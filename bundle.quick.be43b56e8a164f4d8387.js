/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[2].use[1]!./node_modules/postcss-loader/src/index.js??ruleSet[1].rules[2].use[2]!./src/style.css":
/*!****************************************************************************************************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[2].use[1]!./node_modules/postcss-loader/src/index.js??ruleSet[1].rules[2].use[2]!./src/style.css ***!
  \****************************************************************************************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

// Imports
var ___CSS_LOADER_API_IMPORT___ = __webpack_require__(/*! ../node_modules/css-loader/dist/runtime/api.js */ "./node_modules/css-loader/dist/runtime/api.js");
exports = ___CSS_LOADER_API_IMPORT___(false);
exports.push([module.id, "@import url(https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Questrial&family=Poppins:wght@400;500;600&family=Barlow:wght@400;500;600;700&display=swap);"]);
// Module
exports.push([module.id, ":root {\n  --logo-font-family: \"Poppins\", sans-serif;\n  --body-font-family: \"Inter\", sans-serif;\n  --heading-font-family: \"Poppins\", sans-serif;\n  --header-font-family: \"Questrial\", sans-serif;\n\n  /* Slate Blue */\n  --clr-primary-100: #e0e2f4;\n  --clr-primary-200: #bfc3ec;\n  --clr-primary-300: #9fa7e2;\n  --clr-primary-400: #7e89d8;\n  --clr-primary-500: #616acb;\n  --clr-primary-600: #4854bb;\n  --clr-primary-700: #3943a2;\n  --clr-primary-800: #2f3885;\n  --clr-primary-900: #242b67;\n  --clr-primary-950: #191e4d;\n  --clr-primary-975: #0f122e;\n  --clr-primary-999: #05060f;\n\n  /* Mantis */\n  --clr-green-100: #f4fbf0;\n  --clr-green-200: #dff1d2;\n  --clr-green-300: #bfe2a6;\n  --clr-green-400: #a0d57b;\n  --clr-green-500: #8ccc61;\n  --clr-green-600: #6fad45;\n  --clr-green-700: #5b8d38;\n  --clr-green-800: #33571c;\n  --clr-green-900: #1e2f12;\n\n  /* Dandelion */\n  --clr-yellow-100: #fffdf1;\n  --clr-yellow-200: #fdf7db;\n  --clr-yellow-300: #faedb7;\n  --clr-yellow-400: #f7e695;\n  --clr-yellow-500: #f9dc5c;\n  --clr-yellow-600: #e5c343;\n  --clr-yellow-700: #9f8004;\n  --clr-yellow-800: #504102;\n  --clr-yellow-900: #282001;\n\n  /* Tomato */\n  --clr-red-100: #fff5f3;\n  --clr-red-200: #fbded8;\n  --clr-red-300: #f0b5a9;\n  --clr-red-400: #fa927b;\n  --clr-red-500: #fc6948;\n  --clr-red-600: #e9502f;\n  --clr-red-700: #cb3413;\n  --clr-red-800: #a30303;\n  --clr-red-900: #5c1111;\n\n  /* Neutrals */\n  --clr-neutral-0: #ffffff;\n  --clr-neutral-50: #f4f4f6;\n  --clr-neutral-100: #e9e9ec;\n  --clr-neutral-200: #d3d3d9;\n  --clr-neutral-300: #b3b3bc;\n  --clr-neutral-400: #9d9da9;\n  --clr-neutral-450: #868695;\n  --clr-neutral-500: #686877;\n  --clr-neutral-600: #5f5f6c;\n  --clr-neutral-700: #4c4c56;\n  --clr-neutral-800: #393941;\n  --clr-neutral-850: #2c2c33;\n  --clr-neutral-900: #26262c;\n  --clr-neutral-925: #1e1e23;\n  --clr-neutral-950: #131316;\n  --clr-neutral-975: #09090b;\n  --clr-neutral-990: #040405;\n  --clr-neutral-1000: #000000;\n}\n\n.spacer {\n  flex-grow: 1;\n}\n\n/** Margin and Padding helpers */\n.m-t-0 {\n  margin-top: 0px !important;\n}\n.p-t-0 {\n  padding-top: 0px !important;\n}\n.m-b-0 {\n  margin-bottom: 0px !important;\n}\n.p-b-0 {\n  padding-bottom: 0px !important;\n}\n.m-l-0 {\n  margin-left: 0px !important;\n}\n.p-l-0 {\n  padding-left: 0px !important;\n}\n.m-r-0 {\n  margin-right: 0px !important;\n}\n.p-r-0 {\n  padding-right: 0px !important;\n}\n.m-t-4 {\n  margin-top: 4px !important;\n}\n.p-t-4 {\n  padding-top: 4px !important;\n}\n.m-b-4 {\n  margin-bottom: 4px !important;\n}\n.p-b-4 {\n  padding-bottom: 4px !important;\n}\n.m-l-4 {\n  margin-left: 4px !important;\n}\n.p-l-4 {\n  padding-left: 4px !important;\n}\n.m-r-4 {\n  margin-right: 4px !important;\n}\n.p-r-4 {\n  padding-right: 4px !important;\n}\n.m-t-8 {\n  margin-top: 8px !important;\n}\n.p-t-8 {\n  padding-top: 8px !important;\n}\n.m-b-8 {\n  margin-bottom: 8px !important;\n}\n.p-b-8 {\n  padding-bottom: 8px !important;\n}\n.m-l-8 {\n  margin-left: 8px !important;\n}\n.p-l-8 {\n  padding-left: 8px !important;\n}\n.m-r-8 {\n  margin-right: 8px !important;\n}\n.p-r-8 {\n  padding-right: 8px !important;\n}\n.m-t-16 {\n  margin-top: 16px !important;\n}\n.p-t-16 {\n  padding-top: 16px !important;\n}\n.m-b-16 {\n  margin-bottom: 16px !important;\n}\n.p-b-16 {\n  padding-bottom: 16px !important;\n}\n.m-l-16 {\n  margin-left: 16px !important;\n}\n.p-l-16 {\n  padding-left: 16px !important;\n}\n.m-r-16 {\n  margin-right: 16px !important;\n}\n.p-r-16 {\n  padding-right: 16px !important;\n}\n.m-t-24 {\n  margin-top: 24px !important;\n}\n.p-t-24 {\n  padding-top: 24px !important;\n}\n.m-b-24 {\n  margin-bottom: 24px !important;\n}\n.p-b-24 {\n  padding-bottom: 24px !important;\n}\n.m-l-24 {\n  margin-left: 24px !important;\n}\n.p-l-24 {\n  padding-left: 24px !important;\n}\n.m-r-24 {\n  margin-right: 24px !important;\n}\n.p-r-24 {\n  padding-right: 24px !important;\n}\n.m-t-32 {\n  margin-top: 32px !important;\n}\n.p-t-32 {\n  padding-top: 32px !important;\n}\n.m-b-32 {\n  margin-bottom: 32px !important;\n}\n.p-b-32 {\n  padding-bottom: 32px !important;\n}\n.m-l-32 {\n  margin-left: 32px !important;\n}\n.p-l-32 {\n  padding-left: 32px !important;\n}\n.m-r-32 {\n  margin-right: 32px !important;\n}\n.p-r-32 {\n  padding-right: 32px !important;\n}\n.m-t-40 {\n  margin-top: 40px !important;\n}\n.p-t-40 {\n  padding-top: 40px !important;\n}\n.m-b-40 {\n  margin-bottom: 40px !important;\n}\n.p-b-40 {\n  padding-bottom: 40px !important;\n}\n.m-l-40 {\n  margin-left: 40px !important;\n}\n.p-l-40 {\n  padding-left: 40px !important;\n}\n.m-r-40 {\n  margin-right: 40px !important;\n}\n.p-r-40 {\n  padding-right: 40px !important;\n}\n.m-t-48 {\n  margin-top: 48px !important;\n}\n.p-t-48 {\n  padding-top: 48px !important;\n}\n.m-b-48 {\n  margin-bottom: 48px !important;\n}\n.p-b-48 {\n  padding-bottom: 48px !important;\n}\n.m-l-48 {\n  margin-left: 48px !important;\n}\n.p-l-48 {\n  padding-left: 48px !important;\n}\n.m-r-48 {\n  margin-right: 48px !important;\n}\n.p-r-48 {\n  padding-right: 48px !important;\n}\n.m-t-56 {\n  margin-top: 56px !important;\n}\n.p-t-56 {\n  padding-top: 56px !important;\n}\n.m-b-56 {\n  margin-bottom: 56px !important;\n}\n.p-b-56 {\n  padding-bottom: 56px !important;\n}\n.m-l-56 {\n  margin-left: 56px !important;\n}\n.p-l-56 {\n  padding-left: 56px !important;\n}\n.m-r-56 {\n  margin-right: 56px !important;\n}\n.p-r-56 {\n  padding-right: 56px !important;\n}\n.m-t-64 {\n  margin-top: 64px !important;\n}\n.p-t-64 {\n  padding-top: 64px !important;\n}\n.m-b-64 {\n  margin-bottom: 64px !important;\n}\n.p-b-64 {\n  padding-bottom: 64px !important;\n}\n.m-l-64 {\n  margin-left: 64px !important;\n}\n.p-l-64 {\n  padding-left: 64px !important;\n}\n.m-r-64 {\n  margin-right: 64px !important;\n}\n.p-r-64 {\n  padding-right: 64px !important;\n}\n.m-t-72 {\n  margin-top: 72px !important;\n}\n.p-t-72 {\n  padding-top: 72px !important;\n}\n.m-b-72 {\n  margin-bottom: 72px !important;\n}\n.p-b-72 {\n  padding-bottom: 72px !important;\n}\n.m-l-72 {\n  margin-left: 72px !important;\n}\n.p-l-72 {\n  padding-left: 72px !important;\n}\n.m-r-72 {\n  margin-right: 72px !important;\n}\n.p-r-72 {\n  padding-right: 72px !important;\n}\n.m-t-80 {\n  margin-top: 80px !important;\n}\n.p-t-80 {\n  padding-top: 80px !important;\n}\n.m-b-80 {\n  margin-bottom: 80px !important;\n}\n.p-b-80 {\n  padding-bottom: 80px !important;\n}\n.m-l-80 {\n  margin-left: 80px !important;\n}\n.p-l-80 {\n  padding-left: 80px !important;\n}\n.m-r-80 {\n  margin-right: 80px !important;\n}\n.p-r-80 {\n  padding-right: 80px !important;\n}\n.m-t-120 {\n  margin-top: 120px !important;\n}\n.p-t-120 {\n  padding-top: 120px !important;\n}\n.m-b-120 {\n  margin-bottom: 120px !important;\n}\n.p-b-120 {\n  padding-bottom: 120px !important;\n}\n.m-l-120 {\n  margin-left: 120px !important;\n}\n.p-l-120 {\n  padding-left: 120px !important;\n}\n.m-r-120 {\n  margin-right: 120px !important;\n}\n.p-r-120 {\n  padding-right: 120px !important;\n}\n.m-t-160 {\n  margin-top: 160px !important;\n}\n.p-t-160 {\n  padding-top: 160px !important;\n}\n.m-b-160 {\n  margin-bottom: 160px !important;\n}\n.p-b-160 {\n  padding-bottom: 160px !important;\n}\n.m-l-160 {\n  margin-left: 160px !important;\n}\n.p-l-160 {\n  padding-left: 160px !important;\n}\n.m-r-160 {\n  margin-right: 160px !important;\n}\n.p-r-160 {\n  padding-right: 160px !important;\n}\n\n* {\n  margin: 0;\n  padding: 0;\n  box-sizing: border-box;\n}\n\nhtml {\n  background: #131316;\n  scroll-behavior: smooth;\n  color-scheme: dark;\n}\n\nbody {\n  font-family: var(--body-font-family);\n  font-size: 14px;\n  color: var(--clr-neutral-300);\n}\n\nheader {\n  padding: 24px 32px;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  background: #000000;\n  box-shadow: 0px 1px 0px rgba(255, 255, 255, 0.15);\n}\n\n.header-inner {\n  flex: 1;\n  display: flex;\n  align-items: center;\n  max-width: 1100px;\n}\n\n.build-notes {\n  flex: 1;\n  display: flex;\n  justify-content: flex-end;\n  align-items: center;\n}\n\n.build-note {\n  line-height: 1;\n  display: flex;\n  align-items: center;\n  color: var(--clr-neutral-450);\n}\n\n.build-note + .build-note {\n  margin-left: 16px;\n}\n\n.build-note > svg {\n  margin-right: 8px;\n}\n\nh1 {\n  font-family: var(--heading-font-family);\n  font-size: 20px;\n  font-weight: bold;\n  color: var(--clr-neutral-0);\n}\n\nh2 {\n  font-family: var(--heading-font-family);\n  font-size: 16px;\n  font-weight: 600;\n  color: var(--clr-neutral-50);\n}\n\nh3 {\n  font-family: var(--heading-font-family);\n  font-size: 16px;\n  font-weight: 500;\n  color: var(--clr-neutral-100);\n}\n\nbutton {\n  border: none;\n  color: var(--clr-neutral-50);\n  background: linear-gradient(90deg, #616acb 0%, #4854bb 100%);\n  border-radius: 4px;\n  font-family: var(--body-font-family);\n  font-size: 14px;\n  padding: 12px 18px;\n  cursor: pointer;\n}\n\nbutton.secondary {\n  border: 1px solid var(--clr-primary-500);\n  background: transparent;\n}\n\nbutton:disabled {\n  color: var(--clr-neutral-400);\n  background: var(--clr-neutral-850);\n  cursor: inherit;\n}\n\ninput {\n  font-size: 14px;\n}\n\ninput[type=\"text\"] {\n  font-family: var(--body-font-family);\n  background: var(--clr-neutral-950);\n  border: 1px solid var(--clr-neutral-850);\n  border-radius: 5px;\n  padding: 12px 16px;\n}\n\n.badge {\n  display: flex;\n  flex-direction: row;\n  justify-content: center;\n  align-items: center;\n  padding: 4px 8px;\n  font-size: 12px;\n  font-weight: 500;\n  border-radius: 24px;\n  background: var(--clr-neutral-900);\n  color: var(--clr-neutral-300);\n}\n\n.badge.ok {\n  background: var(--clr-primary-900);\n  color: var(--clr-primary-300);\n}\n\n.backdrop {\n  width: 100%;\n  height: 180px;\n  position: absolute;\n  z-index: -5;\n  pointer-events: none;\n  background: #000000;\n}\n\n.demo {\n  padding: 32px;\n  max-width: 1100px;\n  margin: auto;\n}\n\n.flex {\n  display: flex;\n  align-items: center;\n}\n\nsvg {\n  flex-shrink: 0;\n}\n\n.card {\n  background: var(--clr-neutral-925);\n  box-shadow: 0px 8px 50px rgba(0, 0, 0, 0.25);\n  border-radius: 8px;\n  padding: 24px;\n  margin: 24px 0;\n}\n\n.card-top {\n  display: flex;\n  align-items: center;\n  margin-bottom: 8px;\n}\n\n.card-top > * + * {\n  margin-left: 8px;\n}\n\n.widget-body {\n  display: flex;\n}\n\n.stream-column {\n  flex: 2;\n}\n\n.chat-column {\n  flex: 1;\n  display: flex;\n  flex-direction: column;\n}\n\n.chat-history {\n  flex: 1;\n}\n\n.chat-bottom {\n  display: flex;\n  position: relative;\n  align-items: center;\n}\n\n.chat-input {\n  flex: 1;\n}\n\nbutton.chat-send-button {\n  cursor: pointer;\n  background: none;\n  padding: 0;\n  margin: 0;\n  position: absolute;\n  right: 16px;\n  margin-top: auto;\n}\n\nbutton.chat-send-button:disabled {\n  cursor: inherit;\n  filter: grayscale();\n}\n\n.stream-wrapper {\n  border: 1px solid rgba(0, 0, 0, 0.4);\n  background-image: /* url(\"https://rainway.com/images/logo.svg\"), */\n    linear-gradient(-45deg, #141625, #241635);\n  background-repeat: no-repeat;\n  background-position: center;\n  width: 100%;\n  height: 393px;\n}\n\na {\n  color: var(--clr-primary-400);\n  font-weight: 600;\n  text-decoration: none;\n  transition: color 0.2s ease;\n}\n\na:hover {\n  color: var(--clr-neutral-50);\n}\n", ""]);
// Exports
module.exports = exports;


/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/api.js":
/*!*****************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/api.js ***!
  \*****************************************************/
/***/ ((module) => {

"use strict";


/*
  MIT License http://www.opensource.org/licenses/mit-license.php
  Author Tobias Koppers @sokra
*/
// css base code, injected by the css-loader
// eslint-disable-next-line func-names
module.exports = function (useSourceMap) {
  var list = []; // return the list of modules as css string

  list.toString = function toString() {
    return this.map(function (item) {
      var content = cssWithMappingToString(item, useSourceMap);

      if (item[2]) {
        return "@media ".concat(item[2], " {").concat(content, "}");
      }

      return content;
    }).join('');
  }; // import a list of modules into the list
  // eslint-disable-next-line func-names


  list.i = function (modules, mediaQuery, dedupe) {
    if (typeof modules === 'string') {
      // eslint-disable-next-line no-param-reassign
      modules = [[null, modules, '']];
    }

    var alreadyImportedModules = {};

    if (dedupe) {
      for (var i = 0; i < this.length; i++) {
        // eslint-disable-next-line prefer-destructuring
        var id = this[i][0];

        if (id != null) {
          alreadyImportedModules[id] = true;
        }
      }
    }

    for (var _i = 0; _i < modules.length; _i++) {
      var item = [].concat(modules[_i]);

      if (dedupe && alreadyImportedModules[item[0]]) {
        // eslint-disable-next-line no-continue
        continue;
      }

      if (mediaQuery) {
        if (!item[2]) {
          item[2] = mediaQuery;
        } else {
          item[2] = "".concat(mediaQuery, " and ").concat(item[2]);
        }
      }

      list.push(item);
    }
  };

  return list;
};

function cssWithMappingToString(item, useSourceMap) {
  var content = item[1] || ''; // eslint-disable-next-line prefer-destructuring

  var cssMapping = item[3];

  if (!cssMapping) {
    return content;
  }

  if (useSourceMap && typeof btoa === 'function') {
    var sourceMapping = toComment(cssMapping);
    var sourceURLs = cssMapping.sources.map(function (source) {
      return "/*# sourceURL=".concat(cssMapping.sourceRoot || '').concat(source, " */");
    });
    return [content].concat(sourceURLs).concat([sourceMapping]).join('\n');
  }

  return [content].join('\n');
} // Adapted from convert-source-map (MIT)


function toComment(sourceMap) {
  // eslint-disable-next-line no-undef
  var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));
  var data = "sourceMappingURL=data:application/json;charset=utf-8;base64,".concat(base64);
  return "/*# ".concat(data, " */");
}

/***/ }),

/***/ "./node_modules/object-assign/index.js":
/*!*********************************************!*\
  !*** ./node_modules/object-assign/index.js ***!
  \*********************************************/
/***/ ((module) => {

"use strict";
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/


/* eslint-disable no-unused-vars */
var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var hasOwnProperty = Object.prototype.hasOwnProperty;
var propIsEnumerable = Object.prototype.propertyIsEnumerable;

function toObject(val) {
	if (val === null || val === undefined) {
		throw new TypeError('Object.assign cannot be called with null or undefined');
	}

	return Object(val);
}

function shouldUseNative() {
	try {
		if (!Object.assign) {
			return false;
		}

		// Detect buggy property enumeration order in older V8 versions.

		// https://bugs.chromium.org/p/v8/issues/detail?id=4118
		var test1 = new String('abc');  // eslint-disable-line no-new-wrappers
		test1[5] = 'de';
		if (Object.getOwnPropertyNames(test1)[0] === '5') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test2 = {};
		for (var i = 0; i < 10; i++) {
			test2['_' + String.fromCharCode(i)] = i;
		}
		var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
			return test2[n];
		});
		if (order2.join('') !== '0123456789') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test3 = {};
		'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
			test3[letter] = letter;
		});
		if (Object.keys(Object.assign({}, test3)).join('') !==
				'abcdefghijklmnopqrst') {
			return false;
		}

		return true;
	} catch (err) {
		// We don't expect any of the above to throw, but better to be safe.
		return false;
	}
}

module.exports = shouldUseNative() ? Object.assign : function (target, source) {
	var from;
	var to = toObject(target);
	var symbols;

	for (var s = 1; s < arguments.length; s++) {
		from = Object(arguments[s]);

		for (var key in from) {
			if (hasOwnProperty.call(from, key)) {
				to[key] = from[key];
			}
		}

		if (getOwnPropertySymbols) {
			symbols = getOwnPropertySymbols(from);
			for (var i = 0; i < symbols.length; i++) {
				if (propIsEnumerable.call(from, symbols[i])) {
					to[symbols[i]] = from[symbols[i]];
				}
			}
		}
	}

	return to;
};


/***/ }),

/***/ "./node_modules/rainway-sdk/dist/index.js":
/*!************************************************!*\
  !*** ./node_modules/rainway-sdk/dist/index.js ***!
  \************************************************/
/***/ ((module) => {

!function(A,I){ true?module.exports=I():0}(self,(function(){return(()=>{var A={120:(A,I,g)=>{"use strict";Object.defineProperty(I,"__esModule",{value:!0}),I.BebopView=I.BebopRuntimeError=void 0;const e="0123456789abcdef",B=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,2,3,4,5,6,7,8,9,0,0,0,0,0,0,0,10,11,12,13,14,15,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,10,11,12,13,14,15,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],i=new Uint8Array(0),Q=[];for(const A of e)for(const I of e)Q.push(A+I);"undefined"==typeof TextDecoder&&(g.g.TextDecoder=g(700).TextDecoder);class t extends Error{constructor(A){super(A),this.name="BebopRuntimeError"}}I.BebopRuntimeError=t;class C{static textDecoder=new TextDecoder;static writeBuffer=new Uint8Array(256);static writeBufferView=new DataView(C.writeBuffer.buffer);static instance;static getInstance(){return C.instance||(C.instance=new C),C.instance}minimumTextDecoderLength=300;buffer;view;index;length;constructor(){this.buffer=C.writeBuffer,this.view=C.writeBufferView,this.index=0,this.length=0}startReading(A){this.buffer=A,this.view=new DataView(this.buffer.buffer,this.buffer.byteOffset,this.buffer.byteLength),this.index=0,this.length=A.length}startWriting(){this.buffer=C.writeBuffer,this.view=C.writeBufferView,this.index=0,this.length=0}guaranteeBufferLength(A){if(A>this.buffer.length){const I=new Uint8Array(A<<1);I.set(this.buffer),this.buffer=I,this.view=new DataView(I.buffer)}}growBy(A){this.length+=A,this.guaranteeBufferLength(this.length)}skip(A){this.index+=A}toArray(){return this.buffer.subarray(0,this.length)}readByte(){return this.buffer[this.index++]}readUint16(){const A=this.view.getUint16(this.index,!0);return this.index+=2,A}readInt16(){const A=this.view.getInt16(this.index,!0);return this.index+=2,A}readUint32(){const A=this.view.getUint32(this.index,!0);return this.index+=4,A}readInt32(){const A=this.view.getInt32(this.index,!0);return this.index+=4,A}readUint64(){const A=this.view.getBigUint64(this.index,!0);return this.index+=8,A}readInt64(){const A=this.view.getBigInt64(this.index,!0);return this.index+=8,A}readFloat32(){const A=this.view.getFloat32(this.index,!0);return this.index+=4,A}readFloat64(){const A=this.view.getFloat64(this.index,!0);return this.index+=8,A}writeByte(A){const I=this.length;this.growBy(1),this.buffer[I]=A}writeUint16(A){const I=this.length;this.growBy(2),this.view.setUint16(I,A,!0)}writeInt16(A){const I=this.length;this.growBy(2),this.view.setInt16(I,A,!0)}writeUint32(A){const I=this.length;this.growBy(4),this.view.setUint32(I,A,!0)}writeInt32(A){const I=this.length;this.growBy(4),this.view.setInt32(I,A,!0)}writeUint64(A){const I=this.length;this.growBy(8),this.view.setBigUint64(I,A,!0)}writeInt64(A){const I=this.length;this.growBy(8),this.view.setBigInt64(I,A,!0)}writeFloat32(A){const I=this.length;this.growBy(4),this.view.setFloat32(I,A,!0)}writeFloat64(A){const I=this.length;this.growBy(8),this.view.setFloat64(I,A,!0)}readBytes(){const A=this.readUint32();if(0===A)return i;const I=this.index,g=I+A;return this.index=g,this.buffer.subarray(I,g)}writeBytes(A){const I=A.length;if(this.writeUint32(I),0===I)return;const g=this.length;this.growBy(I),this.buffer.set(A,g)}readString(){const A=this.readUint32();if(0===A)return"";if(A>=this.minimumTextDecoderLength)return C.textDecoder.decode(this.buffer.subarray(this.index,this.index+=A));const I=this.index+A;let g,e="";for(;this.index<I;){const A=this.buffer[this.index++];if(A<192)g=A;else{const I=this.buffer[this.index++];if(A<224)g=(31&A)<<6|63&I;else{const e=this.buffer[this.index++];g=A<240?(15&A)<<12|(63&I)<<6|63&e:(7&A)<<18|(63&I)<<12|(63&e)<<6|63&this.buffer[this.index++]}}g<65536?e+=String.fromCharCode(g):(g-=65536,e+=String.fromCharCode(55296+(g>>10),56320+(1023&g)))}return this.index=I,e}writeString(A){const I=A.length;if(0===I)return void this.writeUint32(0);const g=4+3*I;this.guaranteeBufferLength(this.length+g);let e=this.length+4;const B=e;let i;for(let g=0;g<I;g++){const B=A.charCodeAt(g);i=g+1===I||B<55296||B>=56320?B:(B<<10)+A.charCodeAt(++g)+-56613888,i<128?this.buffer[e++]=i:(i<2048?this.buffer[e++]=i>>6&31|192:(i<65536?this.buffer[e++]=i>>12&15|224:(this.buffer[e++]=i>>18&7|240,this.buffer[e++]=i>>12&63|128),this.buffer[e++]=i>>6&63|128),this.buffer[e++]=63&i|128)}const Q=e-B;this.view.setUint32(this.length,Q,!0),this.length+=4+Q}readGuid(){const A=Q,I=this.buffer,g=this.index,e="-";var B=A[I[g+3]];return B+=A[I[g+2]],B+=A[I[g+1]],B+=A[I[g]],B+=e,B+=A[I[g+5]],B+=A[I[g+4]],B+=e,B+=A[I[g+7]],B+=A[I[g+6]],B+=e,B+=A[I[g+8]],B+=A[I[g+9]],B+=e,B+=A[I[g+10]],B+=A[I[g+11]],B+=A[I[g+12]],B+=A[I[g+13]],B+=A[I[g+14]],B+=A[I[g+15]],this.index+=16,B}writeGuid(A){const I=this.view,g=this.length;this.growBy(16);var e=0,i=0;i=(i=(i=(i=(i=(i=(i=(i=i<<4|B[A.charCodeAt(e++)])<<4|B[A.charCodeAt(e++)])<<4|B[A.charCodeAt(e++)])<<4|B[A.charCodeAt(e++)])<<4|B[A.charCodeAt(e++)])<<4|B[A.charCodeAt(e++)])<<4|B[A.charCodeAt(e++)])<<4|B[A.charCodeAt(e++)],e+=45===A.charCodeAt(e),I.setUint32(g,i,!0),i=(i=(i=(i=i<<4|B[A.charCodeAt(e++)])<<4|B[A.charCodeAt(e++)])<<4|B[A.charCodeAt(e++)])<<4|B[A.charCodeAt(e++)],e+=45===A.charCodeAt(e),I.setUint16(g+4,i,!0),i=(i=(i=(i=i<<4|B[A.charCodeAt(e++)])<<4|B[A.charCodeAt(e++)])<<4|B[A.charCodeAt(e++)])<<4|B[A.charCodeAt(e++)],e+=45===A.charCodeAt(e),I.setUint16(g+6,i,!0),i=(i=(i=(i=i<<4|B[A.charCodeAt(e++)])<<4|B[A.charCodeAt(e++)])<<4|B[A.charCodeAt(e++)])<<4|B[A.charCodeAt(e++)],e+=45===A.charCodeAt(e),i=(i=(i=(i=i<<4|B[A.charCodeAt(e++)])<<4|B[A.charCodeAt(e++)])<<4|B[A.charCodeAt(e++)])<<4|B[A.charCodeAt(e++)],I.setUint32(g+8,i,!1),i=(i=(i=(i=(i=(i=(i=(i=i<<4|B[A.charCodeAt(e++)])<<4|B[A.charCodeAt(e++)])<<4|B[A.charCodeAt(e++)])<<4|B[A.charCodeAt(e++)])<<4|B[A.charCodeAt(e++)])<<4|B[A.charCodeAt(e++)])<<4|B[A.charCodeAt(e++)])<<4|B[A.charCodeAt(e++)],I.setUint32(g+12,i,!1)}readDate(){const A=this.readUint32(),I=1073741823&this.readUint32();return new Date(429496.7296*I+1e-4*A-621355968e5)}writeDate(A){const I=A.getTime()+621355968e5,g=I%429496.7296*1e4|0,e=I/429496.7296|1073741824;this.writeUint32(g),this.writeUint32(e)}reserveMessageLength(){const A=this.length;return this.growBy(4),A}fillMessageLength(A,I){this.view.setUint32(A,I,!0)}readMessageLength(){const A=this.view.getUint32(this.index,!0);return this.index+=4,A}}I.BebopView=C},290:function(A,I,g){"use strict";var e=this&&this.__awaiter||function(A,I,g,e){return new(g||(g=Promise))((function(B,i){function Q(A){try{C(e.next(A))}catch(A){i(A)}}function t(A){try{C(e.throw(A))}catch(A){i(A)}}function C(A){var I;A.done?B(A.value):(I=A.value,I instanceof g?I:new g((function(A){A(I)}))).then(Q,t)}C((e=e.apply(A,I||[])).next())}))};Object.defineProperty(I,"__esModule",{value:!0}),I.fetchNewPeerId=I.getOrganizationInfo=void 0;const B=g(464),i=g(994),Q="https://api.rainway.network/v1";I.getOrganizationInfo=function(A){return e(this,void 0,void 0,(function*(){try{const I=yield fetch(Q+"/keys/validate",{headers:{Authorization:`Bearer ${A}`}}),g=yield I.json();return{universeFlag:g.universe,organizationId:g.org_id}}catch(A){throw B.RainwayLogging.error(String(A)),new i.RainwayError("The Rainway API key is invalid.")}}))},I.fetchNewPeerId=function(){return e(this,void 0,void 0,(function*(){const A=yield fetch(Q+"/druid/next");return BigInt(yield A.text())}))}},434:(A,I)=>{"use strict";var g,e;Object.defineProperty(I,"__esModule",{value:!0}),I.AudioReadyState=I.VideoReadyState=void 0,(e=I.VideoReadyState||(I.VideoReadyState={}))[e.Detached=0]="Detached",e[e.Initializing=1]="Initializing",e[e.WaitingForKeyframe=2]="WaitingForKeyframe",e[e.Playing=3]="Playing",e[e.Paused=4]="Paused",e[e.Disposed=5]="Disposed",(g=I.AudioReadyState||(I.AudioReadyState={}))[g.Detached=0]="Detached",g[g.Uninitialized=1]="Uninitialized",g[g.Initializing=2]="Initializing",g[g.Playing=3]="Playing",g[g.Paused=4]="Paused"},528:(A,I)=>{"use strict";Object.defineProperty(I,"__esModule",{value:!0}),I.isDesktopSafari=void 0,I.isDesktopSafari=/Macintosh;.*Safari/.test(navigator.userAgent)&&!/Chrome|Android/i.test(navigator.userAgent)},987:(A,I)=>{"use strict";Object.defineProperty(I,"__esModule",{value:!0}),I.reassemble=I.eachChunk=void 0;let g=0;I.eachChunk=function(A,I,e=16e3){const B=Math.ceil(A.length/e),i=++g;for(let g=0;g<B;g++){const Q=g*e,t=Math.min((g+1)*e,A.length);I({chunksInGroup:B,groupId:i,index:g,data:A.slice(Q,t)})}},I.reassemble=function(A){let I=0;const g=A.chunks.length;for(let e=0;e<g;e++)I+=A.chunks[e].byteLength;const e=new Uint8Array(I);let B=0;for(let I=0;I<g;I++){const g=A.chunks[I];e.set(g,B),B+=g.byteLength}return e}},24:(A,I)=>{"use strict";Object.defineProperty(I,"__esModule",{value:!0}),I.Action=void 0,I.Action=class{constructor(){this.handlers=[]}addHandler(A){this.handlers.push(A)}removeHandler(A){this.handlers=this.handlers.filter((I=>I!==A))}invoke(A){for(let I=0;I<this.handlers.length;I++)this.handlers[I](A)}}},930:(A,I)=>{"use strict";Object.defineProperty(I,"__esModule",{value:!0}),I.boundingRectangle=void 0,I.boundingRectangle=function(A){const I=A.length;if(0===I)throw new Error("boundingRectangle() of 0 rectangles");const g=A[0];let{left:e,top:B}=g,i=e+g.width,Q=B+g.height;for(let g=1;g<I;g++){const I=A[g];e=Math.min(e,I.left),B=Math.min(B,I.top),i=Math.max(i,I.left+I.width),Q=Math.max(Q,I.top+I.height)}return{left:e,top:B,width:i-e,height:Q-B}}},198:(A,I)=>{"use strict";function g(A){if(0===A.length)return NaN;let I=0;for(const g of A)I+=g;return I/A.length}Object.defineProperty(I,"__esModule",{value:!0}),I.meanOrZero=I.mean=I.standardDeviation=I.interquartileRange=I.median=I.WindowTrack=void 0,I.WindowTrack=class{constructor(A,I){this.sizeMs=A,this.averageOperation=I,this.cachedAverage=void 0,this.buffer=[]}get values(){return this.trim(),this.buffer.map((A=>A.value))}get measurements(){return this.trim(),this.buffer}trim(){const A=performance.now(),I=this.buffer.findIndex((I=>I.time>A-this.sizeMs));I>0?(this.buffer.splice(0,I),this.cachedAverage=void 0):-1===I&&(this.buffer.splice(0,this.buffer.length),this.cachedAverage=void 0)}feed(A){const I=performance.now();this.buffer.push({time:I,value:A}),this.buffer.length>=500&&this.trim(),this.cachedAverage=void 0}average(){if(this.trim(),this.cachedAverage)return this.cachedAverage;const A=this.buffer.map((A=>A.value));return this.cachedAverage=this.averageOperation(A)}},I.median=function(A){return 0===A.length?NaN:(A.sort(((A,I)=>A-I)),A[Math.floor(A.length/2)])},I.interquartileRange=function(A){if(0===A.length)return NaN;A.sort(((A,I)=>A-I));const I=Math.floor(.25*A.length);return A[Math.floor(.75*A.length)]-A[I]},I.standardDeviation=function(A){if(0===A.length)return NaN;const I=A.length,g=A.reduce(((A,I)=>A+I),0)/I;return Math.sqrt(A.map((A=>Math.pow(A-g,2))).reduce(((A,I)=>A+I),0)/I)},I.mean=g,I.meanOrZero=function(A){return 0===A.length?0:g(A)}},904:function(A,I,g){"use strict";var e=this&&this.__createBinding||(Object.create?function(A,I,g,e){void 0===e&&(e=g),Object.defineProperty(A,e,{enumerable:!0,get:function(){return I[g]}})}:function(A,I,g,e){void 0===e&&(e=g),A[e]=I[g]}),B=this&&this.__exportStar||function(A,I){for(var g in A)"default"===g||Object.prototype.hasOwnProperty.call(I,g)||e(I,A,g)};Object.defineProperty(I,"__esModule",{value:!0}),B(g(162),I)},162:(A,I,g)=>{"use strict";Object.defineProperty(I,"__esModule",{value:!0}),I.WindowsPointerFlags=I.VirtualKey=I.KeyboardAction=I.ScrollAxis=I.MouseButton=I.ButtonAction=I.XInputButtons=I.ArbitraryDatagram=I.MediaDatagram=I.LogicDatagram=I.InputDatagram=I.Chunk=I.RainwayHeader=I.Guid=I.TelemetryValueType=I.RainwayTelemetryDimension=I.RainwayTelemetryRecord=I.RainwayTelemetryRequest=I.TelemetryBatchesKeyTemplate=I.TelemetrySetKey=I.GatewayForwardableBody=I.PeerSignalingInformation=I.RejectedConnectionRequest=I.AcceptedConnectionRequest=I.ConnectionRequest=I.GatewayResponseBody=I.GatewayHello=I.GatewayRequestBody=I.InitConnectionRequest=I.GatewayBody=I.GatewayForwardable=I.GatewayAlert=I.GatewayResponse=I.GatewayRequest=I.GatewayDatagram=I.GatewayHeader=I.PendingConnectionRequest=I.Peer=I.GatewayIdentity=I.GatewayTrunk=I.PeerInformationType=I.PeerTransportType=I.GatewayAlertDescription=I.GatewayAlertLevel=I.GatewayResponseContext=I.PeerSetKeyTemplate=I.AcceptedConnectionRequestKeyTemplate=I.PendingConnectionRequestKeyTemplate=I.PeerKeyTemplate=I.DatagramChannel=void 0,I.LogicBody=I.InputLevelRequest=I.InputLevelUpdate=I.RejectStreamRequest=I.PauseStream=I.JoinStream=I.VideoBitrateRequest=I.KeyframeRequest=I.StreamStopping=I.LeaveStream=I.StreamStarting=I.StreamRequest=I.ErrorResponse=I.ClientCapabilities=I.CodecPackResponse=I.CodecPackRequest=I.DeviceInfo=I.InputLevel=I.VideoConfig=I.CaptureMode=I.AudioConfig=I.LogicError=I.VideoContainer=I.AudioContainer=I.AudioCodec=I.AudioChannels=I.NetworkProtocol=I.OperatingSystem=I.FormFactor=I.VideoCodec=I.Vendor=I.VideoCodecType=I.InputBody=I.SetClipboardText=I.ViewportResize=I.PenAbsolute=I.TouchesAbsolute=I.LogicalInput=I.KeyboardInput=I.MouseScroll=I.MouseClick=I.MouseRelative=I.MouseAbsolute=I.GamepadRumble=I.GamepadReport=I.TouchAbsolute=I.PenFlags=I.PenMask=I.TouchMask=I.TouchPenPointerInfo=void 0,I.MediaBody=I.MediaChunk=I.AudioData=I.PointerData=I.VideoData=I.DesktopRect=I.AudioDataType=I.VideoDataType=void 0;const e=g(120);var B,i,Q,t,C,E,o,a,n,s,r,d,h,c,D,w,y,u,l,S,F,R,G,k,U,N,m,p,f;I.DatagramChannel="network:datagrams",I.PeerKeyTemplate="network:peers:{0}",I.PendingConnectionRequestKeyTemplate="network:connection.requests:pending:{0}",I.AcceptedConnectionRequestKeyTemplate="network:connection.requests:accepted:{0}",I.PeerSetKeyTemplate="network:active.peers:{0}",I.GatewayResponseContext={encode(A){const I=e.BebopView.getInstance();return I.startWriting(),this.encodeInto(A,I),I.toArray()},encodeInto(A,g){const e=g.length;return g.writeInt64(A.sourcePeerId),g.writeInt64(A.targetPeerId),I.GatewayDatagram.encodeInto(A.datagram,g),g.length-e},decode(A){const I=e.BebopView.getInstance();return I.startReading(A),this.readFrom(I)},readFrom(A){let g,e,B;return g=A.readInt64(),e=A.readInt64(),B=I.GatewayDatagram.readFrom(A),{sourcePeerId:g,targetPeerId:e,datagram:B}}},(f=I.GatewayAlertLevel||(I.GatewayAlertLevel={}))[f.Unknown=0]="Unknown",f[f.Warning=1]="Warning",f[f.Fatal=2]="Fatal",(p=I.GatewayAlertDescription||(I.GatewayAlertDescription={}))[p.CloseNotify=0]="CloseNotify",p[p.UnexpectedMessage=10]="UnexpectedMessage",p[p.RecordOverflow=20]="RecordOverflow",p[p.TicketValidationError=30]="TicketValidationError",p[p.AccessDenied=49]="AccessDenied",p[p.DecodeError=50]="DecodeError",p[p.DecryptError=51]="DecryptError",p[p.ProtocolVersion=70]="ProtocolVersion",p[p.InternalError=80]="InternalError",p[p.PeerGoneAway=90]="PeerGoneAway",p[p.CommitFailure=100]="CommitFailure",p[p.ResourceExpired=200]="ResourceExpired",(m=I.PeerTransportType||(I.PeerTransportType={}))[m.Invalid=0]="Invalid",m[m.SCTP=1]="SCTP",m[m.GUDP=2]="GUDP",m[m.Reserved=3]="Reserved",(N=I.PeerInformationType||(I.PeerInformationType={}))[N.Invalid=0]="Invalid",N[N.Offer=1]="Offer",N[N.Answer=2]="Answer",N[N.Candidate=3]="Candidate",I.GatewayTrunk={encode(A){const I=e.BebopView.getInstance();return I.startWriting(),this.encodeInto(A,I),I.toArray()},encodeInto(A,I){const g=I.length;return I.writeString(A.machineId),I.writeDate(A.startDate),I.length-g},decode(A){const I=e.BebopView.getInstance();return I.startReading(A),this.readFrom(I)},readFrom(A){let I,g;return I=A.readString(),g=A.readDate(),{machineId:I,startDate:g}}},I.GatewayIdentity={encode(A){const I=e.BebopView.getInstance();return I.startWriting(),this.encodeInto(A,I),I.toArray()},encodeInto(A,I){const g=I.length;return I.writeString(A.apiKey),I.writeInt64(A.id),I.writeString(A.externalId),I.length-g},decode(A){const I=e.BebopView.getInstance();return I.startReading(A),this.readFrom(I)},readFrom(A){let I,g,e;return I=A.readString(),g=A.readInt64(),e=A.readString(),{apiKey:I,id:g,externalId:e}}},I.Peer={encode(A){const I=e.BebopView.getInstance();return I.startWriting(),this.encodeInto(A,I),I.toArray()},encodeInto(A,I){const g=I.length;return I.writeInt64(A.id),I.writeString(A.externalId),I.writeDate(A.connectionDate),I.writeInt64(A.organizationId),I.length-g},decode(A){const I=e.BebopView.getInstance();return I.startReading(A),this.readFrom(I)},readFrom(A){let I,g,e,B;return I=A.readInt64(),g=A.readString(),e=A.readDate(),B=A.readInt64(),{id:I,externalId:g,connectionDate:e,organizationId:B}}},I.PendingConnectionRequest={encode(A){const I=e.BebopView.getInstance();return I.startWriting(),this.encodeInto(A,I),I.toArray()},encodeInto(A,I){const g=I.length;return I.writeInt64(A.sourcePeerId),I.writeInt64(A.targetPeerId),I.length-g},decode(A){const I=e.BebopView.getInstance();return I.startReading(A),this.readFrom(I)},readFrom(A){let I,g;return I=A.readInt64(),g=A.readInt64(),{sourcePeerId:I,targetPeerId:g}}},I.GatewayHeader={encode(A){const I=e.BebopView.getInstance();return I.startWriting(),this.encodeInto(A,I),I.toArray()},encodeInto(A,I){const g=I.length;return I.writeUint32(A.syncKey),I.length-g},decode(A){const I=e.BebopView.getInstance();return I.startReading(A),this.readFrom(I)},readFrom(A){let I;return I=A.readUint32(),{syncKey:I}}},I.GatewayDatagram={encode(A){const I=e.BebopView.getInstance();return I.startWriting(),this.encodeInto(A,I),I.toArray()},encodeInto(A,g){const e=g.length;return I.GatewayHeader.encodeInto(A.header,g),I.GatewayBody.encodeInto(A.body,g),g.length-e},decode(A){const I=e.BebopView.getInstance();return I.startReading(A),this.readFrom(I)},readFrom(A){let g,e;return g=I.GatewayHeader.readFrom(A),e=I.GatewayBody.readFrom(A),{header:g,body:e}}},I.GatewayRequest={discriminator:1,encode(A){const I=e.BebopView.getInstance();return I.startWriting(),this.encodeInto(A,I),I.toArray()},encodeInto(A,g){const e=g.length;return I.GatewayRequestBody.encodeInto(A.body,g),g.length-e},decode(A){const I=e.BebopView.getInstance();return I.startReading(A),this.readFrom(I)},readFrom(A){let g;return g=I.GatewayRequestBody.readFrom(A),{body:g}}},I.GatewayResponse={discriminator:2,encode(A){const I=e.BebopView.getInstance();return I.startWriting(),this.encodeInto(A,I),I.toArray()},encodeInto(A,g){const e=g.length;return I.GatewayResponseBody.encodeInto(A.body,g),g.length-e},decode(A){const I=e.BebopView.getInstance();return I.startReading(A),this.readFrom(I)},readFrom(A){let g;return g=I.GatewayResponseBody.readFrom(A),{body:g}}},I.GatewayAlert={discriminator:3,encode(A){const I=e.BebopView.getInstance();return I.startWriting(),this.encodeInto(A,I),I.toArray()},encodeInto(A,I){const g=I.length;return I.writeUint32(A.level),I.writeUint32(A.description),I.length-g},decode(A){const I=e.BebopView.getInstance();return I.startReading(A),this.readFrom(I)},readFrom(A){let I,g;return I=A.readUint32(),g=A.readUint32(),{level:I,description:g}}},I.GatewayForwardable={discriminator:4,encode(A){const I=e.BebopView.getInstance();return I.startWriting(),this.encodeInto(A,I),I.toArray()},encodeInto(A,g){const e=g.length;return g.writeInt64(A.targetPeerId),I.GatewayForwardableBody.encodeInto(A.body,g),g.length-e},decode(A){const I=e.BebopView.getInstance();return I.startReading(A),this.readFrom(I)},readFrom(A){let g,e;return g=A.readInt64(),e=I.GatewayForwardableBody.readFrom(A),{targetPeerId:g,body:e}}},I.GatewayBody={encode(A){const I=e.BebopView.getInstance();return I.startWriting(),this.encodeInto(A,I),I.toArray()},encodeInto(A,g){const e=g.length,B=g.reserveMessageLength(),i=g.length+1;switch(g.writeByte(A.discriminator),A.discriminator){case 1:I.GatewayRequest.encodeInto(A.value,g);break;case 2:I.GatewayResponse.encodeInto(A.value,g);break;case 3:I.GatewayAlert.encodeInto(A.value,g);break;case 4:I.GatewayForwardable.encodeInto(A.value,g)}const Q=g.length;return g.fillMessageLength(B,Q-i),g.length-e},decode(A){const I=e.BebopView.getInstance();return I.startReading(A),this.readFrom(I)},readFrom(A){const g=A.readMessageLength(),B=A.index+1+g;switch(A.readByte()){case 1:return{discriminator:1,value:I.GatewayRequest.readFrom(A)};case 2:return{discriminator:2,value:I.GatewayResponse.readFrom(A)};case 3:return{discriminator:3,value:I.GatewayAlert.readFrom(A)};case 4:return{discriminator:4,value:I.GatewayForwardable.readFrom(A)};default:throw A.index=B,new e.BebopRuntimeError("Unrecognized discriminator while decoding GatewayBody")}}},I.InitConnectionRequest={discriminator:1,encode(A){const I=e.BebopView.getInstance();return I.startWriting(),this.encodeInto(A,I),I.toArray()},encodeInto(A,I){const g=I.length;return I.writeInt64(A.targetPeerId),I.writeUint32(A.desiredTransport),I.length-g},decode(A){const I=e.BebopView.getInstance();return I.startReading(A),this.readFrom(I)},readFrom(A){let I,g;return I=A.readInt64(),g=A.readUint32(),{targetPeerId:I,desiredTransport:g}}},I.GatewayRequestBody={encode(A){const I=e.BebopView.getInstance();return I.startWriting(),this.encodeInto(A,I),I.toArray()},encodeInto(A,g){const e=g.length,B=g.reserveMessageLength(),i=g.length+1;g.writeByte(A.discriminator),1===A.discriminator&&I.InitConnectionRequest.encodeInto(A.value,g);const Q=g.length;return g.fillMessageLength(B,Q-i),g.length-e},decode(A){const I=e.BebopView.getInstance();return I.startReading(A),this.readFrom(I)},readFrom(A){const g=A.readMessageLength(),B=A.index+1+g;if(1===A.readByte())return{discriminator:1,value:I.InitConnectionRequest.readFrom(A)};throw A.index=B,new e.BebopRuntimeError("Unrecognized discriminator while decoding GatewayRequestBody")}},I.GatewayHello={discriminator:1,encode(A){const I=e.BebopView.getInstance();return I.startWriting(),this.encodeInto(A,I),I.toArray()},encodeInto(A,I){const g=I.length;return I.length-g},decode(A){const I=e.BebopView.getInstance();return I.startReading(A),this.readFrom(I)},readFrom:A=>({})},I.GatewayResponseBody={encode(A){const I=e.BebopView.getInstance();return I.startWriting(),this.encodeInto(A,I),I.toArray()},encodeInto(A,g){const e=g.length,B=g.reserveMessageLength(),i=g.length+1;g.writeByte(A.discriminator),1===A.discriminator&&I.GatewayHello.encodeInto(A.value,g);const Q=g.length;return g.fillMessageLength(B,Q-i),g.length-e},decode(A){const I=e.BebopView.getInstance();return I.startReading(A),this.readFrom(I)},readFrom(A){const g=A.readMessageLength(),B=A.index+1+g;if(1===A.readByte())return{discriminator:1,value:I.GatewayHello.readFrom(A)};throw A.index=B,new e.BebopRuntimeError("Unrecognized discriminator while decoding GatewayResponseBody")}},I.ConnectionRequest={discriminator:1,encode(A){const I=e.BebopView.getInstance();return I.startWriting(),this.encodeInto(A,I),I.toArray()},encodeInto(A,I){const g=I.length;return I.writeInt64(A.sourcePeerId),I.writeString(A.sourceExternalId),I.writeUint32(A.desiredTransport),I.writeGuid(A.id),I.writeDate(A.expirationDate),I.length-g},decode(A){const I=e.BebopView.getInstance();return I.startReading(A),this.readFrom(I)},readFrom(A){let I,g,e,B,i;return I=A.readInt64(),g=A.readString(),e=A.readUint32(),B=A.readGuid(),i=A.readDate(),{sourcePeerId:I,sourceExternalId:g,desiredTransport:e,id:B,expirationDate:i}}},I.AcceptedConnectionRequest={discriminator:2,encode(A){const I=e.BebopView.getInstance();return I.startWriting(),this.encodeInto(A,I),I.toArray()},encodeInto(A,I){const g=I.length;return I.writeInt64(A.sourcePeerId),I.writeString(A.sourceExternalId),I.writeGuid(A.id),I.length-g},decode(A){const I=e.BebopView.getInstance();return I.startReading(A),this.readFrom(I)},readFrom(A){let I,g,e;return I=A.readInt64(),g=A.readString(),e=A.readGuid(),{sourcePeerId:I,sourceExternalId:g,id:e}}},I.RejectedConnectionRequest={discriminator:3,encode(A){const I=e.BebopView.getInstance();return I.startWriting(),this.encodeInto(A,I),I.toArray()},encodeInto(A,I){const g=I.length;return I.writeInt64(A.sourcePeerId),I.writeString(A.sourceExternalId),I.writeGuid(A.id),I.writeString(A.reason),I.length-g},decode(A){const I=e.BebopView.getInstance();return I.startReading(A),this.readFrom(I)},readFrom(A){let I,g,e,B;return I=A.readInt64(),g=A.readString(),e=A.readGuid(),B=A.readString(),{sourcePeerId:I,sourceExternalId:g,id:e,reason:B}}},I.PeerSignalingInformation={discriminator:4,encode(A){const I=e.BebopView.getInstance();return I.startWriting(),this.encodeInto(A,I),I.toArray()},encodeInto(A,I){const g=I.length;return I.writeGuid(A.id),I.writeUint32(A.type),I.writeString(A.data),I.length-g},decode(A){const I=e.BebopView.getInstance();return I.startReading(A),this.readFrom(I)},readFrom(A){let I,g,e;return I=A.readGuid(),g=A.readUint32(),e=A.readString(),{id:I,type:g,data:e}}},I.GatewayForwardableBody={encode(A){const I=e.BebopView.getInstance();return I.startWriting(),this.encodeInto(A,I),I.toArray()},encodeInto(A,g){const e=g.length,B=g.reserveMessageLength(),i=g.length+1;switch(g.writeByte(A.discriminator),A.discriminator){case 1:I.ConnectionRequest.encodeInto(A.value,g);break;case 2:I.AcceptedConnectionRequest.encodeInto(A.value,g);break;case 3:I.RejectedConnectionRequest.encodeInto(A.value,g);break;case 4:I.PeerSignalingInformation.encodeInto(A.value,g)}const Q=g.length;return g.fillMessageLength(B,Q-i),g.length-e},decode(A){const I=e.BebopView.getInstance();return I.startReading(A),this.readFrom(I)},readFrom(A){const g=A.readMessageLength(),B=A.index+1+g;switch(A.readByte()){case 1:return{discriminator:1,value:I.ConnectionRequest.readFrom(A)};case 2:return{discriminator:2,value:I.AcceptedConnectionRequest.readFrom(A)};case 3:return{discriminator:3,value:I.RejectedConnectionRequest.readFrom(A)};case 4:return{discriminator:4,value:I.PeerSignalingInformation.readFrom(A)};default:throw A.index=B,new e.BebopRuntimeError("Unrecognized discriminator while decoding GatewayForwardableBody")}}},I.TelemetrySetKey="network:telemetry:batches",I.TelemetryBatchesKeyTemplate="network:telemetry:batches:{0}",I.RainwayTelemetryRequest={encode(A){const I=e.BebopView.getInstance();return I.startWriting(),this.encodeInto(A,I),I.toArray()},encodeInto(A,g){const e=g.length,B=g.reserveMessageLength(),i=g.length;if(null!=A.records){g.writeByte(1);{const e=A.records.length;g.writeUint32(e);for(let B=0;B<e;B++)I.RainwayTelemetryRecord.encodeInto(A.records[B],g)}}null!=A.commonAttributes&&(g.writeByte(2),I.RainwayTelemetryRecord.encodeInto(A.commonAttributes,g)),g.writeByte(0);const Q=g.length;return g.fillMessageLength(B,Q-i),g.length-e},decode(A){const I=e.BebopView.getInstance();return I.startReading(A),this.readFrom(I)},readFrom(A){let g={};const e=A.readMessageLength(),B=A.index+e;for(;;)switch(A.readByte()){case 0:return g;case 1:{let e=A.readUint32();g.records=new Array(e);for(let B=0;B<e;B++){let e;e=I.RainwayTelemetryRecord.readFrom(A),g.records[B]=e}}break;case 2:g.commonAttributes=I.RainwayTelemetryRecord.readFrom(A);break;default:return A.index=B,g}}},I.RainwayTelemetryRecord={encode(A){const I=e.BebopView.getInstance();return I.startWriting(),this.encodeInto(A,I),I.toArray()},encodeInto(A,g){const e=g.length,B=g.reserveMessageLength(),i=g.length;if(null!=A.name&&(g.writeByte(1),g.writeString(A.name)),null!=A.value&&(g.writeByte(2),g.writeString(A.value)),null!=A.time&&(g.writeByte(3),g.writeDate(A.time)),null!=A.type&&(g.writeByte(4),g.writeUint32(A.type)),null!=A.dimensions){g.writeByte(5);{const e=A.dimensions.length;g.writeUint32(e);for(let B=0;B<e;B++)I.RainwayTelemetryDimension.encodeInto(A.dimensions[B],g)}}g.writeByte(0);const Q=g.length;return g.fillMessageLength(B,Q-i),g.length-e},decode(A){const I=e.BebopView.getInstance();return I.startReading(A),this.readFrom(I)},readFrom(A){let g={};const e=A.readMessageLength(),B=A.index+e;for(;;)switch(A.readByte()){case 0:return g;case 1:g.name=A.readString();break;case 2:g.value=A.readString();break;case 3:g.time=A.readDate();break;case 4:g.type=A.readUint32();break;case 5:{let e=A.readUint32();g.dimensions=new Array(e);for(let B=0;B<e;B++){let e;e=I.RainwayTelemetryDimension.readFrom(A),g.dimensions[B]=e}}break;default:return A.index=B,g}}},I.RainwayTelemetryDimension={encode(A){const I=e.BebopView.getInstance();return I.startWriting(),this.encodeInto(A,I),I.toArray()},encodeInto(A,I){const g=I.length;return I.writeString(A.name),I.writeString(A.value),I.length-g},decode(A){const I=e.BebopView.getInstance();return I.startReading(A),this.readFrom(I)},readFrom(A){let I,g;return I=A.readString(),g=A.readString(),{name:I,value:g}}},(U=I.TelemetryValueType||(I.TelemetryValueType={}))[U.Double=0]="Double",U[U.BigInt=1]="BigInt",U[U.VarChar=2]="VarChar",U[U.Bool=3]="Bool",I.Guid={encode(A){const I=e.BebopView.getInstance();return I.startWriting(),this.encodeInto(A,I),I.toArray()},encodeInto(A,I){const g=I.length;return I.writeGuid(A.value),I.length-g},decode(A){const I=e.BebopView.getInstance();return I.startReading(A),this.readFrom(I)},readFrom(A){let I;return I=A.readGuid(),{value:I}}},I.RainwayHeader={encode(A){const I=e.BebopView.getInstance();return I.startWriting(),this.encodeInto(A,I),I.toArray()},encodeInto(A,I){const g=I.length;return I.writeUint32(A.magicNumber),I.writeUint32(A.syncKey),I.writeInt64(A.sourcePeerId),I.writeInt64(A.targetPeerId),I.length-g},decode(A){const I=e.BebopView.getInstance();return I.startReading(A),this.readFrom(I)},readFrom(A){let I,g,e,B;return I=A.readUint32(),g=A.readUint32(),e=A.readInt64(),B=A.readInt64(),{magicNumber:I,syncKey:g,sourcePeerId:e,targetPeerId:B}}},I.Chunk={encode(A){const I=e.BebopView.getInstance();return I.startWriting(),this.encodeInto(A,I),I.toArray()},encodeInto(A,I){const g=I.length;return I.writeUint16(A.groupId),I.writeByte(A.index),I.writeByte(A.chunksInGroup),I.writeBytes(A.data),I.length-g},decode(A){const I=e.BebopView.getInstance();return I.startReading(A),this.readFrom(I)},readFrom(A){let I,g,e,B;return I=A.readUint16(),g=A.readByte(),e=A.readByte(),B=A.readBytes(),{groupId:I,index:g,chunksInGroup:e,data:B}}},I.InputDatagram={encode(A){const I=e.BebopView.getInstance();return I.startWriting(),this.encodeInto(A,I),I.toArray()},encodeInto(A,g){const e=g.length;return I.RainwayHeader.encodeInto(A.header,g),I.InputBody.encodeInto(A.body,g),g.length-e},decode(A){const I=e.BebopView.getInstance();return I.startReading(A),this.readFrom(I)},readFrom(A){let g,e;return g=I.RainwayHeader.readFrom(A),e=I.InputBody.readFrom(A),{header:g,body:e}}},I.LogicDatagram={encode(A){const I=e.BebopView.getInstance();return I.startWriting(),this.encodeInto(A,I),I.toArray()},encodeInto(A,g){const e=g.length;return I.RainwayHeader.encodeInto(A.header,g),I.LogicBody.encodeInto(A.body,g),g.length-e},decode(A){const I=e.BebopView.getInstance();return I.startReading(A),this.readFrom(I)},readFrom(A){let g,e;return g=I.RainwayHeader.readFrom(A),e=I.LogicBody.readFrom(A),{header:g,body:e}}},I.MediaDatagram={encode(A){const I=e.BebopView.getInstance();return I.startWriting(),this.encodeInto(A,I),I.toArray()},encodeInto(A,g){const e=g.length;return I.RainwayHeader.encodeInto(A.header,g),I.MediaBody.encodeInto(A.body,g),g.length-e},decode(A){const I=e.BebopView.getInstance();return I.startReading(A),this.readFrom(I)},readFrom(A){let g,e;return g=I.RainwayHeader.readFrom(A),e=I.MediaBody.readFrom(A),{header:g,body:e}}},I.ArbitraryDatagram={encode(A){const I=e.BebopView.getInstance();return I.startWriting(),this.encodeInto(A,I),I.toArray()},encodeInto(A,g){const e=g.length;return I.RainwayHeader.encodeInto(A.header,g),I.Chunk.encodeInto(A.body,g),g.length-e},decode(A){const I=e.BebopView.getInstance();return I.startReading(A),this.readFrom(I)},readFrom(A){let g,e;return g=I.RainwayHeader.readFrom(A),e=I.Chunk.readFrom(A),{header:g,body:e}}},(k=I.XInputButtons||(I.XInputButtons={}))[k.None=0]="None",k[k.DpadUp=1]="DpadUp",k[k.DpadDown=2]="DpadDown",k[k.DpadLeft=4]="DpadLeft",k[k.DpadRight=8]="DpadRight",k[k.Start=16]="Start",k[k.Back=32]="Back",k[k.LeftStick=64]="LeftStick",k[k.RightStick=128]="RightStick",k[k.LeftBumper=256]="LeftBumper",k[k.RightBumper=512]="RightBumper",k[k.Guide=1024]="Guide",k[k.A=4096]="A",k[k.B=8192]="B",k[k.X=16384]="X",k[k.Y=32768]="Y",(G=I.ButtonAction||(I.ButtonAction={}))[G.ButtonDown=0]="ButtonDown",G[G.ButtonUp=1]="ButtonUp",(R=I.MouseButton||(I.MouseButton={}))[R.Left=0]="Left",R[R.Right=1]="Right",R[R.Middle=2]="Middle",R[R.X1=3]="X1",R[R.X2=4]="X2",(F=I.ScrollAxis||(I.ScrollAxis={}))[F.Horizontal=0]="Horizontal",F[F.Vertical=1]="Vertical",(S=I.KeyboardAction||(I.KeyboardAction={}))[S.KeyDown=0]="KeyDown",S[S.KeyUp=1]="KeyUp",(l=I.VirtualKey||(I.VirtualKey={}))[l.None=0]="None",l[l.Cancel=1]="Cancel",l[l.Back=2]="Back",l[l.Tab=3]="Tab",l[l.LineFeed=4]="LineFeed",l[l.Clear=5]="Clear",l[l.Enter=6]="Enter",l[l.Pause=7]="Pause",l[l.CapsLock=8]="CapsLock",l[l.HangulMode=9]="HangulMode",l[l.JunjaMode=10]="JunjaMode",l[l.FinalMode=11]="FinalMode",l[l.HanjaMode=12]="HanjaMode",l[l.Escape=13]="Escape",l[l.ImeConvert=14]="ImeConvert",l[l.ImeNonConvert=15]="ImeNonConvert",l[l.ImeAccept=16]="ImeAccept",l[l.ImeModeChange=17]="ImeModeChange",l[l.Space=18]="Space",l[l.PageUp=19]="PageUp",l[l.PageDown=20]="PageDown",l[l.End=21]="End",l[l.Home=22]="Home",l[l.Left=23]="Left",l[l.Up=24]="Up",l[l.Right=25]="Right",l[l.Down=26]="Down",l[l.Select=27]="Select",l[l.Print=28]="Print",l[l.Execute=29]="Execute",l[l.PrintScreen=30]="PrintScreen",l[l.Insert=31]="Insert",l[l.Delete=32]="Delete",l[l.Help=33]="Help",l[l.D0=34]="D0",l[l.D1=35]="D1",l[l.D2=36]="D2",l[l.D3=37]="D3",l[l.D4=38]="D4",l[l.D5=39]="D5",l[l.D6=40]="D6",l[l.D7=41]="D7",l[l.D8=42]="D8",l[l.D9=43]="D9",l[l.A=44]="A",l[l.B=45]="B",l[l.C=46]="C",l[l.D=47]="D",l[l.E=48]="E",l[l.F=49]="F",l[l.G=50]="G",l[l.H=51]="H",l[l.I=52]="I",l[l.J=53]="J",l[l.K=54]="K",l[l.L=55]="L",l[l.M=56]="M",l[l.N=57]="N",l[l.O=58]="O",l[l.P=59]="P",l[l.Q=60]="Q",l[l.R=61]="R",l[l.S=62]="S",l[l.T=63]="T",l[l.U=64]="U",l[l.V=65]="V",l[l.W=66]="W",l[l.X=67]="X",l[l.Y=68]="Y",l[l.Z=69]="Z",l[l.LWin=70]="LWin",l[l.RWin=71]="RWin",l[l.Apps=72]="Apps",l[l.Sleep=73]="Sleep",l[l.NumPad0=74]="NumPad0",l[l.NumPad1=75]="NumPad1",l[l.NumPad2=76]="NumPad2",l[l.NumPad3=77]="NumPad3",l[l.NumPad4=78]="NumPad4",l[l.NumPad5=79]="NumPad5",l[l.NumPad6=80]="NumPad6",l[l.NumPad7=81]="NumPad7",l[l.NumPad8=82]="NumPad8",l[l.NumPad9=83]="NumPad9",l[l.Multiply=84]="Multiply",l[l.Add=85]="Add",l[l.Separator=86]="Separator",l[l.Subtract=87]="Subtract",l[l.Decimal=88]="Decimal",l[l.Divide=89]="Divide",l[l.F1=90]="F1",l[l.F2=91]="F2",l[l.F3=92]="F3",l[l.F4=93]="F4",l[l.F5=94]="F5",l[l.F6=95]="F6",l[l.F7=96]="F7",l[l.F8=97]="F8",l[l.F9=98]="F9",l[l.F10=99]="F10",l[l.F11=100]="F11",l[l.F12=101]="F12",l[l.F13=102]="F13",l[l.F14=103]="F14",l[l.F15=104]="F15",l[l.F16=105]="F16",l[l.F17=106]="F17",l[l.F18=107]="F18",l[l.F19=108]="F19",l[l.F20=109]="F20",l[l.F21=110]="F21",l[l.F22=111]="F22",l[l.F23=112]="F23",l[l.F24=113]="F24",l[l.NumLock=114]="NumLock",l[l.Scroll=115]="Scroll",l[l.LeftShift=116]="LeftShift",l[l.RightShift=117]="RightShift",l[l.LeftCtrl=118]="LeftCtrl",l[l.RightCtrl=119]="RightCtrl",l[l.LeftAlt=120]="LeftAlt",l[l.RightAlt=121]="RightAlt",l[l.BrowserBack=122]="BrowserBack",l[l.BrowserForward=123]="BrowserForward",l[l.BrowserRefresh=124]="BrowserRefresh",l[l.BrowserStop=125]="BrowserStop",l[l.BrowserSearch=126]="BrowserSearch",l[l.BrowserFavorites=127]="BrowserFavorites",l[l.BrowserHome=128]="BrowserHome",l[l.VolumeMute=129]="VolumeMute",l[l.VolumeDown=130]="VolumeDown",l[l.VolumeUp=131]="VolumeUp",l[l.MediaNextTrack=132]="MediaNextTrack",l[l.MediaPreviousTrack=133]="MediaPreviousTrack",l[l.MediaStop=134]="MediaStop",l[l.MediaPlayPause=135]="MediaPlayPause",l[l.LaunchMail=136]="LaunchMail",l[l.SelectMedia=137]="SelectMedia",l[l.LaunchApplication1=138]="LaunchApplication1",l[l.LaunchApplication2=139]="LaunchApplication2",l[l.Oem1=140]="Oem1",l[l.OemPlus=141]="OemPlus",l[l.OemComma=142]="OemComma",l[l.OemMinus=143]="OemMinus",l[l.OemPeriod=144]="OemPeriod",l[l.Oem2=145]="Oem2",l[l.Oem3=146]="Oem3",l[l.AbntC1=147]="AbntC1",l[l.AbntC2=148]="AbntC2",l[l.Oem4=149]="Oem4",l[l.Oem5=150]="Oem5",l[l.Oem6=151]="Oem6",l[l.Oem7=152]="Oem7",l[l.Oem8=153]="Oem8",l[l.Oem102=154]="Oem102",l[l.ImeProcessed=155]="ImeProcessed",l[l.System=156]="System",l[l.OemAttn=157]="OemAttn",l[l.OemFinish=158]="OemFinish",l[l.OemCopy=159]="OemCopy",l[l.OemAuto=160]="OemAuto",l[l.OemEnlw=161]="OemEnlw",l[l.OemBackTab=162]="OemBackTab",l[l.Attn=163]="Attn",l[l.CrSel=164]="CrSel",l[l.ExSel=165]="ExSel",l[l.EraseEof=166]="EraseEof",l[l.Play=167]="Play",l[l.Zoom=168]="Zoom",l[l.NoName=169]="NoName",l[l.Pa1=170]="Pa1",l[l.OemClear=171]="OemClear",l[l.DeadCharProcessed=172]="DeadCharProcessed",(u=I.WindowsPointerFlags||(I.WindowsPointerFlags={}))[u.New=1]="New",u[u.InRange=2]="InRange",u[u.InContact=4]="InContact",u[u.FirstButton=16]="FirstButton",u[u.SecondButton=32]="SecondButton",u[u.ThirdButton=64]="ThirdButton",u[u.FourthButton=128]="FourthButton",u[u.FifthButton=256]="FifthButton",u[u.Primary=8192]="Primary",u[u.Confidence=16384]="Confidence",u[u.Canceled=32768]="Canceled",u[u.Down=65536]="Down",u[u.Update=131072]="Update",u[u.Up=262144]="Up",u[u.Wheel=524288]="Wheel",u[u.HWheel=1048576]="HWheel",u[u.CaptureChanged=2097152]="CaptureChanged",u[u.HasTransform=4194304]="HasTransform",I.TouchPenPointerInfo={encode(A){const I=e.BebopView.getInstance();return I.startWriting(),this.encodeInto(A,I),I.toArray()},encodeInto(A,I){const g=I.length;return I.writeUint32(A.pointerId),I.writeUint32(A.frameId),I.writeUint32(A.pointerFlags),I.writeInt32(A.x),I.writeInt32(A.y),I.length-g},decode(A){const I=e.BebopView.getInstance();return I.startReading(A),this.readFrom(I)},readFrom(A){let I,g,e,B,i;return I=A.readUint32(),g=A.readUint32(),e=A.readUint32(),B=A.readInt32(),i=A.readInt32(),{pointerId:I,frameId:g,pointerFlags:e,x:B,y:i}}},(y=I.TouchMask||(I.TouchMask={}))[y.ContactArea=1]="ContactArea",y[y.Orientation=2]="Orientation",y[y.Pressure=4]="Pressure",(w=I.PenMask||(I.PenMask={}))[w.Pressure=1]="Pressure",w[w.Rotation=2]="Rotation",w[w.TiltX=4]="TiltX",w[w.TiltY=8]="TiltY",(D=I.PenFlags||(I.PenFlags={}))[D.Barrel=1]="Barrel",D[D.Inverted=2]="Inverted",D[D.Eraser=4]="Eraser",I.TouchAbsolute={encode(A){const I=e.BebopView.getInstance();return I.startWriting(),this.encodeInto(A,I),I.toArray()},encodeInto(A,g){const e=g.length;return I.TouchPenPointerInfo.encodeInto(A.pointerInfo,g),g.writeUint32(A.touchMask),g.writeInt32(A.contactLeft),g.writeInt32(A.contactTop),g.writeInt32(A.contactRight),g.writeInt32(A.contactBottom),g.writeUint32(A.orientation),g.writeUint32(A.pressure),g.length-e},decode(A){const I=e.BebopView.getInstance();return I.startReading(A),this.readFrom(I)},readFrom(A){let g,e,B,i,Q,t,C,E;return g=I.TouchPenPointerInfo.readFrom(A),e=A.readUint32(),B=A.readInt32(),i=A.readInt32(),Q=A.readInt32(),t=A.readInt32(),C=A.readUint32(),E=A.readUint32(),{pointerInfo:g,touchMask:e,contactLeft:B,contactTop:i,contactRight:Q,contactBottom:t,orientation:C,pressure:E}}},I.GamepadReport={discriminator:1,encode(A){const I=e.BebopView.getInstance();return I.startWriting(),this.encodeInto(A,I),I.toArray()},encodeInto(A,I){const g=I.length;return I.writeUint32(A.buttons),I.writeByte(A.leftTrigger),I.writeByte(A.rightTrigger),I.writeInt16(A.leftThumbX),I.writeInt16(A.leftThumbY),I.writeInt16(A.rightThumbX),I.writeInt16(A.rightThumbY),I.writeByte(A.slot),I.length-g},decode(A){const I=e.BebopView.getInstance();return I.startReading(A),this.readFrom(I)},readFrom(A){let I,g,e,B,i,Q,t,C;return I=A.readUint32(),g=A.readByte(),e=A.readByte(),B=A.readInt16(),i=A.readInt16(),Q=A.readInt16(),t=A.readInt16(),C=A.readByte(),{buttons:I,leftTrigger:g,rightTrigger:e,leftThumbX:B,leftThumbY:i,rightThumbX:Q,rightThumbY:t,slot:C}}},I.GamepadRumble={discriminator:2,encode(A){const I=e.BebopView.getInstance();return I.startWriting(),this.encodeInto(A,I),I.toArray()},encodeInto(A,I){const g=I.length;return I.writeByte(A.port),I.writeUint16(A.leftMotorSpeed),I.writeUint16(A.rightMotorSpeed),I.length-g},decode(A){const I=e.BebopView.getInstance();return I.startReading(A),this.readFrom(I)},readFrom(A){let I,g,e;return I=A.readByte(),g=A.readUint16(),e=A.readUint16(),{port:I,leftMotorSpeed:g,rightMotorSpeed:e}}},I.MouseAbsolute={discriminator:3,encode(A){const I=e.BebopView.getInstance();return I.startWriting(),this.encodeInto(A,I),I.toArray()},encodeInto(A,I){const g=I.length;return I.writeInt32(A.x),I.writeInt32(A.y),I.length-g},decode(A){const I=e.BebopView.getInstance();return I.startReading(A),this.readFrom(I)},readFrom(A){let I,g;return I=A.readInt32(),g=A.readInt32(),{x:I,y:g}}},I.MouseRelative={discriminator:4,encode(A){const I=e.BebopView.getInstance();return I.startWriting(),this.encodeInto(A,I),I.toArray()},encodeInto(A,I){const g=I.length;return I.writeInt32(A.dx),I.writeInt32(A.dy),I.length-g},decode(A){const I=e.BebopView.getInstance();return I.startReading(A),this.readFrom(I)},readFrom(A){let I,g;return I=A.readInt32(),g=A.readInt32(),{dx:I,dy:g}}},I.MouseClick={discriminator:5,encode(A){const I=e.BebopView.getInstance();return I.startWriting(),this.encodeInto(A,I),I.toArray()},encodeInto(A,I){const g=I.length;return I.writeUint32(A.action),I.writeUint32(A.button),I.length-g},decode(A){const I=e.BebopView.getInstance();return I.startReading(A),this.readFrom(I)},readFrom(A){let I,g;return I=A.readUint32(),g=A.readUint32(),{action:I,button:g}}},I.MouseScroll={discriminator:6,encode(A){const I=e.BebopView.getInstance();return I.startWriting(),this.encodeInto(A,I),I.toArray()},encodeInto(A,I){const g=I.length;return I.writeUint32(A.axis),I.writeInt32(A.delta),I.length-g},decode(A){const I=e.BebopView.getInstance();return I.startReading(A),this.readFrom(I)},readFrom(A){let I,g;return I=A.readUint32(),g=A.readInt32(),{axis:I,delta:g}}},I.KeyboardInput={discriminator:7,encode(A){const I=e.BebopView.getInstance();return I.startWriting(),this.encodeInto(A,I),I.toArray()},encodeInto(A,I){const g=I.length;I.writeUint32(A.action);{const g=A.keycodes.length;I.writeUint32(g);for(let e=0;e<g;e++)I.writeUint32(A.keycodes[e])}return I.length-g},decode(A){const I=e.BebopView.getInstance();return I.startReading(A),this.readFrom(I)},readFrom(A){let I,g;I=A.readUint32();{let I=A.readUint32();g=new Array(I);for(let e=0;e<I;e++){let I;I=A.readUint32(),g[e]=I}}return{action:I,keycodes:g}}},I.LogicalInput={discriminator:8,encode(A){const I=e.BebopView.getInstance();return I.startWriting(),this.encodeInto(A,I),I.toArray()},encodeInto(A,I){const g=I.length;return I.writeString(A.inputString),I.length-g},decode(A){const I=e.BebopView.getInstance();return I.startReading(A),this.readFrom(I)},readFrom(A){let I;return I=A.readString(),{inputString:I}}},I.TouchesAbsolute={discriminator:9,encode(A){const I=e.BebopView.getInstance();return I.startWriting(),this.encodeInto(A,I),I.toArray()},encodeInto(A,g){const e=g.length;{const e=A.touches.length;g.writeUint32(e);for(let B=0;B<e;B++)I.TouchAbsolute.encodeInto(A.touches[B],g)}return g.length-e},decode(A){const I=e.BebopView.getInstance();return I.startReading(A),this.readFrom(I)},readFrom(A){let g;{let e=A.readUint32();g=new Array(e);for(let B=0;B<e;B++){let e;e=I.TouchAbsolute.readFrom(A),g[B]=e}}return{touches:g}}},I.PenAbsolute={discriminator:10,encode(A){const I=e.BebopView.getInstance();return I.startWriting(),this.encodeInto(A,I),I.toArray()},encodeInto(A,g){const e=g.length;return I.TouchPenPointerInfo.encodeInto(A.pointerInfo,g),g.writeUint32(A.penFlags),g.writeUint32(A.penMask),g.writeUint32(A.pressure),g.writeUint32(A.rotation),g.writeInt32(A.tiltX),g.writeInt32(A.tiltY),g.length-e},decode(A){const I=e.BebopView.getInstance();return I.startReading(A),this.readFrom(I)},readFrom(A){let g,e,B,i,Q,t,C;return g=I.TouchPenPointerInfo.readFrom(A),e=A.readUint32(),B=A.readUint32(),i=A.readUint32(),Q=A.readUint32(),t=A.readInt32(),C=A.readInt32(),{pointerInfo:g,penFlags:e,penMask:B,pressure:i,rotation:Q,tiltX:t,tiltY:C}}},I.ViewportResize={discriminator:11,encode(A){const I=e.BebopView.getInstance();return I.startWriting(),this.encodeInto(A,I),I.toArray()},encodeInto(A,I){const g=I.length;return I.writeUint32(A.width),I.writeUint32(A.height),I.length-g},decode(A){const I=e.BebopView.getInstance();return I.startReading(A),this.readFrom(I)},readFrom(A){let I,g;return I=A.readUint32(),g=A.readUint32(),{width:I,height:g}}},I.SetClipboardText={discriminator:12,encode(A){const I=e.BebopView.getInstance();return I.startWriting(),this.encodeInto(A,I),I.toArray()},encodeInto(A,I){const g=I.length;return I.writeString(A.text),I.length-g},decode(A){const I=e.BebopView.getInstance();return I.startReading(A),this.readFrom(I)},readFrom(A){let I;return I=A.readString(),{text:I}}},I.InputBody={encode(A){const I=e.BebopView.getInstance();return I.startWriting(),this.encodeInto(A,I),I.toArray()},encodeInto(A,g){const e=g.length,B=g.reserveMessageLength(),i=g.length+1;switch(g.writeByte(A.discriminator),A.discriminator){case 1:I.GamepadReport.encodeInto(A.value,g);break;case 2:I.GamepadRumble.encodeInto(A.value,g);break;case 3:I.MouseAbsolute.encodeInto(A.value,g);break;case 4:I.MouseRelative.encodeInto(A.value,g);break;case 5:I.MouseClick.encodeInto(A.value,g);break;case 6:I.MouseScroll.encodeInto(A.value,g);break;case 7:I.KeyboardInput.encodeInto(A.value,g);break;case 8:I.LogicalInput.encodeInto(A.value,g);break;case 9:I.TouchesAbsolute.encodeInto(A.value,g);break;case 10:I.PenAbsolute.encodeInto(A.value,g);break;case 11:I.ViewportResize.encodeInto(A.value,g);break;case 12:I.SetClipboardText.encodeInto(A.value,g)}const Q=g.length;return g.fillMessageLength(B,Q-i),g.length-e},decode(A){const I=e.BebopView.getInstance();return I.startReading(A),this.readFrom(I)},readFrom(A){const g=A.readMessageLength(),B=A.index+1+g;switch(A.readByte()){case 1:return{discriminator:1,value:I.GamepadReport.readFrom(A)};case 2:return{discriminator:2,value:I.GamepadRumble.readFrom(A)};case 3:return{discriminator:3,value:I.MouseAbsolute.readFrom(A)};case 4:return{discriminator:4,value:I.MouseRelative.readFrom(A)};case 5:return{discriminator:5,value:I.MouseClick.readFrom(A)};case 6:return{discriminator:6,value:I.MouseScroll.readFrom(A)};case 7:return{discriminator:7,value:I.KeyboardInput.readFrom(A)};case 8:return{discriminator:8,value:I.LogicalInput.readFrom(A)};case 9:return{discriminator:9,value:I.TouchesAbsolute.readFrom(A)};case 10:return{discriminator:10,value:I.PenAbsolute.readFrom(A)};case 11:return{discriminator:11,value:I.ViewportResize.readFrom(A)};case 12:return{discriminator:12,value:I.SetClipboardText.readFrom(A)};default:throw A.index=B,new e.BebopRuntimeError("Unrecognized discriminator while decoding InputBody")}}},(c=I.VideoCodecType||(I.VideoCodecType={}))[c.Baseline=1]="Baseline",c[c.Main=2]="Main",c[c.High=4]="High",c[c.H264=7]="H264",c[c.H265=8]="H265",(h=I.Vendor||(I.Vendor={}))[h.Unknown=0]="Unknown",h[h.Amd=4098]="Amd",h[h.Nvidia=4318]="Nvidia",h[h.Intel=32902]="Intel",I.VideoCodec={encode(A){const I=e.BebopView.getInstance();return I.startWriting(),this.encodeInto(A,I),I.toArray()},encodeInto(A,I){const g=I.length;return I.writeString(A.friendlyName),I.writeUint32(A.width),I.writeUint32(A.height),I.writeUint32(A.refreshRate),I.writeBytes(A.data),I.writeUint32(A.type),I.length-g},decode(A){const I=e.BebopView.getInstance();return I.startReading(A),this.readFrom(I)},readFrom(A){let I,g,e,B,i,Q;return I=A.readString(),g=A.readUint32(),e=A.readUint32(),B=A.readUint32(),i=A.readBytes(),Q=A.readUint32(),{friendlyName:I,width:g,height:e,refreshRate:B,data:i,type:Q}}},(d=I.FormFactor||(I.FormFactor={}))[d.Unknown=0]="Unknown",d[d.Phone=1]="Phone",d[d.Tablet=2]="Tablet",d[d.Computer=3]="Computer",d[d.Console=4]="Console",d[d.Tv=5]="Tv",(r=I.OperatingSystem||(I.OperatingSystem={}))[r.Other=0]="Other",r[r.IOS=1]="IOS",r[r.TvOS=2]="TvOS",r[r.Android=3]="Android",r[r.Windows=4]="Windows",r[r.MacOS=5]="MacOS",r[r.Linux=6]="Linux",r[r.Roku=7]="Roku",(s=I.NetworkProtocol||(I.NetworkProtocol={}))[s.WebRTC=0]="WebRTC",s[s.Geyser=1]="Geyser",(n=I.AudioChannels||(I.AudioChannels={}))[n.Mono=0]="Mono",n[n.Stereo=1]="Stereo",n[n.Surround51=2]="Surround51",n[n.Surround71=3]="Surround71",(a=I.AudioCodec||(I.AudioCodec={}))[a.Opus=0]="Opus",a[a.Aac=1]="Aac",(o=I.AudioContainer||(I.AudioContainer={}))[o.Raw=0]="Raw",o[o.WebM=1]="WebM",o[o.IsoBMFF=2]="IsoBMFF",(E=I.VideoContainer||(I.VideoContainer={}))[E.Raw=0]="Raw",E[E.IsoBMFF=1]="IsoBMFF",(C=I.LogicError||(I.LogicError={}))[C.UnknownError=0]="UnknownError",C[C.DisplaysMissing=1]="DisplaysMissing",C[C.NoAvailableEncoder=2]="NoAvailableEncoder",C[C.InvalidEncodingConfig=3]="InvalidEncodingConfig",C[C.NoCodecsExchanged=4]="NoCodecsExchanged",C[C.NoCapabilities=5]="NoCapabilities",C[C.NoSuchStream=6]="NoSuchStream",C[C.ForceSegmentFailed=7]="ForceSegmentFailed",I.AudioConfig={encode(A){const I=e.BebopView.getInstance();return I.startWriting(),this.encodeInto(A,I),I.toArray()},encodeInto(A,I){const g=I.length;return I.writeUint32(A.codec),I.writeUint32(A.container),I.length-g},decode(A){const I=e.BebopView.getInstance();return I.startReading(A),this.readFrom(I)},readFrom(A){let I,g;return I=A.readUint32(),g=A.readUint32(),{codec:I,container:g}}},(t=I.CaptureMode||(I.CaptureMode={}))[t.Unknown=0]="Unknown",t[t.FullDesktop=1]="FullDesktop",t[t.AppIsolation=2]="AppIsolation",t[t.BYOFB=3]="BYOFB",I.VideoConfig={encode(A){const I=e.BebopView.getInstance();return I.startWriting(),this.encodeInto(A,I),I.toArray()},encodeInto(A,g){const e=g.length;return I.VideoCodec.encodeInto(A.codec,g),g.writeUint32(A.container),g.length-e},decode(A){const I=e.BebopView.getInstance();return I.startReading(A),this.readFrom(I)},readFrom(A){let g,e;return g=I.VideoCodec.readFrom(A),e=A.readUint32(),{codec:g,container:e}}},(Q=I.InputLevel||(I.InputLevel={}))[Q.None=0]="None",Q[Q.GamepadPort1=1]="GamepadPort1",Q[Q.GamepadPort2=2]="GamepadPort2",Q[Q.GamepadPort3=4]="GamepadPort3",Q[Q.GamepadPort4=8]="GamepadPort4",Q[Q.Gamepad=15]="Gamepad",Q[Q.Mouse=16]="Mouse",Q[Q.Keyboard=32]="Keyboard",Q[Q.Clipboard=64]="Clipboard",I.DeviceInfo={discriminator:1,encode(A){const I=e.BebopView.getInstance();return I.startWriting(),this.encodeInto(A,I),I.toArray()},encodeInto(A,I){const g=I.length;return I.writeUint32(A.formFactor),I.writeString(A.deviceName),I.writeUint32(A.deviceOs),I.writeString(A.deviceOsVersion),I.writeString(A.deviceModel),I.writeString(A.userAgent),I.writeString(A.deviceId),I.writeByte(Number(A.isWeb)),I.length-g},decode(A){const I=e.BebopView.getInstance();return I.startReading(A),this.readFrom(I)},readFrom(A){let I,g,e,B,i,Q,t,C;return I=A.readUint32(),g=A.readString(),e=A.readUint32(),B=A.readString(),i=A.readString(),Q=A.readString(),t=A.readString(),C=!!A.readByte(),{formFactor:I,deviceName:g,deviceOs:e,deviceOsVersion:B,deviceModel:i,userAgent:Q,deviceId:t,isWeb:C}}},I.CodecPackRequest={discriminator:2,encode(A){const I=e.BebopView.getInstance();return I.startWriting(),this.encodeInto(A,I),I.toArray()},encodeInto(A,I){const g=I.length;return I.length-g},decode(A){const I=e.BebopView.getInstance();return I.startReading(A),this.readFrom(I)},readFrom:A=>({})},I.CodecPackResponse={discriminator:3,encode(A){const I=e.BebopView.getInstance();return I.startWriting(),this.encodeInto(A,I),I.toArray()},encodeInto(A,g){const e=g.length;{const e=A.videoCodecs.length;g.writeUint32(e);for(let B=0;B<e;B++)I.VideoCodec.encodeInto(A.videoCodecs[B],g)}return g.length-e},decode(A){const I=e.BebopView.getInstance();return I.startReading(A),this.readFrom(I)},readFrom(A){let g;{let e=A.readUint32();g=new Array(e);for(let B=0;B<e;B++){let e;e=I.VideoCodec.readFrom(A),g[B]=e}}return{videoCodecs:g}}},I.ClientCapabilities={discriminator:4,encode(A){const I=e.BebopView.getInstance();return I.startWriting(),this.encodeInto(A,I),I.toArray()},encodeInto(A,g){const e=g.length;g.writeUint32(A.preferredWidth),g.writeUint32(A.preferredHeight),g.writeUint32(A.preferredFps),g.writeUint32(A.preferredAudioBitrate),g.writeUint32(A.preferredVideoBitrate),g.writeUint32(A.preferredAudioChannels),I.AudioConfig.encodeInto(A.preferredAudioConfig,g),I.VideoConfig.encodeInto(A.preferredVideoConfig,g);{const I=A.supportedAudioChannels.length;g.writeUint32(I);for(let e=0;e<I;e++)g.writeUint32(A.supportedAudioChannels[e])}{const e=A.supportedAudioConfigs.length;g.writeUint32(e);for(let B=0;B<e;B++)I.AudioConfig.encodeInto(A.supportedAudioConfigs[B],g)}{const e=A.supportedVideoConfigs.length;g.writeUint32(e);for(let B=0;B<e;B++)I.VideoConfig.encodeInto(A.supportedVideoConfigs[B],g)}return g.writeByte(Number(A.supportsOver1080P)),g.writeByte(Number(A.supportsTemporalScaling)),g.writeByte(Number(A.supportsAppIsolation)),g.length-e},decode(A){const I=e.BebopView.getInstance();return I.startReading(A),this.readFrom(I)},readFrom(A){let g,e,B,i,Q,t,C,E,o,a,n,s,r,d;g=A.readUint32(),e=A.readUint32(),B=A.readUint32(),i=A.readUint32(),Q=A.readUint32(),t=A.readUint32(),C=I.AudioConfig.readFrom(A),E=I.VideoConfig.readFrom(A);{let I=A.readUint32();o=new Array(I);for(let g=0;g<I;g++){let I;I=A.readUint32(),o[g]=I}}{let g=A.readUint32();a=new Array(g);for(let e=0;e<g;e++){let g;g=I.AudioConfig.readFrom(A),a[e]=g}}{let g=A.readUint32();n=new Array(g);for(let e=0;e<g;e++){let g;g=I.VideoConfig.readFrom(A),n[e]=g}}return s=!!A.readByte(),r=!!A.readByte(),d=!!A.readByte(),{preferredWidth:g,preferredHeight:e,preferredFps:B,preferredAudioBitrate:i,preferredVideoBitrate:Q,preferredAudioChannels:t,preferredAudioConfig:C,preferredVideoConfig:E,supportedAudioChannels:o,supportedAudioConfigs:a,supportedVideoConfigs:n,supportsOver1080P:s,supportsTemporalScaling:r,supportsAppIsolation:d}}},I.ErrorResponse={discriminator:5,encode(A){const I=e.BebopView.getInstance();return I.startWriting(),this.encodeInto(A,I),I.toArray()},encodeInto(A,I){const g=I.length;return I.writeUint32(A.error),I.length-g},decode(A){const I=e.BebopView.getInstance();return I.startReading(A),this.readFrom(I)},readFrom(A){let I;return I=A.readUint32(),{error:I}}},I.StreamRequest={discriminator:6,encode(A){const I=e.BebopView.getInstance();return I.startWriting(),this.encodeInto(A,I),I.toArray()},encodeInto(A,I){const g=I.length;return I.writeUint32(A.inputLevel),I.length-g},decode(A){const I=e.BebopView.getInstance();return I.startReading(A),this.readFrom(I)},readFrom(A){let I;return I=A.readUint32(),{inputLevel:I}}},I.StreamStarting={discriminator:7,encode(A){const I=e.BebopView.getInstance();return I.startWriting(),this.encodeInto(A,I),I.toArray()},encodeInto(A,g){const e=g.length;return g.writeByte(A.streamId),g.writeUint32(A.inputLevel),g.writeFloat32(A.temporalScaleFactor),I.AudioConfig.encodeInto(A.chosenAudioConfig,g),I.VideoConfig.encodeInto(A.chosenVideoConfig,g),g.writeUint32(A.captureMode),g.length-e},decode(A){const I=e.BebopView.getInstance();return I.startReading(A),this.readFrom(I)},readFrom(A){let g,e,B,i,Q,t;return g=A.readByte(),e=A.readUint32(),B=A.readFloat32(),i=I.AudioConfig.readFrom(A),Q=I.VideoConfig.readFrom(A),t=A.readUint32(),{streamId:g,inputLevel:e,temporalScaleFactor:B,chosenAudioConfig:i,chosenVideoConfig:Q,captureMode:t}}},I.LeaveStream={discriminator:8,encode(A){const I=e.BebopView.getInstance();return I.startWriting(),this.encodeInto(A,I),I.toArray()},encodeInto(A,I){const g=I.length;return I.writeByte(A.streamId),I.length-g},decode(A){const I=e.BebopView.getInstance();return I.startReading(A),this.readFrom(I)},readFrom(A){let I;return I=A.readByte(),{streamId:I}}},I.StreamStopping={discriminator:9,encode(A){const I=e.BebopView.getInstance();return I.startWriting(),this.encodeInto(A,I),I.toArray()},encodeInto(A,I){const g=I.length;return I.writeByte(A.streamId),I.length-g},decode(A){const I=e.BebopView.getInstance();return I.startReading(A),this.readFrom(I)},readFrom(A){let I;return I=A.readByte(),{streamId:I}}},I.KeyframeRequest={discriminator:10,encode(A){const I=e.BebopView.getInstance();return I.startWriting(),this.encodeInto(A,I),I.toArray()},encodeInto(A,I){const g=I.length;return I.writeByte(A.streamId),I.length-g},decode(A){const I=e.BebopView.getInstance();return I.startReading(A),this.readFrom(I)},readFrom(A){let I;return I=A.readByte(),{streamId:I}}},I.VideoBitrateRequest={discriminator:11,encode(A){const I=e.BebopView.getInstance();return I.startWriting(),this.encodeInto(A,I),I.toArray()},encodeInto(A,I){const g=I.length;return I.writeByte(A.streamId),I.writeUint32(A.bitsPerSecond),I.length-g},decode(A){const I=e.BebopView.getInstance();return I.startReading(A),this.readFrom(I)},readFrom(A){let I,g;return I=A.readByte(),g=A.readUint32(),{streamId:I,bitsPerSecond:g}}},I.JoinStream={discriminator:12,encode(A){const I=e.BebopView.getInstance();return I.startWriting(),this.encodeInto(A,I),I.toArray()},encodeInto(A,I){const g=I.length;return I.writeByte(A.streamId),I.length-g},decode(A){const I=e.BebopView.getInstance();return I.startReading(A),this.readFrom(I)},readFrom(A){let I;return I=A.readByte(),{streamId:I}}},I.PauseStream={discriminator:13,encode(A){const I=e.BebopView.getInstance();return I.startWriting(),this.encodeInto(A,I),I.toArray()},encodeInto(A,I){const g=I.length;return I.writeByte(A.streamId),I.length-g},decode(A){const I=e.BebopView.getInstance();return I.startReading(A),this.readFrom(I)},readFrom(A){let I;return I=A.readByte(),{streamId:I}}},I.RejectStreamRequest={discriminator:14,encode(A){const I=e.BebopView.getInstance();return I.startWriting(),this.encodeInto(A,I),I.toArray()},encodeInto(A,I){const g=I.length;return I.writeString(A.reason),I.length-g},decode(A){const I=e.BebopView.getInstance();return I.startReading(A),this.readFrom(I)},readFrom(A){let I;return I=A.readString(),{reason:I}}},I.InputLevelUpdate={discriminator:15,encode(A){const I=e.BebopView.getInstance();return I.startWriting(),this.encodeInto(A,I),I.toArray()},encodeInto(A,I){const g=I.length;return I.writeByte(A.streamId),I.writeUint32(A.inputLevel),I.length-g},decode(A){const I=e.BebopView.getInstance();return I.startReading(A),this.readFrom(I)},readFrom(A){let I,g;return I=A.readByte(),g=A.readUint32(),{streamId:I,inputLevel:g}}},I.InputLevelRequest={discriminator:16,encode(A){const I=e.BebopView.getInstance();return I.startWriting(),this.encodeInto(A,I),I.toArray()},encodeInto(A,I){const g=I.length;return I.writeByte(A.streamId),I.writeUint32(A.inputLevel),I.length-g},decode(A){const I=e.BebopView.getInstance();return I.startReading(A),this.readFrom(I)},readFrom(A){let I,g;return I=A.readByte(),g=A.readUint32(),{streamId:I,inputLevel:g}}},I.LogicBody={encode(A){const I=e.BebopView.getInstance();return I.startWriting(),this.encodeInto(A,I),I.toArray()},encodeInto(A,g){const e=g.length,B=g.reserveMessageLength(),i=g.length+1;switch(g.writeByte(A.discriminator),A.discriminator){case 1:I.DeviceInfo.encodeInto(A.value,g);break;case 2:I.CodecPackRequest.encodeInto(A.value,g);break;case 3:I.CodecPackResponse.encodeInto(A.value,g);break;case 4:I.ClientCapabilities.encodeInto(A.value,g);break;case 5:I.ErrorResponse.encodeInto(A.value,g);break;case 6:I.StreamRequest.encodeInto(A.value,g);break;case 7:I.StreamStarting.encodeInto(A.value,g);break;case 8:I.LeaveStream.encodeInto(A.value,g);break;case 9:I.StreamStopping.encodeInto(A.value,g);break;case 10:I.KeyframeRequest.encodeInto(A.value,g);break;case 11:I.VideoBitrateRequest.encodeInto(A.value,g);break;case 12:I.JoinStream.encodeInto(A.value,g);break;case 13:I.PauseStream.encodeInto(A.value,g);break;case 14:I.RejectStreamRequest.encodeInto(A.value,g);break;case 15:I.InputLevelUpdate.encodeInto(A.value,g);break;case 16:I.InputLevelRequest.encodeInto(A.value,g)}const Q=g.length;return g.fillMessageLength(B,Q-i),g.length-e},decode(A){const I=e.BebopView.getInstance();return I.startReading(A),this.readFrom(I)},readFrom(A){const g=A.readMessageLength(),B=A.index+1+g;switch(A.readByte()){case 1:return{discriminator:1,value:I.DeviceInfo.readFrom(A)};case 2:return{discriminator:2,value:I.CodecPackRequest.readFrom(A)};case 3:return{discriminator:3,value:I.CodecPackResponse.readFrom(A)};case 4:return{discriminator:4,value:I.ClientCapabilities.readFrom(A)};case 5:return{discriminator:5,value:I.ErrorResponse.readFrom(A)};case 6:return{discriminator:6,value:I.StreamRequest.readFrom(A)};case 7:return{discriminator:7,value:I.StreamStarting.readFrom(A)};case 8:return{discriminator:8,value:I.LeaveStream.readFrom(A)};case 9:return{discriminator:9,value:I.StreamStopping.readFrom(A)};case 10:return{discriminator:10,value:I.KeyframeRequest.readFrom(A)};case 11:return{discriminator:11,value:I.VideoBitrateRequest.readFrom(A)};case 12:return{discriminator:12,value:I.JoinStream.readFrom(A)};case 13:return{discriminator:13,value:I.PauseStream.readFrom(A)};case 14:return{discriminator:14,value:I.RejectStreamRequest.readFrom(A)};case 15:return{discriminator:15,value:I.InputLevelUpdate.readFrom(A)};case 16:return{discriminator:16,value:I.InputLevelRequest.readFrom(A)};default:throw A.index=B,new e.BebopRuntimeError("Unrecognized discriminator while decoding LogicBody")}}},(i=I.VideoDataType||(I.VideoDataType={}))[i.Metadata=0]="Metadata",i[i.CleanPointFrame=1]="CleanPointFrame",i[i.FrameDiff=2]="FrameDiff",(B=I.AudioDataType||(I.AudioDataType={}))[B.Metadata=0]="Metadata",B[B.Frame=1]="Frame",I.DesktopRect={encode(A){const I=e.BebopView.getInstance();return I.startWriting(),this.encodeInto(A,I),I.toArray()},encodeInto(A,I){const g=I.length;return I.writeInt32(A.left),I.writeInt32(A.top),I.writeUint32(A.width),I.writeUint32(A.height),I.length-g},decode(A){const I=e.BebopView.getInstance();return I.startReading(A),this.readFrom(I)},readFrom(A){let I,g,e,B;return I=A.readInt32(),g=A.readInt32(),e=A.readUint32(),B=A.readUint32(),{left:I,top:g,width:e,height:B}}},I.VideoData={discriminator:1,encode(A){const I=e.BebopView.getInstance();return I.startWriting(),this.encodeInto(A,I),I.toArray()},encodeInto(A,g){const e=g.length;g.writeBytes(A.data),g.writeUint64(A.segmentTime),g.writeUint32(A.type),g.writeByte(A.streamId),I.DesktopRect.encodeInto(A.desktopRect,g);{const e=A.mask.length;g.writeUint32(e);for(let B=0;B<e;B++)I.DesktopRect.encodeInto(A.mask[B],g)}return g.length-e},decode(A){const I=e.BebopView.getInstance();return I.startReading(A),this.readFrom(I)},readFrom(A){let g,e,B,i,Q,t;g=A.readBytes(),e=A.readUint64(),B=A.readUint32(),i=A.readByte(),Q=I.DesktopRect.readFrom(A);{let g=A.readUint32();t=new Array(g);for(let e=0;e<g;e++){let g;g=I.DesktopRect.readFrom(A),t[e]=g}}return{data:g,segmentTime:e,type:B,streamId:i,desktopRect:Q,mask:t}}},I.PointerData={discriminator:2,encode(A){const I=e.BebopView.getInstance();return I.startWriting(),this.encodeInto(A,I),I.toArray()},encodeInto(A,I){const g=I.length;return I.writeBytes(A.data),I.writeUint32(A.monitorWidth),I.writeUint32(A.monitorHeight),I.writeUint32(A.shapeWidth),I.writeUint32(A.shapeHeight),I.writeInt32(A.spotX),I.writeInt32(A.spotY),I.writeByte(Number(A.visible)),I.writeInt32(A.positionX),I.writeInt32(A.positionY),I.writeByte(A.streamId),I.length-g},decode(A){const I=e.BebopView.getInstance();return I.startReading(A),this.readFrom(I)},readFrom(A){let I,g,e,B,i,Q,t,C,E,o,a;return I=A.readBytes(),g=A.readUint32(),e=A.readUint32(),B=A.readUint32(),i=A.readUint32(),Q=A.readInt32(),t=A.readInt32(),C=!!A.readByte(),E=A.readInt32(),o=A.readInt32(),a=A.readByte(),{data:I,monitorWidth:g,monitorHeight:e,shapeWidth:B,shapeHeight:i,spotX:Q,spotY:t,visible:C,positionX:E,positionY:o,streamId:a}}},I.AudioData={discriminator:3,encode(A){const I=e.BebopView.getInstance();return I.startWriting(),this.encodeInto(A,I),I.toArray()},encodeInto(A,I){const g=I.length;return I.writeBytes(A.data),I.writeUint32(A.type),I.writeByte(A.streamId),I.length-g},decode(A){const I=e.BebopView.getInstance();return I.startReading(A),this.readFrom(I)},readFrom(A){let I,g,e;return I=A.readBytes(),g=A.readUint32(),e=A.readByte(),{data:I,type:g,streamId:e}}},I.MediaChunk={discriminator:4,encode(A){const I=e.BebopView.getInstance();return I.startWriting(),this.encodeInto(A,I),I.toArray()},encodeInto(A,g){const e=g.length;return I.Chunk.encodeInto(A.chunk,g),g.length-e},decode(A){const I=e.BebopView.getInstance();return I.startReading(A),this.readFrom(I)},readFrom(A){let g;return g=I.Chunk.readFrom(A),{chunk:g}}},I.MediaBody={encode(A){const I=e.BebopView.getInstance();return I.startWriting(),this.encodeInto(A,I),I.toArray()},encodeInto(A,g){const e=g.length,B=g.reserveMessageLength(),i=g.length+1;switch(g.writeByte(A.discriminator),A.discriminator){case 1:I.VideoData.encodeInto(A.value,g);break;case 2:I.PointerData.encodeInto(A.value,g);break;case 3:I.AudioData.encodeInto(A.value,g);break;case 4:I.MediaChunk.encodeInto(A.value,g)}const Q=g.length;return g.fillMessageLength(B,Q-i),g.length-e},decode(A){const I=e.BebopView.getInstance();return I.startReading(A),this.readFrom(I)},readFrom(A){const g=A.readMessageLength(),B=A.index+1+g;switch(A.readByte()){case 1:return{discriminator:1,value:I.VideoData.readFrom(A)};case 2:return{discriminator:2,value:I.PointerData.readFrom(A)};case 3:return{discriminator:3,value:I.AudioData.readFrom(A)};case 4:return{discriminator:4,value:I.MediaChunk.readFrom(A)};default:throw A.index=B,new e.BebopRuntimeError("Unrecognized discriminator while decoding MediaBody")}}}},14:function(A,I,g){"use strict";var e=this&&this.__createBinding||(Object.create?function(A,I,g,e){void 0===e&&(e=g),Object.defineProperty(A,e,{enumerable:!0,get:function(){return I[g]}})}:function(A,I,g,e){void 0===e&&(e=g),A[e]=I[g]}),B=this&&this.__exportStar||function(A,I){for(var g in A)"default"===g||Object.prototype.hasOwnProperty.call(I,g)||e(I,A,g)};Object.defineProperty(I,"__esModule",{value:!0}),I.RainwayError=I.RainwayStream=I.RainwayRuntime=I.RainwayTransportStatus=I.RainwayTransport=I.RTCTransport=I.friendlyGamepadName=I.RainwayLogLevel=I.RainwayLogging=I.PeerState=I.RainwayChannelMode=I.RainwayPeer=I.RainwayPeerState=void 0;var i=g(783);Object.defineProperty(I,"RainwayPeerState",{enumerable:!0,get:function(){return i.RainwayPeerState}});var Q=g(420);Object.defineProperty(I,"RainwayPeer",{enumerable:!0,get:function(){return Q.RainwayPeer}}),Object.defineProperty(I,"RainwayChannelMode",{enumerable:!0,get:function(){return Q.RainwayChannelMode}}),Object.defineProperty(I,"PeerState",{enumerable:!0,get:function(){return Q.PeerState}});var t=g(464);Object.defineProperty(I,"RainwayLogging",{enumerable:!0,get:function(){return t.RainwayLogging}}),Object.defineProperty(I,"RainwayLogLevel",{enumerable:!0,get:function(){return t.RainwayLogLevel}});var C=g(99);Object.defineProperty(I,"friendlyGamepadName",{enumerable:!0,get:function(){return C.friendlyGamepadName}});var E=g(145);Object.defineProperty(I,"RTCTransport",{enumerable:!0,get:function(){return E.RTCTransport}});var o=g(9);Object.defineProperty(I,"RainwayTransport",{enumerable:!0,get:function(){return o.RainwayTransport}}),Object.defineProperty(I,"RainwayTransportStatus",{enumerable:!0,get:function(){return o.RainwayTransportStatus}});var a=g(783);Object.defineProperty(I,"RainwayRuntime",{enumerable:!0,get:function(){return a.RainwayRuntime}});var n=g(876);Object.defineProperty(I,"RainwayStream",{enumerable:!0,get:function(){return n.RainwayStream}});var s=g(994);Object.defineProperty(I,"RainwayError",{enumerable:!0,get:function(){return s.RainwayError}}),B(g(904),I)},65:(A,I)=>{"use strict";Object.defineProperty(I,"__esModule",{value:!0}),I.RainwayCursorPainter=void 0,I.RainwayCursorPainter=class{constructor(A,I,g,e=100){this.correctRemoteCursor=A,this.transformPointerOffsetToRemote=I,this.getCurrentFrameSize=g,this.cursorSyncInterval=e,this.container=void 0,this.video=void 0,this.canvas=void 0,this.cursorDiv=void 0,this.cursorImg=void 0,this.cursorState={visible:!1,x:0,y:0,spotX:0,spotY:0,extentWidth:0,extentHeight:0},this.wantsRemotePosition=!0,this.videoRect=new DOMRect(0,0,0,0),this.windowWidth=void 0,this.windowHeight=void 0,this.drawDebugDot=!1,this.debugDot=void 0,this.setVideoDimensions=()=>{for(const A of[this.video,this.canvas]){if(!A)continue;const I=A.getBoundingClientRect();if(I.width>0&&I.height>0)return this.videoRect=I,void this.applyCursorDivTransform()}},this.cursorSyncCounter=this.cursorSyncInterval,this.videoResizeObserver=new ResizeObserver((()=>{this.setVideoDimensions()})),["webkitfullscreenchange","mozfullscreenchange","fullscreenchange","MSFullscreenChange"].forEach((A=>{document.addEventListener(A,this.setVideoDimensions,!1)})),window.addEventListener("resize",this.setWindowDimensions)}detach(){["webkitfullscreenchange","mozfullscreenchange","fullscreenchange","MSFullscreenChange"].forEach((A=>{document.removeEventListener(A,this.setVideoDimensions,!1)})),window.removeEventListener("resize",this.setWindowDimensions),this.videoResizeObserver.disconnect()}setWindowDimensions(){this.windowWidth=window.innerWidth,this.windowHeight=window.innerHeight}setContainer(A){this.container=A,A.style.overflow="hidden",this.video&&this.videoResizeObserver.unobserve(this.video),this.canvas&&this.videoResizeObserver.unobserve(this.canvas),this.cursorDiv=void 0;const I=A.childNodes;for(let A=0;A<I.length;A++){const g=I[A];g instanceof HTMLVideoElement?(this.video=g,this.setVideoDimensions(),this.videoResizeObserver.observe(this.video)):g instanceof HTMLCanvasElement&&(g.classList.contains("rainway-canvas")||g.classList.contains("rainway-isolation-canvas"))?(this.canvas=g,this.setVideoDimensions(),this.videoResizeObserver.observe(this.canvas)):g instanceof HTMLDivElement&&(g.className.includes("rainway-cursor")?this.cursorDiv=g:g.className.includes("rainway-debug-dot")&&(this.debugDot=g))}this.cursorDiv||(this.cursorDiv=document.createElement("div"),this.cursorDiv.className="rainway-cursor",this.cursorDiv.style.position="absolute",this.cursorDiv.style.top="0px",this.cursorDiv.style.left="0px",this.cursorDiv.style.zIndex="1",this.cursorDiv.style.pointerEvents="none",this.cursorDiv.style.willChange="transform",this.cursorDiv.style.transformOrigin="top left",this.applyCursorDivTransform(),this.cursorImg=document.createElement("img"),this.cursorDiv.appendChild(this.cursorImg),A.appendChild(this.cursorDiv)),this.drawDebugDot&&!this.debugDot&&(this.debugDot=document.createElement("div"),this.debugDot.className="rainway-debug-dot",this.debugDot.style.position="absolute",this.debugDot.style.top="0px",this.debugDot.style.left="0px",this.debugDot.style.zIndex="1",this.debugDot.style.pointerEvents="none",this.debugDot.style.willChange="transform",this.debugDot.style.transformOrigin="top left",this.debugDot.style.width="3px",this.debugDot.style.height="3px",this.debugDot.style.backgroundColor="#ff0000",A.appendChild(this.debugDot))}unsetContainer(){var A,I;this.detach(),null===(A=this.cursorDiv)||void 0===A||A.remove(),null===(I=this.debugDot)||void 0===I||I.remove(),this.container=void 0}computeTransform(A){var I,g;const{x:e,y:B,spotX:i,spotY:Q}=A,t={left:0,top:0,width:A.extentWidth,height:A.extentHeight},{width:C,height:E}=this.videoRect,o=this.getCurrentFrameSize(),a=o.codecWidth,n=o.codecHeight,s=null!==(I=o.streamBounds)&&void 0!==I?I:t,r=null!==(g=o.fullDesktopBounds)&&void 0!==g?g:t,{left:d,top:h,width:c,height:D}=r,{left:w,top:y,width:u,height:l}=s,S=u*a/c,F=l*n/D,R=Math.min(C/S,E/F),G=Math.round(e-i-(w-d)),k=Math.round(B-Q-(y-h)),U=R*a/c,N=R*n/D;return`translate(${Math.round((C-R*S)/2)}px,${Math.round((E-R*F)/2)}px) scale(${U},${N}) translate(${G}px,${k}px)`}applyCursorDivTransform(){this.cursorDiv&&(this.cursorState.visible?(this.cursorDiv.style.visibility="visible",this.cursorDiv.style.transform=this.computeTransform(this.cursorState)):this.cursorDiv.style.visibility="hidden")}moveDebugDotTo(A){this.debugDot&&(this.debugDot.style.transform=this.computeTransform(A))}processCursor(A){if(this.cursorDiv)if(A.visible&&!this.cursorState.visible&&(this.wantsRemotePosition=!0),this.cursorState.visible=A.visible,this.cursorState.spotX=A.spotX,this.cursorState.spotY=A.spotY,this.cursorState.extentWidth=A.extentWidth,this.cursorState.extentHeight=A.extentHeight,this.drawDebugDot&&this.moveDebugDotTo(A),this.cursorState.visible){if(this.wantsRemotePosition?(this.cursorState.x=A.x,this.cursorState.y=A.y,this.wantsRemotePosition=!1,this.cursorSyncCounter=this.cursorSyncInterval):0==--this.cursorSyncCounter&&(this.correctRemoteCursor(this.cursorState.x,this.cursorState.y),this.cursorSyncCounter=this.cursorSyncInterval),this.cursorDiv.style.width=`${A.shapeWidth}px`,this.cursorDiv.style.height=`${A.shapeHeight}px`,A.hasPointerImage&&this.cursorImg){const I=function(A){let I="";const g=new Uint8Array(A),e=g.byteLength;for(let A=0;A<e;A++)I+=String.fromCharCode(g[A]);return window.btoa(I)}(A.pointerImage);this.cursorImg.src=`data:image/png;base64,${I}`}this.applyCursorDivTransform()}else this.cursorDiv.style.visibility="hidden"}update(A,I,g){if(this.cursorDiv&&("pointermove"===A.type||"mousemove"===A.type)){if("mouse"!==A.pointerType){const A=this.transformPointerOffsetToRemote(I,g);A&&(this.cursorState.x=A.x,this.cursorState.y=A.y)}else{const I=this.cursorState,g=A.movementX,e=A.movementY,B=this.getCurrentFrameSize();if(B.streamBounds){const{top:A,left:i,height:Q,width:t}=B.streamBounds;this.cursorState.x=Math.max(i,Math.min(I.x+g,i+t)),this.cursorState.y=Math.max(A,Math.min(I.y+e,A+Q))}else console.warn("Don't have streamBounds in CursorPainter.update?"),this.cursorState.x=Math.max(0,Math.min(I.x+g,I.extentWidth)),this.cursorState.y=Math.max(0,Math.min(I.y+e,I.extentHeight))}this.applyCursorDivTransform()}}}},99:(A,I)=>{"use strict";Object.defineProperty(I,"__esModule",{value:!0}),I.friendlyGamepadName=void 0;const g={"054c":{"0268":"DualShock 3","05c4":"DualShock 4","09cc":"DualShock 4 (2nd Gen)"},"2dc8":{6101:"N30 Pro"},"0955":{b400:"NVIDIA Shield"},2563:{"0523":"ShanWan PS3 Controller"},"045e":{"02d1":"Xbox One Controller","02dd":"Xbox One Controller (Firmware 2015)","02e3":"Xbox One Elite Controller","02ea":"Xbox One S Controller","02fd":"Xbox One S Controller (Bluetooth)","028f":"Xbox360 Wireless Controller","028e":"Xbox360 Controller","0289":"Xbox Controller S","0285":"Xbox Controller S","0202":"Xbox Controller"},"046d":{c299:"G25 Racing Wheel",c29B:"G27 Racing Wheel",caa3:"DriveFX Racing Wheel",c295:"Momo Force Steering Wheel",c298:"Driving Force Pro"}};I.friendlyGamepadName=function(A,I){var e,B,i,Q;const t=A.id.split("(")[0].trim()||"Unknown gamepad",C=A.id.match(/\b([0-9a-f]{4})\b.*\b([0-9a-f]{4})\b/);if(!C)return t;const E=C[1],o=C[2];return null!==(Q=null!==(B=null===(e=null==I?void 0:I[E])||void 0===e?void 0:e[o])&&void 0!==B?B:null===(i=g[E])||void 0===i?void 0:i[o])&&void 0!==Q?Q:t}},322:(A,I)=>{"use strict";Object.defineProperty(I,"__esModule",{value:!0}),I.RainwayGestureRecognizer=void 0;const g={clickDurationMs:60,dragDelayMs:300,rightClickDelayMs:500,touchSlopRadius:8,doubleTapWindowMs:400,doubleTapRadius:12,scrollGestureThresholdPixels:20,scrollEpsilonPixels:5,scrollSensitivity:4};var e,B,i;function Q(A){return A==B.left?1:A==B.middle?4:A==B.right?2:0}!function(A){A[A.idle=0]="idle",A[A.oneFingerDeciding=1]="oneFingerDeciding",A[A.twoFingersDeciding=2]="twoFingersDeciding",A[A.moving=3]="moving",A[A.dragging=4]="dragging",A[A.holdingRightMouseButton=5]="holdingRightMouseButton",A[A.zooming=6]="zooming",A[A.scrolling=7]="scrolling"}(e||(e={})),function(A){A[A.left=0]="left",A[A.middle=1]="middle",A[A.right=2]="right"}(B||(B={})),function(A){A[A.pixels=0]="pixels",A[A.lines=1]="lines",A[A.pages=2]="pages"}(i||(i={})),I.RainwayGestureRecognizer=class{constructor(A,I,i=g){this.reportPointerEvent=A,this.reportWheelEvent=I,this.parameters=i,this.state=e.idle,this.primary=void 0,this.secondary=void 0,this.centroidY=0,this.lastTapTime=new Date,this.rightClickTimer=void 0,this.rightClick=()=>{this.reportMouseDown(B.right),this.toState(e.holdingRightMouseButton),this.rightClickTimer=void 0},this.tapReleaseTimer=void 0,this.tapRelease=()=>{this.reportMouseUp(B.left),this.toState(e.idle),this.rightClickTimer=void 0},this.onPointerDown=A=>{const I={pointerId:A.pointerId,homeOffsetX:A.offsetX,homeOffsetY:A.offsetY,currentOffsetX:A.offsetX,currentOffsetY:A.offsetY,downTime:new Date,awake:!1};void 0===this.primary?(this.toState(e.oneFingerDeciding),this.primary=I,window.clearTimeout(this.rightClickTimer),this.rightClickTimer=window.setTimeout(this.rightClick,this.parameters.rightClickDelayMs)):void 0===this.secondary&&(this.toState(e.twoFingersDeciding),this.secondary=I,window.clearTimeout(this.rightClickTimer))},this.onPointerUp=A=>{var I;window.clearTimeout(this.rightClickTimer);const g=A.pointerId===(null===(I=this.primary)||void 0===I?void 0:I.pointerId);if(this.state===e.oneFingerDeciding&&g){this.log("pointer up from deciding, tapping"),window.clearTimeout(this.rightClickTimer);const I=Object.assign(Object.assign({},A),{offsetX:A.offsetX,offsetY:A.offsetY,pointerType:"touch",type:"pointermove"});this.reportPointerEvent(I),this.reportMouseDown(B.left),this.primary=void 0,this.lastTapTime=new Date,this.tapReleaseTimer=window.setTimeout(this.tapRelease,this.parameters.clickDurationMs)}else this.primary&&this.secondary?(this.log("stopping two finger gesture"),this.primary=void 0,this.secondary=void 0,this.toState(e.idle)):this.state===e.moving&&g?(this.log("stop moving"),this.primary=void 0,this.toState(e.idle)):this.state===e.dragging&&g?(this.log("stop dragging"),this.reportMouseUp(B.left),this.primary=void 0,this.toState(e.idle)):this.state===e.holdingRightMouseButton&&g&&(this.log("stop right click"),this.reportMouseUp(B.right),this.primary=void 0,this.toState(e.idle))},this.onPointerMove=A=>{var I,g;const i=A.pointerId===(null===(I=this.primary)||void 0===I?void 0:I.pointerId),Q=A.pointerId===(null===(g=this.secondary)||void 0===g?void 0:g.pointerId);if(this.primary&&i?(this.primary.currentOffsetX=A.offsetX,this.primary.currentOffsetY=A.offsetY):this.secondary&&Q&&(this.secondary.currentOffsetX=A.offsetX,this.secondary.currentOffsetY=A.offsetY),this.primary&&i&&!this.secondary)this.state===e.oneFingerDeciding&&function(A,I){const g=A.currentOffsetX-A.homeOffsetX,e=A.currentOffsetY-A.homeOffsetY;return g*g+e*e>I*I}(this.primary,this.parameters.touchSlopRadius)?(this.log("left touch slop radius"),window.clearTimeout(this.rightClickTimer),this.primary.awake=!0,(new Date).valueOf()-this.lastTapTime.valueOf()<this.parameters.dragDelayMs?(this.reportMouseDown(B.left),this.toState(e.dragging)):this.toState(e.moving)):this.state!==e.dragging&&this.state!==e.moving&&this.state!==e.holdingRightMouseButton||this.reportPointerEvent(A);else if(this.primary&&this.secondary)if(this.state===e.twoFingersDeciding){const A=this.primary.currentOffsetY-this.primary.homeOffsetY,I=this.secondary.currentOffsetY-this.secondary.homeOffsetY,g=this.parameters.scrollGestureThresholdPixels;(A>g&&I>g||A<g&&I<g)&&(this.toState(e.scrolling),this.centroidY=(A+I)/2)}else if(this.state===e.scrolling){const A=this.parameters.scrollEpsilonPixels,I=(this.primary.currentOffsetY-this.primary.homeOffsetY+(this.secondary.currentOffsetY-this.secondary.homeOffsetY))/2;I>this.centroidY+A?(this.reportScroll(this.parameters.scrollSensitivity*A),this.centroidY=I):I<this.centroidY-A&&(this.reportScroll(this.parameters.scrollSensitivity*-A),this.centroidY=I)}}}log(...A){}reportMouseUp(A){this.log("--\x3e report pointerup",A);const I=new PointerEvent("pointerup",{pointerType:"mouse",buttons:0,button:A});this.reportPointerEvent(I)}reportMouseDown(A){this.log("--\x3e report pointerdown",A);const I=new PointerEvent("pointerdown",{pointerType:"mouse",buttons:Q(A),button:A});this.reportPointerEvent(I)}reportScroll(A){const I=new WheelEvent("syntheticWheel",{deltaY:A,deltaMode:i.pixels});this.reportWheelEvent(I)}toState(A){this.log(["idle","oneFingerDeciding","twoFingersDeciding","moving","dragging","holdingRightMouseButton","zooming","scrolling"][A]),this.state=A}processPointerEvent(A){if("touch"===A.pointerType)switch(A.type){case"pointerdown":this.onPointerDown(A);break;case"pointerup":this.onPointerUp(A);break;case"pointerrawupdate":case"pointermove":this.onPointerMove(A)}else this.reportPointerEvent(A)}}},824:(A,I,g)=>{"use strict";Object.defineProperty(I,"__esModule",{value:!0}),I.RainwayInputManager=I.mouseClickFrom=void 0;const e=g(994),B=g(904),i=g(40),Q=g(322),t=g(65),C=g(528),E=g(904);function o(A){let I,g;switch(A.button){default:case 0:I=0!=(1&A.buttons),g=E.MouseButton.Left;break;case 1:I=0!=(4&A.buttons),g=E.MouseButton.Middle;break;case 2:I=0!=(2&A.buttons),g=E.MouseButton.Right;break;case 3:I=0!=(8&A.buttons),g=E.MouseButton.X1;break;case 4:I=0!=(16&A.buttons),g=E.MouseButton.X2}return{button:g,action:I?E.ButtonAction.ButtonDown:E.ButtonAction.ButtonUp}}function a(A){return A.axes.length>=4&&A.buttons.length>=16}function n(A,I){if(A===I)return!0;if(A.length!==I.length)return!1;for(let g=0;g<A.length;++g)if(A[g]!==I[g])return!1;return!0}I.mouseClickFrom=o,I.RainwayInputManager=class{constructor(A,I={touchGestures:!1,unlockedMousePointer:!1,embraceMouseAcceleration:!1}){this.rainwayStream=A,this.options=I,this.level=B.InputLevel.None,this.container=void 0,this.heldCodes=new Set,this.alwaysReportGamepadPoll=!0,this.lockPointer=()=>{if(this.options.unlockedMousePointer)return;if(!this.container)return;if(!this.container.requestPointerLock)return;const A=!this.options.embraceMouseAcceleration,I=A?this.container.requestPointerLock({unadjustedMovement:!0}):this.container.requestPointerLock();I instanceof Promise?I.catch((I=>{var g;"NotSupportedError"===I.name&&A&&(null===(g=this.container)||void 0===g||g.requestPointerLock())})):this.container.onpointerlockerror=()=>{var I;A&&(null===(I=this.container)||void 0===I||I.requestPointerLock())},this.container.focus()},this.focusContainer=()=>{var A;return null===(A=this.container)||void 0===A?void 0:A.focus()},this.onPointerEventWithGestureProcessing=A=>{(A.pointerType&&"mouse"!==A.pointerType||document.pointerLockElement===this.container)&&(this.options.touchGestures&&"touch"===A.pointerType?(A.preventDefault(),this.gestureRecognizer.processPointerEvent(A)):this.onPointerEvent(A))},this.onPointerEventFromGestureRecognizer=A=>{this.onPointerEvent(A)},this.onPointerEvent=A=>{this.cursorPainter.update(A,this.rememberedOffsetX,this.rememberedOffsetY),this.reportPointerEvent(A)},this.scrolledAmount=0,this.onWheelEvent=A=>{this.scrolledAmount+=.05*A.deltaY,this.scrolledAmount>=1?(this.sendVerticalScroll(Math.floor(this.scrolledAmount)),this.scrolledAmount%=1):this.scrolledAmount<=-1&&(this.sendVerticalScroll(Math.ceil(this.scrolledAmount)),this.scrolledAmount%=-1)},this.onKeyboardEvent=A=>{A.preventDefault(),"keydown"===A.type?this.heldCodes.add(A.code):"keyup"===A.type&&this.heldCodes.delete(A.code);const I=i.RainwayVirtualKeyFromWebKeyCode[A.code];I&&this.sendInputDatagram({discriminator:E.KeyboardInput.discriminator,value:{action:"keydown"===A.type?E.KeyboardAction.KeyDown:E.KeyboardAction.KeyUp,keycodes:[I]}})},this.onGamepadConnectedEvent=A=>{},this.onGamepadDisconnectedEvent=A=>{},this.onDeviceMotion=A=>{},this.onDeviceOrientation=A=>{},this.gamepadCache=new Map,this.pollGamepads=A=>{if(navigator.getGamepads){if(this.container===document.activeElement){const A=[];for(const I of navigator.getGamepads()){if(!I||!a(I))continue;const g=I.buttons.map((A=>A.value)),e=this.gamepadCache.get(I.index);e&&n(e.axes,I.axes)&&n(e.buttonValues,g)||(A.push(this.makeGamepadInputEvent(I)),this.gamepadCache.set(I.index,{axes:[...I.axes],buttonValues:g}))}(this.alwaysReportGamepadPoll||A.length>0)&&this.reportGamepadEvents(A)}this.level&B.InputLevel.Gamepad&&(this.gamepadFrameHandle=window.requestAnimationFrame(this.pollGamepads))}},this.reportGamepadEvents=A=>{for(const I of A){let A=0;I.buttons.dpadUp&&(A|=1),I.buttons.dpadDown&&(A|=2),I.buttons.dpadLeft&&(A|=4),I.buttons.dpadRight&&(A|=8),I.buttons.start&&(A|=16),I.buttons.select&&(A|=32),I.buttons.leftStickPressed&&(A|=64),I.buttons.rightStickPressed&&(A|=128),I.buttons.leftShoulder&&(A|=256),I.buttons.rightShoulder&&(A|=512),I.buttons.a&&(A|=4096),I.buttons.b&&(A|=8192),I.buttons.x&&(A|=16384),I.buttons.y&&(A|=32768);const g={buttons:A,leftTrigger:Math.round(255*I.buttons.leftTrigger),rightTrigger:Math.round(255*I.buttons.rightTrigger),leftThumbX:Math.round(32767*I.sticks.left.x),leftThumbY:Math.round(32767*-I.sticks.left.y),rightThumbX:Math.round(32767*I.sticks.right.x),rightThumbY:Math.round(32767*-I.sticks.right.y),slot:1};this.sendInputDatagram({discriminator:E.GamepadReport.discriminator,value:g})}},this.moveMouseRelativeXY=(A,I)=>{this.sendMouseMove("relative",A,I)},this.moveMouseAbsoluteXY=(A,I)=>{this.sendMouseMove("absolute",A,I)},this.pointerFrameId=0,this.rememberedOffsetX=0,this.rememberedOffsetY=0,this.touches=new Map,this.reportPointerEvent=A=>{if("touch"===A.pointerType||"pen"===A.pointerType){if(document.pointerLockElement===this.container){const I=this.container.clientWidth,g=this.container.clientHeight,e=A.movementX,B=A.movementY;this.rememberedOffsetX=Math.max(0,Math.min(I,this.rememberedOffsetX+e)),this.rememberedOffsetY=Math.max(0,Math.min(g,this.rememberedOffsetY+B))}else this.rememberedOffsetX=A.offsetX,this.rememberedOffsetY=A.offsetY;const I=this.rainwayStream.transformPointerOffsetToRemote(this.rememberedOffsetX,this.rememberedOffsetY);if(!I)return;const{x:g,y:e}=I,i=Math.ceil(A.width/2),Q=Math.ceil(A.height/2),{pointerId:t,buttons:C}=A,E="pointercancel"===A.type||"pointerout"===A.type||"pointerleave"===A.type,o=C>0,a=("pointerover"===A.type?B.WindowsPointerFlags.New:0)|(o?B.WindowsPointerFlags.InContact:0)|(1==(3&C)?B.WindowsPointerFlags.FirstButton:0)|(3==(3&C)?B.WindowsPointerFlags.SecondButton:0)|(A.isPrimary?B.WindowsPointerFlags.Primary:0)|("pointercancel"===A.type?B.WindowsPointerFlags.Canceled:0)|("pointerdown"===A.type?B.WindowsPointerFlags.Down:"pointerup"===A.type?B.WindowsPointerFlags.Up:B.WindowsPointerFlags.Update)|(E?o?B.WindowsPointerFlags.Up:B.WindowsPointerFlags.Update:B.WindowsPointerFlags.InRange),n={pointerId:t,frameId:++this.pointerFrameId,pointerFlags:a,x:g,y:e},s=Math.round(A.twist)%360,r=Math.round(1024*A.pressure);if("touch"===A.pointerType){const A={pointerInfo:n,touchMask:B.TouchMask.ContactArea|B.TouchMask.Orientation|B.TouchMask.Pressure,contactLeft:g-i,contactTop:e-Q,contactRight:g+i,contactBottom:e+Q,orientation:s,pressure:r};this.touches.set(t,A),this.sendInputDatagram({discriminator:B.TouchesAbsolute.discriminator,value:{touches:[...this.touches.values()]}}),E&&this.touches.delete(t)}else{const I=(2&C?B.PenFlags.Barrel:0)|(32&C?B.PenFlags.Eraser:0);this.sendInputDatagram({discriminator:B.PenAbsolute.discriminator,value:{pointerInfo:n,penMask:B.PenMask.Pressure|B.PenMask.Rotation|B.PenMask.TiltX|B.PenMask.TiltY,penFlags:I,rotation:s,pressure:r,tiltX:Math.round(A.tiltX),tiltY:Math.round(A.tiltY)}})}}else if((A.movementX||A.movementY)&&this.sendMouseMove("relative",A.movementX,A.movementY),A.button>-1){const I=o(A);this.sendMouseClick(I)}},this.cursorPainter=new t.RainwayCursorPainter(this.moveMouseAbsoluteXY,((A,I)=>this.rainwayStream.transformPointerOffsetToRemote(A,I)),(()=>this.rainwayStream.currentFrameSize)),this.gestureRecognizer=new Q.RainwayGestureRecognizer(this.onPointerEventFromGestureRecognizer,this.onWheelEvent)}setContainer(A){if(this.cursorPainter.setContainer(A),this.container){const I=this.level;this.setInputLevel(B.InputLevel.None,!1),this.container=A,this.setInputLevel(I,!1)}else this.container=A}unsetContainer(){this.setInputLevel(B.InputLevel.None,!1),this.cursorPainter.unsetContainer(),this.container=void 0}setInputLevel(A,I=!0,g=!0){this.alwaysReportGamepadPoll=g;const e=A&~this.level,i=this.level&~A;this.level=A,e&B.InputLevel.Gamepad&&this.startGamepad(I),i&B.InputLevel.Gamepad&&this.stopGamepad(),e&B.InputLevel.Mouse&&this.startMouse(),i&B.InputLevel.Mouse&&this.stopMouse(),e&B.InputLevel.Keyboard&&this.startKeyboard(),i&B.InputLevel.Keyboard&&this.stopKeyboard()}getInputLevel(){return this.level}startGamepad(A){window.addEventListener("gamepadconnected",this.onGamepadConnectedEvent),window.addEventListener("gamepaddisconnected",this.onGamepadDisconnectedEvent),this.gamepadFrameHandle=window.requestAnimationFrame(this.pollGamepads),A&&this.reportConnectedGamepads()}reportConnectedGamepads(){for(const A of navigator.getGamepads())A&&this.onGamepadConnectedEvent(new GamepadEvent("gamepadconnected",{gamepad:A}))}stopGamepad(){window.removeEventListener("gamepadconnected",this.onGamepadConnectedEvent),window.removeEventListener("gamepaddisconnected",this.onGamepadDisconnectedEvent),this.gamepadFrameHandle&&window.cancelAnimationFrame(this.gamepadFrameHandle),this.gamepadFrameHandle=void 0}pointerEventListeners(A){if(!window.PointerEvent)throw new Error("browser does not support PointerEvent");A(C.isDesktopSafari&&navigator.maxTouchPoints<1?"mousemove":window.onpointerrawupdate?"pointerrawupdate":"pointermove",this.onPointerEventWithGestureProcessing),A("pointerdown",this.onPointerEventWithGestureProcessing),A("pointerup",this.onPointerEventWithGestureProcessing),A("pointerover",this.onPointerEventWithGestureProcessing),A("pointerenter",this.onPointerEventWithGestureProcessing),A("pointercancel",this.onPointerEventWithGestureProcessing),A("pointerout",this.onPointerEventWithGestureProcessing),A("pointerleave",this.onPointerEventWithGestureProcessing),A("wheel",this.onWheelEvent),A("mouseup",this.lockPointer)}startMouse(){if(!this.container)throw new e.RainwayError("Rainway tried to add an event listener to its container to handle mouse input, but no container element is set. Try calling setContainer() first.");this.pointerEventListeners(this.container.addEventListener.bind(this.container))}stopMouse(){this.container&&this.pointerEventListeners(this.container.removeEventListener.bind(this.container))}startKeyboard(){if(!this.container)throw new e.RainwayError("Rainway tried to add an event listener to its container to handle keyboard input, but no container element is set. Try calling setContainer() first.");this.container.addEventListener("keydown",this.onKeyboardEvent),this.container.addEventListener("keyup",this.onKeyboardEvent),this.container.addEventListener("click",this.focusContainer),this.container.focus()}stopKeyboard(){this.container&&(this.releaseKeys(),this.container.removeEventListener("keydown",this.onKeyboardEvent),this.container.removeEventListener("keyup",this.onKeyboardEvent),this.container.removeEventListener("click",this.focusContainer))}startDeviceMotionEvents(){window.addEventListener("devicemotion",this.onDeviceMotion)}stopDeviceMotionEvents(){window.removeEventListener("devicemotion",this.onDeviceMotion)}startDeviceOrientationEvents(){window.addEventListener("deviceorientation",this.onDeviceOrientation)}stopDeviceOrientationEvents(){window.removeEventListener("deviceorientation",this.onDeviceOrientation)}sendVerticalScroll(A){this.sendInputDatagram({discriminator:E.MouseScroll.discriminator,value:{axis:E.ScrollAxis.Vertical,delta:A}})}makeGamepadInputEvent(A){var I,g,e,B,i,Q,t,C,E,o,a,n,s,r,d,h,c,D,w,y,u,l,S,F,R,G,k,U,N,m,p,f,M,L,H,K,q,J;return{id:A.id,index:A.index,buttons:{a:null!==(g=null===(I=A.buttons[0])||void 0===I?void 0:I.value)&&void 0!==g?g:0,b:null!==(B=null===(e=A.buttons[1])||void 0===e?void 0:e.value)&&void 0!==B?B:0,x:null!==(Q=null===(i=A.buttons[2])||void 0===i?void 0:i.value)&&void 0!==Q?Q:0,y:null!==(C=null===(t=A.buttons[3])||void 0===t?void 0:t.value)&&void 0!==C?C:0,leftShoulder:null!==(o=null===(E=A.buttons[4])||void 0===E?void 0:E.value)&&void 0!==o?o:0,rightShoulder:null!==(n=null===(a=A.buttons[5])||void 0===a?void 0:a.value)&&void 0!==n?n:0,leftTrigger:null!==(r=null===(s=A.buttons[6])||void 0===s?void 0:s.value)&&void 0!==r?r:0,rightTrigger:null!==(h=null===(d=A.buttons[7])||void 0===d?void 0:d.value)&&void 0!==h?h:0,select:null!==(D=null===(c=A.buttons[8])||void 0===c?void 0:c.value)&&void 0!==D?D:0,start:null!==(y=null===(w=A.buttons[9])||void 0===w?void 0:w.value)&&void 0!==y?y:0,leftStickPressed:null!==(l=null===(u=A.buttons[10])||void 0===u?void 0:u.value)&&void 0!==l?l:0,rightStickPressed:null!==(F=null===(S=A.buttons[11])||void 0===S?void 0:S.value)&&void 0!==F?F:0,dpadUp:null!==(G=null===(R=A.buttons[12])||void 0===R?void 0:R.value)&&void 0!==G?G:0,dpadDown:null!==(U=null===(k=A.buttons[13])||void 0===k?void 0:k.value)&&void 0!==U?U:0,dpadLeft:null!==(m=null===(N=A.buttons[14])||void 0===N?void 0:N.value)&&void 0!==m?m:0,dpadRight:null!==(f=null===(p=A.buttons[15])||void 0===p?void 0:p.value)&&void 0!==f?f:0,home:null!==(L=null===(M=A.buttons[16])||void 0===M?void 0:M.value)&&void 0!==L?L:0},sticks:{left:{x:null!==(H=A.axes[0])&&void 0!==H?H:0,y:null!==(K=A.axes[1])&&void 0!==K?K:0},right:{x:null!==(q=A.axes[2])&&void 0!==q?q:0,y:null!==(J=A.axes[3])&&void 0!==J?J:0}}}}feedGamepadInputEvent(A){this.reportGamepadEvents(A)}static vibrateGamepad(A,I){var g,e;const B=navigator.getGamepads()[A];if(null==B?void 0:B.vibrationActuator)null===(e=(g=B.vibrationActuator).playEffect)||void 0===e||e.call(g,"dual-rumble",I);else if(null==B?void 0:B.hapticActuators){const A=null==B?void 0:B.hapticActuators;setTimeout((()=>{var g,e,B;for(const i of A)if("pulse"in i){const A=Math.max(null!==(g=I.strongMagnitude)&&void 0!==g?g:0,null!==(e=I.weakMagnitude)&&void 0!==e?e:0);i.pulse(A,null!==(B=I.duration)&&void 0!==B?B:0)}}),I.startDelay)}}feedKeyboardEvent(A){this.onKeyboardEvent(A)}releaseKeys(){for(const A of this.heldCodes)this.onKeyboardEvent(new KeyboardEvent("keyup",{code:A}));this.heldCodes.clear()}feedPointerEvent(A){this.onPointerEvent(A)}feedWheelEvent(A){this.onWheelEvent(A)}processCursor(A){this.cursorPainter.processCursor(A)}enableGestures(){this.options.touchGestures=!0}disableGestures(){this.options.touchGestures=!1}sendMouseMove(A,I,g){"absolute"===A?this.sendInputDatagram({discriminator:E.MouseAbsolute.discriminator,value:{x:I,y:g}}):this.sendInputDatagram({discriminator:E.MouseRelative.discriminator,value:{dx:I,dy:g}})}sendMouseClick(A){this.sendInputDatagram({discriminator:E.MouseClick.discriminator,value:A})}sendInputDatagram(A){this.rainwayStream.sendInput(A)}dispose(){this.unsetContainer()}}},40:(A,I,g)=>{"use strict";Object.defineProperty(I,"__esModule",{value:!0}),I.RainwayVirtualKeyFromWebKeyCode=void 0;const e=g(904);I.RainwayVirtualKeyFromWebKeyCode={Unidentified:e.VirtualKey.None,Cancel:e.VirtualKey.Cancel,Backspace:e.VirtualKey.Back,Tab:e.VirtualKey.Tab,Enter:e.VirtualKey.Enter,Pause:e.VirtualKey.Pause,CapsLock:e.VirtualKey.CapsLock,HangulMode:e.VirtualKey.HangulMode,KanaMode:e.VirtualKey.HangulMode,Lang1:e.VirtualKey.HangulMode,Hanja:e.VirtualKey.HanjaMode,Lang2:e.VirtualKey.HanjaMode,Escape:e.VirtualKey.Escape,Convert:e.VirtualKey.ImeConvert,NonConvert:e.VirtualKey.ImeNonConvert,Space:e.VirtualKey.Space," ":e.VirtualKey.Space,Spacebar:e.VirtualKey.Space,PageUp:e.VirtualKey.PageUp,PageDown:e.VirtualKey.PageDown,End:e.VirtualKey.End,Home:e.VirtualKey.Home,ArrowLeft:e.VirtualKey.Left,ArrowUp:e.VirtualKey.Up,ArrowRight:e.VirtualKey.Right,ArrowDown:e.VirtualKey.Down,Select:e.VirtualKey.Select,PrintScreen:e.VirtualKey.PrintScreen,Insert:e.VirtualKey.Insert,Delete:e.VirtualKey.Delete,Help:e.VirtualKey.Help,Digit0:e.VirtualKey.D0,Digit1:e.VirtualKey.D1,Digit2:e.VirtualKey.D2,Digit3:e.VirtualKey.D3,Digit4:e.VirtualKey.D4,Digit5:e.VirtualKey.D5,Digit6:e.VirtualKey.D6,Digit7:e.VirtualKey.D7,Digit8:e.VirtualKey.D8,Digit9:e.VirtualKey.D9,KeyA:e.VirtualKey.A,KeyB:e.VirtualKey.B,KeyC:e.VirtualKey.C,KeyD:e.VirtualKey.D,KeyE:e.VirtualKey.E,KeyF:e.VirtualKey.F,KeyG:e.VirtualKey.G,KeyH:e.VirtualKey.H,KeyI:e.VirtualKey.I,KeyJ:e.VirtualKey.J,KeyK:e.VirtualKey.K,KeyL:e.VirtualKey.L,KeyM:e.VirtualKey.M,KeyN:e.VirtualKey.N,KeyO:e.VirtualKey.O,KeyP:e.VirtualKey.P,KeyQ:e.VirtualKey.Q,KeyR:e.VirtualKey.R,KeyS:e.VirtualKey.S,KeyT:e.VirtualKey.T,KeyU:e.VirtualKey.U,KeyV:e.VirtualKey.V,KeyW:e.VirtualKey.W,KeyX:e.VirtualKey.X,KeyY:e.VirtualKey.Y,KeyZ:e.VirtualKey.Z,MetaLeft:e.VirtualKey.LWin,OSLeft:e.VirtualKey.LWin,MetaRight:e.VirtualKey.RWin,OSRight:e.VirtualKey.RWin,ContextMenu:e.VirtualKey.Apps,Sleep:e.VirtualKey.Sleep,Numpad0:e.VirtualKey.NumPad0,Numpad1:e.VirtualKey.NumPad1,Numpad2:e.VirtualKey.NumPad2,Numpad3:e.VirtualKey.NumPad3,Numpad4:e.VirtualKey.NumPad4,Numpad5:e.VirtualKey.NumPad5,Numpad6:e.VirtualKey.NumPad6,Numpad7:e.VirtualKey.NumPad7,Numpad8:e.VirtualKey.NumPad8,Numpad9:e.VirtualKey.NumPad9,NumpadMultiply:e.VirtualKey.Multiply,NumpadAdd:e.VirtualKey.Add,NumpadComma:e.VirtualKey.Separator,NumpadSubtract:e.VirtualKey.Subtract,NumpadDecimal:e.VirtualKey.Decimal,NumpadDivide:e.VirtualKey.Divide,F1:e.VirtualKey.F1,F2:e.VirtualKey.F2,F3:e.VirtualKey.F3,F4:e.VirtualKey.F4,F5:e.VirtualKey.F5,F6:e.VirtualKey.F6,F7:e.VirtualKey.F7,F8:e.VirtualKey.F8,F9:e.VirtualKey.F9,F10:e.VirtualKey.F10,F11:e.VirtualKey.F11,F12:e.VirtualKey.F12,F13:e.VirtualKey.F13,F14:e.VirtualKey.F14,F15:e.VirtualKey.F15,F16:e.VirtualKey.F16,F17:e.VirtualKey.F17,F18:e.VirtualKey.F18,F19:e.VirtualKey.F19,F20:e.VirtualKey.F20,F21:e.VirtualKey.F21,F22:e.VirtualKey.F22,F23:e.VirtualKey.F23,F24:e.VirtualKey.F24,NumLock:e.VirtualKey.NumLock,ScrollLock:e.VirtualKey.Scroll,ShiftLeft:e.VirtualKey.LeftShift,ShiftRight:e.VirtualKey.RightShift,ControlLeft:e.VirtualKey.LeftCtrl,ControlRight:e.VirtualKey.RightCtrl,AltLeft:e.VirtualKey.LeftAlt,AltRight:e.VirtualKey.RightAlt,BrowserBack:e.VirtualKey.BrowserBack,BrowserForward:e.VirtualKey.BrowserForward,BrowserRefresh:e.VirtualKey.BrowserRefresh,BrowserStop:e.VirtualKey.BrowserStop,BrowserSearch:e.VirtualKey.BrowserSearch,BrowserFavorites:e.VirtualKey.BrowserFavorites,BrowserHome:e.VirtualKey.BrowserHome,AudioVolumeMute:e.VirtualKey.VolumeMute,AudioVolumeDown:e.VirtualKey.VolumeDown,AudioVolumeUp:e.VirtualKey.VolumeUp,MediaTrackNext:e.VirtualKey.MediaNextTrack,MediaTrackPrevious:e.VirtualKey.MediaPreviousTrack,MediaStop:e.VirtualKey.MediaStop,MediaPlayPause:e.VirtualKey.MediaPlayPause,LaunchMail:e.VirtualKey.LaunchMail,LaunchMediaPlayer:e.VirtualKey.SelectMedia,MediaSelect:e.VirtualKey.SelectMedia,LaunchApp1:e.VirtualKey.LaunchApplication1,LaunchApp2:e.VirtualKey.LaunchApplication2,Semicolon:e.VirtualKey.Oem1,Equal:e.VirtualKey.OemPlus,Comma:e.VirtualKey.OemComma,Minus:e.VirtualKey.OemMinus,Period:e.VirtualKey.OemPeriod,Slash:e.VirtualKey.Oem2,Backquote:e.VirtualKey.Oem3,BracketLeft:e.VirtualKey.Oem4,Backslash:e.VirtualKey.Oem5,BracketRight:e.VirtualKey.Oem6,Quote:e.VirtualKey.Oem7,IntlBackslash:e.VirtualKey.Oem102}},464:(A,I)=>{"use strict";var g;Object.defineProperty(I,"__esModule",{value:!0}),I.RainwayLogging=I.RainwayLogLevel=void 0,function(A){A[A.Trace=0]="Trace",A[A.Debug=1]="Debug",A[A.Information=2]="Information",A[A.Warning=3]="Warning",A[A.Error=4]="Error",A[A.Critical=5]="Critical",A[A.Silent=6]="Silent"}(g=I.RainwayLogLevel||(I.RainwayLogLevel={}));class e{static setLogSink(A){e._logSink=A}static log(A,I){var g;null===(g=e._logSink)||void 0===g||g.call(e,A,I)}}I.RainwayLogging=e,e.trace=A=>e.log(g.Trace,A),e.debug=A=>e.log(g.Debug,A),e.information=A=>e.log(g.Information,A),e.warning=A=>e.log(g.Warning,A),e.error=A=>e.log(g.Error,A),e.critical=A=>e.log(g.Critical,A)},585:function(A,I,g){"use strict";var e=this&&this.__awaiter||function(A,I,g,e){return new(g||(g=Promise))((function(B,i){function Q(A){try{C(e.next(A))}catch(A){i(A)}}function t(A){try{C(e.throw(A))}catch(A){i(A)}}function C(A){var I;A.done?B(A.value):(I=A.value,I instanceof g?I:new g((function(A){A(I)}))).then(Q,t)}C((e=e.apply(A,I||[])).next())}))},B=this&&this.__importDefault||function(A){return A&&A.__esModule?A:{default:A}};Object.defineProperty(I,"__esModule",{value:!0}),I.AudioStream=void 0;const i=B(g(53)),Q=g(994),t=g(464);I.AudioStream=class{constructor(){this.sampleRateHz=48e3,this.sampleRateKhz=48,this.channelCount=2,this.decodedCount=0,this.totalSamplesDecoded=0,this.waitingToDecodeQueue=[],this.decodeQueueSize=0,this.logPerformance=!1,this.maxDecodingTimeMs=0,this.totalDecodingTimeMs=0,this.totalQueuedSize=0,this.maxQueuedSize=0,this.startStreamTimeMs=0,this.outputBuffers=[],this.currentOutputBuffer=void 0,this.currentBufferReadIndex=0,this.nextStartTime=void 0,this.playing=!1,this.dataDurationMs=10,this.minLatencyMs=60,this.maxLatencyMs=100,this.prevDroppedFrameTimeMs=void 0,this.decodedSamplesPerFrame=0,this.audioBufferSize=0,this.audioBufferPool=[],this.maxAudioBufferPoolCount=5,this.resampledAudioBufferSize=0,this.onDecode=({startTimestamp:A,outputData:I,samplesDecoded:g})=>{--this.decodeQueueSize;const e=new Float32Array(I);this.outputBuffers.push(e);try{if(g>0&&(++this.decodedCount,this.totalSamplesDecoded+=g,this.logPerformance&&this.logPerfTiming(A),this.totalSamplesDecoded>=this.audioBufferSize&&(this.nextStartTime&&this.nextStartTime<this.audioContext.currentTime&&(this.nextStartTime=void 0),this.nextStartTime||this.totalSamplesDecoded>=2*this.audioBufferSize))){const A=Math.floor(this.totalSamplesDecoded/this.audioBufferSize);for(let I=0;I<A;++I){const A=this.nextStartTime?1e3*(this.nextStartTime-this.audioContext.currentTime):0;if(A>this.maxLatencyMs){let I=0;const g=Date.now(),e=this.prevDroppedFrameTimeMs?g-this.prevDroppedFrameTimeMs:void 0,B=1e4;if(e&&e<B)I=this.dropDecodedSamples(this.totalSamplesDecoded);else{const g=A-this.maxLatencyMs+this.dataDurationMs,e=Math.floor(this.sampleRateKhz*g);I=this.dropDecodedSamples(e)}this.prevDroppedFrameTimeMs=g,this.totalSamplesDecoded-=I}if(!(this.totalSamplesDecoded>=this.audioBufferSize))break;{const A=this.copyDecodedSamplesToAudioBuffer();this.scheduleBufferForPlaybackFunc(A),this.totalSamplesDecoded-=A.length}}}}catch(A){t.RainwayLogging.warning("Caught exception in AudioStream onDecode: "+A+" "+A.stack),this.stop(),this.play()}this.sendDecoderWaitingToDecodeFrames()}}initialize(){return e(this,void 0,void 0,(function*(){this.opusDecoderWorker=new i.default,yield this.opusDecoderWorker.initialize(),this.opusDecoderWorker.onDecode=this.onDecode.bind(this)}))}dispose(){var A;null===(A=this.opusDecoderWorker)||void 0===A||A.dispose(),this.opusDecoderWorker=void 0}configure({audioContext:A,sampleRateHz:I,channelCount:g,dataDurationMs:e,minLatencyMs:B,maxLatencyMs:i}){if(this.sampleRateHz=null!=I?I:this.sampleRateHz,8e3!=this.sampleRateHz&&12e3!=this.sampleRateHz&&16e3!=this.sampleRateHz&&24e3!=this.sampleRateHz&&48e3!=this.sampleRateHz)throw new Q.RainwayError(`invalid audio sample rate: ${this.sampleRateHz} (must be 8000, 12000, 16000, 24000, or 48000)`);if(this.sampleRateKhz=this.sampleRateHz/1e3,this.channelCount=null!=g?g:this.channelCount,1!=this.channelCount&&2!=this.channelCount&&6!=this.channelCount)throw new Q.RainwayError(`invalid channel count: ${this.channelCount} (must be 1, 2, or 6)`);if(this.dataDurationMs=null!=e?e:this.dataDurationMs,this.minLatencyMs=null!=B?B:this.minLatencyMs,this.maxLatencyMs=null!=i?i:this.maxLatencyMs,this.dataDurationMs<=0)throw new Q.RainwayError(`dataDurationMs must be positive, but is ${this.dataDurationMs}`);if(this.dataDurationMs>this.minLatencyMs)throw new Q.RainwayError("dataDurationMs may not exceed minLatencyMs");if(this.maxLatencyMs<=this.minLatencyMs)throw new Q.RainwayError("maxLatencyMs must be greater than minLatencyMs");this.decodedSamplesPerFrame=this.dataDurationMs*this.sampleRateKhz,this.currentOutputBuffer=void 0,this.currentBufferReadIndex=0;const C=this.sampleRateKhz*this.minLatencyMs;this.audioBufferSize=Math.floor(C/2),null==A?(this.audioContext=new(window.AudioContext||window.webkitAudioContext)({latencyHint:"interactive",sampleRate:this.sampleRateHz}),this.audioContext.createBufferSource()):this.audioContext=A,this.volumeNode=this.audioContext.createGain(),this.volumeNode.connect(this.audioContext.destination),this.audioContext.resume(),"suspended"==this.audioContext.state&&t.RainwayLogging.information("AudioContext is suspended. Note, on Safari, must be created directly from user interaction (i.e. no 'await'))."),this.audioContext.sampleRate!=this.sampleRateHz?(t.RainwayLogging.warning("Configured sample rate: "+this.sampleRateHz+" does not match AudioContext: "+this.audioContext.sampleRate+". Resampling is required!"),this.resampledAudioBufferSize=Math.floor(this.audioContext.sampleRate/1e3*this.minLatencyMs/2),this.scheduleBufferForPlaybackFunc=this.resampleBufferThenScheduleForPlayback.bind(this)):this.scheduleBufferForPlaybackFunc=this.scheduleBufferForPlayback.bind(this),this.audioBufferPool=[];let E=!1;this.playing&&(E=!0,this.stop()),E&&this.play()}play(){if(!this.opusDecoderWorker)throw new Q.RainwayError("play() has no opusDecoderWorker");if(!this.sampleRateHz)throw new Q.RainwayError("play() has no sampleRateHz");if(!this.channelCount)throw new Q.RainwayError("play() has no channelCount");if(!this.audioContext)throw new Q.RainwayError("play() has no audioContext");this.playing||(this.maxDecodingTimeMs=0,this.totalDecodingTimeMs=0,this.totalQueuedSize=0,this.maxQueuedSize=0,this.startStreamTimeMs=Date.now(),this.opusDecoderWorker.startStream(this.sampleRateHz,this.channelCount,this.decodedSamplesPerFrame),this.playing=!0)}stop(){if(!this.opusDecoderWorker)throw new Q.RainwayError("stop() has no opusDecoderWorker");this.waitingToDecodeQueue=[],this.outputBuffers=[],this.nextStartTime=void 0,this.totalSamplesDecoded=0,this.currentOutputBuffer=void 0,this.currentBufferReadIndex=0,this.prevDroppedFrameTimeMs=void 0,this.opusDecoderWorker.stopStream(),this.playing=!1}pushData(A){this.playing&&this.audioContext&&this.opusDecoderWorker&&(0==this.decodeQueueSize?(0!=this.waitingToDecodeQueue.length&&(t.RainwayLogging.error("[AudioStream] empty decoder queue, but waiting to decode queue not empty!"),this.waitingToDecodeQueue=[]),this.sendToDecoder({startTimestamp:Date.now(),inputData:A})):(this.waitingToDecodeQueue.push({startTimestamp:Date.now(),inputData:A}),this.decodeQueueSize<3&&this.sendDecoderWaitingToDecodeFrames()))}sendDecoderWaitingToDecodeFrames(){const A=(this.decodeQueueSize+this.waitingToDecodeQueue.length)*this.dataDurationMs;if(A>this.maxLatencyMs){const I=A-this.maxLatencyMs,g=Math.floor(I/this.dataDurationMs),e=Math.max(Math.max(this.waitingToDecodeQueue.length-g,3-this.decodeQueueSize),1),B=this.waitingToDecodeQueue.length-e;this.waitingToDecodeQueue=this.waitingToDecodeQueue.slice(B)}for(;this.decodeQueueSize<3&&this.waitingToDecodeQueue.length>0;){const A=this.waitingToDecodeQueue.shift();this.sendToDecoder(A)}}sendToDecoder(A){++this.decodeQueueSize,this.opusDecoderWorker.decode(A.startTimestamp,A.inputData)}dropDecodedSamples(A){let I=0;for(this.currentOutputBuffer&&(I+=this.dropCurrentOutputBufferSamples(A),A-=I);A>0&&this.outputBuffers.length>0;)if(A<this.decodedSamplesPerFrame){this.currentOutputBuffer=this.outputBuffers.shift(),this.currentBufferReadIndex=0;const g=this.dropCurrentOutputBufferSamples(A);I+=g,A-=g}else this.outputBuffers.shift(),I+=this.decodedSamplesPerFrame,A-=this.decodedSamplesPerFrame;return I}dropCurrentOutputBufferSamples(A){const I=Math.floor((this.currentOutputBuffer.length-this.currentBufferReadIndex)/this.channelCount),g=Math.min(I,A);return this.currentBufferReadIndex+=g*this.channelCount,this.currentBufferReadIndex>=this.currentOutputBuffer.length&&(this.currentOutputBuffer=void 0),g}copyDecodedSamplesToAudioBuffer(){const A=this.getOrCreateAudioBuffer();for(let I=0;I<this.audioBufferSize;){this.currentOutputBuffer||(this.currentOutputBuffer=this.outputBuffers.shift(),this.currentBufferReadIndex=0);const g=this.currentOutputBuffer;if(1==this.channelCount){const e=A.getChannelData(0);for(;this.currentBufferReadIndex<g.length&&(e[I]=g[this.currentBufferReadIndex],this.currentBufferReadIndex+=this.channelCount,++I,!(I>=this.audioBufferSize)););}else if(2==this.channelCount){const e=A.getChannelData(0),B=A.getChannelData(1);for(;this.currentBufferReadIndex<g.length&&(e[I]=g[this.currentBufferReadIndex],B[I]=g[this.currentBufferReadIndex+1],this.currentBufferReadIndex+=this.channelCount,++I,!(I>=this.audioBufferSize)););}else{const e=A.getChannelData(0),B=A.getChannelData(1),i=A.getChannelData(2),Q=A.getChannelData(3),t=A.getChannelData(4),C=A.getChannelData(5);for(;this.currentBufferReadIndex<g.length&&(e[I]=g[this.currentBufferReadIndex],B[I]=g[this.currentBufferReadIndex+1],t[I]=g[this.currentBufferReadIndex+2],C[I]=g[this.currentBufferReadIndex+3],i[I]=g[this.currentBufferReadIndex+4],Q[I]=g[this.currentBufferReadIndex+5],this.currentBufferReadIndex+=this.channelCount,++I,!(I>=this.audioBufferSize)););}this.currentBufferReadIndex>=this.currentOutputBuffer.length&&(this.currentOutputBuffer=void 0)}return A}getOrCreateAudioBuffer(){return 0==this.audioBufferPool.length?this.audioContext.createBuffer(this.channelCount,this.audioBufferSize,this.sampleRateHz):this.audioBufferPool.pop()}returnAudioBufferToPool(A,I){this.audioBufferPool.length<this.maxAudioBufferPoolCount&&this.audioBufferPool.push(A)}logPerfTiming(A){const I=Date.now(),g=I-A;this.totalDecodingTimeMs+=g,g>this.maxDecodingTimeMs&&(this.maxDecodingTimeMs=g);const e=this.waitingToDecodeQueue.length+this.decodeQueueSize;this.totalQueuedSize+=e,e>this.maxQueuedSize&&(this.maxQueuedSize=e),1500==this.decodedCount&&(t.RainwayLogging.information("[AudioStream] Avg queue: "+this.totalQueuedSize/this.decodedCount+", Max: "+this.maxQueuedSize+" Avg FPS: "+this.decodedCount/((I-this.startStreamTimeMs)/1e3)+" Avg decode: "+this.totalDecodingTimeMs/this.decodedCount+"ms, Max: "+this.maxDecodingTimeMs+"ms"),this.totalDecodingTimeMs=0,this.maxDecodingTimeMs=0,this.totalQueuedSize=0,this.maxQueuedSize=0,this.decodedCount=0,this.startStreamTimeMs=I)}resampleBufferThenScheduleForPlayback(A){const I=new(window.OfflineAudioContext||window.webkitOfflineAudioContext)(this.channelCount,this.resampledAudioBufferSize,this.audioContext.sampleRate),g=I.createBufferSource();g.buffer=A,g.connect(I.destination),g.start(),I.startRendering(),I.oncomplete=this.scheduleResampledBufferPlayback.bind(this,A)}scheduleResampledBufferPlayback(A,I){this.schedulePlaybackWithOnEnded(I.renderedBuffer),this.returnAudioBufferToPool(A,I)}scheduleBufferForPlayback(A){this.schedulePlaybackWithOnEnded(A,this.returnAudioBufferToPool.bind(this,A))}schedulePlaybackWithOnEnded(A,I=null){const g=this.audioContext.createBufferSource();g.buffer=A,this.nextStartTime||(this.nextStartTime=this.audioContext.currentTime),g.playbackRate.value=1,g.connect(this.volumeNode),g.start(this.nextStartTime),g.onended=I,this.nextStartTime+=A.duration}setVolume(A){this.volumeNode.gain.value=A}}},514:(A,I,g)=>{"use strict";Object.defineProperty(I,"__esModule",{value:!0}),I.makeClientCapabilities=void 0;const e=g(904),B=g(643),i=g(695);I.makeClientCapabilities=function(A){const{filtered:I,preferred:g}=i.filterCodecPack(A),Q={codec:e.AudioCodec.Opus,container:e.AudioContainer.Raw},t="MediaSource"in window?e.VideoContainer.IsoBMFF:e.VideoContainer.Raw,C=!!window.chrome;return{preferredWidth:screen.availWidth,preferredHeight:screen.availHeight,preferredFps:60,preferredAudioBitrate:96e3,preferredVideoBitrate:1e3*B.defaultRateControlParameters.initialBitrateKbps,preferredAudioChannels:e.AudioChannels.Stereo,preferredAudioConfig:Q,preferredVideoConfig:{codec:g,container:t},supportedAudioChannels:[e.AudioChannels.Mono,e.AudioChannels.Stereo],supportedAudioConfigs:[Q],supportedVideoConfigs:I.map((A=>({codec:A,container:t}))),supportsOver1080P:!1,supportsTemporalScaling:!0,supportsAppIsolation:C}}},695:(A,I,g)=>{"use strict";Object.defineProperty(I,"__esModule",{value:!0}),I.filterCodecPack=I.videoCodecMimeType=void 0;const e=g(904);function B(A){const I=A.data;return`video/mp4; codecs="avc1.${(I[5]<<16|I[6]<<8|I[7]).toString(16).padStart(6,"0")}"`}function i(A){if(!("MediaSource"in window))return!1;const I=A.data;if(I.length<8||7!=(31&I[4]))return!1;const g=B(A);return MediaSource.isTypeSupported(g)}function Q(A){const I=A.data;if(I.length<8||7!=(31&I[4]))return e.VideoCodecType.Baseline;const g=I[5];return I[6],116==g||122==g||110==g||100==g?e.VideoCodecType.High:88==g||77==g?e.VideoCodecType.Main:e.VideoCodecType.Baseline}I.videoCodecMimeType=B,I.filterCodecPack=function(A){if(0===A.length)throw new Error("Host supplied an empty CodecPack");let I=A.filter(i);if(0===I.length&&(console.warn("Found no browser-confirmed working codec, falling back to baseline"),I=A.filter((A=>Q(A)<=e.VideoCodecType.Baseline))),0===I.length)throw new Error("Host supplied an unsupported CodecPack");const g=I.reduce(((A,I)=>Q(A)>Q(I)?A:I));return{filtered:I,preferred:g}}},919:(A,I,g)=>{"use strict";Object.defineProperty(I,"__esModule",{value:!0});const e=g(464);class B{constructor(A,I,g){this.glCtx=void 0,this.program=void 0,this.glCtx=A,this.program=this.glCtx.createProgram(),this.glCtx.attachShader(this.program,I),this.glCtx.attachShader(this.program,g),this.glCtx.linkProgram(this.program),this.glCtx.getProgramParameter(this.program,this.glCtx.LINK_STATUS)||e.RainwayLogging.error("Shader link failed.")}static compile(A,I,g){let B;return B="vertex"===I?A.createShader(A.VERTEX_SHADER):A.createShader(A.FRAGMENT_SHADER),A.shaderSource(B,g),A.compileShader(B),0==A.getShaderParameter(B,A.COMPILE_STATUS)&&e.RainwayLogging.error("Shader compile failed, log: "+A.getShaderInfoLog(B)),B}static create(A,I,g){const e=B.compile(A,"vertex",I),i=B.compile(A,"fragment",g);return new B(A,e,i)}use(){this.glCtx.useProgram(this.program)}getAttributeLocation(A){return this.glCtx.getAttribLocation(this.program,A)}getUniformLocation(A){const I=this.glCtx.getUniformLocation(this.program,A);if(I)return I}setMatrixUniform(A,I){this.glCtx.uniformMatrix4fv(A,!1,I)}}I.default=B},756:function(A,I,g){"use strict";var e=this&&this.__importDefault||function(A){return A&&A.__esModule?A:{default:A}};Object.defineProperty(I,"__esModule",{value:!0}),I.yuvFragShaderSrc=void 0;const B=e(g(919));I.yuvFragShaderSrc="\n    precision lowp float;\n    \n    varying vec2 vTexCoord;\n    \n    uniform sampler2D yTexture;\n    uniform sampler2D uTexture;\n    uniform sampler2D vTexture;\n    const mat3 conversion = mat3(\n        1.164, 0.000,  1.596,\n        1.164, -0.391, -0.813,\n        1.164, 2.018,  0.000\n    );\n\n    const vec3 offset = vec3(0.0625, 0.5, 0.5);\n        \n    void main(void) {\n        float y = texture2D(yTexture, vTexCoord).x;\n        float u = texture2D(uTexture, vTexCoord).x;\n        float v = texture2D(vTexture, vTexCoord).x;\n        vec3 yuv = vec3(y, u, v) - offset;\n\n        vec3 rgb = (yuv * conversion);\n\n        gl_FragColor = vec4(rgb, 1.0);\n    }\n";class i{constructor(A,I,g,e,B,i,Q,t,C){this.glCtx=A,this.program=I,this.projectionMtxLoc=g,this.positionAttr=e,this.texCoordAttr=B,this.vertexBuffer=i,this.yTextureLoc=Q,this.uTextureLoc=t,this.vTextureLoc=C}static create(A){const g=B.default.create(A,"\n    precision mediump float;\n\n    uniform mat4 uProjection;\n    attribute vec2 aPosition;\n    attribute vec2 aTexCoord;\n\n    varying vec2 vTexCoord;\n    void main(){\n        vTexCoord = aTexCoord;\n        gl_Position = uProjection * vec4(aPosition, 0.0, 1.0);\n    }\n",I.yuvFragShaderSrc);g.use();const e=g.getUniformLocation("uProjection"),Q=g.getAttributeLocation("aPosition");A.enableVertexAttribArray(Q);const t=g.getAttributeLocation("aTexCoord");A.enableVertexAttribArray(t);const C=A.createBuffer(),E=g.getUniformLocation("yTexture"),o=g.getUniformLocation("uTexture"),a=g.getUniformLocation("vTexture");return new i(A,g,e,Q,t,C,E,o,a)}bindInputTextures(A,I,g){const e=this.glCtx;e.uniform1i(this.yTextureLoc,0),e.activeTexture(e.TEXTURE0),e.bindTexture(e.TEXTURE_2D,A.textureId),e.uniform1i(this.uTextureLoc,1),e.activeTexture(e.TEXTURE1),e.bindTexture(e.TEXTURE_2D,I.textureId),e.uniform1i(this.vTextureLoc,2),e.activeTexture(e.TEXTURE2),e.bindTexture(e.TEXTURE_2D,g.textureId)}use(){this.program.use()}drop(){this.glCtx.useProgram(0)}update(A,I,g,e){this.glCtx.viewport(0,0,A,I),this.program.setMatrixUniform(this.projectionMtxLoc,[2/A,0,0,0,0,2/-I,0,0,0,0,1,0,-1,1,0,1]),this.glCtx.bindBuffer(this.glCtx.ARRAY_BUFFER,this.vertexBuffer),this.glCtx.bufferData(this.glCtx.ARRAY_BUFFER,new Float32Array([0,0,0,0,A,0,g,0,A,I,g,e,A,I,g,e,0,I,0,e,0,0,0,0]),this.glCtx.DYNAMIC_DRAW),this.glCtx.vertexAttribPointer(this.positionAttr,2,this.glCtx.FLOAT,!1,16,0),this.glCtx.vertexAttribPointer(this.texCoordAttr,2,this.glCtx.FLOAT,!1,16,8)}draw(){const A=this.glCtx;A.clear(A.COLOR_BUFFER_BIT|A.DEPTH_BUFFER_BIT|A.STENCIL_BUFFER_BIT),A.drawArrays(A.TRIANGLE_STRIP,0,6),A.bindTexture(A.TEXTURE_2D,null)}}I.default=i},346:(A,I)=>{"use strict";Object.defineProperty(I,"__esModule",{value:!0});class g{constructor(A,I){this.glCtx=void 0,this.textureId=void 0,this.glCtx=A,this.textureId=I}static create(A){const I=A.createTexture();return A.bindTexture(A.TEXTURE_2D,I),A.texParameteri(A.TEXTURE_2D,A.TEXTURE_MAG_FILTER,A.NEAREST),A.texParameteri(A.TEXTURE_2D,A.TEXTURE_MIN_FILTER,A.NEAREST),A.texParameteri(A.TEXTURE_2D,A.TEXTURE_WRAP_S,A.CLAMP_TO_EDGE),A.texParameteri(A.TEXTURE_2D,A.TEXTURE_WRAP_T,A.CLAMP_TO_EDGE),A.bindTexture(A.TEXTURE_2D,null),new g(A,I)}uploadBuffer(A,I,g){const e=this.glCtx;e.bindTexture(e.TEXTURE_2D,this.textureId),e.texImage2D(e.TEXTURE_2D,0,e.LUMINANCE,I,g,0,e.LUMINANCE,e.UNSIGNED_BYTE,A),e.bindTexture(e.TEXTURE_2D,null)}delete(){null!=this.glCtx&&0!=this.textureId&&(this.glCtx.deleteTexture(this.textureId),this.textureId=0)}}I.default=g},425:function(A,I,g){"use strict";var e,B=this&&this.__awaiter||function(A,I,g,e){return new(g||(g=Promise))((function(B,i){function Q(A){try{C(e.next(A))}catch(A){i(A)}}function t(A){try{C(e.throw(A))}catch(A){i(A)}}function C(A){var I;A.done?B(A.value):(I=A.value,I instanceof g?I:new g((function(A){A(I)}))).then(Q,t)}C((e=e.apply(A,I||[])).next())}))},i=this&&this.__classPrivateFieldSet||function(A,I,g){if(!I.has(A))throw new TypeError("attempted to set private field on non-instance");return I.set(A,g),g},Q=this&&this.__classPrivateFieldGet||function(A,I){if(!I.has(A))throw new TypeError("attempted to get private field on non-instance");return I.get(A)};Object.defineProperty(I,"__esModule",{value:!0}),I.MediaManager=I.RainwayVideoFormat=I.RainwayVideoDecoder=void 0;const t=g(900),C=g(585),E=g(78),o=g(914),a=g(146),n=g(930),s=g(904),r=g(14);var d,h;!function(A){A[A.MSE=0]="MSE",A[A.Software=1]="Software"}(d=I.RainwayVideoDecoder||(I.RainwayVideoDecoder={})),function(A){A[A.AnnexB=0]="AnnexB",A[A.LengthPrefixed=1]="LengthPrefixed"}(h=I.RainwayVideoFormat||(I.RainwayVideoFormat={})),I.MediaManager=class{constructor(A,I,g,B){var n;if(this.captureMode=A,this.chosenVideoConfig=I,e.set(this,void 0),this.overlayEnabled=!1,this.captureMode===s.CaptureMode.BYOFB)throw new r.RainwayError("BYOFB mode stream consumption is not supported in the Web SDK.");i(this,e,{video:Object.assign(Object.assign({codecString:'video/mp4; codecs="avc1.42c020"'},this.autodetectVideoConfiguration()),g.video),videoPerformance:null!==(n=g.videoPerformance)&&void 0!==n?n:{},audio:Object.assign({},g.audio)}),Q(this,e).video.decoder===d.Software?this.videoStream=new a.VideoStreamSoftwareDecoder(Q(this,e).video.codecString,h.LengthPrefixed):this.videoStream=new t.VideoStreamMSE(Q(this,e).video.codecString),this.audioStream=new C.AudioStream,this.audioStream.configure(Q(this,e).audio),this.videoPerformanceMonitor=new E.VideoPerformanceMonitor(this.videoStream,Q(this,e).videoPerformance),this.videoStatsOverlay=new o.VideoStatsOverlay(this.videoStream,Q(this,e).video.decoder===d.Software,B)}get videoReadyStateChangeEvent(){return this.videoStream.readyStateChangeEvent}get videoNeedsRestartEvent(){return this.videoStream.needsRestartEvent}get audioContext(){return this.audioStream.audioContext}get currentStreamBounds(){return this.streamBounds}get currentFullDesktopBounds(){return this.fullDesktopBounds}initialize(){return B(this,void 0,void 0,(function*(){yield this.audioStream.initialize(),this.audioStream.play()}))}get config(){return Q(this,e)}autodetectVideoConfiguration(){return{decoder:window.MediaSource?d.MSE:d.Software}}setContainer(A){if(this.unsetContainer(),this.container=A,this.captureMode===s.CaptureMode.AppIsolation){const A=this.createIsolationCanvasElement();this.showStreamElement(A),Q(this,e).video.decoder===d.MSE?this.setIsolationSource(this.createVideoElement()):this.setIsolationSource(this.createCanvasElement())}else Q(this,e).video.decoder===d.MSE?this.showStreamElement(this.createVideoElement()):this.showStreamElement(this.createCanvasElement());this.overlayEnabled&&this.createAndShowStatsOverlay()}setIsolationSource(A){this.isolationSource=A}createAndShowStatsOverlay(){const A=this.createOverlayCanvasElement();this.showOverlayElement(A),Q(this,e).video.decoder===d.MSE?this.videoStatsOverlay.setElements({video:this.videoElement,canvas:A,usingOutputCanvas:!1}):this.videoStatsOverlay.setElements({canvas:A,usingOutputCanvas:!1})}unsetContainer(){var A,I,g,e,B,i,Q,t;this.disposeVideoElement(),this.disposeCanvasElement(),this.disposeOverlayCanvasElement(),this.disposeIsolationCanvasElement(),null===(I=null===(A=this.container)||void 0===A?void 0:A.querySelector(".rainway-video"))||void 0===I||I.remove(),null===(e=null===(g=this.container)||void 0===g?void 0:g.querySelector(".rainway-canvas"))||void 0===e||e.remove(),null===(i=null===(B=this.container)||void 0===B?void 0:B.querySelector(".rainway-overlay-canvas"))||void 0===i||i.remove(),null===(t=null===(Q=this.container)||void 0===Q?void 0:Q.querySelector(".rainway-isolation-canvas"))||void 0===t||t.remove(),this.container=void 0}showOverlayElement(A){Object.assign(A.style,{position:"absolute",top:"0",bottom:"0",left:"0",right:"0",width:"100%",height:"100%",pointerEvents:"none"})}createVideoElement(){var A,I;null===(I=null===(A=this.container)||void 0===A?void 0:A.querySelector(".rainway-video"))||void 0===I||I.remove(),this.videoElement=document.createElement("video");const g=this.videoElement;return g.className="rainway-video",g.autoplay=!0,g.muted=!0,g.style.display="none",this.container.appendChild(g),this.videoStream.attachToElement(g),this.videoElement}disposeVideoElement(){this.videoElement&&(this.videoStream.detachFromElement(),this.videoElement.remove(),this.videoElement=void 0)}createOverlayCanvasElement(){var A,I,g;null===(I=null===(A=this.container)||void 0===A?void 0:A.querySelector(".rainway-overlay-canvas"))||void 0===I||I.remove(),this.canvasElement=document.createElement("canvas");const e=this.canvasElement;return e.className="rainway-overlay-canvas",this.container.appendChild(e),null===(g=e.getContext("2d"))||void 0===g||g.clearRect(0,0,e.width,e.height),e}disposeOverlayCanvasElement(){var A,I;null===(I=null===(A=this.container)||void 0===A?void 0:A.querySelector(".rainway-overlay-canvas"))||void 0===I||I.remove(),this.overlayCanvasElement&&(this.overlayCanvasElement.remove(),this.overlayCanvasElement=void 0)}createCanvasElement(){var A,I,g;null===(I=null===(A=this.container)||void 0===A?void 0:A.querySelector(".rainway-canvas"))||void 0===I||I.remove(),this.canvasElement=document.createElement("canvas");const e=this.canvasElement;return e.className="rainway-canvas",e.style.display="none",this.container.appendChild(e),this.videoStream instanceof a.VideoStreamSoftwareDecoder&&this.videoStream.attachToCanvas(e),null===(g=e.getContext("2d"))||void 0===g||g.clearRect(0,0,e.width,e.height),e}disposeCanvasElement(){this.canvasElement&&(this.videoStream instanceof a.VideoStreamSoftwareDecoder&&this.videoStream.detachFromCanvas(),this.canvasElement.remove(),this.canvasElement=void 0)}createIsolationCanvasElement(){var A,I,g;null===(I=null===(A=this.container)||void 0===A?void 0:A.querySelector(".rainway-isolation-canvas"))||void 0===I||I.remove(),this.isolationCanvasElement=document.createElement("canvas");const e=this.isolationCanvasElement;return e.className="rainway-isolation-canvas",this.container.appendChild(e),null===(g=e.getContext("2d"))||void 0===g||g.clearRect(0,0,e.width,e.height),e}disposeIsolationCanvasElement(){this.isolationCanvasElement&&(this.isolationCanvasElement.remove(),this.isolationCanvasElement=void 0)}hideStreamElement(A){A.style.width="0",A.style.height="0"}showStreamElement(A){this.container&&(this.streamElement=A,A.style.width="100%",A.style.height="100%",A.style.display="block",A.style.objectFit="contain")}pause(){this.videoStream.pause(),this.audioStream.stop()}play(){this.videoStream.play(),this.audioStream.play()}renderVideoFrame(A,I){this.videoStream.pushData(A,I),this.fullDesktopBounds={left:A.x,top:A.y,width:A.width,height:A.height},this.captureMode===s.CaptureMode.AppIsolation?(A.mask.length>0&&(this.mask=A.mask),A.width>0&&(this.frameWidth=A.width),A.height>0&&(this.frameHeight=A.height),this.renderIsolatedApp()):this.streamBounds=this.fullDesktopBounds}renderIsolatedApp(){if(!this.mask)return;if(!this.frameWidth)return;if(!this.frameHeight)return;const A=this.isolationSource;if(!A)return;const I=this.isolationCanvasElement;if(!I)return;const g=I.getContext("2d");if(!g)return;const e=n.boundingRectangle(this.mask);this.streamBounds=e;const B=this.chosenVideoConfig.codec.width/this.frameWidth,i=this.chosenVideoConfig.codec.height/this.frameHeight;I.width=e.width*B,I.height=e.height*i;for(const{left:I,top:Q,width:t,height:C}of this.mask){const E=I*B,o=Q*i,a=t*B,n=C*i,s=(I-e.left)*B,r=(Q-e.top)*i;g.drawImage(A,E,o,a,n,s,r,a,n)}}processAudio(A){this.audioStream.pushData(A)}getVideoStats(){return this.videoStream.getStats()}configureAudio(A){return B(this,void 0,void 0,(function*(){Q(this,e).audio=Object.assign(Object.assign({},Q(this,e).audio),A),this.audioStream.configure(A)}))}enableStatsOverlay(){this.overlayEnabled=!0,this.videoStatsOverlay.enable(),this.disposeOverlayCanvasElement(),this.createAndShowStatsOverlay()}disableStatsOverlay(){this.disposeOverlayCanvasElement(),this.overlayEnabled=!1,this.videoStatsOverlay.disable()}dispose(){this.pause(),this.unsetContainer(),this.audioStream.dispose(),this.videoStream.dispose()}setVolume(A){this.audioStream.setVolume(A)}},e=new WeakMap},633:function(A,I){"use strict";var g,e=this&&this.__awaiter||function(A,I,g,e){return new(g||(g=Promise))((function(B,i){function Q(A){try{C(e.next(A))}catch(A){i(A)}}function t(A){try{C(e.throw(A))}catch(A){i(A)}}function C(A){var I;A.done?B(A.value):(I=A.value,I instanceof g?I:new g((function(A){A(I)}))).then(Q,t)}C((e=e.apply(A,I||[])).next())}))},B=this&&this.__classPrivateFieldGet||function(A,I){if(!I.has(A))throw new TypeError("attempted to get private field on non-instance");return I.get(A)},i=this&&this.__classPrivateFieldSet||function(A,I,g){if(!I.has(A))throw new TypeError("attempted to set private field on non-instance");return I.set(A,g),g};Object.defineProperty(I,"__esModule",{value:!0}),I.CircularBuffer=I.average=I.createSourceBuffer=I.awaitMediaSourceOpen=I.createMediaSource=I.MediaUnsupportedError=void 0;class Q extends Error{}function t(A,I){return e(this,void 0,void 0,(function*(){return new Promise(((g,e)=>{let B=!1;const i=()=>{A.removeEventListener("sourceopen",Q),null==I||I.removeHandler(E),window.clearInterval(C),B=!0},Q=()=>{i(),g(!0)},t=()=>{B||"open"===A.readyState&&(i(),g(!0))},C=window.setInterval(t,500);t(),window.setTimeout((()=>{B||(i(),e(new Error("MediaSource open timed out.")))}),1e4),A.addEventListener("sourceopen",Q);const E=()=>{i(),g(!1)};null==I||I.addHandler(E)}))}))}I.MediaUnsupportedError=Q,I.createMediaSource=function(A,I){return e(this,void 0,void 0,(function*(){if(!window.MediaSource)throw new Q("Browser does not support MSE.");const g=new MediaSource,e=window.URL.createObjectURL(g);if(A.src=void 0,A.src=e,A.load(),yield t(g,I))return g.duration=Number.POSITIVE_INFINITY,g}))},I.awaitMediaSourceOpen=t,I.createSourceBuffer=function(A,I){const g=A.addSourceBuffer(I);return g.mode="sequence",g},I.average=function(A){return 0===A.length?0:A.reduce(((A,I)=>A+I),0)/A.length},I.CircularBuffer=class{constructor(A){this.maxLength=A,this.nextIndex=0,this.list=Array(this.maxLength),g.set(this,0)}get length(){return B(this,g)}push(A){this.list[this.nextIndex++]=A,i(this,g,Math.max(B(this,g),this.nextIndex)),this.nextIndex%=this.maxLength}values(){return this.list.slice(0,B(this,g))}},g=new WeakMap},78:(A,I,g)=>{"use strict";Object.defineProperty(I,"__esModule",{value:!0}),I.VideoPerformanceMonitor=void 0;const e=g(198),B=g(434),i=g(24),Q={targetFramerate:60,bufferLimitMs:500,cpuStarvationThreshold:1,decoderStrugglingThreshold:1,checkInterval:1500,windowMs:500};I.VideoPerformanceMonitor=class{constructor(A,I={}){this.videoStream=A,this.decoderStrugglingEvent=new i.Action,this.cpuStarvationEvent=new i.Action,this.cpuStarvationCounter=0,this.decoderStrugglingCounter=0,this.readyStateChangeHandler=A=>{A===B.VideoReadyState.Detached?this.stopChecking():this.lastVideoReadyState===B.VideoReadyState.Detached&&this.startChecking(),this.lastVideoReadyState=A},this.videoFrameMetadataHandler=A=>{this.processingDurationTrack.feed(A)},this.checkPerformance=()=>{if(this.videoStream.readyState===B.VideoReadyState.Playing){const A=1/this.config.targetFramerate,I=1e3*A,g=Math.floor(this.config.bufferLimitMs/I),e=this.videoStream.getStats();(e.endOfBuffered>e.currentTime+this.config.bufferLimitMs/1e3||this.videoStream.dataQueueLength>g)&&this.videoStream.restart("checkPerformance"),this.videoStream.dataQueueLength>g?this.cpuStarvationCounter+=1:this.cpuStarvationCounter=Math.max(0,this.cpuStarvationCounter-1),this.processingDurationTrack.average()>A?(this.decoderStrugglingCounter+=1,this.cpuStarvationCounter=Math.max(0,this.cpuStarvationCounter-1)):this.decoderStrugglingCounter=Math.max(0,this.decoderStrugglingCounter-1),this.cpuStarvationCounter,this.config.cpuStarvationThreshold,this.decoderStrugglingCounter,this.config.decoderStrugglingThreshold}},this.config=Object.assign(Object.assign({},Q),I),this.processingDurationTrack=new e.WindowTrack(this.config.windowMs,e.meanOrZero),this.videoStream.readyStateChangeEvent.addHandler(this.readyStateChangeHandler),this.videoStream.videoFrameProcessingDurationEvent.addHandler(this.videoFrameMetadataHandler),this.lastVideoReadyState=this.videoStream.readyState,this.videoStream.readyState!==B.VideoReadyState.Detached&&this.startChecking()}dispose(){this.stopChecking(),this.videoStream.readyStateChangeEvent.removeHandler(this.readyStateChangeHandler),this.videoStream.videoFrameProcessingDurationEvent.removeHandler(this.videoFrameMetadataHandler)}startChecking(){this.processingDurationTrack=new e.WindowTrack(this.config.windowMs,e.meanOrZero),this.checkPerformanceInterval=window.setInterval(this.checkPerformance,this.config.checkInterval)}stopChecking(){this.checkPerformanceInterval&&(window.clearInterval(this.checkPerformanceInterval),this.checkPerformanceInterval=void 0)}}},914:function(A,I,g){"use strict";var e=this&&this.__awaiter||function(A,I,g,e){return new(g||(g=Promise))((function(B,i){function Q(A){try{C(e.next(A))}catch(A){i(A)}}function t(A){try{C(e.throw(A))}catch(A){i(A)}}function C(A){var I;A.done?B(A.value):(I=A.value,I instanceof g?I:new g((function(A){A(I)}))).then(Q,t)}C((e=e.apply(A,I||[])).next())}))};Object.defineProperty(I,"__esModule",{value:!0}),I.VideoStatsOverlay=void 0;const B=g(146),i=g(434),Q=g(198),t=5e3,C={droppedFrames:"Dropped frames",totalFrames:"Total frames",currentTime:"Current video time",endOfBuffered:"End of video buffer",endOfSeekable:"End of video seekable",dataInterval:"Video data interval",dataSize:"Video frame size",processingDuration:"Frame processing duration"};I.VideoStatsOverlay=class{constructor(A,I,g){this.videoStream=A,this.usingOutputCanvas=I,this.getStats=g,this.compositingTimeTrack=new Q.WindowTrack(t,Q.mean),this.processingDurationTrack=new Q.WindowTrack(t,Q.mean),this.frameTrack=new Q.WindowTrack(t,Q.mean),this.drawIntervalTrack=new Q.WindowTrack(t,Q.mean),this.displayTimeIntervalTrack=new Q.WindowTrack(t,Q.mean),this.frameCounter=0,this.throughput=[],this.fetchStats=()=>e(this,void 0,void 0,(function*(){this.videoStream.readyState===i.VideoReadyState.Playing&&(this.stats=this.videoStream.getStats(),this.lastTransportStats=this.transportStats,this.transportStats=yield this.getStats(),this.throughput=this.getThroughput())})),this.animationFrameHandler=()=>{this.frameTrack.feed(this.frameCounter),this.frameCounter=0,this.animationFrameHandle=window.requestAnimationFrame(this.animationFrameHandler)},this.drawStatsOnlyOnAnimationFrame=()=>{if(this.drawStatsOnlyHandle=window.requestAnimationFrame(this.drawStatsOnlyOnAnimationFrame),!this.canvasContext||this.videoStream.readyState!==i.VideoReadyState.Playing)return;const A=this.canvasContext;this.usingOutputCanvas||(A.canvas.width!==A.canvas.clientWidth&&(A.canvas.width=A.canvas.clientWidth),A.canvas.height!==A.canvas.clientHeight&&(A.canvas.height=A.canvas.clientHeight),A.clearRect(0,0,A.canvas.width,A.canvas.height)),this.drawStats()},this.drawStatsAndGraphsOnVideoFrame=([A,I])=>{if(this.frameCounter++,!this.canvasContext||this.videoStream.readyState!==i.VideoReadyState.Playing||!I)return;const g=this.canvasContext;this.usingOutputCanvas||(g.canvas.width!==g.canvas.clientWidth&&(g.canvas.width=g.canvas.clientWidth),g.canvas.height!==g.canvas.clientHeight&&(g.canvas.height=g.canvas.clientHeight),g.clearRect(0,0,g.canvas.width,g.canvas.height));const e=performance.now();this.lastCanvasDrawTime&&this.drawIntervalTrack.feed(e-this.lastCanvasDrawTime),this.lastCanvasDrawTime=e;const B=I.expectedDisplayTime;this.lastDisplayTime&&this.displayTimeIntervalTrack.feed(B-this.lastDisplayTime),this.lastDisplayTime=B,this.compositingTimeTrack.feed(I.expectedDisplayTime-A),this.processingDurationTrack.feed(I.processingDuration);const Q=g.canvas;Q.width,Q.clientWidth,Q.height,Q.clientHeight,this.drawStats(I)}}setElements({video:A,canvas:I,usingOutputCanvas:g=!1}){this.usingOutputCanvas=g,this.canvas=I,this.video=A,this.canvas&&(this.canvasContext=this.canvas.getContext("2d",{alpha:!this.usingOutputCanvas}))}enable(){this.animationFrameHandle&&window.cancelAnimationFrame(this.animationFrameHandle),this.drawStatsOnlyHandle&&window.cancelAnimationFrame(this.drawStatsOnlyHandle),this.videoStream instanceof B.VideoStreamSoftwareDecoder||"requestVideoFrameCallback"in HTMLVideoElement.prototype?(this.animationFrameHandle=window.requestAnimationFrame(this.animationFrameHandler),this.videoStream.videoFrameEvent.addHandler(this.drawStatsAndGraphsOnVideoFrame)):this.drawStatsOnlyHandle=window.requestAnimationFrame(this.drawStatsOnlyOnAnimationFrame),this.statsInterval=window.setInterval(this.fetchStats,1e3)}disable(){this.animationFrameHandle&&window.cancelAnimationFrame(this.animationFrameHandle),this.drawStatsOnlyHandle&&window.cancelAnimationFrame(this.drawStatsOnlyHandle),this.videoStream.videoFrameEvent.removeHandler(this.drawStatsAndGraphsOnVideoFrame),window.clearInterval(this.statsInterval)}getThroughput(){var A;return this.transportStats&&this.lastTransportStats?Object.entries(null===(A=this.transportStats)||void 0===A?void 0:A.channels).map((([A,I])=>this.lastTransportStats?[A,I.bytesSent-this.lastTransportStats.channels[A].bytesSent,I.bytesReceived-this.lastTransportStats.channels[A].bytesReceived]:[A,0,0])):[]}drawStats(A){var I,g;if(!this.canvasContext||this.videoStream.readyState!==i.VideoReadyState.Playing)return;const e=this.canvasContext,B=e.canvas,Q=B.width/B.clientWidth,t=B.height/B.clientHeight,E=this.throughput;if(this.stats){const i=Object.entries(this.stats),o=i.length+E.length,a=e.measureText("M").width;e.fillStyle="rgba(0, 0, 0, 0.5)";const n=(o+2)*a+2*(a+2*t)+15*t;e.fillRect(10*Q,B.height-(n+10*t),300*Q,n),e.fillStyle="white",e.font=`${(12*Q).toFixed(0)}px sans-serif`,e.textBaseline="top";let s=0;const r=B.height-(n+15*t)+15*Q;A?e.fillText(`Resolution: ${A.width}x${A.height}`,15*Q,r):e.fillText(`Resolution: ${null===(I=this.video)||void 0===I?void 0:I.videoWidth}x${null===(g=this.video)||void 0===g?void 0:g.videoHeight}`,15*Q,r),e.fillText(`Element size: ${B.clientWidth}x${B.clientHeight}`,15*Q,r+a);for(const[A,I]of i){let g,B="";"processingDuration"===A?(B="ms",g=1e3*I):g=I,"endOfBuffered"===A||"endOfSeekable"===A||"currentTime"===A?B="s":"dataInterval"===A?B="ms":"dataSize"===A&&(B="bytes"),e.fillText(`${C[A]}: ${g.toFixed(2)} ${B}`,15*Q,s*(a+2*t)+2*(a+2*t)+r),s++}for(const[A,I,g]of E)e.fillText(`${A} throughput - up: ${(I/1e3).toFixed(0)} kb/s, down: ${(g/1e3).toFixed(0)} kb/s`,15*Q,s*(a+2*t)+2*(a+2*t)+r),s++}}}},441:(A,I,g)=>{"use strict";Object.defineProperty(I,"__esModule",{value:!0}),I.VideoStats=void 0;const e=g(994),B=g(633);I.VideoStats=class{constructor(){this.processingDurations=new Map,this.dataIntervals=new B.CircularBuffer(60),this.dataSizes=new B.CircularBuffer(60),this.totalFrames=0,this.presentedFrames=0}pushFrameMetadata(A){this.presentedFrames+=1;const{processingDuration:I}=A,g=(new Date).getTime();this.processingDurations.set(g,I);for(const[A]of this.processingDurations.entries())A<g-1e3&&this.processingDurations.delete(A)}reportFrameSubmitted(){this.totalFrames+=1}resetFrameCounts(){this.totalFrames=0,this.presentedFrames=0}pushData(A){this.dataSizes.push(A.byteLength);const I=(new Date).getTime();this.lastDataTimestamp&&this.dataIntervals.push(I-this.lastDataTimestamp),this.lastDataTimestamp=I}setElement(A){this.element=A}getReport(){if(!this.element)throw new e.RainwayError("getReport() has no video element");const A=B.average(Array.from(this.processingDurations.values())),I=this.element.buffered,g=I.length>0?I.end(I.length-1):0,i=this.element.seekable,Q=i.length>0?i.end(i.length-1):0;return{processingDuration:A,droppedFrames:this.totalFrames-this.presentedFrames,totalFrames:this.totalFrames,dataInterval:B.average(this.dataIntervals.values()),dataSize:B.average(this.dataSizes.values()),currentTime:this.element.currentTime,endOfBuffered:g,endOfSeekable:Q}}createReport(A,I){return{processingDuration:B.average(Array.from(this.processingDurations.values())),droppedFrames:null!=A?A:0,totalFrames:null!=I?I:0,dataInterval:B.average(this.dataIntervals.values()),dataSize:B.average(this.dataSizes.values()),currentTime:0,endOfBuffered:0,endOfSeekable:0}}}},900:function(A,I,g){"use strict";var e=this&&this.__awaiter||function(A,I,g,e){return new(g||(g=Promise))((function(B,i){function Q(A){try{C(e.next(A))}catch(A){i(A)}}function t(A){try{C(e.throw(A))}catch(A){i(A)}}function C(A){var I;A.done?B(A.value):(I=A.value,I instanceof g?I:new g((function(A){A(I)}))).then(Q,t)}C((e=e.apply(A,I||[])).next())}))};Object.defineProperty(I,"__esModule",{value:!0}),I.VideoStreamMSE=void 0;const B=g(24),i=g(633),Q=g(434),t=g(464),C=g(441);function E(A){return 102===A[4]&&116===A[5]&&121===A[6]&&112===A[7]}I.VideoStreamMSE=class{constructor(A){this.codecString=A,this.readyState=Q.VideoReadyState.Detached,this.needsRestartEvent=new B.Action,this.sourceOpenEvent=new B.Action,this.readyStateChangeEvent=new B.Action,this.videoFrameEvent=new B.Action,this.videoFrameProcessingDurationEvent=new B.Action,this.cancelInitializeEvent=new B.Action,this.dataQueue=[],this.stats=new C.VideoStats,this.justClearedBuffer=!1,this.lastBufferEnd=0,this.framesFrozenFor=0,this.ensureBuffer=()=>{if(this.readyState!==Q.VideoReadyState.Paused&&this.readyState!==Q.VideoReadyState.Detached&&this.element&&0===this.element.buffered.length){if(this.sourceBuffer&&!this.sourceBuffer.updating&&this.sourceBuffer.timestampOffset<=0){const A=this.sourceBuffer.timestampOffset.toFixed(2);this.sourceBuffer.timestampOffset=1;const I=this.sourceBuffer.timestampOffset.toFixed(2);this.warn(`Poked timestampOffset from ${A} to ${I}`)}this.restart("ensureBuffer")}},this.videoFrameHandler=(A,I)=>{(null==I?void 0:I.processingDuration)&&this.videoFrameProcessingDurationEvent.invoke(I.processingDuration),I&&this.stats.pushFrameMetadata(I),this.videoFrameEvent.invoke([A,I]),this.requestNextFrameCallback()},this.fallbackVideoFrameHandler=A=>{this.videoFrameHandler(A,void 0)},this.sourceBufferUpdateHandler=()=>{this.submitData()},window.__rainwayVideo=this}info(A){t.RainwayLogging.information(`[VideoStream] ${String(A)}`)}debug(A){t.RainwayLogging.debug(`[VideoStream] ${String(A)}`)}warn(A){t.RainwayLogging.warning(`[VideoStream] ${String(A)}`)}get dataQueueLength(){return this.dataQueue.length}attachToElement(A){this.info("Attaching to element: "+A),this.cancelInitializeEvent.invoke(),this.element=A,this.stats.setElement(this.element),this.stats.resetFrameCounts(),this.restart("attachToElement"),this.info("Attached to element.")}detachFromElement(){this.destroyMedia(),this.element=void 0,this.setReadyState(Q.VideoReadyState.Detached),this.info("Detached from element.")}pause(){this.setReadyState(Q.VideoReadyState.Paused)}play(){this.readyState===Q.VideoReadyState.Paused&&this.restart("play")}pushData(A,I){if(this.dataQueue.length>8)return void this.restart("pushData.dataQueue too long");const g=new Uint8Array(I);this.stats.pushData(g),this.readyState!==Q.VideoReadyState.Paused&&(E(g)&&this.readyState===Q.VideoReadyState.WaitingForKeyframe&&this.element&&(this.debug(`Got requested keyframe (${g.length} bytes)`),this.getStats(),this.dataQueue.push(g),this.submitData(),this.initializeMedia()),this.readyState!==Q.VideoReadyState.WaitingForKeyframe&&this.element?(this.dataQueue.push(g),this.submitData()):this.startEnsuringBuffer())}getStats(){return this.stats.getReport()}setReadyState(A){this.info(`ReadyState changed: ${Q.VideoReadyState[this.readyState]} => ${Q.VideoReadyState[A]}`),this.readyState=A,this.readyStateChangeEvent.invoke(A)}submitData(){if(0!==this.dataQueue.length)if(void 0!==this.mediaSource)if(this.sourceBuffer){if(!this.sourceBuffer.updating)if(this.element){if(this.sourceBuffer.buffered.length>=1){const A=this.sourceBuffer.buffered.end(this.sourceBuffer.buffered.length-1);this.justClearedBuffer&&(this.element.currentTime=A,this.justClearedBuffer=!1),A===this.lastBufferEnd?(this.framesFrozenFor++,this.debug(`Frozen for ${this.framesFrozenFor} frames...`)):this.framesFrozenFor=0,this.lastBufferEnd=A}if(this.framesFrozenFor>=4)return this.restart("sourceBuffer FrozenFrames"),void(this.framesFrozenFor=0);try{const A=this.dataQueue[0];if(E(A)&&!this.justClearedBuffer)return this.debug("Got keyframe. Clearing sourcebuffer."),this.getStats(),this.sourceBuffer.remove(0,1/0),void(this.justClearedBuffer=!0);this.dataQueue.shift(),this.sourceBuffer.appendBuffer(A),this.stats.reportFrameSubmitted()}catch(A){t.RainwayLogging.error(String(A)),this.restart("submitData, sourceBuffer.appendBuffer error.")}}else this.debug("Idling because !element")}else this.debug("Idling because !sourceBuffer");else this.debug("Idling because mediaSource === undefined")}initializeMedia(){var A,I;return e(this,void 0,void 0,(function*(){if(this.setReadyState(Q.VideoReadyState.Initializing),this.cancelInitializeEvent.invoke(),void 0!==this.mediaSource)return this.setReadyState(Q.VideoReadyState.Playing),void(null===(A=this.element)||void 0===A||A.play());if(!this.element)throw new Error("Stream not attached to element.");try{const A=yield i.createMediaSource(this.element,this.cancelInitializeEvent);if(!A)return void this.setReadyState(Q.VideoReadyState.WaitingForKeyframe);this.mediaSource=A,this.sourceBuffer=i.createSourceBuffer(this.mediaSource,this.codecString),this.sourceBuffer.addEventListener("updateend",this.sourceBufferUpdateHandler),this.sourceBuffer.addEventListener("error",(A=>console.error("sourceBuffer error:",A))),this.startEnsuringBuffer(),this.setReadyState(Q.VideoReadyState.Playing),this.requestNextFrameCallback(),this.submitData(),null===(I=this.element)||void 0===I||I.play()}catch(A){this.setReadyState(Q.VideoReadyState.WaitingForKeyframe)}}))}startEnsuringBuffer(){void 0===this.ensureBufferInterval&&(this.debug("Starting ensureBuffer loop"),this.ensureBufferInterval=window.setInterval(this.ensureBuffer,1e3))}destroyMedia(){var A,I;if(this.debug("destroyMedia() called"),void 0!==this.mediaSource){if(this.cancelFrameCallback(),null===(A=this.element)||void 0===A||A.pause(),null===(I=this.sourceBuffer)||void 0===I||I.removeEventListener("updateend",this.sourceBufferUpdateHandler),this.mediaSource){if(this.sourceBuffer){try{this.mediaSource.removeSourceBuffer(this.sourceBuffer)}catch(A){}this.sourceBuffer=void 0}if("open"===this.mediaSource.readyState)try{this.mediaSource.endOfStream()}catch(A){}this.mediaSource=void 0,this.element&&window.URL.revokeObjectURL(this.element.src)}window.clearInterval(this.ensureBufferInterval),this.ensureBufferInterval=void 0,this.setReadyState(Q.VideoReadyState.WaitingForKeyframe)}}restart(A=""){const I=A?`Restarting Video Stream... Reason: '${A}'.`:"Restarting Video Stream.";this.warn(I),this.dataQueue=[],this.setReadyState(Q.VideoReadyState.WaitingForKeyframe),this.needsRestartEvent.invoke()}requestNextFrameCallback(){var A,I,g,e;"requestVideoFrameCallback"in HTMLVideoElement.prototype?(this.frameHandle&&(null===(I=null===(A=this.element)||void 0===A?void 0:A.cancelVideoFrameCallback)||void 0===I||I.call(A,this.frameHandle),this.frameHandle=void 0),this.frameHandle=null===(e=null===(g=this.element)||void 0===g?void 0:g.requestVideoFrameCallback)||void 0===e?void 0:e.call(g,this.videoFrameHandler)):(this.frameHandle&&(window.cancelAnimationFrame(this.frameHandle),this.frameHandle=void 0),this.frameHandle=window.requestAnimationFrame(this.fallbackVideoFrameHandler))}cancelFrameCallback(){var A,I;"requestVideoFrameCallback"in HTMLVideoElement.prototype?this.frameHandle&&(null===(I=null===(A=this.element)||void 0===A?void 0:A.cancelVideoFrameCallback)||void 0===I||I.call(A,this.frameHandle),this.frameHandle=void 0):this.frameHandle&&(window.cancelAnimationFrame(this.frameHandle),this.frameHandle=void 0)}dispose(){this.cancelFrameCallback(),this.destroyMedia(),window.clearInterval(this.ensureBufferInterval),this.setReadyState(Q.VideoReadyState.Disposed)}}},146:function(A,I,g){"use strict";var e=this&&this.__importDefault||function(A){return A&&A.__esModule?A:{default:A}};Object.defineProperty(I,"__esModule",{value:!0}),I.VideoStreamSoftwareDecoder=void 0;const B=g(434),i=g(24),Q=g(425),t=e(g(859)),C=e(g(756)),E=e(g(346)),o=g(464),a=g(441);I.VideoStreamSoftwareDecoder=class{constructor(A,I){this.codecString=A,this.format=I,this.readyState=B.VideoReadyState.Detached,this.needsRestartEvent=new i.Action,this.readyStateChangeEvent=new i.Action,this.videoFrameProcessingDurationEvent=new i.Action,this.videoFrameEvent=new i.Action,this.currentFrameInfo={containsSPS:!1,containsPPS:!1,containsFrameData:!0},this.paused=!1,this.stats=new a.VideoStats,this.totalFrames=0,this.waitingToDecodeQueue=[],this.decodeQueue=[],this.maxDecodeQueueSize=3,this.maxLatencyFrameCount=7,this.maxConsecutiveFramesDrops=3,this.framesDroppedSinceLastRender=0,this.totalFramesDropped=0,this.canvas=void 0,this.shader=void 0,this.yTexture=void 0,this.uTexture=void 0,this.vTexture=void 0,this.onDecode=({width:A,height:I,data:g})=>{if(0==this.decodeQueue.length)return o.RainwayLogging.error("[VideoStreamSoftwareDecoder] onDecode called with empty decoder queue!"),void this.sendDecoderWaitingToDecodeFrames();++this.totalFrames;const e=this.decodeQueue.shift();if(!this.paused){const B=Date.now();if(e.processingDuration=(B-e.mediaTime)/1e3,this.videoFrameProcessingDurationEvent.invoke(e.processingDuration),this.dataQueueLength>this.maxLatencyFrameCount&&this.framesDroppedSinceLastRender<this.maxConsecutiveFramesDrops)++this.framesDroppedSinceLastRender,++this.totalFramesDropped;else{this.framesDroppedSinceLastRender=0;const B=e.width,i=e.height;e.width=A,e.height=I,this.stats.pushFrameMetadata(e),this.renderFrame(B,i,g,A,I),this.videoFrameEvent.invoke([performance.now(),e])}}this.sendDecoderWaitingToDecodeFrames()},this.ensureBuffer=()=>{this.readyState===B.VideoReadyState.WaitingForKeyframe&&0===this.dataQueueLength&&(o.RainwayLogging.debug("Sending another request for a keyframe."),this.restart())},this.videoFormat=I,this.decoderWorker=new t.default,this.decoderWorker.initialize(),this.decoderWorker.onDecode=this.onDecode.bind(this),this.ensureBufferInterval=window.setInterval(this.ensureBuffer,1e3)}get dataQueueLength(){return this.waitingToDecodeQueue.length+this.decodeQueue.length}configure(A,I,g){this.maxDecodeQueueSize=A,this.maxLatencyFrameCount=I,this.maxConsecutiveFramesDrops=g}attachToElement(A){this.stats.resetFrameCounts(),this.readyState!=B.VideoReadyState.WaitingForKeyframe&&this.restart()}attachToCanvas(A){this.readyState!=B.VideoReadyState.WaitingForKeyframe&&this.restart(),this.canvas&&this.detachFromCanvas(),this.canvas=A;const I=A.getContext("webgl");this.shader=C.default.create(I),this.yTexture=E.default.create(I),this.uTexture=E.default.create(I),this.vTexture=E.default.create(I)}detachFromElement(){this.setReadyState(B.VideoReadyState.Detached)}detachFromCanvas(){this.decoderWorker.release(),this.yTexture&&this.yTexture.delete(),this.uTexture&&this.uTexture.delete(),this.vTexture&&this.vTexture.delete(),this.canvas=void 0}pause(){this.paused=!0,this.setReadyState(B.VideoReadyState.Paused)}play(){this.paused&&(this.paused=!1,this.restart())}restart(){this.totalFrames=0,this.totalFramesDropped=0,this.framesDroppedSinceLastRender=0,this.waitingToDecodeQueue=[],this.setReadyState(B.VideoReadyState.WaitingForKeyframe),this.needsRestartEvent.invoke()}pushData(A,I){var g,e,i;if(this.stats.pushData(I),this.paused)return;const t=new Uint8Array(I);let C=!1;if(this.videoFormat==Q.RainwayVideoFormat.LengthPrefixed?C=this.convertToAnnexbFormat(t):this.readyState==B.VideoReadyState.WaitingForKeyframe&&(C=this.parseAnnexbFrameInfo(t)),this.readyState==B.VideoReadyState.WaitingForKeyframe)if(C)this.setReadyState(B.VideoReadyState.Playing);else if(!(null===(g=this.currentFrameInfo)||void 0===g?void 0:g.containsFrameData))return((null===(e=this.currentFrameInfo)||void 0===e?void 0:e.containsSPS)||(null===(i=this.currentFrameInfo)||void 0===i?void 0:i.containsPPS))&&this.decoderWorker.decode(t),this.currentFrameInfo.containsSPS=!1,this.currentFrameInfo.containsPPS=!1,void(this.currentFrameInfo.containsFrameData=!0);if(this.readyState!=B.VideoReadyState.WaitingForKeyframe&&this.currentFrameInfo.containsFrameData){const I={width:A.width,height:A.height,mediaTime:Date.now(),processingDuration:0,expectedDisplayTime:0,presentationTime:0,presentedFrames:0};this.decode(I,t)}}convertToAnnexbFormat(A){let I=!1;this.currentFrameInfo.containsFrameData=!1;for(let g=0;g<A.length;){const e=this.ntohl(A,g);A[g]=0,A[++g]=0,A[++g]=0,A[++g]=1,++g;const B=31&A[g];B<=5&&B>=1?(I=5==B,this.currentFrameInfo.containsFrameData=!0):7==B?this.currentFrameInfo.containsSPS=!0:8==B&&(this.currentFrameInfo.containsPPS=!0),g+=e}return I}ntohl(A,I){return(255&A[I])<<24|(255&A[I+1])<<16|(255&A[I+2])<<8|255&A[I+3]}parseAnnexbFrameInfo(A){let I=!1;this.currentFrameInfo.containsFrameData=!1;for(let g=0;g<A.length;)if(0==A[g]&&0==A[g+1]){let e=0;if(1==A[g+2]?(g+=3,e=31&A[g]):0==A[g+2]&&1==A[g+3]?(g+=4,e=31&A[g]):++g,e<=5&&e>=1){if(this.currentFrameInfo.containsFrameData=!0,5==e){I=!0;break}}else 7==e?this.currentFrameInfo.containsSPS=!0:8==e&&(this.currentFrameInfo.containsPPS=!0)}else++g;return I}decode(A,I){0==this.decodeQueue.length?(0!=this.waitingToDecodeQueue.length&&(o.RainwayLogging.error("[VideoStreamSoftwareDecoder] empty decoder queue, but waiting to decode queue not empty!"),this.waitingToDecodeQueue=[]),this.sendToDecoder(A,I)):(this.waitingToDecodeQueue.push({metadata:A,data:I}),this.decodeQueue.length<this.maxDecodeQueueSize&&this.sendDecoderWaitingToDecodeFrames())}sendDecoderWaitingToDecodeFrames(){for(;this.decodeQueue.length<this.maxDecodeQueueSize&&this.waitingToDecodeQueue.length>0;){const A=this.waitingToDecodeQueue.shift();this.sendToDecoder(A.metadata,A.data)}}sendToDecoder(A,I){this.stats.reportFrameSubmitted(),this.decodeQueue.push(A),this.decoderWorker.decode(I)}renderFrame(A,I,g,e,B){this.canvas.width=A,this.canvas.height=I;const i=new Uint8Array(g),Q=e*B,t=i.subarray(0,Q),C=Q>>2,E=i.subarray(Q,Q+C),o=i.subarray(Q+C,Q+2*C);this.yTexture.uploadBuffer(t,e,B);const a=e>>1,n=B>>1;this.uTexture.uploadBuffer(E,a,n),this.vTexture.uploadBuffer(o,a,n),this.shader.bindInputTextures(this.yTexture,this.uTexture,this.vTexture);const s=A/e,r=I/B;this.shader.update(e,B,s,r),this.shader.draw()}getStats(){return this.stats.createReport(this.totalFramesDropped,this.totalFrames)}setReadyState(A){this.readyState=A,this.readyStateChangeEvent.invoke(A)}dispose(){o.RainwayLogging.debug("Disposing VideoStreamSoftwareDecoder"),this.readyState=B.VideoReadyState.Disposed,this.decoderWorker.release(),this.decoderWorker.dispose(),window.clearInterval(this.ensureBufferInterval)}}},104:function(A,I,g){"use strict";var e,B=this&&this.__awaiter||function(A,I,g,e){return new(g||(g=Promise))((function(B,i){function Q(A){try{C(e.next(A))}catch(A){i(A)}}function t(A){try{C(e.throw(A))}catch(A){i(A)}}function C(A){var I;A.done?B(A.value):(I=A.value,I instanceof g?I:new g((function(A){A(I)}))).then(Q,t)}C((e=e.apply(A,I||[])).next())}))},i=this&&this.__classPrivateFieldGet||function(A,I){if(!I.has(A))throw new TypeError("attempted to get private field on non-instance");return I.get(A)},Q=this&&this.__classPrivateFieldSet||function(A,I,g){if(!I.has(A))throw new TypeError("attempted to set private field on non-instance");return I.set(A,g),g};Object.defineProperty(I,"__esModule",{value:!0}),I.Gateway=I.getHandshakeDataBase64=I.getPeerId=I.GatewayStatus=void 0;const t=g(290),C=g(994),E=g(464),o=g(904),a=g(24);var n;function s(A,I,g){const e=o.GatewayIdentity.encode({id:A,apiKey:I,externalId:g});return btoa(String.fromCharCode(...e)).replace(/=*$/,"").replace(/\+/g,"-").replace(/\//g,"_")}!function(A){A[A.Open=0]="Open",A[A.Closed=1]="Closed"}(n=I.GatewayStatus||(I.GatewayStatus={})),I.getPeerId=function(A){var I;return B(this,void 0,void 0,(function*(){const g=yield t.getOrganizationInfo(A),e=`rainway-hostname-${g.organizationId.toString(16).padStart(8,"0")}-${g.universeFlag}`,B=BigInt(null!==(I=localStorage.getItem(e))&&void 0!==I?I:yield t.fetchNewPeerId());return localStorage.setItem(e,B.toString()),B}))},I.getHandshakeDataBase64=s,I.Gateway=class{constructor(A,I,g,i,Q,t,C="wss://gateway.rainway.network"){this.ownPeerId=A,this.apiKey=I,this.externalId=g,this.handlePeerInfo=i,this.connectionRequestHandler=Q,this.addAcceptedPeer=t,this.connections=new Map,this.connectionLostEvent=new a.Action,e.set(this,n.Closed),this.syncKey=0,this.peerIdToExternalId=new Map,this.onMessage=A=>B(this,void 0,void 0,(function*(){var I;if(void 0!==this.socket&&"[object ArrayBuffer]"===A.data.toString()){const g=o.GatewayDatagram.decode(new Uint8Array(A.data)),{header:{syncKey:e},body:B}=g;switch(B.discriminator){case o.GatewayRequest.discriminator:E.RainwayLogging.warning("got GatewayRequest?! i am not a gateway. ignoring");break;case o.GatewayResponse.discriminator:{const A=B.value.body.value;E.RainwayLogging.trace("got GatewayHello"),null===(I=this.resolveConnectToGatewayPromise)||void 0===I||I.call(this,A);break}case o.GatewayAlert.discriminator:{const{level:A,description:I}=B.value;A===o.GatewayAlertLevel.Fatal?(E.RainwayLogging.error("Fatal GatewayAlert: "+o.GatewayAlertDescription[I]),this.die(I,"The connection to the Rainway server encountered a fatal error.")):this.onNonFatalAlert(e,I);break}case o.GatewayForwardable.discriminator:this.onForwardable(e,B.value)}}})),this.onClose=A=>{this.die(A,"The connection to the Rainway server was closed.")},this.onError=A=>{this.die(A,"The connection to the Rainway server was lost.")},window.__rainwayGateway=this,this.url=C}get status(){return i(this,e)}connect(){var A;return B(this,void 0,void 0,(function*(){return null!==(A=this.connectToGatewayPromise)&&void 0!==A?A:this.connectToGatewayPromise=new Promise(((A,I)=>{this.resolveConnectToGatewayPromise=A,this.rejectConnectToGatewayPromise=I,this.open()}))}))}open(){return B(this,void 0,void 0,(function*(){this.socket=yield this.makeWebSocket(this.url),E.RainwayLogging.debug("Gateway: connected WebSocket"),this.socket.addEventListener("message",this.onMessage),this.socket.addEventListener("close",this.onClose),Q(this,e,n.Open)}))}makeWebSocket(A){return new Promise(((I,g)=>{const e=new WebSocket(A,["handshake",s(this.ownPeerId,this.apiKey,this.externalId)]);e.binaryType="arraybuffer",e.onopen=()=>{I(e)},e.onerror=A=>{this.onError(A),g(A),this.connectToGatewayPromise=void 0}}))}disconnect(){var A;if(E.RainwayLogging.debug("Gateway: close()"),void 0!==this.socket){this.socket.close(3e3,"Signaling websocket closed.");const A=this.socket;window.setTimeout((()=>{A.removeEventListener("close",this.onClose),A.removeEventListener("message",this.onMessage)}),0)}null===(A=this.rejectConnectToGatewayPromise)||void 0===A||A.call(this,void 0),Q(this,e,n.Closed),this.connectToGatewayPromise=void 0,this.resolveConnectToGatewayPromise=void 0,this.rejectConnectToGatewayPromise=void 0,this.socket=void 0,this.connections.clear()}makeDatagram(A){return{header:{syncKey:++this.syncKey},body:A}}makeForwardable(A,I){return this.makeDatagram({discriminator:o.GatewayForwardable.discriminator,value:{targetPeerId:A,body:I}})}connectToHost(A,I){const g=this.connections.get(A);if(void 0!==g){if(g.owned)throw new C.RainwayError("already connected in other direction");return g.promise}if(void 0===this.socket)throw new C.RainwayError("socket undefined in sendInitConnectionRequest");if(this.status!==n.Open)throw new C.RainwayError("signaling channel not open in sendInitConnectionRequest");const e=this.socket,B={pending:!0};return B.promise=new Promise(((g,i)=>{B.resolve=g,B.reject=i,E.RainwayLogging.trace(`Gateway: Adding ${A} to pendingConnections`);const Q=this.makeDatagram({discriminator:o.GatewayRequest.discriminator,value:{body:{discriminator:o.InitConnectionRequest.discriminator,value:{desiredTransport:I,targetPeerId:A}}}});B.syncKey=Q.header.syncKey,this.connections.set(A,B),e.send(o.GatewayDatagram.encode(Q))})),B.promise}cancelConnectionAttempt(A){const I=this.connections.get(A);void 0!==I&&I.pending&&(I.resolve({canceled:!0}),this.connections.delete(A))}deleteConnection(A){this.connections.delete(A)}sendPeerInfo(A,I,g){if(void 0===this.socket)throw new C.RainwayError("socket unset in Gateway.sendPeerInfo");const e=this.connections.get(A);if(void 0===e)throw new C.RainwayError(`can't send peer info to unknown peerId ${A}`);if(e.pending)throw new C.RainwayError(`can't send peer info to pending peerId ${A}`);const B=this.makeForwardable(A,{discriminator:o.PeerSignalingInformation.discriminator,value:{id:e.connectionRequestId,type:I,data:g}}),i=o.GatewayDatagram.encode(B);this.socket.send(i)}sendOffer(A,I){E.RainwayLogging.debug("sending offer: "+I),this.sendPeerInfo(A,o.PeerInformationType.Offer,I)}sendAnswer(A,I){E.RainwayLogging.debug("sending offer: "+I),this.sendPeerInfo(A,o.PeerInformationType.Answer,I)}sendCandidate(A,I){E.RainwayLogging.debug("sending candidate"+I.candidate),this.sendPeerInfo(A,o.PeerInformationType.Candidate,I.candidate)}onNonFatalAlert(A,I){if(I===o.GatewayAlertDescription.PeerGoneAway)for(const[I,g]of this.connections.entries())g.pending&&g.syncKey===A&&(g.reject("The target peer is not connected to Rainway."),this.connections.delete(I))}onForwardable(A,I){const{targetPeerId:g,body:e}=I;switch(e.discriminator){case o.ConnectionRequest.discriminator:{const{sourcePeerId:I,sourceExternalId:g,desiredTransport:B,id:i,expirationDate:Q}=e.value,t=i;this.peerIdToExternalId.set(I,g),this.connectionRequestHandler({peerId:I,externalId:e.value.sourceExternalId,accept:()=>{if(void 0===this.socket)throw new C.RainwayError("Couldn't send accept message because the connection to Rainway was lost.");const e=o.GatewayDatagram.encode({header:{syncKey:A},body:{discriminator:o.GatewayForwardable.discriminator,value:{targetPeerId:I,body:{discriminator:o.AcceptedConnectionRequest.discriminator,value:{sourcePeerId:this.ownPeerId,sourceExternalId:this.externalId,id:i}}}}});this.socket.send(e),this.connections.set(I,{pending:!1,owned:!0,connectionRequestId:t}),this.addAcceptedPeer(I,g,t)},reject:g=>{if(void 0===this.socket)throw new C.RainwayError("Couldn't send reject message because the connection to Rainway was lost.");const e=o.GatewayDatagram.encode({header:{syncKey:A},body:{discriminator:o.GatewayForwardable.discriminator,value:{targetPeerId:I,body:{discriminator:o.RejectedConnectionRequest.discriminator,value:{sourcePeerId:this.ownPeerId,sourceExternalId:this.externalId,id:i,reason:g}}}}});this.socket.send(e)}});break}case o.AcceptedConnectionRequest.discriminator:{const{id:A,sourcePeerId:I,sourceExternalId:g}=e.value,B=A,i=this.connections.get(I);if(void 0===i)return void E.RainwayLogging.warning("Ignoring AcceptedConnectionRequest from unexpected hostname: "+I);if(!i.pending)return void E.RainwayLogging.warning("Ignoring AcceptedConnectionRequest from already-connected hostname: "+I);i.resolve({canceled:!1,accepted:!0,connectionRequestId:B,hostExternalId:g,transportProtocol:o.PeerTransportType.SCTP}),this.connections.set(I,{pending:!1,owned:!1,promise:i.promise,connectionRequestId:B});break}case o.RejectedConnectionRequest.discriminator:{const{id:A,sourcePeerId:I,sourceExternalId:g}=e.value,B=A,i=this.connections.get(I);if(void 0===i)return void E.RainwayLogging.warning("Ignoring RejectedConnectionRequest from unexpected hostname: "+I);if(!i.pending)return void E.RainwayLogging.warning("Ignoring RejectedConnectionRequest from already-connected hostname: "+I);i.resolve({canceled:!1,accepted:!1,connectionRequestId:B,hostExternalId:g,transportProtocol:o.PeerTransportType.SCTP,reason:e.value.reason}),this.connections.delete(I);break}case o.PeerSignalingInformation.discriminator:E.RainwayLogging.trace("Got peer info:\n"+JSON.stringify(e.value)),this.handlePeerInfo(e.value)}}die(A,I){var g,e;null===(g=this.rejectConnectToGatewayPromise)||void 0===g||g.call(this,A),this.connectToGatewayPromise=void 0,this.resolveConnectToGatewayPromise=void 0,this.rejectConnectToGatewayPromise=void 0;for(const A of this.connections.values())A.pending&&A.reject(I);this.connections.clear(),null===(e=this.connectionLostEvent)||void 0===e||e.invoke(new C.RainwayError(I))}unsetConnectToGatewayPromise(){this.connectToGatewayPromise=void 0,this.resolveConnectToGatewayPromise=void 0,this.rejectConnectToGatewayPromise=void 0}},e=new WeakMap},643:function(A,I,g){"use strict";var e,B=this&&this.__awaiter||function(A,I,g,e){return new(g||(g=Promise))((function(B,i){function Q(A){try{C(e.next(A))}catch(A){i(A)}}function t(A){try{C(e.throw(A))}catch(A){i(A)}}function C(A){var I;A.done?B(A.value):(I=A.value,I instanceof g?I:new g((function(A){A(I)}))).then(Q,t)}C((e=e.apply(A,I||[])).next())}))};Object.defineProperty(I,"__esModule",{value:!0}),I.RainwayRateController=I.defaultRateControlParameters=I.QualityAdjustment=void 0;const i=g(198),Q=g(434),t=g(464),C=g(695);var E;!function(A){A[A.Up=0]="Up",A[A.Down=1]="Down"}(E=I.QualityAdjustment||(I.QualityAdjustment={})),I.defaultRateControlParameters={beatMs:2500,windowMs:4500,badBeats:2,goodBeats:4,backoffFactor:2,latenessThresholdMs:200,latenessSmoothingFactor:.9375,badLateFrameRatio:.75,initialBitrateKbps:Number(null!==(e=new URLSearchParams(window.location.search).get("initial-bitrate"))&&void 0!==e?e:5e3),qualityStepFactor:1.1875},I.RainwayRateController=class{constructor(A=I.defaultRateControlParameters,g,e,t){this.chosenVideoConfig=g,this.performanceMonitor=t,this.badBeatCount=0,this.goodBeatCount=0,this.lastAdjustment=void 0,this.history=[],this.lowestDelta=void 0,this.smoothLateness=0,this.framesThisBeat=0,this.lateFramesThisBeat=0,this.debugLatenessSmoothing=!1,this.badCpuPerfThisBeat=!1,this.badDecoderPerfThisBeat=!1,this.badCpuPerfHandler=()=>{this.badCpuPerfThisBeat=!0},this.badDecoderPerfHandler=()=>{this.badDecoderPerfThisBeat=!0},this.handleVideoReadyState=A=>{A===Q.VideoReadyState.Detached||A===Q.VideoReadyState.Paused||A===Q.VideoReadyState.WaitingForKeyframe?this.stop():this.start()},this.check=()=>B(this,void 0,void 0,(function*(){0!==this.framesThisBeat&&((yield this.beatIsBad())?this.badBeat():this.goodBeat(),this.framesThisBeat=0,this.lateFramesThisBeat=0,this.badCpuPerfThisBeat=!1,this.badDecoderPerfThisBeat=!1)})),this.ownMaximumKbps=1/0,this.chosenVideoConfigMimeType=C.videoCodecMimeType(g.codec),this.parameters=Object.assign(Object.assign({},I.defaultRateControlParameters),A),this.suggestBitrateKbps=e,this.currentBitrateKbps=this.parameters.initialBitrateKbps,this.frameVarianceMs=new i.WindowTrack(this.parameters.windowMs,i.standardDeviation)}format(A){return`[RateControl: ${this.currentBitrateKbps.toFixed(0)+"kbps"}, +${this.smoothLateness.toFixed(0)}ms] ${A}`}debug(A){t.RainwayLogging.debug(this.format(A))}info(A){t.RainwayLogging.information(this.format(A))}start(){var A,I;this.checkInterval||(this.info("Starting rate control!"),this.checkInterval=window.setInterval(this.check,this.parameters.beatMs),null===(A=this.performanceMonitor)||void 0===A||A.cpuStarvationEvent.addHandler(this.badCpuPerfHandler),null===(I=this.performanceMonitor)||void 0===I||I.decoderStrugglingEvent.addHandler(this.badDecoderPerfHandler))}stop(){var A,I;this.checkInterval&&(this.info("Stopping rate control!"),window.clearInterval(this.checkInterval),this.checkInterval=void 0,null===(A=this.performanceMonitor)||void 0===A||A.cpuStarvationEvent.removeHandler(this.badCpuPerfHandler),null===(I=this.performanceMonitor)||void 0===I||I.decoderStrugglingEvent.removeHandler(this.badDecoderPerfHandler))}feedFrameTimestamp(A){const I=performance.now()-A;(void 0===this.lowestDelta||I<this.lowestDelta||Math.abs(this.lowestDelta-I)>5e4)&&(this.lowestDelta=I);const g=I-this.lowestDelta,e=this.parameters.latenessSmoothingFactor;if(this.smoothLateness=e*this.smoothLateness+(1-e)*g,this.framesThisBeat++,this.smoothLateness>=this.parameters.latenessThresholdMs&&this.lateFramesThisBeat++,this.debugLatenessSmoothing){const A=new Array(100);A.fill("-");const I=g,e=this.smoothLateness;A[50]=".",A[Math.max(0,Math.min(Math.round(I/10+50),99))]="L",A[Math.max(0,Math.min(Math.round(e/10+50),99))]="S",this.beatIsBad().then((g=>t.RainwayLogging.debug(`${A.join("")} L=${I} S=${e} bad=${g} ld=${this.lowestDelta}`)))}}decodingInfoAtBitrate(A){return navigator.mediaCapabilities.decodingInfo({type:"media-source",video:{width:this.chosenVideoConfig.codec.width,height:this.chosenVideoConfig.codec.height,framerate:this.chosenVideoConfig.codec.refreshRate,bitrate:1e3*A,contentType:C.videoCodecMimeType(this.chosenVideoConfig.codec)}})}capabilitiesBad(){return B(this,void 0,void 0,(function*(){if(!("MediaSource"in window))return!1;if(!("mediaCapabilities"in navigator))return!1;const A=yield this.decodingInfoAtBitrate(this.currentBitrateKbps),I=yield this.decodingInfoAtBitrate(this.bitrateOneStepDownKbps());return I.smooth&&!A.smooth||I.powerEfficient&&!A.powerEfficient}))}lateFrameRatioBad(){return this.lateFramesThisBeat/this.framesThisBeat>=this.parameters.badLateFrameRatio}beatIsBad(){return B(this,void 0,void 0,(function*(){return this.badDecoderPerfThisBeat||this.badCpuPerfThisBeat||this.lateFrameRatioBad()||(yield this.capabilitiesBad())}))}badBeat(){if(this.currentBitrateKbps<=this.lowestSupportedBitrateKbps())return void this.debug(`crashed at ${this.currentBitrateKbps.toFixed(0)}kbps, ignoring bad beat`);this.badBeatCount++,this.goodBeatCount=0,this.currentBitrateKbps;const A=this.parameters.badBeats;if(this.debug(`bad beat: ${this.badBeatCount}/${A}`),this.badBeatCount>=this.parameters.badBeats){this.goodBeatCount=this.badBeatCount=0;const A=this.lastAdjustment===E.Up;this.qualityDown(),this.debug("went down in quality"),A&&this.currentBitrateKbps<this.ownMaximumKbps&&(this.ownMaximumKbps=this.currentBitrateKbps,this.info(`setting a new maximum at ${this.ownMaximumKbps.toFixed(0)}kbps`))}}goodBeat(){if(this.currentBitrateKbps>=this.ownMaximumKbps||this.currentBitrateKbps>=this.highestSupportedBitrateKbps())return this.debug(`maxed at ${this.currentBitrateKbps.toFixed(0)}kbps, ignoring good beat`),void(this.badBeatCount=0);this.goodBeatCount++,this.badBeatCount=0,this.currentBitrateKbps;const A=this.parameters.goodBeats;this.debug(`good beat: ${this.goodBeatCount}/${A}`),this.goodBeatCount>=A&&(this.goodBeatCount=this.badBeatCount=0,this.qualityUp(),this.debug("went up in quality"))}bitrateOneStepUpKbps(){return Math.min(this.highestSupportedBitrateKbps(),this.currentBitrateKbps*this.parameters.qualityStepFactor)}bitrateOneStepDownKbps(){return Math.max(this.lowestSupportedBitrateKbps(),this.currentBitrateKbps/this.parameters.qualityStepFactor)}qualityUp(){this.currentBitrateKbps=this.bitrateOneStepUpKbps(),this.suggestBitrateKbps(this.currentBitrateKbps),this.lastAdjustment=E.Up,this.history.push({time:performance.now(),bitrate:this.currentBitrateKbps})}qualityDown(){this.currentBitrateKbps=this.bitrateOneStepDownKbps(),this.suggestBitrateKbps(this.currentBitrateKbps),this.lastAdjustment=E.Down,this.history.push({time:performance.now(),bitrate:this.currentBitrateKbps}),this.lowestDelta=void 0}lowestSupportedBitrateKbps(){var A;return Number(null!==(A=new URLSearchParams(window.location.search).get("lowest-bitrate"))&&void 0!==A?A:5e3)}highestSupportedBitrateKbps(){var A;return Number(null!==(A=new URLSearchParams(window.location.search).get("max-bitrate"))&&void 0!==A?A:1e4)}}},145:function(A,I,g){"use strict";var e,B=this&&this.__awaiter||function(A,I,g,e){return new(g||(g=Promise))((function(B,i){function Q(A){try{C(e.next(A))}catch(A){i(A)}}function t(A){try{C(e.throw(A))}catch(A){i(A)}}function C(A){var I;A.done?B(A.value):(I=A.value,I instanceof g?I:new g((function(A){A(I)}))).then(Q,t)}C((e=e.apply(A,I||[])).next())}))},i=this&&this.__classPrivateFieldSet||function(A,I,g){if(!I.has(A))throw new TypeError("attempted to set private field on non-instance");return I.set(A,g),g},Q=this&&this.__classPrivateFieldGet||function(A,I){if(!I.has(A))throw new TypeError("attempted to get private field on non-instance");return I.get(A)};Object.defineProperty(I,"__esModule",{value:!0}),I.RTCTransport=void 0;const t=g(994),C=g(9),E=g(464),o=g(904),a=g(987),n=g(420),s=g(783),r={iceServers:[{urls:"stun:stun.rainway.com:3478"}]};class d extends C.RainwayTransport{constructor(A,I,g,B,Q,a){super(),this.ownPeerId=A,this.targetPeerId=I,this.sendLocalOfferSdp=g,this.sendLocalAnswerSdp=B,this.sendLocalIceCandidate=Q,this.reportStateChange=a,e.set(this,C.RainwayTransportStatus.Disconnected),this.rtcConfiguration=r,this.dataChannelsConfig={},this.syncKey=0,this.onRainwayMessage=()=>{},this.onApplicationMessage=()=>{},this.onClose=()=>{},this.handlePeerInfo=A=>{var I,g,e;if(A.type===o.PeerInformationType.Answer)E.RainwayLogging.debug("Got Answer in CRID "+A.id+"\n"+A.data),null===(I=this.peerConnection)||void 0===I||I.setRemoteDescription({type:"answer",sdp:A.data});else if(A.type===o.PeerInformationType.Offer)E.RainwayLogging.debug("Got Offer in CRID "+A.id+"\n"+A.data),null===(g=this.peerConnection)||void 0===g||g.setRemoteDescription({type:"offer",sdp:A.data}),this.sendAnswer();else{if(A.type!==o.PeerInformationType.Candidate){const I=o.PeerInformationType[A.type];throw new t.RainwayError(`unexpected PeerInformationType ${I} in handlePeerInfo`)}E.RainwayLogging.debug("Got Candidate in CRID "+A.id+"\n"+A.data),null===(e=this.peerConnection)||void 0===e||e.addIceCandidate(new RTCIceCandidate({candidate:A.data,sdpMid:"",sdpMLineIndex:0}))}},this.handleLocalIceCandidate=A=>{A.candidate&&"1"===A.candidate.candidate.split(" ")[1]&&this.sendLocalIceCandidate(A.candidate)},this.handleIceConnectionStateChange=()=>{if(!this.peerConnection)return;const A=this.peerConnection.iceConnectionState;E.RainwayLogging.information(`ICE connection state changed to ${A}`)},this.handleConnectionStateChange=()=>{var A;if(!this.peerConnection)return;const I=this.peerConnection.connectionState;E.RainwayLogging.information(`Connection state changed to ${I}`),"closed"===I||"failed"===I?(this.reportStateChange(s.RainwayPeerState.Failed),null===(A=this.openReject)||void 0===A||A.call(this),this.onClose(),i(this,e,C.RainwayTransportStatus.Disconnected),this.dispose()):"disconnected"===I?this.reportStateChange(s.RainwayPeerState.Disconnected):"connecting"===I?this.reportStateChange(s.RainwayPeerState.Connecting):"connected"===I?this.reportStateChange(s.RainwayPeerState.Connected):"new"===I&&this.reportStateChange(s.RainwayPeerState.New)},this.handleDataChannelMessage=A=>{const I=A.target.label;this.handleLabelAndData(I,new Uint8Array(A.data))},this.handleDataChannelClose=A=>{const I=A.target.label;E.RainwayLogging.warning("RTC channel closed: "+I)},this.handleDataChannelError=A=>{const I=A.target.label;E.RainwayLogging.warning("RTC channel errored: "+I)},this.chunkedMessages=new Map,this.highestChunkGroup=0;const n={protocol:"sctp",negotiated:!1},d={ordered:!1,maxRetransmits:0};this.dataChannelsConfig={RW_Logic:Object.assign(Object.assign({id:0},n),{ordered:!0}),RW_Video:Object.assign(Object.assign({id:1},n),d),RW_Audio:Object.assign(Object.assign({id:2},n),d),RW_Input:Object.assign(Object.assign({id:3},n),d)}}createDataChannel(A,I){var g,e;const B={protocol:"sctp",negotiated:!1},i=null===(g=this.peerConnection)||void 0===g?void 0:g.createDataChannel(A,I===n.RainwayChannelMode.Reliable?Object.assign(Object.assign({},B),{ordered:!0}):Object.assign(Object.assign({},B),{ordered:!1,maxRetransmits:0}));return i&&(i.addEventListener("close",this.handleDataChannelClose),i.addEventListener("error",this.handleDataChannelError),i.addEventListener("message",this.handleDataChannelMessage),null!==(e=this.dataChannels)&&void 0!==e||(this.dataChannels={}),this.dataChannels[A]=i),i}sendMessage(A,I){var g;if(!A)throw new t.RainwayError("sendMessage: no label");if(!this.dataChannels)throw new t.RainwayError("sendMessage: dataChannels not initialized");const e=null===(g=this.dataChannels)||void 0===g?void 0:g[A];if(!e)throw new t.RainwayError(`sendMessage: channel "${A}" does not exist`);if("open"!==e.readyState)throw new t.RainwayError(`sendMessage: channel "${A}" is not open`);e.send(I)}get status(){return Q(this,e)}get maxMessageSize(){var A,I,g;return null!==(g=null===(I=null===(A=this.peerConnection)||void 0===A?void 0:A.sctp)||void 0===I?void 0:I.maxMessageSize)&&void 0!==g?g:262144}getStats(){return B(this,void 0,void 0,(function*(){if(!this.peerConnection)throw new t.RainwayError("getStats() but no peerConnection");const A=yield this.peerConnection.getStats(void 0),I={channels:{},raw:A};return A.forEach((A=>{"data-channel"===A.type&&(I.channels[A.label]=A)})),I}))}checkHeader(A){if(2036430674!==A.magicNumber)throw new t.RainwayError("Invalid magicNumber in checkHeader.");if(A.targetPeerId!==this.ownPeerId)throw new t.RainwayError("Invalid destination host name (not ours) in checkHeader.")}handleLabelAndData(A,I){if("RW_Logic"===A){const A=o.LogicDatagram.decode(I);this.checkHeader(A.header),this.onRainwayMessage({kind:"Logic",body:A.body})}else if("RW_Input"===A){const A=o.InputDatagram.decode(I);this.checkHeader(A.header),this.onRainwayMessage({kind:"Input",body:A.body})}else if("RW_Audio"===A||"RW_Video"==A){const g=o.MediaDatagram.decode(I);this.checkHeader(g.header),g.body.discriminator===o.MediaChunk.discriminator?this.handleChunk(A,g.body.value.chunk):this.onRainwayMessage({kind:"Media",body:g.body})}else if(/^RW_/.test(A))E.RainwayLogging.warning(`Unknown Rainway-reserved RTC label? ${A}`);else{const g=o.ArbitraryDatagram.decode(I);this.checkHeader(g.header),this.handleChunk(A,g.body)}}getDatagramHeader(A){return{magicNumber:2036430674,syncKey:A?++this.syncKey:0,sourcePeerId:this.ownPeerId,targetPeerId:this.targetPeerId}}sendArbitraryDatagram(A,I){a.eachChunk(I,(I=>{this.sendMessage(A,o.ArbitraryDatagram.encode({header:this.getDatagramHeader(!0),body:I}))}))}sendLogicDatagram(A){this.sendMessage("RW_Logic",o.LogicDatagram.encode({header:this.getDatagramHeader(!0),body:A}))}sendInputDatagram(A){this.sendMessage("RW_Input",o.InputDatagram.encode({header:this.getDatagramHeader(!1),body:A}))}open(A){return B(this,void 0,void 0,(function*(){yield new Promise(((I,g)=>B(this,void 0,void 0,(function*(){var B;this.openResolve=I,this.openReject=g,i(this,e,C.RainwayTransportStatus.Connecting),this.peerConnection=new RTCPeerConnection(this.rtcConfiguration),this.peerConnection.addEventListener("iceconnectionstatechange",this.handleIceConnectionStateChange),this.peerConnection.addEventListener("connectionstatechange",this.handleConnectionStateChange),this.handleConnectionStateChange(),null!==(B=this.dataChannels)&&void 0!==B||(this.dataChannels={});const Q=Object.keys(this.dataChannelsConfig).length;let t=0;const E=(A,g)=>{const B=()=>{var A;++t,t===Q&&(null===(A=this.peerConnection)||void 0===A||A.removeEventListener("icecandidate",this.handleLocalIceCandidate),i(this,e,C.RainwayTransportStatus.Connected),I()),g.removeEventListener("open",B)};g.addEventListener("open",B),g.addEventListener("close",this.handleDataChannelClose),g.addEventListener("error",this.handleDataChannelError),g.addEventListener("message",this.handleDataChannelMessage)};if("offer"===A)for(const[A,I]of Object.entries(this.dataChannelsConfig)){const g=this.peerConnection.createDataChannel(A,I);this.dataChannels[A]=g,g.binaryType="arraybuffer",E(0,g)}else this.peerConnection.addEventListener("datachannel",(A=>{var I;const g=A.channel.label;null!==(I=this.dataChannels)&&void 0!==I||(this.dataChannels={}),this.dataChannels[g]=A.channel,E(A.channel.label,A.channel)}));this.peerConnection.addEventListener("icecandidate",this.handleLocalIceCandidate),"offer"===A&&(yield this.sendOffer())}))))}))}sendOffer(){return B(this,void 0,void 0,(function*(){if(void 0===this.peerConnection)throw new t.RainwayError("sendOffer(): no peer connection");const A=yield this.peerConnection.createOffer();if(yield this.peerConnection.setLocalDescription(A),!A.sdp)throw new t.RainwayError("Created offer contained no sdp?");this.sendLocalOfferSdp(A.sdp)}))}sendAnswer(){return B(this,void 0,void 0,(function*(){if(void 0===this.peerConnection)throw new t.RainwayError("sendOffer(): no peer connection");const A=yield this.peerConnection.createAnswer();if(yield this.peerConnection.setLocalDescription(A),!A.sdp)throw new t.RainwayError("Created answer contained no sdp?");this.sendLocalAnswerSdp(A.sdp)}))}close(){var A;this.status!==C.RainwayTransportStatus.Disconnected&&(E.RainwayLogging.debug("rtc-transport close()."),null===(A=this.peerConnection)||void 0===A||A.close(),this.onClose(),this.dispose())}dispose(){var A,I,g;if(null===(A=this.peerConnection)||void 0===A||A.removeEventListener("iceconnectionstatechange",this.handleIceConnectionStateChange),null===(I=this.peerConnection)||void 0===I||I.removeEventListener("connectionstatechange",this.handleConnectionStateChange),null===(g=this.peerConnection)||void 0===g||g.removeEventListener("icecandidate",this.handleLocalIceCandidate),this.dataChannels)for(const A of Object.values(this.dataChannels))A.removeEventListener("message",this.handleDataChannelMessage);this.dataChannels=void 0,this.peerConnection=void 0,this.openResolve=void 0,this.openReject=void 0}handleChunk(A,I){I.groupId<this.highestChunkGroup&&(this.chunkedMessages=new Map,this.highestChunkGroup=0);let g=this.chunkedMessages.get(I.groupId);if(g||(g={receivedChunkCount:0,chunks:[]},this.chunkedMessages.set(I.groupId,g)),g.chunks[I.index]=I.data,g.receivedChunkCount++,g.receivedChunkCount===I.chunksInGroup){this.highestChunkGroup=I.groupId,this.chunkedMessages.delete(I.groupId);const e=a.reassemble(g);/^RW_(Logic|Input|Audio|Video)$/.test(A)?this.handleLabelAndData(A,e):this.onApplicationMessage(A,e)}}}I.RTCTransport=d,e=new WeakMap},9:(A,I)=>{"use strict";var g;Object.defineProperty(I,"__esModule",{value:!0}),I.RainwayTransport=I.RainwayTransportStatus=void 0,(g=I.RainwayTransportStatus||(I.RainwayTransportStatus={}))[g.Disconnected=0]="Disconnected",g[g.Connecting=1]="Connecting",g[g.Connected=2]="Connected",I.RainwayTransport=class{}},420:function(A,I,g){"use strict";var e,B,i,Q,t=this&&this.__awaiter||function(A,I,g,e){return new(g||(g=Promise))((function(B,i){function Q(A){try{C(e.next(A))}catch(A){i(A)}}function t(A){try{C(e.throw(A))}catch(A){i(A)}}function C(A){var I;A.done?B(A.value):(I=A.value,I instanceof g?I:new g((function(A){A(I)}))).then(Q,t)}C((e=e.apply(A,I||[])).next())}))},C=this&&this.__classPrivateFieldSet||function(A,I,g){if(!I.has(A))throw new TypeError("attempted to set private field on non-instance");return I.set(A,g),g},E=this&&this.__classPrivateFieldGet||function(A,I){if(!I.has(A))throw new TypeError("attempted to get private field on non-instance");return I.get(A)};Object.defineProperty(I,"__esModule",{value:!0}),I.RainwayPeer=I.RainwayChannelMode=I.PeerState=void 0;const o=g(904),a=g(824),n=g(464),s=g(514),r=g(876),d=g(994);var h,c;!function(A){A[A.ExchangingInfo=0]="ExchangingInfo",A[A.Ready=1]="Ready",A[A.Disconnected=2]="Disconnected"}(h=I.PeerState||(I.PeerState={})),(c=I.RainwayChannelMode||(I.RainwayChannelMode={}))[c.Unreliable=0]="Unreliable",c[c.Reliable=1]="Reliable",I.RainwayPeer=class{constructor(A,I,g,t,E,o,a){this.transport=g,this.outerOnClose=t,this.onError=E,this.onStreamAnnouncement=o,this.onStreamStop=a,e.set(this,h.ExchangingInfo),B.set(this,new Map),i.set(this,void 0),Q.set(this,void 0),this.lastTimestamp=void 0,C(this,i,A),C(this,Q,I),g.onRainwayMessage=this.onMessage.bind(this),g.onClose=this.onClose.bind(this),this.readyToStream=new Promise(((A,I)=>{this.resolveReadyToStream=A}))}get state(){return E(this,e)}get stream(){const A=[...E(this,B).entries()];if(0!==A.length)return A.sort(((A,I)=>A[0]-I[0])),A[0][1]}get streams(){return E(this,B)}get peerId(){return E(this,i)}get externalId(){return E(this,Q)}onClose(){C(this,e,h.Disconnected),this.outerOnClose()}sendDeviceInfoAndExchangeCodecs(){if(E(this,e)===h.Disconnected)throw new d.RainwayError("Couldn't send device info and exchange codecs: peer is disconnected");this.sendDeviceInfo(),this.exchangeCodecs().then((A=>{var I,g;0===A.length?null===(I=this.resolveReadyToStream)||void 0===I||I.call(this,!1):(this.transport.sendLogicDatagram({discriminator:o.ClientCapabilities.discriminator,value:s.makeClientCapabilities(A)}),null===(g=this.resolveReadyToStream)||void 0===g||g.call(this,!0)),C(this,e,h.Ready)}))}onMessage(A){"Logic"===A.kind?this.handleLogicMessage(A.body):"Input"===A.kind?this.handleInputMessage(A.body):"Media"===A.kind&&this.handleMediaMessage(A.body)}sendDeviceInfo(){if(E(this,e)===h.Disconnected)throw new d.RainwayError("Couldn't send device info: peer is disconnected");this.transport.sendLogicDatagram({discriminator:o.DeviceInfo.discriminator,value:{isWeb:!0,formFactor:o.FormFactor.Computer,deviceName:"deviceName",deviceId:"deviceId",deviceModel:"",deviceOs:o.OperatingSystem.Other,deviceOsVersion:"",userAgent:navigator.userAgent}})}send(A,I){if(E(this,e)===h.Disconnected)throw new d.RainwayError("Couldn't send message: peer is disconnected");this.transport.sendArbitraryDatagram(A,I)}disconnect(){for(const A of E(this,B).values())A.leave();E(this,B).clear(),this.transport.close()}requestStream(A){return t(this,void 0,void 0,(function*(){if(E(this,e)===h.Disconnected)throw new d.RainwayError("Couldn't request stream: peer is disconnected");return yield this.readyToStream,this.transport.sendLogicDatagram({discriminator:o.StreamRequest.discriminator,value:{inputLevel:A}}),new Promise(((A,I)=>{this.resolveStream=A,this.rejectStream=I}))}))}handleLogicMessage(A){var I;return t(this,void 0,void 0,(function*(){if(A.discriminator===o.DeviceInfo.discriminator)n.RainwayLogging.debug("Got remote DeviceInfo:\n"+JSON.stringify(A.value));else if(A.discriminator===o.CodecPackRequest.discriminator)this.transport.sendLogicDatagram({discriminator:o.CodecPackResponse.discriminator,value:{videoCodecs:[]}});else if(A.discriminator===o.CodecPackResponse.discriminator)null===(I=this.codecsResolve)||void 0===I||I.call(this,A.value.videoCodecs);else if(A.discriminator===o.ClientCapabilities.discriminator)n.RainwayLogging.debug("Got remote ClientCapabilities:\n"+JSON.stringify(A.value));else if(A.discriminator===o.StreamRequest.discriminator)n.RainwayLogging.warning("Got remote StreamRequest?\n"+JSON.stringify(A.value));else if(A.discriminator===o.StreamStarting.discriminator)if(void 0===this.resolveStream)this.onStreamAnnouncement({info:A.value,join:()=>t(this,void 0,void 0,(function*(){const I=yield this.createStream(A.value);return E(this,B).set(I.streamId,I),this.transport.sendLogicDatagram({discriminator:o.JoinStream.discriminator,value:{streamId:A.value.streamId}}),I}))});else{const I=yield this.createStream(A.value);E(this,B).set(I.streamId,I),this.transport.sendLogicDatagram({discriminator:o.JoinStream.discriminator,value:{streamId:A.value.streamId}}),this.resolveStream(I),this.resolveStream=void 0,this.rejectStream=void 0}else A.discriminator===o.RejectStreamRequest.discriminator?void 0!==this.rejectStream?(this.rejectStream(A.value.reason),this.resolveStream=void 0,this.rejectStream=void 0):n.RainwayLogging.warning("Got RejectStreamRequest, but didn't ask for a stream."):A.discriminator===o.LeaveStream.discriminator?n.RainwayLogging.warning("Got remote LeaveStream?\n"+JSON.stringify(A.value)):A.discriminator===o.StreamStopping.discriminator&&(n.RainwayLogging.debug("Got remote StreamStopping:\n"+JSON.stringify(A.value)),this.discardStream(A.value.streamId))}))}createStream(A){return r.RainwayStream.createAndInitialize(this,A.streamId,A.inputLevel,A.chosenAudioConfig,A.chosenVideoConfig,A.captureMode,(A=>this.transport.sendInputDatagram(A)),(A=>this.transport.sendLogicDatagram(A)),(()=>this.transport.getStats()),(()=>this.discardStream(A.streamId)))}discardStream(A){const I=E(this,B).get(A);void 0!==I&&this.onStreamStop(I),E(this,B).delete(A)}handleInputMessage(A){if(A.discriminator===o.GamepadRumble.discriminator){const I=A.value.leftMotorSpeed,g=A.value.rightMotorSpeed;a.RainwayInputManager.vibrateGamepad(A.value.port,{duration:100,startDelay:0,strongMagnitude:Math.max(I,g)/65535,weakMagnitude:0})}else if(A.discriminator===o.SetClipboardText.discriminator){const I=A.value.text;navigator.clipboard.writeText(I).then((()=>{}))}else n.RainwayLogging.warning(`Ignoring unrecognized Input discriminator ${A.discriminator}`)}handleMediaMessage(A){if(A.discriminator===o.VideoData.discriminator){const{data:I,segmentTime:g,type:e,desktopRect:i,mask:Q,streamId:t}=A.value,C=E(this,B).get(t);if(!C)return;const a=I.buffer.slice(I.byteOffset,I.byteOffset+I.length),s=1e-4*Number(g);e===o.VideoDataType.FrameDiff&&void 0!==this.lastTimestamp&&s-this.lastTimestamp<3&&n.RainwayLogging.warning(`Difference between successive timestamps was ${(s-this.lastTimestamp).toFixed(1)}`),e!==o.VideoDataType.Metadata&&(this.lastTimestamp=s),C.renderVideoFrame({timestamp:s,x:i.left,y:i.top,width:i.width,height:i.height,mask:Q},a)}else if(A.discriminator===o.PointerData.discriminator){const I=E(this,B).get(A.value.streamId);if(!I)return;I.processCursor({x:A.value.positionX,y:A.value.positionY,spotX:A.value.spotX,spotY:A.value.spotY,shapeWidth:A.value.shapeWidth,shapeHeight:A.value.shapeHeight,extentWidth:A.value.monitorWidth,extentHeight:A.value.monitorHeight,visible:A.value.visible,hasPointerImage:A.value.data.length>0,pointerImage:A.value.data})}else if(A.discriminator===o.AudioData.discriminator){const I=E(this,B).get(A.value.streamId);if(!I)return;const{data:g,type:e}=A.value,i=g.buffer.slice(g.byteOffset,g.byteOffset+g.length);I.processAudio(i)}}exchangeCodecs(){return t(this,void 0,void 0,(function*(){if(E(this,e)===h.Disconnected)throw new d.RainwayError("Couldn't exchange codecs: peer is disconnected");const A=yield new Promise((A=>{this.transport.sendLogicDatagram({discriminator:o.CodecPackRequest.discriminator,value:{}}),this.codecsResolve=A}));return this.codecsResolve=void 0,A}))}createDataChannel(A,I){if(/^RW_/.test(A))throw new d.RainwayError("Data channel names starting with RW_ are reserved for Rainway");return void 0!==this.transport.createDataChannel(A,I)}},e=new WeakMap,B=new WeakMap,i=new WeakMap,Q=new WeakMap},783:function(A,I,g){"use strict";var e,B,i,Q,t,C,E=this&&this.__awaiter||function(A,I,g,e){return new(g||(g=Promise))((function(B,i){function Q(A){try{C(e.next(A))}catch(A){i(A)}}function t(A){try{C(e.throw(A))}catch(A){i(A)}}function C(A){var I;A.done?B(A.value):(I=A.value,I instanceof g?I:new g((function(A){A(I)}))).then(Q,t)}C((e=e.apply(A,I||[])).next())}))},o=this&&this.__classPrivateFieldSet||function(A,I,g){if(!I.has(A))throw new TypeError("attempted to set private field on non-instance");return I.set(A,g),g},a=this&&this.__classPrivateFieldGet||function(A,I){if(!I.has(A))throw new TypeError("attempted to get private field on non-instance");return I.get(A)};Object.defineProperty(I,"__esModule",{value:!0}),I.RainwayRuntime=I.RainwayPeerState=void 0;const n=g(104),s=g(994),r=g(464),d=g(145),h=g(904),c=g(420);var D;null!==(e=(i=DataView.prototype).setBigUint64)&&void 0!==e||(i.setBigUint64=function(A,I,g){const e=BigInt(4294967295),B=Number(I>>BigInt(32)&e),i=Number(I&e),[Q,t]=g?[4,0]:[0,4];this.setUint32(A+Q,B,g),this.setUint32(A+t,i,g)}),null!==(B=(Q=DataView.prototype).getBigUint64)&&void 0!==B||(Q.getBigUint64=function(A,I){const[g,e]=I?[4,0]:[0,4],B=BigInt(this.getUint32(A+g,I)),i=BigInt(this.getUint32(A+e,I));return B<<BigInt(32)|i}),function(A){A[A.New=0]="New",A[A.Connecting=1]="Connecting",A[A.Connected=2]="Connected",A[A.Disconnected=3]="Disconnected",A[A.Failed=4]="Failed"}(D=I.RainwayPeerState||(I.RainwayPeerState={}));class w{constructor(A,I){t.set(this,void 0),C.set(this,new Map),this.connectionTransports=new Map,this.documentVisibilityChangeHandler=()=>{if(document.hidden)for(const A of this.peers.values())for(const I of A.streams.values())I.releaseKeys(),I.pause();else for(const A of this.peers.values())for(const I of A.streams.values())I.play()},this.windowBlurHandler=()=>{for(const A of this.peers.values())for(const I of A.streams.values())I.releaseKeys()},this.beforeUnloadHandler=A=>{const I=location.hash;return[...this.peers.values()].some((A=>A.streams.size>0))&&(setTimeout((()=>{location.hash="?hj="+~~(9999*Math.random()),location.hash=I}),0),A.preventDefault(),A.returnValue=""),!1},window.__rainwayRuntime=this,o(this,t,A),this.config=Object.assign({externalId:"",preventUnloadingPage:!0,logSink:()=>{}},I),this.setLogSink(this.config.logSink),this.gateway=new n.Gateway(a(this,t),this.config.apiKey,this.config.externalId,(A=>this.handlePeerInfo(A)),(A=>this.config.onConnectionRequest(A)),((A,I,g)=>this.addPeer(A,I,g,"answer"))),this.gateway.connectionLostEvent.addHandler((A=>{a(this,C).clear(),this.config.onRuntimeConnectionLost(A)}))}get peers(){return[...a(this,C).values()]}static initialize(A){return E(this,void 0,void 0,(function*(){if(w.initialized)throw new s.RainwayError("RainwayRuntime may only be initialized once. Don't worry: you can manage multiple Rainway connections from a single RainwayRuntime object.");const I=yield n.getPeerId(A.apiKey),g=new w(I,A);return yield g.gateway.connect(),window.addEventListener("beforeunload",(A=>g.beforeUnloadHandler(A))),window.addEventListener("blur",(A=>g.windowBlurHandler())),document.addEventListener("visibilitychange",(A=>g.documentVisibilityChangeHandler())),w.initialized=!0,g}))}getPeerId(){return a(this,t)}connect(A){return E(this,void 0,void 0,(function*(){if(yield this.gateway.connect(),a(this,C).has(A))throw new s.RainwayError(`Already connected to ${A}`);const I=yield this.gateway.connectToHost(A,h.PeerTransportType.SCTP);if(I.canceled)throw new s.RainwayError("The connection attempt was canceled.");if(!I.accepted)throw new s.RainwayError(`The peer at ${A} rejected the connection, with reason: ${I.reason}`);return this.addPeer(A,I.hostExternalId,I.connectionRequestId,"offer")}))}addPeer(A,I,g,e){return E(this,void 0,void 0,(function*(){const B=new d.RTCTransport(a(this,t),A,(I=>this.gateway.sendOffer(A,I)),(I=>this.gateway.sendAnswer(A,I)),(I=>this.gateway.sendCandidate(A,I)),(A=>{this.config.onPeerStateChange(i,A)})),i=new c.RainwayPeer(A,I,B,(()=>{this.gateway.deleteConnection(A),a(this,C).delete(A)}),(A=>{this.config.onPeerError(i,A)}),(A=>{this.config.onStreamAnnouncement(i,A)}),(A=>{this.config.onStreamStop(A)}));this.connectionTransports.set(g,B),B.onApplicationMessage=(A,I)=>this.config.onPeerMessage(i,A,I);try{yield B.open(e)}finally{this.connectionTransports.delete(g)}return i.sendDeviceInfoAndExchangeCodecs(),a(this,C).set(A,i),this.config.onPeerStateChange(i,D.Connected),i}))}cancelConnectionAttempt(A){this.gateway.cancelConnectionAttempt(A)}handlePeerInfo(A){const I=this.connectionTransports.get(A.id);void 0!==I?I.handlePeerInfo(A):A.type!==h.PeerInformationType.Candidate&&r.RainwayLogging.warning("Got peer info for unexpected CRID? "+A.id)}getMediaCapabilities(A){return navigator.mediaCapabilities.decodingInfo(A)}setLogSink(A){r.RainwayLogging.setLogSink(A)}}I.RainwayRuntime=w,t=new WeakMap,C=new WeakMap,w.initialized=!1},876:function(A,I,g){"use strict";var e,B=this&&this.__awaiter||function(A,I,g,e){return new(g||(g=Promise))((function(B,i){function Q(A){try{C(e.next(A))}catch(A){i(A)}}function t(A){try{C(e.throw(A))}catch(A){i(A)}}function C(A){var I;A.done?B(A.value):(I=A.value,I instanceof g?I:new g((function(A){A(I)}))).then(Q,t)}C((e=e.apply(A,I||[])).next())}))},i=this&&this.__classPrivateFieldGet||function(A,I){if(!I.has(A))throw new TypeError("attempted to get private field on non-instance");return I.get(A)},Q=this&&this.__classPrivateFieldSet||function(A,I,g){if(!I.has(A))throw new TypeError("attempted to set private field on non-instance");return I.set(A,g),g};Object.defineProperty(I,"__esModule",{value:!0}),I.RainwayStream=void 0;const t=g(994),C=g(904),E=g(824),o=g(425),a=g(643),n=g(464),s=g(695);class r{constructor(A,I,g,B,i,Q,t,n,r,d){this.host=A,this.streamId=I,this.chosenAudioConfig=B,this.chosenVideoConfig=i,this.captureMode=Q,this.sendInput=t,this.sendLogic=n,this.peerDiscardStream=d,this.resizeDebounceHandle=void 0,e.set(this,!1),this.sendKeyframeRequest=()=>{this.sendLogic({discriminator:C.KeyframeRequest.discriminator,value:{streamId:this.streamId}})},this.feedVideoStateIntoRateController=A=>{this.rateController.handleVideoReadyState(A)},this.setRemoteClipboard=()=>{navigator.clipboard.readText().then((A=>{this.sendInput({discriminator:C.SetClipboardText.discriminator,value:{text:A}})}))};const h=document.createElement("div");h.tabIndex=0,h.style.touchAction="none",h.style.userSelect="none",h.style.webkitUserSelect="none",h.style.position="relative",h.style.width="100%",h.style.height="100%",h.className="rainway-inner-container",h.addEventListener("focus",this.setRemoteClipboard),this.innerContainer=h,this.inputManager=new E.RainwayInputManager(this),this.mediaManager=new o.MediaManager(Q,i,{video:{codecString:s.videoCodecMimeType(i.codec)}},r),this.rateController=new a.RainwayRateController(void 0,i,(A=>this.sendLogic({discriminator:C.VideoBitrateRequest.discriminator,value:{streamId:I,bitsPerSecond:1e3*A}})),this.mediaManager.videoPerformanceMonitor),h.addEventListener("click",(()=>{this.resumeAudio()})),this.mediaManager.setContainer(h),this.mediaManager.videoNeedsRestartEvent.addHandler(this.sendKeyframeRequest),this.mediaManager.videoReadyStateChangeEvent.addHandler(this.feedVideoStateIntoRateController),this.inputManager.setContainer(h),this.inputManager.setInputLevel(g),this.containerResizeObserver=new ResizeObserver((()=>{this.resizeDebounceHandle&&window.clearTimeout(this.resizeDebounceHandle),this.resizeDebounceHandle=window.setTimeout((()=>{this.sendInput({discriminator:C.ViewportResize.discriminator,value:{width:this.innerContainer.clientWidth,height:this.innerContainer.clientHeight}}),this.resizeDebounceHandle=void 0}),100)})),this.containerResizeObserver.observe(h),window.__rainwayStream=this}get dead(){return i(this,e)}get container(){return this.innerContainer}get inputLevel(){return this.inputManager.getInputLevel()}get currentFrameSize(){const{codec:A}=this.chosenVideoConfig;return{codecWidth:A.width,codecHeight:A.height,streamBounds:this.mediaManager.currentStreamBounds,fullDesktopBounds:this.mediaManager.currentFullDesktopBounds}}static createAndInitialize(A,I,g,e,i,Q,t,C,E,o){return B(this,void 0,void 0,(function*(){const B=new r(A,I,g,e,i,Q,t,C,E,o);return yield B.mediaManager.initialize(),B}))}processAudio(A){this.mediaManager.processAudio(A)}processCursor(A){this.inputManager.processCursor(A)}renderVideoFrame(A,I){this.rateController.feedFrameTimestamp(A.timestamp),this.mediaManager.renderVideoFrame(A,I)}transformPointerOffsetToRemote(A,I){const g=this.mediaManager.currentStreamBounds;if(!g)return;const e=this.mediaManager.currentFullDesktopBounds;if(!e)return;const{left:B,top:i,width:Q,height:t}=e,{left:C,top:E,width:o,height:a}=g,n=this.chosenVideoConfig.codec.width,s=this.chosenVideoConfig.codec.height,r=this.innerContainer.clientWidth,d=this.innerContainer.clientHeight,h=o*n/Q,c=a*s/t,D=Math.min(r/h,d/c);return{x:(A-(r-D*h)/2)/(D*n/Q)+C-B,y:(I-(d-D*c)/2)/(D*s/t)+E-i}}releaseKeys(){this.inputManager.releaseKeys()}enableVideoStatsOverlay(){var A;null===(A=this.mediaManager)||void 0===A||A.enableStatsOverlay()}disableVideoStatsOverlay(){var A;null===(A=this.mediaManager)||void 0===A||A.disableStatsOverlay()}requestFullscreen(A){var I,g,e;const B=null===(I=null==A?void 0:A.lockKeyboard)||void 0===I||I,i=null===(g=null==A?void 0:A.lockPointer)||void 0===g||g;if(this.innerContainer.requestFullscreen?this.innerContainer.requestFullscreen({navigationUI:"hide"}):this.innerContainer.webkitRequestFullscreen({navigationUI:"hide"}),B&&"keyboard"in navigator)try{navigator.keyboard.lock()}catch(A){}i&&(null===(e=this.inputManager)||void 0===e||e.lockPointer())}play(){if(i(this,e))throw new t.RainwayError("Attempted to play a dead stream");this.mediaManager.play(),this.rateController.start()}pause(){if(i(this,e))throw new t.RainwayError("Attempted to pause a dead stream");this.mediaManager.pause(),this.rateController.stop()}leave(){i(this,e)?n.RainwayLogging.warning("Attempted to leave a dead stream"):(this.sendLogic({discriminator:C.LeaveStream.discriminator,value:{streamId:this.streamId}}),this.peerDiscardStream(),this.innerContainer.removeEventListener("focus",this.setRemoteClipboard),this.containerResizeObserver.disconnect(),this.mediaManager.videoNeedsRestartEvent.removeHandler(this.sendKeyframeRequest),this.mediaManager.videoReadyStateChangeEvent.removeHandler(this.feedVideoStateIntoRateController),this.inputManager.dispose(),this.mediaManager.dispose(),this.rateController.stop(),Q(this,e,!0))}resumeAudio(){var A,I;null===(I=null===(A=this.mediaManager)||void 0===A?void 0:A.audioContext)||void 0===I||I.resume()}enableGestures(){var A;null===(A=this.inputManager)||void 0===A||A.enableGestures()}disableGestures(){var A;null===(A=this.inputManager)||void 0===A||A.disableGestures()}}I.RainwayStream=r,e=new WeakMap},994:(A,I)=>{"use strict";Object.defineProperty(I,"__esModule",{value:!0}),I.RainwayError=void 0;class g extends Error{constructor(A){super(`Rainway SDK Error: ${A}`),this.name=this.constructor.name,"function"==typeof Error.captureStackTrace?Error.captureStackTrace(this,this.constructor):this.stack=new Error(`Rainway SDK Error: ${A}`).stack,Object.setPrototypeOf(this,g.prototype)}}I.RainwayError=g},859:A=>{self,A.exports=(()=>{"use strict";var A={114:function(A,I,g){var e=this&&this.__importDefault||function(A){return A&&A.__esModule?A:{default:A}};Object.defineProperty(I,"__esModule",{value:!0});const B=e(g(170));class i{initialize(){return this.id=i.uniqueIdCounter++,new Promise(((A,I)=>{this.worker=new B.default,this.worker.addEventListener("message",(I=>{var g;const e=I.data;"decoderReady"===e.type?A(0):"pictureReady"===e.type&&(null===(g=this.onDecode)||void 0===g||g.call(this,e))}))}))}decode(A){this.worker&&this.worker.postMessage({type:"decode",data:A.buffer,offset:A.byteOffset,length:A.byteLength,renderStateId:this.id},[A.buffer])}release(){this.worker&&this.worker.postMessage({type:"release",renderStateId:this.id})}dispose(){this.worker&&(this.worker.terminate(),this.worker=void 0)}}I.default=i,i.uniqueIdCounter=1},170:(A,I,g)=>{g.r(I),g.d(I,{default:()=>i});var e=g(614),B=g.n(e);function i(){return B()('/*! For license information please see index.worker.js.LICENSE.txt */\n(()=>{var A={719:A=>{var I,g=(I="undefined"!=typeof document&&document.currentScript?document.currentScript.src:void 0,function(A){(A=A||{})||(A=void 0!==A?A:{});var g,B={};for(g in A)A.hasOwnProperty(g)&&(B[g]=A[g]);var Q,C=[],E="";E=self.location.href,I&&(E=I),E=0!==E.indexOf("blob:")?E.substr(0,E.lastIndexOf("/")+1):"",Q=function(A){var I=new XMLHttpRequest;return I.open("GET",A,!1),I.responseType="arraybuffer",I.send(null),new Uint8Array(I.response)};var i,D,o=A.print||console.log.bind(console),a=A.printErr||console.warn.bind(console);for(g in B)B.hasOwnProperty(g)&&(A[g]=B[g]);B=null,A.arguments&&(C=A.arguments),A.thisProgram&&A.thisProgram,A.quit&&A.quit,A.wasmBinary&&(i=A.wasmBinary),A.noExitRuntime&&A.noExitRuntime,"object"!=typeof WebAssembly&&a("no native wasm support detected");var G,S,F,N,w,y,R,h=new WebAssembly.Table({initial:1,maximum:1,element:"anyfunc"}),s=!1;function k(I){G=I,A.HEAP8=S=new Int8Array(I),A.HEAP16=N=new Int16Array(I),A.HEAP32=w=new Int32Array(I),A.HEAPU8=F=new Uint8Array(I),A.HEAPU16=new Uint16Array(I),A.HEAPU32=new Uint32Array(I),A.HEAPF32=y=new Float32Array(I),A.HEAPF64=R=new Float64Array(I)}var L=A.INITIAL_MEMORY||16777216;function M(I){for(;I.length>0;){var g=I.shift();if("function"!=typeof g){var B=g.func;"number"==typeof B?void 0===g.arg?A.dynCall_v(B):A.dynCall_vi(B,g.arg):B(void 0===g.arg?null:g.arg)}else g(A)}}(D=A.wasmMemory?A.wasmMemory:new WebAssembly.Memory({initial:L/65536,maximum:32768}))&&(G=D.buffer),L=G.byteLength,k(G),w[2188]=5251792;var U=[],Y=[],J=[],q=[],K=0,H=null,t=null;function c(I){throw A.onAbort&&A.onAbort(I),o(I+=""),a(I),s=!0,I="abort("+I+"). Build with -s ASSERTIONS=1 for more info.",new WebAssembly.RuntimeError(I)}function d(A){return I=A,g="data:application/octet-stream;base64,",String.prototype.startsWith?I.startsWith(g):0===I.indexOf(g);var I,g}A.preloadedImages={},A.preloadedAudios={};var n,p="TinyH264.wasm";function f(){try{if(i)return new Uint8Array(i);if(Q)return Q(p);throw"both async and sync fetching of the wasm failed"}catch(A){c(A)}}function r(A){try{return D.grow(A-G.byteLength+65535>>>16),k(D.buffer),1}catch(A){}}d(p)||(n=p,p=A.locateFile?A.locateFile(n,E):E+n),Y.push({func:function(){x()}});var e={a:function(A,I,g){F.copyWithin(A,I,I+g)},b:function(A){A>>>=0;var I=F.length,g=2147483648;if(A>g)return!1;for(var B,Q=1;Q<=4;Q*=2){var C=I*(1+.2/Q);if(C=Math.min(C,A+100663296),r(Math.min(g,((B=Math.max(16777216,A,C))%65536>0&&(B+=65536-B%65536),B))))return!0}return!1},memory:D,table:h},m=function(){var I={a:e};function g(I,g){var B=I.exports;A.asm=B,function(I){if(K--,A.monitorRunDependencies&&A.monitorRunDependencies(K),0==K&&(null!==H&&(clearInterval(H),H=null),t)){var g=t;t=null,g()}}()}function B(A){g(A.instance)}function Q(A){return(i||"function"!=typeof fetch?new Promise((function(A,I){A(f())})):fetch(p,{credentials:"same-origin"}).then((function(A){if(!A.ok)throw"failed to load wasm binary file at \'"+p+"\'";return A.arrayBuffer()})).catch((function(){return f()}))).then((function(A){return WebAssembly.instantiate(A,I)})).then(A,(function(A){a("failed to asynchronously prepare wasm: "+A),c(A)}))}if(K++,A.monitorRunDependencies&&A.monitorRunDependencies(K),A.instantiateWasm)try{return A.instantiateWasm(I,g)}catch(A){return a("Module.instantiateWasm callback failed with error: "+A),!1}return function(){if(i||"function"!=typeof WebAssembly.instantiateStreaming||d(p)||"function"!=typeof fetch)return Q(B);fetch(p,{credentials:"same-origin"}).then((function(A){return WebAssembly.instantiateStreaming(A,I).then(B,(function(A){a("wasm streaming compile failed: "+A),a("falling back to ArrayBuffer instantiation"),Q(B)}))}))}(),{}}();A.asm=m;var W,x=A.___wasm_call_ctors=function(){return(x=A.___wasm_call_ctors=A.asm.c).apply(null,arguments)};function X(I){function g(){W||(W=!0,A.calledRun=!0,s||(M(Y),M(J),A.onRuntimeInitialized&&A.onRuntimeInitialized(),function(){if(A.postRun)for("function"==typeof A.postRun&&(A.postRun=[A.postRun]);A.postRun.length;)I=A.postRun.shift(),q.unshift(I);var I;M(q)}()))}I=I||C,K>0||(function(){if(A.preRun)for("function"==typeof A.preRun&&(A.preRun=[A.preRun]);A.preRun.length;)I=A.preRun.shift(),U.unshift(I);var I;M(U)}(),K>0||(A.setStatus?(A.setStatus("Running..."),setTimeout((function(){setTimeout((function(){A.setStatus("")}),1),g()}),1)):g()))}if(A._h264bsdInit=function(){return(A._h264bsdInit=A.asm.d).apply(null,arguments)},A._malloc=function(){return(A._malloc=A.asm.e).apply(null,arguments)},A._free=function(){return(A._free=A.asm.f).apply(null,arguments)},A._h264bsdDecode=function(){return(A._h264bsdDecode=A.asm.g).apply(null,arguments)},A._h264bsdShutdown=function(){return(A._h264bsdShutdown=A.asm.h).apply(null,arguments)},A._h264bsdAlloc=function(){return(A._h264bsdAlloc=A.asm.i).apply(null,arguments)},A._h264bsdFree=function(){return(A._h264bsdFree=A.asm.j).apply(null,arguments)},A.asm=m,A.getValue=function(A,I,g){switch("*"===(I=I||"i8").charAt(I.length-1)&&(I="i32"),I){case"i1":case"i8":return S[A>>0];case"i16":return N[A>>1];case"i32":case"i64":return w[A>>2];case"float":return y[A>>2];case"double":return R[A>>3];default:c("invalid type for getValue: "+I)}return null},A.then=function(I){if(W)I(A);else{var g=A.onRuntimeInitialized;A.onRuntimeInitialized=function(){g&&g(),I(A)}}return A},t=function A(){W||X(),W||(t=A)},A.run=X,A.preInit)for("function"==typeof A.preInit&&(A.preInit=[A.preInit]);A.preInit.length>0;)A.preInit.pop()();return X(),A});A.exports=g},340:(A,I,g)=>{"use strict";g.r(I),g.d(I,{init:()=>o});var B=function(){function A(A,I){this.tinyH264Module=A,this.onPictureReady=I,this.pStorage=this.tinyH264Module._h264bsdAlloc(),this.pWidth=this.tinyH264Module._malloc(4),this.pHeight=this.tinyH264Module._malloc(4),this.pPicture=this.tinyH264Module._malloc(4),this._decBuffer=this.tinyH264Module._malloc(1048576),this.tinyH264Module._h264bsdInit(this.pStorage,0)}var I=A.prototype;return I.release=function(){var A=this.pStorage;0!==A&&(this.tinyH264Module._h264bsdShutdown(A),this.tinyH264Module._h264bsdFree(A)),this.tinyH264Module._free(this.pWidth),this.tinyH264Module._free(this.pHeight),this.tinyH264Module._free(this.pPicture),this.pStorage=0,this.pWidth=0,this.pHeight=0},I.decode=function(I){if(I instanceof ArrayBuffer&&(I=new Uint8Array(I)),this.tinyH264Module.HEAPU8.set(I,this._decBuffer),this.tinyH264Module._h264bsdDecode(this.pStorage,this._decBuffer,I.byteLength,this.pPicture,this.pWidth,this.pHeight)===A.PIC_RDY){var g=this.tinyH264Module.getValue(this.pWidth,"i32"),B=this.tinyH264Module.getValue(this.pHeight,"i32"),Q=this.tinyH264Module.getValue(this.pPicture,"i8*"),C=new Uint8Array(this.tinyH264Module.HEAPU8.subarray(Q,Q+g*B*3/2));this.onPictureReady(C,g,B)}},A}();B.RDY=0,B.PIC_RDY=1,B.HDRS_RDY=2,B.ERROR=3,B.PARAM_SET_ERROR=4,B.MEMALLOC_ERROR=5;const Q=B;var C=g(719),E=g.n(C),i={"TinyH264.wasm":"data:;base64,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ZGogATYCACAEIANBBHFBGHIiBGsiAkEgSQ0AIAGtIgVCIIYgBYQhBSADIARqIQEDQCABIAU3AxggASAFNwMQIAEgBTcDCCABIAU3AwAgAUEgaiEBIAJBYGoiAkEfSw0ACwsgAAvyAwEDfyABKAIAIgNB////B0cEQCABKAIEIQQgACACIAJBA3EgAkEQSSICG0ECdCIFQfApaigCAEEQQQggAhsiAmxqIAVBsClqKAIAaiIAIAMgAC0AAGpBsC5qLQAAOgAAIAEoAgghAyAAIAQgAC0AAWpBsC5qLQAAOgABIAEoAgwhBCAAIAMgAC0AAmpBsC5qLQAAOgACIAAgBCAALQADakGwLmotAAA6AAMgASgCFCEDIAAgAmoiACABKAIQIAAtAABqQbAuai0AADoAACABKAIYIQQgACADIAAtAAFqQbAuai0AADoAASABKAIcIQMgACAEIAAtAAJqQbAuai0AADoAAiAAIAMgAC0AA2pBsC5qLQAAOgADIAEoAiQhAyAAIAJqIgAgASgCICAALQAAakGwLmotAAA6AAAgASgCKCEEIAAgAyAALQABakGwLmotAAA6AAEgASgCLCEDIAAgBCAALQACakGwLmotAAA6AAIgACADIAAtAANqQbAuai0AADoAAyABKAI0IQMgACACaiIAIAEoAjAgAC0AAGpBsC5qLQAAOgAAIAEoAjghAiAAIAMgAC0AAWpBsC5qLQAAOgABIAEoAjwhASAAIAIgAC0AAmpBsC5qLQAAOgACIAAgASAALQADakGwLmotAAA6AAMLC9MQAQx/IwBBgAFrIgokACAAEA8hBEEBIQUCQAJAAn8gAkEBTQRAIARBAEgNAiAEQRl2Qf4AcUGACGogBEGAgIDgAE8NARogBEEVdkH+D3FBwAhqIARBgICACE8NARogBEERdkH+/wFxQZAJaiAEQYCAgAFPDQEaIARBEHZBAXRBkApqDAELIAJBA00EQCAEQX9MBEBBAkGiECAEQYCAgIAEcRshBQwDCyAEQRl2Qf4AcUHQCmogBEGAgICAAU8NARogBEEWdkH+B3FBkAtqIARBgICAEE8NARogBEERdkH+/wFxQdALagwBCyACQQdNBEAgBEEadiICQXhqQThJBEAgAkEBdEHQDWoMAgsgBEEVdkH+D3FB0A5qDAELIARBGXZB/gBxQdAQaiACQRBNDQAaIARBHXYiAgRAIAJBAXRB0BFqDAELIARBF3ZB/gNxQeARagsvAQAiBQ0AQQEhCwwBC0EBIQsgBUELdiIJIANLDQBBICAFQR9xIgZrIQICQCAJRQRADAELIAQgBnQhBAJAIAVBBXZBP3EiDEUEQAwBCyACIAxJBEAgACAGEAtBf0YNAyAAEA8hBEEgIQILIAQgDHQhBkEBIAxBf2p0IQcgBEEgIAxrdiEEA0AgCkFAayAIQQJ0akF/QQEgBCAHcRs2AgAgCEEBaiEIIAdBAXYiBw0ACyACIAxrIQIgBiEECyAIIAlJBEAgDEEDSSIPIAVB/68BS3EhBQNAIAJBD00EQCAAQSAgAmsQC0F/RgRADAULIAAQDyEEQSAhAgtBACEGAkACQAJ/AkAgBEEASA0AQQEhBiAEQf////8DSw0AQQIhBiAEQf////8BSw0AQQMhBiAEQf////8ASw0AQQQhBiAEQf///z9LDQBBBSEGIARB////H0sNAEEGIQYgBEH///8PSw0AQQchBiAEQf///wdLDQBBCCEGIARB////A0sNAEEJIQYgBEH///8BSw0AQQohBiAEQf///wBLDQBBCyEGIARB//8/Sw0AQQwhBiAEQf//H0sNAEENIQYgBEH//w9LDQACfwJAIARB//8HTQRAIARBgIB8cUGAgARGDQEMCgsgBUEEIAUbIQYgBEEPdCEEQQ4hByACQXFqDAELIAVBASAFGyEFIARBEHQhBEEMIQZBDyEHIAJBcGoLIQIgByAFdCEHIAVFDAELIAYgBXQhB0EBIQ4gAiAGQQFqIgZrIQIgBCAGdCEEIAVFDQEgBSEGQQALIQ4gAiAGTwR/IAQFIABBICACaxALQX9GBEAMBwtBICECIAAQDwshDSACIAZrIQIgDSAGdCEEIA1BICAGa3YgB2ohBwwBC0EAIQULIApBQGsgCEECdGpBACAHQQJqIAcgCCAMRhsgByAPGyINQQJqQQF2IgZrIAYgDUEBcRs2AgBBASAFIA4bIgUgBUEGSSAGQQMgBUF/anRKcWohBSAIQQFqIgggCUcNAAsLQQAhBwJAIAkgA08EQEEAIQgMAQsCQCACQQhLBEAgAiEFDAELQSAhBSAAQSAgAmsQC0F/Rg0DIAAQDyEECwJAAkACfwJAIANBBEcEQCAJQX9qIgJBDUsNAwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIAJBAWsODQABAgMEBQYHCAkKCwwOCyAEQRp2QeASagwOCyAEQRp2QaATagwNCyAEQRt2QeATagwMCyAEQRt2QYAUagwLCyAEQRp2QaAUagwKCyAEQRp2QeAUagwJCyAEQRp2QaAVagwICyAEQRp2QeAVagwHCyAEQRt2QaAWagwGCyAEQRx2QcAWagwFCyAEQRx2QdAWagwECyAEQR12QeAWagwDCyAEQR52QegWagwCCyAEQQBIBEBBASECDAQLQREhAiAJQQNGDQNBEiECIARB/////wNLDQNBIiECIAlBAkYNA0EjQTMgBEH/////AUsbIQIMAwsgBEEbdkGgEmogBEEXdkHAEmogBEH/////AEsbCy0AACICDQEMBAtBEUEBIARBAEgbIQILIAJBBHYhCCAFIAJBD3EiA2shAiAEIAN0IQQLIAlBf2oiAwRAA0ACfyAIBEAgAkEKTQRAIABBICACaxALQX9GBEAMBwsgABAPIQRBICECCwJAAn8CQCAIQX9qIgVBBU0EQAJAAkACQAJAAkAgBUEBaw4FAAECAwQGCyAEQR52Qe4WagwGCyAEQR52QfIWagwFCyAEQR12QfYWagwECyAEQR12Qf4WagwDCyAEQR12QYYXagwCCwJ/QfMAIARBGXZB8ABxayAEQYCAgIACTw0AGkH0ACAEQf////8ASw0AGkGFASAEQf///z9LDQAaQZYBIARB////H0sNABpBpwEgBEH///8PSw0AGkG4ASAEQf///wdLDQAaQckBIARB////A0sNABpB2gEgBEH///8BSw0AGkEAQesBIARBgICAAUkbCyIFQQR2IAhNDQIMCAsgBEEfdkHsFmoLLQAAIQULIAVFBEAMBgsgCiAHQQJ0aiAFQQR2IgZBAWo2AgAgAiAFQQ9xIgVrIQIgBCAFdCEEIAggBmsMAQsgCiAHQQJ0akEBNgIAQQALIQggB0EBaiIHIANHDQALIAEgCEECdGogCkFAayADQQJ0aigCADYCACAJQX5qIQVBASAIdCEHA0AgASAKIAUiA0ECdCIFaigCACAIaiIIQQJ0aiAKQUBrIAVqKAIANgIAIANBf2ohBUEBIAh0IAdyIQcgAw0ACwwBCyABIAhBAnRqIApBQGsgA0ECdGooAgA2AgBBASAIdCEHCyAA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ASAAKALMASADQQF0ai4BHGpBAWpBAXUPCyAFQQRGBEAgAiADQQF0ai4BACEBAn8gACgCyAEiAgRAIAAoAgQgAigCBEYMAQtBAAtFDQEgASAAKALIASAEQQF0ai4BHGpBAWpBAXUPCwJ/An8gACgCyAEiAQRAIAAoAgQgASgCBEYMAQtBAAtFBEBBACECQQAMAQtBASECIAAoAsgBIARBAXRqLgEcCyEBAn8gACgCzAEiBARAIAAoAgQgBCgCBEYMAQtBAAtFDQAgACgCzAEgA0EBdGouARwhACACRQRAIAAPCyAAIAFqQQFqQQF1IQELIAELiQcBB38gAyAFaiINIAEuAQAiDEECdWohAyAEIAZqIg4gAS4BAiIPQQJ1aiEEIAIoAghBBHQhCSACKAIEQQR0IQogACAGQQR0aiAFaiELAkAgDEEDcUEEdCAPQQNxQQJ0ckHQO2ooAgAiDEEOTQRAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIAxBAWsODgECAwQFBgcICQoLDA0OAAsgAigCACALIAMgBCAKIAkgByAIQRAQDAwPCyACKAIAIAsgAyAEQX5qIAogCSAHIAhBABAkDA4LIAIoAgAgCyADIARBfmogCiAJIAcgCBBHDA0LIAIoAgAgCyADIARBfmogCiAJIAcgCEEBECQMDAsgAigCACALIANBfmogBCAKIAkgByAIQQAQIwwLCyACKAIAIAsgA0F+aiAEQX5qIAogCSAHIAhBABAaDAoLIAIoAgAgCyADQX5qIARBfmogCiAJIAcgCEEAECEMCQsgAigCACALIANBfmogBEF+aiAKIAkgByAIQQIQGgwICyACKAIAIAsgA0F+aiAEIAogCSAHIAgQRgwHCyACKAIAIAsgA0F+aiAEQX5qIAogCSAHIAhBABAiDAYLIAIoAgAgCyADQX5qIARBfmogCiAJIAcgCBBFDAULIAIoAgAgCyADQX5qIARBfmogCiAJIAcgCEEBECIMBAsgAigCACALIANBfmogBCAKIAkgByAIQQEQIwwDCyACKAIAIAsgA0F+aiAEQX5qIAogCSAHIAhBARAaDAILIAIoAgAgCyADQX5qIARBfmogCiAJIAcgCEEBECEMAQsgAigCACALIANBfmogBEF+aiAKIAkgByAIQQMQGgsgDUEBdiABLgEAIglBA3VqIQMgDkEBdiABLgECIgFBA3VqIQQgAigCACACKAIEIgogAigCCCILbEEIdGohAiAAIAZBAnRBeHFqIAVBAXZqQYACaiEFIAhBAXYhBiAHQQF2IQcgAUEHcSEIIAtBA3QhACAKQQN0IQECQCAJQQdxIglFDQAgCEUNACACIAUgAyAEIAEgACAJIAggByAGEEgPCyAJBEAgAiAFIAMgBCABIAAgCSAHIAYQSw8LIAgEQCACIAUgAyAEIAEgACAIIAcgBhBKDwsgAiAFIAMgBCABIAAgByAGQQgQDCACIAAgAWxqIAVBQGsgAyAEIAEgACAHIAZBCBAMC8cBAQR/IAAoAgQhAgJAIAAoAgxBA3QgACgCEGsiA0EgTgRAIAIoAAAiAUEYdCABQQh0QYCA/AdxciABQQh2QYD+A3EgAUEYdnJyIQEgACgCCCIARQ0BIAEgAHQgAi0ABEEIIABrdnIPCyADQQFIBEBBAA8LIAItAAAgACgCCCIAQRhqIgR0IQEgACADakF4aiIAQQFIDQADQCACLQABIARBeGoiBHQgAXIhASAAQQhKIQMgAkEBaiECIABBeGohACADDQALCyABC4wEAQd/AkAgAEF/aiIILQAAIgUgAC0AACIGayIEIARBH3UiBGogBHMgAigCBE8NACAAQX5qLQAAIgQgBWsiByAHQR91IgdqIAdzIAIoAggiCU8NACAALQABIgcgBmsiCiAKQR91IgpqIApzIAlPDQAgAUEDTQRAIAggBSABIAIoAgBqQX9qLQAAIghBf3MiCSAIQQFqIgggBiAFa0ECdCAHayAEakEEakEDdSIFIAUgCEobIAUgCUgbIgVqQbAuai0AADoAACAAIAYgBWtBsC5qLQAAOgAADAELIAggBSAHaiAEQQF0akECakECdjoAACAAIAYgB0EBdGogBGpBAmpBAnY6AAALAkAgACADaiIAQX9qIgctAAAiAyAALQAAIgVrIgYgBkEfdSIGaiAGcyACKAIETw0AIABBfmotAAAiBiADayIEIARBH3UiBGogBHMgAigCCCIITw0AIAAtAAEiBCAFayIJIAlBH3UiCWogCXMgCE8NACABQQNNBEAgByABIAIoAgBqQX9qLQAAIgFBf3MiAiABQQFqIgcgBSADa0ECdCAEayAGakEEakEDdSIBIAEgB0obIAEgAkgbIgEg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QRBqIQELIAdBAnYiBEUNAEHAACAGayEQIAlBAXQhCiAJQQJ0IAZrIQtBACAJayIMQQF0IRIgASAHQQR0ayECIAkgE2ogCEEBcWpBAmoiACAJQQVsaiEBA0AgBiIDBEADQCACIAAgCmotAAAiBSABIApqLQAAIAEgCWotAAAiDiABIBJqLQAAIgdqIghrIAhBAnRraiABLQAAIg0gASAMai0AACIIakEUbGpBEGpBBXVBsC5qLQAAIAItADBqQQFqQQF2OgAwIAIgACAJai0AACIPIA4gByAIakEUbGogBSANaiIOayAOQQJ0a2pBEGpBBXVBsC5qLQAAIAItACBqQQFqQQF2OgAgIAIgAC0AACIOIA0gBSAHakEUbGogCCAPaiINayANQQJ0a2pBEGpBBXVBsC5qLQAAIAItABBqQQFqQQF2OgAQIAIgACAMai0AACAIIAUgD2pBFGxqIAcgDmoiBWsgBUECdGtqQRBqQQV1QbAuai0AACACLQAAakEBakEBdjoAACAAQQFqIQAgAkEBaiECIAFBAWohASADQX9qIgMNAAsLIAIgEGohAiABIAtqIQEgACALaiEAIARBf2oiBA0ACwsgEUHAA2okAAu1BQEEfyAAKAIUIQMgACgCECEEIAAoAgQhBSAAKAIMIgIgASkCADcCACACIAEpAgg3AgggAiAFQQR0IgBqIgIgASkCEDcCACACIAEpAhg3AgggACACaiICIAEpAiA3AgAgAiABKQIoNwIIIAAgAmoiAiABKQIwNwIAIAIgASkCODcCCCAAIAJqIgIgASkCQDcCACACIAEpAkg3AgggACACaiICIAEpAlA3AgAgAiABKQJYNwIIIAAgAmoiAiABKQJgNwIAIAIgASkCaDcCCCAAIAJqIgIgASkCcDcCACACIAEpAng3AgggACACaiICIAEpAoABNwIAIAIgASkCiAE3AgggACACaiICIAEpApABNwIAIAIgASkCmAE3AgggACACaiICIAEpAqABNwIAIAIgASkCqAE3AgggACACaiICIAEpArABNwIAIAIgASkCuAE3AgggACACaiICIAEpAsABNwIAIAIgASkCyAE3AgggACACaiICIAEpAtABNwIAIAIgASkC2AE3AgggACACaiICIAEpAuABNwIAIAIgASkC6AE3AgggACACaiIAIAEpAvABNwIAIAAgASkC+AE3AgggBCABKQKAAjcCACAEIAVBA3QiAGoiBCABKQKIAjcCACAAIARqIgQgASkCkAI3AgAgACAEaiIEIAEpApgCNwIAIAAgBGoiBCABKQKgAjcCACAAIARqIgQgASkCqAI3AgAgACAEaiIEIAEpArACNwIAIAAgBGogASkCuAI3AgAgAyABKQLAAjcCACAAIANqIgMgASkCyAI3AgAgACADaiIDIAEpAtACNwIAIAAgA2oiAyABKQLYAjcCACAAIANqIgMgASkC4AI3AgAgACADaiIDIAEpAugCNwIAIAAgA2oiAyABKQLwAjcCACAAIANqIAEpAvgCNwIAC+gCAQV/AkAgACABEAIiAw0AQQEhAyABIAEoAgBBAWoiAjYCACACQSBLDQAgAEEEEAMiAkF/Rg0AIAEgAjYCBCAAQQQQAyICQX9GDQAgASACNgIIIAEoAgAEQANAIAAgASAFQQJ0aiICIgRBDGoQAiIDDQJBASEDIAQoAgwiBkF/Rg0CIAQgBkEBaiIDNgIMIAQgAyABKAIEQQZqdDYCDCAAIAJBjAFqEAIiAw0CQQEhAyACKAKMASIEQX9GDQIgAiAEQQFqIgQ2AowBIAIgBCABKAIIQQRqdDYCjAEgAEEBEAMiBEF/Rg0CIAIgBEEBRjYCjAIgBUEBaiIFIAEoAgBJDQALCyAAQQUQAyICQX9GDQAgASACQQFqNgKMAyAAQQUQAyICQX9GDQAgASACQQFqNgKQAyAAQQUQAyICQX9GDQAgASACQQFqNgKUAyAAQQUQAyIAQX9GDQAgASAANgKYA0EAIQMLIAMLWwEDfyAAIAAoAgAiBCABIAAoAgQiAnAiA0EEdGogASADayIBQQh0ajYCDCAAIAQgAiAAKAIIbCICQQh0aiABQQZ0aiADQQN0aiIBNgIQIAAgASACQQZ0ajYCFAtVAQJ/IAEgAkEBaiIDIAMgAUkbIQMgACACQQJ0aigCACEEA0ACQCACQQFqIgIgAU8EQCADIQIMAQsgACACQQJ0aigCACAERw0BCwtBACACIAEgAkYbCycAIABBCCAAKAIIIgBrEANBf0YEQA8LQQAgAGtBAnRBzD9qKAIAGgt6AQJ/IwBBIGsiAiQAIAIgACgCEDYCECACIAApAgg3AwggAiAAKQIANwMAAkAgAiACQRxqEAIiAA0AIAIgAkEcahACIgANACACIAJBHGoQAiIADQBBASEAIAIoAhwiA0H/AUsNACABIAM2AgBBACEACyACQSBqJAAgAAvnBwESfyMAQYAOayIMJAAgBkEFaiEJAkACQCACQQBIDQAgA0EASA0AIAIgCWogBEsNACADIAdqQQVqIAVLDQAgAyEKDAELIAAgDEHACmogAiADIAQgBSAJIAdBBWogCRAMIAxBwApqIQAgCSEEQQAhAgsCQCAHQQJ2IhRFDQAgCUUNACAEQQF0IRVBACAEayIWQQF0IRogBEECdCAGa0F7aiEXIAAgBCAKbCACamogBGoiACAEQQVsaiECIAwgCUECdCIQaiEDIAlBA3QhDUEAIAlrQQJ0IQ4gCUEDbEECdCEPA0AgCSEFA0AgAyANaiAAIBVqLQAAIhEgAiAVai0AACACIARqLQAAIgsgAiAaai0AACISaiIKayAKQQJ0a2ogAi0AACIYIAIgFmotAAAiE2pBFGxqNgIAIAMgEGogACAEai0AACIZIAsgEiATakEUbGogESAYaiIKayAKQQJ0a2o2AgAgAyAALQAAIgsgGCARIBJqQRRsaiATIBlqIgprIApBAnRrajYCACADIA5qIAAgFmotAAAgEyARIBlqQRRsaiALIBJqIgprIApBAnRrajYCACAAQQFqIQAgA0EEaiEDIAJBAWohAiAFQX9qIgUNAAsgAiAXaiECIAAgF2ohACADIA9qIQMgFEF/aiIUDQALCyAHBEBBECAGayEQIAZBAnYhCiAMIAhBAnRqQQhqIQAgDEEUaiECA0AgCgRAIAJBbGooAgAhBCACQXBqKAIAIQ8gAkF0aigCACENIAJBeGooAgAhBSACQXxqKAIAIQMgCiEJA0AgASACKAIAIg4gBCADIA9qIgRrIAUgDWpBFGxqIARBAnRrakGABGpBCnVBsC5qLQAAIAAoAgBBEGpBBXVBsC5qLQAAakEBakEBdjoAACABIAIoAgQiCyAPIAMgBWpBFGxqIA0gDmoiBGsgBEECdGtqQYAEakEKdUGwLmotAAAgACgCBEEQakEFdUGwLmotAABqQQFqQQF2OgABIAEgAigCCCIIIA0gAyAOakEUbGogBSALaiIEayAEQQJ0a2pBgARqQQp1QbAuai0AACAAKAIIQRBqQQV1QbAuai0AAGpBAWpBAXY6AAIgASACKAIM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KAIABEAgAyAAQewMaiABIABB5ApqKAIAIAIgACgC0ApBBUYgACgCuAkgACgCtAkQKQwBCyADQQAgASAAQeQKaigCACACIAAoAtAKQQVGIAAoArgJIAAoArQJECkLIABCADcCoAlBASEFCyAEQZABaiQAIAULqAwBC38CQCABQQRPBEBBACADayINQQF0IQoCQCAAIANrIgUtAAAiBiAALQAAIghrIgEgAUEfdSIBaiABcyACKAIEIgFPDQAgACAKai0AACIHIAZrIgQgBEEfdSIEaiAEcyACKAIIIgxPDQAgACADai0AACIEIAhrIgsgC0EfdSILaiALcyAMTw0AIAUgBCAGaiAHQQF0akECakECdjoAACAAIAggBEEBdGogB2pBAmpBAnY6AAAgAigCBCEBCwJAIABBAWoiBiANaiIMLQAAIgggAC0AASIHayIEIARBH3UiBGogBHMgAU8NACAGIApqLQAAIgQgCGsiBSAFQR91IgVqIAVzIAIoAggiC08NACADIAZqLQAAIgUgB2siCSAJQR91IglqIAlzIAtPDQAgDCAFIAhqIARBAXRqQQJqQQJ2OgAAIAYgByAFQQF0aiAEakECakECdjoAACACKAIEIQELAkAgAEECaiIGIA1qIgwtAAAiCCAALQACIgdrIgQgBEEfdSIEaiAEcyABTw0AIAYgCmotAAAiBCAIayIFIAVBH3UiBWogBXMgAigCCCILTw0AIAMgBmotAAAiBSAHayIJIAlBH3UiCWogCXMgC08NACAMIAUgCGogBEEBdGpBAmpBAnY6AAAgBiAHIAVBAXRqIARqQQJqQQJ2OgAAIAIoAgQhAQsCQCAAQQNqIgYgDWoiDC0AACIIIAAtAAMiB2siBCAEQR91IgRqIARzIAFPDQAgBiAKai0AACIEIAhrIgUgBUEfdSIFaiAFcyACKAIIIgtPDQAgAyAGai0AACIFIAdrIgkgCUEfdSIJaiAJcyALTw0AIAwgBSAIaiAEQQF0akECakECdjoAACAGIAcgBUEBdGogBGpBAmpBAnY6AAAgAigCBCEBCwJAIABBBGoiBiANaiIMLQAAIgggAC0ABCIHayIEIARBH3UiBGogBHMgAU8NACAGIApqLQAAIgQgCGsiBSAFQR91IgVqIAVzIAIoAggiC08NACADIAZqLQAAIgUgB2siCSAJQR91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ayISNgI8IAAgAiANayICIAMgDmsiA2siDTYCOCAAIAIgA2oiDjYCNCAAIBMgFGoiEzYCMCABQZA8ai0AACECIAFBoD1qLQAAQQxsQdA8aigCACEDIAFBDE8EQCAAIAMgAkF+anQiASAFIAtqIgMgCCATaiICa2w2AjAgACALIAVrIgUgCCATayIIayABbDYCICAAIAUgCGogAWw2AhAgACACIANqIAFsNgIAIAAgBCAJaiIDIAcgDmoiAmsgAWw2AjQgACAJIARrIgQgByAOayIFayABbDYCJCAAIAQgBWogAWw2AhQgACACIANqIAFsNgIEIAAgBiAPaiIDIAogDWoiAmsgAWw2AjggACAPIAZrIgYgCiANayIEayABbDYCKCAAIAQgBmogAWw2AhggACACIANqIAFsNgIIIAAgDCARayIDIBAgEmsiAmsgAWw2AiwgACACIANqIAFsNgIcIAAgECASaiIDIAwgEWoiAmogAWw2AgwgACACIANrIAFsNgI8DwsgAEEBQQIgAUF6akEGSRsiASAFIAtqIhQgCCATaiIVayADbGpBAiACayICdTYCMCAAIAsgBWsiBSAIIBNrIghrIANsIAFqIAJ1NgIgIAAgBSAIaiADbCABaiACdTYCECAAIBQgFWogA2wgAWogAnU2AgAgACAEIAlqIgUgByAOaiIIayADbCABaiACdTYCNCAAIAkgBGsiBCAHIA5rIgdrIANsIAFqIAJ1NgIkIAAgBCAHaiADbCABaiACdTYCFCAAIAUgCGogA2wgAWogAnU2AgQgACAGIA9qIgQgCiANaiIFayADbCABaiACdTYCOCAAIA8gBmsiBiAKIA1rIgprIANsIAFqIAJ1NgIoIAAgBiAKaiADbCABaiACdTYCGCAAIAQgBWogA2wgAWogAnU2AgggACAMIBFrIgYgECASayIEayADbCABaiACdTYCLCAAIAQgBmogA2wgAWogAnU2AhwgACAQIBJqIgYgDCARaiIRaiADbCABaiACdTYCDCAAIBEgBmsgA2wgAWogAnU2AjwLvQUBBn8jAEEgayIFJAAgA0EANgIAAkAgASgCACIGQRJLDQBBASAGdCIGQcDfH3FFBEAgBkEicUUNASACQbQKaigCAARAIANBATYCACACQQA2ArQKCyAAIAVBHGoQICIEDQFB8P8DIQQgAiAF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IAFBf2oQA0F/RgRAQQEhAAwBCyAEIAMQBSEACyAEQSBqJAAgAAvmAQEDfyMAQSBrIgQkACAEIAAoAhA2AhAgBCAAKQIINwMIIAQgACkCADcDAAJAIAQgBEEcahACIgANACAEIARBHGoQAiIADQAgBCAEQRxqEAIiAA0AIAEoAgwhBkEAIQADQCAAIgVBAWohACAGIAV2DQALIAQgBUF/ahADQX9GBEBBASEADAELIAJBBUYEQCAEIARBHGoQAiIADQELIAEoAhQhAkEAIQADQCAAIgFBAWohACACIAF2DQALIAQgAUF/ahADIgBBf0YEQEEBIQAMAQsgAyAANgIAQQAhAAsgBEEgaiQAIAALkgEBAn8jAEEgayIDJAAgAyAAKAIQNgIQIAMgACkCADcDACADIAApAgg3AwgCQCADIANBHGoQAiIADQAgAyADQRxqEAIiAA0AIAMgA0EcahACIgANAEEAIQADQCAAIgRBAWohACABIAR2DQALIAMgBEF/ahADQX9GBEBBASEADAELIAMgAhACIQALIANBIGokACAAC5cBAQJ/IwBBIGsiAyQAIAMgACgCEDYCECADIAApAgg3AwggAyAAKQIANwMAAkAgAyADQRxqEAIiAA0AIAMgA0EcahACIgANACADIANBHGoQAiIADQBBACEAA0AgACIEQQFqIQAgASAEdg0ACyADIARBf2oQAyIAQX9GBEBBASEADAELIAIgADYCAEEAIQALIANBIGokACAAC68OAQp/IwBBEGsiBSQAIAFBAEHcBxAHIQcgAigCNCEGIAIoAjghCAJAIAAgBUEEahACIgENACAHIAUoAgQiATYCACABIAYgCGwiC08EQEEBIQEMAQsgACAFQQRqEAIiAQ0AIAcgBSgCBCIGNgIEIAZBB0sEQEEBIQEMAQtBASEBAkACQCAGQQFrDgcCAQICAAIBAAsgBCgCAEEFRgRADAILIAIoAiwNAAwBCyAAIAVBBGoQAiIBDQAgByAFKAIEIgY2AghBASEBIAYgAygCAEcNACACKAIMIQhBACEBA0AgASIGQQFqIQEgCCAGdg0AC0EBIQEgACAGQX9qEAMiBkF/Rg0AIAZBACAEKAIAIghBBUYbDQAgByAGNgIMIAhBBUYEQCAAIAVBBGoQAiIBDQEgByAFKAIEIgY2AhBBASEBIAZB//8DSw0B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IgMgAiANai0AACACIARqLQAAIgkgAiASai0AACIFaiIIayAIQQJ0a2ogAi0AACIKIAIgD2otAAAiCGpBFGxqQRBqQQV1QbAuai0AADoAMCABIAQgB2otAAAiECAJIAUgCGpBFGxqIAMgCmoiCWsgCUECdGtqQRBqQQV1QbAuai0AADoAICABIActAAAiCSAKIAMgBWpBFGxqIAggEGoiCmsgCkECdGtqQRBqQQV1QbAuai0AADoAECABIAcgD2otAAAgCCADIBBqQRRsaiAFIAlqIgNrIANBAnRrakEQakEFdUGwLmotAAA6AAAgB0EBaiEHIAFBAWohASACQQFqIQIgAEF/aiIADQALIAEgEWohASACIA5qIQIgByAOaiEHIAxBf2oiDA0ACwsgC0HAA2okAAuqBgENfyMAQbABayIRJAAgCEEBaiEKAkACQCACQQBIDQAgA0EASA0AIAIgCmogBEsNACADIAlqQQFqIAVLDQAgBSEMIAQhCiADIQ8MAQsgACARIAIgAyAEIAUgCiAJQQFqIgwgChAMIAAgBCAFbGogESAKIAxsaiACIAMgBCAFIAogDCAKEAwgESEAQQAhAgsCQCAJQQF2IgVFDQAgCEEBdiIERQ0AQRAgCGshE0EIIAdrIQtBCCAGayENIApBAXQiDiAIayEUIAAgAmoiFiAKIA9saiECIAEhACAFIRUDQCACIA5qLQAAIAdsIAsgAiAKai0AACIDbGohCCADIAdsIAsgAi0AAGxqIQkgBCEDA0AgAkEBaiIQIA5qLQAAIRIgACAJIA1sIAogEGotAAAiCSAHbCALIAItAAFsaiIQIAZsakEgakEGdjoAACAAIAggDWwgByASbCAJIAtsaiIIIAZsakEgakEGdjoACCACLQACIQkgAkECaiICIA5qLQAAIRIgACANIBBsIAIgCmotAAAiECAHbCAJIAtsaiIJIAZsakEgakEGdjoAASAAIAggDWwgByASbCALIBBsaiIIIAZsakEgakEGdjoACSAAQQJqIQAgA0F/aiIDDQALIAIgFGohAiAAIBNqIQAgFUF/aiIVDQALIAFBQGshACAWIAwgD2ogCmxqIQIDQCACIA5qLQAAIAdsIAsgAiAKai0AACIBbGohCCABIAdsIAsgAi0AAGxqIQkgBCEDA0AgAkEBaiIBIA5qLQAAIQwgACAJ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AmogAnNBA0shCgsgAyAKNgJoIAEuAaYBIR5BAiEbQQIhEwJAIC8gAS8BLCI0cg0AQQEhEyABLgGkASABLgGMAWsiAiACQR91IgJqIAJzQQNLDQAgHiAEayICIAJBH3UiAmogAnNBA0sNACABKAJ8IAEoAnRHIRMLIAMgEzYCcCABLgGqASEOAkAgECABLwEuIhhyDQBBASEbIAEuAagBIAEuAZABayICIAJBH3UiAmogAnNBA0sNACAOIAZrIgIgAkEfdSICaiACc0EDSw0AIAEoAnwgASgCdEchGwsgAyAbNgJ4IAEuAbYBIRlBAiESQQIhFQJAIBcgAS8BNCIgcg0AQQEhFSABLgG0ASABLgGcAWsiAiACQR91IgJqIAJzQQNLDQAgGSAHayICIAJBH3UiAmogAnNBA0sNACABKAKAASABKAJ4RyEVCyADIBU2AoABIAEuAboBISECQCAzIAEvATYiNXINAEEBIRIgAS4BuAEgAS4BoAFrIgIgAkEfdSICaiACc0EDSw0AICEgC2siAiACQR91IgJqIAJzQQNLDQAgASgCgAEgASgCeEchEgsgAyASNgKIASABLgGuASE2QQIhDSADAn9BAiA0IAEvATAiQXINABpBASABLgGsASABLgGkAWsiAiACQR91IgJqIAJzQQNLDQAaIDYgHmsiAiACQR91IgJqIAJzQQNLCyIdNgKQASABLgGyASEkAkAgGCABLwEyIjdyDQBBASENIAEuAbABIAEuAagBayICIAJBH3UiAmogAnNBA0sNACAkIA5rIgIgAkEfdSICaiACc0EDSyENCyADIA02ApgBIAEuAb4BISlBAiEcIAMCf0ECICAgAS8BOCI4cg0AGkEBIAEuAbwBIAEuAbQBayICIAJBH3UiAmogAnNBA0sNABogKSAZayICIAJBH3UiAmogAnNBA0sLIiY2AqABIAEuAcIBITkCQCA1IAEvAToiQnINAEEBIRwgAS4BwAEgAS4BuAFrIgIgAkEfdSICaiACc0EDSw0AIDkgIWsiAiACQR91IgJqIAJzQQNLIRwLIAMgHDYCqAFBAiECIAMCf0ECIBEgMHINABpBASABLgGIASABLgGEAWsiESARQR91IhFqIBFzQQNLDQAaIAggFGsiFCAUQR91IhRqIBRzQQNLCyIRNgI8AkAgMCAxcg0AQQEhAiAB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BSADLQAGampqQQJqQQJ2DAELIAcEQCADLQAEIAMtAAMgAy0AASADLQACampqQQJqQQJ2IQYgAy0ACCADLQAHIAMtAAUgAy0ABmpqakECakECdgwBCyAKRQRAQYABIQZBgAEMAQsgBC0AAyAELQACIAQtAAAgBC0AAWpqakECakECdiIGC0H/AXFBgYKECGwiADYAHCABIAZB/wFxQYGChAhsIgY2ABggASAANgAUIAEgBjYAECABIAA2AAwgASAGNgAIIAEgADYABCABIAY2AAACfyAKBEAgBC0AByAELQAGIAQtAAUgBC0ABGpqaiIGQQJqQQJ2IgAgB0UNARogAy0ACCADLQAHIAMtAAYgBiADLQAFampqakEEakEDdgwBCyAHRQRAQYABIQBBgAEMAQsgAy0ABCADLQADIAMtAAEgAy0AAmpqakECakECdiEAIAMtAAggAy0AByADLQAFIAMtAAZqampBAmpBAnYLIQYgASAAQf8BcUGBgoQIbCIANgAgIAEgBkH/AXFBgYKECGwiBjYAPCABIAA2ADggASAGNgA0IAEgADYAMCABIAY2ACwgASAANgAoIAEgBjYAJAwDCyAKRQRAQQEPCyABIAQtAAA6AAAgASAELQAAOgABIAEgBC0AADoAAiABIAQtAAA6AAMgASAELQAAOgAEIAEgBC0AADoABSABIAQtAAA6AAYgASAELQAAOgAHIAEgBC0AAToACCABIAQtAAE6AAkgASAELQABOgAKIAEgBC0AAToACyABIAQtAAE6AAwgASAELQABOgANIAEgBC0AAToADiABIAQtAAE6AA8gASAELQACOgAQIAEgBC0AAjoAESABIAQtAAI6ABIgASAELQACOgATIAEgBC0AAjoAFCABIAQtAAI6ABUgASAELQACOgAWIAEgBC0AAjoAFyABIAQtAAM6ABggASAELQADOgAZIAEgBC0AAzoAGiABIAQtAAM6ABsgASAELQADOgAcIAEgBC0AAzoAHSABIAQtAAM6AB4gASAELQADOgAfIAEgBC0ABDoAICABIAQtAAQ6ACEgASAELQAEOgAiIAEgBC0ABDoAIyABIAQtAAQ6ACQgASAELQAEOgAlIAEgBC0ABDoAJiABIAQtAAQ6ACcgASAELQAFOgAoIAEgBC0ABToAKSABIAQtAAU6ACogASAELQAFOgArIAEgBC0ABToALCABIAQtAAU6AC0gASAELQAFOgAuIAEgBC0ABToALyABIAQtAAY6ADAgASAELQAGOgAxIAEgBC0ABjoAMiABIAQtAAY6ADMgASAELQAGOgA0IAEgBC0ABjoANSABIAQtAAY6ADYgASAELQAGOgA3IAEgBC0ABzoAOCABIAQtAAc6ADkgASAELQAHOgA6IAEgBC0ABzoAOyABIAQtAAc6ADwgASAELQAHOgA9IAEgBC0ABzoAPiABIAQtAAc6AD8MAgsgB0UEQEEBDwsgASADLQABOgAAIAEgAy0AAToACCABIAMtAAE6ABAgASADLQABOgAYIAEgAy0AAToAICABIAMtAAE6ACggASADLQABOgAwIAEgAy0AAToAOCABIAMtAAI6AAEgASADLQACOgAJIAEgAy0AAjoAESABIAMtAAI6ABkgASADLQACOgAhIAEgAy0AAjoAKSABIAMtAAI6ADEgASADLQACOgA5IAEgAy0AAzoAAiABIAMtAAM6AAogASADLQADOgASIAEgAy0AAzoAGiABIAMtAAM6ACIgASADLQADOgAqIAEgAy0AAzoAMiABIAMtAAM6ADogASADLQAEOgADIAEgAy0ABDoACyABIAMtAAQ6ABMgASADLQAEOgAbIAEgAy0ABDoAIyABIAMtAAQ6ACsgASADLQAEOgAzIAEgAy0ABDoAOyABIAMtAAU6AAQgASADLQAFOgAMIAEgAy0ABToAFCABIAMtAAU6ABwgASADLQAFOgAkIAEgAy0ABToALCABIAMtAAU6ADQgASADLQAFOgA8IAEgAy0ABjoABSABIAMtAAY6AA0gASADLQAGOgAVIAEgAy0ABjoAHSABIAMtAAY6ACUgASADLQAGOgAtIAEgAy0ABjoANSABIAMtAAY6AD0gASADLQAHOgAGIAEgAy0ABzoADiABIAMtAAc6ABYgASADLQAHOgAeIAEgAy0ABzoAJiABIAMtAAc6AC4gASADLQAHOgA2IAEgAy0ABzoAPiABIAMtAAg6AAcgASADLQAIOgAPIAEgAy0ACDoAFyABIAMtAAg6AB8gASADLQAIOgAnIAEgAy0ACDoALyABIAMtAAg6ADcgASADLQAIOgA/DAELIA5FBEBBAQ8LIAMtAAUgAy0AA2sgAy0ABiADLQACa0EBdGogAy0AByADLQAB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ABA6AA8gAEEQaiEAIAVBAWoiBUEQRw0ACwwDCyAHRQRAQQEPC0EAIQUgASEAA0AgACAEIAVqIgMtAAA6AAAgACADLQAAOgABIAAgAy0AADoAAiAAIAMtAAA6AAMgACADLQAAOgAEIAAgAy0AADoABSAAIAMtAAA6AAYgACADLQAAOgAHIAAgAy0AADoACCAAIAMtAAA6AAkgACADLQAAOgAKIAAgAy0AADoACyAAIAMtAAA6AAwgACADLQAAOgANIAAgAy0AADoADiAAIAMtAAA6AA8gAEEQaiEAIAVBAWoiBUEQRw0ACwwCCyABAn8CQCAHRQ0AIAhFDQAgBC0ADyADLQAQIAQtAA4gAy0ADyAELQANIAMtAA4gBC0ADCADLQANIAQtAAsgAy0ADCAELQAKIAMtAAsgBC0ACSADLQAKIAQtAAggAy0ACSAELQAHIAMtAAggBC0ABiADLQAHIAQtAAUgAy0ABiAELQAEIAMtAAUgBC0AAyADLQAEIAQtAAIgAy0AAyAELQABIAMtAAIgAy0AASAELQAAampqampqampqampqampqampqampqampqampqampqakEQakEFdgwBCyAHBEAgBC0ADyAELQAOIAQtAA0gBC0ADCAELQALIAQtAAogBC0ACSAELQAIIAQtAAcgBC0ABiAELQAFIAQtAAQgBC0AAyAELQACIAQtAAAgBC0AAWpqampqampqampqampqakEIakEEdgwBC0GAASAIRQ0AGiADLQAQIAMtAA8gAy0ADiADLQANIAMtAAwgAy0ACyADLQAKIAMtAAkgAy0ACCADLQAHIAMtAAYgAy0ABSADLQAEIAMtAAMgAy0AASADLQACampqampqampqampqampqQQhqQQR2C0GAAhAHGgwBC0EBIQAgB0UNASAIRQ0BIAlFDQEgBC0ACCAELQAGayAELQAPIgAgAy0AACIFa0EDdGogBC0ACSAELQAFa0EBdGogBC0ACiAELQAEa0EDbGogBC0ACyAELQADa0ECdGogBC0ADCAELQACa0EFbGogBC0ADSAELQABa0EGbGogBC0ADiAELQAAa0EHbGpBBWxBIGpBBnUhByADLQAJIAMtAAdrIAMtAAogAy0ABmtBAXRqIAMtAAsgAy0ABWtBA2xqIAMtAAwgAy0ABGtBAnRqIAMtAA0gAy0AA2tBBWxqIAMtAA4gAy0AAmtBBmxqIAMtAA8gAy0AAWtBB2xqIAMtABAiAyAFa0EDdGpBBWxBIGpBBnUiBEEDdCEIIARBB2whCSAEQQZsIQogBEEFbCELIARBA2whDCAEQX1sIQ0gBEF7bCEOIARBemwhDyAEQXlsIRBBACAEQQF0IhFrIRJBACAEQQJ0IhNrIRQgACADakEEdEEQaiEVQQAhBQNAIAEgBUEEdCIAaiAVIAVBeWogB2xqIgMgEGpBBXUiBkH/ASAGQf8BSBsiBkEAIAZBAEobOgAAIAEgAEEBcmogAyAPakEFdSIGQf8BIAZB/wFIGyIGQQAgBkEAShs6AAAgASAAQQJyaiADIA5qQQV1IgZB/wEgBkH/AUgbIgZBACAGQQBKGzoAACABIABBA3JqIAMgFGpBBXUiBkH/ASAGQf8BSBsiBkEAIAZBAEobOgAAIAEgAEEEcmogAyANakEFdSIGQf8BIAZB/wFIGyIGQQAgBkEAShs6AAAgASAAQQVyaiADIBJqQQV1IgZB/wEgBkH/AUgbIgZBACAGQQBKGzoAACABIABBBnJqIAMgBGtBBXUiBkH/ASAGQf8BSBsiBkEAIAZBAEobOgAAIAEgAEEHcmogA0EFdSIGQf8BIAZB/wFIGyIGQQAgBkEAShs6AAAgASAAQQhyaiADIARqQQV1IgZB/wEgBkH/AUgbIgZBACAGQQBKGzoAACABIABBCXJqIAMgEWpBBXUiBkH/ASAGQf8BSBsiBkEAIAZBAEobOgAAIAEgAEEKcmogAyAMakEFdSIGQf8BIAZB/wFIGyIGQQAgBkEAShs6AAAgASAAQQtyaiADIBNqQQV1IgZB/wEgBkH/AUgbIgZBACAGQQBKGzoAACABIABBDHJqIAMgC2pBBXUiBkH/ASAGQf8BSBsiBkEAIAZBAEobOgAAIAEgAEENcmogAyAKakEFdSIGQf8BIAZB/wFIGyIGQQAgBkEAShs6AAAgASAAQQ5yaiADIAlqQQV1IgZB/wEgBkH/AUgbIgZBACAGQQBKGzoAACABIABBD3JqIAMgCGpBBXUiAEH/ASAAQf8BSBsiAEEAIABBAEobOgAAIAVBAWoiBUEQRw0ACwtBACEAIAEgAkEAEAggASACQUBrQQEQCCABIAJBgAFqQQIQCCABIAJBwAFqQQMQCCABIAJBgAJqQQQQCCABIAJBwAJqQQUQCCABIAJBgANqQQYQCCABIAJBwANqQQcQCCABIAJBgARqQQgQCCABIAJBwARqQQkQCCABIAJBgAVqQQoQCCABIAJBwAVqQQsQCCABIAJBgAZqQQwQCCABIAJBwAZqQQ0QCCABIAJBgAdqQQ4QCCABIAJBwAdqQQ8QCAsgAAvBCAEHfwJAIANFDQAgACgCACADIAAoAgQiBW4iCCAFbCIEQQh0aiADIARrIgdBBHRqIQYgBUEEdCEEIAAoAgghCSAFIANLIgpFBEAgASAGIARBf3NqIgMtAAA6AAAgASAGIARrLQAAOgABIAEgAy0AAjoAAiABIAMtAAM6AAMgASADLQAEOgAEIAEgAy0ABToABSABIAMtAAY6AAYgASADLQAHOgAHIAEgAy0ACDoACCABIAMtAAk6AAkgASADLQAKOgAKIAEgAy0ACzoACyABIAMtAAw6AAwgASADLQANOgANIAEgAy0ADjoADiABIAMtAA86AA8gASADLQAQOgAQIAEgAy0AEToAESABIAMtABI6ABIgASADLQATOgATIAEgAy0AFDoAFCABQRVqIQELIAcEQCACIAZBf2oiAy0AADoAACACIAMgBGoiAy0AADoAASACIAMgBGoiAy0AADoAAiACIAMgBGoiAy0AADoAAyACIAMgBGoiAy0AADoABCACIAMgBGoiAy0AADoABSACIAMgBGoiAy0AADoABiACIAMgBGoiAy0AADoAByACIAMgBGoiAy0AADoACCACIAMgBGoiAy0AADoACSACIAMgBGoiAy0AADoACiACIAMgBGoiAy0AADoACyACIAMgBGoiAy0AADoADCACIAMgBGoiAy0AADoADSACIAMgBGoiAy0AADoADiACIAMgBGotAAA6AA8gAkEQaiECCyAAKAIAIAUgCWwiBkEIdGogCCAFQQN0IgBsQQN0aiAHQQN0aiEEIABB+P///wdxIQAgCkUEQCABIAQgAEF/c2oiAy0AADoAACABIAQgAGstAAA6AAEgASADLQACOgACIAEgAy0AAzoAAyABIAMtAAQ6AAQgASADLQAFOgAFIAEgAy0ABjoABiABIAMtAAc6AAcgASADQQhqIgMtAAA6AAggASAGQQZ0IANqIgNBeGotAAA6AAkgASADQXlqLQAAOgAKIAEgA0F6ai0AADoACyABIANBe2otAAA6AAwgASADQXxqLQAAOgANIAEgA0F9ai0AADoADiABIANBfmotAAA6AA8gASADQX9qLQAAOgAQIAEgAy0AADoAEQsgB0UNACACIARBf2oiAS0AADoAACACIAAgAWoiAS0AADoAASACIAAgAWoiAS0AADoAAiACIAAgAWoiAS0AADoAAyACIAAgAWoiAS0AADoABCACIAAgAWoiAS0AADoABSACIAAgAWoiAS0AADoABiACIAAgAWoiAS0AADoAByACIAAgAWogBiAFa0EGdGoiAS0AADoACCACIAAgAWoiAS0AADoACSACIAAgAWoiAS0AADoACiACIAAgAWoiAS0AADoACyACIAAgAWoiAS0AADoADCACIAAgAWoiAS0AADoADSACIAAgAWoiAS0AADoADiACIAAgAWotAAA6AA8LC68BAQF/IwBB0ABrIgYkACACIAZBIGogBiADEFUCQAJAQQIgACgCACIDQQZHIANBBkkbQQFGBEAgACAFIAFByAJqIAZBIGogBiAEEFQiA0UNAQwCCyAAIAUgASAGQSBqIAYgBBBTIgMNAQsgACAFQYACaiABQcgKaiAGQTVqIAZBEGogASgCjAEgBBBSIgMNAEEAIQMgACgCxAFBAUsNACACIAUQGwsgBkHQAGokACADC6MqASR/IwBBIGsiECQAIBAgBCgCBCIINgIMIBAgBCgCCDYCECADIAhuIgZBBHQhFCADIAYgCGxrQQR0IRUCQAJAAkACQAJAAkACQAJAIAAoAgAiBkEDTQRAAkACQAJAIAZBAmsOAgECAAsgASgCkAEhEyAAKAIEIQ5BfyEPAn8gACgCyAEiCUUEQEEAIQhBfwwBC0EAIQhBfyAJKAIEIA5HDQAaQQEhEkF/IAkoAgBBBUsNABogCSgCmAEiCEEQdiEHIAkoAmgLIQ0gACgCzAEiCUUNCCAJKAIEIA5HDQhBASEWIAkoAgBBBUsNCCAJKAKsASIRQRB2IQogCSgCbCEPDAgLIAEoApABIRMgAS8BogEhDSABLwGgASEMIAAoAgQhC0F/IQcCQCAAKALMASIGRQ0AIAsgBigCBEcEQAwBC0EBIRIgBigCAEEFSw0AIAYoAqwBIglBEHYhCiAGKAJsIQcLIAcgE0YEQCAKIQcgCSEGDAcLQX8hDwJAAkACQCAAKALIASIIRQRAQQAh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AAAJAAAABAAAAAwAAAD/AAAAAAAAAP8AAAAAAAAABAAAAAkAAAAEAAAADAAAAAQAAAALAAAABAAAAA4AAAABAAAACgAAAP8AAAAAAAAA/wAAAAAAAAD/AAAAAAAAAAEAAAAKAAAABAAAAAAAAAD/AAAAAAAAAP8AAAAAAAAAAQAAAAoAAAABAAAACwAAAP8AAAAAAAAA/wAAAAAAAAABAAAACgAAAAEAAAALAAAABAAAAAAAAAAEAAAAAQAAAAEAAAAOAAAA/wAAAAAAAAD/AAAAAAAAAP8AAAAAAAAAAQAAAA4AAAAEAAAABAAAAP8AAAAAAAAA/wAAAAAAAAABAAAADgAAAAEAAAAPAAAA/wAAAAAAAAD/AAAAAAAAAAEAAAAOAAAAAQAAAA8AAAAEAAAABAAAAAQAAAAFAAAABAAAAAIAAAD/AAAAAAAAAP8AAAAAAAAA/wAAAAAAAAAEAAAAAgAAAAQAAAAIAAAA/wAAAAAAAAD/AAAAAAAAAAQAAAACAAAABAAAAAMAAAD/AAAAAAAAAP8AAAAAAAAABAAAAAIAAAAEAAAAAwAAAAQAAAAIAAAABAAAAAkAAAAEAAAABgAAAP8AAAAAAAAA/wAAAAAAAAD/AAAAAAAAAAQAAAAGAAAABAAAAAwAAAD/AAAAAAAAAP8AAAAAAAAABAAAAAYAAAAEAAAABwAAAP8AAAAAAAAA/wAAAAAAAAAEAAAABgAAAAQAAAAHAAAABAAAAAwAAAAEAAAADQAAAAEAAAAOAAAA/wAAAAAAAAD/AAAAAAAAAP8AAAAAAAAAAQAAAA4AAAD/AAAABAAAAP8AAAAAAAAA/wAAAAAAAAABAAAACwAAAAEAAAAOAAAA/wAAAAAAAAD/AAAAAAAAAAEAAAALAAAAAQAAAA4AAAAEAAAAAQAAAP8AAAAEAAAAAgAAAAoAAAD/AAAAAAAAAP8AAAAAAAAA/wAAAAAAAAACAAAACgAAAP8AAAAAAAAA/wAAAAAAAAD/AAAAAAAAAAEAAAAPAAAAAgAAAAoAAAD/AAAAAAAAAP8AAAAAAAAAAQAAAA8AAAACAAAACgAAAAQAAAAFAAAA/wAAAAAAAAAEAAAABgAAAP8AAAAAAAAA/wAAAAAAAAD/AAAAAAAAAAQAAAAGAAAA/wAAAAwAAAD/AAAAAAAAAP8AAAAAAAAABAAAAAMAAAAEAAAABgAAAP8AAAAAAAAA/wAAAAAAAAAEAAAAAwAAAAQAAAAGAAAABAAAAAkAAAD/AAAADAAAAP8AAAACAAAA/wAAAAAAAAD/AAAAAAAAAP8AAAAAAAAA/wAAAAIAAAD/AAAACAAAAP8AAAAAAAAA/wAAAAAAAAAEAAAABwAAAP8AAAACAAAA/wAAAAAAAAD/AAAAAAAAAAQAAAAHAAAA/wAAAAIAAAAEAAAADQAAAP8AAAAIAAAAAwAAAA8AAAD/AAAAAAAAAP8AAAAAAAAA/wAAAAAAAAADAAAADwAAAAAAAAAFAAAA/wAAAAAAAAD/AAAAAAAAAAMAAAAPAAAAAQAAAAoAAAD/AAAAAAAAAP8AAAAAAAAAAwAAAA8AAAABAAAACgAAAAAAAAAFAAAABAAAAAAAAAABAAAACwAAAP8AAAAAAAAA/wAAAAAAAAD/AAAAAAAAAAEAAAALAAAABAAAAAEAAAD/AAAAAAAAAP8AAAAAAAAAAQAAAAsAAAABAAAADgAAAP8AAAAAAAAA/wAAAAAAAAABAAAACwAAAAEAAAAOAAAABAAAAAEAAAAEAAAABAAAAAAAAAAHAAAA/wAAAAAAAAD/AAAAAAAAAP8AQdQnCxUHAAAAAAAAAA0AAAD/AAAAAAAAAP8AQfQnCxUHAAAABAAAAAIAAAD/AAAAAAAAAP8AQZQoC9kBBwAAAAQAAAACAAAAAAAAAA0AAAAEAAAACAAAAAQAAAADAAAA/wAAAAAAAAD/AAAAAAAAAP8AAAAAAAAABAAAAAMAAAAEAAAACQAAAP8AAAAAAAAA/wAAAAAAAAAEAAAAAwAAAAQAAAAGAAAA/wAAAAAAAAD/AAAAAAAAAAQAAAADAAAABAAAAAYAAAAEAAAACQAAAAQAAAAMAAAAAAAAAAQAAAAAAAAABAAAAAgAAAAMAAAACAAAAAwAAAAAAAAABAAAAAAAAAAEAAAACAAAAAwAAAAIAAAADABB+CkLBQQAAAAEAEGIKgslBAAAAAQAAAAIAAAACAAAAAwAAAAMAAAACAAAAAgAAAAMAAAADABBsS4LyAYBAgMEBQYHCAkKCwwNDg8QERITFBUWFxgZGhscHR4fICEiIyQlJicoKSorLC0uLzAxMjM0NTY3ODk6Ozw9Pj9AQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVpbXF1eX2BhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ent8fX5/gIGCg4SFhoeIiYqLjI2Oj5CRkpOUlZaXmJmam5ydnp+goaKjpKWmp6ipqqusra6vsLGys7S1tre4ubq7vL2+v8DBwsPExcbHyMnKy8zNzs/Q0dLT1NXW19jZ2tvc3d7f4OHi4+Tl5ufo6err7O3u7/Dx8vP09fb3+Pn6+/z9/v///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////wAAAAABAAAABAAAAAUAAAACAAAAAwAAAAYAAAAHAAAACAAAAAkAAAAMAAAADQAAAAoAAAALAAAADgAAAA8AAAAAAAAAAQAAAAEAQYQ1CyEBAAAAAQAAAAEAAAABAAAAAgAAAAIAAAABAAAAAgAAAAIAQbQ1CwUFAAAABABBxDULyQYHAAAABAAAAAIAAAAEAAAAAQAAAAQAAAAEAAAABAAAAAMAAAAEAAAABgAAAAAAAAANAAAABAAAAAgAAAAAAAAADwAAAAQAAAAKAAAABAAAAAkAAAAEAAAADAAAAAQAAAALAAAABAAAAA4AAAAAAAAAEQAAAAQAAAAQAAAAAAAAABMAAAAEAAAAEgAAAAAAAAAVAAAABAAAABQAAAAAAAAAFwAAAAQAAAAWAAAAAQAAAAoAAAABAAAACwAAAAQAAAAAAAAABAAAAAEAAAABAAAADgAAAAEAAAAPAAAABAAAAAQAAAAEAAAABQAAAAQAAAACAAAABAAAAAMAAAAEAAAACAAAAAQAAAAJAAAABAAAAAYAAAAEAAAABwAAAAQAAAAMAAAABAAAAA0AAAABAAAAEgAAAAEAAAATAAAABAAAABAAAAAEAAAAEQAAAAEAAAAWAAAAAQAAABcAAAAEAAAAFAAAAAQAAAAVAAAAAQAAAAsAAAABAAAADgAAAAQAAAABAAAA/wAAAAQAAAABAAAADwAAAAIAAAAKAAAABAAAAAUAAAD/AAAAAAAAAAQAAAADAAAABAAAAAYAAAAEAAAACQAAAP8AAAAMAAAABAAAAAcAAAD/AAAAAgAAAAQAAAANAAAA/wAAAAgAAAABAAAAEwAAAAIAAAASAAAABAAAABEAAAD/AAAAEAAAAAEAAAAXAAAAAgAAABYAAAAEAAAAFQAAAP8AAAAUAAAAAwAAAA8AAAABAAAACgAAAAAAAAAFAAAABAAAAAAAAAABAAAACwAAAAEAAAAOAAAABAAAAAEAAAAEAAAABAAAAAAAAAAHAAAABAAAAAIAAAAAAAAADQAAAAQAAAAIAAAABAAAAAMAAAAEAAAABgAAAAQAAAAJAAAABAAAAAwAAAADAAAAEwAAAAEAAAASAAAAAAAAABEAAAAEAAAAEAAAAAMAAAAXAAAAAQAAABYAAAAAAAAAFQAAAAQAAAAUAAAAAQAAAAEAAAACAAAAAgAAAAMAAAADAAAAAwAAAAMAAAAAAAAAAQAAAAIAAAADAAAABAAAAAUAAAAGAAAABwAAAAgAAAAJAAAACgAAAAsAAAAMAAAADQAAAA4AAAAPAEGWPAsuAQEBAQEBAgICAgICAwMDAwMDBAQEBAQEBQUFBQUFBgYGBgYGBwcHBwcHCAgICABB0DwLRQoAAAANAAAAEAAAAAsAAAAOAAAAEgAAAA0AAAAQAAAAFAAAAA4AAAASAAAAFwAAABAAAAAUAAAAGQAAABIAAAAXAAAAHQBBoT0LMwECAwQFAAECAwQFAAECAwQFAAECAwQFAAECAwQFAAECAwQFAAECAwQFAAECAwQFAAECAwBB5D0LzAIBAAAAAgAAAAMAAAAEAAAABQAAAAYAAAAHAAAACAAAAAkAAAAKAAAACwAAAAwAAAANAAAADgAAAA8AAAAQAAAAEQAAABIAAAATAAAAFAAAABUAAAAWAAAAFwAAABgAAAAZAAAAGgAAABsAAAAcAAAAHQAAAB0AAAAeAAAAHwAAACAAAAAgAAAAIQAAACIAAAAiAAAAIwAAACMAAAAkAAAAJAAAACUAAAAlAAAAJQAAACYAAAAmAAAAJgAAACcAAAAnAAAAJwAAACcAAAABAAAAAgAAAAQAAAAIAAAAEAAAACAAAABAAAAAgAAAAC8fDwAXGx0eBwsNDicrLS4QAwUKDBMVGhwjJSosAQIECBESFBgGCRYZICEiJCgmKQAQAQIECCADBQoMDy8HCw0OBgkfIyUqLCEiJCgnKy0uERIUGBMVGhwXGx0eFhkmKQ=="},D={};function o(){var A,I=E()({locateFile:function(A){return i[A]}});return(A=I,new Promise((function(I){A.calledRun?I():A.onRuntimeInitialized=function(){return I()}}))).then((function(){self.addEventListener("message",(function(A){var g=A.data,B=g.renderStateId;switch(g.type){case"decode":var C=D[B];C||(C=new Q(I,(function(A,I,g){postMessage({type:"pictureReady",width:I,height:g,renderStateId:B,data:A.buffer},[A.buffer])})),D[B]=C),C.decode(new Uint8Array(g.data,g.offset,g.length));break;case"release":var E=D[B];E&&(E.release(),delete D[B])}})),self.postMessage({type:"decoderReady"})}))}}},I={};function g(B){var Q=I[B];if(void 0!==Q)return Q.exports;var C=I[B]={exports:{}};return A[B](C,C.exports,g),C.exports}g.n=A=>{var I=A&&A.__esModule?()=>A.default:()=>A;return g.d(I,{a:I}),I},g.d=(A,I)=>{for(var B in I)g.o(I,B)&&!g.o(A,B)&&Object.defineProperty(A,B,{enumerable:!0,get:I[B]})},g.o=(A,I)=>Object.prototype.hasOwnProperty.call(A,I),g.r=A=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(A,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(A,"__esModule",{value:!0})},(()=>{"use strict";g(340).init()})()})();',"Worker",void 0,void 0)}},614:A=>{A.exports=function(A,I,g,e){var B=self||window;try{try{var i;try{i=new B.Blob([A])}catch(I){(i=new(B.BlobBuilder||B.WebKitBlobBuilder||B.MozBlobBuilder||B.MSBlobBuilder)).append(A),i=i.getBlob()}var Q=B.URL||B.webkitURL,t=Q.createObjectURL(i),C=new B[I](t,g);return Q.revokeObjectURL(t),C}catch(e){return new B[I]("data:application/javascript,".concat(encodeURIComponent(A)),g)}}catch(A){if(!e)throw Error("Inline worker is not supported");return new B[I](e,g)}}}},I={};function g(e){var B=I[e];if(void 0!==B)return B.exports;var i=I[e]={exports:{}};return A[e].call(i.exports,i,i.exports,g),i.exports}return g.n=A=>{var I=A&&A.__esModule?()=>A.default:()=>A;return g.d(I,{a:I}),I},g.d=(A,I)=>{for(var e in I)g.o(I,e)&&!g.o(A,e)&&Object.defineProperty(A,e,{enumerable:!0,get:I[e]})},g.o=(A,I)=>Object.prototype.hasOwnProperty.call(A,I),g.r=A=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(A,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(A,"__esModule",{value:!0})},g(114)})()},53:A=>{self,A.exports=(()=>{"use strict";var A={114:function(A,I,g){var e=this&&this.__importDefault||function(A){return A&&A.__esModule?A:{default:A}};Object.defineProperty(I,"__esModule",{value:!0});const B=e(g(289));I.default=class{initialize(){return new Promise(((A,I)=>{this.worker=new B.default,this.worker.addEventListener("message",(I=>{var g;const e=I.data;"decoderReady"===e.type?A(0):"decodeDone"===e.type&&(null===(g=this.onDecode)||void 0===g||g.call(this,e))}))}))}startStream(A,I,g){this.worker&&this.worker.postMessage({type:"startStream",sampleRateHz:A,channelCount:I,decodedSamplesPerFrame:g})}stopStream(){this.worker&&this.worker.postMessage({type:"stopStream"})}decode(A,I){this.worker&&this.worker.postMessage({type:"decode",startTimestamp:A,inputData:I},[I])}release(){this.worker&&this.worker.postMessage({type:"release"})}dispose(){this.worker&&(this.worker.terminate(),this.worker=void 0)}}},289:(A,I,g)=>{g.r(I),g.d(I,{default:()=>i});var e=g(614),B=g.n(e);function i(){return B()('(()=>{var A={305:A=>{var I,g=(I="undefined"!=typeof document&&document.currentScript?document.currentScript.src:void 0,function(A){var g,B;(A=void 0!==(A=A||{})?A:{}).ready=new Promise((function(A,I){g=A,B=I}));var Q,C={};for(Q in A)A.hasOwnProperty(Q)&&(C[Q]=A[Q]);var E=[],i="./this.program",D=function(A,I){throw I},o="";"undefined"!=typeof document&&document.currentScript&&(o=document.currentScript.src),I&&(o=I),o=0!==o.indexOf("blob:")?o.substr(0,o.lastIndexOf("/")+1):"";var w,F,G=A.print||console.log.bind(console),R=A.printErr||console.warn.bind(console);for(Q in C)C.hasOwnProperty(Q)&&(A[Q]=C[Q]);C=null,A.arguments&&(E=A.arguments),A.thisProgram&&(i=A.thisProgram),A.quit&&(D=A.quit),A.wasmBinary&&(w=A.wasmBinary),A.noExitRuntime&&(F=A.noExitRuntime),"object"!=typeof WebAssembly&&n("no native wasm support detected");var S=!1;function U(I){var g,B=A["_"+I];return g="Cannot call unknown function "+I+", make sure it is exported",B||n("Assertion failed: "+g),B}function a(A,I,g,B,Q){var C={string:function(A){var I=0;if(null!=A&&0!==A){var g=1+(A.length<<2);!function(A,I,g){J(A,k,I,g)}(A,I=V(g),g)}return I},array:function(A){var I,g,B=V(A.length);return I=A,g=B,s.set(I,g),B}},E=U(A),i=[],D=0;if(B)for(var o=0;o<B.length;o++){var w=C[g[o]];w?(0===D&&(D=X()),i[o]=w(B[o])):i[o]=B[o]}var F=E.apply(null,i);return F=function(A){return"string"===I?H(A):"boolean"===I?Boolean(A):A}(F),0!==D&&Z(D),F}var s,k,h,N="undefined"!=typeof TextDecoder?new TextDecoder("utf8"):void 0;function y(A,I,g){for(var B=I+g,Q=I;A[Q]&&!(Q>=B);)++Q;if(Q-I>16&&A.subarray&&N)return N.decode(A.subarray(I,Q));for(var C="";I<Q;){var E=A[I++];if(128&E){var i=63&A[I++];if(192!=(224&E)){var D=63&A[I++];if((E=224==(240&E)?(15&E)<<12|i<<6|D:(7&E)<<18|i<<12|D<<6|63&A[I++])<65536)C+=String.fromCharCode(E);else{var o=E-65536;C+=String.fromCharCode(55296|o>>10,56320|1023&o)}}else C+=String.fromCharCode((31&E)<<6|i)}else C+=String.fromCharCode(E)}return C}function H(A,I){return A?y(k,A,I):""}function J(A,I,g,B){if(!(B>0))return 0;for(var Q=g,C=g+B-1,E=0;E<A.length;++E){var i=A.charCodeAt(E);if(i>=55296&&i<=57343&&(i=65536+((1023&i)<<10)|1023&A.charCodeAt(++E)),i<=127){if(g>=C)break;I[g++]=i}else if(i<=2047){if(g+1>=C)break;I[g++]=192|i>>6,I[g++]=128|63&i}else if(i<=65535){if(g+2>=C)break;I[g++]=224|i>>12,I[g++]=128|i>>6&63,I[g++]=128|63&i}else{if(g+3>=C)break;I[g++]=240|i>>18,I[g++]=128|i>>12&63,I[g++]=128|i>>6&63,I[g++]=128|63&i}}return I[g]=0,g-Q}function L(A){var I=function(A){for(var I=0,g=0;g<A.length;++g){var B=A.charCodeAt(g);B>=55296&&B<=57343&&(B=65536+((1023&B)<<10)|1023&A.charCodeAt(++g)),B<=127?++I:I+=B<=2047?2:B<=65535?3:4}return I}(A)+1,g=V(I);return J(A,s,g,I),g}A.INITIAL_MEMORY;var q,M=[],K=[],c=[],Y=[];K.push({func:function(){l()}});var d=0,P=null,t=null;function n(I){A.onAbort&&A.onAbort(I),R(I+=""),S=!0,I="abort("+I+"). Build with -s ASSERTIONS=1 for more info.";var g=new WebAssembly.RuntimeError(I);throw B(g),g}A.preloadedImages={},A.preloadedAudios={};var r="data:application/octet-stream;base64,";function f(A){return I=A,g=r,String.prototype.startsWith?I.startsWith(g):0===I.indexOf(g);var I,g}var W,b="data:application/octet-stream;base64,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AXgB2AEEAGQAxAAkAYQBJACEAOQARAGkAUQApAAEAWQBxAEMAGwAzAAsAYwBLACMAOwATAGsAUwArAAMAWwBzAEUAHQA1AA0AZQBNACUAPQAVAG0AVQAtAAUAXQB1AEcAHwA3AA8AZwBPACcAPwAXAG8AVwAvAAcAXwB3AEBAGEAwQAhAYEBIQCBAOEAQQGhAUEAoQABAWEBwQEJAGkAyQApAYkBKQCJAOkASQGpAUkAqQAJAWkByQERAHEA0QAxAZEBMQCRAPEAUQGxAVEAsQARAXEB0QEZAHkA2QA5AZkBOQCZAPkAWQG5AVkAuQAZAXkB2QEFAGUAxQAlAYUBJQCFAOUARQGlAUUApQAFAWUBxQENAG0AzQAtAY0BLQCNAO0ATQGtAU0ArQANAW0BzQEVAHUA1QA1AZUBNQCVAPUAVQG1AVUAtQAVAXUB1QEdAH0A3QA9AZ0BPQCdAP0AXQG9AV0AvQAdAX0B3QECAGIAwgAiAYIBIgCCAOIAQgGiAUIAogACAWIBwgEKAGoAygAqAYoBKgCKAOoASgGqAUoAqgAKAWoBygESAHIA0gAyAZIBMgCSAPIAUgGyAVIAsgASAXIB0gEaAHoA2gA6AZoBOgCaAPoAWgG6AVoAugAaAXoB2gEGAGYAxgAmAYYBJgCGAOYARgGmAUYApgAGAWYBxgEOAG4AzgAuAY4BLgCOAO4ATgGuAU4ArgAOAW4BzgEWAHYA1gA2AZYBNgCWAPYAVgG2AVYAtgAWAXYB1gEeAH4A3gA+AZ4BPgCeAP4AXgG+AV4AvgAeAX4B3gEDAGMAwwAjAYMBIwCDAOMAQwGjAUMAowADAWMBwwELAGsAywArAYsBKwCLAOsASwGrAUsAqwALAWsBywETAHMA0wAzAZMBMwCTAPMAUwGzAVMAswATAXMB0wEbAHsA2wA7AZsBOwCbAPsAWwG7AVsAuwAbAXsB2wEHAGcAxwAnAYcBJwCHAOcARwGnAUcApwAHAWcBxwEPAG8AzwAvAY8BLwCPAO8ATwGvAU8ArwAPAW8BzwEXAHcA1wA3AZcBNwCXAPcAVwG3AVcAtwAXAXcB1wEfAH8A3wA/AZ8BPwCfAP8AXwG/AV8AvwAfAX8B3wEAAIA/AAAAgGP6fz+/dVa8i+l/Pwpx1rx5zX8/584gvS+mfz86Xla9r3N/PxPyhb35NX8/Kq+g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PjB8dD9M1Jc+NnV1P3VqkT53Y3Y/PvqKPupGdz/ug4Q+hB94P5wPfD487Xg/TQxvPgmweT+C/mE+4md6P83mVD6+FHs/wsVHPpi2ez/zmzo+Z018P/VpLT4l2Xw/XDAgPstZfT+77xI+Vc99P6ioBT68OX4/c7fwPf2Yfj8EE9Y9Eu1+PzNluz35NX8/Kq+gPa9zfz8T8oU9L6Z/PzpeVj15zX8/584gPYvpfz8KcdY8Y/p/P791VjwAADAAYACQAMAAEABAAHAAoADQACAAUACAALAA4AAEADQAZACUAMQAFABEAHQApADUACQAVACEALQA5AAIADgAaACYAMgAGABIAHgAqADYACgAWACIALgA6AAMADwAbACcAMwAHABMAHwArADcACwAXACMALwA7AABADEAYQCRAMEAEQBBAHEAoQDRACEAUQCBALEA4QAFADUAZQCVAMUAFQBFAHUApQDVACUAVQCFALUA5QAJADkAaQCZAMkAGQBJAHkAqQDZACkAWQCJALkA6QANAD0AbQCdAM0AHQBNAH0ArQDdAC0AXQCNAL0A7QACADIAYgCSAMIAEgBCAHIAogDSACIAUgCCALIA4gAGADYAZgCWAMYAFgBGAHYApgDWACYAVgCGALYA5gAKADoAagCaAMoAGgBKAHoAqgDaACoAWgCKALoA6gAOAD4AbgCeAM4AHgBOAH4ArgDeAC4AXgCOAL4A7gADADMAYwCTAMMAEwBDAHMAowDTACMAUwCDALMA4wAHADcAZwCXAMcAFwBHAHcApwDXACcAVwCHALcA5wALADsAawCbAMsAGwBLAHsAqwDbACsAWwCLALsA6wAPAD8AbwCfAM8AHwBPAH8ArwDfAC8AXwCPAL8A7wDwAAAAiYiIOwEAAAAFADAAAwAQAAQABAAEAAEAQYytAQsGgFQAAIBFAEGirQELiQIYADAASABgAAgAIAA4AFAAaAAQACgAQABYAHAABAAcADQATABkAAwAJAA8AFQAbAAUACwARABcAHQAAQAZADEASQBhAAkAIQA5AFEAaQARACkAQQBZAHEABQAdADUATQBlAA0AJQA9AFUAbQAVAC0ARQBdAHUAAgAaADIASgBiAAoAIgA6AFIAagASACoAQgBaAHIABgAeADYATgBmAA4AJgA+AFYAbgAWAC4ARgBeAHYAAwAbADMASwBjAAsAIwA7AFMAawATACsAQwBbAHMABwAfADcATwBnAA8AJwA/AFcAbwAXAC8ARwBfAHcAeAAAAIiICDwCAAAABQAYAAMACAACAAQABAABAEG8rwELBqBWAACARQBB0q8BC40BDAAYACQAMAAEABAAHAAoADQACAAUACAALAA4AAEADQAZACUAMQAFABEAHQApADUACQAVACEALQA5AAIADgAaACYAMgAGABIAHgAqADYACgAWACIALgA6AAMADwAbACcAMwAHABMAHwArADcACwAXACMALwA7ADwAAACJiIg8AwAAAAUADAADAAQABAABAEH0sAELTdBXAACARQAAAAAAAMBYAACAWwAAPF4AAPRgAACoYwAAWGYAAARpAABsagAAKGsAAJxrAADoawAAIGwAAEBsAABYbAAAZGwAAAAAAAABAEGEtwELoCMBAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAA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";function e(A){try{if(A==b&&w)return new Uint8Array(w);var I=function(A){if(f(A))return function(A){try{for(var I=p(A),g=new Uint8Array(I.length),B=0;B<I.length;++B)g[B]=I.charCodeAt(B);return g}catch(A){throw new Error("Converting base64 string to bytes failed.")}}(A.slice(r.length))}(A);if(I)return I;throw"both async and sync fetching of the wasm failed"}catch(A){n(A)}}function x(I){for(;I.length>0;){var g=I.shift();if("function"!=typeof g){var B=g.func;"number"==typeof B?void 0===g.arg?q.get(B)():q.get(B)(g.arg):B(void 0===g.arg?null:g.arg)}else g(A)}}f(b)||(W=b,b=A.locateFile?A.locateFile(W,o):o+W);var v={mappings:{},buffers:[null,[],[]],printChar:function(A,I){var g=v.buffers[A];0===I||10===I?((1===A?G:R)(y(g,0)),g.length=0):g.push(I)},varargs:void 0,get:function(){return v.varargs+=4,h[v.varargs-4>>2]},getStr:function(A){return H(A)},get64:function(A,I){return A}},p="function"==typeof atob?atob:function(A){var I,g,B,Q,C,E,i="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",D="",o=0;A=A.replace(/[^A-Za-z0-9\\+\\/\\=]/g,"");do{I=i.indexOf(A.charAt(o++))<<2|(Q=i.indexOf(A.charAt(o++)))>>4,g=(15&Q)<<4|(C=i.indexOf(A.charAt(o++)))>>2,B=(3&C)<<6|(E=i.indexOf(A.charAt(o++))),D+=String.fromCharCode(I),64!==C&&(D+=String.fromCharCode(g)),64!==E&&(D+=String.fromCharCode(B))}while(o<A.length);return D};var T,O={b:function(A,I,g){k.copyWithin(A,I,I+g)},c:function(A){n("OOM")},a:function(A,I,g,B){for(var Q=0,C=0;C<g;C++){for(var E=h[I+8*C>>2],i=h[I+(8*C+4)>>2],D=0;D<i;D++)v.printChar(A,k[E+D]);Q+=i}return h[B>>2]=Q,0}},l=(function(){var I={a:O};function g(I,g){var B,Q=I.exports;A.asm=Q,B=A.asm.d.buffer,A.HEAP8=s=new Int8Array(B),A.HEAP16=new Int16Array(B),A.HEAP32=h=new Int32Array(B),A.HEAPU8=k=new Uint8Array(B),A.HEAPU16=new Uint16Array(B),A.HEAPU32=new Uint32Array(B),A.HEAPF32=new Float32Array(B),A.HEAPF64=new Float64Array(B),q=A.asm.e,function(I){if(d--,A.monitorRunDependencies&&A.monitorRunDependencies(d),0==d&&(null!==P&&(clearInterval(P),P=null),t)){var g=t;t=null,g()}}()}function Q(A){g(A.instance)}function C(A){return(w||"function"!=typeof fetch?Promise.resolve().then((function(){return e(b)})):fetch(b,{credentials:"same-origin"}).then((function(A){if(!A.ok)throw"failed to load wasm binary file at \'"+b+"\'";return A.arrayBuffer()})).catch((function(){return e(b)}))).then((function(A){return WebAssembly.instantiate(A,I)})).then(A,(function(A){R("failed to asynchronously prepare wasm: "+A),n(A)}))}if(d++,A.monitorRunDependencies&&A.monitorRunDependencies(d),A.instantiateWasm)try{return A.instantiateWasm(I,g)}catch(A){return R("Module.instantiateWasm callback failed with error: "+A),!1}(w||"function"!=typeof WebAssembly.instantiateStreaming||f(b)||"function"!=typeof fetch?C(Q):fetch(b,{credentials:"same-origin"}).then((function(A){return WebAssembly.instantiateStreaming(A,I).then(Q,(function(A){return R("wasm streaming compile failed: "+A),R("falling back to ArrayBuffer instantiation"),C(Q)}))}))).catch(B)}(),A.___wasm_call_ctors=function(){return(l=A.___wasm_call_ctors=A.asm.f).apply(null,arguments)}),X=(A._stopStream=function(){return(A._stopStream=A.asm.g).apply(null,arguments)},A._startStream=function(){return(A._startStream=A.asm.h).apply(null,arguments)},A._decode=function(){return(A._decode=A.asm.i).apply(null,arguments)},A._createBuffer=function(){return(A._createBuffer=A.asm.j).apply(null,arguments)},A._freeBuffer=function(){return(A._freeBuffer=A.asm.k).apply(null,arguments)},A._main=function(){return(A._main=A.asm.l).apply(null,arguments)},A.stackSave=function(){return(X=A.stackSave=A.asm.m).apply(null,arguments)}),Z=A.stackRestore=function(){return(Z=A.stackRestore=A.asm.n).apply(null,arguments)},V=A.stackAlloc=function(){return(V=A.stackAlloc=A.asm.o).apply(null,arguments)};function z(A){this.name="ExitStatus",this.message="Program terminated with exit("+A+")",this.status=A}function j(I){function B(){T||(T=!0,A.calledRun=!0,S||(x(K),x(c),g(A),A.onRuntimeInitialized&&A.onRuntimeInitialized(),u&&function(I){var g,B=A._main,Q=(I=I||[]).length+1,C=V(4*(Q+1));h[C>>2]=L(i);for(var E=1;E<Q;E++)h[(C>>2)+E]=L(I[E-1]);h[(C>>2)+Q]=0;try{g=B(Q,C),F&&0===g||(F||(A.onExit&&A.onExit(g),S=!0),D(g,new z(g)))}catch(A){if(A instanceof z)return;if("unwind"==A)return void(F=!0);var o=A;A&&"object"==typeof A&&A.stack&&(o=[A,A.stack]),R("exception thrown: "+o),D(1,A)}}(I),function(){if(A.postRun)for("function"==typeof A.postRun&&(A.postRun=[A.postRun]);A.postRun.length;)I=A.postRun.shift(),Y.unshift(I);var I;x(Y)}()))}I=I||E,d>0||(function(){if(A.preRun)for("function"==typeof A.preRun&&(A.preRun=[A.preRun]);A.preRun.length;)I=A.preRun.shift(),M.unshift(I);var I;x(M)}(),d>0||(A.setStatus?(A.setStatus("Running..."),setTimeout((function(){setTimeout((function(){A.setStatus("")}),1),B()}),1)):B()))}if(A.cwrap=function(A,I,g,B){var Q=(g=g||[]).every((function(A){return"number"===A}));return"string"!==I&&Q&&!B?U(A):function(){return a(A,I,g,arguments)}},t=function A(){T||j(),T||(t=A)},A.run=j,A.preInit)for("function"==typeof A.preInit&&(A.preInit=[A.preInit]);A.preInit.length>0;)A.preInit.pop()();var u=!0;return A.noInitialRun&&(u=!1),F=!0,j(),A.ready});A.exports=g}},I={};function g(B){var Q=I[B];if(void 0!==Q)return Q.exports;var C=I[B]={exports:{}};return A[B](C,C.exports,g),C.exports}g.n=A=>{var I=A&&A.__esModule?()=>A.default:()=>A;return g.d(I,{a:I}),I},g.d=(A,I)=>{for(var B in I)g.o(I,B)&&!g.o(A,B)&&Object.defineProperty(A,B,{enumerable:!0,get:I[B]})},g.o=(A,I)=>Object.prototype.hasOwnProperty.call(A,I),(()=>{"use strict";var A,I=g(305),B=g.n(I),Q=0,C=0,E=0,i=0,D=0,o=0;!async function(){A=await B()(),self.addEventListener("message",(async function(I){var g=I.data;switch(g.type){case"startStream":o=g.decodedSamplesPerFrame,D=o*g.channelCount,A._startStream(g.sampleRateHz,g.channelCount);break;case"stopStream":A._stopStream();break;case"decode":{const I=g.startTimestamp,B=function(I){const g=I.byteLength;return 0!=Q&&C<g&&(A._freeBuffer(Q),Q=0,C=0),0==Q&&(Q=A._createBuffer(I.BYTES_PER_ELEMENT*g),C=g),A.HEAPU8.set(I,Q),Q}(new Uint8Array(g.inputData)),w=(0!=E&&i<D&&(A._freeBuffer(E),E=0,i=0),0==E&&(E=A._createBuffer(Float32Array.BYTES_PER_ELEMENT*D),i=D),E),F=new Float32Array(A.HEAPF32.buffer,w,D),G=A._decode(B,g.inputData.byteLength,w,o),R=F.buffer.slice(w,w+D*F.BYTES_PER_ELEMENT);postMessage({type:"decodeDone",startTimestamp:I,outputData:R,samplesDecoded:G},[R]);break}case"release":0!=Q&&(A._freeBuffer(Q),Q=0,C=0),0!=E&&(A._freeBuffer(E),E=0,i=0),A._stopStream()}})),postMessage({type:"decoderReady"})}()})()})();',"Worker",void 0,void 0)}},614:A=>{A.exports=function(A,I,g,e){var B=self||window;try{try{var i;try{i=new B.Blob([A])}catch(I){(i=new(B.BlobBuilder||B.WebKitBlobBuilder||B.MozBlobBuilder||B.MSBlobBuilder)).append(A),i=i.getBlob()}var Q=B.URL||B.webkitURL,t=Q.createObjectURL(i),C=new B[I](t,g);return Q.revokeObjectURL(t),C}catch(e){return new B[I]("data:application/javascript,".concat(encodeURIComponent(A)),g)}}catch(A){if(!e)throw Error("Inline worker is not supported");return new B[I](e,g)}}}},I={};function g(e){var B=I[e];if(void 0!==B)return B.exports;var i=I[e]={exports:{}};return A[e].call(i.exports,i,i.exports,g),i.exports}return g.n=A=>{var I=A&&A.__esModule?()=>A.default:()=>A;return g.d(I,{a:I}),I},g.d=(A,I)=>{for(var e in I)g.o(I,e)&&!g.o(A,e)&&Object.defineProperty(A,e,{enumerable:!0,get:I[e]})},g.o=(A,I)=>Object.prototype.hasOwnProperty.call(A,I),g.r=A=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(A,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(A,"__esModule",{value:!0})},g(114)})()},700:()=>{}},I={};function g(e){var B=I[e];if(void 0!==B)return B.exports;var i=I[e]={exports:{}};return A[e].call(i.exports,i,i.exports,g),i.exports}return g.g=function(){if("object"==typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(A){if("object"==typeof window)return window}}(),g(14)})()}));

/***/ }),

/***/ "./node_modules/react-dom/cjs/react-dom.development.js":
/*!*************************************************************!*\
  !*** ./node_modules/react-dom/cjs/react-dom.development.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/** @license React v17.0.2
 * react-dom.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



if (true) {
  (function() {
'use strict';

var React = __webpack_require__(/*! react */ "./node_modules/react/index.js");
var _assign = __webpack_require__(/*! object-assign */ "./node_modules/object-assign/index.js");
var Scheduler = __webpack_require__(/*! scheduler */ "./node_modules/scheduler/index.js");
var tracing = __webpack_require__(/*! scheduler/tracing */ "./node_modules/scheduler/tracing.js");

var ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;

// by calls to these methods by a Babel plugin.
//
// In PROD (or in packages without access to React internals),
// they are left as they are instead.

function warn(format) {
  {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    printWarning('warn', format, args);
  }
}
function error(format) {
  {
    for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
      args[_key2 - 1] = arguments[_key2];
    }

    printWarning('error', format, args);
  }
}

function printWarning(level, format, args) {
  // When changing this logic, you might want to also
  // update consoleWithStackDev.www.js as well.
  {
    var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
    var stack = ReactDebugCurrentFrame.getStackAddendum();

    if (stack !== '') {
      format += '%s';
      args = args.concat([stack]);
    }

    var argsWithFormat = args.map(function (item) {
      return '' + item;
    }); // Careful: RN currently depends on this prefix

    argsWithFormat.unshift('Warning: ' + format); // We intentionally don't use spread (or .apply) directly because it
    // breaks IE9: https://github.com/facebook/react/issues/13610
    // eslint-disable-next-line react-internal/no-production-logging

    Function.prototype.apply.call(console[level], console, argsWithFormat);
  }
}

if (!React) {
  {
    throw Error( "ReactDOM was loaded before React. Make sure you load the React package before loading ReactDOM." );
  }
}

var FunctionComponent = 0;
var ClassComponent = 1;
var IndeterminateComponent = 2; // Before we know whether it is function or class

var HostRoot = 3; // Root of a host tree. Could be nested inside another node.

var HostPortal = 4; // A subtree. Could be an entry point to a different renderer.

var HostComponent = 5;
var HostText = 6;
var Fragment = 7;
var Mode = 8;
var ContextConsumer = 9;
var ContextProvider = 10;
var ForwardRef = 11;
var Profiler = 12;
var SuspenseComponent = 13;
var MemoComponent = 14;
var SimpleMemoComponent = 15;
var LazyComponent = 16;
var IncompleteClassComponent = 17;
var DehydratedFragment = 18;
var SuspenseListComponent = 19;
var FundamentalComponent = 20;
var ScopeComponent = 21;
var Block = 22;
var OffscreenComponent = 23;
var LegacyHiddenComponent = 24;

// Filter certain DOM attributes (e.g. src, href) if their values are empty strings.

var enableProfilerTimer = true; // Record durations for commit and passive effects phases.

var enableFundamentalAPI = false; // Experimental Scope support.
var enableNewReconciler = false; // Errors that are thrown while unmounting (or after in the case of passive effects)
var warnAboutStringRefs = false;

var allNativeEvents = new Set();
/**
 * Mapping from registration name to event name
 */


var registrationNameDependencies = {};
/**
 * Mapping from lowercase registration names to the properly cased version,
 * used to warn in the case of missing event handlers. Available
 * only in true.
 * @type {Object}
 */

var possibleRegistrationNames =  {} ; // Trust the developer to only use possibleRegistrationNames in true

function registerTwoPhaseEvent(registrationName, dependencies) {
  registerDirectEvent(registrationName, dependencies);
  registerDirectEvent(registrationName + 'Capture', dependencies);
}
function registerDirectEvent(registrationName, dependencies) {
  {
    if (registrationNameDependencies[registrationName]) {
      error('EventRegistry: More than one plugin attempted to publish the same ' + 'registration name, `%s`.', registrationName);
    }
  }

  registrationNameDependencies[registrationName] = dependencies;

  {
    var lowerCasedName = registrationName.toLowerCase();
    possibleRegistrationNames[lowerCasedName] = registrationName;

    if (registrationName === 'onDoubleClick') {
      possibleRegistrationNames.ondblclick = registrationName;
    }
  }

  for (var i = 0; i < dependencies.length; i++) {
    allNativeEvents.add(dependencies[i]);
  }
}

var canUseDOM = !!(typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined');

// A reserved attribute.
// It is handled by React separately and shouldn't be written to the DOM.
var RESERVED = 0; // A simple string attribute.
// Attributes that aren't in the filter are presumed to have this type.

var STRING = 1; // A string attribute that accepts booleans in React. In HTML, these are called
// "enumerated" attributes with "true" and "false" as possible values.
// When true, it should be set to a "true" string.
// When false, it should be set to a "false" string.

var BOOLEANISH_STRING = 2; // A real boolean attribute.
// When true, it should be present (set either to an empty string or its name).
// When false, it should be omitted.

var BOOLEAN = 3; // An attribute that can be used as a flag as well as with a value.
// When true, it should be present (set either to an empty string or its name).
// When false, it should be omitted.
// For any other value, should be present with that value.

var OVERLOADED_BOOLEAN = 4; // An attribute that must be numeric or parse as a numeric.
// When falsy, it should be removed.

var NUMERIC = 5; // An attribute that must be positive numeric or parse as a positive numeric.
// When falsy, it should be removed.

var POSITIVE_NUMERIC = 6;

/* eslint-disable max-len */
var ATTRIBUTE_NAME_START_CHAR = ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD";
/* eslint-enable max-len */

var ATTRIBUTE_NAME_CHAR = ATTRIBUTE_NAME_START_CHAR + "\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040";
var ROOT_ATTRIBUTE_NAME = 'data-reactroot';
var VALID_ATTRIBUTE_NAME_REGEX = new RegExp('^[' + ATTRIBUTE_NAME_START_CHAR + '][' + ATTRIBUTE_NAME_CHAR + ']*$');
var hasOwnProperty = Object.prototype.hasOwnProperty;
var illegalAttributeNameCache = {};
var validatedAttributeNameCache = {};
function isAttributeNameSafe(attributeName) {
  if (hasOwnProperty.call(validatedAttributeNameCache, attributeName)) {
    return true;
  }

  if (hasOwnProperty.call(illegalAttributeNameCache, attributeName)) {
    return false;
  }

  if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName)) {
    validatedAttributeNameCache[attributeName] = true;
    return true;
  }

  illegalAttributeNameCache[attributeName] = true;

  {
    error('Invalid attribute name: `%s`', attributeName);
  }

  return false;
}
function shouldIgnoreAttribute(name, propertyInfo, isCustomComponentTag) {
  if (propertyInfo !== null) {
    return propertyInfo.type === RESERVED;
  }

  if (isCustomComponentTag) {
    return false;
  }

  if (name.length > 2 && (name[0] === 'o' || name[0] === 'O') && (name[1] === 'n' || name[1] === 'N')) {
    return true;
  }

  return false;
}
function shouldRemoveAttributeWithWarning(name, value, propertyInfo, isCustomComponentTag) {
  if (propertyInfo !== null && propertyInfo.type === RESERVED) {
    return false;
  }

  switch (typeof value) {
    case 'function': // $FlowIssue symbol is perfectly valid here

    case 'symbol':
      // eslint-disable-line
      return true;

    case 'boolean':
      {
        if (isCustomComponentTag) {
          return false;
        }

        if (propertyInfo !== null) {
          return !propertyInfo.acceptsBooleans;
        } else {
          var prefix = name.toLowerCase().slice(0, 5);
          return prefix !== 'data-' && prefix !== 'aria-';
        }
      }

    default:
      return false;
  }
}
function shouldRemoveAttribute(name, value, propertyInfo, isCustomComponentTag) {
  if (value === null || typeof value === 'undefined') {
    return true;
  }

  if (shouldRemoveAttributeWithWarning(name, value, propertyInfo, isCustomComponentTag)) {
    return true;
  }

  if (isCustomComponentTag) {
    return false;
  }

  if (propertyInfo !== null) {

    switch (propertyInfo.type) {
      case BOOLEAN:
        return !value;

      case OVERLOADED_BOOLEAN:
        return value === false;

      case NUMERIC:
        return isNaN(value);

      case POSITIVE_NUMERIC:
        return isNaN(value) || value < 1;
    }
  }

  return false;
}
function getPropertyInfo(name) {
  return properties.hasOwnProperty(name) ? properties[name] : null;
}

function PropertyInfoRecord(name, type, mustUseProperty, attributeName, attributeNamespace, sanitizeURL, removeEmptyString) {
  this.acceptsBooleans = type === BOOLEANISH_STRING || type === BOOLEAN || type === OVERLOADED_BOOLEAN;
  this.attributeName = attributeName;
  this.attributeNamespace = attributeNamespace;
  this.mustUseProperty = mustUseProperty;
  this.propertyName = name;
  this.type = type;
  this.sanitizeURL = sanitizeURL;
  this.removeEmptyString = removeEmptyString;
} // When adding attributes to this list, be sure to also add them to
// the `possibleStandardNames` module to ensure casing and incorrect
// name warnings.


var properties = {}; // These props are reserved by React. They shouldn't be written to the DOM.

var reservedProps = ['children', 'dangerouslySetInnerHTML', // TODO: This prevents the assignment of defaultValue to regular
// elements (not just inputs). Now that ReactDOMInput assigns to the
// defaultValue property -- do we need this?
'defaultValue', 'defaultChecked', 'innerHTML', 'suppressContentEditableWarning', 'suppressHydrationWarning', 'style'];
reservedProps.forEach(function (name) {
  properties[name] = new PropertyInfoRecord(name, RESERVED, false, // mustUseProperty
  name, // attributeName
  null, // attributeNamespace
  false, // sanitizeURL
  false);
}); // A few React string attributes have a different name.
// This is a mapping from React prop names to the attribute names.

[['acceptCharset', 'accept-charset'], ['className', 'class'], ['htmlFor', 'for'], ['httpEquiv', 'http-equiv']].forEach(function (_ref) {
  var name = _ref[0],
      attributeName = _ref[1];
  properties[name] = new PropertyInfoRecord(name, STRING, false, // mustUseProperty
  attributeName, // attributeName
  null, // attributeNamespace
  false, // sanitizeURL
  false);
}); // These are "enumerated" HTML attributes that accept "true" and "false".
// In React, we let users pass `true` and `false` even though technically
// these aren't boolean attributes (they are coerced to strings).

['contentEditable', 'draggable', 'spellCheck', 'value'].forEach(function (name) {
  properties[name] = new PropertyInfoRecord(name, BOOLEANISH_STRING, false, // mustUseProperty
  name.toLowerCase(), // attributeName
  null, // attributeNamespace
  false, // sanitizeURL
  false);
}); // These are "enumerated" SVG attributes that accept "true" and "false".
// In React, we let users pass `true` and `false` even though technically
// these aren't boolean attributes (they are coerced to strings).
// Since these are SVG attributes, their attribute names are case-sensitive.

['autoReverse', 'externalResourcesRequired', 'focusable', 'preserveAlpha'].forEach(function (name) {
  properties[name] = new PropertyInfoRecord(name, BOOLEANISH_STRING, false, // mustUseProperty
  name, // attributeName
  null, // attributeNamespace
  false, // sanitizeURL
  false);
}); // These are HTML boolean attributes.

['allowFullScreen', 'async', // Note: there is a special case that prevents it from being written to the DOM
// on the client side because the browsers are inconsistent. Instead we call focus().
'autoFocus', 'autoPlay', 'controls', 'default', 'defer', 'disabled', 'disablePictureInPicture', 'disableRemotePlayback', 'formNoValidate', 'hidden', 'loop', 'noModule', 'noValidate', 'open', 'playsInline', 'readOnly', 'required', 'reversed', 'scoped', 'seamless', // Microdata
'itemScope'].forEach(function (name) {
  properties[name] = new PropertyInfoRecord(name, BOOLEAN, false, // mustUseProperty
  name.toLowerCase(), // attributeName
  null, // attributeNamespace
  false, // sanitizeURL
  false);
}); // These are the few React props that we set as DOM properties
// rather than attributes. These are all booleans.

['checked', // Note: `option.selected` is not updated if `select.multiple` is
// disabled with `removeAttribute`. We have special logic for handling this.
'multiple', 'muted', 'selected' // NOTE: if you add a camelCased prop to this list,
// you'll need to set attributeName to name.toLowerCase()
// instead in the assignment below.
].forEach(function (name) {
  properties[name] = new PropertyInfoRecord(name, BOOLEAN, true, // mustUseProperty
  name, // attributeName
  null, // attributeNamespace
  false, // sanitizeURL
  false);
}); // These are HTML attributes that are "overloaded booleans": they behave like
// booleans, but can also accept a string value.

['capture', 'download' // NOTE: if you add a camelCased prop to this list,
// you'll need to set attributeName to name.toLowerCase()
// instead in the assignment below.
].forEach(function (name) {
  properties[name] = new PropertyInfoRecord(name, OVERLOADED_BOOLEAN, false, // mustUseProperty
  name, // attributeName
  null, // attributeNamespace
  false, // sanitizeURL
  false);
}); // These are HTML attributes that must be positive numbers.

['cols', 'rows', 'size', 'span' // NOTE: if you add a camelCased prop to this list,
// you'll need to set attributeName to name.toLowerCase()
// instead in the assignment below.
].forEach(function (name) {
  properties[name] = new PropertyInfoRecord(name, POSITIVE_NUMERIC, false, // mustUseProperty
  name, // attributeName
  null, // attributeNamespace
  false, // sanitizeURL
  false);
}); // These are HTML attributes that must be numbers.

['rowSpan', 'start'].forEach(function (name) {
  properties[name] = new PropertyInfoRecord(name, NUMERIC, false, // mustUseProperty
  name.toLowerCase(), // attributeName
  null, // attributeNamespace
  false, // sanitizeURL
  false);
});
var CAMELIZE = /[\-\:]([a-z])/g;

var capitalize = function (token) {
  return token[1].toUpperCase();
}; // This is a list of all SVG attributes that need special casing, namespacing,
// or boolean value assignment. Regular attributes that just accept strings
// and have the same names are omitted, just like in the HTML attribute filter.
// Some of these attributes can be hard to find. This list was created by
// scraping the MDN documentation.


['accent-height', 'alignment-baseline', 'arabic-form', 'baseline-shift', 'cap-height', 'clip-path', 'clip-rule', 'color-interpolation', 'color-interpolation-filters', 'color-profile', 'color-rendering', 'dominant-baseline', 'enable-background', 'fill-opacity', 'fill-rule', 'flood-color', 'flood-opacity', 'font-family', 'font-size', 'font-size-adjust', 'font-stretch', 'font-style', 'font-variant', 'font-weight', 'glyph-name', 'glyph-orientation-horizontal', 'glyph-orientation-vertical', 'horiz-adv-x', 'horiz-origin-x', 'image-rendering', 'letter-spacing', 'lighting-color', 'marker-end', 'marker-mid', 'marker-start', 'overline-position', 'overline-thickness', 'paint-order', 'panose-1', 'pointer-events', 'rendering-intent', 'shape-rendering', 'stop-color', 'stop-opacity', 'strikethrough-position', 'strikethrough-thickness', 'stroke-dasharray', 'stroke-dashoffset', 'stroke-linecap', 'stroke-linejoin', 'stroke-miterlimit', 'stroke-opacity', 'stroke-width', 'text-anchor', 'text-decoration', 'text-rendering', 'underline-position', 'underline-thickness', 'unicode-bidi', 'unicode-range', 'units-per-em', 'v-alphabetic', 'v-hanging', 'v-ideographic', 'v-mathematical', 'vector-effect', 'vert-adv-y', 'vert-origin-x', 'vert-origin-y', 'word-spacing', 'writing-mode', 'xmlns:xlink', 'x-height' // NOTE: if you add a camelCased prop to this list,
// you'll need to set attributeName to name.toLowerCase()
// instead in the assignment below.
].forEach(function (attributeName) {
  var name = attributeName.replace(CAMELIZE, capitalize);
  properties[name] = new PropertyInfoRecord(name, STRING, false, // mustUseProperty
  attributeName, null, // attributeNamespace
  false, // sanitizeURL
  false);
}); // String SVG attributes with the xlink namespace.

['xlink:actuate', 'xlink:arcrole', 'xlink:role', 'xlink:show', 'xlink:title', 'xlink:type' // NOTE: if you add a camelCased prop to this list,
// you'll need to set attributeName to name.toLowerCase()
// instead in the assignment below.
].forEach(function (attributeName) {
  var name = attributeName.replace(CAMELIZE, capitalize);
  properties[name] = new PropertyInfoRecord(name, STRING, false, // mustUseProperty
  attributeName, 'http://www.w3.org/1999/xlink', false, // sanitizeURL
  false);
}); // String SVG attributes with the xml namespace.

['xml:base', 'xml:lang', 'xml:space' // NOTE: if you add a camelCased prop to this list,
// you'll need to set attributeName to name.toLowerCase()
// instead in the assignment below.
].forEach(function (attributeName) {
  var name = attributeName.replace(CAMELIZE, capitalize);
  properties[name] = new PropertyInfoRecord(name, STRING, false, // mustUseProperty
  attributeName, 'http://www.w3.org/XML/1998/namespace', false, // sanitizeURL
  false);
}); // These attribute exists both in HTML and SVG.
// The attribute name is case-sensitive in SVG so we can't just use
// the React name like we do for attributes that exist only in HTML.

['tabIndex', 'crossOrigin'].forEach(function (attributeName) {
  properties[attributeName] = new PropertyInfoRecord(attributeName, STRING, false, // mustUseProperty
  attributeName.toLowerCase(), // attributeName
  null, // attributeNamespace
  false, // sanitizeURL
  false);
}); // These attributes accept URLs. These must not allow javascript: URLS.
// These will also need to accept Trusted Types object in the future.

var xlinkHref = 'xlinkHref';
properties[xlinkHref] = new PropertyInfoRecord('xlinkHref', STRING, false, // mustUseProperty
'xlink:href', 'http://www.w3.org/1999/xlink', true, // sanitizeURL
false);
['src', 'href', 'action', 'formAction'].forEach(function (attributeName) {
  properties[attributeName] = new PropertyInfoRecord(attributeName, STRING, false, // mustUseProperty
  attributeName.toLowerCase(), // attributeName
  null, // attributeNamespace
  true, // sanitizeURL
  true);
});

// and any newline or tab are filtered out as if they're not part of the URL.
// https://url.spec.whatwg.org/#url-parsing
// Tab or newline are defined as \r\n\t:
// https://infra.spec.whatwg.org/#ascii-tab-or-newline
// A C0 control is a code point in the range \u0000 NULL to \u001F
// INFORMATION SEPARATOR ONE, inclusive:
// https://infra.spec.whatwg.org/#c0-control-or-space

/* eslint-disable max-len */

var isJavaScriptProtocol = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*\:/i;
var didWarn = false;

function sanitizeURL(url) {
  {
    if (!didWarn && isJavaScriptProtocol.test(url)) {
      didWarn = true;

      error('A future version of React will block javascript: URLs as a security precaution. ' + 'Use event handlers instead if you can. If you need to generate unsafe HTML try ' + 'using dangerouslySetInnerHTML instead. React was passed %s.', JSON.stringify(url));
    }
  }
}

/**
 * Get the value for a property on a node. Only used in DEV for SSR validation.
 * The "expected" argument is used as a hint of what the expected value is.
 * Some properties have multiple equivalent values.
 */
function getValueForProperty(node, name, expected, propertyInfo) {
  {
    if (propertyInfo.mustUseProperty) {
      var propertyName = propertyInfo.propertyName;
      return node[propertyName];
    } else {
      if ( propertyInfo.sanitizeURL) {
        // If we haven't fully disabled javascript: URLs, and if
        // the hydration is successful of a javascript: URL, we
        // still want to warn on the client.
        sanitizeURL('' + expected);
      }

      var attributeName = propertyInfo.attributeName;
      var stringValue = null;

      if (propertyInfo.type === OVERLOADED_BOOLEAN) {
        if (node.hasAttribute(attributeName)) {
          var value = node.getAttribute(attributeName);

          if (value === '') {
            return true;
          }

          if (shouldRemoveAttribute(name, expected, propertyInfo, false)) {
            return value;
          }

          if (value === '' + expected) {
            return expected;
          }

          return value;
        }
      } else if (node.hasAttribute(attributeName)) {
        if (shouldRemoveAttribute(name, expected, propertyInfo, false)) {
          // We had an attribute but shouldn't have had one, so read it
          // for the error message.
          return node.getAttribute(attributeName);
        }

        if (propertyInfo.type === BOOLEAN) {
          // If this was a boolean, it doesn't matter what the value is
          // the fact that we have it is the same as the expected.
          return expected;
        } // Even if this property uses a namespace we use getAttribute
        // because we assume its namespaced name is the same as our config.
        // To use getAttributeNS we need the local name which we don't have
        // in our config atm.


        stringValue = node.getAttribute(attributeName);
      }

      if (shouldRemoveAttribute(name, expected, propertyInfo, false)) {
        return stringValue === null ? expected : stringValue;
      } else if (stringValue === '' + expected) {
        return expected;
      } else {
        return stringValue;
      }
    }
  }
}
/**
 * Get the value for a attribute on a node. Only used in DEV for SSR validation.
 * The third argument is used as a hint of what the expected value is. Some
 * attributes have multiple equivalent values.
 */

function getValueForAttribute(node, name, expected) {
  {
    if (!isAttributeNameSafe(name)) {
      return;
    } // If the object is an opaque reference ID, it's expected that
    // the next prop is different than the server value, so just return
    // expected


    if (isOpaqueHydratingObject(expected)) {
      return expected;
    }

    if (!node.hasAttribute(name)) {
      return expected === undefined ? undefined : null;
    }

    var value = node.getAttribute(name);

    if (value === '' + expected) {
      return expected;
    }

    return value;
  }
}
/**
 * Sets the value for a property on a node.
 *
 * @param {DOMElement} node
 * @param {string} name
 * @param {*} value
 */

function setValueForProperty(node, name, value, isCustomComponentTag) {
  var propertyInfo = getPropertyInfo(name);

  if (shouldIgnoreAttribute(name, propertyInfo, isCustomComponentTag)) {
    return;
  }

  if (shouldRemoveAttribute(name, value, propertyInfo, isCustomComponentTag)) {
    value = null;
  } // If the prop isn't in the special list, treat it as a simple attribute.


  if (isCustomComponentTag || propertyInfo === null) {
    if (isAttributeNameSafe(name)) {
      var _attributeName = name;

      if (value === null) {
        node.removeAttribute(_attributeName);
      } else {
        node.setAttribute(_attributeName,  '' + value);
      }
    }

    return;
  }

  var mustUseProperty = propertyInfo.mustUseProperty;

  if (mustUseProperty) {
    var propertyName = propertyInfo.propertyName;

    if (value === null) {
      var type = propertyInfo.type;
      node[propertyName] = type === BOOLEAN ? false : '';
    } else {
      // Contrary to `setAttribute`, object properties are properly
      // `toString`ed by IE8/9.
      node[propertyName] = value;
    }

    return;
  } // The rest are treated as attributes with special cases.


  var attributeName = propertyInfo.attributeName,
      attributeNamespace = propertyInfo.attributeNamespace;

  if (value === null) {
    node.removeAttribute(attributeName);
  } else {
    var _type = propertyInfo.type;
    var attributeValue;

    if (_type === BOOLEAN || _type === OVERLOADED_BOOLEAN && value === true) {
      // If attribute type is boolean, we know for sure it won't be an execution sink
      // and we won't require Trusted Type here.
      attributeValue = '';
    } else {
      // `setAttribute` with objects becomes only `[object]` in IE8/9,
      // ('' + value) makes it output the correct toString()-value.
      {
        attributeValue = '' + value;
      }

      if (propertyInfo.sanitizeURL) {
        sanitizeURL(attributeValue.toString());
      }
    }

    if (attributeNamespace) {
      node.setAttributeNS(attributeNamespace, attributeName, attributeValue);
    } else {
      node.setAttribute(attributeName, attributeValue);
    }
  }
}

// ATTENTION
// When adding new symbols to this file,
// Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'
// The Symbol used to tag the ReactElement-like types. If there is no native Symbol
// nor polyfill, then a plain number is used for performance.
var REACT_ELEMENT_TYPE = 0xeac7;
var REACT_PORTAL_TYPE = 0xeaca;
var REACT_FRAGMENT_TYPE = 0xeacb;
var REACT_STRICT_MODE_TYPE = 0xeacc;
var REACT_PROFILER_TYPE = 0xead2;
var REACT_PROVIDER_TYPE = 0xeacd;
var REACT_CONTEXT_TYPE = 0xeace;
var REACT_FORWARD_REF_TYPE = 0xead0;
var REACT_SUSPENSE_TYPE = 0xead1;
var REACT_SUSPENSE_LIST_TYPE = 0xead8;
var REACT_MEMO_TYPE = 0xead3;
var REACT_LAZY_TYPE = 0xead4;
var REACT_BLOCK_TYPE = 0xead9;
var REACT_SERVER_BLOCK_TYPE = 0xeada;
var REACT_FUNDAMENTAL_TYPE = 0xead5;
var REACT_SCOPE_TYPE = 0xead7;
var REACT_OPAQUE_ID_TYPE = 0xeae0;
var REACT_DEBUG_TRACING_MODE_TYPE = 0xeae1;
var REACT_OFFSCREEN_TYPE = 0xeae2;
var REACT_LEGACY_HIDDEN_TYPE = 0xeae3;

if (typeof Symbol === 'function' && Symbol.for) {
  var symbolFor = Symbol.for;
  REACT_ELEMENT_TYPE = symbolFor('react.element');
  REACT_PORTAL_TYPE = symbolFor('react.portal');
  REACT_FRAGMENT_TYPE = symbolFor('react.fragment');
  REACT_STRICT_MODE_TYPE = symbolFor('react.strict_mode');
  REACT_PROFILER_TYPE = symbolFor('react.profiler');
  REACT_PROVIDER_TYPE = symbolFor('react.provider');
  REACT_CONTEXT_TYPE = symbolFor('react.context');
  REACT_FORWARD_REF_TYPE = symbolFor('react.forward_ref');
  REACT_SUSPENSE_TYPE = symbolFor('react.suspense');
  REACT_SUSPENSE_LIST_TYPE = symbolFor('react.suspense_list');
  REACT_MEMO_TYPE = symbolFor('react.memo');
  REACT_LAZY_TYPE = symbolFor('react.lazy');
  REACT_BLOCK_TYPE = symbolFor('react.block');
  REACT_SERVER_BLOCK_TYPE = symbolFor('react.server.block');
  REACT_FUNDAMENTAL_TYPE = symbolFor('react.fundamental');
  REACT_SCOPE_TYPE = symbolFor('react.scope');
  REACT_OPAQUE_ID_TYPE = symbolFor('react.opaque.id');
  REACT_DEBUG_TRACING_MODE_TYPE = symbolFor('react.debug_trace_mode');
  REACT_OFFSCREEN_TYPE = symbolFor('react.offscreen');
  REACT_LEGACY_HIDDEN_TYPE = symbolFor('react.legacy_hidden');
}

var MAYBE_ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
var FAUX_ITERATOR_SYMBOL = '@@iterator';
function getIteratorFn(maybeIterable) {
  if (maybeIterable === null || typeof maybeIterable !== 'object') {
    return null;
  }

  var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];

  if (typeof maybeIterator === 'function') {
    return maybeIterator;
  }

  return null;
}

// Helpers to patch console.logs to avoid logging during side-effect free
// replaying on render function. This currently only patches the object
// lazily which won't cover if the log function was extracted eagerly.
// We could also eagerly patch the method.
var disabledDepth = 0;
var prevLog;
var prevInfo;
var prevWarn;
var prevError;
var prevGroup;
var prevGroupCollapsed;
var prevGroupEnd;

function disabledLog() {}

disabledLog.__reactDisabledLog = true;
function disableLogs() {
  {
    if (disabledDepth === 0) {
      /* eslint-disable react-internal/no-production-logging */
      prevLog = console.log;
      prevInfo = console.info;
      prevWarn = console.warn;
      prevError = console.error;
      prevGroup = console.group;
      prevGroupCollapsed = console.groupCollapsed;
      prevGroupEnd = console.groupEnd; // https://github.com/facebook/react/issues/19099

      var props = {
        configurable: true,
        enumerable: true,
        value: disabledLog,
        writable: true
      }; // $FlowFixMe Flow thinks console is immutable.

      Object.defineProperties(console, {
        info: props,
        log: props,
        warn: props,
        error: props,
        group: props,
        groupCollapsed: props,
        groupEnd: props
      });
      /* eslint-enable react-internal/no-production-logging */
    }

    disabledDepth++;
  }
}
function reenableLogs() {
  {
    disabledDepth--;

    if (disabledDepth === 0) {
      /* eslint-disable react-internal/no-production-logging */
      var props = {
        configurable: true,
        enumerable: true,
        writable: true
      }; // $FlowFixMe Flow thinks console is immutable.

      Object.defineProperties(console, {
        log: _assign({}, props, {
          value: prevLog
        }),
        info: _assign({}, props, {
          value: prevInfo
        }),
        warn: _assign({}, props, {
          value: prevWarn
        }),
        error: _assign({}, props, {
          value: prevError
        }),
        group: _assign({}, props, {
          value: prevGroup
        }),
        groupCollapsed: _assign({}, props, {
          value: prevGroupCollapsed
        }),
        groupEnd: _assign({}, props, {
          value: prevGroupEnd
        })
      });
      /* eslint-enable react-internal/no-production-logging */
    }

    if (disabledDepth < 0) {
      error('disabledDepth fell below zero. ' + 'This is a bug in React. Please file an issue.');
    }
  }
}

var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;
var prefix;
function describeBuiltInComponentFrame(name, source, ownerFn) {
  {
    if (prefix === undefined) {
      // Extract the VM specific prefix used by each line.
      try {
        throw Error();
      } catch (x) {
        var match = x.stack.trim().match(/\n( *(at )?)/);
        prefix = match && match[1] || '';
      }
    } // We use the prefix to ensure our stacks line up with native stack frames.


    return '\n' + prefix + name;
  }
}
var reentry = false;
var componentFrameCache;

{
  var PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map;
  componentFrameCache = new PossiblyWeakMap();
}

function describeNativeComponentFrame(fn, construct) {
  // If something asked for a stack inside a fake render, it should get ignored.
  if (!fn || reentry) {
    return '';
  }

  {
    var frame = componentFrameCache.get(fn);

    if (frame !== undefined) {
      return frame;
    }
  }

  var control;
  reentry = true;
  var previousPrepareStackTrace = Error.prepareStackTrace; // $FlowFixMe It does accept undefined.

  Error.prepareStackTrace = undefined;
  var previousDispatcher;

  {
    previousDispatcher = ReactCurrentDispatcher.current; // Set the dispatcher in DEV because this might be call in the render function
    // for warnings.

    ReactCurrentDispatcher.current = null;
    disableLogs();
  }

  try {
    // This should throw.
    if (construct) {
      // Something should be setting the props in the constructor.
      var Fake = function () {
        throw Error();
      }; // $FlowFixMe


      Object.defineProperty(Fake.prototype, 'props', {
        set: function () {
          // We use a throwing setter instead of frozen or non-writable props
          // because that won't throw in a non-strict mode function.
          throw Error();
        }
      });

      if (typeof Reflect === 'object' && Reflect.construct) {
        // We construct a different control for this case to include any extra
        // frames added by the construct call.
        try {
          Reflect.construct(Fake, []);
        } catch (x) {
          control = x;
        }

        Reflect.construct(fn, [], Fake);
      } else {
        try {
          Fake.call();
        } catch (x) {
          control = x;
        }

        fn.call(Fake.prototype);
      }
    } else {
      try {
        throw Error();
      } catch (x) {
        control = x;
      }

      fn();
    }
  } catch (sample) {
    // This is inlined manually because closure doesn't do it for us.
    if (sample && control && typeof sample.stack === 'string') {
      // This extracts the first frame from the sample that isn't also in the control.
      // Skipping one frame that we assume is the frame that calls the two.
      var sampleLines = sample.stack.split('\n');
      var controlLines = control.stack.split('\n');
      var s = sampleLines.length - 1;
      var c = controlLines.length - 1;

      while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {
        // We expect at least one stack frame to be shared.
        // Typically this will be the root most one. However, stack frames may be
        // cut off due to maximum stack limits. In this case, one maybe cut off
        // earlier than the other. We assume that the sample is longer or the same
        // and there for cut off earlier. So we should find the root most frame in
        // the sample somewhere in the control.
        c--;
      }

      for (; s >= 1 && c >= 0; s--, c--) {
        // Next we find the first one that isn't the same which should be the
        // frame that called our sample function and the control.
        if (sampleLines[s] !== controlLines[c]) {
          // In V8, the first line is describing the message but other VMs don't.
          // If we're about to return the first line, and the control is also on the same
          // line, that's a pretty good indicator that our sample threw at same line as
          // the control. I.e. before we entered the sample frame. So we ignore this result.
          // This can happen if you passed a class to function component, or non-function.
          if (s !== 1 || c !== 1) {
            do {
              s--;
              c--; // We may still have similar intermediate frames from the construct call.
              // The next one that isn't the same should be our match though.

              if (c < 0 || sampleLines[s] !== controlLines[c]) {
                // V8 adds a "new" prefix for native classes. Let's remove it to make it prettier.
                var _frame = '\n' + sampleLines[s].replace(' at new ', ' at ');

                {
                  if (typeof fn === 'function') {
                    componentFrameCache.set(fn, _frame);
                  }
                } // Return the line we found.


                return _frame;
              }
            } while (s >= 1 && c >= 0);
          }

          break;
        }
      }
    }
  } finally {
    reentry = false;

    {
      ReactCurrentDispatcher.current = previousDispatcher;
      reenableLogs();
    }

    Error.prepareStackTrace = previousPrepareStackTrace;
  } // Fallback to just using the name if we couldn't make it throw.


  var name = fn ? fn.displayName || fn.name : '';
  var syntheticFrame = name ? describeBuiltInComponentFrame(name) : '';

  {
    if (typeof fn === 'function') {
      componentFrameCache.set(fn, syntheticFrame);
    }
  }

  return syntheticFrame;
}

function describeClassComponentFrame(ctor, source, ownerFn) {
  {
    return describeNativeComponentFrame(ctor, true);
  }
}
function describeFunctionComponentFrame(fn, source, ownerFn) {
  {
    return describeNativeComponentFrame(fn, false);
  }
}

function shouldConstruct(Component) {
  var prototype = Component.prototype;
  return !!(prototype && prototype.isReactComponent);
}

function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {

  if (type == null) {
    return '';
  }

  if (typeof type === 'function') {
    {
      return describeNativeComponentFrame(type, shouldConstruct(type));
    }
  }

  if (typeof type === 'string') {
    return describeBuiltInComponentFrame(type);
  }

  switch (type) {
    case REACT_SUSPENSE_TYPE:
      return describeBuiltInComponentFrame('Suspense');

    case REACT_SUSPENSE_LIST_TYPE:
      return describeBuiltInComponentFrame('SuspenseList');
  }

  if (typeof type === 'object') {
    switch (type.$$typeof) {
      case REACT_FORWARD_REF_TYPE:
        return describeFunctionComponentFrame(type.render);

      case REACT_MEMO_TYPE:
        // Memo may contain any component type so we recursively resolve it.
        return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);

      case REACT_BLOCK_TYPE:
        return describeFunctionComponentFrame(type._render);

      case REACT_LAZY_TYPE:
        {
          var lazyComponent = type;
          var payload = lazyComponent._payload;
          var init = lazyComponent._init;

          try {
            // Lazy may contain any component type so we recursively resolve it.
            return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);
          } catch (x) {}
        }
    }
  }

  return '';
}

function describeFiber(fiber) {
  var owner =  fiber._debugOwner ? fiber._debugOwner.type : null ;
  var source =  fiber._debugSource ;

  switch (fiber.tag) {
    case HostComponent:
      return describeBuiltInComponentFrame(fiber.type);

    case LazyComponent:
      return describeBuiltInComponentFrame('Lazy');

    case SuspenseComponent:
      return describeBuiltInComponentFrame('Suspense');

    case SuspenseListComponent:
      return describeBuiltInComponentFrame('SuspenseList');

    case FunctionComponent:
    case IndeterminateComponent:
    case SimpleMemoComponent:
      return describeFunctionComponentFrame(fiber.type);

    case ForwardRef:
      return describeFunctionComponentFrame(fiber.type.render);

    case Block:
      return describeFunctionComponentFrame(fiber.type._render);

    case ClassComponent:
      return describeClassComponentFrame(fiber.type);

    default:
      return '';
  }
}

function getStackByFiberInDevAndProd(workInProgress) {
  try {
    var info = '';
    var node = workInProgress;

    do {
      info += describeFiber(node);
      node = node.return;
    } while (node);

    return info;
  } catch (x) {
    return '\nError generating stack: ' + x.message + '\n' + x.stack;
  }
}

function getWrappedName(outerType, innerType, wrapperName) {
  var functionName = innerType.displayName || innerType.name || '';
  return outerType.displayName || (functionName !== '' ? wrapperName + "(" + functionName + ")" : wrapperName);
}

function getContextName(type) {
  return type.displayName || 'Context';
}

function getComponentName(type) {
  if (type == null) {
    // Host root, text node or just invalid type.
    return null;
  }

  {
    if (typeof type.tag === 'number') {
      error('Received an unexpected object in getComponentName(). ' + 'This is likely a bug in React. Please file an issue.');
    }
  }

  if (typeof type === 'function') {
    return type.displayName || type.name || null;
  }

  if (typeof type === 'string') {
    return type;
  }

  switch (type) {
    case REACT_FRAGMENT_TYPE:
      return 'Fragment';

    case REACT_PORTAL_TYPE:
      return 'Portal';

    case REACT_PROFILER_TYPE:
      return 'Profiler';

    case REACT_STRICT_MODE_TYPE:
      return 'StrictMode';

    case REACT_SUSPENSE_TYPE:
      return 'Suspense';

    case REACT_SUSPENSE_LIST_TYPE:
      return 'SuspenseList';
  }

  if (typeof type === 'object') {
    switch (type.$$typeof) {
      case REACT_CONTEXT_TYPE:
        var context = type;
        return getContextName(context) + '.Consumer';

      case REACT_PROVIDER_TYPE:
        var provider = type;
        return getContextName(provider._context) + '.Provider';

      case REACT_FORWARD_REF_TYPE:
        return getWrappedName(type, type.render, 'ForwardRef');

      case REACT_MEMO_TYPE:
        return getComponentName(type.type);

      case REACT_BLOCK_TYPE:
        return getComponentName(type._render);

      case REACT_LAZY_TYPE:
        {
          var lazyComponent = type;
          var payload = lazyComponent._payload;
          var init = lazyComponent._init;

          try {
            return getComponentName(init(payload));
          } catch (x) {
            return null;
          }
        }
    }
  }

  return null;
}

var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
var current = null;
var isRendering = false;
function getCurrentFiberOwnerNameInDevOrNull() {
  {
    if (current === null) {
      return null;
    }

    var owner = current._debugOwner;

    if (owner !== null && typeof owner !== 'undefined') {
      return getComponentName(owner.type);
    }
  }

  return null;
}

function getCurrentFiberStackInDev() {
  {
    if (current === null) {
      return '';
    } // Safe because if current fiber exists, we are reconciling,
    // and it is guaranteed to be the work-in-progress version.


    return getStackByFiberInDevAndProd(current);
  }
}

function resetCurrentFiber() {
  {
    ReactDebugCurrentFrame.getCurrentStack = null;
    current = null;
    isRendering = false;
  }
}
function setCurrentFiber(fiber) {
  {
    ReactDebugCurrentFrame.getCurrentStack = getCurrentFiberStackInDev;
    current = fiber;
    isRendering = false;
  }
}
function setIsRendering(rendering) {
  {
    isRendering = rendering;
  }
}
function getIsRendering() {
  {
    return isRendering;
  }
}

// Flow does not allow string concatenation of most non-string types. To work
// around this limitation, we use an opaque type that can only be obtained by
// passing the value through getToStringValue first.
function toString(value) {
  return '' + value;
}
function getToStringValue(value) {
  switch (typeof value) {
    case 'boolean':
    case 'number':
    case 'object':
    case 'string':
    case 'undefined':
      return value;

    default:
      // function, symbol are assigned as empty strings
      return '';
  }
}

var hasReadOnlyValue = {
  button: true,
  checkbox: true,
  image: true,
  hidden: true,
  radio: true,
  reset: true,
  submit: true
};
function checkControlledValueProps(tagName, props) {
  {
    if (!(hasReadOnlyValue[props.type] || props.onChange || props.onInput || props.readOnly || props.disabled || props.value == null)) {
      error('You provided a `value` prop to a form field without an ' + '`onChange` handler. This will render a read-only field. If ' + 'the field should be mutable use `defaultValue`. Otherwise, ' + 'set either `onChange` or `readOnly`.');
    }

    if (!(props.onChange || props.readOnly || props.disabled || props.checked == null)) {
      error('You provided a `checked` prop to a form field without an ' + '`onChange` handler. This will render a read-only field. If ' + 'the field should be mutable use `defaultChecked`. Otherwise, ' + 'set either `onChange` or `readOnly`.');
    }
  }
}

function isCheckable(elem) {
  var type = elem.type;
  var nodeName = elem.nodeName;
  return nodeName && nodeName.toLowerCase() === 'input' && (type === 'checkbox' || type === 'radio');
}

function getTracker(node) {
  return node._valueTracker;
}

function detachTracker(node) {
  node._valueTracker = null;
}

function getValueFromNode(node) {
  var value = '';

  if (!node) {
    return value;
  }

  if (isCheckable(node)) {
    value = node.checked ? 'true' : 'false';
  } else {
    value = node.value;
  }

  return value;
}

function trackValueOnNode(node) {
  var valueField = isCheckable(node) ? 'checked' : 'value';
  var descriptor = Object.getOwnPropertyDescriptor(node.constructor.prototype, valueField);
  var currentValue = '' + node[valueField]; // if someone has already defined a value or Safari, then bail
  // and don't track value will cause over reporting of changes,
  // but it's better then a hard failure
  // (needed for certain tests that spyOn input values and Safari)

  if (node.hasOwnProperty(valueField) || typeof descriptor === 'undefined' || typeof descriptor.get !== 'function' || typeof descriptor.set !== 'function') {
    return;
  }

  var get = descriptor.get,
      set = descriptor.set;
  Object.defineProperty(node, valueField, {
    configurable: true,
    get: function () {
      return get.call(this);
    },
    set: function (value) {
      currentValue = '' + value;
      set.call(this, value);
    }
  }); // We could've passed this the first time
  // but it triggers a bug in IE11 and Edge 14/15.
  // Calling defineProperty() again should be equivalent.
  // https://github.com/facebook/react/issues/11768

  Object.defineProperty(node, valueField, {
    enumerable: descriptor.enumerable
  });
  var tracker = {
    getValue: function () {
      return currentValue;
    },
    setValue: function (value) {
      currentValue = '' + value;
    },
    stopTracking: function () {
      detachTracker(node);
      delete node[valueField];
    }
  };
  return tracker;
}

function track(node) {
  if (getTracker(node)) {
    return;
  } // TODO: Once it's just Fiber we can move this to node._wrapperState


  node._valueTracker = trackValueOnNode(node);
}
function updateValueIfChanged(node) {
  if (!node) {
    return false;
  }

  var tracker = getTracker(node); // if there is no tracker at this point it's unlikely
  // that trying again will succeed

  if (!tracker) {
    return true;
  }

  var lastValue = tracker.getValue();
  var nextValue = getValueFromNode(node);

  if (nextValue !== lastValue) {
    tracker.setValue(nextValue);
    return true;
  }

  return false;
}

function getActiveElement(doc) {
  doc = doc || (typeof document !== 'undefined' ? document : undefined);

  if (typeof doc === 'undefined') {
    return null;
  }

  try {
    return doc.activeElement || doc.body;
  } catch (e) {
    return doc.body;
  }
}

var didWarnValueDefaultValue = false;
var didWarnCheckedDefaultChecked = false;
var didWarnControlledToUncontrolled = false;
var didWarnUncontrolledToControlled = false;

function isControlled(props) {
  var usesChecked = props.type === 'checkbox' || props.type === 'radio';
  return usesChecked ? props.checked != null : props.value != null;
}
/**
 * Implements an <input> host component that allows setting these optional
 * props: `checked`, `value`, `defaultChecked`, and `defaultValue`.
 *
 * If `checked` or `value` are not supplied (or null/undefined), user actions
 * that affect the checked state or value will trigger updates to the element.
 *
 * If they are supplied (and not null/undefined), the rendered element will not
 * trigger updates to the element. Instead, the props must change in order for
 * the rendered element to be updated.
 *
 * The rendered element will be initialized as unchecked (or `defaultChecked`)
 * with an empty value (or `defaultValue`).
 *
 * See http://www.w3.org/TR/2012/WD-html5-20121025/the-input-element.html
 */


function getHostProps(element, props) {
  var node = element;
  var checked = props.checked;

  var hostProps = _assign({}, props, {
    defaultChecked: undefined,
    defaultValue: undefined,
    value: undefined,
    checked: checked != null ? checked : node._wrapperState.initialChecked
  });

  return hostProps;
}
function initWrapperState(element, props) {
  {
    checkControlledValueProps('input', props);

    if (props.checked !== undefined && props.defaultChecked !== undefined && !didWarnCheckedDefaultChecked) {
      error('%s contains an input of type %s with both checked and defaultChecked props. ' + 'Input elements must be either controlled or uncontrolled ' + '(specify either the checked prop, or the defaultChecked prop, but not ' + 'both). Decide between using a controlled or uncontrolled input ' + 'element and remove one of these props. More info: ' + 'https://reactjs.org/link/controlled-components', getCurrentFiberOwnerNameInDevOrNull() || 'A component', props.type);

      didWarnCheckedDefaultChecked = true;
    }

    if (props.value !== undefined && props.defaultValue !== undefined && !didWarnValueDefaultValue) {
      error('%s contains an input of type %s with both value and defaultValue props. ' + 'Input elements must be either controlled or uncontrolled ' + '(specify either the value prop, or the defaultValue prop, but not ' + 'both). Decide between using a controlled or uncontrolled input ' + 'element and remove one of these props. More info: ' + 'https://reactjs.org/link/controlled-components', getCurrentFiberOwnerNameInDevOrNull() || 'A component', props.type);

      didWarnValueDefaultValue = true;
    }
  }

  var node = element;
  var defaultValue = props.defaultValue == null ? '' : props.defaultValue;
  node._wrapperState = {
    initialChecked: props.checked != null ? props.checked : props.defaultChecked,
    initialValue: getToStringValue(props.value != null ? props.value : defaultValue),
    controlled: isControlled(props)
  };
}
function updateChecked(element, props) {
  var node = element;
  var checked = props.checked;

  if (checked != null) {
    setValueForProperty(node, 'checked', checked, false);
  }
}
function updateWrapper(element, props) {
  var node = element;

  {
    var controlled = isControlled(props);

    if (!node._wrapperState.controlled && controlled && !didWarnUncontrolledToControlled) {
      error('A component is changing an uncontrolled input to be controlled. ' + 'This is likely caused by the value changing from undefined to ' + 'a defined value, which should not happen. ' + 'Decide between using a controlled or uncontrolled input ' + 'element for the lifetime of the component. More info: https://reactjs.org/link/controlled-components');

      didWarnUncontrolledToControlled = true;
    }

    if (node._wrapperState.controlled && !controlled && !didWarnControlledToUncontrolled) {
      error('A component is changing a controlled input to be uncontrolled. ' + 'This is likely caused by the value changing from a defined to ' + 'undefined, which should not happen. ' + 'Decide between using a controlled or uncontrolled input ' + 'element for the lifetime of the component. More info: https://reactjs.org/link/controlled-components');

      didWarnControlledToUncontrolled = true;
    }
  }

  updateChecked(element, props);
  var value = getToStringValue(props.value);
  var type = props.type;

  if (value != null) {
    if (type === 'number') {
      if (value === 0 && node.value === '' || // We explicitly want to coerce to number here if possible.
      // eslint-disable-next-line
      node.value != value) {
        node.value = toString(value);
      }
    } else if (node.value !== toString(value)) {
      node.value = toString(value);
    }
  } else if (type === 'submit' || type === 'reset') {
    // Submit/reset inputs need the attribute removed completely to avoid
    // blank-text buttons.
    node.removeAttribute('value');
    return;
  }

  {
    // When syncing the value attribute, the value comes from a cascade of
    // properties:
    //  1. The value React property
    //  2. The defaultValue React property
    //  3. Otherwise there should be no change
    if (props.hasOwnProperty('value')) {
      setDefaultValue(node, props.type, value);
    } else if (props.hasOwnProperty('defaultValue')) {
      setDefaultValue(node, props.type, getToStringValue(props.defaultValue));
    }
  }

  {
    // When syncing the checked attribute, it only changes when it needs
    // to be removed, such as transitioning from a checkbox into a text input
    if (props.checked == null && props.defaultChecked != null) {
      node.defaultChecked = !!props.defaultChecked;
    }
  }
}
function postMountWrapper(element, props, isHydrating) {
  var node = element; // Do not assign value if it is already set. This prevents user text input
  // from being lost during SSR hydration.

  if (props.hasOwnProperty('value') || props.hasOwnProperty('defaultValue')) {
    var type = props.type;
    var isButton = type === 'submit' || type === 'reset'; // Avoid setting value attribute on submit/reset inputs as it overrides the
    // default value provided by the browser. See: #12872

    if (isButton && (props.value === undefined || props.value === null)) {
      return;
    }

    var initialValue = toString(node._wrapperState.initialValue); // Do not assign value if it is already set. This prevents user text input
    // from being lost during SSR hydration.

    if (!isHydrating) {
      {
        // When syncing the value attribute, the value property should use
        // the wrapperState._initialValue property. This uses:
        //
        //   1. The value React property when present
        //   2. The defaultValue React property when present
        //   3. An empty string
        if (initialValue !== node.value) {
          node.value = initialValue;
        }
      }
    }

    {
      // Otherwise, the value attribute is synchronized to the property,
      // so we assign defaultValue to the same thing as the value property
      // assignment step above.
      node.defaultValue = initialValue;
    }
  } // Normally, we'd just do `node.checked = node.checked` upon initial mount, less this bug
  // this is needed to work around a chrome bug where setting defaultChecked
  // will sometimes influence the value of checked (even after detachment).
  // Reference: https://bugs.chromium.org/p/chromium/issues/detail?id=608416
  // We need to temporarily unset name to avoid disrupting radio button groups.


  var name = node.name;

  if (name !== '') {
    node.name = '';
  }

  {
    // When syncing the checked attribute, both the checked property and
    // attribute are assigned at the same time using defaultChecked. This uses:
    //
    //   1. The checked React property when present
    //   2. The defaultChecked React property when present
    //   3. Otherwise, false
    node.defaultChecked = !node.defaultChecked;
    node.defaultChecked = !!node._wrapperState.initialChecked;
  }

  if (name !== '') {
    node.name = name;
  }
}
function restoreControlledState(element, props) {
  var node = element;
  updateWrapper(node, props);
  updateNamedCousins(node, props);
}

function updateNamedCousins(rootNode, props) {
  var name = props.name;

  if (props.type === 'radio' && name != null) {
    var queryRoot = rootNode;

    while (queryRoot.parentNode) {
      queryRoot = queryRoot.parentNode;
    } // If `rootNode.form` was non-null, then we could try `form.elements`,
    // but that sometimes behaves strangely in IE8. We could also try using
    // `form.getElementsByName`, but that will only return direct children
    // and won't include inputs that use the HTML5 `form=` attribute. Since
    // the input might not even be in a form. It might not even be in the
    // document. Let's just use the local `querySelectorAll` to ensure we don't
    // miss anything.


    var group = queryRoot.querySelectorAll('input[name=' + JSON.stringify('' + name) + '][type="radio"]');

    for (var i = 0; i < group.length; i++) {
      var otherNode = group[i];

      if (otherNode === rootNode || otherNode.form !== rootNode.form) {
        continue;
      } // This will throw if radio buttons rendered by different copies of React
      // and the same name are rendered into the same form (same as #1939).
      // That's probably okay; we don't support it just as we don't support
      // mixing React radio buttons with non-React ones.


      var otherProps = getFiberCurrentPropsFromNode(otherNode);

      if (!otherProps) {
        {
          throw Error( "ReactDOMInput: Mixing React and non-React radio inputs with the same `name` is not supported." );
        }
      } // We need update the tracked value on the named cousin since the value
      // was changed but the input saw no event or value set


      updateValueIfChanged(otherNode); // If this is a controlled radio button group, forcing the input that
      // was previously checked to update will cause it to be come re-checked
      // as appropriate.

      updateWrapper(otherNode, otherProps);
    }
  }
} // In Chrome, assigning defaultValue to certain input types triggers input validation.
// For number inputs, the display value loses trailing decimal points. For email inputs,
// Chrome raises "The specified value <x> is not a valid email address".
//
// Here we check to see if the defaultValue has actually changed, avoiding these problems
// when the user is inputting text
//
// https://github.com/facebook/react/issues/7253


function setDefaultValue(node, type, value) {
  if ( // Focused number inputs synchronize on blur. See ChangeEventPlugin.js
  type !== 'number' || getActiveElement(node.ownerDocument) !== node) {
    if (value == null) {
      node.defaultValue = toString(node._wrapperState.initialValue);
    } else if (node.defaultValue !== toString(value)) {
      node.defaultValue = toString(value);
    }
  }
}

var didWarnSelectedSetOnOption = false;
var didWarnInvalidChild = false;

function flattenChildren(children) {
  var content = ''; // Flatten children. We'll warn if they are invalid
  // during validateProps() which runs for hydration too.
  // Note that this would throw on non-element objects.
  // Elements are stringified (which is normally irrelevant
  // but matters for <fbt>).

  React.Children.forEach(children, function (child) {
    if (child == null) {
      return;
    }

    content += child; // Note: we don't warn about invalid children here.
    // Instead, this is done separately below so that
    // it happens during the hydration code path too.
  });
  return content;
}
/**
 * Implements an <option> host component that warns when `selected` is set.
 */


function validateProps(element, props) {
  {
    // This mirrors the code path above, but runs for hydration too.
    // Warn about invalid children here so that client and hydration are consistent.
    // TODO: this seems like it could cause a DEV-only throw for hydration
    // if children contains a non-element object. We should try to avoid that.
    if (typeof props.children === 'object' && props.children !== null) {
      React.Children.forEach(props.children, function (child) {
        if (child == null) {
          return;
        }

        if (typeof child === 'string' || typeof child === 'number') {
          return;
        }

        if (typeof child.type !== 'string') {
          return;
        }

        if (!didWarnInvalidChild) {
          didWarnInvalidChild = true;

          error('Only strings and numbers are supported as <option> children.');
        }
      });
    } // TODO: Remove support for `selected` in <option>.


    if (props.selected != null && !didWarnSelectedSetOnOption) {
      error('Use the `defaultValue` or `value` props on <select> instead of ' + 'setting `selected` on <option>.');

      didWarnSelectedSetOnOption = true;
    }
  }
}
function postMountWrapper$1(element, props) {
  // value="" should make a value attribute (#6219)
  if (props.value != null) {
    element.setAttribute('value', toString(getToStringValue(props.value)));
  }
}
function getHostProps$1(element, props) {
  var hostProps = _assign({
    children: undefined
  }, props);

  var content = flattenChildren(props.children);

  if (content) {
    hostProps.children = content;
  }

  return hostProps;
}

var didWarnValueDefaultValue$1;

{
  didWarnValueDefaultValue$1 = false;
}

function getDeclarationErrorAddendum() {
  var ownerName = getCurrentFiberOwnerNameInDevOrNull();

  if (ownerName) {
    return '\n\nCheck the render method of `' + ownerName + '`.';
  }

  return '';
}

var valuePropNames = ['value', 'defaultValue'];
/**
 * Validation function for `value` and `defaultValue`.
 */

function checkSelectPropTypes(props) {
  {
    checkControlledValueProps('select', props);

    for (var i = 0; i < valuePropNames.length; i++) {
      var propName = valuePropNames[i];

      if (props[propName] == null) {
        continue;
      }

      var isArray = Array.isArray(props[propName]);

      if (props.multiple && !isArray) {
        error('The `%s` prop supplied to <select> must be an array if ' + '`multiple` is true.%s', propName, getDeclarationErrorAddendum());
      } else if (!props.multiple && isArray) {
        error('The `%s` prop supplied to <select> must be a scalar ' + 'value if `multiple` is false.%s', propName, getDeclarationErrorAddendum());
      }
    }
  }
}

function updateOptions(node, multiple, propValue, setDefaultSelected) {
  var options = node.options;

  if (multiple) {
    var selectedValues = propValue;
    var selectedValue = {};

    for (var i = 0; i < selectedValues.length; i++) {
      // Prefix to avoid chaos with special keys.
      selectedValue['$' + selectedValues[i]] = true;
    }

    for (var _i = 0; _i < options.length; _i++) {
      var selected = selectedValue.hasOwnProperty('$' + options[_i].value);

      if (options[_i].selected !== selected) {
        options[_i].selected = selected;
      }

      if (selected && setDefaultSelected) {
        options[_i].defaultSelected = true;
      }
    }
  } else {
    // Do not set `select.value` as exact behavior isn't consistent across all
    // browsers for all cases.
    var _selectedValue = toString(getToStringValue(propValue));

    var defaultSelected = null;

    for (var _i2 = 0; _i2 < options.length; _i2++) {
      if (options[_i2].value === _selectedValue) {
        options[_i2].selected = true;

        if (setDefaultSelected) {
          options[_i2].defaultSelected = true;
        }

        return;
      }

      if (defaultSelected === null && !options[_i2].disabled) {
        defaultSelected = options[_i2];
      }
    }

    if (defaultSelected !== null) {
      defaultSelected.selected = true;
    }
  }
}
/**
 * Implements a <select> host component that allows optionally setting the
 * props `value` and `defaultValue`. If `multiple` is false, the prop must be a
 * stringable. If `multiple` is true, the prop must be an array of stringables.
 *
 * If `value` is not supplied (or null/undefined), user actions that change the
 * selected option will trigger updates to the rendered options.
 *
 * If it is supplied (and not null/undefined), the rendered options will not
 * update in response to user actions. Instead, the `value` prop must change in
 * order for the rendered options to update.
 *
 * If `defaultValue` is provided, any options with the supplied values will be
 * selected.
 */


function getHostProps$2(element, props) {
  return _assign({}, props, {
    value: undefined
  });
}
function initWrapperState$1(element, props) {
  var node = element;

  {
    checkSelectPropTypes(props);
  }

  node._wrapperState = {
    wasMultiple: !!props.multiple
  };

  {
    if (props.value !== undefined && props.defaultValue !== undefined && !didWarnValueDefaultValue$1) {
      error('Select elements must be either controlled or uncontrolled ' + '(specify either the value prop, or the defaultValue prop, but not ' + 'both). Decide between using a controlled or uncontrolled select ' + 'element and remove one of these props. More info: ' + 'https://reactjs.org/link/controlled-components');

      didWarnValueDefaultValue$1 = true;
    }
  }
}
function postMountWrapper$2(element, props) {
  var node = element;
  node.multiple = !!props.multiple;
  var value = props.value;

  if (value != null) {
    updateOptions(node, !!props.multiple, value, false);
  } else if (props.defaultValue != null) {
    updateOptions(node, !!props.multiple, props.defaultValue, true);
  }
}
function postUpdateWrapper(element, props) {
  var node = element;
  var wasMultiple = node._wrapperState.wasMultiple;
  node._wrapperState.wasMultiple = !!props.multiple;
  var value = props.value;

  if (value != null) {
    updateOptions(node, !!props.multiple, value, false);
  } else if (wasMultiple !== !!props.multiple) {
    // For simplicity, reapply `defaultValue` if `multiple` is toggled.
    if (props.defaultValue != null) {
      updateOptions(node, !!props.multiple, props.defaultValue, true);
    } else {
      // Revert the select back to its default unselected state.
      updateOptions(node, !!props.multiple, props.multiple ? [] : '', false);
    }
  }
}
function restoreControlledState$1(element, props) {
  var node = element;
  var value = props.value;

  if (value != null) {
    updateOptions(node, !!props.multiple, value, false);
  }
}

var didWarnValDefaultVal = false;

/**
 * Implements a <textarea> host component that allows setting `value`, and
 * `defaultValue`. This differs from the traditional DOM API because value is
 * usually set as PCDATA children.
 *
 * If `value` is not supplied (or null/undefined), user actions that affect the
 * value will trigger updates to the element.
 *
 * If `value` is supplied (and not null/undefined), the rendered element will
 * not trigger updates to the element. Instead, the `value` prop must change in
 * order for the rendered element to be updated.
 *
 * The rendered element will be initialized with an empty value, the prop
 * `defaultValue` if specified, or the children content (deprecated).
 */
function getHostProps$3(element, props) {
  var node = element;

  if (!(props.dangerouslySetInnerHTML == null)) {
    {
      throw Error( "`dangerouslySetInnerHTML` does not make sense on <textarea>." );
    }
  } // Always set children to the same thing. In IE9, the selection range will
  // get reset if `textContent` is mutated.  We could add a check in setTextContent
  // to only set the value if/when the value differs from the node value (which would
  // completely solve this IE9 bug), but Sebastian+Sophie seemed to like this
  // solution. The value can be a boolean or object so that's why it's forced
  // to be a string.


  var hostProps = _assign({}, props, {
    value: undefined,
    defaultValue: undefined,
    children: toString(node._wrapperState.initialValue)
  });

  return hostProps;
}
function initWrapperState$2(element, props) {
  var node = element;

  {
    checkControlledValueProps('textarea', props);

    if (props.value !== undefined && props.defaultValue !== undefined && !didWarnValDefaultVal) {
      error('%s contains a textarea with both value and defaultValue props. ' + 'Textarea elements must be either controlled or uncontrolled ' + '(specify either the value prop, or the defaultValue prop, but not ' + 'both). Decide between using a controlled or uncontrolled textarea ' + 'and remove one of these props. More info: ' + 'https://reactjs.org/link/controlled-components', getCurrentFiberOwnerNameInDevOrNull() || 'A component');

      didWarnValDefaultVal = true;
    }
  }

  var initialValue = props.value; // Only bother fetching default value if we're going to use it

  if (initialValue == null) {
    var children = props.children,
        defaultValue = props.defaultValue;

    if (children != null) {
      {
        error('Use the `defaultValue` or `value` props instead of setting ' + 'children on <textarea>.');
      }

      {
        if (!(defaultValue == null)) {
          {
            throw Error( "If you supply `defaultValue` on a <textarea>, do not pass children." );
          }
        }

        if (Array.isArray(children)) {
          if (!(children.length <= 1)) {
            {
              throw Error( "<textarea> can only have at most one child." );
            }
          }

          children = children[0];
        }

        defaultValue = children;
      }
    }

    if (defaultValue == null) {
      defaultValue = '';
    }

    initialValue = defaultValue;
  }

  node._wrapperState = {
    initialValue: getToStringValue(initialValue)
  };
}
function updateWrapper$1(element, props) {
  var node = element;
  var value = getToStringValue(props.value);
  var defaultValue = getToStringValue(props.defaultValue);

  if (value != null) {
    // Cast `value` to a string to ensure the value is set correctly. While
    // browsers typically do this as necessary, jsdom doesn't.
    var newValue = toString(value); // To avoid side effects (such as losing text selection), only set value if changed

    if (newValue !== node.value) {
      node.value = newValue;
    }

    if (props.defaultValue == null && node.defaultValue !== newValue) {
      node.defaultValue = newValue;
    }
  }

  if (defaultValue != null) {
    node.defaultValue = toString(defaultValue);
  }
}
function postMountWrapper$3(element, props) {
  var node = element; // This is in postMount because we need access to the DOM node, which is not
  // available until after the component has mounted.

  var textContent = node.textContent; // Only set node.value if textContent is equal to the expected
  // initial value. In IE10/IE11 there is a bug where the placeholder attribute
  // will populate textContent as well.
  // https://developer.microsoft.com/microsoft-edge/platform/issues/101525/

  if (textContent === node._wrapperState.initialValue) {
    if (textContent !== '' && textContent !== null) {
      node.value = textContent;
    }
  }
}
function restoreControlledState$2(element, props) {
  // DOM component is still mounted; update
  updateWrapper$1(element, props);
}

var HTML_NAMESPACE = 'http://www.w3.org/1999/xhtml';
var MATH_NAMESPACE = 'http://www.w3.org/1998/Math/MathML';
var SVG_NAMESPACE = 'http://www.w3.org/2000/svg';
var Namespaces = {
  html: HTML_NAMESPACE,
  mathml: MATH_NAMESPACE,
  svg: SVG_NAMESPACE
}; // Assumes there is no parent namespace.

function getIntrinsicNamespace(type) {
  switch (type) {
    case 'svg':
      return SVG_NAMESPACE;

    case 'math':
      return MATH_NAMESPACE;

    default:
      return HTML_NAMESPACE;
  }
}
function getChildNamespace(parentNamespace, type) {
  if (parentNamespace == null || parentNamespace === HTML_NAMESPACE) {
    // No (or default) parent namespace: potential entry point.
    return getIntrinsicNamespace(type);
  }

  if (parentNamespace === SVG_NAMESPACE && type === 'foreignObject') {
    // We're leaving SVG.
    return HTML_NAMESPACE;
  } // By default, pass namespace below.


  return parentNamespace;
}

/* globals MSApp */

/**
 * Create a function which has 'unsafe' privileges (required by windows8 apps)
 */
var createMicrosoftUnsafeLocalFunction = function (func) {
  if (typeof MSApp !== 'undefined' && MSApp.execUnsafeLocalFunction) {
    return function (arg0, arg1, arg2, arg3) {
      MSApp.execUnsafeLocalFunction(function () {
        return func(arg0, arg1, arg2, arg3);
      });
    };
  } else {
    return func;
  }
};

var reusableSVGContainer;
/**
 * Set the innerHTML property of a node
 *
 * @param {DOMElement} node
 * @param {string} html
 * @internal
 */

var setInnerHTML = createMicrosoftUnsafeLocalFunction(function (node, html) {
  if (node.namespaceURI === Namespaces.svg) {

    if (!('innerHTML' in node)) {
      // IE does not have innerHTML for SVG nodes, so instead we inject the
      // new markup in a temp node and then move the child nodes across into
      // the target node
      reusableSVGContainer = reusableSVGContainer || document.createElement('div');
      reusableSVGContainer.innerHTML = '<svg>' + html.valueOf().toString() + '</svg>';
      var svgNode = reusableSVGContainer.firstChild;

      while (node.firstChild) {
        node.removeChild(node.firstChild);
      }

      while (svgNode.firstChild) {
        node.appendChild(svgNode.firstChild);
      }

      return;
    }
  }

  node.innerHTML = html;
});

/**
 * HTML nodeType values that represent the type of the node
 */
var ELEMENT_NODE = 1;
var TEXT_NODE = 3;
var COMMENT_NODE = 8;
var DOCUMENT_NODE = 9;
var DOCUMENT_FRAGMENT_NODE = 11;

/**
 * Set the textContent property of a node. For text updates, it's faster
 * to set the `nodeValue` of the Text node directly instead of using
 * `.textContent` which will remove the existing node and create a new one.
 *
 * @param {DOMElement} node
 * @param {string} text
 * @internal
 */

var setTextContent = function (node, text) {
  if (text) {
    var firstChild = node.firstChild;

    if (firstChild && firstChild === node.lastChild && firstChild.nodeType === TEXT_NODE) {
      firstChild.nodeValue = text;
      return;
    }
  }

  node.textContent = text;
};

// List derived from Gecko source code:
// https://github.com/mozilla/gecko-dev/blob/4e638efc71/layout/style/test/property_database.js
var shorthandToLonghand = {
  animation: ['animationDelay', 'animationDirection', 'animationDuration', 'animationFillMode', 'animationIterationCount', 'animationName', 'animationPlayState', 'animationTimingFunction'],
  background: ['backgroundAttachment', 'backgroundClip', 'backgroundColor', 'backgroundImage', 'backgroundOrigin', 'backgroundPositionX', 'backgroundPositionY', 'backgroundRepeat', 'backgroundSize'],
  backgroundPosition: ['backgroundPositionX', 'backgroundPositionY'],
  border: ['borderBottomColor', 'borderBottomStyle', 'borderBottomWidth', 'borderImageOutset', 'borderImageRepeat', 'borderImageSlice', 'borderImageSource', 'borderImageWidth', 'borderLeftColor', 'borderLeftStyle', 'borderLeftWidth', 'borderRightColor', 'borderRightStyle', 'borderRightWidth', 'borderTopColor', 'borderTopStyle', 'borderTopWidth'],
  borderBlockEnd: ['borderBlockEndColor', 'borderBlockEndStyle', 'borderBlockEndWidth'],
  borderBlockStart: ['borderBlockStartColor', 'borderBlockStartStyle', 'borderBlockStartWidth'],
  borderBottom: ['borderBottomColor', 'borderBottomStyle', 'borderBottomWidth'],
  borderColor: ['borderBottomColor', 'borderLeftColor', 'borderRightColor', 'borderTopColor'],
  borderImage: ['borderImageOutset', 'borderImageRepeat', 'borderImageSlice', 'borderImageSource', 'borderImageWidth'],
  borderInlineEnd: ['borderInlineEndColor', 'borderInlineEndStyle', 'borderInlineEndWidth'],
  borderInlineStart: ['borderInlineStartColor', 'borderInlineStartStyle', 'borderInlineStartWidth'],
  borderLeft: ['borderLeftColor', 'borderLeftStyle', 'borderLeftWidth'],
  borderRadius: ['borderBottomLeftRadius', 'borderBottomRightRadius', 'borderTopLeftRadius', 'borderTopRightRadius'],
  borderRight: ['borderRightColor', 'borderRightStyle', 'borderRightWidth'],
  borderStyle: ['borderBottomStyle', 'borderLeftStyle', 'borderRightStyle', 'borderTopStyle'],
  borderTop: ['borderTopColor', 'borderTopStyle', 'borderTopWidth'],
  borderWidth: ['borderBottomWidth', 'borderLeftWidth', 'borderRightWidth', 'borderTopWidth'],
  columnRule: ['columnRuleColor', 'columnRuleStyle', 'columnRuleWidth'],
  columns: ['columnCount', 'columnWidth'],
  flex: ['flexBasis', 'flexGrow', 'flexShrink'],
  flexFlow: ['flexDirection', 'flexWrap'],
  font: ['fontFamily', 'fontFeatureSettings', 'fontKerning', 'fontLanguageOverride', 'fontSize', 'fontSizeAdjust', 'fontStretch', 'fontStyle', 'fontVariant', 'fontVariantAlternates', 'fontVariantCaps', 'fontVariantEastAsian', 'fontVariantLigatures', 'fontVariantNumeric', 'fontVariantPosition', 'fontWeight', 'lineHeight'],
  fontVariant: ['fontVariantAlternates', 'fontVariantCaps', 'fontVariantEastAsian', 'fontVariantLigatures', 'fontVariantNumeric', 'fontVariantPosition'],
  gap: ['columnGap', 'rowGap'],
  grid: ['gridAutoColumns', 'gridAutoFlow', 'gridAutoRows', 'gridTemplateAreas', 'gridTemplateColumns', 'gridTemplateRows'],
  gridArea: ['gridColumnEnd', 'gridColumnStart', 'gridRowEnd', 'gridRowStart'],
  gridColumn: ['gridColumnEnd', 'gridColumnStart'],
  gridColumnGap: ['columnGap'],
  gridGap: ['columnGap', 'rowGap'],
  gridRow: ['gridRowEnd', 'gridRowStart'],
  gridRowGap: ['rowGap'],
  gridTemplate: ['gridTemplateAreas', 'gridTemplateColumns', 'gridTemplateRows'],
  listStyle: ['listStyleImage', 'listStylePosition', 'listStyleType'],
  margin: ['marginBottom', 'marginLeft', 'marginRight', 'marginTop'],
  marker: ['markerEnd', 'markerMid', 'markerStart'],
  mask: ['maskClip', 'maskComposite', 'maskImage', 'maskMode', 'maskOrigin', 'maskPositionX', 'maskPositionY', 'maskRepeat', 'maskSize'],
  maskPosition: ['maskPositionX', 'maskPositionY'],
  outline: ['outlineColor', 'outlineStyle', 'outlineWidth'],
  overflow: ['overflowX', 'overflowY'],
  padding: ['paddingBottom', 'paddingLeft', 'paddingRight', 'paddingTop'],
  placeContent: ['alignContent', 'justifyContent'],
  placeItems: ['alignItems', 'justifyItems'],
  placeSelf: ['alignSelf', 'justifySelf'],
  textDecoration: ['textDecorationColor', 'textDecorationLine', 'textDecorationStyle'],
  textEmphasis: ['textEmphasisColor', 'textEmphasisStyle'],
  transition: ['transitionDelay', 'transitionDuration', 'transitionProperty', 'transitionTimingFunction'],
  wordWrap: ['overflowWrap']
};

/**
 * CSS properties which accept numbers but are not in units of "px".
 */
var isUnitlessNumber = {
  animationIterationCount: true,
  borderImageOutset: true,
  borderImageSlice: true,
  borderImageWidth: true,
  boxFlex: true,
  boxFlexGroup: true,
  boxOrdinalGroup: true,
  columnCount: true,
  columns: true,
  flex: true,
  flexGrow: true,
  flexPositive: true,
  flexShrink: true,
  flexNegative: true,
  flexOrder: true,
  gridArea: true,
  gridRow: true,
  gridRowEnd: true,
  gridRowSpan: true,
  gridRowStart: true,
  gridColumn: true,
  gridColumnEnd: true,
  gridColumnSpan: true,
  gridColumnStart: true,
  fontWeight: true,
  lineClamp: true,
  lineHeight: true,
  opacity: true,
  order: true,
  orphans: true,
  tabSize: true,
  widows: true,
  zIndex: true,
  zoom: true,
  // SVG-related properties
  fillOpacity: true,
  floodOpacity: true,
  stopOpacity: true,
  strokeDasharray: true,
  strokeDashoffset: true,
  strokeMiterlimit: true,
  strokeOpacity: true,
  strokeWidth: true
};
/**
 * @param {string} prefix vendor-specific prefix, eg: Webkit
 * @param {string} key style name, eg: transitionDuration
 * @return {string} style name prefixed with `prefix`, properly camelCased, eg:
 * WebkitTransitionDuration
 */

function prefixKey(prefix, key) {
  return prefix + key.charAt(0).toUpperCase() + key.substring(1);
}
/**
 * Support style names that may come passed in prefixed by adding permutations
 * of vendor prefixes.
 */


var prefixes = ['Webkit', 'ms', 'Moz', 'O']; // Using Object.keys here, or else the vanilla for-in loop makes IE8 go into an
// infinite loop, because it iterates over the newly added props too.

Object.keys(isUnitlessNumber).forEach(function (prop) {
  prefixes.forEach(function (prefix) {
    isUnitlessNumber[prefixKey(prefix, prop)] = isUnitlessNumber[prop];
  });
});

/**
 * Convert a value into the proper css writable value. The style name `name`
 * should be logical (no hyphens), as specified
 * in `CSSProperty.isUnitlessNumber`.
 *
 * @param {string} name CSS property name such as `topMargin`.
 * @param {*} value CSS property value such as `10px`.
 * @return {string} Normalized style value with dimensions applied.
 */

function dangerousStyleValue(name, value, isCustomProperty) {
  // Note that we've removed escapeTextForBrowser() calls here since the
  // whole string will be escaped when the attribute is injected into
  // the markup. If you provide unsafe user data here they can inject
  // arbitrary CSS which may be problematic (I couldn't repro this):
  // https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet
  // http://www.thespanner.co.uk/2007/11/26/ultimate-xss-css-injection/
  // This is not an XSS hole but instead a potential CSS injection issue
  // which has lead to a greater discussion about how we're going to
  // trust URLs moving forward. See #2115901
  var isEmpty = value == null || typeof value === 'boolean' || value === '';

  if (isEmpty) {
    return '';
  }

  if (!isCustomProperty && typeof value === 'number' && value !== 0 && !(isUnitlessNumber.hasOwnProperty(name) && isUnitlessNumber[name])) {
    return value + 'px'; // Presumes implicit 'px' suffix for unitless numbers
  }

  return ('' + value).trim();
}

var uppercasePattern = /([A-Z])/g;
var msPattern = /^ms-/;
/**
 * Hyphenates a camelcased CSS property name, for example:
 *
 *   > hyphenateStyleName('backgroundColor')
 *   < "background-color"
 *   > hyphenateStyleName('MozTransition')
 *   < "-moz-transition"
 *   > hyphenateStyleName('msTransition')
 *   < "-ms-transition"
 *
 * As Modernizr suggests (http://modernizr.com/docs/#prefixed), an `ms` prefix
 * is converted to `-ms-`.
 */

function hyphenateStyleName(name) {
  return name.replace(uppercasePattern, '-$1').toLowerCase().replace(msPattern, '-ms-');
}

var warnValidStyle = function () {};

{
  // 'msTransform' is correct, but the other prefixes should be capitalized
  var badVendoredStyleNamePattern = /^(?:webkit|moz|o)[A-Z]/;
  var msPattern$1 = /^-ms-/;
  var hyphenPattern = /-(.)/g; // style values shouldn't contain a semicolon

  var badStyleValueWithSemicolonPattern = /;\s*$/;
  var warnedStyleNames = {};
  var warnedStyleValues = {};
  var warnedForNaNValue = false;
  var warnedForInfinityValue = false;

  var camelize = function (string) {
    return string.replace(hyphenPattern, function (_, character) {
      return character.toUpperCase();
    });
  };

  var warnHyphenatedStyleName = function (name) {
    if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {
      return;
    }

    warnedStyleNames[name] = true;

    error('Unsupported style property %s. Did you mean %s?', name, // As Andi Smith suggests
    // (http://www.andismith.com/blog/2012/02/modernizr-prefixed/), an `-ms` prefix
    // is converted to lowercase `ms`.
    camelize(name.replace(msPattern$1, 'ms-')));
  };

  var warnBadVendoredStyleName = function (name) {
    if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {
      return;
    }

    warnedStyleNames[name] = true;

    error('Unsupported vendor-prefixed style property %s. Did you mean %s?', name, name.charAt(0).toUpperCase() + name.slice(1));
  };

  var warnStyleValueWithSemicolon = function (name, value) {
    if (warnedStyleValues.hasOwnProperty(value) && warnedStyleValues[value]) {
      return;
    }

    warnedStyleValues[value] = true;

    error("Style property values shouldn't contain a semicolon. " + 'Try "%s: %s" instead.', name, value.replace(badStyleValueWithSemicolonPattern, ''));
  };

  var warnStyleValueIsNaN = function (name, value) {
    if (warnedForNaNValue) {
      return;
    }

    warnedForNaNValue = true;

    error('`NaN` is an invalid value for the `%s` css style property.', name);
  };

  var warnStyleValueIsInfinity = function (name, value) {
    if (warnedForInfinityValue) {
      return;
    }

    warnedForInfinityValue = true;

    error('`Infinity` is an invalid value for the `%s` css style property.', name);
  };

  warnValidStyle = function (name, value) {
    if (name.indexOf('-') > -1) {
      warnHyphenatedStyleName(name);
    } else if (badVendoredStyleNamePattern.test(name)) {
      warnBadVendoredStyleName(name);
    } else if (badStyleValueWithSemicolonPattern.test(value)) {
      warnStyleValueWithSemicolon(name, value);
    }

    if (typeof value === 'number') {
      if (isNaN(value)) {
        warnStyleValueIsNaN(name, value);
      } else if (!isFinite(value)) {
        warnStyleValueIsInfinity(name, value);
      }
    }
  };
}

var warnValidStyle$1 = warnValidStyle;

/**
 * Operations for dealing with CSS properties.
 */

/**
 * This creates a string that is expected to be equivalent to the style
 * attribute generated by server-side rendering. It by-passes warnings and
 * security checks so it's not safe to use this value for anything other than
 * comparison. It is only used in DEV for SSR validation.
 */

function createDangerousStringForStyles(styles) {
  {
    var serialized = '';
    var delimiter = '';

    for (var styleName in styles) {
      if (!styles.hasOwnProperty(styleName)) {
        continue;
      }

      var styleValue = styles[styleName];

      if (styleValue != null) {
        var isCustomProperty = styleName.indexOf('--') === 0;
        serialized += delimiter + (isCustomProperty ? styleName : hyphenateStyleName(styleName)) + ':';
        serialized += dangerousStyleValue(styleName, styleValue, isCustomProperty);
        delimiter = ';';
      }
    }

    return serialized || null;
  }
}
/**
 * Sets the value for multiple styles on a node.  If a value is specified as
 * '' (empty string), the corresponding style property will be unset.
 *
 * @param {DOMElement} node
 * @param {object} styles
 */

function setValueForStyles(node, styles) {
  var style = node.style;

  for (var styleName in styles) {
    if (!styles.hasOwnProperty(styleName)) {
      continue;
    }

    var isCustomProperty = styleName.indexOf('--') === 0;

    {
      if (!isCustomProperty) {
        warnValidStyle$1(styleName, styles[styleName]);
      }
    }

    var styleValue = dangerousStyleValue(styleName, styles[styleName], isCustomProperty);

    if (styleName === 'float') {
      styleName = 'cssFloat';
    }

    if (isCustomProperty) {
      style.setProperty(styleName, styleValue);
    } else {
      style[styleName] = styleValue;
    }
  }
}

function isValueEmpty(value) {
  return value == null || typeof value === 'boolean' || value === '';
}
/**
 * Given {color: 'red', overflow: 'hidden'} returns {
 *   color: 'color',
 *   overflowX: 'overflow',
 *   overflowY: 'overflow',
 * }. This can be read as "the overflowY property was set by the overflow
 * shorthand". That is, the values are the property that each was derived from.
 */


function expandShorthandMap(styles) {
  var expanded = {};

  for (var key in styles) {
    var longhands = shorthandToLonghand[key] || [key];

    for (var i = 0; i < longhands.length; i++) {
      expanded[longhands[i]] = key;
    }
  }

  return expanded;
}
/**
 * When mixing shorthand and longhand property names, we warn during updates if
 * we expect an incorrect result to occur. In particular, we warn for:
 *
 * Updating a shorthand property (longhand gets overwritten):
 *   {font: 'foo', fontVariant: 'bar'} -> {font: 'baz', fontVariant: 'bar'}
 *   becomes .style.font = 'baz'
 * Removing a shorthand property (longhand gets lost too):
 *   {font: 'foo', fontVariant: 'bar'} -> {fontVariant: 'bar'}
 *   becomes .style.font = ''
 * Removing a longhand property (should revert to shorthand; doesn't):
 *   {font: 'foo', fontVariant: 'bar'} -> {font: 'foo'}
 *   becomes .style.fontVariant = ''
 */


function validateShorthandPropertyCollisionInDev(styleUpdates, nextStyles) {
  {
    if (!nextStyles) {
      return;
    }

    var expandedUpdates = expandShorthandMap(styleUpdates);
    var expandedStyles = expandShorthandMap(nextStyles);
    var warnedAbout = {};

    for (var key in expandedUpdates) {
      var originalKey = expandedUpdates[key];
      var correctOriginalKey = expandedStyles[key];

      if (correctOriginalKey && originalKey !== correctOriginalKey) {
        var warningKey = originalKey + ',' + correctOriginalKey;

        if (warnedAbout[warningKey]) {
          continue;
        }

        warnedAbout[warningKey] = true;

        error('%s a style property during rerender (%s) when a ' + 'conflicting property is set (%s) can lead to styling bugs. To ' + "avoid this, don't mix shorthand and non-shorthand properties " + 'for the same value; instead, replace the shorthand with ' + 'separate values.', isValueEmpty(styleUpdates[originalKey]) ? 'Removing' : 'Updating', originalKey, correctOriginalKey);
      }
    }
  }
}

// For HTML, certain tags should omit their close tag. We keep a list for
// those special-case tags.
var omittedCloseTags = {
  area: true,
  base: true,
  br: true,
  col: true,
  embed: true,
  hr: true,
  img: true,
  input: true,
  keygen: true,
  link: true,
  meta: true,
  param: true,
  source: true,
  track: true,
  wbr: true // NOTE: menuitem's close tag should be omitted, but that causes problems.

};

// `omittedCloseTags` except that `menuitem` should still have its closing tag.

var voidElementTags = _assign({
  menuitem: true
}, omittedCloseTags);

var HTML = '__html';

function assertValidProps(tag, props) {
  if (!props) {
    return;
  } // Note the use of `==` which checks for null or undefined.


  if (voidElementTags[tag]) {
    if (!(props.children == null && props.dangerouslySetInnerHTML == null)) {
      {
        throw Error( tag + " is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`." );
      }
    }
  }

  if (props.dangerouslySetInnerHTML != null) {
    if (!(props.children == null)) {
      {
        throw Error( "Can only set one of `children` or `props.dangerouslySetInnerHTML`." );
      }
    }

    if (!(typeof props.dangerouslySetInnerHTML === 'object' && HTML in props.dangerouslySetInnerHTML)) {
      {
        throw Error( "`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://reactjs.org/link/dangerously-set-inner-html for more information." );
      }
    }
  }

  {
    if (!props.suppressContentEditableWarning && props.contentEditable && props.children != null) {
      error('A component is `contentEditable` and contains `children` managed by ' + 'React. It is now your responsibility to guarantee that none of ' + 'those nodes are unexpectedly modified or duplicated. This is ' + 'probably not intentional.');
    }
  }

  if (!(props.style == null || typeof props.style === 'object')) {
    {
      throw Error( "The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX." );
    }
  }
}

function isCustomComponent(tagName, props) {
  if (tagName.indexOf('-') === -1) {
    return typeof props.is === 'string';
  }

  switch (tagName) {
    // These are reserved SVG and MathML elements.
    // We don't mind this list too much because we expect it to never grow.
    // The alternative is to track the namespace in a few places which is convoluted.
    // https://w3c.github.io/webcomponents/spec/custom/#custom-elements-core-concepts
    case 'annotation-xml':
    case 'color-profile':
    case 'font-face':
    case 'font-face-src':
    case 'font-face-uri':
    case 'font-face-format':
    case 'font-face-name':
    case 'missing-glyph':
      return false;

    default:
      return true;
  }
}

// When adding attributes to the HTML or SVG allowed attribute list, be sure to
// also add them to this module to ensure casing and incorrect name
// warnings.
var possibleStandardNames = {
  // HTML
  accept: 'accept',
  acceptcharset: 'acceptCharset',
  'accept-charset': 'acceptCharset',
  accesskey: 'accessKey',
  action: 'action',
  allowfullscreen: 'allowFullScreen',
  alt: 'alt',
  as: 'as',
  async: 'async',
  autocapitalize: 'autoCapitalize',
  autocomplete: 'autoComplete',
  autocorrect: 'autoCorrect',
  autofocus: 'autoFocus',
  autoplay: 'autoPlay',
  autosave: 'autoSave',
  capture: 'capture',
  cellpadding: 'cellPadding',
  cellspacing: 'cellSpacing',
  challenge: 'challenge',
  charset: 'charSet',
  checked: 'checked',
  children: 'children',
  cite: 'cite',
  class: 'className',
  classid: 'classID',
  classname: 'className',
  cols: 'cols',
  colspan: 'colSpan',
  content: 'content',
  contenteditable: 'contentEditable',
  contextmenu: 'contextMenu',
  controls: 'controls',
  controlslist: 'controlsList',
  coords: 'coords',
  crossorigin: 'crossOrigin',
  dangerouslysetinnerhtml: 'dangerouslySetInnerHTML',
  data: 'data',
  datetime: 'dateTime',
  default: 'default',
  defaultchecked: 'defaultChecked',
  defaultvalue: 'defaultValue',
  defer: 'defer',
  dir: 'dir',
  disabled: 'disabled',
  disablepictureinpicture: 'disablePictureInPicture',
  disableremoteplayback: 'disableRemotePlayback',
  download: 'download',
  draggable: 'draggable',
  enctype: 'encType',
  enterkeyhint: 'enterKeyHint',
  for: 'htmlFor',
  form: 'form',
  formmethod: 'formMethod',
  formaction: 'formAction',
  formenctype: 'formEncType',
  formnovalidate: 'formNoValidate',
  formtarget: 'formTarget',
  frameborder: 'frameBorder',
  headers: 'headers',
  height: 'height',
  hidden: 'hidden',
  high: 'high',
  href: 'href',
  hreflang: 'hrefLang',
  htmlfor: 'htmlFor',
  httpequiv: 'httpEquiv',
  'http-equiv': 'httpEquiv',
  icon: 'icon',
  id: 'id',
  innerhtml: 'innerHTML',
  inputmode: 'inputMode',
  integrity: 'integrity',
  is: 'is',
  itemid: 'itemID',
  itemprop: 'itemProp',
  itemref: 'itemRef',
  itemscope: 'itemScope',
  itemtype: 'itemType',
  keyparams: 'keyParams',
  keytype: 'keyType',
  kind: 'kind',
  label: 'label',
  lang: 'lang',
  list: 'list',
  loop: 'loop',
  low: 'low',
  manifest: 'manifest',
  marginwidth: 'marginWidth',
  marginheight: 'marginHeight',
  max: 'max',
  maxlength: 'maxLength',
  media: 'media',
  mediagroup: 'mediaGroup',
  method: 'method',
  min: 'min',
  minlength: 'minLength',
  multiple: 'multiple',
  muted: 'muted',
  name: 'name',
  nomodule: 'noModule',
  nonce: 'nonce',
  novalidate: 'noValidate',
  open: 'open',
  optimum: 'optimum',
  pattern: 'pattern',
  placeholder: 'placeholder',
  playsinline: 'playsInline',
  poster: 'poster',
  preload: 'preload',
  profile: 'profile',
  radiogroup: 'radioGroup',
  readonly: 'readOnly',
  referrerpolicy: 'referrerPolicy',
  rel: 'rel',
  required: 'required',
  reversed: 'reversed',
  role: 'role',
  rows: 'rows',
  rowspan: 'rowSpan',
  sandbox: 'sandbox',
  scope: 'scope',
  scoped: 'scoped',
  scrolling: 'scrolling',
  seamless: 'seamless',
  selected: 'selected',
  shape: 'shape',
  size: 'size',
  sizes: 'sizes',
  span: 'span',
  spellcheck: 'spellCheck',
  src: 'src',
  srcdoc: 'srcDoc',
  srclang: 'srcLang',
  srcset: 'srcSet',
  start: 'start',
  step: 'step',
  style: 'style',
  summary: 'summary',
  tabindex: 'tabIndex',
  target: 'target',
  title: 'title',
  type: 'type',
  usemap: 'useMap',
  value: 'value',
  width: 'width',
  wmode: 'wmode',
  wrap: 'wrap',
  // SVG
  about: 'about',
  accentheight: 'accentHeight',
  'accent-height': 'accentHeight',
  accumulate: 'accumulate',
  additive: 'additive',
  alignmentbaseline: 'alignmentBaseline',
  'alignment-baseline': 'alignmentBaseline',
  allowreorder: 'allowReorder',
  alphabetic: 'alphabetic',
  amplitude: 'amplitude',
  arabicform: 'arabicForm',
  'arabic-form': 'arabicForm',
  ascent: 'ascent',
  attributename: 'attributeName',
  attributetype: 'attributeType',
  autoreverse: 'autoReverse',
  azimuth: 'azimuth',
  basefrequency: 'baseFrequency',
  baselineshift: 'baselineShift',
  'baseline-shift': 'baselineShift',
  baseprofile: 'baseProfile',
  bbox: 'bbox',
  begin: 'begin',
  bias: 'bias',
  by: 'by',
  calcmode: 'calcMode',
  capheight: 'capHeight',
  'cap-height': 'capHeight',
  clip: 'clip',
  clippath: 'clipPath',
  'clip-path': 'clipPath',
  clippathunits: 'clipPathUnits',
  cliprule: 'clipRule',
  'clip-rule': 'clipRule',
  color: 'color',
  colorinterpolation: 'colorInterpolation',
  'color-interpolation': 'colorInterpolation',
  colorinterpolationfilters: 'colorInterpolationFilters',
  'color-interpolation-filters': 'colorInterpolationFilters',
  colorprofile: 'colorProfile',
  'color-profile': 'colorProfile',
  colorrendering: 'colorRendering',
  'color-rendering': 'colorRendering',
  contentscripttype: 'contentScriptType',
  contentstyletype: 'contentStyleType',
  cursor: 'cursor',
  cx: 'cx',
  cy: 'cy',
  d: 'd',
  datatype: 'datatype',
  decelerate: 'decelerate',
  descent: 'descent',
  diffuseconstant: 'diffuseConstant',
  direction: 'direction',
  display: 'display',
  divisor: 'divisor',
  dominantbaseline: 'dominantBaseline',
  'dominant-baseline': 'dominantBaseline',
  dur: 'dur',
  dx: 'dx',
  dy: 'dy',
  edgemode: 'edgeMode',
  elevation: 'elevation',
  enablebackground: 'enableBackground',
  'enable-background': 'enableBackground',
  end: 'end',
  exponent: 'exponent',
  externalresourcesrequired: 'externalResourcesRequired',
  fill: 'fill',
  fillopacity: 'fillOpacity',
  'fill-opacity': 'fillOpacity',
  fillrule: 'fillRule',
  'fill-rule': 'fillRule',
  filter: 'filter',
  filterres: 'filterRes',
  filterunits: 'filterUnits',
  floodopacity: 'floodOpacity',
  'flood-opacity': 'floodOpacity',
  floodcolor: 'floodColor',
  'flood-color': 'floodColor',
  focusable: 'focusable',
  fontfamily: 'fontFamily',
  'font-family': 'fontFamily',
  fontsize: 'fontSize',
  'font-size': 'fontSize',
  fontsizeadjust: 'fontSizeAdjust',
  'font-size-adjust': 'fontSizeAdjust',
  fontstretch: 'fontStretch',
  'font-stretch': 'fontStretch',
  fontstyle: 'fontStyle',
  'font-style': 'fontStyle',
  fontvariant: 'fontVariant',
  'font-variant': 'fontVariant',
  fontweight: 'fontWeight',
  'font-weight': 'fontWeight',
  format: 'format',
  from: 'from',
  fx: 'fx',
  fy: 'fy',
  g1: 'g1',
  g2: 'g2',
  glyphname: 'glyphName',
  'glyph-name': 'glyphName',
  glyphorientationhorizontal: 'glyphOrientationHorizontal',
  'glyph-orientation-horizontal': 'glyphOrientationHorizontal',
  glyphorientationvertical: 'glyphOrientationVertical',
  'glyph-orientation-vertical': 'glyphOrientationVertical',
  glyphref: 'glyphRef',
  gradienttransform: 'gradientTransform',
  gradientunits: 'gradientUnits',
  hanging: 'hanging',
  horizadvx: 'horizAdvX',
  'horiz-adv-x': 'horizAdvX',
  horizoriginx: 'horizOriginX',
  'horiz-origin-x': 'horizOriginX',
  ideographic: 'ideographic',
  imagerendering: 'imageRendering',
  'image-rendering': 'imageRendering',
  in2: 'in2',
  in: 'in',
  inlist: 'inlist',
  intercept: 'intercept',
  k1: 'k1',
  k2: 'k2',
  k3: 'k3',
  k4: 'k4',
  k: 'k',
  kernelmatrix: 'kernelMatrix',
  kernelunitlength: 'kernelUnitLength',
  kerning: 'kerning',
  keypoints: 'keyPoints',
  keysplines: 'keySplines',
  keytimes: 'keyTimes',
  lengthadjust: 'lengthAdjust',
  letterspacing: 'letterSpacing',
  'letter-spacing': 'letterSpacing',
  lightingcolor: 'lightingColor',
  'lighting-color': 'lightingColor',
  limitingconeangle: 'limitingConeAngle',
  local: 'local',
  markerend: 'markerEnd',
  'marker-end': 'markerEnd',
  markerheight: 'markerHeight',
  markermid: 'markerMid',
  'marker-mid': 'markerMid',
  markerstart: 'markerStart',
  'marker-start': 'markerStart',
  markerunits: 'markerUnits',
  markerwidth: 'markerWidth',
  mask: 'mask',
  maskcontentunits: 'maskContentUnits',
  maskunits: 'maskUnits',
  mathematical: 'mathematical',
  mode: 'mode',
  numoctaves: 'numOctaves',
  offset: 'offset',
  opacity: 'opacity',
  operator: 'operator',
  order: 'order',
  orient: 'orient',
  orientation: 'orientation',
  origin: 'origin',
  overflow: 'overflow',
  overlineposition: 'overlinePosition',
  'overline-position': 'overlinePosition',
  overlinethickness: 'overlineThickness',
  'overline-thickness': 'overlineThickness',
  paintorder: 'paintOrder',
  'paint-order': 'paintOrder',
  panose1: 'panose1',
  'panose-1': 'panose1',
  pathlength: 'pathLength',
  patterncontentunits: 'patternContentUnits',
  patterntransform: 'patternTransform',
  patternunits: 'patternUnits',
  pointerevents: 'pointerEvents',
  'pointer-events': 'pointerEvents',
  points: 'points',
  pointsatx: 'pointsAtX',
  pointsaty: 'pointsAtY',
  pointsatz: 'pointsAtZ',
  prefix: 'prefix',
  preservealpha: 'preserveAlpha',
  preserveaspectratio: 'preserveAspectRatio',
  primitiveunits: 'primitiveUnits',
  property: 'property',
  r: 'r',
  radius: 'radius',
  refx: 'refX',
  refy: 'refY',
  renderingintent: 'renderingIntent',
  'rendering-intent': 'renderingIntent',
  repeatcount: 'repeatCount',
  repeatdur: 'repeatDur',
  requiredextensions: 'requiredExtensions',
  requiredfeatures: 'requiredFeatures',
  resource: 'resource',
  restart: 'restart',
  result: 'result',
  results: 'results',
  rotate: 'rotate',
  rx: 'rx',
  ry: 'ry',
  scale: 'scale',
  security: 'security',
  seed: 'seed',
  shaperendering: 'shapeRendering',
  'shape-rendering': 'shapeRendering',
  slope: 'slope',
  spacing: 'spacing',
  specularconstant: 'specularConstant',
  specularexponent: 'specularExponent',
  speed: 'speed',
  spreadmethod: 'spreadMethod',
  startoffset: 'startOffset',
  stddeviation: 'stdDeviation',
  stemh: 'stemh',
  stemv: 'stemv',
  stitchtiles: 'stitchTiles',
  stopcolor: 'stopColor',
  'stop-color': 'stopColor',
  stopopacity: 'stopOpacity',
  'stop-opacity': 'stopOpacity',
  strikethroughposition: 'strikethroughPosition',
  'strikethrough-position': 'strikethroughPosition',
  strikethroughthickness: 'strikethroughThickness',
  'strikethrough-thickness': 'strikethroughThickness',
  string: 'string',
  stroke: 'stroke',
  strokedasharray: 'strokeDasharray',
  'stroke-dasharray': 'strokeDasharray',
  strokedashoffset: 'strokeDashoffset',
  'stroke-dashoffset': 'strokeDashoffset',
  strokelinecap: 'strokeLinecap',
  'stroke-linecap': 'strokeLinecap',
  strokelinejoin: 'strokeLinejoin',
  'stroke-linejoin': 'strokeLinejoin',
  strokemiterlimit: 'strokeMiterlimit',
  'stroke-miterlimit': 'strokeMiterlimit',
  strokewidth: 'strokeWidth',
  'stroke-width': 'strokeWidth',
  strokeopacity: 'strokeOpacity',
  'stroke-opacity': 'strokeOpacity',
  suppresscontenteditablewarning: 'suppressContentEditableWarning',
  suppresshydrationwarning: 'suppressHydrationWarning',
  surfacescale: 'surfaceScale',
  systemlanguage: 'systemLanguage',
  tablevalues: 'tableValues',
  targetx: 'targetX',
  targety: 'targetY',
  textanchor: 'textAnchor',
  'text-anchor': 'textAnchor',
  textdecoration: 'textDecoration',
  'text-decoration': 'textDecoration',
  textlength: 'textLength',
  textrendering: 'textRendering',
  'text-rendering': 'textRendering',
  to: 'to',
  transform: 'transform',
  typeof: 'typeof',
  u1: 'u1',
  u2: 'u2',
  underlineposition: 'underlinePosition',
  'underline-position': 'underlinePosition',
  underlinethickness: 'underlineThickness',
  'underline-thickness': 'underlineThickness',
  unicode: 'unicode',
  unicodebidi: 'unicodeBidi',
  'unicode-bidi': 'unicodeBidi',
  unicoderange: 'unicodeRange',
  'unicode-range': 'unicodeRange',
  unitsperem: 'unitsPerEm',
  'units-per-em': 'unitsPerEm',
  unselectable: 'unselectable',
  valphabetic: 'vAlphabetic',
  'v-alphabetic': 'vAlphabetic',
  values: 'values',
  vectoreffect: 'vectorEffect',
  'vector-effect': 'vectorEffect',
  version: 'version',
  vertadvy: 'vertAdvY',
  'vert-adv-y': 'vertAdvY',
  vertoriginx: 'vertOriginX',
  'vert-origin-x': 'vertOriginX',
  vertoriginy: 'vertOriginY',
  'vert-origin-y': 'vertOriginY',
  vhanging: 'vHanging',
  'v-hanging': 'vHanging',
  videographic: 'vIdeographic',
  'v-ideographic': 'vIdeographic',
  viewbox: 'viewBox',
  viewtarget: 'viewTarget',
  visibility: 'visibility',
  vmathematical: 'vMathematical',
  'v-mathematical': 'vMathematical',
  vocab: 'vocab',
  widths: 'widths',
  wordspacing: 'wordSpacing',
  'word-spacing': 'wordSpacing',
  writingmode: 'writingMode',
  'writing-mode': 'writingMode',
  x1: 'x1',
  x2: 'x2',
  x: 'x',
  xchannelselector: 'xChannelSelector',
  xheight: 'xHeight',
  'x-height': 'xHeight',
  xlinkactuate: 'xlinkActuate',
  'xlink:actuate': 'xlinkActuate',
  xlinkarcrole: 'xlinkArcrole',
  'xlink:arcrole': 'xlinkArcrole',
  xlinkhref: 'xlinkHref',
  'xlink:href': 'xlinkHref',
  xlinkrole: 'xlinkRole',
  'xlink:role': 'xlinkRole',
  xlinkshow: 'xlinkShow',
  'xlink:show': 'xlinkShow',
  xlinktitle: 'xlinkTitle',
  'xlink:title': 'xlinkTitle',
  xlinktype: 'xlinkType',
  'xlink:type': 'xlinkType',
  xmlbase: 'xmlBase',
  'xml:base': 'xmlBase',
  xmllang: 'xmlLang',
  'xml:lang': 'xmlLang',
  xmlns: 'xmlns',
  'xml:space': 'xmlSpace',
  xmlnsxlink: 'xmlnsXlink',
  'xmlns:xlink': 'xmlnsXlink',
  xmlspace: 'xmlSpace',
  y1: 'y1',
  y2: 'y2',
  y: 'y',
  ychannelselector: 'yChannelSelector',
  z: 'z',
  zoomandpan: 'zoomAndPan'
};

var ariaProperties = {
  'aria-current': 0,
  // state
  'aria-details': 0,
  'aria-disabled': 0,
  // state
  'aria-hidden': 0,
  // state
  'aria-invalid': 0,
  // state
  'aria-keyshortcuts': 0,
  'aria-label': 0,
  'aria-roledescription': 0,
  // Widget Attributes
  'aria-autocomplete': 0,
  'aria-checked': 0,
  'aria-expanded': 0,
  'aria-haspopup': 0,
  'aria-level': 0,
  'aria-modal': 0,
  'aria-multiline': 0,
  'aria-multiselectable': 0,
  'aria-orientation': 0,
  'aria-placeholder': 0,
  'aria-pressed': 0,
  'aria-readonly': 0,
  'aria-required': 0,
  'aria-selected': 0,
  'aria-sort': 0,
  'aria-valuemax': 0,
  'aria-valuemin': 0,
  'aria-valuenow': 0,
  'aria-valuetext': 0,
  // Live Region Attributes
  'aria-atomic': 0,
  'aria-busy': 0,
  'aria-live': 0,
  'aria-relevant': 0,
  // Drag-and-Drop Attributes
  'aria-dropeffect': 0,
  'aria-grabbed': 0,
  // Relationship Attributes
  'aria-activedescendant': 0,
  'aria-colcount': 0,
  'aria-colindex': 0,
  'aria-colspan': 0,
  'aria-controls': 0,
  'aria-describedby': 0,
  'aria-errormessage': 0,
  'aria-flowto': 0,
  'aria-labelledby': 0,
  'aria-owns': 0,
  'aria-posinset': 0,
  'aria-rowcount': 0,
  'aria-rowindex': 0,
  'aria-rowspan': 0,
  'aria-setsize': 0
};

var warnedProperties = {};
var rARIA = new RegExp('^(aria)-[' + ATTRIBUTE_NAME_CHAR + ']*$');
var rARIACamel = new RegExp('^(aria)[A-Z][' + ATTRIBUTE_NAME_CHAR + ']*$');
var hasOwnProperty$1 = Object.prototype.hasOwnProperty;

function validateProperty(tagName, name) {
  {
    if (hasOwnProperty$1.call(warnedProperties, name) && warnedProperties[name]) {
      return true;
    }

    if (rARIACamel.test(name)) {
      var ariaName = 'aria-' + name.slice(4).toLowerCase();
      var correctName = ariaProperties.hasOwnProperty(ariaName) ? ariaName : null; // If this is an aria-* attribute, but is not listed in the known DOM
      // DOM properties, then it is an invalid aria-* attribute.

      if (correctName == null) {
        error('Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.', name);

        warnedProperties[name] = true;
        return true;
      } // aria-* attributes should be lowercase; suggest the lowercase version.


      if (name !== correctName) {
        error('Invalid ARIA attribute `%s`. Did you mean `%s`?', name, correctName);

        warnedProperties[name] = true;
        return true;
      }
    }

    if (rARIA.test(name)) {
      var lowerCasedName = name.toLowerCase();
      var standardName = ariaProperties.hasOwnProperty(lowerCasedName) ? lowerCasedName : null; // If this is an aria-* attribute, but is not listed in the known DOM
      // DOM properties, then it is an invalid aria-* attribute.

      if (standardName == null) {
        warnedProperties[name] = true;
        return false;
      } // aria-* attributes should be lowercase; suggest the lowercase version.


      if (name !== standardName) {
        error('Unknown ARIA attribute `%s`. Did you mean `%s`?', name, standardName);

        warnedProperties[name] = true;
        return true;
      }
    }
  }

  return true;
}

function warnInvalidARIAProps(type, props) {
  {
    var invalidProps = [];

    for (var key in props) {
      var isValid = validateProperty(type, key);

      if (!isValid) {
        invalidProps.push(key);
      }
    }

    var unknownPropString = invalidProps.map(function (prop) {
      return '`' + prop + '`';
    }).join(', ');

    if (invalidProps.length === 1) {
      error('Invalid aria prop %s on <%s> tag. ' + 'For details, see https://reactjs.org/link/invalid-aria-props', unknownPropString, type);
    } else if (invalidProps.length > 1) {
      error('Invalid aria props %s on <%s> tag. ' + 'For details, see https://reactjs.org/link/invalid-aria-props', unknownPropString, type);
    }
  }
}

function validateProperties(type, props) {
  if (isCustomComponent(type, props)) {
    return;
  }

  warnInvalidARIAProps(type, props);
}

var didWarnValueNull = false;
function validateProperties$1(type, props) {
  {
    if (type !== 'input' && type !== 'textarea' && type !== 'select') {
      return;
    }

    if (props != null && props.value === null && !didWarnValueNull) {
      didWarnValueNull = true;

      if (type === 'select' && props.multiple) {
        error('`value` prop on `%s` should not be null. ' + 'Consider using an empty array when `multiple` is set to `true` ' + 'to clear the component or `undefined` for uncontrolled components.', type);
      } else {
        error('`value` prop on `%s` should not be null. ' + 'Consider using an empty string to clear the component or `undefined` ' + 'for uncontrolled components.', type);
      }
    }
  }
}

var validateProperty$1 = function () {};

{
  var warnedProperties$1 = {};
  var _hasOwnProperty = Object.prototype.hasOwnProperty;
  var EVENT_NAME_REGEX = /^on./;
  var INVALID_EVENT_NAME_REGEX = /^on[^A-Z]/;
  var rARIA$1 = new RegExp('^(aria)-[' + ATTRIBUTE_NAME_CHAR + ']*$');
  var rARIACamel$1 = new RegExp('^(aria)[A-Z][' + ATTRIBUTE_NAME_CHAR + ']*$');

  validateProperty$1 = function (tagName, name, value, eventRegistry) {
    if (_hasOwnProperty.call(warnedProperties$1, name) && warnedProperties$1[name]) {
      return true;
    }

    var lowerCasedName = name.toLowerCase();

    if (lowerCasedName === 'onfocusin' || lowerCasedName === 'onfocusout') {
      error('React uses onFocus and onBlur instead of onFocusIn and onFocusOut. ' + 'All React events are normalized to bubble, so onFocusIn and onFocusOut ' + 'are not needed/supported by React.');

      warnedProperties$1[name] = true;
      return true;
    } // We can't rely on the event system being injected on the server.


    if (eventRegistry != null) {
      var registrationNameDependencies = eventRegistry.registrationNameDependencies,
          possibleRegistrationNames = eventRegistry.possibleRegistrationNames;

      if (registrationNameDependencies.hasOwnProperty(name)) {
        return true;
      }

      var registrationName = possibleRegistrationNames.hasOwnProperty(lowerCasedName) ? possibleRegistrationNames[lowerCasedName] : null;

      if (registrationName != null) {
        error('Invalid event handler property `%s`. Did you mean `%s`?', name, registrationName);

        warnedProperties$1[name] = true;
        return true;
      }

      if (EVENT_NAME_REGEX.test(name)) {
        error('Unknown event handler property `%s`. It will be ignored.', name);

        warnedProperties$1[name] = true;
        return true;
      }
    } else if (EVENT_NAME_REGEX.test(name)) {
      // If no event plugins have been injected, we are in a server environment.
      // So we can't tell if the event name is correct for sure, but we can filter
      // out known bad ones like `onclick`. We can't suggest a specific replacement though.
      if (INVALID_EVENT_NAME_REGEX.test(name)) {
        error('Invalid event handler property `%s`. ' + 'React events use the camelCase naming convention, for example `onClick`.', name);
      }

      warnedProperties$1[name] = true;
      return true;
    } // Let the ARIA attribute hook validate ARIA attributes


    if (rARIA$1.test(name) || rARIACamel$1.test(name)) {
      return true;
    }

    if (lowerCasedName === 'innerhtml') {
      error('Directly setting property `innerHTML` is not permitted. ' + 'For more information, lookup documentation on `dangerouslySetInnerHTML`.');

      warnedProperties$1[name] = true;
      return true;
    }

    if (lowerCasedName === 'aria') {
      error('The `aria` attribute is reserved for future use in React. ' + 'Pass individual `aria-` attributes instead.');

      warnedProperties$1[name] = true;
      return true;
    }

    if (lowerCasedName === 'is' && value !== null && value !== undefined && typeof value !== 'string') {
      error('Received a `%s` for a string attribute `is`. If this is expected, cast ' + 'the value to a string.', typeof value);

      warnedProperties$1[name] = true;
      return true;
    }

    if (typeof value === 'number' && isNaN(value)) {
      error('Received NaN for the `%s` attribute. If this is expected, cast ' + 'the value to a string.', name);

      warnedProperties$1[name] = true;
      return true;
    }

    var propertyInfo = getPropertyInfo(name);
    var isReserved = propertyInfo !== null && propertyInfo.type === RESERVED; // Known attributes should match the casing specified in the property config.

    if (possibleStandardNames.hasOwnProperty(lowerCasedName)) {
      var standardName = possibleStandardNames[lowerCasedName];

      if (standardName !== name) {
        error('Invalid DOM property `%s`. Did you mean `%s`?', name, standardName);

        warnedProperties$1[name] = true;
        return true;
      }
    } else if (!isReserved && name !== lowerCasedName) {
      // Unknown attributes should have lowercase casing since that's how they
      // will be cased anyway with server rendering.
      error('React does not recognize the `%s` prop on a DOM element. If you ' + 'intentionally want it to appear in the DOM as a custom ' + 'attribute, spell it as lowercase `%s` instead. ' + 'If you accidentally passed it from a parent component, remove ' + 'it from the DOM element.', name, lowerCasedName);

      warnedProperties$1[name] = true;
      return true;
    }

    if (typeof value === 'boolean' && shouldRemoveAttributeWithWarning(name, value, propertyInfo, false)) {
      if (value) {
        error('Received `%s` for a non-boolean attribute `%s`.\n\n' + 'If you want to write it to the DOM, pass a string instead: ' + '%s="%s" or %s={value.toString()}.', value, name, name, value, name);
      } else {
        error('Received `%s` for a non-boolean attribute `%s`.\n\n' + 'If you want to write it to the DOM, pass a string instead: ' + '%s="%s" or %s={value.toString()}.\n\n' + 'If you used to conditionally omit it with %s={condition && value}, ' + 'pass %s={condition ? value : undefined} instead.', value, name, name, value, name, name, name);
      }

      warnedProperties$1[name] = true;
      return true;
    } // Now that we've validated casing, do not validate
    // data types for reserved props


    if (isReserved) {
      return true;
    } // Warn when a known attribute is a bad type


    if (shouldRemoveAttributeWithWarning(name, value, propertyInfo, false)) {
      warnedProperties$1[name] = true;
      return false;
    } // Warn when passing the strings 'false' or 'true' into a boolean prop


    if ((value === 'false' || value === 'true') && propertyInfo !== null && propertyInfo.type === BOOLEAN) {
      error('Received the string `%s` for the boolean attribute `%s`. ' + '%s ' + 'Did you mean %s={%s}?', value, name, value === 'false' ? 'The browser will interpret it as a truthy value.' : 'Although this works, it will not work as expected if you pass the string "false".', name, value);

      warnedProperties$1[name] = true;
      return true;
    }

    return true;
  };
}

var warnUnknownProperties = function (type, props, eventRegistry) {
  {
    var unknownProps = [];

    for (var key in props) {
      var isValid = validateProperty$1(type, key, props[key], eventRegistry);

      if (!isValid) {
        unknownProps.push(key);
      }
    }

    var unknownPropString = unknownProps.map(function (prop) {
      return '`' + prop + '`';
    }).join(', ');

    if (unknownProps.length === 1) {
      error('Invalid value for prop %s on <%s> tag. Either remove it from the element, ' + 'or pass a string or number value to keep it in the DOM. ' + 'For details, see https://reactjs.org/link/attribute-behavior ', unknownPropString, type);
    } else if (unknownProps.length > 1) {
      error('Invalid values for props %s on <%s> tag. Either remove them from the element, ' + 'or pass a string or number value to keep them in the DOM. ' + 'For details, see https://reactjs.org/link/attribute-behavior ', unknownPropString, type);
    }
  }
};

function validateProperties$2(type, props, eventRegistry) {
  if (isCustomComponent(type, props)) {
    return;
  }

  warnUnknownProperties(type, props, eventRegistry);
}

var IS_EVENT_HANDLE_NON_MANAGED_NODE = 1;
var IS_NON_DELEGATED = 1 << 1;
var IS_CAPTURE_PHASE = 1 << 2;
var IS_REPLAYED = 1 << 4;
// set to LEGACY_FB_SUPPORT. LEGACY_FB_SUPPORT only gets set when
// we call willDeferLaterForLegacyFBSupport, thus not bailing out
// will result in endless cycles like an infinite loop.
// We also don't want to defer during event replaying.

var SHOULD_NOT_PROCESS_POLYFILL_EVENT_PLUGINS = IS_EVENT_HANDLE_NON_MANAGED_NODE | IS_NON_DELEGATED | IS_CAPTURE_PHASE;

/**
 * Gets the target node from a native browser event by accounting for
 * inconsistencies in browser DOM APIs.
 *
 * @param {object} nativeEvent Native browser event.
 * @return {DOMEventTarget} Target node.
 */

function getEventTarget(nativeEvent) {
  // Fallback to nativeEvent.srcElement for IE9
  // https://github.com/facebook/react/issues/12506
  var target = nativeEvent.target || nativeEvent.srcElement || window; // Normalize SVG <use> element events #4963

  if (target.correspondingUseElement) {
    target = target.correspondingUseElement;
  } // Safari may fire events on text nodes (Node.TEXT_NODE is 3).
  // @see http://www.quirksmode.org/js/events_properties.html


  return target.nodeType === TEXT_NODE ? target.parentNode : target;
}

var restoreImpl = null;
var restoreTarget = null;
var restoreQueue = null;

function restoreStateOfTarget(target) {
  // We perform this translation at the end of the event loop so that we
  // always receive the correct fiber here
  var internalInstance = getInstanceFromNode(target);

  if (!internalInstance) {
    // Unmounted
    return;
  }

  if (!(typeof restoreImpl === 'function')) {
    {
      throw Error( "setRestoreImplementation() needs to be called to handle a target for controlled events. This error is likely caused by a bug in React. Please file an issue." );
    }
  }

  var stateNode = internalInstance.stateNode; // Guard against Fiber being unmounted.

  if (stateNode) {
    var _props = getFiberCurrentPropsFromNode(stateNode);

    restoreImpl(internalInstance.stateNode, internalInstance.type, _props);
  }
}

function setRestoreImplementation(impl) {
  restoreImpl = impl;
}
function enqueueStateRestore(target) {
  if (restoreTarget) {
    if (restoreQueue) {
      restoreQueue.push(target);
    } else {
      restoreQueue = [target];
    }
  } else {
    restoreTarget = target;
  }
}
function needsStateRestore() {
  return restoreTarget !== null || restoreQueue !== null;
}
function restoreStateIfNeeded() {
  if (!restoreTarget) {
    return;
  }

  var target = restoreTarget;
  var queuedTargets = restoreQueue;
  restoreTarget = null;
  restoreQueue = null;
  restoreStateOfTarget(target);

  if (queuedTargets) {
    for (var i = 0; i < queuedTargets.length; i++) {
      restoreStateOfTarget(queuedTargets[i]);
    }
  }
}

// the renderer. Such as when we're dispatching events or if third party
// libraries need to call batchedUpdates. Eventually, this API will go away when
// everything is batched by default. We'll then have a similar API to opt-out of
// scheduled work and instead do synchronous work.
// Defaults

var batchedUpdatesImpl = function (fn, bookkeeping) {
  return fn(bookkeeping);
};

var discreteUpdatesImpl = function (fn, a, b, c, d) {
  return fn(a, b, c, d);
};

var flushDiscreteUpdatesImpl = function () {};

var batchedEventUpdatesImpl = batchedUpdatesImpl;
var isInsideEventHandler = false;
var isBatchingEventUpdates = false;

function finishEventHandler() {
  // Here we wait until all updates have propagated, which is important
  // when using controlled components within layers:
  // https://github.com/facebook/react/issues/1698
  // Then we restore state of any controlled component.
  var controlledComponentsHavePendingUpdates = needsStateRestore();

  if (controlledComponentsHavePendingUpdates) {
    // If a controlled event was fired, we may need to restore the state of
    // the DOM node back to the controlled value. This is necessary when React
    // bails out of the update without touching the DOM.
    flushDiscreteUpdatesImpl();
    restoreStateIfNeeded();
  }
}

function batchedUpdates(fn, bookkeeping) {
  if (isInsideEventHandler) {
    // If we are currently inside another batch, we need to wait until it
    // fully completes before restoring state.
    return fn(bookkeeping);
  }

  isInsideEventHandler = true;

  try {
    return batchedUpdatesImpl(fn, bookkeeping);
  } finally {
    isInsideEventHandler = false;
    finishEventHandler();
  }
}
function batchedEventUpdates(fn, a, b) {
  if (isBatchingEventUpdates) {
    // If we are currently inside another batch, we need to wait until it
    // fully completes before restoring state.
    return fn(a, b);
  }

  isBatchingEventUpdates = true;

  try {
    return batchedEventUpdatesImpl(fn, a, b);
  } finally {
    isBatchingEventUpdates = false;
    finishEventHandler();
  }
}
function discreteUpdates(fn, a, b, c, d) {
  var prevIsInsideEventHandler = isInsideEventHandler;
  isInsideEventHandler = true;

  try {
    return discreteUpdatesImpl(fn, a, b, c, d);
  } finally {
    isInsideEventHandler = prevIsInsideEventHandler;

    if (!isInsideEventHandler) {
      finishEventHandler();
    }
  }
}
function flushDiscreteUpdatesIfNeeded(timeStamp) {
  {
    if (!isInsideEventHandler) {
      flushDiscreteUpdatesImpl();
    }
  }
}
function setBatchingImplementation(_batchedUpdatesImpl, _discreteUpdatesImpl, _flushDiscreteUpdatesImpl, _batchedEventUpdatesImpl) {
  batchedUpdatesImpl = _batchedUpdatesImpl;
  discreteUpdatesImpl = _discreteUpdatesImpl;
  flushDiscreteUpdatesImpl = _flushDiscreteUpdatesImpl;
  batchedEventUpdatesImpl = _batchedEventUpdatesImpl;
}

function isInteractive(tag) {
  return tag === 'button' || tag === 'input' || tag === 'select' || tag === 'textarea';
}

function shouldPreventMouseEvent(name, type, props) {
  switch (name) {
    case 'onClick':
    case 'onClickCapture':
    case 'onDoubleClick':
    case 'onDoubleClickCapture':
    case 'onMouseDown':
    case 'onMouseDownCapture':
    case 'onMouseMove':
    case 'onMouseMoveCapture':
    case 'onMouseUp':
    case 'onMouseUpCapture':
    case 'onMouseEnter':
      return !!(props.disabled && isInteractive(type));

    default:
      return false;
  }
}
/**
 * @param {object} inst The instance, which is the source of events.
 * @param {string} registrationName Name of listener (e.g. `onClick`).
 * @return {?function} The stored callback.
 */


function getListener(inst, registrationName) {
  var stateNode = inst.stateNode;

  if (stateNode === null) {
    // Work in progress (ex: onload events in incremental mode).
    return null;
  }

  var props = getFiberCurrentPropsFromNode(stateNode);

  if (props === null) {
    // Work in progress.
    return null;
  }

  var listener = props[registrationName];

  if (shouldPreventMouseEvent(registrationName, inst.type, props)) {
    return null;
  }

  if (!(!listener || typeof listener === 'function')) {
    {
      throw Error( "Expected `" + registrationName + "` listener to be a function, instead got a value of `" + typeof listener + "` type." );
    }
  }

  return listener;
}

var passiveBrowserEventsSupported = false; // Check if browser support events with passive listeners
// https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#Safely_detecting_option_support

if (canUseDOM) {
  try {
    var options = {}; // $FlowFixMe: Ignore Flow complaining about needing a value

    Object.defineProperty(options, 'passive', {
      get: function () {
        passiveBrowserEventsSupported = true;
      }
    });
    window.addEventListener('test', options, options);
    window.removeEventListener('test', options, options);
  } catch (e) {
    passiveBrowserEventsSupported = false;
  }
}

function invokeGuardedCallbackProd(name, func, context, a, b, c, d, e, f) {
  var funcArgs = Array.prototype.slice.call(arguments, 3);

  try {
    func.apply(context, funcArgs);
  } catch (error) {
    this.onError(error);
  }
}

var invokeGuardedCallbackImpl = invokeGuardedCallbackProd;

{
  // In DEV mode, we swap out invokeGuardedCallback for a special version
  // that plays more nicely with the browser's DevTools. The idea is to preserve
  // "Pause on exceptions" behavior. Because React wraps all user-provided
  // functions in invokeGuardedCallback, and the production version of
  // invokeGuardedCallback uses a try-catch, all user exceptions are treated
  // like caught exceptions, and the DevTools won't pause unless the developer
  // takes the extra step of enabling pause on caught exceptions. This is
  // unintuitive, though, because even though React has caught the error, from
  // the developer's perspective, the error is uncaught.
  //
  // To preserve the expected "Pause on exceptions" behavior, we don't use a
  // try-catch in DEV. Instead, we synchronously dispatch a fake event to a fake
  // DOM node, and call the user-provided callback from inside an event handler
  // for that fake event. If the callback throws, the error is "captured" using
  // a global event handler. But because the error happens in a different
  // event loop context, it does not interrupt the normal program flow.
  // Effectively, this gives us try-catch behavior without actually using
  // try-catch. Neat!
  // Check that the browser supports the APIs we need to implement our special
  // DEV version of invokeGuardedCallback
  if (typeof window !== 'undefined' && typeof window.dispatchEvent === 'function' && typeof document !== 'undefined' && typeof document.createEvent === 'function') {
    var fakeNode = document.createElement('react');

    invokeGuardedCallbackImpl = function invokeGuardedCallbackDev(name, func, context, a, b, c, d, e, f) {
      // If document doesn't exist we know for sure we will crash in this method
      // when we call document.createEvent(). However this can cause confusing
      // errors: https://github.com/facebookincubator/create-react-app/issues/3482
      // So we preemptively throw with a better message instead.
      if (!(typeof document !== 'undefined')) {
        {
          throw Error( "The `document` global was defined when React was initialized, but is not defined anymore. This can happen in a test environment if a component schedules an update from an asynchronous callback, but the test has already finished running. To solve this, you can either unmount the component at the end of your test (and ensure that any asynchronous operations get canceled in `componentWillUnmount`), or you can change the test itself to be asynchronous." );
        }
      }

      var evt = document.createEvent('Event');
      var didCall = false; // Keeps track of whether the user-provided callback threw an error. We
      // set this to true at the beginning, then set it to false right after
      // calling the function. If the function errors, `didError` will never be
      // set to false. This strategy works even if the browser is flaky and
      // fails to call our global error handler, because it doesn't rely on
      // the error event at all.

      var didError = true; // Keeps track of the value of window.event so that we can reset it
      // during the callback to let user code access window.event in the
      // browsers that support it.

      var windowEvent = window.event; // Keeps track of the descriptor of window.event to restore it after event
      // dispatching: https://github.com/facebook/react/issues/13688

      var windowEventDescriptor = Object.getOwnPropertyDescriptor(window, 'event');

      function restoreAfterDispatch() {
        // We immediately remove the callback from event listeners so that
        // nested `invokeGuardedCallback` calls do not clash. Otherwise, a
        // nested call would trigger the fake event handlers of any call higher
        // in the stack.
        fakeNode.removeEventListener(evtType, callCallback, false); // We check for window.hasOwnProperty('event') to prevent the
        // window.event assignment in both IE <= 10 as they throw an error
        // "Member not found" in strict mode, and in Firefox which does not
        // support window.event.

        if (typeof window.event !== 'undefined' && window.hasOwnProperty('event')) {
          window.event = windowEvent;
        }
      } // Create an event handler for our fake event. We will synchronously
      // dispatch our fake event using `dispatchEvent`. Inside the handler, we
      // call the user-provided callback.


      var funcArgs = Array.prototype.slice.call(arguments, 3);

      function callCallback() {
        didCall = true;
        restoreAfterDispatch();
        func.apply(context, funcArgs);
        didError = false;
      } // Create a global error event handler. We use this to capture the value
      // that was thrown. It's possible that this error handler will fire more
      // than once; for example, if non-React code also calls `dispatchEvent`
      // and a handler for that event throws. We should be resilient to most of
      // those cases. Even if our error event handler fires more than once, the
      // last error event is always used. If the callback actually does error,
      // we know that the last error event is the correct one, because it's not
      // possible for anything else to have happened in between our callback
      // erroring and the code that follows the `dispatchEvent` call below. If
      // the callback doesn't error, but the error event was fired, we know to
      // ignore it because `didError` will be false, as described above.


      var error; // Use this to track whether the error event is ever called.

      var didSetError = false;
      var isCrossOriginError = false;

      function handleWindowError(event) {
        error = event.error;
        didSetError = true;

        if (error === null && event.colno === 0 && event.lineno === 0) {
          isCrossOriginError = true;
        }

        if (event.defaultPrevented) {
          // Some other error handler has prevented default.
          // Browsers silence the error report if this happens.
          // We'll remember this to later decide whether to log it or not.
          if (error != null && typeof error === 'object') {
            try {
              error._suppressLogging = true;
            } catch (inner) {// Ignore.
            }
          }
        }
      } // Create a fake event type.


      var evtType = "react-" + (name ? name : 'invokeguardedcallback'); // Attach our event handlers

      window.addEventListener('error', handleWindowError);
      fakeNode.addEventListener(evtType, callCallback, false); // Synchronously dispatch our fake event. If the user-provided function
      // errors, it will trigger our global error handler.

      evt.initEvent(evtType, false, false);
      fakeNode.dispatchEvent(evt);

      if (windowEventDescriptor) {
        Object.defineProperty(window, 'event', windowEventDescriptor);
      }

      if (didCall && didError) {
        if (!didSetError) {
          // The callback errored, but the error event never fired.
          error = new Error('An error was thrown inside one of your components, but React ' + "doesn't know what it was. This is likely due to browser " + 'flakiness. React does its best to preserve the "Pause on ' + 'exceptions" behavior of the DevTools, which requires some ' + "DEV-mode only tricks. It's possible that these don't work in " + 'your browser. Try triggering the error in production mode, ' + 'or switching to a modern browser. If you suspect that this is ' + 'actually an issue with React, please file an issue.');
        } else if (isCrossOriginError) {
          error = new Error("A cross-origin error was thrown. React doesn't have access to " + 'the actual error object in development. ' + 'See https://reactjs.org/link/crossorigin-error for more information.');
        }

        this.onError(error);
      } // Remove our event listeners


      window.removeEventListener('error', handleWindowError);

      if (!didCall) {
        // Something went really wrong, and our event was not dispatched.
        // https://github.com/facebook/react/issues/16734
        // https://github.com/facebook/react/issues/16585
        // Fall back to the production implementation.
        restoreAfterDispatch();
        return invokeGuardedCallbackProd.apply(this, arguments);
      }
    };
  }
}

var invokeGuardedCallbackImpl$1 = invokeGuardedCallbackImpl;

var hasError = false;
var caughtError = null; // Used by event system to capture/rethrow the first error.

var hasRethrowError = false;
var rethrowError = null;
var reporter = {
  onError: function (error) {
    hasError = true;
    caughtError = error;
  }
};
/**
 * Call a function while guarding against errors that happens within it.
 * Returns an error if it throws, otherwise null.
 *
 * In production, this is implemented using a try-catch. The reason we don't
 * use a try-catch directly is so that we can swap out a different
 * implementation in DEV mode.
 *
 * @param {String} name of the guard to use for logging or debugging
 * @param {Function} func The function to invoke
 * @param {*} context The context to use when calling the function
 * @param {...*} args Arguments for function
 */

function invokeGuardedCallback(name, func, context, a, b, c, d, e, f) {
  hasError = false;
  caughtError = null;
  invokeGuardedCallbackImpl$1.apply(reporter, arguments);
}
/**
 * Same as invokeGuardedCallback, but instead of returning an error, it stores
 * it in a global so it can be rethrown by `rethrowCaughtError` later.
 * TODO: See if caughtError and rethrowError can be unified.
 *
 * @param {String} name of the guard to use for logging or debugging
 * @param {Function} func The function to invoke
 * @param {*} context The context to use when calling the function
 * @param {...*} args Arguments for function
 */

function invokeGuardedCallbackAndCatchFirstError(name, func, context, a, b, c, d, e, f) {
  invokeGuardedCallback.apply(this, arguments);

  if (hasError) {
    var error = clearCaughtError();

    if (!hasRethrowError) {
      hasRethrowError = true;
      rethrowError = error;
    }
  }
}
/**
 * During execution of guarded functions we will capture the first error which
 * we will rethrow to be handled by the top level error handler.
 */

function rethrowCaughtError() {
  if (hasRethrowError) {
    var error = rethrowError;
    hasRethrowError = false;
    rethrowError = null;
    throw error;
  }
}
function hasCaughtError() {
  return hasError;
}
function clearCaughtError() {
  if (hasError) {
    var error = caughtError;
    hasError = false;
    caughtError = null;
    return error;
  } else {
    {
      {
        throw Error( "clearCaughtError was called but no error was captured. This error is likely caused by a bug in React. Please file an issue." );
      }
    }
  }
}

/**
 * `ReactInstanceMap` maintains a mapping from a public facing stateful
 * instance (key) and the internal representation (value). This allows public
 * methods to accept the user facing instance as an argument and map them back
 * to internal methods.
 *
 * Note that this module is currently shared and assumed to be stateless.
 * If this becomes an actual Map, that will break.
 */
function get(key) {
  return key._reactInternals;
}
function has(key) {
  return key._reactInternals !== undefined;
}
function set(key, value) {
  key._reactInternals = value;
}

// Don't change these two values. They're used by React Dev Tools.
var NoFlags =
/*                      */
0;
var PerformedWork =
/*                */
1; // You can change the rest (and add more).

var Placement =
/*                    */
2;
var Update =
/*                       */
4;
var PlacementAndUpdate =
/*           */
6;
var Deletion =
/*                     */
8;
var ContentReset =
/*                 */
16;
var Callback =
/*                     */
32;
var DidCapture =
/*                   */
64;
var Ref =
/*                          */
128;
var Snapshot =
/*                     */
256;
var Passive =
/*                      */
512; // TODO (effects) Remove this bit once the new reconciler is synced to the old.

var PassiveUnmountPendingDev =
/*     */
8192;
var Hydrating =
/*                    */
1024;
var HydratingAndUpdate =
/*           */
1028; // Passive & Update & Callback & Ref & Snapshot

var LifecycleEffectMask =
/*          */
932; // Union of all host effects

var HostEffectMask =
/*               */
2047; // These are not really side effects, but we still reuse this field.

var Incomplete =
/*                   */
2048;
var ShouldCapture =
/*                */
4096;
var ForceUpdateForLegacySuspense =
/* */
16384; // Static tags describe aspects of a fiber that are not specific to a render,

var ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;
function getNearestMountedFiber(fiber) {
  var node = fiber;
  var nearestMounted = fiber;

  if (!fiber.alternate) {
    // If there is no alternate, this might be a new tree that isn't inserted
    // yet. If it is, then it will have a pending insertion effect on it.
    var nextNode = node;

    do {
      node = nextNode;

      if ((node.flags & (Placement | Hydrating)) !== NoFlags) {
        // This is an insertion or in-progress hydration. The nearest possible
        // mounted fiber is the parent but we need to continue to figure out
        // if that one is still mounted.
        nearestMounted = node.return;
      }

      nextNode = node.return;
    } while (nextNode);
  } else {
    while (node.return) {
      node = node.return;
    }
  }

  if (node.tag === HostRoot) {
    // TODO: Check if this was a nested HostRoot when used with
    // renderContainerIntoSubtree.
    return nearestMounted;
  } // If we didn't hit the root, that means that we're in an disconnected tree
  // that has been unmounted.


  return null;
}
function getSuspenseInstanceFromFiber(fiber) {
  if (fiber.tag === SuspenseComponent) {
    var suspenseState = fiber.memoizedState;

    if (suspenseState === null) {
      var current = fiber.alternate;

      if (current !== null) {
        suspenseState = current.memoizedState;
      }
    }

    if (suspenseState !== null) {
      return suspenseState.dehydrated;
    }
  }

  return null;
}
function getContainerFromFiber(fiber) {
  return fiber.tag === HostRoot ? fiber.stateNode.containerInfo : null;
}
function isFiberMounted(fiber) {
  return getNearestMountedFiber(fiber) === fiber;
}
function isMounted(component) {
  {
    var owner = ReactCurrentOwner.current;

    if (owner !== null && owner.tag === ClassComponent) {
      var ownerFiber = owner;
      var instance = ownerFiber.stateNode;

      if (!instance._warnedAboutRefsInRender) {
        error('%s is accessing isMounted inside its render() function. ' + 'render() should be a pure function of props and state. It should ' + 'never access something that requires stale data from the previous ' + 'render, such as refs. Move this logic to componentDidMount and ' + 'componentDidUpdate instead.', getComponentName(ownerFiber.type) || 'A component');
      }

      instance._warnedAboutRefsInRender = true;
    }
  }

  var fiber = get(component);

  if (!fiber) {
    return false;
  }

  return getNearestMountedFiber(fiber) === fiber;
}

function assertIsMounted(fiber) {
  if (!(getNearestMountedFiber(fiber) === fiber)) {
    {
      throw Error( "Unable to find node on an unmounted component." );
    }
  }
}

function findCurrentFiberUsingSlowPath(fiber) {
  var alternate = fiber.alternate;

  if (!alternate) {
    // If there is no alternate, then we only need to check if it is mounted.
    var nearestMounted = getNearestMountedFiber(fiber);

    if (!(nearestMounted !== null)) {
      {
        throw Error( "Unable to find node on an unmounted component." );
      }
    }

    if (nearestMounted !== fiber) {
      return null;
    }

    return fiber;
  } // If we have two possible branches, we'll walk backwards up to the root
  // to see what path the root points to. On the way we may hit one of the
  // special cases and we'll deal with them.


  var a = fiber;
  var b = alternate;

  while (true) {
    var parentA = a.return;

    if (parentA === null) {
      // We're at the root.
      break;
    }

    var parentB = parentA.alternate;

    if (parentB === null) {
      // There is no alternate. This is an unusual case. Currently, it only
      // happens when a Suspense component is hidden. An extra fragment fiber
      // is inserted in between the Suspense fiber and its children. Skip
      // over this extra fragment fiber and proceed to the next parent.
      var nextParent = parentA.return;

      if (nextParent !== null) {
        a = b = nextParent;
        continue;
      } // If there's no parent, we're at the root.


      break;
    } // If both copies of the parent fiber point to the same child, we can
    // assume that the child is current. This happens when we bailout on low
    // priority: the bailed out fiber's child reuses the current child.


    if (parentA.child === parentB.child) {
      var child = parentA.child;

      while (child) {
        if (child === a) {
          // We've determined that A is the current branch.
          assertIsMounted(parentA);
          return fiber;
        }

        if (child === b) {
          // We've determined that B is the current branch.
          assertIsMounted(parentA);
          return alternate;
        }

        child = child.sibling;
      } // We should never have an alternate for any mounting node. So the only
      // way this could possibly happen is if this was unmounted, if at all.


      {
        {
          throw Error( "Unable to find node on an unmounted component." );
        }
      }
    }

    if (a.return !== b.return) {
      // The return pointer of A and the return pointer of B point to different
      // fibers. We assume that return pointers never criss-cross, so A must
      // belong to the child set of A.return, and B must belong to the child
      // set of B.return.
      a = parentA;
      b = parentB;
    } else {
      // The return pointers point to the same fiber. We'll have to use the
      // default, slow path: scan the child sets of each parent alternate to see
      // which child belongs to which set.
      //
      // Search parent A's child set
      var didFindChild = false;
      var _child = parentA.child;

      while (_child) {
        if (_child === a) {
          didFindChild = true;
          a = parentA;
          b = parentB;
          break;
        }

        if (_child === b) {
          didFindChild = true;
          b = parentA;
          a = parentB;
          break;
        }

        _child = _child.sibling;
      }

      if (!didFindChild) {
        // Search parent B's child set
        _child = parentB.child;

        while (_child) {
          if (_child === a) {
            didFindChild = true;
            a = parentB;
            b = parentA;
            break;
          }

          if (_child === b) {
            didFindChild = true;
            b = parentB;
            a = parentA;
            break;
          }

          _child = _child.sibling;
        }

        if (!didFindChild) {
          {
            throw Error( "Child was not found in either parent set. This indicates a bug in React related to the return pointer. Please file an issue." );
          }
        }
      }
    }

    if (!(a.alternate === b)) {
      {
        throw Error( "Return fibers should always be each others' alternates. This error is likely caused by a bug in React. Please file an issue." );
      }
    }
  } // If the root is not a host container, we're in a disconnected tree. I.e.
  // unmounted.


  if (!(a.tag === HostRoot)) {
    {
      throw Error( "Unable to find node on an unmounted component." );
    }
  }

  if (a.stateNode.current === a) {
    // We've determined that A is the current branch.
    return fiber;
  } // Otherwise B has to be current branch.


  return alternate;
}
function findCurrentHostFiber(parent) {
  var currentParent = findCurrentFiberUsingSlowPath(parent);

  if (!currentParent) {
    return null;
  } // Next we'll drill down this component to find the first HostComponent/Text.


  var node = currentParent;

  while (true) {
    if (node.tag === HostComponent || node.tag === HostText) {
      return node;
    } else if (node.child) {
      node.child.return = node;
      node = node.child;
      continue;
    }

    if (node === currentParent) {
      return null;
    }

    while (!node.sibling) {
      if (!node.return || node.return === currentParent) {
        return null;
      }

      node = node.return;
    }

    node.sibling.return = node.return;
    node = node.sibling;
  } // Flow needs the return null here, but ESLint complains about it.
  // eslint-disable-next-line no-unreachable


  return null;
}
function findCurrentHostFiberWithNoPortals(parent) {
  var currentParent = findCurrentFiberUsingSlowPath(parent);

  if (!currentParent) {
    return null;
  } // Next we'll drill down this component to find the first HostComponent/Text.


  var node = currentParent;

  while (true) {
    if (node.tag === HostComponent || node.tag === HostText || enableFundamentalAPI ) {
      return node;
    } else if (node.child && node.tag !== HostPortal) {
      node.child.return = node;
      node = node.child;
      continue;
    }

    if (node === currentParent) {
      return null;
    }

    while (!node.sibling) {
      if (!node.return || node.return === currentParent) {
        return null;
      }

      node = node.return;
    }

    node.sibling.return = node.return;
    node = node.sibling;
  } // Flow needs the return null here, but ESLint complains about it.
  // eslint-disable-next-line no-unreachable


  return null;
}
function doesFiberContain(parentFiber, childFiber) {
  var node = childFiber;
  var parentFiberAlternate = parentFiber.alternate;

  while (node !== null) {
    if (node === parentFiber || node === parentFiberAlternate) {
      return true;
    }

    node = node.return;
  }

  return false;
}

var attemptUserBlockingHydration;
function setAttemptUserBlockingHydration(fn) {
  attemptUserBlockingHydration = fn;
}
var attemptContinuousHydration;
function setAttemptContinuousHydration(fn) {
  attemptContinuousHydration = fn;
}
var attemptHydrationAtCurrentPriority;
function setAttemptHydrationAtCurrentPriority(fn) {
  attemptHydrationAtCurrentPriority = fn;
}
var attemptHydrationAtPriority;
function setAttemptHydrationAtPriority(fn) {
  attemptHydrationAtPriority = fn;
} // TODO: Upgrade this definition once we're on a newer version of Flow that
var hasScheduledReplayAttempt = false; // The queue of discrete events to be replayed.

var queuedDiscreteEvents = []; // Indicates if any continuous event targets are non-null for early bailout.
// if the last target was dehydrated.

var queuedFocus = null;
var queuedDrag = null;
var queuedMouse = null; // For pointer events there can be one latest event per pointerId.

var queuedPointers = new Map();
var queuedPointerCaptures = new Map(); // We could consider replaying selectionchange and touchmoves too.

var queuedExplicitHydrationTargets = [];
function hasQueuedDiscreteEvents() {
  return queuedDiscreteEvents.length > 0;
}
var discreteReplayableEvents = ['mousedown', 'mouseup', 'touchcancel', 'touchend', 'touchstart', 'auxclick', 'dblclick', 'pointercancel', 'pointerdown', 'pointerup', 'dragend', 'dragstart', 'drop', 'compositionend', 'compositionstart', 'keydown', 'keypress', 'keyup', 'input', 'textInput', // Intentionally camelCase
'copy', 'cut', 'paste', 'click', 'change', 'contextmenu', 'reset', 'submit'];
function isReplayableDiscreteEvent(eventType) {
  return discreteReplayableEvents.indexOf(eventType) > -1;
}

function createQueuedReplayableEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent) {
  return {
    blockedOn: blockedOn,
    domEventName: domEventName,
    eventSystemFlags: eventSystemFlags | IS_REPLAYED,
    nativeEvent: nativeEvent,
    targetContainers: [targetContainer]
  };
}

function queueDiscreteEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent) {
  var queuedEvent = createQueuedReplayableEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent);
  queuedDiscreteEvents.push(queuedEvent);
} // Resets the replaying for this type of continuous event to no event.

function clearIfContinuousEvent(domEventName, nativeEvent) {
  switch (domEventName) {
    case 'focusin':
    case 'focusout':
      queuedFocus = null;
      break;

    case 'dragenter':
    case 'dragleave':
      queuedDrag = null;
      break;

    case 'mouseover':
    case 'mouseout':
      queuedMouse = null;
      break;

    case 'pointerover':
    case 'pointerout':
      {
        var pointerId = nativeEvent.pointerId;
        queuedPointers.delete(pointerId);
        break;
      }

    case 'gotpointercapture':
    case 'lostpointercapture':
      {
        var _pointerId = nativeEvent.pointerId;
        queuedPointerCaptures.delete(_pointerId);
        break;
      }
  }
}

function accumulateOrCreateContinuousQueuedReplayableEvent(existingQueuedEvent, blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent) {
  if (existingQueuedEvent === null || existingQueuedEvent.nativeEvent !== nativeEvent) {
    var queuedEvent = createQueuedReplayableEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent);

    if (blockedOn !== null) {
      var _fiber2 = getInstanceFromNode(blockedOn);

      if (_fiber2 !== null) {
        // Attempt to increase the priority of this target.
        attemptContinuousHydration(_fiber2);
      }
    }

    return queuedEvent;
  } // If we have already queued this exact event, then it's because
  // the different event systems have different DOM event listeners.
  // We can accumulate the flags, and the targetContainers, and
  // store a single event to be replayed.


  existingQueuedEvent.eventSystemFlags |= eventSystemFlags;
  var targetContainers = existingQueuedEvent.targetContainers;

  if (targetContainer !== null && targetContainers.indexOf(targetContainer) === -1) {
    targetContainers.push(targetContainer);
  }

  return existingQueuedEvent;
}

function queueIfContinuousEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent) {
  // These set relatedTarget to null because the replayed event will be treated as if we
  // moved from outside the window (no target) onto the target once it hydrates.
  // Instead of mutating we could clone the event.
  switch (domEventName) {
    case 'focusin':
      {
        var focusEvent = nativeEvent;
        queuedFocus = accumulateOrCreateContinuousQueuedReplayableEvent(queuedFocus, blockedOn, domEventName, eventSystemFlags, targetContainer, focusEvent);
        return true;
      }

    case 'dragenter':
      {
        var dragEvent = nativeEvent;
        queuedDrag = accumulateOrCreateContinuousQueuedReplayableEvent(queuedDrag, blockedOn, domEventName, eventSystemFlags, targetContainer, dragEvent);
        return true;
      }

    case 'mouseover':
      {
        var mouseEvent = nativeEvent;
        queuedMouse = accumulateOrCreateContinuousQueuedReplayableEvent(queuedMouse, blockedOn, domEventName, eventSystemFlags, targetContainer, mouseEvent);
        return true;
      }

    case 'pointerover':
      {
        var pointerEvent = nativeEvent;
        var pointerId = pointerEvent.pointerId;
        queuedPointers.set(pointerId, accumulateOrCreateContinuousQueuedReplayableEvent(queuedPointers.get(pointerId) || null, blockedOn, domEventName, eventSystemFlags, targetContainer, pointerEvent));
        return true;
      }

    case 'gotpointercapture':
      {
        var _pointerEvent = nativeEvent;
        var _pointerId2 = _pointerEvent.pointerId;
        queuedPointerCaptures.set(_pointerId2, accumulateOrCreateContinuousQueuedReplayableEvent(queuedPointerCaptures.get(_pointerId2) || null, blockedOn, domEventName, eventSystemFlags, targetContainer, _pointerEvent));
        return true;
      }
  }

  return false;
} // Check if this target is unblocked. Returns true if it's unblocked.

function attemptExplicitHydrationTarget(queuedTarget) {
  // TODO: This function shares a lot of logic with attemptToDispatchEvent.
  // Try to unify them. It's a bit tricky since it would require two return
  // values.
  var targetInst = getClosestInstanceFromNode(queuedTarget.target);

  if (targetInst !== null) {
    var nearestMounted = getNearestMountedFiber(targetInst);

    if (nearestMounted !== null) {
      var tag = nearestMounted.tag;

      if (tag === SuspenseComponent) {
        var instance = getSuspenseInstanceFromFiber(nearestMounted);

        if (instance !== null) {
          // We're blocked on hydrating this boundary.
          // Increase its priority.
          queuedTarget.blockedOn = instance;
          attemptHydrationAtPriority(queuedTarget.lanePriority, function () {
            Scheduler.unstable_runWithPriority(queuedTarget.priority, function () {
              attemptHydrationAtCurrentPriority(nearestMounted);
            });
          });
          return;
        }
      } else if (tag === HostRoot) {
        var root = nearestMounted.stateNode;

        if (root.hydrate) {
          queuedTarget.blockedOn = getContainerFromFiber(nearestMounted); // We don't currently have a way to increase the priority of
          // a root other than sync.

          return;
        }
      }
    }
  }

  queuedTarget.blockedOn = null;
}

function attemptReplayContinuousQueuedEvent(queuedEvent) {
  if (queuedEvent.blockedOn !== null) {
    return false;
  }

  var targetContainers = queuedEvent.targetContainers;

  while (targetContainers.length > 0) {
    var targetContainer = targetContainers[0];
    var nextBlockedOn = attemptToDispatchEvent(queuedEvent.domEventName, queuedEvent.eventSystemFlags, targetContainer, queuedEvent.nativeEvent);

    if (nextBlockedOn !== null) {
      // We're still blocked. Try again later.
      var _fiber3 = getInstanceFromNode(nextBlockedOn);

      if (_fiber3 !== null) {
        attemptContinuousHydration(_fiber3);
      }

      queuedEvent.blockedOn = nextBlockedOn;
      return false;
    } // This target container was successfully dispatched. Try the next.


    targetContainers.shift();
  }

  return true;
}

function attemptReplayContinuousQueuedEventInMap(queuedEvent, key, map) {
  if (attemptReplayContinuousQueuedEvent(queuedEvent)) {
    map.delete(key);
  }
}

function replayUnblockedEvents() {
  hasScheduledReplayAttempt = false; // First replay discrete events.

  while (queuedDiscreteEvents.length > 0) {
    var nextDiscreteEvent = queuedDiscreteEvents[0];

    if (nextDiscreteEvent.blockedOn !== null) {
      // We're still blocked.
      // Increase the priority of this boundary to unblock
      // the next discrete event.
      var _fiber4 = getInstanceFromNode(nextDiscreteEvent.blockedOn);

      if (_fiber4 !== null) {
        attemptUserBlockingHydration(_fiber4);
      }

      break;
    }

    var targetContainers = nextDiscreteEvent.targetContainers;

    while (targetContainers.length > 0) {
      var targetContainer = targetContainers[0];
      var nextBlockedOn = attemptToDispatchEvent(nextDiscreteEvent.domEventName, nextDiscreteEvent.eventSystemFlags, targetContainer, nextDiscreteEvent.nativeEvent);

      if (nextBlockedOn !== null) {
        // We're still blocked. Try again later.
        nextDiscreteEvent.blockedOn = nextBlockedOn;
        break;
      } // This target container was successfully dispatched. Try the next.


      targetContainers.shift();
    }

    if (nextDiscreteEvent.blockedOn === null) {
      // We've successfully replayed the first event. Let's try the next one.
      queuedDiscreteEvents.shift();
    }
  } // Next replay any continuous events.


  if (queuedFocus !== null && attemptReplayContinuousQueuedEvent(queuedFocus)) {
    queuedFocus = null;
  }

  if (queuedDrag !== null && attemptReplayContinuousQueuedEvent(queuedDrag)) {
    queuedDrag = null;
  }

  if (queuedMouse !== null && attemptReplayContinuousQueuedEvent(queuedMouse)) {
    queuedMouse = null;
  }

  queuedPointers.forEach(attemptReplayContinuousQueuedEventInMap);
  queuedPointerCaptures.forEach(attemptReplayContinuousQueuedEventInMap);
}

function scheduleCallbackIfUnblocked(queuedEvent, unblocked) {
  if (queuedEvent.blockedOn === unblocked) {
    queuedEvent.blockedOn = null;

    if (!hasScheduledReplayAttempt) {
      hasScheduledReplayAttempt = true; // Schedule a callback to attempt replaying as many events as are
      // now unblocked. This first might not actually be unblocked yet.
      // We could check it early to avoid scheduling an unnecessary callback.

      Scheduler.unstable_scheduleCallback(Scheduler.unstable_NormalPriority, replayUnblockedEvents);
    }
  }
}

function retryIfBlockedOn(unblocked) {
  // Mark anything that was blocked on this as no longer blocked
  // and eligible for a replay.
  if (queuedDiscreteEvents.length > 0) {
    scheduleCallbackIfUnblocked(queuedDiscreteEvents[0], unblocked); // This is a exponential search for each boundary that commits. I think it's
    // worth it because we expect very few discrete events to queue up and once
    // we are actually fully unblocked it will be fast to replay them.

    for (var i = 1; i < queuedDiscreteEvents.length; i++) {
      var queuedEvent = queuedDiscreteEvents[i];

      if (queuedEvent.blockedOn === unblocked) {
        queuedEvent.blockedOn = null;
      }
    }
  }

  if (queuedFocus !== null) {
    scheduleCallbackIfUnblocked(queuedFocus, unblocked);
  }

  if (queuedDrag !== null) {
    scheduleCallbackIfUnblocked(queuedDrag, unblocked);
  }

  if (queuedMouse !== null) {
    scheduleCallbackIfUnblocked(queuedMouse, unblocked);
  }

  var unblock = function (queuedEvent) {
    return scheduleCallbackIfUnblocked(queuedEvent, unblocked);
  };

  queuedPointers.forEach(unblock);
  queuedPointerCaptures.forEach(unblock);

  for (var _i = 0; _i < queuedExplicitHydrationTargets.length; _i++) {
    var queuedTarget = queuedExplicitHydrationTargets[_i];

    if (queuedTarget.blockedOn === unblocked) {
      queuedTarget.blockedOn = null;
    }
  }

  while (queuedExplicitHydrationTargets.length > 0) {
    var nextExplicitTarget = queuedExplicitHydrationTargets[0];

    if (nextExplicitTarget.blockedOn !== null) {
      // We're still blocked.
      break;
    } else {
      attemptExplicitHydrationTarget(nextExplicitTarget);

      if (nextExplicitTarget.blockedOn === null) {
        // We're unblocked.
        queuedExplicitHydrationTargets.shift();
      }
    }
  }
}

var DiscreteEvent = 0;
var UserBlockingEvent = 1;
var ContinuousEvent = 2;

/**
 * Generate a mapping of standard vendor prefixes using the defined style property and event name.
 *
 * @param {string} styleProp
 * @param {string} eventName
 * @returns {object}
 */

function makePrefixMap(styleProp, eventName) {
  var prefixes = {};
  prefixes[styleProp.toLowerCase()] = eventName.toLowerCase();
  prefixes['Webkit' + styleProp] = 'webkit' + eventName;
  prefixes['Moz' + styleProp] = 'moz' + eventName;
  return prefixes;
}
/**
 * A list of event names to a configurable list of vendor prefixes.
 */


var vendorPrefixes = {
  animationend: makePrefixMap('Animation', 'AnimationEnd'),
  animationiteration: makePrefixMap('Animation', 'AnimationIteration'),
  animationstart: makePrefixMap('Animation', 'AnimationStart'),
  transitionend: makePrefixMap('Transition', 'TransitionEnd')
};
/**
 * Event names that have already been detected and prefixed (if applicable).
 */

var prefixedEventNames = {};
/**
 * Element to check for prefixes on.
 */

var style = {};
/**
 * Bootstrap if a DOM exists.
 */

if (canUseDOM) {
  style = document.createElement('div').style; // On some platforms, in particular some releases of Android 4.x,
  // the un-prefixed "animation" and "transition" properties are defined on the
  // style object but the events that fire will still be prefixed, so we need
  // to check if the un-prefixed events are usable, and if not remove them from the map.

  if (!('AnimationEvent' in window)) {
    delete vendorPrefixes.animationend.animation;
    delete vendorPrefixes.animationiteration.animation;
    delete vendorPrefixes.animationstart.animation;
  } // Same as above


  if (!('TransitionEvent' in window)) {
    delete vendorPrefixes.transitionend.transition;
  }
}
/**
 * Attempts to determine the correct vendor prefixed event name.
 *
 * @param {string} eventName
 * @returns {string}
 */


function getVendorPrefixedEventName(eventName) {
  if (prefixedEventNames[eventName]) {
    return prefixedEventNames[eventName];
  } else if (!vendorPrefixes[eventName]) {
    return eventName;
  }

  var prefixMap = vendorPrefixes[eventName];

  for (var styleProp in prefixMap) {
    if (prefixMap.hasOwnProperty(styleProp) && styleProp in style) {
      return prefixedEventNames[eventName] = prefixMap[styleProp];
    }
  }

  return eventName;
}

var ANIMATION_END = getVendorPrefixedEventName('animationend');
var ANIMATION_ITERATION = getVendorPrefixedEventName('animationiteration');
var ANIMATION_START = getVendorPrefixedEventName('animationstart');
var TRANSITION_END = getVendorPrefixedEventName('transitionend');

var topLevelEventsToReactNames = new Map();
var eventPriorities = new Map(); // We store most of the events in this module in pairs of two strings so we can re-use
// the code required to apply the same logic for event prioritization and that of the
// SimpleEventPlugin. This complicates things slightly, but the aim is to reduce code
// duplication (for which there would be quite a bit). For the events that are not needed
// for the SimpleEventPlugin (otherDiscreteEvents) we process them separately as an
// array of top level events.
// Lastly, we ignore prettier so we can keep the formatting sane.
// prettier-ignore

var discreteEventPairsForSimpleEventPlugin = ['cancel', 'cancel', 'click', 'click', 'close', 'close', 'contextmenu', 'contextMenu', 'copy', 'copy', 'cut', 'cut', 'auxclick', 'auxClick', 'dblclick', 'doubleClick', // Careful!
'dragend', 'dragEnd', 'dragstart', 'dragStart', 'drop', 'drop', 'focusin', 'focus', // Careful!
'focusout', 'blur', // Careful!
'input', 'input', 'invalid', 'invalid', 'keydown', 'keyDown', 'keypress', 'keyPress', 'keyup', 'keyUp', 'mousedown', 'mouseDown', 'mouseup', 'mouseUp', 'paste', 'paste', 'pause', 'pause', 'play', 'play', 'pointercancel', 'pointerCancel', 'pointerdown', 'pointerDown', 'pointerup', 'pointerUp', 'ratechange', 'rateChange', 'reset', 'reset', 'seeked', 'seeked', 'submit', 'submit', 'touchcancel', 'touchCancel', 'touchend', 'touchEnd', 'touchstart', 'touchStart', 'volumechange', 'volumeChange'];
var otherDiscreteEvents = ['change', 'selectionchange', 'textInput', 'compositionstart', 'compositionend', 'compositionupdate'];


var userBlockingPairsForSimpleEventPlugin = ['drag', 'drag', 'dragenter', 'dragEnter', 'dragexit', 'dragExit', 'dragleave', 'dragLeave', 'dragover', 'dragOver', 'mousemove', 'mouseMove', 'mouseout', 'mouseOut', 'mouseover', 'mouseOver', 'pointermove', 'pointerMove', 'pointerout', 'pointerOut', 'pointerover', 'pointerOver', 'scroll', 'scroll', 'toggle', 'toggle', 'touchmove', 'touchMove', 'wheel', 'wheel']; // prettier-ignore

var continuousPairsForSimpleEventPlugin = ['abort', 'abort', ANIMATION_END, 'animationEnd', ANIMATION_ITERATION, 'animationIteration', ANIMATION_START, 'animationStart', 'canplay', 'canPlay', 'canplaythrough', 'canPlayThrough', 'durationchange', 'durationChange', 'emptied', 'emptied', 'encrypted', 'encrypted', 'ended', 'ended', 'error', 'error', 'gotpointercapture', 'gotPointerCapture', 'load', 'load', 'loadeddata', 'loadedData', 'loadedmetadata', 'loadedMetadata', 'loadstart', 'loadStart', 'lostpointercapture', 'lostPointerCapture', 'playing', 'playing', 'progress', 'progress', 'seeking', 'seeking', 'stalled', 'stalled', 'suspend', 'suspend', 'timeupdate', 'timeUpdate', TRANSITION_END, 'transitionEnd', 'waiting', 'waiting'];
/**
 * Turns
 * ['abort', ...]
 *
 * into
 *
 * topLevelEventsToReactNames = new Map([
 *   ['abort', 'onAbort'],
 * ]);
 *
 * and registers them.
 */

function registerSimplePluginEventsAndSetTheirPriorities(eventTypes, priority) {
  // As the event types are in pairs of two, we need to iterate
  // through in twos. The events are in pairs of two to save code
  // and improve init perf of processing this array, as it will
  // result in far fewer object allocations and property accesses
  // if we only use three arrays to process all the categories of
  // instead of tuples.
  for (var i = 0; i < eventTypes.length; i += 2) {
    var topEvent = eventTypes[i];
    var event = eventTypes[i + 1];
    var capitalizedEvent = event[0].toUpperCase() + event.slice(1);
    var reactName = 'on' + capitalizedEvent;
    eventPriorities.set(topEvent, priority);
    topLevelEventsToReactNames.set(topEvent, reactName);
    registerTwoPhaseEvent(reactName, [topEvent]);
  }
}

function setEventPriorities(eventTypes, priority) {
  for (var i = 0; i < eventTypes.length; i++) {
    eventPriorities.set(eventTypes[i], priority);
  }
}

function getEventPriorityForPluginSystem(domEventName) {
  var priority = eventPriorities.get(domEventName); // Default to a ContinuousEvent. Note: we might
  // want to warn if we can't detect the priority
  // for the event.

  return priority === undefined ? ContinuousEvent : priority;
}
function registerSimpleEvents() {
  registerSimplePluginEventsAndSetTheirPriorities(discreteEventPairsForSimpleEventPlugin, DiscreteEvent);
  registerSimplePluginEventsAndSetTheirPriorities(userBlockingPairsForSimpleEventPlugin, UserBlockingEvent);
  registerSimplePluginEventsAndSetTheirPriorities(continuousPairsForSimpleEventPlugin, ContinuousEvent);
  setEventPriorities(otherDiscreteEvents, DiscreteEvent);
}

var Scheduler_now = Scheduler.unstable_now;

{
  // Provide explicit error message when production+profiling bundle of e.g.
  // react-dom is used with production (non-profiling) bundle of
  // scheduler/tracing
  if (!(tracing.__interactionsRef != null && tracing.__interactionsRef.current != null)) {
    {
      throw Error( "It is not supported to run the profiling version of a renderer (for example, `react-dom/profiling`) without also replacing the `scheduler/tracing` module with `scheduler/tracing-profiling`. Your bundler might have a setting for aliasing both modules. Learn more at https://reactjs.org/link/profiling" );
    }
  }
}
// ascending numbers so we can compare them like numbers. They start at 90 to
// avoid clashing with Scheduler's priorities.

var ImmediatePriority = 99;
var UserBlockingPriority = 98;
var NormalPriority = 97;
var LowPriority = 96;
var IdlePriority = 95; // NoPriority is the absence of priority. Also React-only.

var NoPriority = 90;
var initialTimeMs = Scheduler_now(); // If the initial timestamp is reasonably small, use Scheduler's `now` directly.

var SyncLanePriority = 15;
var SyncBatchedLanePriority = 14;
var InputDiscreteHydrationLanePriority = 13;
var InputDiscreteLanePriority = 12;
var InputContinuousHydrationLanePriority = 11;
var InputContinuousLanePriority = 10;
var DefaultHydrationLanePriority = 9;
var DefaultLanePriority = 8;
var TransitionHydrationPriority = 7;
var TransitionPriority = 6;
var RetryLanePriority = 5;
var SelectiveHydrationLanePriority = 4;
var IdleHydrationLanePriority = 3;
var IdleLanePriority = 2;
var OffscreenLanePriority = 1;
var NoLanePriority = 0;
var TotalLanes = 31;
var NoLanes =
/*                        */
0;
var NoLane =
/*                          */
0;
var SyncLane =
/*                        */
1;
var SyncBatchedLane =
/*                 */
2;
var InputDiscreteHydrationLane =
/*      */
4;
var InputDiscreteLanes =
/*                    */
24;
var InputContinuousHydrationLane =
/*           */
32;
var InputContinuousLanes =
/*                  */
192;
var DefaultHydrationLane =
/*            */
256;
var DefaultLanes =
/*                   */
3584;
var TransitionHydrationLane =
/*                */
4096;
var TransitionLanes =
/*                       */
4186112;
var RetryLanes =
/*                            */
62914560;
var SomeRetryLane =
/*                  */
33554432;
var SelectiveHydrationLane =
/*          */
67108864;
var NonIdleLanes =
/*                                 */
134217727;
var IdleHydrationLane =
/*               */
134217728;
var IdleLanes =
/*                             */
805306368;
var OffscreenLane =
/*                   */
1073741824;
var NoTimestamp = -1;
function setCurrentUpdateLanePriority(newLanePriority) {
} // "Registers" used to "return" multiple values
// Used by getHighestPriorityLanes and getNextLanes:

var return_highestLanePriority = DefaultLanePriority;

function getHighestPriorityLanes(lanes) {
  if ((SyncLane & lanes) !== NoLanes) {
    return_highestLanePriority = SyncLanePriority;
    return SyncLane;
  }

  if ((SyncBatchedLane & lanes) !== NoLanes) {
    return_highestLanePriority = SyncBatchedLanePriority;
    return SyncBatchedLane;
  }

  if ((InputDiscreteHydrationLane & lanes) !== NoLanes) {
    return_highestLanePriority = InputDiscreteHydrationLanePriority;
    return InputDiscreteHydrationLane;
  }

  var inputDiscreteLanes = InputDiscreteLanes & lanes;

  if (inputDiscreteLanes !== NoLanes) {
    return_highestLanePriority = InputDiscreteLanePriority;
    return inputDiscreteLanes;
  }

  if ((lanes & InputContinuousHydrationLane) !== NoLanes) {
    return_highestLanePriority = InputContinuousHydrationLanePriority;
    return InputContinuousHydrationLane;
  }

  var inputContinuousLanes = InputContinuousLanes & lanes;

  if (inputContinuousLanes !== NoLanes) {
    return_highestLanePriority = InputContinuousLanePriority;
    return inputContinuousLanes;
  }

  if ((lanes & DefaultHydrationLane) !== NoLanes) {
    return_highestLanePriority = DefaultHydrationLanePriority;
    return DefaultHydrationLane;
  }

  var defaultLanes = DefaultLanes & lanes;

  if (defaultLanes !== NoLanes) {
    return_highestLanePriority = DefaultLanePriority;
    return defaultLanes;
  }

  if ((lanes & TransitionHydrationLane) !== NoLanes) {
    return_highestLanePriority = TransitionHydrationPriority;
    return TransitionHydrationLane;
  }

  var transitionLanes = TransitionLanes & lanes;

  if (transitionLanes !== NoLanes) {
    return_highestLanePriority = TransitionPriority;
    return transitionLanes;
  }

  var retryLanes = RetryLanes & lanes;

  if (retryLanes !== NoLanes) {
    return_highestLanePriority = RetryLanePriority;
    return retryLanes;
  }

  if (lanes & SelectiveHydrationLane) {
    return_highestLanePriority = SelectiveHydrationLanePriority;
    return SelectiveHydrationLane;
  }

  if ((lanes & IdleHydrationLane) !== NoLanes) {
    return_highestLanePriority = IdleHydrationLanePriority;
    return IdleHydrationLane;
  }

  var idleLanes = IdleLanes & lanes;

  if (idleLanes !== NoLanes) {
    return_highestLanePriority = IdleLanePriority;
    return idleLanes;
  }

  if ((OffscreenLane & lanes) !== NoLanes) {
    return_highestLanePriority = OffscreenLanePriority;
    return OffscreenLane;
  }

  {
    error('Should have found matching lanes. This is a bug in React.');
  } // This shouldn't be reachable, but as a fallback, return the entire bitmask.


  return_highestLanePriority = DefaultLanePriority;
  return lanes;
}

function schedulerPriorityToLanePriority(schedulerPriorityLevel) {
  switch (schedulerPriorityLevel) {
    case ImmediatePriority:
      return SyncLanePriority;

    case UserBlockingPriority:
      return InputContinuousLanePriority;

    case NormalPriority:
    case LowPriority:
      // TODO: Handle LowSchedulerPriority, somehow. Maybe the same lane as hydration.
      return DefaultLanePriority;

    case IdlePriority:
      return IdleLanePriority;

    default:
      return NoLanePriority;
  }
}
function lanePriorityToSchedulerPriority(lanePriority) {
  switch (lanePriority) {
    case SyncLanePriority:
    case SyncBatchedLanePriority:
      return ImmediatePriority;

    case InputDiscreteHydrationLanePriority:
    case InputDiscreteLanePriority:
    case InputContinuousHydrationLanePriority:
    case InputContinuousLanePriority:
      return UserBlockingPriority;

    case DefaultHydrationLanePriority:
    case DefaultLanePriority:
    case TransitionHydrationPriority:
    case TransitionPriority:
    case SelectiveHydrationLanePriority:
    case RetryLanePriority:
      return NormalPriority;

    case IdleHydrationLanePriority:
    case IdleLanePriority:
    case OffscreenLanePriority:
      return IdlePriority;

    case NoLanePriority:
      return NoPriority;

    default:
      {
        {
          throw Error( "Invalid update priority: " + lanePriority + ". This is a bug in React." );
        }
      }

  }
}
function getNextLanes(root, wipLanes) {
  // Early bailout if there's no pending work left.
  var pendingLanes = root.pendingLanes;

  if (pendingLanes === NoLanes) {
    return_highestLanePriority = NoLanePriority;
    return NoLanes;
  }

  var nextLanes = NoLanes;
  var nextLanePriority = NoLanePriority;
  var expiredLanes = root.expiredLanes;
  var suspendedLanes = root.suspendedLanes;
  var pingedLanes = root.pingedLanes; // Check if any work has expired.

  if (expiredLanes !== NoLanes) {
    nextLanes = expiredLanes;
    nextLanePriority = return_highestLanePriority = SyncLanePriority;
  } else {
    // Do not work on any idle work until all the non-idle work has finished,
    // even if the work is suspended.
    var nonIdlePendingLanes = pendingLanes & NonIdleLanes;

    if (nonIdlePendingLanes !== NoLanes) {
      var nonIdleUnblockedLanes = nonIdlePendingLanes & ~suspendedLanes;

      if (nonIdleUnblockedLanes !== NoLanes) {
        nextLanes = getHighestPriorityLanes(nonIdleUnblockedLanes);
        nextLanePriority = return_highestLanePriority;
      } else {
        var nonIdlePingedLanes = nonIdlePendingLanes & pingedLanes;

        if (nonIdlePingedLanes !== NoLanes) {
          nextLanes = getHighestPriorityLanes(nonIdlePingedLanes);
          nextLanePriority = return_highestLanePriority;
        }
      }
    } else {
      // The only remaining work is Idle.
      var unblockedLanes = pendingLanes & ~suspendedLanes;

      if (unblockedLanes !== NoLanes) {
        nextLanes = getHighestPriorityLanes(unblockedLanes);
        nextLanePriority = return_highestLanePriority;
      } else {
        if (pingedLanes !== NoLanes) {
          nextLanes = getHighestPriorityLanes(pingedLanes);
          nextLanePriority = return_highestLanePriority;
        }
      }
    }
  }

  if (nextLanes === NoLanes) {
    // This should only be reachable if we're suspended
    // TODO: Consider warning in this path if a fallback timer is not scheduled.
    return NoLanes;
  } // If there are higher priority lanes, we'll include them even if they
  // are suspended.


  nextLanes = pendingLanes & getEqualOrHigherPriorityLanes(nextLanes); // If we're already in the middle of a render, switching lanes will interrupt
  // it and we'll lose our progress. We should only do this if the new lanes are
  // higher priority.

  if (wipLanes !== NoLanes && wipLanes !== nextLanes && // If we already suspended with a delay, then interrupting is fine. Don't
  // bother waiting until the root is complete.
  (wipLanes & suspendedLanes) === NoLanes) {
    getHighestPriorityLanes(wipLanes);
    var wipLanePriority = return_highestLanePriority;

    if (nextLanePriority <= wipLanePriority) {
      return wipLanes;
    } else {
      return_highestLanePriority = nextLanePriority;
    }
  } // Check for entangled lanes and add them to the batch.
  //
  // A lane is said to be entangled with another when it's not allowed to render
  // in a batch that does not also include the other lane. Typically we do this
  // when multiple updates have the same source, and we only want to respond to
  // the most recent event from that source.
  //
  // Note that we apply entanglements *after* checking for partial work above.
  // This means that if a lane is entangled during an interleaved event while
  // it's already rendering, we won't interrupt it. This is intentional, since
  // entanglement is usually "best effort": we'll try our best to render the
  // lanes in the same batch, but it's not worth throwing out partially
  // completed work in order to do it.
  //
  // For those exceptions where entanglement is semantically important, like
  // useMutableSource, we should ensure that there is no partial work at the
  // time we apply the entanglement.


  var entangledLanes = root.entangledLanes;

  if (entangledLanes !== NoLanes) {
    var entanglements = root.entanglements;
    var lanes = nextLanes & entangledLanes;

    while (lanes > 0) {
      var index = pickArbitraryLaneIndex(lanes);
      var lane = 1 << index;
      nextLanes |= entanglements[index];
      lanes &= ~lane;
    }
  }

  return nextLanes;
}
function getMostRecentEventTime(root, lanes) {
  var eventTimes = root.eventTimes;
  var mostRecentEventTime = NoTimestamp;

  while (lanes > 0) {
    var index = pickArbitraryLaneIndex(lanes);
    var lane = 1 << index;
    var eventTime = eventTimes[index];

    if (eventTime > mostRecentEventTime) {
      mostRecentEventTime = eventTime;
    }

    lanes &= ~lane;
  }

  return mostRecentEventTime;
}

function computeExpirationTime(lane, currentTime) {
  // TODO: Expiration heuristic is constant per lane, so could use a map.
  getHighestPriorityLanes(lane);
  var priority = return_highestLanePriority;

  if (priority >= InputContinuousLanePriority) {
    // User interactions should expire slightly more quickly.
    //
    // NOTE: This is set to the corresponding constant as in Scheduler.js. When
    // we made it larger, a product metric in www regressed, suggesting there's
    // a user interaction that's being starved by a series of synchronous
    // updates. If that theory is correct, the proper solution is to fix the
    // starvation. However, this scenario supports the idea that expiration
    // times are an important safeguard when starvation does happen.
    //
    // Also note that, in the case of user input specifically, this will soon no
    // longer be an issue because we plan to make user input synchronous by
    // default (until you enter `startTransition`, of course.)
    //
    // If weren't planning to make these updates synchronous soon anyway, I
    // would probably make this number a configurable parameter.
    return currentTime + 250;
  } else if (priority >= TransitionPriority) {
    return currentTime + 5000;
  } else {
    // Anything idle priority or lower should never expire.
    return NoTimestamp;
  }
}

function markStarvedLanesAsExpired(root, currentTime) {
  // TODO: This gets called every time we yield. We can optimize by storing
  // the earliest expiration time on the root. Then use that to quickly bail out
  // of this function.
  var pendingLanes = root.pendingLanes;
  var suspendedLanes = root.suspendedLanes;
  var pingedLanes = root.pingedLanes;
  var expirationTimes = root.expirationTimes; // Iterate through the pending lanes and check if we've reached their
  // expiration time. If so, we'll assume the update is being starved and mark
  // it as expired to force it to finish.

  var lanes = pendingLanes;

  while (lanes > 0) {
    var index = pickArbitraryLaneIndex(lanes);
    var lane = 1 << index;
    var expirationTime = expirationTimes[index];

    if (expirationTime === NoTimestamp) {
      // Found a pending lane with no expiration time. If it's not suspended, or
      // if it's pinged, assume it's CPU-bound. Compute a new expiration time
      // using the current time.
      if ((lane & suspendedLanes) === NoLanes || (lane & pingedLanes) !== NoLanes) {
        // Assumes timestamps are monotonically increasing.
        expirationTimes[index] = computeExpirationTime(lane, currentTime);
      }
    } else if (expirationTime <= currentTime) {
      // This lane expired
      root.expiredLanes |= lane;
    }

    lanes &= ~lane;
  }
} // This returns the highest priority pending lanes regardless of whether they
function getLanesToRetrySynchronouslyOnError(root) {
  var everythingButOffscreen = root.pendingLanes & ~OffscreenLane;

  if (everythingButOffscreen !== NoLanes) {
    return everythingButOffscreen;
  }

  if (everythingButOffscreen & OffscreenLane) {
    return OffscreenLane;
  }

  return NoLanes;
}
function returnNextLanesPriority() {
  return return_highestLanePriority;
}
function includesNonIdleWork(lanes) {
  return (lanes & NonIdleLanes) !== NoLanes;
}
function includesOnlyRetries(lanes) {
  return (lanes & RetryLanes) === lanes;
}
function includesOnlyTransitions(lanes) {
  return (lanes & TransitionLanes) === lanes;
} // To ensure consistency across multiple updates in the same event, this should
// be a pure function, so that it always returns the same lane for given inputs.

function findUpdateLane(lanePriority, wipLanes) {
  switch (lanePriority) {
    case NoLanePriority:
      break;

    case SyncLanePriority:
      return SyncLane;

    case SyncBatchedLanePriority:
      return SyncBatchedLane;

    case InputDiscreteLanePriority:
      {
        var _lane = pickArbitraryLane(InputDiscreteLanes & ~wipLanes);

        if (_lane === NoLane) {
          // Shift to the next priority level
          return findUpdateLane(InputContinuousLanePriority, wipLanes);
        }

        return _lane;
      }

    case InputContinuousLanePriority:
      {
        var _lane2 = pickArbitraryLane(InputContinuousLanes & ~wipLanes);

        if (_lane2 === NoLane) {
          // Shift to the next priority level
          return findUpdateLane(DefaultLanePriority, wipLanes);
        }

        return _lane2;
      }

    case DefaultLanePriority:
      {
        var _lane3 = pickArbitraryLane(DefaultLanes & ~wipLanes);

        if (_lane3 === NoLane) {
          // If all the default lanes are already being worked on, look for a
          // lane in the transition range.
          _lane3 = pickArbitraryLane(TransitionLanes & ~wipLanes);

          if (_lane3 === NoLane) {
            // All the transition lanes are taken, too. This should be very
            // rare, but as a last resort, pick a default lane. This will have
            // the effect of interrupting the current work-in-progress render.
            _lane3 = pickArbitraryLane(DefaultLanes);
          }
        }

        return _lane3;
      }

    case TransitionPriority: // Should be handled by findTransitionLane instead

    case RetryLanePriority:
      // Should be handled by findRetryLane instead
      break;

    case IdleLanePriority:
      var lane = pickArbitraryLane(IdleLanes & ~wipLanes);

      if (lane === NoLane) {
        lane = pickArbitraryLane(IdleLanes);
      }

      return lane;
  }

  {
    {
      throw Error( "Invalid update priority: " + lanePriority + ". This is a bug in React." );
    }
  }
} // To ensure consistency across multiple updates in the same event, this should
// be pure function, so that it always returns the same lane for given inputs.

function findTransitionLane(wipLanes, pendingLanes) {
  // First look for lanes that are completely unclaimed, i.e. have no
  // pending work.
  var lane = pickArbitraryLane(TransitionLanes & ~pendingLanes);

  if (lane === NoLane) {
    // If all lanes have pending work, look for a lane that isn't currently
    // being worked on.
    lane = pickArbitraryLane(TransitionLanes & ~wipLanes);

    if (lane === NoLane) {
      // If everything is being worked on, pick any lane. This has the
      // effect of interrupting the current work-in-progress.
      lane = pickArbitraryLane(TransitionLanes);
    }
  }

  return lane;
} // To ensure consistency across multiple updates in the same event, this should
// be pure function, so that it always returns the same lane for given inputs.

function findRetryLane(wipLanes) {
  // This is a fork of `findUpdateLane` designed specifically for Suspense
  // "retries" — a special update that attempts to flip a Suspense boundary
  // from its placeholder state to its primary/resolved state.
  var lane = pickArbitraryLane(RetryLanes & ~wipLanes);

  if (lane === NoLane) {
    lane = pickArbitraryLane(RetryLanes);
  }

  return lane;
}

function getHighestPriorityLane(lanes) {
  return lanes & -lanes;
}

function getLowestPriorityLane(lanes) {
  // This finds the most significant non-zero bit.
  var index = 31 - clz32(lanes);
  return index < 0 ? NoLanes : 1 << index;
}

function getEqualOrHigherPriorityLanes(lanes) {
  return (getLowestPriorityLane(lanes) << 1) - 1;
}

function pickArbitraryLane(lanes) {
  // This wrapper function gets inlined. Only exists so to communicate that it
  // doesn't matter which bit is selected; you can pick any bit without
  // affecting the algorithms where its used. Here I'm using
  // getHighestPriorityLane because it requires the fewest operations.
  return getHighestPriorityLane(lanes);
}

function pickArbitraryLaneIndex(lanes) {
  return 31 - clz32(lanes);
}

function laneToIndex(lane) {
  return pickArbitraryLaneIndex(lane);
}

function includesSomeLane(a, b) {
  return (a & b) !== NoLanes;
}
function isSubsetOfLanes(set, subset) {
  return (set & subset) === subset;
}
function mergeLanes(a, b) {
  return a | b;
}
function removeLanes(set, subset) {
  return set & ~subset;
} // Seems redundant, but it changes the type from a single lane (used for
// updates) to a group of lanes (used for flushing work).

function laneToLanes(lane) {
  return lane;
}
function higherPriorityLane(a, b) {
  // This works because the bit ranges decrease in priority as you go left.
  return a !== NoLane && a < b ? a : b;
}
function createLaneMap(initial) {
  // Intentionally pushing one by one.
  // https://v8.dev/blog/elements-kinds#avoid-creating-holes
  var laneMap = [];

  for (var i = 0; i < TotalLanes; i++) {
    laneMap.push(initial);
  }

  return laneMap;
}
function markRootUpdated(root, updateLane, eventTime) {
  root.pendingLanes |= updateLane; // TODO: Theoretically, any update to any lane can unblock any other lane. But
  // it's not practical to try every single possible combination. We need a
  // heuristic to decide which lanes to attempt to render, and in which batches.
  // For now, we use the same heuristic as in the old ExpirationTimes model:
  // retry any lane at equal or lower priority, but don't try updates at higher
  // priority without also including the lower priority updates. This works well
  // when considering updates across different priority levels, but isn't
  // sufficient for updates within the same priority, since we want to treat
  // those updates as parallel.
  // Unsuspend any update at equal or lower priority.

  var higherPriorityLanes = updateLane - 1; // Turns 0b1000 into 0b0111

  root.suspendedLanes &= higherPriorityLanes;
  root.pingedLanes &= higherPriorityLanes;
  var eventTimes = root.eventTimes;
  var index = laneToIndex(updateLane); // We can always overwrite an existing timestamp because we prefer the most
  // recent event, and we assume time is monotonically increasing.

  eventTimes[index] = eventTime;
}
function markRootSuspended(root, suspendedLanes) {
  root.suspendedLanes |= suspendedLanes;
  root.pingedLanes &= ~suspendedLanes; // The suspended lanes are no longer CPU-bound. Clear their expiration times.

  var expirationTimes = root.expirationTimes;
  var lanes = suspendedLanes;

  while (lanes > 0) {
    var index = pickArbitraryLaneIndex(lanes);
    var lane = 1 << index;
    expirationTimes[index] = NoTimestamp;
    lanes &= ~lane;
  }
}
function markRootPinged(root, pingedLanes, eventTime) {
  root.pingedLanes |= root.suspendedLanes & pingedLanes;
}
function markDiscreteUpdatesExpired(root) {
  root.expiredLanes |= InputDiscreteLanes & root.pendingLanes;
}
function hasDiscreteLanes(lanes) {
  return (lanes & InputDiscreteLanes) !== NoLanes;
}
function markRootMutableRead(root, updateLane) {
  root.mutableReadLanes |= updateLane & root.pendingLanes;
}
function markRootFinished(root, remainingLanes) {
  var noLongerPendingLanes = root.pendingLanes & ~remainingLanes;
  root.pendingLanes = remainingLanes; // Let's try everything again

  root.suspendedLanes = 0;
  root.pingedLanes = 0;
  root.expiredLanes &= remainingLanes;
  root.mutableReadLanes &= remainingLanes;
  root.entangledLanes &= remainingLanes;
  var entanglements = root.entanglements;
  var eventTimes = root.eventTimes;
  var expirationTimes = root.expirationTimes; // Clear the lanes that no longer have pending work

  var lanes = noLongerPendingLanes;

  while (lanes > 0) {
    var index = pickArbitraryLaneIndex(lanes);
    var lane = 1 << index;
    entanglements[index] = NoLanes;
    eventTimes[index] = NoTimestamp;
    expirationTimes[index] = NoTimestamp;
    lanes &= ~lane;
  }
}
function markRootEntangled(root, entangledLanes) {
  root.entangledLanes |= entangledLanes;
  var entanglements = root.entanglements;
  var lanes = entangledLanes;

  while (lanes > 0) {
    var index = pickArbitraryLaneIndex(lanes);
    var lane = 1 << index;
    entanglements[index] |= entangledLanes;
    lanes &= ~lane;
  }
}
var clz32 = Math.clz32 ? Math.clz32 : clz32Fallback; // Count leading zeros. Only used on lanes, so assume input is an integer.
// Based on:
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/clz32

var log = Math.log;
var LN2 = Math.LN2;

function clz32Fallback(lanes) {
  if (lanes === 0) {
    return 32;
  }

  return 31 - (log(lanes) / LN2 | 0) | 0;
}

// Intentionally not named imports because Rollup would use dynamic dispatch for
var UserBlockingPriority$1 = Scheduler.unstable_UserBlockingPriority,
    runWithPriority = Scheduler.unstable_runWithPriority; // TODO: can we stop exporting these?

var _enabled = true; // This is exported in FB builds for use by legacy FB layer infra.
// We'd like to remove this but it's not clear if this is safe.

function setEnabled(enabled) {
  _enabled = !!enabled;
}
function isEnabled() {
  return _enabled;
}
function createEventListenerWrapperWithPriority(targetContainer, domEventName, eventSystemFlags) {
  var eventPriority = getEventPriorityForPluginSystem(domEventName);
  var listenerWrapper;

  switch (eventPriority) {
    case DiscreteEvent:
      listenerWrapper = dispatchDiscreteEvent;
      break;

    case UserBlockingEvent:
      listenerWrapper = dispatchUserBlockingUpdate;
      break;

    case ContinuousEvent:
    default:
      listenerWrapper = dispatchEvent;
      break;
  }

  return listenerWrapper.bind(null, domEventName, eventSystemFlags, targetContainer);
}

function dispatchDiscreteEvent(domEventName, eventSystemFlags, container, nativeEvent) {
  {
    flushDiscreteUpdatesIfNeeded(nativeEvent.timeStamp);
  }

  discreteUpdates(dispatchEvent, domEventName, eventSystemFlags, container, nativeEvent);
}

function dispatchUserBlockingUpdate(domEventName, eventSystemFlags, container, nativeEvent) {
  {
    runWithPriority(UserBlockingPriority$1, dispatchEvent.bind(null, domEventName, eventSystemFlags, container, nativeEvent));
  }
}

function dispatchEvent(domEventName, eventSystemFlags, targetContainer, nativeEvent) {
  if (!_enabled) {
    return;
  }

  var allowReplay = true;

  {
    // TODO: replaying capture phase events is currently broken
    // because we used to do it during top-level native bubble handlers
    // but now we use different bubble and capture handlers.
    // In eager mode, we attach capture listeners early, so we need
    // to filter them out until we fix the logic to handle them correctly.
    // This could've been outside the flag but I put it inside to reduce risk.
    allowReplay = (eventSystemFlags & IS_CAPTURE_PHASE) === 0;
  }

  if (allowReplay && hasQueuedDiscreteEvents() && isReplayableDiscreteEvent(domEventName)) {
    // If we already have a queue of discrete events, and this is another discrete
    // event, then we can't dispatch it regardless of its target, since they
    // need to dispatch in order.
    queueDiscreteEvent(null, // Flags that we're not actually blocked on anything as far as we know.
    domEventName, eventSystemFlags, targetContainer, nativeEvent);
    return;
  }

  var blockedOn = attemptToDispatchEvent(domEventName, eventSystemFlags, targetContainer, nativeEvent);

  if (blockedOn === null) {
    // We successfully dispatched this event.
    if (allowReplay) {
      clearIfContinuousEvent(domEventName, nativeEvent);
    }

    return;
  }

  if (allowReplay) {
    if (isReplayableDiscreteEvent(domEventName)) {
      // This this to be replayed later once the target is available.
      queueDiscreteEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent);
      return;
    }

    if (queueIfContinuousEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent)) {
      return;
    } // We need to clear only if we didn't queue because
    // queueing is accummulative.


    clearIfContinuousEvent(domEventName, nativeEvent);
  } // This is not replayable so we'll invoke it but without a target,
  // in case the event system needs to trace it.


  dispatchEventForPluginEventSystem(domEventName, eventSystemFlags, nativeEvent, null, targetContainer);
} // Attempt dispatching an event. Returns a SuspenseInstance or Container if it's blocked.

function attemptToDispatchEvent(domEventName, eventSystemFlags, targetContainer, nativeEvent) {
  // TODO: Warn if _enabled is false.
  var nativeEventTarget = getEventTarget(nativeEvent);
  var targetInst = getClosestInstanceFromNode(nativeEventTarget);

  if (targetInst !== null) {
    var nearestMounted = getNearestMountedFiber(targetInst);

    if (nearestMounted === null) {
      // This tree has been unmounted already. Dispatch without a target.
      targetInst = null;
    } else {
      var tag = nearestMounted.tag;

      if (tag === SuspenseComponent) {
        var instance = getSuspenseInstanceFromFiber(nearestMounted);

        if (instance !== null) {
          // Queue the event to be replayed later. Abort dispatching since we
          // don't want this event dispatched twice through the event system.
          // TODO: If this is the first discrete event in the queue. Schedule an increased
          // priority for this boundary.
          return instance;
        } // This shouldn't happen, something went wrong but to avoid blocking
        // the whole system, dispatch the event without a target.
        // TODO: Warn.


        targetInst = null;
      } else if (tag === HostRoot) {
        var root = nearestMounted.stateNode;

        if (root.hydrate) {
          // If this happens during a replay something went wrong and it might block
          // the whole system.
          return getContainerFromFiber(nearestMounted);
        }

        targetInst = null;
      } else if (nearestMounted !== targetInst) {
        // If we get an event (ex: img onload) before committing that
        // component's mount, ignore it for now (that is, treat it as if it was an
        // event on a non-React tree). We might also consider queueing events and
        // dispatching them after the mount.
        targetInst = null;
      }
    }
  }

  dispatchEventForPluginEventSystem(domEventName, eventSystemFlags, nativeEvent, targetInst, targetContainer); // We're not blocked on anything.

  return null;
}

function addEventBubbleListener(target, eventType, listener) {
  target.addEventListener(eventType, listener, false);
  return listener;
}
function addEventCaptureListener(target, eventType, listener) {
  target.addEventListener(eventType, listener, true);
  return listener;
}
function addEventCaptureListenerWithPassiveFlag(target, eventType, listener, passive) {
  target.addEventListener(eventType, listener, {
    capture: true,
    passive: passive
  });
  return listener;
}
function addEventBubbleListenerWithPassiveFlag(target, eventType, listener, passive) {
  target.addEventListener(eventType, listener, {
    passive: passive
  });
  return listener;
}

/**
 * These variables store information about text content of a target node,
 * allowing comparison of content before and after a given event.
 *
 * Identify the node where selection currently begins, then observe
 * both its text content and its current position in the DOM. Since the
 * browser may natively replace the target node during composition, we can
 * use its position to find its replacement.
 *
 *
 */
var root = null;
var startText = null;
var fallbackText = null;
function initialize(nativeEventTarget) {
  root = nativeEventTarget;
  startText = getText();
  return true;
}
function reset() {
  root = null;
  startText = null;
  fallbackText = null;
}
function getData() {
  if (fallbackText) {
    return fallbackText;
  }

  var start;
  var startValue = startText;
  var startLength = startValue.length;
  var end;
  var endValue = getText();
  var endLength = endValue.length;

  for (start = 0; start < startLength; start++) {
    if (startValue[start] !== endValue[start]) {
      break;
    }
  }

  var minEnd = startLength - start;

  for (end = 1; end <= minEnd; end++) {
    if (startValue[startLength - end] !== endValue[endLength - end]) {
      break;
    }
  }

  var sliceTail = end > 1 ? 1 - end : undefined;
  fallbackText = endValue.slice(start, sliceTail);
  return fallbackText;
}
function getText() {
  if ('value' in root) {
    return root.value;
  }

  return root.textContent;
}

/**
 * `charCode` represents the actual "character code" and is safe to use with
 * `String.fromCharCode`. As such, only keys that correspond to printable
 * characters produce a valid `charCode`, the only exception to this is Enter.
 * The Tab-key is considered non-printable and does not have a `charCode`,
 * presumably because it does not produce a tab-character in browsers.
 *
 * @param {object} nativeEvent Native browser event.
 * @return {number} Normalized `charCode` property.
 */
function getEventCharCode(nativeEvent) {
  var charCode;
  var keyCode = nativeEvent.keyCode;

  if ('charCode' in nativeEvent) {
    charCode = nativeEvent.charCode; // FF does not set `charCode` for the Enter-key, check against `keyCode`.

    if (charCode === 0 && keyCode === 13) {
      charCode = 13;
    }
  } else {
    // IE8 does not implement `charCode`, but `keyCode` has the correct value.
    charCode = keyCode;
  } // IE and Edge (on Windows) and Chrome / Safari (on Windows and Linux)
  // report Enter as charCode 10 when ctrl is pressed.


  if (charCode === 10) {
    charCode = 13;
  } // Some non-printable keys are reported in `charCode`/`keyCode`, discard them.
  // Must not discard the (non-)printable Enter-key.


  if (charCode >= 32 || charCode === 13) {
    return charCode;
  }

  return 0;
}

function functionThatReturnsTrue() {
  return true;
}

function functionThatReturnsFalse() {
  return false;
} // This is intentionally a factory so that we have different returned constructors.
// If we had a single constructor, it would be megamorphic and engines would deopt.


function createSyntheticEvent(Interface) {
  /**
   * Synthetic events are dispatched by event plugins, typically in response to a
   * top-level event delegation handler.
   *
   * These systems should generally use pooling to reduce the frequency of garbage
   * collection. The system should check `isPersistent` to determine whether the
   * event should be released into the pool after being dispatched. Users that
   * need a persisted event should invoke `persist`.
   *
   * Synthetic events (and subclasses) implement the DOM Level 3 Events API by
   * normalizing browser quirks. Subclasses do not necessarily have to implement a
   * DOM interface; custom application-specific events can also subclass this.
   */
  function SyntheticBaseEvent(reactName, reactEventType, targetInst, nativeEvent, nativeEventTarget) {
    this._reactName = reactName;
    this._targetInst = targetInst;
    this.type = reactEventType;
    this.nativeEvent = nativeEvent;
    this.target = nativeEventTarget;
    this.currentTarget = null;

    for (var _propName in Interface) {
      if (!Interface.hasOwnProperty(_propName)) {
        continue;
      }

      var normalize = Interface[_propName];

      if (normalize) {
        this[_propName] = normalize(nativeEvent);
      } else {
        this[_propName] = nativeEvent[_propName];
      }
    }

    var defaultPrevented = nativeEvent.defaultPrevented != null ? nativeEvent.defaultPrevented : nativeEvent.returnValue === false;

    if (defaultPrevented) {
      this.isDefaultPrevented = functionThatReturnsTrue;
    } else {
      this.isDefaultPrevented = functionThatReturnsFalse;
    }

    this.isPropagationStopped = functionThatReturnsFalse;
    return this;
  }

  _assign(SyntheticBaseEvent.prototype, {
    preventDefault: function () {
      this.defaultPrevented = true;
      var event = this.nativeEvent;

      if (!event) {
        return;
      }

      if (event.preventDefault) {
        event.preventDefault(); // $FlowFixMe - flow is not aware of `unknown` in IE
      } else if (typeof event.returnValue !== 'unknown') {
        event.returnValue = false;
      }

      this.isDefaultPrevented = functionThatReturnsTrue;
    },
    stopPropagation: function () {
      var event = this.nativeEvent;

      if (!event) {
        return;
      }

      if (event.stopPropagation) {
        event.stopPropagation(); // $FlowFixMe - flow is not aware of `unknown` in IE
      } else if (typeof event.cancelBubble !== 'unknown') {
        // The ChangeEventPlugin registers a "propertychange" event for
        // IE. This event does not support bubbling or cancelling, and
        // any references to cancelBubble throw "Member not found".  A
        // typeof check of "unknown" circumvents this issue (and is also
        // IE specific).
        event.cancelBubble = true;
      }

      this.isPropagationStopped = functionThatReturnsTrue;
    },

    /**
     * We release all dispatched `SyntheticEvent`s after each event loop, adding
     * them back into the pool. This allows a way to hold onto a reference that
     * won't be added back into the pool.
     */
    persist: function () {// Modern event system doesn't use pooling.
    },

    /**
     * Checks if this event should be released back into the pool.
     *
     * @return {boolean} True if this should not be released, false otherwise.
     */
    isPersistent: functionThatReturnsTrue
  });

  return SyntheticBaseEvent;
}
/**
 * @interface Event
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */


var EventInterface = {
  eventPhase: 0,
  bubbles: 0,
  cancelable: 0,
  timeStamp: function (event) {
    return event.timeStamp || Date.now();
  },
  defaultPrevented: 0,
  isTrusted: 0
};
var SyntheticEvent = createSyntheticEvent(EventInterface);

var UIEventInterface = _assign({}, EventInterface, {
  view: 0,
  detail: 0
});

var SyntheticUIEvent = createSyntheticEvent(UIEventInterface);
var lastMovementX;
var lastMovementY;
var lastMouseEvent;

function updateMouseMovementPolyfillState(event) {
  if (event !== lastMouseEvent) {
    if (lastMouseEvent && event.type === 'mousemove') {
      lastMovementX = event.screenX - lastMouseEvent.screenX;
      lastMovementY = event.screenY - lastMouseEvent.screenY;
    } else {
      lastMovementX = 0;
      lastMovementY = 0;
    }

    lastMouseEvent = event;
  }
}
/**
 * @interface MouseEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */


var MouseEventInterface = _assign({}, UIEventInterface, {
  screenX: 0,
  screenY: 0,
  clientX: 0,
  clientY: 0,
  pageX: 0,
  pageY: 0,
  ctrlKey: 0,
  shiftKey: 0,
  altKey: 0,
  metaKey: 0,
  getModifierState: getEventModifierState,
  button: 0,
  buttons: 0,
  relatedTarget: function (event) {
    if (event.relatedTarget === undefined) return event.fromElement === event.srcElement ? event.toElement : event.fromElement;
    return event.relatedTarget;
  },
  movementX: function (event) {
    if ('movementX' in event) {
      return event.movementX;
    }

    updateMouseMovementPolyfillState(event);
    return lastMovementX;
  },
  movementY: function (event) {
    if ('movementY' in event) {
      return event.movementY;
    } // Don't need to call updateMouseMovementPolyfillState() here
    // because it's guaranteed to have already run when movementX
    // was copied.


    return lastMovementY;
  }
});

var SyntheticMouseEvent = createSyntheticEvent(MouseEventInterface);
/**
 * @interface DragEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */

var DragEventInterface = _assign({}, MouseEventInterface, {
  dataTransfer: 0
});

var SyntheticDragEvent = createSyntheticEvent(DragEventInterface);
/**
 * @interface FocusEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */

var FocusEventInterface = _assign({}, UIEventInterface, {
  relatedTarget: 0
});

var SyntheticFocusEvent = createSyntheticEvent(FocusEventInterface);
/**
 * @interface Event
 * @see http://www.w3.org/TR/css3-animations/#AnimationEvent-interface
 * @see https://developer.mozilla.org/en-US/docs/Web/API/AnimationEvent
 */

var AnimationEventInterface = _assign({}, EventInterface, {
  animationName: 0,
  elapsedTime: 0,
  pseudoElement: 0
});

var SyntheticAnimationEvent = createSyntheticEvent(AnimationEventInterface);
/**
 * @interface Event
 * @see http://www.w3.org/TR/clipboard-apis/
 */

var ClipboardEventInterface = _assign({}, EventInterface, {
  clipboardData: function (event) {
    return 'clipboardData' in event ? event.clipboardData : window.clipboardData;
  }
});

var SyntheticClipboardEvent = createSyntheticEvent(ClipboardEventInterface);
/**
 * @interface Event
 * @see http://www.w3.org/TR/DOM-Level-3-Events/#events-compositionevents
 */

var CompositionEventInterface = _assign({}, EventInterface, {
  data: 0
});

var SyntheticCompositionEvent = createSyntheticEvent(CompositionEventInterface);
/**
 * @interface Event
 * @see http://www.w3.org/TR/2013/WD-DOM-Level-3-Events-20131105
 *      /#events-inputevents
 */
// Happens to share the same list for now.

var SyntheticInputEvent = SyntheticCompositionEvent;
/**
 * Normalization of deprecated HTML5 `key` values
 * @see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent#Key_names
 */

var normalizeKey = {
  Esc: 'Escape',
  Spacebar: ' ',
  Left: 'ArrowLeft',
  Up: 'ArrowUp',
  Right: 'ArrowRight',
  Down: 'ArrowDown',
  Del: 'Delete',
  Win: 'OS',
  Menu: 'ContextMenu',
  Apps: 'ContextMenu',
  Scroll: 'ScrollLock',
  MozPrintableKey: 'Unidentified'
};
/**
 * Translation from legacy `keyCode` to HTML5 `key`
 * Only special keys supported, all others depend on keyboard layout or browser
 * @see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent#Key_names
 */

var translateToKey = {
  '8': 'Backspace',
  '9': 'Tab',
  '12': 'Clear',
  '13': 'Enter',
  '16': 'Shift',
  '17': 'Control',
  '18': 'Alt',
  '19': 'Pause',
  '20': 'CapsLock',
  '27': 'Escape',
  '32': ' ',
  '33': 'PageUp',
  '34': 'PageDown',
  '35': 'End',
  '36': 'Home',
  '37': 'ArrowLeft',
  '38': 'ArrowUp',
  '39': 'ArrowRight',
  '40': 'ArrowDown',
  '45': 'Insert',
  '46': 'Delete',
  '112': 'F1',
  '113': 'F2',
  '114': 'F3',
  '115': 'F4',
  '116': 'F5',
  '117': 'F6',
  '118': 'F7',
  '119': 'F8',
  '120': 'F9',
  '121': 'F10',
  '122': 'F11',
  '123': 'F12',
  '144': 'NumLock',
  '145': 'ScrollLock',
  '224': 'Meta'
};
/**
 * @param {object} nativeEvent Native browser event.
 * @return {string} Normalized `key` property.
 */

function getEventKey(nativeEvent) {
  if (nativeEvent.key) {
    // Normalize inconsistent values reported by browsers due to
    // implementations of a working draft specification.
    // FireFox implements `key` but returns `MozPrintableKey` for all
    // printable characters (normalized to `Unidentified`), ignore it.
    var key = normalizeKey[nativeEvent.key] || nativeEvent.key;

    if (key !== 'Unidentified') {
      return key;
    }
  } // Browser does not implement `key`, polyfill as much of it as we can.


  if (nativeEvent.type === 'keypress') {
    var charCode = getEventCharCode(nativeEvent); // The enter-key is technically both printable and non-printable and can
    // thus be captured by `keypress`, no other non-printable key should.

    return charCode === 13 ? 'Enter' : String.fromCharCode(charCode);
  }

  if (nativeEvent.type === 'keydown' || nativeEvent.type === 'keyup') {
    // While user keyboard layout determines the actual meaning of each
    // `keyCode` value, almost all function keys have a universal value.
    return translateToKey[nativeEvent.keyCode] || 'Unidentified';
  }

  return '';
}
/**
 * Translation from modifier key to the associated property in the event.
 * @see http://www.w3.org/TR/DOM-Level-3-Events/#keys-Modifiers
 */


var modifierKeyToProp = {
  Alt: 'altKey',
  Control: 'ctrlKey',
  Meta: 'metaKey',
  Shift: 'shiftKey'
}; // Older browsers (Safari <= 10, iOS Safari <= 10.2) do not support
// getModifierState. If getModifierState is not supported, we map it to a set of
// modifier keys exposed by the event. In this case, Lock-keys are not supported.

function modifierStateGetter(keyArg) {
  var syntheticEvent = this;
  var nativeEvent = syntheticEvent.nativeEvent;

  if (nativeEvent.getModifierState) {
    return nativeEvent.getModifierState(keyArg);
  }

  var keyProp = modifierKeyToProp[keyArg];
  return keyProp ? !!nativeEvent[keyProp] : false;
}

function getEventModifierState(nativeEvent) {
  return modifierStateGetter;
}
/**
 * @interface KeyboardEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */


var KeyboardEventInterface = _assign({}, UIEventInterface, {
  key: getEventKey,
  code: 0,
  location: 0,
  ctrlKey: 0,
  shiftKey: 0,
  altKey: 0,
  metaKey: 0,
  repeat: 0,
  locale: 0,
  getModifierState: getEventModifierState,
  // Legacy Interface
  charCode: function (event) {
    // `charCode` is the result of a KeyPress event and represents the value of
    // the actual printable character.
    // KeyPress is deprecated, but its replacement is not yet final and not
    // implemented in any major browser. Only KeyPress has charCode.
    if (event.type === 'keypress') {
      return getEventCharCode(event);
    }

    return 0;
  },
  keyCode: function (event) {
    // `keyCode` is the result of a KeyDown/Up event and represents the value of
    // physical keyboard key.
    // The actual meaning of the value depends on the users' keyboard layout
    // which cannot be detected. Assuming that it is a US keyboard layout
    // provides a surprisingly accurate mapping for US and European users.
    // Due to this, it is left to the user to implement at this time.
    if (event.type === 'keydown' || event.type === 'keyup') {
      return event.keyCode;
    }

    return 0;
  },
  which: function (event) {
    // `which` is an alias for either `keyCode` or `charCode` depending on the
    // type of the event.
    if (event.type === 'keypress') {
      return getEventCharCode(event);
    }

    if (event.type === 'keydown' || event.type === 'keyup') {
      return event.keyCode;
    }

    return 0;
  }
});

var SyntheticKeyboardEvent = createSyntheticEvent(KeyboardEventInterface);
/**
 * @interface PointerEvent
 * @see http://www.w3.org/TR/pointerevents/
 */

var PointerEventInterface = _assign({}, MouseEventInterface, {
  pointerId: 0,
  width: 0,
  height: 0,
  pressure: 0,
  tangentialPressure: 0,
  tiltX: 0,
  tiltY: 0,
  twist: 0,
  pointerType: 0,
  isPrimary: 0
});

var SyntheticPointerEvent = createSyntheticEvent(PointerEventInterface);
/**
 * @interface TouchEvent
 * @see http://www.w3.org/TR/touch-events/
 */

var TouchEventInterface = _assign({}, UIEventInterface, {
  touches: 0,
  targetTouches: 0,
  changedTouches: 0,
  altKey: 0,
  metaKey: 0,
  ctrlKey: 0,
  shiftKey: 0,
  getModifierState: getEventModifierState
});

var SyntheticTouchEvent = createSyntheticEvent(TouchEventInterface);
/**
 * @interface Event
 * @see http://www.w3.org/TR/2009/WD-css3-transitions-20090320/#transition-events-
 * @see https://developer.mozilla.org/en-US/docs/Web/API/TransitionEvent
 */

var TransitionEventInterface = _assign({}, EventInterface, {
  propertyName: 0,
  elapsedTime: 0,
  pseudoElement: 0
});

var SyntheticTransitionEvent = createSyntheticEvent(TransitionEventInterface);
/**
 * @interface WheelEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */

var WheelEventInterface = _assign({}, MouseEventInterface, {
  deltaX: function (event) {
    return 'deltaX' in event ? event.deltaX : // Fallback to `wheelDeltaX` for Webkit and normalize (right is positive).
    'wheelDeltaX' in event ? -event.wheelDeltaX : 0;
  },
  deltaY: function (event) {
    return 'deltaY' in event ? event.deltaY : // Fallback to `wheelDeltaY` for Webkit and normalize (down is positive).
    'wheelDeltaY' in event ? -event.wheelDeltaY : // Fallback to `wheelDelta` for IE<9 and normalize (down is positive).
    'wheelDelta' in event ? -event.wheelDelta : 0;
  },
  deltaZ: 0,
  // Browsers without "deltaMode" is reporting in raw wheel delta where one
  // notch on the scroll is always +/- 120, roughly equivalent to pixels.
  // A good approximation of DOM_DELTA_LINE (1) is 5% of viewport size or
  // ~40 pixels, for DOM_DELTA_SCREEN (2) it is 87.5% of viewport size.
  deltaMode: 0
});

var SyntheticWheelEvent = createSyntheticEvent(WheelEventInterface);

var END_KEYCODES = [9, 13, 27, 32]; // Tab, Return, Esc, Space

var START_KEYCODE = 229;
var canUseCompositionEvent = canUseDOM && 'CompositionEvent' in window;
var documentMode = null;

if (canUseDOM && 'documentMode' in document) {
  documentMode = document.documentMode;
} // Webkit offers a very useful `textInput` event that can be used to
// directly represent `beforeInput`. The IE `textinput` event is not as
// useful, so we don't use it.


var canUseTextInputEvent = canUseDOM && 'TextEvent' in window && !documentMode; // In IE9+, we have access to composition events, but the data supplied
// by the native compositionend event may be incorrect. Japanese ideographic
// spaces, for instance (\u3000) are not recorded correctly.

var useFallbackCompositionData = canUseDOM && (!canUseCompositionEvent || documentMode && documentMode > 8 && documentMode <= 11);
var SPACEBAR_CODE = 32;
var SPACEBAR_CHAR = String.fromCharCode(SPACEBAR_CODE);

function registerEvents() {
  registerTwoPhaseEvent('onBeforeInput', ['compositionend', 'keypress', 'textInput', 'paste']);
  registerTwoPhaseEvent('onCompositionEnd', ['compositionend', 'focusout', 'keydown', 'keypress', 'keyup', 'mousedown']);
  registerTwoPhaseEvent('onCompositionStart', ['compositionstart', 'focusout', 'keydown', 'keypress', 'keyup', 'mousedown']);
  registerTwoPhaseEvent('onCompositionUpdate', ['compositionupdate', 'focusout', 'keydown', 'keypress', 'keyup', 'mousedown']);
} // Track whether we've ever handled a keypress on the space key.


var hasSpaceKeypress = false;
/**
 * Return whether a native keypress event is assumed to be a command.
 * This is required because Firefox fires `keypress` events for key commands
 * (cut, copy, select-all, etc.) even though no character is inserted.
 */

function isKeypressCommand(nativeEvent) {
  return (nativeEvent.ctrlKey || nativeEvent.altKey || nativeEvent.metaKey) && // ctrlKey && altKey is equivalent to AltGr, and is not a command.
  !(nativeEvent.ctrlKey && nativeEvent.altKey);
}
/**
 * Translate native top level events into event types.
 */


function getCompositionEventType(domEventName) {
  switch (domEventName) {
    case 'compositionstart':
      return 'onCompositionStart';

    case 'compositionend':
      return 'onCompositionEnd';

    case 'compositionupdate':
      return 'onCompositionUpdate';
  }
}
/**
 * Does our fallback best-guess model think this event signifies that
 * composition has begun?
 */


function isFallbackCompositionStart(domEventName, nativeEvent) {
  return domEventName === 'keydown' && nativeEvent.keyCode === START_KEYCODE;
}
/**
 * Does our fallback mode think that this event is the end of composition?
 */


function isFallbackCompositionEnd(domEventName, nativeEvent) {
  switch (domEventName) {
    case 'keyup':
      // Command keys insert or clear IME input.
      return END_KEYCODES.indexOf(nativeEvent.keyCode) !== -1;

    case 'keydown':
      // Expect IME keyCode on each keydown. If we get any other
      // code we must have exited earlier.
      return nativeEvent.keyCode !== START_KEYCODE;

    case 'keypress':
    case 'mousedown':
    case 'focusout':
      // Events are not possible without cancelling IME.
      return true;

    default:
      return false;
  }
}
/**
 * Google Input Tools provides composition data via a CustomEvent,
 * with the `data` property populated in the `detail` object. If this
 * is available on the event object, use it. If not, this is a plain
 * composition event and we have nothing special to extract.
 *
 * @param {object} nativeEvent
 * @return {?string}
 */


function getDataFromCustomEvent(nativeEvent) {
  var detail = nativeEvent.detail;

  if (typeof detail === 'object' && 'data' in detail) {
    return detail.data;
  }

  return null;
}
/**
 * Check if a composition event was triggered by Korean IME.
 * Our fallback mode does not work well with IE's Korean IME,
 * so just use native composition events when Korean IME is used.
 * Although CompositionEvent.locale property is deprecated,
 * it is available in IE, where our fallback mode is enabled.
 *
 * @param {object} nativeEvent
 * @return {boolean}
 */


function isUsingKoreanIME(nativeEvent) {
  return nativeEvent.locale === 'ko';
} // Track the current IME composition status, if any.


var isComposing = false;
/**
 * @return {?object} A SyntheticCompositionEvent.
 */

function extractCompositionEvent(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget) {
  var eventType;
  var fallbackData;

  if (canUseCompositionEvent) {
    eventType = getCompositionEventType(domEventName);
  } else if (!isComposing) {
    if (isFallbackCompositionStart(domEventName, nativeEvent)) {
      eventType = 'onCompositionStart';
    }
  } else if (isFallbackCompositionEnd(domEventName, nativeEvent)) {
    eventType = 'onCompositionEnd';
  }

  if (!eventType) {
    return null;
  }

  if (useFallbackCompositionData && !isUsingKoreanIME(nativeEvent)) {
    // The current composition is stored statically and must not be
    // overwritten while composition continues.
    if (!isComposing && eventType === 'onCompositionStart') {
      isComposing = initialize(nativeEventTarget);
    } else if (eventType === 'onCompositionEnd') {
      if (isComposing) {
        fallbackData = getData();
      }
    }
  }

  var listeners = accumulateTwoPhaseListeners(targetInst, eventType);

  if (listeners.length > 0) {
    var event = new SyntheticCompositionEvent(eventType, domEventName, null, nativeEvent, nativeEventTarget);
    dispatchQueue.push({
      event: event,
      listeners: listeners
    });

    if (fallbackData) {
      // Inject data generated from fallback path into the synthetic event.
      // This matches the property of native CompositionEventInterface.
      event.data = fallbackData;
    } else {
      var customData = getDataFromCustomEvent(nativeEvent);

      if (customData !== null) {
        event.data = customData;
      }
    }
  }
}

function getNativeBeforeInputChars(domEventName, nativeEvent) {
  switch (domEventName) {
    case 'compositionend':
      return getDataFromCustomEvent(nativeEvent);

    case 'keypress':
      /**
       * If native `textInput` events are available, our goal is to make
       * use of them. However, there is a special case: the spacebar key.
       * In Webkit, preventing default on a spacebar `textInput` event
       * cancels character insertion, but it *also* causes the browser
       * to fall back to its default spacebar behavior of scrolling the
       * page.
       *
       * Tracking at:
       * https://code.google.com/p/chromium/issues/detail?id=355103
       *
       * To avoid this issue, use the keypress event as if no `textInput`
       * event is available.
       */
      var which = nativeEvent.which;

      if (which !== SPACEBAR_CODE) {
        return null;
      }

      hasSpaceKeypress = true;
      return SPACEBAR_CHAR;

    case 'textInput':
      // Record the characters to be added to the DOM.
      var chars = nativeEvent.data; // If it's a spacebar character, assume that we have already handled
      // it at the keypress level and bail immediately. Android Chrome
      // doesn't give us keycodes, so we need to ignore it.

      if (chars === SPACEBAR_CHAR && hasSpaceKeypress) {
        return null;
      }

      return chars;

    default:
      // For other native event types, do nothing.
      return null;
  }
}
/**
 * For browsers that do not provide the `textInput` event, extract the
 * appropriate string to use for SyntheticInputEvent.
 */


function getFallbackBeforeInputChars(domEventName, nativeEvent) {
  // If we are currently composing (IME) and using a fallback to do so,
  // try to extract the composed characters from the fallback object.
  // If composition event is available, we extract a string only at
  // compositionevent, otherwise extract it at fallback events.
  if (isComposing) {
    if (domEventName === 'compositionend' || !canUseCompositionEvent && isFallbackCompositionEnd(domEventName, nativeEvent)) {
      var chars = getData();
      reset();
      isComposing = false;
      return chars;
    }

    return null;
  }

  switch (domEventName) {
    case 'paste':
      // If a paste event occurs after a keypress, throw out the input
      // chars. Paste events should not lead to BeforeInput events.
      return null;

    case 'keypress':
      /**
       * As of v27, Firefox may fire keypress events even when no character
       * will be inserted. A few possibilities:
       *
       * - `which` is `0`. Arrow keys, Esc key, etc.
       *
       * - `which` is the pressed key code, but no char is available.
       *   Ex: 'AltGr + d` in Polish. There is no modified character for
       *   this key combination and no character is inserted into the
       *   document, but FF fires the keypress for char code `100` anyway.
       *   No `input` event will occur.
       *
       * - `which` is the pressed key code, but a command combination is
       *   being used. Ex: `Cmd+C`. No character is inserted, and no
       *   `input` event will occur.
       */
      if (!isKeypressCommand(nativeEvent)) {
        // IE fires the `keypress` event when a user types an emoji via
        // Touch keyboard of Windows.  In such a case, the `char` property
        // holds an emoji character like `\uD83D\uDE0A`.  Because its length
        // is 2, the property `which` does not represent an emoji correctly.
        // In such a case, we directly return the `char` property instead of
        // using `which`.
        if (nativeEvent.char && nativeEvent.char.length > 1) {
          return nativeEvent.char;
        } else if (nativeEvent.which) {
          return String.fromCharCode(nativeEvent.which);
        }
      }

      return null;

    case 'compositionend':
      return useFallbackCompositionData && !isUsingKoreanIME(nativeEvent) ? null : nativeEvent.data;

    default:
      return null;
  }
}
/**
 * Extract a SyntheticInputEvent for `beforeInput`, based on either native
 * `textInput` or fallback behavior.
 *
 * @return {?object} A SyntheticInputEvent.
 */


function extractBeforeInputEvent(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget) {
  var chars;

  if (canUseTextInputEvent) {
    chars = getNativeBeforeInputChars(domEventName, nativeEvent);
  } else {
    chars = getFallbackBeforeInputChars(domEventName, nativeEvent);
  } // If no characters are being inserted, no BeforeInput event should
  // be fired.


  if (!chars) {
    return null;
  }

  var listeners = accumulateTwoPhaseListeners(targetInst, 'onBeforeInput');

  if (listeners.length > 0) {
    var event = new SyntheticInputEvent('onBeforeInput', 'beforeinput', null, nativeEvent, nativeEventTarget);
    dispatchQueue.push({
      event: event,
      listeners: listeners
    });
    event.data = chars;
  }
}
/**
 * Create an `onBeforeInput` event to match
 * http://www.w3.org/TR/2013/WD-DOM-Level-3-Events-20131105/#events-inputevents.
 *
 * This event plugin is based on the native `textInput` event
 * available in Chrome, Safari, Opera, and IE. This event fires after
 * `onKeyPress` and `onCompositionEnd`, but before `onInput`.
 *
 * `beforeInput` is spec'd but not implemented in any browsers, and
 * the `input` event does not provide any useful information about what has
 * actually been added, contrary to the spec. Thus, `textInput` is the best
 * available event to identify the characters that have actually been inserted
 * into the target node.
 *
 * This plugin is also responsible for emitting `composition` events, thus
 * allowing us to share composition fallback code for both `beforeInput` and
 * `composition` event types.
 */


function extractEvents(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer) {
  extractCompositionEvent(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget);
  extractBeforeInputEvent(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget);
}

/**
 * @see http://www.whatwg.org/specs/web-apps/current-work/multipage/the-input-element.html#input-type-attr-summary
 */
var supportedInputTypes = {
  color: true,
  date: true,
  datetime: true,
  'datetime-local': true,
  email: true,
  month: true,
  number: true,
  password: true,
  range: true,
  search: true,
  tel: true,
  text: true,
  time: true,
  url: true,
  week: true
};

function isTextInputElement(elem) {
  var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();

  if (nodeName === 'input') {
    return !!supportedInputTypes[elem.type];
  }

  if (nodeName === 'textarea') {
    return true;
  }

  return false;
}

/**
 * Checks if an event is supported in the current execution environment.
 *
 * NOTE: This will not work correctly for non-generic events such as `change`,
 * `reset`, `load`, `error`, and `select`.
 *
 * Borrows from Modernizr.
 *
 * @param {string} eventNameSuffix Event name, e.g. "click".
 * @return {boolean} True if the event is supported.
 * @internal
 * @license Modernizr 3.0.0pre (Custom Build) | MIT
 */

function isEventSupported(eventNameSuffix) {
  if (!canUseDOM) {
    return false;
  }

  var eventName = 'on' + eventNameSuffix;
  var isSupported = (eventName in document);

  if (!isSupported) {
    var element = document.createElement('div');
    element.setAttribute(eventName, 'return;');
    isSupported = typeof element[eventName] === 'function';
  }

  return isSupported;
}

function registerEvents$1() {
  registerTwoPhaseEvent('onChange', ['change', 'click', 'focusin', 'focusout', 'input', 'keydown', 'keyup', 'selectionchange']);
}

function createAndAccumulateChangeEvent(dispatchQueue, inst, nativeEvent, target) {
  // Flag this event loop as needing state restore.
  enqueueStateRestore(target);
  var listeners = accumulateTwoPhaseListeners(inst, 'onChange');

  if (listeners.length > 0) {
    var event = new SyntheticEvent('onChange', 'change', null, nativeEvent, target);
    dispatchQueue.push({
      event: event,
      listeners: listeners
    });
  }
}
/**
 * For IE shims
 */


var activeElement = null;
var activeElementInst = null;
/**
 * SECTION: handle `change` event
 */

function shouldUseChangeEvent(elem) {
  var nodeName = elem.nodeName && elem.nodeName.toLowerCase();
  return nodeName === 'select' || nodeName === 'input' && elem.type === 'file';
}

function manualDispatchChangeEvent(nativeEvent) {
  var dispatchQueue = [];
  createAndAccumulateChangeEvent(dispatchQueue, activeElementInst, nativeEvent, getEventTarget(nativeEvent)); // If change and propertychange bubbled, we'd just bind to it like all the
  // other events and have it go through ReactBrowserEventEmitter. Since it
  // doesn't, we manually listen for the events and so we have to enqueue and
  // process the abstract event manually.
  //
  // Batching is necessary here in order to ensure that all event handlers run
  // before the next rerender (including event handlers attached to ancestor
  // elements instead of directly on the input). Without this, controlled
  // components don't work properly in conjunction with event bubbling because
  // the component is rerendered and the value reverted before all the event
  // handlers can run. See https://github.com/facebook/react/issues/708.

  batchedUpdates(runEventInBatch, dispatchQueue);
}

function runEventInBatch(dispatchQueue) {
  processDispatchQueue(dispatchQueue, 0);
}

function getInstIfValueChanged(targetInst) {
  var targetNode = getNodeFromInstance(targetInst);

  if (updateValueIfChanged(targetNode)) {
    return targetInst;
  }
}

function getTargetInstForChangeEvent(domEventName, targetInst) {
  if (domEventName === 'change') {
    return targetInst;
  }
}
/**
 * SECTION: handle `input` event
 */


var isInputEventSupported = false;

if (canUseDOM) {
  // IE9 claims to support the input event but fails to trigger it when
  // deleting text, so we ignore its input events.
  isInputEventSupported = isEventSupported('input') && (!document.documentMode || document.documentMode > 9);
}
/**
 * (For IE <=9) Starts tracking propertychange events on the passed-in element
 * and override the value property so that we can distinguish user events from
 * value changes in JS.
 */


function startWatchingForValueChange(target, targetInst) {
  activeElement = target;
  activeElementInst = targetInst;
  activeElement.attachEvent('onpropertychange', handlePropertyChange);
}
/**
 * (For IE <=9) Removes the event listeners from the currently-tracked element,
 * if any exists.
 */


function stopWatchingForValueChange() {
  if (!activeElement) {
    return;
  }

  activeElement.detachEvent('onpropertychange', handlePropertyChange);
  activeElement = null;
  activeElementInst = null;
}
/**
 * (For IE <=9) Handles a propertychange event, sending a `change` event if
 * the value of the active element has changed.
 */


function handlePropertyChange(nativeEvent) {
  if (nativeEvent.propertyName !== 'value') {
    return;
  }

  if (getInstIfValueChanged(activeElementInst)) {
    manualDispatchChangeEvent(nativeEvent);
  }
}

function handleEventsForInputEventPolyfill(domEventName, target, targetInst) {
  if (domEventName === 'focusin') {
    // In IE9, propertychange fires for most input events but is buggy and
    // doesn't fire when text is deleted, but conveniently, selectionchange
    // appears to fire in all of the remaining cases so we catch those and
    // forward the event if the value has changed
    // In either case, we don't want to call the event handler if the value
    // is changed from JS so we redefine a setter for `.value` that updates
    // our activeElementValue variable, allowing us to ignore those changes
    //
    // stopWatching() should be a noop here but we call it just in case we
    // missed a blur event somehow.
    stopWatchingForValueChange();
    startWatchingForValueChange(target, targetInst);
  } else if (domEventName === 'focusout') {
    stopWatchingForValueChange();
  }
} // For IE8 and IE9.


function getTargetInstForInputEventPolyfill(domEventName, targetInst) {
  if (domEventName === 'selectionchange' || domEventName === 'keyup' || domEventName === 'keydown') {
    // On the selectionchange event, the target is just document which isn't
    // helpful for us so just check activeElement instead.
    //
    // 99% of the time, keydown and keyup aren't necessary. IE8 fails to fire
    // propertychange on the first input event after setting `value` from a
    // script and fires only keydown, keypress, keyup. Catching keyup usually
    // gets it and catching keydown lets us fire an event for the first
    // keystroke if user does a key repeat (it'll be a little delayed: right
    // before the second keystroke). Other input methods (e.g., paste) seem to
    // fire selectionchange normally.
    return getInstIfValueChanged(activeElementInst);
  }
}
/**
 * SECTION: handle `click` event
 */


function shouldUseClickEvent(elem) {
  // Use the `click` event to detect changes to checkbox and radio inputs.
  // This approach works across all browsers, whereas `change` does not fire
  // until `blur` in IE8.
  var nodeName = elem.nodeName;
  return nodeName && nodeName.toLowerCase() === 'input' && (elem.type === 'checkbox' || elem.type === 'radio');
}

function getTargetInstForClickEvent(domEventName, targetInst) {
  if (domEventName === 'click') {
    return getInstIfValueChanged(targetInst);
  }
}

function getTargetInstForInputOrChangeEvent(domEventName, targetInst) {
  if (domEventName === 'input' || domEventName === 'change') {
    return getInstIfValueChanged(targetInst);
  }
}

function handleControlledInputBlur(node) {
  var state = node._wrapperState;

  if (!state || !state.controlled || node.type !== 'number') {
    return;
  }

  {
    // If controlled, assign the value attribute to the current value on blur
    setDefaultValue(node, 'number', node.value);
  }
}
/**
 * This plugin creates an `onChange` event that normalizes change events
 * across form elements. This event fires at a time when it's possible to
 * change the element's value without seeing a flicker.
 *
 * Supported elements are:
 * - input (see `isTextInputElement`)
 * - textarea
 * - select
 */


function extractEvents$1(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer) {
  var targetNode = targetInst ? getNodeFromInstance(targetInst) : window;
  var getTargetInstFunc, handleEventFunc;

  if (shouldUseChangeEvent(targetNode)) {
    getTargetInstFunc = getTargetInstForChangeEvent;
  } else if (isTextInputElement(targetNode)) {
    if (isInputEventSupported) {
      getTargetInstFunc = getTargetInstForInputOrChangeEvent;
    } else {
      getTargetInstFunc = getTargetInstForInputEventPolyfill;
      handleEventFunc = handleEventsForInputEventPolyfill;
    }
  } else if (shouldUseClickEvent(targetNode)) {
    getTargetInstFunc = getTargetInstForClickEvent;
  }

  if (getTargetInstFunc) {
    var inst = getTargetInstFunc(domEventName, targetInst);

    if (inst) {
      createAndAccumulateChangeEvent(dispatchQueue, inst, nativeEvent, nativeEventTarget);
      return;
    }
  }

  if (handleEventFunc) {
    handleEventFunc(domEventName, targetNode, targetInst);
  } // When blurring, set the value attribute for number inputs


  if (domEventName === 'focusout') {
    handleControlledInputBlur(targetNode);
  }
}

function registerEvents$2() {
  registerDirectEvent('onMouseEnter', ['mouseout', 'mouseover']);
  registerDirectEvent('onMouseLeave', ['mouseout', 'mouseover']);
  registerDirectEvent('onPointerEnter', ['pointerout', 'pointerover']);
  registerDirectEvent('onPointerLeave', ['pointerout', 'pointerover']);
}
/**
 * For almost every interaction we care about, there will be both a top-level
 * `mouseover` and `mouseout` event that occurs. Only use `mouseout` so that
 * we do not extract duplicate events. However, moving the mouse into the
 * browser from outside will not fire a `mouseout` event. In this case, we use
 * the `mouseover` top-level event.
 */


function extractEvents$2(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer) {
  var isOverEvent = domEventName === 'mouseover' || domEventName === 'pointerover';
  var isOutEvent = domEventName === 'mouseout' || domEventName === 'pointerout';

  if (isOverEvent && (eventSystemFlags & IS_REPLAYED) === 0) {
    // If this is an over event with a target, we might have already dispatched
    // the event in the out event of the other target. If this is replayed,
    // then it's because we couldn't dispatch against this target previously
    // so we have to do it now instead.
    var related = nativeEvent.relatedTarget || nativeEvent.fromElement;

    if (related) {
      // If the related node is managed by React, we can assume that we have
      // already dispatched the corresponding events during its mouseout.
      if (getClosestInstanceFromNode(related) || isContainerMarkedAsRoot(related)) {
        return;
      }
    }
  }

  if (!isOutEvent && !isOverEvent) {
    // Must not be a mouse or pointer in or out - ignoring.
    return;
  }

  var win; // TODO: why is this nullable in the types but we read from it?

  if (nativeEventTarget.window === nativeEventTarget) {
    // `nativeEventTarget` is probably a window object.
    win = nativeEventTarget;
  } else {
    // TODO: Figure out why `ownerDocument` is sometimes undefined in IE8.
    var doc = nativeEventTarget.ownerDocument;

    if (doc) {
      win = doc.defaultView || doc.parentWindow;
    } else {
      win = window;
    }
  }

  var from;
  var to;

  if (isOutEvent) {
    var _related = nativeEvent.relatedTarget || nativeEvent.toElement;

    from = targetInst;
    to = _related ? getClosestInstanceFromNode(_related) : null;

    if (to !== null) {
      var nearestMounted = getNearestMountedFiber(to);

      if (to !== nearestMounted || to.tag !== HostComponent && to.tag !== HostText) {
        to = null;
      }
    }
  } else {
    // Moving to a node from outside the window.
    from = null;
    to = targetInst;
  }

  if (from === to) {
    // Nothing pertains to our managed components.
    return;
  }

  var SyntheticEventCtor = SyntheticMouseEvent;
  var leaveEventType = 'onMouseLeave';
  var enterEventType = 'onMouseEnter';
  var eventTypePrefix = 'mouse';

  if (domEventName === 'pointerout' || domEventName === 'pointerover') {
    SyntheticEventCtor = SyntheticPointerEvent;
    leaveEventType = 'onPointerLeave';
    enterEventType = 'onPointerEnter';
    eventTypePrefix = 'pointer';
  }

  var fromNode = from == null ? win : getNodeFromInstance(from);
  var toNode = to == null ? win : getNodeFromInstance(to);
  var leave = new SyntheticEventCtor(leaveEventType, eventTypePrefix + 'leave', from, nativeEvent, nativeEventTarget);
  leave.target = fromNode;
  leave.relatedTarget = toNode;
  var enter = null; // We should only process this nativeEvent if we are processing
  // the first ancestor. Next time, we will ignore the event.

  var nativeTargetInst = getClosestInstanceFromNode(nativeEventTarget);

  if (nativeTargetInst === targetInst) {
    var enterEvent = new SyntheticEventCtor(enterEventType, eventTypePrefix + 'enter', to, nativeEvent, nativeEventTarget);
    enterEvent.target = toNode;
    enterEvent.relatedTarget = fromNode;
    enter = enterEvent;
  }

  accumulateEnterLeaveTwoPhaseListeners(dispatchQueue, leave, enter, from, to);
}

/**
 * inlined Object.is polyfill to avoid requiring consumers ship their own
 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
 */
function is(x, y) {
  return x === y && (x !== 0 || 1 / x === 1 / y) || x !== x && y !== y // eslint-disable-line no-self-compare
  ;
}

var objectIs = typeof Object.is === 'function' ? Object.is : is;

var hasOwnProperty$2 = Object.prototype.hasOwnProperty;
/**
 * Performs equality by iterating through keys on an object and returning false
 * when any key has values which are not strictly equal between the arguments.
 * Returns true when the values of all keys are strictly equal.
 */

function shallowEqual(objA, objB) {
  if (objectIs(objA, objB)) {
    return true;
  }

  if (typeof objA !== 'object' || objA === null || typeof objB !== 'object' || objB === null) {
    return false;
  }

  var keysA = Object.keys(objA);
  var keysB = Object.keys(objB);

  if (keysA.length !== keysB.length) {
    return false;
  } // Test for A's keys different from B.


  for (var i = 0; i < keysA.length; i++) {
    if (!hasOwnProperty$2.call(objB, keysA[i]) || !objectIs(objA[keysA[i]], objB[keysA[i]])) {
      return false;
    }
  }

  return true;
}

/**
 * Given any node return the first leaf node without children.
 *
 * @param {DOMElement|DOMTextNode} node
 * @return {DOMElement|DOMTextNode}
 */

function getLeafNode(node) {
  while (node && node.firstChild) {
    node = node.firstChild;
  }

  return node;
}
/**
 * Get the next sibling within a container. This will walk up the
 * DOM if a node's siblings have been exhausted.
 *
 * @param {DOMElement|DOMTextNode} node
 * @return {?DOMElement|DOMTextNode}
 */


function getSiblingNode(node) {
  while (node) {
    if (node.nextSibling) {
      return node.nextSibling;
    }

    node = node.parentNode;
  }
}
/**
 * Get object describing the nodes which contain characters at offset.
 *
 * @param {DOMElement|DOMTextNode} root
 * @param {number} offset
 * @return {?object}
 */


function getNodeForCharacterOffset(root, offset) {
  var node = getLeafNode(root);
  var nodeStart = 0;
  var nodeEnd = 0;

  while (node) {
    if (node.nodeType === TEXT_NODE) {
      nodeEnd = nodeStart + node.textContent.length;

      if (nodeStart <= offset && nodeEnd >= offset) {
        return {
          node: node,
          offset: offset - nodeStart
        };
      }

      nodeStart = nodeEnd;
    }

    node = getLeafNode(getSiblingNode(node));
  }
}

/**
 * @param {DOMElement} outerNode
 * @return {?object}
 */

function getOffsets(outerNode) {
  var ownerDocument = outerNode.ownerDocument;
  var win = ownerDocument && ownerDocument.defaultView || window;
  var selection = win.getSelection && win.getSelection();

  if (!selection || selection.rangeCount === 0) {
    return null;
  }

  var anchorNode = selection.anchorNode,
      anchorOffset = selection.anchorOffset,
      focusNode = selection.focusNode,
      focusOffset = selection.focusOffset; // In Firefox, anchorNode and focusNode can be "anonymous divs", e.g. the
  // up/down buttons on an <input type="number">. Anonymous divs do not seem to
  // expose properties, triggering a "Permission denied error" if any of its
  // properties are accessed. The only seemingly possible way to avoid erroring
  // is to access a property that typically works for non-anonymous divs and
  // catch any error that may otherwise arise. See
  // https://bugzilla.mozilla.org/show_bug.cgi?id=208427

  try {
    /* eslint-disable no-unused-expressions */
    anchorNode.nodeType;
    focusNode.nodeType;
    /* eslint-enable no-unused-expressions */
  } catch (e) {
    return null;
  }

  return getModernOffsetsFromPoints(outerNode, anchorNode, anchorOffset, focusNode, focusOffset);
}
/**
 * Returns {start, end} where `start` is the character/codepoint index of
 * (anchorNode, anchorOffset) within the textContent of `outerNode`, and
 * `end` is the index of (focusNode, focusOffset).
 *
 * Returns null if you pass in garbage input but we should probably just crash.
 *
 * Exported only for testing.
 */

function getModernOffsetsFromPoints(outerNode, anchorNode, anchorOffset, focusNode, focusOffset) {
  var length = 0;
  var start = -1;
  var end = -1;
  var indexWithinAnchor = 0;
  var indexWithinFocus = 0;
  var node = outerNode;
  var parentNode = null;

  outer: while (true) {
    var next = null;

    while (true) {
      if (node === anchorNode && (anchorOffset === 0 || node.nodeType === TEXT_NODE)) {
        start = length + anchorOffset;
      }

      if (node === focusNode && (focusOffset === 0 || node.nodeType === TEXT_NODE)) {
        end = length + focusOffset;
      }

      if (node.nodeType === TEXT_NODE) {
        length += node.nodeValue.length;
      }

      if ((next = node.firstChild) === null) {
        break;
      } // Moving from `node` to its first child `next`.


      parentNode = node;
      node = next;
    }

    while (true) {
      if (node === outerNode) {
        // If `outerNode` has children, this is always the second time visiting
        // it. If it has no children, this is still the first loop, and the only
        // valid selection is anchorNode and focusNode both equal to this node
        // and both offsets 0, in which case we will have handled above.
        break outer;
      }

      if (parentNode === anchorNode && ++indexWithinAnchor === anchorOffset) {
        start = length;
      }

      if (parentNode === focusNode && ++indexWithinFocus === focusOffset) {
        end = length;
      }

      if ((next = node.nextSibling) !== null) {
        break;
      }

      node = parentNode;
      parentNode = node.parentNode;
    } // Moving from `node` to its next sibling `next`.


    node = next;
  }

  if (start === -1 || end === -1) {
    // This should never happen. (Would happen if the anchor/focus nodes aren't
    // actually inside the passed-in node.)
    return null;
  }

  return {
    start: start,
    end: end
  };
}
/**
 * In modern non-IE browsers, we can support both forward and backward
 * selections.
 *
 * Note: IE10+ supports the Selection object, but it does not support
 * the `extend` method, which means that even in modern IE, it's not possible
 * to programmatically create a backward selection. Thus, for all IE
 * versions, we use the old IE API to create our selections.
 *
 * @param {DOMElement|DOMTextNode} node
 * @param {object} offsets
 */

function setOffsets(node, offsets) {
  var doc = node.ownerDocument || document;
  var win = doc && doc.defaultView || window; // Edge fails with "Object expected" in some scenarios.
  // (For instance: TinyMCE editor used in a list component that supports pasting to add more,
  // fails when pasting 100+ items)

  if (!win.getSelection) {
    return;
  }

  var selection = win.getSelection();
  var length = node.textContent.length;
  var start = Math.min(offsets.start, length);
  var end = offsets.end === undefined ? start : Math.min(offsets.end, length); // IE 11 uses modern selection, but doesn't support the extend method.
  // Flip backward selections, so we can set with a single range.

  if (!selection.extend && start > end) {
    var temp = end;
    end = start;
    start = temp;
  }

  var startMarker = getNodeForCharacterOffset(node, start);
  var endMarker = getNodeForCharacterOffset(node, end);

  if (startMarker && endMarker) {
    if (selection.rangeCount === 1 && selection.anchorNode === startMarker.node && selection.anchorOffset === startMarker.offset && selection.focusNode === endMarker.node && selection.focusOffset === endMarker.offset) {
      return;
    }

    var range = doc.createRange();
    range.setStart(startMarker.node, startMarker.offset);
    selection.removeAllRanges();

    if (start > end) {
      selection.addRange(range);
      selection.extend(endMarker.node, endMarker.offset);
    } else {
      range.setEnd(endMarker.node, endMarker.offset);
      selection.addRange(range);
    }
  }
}

function isTextNode(node) {
  return node && node.nodeType === TEXT_NODE;
}

function containsNode(outerNode, innerNode) {
  if (!outerNode || !innerNode) {
    return false;
  } else if (outerNode === innerNode) {
    return true;
  } else if (isTextNode(outerNode)) {
    return false;
  } else if (isTextNode(innerNode)) {
    return containsNode(outerNode, innerNode.parentNode);
  } else if ('contains' in outerNode) {
    return outerNode.contains(innerNode);
  } else if (outerNode.compareDocumentPosition) {
    return !!(outerNode.compareDocumentPosition(innerNode) & 16);
  } else {
    return false;
  }
}

function isInDocument(node) {
  return node && node.ownerDocument && containsNode(node.ownerDocument.documentElement, node);
}

function isSameOriginFrame(iframe) {
  try {
    // Accessing the contentDocument of a HTMLIframeElement can cause the browser
    // to throw, e.g. if it has a cross-origin src attribute.
    // Safari will show an error in the console when the access results in "Blocked a frame with origin". e.g:
    // iframe.contentDocument.defaultView;
    // A safety way is to access one of the cross origin properties: Window or Location
    // Which might result in "SecurityError" DOM Exception and it is compatible to Safari.
    // https://html.spec.whatwg.org/multipage/browsers.html#integration-with-idl
    return typeof iframe.contentWindow.location.href === 'string';
  } catch (err) {
    return false;
  }
}

function getActiveElementDeep() {
  var win = window;
  var element = getActiveElement();

  while (element instanceof win.HTMLIFrameElement) {
    if (isSameOriginFrame(element)) {
      win = element.contentWindow;
    } else {
      return element;
    }

    element = getActiveElement(win.document);
  }

  return element;
}
/**
 * @ReactInputSelection: React input selection module. Based on Selection.js,
 * but modified to be suitable for react and has a couple of bug fixes (doesn't
 * assume buttons have range selections allowed).
 * Input selection module for React.
 */

/**
 * @hasSelectionCapabilities: we get the element types that support selection
 * from https://html.spec.whatwg.org/#do-not-apply, looking at `selectionStart`
 * and `selectionEnd` rows.
 */


function hasSelectionCapabilities(elem) {
  var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
  return nodeName && (nodeName === 'input' && (elem.type === 'text' || elem.type === 'search' || elem.type === 'tel' || elem.type === 'url' || elem.type === 'password') || nodeName === 'textarea' || elem.contentEditable === 'true');
}
function getSelectionInformation() {
  var focusedElem = getActiveElementDeep();
  return {
    focusedElem: focusedElem,
    selectionRange: hasSelectionCapabilities(focusedElem) ? getSelection(focusedElem) : null
  };
}
/**
 * @restoreSelection: If any selection information was potentially lost,
 * restore it. This is useful when performing operations that could remove dom
 * nodes and place them back in, resulting in focus being lost.
 */

function restoreSelection(priorSelectionInformation) {
  var curFocusedElem = getActiveElementDeep();
  var priorFocusedElem = priorSelectionInformation.focusedElem;
  var priorSelectionRange = priorSelectionInformation.selectionRange;

  if (curFocusedElem !== priorFocusedElem && isInDocument(priorFocusedElem)) {
    if (priorSelectionRange !== null && hasSelectionCapabilities(priorFocusedElem)) {
      setSelection(priorFocusedElem, priorSelectionRange);
    } // Focusing a node can change the scroll position, which is undesirable


    var ancestors = [];
    var ancestor = priorFocusedElem;

    while (ancestor = ancestor.parentNode) {
      if (ancestor.nodeType === ELEMENT_NODE) {
        ancestors.push({
          element: ancestor,
          left: ancestor.scrollLeft,
          top: ancestor.scrollTop
        });
      }
    }

    if (typeof priorFocusedElem.focus === 'function') {
      priorFocusedElem.focus();
    }

    for (var i = 0; i < ancestors.length; i++) {
      var info = ancestors[i];
      info.element.scrollLeft = info.left;
      info.element.scrollTop = info.top;
    }
  }
}
/**
 * @getSelection: Gets the selection bounds of a focused textarea, input or
 * contentEditable node.
 * -@input: Look up selection bounds of this input
 * -@return {start: selectionStart, end: selectionEnd}
 */

function getSelection(input) {
  var selection;

  if ('selectionStart' in input) {
    // Modern browser with input or textarea.
    selection = {
      start: input.selectionStart,
      end: input.selectionEnd
    };
  } else {
    // Content editable or old IE textarea.
    selection = getOffsets(input);
  }

  return selection || {
    start: 0,
    end: 0
  };
}
/**
 * @setSelection: Sets the selection bounds of a textarea or input and focuses
 * the input.
 * -@input     Set selection bounds of this input or textarea
 * -@offsets   Object of same form that is returned from get*
 */

function setSelection(input, offsets) {
  var start = offsets.start;
  var end = offsets.end;

  if (end === undefined) {
    end = start;
  }

  if ('selectionStart' in input) {
    input.selectionStart = start;
    input.selectionEnd = Math.min(end, input.value.length);
  } else {
    setOffsets(input, offsets);
  }
}

var skipSelectionChangeEvent = canUseDOM && 'documentMode' in document && document.documentMode <= 11;

function registerEvents$3() {
  registerTwoPhaseEvent('onSelect', ['focusout', 'contextmenu', 'dragend', 'focusin', 'keydown', 'keyup', 'mousedown', 'mouseup', 'selectionchange']);
}

var activeElement$1 = null;
var activeElementInst$1 = null;
var lastSelection = null;
var mouseDown = false;
/**
 * Get an object which is a unique representation of the current selection.
 *
 * The return value will not be consistent across nodes or browsers, but
 * two identical selections on the same node will return identical objects.
 */

function getSelection$1(node) {
  if ('selectionStart' in node && hasSelectionCapabilities(node)) {
    return {
      start: node.selectionStart,
      end: node.selectionEnd
    };
  } else {
    var win = node.ownerDocument && node.ownerDocument.defaultView || window;
    var selection = win.getSelection();
    return {
      anchorNode: selection.anchorNode,
      anchorOffset: selection.anchorOffset,
      focusNode: selection.focusNode,
      focusOffset: selection.focusOffset
    };
  }
}
/**
 * Get document associated with the event target.
 */


function getEventTargetDocument(eventTarget) {
  return eventTarget.window === eventTarget ? eventTarget.document : eventTarget.nodeType === DOCUMENT_NODE ? eventTarget : eventTarget.ownerDocument;
}
/**
 * Poll selection to see whether it's changed.
 *
 * @param {object} nativeEvent
 * @param {object} nativeEventTarget
 * @return {?SyntheticEvent}
 */


function constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget) {
  // Ensure we have the right element, and that the user is not dragging a
  // selection (this matches native `select` event behavior). In HTML5, select
  // fires only on input and textarea thus if there's no focused element we
  // won't dispatch.
  var doc = getEventTargetDocument(nativeEventTarget);

  if (mouseDown || activeElement$1 == null || activeElement$1 !== getActiveElement(doc)) {
    return;
  } // Only fire when selection has actually changed.


  var currentSelection = getSelection$1(activeElement$1);

  if (!lastSelection || !shallowEqual(lastSelection, currentSelection)) {
    lastSelection = currentSelection;
    var listeners = accumulateTwoPhaseListeners(activeElementInst$1, 'onSelect');

    if (listeners.length > 0) {
      var event = new SyntheticEvent('onSelect', 'select', null, nativeEvent, nativeEventTarget);
      dispatchQueue.push({
        event: event,
        listeners: listeners
      });
      event.target = activeElement$1;
    }
  }
}
/**
 * This plugin creates an `onSelect` event that normalizes select events
 * across form elements.
 *
 * Supported elements are:
 * - input (see `isTextInputElement`)
 * - textarea
 * - contentEditable
 *
 * This differs from native browser implementations in the following ways:
 * - Fires on contentEditable fields as well as inputs.
 * - Fires for collapsed selection.
 * - Fires after user input.
 */


function extractEvents$3(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer) {

  var targetNode = targetInst ? getNodeFromInstance(targetInst) : window;

  switch (domEventName) {
    // Track the input node that has focus.
    case 'focusin':
      if (isTextInputElement(targetNode) || targetNode.contentEditable === 'true') {
        activeElement$1 = targetNode;
        activeElementInst$1 = targetInst;
        lastSelection = null;
      }

      break;

    case 'focusout':
      activeElement$1 = null;
      activeElementInst$1 = null;
      lastSelection = null;
      break;
    // Don't fire the event while the user is dragging. This matches the
    // semantics of the native select event.

    case 'mousedown':
      mouseDown = true;
      break;

    case 'contextmenu':
    case 'mouseup':
    case 'dragend':
      mouseDown = false;
      constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget);
      break;
    // Chrome and IE fire non-standard event when selection is changed (and
    // sometimes when it hasn't). IE's event fires out of order with respect
    // to key and input events on deletion, so we discard it.
    //
    // Firefox doesn't support selectionchange, so check selection status
    // after each key entry. The selection changes after keydown and before
    // keyup, but we check on keydown as well in the case of holding down a
    // key, when multiple keydown events are fired but only one keyup is.
    // This is also our approach for IE handling, for the reason above.

    case 'selectionchange':
      if (skipSelectionChangeEvent) {
        break;
      }

    // falls through

    case 'keydown':
    case 'keyup':
      constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget);
  }
}

function extractEvents$4(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer) {
  var reactName = topLevelEventsToReactNames.get(domEventName);

  if (reactName === undefined) {
    return;
  }

  var SyntheticEventCtor = SyntheticEvent;
  var reactEventType = domEventName;

  switch (domEventName) {
    case 'keypress':
      // Firefox creates a keypress event for function keys too. This removes
      // the unwanted keypress events. Enter is however both printable and
      // non-printable. One would expect Tab to be as well (but it isn't).
      if (getEventCharCode(nativeEvent) === 0) {
        return;
      }

    /* falls through */

    case 'keydown':
    case 'keyup':
      SyntheticEventCtor = SyntheticKeyboardEvent;
      break;

    case 'focusin':
      reactEventType = 'focus';
      SyntheticEventCtor = SyntheticFocusEvent;
      break;

    case 'focusout':
      reactEventType = 'blur';
      SyntheticEventCtor = SyntheticFocusEvent;
      break;

    case 'beforeblur':
    case 'afterblur':
      SyntheticEventCtor = SyntheticFocusEvent;
      break;

    case 'click':
      // Firefox creates a click event on right mouse clicks. This removes the
      // unwanted click events.
      if (nativeEvent.button === 2) {
        return;
      }

    /* falls through */

    case 'auxclick':
    case 'dblclick':
    case 'mousedown':
    case 'mousemove':
    case 'mouseup': // TODO: Disabled elements should not respond to mouse events

    /* falls through */

    case 'mouseout':
    case 'mouseover':
    case 'contextmenu':
      SyntheticEventCtor = SyntheticMouseEvent;
      break;

    case 'drag':
    case 'dragend':
    case 'dragenter':
    case 'dragexit':
    case 'dragleave':
    case 'dragover':
    case 'dragstart':
    case 'drop':
      SyntheticEventCtor = SyntheticDragEvent;
      break;

    case 'touchcancel':
    case 'touchend':
    case 'touchmove':
    case 'touchstart':
      SyntheticEventCtor = SyntheticTouchEvent;
      break;

    case ANIMATION_END:
    case ANIMATION_ITERATION:
    case ANIMATION_START:
      SyntheticEventCtor = SyntheticAnimationEvent;
      break;

    case TRANSITION_END:
      SyntheticEventCtor = SyntheticTransitionEvent;
      break;

    case 'scroll':
      SyntheticEventCtor = SyntheticUIEvent;
      break;

    case 'wheel':
      SyntheticEventCtor = SyntheticWheelEvent;
      break;

    case 'copy':
    case 'cut':
    case 'paste':
      SyntheticEventCtor = SyntheticClipboardEvent;
      break;

    case 'gotpointercapture':
    case 'lostpointercapture':
    case 'pointercancel':
    case 'pointerdown':
    case 'pointermove':
    case 'pointerout':
    case 'pointerover':
    case 'pointerup':
      SyntheticEventCtor = SyntheticPointerEvent;
      break;
  }

  var inCapturePhase = (eventSystemFlags & IS_CAPTURE_PHASE) !== 0;

  {
    // Some events don't bubble in the browser.
    // In the past, React has always bubbled them, but this can be surprising.
    // We're going to try aligning closer to the browser behavior by not bubbling
    // them in React either. We'll start by not bubbling onScroll, and then expand.
    var accumulateTargetOnly = !inCapturePhase && // TODO: ideally, we'd eventually add all events from
    // nonDelegatedEvents list in DOMPluginEventSystem.
    // Then we can remove this special list.
    // This is a breaking change that can wait until React 18.
    domEventName === 'scroll';

    var _listeners = accumulateSinglePhaseListeners(targetInst, reactName, nativeEvent.type, inCapturePhase, accumulateTargetOnly);

    if (_listeners.length > 0) {
      // Intentionally create event lazily.
      var _event = new SyntheticEventCtor(reactName, reactEventType, null, nativeEvent, nativeEventTarget);

      dispatchQueue.push({
        event: _event,
        listeners: _listeners
      });
    }
  }
}

// TODO: remove top-level side effect.
registerSimpleEvents();
registerEvents$2();
registerEvents$1();
registerEvents$3();
registerEvents();

function extractEvents$5(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer) {
  // TODO: we should remove the concept of a "SimpleEventPlugin".
  // This is the basic functionality of the event system. All
  // the other plugins are essentially polyfills. So the plugin
  // should probably be inlined somewhere and have its logic
  // be core the to event system. This would potentially allow
  // us to ship builds of React without the polyfilled plugins below.
  extractEvents$4(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags);
  var shouldProcessPolyfillPlugins = (eventSystemFlags & SHOULD_NOT_PROCESS_POLYFILL_EVENT_PLUGINS) === 0; // We don't process these events unless we are in the
  // event's native "bubble" phase, which means that we're
  // not in the capture phase. That's because we emulate
  // the capture phase here still. This is a trade-off,
  // because in an ideal world we would not emulate and use
  // the phases properly, like we do with the SimpleEvent
  // plugin. However, the plugins below either expect
  // emulation (EnterLeave) or use state localized to that
  // plugin (BeforeInput, Change, Select). The state in
  // these modules complicates things, as you'll essentially
  // get the case where the capture phase event might change
  // state, only for the following bubble event to come in
  // later and not trigger anything as the state now
  // invalidates the heuristics of the event plugin. We
  // could alter all these plugins to work in such ways, but
  // that might cause other unknown side-effects that we
  // can't forsee right now.

  if (shouldProcessPolyfillPlugins) {
    extractEvents$2(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags);
    extractEvents$1(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget);
    extractEvents$3(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget);
    extractEvents(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget);
  }
} // List of events that need to be individually attached to media elements.


var mediaEventTypes = ['abort', 'canplay', 'canplaythrough', 'durationchange', 'emptied', 'encrypted', 'ended', 'error', 'loadeddata', 'loadedmetadata', 'loadstart', 'pause', 'play', 'playing', 'progress', 'ratechange', 'seeked', 'seeking', 'stalled', 'suspend', 'timeupdate', 'volumechange', 'waiting']; // We should not delegate these events to the container, but rather
// set them on the actual target element itself. This is primarily
// because these events do not consistently bubble in the DOM.

var nonDelegatedEvents = new Set(['cancel', 'close', 'invalid', 'load', 'scroll', 'toggle'].concat(mediaEventTypes));

function executeDispatch(event, listener, currentTarget) {
  var type = event.type || 'unknown-event';
  event.currentTarget = currentTarget;
  invokeGuardedCallbackAndCatchFirstError(type, listener, undefined, event);
  event.currentTarget = null;
}

function processDispatchQueueItemsInOrder(event, dispatchListeners, inCapturePhase) {
  var previousInstance;

  if (inCapturePhase) {
    for (var i = dispatchListeners.length - 1; i >= 0; i--) {
      var _dispatchListeners$i = dispatchListeners[i],
          instance = _dispatchListeners$i.instance,
          currentTarget = _dispatchListeners$i.currentTarget,
          listener = _dispatchListeners$i.listener;

      if (instance !== previousInstance && event.isPropagationStopped()) {
        return;
      }

      executeDispatch(event, listener, currentTarget);
      previousInstance = instance;
    }
  } else {
    for (var _i = 0; _i < dispatchListeners.length; _i++) {
      var _dispatchListeners$_i = dispatchListeners[_i],
          _instance = _dispatchListeners$_i.instance,
          _currentTarget = _dispatchListeners$_i.currentTarget,
          _listener = _dispatchListeners$_i.listener;

      if (_instance !== previousInstance && event.isPropagationStopped()) {
        return;
      }

      executeDispatch(event, _listener, _currentTarget);
      previousInstance = _instance;
    }
  }
}

function processDispatchQueue(dispatchQueue, eventSystemFlags) {
  var inCapturePhase = (eventSystemFlags & IS_CAPTURE_PHASE) !== 0;

  for (var i = 0; i < dispatchQueue.length; i++) {
    var _dispatchQueue$i = dispatchQueue[i],
        event = _dispatchQueue$i.event,
        listeners = _dispatchQueue$i.listeners;
    processDispatchQueueItemsInOrder(event, listeners, inCapturePhase); //  event system doesn't use pooling.
  } // This would be a good time to rethrow if any of the event handlers threw.


  rethrowCaughtError();
}

function dispatchEventsForPlugins(domEventName, eventSystemFlags, nativeEvent, targetInst, targetContainer) {
  var nativeEventTarget = getEventTarget(nativeEvent);
  var dispatchQueue = [];
  extractEvents$5(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags);
  processDispatchQueue(dispatchQueue, eventSystemFlags);
}

function listenToNonDelegatedEvent(domEventName, targetElement) {
  var isCapturePhaseListener = false;
  var listenerSet = getEventListenerSet(targetElement);
  var listenerSetKey = getListenerSetKey(domEventName, isCapturePhaseListener);

  if (!listenerSet.has(listenerSetKey)) {
    addTrappedEventListener(targetElement, domEventName, IS_NON_DELEGATED, isCapturePhaseListener);
    listenerSet.add(listenerSetKey);
  }
}
var listeningMarker = '_reactListening' + Math.random().toString(36).slice(2);
function listenToAllSupportedEvents(rootContainerElement) {
  {
    if (rootContainerElement[listeningMarker]) {
      // Performance optimization: don't iterate through events
      // for the same portal container or root node more than once.
      // TODO: once we remove the flag, we may be able to also
      // remove some of the bookkeeping maps used for laziness.
      return;
    }

    rootContainerElement[listeningMarker] = true;
    allNativeEvents.forEach(function (domEventName) {
      if (!nonDelegatedEvents.has(domEventName)) {
        listenToNativeEvent(domEventName, false, rootContainerElement, null);
      }

      listenToNativeEvent(domEventName, true, rootContainerElement, null);
    });
  }
}
function listenToNativeEvent(domEventName, isCapturePhaseListener, rootContainerElement, targetElement) {
  var eventSystemFlags = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;
  var target = rootContainerElement; // selectionchange needs to be attached to the document
  // otherwise it won't capture incoming events that are only
  // triggered on the document directly.

  if (domEventName === 'selectionchange' && rootContainerElement.nodeType !== DOCUMENT_NODE) {
    target = rootContainerElement.ownerDocument;
  } // If the event can be delegated (or is capture phase), we can
  // register it to the root container. Otherwise, we should
  // register the event to the target element and mark it as
  // a non-delegated event.


  if (targetElement !== null && !isCapturePhaseListener && nonDelegatedEvents.has(domEventName)) {
    // For all non-delegated events, apart from scroll, we attach
    // their event listeners to the respective elements that their
    // events fire on. That means we can skip this step, as event
    // listener has already been added previously. However, we
    // special case the scroll event because the reality is that any
    // element can scroll.
    // TODO: ideally, we'd eventually apply the same logic to all
    // events from the nonDelegatedEvents list. Then we can remove
    // this special case and use the same logic for all events.
    if (domEventName !== 'scroll') {
      return;
    }

    eventSystemFlags |= IS_NON_DELEGATED;
    target = targetElement;
  }

  var listenerSet = getEventListenerSet(target);
  var listenerSetKey = getListenerSetKey(domEventName, isCapturePhaseListener); // If the listener entry is empty or we should upgrade, then
  // we need to trap an event listener onto the target.

  if (!listenerSet.has(listenerSetKey)) {
    if (isCapturePhaseListener) {
      eventSystemFlags |= IS_CAPTURE_PHASE;
    }

    addTrappedEventListener(target, domEventName, eventSystemFlags, isCapturePhaseListener);
    listenerSet.add(listenerSetKey);
  }
}

function addTrappedEventListener(targetContainer, domEventName, eventSystemFlags, isCapturePhaseListener, isDeferredListenerForLegacyFBSupport) {
  var listener = createEventListenerWrapperWithPriority(targetContainer, domEventName, eventSystemFlags); // If passive option is not supported, then the event will be
  // active and not passive.

  var isPassiveListener = undefined;

  if (passiveBrowserEventsSupported) {
    // Browsers introduced an intervention, making these events
    // passive by default on document. React doesn't bind them
    // to document anymore, but changing this now would undo
    // the performance wins from the change. So we emulate
    // the existing behavior manually on the roots now.
    // https://github.com/facebook/react/issues/19651
    if (domEventName === 'touchstart' || domEventName === 'touchmove' || domEventName === 'wheel') {
      isPassiveListener = true;
    }
  }

  targetContainer =  targetContainer;
  var unsubscribeListener; // When legacyFBSupport is enabled, it's for when we


  if (isCapturePhaseListener) {
    if (isPassiveListener !== undefined) {
      unsubscribeListener = addEventCaptureListenerWithPassiveFlag(targetContainer, domEventName, listener, isPassiveListener);
    } else {
      unsubscribeListener = addEventCaptureListener(targetContainer, domEventName, listener);
    }
  } else {
    if (isPassiveListener !== undefined) {
      unsubscribeListener = addEventBubbleListenerWithPassiveFlag(targetContainer, domEventName, listener, isPassiveListener);
    } else {
      unsubscribeListener = addEventBubbleListener(targetContainer, domEventName, listener);
    }
  }
}

function isMatchingRootContainer(grandContainer, targetContainer) {
  return grandContainer === targetContainer || grandContainer.nodeType === COMMENT_NODE && grandContainer.parentNode === targetContainer;
}

function dispatchEventForPluginEventSystem(domEventName, eventSystemFlags, nativeEvent, targetInst, targetContainer) {
  var ancestorInst = targetInst;

  if ((eventSystemFlags & IS_EVENT_HANDLE_NON_MANAGED_NODE) === 0 && (eventSystemFlags & IS_NON_DELEGATED) === 0) {
    var targetContainerNode = targetContainer; // If we are using the legacy FB support flag, we

    if (targetInst !== null) {
      // The below logic attempts to work out if we need to change
      // the target fiber to a different ancestor. We had similar logic
      // in the legacy event system, except the big difference between
      // systems is that the modern event system now has an event listener
      // attached to each React Root and React Portal Root. Together,
      // the DOM nodes representing these roots are the "rootContainer".
      // To figure out which ancestor instance we should use, we traverse
      // up the fiber tree from the target instance and attempt to find
      // root boundaries that match that of our current "rootContainer".
      // If we find that "rootContainer", we find the parent fiber
      // sub-tree for that root and make that our ancestor instance.
      var node = targetInst;

      mainLoop: while (true) {
        if (node === null) {
          return;
        }

        var nodeTag = node.tag;

        if (nodeTag === HostRoot || nodeTag === HostPortal) {
          var container = node.stateNode.containerInfo;

          if (isMatchingRootContainer(container, targetContainerNode)) {
            break;
          }

          if (nodeTag === HostPortal) {
            // The target is a portal, but it's not the rootContainer we're looking for.
            // Normally portals handle their own events all the way down to the root.
            // So we should be able to stop now. However, we don't know if this portal
            // was part of *our* root.
            var grandNode = node.return;

            while (grandNode !== null) {
              var grandTag = grandNode.tag;

              if (grandTag === HostRoot || grandTag === HostPortal) {
                var grandContainer = grandNode.stateNode.containerInfo;

                if (isMatchingRootContainer(grandContainer, targetContainerNode)) {
                  // This is the rootContainer we're looking for and we found it as
                  // a parent of the Portal. That means we can ignore it because the
                  // Portal will bubble through to us.
                  return;
                }
              }

              grandNode = grandNode.return;
            }
          } // Now we need to find it's corresponding host fiber in the other
          // tree. To do this we can use getClosestInstanceFromNode, but we
          // need to validate that the fiber is a host instance, otherwise
          // we need to traverse up through the DOM till we find the correct
          // node that is from the other tree.


          while (container !== null) {
            var parentNode = getClosestInstanceFromNode(container);

            if (parentNode === null) {
              return;
            }

            var parentTag = parentNode.tag;

            if (parentTag === HostComponent || parentTag === HostText) {
              node = ancestorInst = parentNode;
              continue mainLoop;
            }

            container = container.parentNode;
          }
        }

        node = node.return;
      }
    }
  }

  batchedEventUpdates(function () {
    return dispatchEventsForPlugins(domEventName, eventSystemFlags, nativeEvent, ancestorInst);
  });
}

function createDispatchListener(instance, listener, currentTarget) {
  return {
    instance: instance,
    listener: listener,
    currentTarget: currentTarget
  };
}

function accumulateSinglePhaseListeners(targetFiber, reactName, nativeEventType, inCapturePhase, accumulateTargetOnly) {
  var captureName = reactName !== null ? reactName + 'Capture' : null;
  var reactEventName = inCapturePhase ? captureName : reactName;
  var listeners = [];
  var instance = targetFiber;
  var lastHostComponent = null; // Accumulate all instances and listeners via the target -> root path.

  while (instance !== null) {
    var _instance2 = instance,
        stateNode = _instance2.stateNode,
        tag = _instance2.tag; // Handle listeners that are on HostComponents (i.e. <div>)

    if (tag === HostComponent && stateNode !== null) {
      lastHostComponent = stateNode; // createEventHandle listeners


      if (reactEventName !== null) {
        var listener = getListener(instance, reactEventName);

        if (listener != null) {
          listeners.push(createDispatchListener(instance, listener, lastHostComponent));
        }
      }
    } // If we are only accumulating events for the target, then we don't
    // continue to propagate through the React fiber tree to find other
    // listeners.


    if (accumulateTargetOnly) {
      break;
    }

    instance = instance.return;
  }

  return listeners;
} // We should only use this function for:
// - BeforeInputEventPlugin
// - ChangeEventPlugin
// - SelectEventPlugin
// This is because we only process these plugins
// in the bubble phase, so we need to accumulate two
// phase event listeners (via emulation).

function accumulateTwoPhaseListeners(targetFiber, reactName) {
  var captureName = reactName + 'Capture';
  var listeners = [];
  var instance = targetFiber; // Accumulate all instances and listeners via the target -> root path.

  while (instance !== null) {
    var _instance3 = instance,
        stateNode = _instance3.stateNode,
        tag = _instance3.tag; // Handle listeners that are on HostComponents (i.e. <div>)

    if (tag === HostComponent && stateNode !== null) {
      var currentTarget = stateNode;
      var captureListener = getListener(instance, captureName);

      if (captureListener != null) {
        listeners.unshift(createDispatchListener(instance, captureListener, currentTarget));
      }

      var bubbleListener = getListener(instance, reactName);

      if (bubbleListener != null) {
        listeners.push(createDispatchListener(instance, bubbleListener, currentTarget));
      }
    }

    instance = instance.return;
  }

  return listeners;
}

function getParent(inst) {
  if (inst === null) {
    return null;
  }

  do {
    inst = inst.return; // TODO: If this is a HostRoot we might want to bail out.
    // That is depending on if we want nested subtrees (layers) to bubble
    // events to their parent. We could also go through parentNode on the
    // host node but that wouldn't work for React Native and doesn't let us
    // do the portal feature.
  } while (inst && inst.tag !== HostComponent);

  if (inst) {
    return inst;
  }

  return null;
}
/**
 * Return the lowest common ancestor of A and B, or null if they are in
 * different trees.
 */


function getLowestCommonAncestor(instA, instB) {
  var nodeA = instA;
  var nodeB = instB;
  var depthA = 0;

  for (var tempA = nodeA; tempA; tempA = getParent(tempA)) {
    depthA++;
  }

  var depthB = 0;

  for (var tempB = nodeB; tempB; tempB = getParent(tempB)) {
    depthB++;
  } // If A is deeper, crawl up.


  while (depthA - depthB > 0) {
    nodeA = getParent(nodeA);
    depthA--;
  } // If B is deeper, crawl up.


  while (depthB - depthA > 0) {
    nodeB = getParent(nodeB);
    depthB--;
  } // Walk in lockstep until we find a match.


  var depth = depthA;

  while (depth--) {
    if (nodeA === nodeB || nodeB !== null && nodeA === nodeB.alternate) {
      return nodeA;
    }

    nodeA = getParent(nodeA);
    nodeB = getParent(nodeB);
  }

  return null;
}

function accumulateEnterLeaveListenersForEvent(dispatchQueue, event, target, common, inCapturePhase) {
  var registrationName = event._reactName;
  var listeners = [];
  var instance = target;

  while (instance !== null) {
    if (instance === common) {
      break;
    }

    var _instance4 = instance,
        alternate = _instance4.alternate,
        stateNode = _instance4.stateNode,
        tag = _instance4.tag;

    if (alternate !== null && alternate === common) {
      break;
    }

    if (tag === HostComponent && stateNode !== null) {
      var currentTarget = stateNode;

      if (inCapturePhase) {
        var captureListener = getListener(instance, registrationName);

        if (captureListener != null) {
          listeners.unshift(createDispatchListener(instance, captureListener, currentTarget));
        }
      } else if (!inCapturePhase) {
        var bubbleListener = getListener(instance, registrationName);

        if (bubbleListener != null) {
          listeners.push(createDispatchListener(instance, bubbleListener, currentTarget));
        }
      }
    }

    instance = instance.return;
  }

  if (listeners.length !== 0) {
    dispatchQueue.push({
      event: event,
      listeners: listeners
    });
  }
} // We should only use this function for:
// - EnterLeaveEventPlugin
// This is because we only process this plugin
// in the bubble phase, so we need to accumulate two
// phase event listeners.


function accumulateEnterLeaveTwoPhaseListeners(dispatchQueue, leaveEvent, enterEvent, from, to) {
  var common = from && to ? getLowestCommonAncestor(from, to) : null;

  if (from !== null) {
    accumulateEnterLeaveListenersForEvent(dispatchQueue, leaveEvent, from, common, false);
  }

  if (to !== null && enterEvent !== null) {
    accumulateEnterLeaveListenersForEvent(dispatchQueue, enterEvent, to, common, true);
  }
}
function getListenerSetKey(domEventName, capture) {
  return domEventName + "__" + (capture ? 'capture' : 'bubble');
}

var didWarnInvalidHydration = false;
var DANGEROUSLY_SET_INNER_HTML = 'dangerouslySetInnerHTML';
var SUPPRESS_CONTENT_EDITABLE_WARNING = 'suppressContentEditableWarning';
var SUPPRESS_HYDRATION_WARNING = 'suppressHydrationWarning';
var AUTOFOCUS = 'autoFocus';
var CHILDREN = 'children';
var STYLE = 'style';
var HTML$1 = '__html';
var HTML_NAMESPACE$1 = Namespaces.html;
var warnedUnknownTags;
var suppressHydrationWarning;
var validatePropertiesInDevelopment;
var warnForTextDifference;
var warnForPropDifference;
var warnForExtraAttributes;
var warnForInvalidEventListener;
var canDiffStyleForHydrationWarning;
var normalizeMarkupForTextOrAttribute;
var normalizeHTML;

{
  warnedUnknownTags = {
    // There are working polyfills for <dialog>. Let people use it.
    dialog: true,
    // Electron ships a custom <webview> tag to display external web content in
    // an isolated frame and process.
    // This tag is not present in non Electron environments such as JSDom which
    // is often used for testing purposes.
    // @see https://electronjs.org/docs/api/webview-tag
    webview: true
  };

  validatePropertiesInDevelopment = function (type, props) {
    validateProperties(type, props);
    validateProperties$1(type, props);
    validateProperties$2(type, props, {
      registrationNameDependencies: registrationNameDependencies,
      possibleRegistrationNames: possibleRegistrationNames
    });
  }; // IE 11 parses & normalizes the style attribute as opposed to other
  // browsers. It adds spaces and sorts the properties in some
  // non-alphabetical order. Handling that would require sorting CSS
  // properties in the client & server versions or applying
  // `expectedStyle` to a temporary DOM node to read its `style` attribute
  // normalized. Since it only affects IE, we're skipping style warnings
  // in that browser completely in favor of doing all that work.
  // See https://github.com/facebook/react/issues/11807


  canDiffStyleForHydrationWarning = canUseDOM && !document.documentMode; // HTML parsing normalizes CR and CRLF to LF.
  // It also can turn \u0000 into \uFFFD inside attributes.
  // https://www.w3.org/TR/html5/single-page.html#preprocessing-the-input-stream
  // If we have a mismatch, it might be caused by that.
  // We will still patch up in this case but not fire the warning.

  var NORMALIZE_NEWLINES_REGEX = /\r\n?/g;
  var NORMALIZE_NULL_AND_REPLACEMENT_REGEX = /\u0000|\uFFFD/g;

  normalizeMarkupForTextOrAttribute = function (markup) {
    var markupString = typeof markup === 'string' ? markup : '' + markup;
    return markupString.replace(NORMALIZE_NEWLINES_REGEX, '\n').replace(NORMALIZE_NULL_AND_REPLACEMENT_REGEX, '');
  };

  warnForTextDifference = function (serverText, clientText) {
    if (didWarnInvalidHydration) {
      return;
    }

    var normalizedClientText = normalizeMarkupForTextOrAttribute(clientText);
    var normalizedServerText = normalizeMarkupForTextOrAttribute(serverText);

    if (normalizedServerText === normalizedClientText) {
      return;
    }

    didWarnInvalidHydration = true;

    error('Text content did not match. Server: "%s" Client: "%s"', normalizedServerText, normalizedClientText);
  };

  warnForPropDifference = function (propName, serverValue, clientValue) {
    if (didWarnInvalidHydration) {
      return;
    }

    var normalizedClientValue = normalizeMarkupForTextOrAttribute(clientValue);
    var normalizedServerValue = normalizeMarkupForTextOrAttribute(serverValue);

    if (normalizedServerValue === normalizedClientValue) {
      return;
    }

    didWarnInvalidHydration = true;

    error('Prop `%s` did not match. Server: %s Client: %s', propName, JSON.stringify(normalizedServerValue), JSON.stringify(normalizedClientValue));
  };

  warnForExtraAttributes = function (attributeNames) {
    if (didWarnInvalidHydration) {
      return;
    }

    didWarnInvalidHydration = true;
    var names = [];
    attributeNames.forEach(function (name) {
      names.push(name);
    });

    error('Extra attributes from the server: %s', names);
  };

  warnForInvalidEventListener = function (registrationName, listener) {
    if (listener === false) {
      error('Expected `%s` listener to be a function, instead got `false`.\n\n' + 'If you used to conditionally omit it with %s={condition && value}, ' + 'pass %s={condition ? value : undefined} instead.', registrationName, registrationName, registrationName);
    } else {
      error('Expected `%s` listener to be a function, instead got a value of `%s` type.', registrationName, typeof listener);
    }
  }; // Parse the HTML and read it back to normalize the HTML string so that it
  // can be used for comparison.


  normalizeHTML = function (parent, html) {
    // We could have created a separate document here to avoid
    // re-initializing custom elements if they exist. But this breaks
    // how <noscript> is being handled. So we use the same document.
    // See the discussion in https://github.com/facebook/react/pull/11157.
    var testElement = parent.namespaceURI === HTML_NAMESPACE$1 ? parent.ownerDocument.createElement(parent.tagName) : parent.ownerDocument.createElementNS(parent.namespaceURI, parent.tagName);
    testElement.innerHTML = html;
    return testElement.innerHTML;
  };
}

function getOwnerDocumentFromRootContainer(rootContainerElement) {
  return rootContainerElement.nodeType === DOCUMENT_NODE ? rootContainerElement : rootContainerElement.ownerDocument;
}

function noop() {}

function trapClickOnNonInteractiveElement(node) {
  // Mobile Safari does not fire properly bubble click events on
  // non-interactive elements, which means delegated click listeners do not
  // fire. The workaround for this bug involves attaching an empty click
  // listener on the target node.
  // https://www.quirksmode.org/blog/archives/2010/09/click_event_del.html
  // Just set it using the onclick property so that we don't have to manage any
  // bookkeeping for it. Not sure if we need to clear it when the listener is
  // removed.
  // TODO: Only do this for the relevant Safaris maybe?
  node.onclick = noop;
}

function setInitialDOMProperties(tag, domElement, rootContainerElement, nextProps, isCustomComponentTag) {
  for (var propKey in nextProps) {
    if (!nextProps.hasOwnProperty(propKey)) {
      continue;
    }

    var nextProp = nextProps[propKey];

    if (propKey === STYLE) {
      {
        if (nextProp) {
          // Freeze the next style object so that we can assume it won't be
          // mutated. We have already warned for this in the past.
          Object.freeze(nextProp);
        }
      } // Relies on `updateStylesByID` not mutating `styleUpdates`.


      setValueForStyles(domElement, nextProp);
    } else if (propKey === DANGEROUSLY_SET_INNER_HTML) {
      var nextHtml = nextProp ? nextProp[HTML$1] : undefined;

      if (nextHtml != null) {
        setInnerHTML(domElement, nextHtml);
      }
    } else if (propKey === CHILDREN) {
      if (typeof nextProp === 'string') {
        // Avoid setting initial textContent when the text is empty. In IE11 setting
        // textContent on a <textarea> will cause the placeholder to not
        // show within the <textarea> until it has been focused and blurred again.
        // https://github.com/facebook/react/issues/6731#issuecomment-254874553
        var canSetTextContent = tag !== 'textarea' || nextProp !== '';

        if (canSetTextContent) {
          setTextContent(domElement, nextProp);
        }
      } else if (typeof nextProp === 'number') {
        setTextContent(domElement, '' + nextProp);
      }
    } else if (propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING) ; else if (propKey === AUTOFOCUS) ; else if (registrationNameDependencies.hasOwnProperty(propKey)) {
      if (nextProp != null) {
        if ( typeof nextProp !== 'function') {
          warnForInvalidEventListener(propKey, nextProp);
        }

        if (propKey === 'onScroll') {
          listenToNonDelegatedEvent('scroll', domElement);
        }
      }
    } else if (nextProp != null) {
      setValueForProperty(domElement, propKey, nextProp, isCustomComponentTag);
    }
  }
}

function updateDOMProperties(domElement, updatePayload, wasCustomComponentTag, isCustomComponentTag) {
  // TODO: Handle wasCustomComponentTag
  for (var i = 0; i < updatePayload.length; i += 2) {
    var propKey = updatePayload[i];
    var propValue = updatePayload[i + 1];

    if (propKey === STYLE) {
      setValueForStyles(domElement, propValue);
    } else if (propKey === DANGEROUSLY_SET_INNER_HTML) {
      setInnerHTML(domElement, propValue);
    } else if (propKey === CHILDREN) {
      setTextContent(domElement, propValue);
    } else {
      setValueForProperty(domElement, propKey, propValue, isCustomComponentTag);
    }
  }
}

function createElement(type, props, rootContainerElement, parentNamespace) {
  var isCustomComponentTag; // We create tags in the namespace of their parent container, except HTML
  // tags get no namespace.

  var ownerDocument = getOwnerDocumentFromRootContainer(rootContainerElement);
  var domElement;
  var namespaceURI = parentNamespace;

  if (namespaceURI === HTML_NAMESPACE$1) {
    namespaceURI = getIntrinsicNamespace(type);
  }

  if (namespaceURI === HTML_NAMESPACE$1) {
    {
      isCustomComponentTag = isCustomComponent(type, props); // Should this check be gated by parent namespace? Not sure we want to
      // allow <SVG> or <mATH>.

      if (!isCustomComponentTag && type !== type.toLowerCase()) {
        error('<%s /> is using incorrect casing. ' + 'Use PascalCase for React components, ' + 'or lowercase for HTML elements.', type);
      }
    }

    if (type === 'script') {
      // Create the script via .innerHTML so its "parser-inserted" flag is
      // set to true and it does not execute
      var div = ownerDocument.createElement('div');

      div.innerHTML = '<script><' + '/script>'; // eslint-disable-line
      // This is guaranteed to yield a script element.

      var firstChild = div.firstChild;
      domElement = div.removeChild(firstChild);
    } else if (typeof props.is === 'string') {
      // $FlowIssue `createElement` should be updated for Web Components
      domElement = ownerDocument.createElement(type, {
        is: props.is
      });
    } else {
      // Separate else branch instead of using `props.is || undefined` above because of a Firefox bug.
      // See discussion in https://github.com/facebook/react/pull/6896
      // and discussion in https://bugzilla.mozilla.org/show_bug.cgi?id=1276240
      domElement = ownerDocument.createElement(type); // Normally attributes are assigned in `setInitialDOMProperties`, however the `multiple` and `size`
      // attributes on `select`s needs to be added before `option`s are inserted.
      // This prevents:
      // - a bug where the `select` does not scroll to the correct option because singular
      //  `select` elements automatically pick the first item #13222
      // - a bug where the `select` set the first item as selected despite the `size` attribute #14239
      // See https://github.com/facebook/react/issues/13222
      // and https://github.com/facebook/react/issues/14239

      if (type === 'select') {
        var node = domElement;

        if (props.multiple) {
          node.multiple = true;
        } else if (props.size) {
          // Setting a size greater than 1 causes a select to behave like `multiple=true`, where
          // it is possible that no option is selected.
          //
          // This is only necessary when a select in "single selection mode".
          node.size = props.size;
        }
      }
    }
  } else {
    domElement = ownerDocument.createElementNS(namespaceURI, type);
  }

  {
    if (namespaceURI === HTML_NAMESPACE$1) {
      if (!isCustomComponentTag && Object.prototype.toString.call(domElement) === '[object HTMLUnknownElement]' && !Object.prototype.hasOwnProperty.call(warnedUnknownTags, type)) {
        warnedUnknownTags[type] = true;

        error('The tag <%s> is unrecognized in this browser. ' + 'If you meant to render a React component, start its name with ' + 'an uppercase letter.', type);
      }
    }
  }

  return domElement;
}
function createTextNode(text, rootContainerElement) {
  return getOwnerDocumentFromRootContainer(rootContainerElement).createTextNode(text);
}
function setInitialProperties(domElement, tag, rawProps, rootContainerElement) {
  var isCustomComponentTag = isCustomComponent(tag, rawProps);

  {
    validatePropertiesInDevelopment(tag, rawProps);
  } // TODO: Make sure that we check isMounted before firing any of these events.


  var props;

  switch (tag) {
    case 'dialog':
      listenToNonDelegatedEvent('cancel', domElement);
      listenToNonDelegatedEvent('close', domElement);
      props = rawProps;
      break;

    case 'iframe':
    case 'object':
    case 'embed':
      // We listen to this event in case to ensure emulated bubble
      // listeners still fire for the load event.
      listenToNonDelegatedEvent('load', domElement);
      props = rawProps;
      break;

    case 'video':
    case 'audio':
      // We listen to these events in case to ensure emulated bubble
      // listeners still fire for all the media events.
      for (var i = 0; i < mediaEventTypes.length; i++) {
        listenToNonDelegatedEvent(mediaEventTypes[i], domElement);
      }

      props = rawProps;
      break;

    case 'source':
      // We listen to this event in case to ensure emulated bubble
      // listeners still fire for the error event.
      listenToNonDelegatedEvent('error', domElement);
      props = rawProps;
      break;

    case 'img':
    case 'image':
    case 'link':
      // We listen to these events in case to ensure emulated bubble
      // listeners still fire for error and load events.
      listenToNonDelegatedEvent('error', domElement);
      listenToNonDelegatedEvent('load', domElement);
      props = rawProps;
      break;

    case 'details':
      // We listen to this event in case to ensure emulated bubble
      // listeners still fire for the toggle event.
      listenToNonDelegatedEvent('toggle', domElement);
      props = rawProps;
      break;

    case 'input':
      initWrapperState(domElement, rawProps);
      props = getHostProps(domElement, rawProps); // We listen to this event in case to ensure emulated bubble
      // listeners still fire for the invalid event.

      listenToNonDelegatedEvent('invalid', domElement);

      break;

    case 'option':
      validateProps(domElement, rawProps);
      props = getHostProps$1(domElement, rawProps);
      break;

    case 'select':
      initWrapperState$1(domElement, rawProps);
      props = getHostProps$2(domElement, rawProps); // We listen to this event in case to ensure emulated bubble
      // listeners still fire for the invalid event.

      listenToNonDelegatedEvent('invalid', domElement);

      break;

    case 'textarea':
      initWrapperState$2(domElement, rawProps);
      props = getHostProps$3(domElement, rawProps); // We listen to this event in case to ensure emulated bubble
      // listeners still fire for the invalid event.

      listenToNonDelegatedEvent('invalid', domElement);

      break;

    default:
      props = rawProps;
  }

  assertValidProps(tag, props);
  setInitialDOMProperties(tag, domElement, rootContainerElement, props, isCustomComponentTag);

  switch (tag) {
    case 'input':
      // TODO: Make sure we check if this is still unmounted or do any clean
      // up necessary since we never stop tracking anymore.
      track(domElement);
      postMountWrapper(domElement, rawProps, false);
      break;

    case 'textarea':
      // TODO: Make sure we check if this is still unmounted or do any clean
      // up necessary since we never stop tracking anymore.
      track(domElement);
      postMountWrapper$3(domElement);
      break;

    case 'option':
      postMountWrapper$1(domElement, rawProps);
      break;

    case 'select':
      postMountWrapper$2(domElement, rawProps);
      break;

    default:
      if (typeof props.onClick === 'function') {
        // TODO: This cast may not be sound for SVG, MathML or custom elements.
        trapClickOnNonInteractiveElement(domElement);
      }

      break;
  }
} // Calculate the diff between the two objects.

function diffProperties(domElement, tag, lastRawProps, nextRawProps, rootContainerElement) {
  {
    validatePropertiesInDevelopment(tag, nextRawProps);
  }

  var updatePayload = null;
  var lastProps;
  var nextProps;

  switch (tag) {
    case 'input':
      lastProps = getHostProps(domElement, lastRawProps);
      nextProps = getHostProps(domElement, nextRawProps);
      updatePayload = [];
      break;

    case 'option':
      lastProps = getHostProps$1(domElement, lastRawProps);
      nextProps = getHostProps$1(domElement, nextRawProps);
      updatePayload = [];
      break;

    case 'select':
      lastProps = getHostProps$2(domElement, lastRawProps);
      nextProps = getHostProps$2(domElement, nextRawProps);
      updatePayload = [];
      break;

    case 'textarea':
      lastProps = getHostProps$3(domElement, lastRawProps);
      nextProps = getHostProps$3(domElement, nextRawProps);
      updatePayload = [];
      break;

    default:
      lastProps = lastRawProps;
      nextProps = nextRawProps;

      if (typeof lastProps.onClick !== 'function' && typeof nextProps.onClick === 'function') {
        // TODO: This cast may not be sound for SVG, MathML or custom elements.
        trapClickOnNonInteractiveElement(domElement);
      }

      break;
  }

  assertValidProps(tag, nextProps);
  var propKey;
  var styleName;
  var styleUpdates = null;

  for (propKey in lastProps) {
    if (nextProps.hasOwnProperty(propKey) || !lastProps.hasOwnProperty(propKey) || lastProps[propKey] == null) {
      continue;
    }

    if (propKey === STYLE) {
      var lastStyle = lastProps[propKey];

      for (styleName in lastStyle) {
        if (lastStyle.hasOwnProperty(styleName)) {
          if (!styleUpdates) {
            styleUpdates = {};
          }

          styleUpdates[styleName] = '';
        }
      }
    } else if (propKey === DANGEROUSLY_SET_INNER_HTML || propKey === CHILDREN) ; else if (propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING) ; else if (propKey === AUTOFOCUS) ; else if (registrationNameDependencies.hasOwnProperty(propKey)) {
      // This is a special case. If any listener updates we need to ensure
      // that the "current" fiber pointer gets updated so we need a commit
      // to update this element.
      if (!updatePayload) {
        updatePayload = [];
      }
    } else {
      // For all other deleted properties we add it to the queue. We use
      // the allowed property list in the commit phase instead.
      (updatePayload = updatePayload || []).push(propKey, null);
    }
  }

  for (propKey in nextProps) {
    var nextProp = nextProps[propKey];
    var lastProp = lastProps != null ? lastProps[propKey] : undefined;

    if (!nextProps.hasOwnProperty(propKey) || nextProp === lastProp || nextProp == null && lastProp == null) {
      continue;
    }

    if (propKey === STYLE) {
      {
        if (nextProp) {
          // Freeze the next style object so that we can assume it won't be
          // mutated. We have already warned for this in the past.
          Object.freeze(nextProp);
        }
      }

      if (lastProp) {
        // Unset styles on `lastProp` but not on `nextProp`.
        for (styleName in lastProp) {
          if (lastProp.hasOwnProperty(styleName) && (!nextProp || !nextProp.hasOwnProperty(styleName))) {
            if (!styleUpdates) {
              styleUpdates = {};
            }

            styleUpdates[styleName] = '';
          }
        } // Update styles that changed since `lastProp`.


        for (styleName in nextProp) {
          if (nextProp.hasOwnProperty(styleName) && lastProp[styleName] !== nextProp[styleName]) {
            if (!styleUpdates) {
              styleUpdates = {};
            }

            styleUpdates[styleName] = nextProp[styleName];
          }
        }
      } else {
        // Relies on `updateStylesByID` not mutating `styleUpdates`.
        if (!styleUpdates) {
          if (!updatePayload) {
            updatePayload = [];
          }

          updatePayload.push(propKey, styleUpdates);
        }

        styleUpdates = nextProp;
      }
    } else if (propKey === DANGEROUSLY_SET_INNER_HTML) {
      var nextHtml = nextProp ? nextProp[HTML$1] : undefined;
      var lastHtml = lastProp ? lastProp[HTML$1] : undefined;

      if (nextHtml != null) {
        if (lastHtml !== nextHtml) {
          (updatePayload = updatePayload || []).push(propKey, nextHtml);
        }
      }
    } else if (propKey === CHILDREN) {
      if (typeof nextProp === 'string' || typeof nextProp === 'number') {
        (updatePayload = updatePayload || []).push(propKey, '' + nextProp);
      }
    } else if (propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING) ; else if (registrationNameDependencies.hasOwnProperty(propKey)) {
      if (nextProp != null) {
        // We eagerly listen to this even though we haven't committed yet.
        if ( typeof nextProp !== 'function') {
          warnForInvalidEventListener(propKey, nextProp);
        }

        if (propKey === 'onScroll') {
          listenToNonDelegatedEvent('scroll', domElement);
        }
      }

      if (!updatePayload && lastProp !== nextProp) {
        // This is a special case. If any listener updates we need to ensure
        // that the "current" props pointer gets updated so we need a commit
        // to update this element.
        updatePayload = [];
      }
    } else if (typeof nextProp === 'object' && nextProp !== null && nextProp.$$typeof === REACT_OPAQUE_ID_TYPE) {
      // If we encounter useOpaqueReference's opaque object, this means we are hydrating.
      // In this case, call the opaque object's toString function which generates a new client
      // ID so client and server IDs match and throws to rerender.
      nextProp.toString();
    } else {
      // For any other property we always add it to the queue and then we
      // filter it out using the allowed property list during the commit.
      (updatePayload = updatePayload || []).push(propKey, nextProp);
    }
  }

  if (styleUpdates) {
    {
      validateShorthandPropertyCollisionInDev(styleUpdates, nextProps[STYLE]);
    }

    (updatePayload = updatePayload || []).push(STYLE, styleUpdates);
  }

  return updatePayload;
} // Apply the diff.

function updateProperties(domElement, updatePayload, tag, lastRawProps, nextRawProps) {
  // Update checked *before* name.
  // In the middle of an update, it is possible to have multiple checked.
  // When a checked radio tries to change name, browser makes another radio's checked false.
  if (tag === 'input' && nextRawProps.type === 'radio' && nextRawProps.name != null) {
    updateChecked(domElement, nextRawProps);
  }

  var wasCustomComponentTag = isCustomComponent(tag, lastRawProps);
  var isCustomComponentTag = isCustomComponent(tag, nextRawProps); // Apply the diff.

  updateDOMProperties(domElement, updatePayload, wasCustomComponentTag, isCustomComponentTag); // TODO: Ensure that an update gets scheduled if any of the special props
  // changed.

  switch (tag) {
    case 'input':
      // Update the wrapper around inputs *after* updating props. This has to
      // happen after `updateDOMProperties`. Otherwise HTML5 input validations
      // raise warnings and prevent the new value from being assigned.
      updateWrapper(domElement, nextRawProps);
      break;

    case 'textarea':
      updateWrapper$1(domElement, nextRawProps);
      break;

    case 'select':
      // <select> value update needs to occur after <option> children
      // reconciliation
      postUpdateWrapper(domElement, nextRawProps);
      break;
  }
}

function getPossibleStandardName(propName) {
  {
    var lowerCasedName = propName.toLowerCase();

    if (!possibleStandardNames.hasOwnProperty(lowerCasedName)) {
      return null;
    }

    return possibleStandardNames[lowerCasedName] || null;
  }
}

function diffHydratedProperties(domElement, tag, rawProps, parentNamespace, rootContainerElement) {
  var isCustomComponentTag;
  var extraAttributeNames;

  {
    suppressHydrationWarning = rawProps[SUPPRESS_HYDRATION_WARNING] === true;
    isCustomComponentTag = isCustomComponent(tag, rawProps);
    validatePropertiesInDevelopment(tag, rawProps);
  } // TODO: Make sure that we check isMounted before firing any of these events.


  switch (tag) {
    case 'dialog':
      listenToNonDelegatedEvent('cancel', domElement);
      listenToNonDelegatedEvent('close', domElement);
      break;

    case 'iframe':
    case 'object':
    case 'embed':
      // We listen to this event in case to ensure emulated bubble
      // listeners still fire for the load event.
      listenToNonDelegatedEvent('load', domElement);
      break;

    case 'video':
    case 'audio':
      // We listen to these events in case to ensure emulated bubble
      // listeners still fire for all the media events.
      for (var i = 0; i < mediaEventTypes.length; i++) {
        listenToNonDelegatedEvent(mediaEventTypes[i], domElement);
      }

      break;

    case 'source':
      // We listen to this event in case to ensure emulated bubble
      // listeners still fire for the error event.
      listenToNonDelegatedEvent('error', domElement);
      break;

    case 'img':
    case 'image':
    case 'link':
      // We listen to these events in case to ensure emulated bubble
      // listeners still fire for error and load events.
      listenToNonDelegatedEvent('error', domElement);
      listenToNonDelegatedEvent('load', domElement);
      break;

    case 'details':
      // We listen to this event in case to ensure emulated bubble
      // listeners still fire for the toggle event.
      listenToNonDelegatedEvent('toggle', domElement);
      break;

    case 'input':
      initWrapperState(domElement, rawProps); // We listen to this event in case to ensure emulated bubble
      // listeners still fire for the invalid event.

      listenToNonDelegatedEvent('invalid', domElement);

      break;

    case 'option':
      validateProps(domElement, rawProps);
      break;

    case 'select':
      initWrapperState$1(domElement, rawProps); // We listen to this event in case to ensure emulated bubble
      // listeners still fire for the invalid event.

      listenToNonDelegatedEvent('invalid', domElement);

      break;

    case 'textarea':
      initWrapperState$2(domElement, rawProps); // We listen to this event in case to ensure emulated bubble
      // listeners still fire for the invalid event.

      listenToNonDelegatedEvent('invalid', domElement);

      break;
  }

  assertValidProps(tag, rawProps);

  {
    extraAttributeNames = new Set();
    var attributes = domElement.attributes;

    for (var _i = 0; _i < attributes.length; _i++) {
      var name = attributes[_i].name.toLowerCase();

      switch (name) {
        // Built-in SSR attribute is allowed
        case 'data-reactroot':
          break;
        // Controlled attributes are not validated
        // TODO: Only ignore them on controlled tags.

        case 'value':
          break;

        case 'checked':
          break;

        case 'selected':
          break;

        default:
          // Intentionally use the original name.
          // See discussion in https://github.com/facebook/react/pull/10676.
          extraAttributeNames.add(attributes[_i].name);
      }
    }
  }

  var updatePayload = null;

  for (var propKey in rawProps) {
    if (!rawProps.hasOwnProperty(propKey)) {
      continue;
    }

    var nextProp = rawProps[propKey];

    if (propKey === CHILDREN) {
      // For text content children we compare against textContent. This
      // might match additional HTML that is hidden when we read it using
      // textContent. E.g. "foo" will match "f<span>oo</span>" but that still
      // satisfies our requirement. Our requirement is not to produce perfect
      // HTML and attributes. Ideally we should preserve structure but it's
      // ok not to if the visible content is still enough to indicate what
      // even listeners these nodes might be wired up to.
      // TODO: Warn if there is more than a single textNode as a child.
      // TODO: Should we use domElement.firstChild.nodeValue to compare?
      if (typeof nextProp === 'string') {
        if (domElement.textContent !== nextProp) {
          if ( !suppressHydrationWarning) {
            warnForTextDifference(domElement.textContent, nextProp);
          }

          updatePayload = [CHILDREN, nextProp];
        }
      } else if (typeof nextProp === 'number') {
        if (domElement.textContent !== '' + nextProp) {
          if ( !suppressHydrationWarning) {
            warnForTextDifference(domElement.textContent, nextProp);
          }

          updatePayload = [CHILDREN, '' + nextProp];
        }
      }
    } else if (registrationNameDependencies.hasOwnProperty(propKey)) {
      if (nextProp != null) {
        if ( typeof nextProp !== 'function') {
          warnForInvalidEventListener(propKey, nextProp);
        }

        if (propKey === 'onScroll') {
          listenToNonDelegatedEvent('scroll', domElement);
        }
      }
    } else if ( // Convince Flow we've calculated it (it's DEV-only in this method.)
    typeof isCustomComponentTag === 'boolean') {
      // Validate that the properties correspond to their expected values.
      var serverValue = void 0;
      var propertyInfo = getPropertyInfo(propKey);

      if (suppressHydrationWarning) ; else if (propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING || // Controlled attributes are not validated
      // TODO: Only ignore them on controlled tags.
      propKey === 'value' || propKey === 'checked' || propKey === 'selected') ; else if (propKey === DANGEROUSLY_SET_INNER_HTML) {
        var serverHTML = domElement.innerHTML;
        var nextHtml = nextProp ? nextProp[HTML$1] : undefined;

        if (nextHtml != null) {
          var expectedHTML = normalizeHTML(domElement, nextHtml);

          if (expectedHTML !== serverHTML) {
            warnForPropDifference(propKey, serverHTML, expectedHTML);
          }
        }
      } else if (propKey === STYLE) {
        // $FlowFixMe - Should be inferred as not undefined.
        extraAttributeNames.delete(propKey);

        if (canDiffStyleForHydrationWarning) {
          var expectedStyle = createDangerousStringForStyles(nextProp);
          serverValue = domElement.getAttribute('style');

          if (expectedStyle !== serverValue) {
            warnForPropDifference(propKey, serverValue, expectedStyle);
          }
        }
      } else if (isCustomComponentTag) {
        // $FlowFixMe - Should be inferred as not undefined.
        extraAttributeNames.delete(propKey.toLowerCase());
        serverValue = getValueForAttribute(domElement, propKey, nextProp);

        if (nextProp !== serverValue) {
          warnForPropDifference(propKey, serverValue, nextProp);
        }
      } else if (!shouldIgnoreAttribute(propKey, propertyInfo, isCustomComponentTag) && !shouldRemoveAttribute(propKey, nextProp, propertyInfo, isCustomComponentTag)) {
        var isMismatchDueToBadCasing = false;

        if (propertyInfo !== null) {
          // $FlowFixMe - Should be inferred as not undefined.
          extraAttributeNames.delete(propertyInfo.attributeName);
          serverValue = getValueForProperty(domElement, propKey, nextProp, propertyInfo);
        } else {
          var ownNamespace = parentNamespace;

          if (ownNamespace === HTML_NAMESPACE$1) {
            ownNamespace = getIntrinsicNamespace(tag);
          }

          if (ownNamespace === HTML_NAMESPACE$1) {
            // $FlowFixMe - Should be inferred as not undefined.
            extraAttributeNames.delete(propKey.toLowerCase());
          } else {
            var standardName = getPossibleStandardName(propKey);

            if (standardName !== null && standardName !== propKey) {
              // If an SVG prop is supplied with bad casing, it will
              // be successfully parsed from HTML, but will produce a mismatch
              // (and would be incorrectly rendered on the client).
              // However, we already warn about bad casing elsewhere.
              // So we'll skip the misleading extra mismatch warning in this case.
              isMismatchDueToBadCasing = true; // $FlowFixMe - Should be inferred as not undefined.

              extraAttributeNames.delete(standardName);
            } // $FlowFixMe - Should be inferred as not undefined.


            extraAttributeNames.delete(propKey);
          }

          serverValue = getValueForAttribute(domElement, propKey, nextProp);
        }

        if (nextProp !== serverValue && !isMismatchDueToBadCasing) {
          warnForPropDifference(propKey, serverValue, nextProp);
        }
      }
    }
  }

  {
    // $FlowFixMe - Should be inferred as not undefined.
    if (extraAttributeNames.size > 0 && !suppressHydrationWarning) {
      // $FlowFixMe - Should be inferred as not undefined.
      warnForExtraAttributes(extraAttributeNames);
    }
  }

  switch (tag) {
    case 'input':
      // TODO: Make sure we check if this is still unmounted or do any clean
      // up necessary since we never stop tracking anymore.
      track(domElement);
      postMountWrapper(domElement, rawProps, true);
      break;

    case 'textarea':
      // TODO: Make sure we check if this is still unmounted or do any clean
      // up necessary since we never stop tracking anymore.
      track(domElement);
      postMountWrapper$3(domElement);
      break;

    case 'select':
    case 'option':
      // For input and textarea we current always set the value property at
      // post mount to force it to diverge from attributes. However, for
      // option and select we don't quite do the same thing and select
      // is not resilient to the DOM state changing so we don't do that here.
      // TODO: Consider not doing this for input and textarea.
      break;

    default:
      if (typeof rawProps.onClick === 'function') {
        // TODO: This cast may not be sound for SVG, MathML or custom elements.
        trapClickOnNonInteractiveElement(domElement);
      }

      break;
  }

  return updatePayload;
}
function diffHydratedText(textNode, text) {
  var isDifferent = textNode.nodeValue !== text;
  return isDifferent;
}
function warnForUnmatchedText(textNode, text) {
  {
    warnForTextDifference(textNode.nodeValue, text);
  }
}
function warnForDeletedHydratableElement(parentNode, child) {
  {
    if (didWarnInvalidHydration) {
      return;
    }

    didWarnInvalidHydration = true;

    error('Did not expect server HTML to contain a <%s> in <%s>.', child.nodeName.toLowerCase(), parentNode.nodeName.toLowerCase());
  }
}
function warnForDeletedHydratableText(parentNode, child) {
  {
    if (didWarnInvalidHydration) {
      return;
    }

    didWarnInvalidHydration = true;

    error('Did not expect server HTML to contain the text node "%s" in <%s>.', child.nodeValue, parentNode.nodeName.toLowerCase());
  }
}
function warnForInsertedHydratedElement(parentNode, tag, props) {
  {
    if (didWarnInvalidHydration) {
      return;
    }

    didWarnInvalidHydration = true;

    error('Expected server HTML to contain a matching <%s> in <%s>.', tag, parentNode.nodeName.toLowerCase());
  }
}
function warnForInsertedHydratedText(parentNode, text) {
  {
    if (text === '') {
      // We expect to insert empty text nodes since they're not represented in
      // the HTML.
      // TODO: Remove this special case if we can just avoid inserting empty
      // text nodes.
      return;
    }

    if (didWarnInvalidHydration) {
      return;
    }

    didWarnInvalidHydration = true;

    error('Expected server HTML to contain a matching text node for "%s" in <%s>.', text, parentNode.nodeName.toLowerCase());
  }
}
function restoreControlledState$3(domElement, tag, props) {
  switch (tag) {
    case 'input':
      restoreControlledState(domElement, props);
      return;

    case 'textarea':
      restoreControlledState$2(domElement, props);
      return;

    case 'select':
      restoreControlledState$1(domElement, props);
      return;
  }
}

var validateDOMNesting = function () {};

var updatedAncestorInfo = function () {};

{
  // This validation code was written based on the HTML5 parsing spec:
  // https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-scope
  //
  // Note: this does not catch all invalid nesting, nor does it try to (as it's
  // not clear what practical benefit doing so provides); instead, we warn only
  // for cases where the parser will give a parse tree differing from what React
  // intended. For example, <b><div></div></b> is invalid but we don't warn
  // because it still parses correctly; we do warn for other cases like nested
  // <p> tags where the beginning of the second element implicitly closes the
  // first, causing a confusing mess.
  // https://html.spec.whatwg.org/multipage/syntax.html#special
  var specialTags = ['address', 'applet', 'area', 'article', 'aside', 'base', 'basefont', 'bgsound', 'blockquote', 'body', 'br', 'button', 'caption', 'center', 'col', 'colgroup', 'dd', 'details', 'dir', 'div', 'dl', 'dt', 'embed', 'fieldset', 'figcaption', 'figure', 'footer', 'form', 'frame', 'frameset', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hgroup', 'hr', 'html', 'iframe', 'img', 'input', 'isindex', 'li', 'link', 'listing', 'main', 'marquee', 'menu', 'menuitem', 'meta', 'nav', 'noembed', 'noframes', 'noscript', 'object', 'ol', 'p', 'param', 'plaintext', 'pre', 'script', 'section', 'select', 'source', 'style', 'summary', 'table', 'tbody', 'td', 'template', 'textarea', 'tfoot', 'th', 'thead', 'title', 'tr', 'track', 'ul', 'wbr', 'xmp']; // https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-scope

  var inScopeTags = ['applet', 'caption', 'html', 'table', 'td', 'th', 'marquee', 'object', 'template', // https://html.spec.whatwg.org/multipage/syntax.html#html-integration-point
  // TODO: Distinguish by namespace here -- for <title>, including it here
  // errs on the side of fewer warnings
  'foreignObject', 'desc', 'title']; // https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-button-scope

  var buttonScopeTags = inScopeTags.concat(['button']); // https://html.spec.whatwg.org/multipage/syntax.html#generate-implied-end-tags

  var impliedEndTags = ['dd', 'dt', 'li', 'option', 'optgroup', 'p', 'rp', 'rt'];
  var emptyAncestorInfo = {
    current: null,
    formTag: null,
    aTagInScope: null,
    buttonTagInScope: null,
    nobrTagInScope: null,
    pTagInButtonScope: null,
    listItemTagAutoclosing: null,
    dlItemTagAutoclosing: null
  };

  updatedAncestorInfo = function (oldInfo, tag) {
    var ancestorInfo = _assign({}, oldInfo || emptyAncestorInfo);

    var info = {
      tag: tag
    };

    if (inScopeTags.indexOf(tag) !== -1) {
      ancestorInfo.aTagInScope = null;
      ancestorInfo.buttonTagInScope = null;
      ancestorInfo.nobrTagInScope = null;
    }

    if (buttonScopeTags.indexOf(tag) !== -1) {
      ancestorInfo.pTagInButtonScope = null;
    } // See rules for 'li', 'dd', 'dt' start tags in
    // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inbody


    if (specialTags.indexOf(tag) !== -1 && tag !== 'address' && tag !== 'div' && tag !== 'p') {
      ancestorInfo.listItemTagAutoclosing = null;
      ancestorInfo.dlItemTagAutoclosing = null;
    }

    ancestorInfo.current = info;

    if (tag === 'form') {
      ancestorInfo.formTag = info;
    }

    if (tag === 'a') {
      ancestorInfo.aTagInScope = info;
    }

    if (tag === 'button') {
      ancestorInfo.buttonTagInScope = info;
    }

    if (tag === 'nobr') {
      ancestorInfo.nobrTagInScope = info;
    }

    if (tag === 'p') {
      ancestorInfo.pTagInButtonScope = info;
    }

    if (tag === 'li') {
      ancestorInfo.listItemTagAutoclosing = info;
    }

    if (tag === 'dd' || tag === 'dt') {
      ancestorInfo.dlItemTagAutoclosing = info;
    }

    return ancestorInfo;
  };
  /**
   * Returns whether
   */


  var isTagValidWithParent = function (tag, parentTag) {
    // First, let's check if we're in an unusual parsing mode...
    switch (parentTag) {
      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inselect
      case 'select':
        return tag === 'option' || tag === 'optgroup' || tag === '#text';

      case 'optgroup':
        return tag === 'option' || tag === '#text';
      // Strictly speaking, seeing an <option> doesn't mean we're in a <select>
      // but

      case 'option':
        return tag === '#text';
      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intd
      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incaption
      // No special behavior since these rules fall back to "in body" mode for
      // all except special table nodes which cause bad parsing behavior anyway.
      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intr

      case 'tr':
        return tag === 'th' || tag === 'td' || tag === 'style' || tag === 'script' || tag === 'template';
      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intbody

      case 'tbody':
      case 'thead':
      case 'tfoot':
        return tag === 'tr' || tag === 'style' || tag === 'script' || tag === 'template';
      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incolgroup

      case 'colgroup':
        return tag === 'col' || tag === 'template';
      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intable

      case 'table':
        return tag === 'caption' || tag === 'colgroup' || tag === 'tbody' || tag === 'tfoot' || tag === 'thead' || tag === 'style' || tag === 'script' || tag === 'template';
      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inhead

      case 'head':
        return tag === 'base' || tag === 'basefont' || tag === 'bgsound' || tag === 'link' || tag === 'meta' || tag === 'title' || tag === 'noscript' || tag === 'noframes' || tag === 'style' || tag === 'script' || tag === 'template';
      // https://html.spec.whatwg.org/multipage/semantics.html#the-html-element

      case 'html':
        return tag === 'head' || tag === 'body' || tag === 'frameset';

      case 'frameset':
        return tag === 'frame';

      case '#document':
        return tag === 'html';
    } // Probably in the "in body" parsing mode, so we outlaw only tag combos
    // where the parsing rules cause implicit opens or closes to be added.
    // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inbody


    switch (tag) {
      case 'h1':
      case 'h2':
      case 'h3':
      case 'h4':
      case 'h5':
      case 'h6':
        return parentTag !== 'h1' && parentTag !== 'h2' && parentTag !== 'h3' && parentTag !== 'h4' && parentTag !== 'h5' && parentTag !== 'h6';

      case 'rp':
      case 'rt':
        return impliedEndTags.indexOf(parentTag) === -1;

      case 'body':
      case 'caption':
      case 'col':
      case 'colgroup':
      case 'frameset':
      case 'frame':
      case 'head':
      case 'html':
      case 'tbody':
      case 'td':
      case 'tfoot':
      case 'th':
      case 'thead':
      case 'tr':
        // These tags are only valid with a few parents that have special child
        // parsing rules -- if we're down here, then none of those matched and
        // so we allow it only if we don't know what the parent is, as all other
        // cases are invalid.
        return parentTag == null;
    }

    return true;
  };
  /**
   * Returns whether
   */


  var findInvalidAncestorForTag = function (tag, ancestorInfo) {
    switch (tag) {
      case 'address':
      case 'article':
      case 'aside':
      case 'blockquote':
      case 'center':
      case 'details':
      case 'dialog':
      case 'dir':
      case 'div':
      case 'dl':
      case 'fieldset':
      case 'figcaption':
      case 'figure':
      case 'footer':
      case 'header':
      case 'hgroup':
      case 'main':
      case 'menu':
      case 'nav':
      case 'ol':
      case 'p':
      case 'section':
      case 'summary':
      case 'ul':
      case 'pre':
      case 'listing':
      case 'table':
      case 'hr':
      case 'xmp':
      case 'h1':
      case 'h2':
      case 'h3':
      case 'h4':
      case 'h5':
      case 'h6':
        return ancestorInfo.pTagInButtonScope;

      case 'form':
        return ancestorInfo.formTag || ancestorInfo.pTagInButtonScope;

      case 'li':
        return ancestorInfo.listItemTagAutoclosing;

      case 'dd':
      case 'dt':
        return ancestorInfo.dlItemTagAutoclosing;

      case 'button':
        return ancestorInfo.buttonTagInScope;

      case 'a':
        // Spec says something about storing a list of markers, but it sounds
        // equivalent to this check.
        return ancestorInfo.aTagInScope;

      case 'nobr':
        return ancestorInfo.nobrTagInScope;
    }

    return null;
  };

  var didWarn$1 = {};

  validateDOMNesting = function (childTag, childText, ancestorInfo) {
    ancestorInfo = ancestorInfo || emptyAncestorInfo;
    var parentInfo = ancestorInfo.current;
    var parentTag = parentInfo && parentInfo.tag;

    if (childText != null) {
      if (childTag != null) {
        error('validateDOMNesting: when childText is passed, childTag should be null');
      }

      childTag = '#text';
    }

    var invalidParent = isTagValidWithParent(childTag, parentTag) ? null : parentInfo;
    var invalidAncestor = invalidParent ? null : findInvalidAncestorForTag(childTag, ancestorInfo);
    var invalidParentOrAncestor = invalidParent || invalidAncestor;

    if (!invalidParentOrAncestor) {
      return;
    }

    var ancestorTag = invalidParentOrAncestor.tag;
    var warnKey = !!invalidParent + '|' + childTag + '|' + ancestorTag;

    if (didWarn$1[warnKey]) {
      return;
    }

    didWarn$1[warnKey] = true;
    var tagDisplayName = childTag;
    var whitespaceInfo = '';

    if (childTag === '#text') {
      if (/\S/.test(childText)) {
        tagDisplayName = 'Text nodes';
      } else {
        tagDisplayName = 'Whitespace text nodes';
        whitespaceInfo = " Make sure you don't have any extra whitespace between tags on " + 'each line of your source code.';
      }
    } else {
      tagDisplayName = '<' + childTag + '>';
    }

    if (invalidParent) {
      var info = '';

      if (ancestorTag === 'table' && childTag === 'tr') {
        info += ' Add a <tbody>, <thead> or <tfoot> to your code to match the DOM tree generated by ' + 'the browser.';
      }

      error('validateDOMNesting(...): %s cannot appear as a child of <%s>.%s%s', tagDisplayName, ancestorTag, whitespaceInfo, info);
    } else {
      error('validateDOMNesting(...): %s cannot appear as a descendant of ' + '<%s>.', tagDisplayName, ancestorTag);
    }
  };
}

var SUPPRESS_HYDRATION_WARNING$1;

{
  SUPPRESS_HYDRATION_WARNING$1 = 'suppressHydrationWarning';
}

var SUSPENSE_START_DATA = '$';
var SUSPENSE_END_DATA = '/$';
var SUSPENSE_PENDING_START_DATA = '$?';
var SUSPENSE_FALLBACK_START_DATA = '$!';
var STYLE$1 = 'style';
var eventsEnabled = null;
var selectionInformation = null;

function shouldAutoFocusHostComponent(type, props) {
  switch (type) {
    case 'button':
    case 'input':
    case 'select':
    case 'textarea':
      return !!props.autoFocus;
  }

  return false;
}
function getRootHostContext(rootContainerInstance) {
  var type;
  var namespace;
  var nodeType = rootContainerInstance.nodeType;

  switch (nodeType) {
    case DOCUMENT_NODE:
    case DOCUMENT_FRAGMENT_NODE:
      {
        type = nodeType === DOCUMENT_NODE ? '#document' : '#fragment';
        var root = rootContainerInstance.documentElement;
        namespace = root ? root.namespaceURI : getChildNamespace(null, '');
        break;
      }

    default:
      {
        var container = nodeType === COMMENT_NODE ? rootContainerInstance.parentNode : rootContainerInstance;
        var ownNamespace = container.namespaceURI || null;
        type = container.tagName;
        namespace = getChildNamespace(ownNamespace, type);
        break;
      }
  }

  {
    var validatedTag = type.toLowerCase();
    var ancestorInfo = updatedAncestorInfo(null, validatedTag);
    return {
      namespace: namespace,
      ancestorInfo: ancestorInfo
    };
  }
}
function getChildHostContext(parentHostContext, type, rootContainerInstance) {
  {
    var parentHostContextDev = parentHostContext;
    var namespace = getChildNamespace(parentHostContextDev.namespace, type);
    var ancestorInfo = updatedAncestorInfo(parentHostContextDev.ancestorInfo, type);
    return {
      namespace: namespace,
      ancestorInfo: ancestorInfo
    };
  }
}
function getPublicInstance(instance) {
  return instance;
}
function prepareForCommit(containerInfo) {
  eventsEnabled = isEnabled();
  selectionInformation = getSelectionInformation();
  var activeInstance = null;

  setEnabled(false);
  return activeInstance;
}
function resetAfterCommit(containerInfo) {
  restoreSelection(selectionInformation);
  setEnabled(eventsEnabled);
  eventsEnabled = null;
  selectionInformation = null;
}
function createInstance(type, props, rootContainerInstance, hostContext, internalInstanceHandle) {
  var parentNamespace;

  {
    // TODO: take namespace into account when validating.
    var hostContextDev = hostContext;
    validateDOMNesting(type, null, hostContextDev.ancestorInfo);

    if (typeof props.children === 'string' || typeof props.children === 'number') {
      var string = '' + props.children;
      var ownAncestorInfo = updatedAncestorInfo(hostContextDev.ancestorInfo, type);
      validateDOMNesting(null, string, ownAncestorInfo);
    }

    parentNamespace = hostContextDev.namespace;
  }

  var domElement = createElement(type, props, rootContainerInstance, parentNamespace);
  precacheFiberNode(internalInstanceHandle, domElement);
  updateFiberProps(domElement, props);
  return domElement;
}
function appendInitialChild(parentInstance, child) {
  parentInstance.appendChild(child);
}
function finalizeInitialChildren(domElement, type, props, rootContainerInstance, hostContext) {
  setInitialProperties(domElement, type, props, rootContainerInstance);
  return shouldAutoFocusHostComponent(type, props);
}
function prepareUpdate(domElement, type, oldProps, newProps, rootContainerInstance, hostContext) {
  {
    var hostContextDev = hostContext;

    if (typeof newProps.children !== typeof oldProps.children && (typeof newProps.children === 'string' || typeof newProps.children === 'number')) {
      var string = '' + newProps.children;
      var ownAncestorInfo = updatedAncestorInfo(hostContextDev.ancestorInfo, type);
      validateDOMNesting(null, string, ownAncestorInfo);
    }
  }

  return diffProperties(domElement, type, oldProps, newProps);
}
function shouldSetTextContent(type, props) {
  return type === 'textarea' || type === 'option' || type === 'noscript' || typeof props.children === 'string' || typeof props.children === 'number' || typeof props.dangerouslySetInnerHTML === 'object' && props.dangerouslySetInnerHTML !== null && props.dangerouslySetInnerHTML.__html != null;
}
function createTextInstance(text, rootContainerInstance, hostContext, internalInstanceHandle) {
  {
    var hostContextDev = hostContext;
    validateDOMNesting(null, text, hostContextDev.ancestorInfo);
  }

  var textNode = createTextNode(text, rootContainerInstance);
  precacheFiberNode(internalInstanceHandle, textNode);
  return textNode;
}
// if a component just imports ReactDOM (e.g. for findDOMNode).
// Some environments might not have setTimeout or clearTimeout.

var scheduleTimeout = typeof setTimeout === 'function' ? setTimeout : undefined;
var cancelTimeout = typeof clearTimeout === 'function' ? clearTimeout : undefined;
var noTimeout = -1; // -------------------
function commitMount(domElement, type, newProps, internalInstanceHandle) {
  // Despite the naming that might imply otherwise, this method only
  // fires if there is an `Update` effect scheduled during mounting.
  // This happens if `finalizeInitialChildren` returns `true` (which it
  // does to implement the `autoFocus` attribute on the client). But
  // there are also other cases when this might happen (such as patching
  // up text content during hydration mismatch). So we'll check this again.
  if (shouldAutoFocusHostComponent(type, newProps)) {
    domElement.focus();
  }
}
function commitUpdate(domElement, updatePayload, type, oldProps, newProps, internalInstanceHandle) {
  // Update the props handle so that we know which props are the ones with
  // with current event handlers.
  updateFiberProps(domElement, newProps); // Apply the diff to the DOM node.

  updateProperties(domElement, updatePayload, type, oldProps, newProps);
}
function resetTextContent(domElement) {
  setTextContent(domElement, '');
}
function commitTextUpdate(textInstance, oldText, newText) {
  textInstance.nodeValue = newText;
}
function appendChild(parentInstance, child) {
  parentInstance.appendChild(child);
}
function appendChildToContainer(container, child) {
  var parentNode;

  if (container.nodeType === COMMENT_NODE) {
    parentNode = container.parentNode;
    parentNode.insertBefore(child, container);
  } else {
    parentNode = container;
    parentNode.appendChild(child);
  } // This container might be used for a portal.
  // If something inside a portal is clicked, that click should bubble
  // through the React tree. However, on Mobile Safari the click would
  // never bubble through the *DOM* tree unless an ancestor with onclick
  // event exists. So we wouldn't see it and dispatch it.
  // This is why we ensure that non React root containers have inline onclick
  // defined.
  // https://github.com/facebook/react/issues/11918


  var reactRootContainer = container._reactRootContainer;

  if ((reactRootContainer === null || reactRootContainer === undefined) && parentNode.onclick === null) {
    // TODO: This cast may not be sound for SVG, MathML or custom elements.
    trapClickOnNonInteractiveElement(parentNode);
  }
}
function insertBefore(parentInstance, child, beforeChild) {
  parentInstance.insertBefore(child, beforeChild);
}
function insertInContainerBefore(container, child, beforeChild) {
  if (container.nodeType === COMMENT_NODE) {
    container.parentNode.insertBefore(child, beforeChild);
  } else {
    container.insertBefore(child, beforeChild);
  }
}

function removeChild(parentInstance, child) {
  parentInstance.removeChild(child);
}
function removeChildFromContainer(container, child) {
  if (container.nodeType === COMMENT_NODE) {
    container.parentNode.removeChild(child);
  } else {
    container.removeChild(child);
  }
}
function hideInstance(instance) {
  // TODO: Does this work for all element types? What about MathML? Should we
  // pass host context to this method?
  instance = instance;
  var style = instance.style;

  if (typeof style.setProperty === 'function') {
    style.setProperty('display', 'none', 'important');
  } else {
    style.display = 'none';
  }
}
function hideTextInstance(textInstance) {
  textInstance.nodeValue = '';
}
function unhideInstance(instance, props) {
  instance = instance;
  var styleProp = props[STYLE$1];
  var display = styleProp !== undefined && styleProp !== null && styleProp.hasOwnProperty('display') ? styleProp.display : null;
  instance.style.display = dangerousStyleValue('display', display);
}
function unhideTextInstance(textInstance, text) {
  textInstance.nodeValue = text;
}
function clearContainer(container) {
  if (container.nodeType === ELEMENT_NODE) {
    container.textContent = '';
  } else if (container.nodeType === DOCUMENT_NODE) {
    var body = container.body;

    if (body != null) {
      body.textContent = '';
    }
  }
} // -------------------
function canHydrateInstance(instance, type, props) {
  if (instance.nodeType !== ELEMENT_NODE || type.toLowerCase() !== instance.nodeName.toLowerCase()) {
    return null;
  } // This has now been refined to an element node.


  return instance;
}
function canHydrateTextInstance(instance, text) {
  if (text === '' || instance.nodeType !== TEXT_NODE) {
    // Empty strings are not parsed by HTML so there won't be a correct match here.
    return null;
  } // This has now been refined to a text node.


  return instance;
}
function isSuspenseInstancePending(instance) {
  return instance.data === SUSPENSE_PENDING_START_DATA;
}
function isSuspenseInstanceFallback(instance) {
  return instance.data === SUSPENSE_FALLBACK_START_DATA;
}

function getNextHydratable(node) {
  // Skip non-hydratable nodes.
  for (; node != null; node = node.nextSibling) {
    var nodeType = node.nodeType;

    if (nodeType === ELEMENT_NODE || nodeType === TEXT_NODE) {
      break;
    }
  }

  return node;
}

function getNextHydratableSibling(instance) {
  return getNextHydratable(instance.nextSibling);
}
function getFirstHydratableChild(parentInstance) {
  return getNextHydratable(parentInstance.firstChild);
}
function hydrateInstance(instance, type, props, rootContainerInstance, hostContext, internalInstanceHandle) {
  precacheFiberNode(internalInstanceHandle, instance); // TODO: Possibly defer this until the commit phase where all the events
  // get attached.

  updateFiberProps(instance, props);
  var parentNamespace;

  {
    var hostContextDev = hostContext;
    parentNamespace = hostContextDev.namespace;
  }

  return diffHydratedProperties(instance, type, props, parentNamespace);
}
function hydrateTextInstance(textInstance, text, internalInstanceHandle) {
  precacheFiberNode(internalInstanceHandle, textInstance);
  return diffHydratedText(textInstance, text);
}
function getNextHydratableInstanceAfterSuspenseInstance(suspenseInstance) {
  var node = suspenseInstance.nextSibling; // Skip past all nodes within this suspense boundary.
  // There might be nested nodes so we need to keep track of how
  // deep we are and only break out when we're back on top.

  var depth = 0;

  while (node) {
    if (node.nodeType === COMMENT_NODE) {
      var data = node.data;

      if (data === SUSPENSE_END_DATA) {
        if (depth === 0) {
          return getNextHydratableSibling(node);
        } else {
          depth--;
        }
      } else if (data === SUSPENSE_START_DATA || data === SUSPENSE_FALLBACK_START_DATA || data === SUSPENSE_PENDING_START_DATA) {
        depth++;
      }
    }

    node = node.nextSibling;
  } // TODO: Warn, we didn't find the end comment boundary.


  return null;
} // Returns the SuspenseInstance if this node is a direct child of a
// SuspenseInstance. I.e. if its previous sibling is a Comment with
// SUSPENSE_x_START_DATA. Otherwise, null.

function getParentSuspenseInstance(targetInstance) {
  var node = targetInstance.previousSibling; // Skip past all nodes within this suspense boundary.
  // There might be nested nodes so we need to keep track of how
  // deep we are and only break out when we're back on top.

  var depth = 0;

  while (node) {
    if (node.nodeType === COMMENT_NODE) {
      var data = node.data;

      if (data === SUSPENSE_START_DATA || data === SUSPENSE_FALLBACK_START_DATA || data === SUSPENSE_PENDING_START_DATA) {
        if (depth === 0) {
          return node;
        } else {
          depth--;
        }
      } else if (data === SUSPENSE_END_DATA) {
        depth++;
      }
    }

    node = node.previousSibling;
  }

  return null;
}
function commitHydratedContainer(container) {
  // Retry if any event replaying was blocked on this.
  retryIfBlockedOn(container);
}
function commitHydratedSuspenseInstance(suspenseInstance) {
  // Retry if any event replaying was blocked on this.
  retryIfBlockedOn(suspenseInstance);
}
function didNotMatchHydratedContainerTextInstance(parentContainer, textInstance, text) {
  {
    warnForUnmatchedText(textInstance, text);
  }
}
function didNotMatchHydratedTextInstance(parentType, parentProps, parentInstance, textInstance, text) {
  if ( parentProps[SUPPRESS_HYDRATION_WARNING$1] !== true) {
    warnForUnmatchedText(textInstance, text);
  }
}
function didNotHydrateContainerInstance(parentContainer, instance) {
  {
    if (instance.nodeType === ELEMENT_NODE) {
      warnForDeletedHydratableElement(parentContainer, instance);
    } else if (instance.nodeType === COMMENT_NODE) ; else {
      warnForDeletedHydratableText(parentContainer, instance);
    }
  }
}
function didNotHydrateInstance(parentType, parentProps, parentInstance, instance) {
  if ( parentProps[SUPPRESS_HYDRATION_WARNING$1] !== true) {
    if (instance.nodeType === ELEMENT_NODE) {
      warnForDeletedHydratableElement(parentInstance, instance);
    } else if (instance.nodeType === COMMENT_NODE) ; else {
      warnForDeletedHydratableText(parentInstance, instance);
    }
  }
}
function didNotFindHydratableContainerInstance(parentContainer, type, props) {
  {
    warnForInsertedHydratedElement(parentContainer, type);
  }
}
function didNotFindHydratableContainerTextInstance(parentContainer, text) {
  {
    warnForInsertedHydratedText(parentContainer, text);
  }
}
function didNotFindHydratableInstance(parentType, parentProps, parentInstance, type, props) {
  if ( parentProps[SUPPRESS_HYDRATION_WARNING$1] !== true) {
    warnForInsertedHydratedElement(parentInstance, type);
  }
}
function didNotFindHydratableTextInstance(parentType, parentProps, parentInstance, text) {
  if ( parentProps[SUPPRESS_HYDRATION_WARNING$1] !== true) {
    warnForInsertedHydratedText(parentInstance, text);
  }
}
function didNotFindHydratableSuspenseInstance(parentType, parentProps, parentInstance) {
  if ( parentProps[SUPPRESS_HYDRATION_WARNING$1] !== true) ;
}
var clientId = 0;
function makeClientIdInDEV(warnOnAccessInDEV) {
  var id = 'r:' + (clientId++).toString(36);
  return {
    toString: function () {
      warnOnAccessInDEV();
      return id;
    },
    valueOf: function () {
      warnOnAccessInDEV();
      return id;
    }
  };
}
function isOpaqueHydratingObject(value) {
  return value !== null && typeof value === 'object' && value.$$typeof === REACT_OPAQUE_ID_TYPE;
}
function makeOpaqueHydratingObject(attemptToReadValue) {
  return {
    $$typeof: REACT_OPAQUE_ID_TYPE,
    toString: attemptToReadValue,
    valueOf: attemptToReadValue
  };
}
function preparePortalMount(portalInstance) {
  {
    listenToAllSupportedEvents(portalInstance);
  }
}

var randomKey = Math.random().toString(36).slice(2);
var internalInstanceKey = '__reactFiber$' + randomKey;
var internalPropsKey = '__reactProps$' + randomKey;
var internalContainerInstanceKey = '__reactContainer$' + randomKey;
var internalEventHandlersKey = '__reactEvents$' + randomKey;
function precacheFiberNode(hostInst, node) {
  node[internalInstanceKey] = hostInst;
}
function markContainerAsRoot(hostRoot, node) {
  node[internalContainerInstanceKey] = hostRoot;
}
function unmarkContainerAsRoot(node) {
  node[internalContainerInstanceKey] = null;
}
function isContainerMarkedAsRoot(node) {
  return !!node[internalContainerInstanceKey];
} // Given a DOM node, return the closest HostComponent or HostText fiber ancestor.
// If the target node is part of a hydrated or not yet rendered subtree, then
// this may also return a SuspenseComponent or HostRoot to indicate that.
// Conceptually the HostRoot fiber is a child of the Container node. So if you
// pass the Container node as the targetNode, you will not actually get the
// HostRoot back. To get to the HostRoot, you need to pass a child of it.
// The same thing applies to Suspense boundaries.

function getClosestInstanceFromNode(targetNode) {
  var targetInst = targetNode[internalInstanceKey];

  if (targetInst) {
    // Don't return HostRoot or SuspenseComponent here.
    return targetInst;
  } // If the direct event target isn't a React owned DOM node, we need to look
  // to see if one of its parents is a React owned DOM node.


  var parentNode = targetNode.parentNode;

  while (parentNode) {
    // We'll check if this is a container root that could include
    // React nodes in the future. We need to check this first because
    // if we're a child of a dehydrated container, we need to first
    // find that inner container before moving on to finding the parent
    // instance. Note that we don't check this field on  the targetNode
    // itself because the fibers are conceptually between the container
    // node and the first child. It isn't surrounding the container node.
    // If it's not a container, we check if it's an instance.
    targetInst = parentNode[internalContainerInstanceKey] || parentNode[internalInstanceKey];

    if (targetInst) {
      // Since this wasn't the direct target of the event, we might have
      // stepped past dehydrated DOM nodes to get here. However they could
      // also have been non-React nodes. We need to answer which one.
      // If we the instance doesn't have any children, then there can't be
      // a nested suspense boundary within it. So we can use this as a fast
      // bailout. Most of the time, when people add non-React children to
      // the tree, it is using a ref to a child-less DOM node.
      // Normally we'd only need to check one of the fibers because if it
      // has ever gone from having children to deleting them or vice versa
      // it would have deleted the dehydrated boundary nested inside already.
      // However, since the HostRoot starts out with an alternate it might
      // have one on the alternate so we need to check in case this was a
      // root.
      var alternate = targetInst.alternate;

      if (targetInst.child !== null || alternate !== null && alternate.child !== null) {
        // Next we need to figure out if the node that skipped past is
        // nested within a dehydrated boundary and if so, which one.
        var suspenseInstance = getParentSuspenseInstance(targetNode);

        while (suspenseInstance !== null) {
          // We found a suspense instance. That means that we haven't
          // hydrated it yet. Even though we leave the comments in the
          // DOM after hydrating, and there are boundaries in the DOM
          // that could already be hydrated, we wouldn't have found them
          // through this pass since if the target is hydrated it would
          // have had an internalInstanceKey on it.
          // Let's get the fiber associated with the SuspenseComponent
          // as the deepest instance.
          var targetSuspenseInst = suspenseInstance[internalInstanceKey];

          if (targetSuspenseInst) {
            return targetSuspenseInst;
          } // If we don't find a Fiber on the comment, it might be because
          // we haven't gotten to hydrate it yet. There might still be a
          // parent boundary that hasn't above this one so we need to find
          // the outer most that is known.


          suspenseInstance = getParentSuspenseInstance(suspenseInstance); // If we don't find one, then that should mean that the parent
          // host component also hasn't hydrated yet. We can return it
          // below since it will bail out on the isMounted check later.
        }
      }

      return targetInst;
    }

    targetNode = parentNode;
    parentNode = targetNode.parentNode;
  }

  return null;
}
/**
 * Given a DOM node, return the ReactDOMComponent or ReactDOMTextComponent
 * instance, or null if the node was not rendered by this React.
 */

function getInstanceFromNode(node) {
  var inst = node[internalInstanceKey] || node[internalContainerInstanceKey];

  if (inst) {
    if (inst.tag === HostComponent || inst.tag === HostText || inst.tag === SuspenseComponent || inst.tag === HostRoot) {
      return inst;
    } else {
      return null;
    }
  }

  return null;
}
/**
 * Given a ReactDOMComponent or ReactDOMTextComponent, return the corresponding
 * DOM node.
 */

function getNodeFromInstance(inst) {
  if (inst.tag === HostComponent || inst.tag === HostText) {
    // In Fiber this, is just the state node right now. We assume it will be
    // a host component or host text.
    return inst.stateNode;
  } // Without this first invariant, passing a non-DOM-component triggers the next
  // invariant for a missing parent, which is super confusing.


  {
    {
      throw Error( "getNodeFromInstance: Invalid argument." );
    }
  }
}
function getFiberCurrentPropsFromNode(node) {
  return node[internalPropsKey] || null;
}
function updateFiberProps(node, props) {
  node[internalPropsKey] = props;
}
function getEventListenerSet(node) {
  var elementListenerSet = node[internalEventHandlersKey];

  if (elementListenerSet === undefined) {
    elementListenerSet = node[internalEventHandlersKey] = new Set();
  }

  return elementListenerSet;
}

var loggedTypeFailures = {};
var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;

function setCurrentlyValidatingElement(element) {
  {
    if (element) {
      var owner = element._owner;
      var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
      ReactDebugCurrentFrame$1.setExtraStackFrame(stack);
    } else {
      ReactDebugCurrentFrame$1.setExtraStackFrame(null);
    }
  }
}

function checkPropTypes(typeSpecs, values, location, componentName, element) {
  {
    // $FlowFixMe This is okay but Flow doesn't know it.
    var has = Function.call.bind(Object.prototype.hasOwnProperty);

    for (var typeSpecName in typeSpecs) {
      if (has(typeSpecs, typeSpecName)) {
        var error$1 = void 0; // Prop type validation may throw. In case they do, we don't want to
        // fail the render phase where it didn't fail before. So we log it.
        // After these have been cleaned up, we'll let them throw.

        try {
          // This is intentionally an invariant that gets caught. It's the same
          // behavior as without this statement except with a better message.
          if (typeof typeSpecs[typeSpecName] !== 'function') {
            var err = Error((componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' + 'it must be a function, usually from the `prop-types` package, but received `' + typeof typeSpecs[typeSpecName] + '`.' + 'This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.');
            err.name = 'Invariant Violation';
            throw err;
          }

          error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED');
        } catch (ex) {
          error$1 = ex;
        }

        if (error$1 && !(error$1 instanceof Error)) {
          setCurrentlyValidatingElement(element);

          error('%s: type specification of %s' + ' `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', location, typeSpecName, typeof error$1);

          setCurrentlyValidatingElement(null);
        }

        if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {
          // Only monitor this failure once because there tends to be a lot of the
          // same error.
          loggedTypeFailures[error$1.message] = true;
          setCurrentlyValidatingElement(element);

          error('Failed %s type: %s', location, error$1.message);

          setCurrentlyValidatingElement(null);
        }
      }
    }
  }
}

var valueStack = [];
var fiberStack;

{
  fiberStack = [];
}

var index = -1;

function createCursor(defaultValue) {
  return {
    current: defaultValue
  };
}

function pop(cursor, fiber) {
  if (index < 0) {
    {
      error('Unexpected pop.');
    }

    return;
  }

  {
    if (fiber !== fiberStack[index]) {
      error('Unexpected Fiber popped.');
    }
  }

  cursor.current = valueStack[index];
  valueStack[index] = null;

  {
    fiberStack[index] = null;
  }

  index--;
}

function push(cursor, value, fiber) {
  index++;
  valueStack[index] = cursor.current;

  {
    fiberStack[index] = fiber;
  }

  cursor.current = value;
}

var warnedAboutMissingGetChildContext;

{
  warnedAboutMissingGetChildContext = {};
}

var emptyContextObject = {};

{
  Object.freeze(emptyContextObject);
} // A cursor to the current merged context object on the stack.


var contextStackCursor = createCursor(emptyContextObject); // A cursor to a boolean indicating whether the context has changed.

var didPerformWorkStackCursor = createCursor(false); // Keep track of the previous context object that was on the stack.
// We use this to get access to the parent context after we have already
// pushed the next context provider, and now need to merge their contexts.

var previousContext = emptyContextObject;

function getUnmaskedContext(workInProgress, Component, didPushOwnContextIfProvider) {
  {
    if (didPushOwnContextIfProvider && isContextProvider(Component)) {
      // If the fiber is a context provider itself, when we read its context
      // we may have already pushed its own child context on the stack. A context
      // provider should not "see" its own child context. Therefore we read the
      // previous (parent) context instead for a context provider.
      return previousContext;
    }

    return contextStackCursor.current;
  }
}

function cacheContext(workInProgress, unmaskedContext, maskedContext) {
  {
    var instance = workInProgress.stateNode;
    instance.__reactInternalMemoizedUnmaskedChildContext = unmaskedContext;
    instance.__reactInternalMemoizedMaskedChildContext = maskedContext;
  }
}

function getMaskedContext(workInProgress, unmaskedContext) {
  {
    var type = workInProgress.type;
    var contextTypes = type.contextTypes;

    if (!contextTypes) {
      return emptyContextObject;
    } // Avoid recreating masked context unless unmasked context has changed.
    // Failing to do this will result in unnecessary calls to componentWillReceiveProps.
    // This may trigger infinite loops if componentWillReceiveProps calls setState.


    var instance = workInProgress.stateNode;

    if (instance && instance.__reactInternalMemoizedUnmaskedChildContext === unmaskedContext) {
      return instance.__reactInternalMemoizedMaskedChildContext;
    }

    var context = {};

    for (var key in contextTypes) {
      context[key] = unmaskedContext[key];
    }

    {
      var name = getComponentName(type) || 'Unknown';
      checkPropTypes(contextTypes, context, 'context', name);
    } // Cache unmasked context so we can avoid recreating masked context unless necessary.
    // Context is created before the class component is instantiated so check for instance.


    if (instance) {
      cacheContext(workInProgress, unmaskedContext, context);
    }

    return context;
  }
}

function hasContextChanged() {
  {
    return didPerformWorkStackCursor.current;
  }
}

function isContextProvider(type) {
  {
    var childContextTypes = type.childContextTypes;
    return childContextTypes !== null && childContextTypes !== undefined;
  }
}

function popContext(fiber) {
  {
    pop(didPerformWorkStackCursor, fiber);
    pop(contextStackCursor, fiber);
  }
}

function popTopLevelContextObject(fiber) {
  {
    pop(didPerformWorkStackCursor, fiber);
    pop(contextStackCursor, fiber);
  }
}

function pushTopLevelContextObject(fiber, context, didChange) {
  {
    if (!(contextStackCursor.current === emptyContextObject)) {
      {
        throw Error( "Unexpected context found on stack. This error is likely caused by a bug in React. Please file an issue." );
      }
    }

    push(contextStackCursor, context, fiber);
    push(didPerformWorkStackCursor, didChange, fiber);
  }
}

function processChildContext(fiber, type, parentContext) {
  {
    var instance = fiber.stateNode;
    var childContextTypes = type.childContextTypes; // TODO (bvaughn) Replace this behavior with an invariant() in the future.
    // It has only been added in Fiber to match the (unintentional) behavior in Stack.

    if (typeof instance.getChildContext !== 'function') {
      {
        var componentName = getComponentName(type) || 'Unknown';

        if (!warnedAboutMissingGetChildContext[componentName]) {
          warnedAboutMissingGetChildContext[componentName] = true;

          error('%s.childContextTypes is specified but there is no getChildContext() method ' + 'on the instance. You can either define getChildContext() on %s or remove ' + 'childContextTypes from it.', componentName, componentName);
        }
      }

      return parentContext;
    }

    var childContext = instance.getChildContext();

    for (var contextKey in childContext) {
      if (!(contextKey in childContextTypes)) {
        {
          throw Error( (getComponentName(type) || 'Unknown') + ".getChildContext(): key \"" + contextKey + "\" is not defined in childContextTypes." );
        }
      }
    }

    {
      var name = getComponentName(type) || 'Unknown';
      checkPropTypes(childContextTypes, childContext, 'child context', name);
    }

    return _assign({}, parentContext, childContext);
  }
}

function pushContextProvider(workInProgress) {
  {
    var instance = workInProgress.stateNode; // We push the context as early as possible to ensure stack integrity.
    // If the instance does not exist yet, we will push null at first,
    // and replace it on the stack later when invalidating the context.

    var memoizedMergedChildContext = instance && instance.__reactInternalMemoizedMergedChildContext || emptyContextObject; // Remember the parent context so we can merge with it later.
    // Inherit the parent's did-perform-work value to avoid inadvertently blocking updates.

    previousContext = contextStackCursor.current;
    push(contextStackCursor, memoizedMergedChildContext, workInProgress);
    push(didPerformWorkStackCursor, didPerformWorkStackCursor.current, workInProgress);
    return true;
  }
}

function invalidateContextProvider(workInProgress, type, didChange) {
  {
    var instance = workInProgress.stateNode;

    if (!instance) {
      {
        throw Error( "Expected to have an instance by this point. This error is likely caused by a bug in React. Please file an issue." );
      }
    }

    if (didChange) {
      // Merge parent and own context.
      // Skip this if we're not updating due to sCU.
      // This avoids unnecessarily recomputing memoized values.
      var mergedContext = processChildContext(workInProgress, type, previousContext);
      instance.__reactInternalMemoizedMergedChildContext = mergedContext; // Replace the old (or empty) context with the new one.
      // It is important to unwind the context in the reverse order.

      pop(didPerformWorkStackCursor, workInProgress);
      pop(contextStackCursor, workInProgress); // Now push the new context and mark that it has changed.

      push(contextStackCursor, mergedContext, workInProgress);
      push(didPerformWorkStackCursor, didChange, workInProgress);
    } else {
      pop(didPerformWorkStackCursor, workInProgress);
      push(didPerformWorkStackCursor, didChange, workInProgress);
    }
  }
}

function findCurrentUnmaskedContext(fiber) {
  {
    // Currently this is only used with renderSubtreeIntoContainer; not sure if it
    // makes sense elsewhere
    if (!(isFiberMounted(fiber) && fiber.tag === ClassComponent)) {
      {
        throw Error( "Expected subtree parent to be a mounted class component. This error is likely caused by a bug in React. Please file an issue." );
      }
    }

    var node = fiber;

    do {
      switch (node.tag) {
        case HostRoot:
          return node.stateNode.context;

        case ClassComponent:
          {
            var Component = node.type;

            if (isContextProvider(Component)) {
              return node.stateNode.__reactInternalMemoizedMergedChildContext;
            }

            break;
          }
      }

      node = node.return;
    } while (node !== null);

    {
      {
        throw Error( "Found unexpected detached subtree parent. This error is likely caused by a bug in React. Please file an issue." );
      }
    }
  }
}

var LegacyRoot = 0;
var BlockingRoot = 1;
var ConcurrentRoot = 2;

var rendererID = null;
var injectedHook = null;
var hasLoggedError = false;
var isDevToolsPresent = typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined';
function injectInternals(internals) {
  if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === 'undefined') {
    // No DevTools
    return false;
  }

  var hook = __REACT_DEVTOOLS_GLOBAL_HOOK__;

  if (hook.isDisabled) {
    // This isn't a real property on the hook, but it can be set to opt out
    // of DevTools integration and associated warnings and logs.
    // https://github.com/facebook/react/issues/3877
    return true;
  }

  if (!hook.supportsFiber) {
    {
      error('The installed version of React DevTools is too old and will not work ' + 'with the current version of React. Please update React DevTools. ' + 'https://reactjs.org/link/react-devtools');
    } // DevTools exists, even though it doesn't support Fiber.


    return true;
  }

  try {
    rendererID = hook.inject(internals); // We have successfully injected, so now it is safe to set up hooks.

    injectedHook = hook;
  } catch (err) {
    // Catch all errors because it is unsafe to throw during initialization.
    {
      error('React instrumentation encountered an error: %s.', err);
    }
  } // DevTools exists


  return true;
}
function onScheduleRoot(root, children) {
  {
    if (injectedHook && typeof injectedHook.onScheduleFiberRoot === 'function') {
      try {
        injectedHook.onScheduleFiberRoot(rendererID, root, children);
      } catch (err) {
        if ( !hasLoggedError) {
          hasLoggedError = true;

          error('React instrumentation encountered an error: %s', err);
        }
      }
    }
  }
}
function onCommitRoot(root, priorityLevel) {
  if (injectedHook && typeof injectedHook.onCommitFiberRoot === 'function') {
    try {
      var didError = (root.current.flags & DidCapture) === DidCapture;

      if (enableProfilerTimer) {
        injectedHook.onCommitFiberRoot(rendererID, root, priorityLevel, didError);
      } else {
        injectedHook.onCommitFiberRoot(rendererID, root, undefined, didError);
      }
    } catch (err) {
      {
        if (!hasLoggedError) {
          hasLoggedError = true;

          error('React instrumentation encountered an error: %s', err);
        }
      }
    }
  }
}
function onCommitUnmount(fiber) {
  if (injectedHook && typeof injectedHook.onCommitFiberUnmount === 'function') {
    try {
      injectedHook.onCommitFiberUnmount(rendererID, fiber);
    } catch (err) {
      {
        if (!hasLoggedError) {
          hasLoggedError = true;

          error('React instrumentation encountered an error: %s', err);
        }
      }
    }
  }
}

var Scheduler_runWithPriority = Scheduler.unstable_runWithPriority,
    Scheduler_scheduleCallback = Scheduler.unstable_scheduleCallback,
    Scheduler_cancelCallback = Scheduler.unstable_cancelCallback,
    Scheduler_shouldYield = Scheduler.unstable_shouldYield,
    Scheduler_requestPaint = Scheduler.unstable_requestPaint,
    Scheduler_now$1 = Scheduler.unstable_now,
    Scheduler_getCurrentPriorityLevel = Scheduler.unstable_getCurrentPriorityLevel,
    Scheduler_ImmediatePriority = Scheduler.unstable_ImmediatePriority,
    Scheduler_UserBlockingPriority = Scheduler.unstable_UserBlockingPriority,
    Scheduler_NormalPriority = Scheduler.unstable_NormalPriority,
    Scheduler_LowPriority = Scheduler.unstable_LowPriority,
    Scheduler_IdlePriority = Scheduler.unstable_IdlePriority;

{
  // Provide explicit error message when production+profiling bundle of e.g.
  // react-dom is used with production (non-profiling) bundle of
  // scheduler/tracing
  if (!(tracing.__interactionsRef != null && tracing.__interactionsRef.current != null)) {
    {
      throw Error( "It is not supported to run the profiling version of a renderer (for example, `react-dom/profiling`) without also replacing the `scheduler/tracing` module with `scheduler/tracing-profiling`. Your bundler might have a setting for aliasing both modules. Learn more at https://reactjs.org/link/profiling" );
    }
  }
}

var fakeCallbackNode = {}; // Except for NoPriority, these correspond to Scheduler priorities. We use
// ascending numbers so we can compare them like numbers. They start at 90 to
// avoid clashing with Scheduler's priorities.

var ImmediatePriority$1 = 99;
var UserBlockingPriority$2 = 98;
var NormalPriority$1 = 97;
var LowPriority$1 = 96;
var IdlePriority$1 = 95; // NoPriority is the absence of priority. Also React-only.

var NoPriority$1 = 90;
var shouldYield = Scheduler_shouldYield;
var requestPaint = // Fall back gracefully if we're running an older version of Scheduler.
Scheduler_requestPaint !== undefined ? Scheduler_requestPaint : function () {};
var syncQueue = null;
var immediateQueueCallbackNode = null;
var isFlushingSyncQueue = false;
var initialTimeMs$1 = Scheduler_now$1(); // If the initial timestamp is reasonably small, use Scheduler's `now` directly.
// This will be the case for modern browsers that support `performance.now`. In
// older browsers, Scheduler falls back to `Date.now`, which returns a Unix
// timestamp. In that case, subtract the module initialization time to simulate
// the behavior of performance.now and keep our times small enough to fit
// within 32 bits.
// TODO: Consider lifting this into Scheduler.

var now = initialTimeMs$1 < 10000 ? Scheduler_now$1 : function () {
  return Scheduler_now$1() - initialTimeMs$1;
};
function getCurrentPriorityLevel() {
  switch (Scheduler_getCurrentPriorityLevel()) {
    case Scheduler_ImmediatePriority:
      return ImmediatePriority$1;

    case Scheduler_UserBlockingPriority:
      return UserBlockingPriority$2;

    case Scheduler_NormalPriority:
      return NormalPriority$1;

    case Scheduler_LowPriority:
      return LowPriority$1;

    case Scheduler_IdlePriority:
      return IdlePriority$1;

    default:
      {
        {
          throw Error( "Unknown priority level." );
        }
      }

  }
}

function reactPriorityToSchedulerPriority(reactPriorityLevel) {
  switch (reactPriorityLevel) {
    case ImmediatePriority$1:
      return Scheduler_ImmediatePriority;

    case UserBlockingPriority$2:
      return Scheduler_UserBlockingPriority;

    case NormalPriority$1:
      return Scheduler_NormalPriority;

    case LowPriority$1:
      return Scheduler_LowPriority;

    case IdlePriority$1:
      return Scheduler_IdlePriority;

    default:
      {
        {
          throw Error( "Unknown priority level." );
        }
      }

  }
}

function runWithPriority$1(reactPriorityLevel, fn) {
  var priorityLevel = reactPriorityToSchedulerPriority(reactPriorityLevel);
  return Scheduler_runWithPriority(priorityLevel, fn);
}
function scheduleCallback(reactPriorityLevel, callback, options) {
  var priorityLevel = reactPriorityToSchedulerPriority(reactPriorityLevel);
  return Scheduler_scheduleCallback(priorityLevel, callback, options);
}
function scheduleSyncCallback(callback) {
  // Push this callback into an internal queue. We'll flush these either in
  // the next tick, or earlier if something calls `flushSyncCallbackQueue`.
  if (syncQueue === null) {
    syncQueue = [callback]; // Flush the queue in the next tick, at the earliest.

    immediateQueueCallbackNode = Scheduler_scheduleCallback(Scheduler_ImmediatePriority, flushSyncCallbackQueueImpl);
  } else {
    // Push onto existing queue. Don't need to schedule a callback because
    // we already scheduled one when we created the queue.
    syncQueue.push(callback);
  }

  return fakeCallbackNode;
}
function cancelCallback(callbackNode) {
  if (callbackNode !== fakeCallbackNode) {
    Scheduler_cancelCallback(callbackNode);
  }
}
function flushSyncCallbackQueue() {
  if (immediateQueueCallbackNode !== null) {
    var node = immediateQueueCallbackNode;
    immediateQueueCallbackNode = null;
    Scheduler_cancelCallback(node);
  }

  flushSyncCallbackQueueImpl();
}

function flushSyncCallbackQueueImpl() {
  if (!isFlushingSyncQueue && syncQueue !== null) {
    // Prevent re-entrancy.
    isFlushingSyncQueue = true;
    var i = 0;

    {
      try {
        var _isSync2 = true;
        var _queue = syncQueue;
        runWithPriority$1(ImmediatePriority$1, function () {
          for (; i < _queue.length; i++) {
            var callback = _queue[i];

            do {
              callback = callback(_isSync2);
            } while (callback !== null);
          }
        });
        syncQueue = null;
      } catch (error) {
        // If something throws, leave the remaining callbacks on the queue.
        if (syncQueue !== null) {
          syncQueue = syncQueue.slice(i + 1);
        } // Resume flushing in the next tick


        Scheduler_scheduleCallback(Scheduler_ImmediatePriority, flushSyncCallbackQueue);
        throw error;
      } finally {
        isFlushingSyncQueue = false;
      }
    }
  }
}

// TODO: this is special because it gets imported during build.
var ReactVersion = '17.0.2';

var NoMode = 0;
var StrictMode = 1; // TODO: Remove BlockingMode and ConcurrentMode by reading from the root
// tag instead

var BlockingMode = 2;
var ConcurrentMode = 4;
var ProfileMode = 8;
var DebugTracingMode = 16;

var ReactCurrentBatchConfig = ReactSharedInternals.ReactCurrentBatchConfig;
var NoTransition = 0;
function requestCurrentTransition() {
  return ReactCurrentBatchConfig.transition;
}

var ReactStrictModeWarnings = {
  recordUnsafeLifecycleWarnings: function (fiber, instance) {},
  flushPendingUnsafeLifecycleWarnings: function () {},
  recordLegacyContextWarning: function (fiber, instance) {},
  flushLegacyContextWarning: function () {},
  discardPendingWarnings: function () {}
};

{
  var findStrictRoot = function (fiber) {
    var maybeStrictRoot = null;
    var node = fiber;

    while (node !== null) {
      if (node.mode & StrictMode) {
        maybeStrictRoot = node;
      }

      node = node.return;
    }

    return maybeStrictRoot;
  };

  var setToSortedString = function (set) {
    var array = [];
    set.forEach(function (value) {
      array.push(value);
    });
    return array.sort().join(', ');
  };

  var pendingComponentWillMountWarnings = [];
  var pendingUNSAFE_ComponentWillMountWarnings = [];
  var pendingComponentWillReceivePropsWarnings = [];
  var pendingUNSAFE_ComponentWillReceivePropsWarnings = [];
  var pendingComponentWillUpdateWarnings = [];
  var pendingUNSAFE_ComponentWillUpdateWarnings = []; // Tracks components we have already warned about.

  var didWarnAboutUnsafeLifecycles = new Set();

  ReactStrictModeWarnings.recordUnsafeLifecycleWarnings = function (fiber, instance) {
    // Dedup strategy: Warn once per component.
    if (didWarnAboutUnsafeLifecycles.has(fiber.type)) {
      return;
    }

    if (typeof instance.componentWillMount === 'function' && // Don't warn about react-lifecycles-compat polyfilled components.
    instance.componentWillMount.__suppressDeprecationWarning !== true) {
      pendingComponentWillMountWarnings.push(fiber);
    }

    if (fiber.mode & StrictMode && typeof instance.UNSAFE_componentWillMount === 'function') {
      pendingUNSAFE_ComponentWillMountWarnings.push(fiber);
    }

    if (typeof instance.componentWillReceiveProps === 'function' && instance.componentWillReceiveProps.__suppressDeprecationWarning !== true) {
      pendingComponentWillReceivePropsWarnings.push(fiber);
    }

    if (fiber.mode & StrictMode && typeof instance.UNSAFE_componentWillReceiveProps === 'function') {
      pendingUNSAFE_ComponentWillReceivePropsWarnings.push(fiber);
    }

    if (typeof instance.componentWillUpdate === 'function' && instance.componentWillUpdate.__suppressDeprecationWarning !== true) {
      pendingComponentWillUpdateWarnings.push(fiber);
    }

    if (fiber.mode & StrictMode && typeof instance.UNSAFE_componentWillUpdate === 'function') {
      pendingUNSAFE_ComponentWillUpdateWarnings.push(fiber);
    }
  };

  ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings = function () {
    // We do an initial pass to gather component names
    var componentWillMountUniqueNames = new Set();

    if (pendingComponentWillMountWarnings.length > 0) {
      pendingComponentWillMountWarnings.forEach(function (fiber) {
        componentWillMountUniqueNames.add(getComponentName(fiber.type) || 'Component');
        didWarnAboutUnsafeLifecycles.add(fiber.type);
      });
      pendingComponentWillMountWarnings = [];
    }

    var UNSAFE_componentWillMountUniqueNames = new Set();

    if (pendingUNSAFE_ComponentWillMountWarnings.length > 0) {
      pendingUNSAFE_ComponentWillMountWarnings.forEach(function (fiber) {
        UNSAFE_componentWillMountUniqueNames.add(getComponentName(fiber.type) || 'Component');
        didWarnAboutUnsafeLifecycles.add(fiber.type);
      });
      pendingUNSAFE_ComponentWillMountWarnings = [];
    }

    var componentWillReceivePropsUniqueNames = new Set();

    if (pendingComponentWillReceivePropsWarnings.length > 0) {
      pendingComponentWillReceivePropsWarnings.forEach(function (fiber) {
        componentWillReceivePropsUniqueNames.add(getComponentName(fiber.type) || 'Component');
        didWarnAboutUnsafeLifecycles.add(fiber.type);
      });
      pendingComponentWillReceivePropsWarnings = [];
    }

    var UNSAFE_componentWillReceivePropsUniqueNames = new Set();

    if (pendingUNSAFE_ComponentWillReceivePropsWarnings.length > 0) {
      pendingUNSAFE_ComponentWillReceivePropsWarnings.forEach(function (fiber) {
        UNSAFE_componentWillReceivePropsUniqueNames.add(getComponentName(fiber.type) || 'Component');
        didWarnAboutUnsafeLifecycles.add(fiber.type);
      });
      pendingUNSAFE_ComponentWillReceivePropsWarnings = [];
    }

    var componentWillUpdateUniqueNames = new Set();

    if (pendingComponentWillUpdateWarnings.length > 0) {
      pendingComponentWillUpdateWarnings.forEach(function (fiber) {
        componentWillUpdateUniqueNames.add(getComponentName(fiber.type) || 'Component');
        didWarnAboutUnsafeLifecycles.add(fiber.type);
      });
      pendingComponentWillUpdateWarnings = [];
    }

    var UNSAFE_componentWillUpdateUniqueNames = new Set();

    if (pendingUNSAFE_ComponentWillUpdateWarnings.length > 0) {
      pendingUNSAFE_ComponentWillUpdateWarnings.forEach(function (fiber) {
        UNSAFE_componentWillUpdateUniqueNames.add(getComponentName(fiber.type) || 'Component');
        didWarnAboutUnsafeLifecycles.add(fiber.type);
      });
      pendingUNSAFE_ComponentWillUpdateWarnings = [];
    } // Finally, we flush all the warnings
    // UNSAFE_ ones before the deprecated ones, since they'll be 'louder'


    if (UNSAFE_componentWillMountUniqueNames.size > 0) {
      var sortedNames = setToSortedString(UNSAFE_componentWillMountUniqueNames);

      error('Using UNSAFE_componentWillMount in strict mode is not recommended and may indicate bugs in your code. ' + 'See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n' + '* Move code with side effects to componentDidMount, and set initial state in the constructor.\n' + '\nPlease update the following components: %s', sortedNames);
    }

    if (UNSAFE_componentWillReceivePropsUniqueNames.size > 0) {
      var _sortedNames = setToSortedString(UNSAFE_componentWillReceivePropsUniqueNames);

      error('Using UNSAFE_componentWillReceiveProps in strict mode is not recommended ' + 'and may indicate bugs in your code. ' + 'See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n' + '* Move data fetching code or side effects to componentDidUpdate.\n' + "* If you're updating state whenever props change, " + 'refactor your code to use memoization techniques or move it to ' + 'static getDerivedStateFromProps. Learn more at: https://reactjs.org/link/derived-state\n' + '\nPlease update the following components: %s', _sortedNames);
    }

    if (UNSAFE_componentWillUpdateUniqueNames.size > 0) {
      var _sortedNames2 = setToSortedString(UNSAFE_componentWillUpdateUniqueNames);

      error('Using UNSAFE_componentWillUpdate in strict mode is not recommended ' + 'and may indicate bugs in your code. ' + 'See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n' + '* Move data fetching code or side effects to componentDidUpdate.\n' + '\nPlease update the following components: %s', _sortedNames2);
    }

    if (componentWillMountUniqueNames.size > 0) {
      var _sortedNames3 = setToSortedString(componentWillMountUniqueNames);

      warn('componentWillMount has been renamed, and is not recommended for use. ' + 'See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n' + '* Move code with side effects to componentDidMount, and set initial state in the constructor.\n' + '* Rename componentWillMount to UNSAFE_componentWillMount to suppress ' + 'this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. ' + 'To rename all deprecated lifecycles to their new names, you can run ' + '`npx react-codemod rename-unsafe-lifecycles` in your project source folder.\n' + '\nPlease update the following components: %s', _sortedNames3);
    }

    if (componentWillReceivePropsUniqueNames.size > 0) {
      var _sortedNames4 = setToSortedString(componentWillReceivePropsUniqueNames);

      warn('componentWillReceiveProps has been renamed, and is not recommended for use. ' + 'See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n' + '* Move data fetching code or side effects to componentDidUpdate.\n' + "* If you're updating state whenever props change, refactor your " + 'code to use memoization techniques or move it to ' + 'static getDerivedStateFromProps. Learn more at: https://reactjs.org/link/derived-state\n' + '* Rename componentWillReceiveProps to UNSAFE_componentWillReceiveProps to suppress ' + 'this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. ' + 'To rename all deprecated lifecycles to their new names, you can run ' + '`npx react-codemod rename-unsafe-lifecycles` in your project source folder.\n' + '\nPlease update the following components: %s', _sortedNames4);
    }

    if (componentWillUpdateUniqueNames.size > 0) {
      var _sortedNames5 = setToSortedString(componentWillUpdateUniqueNames);

      warn('componentWillUpdate has been renamed, and is not recommended for use. ' + 'See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n' + '* Move data fetching code or side effects to componentDidUpdate.\n' + '* Rename componentWillUpdate to UNSAFE_componentWillUpdate to suppress ' + 'this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. ' + 'To rename all deprecated lifecycles to their new names, you can run ' + '`npx react-codemod rename-unsafe-lifecycles` in your project source folder.\n' + '\nPlease update the following components: %s', _sortedNames5);
    }
  };

  var pendingLegacyContextWarning = new Map(); // Tracks components we have already warned about.

  var didWarnAboutLegacyContext = new Set();

  ReactStrictModeWarnings.recordLegacyContextWarning = function (fiber, instance) {
    var strictRoot = findStrictRoot(fiber);

    if (strictRoot === null) {
      error('Expected to find a StrictMode component in a strict mode tree. ' + 'This error is likely caused by a bug in React. Please file an issue.');

      return;
    } // Dedup strategy: Warn once per component.


    if (didWarnAboutLegacyContext.has(fiber.type)) {
      return;
    }

    var warningsForRoot = pendingLegacyContextWarning.get(strictRoot);

    if (fiber.type.contextTypes != null || fiber.type.childContextTypes != null || instance !== null && typeof instance.getChildContext === 'function') {
      if (warningsForRoot === undefined) {
        warningsForRoot = [];
        pendingLegacyContextWarning.set(strictRoot, warningsForRoot);
      }

      warningsForRoot.push(fiber);
    }
  };

  ReactStrictModeWarnings.flushLegacyContextWarning = function () {
    pendingLegacyContextWarning.forEach(function (fiberArray, strictRoot) {
      if (fiberArray.length === 0) {
        return;
      }

      var firstFiber = fiberArray[0];
      var uniqueNames = new Set();
      fiberArray.forEach(function (fiber) {
        uniqueNames.add(getComponentName(fiber.type) || 'Component');
        didWarnAboutLegacyContext.add(fiber.type);
      });
      var sortedNames = setToSortedString(uniqueNames);

      try {
        setCurrentFiber(firstFiber);

        error('Legacy context API has been detected within a strict-mode tree.' + '\n\nThe old API will be supported in all 16.x releases, but applications ' + 'using it should migrate to the new version.' + '\n\nPlease update the following components: %s' + '\n\nLearn more about this warning here: https://reactjs.org/link/legacy-context', sortedNames);
      } finally {
        resetCurrentFiber();
      }
    });
  };

  ReactStrictModeWarnings.discardPendingWarnings = function () {
    pendingComponentWillMountWarnings = [];
    pendingUNSAFE_ComponentWillMountWarnings = [];
    pendingComponentWillReceivePropsWarnings = [];
    pendingUNSAFE_ComponentWillReceivePropsWarnings = [];
    pendingComponentWillUpdateWarnings = [];
    pendingUNSAFE_ComponentWillUpdateWarnings = [];
    pendingLegacyContextWarning = new Map();
  };
}

function resolveDefaultProps(Component, baseProps) {
  if (Component && Component.defaultProps) {
    // Resolve default props. Taken from ReactElement
    var props = _assign({}, baseProps);

    var defaultProps = Component.defaultProps;

    for (var propName in defaultProps) {
      if (props[propName] === undefined) {
        props[propName] = defaultProps[propName];
      }
    }

    return props;
  }

  return baseProps;
}

// Max 31 bit integer. The max integer size in V8 for 32-bit systems.
// Math.pow(2, 30) - 1
// 0b111111111111111111111111111111
var MAX_SIGNED_31_BIT_INT = 1073741823;

var valueCursor = createCursor(null);
var rendererSigil;

{
  // Use this to detect multiple renderers using the same context
  rendererSigil = {};
}

var currentlyRenderingFiber = null;
var lastContextDependency = null;
var lastContextWithAllBitsObserved = null;
var isDisallowedContextReadInDEV = false;
function resetContextDependencies() {
  // This is called right before React yields execution, to ensure `readContext`
  // cannot be called outside the render phase.
  currentlyRenderingFiber = null;
  lastContextDependency = null;
  lastContextWithAllBitsObserved = null;

  {
    isDisallowedContextReadInDEV = false;
  }
}
function enterDisallowedContextReadInDEV() {
  {
    isDisallowedContextReadInDEV = true;
  }
}
function exitDisallowedContextReadInDEV() {
  {
    isDisallowedContextReadInDEV = false;
  }
}
function pushProvider(providerFiber, nextValue) {
  var context = providerFiber.type._context;

  {
    push(valueCursor, context._currentValue, providerFiber);
    context._currentValue = nextValue;

    {
      if (context._currentRenderer !== undefined && context._currentRenderer !== null && context._currentRenderer !== rendererSigil) {
        error('Detected multiple renderers concurrently rendering the ' + 'same context provider. This is currently unsupported.');
      }

      context._currentRenderer = rendererSigil;
    }
  }
}
function popProvider(providerFiber) {
  var currentValue = valueCursor.current;
  pop(valueCursor, providerFiber);
  var context = providerFiber.type._context;

  {
    context._currentValue = currentValue;
  }
}
function calculateChangedBits(context, newValue, oldValue) {
  if (objectIs(oldValue, newValue)) {
    // No change
    return 0;
  } else {
    var changedBits = typeof context._calculateChangedBits === 'function' ? context._calculateChangedBits(oldValue, newValue) : MAX_SIGNED_31_BIT_INT;

    {
      if ((changedBits & MAX_SIGNED_31_BIT_INT) !== changedBits) {
        error('calculateChangedBits: Expected the return value to be a ' + '31-bit integer. Instead received: %s', changedBits);
      }
    }

    return changedBits | 0;
  }
}
function scheduleWorkOnParentPath(parent, renderLanes) {
  // Update the child lanes of all the ancestors, including the alternates.
  var node = parent;

  while (node !== null) {
    var alternate = node.alternate;

    if (!isSubsetOfLanes(node.childLanes, renderLanes)) {
      node.childLanes = mergeLanes(node.childLanes, renderLanes);

      if (alternate !== null) {
        alternate.childLanes = mergeLanes(alternate.childLanes, renderLanes);
      }
    } else if (alternate !== null && !isSubsetOfLanes(alternate.childLanes, renderLanes)) {
      alternate.childLanes = mergeLanes(alternate.childLanes, renderLanes);
    } else {
      // Neither alternate was updated, which means the rest of the
      // ancestor path already has sufficient priority.
      break;
    }

    node = node.return;
  }
}
function propagateContextChange(workInProgress, context, changedBits, renderLanes) {
  var fiber = workInProgress.child;

  if (fiber !== null) {
    // Set the return pointer of the child to the work-in-progress fiber.
    fiber.return = workInProgress;
  }

  while (fiber !== null) {
    var nextFiber = void 0; // Visit this fiber.

    var list = fiber.dependencies;

    if (list !== null) {
      nextFiber = fiber.child;
      var dependency = list.firstContext;

      while (dependency !== null) {
        // Check if the context matches.
        if (dependency.context === context && (dependency.observedBits & changedBits) !== 0) {
          // Match! Schedule an update on this fiber.
          if (fiber.tag === ClassComponent) {
            // Schedule a force update on the work-in-progress.
            var update = createUpdate(NoTimestamp, pickArbitraryLane(renderLanes));
            update.tag = ForceUpdate; // TODO: Because we don't have a work-in-progress, this will add the
            // update to the current fiber, too, which means it will persist even if
            // this render is thrown away. Since it's a race condition, not sure it's
            // worth fixing.

            enqueueUpdate(fiber, update);
          }

          fiber.lanes = mergeLanes(fiber.lanes, renderLanes);
          var alternate = fiber.alternate;

          if (alternate !== null) {
            alternate.lanes = mergeLanes(alternate.lanes, renderLanes);
          }

          scheduleWorkOnParentPath(fiber.return, renderLanes); // Mark the updated lanes on the list, too.

          list.lanes = mergeLanes(list.lanes, renderLanes); // Since we already found a match, we can stop traversing the
          // dependency list.

          break;
        }

        dependency = dependency.next;
      }
    } else if (fiber.tag === ContextProvider) {
      // Don't scan deeper if this is a matching provider
      nextFiber = fiber.type === workInProgress.type ? null : fiber.child;
    } else {
      // Traverse down.
      nextFiber = fiber.child;
    }

    if (nextFiber !== null) {
      // Set the return pointer of the child to the work-in-progress fiber.
      nextFiber.return = fiber;
    } else {
      // No child. Traverse to next sibling.
      nextFiber = fiber;

      while (nextFiber !== null) {
        if (nextFiber === workInProgress) {
          // We're back to the root of this subtree. Exit.
          nextFiber = null;
          break;
        }

        var sibling = nextFiber.sibling;

        if (sibling !== null) {
          // Set the return pointer of the sibling to the work-in-progress fiber.
          sibling.return = nextFiber.return;
          nextFiber = sibling;
          break;
        } // No more siblings. Traverse up.


        nextFiber = nextFiber.return;
      }
    }

    fiber = nextFiber;
  }
}
function prepareToReadContext(workInProgress, renderLanes) {
  currentlyRenderingFiber = workInProgress;
  lastContextDependency = null;
  lastContextWithAllBitsObserved = null;
  var dependencies = workInProgress.dependencies;

  if (dependencies !== null) {
    var firstContext = dependencies.firstContext;

    if (firstContext !== null) {
      if (includesSomeLane(dependencies.lanes, renderLanes)) {
        // Context list has a pending update. Mark that this fiber performed work.
        markWorkInProgressReceivedUpdate();
      } // Reset the work-in-progress list


      dependencies.firstContext = null;
    }
  }
}
function readContext(context, observedBits) {
  {
    // This warning would fire if you read context inside a Hook like useMemo.
    // Unlike the class check below, it's not enforced in production for perf.
    if (isDisallowedContextReadInDEV) {
      error('Context can only be read while React is rendering. ' + 'In classes, you can read it in the render method or getDerivedStateFromProps. ' + 'In function components, you can read it directly in the function body, but not ' + 'inside Hooks like useReducer() or useMemo().');
    }
  }

  if (lastContextWithAllBitsObserved === context) ; else if (observedBits === false || observedBits === 0) ; else {
    var resolvedObservedBits; // Avoid deopting on observable arguments or heterogeneous types.

    if (typeof observedBits !== 'number' || observedBits === MAX_SIGNED_31_BIT_INT) {
      // Observe all updates.
      lastContextWithAllBitsObserved = context;
      resolvedObservedBits = MAX_SIGNED_31_BIT_INT;
    } else {
      resolvedObservedBits = observedBits;
    }

    var contextItem = {
      context: context,
      observedBits: resolvedObservedBits,
      next: null
    };

    if (lastContextDependency === null) {
      if (!(currentlyRenderingFiber !== null)) {
        {
          throw Error( "Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo()." );
        }
      } // This is the first dependency for this component. Create a new list.


      lastContextDependency = contextItem;
      currentlyRenderingFiber.dependencies = {
        lanes: NoLanes,
        firstContext: contextItem,
        responders: null
      };
    } else {
      // Append a new context item.
      lastContextDependency = lastContextDependency.next = contextItem;
    }
  }

  return  context._currentValue ;
}

var UpdateState = 0;
var ReplaceState = 1;
var ForceUpdate = 2;
var CaptureUpdate = 3; // Global state that is reset at the beginning of calling `processUpdateQueue`.
// It should only be read right after calling `processUpdateQueue`, via
// `checkHasForceUpdateAfterProcessing`.

var hasForceUpdate = false;
var didWarnUpdateInsideUpdate;
var currentlyProcessingQueue;

{
  didWarnUpdateInsideUpdate = false;
  currentlyProcessingQueue = null;
}

function initializeUpdateQueue(fiber) {
  var queue = {
    baseState: fiber.memoizedState,
    firstBaseUpdate: null,
    lastBaseUpdate: null,
    shared: {
      pending: null
    },
    effects: null
  };
  fiber.updateQueue = queue;
}
function cloneUpdateQueue(current, workInProgress) {
  // Clone the update queue from current. Unless it's already a clone.
  var queue = workInProgress.updateQueue;
  var currentQueue = current.updateQueue;

  if (queue === currentQueue) {
    var clone = {
      baseState: currentQueue.baseState,
      firstBaseUpdate: currentQueue.firstBaseUpdate,
      lastBaseUpdate: currentQueue.lastBaseUpdate,
      shared: currentQueue.shared,
      effects: currentQueue.effects
    };
    workInProgress.updateQueue = clone;
  }
}
function createUpdate(eventTime, lane) {
  var update = {
    eventTime: eventTime,
    lane: lane,
    tag: UpdateState,
    payload: null,
    callback: null,
    next: null
  };
  return update;
}
function enqueueUpdate(fiber, update) {
  var updateQueue = fiber.updateQueue;

  if (updateQueue === null) {
    // Only occurs if the fiber has been unmounted.
    return;
  }

  var sharedQueue = updateQueue.shared;
  var pending = sharedQueue.pending;

  if (pending === null) {
    // This is the first update. Create a circular list.
    update.next = update;
  } else {
    update.next = pending.next;
    pending.next = update;
  }

  sharedQueue.pending = update;

  {
    if (currentlyProcessingQueue === sharedQueue && !didWarnUpdateInsideUpdate) {
      error('An update (setState, replaceState, or forceUpdate) was scheduled ' + 'from inside an update function. Update functions should be pure, ' + 'with zero side-effects. Consider using componentDidUpdate or a ' + 'callback.');

      didWarnUpdateInsideUpdate = true;
    }
  }
}
function enqueueCapturedUpdate(workInProgress, capturedUpdate) {
  // Captured updates are updates that are thrown by a child during the render
  // phase. They should be discarded if the render is aborted. Therefore,
  // we should only put them on the work-in-progress queue, not the current one.
  var queue = workInProgress.updateQueue; // Check if the work-in-progress queue is a clone.

  var current = workInProgress.alternate;

  if (current !== null) {
    var currentQueue = current.updateQueue;

    if (queue === currentQueue) {
      // The work-in-progress queue is the same as current. This happens when
      // we bail out on a parent fiber that then captures an error thrown by
      // a child. Since we want to append the update only to the work-in
      // -progress queue, we need to clone the updates. We usually clone during
      // processUpdateQueue, but that didn't happen in this case because we
      // skipped over the parent when we bailed out.
      var newFirst = null;
      var newLast = null;
      var firstBaseUpdate = queue.firstBaseUpdate;

      if (firstBaseUpdate !== null) {
        // Loop through the updates and clone them.
        var update = firstBaseUpdate;

        do {
          var clone = {
            eventTime: update.eventTime,
            lane: update.lane,
            tag: update.tag,
            payload: update.payload,
            callback: update.callback,
            next: null
          };

          if (newLast === null) {
            newFirst = newLast = clone;
          } else {
            newLast.next = clone;
            newLast = clone;
          }

          update = update.next;
        } while (update !== null); // Append the captured update the end of the cloned list.


        if (newLast === null) {
          newFirst = newLast = capturedUpdate;
        } else {
          newLast.next = capturedUpdate;
          newLast = capturedUpdate;
        }
      } else {
        // There are no base updates.
        newFirst = newLast = capturedUpdate;
      }

      queue = {
        baseState: currentQueue.baseState,
        firstBaseUpdate: newFirst,
        lastBaseUpdate: newLast,
        shared: currentQueue.shared,
        effects: currentQueue.effects
      };
      workInProgress.updateQueue = queue;
      return;
    }
  } // Append the update to the end of the list.


  var lastBaseUpdate = queue.lastBaseUpdate;

  if (lastBaseUpdate === null) {
    queue.firstBaseUpdate = capturedUpdate;
  } else {
    lastBaseUpdate.next = capturedUpdate;
  }

  queue.lastBaseUpdate = capturedUpdate;
}

function getStateFromUpdate(workInProgress, queue, update, prevState, nextProps, instance) {
  switch (update.tag) {
    case ReplaceState:
      {
        var payload = update.payload;

        if (typeof payload === 'function') {
          // Updater function
          {
            enterDisallowedContextReadInDEV();
          }

          var nextState = payload.call(instance, prevState, nextProps);

          {
            if ( workInProgress.mode & StrictMode) {
              disableLogs();

              try {
                payload.call(instance, prevState, nextProps);
              } finally {
                reenableLogs();
              }
            }

            exitDisallowedContextReadInDEV();
          }

          return nextState;
        } // State object


        return payload;
      }

    case CaptureUpdate:
      {
        workInProgress.flags = workInProgress.flags & ~ShouldCapture | DidCapture;
      }
    // Intentional fallthrough

    case UpdateState:
      {
        var _payload = update.payload;
        var partialState;

        if (typeof _payload === 'function') {
          // Updater function
          {
            enterDisallowedContextReadInDEV();
          }

          partialState = _payload.call(instance, prevState, nextProps);

          {
            if ( workInProgress.mode & StrictMode) {
              disableLogs();

              try {
                _payload.call(instance, prevState, nextProps);
              } finally {
                reenableLogs();
              }
            }

            exitDisallowedContextReadInDEV();
          }
        } else {
          // Partial state object
          partialState = _payload;
        }

        if (partialState === null || partialState === undefined) {
          // Null and undefined are treated as no-ops.
          return prevState;
        } // Merge the partial state and the previous state.


        return _assign({}, prevState, partialState);
      }

    case ForceUpdate:
      {
        hasForceUpdate = true;
        return prevState;
      }
  }

  return prevState;
}

function processUpdateQueue(workInProgress, props, instance, renderLanes) {
  // This is always non-null on a ClassComponent or HostRoot
  var queue = workInProgress.updateQueue;
  hasForceUpdate = false;

  {
    currentlyProcessingQueue = queue.shared;
  }

  var firstBaseUpdate = queue.firstBaseUpdate;
  var lastBaseUpdate = queue.lastBaseUpdate; // Check if there are pending updates. If so, transfer them to the base queue.

  var pendingQueue = queue.shared.pending;

  if (pendingQueue !== null) {
    queue.shared.pending = null; // The pending queue is circular. Disconnect the pointer between first
    // and last so that it's non-circular.

    var lastPendingUpdate = pendingQueue;
    var firstPendingUpdate = lastPendingUpdate.next;
    lastPendingUpdate.next = null; // Append pending updates to base queue

    if (lastBaseUpdate === null) {
      firstBaseUpdate = firstPendingUpdate;
    } else {
      lastBaseUpdate.next = firstPendingUpdate;
    }

    lastBaseUpdate = lastPendingUpdate; // If there's a current queue, and it's different from the base queue, then
    // we need to transfer the updates to that queue, too. Because the base
    // queue is a singly-linked list with no cycles, we can append to both
    // lists and take advantage of structural sharing.
    // TODO: Pass `current` as argument

    var current = workInProgress.alternate;

    if (current !== null) {
      // This is always non-null on a ClassComponent or HostRoot
      var currentQueue = current.updateQueue;
      var currentLastBaseUpdate = currentQueue.lastBaseUpdate;

      if (currentLastBaseUpdate !== lastBaseUpdate) {
        if (currentLastBaseUpdate === null) {
          currentQueue.firstBaseUpdate = firstPendingUpdate;
        } else {
          currentLastBaseUpdate.next = firstPendingUpdate;
        }

        currentQueue.lastBaseUpdate = lastPendingUpdate;
      }
    }
  } // These values may change as we process the queue.


  if (firstBaseUpdate !== null) {
    // Iterate through the list of updates to compute the result.
    var newState = queue.baseState; // TODO: Don't need to accumulate this. Instead, we can remove renderLanes
    // from the original lanes.

    var newLanes = NoLanes;
    var newBaseState = null;
    var newFirstBaseUpdate = null;
    var newLastBaseUpdate = null;
    var update = firstBaseUpdate;

    do {
      var updateLane = update.lane;
      var updateEventTime = update.eventTime;

      if (!isSubsetOfLanes(renderLanes, updateLane)) {
        // Priority is insufficient. Skip this update. If this is the first
        // skipped update, the previous update/state is the new base
        // update/state.
        var clone = {
          eventTime: updateEventTime,
          lane: updateLane,
          tag: update.tag,
          payload: update.payload,
          callback: update.callback,
          next: null
        };

        if (newLastBaseUpdate === null) {
          newFirstBaseUpdate = newLastBaseUpdate = clone;
          newBaseState = newState;
        } else {
          newLastBaseUpdate = newLastBaseUpdate.next = clone;
        } // Update the remaining priority in the queue.


        newLanes = mergeLanes(newLanes, updateLane);
      } else {
        // This update does have sufficient priority.
        if (newLastBaseUpdate !== null) {
          var _clone = {
            eventTime: updateEventTime,
            // This update is going to be committed so we never want uncommit
            // it. Using NoLane works because 0 is a subset of all bitmasks, so
            // this will never be skipped by the check above.
            lane: NoLane,
            tag: update.tag,
            payload: update.payload,
            callback: update.callback,
            next: null
          };
          newLastBaseUpdate = newLastBaseUpdate.next = _clone;
        } // Process this update.


        newState = getStateFromUpdate(workInProgress, queue, update, newState, props, instance);
        var callback = update.callback;

        if (callback !== null) {
          workInProgress.flags |= Callback;
          var effects = queue.effects;

          if (effects === null) {
            queue.effects = [update];
          } else {
            effects.push(update);
          }
        }
      }

      update = update.next;

      if (update === null) {
        pendingQueue = queue.shared.pending;

        if (pendingQueue === null) {
          break;
        } else {
          // An update was scheduled from inside a reducer. Add the new
          // pending updates to the end of the list and keep processing.
          var _lastPendingUpdate = pendingQueue; // Intentionally unsound. Pending updates form a circular list, but we
          // unravel them when transferring them to the base queue.

          var _firstPendingUpdate = _lastPendingUpdate.next;
          _lastPendingUpdate.next = null;
          update = _firstPendingUpdate;
          queue.lastBaseUpdate = _lastPendingUpdate;
          queue.shared.pending = null;
        }
      }
    } while (true);

    if (newLastBaseUpdate === null) {
      newBaseState = newState;
    }

    queue.baseState = newBaseState;
    queue.firstBaseUpdate = newFirstBaseUpdate;
    queue.lastBaseUpdate = newLastBaseUpdate; // Set the remaining expiration time to be whatever is remaining in the queue.
    // This should be fine because the only two other things that contribute to
    // expiration time are props and context. We're already in the middle of the
    // begin phase by the time we start processing the queue, so we've already
    // dealt with the props. Context in components that specify
    // shouldComponentUpdate is tricky; but we'll have to account for
    // that regardless.

    markSkippedUpdateLanes(newLanes);
    workInProgress.lanes = newLanes;
    workInProgress.memoizedState = newState;
  }

  {
    currentlyProcessingQueue = null;
  }
}

function callCallback(callback, context) {
  if (!(typeof callback === 'function')) {
    {
      throw Error( "Invalid argument passed as callback. Expected a function. Instead received: " + callback );
    }
  }

  callback.call(context);
}

function resetHasForceUpdateBeforeProcessing() {
  hasForceUpdate = false;
}
function checkHasForceUpdateAfterProcessing() {
  return hasForceUpdate;
}
function commitUpdateQueue(finishedWork, finishedQueue, instance) {
  // Commit the effects
  var effects = finishedQueue.effects;
  finishedQueue.effects = null;

  if (effects !== null) {
    for (var i = 0; i < effects.length; i++) {
      var effect = effects[i];
      var callback = effect.callback;

      if (callback !== null) {
        effect.callback = null;
        callCallback(callback, instance);
      }
    }
  }
}

var fakeInternalInstance = {};
var isArray = Array.isArray; // React.Component uses a shared frozen object by default.
// We'll use it to determine whether we need to initialize legacy refs.

var emptyRefsObject = new React.Component().refs;
var didWarnAboutStateAssignmentForComponent;
var didWarnAboutUninitializedState;
var didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate;
var didWarnAboutLegacyLifecyclesAndDerivedState;
var didWarnAboutUndefinedDerivedState;
var warnOnUndefinedDerivedState;
var warnOnInvalidCallback;
var didWarnAboutDirectlyAssigningPropsToState;
var didWarnAboutContextTypeAndContextTypes;
var didWarnAboutInvalidateContextType;

{
  didWarnAboutStateAssignmentForComponent = new Set();
  didWarnAboutUninitializedState = new Set();
  didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate = new Set();
  didWarnAboutLegacyLifecyclesAndDerivedState = new Set();
  didWarnAboutDirectlyAssigningPropsToState = new Set();
  didWarnAboutUndefinedDerivedState = new Set();
  didWarnAboutContextTypeAndContextTypes = new Set();
  didWarnAboutInvalidateContextType = new Set();
  var didWarnOnInvalidCallback = new Set();

  warnOnInvalidCallback = function (callback, callerName) {
    if (callback === null || typeof callback === 'function') {
      return;
    }

    var key = callerName + '_' + callback;

    if (!didWarnOnInvalidCallback.has(key)) {
      didWarnOnInvalidCallback.add(key);

      error('%s(...): Expected the last optional `callback` argument to be a ' + 'function. Instead received: %s.', callerName, callback);
    }
  };

  warnOnUndefinedDerivedState = function (type, partialState) {
    if (partialState === undefined) {
      var componentName = getComponentName(type) || 'Component';

      if (!didWarnAboutUndefinedDerivedState.has(componentName)) {
        didWarnAboutUndefinedDerivedState.add(componentName);

        error('%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. ' + 'You have returned undefined.', componentName);
      }
    }
  }; // This is so gross but it's at least non-critical and can be removed if
  // it causes problems. This is meant to give a nicer error message for
  // ReactDOM15.unstable_renderSubtreeIntoContainer(reactDOM16Component,
  // ...)) which otherwise throws a "_processChildContext is not a function"
  // exception.


  Object.defineProperty(fakeInternalInstance, '_processChildContext', {
    enumerable: false,
    value: function () {
      {
        {
          throw Error( "_processChildContext is not available in React 16+. This likely means you have multiple copies of React and are attempting to nest a React 15 tree inside a React 16 tree using unstable_renderSubtreeIntoContainer, which isn't supported. Try to make sure you have only one copy of React (and ideally, switch to ReactDOM.createPortal)." );
        }
      }
    }
  });
  Object.freeze(fakeInternalInstance);
}

function applyDerivedStateFromProps(workInProgress, ctor, getDerivedStateFromProps, nextProps) {
  var prevState = workInProgress.memoizedState;

  {
    if ( workInProgress.mode & StrictMode) {
      disableLogs();

      try {
        // Invoke the function an extra time to help detect side-effects.
        getDerivedStateFromProps(nextProps, prevState);
      } finally {
        reenableLogs();
      }
    }
  }

  var partialState = getDerivedStateFromProps(nextProps, prevState);

  {
    warnOnUndefinedDerivedState(ctor, partialState);
  } // Merge the partial state and the previous state.


  var memoizedState = partialState === null || partialState === undefined ? prevState : _assign({}, prevState, partialState);
  workInProgress.memoizedState = memoizedState; // Once the update queue is empty, persist the derived state onto the
  // base state.

  if (workInProgress.lanes === NoLanes) {
    // Queue is always non-null for classes
    var updateQueue = workInProgress.updateQueue;
    updateQueue.baseState = memoizedState;
  }
}
var classComponentUpdater = {
  isMounted: isMounted,
  enqueueSetState: function (inst, payload, callback) {
    var fiber = get(inst);
    var eventTime = requestEventTime();
    var lane = requestUpdateLane(fiber);
    var update = createUpdate(eventTime, lane);
    update.payload = payload;

    if (callback !== undefined && callback !== null) {
      {
        warnOnInvalidCallback(callback, 'setState');
      }

      update.callback = callback;
    }

    enqueueUpdate(fiber, update);
    scheduleUpdateOnFiber(fiber, lane, eventTime);
  },
  enqueueReplaceState: function (inst, payload, callback) {
    var fiber = get(inst);
    var eventTime = requestEventTime();
    var lane = requestUpdateLane(fiber);
    var update = createUpdate(eventTime, lane);
    update.tag = ReplaceState;
    update.payload = payload;

    if (callback !== undefined && callback !== null) {
      {
        warnOnInvalidCallback(callback, 'replaceState');
      }

      update.callback = callback;
    }

    enqueueUpdate(fiber, update);
    scheduleUpdateOnFiber(fiber, lane, eventTime);
  },
  enqueueForceUpdate: function (inst, callback) {
    var fiber = get(inst);
    var eventTime = requestEventTime();
    var lane = requestUpdateLane(fiber);
    var update = createUpdate(eventTime, lane);
    update.tag = ForceUpdate;

    if (callback !== undefined && callback !== null) {
      {
        warnOnInvalidCallback(callback, 'forceUpdate');
      }

      update.callback = callback;
    }

    enqueueUpdate(fiber, update);
    scheduleUpdateOnFiber(fiber, lane, eventTime);
  }
};

function checkShouldComponentUpdate(workInProgress, ctor, oldProps, newProps, oldState, newState, nextContext) {
  var instance = workInProgress.stateNode;

  if (typeof instance.shouldComponentUpdate === 'function') {
    {
      if ( workInProgress.mode & StrictMode) {
        disableLogs();

        try {
          // Invoke the function an extra time to help detect side-effects.
          instance.shouldComponentUpdate(newProps, newState, nextContext);
        } finally {
          reenableLogs();
        }
      }
    }

    var shouldUpdate = instance.shouldComponentUpdate(newProps, newState, nextContext);

    {
      if (shouldUpdate === undefined) {
        error('%s.shouldComponentUpdate(): Returned undefined instead of a ' + 'boolean value. Make sure to return true or false.', getComponentName(ctor) || 'Component');
      }
    }

    return shouldUpdate;
  }

  if (ctor.prototype && ctor.prototype.isPureReactComponent) {
    return !shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState);
  }

  return true;
}

function checkClassInstance(workInProgress, ctor, newProps) {
  var instance = workInProgress.stateNode;

  {
    var name = getComponentName(ctor) || 'Component';
    var renderPresent = instance.render;

    if (!renderPresent) {
      if (ctor.prototype && typeof ctor.prototype.render === 'function') {
        error('%s(...): No `render` method found on the returned component ' + 'instance: did you accidentally return an object from the constructor?', name);
      } else {
        error('%s(...): No `render` method found on the returned component ' + 'instance: you may have forgotten to define `render`.', name);
      }
    }

    if (instance.getInitialState && !instance.getInitialState.isReactClassApproved && !instance.state) {
      error('getInitialState was defined on %s, a plain JavaScript class. ' + 'This is only supported for classes created using React.createClass. ' + 'Did you mean to define a state property instead?', name);
    }

    if (instance.getDefaultProps && !instance.getDefaultProps.isReactClassApproved) {
      error('getDefaultProps was defined on %s, a plain JavaScript class. ' + 'This is only supported for classes created using React.createClass. ' + 'Use a static property to define defaultProps instead.', name);
    }

    if (instance.propTypes) {
      error('propTypes was defined as an instance property on %s. Use a static ' + 'property to define propTypes instead.', name);
    }

    if (instance.contextType) {
      error('contextType was defined as an instance property on %s. Use a static ' + 'property to define contextType instead.', name);
    }

    {
      if (instance.contextTypes) {
        error('contextTypes was defined as an instance property on %s. Use a static ' + 'property to define contextTypes instead.', name);
      }

      if (ctor.contextType && ctor.contextTypes && !didWarnAboutContextTypeAndContextTypes.has(ctor)) {
        didWarnAboutContextTypeAndContextTypes.add(ctor);

        error('%s declares both contextTypes and contextType static properties. ' + 'The legacy contextTypes property will be ignored.', name);
      }
    }

    if (typeof instance.componentShouldUpdate === 'function') {
      error('%s has a method called ' + 'componentShouldUpdate(). Did you mean shouldComponentUpdate()? ' + 'The name is phrased as a question because the function is ' + 'expected to return a value.', name);
    }

    if (ctor.prototype && ctor.prototype.isPureReactComponent && typeof instance.shouldComponentUpdate !== 'undefined') {
      error('%s has a method called shouldComponentUpdate(). ' + 'shouldComponentUpdate should not be used when extending React.PureComponent. ' + 'Please extend React.Component if shouldComponentUpdate is used.', getComponentName(ctor) || 'A pure component');
    }

    if (typeof instance.componentDidUnmount === 'function') {
      error('%s has a method called ' + 'componentDidUnmount(). But there is no such lifecycle method. ' + 'Did you mean componentWillUnmount()?', name);
    }

    if (typeof instance.componentDidReceiveProps === 'function') {
      error('%s has a method called ' + 'componentDidReceiveProps(). But there is no such lifecycle method. ' + 'If you meant to update the state in response to changing props, ' + 'use componentWillReceiveProps(). If you meant to fetch data or ' + 'run side-effects or mutations after React has updated the UI, use componentDidUpdate().', name);
    }

    if (typeof instance.componentWillRecieveProps === 'function') {
      error('%s has a method called ' + 'componentWillRecieveProps(). Did you mean componentWillReceiveProps()?', name);
    }

    if (typeof instance.UNSAFE_componentWillRecieveProps === 'function') {
      error('%s has a method called ' + 'UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?', name);
    }

    var hasMutatedProps = instance.props !== newProps;

    if (instance.props !== undefined && hasMutatedProps) {
      error('%s(...): When calling super() in `%s`, make sure to pass ' + "up the same props that your component's constructor was passed.", name, name);
    }

    if (instance.defaultProps) {
      error('Setting defaultProps as an instance property on %s is not supported and will be ignored.' + ' Instead, define defaultProps as a static property on %s.', name, name);
    }

    if (typeof instance.getSnapshotBeforeUpdate === 'function' && typeof instance.componentDidUpdate !== 'function' && !didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.has(ctor)) {
      didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.add(ctor);

      error('%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). ' + 'This component defines getSnapshotBeforeUpdate() only.', getComponentName(ctor));
    }

    if (typeof instance.getDerivedStateFromProps === 'function') {
      error('%s: getDerivedStateFromProps() is defined as an instance method ' + 'and will be ignored. Instead, declare it as a static method.', name);
    }

    if (typeof instance.getDerivedStateFromError === 'function') {
      error('%s: getDerivedStateFromError() is defined as an instance method ' + 'and will be ignored. Instead, declare it as a static method.', name);
    }

    if (typeof ctor.getSnapshotBeforeUpdate === 'function') {
      error('%s: getSnapshotBeforeUpdate() is defined as a static method ' + 'and will be ignored. Instead, declare it as an instance method.', name);
    }

    var _state = instance.state;

    if (_state && (typeof _state !== 'object' || isArray(_state))) {
      error('%s.state: must be set to an object or null', name);
    }

    if (typeof instance.getChildContext === 'function' && typeof ctor.childContextTypes !== 'object') {
      error('%s.getChildContext(): childContextTypes must be defined in order to ' + 'use getChildContext().', name);
    }
  }
}

function adoptClassInstance(workInProgress, instance) {
  instance.updater = classComponentUpdater;
  workInProgress.stateNode = instance; // The instance needs access to the fiber so that it can schedule updates

  set(instance, workInProgress);

  {
    instance._reactInternalInstance = fakeInternalInstance;
  }
}

function constructClassInstance(workInProgress, ctor, props) {
  var isLegacyContextConsumer = false;
  var unmaskedContext = emptyContextObject;
  var context = emptyContextObject;
  var contextType = ctor.contextType;

  {
    if ('contextType' in ctor) {
      var isValid = // Allow null for conditional declaration
      contextType === null || contextType !== undefined && contextType.$$typeof === REACT_CONTEXT_TYPE && contextType._context === undefined; // Not a <Context.Consumer>

      if (!isValid && !didWarnAboutInvalidateContextType.has(ctor)) {
        didWarnAboutInvalidateContextType.add(ctor);
        var addendum = '';

        if (contextType === undefined) {
          addendum = ' However, it is set to undefined. ' + 'This can be caused by a typo or by mixing up named and default imports. ' + 'This can also happen due to a circular dependency, so ' + 'try moving the createContext() call to a separate file.';
        } else if (typeof contextType !== 'object') {
          addendum = ' However, it is set to a ' + typeof contextType + '.';
        } else if (contextType.$$typeof === REACT_PROVIDER_TYPE) {
          addendum = ' Did you accidentally pass the Context.Provider instead?';
        } else if (contextType._context !== undefined) {
          // <Context.Consumer>
          addendum = ' Did you accidentally pass the Context.Consumer instead?';
        } else {
          addendum = ' However, it is set to an object with keys {' + Object.keys(contextType).join(', ') + '}.';
        }

        error('%s defines an invalid contextType. ' + 'contextType should point to the Context object returned by React.createContext().%s', getComponentName(ctor) || 'Component', addendum);
      }
    }
  }

  if (typeof contextType === 'object' && contextType !== null) {
    context = readContext(contextType);
  } else {
    unmaskedContext = getUnmaskedContext(workInProgress, ctor, true);
    var contextTypes = ctor.contextTypes;
    isLegacyContextConsumer = contextTypes !== null && contextTypes !== undefined;
    context = isLegacyContextConsumer ? getMaskedContext(workInProgress, unmaskedContext) : emptyContextObject;
  } // Instantiate twice to help detect side-effects.


  {
    if ( workInProgress.mode & StrictMode) {
      disableLogs();

      try {
        new ctor(props, context); // eslint-disable-line no-new
      } finally {
        reenableLogs();
      }
    }
  }

  var instance = new ctor(props, context);
  var state = workInProgress.memoizedState = instance.state !== null && instance.state !== undefined ? instance.state : null;
  adoptClassInstance(workInProgress, instance);

  {
    if (typeof ctor.getDerivedStateFromProps === 'function' && state === null) {
      var componentName = getComponentName(ctor) || 'Component';

      if (!didWarnAboutUninitializedState.has(componentName)) {
        didWarnAboutUninitializedState.add(componentName);

        error('`%s` uses `getDerivedStateFromProps` but its initial state is ' + '%s. This is not recommended. Instead, define the initial state by ' + 'assigning an object to `this.state` in the constructor of `%s`. ' + 'This ensures that `getDerivedStateFromProps` arguments have a consistent shape.', componentName, instance.state === null ? 'null' : 'undefined', componentName);
      }
    } // If new component APIs are defined, "unsafe" lifecycles won't be called.
    // Warn about these lifecycles if they are present.
    // Don't warn about react-lifecycles-compat polyfilled methods though.


    if (typeof ctor.getDerivedStateFromProps === 'function' || typeof instance.getSnapshotBeforeUpdate === 'function') {
      var foundWillMountName = null;
      var foundWillReceivePropsName = null;
      var foundWillUpdateName = null;

      if (typeof instance.componentWillMount === 'function' && instance.componentWillMount.__suppressDeprecationWarning !== true) {
        foundWillMountName = 'componentWillMount';
      } else if (typeof instance.UNSAFE_componentWillMount === 'function') {
        foundWillMountName = 'UNSAFE_componentWillMount';
      }

      if (typeof instance.componentWillReceiveProps === 'function' && instance.componentWillReceiveProps.__suppressDeprecationWarning !== true) {
        foundWillReceivePropsName = 'componentWillReceiveProps';
      } else if (typeof instance.UNSAFE_componentWillReceiveProps === 'function') {
        foundWillReceivePropsName = 'UNSAFE_componentWillReceiveProps';
      }

      if (typeof instance.componentWillUpdate === 'function' && instance.componentWillUpdate.__suppressDeprecationWarning !== true) {
        foundWillUpdateName = 'componentWillUpdate';
      } else if (typeof instance.UNSAFE_componentWillUpdate === 'function') {
        foundWillUpdateName = 'UNSAFE_componentWillUpdate';
      }

      if (foundWillMountName !== null || foundWillReceivePropsName !== null || foundWillUpdateName !== null) {
        var _componentName = getComponentName(ctor) || 'Component';

        var newApiName = typeof ctor.getDerivedStateFromProps === 'function' ? 'getDerivedStateFromProps()' : 'getSnapshotBeforeUpdate()';

        if (!didWarnAboutLegacyLifecyclesAndDerivedState.has(_componentName)) {
          didWarnAboutLegacyLifecyclesAndDerivedState.add(_componentName);

          error('Unsafe legacy lifecycles will not be called for components using new component APIs.\n\n' + '%s uses %s but also contains the following legacy lifecycles:%s%s%s\n\n' + 'The above lifecycles should be removed. Learn more about this warning here:\n' + 'https://reactjs.org/link/unsafe-component-lifecycles', _componentName, newApiName, foundWillMountName !== null ? "\n  " + foundWillMountName : '', foundWillReceivePropsName !== null ? "\n  " + foundWillReceivePropsName : '', foundWillUpdateName !== null ? "\n  " + foundWillUpdateName : '');
        }
      }
    }
  } // Cache unmasked context so we can avoid recreating masked context unless necessary.
  // ReactFiberContext usually updates this cache but can't for newly-created instances.


  if (isLegacyContextConsumer) {
    cacheContext(workInProgress, unmaskedContext, context);
  }

  return instance;
}

function callComponentWillMount(workInProgress, instance) {
  var oldState = instance.state;

  if (typeof instance.componentWillMount === 'function') {
    instance.componentWillMount();
  }

  if (typeof instance.UNSAFE_componentWillMount === 'function') {
    instance.UNSAFE_componentWillMount();
  }

  if (oldState !== instance.state) {
    {
      error('%s.componentWillMount(): Assigning directly to this.state is ' + "deprecated (except inside a component's " + 'constructor). Use setState instead.', getComponentName(workInProgress.type) || 'Component');
    }

    classComponentUpdater.enqueueReplaceState(instance, instance.state, null);
  }
}

function callComponentWillReceiveProps(workInProgress, instance, newProps, nextContext) {
  var oldState = instance.state;

  if (typeof instance.componentWillReceiveProps === 'function') {
    instance.componentWillReceiveProps(newProps, nextContext);
  }

  if (typeof instance.UNSAFE_componentWillReceiveProps === 'function') {
    instance.UNSAFE_componentWillReceiveProps(newProps, nextContext);
  }

  if (instance.state !== oldState) {
    {
      var componentName = getComponentName(workInProgress.type) || 'Component';

      if (!didWarnAboutStateAssignmentForComponent.has(componentName)) {
        didWarnAboutStateAssignmentForComponent.add(componentName);

        error('%s.componentWillReceiveProps(): Assigning directly to ' + "this.state is deprecated (except inside a component's " + 'constructor). Use setState instead.', componentName);
      }
    }

    classComponentUpdater.enqueueReplaceState(instance, instance.state, null);
  }
} // Invokes the mount life-cycles on a previously never rendered instance.


function mountClassInstance(workInProgress, ctor, newProps, renderLanes) {
  {
    checkClassInstance(workInProgress, ctor, newProps);
  }

  var instance = workInProgress.stateNode;
  instance.props = newProps;
  instance.state = workInProgress.memoizedState;
  instance.refs = emptyRefsObject;
  initializeUpdateQueue(workInProgress);
  var contextType = ctor.contextType;

  if (typeof contextType === 'object' && contextType !== null) {
    instance.context = readContext(contextType);
  } else {
    var unmaskedContext = getUnmaskedContext(workInProgress, ctor, true);
    instance.context = getMaskedContext(workInProgress, unmaskedContext);
  }

  {
    if (instance.state === newProps) {
      var componentName = getComponentName(ctor) || 'Component';

      if (!didWarnAboutDirectlyAssigningPropsToState.has(componentName)) {
        didWarnAboutDirectlyAssigningPropsToState.add(componentName);

        error('%s: It is not recommended to assign props directly to state ' + "because updates to props won't be reflected in state. " + 'In most cases, it is better to use props directly.', componentName);
      }
    }

    if (workInProgress.mode & StrictMode) {
      ReactStrictModeWarnings.recordLegacyContextWarning(workInProgress, instance);
    }

    {
      ReactStrictModeWarnings.recordUnsafeLifecycleWarnings(workInProgress, instance);
    }
  }

  processUpdateQueue(workInProgress, newProps, instance, renderLanes);
  instance.state = workInProgress.memoizedState;
  var getDerivedStateFromProps = ctor.getDerivedStateFromProps;

  if (typeof getDerivedStateFromProps === 'function') {
    applyDerivedStateFromProps(workInProgress, ctor, getDerivedStateFromProps, newProps);
    instance.state = workInProgress.memoizedState;
  } // In order to support react-lifecycles-compat polyfilled components,
  // Unsafe lifecycles should not be invoked for components using the new APIs.


  if (typeof ctor.getDerivedStateFromProps !== 'function' && typeof instance.getSnapshotBeforeUpdate !== 'function' && (typeof instance.UNSAFE_componentWillMount === 'function' || typeof instance.componentWillMount === 'function')) {
    callComponentWillMount(workInProgress, instance); // If we had additional state updates during this life-cycle, let's
    // process them now.

    processUpdateQueue(workInProgress, newProps, instance, renderLanes);
    instance.state = workInProgress.memoizedState;
  }

  if (typeof instance.componentDidMount === 'function') {
    workInProgress.flags |= Update;
  }
}

function resumeMountClassInstance(workInProgress, ctor, newProps, renderLanes) {
  var instance = workInProgress.stateNode;
  var oldProps = workInProgress.memoizedProps;
  instance.props = oldProps;
  var oldContext = instance.context;
  var contextType = ctor.contextType;
  var nextContext = emptyContextObject;

  if (typeof contextType === 'object' && contextType !== null) {
    nextContext = readContext(contextType);
  } else {
    var nextLegacyUnmaskedContext = getUnmaskedContext(workInProgress, ctor, true);
    nextContext = getMaskedContext(workInProgress, nextLegacyUnmaskedContext);
  }

  var getDerivedStateFromProps = ctor.getDerivedStateFromProps;
  var hasNewLifecycles = typeof getDerivedStateFromProps === 'function' || typeof instance.getSnapshotBeforeUpdate === 'function'; // Note: During these life-cycles, instance.props/instance.state are what
  // ever the previously attempted to render - not the "current". However,
  // during componentDidUpdate we pass the "current" props.
  // In order to support react-lifecycles-compat polyfilled components,
  // Unsafe lifecycles should not be invoked for components using the new APIs.

  if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillReceiveProps === 'function' || typeof instance.componentWillReceiveProps === 'function')) {
    if (oldProps !== newProps || oldContext !== nextContext) {
      callComponentWillReceiveProps(workInProgress, instance, newProps, nextContext);
    }
  }

  resetHasForceUpdateBeforeProcessing();
  var oldState = workInProgress.memoizedState;
  var newState = instance.state = oldState;
  processUpdateQueue(workInProgress, newProps, instance, renderLanes);
  newState = workInProgress.memoizedState;

  if (oldProps === newProps && oldState === newState && !hasContextChanged() && !checkHasForceUpdateAfterProcessing()) {
    // If an update was already in progress, we should schedule an Update
    // effect even though we're bailing out, so that cWU/cDU are called.
    if (typeof instance.componentDidMount === 'function') {
      workInProgress.flags |= Update;
    }

    return false;
  }

  if (typeof getDerivedStateFromProps === 'function') {
    applyDerivedStateFromProps(workInProgress, ctor, getDerivedStateFromProps, newProps);
    newState = workInProgress.memoizedState;
  }

  var shouldUpdate = checkHasForceUpdateAfterProcessing() || checkShouldComponentUpdate(workInProgress, ctor, oldProps, newProps, oldState, newState, nextContext);

  if (shouldUpdate) {
    // In order to support react-lifecycles-compat polyfilled components,
    // Unsafe lifecycles should not be invoked for components using the new APIs.
    if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillMount === 'function' || typeof instance.componentWillMount === 'function')) {
      if (typeof instance.componentWillMount === 'function') {
        instance.componentWillMount();
      }

      if (typeof instance.UNSAFE_componentWillMount === 'function') {
        instance.UNSAFE_componentWillMount();
      }
    }

    if (typeof instance.componentDidMount === 'function') {
      workInProgress.flags |= Update;
    }
  } else {
    // If an update was already in progress, we should schedule an Update
    // effect even though we're bailing out, so that cWU/cDU are called.
    if (typeof instance.componentDidMount === 'function') {
      workInProgress.flags |= Update;
    } // If shouldComponentUpdate returned false, we should still update the
    // memoized state to indicate that this work can be reused.


    workInProgress.memoizedProps = newProps;
    workInProgress.memoizedState = newState;
  } // Update the existing instance's state, props, and context pointers even
  // if shouldComponentUpdate returns false.


  instance.props = newProps;
  instance.state = newState;
  instance.context = nextContext;
  return shouldUpdate;
} // Invokes the update life-cycles and returns false if it shouldn't rerender.


function updateClassInstance(current, workInProgress, ctor, newProps, renderLanes) {
  var instance = workInProgress.stateNode;
  cloneUpdateQueue(current, workInProgress);
  var unresolvedOldProps = workInProgress.memoizedProps;
  var oldProps = workInProgress.type === workInProgress.elementType ? unresolvedOldProps : resolveDefaultProps(workInProgress.type, unresolvedOldProps);
  instance.props = oldProps;
  var unresolvedNewProps = workInProgress.pendingProps;
  var oldContext = instance.context;
  var contextType = ctor.contextType;
  var nextContext = emptyContextObject;

  if (typeof contextType === 'object' && contextType !== null) {
    nextContext = readContext(contextType);
  } else {
    var nextUnmaskedContext = getUnmaskedContext(workInProgress, ctor, true);
    nextContext = getMaskedContext(workInProgress, nextUnmaskedContext);
  }

  var getDerivedStateFromProps = ctor.getDerivedStateFromProps;
  var hasNewLifecycles = typeof getDerivedStateFromProps === 'function' || typeof instance.getSnapshotBeforeUpdate === 'function'; // Note: During these life-cycles, instance.props/instance.state are what
  // ever the previously attempted to render - not the "current". However,
  // during componentDidUpdate we pass the "current" props.
  // In order to support react-lifecycles-compat polyfilled components,
  // Unsafe lifecycles should not be invoked for components using the new APIs.

  if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillReceiveProps === 'function' || typeof instance.componentWillReceiveProps === 'function')) {
    if (unresolvedOldProps !== unresolvedNewProps || oldContext !== nextContext) {
      callComponentWillReceiveProps(workInProgress, instance, newProps, nextContext);
    }
  }

  resetHasForceUpdateBeforeProcessing();
  var oldState = workInProgress.memoizedState;
  var newState = instance.state = oldState;
  processUpdateQueue(workInProgress, newProps, instance, renderLanes);
  newState = workInProgress.memoizedState;

  if (unresolvedOldProps === unresolvedNewProps && oldState === newState && !hasContextChanged() && !checkHasForceUpdateAfterProcessing()) {
    // If an update was already in progress, we should schedule an Update
    // effect even though we're bailing out, so that cWU/cDU are called.
    if (typeof instance.componentDidUpdate === 'function') {
      if (unresolvedOldProps !== current.memoizedProps || oldState !== current.memoizedState) {
        workInProgress.flags |= Update;
      }
    }

    if (typeof instance.getSnapshotBeforeUpdate === 'function') {
      if (unresolvedOldProps !== current.memoizedProps || oldState !== current.memoizedState) {
        workInProgress.flags |= Snapshot;
      }
    }

    return false;
  }

  if (typeof getDerivedStateFromProps === 'function') {
    applyDerivedStateFromProps(workInProgress, ctor, getDerivedStateFromProps, newProps);
    newState = workInProgress.memoizedState;
  }

  var shouldUpdate = checkHasForceUpdateAfterProcessing() || checkShouldComponentUpdate(workInProgress, ctor, oldProps, newProps, oldState, newState, nextContext);

  if (shouldUpdate) {
    // In order to support react-lifecycles-compat polyfilled components,
    // Unsafe lifecycles should not be invoked for components using the new APIs.
    if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillUpdate === 'function' || typeof instance.componentWillUpdate === 'function')) {
      if (typeof instance.componentWillUpdate === 'function') {
        instance.componentWillUpdate(newProps, newState, nextContext);
      }

      if (typeof instance.UNSAFE_componentWillUpdate === 'function') {
        instance.UNSAFE_componentWillUpdate(newProps, newState, nextContext);
      }
    }

    if (typeof instance.componentDidUpdate === 'function') {
      workInProgress.flags |= Update;
    }

    if (typeof instance.getSnapshotBeforeUpdate === 'function') {
      workInProgress.flags |= Snapshot;
    }
  } else {
    // If an update was already in progress, we should schedule an Update
    // effect even though we're bailing out, so that cWU/cDU are called.
    if (typeof instance.componentDidUpdate === 'function') {
      if (unresolvedOldProps !== current.memoizedProps || oldState !== current.memoizedState) {
        workInProgress.flags |= Update;
      }
    }

    if (typeof instance.getSnapshotBeforeUpdate === 'function') {
      if (unresolvedOldProps !== current.memoizedProps || oldState !== current.memoizedState) {
        workInProgress.flags |= Snapshot;
      }
    } // If shouldComponentUpdate returned false, we should still update the
    // memoized props/state to indicate that this work can be reused.


    workInProgress.memoizedProps = newProps;
    workInProgress.memoizedState = newState;
  } // Update the existing instance's state, props, and context pointers even
  // if shouldComponentUpdate returns false.


  instance.props = newProps;
  instance.state = newState;
  instance.context = nextContext;
  return shouldUpdate;
}

var didWarnAboutMaps;
var didWarnAboutGenerators;
var didWarnAboutStringRefs;
var ownerHasKeyUseWarning;
var ownerHasFunctionTypeWarning;

var warnForMissingKey = function (child, returnFiber) {};

{
  didWarnAboutMaps = false;
  didWarnAboutGenerators = false;
  didWarnAboutStringRefs = {};
  /**
   * Warn if there's no key explicitly set on dynamic arrays of children or
   * object keys are not valid. This allows us to keep track of children between
   * updates.
   */

  ownerHasKeyUseWarning = {};
  ownerHasFunctionTypeWarning = {};

  warnForMissingKey = function (child, returnFiber) {
    if (child === null || typeof child !== 'object') {
      return;
    }

    if (!child._store || child._store.validated || child.key != null) {
      return;
    }

    if (!(typeof child._store === 'object')) {
      {
        throw Error( "React Component in warnForMissingKey should have a _store. This error is likely caused by a bug in React. Please file an issue." );
      }
    }

    child._store.validated = true;
    var componentName = getComponentName(returnFiber.type) || 'Component';

    if (ownerHasKeyUseWarning[componentName]) {
      return;
    }

    ownerHasKeyUseWarning[componentName] = true;

    error('Each child in a list should have a unique ' + '"key" prop. See https://reactjs.org/link/warning-keys for ' + 'more information.');
  };
}

var isArray$1 = Array.isArray;

function coerceRef(returnFiber, current, element) {
  var mixedRef = element.ref;

  if (mixedRef !== null && typeof mixedRef !== 'function' && typeof mixedRef !== 'object') {
    {
      // TODO: Clean this up once we turn on the string ref warning for
      // everyone, because the strict mode case will no longer be relevant
      if ((returnFiber.mode & StrictMode || warnAboutStringRefs) && // We warn in ReactElement.js if owner and self are equal for string refs
      // because these cannot be automatically converted to an arrow function
      // using a codemod. Therefore, we don't have to warn about string refs again.
      !(element._owner && element._self && element._owner.stateNode !== element._self)) {
        var componentName = getComponentName(returnFiber.type) || 'Component';

        if (!didWarnAboutStringRefs[componentName]) {
          {
            error('A string ref, "%s", has been found within a strict mode tree. ' + 'String refs are a source of potential bugs and should be avoided. ' + 'We recommend using useRef() or createRef() instead. ' + 'Learn more about using refs safely here: ' + 'https://reactjs.org/link/strict-mode-string-ref', mixedRef);
          }

          didWarnAboutStringRefs[componentName] = true;
        }
      }
    }

    if (element._owner) {
      var owner = element._owner;
      var inst;

      if (owner) {
        var ownerFiber = owner;

        if (!(ownerFiber.tag === ClassComponent)) {
          {
            throw Error( "Function components cannot have string refs. We recommend using useRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref" );
          }
        }

        inst = ownerFiber.stateNode;
      }

      if (!inst) {
        {
          throw Error( "Missing owner for string ref " + mixedRef + ". This error is likely caused by a bug in React. Please file an issue." );
        }
      }

      var stringRef = '' + mixedRef; // Check if previous string ref matches new string ref

      if (current !== null && current.ref !== null && typeof current.ref === 'function' && current.ref._stringRef === stringRef) {
        return current.ref;
      }

      var ref = function (value) {
        var refs = inst.refs;

        if (refs === emptyRefsObject) {
          // This is a lazy pooled frozen object, so we need to initialize.
          refs = inst.refs = {};
        }

        if (value === null) {
          delete refs[stringRef];
        } else {
          refs[stringRef] = value;
        }
      };

      ref._stringRef = stringRef;
      return ref;
    } else {
      if (!(typeof mixedRef === 'string')) {
        {
          throw Error( "Expected ref to be a function, a string, an object returned by React.createRef(), or null." );
        }
      }

      if (!element._owner) {
        {
          throw Error( "Element ref was specified as a string (" + mixedRef + ") but no owner was set. This could happen for one of the following reasons:\n1. You may be adding a ref to a function component\n2. You may be adding a ref to a component that was not created inside a component's render method\n3. You have multiple copies of React loaded\nSee https://reactjs.org/link/refs-must-have-owner for more information." );
        }
      }
    }
  }

  return mixedRef;
}

function throwOnInvalidObjectType(returnFiber, newChild) {
  if (returnFiber.type !== 'textarea') {
    {
      {
        throw Error( "Objects are not valid as a React child (found: " + (Object.prototype.toString.call(newChild) === '[object Object]' ? 'object with keys {' + Object.keys(newChild).join(', ') + '}' : newChild) + "). If you meant to render a collection of children, use an array instead." );
      }
    }
  }
}

function warnOnFunctionType(returnFiber) {
  {
    var componentName = getComponentName(returnFiber.type) || 'Component';

    if (ownerHasFunctionTypeWarning[componentName]) {
      return;
    }

    ownerHasFunctionTypeWarning[componentName] = true;

    error('Functions are not valid as a React child. This may happen if ' + 'you return a Component instead of <Component /> from render. ' + 'Or maybe you meant to call this function rather than return it.');
  }
} // We avoid inlining this to avoid potential deopts from using try/catch.
// to be able to optimize each path individually by branching early. This needs
// a compiler or we can do it manually. Helpers that don't need this branching
// live outside of this function.


function ChildReconciler(shouldTrackSideEffects) {
  function deleteChild(returnFiber, childToDelete) {
    if (!shouldTrackSideEffects) {
      // Noop.
      return;
    } // Deletions are added in reversed order so we add it to the front.
    // At this point, the return fiber's effect list is empty except for
    // deletions, so we can just append the deletion to the list. The remaining
    // effects aren't added until the complete phase. Once we implement
    // resuming, this may not be true.


    var last = returnFiber.lastEffect;

    if (last !== null) {
      last.nextEffect = childToDelete;
      returnFiber.lastEffect = childToDelete;
    } else {
      returnFiber.firstEffect = returnFiber.lastEffect = childToDelete;
    }

    childToDelete.nextEffect = null;
    childToDelete.flags = Deletion;
  }

  function deleteRemainingChildren(returnFiber, currentFirstChild) {
    if (!shouldTrackSideEffects) {
      // Noop.
      return null;
    } // TODO: For the shouldClone case, this could be micro-optimized a bit by
    // assuming that after the first child we've already added everything.


    var childToDelete = currentFirstChild;

    while (childToDelete !== null) {
      deleteChild(returnFiber, childToDelete);
      childToDelete = childToDelete.sibling;
    }

    return null;
  }

  function mapRemainingChildren(returnFiber, currentFirstChild) {
    // Add the remaining children to a temporary map so that we can find them by
    // keys quickly. Implicit (null) keys get added to this set with their index
    // instead.
    var existingChildren = new Map();
    var existingChild = currentFirstChild;

    while (existingChild !== null) {
      if (existingChild.key !== null) {
        existingChildren.set(existingChild.key, existingChild);
      } else {
        existingChildren.set(existingChild.index, existingChild);
      }

      existingChild = existingChild.sibling;
    }

    return existingChildren;
  }

  function useFiber(fiber, pendingProps) {
    // We currently set sibling to null and index to 0 here because it is easy
    // to forget to do before returning it. E.g. for the single child case.
    var clone = createWorkInProgress(fiber, pendingProps);
    clone.index = 0;
    clone.sibling = null;
    return clone;
  }

  function placeChild(newFiber, lastPlacedIndex, newIndex) {
    newFiber.index = newIndex;

    if (!shouldTrackSideEffects) {
      // Noop.
      return lastPlacedIndex;
    }

    var current = newFiber.alternate;

    if (current !== null) {
      var oldIndex = current.index;

      if (oldIndex < lastPlacedIndex) {
        // This is a move.
        newFiber.flags = Placement;
        return lastPlacedIndex;
      } else {
        // This item can stay in place.
        return oldIndex;
      }
    } else {
      // This is an insertion.
      newFiber.flags = Placement;
      return lastPlacedIndex;
    }
  }

  function placeSingleChild(newFiber) {
    // This is simpler for the single child case. We only need to do a
    // placement for inserting new children.
    if (shouldTrackSideEffects && newFiber.alternate === null) {
      newFiber.flags = Placement;
    }

    return newFiber;
  }

  function updateTextNode(returnFiber, current, textContent, lanes) {
    if (current === null || current.tag !== HostText) {
      // Insert
      var created = createFiberFromText(textContent, returnFiber.mode, lanes);
      created.return = returnFiber;
      return created;
    } else {
      // Update
      var existing = useFiber(current, textContent);
      existing.return = returnFiber;
      return existing;
    }
  }

  function updateElement(returnFiber, current, element, lanes) {
    if (current !== null) {
      if (current.elementType === element.type || ( // Keep this check inline so it only runs on the false path:
       isCompatibleFamilyForHotReloading(current, element) )) {
        // Move based on index
        var existing = useFiber(current, element.props);
        existing.ref = coerceRef(returnFiber, current, element);
        existing.return = returnFiber;

        {
          existing._debugSource = element._source;
          existing._debugOwner = element._owner;
        }

        return existing;
      }
    } // Insert


    var created = createFiberFromElement(element, returnFiber.mode, lanes);
    created.ref = coerceRef(returnFiber, current, element);
    created.return = returnFiber;
    return created;
  }

  function updatePortal(returnFiber, current, portal, lanes) {
    if (current === null || current.tag !== HostPortal || current.stateNode.containerInfo !== portal.containerInfo || current.stateNode.implementation !== portal.implementation) {
      // Insert
      var created = createFiberFromPortal(portal, returnFiber.mode, lanes);
      created.return = returnFiber;
      return created;
    } else {
      // Update
      var existing = useFiber(current, portal.children || []);
      existing.return = returnFiber;
      return existing;
    }
  }

  function updateFragment(returnFiber, current, fragment, lanes, key) {
    if (current === null || current.tag !== Fragment) {
      // Insert
      var created = createFiberFromFragment(fragment, returnFiber.mode, lanes, key);
      created.return = returnFiber;
      return created;
    } else {
      // Update
      var existing = useFiber(current, fragment);
      existing.return = returnFiber;
      return existing;
    }
  }

  function createChild(returnFiber, newChild, lanes) {
    if (typeof newChild === 'string' || typeof newChild === 'number') {
      // Text nodes don't have keys. If the previous node is implicitly keyed
      // we can continue to replace it without aborting even if it is not a text
      // node.
      var created = createFiberFromText('' + newChild, returnFiber.mode, lanes);
      created.return = returnFiber;
      return created;
    }

    if (typeof newChild === 'object' && newChild !== null) {
      switch (newChild.$$typeof) {
        case REACT_ELEMENT_TYPE:
          {
            var _created = createFiberFromElement(newChild, returnFiber.mode, lanes);

            _created.ref = coerceRef(returnFiber, null, newChild);
            _created.return = returnFiber;
            return _created;
          }

        case REACT_PORTAL_TYPE:
          {
            var _created2 = createFiberFromPortal(newChild, returnFiber.mode, lanes);

            _created2.return = returnFiber;
            return _created2;
          }
      }

      if (isArray$1(newChild) || getIteratorFn(newChild)) {
        var _created3 = createFiberFromFragment(newChild, returnFiber.mode, lanes, null);

        _created3.return = returnFiber;
        return _created3;
      }

      throwOnInvalidObjectType(returnFiber, newChild);
    }

    {
      if (typeof newChild === 'function') {
        warnOnFunctionType(returnFiber);
      }
    }

    return null;
  }

  function updateSlot(returnFiber, oldFiber, newChild, lanes) {
    // Update the fiber if the keys match, otherwise return null.
    var key = oldFiber !== null ? oldFiber.key : null;

    if (typeof newChild === 'string' || typeof newChild === 'number') {
      // Text nodes don't have keys. If the previous node is implicitly keyed
      // we can continue to replace it without aborting even if it is not a text
      // node.
      if (key !== null) {
        return null;
      }

      return updateTextNode(returnFiber, oldFiber, '' + newChild, lanes);
    }

    if (typeof newChild === 'object' && newChild !== null) {
      switch (newChild.$$typeof) {
        case REACT_ELEMENT_TYPE:
          {
            if (newChild.key === key) {
              if (newChild.type === REACT_FRAGMENT_TYPE) {
                return updateFragment(returnFiber, oldFiber, newChild.props.children, lanes, key);
              }

              return updateElement(returnFiber, oldFiber, newChild, lanes);
            } else {
              return null;
            }
          }

        case REACT_PORTAL_TYPE:
          {
            if (newChild.key === key) {
              return updatePortal(returnFiber, oldFiber, newChild, lanes);
            } else {
              return null;
            }
          }
      }

      if (isArray$1(newChild) || getIteratorFn(newChild)) {
        if (key !== null) {
          return null;
        }

        return updateFragment(returnFiber, oldFiber, newChild, lanes, null);
      }

      throwOnInvalidObjectType(returnFiber, newChild);
    }

    {
      if (typeof newChild === 'function') {
        warnOnFunctionType(returnFiber);
      }
    }

    return null;
  }

  function updateFromMap(existingChildren, returnFiber, newIdx, newChild, lanes) {
    if (typeof newChild === 'string' || typeof newChild === 'number') {
      // Text nodes don't have keys, so we neither have to check the old nor
      // new node for the key. If both are text nodes, they match.
      var matchedFiber = existingChildren.get(newIdx) || null;
      return updateTextNode(returnFiber, matchedFiber, '' + newChild, lanes);
    }

    if (typeof newChild === 'object' && newChild !== null) {
      switch (newChild.$$typeof) {
        case REACT_ELEMENT_TYPE:
          {
            var _matchedFiber = existingChildren.get(newChild.key === null ? newIdx : newChild.key) || null;

            if (newChild.type === REACT_FRAGMENT_TYPE) {
              return updateFragment(returnFiber, _matchedFiber, newChild.props.children, lanes, newChild.key);
            }

            return updateElement(returnFiber, _matchedFiber, newChild, lanes);
          }

        case REACT_PORTAL_TYPE:
          {
            var _matchedFiber2 = existingChildren.get(newChild.key === null ? newIdx : newChild.key) || null;

            return updatePortal(returnFiber, _matchedFiber2, newChild, lanes);
          }

      }

      if (isArray$1(newChild) || getIteratorFn(newChild)) {
        var _matchedFiber3 = existingChildren.get(newIdx) || null;

        return updateFragment(returnFiber, _matchedFiber3, newChild, lanes, null);
      }

      throwOnInvalidObjectType(returnFiber, newChild);
    }

    {
      if (typeof newChild === 'function') {
        warnOnFunctionType(returnFiber);
      }
    }

    return null;
  }
  /**
   * Warns if there is a duplicate or missing key
   */


  function warnOnInvalidKey(child, knownKeys, returnFiber) {
    {
      if (typeof child !== 'object' || child === null) {
        return knownKeys;
      }

      switch (child.$$typeof) {
        case REACT_ELEMENT_TYPE:
        case REACT_PORTAL_TYPE:
          warnForMissingKey(child, returnFiber);
          var key = child.key;

          if (typeof key !== 'string') {
            break;
          }

          if (knownKeys === null) {
            knownKeys = new Set();
            knownKeys.add(key);
            break;
          }

          if (!knownKeys.has(key)) {
            knownKeys.add(key);
            break;
          }

          error('Encountered two children with the same key, `%s`. ' + 'Keys should be unique so that components maintain their identity ' + 'across updates. Non-unique keys may cause children to be ' + 'duplicated and/or omitted — the behavior is unsupported and ' + 'could change in a future version.', key);

          break;
      }
    }

    return knownKeys;
  }

  function reconcileChildrenArray(returnFiber, currentFirstChild, newChildren, lanes) {
    // This algorithm can't optimize by searching from both ends since we
    // don't have backpointers on fibers. I'm trying to see how far we can get
    // with that model. If it ends up not being worth the tradeoffs, we can
    // add it later.
    // Even with a two ended optimization, we'd want to optimize for the case
    // where there are few changes and brute force the comparison instead of
    // going for the Map. It'd like to explore hitting that path first in
    // forward-only mode and only go for the Map once we notice that we need
    // lots of look ahead. This doesn't handle reversal as well as two ended
    // search but that's unusual. Besides, for the two ended optimization to
    // work on Iterables, we'd need to copy the whole set.
    // In this first iteration, we'll just live with hitting the bad case
    // (adding everything to a Map) in for every insert/move.
    // If you change this code, also update reconcileChildrenIterator() which
    // uses the same algorithm.
    {
      // First, validate keys.
      var knownKeys = null;

      for (var i = 0; i < newChildren.length; i++) {
        var child = newChildren[i];
        knownKeys = warnOnInvalidKey(child, knownKeys, returnFiber);
      }
    }

    var resultingFirstChild = null;
    var previousNewFiber = null;
    var oldFiber = currentFirstChild;
    var lastPlacedIndex = 0;
    var newIdx = 0;
    var nextOldFiber = null;

    for (; oldFiber !== null && newIdx < newChildren.length; newIdx++) {
      if (oldFiber.index > newIdx) {
        nextOldFiber = oldFiber;
        oldFiber = null;
      } else {
        nextOldFiber = oldFiber.sibling;
      }

      var newFiber = updateSlot(returnFiber, oldFiber, newChildren[newIdx], lanes);

      if (newFiber === null) {
        // TODO: This breaks on empty slots like null children. That's
        // unfortunate because it triggers the slow path all the time. We need
        // a better way to communicate whether this was a miss or null,
        // boolean, undefined, etc.
        if (oldFiber === null) {
          oldFiber = nextOldFiber;
        }

        break;
      }

      if (shouldTrackSideEffects) {
        if (oldFiber && newFiber.alternate === null) {
          // We matched the slot, but we didn't reuse the existing fiber, so we
          // need to delete the existing child.
          deleteChild(returnFiber, oldFiber);
        }
      }

      lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);

      if (previousNewFiber === null) {
        // TODO: Move out of the loop. This only happens for the first run.
        resultingFirstChild = newFiber;
      } else {
        // TODO: Defer siblings if we're not at the right index for this slot.
        // I.e. if we had null values before, then we want to defer this
        // for each null value. However, we also don't want to call updateSlot
        // with the previous one.
        previousNewFiber.sibling = newFiber;
      }

      previousNewFiber = newFiber;
      oldFiber = nextOldFiber;
    }

    if (newIdx === newChildren.length) {
      // We've reached the end of the new children. We can delete the rest.
      deleteRemainingChildren(returnFiber, oldFiber);
      return resultingFirstChild;
    }

    if (oldFiber === null) {
      // If we don't have any more existing children we can choose a fast path
      // since the rest will all be insertions.
      for (; newIdx < newChildren.length; newIdx++) {
        var _newFiber = createChild(returnFiber, newChildren[newIdx], lanes);

        if (_newFiber === null) {
          continue;
        }

        lastPlacedIndex = placeChild(_newFiber, lastPlacedIndex, newIdx);

        if (previousNewFiber === null) {
          // TODO: Move out of the loop. This only happens for the first run.
          resultingFirstChild = _newFiber;
        } else {
          previousNewFiber.sibling = _newFiber;
        }

        previousNewFiber = _newFiber;
      }

      return resultingFirstChild;
    } // Add all children to a key map for quick lookups.


    var existingChildren = mapRemainingChildren(returnFiber, oldFiber); // Keep scanning and use the map to restore deleted items as moves.

    for (; newIdx < newChildren.length; newIdx++) {
      var _newFiber2 = updateFromMap(existingChildren, returnFiber, newIdx, newChildren[newIdx], lanes);

      if (_newFiber2 !== null) {
        if (shouldTrackSideEffects) {
          if (_newFiber2.alternate !== null) {
            // The new fiber is a work in progress, but if there exists a
            // current, that means that we reused the fiber. We need to delete
            // it from the child list so that we don't add it to the deletion
            // list.
            existingChildren.delete(_newFiber2.key === null ? newIdx : _newFiber2.key);
          }
        }

        lastPlacedIndex = placeChild(_newFiber2, lastPlacedIndex, newIdx);

        if (previousNewFiber === null) {
          resultingFirstChild = _newFiber2;
        } else {
          previousNewFiber.sibling = _newFiber2;
        }

        previousNewFiber = _newFiber2;
      }
    }

    if (shouldTrackSideEffects) {
      // Any existing children that weren't consumed above were deleted. We need
      // to add them to the deletion list.
      existingChildren.forEach(function (child) {
        return deleteChild(returnFiber, child);
      });
    }

    return resultingFirstChild;
  }

  function reconcileChildrenIterator(returnFiber, currentFirstChild, newChildrenIterable, lanes) {
    // This is the same implementation as reconcileChildrenArray(),
    // but using the iterator instead.
    var iteratorFn = getIteratorFn(newChildrenIterable);

    if (!(typeof iteratorFn === 'function')) {
      {
        throw Error( "An object is not an iterable. This error is likely caused by a bug in React. Please file an issue." );
      }
    }

    {
      // We don't support rendering Generators because it's a mutation.
      // See https://github.com/facebook/react/issues/12995
      if (typeof Symbol === 'function' && // $FlowFixMe Flow doesn't know about toStringTag
      newChildrenIterable[Symbol.toStringTag] === 'Generator') {
        if (!didWarnAboutGenerators) {
          error('Using Generators as children is unsupported and will likely yield ' + 'unexpected results because enumerating a generator mutates it. ' + 'You may convert it to an array with `Array.from()` or the ' + '`[...spread]` operator before rendering. Keep in mind ' + 'you might need to polyfill these features for older browsers.');
        }

        didWarnAboutGenerators = true;
      } // Warn about using Maps as children


      if (newChildrenIterable.entries === iteratorFn) {
        if (!didWarnAboutMaps) {
          error('Using Maps as children is not supported. ' + 'Use an array of keyed ReactElements instead.');
        }

        didWarnAboutMaps = true;
      } // First, validate keys.
      // We'll get a different iterator later for the main pass.


      var _newChildren = iteratorFn.call(newChildrenIterable);

      if (_newChildren) {
        var knownKeys = null;

        var _step = _newChildren.next();

        for (; !_step.done; _step = _newChildren.next()) {
          var child = _step.value;
          knownKeys = warnOnInvalidKey(child, knownKeys, returnFiber);
        }
      }
    }

    var newChildren = iteratorFn.call(newChildrenIterable);

    if (!(newChildren != null)) {
      {
        throw Error( "An iterable object provided no iterator." );
      }
    }

    var resultingFirstChild = null;
    var previousNewFiber = null;
    var oldFiber = currentFirstChild;
    var lastPlacedIndex = 0;
    var newIdx = 0;
    var nextOldFiber = null;
    var step = newChildren.next();

    for (; oldFiber !== null && !step.done; newIdx++, step = newChildren.next()) {
      if (oldFiber.index > newIdx) {
        nextOldFiber = oldFiber;
        oldFiber = null;
      } else {
        nextOldFiber = oldFiber.sibling;
      }

      var newFiber = updateSlot(returnFiber, oldFiber, step.value, lanes);

      if (newFiber === null) {
        // TODO: This breaks on empty slots like null children. That's
        // unfortunate because it triggers the slow path all the time. We need
        // a better way to communicate whether this was a miss or null,
        // boolean, undefined, etc.
        if (oldFiber === null) {
          oldFiber = nextOldFiber;
        }

        break;
      }

      if (shouldTrackSideEffects) {
        if (oldFiber && newFiber.alternate === null) {
          // We matched the slot, but we didn't reuse the existing fiber, so we
          // need to delete the existing child.
          deleteChild(returnFiber, oldFiber);
        }
      }

      lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);

      if (previousNewFiber === null) {
        // TODO: Move out of the loop. This only happens for the first run.
        resultingFirstChild = newFiber;
      } else {
        // TODO: Defer siblings if we're not at the right index for this slot.
        // I.e. if we had null values before, then we want to defer this
        // for each null value. However, we also don't want to call updateSlot
        // with the previous one.
        previousNewFiber.sibling = newFiber;
      }

      previousNewFiber = newFiber;
      oldFiber = nextOldFiber;
    }

    if (step.done) {
      // We've reached the end of the new children. We can delete the rest.
      deleteRemainingChildren(returnFiber, oldFiber);
      return resultingFirstChild;
    }

    if (oldFiber === null) {
      // If we don't have any more existing children we can choose a fast path
      // since the rest will all be insertions.
      for (; !step.done; newIdx++, step = newChildren.next()) {
        var _newFiber3 = createChild(returnFiber, step.value, lanes);

        if (_newFiber3 === null) {
          continue;
        }

        lastPlacedIndex = placeChild(_newFiber3, lastPlacedIndex, newIdx);

        if (previousNewFiber === null) {
          // TODO: Move out of the loop. This only happens for the first run.
          resultingFirstChild = _newFiber3;
        } else {
          previousNewFiber.sibling = _newFiber3;
        }

        previousNewFiber = _newFiber3;
      }

      return resultingFirstChild;
    } // Add all children to a key map for quick lookups.


    var existingChildren = mapRemainingChildren(returnFiber, oldFiber); // Keep scanning and use the map to restore deleted items as moves.

    for (; !step.done; newIdx++, step = newChildren.next()) {
      var _newFiber4 = updateFromMap(existingChildren, returnFiber, newIdx, step.value, lanes);

      if (_newFiber4 !== null) {
        if (shouldTrackSideEffects) {
          if (_newFiber4.alternate !== null) {
            // The new fiber is a work in progress, but if there exists a
            // current, that means that we reused the fiber. We need to delete
            // it from the child list so that we don't add it to the deletion
            // list.
            existingChildren.delete(_newFiber4.key === null ? newIdx : _newFiber4.key);
          }
        }

        lastPlacedIndex = placeChild(_newFiber4, lastPlacedIndex, newIdx);

        if (previousNewFiber === null) {
          resultingFirstChild = _newFiber4;
        } else {
          previousNewFiber.sibling = _newFiber4;
        }

        previousNewFiber = _newFiber4;
      }
    }

    if (shouldTrackSideEffects) {
      // Any existing children that weren't consumed above were deleted. We need
      // to add them to the deletion list.
      existingChildren.forEach(function (child) {
        return deleteChild(returnFiber, child);
      });
    }

    return resultingFirstChild;
  }

  function reconcileSingleTextNode(returnFiber, currentFirstChild, textContent, lanes) {
    // There's no need to check for keys on text nodes since we don't have a
    // way to define them.
    if (currentFirstChild !== null && currentFirstChild.tag === HostText) {
      // We already have an existing node so let's just update it and delete
      // the rest.
      deleteRemainingChildren(returnFiber, currentFirstChild.sibling);
      var existing = useFiber(currentFirstChild, textContent);
      existing.return = returnFiber;
      return existing;
    } // The existing first child is not a text node so we need to create one
    // and delete the existing ones.


    deleteRemainingChildren(returnFiber, currentFirstChild);
    var created = createFiberFromText(textContent, returnFiber.mode, lanes);
    created.return = returnFiber;
    return created;
  }

  function reconcileSingleElement(returnFiber, currentFirstChild, element, lanes) {
    var key = element.key;
    var child = currentFirstChild;

    while (child !== null) {
      // TODO: If key === null and child.key === null, then this only applies to
      // the first item in the list.
      if (child.key === key) {
        switch (child.tag) {
          case Fragment:
            {
              if (element.type === REACT_FRAGMENT_TYPE) {
                deleteRemainingChildren(returnFiber, child.sibling);
                var existing = useFiber(child, element.props.children);
                existing.return = returnFiber;

                {
                  existing._debugSource = element._source;
                  existing._debugOwner = element._owner;
                }

                return existing;
              }

              break;
            }

          case Block:

          // We intentionally fallthrough here if enableBlocksAPI is not on.
          // eslint-disable-next-lined no-fallthrough

          default:
            {
              if (child.elementType === element.type || ( // Keep this check inline so it only runs on the false path:
               isCompatibleFamilyForHotReloading(child, element) )) {
                deleteRemainingChildren(returnFiber, child.sibling);

                var _existing3 = useFiber(child, element.props);

                _existing3.ref = coerceRef(returnFiber, child, element);
                _existing3.return = returnFiber;

                {
                  _existing3._debugSource = element._source;
                  _existing3._debugOwner = element._owner;
                }

                return _existing3;
              }

              break;
            }
        } // Didn't match.


        deleteRemainingChildren(returnFiber, child);
        break;
      } else {
        deleteChild(returnFiber, child);
      }

      child = child.sibling;
    }

    if (element.type === REACT_FRAGMENT_TYPE) {
      var created = createFiberFromFragment(element.props.children, returnFiber.mode, lanes, element.key);
      created.return = returnFiber;
      return created;
    } else {
      var _created4 = createFiberFromElement(element, returnFiber.mode, lanes);

      _created4.ref = coerceRef(returnFiber, currentFirstChild, element);
      _created4.return = returnFiber;
      return _created4;
    }
  }

  function reconcileSinglePortal(returnFiber, currentFirstChild, portal, lanes) {
    var key = portal.key;
    var child = currentFirstChild;

    while (child !== null) {
      // TODO: If key === null and child.key === null, then this only applies to
      // the first item in the list.
      if (child.key === key) {
        if (child.tag === HostPortal && child.stateNode.containerInfo === portal.containerInfo && child.stateNode.implementation === portal.implementation) {
          deleteRemainingChildren(returnFiber, child.sibling);
          var existing = useFiber(child, portal.children || []);
          existing.return = returnFiber;
          return existing;
        } else {
          deleteRemainingChildren(returnFiber, child);
          break;
        }
      } else {
        deleteChild(returnFiber, child);
      }

      child = child.sibling;
    }

    var created = createFiberFromPortal(portal, returnFiber.mode, lanes);
    created.return = returnFiber;
    return created;
  } // This API will tag the children with the side-effect of the reconciliation
  // itself. They will be added to the side-effect list as we pass through the
  // children and the parent.


  function reconcileChildFibers(returnFiber, currentFirstChild, newChild, lanes) {
    // This function is not recursive.
    // If the top level item is an array, we treat it as a set of children,
    // not as a fragment. Nested arrays on the other hand will be treated as
    // fragment nodes. Recursion happens at the normal flow.
    // Handle top level unkeyed fragments as if they were arrays.
    // This leads to an ambiguity between <>{[...]}</> and <>...</>.
    // We treat the ambiguous cases above the same.
    var isUnkeyedTopLevelFragment = typeof newChild === 'object' && newChild !== null && newChild.type === REACT_FRAGMENT_TYPE && newChild.key === null;

    if (isUnkeyedTopLevelFragment) {
      newChild = newChild.props.children;
    } // Handle object types


    var isObject = typeof newChild === 'object' && newChild !== null;

    if (isObject) {
      switch (newChild.$$typeof) {
        case REACT_ELEMENT_TYPE:
          return placeSingleChild(reconcileSingleElement(returnFiber, currentFirstChild, newChild, lanes));

        case REACT_PORTAL_TYPE:
          return placeSingleChild(reconcileSinglePortal(returnFiber, currentFirstChild, newChild, lanes));

      }
    }

    if (typeof newChild === 'string' || typeof newChild === 'number') {
      return placeSingleChild(reconcileSingleTextNode(returnFiber, currentFirstChild, '' + newChild, lanes));
    }

    if (isArray$1(newChild)) {
      return reconcileChildrenArray(returnFiber, currentFirstChild, newChild, lanes);
    }

    if (getIteratorFn(newChild)) {
      return reconcileChildrenIterator(returnFiber, currentFirstChild, newChild, lanes);
    }

    if (isObject) {
      throwOnInvalidObjectType(returnFiber, newChild);
    }

    {
      if (typeof newChild === 'function') {
        warnOnFunctionType(returnFiber);
      }
    }

    if (typeof newChild === 'undefined' && !isUnkeyedTopLevelFragment) {
      // If the new child is undefined, and the return fiber is a composite
      // component, throw an error. If Fiber return types are disabled,
      // we already threw above.
      switch (returnFiber.tag) {
        case ClassComponent:
          {
            {
              var instance = returnFiber.stateNode;

              if (instance.render._isMockFunction) {
                // We allow auto-mocks to proceed as if they're returning null.
                break;
              }
            }
          }
        // Intentionally fall through to the next case, which handles both
        // functions and classes
        // eslint-disable-next-lined no-fallthrough

        case Block:
        case FunctionComponent:
        case ForwardRef:
        case SimpleMemoComponent:
          {
            {
              {
                throw Error( (getComponentName(returnFiber.type) || 'Component') + "(...): Nothing was returned from render. This usually means a return statement is missing. Or, to render nothing, return null." );
              }
            }
          }
      }
    } // Remaining cases are all treated as empty.


    return deleteRemainingChildren(returnFiber, currentFirstChild);
  }

  return reconcileChildFibers;
}

var reconcileChildFibers = ChildReconciler(true);
var mountChildFibers = ChildReconciler(false);
function cloneChildFibers(current, workInProgress) {
  if (!(current === null || workInProgress.child === current.child)) {
    {
      throw Error( "Resuming work not yet implemented." );
    }
  }

  if (workInProgress.child === null) {
    return;
  }

  var currentChild = workInProgress.child;
  var newChild = createWorkInProgress(currentChild, currentChild.pendingProps);
  workInProgress.child = newChild;
  newChild.return = workInProgress;

  while (currentChild.sibling !== null) {
    currentChild = currentChild.sibling;
    newChild = newChild.sibling = createWorkInProgress(currentChild, currentChild.pendingProps);
    newChild.return = workInProgress;
  }

  newChild.sibling = null;
} // Reset a workInProgress child set to prepare it for a second pass.

function resetChildFibers(workInProgress, lanes) {
  var child = workInProgress.child;

  while (child !== null) {
    resetWorkInProgress(child, lanes);
    child = child.sibling;
  }
}

var NO_CONTEXT = {};
var contextStackCursor$1 = createCursor(NO_CONTEXT);
var contextFiberStackCursor = createCursor(NO_CONTEXT);
var rootInstanceStackCursor = createCursor(NO_CONTEXT);

function requiredContext(c) {
  if (!(c !== NO_CONTEXT)) {
    {
      throw Error( "Expected host context to exist. This error is likely caused by a bug in React. Please file an issue." );
    }
  }

  return c;
}

function getRootHostContainer() {
  var rootInstance = requiredContext(rootInstanceStackCursor.current);
  return rootInstance;
}

function pushHostContainer(fiber, nextRootInstance) {
  // Push current root instance onto the stack;
  // This allows us to reset root when portals are popped.
  push(rootInstanceStackCursor, nextRootInstance, fiber); // Track the context and the Fiber that provided it.
  // This enables us to pop only Fibers that provide unique contexts.

  push(contextFiberStackCursor, fiber, fiber); // Finally, we need to push the host context to the stack.
  // However, we can't just call getRootHostContext() and push it because
  // we'd have a different number of entries on the stack depending on
  // whether getRootHostContext() throws somewhere in renderer code or not.
  // So we push an empty value first. This lets us safely unwind on errors.

  push(contextStackCursor$1, NO_CONTEXT, fiber);
  var nextRootContext = getRootHostContext(nextRootInstance); // Now that we know this function doesn't throw, replace it.

  pop(contextStackCursor$1, fiber);
  push(contextStackCursor$1, nextRootContext, fiber);
}

function popHostContainer(fiber) {
  pop(contextStackCursor$1, fiber);
  pop(contextFiberStackCursor, fiber);
  pop(rootInstanceStackCursor, fiber);
}

function getHostContext() {
  var context = requiredContext(contextStackCursor$1.current);
  return context;
}

function pushHostContext(fiber) {
  var rootInstance = requiredContext(rootInstanceStackCursor.current);
  var context = requiredContext(contextStackCursor$1.current);
  var nextContext = getChildHostContext(context, fiber.type); // Don't push this Fiber's context unless it's unique.

  if (context === nextContext) {
    return;
  } // Track the context and the Fiber that provided it.
  // This enables us to pop only Fibers that provide unique contexts.


  push(contextFiberStackCursor, fiber, fiber);
  push(contextStackCursor$1, nextContext, fiber);
}

function popHostContext(fiber) {
  // Do not pop unless this Fiber provided the current context.
  // pushHostContext() only pushes Fibers that provide unique contexts.
  if (contextFiberStackCursor.current !== fiber) {
    return;
  }

  pop(contextStackCursor$1, fiber);
  pop(contextFiberStackCursor, fiber);
}

var DefaultSuspenseContext = 0; // The Suspense Context is split into two parts. The lower bits is
// inherited deeply down the subtree. The upper bits only affect
// this immediate suspense boundary and gets reset each new
// boundary or suspense list.

var SubtreeSuspenseContextMask = 1; // Subtree Flags:
// InvisibleParentSuspenseContext indicates that one of our parent Suspense
// boundaries is not currently showing visible main content.
// Either because it is already showing a fallback or is not mounted at all.
// We can use this to determine if it is desirable to trigger a fallback at
// the parent. If not, then we might need to trigger undesirable boundaries
// and/or suspend the commit to avoid hiding the parent content.

var InvisibleParentSuspenseContext = 1; // Shallow Flags:
// ForceSuspenseFallback can be used by SuspenseList to force newly added
// items into their fallback state during one of the render passes.

var ForceSuspenseFallback = 2;
var suspenseStackCursor = createCursor(DefaultSuspenseContext);
function hasSuspenseContext(parentContext, flag) {
  return (parentContext & flag) !== 0;
}
function setDefaultShallowSuspenseContext(parentContext) {
  return parentContext & SubtreeSuspenseContextMask;
}
function setShallowSuspenseContext(parentContext, shallowContext) {
  return parentContext & SubtreeSuspenseContextMask | shallowContext;
}
function addSubtreeSuspenseContext(parentContext, subtreeContext) {
  return parentContext | subtreeContext;
}
function pushSuspenseContext(fiber, newContext) {
  push(suspenseStackCursor, newContext, fiber);
}
function popSuspenseContext(fiber) {
  pop(suspenseStackCursor, fiber);
}

function shouldCaptureSuspense(workInProgress, hasInvisibleParent) {
  // If it was the primary children that just suspended, capture and render the
  // fallback. Otherwise, don't capture and bubble to the next boundary.
  var nextState = workInProgress.memoizedState;

  if (nextState !== null) {
    if (nextState.dehydrated !== null) {
      // A dehydrated boundary always captures.
      return true;
    }

    return false;
  }

  var props = workInProgress.memoizedProps; // In order to capture, the Suspense component must have a fallback prop.

  if (props.fallback === undefined) {
    return false;
  } // Regular boundaries always capture.


  if (props.unstable_avoidThisFallback !== true) {
    return true;
  } // If it's a boundary we should avoid, then we prefer to bubble up to the
  // parent boundary if it is currently invisible.


  if (hasInvisibleParent) {
    return false;
  } // If the parent is not able to handle it, we must handle it.


  return true;
}
function findFirstSuspended(row) {
  var node = row;

  while (node !== null) {
    if (node.tag === SuspenseComponent) {
      var state = node.memoizedState;

      if (state !== null) {
        var dehydrated = state.dehydrated;

        if (dehydrated === null || isSuspenseInstancePending(dehydrated) || isSuspenseInstanceFallback(dehydrated)) {
          return node;
        }
      }
    } else if (node.tag === SuspenseListComponent && // revealOrder undefined can't be trusted because it don't
    // keep track of whether it suspended or not.
    node.memoizedProps.revealOrder !== undefined) {
      var didSuspend = (node.flags & DidCapture) !== NoFlags;

      if (didSuspend) {
        return node;
      }
    } else if (node.child !== null) {
      node.child.return = node;
      node = node.child;
      continue;
    }

    if (node === row) {
      return null;
    }

    while (node.sibling === null) {
      if (node.return === null || node.return === row) {
        return null;
      }

      node = node.return;
    }

    node.sibling.return = node.return;
    node = node.sibling;
  }

  return null;
}

var NoFlags$1 =
/*  */
0; // Represents whether effect should fire.

var HasEffect =
/* */
1; // Represents the phase in which the effect (not the clean-up) fires.

var Layout =
/*    */
2;
var Passive$1 =
/*   */
4;

// This may have been an insertion or a hydration.

var hydrationParentFiber = null;
var nextHydratableInstance = null;
var isHydrating = false;

function enterHydrationState(fiber) {

  var parentInstance = fiber.stateNode.containerInfo;
  nextHydratableInstance = getFirstHydratableChild(parentInstance);
  hydrationParentFiber = fiber;
  isHydrating = true;
  return true;
}

function deleteHydratableInstance(returnFiber, instance) {
  {
    switch (returnFiber.tag) {
      case HostRoot:
        didNotHydrateContainerInstance(returnFiber.stateNode.containerInfo, instance);
        break;

      case HostComponent:
        didNotHydrateInstance(returnFiber.type, returnFiber.memoizedProps, returnFiber.stateNode, instance);
        break;
    }
  }

  var childToDelete = createFiberFromHostInstanceForDeletion();
  childToDelete.stateNode = instance;
  childToDelete.return = returnFiber;
  childToDelete.flags = Deletion; // This might seem like it belongs on progressedFirstDeletion. However,
  // these children are not part of the reconciliation list of children.
  // Even if we abort and rereconcile the children, that will try to hydrate
  // again and the nodes are still in the host tree so these will be
  // recreated.

  if (returnFiber.lastEffect !== null) {
    returnFiber.lastEffect.nextEffect = childToDelete;
    returnFiber.lastEffect = childToDelete;
  } else {
    returnFiber.firstEffect = returnFiber.lastEffect = childToDelete;
  }
}

function insertNonHydratedInstance(returnFiber, fiber) {
  fiber.flags = fiber.flags & ~Hydrating | Placement;

  {
    switch (returnFiber.tag) {
      case HostRoot:
        {
          var parentContainer = returnFiber.stateNode.containerInfo;

          switch (fiber.tag) {
            case HostComponent:
              var type = fiber.type;
              var props = fiber.pendingProps;
              didNotFindHydratableContainerInstance(parentContainer, type);
              break;

            case HostText:
              var text = fiber.pendingProps;
              didNotFindHydratableContainerTextInstance(parentContainer, text);
              break;
          }

          break;
        }

      case HostComponent:
        {
          var parentType = returnFiber.type;
          var parentProps = returnFiber.memoizedProps;
          var parentInstance = returnFiber.stateNode;

          switch (fiber.tag) {
            case HostComponent:
              var _type = fiber.type;
              var _props = fiber.pendingProps;
              didNotFindHydratableInstance(parentType, parentProps, parentInstance, _type);
              break;

            case HostText:
              var _text = fiber.pendingProps;
              didNotFindHydratableTextInstance(parentType, parentProps, parentInstance, _text);
              break;

            case SuspenseComponent:
              didNotFindHydratableSuspenseInstance(parentType, parentProps);
              break;
          }

          break;
        }

      default:
        return;
    }
  }
}

function tryHydrate(fiber, nextInstance) {
  switch (fiber.tag) {
    case HostComponent:
      {
        var type = fiber.type;
        var props = fiber.pendingProps;
        var instance = canHydrateInstance(nextInstance, type);

        if (instance !== null) {
          fiber.stateNode = instance;
          return true;
        }

        return false;
      }

    case HostText:
      {
        var text = fiber.pendingProps;
        var textInstance = canHydrateTextInstance(nextInstance, text);

        if (textInstance !== null) {
          fiber.stateNode = textInstance;
          return true;
        }

        return false;
      }

    case SuspenseComponent:
      {

        return false;
      }

    default:
      return false;
  }
}

function tryToClaimNextHydratableInstance(fiber) {
  if (!isHydrating) {
    return;
  }

  var nextInstance = nextHydratableInstance;

  if (!nextInstance) {
    // Nothing to hydrate. Make it an insertion.
    insertNonHydratedInstance(hydrationParentFiber, fiber);
    isHydrating = false;
    hydrationParentFiber = fiber;
    return;
  }

  var firstAttemptedInstance = nextInstance;

  if (!tryHydrate(fiber, nextInstance)) {
    // If we can't hydrate this instance let's try the next one.
    // We use this as a heuristic. It's based on intuition and not data so it
    // might be flawed or unnecessary.
    nextInstance = getNextHydratableSibling(firstAttemptedInstance);

    if (!nextInstance || !tryHydrate(fiber, nextInstance)) {
      // Nothing to hydrate. Make it an insertion.
      insertNonHydratedInstance(hydrationParentFiber, fiber);
      isHydrating = false;
      hydrationParentFiber = fiber;
      return;
    } // We matched the next one, we'll now assume that the first one was
    // superfluous and we'll delete it. Since we can't eagerly delete it
    // we'll have to schedule a deletion. To do that, this node needs a dummy
    // fiber associated with it.


    deleteHydratableInstance(hydrationParentFiber, firstAttemptedInstance);
  }

  hydrationParentFiber = fiber;
  nextHydratableInstance = getFirstHydratableChild(nextInstance);
}

function prepareToHydrateHostInstance(fiber, rootContainerInstance, hostContext) {

  var instance = fiber.stateNode;
  var updatePayload = hydrateInstance(instance, fiber.type, fiber.memoizedProps, rootContainerInstance, hostContext, fiber); // TODO: Type this specific to this type of component.

  fiber.updateQueue = updatePayload; // If the update payload indicates that there is a change or if there
  // is a new ref we mark this as an update.

  if (updatePayload !== null) {
    return true;
  }

  return false;
}

function prepareToHydrateHostTextInstance(fiber) {

  var textInstance = fiber.stateNode;
  var textContent = fiber.memoizedProps;
  var shouldUpdate = hydrateTextInstance(textInstance, textContent, fiber);

  {
    if (shouldUpdate) {
      // We assume that prepareToHydrateHostTextInstance is called in a context where the
      // hydration parent is the parent host component of this host text.
      var returnFiber = hydrationParentFiber;

      if (returnFiber !== null) {
        switch (returnFiber.tag) {
          case HostRoot:
            {
              var parentContainer = returnFiber.stateNode.containerInfo;
              didNotMatchHydratedContainerTextInstance(parentContainer, textInstance, textContent);
              break;
            }

          case HostComponent:
            {
              var parentType = returnFiber.type;
              var parentProps = returnFiber.memoizedProps;
              var parentInstance = returnFiber.stateNode;
              didNotMatchHydratedTextInstance(parentType, parentProps, parentInstance, textInstance, textContent);
              break;
            }
        }
      }
    }
  }

  return shouldUpdate;
}

function skipPastDehydratedSuspenseInstance(fiber) {

  var suspenseState = fiber.memoizedState;
  var suspenseInstance = suspenseState !== null ? suspenseState.dehydrated : null;

  if (!suspenseInstance) {
    {
      throw Error( "Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue." );
    }
  }

  return getNextHydratableInstanceAfterSuspenseInstance(suspenseInstance);
}

function popToNextHostParent(fiber) {
  var parent = fiber.return;

  while (parent !== null && parent.tag !== HostComponent && parent.tag !== HostRoot && parent.tag !== SuspenseComponent) {
    parent = parent.return;
  }

  hydrationParentFiber = parent;
}

function popHydrationState(fiber) {

  if (fiber !== hydrationParentFiber) {
    // We're deeper than the current hydration context, inside an inserted
    // tree.
    return false;
  }

  if (!isHydrating) {
    // If we're not currently hydrating but we're in a hydration context, then
    // we were an insertion and now need to pop up reenter hydration of our
    // siblings.
    popToNextHostParent(fiber);
    isHydrating = true;
    return false;
  }

  var type = fiber.type; // If we have any remaining hydratable nodes, we need to delete them now.
  // We only do this deeper than head and body since they tend to have random
  // other nodes in them. We also ignore components with pure text content in
  // side of them.
  // TODO: Better heuristic.

  if (fiber.tag !== HostComponent || type !== 'head' && type !== 'body' && !shouldSetTextContent(type, fiber.memoizedProps)) {
    var nextInstance = nextHydratableInstance;

    while (nextInstance) {
      deleteHydratableInstance(fiber, nextInstance);
      nextInstance = getNextHydratableSibling(nextInstance);
    }
  }

  popToNextHostParent(fiber);

  if (fiber.tag === SuspenseComponent) {
    nextHydratableInstance = skipPastDehydratedSuspenseInstance(fiber);
  } else {
    nextHydratableInstance = hydrationParentFiber ? getNextHydratableSibling(fiber.stateNode) : null;
  }

  return true;
}

function resetHydrationState() {

  hydrationParentFiber = null;
  nextHydratableInstance = null;
  isHydrating = false;
}

function getIsHydrating() {
  return isHydrating;
}

// and should be reset before starting a new render.
// This tracks which mutable sources need to be reset after a render.

var workInProgressSources = [];
var rendererSigil$1;

{
  // Used to detect multiple renderers using the same mutable source.
  rendererSigil$1 = {};
}

function markSourceAsDirty(mutableSource) {
  workInProgressSources.push(mutableSource);
}
function resetWorkInProgressVersions() {
  for (var i = 0; i < workInProgressSources.length; i++) {
    var mutableSource = workInProgressSources[i];

    {
      mutableSource._workInProgressVersionPrimary = null;
    }
  }

  workInProgressSources.length = 0;
}
function getWorkInProgressVersion(mutableSource) {
  {
    return mutableSource._workInProgressVersionPrimary;
  }
}
function setWorkInProgressVersion(mutableSource, version) {
  {
    mutableSource._workInProgressVersionPrimary = version;
  }

  workInProgressSources.push(mutableSource);
}
function warnAboutMultipleRenderersDEV(mutableSource) {
  {
    {
      if (mutableSource._currentPrimaryRenderer == null) {
        mutableSource._currentPrimaryRenderer = rendererSigil$1;
      } else if (mutableSource._currentPrimaryRenderer !== rendererSigil$1) {
        error('Detected multiple renderers concurrently rendering the ' + 'same mutable source. This is currently unsupported.');
      }
    }
  }
} // Eager reads the version of a mutable source and stores it on the root.

var ReactCurrentDispatcher$1 = ReactSharedInternals.ReactCurrentDispatcher,
    ReactCurrentBatchConfig$1 = ReactSharedInternals.ReactCurrentBatchConfig;
var didWarnAboutMismatchedHooksForComponent;
var didWarnAboutUseOpaqueIdentifier;

{
  didWarnAboutUseOpaqueIdentifier = {};
  didWarnAboutMismatchedHooksForComponent = new Set();
}

// These are set right before calling the component.
var renderLanes = NoLanes; // The work-in-progress fiber. I've named it differently to distinguish it from
// the work-in-progress hook.

var currentlyRenderingFiber$1 = null; // Hooks are stored as a linked list on the fiber's memoizedState field. The
// current hook list is the list that belongs to the current fiber. The
// work-in-progress hook list is a new list that will be added to the
// work-in-progress fiber.

var currentHook = null;
var workInProgressHook = null; // Whether an update was scheduled at any point during the render phase. This
// does not get reset if we do another render pass; only when we're completely
// finished evaluating this component. This is an optimization so we know
// whether we need to clear render phase updates after a throw.

var didScheduleRenderPhaseUpdate = false; // Where an update was scheduled only during the current render pass. This
// gets reset after each attempt.
// TODO: Maybe there's some way to consolidate this with
// `didScheduleRenderPhaseUpdate`. Or with `numberOfReRenders`.

var didScheduleRenderPhaseUpdateDuringThisPass = false;
var RE_RENDER_LIMIT = 25; // In DEV, this is the name of the currently executing primitive hook

var currentHookNameInDev = null; // In DEV, this list ensures that hooks are called in the same order between renders.
// The list stores the order of hooks used during the initial render (mount).
// Subsequent renders (updates) reference this list.

var hookTypesDev = null;
var hookTypesUpdateIndexDev = -1; // In DEV, this tracks whether currently rendering component needs to ignore
// the dependencies for Hooks that need them (e.g. useEffect or useMemo).
// When true, such Hooks will always be "remounted". Only used during hot reload.

var ignorePreviousDependencies = false;

function mountHookTypesDev() {
  {
    var hookName = currentHookNameInDev;

    if (hookTypesDev === null) {
      hookTypesDev = [hookName];
    } else {
      hookTypesDev.push(hookName);
    }
  }
}

function updateHookTypesDev() {
  {
    var hookName = currentHookNameInDev;

    if (hookTypesDev !== null) {
      hookTypesUpdateIndexDev++;

      if (hookTypesDev[hookTypesUpdateIndexDev] !== hookName) {
        warnOnHookMismatchInDev(hookName);
      }
    }
  }
}

function checkDepsAreArrayDev(deps) {
  {
    if (deps !== undefined && deps !== null && !Array.isArray(deps)) {
      // Verify deps, but only on mount to avoid extra checks.
      // It's unlikely their type would change as usually you define them inline.
      error('%s received a final argument that is not an array (instead, received `%s`). When ' + 'specified, the final argument must be an array.', currentHookNameInDev, typeof deps);
    }
  }
}

function warnOnHookMismatchInDev(currentHookName) {
  {
    var componentName = getComponentName(currentlyRenderingFiber$1.type);

    if (!didWarnAboutMismatchedHooksForComponent.has(componentName)) {
      didWarnAboutMismatchedHooksForComponent.add(componentName);

      if (hookTypesDev !== null) {
        var table = '';
        var secondColumnStart = 30;

        for (var i = 0; i <= hookTypesUpdateIndexDev; i++) {
          var oldHookName = hookTypesDev[i];
          var newHookName = i === hookTypesUpdateIndexDev ? currentHookName : oldHookName;
          var row = i + 1 + ". " + oldHookName; // Extra space so second column lines up
          // lol @ IE not supporting String#repeat

          while (row.length < secondColumnStart) {
            row += ' ';
          }

          row += newHookName + '\n';
          table += row;
        }

        error('React has detected a change in the order of Hooks called by %s. ' + 'This will lead to bugs and errors if not fixed. ' + 'For more information, read the Rules of Hooks: https://reactjs.org/link/rules-of-hooks\n\n' + '   Previous render            Next render\n' + '   ------------------------------------------------------\n' + '%s' + '   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n', componentName, table);
      }
    }
  }
}

function throwInvalidHookError() {
  {
    {
      throw Error( "Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem." );
    }
  }
}

function areHookInputsEqual(nextDeps, prevDeps) {
  {
    if (ignorePreviousDependencies) {
      // Only true when this component is being hot reloaded.
      return false;
    }
  }

  if (prevDeps === null) {
    {
      error('%s received a final argument during this render, but not during ' + 'the previous render. Even though the final argument is optional, ' + 'its type cannot change between renders.', currentHookNameInDev);
    }

    return false;
  }

  {
    // Don't bother comparing lengths in prod because these arrays should be
    // passed inline.
    if (nextDeps.length !== prevDeps.length) {
      error('The final argument passed to %s changed size between renders. The ' + 'order and size of this array must remain constant.\n\n' + 'Previous: %s\n' + 'Incoming: %s', currentHookNameInDev, "[" + prevDeps.join(', ') + "]", "[" + nextDeps.join(', ') + "]");
    }
  }

  for (var i = 0; i < prevDeps.length && i < nextDeps.length; i++) {
    if (objectIs(nextDeps[i], prevDeps[i])) {
      continue;
    }

    return false;
  }

  return true;
}

function renderWithHooks(current, workInProgress, Component, props, secondArg, nextRenderLanes) {
  renderLanes = nextRenderLanes;
  currentlyRenderingFiber$1 = workInProgress;

  {
    hookTypesDev = current !== null ? current._debugHookTypes : null;
    hookTypesUpdateIndexDev = -1; // Used for hot reloading:

    ignorePreviousDependencies = current !== null && current.type !== workInProgress.type;
  }

  workInProgress.memoizedState = null;
  workInProgress.updateQueue = null;
  workInProgress.lanes = NoLanes; // The following should have already been reset
  // currentHook = null;
  // workInProgressHook = null;
  // didScheduleRenderPhaseUpdate = false;
  // TODO Warn if no hooks are used at all during mount, then some are used during update.
  // Currently we will identify the update render as a mount because memoizedState === null.
  // This is tricky because it's valid for certain types of components (e.g. React.lazy)
  // Using memoizedState to differentiate between mount/update only works if at least one stateful hook is used.
  // Non-stateful hooks (e.g. context) don't get added to memoizedState,
  // so memoizedState would be null during updates and mounts.

  {
    if (current !== null && current.memoizedState !== null) {
      ReactCurrentDispatcher$1.current = HooksDispatcherOnUpdateInDEV;
    } else if (hookTypesDev !== null) {
      // This dispatcher handles an edge case where a component is updating,
      // but no stateful hooks have been used.
      // We want to match the production code behavior (which will use HooksDispatcherOnMount),
      // but with the extra DEV validation to ensure hooks ordering hasn't changed.
      // This dispatcher does that.
      ReactCurrentDispatcher$1.current = HooksDispatcherOnMountWithHookTypesInDEV;
    } else {
      ReactCurrentDispatcher$1.current = HooksDispatcherOnMountInDEV;
    }
  }

  var children = Component(props, secondArg); // Check if there was a render phase update

  if (didScheduleRenderPhaseUpdateDuringThisPass) {
    // Keep rendering in a loop for as long as render phase updates continue to
    // be scheduled. Use a counter to prevent infinite loops.
    var numberOfReRenders = 0;

    do {
      didScheduleRenderPhaseUpdateDuringThisPass = false;

      if (!(numberOfReRenders < RE_RENDER_LIMIT)) {
        {
          throw Error( "Too many re-renders. React limits the number of renders to prevent an infinite loop." );
        }
      }

      numberOfReRenders += 1;

      {
        // Even when hot reloading, allow dependencies to stabilize
        // after first render to prevent infinite render phase updates.
        ignorePreviousDependencies = false;
      } // Start over from the beginning of the list


      currentHook = null;
      workInProgressHook = null;
      workInProgress.updateQueue = null;

      {
        // Also validate hook order for cascading updates.
        hookTypesUpdateIndexDev = -1;
      }

      ReactCurrentDispatcher$1.current =  HooksDispatcherOnRerenderInDEV ;
      children = Component(props, secondArg);
    } while (didScheduleRenderPhaseUpdateDuringThisPass);
  } // We can assume the previous dispatcher is always this one, since we set it
  // at the beginning of the render phase and there's no re-entrancy.


  ReactCurrentDispatcher$1.current = ContextOnlyDispatcher;

  {
    workInProgress._debugHookTypes = hookTypesDev;
  } // This check uses currentHook so that it works the same in DEV and prod bundles.
  // hookTypesDev could catch more cases (e.g. context) but only in DEV bundles.


  var didRenderTooFewHooks = currentHook !== null && currentHook.next !== null;
  renderLanes = NoLanes;
  currentlyRenderingFiber$1 = null;
  currentHook = null;
  workInProgressHook = null;

  {
    currentHookNameInDev = null;
    hookTypesDev = null;
    hookTypesUpdateIndexDev = -1;
  }

  didScheduleRenderPhaseUpdate = false;

  if (!!didRenderTooFewHooks) {
    {
      throw Error( "Rendered fewer hooks than expected. This may be caused by an accidental early return statement." );
    }
  }

  return children;
}
function bailoutHooks(current, workInProgress, lanes) {
  workInProgress.updateQueue = current.updateQueue;
  workInProgress.flags &= ~(Passive | Update);
  current.lanes = removeLanes(current.lanes, lanes);
}
function resetHooksAfterThrow() {
  // We can assume the previous dispatcher is always this one, since we set it
  // at the beginning of the render phase and there's no re-entrancy.
  ReactCurrentDispatcher$1.current = ContextOnlyDispatcher;

  if (didScheduleRenderPhaseUpdate) {
    // There were render phase updates. These are only valid for this render
    // phase, which we are now aborting. Remove the updates from the queues so
    // they do not persist to the next render. Do not remove updates from hooks
    // that weren't processed.
    //
    // Only reset the updates from the queue if it has a clone. If it does
    // not have a clone, that means it wasn't processed, and the updates were
    // scheduled before we entered the render phase.
    var hook = currentlyRenderingFiber$1.memoizedState;

    while (hook !== null) {
      var queue = hook.queue;

      if (queue !== null) {
        queue.pending = null;
      }

      hook = hook.next;
    }

    didScheduleRenderPhaseUpdate = false;
  }

  renderLanes = NoLanes;
  currentlyRenderingFiber$1 = null;
  currentHook = null;
  workInProgressHook = null;

  {
    hookTypesDev = null;
    hookTypesUpdateIndexDev = -1;
    currentHookNameInDev = null;
    isUpdatingOpaqueValueInRenderPhase = false;
  }

  didScheduleRenderPhaseUpdateDuringThisPass = false;
}

function mountWorkInProgressHook() {
  var hook = {
    memoizedState: null,
    baseState: null,
    baseQueue: null,
    queue: null,
    next: null
  };

  if (workInProgressHook === null) {
    // This is the first hook in the list
    currentlyRenderingFiber$1.memoizedState = workInProgressHook = hook;
  } else {
    // Append to the end of the list
    workInProgressHook = workInProgressHook.next = hook;
  }

  return workInProgressHook;
}

function updateWorkInProgressHook() {
  // This function is used both for updates and for re-renders triggered by a
  // render phase update. It assumes there is either a current hook we can
  // clone, or a work-in-progress hook from a previous render pass that we can
  // use as a base. When we reach the end of the base list, we must switch to
  // the dispatcher used for mounts.
  var nextCurrentHook;

  if (currentHook === null) {
    var current = currentlyRenderingFiber$1.alternate;

    if (current !== null) {
      nextCurrentHook = current.memoizedState;
    } else {
      nextCurrentHook = null;
    }
  } else {
    nextCurrentHook = currentHook.next;
  }

  var nextWorkInProgressHook;

  if (workInProgressHook === null) {
    nextWorkInProgressHook = currentlyRenderingFiber$1.memoizedState;
  } else {
    nextWorkInProgressHook = workInProgressHook.next;
  }

  if (nextWorkInProgressHook !== null) {
    // There's already a work-in-progress. Reuse it.
    workInProgressHook = nextWorkInProgressHook;
    nextWorkInProgressHook = workInProgressHook.next;
    currentHook = nextCurrentHook;
  } else {
    // Clone from the current hook.
    if (!(nextCurrentHook !== null)) {
      {
        throw Error( "Rendered more hooks than during the previous render." );
      }
    }

    currentHook = nextCurrentHook;
    var newHook = {
      memoizedState: currentHook.memoizedState,
      baseState: currentHook.baseState,
      baseQueue: currentHook.baseQueue,
      queue: currentHook.queue,
      next: null
    };

    if (workInProgressHook === null) {
      // This is the first hook in the list.
      currentlyRenderingFiber$1.memoizedState = workInProgressHook = newHook;
    } else {
      // Append to the end of the list.
      workInProgressHook = workInProgressHook.next = newHook;
    }
  }

  return workInProgressHook;
}

function createFunctionComponentUpdateQueue() {
  return {
    lastEffect: null
  };
}

function basicStateReducer(state, action) {
  // $FlowFixMe: Flow doesn't like mixed types
  return typeof action === 'function' ? action(state) : action;
}

function mountReducer(reducer, initialArg, init) {
  var hook = mountWorkInProgressHook();
  var initialState;

  if (init !== undefined) {
    initialState = init(initialArg);
  } else {
    initialState = initialArg;
  }

  hook.memoizedState = hook.baseState = initialState;
  var queue = hook.queue = {
    pending: null,
    dispatch: null,
    lastRenderedReducer: reducer,
    lastRenderedState: initialState
  };
  var dispatch = queue.dispatch = dispatchAction.bind(null, currentlyRenderingFiber$1, queue);
  return [hook.memoizedState, dispatch];
}

function updateReducer(reducer, initialArg, init) {
  var hook = updateWorkInProgressHook();
  var queue = hook.queue;

  if (!(queue !== null)) {
    {
      throw Error( "Should have a queue. This is likely a bug in React. Please file an issue." );
    }
  }

  queue.lastRenderedReducer = reducer;
  var current = currentHook; // The last rebase update that is NOT part of the base state.

  var baseQueue = current.baseQueue; // The last pending update that hasn't been processed yet.

  var pendingQueue = queue.pending;

  if (pendingQueue !== null) {
    // We have new updates that haven't been processed yet.
    // We'll add them to the base queue.
    if (baseQueue !== null) {
      // Merge the pending queue and the base queue.
      var baseFirst = baseQueue.next;
      var pendingFirst = pendingQueue.next;
      baseQueue.next = pendingFirst;
      pendingQueue.next = baseFirst;
    }

    {
      if (current.baseQueue !== baseQueue) {
        // Internal invariant that should never happen, but feasibly could in
        // the future if we implement resuming, or some form of that.
        error('Internal error: Expected work-in-progress queue to be a clone. ' + 'This is a bug in React.');
      }
    }

    current.baseQueue = baseQueue = pendingQueue;
    queue.pending = null;
  }

  if (baseQueue !== null) {
    // We have a queue to process.
    var first = baseQueue.next;
    var newState = current.baseState;
    var newBaseState = null;
    var newBaseQueueFirst = null;
    var newBaseQueueLast = null;
    var update = first;

    do {
      var updateLane = update.lane;

      if (!isSubsetOfLanes(renderLanes, updateLane)) {
        // Priority is insufficient. Skip this update. If this is the first
        // skipped update, the previous update/state is the new base
        // update/state.
        var clone = {
          lane: updateLane,
          action: update.action,
          eagerReducer: update.eagerReducer,
          eagerState: update.eagerState,
          next: null
        };

        if (newBaseQueueLast === null) {
          newBaseQueueFirst = newBaseQueueLast = clone;
          newBaseState = newState;
        } else {
          newBaseQueueLast = newBaseQueueLast.next = clone;
        } // Update the remaining priority in the queue.
        // TODO: Don't need to accumulate this. Instead, we can remove
        // renderLanes from the original lanes.


        currentlyRenderingFiber$1.lanes = mergeLanes(currentlyRenderingFiber$1.lanes, updateLane);
        markSkippedUpdateLanes(updateLane);
      } else {
        // This update does have sufficient priority.
        if (newBaseQueueLast !== null) {
          var _clone = {
            // This update is going to be committed so we never want uncommit
            // it. Using NoLane works because 0 is a subset of all bitmasks, so
            // this will never be skipped by the check above.
            lane: NoLane,
            action: update.action,
            eagerReducer: update.eagerReducer,
            eagerState: update.eagerState,
            next: null
          };
          newBaseQueueLast = newBaseQueueLast.next = _clone;
        } // Process this update.


        if (update.eagerReducer === reducer) {
          // If this update was processed eagerly, and its reducer matches the
          // current reducer, we can use the eagerly computed state.
          newState = update.eagerState;
        } else {
          var action = update.action;
          newState = reducer(newState, action);
        }
      }

      update = update.next;
    } while (update !== null && update !== first);

    if (newBaseQueueLast === null) {
      newBaseState = newState;
    } else {
      newBaseQueueLast.next = newBaseQueueFirst;
    } // Mark that the fiber performed work, but only if the new state is
    // different from the current state.


    if (!objectIs(newState, hook.memoizedState)) {
      markWorkInProgressReceivedUpdate();
    }

    hook.memoizedState = newState;
    hook.baseState = newBaseState;
    hook.baseQueue = newBaseQueueLast;
    queue.lastRenderedState = newState;
  }

  var dispatch = queue.dispatch;
  return [hook.memoizedState, dispatch];
}

function rerenderReducer(reducer, initialArg, init) {
  var hook = updateWorkInProgressHook();
  var queue = hook.queue;

  if (!(queue !== null)) {
    {
      throw Error( "Should have a queue. This is likely a bug in React. Please file an issue." );
    }
  }

  queue.lastRenderedReducer = reducer; // This is a re-render. Apply the new render phase updates to the previous
  // work-in-progress hook.

  var dispatch = queue.dispatch;
  var lastRenderPhaseUpdate = queue.pending;
  var newState = hook.memoizedState;

  if (lastRenderPhaseUpdate !== null) {
    // The queue doesn't persist past this render pass.
    queue.pending = null;
    var firstRenderPhaseUpdate = lastRenderPhaseUpdate.next;
    var update = firstRenderPhaseUpdate;

    do {
      // Process this render phase update. We don't have to check the
      // priority because it will always be the same as the current
      // render's.
      var action = update.action;
      newState = reducer(newState, action);
      update = update.next;
    } while (update !== firstRenderPhaseUpdate); // Mark that the fiber performed work, but only if the new state is
    // different from the current state.


    if (!objectIs(newState, hook.memoizedState)) {
      markWorkInProgressReceivedUpdate();
    }

    hook.memoizedState = newState; // Don't persist the state accumulated from the render phase updates to
    // the base state unless the queue is empty.
    // TODO: Not sure if this is the desired semantics, but it's what we
    // do for gDSFP. I can't remember why.

    if (hook.baseQueue === null) {
      hook.baseState = newState;
    }

    queue.lastRenderedState = newState;
  }

  return [newState, dispatch];
}

function readFromUnsubcribedMutableSource(root, source, getSnapshot) {
  {
    warnAboutMultipleRenderersDEV(source);
  }

  var getVersion = source._getVersion;
  var version = getVersion(source._source); // Is it safe for this component to read from this source during the current render?

  var isSafeToReadFromSource = false; // Check the version first.
  // If this render has already been started with a specific version,
  // we can use it alone to determine if we can safely read from the source.

  var currentRenderVersion = getWorkInProgressVersion(source);

  if (currentRenderVersion !== null) {
    // It's safe to read if the store hasn't been mutated since the last time
    // we read something.
    isSafeToReadFromSource = currentRenderVersion === version;
  } else {
    // If there's no version, then this is the first time we've read from the
    // source during the current render pass, so we need to do a bit more work.
    // What we need to determine is if there are any hooks that already
    // subscribed to the source, and if so, whether there are any pending
    // mutations that haven't been synchronized yet.
    //
    // If there are no pending mutations, then `root.mutableReadLanes` will be
    // empty, and we know we can safely read.
    //
    // If there *are* pending mutations, we may still be able to safely read
    // if the currently rendering lanes are inclusive of the pending mutation
    // lanes, since that guarantees that the value we're about to read from
    // the source is consistent with the values that we read during the most
    // recent mutation.
    isSafeToReadFromSource = isSubsetOfLanes(renderLanes, root.mutableReadLanes);

    if (isSafeToReadFromSource) {
      // If it's safe to read from this source during the current render,
      // store the version in case other components read from it.
      // A changed version number will let those components know to throw and restart the render.
      setWorkInProgressVersion(source, version);
    }
  }

  if (isSafeToReadFromSource) {
    var snapshot = getSnapshot(source._source);

    {
      if (typeof snapshot === 'function') {
        error('Mutable source should not return a function as the snapshot value. ' + 'Functions may close over mutable values and cause tearing.');
      }
    }

    return snapshot;
  } else {
    // This handles the special case of a mutable source being shared between renderers.
    // In that case, if the source is mutated between the first and second renderer,
    // The second renderer don't know that it needs to reset the WIP version during unwind,
    // (because the hook only marks sources as dirty if it's written to their WIP version).
    // That would cause this tear check to throw again and eventually be visible to the user.
    // We can avoid this infinite loop by explicitly marking the source as dirty.
    //
    // This can lead to tearing in the first renderer when it resumes,
    // but there's nothing we can do about that (short of throwing here and refusing to continue the render).
    markSourceAsDirty(source);

    {
      {
        throw Error( "Cannot read from mutable source during the current render without tearing. This is a bug in React. Please file an issue." );
      }
    }
  }
}

function useMutableSource(hook, source, getSnapshot, subscribe) {
  var root = getWorkInProgressRoot();

  if (!(root !== null)) {
    {
      throw Error( "Expected a work-in-progress root. This is a bug in React. Please file an issue." );
    }
  }

  var getVersion = source._getVersion;
  var version = getVersion(source._source);
  var dispatcher = ReactCurrentDispatcher$1.current; // eslint-disable-next-line prefer-const

  var _dispatcher$useState = dispatcher.useState(function () {
    return readFromUnsubcribedMutableSource(root, source, getSnapshot);
  }),
      currentSnapshot = _dispatcher$useState[0],
      setSnapshot = _dispatcher$useState[1];

  var snapshot = currentSnapshot; // Grab a handle to the state hook as well.
  // We use it to clear the pending update queue if we have a new source.

  var stateHook = workInProgressHook;
  var memoizedState = hook.memoizedState;
  var refs = memoizedState.refs;
  var prevGetSnapshot = refs.getSnapshot;
  var prevSource = memoizedState.source;
  var prevSubscribe = memoizedState.subscribe;
  var fiber = currentlyRenderingFiber$1;
  hook.memoizedState = {
    refs: refs,
    source: source,
    subscribe: subscribe
  }; // Sync the values needed by our subscription handler after each commit.

  dispatcher.useEffect(function () {
    refs.getSnapshot = getSnapshot; // Normally the dispatch function for a state hook never changes,
    // but this hook recreates the queue in certain cases  to avoid updates from stale sources.
    // handleChange() below needs to reference the dispatch function without re-subscribing,
    // so we use a ref to ensure that it always has the latest version.

    refs.setSnapshot = setSnapshot; // Check for a possible change between when we last rendered now.

    var maybeNewVersion = getVersion(source._source);

    if (!objectIs(version, maybeNewVersion)) {
      var maybeNewSnapshot = getSnapshot(source._source);

      {
        if (typeof maybeNewSnapshot === 'function') {
          error('Mutable source should not return a function as the snapshot value. ' + 'Functions may close over mutable values and cause tearing.');
        }
      }

      if (!objectIs(snapshot, maybeNewSnapshot)) {
        setSnapshot(maybeNewSnapshot);
        var lane = requestUpdateLane(fiber);
        markRootMutableRead(root, lane);
      } // If the source mutated between render and now,
      // there may be state updates already scheduled from the old source.
      // Entangle the updates so that they render in the same batch.


      markRootEntangled(root, root.mutableReadLanes);
    }
  }, [getSnapshot, source, subscribe]); // If we got a new source or subscribe function, re-subscribe in a passive effect.

  dispatcher.useEffect(function () {
    var handleChange = function () {
      var latestGetSnapshot = refs.getSnapshot;
      var latestSetSnapshot = refs.setSnapshot;

      try {
        latestSetSnapshot(latestGetSnapshot(source._source)); // Record a pending mutable source update with the same expiration time.

        var lane = requestUpdateLane(fiber);
        markRootMutableRead(root, lane);
      } catch (error) {
        // A selector might throw after a source mutation.
        // e.g. it might try to read from a part of the store that no longer exists.
        // In this case we should still schedule an update with React.
        // Worst case the selector will throw again and then an error boundary will handle it.
        latestSetSnapshot(function () {
          throw error;
        });
      }
    };

    var unsubscribe = subscribe(source._source, handleChange);

    {
      if (typeof unsubscribe !== 'function') {
        error('Mutable source subscribe function must return an unsubscribe function.');
      }
    }

    return unsubscribe;
  }, [source, subscribe]); // If any of the inputs to useMutableSource change, reading is potentially unsafe.
  //
  // If either the source or the subscription have changed we can't can't trust the update queue.
  // Maybe the source changed in a way that the old subscription ignored but the new one depends on.
  //
  // If the getSnapshot function changed, we also shouldn't rely on the update queue.
  // It's possible that the underlying source was mutated between the when the last "change" event fired,
  // and when the current render (with the new getSnapshot function) is processed.
  //
  // In both cases, we need to throw away pending updates (since they are no longer relevant)
  // and treat reading from the source as we do in the mount case.

  if (!objectIs(prevGetSnapshot, getSnapshot) || !objectIs(prevSource, source) || !objectIs(prevSubscribe, subscribe)) {
    // Create a new queue and setState method,
    // So if there are interleaved updates, they get pushed to the older queue.
    // When this becomes current, the previous queue and dispatch method will be discarded,
    // including any interleaving updates that occur.
    var newQueue = {
      pending: null,
      dispatch: null,
      lastRenderedReducer: basicStateReducer,
      lastRenderedState: snapshot
    };
    newQueue.dispatch = setSnapshot = dispatchAction.bind(null, currentlyRenderingFiber$1, newQueue);
    stateHook.queue = newQueue;
    stateHook.baseQueue = null;
    snapshot = readFromUnsubcribedMutableSource(root, source, getSnapshot);
    stateHook.memoizedState = stateHook.baseState = snapshot;
  }

  return snapshot;
}

function mountMutableSource(source, getSnapshot, subscribe) {
  var hook = mountWorkInProgressHook();
  hook.memoizedState = {
    refs: {
      getSnapshot: getSnapshot,
      setSnapshot: null
    },
    source: source,
    subscribe: subscribe
  };
  return useMutableSource(hook, source, getSnapshot, subscribe);
}

function updateMutableSource(source, getSnapshot, subscribe) {
  var hook = updateWorkInProgressHook();
  return useMutableSource(hook, source, getSnapshot, subscribe);
}

function mountState(initialState) {
  var hook = mountWorkInProgressHook();

  if (typeof initialState === 'function') {
    // $FlowFixMe: Flow doesn't like mixed types
    initialState = initialState();
  }

  hook.memoizedState = hook.baseState = initialState;
  var queue = hook.queue = {
    pending: null,
    dispatch: null,
    lastRenderedReducer: basicStateReducer,
    lastRenderedState: initialState
  };
  var dispatch = queue.dispatch = dispatchAction.bind(null, currentlyRenderingFiber$1, queue);
  return [hook.memoizedState, dispatch];
}

function updateState(initialState) {
  return updateReducer(basicStateReducer);
}

function rerenderState(initialState) {
  return rerenderReducer(basicStateReducer);
}

function pushEffect(tag, create, destroy, deps) {
  var effect = {
    tag: tag,
    create: create,
    destroy: destroy,
    deps: deps,
    // Circular
    next: null
  };
  var componentUpdateQueue = currentlyRenderingFiber$1.updateQueue;

  if (componentUpdateQueue === null) {
    componentUpdateQueue = createFunctionComponentUpdateQueue();
    currentlyRenderingFiber$1.updateQueue = componentUpdateQueue;
    componentUpdateQueue.lastEffect = effect.next = effect;
  } else {
    var lastEffect = componentUpdateQueue.lastEffect;

    if (lastEffect === null) {
      componentUpdateQueue.lastEffect = effect.next = effect;
    } else {
      var firstEffect = lastEffect.next;
      lastEffect.next = effect;
      effect.next = firstEffect;
      componentUpdateQueue.lastEffect = effect;
    }
  }

  return effect;
}

function mountRef(initialValue) {
  var hook = mountWorkInProgressHook();
  var ref = {
    current: initialValue
  };

  {
    Object.seal(ref);
  }

  hook.memoizedState = ref;
  return ref;
}

function updateRef(initialValue) {
  var hook = updateWorkInProgressHook();
  return hook.memoizedState;
}

function mountEffectImpl(fiberFlags, hookFlags, create, deps) {
  var hook = mountWorkInProgressHook();
  var nextDeps = deps === undefined ? null : deps;
  currentlyRenderingFiber$1.flags |= fiberFlags;
  hook.memoizedState = pushEffect(HasEffect | hookFlags, create, undefined, nextDeps);
}

function updateEffectImpl(fiberFlags, hookFlags, create, deps) {
  var hook = updateWorkInProgressHook();
  var nextDeps = deps === undefined ? null : deps;
  var destroy = undefined;

  if (currentHook !== null) {
    var prevEffect = currentHook.memoizedState;
    destroy = prevEffect.destroy;

    if (nextDeps !== null) {
      var prevDeps = prevEffect.deps;

      if (areHookInputsEqual(nextDeps, prevDeps)) {
        pushEffect(hookFlags, create, destroy, nextDeps);
        return;
      }
    }
  }

  currentlyRenderingFiber$1.flags |= fiberFlags;
  hook.memoizedState = pushEffect(HasEffect | hookFlags, create, destroy, nextDeps);
}

function mountEffect(create, deps) {
  {
    // $FlowExpectedError - jest isn't a global, and isn't recognized outside of tests
    if ('undefined' !== typeof jest) {
      warnIfNotCurrentlyActingEffectsInDEV(currentlyRenderingFiber$1);
    }
  }

  return mountEffectImpl(Update | Passive, Passive$1, create, deps);
}

function updateEffect(create, deps) {
  {
    // $FlowExpectedError - jest isn't a global, and isn't recognized outside of tests
    if ('undefined' !== typeof jest) {
      warnIfNotCurrentlyActingEffectsInDEV(currentlyRenderingFiber$1);
    }
  }

  return updateEffectImpl(Update | Passive, Passive$1, create, deps);
}

function mountLayoutEffect(create, deps) {
  return mountEffectImpl(Update, Layout, create, deps);
}

function updateLayoutEffect(create, deps) {
  return updateEffectImpl(Update, Layout, create, deps);
}

function imperativeHandleEffect(create, ref) {
  if (typeof ref === 'function') {
    var refCallback = ref;

    var _inst = create();

    refCallback(_inst);
    return function () {
      refCallback(null);
    };
  } else if (ref !== null && ref !== undefined) {
    var refObject = ref;

    {
      if (!refObject.hasOwnProperty('current')) {
        error('Expected useImperativeHandle() first argument to either be a ' + 'ref callback or React.createRef() object. Instead received: %s.', 'an object with keys {' + Object.keys(refObject).join(', ') + '}');
      }
    }

    var _inst2 = create();

    refObject.current = _inst2;
    return function () {
      refObject.current = null;
    };
  }
}

function mountImperativeHandle(ref, create, deps) {
  {
    if (typeof create !== 'function') {
      error('Expected useImperativeHandle() second argument to be a function ' + 'that creates a handle. Instead received: %s.', create !== null ? typeof create : 'null');
    }
  } // TODO: If deps are provided, should we skip comparing the ref itself?


  var effectDeps = deps !== null && deps !== undefined ? deps.concat([ref]) : null;
  return mountEffectImpl(Update, Layout, imperativeHandleEffect.bind(null, create, ref), effectDeps);
}

function updateImperativeHandle(ref, create, deps) {
  {
    if (typeof create !== 'function') {
      error('Expected useImperativeHandle() second argument to be a function ' + 'that creates a handle. Instead received: %s.', create !== null ? typeof create : 'null');
    }
  } // TODO: If deps are provided, should we skip comparing the ref itself?


  var effectDeps = deps !== null && deps !== undefined ? deps.concat([ref]) : null;
  return updateEffectImpl(Update, Layout, imperativeHandleEffect.bind(null, create, ref), effectDeps);
}

function mountDebugValue(value, formatterFn) {// This hook is normally a no-op.
  // The react-debug-hooks package injects its own implementation
  // so that e.g. DevTools can display custom hook values.
}

var updateDebugValue = mountDebugValue;

function mountCallback(callback, deps) {
  var hook = mountWorkInProgressHook();
  var nextDeps = deps === undefined ? null : deps;
  hook.memoizedState = [callback, nextDeps];
  return callback;
}

function updateCallback(callback, deps) {
  var hook = updateWorkInProgressHook();
  var nextDeps = deps === undefined ? null : deps;
  var prevState = hook.memoizedState;

  if (prevState !== null) {
    if (nextDeps !== null) {
      var prevDeps = prevState[1];

      if (areHookInputsEqual(nextDeps, prevDeps)) {
        return prevState[0];
      }
    }
  }

  hook.memoizedState = [callback, nextDeps];
  return callback;
}

function mountMemo(nextCreate, deps) {
  var hook = mountWorkInProgressHook();
  var nextDeps = deps === undefined ? null : deps;
  var nextValue = nextCreate();
  hook.memoizedState = [nextValue, nextDeps];
  return nextValue;
}

function updateMemo(nextCreate, deps) {
  var hook = updateWorkInProgressHook();
  var nextDeps = deps === undefined ? null : deps;
  var prevState = hook.memoizedState;

  if (prevState !== null) {
    // Assume these are defined. If they're not, areHookInputsEqual will warn.
    if (nextDeps !== null) {
      var prevDeps = prevState[1];

      if (areHookInputsEqual(nextDeps, prevDeps)) {
        return prevState[0];
      }
    }
  }

  var nextValue = nextCreate();
  hook.memoizedState = [nextValue, nextDeps];
  return nextValue;
}

function mountDeferredValue(value) {
  var _mountState = mountState(value),
      prevValue = _mountState[0],
      setValue = _mountState[1];

  mountEffect(function () {
    var prevTransition = ReactCurrentBatchConfig$1.transition;
    ReactCurrentBatchConfig$1.transition = 1;

    try {
      setValue(value);
    } finally {
      ReactCurrentBatchConfig$1.transition = prevTransition;
    }
  }, [value]);
  return prevValue;
}

function updateDeferredValue(value) {
  var _updateState = updateState(),
      prevValue = _updateState[0],
      setValue = _updateState[1];

  updateEffect(function () {
    var prevTransition = ReactCurrentBatchConfig$1.transition;
    ReactCurrentBatchConfig$1.transition = 1;

    try {
      setValue(value);
    } finally {
      ReactCurrentBatchConfig$1.transition = prevTransition;
    }
  }, [value]);
  return prevValue;
}

function rerenderDeferredValue(value) {
  var _rerenderState = rerenderState(),
      prevValue = _rerenderState[0],
      setValue = _rerenderState[1];

  updateEffect(function () {
    var prevTransition = ReactCurrentBatchConfig$1.transition;
    ReactCurrentBatchConfig$1.transition = 1;

    try {
      setValue(value);
    } finally {
      ReactCurrentBatchConfig$1.transition = prevTransition;
    }
  }, [value]);
  return prevValue;
}

function startTransition(setPending, callback) {
  var priorityLevel = getCurrentPriorityLevel();

  {
    runWithPriority$1(priorityLevel < UserBlockingPriority$2 ? UserBlockingPriority$2 : priorityLevel, function () {
      setPending(true);
    });
    runWithPriority$1(priorityLevel > NormalPriority$1 ? NormalPriority$1 : priorityLevel, function () {
      var prevTransition = ReactCurrentBatchConfig$1.transition;
      ReactCurrentBatchConfig$1.transition = 1;

      try {
        setPending(false);
        callback();
      } finally {
        ReactCurrentBatchConfig$1.transition = prevTransition;
      }
    });
  }
}

function mountTransition() {
  var _mountState2 = mountState(false),
      isPending = _mountState2[0],
      setPending = _mountState2[1]; // The `start` method can be stored on a ref, since `setPending`
  // never changes.


  var start = startTransition.bind(null, setPending);
  mountRef(start);
  return [start, isPending];
}

function updateTransition() {
  var _updateState2 = updateState(),
      isPending = _updateState2[0];

  var startRef = updateRef();
  var start = startRef.current;
  return [start, isPending];
}

function rerenderTransition() {
  var _rerenderState2 = rerenderState(),
      isPending = _rerenderState2[0];

  var startRef = updateRef();
  var start = startRef.current;
  return [start, isPending];
}

var isUpdatingOpaqueValueInRenderPhase = false;
function getIsUpdatingOpaqueValueInRenderPhaseInDEV() {
  {
    return isUpdatingOpaqueValueInRenderPhase;
  }
}

function warnOnOpaqueIdentifierAccessInDEV(fiber) {
  {
    // TODO: Should warn in effects and callbacks, too
    var name = getComponentName(fiber.type) || 'Unknown';

    if (getIsRendering() && !didWarnAboutUseOpaqueIdentifier[name]) {
      error('The object passed back from useOpaqueIdentifier is meant to be ' + 'passed through to attributes only. Do not read the ' + 'value directly.');

      didWarnAboutUseOpaqueIdentifier[name] = true;
    }
  }
}

function mountOpaqueIdentifier() {
  var makeId =  makeClientIdInDEV.bind(null, warnOnOpaqueIdentifierAccessInDEV.bind(null, currentlyRenderingFiber$1)) ;

  if (getIsHydrating()) {
    var didUpgrade = false;
    var fiber = currentlyRenderingFiber$1;

    var readValue = function () {
      if (!didUpgrade) {
        // Only upgrade once. This works even inside the render phase because
        // the update is added to a shared queue, which outlasts the
        // in-progress render.
        didUpgrade = true;

        {
          isUpdatingOpaqueValueInRenderPhase = true;
          setId(makeId());
          isUpdatingOpaqueValueInRenderPhase = false;
          warnOnOpaqueIdentifierAccessInDEV(fiber);
        }
      }

      {
        {
          throw Error( "The object passed back from useOpaqueIdentifier is meant to be passed through to attributes only. Do not read the value directly." );
        }
      }
    };

    var id = makeOpaqueHydratingObject(readValue);
    var setId = mountState(id)[1];

    if ((currentlyRenderingFiber$1.mode & BlockingMode) === NoMode) {
      currentlyRenderingFiber$1.flags |= Update | Passive;
      pushEffect(HasEffect | Passive$1, function () {
        setId(makeId());
      }, undefined, null);
    }

    return id;
  } else {
    var _id = makeId();

    mountState(_id);
    return _id;
  }
}

function updateOpaqueIdentifier() {
  var id = updateState()[0];
  return id;
}

function rerenderOpaqueIdentifier() {
  var id = rerenderState()[0];
  return id;
}

function dispatchAction(fiber, queue, action) {
  {
    if (typeof arguments[3] === 'function') {
      error("State updates from the useState() and useReducer() Hooks don't support the " + 'second callback argument. To execute a side effect after ' + 'rendering, declare it in the component body with useEffect().');
    }
  }

  var eventTime = requestEventTime();
  var lane = requestUpdateLane(fiber);
  var update = {
    lane: lane,
    action: action,
    eagerReducer: null,
    eagerState: null,
    next: null
  }; // Append the update to the end of the list.

  var pending = queue.pending;

  if (pending === null) {
    // This is the first update. Create a circular list.
    update.next = update;
  } else {
    update.next = pending.next;
    pending.next = update;
  }

  queue.pending = update;
  var alternate = fiber.alternate;

  if (fiber === currentlyRenderingFiber$1 || alternate !== null && alternate === currentlyRenderingFiber$1) {
    // This is a render phase update. Stash it in a lazily-created map of
    // queue -> linked list of updates. After this render pass, we'll restart
    // and apply the stashed updates on top of the work-in-progress hook.
    didScheduleRenderPhaseUpdateDuringThisPass = didScheduleRenderPhaseUpdate = true;
  } else {
    if (fiber.lanes === NoLanes && (alternate === null || alternate.lanes === NoLanes)) {
      // The queue is currently empty, which means we can eagerly compute the
      // next state before entering the render phase. If the new state is the
      // same as the current state, we may be able to bail out entirely.
      var lastRenderedReducer = queue.lastRenderedReducer;

      if (lastRenderedReducer !== null) {
        var prevDispatcher;

        {
          prevDispatcher = ReactCurrentDispatcher$1.current;
          ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
        }

        try {
          var currentState = queue.lastRenderedState;
          var eagerState = lastRenderedReducer(currentState, action); // Stash the eagerly computed state, and the reducer used to compute
          // it, on the update object. If the reducer hasn't changed by the
          // time we enter the render phase, then the eager state can be used
          // without calling the reducer again.

          update.eagerReducer = lastRenderedReducer;
          update.eagerState = eagerState;

          if (objectIs(eagerState, currentState)) {
            // Fast path. We can bail out without scheduling React to re-render.
            // It's still possible that we'll need to rebase this update later,
            // if the component re-renders for a different reason and by that
            // time the reducer has changed.
            return;
          }
        } catch (error) {// Suppress the error. It will throw again in the render phase.
        } finally {
          {
            ReactCurrentDispatcher$1.current = prevDispatcher;
          }
        }
      }
    }

    {
      // $FlowExpectedError - jest isn't a global, and isn't recognized outside of tests
      if ('undefined' !== typeof jest) {
        warnIfNotScopedWithMatchingAct(fiber);
        warnIfNotCurrentlyActingUpdatesInDev(fiber);
      }
    }

    scheduleUpdateOnFiber(fiber, lane, eventTime);
  }
}

var ContextOnlyDispatcher = {
  readContext: readContext,
  useCallback: throwInvalidHookError,
  useContext: throwInvalidHookError,
  useEffect: throwInvalidHookError,
  useImperativeHandle: throwInvalidHookError,
  useLayoutEffect: throwInvalidHookError,
  useMemo: throwInvalidHookError,
  useReducer: throwInvalidHookError,
  useRef: throwInvalidHookError,
  useState: throwInvalidHookError,
  useDebugValue: throwInvalidHookError,
  useDeferredValue: throwInvalidHookError,
  useTransition: throwInvalidHookError,
  useMutableSource: throwInvalidHookError,
  useOpaqueIdentifier: throwInvalidHookError,
  unstable_isNewReconciler: enableNewReconciler
};
var HooksDispatcherOnMountInDEV = null;
var HooksDispatcherOnMountWithHookTypesInDEV = null;
var HooksDispatcherOnUpdateInDEV = null;
var HooksDispatcherOnRerenderInDEV = null;
var InvalidNestedHooksDispatcherOnMountInDEV = null;
var InvalidNestedHooksDispatcherOnUpdateInDEV = null;
var InvalidNestedHooksDispatcherOnRerenderInDEV = null;

{
  var warnInvalidContextAccess = function () {
    error('Context can only be read while React is rendering. ' + 'In classes, you can read it in the render method or getDerivedStateFromProps. ' + 'In function components, you can read it directly in the function body, but not ' + 'inside Hooks like useReducer() or useMemo().');
  };

  var warnInvalidHookAccess = function () {
    error('Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. ' + 'You can only call Hooks at the top level of your React function. ' + 'For more information, see ' + 'https://reactjs.org/link/rules-of-hooks');
  };

  HooksDispatcherOnMountInDEV = {
    readContext: function (context, observedBits) {
      return readContext(context, observedBits);
    },
    useCallback: function (callback, deps) {
      currentHookNameInDev = 'useCallback';
      mountHookTypesDev();
      checkDepsAreArrayDev(deps);
      return mountCallback(callback, deps);
    },
    useContext: function (context, observedBits) {
      currentHookNameInDev = 'useContext';
      mountHookTypesDev();
      return readContext(context, observedBits);
    },
    useEffect: function (create, deps) {
      currentHookNameInDev = 'useEffect';
      mountHookTypesDev();
      checkDepsAreArrayDev(deps);
      return mountEffect(create, deps);
    },
    useImperativeHandle: function (ref, create, deps) {
      currentHookNameInDev = 'useImperativeHandle';
      mountHookTypesDev();
      checkDepsAreArrayDev(deps);
      return mountImperativeHandle(ref, create, deps);
    },
    useLayoutEffect: function (create, deps) {
      currentHookNameInDev = 'useLayoutEffect';
      mountHookTypesDev();
      checkDepsAreArrayDev(deps);
      return mountLayoutEffect(create, deps);
    },
    useMemo: function (create, deps) {
      currentHookNameInDev = 'useMemo';
      mountHookTypesDev();
      checkDepsAreArrayDev(deps);
      var prevDispatcher = ReactCurrentDispatcher$1.current;
      ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;

      try {
        return mountMemo(create, deps);
      } finally {
        ReactCurrentDispatcher$1.current = prevDispatcher;
      }
    },
    useReducer: function (reducer, initialArg, init) {
      currentHookNameInDev = 'useReducer';
      mountHookTypesDev();
      var prevDispatcher = ReactCurrentDispatcher$1.current;
      ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;

      try {
        return mountReducer(reducer, initialArg, init);
      } finally {
        ReactCurrentDispatcher$1.current = prevDispatcher;
      }
    },
    useRef: function (initialValue) {
      currentHookNameInDev = 'useRef';
      mountHookTypesDev();
      return mountRef(initialValue);
    },
    useState: function (initialState) {
      currentHookNameInDev = 'useState';
      mountHookTypesDev();
      var prevDispatcher = ReactCurrentDispatcher$1.current;
      ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;

      try {
        return mountState(initialState);
      } finally {
        ReactCurrentDispatcher$1.current = prevDispatcher;
      }
    },
    useDebugValue: function (value, formatterFn) {
      currentHookNameInDev = 'useDebugValue';
      mountHookTypesDev();
      return mountDebugValue();
    },
    useDeferredValue: function (value) {
      currentHookNameInDev = 'useDeferredValue';
      mountHookTypesDev();
      return mountDeferredValue(value);
    },
    useTransition: function () {
      currentHookNameInDev = 'useTransition';
      mountHookTypesDev();
      return mountTransition();
    },
    useMutableSource: function (source, getSnapshot, subscribe) {
      currentHookNameInDev = 'useMutableSource';
      mountHookTypesDev();
      return mountMutableSource(source, getSnapshot, subscribe);
    },
    useOpaqueIdentifier: function () {
      currentHookNameInDev = 'useOpaqueIdentifier';
      mountHookTypesDev();
      return mountOpaqueIdentifier();
    },
    unstable_isNewReconciler: enableNewReconciler
  };
  HooksDispatcherOnMountWithHookTypesInDEV = {
    readContext: function (context, observedBits) {
      return readContext(context, observedBits);
    },
    useCallback: function (callback, deps) {
      currentHookNameInDev = 'useCallback';
      updateHookTypesDev();
      return mountCallback(callback, deps);
    },
    useContext: function (context, observedBits) {
      currentHookNameInDev = 'useContext';
      updateHookTypesDev();
      return readContext(context, observedBits);
    },
    useEffect: function (create, deps) {
      currentHookNameInDev = 'useEffect';
      updateHookTypesDev();
      return mountEffect(create, deps);
    },
    useImperativeHandle: function (ref, create, deps) {
      currentHookNameInDev = 'useImperativeHandle';
      updateHookTypesDev();
      return mountImperativeHandle(ref, create, deps);
    },
    useLayoutEffect: function (create, deps) {
      currentHookNameInDev = 'useLayoutEffect';
      updateHookTypesDev();
      return mountLayoutEffect(create, deps);
    },
    useMemo: function (create, deps) {
      currentHookNameInDev = 'useMemo';
      updateHookTypesDev();
      var prevDispatcher = ReactCurrentDispatcher$1.current;
      ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;

      try {
        return mountMemo(create, deps);
      } finally {
        ReactCurrentDispatcher$1.current = prevDispatcher;
      }
    },
    useReducer: function (reducer, initialArg, init) {
      currentHookNameInDev = 'useReducer';
      updateHookTypesDev();
      var prevDispatcher = ReactCurrentDispatcher$1.current;
      ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;

      try {
        return mountReducer(reducer, initialArg, init);
      } finally {
        ReactCurrentDispatcher$1.current = prevDispatcher;
      }
    },
    useRef: function (initialValue) {
      currentHookNameInDev = 'useRef';
      updateHookTypesDev();
      return mountRef(initialValue);
    },
    useState: function (initialState) {
      currentHookNameInDev = 'useState';
      updateHookTypesDev();
      var prevDispatcher = ReactCurrentDispatcher$1.current;
      ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;

      try {
        return mountState(initialState);
      } finally {
        ReactCurrentDispatcher$1.current = prevDispatcher;
      }
    },
    useDebugValue: function (value, formatterFn) {
      currentHookNameInDev = 'useDebugValue';
      updateHookTypesDev();
      return mountDebugValue();
    },
    useDeferredValue: function (value) {
      currentHookNameInDev = 'useDeferredValue';
      updateHookTypesDev();
      return mountDeferredValue(value);
    },
    useTransition: function () {
      currentHookNameInDev = 'useTransition';
      updateHookTypesDev();
      return mountTransition();
    },
    useMutableSource: function (source, getSnapshot, subscribe) {
      currentHookNameInDev = 'useMutableSource';
      updateHookTypesDev();
      return mountMutableSource(source, getSnapshot, subscribe);
    },
    useOpaqueIdentifier: function () {
      currentHookNameInDev = 'useOpaqueIdentifier';
      updateHookTypesDev();
      return mountOpaqueIdentifier();
    },
    unstable_isNewReconciler: enableNewReconciler
  };
  HooksDispatcherOnUpdateInDEV = {
    readContext: function (context, observedBits) {
      return readContext(context, observedBits);
    },
    useCallback: function (callback, deps) {
      currentHookNameInDev = 'useCallback';
      updateHookTypesDev();
      return updateCallback(callback, deps);
    },
    useContext: function (context, observedBits) {
      currentHookNameInDev = 'useContext';
      updateHookTypesDev();
      return readContext(context, observedBits);
    },
    useEffect: function (create, deps) {
      currentHookNameInDev = 'useEffect';
      updateHookTypesDev();
      return updateEffect(create, deps);
    },
    useImperativeHandle: function (ref, create, deps) {
      currentHookNameInDev = 'useImperativeHandle';
      updateHookTypesDev();
      return updateImperativeHandle(ref, create, deps);
    },
    useLayoutEffect: function (create, deps) {
      currentHookNameInDev = 'useLayoutEffect';
      updateHookTypesDev();
      return updateLayoutEffect(create, deps);
    },
    useMemo: function (create, deps) {
      currentHookNameInDev = 'useMemo';
      updateHookTypesDev();
      var prevDispatcher = ReactCurrentDispatcher$1.current;
      ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;

      try {
        return updateMemo(create, deps);
      } finally {
        ReactCurrentDispatcher$1.current = prevDispatcher;
      }
    },
    useReducer: function (reducer, initialArg, init) {
      currentHookNameInDev = 'useReducer';
      updateHookTypesDev();
      var prevDispatcher = ReactCurrentDispatcher$1.current;
      ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;

      try {
        return updateReducer(reducer, initialArg, init);
      } finally {
        ReactCurrentDispatcher$1.current = prevDispatcher;
      }
    },
    useRef: function (initialValue) {
      currentHookNameInDev = 'useRef';
      updateHookTypesDev();
      return updateRef();
    },
    useState: function (initialState) {
      currentHookNameInDev = 'useState';
      updateHookTypesDev();
      var prevDispatcher = ReactCurrentDispatcher$1.current;
      ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;

      try {
        return updateState(initialState);
      } finally {
        ReactCurrentDispatcher$1.current = prevDispatcher;
      }
    },
    useDebugValue: function (value, formatterFn) {
      currentHookNameInDev = 'useDebugValue';
      updateHookTypesDev();
      return updateDebugValue();
    },
    useDeferredValue: function (value) {
      currentHookNameInDev = 'useDeferredValue';
      updateHookTypesDev();
      return updateDeferredValue(value);
    },
    useTransition: function () {
      currentHookNameInDev = 'useTransition';
      updateHookTypesDev();
      return updateTransition();
    },
    useMutableSource: function (source, getSnapshot, subscribe) {
      currentHookNameInDev = 'useMutableSource';
      updateHookTypesDev();
      return updateMutableSource(source, getSnapshot, subscribe);
    },
    useOpaqueIdentifier: function () {
      currentHookNameInDev = 'useOpaqueIdentifier';
      updateHookTypesDev();
      return updateOpaqueIdentifier();
    },
    unstable_isNewReconciler: enableNewReconciler
  };
  HooksDispatcherOnRerenderInDEV = {
    readContext: function (context, observedBits) {
      return readContext(context, observedBits);
    },
    useCallback: function (callback, deps) {
      currentHookNameInDev = 'useCallback';
      updateHookTypesDev();
      return updateCallback(callback, deps);
    },
    useContext: function (context, observedBits) {
      currentHookNameInDev = 'useContext';
      updateHookTypesDev();
      return readContext(context, observedBits);
    },
    useEffect: function (create, deps) {
      currentHookNameInDev = 'useEffect';
      updateHookTypesDev();
      return updateEffect(create, deps);
    },
    useImperativeHandle: function (ref, create, deps) {
      currentHookNameInDev = 'useImperativeHandle';
      updateHookTypesDev();
      return updateImperativeHandle(ref, create, deps);
    },
    useLayoutEffect: function (create, deps) {
      currentHookNameInDev = 'useLayoutEffect';
      updateHookTypesDev();
      return updateLayoutEffect(create, deps);
    },
    useMemo: function (create, deps) {
      currentHookNameInDev = 'useMemo';
      updateHookTypesDev();
      var prevDispatcher = ReactCurrentDispatcher$1.current;
      ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnRerenderInDEV;

      try {
        return updateMemo(create, deps);
      } finally {
        ReactCurrentDispatcher$1.current = prevDispatcher;
      }
    },
    useReducer: function (reducer, initialArg, init) {
      currentHookNameInDev = 'useReducer';
      updateHookTypesDev();
      var prevDispatcher = ReactCurrentDispatcher$1.current;
      ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnRerenderInDEV;

      try {
        return rerenderReducer(reducer, initialArg, init);
      } finally {
        ReactCurrentDispatcher$1.current = prevDispatcher;
      }
    },
    useRef: function (initialValue) {
      currentHookNameInDev = 'useRef';
      updateHookTypesDev();
      return updateRef();
    },
    useState: function (initialState) {
      currentHookNameInDev = 'useState';
      updateHookTypesDev();
      var prevDispatcher = ReactCurrentDispatcher$1.current;
      ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnRerenderInDEV;

      try {
        return rerenderState(initialState);
      } finally {
        ReactCurrentDispatcher$1.current = prevDispatcher;
      }
    },
    useDebugValue: function (value, formatterFn) {
      currentHookNameInDev = 'useDebugValue';
      updateHookTypesDev();
      return updateDebugValue();
    },
    useDeferredValue: function (value) {
      currentHookNameInDev = 'useDeferredValue';
      updateHookTypesDev();
      return rerenderDeferredValue(value);
    },
    useTransition: function () {
      currentHookNameInDev = 'useTransition';
      updateHookTypesDev();
      return rerenderTransition();
    },
    useMutableSource: function (source, getSnapshot, subscribe) {
      currentHookNameInDev = 'useMutableSource';
      updateHookTypesDev();
      return updateMutableSource(source, getSnapshot, subscribe);
    },
    useOpaqueIdentifier: function () {
      currentHookNameInDev = 'useOpaqueIdentifier';
      updateHookTypesDev();
      return rerenderOpaqueIdentifier();
    },
    unstable_isNewReconciler: enableNewReconciler
  };
  InvalidNestedHooksDispatcherOnMountInDEV = {
    readContext: function (context, observedBits) {
      warnInvalidContextAccess();
      return readContext(context, observedBits);
    },
    useCallback: function (callback, deps) {
      currentHookNameInDev = 'useCallback';
      warnInvalidHookAccess();
      mountHookTypesDev();
      return mountCallback(callback, deps);
    },
    useContext: function (context, observedBits) {
      currentHookNameInDev = 'useContext';
      warnInvalidHookAccess();
      mountHookTypesDev();
      return readContext(context, observedBits);
    },
    useEffect: function (create, deps) {
      currentHookNameInDev = 'useEffect';
      warnInvalidHookAccess();
      mountHookTypesDev();
      return mountEffect(create, deps);
    },
    useImperativeHandle: function (ref, create, deps) {
      currentHookNameInDev = 'useImperativeHandle';
      warnInvalidHookAccess();
      mountHookTypesDev();
      return mountImperativeHandle(ref, create, deps);
    },
    useLayoutEffect: function (create, deps) {
      currentHookNameInDev = 'useLayoutEffect';
      warnInvalidHookAccess();
      mountHookTypesDev();
      return mountLayoutEffect(create, deps);
    },
    useMemo: function (create, deps) {
      currentHookNameInDev = 'useMemo';
      warnInvalidHookAccess();
      mountHookTypesDev();
      var prevDispatcher = ReactCurrentDispatcher$1.current;
      ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;

      try {
        return mountMemo(create, deps);
      } finally {
        ReactCurrentDispatcher$1.current = prevDispatcher;
      }
    },
    useReducer: function (reducer, initialArg, init) {
      currentHookNameInDev = 'useReducer';
      warnInvalidHookAccess();
      mountHookTypesDev();
      var prevDispatcher = ReactCurrentDispatcher$1.current;
      ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;

      try {
        return mountReducer(reducer, initialArg, init);
      } finally {
        ReactCurrentDispatcher$1.current = prevDispatcher;
      }
    },
    useRef: function (initialValue) {
      currentHookNameInDev = 'useRef';
      warnInvalidHookAccess();
      mountHookTypesDev();
      return mountRef(initialValue);
    },
    useState: function (initialState) {
      currentHookNameInDev = 'useState';
      warnInvalidHookAccess();
      mountHookTypesDev();
      var prevDispatcher = ReactCurrentDispatcher$1.current;
      ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;

      try {
        return mountState(initialState);
      } finally {
        ReactCurrentDispatcher$1.current = prevDispatcher;
      }
    },
    useDebugValue: function (value, formatterFn) {
      currentHookNameInDev = 'useDebugValue';
      warnInvalidHookAccess();
      mountHookTypesDev();
      return mountDebugValue();
    },
    useDeferredValue: function (value) {
      currentHookNameInDev = 'useDeferredValue';
      warnInvalidHookAccess();
      mountHookTypesDev();
      return mountDeferredValue(value);
    },
    useTransition: function () {
      currentHookNameInDev = 'useTransition';
      warnInvalidHookAccess();
      mountHookTypesDev();
      return mountTransition();
    },
    useMutableSource: function (source, getSnapshot, subscribe) {
      currentHookNameInDev = 'useMutableSource';
      warnInvalidHookAccess();
      mountHookTypesDev();
      return mountMutableSource(source, getSnapshot, subscribe);
    },
    useOpaqueIdentifier: function () {
      currentHookNameInDev = 'useOpaqueIdentifier';
      warnInvalidHookAccess();
      mountHookTypesDev();
      return mountOpaqueIdentifier();
    },
    unstable_isNewReconciler: enableNewReconciler
  };
  InvalidNestedHooksDispatcherOnUpdateInDEV = {
    readContext: function (context, observedBits) {
      warnInvalidContextAccess();
      return readContext(context, observedBits);
    },
    useCallback: function (callback, deps) {
      currentHookNameInDev = 'useCallback';
      warnInvalidHookAccess();
      updateHookTypesDev();
      return updateCallback(callback, deps);
    },
    useContext: function (context, observedBits) {
      currentHookNameInDev = 'useContext';
      warnInvalidHookAccess();
      updateHookTypesDev();
      return readContext(context, observedBits);
    },
    useEffect: function (create, deps) {
      currentHookNameInDev = 'useEffect';
      warnInvalidHookAccess();
      updateHookTypesDev();
      return updateEffect(create, deps);
    },
    useImperativeHandle: function (ref, create, deps) {
      currentHookNameInDev = 'useImperativeHandle';
      warnInvalidHookAccess();
      updateHookTypesDev();
      return updateImperativeHandle(ref, create, deps);
    },
    useLayoutEffect: function (create, deps) {
      currentHookNameInDev = 'useLayoutEffect';
      warnInvalidHookAccess();
      updateHookTypesDev();
      return updateLayoutEffect(create, deps);
    },
    useMemo: function (create, deps) {
      currentHookNameInDev = 'useMemo';
      warnInvalidHookAccess();
      updateHookTypesDev();
      var prevDispatcher = ReactCurrentDispatcher$1.current;
      ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;

      try {
        return updateMemo(create, deps);
      } finally {
        ReactCurrentDispatcher$1.current = prevDispatcher;
      }
    },
    useReducer: function (reducer, initialArg, init) {
      currentHookNameInDev = 'useReducer';
      warnInvalidHookAccess();
      updateHookTypesDev();
      var prevDispatcher = ReactCurrentDispatcher$1.current;
      ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;

      try {
        return updateReducer(reducer, initialArg, init);
      } finally {
        ReactCurrentDispatcher$1.current = prevDispatcher;
      }
    },
    useRef: function (initialValue) {
      currentHookNameInDev = 'useRef';
      warnInvalidHookAccess();
      updateHookTypesDev();
      return updateRef();
    },
    useState: function (initialState) {
      currentHookNameInDev = 'useState';
      warnInvalidHookAccess();
      updateHookTypesDev();
      var prevDispatcher = ReactCurrentDispatcher$1.current;
      ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;

      try {
        return updateState(initialState);
      } finally {
        ReactCurrentDispatcher$1.current = prevDispatcher;
      }
    },
    useDebugValue: function (value, formatterFn) {
      currentHookNameInDev = 'useDebugValue';
      warnInvalidHookAccess();
      updateHookTypesDev();
      return updateDebugValue();
    },
    useDeferredValue: function (value) {
      currentHookNameInDev = 'useDeferredValue';
      warnInvalidHookAccess();
      updateHookTypesDev();
      return updateDeferredValue(value);
    },
    useTransition: function () {
      currentHookNameInDev = 'useTransition';
      warnInvalidHookAccess();
      updateHookTypesDev();
      return updateTransition();
    },
    useMutableSource: function (source, getSnapshot, subscribe) {
      currentHookNameInDev = 'useMutableSource';
      warnInvalidHookAccess();
      updateHookTypesDev();
      return updateMutableSource(source, getSnapshot, subscribe);
    },
    useOpaqueIdentifier: function () {
      currentHookNameInDev = 'useOpaqueIdentifier';
      warnInvalidHookAccess();
      updateHookTypesDev();
      return updateOpaqueIdentifier();
    },
    unstable_isNewReconciler: enableNewReconciler
  };
  InvalidNestedHooksDispatcherOnRerenderInDEV = {
    readContext: function (context, observedBits) {
      warnInvalidContextAccess();
      return readContext(context, observedBits);
    },
    useCallback: function (callback, deps) {
      currentHookNameInDev = 'useCallback';
      warnInvalidHookAccess();
      updateHookTypesDev();
      return updateCallback(callback, deps);
    },
    useContext: function (context, observedBits) {
      currentHookNameInDev = 'useContext';
      warnInvalidHookAccess();
      updateHookTypesDev();
      return readContext(context, observedBits);
    },
    useEffect: function (create, deps) {
      currentHookNameInDev = 'useEffect';
      warnInvalidHookAccess();
      updateHookTypesDev();
      return updateEffect(create, deps);
    },
    useImperativeHandle: function (ref, create, deps) {
      currentHookNameInDev = 'useImperativeHandle';
      warnInvalidHookAccess();
      updateHookTypesDev();
      return updateImperativeHandle(ref, create, deps);
    },
    useLayoutEffect: function (create, deps) {
      currentHookNameInDev = 'useLayoutEffect';
      warnInvalidHookAccess();
      updateHookTypesDev();
      return updateLayoutEffect(create, deps);
    },
    useMemo: function (create, deps) {
      currentHookNameInDev = 'useMemo';
      warnInvalidHookAccess();
      updateHookTypesDev();
      var prevDispatcher = ReactCurrentDispatcher$1.current;
      ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;

      try {
        return updateMemo(create, deps);
      } finally {
        ReactCurrentDispatcher$1.current = prevDispatcher;
      }
    },
    useReducer: function (reducer, initialArg, init) {
      currentHookNameInDev = 'useReducer';
      warnInvalidHookAccess();
      updateHookTypesDev();
      var prevDispatcher = ReactCurrentDispatcher$1.current;
      ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;

      try {
        return rerenderReducer(reducer, initialArg, init);
      } finally {
        ReactCurrentDispatcher$1.current = prevDispatcher;
      }
    },
    useRef: function (initialValue) {
      currentHookNameInDev = 'useRef';
      warnInvalidHookAccess();
      updateHookTypesDev();
      return updateRef();
    },
    useState: function (initialState) {
      currentHookNameInDev = 'useState';
      warnInvalidHookAccess();
      updateHookTypesDev();
      var prevDispatcher = ReactCurrentDispatcher$1.current;
      ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;

      try {
        return rerenderState(initialState);
      } finally {
        ReactCurrentDispatcher$1.current = prevDispatcher;
      }
    },
    useDebugValue: function (value, formatterFn) {
      currentHookNameInDev = 'useDebugValue';
      warnInvalidHookAccess();
      updateHookTypesDev();
      return updateDebugValue();
    },
    useDeferredValue: function (value) {
      currentHookNameInDev = 'useDeferredValue';
      warnInvalidHookAccess();
      updateHookTypesDev();
      return rerenderDeferredValue(value);
    },
    useTransition: function () {
      currentHookNameInDev = 'useTransition';
      warnInvalidHookAccess();
      updateHookTypesDev();
      return rerenderTransition();
    },
    useMutableSource: function (source, getSnapshot, subscribe) {
      currentHookNameInDev = 'useMutableSource';
      warnInvalidHookAccess();
      updateHookTypesDev();
      return updateMutableSource(source, getSnapshot, subscribe);
    },
    useOpaqueIdentifier: function () {
      currentHookNameInDev = 'useOpaqueIdentifier';
      warnInvalidHookAccess();
      updateHookTypesDev();
      return rerenderOpaqueIdentifier();
    },
    unstable_isNewReconciler: enableNewReconciler
  };
}

var now$1 = Scheduler.unstable_now;
var commitTime = 0;
var profilerStartTime = -1;

function getCommitTime() {
  return commitTime;
}

function recordCommitTime() {

  commitTime = now$1();
}

function startProfilerTimer(fiber) {

  profilerStartTime = now$1();

  if (fiber.actualStartTime < 0) {
    fiber.actualStartTime = now$1();
  }
}

function stopProfilerTimerIfRunning(fiber) {

  profilerStartTime = -1;
}

function stopProfilerTimerIfRunningAndRecordDelta(fiber, overrideBaseTime) {

  if (profilerStartTime >= 0) {
    var elapsedTime = now$1() - profilerStartTime;
    fiber.actualDuration += elapsedTime;

    if (overrideBaseTime) {
      fiber.selfBaseDuration = elapsedTime;
    }

    profilerStartTime = -1;
  }
}

function transferActualDuration(fiber) {
  // Transfer time spent rendering these children so we don't lose it
  // after we rerender. This is used as a helper in special cases
  // where we should count the work of multiple passes.
  var child = fiber.child;

  while (child) {
    fiber.actualDuration += child.actualDuration;
    child = child.sibling;
  }
}

var ReactCurrentOwner$1 = ReactSharedInternals.ReactCurrentOwner;
var didReceiveUpdate = false;
var didWarnAboutBadClass;
var didWarnAboutModulePatternComponent;
var didWarnAboutContextTypeOnFunctionComponent;
var didWarnAboutGetDerivedStateOnFunctionComponent;
var didWarnAboutFunctionRefs;
var didWarnAboutReassigningProps;
var didWarnAboutRevealOrder;
var didWarnAboutTailOptions;

{
  didWarnAboutBadClass = {};
  didWarnAboutModulePatternComponent = {};
  didWarnAboutContextTypeOnFunctionComponent = {};
  didWarnAboutGetDerivedStateOnFunctionComponent = {};
  didWarnAboutFunctionRefs = {};
  didWarnAboutReassigningProps = false;
  didWarnAboutRevealOrder = {};
  didWarnAboutTailOptions = {};
}

function reconcileChildren(current, workInProgress, nextChildren, renderLanes) {
  if (current === null) {
    // If this is a fresh new component that hasn't been rendered yet, we
    // won't update its child set by applying minimal side-effects. Instead,
    // we will add them all to the child before it gets rendered. That means
    // we can optimize this reconciliation pass by not tracking side-effects.
    workInProgress.child = mountChildFibers(workInProgress, null, nextChildren, renderLanes);
  } else {
    // If the current child is the same as the work in progress, it means that
    // we haven't yet started any work on these children. Therefore, we use
    // the clone algorithm to create a copy of all the current children.
    // If we had any progressed work already, that is invalid at this point so
    // let's throw it out.
    workInProgress.child = reconcileChildFibers(workInProgress, current.child, nextChildren, renderLanes);
  }
}

function forceUnmountCurrentAndReconcile(current, workInProgress, nextChildren, renderLanes) {
  // This function is fork of reconcileChildren. It's used in cases where we
  // want to reconcile without matching against the existing set. This has the
  // effect of all current children being unmounted; even if the type and key
  // are the same, the old child is unmounted and a new child is created.
  //
  // To do this, we're going to go through the reconcile algorithm twice. In
  // the first pass, we schedule a deletion for all the current children by
  // passing null.
  workInProgress.child = reconcileChildFibers(workInProgress, current.child, null, renderLanes); // In the second pass, we mount the new children. The trick here is that we
  // pass null in place of where we usually pass the current child set. This has
  // the effect of remounting all children regardless of whether their
  // identities match.

  workInProgress.child = reconcileChildFibers(workInProgress, null, nextChildren, renderLanes);
}

function updateForwardRef(current, workInProgress, Component, nextProps, renderLanes) {
  // TODO: current can be non-null here even if the component
  // hasn't yet mounted. This happens after the first render suspends.
  // We'll need to figure out if this is fine or can cause issues.
  {
    if (workInProgress.type !== workInProgress.elementType) {
      // Lazy component props can't be validated in createElement
      // because they're only guaranteed to be resolved here.
      var innerPropTypes = Component.propTypes;

      if (innerPropTypes) {
        checkPropTypes(innerPropTypes, nextProps, // Resolved props
        'prop', getComponentName(Component));
      }
    }
  }

  var render = Component.render;
  var ref = workInProgress.ref; // The rest is a fork of updateFunctionComponent

  var nextChildren;
  prepareToReadContext(workInProgress, renderLanes);

  {
    ReactCurrentOwner$1.current = workInProgress;
    setIsRendering(true);
    nextChildren = renderWithHooks(current, workInProgress, render, nextProps, ref, renderLanes);

    if ( workInProgress.mode & StrictMode) {
      disableLogs();

      try {
        nextChildren = renderWithHooks(current, workInProgress, render, nextProps, ref, renderLanes);
      } finally {
        reenableLogs();
      }
    }

    setIsRendering(false);
  }

  if (current !== null && !didReceiveUpdate) {
    bailoutHooks(current, workInProgress, renderLanes);
    return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);
  } // React DevTools reads this flag.


  workInProgress.flags |= PerformedWork;
  reconcileChildren(current, workInProgress, nextChildren, renderLanes);
  return workInProgress.child;
}

function updateMemoComponent(current, workInProgress, Component, nextProps, updateLanes, renderLanes) {
  if (current === null) {
    var type = Component.type;

    if (isSimpleFunctionComponent(type) && Component.compare === null && // SimpleMemoComponent codepath doesn't resolve outer props either.
    Component.defaultProps === undefined) {
      var resolvedType = type;

      {
        resolvedType = resolveFunctionForHotReloading(type);
      } // If this is a plain function component without default props,
      // and with only the default shallow comparison, we upgrade it
      // to a SimpleMemoComponent to allow fast path updates.


      workInProgress.tag = SimpleMemoComponent;
      workInProgress.type = resolvedType;

      {
        validateFunctionComponentInDev(workInProgress, type);
      }

      return updateSimpleMemoComponent(current, workInProgress, resolvedType, nextProps, updateLanes, renderLanes);
    }

    {
      var innerPropTypes = type.propTypes;

      if (innerPropTypes) {
        // Inner memo component props aren't currently validated in createElement.
        // We could move it there, but we'd still need this for lazy code path.
        checkPropTypes(innerPropTypes, nextProps, // Resolved props
        'prop', getComponentName(type));
      }
    }

    var child = createFiberFromTypeAndProps(Component.type, null, nextProps, workInProgress, workInProgress.mode, renderLanes);
    child.ref = workInProgress.ref;
    child.return = workInProgress;
    workInProgress.child = child;
    return child;
  }

  {
    var _type = Component.type;
    var _innerPropTypes = _type.propTypes;

    if (_innerPropTypes) {
      // Inner memo component props aren't currently validated in createElement.
      // We could move it there, but we'd still need this for lazy code path.
      checkPropTypes(_innerPropTypes, nextProps, // Resolved props
      'prop', getComponentName(_type));
    }
  }

  var currentChild = current.child; // This is always exactly one child

  if (!includesSomeLane(updateLanes, renderLanes)) {
    // This will be the props with resolved defaultProps,
    // unlike current.memoizedProps which will be the unresolved ones.
    var prevProps = currentChild.memoizedProps; // Default to shallow comparison

    var compare = Component.compare;
    compare = compare !== null ? compare : shallowEqual;

    if (compare(prevProps, nextProps) && current.ref === workInProgress.ref) {
      return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);
    }
  } // React DevTools reads this flag.


  workInProgress.flags |= PerformedWork;
  var newChild = createWorkInProgress(currentChild, nextProps);
  newChild.ref = workInProgress.ref;
  newChild.return = workInProgress;
  workInProgress.child = newChild;
  return newChild;
}

function updateSimpleMemoComponent(current, workInProgress, Component, nextProps, updateLanes, renderLanes) {
  // TODO: current can be non-null here even if the component
  // hasn't yet mounted. This happens when the inner render suspends.
  // We'll need to figure out if this is fine or can cause issues.
  {
    if (workInProgress.type !== workInProgress.elementType) {
      // Lazy component props can't be validated in createElement
      // because they're only guaranteed to be resolved here.
      var outerMemoType = workInProgress.elementType;

      if (outerMemoType.$$typeof === REACT_LAZY_TYPE) {
        // We warn when you define propTypes on lazy()
        // so let's just skip over it to find memo() outer wrapper.
        // Inner props for memo are validated later.
        var lazyComponent = outerMemoType;
        var payload = lazyComponent._payload;
        var init = lazyComponent._init;

        try {
          outerMemoType = init(payload);
        } catch (x) {
          outerMemoType = null;
        } // Inner propTypes will be validated in the function component path.


        var outerPropTypes = outerMemoType && outerMemoType.propTypes;

        if (outerPropTypes) {
          checkPropTypes(outerPropTypes, nextProps, // Resolved (SimpleMemoComponent has no defaultProps)
          'prop', getComponentName(outerMemoType));
        }
      }
    }
  }

  if (current !== null) {
    var prevProps = current.memoizedProps;

    if (shallowEqual(prevProps, nextProps) && current.ref === workInProgress.ref && ( // Prevent bailout if the implementation changed due to hot reload.
     workInProgress.type === current.type )) {
      didReceiveUpdate = false;

      if (!includesSomeLane(renderLanes, updateLanes)) {
        // The pending lanes were cleared at the beginning of beginWork. We're
        // about to bail out, but there might be other lanes that weren't
        // included in the current render. Usually, the priority level of the
        // remaining updates is accumlated during the evaluation of the
        // component (i.e. when processing the update queue). But since since
        // we're bailing out early *without* evaluating the component, we need
        // to account for it here, too. Reset to the value of the current fiber.
        // NOTE: This only applies to SimpleMemoComponent, not MemoComponent,
        // because a MemoComponent fiber does not have hooks or an update queue;
        // rather, it wraps around an inner component, which may or may not
        // contains hooks.
        // TODO: Move the reset at in beginWork out of the common path so that
        // this is no longer necessary.
        workInProgress.lanes = current.lanes;
        return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);
      } else if ((current.flags & ForceUpdateForLegacySuspense) !== NoFlags) {
        // This is a special case that only exists for legacy mode.
        // See https://github.com/facebook/react/pull/19216.
        didReceiveUpdate = true;
      }
    }
  }

  return updateFunctionComponent(current, workInProgress, Component, nextProps, renderLanes);
}

function updateOffscreenComponent(current, workInProgress, renderLanes) {
  var nextProps = workInProgress.pendingProps;
  var nextChildren = nextProps.children;
  var prevState = current !== null ? current.memoizedState : null;

  if (nextProps.mode === 'hidden' || nextProps.mode === 'unstable-defer-without-hiding') {
    if ((workInProgress.mode & ConcurrentMode) === NoMode) {
      // In legacy sync mode, don't defer the subtree. Render it now.
      // TODO: Figure out what we should do in Blocking mode.
      var nextState = {
        baseLanes: NoLanes
      };
      workInProgress.memoizedState = nextState;
      pushRenderLanes(workInProgress, renderLanes);
    } else if (!includesSomeLane(renderLanes, OffscreenLane)) {
      var nextBaseLanes;

      if (prevState !== null) {
        var prevBaseLanes = prevState.baseLanes;
        nextBaseLanes = mergeLanes(prevBaseLanes, renderLanes);
      } else {
        nextBaseLanes = renderLanes;
      } // Schedule this fiber to re-render at offscreen priority. Then bailout.


      {
        markSpawnedWork(OffscreenLane);
      }

      workInProgress.lanes = workInProgress.childLanes = laneToLanes(OffscreenLane);
      var _nextState = {
        baseLanes: nextBaseLanes
      };
      workInProgress.memoizedState = _nextState; // We're about to bail out, but we need to push this to the stack anyway
      // to avoid a push/pop misalignment.

      pushRenderLanes(workInProgress, nextBaseLanes);
      return null;
    } else {
      // Rendering at offscreen, so we can clear the base lanes.
      var _nextState2 = {
        baseLanes: NoLanes
      };
      workInProgress.memoizedState = _nextState2; // Push the lanes that were skipped when we bailed out.

      var subtreeRenderLanes = prevState !== null ? prevState.baseLanes : renderLanes;
      pushRenderLanes(workInProgress, subtreeRenderLanes);
    }
  } else {
    var _subtreeRenderLanes;

    if (prevState !== null) {
      _subtreeRenderLanes = mergeLanes(prevState.baseLanes, renderLanes); // Since we're not hidden anymore, reset the state

      workInProgress.memoizedState = null;
    } else {
      // We weren't previously hidden, and we still aren't, so there's nothing
      // special to do. Need to push to the stack regardless, though, to avoid
      // a push/pop misalignment.
      _subtreeRenderLanes = renderLanes;
    }

    pushRenderLanes(workInProgress, _subtreeRenderLanes);
  }

  reconcileChildren(current, workInProgress, nextChildren, renderLanes);
  return workInProgress.child;
} // Note: These happen to have identical begin phases, for now. We shouldn't hold
// ourselves to this constraint, though. If the behavior diverges, we should
// fork the function.


var updateLegacyHiddenComponent = updateOffscreenComponent;

function updateFragment(current, workInProgress, renderLanes) {
  var nextChildren = workInProgress.pendingProps;
  reconcileChildren(current, workInProgress, nextChildren, renderLanes);
  return workInProgress.child;
}

function updateMode(current, workInProgress, renderLanes) {
  var nextChildren = workInProgress.pendingProps.children;
  reconcileChildren(current, workInProgress, nextChildren, renderLanes);
  return workInProgress.child;
}

function updateProfiler(current, workInProgress, renderLanes) {
  {
    workInProgress.flags |= Update; // Reset effect durations for the next eventual effect phase.
    // These are reset during render to allow the DevTools commit hook a chance to read them,

    var stateNode = workInProgress.stateNode;
    stateNode.effectDuration = 0;
    stateNode.passiveEffectDuration = 0;
  }

  var nextProps = workInProgress.pendingProps;
  var nextChildren = nextProps.children;
  reconcileChildren(current, workInProgress, nextChildren, renderLanes);
  return workInProgress.child;
}

function markRef(current, workInProgress) {
  var ref = workInProgress.ref;

  if (current === null && ref !== null || current !== null && current.ref !== ref) {
    // Schedule a Ref effect
    workInProgress.flags |= Ref;
  }
}

function updateFunctionComponent(current, workInProgress, Component, nextProps, renderLanes) {
  {
    if (workInProgress.type !== workInProgress.elementType) {
      // Lazy component props can't be validated in createElement
      // because they're only guaranteed to be resolved here.
      var innerPropTypes = Component.propTypes;

      if (innerPropTypes) {
        checkPropTypes(innerPropTypes, nextProps, // Resolved props
        'prop', getComponentName(Component));
      }
    }
  }

  var context;

  {
    var unmaskedContext = getUnmaskedContext(workInProgress, Component, true);
    context = getMaskedContext(workInProgress, unmaskedContext);
  }

  var nextChildren;
  prepareToReadContext(workInProgress, renderLanes);

  {
    ReactCurrentOwner$1.current = workInProgress;
    setIsRendering(true);
    nextChildren = renderWithHooks(current, workInProgress, Component, nextProps, context, renderLanes);

    if ( workInProgress.mode & StrictMode) {
      disableLogs();

      try {
        nextChildren = renderWithHooks(current, workInProgress, Component, nextProps, context, renderLanes);
      } finally {
        reenableLogs();
      }
    }

    setIsRendering(false);
  }

  if (current !== null && !didReceiveUpdate) {
    bailoutHooks(current, workInProgress, renderLanes);
    return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);
  } // React DevTools reads this flag.


  workInProgress.flags |= PerformedWork;
  reconcileChildren(current, workInProgress, nextChildren, renderLanes);
  return workInProgress.child;
}

function updateClassComponent(current, workInProgress, Component, nextProps, renderLanes) {
  {
    if (workInProgress.type !== workInProgress.elementType) {
      // Lazy component props can't be validated in createElement
      // because they're only guaranteed to be resolved here.
      var innerPropTypes = Component.propTypes;

      if (innerPropTypes) {
        checkPropTypes(innerPropTypes, nextProps, // Resolved props
        'prop', getComponentName(Component));
      }
    }
  } // Push context providers early to prevent context stack mismatches.
  // During mounting we don't know the child context yet as the instance doesn't exist.
  // We will invalidate the child context in finishClassComponent() right after rendering.


  var hasContext;

  if (isContextProvider(Component)) {
    hasContext = true;
    pushContextProvider(workInProgress);
  } else {
    hasContext = false;
  }

  prepareToReadContext(workInProgress, renderLanes);
  var instance = workInProgress.stateNode;
  var shouldUpdate;

  if (instance === null) {
    if (current !== null) {
      // A class component without an instance only mounts if it suspended
      // inside a non-concurrent tree, in an inconsistent state. We want to
      // treat it like a new mount, even though an empty version of it already
      // committed. Disconnect the alternate pointers.
      current.alternate = null;
      workInProgress.alternate = null; // Since this is conceptually a new fiber, schedule a Placement effect

      workInProgress.flags |= Placement;
    } // In the initial pass we might need to construct the instance.


    constructClassInstance(workInProgress, Component, nextProps);
    mountClassInstance(workInProgress, Component, nextProps, renderLanes);
    shouldUpdate = true;
  } else if (current === null) {
    // In a resume, we'll already have an instance we can reuse.
    shouldUpdate = resumeMountClassInstance(workInProgress, Component, nextProps, renderLanes);
  } else {
    shouldUpdate = updateClassInstance(current, workInProgress, Component, nextProps, renderLanes);
  }

  var nextUnitOfWork = finishClassComponent(current, workInProgress, Component, shouldUpdate, hasContext, renderLanes);

  {
    var inst = workInProgress.stateNode;

    if (shouldUpdate && inst.props !== nextProps) {
      if (!didWarnAboutReassigningProps) {
        error('It looks like %s is reassigning its own `this.props` while rendering. ' + 'This is not supported and can lead to confusing bugs.', getComponentName(workInProgress.type) || 'a component');
      }

      didWarnAboutReassigningProps = true;
    }
  }

  return nextUnitOfWork;
}

function finishClassComponent(current, workInProgress, Component, shouldUpdate, hasContext, renderLanes) {
  // Refs should update even if shouldComponentUpdate returns false
  markRef(current, workInProgress);
  var didCaptureError = (workInProgress.flags & DidCapture) !== NoFlags;

  if (!shouldUpdate && !didCaptureError) {
    // Context providers should defer to sCU for rendering
    if (hasContext) {
      invalidateContextProvider(workInProgress, Component, false);
    }

    return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);
  }

  var instance = workInProgress.stateNode; // Rerender

  ReactCurrentOwner$1.current = workInProgress;
  var nextChildren;

  if (didCaptureError && typeof Component.getDerivedStateFromError !== 'function') {
    // If we captured an error, but getDerivedStateFromError is not defined,
    // unmount all the children. componentDidCatch will schedule an update to
    // re-render a fallback. This is temporary until we migrate everyone to
    // the new API.
    // TODO: Warn in a future release.
    nextChildren = null;

    {
      stopProfilerTimerIfRunning();
    }
  } else {
    {
      setIsRendering(true);
      nextChildren = instance.render();

      if ( workInProgress.mode & StrictMode) {
        disableLogs();

        try {
          instance.render();
        } finally {
          reenableLogs();
        }
      }

      setIsRendering(false);
    }
  } // React DevTools reads this flag.


  workInProgress.flags |= PerformedWork;

  if (current !== null && didCaptureError) {
    // If we're recovering from an error, reconcile without reusing any of
    // the existing children. Conceptually, the normal children and the children
    // that are shown on error are two different sets, so we shouldn't reuse
    // normal children even if their identities match.
    forceUnmountCurrentAndReconcile(current, workInProgress, nextChildren, renderLanes);
  } else {
    reconcileChildren(current, workInProgress, nextChildren, renderLanes);
  } // Memoize state using the values we just used to render.
  // TODO: Restructure so we never read values from the instance.


  workInProgress.memoizedState = instance.state; // The context might have changed so we need to recalculate it.

  if (hasContext) {
    invalidateContextProvider(workInProgress, Component, true);
  }

  return workInProgress.child;
}

function pushHostRootContext(workInProgress) {
  var root = workInProgress.stateNode;

  if (root.pendingContext) {
    pushTopLevelContextObject(workInProgress, root.pendingContext, root.pendingContext !== root.context);
  } else if (root.context) {
    // Should always be set
    pushTopLevelContextObject(workInProgress, root.context, false);
  }

  pushHostContainer(workInProgress, root.containerInfo);
}

function updateHostRoot(current, workInProgress, renderLanes) {
  pushHostRootContext(workInProgress);
  var updateQueue = workInProgress.updateQueue;

  if (!(current !== null && updateQueue !== null)) {
    {
      throw Error( "If the root does not have an updateQueue, we should have already bailed out. This error is likely caused by a bug in React. Please file an issue." );
    }
  }

  var nextProps = workInProgress.pendingProps;
  var prevState = workInProgress.memoizedState;
  var prevChildren = prevState !== null ? prevState.element : null;
  cloneUpdateQueue(current, workInProgress);
  processUpdateQueue(workInProgress, nextProps, null, renderLanes);
  var nextState = workInProgress.memoizedState; // Caution: React DevTools currently depends on this property
  // being called "element".

  var nextChildren = nextState.element;

  if (nextChildren === prevChildren) {
    resetHydrationState();
    return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);
  }

  var root = workInProgress.stateNode;

  if (root.hydrate && enterHydrationState(workInProgress)) {
    // If we don't have any current children this might be the first pass.
    // We always try to hydrate. If this isn't a hydration pass there won't
    // be any children to hydrate which is effectively the same thing as
    // not hydrating.
    {
      var mutableSourceEagerHydrationData = root.mutableSourceEagerHydrationData;

      if (mutableSourceEagerHydrationData != null) {
        for (var i = 0; i < mutableSourceEagerHydrationData.length; i += 2) {
          var mutableSource = mutableSourceEagerHydrationData[i];
          var version = mutableSourceEagerHydrationData[i + 1];
          setWorkInProgressVersion(mutableSource, version);
        }
      }
    }

    var child = mountChildFibers(workInProgress, null, nextChildren, renderLanes);
    workInProgress.child = child;
    var node = child;

    while (node) {
      // Mark each child as hydrating. This is a fast path to know whether this
      // tree is part of a hydrating tree. This is used to determine if a child
      // node has fully mounted yet, and for scheduling event replaying.
      // Conceptually this is similar to Placement in that a new subtree is
      // inserted into the React tree here. It just happens to not need DOM
      // mutations because it already exists.
      node.flags = node.flags & ~Placement | Hydrating;
      node = node.sibling;
    }
  } else {
    // Otherwise reset hydration state in case we aborted and resumed another
    // root.
    reconcileChildren(current, workInProgress, nextChildren, renderLanes);
    resetHydrationState();
  }

  return workInProgress.child;
}

function updateHostComponent(current, workInProgress, renderLanes) {
  pushHostContext(workInProgress);

  if (current === null) {
    tryToClaimNextHydratableInstance(workInProgress);
  }

  var type = workInProgress.type;
  var nextProps = workInProgress.pendingProps;
  var prevProps = current !== null ? current.memoizedProps : null;
  var nextChildren = nextProps.children;
  var isDirectTextChild = shouldSetTextContent(type, nextProps);

  if (isDirectTextChild) {
    // We special case a direct text child of a host node. This is a common
    // case. We won't handle it as a reified child. We will instead handle
    // this in the host environment that also has access to this prop. That
    // avoids allocating another HostText fiber and traversing it.
    nextChildren = null;
  } else if (prevProps !== null && shouldSetTextContent(type, prevProps)) {
    // If we're switching from a direct text child to a normal child, or to
    // empty, we need to schedule the text content to be reset.
    workInProgress.flags |= ContentReset;
  }

  markRef(current, workInProgress);
  reconcileChildren(current, workInProgress, nextChildren, renderLanes);
  return workInProgress.child;
}

function updateHostText(current, workInProgress) {
  if (current === null) {
    tryToClaimNextHydratableInstance(workInProgress);
  } // Nothing to do here. This is terminal. We'll do the completion step
  // immediately after.


  return null;
}

function mountLazyComponent(_current, workInProgress, elementType, updateLanes, renderLanes) {
  if (_current !== null) {
    // A lazy component only mounts if it suspended inside a non-
    // concurrent tree, in an inconsistent state. We want to treat it like
    // a new mount, even though an empty version of it already committed.
    // Disconnect the alternate pointers.
    _current.alternate = null;
    workInProgress.alternate = null; // Since this is conceptually a new fiber, schedule a Placement effect

    workInProgress.flags |= Placement;
  }

  var props = workInProgress.pendingProps;
  var lazyComponent = elementType;
  var payload = lazyComponent._payload;
  var init = lazyComponent._init;
  var Component = init(payload); // Store the unwrapped component in the type.

  workInProgress.type = Component;
  var resolvedTag = workInProgress.tag = resolveLazyComponentTag(Component);
  var resolvedProps = resolveDefaultProps(Component, props);
  var child;

  switch (resolvedTag) {
    case FunctionComponent:
      {
        {
          validateFunctionComponentInDev(workInProgress, Component);
          workInProgress.type = Component = resolveFunctionForHotReloading(Component);
        }

        child = updateFunctionComponent(null, workInProgress, Component, resolvedProps, renderLanes);
        return child;
      }

    case ClassComponent:
      {
        {
          workInProgress.type = Component = resolveClassForHotReloading(Component);
        }

        child = updateClassComponent(null, workInProgress, Component, resolvedProps, renderLanes);
        return child;
      }

    case ForwardRef:
      {
        {
          workInProgress.type = Component = resolveForwardRefForHotReloading(Component);
        }

        child = updateForwardRef(null, workInProgress, Component, resolvedProps, renderLanes);
        return child;
      }

    case MemoComponent:
      {
        {
          if (workInProgress.type !== workInProgress.elementType) {
            var outerPropTypes = Component.propTypes;

            if (outerPropTypes) {
              checkPropTypes(outerPropTypes, resolvedProps, // Resolved for outer only
              'prop', getComponentName(Component));
            }
          }
        }

        child = updateMemoComponent(null, workInProgress, Component, resolveDefaultProps(Component.type, resolvedProps), // The inner type can have defaults too
        updateLanes, renderLanes);
        return child;
      }
  }

  var hint = '';

  {
    if (Component !== null && typeof Component === 'object' && Component.$$typeof === REACT_LAZY_TYPE) {
      hint = ' Did you wrap a component in React.lazy() more than once?';
    }
  } // This message intentionally doesn't mention ForwardRef or MemoComponent
  // because the fact that it's a separate type of work is an
  // implementation detail.


  {
    {
      throw Error( "Element type is invalid. Received a promise that resolves to: " + Component + ". Lazy element type must resolve to a class or function." + hint );
    }
  }
}

function mountIncompleteClassComponent(_current, workInProgress, Component, nextProps, renderLanes) {
  if (_current !== null) {
    // An incomplete component only mounts if it suspended inside a non-
    // concurrent tree, in an inconsistent state. We want to treat it like
    // a new mount, even though an empty version of it already committed.
    // Disconnect the alternate pointers.
    _current.alternate = null;
    workInProgress.alternate = null; // Since this is conceptually a new fiber, schedule a Placement effect

    workInProgress.flags |= Placement;
  } // Promote the fiber to a class and try rendering again.


  workInProgress.tag = ClassComponent; // The rest of this function is a fork of `updateClassComponent`
  // Push context providers early to prevent context stack mismatches.
  // During mounting we don't know the child context yet as the instance doesn't exist.
  // We will invalidate the child context in finishClassComponent() right after rendering.

  var hasContext;

  if (isContextProvider(Component)) {
    hasContext = true;
    pushContextProvider(workInProgress);
  } else {
    hasContext = false;
  }

  prepareToReadContext(workInProgress, renderLanes);
  constructClassInstance(workInProgress, Component, nextProps);
  mountClassInstance(workInProgress, Component, nextProps, renderLanes);
  return finishClassComponent(null, workInProgress, Component, true, hasContext, renderLanes);
}

function mountIndeterminateComponent(_current, workInProgress, Component, renderLanes) {
  if (_current !== null) {
    // An indeterminate component only mounts if it suspended inside a non-
    // concurrent tree, in an inconsistent state. We want to treat it like
    // a new mount, even though an empty version of it already committed.
    // Disconnect the alternate pointers.
    _current.alternate = null;
    workInProgress.alternate = null; // Since this is conceptually a new fiber, schedule a Placement effect

    workInProgress.flags |= Placement;
  }

  var props = workInProgress.pendingProps;
  var context;

  {
    var unmaskedContext = getUnmaskedContext(workInProgress, Component, false);
    context = getMaskedContext(workInProgress, unmaskedContext);
  }

  prepareToReadContext(workInProgress, renderLanes);
  var value;

  {
    if (Component.prototype && typeof Component.prototype.render === 'function') {
      var componentName = getComponentName(Component) || 'Unknown';

      if (!didWarnAboutBadClass[componentName]) {
        error("The <%s /> component appears to have a render method, but doesn't extend React.Component. " + 'This is likely to cause errors. Change %s to extend React.Component instead.', componentName, componentName);

        didWarnAboutBadClass[componentName] = true;
      }
    }

    if (workInProgress.mode & StrictMode) {
      ReactStrictModeWarnings.recordLegacyContextWarning(workInProgress, null);
    }

    setIsRendering(true);
    ReactCurrentOwner$1.current = workInProgress;
    value = renderWithHooks(null, workInProgress, Component, props, context, renderLanes);
    setIsRendering(false);
  } // React DevTools reads this flag.


  workInProgress.flags |= PerformedWork;

  {
    // Support for module components is deprecated and is removed behind a flag.
    // Whether or not it would crash later, we want to show a good message in DEV first.
    if (typeof value === 'object' && value !== null && typeof value.render === 'function' && value.$$typeof === undefined) {
      var _componentName = getComponentName(Component) || 'Unknown';

      if (!didWarnAboutModulePatternComponent[_componentName]) {
        error('The <%s /> component appears to be a function component that returns a class instance. ' + 'Change %s to a class that extends React.Component instead. ' + "If you can't use a class try assigning the prototype on the function as a workaround. " + "`%s.prototype = React.Component.prototype`. Don't use an arrow function since it " + 'cannot be called with `new` by React.', _componentName, _componentName, _componentName);

        didWarnAboutModulePatternComponent[_componentName] = true;
      }
    }
  }

  if ( // Run these checks in production only if the flag is off.
  // Eventually we'll delete this branch altogether.
   typeof value === 'object' && value !== null && typeof value.render === 'function' && value.$$typeof === undefined) {
    {
      var _componentName2 = getComponentName(Component) || 'Unknown';

      if (!didWarnAboutModulePatternComponent[_componentName2]) {
        error('The <%s /> component appears to be a function component that returns a class instance. ' + 'Change %s to a class that extends React.Component instead. ' + "If you can't use a class try assigning the prototype on the function as a workaround. " + "`%s.prototype = React.Component.prototype`. Don't use an arrow function since it " + 'cannot be called with `new` by React.', _componentName2, _componentName2, _componentName2);

        didWarnAboutModulePatternComponent[_componentName2] = true;
      }
    } // Proceed under the assumption that this is a class instance


    workInProgress.tag = ClassComponent; // Throw out any hooks that were used.

    workInProgress.memoizedState = null;
    workInProgress.updateQueue = null; // Push context providers early to prevent context stack mismatches.
    // During mounting we don't know the child context yet as the instance doesn't exist.
    // We will invalidate the child context in finishClassComponent() right after rendering.

    var hasContext = false;

    if (isContextProvider(Component)) {
      hasContext = true;
      pushContextProvider(workInProgress);
    } else {
      hasContext = false;
    }

    workInProgress.memoizedState = value.state !== null && value.state !== undefined ? value.state : null;
    initializeUpdateQueue(workInProgress);
    var getDerivedStateFromProps = Component.getDerivedStateFromProps;

    if (typeof getDerivedStateFromProps === 'function') {
      applyDerivedStateFromProps(workInProgress, Component, getDerivedStateFromProps, props);
    }

    adoptClassInstance(workInProgress, value);
    mountClassInstance(workInProgress, Component, props, renderLanes);
    return finishClassComponent(null, workInProgress, Component, true, hasContext, renderLanes);
  } else {
    // Proceed under the assumption that this is a function component
    workInProgress.tag = FunctionComponent;

    {

      if ( workInProgress.mode & StrictMode) {
        disableLogs();

        try {
          value = renderWithHooks(null, workInProgress, Component, props, context, renderLanes);
        } finally {
          reenableLogs();
        }
      }
    }

    reconcileChildren(null, workInProgress, value, renderLanes);

    {
      validateFunctionComponentInDev(workInProgress, Component);
    }

    return workInProgress.child;
  }
}

function validateFunctionComponentInDev(workInProgress, Component) {
  {
    if (Component) {
      if (Component.childContextTypes) {
        error('%s(...): childContextTypes cannot be defined on a function component.', Component.displayName || Component.name || 'Component');
      }
    }

    if (workInProgress.ref !== null) {
      var info = '';
      var ownerName = getCurrentFiberOwnerNameInDevOrNull();

      if (ownerName) {
        info += '\n\nCheck the render method of `' + ownerName + '`.';
      }

      var warningKey = ownerName || workInProgress._debugID || '';
      var debugSource = workInProgress._debugSource;

      if (debugSource) {
        warningKey = debugSource.fileName + ':' + debugSource.lineNumber;
      }

      if (!didWarnAboutFunctionRefs[warningKey]) {
        didWarnAboutFunctionRefs[warningKey] = true;

        error('Function components cannot be given refs. ' + 'Attempts to access this ref will fail. ' + 'Did you mean to use React.forwardRef()?%s', info);
      }
    }

    if (typeof Component.getDerivedStateFromProps === 'function') {
      var _componentName3 = getComponentName(Component) || 'Unknown';

      if (!didWarnAboutGetDerivedStateOnFunctionComponent[_componentName3]) {
        error('%s: Function components do not support getDerivedStateFromProps.', _componentName3);

        didWarnAboutGetDerivedStateOnFunctionComponent[_componentName3] = true;
      }
    }

    if (typeof Component.contextType === 'object' && Component.contextType !== null) {
      var _componentName4 = getComponentName(Component) || 'Unknown';

      if (!didWarnAboutContextTypeOnFunctionComponent[_componentName4]) {
        error('%s: Function components do not support contextType.', _componentName4);

        didWarnAboutContextTypeOnFunctionComponent[_componentName4] = true;
      }
    }
  }
}

var SUSPENDED_MARKER = {
  dehydrated: null,
  retryLane: NoLane
};

function mountSuspenseOffscreenState(renderLanes) {
  return {
    baseLanes: renderLanes
  };
}

function updateSuspenseOffscreenState(prevOffscreenState, renderLanes) {
  return {
    baseLanes: mergeLanes(prevOffscreenState.baseLanes, renderLanes)
  };
} // TODO: Probably should inline this back


function shouldRemainOnFallback(suspenseContext, current, workInProgress, renderLanes) {
  // If we're already showing a fallback, there are cases where we need to
  // remain on that fallback regardless of whether the content has resolved.
  // For example, SuspenseList coordinates when nested content appears.
  if (current !== null) {
    var suspenseState = current.memoizedState;

    if (suspenseState === null) {
      // Currently showing content. Don't hide it, even if ForceSuspenseFallack
      // is true. More precise name might be "ForceRemainSuspenseFallback".
      // Note: This is a factoring smell. Can't remain on a fallback if there's
      // no fallback to remain on.
      return false;
    }
  } // Not currently showing content. Consult the Suspense context.


  return hasSuspenseContext(suspenseContext, ForceSuspenseFallback);
}

function getRemainingWorkInPrimaryTree(current, renderLanes) {
  // TODO: Should not remove render lanes that were pinged during this render
  return removeLanes(current.childLanes, renderLanes);
}

function updateSuspenseComponent(current, workInProgress, renderLanes) {
  var nextProps = workInProgress.pendingProps; // This is used by DevTools to force a boundary to suspend.

  {
    if (shouldSuspend(workInProgress)) {
      workInProgress.flags |= DidCapture;
    }
  }

  var suspenseContext = suspenseStackCursor.current;
  var showFallback = false;
  var didSuspend = (workInProgress.flags & DidCapture) !== NoFlags;

  if (didSuspend || shouldRemainOnFallback(suspenseContext, current)) {
    // Something in this boundary's subtree already suspended. Switch to
    // rendering the fallback children.
    showFallback = true;
    workInProgress.flags &= ~DidCapture;
  } else {
    // Attempting the main content
    if (current === null || current.memoizedState !== null) {
      // This is a new mount or this boundary is already showing a fallback state.
      // Mark this subtree context as having at least one invisible parent that could
      // handle the fallback state.
      // Boundaries without fallbacks or should be avoided are not considered since
      // they cannot handle preferred fallback states.
      if (nextProps.fallback !== undefined && nextProps.unstable_avoidThisFallback !== true) {
        suspenseContext = addSubtreeSuspenseContext(suspenseContext, InvisibleParentSuspenseContext);
      }
    }
  }

  suspenseContext = setDefaultShallowSuspenseContext(suspenseContext);
  pushSuspenseContext(workInProgress, suspenseContext); // OK, the next part is confusing. We're about to reconcile the Suspense
  // boundary's children. This involves some custom reconcilation logic. Two
  // main reasons this is so complicated.
  //
  // First, Legacy Mode has different semantics for backwards compatibility. The
  // primary tree will commit in an inconsistent state, so when we do the
  // second pass to render the fallback, we do some exceedingly, uh, clever
  // hacks to make that not totally break. Like transferring effects and
  // deletions from hidden tree. In Concurrent Mode, it's much simpler,
  // because we bailout on the primary tree completely and leave it in its old
  // state, no effects. Same as what we do for Offscreen (except that
  // Offscreen doesn't have the first render pass).
  //
  // Second is hydration. During hydration, the Suspense fiber has a slightly
  // different layout, where the child points to a dehydrated fragment, which
  // contains the DOM rendered by the server.
  //
  // Third, even if you set all that aside, Suspense is like error boundaries in
  // that we first we try to render one tree, and if that fails, we render again
  // and switch to a different tree. Like a try/catch block. So we have to track
  // which branch we're currently rendering. Ideally we would model this using
  // a stack.

  if (current === null) {
    // Initial mount
    // If we're currently hydrating, try to hydrate this boundary.
    // But only if this has a fallback.
    if (nextProps.fallback !== undefined) {
      tryToClaimNextHydratableInstance(workInProgress); // This could've been a dehydrated suspense component.
    }

    var nextPrimaryChildren = nextProps.children;
    var nextFallbackChildren = nextProps.fallback;

    if (showFallback) {
      var fallbackFragment = mountSuspenseFallbackChildren(workInProgress, nextPrimaryChildren, nextFallbackChildren, renderLanes);
      var primaryChildFragment = workInProgress.child;
      primaryChildFragment.memoizedState = mountSuspenseOffscreenState(renderLanes);
      workInProgress.memoizedState = SUSPENDED_MARKER;
      return fallbackFragment;
    } else if (typeof nextProps.unstable_expectedLoadTime === 'number') {
      // This is a CPU-bound tree. Skip this tree and show a placeholder to
      // unblock the surrounding content. Then immediately retry after the
      // initial commit.
      var _fallbackFragment = mountSuspenseFallbackChildren(workInProgress, nextPrimaryChildren, nextFallbackChildren, renderLanes);

      var _primaryChildFragment = workInProgress.child;
      _primaryChildFragment.memoizedState = mountSuspenseOffscreenState(renderLanes);
      workInProgress.memoizedState = SUSPENDED_MARKER; // Since nothing actually suspended, there will nothing to ping this to
      // get it started back up to attempt the next item. While in terms of
      // priority this work has the same priority as this current render, it's
      // not part of the same transition once the transition has committed. If
      // it's sync, we still want to yield so that it can be painted.
      // Conceptually, this is really the same as pinging. We can use any
      // RetryLane even if it's the one currently rendering since we're leaving
      // it behind on this node.

      workInProgress.lanes = SomeRetryLane;

      {
        markSpawnedWork(SomeRetryLane);
      }

      return _fallbackFragment;
    } else {
      return mountSuspensePrimaryChildren(workInProgress, nextPrimaryChildren, renderLanes);
    }
  } else {
    // This is an update.
    // If the current fiber has a SuspenseState, that means it's already showing
    // a fallback.
    var prevState = current.memoizedState;

    if (prevState !== null) {

      if (showFallback) {
        var _nextFallbackChildren2 = nextProps.fallback;
        var _nextPrimaryChildren2 = nextProps.children;

        var _fallbackChildFragment = updateSuspenseFallbackChildren(current, workInProgress, _nextPrimaryChildren2, _nextFallbackChildren2, renderLanes);

        var _primaryChildFragment3 = workInProgress.child;
        var prevOffscreenState = current.child.memoizedState;
        _primaryChildFragment3.memoizedState = prevOffscreenState === null ? mountSuspenseOffscreenState(renderLanes) : updateSuspenseOffscreenState(prevOffscreenState, renderLanes);
        _primaryChildFragment3.childLanes = getRemainingWorkInPrimaryTree(current, renderLanes);
        workInProgress.memoizedState = SUSPENDED_MARKER;
        return _fallbackChildFragment;
      } else {
        var _nextPrimaryChildren3 = nextProps.children;

        var _primaryChildFragment4 = updateSuspensePrimaryChildren(current, workInProgress, _nextPrimaryChildren3, renderLanes);

        workInProgress.memoizedState = null;
        return _primaryChildFragment4;
      }
    } else {
      // The current tree is not already showing a fallback.
      if (showFallback) {
        // Timed out.
        var _nextFallbackChildren3 = nextProps.fallback;
        var _nextPrimaryChildren4 = nextProps.children;

        var _fallbackChildFragment2 = updateSuspenseFallbackChildren(current, workInProgress, _nextPrimaryChildren4, _nextFallbackChildren3, renderLanes);

        var _primaryChildFragment5 = workInProgress.child;
        var _prevOffscreenState = current.child.memoizedState;
        _primaryChildFragment5.memoizedState = _prevOffscreenState === null ? mountSuspenseOffscreenState(renderLanes) : updateSuspenseOffscreenState(_prevOffscreenState, renderLanes);
        _primaryChildFragment5.childLanes = getRemainingWorkInPrimaryTree(current, renderLanes); // Skip the primary children, and continue working on the
        // fallback children.

        workInProgress.memoizedState = SUSPENDED_MARKER;
        return _fallbackChildFragment2;
      } else {
        // Still haven't timed out. Continue rendering the children, like we
        // normally do.
        var _nextPrimaryChildren5 = nextProps.children;

        var _primaryChildFragment6 = updateSuspensePrimaryChildren(current, workInProgress, _nextPrimaryChildren5, renderLanes);

        workInProgress.memoizedState = null;
        return _primaryChildFragment6;
      }
    }
  }
}

function mountSuspensePrimaryChildren(workInProgress, primaryChildren, renderLanes) {
  var mode = workInProgress.mode;
  var primaryChildProps = {
    mode: 'visible',
    children: primaryChildren
  };
  var primaryChildFragment = createFiberFromOffscreen(primaryChildProps, mode, renderLanes, null);
  primaryChildFragment.return = workInProgress;
  workInProgress.child = primaryChildFragment;
  return primaryChildFragment;
}

function mountSuspenseFallbackChildren(workInProgress, primaryChildren, fallbackChildren, renderLanes) {
  var mode = workInProgress.mode;
  var progressedPrimaryFragment = workInProgress.child;
  var primaryChildProps = {
    mode: 'hidden',
    children: primaryChildren
  };
  var primaryChildFragment;
  var fallbackChildFragment;

  if ((mode & BlockingMode) === NoMode && progressedPrimaryFragment !== null) {
    // In legacy mode, we commit the primary tree as if it successfully
    // completed, even though it's in an inconsistent state.
    primaryChildFragment = progressedPrimaryFragment;
    primaryChildFragment.childLanes = NoLanes;
    primaryChildFragment.pendingProps = primaryChildProps;

    if ( workInProgress.mode & ProfileMode) {
      // Reset the durations from the first pass so they aren't included in the
      // final amounts. This seems counterintuitive, since we're intentionally
      // not measuring part of the render phase, but this makes it match what we
      // do in Concurrent Mode.
      primaryChildFragment.actualDuration = 0;
      primaryChildFragment.actualStartTime = -1;
      primaryChildFragment.selfBaseDuration = 0;
      primaryChildFragment.treeBaseDuration = 0;
    }

    fallbackChildFragment = createFiberFromFragment(fallbackChildren, mode, renderLanes, null);
  } else {
    primaryChildFragment = createFiberFromOffscreen(primaryChildProps, mode, NoLanes, null);
    fallbackChildFragment = createFiberFromFragment(fallbackChildren, mode, renderLanes, null);
  }

  primaryChildFragment.return = workInProgress;
  fallbackChildFragment.return = workInProgress;
  primaryChildFragment.sibling = fallbackChildFragment;
  workInProgress.child = primaryChildFragment;
  return fallbackChildFragment;
}

function createWorkInProgressOffscreenFiber(current, offscreenProps) {
  // The props argument to `createWorkInProgress` is `any` typed, so we use this
  // wrapper function to constrain it.
  return createWorkInProgress(current, offscreenProps);
}

function updateSuspensePrimaryChildren(current, workInProgress, primaryChildren, renderLanes) {
  var currentPrimaryChildFragment = current.child;
  var currentFallbackChildFragment = currentPrimaryChildFragment.sibling;
  var primaryChildFragment = createWorkInProgressOffscreenFiber(currentPrimaryChildFragment, {
    mode: 'visible',
    children: primaryChildren
  });

  if ((workInProgress.mode & BlockingMode) === NoMode) {
    primaryChildFragment.lanes = renderLanes;
  }

  primaryChildFragment.return = workInProgress;
  primaryChildFragment.sibling = null;

  if (currentFallbackChildFragment !== null) {
    // Delete the fallback child fragment
    currentFallbackChildFragment.nextEffect = null;
    currentFallbackChildFragment.flags = Deletion;
    workInProgress.firstEffect = workInProgress.lastEffect = currentFallbackChildFragment;
  }

  workInProgress.child = primaryChildFragment;
  return primaryChildFragment;
}

function updateSuspenseFallbackChildren(current, workInProgress, primaryChildren, fallbackChildren, renderLanes) {
  var mode = workInProgress.mode;
  var currentPrimaryChildFragment = current.child;
  var currentFallbackChildFragment = currentPrimaryChildFragment.sibling;
  var primaryChildProps = {
    mode: 'hidden',
    children: primaryChildren
  };
  var primaryChildFragment;

  if ( // In legacy mode, we commit the primary tree as if it successfully
  // completed, even though it's in an inconsistent state.
  (mode & BlockingMode) === NoMode && // Make sure we're on the second pass, i.e. the primary child fragment was
  // already cloned. In legacy mode, the only case where this isn't true is
  // when DevTools forces us to display a fallback; we skip the first render
  // pass entirely and go straight to rendering the fallback. (In Concurrent
  // Mode, SuspenseList can also trigger this scenario, but this is a legacy-
  // only codepath.)
  workInProgress.child !== currentPrimaryChildFragment) {
    var progressedPrimaryFragment = workInProgress.child;
    primaryChildFragment = progressedPrimaryFragment;
    primaryChildFragment.childLanes = NoLanes;
    primaryChildFragment.pendingProps = primaryChildProps;

    if ( workInProgress.mode & ProfileMode) {
      // Reset the durations from the first pass so they aren't included in the
      // final amounts. This seems counterintuitive, since we're intentionally
      // not measuring part of the render phase, but this makes it match what we
      // do in Concurrent Mode.
      primaryChildFragment.actualDuration = 0;
      primaryChildFragment.actualStartTime = -1;
      primaryChildFragment.selfBaseDuration = currentPrimaryChildFragment.selfBaseDuration;
      primaryChildFragment.treeBaseDuration = currentPrimaryChildFragment.treeBaseDuration;
    } // The fallback fiber was added as a deletion effect during the first pass.
    // However, since we're going to remain on the fallback, we no longer want
    // to delete it. So we need to remove it from the list. Deletions are stored
    // on the same list as effects. We want to keep the effects from the primary
    // tree. So we copy the primary child fragment's effect list, which does not
    // include the fallback deletion effect.


    var progressedLastEffect = primaryChildFragment.lastEffect;

    if (progressedLastEffect !== null) {
      workInProgress.firstEffect = primaryChildFragment.firstEffect;
      workInProgress.lastEffect = progressedLastEffect;
      progressedLastEffect.nextEffect = null;
    } else {
      // TODO: Reset this somewhere else? Lol legacy mode is so weird.
      workInProgress.firstEffect = workInProgress.lastEffect = null;
    }
  } else {
    primaryChildFragment = createWorkInProgressOffscreenFiber(currentPrimaryChildFragment, primaryChildProps);
  }

  var fallbackChildFragment;

  if (currentFallbackChildFragment !== null) {
    fallbackChildFragment = createWorkInProgress(currentFallbackChildFragment, fallbackChildren);
  } else {
    fallbackChildFragment = createFiberFromFragment(fallbackChildren, mode, renderLanes, null); // Needs a placement effect because the parent (the Suspense boundary) already
    // mounted but this is a new fiber.

    fallbackChildFragment.flags |= Placement;
  }

  fallbackChildFragment.return = workInProgress;
  primaryChildFragment.return = workInProgress;
  primaryChildFragment.sibling = fallbackChildFragment;
  workInProgress.child = primaryChildFragment;
  return fallbackChildFragment;
}

function scheduleWorkOnFiber(fiber, renderLanes) {
  fiber.lanes = mergeLanes(fiber.lanes, renderLanes);
  var alternate = fiber.alternate;

  if (alternate !== null) {
    alternate.lanes = mergeLanes(alternate.lanes, renderLanes);
  }

  scheduleWorkOnParentPath(fiber.return, renderLanes);
}

function propagateSuspenseContextChange(workInProgress, firstChild, renderLanes) {
  // Mark any Suspense boundaries with fallbacks as having work to do.
  // If they were previously forced into fallbacks, they may now be able
  // to unblock.
  var node = firstChild;

  while (node !== null) {
    if (node.tag === SuspenseComponent) {
      var state = node.memoizedState;

      if (state !== null) {
        scheduleWorkOnFiber(node, renderLanes);
      }
    } else if (node.tag === SuspenseListComponent) {
      // If the tail is hidden there might not be an Suspense boundaries
      // to schedule work on. In this case we have to schedule it on the
      // list itself.
      // We don't have to traverse to the children of the list since
      // the list will propagate the change when it rerenders.
      scheduleWorkOnFiber(node, renderLanes);
    } else if (node.child !== null) {
      node.child.return = node;
      node = node.child;
      continue;
    }

    if (node === workInProgress) {
      return;
    }

    while (node.sibling === null) {
      if (node.return === null || node.return === workInProgress) {
        return;
      }

      node = node.return;
    }

    node.sibling.return = node.return;
    node = node.sibling;
  }
}

function findLastContentRow(firstChild) {
  // This is going to find the last row among these children that is already
  // showing content on the screen, as opposed to being in fallback state or
  // new. If a row has multiple Suspense boundaries, any of them being in the
  // fallback state, counts as the whole row being in a fallback state.
  // Note that the "rows" will be workInProgress, but any nested children
  // will still be current since we haven't rendered them yet. The mounted
  // order may not be the same as the new order. We use the new order.
  var row = firstChild;
  var lastContentRow = null;

  while (row !== null) {
    var currentRow = row.alternate; // New rows can't be content rows.

    if (currentRow !== null && findFirstSuspended(currentRow) === null) {
      lastContentRow = row;
    }

    row = row.sibling;
  }

  return lastContentRow;
}

function validateRevealOrder(revealOrder) {
  {
    if (revealOrder !== undefined && revealOrder !== 'forwards' && revealOrder !== 'backwards' && revealOrder !== 'together' && !didWarnAboutRevealOrder[revealOrder]) {
      didWarnAboutRevealOrder[revealOrder] = true;

      if (typeof revealOrder === 'string') {
        switch (revealOrder.toLowerCase()) {
          case 'together':
          case 'forwards':
          case 'backwards':
            {
              error('"%s" is not a valid value for revealOrder on <SuspenseList />. ' + 'Use lowercase "%s" instead.', revealOrder, revealOrder.toLowerCase());

              break;
            }

          case 'forward':
          case 'backward':
            {
              error('"%s" is not a valid value for revealOrder on <SuspenseList />. ' + 'React uses the -s suffix in the spelling. Use "%ss" instead.', revealOrder, revealOrder.toLowerCase());

              break;
            }

          default:
            error('"%s" is not a supported revealOrder on <SuspenseList />. ' + 'Did you mean "together", "forwards" or "backwards"?', revealOrder);

            break;
        }
      } else {
        error('%s is not a supported value for revealOrder on <SuspenseList />. ' + 'Did you mean "together", "forwards" or "backwards"?', revealOrder);
      }
    }
  }
}

function validateTailOptions(tailMode, revealOrder) {
  {
    if (tailMode !== undefined && !didWarnAboutTailOptions[tailMode]) {
      if (tailMode !== 'collapsed' && tailMode !== 'hidden') {
        didWarnAboutTailOptions[tailMode] = true;

        error('"%s" is not a supported value for tail on <SuspenseList />. ' + 'Did you mean "collapsed" or "hidden"?', tailMode);
      } else if (revealOrder !== 'forwards' && revealOrder !== 'backwards') {
        didWarnAboutTailOptions[tailMode] = true;

        error('<SuspenseList tail="%s" /> is only valid if revealOrder is ' + '"forwards" or "backwards". ' + 'Did you mean to specify revealOrder="forwards"?', tailMode);
      }
    }
  }
}

function validateSuspenseListNestedChild(childSlot, index) {
  {
    var isArray = Array.isArray(childSlot);
    var isIterable = !isArray && typeof getIteratorFn(childSlot) === 'function';

    if (isArray || isIterable) {
      var type = isArray ? 'array' : 'iterable';

      error('A nested %s was passed to row #%s in <SuspenseList />. Wrap it in ' + 'an additional SuspenseList to configure its revealOrder: ' + '<SuspenseList revealOrder=...> ... ' + '<SuspenseList revealOrder=...>{%s}</SuspenseList> ... ' + '</SuspenseList>', type, index, type);

      return false;
    }
  }

  return true;
}

function validateSuspenseListChildren(children, revealOrder) {
  {
    if ((revealOrder === 'forwards' || revealOrder === 'backwards') && children !== undefined && children !== null && children !== false) {
      if (Array.isArray(children)) {
        for (var i = 0; i < children.length; i++) {
          if (!validateSuspenseListNestedChild(children[i], i)) {
            return;
          }
        }
      } else {
        var iteratorFn = getIteratorFn(children);

        if (typeof iteratorFn === 'function') {
          var childrenIterator = iteratorFn.call(children);

          if (childrenIterator) {
            var step = childrenIterator.next();
            var _i = 0;

            for (; !step.done; step = childrenIterator.next()) {
              if (!validateSuspenseListNestedChild(step.value, _i)) {
                return;
              }

              _i++;
            }
          }
        } else {
          error('A single row was passed to a <SuspenseList revealOrder="%s" />. ' + 'This is not useful since it needs multiple rows. ' + 'Did you mean to pass multiple children or an array?', revealOrder);
        }
      }
    }
  }
}

function initSuspenseListRenderState(workInProgress, isBackwards, tail, lastContentRow, tailMode, lastEffectBeforeRendering) {
  var renderState = workInProgress.memoizedState;

  if (renderState === null) {
    workInProgress.memoizedState = {
      isBackwards: isBackwards,
      rendering: null,
      renderingStartTime: 0,
      last: lastContentRow,
      tail: tail,
      tailMode: tailMode,
      lastEffect: lastEffectBeforeRendering
    };
  } else {
    // We can reuse the existing object from previous renders.
    renderState.isBackwards = isBackwards;
    renderState.rendering = null;
    renderState.renderingStartTime = 0;
    renderState.last = lastContentRow;
    renderState.tail = tail;
    renderState.tailMode = tailMode;
    renderState.lastEffect = lastEffectBeforeRendering;
  }
} // This can end up rendering this component multiple passes.
// The first pass splits the children fibers into two sets. A head and tail.
// We first render the head. If anything is in fallback state, we do another
// pass through beginWork to rerender all children (including the tail) with
// the force suspend context. If the first render didn't have anything in
// in fallback state. Then we render each row in the tail one-by-one.
// That happens in the completeWork phase without going back to beginWork.


function updateSuspenseListComponent(current, workInProgress, renderLanes) {
  var nextProps = workInProgress.pendingProps;
  var revealOrder = nextProps.revealOrder;
  var tailMode = nextProps.tail;
  var newChildren = nextProps.children;
  validateRevealOrder(revealOrder);
  validateTailOptions(tailMode, revealOrder);
  validateSuspenseListChildren(newChildren, revealOrder);
  reconcileChildren(current, workInProgress, newChildren, renderLanes);
  var suspenseContext = suspenseStackCursor.current;
  var shouldForceFallback = hasSuspenseContext(suspenseContext, ForceSuspenseFallback);

  if (shouldForceFallback) {
    suspenseContext = setShallowSuspenseContext(suspenseContext, ForceSuspenseFallback);
    workInProgress.flags |= DidCapture;
  } else {
    var didSuspendBefore = current !== null && (current.flags & DidCapture) !== NoFlags;

    if (didSuspendBefore) {
      // If we previously forced a fallback, we need to schedule work
      // on any nested boundaries to let them know to try to render
      // again. This is the same as context updating.
      propagateSuspenseContextChange(workInProgress, workInProgress.child, renderLanes);
    }

    suspenseContext = setDefaultShallowSuspenseContext(suspenseContext);
  }

  pushSuspenseContext(workInProgress, suspenseContext);

  if ((workInProgress.mode & BlockingMode) === NoMode) {
    // In legacy mode, SuspenseList doesn't work so we just
    // use make it a noop by treating it as the default revealOrder.
    workInProgress.memoizedState = null;
  } else {
    switch (revealOrder) {
      case 'forwards':
        {
          var lastContentRow = findLastContentRow(workInProgress.child);
          var tail;

          if (lastContentRow === null) {
            // The whole list is part of the tail.
            // TODO: We could fast path by just rendering the tail now.
            tail = workInProgress.child;
            workInProgress.child = null;
          } else {
            // Disconnect the tail rows after the content row.
            // We're going to render them separately later.
            tail = lastContentRow.sibling;
            lastContentRow.sibling = null;
          }

          initSuspenseListRenderState(workInProgress, false, // isBackwards
          tail, lastContentRow, tailMode, workInProgress.lastEffect);
          break;
        }

      case 'backwards':
        {
          // We're going to find the first row that has existing content.
          // At the same time we're going to reverse the list of everything
          // we pass in the meantime. That's going to be our tail in reverse
          // order.
          var _tail = null;
          var row = workInProgress.child;
          workInProgress.child = null;

          while (row !== null) {
            var currentRow = row.alternate; // New rows can't be content rows.

            if (currentRow !== null && findFirstSuspended(currentRow) === null) {
              // This is the beginning of the main content.
              workInProgress.child = row;
              break;
            }

            var nextRow = row.sibling;
            row.sibling = _tail;
            _tail = row;
            row = nextRow;
          } // TODO: If workInProgress.child is null, we can continue on the tail immediately.


          initSuspenseListRenderState(workInProgress, true, // isBackwards
          _tail, null, // last
          tailMode, workInProgress.lastEffect);
          break;
        }

      case 'together':
        {
          initSuspenseListRenderState(workInProgress, false, // isBackwards
          null, // tail
          null, // last
          undefined, workInProgress.lastEffect);
          break;
        }

      default:
        {
          // The default reveal order is the same as not having
          // a boundary.
          workInProgress.memoizedState = null;
        }
    }
  }

  return workInProgress.child;
}

function updatePortalComponent(current, workInProgress, renderLanes) {
  pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);
  var nextChildren = workInProgress.pendingProps;

  if (current === null) {
    // Portals are special because we don't append the children during mount
    // but at commit. Therefore we need to track insertions which the normal
    // flow doesn't do during mount. This doesn't happen at the root because
    // the root always starts with a "current" with a null child.
    // TODO: Consider unifying this with how the root works.
    workInProgress.child = reconcileChildFibers(workInProgress, null, nextChildren, renderLanes);
  } else {
    reconcileChildren(current, workInProgress, nextChildren, renderLanes);
  }

  return workInProgress.child;
}

var hasWarnedAboutUsingNoValuePropOnContextProvider = false;

function updateContextProvider(current, workInProgress, renderLanes) {
  var providerType = workInProgress.type;
  var context = providerType._context;
  var newProps = workInProgress.pendingProps;
  var oldProps = workInProgress.memoizedProps;
  var newValue = newProps.value;

  {
    if (!('value' in newProps)) {
      if (!hasWarnedAboutUsingNoValuePropOnContextProvider) {
        hasWarnedAboutUsingNoValuePropOnContextProvider = true;

        error('The `value` prop is required for the `<Context.Provider>`. Did you misspell it or forget to pass it?');
      }
    }

    var providerPropTypes = workInProgress.type.propTypes;

    if (providerPropTypes) {
      checkPropTypes(providerPropTypes, newProps, 'prop', 'Context.Provider');
    }
  }

  pushProvider(workInProgress, newValue);

  if (oldProps !== null) {
    var oldValue = oldProps.value;
    var changedBits = calculateChangedBits(context, newValue, oldValue);

    if (changedBits === 0) {
      // No change. Bailout early if children are the same.
      if (oldProps.children === newProps.children && !hasContextChanged()) {
        return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);
      }
    } else {
      // The context value changed. Search for matching consumers and schedule
      // them to update.
      propagateContextChange(workInProgress, context, changedBits, renderLanes);
    }
  }

  var newChildren = newProps.children;
  reconcileChildren(current, workInProgress, newChildren, renderLanes);
  return workInProgress.child;
}

var hasWarnedAboutUsingContextAsConsumer = false;

function updateContextConsumer(current, workInProgress, renderLanes) {
  var context = workInProgress.type; // The logic below for Context differs depending on PROD or DEV mode. In
  // DEV mode, we create a separate object for Context.Consumer that acts
  // like a proxy to Context. This proxy object adds unnecessary code in PROD
  // so we use the old behaviour (Context.Consumer references Context) to
  // reduce size and overhead. The separate object references context via
  // a property called "_context", which also gives us the ability to check
  // in DEV mode if this property exists or not and warn if it does not.

  {
    if (context._context === undefined) {
      // This may be because it's a Context (rather than a Consumer).
      // Or it may be because it's older React where they're the same thing.
      // We only want to warn if we're sure it's a new React.
      if (context !== context.Consumer) {
        if (!hasWarnedAboutUsingContextAsConsumer) {
          hasWarnedAboutUsingContextAsConsumer = true;

          error('Rendering <Context> directly is not supported and will be removed in ' + 'a future major release. Did you mean to render <Context.Consumer> instead?');
        }
      }
    } else {
      context = context._context;
    }
  }

  var newProps = workInProgress.pendingProps;
  var render = newProps.children;

  {
    if (typeof render !== 'function') {
      error('A context consumer was rendered with multiple children, or a child ' + "that isn't a function. A context consumer expects a single child " + 'that is a function. If you did pass a function, make sure there ' + 'is no trailing or leading whitespace around it.');
    }
  }

  prepareToReadContext(workInProgress, renderLanes);
  var newValue = readContext(context, newProps.unstable_observedBits);
  var newChildren;

  {
    ReactCurrentOwner$1.current = workInProgress;
    setIsRendering(true);
    newChildren = render(newValue);
    setIsRendering(false);
  } // React DevTools reads this flag.


  workInProgress.flags |= PerformedWork;
  reconcileChildren(current, workInProgress, newChildren, renderLanes);
  return workInProgress.child;
}

function markWorkInProgressReceivedUpdate() {
  didReceiveUpdate = true;
}

function bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes) {
  if (current !== null) {
    // Reuse previous dependencies
    workInProgress.dependencies = current.dependencies;
  }

  {
    // Don't update "base" render times for bailouts.
    stopProfilerTimerIfRunning();
  }

  markSkippedUpdateLanes(workInProgress.lanes); // Check if the children have any pending work.

  if (!includesSomeLane(renderLanes, workInProgress.childLanes)) {
    // The children don't have any work either. We can skip them.
    // TODO: Once we add back resuming, we should check if the children are
    // a work-in-progress set. If so, we need to transfer their effects.
    return null;
  } else {
    // This fiber doesn't have work, but its subtree does. Clone the child
    // fibers and continue.
    cloneChildFibers(current, workInProgress);
    return workInProgress.child;
  }
}

function remountFiber(current, oldWorkInProgress, newWorkInProgress) {
  {
    var returnFiber = oldWorkInProgress.return;

    if (returnFiber === null) {
      throw new Error('Cannot swap the root fiber.');
    } // Disconnect from the old current.
    // It will get deleted.


    current.alternate = null;
    oldWorkInProgress.alternate = null; // Connect to the new tree.

    newWorkInProgress.index = oldWorkInProgress.index;
    newWorkInProgress.sibling = oldWorkInProgress.sibling;
    newWorkInProgress.return = oldWorkInProgress.return;
    newWorkInProgress.ref = oldWorkInProgress.ref; // Replace the child/sibling pointers above it.

    if (oldWorkInProgress === returnFiber.child) {
      returnFiber.child = newWorkInProgress;
    } else {
      var prevSibling = returnFiber.child;

      if (prevSibling === null) {
        throw new Error('Expected parent to have a child.');
      }

      while (prevSibling.sibling !== oldWorkInProgress) {
        prevSibling = prevSibling.sibling;

        if (prevSibling === null) {
          throw new Error('Expected to find the previous sibling.');
        }
      }

      prevSibling.sibling = newWorkInProgress;
    } // Delete the old fiber and place the new one.
    // Since the old fiber is disconnected, we have to schedule it manually.


    var last = returnFiber.lastEffect;

    if (last !== null) {
      last.nextEffect = current;
      returnFiber.lastEffect = current;
    } else {
      returnFiber.firstEffect = returnFiber.lastEffect = current;
    }

    current.nextEffect = null;
    current.flags = Deletion;
    newWorkInProgress.flags |= Placement; // Restart work from the new fiber.

    return newWorkInProgress;
  }
}

function beginWork(current, workInProgress, renderLanes) {
  var updateLanes = workInProgress.lanes;

  {
    if (workInProgress._debugNeedsRemount && current !== null) {
      // This will restart the begin phase with a new fiber.
      return remountFiber(current, workInProgress, createFiberFromTypeAndProps(workInProgress.type, workInProgress.key, workInProgress.pendingProps, workInProgress._debugOwner || null, workInProgress.mode, workInProgress.lanes));
    }
  }

  if (current !== null) {
    var oldProps = current.memoizedProps;
    var newProps = workInProgress.pendingProps;

    if (oldProps !== newProps || hasContextChanged() || ( // Force a re-render if the implementation changed due to hot reload:
     workInProgress.type !== current.type )) {
      // If props or context changed, mark the fiber as having performed work.
      // This may be unset if the props are determined to be equal later (memo).
      didReceiveUpdate = true;
    } else if (!includesSomeLane(renderLanes, updateLanes)) {
      didReceiveUpdate = false; // This fiber does not have any pending work. Bailout without entering
      // the begin phase. There's still some bookkeeping we that needs to be done
      // in this optimized path, mostly pushing stuff onto the stack.

      switch (workInProgress.tag) {
        case HostRoot:
          pushHostRootContext(workInProgress);
          resetHydrationState();
          break;

        case HostComponent:
          pushHostContext(workInProgress);
          break;

        case ClassComponent:
          {
            var Component = workInProgress.type;

            if (isContextProvider(Component)) {
              pushContextProvider(workInProgress);
            }

            break;
          }

        case HostPortal:
          pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);
          break;

        case ContextProvider:
          {
            var newValue = workInProgress.memoizedProps.value;
            pushProvider(workInProgress, newValue);
            break;
          }

        case Profiler:
          {
            // Profiler should only call onRender when one of its descendants actually rendered.
            var hasChildWork = includesSomeLane(renderLanes, workInProgress.childLanes);

            if (hasChildWork) {
              workInProgress.flags |= Update;
            } // Reset effect durations for the next eventual effect phase.
            // These are reset during render to allow the DevTools commit hook a chance to read them,


            var stateNode = workInProgress.stateNode;
            stateNode.effectDuration = 0;
            stateNode.passiveEffectDuration = 0;
          }

          break;

        case SuspenseComponent:
          {
            var state = workInProgress.memoizedState;

            if (state !== null) {
              // whether to retry the primary children, or to skip over it and
              // go straight to the fallback. Check the priority of the primary
              // child fragment.


              var primaryChildFragment = workInProgress.child;
              var primaryChildLanes = primaryChildFragment.childLanes;

              if (includesSomeLane(renderLanes, primaryChildLanes)) {
                // The primary children have pending work. Use the normal path
                // to attempt to render the primary children again.
                return updateSuspenseComponent(current, workInProgress, renderLanes);
              } else {
                // The primary child fragment does not have pending work marked
                // on it
                pushSuspenseContext(workInProgress, setDefaultShallowSuspenseContext(suspenseStackCursor.current)); // The primary children do not have pending work with sufficient
                // priority. Bailout.

                var child = bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);

                if (child !== null) {
                  // The fallback children have pending work. Skip over the
                  // primary children and work on the fallback.
                  return child.sibling;
                } else {
                  return null;
                }
              }
            } else {
              pushSuspenseContext(workInProgress, setDefaultShallowSuspenseContext(suspenseStackCursor.current));
            }

            break;
          }

        case SuspenseListComponent:
          {
            var didSuspendBefore = (current.flags & DidCapture) !== NoFlags;

            var _hasChildWork = includesSomeLane(renderLanes, workInProgress.childLanes);

            if (didSuspendBefore) {
              if (_hasChildWork) {
                // If something was in fallback state last time, and we have all the
                // same children then we're still in progressive loading state.
                // Something might get unblocked by state updates or retries in the
                // tree which will affect the tail. So we need to use the normal
                // path to compute the correct tail.
                return updateSuspenseListComponent(current, workInProgress, renderLanes);
              } // If none of the children had any work, that means that none of
              // them got retried so they'll still be blocked in the same way
              // as before. We can fast bail out.


              workInProgress.flags |= DidCapture;
            } // If nothing suspended before and we're rendering the same children,
            // then the tail doesn't matter. Anything new that suspends will work
            // in the "together" mode, so we can continue from the state we had.


            var renderState = workInProgress.memoizedState;

            if (renderState !== null) {
              // Reset to the "together" mode in case we've started a different
              // update in the past but didn't complete it.
              renderState.rendering = null;
              renderState.tail = null;
              renderState.lastEffect = null;
            }

            pushSuspenseContext(workInProgress, suspenseStackCursor.current);

            if (_hasChildWork) {
              break;
            } else {
              // If none of the children had any work, that means that none of
              // them got retried so they'll still be blocked in the same way
              // as before. We can fast bail out.
              return null;
            }
          }

        case OffscreenComponent:
        case LegacyHiddenComponent:
          {
            // Need to check if the tree still needs to be deferred. This is
            // almost identical to the logic used in the normal update path,
            // so we'll just enter that. The only difference is we'll bail out
            // at the next level instead of this one, because the child props
            // have not changed. Which is fine.
            // TODO: Probably should refactor `beginWork` to split the bailout
            // path from the normal path. I'm tempted to do a labeled break here
            // but I won't :)
            workInProgress.lanes = NoLanes;
            return updateOffscreenComponent(current, workInProgress, renderLanes);
          }
      }

      return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);
    } else {
      if ((current.flags & ForceUpdateForLegacySuspense) !== NoFlags) {
        // This is a special case that only exists for legacy mode.
        // See https://github.com/facebook/react/pull/19216.
        didReceiveUpdate = true;
      } else {
        // An update was scheduled on this fiber, but there are no new props
        // nor legacy context. Set this to false. If an update queue or context
        // consumer produces a changed value, it will set this to true. Otherwise,
        // the component will assume the children have not changed and bail out.
        didReceiveUpdate = false;
      }
    }
  } else {
    didReceiveUpdate = false;
  } // Before entering the begin phase, clear pending update priority.
  // TODO: This assumes that we're about to evaluate the component and process
  // the update queue. However, there's an exception: SimpleMemoComponent
  // sometimes bails out later in the begin phase. This indicates that we should
  // move this assignment out of the common path and into each branch.


  workInProgress.lanes = NoLanes;

  switch (workInProgress.tag) {
    case IndeterminateComponent:
      {
        return mountIndeterminateComponent(current, workInProgress, workInProgress.type, renderLanes);
      }

    case LazyComponent:
      {
        var elementType = workInProgress.elementType;
        return mountLazyComponent(current, workInProgress, elementType, updateLanes, renderLanes);
      }

    case FunctionComponent:
      {
        var _Component = workInProgress.type;
        var unresolvedProps = workInProgress.pendingProps;
        var resolvedProps = workInProgress.elementType === _Component ? unresolvedProps : resolveDefaultProps(_Component, unresolvedProps);
        return updateFunctionComponent(current, workInProgress, _Component, resolvedProps, renderLanes);
      }

    case ClassComponent:
      {
        var _Component2 = workInProgress.type;
        var _unresolvedProps = workInProgress.pendingProps;

        var _resolvedProps = workInProgress.elementType === _Component2 ? _unresolvedProps : resolveDefaultProps(_Component2, _unresolvedProps);

        return updateClassComponent(current, workInProgress, _Component2, _resolvedProps, renderLanes);
      }

    case HostRoot:
      return updateHostRoot(current, workInProgress, renderLanes);

    case HostComponent:
      return updateHostComponent(current, workInProgress, renderLanes);

    case HostText:
      return updateHostText(current, workInProgress);

    case SuspenseComponent:
      return updateSuspenseComponent(current, workInProgress, renderLanes);

    case HostPortal:
      return updatePortalComponent(current, workInProgress, renderLanes);

    case ForwardRef:
      {
        var type = workInProgress.type;
        var _unresolvedProps2 = workInProgress.pendingProps;

        var _resolvedProps2 = workInProgress.elementType === type ? _unresolvedProps2 : resolveDefaultProps(type, _unresolvedProps2);

        return updateForwardRef(current, workInProgress, type, _resolvedProps2, renderLanes);
      }

    case Fragment:
      return updateFragment(current, workInProgress, renderLanes);

    case Mode:
      return updateMode(current, workInProgress, renderLanes);

    case Profiler:
      return updateProfiler(current, workInProgress, renderLanes);

    case ContextProvider:
      return updateContextProvider(current, workInProgress, renderLanes);

    case ContextConsumer:
      return updateContextConsumer(current, workInProgress, renderLanes);

    case MemoComponent:
      {
        var _type2 = workInProgress.type;
        var _unresolvedProps3 = workInProgress.pendingProps; // Resolve outer props first, then resolve inner props.

        var _resolvedProps3 = resolveDefaultProps(_type2, _unresolvedProps3);

        {
          if (workInProgress.type !== workInProgress.elementType) {
            var outerPropTypes = _type2.propTypes;

            if (outerPropTypes) {
              checkPropTypes(outerPropTypes, _resolvedProps3, // Resolved for outer only
              'prop', getComponentName(_type2));
            }
          }
        }

        _resolvedProps3 = resolveDefaultProps(_type2.type, _resolvedProps3);
        return updateMemoComponent(current, workInProgress, _type2, _resolvedProps3, updateLanes, renderLanes);
      }

    case SimpleMemoComponent:
      {
        return updateSimpleMemoComponent(current, workInProgress, workInProgress.type, workInProgress.pendingProps, updateLanes, renderLanes);
      }

    case IncompleteClassComponent:
      {
        var _Component3 = workInProgress.type;
        var _unresolvedProps4 = workInProgress.pendingProps;

        var _resolvedProps4 = workInProgress.elementType === _Component3 ? _unresolvedProps4 : resolveDefaultProps(_Component3, _unresolvedProps4);

        return mountIncompleteClassComponent(current, workInProgress, _Component3, _resolvedProps4, renderLanes);
      }

    case SuspenseListComponent:
      {
        return updateSuspenseListComponent(current, workInProgress, renderLanes);
      }

    case FundamentalComponent:
      {

        break;
      }

    case ScopeComponent:
      {

        break;
      }

    case Block:
      {

        break;
      }

    case OffscreenComponent:
      {
        return updateOffscreenComponent(current, workInProgress, renderLanes);
      }

    case LegacyHiddenComponent:
      {
        return updateLegacyHiddenComponent(current, workInProgress, renderLanes);
      }
  }

  {
    {
      throw Error( "Unknown unit of work tag (" + workInProgress.tag + "). This error is likely caused by a bug in React. Please file an issue." );
    }
  }
}

function markUpdate(workInProgress) {
  // Tag the fiber with an update effect. This turns a Placement into
  // a PlacementAndUpdate.
  workInProgress.flags |= Update;
}

function markRef$1(workInProgress) {
  workInProgress.flags |= Ref;
}

var appendAllChildren;
var updateHostContainer;
var updateHostComponent$1;
var updateHostText$1;

{
  // Mutation mode
  appendAllChildren = function (parent, workInProgress, needsVisibilityToggle, isHidden) {
    // We only have the top Fiber that was created but we need recurse down its
    // children to find all the terminal nodes.
    var node = workInProgress.child;

    while (node !== null) {
      if (node.tag === HostComponent || node.tag === HostText) {
        appendInitialChild(parent, node.stateNode);
      } else if (node.tag === HostPortal) ; else if (node.child !== null) {
        node.child.return = node;
        node = node.child;
        continue;
      }

      if (node === workInProgress) {
        return;
      }

      while (node.sibling === null) {
        if (node.return === null || node.return === workInProgress) {
          return;
        }

        node = node.return;
      }

      node.sibling.return = node.return;
      node = node.sibling;
    }
  };

  updateHostContainer = function (workInProgress) {// Noop
  };

  updateHostComponent$1 = function (current, workInProgress, type, newProps, rootContainerInstance) {
    // If we have an alternate, that means this is an update and we need to
    // schedule a side-effect to do the updates.
    var oldProps = current.memoizedProps;

    if (oldProps === newProps) {
      // In mutation mode, this is sufficient for a bailout because
      // we won't touch this node even if children changed.
      return;
    } // If we get updated because one of our children updated, we don't
    // have newProps so we'll have to reuse them.
    // TODO: Split the update API as separate for the props vs. children.
    // Even better would be if children weren't special cased at all tho.


    var instance = workInProgress.stateNode;
    var currentHostContext = getHostContext(); // TODO: Experiencing an error where oldProps is null. Suggests a host
    // component is hitting the resume path. Figure out why. Possibly
    // related to `hidden`.

    var updatePayload = prepareUpdate(instance, type, oldProps, newProps, rootContainerInstance, currentHostContext); // TODO: Type this specific to this type of component.

    workInProgress.updateQueue = updatePayload; // If the update payload indicates that there is a change or if there
    // is a new ref we mark this as an update. All the work is done in commitWork.

    if (updatePayload) {
      markUpdate(workInProgress);
    }
  };

  updateHostText$1 = function (current, workInProgress, oldText, newText) {
    // If the text differs, mark it as an update. All the work in done in commitWork.
    if (oldText !== newText) {
      markUpdate(workInProgress);
    }
  };
}

function cutOffTailIfNeeded(renderState, hasRenderedATailFallback) {
  if (getIsHydrating()) {
    // If we're hydrating, we should consume as many items as we can
    // so we don't leave any behind.
    return;
  }

  switch (renderState.tailMode) {
    case 'hidden':
      {
        // Any insertions at the end of the tail list after this point
        // should be invisible. If there are already mounted boundaries
        // anything before them are not considered for collapsing.
        // Therefore we need to go through the whole tail to find if
        // there are any.
        var tailNode = renderState.tail;
        var lastTailNode = null;

        while (tailNode !== null) {
          if (tailNode.alternate !== null) {
            lastTailNode = tailNode;
          }

          tailNode = tailNode.sibling;
        } // Next we're simply going to delete all insertions after the
        // last rendered item.


        if (lastTailNode === null) {
          // All remaining items in the tail are insertions.
          renderState.tail = null;
        } else {
          // Detach the insertion after the last node that was already
          // inserted.
          lastTailNode.sibling = null;
        }

        break;
      }

    case 'collapsed':
      {
        // Any insertions at the end of the tail list after this point
        // should be invisible. If there are already mounted boundaries
        // anything before them are not considered for collapsing.
        // Therefore we need to go through the whole tail to find if
        // there are any.
        var _tailNode = renderState.tail;
        var _lastTailNode = null;

        while (_tailNode !== null) {
          if (_tailNode.alternate !== null) {
            _lastTailNode = _tailNode;
          }

          _tailNode = _tailNode.sibling;
        } // Next we're simply going to delete all insertions after the
        // last rendered item.


        if (_lastTailNode === null) {
          // All remaining items in the tail are insertions.
          if (!hasRenderedATailFallback && renderState.tail !== null) {
            // We suspended during the head. We want to show at least one
            // row at the tail. So we'll keep on and cut off the rest.
            renderState.tail.sibling = null;
          } else {
            renderState.tail = null;
          }
        } else {
          // Detach the insertion after the last node that was already
          // inserted.
          _lastTailNode.sibling = null;
        }

        break;
      }
  }
}

function completeWork(current, workInProgress, renderLanes) {
  var newProps = workInProgress.pendingProps;

  switch (workInProgress.tag) {
    case IndeterminateComponent:
    case LazyComponent:
    case SimpleMemoComponent:
    case FunctionComponent:
    case ForwardRef:
    case Fragment:
    case Mode:
    case Profiler:
    case ContextConsumer:
    case MemoComponent:
      return null;

    case ClassComponent:
      {
        var Component = workInProgress.type;

        if (isContextProvider(Component)) {
          popContext(workInProgress);
        }

        return null;
      }

    case HostRoot:
      {
        popHostContainer(workInProgress);
        popTopLevelContextObject(workInProgress);
        resetWorkInProgressVersions();
        var fiberRoot = workInProgress.stateNode;

        if (fiberRoot.pendingContext) {
          fiberRoot.context = fiberRoot.pendingContext;
          fiberRoot.pendingContext = null;
        }

        if (current === null || current.child === null) {
          // If we hydrated, pop so that we can delete any remaining children
          // that weren't hydrated.
          var wasHydrated = popHydrationState(workInProgress);

          if (wasHydrated) {
            // If we hydrated, then we'll need to schedule an update for
            // the commit side-effects on the root.
            markUpdate(workInProgress);
          } else if (!fiberRoot.hydrate) {
            // Schedule an effect to clear this container at the start of the next commit.
            // This handles the case of React rendering into a container with previous children.
            // It's also safe to do for updates too, because current.child would only be null
            // if the previous render was null (so the the container would already be empty).
            workInProgress.flags |= Snapshot;
          }
        }

        updateHostContainer(workInProgress);
        return null;
      }

    case HostComponent:
      {
        popHostContext(workInProgress);
        var rootContainerInstance = getRootHostContainer();
        var type = workInProgress.type;

        if (current !== null && workInProgress.stateNode != null) {
          updateHostComponent$1(current, workInProgress, type, newProps, rootContainerInstance);

          if (current.ref !== workInProgress.ref) {
            markRef$1(workInProgress);
          }
        } else {
          if (!newProps) {
            if (!(workInProgress.stateNode !== null)) {
              {
                throw Error( "We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue." );
              }
            } // This can happen when we abort work.


            return null;
          }

          var currentHostContext = getHostContext(); // TODO: Move createInstance to beginWork and keep it on a context
          // "stack" as the parent. Then append children as we go in beginWork
          // or completeWork depending on whether we want to add them top->down or
          // bottom->up. Top->down is faster in IE11.

          var _wasHydrated = popHydrationState(workInProgress);

          if (_wasHydrated) {
            // TODO: Move this and createInstance step into the beginPhase
            // to consolidate.
            if (prepareToHydrateHostInstance(workInProgress, rootContainerInstance, currentHostContext)) {
              // If changes to the hydrated node need to be applied at the
              // commit-phase we mark this as such.
              markUpdate(workInProgress);
            }
          } else {
            var instance = createInstance(type, newProps, rootContainerInstance, currentHostContext, workInProgress);
            appendAllChildren(instance, workInProgress, false, false);
            workInProgress.stateNode = instance; // Certain renderers require commit-time effects for initial mount.
            // (eg DOM renderer supports auto-focus for certain elements).
            // Make sure such renderers get scheduled for later work.

            if (finalizeInitialChildren(instance, type, newProps, rootContainerInstance)) {
              markUpdate(workInProgress);
            }
          }

          if (workInProgress.ref !== null) {
            // If there is a ref on a host node we need to schedule a callback
            markRef$1(workInProgress);
          }
        }

        return null;
      }

    case HostText:
      {
        var newText = newProps;

        if (current && workInProgress.stateNode != null) {
          var oldText = current.memoizedProps; // If we have an alternate, that means this is an update and we need
          // to schedule a side-effect to do the updates.

          updateHostText$1(current, workInProgress, oldText, newText);
        } else {
          if (typeof newText !== 'string') {
            if (!(workInProgress.stateNode !== null)) {
              {
                throw Error( "We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue." );
              }
            } // This can happen when we abort work.

          }

          var _rootContainerInstance = getRootHostContainer();

          var _currentHostContext = getHostContext();

          var _wasHydrated2 = popHydrationState(workInProgress);

          if (_wasHydrated2) {
            if (prepareToHydrateHostTextInstance(workInProgress)) {
              markUpdate(workInProgress);
            }
          } else {
            workInProgress.stateNode = createTextInstance(newText, _rootContainerInstance, _currentHostContext, workInProgress);
          }
        }

        return null;
      }

    case SuspenseComponent:
      {
        popSuspenseContext(workInProgress);
        var nextState = workInProgress.memoizedState;

        if ((workInProgress.flags & DidCapture) !== NoFlags) {
          // Something suspended. Re-render with the fallback children.
          workInProgress.lanes = renderLanes; // Do not reset the effect list.

          if ( (workInProgress.mode & ProfileMode) !== NoMode) {
            transferActualDuration(workInProgress);
          }

          return workInProgress;
        }

        var nextDidTimeout = nextState !== null;
        var prevDidTimeout = false;

        if (current === null) {
          if (workInProgress.memoizedProps.fallback !== undefined) {
            popHydrationState(workInProgress);
          }
        } else {
          var prevState = current.memoizedState;
          prevDidTimeout = prevState !== null;
        }

        if (nextDidTimeout && !prevDidTimeout) {
          // If this subtreee is running in blocking mode we can suspend,
          // otherwise we won't suspend.
          // TODO: This will still suspend a synchronous tree if anything
          // in the concurrent tree already suspended during this render.
          // This is a known bug.
          if ((workInProgress.mode & BlockingMode) !== NoMode) {
            // TODO: Move this back to throwException because this is too late
            // if this is a large tree which is common for initial loads. We
            // don't know if we should restart a render or not until we get
            // this marker, and this is too late.
            // If this render already had a ping or lower pri updates,
            // and this is the first time we know we're going to suspend we
            // should be able to immediately restart from within throwException.
            var hasInvisibleChildContext = current === null && workInProgress.memoizedProps.unstable_avoidThisFallback !== true;

            if (hasInvisibleChildContext || hasSuspenseContext(suspenseStackCursor.current, InvisibleParentSuspenseContext)) {
              // If this was in an invisible tree or a new render, then showing
              // this boundary is ok.
              renderDidSuspend();
            } else {
              // Otherwise, we're going to have to hide content so we should
              // suspend for longer if possible.
              renderDidSuspendDelayIfPossible();
            }
          }
        }

        {
          // TODO: Only schedule updates if these values are non equal, i.e. it changed.
          if (nextDidTimeout || prevDidTimeout) {
            // If this boundary just timed out, schedule an effect to attach a
            // retry listener to the promise. This flag is also used to hide the
            // primary children. In mutation mode, we also need the flag to
            // *unhide* children that were previously hidden, so check if this
            // is currently timed out, too.
            workInProgress.flags |= Update;
          }
        }

        return null;
      }

    case HostPortal:
      popHostContainer(workInProgress);
      updateHostContainer(workInProgress);

      if (current === null) {
        preparePortalMount(workInProgress.stateNode.containerInfo);
      }

      return null;

    case ContextProvider:
      // Pop provider fiber
      popProvider(workInProgress);
      return null;

    case IncompleteClassComponent:
      {
        // Same as class component case. I put it down here so that the tags are
        // sequential to ensure this switch is compiled to a jump table.
        var _Component = workInProgress.type;

        if (isContextProvider(_Component)) {
          popContext(workInProgress);
        }

        return null;
      }

    case SuspenseListComponent:
      {
        popSuspenseContext(workInProgress);
        var renderState = workInProgress.memoizedState;

        if (renderState === null) {
          // We're running in the default, "independent" mode.
          // We don't do anything in this mode.
          return null;
        }

        var didSuspendAlready = (workInProgress.flags & DidCapture) !== NoFlags;
        var renderedTail = renderState.rendering;

        if (renderedTail === null) {
          // We just rendered the head.
          if (!didSuspendAlready) {
            // This is the first pass. We need to figure out if anything is still
            // suspended in the rendered set.
            // If new content unsuspended, but there's still some content that
            // didn't. Then we need to do a second pass that forces everything
            // to keep showing their fallbacks.
            // We might be suspended if something in this render pass suspended, or
            // something in the previous committed pass suspended. Otherwise,
            // there's no chance so we can skip the expensive call to
            // findFirstSuspended.
            var cannotBeSuspended = renderHasNotSuspendedYet() && (current === null || (current.flags & DidCapture) === NoFlags);

            if (!cannotBeSuspended) {
              var row = workInProgress.child;

              while (row !== null) {
                var suspended = findFirstSuspended(row);

                if (suspended !== null) {
                  didSuspendAlready = true;
                  workInProgress.flags |= DidCapture;
                  cutOffTailIfNeeded(renderState, false); // If this is a newly suspended tree, it might not get committed as
                  // part of the second pass. In that case nothing will subscribe to
                  // its thennables. Instead, we'll transfer its thennables to the
                  // SuspenseList so that it can retry if they resolve.
                  // There might be multiple of these in the list but since we're
                  // going to wait for all of them anyway, it doesn't really matter
                  // which ones gets to ping. In theory we could get clever and keep
                  // track of how many dependencies remain but it gets tricky because
                  // in the meantime, we can add/remove/change items and dependencies.
                  // We might bail out of the loop before finding any but that
                  // doesn't matter since that means that the other boundaries that
                  // we did find already has their listeners attached.

                  var newThennables = suspended.updateQueue;

                  if (newThennables !== null) {
                    workInProgress.updateQueue = newThennables;
                    workInProgress.flags |= Update;
                  } // Rerender the whole list, but this time, we'll force fallbacks
                  // to stay in place.
                  // Reset the effect list before doing the second pass since that's now invalid.


                  if (renderState.lastEffect === null) {
                    workInProgress.firstEffect = null;
                  }

                  workInProgress.lastEffect = renderState.lastEffect; // Reset the child fibers to their original state.

                  resetChildFibers(workInProgress, renderLanes); // Set up the Suspense Context to force suspense and immediately
                  // rerender the children.

                  pushSuspenseContext(workInProgress, setShallowSuspenseContext(suspenseStackCursor.current, ForceSuspenseFallback));
                  return workInProgress.child;
                }

                row = row.sibling;
              }
            }

            if (renderState.tail !== null && now() > getRenderTargetTime()) {
              // We have already passed our CPU deadline but we still have rows
              // left in the tail. We'll just give up further attempts to render
              // the main content and only render fallbacks.
              workInProgress.flags |= DidCapture;
              didSuspendAlready = true;
              cutOffTailIfNeeded(renderState, false); // Since nothing actually suspended, there will nothing to ping this
              // to get it started back up to attempt the next item. While in terms
              // of priority this work has the same priority as this current render,
              // it's not part of the same transition once the transition has
              // committed. If it's sync, we still want to yield so that it can be
              // painted. Conceptually, this is really the same as pinging.
              // We can use any RetryLane even if it's the one currently rendering
              // since we're leaving it behind on this node.

              workInProgress.lanes = SomeRetryLane;

              {
                markSpawnedWork(SomeRetryLane);
              }
            }
          } else {
            cutOffTailIfNeeded(renderState, false);
          } // Next we're going to render the tail.

        } else {
          // Append the rendered row to the child list.
          if (!didSuspendAlready) {
            var _suspended = findFirstSuspended(renderedTail);

            if (_suspended !== null) {
              workInProgress.flags |= DidCapture;
              didSuspendAlready = true; // Ensure we transfer the update queue to the parent so that it doesn't
              // get lost if this row ends up dropped during a second pass.

              var _newThennables = _suspended.updateQueue;

              if (_newThennables !== null) {
                workInProgress.updateQueue = _newThennables;
                workInProgress.flags |= Update;
              }

              cutOffTailIfNeeded(renderState, true); // This might have been modified.

              if (renderState.tail === null && renderState.tailMode === 'hidden' && !renderedTail.alternate && !getIsHydrating() // We don't cut it if we're hydrating.
              ) {
                  // We need to delete the row we just rendered.
                  // Reset the effect list to what it was before we rendered this
                  // child. The nested children have already appended themselves.
                  var lastEffect = workInProgress.lastEffect = renderState.lastEffect; // Remove any effects that were appended after this point.

                  if (lastEffect !== null) {
                    lastEffect.nextEffect = null;
                  } // We're done.


                  return null;
                }
            } else if ( // The time it took to render last row is greater than the remaining
            // time we have to render. So rendering one more row would likely
            // exceed it.
            now() * 2 - renderState.renderingStartTime > getRenderTargetTime() && renderLanes !== OffscreenLane) {
              // We have now passed our CPU deadline and we'll just give up further
              // attempts to render the main content and only render fallbacks.
              // The assumption is that this is usually faster.
              workInProgress.flags |= DidCapture;
              didSuspendAlready = true;
              cutOffTailIfNeeded(renderState, false); // Since nothing actually suspended, there will nothing to ping this
              // to get it started back up to attempt the next item. While in terms
              // of priority this work has the same priority as this current render,
              // it's not part of the same transition once the transition has
              // committed. If it's sync, we still want to yield so that it can be
              // painted. Conceptually, this is really the same as pinging.
              // We can use any RetryLane even if it's the one currently rendering
              // since we're leaving it behind on this node.

              workInProgress.lanes = SomeRetryLane;

              {
                markSpawnedWork(SomeRetryLane);
              }
            }
          }

          if (renderState.isBackwards) {
            // The effect list of the backwards tail will have been added
            // to the end. This breaks the guarantee that life-cycles fire in
            // sibling order but that isn't a strong guarantee promised by React.
            // Especially since these might also just pop in during future commits.
            // Append to the beginning of the list.
            renderedTail.sibling = workInProgress.child;
            workInProgress.child = renderedTail;
          } else {
            var previousSibling = renderState.last;

            if (previousSibling !== null) {
              previousSibling.sibling = renderedTail;
            } else {
              workInProgress.child = renderedTail;
            }

            renderState.last = renderedTail;
          }
        }

        if (renderState.tail !== null) {
          // We still have tail rows to render.
          // Pop a row.
          var next = renderState.tail;
          renderState.rendering = next;
          renderState.tail = next.sibling;
          renderState.lastEffect = workInProgress.lastEffect;
          renderState.renderingStartTime = now();
          next.sibling = null; // Restore the context.
          // TODO: We can probably just avoid popping it instead and only
          // setting it the first time we go from not suspended to suspended.

          var suspenseContext = suspenseStackCursor.current;

          if (didSuspendAlready) {
            suspenseContext = setShallowSuspenseContext(suspenseContext, ForceSuspenseFallback);
          } else {
            suspenseContext = setDefaultShallowSuspenseContext(suspenseContext);
          }

          pushSuspenseContext(workInProgress, suspenseContext); // Do a pass over the next row.

          return next;
        }

        return null;
      }

    case FundamentalComponent:
      {

        break;
      }

    case ScopeComponent:
      {

        break;
      }

    case Block:

      break;

    case OffscreenComponent:
    case LegacyHiddenComponent:
      {
        popRenderLanes(workInProgress);

        if (current !== null) {
          var _nextState = workInProgress.memoizedState;
          var _prevState = current.memoizedState;
          var prevIsHidden = _prevState !== null;
          var nextIsHidden = _nextState !== null;

          if (prevIsHidden !== nextIsHidden && newProps.mode !== 'unstable-defer-without-hiding') {
            workInProgress.flags |= Update;
          }
        }

        return null;
      }
  }

  {
    {
      throw Error( "Unknown unit of work tag (" + workInProgress.tag + "). This error is likely caused by a bug in React. Please file an issue." );
    }
  }
}

function unwindWork(workInProgress, renderLanes) {
  switch (workInProgress.tag) {
    case ClassComponent:
      {
        var Component = workInProgress.type;

        if (isContextProvider(Component)) {
          popContext(workInProgress);
        }

        var flags = workInProgress.flags;

        if (flags & ShouldCapture) {
          workInProgress.flags = flags & ~ShouldCapture | DidCapture;

          if ( (workInProgress.mode & ProfileMode) !== NoMode) {
            transferActualDuration(workInProgress);
          }

          return workInProgress;
        }

        return null;
      }

    case HostRoot:
      {
        popHostContainer(workInProgress);
        popTopLevelContextObject(workInProgress);
        resetWorkInProgressVersions();
        var _flags = workInProgress.flags;

        if (!((_flags & DidCapture) === NoFlags)) {
          {
            throw Error( "The root failed to unmount after an error. This is likely a bug in React. Please file an issue." );
          }
        }

        workInProgress.flags = _flags & ~ShouldCapture | DidCapture;
        return workInProgress;
      }

    case HostComponent:
      {
        // TODO: popHydrationState
        popHostContext(workInProgress);
        return null;
      }

    case SuspenseComponent:
      {
        popSuspenseContext(workInProgress);

        var _flags2 = workInProgress.flags;

        if (_flags2 & ShouldCapture) {
          workInProgress.flags = _flags2 & ~ShouldCapture | DidCapture; // Captured a suspense effect. Re-render the boundary.

          if ( (workInProgress.mode & ProfileMode) !== NoMode) {
            transferActualDuration(workInProgress);
          }

          return workInProgress;
        }

        return null;
      }

    case SuspenseListComponent:
      {
        popSuspenseContext(workInProgress); // SuspenseList doesn't actually catch anything. It should've been
        // caught by a nested boundary. If not, it should bubble through.

        return null;
      }

    case HostPortal:
      popHostContainer(workInProgress);
      return null;

    case ContextProvider:
      popProvider(workInProgress);
      return null;

    case OffscreenComponent:
    case LegacyHiddenComponent:
      popRenderLanes(workInProgress);
      return null;

    default:
      return null;
  }
}

function unwindInterruptedWork(interruptedWork) {
  switch (interruptedWork.tag) {
    case ClassComponent:
      {
        var childContextTypes = interruptedWork.type.childContextTypes;

        if (childContextTypes !== null && childContextTypes !== undefined) {
          popContext(interruptedWork);
        }

        break;
      }

    case HostRoot:
      {
        popHostContainer(interruptedWork);
        popTopLevelContextObject(interruptedWork);
        resetWorkInProgressVersions();
        break;
      }

    case HostComponent:
      {
        popHostContext(interruptedWork);
        break;
      }

    case HostPortal:
      popHostContainer(interruptedWork);
      break;

    case SuspenseComponent:
      popSuspenseContext(interruptedWork);
      break;

    case SuspenseListComponent:
      popSuspenseContext(interruptedWork);
      break;

    case ContextProvider:
      popProvider(interruptedWork);
      break;

    case OffscreenComponent:
    case LegacyHiddenComponent:
      popRenderLanes(interruptedWork);
      break;
  }
}

function createCapturedValue(value, source) {
  // If the value is an error, call this function immediately after it is thrown
  // so the stack is accurate.
  return {
    value: value,
    source: source,
    stack: getStackByFiberInDevAndProd(source)
  };
}

// This module is forked in different environments.
// By default, return `true` to log errors to the console.
// Forks can return `false` if this isn't desirable.
function showErrorDialog(boundary, errorInfo) {
  return true;
}

function logCapturedError(boundary, errorInfo) {
  try {
    var logError = showErrorDialog(boundary, errorInfo); // Allow injected showErrorDialog() to prevent default console.error logging.
    // This enables renderers like ReactNative to better manage redbox behavior.

    if (logError === false) {
      return;
    }

    var error = errorInfo.value;

    if (true) {
      var source = errorInfo.source;
      var stack = errorInfo.stack;
      var componentStack = stack !== null ? stack : ''; // Browsers support silencing uncaught errors by calling
      // `preventDefault()` in window `error` handler.
      // We record this information as an expando on the error.

      if (error != null && error._suppressLogging) {
        if (boundary.tag === ClassComponent) {
          // The error is recoverable and was silenced.
          // Ignore it and don't print the stack addendum.
          // This is handy for testing error boundaries without noise.
          return;
        } // The error is fatal. Since the silencing might have
        // been accidental, we'll surface it anyway.
        // However, the browser would have silenced the original error
        // so we'll print it first, and then print the stack addendum.


        console['error'](error); // Don't transform to our wrapper
        // For a more detailed description of this block, see:
        // https://github.com/facebook/react/pull/13384
      }

      var componentName = source ? getComponentName(source.type) : null;
      var componentNameMessage = componentName ? "The above error occurred in the <" + componentName + "> component:" : 'The above error occurred in one of your React components:';
      var errorBoundaryMessage;
      var errorBoundaryName = getComponentName(boundary.type);

      if (errorBoundaryName) {
        errorBoundaryMessage = "React will try to recreate this component tree from scratch " + ("using the error boundary you provided, " + errorBoundaryName + ".");
      } else {
        errorBoundaryMessage = 'Consider adding an error boundary to your tree to customize error handling behavior.\n' + 'Visit https://reactjs.org/link/error-boundaries to learn more about error boundaries.';
      }

      var combinedMessage = componentNameMessage + "\n" + componentStack + "\n\n" + ("" + errorBoundaryMessage); // In development, we provide our own message with just the component stack.
      // We don't include the original error message and JS stack because the browser
      // has already printed it. Even if the application swallows the error, it is still
      // displayed by the browser thanks to the DEV-only fake event trick in ReactErrorUtils.

      console['error'](combinedMessage); // Don't transform to our wrapper
    } else {}
  } catch (e) {
    // This method must not throw, or React internal state will get messed up.
    // If console.error is overridden, or logCapturedError() shows a dialog that throws,
    // we want to report this error outside of the normal stack as a last resort.
    // https://github.com/facebook/react/issues/13188
    setTimeout(function () {
      throw e;
    });
  }
}

var PossiblyWeakMap$1 = typeof WeakMap === 'function' ? WeakMap : Map;

function createRootErrorUpdate(fiber, errorInfo, lane) {
  var update = createUpdate(NoTimestamp, lane); // Unmount the root by rendering null.

  update.tag = CaptureUpdate; // Caution: React DevTools currently depends on this property
  // being called "element".

  update.payload = {
    element: null
  };
  var error = errorInfo.value;

  update.callback = function () {
    onUncaughtError(error);
    logCapturedError(fiber, errorInfo);
  };

  return update;
}

function createClassErrorUpdate(fiber, errorInfo, lane) {
  var update = createUpdate(NoTimestamp, lane);
  update.tag = CaptureUpdate;
  var getDerivedStateFromError = fiber.type.getDerivedStateFromError;

  if (typeof getDerivedStateFromError === 'function') {
    var error$1 = errorInfo.value;

    update.payload = function () {
      logCapturedError(fiber, errorInfo);
      return getDerivedStateFromError(error$1);
    };
  }

  var inst = fiber.stateNode;

  if (inst !== null && typeof inst.componentDidCatch === 'function') {
    update.callback = function callback() {
      {
        markFailedErrorBoundaryForHotReloading(fiber);
      }

      if (typeof getDerivedStateFromError !== 'function') {
        // To preserve the preexisting retry behavior of error boundaries,
        // we keep track of which ones already failed during this batch.
        // This gets reset before we yield back to the browser.
        // TODO: Warn in strict mode if getDerivedStateFromError is
        // not defined.
        markLegacyErrorBoundaryAsFailed(this); // Only log here if componentDidCatch is the only error boundary method defined

        logCapturedError(fiber, errorInfo);
      }

      var error$1 = errorInfo.value;
      var stack = errorInfo.stack;
      this.componentDidCatch(error$1, {
        componentStack: stack !== null ? stack : ''
      });

      {
        if (typeof getDerivedStateFromError !== 'function') {
          // If componentDidCatch is the only error boundary method defined,
          // then it needs to call setState to recover from errors.
          // If no state update is scheduled then the boundary will swallow the error.
          if (!includesSomeLane(fiber.lanes, SyncLane)) {
            error('%s: Error boundaries should implement getDerivedStateFromError(). ' + 'In that method, return a state update to display an error message or fallback UI.', getComponentName(fiber.type) || 'Unknown');
          }
        }
      }
    };
  } else {
    update.callback = function () {
      markFailedErrorBoundaryForHotReloading(fiber);
    };
  }

  return update;
}

function attachPingListener(root, wakeable, lanes) {
  // Attach a listener to the promise to "ping" the root and retry. But only if
  // one does not already exist for the lanes we're currently rendering (which
  // acts like a "thread ID" here).
  var pingCache = root.pingCache;
  var threadIDs;

  if (pingCache === null) {
    pingCache = root.pingCache = new PossiblyWeakMap$1();
    threadIDs = new Set();
    pingCache.set(wakeable, threadIDs);
  } else {
    threadIDs = pingCache.get(wakeable);

    if (threadIDs === undefined) {
      threadIDs = new Set();
      pingCache.set(wakeable, threadIDs);
    }
  }

  if (!threadIDs.has(lanes)) {
    // Memoize using the thread ID to prevent redundant listeners.
    threadIDs.add(lanes);
    var ping = pingSuspendedRoot.bind(null, root, wakeable, lanes);
    wakeable.then(ping, ping);
  }
}

function throwException(root, returnFiber, sourceFiber, value, rootRenderLanes) {
  // The source fiber did not complete.
  sourceFiber.flags |= Incomplete; // Its effect list is no longer valid.

  sourceFiber.firstEffect = sourceFiber.lastEffect = null;

  if (value !== null && typeof value === 'object' && typeof value.then === 'function') {
    // This is a wakeable.
    var wakeable = value;

    if ((sourceFiber.mode & BlockingMode) === NoMode) {
      // Reset the memoizedState to what it was before we attempted
      // to render it.
      var currentSource = sourceFiber.alternate;

      if (currentSource) {
        sourceFiber.updateQueue = currentSource.updateQueue;
        sourceFiber.memoizedState = currentSource.memoizedState;
        sourceFiber.lanes = currentSource.lanes;
      } else {
        sourceFiber.updateQueue = null;
        sourceFiber.memoizedState = null;
      }
    }

    var hasInvisibleParentBoundary = hasSuspenseContext(suspenseStackCursor.current, InvisibleParentSuspenseContext); // Schedule the nearest Suspense to re-render the timed out view.

    var _workInProgress = returnFiber;

    do {
      if (_workInProgress.tag === SuspenseComponent && shouldCaptureSuspense(_workInProgress, hasInvisibleParentBoundary)) {
        // Found the nearest boundary.
        // Stash the promise on the boundary fiber. If the boundary times out, we'll
        // attach another listener to flip the boundary back to its normal state.
        var wakeables = _workInProgress.updateQueue;

        if (wakeables === null) {
          var updateQueue = new Set();
          updateQueue.add(wakeable);
          _workInProgress.updateQueue = updateQueue;
        } else {
          wakeables.add(wakeable);
        } // If the boundary is outside of blocking mode, we should *not*
        // suspend the commit. Pretend as if the suspended component rendered
        // null and keep rendering. In the commit phase, we'll schedule a
        // subsequent synchronous update to re-render the Suspense.
        //
        // Note: It doesn't matter whether the component that suspended was
        // inside a blocking mode tree. If the Suspense is outside of it, we
        // should *not* suspend the commit.


        if ((_workInProgress.mode & BlockingMode) === NoMode) {
          _workInProgress.flags |= DidCapture;
          sourceFiber.flags |= ForceUpdateForLegacySuspense; // We're going to commit this fiber even though it didn't complete.
          // But we shouldn't call any lifecycle methods or callbacks. Remove
          // all lifecycle effect tags.

          sourceFiber.flags &= ~(LifecycleEffectMask | Incomplete);

          if (sourceFiber.tag === ClassComponent) {
            var currentSourceFiber = sourceFiber.alternate;

            if (currentSourceFiber === null) {
              // This is a new mount. Change the tag so it's not mistaken for a
              // completed class component. For example, we should not call
              // componentWillUnmount if it is deleted.
              sourceFiber.tag = IncompleteClassComponent;
            } else {
              // When we try rendering again, we should not reuse the current fiber,
              // since it's known to be in an inconsistent state. Use a force update to
              // prevent a bail out.
              var update = createUpdate(NoTimestamp, SyncLane);
              update.tag = ForceUpdate;
              enqueueUpdate(sourceFiber, update);
            }
          } // The source fiber did not complete. Mark it with Sync priority to
          // indicate that it still has pending work.


          sourceFiber.lanes = mergeLanes(sourceFiber.lanes, SyncLane); // Exit without suspending.

          return;
        } // Confirmed that the boundary is in a concurrent mode tree. Continue
        // with the normal suspend path.
        //
        // After this we'll use a set of heuristics to determine whether this
        // render pass will run to completion or restart or "suspend" the commit.
        // The actual logic for this is spread out in different places.
        //
        // This first principle is that if we're going to suspend when we complete
        // a root, then we should also restart if we get an update or ping that
        // might unsuspend it, and vice versa. The only reason to suspend is
        // because you think you might want to restart before committing. However,
        // it doesn't make sense to restart only while in the period we're suspended.
        //
        // Restarting too aggressively is also not good because it starves out any
        // intermediate loading state. So we use heuristics to determine when.
        // Suspense Heuristics
        //
        // If nothing threw a Promise or all the same fallbacks are already showing,
        // then don't suspend/restart.
        //
        // If this is an initial render of a new tree of Suspense boundaries and
        // those trigger a fallback, then don't suspend/restart. We want to ensure
        // that we can show the initial loading state as quickly as possible.
        //
        // If we hit a "Delayed" case, such as when we'd switch from content back into
        // a fallback, then we should always suspend/restart. Transitions apply
        // to this case. If none is defined, JND is used instead.
        //
        // If we're already showing a fallback and it gets "retried", allowing us to show
        // another level, but there's still an inner boundary that would show a fallback,
        // then we suspend/restart for 500ms since the last time we showed a fallback
        // anywhere in the tree. This effectively throttles progressive loading into a
        // consistent train of commits. This also gives us an opportunity to restart to
        // get to the completed state slightly earlier.
        //
        // If there's ambiguity due to batching it's resolved in preference of:
        // 1) "delayed", 2) "initial render", 3) "retry".
        //
        // We want to ensure that a "busy" state doesn't get force committed. We want to
        // ensure that new initial loading states can commit as soon as possible.


        attachPingListener(root, wakeable, rootRenderLanes);
        _workInProgress.flags |= ShouldCapture;
        _workInProgress.lanes = rootRenderLanes;
        return;
      } // This boundary already captured during this render. Continue to the next
      // boundary.


      _workInProgress = _workInProgress.return;
    } while (_workInProgress !== null); // No boundary was found. Fallthrough to error mode.
    // TODO: Use invariant so the message is stripped in prod?


    value = new Error((getComponentName(sourceFiber.type) || 'A React component') + ' suspended while rendering, but no fallback UI was specified.\n' + '\n' + 'Add a <Suspense fallback=...> component higher in the tree to ' + 'provide a loading indicator or placeholder to display.');
  } // We didn't find a boundary that could handle this type of exception. Start
  // over and traverse parent path again, this time treating the exception
  // as an error.


  renderDidError();
  value = createCapturedValue(value, sourceFiber);
  var workInProgress = returnFiber;

  do {
    switch (workInProgress.tag) {
      case HostRoot:
        {
          var _errorInfo = value;
          workInProgress.flags |= ShouldCapture;
          var lane = pickArbitraryLane(rootRenderLanes);
          workInProgress.lanes = mergeLanes(workInProgress.lanes, lane);

          var _update = createRootErrorUpdate(workInProgress, _errorInfo, lane);

          enqueueCapturedUpdate(workInProgress, _update);
          return;
        }

      case ClassComponent:
        // Capture and retry
        var errorInfo = value;
        var ctor = workInProgress.type;
        var instance = workInProgress.stateNode;

        if ((workInProgress.flags & DidCapture) === NoFlags && (typeof ctor.getDerivedStateFromError === 'function' || instance !== null && typeof instance.componentDidCatch === 'function' && !isAlreadyFailedLegacyErrorBoundary(instance))) {
          workInProgress.flags |= ShouldCapture;

          var _lane = pickArbitraryLane(rootRenderLanes);

          workInProgress.lanes = mergeLanes(workInProgress.lanes, _lane); // Schedule the error boundary to re-render using updated state

          var _update2 = createClassErrorUpdate(workInProgress, errorInfo, _lane);

          enqueueCapturedUpdate(workInProgress, _update2);
          return;
        }

        break;
    }

    workInProgress = workInProgress.return;
  } while (workInProgress !== null);
}

var didWarnAboutUndefinedSnapshotBeforeUpdate = null;

{
  didWarnAboutUndefinedSnapshotBeforeUpdate = new Set();
}

var PossiblyWeakSet = typeof WeakSet === 'function' ? WeakSet : Set;

var callComponentWillUnmountWithTimer = function (current, instance) {
  instance.props = current.memoizedProps;
  instance.state = current.memoizedState;

  {
    instance.componentWillUnmount();
  }
}; // Capture errors so they don't interrupt unmounting.


function safelyCallComponentWillUnmount(current, instance) {
  {
    invokeGuardedCallback(null, callComponentWillUnmountWithTimer, null, current, instance);

    if (hasCaughtError()) {
      var unmountError = clearCaughtError();
      captureCommitPhaseError(current, unmountError);
    }
  }
}

function safelyDetachRef(current) {
  var ref = current.ref;

  if (ref !== null) {
    if (typeof ref === 'function') {
      {
        invokeGuardedCallback(null, ref, null, null);

        if (hasCaughtError()) {
          var refError = clearCaughtError();
          captureCommitPhaseError(current, refError);
        }
      }
    } else {
      ref.current = null;
    }
  }
}

function safelyCallDestroy(current, destroy) {
  {
    invokeGuardedCallback(null, destroy, null);

    if (hasCaughtError()) {
      var error = clearCaughtError();
      captureCommitPhaseError(current, error);
    }
  }
}

function commitBeforeMutationLifeCycles(current, finishedWork) {
  switch (finishedWork.tag) {
    case FunctionComponent:
    case ForwardRef:
    case SimpleMemoComponent:
    case Block:
      {
        return;
      }

    case ClassComponent:
      {
        if (finishedWork.flags & Snapshot) {
          if (current !== null) {
            var prevProps = current.memoizedProps;
            var prevState = current.memoizedState;
            var instance = finishedWork.stateNode; // We could update instance props and state here,
            // but instead we rely on them being set during last render.
            // TODO: revisit this when we implement resuming.

            {
              if (finishedWork.type === finishedWork.elementType && !didWarnAboutReassigningProps) {
                if (instance.props !== finishedWork.memoizedProps) {
                  error('Expected %s props to match memoized props before ' + 'getSnapshotBeforeUpdate. ' + 'This might either be because of a bug in React, or because ' + 'a component reassigns its own `this.props`. ' + 'Please file an issue.', getComponentName(finishedWork.type) || 'instance');
                }

                if (instance.state !== finishedWork.memoizedState) {
                  error('Expected %s state to match memoized state before ' + 'getSnapshotBeforeUpdate. ' + 'This might either be because of a bug in React, or because ' + 'a component reassigns its own `this.state`. ' + 'Please file an issue.', getComponentName(finishedWork.type) || 'instance');
                }
              }
            }

            var snapshot = instance.getSnapshotBeforeUpdate(finishedWork.elementType === finishedWork.type ? prevProps : resolveDefaultProps(finishedWork.type, prevProps), prevState);

            {
              var didWarnSet = didWarnAboutUndefinedSnapshotBeforeUpdate;

              if (snapshot === undefined && !didWarnSet.has(finishedWork.type)) {
                didWarnSet.add(finishedWork.type);

                error('%s.getSnapshotBeforeUpdate(): A snapshot value (or null) ' + 'must be returned. You have returned undefined.', getComponentName(finishedWork.type));
              }
            }

            instance.__reactInternalSnapshotBeforeUpdate = snapshot;
          }
        }

        return;
      }

    case HostRoot:
      {
        {
          if (finishedWork.flags & Snapshot) {
            var root = finishedWork.stateNode;
            clearContainer(root.containerInfo);
          }
        }

        return;
      }

    case HostComponent:
    case HostText:
    case HostPortal:
    case IncompleteClassComponent:
      // Nothing to do for these component types
      return;
  }

  {
    {
      throw Error( "This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue." );
    }
  }
}

function commitHookEffectListUnmount(tag, finishedWork) {
  var updateQueue = finishedWork.updateQueue;
  var lastEffect = updateQueue !== null ? updateQueue.lastEffect : null;

  if (lastEffect !== null) {
    var firstEffect = lastEffect.next;
    var effect = firstEffect;

    do {
      if ((effect.tag & tag) === tag) {
        // Unmount
        var destroy = effect.destroy;
        effect.destroy = undefined;

        if (destroy !== undefined) {
          destroy();
        }
      }

      effect = effect.next;
    } while (effect !== firstEffect);
  }
}

function commitHookEffectListMount(tag, finishedWork) {
  var updateQueue = finishedWork.updateQueue;
  var lastEffect = updateQueue !== null ? updateQueue.lastEffect : null;

  if (lastEffect !== null) {
    var firstEffect = lastEffect.next;
    var effect = firstEffect;

    do {
      if ((effect.tag & tag) === tag) {
        // Mount
        var create = effect.create;
        effect.destroy = create();

        {
          var destroy = effect.destroy;

          if (destroy !== undefined && typeof destroy !== 'function') {
            var addendum = void 0;

            if (destroy === null) {
              addendum = ' You returned null. If your effect does not require clean ' + 'up, return undefined (or nothing).';
            } else if (typeof destroy.then === 'function') {
              addendum = '\n\nIt looks like you wrote useEffect(async () => ...) or returned a Promise. ' + 'Instead, write the async function inside your effect ' + 'and call it immediately:\n\n' + 'useEffect(() => {\n' + '  async function fetchData() {\n' + '    // You can await here\n' + '    const response = await MyAPI.getData(someId);\n' + '    // ...\n' + '  }\n' + '  fetchData();\n' + "}, [someId]); // Or [] if effect doesn't need props or state\n\n" + 'Learn more about data fetching with Hooks: https://reactjs.org/link/hooks-data-fetching';
            } else {
              addendum = ' You returned: ' + destroy;
            }

            error('An effect function must not return anything besides a function, ' + 'which is used for clean-up.%s', addendum);
          }
        }
      }

      effect = effect.next;
    } while (effect !== firstEffect);
  }
}

function schedulePassiveEffects(finishedWork) {
  var updateQueue = finishedWork.updateQueue;
  var lastEffect = updateQueue !== null ? updateQueue.lastEffect : null;

  if (lastEffect !== null) {
    var firstEffect = lastEffect.next;
    var effect = firstEffect;

    do {
      var _effect = effect,
          next = _effect.next,
          tag = _effect.tag;

      if ((tag & Passive$1) !== NoFlags$1 && (tag & HasEffect) !== NoFlags$1) {
        enqueuePendingPassiveHookEffectUnmount(finishedWork, effect);
        enqueuePendingPassiveHookEffectMount(finishedWork, effect);
      }

      effect = next;
    } while (effect !== firstEffect);
  }
}

function commitLifeCycles(finishedRoot, current, finishedWork, committedLanes) {
  switch (finishedWork.tag) {
    case FunctionComponent:
    case ForwardRef:
    case SimpleMemoComponent:
    case Block:
      {
        // At this point layout effects have already been destroyed (during mutation phase).
        // This is done to prevent sibling component effects from interfering with each other,
        // e.g. a destroy function in one component should never override a ref set
        // by a create function in another component during the same commit.
        {
          commitHookEffectListMount(Layout | HasEffect, finishedWork);
        }

        schedulePassiveEffects(finishedWork);
        return;
      }

    case ClassComponent:
      {
        var instance = finishedWork.stateNode;

        if (finishedWork.flags & Update) {
          if (current === null) {
            // We could update instance props and state here,
            // but instead we rely on them being set during last render.
            // TODO: revisit this when we implement resuming.
            {
              if (finishedWork.type === finishedWork.elementType && !didWarnAboutReassigningProps) {
                if (instance.props !== finishedWork.memoizedProps) {
                  error('Expected %s props to match memoized props before ' + 'componentDidMount. ' + 'This might either be because of a bug in React, or because ' + 'a component reassigns its own `this.props`. ' + 'Please file an issue.', getComponentName(finishedWork.type) || 'instance');
                }

                if (instance.state !== finishedWork.memoizedState) {
                  error('Expected %s state to match memoized state before ' + 'componentDidMount. ' + 'This might either be because of a bug in React, or because ' + 'a component reassigns its own `this.state`. ' + 'Please file an issue.', getComponentName(finishedWork.type) || 'instance');
                }
              }
            }

            {
              instance.componentDidMount();
            }
          } else {
            var prevProps = finishedWork.elementType === finishedWork.type ? current.memoizedProps : resolveDefaultProps(finishedWork.type, current.memoizedProps);
            var prevState = current.memoizedState; // We could update instance props and state here,
            // but instead we rely on them being set during last render.
            // TODO: revisit this when we implement resuming.

            {
              if (finishedWork.type === finishedWork.elementType && !didWarnAboutReassigningProps) {
                if (instance.props !== finishedWork.memoizedProps) {
                  error('Expected %s props to match memoized props before ' + 'componentDidUpdate. ' + 'This might either be because of a bug in React, or because ' + 'a component reassigns its own `this.props`. ' + 'Please file an issue.', getComponentName(finishedWork.type) || 'instance');
                }

                if (instance.state !== finishedWork.memoizedState) {
                  error('Expected %s state to match memoized state before ' + 'componentDidUpdate. ' + 'This might either be because of a bug in React, or because ' + 'a component reassigns its own `this.state`. ' + 'Please file an issue.', getComponentName(finishedWork.type) || 'instance');
                }
              }
            }

            {
              instance.componentDidUpdate(prevProps, prevState, instance.__reactInternalSnapshotBeforeUpdate);
            }
          }
        } // TODO: I think this is now always non-null by the time it reaches the
        // commit phase. Consider removing the type check.


        var updateQueue = finishedWork.updateQueue;

        if (updateQueue !== null) {
          {
            if (finishedWork.type === finishedWork.elementType && !didWarnAboutReassigningProps) {
              if (instance.props !== finishedWork.memoizedProps) {
                error('Expected %s props to match memoized props before ' + 'processing the update queue. ' + 'This might either be because of a bug in React, or because ' + 'a component reassigns its own `this.props`. ' + 'Please file an issue.', getComponentName(finishedWork.type) || 'instance');
              }

              if (instance.state !== finishedWork.memoizedState) {
                error('Expected %s state to match memoized state before ' + 'processing the update queue. ' + 'This might either be because of a bug in React, or because ' + 'a component reassigns its own `this.state`. ' + 'Please file an issue.', getComponentName(finishedWork.type) || 'instance');
              }
            }
          } // We could update instance props and state here,
          // but instead we rely on them being set during last render.
          // TODO: revisit this when we implement resuming.


          commitUpdateQueue(finishedWork, updateQueue, instance);
        }

        return;
      }

    case HostRoot:
      {
        // TODO: I think this is now always non-null by the time it reaches the
        // commit phase. Consider removing the type check.
        var _updateQueue = finishedWork.updateQueue;

        if (_updateQueue !== null) {
          var _instance = null;

          if (finishedWork.child !== null) {
            switch (finishedWork.child.tag) {
              case HostComponent:
                _instance = getPublicInstance(finishedWork.child.stateNode);
                break;

              case ClassComponent:
                _instance = finishedWork.child.stateNode;
                break;
            }
          }

          commitUpdateQueue(finishedWork, _updateQueue, _instance);
        }

        return;
      }

    case HostComponent:
      {
        var _instance2 = finishedWork.stateNode; // Renderers may schedule work to be done after host components are mounted
        // (eg DOM renderer may schedule auto-focus for inputs and form controls).
        // These effects should only be committed when components are first mounted,
        // aka when there is no current/alternate.

        if (current === null && finishedWork.flags & Update) {
          var type = finishedWork.type;
          var props = finishedWork.memoizedProps;
          commitMount(_instance2, type, props);
        }

        return;
      }

    case HostText:
      {
        // We have no life-cycles associated with text.
        return;
      }

    case HostPortal:
      {
        // We have no life-cycles associated with portals.
        return;
      }

    case Profiler:
      {
        {
          var _finishedWork$memoize2 = finishedWork.memoizedProps,
              onCommit = _finishedWork$memoize2.onCommit,
              onRender = _finishedWork$memoize2.onRender;
          var effectDuration = finishedWork.stateNode.effectDuration;
          var commitTime = getCommitTime();

          if (typeof onRender === 'function') {
            {
              onRender(finishedWork.memoizedProps.id, current === null ? 'mount' : 'update', finishedWork.actualDuration, finishedWork.treeBaseDuration, finishedWork.actualStartTime, commitTime, finishedRoot.memoizedInteractions);
            }
          }
        }

        return;
      }

    case SuspenseComponent:
      {
        commitSuspenseHydrationCallbacks(finishedRoot, finishedWork);
        return;
      }

    case SuspenseListComponent:
    case IncompleteClassComponent:
    case FundamentalComponent:
    case ScopeComponent:
    case OffscreenComponent:
    case LegacyHiddenComponent:
      return;
  }

  {
    {
      throw Error( "This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue." );
    }
  }
}

function hideOrUnhideAllChildren(finishedWork, isHidden) {
  {
    // We only have the top Fiber that was inserted but we need to recurse down its
    // children to find all the terminal nodes.
    var node = finishedWork;

    while (true) {
      if (node.tag === HostComponent) {
        var instance = node.stateNode;

        if (isHidden) {
          hideInstance(instance);
        } else {
          unhideInstance(node.stateNode, node.memoizedProps);
        }
      } else if (node.tag === HostText) {
        var _instance3 = node.stateNode;

        if (isHidden) {
          hideTextInstance(_instance3);
        } else {
          unhideTextInstance(_instance3, node.memoizedProps);
        }
      } else if ((node.tag === OffscreenComponent || node.tag === LegacyHiddenComponent) && node.memoizedState !== null && node !== finishedWork) ; else if (node.child !== null) {
        node.child.return = node;
        node = node.child;
        continue;
      }

      if (node === finishedWork) {
        return;
      }

      while (node.sibling === null) {
        if (node.return === null || node.return === finishedWork) {
          return;
        }

        node = node.return;
      }

      node.sibling.return = node.return;
      node = node.sibling;
    }
  }
}

function commitAttachRef(finishedWork) {
  var ref = finishedWork.ref;

  if (ref !== null) {
    var instance = finishedWork.stateNode;
    var instanceToUse;

    switch (finishedWork.tag) {
      case HostComponent:
        instanceToUse = getPublicInstance(instance);
        break;

      default:
        instanceToUse = instance;
    } // Moved outside to ensure DCE works with this flag

    if (typeof ref === 'function') {
      ref(instanceToUse);
    } else {
      {
        if (!ref.hasOwnProperty('current')) {
          error('Unexpected ref object provided for %s. ' + 'Use either a ref-setter function or React.createRef().', getComponentName(finishedWork.type));
        }
      }

      ref.current = instanceToUse;
    }
  }
}

function commitDetachRef(current) {
  var currentRef = current.ref;

  if (currentRef !== null) {
    if (typeof currentRef === 'function') {
      currentRef(null);
    } else {
      currentRef.current = null;
    }
  }
} // User-originating errors (lifecycles and refs) should not interrupt
// deletion, so don't let them throw. Host-originating errors should
// interrupt deletion, so it's okay


function commitUnmount(finishedRoot, current, renderPriorityLevel) {
  onCommitUnmount(current);

  switch (current.tag) {
    case FunctionComponent:
    case ForwardRef:
    case MemoComponent:
    case SimpleMemoComponent:
    case Block:
      {
        var updateQueue = current.updateQueue;

        if (updateQueue !== null) {
          var lastEffect = updateQueue.lastEffect;

          if (lastEffect !== null) {
            var firstEffect = lastEffect.next;
            var effect = firstEffect;

            do {
              var _effect2 = effect,
                  destroy = _effect2.destroy,
                  tag = _effect2.tag;

              if (destroy !== undefined) {
                if ((tag & Passive$1) !== NoFlags$1) {
                  enqueuePendingPassiveHookEffectUnmount(current, effect);
                } else {
                  {
                    safelyCallDestroy(current, destroy);
                  }
                }
              }

              effect = effect.next;
            } while (effect !== firstEffect);
          }
        }

        return;
      }

    case ClassComponent:
      {
        safelyDetachRef(current);
        var instance = current.stateNode;

        if (typeof instance.componentWillUnmount === 'function') {
          safelyCallComponentWillUnmount(current, instance);
        }

        return;
      }

    case HostComponent:
      {
        safelyDetachRef(current);
        return;
      }

    case HostPortal:
      {
        // TODO: this is recursive.
        // We are also not using this parent because
        // the portal will get pushed immediately.
        {
          unmountHostComponents(finishedRoot, current);
        }

        return;
      }

    case FundamentalComponent:
      {

        return;
      }

    case DehydratedFragment:
      {

        return;
      }

    case ScopeComponent:
      {

        return;
      }
  }
}

function commitNestedUnmounts(finishedRoot, root, renderPriorityLevel) {
  // While we're inside a removed host node we don't want to call
  // removeChild on the inner nodes because they're removed by the top
  // call anyway. We also want to call componentWillUnmount on all
  // composites before this host node is removed from the tree. Therefore
  // we do an inner loop while we're still inside the host node.
  var node = root;

  while (true) {
    commitUnmount(finishedRoot, node); // Visit children because they may contain more composite or host nodes.
    // Skip portals because commitUnmount() currently visits them recursively.

    if (node.child !== null && ( // If we use mutation we drill down into portals using commitUnmount above.
    // If we don't use mutation we drill down into portals here instead.
     node.tag !== HostPortal)) {
      node.child.return = node;
      node = node.child;
      continue;
    }

    if (node === root) {
      return;
    }

    while (node.sibling === null) {
      if (node.return === null || node.return === root) {
        return;
      }

      node = node.return;
    }

    node.sibling.return = node.return;
    node = node.sibling;
  }
}

function detachFiberMutation(fiber) {
  // Cut off the return pointers to disconnect it from the tree. Ideally, we
  // should clear the child pointer of the parent alternate to let this
  // get GC:ed but we don't know which for sure which parent is the current
  // one so we'll settle for GC:ing the subtree of this child. This child
  // itself will be GC:ed when the parent updates the next time.
  // Note: we cannot null out sibling here, otherwise it can cause issues
  // with findDOMNode and how it requires the sibling field to carry out
  // traversal in a later effect. See PR #16820. We now clear the sibling
  // field after effects, see: detachFiberAfterEffects.
  //
  // Don't disconnect stateNode now; it will be detached in detachFiberAfterEffects.
  // It may be required if the current component is an error boundary,
  // and one of its descendants throws while unmounting a passive effect.
  fiber.alternate = null;
  fiber.child = null;
  fiber.dependencies = null;
  fiber.firstEffect = null;
  fiber.lastEffect = null;
  fiber.memoizedProps = null;
  fiber.memoizedState = null;
  fiber.pendingProps = null;
  fiber.return = null;
  fiber.updateQueue = null;

  {
    fiber._debugOwner = null;
  }
}

function getHostParentFiber(fiber) {
  var parent = fiber.return;

  while (parent !== null) {
    if (isHostParent(parent)) {
      return parent;
    }

    parent = parent.return;
  }

  {
    {
      throw Error( "Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue." );
    }
  }
}

function isHostParent(fiber) {
  return fiber.tag === HostComponent || fiber.tag === HostRoot || fiber.tag === HostPortal;
}

function getHostSibling(fiber) {
  // We're going to search forward into the tree until we find a sibling host
  // node. Unfortunately, if multiple insertions are done in a row we have to
  // search past them. This leads to exponential search for the next sibling.
  // TODO: Find a more efficient way to do this.
  var node = fiber;

  siblings: while (true) {
    // If we didn't find anything, let's try the next sibling.
    while (node.sibling === null) {
      if (node.return === null || isHostParent(node.return)) {
        // If we pop out of the root or hit the parent the fiber we are the
        // last sibling.
        return null;
      }

      node = node.return;
    }

    node.sibling.return = node.return;
    node = node.sibling;

    while (node.tag !== HostComponent && node.tag !== HostText && node.tag !== DehydratedFragment) {
      // If it is not host node and, we might have a host node inside it.
      // Try to search down until we find one.
      if (node.flags & Placement) {
        // If we don't have a child, try the siblings instead.
        continue siblings;
      } // If we don't have a child, try the siblings instead.
      // We also skip portals because they are not part of this host tree.


      if (node.child === null || node.tag === HostPortal) {
        continue siblings;
      } else {
        node.child.return = node;
        node = node.child;
      }
    } // Check if this host node is stable or about to be placed.


    if (!(node.flags & Placement)) {
      // Found it!
      return node.stateNode;
    }
  }
}

function commitPlacement(finishedWork) {


  var parentFiber = getHostParentFiber(finishedWork); // Note: these two variables *must* always be updated together.

  var parent;
  var isContainer;
  var parentStateNode = parentFiber.stateNode;

  switch (parentFiber.tag) {
    case HostComponent:
      parent = parentStateNode;
      isContainer = false;
      break;

    case HostRoot:
      parent = parentStateNode.containerInfo;
      isContainer = true;
      break;

    case HostPortal:
      parent = parentStateNode.containerInfo;
      isContainer = true;
      break;

    case FundamentalComponent:

    // eslint-disable-next-line-no-fallthrough

    default:
      {
        {
          throw Error( "Invalid host parent fiber. This error is likely caused by a bug in React. Please file an issue." );
        }
      }

  }

  if (parentFiber.flags & ContentReset) {
    // Reset the text content of the parent before doing any insertions
    resetTextContent(parent); // Clear ContentReset from the effect tag

    parentFiber.flags &= ~ContentReset;
  }

  var before = getHostSibling(finishedWork); // We only have the top Fiber that was inserted but we need to recurse down its
  // children to find all the terminal nodes.

  if (isContainer) {
    insertOrAppendPlacementNodeIntoContainer(finishedWork, before, parent);
  } else {
    insertOrAppendPlacementNode(finishedWork, before, parent);
  }
}

function insertOrAppendPlacementNodeIntoContainer(node, before, parent) {
  var tag = node.tag;
  var isHost = tag === HostComponent || tag === HostText;

  if (isHost || enableFundamentalAPI ) {
    var stateNode = isHost ? node.stateNode : node.stateNode.instance;

    if (before) {
      insertInContainerBefore(parent, stateNode, before);
    } else {
      appendChildToContainer(parent, stateNode);
    }
  } else if (tag === HostPortal) ; else {
    var child = node.child;

    if (child !== null) {
      insertOrAppendPlacementNodeIntoContainer(child, before, parent);
      var sibling = child.sibling;

      while (sibling !== null) {
        insertOrAppendPlacementNodeIntoContainer(sibling, before, parent);
        sibling = sibling.sibling;
      }
    }
  }
}

function insertOrAppendPlacementNode(node, before, parent) {
  var tag = node.tag;
  var isHost = tag === HostComponent || tag === HostText;

  if (isHost || enableFundamentalAPI ) {
    var stateNode = isHost ? node.stateNode : node.stateNode.instance;

    if (before) {
      insertBefore(parent, stateNode, before);
    } else {
      appendChild(parent, stateNode);
    }
  } else if (tag === HostPortal) ; else {
    var child = node.child;

    if (child !== null) {
      insertOrAppendPlacementNode(child, before, parent);
      var sibling = child.sibling;

      while (sibling !== null) {
        insertOrAppendPlacementNode(sibling, before, parent);
        sibling = sibling.sibling;
      }
    }
  }
}

function unmountHostComponents(finishedRoot, current, renderPriorityLevel) {
  // We only have the top Fiber that was deleted but we need to recurse down its
  // children to find all the terminal nodes.
  var node = current; // Each iteration, currentParent is populated with node's host parent if not
  // currentParentIsValid.

  var currentParentIsValid = false; // Note: these two variables *must* always be updated together.

  var currentParent;
  var currentParentIsContainer;

  while (true) {
    if (!currentParentIsValid) {
      var parent = node.return;

      findParent: while (true) {
        if (!(parent !== null)) {
          {
            throw Error( "Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue." );
          }
        }

        var parentStateNode = parent.stateNode;

        switch (parent.tag) {
          case HostComponent:
            currentParent = parentStateNode;
            currentParentIsContainer = false;
            break findParent;

          case HostRoot:
            currentParent = parentStateNode.containerInfo;
            currentParentIsContainer = true;
            break findParent;

          case HostPortal:
            currentParent = parentStateNode.containerInfo;
            currentParentIsContainer = true;
            break findParent;

        }

        parent = parent.return;
      }

      currentParentIsValid = true;
    }

    if (node.tag === HostComponent || node.tag === HostText) {
      commitNestedUnmounts(finishedRoot, node); // After all the children have unmounted, it is now safe to remove the
      // node from the tree.

      if (currentParentIsContainer) {
        removeChildFromContainer(currentParent, node.stateNode);
      } else {
        removeChild(currentParent, node.stateNode);
      } // Don't visit children because we already visited them.

    } else if (node.tag === HostPortal) {
      if (node.child !== null) {
        // When we go into a portal, it becomes the parent to remove from.
        // We will reassign it back when we pop the portal on the way up.
        currentParent = node.stateNode.containerInfo;
        currentParentIsContainer = true; // Visit children because portals might contain host components.

        node.child.return = node;
        node = node.child;
        continue;
      }
    } else {
      commitUnmount(finishedRoot, node); // Visit children because we may find more host components below.

      if (node.child !== null) {
        node.child.return = node;
        node = node.child;
        continue;
      }
    }

    if (node === current) {
      return;
    }

    while (node.sibling === null) {
      if (node.return === null || node.return === current) {
        return;
      }

      node = node.return;

      if (node.tag === HostPortal) {
        // When we go out of the portal, we need to restore the parent.
        // Since we don't keep a stack of them, we will search for it.
        currentParentIsValid = false;
      }
    }

    node.sibling.return = node.return;
    node = node.sibling;
  }
}

function commitDeletion(finishedRoot, current, renderPriorityLevel) {
  {
    // Recursively delete all host nodes from the parent.
    // Detach refs and call componentWillUnmount() on the whole subtree.
    unmountHostComponents(finishedRoot, current);
  }

  var alternate = current.alternate;
  detachFiberMutation(current);

  if (alternate !== null) {
    detachFiberMutation(alternate);
  }
}

function commitWork(current, finishedWork) {

  switch (finishedWork.tag) {
    case FunctionComponent:
    case ForwardRef:
    case MemoComponent:
    case SimpleMemoComponent:
    case Block:
      {
        // Layout effects are destroyed during the mutation phase so that all
        // destroy functions for all fibers are called before any create functions.
        // This prevents sibling component effects from interfering with each other,
        // e.g. a destroy function in one component should never override a ref set
        // by a create function in another component during the same commit.
        {
          commitHookEffectListUnmount(Layout | HasEffect, finishedWork);
        }

        return;
      }

    case ClassComponent:
      {
        return;
      }

    case HostComponent:
      {
        var instance = finishedWork.stateNode;

        if (instance != null) {
          // Commit the work prepared earlier.
          var newProps = finishedWork.memoizedProps; // For hydration we reuse the update path but we treat the oldProps
          // as the newProps. The updatePayload will contain the real change in
          // this case.

          var oldProps = current !== null ? current.memoizedProps : newProps;
          var type = finishedWork.type; // TODO: Type the updateQueue to be specific to host components.

          var updatePayload = finishedWork.updateQueue;
          finishedWork.updateQueue = null;

          if (updatePayload !== null) {
            commitUpdate(instance, updatePayload, type, oldProps, newProps);
          }
        }

        return;
      }

    case HostText:
      {
        if (!(finishedWork.stateNode !== null)) {
          {
            throw Error( "This should have a text node initialized. This error is likely caused by a bug in React. Please file an issue." );
          }
        }

        var textInstance = finishedWork.stateNode;
        var newText = finishedWork.memoizedProps; // For hydration we reuse the update path but we treat the oldProps
        // as the newProps. The updatePayload will contain the real change in
        // this case.

        var oldText = current !== null ? current.memoizedProps : newText;
        commitTextUpdate(textInstance, oldText, newText);
        return;
      }

    case HostRoot:
      {
        {
          var _root = finishedWork.stateNode;

          if (_root.hydrate) {
            // We've just hydrated. No need to hydrate again.
            _root.hydrate = false;
            commitHydratedContainer(_root.containerInfo);
          }
        }

        return;
      }

    case Profiler:
      {
        return;
      }

    case SuspenseComponent:
      {
        commitSuspenseComponent(finishedWork);
        attachSuspenseRetryListeners(finishedWork);
        return;
      }

    case SuspenseListComponent:
      {
        attachSuspenseRetryListeners(finishedWork);
        return;
      }

    case IncompleteClassComponent:
      {
        return;
      }

    case FundamentalComponent:
      {

        break;
      }

    case ScopeComponent:
      {

        break;
      }

    case OffscreenComponent:
    case LegacyHiddenComponent:
      {
        var newState = finishedWork.memoizedState;
        var isHidden = newState !== null;
        hideOrUnhideAllChildren(finishedWork, isHidden);
        return;
      }
  }

  {
    {
      throw Error( "This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue." );
    }
  }
}

function commitSuspenseComponent(finishedWork) {
  var newState = finishedWork.memoizedState;

  if (newState !== null) {
    markCommitTimeOfFallback();

    {
      // Hide the Offscreen component that contains the primary children. TODO:
      // Ideally, this effect would have been scheduled on the Offscreen fiber
      // itself. That's how unhiding works: the Offscreen component schedules an
      // effect on itself. However, in this case, the component didn't complete,
      // so the fiber was never added to the effect list in the normal path. We
      // could have appended it to the effect list in the Suspense component's
      // second pass, but doing it this way is less complicated. This would be
      // simpler if we got rid of the effect list and traversed the tree, like
      // we're planning to do.
      var primaryChildParent = finishedWork.child;
      hideOrUnhideAllChildren(primaryChildParent, true);
    }
  }
}

function commitSuspenseHydrationCallbacks(finishedRoot, finishedWork) {

  var newState = finishedWork.memoizedState;

  if (newState === null) {
    var current = finishedWork.alternate;

    if (current !== null) {
      var prevState = current.memoizedState;

      if (prevState !== null) {
        var suspenseInstance = prevState.dehydrated;

        if (suspenseInstance !== null) {
          commitHydratedSuspenseInstance(suspenseInstance);
        }
      }
    }
  }
}

function attachSuspenseRetryListeners(finishedWork) {
  // If this boundary just timed out, then it will have a set of wakeables.
  // For each wakeable, attach a listener so that when it resolves, React
  // attempts to re-render the boundary in the primary (pre-timeout) state.
  var wakeables = finishedWork.updateQueue;

  if (wakeables !== null) {
    finishedWork.updateQueue = null;
    var retryCache = finishedWork.stateNode;

    if (retryCache === null) {
      retryCache = finishedWork.stateNode = new PossiblyWeakSet();
    }

    wakeables.forEach(function (wakeable) {
      // Memoize using the boundary fiber to prevent redundant listeners.
      var retry = resolveRetryWakeable.bind(null, finishedWork, wakeable);

      if (!retryCache.has(wakeable)) {
        {
          if (wakeable.__reactDoNotTraceInteractions !== true) {
            retry = tracing.unstable_wrap(retry);
          }
        }

        retryCache.add(wakeable);
        wakeable.then(retry, retry);
      }
    });
  }
} // This function detects when a Suspense boundary goes from visible to hidden.
// It returns false if the boundary is already hidden.
// TODO: Use an effect tag.


function isSuspenseBoundaryBeingHidden(current, finishedWork) {
  if (current !== null) {
    var oldState = current.memoizedState;

    if (oldState === null || oldState.dehydrated !== null) {
      var newState = finishedWork.memoizedState;
      return newState !== null && newState.dehydrated === null;
    }
  }

  return false;
}

function commitResetTextContent(current) {

  resetTextContent(current.stateNode);
}

var COMPONENT_TYPE = 0;
var HAS_PSEUDO_CLASS_TYPE = 1;
var ROLE_TYPE = 2;
var TEST_NAME_TYPE = 3;
var TEXT_TYPE = 4;

if (typeof Symbol === 'function' && Symbol.for) {
  var symbolFor$1 = Symbol.for;
  COMPONENT_TYPE = symbolFor$1('selector.component');
  HAS_PSEUDO_CLASS_TYPE = symbolFor$1('selector.has_pseudo_class');
  ROLE_TYPE = symbolFor$1('selector.role');
  TEST_NAME_TYPE = symbolFor$1('selector.test_id');
  TEXT_TYPE = symbolFor$1('selector.text');
}
var commitHooks = [];
function onCommitRoot$1() {
  {
    commitHooks.forEach(function (commitHook) {
      return commitHook();
    });
  }
}

var ceil = Math.ceil;
var ReactCurrentDispatcher$2 = ReactSharedInternals.ReactCurrentDispatcher,
    ReactCurrentOwner$2 = ReactSharedInternals.ReactCurrentOwner,
    IsSomeRendererActing = ReactSharedInternals.IsSomeRendererActing;
var NoContext =
/*             */
0;
var BatchedContext =
/*               */
1;
var EventContext =
/*                 */
2;
var DiscreteEventContext =
/*         */
4;
var LegacyUnbatchedContext =
/*       */
8;
var RenderContext =
/*                */
16;
var CommitContext =
/*                */
32;
var RetryAfterError =
/*       */
64;
var RootIncomplete = 0;
var RootFatalErrored = 1;
var RootErrored = 2;
var RootSuspended = 3;
var RootSuspendedWithDelay = 4;
var RootCompleted = 5; // Describes where we are in the React execution stack

var executionContext = NoContext; // The root we're working on

var workInProgressRoot = null; // The fiber we're working on

var workInProgress = null; // The lanes we're rendering

var workInProgressRootRenderLanes = NoLanes; // Stack that allows components to change the render lanes for its subtree
// This is a superset of the lanes we started working on at the root. The only
// case where it's different from `workInProgressRootRenderLanes` is when we
// enter a subtree that is hidden and needs to be unhidden: Suspense and
// Offscreen component.
//
// Most things in the work loop should deal with workInProgressRootRenderLanes.
// Most things in begin/complete phases should deal with subtreeRenderLanes.

var subtreeRenderLanes = NoLanes;
var subtreeRenderLanesCursor = createCursor(NoLanes); // Whether to root completed, errored, suspended, etc.

var workInProgressRootExitStatus = RootIncomplete; // A fatal error, if one is thrown

var workInProgressRootFatalError = null; // "Included" lanes refer to lanes that were worked on during this render. It's
// slightly different than `renderLanes` because `renderLanes` can change as you
// enter and exit an Offscreen tree. This value is the combination of all render
// lanes for the entire render phase.

var workInProgressRootIncludedLanes = NoLanes; // The work left over by components that were visited during this render. Only
// includes unprocessed updates, not work in bailed out children.

var workInProgressRootSkippedLanes = NoLanes; // Lanes that were updated (in an interleaved event) during this render.

var workInProgressRootUpdatedLanes = NoLanes; // Lanes that were pinged (in an interleaved event) during this render.

var workInProgressRootPingedLanes = NoLanes;
var mostRecentlyUpdatedRoot = null; // The most recent time we committed a fallback. This lets us ensure a train
// model where we don't commit new loading states in too quick succession.

var globalMostRecentFallbackTime = 0;
var FALLBACK_THROTTLE_MS = 500; // The absolute time for when we should start giving up on rendering
// more and prefer CPU suspense heuristics instead.

var workInProgressRootRenderTargetTime = Infinity; // How long a render is supposed to take before we start following CPU
// suspense heuristics and opt out of rendering more content.

var RENDER_TIMEOUT_MS = 500;

function resetRenderTimer() {
  workInProgressRootRenderTargetTime = now() + RENDER_TIMEOUT_MS;
}

function getRenderTargetTime() {
  return workInProgressRootRenderTargetTime;
}
var nextEffect = null;
var hasUncaughtError = false;
var firstUncaughtError = null;
var legacyErrorBoundariesThatAlreadyFailed = null;
var rootDoesHavePassiveEffects = false;
var rootWithPendingPassiveEffects = null;
var pendingPassiveEffectsRenderPriority = NoPriority$1;
var pendingPassiveEffectsLanes = NoLanes;
var pendingPassiveHookEffectsMount = [];
var pendingPassiveHookEffectsUnmount = [];
var rootsWithPendingDiscreteUpdates = null; // Use these to prevent an infinite loop of nested updates

var NESTED_UPDATE_LIMIT = 50;
var nestedUpdateCount = 0;
var rootWithNestedUpdates = null;
var NESTED_PASSIVE_UPDATE_LIMIT = 50;
var nestedPassiveUpdateCount = 0; // Marks the need to reschedule pending interactions at these lanes
// during the commit phase. This enables them to be traced across components
// that spawn new work during render. E.g. hidden boundaries, suspended SSR
// hydration or SuspenseList.
// TODO: Can use a bitmask instead of an array

var spawnedWorkDuringRender = null; // If two updates are scheduled within the same event, we should treat their
// event times as simultaneous, even if the actual clock time has advanced
// between the first and second call.

var currentEventTime = NoTimestamp;
var currentEventWipLanes = NoLanes;
var currentEventPendingLanes = NoLanes; // Dev only flag that tracks if passive effects are currently being flushed.
// We warn about state updates for unmounted components differently in this case.

var isFlushingPassiveEffects = false;
var focusedInstanceHandle = null;
var shouldFireAfterActiveInstanceBlur = false;
function getWorkInProgressRoot() {
  return workInProgressRoot;
}
function requestEventTime() {
  if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {
    // We're inside React, so it's fine to read the actual time.
    return now();
  } // We're not inside React, so we may be in the middle of a browser event.


  if (currentEventTime !== NoTimestamp) {
    // Use the same start time for all updates until we enter React again.
    return currentEventTime;
  } // This is the first update since React yielded. Compute a new start time.


  currentEventTime = now();
  return currentEventTime;
}
function requestUpdateLane(fiber) {
  // Special cases
  var mode = fiber.mode;

  if ((mode & BlockingMode) === NoMode) {
    return SyncLane;
  } else if ((mode & ConcurrentMode) === NoMode) {
    return getCurrentPriorityLevel() === ImmediatePriority$1 ? SyncLane : SyncBatchedLane;
  } // The algorithm for assigning an update to a lane should be stable for all
  // updates at the same priority within the same event. To do this, the inputs
  // to the algorithm must be the same. For example, we use the `renderLanes`
  // to avoid choosing a lane that is already in the middle of rendering.
  //
  // However, the "included" lanes could be mutated in between updates in the
  // same event, like if you perform an update inside `flushSync`. Or any other
  // code path that might call `prepareFreshStack`.
  //
  // The trick we use is to cache the first of each of these inputs within an
  // event. Then reset the cached values once we can be sure the event is over.
  // Our heuristic for that is whenever we enter a concurrent work loop.
  //
  // We'll do the same for `currentEventPendingLanes` below.


  if (currentEventWipLanes === NoLanes) {
    currentEventWipLanes = workInProgressRootIncludedLanes;
  }

  var isTransition = requestCurrentTransition() !== NoTransition;

  if (isTransition) {
    if (currentEventPendingLanes !== NoLanes) {
      currentEventPendingLanes = mostRecentlyUpdatedRoot !== null ? mostRecentlyUpdatedRoot.pendingLanes : NoLanes;
    }

    return findTransitionLane(currentEventWipLanes, currentEventPendingLanes);
  } // TODO: Remove this dependency on the Scheduler priority.
  // To do that, we're replacing it with an update lane priority.


  var schedulerPriority = getCurrentPriorityLevel(); // The old behavior was using the priority level of the Scheduler.
  // This couples React to the Scheduler internals, so we're replacing it
  // with the currentUpdateLanePriority above. As an example of how this
  // could be problematic, if we're not inside `Scheduler.runWithPriority`,
  // then we'll get the priority of the current running Scheduler task,
  // which is probably not what we want.

  var lane;

  if ( // TODO: Temporary. We're removing the concept of discrete updates.
  (executionContext & DiscreteEventContext) !== NoContext && schedulerPriority === UserBlockingPriority$2) {
    lane = findUpdateLane(InputDiscreteLanePriority, currentEventWipLanes);
  } else {
    var schedulerLanePriority = schedulerPriorityToLanePriority(schedulerPriority);

    lane = findUpdateLane(schedulerLanePriority, currentEventWipLanes);
  }

  return lane;
}

function requestRetryLane(fiber) {
  // This is a fork of `requestUpdateLane` designed specifically for Suspense
  // "retries" — a special update that attempts to flip a Suspense boundary
  // from its placeholder state to its primary/resolved state.
  // Special cases
  var mode = fiber.mode;

  if ((mode & BlockingMode) === NoMode) {
    return SyncLane;
  } else if ((mode & ConcurrentMode) === NoMode) {
    return getCurrentPriorityLevel() === ImmediatePriority$1 ? SyncLane : SyncBatchedLane;
  } // See `requestUpdateLane` for explanation of `currentEventWipLanes`


  if (currentEventWipLanes === NoLanes) {
    currentEventWipLanes = workInProgressRootIncludedLanes;
  }

  return findRetryLane(currentEventWipLanes);
}

function scheduleUpdateOnFiber(fiber, lane, eventTime) {
  checkForNestedUpdates();
  warnAboutRenderPhaseUpdatesInDEV(fiber);
  var root = markUpdateLaneFromFiberToRoot(fiber, lane);

  if (root === null) {
    warnAboutUpdateOnUnmountedFiberInDEV(fiber);
    return null;
  } // Mark that the root has a pending update.


  markRootUpdated(root, lane, eventTime);

  if (root === workInProgressRoot) {
    // Received an update to a tree that's in the middle of rendering. Mark
    // that there was an interleaved update work on this root. Unless the
    // `deferRenderPhaseUpdateToNextBatch` flag is off and this is a render
    // phase update. In that case, we don't treat render phase updates as if
    // they were interleaved, for backwards compat reasons.
    {
      workInProgressRootUpdatedLanes = mergeLanes(workInProgressRootUpdatedLanes, lane);
    }

    if (workInProgressRootExitStatus === RootSuspendedWithDelay) {
      // The root already suspended with a delay, which means this render
      // definitely won't finish. Since we have a new update, let's mark it as
      // suspended now, right before marking the incoming update. This has the
      // effect of interrupting the current render and switching to the update.
      // TODO: Make sure this doesn't override pings that happen while we've
      // already started rendering.
      markRootSuspended$1(root, workInProgressRootRenderLanes);
    }
  } // TODO: requestUpdateLanePriority also reads the priority. Pass the
  // priority as an argument to that function and this one.


  var priorityLevel = getCurrentPriorityLevel();

  if (lane === SyncLane) {
    if ( // Check if we're inside unbatchedUpdates
    (executionContext & LegacyUnbatchedContext) !== NoContext && // Check if we're not already rendering
    (executionContext & (RenderContext | CommitContext)) === NoContext) {
      // Register pending interactions on the root to avoid losing traced interaction data.
      schedulePendingInteractions(root, lane); // This is a legacy edge case. The initial mount of a ReactDOM.render-ed
      // root inside of batchedUpdates should be synchronous, but layout updates
      // should be deferred until the end of the batch.

      performSyncWorkOnRoot(root);
    } else {
      ensureRootIsScheduled(root, eventTime);
      schedulePendingInteractions(root, lane);

      if (executionContext === NoContext) {
        // Flush the synchronous work now, unless we're already working or inside
        // a batch. This is intentionally inside scheduleUpdateOnFiber instead of
        // scheduleCallbackForFiber to preserve the ability to schedule a callback
        // without immediately flushing it. We only do this for user-initiated
        // updates, to preserve historical behavior of legacy mode.
        resetRenderTimer();
        flushSyncCallbackQueue();
      }
    }
  } else {
    // Schedule a discrete update but only if it's not Sync.
    if ((executionContext & DiscreteEventContext) !== NoContext && ( // Only updates at user-blocking priority or greater are considered
    // discrete, even inside a discrete event.
    priorityLevel === UserBlockingPriority$2 || priorityLevel === ImmediatePriority$1)) {
      // This is the result of a discrete event. Track the lowest priority
      // discrete update per root so we can flush them early, if needed.
      if (rootsWithPendingDiscreteUpdates === null) {
        rootsWithPendingDiscreteUpdates = new Set([root]);
      } else {
        rootsWithPendingDiscreteUpdates.add(root);
      }
    } // Schedule other updates after in case the callback is sync.


    ensureRootIsScheduled(root, eventTime);
    schedulePendingInteractions(root, lane);
  } // We use this when assigning a lane for a transition inside
  // `requestUpdateLane`. We assume it's the same as the root being updated,
  // since in the common case of a single root app it probably is. If it's not
  // the same root, then it's not a huge deal, we just might batch more stuff
  // together more than necessary.


  mostRecentlyUpdatedRoot = root;
} // This is split into a separate function so we can mark a fiber with pending
// work without treating it as a typical update that originates from an event;
// e.g. retrying a Suspense boundary isn't an update, but it does schedule work
// on a fiber.

function markUpdateLaneFromFiberToRoot(sourceFiber, lane) {
  // Update the source fiber's lanes
  sourceFiber.lanes = mergeLanes(sourceFiber.lanes, lane);
  var alternate = sourceFiber.alternate;

  if (alternate !== null) {
    alternate.lanes = mergeLanes(alternate.lanes, lane);
  }

  {
    if (alternate === null && (sourceFiber.flags & (Placement | Hydrating)) !== NoFlags) {
      warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber);
    }
  } // Walk the parent path to the root and update the child expiration time.


  var node = sourceFiber;
  var parent = sourceFiber.return;

  while (parent !== null) {
    parent.childLanes = mergeLanes(parent.childLanes, lane);
    alternate = parent.alternate;

    if (alternate !== null) {
      alternate.childLanes = mergeLanes(alternate.childLanes, lane);
    } else {
      {
        if ((parent.flags & (Placement | Hydrating)) !== NoFlags) {
          warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber);
        }
      }
    }

    node = parent;
    parent = parent.return;
  }

  if (node.tag === HostRoot) {
    var root = node.stateNode;
    return root;
  } else {
    return null;
  }
} // Use this function to schedule a task for a root. There's only one task per
// root; if a task was already scheduled, we'll check to make sure the priority
// of the existing task is the same as the priority of the next level that the
// root has work on. This function is called on every update, and right before
// exiting a task.


function ensureRootIsScheduled(root, currentTime) {
  var existingCallbackNode = root.callbackNode; // Check if any lanes are being starved by other work. If so, mark them as
  // expired so we know to work on those next.

  markStarvedLanesAsExpired(root, currentTime); // Determine the next lanes to work on, and their priority.

  var nextLanes = getNextLanes(root, root === workInProgressRoot ? workInProgressRootRenderLanes : NoLanes); // This returns the priority level computed during the `getNextLanes` call.

  var newCallbackPriority = returnNextLanesPriority();

  if (nextLanes === NoLanes) {
    // Special case: There's nothing to work on.
    if (existingCallbackNode !== null) {
      cancelCallback(existingCallbackNode);
      root.callbackNode = null;
      root.callbackPriority = NoLanePriority;
    }

    return;
  } // Check if there's an existing task. We may be able to reuse it.


  if (existingCallbackNode !== null) {
    var existingCallbackPriority = root.callbackPriority;

    if (existingCallbackPriority === newCallbackPriority) {
      // The priority hasn't changed. We can reuse the existing task. Exit.
      return;
    } // The priority changed. Cancel the existing callback. We'll schedule a new
    // one below.


    cancelCallback(existingCallbackNode);
  } // Schedule a new callback.


  var newCallbackNode;

  if (newCallbackPriority === SyncLanePriority) {
    // Special case: Sync React callbacks are scheduled on a special
    // internal queue
    newCallbackNode = scheduleSyncCallback(performSyncWorkOnRoot.bind(null, root));
  } else if (newCallbackPriority === SyncBatchedLanePriority) {
    newCallbackNode = scheduleCallback(ImmediatePriority$1, performSyncWorkOnRoot.bind(null, root));
  } else {
    var schedulerPriorityLevel = lanePriorityToSchedulerPriority(newCallbackPriority);
    newCallbackNode = scheduleCallback(schedulerPriorityLevel, performConcurrentWorkOnRoot.bind(null, root));
  }

  root.callbackPriority = newCallbackPriority;
  root.callbackNode = newCallbackNode;
} // This is the entry point for every concurrent task, i.e. anything that
// goes through Scheduler.


function performConcurrentWorkOnRoot(root) {
  // Since we know we're in a React event, we can clear the current
  // event time. The next update will compute a new event time.
  currentEventTime = NoTimestamp;
  currentEventWipLanes = NoLanes;
  currentEventPendingLanes = NoLanes;

  if (!((executionContext & (RenderContext | CommitContext)) === NoContext)) {
    {
      throw Error( "Should not already be working." );
    }
  } // Flush any pending passive effects before deciding which lanes to work on,
  // in case they schedule additional work.


  var originalCallbackNode = root.callbackNode;
  var didFlushPassiveEffects = flushPassiveEffects();

  if (didFlushPassiveEffects) {
    // Something in the passive effect phase may have canceled the current task.
    // Check if the task node for this root was changed.
    if (root.callbackNode !== originalCallbackNode) {
      // The current task was canceled. Exit. We don't need to call
      // `ensureRootIsScheduled` because the check above implies either that
      // there's a new task, or that there's no remaining work on this root.
      return null;
    }
  } // Determine the next expiration time to work on, using the fields stored
  // on the root.


  var lanes = getNextLanes(root, root === workInProgressRoot ? workInProgressRootRenderLanes : NoLanes);

  if (lanes === NoLanes) {
    // Defensive coding. This is never expected to happen.
    return null;
  }

  var exitStatus = renderRootConcurrent(root, lanes);

  if (includesSomeLane(workInProgressRootIncludedLanes, workInProgressRootUpdatedLanes)) {
    // The render included lanes that were updated during the render phase.
    // For example, when unhiding a hidden tree, we include all the lanes
    // that were previously skipped when the tree was hidden. That set of
    // lanes is a superset of the lanes we started rendering with.
    //
    // So we'll throw out the current work and restart.
    prepareFreshStack(root, NoLanes);
  } else if (exitStatus !== RootIncomplete) {
    if (exitStatus === RootErrored) {
      executionContext |= RetryAfterError; // If an error occurred during hydration,
      // discard server response and fall back to client side render.

      if (root.hydrate) {
        root.hydrate = false;
        clearContainer(root.containerInfo);
      } // If something threw an error, try rendering one more time. We'll render
      // synchronously to block concurrent data mutations, and we'll includes
      // all pending updates are included. If it still fails after the second
      // attempt, we'll give up and commit the resulting tree.


      lanes = getLanesToRetrySynchronouslyOnError(root);

      if (lanes !== NoLanes) {
        exitStatus = renderRootSync(root, lanes);
      }
    }

    if (exitStatus === RootFatalErrored) {
      var fatalError = workInProgressRootFatalError;
      prepareFreshStack(root, NoLanes);
      markRootSuspended$1(root, lanes);
      ensureRootIsScheduled(root, now());
      throw fatalError;
    } // We now have a consistent tree. The next step is either to commit it,
    // or, if something suspended, wait to commit it after a timeout.


    var finishedWork = root.current.alternate;
    root.finishedWork = finishedWork;
    root.finishedLanes = lanes;
    finishConcurrentRender(root, exitStatus, lanes);
  }

  ensureRootIsScheduled(root, now());

  if (root.callbackNode === originalCallbackNode) {
    // The task node scheduled for this root is the same one that's
    // currently executed. Need to return a continuation.
    return performConcurrentWorkOnRoot.bind(null, root);
  }

  return null;
}

function finishConcurrentRender(root, exitStatus, lanes) {
  switch (exitStatus) {
    case RootIncomplete:
    case RootFatalErrored:
      {
        {
          {
            throw Error( "Root did not complete. This is a bug in React." );
          }
        }
      }
    // Flow knows about invariant, so it complains if I add a break
    // statement, but eslint doesn't know about invariant, so it complains
    // if I do. eslint-disable-next-line no-fallthrough

    case RootErrored:
      {
        // We should have already attempted to retry this tree. If we reached
        // this point, it errored again. Commit it.
        commitRoot(root);
        break;
      }

    case RootSuspended:
      {
        markRootSuspended$1(root, lanes); // We have an acceptable loading state. We need to figure out if we
        // should immediately commit it or wait a bit.

        if (includesOnlyRetries(lanes) && // do not delay if we're inside an act() scope
        !shouldForceFlushFallbacksInDEV()) {
          // This render only included retries, no updates. Throttle committing
          // retries so that we don't show too many loading states too quickly.
          var msUntilTimeout = globalMostRecentFallbackTime + FALLBACK_THROTTLE_MS - now(); // Don't bother with a very short suspense time.

          if (msUntilTimeout > 10) {
            var nextLanes = getNextLanes(root, NoLanes);

            if (nextLanes !== NoLanes) {
              // There's additional work on this root.
              break;
            }

            var suspendedLanes = root.suspendedLanes;

            if (!isSubsetOfLanes(suspendedLanes, lanes)) {
              // We should prefer to render the fallback of at the last
              // suspended level. Ping the last suspended level to try
              // rendering it again.
              // FIXME: What if the suspended lanes are Idle? Should not restart.
              var eventTime = requestEventTime();
              markRootPinged(root, suspendedLanes);
              break;
            } // The render is suspended, it hasn't timed out, and there's no
            // lower priority work to do. Instead of committing the fallback
            // immediately, wait for more data to arrive.


            root.timeoutHandle = scheduleTimeout(commitRoot.bind(null, root), msUntilTimeout);
            break;
          }
        } // The work expired. Commit immediately.


        commitRoot(root);
        break;
      }

    case RootSuspendedWithDelay:
      {
        markRootSuspended$1(root, lanes);

        if (includesOnlyTransitions(lanes)) {
          // This is a transition, so we should exit without committing a
          // placeholder and without scheduling a timeout. Delay indefinitely
          // until we receive more data.
          break;
        }

        if (!shouldForceFlushFallbacksInDEV()) {
          // This is not a transition, but we did trigger an avoided state.
          // Schedule a placeholder to display after a short delay, using the Just
          // Noticeable Difference.
          // TODO: Is the JND optimization worth the added complexity? If this is
          // the only reason we track the event time, then probably not.
          // Consider removing.
          var mostRecentEventTime = getMostRecentEventTime(root, lanes);
          var eventTimeMs = mostRecentEventTime;
          var timeElapsedMs = now() - eventTimeMs;

          var _msUntilTimeout = jnd(timeElapsedMs) - timeElapsedMs; // Don't bother with a very short suspense time.


          if (_msUntilTimeout > 10) {
            // Instead of committing the fallback immediately, wait for more data
            // to arrive.
            root.timeoutHandle = scheduleTimeout(commitRoot.bind(null, root), _msUntilTimeout);
            break;
          }
        } // Commit the placeholder.


        commitRoot(root);
        break;
      }

    case RootCompleted:
      {
        // The work completed. Ready to commit.
        commitRoot(root);
        break;
      }

    default:
      {
        {
          {
            throw Error( "Unknown root exit status." );
          }
        }
      }
  }
}

function markRootSuspended$1(root, suspendedLanes) {
  // When suspending, we should always exclude lanes that were pinged or (more
  // rarely, since we try to avoid it) updated during the render phase.
  // TODO: Lol maybe there's a better way to factor this besides this
  // obnoxiously named function :)
  suspendedLanes = removeLanes(suspendedLanes, workInProgressRootPingedLanes);
  suspendedLanes = removeLanes(suspendedLanes, workInProgressRootUpdatedLanes);
  markRootSuspended(root, suspendedLanes);
} // This is the entry point for synchronous tasks that don't go
// through Scheduler


function performSyncWorkOnRoot(root) {
  if (!((executionContext & (RenderContext | CommitContext)) === NoContext)) {
    {
      throw Error( "Should not already be working." );
    }
  }

  flushPassiveEffects();
  var lanes;
  var exitStatus;

  if (root === workInProgressRoot && includesSomeLane(root.expiredLanes, workInProgressRootRenderLanes)) {
    // There's a partial tree, and at least one of its lanes has expired. Finish
    // rendering it before rendering the rest of the expired work.
    lanes = workInProgressRootRenderLanes;
    exitStatus = renderRootSync(root, lanes);

    if (includesSomeLane(workInProgressRootIncludedLanes, workInProgressRootUpdatedLanes)) {
      // The render included lanes that were updated during the render phase.
      // For example, when unhiding a hidden tree, we include all the lanes
      // that were previously skipped when the tree was hidden. That set of
      // lanes is a superset of the lanes we started rendering with.
      //
      // Note that this only happens when part of the tree is rendered
      // concurrently. If the whole tree is rendered synchronously, then there
      // are no interleaved events.
      lanes = getNextLanes(root, lanes);
      exitStatus = renderRootSync(root, lanes);
    }
  } else {
    lanes = getNextLanes(root, NoLanes);
    exitStatus = renderRootSync(root, lanes);
  }

  if (root.tag !== LegacyRoot && exitStatus === RootErrored) {
    executionContext |= RetryAfterError; // If an error occurred during hydration,
    // discard server response and fall back to client side render.

    if (root.hydrate) {
      root.hydrate = false;
      clearContainer(root.containerInfo);
    } // If something threw an error, try rendering one more time. We'll render
    // synchronously to block concurrent data mutations, and we'll includes
    // all pending updates are included. If it still fails after the second
    // attempt, we'll give up and commit the resulting tree.


    lanes = getLanesToRetrySynchronouslyOnError(root);

    if (lanes !== NoLanes) {
      exitStatus = renderRootSync(root, lanes);
    }
  }

  if (exitStatus === RootFatalErrored) {
    var fatalError = workInProgressRootFatalError;
    prepareFreshStack(root, NoLanes);
    markRootSuspended$1(root, lanes);
    ensureRootIsScheduled(root, now());
    throw fatalError;
  } // We now have a consistent tree. Because this is a sync render, we
  // will commit it even if something suspended.


  var finishedWork = root.current.alternate;
  root.finishedWork = finishedWork;
  root.finishedLanes = lanes;
  commitRoot(root); // Before exiting, make sure there's a callback scheduled for the next
  // pending level.

  ensureRootIsScheduled(root, now());
  return null;
}
function flushDiscreteUpdates() {
  // TODO: Should be able to flush inside batchedUpdates, but not inside `act`.
  // However, `act` uses `batchedUpdates`, so there's no way to distinguish
  // those two cases. Need to fix this before exposing flushDiscreteUpdates
  // as a public API.
  if ((executionContext & (BatchedContext | RenderContext | CommitContext)) !== NoContext) {
    {
      if ((executionContext & RenderContext) !== NoContext) {
        error('unstable_flushDiscreteUpdates: Cannot flush updates when React is ' + 'already rendering.');
      }
    } // We're already rendering, so we can't synchronously flush pending work.
    // This is probably a nested event dispatch triggered by a lifecycle/effect,
    // like `el.focus()`. Exit.


    return;
  }

  flushPendingDiscreteUpdates(); // If the discrete updates scheduled passive effects, flush them now so that
  // they fire before the next serial event.

  flushPassiveEffects();
}

function flushPendingDiscreteUpdates() {
  if (rootsWithPendingDiscreteUpdates !== null) {
    // For each root with pending discrete updates, schedule a callback to
    // immediately flush them.
    var roots = rootsWithPendingDiscreteUpdates;
    rootsWithPendingDiscreteUpdates = null;
    roots.forEach(function (root) {
      markDiscreteUpdatesExpired(root);
      ensureRootIsScheduled(root, now());
    });
  } // Now flush the immediate queue.


  flushSyncCallbackQueue();
}

function batchedUpdates$1(fn, a) {
  var prevExecutionContext = executionContext;
  executionContext |= BatchedContext;

  try {
    return fn(a);
  } finally {
    executionContext = prevExecutionContext;

    if (executionContext === NoContext) {
      // Flush the immediate callbacks that were scheduled during this batch
      resetRenderTimer();
      flushSyncCallbackQueue();
    }
  }
}
function batchedEventUpdates$1(fn, a) {
  var prevExecutionContext = executionContext;
  executionContext |= EventContext;

  try {
    return fn(a);
  } finally {
    executionContext = prevExecutionContext;

    if (executionContext === NoContext) {
      // Flush the immediate callbacks that were scheduled during this batch
      resetRenderTimer();
      flushSyncCallbackQueue();
    }
  }
}
function discreteUpdates$1(fn, a, b, c, d) {
  var prevExecutionContext = executionContext;
  executionContext |= DiscreteEventContext;

  {
    try {
      return runWithPriority$1(UserBlockingPriority$2, fn.bind(null, a, b, c, d));
    } finally {
      executionContext = prevExecutionContext;

      if (executionContext === NoContext) {
        // Flush the immediate callbacks that were scheduled during this batch
        resetRenderTimer();
        flushSyncCallbackQueue();
      }
    }
  }
}
function unbatchedUpdates(fn, a) {
  var prevExecutionContext = executionContext;
  executionContext &= ~BatchedContext;
  executionContext |= LegacyUnbatchedContext;

  try {
    return fn(a);
  } finally {
    executionContext = prevExecutionContext;

    if (executionContext === NoContext) {
      // Flush the immediate callbacks that were scheduled during this batch
      resetRenderTimer();
      flushSyncCallbackQueue();
    }
  }
}
function flushSync(fn, a) {
  var prevExecutionContext = executionContext;

  if ((prevExecutionContext & (RenderContext | CommitContext)) !== NoContext) {
    {
      error('flushSync was called from inside a lifecycle method. React cannot ' + 'flush when React is already rendering. Consider moving this call to ' + 'a scheduler task or micro task.');
    }

    return fn(a);
  }

  executionContext |= BatchedContext;

  {
    try {
      if (fn) {
        return runWithPriority$1(ImmediatePriority$1, fn.bind(null, a));
      } else {
        return undefined;
      }
    } finally {
      executionContext = prevExecutionContext; // Flush the immediate callbacks that were scheduled during this batch.
      // Note that this will happen even if batchedUpdates is higher up
      // the stack.

      flushSyncCallbackQueue();
    }
  }
}
function pushRenderLanes(fiber, lanes) {
  push(subtreeRenderLanesCursor, subtreeRenderLanes, fiber);
  subtreeRenderLanes = mergeLanes(subtreeRenderLanes, lanes);
  workInProgressRootIncludedLanes = mergeLanes(workInProgressRootIncludedLanes, lanes);
}
function popRenderLanes(fiber) {
  subtreeRenderLanes = subtreeRenderLanesCursor.current;
  pop(subtreeRenderLanesCursor, fiber);
}

function prepareFreshStack(root, lanes) {
  root.finishedWork = null;
  root.finishedLanes = NoLanes;
  var timeoutHandle = root.timeoutHandle;

  if (timeoutHandle !== noTimeout) {
    // The root previous suspended and scheduled a timeout to commit a fallback
    // state. Now that we have additional work, cancel the timeout.
    root.timeoutHandle = noTimeout; // $FlowFixMe Complains noTimeout is not a TimeoutID, despite the check above

    cancelTimeout(timeoutHandle);
  }

  if (workInProgress !== null) {
    var interruptedWork = workInProgress.return;

    while (interruptedWork !== null) {
      unwindInterruptedWork(interruptedWork);
      interruptedWork = interruptedWork.return;
    }
  }

  workInProgressRoot = root;
  workInProgress = createWorkInProgress(root.current, null);
  workInProgressRootRenderLanes = subtreeRenderLanes = workInProgressRootIncludedLanes = lanes;
  workInProgressRootExitStatus = RootIncomplete;
  workInProgressRootFatalError = null;
  workInProgressRootSkippedLanes = NoLanes;
  workInProgressRootUpdatedLanes = NoLanes;
  workInProgressRootPingedLanes = NoLanes;

  {
    spawnedWorkDuringRender = null;
  }

  {
    ReactStrictModeWarnings.discardPendingWarnings();
  }
}

function handleError(root, thrownValue) {
  do {
    var erroredWork = workInProgress;

    try {
      // Reset module-level state that was set during the render phase.
      resetContextDependencies();
      resetHooksAfterThrow();
      resetCurrentFiber(); // TODO: I found and added this missing line while investigating a
      // separate issue. Write a regression test using string refs.

      ReactCurrentOwner$2.current = null;

      if (erroredWork === null || erroredWork.return === null) {
        // Expected to be working on a non-root fiber. This is a fatal error
        // because there's no ancestor that can handle it; the root is
        // supposed to capture all errors that weren't caught by an error
        // boundary.
        workInProgressRootExitStatus = RootFatalErrored;
        workInProgressRootFatalError = thrownValue; // Set `workInProgress` to null. This represents advancing to the next
        // sibling, or the parent if there are no siblings. But since the root
        // has no siblings nor a parent, we set it to null. Usually this is
        // handled by `completeUnitOfWork` or `unwindWork`, but since we're
        // intentionally not calling those, we need set it here.
        // TODO: Consider calling `unwindWork` to pop the contexts.

        workInProgress = null;
        return;
      }

      if (enableProfilerTimer && erroredWork.mode & ProfileMode) {
        // Record the time spent rendering before an error was thrown. This
        // avoids inaccurate Profiler durations in the case of a
        // suspended render.
        stopProfilerTimerIfRunningAndRecordDelta(erroredWork, true);
      }

      throwException(root, erroredWork.return, erroredWork, thrownValue, workInProgressRootRenderLanes);
      completeUnitOfWork(erroredWork);
    } catch (yetAnotherThrownValue) {
      // Something in the return path also threw.
      thrownValue = yetAnotherThrownValue;

      if (workInProgress === erroredWork && erroredWork !== null) {
        // If this boundary has already errored, then we had trouble processing
        // the error. Bubble it to the next boundary.
        erroredWork = erroredWork.return;
        workInProgress = erroredWork;
      } else {
        erroredWork = workInProgress;
      }

      continue;
    } // Return to the normal work loop.


    return;
  } while (true);
}

function pushDispatcher() {
  var prevDispatcher = ReactCurrentDispatcher$2.current;
  ReactCurrentDispatcher$2.current = ContextOnlyDispatcher;

  if (prevDispatcher === null) {
    // The React isomorphic package does not include a default dispatcher.
    // Instead the first renderer will lazily attach one, in order to give
    // nicer error messages.
    return ContextOnlyDispatcher;
  } else {
    return prevDispatcher;
  }
}

function popDispatcher(prevDispatcher) {
  ReactCurrentDispatcher$2.current = prevDispatcher;
}

function pushInteractions(root) {
  {
    var prevInteractions = tracing.__interactionsRef.current;
    tracing.__interactionsRef.current = root.memoizedInteractions;
    return prevInteractions;
  }
}

function popInteractions(prevInteractions) {
  {
    tracing.__interactionsRef.current = prevInteractions;
  }
}

function markCommitTimeOfFallback() {
  globalMostRecentFallbackTime = now();
}
function markSkippedUpdateLanes(lane) {
  workInProgressRootSkippedLanes = mergeLanes(lane, workInProgressRootSkippedLanes);
}
function renderDidSuspend() {
  if (workInProgressRootExitStatus === RootIncomplete) {
    workInProgressRootExitStatus = RootSuspended;
  }
}
function renderDidSuspendDelayIfPossible() {
  if (workInProgressRootExitStatus === RootIncomplete || workInProgressRootExitStatus === RootSuspended) {
    workInProgressRootExitStatus = RootSuspendedWithDelay;
  } // Check if there are updates that we skipped tree that might have unblocked
  // this render.


  if (workInProgressRoot !== null && (includesNonIdleWork(workInProgressRootSkippedLanes) || includesNonIdleWork(workInProgressRootUpdatedLanes))) {
    // Mark the current render as suspended so that we switch to working on
    // the updates that were skipped. Usually we only suspend at the end of
    // the render phase.
    // TODO: We should probably always mark the root as suspended immediately
    // (inside this function), since by suspending at the end of the render
    // phase introduces a potential mistake where we suspend lanes that were
    // pinged or updated while we were rendering.
    markRootSuspended$1(workInProgressRoot, workInProgressRootRenderLanes);
  }
}
function renderDidError() {
  if (workInProgressRootExitStatus !== RootCompleted) {
    workInProgressRootExitStatus = RootErrored;
  }
} // Called during render to determine if anything has suspended.
// Returns false if we're not sure.

function renderHasNotSuspendedYet() {
  // If something errored or completed, we can't really be sure,
  // so those are false.
  return workInProgressRootExitStatus === RootIncomplete;
}

function renderRootSync(root, lanes) {
  var prevExecutionContext = executionContext;
  executionContext |= RenderContext;
  var prevDispatcher = pushDispatcher(); // If the root or lanes have changed, throw out the existing stack
  // and prepare a fresh one. Otherwise we'll continue where we left off.

  if (workInProgressRoot !== root || workInProgressRootRenderLanes !== lanes) {
    prepareFreshStack(root, lanes);
    startWorkOnPendingInteractions(root, lanes);
  }

  var prevInteractions = pushInteractions(root);

  do {
    try {
      workLoopSync();
      break;
    } catch (thrownValue) {
      handleError(root, thrownValue);
    }
  } while (true);

  resetContextDependencies();

  {
    popInteractions(prevInteractions);
  }

  executionContext = prevExecutionContext;
  popDispatcher(prevDispatcher);

  if (workInProgress !== null) {
    // This is a sync render, so we should have finished the whole tree.
    {
      {
        throw Error( "Cannot commit an incomplete root. This error is likely caused by a bug in React. Please file an issue." );
      }
    }
  }


  workInProgressRoot = null;
  workInProgressRootRenderLanes = NoLanes;
  return workInProgressRootExitStatus;
} // The work loop is an extremely hot path. Tell Closure not to inline it.

/** @noinline */


function workLoopSync() {
  // Already timed out, so perform work without checking if we need to yield.
  while (workInProgress !== null) {
    performUnitOfWork(workInProgress);
  }
}

function renderRootConcurrent(root, lanes) {
  var prevExecutionContext = executionContext;
  executionContext |= RenderContext;
  var prevDispatcher = pushDispatcher(); // If the root or lanes have changed, throw out the existing stack
  // and prepare a fresh one. Otherwise we'll continue where we left off.

  if (workInProgressRoot !== root || workInProgressRootRenderLanes !== lanes) {
    resetRenderTimer();
    prepareFreshStack(root, lanes);
    startWorkOnPendingInteractions(root, lanes);
  }

  var prevInteractions = pushInteractions(root);

  do {
    try {
      workLoopConcurrent();
      break;
    } catch (thrownValue) {
      handleError(root, thrownValue);
    }
  } while (true);

  resetContextDependencies();

  {
    popInteractions(prevInteractions);
  }

  popDispatcher(prevDispatcher);
  executionContext = prevExecutionContext;


  if (workInProgress !== null) {

    return RootIncomplete;
  } else {


    workInProgressRoot = null;
    workInProgressRootRenderLanes = NoLanes; // Return the final exit status.

    return workInProgressRootExitStatus;
  }
}
/** @noinline */


function workLoopConcurrent() {
  // Perform work until Scheduler asks us to yield
  while (workInProgress !== null && !shouldYield()) {
    performUnitOfWork(workInProgress);
  }
}

function performUnitOfWork(unitOfWork) {
  // The current, flushed, state of this fiber is the alternate. Ideally
  // nothing should rely on this, but relying on it here means that we don't
  // need an additional field on the work in progress.
  var current = unitOfWork.alternate;
  setCurrentFiber(unitOfWork);
  var next;

  if ( (unitOfWork.mode & ProfileMode) !== NoMode) {
    startProfilerTimer(unitOfWork);
    next = beginWork$1(current, unitOfWork, subtreeRenderLanes);
    stopProfilerTimerIfRunningAndRecordDelta(unitOfWork, true);
  } else {
    next = beginWork$1(current, unitOfWork, subtreeRenderLanes);
  }

  resetCurrentFiber();
  unitOfWork.memoizedProps = unitOfWork.pendingProps;

  if (next === null) {
    // If this doesn't spawn new work, complete the current work.
    completeUnitOfWork(unitOfWork);
  } else {
    workInProgress = next;
  }

  ReactCurrentOwner$2.current = null;
}

function completeUnitOfWork(unitOfWork) {
  // Attempt to complete the current unit of work, then move to the next
  // sibling. If there are no more siblings, return to the parent fiber.
  var completedWork = unitOfWork;

  do {
    // The current, flushed, state of this fiber is the alternate. Ideally
    // nothing should rely on this, but relying on it here means that we don't
    // need an additional field on the work in progress.
    var current = completedWork.alternate;
    var returnFiber = completedWork.return; // Check if the work completed or if something threw.

    if ((completedWork.flags & Incomplete) === NoFlags) {
      setCurrentFiber(completedWork);
      var next = void 0;

      if ( (completedWork.mode & ProfileMode) === NoMode) {
        next = completeWork(current, completedWork, subtreeRenderLanes);
      } else {
        startProfilerTimer(completedWork);
        next = completeWork(current, completedWork, subtreeRenderLanes); // Update render duration assuming we didn't error.

        stopProfilerTimerIfRunningAndRecordDelta(completedWork, false);
      }

      resetCurrentFiber();

      if (next !== null) {
        // Completing this fiber spawned new work. Work on that next.
        workInProgress = next;
        return;
      }

      resetChildLanes(completedWork);

      if (returnFiber !== null && // Do not append effects to parents if a sibling failed to complete
      (returnFiber.flags & Incomplete) === NoFlags) {
        // Append all the effects of the subtree and this fiber onto the effect
        // list of the parent. The completion order of the children affects the
        // side-effect order.
        if (returnFiber.firstEffect === null) {
          returnFiber.firstEffect = completedWork.firstEffect;
        }

        if (completedWork.lastEffect !== null) {
          if (returnFiber.lastEffect !== null) {
            returnFiber.lastEffect.nextEffect = completedWork.firstEffect;
          }

          returnFiber.lastEffect = completedWork.lastEffect;
        } // If this fiber had side-effects, we append it AFTER the children's
        // side-effects. We can perform certain side-effects earlier if needed,
        // by doing multiple passes over the effect list. We don't want to
        // schedule our own side-effect on our own list because if end up
        // reusing children we'll schedule this effect onto itself since we're
        // at the end.


        var flags = completedWork.flags; // Skip both NoWork and PerformedWork tags when creating the effect
        // list. PerformedWork effect is read by React DevTools but shouldn't be
        // committed.

        if (flags > PerformedWork) {
          if (returnFiber.lastEffect !== null) {
            returnFiber.lastEffect.nextEffect = completedWork;
          } else {
            returnFiber.firstEffect = completedWork;
          }

          returnFiber.lastEffect = completedWork;
        }
      }
    } else {
      // This fiber did not complete because something threw. Pop values off
      // the stack without entering the complete phase. If this is a boundary,
      // capture values if possible.
      var _next = unwindWork(completedWork); // Because this fiber did not complete, don't reset its expiration time.


      if (_next !== null) {
        // If completing this work spawned new work, do that next. We'll come
        // back here again.
        // Since we're restarting, remove anything that is not a host effect
        // from the effect tag.
        _next.flags &= HostEffectMask;
        workInProgress = _next;
        return;
      }

      if ( (completedWork.mode & ProfileMode) !== NoMode) {
        // Record the render duration for the fiber that errored.
        stopProfilerTimerIfRunningAndRecordDelta(completedWork, false); // Include the time spent working on failed children before continuing.

        var actualDuration = completedWork.actualDuration;
        var child = completedWork.child;

        while (child !== null) {
          actualDuration += child.actualDuration;
          child = child.sibling;
        }

        completedWork.actualDuration = actualDuration;
      }

      if (returnFiber !== null) {
        // Mark the parent fiber as incomplete and clear its effect list.
        returnFiber.firstEffect = returnFiber.lastEffect = null;
        returnFiber.flags |= Incomplete;
      }
    }

    var siblingFiber = completedWork.sibling;

    if (siblingFiber !== null) {
      // If there is more work to do in this returnFiber, do that next.
      workInProgress = siblingFiber;
      return;
    } // Otherwise, return to the parent


    completedWork = returnFiber; // Update the next thing we're working on in case something throws.

    workInProgress = completedWork;
  } while (completedWork !== null); // We've reached the root.


  if (workInProgressRootExitStatus === RootIncomplete) {
    workInProgressRootExitStatus = RootCompleted;
  }
}

function resetChildLanes(completedWork) {
  if ( // TODO: Move this check out of the hot path by moving `resetChildLanes`
  // to switch statement in `completeWork`.
  (completedWork.tag === LegacyHiddenComponent || completedWork.tag === OffscreenComponent) && completedWork.memoizedState !== null && !includesSomeLane(subtreeRenderLanes, OffscreenLane) && (completedWork.mode & ConcurrentMode) !== NoLanes) {
    // The children of this component are hidden. Don't bubble their
    // expiration times.
    return;
  }

  var newChildLanes = NoLanes; // Bubble up the earliest expiration time.

  if ( (completedWork.mode & ProfileMode) !== NoMode) {
    // In profiling mode, resetChildExpirationTime is also used to reset
    // profiler durations.
    var actualDuration = completedWork.actualDuration;
    var treeBaseDuration = completedWork.selfBaseDuration; // When a fiber is cloned, its actualDuration is reset to 0. This value will
    // only be updated if work is done on the fiber (i.e. it doesn't bailout).
    // When work is done, it should bubble to the parent's actualDuration. If
    // the fiber has not been cloned though, (meaning no work was done), then
    // this value will reflect the amount of time spent working on a previous
    // render. In that case it should not bubble. We determine whether it was
    // cloned by comparing the child pointer.

    var shouldBubbleActualDurations = completedWork.alternate === null || completedWork.child !== completedWork.alternate.child;
    var child = completedWork.child;

    while (child !== null) {
      newChildLanes = mergeLanes(newChildLanes, mergeLanes(child.lanes, child.childLanes));

      if (shouldBubbleActualDurations) {
        actualDuration += child.actualDuration;
      }

      treeBaseDuration += child.treeBaseDuration;
      child = child.sibling;
    }

    var isTimedOutSuspense = completedWork.tag === SuspenseComponent && completedWork.memoizedState !== null;

    if (isTimedOutSuspense) {
      // Don't count time spent in a timed out Suspense subtree as part of the base duration.
      var primaryChildFragment = completedWork.child;

      if (primaryChildFragment !== null) {
        treeBaseDuration -= primaryChildFragment.treeBaseDuration;
      }
    }

    completedWork.actualDuration = actualDuration;
    completedWork.treeBaseDuration = treeBaseDuration;
  } else {
    var _child = completedWork.child;

    while (_child !== null) {
      newChildLanes = mergeLanes(newChildLanes, mergeLanes(_child.lanes, _child.childLanes));
      _child = _child.sibling;
    }
  }

  completedWork.childLanes = newChildLanes;
}

function commitRoot(root) {
  var renderPriorityLevel = getCurrentPriorityLevel();
  runWithPriority$1(ImmediatePriority$1, commitRootImpl.bind(null, root, renderPriorityLevel));
  return null;
}

function commitRootImpl(root, renderPriorityLevel) {
  do {
    // `flushPassiveEffects` will call `flushSyncUpdateQueue` at the end, which
    // means `flushPassiveEffects` will sometimes result in additional
    // passive effects. So we need to keep flushing in a loop until there are
    // no more pending effects.
    // TODO: Might be better if `flushPassiveEffects` did not automatically
    // flush synchronous work at the end, to avoid factoring hazards like this.
    flushPassiveEffects();
  } while (rootWithPendingPassiveEffects !== null);

  flushRenderPhaseStrictModeWarningsInDEV();

  if (!((executionContext & (RenderContext | CommitContext)) === NoContext)) {
    {
      throw Error( "Should not already be working." );
    }
  }

  var finishedWork = root.finishedWork;
  var lanes = root.finishedLanes;

  if (finishedWork === null) {

    return null;
  }

  root.finishedWork = null;
  root.finishedLanes = NoLanes;

  if (!(finishedWork !== root.current)) {
    {
      throw Error( "Cannot commit the same tree as before. This error is likely caused by a bug in React. Please file an issue." );
    }
  } // commitRoot never returns a continuation; it always finishes synchronously.
  // So we can clear these now to allow a new callback to be scheduled.


  root.callbackNode = null; // Update the first and last pending times on this root. The new first
  // pending time is whatever is left on the root fiber.

  var remainingLanes = mergeLanes(finishedWork.lanes, finishedWork.childLanes);
  markRootFinished(root, remainingLanes); // Clear already finished discrete updates in case that a later call of
  // `flushDiscreteUpdates` starts a useless render pass which may cancels
  // a scheduled timeout.

  if (rootsWithPendingDiscreteUpdates !== null) {
    if (!hasDiscreteLanes(remainingLanes) && rootsWithPendingDiscreteUpdates.has(root)) {
      rootsWithPendingDiscreteUpdates.delete(root);
    }
  }

  if (root === workInProgressRoot) {
    // We can reset these now that they are finished.
    workInProgressRoot = null;
    workInProgress = null;
    workInProgressRootRenderLanes = NoLanes;
  } // Get the list of effects.


  var firstEffect;

  if (finishedWork.flags > PerformedWork) {
    // A fiber's effect list consists only of its children, not itself. So if
    // the root has an effect, we need to add it to the end of the list. The
    // resulting list is the set that would belong to the root's parent, if it
    // had one; that is, all the effects in the tree including the root.
    if (finishedWork.lastEffect !== null) {
      finishedWork.lastEffect.nextEffect = finishedWork;
      firstEffect = finishedWork.firstEffect;
    } else {
      firstEffect = finishedWork;
    }
  } else {
    // There is no effect on the root.
    firstEffect = finishedWork.firstEffect;
  }

  if (firstEffect !== null) {

    var prevExecutionContext = executionContext;
    executionContext |= CommitContext;
    var prevInteractions = pushInteractions(root); // Reset this to null before calling lifecycles

    ReactCurrentOwner$2.current = null; // The commit phase is broken into several sub-phases. We do a separate pass
    // of the effect list for each phase: all mutation effects come before all
    // layout effects, and so on.
    // The first phase a "before mutation" phase. We use this phase to read the
    // state of the host tree right before we mutate it. This is where
    // getSnapshotBeforeUpdate is called.

    focusedInstanceHandle = prepareForCommit(root.containerInfo);
    shouldFireAfterActiveInstanceBlur = false;
    nextEffect = firstEffect;

    do {
      {
        invokeGuardedCallback(null, commitBeforeMutationEffects, null);

        if (hasCaughtError()) {
          if (!(nextEffect !== null)) {
            {
              throw Error( "Should be working on an effect." );
            }
          }

          var error = clearCaughtError();
          captureCommitPhaseError(nextEffect, error);
          nextEffect = nextEffect.nextEffect;
        }
      }
    } while (nextEffect !== null); // We no longer need to track the active instance fiber


    focusedInstanceHandle = null;

    {
      // Mark the current commit time to be shared by all Profilers in this
      // batch. This enables them to be grouped later.
      recordCommitTime();
    } // The next phase is the mutation phase, where we mutate the host tree.


    nextEffect = firstEffect;

    do {
      {
        invokeGuardedCallback(null, commitMutationEffects, null, root, renderPriorityLevel);

        if (hasCaughtError()) {
          if (!(nextEffect !== null)) {
            {
              throw Error( "Should be working on an effect." );
            }
          }

          var _error = clearCaughtError();

          captureCommitPhaseError(nextEffect, _error);
          nextEffect = nextEffect.nextEffect;
        }
      }
    } while (nextEffect !== null);

    resetAfterCommit(root.containerInfo); // The work-in-progress tree is now the current tree. This must come after
    // the mutation phase, so that the previous tree is still current during
    // componentWillUnmount, but before the layout phase, so that the finished
    // work is current during componentDidMount/Update.

    root.current = finishedWork; // The next phase is the layout phase, where we call effects that read
    // the host tree after it's been mutated. The idiomatic use case for this is
    // layout, but class component lifecycles also fire here for legacy reasons.

    nextEffect = firstEffect;

    do {
      {
        invokeGuardedCallback(null, commitLayoutEffects, null, root, lanes);

        if (hasCaughtError()) {
          if (!(nextEffect !== null)) {
            {
              throw Error( "Should be working on an effect." );
            }
          }

          var _error2 = clearCaughtError();

          captureCommitPhaseError(nextEffect, _error2);
          nextEffect = nextEffect.nextEffect;
        }
      }
    } while (nextEffect !== null);

    nextEffect = null; // Tell Scheduler to yield at the end of the frame, so the browser has an
    // opportunity to paint.

    requestPaint();

    {
      popInteractions(prevInteractions);
    }

    executionContext = prevExecutionContext;
  } else {
    // No effects.
    root.current = finishedWork; // Measure these anyway so the flamegraph explicitly shows that there were
    // no effects.
    // TODO: Maybe there's a better way to report this.

    {
      recordCommitTime();
    }
  }

  var rootDidHavePassiveEffects = rootDoesHavePassiveEffects;

  if (rootDoesHavePassiveEffects) {
    // This commit has passive effects. Stash a reference to them. But don't
    // schedule a callback until after flushing layout work.
    rootDoesHavePassiveEffects = false;
    rootWithPendingPassiveEffects = root;
    pendingPassiveEffectsLanes = lanes;
    pendingPassiveEffectsRenderPriority = renderPriorityLevel;
  } else {
    // We are done with the effect chain at this point so let's clear the
    // nextEffect pointers to assist with GC. If we have passive effects, we'll
    // clear this in flushPassiveEffects.
    nextEffect = firstEffect;

    while (nextEffect !== null) {
      var nextNextEffect = nextEffect.nextEffect;
      nextEffect.nextEffect = null;

      if (nextEffect.flags & Deletion) {
        detachFiberAfterEffects(nextEffect);
      }

      nextEffect = nextNextEffect;
    }
  } // Read this again, since an effect might have updated it


  remainingLanes = root.pendingLanes; // Check if there's remaining work on this root

  if (remainingLanes !== NoLanes) {
    {
      if (spawnedWorkDuringRender !== null) {
        var expirationTimes = spawnedWorkDuringRender;
        spawnedWorkDuringRender = null;

        for (var i = 0; i < expirationTimes.length; i++) {
          scheduleInteractions(root, expirationTimes[i], root.memoizedInteractions);
        }
      }

      schedulePendingInteractions(root, remainingLanes);
    }
  } else {
    // If there's no remaining work, we can clear the set of already failed
    // error boundaries.
    legacyErrorBoundariesThatAlreadyFailed = null;
  }

  {
    if (!rootDidHavePassiveEffects) {
      // If there are no passive effects, then we can complete the pending interactions.
      // Otherwise, we'll wait until after the passive effects are flushed.
      // Wait to do this until after remaining work has been scheduled,
      // so that we don't prematurely signal complete for interactions when there's e.g. hidden work.
      finishPendingInteractions(root, lanes);
    }
  }

  if (remainingLanes === SyncLane) {
    // Count the number of times the root synchronously re-renders without
    // finishing. If there are too many, it indicates an infinite update loop.
    if (root === rootWithNestedUpdates) {
      nestedUpdateCount++;
    } else {
      nestedUpdateCount = 0;
      rootWithNestedUpdates = root;
    }
  } else {
    nestedUpdateCount = 0;
  }

  onCommitRoot(finishedWork.stateNode, renderPriorityLevel);

  {
    onCommitRoot$1();
  } // Always call this before exiting `commitRoot`, to ensure that any
  // additional work on this root is scheduled.


  ensureRootIsScheduled(root, now());

  if (hasUncaughtError) {
    hasUncaughtError = false;
    var _error3 = firstUncaughtError;
    firstUncaughtError = null;
    throw _error3;
  }

  if ((executionContext & LegacyUnbatchedContext) !== NoContext) {
    // a ReactDOM.render-ed root inside of batchedUpdates. The commit fired
    // synchronously, but layout updates should be deferred until the end
    // of the batch.


    return null;
  } // If layout work was scheduled, flush it now.


  flushSyncCallbackQueue();

  return null;
}

function commitBeforeMutationEffects() {
  while (nextEffect !== null) {
    var current = nextEffect.alternate;

    if (!shouldFireAfterActiveInstanceBlur && focusedInstanceHandle !== null) {
      if ((nextEffect.flags & Deletion) !== NoFlags) {
        if (doesFiberContain(nextEffect, focusedInstanceHandle)) {
          shouldFireAfterActiveInstanceBlur = true;
        }
      } else {
        // TODO: Move this out of the hot path using a dedicated effect tag.
        if (nextEffect.tag === SuspenseComponent && isSuspenseBoundaryBeingHidden(current, nextEffect) && doesFiberContain(nextEffect, focusedInstanceHandle)) {
          shouldFireAfterActiveInstanceBlur = true;
        }
      }
    }

    var flags = nextEffect.flags;

    if ((flags & Snapshot) !== NoFlags) {
      setCurrentFiber(nextEffect);
      commitBeforeMutationLifeCycles(current, nextEffect);
      resetCurrentFiber();
    }

    if ((flags & Passive) !== NoFlags) {
      // If there are passive effects, schedule a callback to flush at
      // the earliest opportunity.
      if (!rootDoesHavePassiveEffects) {
        rootDoesHavePassiveEffects = true;
        scheduleCallback(NormalPriority$1, function () {
          flushPassiveEffects();
          return null;
        });
      }
    }

    nextEffect = nextEffect.nextEffect;
  }
}

function commitMutationEffects(root, renderPriorityLevel) {
  // TODO: Should probably move the bulk of this function to commitWork.
  while (nextEffect !== null) {
    setCurrentFiber(nextEffect);
    var flags = nextEffect.flags;

    if (flags & ContentReset) {
      commitResetTextContent(nextEffect);
    }

    if (flags & Ref) {
      var current = nextEffect.alternate;

      if (current !== null) {
        commitDetachRef(current);
      }
    } // The following switch statement is only concerned about placement,
    // updates, and deletions. To avoid needing to add a case for every possible
    // bitmap value, we remove the secondary effects from the effect tag and
    // switch on that value.


    var primaryFlags = flags & (Placement | Update | Deletion | Hydrating);

    switch (primaryFlags) {
      case Placement:
        {
          commitPlacement(nextEffect); // Clear the "placement" from effect tag so that we know that this is
          // inserted, before any life-cycles like componentDidMount gets called.
          // TODO: findDOMNode doesn't rely on this any more but isMounted does
          // and isMounted is deprecated anyway so we should be able to kill this.

          nextEffect.flags &= ~Placement;
          break;
        }

      case PlacementAndUpdate:
        {
          // Placement
          commitPlacement(nextEffect); // Clear the "placement" from effect tag so that we know that this is
          // inserted, before any life-cycles like componentDidMount gets called.

          nextEffect.flags &= ~Placement; // Update

          var _current = nextEffect.alternate;
          commitWork(_current, nextEffect);
          break;
        }

      case Hydrating:
        {
          nextEffect.flags &= ~Hydrating;
          break;
        }

      case HydratingAndUpdate:
        {
          nextEffect.flags &= ~Hydrating; // Update

          var _current2 = nextEffect.alternate;
          commitWork(_current2, nextEffect);
          break;
        }

      case Update:
        {
          var _current3 = nextEffect.alternate;
          commitWork(_current3, nextEffect);
          break;
        }

      case Deletion:
        {
          commitDeletion(root, nextEffect);
          break;
        }
    }

    resetCurrentFiber();
    nextEffect = nextEffect.nextEffect;
  }
}

function commitLayoutEffects(root, committedLanes) {


  while (nextEffect !== null) {
    setCurrentFiber(nextEffect);
    var flags = nextEffect.flags;

    if (flags & (Update | Callback)) {
      var current = nextEffect.alternate;
      commitLifeCycles(root, current, nextEffect);
    }

    {
      if (flags & Ref) {
        commitAttachRef(nextEffect);
      }
    }

    resetCurrentFiber();
    nextEffect = nextEffect.nextEffect;
  }
}

function flushPassiveEffects() {
  // Returns whether passive effects were flushed.
  if (pendingPassiveEffectsRenderPriority !== NoPriority$1) {
    var priorityLevel = pendingPassiveEffectsRenderPriority > NormalPriority$1 ? NormalPriority$1 : pendingPassiveEffectsRenderPriority;
    pendingPassiveEffectsRenderPriority = NoPriority$1;

    {
      return runWithPriority$1(priorityLevel, flushPassiveEffectsImpl);
    }
  }

  return false;
}
function enqueuePendingPassiveHookEffectMount(fiber, effect) {
  pendingPassiveHookEffectsMount.push(effect, fiber);

  if (!rootDoesHavePassiveEffects) {
    rootDoesHavePassiveEffects = true;
    scheduleCallback(NormalPriority$1, function () {
      flushPassiveEffects();
      return null;
    });
  }
}
function enqueuePendingPassiveHookEffectUnmount(fiber, effect) {
  pendingPassiveHookEffectsUnmount.push(effect, fiber);

  {
    fiber.flags |= PassiveUnmountPendingDev;
    var alternate = fiber.alternate;

    if (alternate !== null) {
      alternate.flags |= PassiveUnmountPendingDev;
    }
  }

  if (!rootDoesHavePassiveEffects) {
    rootDoesHavePassiveEffects = true;
    scheduleCallback(NormalPriority$1, function () {
      flushPassiveEffects();
      return null;
    });
  }
}

function invokePassiveEffectCreate(effect) {
  var create = effect.create;
  effect.destroy = create();
}

function flushPassiveEffectsImpl() {
  if (rootWithPendingPassiveEffects === null) {
    return false;
  }

  var root = rootWithPendingPassiveEffects;
  var lanes = pendingPassiveEffectsLanes;
  rootWithPendingPassiveEffects = null;
  pendingPassiveEffectsLanes = NoLanes;

  if (!((executionContext & (RenderContext | CommitContext)) === NoContext)) {
    {
      throw Error( "Cannot flush passive effects while already rendering." );
    }
  }

  {
    isFlushingPassiveEffects = true;
  }

  var prevExecutionContext = executionContext;
  executionContext |= CommitContext;
  var prevInteractions = pushInteractions(root); // It's important that ALL pending passive effect destroy functions are called
  // before ANY passive effect create functions are called.
  // Otherwise effects in sibling components might interfere with each other.
  // e.g. a destroy function in one component may unintentionally override a ref
  // value set by a create function in another component.
  // Layout effects have the same constraint.
  // First pass: Destroy stale passive effects.

  var unmountEffects = pendingPassiveHookEffectsUnmount;
  pendingPassiveHookEffectsUnmount = [];

  for (var i = 0; i < unmountEffects.length; i += 2) {
    var _effect = unmountEffects[i];
    var fiber = unmountEffects[i + 1];
    var destroy = _effect.destroy;
    _effect.destroy = undefined;

    {
      fiber.flags &= ~PassiveUnmountPendingDev;
      var alternate = fiber.alternate;

      if (alternate !== null) {
        alternate.flags &= ~PassiveUnmountPendingDev;
      }
    }

    if (typeof destroy === 'function') {
      {
        setCurrentFiber(fiber);

        {
          invokeGuardedCallback(null, destroy, null);
        }

        if (hasCaughtError()) {
          if (!(fiber !== null)) {
            {
              throw Error( "Should be working on an effect." );
            }
          }

          var error = clearCaughtError();
          captureCommitPhaseError(fiber, error);
        }

        resetCurrentFiber();
      }
    }
  } // Second pass: Create new passive effects.


  var mountEffects = pendingPassiveHookEffectsMount;
  pendingPassiveHookEffectsMount = [];

  for (var _i = 0; _i < mountEffects.length; _i += 2) {
    var _effect2 = mountEffects[_i];
    var _fiber = mountEffects[_i + 1];

    {
      setCurrentFiber(_fiber);

      {
        invokeGuardedCallback(null, invokePassiveEffectCreate, null, _effect2);
      }

      if (hasCaughtError()) {
        if (!(_fiber !== null)) {
          {
            throw Error( "Should be working on an effect." );
          }
        }

        var _error4 = clearCaughtError();

        captureCommitPhaseError(_fiber, _error4);
      }

      resetCurrentFiber();
    }
  } // Note: This currently assumes there are no passive effects on the root fiber
  // because the root is not part of its own effect list.
  // This could change in the future.


  var effect = root.current.firstEffect;

  while (effect !== null) {
    var nextNextEffect = effect.nextEffect; // Remove nextEffect pointer to assist GC

    effect.nextEffect = null;

    if (effect.flags & Deletion) {
      detachFiberAfterEffects(effect);
    }

    effect = nextNextEffect;
  }

  {
    popInteractions(prevInteractions);
    finishPendingInteractions(root, lanes);
  }

  {
    isFlushingPassiveEffects = false;
  }

  executionContext = prevExecutionContext;
  flushSyncCallbackQueue(); // If additional passive effects were scheduled, increment a counter. If this
  // exceeds the limit, we'll fire a warning.

  nestedPassiveUpdateCount = rootWithPendingPassiveEffects === null ? 0 : nestedPassiveUpdateCount + 1;
  return true;
}

function isAlreadyFailedLegacyErrorBoundary(instance) {
  return legacyErrorBoundariesThatAlreadyFailed !== null && legacyErrorBoundariesThatAlreadyFailed.has(instance);
}
function markLegacyErrorBoundaryAsFailed(instance) {
  if (legacyErrorBoundariesThatAlreadyFailed === null) {
    legacyErrorBoundariesThatAlreadyFailed = new Set([instance]);
  } else {
    legacyErrorBoundariesThatAlreadyFailed.add(instance);
  }
}

function prepareToThrowUncaughtError(error) {
  if (!hasUncaughtError) {
    hasUncaughtError = true;
    firstUncaughtError = error;
  }
}

var onUncaughtError = prepareToThrowUncaughtError;

function captureCommitPhaseErrorOnRoot(rootFiber, sourceFiber, error) {
  var errorInfo = createCapturedValue(error, sourceFiber);
  var update = createRootErrorUpdate(rootFiber, errorInfo, SyncLane);
  enqueueUpdate(rootFiber, update);
  var eventTime = requestEventTime();
  var root = markUpdateLaneFromFiberToRoot(rootFiber, SyncLane);

  if (root !== null) {
    markRootUpdated(root, SyncLane, eventTime);
    ensureRootIsScheduled(root, eventTime);
    schedulePendingInteractions(root, SyncLane);
  }
}

function captureCommitPhaseError(sourceFiber, error) {
  if (sourceFiber.tag === HostRoot) {
    // Error was thrown at the root. There is no parent, so the root
    // itself should capture it.
    captureCommitPhaseErrorOnRoot(sourceFiber, sourceFiber, error);
    return;
  }

  var fiber = sourceFiber.return;

  while (fiber !== null) {
    if (fiber.tag === HostRoot) {
      captureCommitPhaseErrorOnRoot(fiber, sourceFiber, error);
      return;
    } else if (fiber.tag === ClassComponent) {
      var ctor = fiber.type;
      var instance = fiber.stateNode;

      if (typeof ctor.getDerivedStateFromError === 'function' || typeof instance.componentDidCatch === 'function' && !isAlreadyFailedLegacyErrorBoundary(instance)) {
        var errorInfo = createCapturedValue(error, sourceFiber);
        var update = createClassErrorUpdate(fiber, errorInfo, SyncLane);
        enqueueUpdate(fiber, update);
        var eventTime = requestEventTime();
        var root = markUpdateLaneFromFiberToRoot(fiber, SyncLane);

        if (root !== null) {
          markRootUpdated(root, SyncLane, eventTime);
          ensureRootIsScheduled(root, eventTime);
          schedulePendingInteractions(root, SyncLane);
        } else {
          // This component has already been unmounted.
          // We can't schedule any follow up work for the root because the fiber is already unmounted,
          // but we can still call the log-only boundary so the error isn't swallowed.
          //
          // TODO This is only a temporary bandaid for the old reconciler fork.
          // We can delete this special case once the new fork is merged.
          if (typeof instance.componentDidCatch === 'function' && !isAlreadyFailedLegacyErrorBoundary(instance)) {
            try {
              instance.componentDidCatch(error, errorInfo);
            } catch (errorToIgnore) {// TODO Ignore this error? Rethrow it?
              // This is kind of an edge case.
            }
          }
        }

        return;
      }
    }

    fiber = fiber.return;
  }
}
function pingSuspendedRoot(root, wakeable, pingedLanes) {
  var pingCache = root.pingCache;

  if (pingCache !== null) {
    // The wakeable resolved, so we no longer need to memoize, because it will
    // never be thrown again.
    pingCache.delete(wakeable);
  }

  var eventTime = requestEventTime();
  markRootPinged(root, pingedLanes);

  if (workInProgressRoot === root && isSubsetOfLanes(workInProgressRootRenderLanes, pingedLanes)) {
    // Received a ping at the same priority level at which we're currently
    // rendering. We might want to restart this render. This should mirror
    // the logic of whether or not a root suspends once it completes.
    // TODO: If we're rendering sync either due to Sync, Batched or expired,
    // we should probably never restart.
    // If we're suspended with delay, or if it's a retry, we'll always suspend
    // so we can always restart.
    if (workInProgressRootExitStatus === RootSuspendedWithDelay || workInProgressRootExitStatus === RootSuspended && includesOnlyRetries(workInProgressRootRenderLanes) && now() - globalMostRecentFallbackTime < FALLBACK_THROTTLE_MS) {
      // Restart from the root.
      prepareFreshStack(root, NoLanes);
    } else {
      // Even though we can't restart right now, we might get an
      // opportunity later. So we mark this render as having a ping.
      workInProgressRootPingedLanes = mergeLanes(workInProgressRootPingedLanes, pingedLanes);
    }
  }

  ensureRootIsScheduled(root, eventTime);
  schedulePendingInteractions(root, pingedLanes);
}

function retryTimedOutBoundary(boundaryFiber, retryLane) {
  // The boundary fiber (a Suspense component or SuspenseList component)
  // previously was rendered in its fallback state. One of the promises that
  // suspended it has resolved, which means at least part of the tree was
  // likely unblocked. Try rendering again, at a new expiration time.
  if (retryLane === NoLane) {
    retryLane = requestRetryLane(boundaryFiber);
  } // TODO: Special case idle priority?


  var eventTime = requestEventTime();
  var root = markUpdateLaneFromFiberToRoot(boundaryFiber, retryLane);

  if (root !== null) {
    markRootUpdated(root, retryLane, eventTime);
    ensureRootIsScheduled(root, eventTime);
    schedulePendingInteractions(root, retryLane);
  }
}
function resolveRetryWakeable(boundaryFiber, wakeable) {
  var retryLane = NoLane; // Default

  var retryCache;

  {
    retryCache = boundaryFiber.stateNode;
  }

  if (retryCache !== null) {
    // The wakeable resolved, so we no longer need to memoize, because it will
    // never be thrown again.
    retryCache.delete(wakeable);
  }

  retryTimedOutBoundary(boundaryFiber, retryLane);
} // Computes the next Just Noticeable Difference (JND) boundary.
// The theory is that a person can't tell the difference between small differences in time.
// Therefore, if we wait a bit longer than necessary that won't translate to a noticeable
// difference in the experience. However, waiting for longer might mean that we can avoid
// showing an intermediate loading state. The longer we have already waited, the harder it
// is to tell small differences in time. Therefore, the longer we've already waited,
// the longer we can wait additionally. At some point we have to give up though.
// We pick a train model where the next boundary commits at a consistent schedule.
// These particular numbers are vague estimates. We expect to adjust them based on research.

function jnd(timeElapsed) {
  return timeElapsed < 120 ? 120 : timeElapsed < 480 ? 480 : timeElapsed < 1080 ? 1080 : timeElapsed < 1920 ? 1920 : timeElapsed < 3000 ? 3000 : timeElapsed < 4320 ? 4320 : ceil(timeElapsed / 1960) * 1960;
}

function checkForNestedUpdates() {
  if (nestedUpdateCount > NESTED_UPDATE_LIMIT) {
    nestedUpdateCount = 0;
    rootWithNestedUpdates = null;

    {
      {
        throw Error( "Maximum update depth exceeded. This can happen when a component repeatedly calls setState inside componentWillUpdate or componentDidUpdate. React limits the number of nested updates to prevent infinite loops." );
      }
    }
  }

  {
    if (nestedPassiveUpdateCount > NESTED_PASSIVE_UPDATE_LIMIT) {
      nestedPassiveUpdateCount = 0;

      error('Maximum update depth exceeded. This can happen when a component ' + "calls setState inside useEffect, but useEffect either doesn't " + 'have a dependency array, or one of the dependencies changes on ' + 'every render.');
    }
  }
}

function flushRenderPhaseStrictModeWarningsInDEV() {
  {
    ReactStrictModeWarnings.flushLegacyContextWarning();

    {
      ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings();
    }
  }
}

var didWarnStateUpdateForNotYetMountedComponent = null;

function warnAboutUpdateOnNotYetMountedFiberInDEV(fiber) {
  {
    if ((executionContext & RenderContext) !== NoContext) {
      // We let the other warning about render phase updates deal with this one.
      return;
    }

    if (!(fiber.mode & (BlockingMode | ConcurrentMode))) {
      return;
    }

    var tag = fiber.tag;

    if (tag !== IndeterminateComponent && tag !== HostRoot && tag !== ClassComponent && tag !== FunctionComponent && tag !== ForwardRef && tag !== MemoComponent && tag !== SimpleMemoComponent && tag !== Block) {
      // Only warn for user-defined components, not internal ones like Suspense.
      return;
    } // We show the whole stack but dedupe on the top component's name because
    // the problematic code almost always lies inside that component.


    var componentName = getComponentName(fiber.type) || 'ReactComponent';

    if (didWarnStateUpdateForNotYetMountedComponent !== null) {
      if (didWarnStateUpdateForNotYetMountedComponent.has(componentName)) {
        return;
      }

      didWarnStateUpdateForNotYetMountedComponent.add(componentName);
    } else {
      didWarnStateUpdateForNotYetMountedComponent = new Set([componentName]);
    }

    var previousFiber = current;

    try {
      setCurrentFiber(fiber);

      error("Can't perform a React state update on a component that hasn't mounted yet. " + 'This indicates that you have a side-effect in your render function that ' + 'asynchronously later calls tries to update the component. Move this work to ' + 'useEffect instead.');
    } finally {
      if (previousFiber) {
        setCurrentFiber(fiber);
      } else {
        resetCurrentFiber();
      }
    }
  }
}

var didWarnStateUpdateForUnmountedComponent = null;

function warnAboutUpdateOnUnmountedFiberInDEV(fiber) {
  {
    var tag = fiber.tag;

    if (tag !== HostRoot && tag !== ClassComponent && tag !== FunctionComponent && tag !== ForwardRef && tag !== MemoComponent && tag !== SimpleMemoComponent && tag !== Block) {
      // Only warn for user-defined components, not internal ones like Suspense.
      return;
    } // If there are pending passive effects unmounts for this Fiber,
    // we can assume that they would have prevented this update.


    if ((fiber.flags & PassiveUnmountPendingDev) !== NoFlags) {
      return;
    } // We show the whole stack but dedupe on the top component's name because
    // the problematic code almost always lies inside that component.


    var componentName = getComponentName(fiber.type) || 'ReactComponent';

    if (didWarnStateUpdateForUnmountedComponent !== null) {
      if (didWarnStateUpdateForUnmountedComponent.has(componentName)) {
        return;
      }

      didWarnStateUpdateForUnmountedComponent.add(componentName);
    } else {
      didWarnStateUpdateForUnmountedComponent = new Set([componentName]);
    }

    if (isFlushingPassiveEffects) ; else {
      var previousFiber = current;

      try {
        setCurrentFiber(fiber);

        error("Can't perform a React state update on an unmounted component. This " + 'is a no-op, but it indicates a memory leak in your application. To ' + 'fix, cancel all subscriptions and asynchronous tasks in %s.', tag === ClassComponent ? 'the componentWillUnmount method' : 'a useEffect cleanup function');
      } finally {
        if (previousFiber) {
          setCurrentFiber(fiber);
        } else {
          resetCurrentFiber();
        }
      }
    }
  }
}

var beginWork$1;

{
  var dummyFiber = null;

  beginWork$1 = function (current, unitOfWork, lanes) {
    // If a component throws an error, we replay it again in a synchronously
    // dispatched event, so that the debugger will treat it as an uncaught
    // error See ReactErrorUtils for more information.
    // Before entering the begin phase, copy the work-in-progress onto a dummy
    // fiber. If beginWork throws, we'll use this to reset the state.
    var originalWorkInProgressCopy = assignFiberPropertiesInDEV(dummyFiber, unitOfWork);

    try {
      return beginWork(current, unitOfWork, lanes);
    } catch (originalError) {
      if (originalError !== null && typeof originalError === 'object' && typeof originalError.then === 'function') {
        // Don't replay promises. Treat everything else like an error.
        throw originalError;
      } // Keep this code in sync with handleError; any changes here must have
      // corresponding changes there.


      resetContextDependencies();
      resetHooksAfterThrow(); // Don't reset current debug fiber, since we're about to work on the
      // same fiber again.
      // Unwind the failed stack frame

      unwindInterruptedWork(unitOfWork); // Restore the original properties of the fiber.

      assignFiberPropertiesInDEV(unitOfWork, originalWorkInProgressCopy);

      if ( unitOfWork.mode & ProfileMode) {
        // Reset the profiler timer.
        startProfilerTimer(unitOfWork);
      } // Run beginWork again.


      invokeGuardedCallback(null, beginWork, null, current, unitOfWork, lanes);

      if (hasCaughtError()) {
        var replayError = clearCaughtError(); // `invokeGuardedCallback` sometimes sets an expando `_suppressLogging`.
        // Rethrow this error instead of the original one.

        throw replayError;
      } else {
        // This branch is reachable if the render phase is impure.
        throw originalError;
      }
    }
  };
}

var didWarnAboutUpdateInRender = false;
var didWarnAboutUpdateInRenderForAnotherComponent;

{
  didWarnAboutUpdateInRenderForAnotherComponent = new Set();
}

function warnAboutRenderPhaseUpdatesInDEV(fiber) {
  {
    if (isRendering && (executionContext & RenderContext) !== NoContext && !getIsUpdatingOpaqueValueInRenderPhaseInDEV()) {
      switch (fiber.tag) {
        case FunctionComponent:
        case ForwardRef:
        case SimpleMemoComponent:
          {
            var renderingComponentName = workInProgress && getComponentName(workInProgress.type) || 'Unknown'; // Dedupe by the rendering component because it's the one that needs to be fixed.

            var dedupeKey = renderingComponentName;

            if (!didWarnAboutUpdateInRenderForAnotherComponent.has(dedupeKey)) {
              didWarnAboutUpdateInRenderForAnotherComponent.add(dedupeKey);
              var setStateComponentName = getComponentName(fiber.type) || 'Unknown';

              error('Cannot update a component (`%s`) while rendering a ' + 'different component (`%s`). To locate the bad setState() call inside `%s`, ' + 'follow the stack trace as described in https://reactjs.org/link/setstate-in-render', setStateComponentName, renderingComponentName, renderingComponentName);
            }

            break;
          }

        case ClassComponent:
          {
            if (!didWarnAboutUpdateInRender) {
              error('Cannot update during an existing state transition (such as ' + 'within `render`). Render methods should be a pure ' + 'function of props and state.');

              didWarnAboutUpdateInRender = true;
            }

            break;
          }
      }
    }
  }
} // a 'shared' variable that changes when act() opens/closes in tests.


var IsThisRendererActing = {
  current: false
};
function warnIfNotScopedWithMatchingAct(fiber) {
  {
    if ( IsSomeRendererActing.current === true && IsThisRendererActing.current !== true) {
      var previousFiber = current;

      try {
        setCurrentFiber(fiber);

        error("It looks like you're using the wrong act() around your test interactions.\n" + 'Be sure to use the matching version of act() corresponding to your renderer:\n\n' + '// for react-dom:\n' + // Break up imports to avoid accidentally parsing them as dependencies.
        'import {act} fr' + "om 'react-dom/test-utils';\n" + '// ...\n' + 'act(() => ...);\n\n' + '// for react-test-renderer:\n' + // Break up imports to avoid accidentally parsing them as dependencies.
        'import TestRenderer fr' + "om react-test-renderer';\n" + 'const {act} = TestRenderer;\n' + '// ...\n' + 'act(() => ...);');
      } finally {
        if (previousFiber) {
          setCurrentFiber(fiber);
        } else {
          resetCurrentFiber();
        }
      }
    }
  }
}
function warnIfNotCurrentlyActingEffectsInDEV(fiber) {
  {
    if ( (fiber.mode & StrictMode) !== NoMode && IsSomeRendererActing.current === false && IsThisRendererActing.current === false) {
      error('An update to %s ran an effect, but was not wrapped in act(...).\n\n' + 'When testing, code that causes React state updates should be ' + 'wrapped into act(...):\n\n' + 'act(() => {\n' + '  /* fire events that update state */\n' + '});\n' + '/* assert on the output */\n\n' + "This ensures that you're testing the behavior the user would see " + 'in the browser.' + ' Learn more at https://reactjs.org/link/wrap-tests-with-act', getComponentName(fiber.type));
    }
  }
}

function warnIfNotCurrentlyActingUpdatesInDEV(fiber) {
  {
    if ( executionContext === NoContext && IsSomeRendererActing.current === false && IsThisRendererActing.current === false) {
      var previousFiber = current;

      try {
        setCurrentFiber(fiber);

        error('An update to %s inside a test was not wrapped in act(...).\n\n' + 'When testing, code that causes React state updates should be ' + 'wrapped into act(...):\n\n' + 'act(() => {\n' + '  /* fire events that update state */\n' + '});\n' + '/* assert on the output */\n\n' + "This ensures that you're testing the behavior the user would see " + 'in the browser.' + ' Learn more at https://reactjs.org/link/wrap-tests-with-act', getComponentName(fiber.type));
      } finally {
        if (previousFiber) {
          setCurrentFiber(fiber);
        } else {
          resetCurrentFiber();
        }
      }
    }
  }
}

var warnIfNotCurrentlyActingUpdatesInDev = warnIfNotCurrentlyActingUpdatesInDEV; // In tests, we want to enforce a mocked scheduler.

var didWarnAboutUnmockedScheduler = false; // TODO Before we release concurrent mode, revisit this and decide whether a mocked
// scheduler is the actual recommendation. The alternative could be a testing build,
// a new lib, or whatever; we dunno just yet. This message is for early adopters
// to get their tests right.

function warnIfUnmockedScheduler(fiber) {
  {
    if (didWarnAboutUnmockedScheduler === false && Scheduler.unstable_flushAllWithoutAsserting === undefined) {
      if (fiber.mode & BlockingMode || fiber.mode & ConcurrentMode) {
        didWarnAboutUnmockedScheduler = true;

        error('In Concurrent or Sync modes, the "scheduler" module needs to be mocked ' + 'to guarantee consistent behaviour across tests and browsers. ' + 'For example, with jest: \n' + // Break up requires to avoid accidentally parsing them as dependencies.
        "jest.mock('scheduler', () => require" + "('scheduler/unstable_mock'));\n\n" + 'For more info, visit https://reactjs.org/link/mock-scheduler');
      }
    }
  }
}

function computeThreadID(root, lane) {
  // Interaction threads are unique per root and expiration time.
  // NOTE: Intentionally unsound cast. All that matters is that it's a number
  // and it represents a batch of work. Could make a helper function instead,
  // but meh this is fine for now.
  return lane * 1000 + root.interactionThreadID;
}

function markSpawnedWork(lane) {

  if (spawnedWorkDuringRender === null) {
    spawnedWorkDuringRender = [lane];
  } else {
    spawnedWorkDuringRender.push(lane);
  }
}

function scheduleInteractions(root, lane, interactions) {

  if (interactions.size > 0) {
    var pendingInteractionMap = root.pendingInteractionMap;
    var pendingInteractions = pendingInteractionMap.get(lane);

    if (pendingInteractions != null) {
      interactions.forEach(function (interaction) {
        if (!pendingInteractions.has(interaction)) {
          // Update the pending async work count for previously unscheduled interaction.
          interaction.__count++;
        }

        pendingInteractions.add(interaction);
      });
    } else {
      pendingInteractionMap.set(lane, new Set(interactions)); // Update the pending async work count for the current interactions.

      interactions.forEach(function (interaction) {
        interaction.__count++;
      });
    }

    var subscriber = tracing.__subscriberRef.current;

    if (subscriber !== null) {
      var threadID = computeThreadID(root, lane);
      subscriber.onWorkScheduled(interactions, threadID);
    }
  }
}

function schedulePendingInteractions(root, lane) {

  scheduleInteractions(root, lane, tracing.__interactionsRef.current);
}

function startWorkOnPendingInteractions(root, lanes) {
  // we can accurately attribute time spent working on it, And so that cascading
  // work triggered during the render phase will be associated with it.


  var interactions = new Set();
  root.pendingInteractionMap.forEach(function (scheduledInteractions, scheduledLane) {
    if (includesSomeLane(lanes, scheduledLane)) {
      scheduledInteractions.forEach(function (interaction) {
        return interactions.add(interaction);
      });
    }
  }); // Store the current set of interactions on the FiberRoot for a few reasons:
  // We can re-use it in hot functions like performConcurrentWorkOnRoot()
  // without having to recalculate it. We will also use it in commitWork() to
  // pass to any Profiler onRender() hooks. This also provides DevTools with a
  // way to access it when the onCommitRoot() hook is called.

  root.memoizedInteractions = interactions;

  if (interactions.size > 0) {
    var subscriber = tracing.__subscriberRef.current;

    if (subscriber !== null) {
      var threadID = computeThreadID(root, lanes);

      try {
        subscriber.onWorkStarted(interactions, threadID);
      } catch (error) {
        // If the subscriber throws, rethrow it in a separate task
        scheduleCallback(ImmediatePriority$1, function () {
          throw error;
        });
      }
    }
  }
}

function finishPendingInteractions(root, committedLanes) {

  var remainingLanesAfterCommit = root.pendingLanes;
  var subscriber;

  try {
    subscriber = tracing.__subscriberRef.current;

    if (subscriber !== null && root.memoizedInteractions.size > 0) {
      // FIXME: More than one lane can finish in a single commit.
      var threadID = computeThreadID(root, committedLanes);
      subscriber.onWorkStopped(root.memoizedInteractions, threadID);
    }
  } catch (error) {
    // If the subscriber throws, rethrow it in a separate task
    scheduleCallback(ImmediatePriority$1, function () {
      throw error;
    });
  } finally {
    // Clear completed interactions from the pending Map.
    // Unless the render was suspended or cascading work was scheduled,
    // In which case– leave pending interactions until the subsequent render.
    var pendingInteractionMap = root.pendingInteractionMap;
    pendingInteractionMap.forEach(function (scheduledInteractions, lane) {
      // Only decrement the pending interaction count if we're done.
      // If there's still work at the current priority,
      // That indicates that we are waiting for suspense data.
      if (!includesSomeLane(remainingLanesAfterCommit, lane)) {
        pendingInteractionMap.delete(lane);
        scheduledInteractions.forEach(function (interaction) {
          interaction.__count--;

          if (subscriber !== null && interaction.__count === 0) {
            try {
              subscriber.onInteractionScheduledWorkCompleted(interaction);
            } catch (error) {
              // If the subscriber throws, rethrow it in a separate task
              scheduleCallback(ImmediatePriority$1, function () {
                throw error;
              });
            }
          }
        });
      }
    });
  }
} // `act` testing API

function shouldForceFlushFallbacksInDEV() {
  // Never force flush in production. This function should get stripped out.
  return  actingUpdatesScopeDepth > 0;
}
// so we can tell if any async act() calls try to run in parallel.


var actingUpdatesScopeDepth = 0;

function detachFiberAfterEffects(fiber) {
  fiber.sibling = null;
  fiber.stateNode = null;
}

var resolveFamily = null; // $FlowFixMe Flow gets confused by a WeakSet feature check below.

var failedBoundaries = null;
var setRefreshHandler = function (handler) {
  {
    resolveFamily = handler;
  }
};
function resolveFunctionForHotReloading(type) {
  {
    if (resolveFamily === null) {
      // Hot reloading is disabled.
      return type;
    }

    var family = resolveFamily(type);

    if (family === undefined) {
      return type;
    } // Use the latest known implementation.


    return family.current;
  }
}
function resolveClassForHotReloading(type) {
  // No implementation differences.
  return resolveFunctionForHotReloading(type);
}
function resolveForwardRefForHotReloading(type) {
  {
    if (resolveFamily === null) {
      // Hot reloading is disabled.
      return type;
    }

    var family = resolveFamily(type);

    if (family === undefined) {
      // Check if we're dealing with a real forwardRef. Don't want to crash early.
      if (type !== null && type !== undefined && typeof type.render === 'function') {
        // ForwardRef is special because its resolved .type is an object,
        // but it's possible that we only have its inner render function in the map.
        // If that inner render function is different, we'll build a new forwardRef type.
        var currentRender = resolveFunctionForHotReloading(type.render);

        if (type.render !== currentRender) {
          var syntheticType = {
            $$typeof: REACT_FORWARD_REF_TYPE,
            render: currentRender
          };

          if (type.displayName !== undefined) {
            syntheticType.displayName = type.displayName;
          }

          return syntheticType;
        }
      }

      return type;
    } // Use the latest known implementation.


    return family.current;
  }
}
function isCompatibleFamilyForHotReloading(fiber, element) {
  {
    if (resolveFamily === null) {
      // Hot reloading is disabled.
      return false;
    }

    var prevType = fiber.elementType;
    var nextType = element.type; // If we got here, we know types aren't === equal.

    var needsCompareFamilies = false;
    var $$typeofNextType = typeof nextType === 'object' && nextType !== null ? nextType.$$typeof : null;

    switch (fiber.tag) {
      case ClassComponent:
        {
          if (typeof nextType === 'function') {
            needsCompareFamilies = true;
          }

          break;
        }

      case FunctionComponent:
        {
          if (typeof nextType === 'function') {
            needsCompareFamilies = true;
          } else if ($$typeofNextType === REACT_LAZY_TYPE) {
            // We don't know the inner type yet.
            // We're going to assume that the lazy inner type is stable,
            // and so it is sufficient to avoid reconciling it away.
            // We're not going to unwrap or actually use the new lazy type.
            needsCompareFamilies = true;
          }

          break;
        }

      case ForwardRef:
        {
          if ($$typeofNextType === REACT_FORWARD_REF_TYPE) {
            needsCompareFamilies = true;
          } else if ($$typeofNextType === REACT_LAZY_TYPE) {
            needsCompareFamilies = true;
          }

          break;
        }

      case MemoComponent:
      case SimpleMemoComponent:
        {
          if ($$typeofNextType === REACT_MEMO_TYPE) {
            // TODO: if it was but can no longer be simple,
            // we shouldn't set this.
            needsCompareFamilies = true;
          } else if ($$typeofNextType === REACT_LAZY_TYPE) {
            needsCompareFamilies = true;
          }

          break;
        }

      default:
        return false;
    } // Check if both types have a family and it's the same one.


    if (needsCompareFamilies) {
      // Note: memo() and forwardRef() we'll compare outer rather than inner type.
      // This means both of them need to be registered to preserve state.
      // If we unwrapped and compared the inner types for wrappers instead,
      // then we would risk falsely saying two separate memo(Foo)
      // calls are equivalent because they wrap the same Foo function.
      var prevFamily = resolveFamily(prevType);

      if (prevFamily !== undefined && prevFamily === resolveFamily(nextType)) {
        return true;
      }
    }

    return false;
  }
}
function markFailedErrorBoundaryForHotReloading(fiber) {
  {
    if (resolveFamily === null) {
      // Hot reloading is disabled.
      return;
    }

    if (typeof WeakSet !== 'function') {
      return;
    }

    if (failedBoundaries === null) {
      failedBoundaries = new WeakSet();
    }

    failedBoundaries.add(fiber);
  }
}
var scheduleRefresh = function (root, update) {
  {
    if (resolveFamily === null) {
      // Hot reloading is disabled.
      return;
    }

    var staleFamilies = update.staleFamilies,
        updatedFamilies = update.updatedFamilies;
    flushPassiveEffects();
    flushSync(function () {
      scheduleFibersWithFamiliesRecursively(root.current, updatedFamilies, staleFamilies);
    });
  }
};
var scheduleRoot = function (root, element) {
  {
    if (root.context !== emptyContextObject) {
      // Super edge case: root has a legacy _renderSubtree context
      // but we don't know the parentComponent so we can't pass it.
      // Just ignore. We'll delete this with _renderSubtree code path later.
      return;
    }

    flushPassiveEffects();
    flushSync(function () {
      updateContainer(element, root, null, null);
    });
  }
};

function scheduleFibersWithFamiliesRecursively(fiber, updatedFamilies, staleFamilies) {
  {
    var alternate = fiber.alternate,
        child = fiber.child,
        sibling = fiber.sibling,
        tag = fiber.tag,
        type = fiber.type;
    var candidateType = null;

    switch (tag) {
      case FunctionComponent:
      case SimpleMemoComponent:
      case ClassComponent:
        candidateType = type;
        break;

      case ForwardRef:
        candidateType = type.render;
        break;
    }

    if (resolveFamily === null) {
      throw new Error('Expected resolveFamily to be set during hot reload.');
    }

    var needsRender = false;
    var needsRemount = false;

    if (candidateType !== null) {
      var family = resolveFamily(candidateType);

      if (family !== undefined) {
        if (staleFamilies.has(family)) {
          needsRemount = true;
        } else if (updatedFamilies.has(family)) {
          if (tag === ClassComponent) {
            needsRemount = true;
          } else {
            needsRender = true;
          }
        }
      }
    }

    if (failedBoundaries !== null) {
      if (failedBoundaries.has(fiber) || alternate !== null && failedBoundaries.has(alternate)) {
        needsRemount = true;
      }
    }

    if (needsRemount) {
      fiber._debugNeedsRemount = true;
    }

    if (needsRemount || needsRender) {
      scheduleUpdateOnFiber(fiber, SyncLane, NoTimestamp);
    }

    if (child !== null && !needsRemount) {
      scheduleFibersWithFamiliesRecursively(child, updatedFamilies, staleFamilies);
    }

    if (sibling !== null) {
      scheduleFibersWithFamiliesRecursively(sibling, updatedFamilies, staleFamilies);
    }
  }
}

var findHostInstancesForRefresh = function (root, families) {
  {
    var hostInstances = new Set();
    var types = new Set(families.map(function (family) {
      return family.current;
    }));
    findHostInstancesForMatchingFibersRecursively(root.current, types, hostInstances);
    return hostInstances;
  }
};

function findHostInstancesForMatchingFibersRecursively(fiber, types, hostInstances) {
  {
    var child = fiber.child,
        sibling = fiber.sibling,
        tag = fiber.tag,
        type = fiber.type;
    var candidateType = null;

    switch (tag) {
      case FunctionComponent:
      case SimpleMemoComponent:
      case ClassComponent:
        candidateType = type;
        break;

      case ForwardRef:
        candidateType = type.render;
        break;
    }

    var didMatch = false;

    if (candidateType !== null) {
      if (types.has(candidateType)) {
        didMatch = true;
      }
    }

    if (didMatch) {
      // We have a match. This only drills down to the closest host components.
      // There's no need to search deeper because for the purpose of giving
      // visual feedback, "flashing" outermost parent rectangles is sufficient.
      findHostInstancesForFiberShallowly(fiber, hostInstances);
    } else {
      // If there's no match, maybe there will be one further down in the child tree.
      if (child !== null) {
        findHostInstancesForMatchingFibersRecursively(child, types, hostInstances);
      }
    }

    if (sibling !== null) {
      findHostInstancesForMatchingFibersRecursively(sibling, types, hostInstances);
    }
  }
}

function findHostInstancesForFiberShallowly(fiber, hostInstances) {
  {
    var foundHostInstances = findChildHostInstancesForFiberShallowly(fiber, hostInstances);

    if (foundHostInstances) {
      return;
    } // If we didn't find any host children, fallback to closest host parent.


    var node = fiber;

    while (true) {
      switch (node.tag) {
        case HostComponent:
          hostInstances.add(node.stateNode);
          return;

        case HostPortal:
          hostInstances.add(node.stateNode.containerInfo);
          return;

        case HostRoot:
          hostInstances.add(node.stateNode.containerInfo);
          return;
      }

      if (node.return === null) {
        throw new Error('Expected to reach root first.');
      }

      node = node.return;
    }
  }
}

function findChildHostInstancesForFiberShallowly(fiber, hostInstances) {
  {
    var node = fiber;
    var foundHostInstances = false;

    while (true) {
      if (node.tag === HostComponent) {
        // We got a match.
        foundHostInstances = true;
        hostInstances.add(node.stateNode); // There may still be more, so keep searching.
      } else if (node.child !== null) {
        node.child.return = node;
        node = node.child;
        continue;
      }

      if (node === fiber) {
        return foundHostInstances;
      }

      while (node.sibling === null) {
        if (node.return === null || node.return === fiber) {
          return foundHostInstances;
        }

        node = node.return;
      }

      node.sibling.return = node.return;
      node = node.sibling;
    }
  }

  return false;
}

var hasBadMapPolyfill;

{
  hasBadMapPolyfill = false;

  try {
    var nonExtensibleObject = Object.preventExtensions({});
    /* eslint-disable no-new */

    new Map([[nonExtensibleObject, null]]);
    new Set([nonExtensibleObject]);
    /* eslint-enable no-new */
  } catch (e) {
    // TODO: Consider warning about bad polyfills
    hasBadMapPolyfill = true;
  }
}

var debugCounter = 1;

function FiberNode(tag, pendingProps, key, mode) {
  // Instance
  this.tag = tag;
  this.key = key;
  this.elementType = null;
  this.type = null;
  this.stateNode = null; // Fiber

  this.return = null;
  this.child = null;
  this.sibling = null;
  this.index = 0;
  this.ref = null;
  this.pendingProps = pendingProps;
  this.memoizedProps = null;
  this.updateQueue = null;
  this.memoizedState = null;
  this.dependencies = null;
  this.mode = mode; // Effects

  this.flags = NoFlags;
  this.nextEffect = null;
  this.firstEffect = null;
  this.lastEffect = null;
  this.lanes = NoLanes;
  this.childLanes = NoLanes;
  this.alternate = null;

  {
    // Note: The following is done to avoid a v8 performance cliff.
    //
    // Initializing the fields below to smis and later updating them with
    // double values will cause Fibers to end up having separate shapes.
    // This behavior/bug has something to do with Object.preventExtension().
    // Fortunately this only impacts DEV builds.
    // Unfortunately it makes React unusably slow for some applications.
    // To work around this, initialize the fields below with doubles.
    //
    // Learn more about this here:
    // https://github.com/facebook/react/issues/14365
    // https://bugs.chromium.org/p/v8/issues/detail?id=8538
    this.actualDuration = Number.NaN;
    this.actualStartTime = Number.NaN;
    this.selfBaseDuration = Number.NaN;
    this.treeBaseDuration = Number.NaN; // It's okay to replace the initial doubles with smis after initialization.
    // This won't trigger the performance cliff mentioned above,
    // and it simplifies other profiler code (including DevTools).

    this.actualDuration = 0;
    this.actualStartTime = -1;
    this.selfBaseDuration = 0;
    this.treeBaseDuration = 0;
  }

  {
    // This isn't directly used but is handy for debugging internals:
    this._debugID = debugCounter++;
    this._debugSource = null;
    this._debugOwner = null;
    this._debugNeedsRemount = false;
    this._debugHookTypes = null;

    if (!hasBadMapPolyfill && typeof Object.preventExtensions === 'function') {
      Object.preventExtensions(this);
    }
  }
} // This is a constructor function, rather than a POJO constructor, still
// please ensure we do the following:
// 1) Nobody should add any instance methods on this. Instance methods can be
//    more difficult to predict when they get optimized and they are almost
//    never inlined properly in static compilers.
// 2) Nobody should rely on `instanceof Fiber` for type testing. We should
//    always know when it is a fiber.
// 3) We might want to experiment with using numeric keys since they are easier
//    to optimize in a non-JIT environment.
// 4) We can easily go from a constructor to a createFiber object literal if that
//    is faster.
// 5) It should be easy to port this to a C struct and keep a C implementation
//    compatible.


var createFiber = function (tag, pendingProps, key, mode) {
  // $FlowFixMe: the shapes are exact here but Flow doesn't like constructors
  return new FiberNode(tag, pendingProps, key, mode);
};

function shouldConstruct$1(Component) {
  var prototype = Component.prototype;
  return !!(prototype && prototype.isReactComponent);
}

function isSimpleFunctionComponent(type) {
  return typeof type === 'function' && !shouldConstruct$1(type) && type.defaultProps === undefined;
}
function resolveLazyComponentTag(Component) {
  if (typeof Component === 'function') {
    return shouldConstruct$1(Component) ? ClassComponent : FunctionComponent;
  } else if (Component !== undefined && Component !== null) {
    var $$typeof = Component.$$typeof;

    if ($$typeof === REACT_FORWARD_REF_TYPE) {
      return ForwardRef;
    }

    if ($$typeof === REACT_MEMO_TYPE) {
      return MemoComponent;
    }
  }

  return IndeterminateComponent;
} // This is used to create an alternate fiber to do work on.

function createWorkInProgress(current, pendingProps) {
  var workInProgress = current.alternate;

  if (workInProgress === null) {
    // We use a double buffering pooling technique because we know that we'll
    // only ever need at most two versions of a tree. We pool the "other" unused
    // node that we're free to reuse. This is lazily created to avoid allocating
    // extra objects for things that are never updated. It also allow us to
    // reclaim the extra memory if needed.
    workInProgress = createFiber(current.tag, pendingProps, current.key, current.mode);
    workInProgress.elementType = current.elementType;
    workInProgress.type = current.type;
    workInProgress.stateNode = current.stateNode;

    {
      // DEV-only fields
      workInProgress._debugID = current._debugID;
      workInProgress._debugSource = current._debugSource;
      workInProgress._debugOwner = current._debugOwner;
      workInProgress._debugHookTypes = current._debugHookTypes;
    }

    workInProgress.alternate = current;
    current.alternate = workInProgress;
  } else {
    workInProgress.pendingProps = pendingProps; // Needed because Blocks store data on type.

    workInProgress.type = current.type; // We already have an alternate.
    // Reset the effect tag.

    workInProgress.flags = NoFlags; // The effect list is no longer valid.

    workInProgress.nextEffect = null;
    workInProgress.firstEffect = null;
    workInProgress.lastEffect = null;

    {
      // We intentionally reset, rather than copy, actualDuration & actualStartTime.
      // This prevents time from endlessly accumulating in new commits.
      // This has the downside of resetting values for different priority renders,
      // But works for yielding (the common case) and should support resuming.
      workInProgress.actualDuration = 0;
      workInProgress.actualStartTime = -1;
    }
  }

  workInProgress.childLanes = current.childLanes;
  workInProgress.lanes = current.lanes;
  workInProgress.child = current.child;
  workInProgress.memoizedProps = current.memoizedProps;
  workInProgress.memoizedState = current.memoizedState;
  workInProgress.updateQueue = current.updateQueue; // Clone the dependencies object. This is mutated during the render phase, so
  // it cannot be shared with the current fiber.

  var currentDependencies = current.dependencies;
  workInProgress.dependencies = currentDependencies === null ? null : {
    lanes: currentDependencies.lanes,
    firstContext: currentDependencies.firstContext
  }; // These will be overridden during the parent's reconciliation

  workInProgress.sibling = current.sibling;
  workInProgress.index = current.index;
  workInProgress.ref = current.ref;

  {
    workInProgress.selfBaseDuration = current.selfBaseDuration;
    workInProgress.treeBaseDuration = current.treeBaseDuration;
  }

  {
    workInProgress._debugNeedsRemount = current._debugNeedsRemount;

    switch (workInProgress.tag) {
      case IndeterminateComponent:
      case FunctionComponent:
      case SimpleMemoComponent:
        workInProgress.type = resolveFunctionForHotReloading(current.type);
        break;

      case ClassComponent:
        workInProgress.type = resolveClassForHotReloading(current.type);
        break;

      case ForwardRef:
        workInProgress.type = resolveForwardRefForHotReloading(current.type);
        break;
    }
  }

  return workInProgress;
} // Used to reuse a Fiber for a second pass.

function resetWorkInProgress(workInProgress, renderLanes) {
  // This resets the Fiber to what createFiber or createWorkInProgress would
  // have set the values to before during the first pass. Ideally this wouldn't
  // be necessary but unfortunately many code paths reads from the workInProgress
  // when they should be reading from current and writing to workInProgress.
  // We assume pendingProps, index, key, ref, return are still untouched to
  // avoid doing another reconciliation.
  // Reset the effect tag but keep any Placement tags, since that's something
  // that child fiber is setting, not the reconciliation.
  workInProgress.flags &= Placement; // The effect list is no longer valid.

  workInProgress.nextEffect = null;
  workInProgress.firstEffect = null;
  workInProgress.lastEffect = null;
  var current = workInProgress.alternate;

  if (current === null) {
    // Reset to createFiber's initial values.
    workInProgress.childLanes = NoLanes;
    workInProgress.lanes = renderLanes;
    workInProgress.child = null;
    workInProgress.memoizedProps = null;
    workInProgress.memoizedState = null;
    workInProgress.updateQueue = null;
    workInProgress.dependencies = null;
    workInProgress.stateNode = null;

    {
      // Note: We don't reset the actualTime counts. It's useful to accumulate
      // actual time across multiple render passes.
      workInProgress.selfBaseDuration = 0;
      workInProgress.treeBaseDuration = 0;
    }
  } else {
    // Reset to the cloned values that createWorkInProgress would've.
    workInProgress.childLanes = current.childLanes;
    workInProgress.lanes = current.lanes;
    workInProgress.child = current.child;
    workInProgress.memoizedProps = current.memoizedProps;
    workInProgress.memoizedState = current.memoizedState;
    workInProgress.updateQueue = current.updateQueue; // Needed because Blocks store data on type.

    workInProgress.type = current.type; // Clone the dependencies object. This is mutated during the render phase, so
    // it cannot be shared with the current fiber.

    var currentDependencies = current.dependencies;
    workInProgress.dependencies = currentDependencies === null ? null : {
      lanes: currentDependencies.lanes,
      firstContext: currentDependencies.firstContext
    };

    {
      // Note: We don't reset the actualTime counts. It's useful to accumulate
      // actual time across multiple render passes.
      workInProgress.selfBaseDuration = current.selfBaseDuration;
      workInProgress.treeBaseDuration = current.treeBaseDuration;
    }
  }

  return workInProgress;
}
function createHostRootFiber(tag) {
  var mode;

  if (tag === ConcurrentRoot) {
    mode = ConcurrentMode | BlockingMode | StrictMode;
  } else if (tag === BlockingRoot) {
    mode = BlockingMode | StrictMode;
  } else {
    mode = NoMode;
  }

  if ( isDevToolsPresent) {
    // Always collect profile timings when DevTools are present.
    // This enables DevTools to start capturing timing at any point–
    // Without some nodes in the tree having empty base times.
    mode |= ProfileMode;
  }

  return createFiber(HostRoot, null, null, mode);
}
function createFiberFromTypeAndProps(type, // React$ElementType
key, pendingProps, owner, mode, lanes) {
  var fiberTag = IndeterminateComponent; // The resolved type is set if we know what the final type will be. I.e. it's not lazy.

  var resolvedType = type;

  if (typeof type === 'function') {
    if (shouldConstruct$1(type)) {
      fiberTag = ClassComponent;

      {
        resolvedType = resolveClassForHotReloading(resolvedType);
      }
    } else {
      {
        resolvedType = resolveFunctionForHotReloading(resolvedType);
      }
    }
  } else if (typeof type === 'string') {
    fiberTag = HostComponent;
  } else {
    getTag: switch (type) {
      case REACT_FRAGMENT_TYPE:
        return createFiberFromFragment(pendingProps.children, mode, lanes, key);

      case REACT_DEBUG_TRACING_MODE_TYPE:
        fiberTag = Mode;
        mode |= DebugTracingMode;
        break;

      case REACT_STRICT_MODE_TYPE:
        fiberTag = Mode;
        mode |= StrictMode;
        break;

      case REACT_PROFILER_TYPE:
        return createFiberFromProfiler(pendingProps, mode, lanes, key);

      case REACT_SUSPENSE_TYPE:
        return createFiberFromSuspense(pendingProps, mode, lanes, key);

      case REACT_SUSPENSE_LIST_TYPE:
        return createFiberFromSuspenseList(pendingProps, mode, lanes, key);

      case REACT_OFFSCREEN_TYPE:
        return createFiberFromOffscreen(pendingProps, mode, lanes, key);

      case REACT_LEGACY_HIDDEN_TYPE:
        return createFiberFromLegacyHidden(pendingProps, mode, lanes, key);

      case REACT_SCOPE_TYPE:

      // eslint-disable-next-line no-fallthrough

      default:
        {
          if (typeof type === 'object' && type !== null) {
            switch (type.$$typeof) {
              case REACT_PROVIDER_TYPE:
                fiberTag = ContextProvider;
                break getTag;

              case REACT_CONTEXT_TYPE:
                // This is a consumer
                fiberTag = ContextConsumer;
                break getTag;

              case REACT_FORWARD_REF_TYPE:
                fiberTag = ForwardRef;

                {
                  resolvedType = resolveForwardRefForHotReloading(resolvedType);
                }

                break getTag;

              case REACT_MEMO_TYPE:
                fiberTag = MemoComponent;
                break getTag;

              case REACT_LAZY_TYPE:
                fiberTag = LazyComponent;
                resolvedType = null;
                break getTag;

              case REACT_BLOCK_TYPE:
                fiberTag = Block;
                break getTag;
            }
          }

          var info = '';

          {
            if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {
              info += ' You likely forgot to export your component from the file ' + "it's defined in, or you might have mixed up default and " + 'named imports.';
            }

            var ownerName = owner ? getComponentName(owner.type) : null;

            if (ownerName) {
              info += '\n\nCheck the render method of `' + ownerName + '`.';
            }
          }

          {
            {
              throw Error( "Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) but got: " + (type == null ? type : typeof type) + "." + info );
            }
          }
        }
    }
  }

  var fiber = createFiber(fiberTag, pendingProps, key, mode);
  fiber.elementType = type;
  fiber.type = resolvedType;
  fiber.lanes = lanes;

  {
    fiber._debugOwner = owner;
  }

  return fiber;
}
function createFiberFromElement(element, mode, lanes) {
  var owner = null;

  {
    owner = element._owner;
  }

  var type = element.type;
  var key = element.key;
  var pendingProps = element.props;
  var fiber = createFiberFromTypeAndProps(type, key, pendingProps, owner, mode, lanes);

  {
    fiber._debugSource = element._source;
    fiber._debugOwner = element._owner;
  }

  return fiber;
}
function createFiberFromFragment(elements, mode, lanes, key) {
  var fiber = createFiber(Fragment, elements, key, mode);
  fiber.lanes = lanes;
  return fiber;
}

function createFiberFromProfiler(pendingProps, mode, lanes, key) {
  {
    if (typeof pendingProps.id !== 'string') {
      error('Profiler must specify an "id" as a prop');
    }
  }

  var fiber = createFiber(Profiler, pendingProps, key, mode | ProfileMode); // TODO: The Profiler fiber shouldn't have a type. It has a tag.

  fiber.elementType = REACT_PROFILER_TYPE;
  fiber.type = REACT_PROFILER_TYPE;
  fiber.lanes = lanes;

  {
    fiber.stateNode = {
      effectDuration: 0,
      passiveEffectDuration: 0
    };
  }

  return fiber;
}

function createFiberFromSuspense(pendingProps, mode, lanes, key) {
  var fiber = createFiber(SuspenseComponent, pendingProps, key, mode); // TODO: The SuspenseComponent fiber shouldn't have a type. It has a tag.
  // This needs to be fixed in getComponentName so that it relies on the tag
  // instead.

  fiber.type = REACT_SUSPENSE_TYPE;
  fiber.elementType = REACT_SUSPENSE_TYPE;
  fiber.lanes = lanes;
  return fiber;
}
function createFiberFromSuspenseList(pendingProps, mode, lanes, key) {
  var fiber = createFiber(SuspenseListComponent, pendingProps, key, mode);

  {
    // TODO: The SuspenseListComponent fiber shouldn't have a type. It has a tag.
    // This needs to be fixed in getComponentName so that it relies on the tag
    // instead.
    fiber.type = REACT_SUSPENSE_LIST_TYPE;
  }

  fiber.elementType = REACT_SUSPENSE_LIST_TYPE;
  fiber.lanes = lanes;
  return fiber;
}
function createFiberFromOffscreen(pendingProps, mode, lanes, key) {
  var fiber = createFiber(OffscreenComponent, pendingProps, key, mode); // TODO: The OffscreenComponent fiber shouldn't have a type. It has a tag.
  // This needs to be fixed in getComponentName so that it relies on the tag
  // instead.

  {
    fiber.type = REACT_OFFSCREEN_TYPE;
  }

  fiber.elementType = REACT_OFFSCREEN_TYPE;
  fiber.lanes = lanes;
  return fiber;
}
function createFiberFromLegacyHidden(pendingProps, mode, lanes, key) {
  var fiber = createFiber(LegacyHiddenComponent, pendingProps, key, mode); // TODO: The LegacyHidden fiber shouldn't have a type. It has a tag.
  // This needs to be fixed in getComponentName so that it relies on the tag
  // instead.

  {
    fiber.type = REACT_LEGACY_HIDDEN_TYPE;
  }

  fiber.elementType = REACT_LEGACY_HIDDEN_TYPE;
  fiber.lanes = lanes;
  return fiber;
}
function createFiberFromText(content, mode, lanes) {
  var fiber = createFiber(HostText, content, null, mode);
  fiber.lanes = lanes;
  return fiber;
}
function createFiberFromHostInstanceForDeletion() {
  var fiber = createFiber(HostComponent, null, null, NoMode); // TODO: These should not need a type.

  fiber.elementType = 'DELETED';
  fiber.type = 'DELETED';
  return fiber;
}
function createFiberFromPortal(portal, mode, lanes) {
  var pendingProps = portal.children !== null ? portal.children : [];
  var fiber = createFiber(HostPortal, pendingProps, portal.key, mode);
  fiber.lanes = lanes;
  fiber.stateNode = {
    containerInfo: portal.containerInfo,
    pendingChildren: null,
    // Used by persistent updates
    implementation: portal.implementation
  };
  return fiber;
} // Used for stashing WIP properties to replay failed work in DEV.

function assignFiberPropertiesInDEV(target, source) {
  if (target === null) {
    // This Fiber's initial properties will always be overwritten.
    // We only use a Fiber to ensure the same hidden class so DEV isn't slow.
    target = createFiber(IndeterminateComponent, null, null, NoMode);
  } // This is intentionally written as a list of all properties.
  // We tried to use Object.assign() instead but this is called in
  // the hottest path, and Object.assign() was too slow:
  // https://github.com/facebook/react/issues/12502
  // This code is DEV-only so size is not a concern.


  target.tag = source.tag;
  target.key = source.key;
  target.elementType = source.elementType;
  target.type = source.type;
  target.stateNode = source.stateNode;
  target.return = source.return;
  target.child = source.child;
  target.sibling = source.sibling;
  target.index = source.index;
  target.ref = source.ref;
  target.pendingProps = source.pendingProps;
  target.memoizedProps = source.memoizedProps;
  target.updateQueue = source.updateQueue;
  target.memoizedState = source.memoizedState;
  target.dependencies = source.dependencies;
  target.mode = source.mode;
  target.flags = source.flags;
  target.nextEffect = source.nextEffect;
  target.firstEffect = source.firstEffect;
  target.lastEffect = source.lastEffect;
  target.lanes = source.lanes;
  target.childLanes = source.childLanes;
  target.alternate = source.alternate;

  {
    target.actualDuration = source.actualDuration;
    target.actualStartTime = source.actualStartTime;
    target.selfBaseDuration = source.selfBaseDuration;
    target.treeBaseDuration = source.treeBaseDuration;
  }

  target._debugID = source._debugID;
  target._debugSource = source._debugSource;
  target._debugOwner = source._debugOwner;
  target._debugNeedsRemount = source._debugNeedsRemount;
  target._debugHookTypes = source._debugHookTypes;
  return target;
}

function FiberRootNode(containerInfo, tag, hydrate) {
  this.tag = tag;
  this.containerInfo = containerInfo;
  this.pendingChildren = null;
  this.current = null;
  this.pingCache = null;
  this.finishedWork = null;
  this.timeoutHandle = noTimeout;
  this.context = null;
  this.pendingContext = null;
  this.hydrate = hydrate;
  this.callbackNode = null;
  this.callbackPriority = NoLanePriority;
  this.eventTimes = createLaneMap(NoLanes);
  this.expirationTimes = createLaneMap(NoTimestamp);
  this.pendingLanes = NoLanes;
  this.suspendedLanes = NoLanes;
  this.pingedLanes = NoLanes;
  this.expiredLanes = NoLanes;
  this.mutableReadLanes = NoLanes;
  this.finishedLanes = NoLanes;
  this.entangledLanes = NoLanes;
  this.entanglements = createLaneMap(NoLanes);

  {
    this.mutableSourceEagerHydrationData = null;
  }

  {
    this.interactionThreadID = tracing.unstable_getThreadID();
    this.memoizedInteractions = new Set();
    this.pendingInteractionMap = new Map();
  }

  {
    switch (tag) {
      case BlockingRoot:
        this._debugRootType = 'createBlockingRoot()';
        break;

      case ConcurrentRoot:
        this._debugRootType = 'createRoot()';
        break;

      case LegacyRoot:
        this._debugRootType = 'createLegacyRoot()';
        break;
    }
  }
}

function createFiberRoot(containerInfo, tag, hydrate, hydrationCallbacks) {
  var root = new FiberRootNode(containerInfo, tag, hydrate);
  // stateNode is any.


  var uninitializedFiber = createHostRootFiber(tag);
  root.current = uninitializedFiber;
  uninitializedFiber.stateNode = root;
  initializeUpdateQueue(uninitializedFiber);
  return root;
}

// This ensures that the version used for server rendering matches the one
// that is eventually read during hydration.
// If they don't match there's a potential tear and a full deopt render is required.

function registerMutableSourceForHydration(root, mutableSource) {
  var getVersion = mutableSource._getVersion;
  var version = getVersion(mutableSource._source); // TODO Clear this data once all pending hydration work is finished.
  // Retaining it forever may interfere with GC.

  if (root.mutableSourceEagerHydrationData == null) {
    root.mutableSourceEagerHydrationData = [mutableSource, version];
  } else {
    root.mutableSourceEagerHydrationData.push(mutableSource, version);
  }
}

function createPortal(children, containerInfo, // TODO: figure out the API for cross-renderer implementation.
implementation) {
  var key = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
  return {
    // This tag allow us to uniquely identify this as a React Portal
    $$typeof: REACT_PORTAL_TYPE,
    key: key == null ? null : '' + key,
    children: children,
    containerInfo: containerInfo,
    implementation: implementation
  };
}

var didWarnAboutNestedUpdates;
var didWarnAboutFindNodeInStrictMode;

{
  didWarnAboutNestedUpdates = false;
  didWarnAboutFindNodeInStrictMode = {};
}

function getContextForSubtree(parentComponent) {
  if (!parentComponent) {
    return emptyContextObject;
  }

  var fiber = get(parentComponent);
  var parentContext = findCurrentUnmaskedContext(fiber);

  if (fiber.tag === ClassComponent) {
    var Component = fiber.type;

    if (isContextProvider(Component)) {
      return processChildContext(fiber, Component, parentContext);
    }
  }

  return parentContext;
}

function findHostInstanceWithWarning(component, methodName) {
  {
    var fiber = get(component);

    if (fiber === undefined) {
      if (typeof component.render === 'function') {
        {
          {
            throw Error( "Unable to find node on an unmounted component." );
          }
        }
      } else {
        {
          {
            throw Error( "Argument appears to not be a ReactComponent. Keys: " + Object.keys(component) );
          }
        }
      }
    }

    var hostFiber = findCurrentHostFiber(fiber);

    if (hostFiber === null) {
      return null;
    }

    if (hostFiber.mode & StrictMode) {
      var componentName = getComponentName(fiber.type) || 'Component';

      if (!didWarnAboutFindNodeInStrictMode[componentName]) {
        didWarnAboutFindNodeInStrictMode[componentName] = true;
        var previousFiber = current;

        try {
          setCurrentFiber(hostFiber);

          if (fiber.mode & StrictMode) {
            error('%s is deprecated in StrictMode. ' + '%s was passed an instance of %s which is inside StrictMode. ' + 'Instead, add a ref directly to the element you want to reference. ' + 'Learn more about using refs safely here: ' + 'https://reactjs.org/link/strict-mode-find-node', methodName, methodName, componentName);
          } else {
            error('%s is deprecated in StrictMode. ' + '%s was passed an instance of %s which renders StrictMode children. ' + 'Instead, add a ref directly to the element you want to reference. ' + 'Learn more about using refs safely here: ' + 'https://reactjs.org/link/strict-mode-find-node', methodName, methodName, componentName);
          }
        } finally {
          // Ideally this should reset to previous but this shouldn't be called in
          // render and there's another warning for that anyway.
          if (previousFiber) {
            setCurrentFiber(previousFiber);
          } else {
            resetCurrentFiber();
          }
        }
      }
    }

    return hostFiber.stateNode;
  }
}

function createContainer(containerInfo, tag, hydrate, hydrationCallbacks) {
  return createFiberRoot(containerInfo, tag, hydrate);
}
function updateContainer(element, container, parentComponent, callback) {
  {
    onScheduleRoot(container, element);
  }

  var current$1 = container.current;
  var eventTime = requestEventTime();

  {
    // $FlowExpectedError - jest isn't a global, and isn't recognized outside of tests
    if ('undefined' !== typeof jest) {
      warnIfUnmockedScheduler(current$1);
      warnIfNotScopedWithMatchingAct(current$1);
    }
  }

  var lane = requestUpdateLane(current$1);

  var context = getContextForSubtree(parentComponent);

  if (container.context === null) {
    container.context = context;
  } else {
    container.pendingContext = context;
  }

  {
    if (isRendering && current !== null && !didWarnAboutNestedUpdates) {
      didWarnAboutNestedUpdates = true;

      error('Render methods should be a pure function of props and state; ' + 'triggering nested component updates from render is not allowed. ' + 'If necessary, trigger nested updates in componentDidUpdate.\n\n' + 'Check the render method of %s.', getComponentName(current.type) || 'Unknown');
    }
  }

  var update = createUpdate(eventTime, lane); // Caution: React DevTools currently depends on this property
  // being called "element".

  update.payload = {
    element: element
  };
  callback = callback === undefined ? null : callback;

  if (callback !== null) {
    {
      if (typeof callback !== 'function') {
        error('render(...): Expected the last optional `callback` argument to be a ' + 'function. Instead received: %s.', callback);
      }
    }

    update.callback = callback;
  }

  enqueueUpdate(current$1, update);
  scheduleUpdateOnFiber(current$1, lane, eventTime);
  return lane;
}
function getPublicRootInstance(container) {
  var containerFiber = container.current;

  if (!containerFiber.child) {
    return null;
  }

  switch (containerFiber.child.tag) {
    case HostComponent:
      return getPublicInstance(containerFiber.child.stateNode);

    default:
      return containerFiber.child.stateNode;
  }
}

function markRetryLaneImpl(fiber, retryLane) {
  var suspenseState = fiber.memoizedState;

  if (suspenseState !== null && suspenseState.dehydrated !== null) {
    suspenseState.retryLane = higherPriorityLane(suspenseState.retryLane, retryLane);
  }
} // Increases the priority of thennables when they resolve within this boundary.


function markRetryLaneIfNotHydrated(fiber, retryLane) {
  markRetryLaneImpl(fiber, retryLane);
  var alternate = fiber.alternate;

  if (alternate) {
    markRetryLaneImpl(alternate, retryLane);
  }
}

function attemptUserBlockingHydration$1(fiber) {
  if (fiber.tag !== SuspenseComponent) {
    // We ignore HostRoots here because we can't increase
    // their priority and they should not suspend on I/O,
    // since you have to wrap anything that might suspend in
    // Suspense.
    return;
  }

  var eventTime = requestEventTime();
  var lane = InputDiscreteHydrationLane;
  scheduleUpdateOnFiber(fiber, lane, eventTime);
  markRetryLaneIfNotHydrated(fiber, lane);
}
function attemptContinuousHydration$1(fiber) {
  if (fiber.tag !== SuspenseComponent) {
    // We ignore HostRoots here because we can't increase
    // their priority and they should not suspend on I/O,
    // since you have to wrap anything that might suspend in
    // Suspense.
    return;
  }

  var eventTime = requestEventTime();
  var lane = SelectiveHydrationLane;
  scheduleUpdateOnFiber(fiber, lane, eventTime);
  markRetryLaneIfNotHydrated(fiber, lane);
}
function attemptHydrationAtCurrentPriority$1(fiber) {
  if (fiber.tag !== SuspenseComponent) {
    // We ignore HostRoots here because we can't increase
    // their priority other than synchronously flush it.
    return;
  }

  var eventTime = requestEventTime();
  var lane = requestUpdateLane(fiber);
  scheduleUpdateOnFiber(fiber, lane, eventTime);
  markRetryLaneIfNotHydrated(fiber, lane);
}
function runWithPriority$2(priority, fn) {

  try {
    setCurrentUpdateLanePriority(priority);
    return fn();
  } finally {
  }
}
function findHostInstanceWithNoPortals(fiber) {
  var hostFiber = findCurrentHostFiberWithNoPortals(fiber);

  if (hostFiber === null) {
    return null;
  }

  if (hostFiber.tag === FundamentalComponent) {
    return hostFiber.stateNode.instance;
  }

  return hostFiber.stateNode;
}

var shouldSuspendImpl = function (fiber) {
  return false;
};

function shouldSuspend(fiber) {
  return shouldSuspendImpl(fiber);
}
var overrideHookState = null;
var overrideHookStateDeletePath = null;
var overrideHookStateRenamePath = null;
var overrideProps = null;
var overridePropsDeletePath = null;
var overridePropsRenamePath = null;
var scheduleUpdate = null;
var setSuspenseHandler = null;

{
  var copyWithDeleteImpl = function (obj, path, index) {
    var key = path[index];
    var updated = Array.isArray(obj) ? obj.slice() : _assign({}, obj);

    if (index + 1 === path.length) {
      if (Array.isArray(updated)) {
        updated.splice(key, 1);
      } else {
        delete updated[key];
      }

      return updated;
    } // $FlowFixMe number or string is fine here


    updated[key] = copyWithDeleteImpl(obj[key], path, index + 1);
    return updated;
  };

  var copyWithDelete = function (obj, path) {
    return copyWithDeleteImpl(obj, path, 0);
  };

  var copyWithRenameImpl = function (obj, oldPath, newPath, index) {
    var oldKey = oldPath[index];
    var updated = Array.isArray(obj) ? obj.slice() : _assign({}, obj);

    if (index + 1 === oldPath.length) {
      var newKey = newPath[index]; // $FlowFixMe number or string is fine here

      updated[newKey] = updated[oldKey];

      if (Array.isArray(updated)) {
        updated.splice(oldKey, 1);
      } else {
        delete updated[oldKey];
      }
    } else {
      // $FlowFixMe number or string is fine here
      updated[oldKey] = copyWithRenameImpl( // $FlowFixMe number or string is fine here
      obj[oldKey], oldPath, newPath, index + 1);
    }

    return updated;
  };

  var copyWithRename = function (obj, oldPath, newPath) {
    if (oldPath.length !== newPath.length) {
      warn('copyWithRename() expects paths of the same length');

      return;
    } else {
      for (var i = 0; i < newPath.length - 1; i++) {
        if (oldPath[i] !== newPath[i]) {
          warn('copyWithRename() expects paths to be the same except for the deepest key');

          return;
        }
      }
    }

    return copyWithRenameImpl(obj, oldPath, newPath, 0);
  };

  var copyWithSetImpl = function (obj, path, index, value) {
    if (index >= path.length) {
      return value;
    }

    var key = path[index];
    var updated = Array.isArray(obj) ? obj.slice() : _assign({}, obj); // $FlowFixMe number or string is fine here

    updated[key] = copyWithSetImpl(obj[key], path, index + 1, value);
    return updated;
  };

  var copyWithSet = function (obj, path, value) {
    return copyWithSetImpl(obj, path, 0, value);
  };

  var findHook = function (fiber, id) {
    // For now, the "id" of stateful hooks is just the stateful hook index.
    // This may change in the future with e.g. nested hooks.
    var currentHook = fiber.memoizedState;

    while (currentHook !== null && id > 0) {
      currentHook = currentHook.next;
      id--;
    }

    return currentHook;
  }; // Support DevTools editable values for useState and useReducer.


  overrideHookState = function (fiber, id, path, value) {
    var hook = findHook(fiber, id);

    if (hook !== null) {
      var newState = copyWithSet(hook.memoizedState, path, value);
      hook.memoizedState = newState;
      hook.baseState = newState; // We aren't actually adding an update to the queue,
      // because there is no update we can add for useReducer hooks that won't trigger an error.
      // (There's no appropriate action type for DevTools overrides.)
      // As a result though, React will see the scheduled update as a noop and bailout.
      // Shallow cloning props works as a workaround for now to bypass the bailout check.

      fiber.memoizedProps = _assign({}, fiber.memoizedProps);
      scheduleUpdateOnFiber(fiber, SyncLane, NoTimestamp);
    }
  };

  overrideHookStateDeletePath = function (fiber, id, path) {
    var hook = findHook(fiber, id);

    if (hook !== null) {
      var newState = copyWithDelete(hook.memoizedState, path);
      hook.memoizedState = newState;
      hook.baseState = newState; // We aren't actually adding an update to the queue,
      // because there is no update we can add for useReducer hooks that won't trigger an error.
      // (There's no appropriate action type for DevTools overrides.)
      // As a result though, React will see the scheduled update as a noop and bailout.
      // Shallow cloning props works as a workaround for now to bypass the bailout check.

      fiber.memoizedProps = _assign({}, fiber.memoizedProps);
      scheduleUpdateOnFiber(fiber, SyncLane, NoTimestamp);
    }
  };

  overrideHookStateRenamePath = function (fiber, id, oldPath, newPath) {
    var hook = findHook(fiber, id);

    if (hook !== null) {
      var newState = copyWithRename(hook.memoizedState, oldPath, newPath);
      hook.memoizedState = newState;
      hook.baseState = newState; // We aren't actually adding an update to the queue,
      // because there is no update we can add for useReducer hooks that won't trigger an error.
      // (There's no appropriate action type for DevTools overrides.)
      // As a result though, React will see the scheduled update as a noop and bailout.
      // Shallow cloning props works as a workaround for now to bypass the bailout check.

      fiber.memoizedProps = _assign({}, fiber.memoizedProps);
      scheduleUpdateOnFiber(fiber, SyncLane, NoTimestamp);
    }
  }; // Support DevTools props for function components, forwardRef, memo, host components, etc.


  overrideProps = function (fiber, path, value) {
    fiber.pendingProps = copyWithSet(fiber.memoizedProps, path, value);

    if (fiber.alternate) {
      fiber.alternate.pendingProps = fiber.pendingProps;
    }

    scheduleUpdateOnFiber(fiber, SyncLane, NoTimestamp);
  };

  overridePropsDeletePath = function (fiber, path) {
    fiber.pendingProps = copyWithDelete(fiber.memoizedProps, path);

    if (fiber.alternate) {
      fiber.alternate.pendingProps = fiber.pendingProps;
    }

    scheduleUpdateOnFiber(fiber, SyncLane, NoTimestamp);
  };

  overridePropsRenamePath = function (fiber, oldPath, newPath) {
    fiber.pendingProps = copyWithRename(fiber.memoizedProps, oldPath, newPath);

    if (fiber.alternate) {
      fiber.alternate.pendingProps = fiber.pendingProps;
    }

    scheduleUpdateOnFiber(fiber, SyncLane, NoTimestamp);
  };

  scheduleUpdate = function (fiber) {
    scheduleUpdateOnFiber(fiber, SyncLane, NoTimestamp);
  };

  setSuspenseHandler = function (newShouldSuspendImpl) {
    shouldSuspendImpl = newShouldSuspendImpl;
  };
}

function findHostInstanceByFiber(fiber) {
  var hostFiber = findCurrentHostFiber(fiber);

  if (hostFiber === null) {
    return null;
  }

  return hostFiber.stateNode;
}

function emptyFindFiberByHostInstance(instance) {
  return null;
}

function getCurrentFiberForDevTools() {
  return current;
}

function injectIntoDevTools(devToolsConfig) {
  var findFiberByHostInstance = devToolsConfig.findFiberByHostInstance;
  var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;
  return injectInternals({
    bundleType: devToolsConfig.bundleType,
    version: devToolsConfig.version,
    rendererPackageName: devToolsConfig.rendererPackageName,
    rendererConfig: devToolsConfig.rendererConfig,
    overrideHookState: overrideHookState,
    overrideHookStateDeletePath: overrideHookStateDeletePath,
    overrideHookStateRenamePath: overrideHookStateRenamePath,
    overrideProps: overrideProps,
    overridePropsDeletePath: overridePropsDeletePath,
    overridePropsRenamePath: overridePropsRenamePath,
    setSuspenseHandler: setSuspenseHandler,
    scheduleUpdate: scheduleUpdate,
    currentDispatcherRef: ReactCurrentDispatcher,
    findHostInstanceByFiber: findHostInstanceByFiber,
    findFiberByHostInstance: findFiberByHostInstance || emptyFindFiberByHostInstance,
    // React Refresh
    findHostInstancesForRefresh:  findHostInstancesForRefresh ,
    scheduleRefresh:  scheduleRefresh ,
    scheduleRoot:  scheduleRoot ,
    setRefreshHandler:  setRefreshHandler ,
    // Enables DevTools to append owner stacks to error messages in DEV mode.
    getCurrentFiber:  getCurrentFiberForDevTools 
  });
}

function ReactDOMRoot(container, options) {
  this._internalRoot = createRootImpl(container, ConcurrentRoot, options);
}

function ReactDOMBlockingRoot(container, tag, options) {
  this._internalRoot = createRootImpl(container, tag, options);
}

ReactDOMRoot.prototype.render = ReactDOMBlockingRoot.prototype.render = function (children) {
  var root = this._internalRoot;

  {
    if (typeof arguments[1] === 'function') {
      error('render(...): does not support the second callback argument. ' + 'To execute a side effect after rendering, declare it in a component body with useEffect().');
    }

    var container = root.containerInfo;

    if (container.nodeType !== COMMENT_NODE) {
      var hostInstance = findHostInstanceWithNoPortals(root.current);

      if (hostInstance) {
        if (hostInstance.parentNode !== container) {
          error('render(...): It looks like the React-rendered content of the ' + 'root container was removed without using React. This is not ' + 'supported and will cause errors. Instead, call ' + "root.unmount() to empty a root's container.");
        }
      }
    }
  }

  updateContainer(children, root, null, null);
};

ReactDOMRoot.prototype.unmount = ReactDOMBlockingRoot.prototype.unmount = function () {
  {
    if (typeof arguments[0] === 'function') {
      error('unmount(...): does not support a callback argument. ' + 'To execute a side effect after rendering, declare it in a component body with useEffect().');
    }
  }

  var root = this._internalRoot;
  var container = root.containerInfo;
  updateContainer(null, root, null, function () {
    unmarkContainerAsRoot(container);
  });
};

function createRootImpl(container, tag, options) {
  // Tag is either LegacyRoot or Concurrent Root
  var hydrate = options != null && options.hydrate === true;
  var hydrationCallbacks = options != null && options.hydrationOptions || null;
  var mutableSources = options != null && options.hydrationOptions != null && options.hydrationOptions.mutableSources || null;
  var root = createContainer(container, tag, hydrate);
  markContainerAsRoot(root.current, container);
  var containerNodeType = container.nodeType;

  {
    var rootContainerElement = container.nodeType === COMMENT_NODE ? container.parentNode : container;
    listenToAllSupportedEvents(rootContainerElement);
  }

  if (mutableSources) {
    for (var i = 0; i < mutableSources.length; i++) {
      var mutableSource = mutableSources[i];
      registerMutableSourceForHydration(root, mutableSource);
    }
  }

  return root;
}
function createLegacyRoot(container, options) {
  return new ReactDOMBlockingRoot(container, LegacyRoot, options);
}
function isValidContainer(node) {
  return !!(node && (node.nodeType === ELEMENT_NODE || node.nodeType === DOCUMENT_NODE || node.nodeType === DOCUMENT_FRAGMENT_NODE || node.nodeType === COMMENT_NODE && node.nodeValue === ' react-mount-point-unstable '));
}

var ReactCurrentOwner$3 = ReactSharedInternals.ReactCurrentOwner;
var topLevelUpdateWarnings;
var warnedAboutHydrateAPI = false;

{
  topLevelUpdateWarnings = function (container) {
    if (container._reactRootContainer && container.nodeType !== COMMENT_NODE) {
      var hostInstance = findHostInstanceWithNoPortals(container._reactRootContainer._internalRoot.current);

      if (hostInstance) {
        if (hostInstance.parentNode !== container) {
          error('render(...): It looks like the React-rendered content of this ' + 'container was removed without using React. This is not ' + 'supported and will cause errors. Instead, call ' + 'ReactDOM.unmountComponentAtNode to empty a container.');
        }
      }
    }

    var isRootRenderedBySomeReact = !!container._reactRootContainer;
    var rootEl = getReactRootElementInContainer(container);
    var hasNonRootReactChild = !!(rootEl && getInstanceFromNode(rootEl));

    if (hasNonRootReactChild && !isRootRenderedBySomeReact) {
      error('render(...): Replacing React-rendered children with a new root ' + 'component. If you intended to update the children of this node, ' + 'you should instead have the existing children update their state ' + 'and render the new components instead of calling ReactDOM.render.');
    }

    if (container.nodeType === ELEMENT_NODE && container.tagName && container.tagName.toUpperCase() === 'BODY') {
      error('render(): Rendering components directly into document.body is ' + 'discouraged, since its children are often manipulated by third-party ' + 'scripts and browser extensions. This may lead to subtle ' + 'reconciliation issues. Try rendering into a container element created ' + 'for your app.');
    }
  };
}

function getReactRootElementInContainer(container) {
  if (!container) {
    return null;
  }

  if (container.nodeType === DOCUMENT_NODE) {
    return container.documentElement;
  } else {
    return container.firstChild;
  }
}

function shouldHydrateDueToLegacyHeuristic(container) {
  var rootElement = getReactRootElementInContainer(container);
  return !!(rootElement && rootElement.nodeType === ELEMENT_NODE && rootElement.hasAttribute(ROOT_ATTRIBUTE_NAME));
}

function legacyCreateRootFromDOMContainer(container, forceHydrate) {
  var shouldHydrate = forceHydrate || shouldHydrateDueToLegacyHeuristic(container); // First clear any existing content.

  if (!shouldHydrate) {
    var warned = false;
    var rootSibling;

    while (rootSibling = container.lastChild) {
      {
        if (!warned && rootSibling.nodeType === ELEMENT_NODE && rootSibling.hasAttribute(ROOT_ATTRIBUTE_NAME)) {
          warned = true;

          error('render(): Target node has markup rendered by React, but there ' + 'are unrelated nodes as well. This is most commonly caused by ' + 'white-space inserted around server-rendered markup.');
        }
      }

      container.removeChild(rootSibling);
    }
  }

  {
    if (shouldHydrate && !forceHydrate && !warnedAboutHydrateAPI) {
      warnedAboutHydrateAPI = true;

      warn('render(): Calling ReactDOM.render() to hydrate server-rendered markup ' + 'will stop working in React v18. Replace the ReactDOM.render() call ' + 'with ReactDOM.hydrate() if you want React to attach to the server HTML.');
    }
  }

  return createLegacyRoot(container, shouldHydrate ? {
    hydrate: true
  } : undefined);
}

function warnOnInvalidCallback$1(callback, callerName) {
  {
    if (callback !== null && typeof callback !== 'function') {
      error('%s(...): Expected the last optional `callback` argument to be a ' + 'function. Instead received: %s.', callerName, callback);
    }
  }
}

function legacyRenderSubtreeIntoContainer(parentComponent, children, container, forceHydrate, callback) {
  {
    topLevelUpdateWarnings(container);
    warnOnInvalidCallback$1(callback === undefined ? null : callback, 'render');
  } // TODO: Without `any` type, Flow says "Property cannot be accessed on any
  // member of intersection type." Whyyyyyy.


  var root = container._reactRootContainer;
  var fiberRoot;

  if (!root) {
    // Initial mount
    root = container._reactRootContainer = legacyCreateRootFromDOMContainer(container, forceHydrate);
    fiberRoot = root._internalRoot;

    if (typeof callback === 'function') {
      var originalCallback = callback;

      callback = function () {
        var instance = getPublicRootInstance(fiberRoot);
        originalCallback.call(instance);
      };
    } // Initial mount should not be batched.


    unbatchedUpdates(function () {
      updateContainer(children, fiberRoot, parentComponent, callback);
    });
  } else {
    fiberRoot = root._internalRoot;

    if (typeof callback === 'function') {
      var _originalCallback = callback;

      callback = function () {
        var instance = getPublicRootInstance(fiberRoot);

        _originalCallback.call(instance);
      };
    } // Update


    updateContainer(children, fiberRoot, parentComponent, callback);
  }

  return getPublicRootInstance(fiberRoot);
}

function findDOMNode(componentOrElement) {
  {
    var owner = ReactCurrentOwner$3.current;

    if (owner !== null && owner.stateNode !== null) {
      var warnedAboutRefsInRender = owner.stateNode._warnedAboutRefsInRender;

      if (!warnedAboutRefsInRender) {
        error('%s is accessing findDOMNode inside its render(). ' + 'render() should be a pure function of props and state. It should ' + 'never access something that requires stale data from the previous ' + 'render, such as refs. Move this logic to componentDidMount and ' + 'componentDidUpdate instead.', getComponentName(owner.type) || 'A component');
      }

      owner.stateNode._warnedAboutRefsInRender = true;
    }
  }

  if (componentOrElement == null) {
    return null;
  }

  if (componentOrElement.nodeType === ELEMENT_NODE) {
    return componentOrElement;
  }

  {
    return findHostInstanceWithWarning(componentOrElement, 'findDOMNode');
  }
}
function hydrate(element, container, callback) {
  if (!isValidContainer(container)) {
    {
      throw Error( "Target container is not a DOM element." );
    }
  }

  {
    var isModernRoot = isContainerMarkedAsRoot(container) && container._reactRootContainer === undefined;

    if (isModernRoot) {
      error('You are calling ReactDOM.hydrate() on a container that was previously ' + 'passed to ReactDOM.createRoot(). This is not supported. ' + 'Did you mean to call createRoot(container, {hydrate: true}).render(element)?');
    }
  } // TODO: throw or warn if we couldn't hydrate?


  return legacyRenderSubtreeIntoContainer(null, element, container, true, callback);
}
function render(element, container, callback) {
  if (!isValidContainer(container)) {
    {
      throw Error( "Target container is not a DOM element." );
    }
  }

  {
    var isModernRoot = isContainerMarkedAsRoot(container) && container._reactRootContainer === undefined;

    if (isModernRoot) {
      error('You are calling ReactDOM.render() on a container that was previously ' + 'passed to ReactDOM.createRoot(). This is not supported. ' + 'Did you mean to call root.render(element)?');
    }
  }

  return legacyRenderSubtreeIntoContainer(null, element, container, false, callback);
}
function unstable_renderSubtreeIntoContainer(parentComponent, element, containerNode, callback) {
  if (!isValidContainer(containerNode)) {
    {
      throw Error( "Target container is not a DOM element." );
    }
  }

  if (!(parentComponent != null && has(parentComponent))) {
    {
      throw Error( "parentComponent must be a valid React Component" );
    }
  }

  return legacyRenderSubtreeIntoContainer(parentComponent, element, containerNode, false, callback);
}
function unmountComponentAtNode(container) {
  if (!isValidContainer(container)) {
    {
      throw Error( "unmountComponentAtNode(...): Target container is not a DOM element." );
    }
  }

  {
    var isModernRoot = isContainerMarkedAsRoot(container) && container._reactRootContainer === undefined;

    if (isModernRoot) {
      error('You are calling ReactDOM.unmountComponentAtNode() on a container that was previously ' + 'passed to ReactDOM.createRoot(). This is not supported. Did you mean to call root.unmount()?');
    }
  }

  if (container._reactRootContainer) {
    {
      var rootEl = getReactRootElementInContainer(container);
      var renderedByDifferentReact = rootEl && !getInstanceFromNode(rootEl);

      if (renderedByDifferentReact) {
        error("unmountComponentAtNode(): The node you're attempting to unmount " + 'was rendered by another copy of React.');
      }
    } // Unmount should not be batched.


    unbatchedUpdates(function () {
      legacyRenderSubtreeIntoContainer(null, null, container, false, function () {
        // $FlowFixMe This should probably use `delete container._reactRootContainer`
        container._reactRootContainer = null;
        unmarkContainerAsRoot(container);
      });
    }); // If you call unmountComponentAtNode twice in quick succession, you'll
    // get `true` twice. That's probably fine?

    return true;
  } else {
    {
      var _rootEl = getReactRootElementInContainer(container);

      var hasNonRootReactChild = !!(_rootEl && getInstanceFromNode(_rootEl)); // Check if the container itself is a React root node.

      var isContainerReactRoot = container.nodeType === ELEMENT_NODE && isValidContainer(container.parentNode) && !!container.parentNode._reactRootContainer;

      if (hasNonRootReactChild) {
        error("unmountComponentAtNode(): The node you're attempting to unmount " + 'was rendered by React and is not a top-level container. %s', isContainerReactRoot ? 'You may have accidentally passed in a React root node instead ' + 'of its container.' : 'Instead, have the parent component update its state and ' + 'rerender in order to remove this component.');
      }
    }

    return false;
  }
}

setAttemptUserBlockingHydration(attemptUserBlockingHydration$1);
setAttemptContinuousHydration(attemptContinuousHydration$1);
setAttemptHydrationAtCurrentPriority(attemptHydrationAtCurrentPriority$1);
setAttemptHydrationAtPriority(runWithPriority$2);
var didWarnAboutUnstableCreatePortal = false;

{
  if (typeof Map !== 'function' || // $FlowIssue Flow incorrectly thinks Map has no prototype
  Map.prototype == null || typeof Map.prototype.forEach !== 'function' || typeof Set !== 'function' || // $FlowIssue Flow incorrectly thinks Set has no prototype
  Set.prototype == null || typeof Set.prototype.clear !== 'function' || typeof Set.prototype.forEach !== 'function') {
    error('React depends on Map and Set built-in types. Make sure that you load a ' + 'polyfill in older browsers. https://reactjs.org/link/react-polyfills');
  }
}

setRestoreImplementation(restoreControlledState$3);
setBatchingImplementation(batchedUpdates$1, discreteUpdates$1, flushDiscreteUpdates, batchedEventUpdates$1);

function createPortal$1(children, container) {
  var key = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

  if (!isValidContainer(container)) {
    {
      throw Error( "Target container is not a DOM element." );
    }
  } // TODO: pass ReactDOM portal implementation as third argument
  // $FlowFixMe The Flow type is opaque but there's no way to actually create it.


  return createPortal(children, container, null, key);
}

function renderSubtreeIntoContainer(parentComponent, element, containerNode, callback) {

  return unstable_renderSubtreeIntoContainer(parentComponent, element, containerNode, callback);
}

function unstable_createPortal(children, container) {
  var key = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

  {
    if (!didWarnAboutUnstableCreatePortal) {
      didWarnAboutUnstableCreatePortal = true;

      warn('The ReactDOM.unstable_createPortal() alias has been deprecated, ' + 'and will be removed in React 18+. Update your code to use ' + 'ReactDOM.createPortal() instead. It has the exact same API, ' + 'but without the "unstable_" prefix.');
    }
  }

  return createPortal$1(children, container, key);
}

var Internals = {
  // Keep in sync with ReactTestUtils.js, and ReactTestUtilsAct.js.
  // This is an array for better minification.
  Events: [getInstanceFromNode, getNodeFromInstance, getFiberCurrentPropsFromNode, enqueueStateRestore, restoreStateIfNeeded, flushPassiveEffects, // TODO: This is related to `act`, not events. Move to separate key?
  IsThisRendererActing]
};
var foundDevTools = injectIntoDevTools({
  findFiberByHostInstance: getClosestInstanceFromNode,
  bundleType:  1 ,
  version: ReactVersion,
  rendererPackageName: 'react-dom'
});

{
  if (!foundDevTools && canUseDOM && window.top === window.self) {
    // If we're in Chrome or Firefox, provide a download link if not installed.
    if (navigator.userAgent.indexOf('Chrome') > -1 && navigator.userAgent.indexOf('Edge') === -1 || navigator.userAgent.indexOf('Firefox') > -1) {
      var protocol = window.location.protocol; // Don't warn in exotic cases like chrome-extension://.

      if (/^(https?|file):$/.test(protocol)) {
        // eslint-disable-next-line react-internal/no-production-logging
        console.info('%cDownload the React DevTools ' + 'for a better development experience: ' + 'https://reactjs.org/link/react-devtools' + (protocol === 'file:' ? '\nYou might need to use a local HTTP server (instead of file://): ' + 'https://reactjs.org/link/react-devtools-faq' : ''), 'font-weight:bold');
      }
    }
  }
}

exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = Internals;
exports.createPortal = createPortal$1;
exports.findDOMNode = findDOMNode;
exports.flushSync = flushSync;
exports.hydrate = hydrate;
exports.render = render;
exports.unmountComponentAtNode = unmountComponentAtNode;
exports.unstable_batchedUpdates = batchedUpdates$1;
exports.unstable_createPortal = unstable_createPortal;
exports.unstable_renderSubtreeIntoContainer = renderSubtreeIntoContainer;
exports.version = ReactVersion;
  })();
}


/***/ }),

/***/ "./node_modules/react-dom/index.js":
/*!*****************************************!*\
  !*** ./node_modules/react-dom/index.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


function checkDCE() {
  /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */
  if (
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === 'undefined' ||
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== 'function'
  ) {
    return;
  }
  if (true) {
    // This branch is unreachable because this function is only called
    // in production, but the condition is true only in development.
    // Therefore if the branch is still here, dead code elimination wasn't
    // properly applied.
    // Don't change the message. React DevTools relies on it. Also make sure
    // this message doesn't occur elsewhere in this function, or it will cause
    // a false positive.
    throw new Error('^_^');
  }
  try {
    // Verify that the code above has been dead code eliminated (DCE'd).
    __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
  } catch (err) {
    // DevTools shouldn't crash React, no matter what.
    // We should still report in case we break this code.
    console.error(err);
  }
}

if (false) {} else {
  module.exports = __webpack_require__(/*! ./cjs/react-dom.development.js */ "./node_modules/react-dom/cjs/react-dom.development.js");
}


/***/ }),

/***/ "./node_modules/react/cjs/react.development.js":
/*!*****************************************************!*\
  !*** ./node_modules/react/cjs/react.development.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/** @license React v17.0.2
 * react.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



if (true) {
  (function() {
'use strict';

var _assign = __webpack_require__(/*! object-assign */ "./node_modules/object-assign/index.js");

// TODO: this is special because it gets imported during build.
var ReactVersion = '17.0.2';

// ATTENTION
// When adding new symbols to this file,
// Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'
// The Symbol used to tag the ReactElement-like types. If there is no native Symbol
// nor polyfill, then a plain number is used for performance.
var REACT_ELEMENT_TYPE = 0xeac7;
var REACT_PORTAL_TYPE = 0xeaca;
exports.Fragment = 0xeacb;
exports.StrictMode = 0xeacc;
exports.Profiler = 0xead2;
var REACT_PROVIDER_TYPE = 0xeacd;
var REACT_CONTEXT_TYPE = 0xeace;
var REACT_FORWARD_REF_TYPE = 0xead0;
exports.Suspense = 0xead1;
var REACT_SUSPENSE_LIST_TYPE = 0xead8;
var REACT_MEMO_TYPE = 0xead3;
var REACT_LAZY_TYPE = 0xead4;
var REACT_BLOCK_TYPE = 0xead9;
var REACT_SERVER_BLOCK_TYPE = 0xeada;
var REACT_FUNDAMENTAL_TYPE = 0xead5;
var REACT_SCOPE_TYPE = 0xead7;
var REACT_OPAQUE_ID_TYPE = 0xeae0;
var REACT_DEBUG_TRACING_MODE_TYPE = 0xeae1;
var REACT_OFFSCREEN_TYPE = 0xeae2;
var REACT_LEGACY_HIDDEN_TYPE = 0xeae3;

if (typeof Symbol === 'function' && Symbol.for) {
  var symbolFor = Symbol.for;
  REACT_ELEMENT_TYPE = symbolFor('react.element');
  REACT_PORTAL_TYPE = symbolFor('react.portal');
  exports.Fragment = symbolFor('react.fragment');
  exports.StrictMode = symbolFor('react.strict_mode');
  exports.Profiler = symbolFor('react.profiler');
  REACT_PROVIDER_TYPE = symbolFor('react.provider');
  REACT_CONTEXT_TYPE = symbolFor('react.context');
  REACT_FORWARD_REF_TYPE = symbolFor('react.forward_ref');
  exports.Suspense = symbolFor('react.suspense');
  REACT_SUSPENSE_LIST_TYPE = symbolFor('react.suspense_list');
  REACT_MEMO_TYPE = symbolFor('react.memo');
  REACT_LAZY_TYPE = symbolFor('react.lazy');
  REACT_BLOCK_TYPE = symbolFor('react.block');
  REACT_SERVER_BLOCK_TYPE = symbolFor('react.server.block');
  REACT_FUNDAMENTAL_TYPE = symbolFor('react.fundamental');
  REACT_SCOPE_TYPE = symbolFor('react.scope');
  REACT_OPAQUE_ID_TYPE = symbolFor('react.opaque.id');
  REACT_DEBUG_TRACING_MODE_TYPE = symbolFor('react.debug_trace_mode');
  REACT_OFFSCREEN_TYPE = symbolFor('react.offscreen');
  REACT_LEGACY_HIDDEN_TYPE = symbolFor('react.legacy_hidden');
}

var MAYBE_ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
var FAUX_ITERATOR_SYMBOL = '@@iterator';
function getIteratorFn(maybeIterable) {
  if (maybeIterable === null || typeof maybeIterable !== 'object') {
    return null;
  }

  var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];

  if (typeof maybeIterator === 'function') {
    return maybeIterator;
  }

  return null;
}

/**
 * Keeps track of the current dispatcher.
 */
var ReactCurrentDispatcher = {
  /**
   * @internal
   * @type {ReactComponent}
   */
  current: null
};

/**
 * Keeps track of the current batch's configuration such as how long an update
 * should suspend for if it needs to.
 */
var ReactCurrentBatchConfig = {
  transition: 0
};

/**
 * Keeps track of the current owner.
 *
 * The current owner is the component who should own any components that are
 * currently being constructed.
 */
var ReactCurrentOwner = {
  /**
   * @internal
   * @type {ReactComponent}
   */
  current: null
};

var ReactDebugCurrentFrame = {};
var currentExtraStackFrame = null;
function setExtraStackFrame(stack) {
  {
    currentExtraStackFrame = stack;
  }
}

{
  ReactDebugCurrentFrame.setExtraStackFrame = function (stack) {
    {
      currentExtraStackFrame = stack;
    }
  }; // Stack implementation injected by the current renderer.


  ReactDebugCurrentFrame.getCurrentStack = null;

  ReactDebugCurrentFrame.getStackAddendum = function () {
    var stack = ''; // Add an extra top frame while an element is being validated

    if (currentExtraStackFrame) {
      stack += currentExtraStackFrame;
    } // Delegate to the injected renderer-specific implementation


    var impl = ReactDebugCurrentFrame.getCurrentStack;

    if (impl) {
      stack += impl() || '';
    }

    return stack;
  };
}

/**
 * Used by act() to track whether you're inside an act() scope.
 */
var IsSomeRendererActing = {
  current: false
};

var ReactSharedInternals = {
  ReactCurrentDispatcher: ReactCurrentDispatcher,
  ReactCurrentBatchConfig: ReactCurrentBatchConfig,
  ReactCurrentOwner: ReactCurrentOwner,
  IsSomeRendererActing: IsSomeRendererActing,
  // Used by renderers to avoid bundling object-assign twice in UMD bundles:
  assign: _assign
};

{
  ReactSharedInternals.ReactDebugCurrentFrame = ReactDebugCurrentFrame;
}

// by calls to these methods by a Babel plugin.
//
// In PROD (or in packages without access to React internals),
// they are left as they are instead.

function warn(format) {
  {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    printWarning('warn', format, args);
  }
}
function error(format) {
  {
    for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
      args[_key2 - 1] = arguments[_key2];
    }

    printWarning('error', format, args);
  }
}

function printWarning(level, format, args) {
  // When changing this logic, you might want to also
  // update consoleWithStackDev.www.js as well.
  {
    var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
    var stack = ReactDebugCurrentFrame.getStackAddendum();

    if (stack !== '') {
      format += '%s';
      args = args.concat([stack]);
    }

    var argsWithFormat = args.map(function (item) {
      return '' + item;
    }); // Careful: RN currently depends on this prefix

    argsWithFormat.unshift('Warning: ' + format); // We intentionally don't use spread (or .apply) directly because it
    // breaks IE9: https://github.com/facebook/react/issues/13610
    // eslint-disable-next-line react-internal/no-production-logging

    Function.prototype.apply.call(console[level], console, argsWithFormat);
  }
}

var didWarnStateUpdateForUnmountedComponent = {};

function warnNoop(publicInstance, callerName) {
  {
    var _constructor = publicInstance.constructor;
    var componentName = _constructor && (_constructor.displayName || _constructor.name) || 'ReactClass';
    var warningKey = componentName + "." + callerName;

    if (didWarnStateUpdateForUnmountedComponent[warningKey]) {
      return;
    }

    error("Can't call %s on a component that is not yet mounted. " + 'This is a no-op, but it might indicate a bug in your application. ' + 'Instead, assign to `this.state` directly or define a `state = {};` ' + 'class property with the desired state in the %s component.', callerName, componentName);

    didWarnStateUpdateForUnmountedComponent[warningKey] = true;
  }
}
/**
 * This is the abstract API for an update queue.
 */


var ReactNoopUpdateQueue = {
  /**
   * Checks whether or not this composite component is mounted.
   * @param {ReactClass} publicInstance The instance we want to test.
   * @return {boolean} True if mounted, false otherwise.
   * @protected
   * @final
   */
  isMounted: function (publicInstance) {
    return false;
  },

  /**
   * Forces an update. This should only be invoked when it is known with
   * certainty that we are **not** in a DOM transaction.
   *
   * You may want to call this when you know that some deeper aspect of the
   * component's state has changed but `setState` was not called.
   *
   * This will not invoke `shouldComponentUpdate`, but it will invoke
   * `componentWillUpdate` and `componentDidUpdate`.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @param {?function} callback Called after component is updated.
   * @param {?string} callerName name of the calling function in the public API.
   * @internal
   */
  enqueueForceUpdate: function (publicInstance, callback, callerName) {
    warnNoop(publicInstance, 'forceUpdate');
  },

  /**
   * Replaces all of the state. Always use this or `setState` to mutate state.
   * You should treat `this.state` as immutable.
   *
   * There is no guarantee that `this.state` will be immediately updated, so
   * accessing `this.state` after calling this method may return the old value.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @param {object} completeState Next state.
   * @param {?function} callback Called after component is updated.
   * @param {?string} callerName name of the calling function in the public API.
   * @internal
   */
  enqueueReplaceState: function (publicInstance, completeState, callback, callerName) {
    warnNoop(publicInstance, 'replaceState');
  },

  /**
   * Sets a subset of the state. This only exists because _pendingState is
   * internal. This provides a merging strategy that is not available to deep
   * properties which is confusing. TODO: Expose pendingState or don't use it
   * during the merge.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @param {object} partialState Next partial state to be merged with state.
   * @param {?function} callback Called after component is updated.
   * @param {?string} Name of the calling function in the public API.
   * @internal
   */
  enqueueSetState: function (publicInstance, partialState, callback, callerName) {
    warnNoop(publicInstance, 'setState');
  }
};

var emptyObject = {};

{
  Object.freeze(emptyObject);
}
/**
 * Base class helpers for the updating state of a component.
 */


function Component(props, context, updater) {
  this.props = props;
  this.context = context; // If a component has string refs, we will assign a different object later.

  this.refs = emptyObject; // We initialize the default updater but the real one gets injected by the
  // renderer.

  this.updater = updater || ReactNoopUpdateQueue;
}

Component.prototype.isReactComponent = {};
/**
 * Sets a subset of the state. Always use this to mutate
 * state. You should treat `this.state` as immutable.
 *
 * There is no guarantee that `this.state` will be immediately updated, so
 * accessing `this.state` after calling this method may return the old value.
 *
 * There is no guarantee that calls to `setState` will run synchronously,
 * as they may eventually be batched together.  You can provide an optional
 * callback that will be executed when the call to setState is actually
 * completed.
 *
 * When a function is provided to setState, it will be called at some point in
 * the future (not synchronously). It will be called with the up to date
 * component arguments (state, props, context). These values can be different
 * from this.* because your function may be called after receiveProps but before
 * shouldComponentUpdate, and this new state, props, and context will not yet be
 * assigned to this.
 *
 * @param {object|function} partialState Next partial state or function to
 *        produce next partial state to be merged with current state.
 * @param {?function} callback Called after state is updated.
 * @final
 * @protected
 */

Component.prototype.setState = function (partialState, callback) {
  if (!(typeof partialState === 'object' || typeof partialState === 'function' || partialState == null)) {
    {
      throw Error( "setState(...): takes an object of state variables to update or a function which returns an object of state variables." );
    }
  }

  this.updater.enqueueSetState(this, partialState, callback, 'setState');
};
/**
 * Forces an update. This should only be invoked when it is known with
 * certainty that we are **not** in a DOM transaction.
 *
 * You may want to call this when you know that some deeper aspect of the
 * component's state has changed but `setState` was not called.
 *
 * This will not invoke `shouldComponentUpdate`, but it will invoke
 * `componentWillUpdate` and `componentDidUpdate`.
 *
 * @param {?function} callback Called after update is complete.
 * @final
 * @protected
 */


Component.prototype.forceUpdate = function (callback) {
  this.updater.enqueueForceUpdate(this, callback, 'forceUpdate');
};
/**
 * Deprecated APIs. These APIs used to exist on classic React classes but since
 * we would like to deprecate them, we're not going to move them over to this
 * modern base class. Instead, we define a getter that warns if it's accessed.
 */


{
  var deprecatedAPIs = {
    isMounted: ['isMounted', 'Instead, make sure to clean up subscriptions and pending requests in ' + 'componentWillUnmount to prevent memory leaks.'],
    replaceState: ['replaceState', 'Refactor your code to use setState instead (see ' + 'https://github.com/facebook/react/issues/3236).']
  };

  var defineDeprecationWarning = function (methodName, info) {
    Object.defineProperty(Component.prototype, methodName, {
      get: function () {
        warn('%s(...) is deprecated in plain JavaScript React classes. %s', info[0], info[1]);

        return undefined;
      }
    });
  };

  for (var fnName in deprecatedAPIs) {
    if (deprecatedAPIs.hasOwnProperty(fnName)) {
      defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);
    }
  }
}

function ComponentDummy() {}

ComponentDummy.prototype = Component.prototype;
/**
 * Convenience component with default shallow equality check for sCU.
 */

function PureComponent(props, context, updater) {
  this.props = props;
  this.context = context; // If a component has string refs, we will assign a different object later.

  this.refs = emptyObject;
  this.updater = updater || ReactNoopUpdateQueue;
}

var pureComponentPrototype = PureComponent.prototype = new ComponentDummy();
pureComponentPrototype.constructor = PureComponent; // Avoid an extra prototype jump for these methods.

_assign(pureComponentPrototype, Component.prototype);

pureComponentPrototype.isPureReactComponent = true;

// an immutable object with a single mutable value
function createRef() {
  var refObject = {
    current: null
  };

  {
    Object.seal(refObject);
  }

  return refObject;
}

function getWrappedName(outerType, innerType, wrapperName) {
  var functionName = innerType.displayName || innerType.name || '';
  return outerType.displayName || (functionName !== '' ? wrapperName + "(" + functionName + ")" : wrapperName);
}

function getContextName(type) {
  return type.displayName || 'Context';
}

function getComponentName(type) {
  if (type == null) {
    // Host root, text node or just invalid type.
    return null;
  }

  {
    if (typeof type.tag === 'number') {
      error('Received an unexpected object in getComponentName(). ' + 'This is likely a bug in React. Please file an issue.');
    }
  }

  if (typeof type === 'function') {
    return type.displayName || type.name || null;
  }

  if (typeof type === 'string') {
    return type;
  }

  switch (type) {
    case exports.Fragment:
      return 'Fragment';

    case REACT_PORTAL_TYPE:
      return 'Portal';

    case exports.Profiler:
      return 'Profiler';

    case exports.StrictMode:
      return 'StrictMode';

    case exports.Suspense:
      return 'Suspense';

    case REACT_SUSPENSE_LIST_TYPE:
      return 'SuspenseList';
  }

  if (typeof type === 'object') {
    switch (type.$$typeof) {
      case REACT_CONTEXT_TYPE:
        var context = type;
        return getContextName(context) + '.Consumer';

      case REACT_PROVIDER_TYPE:
        var provider = type;
        return getContextName(provider._context) + '.Provider';

      case REACT_FORWARD_REF_TYPE:
        return getWrappedName(type, type.render, 'ForwardRef');

      case REACT_MEMO_TYPE:
        return getComponentName(type.type);

      case REACT_BLOCK_TYPE:
        return getComponentName(type._render);

      case REACT_LAZY_TYPE:
        {
          var lazyComponent = type;
          var payload = lazyComponent._payload;
          var init = lazyComponent._init;

          try {
            return getComponentName(init(payload));
          } catch (x) {
            return null;
          }
        }
    }
  }

  return null;
}

var hasOwnProperty = Object.prototype.hasOwnProperty;
var RESERVED_PROPS = {
  key: true,
  ref: true,
  __self: true,
  __source: true
};
var specialPropKeyWarningShown, specialPropRefWarningShown, didWarnAboutStringRefs;

{
  didWarnAboutStringRefs = {};
}

function hasValidRef(config) {
  {
    if (hasOwnProperty.call(config, 'ref')) {
      var getter = Object.getOwnPropertyDescriptor(config, 'ref').get;

      if (getter && getter.isReactWarning) {
        return false;
      }
    }
  }

  return config.ref !== undefined;
}

function hasValidKey(config) {
  {
    if (hasOwnProperty.call(config, 'key')) {
      var getter = Object.getOwnPropertyDescriptor(config, 'key').get;

      if (getter && getter.isReactWarning) {
        return false;
      }
    }
  }

  return config.key !== undefined;
}

function defineKeyPropWarningGetter(props, displayName) {
  var warnAboutAccessingKey = function () {
    {
      if (!specialPropKeyWarningShown) {
        specialPropKeyWarningShown = true;

        error('%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);
      }
    }
  };

  warnAboutAccessingKey.isReactWarning = true;
  Object.defineProperty(props, 'key', {
    get: warnAboutAccessingKey,
    configurable: true
  });
}

function defineRefPropWarningGetter(props, displayName) {
  var warnAboutAccessingRef = function () {
    {
      if (!specialPropRefWarningShown) {
        specialPropRefWarningShown = true;

        error('%s: `ref` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);
      }
    }
  };

  warnAboutAccessingRef.isReactWarning = true;
  Object.defineProperty(props, 'ref', {
    get: warnAboutAccessingRef,
    configurable: true
  });
}

function warnIfStringRefCannotBeAutoConverted(config) {
  {
    if (typeof config.ref === 'string' && ReactCurrentOwner.current && config.__self && ReactCurrentOwner.current.stateNode !== config.__self) {
      var componentName = getComponentName(ReactCurrentOwner.current.type);

      if (!didWarnAboutStringRefs[componentName]) {
        error('Component "%s" contains the string ref "%s". ' + 'Support for string refs will be removed in a future major release. ' + 'This case cannot be automatically converted to an arrow function. ' + 'We ask you to manually fix this case by using useRef() or createRef() instead. ' + 'Learn more about using refs safely here: ' + 'https://reactjs.org/link/strict-mode-string-ref', componentName, config.ref);

        didWarnAboutStringRefs[componentName] = true;
      }
    }
  }
}
/**
 * Factory method to create a new React element. This no longer adheres to
 * the class pattern, so do not use new to call it. Also, instanceof check
 * will not work. Instead test $$typeof field against Symbol.for('react.element') to check
 * if something is a React Element.
 *
 * @param {*} type
 * @param {*} props
 * @param {*} key
 * @param {string|object} ref
 * @param {*} owner
 * @param {*} self A *temporary* helper to detect places where `this` is
 * different from the `owner` when React.createElement is called, so that we
 * can warn. We want to get rid of owner and replace string `ref`s with arrow
 * functions, and as long as `this` and owner are the same, there will be no
 * change in behavior.
 * @param {*} source An annotation object (added by a transpiler or otherwise)
 * indicating filename, line number, and/or other information.
 * @internal
 */


var ReactElement = function (type, key, ref, self, source, owner, props) {
  var element = {
    // This tag allows us to uniquely identify this as a React Element
    $$typeof: REACT_ELEMENT_TYPE,
    // Built-in properties that belong on the element
    type: type,
    key: key,
    ref: ref,
    props: props,
    // Record the component responsible for creating this element.
    _owner: owner
  };

  {
    // The validation flag is currently mutative. We put it on
    // an external backing store so that we can freeze the whole object.
    // This can be replaced with a WeakMap once they are implemented in
    // commonly used development environments.
    element._store = {}; // To make comparing ReactElements easier for testing purposes, we make
    // the validation flag non-enumerable (where possible, which should
    // include every environment we run tests in), so the test framework
    // ignores it.

    Object.defineProperty(element._store, 'validated', {
      configurable: false,
      enumerable: false,
      writable: true,
      value: false
    }); // self and source are DEV only properties.

    Object.defineProperty(element, '_self', {
      configurable: false,
      enumerable: false,
      writable: false,
      value: self
    }); // Two elements created in two different places should be considered
    // equal for testing purposes and therefore we hide it from enumeration.

    Object.defineProperty(element, '_source', {
      configurable: false,
      enumerable: false,
      writable: false,
      value: source
    });

    if (Object.freeze) {
      Object.freeze(element.props);
      Object.freeze(element);
    }
  }

  return element;
};
/**
 * Create and return a new ReactElement of the given type.
 * See https://reactjs.org/docs/react-api.html#createelement
 */

function createElement(type, config, children) {
  var propName; // Reserved names are extracted

  var props = {};
  var key = null;
  var ref = null;
  var self = null;
  var source = null;

  if (config != null) {
    if (hasValidRef(config)) {
      ref = config.ref;

      {
        warnIfStringRefCannotBeAutoConverted(config);
      }
    }

    if (hasValidKey(config)) {
      key = '' + config.key;
    }

    self = config.__self === undefined ? null : config.__self;
    source = config.__source === undefined ? null : config.__source; // Remaining properties are added to a new props object

    for (propName in config) {
      if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
        props[propName] = config[propName];
      }
    }
  } // Children can be more than one argument, and those are transferred onto
  // the newly allocated props object.


  var childrenLength = arguments.length - 2;

  if (childrenLength === 1) {
    props.children = children;
  } else if (childrenLength > 1) {
    var childArray = Array(childrenLength);

    for (var i = 0; i < childrenLength; i++) {
      childArray[i] = arguments[i + 2];
    }

    {
      if (Object.freeze) {
        Object.freeze(childArray);
      }
    }

    props.children = childArray;
  } // Resolve default props


  if (type && type.defaultProps) {
    var defaultProps = type.defaultProps;

    for (propName in defaultProps) {
      if (props[propName] === undefined) {
        props[propName] = defaultProps[propName];
      }
    }
  }

  {
    if (key || ref) {
      var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;

      if (key) {
        defineKeyPropWarningGetter(props, displayName);
      }

      if (ref) {
        defineRefPropWarningGetter(props, displayName);
      }
    }
  }

  return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);
}
function cloneAndReplaceKey(oldElement, newKey) {
  var newElement = ReactElement(oldElement.type, newKey, oldElement.ref, oldElement._self, oldElement._source, oldElement._owner, oldElement.props);
  return newElement;
}
/**
 * Clone and return a new ReactElement using element as the starting point.
 * See https://reactjs.org/docs/react-api.html#cloneelement
 */

function cloneElement(element, config, children) {
  if (!!(element === null || element === undefined)) {
    {
      throw Error( "React.cloneElement(...): The argument must be a React element, but you passed " + element + "." );
    }
  }

  var propName; // Original props are copied

  var props = _assign({}, element.props); // Reserved names are extracted


  var key = element.key;
  var ref = element.ref; // Self is preserved since the owner is preserved.

  var self = element._self; // Source is preserved since cloneElement is unlikely to be targeted by a
  // transpiler, and the original source is probably a better indicator of the
  // true owner.

  var source = element._source; // Owner will be preserved, unless ref is overridden

  var owner = element._owner;

  if (config != null) {
    if (hasValidRef(config)) {
      // Silently steal the ref from the parent.
      ref = config.ref;
      owner = ReactCurrentOwner.current;
    }

    if (hasValidKey(config)) {
      key = '' + config.key;
    } // Remaining properties override existing props


    var defaultProps;

    if (element.type && element.type.defaultProps) {
      defaultProps = element.type.defaultProps;
    }

    for (propName in config) {
      if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
        if (config[propName] === undefined && defaultProps !== undefined) {
          // Resolve default props
          props[propName] = defaultProps[propName];
        } else {
          props[propName] = config[propName];
        }
      }
    }
  } // Children can be more than one argument, and those are transferred onto
  // the newly allocated props object.


  var childrenLength = arguments.length - 2;

  if (childrenLength === 1) {
    props.children = children;
  } else if (childrenLength > 1) {
    var childArray = Array(childrenLength);

    for (var i = 0; i < childrenLength; i++) {
      childArray[i] = arguments[i + 2];
    }

    props.children = childArray;
  }

  return ReactElement(element.type, key, ref, self, source, owner, props);
}
/**
 * Verifies the object is a ReactElement.
 * See https://reactjs.org/docs/react-api.html#isvalidelement
 * @param {?object} object
 * @return {boolean} True if `object` is a ReactElement.
 * @final
 */

function isValidElement(object) {
  return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
}

var SEPARATOR = '.';
var SUBSEPARATOR = ':';
/**
 * Escape and wrap key so it is safe to use as a reactid
 *
 * @param {string} key to be escaped.
 * @return {string} the escaped key.
 */

function escape(key) {
  var escapeRegex = /[=:]/g;
  var escaperLookup = {
    '=': '=0',
    ':': '=2'
  };
  var escapedString = key.replace(escapeRegex, function (match) {
    return escaperLookup[match];
  });
  return '$' + escapedString;
}
/**
 * TODO: Test that a single child and an array with one item have the same key
 * pattern.
 */


var didWarnAboutMaps = false;
var userProvidedKeyEscapeRegex = /\/+/g;

function escapeUserProvidedKey(text) {
  return text.replace(userProvidedKeyEscapeRegex, '$&/');
}
/**
 * Generate a key string that identifies a element within a set.
 *
 * @param {*} element A element that could contain a manual key.
 * @param {number} index Index that is used if a manual key is not provided.
 * @return {string}
 */


function getElementKey(element, index) {
  // Do some typechecking here since we call this blindly. We want to ensure
  // that we don't block potential future ES APIs.
  if (typeof element === 'object' && element !== null && element.key != null) {
    // Explicit key
    return escape('' + element.key);
  } // Implicit key determined by the index in the set


  return index.toString(36);
}

function mapIntoArray(children, array, escapedPrefix, nameSoFar, callback) {
  var type = typeof children;

  if (type === 'undefined' || type === 'boolean') {
    // All of the above are perceived as null.
    children = null;
  }

  var invokeCallback = false;

  if (children === null) {
    invokeCallback = true;
  } else {
    switch (type) {
      case 'string':
      case 'number':
        invokeCallback = true;
        break;

      case 'object':
        switch (children.$$typeof) {
          case REACT_ELEMENT_TYPE:
          case REACT_PORTAL_TYPE:
            invokeCallback = true;
        }

    }
  }

  if (invokeCallback) {
    var _child = children;
    var mappedChild = callback(_child); // If it's the only child, treat the name as if it was wrapped in an array
    // so that it's consistent if the number of children grows:

    var childKey = nameSoFar === '' ? SEPARATOR + getElementKey(_child, 0) : nameSoFar;

    if (Array.isArray(mappedChild)) {
      var escapedChildKey = '';

      if (childKey != null) {
        escapedChildKey = escapeUserProvidedKey(childKey) + '/';
      }

      mapIntoArray(mappedChild, array, escapedChildKey, '', function (c) {
        return c;
      });
    } else if (mappedChild != null) {
      if (isValidElement(mappedChild)) {
        mappedChild = cloneAndReplaceKey(mappedChild, // Keep both the (mapped) and old keys if they differ, just as
        // traverseAllChildren used to do for objects as children
        escapedPrefix + ( // $FlowFixMe Flow incorrectly thinks React.Portal doesn't have a key
        mappedChild.key && (!_child || _child.key !== mappedChild.key) ? // $FlowFixMe Flow incorrectly thinks existing element's key can be a number
        escapeUserProvidedKey('' + mappedChild.key) + '/' : '') + childKey);
      }

      array.push(mappedChild);
    }

    return 1;
  }

  var child;
  var nextName;
  var subtreeCount = 0; // Count of children found in the current subtree.

  var nextNamePrefix = nameSoFar === '' ? SEPARATOR : nameSoFar + SUBSEPARATOR;

  if (Array.isArray(children)) {
    for (var i = 0; i < children.length; i++) {
      child = children[i];
      nextName = nextNamePrefix + getElementKey(child, i);
      subtreeCount += mapIntoArray(child, array, escapedPrefix, nextName, callback);
    }
  } else {
    var iteratorFn = getIteratorFn(children);

    if (typeof iteratorFn === 'function') {
      var iterableChildren = children;

      {
        // Warn about using Maps as children
        if (iteratorFn === iterableChildren.entries) {
          if (!didWarnAboutMaps) {
            warn('Using Maps as children is not supported. ' + 'Use an array of keyed ReactElements instead.');
          }

          didWarnAboutMaps = true;
        }
      }

      var iterator = iteratorFn.call(iterableChildren);
      var step;
      var ii = 0;

      while (!(step = iterator.next()).done) {
        child = step.value;
        nextName = nextNamePrefix + getElementKey(child, ii++);
        subtreeCount += mapIntoArray(child, array, escapedPrefix, nextName, callback);
      }
    } else if (type === 'object') {
      var childrenString = '' + children;

      {
        {
          throw Error( "Objects are not valid as a React child (found: " + (childrenString === '[object Object]' ? 'object with keys {' + Object.keys(children).join(', ') + '}' : childrenString) + "). If you meant to render a collection of children, use an array instead." );
        }
      }
    }
  }

  return subtreeCount;
}

/**
 * Maps children that are typically specified as `props.children`.
 *
 * See https://reactjs.org/docs/react-api.html#reactchildrenmap
 *
 * The provided mapFunction(child, index) will be called for each
 * leaf child.
 *
 * @param {?*} children Children tree container.
 * @param {function(*, int)} func The map function.
 * @param {*} context Context for mapFunction.
 * @return {object} Object containing the ordered map of results.
 */
function mapChildren(children, func, context) {
  if (children == null) {
    return children;
  }

  var result = [];
  var count = 0;
  mapIntoArray(children, result, '', '', function (child) {
    return func.call(context, child, count++);
  });
  return result;
}
/**
 * Count the number of children that are typically specified as
 * `props.children`.
 *
 * See https://reactjs.org/docs/react-api.html#reactchildrencount
 *
 * @param {?*} children Children tree container.
 * @return {number} The number of children.
 */


function countChildren(children) {
  var n = 0;
  mapChildren(children, function () {
    n++; // Don't return anything
  });
  return n;
}

/**
 * Iterates through children that are typically specified as `props.children`.
 *
 * See https://reactjs.org/docs/react-api.html#reactchildrenforeach
 *
 * The provided forEachFunc(child, index) will be called for each
 * leaf child.
 *
 * @param {?*} children Children tree container.
 * @param {function(*, int)} forEachFunc
 * @param {*} forEachContext Context for forEachContext.
 */
function forEachChildren(children, forEachFunc, forEachContext) {
  mapChildren(children, function () {
    forEachFunc.apply(this, arguments); // Don't return anything.
  }, forEachContext);
}
/**
 * Flatten a children object (typically specified as `props.children`) and
 * return an array with appropriately re-keyed children.
 *
 * See https://reactjs.org/docs/react-api.html#reactchildrentoarray
 */


function toArray(children) {
  return mapChildren(children, function (child) {
    return child;
  }) || [];
}
/**
 * Returns the first child in a collection of children and verifies that there
 * is only one child in the collection.
 *
 * See https://reactjs.org/docs/react-api.html#reactchildrenonly
 *
 * The current implementation of this function assumes that a single child gets
 * passed without a wrapper, but the purpose of this helper function is to
 * abstract away the particular structure of children.
 *
 * @param {?object} children Child collection structure.
 * @return {ReactElement} The first and only `ReactElement` contained in the
 * structure.
 */


function onlyChild(children) {
  if (!isValidElement(children)) {
    {
      throw Error( "React.Children.only expected to receive a single React element child." );
    }
  }

  return children;
}

function createContext(defaultValue, calculateChangedBits) {
  if (calculateChangedBits === undefined) {
    calculateChangedBits = null;
  } else {
    {
      if (calculateChangedBits !== null && typeof calculateChangedBits !== 'function') {
        error('createContext: Expected the optional second argument to be a ' + 'function. Instead received: %s', calculateChangedBits);
      }
    }
  }

  var context = {
    $$typeof: REACT_CONTEXT_TYPE,
    _calculateChangedBits: calculateChangedBits,
    // As a workaround to support multiple concurrent renderers, we categorize
    // some renderers as primary and others as secondary. We only expect
    // there to be two concurrent renderers at most: React Native (primary) and
    // Fabric (secondary); React DOM (primary) and React ART (secondary).
    // Secondary renderers store their context values on separate fields.
    _currentValue: defaultValue,
    _currentValue2: defaultValue,
    // Used to track how many concurrent renderers this context currently
    // supports within in a single renderer. Such as parallel server rendering.
    _threadCount: 0,
    // These are circular
    Provider: null,
    Consumer: null
  };
  context.Provider = {
    $$typeof: REACT_PROVIDER_TYPE,
    _context: context
  };
  var hasWarnedAboutUsingNestedContextConsumers = false;
  var hasWarnedAboutUsingConsumerProvider = false;
  var hasWarnedAboutDisplayNameOnConsumer = false;

  {
    // A separate object, but proxies back to the original context object for
    // backwards compatibility. It has a different $$typeof, so we can properly
    // warn for the incorrect usage of Context as a Consumer.
    var Consumer = {
      $$typeof: REACT_CONTEXT_TYPE,
      _context: context,
      _calculateChangedBits: context._calculateChangedBits
    }; // $FlowFixMe: Flow complains about not setting a value, which is intentional here

    Object.defineProperties(Consumer, {
      Provider: {
        get: function () {
          if (!hasWarnedAboutUsingConsumerProvider) {
            hasWarnedAboutUsingConsumerProvider = true;

            error('Rendering <Context.Consumer.Provider> is not supported and will be removed in ' + 'a future major release. Did you mean to render <Context.Provider> instead?');
          }

          return context.Provider;
        },
        set: function (_Provider) {
          context.Provider = _Provider;
        }
      },
      _currentValue: {
        get: function () {
          return context._currentValue;
        },
        set: function (_currentValue) {
          context._currentValue = _currentValue;
        }
      },
      _currentValue2: {
        get: function () {
          return context._currentValue2;
        },
        set: function (_currentValue2) {
          context._currentValue2 = _currentValue2;
        }
      },
      _threadCount: {
        get: function () {
          return context._threadCount;
        },
        set: function (_threadCount) {
          context._threadCount = _threadCount;
        }
      },
      Consumer: {
        get: function () {
          if (!hasWarnedAboutUsingNestedContextConsumers) {
            hasWarnedAboutUsingNestedContextConsumers = true;

            error('Rendering <Context.Consumer.Consumer> is not supported and will be removed in ' + 'a future major release. Did you mean to render <Context.Consumer> instead?');
          }

          return context.Consumer;
        }
      },
      displayName: {
        get: function () {
          return context.displayName;
        },
        set: function (displayName) {
          if (!hasWarnedAboutDisplayNameOnConsumer) {
            warn('Setting `displayName` on Context.Consumer has no effect. ' + "You should set it directly on the context with Context.displayName = '%s'.", displayName);

            hasWarnedAboutDisplayNameOnConsumer = true;
          }
        }
      }
    }); // $FlowFixMe: Flow complains about missing properties because it doesn't understand defineProperty

    context.Consumer = Consumer;
  }

  {
    context._currentRenderer = null;
    context._currentRenderer2 = null;
  }

  return context;
}

var Uninitialized = -1;
var Pending = 0;
var Resolved = 1;
var Rejected = 2;

function lazyInitializer(payload) {
  if (payload._status === Uninitialized) {
    var ctor = payload._result;
    var thenable = ctor(); // Transition to the next state.

    var pending = payload;
    pending._status = Pending;
    pending._result = thenable;
    thenable.then(function (moduleObject) {
      if (payload._status === Pending) {
        var defaultExport = moduleObject.default;

        {
          if (defaultExport === undefined) {
            error('lazy: Expected the result of a dynamic import() call. ' + 'Instead received: %s\n\nYour code should look like: \n  ' + // Break up imports to avoid accidentally parsing them as dependencies.
            'const MyComponent = lazy(() => imp' + "ort('./MyComponent'))", moduleObject);
          }
        } // Transition to the next state.


        var resolved = payload;
        resolved._status = Resolved;
        resolved._result = defaultExport;
      }
    }, function (error) {
      if (payload._status === Pending) {
        // Transition to the next state.
        var rejected = payload;
        rejected._status = Rejected;
        rejected._result = error;
      }
    });
  }

  if (payload._status === Resolved) {
    return payload._result;
  } else {
    throw payload._result;
  }
}

function lazy(ctor) {
  var payload = {
    // We use these fields to store the result.
    _status: -1,
    _result: ctor
  };
  var lazyType = {
    $$typeof: REACT_LAZY_TYPE,
    _payload: payload,
    _init: lazyInitializer
  };

  {
    // In production, this would just set it on the object.
    var defaultProps;
    var propTypes; // $FlowFixMe

    Object.defineProperties(lazyType, {
      defaultProps: {
        configurable: true,
        get: function () {
          return defaultProps;
        },
        set: function (newDefaultProps) {
          error('React.lazy(...): It is not supported to assign `defaultProps` to ' + 'a lazy component import. Either specify them where the component ' + 'is defined, or create a wrapping component around it.');

          defaultProps = newDefaultProps; // Match production behavior more closely:
          // $FlowFixMe

          Object.defineProperty(lazyType, 'defaultProps', {
            enumerable: true
          });
        }
      },
      propTypes: {
        configurable: true,
        get: function () {
          return propTypes;
        },
        set: function (newPropTypes) {
          error('React.lazy(...): It is not supported to assign `propTypes` to ' + 'a lazy component import. Either specify them where the component ' + 'is defined, or create a wrapping component around it.');

          propTypes = newPropTypes; // Match production behavior more closely:
          // $FlowFixMe

          Object.defineProperty(lazyType, 'propTypes', {
            enumerable: true
          });
        }
      }
    });
  }

  return lazyType;
}

function forwardRef(render) {
  {
    if (render != null && render.$$typeof === REACT_MEMO_TYPE) {
      error('forwardRef requires a render function but received a `memo` ' + 'component. Instead of forwardRef(memo(...)), use ' + 'memo(forwardRef(...)).');
    } else if (typeof render !== 'function') {
      error('forwardRef requires a render function but was given %s.', render === null ? 'null' : typeof render);
    } else {
      if (render.length !== 0 && render.length !== 2) {
        error('forwardRef render functions accept exactly two parameters: props and ref. %s', render.length === 1 ? 'Did you forget to use the ref parameter?' : 'Any additional parameter will be undefined.');
      }
    }

    if (render != null) {
      if (render.defaultProps != null || render.propTypes != null) {
        error('forwardRef render functions do not support propTypes or defaultProps. ' + 'Did you accidentally pass a React component?');
      }
    }
  }

  var elementType = {
    $$typeof: REACT_FORWARD_REF_TYPE,
    render: render
  };

  {
    var ownName;
    Object.defineProperty(elementType, 'displayName', {
      enumerable: false,
      configurable: true,
      get: function () {
        return ownName;
      },
      set: function (name) {
        ownName = name;

        if (render.displayName == null) {
          render.displayName = name;
        }
      }
    });
  }

  return elementType;
}

// Filter certain DOM attributes (e.g. src, href) if their values are empty strings.

var enableScopeAPI = false; // Experimental Create Event Handle API.

function isValidElementType(type) {
  if (typeof type === 'string' || typeof type === 'function') {
    return true;
  } // Note: typeof might be other than 'symbol' or 'number' (e.g. if it's a polyfill).


  if (type === exports.Fragment || type === exports.Profiler || type === REACT_DEBUG_TRACING_MODE_TYPE || type === exports.StrictMode || type === exports.Suspense || type === REACT_SUSPENSE_LIST_TYPE || type === REACT_LEGACY_HIDDEN_TYPE || enableScopeAPI ) {
    return true;
  }

  if (typeof type === 'object' && type !== null) {
    if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_BLOCK_TYPE || type[0] === REACT_SERVER_BLOCK_TYPE) {
      return true;
    }
  }

  return false;
}

function memo(type, compare) {
  {
    if (!isValidElementType(type)) {
      error('memo: The first argument must be a component. Instead ' + 'received: %s', type === null ? 'null' : typeof type);
    }
  }

  var elementType = {
    $$typeof: REACT_MEMO_TYPE,
    type: type,
    compare: compare === undefined ? null : compare
  };

  {
    var ownName;
    Object.defineProperty(elementType, 'displayName', {
      enumerable: false,
      configurable: true,
      get: function () {
        return ownName;
      },
      set: function (name) {
        ownName = name;

        if (type.displayName == null) {
          type.displayName = name;
        }
      }
    });
  }

  return elementType;
}

function resolveDispatcher() {
  var dispatcher = ReactCurrentDispatcher.current;

  if (!(dispatcher !== null)) {
    {
      throw Error( "Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem." );
    }
  }

  return dispatcher;
}

function useContext(Context, unstable_observedBits) {
  var dispatcher = resolveDispatcher();

  {
    if (unstable_observedBits !== undefined) {
      error('useContext() second argument is reserved for future ' + 'use in React. Passing it is not supported. ' + 'You passed: %s.%s', unstable_observedBits, typeof unstable_observedBits === 'number' && Array.isArray(arguments[2]) ? '\n\nDid you call array.map(useContext)? ' + 'Calling Hooks inside a loop is not supported. ' + 'Learn more at https://reactjs.org/link/rules-of-hooks' : '');
    } // TODO: add a more generic warning for invalid values.


    if (Context._context !== undefined) {
      var realContext = Context._context; // Don't deduplicate because this legitimately causes bugs
      // and nobody should be using this in existing code.

      if (realContext.Consumer === Context) {
        error('Calling useContext(Context.Consumer) is not supported, may cause bugs, and will be ' + 'removed in a future major release. Did you mean to call useContext(Context) instead?');
      } else if (realContext.Provider === Context) {
        error('Calling useContext(Context.Provider) is not supported. ' + 'Did you mean to call useContext(Context) instead?');
      }
    }
  }

  return dispatcher.useContext(Context, unstable_observedBits);
}
function useState(initialState) {
  var dispatcher = resolveDispatcher();
  return dispatcher.useState(initialState);
}
function useReducer(reducer, initialArg, init) {
  var dispatcher = resolveDispatcher();
  return dispatcher.useReducer(reducer, initialArg, init);
}
function useRef(initialValue) {
  var dispatcher = resolveDispatcher();
  return dispatcher.useRef(initialValue);
}
function useEffect(create, deps) {
  var dispatcher = resolveDispatcher();
  return dispatcher.useEffect(create, deps);
}
function useLayoutEffect(create, deps) {
  var dispatcher = resolveDispatcher();
  return dispatcher.useLayoutEffect(create, deps);
}
function useCallback(callback, deps) {
  var dispatcher = resolveDispatcher();
  return dispatcher.useCallback(callback, deps);
}
function useMemo(create, deps) {
  var dispatcher = resolveDispatcher();
  return dispatcher.useMemo(create, deps);
}
function useImperativeHandle(ref, create, deps) {
  var dispatcher = resolveDispatcher();
  return dispatcher.useImperativeHandle(ref, create, deps);
}
function useDebugValue(value, formatterFn) {
  {
    var dispatcher = resolveDispatcher();
    return dispatcher.useDebugValue(value, formatterFn);
  }
}

// Helpers to patch console.logs to avoid logging during side-effect free
// replaying on render function. This currently only patches the object
// lazily which won't cover if the log function was extracted eagerly.
// We could also eagerly patch the method.
var disabledDepth = 0;
var prevLog;
var prevInfo;
var prevWarn;
var prevError;
var prevGroup;
var prevGroupCollapsed;
var prevGroupEnd;

function disabledLog() {}

disabledLog.__reactDisabledLog = true;
function disableLogs() {
  {
    if (disabledDepth === 0) {
      /* eslint-disable react-internal/no-production-logging */
      prevLog = console.log;
      prevInfo = console.info;
      prevWarn = console.warn;
      prevError = console.error;
      prevGroup = console.group;
      prevGroupCollapsed = console.groupCollapsed;
      prevGroupEnd = console.groupEnd; // https://github.com/facebook/react/issues/19099

      var props = {
        configurable: true,
        enumerable: true,
        value: disabledLog,
        writable: true
      }; // $FlowFixMe Flow thinks console is immutable.

      Object.defineProperties(console, {
        info: props,
        log: props,
        warn: props,
        error: props,
        group: props,
        groupCollapsed: props,
        groupEnd: props
      });
      /* eslint-enable react-internal/no-production-logging */
    }

    disabledDepth++;
  }
}
function reenableLogs() {
  {
    disabledDepth--;

    if (disabledDepth === 0) {
      /* eslint-disable react-internal/no-production-logging */
      var props = {
        configurable: true,
        enumerable: true,
        writable: true
      }; // $FlowFixMe Flow thinks console is immutable.

      Object.defineProperties(console, {
        log: _assign({}, props, {
          value: prevLog
        }),
        info: _assign({}, props, {
          value: prevInfo
        }),
        warn: _assign({}, props, {
          value: prevWarn
        }),
        error: _assign({}, props, {
          value: prevError
        }),
        group: _assign({}, props, {
          value: prevGroup
        }),
        groupCollapsed: _assign({}, props, {
          value: prevGroupCollapsed
        }),
        groupEnd: _assign({}, props, {
          value: prevGroupEnd
        })
      });
      /* eslint-enable react-internal/no-production-logging */
    }

    if (disabledDepth < 0) {
      error('disabledDepth fell below zero. ' + 'This is a bug in React. Please file an issue.');
    }
  }
}

var ReactCurrentDispatcher$1 = ReactSharedInternals.ReactCurrentDispatcher;
var prefix;
function describeBuiltInComponentFrame(name, source, ownerFn) {
  {
    if (prefix === undefined) {
      // Extract the VM specific prefix used by each line.
      try {
        throw Error();
      } catch (x) {
        var match = x.stack.trim().match(/\n( *(at )?)/);
        prefix = match && match[1] || '';
      }
    } // We use the prefix to ensure our stacks line up with native stack frames.


    return '\n' + prefix + name;
  }
}
var reentry = false;
var componentFrameCache;

{
  var PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map;
  componentFrameCache = new PossiblyWeakMap();
}

function describeNativeComponentFrame(fn, construct) {
  // If something asked for a stack inside a fake render, it should get ignored.
  if (!fn || reentry) {
    return '';
  }

  {
    var frame = componentFrameCache.get(fn);

    if (frame !== undefined) {
      return frame;
    }
  }

  var control;
  reentry = true;
  var previousPrepareStackTrace = Error.prepareStackTrace; // $FlowFixMe It does accept undefined.

  Error.prepareStackTrace = undefined;
  var previousDispatcher;

  {
    previousDispatcher = ReactCurrentDispatcher$1.current; // Set the dispatcher in DEV because this might be call in the render function
    // for warnings.

    ReactCurrentDispatcher$1.current = null;
    disableLogs();
  }

  try {
    // This should throw.
    if (construct) {
      // Something should be setting the props in the constructor.
      var Fake = function () {
        throw Error();
      }; // $FlowFixMe


      Object.defineProperty(Fake.prototype, 'props', {
        set: function () {
          // We use a throwing setter instead of frozen or non-writable props
          // because that won't throw in a non-strict mode function.
          throw Error();
        }
      });

      if (typeof Reflect === 'object' && Reflect.construct) {
        // We construct a different control for this case to include any extra
        // frames added by the construct call.
        try {
          Reflect.construct(Fake, []);
        } catch (x) {
          control = x;
        }

        Reflect.construct(fn, [], Fake);
      } else {
        try {
          Fake.call();
        } catch (x) {
          control = x;
        }

        fn.call(Fake.prototype);
      }
    } else {
      try {
        throw Error();
      } catch (x) {
        control = x;
      }

      fn();
    }
  } catch (sample) {
    // This is inlined manually because closure doesn't do it for us.
    if (sample && control && typeof sample.stack === 'string') {
      // This extracts the first frame from the sample that isn't also in the control.
      // Skipping one frame that we assume is the frame that calls the two.
      var sampleLines = sample.stack.split('\n');
      var controlLines = control.stack.split('\n');
      var s = sampleLines.length - 1;
      var c = controlLines.length - 1;

      while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {
        // We expect at least one stack frame to be shared.
        // Typically this will be the root most one. However, stack frames may be
        // cut off due to maximum stack limits. In this case, one maybe cut off
        // earlier than the other. We assume that the sample is longer or the same
        // and there for cut off earlier. So we should find the root most frame in
        // the sample somewhere in the control.
        c--;
      }

      for (; s >= 1 && c >= 0; s--, c--) {
        // Next we find the first one that isn't the same which should be the
        // frame that called our sample function and the control.
        if (sampleLines[s] !== controlLines[c]) {
          // In V8, the first line is describing the message but other VMs don't.
          // If we're about to return the first line, and the control is also on the same
          // line, that's a pretty good indicator that our sample threw at same line as
          // the control. I.e. before we entered the sample frame. So we ignore this result.
          // This can happen if you passed a class to function component, or non-function.
          if (s !== 1 || c !== 1) {
            do {
              s--;
              c--; // We may still have similar intermediate frames from the construct call.
              // The next one that isn't the same should be our match though.

              if (c < 0 || sampleLines[s] !== controlLines[c]) {
                // V8 adds a "new" prefix for native classes. Let's remove it to make it prettier.
                var _frame = '\n' + sampleLines[s].replace(' at new ', ' at ');

                {
                  if (typeof fn === 'function') {
                    componentFrameCache.set(fn, _frame);
                  }
                } // Return the line we found.


                return _frame;
              }
            } while (s >= 1 && c >= 0);
          }

          break;
        }
      }
    }
  } finally {
    reentry = false;

    {
      ReactCurrentDispatcher$1.current = previousDispatcher;
      reenableLogs();
    }

    Error.prepareStackTrace = previousPrepareStackTrace;
  } // Fallback to just using the name if we couldn't make it throw.


  var name = fn ? fn.displayName || fn.name : '';
  var syntheticFrame = name ? describeBuiltInComponentFrame(name) : '';

  {
    if (typeof fn === 'function') {
      componentFrameCache.set(fn, syntheticFrame);
    }
  }

  return syntheticFrame;
}
function describeFunctionComponentFrame(fn, source, ownerFn) {
  {
    return describeNativeComponentFrame(fn, false);
  }
}

function shouldConstruct(Component) {
  var prototype = Component.prototype;
  return !!(prototype && prototype.isReactComponent);
}

function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {

  if (type == null) {
    return '';
  }

  if (typeof type === 'function') {
    {
      return describeNativeComponentFrame(type, shouldConstruct(type));
    }
  }

  if (typeof type === 'string') {
    return describeBuiltInComponentFrame(type);
  }

  switch (type) {
    case exports.Suspense:
      return describeBuiltInComponentFrame('Suspense');

    case REACT_SUSPENSE_LIST_TYPE:
      return describeBuiltInComponentFrame('SuspenseList');
  }

  if (typeof type === 'object') {
    switch (type.$$typeof) {
      case REACT_FORWARD_REF_TYPE:
        return describeFunctionComponentFrame(type.render);

      case REACT_MEMO_TYPE:
        // Memo may contain any component type so we recursively resolve it.
        return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);

      case REACT_BLOCK_TYPE:
        return describeFunctionComponentFrame(type._render);

      case REACT_LAZY_TYPE:
        {
          var lazyComponent = type;
          var payload = lazyComponent._payload;
          var init = lazyComponent._init;

          try {
            // Lazy may contain any component type so we recursively resolve it.
            return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);
          } catch (x) {}
        }
    }
  }

  return '';
}

var loggedTypeFailures = {};
var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;

function setCurrentlyValidatingElement(element) {
  {
    if (element) {
      var owner = element._owner;
      var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
      ReactDebugCurrentFrame$1.setExtraStackFrame(stack);
    } else {
      ReactDebugCurrentFrame$1.setExtraStackFrame(null);
    }
  }
}

function checkPropTypes(typeSpecs, values, location, componentName, element) {
  {
    // $FlowFixMe This is okay but Flow doesn't know it.
    var has = Function.call.bind(Object.prototype.hasOwnProperty);

    for (var typeSpecName in typeSpecs) {
      if (has(typeSpecs, typeSpecName)) {
        var error$1 = void 0; // Prop type validation may throw. In case they do, we don't want to
        // fail the render phase where it didn't fail before. So we log it.
        // After these have been cleaned up, we'll let them throw.

        try {
          // This is intentionally an invariant that gets caught. It's the same
          // behavior as without this statement except with a better message.
          if (typeof typeSpecs[typeSpecName] !== 'function') {
            var err = Error((componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' + 'it must be a function, usually from the `prop-types` package, but received `' + typeof typeSpecs[typeSpecName] + '`.' + 'This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.');
            err.name = 'Invariant Violation';
            throw err;
          }

          error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED');
        } catch (ex) {
          error$1 = ex;
        }

        if (error$1 && !(error$1 instanceof Error)) {
          setCurrentlyValidatingElement(element);

          error('%s: type specification of %s' + ' `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', location, typeSpecName, typeof error$1);

          setCurrentlyValidatingElement(null);
        }

        if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {
          // Only monitor this failure once because there tends to be a lot of the
          // same error.
          loggedTypeFailures[error$1.message] = true;
          setCurrentlyValidatingElement(element);

          error('Failed %s type: %s', location, error$1.message);

          setCurrentlyValidatingElement(null);
        }
      }
    }
  }
}

function setCurrentlyValidatingElement$1(element) {
  {
    if (element) {
      var owner = element._owner;
      var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
      setExtraStackFrame(stack);
    } else {
      setExtraStackFrame(null);
    }
  }
}

var propTypesMisspellWarningShown;

{
  propTypesMisspellWarningShown = false;
}

function getDeclarationErrorAddendum() {
  if (ReactCurrentOwner.current) {
    var name = getComponentName(ReactCurrentOwner.current.type);

    if (name) {
      return '\n\nCheck the render method of `' + name + '`.';
    }
  }

  return '';
}

function getSourceInfoErrorAddendum(source) {
  if (source !== undefined) {
    var fileName = source.fileName.replace(/^.*[\\\/]/, '');
    var lineNumber = source.lineNumber;
    return '\n\nCheck your code at ' + fileName + ':' + lineNumber + '.';
  }

  return '';
}

function getSourceInfoErrorAddendumForProps(elementProps) {
  if (elementProps !== null && elementProps !== undefined) {
    return getSourceInfoErrorAddendum(elementProps.__source);
  }

  return '';
}
/**
 * Warn if there's no key explicitly set on dynamic arrays of children or
 * object keys are not valid. This allows us to keep track of children between
 * updates.
 */


var ownerHasKeyUseWarning = {};

function getCurrentComponentErrorInfo(parentType) {
  var info = getDeclarationErrorAddendum();

  if (!info) {
    var parentName = typeof parentType === 'string' ? parentType : parentType.displayName || parentType.name;

    if (parentName) {
      info = "\n\nCheck the top-level render call using <" + parentName + ">.";
    }
  }

  return info;
}
/**
 * Warn if the element doesn't have an explicit key assigned to it.
 * This element is in an array. The array could grow and shrink or be
 * reordered. All children that haven't already been validated are required to
 * have a "key" property assigned to it. Error statuses are cached so a warning
 * will only be shown once.
 *
 * @internal
 * @param {ReactElement} element Element that requires a key.
 * @param {*} parentType element's parent's type.
 */


function validateExplicitKey(element, parentType) {
  if (!element._store || element._store.validated || element.key != null) {
    return;
  }

  element._store.validated = true;
  var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);

  if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {
    return;
  }

  ownerHasKeyUseWarning[currentComponentErrorInfo] = true; // Usually the current owner is the offender, but if it accepts children as a
  // property, it may be the creator of the child that's responsible for
  // assigning it a key.

  var childOwner = '';

  if (element && element._owner && element._owner !== ReactCurrentOwner.current) {
    // Give the component that originally created this child.
    childOwner = " It was passed a child from " + getComponentName(element._owner.type) + ".";
  }

  {
    setCurrentlyValidatingElement$1(element);

    error('Each child in a list should have a unique "key" prop.' + '%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);

    setCurrentlyValidatingElement$1(null);
  }
}
/**
 * Ensure that every element either is passed in a static location, in an
 * array with an explicit keys property defined, or in an object literal
 * with valid key property.
 *
 * @internal
 * @param {ReactNode} node Statically passed child of any type.
 * @param {*} parentType node's parent's type.
 */


function validateChildKeys(node, parentType) {
  if (typeof node !== 'object') {
    return;
  }

  if (Array.isArray(node)) {
    for (var i = 0; i < node.length; i++) {
      var child = node[i];

      if (isValidElement(child)) {
        validateExplicitKey(child, parentType);
      }
    }
  } else if (isValidElement(node)) {
    // This element was passed in a valid location.
    if (node._store) {
      node._store.validated = true;
    }
  } else if (node) {
    var iteratorFn = getIteratorFn(node);

    if (typeof iteratorFn === 'function') {
      // Entry iterators used to provide implicit keys,
      // but now we print a separate warning for them later.
      if (iteratorFn !== node.entries) {
        var iterator = iteratorFn.call(node);
        var step;

        while (!(step = iterator.next()).done) {
          if (isValidElement(step.value)) {
            validateExplicitKey(step.value, parentType);
          }
        }
      }
    }
  }
}
/**
 * Given an element, validate that its props follow the propTypes definition,
 * provided by the type.
 *
 * @param {ReactElement} element
 */


function validatePropTypes(element) {
  {
    var type = element.type;

    if (type === null || type === undefined || typeof type === 'string') {
      return;
    }

    var propTypes;

    if (typeof type === 'function') {
      propTypes = type.propTypes;
    } else if (typeof type === 'object' && (type.$$typeof === REACT_FORWARD_REF_TYPE || // Note: Memo only checks outer props here.
    // Inner props are checked in the reconciler.
    type.$$typeof === REACT_MEMO_TYPE)) {
      propTypes = type.propTypes;
    } else {
      return;
    }

    if (propTypes) {
      // Intentionally inside to avoid triggering lazy initializers:
      var name = getComponentName(type);
      checkPropTypes(propTypes, element.props, 'prop', name, element);
    } else if (type.PropTypes !== undefined && !propTypesMisspellWarningShown) {
      propTypesMisspellWarningShown = true; // Intentionally inside to avoid triggering lazy initializers:

      var _name = getComponentName(type);

      error('Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?', _name || 'Unknown');
    }

    if (typeof type.getDefaultProps === 'function' && !type.getDefaultProps.isReactClassApproved) {
      error('getDefaultProps is only used on classic React.createClass ' + 'definitions. Use a static property named `defaultProps` instead.');
    }
  }
}
/**
 * Given a fragment, validate that it can only be provided with fragment props
 * @param {ReactElement} fragment
 */


function validateFragmentProps(fragment) {
  {
    var keys = Object.keys(fragment.props);

    for (var i = 0; i < keys.length; i++) {
      var key = keys[i];

      if (key !== 'children' && key !== 'key') {
        setCurrentlyValidatingElement$1(fragment);

        error('Invalid prop `%s` supplied to `React.Fragment`. ' + 'React.Fragment can only have `key` and `children` props.', key);

        setCurrentlyValidatingElement$1(null);
        break;
      }
    }

    if (fragment.ref !== null) {
      setCurrentlyValidatingElement$1(fragment);

      error('Invalid attribute `ref` supplied to `React.Fragment`.');

      setCurrentlyValidatingElement$1(null);
    }
  }
}
function createElementWithValidation(type, props, children) {
  var validType = isValidElementType(type); // We warn in this case but don't throw. We expect the element creation to
  // succeed and there will likely be errors in render.

  if (!validType) {
    var info = '';

    if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {
      info += ' You likely forgot to export your component from the file ' + "it's defined in, or you might have mixed up default and named imports.";
    }

    var sourceInfo = getSourceInfoErrorAddendumForProps(props);

    if (sourceInfo) {
      info += sourceInfo;
    } else {
      info += getDeclarationErrorAddendum();
    }

    var typeString;

    if (type === null) {
      typeString = 'null';
    } else if (Array.isArray(type)) {
      typeString = 'array';
    } else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) {
      typeString = "<" + (getComponentName(type.type) || 'Unknown') + " />";
      info = ' Did you accidentally export a JSX literal instead of a component?';
    } else {
      typeString = typeof type;
    }

    {
      error('React.createElement: type is invalid -- expected a string (for ' + 'built-in components) or a class/function (for composite ' + 'components) but got: %s.%s', typeString, info);
    }
  }

  var element = createElement.apply(this, arguments); // The result can be nullish if a mock or a custom function is used.
  // TODO: Drop this when these are no longer allowed as the type argument.

  if (element == null) {
    return element;
  } // Skip key warning if the type isn't valid since our key validation logic
  // doesn't expect a non-string/function type and can throw confusing errors.
  // We don't want exception behavior to differ between dev and prod.
  // (Rendering will throw with a helpful message and as soon as the type is
  // fixed, the key warnings will appear.)


  if (validType) {
    for (var i = 2; i < arguments.length; i++) {
      validateChildKeys(arguments[i], type);
    }
  }

  if (type === exports.Fragment) {
    validateFragmentProps(element);
  } else {
    validatePropTypes(element);
  }

  return element;
}
var didWarnAboutDeprecatedCreateFactory = false;
function createFactoryWithValidation(type) {
  var validatedFactory = createElementWithValidation.bind(null, type);
  validatedFactory.type = type;

  {
    if (!didWarnAboutDeprecatedCreateFactory) {
      didWarnAboutDeprecatedCreateFactory = true;

      warn('React.createFactory() is deprecated and will be removed in ' + 'a future major release. Consider using JSX ' + 'or use React.createElement() directly instead.');
    } // Legacy hook: remove it


    Object.defineProperty(validatedFactory, 'type', {
      enumerable: false,
      get: function () {
        warn('Factory.type is deprecated. Access the class directly ' + 'before passing it to createFactory.');

        Object.defineProperty(this, 'type', {
          value: type
        });
        return type;
      }
    });
  }

  return validatedFactory;
}
function cloneElementWithValidation(element, props, children) {
  var newElement = cloneElement.apply(this, arguments);

  for (var i = 2; i < arguments.length; i++) {
    validateChildKeys(arguments[i], newElement.type);
  }

  validatePropTypes(newElement);
  return newElement;
}

{

  try {
    var frozenObject = Object.freeze({});
    /* eslint-disable no-new */

    new Map([[frozenObject, null]]);
    new Set([frozenObject]);
    /* eslint-enable no-new */
  } catch (e) {
  }
}

var createElement$1 =  createElementWithValidation ;
var cloneElement$1 =  cloneElementWithValidation ;
var createFactory =  createFactoryWithValidation ;
var Children = {
  map: mapChildren,
  forEach: forEachChildren,
  count: countChildren,
  toArray: toArray,
  only: onlyChild
};

exports.Children = Children;
exports.Component = Component;
exports.PureComponent = PureComponent;
exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = ReactSharedInternals;
exports.cloneElement = cloneElement$1;
exports.createContext = createContext;
exports.createElement = createElement$1;
exports.createFactory = createFactory;
exports.createRef = createRef;
exports.forwardRef = forwardRef;
exports.isValidElement = isValidElement;
exports.lazy = lazy;
exports.memo = memo;
exports.useCallback = useCallback;
exports.useContext = useContext;
exports.useDebugValue = useDebugValue;
exports.useEffect = useEffect;
exports.useImperativeHandle = useImperativeHandle;
exports.useLayoutEffect = useLayoutEffect;
exports.useMemo = useMemo;
exports.useReducer = useReducer;
exports.useRef = useRef;
exports.useState = useState;
exports.version = ReactVersion;
  })();
}


/***/ }),

/***/ "./node_modules/react/index.js":
/*!*************************************!*\
  !*** ./node_modules/react/index.js ***!
  \*************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


if (false) {} else {
  module.exports = __webpack_require__(/*! ./cjs/react.development.js */ "./node_modules/react/cjs/react.development.js");
}


/***/ }),

/***/ "./node_modules/scheduler/cjs/scheduler-tracing.development.js":
/*!*********************************************************************!*\
  !*** ./node_modules/scheduler/cjs/scheduler-tracing.development.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
/** @license React v0.20.2
 * scheduler-tracing.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



if (true) {
  (function() {
'use strict';

var DEFAULT_THREAD_ID = 0; // Counters used to generate unique IDs.

var interactionIDCounter = 0;
var threadIDCounter = 0; // Set of currently traced interactions.
// Interactions "stack"–
// Meaning that newly traced interactions are appended to the previously active set.
// When an interaction goes out of scope, the previous set (if any) is restored.

exports.__interactionsRef = null; // Listener(s) to notify when interactions begin and end.

exports.__subscriberRef = null;

{
  exports.__interactionsRef = {
    current: new Set()
  };
  exports.__subscriberRef = {
    current: null
  };
}
function unstable_clear(callback) {

  var prevInteractions = exports.__interactionsRef.current;
  exports.__interactionsRef.current = new Set();

  try {
    return callback();
  } finally {
    exports.__interactionsRef.current = prevInteractions;
  }
}
function unstable_getCurrent() {
  {
    return exports.__interactionsRef.current;
  }
}
function unstable_getThreadID() {
  return ++threadIDCounter;
}
function unstable_trace(name, timestamp, callback) {
  var threadID = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : DEFAULT_THREAD_ID;

  var interaction = {
    __count: 1,
    id: interactionIDCounter++,
    name: name,
    timestamp: timestamp
  };
  var prevInteractions = exports.__interactionsRef.current; // Traced interactions should stack/accumulate.
  // To do that, clone the current interactions.
  // The previous set will be restored upon completion.

  var interactions = new Set(prevInteractions);
  interactions.add(interaction);
  exports.__interactionsRef.current = interactions;
  var subscriber = exports.__subscriberRef.current;
  var returnValue;

  try {
    if (subscriber !== null) {
      subscriber.onInteractionTraced(interaction);
    }
  } finally {
    try {
      if (subscriber !== null) {
        subscriber.onWorkStarted(interactions, threadID);
      }
    } finally {
      try {
        returnValue = callback();
      } finally {
        exports.__interactionsRef.current = prevInteractions;

        try {
          if (subscriber !== null) {
            subscriber.onWorkStopped(interactions, threadID);
          }
        } finally {
          interaction.__count--; // If no async work was scheduled for this interaction,
          // Notify subscribers that it's completed.

          if (subscriber !== null && interaction.__count === 0) {
            subscriber.onInteractionScheduledWorkCompleted(interaction);
          }
        }
      }
    }
  }

  return returnValue;
}
function unstable_wrap(callback) {
  var threadID = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DEFAULT_THREAD_ID;

  var wrappedInteractions = exports.__interactionsRef.current;
  var subscriber = exports.__subscriberRef.current;

  if (subscriber !== null) {
    subscriber.onWorkScheduled(wrappedInteractions, threadID);
  } // Update the pending async work count for the current interactions.
  // Update after calling subscribers in case of error.


  wrappedInteractions.forEach(function (interaction) {
    interaction.__count++;
  });
  var hasRun = false;

  function wrapped() {
    var prevInteractions = exports.__interactionsRef.current;
    exports.__interactionsRef.current = wrappedInteractions;
    subscriber = exports.__subscriberRef.current;

    try {
      var returnValue;

      try {
        if (subscriber !== null) {
          subscriber.onWorkStarted(wrappedInteractions, threadID);
        }
      } finally {
        try {
          returnValue = callback.apply(undefined, arguments);
        } finally {
          exports.__interactionsRef.current = prevInteractions;

          if (subscriber !== null) {
            subscriber.onWorkStopped(wrappedInteractions, threadID);
          }
        }
      }

      return returnValue;
    } finally {
      if (!hasRun) {
        // We only expect a wrapped function to be executed once,
        // But in the event that it's executed more than once–
        // Only decrement the outstanding interaction counts once.
        hasRun = true; // Update pending async counts for all wrapped interactions.
        // If this was the last scheduled async work for any of them,
        // Mark them as completed.

        wrappedInteractions.forEach(function (interaction) {
          interaction.__count--;

          if (subscriber !== null && interaction.__count === 0) {
            subscriber.onInteractionScheduledWorkCompleted(interaction);
          }
        });
      }
    }
  }

  wrapped.cancel = function cancel() {
    subscriber = exports.__subscriberRef.current;

    try {
      if (subscriber !== null) {
        subscriber.onWorkCanceled(wrappedInteractions, threadID);
      }
    } finally {
      // Update pending async counts for all wrapped interactions.
      // If this was the last scheduled async work for any of them,
      // Mark them as completed.
      wrappedInteractions.forEach(function (interaction) {
        interaction.__count--;

        if (subscriber && interaction.__count === 0) {
          subscriber.onInteractionScheduledWorkCompleted(interaction);
        }
      });
    }
  };

  return wrapped;
}

var subscribers = null;

{
  subscribers = new Set();
}

function unstable_subscribe(subscriber) {
  {
    subscribers.add(subscriber);

    if (subscribers.size === 1) {
      exports.__subscriberRef.current = {
        onInteractionScheduledWorkCompleted: onInteractionScheduledWorkCompleted,
        onInteractionTraced: onInteractionTraced,
        onWorkCanceled: onWorkCanceled,
        onWorkScheduled: onWorkScheduled,
        onWorkStarted: onWorkStarted,
        onWorkStopped: onWorkStopped
      };
    }
  }
}
function unstable_unsubscribe(subscriber) {
  {
    subscribers.delete(subscriber);

    if (subscribers.size === 0) {
      exports.__subscriberRef.current = null;
    }
  }
}

function onInteractionTraced(interaction) {
  var didCatchError = false;
  var caughtError = null;
  subscribers.forEach(function (subscriber) {
    try {
      subscriber.onInteractionTraced(interaction);
    } catch (error) {
      if (!didCatchError) {
        didCatchError = true;
        caughtError = error;
      }
    }
  });

  if (didCatchError) {
    throw caughtError;
  }
}

function onInteractionScheduledWorkCompleted(interaction) {
  var didCatchError = false;
  var caughtError = null;
  subscribers.forEach(function (subscriber) {
    try {
      subscriber.onInteractionScheduledWorkCompleted(interaction);
    } catch (error) {
      if (!didCatchError) {
        didCatchError = true;
        caughtError = error;
      }
    }
  });

  if (didCatchError) {
    throw caughtError;
  }
}

function onWorkScheduled(interactions, threadID) {
  var didCatchError = false;
  var caughtError = null;
  subscribers.forEach(function (subscriber) {
    try {
      subscriber.onWorkScheduled(interactions, threadID);
    } catch (error) {
      if (!didCatchError) {
        didCatchError = true;
        caughtError = error;
      }
    }
  });

  if (didCatchError) {
    throw caughtError;
  }
}

function onWorkStarted(interactions, threadID) {
  var didCatchError = false;
  var caughtError = null;
  subscribers.forEach(function (subscriber) {
    try {
      subscriber.onWorkStarted(interactions, threadID);
    } catch (error) {
      if (!didCatchError) {
        didCatchError = true;
        caughtError = error;
      }
    }
  });

  if (didCatchError) {
    throw caughtError;
  }
}

function onWorkStopped(interactions, threadID) {
  var didCatchError = false;
  var caughtError = null;
  subscribers.forEach(function (subscriber) {
    try {
      subscriber.onWorkStopped(interactions, threadID);
    } catch (error) {
      if (!didCatchError) {
        didCatchError = true;
        caughtError = error;
      }
    }
  });

  if (didCatchError) {
    throw caughtError;
  }
}

function onWorkCanceled(interactions, threadID) {
  var didCatchError = false;
  var caughtError = null;
  subscribers.forEach(function (subscriber) {
    try {
      subscriber.onWorkCanceled(interactions, threadID);
    } catch (error) {
      if (!didCatchError) {
        didCatchError = true;
        caughtError = error;
      }
    }
  });

  if (didCatchError) {
    throw caughtError;
  }
}

exports.unstable_clear = unstable_clear;
exports.unstable_getCurrent = unstable_getCurrent;
exports.unstable_getThreadID = unstable_getThreadID;
exports.unstable_subscribe = unstable_subscribe;
exports.unstable_trace = unstable_trace;
exports.unstable_unsubscribe = unstable_unsubscribe;
exports.unstable_wrap = unstable_wrap;
  })();
}


/***/ }),

/***/ "./node_modules/scheduler/cjs/scheduler.development.js":
/*!*************************************************************!*\
  !*** ./node_modules/scheduler/cjs/scheduler.development.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
/** @license React v0.20.2
 * scheduler.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



if (true) {
  (function() {
'use strict';

var enableSchedulerDebugging = false;
var enableProfiling = false;

var requestHostCallback;
var requestHostTimeout;
var cancelHostTimeout;
var requestPaint;
var hasPerformanceNow = typeof performance === 'object' && typeof performance.now === 'function';

if (hasPerformanceNow) {
  var localPerformance = performance;

  exports.unstable_now = function () {
    return localPerformance.now();
  };
} else {
  var localDate = Date;
  var initialTime = localDate.now();

  exports.unstable_now = function () {
    return localDate.now() - initialTime;
  };
}

if ( // If Scheduler runs in a non-DOM environment, it falls back to a naive
// implementation using setTimeout.
typeof window === 'undefined' || // Check if MessageChannel is supported, too.
typeof MessageChannel !== 'function') {
  // If this accidentally gets imported in a non-browser environment, e.g. JavaScriptCore,
  // fallback to a naive implementation.
  var _callback = null;
  var _timeoutID = null;

  var _flushCallback = function () {
    if (_callback !== null) {
      try {
        var currentTime = exports.unstable_now();
        var hasRemainingTime = true;

        _callback(hasRemainingTime, currentTime);

        _callback = null;
      } catch (e) {
        setTimeout(_flushCallback, 0);
        throw e;
      }
    }
  };

  requestHostCallback = function (cb) {
    if (_callback !== null) {
      // Protect against re-entrancy.
      setTimeout(requestHostCallback, 0, cb);
    } else {
      _callback = cb;
      setTimeout(_flushCallback, 0);
    }
  };

  requestHostTimeout = function (cb, ms) {
    _timeoutID = setTimeout(cb, ms);
  };

  cancelHostTimeout = function () {
    clearTimeout(_timeoutID);
  };

  exports.unstable_shouldYield = function () {
    return false;
  };

  requestPaint = exports.unstable_forceFrameRate = function () {};
} else {
  // Capture local references to native APIs, in case a polyfill overrides them.
  var _setTimeout = window.setTimeout;
  var _clearTimeout = window.clearTimeout;

  if (typeof console !== 'undefined') {
    // TODO: Scheduler no longer requires these methods to be polyfilled. But
    // maybe we want to continue warning if they don't exist, to preserve the
    // option to rely on it in the future?
    var requestAnimationFrame = window.requestAnimationFrame;
    var cancelAnimationFrame = window.cancelAnimationFrame;

    if (typeof requestAnimationFrame !== 'function') {
      // Using console['error'] to evade Babel and ESLint
      console['error']("This browser doesn't support requestAnimationFrame. " + 'Make sure that you load a ' + 'polyfill in older browsers. https://reactjs.org/link/react-polyfills');
    }

    if (typeof cancelAnimationFrame !== 'function') {
      // Using console['error'] to evade Babel and ESLint
      console['error']("This browser doesn't support cancelAnimationFrame. " + 'Make sure that you load a ' + 'polyfill in older browsers. https://reactjs.org/link/react-polyfills');
    }
  }

  var isMessageLoopRunning = false;
  var scheduledHostCallback = null;
  var taskTimeoutID = -1; // Scheduler periodically yields in case there is other work on the main
  // thread, like user events. By default, it yields multiple times per frame.
  // It does not attempt to align with frame boundaries, since most tasks don't
  // need to be frame aligned; for those that do, use requestAnimationFrame.

  var yieldInterval = 5;
  var deadline = 0; // TODO: Make this configurable

  {
    // `isInputPending` is not available. Since we have no way of knowing if
    // there's pending input, always yield at the end of the frame.
    exports.unstable_shouldYield = function () {
      return exports.unstable_now() >= deadline;
    }; // Since we yield every frame regardless, `requestPaint` has no effect.


    requestPaint = function () {};
  }

  exports.unstable_forceFrameRate = function (fps) {
    if (fps < 0 || fps > 125) {
      // Using console['error'] to evade Babel and ESLint
      console['error']('forceFrameRate takes a positive int between 0 and 125, ' + 'forcing frame rates higher than 125 fps is not supported');
      return;
    }

    if (fps > 0) {
      yieldInterval = Math.floor(1000 / fps);
    } else {
      // reset the framerate
      yieldInterval = 5;
    }
  };

  var performWorkUntilDeadline = function () {
    if (scheduledHostCallback !== null) {
      var currentTime = exports.unstable_now(); // Yield after `yieldInterval` ms, regardless of where we are in the vsync
      // cycle. This means there's always time remaining at the beginning of
      // the message event.

      deadline = currentTime + yieldInterval;
      var hasTimeRemaining = true;

      try {
        var hasMoreWork = scheduledHostCallback(hasTimeRemaining, currentTime);

        if (!hasMoreWork) {
          isMessageLoopRunning = false;
          scheduledHostCallback = null;
        } else {
          // If there's more work, schedule the next message event at the end
          // of the preceding one.
          port.postMessage(null);
        }
      } catch (error) {
        // If a scheduler task throws, exit the current browser task so the
        // error can be observed.
        port.postMessage(null);
        throw error;
      }
    } else {
      isMessageLoopRunning = false;
    } // Yielding to the browser will give it a chance to paint, so we can
  };

  var channel = new MessageChannel();
  var port = channel.port2;
  channel.port1.onmessage = performWorkUntilDeadline;

  requestHostCallback = function (callback) {
    scheduledHostCallback = callback;

    if (!isMessageLoopRunning) {
      isMessageLoopRunning = true;
      port.postMessage(null);
    }
  };

  requestHostTimeout = function (callback, ms) {
    taskTimeoutID = _setTimeout(function () {
      callback(exports.unstable_now());
    }, ms);
  };

  cancelHostTimeout = function () {
    _clearTimeout(taskTimeoutID);

    taskTimeoutID = -1;
  };
}

function push(heap, node) {
  var index = heap.length;
  heap.push(node);
  siftUp(heap, node, index);
}
function peek(heap) {
  var first = heap[0];
  return first === undefined ? null : first;
}
function pop(heap) {
  var first = heap[0];

  if (first !== undefined) {
    var last = heap.pop();

    if (last !== first) {
      heap[0] = last;
      siftDown(heap, last, 0);
    }

    return first;
  } else {
    return null;
  }
}

function siftUp(heap, node, i) {
  var index = i;

  while (true) {
    var parentIndex = index - 1 >>> 1;
    var parent = heap[parentIndex];

    if (parent !== undefined && compare(parent, node) > 0) {
      // The parent is larger. Swap positions.
      heap[parentIndex] = node;
      heap[index] = parent;
      index = parentIndex;
    } else {
      // The parent is smaller. Exit.
      return;
    }
  }
}

function siftDown(heap, node, i) {
  var index = i;
  var length = heap.length;

  while (index < length) {
    var leftIndex = (index + 1) * 2 - 1;
    var left = heap[leftIndex];
    var rightIndex = leftIndex + 1;
    var right = heap[rightIndex]; // If the left or right node is smaller, swap with the smaller of those.

    if (left !== undefined && compare(left, node) < 0) {
      if (right !== undefined && compare(right, left) < 0) {
        heap[index] = right;
        heap[rightIndex] = node;
        index = rightIndex;
      } else {
        heap[index] = left;
        heap[leftIndex] = node;
        index = leftIndex;
      }
    } else if (right !== undefined && compare(right, node) < 0) {
      heap[index] = right;
      heap[rightIndex] = node;
      index = rightIndex;
    } else {
      // Neither child is smaller. Exit.
      return;
    }
  }
}

function compare(a, b) {
  // Compare sort index first, then task id.
  var diff = a.sortIndex - b.sortIndex;
  return diff !== 0 ? diff : a.id - b.id;
}

// TODO: Use symbols?
var ImmediatePriority = 1;
var UserBlockingPriority = 2;
var NormalPriority = 3;
var LowPriority = 4;
var IdlePriority = 5;

function markTaskErrored(task, ms) {
}

/* eslint-disable no-var */
// Math.pow(2, 30) - 1
// 0b111111111111111111111111111111

var maxSigned31BitInt = 1073741823; // Times out immediately

var IMMEDIATE_PRIORITY_TIMEOUT = -1; // Eventually times out

var USER_BLOCKING_PRIORITY_TIMEOUT = 250;
var NORMAL_PRIORITY_TIMEOUT = 5000;
var LOW_PRIORITY_TIMEOUT = 10000; // Never times out

var IDLE_PRIORITY_TIMEOUT = maxSigned31BitInt; // Tasks are stored on a min heap

var taskQueue = [];
var timerQueue = []; // Incrementing id counter. Used to maintain insertion order.

var taskIdCounter = 1; // Pausing the scheduler is useful for debugging.
var currentTask = null;
var currentPriorityLevel = NormalPriority; // This is set while performing work, to prevent re-entrancy.

var isPerformingWork = false;
var isHostCallbackScheduled = false;
var isHostTimeoutScheduled = false;

function advanceTimers(currentTime) {
  // Check for tasks that are no longer delayed and add them to the queue.
  var timer = peek(timerQueue);

  while (timer !== null) {
    if (timer.callback === null) {
      // Timer was cancelled.
      pop(timerQueue);
    } else if (timer.startTime <= currentTime) {
      // Timer fired. Transfer to the task queue.
      pop(timerQueue);
      timer.sortIndex = timer.expirationTime;
      push(taskQueue, timer);
    } else {
      // Remaining timers are pending.
      return;
    }

    timer = peek(timerQueue);
  }
}

function handleTimeout(currentTime) {
  isHostTimeoutScheduled = false;
  advanceTimers(currentTime);

  if (!isHostCallbackScheduled) {
    if (peek(taskQueue) !== null) {
      isHostCallbackScheduled = true;
      requestHostCallback(flushWork);
    } else {
      var firstTimer = peek(timerQueue);

      if (firstTimer !== null) {
        requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);
      }
    }
  }
}

function flushWork(hasTimeRemaining, initialTime) {


  isHostCallbackScheduled = false;

  if (isHostTimeoutScheduled) {
    // We scheduled a timeout but it's no longer needed. Cancel it.
    isHostTimeoutScheduled = false;
    cancelHostTimeout();
  }

  isPerformingWork = true;
  var previousPriorityLevel = currentPriorityLevel;

  try {
    if (enableProfiling) {
      try {
        return workLoop(hasTimeRemaining, initialTime);
      } catch (error) {
        if (currentTask !== null) {
          var currentTime = exports.unstable_now();
          markTaskErrored(currentTask, currentTime);
          currentTask.isQueued = false;
        }

        throw error;
      }
    } else {
      // No catch in prod code path.
      return workLoop(hasTimeRemaining, initialTime);
    }
  } finally {
    currentTask = null;
    currentPriorityLevel = previousPriorityLevel;
    isPerformingWork = false;
  }
}

function workLoop(hasTimeRemaining, initialTime) {
  var currentTime = initialTime;
  advanceTimers(currentTime);
  currentTask = peek(taskQueue);

  while (currentTask !== null && !(enableSchedulerDebugging )) {
    if (currentTask.expirationTime > currentTime && (!hasTimeRemaining || exports.unstable_shouldYield())) {
      // This currentTask hasn't expired, and we've reached the deadline.
      break;
    }

    var callback = currentTask.callback;

    if (typeof callback === 'function') {
      currentTask.callback = null;
      currentPriorityLevel = currentTask.priorityLevel;
      var didUserCallbackTimeout = currentTask.expirationTime <= currentTime;

      var continuationCallback = callback(didUserCallbackTimeout);
      currentTime = exports.unstable_now();

      if (typeof continuationCallback === 'function') {
        currentTask.callback = continuationCallback;
      } else {

        if (currentTask === peek(taskQueue)) {
          pop(taskQueue);
        }
      }

      advanceTimers(currentTime);
    } else {
      pop(taskQueue);
    }

    currentTask = peek(taskQueue);
  } // Return whether there's additional work


  if (currentTask !== null) {
    return true;
  } else {
    var firstTimer = peek(timerQueue);

    if (firstTimer !== null) {
      requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);
    }

    return false;
  }
}

function unstable_runWithPriority(priorityLevel, eventHandler) {
  switch (priorityLevel) {
    case ImmediatePriority:
    case UserBlockingPriority:
    case NormalPriority:
    case LowPriority:
    case IdlePriority:
      break;

    default:
      priorityLevel = NormalPriority;
  }

  var previousPriorityLevel = currentPriorityLevel;
  currentPriorityLevel = priorityLevel;

  try {
    return eventHandler();
  } finally {
    currentPriorityLevel = previousPriorityLevel;
  }
}

function unstable_next(eventHandler) {
  var priorityLevel;

  switch (currentPriorityLevel) {
    case ImmediatePriority:
    case UserBlockingPriority:
    case NormalPriority:
      // Shift down to normal priority
      priorityLevel = NormalPriority;
      break;

    default:
      // Anything lower than normal priority should remain at the current level.
      priorityLevel = currentPriorityLevel;
      break;
  }

  var previousPriorityLevel = currentPriorityLevel;
  currentPriorityLevel = priorityLevel;

  try {
    return eventHandler();
  } finally {
    currentPriorityLevel = previousPriorityLevel;
  }
}

function unstable_wrapCallback(callback) {
  var parentPriorityLevel = currentPriorityLevel;
  return function () {
    // This is a fork of runWithPriority, inlined for performance.
    var previousPriorityLevel = currentPriorityLevel;
    currentPriorityLevel = parentPriorityLevel;

    try {
      return callback.apply(this, arguments);
    } finally {
      currentPriorityLevel = previousPriorityLevel;
    }
  };
}

function unstable_scheduleCallback(priorityLevel, callback, options) {
  var currentTime = exports.unstable_now();
  var startTime;

  if (typeof options === 'object' && options !== null) {
    var delay = options.delay;

    if (typeof delay === 'number' && delay > 0) {
      startTime = currentTime + delay;
    } else {
      startTime = currentTime;
    }
  } else {
    startTime = currentTime;
  }

  var timeout;

  switch (priorityLevel) {
    case ImmediatePriority:
      timeout = IMMEDIATE_PRIORITY_TIMEOUT;
      break;

    case UserBlockingPriority:
      timeout = USER_BLOCKING_PRIORITY_TIMEOUT;
      break;

    case IdlePriority:
      timeout = IDLE_PRIORITY_TIMEOUT;
      break;

    case LowPriority:
      timeout = LOW_PRIORITY_TIMEOUT;
      break;

    case NormalPriority:
    default:
      timeout = NORMAL_PRIORITY_TIMEOUT;
      break;
  }

  var expirationTime = startTime + timeout;
  var newTask = {
    id: taskIdCounter++,
    callback: callback,
    priorityLevel: priorityLevel,
    startTime: startTime,
    expirationTime: expirationTime,
    sortIndex: -1
  };

  if (startTime > currentTime) {
    // This is a delayed task.
    newTask.sortIndex = startTime;
    push(timerQueue, newTask);

    if (peek(taskQueue) === null && newTask === peek(timerQueue)) {
      // All tasks are delayed, and this is the task with the earliest delay.
      if (isHostTimeoutScheduled) {
        // Cancel an existing timeout.
        cancelHostTimeout();
      } else {
        isHostTimeoutScheduled = true;
      } // Schedule a timeout.


      requestHostTimeout(handleTimeout, startTime - currentTime);
    }
  } else {
    newTask.sortIndex = expirationTime;
    push(taskQueue, newTask);
    // wait until the next time we yield.


    if (!isHostCallbackScheduled && !isPerformingWork) {
      isHostCallbackScheduled = true;
      requestHostCallback(flushWork);
    }
  }

  return newTask;
}

function unstable_pauseExecution() {
}

function unstable_continueExecution() {

  if (!isHostCallbackScheduled && !isPerformingWork) {
    isHostCallbackScheduled = true;
    requestHostCallback(flushWork);
  }
}

function unstable_getFirstCallbackNode() {
  return peek(taskQueue);
}

function unstable_cancelCallback(task) {
  // remove from the queue because you can't remove arbitrary nodes from an
  // array based heap, only the first one.)


  task.callback = null;
}

function unstable_getCurrentPriorityLevel() {
  return currentPriorityLevel;
}

var unstable_requestPaint = requestPaint;
var unstable_Profiling =  null;

exports.unstable_IdlePriority = IdlePriority;
exports.unstable_ImmediatePriority = ImmediatePriority;
exports.unstable_LowPriority = LowPriority;
exports.unstable_NormalPriority = NormalPriority;
exports.unstable_Profiling = unstable_Profiling;
exports.unstable_UserBlockingPriority = UserBlockingPriority;
exports.unstable_cancelCallback = unstable_cancelCallback;
exports.unstable_continueExecution = unstable_continueExecution;
exports.unstable_getCurrentPriorityLevel = unstable_getCurrentPriorityLevel;
exports.unstable_getFirstCallbackNode = unstable_getFirstCallbackNode;
exports.unstable_next = unstable_next;
exports.unstable_pauseExecution = unstable_pauseExecution;
exports.unstable_requestPaint = unstable_requestPaint;
exports.unstable_runWithPriority = unstable_runWithPriority;
exports.unstable_scheduleCallback = unstable_scheduleCallback;
exports.unstable_wrapCallback = unstable_wrapCallback;
  })();
}


/***/ }),

/***/ "./node_modules/scheduler/index.js":
/*!*****************************************!*\
  !*** ./node_modules/scheduler/index.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


if (false) {} else {
  module.exports = __webpack_require__(/*! ./cjs/scheduler.development.js */ "./node_modules/scheduler/cjs/scheduler.development.js");
}


/***/ }),

/***/ "./node_modules/scheduler/tracing.js":
/*!*******************************************!*\
  !*** ./node_modules/scheduler/tracing.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


if (false) {} else {
  module.exports = __webpack_require__(/*! ./cjs/scheduler-tracing.development.js */ "./node_modules/scheduler/cjs/scheduler-tracing.development.js");
}


/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js":
/*!****************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js ***!
  \****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var isOldIE = function isOldIE() {
  var memo;
  return function memorize() {
    if (typeof memo === 'undefined') {
      // Test for IE <= 9 as proposed by Browserhacks
      // @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805
      // Tests for existence of standard globals is to allow style-loader
      // to operate correctly into non-standard environments
      // @see https://github.com/webpack-contrib/style-loader/issues/177
      memo = Boolean(window && document && document.all && !window.atob);
    }

    return memo;
  };
}();

var getTarget = function getTarget() {
  var memo = {};
  return function memorize(target) {
    if (typeof memo[target] === 'undefined') {
      var styleTarget = document.querySelector(target); // Special case to return head of iframe instead of iframe itself

      if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {
        try {
          // This will throw an exception if access to iframe is blocked
          // due to cross-origin restrictions
          styleTarget = styleTarget.contentDocument.head;
        } catch (e) {
          // istanbul ignore next
          styleTarget = null;
        }
      }

      memo[target] = styleTarget;
    }

    return memo[target];
  };
}();

var stylesInDom = [];

function getIndexByIdentifier(identifier) {
  var result = -1;

  for (var i = 0; i < stylesInDom.length; i++) {
    if (stylesInDom[i].identifier === identifier) {
      result = i;
      break;
    }
  }

  return result;
}

function modulesToDom(list, options) {
  var idCountMap = {};
  var identifiers = [];

  for (var i = 0; i < list.length; i++) {
    var item = list[i];
    var id = options.base ? item[0] + options.base : item[0];
    var count = idCountMap[id] || 0;
    var identifier = "".concat(id, " ").concat(count);
    idCountMap[id] = count + 1;
    var index = getIndexByIdentifier(identifier);
    var obj = {
      css: item[1],
      media: item[2],
      sourceMap: item[3]
    };

    if (index !== -1) {
      stylesInDom[index].references++;
      stylesInDom[index].updater(obj);
    } else {
      stylesInDom.push({
        identifier: identifier,
        updater: addStyle(obj, options),
        references: 1
      });
    }

    identifiers.push(identifier);
  }

  return identifiers;
}

function insertStyleElement(options) {
  var style = document.createElement('style');
  var attributes = options.attributes || {};

  if (typeof attributes.nonce === 'undefined') {
    var nonce =  true ? __webpack_require__.nc : 0;

    if (nonce) {
      attributes.nonce = nonce;
    }
  }

  Object.keys(attributes).forEach(function (key) {
    style.setAttribute(key, attributes[key]);
  });

  if (typeof options.insert === 'function') {
    options.insert(style);
  } else {
    var target = getTarget(options.insert || 'head');

    if (!target) {
      throw new Error("Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.");
    }

    target.appendChild(style);
  }

  return style;
}

function removeStyleElement(style) {
  // istanbul ignore if
  if (style.parentNode === null) {
    return false;
  }

  style.parentNode.removeChild(style);
}
/* istanbul ignore next  */


var replaceText = function replaceText() {
  var textStore = [];
  return function replace(index, replacement) {
    textStore[index] = replacement;
    return textStore.filter(Boolean).join('\n');
  };
}();

function applyToSingletonTag(style, index, remove, obj) {
  var css = remove ? '' : obj.media ? "@media ".concat(obj.media, " {").concat(obj.css, "}") : obj.css; // For old IE

  /* istanbul ignore if  */

  if (style.styleSheet) {
    style.styleSheet.cssText = replaceText(index, css);
  } else {
    var cssNode = document.createTextNode(css);
    var childNodes = style.childNodes;

    if (childNodes[index]) {
      style.removeChild(childNodes[index]);
    }

    if (childNodes.length) {
      style.insertBefore(cssNode, childNodes[index]);
    } else {
      style.appendChild(cssNode);
    }
  }
}

function applyToTag(style, options, obj) {
  var css = obj.css;
  var media = obj.media;
  var sourceMap = obj.sourceMap;

  if (media) {
    style.setAttribute('media', media);
  } else {
    style.removeAttribute('media');
  }

  if (sourceMap && typeof btoa !== 'undefined') {
    css += "\n/*# sourceMappingURL=data:application/json;base64,".concat(btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))), " */");
  } // For old IE

  /* istanbul ignore if  */


  if (style.styleSheet) {
    style.styleSheet.cssText = css;
  } else {
    while (style.firstChild) {
      style.removeChild(style.firstChild);
    }

    style.appendChild(document.createTextNode(css));
  }
}

var singleton = null;
var singletonCounter = 0;

function addStyle(obj, options) {
  var style;
  var update;
  var remove;

  if (options.singleton) {
    var styleIndex = singletonCounter++;
    style = singleton || (singleton = insertStyleElement(options));
    update = applyToSingletonTag.bind(null, style, styleIndex, false);
    remove = applyToSingletonTag.bind(null, style, styleIndex, true);
  } else {
    style = insertStyleElement(options);
    update = applyToTag.bind(null, style, options);

    remove = function remove() {
      removeStyleElement(style);
    };
  }

  update(obj);
  return function updateStyle(newObj) {
    if (newObj) {
      if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap) {
        return;
      }

      update(obj = newObj);
    } else {
      remove();
    }
  };
}

module.exports = function (list, options) {
  options = options || {}; // Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
  // tags it will allow on a page

  if (!options.singleton && typeof options.singleton !== 'boolean') {
    options.singleton = isOldIE();
  }

  list = list || [];
  var lastIdentifiers = modulesToDom(list, options);
  return function update(newList) {
    newList = newList || [];

    if (Object.prototype.toString.call(newList) !== '[object Array]') {
      return;
    }

    for (var i = 0; i < lastIdentifiers.length; i++) {
      var identifier = lastIdentifiers[i];
      var index = getIndexByIdentifier(identifier);
      stylesInDom[index].references--;
    }

    var newLastIdentifiers = modulesToDom(newList, options);

    for (var _i = 0; _i < lastIdentifiers.length; _i++) {
      var _identifier = lastIdentifiers[_i];

      var _index = getIndexByIdentifier(_identifier);

      if (stylesInDom[_index].references === 0) {
        stylesInDom[_index].updater();

        stylesInDom.splice(_index, 1);
      }
    }

    lastIdentifiers = newLastIdentifiers;
  };
};

/***/ }),

/***/ "./node_modules/use-async-effect/index.js":
/*!************************************************!*\
  !*** ./node_modules/use-async-effect/index.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var React = __webpack_require__(/*! react */ "./node_modules/react/index.js");

function useAsyncEffect(effect, destroy, inputs) {
  var hasDestroy = typeof destroy === 'function';

  React.useEffect(function () {
    var result;
    var mounted = true;
    var maybePromise = effect(function () {
      return mounted;
    });

    Promise.resolve(maybePromise).then(function (value) {
      result = value;
    });

    return function () {
      mounted = false;

      if (hasDestroy) {
        destroy(result);
      }
    };
  }, hasDestroy ? inputs : destroy);
}

module.exports = useAsyncEffect;
module.exports.useAsyncEffect = useAsyncEffect;


/***/ }),

/***/ "./src/style.css":
/*!***********************!*\
  !*** ./src/style.css ***!
  \***********************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var api = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");
            var content = __webpack_require__(/*! !!../node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[2].use[1]!../node_modules/postcss-loader/src/index.js??ruleSet[1].rules[2].use[2]!./style.css */ "./node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[2].use[1]!./node_modules/postcss-loader/src/index.js??ruleSet[1].rules[2].use[2]!./src/style.css");

            content = content.__esModule ? content.default : content;

            if (typeof content === 'string') {
              content = [[module.id, content, '']];
            }

var options = {};

options.insert = "head";
options.singleton = false;

var update = api(content, options);



module.exports = content.locals || {};

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be in strict mode.
(() => {
"use strict";
/*!**********************************!*\
  !*** ./src/quick-demo/index.tsx ***!
  \**********************************/
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var rainway_sdk__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! rainway-sdk */ "./node_modules/rainway-sdk/dist/index.js");
/* harmony import */ var rainway_sdk__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(rainway_sdk__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react-dom */ "./node_modules/react-dom/index.js");
/* harmony import */ var _style_css__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../style.css */ "./src/style.css");
/* harmony import */ var _style_css__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_style_css__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var use_async_effect__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! use-async-effect */ "./node_modules/use-async-effect/index.js");
/* harmony import */ var use_async_effect__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(use_async_effect__WEBPACK_IMPORTED_MODULE_4__);
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};





const QuickDemo = () => {
    const [runtime, setRuntime] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)();
    const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)("");
    use_async_effect__WEBPACK_IMPORTED_MODULE_4___default()((isAlive) => __awaiter(void 0, void 0, void 0, function* () {
        var _a;
        try {
            const rt = yield rainway_sdk__WEBPACK_IMPORTED_MODULE_0__.RainwayRuntime.initialize({
                apiKey: (_a = new URLSearchParams(window.location.search).get("api_key")) !== null && _a !== void 0 ? _a : "",
                externalId: "web-demo-quick",
                onRuntimeConnectionLost: (error) => {
                    setRuntime(undefined);
                },
                onConnectionRequest: (request) => {
                    request.accept();
                },
                onPeerMessage: () => { },
                onPeerDataChannel: () => { },
                onPeerError: (peer, error) => {
                    console.warn("onPeerError", peer, error);
                },
                onPeerStateChange: (peer, state) => {
                    console.log(`Peer ${peer.peerId} changed states to ${state}`);
                },
                onStreamAnnouncement: () => { },
                onStreamStop: () => { },
                logSink: () => { },
            });
            if (!isAlive())
                return;
            setRuntime(rt);
        }
        catch (e) {
            setError(e.message);
            console.log(e);
        }
    }));
    return (react__WEBPACK_IMPORTED_MODULE_1__.createElement("main", { className: "m-t-8 m-l-8 m-r-8 m-b-8" }, error ? error : runtime ? "Connected." : "Connecting…"));
};
react_dom__WEBPACK_IMPORTED_MODULE_2__.render(react__WEBPACK_IMPORTED_MODULE_1__.createElement(react__WEBPACK_IMPORTED_MODULE_1__.StrictMode, null,
    react__WEBPACK_IMPORTED_MODULE_1__.createElement(QuickDemo, null)), document.getElementById("react-root"));

})();

/******/ })()
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yYWlud2F5LXNkay13ZWItZGVtby8uL3NyYy9zdHlsZS5jc3MiLCJ3ZWJwYWNrOi8vcmFpbndheS1zZGstd2ViLWRlbW8vLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvYXBpLmpzIiwid2VicGFjazovL3JhaW53YXktc2RrLXdlYi1kZW1vLy4vbm9kZV9tb2R1bGVzL29iamVjdC1hc3NpZ24vaW5kZXguanMiLCJ3ZWJwYWNrOi8vcmFpbndheS1zZGstd2ViLWRlbW8vLi9ub2RlX21vZHVsZXMvcmFpbndheS1zZGsvZGlzdC9pbmRleC5qcyIsIndlYnBhY2s6Ly9yYWlud2F5LXNkay13ZWItZGVtby8uL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vY2pzL3JlYWN0LWRvbS5kZXZlbG9wbWVudC5qcyIsIndlYnBhY2s6Ly9yYWlud2F5LXNkay13ZWItZGVtby8uL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vaW5kZXguanMiLCJ3ZWJwYWNrOi8vcmFpbndheS1zZGstd2ViLWRlbW8vLi9ub2RlX21vZHVsZXMvcmVhY3QvY2pzL3JlYWN0LmRldmVsb3BtZW50LmpzIiwid2VicGFjazovL3JhaW53YXktc2RrLXdlYi1kZW1vLy4vbm9kZV9tb2R1bGVzL3JlYWN0L2luZGV4LmpzIiwid2VicGFjazovL3JhaW53YXktc2RrLXdlYi1kZW1vLy4vbm9kZV9tb2R1bGVzL3NjaGVkdWxlci9janMvc2NoZWR1bGVyLXRyYWNpbmcuZGV2ZWxvcG1lbnQuanMiLCJ3ZWJwYWNrOi8vcmFpbndheS1zZGstd2ViLWRlbW8vLi9ub2RlX21vZHVsZXMvc2NoZWR1bGVyL2Nqcy9zY2hlZHVsZXIuZGV2ZWxvcG1lbnQuanMiLCJ3ZWJwYWNrOi8vcmFpbndheS1zZGstd2ViLWRlbW8vLi9ub2RlX21vZHVsZXMvc2NoZWR1bGVyL2luZGV4LmpzIiwid2VicGFjazovL3JhaW53YXktc2RrLXdlYi1kZW1vLy4vbm9kZV9tb2R1bGVzL3NjaGVkdWxlci90cmFjaW5nLmpzIiwid2VicGFjazovL3JhaW53YXktc2RrLXdlYi1kZW1vLy4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvaW5qZWN0U3R5bGVzSW50b1N0eWxlVGFnLmpzIiwid2VicGFjazovL3JhaW53YXktc2RrLXdlYi1kZW1vLy4vbm9kZV9tb2R1bGVzL3VzZS1hc3luYy1lZmZlY3QvaW5kZXguanMiLCJ3ZWJwYWNrOi8vcmFpbndheS1zZGstd2ViLWRlbW8vLi9zcmMvc3R5bGUuY3NzPzllZmQiLCJ3ZWJwYWNrOi8vcmFpbndheS1zZGstd2ViLWRlbW8vd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vcmFpbndheS1zZGstd2ViLWRlbW8vd2VicGFjay9ydW50aW1lL2NvbXBhdCBnZXQgZGVmYXVsdCBleHBvcnQiLCJ3ZWJwYWNrOi8vcmFpbndheS1zZGstd2ViLWRlbW8vd2VicGFjay9ydW50aW1lL2RlZmluZSBwcm9wZXJ0eSBnZXR0ZXJzIiwid2VicGFjazovL3JhaW53YXktc2RrLXdlYi1kZW1vL3dlYnBhY2svcnVudGltZS9oYXNPd25Qcm9wZXJ0eSBzaG9ydGhhbmQiLCJ3ZWJwYWNrOi8vcmFpbndheS1zZGstd2ViLWRlbW8vd2VicGFjay9ydW50aW1lL21ha2UgbmFtZXNwYWNlIG9iamVjdCIsIndlYnBhY2s6Ly9yYWlud2F5LXNkay13ZWItZGVtby8uL3NyYy9xdWljay1kZW1vL2luZGV4LnRzeCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBQTtBQUNBLGtDQUFrQyxtQkFBTyxDQUFDLHFHQUFnRDtBQUMxRjtBQUNBLDhGQUE4RixJQUFJLElBQUksNkNBQTZDLElBQUksMkJBQTJCLElBQUksSUFBSSxrQkFBa0I7QUFDNU07QUFDQSxpQ0FBaUMsZ0RBQWdELDhDQUE4QyxtREFBbUQsb0RBQW9ELHFEQUFxRCwrQkFBK0IsK0JBQStCLCtCQUErQiwrQkFBK0IsK0JBQStCLCtCQUErQiwrQkFBK0IsK0JBQStCLCtCQUErQiwrQkFBK0IsK0JBQStCLCtDQUErQyw2QkFBNkIsNkJBQTZCLDZCQUE2Qiw2QkFBNkIsNkJBQTZCLDZCQUE2Qiw2QkFBNkIsNkJBQTZCLG1EQUFtRCw4QkFBOEIsOEJBQThCLDhCQUE4Qiw4QkFBOEIsOEJBQThCLDhCQUE4Qiw4QkFBOEIsOEJBQThCLDZDQUE2QywyQkFBMkIsMkJBQTJCLDJCQUEyQiwyQkFBMkIsMkJBQTJCLDJCQUEyQiwyQkFBMkIsMkJBQTJCLGlEQUFpRCw4QkFBOEIsK0JBQStCLCtCQUErQiwrQkFBK0IsK0JBQStCLCtCQUErQiwrQkFBK0IsK0JBQStCLCtCQUErQiwrQkFBK0IsK0JBQStCLCtCQUErQiwrQkFBK0IsK0JBQStCLCtCQUErQiwrQkFBK0IsZ0NBQWdDLEdBQUcsYUFBYSxpQkFBaUIsR0FBRywrQ0FBK0MsK0JBQStCLEdBQUcsVUFBVSxnQ0FBZ0MsR0FBRyxVQUFVLGtDQUFrQyxHQUFHLFVBQVUsbUNBQW1DLEdBQUcsVUFBVSxnQ0FBZ0MsR0FBRyxVQUFVLGlDQUFpQyxHQUFHLFVBQVUsaUNBQWlDLEdBQUcsVUFBVSxrQ0FBa0MsR0FBRyxVQUFVLCtCQUErQixHQUFHLFVBQVUsZ0NBQWdDLEdBQUcsVUFBVSxrQ0FBa0MsR0FBRyxVQUFVLG1DQUFtQyxHQUFHLFVBQVUsZ0NBQWdDLEdBQUcsVUFBVSxpQ0FBaUMsR0FBRyxVQUFVLGlDQUFpQyxHQUFHLFVBQVUsa0NBQWtDLEdBQUcsVUFBVSwrQkFBK0IsR0FBRyxVQUFVLGdDQUFnQyxHQUFHLFVBQVUsa0NBQWtDLEdBQUcsVUFBVSxtQ0FBbUMsR0FBRyxVQUFVLGdDQUFnQyxHQUFHLFVBQVUsaUNBQWlDLEdBQUcsVUFBVSxpQ0FBaUMsR0FBRyxVQUFVLGtDQUFrQyxHQUFHLFdBQVcsZ0NBQWdDLEdBQUcsV0FBVyxpQ0FBaUMsR0FBRyxXQUFXLG1DQUFtQyxHQUFHLFdBQVcsb0NBQW9DLEdBQUcsV0FBVyxpQ0FBaUMsR0FBRyxXQUFXLGtDQUFrQyxHQUFHLFdBQVcsa0NBQWtDLEdBQUcsV0FBVyxtQ0FBbUMsR0FBRyxXQUFXLGdDQUFnQyxHQUFHLFdBQVcsaUNBQWlDLEdBQUcsV0FBVyxtQ0FBbUMsR0FBRyxXQUFXLG9DQUFvQyxHQUFHLFdBQVcsaUNBQWlDLEdBQUcsV0FBVyxrQ0FBa0MsR0FBRyxXQUFXLGtDQUFrQyxHQUFHLFdBQVcsbUNBQW1DLEdBQUcsV0FBVyxnQ0FBZ0MsR0FBRyxXQUFXLGlDQUFpQyxHQUFHLFdBQVcsbUNBQW1DLEdBQUcsV0FBVyxvQ0FBb0MsR0FBRyxXQUFXLGlDQUFpQyxHQUFHLFdBQVcsa0NBQWtDLEdBQUcsV0FBVyxrQ0FBa0MsR0FBRyxXQUFXLG1DQUFtQyxHQUFHLFdBQVcsZ0NBQWdDLEdBQUcsV0FBVyxpQ0FBaUMsR0FBRyxXQUFXLG1DQUFtQyxHQUFHLFdBQVcsb0NBQW9DLEdBQUcsV0FBVyxpQ0FBaUMsR0FBRyxXQUFXLGtDQUFrQyxHQUFHLFdBQVcsa0NBQWtDLEdBQUcsV0FBVyxtQ0FBbUMsR0FBRyxXQUFXLGdDQUFnQyxHQUFHLFdBQVcsaUNBQWlDLEdBQUcsV0FBVyxtQ0FBbUMsR0FBRyxXQUFXLG9DQUFvQyxHQUFHLFdBQVcsaUNBQWlDLEdBQUcsV0FBVyxrQ0FBa0MsR0FBRyxXQUFXLGtDQUFrQyxHQUFHLFdBQVcsbUNBQW1DLEdBQUcsV0FBVyxnQ0FBZ0MsR0FBRyxXQUFXLGlDQUFpQyxHQUFHLFdBQVcsbUNBQW1DLEdBQUcsV0FBVyxvQ0FBb0MsR0FBRyxXQUFXLGlDQUFpQyxHQUFHLFdBQVcsa0NBQWtDLEdBQUcsV0FBVyxrQ0FBa0MsR0FBRyxXQUFXLG1DQUFtQyxHQUFHLFdBQVcsZ0NBQWdDLEdBQUcsV0FBVyxpQ0FBaUMsR0FBRyxXQUFXLG1DQUFtQyxHQUFHLFdBQVcsb0NBQW9DLEdBQUcsV0FBVyxpQ0FBaUMsR0FBRyxXQUFXLGtDQUFrQyxHQUFHLFdBQVcsa0NBQWtDLEdBQUcsV0FBVyxtQ0FBbUMsR0FBRyxXQUFXLGdDQUFnQyxHQUFHLFdBQVcsaUNBQWlDLEdBQUcsV0FBVyxtQ0FBbUMsR0FBRyxXQUFXLG9DQUFvQyxHQUFHLFdBQVcsaUNBQWlDLEdBQUcsV0FBVyxrQ0FB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QTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBOzs7QUFHQSxvQkFBb0I7O0FBRXBCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFFO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsRUFBRTtBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFFO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsRUFBRTs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLEVBQUU7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFFO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFFOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsRUFBRTs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7O0FBRUE7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFFOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLEVBQUU7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsRUFBRTtBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFFO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFdBQVc7QUFDdEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsRUFBRTtBQUNiOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOzs7QUFHSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7OztBQUdIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQzs7QUFFdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7O0FBRVI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFROztBQUVSO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0EsU0FBUztBQUNULHdCQUF3QjtBQUN4QjtBQUNBLFNBQVM7QUFDVCx3QkFBd0I7QUFDeEI7QUFDQSxTQUFTO0FBQ1QseUJBQXlCO0FBQ3pCO0FBQ0EsU0FBUztBQUNULHlCQUF5QjtBQUN6QjtBQUNBLFNBQVM7QUFDVCxrQ0FBa0M7QUFDbEM7QUFDQSxTQUFTO0FBQ1QsNEJBQTRCO0FBQzVCO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLOzs7QUFHTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMERBQTBEOztBQUUxRDtBQUNBOztBQUVBO0FBQ0Esd0RBQXdEO0FBQ3hEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFROzs7QUFHUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxZQUFZLGtCQUFrQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjs7O0FBR2pCO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOzs7QUFHSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxFQUFFO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7O0FBR0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlDQUFpQztBQUNqQzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCOztBQUVBO0FBQ0E7QUFDQSx5REFBeUQ7QUFDekQ7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGlFQUFpRTtBQUNqRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQSxtQkFBbUIsa0JBQWtCO0FBQ3JDOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSw4QkFBOEI7QUFDOUI7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOzs7QUFHQSxzQ0FBc0M7QUFDdEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7OztBQUdMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIsMkJBQTJCO0FBQzlDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CLDJCQUEyQjtBQUM5QztBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CLHFCQUFxQjtBQUN6Qzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBOztBQUVBLHFCQUFxQixzQkFBc0I7QUFDM0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsaUNBQWlDOztBQUVqQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQzs7QUFFbkM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7O0FBRUEscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOzs7QUFHSDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxXQUFXO0FBQ3RCLFdBQVcsT0FBTztBQUNsQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsV0FBVztBQUN0QixXQUFXLE9BQU87QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNs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QTtBQUNBLDRFQUE0RSxZQUFZO0FBQ3hGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwySEFBMkgsNkJBQTZCO0FBQ3hKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtGQUFrRjtBQUNsRjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPLDBDQUEwQzs7O0FBR2pEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLCtGQUErRjtBQUMvRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPLDBDQUEwQzs7O0FBR2pEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7O0FBR0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7OztBQUdMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDZFQUE2RTs7QUFFN0U7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzSkFBc0osaUJBQWlCO0FBQ3ZLLE9BQU87QUFDUCxzSkFBc0osaUJBQWlCLHdEQUF3RCxtQkFBbUIsZ0JBQWdCLDhCQUE4QjtBQUNoUzs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMOzs7QUFHQTtBQUNBO0FBQ0EsS0FBSzs7O0FBR0w7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7O0FBR0w7QUFDQSxvR0FBb0csR0FBRzs7QUFFdkc7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixZQUFZLGVBQWU7QUFDM0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esc0VBQXNFOztBQUV0RTtBQUNBO0FBQ0EsR0FBRztBQUNIOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDZDQUE2Qzs7QUFFN0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CLDBCQUEwQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsWUFBWSxVQUFVO0FBQ3RCOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsMENBQTBDO0FBQzFDOztBQUVBO0FBQ0E7QUFDQSxxQkFBcUI7O0FBRXJCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDBCQUEwQjtBQUMxQjtBQUNBOztBQUVBLHFDQUFxQztBQUNyQzs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FO0FBQ25FO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQSxnQkFBZ0I7O0FBRWhCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsZ0JBQWdCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLE9BQU87OztBQUdQLHVFQUF1RTs7QUFFdkU7QUFDQSw4REFBOEQ7QUFDOUQ7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBLE9BQU87OztBQUdQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSx1QkFBdUI7O0FBRXZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsU0FBUztBQUNwQixXQUFXLEVBQUU7QUFDYixXQUFXLEtBQUs7QUFDaEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsRUFBRTtBQUNiLFdBQVcsS0FBSztBQUNoQjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7O0FBR1A7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE9BQU87QUFDUDs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7OztBQUdIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOzs7QUFHSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7OztBQUdIOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Qsc0NBQXNDOztBQUV0Qyw4QkFBOEI7QUFDOUI7O0FBRUE7QUFDQTtBQUNBLHVCQUF1Qjs7QUFFdkI7QUFDQSxzQ0FBc0M7O0FBRXRDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFdBQVc7QUFDWDtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0EseUVBQXlFO0FBQ3pFOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7O0FBR0w7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQ0FBb0M7O0FBRXBDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOzs7QUFHUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7O0FBR0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0VBQW9FO0FBQ3BFO0FBQ0E7O0FBRUEsbUJBQW1CLGlDQUFpQztBQUNwRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGtCQUFrQiw0Q0FBNEM7QUFDOUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7O0FBR0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsYUFBYTtBQUNiOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0EseVpBQXlaOztBQUV6WjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQix1QkFBdUI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLHVCQUF1QjtBQUN4QztBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtREFBbUQ7QUFDbkQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjs7QUFFdEI7QUFDQSxvQ0FBb0M7O0FBRXBDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7OztBQUdIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQzs7QUFFckM7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOzs7QUFHQSxzRUFBc0U7QUFDdEU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQztBQUNEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOztBQUVBO0FBQ0E7QUFDQTtBQUNB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QUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUNBQW1DO0FBQ25DO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9DQUFvQztBQUNwQztBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwwQ0FBMEM7QUFDMUM7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFlBQVksT0FBTztBQUNuQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOzs7QUFHSDtBQUNBLGlEQUFpRDtBQUNqRDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUEsbUNBQW1DOztBQUVuQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBOzs7QUFHQSwrRUFBK0U7QUFDL0U7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7OztBQUdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixZQUFZO0FBQ1o7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixZQUFZO0FBQ1o7OztBQUdBO0FBQ0E7QUFDQSxDQUFDOzs7QUFHRDtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQjs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNkdBQTZHO0FBQzdHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7O0FBR0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxVQUFVOztBQUVWO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7OztBQUdILGlCQUFpQixrQkFBa0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHVCQUF1QjtBQUNsQyxZQUFZO0FBQ1o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyx1QkFBdUI7QUFDbEMsWUFBWTtBQUNaOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsdUJBQXVCO0FBQ2xDLFdBQVcsT0FBTztBQUNsQixZQUFZO0FBQ1o7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLFdBQVc7QUFDdEIsWUFBWTtBQUNaOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFdBQVc7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87OztBQUdQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOzs7QUFHTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsdUJBQXVCO0FBQ2xDLFdBQVcsT0FBTztBQUNsQjs7QUFFQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDhFQUE4RTtBQUM5RTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOzs7QUFHTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIsc0JBQXNCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFlBQVk7QUFDWjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOzs7QUFHSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUIsMEJBQTBCO0FBQzNDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDJCQUEyQjtBQUMzQjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw0REFBNEQ7QUFDNUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsK0NBQStDO0FBQy9DOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxxREFBcUQ7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7O0FBR0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsNEJBQTRCO0FBQ2pEO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaURBQWlEO0FBQ2pEOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtREFBbUQ7QUFDbkQ7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLG1EQUFtRDtBQUNuRDs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUssMkVBQTJFLG9HQUFvRyxrQ0FBa0M7QUFDdE47QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTOzs7QUFHVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSyxvR0FBb0c7QUFDekc7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtFQUFrRTs7QUFFbEUsOEZBQThGO0FBQzlGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOzs7QUFHSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLDRCQUE0QjtBQUNqRDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNkNBQTZDO0FBQzdDOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLCtDQUErQztBQUMvQzs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBLCtDQUErQztBQUMvQzs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0Isd0JBQXdCO0FBQzVDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUNBQXFDO0FBQ3JDO0FBQ0EsK0VBQStFO0FBQy9FO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDOztBQUU5QztBQUNBLGFBQWE7OztBQUdiO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RDtBQUN6RDtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBLDB2QkFBMHZCOztBQUUxdkI7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DOztBQUVwQyx1REFBdUQ7O0FBRXZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQ0FBaUM7O0FBRWpDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDOztBQUV6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7O0FBR0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7O0FBR0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUSxjQUFjO0FBQ3RCOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0Q7QUFDdEQ7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOzs7QUFHSDtBQUNBLENBQUM7QUFDRDtBQUNBOztBQUVBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssK0NBQStDO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLCtDQUErQztBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7OztBQUdBLHlFQUF5RTtBQUN6RTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBIQUEwSDtBQUMxSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBOztBQUVBLG1FQUFtRTs7QUFFbkU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7O0FBR0QsMERBQTBEOztBQUUxRCxvREFBb0Q7QUFDcEQ7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQ7QUFDbkQ7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUJBQXFCO0FBQ3JCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBOztBQUVBLDBIQUEwSDtBQUMxSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlFQUF5RTtBQUN6RTs7QUFFQTtBQUNBLDhDQUE4Qzs7QUFFOUM7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtRUFBbUU7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOzs7QUFHTDtBQUNBOztBQUVBO0FBQ0Esd0NBQXdDOztBQUV4QztBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7OztBQUdIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwwQkFBMEI7QUFDMUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qjs7QUFFeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7O0FBRTNCO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLG1CQUFtQjtBQUNuQzs7QUFFQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFNBQVM7OztBQUdUO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CO0FBQ25COztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4REFBOEQ7QUFDOUQscURBQXFEO0FBQ3JELDJEQUEyRDtBQUMzRCwyQ0FBMkM7QUFDM0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFEOztBQUVyRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDhDQUE4Qzs7QUFFOUM7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7O0FBR0w7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCOztBQUUxQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkJBQTJCOztBQUUzQjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsOERBQThEOztBQUU5RCwyREFBMkQ7QUFDM0Q7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7O0FBR1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87OztBQUdQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtREFBbUQseURBQXlEO0FBQzVHLDZCQUE2Qjs7QUFFN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOzs7QUFHUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDOztBQUV6Qzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTLHlCQUF5Qjs7O0FBR2xDO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7OztBQUdIOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFNBQVM7OztBQUdUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOzs7QUFHVCx5QkFBeUI7QUFDekI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNENBQTRDOztBQUU1Qzs7QUFFQTtBQUNBLGdDQUFnQztBQUNoQzs7QUFFQTtBQUNBO0FBQ0Esa0NBQWtDOztBQUVsQztBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUEsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7OztBQUdIO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7OztBQUdUO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOzs7QUFHVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsZ0RBQWdEO0FBQ2hEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQixvQkFBb0I7QUFDdkM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDRCQUE0QjtBQUM1Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOzs7QUFHSCxrR0FBa0c7QUFDbEcsK0NBQStDO0FBQy9DOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNDQUFzQzs7QUFFdEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw2SUFBNkk7O0FBRTdJO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Qsa0VBQWtFLDRDQUE0QztBQUM5Rzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7O0FBR0g7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUNBQWlDO0FBQ2pDLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7O0FBR0E7QUFDQSxxREFBcUQ7QUFDckQ7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0lBQWtJO0FBQ2xJO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7OztBQUdBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrSUFBa0k7QUFDbEk7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7OztBQUdBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0NBQW9DOztBQUVwQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhKQUE4Six5Q0FBeUM7QUFDdk07QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOzs7QUFHTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFCQUFxQix3QkFBd0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFVBQVUsa0RBQWtEO0FBQzVEO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksNkJBQTZCO0FBQ3pDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7O0FBR0wsdUVBQXVFOztBQUV2RSxVQUFVLDZCQUE2QjtBQUN2Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPOzs7QUFHUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE9BQU87QUFDUDs7O0FBR0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxjQUFjLGFBQWE7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFVBQVUsaUNBQWlDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksWUFBWTtBQUN4Qjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEtBQUs7OztBQUdMLHVFQUF1RTs7QUFFdkUsVUFBVSxZQUFZO0FBQ3RCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTOzs7QUFHVDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLE1BQU07QUFDbkQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7O0FBR0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7O0FBR0w7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQ7QUFDekQ7O0FBRUEsOENBQThDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNkRBQTZEOztBQUU3RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQ7O0FBRTdEO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7O0FBRUEsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx1Q0FBdUM7QUFDdkM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSwyQ0FBMkM7O0FBRTNDO0FBQ0E7QUFDQSxHQUFHOzs7QUFHSDtBQUNBO0FBQ0EsR0FBRztBQUNIOzs7QUFHQTtBQUNBO0FBQ0EsR0FBRzs7O0FBR0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsNEhBQTRIOztBQUU1SCxvQ0FBb0M7QUFDcEM7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsa0NBQWtDO0FBQ25EOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMEJBQTBCO0FBQzFCOztBQUVBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4QkFBOEI7QUFDOUIsbURBQW1EO0FBQ25EO0FBQ0E7O0FBRUEseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHlCQUF5Qjs7QUFFekIsZ0NBQWdDO0FBQ2hDO0FBQ0E7O0FBRUE7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSx1QkFBdUIsOEJBQThCO0FBQ3JEO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCLDRDQUE0QztBQUM3RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUNBQWlDOztBQUVqQztBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBLDZDQUE2Qzs7QUFFN0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7O0FBR1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDRCQUE0Qjs7QUFFNUIsb0NBQW9DOztBQUVwQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOzs7QUFHVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHNDQUFzQztBQUN0Qzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssMkNBQTJDO0FBQ2hEOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUEsa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkNBQTJDOztBQUUzQyxxQ0FBcUM7QUFDckM7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0RBQW9EOztBQUVwRDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUEsaUNBQWlDO0FBQ2pDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTs7QUFFQSxtQ0FBbUM7O0FBRW5DOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOzs7QUFHQTtBQUNBO0FBQ0EsR0FBRyxvQ0FBb0M7O0FBRXZDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNkRBQTZEOztBQUU3RDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHLHVCQUF1QjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0EseUtBQXlLLDBDQUEwQztBQUNuTjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7O0FBR0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOzs7QUFHSDtBQUNBO0FBQ0E7O0FBRUEsOENBQThDO0FBQzlDO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxRUFBcUU7QUFDckU7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLGdCQUFnQjtBQUN6QixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnR0FBZ0c7QUFDaEc7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLCtCQUErQjs7QUFFL0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7O0FBR0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1DQUFtQzs7QUFFbkM7QUFDQTtBQUNBO0FBQ0EsK0NBQStDOztBQUUvQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7OztBQUdIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUzs7O0FBR1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87OztBQUdQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRDtBQUNoRDs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlEOztBQUVqRDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQSx5RUFBeUU7O0FBRXpFO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7O0FBR0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDOztBQUV0QztBQUNBLEtBQUs7OztBQUdMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsMENBQTBDOztBQUUxQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7O0FBR0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIOzs7QUFHQSxnREFBZ0Q7O0FBRWhEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdUJBQXVCLDRDQUE0QztBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7O0FBRXBDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7O0FBRWhDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQzs7QUFFcEM7QUFDQSxHQUFHOzs7QUFHSCxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7O0FBRXBDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOzs7QUFHSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOzs7QUFHTCx3Q0FBd0M7O0FBRXhDO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7OztBQUdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7OztBQUdIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4Q0FBOEM7O0FBRTlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdURBQXVEO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVEO0FBQ3ZEOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzREFBc0Q7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnR0FBZ0c7QUFDaEc7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRDtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNILCtGQUErRjtBQUMvRjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1DQUFtQzs7QUFFbkM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEseU5BQXlOLEdBQUc7O0FBRTVOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHFCQUFxQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0IsWUFBWTtBQUM5QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDJDQUEyQzs7QUFFM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7OztBQUdYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOzs7QUFHSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwrQ0FBK0M7O0FBRS9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMOzs7QUFHQTtBQUNBLHVDQUF1Qzs7QUFFdkM7QUFDQTtBQUNBO0FBQ0Esa0RBQWtEOztBQUVsRDtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0EseUNBQXlDOztBQUV6QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsK0JBQStCO0FBQy9CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWE7QUFDYjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQSxtSEFBbUg7QUFDbkg7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBOzs7QUFHQTtBQUNBLGFBQWE7QUFDYjtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQ7O0FBRTVEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU8sb0NBQW9DO0FBQzNDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1EQUFtRDtBQUNuRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7OztBQUdBO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0E7O0FBRUEscUhBQXFIOztBQUVySCwrQ0FBK0M7QUFDL0M7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUztBQUNUOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTO0FBQ1Q7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7OztBQUdiO0FBQ0E7O0FBRUEsb0RBQW9EO0FBQ3BEO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxnREFBZ0Q7QUFDaEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOENBQThDO0FBQzlDOztBQUVBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw2Q0FBNkM7O0FBRTdDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RDtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUEscUVBQXFFOztBQUVyRSxnRUFBZ0U7QUFDaEU7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQ7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxXQUFXOztBQUVYLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVDQUF1QztBQUN2Qzs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvREFBb0Q7O0FBRXBEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRkFBc0Y7O0FBRXRGO0FBQ0E7QUFDQSxtQkFBbUI7OztBQUduQjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQ7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTs7QUFFQSwrREFBK0Q7O0FBRS9EO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSx1RUFBdUU7O0FBRXZFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDJDQUEyQztBQUMzQzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esd0RBQXdEO0FBQ3hEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxRQUFRLElBQUk7QUFDWjtBQUNBO0FBQ0EsdURBQXVEO0FBQ3ZEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7O0FBR0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUEsZ0hBQWdIO0FBQ2hIO0FBQ0E7QUFDQTs7QUFFQSx3Q0FBd0M7QUFDeEMsS0FBSyxNQUFNLEVBS047QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSwrQ0FBK0M7O0FBRS9DLDZCQUE2QjtBQUM3Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qzs7QUFFOUM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQ0FBa0M7O0FBRWxDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxSEFBcUg7O0FBRXJIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLDREQUE0RDtBQUM1RDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDs7O0FBR0Esc0VBQXNFOztBQUV0RTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOzs7QUFHQTtBQUNBLEtBQUssa0NBQWtDO0FBQ3ZDOzs7QUFHQTtBQUNBLEdBQUc7QUFDSDtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLHlFQUF5RTs7QUFFekU7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FB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OztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNDQUFzQztBQUN0Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOzs7QUFHQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7OztBQUdMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0EscURBQXFEOztBQUVyRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLDZCQUE2Qjs7QUFFN0I7QUFDQTs7QUFFQSw0Q0FBNEM7QUFDNUM7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRywrQkFBK0I7QUFDbEM7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUcsK0JBQStCO0FBQ2xDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7O0FBRUEsbUNBQW1DOztBQUVuQztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSwrQ0FBK0M7QUFDL0M7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87O0FBRVAsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDOztBQUV4QztBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCx3Q0FBd0M7O0FBRXhDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BEO0FBQ0E7O0FBRUE7QUFDQSx1Q0FBdUM7O0FBRXZDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlEQUFpRDtBQUNqRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUM7QUFDRDtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjs7QUFFdEIsaUNBQWlDOztBQUVqQyw4QkFBOEI7O0FBRTlCLDBCQUEwQjs7QUFFMUIsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EscURBQXFEOztBQUVyRCxrREFBa0Q7O0FBRWxELHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7O0FBRUEsOENBQThDO0FBQzlDOztBQUVBLDZDQUE2Qzs7QUFFN0MsNkNBQTZDOztBQUU3QztBQUNBLG1DQUFtQztBQUNuQzs7QUFFQTtBQUNBLCtCQUErQjtBQUMvQjs7QUFFQSxrREFBa0Q7QUFDbEQ7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDOztBQUUzQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQ0FBbUM7QUFDbkM7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7O0FBR0g7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7O0FBR0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDs7O0FBR0Esb0RBQW9EO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7OztBQUdIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7OztBQUdIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7OztBQUdMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOzs7QUFHSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQSwrQ0FBK0M7QUFDL0M7O0FBRUEsK0NBQStDOztBQUUvQyw0R0FBNEc7O0FBRTVHOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7O0FBR0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7OztBQUdBO0FBQ0EsR0FBRzs7O0FBR0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSwwQ0FBMEM7QUFDMUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyRkFBMkY7O0FBRTNGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOzs7QUFHVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtRUFBbUU7OztBQUduRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOzs7QUFHVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0NBQXdDO0FBQ3hDOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25COztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUEsZ0NBQWdDO0FBQ2hDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7OztBQUdIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTCw4Q0FBOEM7QUFDOUM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7O0FBRW5DO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsMERBQTBEO0FBQzFEO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRDtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBLEtBQUs7OztBQUdMO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBLEdBQUc7OztBQUdIO0FBQ0EsNENBQTRDOztBQUU1QztBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7O0FBRTNDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0Esd0VBQXdFOztBQUV4RTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQSx3Q0FBd0M7QUFDeEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsNENBQTRDOzs7QUFHNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1RUFBdUU7O0FBRXZFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOzs7QUFHTCxnQ0FBZ0M7O0FBRWhDO0FBQ0EsR0FBRyxnQ0FBZ0M7OztBQUduQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDhCQUE4Qjs7QUFFOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQ7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsNENBQTRDO0FBQy9DOzs7QUFHQSwyQkFBMkI7QUFDM0I7O0FBRUE7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOzs7QUFHSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLGtEQUFrRDs7QUFFbEQsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssNkJBQTZCOzs7QUFHbEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOzs7QUFHTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTCx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBOztBQUVBLGdDQUFnQztBQUNoQztBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMLHNCQUFzQjtBQUN0Qjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOzs7QUFHSCxxQ0FBcUM7O0FBRXJDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsdUJBQXVCLDRCQUE0QjtBQUNuRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0EsR0FBRzs7O0FBR0g7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDOztBQUVBLHlDQUF5Qzs7QUFFekM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EseUNBQXlDOztBQUV6QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0RBQWdEO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGlCQUFpQiwyQkFBMkI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOzs7QUFHSDtBQUNBOztBQUVBLGtCQUFrQiwwQkFBMEI7QUFDNUM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0EsMkNBQTJDOztBQUUzQzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyQkFBMkI7QUFDM0I7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSx3QkFBd0I7QUFDckM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOzs7QUFHSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCOztBQUV6Qjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7OztBQUdBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUEsbUNBQW1DO0FBQ25DOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE9BQU8sNENBQTRDO0FBQ25EOzs7QUFHQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBOztBQUVBLHdDQUF3Qzs7QUFFeEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7O0FBR1A7O0FBRUE7QUFDQSw2Q0FBNkM7QUFDN0M7O0FBRUE7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4R0FBOEc7O0FBRTlHOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixJQUFJLGtDQUFrQyxtQ0FBbUM7QUFDMUYsNERBQTRELGNBQWMsSUFBSSxnQkFBZ0IsbUNBQW1DO0FBQ2pJLE9BQU87QUFDUDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlNQUFpTSxvREFBb0QsRUFBRTtBQUN2UDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSw4TEFBOEwsb0RBQW9ELEVBQUU7QUFDcFAsT0FBTztBQUNQO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdGQUFnRjs7QUFFaEYsMENBQTBDO0FBQzFDO0FBQ0EsMEJBQTBCO0FBQzFCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwrRUFBK0U7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0wsNkRBQTZEOztBQUU3RDtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUcsRUFBRTtBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHlCQUF5Qjs7QUFFekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOzs7QUFHTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOzs7QUFHTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQ0FBZ0M7O0FBRWhDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7O0FBR0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7O0FBR0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSx5REFBeUQ7QUFDekQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qjs7QUFFeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7O0FBRW5CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSCwrQ0FBK0M7O0FBRS9DLHVDQUF1QztBQUN2Qzs7QUFFQSxtQ0FBbUM7O0FBRW5DO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRDtBQUNuRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7O0FBRXBDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQ7O0FBRXJELHVDQUF1QztBQUN2Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7O0FBRXhDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDJFQUEyRTs7QUFFM0U7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esc0VBQXNFO0FBQ3RFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1RUFBdUU7QUFDdkU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBFQUEwRTtBQUMxRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RDs7QUFFN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtEQUFrRDtBQUNsRDs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSx5RUFBeUU7QUFDekU7QUFDQTs7QUFFQSw2Q0FBNkM7QUFDN0M7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7QUFHRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLCtEQUErRDs7QUFFL0Q7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOzs7QUFHTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwrREFBK0Q7O0FBRS9EO0FBQ0Esa0NBQWtDOztBQUVsQzs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0wscUJBQXFCLHdCQUF3QjtBQUM3QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwrREFBK0QsT0FBTzs7QUFFdEU7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CLDJCQUEyQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUZBQW1GOztBQUVuRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7OztBQUdMO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7O0FBR0w7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsaU1BQWlNLGNBQWM7QUFDL007QUFDQSxHQUFHOzs7QUFHSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOzs7QUFHTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUssRUFBRTtBQUNQOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUEsNkVBQTZFOztBQUU3RTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7OztBQUdBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qzs7QUFFOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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O0FBRUE7QUFDQSxtREFBbUQ7O0FBRW5EOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsRUFBRTtBQUNiLFdBQVcsRUFBRTtBQUNi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Q0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssRUFBRTs7QUFFUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCOztBQUUxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7OztBQUdUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjs7QUFFbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBLHlDQUF5QztBQUN6Qzs7QUFFQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUEsbUNBQW1DO0FBQ25DOztBQUVBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsMkJBQTJCOztBQUUzQjtBQUNBO0FBQ0E7QUFDQSxHQUFHOzs7QUFHSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7OztBQUdMO0FBQ0EseUNBQXlDO0FBQ3pDOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7O0FBRXRDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFROztBQUVSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTs7QUFFUjtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBLFNBQVM7QUFDVCx3QkFBd0I7QUFDeEI7QUFDQSxTQUFTO0FBQ1Qsd0JBQXdCO0FBQ3hCO0FBQ0EsU0FBUztBQUNULHlCQUF5QjtBQUN6QjtBQUNBLFNBQVM7QUFDVCx5QkFBeUI7QUFDekI7QUFDQSxTQUFTO0FBQ1Qsa0NBQWtDO0FBQ2xDO0FBQ0EsU0FBUztBQUNULDRCQUE0QjtBQUM1QjtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7O0FBR0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDBEQUEwRDs7QUFFMUQ7QUFDQTs7QUFFQTtBQUNBLDBEQUEwRDtBQUMxRDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTs7O0FBR1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsWUFBWSxrQkFBa0I7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7OztBQUdqQjtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7O0FBR0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBIQUEwSDtBQUMxSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBOztBQUVBLG1FQUFtRTs7QUFFbkU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGFBQWE7QUFDeEIsV0FBVyxFQUFFO0FBQ2I7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDBEQUEwRDtBQUMxRDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCLFdBQVcsRUFBRTtBQUNiOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQixpQkFBaUI7QUFDcEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxhQUFhO0FBQ3hCOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsMkNBQTJDOztBQUUzQzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxhQUFhO0FBQ3hCOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CLGlCQUFpQjtBQUNwQzs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscURBQXFEO0FBQ3JEOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0EsbUJBQW1CLHNCQUFzQjtBQUN6QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOzs7QUFHTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCLHNCQUFzQjtBQUN2QztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLHVDQUF1QztBQUN2Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnQkFBZ0I7QUFDaEIsaUJBQWlCO0FBQ2pCLHFCQUFxQjtBQUNyQiwwREFBMEQ7QUFDMUQsb0JBQW9CO0FBQ3BCLHFCQUFxQjtBQUNyQixxQkFBcUI7QUFDckIscUJBQXFCO0FBQ3JCLGlCQUFpQjtBQUNqQixrQkFBa0I7QUFDbEIsc0JBQXNCO0FBQ3RCLFlBQVk7QUFDWixZQUFZO0FBQ1osbUJBQW1CO0FBQ25CLGtCQUFrQjtBQUNsQixxQkFBcUI7QUFDckIsaUJBQWlCO0FBQ2pCLDJCQUEyQjtBQUMzQix1QkFBdUI7QUFDdkIsZUFBZTtBQUNmLGtCQUFrQjtBQUNsQixjQUFjO0FBQ2QsZ0JBQWdCO0FBQ2hCLGVBQWU7QUFDZixHQUFHO0FBQ0g7Ozs7Ozs7Ozs7OztBQzV4RWE7O0FBRWIsSUFBSSxLQUFxQyxFQUFFLEVBRTFDO0FBQ0QsRUFBRSx1SEFBc0Q7QUFDeEQ7Ozs7Ozs7Ozs7OztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWIsSUFBSSxJQUFxQztBQUN6QztBQUNBOztBQUVBLDBCQUEwQjs7QUFFMUI7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBOztBQUVBLHlCQUF5QixRQUFROztBQUVqQyx1QkFBdUI7O0FBRXZCO0FBQ0EsRUFBRSx5QkFBeUI7QUFDM0I7QUFDQTtBQUNBLEVBQUUsdUJBQXVCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRSxpQ0FBaUM7O0FBRW5DO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsSUFBSSxpQ0FBaUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRDtBQUMzRDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFLGlDQUFpQztBQUNuQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsUUFBUSxpQ0FBaUM7O0FBRXpDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULGdDQUFnQztBQUNoQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7OztBQUdBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBLElBQUksaUNBQWlDO0FBQ3JDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLFNBQVM7QUFDVCxVQUFVLGlDQUFpQzs7QUFFM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBTSwrQkFBK0I7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNLCtCQUErQjtBQUNyQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCO0FBQ3RCLDJCQUEyQjtBQUMzQiw0QkFBNEI7QUFDNUIsMEJBQTBCO0FBQzFCLHNCQUFzQjtBQUN0Qiw0QkFBNEI7QUFDNUIscUJBQXFCO0FBQ3JCLEdBQUc7QUFDSDs7Ozs7Ozs7Ozs7O0FDMVZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWIsSUFBSSxJQUFxQztBQUN6QztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLEVBQUUsb0JBQW9CO0FBQ3RCO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTs7QUFFQSxFQUFFLG9CQUFvQjtBQUN0QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxFQUFFLDRCQUE0QjtBQUM5QjtBQUNBOztBQUVBLGlCQUFpQiwrQkFBK0I7QUFDaEQsQ0FBQztBQUNEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQSw4QkFBOEI7O0FBRTlCO0FBQ0EsbUJBQW1COztBQUVuQjtBQUNBO0FBQ0E7QUFDQSxJQUFJLDRCQUE0QjtBQUNoQztBQUNBLE1BQU07OztBQUdOO0FBQ0E7O0FBRUEsRUFBRSwrQkFBK0I7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDOztBQUVqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLG1DQUFtQzs7QUFFbkMsb0NBQW9DOztBQUVwQztBQUNBO0FBQ0EsaUNBQWlDOztBQUVqQyw4Q0FBOEM7O0FBRTlDO0FBQ0Esb0JBQW9COztBQUVwQixzQkFBc0I7QUFDdEI7QUFDQSwwQ0FBMEM7O0FBRTFDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7O0FBR0g7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFD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RUFBRSxHQUFHLEVBQUUsR0FBRSxDQUFDO2dCQUN0QixPQUFPLEVBQUUsR0FBRyxFQUFFLEdBQUUsQ0FBQzthQUNsQixDQUFDLENBQUM7WUFDSCxJQUFJLENBQUMsT0FBTyxFQUFFO2dCQUFFLE9BQU87WUFDdkIsVUFBVSxDQUFDLEVBQUUsQ0FBQyxDQUFDO1NBQ2hCO1FBQUMsT0FBTyxDQUFDLEVBQUU7WUFDVixRQUFRLENBQUUsQ0FBVyxDQUFDLE9BQU8sQ0FBQyxDQUFDO1lBQy9CLE9BQU8sQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUM7U0FDaEI7SUFDSCxDQUFDLEVBQUMsQ0FBQztJQUNILE9BQU8sQ0FDTCwyREFBTSxTQUFTLEVBQUMseUJBQXlCLElBQ3RDLEtBQUssQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLFlBQVksQ0FBQyxDQUFDLENBQUMsYUFBYSxDQUNsRCxDQUNSLENBQUM7QUFDSixDQUFDLENBQUM7QUFFRiw2Q0FBZSxDQUNiLGlEQUFDLDZDQUFnQjtJQUNmLGlEQUFDLFNBQVMsT0FBRyxDQUNJLEVBQ25CLFFBQVEsQ0FBQyxjQUFjLENBQUMsWUFBWSxDQUFDLENBQ3RDLENBQUMiLCJmaWxlIjoiYnVuZGxlLnF1aWNrLmJlNDNiNTZlOGExNjRmNGQ4Mzg3LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gSW1wb3J0c1xudmFyIF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyA9IHJlcXVpcmUoXCIuLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvYXBpLmpzXCIpO1xuZXhwb3J0cyA9IF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyhmYWxzZSk7XG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCJAaW1wb3J0IHVybChodHRwczovL2ZvbnRzLmdvb2dsZWFwaXMuY29tL2NzczI/ZmFtaWx5PUludGVyOndnaHRANDAwOzUwMDs2MDA7NzAwJmZhbWlseT1RdWVzdHJpYWwmZmFtaWx5PVBvcHBpbnM6d2dodEA0MDA7NTAwOzYwMCZmYW1pbHk9QmFybG93OndnaHRANDAwOzUwMDs2MDA7NzAwJmRpc3BsYXk9c3dhcCk7XCJdKTtcbi8vIE1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiOnJvb3Qge1xcbiAgLS1sb2dvLWZvbnQtZmFtaWx5OiBcXFwiUG9wcGluc1xcXCIsIHNhbnMtc2VyaWY7XFxuICAtLWJvZHktZm9udC1mYW1pbHk6IFxcXCJJbnRlclxcXCIsIHNhbnMtc2VyaWY7XFxuICAtLWhlYWRpbmctZm9udC1mYW1pbHk6IFxcXCJQb3BwaW5zXFxcIiwgc2Fucy1zZXJpZjtcXG4gIC0taGVhZGVyLWZvbnQtZmFtaWx5OiBcXFwiUXVlc3RyaWFsXFxcIiwgc2Fucy1zZXJpZjtcXG5cXG4gIC8qIFNsYXRlIEJsdWUgKi9cXG4gIC0tY2xyLXByaW1hcnktMTAwOiAjZTBlMmY0O1xcbiAgLS1jbHItcHJpbWFyeS0yMDA6ICNiZmMzZWM7XFxuICAtLWNsci1wcmltYXJ5LTMwMDogIzlmYTdlMjtcXG4gIC0tY2xyLXByaW1hcnktNDAwOiAjN2U4OWQ4O1xcbiAgLS1jbHItcHJpbWFyeS01MDA6ICM2MTZhY2I7XFxuICAtLWNsci1wcmltYXJ5LTYwMDogIzQ4NTRiYjtcXG4gIC0tY2xyLXByaW1hcnktNzAwOiAjMzk0M2EyO1xcbiAgLS1jbHItcHJpbWFyeS04MDA6ICMyZjM4ODU7XFxuICAtLWNsci1wcmltYXJ5LTkwMDogIzI0MmI2NztcXG4gIC0tY2xyLXByaW1hcnktOTUwOiAjMTkxZTRkO1xcbiAgLS1jbHItcHJpbWFyeS05NzU6ICMwZjEyMmU7XFxuICAtLWNsci1wcmltYXJ5LTk5OTogIzA1MDYwZjtcXG5cXG4gIC8qIE1hbnRpcyAqL1xcbiAgLS1jbHItZ3JlZW4tMTAwOiAjZjRmYmYwO1xcbiAgLS1jbHItZ3JlZW4tMjAwOiAjZGZmMWQyO1xcbiAgLS1jbHItZ3JlZW4tMzAwOiAjYmZlMmE2O1xcbiAgLS1jbHItZ3JlZW4tNDAwOiAjYTBkNTdiO1xcbiAgLS1jbHItZ3JlZW4tNTAwOiAjOGNjYzYxO1xcbiAgLS1jbHItZ3JlZW4tNjAwOiAjNmZhZDQ1O1xcbiAgLS1jbHItZ3JlZW4tNzAwOiAjNWI4ZDM4O1xcbiAgLS1jbHItZ3JlZW4tODAwOiAjMzM1NzFjO1xcbiAgLS1jbHItZ3JlZW4tOTAwOiAjMWUyZjEyO1xcblxcbiAgLyogRGFuZGVsaW9uICovXFxuICAtLWNsci15ZWxsb3ctMTAwOiAjZmZmZGYxO1xcbiAgLS1jbHIteWVsbG93LTIwMDogI2ZkZjdkYjtcXG4gIC0tY2xyLXllbGxvdy0zMDA6ICNmYWVkYjc7XFxuICAtLWNsci15ZWxsb3ctNDAwOiAjZjdlNjk1O1xcbiAgLS1jbHIteWVsbG93LTUwMDogI2Y5ZGM1YztcXG4gIC0tY2xyLXllbGxvdy02MDA6ICNlNWMzNDM7XFxuICAtLWNsci15ZWxsb3ctNzAwOiAjOWY4MDA0O1xcbiAgLS1jbHIteWVsbG93LTgwMDogIzUwNDEwMjtcXG4gIC0tY2xyLXllbGxvdy05MDA6ICMyODIwMDE7XFxuXFxuICAvKiBUb21hdG8gKi9cXG4gIC0tY2xyLXJlZC0xMDA6ICNmZmY1ZjM7XFxuICAtLWNsci1yZWQtMjAwOiAjZmJkZWQ4O1xcbiAgLS1jbHItcmVkLTMwMDogI2YwYjVhOTtcXG4gIC0tY2xyLXJlZC00MDA6ICNmYTkyN2I7XFxuICAtLWNsci1yZWQtNTAwOiAjZmM2OTQ4O1xcbiAgLS1jbHItcmVkLTYwMDogI2U5NTAyZjtcXG4gIC0tY2xyLXJlZC03MDA6ICNjYjM0MTM7XFxuICAtLWNsci1yZWQtODAwOiAjYTMwMzAzO1xcbiAgLS1jbHItcmVkLTkwMDogIzVjMTExMTtcXG5cXG4gIC8qIE5ldXRyYWxzICovXFxuICAtLWNsci1uZXV0cmFsLTA6ICNmZmZmZmY7XFxuICAtLWNsci1uZXV0cmFsLTUwOiAjZjRmNGY2O1xcbiAgLS1jbHItbmV1dHJhbC0xMDA6ICNlOWU5ZWM7XFxuICAtLWNsci1uZXV0cmFsLTIwMDogI2QzZDNkOTtcXG4gIC0tY2xyLW5ldXRyYWwtMzAwOiAjYjNiM2JjO1xcbiAgLS1jbHItbmV1dHJhbC00MDA6ICM5ZDlkYTk7XFxuICAtLWNsci1uZXV0cmFsLTQ1MDogIzg2ODY5NTtcXG4gIC0tY2xyLW5ldXRyYWwtNTAwOiAjNjg2ODc3O1xcbiAgLS1jbHItbmV1dHJhbC02MDA6ICM1ZjVmNmM7XFxuICAtLWNsci1uZXV0cmFsLTcwMDogIzRjNGM1NjtcXG4gIC0tY2xyLW5ldXRyYWwtODAwOiAjMzkzOTQxO1xcbiAgLS1jbHItbmV1dHJhbC04NTA6ICMyYzJjMzM7XFxuICAtLWNsci1uZXV0cmFsLTkwMDogIzI2MjYyYztcXG4gIC0tY2xyLW5ldXRyYWwtOTI1OiAjMWUxZTIzO1xcbiAgLS1jbHItbmV1dHJhbC05NTA6ICMxMzEzMTY7XFxuICAtLWNsci1uZXV0cmFsLTk3NTogIzA5MDkwYjtcXG4gIC0tY2xyLW5ldXRyYWwtOTkwOiAjMDQwNDA1O1xcbiAgLS1jbHItbmV1dHJhbC0xMDAwOiAjMDAwMDAwO1xcbn1cXG5cXG4uc3BhY2VyIHtcXG4gIGZsZXgtZ3JvdzogMTtcXG59XFxuXFxuLyoqIE1hcmdpbiBhbmQgUGFkZGluZyBoZWxwZXJzICovXFxuLm0tdC0wIHtcXG4gIG1hcmdpbi10b3A6IDBweCAhaW1wb3J0YW50O1xcbn1cXG4ucC10LTAge1xcbiAgcGFkZGluZy10b3A6IDBweCAhaW1wb3J0YW50O1xcbn1cXG4ubS1iLTAge1xcbiAgbWFyZ2luLWJvdHRvbTogMHB4ICFpbXBvcnRhbnQ7XFxufVxcbi5wLWItMCB7XFxuICBwYWRkaW5nLWJvdHRvbTogMHB4ICFpbXBvcnRhbnQ7XFxufVxcbi5tLWwtMCB7XFxuICBtYXJnaW4tbGVmdDogMHB4ICFpbXBvcnRhbnQ7XFxufVxcbi5wLWwtMCB7XFxuICBwYWRkaW5nLWxlZnQ6IDBweCAhaW1wb3J0YW50O1xcbn1cXG4ubS1yLTAge1xcbiAgbWFyZ2luLXJpZ2h0OiAwcHggIWltcG9ydGFudDtcXG59XFxuLnAtci0wIHtcXG4gIHBhZGRpbmctcmlnaHQ6IDBweCAhaW1wb3J0YW50O1xcbn1cXG4ubS10LTQge1xcbiAgbWFyZ2luLXRvcDogNHB4ICFpbXBvcnRhbnQ7XFxufVxcbi5wLXQtNCB7XFxuICBwYWRkaW5nLXRvcDogNHB4ICFpbXBvcnRhbnQ7XFxufVxcbi5tLWItNCB7XFxuICBtYXJnaW4tYm90dG9tOiA0cHggIWltcG9ydGFudDtcXG59XFxuLnAtYi00IHtcXG4gIHBhZGRpbmctYm90dG9tOiA0cHggIWltcG9ydGFudDtcXG59XFxuLm0tbC00IHtcXG4gIG1hcmdpbi1sZWZ0OiA0cHggIWltcG9ydGFudDtcXG59XFxuLnAtbC00IHtcXG4gIHBhZGRpbmctbGVmdDogNHB4ICFpbXBvcnRhbnQ7XFxufVxcbi5tLXItNCB7XFxuICBtYXJnaW4tcmlnaHQ6IDRweCAhaW1wb3J0YW50O1xcbn1cXG4ucC1yLTQge1xcbiAgcGFkZGluZy1yaWdodDogNHB4ICFpbXBvcnRhbnQ7XFxufVxcbi5tLXQtOCB7XFxuICBtYXJnaW4tdG9wOiA4cHggIWltcG9ydGFudDtcXG59XFxuLnAtdC04IHtcXG4gIHBhZGRpbmctdG9wOiA4cHggIWltcG9ydGFudDtcXG59XFxuLm0tYi04IHtcXG4gIG1hcmdpbi1ib3R0b206IDhweCAhaW1wb3J0YW50O1xcbn1cXG4ucC1iLTgge1xcbiAgcGFkZGluZy1ib3R0b206IDhweCAhaW1wb3J0YW50O1xcbn1cXG4ubS1sLTgge1xcbiAgbWFyZ2luLWxlZnQ6IDhweCAhaW1wb3J0YW50O1xcbn1cXG4ucC1sLTgge1xcbiAgcGFkZGluZy1sZWZ0OiA4cHggIWltcG9ydGFudDtcXG59XFxuLm0tci04IHtcXG4gIG1hcmdpbi1yaWdodDogOHB4ICFpbXBvcnRhbnQ7XFxufVxcbi5wLXItOCB7XFxuICBwYWRkaW5nLXJpZ2h0OiA4cHggIWltcG9ydGFudDtcXG59XFxuLm0tdC0xNiB7XFxuICBtYXJnaW4tdG9wOiAxNnB4ICFpbXBvcnRhbnQ7XFxufVxcbi5wLXQtMTYge1xcbiAgcGFkZGluZy10b3A6IDE2cHggIWltcG9ydGFudDtcXG59XFxuLm0tYi0xNiB7XFxuICBtYXJnaW4tYm90dG9tOiAxNnB4ICFpbXBvcnRhbnQ7XFxufVxcbi5wLWItMTYge1xcbiAgcGFkZGluZy1ib3R0b206IDE2cHggIWltcG9ydGFudDtcXG59XFxuLm0tbC0xNiB7XFxuICBtYXJnaW4tbGVmdDogMTZweCAhaW1wb3J0YW50O1xcbn1cXG4ucC1sLTE2IHtcXG4gIHBhZGRpbmctbGVmdDogMTZweCAhaW1wb3J0YW50O1xcbn1cXG4ubS1yLTE2IHtcXG4gIG1hcmdpbi1yaWdodDogMTZweCAhaW1wb3J0YW50O1xcbn1cXG4ucC1yLTE2IHtcXG4gIHBhZGRpbmctcmlnaHQ6IDE2cHggIWltcG9ydGFudDtcXG59XFxuLm0tdC0yNCB7XFxuICBtYXJnaW4tdG9wOiAyNHB4ICFpbXBvcnRhbnQ7XFxufVxcbi5wLXQtMjQge1xcbiAgcGFkZGluZy10b3A6IDI0cHggIWltcG9ydGFudDtcXG59XFxuLm0tYi0yNCB7XFxuICBtYXJnaW4tYm90dG9tOiAyNHB4ICFpbXBvcnRhbnQ7XFxufVxcbi5wLWItMjQge1xcbiAgcGFkZGluZy1ib3R0b206IDI0cHggIWltcG9ydGFudDtcXG59XFxuLm0tbC0yNCB7XFxuICBtYXJnaW4tbGVmdDogMjRweCAhaW1wb3J0YW50O1xcbn1cXG4ucC1sLTI0IHtcXG4gIHBhZGRpbmctbGVmdDogMjRweCAhaW1wb3J0YW50O1xcbn1cXG4ubS1yLTI0IHtcXG4gIG1hcmdpbi1yaWdodDogMjRweCAhaW1wb3J0YW50O1xcbn1cXG4ucC1yLTI0IHtcXG4gIHBhZGRpbmctcmlnaHQ6IDI0cHggIWltcG9ydGFudDtcXG59XFxuLm0tdC0zMiB7XFxuICBtYXJnaW4tdG9wOiAzMnB4ICFpbXBvcnRhbnQ7XFxufVxcbi5wLXQtMzIge1xcbiAgcGFkZGluZy10b3A6IDMycHggIWltcG9ydGFudDtcXG59XFxuLm0tYi0zMiB7XFxuICBtYXJnaW4tYm90dG9tOiAzMnB4ICFpbXBvcnRhbnQ7XFxufVxcbi5wLWItMzIge1xcbiAgcGFkZGluZy1ib3R0b206IDMycHggIWltcG9ydGFudDtcXG59XFxuLm0tbC0zMiB7XFxuICBtYXJnaW4tbGVmdDogMzJweCAhaW1wb3J0YW50O1xcbn1cXG4ucC1sLTMyIHtcXG4gIHBhZGRpbmctbGVmdDogMzJweCAhaW1wb3J0YW50O1xcbn1cXG4ubS1yLTMyIHtcXG4gIG1hcmdpbi1yaWdodDogMzJweCAhaW1wb3J0YW50O1xcbn1cXG4ucC1yLTMyIHtcXG4gIHBhZGRpbmctcmlnaHQ6IDMycHggIWltcG9ydGFudDtcXG59XFxuLm0tdC00MCB7XFxuICBtYXJnaW4tdG9wOiA0MHB4ICFpbXBvcnRhbnQ7XFxufVxcbi5wLXQtNDAge1xcbiAgcGFkZGluZy10b3A6IDQwcHggIWltcG9ydGFudDtcXG59XFxuLm0tYi00MCB7XFxuICBtYXJnaW4tYm90dG9tOiA0MHB4ICFpbXBvcnRhbnQ7XFxufVxcbi5wLWItNDAge1xcbiAgcGFkZGluZy1ib3R0b206IDQwcHggIWltcG9ydGFudDtcXG59XFxuLm0tbC00MCB7XFxuICBtYXJnaW4tbGVmdDogNDBweCAhaW1wb3J0YW50O1xcbn1cXG4ucC1sLTQwIHtcXG4gIHBhZGRpbmctbGVmdDogNDBweCAhaW1wb3J0YW50O1xcbn1cXG4ubS1yLTQwIHtcXG4gIG1hcmdpbi1yaWdodDogNDBweCAhaW1wb3J0YW50O1xcbn1cXG4ucC1yLTQwIHtcXG4gIHBhZGRpbmctcmlnaHQ6IDQwcHggIWltcG9ydGFudDtcXG59XFxuLm0tdC00OCB7XFxuICBtYXJnaW4tdG9wOiA0OHB4ICFpbXBvcnRhbnQ7XFxufVxcbi5wLXQtNDgge1xcbiAgcGFkZGluZy10b3A6IDQ4cHggIWltcG9ydGFudDtcXG59XFxuLm0tYi00OCB7XFxuICBtYXJnaW4tYm90dG9tOiA0OHB4ICFpbXBvcnRhbnQ7XFxufVxcbi5wLWItNDgge1xcbiAgcGFkZGluZy1ib3R0b206IDQ4cHggIWltcG9ydGFudDtcXG59XFxuLm0tbC00OCB7XFxuICBtYXJnaW4tbGVmdDogNDhweCAhaW1wb3J0YW50O1xcbn1cXG4ucC1sLTQ4IHtcXG4gIHBhZGRpbmctbGVmdDogNDhweCAhaW1wb3J0YW50O1xcbn1cXG4ubS1yLTQ4IHtcXG4gIG1hcmdpbi1yaWdodDogNDhweCAhaW1wb3J0YW50O1xcbn1cXG4ucC1yLTQ4IHtcXG4gIHBhZGRpbmctcmlnaHQ6IDQ4cHggIWltcG9ydGFudDtcXG59XFxuLm0tdC01NiB7XFxuICBtYXJnaW4tdG9wOiA1NnB4ICFpbXBvcnRhbnQ7XFxufVxcbi5wLXQtNTYge1xcbiAgcGFkZGluZy10b3A6IDU2cHggIWltcG9ydGFudDtcXG59XFxuLm0tYi01NiB7XFxuICBtYXJnaW4tYm90dG9tOiA1NnB4ICFpbXBvcnRhbnQ7XFxufVxcbi5wLWItNTYge1xcbiAgcGFkZGluZy1ib3R0b206IDU2cHggIWltcG9ydGFudDtcXG59XFxuLm0tbC01NiB7XFxuICBtYXJnaW4tbGVmdDogNTZweCAhaW1wb3J0YW50O1xcbn1cXG4ucC1sLTU2IHtcXG4gIHBhZGRpbmctbGVmdDogNTZweCAhaW1wb3J0YW50O1xcbn1cXG4ubS1yLTU2IHtcXG4gIG1hcmdpbi1yaWdodDogNTZweCAhaW1wb3J0YW50O1xcbn1cXG4ucC1yLTU2IHtcXG4gIHBhZGRpbmctcmlnaHQ6IDU2cHggIWltcG9ydGFudDtcXG59XFxuLm0tdC02NCB7XFxuICBtYXJnaW4tdG9wOiA2NHB4ICFpbXBvcnRhbnQ7XFxufVxcbi5wLXQtNjQge1xcbiAgcGFkZGluZy10b3A6IDY0cHggIWltcG9ydGFudDtcXG59XFxuLm0tYi02NCB7XFxuICBtYXJnaW4tYm90dG9tOiA2NHB4ICFpbXBvcnRhbnQ7XFxufVxcbi5wLWItNjQge1xcbiAgcGFkZGluZy1ib3R0b206IDY0cHggIWltcG9ydGFudDtcXG59XFxuLm0tbC02NCB7XFxuICBtYXJnaW4tbGVmdDogNjRweCAhaW1wb3J0YW50O1xcbn1cXG4ucC1sLTY0IHtcXG4gIHBhZGRpbmctbGVmdDogNjRweCAhaW1wb3J0YW50O1xcbn1cXG4ubS1yLTY0IHtcXG4gIG1hcmdpbi1yaWdodDogNjRweCAhaW1wb3J0YW50O1xcbn1cXG4ucC1yLTY0IHtcXG4gIHBhZGRpbmctcmlnaHQ6IDY0cHggIWltcG9ydGFudDtcXG59XFxuLm0tdC03MiB7XFxuICBtYXJnaW4tdG9wOiA3MnB4ICFpbXBvcnRhbnQ7XFxufVxcbi5wLXQtNzIge1xcbiAgcGFkZGluZy10b3A6IDcycHggIWltcG9ydGFudDtcXG59XFxuLm0tYi03MiB7XFxuICBtYXJnaW4tYm90dG9tOiA3MnB4ICFpbXBvcnRhbnQ7XFxufVxcbi5wLWItNzIge1xcbiAgcGFkZGluZy1ib3R0b206IDcycHggIWltcG9ydGFudDtcXG59XFxuLm0tbC03MiB7XFxuICBtYXJnaW4tbGVmdDogNzJweCAhaW1wb3J0YW50O1xcbn1cXG4ucC1sLTcyIHtcXG4gIHBhZGRpbmctbGVmdDogNzJweCAhaW1wb3J0YW50O1xcbn1cXG4ubS1yLTcyIHtcXG4gIG1hcmdpbi1yaWdodDogNzJweCAhaW1wb3J0YW50O1xcbn1cXG4ucC1yLTcyIHtcXG4gIHBhZGRpbmctcmlnaHQ6IDcycHggIWltcG9ydGFudDtcXG59XFxuLm0tdC04MCB7XFxuICBtYXJnaW4tdG9wOiA4MHB4ICFpbXBvcnRhbnQ7XFxufVxcbi5wLXQtODAge1xcbiAgcGFkZGluZy10b3A6IDgwcHggIWltcG9ydGFudDtcXG59XFxuLm0tYi04MCB7XFxuICBtYXJnaW4tYm90dG9tOiA4MHB4ICFpbXBvcnRhbnQ7XFxufVxcbi5wLWItODAge1xcbiAgcGFkZGluZy1ib3R0b206IDgwcHggIWltcG9ydGFudDtcXG59XFxuLm0tbC04MCB7XFxuICBtYXJnaW4tbGVmdDogODBweCAhaW1wb3J0YW50O1xcbn1cXG4ucC1sLTgwIHtcXG4gIHBhZGRpbmctbGVmdDogODBweCAhaW1wb3J0YW50O1xcbn1cXG4ubS1yLTgwIHtcXG4gIG1hcmdpbi1yaWdodDogODBweCAhaW1wb3J0YW50O1xcbn1cXG4ucC1yLTgwIHtcXG4gIHBhZGRpbmctcmlnaHQ6IDgwcHggIWltcG9ydGFudDtcXG59XFxuLm0tdC0xMjAge1xcbiAgbWFyZ2luLXRvcDogMTIwcHggIWltcG9ydGFudDtcXG59XFxuLnAtdC0xMjAge1xcbiAgcGFkZGluZy10b3A6IDEyMHB4ICFpbXBvcnRhbnQ7XFxufVxcbi5tLWItMTIwIHtcXG4gIG1hcmdpbi1ib3R0b206IDEyMHB4ICFpbXBvcnRhbnQ7XFxufVxcbi5wLWItMTIwIHtcXG4gIHBhZGRpbmctYm90dG9tOiAxMjBweCAhaW1wb3J0YW50O1xcbn1cXG4ubS1sLTEyMCB7XFxuICBtYXJnaW4tbGVmdDogMTIwcHggIWltcG9ydGFudDtcXG59XFxuLnAtbC0xMjAge1xcbiAgcGFkZGluZy1sZWZ0OiAxMjBweCAhaW1wb3J0YW50O1xcbn1cXG4ubS1yLTEyMCB7XFxuICBtYXJnaW4tcmlnaHQ6IDEyMHB4ICFpbXBvcnRhbnQ7XFxufVxcbi5wLXItMTIwIHtcXG4gIHBhZGRpbmctcmlnaHQ6IDEyMHB4ICFpbXBvcnRhbnQ7XFxufVxcbi5tLXQtMTYwIHtcXG4gIG1hcmdpbi10b3A6IDE2MHB4ICFpbXBvcnRhbnQ7XFxufVxcbi5wLXQtMTYwIHtcXG4gIHBhZGRpbmctdG9wOiAxNjBweCAhaW1wb3J0YW50O1xcbn1cXG4ubS1iLTE2MCB7XFxuICBtYXJnaW4tYm90dG9tOiAxNjBweCAhaW1wb3J0YW50O1xcbn1cXG4ucC1iLTE2MCB7XFxuICBwYWRkaW5nLWJvdHRvbTogMTYwcHggIWltcG9ydGFudDtcXG59XFxuLm0tbC0xNjAge1xcbiAgbWFyZ2luLWxlZnQ6IDE2MHB4ICFpbXBvcnRhbnQ7XFxufVxcbi5wLWwtMTYwIHtcXG4gIHBhZGRpbmctbGVmdDogMTYwcHggIWltcG9ydGFudDtcXG59XFxuLm0tci0xNjAge1xcbiAgbWFyZ2luLXJpZ2h0OiAxNjBweCAhaW1wb3J0YW50O1xcbn1cXG4ucC1yLTE2MCB7XFxuICBwYWRkaW5nLXJpZ2h0OiAxNjBweCAhaW1wb3J0YW50O1xcbn1cXG5cXG4qIHtcXG4gIG1hcmdpbjogMDtcXG4gIHBhZGRpbmc6IDA7XFxuICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xcbn1cXG5cXG5odG1sIHtcXG4gIGJhY2tncm91bmQ6ICMxMzEzMTY7XFxuICBzY3JvbGwtYmVoYXZpb3I6IHNtb290aDtcXG4gIGNvbG9yLXNjaGVtZTogZGFyaztcXG59XFxuXFxuYm9keSB7XFxuICBmb250LWZhbWlseTogdmFyKC0tYm9keS1mb250LWZhbWlseSk7XFxuICBmb250LXNpemU6IDE0cHg7XFxuICBjb2xvcjogdmFyKC0tY2xyLW5ldXRyYWwtMzAwKTtcXG59XFxuXFxuaGVhZGVyIHtcXG4gIHBhZGRpbmc6IDI0cHggMzJweDtcXG4gIGRpc3BsYXk6IGZsZXg7XFxuICBhbGlnbi1pdGVtczogY2VudGVyO1xcbiAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XFxuICBiYWNrZ3JvdW5kOiAjMDAwMDAwO1xcbiAgYm94LXNoYWRvdzogMHB4IDFweCAwcHggcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjE1KTtcXG59XFxuXFxuLmhlYWRlci1pbm5lciB7XFxuICBmbGV4OiAxO1xcbiAgZGlzcGxheTogZmxleDtcXG4gIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxuICBtYXgtd2lkdGg6IDExMDBweDtcXG59XFxuXFxuLmJ1aWxkLW5vdGVzIHtcXG4gIGZsZXg6IDE7XFxuICBkaXNwbGF5OiBmbGV4O1xcbiAganVzdGlmeS1jb250ZW50OiBmbGV4LWVuZDtcXG4gIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxufVxcblxcbi5idWlsZC1ub3RlIHtcXG4gIGxpbmUtaGVpZ2h0OiAxO1xcbiAgZGlzcGxheTogZmxleDtcXG4gIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxuICBjb2xvcjogdmFyKC0tY2xyLW5ldXRyYWwtNDUwKTtcXG59XFxuXFxuLmJ1aWxkLW5vdGUgKyAuYnVpbGQtbm90ZSB7XFxuICBtYXJnaW4tbGVmdDogMTZweDtcXG59XFxuXFxuLmJ1aWxkLW5vdGUgPiBzdmcge1xcbiAgbWFyZ2luLXJpZ2h0OiA4cHg7XFxufVxcblxcbmgxIHtcXG4gIGZvbnQtZmFtaWx5OiB2YXIoLS1oZWFkaW5nLWZvbnQtZmFtaWx5KTtcXG4gIGZvbnQtc2l6ZTogMjBweDtcXG4gIGZvbnQtd2VpZ2h0OiBib2xkO1xcbiAgY29sb3I6IHZhcigtLWNsci1uZXV0cmFsLTApO1xcbn1cXG5cXG5oMiB7XFxuICBmb250LWZhbWlseTogdmFyKC0taGVhZGluZy1mb250LWZhbWlseSk7XFxuICBmb250LXNpemU6IDE2cHg7XFxuICBmb250LXdlaWdodDogNjAwO1xcbiAgY29sb3I6IHZhcigtLWNsci1uZXV0cmFsLTUwKTtcXG59XFxuXFxuaDMge1xcbiAgZm9udC1mYW1pbHk6IHZhcigtLWhlYWRpbmctZm9udC1mYW1pbHkpO1xcbiAgZm9udC1zaXplOiAxNnB4O1xcbiAgZm9udC13ZWlnaHQ6IDUwMDtcXG4gIGNvbG9yOiB2YXIoLS1jbHItbmV1dHJhbC0xMDApO1xcbn1cXG5cXG5idXR0b24ge1xcbiAgYm9yZGVyOiBub25lO1xcbiAgY29sb3I6IHZhcigtLWNsci1uZXV0cmFsLTUwKTtcXG4gIGJhY2tncm91bmQ6IGxpbmVhci1ncmFkaWVudCg5MGRlZywgIzYxNmFjYiAwJSwgIzQ4NTRiYiAxMDAlKTtcXG4gIGJvcmRlci1yYWRpdXM6IDRweDtcXG4gIGZvbnQtZmFtaWx5OiB2YXIoLS1ib2R5LWZvbnQtZmFtaWx5KTtcXG4gIGZvbnQtc2l6ZTogMTRweDtcXG4gIHBhZGRpbmc6IDEycHggMThweDtcXG4gIGN1cnNvcjogcG9pbnRlcjtcXG59XFxuXFxuYnV0dG9uLnNlY29uZGFyeSB7XFxuICBib3JkZXI6IDFweCBzb2xpZCB2YXIoLS1jbHItcHJpbWFyeS01MDApO1xcbiAgYmFja2dyb3VuZDogdHJhbnNwYXJlbnQ7XFxufVxcblxcbmJ1dHRvbjpkaXNhYmxlZCB7XFxuICBjb2xvcjogdmFyKC0tY2xyLW5ldXRyYWwtNDAwKTtcXG4gIGJhY2tncm91bmQ6IHZhcigtLWNsci1uZXV0cmFsLTg1MCk7XFxuICBjdXJzb3I6IGluaGVyaXQ7XFxufVxcblxcbmlucHV0IHtcXG4gIGZvbnQtc2l6ZTogMTRweDtcXG59XFxuXFxuaW5wdXRbdHlwZT1cXFwidGV4dFxcXCJdIHtcXG4gIGZvbnQtZmFtaWx5OiB2YXIoLS1ib2R5LWZvbnQtZmFtaWx5KTtcXG4gIGJhY2tncm91bmQ6IHZhcigtLWNsci1uZXV0cmFsLTk1MCk7XFxuICBib3JkZXI6IDFweCBzb2xpZCB2YXIoLS1jbHItbmV1dHJhbC04NTApO1xcbiAgYm9yZGVyLXJhZGl1czogNXB4O1xcbiAgcGFkZGluZzogMTJweCAxNnB4O1xcbn1cXG5cXG4uYmFkZ2Uge1xcbiAgZGlzcGxheTogZmxleDtcXG4gIGZsZXgtZGlyZWN0aW9uOiByb3c7XFxuICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcXG4gIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxuICBwYWRkaW5nOiA0cHggOHB4O1xcbiAgZm9udC1zaXplOiAxMnB4O1xcbiAgZm9udC13ZWlnaHQ6IDUwMDtcXG4gIGJvcmRlci1yYWRpdXM6IDI0cHg7XFxuICBiYWNrZ3JvdW5kOiB2YXIoLS1jbHItbmV1dHJhbC05MDApO1xcbiAgY29sb3I6IHZhcigtLWNsci1uZXV0cmFsLTMwMCk7XFxufVxcblxcbi5iYWRnZS5vayB7XFxuICBiYWNrZ3JvdW5kOiB2YXIoLS1jbHItcHJpbWFyeS05MDApO1xcbiAgY29sb3I6IHZhcigtLWNsci1wcmltYXJ5LTMwMCk7XFxufVxcblxcbi5iYWNrZHJvcCB7XFxuICB3aWR0aDogMTAwJTtcXG4gIGhlaWdodDogMTgwcHg7XFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICB6LWluZGV4OiAtNTtcXG4gIHBvaW50ZXItZXZlbnRzOiBub25lO1xcbiAgYmFja2dyb3VuZDogIzAwMDAwMDtcXG59XFxuXFxuLmRlbW8ge1xcbiAgcGFkZGluZzogMzJweDtcXG4gIG1heC13aWR0aDogMTEwMHB4O1xcbiAgbWFyZ2luOiBhdXRvO1xcbn1cXG5cXG4uZmxleCB7XFxuICBkaXNwbGF5OiBmbGV4O1xcbiAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG59XFxuXFxuc3ZnIHtcXG4gIGZsZXgtc2hyaW5rOiAwO1xcbn1cXG5cXG4uY2FyZCB7XFxuICBiYWNrZ3JvdW5kOiB2YXIoLS1jbHItbmV1dHJhbC05MjUpO1xcbiAgYm94LXNoYWRvdzogMHB4IDhweCA1MHB4IHJnYmEoMCwgMCwgMCwgMC4yNSk7XFxuICBib3JkZXItcmFkaXVzOiA4cHg7XFxuICBwYWRkaW5nOiAyNHB4O1xcbiAgbWFyZ2luOiAyNHB4IDA7XFxufVxcblxcbi5jYXJkLXRvcCB7XFxuICBkaXNwbGF5OiBmbGV4O1xcbiAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG4gIG1hcmdpbi1ib3R0b206IDhweDtcXG59XFxuXFxuLmNhcmQtdG9wID4gKiArICoge1xcbiAgbWFyZ2luLWxlZnQ6IDhweDtcXG59XFxuXFxuLndpZGdldC1ib2R5IHtcXG4gIGRpc3BsYXk6IGZsZXg7XFxufVxcblxcbi5zdHJlYW0tY29sdW1uIHtcXG4gIGZsZXg6IDI7XFxufVxcblxcbi5jaGF0LWNvbHVtbiB7XFxuICBmbGV4OiAxO1xcbiAgZGlzcGxheTogZmxleDtcXG4gIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XFxufVxcblxcbi5jaGF0LWhpc3Rvcnkge1xcbiAgZmxleDogMTtcXG59XFxuXFxuLmNoYXQtYm90dG9tIHtcXG4gIGRpc3BsYXk6IGZsZXg7XFxuICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICBhbGlnbi1pdGVtczogY2VudGVyO1xcbn1cXG5cXG4uY2hhdC1pbnB1dCB7XFxuICBmbGV4OiAxO1xcbn1cXG5cXG5idXR0b24uY2hhdC1zZW5kLWJ1dHRvbiB7XFxuICBjdXJzb3I6IHBvaW50ZXI7XFxuICBiYWNrZ3JvdW5kOiBub25lO1xcbiAgcGFkZGluZzogMDtcXG4gIG1hcmdpbjogMDtcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gIHJpZ2h0OiAxNnB4O1xcbiAgbWFyZ2luLXRvcDogYXV0bztcXG59XFxuXFxuYnV0dG9uLmNoYXQtc2VuZC1idXR0b246ZGlzYWJsZWQge1xcbiAgY3Vyc29yOiBpbmhlcml0O1xcbiAgZmlsdGVyOiBncmF5c2NhbGUoKTtcXG59XFxuXFxuLnN0cmVhbS13cmFwcGVyIHtcXG4gIGJvcmRlcjogMXB4IHNvbGlkIHJnYmEoMCwgMCwgMCwgMC40KTtcXG4gIGJhY2tncm91bmQtaW1hZ2U6IC8qIHVybChcXFwiaHR0cHM6Ly9yYWlud2F5LmNvbS9pbWFnZXMvbG9nby5zdmdcXFwiKSwgKi9cXG4gICAgbGluZWFyLWdyYWRpZW50KC00NWRlZywgIzE0MTYyNSwgIzI0MTYzNSk7XFxuICBiYWNrZ3JvdW5kLXJlcGVhdDogbm8tcmVwZWF0O1xcbiAgYmFja2dyb3VuZC1wb3NpdGlvbjogY2VudGVyO1xcbiAgd2lkdGg6IDEwMCU7XFxuICBoZWlnaHQ6IDM5M3B4O1xcbn1cXG5cXG5hIHtcXG4gIGNvbG9yOiB2YXIoLS1jbHItcHJpbWFyeS00MDApO1xcbiAgZm9udC13ZWlnaHQ6IDYwMDtcXG4gIHRleHQtZGVjb3JhdGlvbjogbm9uZTtcXG4gIHRyYW5zaXRpb246IGNvbG9yIDAuMnMgZWFzZTtcXG59XFxuXFxuYTpob3ZlciB7XFxuICBjb2xvcjogdmFyKC0tY2xyLW5ldXRyYWwtNTApO1xcbn1cXG5cIiwgXCJcIl0pO1xuLy8gRXhwb3J0c1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qXG4gIE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXG4gIEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcbiovXG4vLyBjc3MgYmFzZSBjb2RlLCBpbmplY3RlZCBieSB0aGUgY3NzLWxvYWRlclxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGZ1bmMtbmFtZXNcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHVzZVNvdXJjZU1hcCkge1xuICB2YXIgbGlzdCA9IFtdOyAvLyByZXR1cm4gdGhlIGxpc3Qgb2YgbW9kdWxlcyBhcyBjc3Mgc3RyaW5nXG5cbiAgbGlzdC50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgdmFyIGNvbnRlbnQgPSBjc3NXaXRoTWFwcGluZ1RvU3RyaW5nKGl0ZW0sIHVzZVNvdXJjZU1hcCk7XG5cbiAgICAgIGlmIChpdGVtWzJdKSB7XG4gICAgICAgIHJldHVybiBcIkBtZWRpYSBcIi5jb25jYXQoaXRlbVsyXSwgXCIge1wiKS5jb25jYXQoY29udGVudCwgXCJ9XCIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY29udGVudDtcbiAgICB9KS5qb2luKCcnKTtcbiAgfTsgLy8gaW1wb3J0IGEgbGlzdCBvZiBtb2R1bGVzIGludG8gdGhlIGxpc3RcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGZ1bmMtbmFtZXNcblxuXG4gIGxpc3QuaSA9IGZ1bmN0aW9uIChtb2R1bGVzLCBtZWRpYVF1ZXJ5LCBkZWR1cGUpIHtcbiAgICBpZiAodHlwZW9mIG1vZHVsZXMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgIG1vZHVsZXMgPSBbW251bGwsIG1vZHVsZXMsICcnXV07XG4gICAgfVxuXG4gICAgdmFyIGFscmVhZHlJbXBvcnRlZE1vZHVsZXMgPSB7fTtcblxuICAgIGlmIChkZWR1cGUpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcHJlZmVyLWRlc3RydWN0dXJpbmdcbiAgICAgICAgdmFyIGlkID0gdGhpc1tpXVswXTtcblxuICAgICAgICBpZiAoaWQgIT0gbnVsbCkge1xuICAgICAgICAgIGFscmVhZHlJbXBvcnRlZE1vZHVsZXNbaWRdID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBtb2R1bGVzLmxlbmd0aDsgX2krKykge1xuICAgICAgdmFyIGl0ZW0gPSBbXS5jb25jYXQobW9kdWxlc1tfaV0pO1xuXG4gICAgICBpZiAoZGVkdXBlICYmIGFscmVhZHlJbXBvcnRlZE1vZHVsZXNbaXRlbVswXV0pIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnRpbnVlXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAobWVkaWFRdWVyeSkge1xuICAgICAgICBpZiAoIWl0ZW1bMl0pIHtcbiAgICAgICAgICBpdGVtWzJdID0gbWVkaWFRdWVyeTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpdGVtWzJdID0gXCJcIi5jb25jYXQobWVkaWFRdWVyeSwgXCIgYW5kIFwiKS5jb25jYXQoaXRlbVsyXSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgbGlzdC5wdXNoKGl0ZW0pO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gbGlzdDtcbn07XG5cbmZ1bmN0aW9uIGNzc1dpdGhNYXBwaW5nVG9TdHJpbmcoaXRlbSwgdXNlU291cmNlTWFwKSB7XG4gIHZhciBjb250ZW50ID0gaXRlbVsxXSB8fCAnJzsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHByZWZlci1kZXN0cnVjdHVyaW5nXG5cbiAgdmFyIGNzc01hcHBpbmcgPSBpdGVtWzNdO1xuXG4gIGlmICghY3NzTWFwcGluZykge1xuICAgIHJldHVybiBjb250ZW50O1xuICB9XG5cbiAgaWYgKHVzZVNvdXJjZU1hcCAmJiB0eXBlb2YgYnRvYSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHZhciBzb3VyY2VNYXBwaW5nID0gdG9Db21tZW50KGNzc01hcHBpbmcpO1xuICAgIHZhciBzb3VyY2VVUkxzID0gY3NzTWFwcGluZy5zb3VyY2VzLm1hcChmdW5jdGlvbiAoc291cmNlKSB7XG4gICAgICByZXR1cm4gXCIvKiMgc291cmNlVVJMPVwiLmNvbmNhdChjc3NNYXBwaW5nLnNvdXJjZVJvb3QgfHwgJycpLmNvbmNhdChzb3VyY2UsIFwiICovXCIpO1xuICAgIH0pO1xuICAgIHJldHVybiBbY29udGVudF0uY29uY2F0KHNvdXJjZVVSTHMpLmNvbmNhdChbc291cmNlTWFwcGluZ10pLmpvaW4oJ1xcbicpO1xuICB9XG5cbiAgcmV0dXJuIFtjb250ZW50XS5qb2luKCdcXG4nKTtcbn0gLy8gQWRhcHRlZCBmcm9tIGNvbnZlcnQtc291cmNlLW1hcCAoTUlUKVxuXG5cbmZ1bmN0aW9uIHRvQ29tbWVudChzb3VyY2VNYXApIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmXG4gIHZhciBiYXNlNjQgPSBidG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShzb3VyY2VNYXApKSkpO1xuICB2YXIgZGF0YSA9IFwic291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247Y2hhcnNldD11dGYtODtiYXNlNjQsXCIuY29uY2F0KGJhc2U2NCk7XG4gIHJldHVybiBcIi8qIyBcIi5jb25jYXQoZGF0YSwgXCIgKi9cIik7XG59IiwiLypcbm9iamVjdC1hc3NpZ25cbihjKSBTaW5kcmUgU29yaHVzXG5AbGljZW5zZSBNSVRcbiovXG5cbid1c2Ugc3RyaWN0Jztcbi8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovXG52YXIgZ2V0T3duUHJvcGVydHlTeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgcHJvcElzRW51bWVyYWJsZSA9IE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGU7XG5cbmZ1bmN0aW9uIHRvT2JqZWN0KHZhbCkge1xuXHRpZiAodmFsID09PSBudWxsIHx8IHZhbCA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignT2JqZWN0LmFzc2lnbiBjYW5ub3QgYmUgY2FsbGVkIHdpdGggbnVsbCBvciB1bmRlZmluZWQnKTtcblx0fVxuXG5cdHJldHVybiBPYmplY3QodmFsKTtcbn1cblxuZnVuY3Rpb24gc2hvdWxkVXNlTmF0aXZlKCkge1xuXHR0cnkge1xuXHRcdGlmICghT2JqZWN0LmFzc2lnbikge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vIERldGVjdCBidWdneSBwcm9wZXJ0eSBlbnVtZXJhdGlvbiBvcmRlciBpbiBvbGRlciBWOCB2ZXJzaW9ucy5cblxuXHRcdC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTQxMThcblx0XHR2YXIgdGVzdDEgPSBuZXcgU3RyaW5nKCdhYmMnKTsgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3LXdyYXBwZXJzXG5cdFx0dGVzdDFbNV0gPSAnZGUnO1xuXHRcdGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0ZXN0MSlbMF0gPT09ICc1Jykge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTMwNTZcblx0XHR2YXIgdGVzdDIgPSB7fTtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IDEwOyBpKyspIHtcblx0XHRcdHRlc3QyWydfJyArIFN0cmluZy5mcm9tQ2hhckNvZGUoaSldID0gaTtcblx0XHR9XG5cdFx0dmFyIG9yZGVyMiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRlc3QyKS5tYXAoZnVuY3Rpb24gKG4pIHtcblx0XHRcdHJldHVybiB0ZXN0MltuXTtcblx0XHR9KTtcblx0XHRpZiAob3JkZXIyLmpvaW4oJycpICE9PSAnMDEyMzQ1Njc4OScpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0zMDU2XG5cdFx0dmFyIHRlc3QzID0ge307XG5cdFx0J2FiY2RlZmdoaWprbG1ub3BxcnN0Jy5zcGxpdCgnJykuZm9yRWFjaChmdW5jdGlvbiAobGV0dGVyKSB7XG5cdFx0XHR0ZXN0M1tsZXR0ZXJdID0gbGV0dGVyO1xuXHRcdH0pO1xuXHRcdGlmIChPYmplY3Qua2V5cyhPYmplY3QuYXNzaWduKHt9LCB0ZXN0MykpLmpvaW4oJycpICE9PVxuXHRcdFx0XHQnYWJjZGVmZ2hpamtsbW5vcHFyc3QnKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRydWU7XG5cdH0gY2F0Y2ggKGVycikge1xuXHRcdC8vIFdlIGRvbid0IGV4cGVjdCBhbnkgb2YgdGhlIGFib3ZlIHRvIHRocm93LCBidXQgYmV0dGVyIHRvIGJlIHNhZmUuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2hvdWxkVXNlTmF0aXZlKCkgPyBPYmplY3QuYXNzaWduIDogZnVuY3Rpb24gKHRhcmdldCwgc291cmNlKSB7XG5cdHZhciBmcm9tO1xuXHR2YXIgdG8gPSB0b09iamVjdCh0YXJnZXQpO1xuXHR2YXIgc3ltYm9scztcblxuXHRmb3IgKHZhciBzID0gMTsgcyA8IGFyZ3VtZW50cy5sZW5ndGg7IHMrKykge1xuXHRcdGZyb20gPSBPYmplY3QoYXJndW1lbnRzW3NdKTtcblxuXHRcdGZvciAodmFyIGtleSBpbiBmcm9tKSB7XG5cdFx0XHRpZiAoaGFzT3duUHJvcGVydHkuY2FsbChmcm9tLCBrZXkpKSB7XG5cdFx0XHRcdHRvW2tleV0gPSBmcm9tW2tleV07XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKGdldE93blByb3BlcnR5U3ltYm9scykge1xuXHRcdFx0c3ltYm9scyA9IGdldE93blByb3BlcnR5U3ltYm9scyhmcm9tKTtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgc3ltYm9scy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRpZiAocHJvcElzRW51bWVyYWJsZS5jYWxsKGZyb20sIHN5bWJvbHNbaV0pKSB7XG5cdFx0XHRcdFx0dG9bc3ltYm9sc1tpXV0gPSBmcm9tW3N5bWJvbHNbaV1dO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHRvO1xufTtcbiIsIiFmdW5jdGlvbihBLEkpe1wib2JqZWN0XCI9PXR5cGVvZiBleHBvcnRzJiZcIm9iamVjdFwiPT10eXBlb2YgbW9kdWxlP21vZHVsZS5leHBvcnRzPUkoKTpcImZ1bmN0aW9uXCI9PXR5cGVvZiBkZWZpbmUmJmRlZmluZS5hbWQ/ZGVmaW5lKFtdLEkpOlwib2JqZWN0XCI9PXR5cGVvZiBleHBvcnRzP2V4cG9ydHNbXCJyYWlud2F5LXNka1wiXT1JKCk6QVtcInJhaW53YXktc2RrXCJdPUkoKX0oc2VsZiwoZnVuY3Rpb24oKXtyZXR1cm4oKCk9Pnt2YXIgQT17MTIwOihBLEksZyk9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkoSSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxJLkJlYm9wVmlldz1JLkJlYm9wUnVudGltZUVycm9yPXZvaWQgMDtjb25zdCBlPVwiMDEyMzQ1Njc4OWFiY2RlZlwiLEI9WzAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMSwyLDMsNCw1LDYsNyw4LDksMCwwLDAsMCwwLDAsMCwxMCwxMSwxMiwxMywxNCwxNSwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMTAsMTEsMTIsMTMsMTQsMTUsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMF0saT1uZXcgVWludDhBcnJheSgwKSxRPVtdO2Zvcihjb25zdCBBIG9mIGUpZm9yKGNvbnN0IEkgb2YgZSlRLnB1c2goQStJKTtcInVuZGVmaW5lZFwiPT10eXBlb2YgVGV4dERlY29kZXImJihnLmcuVGV4dERlY29kZXI9Zyg3MDApLlRleHREZWNvZGVyKTtjbGFzcyB0IGV4dGVuZHMgRXJyb3J7Y29uc3RydWN0b3IoQSl7c3VwZXIoQSksdGhpcy5uYW1lPVwiQmVib3BSdW50aW1lRXJyb3JcIn19SS5CZWJvcFJ1bnRpbWVFcnJvcj10O2NsYXNzIEN7c3RhdGljIHRleHREZWNvZGVyPW5ldyBUZXh0RGVjb2RlcjtzdGF0aWMgd3JpdGVCdWZmZXI9bmV3IFVpbnQ4QXJyYXkoMjU2KTtzdGF0aWMgd3JpdGVCdWZmZXJWaWV3PW5ldyBEYXRhVmlldyhDLndyaXRlQnVmZmVyLmJ1ZmZlcik7c3RhdGljIGluc3RhbmNlO3N0YXRpYyBnZXRJbnN0YW5jZSgpe3JldHVybiBDLmluc3RhbmNlfHwoQy5pbnN0YW5jZT1uZXcgQyksQy5pbnN0YW5jZX1taW5pbXVtVGV4dERlY29kZXJMZW5ndGg9MzAwO2J1ZmZlcjt2aWV3O2luZGV4O2xlbmd0aDtjb25zdHJ1Y3Rvcigpe3RoaXMuYnVmZmVyPUMud3JpdGVCdWZmZXIsdGhpcy52aWV3PUMud3JpdGVCdWZmZXJWaWV3LHRoaXMuaW5kZXg9MCx0aGlzLmxlbmd0aD0wfXN0YXJ0UmVhZGluZyhBKXt0aGlzLmJ1ZmZlcj1BLHRoaXMudmlldz1uZXcgRGF0YVZpZXcodGhpcy5idWZmZXIuYnVmZmVyLHRoaXMuYnVmZmVyLmJ5dGVPZmZzZXQsdGhpcy5idWZmZXIuYnl0ZUxlbmd0aCksdGhpcy5pbmRleD0wLHRoaXMubGVuZ3RoPUEubGVuZ3RofXN0YXJ0V3JpdGluZygpe3RoaXMuYnVmZmVyPUMud3JpdGVCdWZmZXIsdGhpcy52aWV3PUMud3JpdGVCdWZmZXJWaWV3LHRoaXMuaW5kZXg9MCx0aGlzLmxlbmd0aD0wfWd1YXJhbnRlZUJ1ZmZlckxlbmd0aChBKXtpZihBPnRoaXMuYnVmZmVyLmxlbmd0aCl7Y29uc3QgST1uZXcgVWludDhBcnJheShBPDwxKTtJLnNldCh0aGlzLmJ1ZmZlciksdGhpcy5idWZmZXI9SSx0aGlzLnZpZXc9bmV3IERhdGFWaWV3KEkuYnVmZmVyKX19Z3Jvd0J5KEEpe3RoaXMubGVuZ3RoKz1BLHRoaXMuZ3VhcmFudGVlQnVmZmVyTGVuZ3RoKHRoaXMubGVuZ3RoKX1za2lwKEEpe3RoaXMuaW5kZXgrPUF9dG9BcnJheSgpe3JldHVybiB0aGlzLmJ1ZmZlci5zdWJhcnJheSgwLHRoaXMubGVuZ3RoKX1yZWFkQnl0ZSgpe3JldHVybiB0aGlzLmJ1ZmZlclt0aGlzLmluZGV4KytdfXJlYWRVaW50MTYoKXtjb25zdCBBPXRoaXMudmlldy5nZXRVaW50MTYodGhpcy5pbmRleCwhMCk7cmV0dXJuIHRoaXMuaW5kZXgrPTIsQX1yZWFkSW50MTYoKXtjb25zdCBBPXRoaXMudmlldy5nZXRJbnQxNih0aGlzLmluZGV4LCEwKTtyZXR1cm4gdGhpcy5pbmRleCs9MixBfXJlYWRVaW50MzIoKXtjb25zdCBBPXRoaXMudmlldy5nZXRVaW50MzIodGhpcy5pbmRleCwhMCk7cmV0dXJuIHRoaXMuaW5kZXgrPTQsQX1yZWFkSW50MzIoKXtjb25zdCBBPXRoaXMudmlldy5nZXRJbnQzMih0aGlzLmluZGV4LCEwKTtyZXR1cm4gdGhpcy5pbmRleCs9NCxBfXJlYWRVaW50NjQoKXtjb25zdCBBPXRoaXMudmlldy5nZXRCaWdVaW50NjQodGhpcy5pbmRleCwhMCk7cmV0dXJuIHRoaXMuaW5kZXgrPTgsQX1yZWFkSW50NjQoKXtjb25zdCBBPXRoaXMudmlldy5nZXRCaWdJbnQ2NCh0aGlzLmluZGV4LCEwKTtyZXR1cm4gdGhpcy5pbmRleCs9OCxBfXJlYWRGbG9hdDMyKCl7Y29uc3QgQT10aGlzLnZpZXcuZ2V0RmxvYXQzMih0aGlzLmluZGV4LCEwKTtyZXR1cm4gdGhpcy5pbmRleCs9NCxBfXJlYWRGbG9hdDY0KCl7Y29uc3QgQT10aGlzLnZpZXcuZ2V0RmxvYXQ2NCh0aGlzLmluZGV4LCEwKTtyZXR1cm4gdGhpcy5pbmRleCs9OCxBfXdyaXRlQnl0ZShBKXtjb25zdCBJPXRoaXMubGVuZ3RoO3RoaXMuZ3Jvd0J5KDEpLHRoaXMuYnVmZmVyW0ldPUF9d3JpdGVVaW50MTYoQSl7Y29uc3QgST10aGlzLmxlbmd0aDt0aGlzLmdyb3dCeSgyKSx0aGlzLnZpZXcuc2V0VWludDE2KEksQSwhMCl9d3JpdGVJbnQxNihBKXtjb25zdCBJPXRoaXMubGVuZ3RoO3RoaXMuZ3Jvd0J5KDIpLHRoaXMudmlldy5zZXRJbnQxNihJLEEsITApfXdyaXRlVWludDMyKEEpe2NvbnN0IEk9dGhpcy5sZW5ndGg7dGhpcy5ncm93QnkoNCksdGhpcy52aWV3LnNldFVpbnQzMihJLEEsITApfXdyaXRlSW50MzIoQSl7Y29uc3QgST10aGlzLmxlbmd0aDt0aGlzLmdyb3dCeSg0KSx0aGlzLnZpZXcuc2V0SW50MzIoSSxBLCEwKX13cml0ZVVpbnQ2NChBKXtjb25zdCBJPXRoaXMubGVuZ3RoO3RoaXMuZ3Jvd0J5KDgpLHRoaXMudmlldy5zZXRCaWdVaW50NjQoSSxBLCEwKX13cml0ZUludDY0KEEpe2NvbnN0IEk9dGhpcy5sZW5ndGg7dGhpcy5ncm93QnkoOCksdGhpcy52aWV3LnNldEJpZ0ludDY0KEksQSwhMCl9d3JpdGVGbG9hdDMyKEEpe2NvbnN0IEk9dGhpcy5sZW5ndGg7dGhpcy5ncm93QnkoNCksdGhpcy52aWV3LnNldEZsb2F0MzIoSSxBLCEwKX13cml0ZUZsb2F0NjQoQSl7Y29uc3QgST10aGlzLmxlbmd0aDt0aGlzLmdyb3dCeSg4KSx0aGlzLnZpZXcuc2V0RmxvYXQ2NChJLEEsITApfXJlYWRCeXRlcygpe2NvbnN0IEE9dGhpcy5yZWFkVWludDMyKCk7aWYoMD09PUEpcmV0dXJuIGk7Y29uc3QgST10aGlzLmluZGV4LGc9SStBO3JldHVybiB0aGlzLmluZGV4PWcsdGhpcy5idWZmZXIuc3ViYXJyYXkoSSxnKX13cml0ZUJ5dGVzKEEpe2NvbnN0IEk9QS5sZW5ndGg7aWYodGhpcy53cml0ZVVpbnQzMihJKSwwPT09SSlyZXR1cm47Y29uc3QgZz10aGlzLmxlbmd0aDt0aGlzLmdyb3dCeShJKSx0aGlzLmJ1ZmZlci5zZXQoQSxnKX1yZWFkU3RyaW5nKCl7Y29uc3QgQT10aGlzLnJlYWRVaW50MzIoKTtpZigwPT09QSlyZXR1cm5cIlwiO2lmKEE+PXRoaXMubWluaW11bVRleHREZWNvZGVyTGVuZ3RoKXJldHVybiBDLnRleHREZWNvZGVyLmRlY29kZSh0aGlzLmJ1ZmZlci5zdWJhcnJheSh0aGlzLmluZGV4LHRoaXMuaW5kZXgrPUEpKTtjb25zdCBJPXRoaXMuaW5kZXgrQTtsZXQgZyxlPVwiXCI7Zm9yKDt0aGlzLmluZGV4PEk7KXtjb25zdCBBPXRoaXMuYnVmZmVyW3RoaXMuaW5kZXgrK107aWYoQTwxOTIpZz1BO2Vsc2V7Y29uc3QgST10aGlzLmJ1ZmZlclt0aGlzLmluZGV4KytdO2lmKEE8MjI0KWc9KDMxJkEpPDw2fDYzJkk7ZWxzZXtjb25zdCBlPXRoaXMuYnVmZmVyW3RoaXMuaW5kZXgrK107Zz1BPDI0MD8oMTUmQSk8PDEyfCg2MyZJKTw8Nnw2MyZlOig3JkEpPDwxOHwoNjMmSSk8PDEyfCg2MyZlKTw8Nnw2MyZ0aGlzLmJ1ZmZlclt0aGlzLmluZGV4KytdfX1nPDY1NTM2P2UrPVN0cmluZy5mcm9tQ2hhckNvZGUoZyk6KGctPTY1NTM2LGUrPVN0cmluZy5mcm9tQ2hhckNvZGUoNTUyOTYrKGc+PjEwKSw1NjMyMCsoMTAyMyZnKSkpfXJldHVybiB0aGlzLmluZGV4PUksZX13cml0ZVN0cmluZyhBKXtjb25zdCBJPUEubGVuZ3RoO2lmKDA9PT1JKXJldHVybiB2b2lkIHRoaXMud3JpdGVVaW50MzIoMCk7Y29uc3QgZz00KzMqSTt0aGlzLmd1YXJhbnRlZUJ1ZmZlckxlbmd0aCh0aGlzLmxlbmd0aCtnKTtsZXQgZT10aGlzLmxlbmd0aCs0O2NvbnN0IEI9ZTtsZXQgaTtmb3IobGV0IGc9MDtnPEk7ZysrKXtjb25zdCBCPUEuY2hhckNvZGVBdChnKTtpPWcrMT09PUl8fEI8NTUyOTZ8fEI+PTU2MzIwP0I6KEI8PDEwKStBLmNoYXJDb2RlQXQoKytnKSstNTY2MTM4ODgsaTwxMjg/dGhpcy5idWZmZXJbZSsrXT1pOihpPDIwNDg/dGhpcy5idWZmZXJbZSsrXT1pPj42JjMxfDE5MjooaTw2NTUzNj90aGlzLmJ1ZmZlcltlKytdPWk+PjEyJjE1fDIyNDoodGhpcy5idWZmZXJbZSsrXT1pPj4xOCY3fDI0MCx0aGlzLmJ1ZmZlcltlKytdPWk+PjEyJjYzfDEyOCksdGhpcy5idWZmZXJbZSsrXT1pPj42JjYzfDEyOCksdGhpcy5idWZmZXJbZSsrXT02MyZpfDEyOCl9Y29uc3QgUT1lLUI7dGhpcy52aWV3LnNldFVpbnQzMih0aGlzLmxlbmd0aCxRLCEwKSx0aGlzLmxlbmd0aCs9NCtRfXJlYWRHdWlkKCl7Y29uc3QgQT1RLEk9dGhpcy5idWZmZXIsZz10aGlzLmluZGV4LGU9XCItXCI7dmFyIEI9QVtJW2crM11dO3JldHVybiBCKz1BW0lbZysyXV0sQis9QVtJW2crMV1dLEIrPUFbSVtnXV0sQis9ZSxCKz1BW0lbZys1XV0sQis9QVtJW2crNF1dLEIrPWUsQis9QVtJW2crN11dLEIrPUFbSVtnKzZdXSxCKz1lLEIrPUFbSVtnKzhdXSxCKz1BW0lbZys5XV0sQis9ZSxCKz1BW0lbZysxMF1dLEIrPUFbSVtnKzExXV0sQis9QVtJW2crMTJdXSxCKz1BW0lbZysxM11dLEIrPUFbSVtnKzE0XV0sQis9QVtJW2crMTVdXSx0aGlzLmluZGV4Kz0xNixCfXdyaXRlR3VpZChBKXtjb25zdCBJPXRoaXMudmlldyxnPXRoaXMubGVuZ3RoO3RoaXMuZ3Jvd0J5KDE2KTt2YXIgZT0wLGk9MDtpPShpPShpPShpPShpPShpPShpPShpPWk8PDR8QltBLmNoYXJDb2RlQXQoZSsrKV0pPDw0fEJbQS5jaGFyQ29kZUF0KGUrKyldKTw8NHxCW0EuY2hhckNvZGVBdChlKyspXSk8PDR8QltBLmNoYXJDb2RlQXQoZSsrKV0pPDw0fEJbQS5jaGFyQ29kZUF0KGUrKyldKTw8NHxCW0EuY2hhckNvZGVBdChlKyspXSk8PDR8QltBLmNoYXJDb2RlQXQoZSsrKV0pPDw0fEJbQS5jaGFyQ29kZUF0KGUrKyldLGUrPTQ1PT09QS5jaGFyQ29kZUF0KGUpLEkuc2V0VWludDMyKGcsaSwhMCksaT0oaT0oaT0oaT1pPDw0fEJbQS5jaGFyQ29kZUF0KGUrKyldKTw8NHxCW0EuY2hhckNvZGVBdChlKyspXSk8PDR8QltBLmNoYXJDb2RlQXQoZSsrKV0pPDw0fEJbQS5jaGFyQ29kZUF0KGUrKyldLGUrPTQ1PT09QS5jaGFyQ29kZUF0KGUpLEkuc2V0VWludDE2KGcrNCxpLCEwKSxpPShpPShpPShpPWk8PDR8QltBLmNoYXJDb2RlQXQoZSsrKV0pPDw0fEJbQS5jaGFyQ29kZUF0KGUrKyldKTw8NHxCW0EuY2hhckNvZGVBdChlKyspXSk8PDR8QltBLmNoYXJDb2RlQXQoZSsrKV0sZSs9NDU9PT1BLmNoYXJDb2RlQXQoZSksSS5zZXRVaW50MTYoZys2LGksITApLGk9KGk9KGk9KGk9aTw8NHxCW0EuY2hhckNvZGVBdChlKyspXSk8PDR8QltBLmNoYXJDb2RlQXQoZSsrKV0pPDw0fEJbQS5jaGFyQ29kZUF0KGUrKyldKTw8NHxCW0EuY2hhckNvZGVBdChlKyspXSxlKz00NT09PUEuY2hhckNvZGVBdChlKSxpPShpPShpPShpPWk8PDR8QltBLmNoYXJDb2RlQXQoZSsrKV0pPDw0fEJbQS5jaGFyQ29kZUF0KGUrKyldKTw8NHxCW0EuY2hhckNvZGVBdChlKyspXSk8PDR8QltBLmNoYXJDb2RlQXQoZSsrKV0sSS5zZXRVaW50MzIoZys4LGksITEpLGk9KGk9KGk9KGk9KGk9KGk9KGk9KGk9aTw8NHxCW0EuY2hhckNvZGVBdChlKyspXSk8PDR8QltBLmNoYXJDb2RlQXQoZSsrKV0pPDw0fEJbQS5jaGFyQ29kZUF0KGUrKyldKTw8NHxCW0EuY2hhckNvZGVBdChlKyspXSk8PDR8QltBLmNoYXJDb2RlQXQoZSsrKV0pPDw0fEJbQS5jaGFyQ29kZUF0KGUrKyldKTw8NHxCW0EuY2hhckNvZGVBdChlKyspXSk8PDR8QltBLmNoYXJDb2RlQXQoZSsrKV0sSS5zZXRVaW50MzIoZysxMixpLCExKX1yZWFkRGF0ZSgpe2NvbnN0IEE9dGhpcy5yZWFkVWludDMyKCksST0xMDczNzQxODIzJnRoaXMucmVhZFVpbnQzMigpO3JldHVybiBuZXcgRGF0ZSg0Mjk0OTYuNzI5NipJKzFlLTQqQS02MjEzNTU5NjhlNSl9d3JpdGVEYXRlKEEpe2NvbnN0IEk9QS5nZXRUaW1lKCkrNjIxMzU1OTY4ZTUsZz1JJTQyOTQ5Ni43Mjk2KjFlNHwwLGU9SS80Mjk0OTYuNzI5NnwxMDczNzQxODI0O3RoaXMud3JpdGVVaW50MzIoZyksdGhpcy53cml0ZVVpbnQzMihlKX1yZXNlcnZlTWVzc2FnZUxlbmd0aCgpe2NvbnN0IEE9dGhpcy5sZW5ndGg7cmV0dXJuIHRoaXMuZ3Jvd0J5KDQpLEF9ZmlsbE1lc3NhZ2VMZW5ndGgoQSxJKXt0aGlzLnZpZXcuc2V0VWludDMyKEEsSSwhMCl9cmVhZE1lc3NhZ2VMZW5ndGgoKXtjb25zdCBBPXRoaXMudmlldy5nZXRVaW50MzIodGhpcy5pbmRleCwhMCk7cmV0dXJuIHRoaXMuaW5kZXgrPTQsQX19SS5CZWJvcFZpZXc9Q30sMjkwOmZ1bmN0aW9uKEEsSSxnKXtcInVzZSBzdHJpY3RcIjt2YXIgZT10aGlzJiZ0aGlzLl9fYXdhaXRlcnx8ZnVuY3Rpb24oQSxJLGcsZSl7cmV0dXJuIG5ldyhnfHwoZz1Qcm9taXNlKSkoKGZ1bmN0aW9uKEIsaSl7ZnVuY3Rpb24gUShBKXt0cnl7QyhlLm5leHQoQSkpfWNhdGNoKEEpe2koQSl9fWZ1bmN0aW9uIHQoQSl7dHJ5e0MoZS50aHJvdyhBKSl9Y2F0Y2goQSl7aShBKX19ZnVuY3Rpb24gQyhBKXt2YXIgSTtBLmRvbmU/QihBLnZhbHVlKTooST1BLnZhbHVlLEkgaW5zdGFuY2VvZiBnP0k6bmV3IGcoKGZ1bmN0aW9uKEEpe0EoSSl9KSkpLnRoZW4oUSx0KX1DKChlPWUuYXBwbHkoQSxJfHxbXSkpLm5leHQoKSl9KSl9O09iamVjdC5kZWZpbmVQcm9wZXJ0eShJLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLEkuZmV0Y2hOZXdQZWVySWQ9SS5nZXRPcmdhbml6YXRpb25JbmZvPXZvaWQgMDtjb25zdCBCPWcoNDY0KSxpPWcoOTk0KSxRPVwiaHR0cHM6Ly9hcGkucmFpbndheS5uZXR3b3JrL3YxXCI7SS5nZXRPcmdhbml6YXRpb25JbmZvPWZ1bmN0aW9uKEEpe3JldHVybiBlKHRoaXMsdm9pZCAwLHZvaWQgMCwoZnVuY3Rpb24qKCl7dHJ5e2NvbnN0IEk9eWllbGQgZmV0Y2goUStcIi9rZXlzL3ZhbGlkYXRlXCIse2hlYWRlcnM6e0F1dGhvcml6YXRpb246YEJlYXJlciAke0F9YH19KSxnPXlpZWxkIEkuanNvbigpO3JldHVybnt1bml2ZXJzZUZsYWc6Zy51bml2ZXJzZSxvcmdhbml6YXRpb25JZDpnLm9yZ19pZH19Y2F0Y2goQSl7dGhyb3cgQi5SYWlud2F5TG9nZ2luZy5lcnJvcihTdHJpbmcoQSkpLG5ldyBpLlJhaW53YXlFcnJvcihcIlRoZSBSYWlud2F5IEFQSSBrZXkgaXMgaW52YWxpZC5cIil9fSkpfSxJLmZldGNoTmV3UGVlcklkPWZ1bmN0aW9uKCl7cmV0dXJuIGUodGhpcyx2b2lkIDAsdm9pZCAwLChmdW5jdGlvbiooKXtjb25zdCBBPXlpZWxkIGZldGNoKFErXCIvZHJ1aWQvbmV4dFwiKTtyZXR1cm4gQmlnSW50KHlpZWxkIEEudGV4dCgpKX0pKX19LDQzNDooQSxJKT0+e1widXNlIHN0cmljdFwiO3ZhciBnLGU7T2JqZWN0LmRlZmluZVByb3BlcnR5KEksXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksSS5BdWRpb1JlYWR5U3RhdGU9SS5WaWRlb1JlYWR5U3RhdGU9dm9pZCAwLChlPUkuVmlkZW9SZWFkeVN0YXRlfHwoSS5WaWRlb1JlYWR5U3RhdGU9e30pKVtlLkRldGFjaGVkPTBdPVwiRGV0YWNoZWRcIixlW2UuSW5pdGlhbGl6aW5nPTFdPVwiSW5pdGlhbGl6aW5nXCIsZVtlLldhaXRpbmdGb3JLZXlmcmFtZT0yXT1cIldhaXRpbmdGb3JLZXlmcmFtZVwiLGVbZS5QbGF5aW5nPTNdPVwiUGxheWluZ1wiLGVbZS5QYXVzZWQ9NF09XCJQYXVzZWRcIixlW2UuRGlzcG9zZWQ9NV09XCJEaXNwb3NlZFwiLChnPUkuQXVkaW9SZWFkeVN0YXRlfHwoSS5BdWRpb1JlYWR5U3RhdGU9e30pKVtnLkRldGFjaGVkPTBdPVwiRGV0YWNoZWRcIixnW2cuVW5pbml0aWFsaXplZD0xXT1cIlVuaW5pdGlhbGl6ZWRcIixnW2cuSW5pdGlhbGl6aW5nPTJdPVwiSW5pdGlhbGl6aW5nXCIsZ1tnLlBsYXlpbmc9M109XCJQbGF5aW5nXCIsZ1tnLlBhdXNlZD00XT1cIlBhdXNlZFwifSw1Mjg6KEEsSSk9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkoSSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxJLmlzRGVza3RvcFNhZmFyaT12b2lkIDAsSS5pc0Rlc2t0b3BTYWZhcmk9L01hY2ludG9zaDsuKlNhZmFyaS8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSYmIS9DaHJvbWV8QW5kcm9pZC9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCl9LDk4NzooQSxJKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eShJLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLEkucmVhc3NlbWJsZT1JLmVhY2hDaHVuaz12b2lkIDA7bGV0IGc9MDtJLmVhY2hDaHVuaz1mdW5jdGlvbihBLEksZT0xNmUzKXtjb25zdCBCPU1hdGguY2VpbChBLmxlbmd0aC9lKSxpPSsrZztmb3IobGV0IGc9MDtnPEI7ZysrKXtjb25zdCBRPWcqZSx0PU1hdGgubWluKChnKzEpKmUsQS5sZW5ndGgpO0koe2NodW5rc0luR3JvdXA6Qixncm91cElkOmksaW5kZXg6ZyxkYXRhOkEuc2xpY2UoUSx0KX0pfX0sSS5yZWFzc2VtYmxlPWZ1bmN0aW9uKEEpe2xldCBJPTA7Y29uc3QgZz1BLmNodW5rcy5sZW5ndGg7Zm9yKGxldCBlPTA7ZTxnO2UrKylJKz1BLmNodW5rc1tlXS5ieXRlTGVuZ3RoO2NvbnN0IGU9bmV3IFVpbnQ4QXJyYXkoSSk7bGV0IEI9MDtmb3IobGV0IEk9MDtJPGc7SSsrKXtjb25zdCBnPUEuY2h1bmtzW0ldO2Uuc2V0KGcsQiksQis9Zy5ieXRlTGVuZ3RofXJldHVybiBlfX0sMjQ6KEEsSSk9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkoSSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxJLkFjdGlvbj12b2lkIDAsSS5BY3Rpb249Y2xhc3N7Y29uc3RydWN0b3IoKXt0aGlzLmhhbmRsZXJzPVtdfWFkZEhhbmRsZXIoQSl7dGhpcy5oYW5kbGVycy5wdXNoKEEpfXJlbW92ZUhhbmRsZXIoQSl7dGhpcy5oYW5kbGVycz10aGlzLmhhbmRsZXJzLmZpbHRlcigoST0+SSE9PUEpKX1pbnZva2UoQSl7Zm9yKGxldCBJPTA7STx0aGlzLmhhbmRsZXJzLmxlbmd0aDtJKyspdGhpcy5oYW5kbGVyc1tJXShBKX19fSw5MzA6KEEsSSk9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkoSSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxJLmJvdW5kaW5nUmVjdGFuZ2xlPXZvaWQgMCxJLmJvdW5kaW5nUmVjdGFuZ2xlPWZ1bmN0aW9uKEEpe2NvbnN0IEk9QS5sZW5ndGg7aWYoMD09PUkpdGhyb3cgbmV3IEVycm9yKFwiYm91bmRpbmdSZWN0YW5nbGUoKSBvZiAwIHJlY3RhbmdsZXNcIik7Y29uc3QgZz1BWzBdO2xldHtsZWZ0OmUsdG9wOkJ9PWcsaT1lK2cud2lkdGgsUT1CK2cuaGVpZ2h0O2ZvcihsZXQgZz0xO2c8STtnKyspe2NvbnN0IEk9QVtnXTtlPU1hdGgubWluKGUsSS5sZWZ0KSxCPU1hdGgubWluKEIsSS50b3ApLGk9TWF0aC5tYXgoaSxJLmxlZnQrSS53aWR0aCksUT1NYXRoLm1heChRLEkudG9wK0kuaGVpZ2h0KX1yZXR1cm57bGVmdDplLHRvcDpCLHdpZHRoOmktZSxoZWlnaHQ6US1CfX19LDE5ODooQSxJKT0+e1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIGcoQSl7aWYoMD09PUEubGVuZ3RoKXJldHVybiBOYU47bGV0IEk9MDtmb3IoY29uc3QgZyBvZiBBKUkrPWc7cmV0dXJuIEkvQS5sZW5ndGh9T2JqZWN0LmRlZmluZVByb3BlcnR5KEksXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksSS5tZWFuT3JaZXJvPUkubWVhbj1JLnN0YW5kYXJkRGV2aWF0aW9uPUkuaW50ZXJxdWFydGlsZVJhbmdlPUkubWVkaWFuPUkuV2luZG93VHJhY2s9dm9pZCAwLEkuV2luZG93VHJhY2s9Y2xhc3N7Y29uc3RydWN0b3IoQSxJKXt0aGlzLnNpemVNcz1BLHRoaXMuYXZlcmFnZU9wZXJhdGlvbj1JLHRoaXMuY2FjaGVkQXZlcmFnZT12b2lkIDAsdGhpcy5idWZmZXI9W119Z2V0IHZhbHVlcygpe3JldHVybiB0aGlzLnRyaW0oKSx0aGlzLmJ1ZmZlci5tYXAoKEE9PkEudmFsdWUpKX1nZXQgbWVhc3VyZW1lbnRzKCl7cmV0dXJuIHRoaXMudHJpbSgpLHRoaXMuYnVmZmVyfXRyaW0oKXtjb25zdCBBPXBlcmZvcm1hbmNlLm5vdygpLEk9dGhpcy5idWZmZXIuZmluZEluZGV4KChJPT5JLnRpbWU+QS10aGlzLnNpemVNcykpO0k+MD8odGhpcy5idWZmZXIuc3BsaWNlKDAsSSksdGhpcy5jYWNoZWRBdmVyYWdlPXZvaWQgMCk6LTE9PT1JJiYodGhpcy5idWZmZXIuc3BsaWNlKDAsdGhpcy5idWZmZXIubGVuZ3RoKSx0aGlzLmNhY2hlZEF2ZXJhZ2U9dm9pZCAwKX1mZWVkKEEpe2NvbnN0IEk9cGVyZm9ybWFuY2Uubm93KCk7dGhpcy5idWZmZXIucHVzaCh7dGltZTpJLHZhbHVlOkF9KSx0aGlzLmJ1ZmZlci5sZW5ndGg+PTUwMCYmdGhpcy50cmltKCksdGhpcy5jYWNoZWRBdmVyYWdlPXZvaWQgMH1hdmVyYWdlKCl7aWYodGhpcy50cmltKCksdGhpcy5jYWNoZWRBdmVyYWdlKXJldHVybiB0aGlzLmNhY2hlZEF2ZXJhZ2U7Y29uc3QgQT10aGlzLmJ1ZmZlci5tYXAoKEE9PkEudmFsdWUpKTtyZXR1cm4gdGhpcy5jYWNoZWRBdmVyYWdlPXRoaXMuYXZlcmFnZU9wZXJhdGlvbihBKX19LEkubWVkaWFuPWZ1bmN0aW9uKEEpe3JldHVybiAwPT09QS5sZW5ndGg/TmFOOihBLnNvcnQoKChBLEkpPT5BLUkpKSxBW01hdGguZmxvb3IoQS5sZW5ndGgvMildKX0sSS5pbnRlcnF1YXJ0aWxlUmFuZ2U9ZnVuY3Rpb24oQSl7aWYoMD09PUEubGVuZ3RoKXJldHVybiBOYU47QS5zb3J0KCgoQSxJKT0+QS1JKSk7Y29uc3QgST1NYXRoLmZsb29yKC4yNSpBLmxlbmd0aCk7cmV0dXJuIEFbTWF0aC5mbG9vciguNzUqQS5sZW5ndGgpXS1BW0ldfSxJLnN0YW5kYXJkRGV2aWF0aW9uPWZ1bmN0aW9uKEEpe2lmKDA9PT1BLmxlbmd0aClyZXR1cm4gTmFOO2NvbnN0IEk9QS5sZW5ndGgsZz1BLnJlZHVjZSgoKEEsSSk9PkErSSksMCkvSTtyZXR1cm4gTWF0aC5zcXJ0KEEubWFwKChBPT5NYXRoLnBvdyhBLWcsMikpKS5yZWR1Y2UoKChBLEkpPT5BK0kpLDApL0kpfSxJLm1lYW49ZyxJLm1lYW5Pclplcm89ZnVuY3Rpb24oQSl7cmV0dXJuIDA9PT1BLmxlbmd0aD8wOmcoQSl9fSw5MDQ6ZnVuY3Rpb24oQSxJLGcpe1widXNlIHN0cmljdFwiO3ZhciBlPXRoaXMmJnRoaXMuX19jcmVhdGVCaW5kaW5nfHwoT2JqZWN0LmNyZWF0ZT9mdW5jdGlvbihBLEksZyxlKXt2b2lkIDA9PT1lJiYoZT1nKSxPYmplY3QuZGVmaW5lUHJvcGVydHkoQSxlLHtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiBJW2ddfX0pfTpmdW5jdGlvbihBLEksZyxlKXt2b2lkIDA9PT1lJiYoZT1nKSxBW2VdPUlbZ119KSxCPXRoaXMmJnRoaXMuX19leHBvcnRTdGFyfHxmdW5jdGlvbihBLEkpe2Zvcih2YXIgZyBpbiBBKVwiZGVmYXVsdFwiPT09Z3x8T2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKEksZyl8fGUoSSxBLGcpfTtPYmplY3QuZGVmaW5lUHJvcGVydHkoSSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxCKGcoMTYyKSxJKX0sMTYyOihBLEksZyk9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkoSSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxJLldpbmRvd3NQb2ludGVyRmxhZ3M9SS5WaXJ0dWFsS2V5PUkuS2V5Ym9hcmRBY3Rpb249SS5TY3JvbGxBeGlzPUkuTW91c2VCdXR0b249SS5CdXR0b25BY3Rpb249SS5YSW5wdXRCdXR0b25zPUkuQXJiaXRyYXJ5RGF0YWdyYW09SS5NZWRpYURhdGFncmFtPUkuTG9naWNEYXRhZ3JhbT1JLklucHV0RGF0YWdyYW09SS5DaHVuaz1JLlJhaW53YXlIZWFkZXI9SS5HdWlkPUkuVGVsZW1ldHJ5VmFsdWVUeXBlPUkuUmFpbndheVRlbGVtZXRyeURpbWVuc2lvbj1JLlJhaW53YXlUZWxlbWV0cnlSZWNvcmQ9SS5SYWlud2F5VGVsZW1ldHJ5UmVxdWVzdD1JLlRlbGVtZXRyeUJhdGNoZXNLZXlUZW1wbGF0ZT1JLlRlbGVtZXRyeVNldEtleT1JLkdhdGV3YXlGb3J3YXJkYWJsZUJvZHk9SS5QZWVyU2lnbmFsaW5nSW5mb3JtYXRpb249SS5SZWplY3RlZENvbm5lY3Rpb25SZXF1ZXN0PUkuQWNjZXB0ZWRDb25uZWN0aW9uUmVxdWVzdD1JLkNvbm5lY3Rpb25SZXF1ZXN0PUkuR2F0ZXdheVJlc3BvbnNlQm9keT1JLkdhdGV3YXlIZWxsbz1JLkdhdGV3YXlSZXF1ZXN0Qm9keT1JLkluaXRDb25uZWN0aW9uUmVxdWVzdD1JLkdhdGV3YXlCb2R5PUkuR2F0ZXdheUZvcndhcmRhYmxlPUkuR2F0ZXdheUFsZXJ0PUkuR2F0ZXdheVJlc3BvbnNlPUkuR2F0ZXdheVJlcXVlc3Q9SS5HYXRld2F5RGF0YWdyYW09SS5HYXRld2F5SGVhZGVyPUkuUGVuZGluZ0Nvbm5lY3Rpb25SZXF1ZXN0PUkuUGVlcj1JLkdhdGV3YXlJZGVudGl0eT1JLkdhdGV3YXlUcnVuaz1JLlBlZXJJbmZvcm1hdGlvblR5cGU9SS5QZWVyVHJhbnNwb3J0VHlwZT1JLkdhdGV3YXlBbGVydERlc2NyaXB0aW9uPUkuR2F0ZXdheUFsZXJ0TGV2ZWw9SS5HYXRld2F5UmVzcG9uc2VDb250ZXh0PUkuUGVlclNldEtleVRlbXBsYXRlPUkuQWNjZXB0ZWRDb25uZWN0aW9uUmVxdWVzdEtleVRlbXBsYXRlPUkuUGVuZGluZ0Nvbm5lY3Rpb25SZXF1ZXN0S2V5VGVtcGxhdGU9SS5QZWVyS2V5VGVtcGxhdGU9SS5EYXRhZ3JhbUNoYW5uZWw9dm9pZCAwLEkuTG9naWNCb2R5PUkuSW5wdXRMZXZlbFJlcXVlc3Q9SS5JbnB1dExldmVsVXBkYXRlPUkuUmVqZWN0U3RyZWFtUmVxdWVzdD1JLlBhdXNlU3RyZWFtPUkuSm9pblN0cmVhbT1JLlZpZGVvQml0cmF0ZVJlcXVlc3Q9SS5LZXlmcmFtZVJlcXVlc3Q9SS5TdHJlYW1TdG9wcGluZz1JLkxlYXZlU3RyZWFtPUkuU3RyZWFtU3RhcnRpbmc9SS5TdHJlYW1SZXF1ZXN0PUkuRXJyb3JSZXNwb25zZT1JLkNsaWVudENhcGFiaWxpdGllcz1JLkNvZGVjUGFja1Jlc3BvbnNlPUkuQ29kZWNQYWNrUmVxdWVzdD1JLkRldmljZUluZm89SS5JbnB1dExldmVsPUkuVmlkZW9Db25maWc9SS5DYXB0dXJlTW9kZT1JLkF1ZGlvQ29uZmlnPUkuTG9naWNFcnJvcj1JLlZpZGVvQ29udGFpbmVyPUkuQXVkaW9Db250YWluZXI9SS5BdWRpb0NvZGVjPUkuQXVkaW9DaGFubmVscz1JLk5ldHdvcmtQcm90b2NvbD1JLk9wZXJhdGluZ1N5c3RlbT1JLkZvcm1GYWN0b3I9SS5WaWRlb0NvZGVjPUkuVmVuZG9yPUkuVmlkZW9Db2RlY1R5cGU9SS5JbnB1dEJvZHk9SS5TZXRDbGlwYm9hcmRUZXh0PUkuVmlld3BvcnRSZXNpemU9SS5QZW5BYnNvbHV0ZT1JLlRvdWNoZXNBYnNvbHV0ZT1JLkxvZ2ljYWxJbnB1dD1JLktleWJvYXJkSW5wdXQ9SS5Nb3VzZVNjcm9sbD1JLk1vdXNlQ2xpY2s9SS5Nb3VzZVJlbGF0aXZlPUkuTW91c2VBYnNvbHV0ZT1JLkdhbWVwYWRSdW1ibGU9SS5HYW1lcGFkUmVwb3J0PUkuVG91Y2hBYnNvbHV0ZT1JLlBlbkZsYWdzPUkuUGVuTWFzaz1JLlRvdWNoTWFzaz1JLlRvdWNoUGVuUG9pbnRlckluZm89dm9pZCAwLEkuTWVkaWFCb2R5PUkuTWVkaWFDaHVuaz1JLkF1ZGlvRGF0YT1JLlBvaW50ZXJEYXRhPUkuVmlkZW9EYXRhPUkuRGVza3RvcFJlY3Q9SS5BdWRpb0RhdGFUeXBlPUkuVmlkZW9EYXRhVHlwZT12b2lkIDA7Y29uc3QgZT1nKDEyMCk7dmFyIEIsaSxRLHQsQyxFLG8sYSxuLHMscixkLGgsYyxELHcseSx1LGwsUyxGLFIsRyxrLFUsTixtLHAsZjtJLkRhdGFncmFtQ2hhbm5lbD1cIm5ldHdvcms6ZGF0YWdyYW1zXCIsSS5QZWVyS2V5VGVtcGxhdGU9XCJuZXR3b3JrOnBlZXJzOnswfVwiLEkuUGVuZGluZ0Nvbm5lY3Rpb25SZXF1ZXN0S2V5VGVtcGxhdGU9XCJuZXR3b3JrOmNvbm5lY3Rpb24ucmVxdWVzdHM6cGVuZGluZzp7MH1cIixJLkFjY2VwdGVkQ29ubmVjdGlvblJlcXVlc3RLZXlUZW1wbGF0ZT1cIm5ldHdvcms6Y29ubmVjdGlvbi5yZXF1ZXN0czphY2NlcHRlZDp7MH1cIixJLlBlZXJTZXRLZXlUZW1wbGF0ZT1cIm5ldHdvcms6YWN0aXZlLnBlZXJzOnswfVwiLEkuR2F0ZXdheVJlc3BvbnNlQ29udGV4dD17ZW5jb2RlKEEpe2NvbnN0IEk9ZS5CZWJvcFZpZXcuZ2V0SW5zdGFuY2UoKTtyZXR1cm4gSS5zdGFydFdyaXRpbmcoKSx0aGlzLmVuY29kZUludG8oQSxJKSxJLnRvQXJyYXkoKX0sZW5jb2RlSW50byhBLGcpe2NvbnN0IGU9Zy5sZW5ndGg7cmV0dXJuIGcud3JpdGVJbnQ2NChBLnNvdXJjZVBlZXJJZCksZy53cml0ZUludDY0KEEudGFyZ2V0UGVlcklkKSxJLkdhdGV3YXlEYXRhZ3JhbS5lbmNvZGVJbnRvKEEuZGF0YWdyYW0sZyksZy5sZW5ndGgtZX0sZGVjb2RlKEEpe2NvbnN0IEk9ZS5CZWJvcFZpZXcuZ2V0SW5zdGFuY2UoKTtyZXR1cm4gSS5zdGFydFJlYWRpbmcoQSksdGhpcy5yZWFkRnJvbShJKX0scmVhZEZyb20oQSl7bGV0IGcsZSxCO3JldHVybiBnPUEucmVhZEludDY0KCksZT1BLnJlYWRJbnQ2NCgpLEI9SS5HYXRld2F5RGF0YWdyYW0ucmVhZEZyb20oQSkse3NvdXJjZVBlZXJJZDpnLHRhcmdldFBlZXJJZDplLGRhdGFncmFtOkJ9fX0sKGY9SS5HYXRld2F5QWxlcnRMZXZlbHx8KEkuR2F0ZXdheUFsZXJ0TGV2ZWw9e30pKVtmLlVua25vd249MF09XCJVbmtub3duXCIsZltmLldhcm5pbmc9MV09XCJXYXJuaW5nXCIsZltmLkZhdGFsPTJdPVwiRmF0YWxcIiwocD1JLkdhdGV3YXlBbGVydERlc2NyaXB0aW9ufHwoSS5HYXRld2F5QWxlcnREZXNjcmlwdGlvbj17fSkpW3AuQ2xvc2VOb3RpZnk9MF09XCJDbG9zZU5vdGlmeVwiLHBbcC5VbmV4cGVjdGVkTWVzc2FnZT0xMF09XCJVbmV4cGVjdGVkTWVzc2FnZVwiLHBbcC5SZWNvcmRPdmVyZmxvdz0yMF09XCJSZWNvcmRPdmVyZmxvd1wiLHBbcC5UaWNrZXRWYWxpZGF0aW9uRXJyb3I9MzBdPVwiVGlja2V0VmFsaWRhdGlvbkVycm9yXCIscFtwLkFjY2Vzc0RlbmllZD00OV09XCJBY2Nlc3NEZW5pZWRcIixwW3AuRGVjb2RlRXJyb3I9NTBdPVwiRGVjb2RlRXJyb3JcIixwW3AuRGVjcnlwdEVycm9yPTUxXT1cIkRlY3J5cHRFcnJvclwiLHBbcC5Qcm90b2NvbFZlcnNpb249NzBdPVwiUHJvdG9jb2xWZXJzaW9uXCIscFtwLkludGVybmFsRXJyb3I9ODBdPVwiSW50ZXJuYWxFcnJvclwiLHBbcC5QZWVyR29uZUF3YXk9OTBdPVwiUGVlckdvbmVBd2F5XCIscFtwLkNvbW1pdEZhaWx1cmU9MTAwXT1cIkNvbW1pdEZhaWx1cmVcIixwW3AuUmVzb3VyY2VFeHBpcmVkPTIwMF09XCJSZXNvdXJjZUV4cGlyZWRcIiwobT1JLlBlZXJUcmFuc3BvcnRUeXBlfHwoSS5QZWVyVHJhbnNwb3J0VHlwZT17fSkpW20uSW52YWxpZD0wXT1cIkludmFsaWRcIixtW20uU0NUUD0xXT1cIlNDVFBcIixtW20uR1VEUD0yXT1cIkdVRFBcIixtW20uUmVzZXJ2ZWQ9M109XCJSZXNlcnZlZFwiLChOPUkuUGVlckluZm9ybWF0aW9uVHlwZXx8KEkuUGVlckluZm9ybWF0aW9uVHlwZT17fSkpW04uSW52YWxpZD0wXT1cIkludmFsaWRcIixOW04uT2ZmZXI9MV09XCJPZmZlclwiLE5bTi5BbnN3ZXI9Ml09XCJBbnN3ZXJcIixOW04uQ2FuZGlkYXRlPTNdPVwiQ2FuZGlkYXRlXCIsSS5HYXRld2F5VHJ1bms9e2VuY29kZShBKXtjb25zdCBJPWUuQmVib3BWaWV3LmdldEluc3RhbmNlKCk7cmV0dXJuIEkuc3RhcnRXcml0aW5nKCksdGhpcy5lbmNvZGVJbnRvKEEsSSksSS50b0FycmF5KCl9LGVuY29kZUludG8oQSxJKXtjb25zdCBnPUkubGVuZ3RoO3JldHVybiBJLndyaXRlU3RyaW5nKEEubWFjaGluZUlkKSxJLndyaXRlRGF0ZShBLnN0YXJ0RGF0ZSksSS5sZW5ndGgtZ30sZGVjb2RlKEEpe2NvbnN0IEk9ZS5CZWJvcFZpZXcuZ2V0SW5zdGFuY2UoKTtyZXR1cm4gSS5zdGFydFJlYWRpbmcoQSksdGhpcy5yZWFkRnJvbShJKX0scmVhZEZyb20oQSl7bGV0IEksZztyZXR1cm4gST1BLnJlYWRTdHJpbmcoKSxnPUEucmVhZERhdGUoKSx7bWFjaGluZUlkOkksc3RhcnREYXRlOmd9fX0sSS5HYXRld2F5SWRlbnRpdHk9e2VuY29kZShBKXtjb25zdCBJPWUuQmVib3BWaWV3LmdldEluc3RhbmNlKCk7cmV0dXJuIEkuc3RhcnRXcml0aW5nKCksdGhpcy5lbmNvZGVJbnRvKEEsSSksSS50b0FycmF5KCl9LGVuY29kZUludG8oQSxJKXtjb25zdCBnPUkubGVuZ3RoO3JldHVybiBJLndyaXRlU3RyaW5nKEEuYXBpS2V5KSxJLndyaXRlSW50NjQoQS5pZCksSS53cml0ZVN0cmluZyhBLmV4dGVybmFsSWQpLEkubGVuZ3RoLWd9LGRlY29kZShBKXtjb25zdCBJPWUuQmVib3BWaWV3LmdldEluc3RhbmNlKCk7cmV0dXJuIEkuc3RhcnRSZWFkaW5nKEEpLHRoaXMucmVhZEZyb20oSSl9LHJlYWRGcm9tKEEpe2xldCBJLGcsZTtyZXR1cm4gST1BLnJlYWRTdHJpbmcoKSxnPUEucmVhZEludDY0KCksZT1BLnJlYWRTdHJpbmcoKSx7YXBpS2V5OkksaWQ6ZyxleHRlcm5hbElkOmV9fX0sSS5QZWVyPXtlbmNvZGUoQSl7Y29uc3QgST1lLkJlYm9wVmlldy5nZXRJbnN0YW5jZSgpO3JldHVybiBJLnN0YXJ0V3JpdGluZygpLHRoaXMuZW5jb2RlSW50byhBLEkpLEkudG9BcnJheSgpfSxlbmNvZGVJbnRvKEEsSSl7Y29uc3QgZz1JLmxlbmd0aDtyZXR1cm4gSS53cml0ZUludDY0KEEuaWQpLEkud3JpdGVTdHJpbmcoQS5leHRlcm5hbElkKSxJLndyaXRlRGF0ZShBLmNvbm5lY3Rpb25EYXRlKSxJLndyaXRlSW50NjQoQS5vcmdhbml6YXRpb25JZCksSS5sZW5ndGgtZ30sZGVjb2RlKEEpe2NvbnN0IEk9ZS5CZWJvcFZpZXcuZ2V0SW5zdGFuY2UoKTtyZXR1cm4gSS5zdGFydFJlYWRpbmcoQSksdGhpcy5yZWFkRnJvbShJKX0scmVhZEZyb20oQSl7bGV0IEksZyxlLEI7cmV0dXJuIEk9QS5yZWFkSW50NjQoKSxnPUEucmVhZFN0cmluZygpLGU9QS5yZWFkRGF0ZSgpLEI9QS5yZWFkSW50NjQoKSx7aWQ6SSxleHRlcm5hbElkOmcsY29ubmVjdGlvbkRhdGU6ZSxvcmdhbml6YXRpb25JZDpCfX19LEkuUGVuZGluZ0Nvbm5lY3Rpb25SZXF1ZXN0PXtlbmNvZGUoQSl7Y29uc3QgST1lLkJlYm9wVmlldy5nZXRJbnN0YW5jZSgpO3JldHVybiBJLnN0YXJ0V3JpdGluZygpLHRoaXMuZW5jb2RlSW50byhBLEkpLEkudG9BcnJheSgpfSxlbmNvZGVJbnRvKEEsSSl7Y29uc3QgZz1JLmxlbmd0aDtyZXR1cm4gSS53cml0ZUludDY0KEEuc291cmNlUGVlcklkKSxJLndyaXRlSW50NjQoQS50YXJnZXRQZWVySWQpLEkubGVuZ3RoLWd9LGRlY29kZShBKXtjb25zdCBJPWUuQmVib3BWaWV3LmdldEluc3RhbmNlKCk7cmV0dXJuIEkuc3RhcnRSZWFkaW5nKEEpLHRoaXMucmVhZEZyb20oSSl9LHJlYWRGcm9tKEEpe2xldCBJLGc7cmV0dXJuIEk9QS5yZWFkSW50NjQoKSxnPUEucmVhZEludDY0KCkse3NvdXJjZVBlZXJJZDpJLHRhcmdldFBlZXJJZDpnfX19LEkuR2F0ZXdheUhlYWRlcj17ZW5jb2RlKEEpe2NvbnN0IEk9ZS5CZWJvcFZpZXcuZ2V0SW5zdGFuY2UoKTtyZXR1cm4gSS5zdGFydFdyaXRpbmcoKSx0aGlzLmVuY29kZUludG8oQSxJKSxJLnRvQXJyYXkoKX0sZW5jb2RlSW50byhBLEkpe2NvbnN0IGc9SS5sZW5ndGg7cmV0dXJuIEkud3JpdGVVaW50MzIoQS5zeW5jS2V5KSxJLmxlbmd0aC1nfSxkZWNvZGUoQSl7Y29uc3QgST1lLkJlYm9wVmlldy5nZXRJbnN0YW5jZSgpO3JldHVybiBJLnN0YXJ0UmVhZGluZyhBKSx0aGlzLnJlYWRGcm9tKEkpfSxyZWFkRnJvbShBKXtsZXQgSTtyZXR1cm4gST1BLnJlYWRVaW50MzIoKSx7c3luY0tleTpJfX19LEkuR2F0ZXdheURhdGFncmFtPXtlbmNvZGUoQSl7Y29uc3QgST1lLkJlYm9wVmlldy5nZXRJbnN0YW5jZSgpO3JldHVybiBJLnN0YXJ0V3JpdGluZygpLHRoaXMuZW5jb2RlSW50byhBLEkpLEkudG9BcnJheSgpfSxlbmNvZGVJbnRvKEEsZyl7Y29uc3QgZT1nLmxlbmd0aDtyZXR1cm4gSS5HYXRld2F5SGVhZGVyLmVuY29kZUludG8oQS5oZWFkZXIsZyksSS5HYXRld2F5Qm9keS5lbmNvZGVJbnRvKEEuYm9keSxnKSxnLmxlbmd0aC1lfSxkZWNvZGUoQSl7Y29uc3QgST1lLkJlYm9wVmlldy5nZXRJbnN0YW5jZSgpO3JldHVybiBJLnN0YXJ0UmVhZGluZyhBKSx0aGlzLnJlYWRGcm9tKEkpfSxyZWFkRnJvbShBKXtsZXQgZyxlO3JldHVybiBnPUkuR2F0ZXdheUhlYWRlci5yZWFkRnJvbShBKSxlPUkuR2F0ZXdheUJvZHkucmVhZEZyb20oQSkse2hlYWRlcjpnLGJvZHk6ZX19fSxJLkdhdGV3YXlSZXF1ZXN0PXtkaXNjcmltaW5hdG9yOjEsZW5jb2RlKEEpe2NvbnN0IEk9ZS5CZWJvcFZpZXcuZ2V0SW5zdGFuY2UoKTtyZXR1cm4gSS5zdGFydFdyaXRpbmcoKSx0aGlzLmVuY29kZUludG8oQSxJKSxJLnRvQXJyYXkoKX0sZW5jb2RlSW50byhBLGcpe2NvbnN0IGU9Zy5sZW5ndGg7cmV0dXJuIEkuR2F0ZXdheVJlcXVlc3RCb2R5LmVuY29kZUludG8oQS5ib2R5LGcpLGcubGVuZ3RoLWV9LGRlY29kZShBKXtjb25zdCBJPWUuQmVib3BWaWV3LmdldEluc3RhbmNlKCk7cmV0dXJuIEkuc3RhcnRSZWFkaW5nKEEpLHRoaXMucmVhZEZyb20oSSl9LHJlYWRGcm9tKEEpe2xldCBnO3JldHVybiBnPUkuR2F0ZXdheVJlcXVlc3RCb2R5LnJlYWRGcm9tKEEpLHtib2R5Omd9fX0sSS5HYXRld2F5UmVzcG9uc2U9e2Rpc2NyaW1pbmF0b3I6MixlbmNvZGUoQSl7Y29uc3QgST1lLkJlYm9wVmlldy5nZXRJbnN0YW5jZSgpO3JldHVybiBJLnN0YXJ0V3JpdGluZygpLHRoaXMuZW5jb2RlSW50byhBLEkpLEkudG9BcnJheSgpfSxlbmNvZGVJbnRvKEEsZyl7Y29uc3QgZT1nLmxlbmd0aDtyZXR1cm4gSS5HYXRld2F5UmVzcG9uc2VCb2R5LmVuY29kZUludG8oQS5ib2R5LGcpLGcubGVuZ3RoLWV9LGRlY29kZShBKXtjb25zdCBJPWUuQmVib3BWaWV3LmdldEluc3RhbmNlKCk7cmV0dXJuIEkuc3RhcnRSZWFkaW5nKEEpLHRoaXMucmVhZEZyb20oSSl9LHJlYWRGcm9tKEEpe2xldCBnO3JldHVybiBnPUkuR2F0ZXdheVJlc3BvbnNlQm9keS5yZWFkRnJvbShBKSx7Ym9keTpnfX19LEkuR2F0ZXdheUFsZXJ0PXtkaXNjcmltaW5hdG9yOjMsZW5jb2RlKEEpe2NvbnN0IEk9ZS5CZWJvcFZpZXcuZ2V0SW5zdGFuY2UoKTtyZXR1cm4gSS5zdGFydFdyaXRpbmcoKSx0aGlzLmVuY29kZUludG8oQSxJKSxJLnRvQXJyYXkoKX0sZW5jb2RlSW50byhBLEkpe2NvbnN0IGc9SS5sZW5ndGg7cmV0dXJuIEkud3JpdGVVaW50MzIoQS5sZXZlbCksSS53cml0ZVVpbnQzMihBLmRlc2NyaXB0aW9uKSxJLmxlbmd0aC1nfSxkZWNvZGUoQSl7Y29uc3QgST1lLkJlYm9wVmlldy5nZXRJbnN0YW5jZSgpO3JldHVybiBJLnN0YXJ0UmVhZGluZyhBKSx0aGlzLnJlYWRGcm9tKEkpfSxyZWFkRnJvbShBKXtsZXQgSSxnO3JldHVybiBJPUEucmVhZFVpbnQzMigpLGc9QS5yZWFkVWludDMyKCkse2xldmVsOkksZGVzY3JpcHRpb246Z319fSxJLkdhdGV3YXlGb3J3YXJkYWJsZT17ZGlzY3JpbWluYXRvcjo0LGVuY29kZShBKXtjb25zdCBJPWUuQmVib3BWaWV3LmdldEluc3RhbmNlKCk7cmV0dXJuIEkuc3RhcnRXcml0aW5nKCksdGhpcy5lbmNvZGVJbnRvKEEsSSksSS50b0FycmF5KCl9LGVuY29kZUludG8oQSxnKXtjb25zdCBlPWcubGVuZ3RoO3JldHVybiBnLndyaXRlSW50NjQoQS50YXJnZXRQZWVySWQpLEkuR2F0ZXdheUZvcndhcmRhYmxlQm9keS5lbmNvZGVJbnRvKEEuYm9keSxnKSxnLmxlbmd0aC1lfSxkZWNvZGUoQSl7Y29uc3QgST1lLkJlYm9wVmlldy5nZXRJbnN0YW5jZSgpO3JldHVybiBJLnN0YXJ0UmVhZGluZyhBKSx0aGlzLnJlYWRGcm9tKEkpfSxyZWFkRnJvbShBKXtsZXQgZyxlO3JldHVybiBnPUEucmVhZEludDY0KCksZT1JLkdhdGV3YXlGb3J3YXJkYWJsZUJvZHkucmVhZEZyb20oQSkse3RhcmdldFBlZXJJZDpnLGJvZHk6ZX19fSxJLkdhdGV3YXlCb2R5PXtlbmNvZGUoQSl7Y29uc3QgST1lLkJlYm9wVmlldy5nZXRJbnN0YW5jZSgpO3JldHVybiBJLnN0YXJ0V3JpdGluZygpLHRoaXMuZW5jb2RlSW50byhBLEkpLEkudG9BcnJheSgpfSxlbmNvZGVJbnRvKEEsZyl7Y29uc3QgZT1nLmxlbmd0aCxCPWcucmVzZXJ2ZU1lc3NhZ2VMZW5ndGgoKSxpPWcubGVuZ3RoKzE7c3dpdGNoKGcud3JpdGVCeXRlKEEuZGlzY3JpbWluYXRvciksQS5kaXNjcmltaW5hdG9yKXtjYXNlIDE6SS5HYXRld2F5UmVxdWVzdC5lbmNvZGVJbnRvKEEudmFsdWUsZyk7YnJlYWs7Y2FzZSAyOkkuR2F0ZXdheVJlc3BvbnNlLmVuY29kZUludG8oQS52YWx1ZSxnKTticmVhaztjYXNlIDM6SS5HYXRld2F5QWxlcnQuZW5jb2RlSW50byhBLnZhbHVlLGcpO2JyZWFrO2Nhc2UgNDpJLkdhdGV3YXlGb3J3YXJkYWJsZS5lbmNvZGVJbnRvKEEudmFsdWUsZyl9Y29uc3QgUT1nLmxlbmd0aDtyZXR1cm4gZy5maWxsTWVzc2FnZUxlbmd0aChCLFEtaSksZy5sZW5ndGgtZX0sZGVjb2RlKEEpe2NvbnN0IEk9ZS5CZWJvcFZpZXcuZ2V0SW5zdGFuY2UoKTtyZXR1cm4gSS5zdGFydFJlYWRpbmcoQSksdGhpcy5yZWFkRnJvbShJKX0scmVhZEZyb20oQSl7Y29uc3QgZz1BLnJlYWRNZXNzYWdlTGVuZ3RoKCksQj1BLmluZGV4KzErZztzd2l0Y2goQS5yZWFkQnl0ZSgpKXtjYXNlIDE6cmV0dXJue2Rpc2NyaW1pbmF0b3I6MSx2YWx1ZTpJLkdhdGV3YXlSZXF1ZXN0LnJlYWRGcm9tKEEpfTtjYXNlIDI6cmV0dXJue2Rpc2NyaW1pbmF0b3I6Mix2YWx1ZTpJLkdhdGV3YXlSZXNwb25zZS5yZWFkRnJvbShBKX07Y2FzZSAzOnJldHVybntkaXNjcmltaW5hdG9yOjMsdmFsdWU6SS5HYXRld2F5QWxlcnQucmVhZEZyb20oQSl9O2Nhc2UgNDpyZXR1cm57ZGlzY3JpbWluYXRvcjo0LHZhbHVlOkkuR2F0ZXdheUZvcndhcmRhYmxlLnJlYWRGcm9tKEEpfTtkZWZhdWx0OnRocm93IEEuaW5kZXg9QixuZXcgZS5CZWJvcFJ1bnRpbWVFcnJvcihcIlVucmVjb2duaXplZCBkaXNjcmltaW5hdG9yIHdoaWxlIGRlY29kaW5nIEdhdGV3YXlCb2R5XCIpfX19LEkuSW5pdENvbm5lY3Rpb25SZXF1ZXN0PXtkaXNjcmltaW5hdG9yOjEsZW5jb2RlKEEpe2NvbnN0IEk9ZS5CZWJvcFZpZXcuZ2V0SW5zdGFuY2UoKTtyZXR1cm4gSS5zdGFydFdyaXRpbmcoKSx0aGlzLmVuY29kZUludG8oQSxJKSxJLnRvQXJyYXkoKX0sZW5jb2RlSW50byhBLEkpe2NvbnN0IGc9SS5sZW5ndGg7cmV0dXJuIEkud3JpdGVJbnQ2NChBLnRhcmdldFBlZXJJZCksSS53cml0ZVVpbnQzMihBLmRlc2lyZWRUcmFuc3BvcnQpLEkubGVuZ3RoLWd9LGRlY29kZShBKXtjb25zdCBJPWUuQmVib3BWaWV3LmdldEluc3RhbmNlKCk7cmV0dXJuIEkuc3RhcnRSZWFkaW5nKEEpLHRoaXMucmVhZEZyb20oSSl9LHJlYWRGcm9tKEEpe2xldCBJLGc7cmV0dXJuIEk9QS5yZWFkSW50NjQoKSxnPUEucmVhZFVpbnQzMigpLHt0YXJnZXRQZWVySWQ6SSxkZXNpcmVkVHJhbnNwb3J0Omd9fX0sSS5HYXRld2F5UmVxdWVzdEJvZHk9e2VuY29kZShBKXtjb25zdCBJPWUuQmVib3BWaWV3LmdldEluc3RhbmNlKCk7cmV0dXJuIEkuc3RhcnRXcml0aW5nKCksdGhpcy5lbmNvZGVJbnRvKEEsSSksSS50b0FycmF5KCl9LGVuY29kZUludG8oQSxnKXtjb25zdCBlPWcubGVuZ3RoLEI9Zy5yZXNlcnZlTWVzc2FnZUxlbmd0aCgpLGk9Zy5sZW5ndGgrMTtnLndyaXRlQnl0ZShBLmRpc2NyaW1pbmF0b3IpLDE9PT1BLmRpc2NyaW1pbmF0b3ImJkkuSW5pdENvbm5lY3Rpb25SZXF1ZXN0LmVuY29kZUludG8oQS52YWx1ZSxnKTtjb25zdCBRPWcubGVuZ3RoO3JldHVybiBnLmZpbGxNZXNzYWdlTGVuZ3RoKEIsUS1pKSxnLmxlbmd0aC1lfSxkZWNvZGUoQSl7Y29uc3QgST1lLkJlYm9wVmlldy5nZXRJbnN0YW5jZSgpO3JldHVybiBJLnN0YXJ0UmVhZGluZyhBKSx0aGlzLnJlYWRGcm9tKEkpfSxyZWFkRnJvbShBKXtjb25zdCBnPUEucmVhZE1lc3NhZ2VMZW5ndGgoKSxCPUEuaW5kZXgrMStnO2lmKDE9PT1BLnJlYWRCeXRlKCkpcmV0dXJue2Rpc2NyaW1pbmF0b3I6MSx2YWx1ZTpJLkluaXRDb25uZWN0aW9uUmVxdWVzdC5yZWFkRnJvbShBKX07dGhyb3cgQS5pbmRleD1CLG5ldyBlLkJlYm9wUnVudGltZUVycm9yKFwiVW5yZWNvZ25pemVkIGRpc2NyaW1pbmF0b3Igd2hpbGUgZGVjb2RpbmcgR2F0ZXdheVJlcXVlc3RCb2R5XCIpfX0sSS5HYXRld2F5SGVsbG89e2Rpc2NyaW1pbmF0b3I6MSxlbmNvZGUoQSl7Y29uc3QgST1lLkJlYm9wVmlldy5nZXRJbnN0YW5jZSgpO3JldHVybiBJLnN0YXJ0V3JpdGluZygpLHRoaXMuZW5jb2RlSW50byhBLEkpLEkudG9BcnJheSgpfSxlbmNvZGVJbnRvKEEsSSl7Y29uc3QgZz1JLmxlbmd0aDtyZXR1cm4gSS5sZW5ndGgtZ30sZGVjb2RlKEEpe2NvbnN0IEk9ZS5CZWJvcFZpZXcuZ2V0SW5zdGFuY2UoKTtyZXR1cm4gSS5zdGFydFJlYWRpbmcoQSksdGhpcy5yZWFkRnJvbShJKX0scmVhZEZyb206QT0+KHt9KX0sSS5HYXRld2F5UmVzcG9uc2VCb2R5PXtlbmNvZGUoQSl7Y29uc3QgST1lLkJlYm9wVmlldy5nZXRJbnN0YW5jZSgpO3JldHVybiBJLnN0YXJ0V3JpdGluZygpLHRoaXMuZW5jb2RlSW50byhBLEkpLEkudG9BcnJheSgpfSxlbmNvZGVJbnRvKEEsZyl7Y29uc3QgZT1nLmxlbmd0aCxCPWcucmVzZXJ2ZU1lc3NhZ2VMZW5ndGgoKSxpPWcubGVuZ3RoKzE7Zy53cml0ZUJ5dGUoQS5kaXNjcmltaW5hdG9yKSwxPT09QS5kaXNjcmltaW5hdG9yJiZJLkdhdGV3YXlIZWxsby5lbmNvZGVJbnRvKEEudmFsdWUsZyk7Y29uc3QgUT1nLmxlbmd0aDtyZXR1cm4gZy5maWxsTWVzc2FnZUxlbmd0aChCLFEtaSksZy5sZW5ndGgtZX0sZGVjb2RlKEEpe2NvbnN0IEk9ZS5CZWJvcFZpZXcuZ2V0SW5zdGFuY2UoKTtyZXR1cm4gSS5zdGFydFJlYWRpbmcoQSksdGhpcy5yZWFkRnJvbShJKX0scmVhZEZyb20oQSl7Y29uc3QgZz1BLnJlYWRNZXNzYWdlTGVuZ3RoKCksQj1BLmluZGV4KzErZztpZigxPT09QS5yZWFkQnl0ZSgpKXJldHVybntkaXNjcmltaW5hdG9yOjEsdmFsdWU6SS5HYXRld2F5SGVsbG8ucmVhZEZyb20oQSl9O3Rocm93IEEuaW5kZXg9QixuZXcgZS5CZWJvcFJ1bnRpbWVFcnJvcihcIlVucmVjb2duaXplZCBkaXNjcmltaW5hdG9yIHdoaWxlIGRlY29kaW5nIEdhdGV3YXlSZXNwb25zZUJvZHlcIil9fSxJLkNvbm5lY3Rpb25SZXF1ZXN0PXtkaXNjcmltaW5hdG9yOjEsZW5jb2RlKEEpe2NvbnN0IEk9ZS5CZWJvcFZpZXcuZ2V0SW5zdGFuY2UoKTtyZXR1cm4gSS5zdGFydFdyaXRpbmcoKSx0aGlzLmVuY29kZUludG8oQSxJKSxJLnRvQXJyYXkoKX0sZW5jb2RlSW50byhBLEkpe2NvbnN0IGc9SS5sZW5ndGg7cmV0dXJuIEkud3JpdGVJbnQ2NChBLnNvdXJjZVBlZXJJZCksSS53cml0ZVN0cmluZyhBLnNvdXJjZUV4dGVybmFsSWQpLEkud3JpdGVVaW50MzIoQS5kZXNpcmVkVHJhbnNwb3J0KSxJLndyaXRlR3VpZChBLmlkKSxJLndyaXRlRGF0ZShBLmV4cGlyYXRpb25EYXRlKSxJLmxlbmd0aC1nfSxkZWNvZGUoQSl7Y29uc3QgST1lLkJlYm9wVmlldy5nZXRJbnN0YW5jZSgpO3JldHVybiBJLnN0YXJ0UmVhZGluZyhBKSx0aGlzLnJlYWRGcm9tKEkpfSxyZWFkRnJvbShBKXtsZXQgSSxnLGUsQixpO3JldHVybiBJPUEucmVhZEludDY0KCksZz1BLnJlYWRTdHJpbmcoKSxlPUEucmVhZFVpbnQzMigpLEI9QS5yZWFkR3VpZCgpLGk9QS5yZWFkRGF0ZSgpLHtzb3VyY2VQZWVySWQ6SSxzb3VyY2VFeHRlcm5hbElkOmcsZGVzaXJlZFRyYW5zcG9ydDplLGlkOkIsZXhwaXJhdGlvbkRhdGU6aX19fSxJLkFjY2VwdGVkQ29ubmVjdGlvblJlcXVlc3Q9e2Rpc2NyaW1pbmF0b3I6MixlbmNvZGUoQSl7Y29uc3QgST1lLkJlYm9wVmlldy5nZXRJbnN0YW5jZSgpO3JldHVybiBJLnN0YXJ0V3JpdGluZygpLHRoaXMuZW5jb2RlSW50byhBLEkpLEkudG9BcnJheSgpfSxlbmNvZGVJbnRvKEEsSSl7Y29uc3QgZz1JLmxlbmd0aDtyZXR1cm4gSS53cml0ZUludDY0KEEuc291cmNlUGVlcklkKSxJLndyaXRlU3RyaW5nKEEuc291cmNlRXh0ZXJuYWxJZCksSS53cml0ZUd1aWQoQS5pZCksSS5sZW5ndGgtZ30sZGVjb2RlKEEpe2NvbnN0IEk9ZS5CZWJvcFZpZXcuZ2V0SW5zdGFuY2UoKTtyZXR1cm4gSS5zdGFydFJlYWRpbmcoQSksdGhpcy5yZWFkRnJvbShJKX0scmVhZEZyb20oQSl7bGV0IEksZyxlO3JldHVybiBJPUEucmVhZEludDY0KCksZz1BLnJlYWRTdHJpbmcoKSxlPUEucmVhZEd1aWQoKSx7c291cmNlUGVlcklkOkksc291cmNlRXh0ZXJuYWxJZDpnLGlkOmV9fX0sSS5SZWplY3RlZENvbm5lY3Rpb25SZXF1ZXN0PXtkaXNjcmltaW5hdG9yOjMsZW5jb2RlKEEpe2NvbnN0IEk9ZS5CZWJvcFZpZXcuZ2V0SW5zdGFuY2UoKTtyZXR1cm4gSS5zdGFydFdyaXRpbmcoKSx0aGlzLmVuY29kZUludG8oQSxJKSxJLnRvQXJyYXkoKX0sZW5jb2RlSW50byhBLEkpe2NvbnN0IGc9SS5sZW5ndGg7cmV0dXJuIEkud3JpdGVJbnQ2NChBLnNvdXJjZVBlZXJJZCksSS53cml0ZVN0cmluZyhBLnNvdXJjZUV4dGVybmFsSWQpLEkud3JpdGVHdWlkKEEuaWQpLEkud3JpdGVTdHJpbmcoQS5yZWFzb24pLEkubGVuZ3RoLWd9LGRlY29kZShBKXtjb25zdCBJPWUuQmVib3BWaWV3LmdldEluc3RhbmNlKCk7cmV0dXJuIEkuc3RhcnRSZWFkaW5nKEEpLHRoaXMucmVhZEZyb20oSSl9LHJlYWRGcm9tKEEpe2xldCBJLGcsZSxCO3JldHVybiBJPUEucmVhZEludDY0KCksZz1BLnJlYWRTdHJpbmcoKSxlPUEucmVhZEd1aWQoKSxCPUEucmVhZFN0cmluZygpLHtzb3VyY2VQZWVySWQ6SSxzb3VyY2VFeHRlcm5hbElkOmcsaWQ6ZSxyZWFzb246Qn19fSxJLlBlZXJTaWduYWxpbmdJbmZvcm1hdGlvbj17ZGlzY3JpbWluYXRvcjo0LGVuY29kZShBKXtjb25zdCBJPWUuQmVib3BWaWV3LmdldEluc3RhbmNlKCk7cmV0dXJuIEkuc3RhcnRXcml0aW5nKCksdGhpcy5lbmNvZGVJbnRvKEEsSSksSS50b0FycmF5KCl9LGVuY29kZUludG8oQSxJKXtjb25zdCBnPUkubGVuZ3RoO3JldHVybiBJLndyaXRlR3VpZChBLmlkKSxJLndyaXRlVWludDMyKEEudHlwZSksSS53cml0ZVN0cmluZyhBLmRhdGEpLEkubGVuZ3RoLWd9LGRlY29kZShBKXtjb25zdCBJPWUuQmVib3BWaWV3LmdldEluc3RhbmNlKCk7cmV0dXJuIEkuc3RhcnRSZWFkaW5nKEEpLHRoaXMucmVhZEZyb20oSSl9LHJlYWRGcm9tKEEpe2xldCBJLGcsZTtyZXR1cm4gST1BLnJlYWRHdWlkKCksZz1BLnJlYWRVaW50MzIoKSxlPUEucmVhZFN0cmluZygpLHtpZDpJLHR5cGU6ZyxkYXRhOmV9fX0sSS5HYXRld2F5Rm9yd2FyZGFibGVCb2R5PXtlbmNvZGUoQSl7Y29uc3QgST1lLkJlYm9wVmlldy5nZXRJbnN0YW5jZSgpO3JldHVybiBJLnN0YXJ0V3JpdGluZygpLHRoaXMuZW5jb2RlSW50byhBLEkpLEkudG9BcnJheSgpfSxlbmNvZGVJbnRvKEEsZyl7Y29uc3QgZT1nLmxlbmd0aCxCPWcucmVzZXJ2ZU1lc3NhZ2VMZW5ndGgoKSxpPWcubGVuZ3RoKzE7c3dpdGNoKGcud3JpdGVCeXRlKEEuZGlzY3JpbWluYXRvciksQS5kaXNjcmltaW5hdG9yKXtjYXNlIDE6SS5Db25uZWN0aW9uUmVxdWVzdC5lbmNvZGVJbnRvKEEudmFsdWUsZyk7YnJlYWs7Y2FzZSAyOkkuQWNjZXB0ZWRDb25uZWN0aW9uUmVxdWVzdC5lbmNvZGVJbnRvKEEudmFsdWUsZyk7YnJlYWs7Y2FzZSAzOkkuUmVqZWN0ZWRDb25uZWN0aW9uUmVxdWVzdC5lbmNvZGVJbnRvKEEudmFsdWUsZyk7YnJlYWs7Y2FzZSA0OkkuUGVlclNpZ25hbGluZ0luZm9ybWF0aW9uLmVuY29kZUludG8oQS52YWx1ZSxnKX1jb25zdCBRPWcubGVuZ3RoO3JldHVybiBnLmZpbGxNZXNzYWdlTGVuZ3RoKEIsUS1pKSxnLmxlbmd0aC1lfSxkZWNvZGUoQSl7Y29uc3QgST1lLkJlYm9wVmlldy5nZXRJbnN0YW5jZSgpO3JldHVybiBJLnN0YXJ0UmVhZGluZyhBKSx0aGlzLnJlYWRGcm9tKEkpfSxyZWFkRnJvbShBKXtjb25zdCBnPUEucmVhZE1lc3NhZ2VMZW5ndGgoKSxCPUEuaW5kZXgrMStnO3N3aXRjaChBLnJlYWRCeXRlKCkpe2Nhc2UgMTpyZXR1cm57ZGlzY3JpbWluYXRvcjoxLHZhbHVlOkkuQ29ubmVjdGlvblJlcXVlc3QucmVhZEZyb20oQSl9O2Nhc2UgMjpyZXR1cm57ZGlzY3JpbWluYXRvcjoyLHZhbHVlOkkuQWNjZXB0ZWRDb25uZWN0aW9uUmVxdWVzdC5yZWFkRnJvbShBKX07Y2FzZSAzOnJldHVybntkaXNjcmltaW5hdG9yOjMsdmFsdWU6SS5SZWplY3RlZENvbm5lY3Rpb25SZXF1ZXN0LnJlYWRGcm9tKEEpfTtjYXNlIDQ6cmV0dXJue2Rpc2NyaW1pbmF0b3I6NCx2YWx1ZTpJLlBlZXJTaWduYWxpbmdJbmZvcm1hdGlvbi5yZWFkRnJvbShBKX07ZGVmYXVsdDp0aHJvdyBBLmluZGV4PUIsbmV3IGUuQmVib3BSdW50aW1lRXJyb3IoXCJVbnJlY29nbml6ZWQgZGlzY3JpbWluYXRvciB3aGlsZSBkZWNvZGluZyBHYXRld2F5Rm9yd2FyZGFibGVCb2R5XCIpfX19LEkuVGVsZW1ldHJ5U2V0S2V5PVwibmV0d29yazp0ZWxlbWV0cnk6YmF0Y2hlc1wiLEkuVGVsZW1ldHJ5QmF0Y2hlc0tleVRlbXBsYXRlPVwibmV0d29yazp0ZWxlbWV0cnk6YmF0Y2hlczp7MH1cIixJLlJhaW53YXlUZWxlbWV0cnlSZXF1ZXN0PXtlbmNvZGUoQSl7Y29uc3QgST1lLkJlYm9wVmlldy5nZXRJbnN0YW5jZSgpO3JldHVybiBJLnN0YXJ0V3JpdGluZygpLHRoaXMuZW5jb2RlSW50byhBLEkpLEkudG9BcnJheSgpfSxlbmNvZGVJbnRvKEEsZyl7Y29uc3QgZT1nLmxlbmd0aCxCPWcucmVzZXJ2ZU1lc3NhZ2VMZW5ndGgoKSxpPWcubGVuZ3RoO2lmKG51bGwhPUEucmVjb3Jkcyl7Zy53cml0ZUJ5dGUoMSk7e2NvbnN0IGU9QS5yZWNvcmRzLmxlbmd0aDtnLndyaXRlVWludDMyKGUpO2ZvcihsZXQgQj0wO0I8ZTtCKyspSS5SYWlud2F5VGVsZW1ldHJ5UmVjb3JkLmVuY29kZUludG8oQS5yZWNvcmRzW0JdLGcpfX1udWxsIT1BLmNvbW1vbkF0dHJpYnV0ZXMmJihnLndyaXRlQnl0ZSgyKSxJLlJhaW53YXlUZWxlbWV0cnlSZWNvcmQuZW5jb2RlSW50byhBLmNvbW1vbkF0dHJpYnV0ZXMsZykpLGcud3JpdGVCeXRlKDApO2NvbnN0IFE9Zy5sZW5ndGg7cmV0dXJuIGcuZmlsbE1lc3NhZ2VMZW5ndGgoQixRLWkpLGcubGVuZ3RoLWV9LGRlY29kZShBKXtjb25zdCBJPWUuQmVib3BWaWV3LmdldEluc3RhbmNlKCk7cmV0dXJuIEkuc3RhcnRSZWFkaW5nKEEpLHRoaXMucmVhZEZyb20oSSl9LHJlYWRGcm9tKEEpe2xldCBnPXt9O2NvbnN0IGU9QS5yZWFkTWVzc2FnZUxlbmd0aCgpLEI9QS5pbmRleCtlO2Zvcig7Oylzd2l0Y2goQS5yZWFkQnl0ZSgpKXtjYXNlIDA6cmV0dXJuIGc7Y2FzZSAxOntsZXQgZT1BLnJlYWRVaW50MzIoKTtnLnJlY29yZHM9bmV3IEFycmF5KGUpO2ZvcihsZXQgQj0wO0I8ZTtCKyspe2xldCBlO2U9SS5SYWlud2F5VGVsZW1ldHJ5UmVjb3JkLnJlYWRGcm9tKEEpLGcucmVjb3Jkc1tCXT1lfX1icmVhaztjYXNlIDI6Zy5jb21tb25BdHRyaWJ1dGVzPUkuUmFpbndheVRlbGVtZXRyeVJlY29yZC5yZWFkRnJvbShBKTticmVhaztkZWZhdWx0OnJldHVybiBBLmluZGV4PUIsZ319fSxJLlJhaW53YXlUZWxlbWV0cnlSZWNvcmQ9e2VuY29kZShBKXtjb25zdCBJPWUuQmVib3BWaWV3LmdldEluc3RhbmNlKCk7cmV0dXJuIEkuc3RhcnRXcml0aW5nKCksdGhpcy5lbmNvZGVJbnRvKEEsSSksSS50b0FycmF5KCl9LGVuY29kZUludG8oQSxnKXtjb25zdCBlPWcubGVuZ3RoLEI9Zy5yZXNlcnZlTWVzc2FnZUxlbmd0aCgpLGk9Zy5sZW5ndGg7aWYobnVsbCE9QS5uYW1lJiYoZy53cml0ZUJ5dGUoMSksZy53cml0ZVN0cmluZyhBLm5hbWUpKSxudWxsIT1BLnZhbHVlJiYoZy53cml0ZUJ5dGUoMiksZy53cml0ZVN0cmluZyhBLnZhbHVlKSksbnVsbCE9QS50aW1lJiYoZy53cml0ZUJ5dGUoMyksZy53cml0ZURhdGUoQS50aW1lKSksbnVsbCE9QS50eXBlJiYoZy53cml0ZUJ5dGUoNCksZy53cml0ZVVpbnQzMihBLnR5cGUpKSxudWxsIT1BLmRpbWVuc2lvbnMpe2cud3JpdGVCeXRlKDUpO3tjb25zdCBlPUEuZGltZW5zaW9ucy5sZW5ndGg7Zy53cml0ZVVpbnQzMihlKTtmb3IobGV0IEI9MDtCPGU7QisrKUkuUmFpbndheVRlbGVtZXRyeURpbWVuc2lvbi5lbmNvZGVJbnRvKEEuZGltZW5zaW9uc1tCXSxnKX19Zy53cml0ZUJ5dGUoMCk7Y29uc3QgUT1nLmxlbmd0aDtyZXR1cm4gZy5maWxsTWVzc2FnZUxlbmd0aChCLFEtaSksZy5sZW5ndGgtZX0sZGVjb2RlKEEpe2NvbnN0IEk9ZS5CZWJvcFZpZXcuZ2V0SW5zdGFuY2UoKTtyZXR1cm4gSS5zdGFydFJlYWRpbmcoQSksdGhpcy5yZWFkRnJvbShJKX0scmVhZEZyb20oQSl7bGV0IGc9e307Y29uc3QgZT1BLnJlYWRNZXNzYWdlTGVuZ3RoKCksQj1BLmluZGV4K2U7Zm9yKDs7KXN3aXRjaChBLnJlYWRCeXRlKCkpe2Nhc2UgMDpyZXR1cm4gZztjYXNlIDE6Zy5uYW1lPUEucmVhZFN0cmluZygpO2JyZWFrO2Nhc2UgMjpnLnZhbHVlPUEucmVhZFN0cmluZygpO2JyZWFrO2Nhc2UgMzpnLnRpbWU9QS5yZWFkRGF0ZSgpO2JyZWFrO2Nhc2UgNDpnLnR5cGU9QS5yZWFkVWludDMyKCk7YnJlYWs7Y2FzZSA1OntsZXQgZT1BLnJlYWRVaW50MzIoKTtnLmRpbWVuc2lvbnM9bmV3IEFycmF5KGUpO2ZvcihsZXQgQj0wO0I8ZTtCKyspe2xldCBlO2U9SS5SYWlud2F5VGVsZW1ldHJ5RGltZW5zaW9uLnJlYWRGcm9tKEEpLGcuZGltZW5zaW9uc1tCXT1lfX1icmVhaztkZWZhdWx0OnJldHVybiBBLmluZGV4PUIsZ319fSxJLlJhaW53YXlUZWxlbWV0cnlEaW1lbnNpb249e2VuY29kZShBKXtjb25zdCBJPWUuQmVib3BWaWV3LmdldEluc3RhbmNlKCk7cmV0dXJuIEkuc3RhcnRXcml0aW5nKCksdGhpcy5lbmNvZGVJbnRvKEEsSSksSS50b0FycmF5KCl9LGVuY29kZUludG8oQSxJKXtjb25zdCBnPUkubGVuZ3RoO3JldHVybiBJLndyaXRlU3RyaW5nKEEubmFtZSksSS53cml0ZVN0cmluZyhBLnZhbHVlKSxJLmxlbmd0aC1nfSxkZWNvZGUoQSl7Y29uc3QgST1lLkJlYm9wVmlldy5nZXRJbnN0YW5jZSgpO3JldHVybiBJLnN0YXJ0UmVhZGluZyhBKSx0aGlzLnJlYWRGcm9tKEkpfSxyZWFkRnJvbShBKXtsZXQgSSxnO3JldHVybiBJPUEucmVhZFN0cmluZygpLGc9QS5yZWFkU3RyaW5nKCkse25hbWU6SSx2YWx1ZTpnfX19LChVPUkuVGVsZW1ldHJ5VmFsdWVUeXBlfHwoSS5UZWxlbWV0cnlWYWx1ZVR5cGU9e30pKVtVLkRvdWJsZT0wXT1cIkRvdWJsZVwiLFVbVS5CaWdJbnQ9MV09XCJCaWdJbnRcIixVW1UuVmFyQ2hhcj0yXT1cIlZhckNoYXJcIixVW1UuQm9vbD0zXT1cIkJvb2xcIixJLkd1aWQ9e2VuY29kZShBKXtjb25zdCBJPWUuQmVib3BWaWV3LmdldEluc3RhbmNlKCk7cmV0dXJuIEkuc3RhcnRXcml0aW5nKCksdGhpcy5lbmNvZGVJbnRvKEEsSSksSS50b0FycmF5KCl9LGVuY29kZUludG8oQSxJKXtjb25zdCBnPUkubGVuZ3RoO3JldHVybiBJLndyaXRlR3VpZChBLnZhbHVlKSxJLmxlbmd0aC1nfSxkZWNvZGUoQSl7Y29uc3QgST1lLkJlYm9wVmlldy5nZXRJbnN0YW5jZSgpO3JldHVybiBJLnN0YXJ0UmVhZGluZyhBKSx0aGlzLnJlYWRGcm9tKEkpfSxyZWFkRnJvbShBKXtsZXQgSTtyZXR1cm4gST1BLnJlYWRHdWlkKCkse3ZhbHVlOkl9fX0sSS5SYWlud2F5SGVhZGVyPXtlbmNvZGUoQSl7Y29uc3QgST1lLkJlYm9wVmlldy5nZXRJbnN0YW5jZSgpO3JldHVybiBJLnN0YXJ0V3JpdGluZygpLHRoaXMuZW5jb2RlSW50byhBLEkpLEkudG9BcnJheSgpfSxlbmNvZGVJbnRvKEEsSSl7Y29uc3QgZz1JLmxlbmd0aDtyZXR1cm4gSS53cml0ZVVpbnQzMihBLm1hZ2ljTnVtYmVyKSxJLndyaXRlVWludDMyKEEuc3luY0tleSksSS53cml0ZUludDY0KEEuc291cmNlUGVlcklkKSxJLndyaXRlSW50NjQoQS50YXJnZXRQZWVySWQpLEkubGVuZ3RoLWd9LGRlY29kZShBKXtjb25zdCBJPWUuQmVib3BWaWV3LmdldEluc3RhbmNlKCk7cmV0dXJuIEkuc3RhcnRSZWFkaW5nKEEpLHRoaXMucmVhZEZyb20oSSl9LHJlYWRGcm9tKEEpe2xldCBJLGcsZSxCO3JldHVybiBJPUEucmVhZFVpbnQzMigpLGc9QS5yZWFkVWludDMyKCksZT1BLnJlYWRJbnQ2NCgpLEI9QS5yZWFkSW50NjQoKSx7bWFnaWNOdW1iZXI6SSxzeW5jS2V5Omcsc291cmNlUGVlcklkOmUsdGFyZ2V0UGVlcklkOkJ9fX0sSS5DaHVuaz17ZW5jb2RlKEEpe2NvbnN0IEk9ZS5CZWJvcFZpZXcuZ2V0SW5zdGFuY2UoKTtyZXR1cm4gSS5zdGFydFdyaXRpbmcoKSx0aGlzLmVuY29kZUludG8oQSxJKSxJLnRvQXJyYXkoKX0sZW5jb2RlSW50byhBLEkpe2NvbnN0IGc9SS5sZW5ndGg7cmV0dXJuIEkud3JpdGVVaW50MTYoQS5ncm91cElkKSxJLndyaXRlQnl0ZShBLmluZGV4KSxJLndyaXRlQnl0ZShBLmNodW5rc0luR3JvdXApLEkud3JpdGVCeXRlcyhBLmRhdGEpLEkubGVuZ3RoLWd9LGRlY29kZShBKXtjb25zdCBJPWUuQmVib3BWaWV3LmdldEluc3RhbmNlKCk7cmV0dXJuIEkuc3RhcnRSZWFkaW5nKEEpLHRoaXMucmVhZEZyb20oSSl9LHJlYWRGcm9tKEEpe2xldCBJLGcsZSxCO3JldHVybiBJPUEucmVhZFVpbnQxNigpLGc9QS5yZWFkQnl0ZSgpLGU9QS5yZWFkQnl0ZSgpLEI9QS5yZWFkQnl0ZXMoKSx7Z3JvdXBJZDpJLGluZGV4OmcsY2h1bmtzSW5Hcm91cDplLGRhdGE6Qn19fSxJLklucHV0RGF0YWdyYW09e2VuY29kZShBKXtjb25zdCBJPWUuQmVib3BWaWV3LmdldEluc3RhbmNlKCk7cmV0dXJuIEkuc3RhcnRXcml0aW5nKCksdGhpcy5lbmNvZGVJbnRvKEEsSSksSS50b0FycmF5KCl9LGVuY29kZUludG8oQSxnKXtjb25zdCBlPWcubGVuZ3RoO3JldHVybiBJLlJhaW53YXlIZWFkZXIuZW5jb2RlSW50byhBLmhlYWRlcixnKSxJLklucHV0Qm9keS5lbmNvZGVJbnRvKEEuYm9keSxnKSxnLmxlbmd0aC1lfSxkZWNvZGUoQSl7Y29uc3QgST1lLkJlYm9wVmlldy5nZXRJbnN0YW5jZSgpO3JldHVybiBJLnN0YXJ0UmVhZGluZyhBKSx0aGlzLnJlYWRGcm9tKEkpfSxyZWFkRnJvbShBKXtsZXQgZyxlO3JldHVybiBnPUkuUmFpbndheUhlYWRlci5yZWFkRnJvbShBKSxlPUkuSW5wdXRCb2R5LnJlYWRGcm9tKEEpLHtoZWFkZXI6Zyxib2R5OmV9fX0sSS5Mb2dpY0RhdGFncmFtPXtlbmNvZGUoQSl7Y29uc3QgST1lLkJlYm9wVmlldy5nZXRJbnN0YW5jZSgpO3JldHVybiBJLnN0YXJ0V3JpdGluZygpLHRoaXMuZW5jb2RlSW50byhBLEkpLEkudG9BcnJheSgpfSxlbmNvZGVJbnRvKEEsZyl7Y29uc3QgZT1nLmxlbmd0aDtyZXR1cm4gSS5SYWlud2F5SGVhZGVyLmVuY29kZUludG8oQS5oZWFkZXIsZyksSS5Mb2dpY0JvZHkuZW5jb2RlSW50byhBLmJvZHksZyksZy5sZW5ndGgtZX0sZGVjb2RlKEEpe2NvbnN0IEk9ZS5CZWJvcFZpZXcuZ2V0SW5zdGFuY2UoKTtyZXR1cm4gSS5zdGFydFJlYWRpbmcoQSksdGhpcy5yZWFkRnJvbShJKX0scmVhZEZyb20oQSl7bGV0IGcsZTtyZXR1cm4gZz1JLlJhaW53YXlIZWFkZXIucmVhZEZyb20oQSksZT1JLkxvZ2ljQm9keS5yZWFkRnJvbShBKSx7aGVhZGVyOmcsYm9keTplfX19LEkuTWVkaWFEYXRhZ3JhbT17ZW5jb2RlKEEpe2NvbnN0IEk9ZS5CZWJvcFZpZXcuZ2V0SW5zdGFuY2UoKTtyZXR1cm4gSS5zdGFydFdyaXRpbmcoKSx0aGlzLmVuY29kZUludG8oQSxJKSxJLnRvQXJyYXkoKX0sZW5jb2RlSW50byhBLGcpe2NvbnN0IGU9Zy5sZW5ndGg7cmV0dXJuIEkuUmFpbndheUhlYWRlci5lbmNvZGVJbnRvKEEuaGVhZGVyLGcpLEkuTWVkaWFCb2R5LmVuY29kZUludG8oQS5ib2R5LGcpLGcubGVuZ3RoLWV9LGRlY29kZShBKXtjb25zdCBJPWUuQmVib3BWaWV3LmdldEluc3RhbmNlKCk7cmV0dXJuIEkuc3RhcnRSZWFkaW5nKEEpLHRoaXMucmVhZEZyb20oSSl9LHJlYWRGcm9tKEEpe2xldCBnLGU7cmV0dXJuIGc9SS5SYWlud2F5SGVhZGVyLnJlYWRGcm9tKEEpLGU9SS5NZWRpYUJvZHkucmVhZEZyb20oQSkse2hlYWRlcjpnLGJvZHk6ZX19fSxJLkFyYml0cmFyeURhdGFncmFtPXtlbmNvZGUoQSl7Y29uc3QgST1lLkJlYm9wVmlldy5nZXRJbnN0YW5jZSgpO3JldHVybiBJLnN0YXJ0V3JpdGluZygpLHRoaXMuZW5jb2RlSW50byhBLEkpLEkudG9BcnJheSgpfSxlbmNvZGVJbnRvKEEsZyl7Y29uc3QgZT1nLmxlbmd0aDtyZXR1cm4gSS5SYWlud2F5SGVhZGVyLmVuY29kZUludG8oQS5oZWFkZXIsZyksSS5DaHVuay5lbmNvZGVJbnRvKEEuYm9keSxnKSxnLmxlbmd0aC1lfSxkZWNvZGUoQSl7Y29uc3QgST1lLkJlYm9wVmlldy5nZXRJbnN0YW5jZSgpO3JldHVybiBJLnN0YXJ0UmVhZGluZyhBKSx0aGlzLnJlYWRGcm9tKEkpfSxyZWFkRnJvbShBKXtsZXQgZyxlO3JldHVybiBnPUkuUmFpbndheUhlYWRlci5yZWFkRnJvbShBKSxlPUkuQ2h1bmsucmVhZEZyb20oQSkse2hlYWRlcjpnLGJvZHk6ZX19fSwoaz1JLlhJbnB1dEJ1dHRvbnN8fChJLlhJbnB1dEJ1dHRvbnM9e30pKVtrLk5vbmU9MF09XCJOb25lXCIsa1trLkRwYWRVcD0xXT1cIkRwYWRVcFwiLGtbay5EcGFkRG93bj0yXT1cIkRwYWREb3duXCIsa1trLkRwYWRMZWZ0PTRdPVwiRHBhZExlZnRcIixrW2suRHBhZFJpZ2h0PThdPVwiRHBhZFJpZ2h0XCIsa1trLlN0YXJ0PTE2XT1cIlN0YXJ0XCIsa1trLkJhY2s9MzJdPVwiQmFja1wiLGtbay5MZWZ0U3RpY2s9NjRdPVwiTGVmdFN0aWNrXCIsa1trLlJpZ2h0U3RpY2s9MTI4XT1cIlJpZ2h0U3RpY2tcIixrW2suTGVmdEJ1bXBlcj0yNTZdPVwiTGVmdEJ1bXBlclwiLGtbay5SaWdodEJ1bXBlcj01MTJdPVwiUmlnaHRCdW1wZXJcIixrW2suR3VpZGU9MTAyNF09XCJHdWlkZVwiLGtbay5BPTQwOTZdPVwiQVwiLGtbay5CPTgxOTJdPVwiQlwiLGtbay5YPTE2Mzg0XT1cIlhcIixrW2suWT0zMjc2OF09XCJZXCIsKEc9SS5CdXR0b25BY3Rpb258fChJLkJ1dHRvbkFjdGlvbj17fSkpW0cuQnV0dG9uRG93bj0wXT1cIkJ1dHRvbkRvd25cIixHW0cuQnV0dG9uVXA9MV09XCJCdXR0b25VcFwiLChSPUkuTW91c2VCdXR0b258fChJLk1vdXNlQnV0dG9uPXt9KSlbUi5MZWZ0PTBdPVwiTGVmdFwiLFJbUi5SaWdodD0xXT1cIlJpZ2h0XCIsUltSLk1pZGRsZT0yXT1cIk1pZGRsZVwiLFJbUi5YMT0zXT1cIlgxXCIsUltSLlgyPTRdPVwiWDJcIiwoRj1JLlNjcm9sbEF4aXN8fChJLlNjcm9sbEF4aXM9e30pKVtGLkhvcml6b250YWw9MF09XCJIb3Jpem9udGFsXCIsRltGLlZlcnRpY2FsPTFdPVwiVmVydGljYWxcIiwoUz1JLktleWJvYXJkQWN0aW9ufHwoSS5LZXlib2FyZEFjdGlvbj17fSkpW1MuS2V5RG93bj0wXT1cIktleURvd25cIixTW1MuS2V5VXA9MV09XCJLZXlVcFwiLChsPUkuVmlydHVhbEtleXx8KEkuVmlydHVhbEtleT17fSkpW2wuTm9uZT0wXT1cIk5vbmVcIixsW2wuQ2FuY2VsPTFdPVwiQ2FuY2VsXCIsbFtsLkJhY2s9Ml09XCJCYWNrXCIsbFtsLlRhYj0zXT1cIlRhYlwiLGxbbC5MaW5lRmVlZD00XT1cIkxpbmVGZWVkXCIsbFtsLkNsZWFyPTVdPVwiQ2xlYXJcIixsW2wuRW50ZXI9Nl09XCJFbnRlclwiLGxbbC5QYXVzZT03XT1cIlBhdXNlXCIsbFtsLkNhcHNMb2NrPThdPVwiQ2Fwc0xvY2tcIixsW2wuSGFuZ3VsTW9kZT05XT1cIkhhbmd1bE1vZGVcIixsW2wuSnVuamFNb2RlPTEwXT1cIkp1bmphTW9kZVwiLGxbbC5GaW5hbE1vZGU9MTFdPVwiRmluYWxNb2RlXCIsbFtsLkhhbmphTW9kZT0xMl09XCJIYW5qYU1vZGVcIixsW2wuRXNjYXBlPTEzXT1cIkVzY2FwZVwiLGxbbC5JbWVDb252ZXJ0PTE0XT1cIkltZUNvbnZlcnRcIixsW2wuSW1lTm9uQ29udmVydD0xNV09XCJJbWVOb25Db252ZXJ0XCIsbFtsLkltZUFjY2VwdD0xNl09XCJJbWVBY2NlcHRcIixsW2wuSW1lTW9kZUNoYW5nZT0xN109XCJJbWVNb2RlQ2hhbmdlXCIsbFtsLlNwYWNlPTE4XT1cIlNwYWNlXCIsbFtsLlBhZ2VVcD0xOV09XCJQYWdlVXBcIixsW2wuUGFnZURvd249MjBdPVwiUGFnZURvd25cIixsW2wuRW5kPTIxXT1cIkVuZFwiLGxbbC5Ib21lPTIyXT1cIkhvbWVcIixsW2wuTGVmdD0yM109XCJMZWZ0XCIsbFtsLlVwPTI0XT1cIlVwXCIsbFtsLlJpZ2h0PTI1XT1cIlJpZ2h0XCIsbFtsLkRvd249MjZdPVwiRG93blwiLGxbbC5TZWxlY3Q9MjddPVwiU2VsZWN0XCIsbFtsLlByaW50PTI4XT1cIlByaW50XCIsbFtsLkV4ZWN1dGU9MjldPVwiRXhlY3V0ZVwiLGxbbC5QcmludFNjcmVlbj0zMF09XCJQcmludFNjcmVlblwiLGxbbC5JbnNlcnQ9MzFdPVwiSW5zZXJ0XCIsbFtsLkRlbGV0ZT0zMl09XCJEZWxldGVcIixsW2wuSGVscD0zM109XCJIZWxwXCIsbFtsLkQwPTM0XT1cIkQwXCIsbFtsLkQxPTM1XT1cIkQxXCIsbFtsLkQyPTM2XT1cIkQyXCIsbFtsLkQzPTM3XT1cIkQzXCIsbFtsLkQ0PTM4XT1cIkQ0XCIsbFtsLkQ1PTM5XT1cIkQ1XCIsbFtsLkQ2PTQwXT1cIkQ2XCIsbFtsLkQ3PTQxXT1cIkQ3XCIsbFtsLkQ4PTQyXT1cIkQ4XCIsbFtsLkQ5PTQzXT1cIkQ5XCIsbFtsLkE9NDRdPVwiQVwiLGxbbC5CPTQ1XT1cIkJcIixsW2wuQz00Nl09XCJDXCIsbFtsLkQ9NDddPVwiRFwiLGxbbC5FPTQ4XT1cIkVcIixsW2wuRj00OV09XCJGXCIsbFtsLkc9NTBdPVwiR1wiLGxbbC5IPTUxXT1cIkhcIixsW2wuST01Ml09XCJJXCIsbFtsLko9NTNdPVwiSlwiLGxbbC5LPTU0XT1cIktcIixsW2wuTD01NV09XCJMXCIsbFtsLk09NTZdPVwiTVwiLGxbbC5OPTU3XT1cIk5cIixsW2wuTz01OF09XCJPXCIsbFtsLlA9NTldPVwiUFwiLGxbbC5RPTYwXT1cIlFcIixsW2wuUj02MV09XCJSXCIsbFtsLlM9NjJdPVwiU1wiLGxbbC5UPTYzXT1cIlRcIixsW2wuVT02NF09XCJVXCIsbFtsLlY9NjVdPVwiVlwiLGxbbC5XPTY2XT1cIldcIixsW2wuWD02N109XCJYXCIsbFtsLlk9NjhdPVwiWVwiLGxbbC5aPTY5XT1cIlpcIixsW2wuTFdpbj03MF09XCJMV2luXCIsbFtsLlJXaW49NzFdPVwiUldpblwiLGxbbC5BcHBzPTcyXT1cIkFwcHNcIixsW2wuU2xlZXA9NzNdPVwiU2xlZXBcIixsW2wuTnVtUGFkMD03NF09XCJOdW1QYWQwXCIsbFtsLk51bVBhZDE9NzVdPVwiTnVtUGFkMVwiLGxbbC5OdW1QYWQyPTc2XT1cIk51bVBhZDJcIixsW2wuTnVtUGFkMz03N109XCJOdW1QYWQzXCIsbFtsLk51bVBhZDQ9NzhdPVwiTnVtUGFkNFwiLGxbbC5OdW1QYWQ1PTc5XT1cIk51bVBhZDVcIixsW2wuTnVtUGFkNj04MF09XCJOdW1QYWQ2XCIsbFtsLk51bVBhZDc9ODFdPVwiTnVtUGFkN1wiLGxbbC5OdW1QYWQ4PTgyXT1cIk51bVBhZDhcIixsW2wuTnVtUGFkOT04M109XCJOdW1QYWQ5XCIsbFtsLk11bHRpcGx5PTg0XT1cIk11bHRpcGx5XCIsbFtsLkFkZD04NV09XCJBZGRcIixsW2wuU2VwYXJhdG9yPTg2XT1cIlNlcGFyYXRvclwiLGxbbC5TdWJ0cmFjdD04N109XCJTdWJ0cmFjdFwiLGxbbC5EZWNpbWFsPTg4XT1cIkRlY2ltYWxcIixsW2wuRGl2aWRlPTg5XT1cIkRpdmlkZVwiLGxbbC5GMT05MF09XCJGMVwiLGxbbC5GMj05MV09XCJGMlwiLGxbbC5GMz05Ml09XCJGM1wiLGxbbC5GND05M109XCJGNFwiLGxbbC5GNT05NF09XCJGNVwiLGxbbC5GNj05NV09XCJGNlwiLGxbbC5GNz05Nl09XCJGN1wiLGxbbC5GOD05N109XCJGOFwiLGxbbC5GOT05OF09XCJGOVwiLGxbbC5GMTA9OTldPVwiRjEwXCIsbFtsLkYxMT0xMDBdPVwiRjExXCIsbFtsLkYxMj0xMDFdPVwiRjEyXCIsbFtsLkYxMz0xMDJdPVwiRjEzXCIsbFtsLkYxND0xMDNdPVwiRjE0XCIsbFtsLkYxNT0xMDRdPVwiRjE1XCIsbFtsLkYxNj0xMDVdPVwiRjE2XCIsbFtsLkYxNz0xMDZdPVwiRjE3XCIsbFtsLkYxOD0xMDddPVwiRjE4XCIsbFtsLkYxOT0xMDhdPVwiRjE5XCIsbFtsLkYyMD0xMDldPVwiRjIwXCIsbFtsLkYyMT0xMTBdPVwiRjIxXCIsbFtsLkYyMj0xMTFdPVwiRjIyXCIsbFtsLkYyMz0xMTJdPVwiRjIzXCIsbFtsLkYyND0xMTNdPVwiRjI0XCIsbFtsLk51bUxvY2s9MTE0XT1cIk51bUxvY2tcIixsW2wuU2Nyb2xsPTExNV09XCJTY3JvbGxcIixsW2wuTGVmdFNoaWZ0PTExNl09XCJMZWZ0U2hpZnRcIixsW2wuUmlnaHRTaGlmdD0xMTddPVwiUmlnaHRTaGlmdFwiLGxbbC5MZWZ0Q3RybD0xMThdPVwiTGVmdEN0cmxcIixsW2wuUmlnaHRDdHJsPTExOV09XCJSaWdodEN0cmxcIixsW2wuTGVmdEFsdD0xMjBdPVwiTGVmdEFsdFwiLGxbbC5SaWdodEFsdD0xMjFdPVwiUmlnaHRBbHRcIixsW2wuQnJvd3NlckJhY2s9MTIyXT1cIkJyb3dzZXJCYWNrXCIsbFtsLkJyb3dzZXJGb3J3YXJkPTEyM109XCJCcm93c2VyRm9yd2FyZFwiLGxbbC5Ccm93c2VyUmVmcmVzaD0xMjRdPVwiQnJvd3NlclJlZnJlc2hcIixsW2wuQnJvd3NlclN0b3A9MTI1XT1cIkJyb3dzZXJTdG9wXCIsbFtsLkJyb3dzZXJTZWFyY2g9MTI2XT1cIkJyb3dzZXJTZWFyY2hcIixsW2wuQnJvd3NlckZhdm9yaXRlcz0xMjddPVwiQnJvd3NlckZhdm9yaXRlc1wiLGxbbC5Ccm93c2VySG9tZT0xMjhdPVwiQnJvd3NlckhvbWVcIixsW2wuVm9sdW1lTXV0ZT0xMjldPVwiVm9sdW1lTXV0ZVwiLGxbbC5Wb2x1bWVEb3duPTEzMF09XCJWb2x1bWVEb3duXCIsbFtsLlZvbHVtZVVwPTEzMV09XCJWb2x1bWVVcFwiLGxbbC5NZWRpYU5leHRUcmFjaz0xMzJdPVwiTWVkaWFOZXh0VHJhY2tcIixsW2wuTWVkaWFQcmV2aW91c1RyYWNrPTEzM109XCJNZWRpYVByZXZpb3VzVHJhY2tcIixsW2wuTWVkaWFTdG9wPTEzNF09XCJNZWRpYVN0b3BcIixsW2wuTWVkaWFQbGF5UGF1c2U9MTM1XT1cIk1lZGlhUGxheVBhdXNlXCIsbFtsLkxhdW5jaE1haWw9MTM2XT1cIkxhdW5jaE1haWxcIixsW2wuU2VsZWN0TWVkaWE9MTM3XT1cIlNlbGVjdE1lZGlhXCIsbFtsLkxhdW5jaEFwcGxpY2F0aW9uMT0xMzhdPVwiTGF1bmNoQXBwbGljYXRpb24xXCIsbFtsLkxhdW5jaEFwcGxpY2F0aW9uMj0xMzldPVwiTGF1bmNoQXBwbGljYXRpb24yXCIsbFtsLk9lbTE9MTQwXT1cIk9lbTFcIixsW2wuT2VtUGx1cz0xNDFdPVwiT2VtUGx1c1wiLGxbbC5PZW1Db21tYT0xNDJdPVwiT2VtQ29tbWFcIixsW2wuT2VtTWludXM9MTQzXT1cIk9lbU1pbnVzXCIsbFtsLk9lbVBlcmlvZD0xNDRdPVwiT2VtUGVyaW9kXCIsbFtsLk9lbTI9MTQ1XT1cIk9lbTJcIixsW2wuT2VtMz0xNDZdPVwiT2VtM1wiLGxbbC5BYm50QzE9MTQ3XT1cIkFibnRDMVwiLGxbbC5BYm50QzI9MTQ4XT1cIkFibnRDMlwiLGxbbC5PZW00PTE0OV09XCJPZW00XCIsbFtsLk9lbTU9MTUwXT1cIk9lbTVcIixsW2wuT2VtNj0xNTFdPVwiT2VtNlwiLGxbbC5PZW03PTE1Ml09XCJPZW03XCIsbFtsLk9lbTg9MTUzXT1cIk9lbThcIixsW2wuT2VtMTAyPTE1NF09XCJPZW0xMDJcIixsW2wuSW1lUHJvY2Vzc2VkPTE1NV09XCJJbWVQcm9jZXNzZWRcIixsW2wuU3lzdGVtPTE1Nl09XCJTeXN0ZW1cIixsW2wuT2VtQXR0bj0xNTddPVwiT2VtQXR0blwiLGxbbC5PZW1GaW5pc2g9MTU4XT1cIk9lbUZpbmlzaFwiLGxbbC5PZW1Db3B5PTE1OV09XCJPZW1Db3B5XCIsbFtsLk9lbUF1dG89MTYwXT1cIk9lbUF1dG9cIixsW2wuT2VtRW5sdz0xNjFdPVwiT2VtRW5sd1wiLGxbbC5PZW1CYWNrVGFiPTE2Ml09XCJPZW1CYWNrVGFiXCIsbFtsLkF0dG49MTYzXT1cIkF0dG5cIixsW2wuQ3JTZWw9MTY0XT1cIkNyU2VsXCIsbFtsLkV4U2VsPTE2NV09XCJFeFNlbFwiLGxbbC5FcmFzZUVvZj0xNjZdPVwiRXJhc2VFb2ZcIixsW2wuUGxheT0xNjddPVwiUGxheVwiLGxbbC5ab29tPTE2OF09XCJab29tXCIsbFtsLk5vTmFtZT0xNjldPVwiTm9OYW1lXCIsbFtsLlBhMT0xNzBdPVwiUGExXCIsbFtsLk9lbUNsZWFyPTE3MV09XCJPZW1DbGVhclwiLGxbbC5EZWFkQ2hhclByb2Nlc3NlZD0xNzJdPVwiRGVhZENoYXJQcm9jZXNzZWRcIiwodT1JLldpbmRvd3NQb2ludGVyRmxhZ3N8fChJLldpbmRvd3NQb2ludGVyRmxhZ3M9e30pKVt1Lk5ldz0xXT1cIk5ld1wiLHVbdS5JblJhbmdlPTJdPVwiSW5SYW5nZVwiLHVbdS5JbkNvbnRhY3Q9NF09XCJJbkNvbnRhY3RcIix1W3UuRmlyc3RCdXR0b249MTZdPVwiRmlyc3RCdXR0b25cIix1W3UuU2Vjb25kQnV0dG9uPTMyXT1cIlNlY29uZEJ1dHRvblwiLHVbdS5UaGlyZEJ1dHRvbj02NF09XCJUaGlyZEJ1dHRvblwiLHVbdS5Gb3VydGhCdXR0b249MTI4XT1cIkZvdXJ0aEJ1dHRvblwiLHVbdS5GaWZ0aEJ1dHRvbj0yNTZdPVwiRmlmdGhCdXR0b25cIix1W3UuUHJpbWFyeT04MTkyXT1cIlByaW1hcnlcIix1W3UuQ29uZmlkZW5jZT0xNjM4NF09XCJDb25maWRlbmNlXCIsdVt1LkNhbmNlbGVkPTMyNzY4XT1cIkNhbmNlbGVkXCIsdVt1LkRvd249NjU1MzZdPVwiRG93blwiLHVbdS5VcGRhdGU9MTMxMDcyXT1cIlVwZGF0ZVwiLHVbdS5VcD0yNjIxNDRdPVwiVXBcIix1W3UuV2hlZWw9NTI0Mjg4XT1cIldoZWVsXCIsdVt1LkhXaGVlbD0xMDQ4NTc2XT1cIkhXaGVlbFwiLHVbdS5DYXB0dXJlQ2hhbmdlZD0yMDk3MTUyXT1cIkNhcHR1cmVDaGFuZ2VkXCIsdVt1Lkhhc1RyYW5zZm9ybT00MTk0MzA0XT1cIkhhc1RyYW5zZm9ybVwiLEkuVG91Y2hQZW5Qb2ludGVySW5mbz17ZW5jb2RlKEEpe2NvbnN0IEk9ZS5CZWJvcFZpZXcuZ2V0SW5zdGFuY2UoKTtyZXR1cm4gSS5zdGFydFdyaXRpbmcoKSx0aGlzLmVuY29kZUludG8oQSxJKSxJLnRvQXJyYXkoKX0sZW5jb2RlSW50byhBLEkpe2NvbnN0IGc9SS5sZW5ndGg7cmV0dXJuIEkud3JpdGVVaW50MzIoQS5wb2ludGVySWQpLEkud3JpdGVVaW50MzIoQS5mcmFtZUlkKSxJLndyaXRlVWludDMyKEEucG9pbnRlckZsYWdzKSxJLndyaXRlSW50MzIoQS54KSxJLndyaXRlSW50MzIoQS55KSxJLmxlbmd0aC1nfSxkZWNvZGUoQSl7Y29uc3QgST1lLkJlYm9wVmlldy5nZXRJbnN0YW5jZSgpO3JldHVybiBJLnN0YXJ0UmVhZGluZyhBKSx0aGlzLnJlYWRGcm9tKEkpfSxyZWFkRnJvbShBKXtsZXQgSSxnLGUsQixpO3JldHVybiBJPUEucmVhZFVpbnQzMigpLGc9QS5yZWFkVWludDMyKCksZT1BLnJlYWRVaW50MzIoKSxCPUEucmVhZEludDMyKCksaT1BLnJlYWRJbnQzMigpLHtwb2ludGVySWQ6SSxmcmFtZUlkOmcscG9pbnRlckZsYWdzOmUseDpCLHk6aX19fSwoeT1JLlRvdWNoTWFza3x8KEkuVG91Y2hNYXNrPXt9KSlbeS5Db250YWN0QXJlYT0xXT1cIkNvbnRhY3RBcmVhXCIseVt5Lk9yaWVudGF0aW9uPTJdPVwiT3JpZW50YXRpb25cIix5W3kuUHJlc3N1cmU9NF09XCJQcmVzc3VyZVwiLCh3PUkuUGVuTWFza3x8KEkuUGVuTWFzaz17fSkpW3cuUHJlc3N1cmU9MV09XCJQcmVzc3VyZVwiLHdbdy5Sb3RhdGlvbj0yXT1cIlJvdGF0aW9uXCIsd1t3LlRpbHRYPTRdPVwiVGlsdFhcIix3W3cuVGlsdFk9OF09XCJUaWx0WVwiLChEPUkuUGVuRmxhZ3N8fChJLlBlbkZsYWdzPXt9KSlbRC5CYXJyZWw9MV09XCJCYXJyZWxcIixEW0QuSW52ZXJ0ZWQ9Ml09XCJJbnZlcnRlZFwiLERbRC5FcmFzZXI9NF09XCJFcmFzZXJcIixJLlRvdWNoQWJzb2x1dGU9e2VuY29kZShBKXtjb25zdCBJPWUuQmVib3BWaWV3LmdldEluc3RhbmNlKCk7cmV0dXJuIEkuc3RhcnRXcml0aW5nKCksdGhpcy5lbmNvZGVJbnRvKEEsSSksSS50b0FycmF5KCl9LGVuY29kZUludG8oQSxnKXtjb25zdCBlPWcubGVuZ3RoO3JldHVybiBJLlRvdWNoUGVuUG9pbnRlckluZm8uZW5jb2RlSW50byhBLnBvaW50ZXJJbmZvLGcpLGcud3JpdGVVaW50MzIoQS50b3VjaE1hc2spLGcud3JpdGVJbnQzMihBLmNvbnRhY3RMZWZ0KSxnLndyaXRlSW50MzIoQS5jb250YWN0VG9wKSxnLndyaXRlSW50MzIoQS5jb250YWN0UmlnaHQpLGcud3JpdGVJbnQzMihBLmNvbnRhY3RCb3R0b20pLGcud3JpdGVVaW50MzIoQS5vcmllbnRhdGlvbiksZy53cml0ZVVpbnQzMihBLnByZXNzdXJlKSxnLmxlbmd0aC1lfSxkZWNvZGUoQSl7Y29uc3QgST1lLkJlYm9wVmlldy5nZXRJbnN0YW5jZSgpO3JldHVybiBJLnN0YXJ0UmVhZGluZyhBKSx0aGlzLnJlYWRGcm9tKEkpfSxyZWFkRnJvbShBKXtsZXQgZyxlLEIsaSxRLHQsQyxFO3JldHVybiBnPUkuVG91Y2hQZW5Qb2ludGVySW5mby5yZWFkRnJvbShBKSxlPUEucmVhZFVpbnQzMigpLEI9QS5yZWFkSW50MzIoKSxpPUEucmVhZEludDMyKCksUT1BLnJlYWRJbnQzMigpLHQ9QS5yZWFkSW50MzIoKSxDPUEucmVhZFVpbnQzMigpLEU9QS5yZWFkVWludDMyKCkse3BvaW50ZXJJbmZvOmcsdG91Y2hNYXNrOmUsY29udGFjdExlZnQ6Qixjb250YWN0VG9wOmksY29udGFjdFJpZ2h0OlEsY29udGFjdEJvdHRvbTp0LG9yaWVudGF0aW9uOkMscHJlc3N1cmU6RX19fSxJLkdhbWVwYWRSZXBvcnQ9e2Rpc2NyaW1pbmF0b3I6MSxlbmNvZGUoQSl7Y29uc3QgST1lLkJlYm9wVmlldy5nZXRJbnN0YW5jZSgpO3JldHVybiBJLnN0YXJ0V3JpdGluZygpLHRoaXMuZW5jb2RlSW50byhBLEkpLEkudG9BcnJheSgpfSxlbmNvZGVJbnRvKEEsSSl7Y29uc3QgZz1JLmxlbmd0aDtyZXR1cm4gSS53cml0ZVVpbnQzMihBLmJ1dHRvbnMpLEkud3JpdGVCeXRlKEEubGVmdFRyaWdnZXIpLEkud3JpdGVCeXRlKEEucmlnaHRUcmlnZ2VyKSxJLndyaXRlSW50MTYoQS5sZWZ0VGh1bWJYKSxJLndyaXRlSW50MTYoQS5sZWZ0VGh1bWJZKSxJLndyaXRlSW50MTYoQS5yaWdodFRodW1iWCksSS53cml0ZUludDE2KEEucmlnaHRUaHVtYlkpLEkud3JpdGVCeXRlKEEuc2xvdCksSS5sZW5ndGgtZ30sZGVjb2RlKEEpe2NvbnN0IEk9ZS5CZWJvcFZpZXcuZ2V0SW5zdGFuY2UoKTtyZXR1cm4gSS5zdGFydFJlYWRpbmcoQSksdGhpcy5yZWFkRnJvbShJKX0scmVhZEZyb20oQSl7bGV0IEksZyxlLEIsaSxRLHQsQztyZXR1cm4gST1BLnJlYWRVaW50MzIoKSxnPUEucmVhZEJ5dGUoKSxlPUEucmVhZEJ5dGUoKSxCPUEucmVhZEludDE2KCksaT1BLnJlYWRJbnQxNigpLFE9QS5yZWFkSW50MTYoKSx0PUEucmVhZEludDE2KCksQz1BLnJlYWRCeXRlKCkse2J1dHRvbnM6SSxsZWZ0VHJpZ2dlcjpnLHJpZ2h0VHJpZ2dlcjplLGxlZnRUaHVtYlg6QixsZWZ0VGh1bWJZOmkscmlnaHRUaHVtYlg6USxyaWdodFRodW1iWTp0LHNsb3Q6Q319fSxJLkdhbWVwYWRSdW1ibGU9e2Rpc2NyaW1pbmF0b3I6MixlbmNvZGUoQSl7Y29uc3QgST1lLkJlYm9wVmlldy5nZXRJbnN0YW5jZSgpO3JldHVybiBJLnN0YXJ0V3JpdGluZygpLHRoaXMuZW5jb2RlSW50byhBLEkpLEkudG9BcnJheSgpfSxlbmNvZGVJbnRvKEEsSSl7Y29uc3QgZz1JLmxlbmd0aDtyZXR1cm4gSS53cml0ZUJ5dGUoQS5wb3J0KSxJLndyaXRlVWludDE2KEEubGVmdE1vdG9yU3BlZWQpLEkud3JpdGVVaW50MTYoQS5yaWdodE1vdG9yU3BlZWQpLEkubGVuZ3RoLWd9LGRlY29kZShBKXtjb25zdCBJPWUuQmVib3BWaWV3LmdldEluc3RhbmNlKCk7cmV0dXJuIEkuc3RhcnRSZWFkaW5nKEEpLHRoaXMucmVhZEZyb20oSSl9LHJlYWRGcm9tKEEpe2xldCBJLGcsZTtyZXR1cm4gST1BLnJlYWRCeXRlKCksZz1BLnJlYWRVaW50MTYoKSxlPUEucmVhZFVpbnQxNigpLHtwb3J0OkksbGVmdE1vdG9yU3BlZWQ6ZyxyaWdodE1vdG9yU3BlZWQ6ZX19fSxJLk1vdXNlQWJzb2x1dGU9e2Rpc2NyaW1pbmF0b3I6MyxlbmNvZGUoQSl7Y29uc3QgST1lLkJlYm9wVmlldy5nZXRJbnN0YW5jZSgpO3JldHVybiBJLnN0YXJ0V3JpdGluZygpLHRoaXMuZW5jb2RlSW50byhBLEkpLEkudG9BcnJheSgpfSxlbmNvZGVJbnRvKEEsSSl7Y29uc3QgZz1JLmxlbmd0aDtyZXR1cm4gSS53cml0ZUludDMyKEEueCksSS53cml0ZUludDMyKEEueSksSS5sZW5ndGgtZ30sZGVjb2RlKEEpe2NvbnN0IEk9ZS5CZWJvcFZpZXcuZ2V0SW5zdGFuY2UoKTtyZXR1cm4gSS5zdGFydFJlYWRpbmcoQSksdGhpcy5yZWFkRnJvbShJKX0scmVhZEZyb20oQSl7bGV0IEksZztyZXR1cm4gST1BLnJlYWRJbnQzMigpLGc9QS5yZWFkSW50MzIoKSx7eDpJLHk6Z319fSxJLk1vdXNlUmVsYXRpdmU9e2Rpc2NyaW1pbmF0b3I6NCxlbmNvZGUoQSl7Y29uc3QgST1lLkJlYm9wVmlldy5nZXRJbnN0YW5jZSgpO3JldHVybiBJLnN0YXJ0V3JpdGluZygpLHRoaXMuZW5jb2RlSW50byhBLEkpLEkudG9BcnJheSgpfSxlbmNvZGVJbnRvKEEsSSl7Y29uc3QgZz1JLmxlbmd0aDtyZXR1cm4gSS53cml0ZUludDMyKEEuZHgpLEkud3JpdGVJbnQzMihBLmR5KSxJLmxlbmd0aC1nfSxkZWNvZGUoQSl7Y29uc3QgST1lLkJlYm9wVmlldy5nZXRJbnN0YW5jZSgpO3JldHVybiBJLnN0YXJ0UmVhZGluZyhBKSx0aGlzLnJlYWRGcm9tKEkpfSxyZWFkRnJvbShBKXtsZXQgSSxnO3JldHVybiBJPUEucmVhZEludDMyKCksZz1BLnJlYWRJbnQzMigpLHtkeDpJLGR5Omd9fX0sSS5Nb3VzZUNsaWNrPXtkaXNjcmltaW5hdG9yOjUsZW5jb2RlKEEpe2NvbnN0IEk9ZS5CZWJvcFZpZXcuZ2V0SW5zdGFuY2UoKTtyZXR1cm4gSS5zdGFydFdyaXRpbmcoKSx0aGlzLmVuY29kZUludG8oQSxJKSxJLnRvQXJyYXkoKX0sZW5jb2RlSW50byhBLEkpe2NvbnN0IGc9SS5sZW5ndGg7cmV0dXJuIEkud3JpdGVVaW50MzIoQS5hY3Rpb24pLEkud3JpdGVVaW50MzIoQS5idXR0b24pLEkubGVuZ3RoLWd9LGRlY29kZShBKXtjb25zdCBJPWUuQmVib3BWaWV3LmdldEluc3RhbmNlKCk7cmV0dXJuIEkuc3RhcnRSZWFkaW5nKEEpLHRoaXMucmVhZEZyb20oSSl9LHJlYWRGcm9tKEEpe2xldCBJLGc7cmV0dXJuIEk9QS5yZWFkVWludDMyKCksZz1BLnJlYWRVaW50MzIoKSx7YWN0aW9uOkksYnV0dG9uOmd9fX0sSS5Nb3VzZVNjcm9sbD17ZGlzY3JpbWluYXRvcjo2LGVuY29kZShBKXtjb25zdCBJPWUuQmVib3BWaWV3LmdldEluc3RhbmNlKCk7cmV0dXJuIEkuc3RhcnRXcml0aW5nKCksdGhpcy5lbmNvZGVJbnRvKEEsSSksSS50b0FycmF5KCl9LGVuY29kZUludG8oQSxJKXtjb25zdCBnPUkubGVuZ3RoO3JldHVybiBJLndyaXRlVWludDMyKEEuYXhpcyksSS53cml0ZUludDMyKEEuZGVsdGEpLEkubGVuZ3RoLWd9LGRlY29kZShBKXtjb25zdCBJPWUuQmVib3BWaWV3LmdldEluc3RhbmNlKCk7cmV0dXJuIEkuc3RhcnRSZWFkaW5nKEEpLHRoaXMucmVhZEZyb20oSSl9LHJlYWRGcm9tKEEpe2xldCBJLGc7cmV0dXJuIEk9QS5yZWFkVWludDMyKCksZz1BLnJlYWRJbnQzMigpLHtheGlzOkksZGVsdGE6Z319fSxJLktleWJvYXJkSW5wdXQ9e2Rpc2NyaW1pbmF0b3I6NyxlbmNvZGUoQSl7Y29uc3QgST1lLkJlYm9wVmlldy5nZXRJbnN0YW5jZSgpO3JldHVybiBJLnN0YXJ0V3JpdGluZygpLHRoaXMuZW5jb2RlSW50byhBLEkpLEkudG9BcnJheSgpfSxlbmNvZGVJbnRvKEEsSSl7Y29uc3QgZz1JLmxlbmd0aDtJLndyaXRlVWludDMyKEEuYWN0aW9uKTt7Y29uc3QgZz1BLmtleWNvZGVzLmxlbmd0aDtJLndyaXRlVWludDMyKGcpO2ZvcihsZXQgZT0wO2U8ZztlKyspSS53cml0ZVVpbnQzMihBLmtleWNvZGVzW2VdKX1yZXR1cm4gSS5sZW5ndGgtZ30sZGVjb2RlKEEpe2NvbnN0IEk9ZS5CZWJvcFZpZXcuZ2V0SW5zdGFuY2UoKTtyZXR1cm4gSS5zdGFydFJlYWRpbmcoQSksdGhpcy5yZWFkRnJvbShJKX0scmVhZEZyb20oQSl7bGV0IEksZztJPUEucmVhZFVpbnQzMigpO3tsZXQgST1BLnJlYWRVaW50MzIoKTtnPW5ldyBBcnJheShJKTtmb3IobGV0IGU9MDtlPEk7ZSsrKXtsZXQgSTtJPUEucmVhZFVpbnQzMigpLGdbZV09SX19cmV0dXJue2FjdGlvbjpJLGtleWNvZGVzOmd9fX0sSS5Mb2dpY2FsSW5wdXQ9e2Rpc2NyaW1pbmF0b3I6OCxlbmNvZGUoQSl7Y29uc3QgST1lLkJlYm9wVmlldy5nZXRJbnN0YW5jZSgpO3JldHVybiBJLnN0YXJ0V3JpdGluZygpLHRoaXMuZW5jb2RlSW50byhBLEkpLEkudG9BcnJheSgpfSxlbmNvZGVJbnRvKEEsSSl7Y29uc3QgZz1JLmxlbmd0aDtyZXR1cm4gSS53cml0ZVN0cmluZyhBLmlucHV0U3RyaW5nKSxJLmxlbmd0aC1nfSxkZWNvZGUoQSl7Y29uc3QgST1lLkJlYm9wVmlldy5nZXRJbnN0YW5jZSgpO3JldHVybiBJLnN0YXJ0UmVhZGluZyhBKSx0aGlzLnJlYWRGcm9tKEkpfSxyZWFkRnJvbShBKXtsZXQgSTtyZXR1cm4gST1BLnJlYWRTdHJpbmcoKSx7aW5wdXRTdHJpbmc6SX19fSxJLlRvdWNoZXNBYnNvbHV0ZT17ZGlzY3JpbWluYXRvcjo5LGVuY29kZShBKXtjb25zdCBJPWUuQmVib3BWaWV3LmdldEluc3RhbmNlKCk7cmV0dXJuIEkuc3RhcnRXcml0aW5nKCksdGhpcy5lbmNvZGVJbnRvKEEsSSksSS50b0FycmF5KCl9LGVuY29kZUludG8oQSxnKXtjb25zdCBlPWcubGVuZ3RoO3tjb25zdCBlPUEudG91Y2hlcy5sZW5ndGg7Zy53cml0ZVVpbnQzMihlKTtmb3IobGV0IEI9MDtCPGU7QisrKUkuVG91Y2hBYnNvbHV0ZS5lbmNvZGVJbnRvKEEudG91Y2hlc1tCXSxnKX1yZXR1cm4gZy5sZW5ndGgtZX0sZGVjb2RlKEEpe2NvbnN0IEk9ZS5CZWJvcFZpZXcuZ2V0SW5zdGFuY2UoKTtyZXR1cm4gSS5zdGFydFJlYWRpbmcoQSksdGhpcy5yZWFkRnJvbShJKX0scmVhZEZyb20oQSl7bGV0IGc7e2xldCBlPUEucmVhZFVpbnQzMigpO2c9bmV3IEFycmF5KGUpO2ZvcihsZXQgQj0wO0I8ZTtCKyspe2xldCBlO2U9SS5Ub3VjaEFic29sdXRlLnJlYWRGcm9tKEEpLGdbQl09ZX19cmV0dXJue3RvdWNoZXM6Z319fSxJLlBlbkFic29sdXRlPXtkaXNjcmltaW5hdG9yOjEwLGVuY29kZShBKXtjb25zdCBJPWUuQmVib3BWaWV3LmdldEluc3RhbmNlKCk7cmV0dXJuIEkuc3RhcnRXcml0aW5nKCksdGhpcy5lbmNvZGVJbnRvKEEsSSksSS50b0FycmF5KCl9LGVuY29kZUludG8oQSxnKXtjb25zdCBlPWcubGVuZ3RoO3JldHVybiBJLlRvdWNoUGVuUG9pbnRlckluZm8uZW5jb2RlSW50byhBLnBvaW50ZXJJbmZvLGcpLGcud3JpdGVVaW50MzIoQS5wZW5GbGFncyksZy53cml0ZVVpbnQzMihBLnBlbk1hc2spLGcud3JpdGVVaW50MzIoQS5wcmVzc3VyZSksZy53cml0ZVVpbnQzMihBLnJvdGF0aW9uKSxnLndyaXRlSW50MzIoQS50aWx0WCksZy53cml0ZUludDMyKEEudGlsdFkpLGcubGVuZ3RoLWV9LGRlY29kZShBKXtjb25zdCBJPWUuQmVib3BWaWV3LmdldEluc3RhbmNlKCk7cmV0dXJuIEkuc3RhcnRSZWFkaW5nKEEpLHRoaXMucmVhZEZyb20oSSl9LHJlYWRGcm9tKEEpe2xldCBnLGUsQixpLFEsdCxDO3JldHVybiBnPUkuVG91Y2hQZW5Qb2ludGVySW5mby5yZWFkRnJvbShBKSxlPUEucmVhZFVpbnQzMigpLEI9QS5yZWFkVWludDMyKCksaT1BLnJlYWRVaW50MzIoKSxRPUEucmVhZFVpbnQzMigpLHQ9QS5yZWFkSW50MzIoKSxDPUEucmVhZEludDMyKCkse3BvaW50ZXJJbmZvOmcscGVuRmxhZ3M6ZSxwZW5NYXNrOkIscHJlc3N1cmU6aSxyb3RhdGlvbjpRLHRpbHRYOnQsdGlsdFk6Q319fSxJLlZpZXdwb3J0UmVzaXplPXtkaXNjcmltaW5hdG9yOjExLGVuY29kZShBKXtjb25zdCBJPWUuQmVib3BWaWV3LmdldEluc3RhbmNlKCk7cmV0dXJuIEkuc3RhcnRXcml0aW5nKCksdGhpcy5lbmNvZGVJbnRvKEEsSSksSS50b0FycmF5KCl9LGVuY29kZUludG8oQSxJKXtjb25zdCBnPUkubGVuZ3RoO3JldHVybiBJLndyaXRlVWludDMyKEEud2lkdGgpLEkud3JpdGVVaW50MzIoQS5oZWlnaHQpLEkubGVuZ3RoLWd9LGRlY29kZShBKXtjb25zdCBJPWUuQmVib3BWaWV3LmdldEluc3RhbmNlKCk7cmV0dXJuIEkuc3RhcnRSZWFkaW5nKEEpLHRoaXMucmVhZEZyb20oSSl9LHJlYWRGcm9tKEEpe2xldCBJLGc7cmV0dXJuIEk9QS5yZWFkVWludDMyKCksZz1BLnJlYWRVaW50MzIoKSx7d2lkdGg6SSxoZWlnaHQ6Z319fSxJLlNldENsaXBib2FyZFRleHQ9e2Rpc2NyaW1pbmF0b3I6MTIsZW5jb2RlKEEpe2NvbnN0IEk9ZS5CZWJvcFZpZXcuZ2V0SW5zdGFuY2UoKTtyZXR1cm4gSS5zdGFydFdyaXRpbmcoKSx0aGlzLmVuY29kZUludG8oQSxJKSxJLnRvQXJyYXkoKX0sZW5jb2RlSW50byhBLEkpe2NvbnN0IGc9SS5sZW5ndGg7cmV0dXJuIEkud3JpdGVTdHJpbmcoQS50ZXh0KSxJLmxlbmd0aC1nfSxkZWNvZGUoQSl7Y29uc3QgST1lLkJlYm9wVmlldy5nZXRJbnN0YW5jZSgpO3JldHVybiBJLnN0YXJ0UmVhZGluZyhBKSx0aGlzLnJlYWRGcm9tKEkpfSxyZWFkRnJvbShBKXtsZXQgSTtyZXR1cm4gST1BLnJlYWRTdHJpbmcoKSx7dGV4dDpJfX19LEkuSW5wdXRCb2R5PXtlbmNvZGUoQSl7Y29uc3QgST1lLkJlYm9wVmlldy5nZXRJbnN0YW5jZSgpO3JldHVybiBJLnN0YXJ0V3JpdGluZygpLHRoaXMuZW5jb2RlSW50byhBLEkpLEkudG9BcnJheSgpfSxlbmNvZGVJbnRvKEEsZyl7Y29uc3QgZT1nLmxlbmd0aCxCPWcucmVzZXJ2ZU1lc3NhZ2VMZW5ndGgoKSxpPWcubGVuZ3RoKzE7c3dpdGNoKGcud3JpdGVCeXRlKEEuZGlzY3JpbWluYXRvciksQS5kaXNjcmltaW5hdG9yKXtjYXNlIDE6SS5HYW1lcGFkUmVwb3J0LmVuY29kZUludG8oQS52YWx1ZSxnKTticmVhaztjYXNlIDI6SS5HYW1lcGFkUnVtYmxlLmVuY29kZUludG8oQS52YWx1ZSxnKTticmVhaztjYXNlIDM6SS5Nb3VzZUFic29sdXRlLmVuY29kZUludG8oQS52YWx1ZSxnKTticmVhaztjYXNlIDQ6SS5Nb3VzZVJlbGF0aXZlLmVuY29kZUludG8oQS52YWx1ZSxnKTticmVhaztjYXNlIDU6SS5Nb3VzZUNsaWNrLmVuY29kZUludG8oQS52YWx1ZSxnKTticmVhaztjYXNlIDY6SS5Nb3VzZVNjcm9sbC5lbmNvZGVJbnRvKEEudmFsdWUsZyk7YnJlYWs7Y2FzZSA3OkkuS2V5Ym9hcmRJbnB1dC5lbmNvZGVJbnRvKEEudmFsdWUsZyk7YnJlYWs7Y2FzZSA4OkkuTG9naWNhbElucHV0LmVuY29kZUludG8oQS52YWx1ZSxnKTticmVhaztjYXNlIDk6SS5Ub3VjaGVzQWJzb2x1dGUuZW5jb2RlSW50byhBLnZhbHVlLGcpO2JyZWFrO2Nhc2UgMTA6SS5QZW5BYnNvbHV0ZS5lbmNvZGVJbnRvKEEudmFsdWUsZyk7YnJlYWs7Y2FzZSAxMTpJLlZpZXdwb3J0UmVzaXplLmVuY29kZUludG8oQS52YWx1ZSxnKTticmVhaztjYXNlIDEyOkkuU2V0Q2xpcGJvYXJkVGV4dC5lbmNvZGVJbnRvKEEudmFsdWUsZyl9Y29uc3QgUT1nLmxlbmd0aDtyZXR1cm4gZy5maWxsTWVzc2FnZUxlbmd0aChCLFEtaSksZy5sZW5ndGgtZX0sZGVjb2RlKEEpe2NvbnN0IEk9ZS5CZWJvcFZpZXcuZ2V0SW5zdGFuY2UoKTtyZXR1cm4gSS5zdGFydFJlYWRpbmcoQSksdGhpcy5yZWFkRnJvbShJKX0scmVhZEZyb20oQSl7Y29uc3QgZz1BLnJlYWRNZXNzYWdlTGVuZ3RoKCksQj1BLmluZGV4KzErZztzd2l0Y2goQS5yZWFkQnl0ZSgpKXtjYXNlIDE6cmV0dXJue2Rpc2NyaW1pbmF0b3I6MSx2YWx1ZTpJLkdhbWVwYWRSZXBvcnQucmVhZEZyb20oQSl9O2Nhc2UgMjpyZXR1cm57ZGlzY3JpbWluYXRvcjoyLHZhbHVlOkkuR2FtZXBhZFJ1bWJsZS5yZWFkRnJvbShBKX07Y2FzZSAzOnJldHVybntkaXNjcmltaW5hdG9yOjMsdmFsdWU6SS5Nb3VzZUFic29sdXRlLnJlYWRGcm9tKEEpfTtjYXNlIDQ6cmV0dXJue2Rpc2NyaW1pbmF0b3I6NCx2YWx1ZTpJLk1vdXNlUmVsYXRpdmUucmVhZEZyb20oQSl9O2Nhc2UgNTpyZXR1cm57ZGlzY3JpbWluYXRvcjo1LHZhbHVlOkkuTW91c2VDbGljay5yZWFkRnJvbShBKX07Y2FzZSA2OnJldHVybntkaXNjcmltaW5hdG9yOjYsdmFsdWU6SS5Nb3VzZVNjcm9sbC5yZWFkRnJvbShBKX07Y2FzZSA3OnJldHVybntkaXNjcmltaW5hdG9yOjcsdmFsdWU6SS5LZXlib2FyZElucHV0LnJlYWRGcm9tKEEpfTtjYXNlIDg6cmV0dXJue2Rpc2NyaW1pbmF0b3I6OCx2YWx1ZTpJLkxvZ2ljYWxJbnB1dC5yZWFkRnJvbShBKX07Y2FzZSA5OnJldHVybntkaXNjcmltaW5hdG9yOjksdmFsdWU6SS5Ub3VjaGVzQWJzb2x1dGUucmVhZEZyb20oQSl9O2Nhc2UgMTA6cmV0dXJue2Rpc2NyaW1pbmF0b3I6MTAsdmFsdWU6SS5QZW5BYnNvbHV0ZS5yZWFkRnJvbShBKX07Y2FzZSAxMTpyZXR1cm57ZGlzY3JpbWluYXRvcjoxMSx2YWx1ZTpJLlZpZXdwb3J0UmVzaXplLnJlYWRGcm9tKEEpfTtjYXNlIDEyOnJldHVybntkaXNjcmltaW5hdG9yOjEyLHZhbHVlOkkuU2V0Q2xpcGJvYXJkVGV4dC5yZWFkRnJvbShBKX07ZGVmYXVsdDp0aHJvdyBBLmluZGV4PUIsbmV3IGUuQmVib3BSdW50aW1lRXJyb3IoXCJVbnJlY29nbml6ZWQgZGlzY3JpbWluYXRvciB3aGlsZSBkZWNvZGluZyBJbnB1dEJvZHlcIil9fX0sKGM9SS5WaWRlb0NvZGVjVHlwZXx8KEkuVmlkZW9Db2RlY1R5cGU9e30pKVtjLkJhc2VsaW5lPTFdPVwiQmFzZWxpbmVcIixjW2MuTWFpbj0yXT1cIk1haW5cIixjW2MuSGlnaD00XT1cIkhpZ2hcIixjW2MuSDI2ND03XT1cIkgyNjRcIixjW2MuSDI2NT04XT1cIkgyNjVcIiwoaD1JLlZlbmRvcnx8KEkuVmVuZG9yPXt9KSlbaC5Vbmtub3duPTBdPVwiVW5rbm93blwiLGhbaC5BbWQ9NDA5OF09XCJBbWRcIixoW2guTnZpZGlhPTQzMThdPVwiTnZpZGlhXCIsaFtoLkludGVsPTMyOTAyXT1cIkludGVsXCIsSS5WaWRlb0NvZGVjPXtlbmNvZGUoQSl7Y29uc3QgST1lLkJlYm9wVmlldy5nZXRJbnN0YW5jZSgpO3JldHVybiBJLnN0YXJ0V3JpdGluZygpLHRoaXMuZW5jb2RlSW50byhBLEkpLEkudG9BcnJheSgpfSxlbmNvZGVJbnRvKEEsSSl7Y29uc3QgZz1JLmxlbmd0aDtyZXR1cm4gSS53cml0ZVN0cmluZyhBLmZyaWVuZGx5TmFtZSksSS53cml0ZVVpbnQzMihBLndpZHRoKSxJLndyaXRlVWludDMyKEEuaGVpZ2h0KSxJLndyaXRlVWludDMyKEEucmVmcmVzaFJhdGUpLEkud3JpdGVCeXRlcyhBLmRhdGEpLEkud3JpdGVVaW50MzIoQS50eXBlKSxJLmxlbmd0aC1nfSxkZWNvZGUoQSl7Y29uc3QgST1lLkJlYm9wVmlldy5nZXRJbnN0YW5jZSgpO3JldHVybiBJLnN0YXJ0UmVhZGluZyhBKSx0aGlzLnJlYWRGcm9tKEkpfSxyZWFkRnJvbShBKXtsZXQgSSxnLGUsQixpLFE7cmV0dXJuIEk9QS5yZWFkU3RyaW5nKCksZz1BLnJlYWRVaW50MzIoKSxlPUEucmVhZFVpbnQzMigpLEI9QS5yZWFkVWludDMyKCksaT1BLnJlYWRCeXRlcygpLFE9QS5yZWFkVWludDMyKCkse2ZyaWVuZGx5TmFtZTpJLHdpZHRoOmcsaGVpZ2h0OmUscmVmcmVzaFJhdGU6QixkYXRhOmksdHlwZTpRfX19LChkPUkuRm9ybUZhY3Rvcnx8KEkuRm9ybUZhY3Rvcj17fSkpW2QuVW5rbm93bj0wXT1cIlVua25vd25cIixkW2QuUGhvbmU9MV09XCJQaG9uZVwiLGRbZC5UYWJsZXQ9Ml09XCJUYWJsZXRcIixkW2QuQ29tcHV0ZXI9M109XCJDb21wdXRlclwiLGRbZC5Db25zb2xlPTRdPVwiQ29uc29sZVwiLGRbZC5Udj01XT1cIlR2XCIsKHI9SS5PcGVyYXRpbmdTeXN0ZW18fChJLk9wZXJhdGluZ1N5c3RlbT17fSkpW3IuT3RoZXI9MF09XCJPdGhlclwiLHJbci5JT1M9MV09XCJJT1NcIixyW3IuVHZPUz0yXT1cIlR2T1NcIixyW3IuQW5kcm9pZD0zXT1cIkFuZHJvaWRcIixyW3IuV2luZG93cz00XT1cIldpbmRvd3NcIixyW3IuTWFjT1M9NV09XCJNYWNPU1wiLHJbci5MaW51eD02XT1cIkxpbnV4XCIscltyLlJva3U9N109XCJSb2t1XCIsKHM9SS5OZXR3b3JrUHJvdG9jb2x8fChJLk5ldHdvcmtQcm90b2NvbD17fSkpW3MuV2ViUlRDPTBdPVwiV2ViUlRDXCIsc1tzLkdleXNlcj0xXT1cIkdleXNlclwiLChuPUkuQXVkaW9DaGFubmVsc3x8KEkuQXVkaW9DaGFubmVscz17fSkpW24uTW9ubz0wXT1cIk1vbm9cIixuW24uU3RlcmVvPTFdPVwiU3RlcmVvXCIsbltuLlN1cnJvdW5kNTE9Ml09XCJTdXJyb3VuZDUxXCIsbltuLlN1cnJvdW5kNzE9M109XCJTdXJyb3VuZDcxXCIsKGE9SS5BdWRpb0NvZGVjfHwoSS5BdWRpb0NvZGVjPXt9KSlbYS5PcHVzPTBdPVwiT3B1c1wiLGFbYS5BYWM9MV09XCJBYWNcIiwobz1JLkF1ZGlvQ29udGFpbmVyfHwoSS5BdWRpb0NvbnRhaW5lcj17fSkpW28uUmF3PTBdPVwiUmF3XCIsb1tvLldlYk09MV09XCJXZWJNXCIsb1tvLklzb0JNRkY9Ml09XCJJc29CTUZGXCIsKEU9SS5WaWRlb0NvbnRhaW5lcnx8KEkuVmlkZW9Db250YWluZXI9e30pKVtFLlJhdz0wXT1cIlJhd1wiLEVbRS5Jc29CTUZGPTFdPVwiSXNvQk1GRlwiLChDPUkuTG9naWNFcnJvcnx8KEkuTG9naWNFcnJvcj17fSkpW0MuVW5rbm93bkVycm9yPTBdPVwiVW5rbm93bkVycm9yXCIsQ1tDLkRpc3BsYXlzTWlzc2luZz0xXT1cIkRpc3BsYXlzTWlzc2luZ1wiLENbQy5Ob0F2YWlsYWJsZUVuY29kZXI9Ml09XCJOb0F2YWlsYWJsZUVuY29kZXJcIixDW0MuSW52YWxpZEVuY29kaW5nQ29uZmlnPTNdPVwiSW52YWxpZEVuY29kaW5nQ29uZmlnXCIsQ1tDLk5vQ29kZWNzRXhjaGFuZ2VkPTRdPVwiTm9Db2RlY3NFeGNoYW5nZWRcIixDW0MuTm9DYXBhYmlsaXRpZXM9NV09XCJOb0NhcGFiaWxpdGllc1wiLENbQy5Ob1N1Y2hTdHJlYW09Nl09XCJOb1N1Y2hTdHJlYW1cIixDW0MuRm9yY2VTZWdtZW50RmFpbGVkPTddPVwiRm9yY2VTZWdtZW50RmFpbGVkXCIsSS5BdWRpb0NvbmZpZz17ZW5jb2RlKEEpe2NvbnN0IEk9ZS5CZWJvcFZpZXcuZ2V0SW5zdGFuY2UoKTtyZXR1cm4gSS5zdGFydFdyaXRpbmcoKSx0aGlzLmVuY29kZUludG8oQSxJKSxJLnRvQXJyYXkoKX0sZW5jb2RlSW50byhBLEkpe2NvbnN0IGc9SS5sZW5ndGg7cmV0dXJuIEkud3JpdGVVaW50MzIoQS5jb2RlYyksSS53cml0ZVVpbnQzMihBLmNvbnRhaW5lciksSS5sZW5ndGgtZ30sZGVjb2RlKEEpe2NvbnN0IEk9ZS5CZWJvcFZpZXcuZ2V0SW5zdGFuY2UoKTtyZXR1cm4gSS5zdGFydFJlYWRpbmcoQSksdGhpcy5yZWFkRnJvbShJKX0scmVhZEZyb20oQSl7bGV0IEksZztyZXR1cm4gST1BLnJlYWRVaW50MzIoKSxnPUEucmVhZFVpbnQzMigpLHtjb2RlYzpJLGNvbnRhaW5lcjpnfX19LCh0PUkuQ2FwdHVyZU1vZGV8fChJLkNhcHR1cmVNb2RlPXt9KSlbdC5Vbmtub3duPTBdPVwiVW5rbm93blwiLHRbdC5GdWxsRGVza3RvcD0xXT1cIkZ1bGxEZXNrdG9wXCIsdFt0LkFwcElzb2xhdGlvbj0yXT1cIkFwcElzb2xhdGlvblwiLHRbdC5CWU9GQj0zXT1cIkJZT0ZCXCIsSS5WaWRlb0NvbmZpZz17ZW5jb2RlKEEpe2NvbnN0IEk9ZS5CZWJvcFZpZXcuZ2V0SW5zdGFuY2UoKTtyZXR1cm4gSS5zdGFydFdyaXRpbmcoKSx0aGlzLmVuY29kZUludG8oQSxJKSxJLnRvQXJyYXkoKX0sZW5jb2RlSW50byhBLGcpe2NvbnN0IGU9Zy5sZW5ndGg7cmV0dXJuIEkuVmlkZW9Db2RlYy5lbmNvZGVJbnRvKEEuY29kZWMsZyksZy53cml0ZVVpbnQzMihBLmNvbnRhaW5lciksZy5sZW5ndGgtZX0sZGVjb2RlKEEpe2NvbnN0IEk9ZS5CZWJvcFZpZXcuZ2V0SW5zdGFuY2UoKTtyZXR1cm4gSS5zdGFydFJlYWRpbmcoQSksdGhpcy5yZWFkRnJvbShJKX0scmVhZEZyb20oQSl7bGV0IGcsZTtyZXR1cm4gZz1JLlZpZGVvQ29kZWMucmVhZEZyb20oQSksZT1BLnJlYWRVaW50MzIoKSx7Y29kZWM6Zyxjb250YWluZXI6ZX19fSwoUT1JLklucHV0TGV2ZWx8fChJLklucHV0TGV2ZWw9e30pKVtRLk5vbmU9MF09XCJOb25lXCIsUVtRLkdhbWVwYWRQb3J0MT0xXT1cIkdhbWVwYWRQb3J0MVwiLFFbUS5HYW1lcGFkUG9ydDI9Ml09XCJHYW1lcGFkUG9ydDJcIixRW1EuR2FtZXBhZFBvcnQzPTRdPVwiR2FtZXBhZFBvcnQzXCIsUVtRLkdhbWVwYWRQb3J0ND04XT1cIkdhbWVwYWRQb3J0NFwiLFFbUS5HYW1lcGFkPTE1XT1cIkdhbWVwYWRcIixRW1EuTW91c2U9MTZdPVwiTW91c2VcIixRW1EuS2V5Ym9hcmQ9MzJdPVwiS2V5Ym9hcmRcIixRW1EuQ2xpcGJvYXJkPTY0XT1cIkNsaXBib2FyZFwiLEkuRGV2aWNlSW5mbz17ZGlzY3JpbWluYXRvcjoxLGVuY29kZShBKXtjb25zdCBJPWUuQmVib3BWaWV3LmdldEluc3RhbmNlKCk7cmV0dXJuIEkuc3RhcnRXcml0aW5nKCksdGhpcy5lbmNvZGVJbnRvKEEsSSksSS50b0FycmF5KCl9LGVuY29kZUludG8oQSxJKXtjb25zdCBnPUkubGVuZ3RoO3JldHVybiBJLndyaXRlVWludDMyKEEuZm9ybUZhY3RvciksSS53cml0ZVN0cmluZyhBLmRldmljZU5hbWUpLEkud3JpdGVVaW50MzIoQS5kZXZpY2VPcyksSS53cml0ZVN0cmluZyhBLmRldmljZU9zVmVyc2lvbiksSS53cml0ZVN0cmluZyhBLmRldmljZU1vZGVsKSxJLndyaXRlU3RyaW5nKEEudXNlckFnZW50KSxJLndyaXRlU3RyaW5nKEEuZGV2aWNlSWQpLEkud3JpdGVCeXRlKE51bWJlcihBLmlzV2ViKSksSS5sZW5ndGgtZ30sZGVjb2RlKEEpe2NvbnN0IEk9ZS5CZWJvcFZpZXcuZ2V0SW5zdGFuY2UoKTtyZXR1cm4gSS5zdGFydFJlYWRpbmcoQSksdGhpcy5yZWFkRnJvbShJKX0scmVhZEZyb20oQSl7bGV0IEksZyxlLEIsaSxRLHQsQztyZXR1cm4gST1BLnJlYWRVaW50MzIoKSxnPUEucmVhZFN0cmluZygpLGU9QS5yZWFkVWludDMyKCksQj1BLnJlYWRTdHJpbmcoKSxpPUEucmVhZFN0cmluZygpLFE9QS5yZWFkU3RyaW5nKCksdD1BLnJlYWRTdHJpbmcoKSxDPSEhQS5yZWFkQnl0ZSgpLHtmb3JtRmFjdG9yOkksZGV2aWNlTmFtZTpnLGRldmljZU9zOmUsZGV2aWNlT3NWZXJzaW9uOkIsZGV2aWNlTW9kZWw6aSx1c2VyQWdlbnQ6USxkZXZpY2VJZDp0LGlzV2ViOkN9fX0sSS5Db2RlY1BhY2tSZXF1ZXN0PXtkaXNjcmltaW5hdG9yOjIsZW5jb2RlKEEpe2NvbnN0IEk9ZS5CZWJvcFZpZXcuZ2V0SW5zdGFuY2UoKTtyZXR1cm4gSS5zdGFydFdyaXRpbmcoKSx0aGlzLmVuY29kZUludG8oQSxJKSxJLnRvQXJyYXkoKX0sZW5jb2RlSW50byhBLEkpe2NvbnN0IGc9SS5sZW5ndGg7cmV0dXJuIEkubGVuZ3RoLWd9LGRlY29kZShBKXtjb25zdCBJPWUuQmVib3BWaWV3LmdldEluc3RhbmNlKCk7cmV0dXJuIEkuc3RhcnRSZWFkaW5nKEEpLHRoaXMucmVhZEZyb20oSSl9LHJlYWRGcm9tOkE9Pih7fSl9LEkuQ29kZWNQYWNrUmVzcG9uc2U9e2Rpc2NyaW1pbmF0b3I6MyxlbmNvZGUoQSl7Y29uc3QgST1lLkJlYm9wVmlldy5nZXRJbnN0YW5jZSgpO3JldHVybiBJLnN0YXJ0V3JpdGluZygpLHRoaXMuZW5jb2RlSW50byhBLEkpLEkudG9BcnJheSgpfSxlbmNvZGVJbnRvKEEsZyl7Y29uc3QgZT1nLmxlbmd0aDt7Y29uc3QgZT1BLnZpZGVvQ29kZWNzLmxlbmd0aDtnLndyaXRlVWludDMyKGUpO2ZvcihsZXQgQj0wO0I8ZTtCKyspSS5WaWRlb0NvZGVjLmVuY29kZUludG8oQS52aWRlb0NvZGVjc1tCXSxnKX1yZXR1cm4gZy5sZW5ndGgtZX0sZGVjb2RlKEEpe2NvbnN0IEk9ZS5CZWJvcFZpZXcuZ2V0SW5zdGFuY2UoKTtyZXR1cm4gSS5zdGFydFJlYWRpbmcoQSksdGhpcy5yZWFkRnJvbShJKX0scmVhZEZyb20oQSl7bGV0IGc7e2xldCBlPUEucmVhZFVpbnQzMigpO2c9bmV3IEFycmF5KGUpO2ZvcihsZXQgQj0wO0I8ZTtCKyspe2xldCBlO2U9SS5WaWRlb0NvZGVjLnJlYWRGcm9tKEEpLGdbQl09ZX19cmV0dXJue3ZpZGVvQ29kZWNzOmd9fX0sSS5DbGllbnRDYXBhYmlsaXRpZXM9e2Rpc2NyaW1pbmF0b3I6NCxlbmNvZGUoQSl7Y29uc3QgST1lLkJlYm9wVmlldy5nZXRJbnN0YW5jZSgpO3JldHVybiBJLnN0YXJ0V3JpdGluZygpLHRoaXMuZW5jb2RlSW50byhBLEkpLEkudG9BcnJheSgpfSxlbmNvZGVJbnRvKEEsZyl7Y29uc3QgZT1nLmxlbmd0aDtnLndyaXRlVWludDMyKEEucHJlZmVycmVkV2lkdGgpLGcud3JpdGVVaW50MzIoQS5wcmVmZXJyZWRIZWlnaHQpLGcud3JpdGVVaW50MzIoQS5wcmVmZXJyZWRGcHMpLGcud3JpdGVVaW50MzIoQS5wcmVmZXJyZWRBdWRpb0JpdHJhdGUpLGcud3JpdGVVaW50MzIoQS5wcmVmZXJyZWRWaWRlb0JpdHJhdGUpLGcud3JpdGVVaW50MzIoQS5wcmVmZXJyZWRBdWRpb0NoYW5uZWxzKSxJLkF1ZGlvQ29uZmlnLmVuY29kZUludG8oQS5wcmVmZXJyZWRBdWRpb0NvbmZpZyxnKSxJLlZpZGVvQ29uZmlnLmVuY29kZUludG8oQS5wcmVmZXJyZWRWaWRlb0NvbmZpZyxnKTt7Y29uc3QgST1BLnN1cHBvcnRlZEF1ZGlvQ2hhbm5lbHMubGVuZ3RoO2cud3JpdGVVaW50MzIoSSk7Zm9yKGxldCBlPTA7ZTxJO2UrKylnLndyaXRlVWludDMyKEEuc3VwcG9ydGVkQXVkaW9DaGFubmVsc1tlXSl9e2NvbnN0IGU9QS5zdXBwb3J0ZWRBdWRpb0NvbmZpZ3MubGVuZ3RoO2cud3JpdGVVaW50MzIoZSk7Zm9yKGxldCBCPTA7QjxlO0IrKylJLkF1ZGlvQ29uZmlnLmVuY29kZUludG8oQS5zdXBwb3J0ZWRBdWRpb0NvbmZpZ3NbQl0sZyl9e2NvbnN0IGU9QS5zdXBwb3J0ZWRWaWRlb0NvbmZpZ3MubGVuZ3RoO2cud3JpdGVVaW50MzIoZSk7Zm9yKGxldCBCPTA7QjxlO0IrKylJLlZpZGVvQ29uZmlnLmVuY29kZUludG8oQS5zdXBwb3J0ZWRWaWRlb0NvbmZpZ3NbQl0sZyl9cmV0dXJuIGcud3JpdGVCeXRlKE51bWJlcihBLnN1cHBvcnRzT3ZlcjEwODBQKSksZy53cml0ZUJ5dGUoTnVtYmVyKEEuc3VwcG9ydHNUZW1wb3JhbFNjYWxpbmcpKSxnLndyaXRlQnl0ZShOdW1iZXIoQS5zdXBwb3J0c0FwcElzb2xhdGlvbikpLGcubGVuZ3RoLWV9LGRlY29kZShBKXtjb25zdCBJPWUuQmVib3BWaWV3LmdldEluc3RhbmNlKCk7cmV0dXJuIEkuc3RhcnRSZWFkaW5nKEEpLHRoaXMucmVhZEZyb20oSSl9LHJlYWRGcm9tKEEpe2xldCBnLGUsQixpLFEsdCxDLEUsbyxhLG4scyxyLGQ7Zz1BLnJlYWRVaW50MzIoKSxlPUEucmVhZFVpbnQzMigpLEI9QS5yZWFkVWludDMyKCksaT1BLnJlYWRVaW50MzIoKSxRPUEucmVhZFVpbnQzMigpLHQ9QS5yZWFkVWludDMyKCksQz1JLkF1ZGlvQ29uZmlnLnJlYWRGcm9tKEEpLEU9SS5WaWRlb0NvbmZpZy5yZWFkRnJvbShBKTt7bGV0IEk9QS5yZWFkVWludDMyKCk7bz1uZXcgQXJyYXkoSSk7Zm9yKGxldCBnPTA7ZzxJO2crKyl7bGV0IEk7ST1BLnJlYWRVaW50MzIoKSxvW2ddPUl9fXtsZXQgZz1BLnJlYWRVaW50MzIoKTthPW5ldyBBcnJheShnKTtmb3IobGV0IGU9MDtlPGc7ZSsrKXtsZXQgZztnPUkuQXVkaW9Db25maWcucmVhZEZyb20oQSksYVtlXT1nfX17bGV0IGc9QS5yZWFkVWludDMyKCk7bj1uZXcgQXJyYXkoZyk7Zm9yKGxldCBlPTA7ZTxnO2UrKyl7bGV0IGc7Zz1JLlZpZGVvQ29uZmlnLnJlYWRGcm9tKEEpLG5bZV09Z319cmV0dXJuIHM9ISFBLnJlYWRCeXRlKCkscj0hIUEucmVhZEJ5dGUoKSxkPSEhQS5yZWFkQnl0ZSgpLHtwcmVmZXJyZWRXaWR0aDpnLHByZWZlcnJlZEhlaWdodDplLHByZWZlcnJlZEZwczpCLHByZWZlcnJlZEF1ZGlvQml0cmF0ZTppLHByZWZlcnJlZFZpZGVvQml0cmF0ZTpRLHByZWZlcnJlZEF1ZGlvQ2hhbm5lbHM6dCxwcmVmZXJyZWRBdWRpb0NvbmZpZzpDLHByZWZlcnJlZFZpZGVvQ29uZmlnOkUsc3VwcG9ydGVkQXVkaW9DaGFubmVsczpvLHN1cHBvcnRlZEF1ZGlvQ29uZmlnczphLHN1cHBvcnRlZFZpZGVvQ29uZmlnczpuLHN1cHBvcnRzT3ZlcjEwODBQOnMsc3VwcG9ydHNUZW1wb3JhbFNjYWxpbmc6cixzdXBwb3J0c0FwcElzb2xhdGlvbjpkfX19LEkuRXJyb3JSZXNwb25zZT17ZGlzY3JpbWluYXRvcjo1LGVuY29kZShBKXtjb25zdCBJPWUuQmVib3BWaWV3LmdldEluc3RhbmNlKCk7cmV0dXJuIEkuc3RhcnRXcml0aW5nKCksdGhpcy5lbmNvZGVJbnRvKEEsSSksSS50b0FycmF5KCl9LGVuY29kZUludG8oQSxJKXtjb25zdCBnPUkubGVuZ3RoO3JldHVybiBJLndyaXRlVWludDMyKEEuZXJyb3IpLEkubGVuZ3RoLWd9LGRlY29kZShBKXtjb25zdCBJPWUuQmVib3BWaWV3LmdldEluc3RhbmNlKCk7cmV0dXJuIEkuc3RhcnRSZWFkaW5nKEEpLHRoaXMucmVhZEZyb20oSSl9LHJlYWRGcm9tKEEpe2xldCBJO3JldHVybiBJPUEucmVhZFVpbnQzMigpLHtlcnJvcjpJfX19LEkuU3RyZWFtUmVxdWVzdD17ZGlzY3JpbWluYXRvcjo2LGVuY29kZShBKXtjb25zdCBJPWUuQmVib3BWaWV3LmdldEluc3RhbmNlKCk7cmV0dXJuIEkuc3RhcnRXcml0aW5nKCksdGhpcy5lbmNvZGVJbnRvKEEsSSksSS50b0FycmF5KCl9LGVuY29kZUludG8oQSxJKXtjb25zdCBnPUkubGVuZ3RoO3JldHVybiBJLndyaXRlVWludDMyKEEuaW5wdXRMZXZlbCksSS5sZW5ndGgtZ30sZGVjb2RlKEEpe2NvbnN0IEk9ZS5CZWJvcFZpZXcuZ2V0SW5zdGFuY2UoKTtyZXR1cm4gSS5zdGFydFJlYWRpbmcoQSksdGhpcy5yZWFkRnJvbShJKX0scmVhZEZyb20oQSl7bGV0IEk7cmV0dXJuIEk9QS5yZWFkVWludDMyKCkse2lucHV0TGV2ZWw6SX19fSxJLlN0cmVhbVN0YXJ0aW5nPXtkaXNjcmltaW5hdG9yOjcsZW5jb2RlKEEpe2NvbnN0IEk9ZS5CZWJvcFZpZXcuZ2V0SW5zdGFuY2UoKTtyZXR1cm4gSS5zdGFydFdyaXRpbmcoKSx0aGlzLmVuY29kZUludG8oQSxJKSxJLnRvQXJyYXkoKX0sZW5jb2RlSW50byhBLGcpe2NvbnN0IGU9Zy5sZW5ndGg7cmV0dXJuIGcud3JpdGVCeXRlKEEuc3RyZWFtSWQpLGcud3JpdGVVaW50MzIoQS5pbnB1dExldmVsKSxnLndyaXRlRmxvYXQzMihBLnRlbXBvcmFsU2NhbGVGYWN0b3IpLEkuQXVkaW9Db25maWcuZW5jb2RlSW50byhBLmNob3NlbkF1ZGlvQ29uZmlnLGcpLEkuVmlkZW9Db25maWcuZW5jb2RlSW50byhBLmNob3NlblZpZGVvQ29uZmlnLGcpLGcud3JpdGVVaW50MzIoQS5jYXB0dXJlTW9kZSksZy5sZW5ndGgtZX0sZGVjb2RlKEEpe2NvbnN0IEk9ZS5CZWJvcFZpZXcuZ2V0SW5zdGFuY2UoKTtyZXR1cm4gSS5zdGFydFJlYWRpbmcoQSksdGhpcy5yZWFkRnJvbShJKX0scmVhZEZyb20oQSl7bGV0IGcsZSxCLGksUSx0O3JldHVybiBnPUEucmVhZEJ5dGUoKSxlPUEucmVhZFVpbnQzMigpLEI9QS5yZWFkRmxvYXQzMigpLGk9SS5BdWRpb0NvbmZpZy5yZWFkRnJvbShBKSxRPUkuVmlkZW9Db25maWcucmVhZEZyb20oQSksdD1BLnJlYWRVaW50MzIoKSx7c3RyZWFtSWQ6ZyxpbnB1dExldmVsOmUsdGVtcG9yYWxTY2FsZUZhY3RvcjpCLGNob3NlbkF1ZGlvQ29uZmlnOmksY2hvc2VuVmlkZW9Db25maWc6USxjYXB0dXJlTW9kZTp0fX19LEkuTGVhdmVTdHJlYW09e2Rpc2NyaW1pbmF0b3I6OCxlbmNvZGUoQSl7Y29uc3QgST1lLkJlYm9wVmlldy5nZXRJbnN0YW5jZSgpO3JldHVybiBJLnN0YXJ0V3JpdGluZygpLHRoaXMuZW5jb2RlSW50byhBLEkpLEkudG9BcnJheSgpfSxlbmNvZGVJbnRvKEEsSSl7Y29uc3QgZz1JLmxlbmd0aDtyZXR1cm4gSS53cml0ZUJ5dGUoQS5zdHJlYW1JZCksSS5sZW5ndGgtZ30sZGVjb2RlKEEpe2NvbnN0IEk9ZS5CZWJvcFZpZXcuZ2V0SW5zdGFuY2UoKTtyZXR1cm4gSS5zdGFydFJlYWRpbmcoQSksdGhpcy5yZWFkRnJvbShJKX0scmVhZEZyb20oQSl7bGV0IEk7cmV0dXJuIEk9QS5yZWFkQnl0ZSgpLHtzdHJlYW1JZDpJfX19LEkuU3RyZWFtU3RvcHBpbmc9e2Rpc2NyaW1pbmF0b3I6OSxlbmNvZGUoQSl7Y29uc3QgST1lLkJlYm9wVmlldy5nZXRJbnN0YW5jZSgpO3JldHVybiBJLnN0YXJ0V3JpdGluZygpLHRoaXMuZW5jb2RlSW50byhBLEkpLEkudG9BcnJheSgpfSxlbmNvZGVJbnRvKEEsSSl7Y29uc3QgZz1JLmxlbmd0aDtyZXR1cm4gSS53cml0ZUJ5dGUoQS5zdHJlYW1JZCksSS5sZW5ndGgtZ30sZGVjb2RlKEEpe2NvbnN0IEk9ZS5CZWJvcFZpZXcuZ2V0SW5zdGFuY2UoKTtyZXR1cm4gSS5zdGFydFJlYWRpbmcoQSksdGhpcy5yZWFkRnJvbShJKX0scmVhZEZyb20oQSl7bGV0IEk7cmV0dXJuIEk9QS5yZWFkQnl0ZSgpLHtzdHJlYW1JZDpJfX19LEkuS2V5ZnJhbWVSZXF1ZXN0PXtkaXNjcmltaW5hdG9yOjEwLGVuY29kZShBKXtjb25zdCBJPWUuQmVib3BWaWV3LmdldEluc3RhbmNlKCk7cmV0dXJuIEkuc3RhcnRXcml0aW5nKCksdGhpcy5lbmNvZGVJbnRvKEEsSSksSS50b0FycmF5KCl9LGVuY29kZUludG8oQSxJKXtjb25zdCBnPUkubGVuZ3RoO3JldHVybiBJLndyaXRlQnl0ZShBLnN0cmVhbUlkKSxJLmxlbmd0aC1nfSxkZWNvZGUoQSl7Y29uc3QgST1lLkJlYm9wVmlldy5nZXRJbnN0YW5jZSgpO3JldHVybiBJLnN0YXJ0UmVhZGluZyhBKSx0aGlzLnJlYWRGcm9tKEkpfSxyZWFkRnJvbShBKXtsZXQgSTtyZXR1cm4gST1BLnJlYWRCeXRlKCkse3N0cmVhbUlkOkl9fX0sSS5WaWRlb0JpdHJhdGVSZXF1ZXN0PXtkaXNjcmltaW5hdG9yOjExLGVuY29kZShBKXtjb25zdCBJPWUuQmVib3BWaWV3LmdldEluc3RhbmNlKCk7cmV0dXJuIEkuc3RhcnRXcml0aW5nKCksdGhpcy5lbmNvZGVJbnRvKEEsSSksSS50b0FycmF5KCl9LGVuY29kZUludG8oQSxJKXtjb25zdCBnPUkubGVuZ3RoO3JldHVybiBJLndyaXRlQnl0ZShBLnN0cmVhbUlkKSxJLndyaXRlVWludDMyKEEuYml0c1BlclNlY29uZCksSS5sZW5ndGgtZ30sZGVjb2RlKEEpe2NvbnN0IEk9ZS5CZWJvcFZpZXcuZ2V0SW5zdGFuY2UoKTtyZXR1cm4gSS5zdGFydFJlYWRpbmcoQSksdGhpcy5yZWFkRnJvbShJKX0scmVhZEZyb20oQSl7bGV0IEksZztyZXR1cm4gST1BLnJlYWRCeXRlKCksZz1BLnJlYWRVaW50MzIoKSx7c3RyZWFtSWQ6SSxiaXRzUGVyU2Vjb25kOmd9fX0sSS5Kb2luU3RyZWFtPXtkaXNjcmltaW5hdG9yOjEyLGVuY29kZShBKXtjb25zdCBJPWUuQmVib3BWaWV3LmdldEluc3RhbmNlKCk7cmV0dXJuIEkuc3RhcnRXcml0aW5nKCksdGhpcy5lbmNvZGVJbnRvKEEsSSksSS50b0FycmF5KCl9LGVuY29kZUludG8oQSxJKXtjb25zdCBnPUkubGVuZ3RoO3JldHVybiBJLndyaXRlQnl0ZShBLnN0cmVhbUlkKSxJLmxlbmd0aC1nfSxkZWNvZGUoQSl7Y29uc3QgST1lLkJlYm9wVmlldy5nZXRJbnN0YW5jZSgpO3JldHVybiBJLnN0YXJ0UmVhZGluZyhBKSx0aGlzLnJlYWRGcm9tKEkpfSxyZWFkRnJvbShBKXtsZXQgSTtyZXR1cm4gST1BLnJlYWRCeXRlKCkse3N0cmVhbUlkOkl9fX0sSS5QYXVzZVN0cmVhbT17ZGlzY3JpbWluYXRvcjoxMyxlbmNvZGUoQSl7Y29uc3QgST1lLkJlYm9wVmlldy5nZXRJbnN0YW5jZSgpO3JldHVybiBJLnN0YXJ0V3JpdGluZygpLHRoaXMuZW5jb2RlSW50byhBLEkpLEkudG9BcnJheSgpfSxlbmNvZGVJbnRvKEEsSSl7Y29uc3QgZz1JLmxlbmd0aDtyZXR1cm4gSS53cml0ZUJ5dGUoQS5zdHJlYW1JZCksSS5sZW5ndGgtZ30sZGVjb2RlKEEpe2NvbnN0IEk9ZS5CZWJvcFZpZXcuZ2V0SW5zdGFuY2UoKTtyZXR1cm4gSS5zdGFydFJlYWRpbmcoQSksdGhpcy5yZWFkRnJvbShJKX0scmVhZEZyb20oQSl7bGV0IEk7cmV0dXJuIEk9QS5yZWFkQnl0ZSgpLHtzdHJlYW1JZDpJfX19LEkuUmVqZWN0U3RyZWFtUmVxdWVzdD17ZGlzY3JpbWluYXRvcjoxNCxlbmNvZGUoQSl7Y29uc3QgST1lLkJlYm9wVmlldy5nZXRJbnN0YW5jZSgpO3JldHVybiBJLnN0YXJ0V3JpdGluZygpLHRoaXMuZW5jb2RlSW50byhBLEkpLEkudG9BcnJheSgpfSxlbmNvZGVJbnRvKEEsSSl7Y29uc3QgZz1JLmxlbmd0aDtyZXR1cm4gSS53cml0ZVN0cmluZyhBLnJlYXNvbiksSS5sZW5ndGgtZ30sZGVjb2RlKEEpe2NvbnN0IEk9ZS5CZWJvcFZpZXcuZ2V0SW5zdGFuY2UoKTtyZXR1cm4gSS5zdGFydFJlYWRpbmcoQSksdGhpcy5yZWFkRnJvbShJKX0scmVhZEZyb20oQSl7bGV0IEk7cmV0dXJuIEk9QS5yZWFkU3RyaW5nKCkse3JlYXNvbjpJfX19LEkuSW5wdXRMZXZlbFVwZGF0ZT17ZGlzY3JpbWluYXRvcjoxNSxlbmNvZGUoQSl7Y29uc3QgST1lLkJlYm9wVmlldy5nZXRJbnN0YW5jZSgpO3JldHVybiBJLnN0YXJ0V3JpdGluZygpLHRoaXMuZW5jb2RlSW50byhBLEkpLEkudG9BcnJheSgpfSxlbmNvZGVJbnRvKEEsSSl7Y29uc3QgZz1JLmxlbmd0aDtyZXR1cm4gSS53cml0ZUJ5dGUoQS5zdHJlYW1JZCksSS53cml0ZVVpbnQzMihBLmlucHV0TGV2ZWwpLEkubGVuZ3RoLWd9LGRlY29kZShBKXtjb25zdCBJPWUuQmVib3BWaWV3LmdldEluc3RhbmNlKCk7cmV0dXJuIEkuc3RhcnRSZWFkaW5nKEEpLHRoaXMucmVhZEZyb20oSSl9LHJlYWRGcm9tKEEpe2xldCBJLGc7cmV0dXJuIEk9QS5yZWFkQnl0ZSgpLGc9QS5yZWFkVWludDMyKCkse3N0cmVhbUlkOkksaW5wdXRMZXZlbDpnfX19LEkuSW5wdXRMZXZlbFJlcXVlc3Q9e2Rpc2NyaW1pbmF0b3I6MTYsZW5jb2RlKEEpe2NvbnN0IEk9ZS5CZWJvcFZpZXcuZ2V0SW5zdGFuY2UoKTtyZXR1cm4gSS5zdGFydFdyaXRpbmcoKSx0aGlzLmVuY29kZUludG8oQSxJKSxJLnRvQXJyYXkoKX0sZW5jb2RlSW50byhBLEkpe2NvbnN0IGc9SS5sZW5ndGg7cmV0dXJuIEkud3JpdGVCeXRlKEEuc3RyZWFtSWQpLEkud3JpdGVVaW50MzIoQS5pbnB1dExldmVsKSxJLmxlbmd0aC1nfSxkZWNvZGUoQSl7Y29uc3QgST1lLkJlYm9wVmlldy5nZXRJbnN0YW5jZSgpO3JldHVybiBJLnN0YXJ0UmVhZGluZyhBKSx0aGlzLnJlYWRGcm9tKEkpfSxyZWFkRnJvbShBKXtsZXQgSSxnO3JldHVybiBJPUEucmVhZEJ5dGUoKSxnPUEucmVhZFVpbnQzMigpLHtzdHJlYW1JZDpJLGlucHV0TGV2ZWw6Z319fSxJLkxvZ2ljQm9keT17ZW5jb2RlKEEpe2NvbnN0IEk9ZS5CZWJvcFZpZXcuZ2V0SW5zdGFuY2UoKTtyZXR1cm4gSS5zdGFydFdyaXRpbmcoKSx0aGlzLmVuY29kZUludG8oQSxJKSxJLnRvQXJyYXkoKX0sZW5jb2RlSW50byhBLGcpe2NvbnN0IGU9Zy5sZW5ndGgsQj1nLnJlc2VydmVNZXNzYWdlTGVuZ3RoKCksaT1nLmxlbmd0aCsxO3N3aXRjaChnLndyaXRlQnl0ZShBLmRpc2NyaW1pbmF0b3IpLEEuZGlzY3JpbWluYXRvcil7Y2FzZSAxOkkuRGV2aWNlSW5mby5lbmNvZGVJbnRvKEEudmFsdWUsZyk7YnJlYWs7Y2FzZSAyOkkuQ29kZWNQYWNrUmVxdWVzdC5lbmNvZGVJbnRvKEEudmFsdWUsZyk7YnJlYWs7Y2FzZSAzOkkuQ29kZWNQYWNrUmVzcG9uc2UuZW5jb2RlSW50byhBLnZhbHVlLGcpO2JyZWFrO2Nhc2UgNDpJLkNsaWVudENhcGFiaWxpdGllcy5lbmNvZGVJbnRvKEEudmFsdWUsZyk7YnJlYWs7Y2FzZSA1OkkuRXJyb3JSZXNwb25zZS5lbmNvZGVJbnRvKEEudmFsdWUsZyk7YnJlYWs7Y2FzZSA2OkkuU3RyZWFtUmVxdWVzdC5lbmNvZGVJbnRvKEEudmFsdWUsZyk7YnJlYWs7Y2FzZSA3OkkuU3RyZWFtU3RhcnRpbmcuZW5jb2RlSW50byhBLnZhbHVlLGcpO2JyZWFrO2Nhc2UgODpJLkxlYXZlU3RyZWFtLmVuY29kZUludG8oQS52YWx1ZSxnKTticmVhaztjYXNlIDk6SS5TdHJlYW1TdG9wcGluZy5lbmNvZGVJbnRvKEEudmFsdWUsZyk7YnJlYWs7Y2FzZSAxMDpJLktleWZyYW1lUmVxdWVzdC5lbmNvZGVJbnRvKEEudmFsdWUsZyk7YnJlYWs7Y2FzZSAxMTpJLlZpZGVvQml0cmF0ZVJlcXVlc3QuZW5jb2RlSW50byhBLnZhbHVlLGcpO2JyZWFrO2Nhc2UgMTI6SS5Kb2luU3RyZWFtLmVuY29kZUludG8oQS52YWx1ZSxnKTticmVhaztjYXNlIDEzOkkuUGF1c2VTdHJlYW0uZW5jb2RlSW50byhBLnZhbHVlLGcpO2JyZWFrO2Nhc2UgMTQ6SS5SZWplY3RTdHJlYW1SZXF1ZXN0LmVuY29kZUludG8oQS52YWx1ZSxnKTticmVhaztjYXNlIDE1OkkuSW5wdXRMZXZlbFVwZGF0ZS5lbmNvZGVJbnRvKEEudmFsdWUsZyk7YnJlYWs7Y2FzZSAxNjpJLklucHV0TGV2ZWxSZXF1ZXN0LmVuY29kZUludG8oQS52YWx1ZSxnKX1jb25zdCBRPWcubGVuZ3RoO3JldHVybiBnLmZpbGxNZXNzYWdlTGVuZ3RoKEIsUS1pKSxnLmxlbmd0aC1lfSxkZWNvZGUoQSl7Y29uc3QgST1lLkJlYm9wVmlldy5nZXRJbnN0YW5jZSgpO3JldHVybiBJLnN0YXJ0UmVhZGluZyhBKSx0aGlzLnJlYWRGcm9tKEkpfSxyZWFkRnJvbShBKXtjb25zdCBnPUEucmVhZE1lc3NhZ2VMZW5ndGgoKSxCPUEuaW5kZXgrMStnO3N3aXRjaChBLnJlYWRCeXRlKCkpe2Nhc2UgMTpyZXR1cm57ZGlzY3JpbWluYXRvcjoxLHZhbHVlOkkuRGV2aWNlSW5mby5yZWFkRnJvbShBKX07Y2FzZSAyOnJldHVybntkaXNjcmltaW5hdG9yOjIsdmFsdWU6SS5Db2RlY1BhY2tSZXF1ZXN0LnJlYWRGcm9tKEEpfTtjYXNlIDM6cmV0dXJue2Rpc2NyaW1pbmF0b3I6Myx2YWx1ZTpJLkNvZGVjUGFja1Jlc3BvbnNlLnJlYWRGcm9tKEEpfTtjYXNlIDQ6cmV0dXJue2Rpc2NyaW1pbmF0b3I6NCx2YWx1ZTpJLkNsaWVudENhcGFiaWxpdGllcy5yZWFkRnJvbShBKX07Y2FzZSA1OnJldHVybntkaXNjcmltaW5hdG9yOjUsdmFsdWU6SS5FcnJvclJlc3BvbnNlLnJlYWRGcm9tKEEpfTtjYXNlIDY6cmV0dXJue2Rpc2NyaW1pbmF0b3I6Nix2YWx1ZTpJLlN0cmVhbVJlcXVlc3QucmVhZEZyb20oQSl9O2Nhc2UgNzpyZXR1cm57ZGlzY3JpbWluYXRvcjo3LHZhbHVlOkkuU3RyZWFtU3RhcnRpbmcucmVhZEZyb20oQSl9O2Nhc2UgODpyZXR1cm57ZGlzY3JpbWluYXRvcjo4LHZhbHVlOkkuTGVhdmVTdHJlYW0ucmVhZEZyb20oQSl9O2Nhc2UgOTpyZXR1cm57ZGlzY3JpbWluYXRvcjo5LHZhbHVlOkkuU3RyZWFtU3RvcHBpbmcucmVhZEZyb20oQSl9O2Nhc2UgMTA6cmV0dXJue2Rpc2NyaW1pbmF0b3I6MTAsdmFsdWU6SS5LZXlmcmFtZVJlcXVlc3QucmVhZEZyb20oQSl9O2Nhc2UgMTE6cmV0dXJue2Rpc2NyaW1pbmF0b3I6MTEsdmFsdWU6SS5WaWRlb0JpdHJhdGVSZXF1ZXN0LnJlYWRGcm9tKEEpfTtjYXNlIDEyOnJldHVybntkaXNjcmltaW5hdG9yOjEyLHZhbHVlOkkuSm9pblN0cmVhbS5yZWFkRnJvbShBKX07Y2FzZSAxMzpyZXR1cm57ZGlzY3JpbWluYXRvcjoxMyx2YWx1ZTpJLlBhdXNlU3RyZWFtLnJlYWRGcm9tKEEpfTtjYXNlIDE0OnJldHVybntkaXNjcmltaW5hdG9yOjE0LHZhbHVlOkkuUmVqZWN0U3RyZWFtUmVxdWVzdC5yZWFkRnJvbShBKX07Y2FzZSAxNTpyZXR1cm57ZGlzY3JpbWluYXRvcjoxNSx2YWx1ZTpJLklucHV0TGV2ZWxVcGRhdGUucmVhZEZyb20oQSl9O2Nhc2UgMTY6cmV0dXJue2Rpc2NyaW1pbmF0b3I6MTYsdmFsdWU6SS5JbnB1dExldmVsUmVxdWVzdC5yZWFkRnJvbShBKX07ZGVmYXVsdDp0aHJvdyBBLmluZGV4PUIsbmV3IGUuQmVib3BSdW50aW1lRXJyb3IoXCJVbnJlY29nbml6ZWQgZGlzY3JpbWluYXRvciB3aGlsZSBkZWNvZGluZyBMb2dpY0JvZHlcIil9fX0sKGk9SS5WaWRlb0RhdGFUeXBlfHwoSS5WaWRlb0RhdGFUeXBlPXt9KSlbaS5NZXRhZGF0YT0wXT1cIk1ldGFkYXRhXCIsaVtpLkNsZWFuUG9pbnRGcmFtZT0xXT1cIkNsZWFuUG9pbnRGcmFtZVwiLGlbaS5GcmFtZURpZmY9Ml09XCJGcmFtZURpZmZcIiwoQj1JLkF1ZGlvRGF0YVR5cGV8fChJLkF1ZGlvRGF0YVR5cGU9e30pKVtCLk1ldGFkYXRhPTBdPVwiTWV0YWRhdGFcIixCW0IuRnJhbWU9MV09XCJGcmFtZVwiLEkuRGVza3RvcFJlY3Q9e2VuY29kZShBKXtjb25zdCBJPWUuQmVib3BWaWV3LmdldEluc3RhbmNlKCk7cmV0dXJuIEkuc3RhcnRXcml0aW5nKCksdGhpcy5lbmNvZGVJbnRvKEEsSSksSS50b0FycmF5KCl9LGVuY29kZUludG8oQSxJKXtjb25zdCBnPUkubGVuZ3RoO3JldHVybiBJLndyaXRlSW50MzIoQS5sZWZ0KSxJLndyaXRlSW50MzIoQS50b3ApLEkud3JpdGVVaW50MzIoQS53aWR0aCksSS53cml0ZVVpbnQzMihBLmhlaWdodCksSS5sZW5ndGgtZ30sZGVjb2RlKEEpe2NvbnN0IEk9ZS5CZWJvcFZpZXcuZ2V0SW5zdGFuY2UoKTtyZXR1cm4gSS5zdGFydFJlYWRpbmcoQSksdGhpcy5yZWFkRnJvbShJKX0scmVhZEZyb20oQSl7bGV0IEksZyxlLEI7cmV0dXJuIEk9QS5yZWFkSW50MzIoKSxnPUEucmVhZEludDMyKCksZT1BLnJlYWRVaW50MzIoKSxCPUEucmVhZFVpbnQzMigpLHtsZWZ0OkksdG9wOmcsd2lkdGg6ZSxoZWlnaHQ6Qn19fSxJLlZpZGVvRGF0YT17ZGlzY3JpbWluYXRvcjoxLGVuY29kZShBKXtjb25zdCBJPWUuQmVib3BWaWV3LmdldEluc3RhbmNlKCk7cmV0dXJuIEkuc3RhcnRXcml0aW5nKCksdGhpcy5lbmNvZGVJbnRvKEEsSSksSS50b0FycmF5KCl9LGVuY29kZUludG8oQSxnKXtjb25zdCBlPWcubGVuZ3RoO2cud3JpdGVCeXRlcyhBLmRhdGEpLGcud3JpdGVVaW50NjQoQS5zZWdtZW50VGltZSksZy53cml0ZVVpbnQzMihBLnR5cGUpLGcud3JpdGVCeXRlKEEuc3RyZWFtSWQpLEkuRGVza3RvcFJlY3QuZW5jb2RlSW50byhBLmRlc2t0b3BSZWN0LGcpO3tjb25zdCBlPUEubWFzay5sZW5ndGg7Zy53cml0ZVVpbnQzMihlKTtmb3IobGV0IEI9MDtCPGU7QisrKUkuRGVza3RvcFJlY3QuZW5jb2RlSW50byhBLm1hc2tbQl0sZyl9cmV0dXJuIGcubGVuZ3RoLWV9LGRlY29kZShBKXtjb25zdCBJPWUuQmVib3BWaWV3LmdldEluc3RhbmNlKCk7cmV0dXJuIEkuc3RhcnRSZWFkaW5nKEEpLHRoaXMucmVhZEZyb20oSSl9LHJlYWRGcm9tKEEpe2xldCBnLGUsQixpLFEsdDtnPUEucmVhZEJ5dGVzKCksZT1BLnJlYWRVaW50NjQoKSxCPUEucmVhZFVpbnQzMigpLGk9QS5yZWFkQnl0ZSgpLFE9SS5EZXNrdG9wUmVjdC5yZWFkRnJvbShBKTt7bGV0IGc9QS5yZWFkVWludDMyKCk7dD1uZXcgQXJyYXkoZyk7Zm9yKGxldCBlPTA7ZTxnO2UrKyl7bGV0IGc7Zz1JLkRlc2t0b3BSZWN0LnJlYWRGcm9tKEEpLHRbZV09Z319cmV0dXJue2RhdGE6ZyxzZWdtZW50VGltZTplLHR5cGU6QixzdHJlYW1JZDppLGRlc2t0b3BSZWN0OlEsbWFzazp0fX19LEkuUG9pbnRlckRhdGE9e2Rpc2NyaW1pbmF0b3I6MixlbmNvZGUoQSl7Y29uc3QgST1lLkJlYm9wVmlldy5nZXRJbnN0YW5jZSgpO3JldHVybiBJLnN0YXJ0V3JpdGluZygpLHRoaXMuZW5jb2RlSW50byhBLEkpLEkudG9BcnJheSgpfSxlbmNvZGVJbnRvKEEsSSl7Y29uc3QgZz1JLmxlbmd0aDtyZXR1cm4gSS53cml0ZUJ5dGVzKEEuZGF0YSksSS53cml0ZVVpbnQzMihBLm1vbml0b3JXaWR0aCksSS53cml0ZVVpbnQzMihBLm1vbml0b3JIZWlnaHQpLEkud3JpdGVVaW50MzIoQS5zaGFwZVdpZHRoKSxJLndyaXRlVWludDMyKEEuc2hhcGVIZWlnaHQpLEkud3JpdGVJbnQzMihBLnNwb3RYKSxJLndyaXRlSW50MzIoQS5zcG90WSksSS53cml0ZUJ5dGUoTnVtYmVyKEEudmlzaWJsZSkpLEkud3JpdGVJbnQzMihBLnBvc2l0aW9uWCksSS53cml0ZUludDMyKEEucG9zaXRpb25ZKSxJLndyaXRlQnl0ZShBLnN0cmVhbUlkKSxJLmxlbmd0aC1nfSxkZWNvZGUoQSl7Y29uc3QgST1lLkJlYm9wVmlldy5nZXRJbnN0YW5jZSgpO3JldHVybiBJLnN0YXJ0UmVhZGluZyhBKSx0aGlzLnJlYWRGcm9tKEkpfSxyZWFkRnJvbShBKXtsZXQgSSxnLGUsQixpLFEsdCxDLEUsbyxhO3JldHVybiBJPUEucmVhZEJ5dGVzKCksZz1BLnJlYWRVaW50MzIoKSxlPUEucmVhZFVpbnQzMigpLEI9QS5yZWFkVWludDMyKCksaT1BLnJlYWRVaW50MzIoKSxRPUEucmVhZEludDMyKCksdD1BLnJlYWRJbnQzMigpLEM9ISFBLnJlYWRCeXRlKCksRT1BLnJlYWRJbnQzMigpLG89QS5yZWFkSW50MzIoKSxhPUEucmVhZEJ5dGUoKSx7ZGF0YTpJLG1vbml0b3JXaWR0aDpnLG1vbml0b3JIZWlnaHQ6ZSxzaGFwZVdpZHRoOkIsc2hhcGVIZWlnaHQ6aSxzcG90WDpRLHNwb3RZOnQsdmlzaWJsZTpDLHBvc2l0aW9uWDpFLHBvc2l0aW9uWTpvLHN0cmVhbUlkOmF9fX0sSS5BdWRpb0RhdGE9e2Rpc2NyaW1pbmF0b3I6MyxlbmNvZGUoQSl7Y29uc3QgST1lLkJlYm9wVmlldy5nZXRJbnN0YW5jZSgpO3JldHVybiBJLnN0YXJ0V3JpdGluZygpLHRoaXMuZW5jb2RlSW50byhBLEkpLEkudG9BcnJheSgpfSxlbmNvZGVJbnRvKEEsSSl7Y29uc3QgZz1JLmxlbmd0aDtyZXR1cm4gSS53cml0ZUJ5dGVzKEEuZGF0YSksSS53cml0ZVVpbnQzMihBLnR5cGUpLEkud3JpdGVCeXRlKEEuc3RyZWFtSWQpLEkubGVuZ3RoLWd9LGRlY29kZShBKXtjb25zdCBJPWUuQmVib3BWaWV3LmdldEluc3RhbmNlKCk7cmV0dXJuIEkuc3RhcnRSZWFkaW5nKEEpLHRoaXMucmVhZEZyb20oSSl9LHJlYWRGcm9tKEEpe2xldCBJLGcsZTtyZXR1cm4gST1BLnJlYWRCeXRlcygpLGc9QS5yZWFkVWludDMyKCksZT1BLnJlYWRCeXRlKCkse2RhdGE6SSx0eXBlOmcsc3RyZWFtSWQ6ZX19fSxJLk1lZGlhQ2h1bms9e2Rpc2NyaW1pbmF0b3I6NCxlbmNvZGUoQSl7Y29uc3QgST1lLkJlYm9wVmlldy5nZXRJbnN0YW5jZSgpO3JldHVybiBJLnN0YXJ0V3JpdGluZygpLHRoaXMuZW5jb2RlSW50byhBLEkpLEkudG9BcnJheSgpfSxlbmNvZGVJbnRvKEEsZyl7Y29uc3QgZT1nLmxlbmd0aDtyZXR1cm4gSS5DaHVuay5lbmNvZGVJbnRvKEEuY2h1bmssZyksZy5sZW5ndGgtZX0sZGVjb2RlKEEpe2NvbnN0IEk9ZS5CZWJvcFZpZXcuZ2V0SW5zdGFuY2UoKTtyZXR1cm4gSS5zdGFydFJlYWRpbmcoQSksdGhpcy5yZWFkRnJvbShJKX0scmVhZEZyb20oQSl7bGV0IGc7cmV0dXJuIGc9SS5DaHVuay5yZWFkRnJvbShBKSx7Y2h1bms6Z319fSxJLk1lZGlhQm9keT17ZW5jb2RlKEEpe2NvbnN0IEk9ZS5CZWJvcFZpZXcuZ2V0SW5zdGFuY2UoKTtyZXR1cm4gSS5zdGFydFdyaXRpbmcoKSx0aGlzLmVuY29kZUludG8oQSxJKSxJLnRvQXJyYXkoKX0sZW5jb2RlSW50byhBLGcpe2NvbnN0IGU9Zy5sZW5ndGgsQj1nLnJlc2VydmVNZXNzYWdlTGVuZ3RoKCksaT1nLmxlbmd0aCsxO3N3aXRjaChnLndyaXRlQnl0ZShBLmRpc2NyaW1pbmF0b3IpLEEuZGlzY3JpbWluYXRvcil7Y2FzZSAxOkkuVmlkZW9EYXRhLmVuY29kZUludG8oQS52YWx1ZSxnKTticmVhaztjYXNlIDI6SS5Qb2ludGVyRGF0YS5lbmNvZGVJbnRvKEEudmFsdWUsZyk7YnJlYWs7Y2FzZSAzOkkuQXVkaW9EYXRhLmVuY29kZUludG8oQS52YWx1ZSxnKTticmVhaztjYXNlIDQ6SS5NZWRpYUNodW5rLmVuY29kZUludG8oQS52YWx1ZSxnKX1jb25zdCBRPWcubGVuZ3RoO3JldHVybiBnLmZpbGxNZXNzYWdlTGVuZ3RoKEIsUS1pKSxnLmxlbmd0aC1lfSxkZWNvZGUoQSl7Y29uc3QgST1lLkJlYm9wVmlldy5nZXRJbnN0YW5jZSgpO3JldHVybiBJLnN0YXJ0UmVhZGluZyhBKSx0aGlzLnJlYWRGcm9tKEkpfSxyZWFkRnJvbShBKXtjb25zdCBnPUEucmVhZE1lc3NhZ2VMZW5ndGgoKSxCPUEuaW5kZXgrMStnO3N3aXRjaChBLnJlYWRCeXRlKCkpe2Nhc2UgMTpyZXR1cm57ZGlzY3JpbWluYXRvcjoxLHZhbHVlOkkuVmlkZW9EYXRhLnJlYWRGcm9tKEEpfTtjYXNlIDI6cmV0dXJue2Rpc2NyaW1pbmF0b3I6Mix2YWx1ZTpJLlBvaW50ZXJEYXRhLnJlYWRGcm9tKEEpfTtjYXNlIDM6cmV0dXJue2Rpc2NyaW1pbmF0b3I6Myx2YWx1ZTpJLkF1ZGlvRGF0YS5yZWFkRnJvbShBKX07Y2FzZSA0OnJldHVybntkaXNjcmltaW5hdG9yOjQsdmFsdWU6SS5NZWRpYUNodW5rLnJlYWRGcm9tKEEpfTtkZWZhdWx0OnRocm93IEEuaW5kZXg9QixuZXcgZS5CZWJvcFJ1bnRpbWVFcnJvcihcIlVucmVjb2duaXplZCBkaXNjcmltaW5hdG9yIHdoaWxlIGRlY29kaW5nIE1lZGlhQm9keVwiKX19fX0sMTQ6ZnVuY3Rpb24oQSxJLGcpe1widXNlIHN0cmljdFwiO3ZhciBlPXRoaXMmJnRoaXMuX19jcmVhdGVCaW5kaW5nfHwoT2JqZWN0LmNyZWF0ZT9mdW5jdGlvbihBLEksZyxlKXt2b2lkIDA9PT1lJiYoZT1nKSxPYmplY3QuZGVmaW5lUHJvcGVydHkoQSxlLHtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiBJW2ddfX0pfTpmdW5jdGlvbihBLEksZyxlKXt2b2lkIDA9PT1lJiYoZT1nKSxBW2VdPUlbZ119KSxCPXRoaXMmJnRoaXMuX19leHBvcnRTdGFyfHxmdW5jdGlvbihBLEkpe2Zvcih2YXIgZyBpbiBBKVwiZGVmYXVsdFwiPT09Z3x8T2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKEksZyl8fGUoSSxBLGcpfTtPYmplY3QuZGVmaW5lUHJvcGVydHkoSSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxJLlJhaW53YXlFcnJvcj1JLlJhaW53YXlTdHJlYW09SS5SYWlud2F5UnVudGltZT1JLlJhaW53YXlUcmFuc3BvcnRTdGF0dXM9SS5SYWlud2F5VHJhbnNwb3J0PUkuUlRDVHJhbnNwb3J0PUkuZnJpZW5kbHlHYW1lcGFkTmFtZT1JLlJhaW53YXlMb2dMZXZlbD1JLlJhaW53YXlMb2dnaW5nPUkuUGVlclN0YXRlPUkuUmFpbndheUNoYW5uZWxNb2RlPUkuUmFpbndheVBlZXI9SS5SYWlud2F5UGVlclN0YXRlPXZvaWQgMDt2YXIgaT1nKDc4Myk7T2JqZWN0LmRlZmluZVByb3BlcnR5KEksXCJSYWlud2F5UGVlclN0YXRlXCIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGkuUmFpbndheVBlZXJTdGF0ZX19KTt2YXIgUT1nKDQyMCk7T2JqZWN0LmRlZmluZVByb3BlcnR5KEksXCJSYWlud2F5UGVlclwiLHtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiBRLlJhaW53YXlQZWVyfX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShJLFwiUmFpbndheUNoYW5uZWxNb2RlXCIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIFEuUmFpbndheUNoYW5uZWxNb2RlfX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShJLFwiUGVlclN0YXRlXCIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIFEuUGVlclN0YXRlfX0pO3ZhciB0PWcoNDY0KTtPYmplY3QuZGVmaW5lUHJvcGVydHkoSSxcIlJhaW53YXlMb2dnaW5nXCIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHQuUmFpbndheUxvZ2dpbmd9fSksT2JqZWN0LmRlZmluZVByb3BlcnR5KEksXCJSYWlud2F5TG9nTGV2ZWxcIix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdC5SYWlud2F5TG9nTGV2ZWx9fSk7dmFyIEM9Zyg5OSk7T2JqZWN0LmRlZmluZVByb3BlcnR5KEksXCJmcmllbmRseUdhbWVwYWROYW1lXCIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIEMuZnJpZW5kbHlHYW1lcGFkTmFtZX19KTt2YXIgRT1nKDE0NSk7T2JqZWN0LmRlZmluZVByb3BlcnR5KEksXCJSVENUcmFuc3BvcnRcIix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gRS5SVENUcmFuc3BvcnR9fSk7dmFyIG89Zyg5KTtPYmplY3QuZGVmaW5lUHJvcGVydHkoSSxcIlJhaW53YXlUcmFuc3BvcnRcIix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gby5SYWlud2F5VHJhbnNwb3J0fX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShJLFwiUmFpbndheVRyYW5zcG9ydFN0YXR1c1wiLHtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiBvLlJhaW53YXlUcmFuc3BvcnRTdGF0dXN9fSk7dmFyIGE9Zyg3ODMpO09iamVjdC5kZWZpbmVQcm9wZXJ0eShJLFwiUmFpbndheVJ1bnRpbWVcIix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gYS5SYWlud2F5UnVudGltZX19KTt2YXIgbj1nKDg3Nik7T2JqZWN0LmRlZmluZVByb3BlcnR5KEksXCJSYWlud2F5U3RyZWFtXCIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIG4uUmFpbndheVN0cmVhbX19KTt2YXIgcz1nKDk5NCk7T2JqZWN0LmRlZmluZVByb3BlcnR5KEksXCJSYWlud2F5RXJyb3JcIix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gcy5SYWlud2F5RXJyb3J9fSksQihnKDkwNCksSSl9LDY1OihBLEkpPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KEksXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksSS5SYWlud2F5Q3Vyc29yUGFpbnRlcj12b2lkIDAsSS5SYWlud2F5Q3Vyc29yUGFpbnRlcj1jbGFzc3tjb25zdHJ1Y3RvcihBLEksZyxlPTEwMCl7dGhpcy5jb3JyZWN0UmVtb3RlQ3Vyc29yPUEsdGhpcy50cmFuc2Zvcm1Qb2ludGVyT2Zmc2V0VG9SZW1vdGU9SSx0aGlzLmdldEN1cnJlbnRGcmFtZVNpemU9Zyx0aGlzLmN1cnNvclN5bmNJbnRlcnZhbD1lLHRoaXMuY29udGFpbmVyPXZvaWQgMCx0aGlzLnZpZGVvPXZvaWQgMCx0aGlzLmNhbnZhcz12b2lkIDAsdGhpcy5jdXJzb3JEaXY9dm9pZCAwLHRoaXMuY3Vyc29ySW1nPXZvaWQgMCx0aGlzLmN1cnNvclN0YXRlPXt2aXNpYmxlOiExLHg6MCx5OjAsc3BvdFg6MCxzcG90WTowLGV4dGVudFdpZHRoOjAsZXh0ZW50SGVpZ2h0OjB9LHRoaXMud2FudHNSZW1vdGVQb3NpdGlvbj0hMCx0aGlzLnZpZGVvUmVjdD1uZXcgRE9NUmVjdCgwLDAsMCwwKSx0aGlzLndpbmRvd1dpZHRoPXZvaWQgMCx0aGlzLndpbmRvd0hlaWdodD12b2lkIDAsdGhpcy5kcmF3RGVidWdEb3Q9ITEsdGhpcy5kZWJ1Z0RvdD12b2lkIDAsdGhpcy5zZXRWaWRlb0RpbWVuc2lvbnM9KCk9Pntmb3IoY29uc3QgQSBvZlt0aGlzLnZpZGVvLHRoaXMuY2FudmFzXSl7aWYoIUEpY29udGludWU7Y29uc3QgST1BLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO2lmKEkud2lkdGg+MCYmSS5oZWlnaHQ+MClyZXR1cm4gdGhpcy52aWRlb1JlY3Q9SSx2b2lkIHRoaXMuYXBwbHlDdXJzb3JEaXZUcmFuc2Zvcm0oKX19LHRoaXMuY3Vyc29yU3luY0NvdW50ZXI9dGhpcy5jdXJzb3JTeW5jSW50ZXJ2YWwsdGhpcy52aWRlb1Jlc2l6ZU9ic2VydmVyPW5ldyBSZXNpemVPYnNlcnZlcigoKCk9Pnt0aGlzLnNldFZpZGVvRGltZW5zaW9ucygpfSkpLFtcIndlYmtpdGZ1bGxzY3JlZW5jaGFuZ2VcIixcIm1vemZ1bGxzY3JlZW5jaGFuZ2VcIixcImZ1bGxzY3JlZW5jaGFuZ2VcIixcIk1TRnVsbHNjcmVlbkNoYW5nZVwiXS5mb3JFYWNoKChBPT57ZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihBLHRoaXMuc2V0VmlkZW9EaW1lbnNpb25zLCExKX0pKSx3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLHRoaXMuc2V0V2luZG93RGltZW5zaW9ucyl9ZGV0YWNoKCl7W1wid2Via2l0ZnVsbHNjcmVlbmNoYW5nZVwiLFwibW96ZnVsbHNjcmVlbmNoYW5nZVwiLFwiZnVsbHNjcmVlbmNoYW5nZVwiLFwiTVNGdWxsc2NyZWVuQ2hhbmdlXCJdLmZvckVhY2goKEE9Pntkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKEEsdGhpcy5zZXRWaWRlb0RpbWVuc2lvbnMsITEpfSkpLHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwicmVzaXplXCIsdGhpcy5zZXRXaW5kb3dEaW1lbnNpb25zKSx0aGlzLnZpZGVvUmVzaXplT2JzZXJ2ZXIuZGlzY29ubmVjdCgpfXNldFdpbmRvd0RpbWVuc2lvbnMoKXt0aGlzLndpbmRvd1dpZHRoPXdpbmRvdy5pbm5lcldpZHRoLHRoaXMud2luZG93SGVpZ2h0PXdpbmRvdy5pbm5lckhlaWdodH1zZXRDb250YWluZXIoQSl7dGhpcy5jb250YWluZXI9QSxBLnN0eWxlLm92ZXJmbG93PVwiaGlkZGVuXCIsdGhpcy52aWRlbyYmdGhpcy52aWRlb1Jlc2l6ZU9ic2VydmVyLnVub2JzZXJ2ZSh0aGlzLnZpZGVvKSx0aGlzLmNhbnZhcyYmdGhpcy52aWRlb1Jlc2l6ZU9ic2VydmVyLnVub2JzZXJ2ZSh0aGlzLmNhbnZhcyksdGhpcy5jdXJzb3JEaXY9dm9pZCAwO2NvbnN0IEk9QS5jaGlsZE5vZGVzO2ZvcihsZXQgQT0wO0E8SS5sZW5ndGg7QSsrKXtjb25zdCBnPUlbQV07ZyBpbnN0YW5jZW9mIEhUTUxWaWRlb0VsZW1lbnQ/KHRoaXMudmlkZW89Zyx0aGlzLnNldFZpZGVvRGltZW5zaW9ucygpLHRoaXMudmlkZW9SZXNpemVPYnNlcnZlci5vYnNlcnZlKHRoaXMudmlkZW8pKTpnIGluc3RhbmNlb2YgSFRNTENhbnZhc0VsZW1lbnQmJihnLmNsYXNzTGlzdC5jb250YWlucyhcInJhaW53YXktY2FudmFzXCIpfHxnLmNsYXNzTGlzdC5jb250YWlucyhcInJhaW53YXktaXNvbGF0aW9uLWNhbnZhc1wiKSk/KHRoaXMuY2FudmFzPWcsdGhpcy5zZXRWaWRlb0RpbWVuc2lvbnMoKSx0aGlzLnZpZGVvUmVzaXplT2JzZXJ2ZXIub2JzZXJ2ZSh0aGlzLmNhbnZhcykpOmcgaW5zdGFuY2VvZiBIVE1MRGl2RWxlbWVudCYmKGcuY2xhc3NOYW1lLmluY2x1ZGVzKFwicmFpbndheS1jdXJzb3JcIik/dGhpcy5jdXJzb3JEaXY9ZzpnLmNsYXNzTmFtZS5pbmNsdWRlcyhcInJhaW53YXktZGVidWctZG90XCIpJiYodGhpcy5kZWJ1Z0RvdD1nKSl9dGhpcy5jdXJzb3JEaXZ8fCh0aGlzLmN1cnNvckRpdj1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpLHRoaXMuY3Vyc29yRGl2LmNsYXNzTmFtZT1cInJhaW53YXktY3Vyc29yXCIsdGhpcy5jdXJzb3JEaXYuc3R5bGUucG9zaXRpb249XCJhYnNvbHV0ZVwiLHRoaXMuY3Vyc29yRGl2LnN0eWxlLnRvcD1cIjBweFwiLHRoaXMuY3Vyc29yRGl2LnN0eWxlLmxlZnQ9XCIwcHhcIix0aGlzLmN1cnNvckRpdi5zdHlsZS56SW5kZXg9XCIxXCIsdGhpcy5jdXJzb3JEaXYuc3R5bGUucG9pbnRlckV2ZW50cz1cIm5vbmVcIix0aGlzLmN1cnNvckRpdi5zdHlsZS53aWxsQ2hhbmdlPVwidHJhbnNmb3JtXCIsdGhpcy5jdXJzb3JEaXYuc3R5bGUudHJhbnNmb3JtT3JpZ2luPVwidG9wIGxlZnRcIix0aGlzLmFwcGx5Q3Vyc29yRGl2VHJhbnNmb3JtKCksdGhpcy5jdXJzb3JJbWc9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImltZ1wiKSx0aGlzLmN1cnNvckRpdi5hcHBlbmRDaGlsZCh0aGlzLmN1cnNvckltZyksQS5hcHBlbmRDaGlsZCh0aGlzLmN1cnNvckRpdikpLHRoaXMuZHJhd0RlYnVnRG90JiYhdGhpcy5kZWJ1Z0RvdCYmKHRoaXMuZGVidWdEb3Q9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSx0aGlzLmRlYnVnRG90LmNsYXNzTmFtZT1cInJhaW53YXktZGVidWctZG90XCIsdGhpcy5kZWJ1Z0RvdC5zdHlsZS5wb3NpdGlvbj1cImFic29sdXRlXCIsdGhpcy5kZWJ1Z0RvdC5zdHlsZS50b3A9XCIwcHhcIix0aGlzLmRlYnVnRG90LnN0eWxlLmxlZnQ9XCIwcHhcIix0aGlzLmRlYnVnRG90LnN0eWxlLnpJbmRleD1cIjFcIix0aGlzLmRlYnVnRG90LnN0eWxlLnBvaW50ZXJFdmVudHM9XCJub25lXCIsdGhpcy5kZWJ1Z0RvdC5zdHlsZS53aWxsQ2hhbmdlPVwidHJhbnNmb3JtXCIsdGhpcy5kZWJ1Z0RvdC5zdHlsZS50cmFuc2Zvcm1PcmlnaW49XCJ0b3AgbGVmdFwiLHRoaXMuZGVidWdEb3Quc3R5bGUud2lkdGg9XCIzcHhcIix0aGlzLmRlYnVnRG90LnN0eWxlLmhlaWdodD1cIjNweFwiLHRoaXMuZGVidWdEb3Quc3R5bGUuYmFja2dyb3VuZENvbG9yPVwiI2ZmMDAwMFwiLEEuYXBwZW5kQ2hpbGQodGhpcy5kZWJ1Z0RvdCkpfXVuc2V0Q29udGFpbmVyKCl7dmFyIEEsSTt0aGlzLmRldGFjaCgpLG51bGw9PT0oQT10aGlzLmN1cnNvckRpdil8fHZvaWQgMD09PUF8fEEucmVtb3ZlKCksbnVsbD09PShJPXRoaXMuZGVidWdEb3QpfHx2b2lkIDA9PT1JfHxJLnJlbW92ZSgpLHRoaXMuY29udGFpbmVyPXZvaWQgMH1jb21wdXRlVHJhbnNmb3JtKEEpe3ZhciBJLGc7Y29uc3R7eDplLHk6QixzcG90WDppLHNwb3RZOlF9PUEsdD17bGVmdDowLHRvcDowLHdpZHRoOkEuZXh0ZW50V2lkdGgsaGVpZ2h0OkEuZXh0ZW50SGVpZ2h0fSx7d2lkdGg6QyxoZWlnaHQ6RX09dGhpcy52aWRlb1JlY3Qsbz10aGlzLmdldEN1cnJlbnRGcmFtZVNpemUoKSxhPW8uY29kZWNXaWR0aCxuPW8uY29kZWNIZWlnaHQscz1udWxsIT09KEk9by5zdHJlYW1Cb3VuZHMpJiZ2b2lkIDAhPT1JP0k6dCxyPW51bGwhPT0oZz1vLmZ1bGxEZXNrdG9wQm91bmRzKSYmdm9pZCAwIT09Zz9nOnQse2xlZnQ6ZCx0b3A6aCx3aWR0aDpjLGhlaWdodDpEfT1yLHtsZWZ0OncsdG9wOnksd2lkdGg6dSxoZWlnaHQ6bH09cyxTPXUqYS9jLEY9bCpuL0QsUj1NYXRoLm1pbihDL1MsRS9GKSxHPU1hdGgucm91bmQoZS1pLSh3LWQpKSxrPU1hdGgucm91bmQoQi1RLSh5LWgpKSxVPVIqYS9jLE49UipuL0Q7cmV0dXJuYHRyYW5zbGF0ZSgke01hdGgucm91bmQoKEMtUipTKS8yKX1weCwke01hdGgucm91bmQoKEUtUipGKS8yKX1weCkgc2NhbGUoJHtVfSwke059KSB0cmFuc2xhdGUoJHtHfXB4LCR7a31weClgfWFwcGx5Q3Vyc29yRGl2VHJhbnNmb3JtKCl7dGhpcy5jdXJzb3JEaXYmJih0aGlzLmN1cnNvclN0YXRlLnZpc2libGU/KHRoaXMuY3Vyc29yRGl2LnN0eWxlLnZpc2liaWxpdHk9XCJ2aXNpYmxlXCIsdGhpcy5jdXJzb3JEaXYuc3R5bGUudHJhbnNmb3JtPXRoaXMuY29tcHV0ZVRyYW5zZm9ybSh0aGlzLmN1cnNvclN0YXRlKSk6dGhpcy5jdXJzb3JEaXYuc3R5bGUudmlzaWJpbGl0eT1cImhpZGRlblwiKX1tb3ZlRGVidWdEb3RUbyhBKXt0aGlzLmRlYnVnRG90JiYodGhpcy5kZWJ1Z0RvdC5zdHlsZS50cmFuc2Zvcm09dGhpcy5jb21wdXRlVHJhbnNmb3JtKEEpKX1wcm9jZXNzQ3Vyc29yKEEpe2lmKHRoaXMuY3Vyc29yRGl2KWlmKEEudmlzaWJsZSYmIXRoaXMuY3Vyc29yU3RhdGUudmlzaWJsZSYmKHRoaXMud2FudHNSZW1vdGVQb3NpdGlvbj0hMCksdGhpcy5jdXJzb3JTdGF0ZS52aXNpYmxlPUEudmlzaWJsZSx0aGlzLmN1cnNvclN0YXRlLnNwb3RYPUEuc3BvdFgsdGhpcy5jdXJzb3JTdGF0ZS5zcG90WT1BLnNwb3RZLHRoaXMuY3Vyc29yU3RhdGUuZXh0ZW50V2lkdGg9QS5leHRlbnRXaWR0aCx0aGlzLmN1cnNvclN0YXRlLmV4dGVudEhlaWdodD1BLmV4dGVudEhlaWdodCx0aGlzLmRyYXdEZWJ1Z0RvdCYmdGhpcy5tb3ZlRGVidWdEb3RUbyhBKSx0aGlzLmN1cnNvclN0YXRlLnZpc2libGUpe2lmKHRoaXMud2FudHNSZW1vdGVQb3NpdGlvbj8odGhpcy5jdXJzb3JTdGF0ZS54PUEueCx0aGlzLmN1cnNvclN0YXRlLnk9QS55LHRoaXMud2FudHNSZW1vdGVQb3NpdGlvbj0hMSx0aGlzLmN1cnNvclN5bmNDb3VudGVyPXRoaXMuY3Vyc29yU3luY0ludGVydmFsKTowPT0tLXRoaXMuY3Vyc29yU3luY0NvdW50ZXImJih0aGlzLmNvcnJlY3RSZW1vdGVDdXJzb3IodGhpcy5jdXJzb3JTdGF0ZS54LHRoaXMuY3Vyc29yU3RhdGUueSksdGhpcy5jdXJzb3JTeW5jQ291bnRlcj10aGlzLmN1cnNvclN5bmNJbnRlcnZhbCksdGhpcy5jdXJzb3JEaXYuc3R5bGUud2lkdGg9YCR7QS5zaGFwZVdpZHRofXB4YCx0aGlzLmN1cnNvckRpdi5zdHlsZS5oZWlnaHQ9YCR7QS5zaGFwZUhlaWdodH1weGAsQS5oYXNQb2ludGVySW1hZ2UmJnRoaXMuY3Vyc29ySW1nKXtjb25zdCBJPWZ1bmN0aW9uKEEpe2xldCBJPVwiXCI7Y29uc3QgZz1uZXcgVWludDhBcnJheShBKSxlPWcuYnl0ZUxlbmd0aDtmb3IobGV0IEE9MDtBPGU7QSsrKUkrPVN0cmluZy5mcm9tQ2hhckNvZGUoZ1tBXSk7cmV0dXJuIHdpbmRvdy5idG9hKEkpfShBLnBvaW50ZXJJbWFnZSk7dGhpcy5jdXJzb3JJbWcuc3JjPWBkYXRhOmltYWdlL3BuZztiYXNlNjQsJHtJfWB9dGhpcy5hcHBseUN1cnNvckRpdlRyYW5zZm9ybSgpfWVsc2UgdGhpcy5jdXJzb3JEaXYuc3R5bGUudmlzaWJpbGl0eT1cImhpZGRlblwifXVwZGF0ZShBLEksZyl7aWYodGhpcy5jdXJzb3JEaXYmJihcInBvaW50ZXJtb3ZlXCI9PT1BLnR5cGV8fFwibW91c2Vtb3ZlXCI9PT1BLnR5cGUpKXtpZihcIm1vdXNlXCIhPT1BLnBvaW50ZXJUeXBlKXtjb25zdCBBPXRoaXMudHJhbnNmb3JtUG9pbnRlck9mZnNldFRvUmVtb3RlKEksZyk7QSYmKHRoaXMuY3Vyc29yU3RhdGUueD1BLngsdGhpcy5jdXJzb3JTdGF0ZS55PUEueSl9ZWxzZXtjb25zdCBJPXRoaXMuY3Vyc29yU3RhdGUsZz1BLm1vdmVtZW50WCxlPUEubW92ZW1lbnRZLEI9dGhpcy5nZXRDdXJyZW50RnJhbWVTaXplKCk7aWYoQi5zdHJlYW1Cb3VuZHMpe2NvbnN0e3RvcDpBLGxlZnQ6aSxoZWlnaHQ6USx3aWR0aDp0fT1CLnN0cmVhbUJvdW5kczt0aGlzLmN1cnNvclN0YXRlLng9TWF0aC5tYXgoaSxNYXRoLm1pbihJLngrZyxpK3QpKSx0aGlzLmN1cnNvclN0YXRlLnk9TWF0aC5tYXgoQSxNYXRoLm1pbihJLnkrZSxBK1EpKX1lbHNlIGNvbnNvbGUud2FybihcIkRvbid0IGhhdmUgc3RyZWFtQm91bmRzIGluIEN1cnNvclBhaW50ZXIudXBkYXRlP1wiKSx0aGlzLmN1cnNvclN0YXRlLng9TWF0aC5tYXgoMCxNYXRoLm1pbihJLngrZyxJLmV4dGVudFdpZHRoKSksdGhpcy5jdXJzb3JTdGF0ZS55PU1hdGgubWF4KDAsTWF0aC5taW4oSS55K2UsSS5leHRlbnRIZWlnaHQpKX10aGlzLmFwcGx5Q3Vyc29yRGl2VHJhbnNmb3JtKCl9fX19LDk5OihBLEkpPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KEksXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksSS5mcmllbmRseUdhbWVwYWROYW1lPXZvaWQgMDtjb25zdCBnPXtcIjA1NGNcIjp7XCIwMjY4XCI6XCJEdWFsU2hvY2sgM1wiLFwiMDVjNFwiOlwiRHVhbFNob2NrIDRcIixcIjA5Y2NcIjpcIkR1YWxTaG9jayA0ICgybmQgR2VuKVwifSxcIjJkYzhcIjp7NjEwMTpcIk4zMCBQcm9cIn0sXCIwOTU1XCI6e2I0MDA6XCJOVklESUEgU2hpZWxkXCJ9LDI1NjM6e1wiMDUyM1wiOlwiU2hhbldhbiBQUzMgQ29udHJvbGxlclwifSxcIjA0NWVcIjp7XCIwMmQxXCI6XCJYYm94IE9uZSBDb250cm9sbGVyXCIsXCIwMmRkXCI6XCJYYm94IE9uZSBDb250cm9sbGVyIChGaXJtd2FyZSAyMDE1KVwiLFwiMDJlM1wiOlwiWGJveCBPbmUgRWxpdGUgQ29udHJvbGxlclwiLFwiMDJlYVwiOlwiWGJveCBPbmUgUyBDb250cm9sbGVyXCIsXCIwMmZkXCI6XCJYYm94IE9uZSBTIENvbnRyb2xsZXIgKEJsdWV0b290aClcIixcIjAyOGZcIjpcIlhib3gzNjAgV2lyZWxlc3MgQ29udHJvbGxlclwiLFwiMDI4ZVwiOlwiWGJveDM2MCBDb250cm9sbGVyXCIsXCIwMjg5XCI6XCJYYm94IENvbnRyb2xsZXIgU1wiLFwiMDI4NVwiOlwiWGJveCBDb250cm9sbGVyIFNcIixcIjAyMDJcIjpcIlhib3ggQ29udHJvbGxlclwifSxcIjA0NmRcIjp7YzI5OTpcIkcyNSBSYWNpbmcgV2hlZWxcIixjMjlCOlwiRzI3IFJhY2luZyBXaGVlbFwiLGNhYTM6XCJEcml2ZUZYIFJhY2luZyBXaGVlbFwiLGMyOTU6XCJNb21vIEZvcmNlIFN0ZWVyaW5nIFdoZWVsXCIsYzI5ODpcIkRyaXZpbmcgRm9yY2UgUHJvXCJ9fTtJLmZyaWVuZGx5R2FtZXBhZE5hbWU9ZnVuY3Rpb24oQSxJKXt2YXIgZSxCLGksUTtjb25zdCB0PUEuaWQuc3BsaXQoXCIoXCIpWzBdLnRyaW0oKXx8XCJVbmtub3duIGdhbWVwYWRcIixDPUEuaWQubWF0Y2goL1xcYihbMC05YS1mXXs0fSlcXGIuKlxcYihbMC05YS1mXXs0fSlcXGIvKTtpZighQylyZXR1cm4gdDtjb25zdCBFPUNbMV0sbz1DWzJdO3JldHVybiBudWxsIT09KFE9bnVsbCE9PShCPW51bGw9PT0oZT1udWxsPT1JP3ZvaWQgMDpJW0VdKXx8dm9pZCAwPT09ZT92b2lkIDA6ZVtvXSkmJnZvaWQgMCE9PUI/QjpudWxsPT09KGk9Z1tFXSl8fHZvaWQgMD09PWk/dm9pZCAwOmlbb10pJiZ2b2lkIDAhPT1RP1E6dH19LDMyMjooQSxJKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eShJLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLEkuUmFpbndheUdlc3R1cmVSZWNvZ25pemVyPXZvaWQgMDtjb25zdCBnPXtjbGlja0R1cmF0aW9uTXM6NjAsZHJhZ0RlbGF5TXM6MzAwLHJpZ2h0Q2xpY2tEZWxheU1zOjUwMCx0b3VjaFNsb3BSYWRpdXM6OCxkb3VibGVUYXBXaW5kb3dNczo0MDAsZG91YmxlVGFwUmFkaXVzOjEyLHNjcm9sbEdlc3R1cmVUaHJlc2hvbGRQaXhlbHM6MjAsc2Nyb2xsRXBzaWxvblBpeGVsczo1LHNjcm9sbFNlbnNpdGl2aXR5OjR9O3ZhciBlLEIsaTtmdW5jdGlvbiBRKEEpe3JldHVybiBBPT1CLmxlZnQ/MTpBPT1CLm1pZGRsZT80OkE9PUIucmlnaHQ/MjowfSFmdW5jdGlvbihBKXtBW0EuaWRsZT0wXT1cImlkbGVcIixBW0Eub25lRmluZ2VyRGVjaWRpbmc9MV09XCJvbmVGaW5nZXJEZWNpZGluZ1wiLEFbQS50d29GaW5nZXJzRGVjaWRpbmc9Ml09XCJ0d29GaW5nZXJzRGVjaWRpbmdcIixBW0EubW92aW5nPTNdPVwibW92aW5nXCIsQVtBLmRyYWdnaW5nPTRdPVwiZHJhZ2dpbmdcIixBW0EuaG9sZGluZ1JpZ2h0TW91c2VCdXR0b249NV09XCJob2xkaW5nUmlnaHRNb3VzZUJ1dHRvblwiLEFbQS56b29taW5nPTZdPVwiem9vbWluZ1wiLEFbQS5zY3JvbGxpbmc9N109XCJzY3JvbGxpbmdcIn0oZXx8KGU9e30pKSxmdW5jdGlvbihBKXtBW0EubGVmdD0wXT1cImxlZnRcIixBW0EubWlkZGxlPTFdPVwibWlkZGxlXCIsQVtBLnJpZ2h0PTJdPVwicmlnaHRcIn0oQnx8KEI9e30pKSxmdW5jdGlvbihBKXtBW0EucGl4ZWxzPTBdPVwicGl4ZWxzXCIsQVtBLmxpbmVzPTFdPVwibGluZXNcIixBW0EucGFnZXM9Ml09XCJwYWdlc1wifShpfHwoaT17fSkpLEkuUmFpbndheUdlc3R1cmVSZWNvZ25pemVyPWNsYXNze2NvbnN0cnVjdG9yKEEsSSxpPWcpe3RoaXMucmVwb3J0UG9pbnRlckV2ZW50PUEsdGhpcy5yZXBvcnRXaGVlbEV2ZW50PUksdGhpcy5wYXJhbWV0ZXJzPWksdGhpcy5zdGF0ZT1lLmlkbGUsdGhpcy5wcmltYXJ5PXZvaWQgMCx0aGlzLnNlY29uZGFyeT12b2lkIDAsdGhpcy5jZW50cm9pZFk9MCx0aGlzLmxhc3RUYXBUaW1lPW5ldyBEYXRlLHRoaXMucmlnaHRDbGlja1RpbWVyPXZvaWQgMCx0aGlzLnJpZ2h0Q2xpY2s9KCk9Pnt0aGlzLnJlcG9ydE1vdXNlRG93bihCLnJpZ2h0KSx0aGlzLnRvU3RhdGUoZS5ob2xkaW5nUmlnaHRNb3VzZUJ1dHRvbiksdGhpcy5yaWdodENsaWNrVGltZXI9dm9pZCAwfSx0aGlzLnRhcFJlbGVhc2VUaW1lcj12b2lkIDAsdGhpcy50YXBSZWxlYXNlPSgpPT57dGhpcy5yZXBvcnRNb3VzZVVwKEIubGVmdCksdGhpcy50b1N0YXRlKGUuaWRsZSksdGhpcy5yaWdodENsaWNrVGltZXI9dm9pZCAwfSx0aGlzLm9uUG9pbnRlckRvd249QT0+e2NvbnN0IEk9e3BvaW50ZXJJZDpBLnBvaW50ZXJJZCxob21lT2Zmc2V0WDpBLm9mZnNldFgsaG9tZU9mZnNldFk6QS5vZmZzZXRZLGN1cnJlbnRPZmZzZXRYOkEub2Zmc2V0WCxjdXJyZW50T2Zmc2V0WTpBLm9mZnNldFksZG93blRpbWU6bmV3IERhdGUsYXdha2U6ITF9O3ZvaWQgMD09PXRoaXMucHJpbWFyeT8odGhpcy50b1N0YXRlKGUub25lRmluZ2VyRGVjaWRpbmcpLHRoaXMucHJpbWFyeT1JLHdpbmRvdy5jbGVhclRpbWVvdXQodGhpcy5yaWdodENsaWNrVGltZXIpLHRoaXMucmlnaHRDbGlja1RpbWVyPXdpbmRvdy5zZXRUaW1lb3V0KHRoaXMucmlnaHRDbGljayx0aGlzLnBhcmFtZXRlcnMucmlnaHRDbGlja0RlbGF5TXMpKTp2b2lkIDA9PT10aGlzLnNlY29uZGFyeSYmKHRoaXMudG9TdGF0ZShlLnR3b0ZpbmdlcnNEZWNpZGluZyksdGhpcy5zZWNvbmRhcnk9SSx3aW5kb3cuY2xlYXJUaW1lb3V0KHRoaXMucmlnaHRDbGlja1RpbWVyKSl9LHRoaXMub25Qb2ludGVyVXA9QT0+e3ZhciBJO3dpbmRvdy5jbGVhclRpbWVvdXQodGhpcy5yaWdodENsaWNrVGltZXIpO2NvbnN0IGc9QS5wb2ludGVySWQ9PT0obnVsbD09PShJPXRoaXMucHJpbWFyeSl8fHZvaWQgMD09PUk/dm9pZCAwOkkucG9pbnRlcklkKTtpZih0aGlzLnN0YXRlPT09ZS5vbmVGaW5nZXJEZWNpZGluZyYmZyl7dGhpcy5sb2coXCJwb2ludGVyIHVwIGZyb20gZGVjaWRpbmcsIHRhcHBpbmdcIiksd2luZG93LmNsZWFyVGltZW91dCh0aGlzLnJpZ2h0Q2xpY2tUaW1lcik7Y29uc3QgST1PYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sQSkse29mZnNldFg6QS5vZmZzZXRYLG9mZnNldFk6QS5vZmZzZXRZLHBvaW50ZXJUeXBlOlwidG91Y2hcIix0eXBlOlwicG9pbnRlcm1vdmVcIn0pO3RoaXMucmVwb3J0UG9pbnRlckV2ZW50KEkpLHRoaXMucmVwb3J0TW91c2VEb3duKEIubGVmdCksdGhpcy5wcmltYXJ5PXZvaWQgMCx0aGlzLmxhc3RUYXBUaW1lPW5ldyBEYXRlLHRoaXMudGFwUmVsZWFzZVRpbWVyPXdpbmRvdy5zZXRUaW1lb3V0KHRoaXMudGFwUmVsZWFzZSx0aGlzLnBhcmFtZXRlcnMuY2xpY2tEdXJhdGlvbk1zKX1lbHNlIHRoaXMucHJpbWFyeSYmdGhpcy5zZWNvbmRhcnk/KHRoaXMubG9nKFwic3RvcHBpbmcgdHdvIGZpbmdlciBnZXN0dXJlXCIpLHRoaXMucHJpbWFyeT12b2lkIDAsdGhpcy5zZWNvbmRhcnk9dm9pZCAwLHRoaXMudG9TdGF0ZShlLmlkbGUpKTp0aGlzLnN0YXRlPT09ZS5tb3ZpbmcmJmc/KHRoaXMubG9nKFwic3RvcCBtb3ZpbmdcIiksdGhpcy5wcmltYXJ5PXZvaWQgMCx0aGlzLnRvU3RhdGUoZS5pZGxlKSk6dGhpcy5zdGF0ZT09PWUuZHJhZ2dpbmcmJmc/KHRoaXMubG9nKFwic3RvcCBkcmFnZ2luZ1wiKSx0aGlzLnJlcG9ydE1vdXNlVXAoQi5sZWZ0KSx0aGlzLnByaW1hcnk9dm9pZCAwLHRoaXMudG9TdGF0ZShlLmlkbGUpKTp0aGlzLnN0YXRlPT09ZS5ob2xkaW5nUmlnaHRNb3VzZUJ1dHRvbiYmZyYmKHRoaXMubG9nKFwic3RvcCByaWdodCBjbGlja1wiKSx0aGlzLnJlcG9ydE1vdXNlVXAoQi5yaWdodCksdGhpcy5wcmltYXJ5PXZvaWQgMCx0aGlzLnRvU3RhdGUoZS5pZGxlKSl9LHRoaXMub25Qb2ludGVyTW92ZT1BPT57dmFyIEksZztjb25zdCBpPUEucG9pbnRlcklkPT09KG51bGw9PT0oST10aGlzLnByaW1hcnkpfHx2b2lkIDA9PT1JP3ZvaWQgMDpJLnBvaW50ZXJJZCksUT1BLnBvaW50ZXJJZD09PShudWxsPT09KGc9dGhpcy5zZWNvbmRhcnkpfHx2b2lkIDA9PT1nP3ZvaWQgMDpnLnBvaW50ZXJJZCk7aWYodGhpcy5wcmltYXJ5JiZpPyh0aGlzLnByaW1hcnkuY3VycmVudE9mZnNldFg9QS5vZmZzZXRYLHRoaXMucHJpbWFyeS5jdXJyZW50T2Zmc2V0WT1BLm9mZnNldFkpOnRoaXMuc2Vjb25kYXJ5JiZRJiYodGhpcy5zZWNvbmRhcnkuY3VycmVudE9mZnNldFg9QS5vZmZzZXRYLHRoaXMuc2Vjb25kYXJ5LmN1cnJlbnRPZmZzZXRZPUEub2Zmc2V0WSksdGhpcy5wcmltYXJ5JiZpJiYhdGhpcy5zZWNvbmRhcnkpdGhpcy5zdGF0ZT09PWUub25lRmluZ2VyRGVjaWRpbmcmJmZ1bmN0aW9uKEEsSSl7Y29uc3QgZz1BLmN1cnJlbnRPZmZzZXRYLUEuaG9tZU9mZnNldFgsZT1BLmN1cnJlbnRPZmZzZXRZLUEuaG9tZU9mZnNldFk7cmV0dXJuIGcqZytlKmU+SSpJfSh0aGlzLnByaW1hcnksdGhpcy5wYXJhbWV0ZXJzLnRvdWNoU2xvcFJhZGl1cyk/KHRoaXMubG9nKFwibGVmdCB0b3VjaCBzbG9wIHJhZGl1c1wiKSx3aW5kb3cuY2xlYXJUaW1lb3V0KHRoaXMucmlnaHRDbGlja1RpbWVyKSx0aGlzLnByaW1hcnkuYXdha2U9ITAsKG5ldyBEYXRlKS52YWx1ZU9mKCktdGhpcy5sYXN0VGFwVGltZS52YWx1ZU9mKCk8dGhpcy5wYXJhbWV0ZXJzLmRyYWdEZWxheU1zPyh0aGlzLnJlcG9ydE1vdXNlRG93bihCLmxlZnQpLHRoaXMudG9TdGF0ZShlLmRyYWdnaW5nKSk6dGhpcy50b1N0YXRlKGUubW92aW5nKSk6dGhpcy5zdGF0ZSE9PWUuZHJhZ2dpbmcmJnRoaXMuc3RhdGUhPT1lLm1vdmluZyYmdGhpcy5zdGF0ZSE9PWUuaG9sZGluZ1JpZ2h0TW91c2VCdXR0b258fHRoaXMucmVwb3J0UG9pbnRlckV2ZW50KEEpO2Vsc2UgaWYodGhpcy5wcmltYXJ5JiZ0aGlzLnNlY29uZGFyeSlpZih0aGlzLnN0YXRlPT09ZS50d29GaW5nZXJzRGVjaWRpbmcpe2NvbnN0IEE9dGhpcy5wcmltYXJ5LmN1cnJlbnRPZmZzZXRZLXRoaXMucHJpbWFyeS5ob21lT2Zmc2V0WSxJPXRoaXMuc2Vjb25kYXJ5LmN1cnJlbnRPZmZzZXRZLXRoaXMuc2Vjb25kYXJ5LmhvbWVPZmZzZXRZLGc9dGhpcy5wYXJhbWV0ZXJzLnNjcm9sbEdlc3R1cmVUaHJlc2hvbGRQaXhlbHM7KEE+ZyYmST5nfHxBPGcmJkk8ZykmJih0aGlzLnRvU3RhdGUoZS5zY3JvbGxpbmcpLHRoaXMuY2VudHJvaWRZPShBK0kpLzIpfWVsc2UgaWYodGhpcy5zdGF0ZT09PWUuc2Nyb2xsaW5nKXtjb25zdCBBPXRoaXMucGFyYW1ldGVycy5zY3JvbGxFcHNpbG9uUGl4ZWxzLEk9KHRoaXMucHJpbWFyeS5jdXJyZW50T2Zmc2V0WS10aGlzLnByaW1hcnkuaG9tZU9mZnNldFkrKHRoaXMuc2Vjb25kYXJ5LmN1cnJlbnRPZmZzZXRZLXRoaXMuc2Vjb25kYXJ5LmhvbWVPZmZzZXRZKSkvMjtJPnRoaXMuY2VudHJvaWRZK0E/KHRoaXMucmVwb3J0U2Nyb2xsKHRoaXMucGFyYW1ldGVycy5zY3JvbGxTZW5zaXRpdml0eSpBKSx0aGlzLmNlbnRyb2lkWT1JKTpJPHRoaXMuY2VudHJvaWRZLUEmJih0aGlzLnJlcG9ydFNjcm9sbCh0aGlzLnBhcmFtZXRlcnMuc2Nyb2xsU2Vuc2l0aXZpdHkqLUEpLHRoaXMuY2VudHJvaWRZPUkpfX19bG9nKC4uLkEpe31yZXBvcnRNb3VzZVVwKEEpe3RoaXMubG9nKFwiLS1cXHgzZSByZXBvcnQgcG9pbnRlcnVwXCIsQSk7Y29uc3QgST1uZXcgUG9pbnRlckV2ZW50KFwicG9pbnRlcnVwXCIse3BvaW50ZXJUeXBlOlwibW91c2VcIixidXR0b25zOjAsYnV0dG9uOkF9KTt0aGlzLnJlcG9ydFBvaW50ZXJFdmVudChJKX1yZXBvcnRNb3VzZURvd24oQSl7dGhpcy5sb2coXCItLVxceDNlIHJlcG9ydCBwb2ludGVyZG93blwiLEEpO2NvbnN0IEk9bmV3IFBvaW50ZXJFdmVudChcInBvaW50ZXJkb3duXCIse3BvaW50ZXJUeXBlOlwibW91c2VcIixidXR0b25zOlEoQSksYnV0dG9uOkF9KTt0aGlzLnJlcG9ydFBvaW50ZXJFdmVudChJKX1yZXBvcnRTY3JvbGwoQSl7Y29uc3QgST1uZXcgV2hlZWxFdmVudChcInN5bnRoZXRpY1doZWVsXCIse2RlbHRhWTpBLGRlbHRhTW9kZTppLnBpeGVsc30pO3RoaXMucmVwb3J0V2hlZWxFdmVudChJKX10b1N0YXRlKEEpe3RoaXMubG9nKFtcImlkbGVcIixcIm9uZUZpbmdlckRlY2lkaW5nXCIsXCJ0d29GaW5nZXJzRGVjaWRpbmdcIixcIm1vdmluZ1wiLFwiZHJhZ2dpbmdcIixcImhvbGRpbmdSaWdodE1vdXNlQnV0dG9uXCIsXCJ6b29taW5nXCIsXCJzY3JvbGxpbmdcIl1bQV0pLHRoaXMuc3RhdGU9QX1wcm9jZXNzUG9pbnRlckV2ZW50KEEpe2lmKFwidG91Y2hcIj09PUEucG9pbnRlclR5cGUpc3dpdGNoKEEudHlwZSl7Y2FzZVwicG9pbnRlcmRvd25cIjp0aGlzLm9uUG9pbnRlckRvd24oQSk7YnJlYWs7Y2FzZVwicG9pbnRlcnVwXCI6dGhpcy5vblBvaW50ZXJVcChBKTticmVhaztjYXNlXCJwb2ludGVycmF3dXBkYXRlXCI6Y2FzZVwicG9pbnRlcm1vdmVcIjp0aGlzLm9uUG9pbnRlck1vdmUoQSl9ZWxzZSB0aGlzLnJlcG9ydFBvaW50ZXJFdmVudChBKX19fSw4MjQ6KEEsSSxnKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eShJLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLEkuUmFpbndheUlucHV0TWFuYWdlcj1JLm1vdXNlQ2xpY2tGcm9tPXZvaWQgMDtjb25zdCBlPWcoOTk0KSxCPWcoOTA0KSxpPWcoNDApLFE9ZygzMjIpLHQ9Zyg2NSksQz1nKDUyOCksRT1nKDkwNCk7ZnVuY3Rpb24gbyhBKXtsZXQgSSxnO3N3aXRjaChBLmJ1dHRvbil7ZGVmYXVsdDpjYXNlIDA6ST0wIT0oMSZBLmJ1dHRvbnMpLGc9RS5Nb3VzZUJ1dHRvbi5MZWZ0O2JyZWFrO2Nhc2UgMTpJPTAhPSg0JkEuYnV0dG9ucyksZz1FLk1vdXNlQnV0dG9uLk1pZGRsZTticmVhaztjYXNlIDI6ST0wIT0oMiZBLmJ1dHRvbnMpLGc9RS5Nb3VzZUJ1dHRvbi5SaWdodDticmVhaztjYXNlIDM6ST0wIT0oOCZBLmJ1dHRvbnMpLGc9RS5Nb3VzZUJ1dHRvbi5YMTticmVhaztjYXNlIDQ6ST0wIT0oMTYmQS5idXR0b25zKSxnPUUuTW91c2VCdXR0b24uWDJ9cmV0dXJue2J1dHRvbjpnLGFjdGlvbjpJP0UuQnV0dG9uQWN0aW9uLkJ1dHRvbkRvd246RS5CdXR0b25BY3Rpb24uQnV0dG9uVXB9fWZ1bmN0aW9uIGEoQSl7cmV0dXJuIEEuYXhlcy5sZW5ndGg+PTQmJkEuYnV0dG9ucy5sZW5ndGg+PTE2fWZ1bmN0aW9uIG4oQSxJKXtpZihBPT09SSlyZXR1cm4hMDtpZihBLmxlbmd0aCE9PUkubGVuZ3RoKXJldHVybiExO2ZvcihsZXQgZz0wO2c8QS5sZW5ndGg7KytnKWlmKEFbZ10hPT1JW2ddKXJldHVybiExO3JldHVybiEwfUkubW91c2VDbGlja0Zyb209byxJLlJhaW53YXlJbnB1dE1hbmFnZXI9Y2xhc3N7Y29uc3RydWN0b3IoQSxJPXt0b3VjaEdlc3R1cmVzOiExLHVubG9ja2VkTW91c2VQb2ludGVyOiExLGVtYnJhY2VNb3VzZUFjY2VsZXJhdGlvbjohMX0pe3RoaXMucmFpbndheVN0cmVhbT1BLHRoaXMub3B0aW9ucz1JLHRoaXMubGV2ZWw9Qi5JbnB1dExldmVsLk5vbmUsdGhpcy5jb250YWluZXI9dm9pZCAwLHRoaXMuaGVsZENvZGVzPW5ldyBTZXQsdGhpcy5hbHdheXNSZXBvcnRHYW1lcGFkUG9sbD0hMCx0aGlzLmxvY2tQb2ludGVyPSgpPT57aWYodGhpcy5vcHRpb25zLnVubG9ja2VkTW91c2VQb2ludGVyKXJldHVybjtpZighdGhpcy5jb250YWluZXIpcmV0dXJuO2lmKCF0aGlzLmNvbnRhaW5lci5yZXF1ZXN0UG9pbnRlckxvY2spcmV0dXJuO2NvbnN0IEE9IXRoaXMub3B0aW9ucy5lbWJyYWNlTW91c2VBY2NlbGVyYXRpb24sST1BP3RoaXMuY29udGFpbmVyLnJlcXVlc3RQb2ludGVyTG9jayh7dW5hZGp1c3RlZE1vdmVtZW50OiEwfSk6dGhpcy5jb250YWluZXIucmVxdWVzdFBvaW50ZXJMb2NrKCk7SSBpbnN0YW5jZW9mIFByb21pc2U/SS5jYXRjaCgoST0+e3ZhciBnO1wiTm90U3VwcG9ydGVkRXJyb3JcIj09PUkubmFtZSYmQSYmKG51bGw9PT0oZz10aGlzLmNvbnRhaW5lcil8fHZvaWQgMD09PWd8fGcucmVxdWVzdFBvaW50ZXJMb2NrKCkpfSkpOnRoaXMuY29udGFpbmVyLm9ucG9pbnRlcmxvY2tlcnJvcj0oKT0+e3ZhciBJO0EmJihudWxsPT09KEk9dGhpcy5jb250YWluZXIpfHx2b2lkIDA9PT1JfHxJLnJlcXVlc3RQb2ludGVyTG9jaygpKX0sdGhpcy5jb250YWluZXIuZm9jdXMoKX0sdGhpcy5mb2N1c0NvbnRhaW5lcj0oKT0+e3ZhciBBO3JldHVybiBudWxsPT09KEE9dGhpcy5jb250YWluZXIpfHx2b2lkIDA9PT1BP3ZvaWQgMDpBLmZvY3VzKCl9LHRoaXMub25Qb2ludGVyRXZlbnRXaXRoR2VzdHVyZVByb2Nlc3Npbmc9QT0+eyhBLnBvaW50ZXJUeXBlJiZcIm1vdXNlXCIhPT1BLnBvaW50ZXJUeXBlfHxkb2N1bWVudC5wb2ludGVyTG9ja0VsZW1lbnQ9PT10aGlzLmNvbnRhaW5lcikmJih0aGlzLm9wdGlvbnMudG91Y2hHZXN0dXJlcyYmXCJ0b3VjaFwiPT09QS5wb2ludGVyVHlwZT8oQS5wcmV2ZW50RGVmYXVsdCgpLHRoaXMuZ2VzdHVyZVJlY29nbml6ZXIucHJvY2Vzc1BvaW50ZXJFdmVudChBKSk6dGhpcy5vblBvaW50ZXJFdmVudChBKSl9LHRoaXMub25Qb2ludGVyRXZlbnRGcm9tR2VzdHVyZVJlY29nbml6ZXI9QT0+e3RoaXMub25Qb2ludGVyRXZlbnQoQSl9LHRoaXMub25Qb2ludGVyRXZlbnQ9QT0+e3RoaXMuY3Vyc29yUGFpbnRlci51cGRhdGUoQSx0aGlzLnJlbWVtYmVyZWRPZmZzZXRYLHRoaXMucmVtZW1iZXJlZE9mZnNldFkpLHRoaXMucmVwb3J0UG9pbnRlckV2ZW50KEEpfSx0aGlzLnNjcm9sbGVkQW1vdW50PTAsdGhpcy5vbldoZWVsRXZlbnQ9QT0+e3RoaXMuc2Nyb2xsZWRBbW91bnQrPS4wNSpBLmRlbHRhWSx0aGlzLnNjcm9sbGVkQW1vdW50Pj0xPyh0aGlzLnNlbmRWZXJ0aWNhbFNjcm9sbChNYXRoLmZsb29yKHRoaXMuc2Nyb2xsZWRBbW91bnQpKSx0aGlzLnNjcm9sbGVkQW1vdW50JT0xKTp0aGlzLnNjcm9sbGVkQW1vdW50PD0tMSYmKHRoaXMuc2VuZFZlcnRpY2FsU2Nyb2xsKE1hdGguY2VpbCh0aGlzLnNjcm9sbGVkQW1vdW50KSksdGhpcy5zY3JvbGxlZEFtb3VudCU9LTEpfSx0aGlzLm9uS2V5Ym9hcmRFdmVudD1BPT57QS5wcmV2ZW50RGVmYXVsdCgpLFwia2V5ZG93blwiPT09QS50eXBlP3RoaXMuaGVsZENvZGVzLmFkZChBLmNvZGUpOlwia2V5dXBcIj09PUEudHlwZSYmdGhpcy5oZWxkQ29kZXMuZGVsZXRlKEEuY29kZSk7Y29uc3QgST1pLlJhaW53YXlWaXJ0dWFsS2V5RnJvbVdlYktleUNvZGVbQS5jb2RlXTtJJiZ0aGlzLnNlbmRJbnB1dERhdGFncmFtKHtkaXNjcmltaW5hdG9yOkUuS2V5Ym9hcmRJbnB1dC5kaXNjcmltaW5hdG9yLHZhbHVlOnthY3Rpb246XCJrZXlkb3duXCI9PT1BLnR5cGU/RS5LZXlib2FyZEFjdGlvbi5LZXlEb3duOkUuS2V5Ym9hcmRBY3Rpb24uS2V5VXAsa2V5Y29kZXM6W0ldfX0pfSx0aGlzLm9uR2FtZXBhZENvbm5lY3RlZEV2ZW50PUE9Pnt9LHRoaXMub25HYW1lcGFkRGlzY29ubmVjdGVkRXZlbnQ9QT0+e30sdGhpcy5vbkRldmljZU1vdGlvbj1BPT57fSx0aGlzLm9uRGV2aWNlT3JpZW50YXRpb249QT0+e30sdGhpcy5nYW1lcGFkQ2FjaGU9bmV3IE1hcCx0aGlzLnBvbGxHYW1lcGFkcz1BPT57aWYobmF2aWdhdG9yLmdldEdhbWVwYWRzKXtpZih0aGlzLmNvbnRhaW5lcj09PWRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpe2NvbnN0IEE9W107Zm9yKGNvbnN0IEkgb2YgbmF2aWdhdG9yLmdldEdhbWVwYWRzKCkpe2lmKCFJfHwhYShJKSljb250aW51ZTtjb25zdCBnPUkuYnV0dG9ucy5tYXAoKEE9PkEudmFsdWUpKSxlPXRoaXMuZ2FtZXBhZENhY2hlLmdldChJLmluZGV4KTtlJiZuKGUuYXhlcyxJLmF4ZXMpJiZuKGUuYnV0dG9uVmFsdWVzLGcpfHwoQS5wdXNoKHRoaXMubWFrZUdhbWVwYWRJbnB1dEV2ZW50KEkpKSx0aGlzLmdhbWVwYWRDYWNoZS5zZXQoSS5pbmRleCx7YXhlczpbLi4uSS5heGVzXSxidXR0b25WYWx1ZXM6Z30pKX0odGhpcy5hbHdheXNSZXBvcnRHYW1lcGFkUG9sbHx8QS5sZW5ndGg+MCkmJnRoaXMucmVwb3J0R2FtZXBhZEV2ZW50cyhBKX10aGlzLmxldmVsJkIuSW5wdXRMZXZlbC5HYW1lcGFkJiYodGhpcy5nYW1lcGFkRnJhbWVIYW5kbGU9d2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSh0aGlzLnBvbGxHYW1lcGFkcykpfX0sdGhpcy5yZXBvcnRHYW1lcGFkRXZlbnRzPUE9Pntmb3IoY29uc3QgSSBvZiBBKXtsZXQgQT0wO0kuYnV0dG9ucy5kcGFkVXAmJihBfD0xKSxJLmJ1dHRvbnMuZHBhZERvd24mJihBfD0yKSxJLmJ1dHRvbnMuZHBhZExlZnQmJihBfD00KSxJLmJ1dHRvbnMuZHBhZFJpZ2h0JiYoQXw9OCksSS5idXR0b25zLnN0YXJ0JiYoQXw9MTYpLEkuYnV0dG9ucy5zZWxlY3QmJihBfD0zMiksSS5idXR0b25zLmxlZnRTdGlja1ByZXNzZWQmJihBfD02NCksSS5idXR0b25zLnJpZ2h0U3RpY2tQcmVzc2VkJiYoQXw9MTI4KSxJLmJ1dHRvbnMubGVmdFNob3VsZGVyJiYoQXw9MjU2KSxJLmJ1dHRvbnMucmlnaHRTaG91bGRlciYmKEF8PTUxMiksSS5idXR0b25zLmEmJihBfD00MDk2KSxJLmJ1dHRvbnMuYiYmKEF8PTgxOTIpLEkuYnV0dG9ucy54JiYoQXw9MTYzODQpLEkuYnV0dG9ucy55JiYoQXw9MzI3NjgpO2NvbnN0IGc9e2J1dHRvbnM6QSxsZWZ0VHJpZ2dlcjpNYXRoLnJvdW5kKDI1NSpJLmJ1dHRvbnMubGVmdFRyaWdnZXIpLHJpZ2h0VHJpZ2dlcjpNYXRoLnJvdW5kKDI1NSpJLmJ1dHRvbnMucmlnaHRUcmlnZ2VyKSxsZWZ0VGh1bWJYOk1hdGgucm91bmQoMzI3NjcqSS5zdGlja3MubGVmdC54KSxsZWZ0VGh1bWJZOk1hdGgucm91bmQoMzI3NjcqLUkuc3RpY2tzLmxlZnQueSkscmlnaHRUaHVtYlg6TWF0aC5yb3VuZCgzMjc2NypJLnN0aWNrcy5yaWdodC54KSxyaWdodFRodW1iWTpNYXRoLnJvdW5kKDMyNzY3Ki1JLnN0aWNrcy5yaWdodC55KSxzbG90OjF9O3RoaXMuc2VuZElucHV0RGF0YWdyYW0oe2Rpc2NyaW1pbmF0b3I6RS5HYW1lcGFkUmVwb3J0LmRpc2NyaW1pbmF0b3IsdmFsdWU6Z30pfX0sdGhpcy5tb3ZlTW91c2VSZWxhdGl2ZVhZPShBLEkpPT57dGhpcy5zZW5kTW91c2VNb3ZlKFwicmVsYXRpdmVcIixBLEkpfSx0aGlzLm1vdmVNb3VzZUFic29sdXRlWFk9KEEsSSk9Pnt0aGlzLnNlbmRNb3VzZU1vdmUoXCJhYnNvbHV0ZVwiLEEsSSl9LHRoaXMucG9pbnRlckZyYW1lSWQ9MCx0aGlzLnJlbWVtYmVyZWRPZmZzZXRYPTAsdGhpcy5yZW1lbWJlcmVkT2Zmc2V0WT0wLHRoaXMudG91Y2hlcz1uZXcgTWFwLHRoaXMucmVwb3J0UG9pbnRlckV2ZW50PUE9PntpZihcInRvdWNoXCI9PT1BLnBvaW50ZXJUeXBlfHxcInBlblwiPT09QS5wb2ludGVyVHlwZSl7aWYoZG9jdW1lbnQucG9pbnRlckxvY2tFbGVtZW50PT09dGhpcy5jb250YWluZXIpe2NvbnN0IEk9dGhpcy5jb250YWluZXIuY2xpZW50V2lkdGgsZz10aGlzLmNvbnRhaW5lci5jbGllbnRIZWlnaHQsZT1BLm1vdmVtZW50WCxCPUEubW92ZW1lbnRZO3RoaXMucmVtZW1iZXJlZE9mZnNldFg9TWF0aC5tYXgoMCxNYXRoLm1pbihJLHRoaXMucmVtZW1iZXJlZE9mZnNldFgrZSkpLHRoaXMucmVtZW1iZXJlZE9mZnNldFk9TWF0aC5tYXgoMCxNYXRoLm1pbihnLHRoaXMucmVtZW1iZXJlZE9mZnNldFkrQikpfWVsc2UgdGhpcy5yZW1lbWJlcmVkT2Zmc2V0WD1BLm9mZnNldFgsdGhpcy5yZW1lbWJlcmVkT2Zmc2V0WT1BLm9mZnNldFk7Y29uc3QgST10aGlzLnJhaW53YXlTdHJlYW0udHJhbnNmb3JtUG9pbnRlck9mZnNldFRvUmVtb3RlKHRoaXMucmVtZW1iZXJlZE9mZnNldFgsdGhpcy5yZW1lbWJlcmVkT2Zmc2V0WSk7aWYoIUkpcmV0dXJuO2NvbnN0e3g6Zyx5OmV9PUksaT1NYXRoLmNlaWwoQS53aWR0aC8yKSxRPU1hdGguY2VpbChBLmhlaWdodC8yKSx7cG9pbnRlcklkOnQsYnV0dG9uczpDfT1BLEU9XCJwb2ludGVyY2FuY2VsXCI9PT1BLnR5cGV8fFwicG9pbnRlcm91dFwiPT09QS50eXBlfHxcInBvaW50ZXJsZWF2ZVwiPT09QS50eXBlLG89Qz4wLGE9KFwicG9pbnRlcm92ZXJcIj09PUEudHlwZT9CLldpbmRvd3NQb2ludGVyRmxhZ3MuTmV3OjApfChvP0IuV2luZG93c1BvaW50ZXJGbGFncy5JbkNvbnRhY3Q6MCl8KDE9PSgzJkMpP0IuV2luZG93c1BvaW50ZXJGbGFncy5GaXJzdEJ1dHRvbjowKXwoMz09KDMmQyk/Qi5XaW5kb3dzUG9pbnRlckZsYWdzLlNlY29uZEJ1dHRvbjowKXwoQS5pc1ByaW1hcnk/Qi5XaW5kb3dzUG9pbnRlckZsYWdzLlByaW1hcnk6MCl8KFwicG9pbnRlcmNhbmNlbFwiPT09QS50eXBlP0IuV2luZG93c1BvaW50ZXJGbGFncy5DYW5jZWxlZDowKXwoXCJwb2ludGVyZG93blwiPT09QS50eXBlP0IuV2luZG93c1BvaW50ZXJGbGFncy5Eb3duOlwicG9pbnRlcnVwXCI9PT1BLnR5cGU/Qi5XaW5kb3dzUG9pbnRlckZsYWdzLlVwOkIuV2luZG93c1BvaW50ZXJGbGFncy5VcGRhdGUpfChFP28/Qi5XaW5kb3dzUG9pbnRlckZsYWdzLlVwOkIuV2luZG93c1BvaW50ZXJGbGFncy5VcGRhdGU6Qi5XaW5kb3dzUG9pbnRlckZsYWdzLkluUmFuZ2UpLG49e3BvaW50ZXJJZDp0LGZyYW1lSWQ6Kyt0aGlzLnBvaW50ZXJGcmFtZUlkLHBvaW50ZXJGbGFnczphLHg6Zyx5OmV9LHM9TWF0aC5yb3VuZChBLnR3aXN0KSUzNjAscj1NYXRoLnJvdW5kKDEwMjQqQS5wcmVzc3VyZSk7aWYoXCJ0b3VjaFwiPT09QS5wb2ludGVyVHlwZSl7Y29uc3QgQT17cG9pbnRlckluZm86bix0b3VjaE1hc2s6Qi5Ub3VjaE1hc2suQ29udGFjdEFyZWF8Qi5Ub3VjaE1hc2suT3JpZW50YXRpb258Qi5Ub3VjaE1hc2suUHJlc3N1cmUsY29udGFjdExlZnQ6Zy1pLGNvbnRhY3RUb3A6ZS1RLGNvbnRhY3RSaWdodDpnK2ksY29udGFjdEJvdHRvbTplK1Esb3JpZW50YXRpb246cyxwcmVzc3VyZTpyfTt0aGlzLnRvdWNoZXMuc2V0KHQsQSksdGhpcy5zZW5kSW5wdXREYXRhZ3JhbSh7ZGlzY3JpbWluYXRvcjpCLlRvdWNoZXNBYnNvbHV0ZS5kaXNjcmltaW5hdG9yLHZhbHVlOnt0b3VjaGVzOlsuLi50aGlzLnRvdWNoZXMudmFsdWVzKCldfX0pLEUmJnRoaXMudG91Y2hlcy5kZWxldGUodCl9ZWxzZXtjb25zdCBJPSgyJkM/Qi5QZW5GbGFncy5CYXJyZWw6MCl8KDMyJkM/Qi5QZW5GbGFncy5FcmFzZXI6MCk7dGhpcy5zZW5kSW5wdXREYXRhZ3JhbSh7ZGlzY3JpbWluYXRvcjpCLlBlbkFic29sdXRlLmRpc2NyaW1pbmF0b3IsdmFsdWU6e3BvaW50ZXJJbmZvOm4scGVuTWFzazpCLlBlbk1hc2suUHJlc3N1cmV8Qi5QZW5NYXNrLlJvdGF0aW9ufEIuUGVuTWFzay5UaWx0WHxCLlBlbk1hc2suVGlsdFkscGVuRmxhZ3M6SSxyb3RhdGlvbjpzLHByZXNzdXJlOnIsdGlsdFg6TWF0aC5yb3VuZChBLnRpbHRYKSx0aWx0WTpNYXRoLnJvdW5kKEEudGlsdFkpfX0pfX1lbHNlIGlmKChBLm1vdmVtZW50WHx8QS5tb3ZlbWVudFkpJiZ0aGlzLnNlbmRNb3VzZU1vdmUoXCJyZWxhdGl2ZVwiLEEubW92ZW1lbnRYLEEubW92ZW1lbnRZKSxBLmJ1dHRvbj4tMSl7Y29uc3QgST1vKEEpO3RoaXMuc2VuZE1vdXNlQ2xpY2soSSl9fSx0aGlzLmN1cnNvclBhaW50ZXI9bmV3IHQuUmFpbndheUN1cnNvclBhaW50ZXIodGhpcy5tb3ZlTW91c2VBYnNvbHV0ZVhZLCgoQSxJKT0+dGhpcy5yYWlud2F5U3RyZWFtLnRyYW5zZm9ybVBvaW50ZXJPZmZzZXRUb1JlbW90ZShBLEkpKSwoKCk9PnRoaXMucmFpbndheVN0cmVhbS5jdXJyZW50RnJhbWVTaXplKSksdGhpcy5nZXN0dXJlUmVjb2duaXplcj1uZXcgUS5SYWlud2F5R2VzdHVyZVJlY29nbml6ZXIodGhpcy5vblBvaW50ZXJFdmVudEZyb21HZXN0dXJlUmVjb2duaXplcix0aGlzLm9uV2hlZWxFdmVudCl9c2V0Q29udGFpbmVyKEEpe2lmKHRoaXMuY3Vyc29yUGFpbnRlci5zZXRDb250YWluZXIoQSksdGhpcy5jb250YWluZXIpe2NvbnN0IEk9dGhpcy5sZXZlbDt0aGlzLnNldElucHV0TGV2ZWwoQi5JbnB1dExldmVsLk5vbmUsITEpLHRoaXMuY29udGFpbmVyPUEsdGhpcy5zZXRJbnB1dExldmVsKEksITEpfWVsc2UgdGhpcy5jb250YWluZXI9QX11bnNldENvbnRhaW5lcigpe3RoaXMuc2V0SW5wdXRMZXZlbChCLklucHV0TGV2ZWwuTm9uZSwhMSksdGhpcy5jdXJzb3JQYWludGVyLnVuc2V0Q29udGFpbmVyKCksdGhpcy5jb250YWluZXI9dm9pZCAwfXNldElucHV0TGV2ZWwoQSxJPSEwLGc9ITApe3RoaXMuYWx3YXlzUmVwb3J0R2FtZXBhZFBvbGw9Zztjb25zdCBlPUEmfnRoaXMubGV2ZWwsaT10aGlzLmxldmVsJn5BO3RoaXMubGV2ZWw9QSxlJkIuSW5wdXRMZXZlbC5HYW1lcGFkJiZ0aGlzLnN0YXJ0R2FtZXBhZChJKSxpJkIuSW5wdXRMZXZlbC5HYW1lcGFkJiZ0aGlzLnN0b3BHYW1lcGFkKCksZSZCLklucHV0TGV2ZWwuTW91c2UmJnRoaXMuc3RhcnRNb3VzZSgpLGkmQi5JbnB1dExldmVsLk1vdXNlJiZ0aGlzLnN0b3BNb3VzZSgpLGUmQi5JbnB1dExldmVsLktleWJvYXJkJiZ0aGlzLnN0YXJ0S2V5Ym9hcmQoKSxpJkIuSW5wdXRMZXZlbC5LZXlib2FyZCYmdGhpcy5zdG9wS2V5Ym9hcmQoKX1nZXRJbnB1dExldmVsKCl7cmV0dXJuIHRoaXMubGV2ZWx9c3RhcnRHYW1lcGFkKEEpe3dpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwiZ2FtZXBhZGNvbm5lY3RlZFwiLHRoaXMub25HYW1lcGFkQ29ubmVjdGVkRXZlbnQpLHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwiZ2FtZXBhZGRpc2Nvbm5lY3RlZFwiLHRoaXMub25HYW1lcGFkRGlzY29ubmVjdGVkRXZlbnQpLHRoaXMuZ2FtZXBhZEZyYW1lSGFuZGxlPXdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUodGhpcy5wb2xsR2FtZXBhZHMpLEEmJnRoaXMucmVwb3J0Q29ubmVjdGVkR2FtZXBhZHMoKX1yZXBvcnRDb25uZWN0ZWRHYW1lcGFkcygpe2Zvcihjb25zdCBBIG9mIG5hdmlnYXRvci5nZXRHYW1lcGFkcygpKUEmJnRoaXMub25HYW1lcGFkQ29ubmVjdGVkRXZlbnQobmV3IEdhbWVwYWRFdmVudChcImdhbWVwYWRjb25uZWN0ZWRcIix7Z2FtZXBhZDpBfSkpfXN0b3BHYW1lcGFkKCl7d2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJnYW1lcGFkY29ubmVjdGVkXCIsdGhpcy5vbkdhbWVwYWRDb25uZWN0ZWRFdmVudCksd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJnYW1lcGFkZGlzY29ubmVjdGVkXCIsdGhpcy5vbkdhbWVwYWREaXNjb25uZWN0ZWRFdmVudCksdGhpcy5nYW1lcGFkRnJhbWVIYW5kbGUmJndpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLmdhbWVwYWRGcmFtZUhhbmRsZSksdGhpcy5nYW1lcGFkRnJhbWVIYW5kbGU9dm9pZCAwfXBvaW50ZXJFdmVudExpc3RlbmVycyhBKXtpZighd2luZG93LlBvaW50ZXJFdmVudCl0aHJvdyBuZXcgRXJyb3IoXCJicm93c2VyIGRvZXMgbm90IHN1cHBvcnQgUG9pbnRlckV2ZW50XCIpO0EoQy5pc0Rlc2t0b3BTYWZhcmkmJm5hdmlnYXRvci5tYXhUb3VjaFBvaW50czwxP1wibW91c2Vtb3ZlXCI6d2luZG93Lm9ucG9pbnRlcnJhd3VwZGF0ZT9cInBvaW50ZXJyYXd1cGRhdGVcIjpcInBvaW50ZXJtb3ZlXCIsdGhpcy5vblBvaW50ZXJFdmVudFdpdGhHZXN0dXJlUHJvY2Vzc2luZyksQShcInBvaW50ZXJkb3duXCIsdGhpcy5vblBvaW50ZXJFdmVudFdpdGhHZXN0dXJlUHJvY2Vzc2luZyksQShcInBvaW50ZXJ1cFwiLHRoaXMub25Qb2ludGVyRXZlbnRXaXRoR2VzdHVyZVByb2Nlc3NpbmcpLEEoXCJwb2ludGVyb3ZlclwiLHRoaXMub25Qb2ludGVyRXZlbnRXaXRoR2VzdHVyZVByb2Nlc3NpbmcpLEEoXCJwb2ludGVyZW50ZXJcIix0aGlzLm9uUG9pbnRlckV2ZW50V2l0aEdlc3R1cmVQcm9jZXNzaW5nKSxBKFwicG9pbnRlcmNhbmNlbFwiLHRoaXMub25Qb2ludGVyRXZlbnRXaXRoR2VzdHVyZVByb2Nlc3NpbmcpLEEoXCJwb2ludGVyb3V0XCIsdGhpcy5vblBvaW50ZXJFdmVudFdpdGhHZXN0dXJlUHJvY2Vzc2luZyksQShcInBvaW50ZXJsZWF2ZVwiLHRoaXMub25Qb2ludGVyRXZlbnRXaXRoR2VzdHVyZVByb2Nlc3NpbmcpLEEoXCJ3aGVlbFwiLHRoaXMub25XaGVlbEV2ZW50KSxBKFwibW91c2V1cFwiLHRoaXMubG9ja1BvaW50ZXIpfXN0YXJ0TW91c2UoKXtpZighdGhpcy5jb250YWluZXIpdGhyb3cgbmV3IGUuUmFpbndheUVycm9yKFwiUmFpbndheSB0cmllZCB0byBhZGQgYW4gZXZlbnQgbGlzdGVuZXIgdG8gaXRzIGNvbnRhaW5lciB0byBoYW5kbGUgbW91c2UgaW5wdXQsIGJ1dCBubyBjb250YWluZXIgZWxlbWVudCBpcyBzZXQuIFRyeSBjYWxsaW5nIHNldENvbnRhaW5lcigpIGZpcnN0LlwiKTt0aGlzLnBvaW50ZXJFdmVudExpc3RlbmVycyh0aGlzLmNvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyLmJpbmQodGhpcy5jb250YWluZXIpKX1zdG9wTW91c2UoKXt0aGlzLmNvbnRhaW5lciYmdGhpcy5wb2ludGVyRXZlbnRMaXN0ZW5lcnModGhpcy5jb250YWluZXIucmVtb3ZlRXZlbnRMaXN0ZW5lci5iaW5kKHRoaXMuY29udGFpbmVyKSl9c3RhcnRLZXlib2FyZCgpe2lmKCF0aGlzLmNvbnRhaW5lcil0aHJvdyBuZXcgZS5SYWlud2F5RXJyb3IoXCJSYWlud2F5IHRyaWVkIHRvIGFkZCBhbiBldmVudCBsaXN0ZW5lciB0byBpdHMgY29udGFpbmVyIHRvIGhhbmRsZSBrZXlib2FyZCBpbnB1dCwgYnV0IG5vIGNvbnRhaW5lciBlbGVtZW50IGlzIHNldC4gVHJ5IGNhbGxpbmcgc2V0Q29udGFpbmVyKCkgZmlyc3QuXCIpO3RoaXMuY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsdGhpcy5vbktleWJvYXJkRXZlbnQpLHRoaXMuY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoXCJrZXl1cFwiLHRoaXMub25LZXlib2FyZEV2ZW50KSx0aGlzLmNvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIix0aGlzLmZvY3VzQ29udGFpbmVyKSx0aGlzLmNvbnRhaW5lci5mb2N1cygpfXN0b3BLZXlib2FyZCgpe3RoaXMuY29udGFpbmVyJiYodGhpcy5yZWxlYXNlS2V5cygpLHRoaXMuY29udGFpbmVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsdGhpcy5vbktleWJvYXJkRXZlbnQpLHRoaXMuY29udGFpbmVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJrZXl1cFwiLHRoaXMub25LZXlib2FyZEV2ZW50KSx0aGlzLmNvbnRhaW5lci5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2xpY2tcIix0aGlzLmZvY3VzQ29udGFpbmVyKSl9c3RhcnREZXZpY2VNb3Rpb25FdmVudHMoKXt3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImRldmljZW1vdGlvblwiLHRoaXMub25EZXZpY2VNb3Rpb24pfXN0b3BEZXZpY2VNb3Rpb25FdmVudHMoKXt3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImRldmljZW1vdGlvblwiLHRoaXMub25EZXZpY2VNb3Rpb24pfXN0YXJ0RGV2aWNlT3JpZW50YXRpb25FdmVudHMoKXt3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImRldmljZW9yaWVudGF0aW9uXCIsdGhpcy5vbkRldmljZU9yaWVudGF0aW9uKX1zdG9wRGV2aWNlT3JpZW50YXRpb25FdmVudHMoKXt3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImRldmljZW9yaWVudGF0aW9uXCIsdGhpcy5vbkRldmljZU9yaWVudGF0aW9uKX1zZW5kVmVydGljYWxTY3JvbGwoQSl7dGhpcy5zZW5kSW5wdXREYXRhZ3JhbSh7ZGlzY3JpbWluYXRvcjpFLk1vdXNlU2Nyb2xsLmRpc2NyaW1pbmF0b3IsdmFsdWU6e2F4aXM6RS5TY3JvbGxBeGlzLlZlcnRpY2FsLGRlbHRhOkF9fSl9bWFrZUdhbWVwYWRJbnB1dEV2ZW50KEEpe3ZhciBJLGcsZSxCLGksUSx0LEMsRSxvLGEsbixzLHIsZCxoLGMsRCx3LHksdSxsLFMsRixSLEcsayxVLE4sbSxwLGYsTSxMLEgsSyxxLEo7cmV0dXJue2lkOkEuaWQsaW5kZXg6QS5pbmRleCxidXR0b25zOnthOm51bGwhPT0oZz1udWxsPT09KEk9QS5idXR0b25zWzBdKXx8dm9pZCAwPT09ST92b2lkIDA6SS52YWx1ZSkmJnZvaWQgMCE9PWc/ZzowLGI6bnVsbCE9PShCPW51bGw9PT0oZT1BLmJ1dHRvbnNbMV0pfHx2b2lkIDA9PT1lP3ZvaWQgMDplLnZhbHVlKSYmdm9pZCAwIT09Qj9COjAseDpudWxsIT09KFE9bnVsbD09PShpPUEuYnV0dG9uc1syXSl8fHZvaWQgMD09PWk/dm9pZCAwOmkudmFsdWUpJiZ2b2lkIDAhPT1RP1E6MCx5Om51bGwhPT0oQz1udWxsPT09KHQ9QS5idXR0b25zWzNdKXx8dm9pZCAwPT09dD92b2lkIDA6dC52YWx1ZSkmJnZvaWQgMCE9PUM/QzowLGxlZnRTaG91bGRlcjpudWxsIT09KG89bnVsbD09PShFPUEuYnV0dG9uc1s0XSl8fHZvaWQgMD09PUU/dm9pZCAwOkUudmFsdWUpJiZ2b2lkIDAhPT1vP286MCxyaWdodFNob3VsZGVyOm51bGwhPT0obj1udWxsPT09KGE9QS5idXR0b25zWzVdKXx8dm9pZCAwPT09YT92b2lkIDA6YS52YWx1ZSkmJnZvaWQgMCE9PW4/bjowLGxlZnRUcmlnZ2VyOm51bGwhPT0ocj1udWxsPT09KHM9QS5idXR0b25zWzZdKXx8dm9pZCAwPT09cz92b2lkIDA6cy52YWx1ZSkmJnZvaWQgMCE9PXI/cjowLHJpZ2h0VHJpZ2dlcjpudWxsIT09KGg9bnVsbD09PShkPUEuYnV0dG9uc1s3XSl8fHZvaWQgMD09PWQ/dm9pZCAwOmQudmFsdWUpJiZ2b2lkIDAhPT1oP2g6MCxzZWxlY3Q6bnVsbCE9PShEPW51bGw9PT0oYz1BLmJ1dHRvbnNbOF0pfHx2b2lkIDA9PT1jP3ZvaWQgMDpjLnZhbHVlKSYmdm9pZCAwIT09RD9EOjAsc3RhcnQ6bnVsbCE9PSh5PW51bGw9PT0odz1BLmJ1dHRvbnNbOV0pfHx2b2lkIDA9PT13P3ZvaWQgMDp3LnZhbHVlKSYmdm9pZCAwIT09eT95OjAsbGVmdFN0aWNrUHJlc3NlZDpudWxsIT09KGw9bnVsbD09PSh1PUEuYnV0dG9uc1sxMF0pfHx2b2lkIDA9PT11P3ZvaWQgMDp1LnZhbHVlKSYmdm9pZCAwIT09bD9sOjAscmlnaHRTdGlja1ByZXNzZWQ6bnVsbCE9PShGPW51bGw9PT0oUz1BLmJ1dHRvbnNbMTFdKXx8dm9pZCAwPT09Uz92b2lkIDA6Uy52YWx1ZSkmJnZvaWQgMCE9PUY/RjowLGRwYWRVcDpudWxsIT09KEc9bnVsbD09PShSPUEuYnV0dG9uc1sxMl0pfHx2b2lkIDA9PT1SP3ZvaWQgMDpSLnZhbHVlKSYmdm9pZCAwIT09Rz9HOjAsZHBhZERvd246bnVsbCE9PShVPW51bGw9PT0oaz1BLmJ1dHRvbnNbMTNdKXx8dm9pZCAwPT09az92b2lkIDA6ay52YWx1ZSkmJnZvaWQgMCE9PVU/VTowLGRwYWRMZWZ0Om51bGwhPT0obT1udWxsPT09KE49QS5idXR0b25zWzE0XSl8fHZvaWQgMD09PU4/dm9pZCAwOk4udmFsdWUpJiZ2b2lkIDAhPT1tP206MCxkcGFkUmlnaHQ6bnVsbCE9PShmPW51bGw9PT0ocD1BLmJ1dHRvbnNbMTVdKXx8dm9pZCAwPT09cD92b2lkIDA6cC52YWx1ZSkmJnZvaWQgMCE9PWY/ZjowLGhvbWU6bnVsbCE9PShMPW51bGw9PT0oTT1BLmJ1dHRvbnNbMTZdKXx8dm9pZCAwPT09TT92b2lkIDA6TS52YWx1ZSkmJnZvaWQgMCE9PUw/TDowfSxzdGlja3M6e2xlZnQ6e3g6bnVsbCE9PShIPUEuYXhlc1swXSkmJnZvaWQgMCE9PUg/SDowLHk6bnVsbCE9PShLPUEuYXhlc1sxXSkmJnZvaWQgMCE9PUs/SzowfSxyaWdodDp7eDpudWxsIT09KHE9QS5heGVzWzJdKSYmdm9pZCAwIT09cT9xOjAseTpudWxsIT09KEo9QS5heGVzWzNdKSYmdm9pZCAwIT09Sj9KOjB9fX19ZmVlZEdhbWVwYWRJbnB1dEV2ZW50KEEpe3RoaXMucmVwb3J0R2FtZXBhZEV2ZW50cyhBKX1zdGF0aWMgdmlicmF0ZUdhbWVwYWQoQSxJKXt2YXIgZyxlO2NvbnN0IEI9bmF2aWdhdG9yLmdldEdhbWVwYWRzKClbQV07aWYobnVsbD09Qj92b2lkIDA6Qi52aWJyYXRpb25BY3R1YXRvciludWxsPT09KGU9KGc9Qi52aWJyYXRpb25BY3R1YXRvcikucGxheUVmZmVjdCl8fHZvaWQgMD09PWV8fGUuY2FsbChnLFwiZHVhbC1ydW1ibGVcIixJKTtlbHNlIGlmKG51bGw9PUI/dm9pZCAwOkIuaGFwdGljQWN0dWF0b3JzKXtjb25zdCBBPW51bGw9PUI/dm9pZCAwOkIuaGFwdGljQWN0dWF0b3JzO3NldFRpbWVvdXQoKCgpPT57dmFyIGcsZSxCO2Zvcihjb25zdCBpIG9mIEEpaWYoXCJwdWxzZVwiaW4gaSl7Y29uc3QgQT1NYXRoLm1heChudWxsIT09KGc9SS5zdHJvbmdNYWduaXR1ZGUpJiZ2b2lkIDAhPT1nP2c6MCxudWxsIT09KGU9SS53ZWFrTWFnbml0dWRlKSYmdm9pZCAwIT09ZT9lOjApO2kucHVsc2UoQSxudWxsIT09KEI9SS5kdXJhdGlvbikmJnZvaWQgMCE9PUI/QjowKX19KSxJLnN0YXJ0RGVsYXkpfX1mZWVkS2V5Ym9hcmRFdmVudChBKXt0aGlzLm9uS2V5Ym9hcmRFdmVudChBKX1yZWxlYXNlS2V5cygpe2Zvcihjb25zdCBBIG9mIHRoaXMuaGVsZENvZGVzKXRoaXMub25LZXlib2FyZEV2ZW50KG5ldyBLZXlib2FyZEV2ZW50KFwia2V5dXBcIix7Y29kZTpBfSkpO3RoaXMuaGVsZENvZGVzLmNsZWFyKCl9ZmVlZFBvaW50ZXJFdmVudChBKXt0aGlzLm9uUG9pbnRlckV2ZW50KEEpfWZlZWRXaGVlbEV2ZW50KEEpe3RoaXMub25XaGVlbEV2ZW50KEEpfXByb2Nlc3NDdXJzb3IoQSl7dGhpcy5jdXJzb3JQYWludGVyLnByb2Nlc3NDdXJzb3IoQSl9ZW5hYmxlR2VzdHVyZXMoKXt0aGlzLm9wdGlvbnMudG91Y2hHZXN0dXJlcz0hMH1kaXNhYmxlR2VzdHVyZXMoKXt0aGlzLm9wdGlvbnMudG91Y2hHZXN0dXJlcz0hMX1zZW5kTW91c2VNb3ZlKEEsSSxnKXtcImFic29sdXRlXCI9PT1BP3RoaXMuc2VuZElucHV0RGF0YWdyYW0oe2Rpc2NyaW1pbmF0b3I6RS5Nb3VzZUFic29sdXRlLmRpc2NyaW1pbmF0b3IsdmFsdWU6e3g6SSx5Omd9fSk6dGhpcy5zZW5kSW5wdXREYXRhZ3JhbSh7ZGlzY3JpbWluYXRvcjpFLk1vdXNlUmVsYXRpdmUuZGlzY3JpbWluYXRvcix2YWx1ZTp7ZHg6SSxkeTpnfX0pfXNlbmRNb3VzZUNsaWNrKEEpe3RoaXMuc2VuZElucHV0RGF0YWdyYW0oe2Rpc2NyaW1pbmF0b3I6RS5Nb3VzZUNsaWNrLmRpc2NyaW1pbmF0b3IsdmFsdWU6QX0pfXNlbmRJbnB1dERhdGFncmFtKEEpe3RoaXMucmFpbndheVN0cmVhbS5zZW5kSW5wdXQoQSl9ZGlzcG9zZSgpe3RoaXMudW5zZXRDb250YWluZXIoKX19fSw0MDooQSxJLGcpPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KEksXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksSS5SYWlud2F5VmlydHVhbEtleUZyb21XZWJLZXlDb2RlPXZvaWQgMDtjb25zdCBlPWcoOTA0KTtJLlJhaW53YXlWaXJ0dWFsS2V5RnJvbVdlYktleUNvZGU9e1VuaWRlbnRpZmllZDplLlZpcnR1YWxLZXkuTm9uZSxDYW5jZWw6ZS5WaXJ0dWFsS2V5LkNhbmNlbCxCYWNrc3BhY2U6ZS5WaXJ0dWFsS2V5LkJhY2ssVGFiOmUuVmlydHVhbEtleS5UYWIsRW50ZXI6ZS5WaXJ0dWFsS2V5LkVudGVyLFBhdXNlOmUuVmlydHVhbEtleS5QYXVzZSxDYXBzTG9jazplLlZpcnR1YWxLZXkuQ2Fwc0xvY2ssSGFuZ3VsTW9kZTplLlZpcnR1YWxLZXkuSGFuZ3VsTW9kZSxLYW5hTW9kZTplLlZpcnR1YWxLZXkuSGFuZ3VsTW9kZSxMYW5nMTplLlZpcnR1YWxLZXkuSGFuZ3VsTW9kZSxIYW5qYTplLlZpcnR1YWxLZXkuSGFuamFNb2RlLExhbmcyOmUuVmlydHVhbEtleS5IYW5qYU1vZGUsRXNjYXBlOmUuVmlydHVhbEtleS5Fc2NhcGUsQ29udmVydDplLlZpcnR1YWxLZXkuSW1lQ29udmVydCxOb25Db252ZXJ0OmUuVmlydHVhbEtleS5JbWVOb25Db252ZXJ0LFNwYWNlOmUuVmlydHVhbEtleS5TcGFjZSxcIiBcIjplLlZpcnR1YWxLZXkuU3BhY2UsU3BhY2ViYXI6ZS5WaXJ0dWFsS2V5LlNwYWNlLFBhZ2VVcDplLlZpcnR1YWxLZXkuUGFnZVVwLFBhZ2VEb3duOmUuVmlydHVhbEtleS5QYWdlRG93bixFbmQ6ZS5WaXJ0dWFsS2V5LkVuZCxIb21lOmUuVmlydHVhbEtleS5Ib21lLEFycm93TGVmdDplLlZpcnR1YWxLZXkuTGVmdCxBcnJvd1VwOmUuVmlydHVhbEtleS5VcCxBcnJvd1JpZ2h0OmUuVmlydHVhbEtleS5SaWdodCxBcnJvd0Rvd246ZS5WaXJ0dWFsS2V5LkRvd24sU2VsZWN0OmUuVmlydHVhbEtleS5TZWxlY3QsUHJpbnRTY3JlZW46ZS5WaXJ0dWFsS2V5LlByaW50U2NyZWVuLEluc2VydDplLlZpcnR1YWxLZXkuSW5zZXJ0LERlbGV0ZTplLlZpcnR1YWxLZXkuRGVsZXRlLEhlbHA6ZS5WaXJ0dWFsS2V5LkhlbHAsRGlnaXQwOmUuVmlydHVhbEtleS5EMCxEaWdpdDE6ZS5WaXJ0dWFsS2V5LkQxLERpZ2l0MjplLlZpcnR1YWxLZXkuRDIsRGlnaXQzOmUuVmlydHVhbEtleS5EMyxEaWdpdDQ6ZS5WaXJ0dWFsS2V5LkQ0LERpZ2l0NTplLlZpcnR1YWxLZXkuRDUsRGlnaXQ2OmUuVmlydHVhbEtleS5ENixEaWdpdDc6ZS5WaXJ0dWFsS2V5LkQ3LERpZ2l0ODplLlZpcnR1YWxLZXkuRDgsRGlnaXQ5OmUuVmlydHVhbEtleS5EOSxLZXlBOmUuVmlydHVhbEtleS5BLEtleUI6ZS5WaXJ0dWFsS2V5LkIsS2V5QzplLlZpcnR1YWxLZXkuQyxLZXlEOmUuVmlydHVhbEtleS5ELEtleUU6ZS5WaXJ0dWFsS2V5LkUsS2V5RjplLlZpcnR1YWxLZXkuRixLZXlHOmUuVmlydHVhbEtleS5HLEtleUg6ZS5WaXJ0dWFsS2V5LkgsS2V5STplLlZpcnR1YWxLZXkuSSxLZXlKOmUuVmlydHVhbEtleS5KLEtleUs6ZS5WaXJ0dWFsS2V5LkssS2V5TDplLlZpcnR1YWxLZXkuTCxLZXlNOmUuVmlydHVhbEtleS5NLEtleU46ZS5WaXJ0dWFsS2V5Lk4sS2V5TzplLlZpcnR1YWxLZXkuTyxLZXlQOmUuVmlydHVhbEtleS5QLEtleVE6ZS5WaXJ0dWFsS2V5LlEsS2V5UjplLlZpcnR1YWxLZXkuUixLZXlTOmUuVmlydHVhbEtleS5TLEtleVQ6ZS5WaXJ0dWFsS2V5LlQsS2V5VTplLlZpcnR1YWxLZXkuVSxLZXlWOmUuVmlydHVhbEtleS5WLEtleVc6ZS5WaXJ0dWFsS2V5LlcsS2V5WDplLlZpcnR1YWxLZXkuWCxLZXlZOmUuVmlydHVhbEtleS5ZLEtleVo6ZS5WaXJ0dWFsS2V5LlosTWV0YUxlZnQ6ZS5WaXJ0dWFsS2V5LkxXaW4sT1NMZWZ0OmUuVmlydHVhbEtleS5MV2luLE1ldGFSaWdodDplLlZpcnR1YWxLZXkuUldpbixPU1JpZ2h0OmUuVmlydHVhbEtleS5SV2luLENvbnRleHRNZW51OmUuVmlydHVhbEtleS5BcHBzLFNsZWVwOmUuVmlydHVhbEtleS5TbGVlcCxOdW1wYWQwOmUuVmlydHVhbEtleS5OdW1QYWQwLE51bXBhZDE6ZS5WaXJ0dWFsS2V5Lk51bVBhZDEsTnVtcGFkMjplLlZpcnR1YWxLZXkuTnVtUGFkMixOdW1wYWQzOmUuVmlydHVhbEtleS5OdW1QYWQzLE51bXBhZDQ6ZS5WaXJ0dWFsS2V5Lk51bVBhZDQsTnVtcGFkNTplLlZpcnR1YWxLZXkuTnVtUGFkNSxOdW1wYWQ2OmUuVmlydHVhbEtleS5OdW1QYWQ2LE51bXBhZDc6ZS5WaXJ0dWFsS2V5Lk51bVBhZDcsTnVtcGFkODplLlZpcnR1YWxLZXkuTnVtUGFkOCxOdW1wYWQ5OmUuVmlydHVhbEtleS5OdW1QYWQ5LE51bXBhZE11bHRpcGx5OmUuVmlydHVhbEtleS5NdWx0aXBseSxOdW1wYWRBZGQ6ZS5WaXJ0dWFsS2V5LkFkZCxOdW1wYWRDb21tYTplLlZpcnR1YWxLZXkuU2VwYXJhdG9yLE51bXBhZFN1YnRyYWN0OmUuVmlydHVhbEtleS5TdWJ0cmFjdCxOdW1wYWREZWNpbWFsOmUuVmlydHVhbEtleS5EZWNpbWFsLE51bXBhZERpdmlkZTplLlZpcnR1YWxLZXkuRGl2aWRlLEYxOmUuVmlydHVhbEtleS5GMSxGMjplLlZpcnR1YWxLZXkuRjIsRjM6ZS5WaXJ0dWFsS2V5LkYzLEY0OmUuVmlydHVhbEtleS5GNCxGNTplLlZpcnR1YWxLZXkuRjUsRjY6ZS5WaXJ0dWFsS2V5LkY2LEY3OmUuVmlydHVhbEtleS5GNyxGODplLlZpcnR1YWxLZXkuRjgsRjk6ZS5WaXJ0dWFsS2V5LkY5LEYxMDplLlZpcnR1YWxLZXkuRjEwLEYxMTplLlZpcnR1YWxLZXkuRjExLEYxMjplLlZpcnR1YWxLZXkuRjEyLEYxMzplLlZpcnR1YWxLZXkuRjEzLEYxNDplLlZpcnR1YWxLZXkuRjE0LEYxNTplLlZpcnR1YWxLZXkuRjE1LEYxNjplLlZpcnR1YWxLZXkuRjE2LEYxNzplLlZpcnR1YWxLZXkuRjE3LEYxODplLlZpcnR1YWxLZXkuRjE4LEYxOTplLlZpcnR1YWxLZXkuRjE5LEYyMDplLlZpcnR1YWxLZXkuRjIwLEYyMTplLlZpcnR1YWxLZXkuRjIxLEYyMjplLlZpcnR1YWxLZXkuRjIyLEYyMzplLlZpcnR1YWxLZXkuRjIzLEYyNDplLlZpcnR1YWxLZXkuRjI0LE51bUxvY2s6ZS5WaXJ0dWFsS2V5Lk51bUxvY2ssU2Nyb2xsTG9jazplLlZpcnR1YWxLZXkuU2Nyb2xsLFNoaWZ0TGVmdDplLlZpcnR1YWxLZXkuTGVmdFNoaWZ0LFNoaWZ0UmlnaHQ6ZS5WaXJ0dWFsS2V5LlJpZ2h0U2hpZnQsQ29udHJvbExlZnQ6ZS5WaXJ0dWFsS2V5LkxlZnRDdHJsLENvbnRyb2xSaWdodDplLlZpcnR1YWxLZXkuUmlnaHRDdHJsLEFsdExlZnQ6ZS5WaXJ0dWFsS2V5LkxlZnRBbHQsQWx0UmlnaHQ6ZS5WaXJ0dWFsS2V5LlJpZ2h0QWx0LEJyb3dzZXJCYWNrOmUuVmlydHVhbEtleS5Ccm93c2VyQmFjayxCcm93c2VyRm9yd2FyZDplLlZpcnR1YWxLZXkuQnJvd3NlckZvcndhcmQsQnJvd3NlclJlZnJlc2g6ZS5WaXJ0dWFsS2V5LkJyb3dzZXJSZWZyZXNoLEJyb3dzZXJTdG9wOmUuVmlydHVhbEtleS5Ccm93c2VyU3RvcCxCcm93c2VyU2VhcmNoOmUuVmlydHVhbEtleS5Ccm93c2VyU2VhcmNoLEJyb3dzZXJGYXZvcml0ZXM6ZS5WaXJ0dWFsS2V5LkJyb3dzZXJGYXZvcml0ZXMsQnJvd3NlckhvbWU6ZS5WaXJ0dWFsS2V5LkJyb3dzZXJIb21lLEF1ZGlvVm9sdW1lTXV0ZTplLlZpcnR1YWxLZXkuVm9sdW1lTXV0ZSxBdWRpb1ZvbHVtZURvd246ZS5WaXJ0dWFsS2V5LlZvbHVtZURvd24sQXVkaW9Wb2x1bWVVcDplLlZpcnR1YWxLZXkuVm9sdW1lVXAsTWVkaWFUcmFja05leHQ6ZS5WaXJ0dWFsS2V5Lk1lZGlhTmV4dFRyYWNrLE1lZGlhVHJhY2tQcmV2aW91czplLlZpcnR1YWxLZXkuTWVkaWFQcmV2aW91c1RyYWNrLE1lZGlhU3RvcDplLlZpcnR1YWxLZXkuTWVkaWFTdG9wLE1lZGlhUGxheVBhdXNlOmUuVmlydHVhbEtleS5NZWRpYVBsYXlQYXVzZSxMYXVuY2hNYWlsOmUuVmlydHVhbEtleS5MYXVuY2hNYWlsLExhdW5jaE1lZGlhUGxheWVyOmUuVmlydHVhbEtleS5TZWxlY3RNZWRpYSxNZWRpYVNlbGVjdDplLlZpcnR1YWxLZXkuU2VsZWN0TWVkaWEsTGF1bmNoQXBwMTplLlZpcnR1YWxLZXkuTGF1bmNoQXBwbGljYXRpb24xLExhdW5jaEFwcDI6ZS5WaXJ0dWFsS2V5LkxhdW5jaEFwcGxpY2F0aW9uMixTZW1pY29sb246ZS5WaXJ0dWFsS2V5Lk9lbTEsRXF1YWw6ZS5WaXJ0dWFsS2V5Lk9lbVBsdXMsQ29tbWE6ZS5WaXJ0dWFsS2V5Lk9lbUNvbW1hLE1pbnVzOmUuVmlydHVhbEtleS5PZW1NaW51cyxQZXJpb2Q6ZS5WaXJ0dWFsS2V5Lk9lbVBlcmlvZCxTbGFzaDplLlZpcnR1YWxLZXkuT2VtMixCYWNrcXVvdGU6ZS5WaXJ0dWFsS2V5Lk9lbTMsQnJhY2tldExlZnQ6ZS5WaXJ0dWFsS2V5Lk9lbTQsQmFja3NsYXNoOmUuVmlydHVhbEtleS5PZW01LEJyYWNrZXRSaWdodDplLlZpcnR1YWxLZXkuT2VtNixRdW90ZTplLlZpcnR1YWxLZXkuT2VtNyxJbnRsQmFja3NsYXNoOmUuVmlydHVhbEtleS5PZW0xMDJ9fSw0NjQ6KEEsSSk9PntcInVzZSBzdHJpY3RcIjt2YXIgZztPYmplY3QuZGVmaW5lUHJvcGVydHkoSSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxJLlJhaW53YXlMb2dnaW5nPUkuUmFpbndheUxvZ0xldmVsPXZvaWQgMCxmdW5jdGlvbihBKXtBW0EuVHJhY2U9MF09XCJUcmFjZVwiLEFbQS5EZWJ1Zz0xXT1cIkRlYnVnXCIsQVtBLkluZm9ybWF0aW9uPTJdPVwiSW5mb3JtYXRpb25cIixBW0EuV2FybmluZz0zXT1cIldhcm5pbmdcIixBW0EuRXJyb3I9NF09XCJFcnJvclwiLEFbQS5Dcml0aWNhbD01XT1cIkNyaXRpY2FsXCIsQVtBLlNpbGVudD02XT1cIlNpbGVudFwifShnPUkuUmFpbndheUxvZ0xldmVsfHwoSS5SYWlud2F5TG9nTGV2ZWw9e30pKTtjbGFzcyBle3N0YXRpYyBzZXRMb2dTaW5rKEEpe2UuX2xvZ1Npbms9QX1zdGF0aWMgbG9nKEEsSSl7dmFyIGc7bnVsbD09PShnPWUuX2xvZ1NpbmspfHx2b2lkIDA9PT1nfHxnLmNhbGwoZSxBLEkpfX1JLlJhaW53YXlMb2dnaW5nPWUsZS50cmFjZT1BPT5lLmxvZyhnLlRyYWNlLEEpLGUuZGVidWc9QT0+ZS5sb2coZy5EZWJ1ZyxBKSxlLmluZm9ybWF0aW9uPUE9PmUubG9nKGcuSW5mb3JtYXRpb24sQSksZS53YXJuaW5nPUE9PmUubG9nKGcuV2FybmluZyxBKSxlLmVycm9yPUE9PmUubG9nKGcuRXJyb3IsQSksZS5jcml0aWNhbD1BPT5lLmxvZyhnLkNyaXRpY2FsLEEpfSw1ODU6ZnVuY3Rpb24oQSxJLGcpe1widXNlIHN0cmljdFwiO3ZhciBlPXRoaXMmJnRoaXMuX19hd2FpdGVyfHxmdW5jdGlvbihBLEksZyxlKXtyZXR1cm4gbmV3KGd8fChnPVByb21pc2UpKSgoZnVuY3Rpb24oQixpKXtmdW5jdGlvbiBRKEEpe3RyeXtDKGUubmV4dChBKSl9Y2F0Y2goQSl7aShBKX19ZnVuY3Rpb24gdChBKXt0cnl7QyhlLnRocm93KEEpKX1jYXRjaChBKXtpKEEpfX1mdW5jdGlvbiBDKEEpe3ZhciBJO0EuZG9uZT9CKEEudmFsdWUpOihJPUEudmFsdWUsSSBpbnN0YW5jZW9mIGc/STpuZXcgZygoZnVuY3Rpb24oQSl7QShJKX0pKSkudGhlbihRLHQpfUMoKGU9ZS5hcHBseShBLEl8fFtdKSkubmV4dCgpKX0pKX0sQj10aGlzJiZ0aGlzLl9faW1wb3J0RGVmYXVsdHx8ZnVuY3Rpb24oQSl7cmV0dXJuIEEmJkEuX19lc01vZHVsZT9BOntkZWZhdWx0OkF9fTtPYmplY3QuZGVmaW5lUHJvcGVydHkoSSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxJLkF1ZGlvU3RyZWFtPXZvaWQgMDtjb25zdCBpPUIoZyg1MykpLFE9Zyg5OTQpLHQ9Zyg0NjQpO0kuQXVkaW9TdHJlYW09Y2xhc3N7Y29uc3RydWN0b3IoKXt0aGlzLnNhbXBsZVJhdGVIej00OGUzLHRoaXMuc2FtcGxlUmF0ZUtoej00OCx0aGlzLmNoYW5uZWxDb3VudD0yLHRoaXMuZGVjb2RlZENvdW50PTAsdGhpcy50b3RhbFNhbXBsZXNEZWNvZGVkPTAsdGhpcy53YWl0aW5nVG9EZWNvZGVRdWV1ZT1bXSx0aGlzLmRlY29kZVF1ZXVlU2l6ZT0wLHRoaXMubG9nUGVyZm9ybWFuY2U9ITEsdGhpcy5tYXhEZWNvZGluZ1RpbWVNcz0wLHRoaXMudG90YWxEZWNvZGluZ1RpbWVNcz0wLHRoaXMudG90YWxRdWV1ZWRTaXplPTAsdGhpcy5tYXhRdWV1ZWRTaXplPTAsdGhpcy5zdGFydFN0cmVhbVRpbWVNcz0wLHRoaXMub3V0cHV0QnVmZmVycz1bXSx0aGlzLmN1cnJlbnRPdXRwdXRCdWZmZXI9dm9pZCAwLHRoaXMuY3VycmVudEJ1ZmZlclJlYWRJbmRleD0wLHRoaXMubmV4dFN0YXJ0VGltZT12b2lkIDAsdGhpcy5wbGF5aW5nPSExLHRoaXMuZGF0YUR1cmF0aW9uTXM9MTAsdGhpcy5taW5MYXRlbmN5TXM9NjAsdGhpcy5tYXhMYXRlbmN5TXM9MTAwLHRoaXMucHJldkRyb3BwZWRGcmFtZVRpbWVNcz12b2lkIDAsdGhpcy5kZWNvZGVkU2FtcGxlc1BlckZyYW1lPTAsdGhpcy5hdWRpb0J1ZmZlclNpemU9MCx0aGlzLmF1ZGlvQnVmZmVyUG9vbD1bXSx0aGlzLm1heEF1ZGlvQnVmZmVyUG9vbENvdW50PTUsdGhpcy5yZXNhbXBsZWRBdWRpb0J1ZmZlclNpemU9MCx0aGlzLm9uRGVjb2RlPSh7c3RhcnRUaW1lc3RhbXA6QSxvdXRwdXREYXRhOkksc2FtcGxlc0RlY29kZWQ6Z30pPT57LS10aGlzLmRlY29kZVF1ZXVlU2l6ZTtjb25zdCBlPW5ldyBGbG9hdDMyQXJyYXkoSSk7dGhpcy5vdXRwdXRCdWZmZXJzLnB1c2goZSk7dHJ5e2lmKGc+MCYmKCsrdGhpcy5kZWNvZGVkQ291bnQsdGhpcy50b3RhbFNhbXBsZXNEZWNvZGVkKz1nLHRoaXMubG9nUGVyZm9ybWFuY2UmJnRoaXMubG9nUGVyZlRpbWluZyhBKSx0aGlzLnRvdGFsU2FtcGxlc0RlY29kZWQ+PXRoaXMuYXVkaW9CdWZmZXJTaXplJiYodGhpcy5uZXh0U3RhcnRUaW1lJiZ0aGlzLm5leHRTdGFydFRpbWU8dGhpcy5hdWRpb0NvbnRleHQuY3VycmVudFRpbWUmJih0aGlzLm5leHRTdGFydFRpbWU9dm9pZCAwKSx0aGlzLm5leHRTdGFydFRpbWV8fHRoaXMudG90YWxTYW1wbGVzRGVjb2RlZD49Mip0aGlzLmF1ZGlvQnVmZmVyU2l6ZSkpKXtjb25zdCBBPU1hdGguZmxvb3IodGhpcy50b3RhbFNhbXBsZXNEZWNvZGVkL3RoaXMuYXVkaW9CdWZmZXJTaXplKTtmb3IobGV0IEk9MDtJPEE7KytJKXtjb25zdCBBPXRoaXMubmV4dFN0YXJ0VGltZT8xZTMqKHRoaXMubmV4dFN0YXJ0VGltZS10aGlzLmF1ZGlvQ29udGV4dC5jdXJyZW50VGltZSk6MDtpZihBPnRoaXMubWF4TGF0ZW5jeU1zKXtsZXQgST0wO2NvbnN0IGc9RGF0ZS5ub3coKSxlPXRoaXMucHJldkRyb3BwZWRGcmFtZVRpbWVNcz9nLXRoaXMucHJldkRyb3BwZWRGcmFtZVRpbWVNczp2b2lkIDAsQj0xZTQ7aWYoZSYmZTxCKUk9dGhpcy5kcm9wRGVjb2RlZFNhbXBsZXModGhpcy50b3RhbFNhbXBsZXNEZWNvZGVkKTtlbHNle2NvbnN0IGc9QS10aGlzLm1heExhdGVuY3lNcyt0aGlzLmRhdGFEdXJhdGlvbk1zLGU9TWF0aC5mbG9vcih0aGlzLnNhbXBsZVJhdGVLaHoqZyk7ST10aGlzLmRyb3BEZWNvZGVkU2FtcGxlcyhlKX10aGlzLnByZXZEcm9wcGVkRnJhbWVUaW1lTXM9Zyx0aGlzLnRvdGFsU2FtcGxlc0RlY29kZWQtPUl9aWYoISh0aGlzLnRvdGFsU2FtcGxlc0RlY29kZWQ+PXRoaXMuYXVkaW9CdWZmZXJTaXplKSlicmVhazt7Y29uc3QgQT10aGlzLmNvcHlEZWNvZGVkU2FtcGxlc1RvQXVkaW9CdWZmZXIoKTt0aGlzLnNjaGVkdWxlQnVmZmVyRm9yUGxheWJhY2tGdW5jKEEpLHRoaXMudG90YWxTYW1wbGVzRGVjb2RlZC09QS5sZW5ndGh9fX19Y2F0Y2goQSl7dC5SYWlud2F5TG9nZ2luZy53YXJuaW5nKFwiQ2F1Z2h0IGV4Y2VwdGlvbiBpbiBBdWRpb1N0cmVhbSBvbkRlY29kZTogXCIrQStcIiBcIitBLnN0YWNrKSx0aGlzLnN0b3AoKSx0aGlzLnBsYXkoKX10aGlzLnNlbmREZWNvZGVyV2FpdGluZ1RvRGVjb2RlRnJhbWVzKCl9fWluaXRpYWxpemUoKXtyZXR1cm4gZSh0aGlzLHZvaWQgMCx2b2lkIDAsKGZ1bmN0aW9uKigpe3RoaXMub3B1c0RlY29kZXJXb3JrZXI9bmV3IGkuZGVmYXVsdCx5aWVsZCB0aGlzLm9wdXNEZWNvZGVyV29ya2VyLmluaXRpYWxpemUoKSx0aGlzLm9wdXNEZWNvZGVyV29ya2VyLm9uRGVjb2RlPXRoaXMub25EZWNvZGUuYmluZCh0aGlzKX0pKX1kaXNwb3NlKCl7dmFyIEE7bnVsbD09PShBPXRoaXMub3B1c0RlY29kZXJXb3JrZXIpfHx2b2lkIDA9PT1BfHxBLmRpc3Bvc2UoKSx0aGlzLm9wdXNEZWNvZGVyV29ya2VyPXZvaWQgMH1jb25maWd1cmUoe2F1ZGlvQ29udGV4dDpBLHNhbXBsZVJhdGVIejpJLGNoYW5uZWxDb3VudDpnLGRhdGFEdXJhdGlvbk1zOmUsbWluTGF0ZW5jeU1zOkIsbWF4TGF0ZW5jeU1zOml9KXtpZih0aGlzLnNhbXBsZVJhdGVIej1udWxsIT1JP0k6dGhpcy5zYW1wbGVSYXRlSHosOGUzIT10aGlzLnNhbXBsZVJhdGVIeiYmMTJlMyE9dGhpcy5zYW1wbGVSYXRlSHomJjE2ZTMhPXRoaXMuc2FtcGxlUmF0ZUh6JiYyNGUzIT10aGlzLnNhbXBsZVJhdGVIeiYmNDhlMyE9dGhpcy5zYW1wbGVSYXRlSHopdGhyb3cgbmV3IFEuUmFpbndheUVycm9yKGBpbnZhbGlkIGF1ZGlvIHNhbXBsZSByYXRlOiAke3RoaXMuc2FtcGxlUmF0ZUh6fSAobXVzdCBiZSA4MDAwLCAxMjAwMCwgMTYwMDAsIDI0MDAwLCBvciA0ODAwMClgKTtpZih0aGlzLnNhbXBsZVJhdGVLaHo9dGhpcy5zYW1wbGVSYXRlSHovMWUzLHRoaXMuY2hhbm5lbENvdW50PW51bGwhPWc/Zzp0aGlzLmNoYW5uZWxDb3VudCwxIT10aGlzLmNoYW5uZWxDb3VudCYmMiE9dGhpcy5jaGFubmVsQ291bnQmJjYhPXRoaXMuY2hhbm5lbENvdW50KXRocm93IG5ldyBRLlJhaW53YXlFcnJvcihgaW52YWxpZCBjaGFubmVsIGNvdW50OiAke3RoaXMuY2hhbm5lbENvdW50fSAobXVzdCBiZSAxLCAyLCBvciA2KWApO2lmKHRoaXMuZGF0YUR1cmF0aW9uTXM9bnVsbCE9ZT9lOnRoaXMuZGF0YUR1cmF0aW9uTXMsdGhpcy5taW5MYXRlbmN5TXM9bnVsbCE9Qj9COnRoaXMubWluTGF0ZW5jeU1zLHRoaXMubWF4TGF0ZW5jeU1zPW51bGwhPWk/aTp0aGlzLm1heExhdGVuY3lNcyx0aGlzLmRhdGFEdXJhdGlvbk1zPD0wKXRocm93IG5ldyBRLlJhaW53YXlFcnJvcihgZGF0YUR1cmF0aW9uTXMgbXVzdCBiZSBwb3NpdGl2ZSwgYnV0IGlzICR7dGhpcy5kYXRhRHVyYXRpb25Nc31gKTtpZih0aGlzLmRhdGFEdXJhdGlvbk1zPnRoaXMubWluTGF0ZW5jeU1zKXRocm93IG5ldyBRLlJhaW53YXlFcnJvcihcImRhdGFEdXJhdGlvbk1zIG1heSBub3QgZXhjZWVkIG1pbkxhdGVuY3lNc1wiKTtpZih0aGlzLm1heExhdGVuY3lNczw9dGhpcy5taW5MYXRlbmN5TXMpdGhyb3cgbmV3IFEuUmFpbndheUVycm9yKFwibWF4TGF0ZW5jeU1zIG11c3QgYmUgZ3JlYXRlciB0aGFuIG1pbkxhdGVuY3lNc1wiKTt0aGlzLmRlY29kZWRTYW1wbGVzUGVyRnJhbWU9dGhpcy5kYXRhRHVyYXRpb25Ncyp0aGlzLnNhbXBsZVJhdGVLaHosdGhpcy5jdXJyZW50T3V0cHV0QnVmZmVyPXZvaWQgMCx0aGlzLmN1cnJlbnRCdWZmZXJSZWFkSW5kZXg9MDtjb25zdCBDPXRoaXMuc2FtcGxlUmF0ZUtoeip0aGlzLm1pbkxhdGVuY3lNczt0aGlzLmF1ZGlvQnVmZmVyU2l6ZT1NYXRoLmZsb29yKEMvMiksbnVsbD09QT8odGhpcy5hdWRpb0NvbnRleHQ9bmV3KHdpbmRvdy5BdWRpb0NvbnRleHR8fHdpbmRvdy53ZWJraXRBdWRpb0NvbnRleHQpKHtsYXRlbmN5SGludDpcImludGVyYWN0aXZlXCIsc2FtcGxlUmF0ZTp0aGlzLnNhbXBsZVJhdGVIen0pLHRoaXMuYXVkaW9Db250ZXh0LmNyZWF0ZUJ1ZmZlclNvdXJjZSgpKTp0aGlzLmF1ZGlvQ29udGV4dD1BLHRoaXMudm9sdW1lTm9kZT10aGlzLmF1ZGlvQ29udGV4dC5jcmVhdGVHYWluKCksdGhpcy52b2x1bWVOb2RlLmNvbm5lY3QodGhpcy5hdWRpb0NvbnRleHQuZGVzdGluYXRpb24pLHRoaXMuYXVkaW9Db250ZXh0LnJlc3VtZSgpLFwic3VzcGVuZGVkXCI9PXRoaXMuYXVkaW9Db250ZXh0LnN0YXRlJiZ0LlJhaW53YXlMb2dnaW5nLmluZm9ybWF0aW9uKFwiQXVkaW9Db250ZXh0IGlzIHN1c3BlbmRlZC4gTm90ZSwgb24gU2FmYXJpLCBtdXN0IGJlIGNyZWF0ZWQgZGlyZWN0bHkgZnJvbSB1c2VyIGludGVyYWN0aW9uIChpLmUuIG5vICdhd2FpdCcpKS5cIiksdGhpcy5hdWRpb0NvbnRleHQuc2FtcGxlUmF0ZSE9dGhpcy5zYW1wbGVSYXRlSHo/KHQuUmFpbndheUxvZ2dpbmcud2FybmluZyhcIkNvbmZpZ3VyZWQgc2FtcGxlIHJhdGU6IFwiK3RoaXMuc2FtcGxlUmF0ZUh6K1wiIGRvZXMgbm90IG1hdGNoIEF1ZGlvQ29udGV4dDogXCIrdGhpcy5hdWRpb0NvbnRleHQuc2FtcGxlUmF0ZStcIi4gUmVzYW1wbGluZyBpcyByZXF1aXJlZCFcIiksdGhpcy5yZXNhbXBsZWRBdWRpb0J1ZmZlclNpemU9TWF0aC5mbG9vcih0aGlzLmF1ZGlvQ29udGV4dC5zYW1wbGVSYXRlLzFlMyp0aGlzLm1pbkxhdGVuY3lNcy8yKSx0aGlzLnNjaGVkdWxlQnVmZmVyRm9yUGxheWJhY2tGdW5jPXRoaXMucmVzYW1wbGVCdWZmZXJUaGVuU2NoZWR1bGVGb3JQbGF5YmFjay5iaW5kKHRoaXMpKTp0aGlzLnNjaGVkdWxlQnVmZmVyRm9yUGxheWJhY2tGdW5jPXRoaXMuc2NoZWR1bGVCdWZmZXJGb3JQbGF5YmFjay5iaW5kKHRoaXMpLHRoaXMuYXVkaW9CdWZmZXJQb29sPVtdO2xldCBFPSExO3RoaXMucGxheWluZyYmKEU9ITAsdGhpcy5zdG9wKCkpLEUmJnRoaXMucGxheSgpfXBsYXkoKXtpZighdGhpcy5vcHVzRGVjb2Rlcldvcmtlcil0aHJvdyBuZXcgUS5SYWlud2F5RXJyb3IoXCJwbGF5KCkgaGFzIG5vIG9wdXNEZWNvZGVyV29ya2VyXCIpO2lmKCF0aGlzLnNhbXBsZVJhdGVIeil0aHJvdyBuZXcgUS5SYWlud2F5RXJyb3IoXCJwbGF5KCkgaGFzIG5vIHNhbXBsZVJhdGVIelwiKTtpZighdGhpcy5jaGFubmVsQ291bnQpdGhyb3cgbmV3IFEuUmFpbndheUVycm9yKFwicGxheSgpIGhhcyBubyBjaGFubmVsQ291bnRcIik7aWYoIXRoaXMuYXVkaW9Db250ZXh0KXRocm93IG5ldyBRLlJhaW53YXlFcnJvcihcInBsYXkoKSBoYXMgbm8gYXVkaW9Db250ZXh0XCIpO3RoaXMucGxheWluZ3x8KHRoaXMubWF4RGVjb2RpbmdUaW1lTXM9MCx0aGlzLnRvdGFsRGVjb2RpbmdUaW1lTXM9MCx0aGlzLnRvdGFsUXVldWVkU2l6ZT0wLHRoaXMubWF4UXVldWVkU2l6ZT0wLHRoaXMuc3RhcnRTdHJlYW1UaW1lTXM9RGF0ZS5ub3coKSx0aGlzLm9wdXNEZWNvZGVyV29ya2VyLnN0YXJ0U3RyZWFtKHRoaXMuc2FtcGxlUmF0ZUh6LHRoaXMuY2hhbm5lbENvdW50LHRoaXMuZGVjb2RlZFNhbXBsZXNQZXJGcmFtZSksdGhpcy5wbGF5aW5nPSEwKX1zdG9wKCl7aWYoIXRoaXMub3B1c0RlY29kZXJXb3JrZXIpdGhyb3cgbmV3IFEuUmFpbndheUVycm9yKFwic3RvcCgpIGhhcyBubyBvcHVzRGVjb2RlcldvcmtlclwiKTt0aGlzLndhaXRpbmdUb0RlY29kZVF1ZXVlPVtdLHRoaXMub3V0cHV0QnVmZmVycz1bXSx0aGlzLm5leHRTdGFydFRpbWU9dm9pZCAwLHRoaXMudG90YWxTYW1wbGVzRGVjb2RlZD0wLHRoaXMuY3VycmVudE91dHB1dEJ1ZmZlcj12b2lkIDAsdGhpcy5jdXJyZW50QnVmZmVyUmVhZEluZGV4PTAsdGhpcy5wcmV2RHJvcHBlZEZyYW1lVGltZU1zPXZvaWQgMCx0aGlzLm9wdXNEZWNvZGVyV29ya2VyLnN0b3BTdHJlYW0oKSx0aGlzLnBsYXlpbmc9ITF9cHVzaERhdGEoQSl7dGhpcy5wbGF5aW5nJiZ0aGlzLmF1ZGlvQ29udGV4dCYmdGhpcy5vcHVzRGVjb2RlcldvcmtlciYmKDA9PXRoaXMuZGVjb2RlUXVldWVTaXplPygwIT10aGlzLndhaXRpbmdUb0RlY29kZVF1ZXVlLmxlbmd0aCYmKHQuUmFpbndheUxvZ2dpbmcuZXJyb3IoXCJbQXVkaW9TdHJlYW1dIGVtcHR5IGRlY29kZXIgcXVldWUsIGJ1dCB3YWl0aW5nIHRvIGRlY29kZSBxdWV1ZSBub3QgZW1wdHkhXCIpLHRoaXMud2FpdGluZ1RvRGVjb2RlUXVldWU9W10pLHRoaXMuc2VuZFRvRGVjb2Rlcih7c3RhcnRUaW1lc3RhbXA6RGF0ZS5ub3coKSxpbnB1dERhdGE6QX0pKToodGhpcy53YWl0aW5nVG9EZWNvZGVRdWV1ZS5wdXNoKHtzdGFydFRpbWVzdGFtcDpEYXRlLm5vdygpLGlucHV0RGF0YTpBfSksdGhpcy5kZWNvZGVRdWV1ZVNpemU8MyYmdGhpcy5zZW5kRGVjb2RlcldhaXRpbmdUb0RlY29kZUZyYW1lcygpKSl9c2VuZERlY29kZXJXYWl0aW5nVG9EZWNvZGVGcmFtZXMoKXtjb25zdCBBPSh0aGlzLmRlY29kZVF1ZXVlU2l6ZSt0aGlzLndhaXRpbmdUb0RlY29kZVF1ZXVlLmxlbmd0aCkqdGhpcy5kYXRhRHVyYXRpb25NcztpZihBPnRoaXMubWF4TGF0ZW5jeU1zKXtjb25zdCBJPUEtdGhpcy5tYXhMYXRlbmN5TXMsZz1NYXRoLmZsb29yKEkvdGhpcy5kYXRhRHVyYXRpb25NcyksZT1NYXRoLm1heChNYXRoLm1heCh0aGlzLndhaXRpbmdUb0RlY29kZVF1ZXVlLmxlbmd0aC1nLDMtdGhpcy5kZWNvZGVRdWV1ZVNpemUpLDEpLEI9dGhpcy53YWl0aW5nVG9EZWNvZGVRdWV1ZS5sZW5ndGgtZTt0aGlzLndhaXRpbmdUb0RlY29kZVF1ZXVlPXRoaXMud2FpdGluZ1RvRGVjb2RlUXVldWUuc2xpY2UoQil9Zm9yKDt0aGlzLmRlY29kZVF1ZXVlU2l6ZTwzJiZ0aGlzLndhaXRpbmdUb0RlY29kZVF1ZXVlLmxlbmd0aD4wOyl7Y29uc3QgQT10aGlzLndhaXRpbmdUb0RlY29kZVF1ZXVlLnNoaWZ0KCk7dGhpcy5zZW5kVG9EZWNvZGVyKEEpfX1zZW5kVG9EZWNvZGVyKEEpeysrdGhpcy5kZWNvZGVRdWV1ZVNpemUsdGhpcy5vcHVzRGVjb2Rlcldvcmtlci5kZWNvZGUoQS5zdGFydFRpbWVzdGFtcCxBLmlucHV0RGF0YSl9ZHJvcERlY29kZWRTYW1wbGVzKEEpe2xldCBJPTA7Zm9yKHRoaXMuY3VycmVudE91dHB1dEJ1ZmZlciYmKEkrPXRoaXMuZHJvcEN1cnJlbnRPdXRwdXRCdWZmZXJTYW1wbGVzKEEpLEEtPUkpO0E+MCYmdGhpcy5vdXRwdXRCdWZmZXJzLmxlbmd0aD4wOylpZihBPHRoaXMuZGVjb2RlZFNhbXBsZXNQZXJGcmFtZSl7dGhpcy5jdXJyZW50T3V0cHV0QnVmZmVyPXRoaXMub3V0cHV0QnVmZmVycy5zaGlmdCgpLHRoaXMuY3VycmVudEJ1ZmZlclJlYWRJbmRleD0wO2NvbnN0IGc9dGhpcy5kcm9wQ3VycmVudE91dHB1dEJ1ZmZlclNhbXBsZXMoQSk7SSs9ZyxBLT1nfWVsc2UgdGhpcy5vdXRwdXRCdWZmZXJzLnNoaWZ0KCksSSs9dGhpcy5kZWNvZGVkU2FtcGxlc1BlckZyYW1lLEEtPXRoaXMuZGVjb2RlZFNhbXBsZXNQZXJGcmFtZTtyZXR1cm4gSX1kcm9wQ3VycmVudE91dHB1dEJ1ZmZlclNhbXBsZXMoQSl7Y29uc3QgST1NYXRoLmZsb29yKCh0aGlzLmN1cnJlbnRPdXRwdXRCdWZmZXIubGVuZ3RoLXRoaXMuY3VycmVudEJ1ZmZlclJlYWRJbmRleCkvdGhpcy5jaGFubmVsQ291bnQpLGc9TWF0aC5taW4oSSxBKTtyZXR1cm4gdGhpcy5jdXJyZW50QnVmZmVyUmVhZEluZGV4Kz1nKnRoaXMuY2hhbm5lbENvdW50LHRoaXMuY3VycmVudEJ1ZmZlclJlYWRJbmRleD49dGhpcy5jdXJyZW50T3V0cHV0QnVmZmVyLmxlbmd0aCYmKHRoaXMuY3VycmVudE91dHB1dEJ1ZmZlcj12b2lkIDApLGd9Y29weURlY29kZWRTYW1wbGVzVG9BdWRpb0J1ZmZlcigpe2NvbnN0IEE9dGhpcy5nZXRPckNyZWF0ZUF1ZGlvQnVmZmVyKCk7Zm9yKGxldCBJPTA7STx0aGlzLmF1ZGlvQnVmZmVyU2l6ZTspe3RoaXMuY3VycmVudE91dHB1dEJ1ZmZlcnx8KHRoaXMuY3VycmVudE91dHB1dEJ1ZmZlcj10aGlzLm91dHB1dEJ1ZmZlcnMuc2hpZnQoKSx0aGlzLmN1cnJlbnRCdWZmZXJSZWFkSW5kZXg9MCk7Y29uc3QgZz10aGlzLmN1cnJlbnRPdXRwdXRCdWZmZXI7aWYoMT09dGhpcy5jaGFubmVsQ291bnQpe2NvbnN0IGU9QS5nZXRDaGFubmVsRGF0YSgwKTtmb3IoO3RoaXMuY3VycmVudEJ1ZmZlclJlYWRJbmRleDxnLmxlbmd0aCYmKGVbSV09Z1t0aGlzLmN1cnJlbnRCdWZmZXJSZWFkSW5kZXhdLHRoaXMuY3VycmVudEJ1ZmZlclJlYWRJbmRleCs9dGhpcy5jaGFubmVsQ291bnQsKytJLCEoST49dGhpcy5hdWRpb0J1ZmZlclNpemUpKTspO31lbHNlIGlmKDI9PXRoaXMuY2hhbm5lbENvdW50KXtjb25zdCBlPUEuZ2V0Q2hhbm5lbERhdGEoMCksQj1BLmdldENoYW5uZWxEYXRhKDEpO2Zvcig7dGhpcy5jdXJyZW50QnVmZmVyUmVhZEluZGV4PGcubGVuZ3RoJiYoZVtJXT1nW3RoaXMuY3VycmVudEJ1ZmZlclJlYWRJbmRleF0sQltJXT1nW3RoaXMuY3VycmVudEJ1ZmZlclJlYWRJbmRleCsxXSx0aGlzLmN1cnJlbnRCdWZmZXJSZWFkSW5kZXgrPXRoaXMuY2hhbm5lbENvdW50LCsrSSwhKEk+PXRoaXMuYXVkaW9CdWZmZXJTaXplKSk7KTt9ZWxzZXtjb25zdCBlPUEuZ2V0Q2hhbm5lbERhdGEoMCksQj1BLmdldENoYW5uZWxEYXRhKDEpLGk9QS5nZXRDaGFubmVsRGF0YSgyKSxRPUEuZ2V0Q2hhbm5lbERhdGEoMyksdD1BLmdldENoYW5uZWxEYXRhKDQpLEM9QS5nZXRDaGFubmVsRGF0YSg1KTtmb3IoO3RoaXMuY3VycmVudEJ1ZmZlclJlYWRJbmRleDxnLmxlbmd0aCYmKGVbSV09Z1t0aGlzLmN1cnJlbnRCdWZmZXJSZWFkSW5kZXhdLEJbSV09Z1t0aGlzLmN1cnJlbnRCdWZmZXJSZWFkSW5kZXgrMV0sdFtJXT1nW3RoaXMuY3VycmVudEJ1ZmZlclJlYWRJbmRleCsyXSxDW0ldPWdbdGhpcy5jdXJyZW50QnVmZmVyUmVhZEluZGV4KzNdLGlbSV09Z1t0aGlzLmN1cnJlbnRCdWZmZXJSZWFkSW5kZXgrNF0sUVtJXT1nW3RoaXMuY3VycmVudEJ1ZmZlclJlYWRJbmRleCs1XSx0aGlzLmN1cnJlbnRCdWZmZXJSZWFkSW5kZXgrPXRoaXMuY2hhbm5lbENvdW50LCsrSSwhKEk+PXRoaXMuYXVkaW9CdWZmZXJTaXplKSk7KTt9dGhpcy5jdXJyZW50QnVmZmVyUmVhZEluZGV4Pj10aGlzLmN1cnJlbnRPdXRwdXRCdWZmZXIubGVuZ3RoJiYodGhpcy5jdXJyZW50T3V0cHV0QnVmZmVyPXZvaWQgMCl9cmV0dXJuIEF9Z2V0T3JDcmVhdGVBdWRpb0J1ZmZlcigpe3JldHVybiAwPT10aGlzLmF1ZGlvQnVmZmVyUG9vbC5sZW5ndGg/dGhpcy5hdWRpb0NvbnRleHQuY3JlYXRlQnVmZmVyKHRoaXMuY2hhbm5lbENvdW50LHRoaXMuYXVkaW9CdWZmZXJTaXplLHRoaXMuc2FtcGxlUmF0ZUh6KTp0aGlzLmF1ZGlvQnVmZmVyUG9vbC5wb3AoKX1yZXR1cm5BdWRpb0J1ZmZlclRvUG9vbChBLEkpe3RoaXMuYXVkaW9CdWZmZXJQb29sLmxlbmd0aDx0aGlzLm1heEF1ZGlvQnVmZmVyUG9vbENvdW50JiZ0aGlzLmF1ZGlvQnVmZmVyUG9vbC5wdXNoKEEpfWxvZ1BlcmZUaW1pbmcoQSl7Y29uc3QgST1EYXRlLm5vdygpLGc9SS1BO3RoaXMudG90YWxEZWNvZGluZ1RpbWVNcys9ZyxnPnRoaXMubWF4RGVjb2RpbmdUaW1lTXMmJih0aGlzLm1heERlY29kaW5nVGltZU1zPWcpO2NvbnN0IGU9dGhpcy53YWl0aW5nVG9EZWNvZGVRdWV1ZS5sZW5ndGgrdGhpcy5kZWNvZGVRdWV1ZVNpemU7dGhpcy50b3RhbFF1ZXVlZFNpemUrPWUsZT50aGlzLm1heFF1ZXVlZFNpemUmJih0aGlzLm1heFF1ZXVlZFNpemU9ZSksMTUwMD09dGhpcy5kZWNvZGVkQ291bnQmJih0LlJhaW53YXlMb2dnaW5nLmluZm9ybWF0aW9uKFwiW0F1ZGlvU3RyZWFtXSBBdmcgcXVldWU6IFwiK3RoaXMudG90YWxRdWV1ZWRTaXplL3RoaXMuZGVjb2RlZENvdW50K1wiLCBNYXg6IFwiK3RoaXMubWF4UXVldWVkU2l6ZStcIiBBdmcgRlBTOiBcIit0aGlzLmRlY29kZWRDb3VudC8oKEktdGhpcy5zdGFydFN0cmVhbVRpbWVNcykvMWUzKStcIiBBdmcgZGVjb2RlOiBcIit0aGlzLnRvdGFsRGVjb2RpbmdUaW1lTXMvdGhpcy5kZWNvZGVkQ291bnQrXCJtcywgTWF4OiBcIit0aGlzLm1heERlY29kaW5nVGltZU1zK1wibXNcIiksdGhpcy50b3RhbERlY29kaW5nVGltZU1zPTAsdGhpcy5tYXhEZWNvZGluZ1RpbWVNcz0wLHRoaXMudG90YWxRdWV1ZWRTaXplPTAsdGhpcy5tYXhRdWV1ZWRTaXplPTAsdGhpcy5kZWNvZGVkQ291bnQ9MCx0aGlzLnN0YXJ0U3RyZWFtVGltZU1zPUkpfXJlc2FtcGxlQnVmZmVyVGhlblNjaGVkdWxlRm9yUGxheWJhY2soQSl7Y29uc3QgST1uZXcod2luZG93Lk9mZmxpbmVBdWRpb0NvbnRleHR8fHdpbmRvdy53ZWJraXRPZmZsaW5lQXVkaW9Db250ZXh0KSh0aGlzLmNoYW5uZWxDb3VudCx0aGlzLnJlc2FtcGxlZEF1ZGlvQnVmZmVyU2l6ZSx0aGlzLmF1ZGlvQ29udGV4dC5zYW1wbGVSYXRlKSxnPUkuY3JlYXRlQnVmZmVyU291cmNlKCk7Zy5idWZmZXI9QSxnLmNvbm5lY3QoSS5kZXN0aW5hdGlvbiksZy5zdGFydCgpLEkuc3RhcnRSZW5kZXJpbmcoKSxJLm9uY29tcGxldGU9dGhpcy5zY2hlZHVsZVJlc2FtcGxlZEJ1ZmZlclBsYXliYWNrLmJpbmQodGhpcyxBKX1zY2hlZHVsZVJlc2FtcGxlZEJ1ZmZlclBsYXliYWNrKEEsSSl7dGhpcy5zY2hlZHVsZVBsYXliYWNrV2l0aE9uRW5kZWQoSS5yZW5kZXJlZEJ1ZmZlciksdGhpcy5yZXR1cm5BdWRpb0J1ZmZlclRvUG9vbChBLEkpfXNjaGVkdWxlQnVmZmVyRm9yUGxheWJhY2soQSl7dGhpcy5zY2hlZHVsZVBsYXliYWNrV2l0aE9uRW5kZWQoQSx0aGlzLnJldHVybkF1ZGlvQnVmZmVyVG9Qb29sLmJpbmQodGhpcyxBKSl9c2NoZWR1bGVQbGF5YmFja1dpdGhPbkVuZGVkKEEsST1udWxsKXtjb25zdCBnPXRoaXMuYXVkaW9Db250ZXh0LmNyZWF0ZUJ1ZmZlclNvdXJjZSgpO2cuYnVmZmVyPUEsdGhpcy5uZXh0U3RhcnRUaW1lfHwodGhpcy5uZXh0U3RhcnRUaW1lPXRoaXMuYXVkaW9Db250ZXh0LmN1cnJlbnRUaW1lKSxnLnBsYXliYWNrUmF0ZS52YWx1ZT0xLGcuY29ubmVjdCh0aGlzLnZvbHVtZU5vZGUpLGcuc3RhcnQodGhpcy5uZXh0U3RhcnRUaW1lKSxnLm9uZW5kZWQ9SSx0aGlzLm5leHRTdGFydFRpbWUrPUEuZHVyYXRpb259c2V0Vm9sdW1lKEEpe3RoaXMudm9sdW1lTm9kZS5nYWluLnZhbHVlPUF9fX0sNTE0OihBLEksZyk9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkoSSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxJLm1ha2VDbGllbnRDYXBhYmlsaXRpZXM9dm9pZCAwO2NvbnN0IGU9Zyg5MDQpLEI9Zyg2NDMpLGk9Zyg2OTUpO0kubWFrZUNsaWVudENhcGFiaWxpdGllcz1mdW5jdGlvbihBKXtjb25zdHtmaWx0ZXJlZDpJLHByZWZlcnJlZDpnfT1pLmZpbHRlckNvZGVjUGFjayhBKSxRPXtjb2RlYzplLkF1ZGlvQ29kZWMuT3B1cyxjb250YWluZXI6ZS5BdWRpb0NvbnRhaW5lci5SYXd9LHQ9XCJNZWRpYVNvdXJjZVwiaW4gd2luZG93P2UuVmlkZW9Db250YWluZXIuSXNvQk1GRjplLlZpZGVvQ29udGFpbmVyLlJhdyxDPSEhd2luZG93LmNocm9tZTtyZXR1cm57cHJlZmVycmVkV2lkdGg6c2NyZWVuLmF2YWlsV2lkdGgscHJlZmVycmVkSGVpZ2h0OnNjcmVlbi5hdmFpbEhlaWdodCxwcmVmZXJyZWRGcHM6NjAscHJlZmVycmVkQXVkaW9CaXRyYXRlOjk2ZTMscHJlZmVycmVkVmlkZW9CaXRyYXRlOjFlMypCLmRlZmF1bHRSYXRlQ29udHJvbFBhcmFtZXRlcnMuaW5pdGlhbEJpdHJhdGVLYnBzLHByZWZlcnJlZEF1ZGlvQ2hhbm5lbHM6ZS5BdWRpb0NoYW5uZWxzLlN0ZXJlbyxwcmVmZXJyZWRBdWRpb0NvbmZpZzpRLHByZWZlcnJlZFZpZGVvQ29uZmlnOntjb2RlYzpnLGNvbnRhaW5lcjp0fSxzdXBwb3J0ZWRBdWRpb0NoYW5uZWxzOltlLkF1ZGlvQ2hhbm5lbHMuTW9ubyxlLkF1ZGlvQ2hhbm5lbHMuU3RlcmVvXSxzdXBwb3J0ZWRBdWRpb0NvbmZpZ3M6W1FdLHN1cHBvcnRlZFZpZGVvQ29uZmlnczpJLm1hcCgoQT0+KHtjb2RlYzpBLGNvbnRhaW5lcjp0fSkpKSxzdXBwb3J0c092ZXIxMDgwUDohMSxzdXBwb3J0c1RlbXBvcmFsU2NhbGluZzohMCxzdXBwb3J0c0FwcElzb2xhdGlvbjpDfX19LDY5NTooQSxJLGcpPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KEksXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksSS5maWx0ZXJDb2RlY1BhY2s9SS52aWRlb0NvZGVjTWltZVR5cGU9dm9pZCAwO2NvbnN0IGU9Zyg5MDQpO2Z1bmN0aW9uIEIoQSl7Y29uc3QgST1BLmRhdGE7cmV0dXJuYHZpZGVvL21wNDsgY29kZWNzPVwiYXZjMS4keyhJWzVdPDwxNnxJWzZdPDw4fElbN10pLnRvU3RyaW5nKDE2KS5wYWRTdGFydCg2LFwiMFwiKX1cImB9ZnVuY3Rpb24gaShBKXtpZighKFwiTWVkaWFTb3VyY2VcImluIHdpbmRvdykpcmV0dXJuITE7Y29uc3QgST1BLmRhdGE7aWYoSS5sZW5ndGg8OHx8NyE9KDMxJklbNF0pKXJldHVybiExO2NvbnN0IGc9QihBKTtyZXR1cm4gTWVkaWFTb3VyY2UuaXNUeXBlU3VwcG9ydGVkKGcpfWZ1bmN0aW9uIFEoQSl7Y29uc3QgST1BLmRhdGE7aWYoSS5sZW5ndGg8OHx8NyE9KDMxJklbNF0pKXJldHVybiBlLlZpZGVvQ29kZWNUeXBlLkJhc2VsaW5lO2NvbnN0IGc9SVs1XTtyZXR1cm4gSVs2XSwxMTY9PWd8fDEyMj09Z3x8MTEwPT1nfHwxMDA9PWc/ZS5WaWRlb0NvZGVjVHlwZS5IaWdoOjg4PT1nfHw3Nz09Zz9lLlZpZGVvQ29kZWNUeXBlLk1haW46ZS5WaWRlb0NvZGVjVHlwZS5CYXNlbGluZX1JLnZpZGVvQ29kZWNNaW1lVHlwZT1CLEkuZmlsdGVyQ29kZWNQYWNrPWZ1bmN0aW9uKEEpe2lmKDA9PT1BLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJIb3N0IHN1cHBsaWVkIGFuIGVtcHR5IENvZGVjUGFja1wiKTtsZXQgST1BLmZpbHRlcihpKTtpZigwPT09SS5sZW5ndGgmJihjb25zb2xlLndhcm4oXCJGb3VuZCBubyBicm93c2VyLWNvbmZpcm1lZCB3b3JraW5nIGNvZGVjLCBmYWxsaW5nIGJhY2sgdG8gYmFzZWxpbmVcIiksST1BLmZpbHRlcigoQT0+UShBKTw9ZS5WaWRlb0NvZGVjVHlwZS5CYXNlbGluZSkpKSwwPT09SS5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiSG9zdCBzdXBwbGllZCBhbiB1bnN1cHBvcnRlZCBDb2RlY1BhY2tcIik7Y29uc3QgZz1JLnJlZHVjZSgoKEEsSSk9PlEoQSk+UShJKT9BOkkpKTtyZXR1cm57ZmlsdGVyZWQ6SSxwcmVmZXJyZWQ6Z319fSw5MTk6KEEsSSxnKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eShJLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO2NvbnN0IGU9Zyg0NjQpO2NsYXNzIEJ7Y29uc3RydWN0b3IoQSxJLGcpe3RoaXMuZ2xDdHg9dm9pZCAwLHRoaXMucHJvZ3JhbT12b2lkIDAsdGhpcy5nbEN0eD1BLHRoaXMucHJvZ3JhbT10aGlzLmdsQ3R4LmNyZWF0ZVByb2dyYW0oKSx0aGlzLmdsQ3R4LmF0dGFjaFNoYWRlcih0aGlzLnByb2dyYW0sSSksdGhpcy5nbEN0eC5hdHRhY2hTaGFkZXIodGhpcy5wcm9ncmFtLGcpLHRoaXMuZ2xDdHgubGlua1Byb2dyYW0odGhpcy5wcm9ncmFtKSx0aGlzLmdsQ3R4LmdldFByb2dyYW1QYXJhbWV0ZXIodGhpcy5wcm9ncmFtLHRoaXMuZ2xDdHguTElOS19TVEFUVVMpfHxlLlJhaW53YXlMb2dnaW5nLmVycm9yKFwiU2hhZGVyIGxpbmsgZmFpbGVkLlwiKX1zdGF0aWMgY29tcGlsZShBLEksZyl7bGV0IEI7cmV0dXJuIEI9XCJ2ZXJ0ZXhcIj09PUk/QS5jcmVhdGVTaGFkZXIoQS5WRVJURVhfU0hBREVSKTpBLmNyZWF0ZVNoYWRlcihBLkZSQUdNRU5UX1NIQURFUiksQS5zaGFkZXJTb3VyY2UoQixnKSxBLmNvbXBpbGVTaGFkZXIoQiksMD09QS5nZXRTaGFkZXJQYXJhbWV0ZXIoQixBLkNPTVBJTEVfU1RBVFVTKSYmZS5SYWlud2F5TG9nZ2luZy5lcnJvcihcIlNoYWRlciBjb21waWxlIGZhaWxlZCwgbG9nOiBcIitBLmdldFNoYWRlckluZm9Mb2coQikpLEJ9c3RhdGljIGNyZWF0ZShBLEksZyl7Y29uc3QgZT1CLmNvbXBpbGUoQSxcInZlcnRleFwiLEkpLGk9Qi5jb21waWxlKEEsXCJmcmFnbWVudFwiLGcpO3JldHVybiBuZXcgQihBLGUsaSl9dXNlKCl7dGhpcy5nbEN0eC51c2VQcm9ncmFtKHRoaXMucHJvZ3JhbSl9Z2V0QXR0cmlidXRlTG9jYXRpb24oQSl7cmV0dXJuIHRoaXMuZ2xDdHguZ2V0QXR0cmliTG9jYXRpb24odGhpcy5wcm9ncmFtLEEpfWdldFVuaWZvcm1Mb2NhdGlvbihBKXtjb25zdCBJPXRoaXMuZ2xDdHguZ2V0VW5pZm9ybUxvY2F0aW9uKHRoaXMucHJvZ3JhbSxBKTtpZihJKXJldHVybiBJfXNldE1hdHJpeFVuaWZvcm0oQSxJKXt0aGlzLmdsQ3R4LnVuaWZvcm1NYXRyaXg0ZnYoQSwhMSxJKX19SS5kZWZhdWx0PUJ9LDc1NjpmdW5jdGlvbihBLEksZyl7XCJ1c2Ugc3RyaWN0XCI7dmFyIGU9dGhpcyYmdGhpcy5fX2ltcG9ydERlZmF1bHR8fGZ1bmN0aW9uKEEpe3JldHVybiBBJiZBLl9fZXNNb2R1bGU/QTp7ZGVmYXVsdDpBfX07T2JqZWN0LmRlZmluZVByb3BlcnR5KEksXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksSS55dXZGcmFnU2hhZGVyU3JjPXZvaWQgMDtjb25zdCBCPWUoZyg5MTkpKTtJLnl1dkZyYWdTaGFkZXJTcmM9XCJcXG4gICAgcHJlY2lzaW9uIGxvd3AgZmxvYXQ7XFxuICAgIFxcbiAgICB2YXJ5aW5nIHZlYzIgdlRleENvb3JkO1xcbiAgICBcXG4gICAgdW5pZm9ybSBzYW1wbGVyMkQgeVRleHR1cmU7XFxuICAgIHVuaWZvcm0gc2FtcGxlcjJEIHVUZXh0dXJlO1xcbiAgICB1bmlmb3JtIHNhbXBsZXIyRCB2VGV4dHVyZTtcXG4gICAgY29uc3QgbWF0MyBjb252ZXJzaW9uID0gbWF0MyhcXG4gICAgICAgIDEuMTY0LCAwLjAwMCwgIDEuNTk2LFxcbiAgICAgICAgMS4xNjQsIC0wLjM5MSwgLTAuODEzLFxcbiAgICAgICAgMS4xNjQsIDIuMDE4LCAgMC4wMDBcXG4gICAgKTtcXG5cXG4gICAgY29uc3QgdmVjMyBvZmZzZXQgPSB2ZWMzKDAuMDYyNSwgMC41LCAwLjUpO1xcbiAgICAgICAgXFxuICAgIHZvaWQgbWFpbih2b2lkKSB7XFxuICAgICAgICBmbG9hdCB5ID0gdGV4dHVyZTJEKHlUZXh0dXJlLCB2VGV4Q29vcmQpLng7XFxuICAgICAgICBmbG9hdCB1ID0gdGV4dHVyZTJEKHVUZXh0dXJlLCB2VGV4Q29vcmQpLng7XFxuICAgICAgICBmbG9hdCB2ID0gdGV4dHVyZTJEKHZUZXh0dXJlLCB2VGV4Q29vcmQpLng7XFxuICAgICAgICB2ZWMzIHl1diA9IHZlYzMoeSwgdSwgdikgLSBvZmZzZXQ7XFxuXFxuICAgICAgICB2ZWMzIHJnYiA9ICh5dXYgKiBjb252ZXJzaW9uKTtcXG5cXG4gICAgICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQocmdiLCAxLjApO1xcbiAgICB9XFxuXCI7Y2xhc3MgaXtjb25zdHJ1Y3RvcihBLEksZyxlLEIsaSxRLHQsQyl7dGhpcy5nbEN0eD1BLHRoaXMucHJvZ3JhbT1JLHRoaXMucHJvamVjdGlvbk10eExvYz1nLHRoaXMucG9zaXRpb25BdHRyPWUsdGhpcy50ZXhDb29yZEF0dHI9Qix0aGlzLnZlcnRleEJ1ZmZlcj1pLHRoaXMueVRleHR1cmVMb2M9USx0aGlzLnVUZXh0dXJlTG9jPXQsdGhpcy52VGV4dHVyZUxvYz1DfXN0YXRpYyBjcmVhdGUoQSl7Y29uc3QgZz1CLmRlZmF1bHQuY3JlYXRlKEEsXCJcXG4gICAgcHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XFxuXFxuICAgIHVuaWZvcm0gbWF0NCB1UHJvamVjdGlvbjtcXG4gICAgYXR0cmlidXRlIHZlYzIgYVBvc2l0aW9uO1xcbiAgICBhdHRyaWJ1dGUgdmVjMiBhVGV4Q29vcmQ7XFxuXFxuICAgIHZhcnlpbmcgdmVjMiB2VGV4Q29vcmQ7XFxuICAgIHZvaWQgbWFpbigpe1xcbiAgICAgICAgdlRleENvb3JkID0gYVRleENvb3JkO1xcbiAgICAgICAgZ2xfUG9zaXRpb24gPSB1UHJvamVjdGlvbiAqIHZlYzQoYVBvc2l0aW9uLCAwLjAsIDEuMCk7XFxuICAgIH1cXG5cIixJLnl1dkZyYWdTaGFkZXJTcmMpO2cudXNlKCk7Y29uc3QgZT1nLmdldFVuaWZvcm1Mb2NhdGlvbihcInVQcm9qZWN0aW9uXCIpLFE9Zy5nZXRBdHRyaWJ1dGVMb2NhdGlvbihcImFQb3NpdGlvblwiKTtBLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KFEpO2NvbnN0IHQ9Zy5nZXRBdHRyaWJ1dGVMb2NhdGlvbihcImFUZXhDb29yZFwiKTtBLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KHQpO2NvbnN0IEM9QS5jcmVhdGVCdWZmZXIoKSxFPWcuZ2V0VW5pZm9ybUxvY2F0aW9uKFwieVRleHR1cmVcIiksbz1nLmdldFVuaWZvcm1Mb2NhdGlvbihcInVUZXh0dXJlXCIpLGE9Zy5nZXRVbmlmb3JtTG9jYXRpb24oXCJ2VGV4dHVyZVwiKTtyZXR1cm4gbmV3IGkoQSxnLGUsUSx0LEMsRSxvLGEpfWJpbmRJbnB1dFRleHR1cmVzKEEsSSxnKXtjb25zdCBlPXRoaXMuZ2xDdHg7ZS51bmlmb3JtMWkodGhpcy55VGV4dHVyZUxvYywwKSxlLmFjdGl2ZVRleHR1cmUoZS5URVhUVVJFMCksZS5iaW5kVGV4dHVyZShlLlRFWFRVUkVfMkQsQS50ZXh0dXJlSWQpLGUudW5pZm9ybTFpKHRoaXMudVRleHR1cmVMb2MsMSksZS5hY3RpdmVUZXh0dXJlKGUuVEVYVFVSRTEpLGUuYmluZFRleHR1cmUoZS5URVhUVVJFXzJELEkudGV4dHVyZUlkKSxlLnVuaWZvcm0xaSh0aGlzLnZUZXh0dXJlTG9jLDIpLGUuYWN0aXZlVGV4dHVyZShlLlRFWFRVUkUyKSxlLmJpbmRUZXh0dXJlKGUuVEVYVFVSRV8yRCxnLnRleHR1cmVJZCl9dXNlKCl7dGhpcy5wcm9ncmFtLnVzZSgpfWRyb3AoKXt0aGlzLmdsQ3R4LnVzZVByb2dyYW0oMCl9dXBkYXRlKEEsSSxnLGUpe3RoaXMuZ2xDdHgudmlld3BvcnQoMCwwLEEsSSksdGhpcy5wcm9ncmFtLnNldE1hdHJpeFVuaWZvcm0odGhpcy5wcm9qZWN0aW9uTXR4TG9jLFsyL0EsMCwwLDAsMCwyLy1JLDAsMCwwLDAsMSwwLC0xLDEsMCwxXSksdGhpcy5nbEN0eC5iaW5kQnVmZmVyKHRoaXMuZ2xDdHguQVJSQVlfQlVGRkVSLHRoaXMudmVydGV4QnVmZmVyKSx0aGlzLmdsQ3R4LmJ1ZmZlckRhdGEodGhpcy5nbEN0eC5BUlJBWV9CVUZGRVIsbmV3IEZsb2F0MzJBcnJheShbMCwwLDAsMCxBLDAsZywwLEEsSSxnLGUsQSxJLGcsZSwwLEksMCxlLDAsMCwwLDBdKSx0aGlzLmdsQ3R4LkRZTkFNSUNfRFJBVyksdGhpcy5nbEN0eC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHRoaXMucG9zaXRpb25BdHRyLDIsdGhpcy5nbEN0eC5GTE9BVCwhMSwxNiwwKSx0aGlzLmdsQ3R4LnZlcnRleEF0dHJpYlBvaW50ZXIodGhpcy50ZXhDb29yZEF0dHIsMix0aGlzLmdsQ3R4LkZMT0FULCExLDE2LDgpfWRyYXcoKXtjb25zdCBBPXRoaXMuZ2xDdHg7QS5jbGVhcihBLkNPTE9SX0JVRkZFUl9CSVR8QS5ERVBUSF9CVUZGRVJfQklUfEEuU1RFTkNJTF9CVUZGRVJfQklUKSxBLmRyYXdBcnJheXMoQS5UUklBTkdMRV9TVFJJUCwwLDYpLEEuYmluZFRleHR1cmUoQS5URVhUVVJFXzJELG51bGwpfX1JLmRlZmF1bHQ9aX0sMzQ2OihBLEkpPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KEksXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7Y2xhc3MgZ3tjb25zdHJ1Y3RvcihBLEkpe3RoaXMuZ2xDdHg9dm9pZCAwLHRoaXMudGV4dHVyZUlkPXZvaWQgMCx0aGlzLmdsQ3R4PUEsdGhpcy50ZXh0dXJlSWQ9SX1zdGF0aWMgY3JlYXRlKEEpe2NvbnN0IEk9QS5jcmVhdGVUZXh0dXJlKCk7cmV0dXJuIEEuYmluZFRleHR1cmUoQS5URVhUVVJFXzJELEkpLEEudGV4UGFyYW1ldGVyaShBLlRFWFRVUkVfMkQsQS5URVhUVVJFX01BR19GSUxURVIsQS5ORUFSRVNUKSxBLnRleFBhcmFtZXRlcmkoQS5URVhUVVJFXzJELEEuVEVYVFVSRV9NSU5fRklMVEVSLEEuTkVBUkVTVCksQS50ZXhQYXJhbWV0ZXJpKEEuVEVYVFVSRV8yRCxBLlRFWFRVUkVfV1JBUF9TLEEuQ0xBTVBfVE9fRURHRSksQS50ZXhQYXJhbWV0ZXJpKEEuVEVYVFVSRV8yRCxBLlRFWFRVUkVfV1JBUF9ULEEuQ0xBTVBfVE9fRURHRSksQS5iaW5kVGV4dHVyZShBLlRFWFRVUkVfMkQsbnVsbCksbmV3IGcoQSxJKX11cGxvYWRCdWZmZXIoQSxJLGcpe2NvbnN0IGU9dGhpcy5nbEN0eDtlLmJpbmRUZXh0dXJlKGUuVEVYVFVSRV8yRCx0aGlzLnRleHR1cmVJZCksZS50ZXhJbWFnZTJEKGUuVEVYVFVSRV8yRCwwLGUuTFVNSU5BTkNFLEksZywwLGUuTFVNSU5BTkNFLGUuVU5TSUdORURfQllURSxBKSxlLmJpbmRUZXh0dXJlKGUuVEVYVFVSRV8yRCxudWxsKX1kZWxldGUoKXtudWxsIT10aGlzLmdsQ3R4JiYwIT10aGlzLnRleHR1cmVJZCYmKHRoaXMuZ2xDdHguZGVsZXRlVGV4dHVyZSh0aGlzLnRleHR1cmVJZCksdGhpcy50ZXh0dXJlSWQ9MCl9fUkuZGVmYXVsdD1nfSw0MjU6ZnVuY3Rpb24oQSxJLGcpe1widXNlIHN0cmljdFwiO3ZhciBlLEI9dGhpcyYmdGhpcy5fX2F3YWl0ZXJ8fGZ1bmN0aW9uKEEsSSxnLGUpe3JldHVybiBuZXcoZ3x8KGc9UHJvbWlzZSkpKChmdW5jdGlvbihCLGkpe2Z1bmN0aW9uIFEoQSl7dHJ5e0MoZS5uZXh0KEEpKX1jYXRjaChBKXtpKEEpfX1mdW5jdGlvbiB0KEEpe3RyeXtDKGUudGhyb3coQSkpfWNhdGNoKEEpe2koQSl9fWZ1bmN0aW9uIEMoQSl7dmFyIEk7QS5kb25lP0IoQS52YWx1ZSk6KEk9QS52YWx1ZSxJIGluc3RhbmNlb2YgZz9JOm5ldyBnKChmdW5jdGlvbihBKXtBKEkpfSkpKS50aGVuKFEsdCl9QygoZT1lLmFwcGx5KEEsSXx8W10pKS5uZXh0KCkpfSkpfSxpPXRoaXMmJnRoaXMuX19jbGFzc1ByaXZhdGVGaWVsZFNldHx8ZnVuY3Rpb24oQSxJLGcpe2lmKCFJLmhhcyhBKSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiYXR0ZW1wdGVkIHRvIHNldCBwcml2YXRlIGZpZWxkIG9uIG5vbi1pbnN0YW5jZVwiKTtyZXR1cm4gSS5zZXQoQSxnKSxnfSxRPXRoaXMmJnRoaXMuX19jbGFzc1ByaXZhdGVGaWVsZEdldHx8ZnVuY3Rpb24oQSxJKXtpZighSS5oYXMoQSkpdGhyb3cgbmV3IFR5cGVFcnJvcihcImF0dGVtcHRlZCB0byBnZXQgcHJpdmF0ZSBmaWVsZCBvbiBub24taW5zdGFuY2VcIik7cmV0dXJuIEkuZ2V0KEEpfTtPYmplY3QuZGVmaW5lUHJvcGVydHkoSSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxJLk1lZGlhTWFuYWdlcj1JLlJhaW53YXlWaWRlb0Zvcm1hdD1JLlJhaW53YXlWaWRlb0RlY29kZXI9dm9pZCAwO2NvbnN0IHQ9Zyg5MDApLEM9Zyg1ODUpLEU9Zyg3OCksbz1nKDkxNCksYT1nKDE0Niksbj1nKDkzMCkscz1nKDkwNCkscj1nKDE0KTt2YXIgZCxoOyFmdW5jdGlvbihBKXtBW0EuTVNFPTBdPVwiTVNFXCIsQVtBLlNvZnR3YXJlPTFdPVwiU29mdHdhcmVcIn0oZD1JLlJhaW53YXlWaWRlb0RlY29kZXJ8fChJLlJhaW53YXlWaWRlb0RlY29kZXI9e30pKSxmdW5jdGlvbihBKXtBW0EuQW5uZXhCPTBdPVwiQW5uZXhCXCIsQVtBLkxlbmd0aFByZWZpeGVkPTFdPVwiTGVuZ3RoUHJlZml4ZWRcIn0oaD1JLlJhaW53YXlWaWRlb0Zvcm1hdHx8KEkuUmFpbndheVZpZGVvRm9ybWF0PXt9KSksSS5NZWRpYU1hbmFnZXI9Y2xhc3N7Y29uc3RydWN0b3IoQSxJLGcsQil7dmFyIG47aWYodGhpcy5jYXB0dXJlTW9kZT1BLHRoaXMuY2hvc2VuVmlkZW9Db25maWc9SSxlLnNldCh0aGlzLHZvaWQgMCksdGhpcy5vdmVybGF5RW5hYmxlZD0hMSx0aGlzLmNhcHR1cmVNb2RlPT09cy5DYXB0dXJlTW9kZS5CWU9GQil0aHJvdyBuZXcgci5SYWlud2F5RXJyb3IoXCJCWU9GQiBtb2RlIHN0cmVhbSBjb25zdW1wdGlvbiBpcyBub3Qgc3VwcG9ydGVkIGluIHRoZSBXZWIgU0RLLlwiKTtpKHRoaXMsZSx7dmlkZW86T2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHtjb2RlY1N0cmluZzondmlkZW8vbXA0OyBjb2RlY3M9XCJhdmMxLjQyYzAyMFwiJ30sdGhpcy5hdXRvZGV0ZWN0VmlkZW9Db25maWd1cmF0aW9uKCkpLGcudmlkZW8pLHZpZGVvUGVyZm9ybWFuY2U6bnVsbCE9PShuPWcudmlkZW9QZXJmb3JtYW5jZSkmJnZvaWQgMCE9PW4/bjp7fSxhdWRpbzpPYmplY3QuYXNzaWduKHt9LGcuYXVkaW8pfSksUSh0aGlzLGUpLnZpZGVvLmRlY29kZXI9PT1kLlNvZnR3YXJlP3RoaXMudmlkZW9TdHJlYW09bmV3IGEuVmlkZW9TdHJlYW1Tb2Z0d2FyZURlY29kZXIoUSh0aGlzLGUpLnZpZGVvLmNvZGVjU3RyaW5nLGguTGVuZ3RoUHJlZml4ZWQpOnRoaXMudmlkZW9TdHJlYW09bmV3IHQuVmlkZW9TdHJlYW1NU0UoUSh0aGlzLGUpLnZpZGVvLmNvZGVjU3RyaW5nKSx0aGlzLmF1ZGlvU3RyZWFtPW5ldyBDLkF1ZGlvU3RyZWFtLHRoaXMuYXVkaW9TdHJlYW0uY29uZmlndXJlKFEodGhpcyxlKS5hdWRpbyksdGhpcy52aWRlb1BlcmZvcm1hbmNlTW9uaXRvcj1uZXcgRS5WaWRlb1BlcmZvcm1hbmNlTW9uaXRvcih0aGlzLnZpZGVvU3RyZWFtLFEodGhpcyxlKS52aWRlb1BlcmZvcm1hbmNlKSx0aGlzLnZpZGVvU3RhdHNPdmVybGF5PW5ldyBvLlZpZGVvU3RhdHNPdmVybGF5KHRoaXMudmlkZW9TdHJlYW0sUSh0aGlzLGUpLnZpZGVvLmRlY29kZXI9PT1kLlNvZnR3YXJlLEIpfWdldCB2aWRlb1JlYWR5U3RhdGVDaGFuZ2VFdmVudCgpe3JldHVybiB0aGlzLnZpZGVvU3RyZWFtLnJlYWR5U3RhdGVDaGFuZ2VFdmVudH1nZXQgdmlkZW9OZWVkc1Jlc3RhcnRFdmVudCgpe3JldHVybiB0aGlzLnZpZGVvU3RyZWFtLm5lZWRzUmVzdGFydEV2ZW50fWdldCBhdWRpb0NvbnRleHQoKXtyZXR1cm4gdGhpcy5hdWRpb1N0cmVhbS5hdWRpb0NvbnRleHR9Z2V0IGN1cnJlbnRTdHJlYW1Cb3VuZHMoKXtyZXR1cm4gdGhpcy5zdHJlYW1Cb3VuZHN9Z2V0IGN1cnJlbnRGdWxsRGVza3RvcEJvdW5kcygpe3JldHVybiB0aGlzLmZ1bGxEZXNrdG9wQm91bmRzfWluaXRpYWxpemUoKXtyZXR1cm4gQih0aGlzLHZvaWQgMCx2b2lkIDAsKGZ1bmN0aW9uKigpe3lpZWxkIHRoaXMuYXVkaW9TdHJlYW0uaW5pdGlhbGl6ZSgpLHRoaXMuYXVkaW9TdHJlYW0ucGxheSgpfSkpfWdldCBjb25maWcoKXtyZXR1cm4gUSh0aGlzLGUpfWF1dG9kZXRlY3RWaWRlb0NvbmZpZ3VyYXRpb24oKXtyZXR1cm57ZGVjb2Rlcjp3aW5kb3cuTWVkaWFTb3VyY2U/ZC5NU0U6ZC5Tb2Z0d2FyZX19c2V0Q29udGFpbmVyKEEpe2lmKHRoaXMudW5zZXRDb250YWluZXIoKSx0aGlzLmNvbnRhaW5lcj1BLHRoaXMuY2FwdHVyZU1vZGU9PT1zLkNhcHR1cmVNb2RlLkFwcElzb2xhdGlvbil7Y29uc3QgQT10aGlzLmNyZWF0ZUlzb2xhdGlvbkNhbnZhc0VsZW1lbnQoKTt0aGlzLnNob3dTdHJlYW1FbGVtZW50KEEpLFEodGhpcyxlKS52aWRlby5kZWNvZGVyPT09ZC5NU0U/dGhpcy5zZXRJc29sYXRpb25Tb3VyY2UodGhpcy5jcmVhdGVWaWRlb0VsZW1lbnQoKSk6dGhpcy5zZXRJc29sYXRpb25Tb3VyY2UodGhpcy5jcmVhdGVDYW52YXNFbGVtZW50KCkpfWVsc2UgUSh0aGlzLGUpLnZpZGVvLmRlY29kZXI9PT1kLk1TRT90aGlzLnNob3dTdHJlYW1FbGVtZW50KHRoaXMuY3JlYXRlVmlkZW9FbGVtZW50KCkpOnRoaXMuc2hvd1N0cmVhbUVsZW1lbnQodGhpcy5jcmVhdGVDYW52YXNFbGVtZW50KCkpO3RoaXMub3ZlcmxheUVuYWJsZWQmJnRoaXMuY3JlYXRlQW5kU2hvd1N0YXRzT3ZlcmxheSgpfXNldElzb2xhdGlvblNvdXJjZShBKXt0aGlzLmlzb2xhdGlvblNvdXJjZT1BfWNyZWF0ZUFuZFNob3dTdGF0c092ZXJsYXkoKXtjb25zdCBBPXRoaXMuY3JlYXRlT3ZlcmxheUNhbnZhc0VsZW1lbnQoKTt0aGlzLnNob3dPdmVybGF5RWxlbWVudChBKSxRKHRoaXMsZSkudmlkZW8uZGVjb2Rlcj09PWQuTVNFP3RoaXMudmlkZW9TdGF0c092ZXJsYXkuc2V0RWxlbWVudHMoe3ZpZGVvOnRoaXMudmlkZW9FbGVtZW50LGNhbnZhczpBLHVzaW5nT3V0cHV0Q2FudmFzOiExfSk6dGhpcy52aWRlb1N0YXRzT3ZlcmxheS5zZXRFbGVtZW50cyh7Y2FudmFzOkEsdXNpbmdPdXRwdXRDYW52YXM6ITF9KX11bnNldENvbnRhaW5lcigpe3ZhciBBLEksZyxlLEIsaSxRLHQ7dGhpcy5kaXNwb3NlVmlkZW9FbGVtZW50KCksdGhpcy5kaXNwb3NlQ2FudmFzRWxlbWVudCgpLHRoaXMuZGlzcG9zZU92ZXJsYXlDYW52YXNFbGVtZW50KCksdGhpcy5kaXNwb3NlSXNvbGF0aW9uQ2FudmFzRWxlbWVudCgpLG51bGw9PT0oST1udWxsPT09KEE9dGhpcy5jb250YWluZXIpfHx2b2lkIDA9PT1BP3ZvaWQgMDpBLnF1ZXJ5U2VsZWN0b3IoXCIucmFpbndheS12aWRlb1wiKSl8fHZvaWQgMD09PUl8fEkucmVtb3ZlKCksbnVsbD09PShlPW51bGw9PT0oZz10aGlzLmNvbnRhaW5lcil8fHZvaWQgMD09PWc/dm9pZCAwOmcucXVlcnlTZWxlY3RvcihcIi5yYWlud2F5LWNhbnZhc1wiKSl8fHZvaWQgMD09PWV8fGUucmVtb3ZlKCksbnVsbD09PShpPW51bGw9PT0oQj10aGlzLmNvbnRhaW5lcil8fHZvaWQgMD09PUI/dm9pZCAwOkIucXVlcnlTZWxlY3RvcihcIi5yYWlud2F5LW92ZXJsYXktY2FudmFzXCIpKXx8dm9pZCAwPT09aXx8aS5yZW1vdmUoKSxudWxsPT09KHQ9bnVsbD09PShRPXRoaXMuY29udGFpbmVyKXx8dm9pZCAwPT09UT92b2lkIDA6US5xdWVyeVNlbGVjdG9yKFwiLnJhaW53YXktaXNvbGF0aW9uLWNhbnZhc1wiKSl8fHZvaWQgMD09PXR8fHQucmVtb3ZlKCksdGhpcy5jb250YWluZXI9dm9pZCAwfXNob3dPdmVybGF5RWxlbWVudChBKXtPYmplY3QuYXNzaWduKEEuc3R5bGUse3Bvc2l0aW9uOlwiYWJzb2x1dGVcIix0b3A6XCIwXCIsYm90dG9tOlwiMFwiLGxlZnQ6XCIwXCIscmlnaHQ6XCIwXCIsd2lkdGg6XCIxMDAlXCIsaGVpZ2h0OlwiMTAwJVwiLHBvaW50ZXJFdmVudHM6XCJub25lXCJ9KX1jcmVhdGVWaWRlb0VsZW1lbnQoKXt2YXIgQSxJO251bGw9PT0oST1udWxsPT09KEE9dGhpcy5jb250YWluZXIpfHx2b2lkIDA9PT1BP3ZvaWQgMDpBLnF1ZXJ5U2VsZWN0b3IoXCIucmFpbndheS12aWRlb1wiKSl8fHZvaWQgMD09PUl8fEkucmVtb3ZlKCksdGhpcy52aWRlb0VsZW1lbnQ9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInZpZGVvXCIpO2NvbnN0IGc9dGhpcy52aWRlb0VsZW1lbnQ7cmV0dXJuIGcuY2xhc3NOYW1lPVwicmFpbndheS12aWRlb1wiLGcuYXV0b3BsYXk9ITAsZy5tdXRlZD0hMCxnLnN0eWxlLmRpc3BsYXk9XCJub25lXCIsdGhpcy5jb250YWluZXIuYXBwZW5kQ2hpbGQoZyksdGhpcy52aWRlb1N0cmVhbS5hdHRhY2hUb0VsZW1lbnQoZyksdGhpcy52aWRlb0VsZW1lbnR9ZGlzcG9zZVZpZGVvRWxlbWVudCgpe3RoaXMudmlkZW9FbGVtZW50JiYodGhpcy52aWRlb1N0cmVhbS5kZXRhY2hGcm9tRWxlbWVudCgpLHRoaXMudmlkZW9FbGVtZW50LnJlbW92ZSgpLHRoaXMudmlkZW9FbGVtZW50PXZvaWQgMCl9Y3JlYXRlT3ZlcmxheUNhbnZhc0VsZW1lbnQoKXt2YXIgQSxJLGc7bnVsbD09PShJPW51bGw9PT0oQT10aGlzLmNvbnRhaW5lcil8fHZvaWQgMD09PUE/dm9pZCAwOkEucXVlcnlTZWxlY3RvcihcIi5yYWlud2F5LW92ZXJsYXktY2FudmFzXCIpKXx8dm9pZCAwPT09SXx8SS5yZW1vdmUoKSx0aGlzLmNhbnZhc0VsZW1lbnQ9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtjb25zdCBlPXRoaXMuY2FudmFzRWxlbWVudDtyZXR1cm4gZS5jbGFzc05hbWU9XCJyYWlud2F5LW92ZXJsYXktY2FudmFzXCIsdGhpcy5jb250YWluZXIuYXBwZW5kQ2hpbGQoZSksbnVsbD09PShnPWUuZ2V0Q29udGV4dChcIjJkXCIpKXx8dm9pZCAwPT09Z3x8Zy5jbGVhclJlY3QoMCwwLGUud2lkdGgsZS5oZWlnaHQpLGV9ZGlzcG9zZU92ZXJsYXlDYW52YXNFbGVtZW50KCl7dmFyIEEsSTtudWxsPT09KEk9bnVsbD09PShBPXRoaXMuY29udGFpbmVyKXx8dm9pZCAwPT09QT92b2lkIDA6QS5xdWVyeVNlbGVjdG9yKFwiLnJhaW53YXktb3ZlcmxheS1jYW52YXNcIikpfHx2b2lkIDA9PT1JfHxJLnJlbW92ZSgpLHRoaXMub3ZlcmxheUNhbnZhc0VsZW1lbnQmJih0aGlzLm92ZXJsYXlDYW52YXNFbGVtZW50LnJlbW92ZSgpLHRoaXMub3ZlcmxheUNhbnZhc0VsZW1lbnQ9dm9pZCAwKX1jcmVhdGVDYW52YXNFbGVtZW50KCl7dmFyIEEsSSxnO251bGw9PT0oST1udWxsPT09KEE9dGhpcy5jb250YWluZXIpfHx2b2lkIDA9PT1BP3ZvaWQgMDpBLnF1ZXJ5U2VsZWN0b3IoXCIucmFpbndheS1jYW52YXNcIikpfHx2b2lkIDA9PT1JfHxJLnJlbW92ZSgpLHRoaXMuY2FudmFzRWxlbWVudD1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO2NvbnN0IGU9dGhpcy5jYW52YXNFbGVtZW50O3JldHVybiBlLmNsYXNzTmFtZT1cInJhaW53YXktY2FudmFzXCIsZS5zdHlsZS5kaXNwbGF5PVwibm9uZVwiLHRoaXMuY29udGFpbmVyLmFwcGVuZENoaWxkKGUpLHRoaXMudmlkZW9TdHJlYW0gaW5zdGFuY2VvZiBhLlZpZGVvU3RyZWFtU29mdHdhcmVEZWNvZGVyJiZ0aGlzLnZpZGVvU3RyZWFtLmF0dGFjaFRvQ2FudmFzKGUpLG51bGw9PT0oZz1lLmdldENvbnRleHQoXCIyZFwiKSl8fHZvaWQgMD09PWd8fGcuY2xlYXJSZWN0KDAsMCxlLndpZHRoLGUuaGVpZ2h0KSxlfWRpc3Bvc2VDYW52YXNFbGVtZW50KCl7dGhpcy5jYW52YXNFbGVtZW50JiYodGhpcy52aWRlb1N0cmVhbSBpbnN0YW5jZW9mIGEuVmlkZW9TdHJlYW1Tb2Z0d2FyZURlY29kZXImJnRoaXMudmlkZW9TdHJlYW0uZGV0YWNoRnJvbUNhbnZhcygpLHRoaXMuY2FudmFzRWxlbWVudC5yZW1vdmUoKSx0aGlzLmNhbnZhc0VsZW1lbnQ9dm9pZCAwKX1jcmVhdGVJc29sYXRpb25DYW52YXNFbGVtZW50KCl7dmFyIEEsSSxnO251bGw9PT0oST1udWxsPT09KEE9dGhpcy5jb250YWluZXIpfHx2b2lkIDA9PT1BP3ZvaWQgMDpBLnF1ZXJ5U2VsZWN0b3IoXCIucmFpbndheS1pc29sYXRpb24tY2FudmFzXCIpKXx8dm9pZCAwPT09SXx8SS5yZW1vdmUoKSx0aGlzLmlzb2xhdGlvbkNhbnZhc0VsZW1lbnQ9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtjb25zdCBlPXRoaXMuaXNvbGF0aW9uQ2FudmFzRWxlbWVudDtyZXR1cm4gZS5jbGFzc05hbWU9XCJyYWlud2F5LWlzb2xhdGlvbi1jYW52YXNcIix0aGlzLmNvbnRhaW5lci5hcHBlbmRDaGlsZChlKSxudWxsPT09KGc9ZS5nZXRDb250ZXh0KFwiMmRcIikpfHx2b2lkIDA9PT1nfHxnLmNsZWFyUmVjdCgwLDAsZS53aWR0aCxlLmhlaWdodCksZX1kaXNwb3NlSXNvbGF0aW9uQ2FudmFzRWxlbWVudCgpe3RoaXMuaXNvbGF0aW9uQ2FudmFzRWxlbWVudCYmKHRoaXMuaXNvbGF0aW9uQ2FudmFzRWxlbWVudC5yZW1vdmUoKSx0aGlzLmlzb2xhdGlvbkNhbnZhc0VsZW1lbnQ9dm9pZCAwKX1oaWRlU3RyZWFtRWxlbWVudChBKXtBLnN0eWxlLndpZHRoPVwiMFwiLEEuc3R5bGUuaGVpZ2h0PVwiMFwifXNob3dTdHJlYW1FbGVtZW50KEEpe3RoaXMuY29udGFpbmVyJiYodGhpcy5zdHJlYW1FbGVtZW50PUEsQS5zdHlsZS53aWR0aD1cIjEwMCVcIixBLnN0eWxlLmhlaWdodD1cIjEwMCVcIixBLnN0eWxlLmRpc3BsYXk9XCJibG9ja1wiLEEuc3R5bGUub2JqZWN0Rml0PVwiY29udGFpblwiKX1wYXVzZSgpe3RoaXMudmlkZW9TdHJlYW0ucGF1c2UoKSx0aGlzLmF1ZGlvU3RyZWFtLnN0b3AoKX1wbGF5KCl7dGhpcy52aWRlb1N0cmVhbS5wbGF5KCksdGhpcy5hdWRpb1N0cmVhbS5wbGF5KCl9cmVuZGVyVmlkZW9GcmFtZShBLEkpe3RoaXMudmlkZW9TdHJlYW0ucHVzaERhdGEoQSxJKSx0aGlzLmZ1bGxEZXNrdG9wQm91bmRzPXtsZWZ0OkEueCx0b3A6QS55LHdpZHRoOkEud2lkdGgsaGVpZ2h0OkEuaGVpZ2h0fSx0aGlzLmNhcHR1cmVNb2RlPT09cy5DYXB0dXJlTW9kZS5BcHBJc29sYXRpb24/KEEubWFzay5sZW5ndGg+MCYmKHRoaXMubWFzaz1BLm1hc2spLEEud2lkdGg+MCYmKHRoaXMuZnJhbWVXaWR0aD1BLndpZHRoKSxBLmhlaWdodD4wJiYodGhpcy5mcmFtZUhlaWdodD1BLmhlaWdodCksdGhpcy5yZW5kZXJJc29sYXRlZEFwcCgpKTp0aGlzLnN0cmVhbUJvdW5kcz10aGlzLmZ1bGxEZXNrdG9wQm91bmRzfXJlbmRlcklzb2xhdGVkQXBwKCl7aWYoIXRoaXMubWFzaylyZXR1cm47aWYoIXRoaXMuZnJhbWVXaWR0aClyZXR1cm47aWYoIXRoaXMuZnJhbWVIZWlnaHQpcmV0dXJuO2NvbnN0IEE9dGhpcy5pc29sYXRpb25Tb3VyY2U7aWYoIUEpcmV0dXJuO2NvbnN0IEk9dGhpcy5pc29sYXRpb25DYW52YXNFbGVtZW50O2lmKCFJKXJldHVybjtjb25zdCBnPUkuZ2V0Q29udGV4dChcIjJkXCIpO2lmKCFnKXJldHVybjtjb25zdCBlPW4uYm91bmRpbmdSZWN0YW5nbGUodGhpcy5tYXNrKTt0aGlzLnN0cmVhbUJvdW5kcz1lO2NvbnN0IEI9dGhpcy5jaG9zZW5WaWRlb0NvbmZpZy5jb2RlYy53aWR0aC90aGlzLmZyYW1lV2lkdGgsaT10aGlzLmNob3NlblZpZGVvQ29uZmlnLmNvZGVjLmhlaWdodC90aGlzLmZyYW1lSGVpZ2h0O0kud2lkdGg9ZS53aWR0aCpCLEkuaGVpZ2h0PWUuaGVpZ2h0Kmk7Zm9yKGNvbnN0e2xlZnQ6SSx0b3A6USx3aWR0aDp0LGhlaWdodDpDfW9mIHRoaXMubWFzayl7Y29uc3QgRT1JKkIsbz1RKmksYT10KkIsbj1DKmkscz0oSS1lLmxlZnQpKkIscj0oUS1lLnRvcCkqaTtnLmRyYXdJbWFnZShBLEUsbyxhLG4scyxyLGEsbil9fXByb2Nlc3NBdWRpbyhBKXt0aGlzLmF1ZGlvU3RyZWFtLnB1c2hEYXRhKEEpfWdldFZpZGVvU3RhdHMoKXtyZXR1cm4gdGhpcy52aWRlb1N0cmVhbS5nZXRTdGF0cygpfWNvbmZpZ3VyZUF1ZGlvKEEpe3JldHVybiBCKHRoaXMsdm9pZCAwLHZvaWQgMCwoZnVuY3Rpb24qKCl7USh0aGlzLGUpLmF1ZGlvPU9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSxRKHRoaXMsZSkuYXVkaW8pLEEpLHRoaXMuYXVkaW9TdHJlYW0uY29uZmlndXJlKEEpfSkpfWVuYWJsZVN0YXRzT3ZlcmxheSgpe3RoaXMub3ZlcmxheUVuYWJsZWQ9ITAsdGhpcy52aWRlb1N0YXRzT3ZlcmxheS5lbmFibGUoKSx0aGlzLmRpc3Bvc2VPdmVybGF5Q2FudmFzRWxlbWVudCgpLHRoaXMuY3JlYXRlQW5kU2hvd1N0YXRzT3ZlcmxheSgpfWRpc2FibGVTdGF0c092ZXJsYXkoKXt0aGlzLmRpc3Bvc2VPdmVybGF5Q2FudmFzRWxlbWVudCgpLHRoaXMub3ZlcmxheUVuYWJsZWQ9ITEsdGhpcy52aWRlb1N0YXRzT3ZlcmxheS5kaXNhYmxlKCl9ZGlzcG9zZSgpe3RoaXMucGF1c2UoKSx0aGlzLnVuc2V0Q29udGFpbmVyKCksdGhpcy5hdWRpb1N0cmVhbS5kaXNwb3NlKCksdGhpcy52aWRlb1N0cmVhbS5kaXNwb3NlKCl9c2V0Vm9sdW1lKEEpe3RoaXMuYXVkaW9TdHJlYW0uc2V0Vm9sdW1lKEEpfX0sZT1uZXcgV2Vha01hcH0sNjMzOmZ1bmN0aW9uKEEsSSl7XCJ1c2Ugc3RyaWN0XCI7dmFyIGcsZT10aGlzJiZ0aGlzLl9fYXdhaXRlcnx8ZnVuY3Rpb24oQSxJLGcsZSl7cmV0dXJuIG5ldyhnfHwoZz1Qcm9taXNlKSkoKGZ1bmN0aW9uKEIsaSl7ZnVuY3Rpb24gUShBKXt0cnl7QyhlLm5leHQoQSkpfWNhdGNoKEEpe2koQSl9fWZ1bmN0aW9uIHQoQSl7dHJ5e0MoZS50aHJvdyhBKSl9Y2F0Y2goQSl7aShBKX19ZnVuY3Rpb24gQyhBKXt2YXIgSTtBLmRvbmU/QihBLnZhbHVlKTooST1BLnZhbHVlLEkgaW5zdGFuY2VvZiBnP0k6bmV3IGcoKGZ1bmN0aW9uKEEpe0EoSSl9KSkpLnRoZW4oUSx0KX1DKChlPWUuYXBwbHkoQSxJfHxbXSkpLm5leHQoKSl9KSl9LEI9dGhpcyYmdGhpcy5fX2NsYXNzUHJpdmF0ZUZpZWxkR2V0fHxmdW5jdGlvbihBLEkpe2lmKCFJLmhhcyhBKSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiYXR0ZW1wdGVkIHRvIGdldCBwcml2YXRlIGZpZWxkIG9uIG5vbi1pbnN0YW5jZVwiKTtyZXR1cm4gSS5nZXQoQSl9LGk9dGhpcyYmdGhpcy5fX2NsYXNzUHJpdmF0ZUZpZWxkU2V0fHxmdW5jdGlvbihBLEksZyl7aWYoIUkuaGFzKEEpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJhdHRlbXB0ZWQgdG8gc2V0IHByaXZhdGUgZmllbGQgb24gbm9uLWluc3RhbmNlXCIpO3JldHVybiBJLnNldChBLGcpLGd9O09iamVjdC5kZWZpbmVQcm9wZXJ0eShJLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLEkuQ2lyY3VsYXJCdWZmZXI9SS5hdmVyYWdlPUkuY3JlYXRlU291cmNlQnVmZmVyPUkuYXdhaXRNZWRpYVNvdXJjZU9wZW49SS5jcmVhdGVNZWRpYVNvdXJjZT1JLk1lZGlhVW5zdXBwb3J0ZWRFcnJvcj12b2lkIDA7Y2xhc3MgUSBleHRlbmRzIEVycm9ye31mdW5jdGlvbiB0KEEsSSl7cmV0dXJuIGUodGhpcyx2b2lkIDAsdm9pZCAwLChmdW5jdGlvbiooKXtyZXR1cm4gbmV3IFByb21pc2UoKChnLGUpPT57bGV0IEI9ITE7Y29uc3QgaT0oKT0+e0EucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInNvdXJjZW9wZW5cIixRKSxudWxsPT1JfHxJLnJlbW92ZUhhbmRsZXIoRSksd2luZG93LmNsZWFySW50ZXJ2YWwoQyksQj0hMH0sUT0oKT0+e2koKSxnKCEwKX0sdD0oKT0+e0J8fFwib3BlblwiPT09QS5yZWFkeVN0YXRlJiYoaSgpLGcoITApKX0sQz13aW5kb3cuc2V0SW50ZXJ2YWwodCw1MDApO3QoKSx3aW5kb3cuc2V0VGltZW91dCgoKCk9PntCfHwoaSgpLGUobmV3IEVycm9yKFwiTWVkaWFTb3VyY2Ugb3BlbiB0aW1lZCBvdXQuXCIpKSl9KSwxZTQpLEEuYWRkRXZlbnRMaXN0ZW5lcihcInNvdXJjZW9wZW5cIixRKTtjb25zdCBFPSgpPT57aSgpLGcoITEpfTtudWxsPT1JfHxJLmFkZEhhbmRsZXIoRSl9KSl9KSl9SS5NZWRpYVVuc3VwcG9ydGVkRXJyb3I9USxJLmNyZWF0ZU1lZGlhU291cmNlPWZ1bmN0aW9uKEEsSSl7cmV0dXJuIGUodGhpcyx2b2lkIDAsdm9pZCAwLChmdW5jdGlvbiooKXtpZighd2luZG93Lk1lZGlhU291cmNlKXRocm93IG5ldyBRKFwiQnJvd3NlciBkb2VzIG5vdCBzdXBwb3J0IE1TRS5cIik7Y29uc3QgZz1uZXcgTWVkaWFTb3VyY2UsZT13aW5kb3cuVVJMLmNyZWF0ZU9iamVjdFVSTChnKTtpZihBLnNyYz12b2lkIDAsQS5zcmM9ZSxBLmxvYWQoKSx5aWVsZCB0KGcsSSkpcmV0dXJuIGcuZHVyYXRpb249TnVtYmVyLlBPU0lUSVZFX0lORklOSVRZLGd9KSl9LEkuYXdhaXRNZWRpYVNvdXJjZU9wZW49dCxJLmNyZWF0ZVNvdXJjZUJ1ZmZlcj1mdW5jdGlvbihBLEkpe2NvbnN0IGc9QS5hZGRTb3VyY2VCdWZmZXIoSSk7cmV0dXJuIGcubW9kZT1cInNlcXVlbmNlXCIsZ30sSS5hdmVyYWdlPWZ1bmN0aW9uKEEpe3JldHVybiAwPT09QS5sZW5ndGg/MDpBLnJlZHVjZSgoKEEsSSk9PkErSSksMCkvQS5sZW5ndGh9LEkuQ2lyY3VsYXJCdWZmZXI9Y2xhc3N7Y29uc3RydWN0b3IoQSl7dGhpcy5tYXhMZW5ndGg9QSx0aGlzLm5leHRJbmRleD0wLHRoaXMubGlzdD1BcnJheSh0aGlzLm1heExlbmd0aCksZy5zZXQodGhpcywwKX1nZXQgbGVuZ3RoKCl7cmV0dXJuIEIodGhpcyxnKX1wdXNoKEEpe3RoaXMubGlzdFt0aGlzLm5leHRJbmRleCsrXT1BLGkodGhpcyxnLE1hdGgubWF4KEIodGhpcyxnKSx0aGlzLm5leHRJbmRleCkpLHRoaXMubmV4dEluZGV4JT10aGlzLm1heExlbmd0aH12YWx1ZXMoKXtyZXR1cm4gdGhpcy5saXN0LnNsaWNlKDAsQih0aGlzLGcpKX19LGc9bmV3IFdlYWtNYXB9LDc4OihBLEksZyk9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkoSSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxJLlZpZGVvUGVyZm9ybWFuY2VNb25pdG9yPXZvaWQgMDtjb25zdCBlPWcoMTk4KSxCPWcoNDM0KSxpPWcoMjQpLFE9e3RhcmdldEZyYW1lcmF0ZTo2MCxidWZmZXJMaW1pdE1zOjUwMCxjcHVTdGFydmF0aW9uVGhyZXNob2xkOjEsZGVjb2RlclN0cnVnZ2xpbmdUaHJlc2hvbGQ6MSxjaGVja0ludGVydmFsOjE1MDAsd2luZG93TXM6NTAwfTtJLlZpZGVvUGVyZm9ybWFuY2VNb25pdG9yPWNsYXNze2NvbnN0cnVjdG9yKEEsST17fSl7dGhpcy52aWRlb1N0cmVhbT1BLHRoaXMuZGVjb2RlclN0cnVnZ2xpbmdFdmVudD1uZXcgaS5BY3Rpb24sdGhpcy5jcHVTdGFydmF0aW9uRXZlbnQ9bmV3IGkuQWN0aW9uLHRoaXMuY3B1U3RhcnZhdGlvbkNvdW50ZXI9MCx0aGlzLmRlY29kZXJTdHJ1Z2dsaW5nQ291bnRlcj0wLHRoaXMucmVhZHlTdGF0ZUNoYW5nZUhhbmRsZXI9QT0+e0E9PT1CLlZpZGVvUmVhZHlTdGF0ZS5EZXRhY2hlZD90aGlzLnN0b3BDaGVja2luZygpOnRoaXMubGFzdFZpZGVvUmVhZHlTdGF0ZT09PUIuVmlkZW9SZWFkeVN0YXRlLkRldGFjaGVkJiZ0aGlzLnN0YXJ0Q2hlY2tpbmcoKSx0aGlzLmxhc3RWaWRlb1JlYWR5U3RhdGU9QX0sdGhpcy52aWRlb0ZyYW1lTWV0YWRhdGFIYW5kbGVyPUE9Pnt0aGlzLnByb2Nlc3NpbmdEdXJhdGlvblRyYWNrLmZlZWQoQSl9LHRoaXMuY2hlY2tQZXJmb3JtYW5jZT0oKT0+e2lmKHRoaXMudmlkZW9TdHJlYW0ucmVhZHlTdGF0ZT09PUIuVmlkZW9SZWFkeVN0YXRlLlBsYXlpbmcpe2NvbnN0IEE9MS90aGlzLmNvbmZpZy50YXJnZXRGcmFtZXJhdGUsST0xZTMqQSxnPU1hdGguZmxvb3IodGhpcy5jb25maWcuYnVmZmVyTGltaXRNcy9JKSxlPXRoaXMudmlkZW9TdHJlYW0uZ2V0U3RhdHMoKTsoZS5lbmRPZkJ1ZmZlcmVkPmUuY3VycmVudFRpbWUrdGhpcy5jb25maWcuYnVmZmVyTGltaXRNcy8xZTN8fHRoaXMudmlkZW9TdHJlYW0uZGF0YVF1ZXVlTGVuZ3RoPmcpJiZ0aGlzLnZpZGVvU3RyZWFtLnJlc3RhcnQoXCJjaGVja1BlcmZvcm1hbmNlXCIpLHRoaXMudmlkZW9TdHJlYW0uZGF0YVF1ZXVlTGVuZ3RoPmc/dGhpcy5jcHVTdGFydmF0aW9uQ291bnRlcis9MTp0aGlzLmNwdVN0YXJ2YXRpb25Db3VudGVyPU1hdGgubWF4KDAsdGhpcy5jcHVTdGFydmF0aW9uQ291bnRlci0xKSx0aGlzLnByb2Nlc3NpbmdEdXJhdGlvblRyYWNrLmF2ZXJhZ2UoKT5BPyh0aGlzLmRlY29kZXJTdHJ1Z2dsaW5nQ291bnRlcis9MSx0aGlzLmNwdVN0YXJ2YXRpb25Db3VudGVyPU1hdGgubWF4KDAsdGhpcy5jcHVTdGFydmF0aW9uQ291bnRlci0xKSk6dGhpcy5kZWNvZGVyU3RydWdnbGluZ0NvdW50ZXI9TWF0aC5tYXgoMCx0aGlzLmRlY29kZXJTdHJ1Z2dsaW5nQ291bnRlci0xKSx0aGlzLmNwdVN0YXJ2YXRpb25Db3VudGVyLHRoaXMuY29uZmlnLmNwdVN0YXJ2YXRpb25UaHJlc2hvbGQsdGhpcy5kZWNvZGVyU3RydWdnbGluZ0NvdW50ZXIsdGhpcy5jb25maWcuZGVjb2RlclN0cnVnZ2xpbmdUaHJlc2hvbGR9fSx0aGlzLmNvbmZpZz1PYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sUSksSSksdGhpcy5wcm9jZXNzaW5nRHVyYXRpb25UcmFjaz1uZXcgZS5XaW5kb3dUcmFjayh0aGlzLmNvbmZpZy53aW5kb3dNcyxlLm1lYW5Pclplcm8pLHRoaXMudmlkZW9TdHJlYW0ucmVhZHlTdGF0ZUNoYW5nZUV2ZW50LmFkZEhhbmRsZXIodGhpcy5yZWFkeVN0YXRlQ2hhbmdlSGFuZGxlciksdGhpcy52aWRlb1N0cmVhbS52aWRlb0ZyYW1lUHJvY2Vzc2luZ0R1cmF0aW9uRXZlbnQuYWRkSGFuZGxlcih0aGlzLnZpZGVvRnJhbWVNZXRhZGF0YUhhbmRsZXIpLHRoaXMubGFzdFZpZGVvUmVhZHlTdGF0ZT10aGlzLnZpZGVvU3RyZWFtLnJlYWR5U3RhdGUsdGhpcy52aWRlb1N0cmVhbS5yZWFkeVN0YXRlIT09Qi5WaWRlb1JlYWR5U3RhdGUuRGV0YWNoZWQmJnRoaXMuc3RhcnRDaGVja2luZygpfWRpc3Bvc2UoKXt0aGlzLnN0b3BDaGVja2luZygpLHRoaXMudmlkZW9TdHJlYW0ucmVhZHlTdGF0ZUNoYW5nZUV2ZW50LnJlbW92ZUhhbmRsZXIodGhpcy5yZWFkeVN0YXRlQ2hhbmdlSGFuZGxlciksdGhpcy52aWRlb1N0cmVhbS52aWRlb0ZyYW1lUHJvY2Vzc2luZ0R1cmF0aW9uRXZlbnQucmVtb3ZlSGFuZGxlcih0aGlzLnZpZGVvRnJhbWVNZXRhZGF0YUhhbmRsZXIpfXN0YXJ0Q2hlY2tpbmcoKXt0aGlzLnByb2Nlc3NpbmdEdXJhdGlvblRyYWNrPW5ldyBlLldpbmRvd1RyYWNrKHRoaXMuY29uZmlnLndpbmRvd01zLGUubWVhbk9yWmVybyksdGhpcy5jaGVja1BlcmZvcm1hbmNlSW50ZXJ2YWw9d2luZG93LnNldEludGVydmFsKHRoaXMuY2hlY2tQZXJmb3JtYW5jZSx0aGlzLmNvbmZpZy5jaGVja0ludGVydmFsKX1zdG9wQ2hlY2tpbmcoKXt0aGlzLmNoZWNrUGVyZm9ybWFuY2VJbnRlcnZhbCYmKHdpbmRvdy5jbGVhckludGVydmFsKHRoaXMuY2hlY2tQZXJmb3JtYW5jZUludGVydmFsKSx0aGlzLmNoZWNrUGVyZm9ybWFuY2VJbnRlcnZhbD12b2lkIDApfX19LDkxNDpmdW5jdGlvbihBLEksZyl7XCJ1c2Ugc3RyaWN0XCI7dmFyIGU9dGhpcyYmdGhpcy5fX2F3YWl0ZXJ8fGZ1bmN0aW9uKEEsSSxnLGUpe3JldHVybiBuZXcoZ3x8KGc9UHJvbWlzZSkpKChmdW5jdGlvbihCLGkpe2Z1bmN0aW9uIFEoQSl7dHJ5e0MoZS5uZXh0KEEpKX1jYXRjaChBKXtpKEEpfX1mdW5jdGlvbiB0KEEpe3RyeXtDKGUudGhyb3coQSkpfWNhdGNoKEEpe2koQSl9fWZ1bmN0aW9uIEMoQSl7dmFyIEk7QS5kb25lP0IoQS52YWx1ZSk6KEk9QS52YWx1ZSxJIGluc3RhbmNlb2YgZz9JOm5ldyBnKChmdW5jdGlvbihBKXtBKEkpfSkpKS50aGVuKFEsdCl9QygoZT1lLmFwcGx5KEEsSXx8W10pKS5uZXh0KCkpfSkpfTtPYmplY3QuZGVmaW5lUHJvcGVydHkoSSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxJLlZpZGVvU3RhdHNPdmVybGF5PXZvaWQgMDtjb25zdCBCPWcoMTQ2KSxpPWcoNDM0KSxRPWcoMTk4KSx0PTVlMyxDPXtkcm9wcGVkRnJhbWVzOlwiRHJvcHBlZCBmcmFtZXNcIix0b3RhbEZyYW1lczpcIlRvdGFsIGZyYW1lc1wiLGN1cnJlbnRUaW1lOlwiQ3VycmVudCB2aWRlbyB0aW1lXCIsZW5kT2ZCdWZmZXJlZDpcIkVuZCBvZiB2aWRlbyBidWZmZXJcIixlbmRPZlNlZWthYmxlOlwiRW5kIG9mIHZpZGVvIHNlZWthYmxlXCIsZGF0YUludGVydmFsOlwiVmlkZW8gZGF0YSBpbnRlcnZhbFwiLGRhdGFTaXplOlwiVmlkZW8gZnJhbWUgc2l6ZVwiLHByb2Nlc3NpbmdEdXJhdGlvbjpcIkZyYW1lIHByb2Nlc3NpbmcgZHVyYXRpb25cIn07SS5WaWRlb1N0YXRzT3ZlcmxheT1jbGFzc3tjb25zdHJ1Y3RvcihBLEksZyl7dGhpcy52aWRlb1N0cmVhbT1BLHRoaXMudXNpbmdPdXRwdXRDYW52YXM9SSx0aGlzLmdldFN0YXRzPWcsdGhpcy5jb21wb3NpdGluZ1RpbWVUcmFjaz1uZXcgUS5XaW5kb3dUcmFjayh0LFEubWVhbiksdGhpcy5wcm9jZXNzaW5nRHVyYXRpb25UcmFjaz1uZXcgUS5XaW5kb3dUcmFjayh0LFEubWVhbiksdGhpcy5mcmFtZVRyYWNrPW5ldyBRLldpbmRvd1RyYWNrKHQsUS5tZWFuKSx0aGlzLmRyYXdJbnRlcnZhbFRyYWNrPW5ldyBRLldpbmRvd1RyYWNrKHQsUS5tZWFuKSx0aGlzLmRpc3BsYXlUaW1lSW50ZXJ2YWxUcmFjaz1uZXcgUS5XaW5kb3dUcmFjayh0LFEubWVhbiksdGhpcy5mcmFtZUNvdW50ZXI9MCx0aGlzLnRocm91Z2hwdXQ9W10sdGhpcy5mZXRjaFN0YXRzPSgpPT5lKHRoaXMsdm9pZCAwLHZvaWQgMCwoZnVuY3Rpb24qKCl7dGhpcy52aWRlb1N0cmVhbS5yZWFkeVN0YXRlPT09aS5WaWRlb1JlYWR5U3RhdGUuUGxheWluZyYmKHRoaXMuc3RhdHM9dGhpcy52aWRlb1N0cmVhbS5nZXRTdGF0cygpLHRoaXMubGFzdFRyYW5zcG9ydFN0YXRzPXRoaXMudHJhbnNwb3J0U3RhdHMsdGhpcy50cmFuc3BvcnRTdGF0cz15aWVsZCB0aGlzLmdldFN0YXRzKCksdGhpcy50aHJvdWdocHV0PXRoaXMuZ2V0VGhyb3VnaHB1dCgpKX0pKSx0aGlzLmFuaW1hdGlvbkZyYW1lSGFuZGxlcj0oKT0+e3RoaXMuZnJhbWVUcmFjay5mZWVkKHRoaXMuZnJhbWVDb3VudGVyKSx0aGlzLmZyYW1lQ291bnRlcj0wLHRoaXMuYW5pbWF0aW9uRnJhbWVIYW5kbGU9d2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSh0aGlzLmFuaW1hdGlvbkZyYW1lSGFuZGxlcil9LHRoaXMuZHJhd1N0YXRzT25seU9uQW5pbWF0aW9uRnJhbWU9KCk9PntpZih0aGlzLmRyYXdTdGF0c09ubHlIYW5kbGU9d2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSh0aGlzLmRyYXdTdGF0c09ubHlPbkFuaW1hdGlvbkZyYW1lKSwhdGhpcy5jYW52YXNDb250ZXh0fHx0aGlzLnZpZGVvU3RyZWFtLnJlYWR5U3RhdGUhPT1pLlZpZGVvUmVhZHlTdGF0ZS5QbGF5aW5nKXJldHVybjtjb25zdCBBPXRoaXMuY2FudmFzQ29udGV4dDt0aGlzLnVzaW5nT3V0cHV0Q2FudmFzfHwoQS5jYW52YXMud2lkdGghPT1BLmNhbnZhcy5jbGllbnRXaWR0aCYmKEEuY2FudmFzLndpZHRoPUEuY2FudmFzLmNsaWVudFdpZHRoKSxBLmNhbnZhcy5oZWlnaHQhPT1BLmNhbnZhcy5jbGllbnRIZWlnaHQmJihBLmNhbnZhcy5oZWlnaHQ9QS5jYW52YXMuY2xpZW50SGVpZ2h0KSxBLmNsZWFyUmVjdCgwLDAsQS5jYW52YXMud2lkdGgsQS5jYW52YXMuaGVpZ2h0KSksdGhpcy5kcmF3U3RhdHMoKX0sdGhpcy5kcmF3U3RhdHNBbmRHcmFwaHNPblZpZGVvRnJhbWU9KFtBLEldKT0+e2lmKHRoaXMuZnJhbWVDb3VudGVyKyssIXRoaXMuY2FudmFzQ29udGV4dHx8dGhpcy52aWRlb1N0cmVhbS5yZWFkeVN0YXRlIT09aS5WaWRlb1JlYWR5U3RhdGUuUGxheWluZ3x8IUkpcmV0dXJuO2NvbnN0IGc9dGhpcy5jYW52YXNDb250ZXh0O3RoaXMudXNpbmdPdXRwdXRDYW52YXN8fChnLmNhbnZhcy53aWR0aCE9PWcuY2FudmFzLmNsaWVudFdpZHRoJiYoZy5jYW52YXMud2lkdGg9Zy5jYW52YXMuY2xpZW50V2lkdGgpLGcuY2FudmFzLmhlaWdodCE9PWcuY2FudmFzLmNsaWVudEhlaWdodCYmKGcuY2FudmFzLmhlaWdodD1nLmNhbnZhcy5jbGllbnRIZWlnaHQpLGcuY2xlYXJSZWN0KDAsMCxnLmNhbnZhcy53aWR0aCxnLmNhbnZhcy5oZWlnaHQpKTtjb25zdCBlPXBlcmZvcm1hbmNlLm5vdygpO3RoaXMubGFzdENhbnZhc0RyYXdUaW1lJiZ0aGlzLmRyYXdJbnRlcnZhbFRyYWNrLmZlZWQoZS10aGlzLmxhc3RDYW52YXNEcmF3VGltZSksdGhpcy5sYXN0Q2FudmFzRHJhd1RpbWU9ZTtjb25zdCBCPUkuZXhwZWN0ZWREaXNwbGF5VGltZTt0aGlzLmxhc3REaXNwbGF5VGltZSYmdGhpcy5kaXNwbGF5VGltZUludGVydmFsVHJhY2suZmVlZChCLXRoaXMubGFzdERpc3BsYXlUaW1lKSx0aGlzLmxhc3REaXNwbGF5VGltZT1CLHRoaXMuY29tcG9zaXRpbmdUaW1lVHJhY2suZmVlZChJLmV4cGVjdGVkRGlzcGxheVRpbWUtQSksdGhpcy5wcm9jZXNzaW5nRHVyYXRpb25UcmFjay5mZWVkKEkucHJvY2Vzc2luZ0R1cmF0aW9uKTtjb25zdCBRPWcuY2FudmFzO1Eud2lkdGgsUS5jbGllbnRXaWR0aCxRLmhlaWdodCxRLmNsaWVudEhlaWdodCx0aGlzLmRyYXdTdGF0cyhJKX19c2V0RWxlbWVudHMoe3ZpZGVvOkEsY2FudmFzOkksdXNpbmdPdXRwdXRDYW52YXM6Zz0hMX0pe3RoaXMudXNpbmdPdXRwdXRDYW52YXM9Zyx0aGlzLmNhbnZhcz1JLHRoaXMudmlkZW89QSx0aGlzLmNhbnZhcyYmKHRoaXMuY2FudmFzQ29udGV4dD10aGlzLmNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIix7YWxwaGE6IXRoaXMudXNpbmdPdXRwdXRDYW52YXN9KSl9ZW5hYmxlKCl7dGhpcy5hbmltYXRpb25GcmFtZUhhbmRsZSYmd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMuYW5pbWF0aW9uRnJhbWVIYW5kbGUpLHRoaXMuZHJhd1N0YXRzT25seUhhbmRsZSYmd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMuZHJhd1N0YXRzT25seUhhbmRsZSksdGhpcy52aWRlb1N0cmVhbSBpbnN0YW5jZW9mIEIuVmlkZW9TdHJlYW1Tb2Z0d2FyZURlY29kZXJ8fFwicmVxdWVzdFZpZGVvRnJhbWVDYWxsYmFja1wiaW4gSFRNTFZpZGVvRWxlbWVudC5wcm90b3R5cGU/KHRoaXMuYW5pbWF0aW9uRnJhbWVIYW5kbGU9d2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSh0aGlzLmFuaW1hdGlvbkZyYW1lSGFuZGxlciksdGhpcy52aWRlb1N0cmVhbS52aWRlb0ZyYW1lRXZlbnQuYWRkSGFuZGxlcih0aGlzLmRyYXdTdGF0c0FuZEdyYXBoc09uVmlkZW9GcmFtZSkpOnRoaXMuZHJhd1N0YXRzT25seUhhbmRsZT13aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRoaXMuZHJhd1N0YXRzT25seU9uQW5pbWF0aW9uRnJhbWUpLHRoaXMuc3RhdHNJbnRlcnZhbD13aW5kb3cuc2V0SW50ZXJ2YWwodGhpcy5mZXRjaFN0YXRzLDFlMyl9ZGlzYWJsZSgpe3RoaXMuYW5pbWF0aW9uRnJhbWVIYW5kbGUmJndpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLmFuaW1hdGlvbkZyYW1lSGFuZGxlKSx0aGlzLmRyYXdTdGF0c09ubHlIYW5kbGUmJndpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLmRyYXdTdGF0c09ubHlIYW5kbGUpLHRoaXMudmlkZW9TdHJlYW0udmlkZW9GcmFtZUV2ZW50LnJlbW92ZUhhbmRsZXIodGhpcy5kcmF3U3RhdHNBbmRHcmFwaHNPblZpZGVvRnJhbWUpLHdpbmRvdy5jbGVhckludGVydmFsKHRoaXMuc3RhdHNJbnRlcnZhbCl9Z2V0VGhyb3VnaHB1dCgpe3ZhciBBO3JldHVybiB0aGlzLnRyYW5zcG9ydFN0YXRzJiZ0aGlzLmxhc3RUcmFuc3BvcnRTdGF0cz9PYmplY3QuZW50cmllcyhudWxsPT09KEE9dGhpcy50cmFuc3BvcnRTdGF0cyl8fHZvaWQgMD09PUE/dm9pZCAwOkEuY2hhbm5lbHMpLm1hcCgoKFtBLEldKT0+dGhpcy5sYXN0VHJhbnNwb3J0U3RhdHM/W0EsSS5ieXRlc1NlbnQtdGhpcy5sYXN0VHJhbnNwb3J0U3RhdHMuY2hhbm5lbHNbQV0uYnl0ZXNTZW50LEkuYnl0ZXNSZWNlaXZlZC10aGlzLmxhc3RUcmFuc3BvcnRTdGF0cy5jaGFubmVsc1tBXS5ieXRlc1JlY2VpdmVkXTpbQSwwLDBdKSk6W119ZHJhd1N0YXRzKEEpe3ZhciBJLGc7aWYoIXRoaXMuY2FudmFzQ29udGV4dHx8dGhpcy52aWRlb1N0cmVhbS5yZWFkeVN0YXRlIT09aS5WaWRlb1JlYWR5U3RhdGUuUGxheWluZylyZXR1cm47Y29uc3QgZT10aGlzLmNhbnZhc0NvbnRleHQsQj1lLmNhbnZhcyxRPUIud2lkdGgvQi5jbGllbnRXaWR0aCx0PUIuaGVpZ2h0L0IuY2xpZW50SGVpZ2h0LEU9dGhpcy50aHJvdWdocHV0O2lmKHRoaXMuc3RhdHMpe2NvbnN0IGk9T2JqZWN0LmVudHJpZXModGhpcy5zdGF0cyksbz1pLmxlbmd0aCtFLmxlbmd0aCxhPWUubWVhc3VyZVRleHQoXCJNXCIpLndpZHRoO2UuZmlsbFN0eWxlPVwicmdiYSgwLCAwLCAwLCAwLjUpXCI7Y29uc3Qgbj0obysyKSphKzIqKGErMip0KSsxNSp0O2UuZmlsbFJlY3QoMTAqUSxCLmhlaWdodC0obisxMCp0KSwzMDAqUSxuKSxlLmZpbGxTdHlsZT1cIndoaXRlXCIsZS5mb250PWAkeygxMipRKS50b0ZpeGVkKDApfXB4IHNhbnMtc2VyaWZgLGUudGV4dEJhc2VsaW5lPVwidG9wXCI7bGV0IHM9MDtjb25zdCByPUIuaGVpZ2h0LShuKzE1KnQpKzE1KlE7QT9lLmZpbGxUZXh0KGBSZXNvbHV0aW9uOiAke0Eud2lkdGh9eCR7QS5oZWlnaHR9YCwxNSpRLHIpOmUuZmlsbFRleHQoYFJlc29sdXRpb246ICR7bnVsbD09PShJPXRoaXMudmlkZW8pfHx2b2lkIDA9PT1JP3ZvaWQgMDpJLnZpZGVvV2lkdGh9eCR7bnVsbD09PShnPXRoaXMudmlkZW8pfHx2b2lkIDA9PT1nP3ZvaWQgMDpnLnZpZGVvSGVpZ2h0fWAsMTUqUSxyKSxlLmZpbGxUZXh0KGBFbGVtZW50IHNpemU6ICR7Qi5jbGllbnRXaWR0aH14JHtCLmNsaWVudEhlaWdodH1gLDE1KlEscithKTtmb3IoY29uc3RbQSxJXW9mIGkpe2xldCBnLEI9XCJcIjtcInByb2Nlc3NpbmdEdXJhdGlvblwiPT09QT8oQj1cIm1zXCIsZz0xZTMqSSk6Zz1JLFwiZW5kT2ZCdWZmZXJlZFwiPT09QXx8XCJlbmRPZlNlZWthYmxlXCI9PT1BfHxcImN1cnJlbnRUaW1lXCI9PT1BP0I9XCJzXCI6XCJkYXRhSW50ZXJ2YWxcIj09PUE/Qj1cIm1zXCI6XCJkYXRhU2l6ZVwiPT09QSYmKEI9XCJieXRlc1wiKSxlLmZpbGxUZXh0KGAke0NbQV19OiAke2cudG9GaXhlZCgyKX0gJHtCfWAsMTUqUSxzKihhKzIqdCkrMiooYSsyKnQpK3IpLHMrK31mb3IoY29uc3RbQSxJLGddb2YgRSllLmZpbGxUZXh0KGAke0F9IHRocm91Z2hwdXQgLSB1cDogJHsoSS8xZTMpLnRvRml4ZWQoMCl9IGtiL3MsIGRvd246ICR7KGcvMWUzKS50b0ZpeGVkKDApfSBrYi9zYCwxNSpRLHMqKGErMip0KSsyKihhKzIqdCkrcikscysrfX19fSw0NDE6KEEsSSxnKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eShJLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLEkuVmlkZW9TdGF0cz12b2lkIDA7Y29uc3QgZT1nKDk5NCksQj1nKDYzMyk7SS5WaWRlb1N0YXRzPWNsYXNze2NvbnN0cnVjdG9yKCl7dGhpcy5wcm9jZXNzaW5nRHVyYXRpb25zPW5ldyBNYXAsdGhpcy5kYXRhSW50ZXJ2YWxzPW5ldyBCLkNpcmN1bGFyQnVmZmVyKDYwKSx0aGlzLmRhdGFTaXplcz1uZXcgQi5DaXJjdWxhckJ1ZmZlcig2MCksdGhpcy50b3RhbEZyYW1lcz0wLHRoaXMucHJlc2VudGVkRnJhbWVzPTB9cHVzaEZyYW1lTWV0YWRhdGEoQSl7dGhpcy5wcmVzZW50ZWRGcmFtZXMrPTE7Y29uc3R7cHJvY2Vzc2luZ0R1cmF0aW9uOkl9PUEsZz0obmV3IERhdGUpLmdldFRpbWUoKTt0aGlzLnByb2Nlc3NpbmdEdXJhdGlvbnMuc2V0KGcsSSk7Zm9yKGNvbnN0W0Fdb2YgdGhpcy5wcm9jZXNzaW5nRHVyYXRpb25zLmVudHJpZXMoKSlBPGctMWUzJiZ0aGlzLnByb2Nlc3NpbmdEdXJhdGlvbnMuZGVsZXRlKEEpfXJlcG9ydEZyYW1lU3VibWl0dGVkKCl7dGhpcy50b3RhbEZyYW1lcys9MX1yZXNldEZyYW1lQ291bnRzKCl7dGhpcy50b3RhbEZyYW1lcz0wLHRoaXMucHJlc2VudGVkRnJhbWVzPTB9cHVzaERhdGEoQSl7dGhpcy5kYXRhU2l6ZXMucHVzaChBLmJ5dGVMZW5ndGgpO2NvbnN0IEk9KG5ldyBEYXRlKS5nZXRUaW1lKCk7dGhpcy5sYXN0RGF0YVRpbWVzdGFtcCYmdGhpcy5kYXRhSW50ZXJ2YWxzLnB1c2goSS10aGlzLmxhc3REYXRhVGltZXN0YW1wKSx0aGlzLmxhc3REYXRhVGltZXN0YW1wPUl9c2V0RWxlbWVudChBKXt0aGlzLmVsZW1lbnQ9QX1nZXRSZXBvcnQoKXtpZighdGhpcy5lbGVtZW50KXRocm93IG5ldyBlLlJhaW53YXlFcnJvcihcImdldFJlcG9ydCgpIGhhcyBubyB2aWRlbyBlbGVtZW50XCIpO2NvbnN0IEE9Qi5hdmVyYWdlKEFycmF5LmZyb20odGhpcy5wcm9jZXNzaW5nRHVyYXRpb25zLnZhbHVlcygpKSksST10aGlzLmVsZW1lbnQuYnVmZmVyZWQsZz1JLmxlbmd0aD4wP0kuZW5kKEkubGVuZ3RoLTEpOjAsaT10aGlzLmVsZW1lbnQuc2Vla2FibGUsUT1pLmxlbmd0aD4wP2kuZW5kKGkubGVuZ3RoLTEpOjA7cmV0dXJue3Byb2Nlc3NpbmdEdXJhdGlvbjpBLGRyb3BwZWRGcmFtZXM6dGhpcy50b3RhbEZyYW1lcy10aGlzLnByZXNlbnRlZEZyYW1lcyx0b3RhbEZyYW1lczp0aGlzLnRvdGFsRnJhbWVzLGRhdGFJbnRlcnZhbDpCLmF2ZXJhZ2UodGhpcy5kYXRhSW50ZXJ2YWxzLnZhbHVlcygpKSxkYXRhU2l6ZTpCLmF2ZXJhZ2UodGhpcy5kYXRhU2l6ZXMudmFsdWVzKCkpLGN1cnJlbnRUaW1lOnRoaXMuZWxlbWVudC5jdXJyZW50VGltZSxlbmRPZkJ1ZmZlcmVkOmcsZW5kT2ZTZWVrYWJsZTpRfX1jcmVhdGVSZXBvcnQoQSxJKXtyZXR1cm57cHJvY2Vzc2luZ0R1cmF0aW9uOkIuYXZlcmFnZShBcnJheS5mcm9tKHRoaXMucHJvY2Vzc2luZ0R1cmF0aW9ucy52YWx1ZXMoKSkpLGRyb3BwZWRGcmFtZXM6bnVsbCE9QT9BOjAsdG90YWxGcmFtZXM6bnVsbCE9ST9JOjAsZGF0YUludGVydmFsOkIuYXZlcmFnZSh0aGlzLmRhdGFJbnRlcnZhbHMudmFsdWVzKCkpLGRhdGFTaXplOkIuYXZlcmFnZSh0aGlzLmRhdGFTaXplcy52YWx1ZXMoKSksY3VycmVudFRpbWU6MCxlbmRPZkJ1ZmZlcmVkOjAsZW5kT2ZTZWVrYWJsZTowfX19fSw5MDA6ZnVuY3Rpb24oQSxJLGcpe1widXNlIHN0cmljdFwiO3ZhciBlPXRoaXMmJnRoaXMuX19hd2FpdGVyfHxmdW5jdGlvbihBLEksZyxlKXtyZXR1cm4gbmV3KGd8fChnPVByb21pc2UpKSgoZnVuY3Rpb24oQixpKXtmdW5jdGlvbiBRKEEpe3RyeXtDKGUubmV4dChBKSl9Y2F0Y2goQSl7aShBKX19ZnVuY3Rpb24gdChBKXt0cnl7QyhlLnRocm93KEEpKX1jYXRjaChBKXtpKEEpfX1mdW5jdGlvbiBDKEEpe3ZhciBJO0EuZG9uZT9CKEEudmFsdWUpOihJPUEudmFsdWUsSSBpbnN0YW5jZW9mIGc/STpuZXcgZygoZnVuY3Rpb24oQSl7QShJKX0pKSkudGhlbihRLHQpfUMoKGU9ZS5hcHBseShBLEl8fFtdKSkubmV4dCgpKX0pKX07T2JqZWN0LmRlZmluZVByb3BlcnR5KEksXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksSS5WaWRlb1N0cmVhbU1TRT12b2lkIDA7Y29uc3QgQj1nKDI0KSxpPWcoNjMzKSxRPWcoNDM0KSx0PWcoNDY0KSxDPWcoNDQxKTtmdW5jdGlvbiBFKEEpe3JldHVybiAxMDI9PT1BWzRdJiYxMTY9PT1BWzVdJiYxMjE9PT1BWzZdJiYxMTI9PT1BWzddfUkuVmlkZW9TdHJlYW1NU0U9Y2xhc3N7Y29uc3RydWN0b3IoQSl7dGhpcy5jb2RlY1N0cmluZz1BLHRoaXMucmVhZHlTdGF0ZT1RLlZpZGVvUmVhZHlTdGF0ZS5EZXRhY2hlZCx0aGlzLm5lZWRzUmVzdGFydEV2ZW50PW5ldyBCLkFjdGlvbix0aGlzLnNvdXJjZU9wZW5FdmVudD1uZXcgQi5BY3Rpb24sdGhpcy5yZWFkeVN0YXRlQ2hhbmdlRXZlbnQ9bmV3IEIuQWN0aW9uLHRoaXMudmlkZW9GcmFtZUV2ZW50PW5ldyBCLkFjdGlvbix0aGlzLnZpZGVvRnJhbWVQcm9jZXNzaW5nRHVyYXRpb25FdmVudD1uZXcgQi5BY3Rpb24sdGhpcy5jYW5jZWxJbml0aWFsaXplRXZlbnQ9bmV3IEIuQWN0aW9uLHRoaXMuZGF0YVF1ZXVlPVtdLHRoaXMuc3RhdHM9bmV3IEMuVmlkZW9TdGF0cyx0aGlzLmp1c3RDbGVhcmVkQnVmZmVyPSExLHRoaXMubGFzdEJ1ZmZlckVuZD0wLHRoaXMuZnJhbWVzRnJvemVuRm9yPTAsdGhpcy5lbnN1cmVCdWZmZXI9KCk9PntpZih0aGlzLnJlYWR5U3RhdGUhPT1RLlZpZGVvUmVhZHlTdGF0ZS5QYXVzZWQmJnRoaXMucmVhZHlTdGF0ZSE9PVEuVmlkZW9SZWFkeVN0YXRlLkRldGFjaGVkJiZ0aGlzLmVsZW1lbnQmJjA9PT10aGlzLmVsZW1lbnQuYnVmZmVyZWQubGVuZ3RoKXtpZih0aGlzLnNvdXJjZUJ1ZmZlciYmIXRoaXMuc291cmNlQnVmZmVyLnVwZGF0aW5nJiZ0aGlzLnNvdXJjZUJ1ZmZlci50aW1lc3RhbXBPZmZzZXQ8PTApe2NvbnN0IEE9dGhpcy5zb3VyY2VCdWZmZXIudGltZXN0YW1wT2Zmc2V0LnRvRml4ZWQoMik7dGhpcy5zb3VyY2VCdWZmZXIudGltZXN0YW1wT2Zmc2V0PTE7Y29uc3QgST10aGlzLnNvdXJjZUJ1ZmZlci50aW1lc3RhbXBPZmZzZXQudG9GaXhlZCgyKTt0aGlzLndhcm4oYFBva2VkIHRpbWVzdGFtcE9mZnNldCBmcm9tICR7QX0gdG8gJHtJfWApfXRoaXMucmVzdGFydChcImVuc3VyZUJ1ZmZlclwiKX19LHRoaXMudmlkZW9GcmFtZUhhbmRsZXI9KEEsSSk9PnsobnVsbD09ST92b2lkIDA6SS5wcm9jZXNzaW5nRHVyYXRpb24pJiZ0aGlzLnZpZGVvRnJhbWVQcm9jZXNzaW5nRHVyYXRpb25FdmVudC5pbnZva2UoSS5wcm9jZXNzaW5nRHVyYXRpb24pLEkmJnRoaXMuc3RhdHMucHVzaEZyYW1lTWV0YWRhdGEoSSksdGhpcy52aWRlb0ZyYW1lRXZlbnQuaW52b2tlKFtBLEldKSx0aGlzLnJlcXVlc3ROZXh0RnJhbWVDYWxsYmFjaygpfSx0aGlzLmZhbGxiYWNrVmlkZW9GcmFtZUhhbmRsZXI9QT0+e3RoaXMudmlkZW9GcmFtZUhhbmRsZXIoQSx2b2lkIDApfSx0aGlzLnNvdXJjZUJ1ZmZlclVwZGF0ZUhhbmRsZXI9KCk9Pnt0aGlzLnN1Ym1pdERhdGEoKX0sd2luZG93Ll9fcmFpbndheVZpZGVvPXRoaXN9aW5mbyhBKXt0LlJhaW53YXlMb2dnaW5nLmluZm9ybWF0aW9uKGBbVmlkZW9TdHJlYW1dICR7U3RyaW5nKEEpfWApfWRlYnVnKEEpe3QuUmFpbndheUxvZ2dpbmcuZGVidWcoYFtWaWRlb1N0cmVhbV0gJHtTdHJpbmcoQSl9YCl9d2FybihBKXt0LlJhaW53YXlMb2dnaW5nLndhcm5pbmcoYFtWaWRlb1N0cmVhbV0gJHtTdHJpbmcoQSl9YCl9Z2V0IGRhdGFRdWV1ZUxlbmd0aCgpe3JldHVybiB0aGlzLmRhdGFRdWV1ZS5sZW5ndGh9YXR0YWNoVG9FbGVtZW50KEEpe3RoaXMuaW5mbyhcIkF0dGFjaGluZyB0byBlbGVtZW50OiBcIitBKSx0aGlzLmNhbmNlbEluaXRpYWxpemVFdmVudC5pbnZva2UoKSx0aGlzLmVsZW1lbnQ9QSx0aGlzLnN0YXRzLnNldEVsZW1lbnQodGhpcy5lbGVtZW50KSx0aGlzLnN0YXRzLnJlc2V0RnJhbWVDb3VudHMoKSx0aGlzLnJlc3RhcnQoXCJhdHRhY2hUb0VsZW1lbnRcIiksdGhpcy5pbmZvKFwiQXR0YWNoZWQgdG8gZWxlbWVudC5cIil9ZGV0YWNoRnJvbUVsZW1lbnQoKXt0aGlzLmRlc3Ryb3lNZWRpYSgpLHRoaXMuZWxlbWVudD12b2lkIDAsdGhpcy5zZXRSZWFkeVN0YXRlKFEuVmlkZW9SZWFkeVN0YXRlLkRldGFjaGVkKSx0aGlzLmluZm8oXCJEZXRhY2hlZCBmcm9tIGVsZW1lbnQuXCIpfXBhdXNlKCl7dGhpcy5zZXRSZWFkeVN0YXRlKFEuVmlkZW9SZWFkeVN0YXRlLlBhdXNlZCl9cGxheSgpe3RoaXMucmVhZHlTdGF0ZT09PVEuVmlkZW9SZWFkeVN0YXRlLlBhdXNlZCYmdGhpcy5yZXN0YXJ0KFwicGxheVwiKX1wdXNoRGF0YShBLEkpe2lmKHRoaXMuZGF0YVF1ZXVlLmxlbmd0aD44KXJldHVybiB2b2lkIHRoaXMucmVzdGFydChcInB1c2hEYXRhLmRhdGFRdWV1ZSB0b28gbG9uZ1wiKTtjb25zdCBnPW5ldyBVaW50OEFycmF5KEkpO3RoaXMuc3RhdHMucHVzaERhdGEoZyksdGhpcy5yZWFkeVN0YXRlIT09US5WaWRlb1JlYWR5U3RhdGUuUGF1c2VkJiYoRShnKSYmdGhpcy5yZWFkeVN0YXRlPT09US5WaWRlb1JlYWR5U3RhdGUuV2FpdGluZ0ZvcktleWZyYW1lJiZ0aGlzLmVsZW1lbnQmJih0aGlzLmRlYnVnKGBHb3QgcmVxdWVzdGVkIGtleWZyYW1lICgke2cubGVuZ3RofSBieXRlcylgKSx0aGlzLmdldFN0YXRzKCksdGhpcy5kYXRhUXVldWUucHVzaChnKSx0aGlzLnN1Ym1pdERhdGEoKSx0aGlzLmluaXRpYWxpemVNZWRpYSgpKSx0aGlzLnJlYWR5U3RhdGUhPT1RLlZpZGVvUmVhZHlTdGF0ZS5XYWl0aW5nRm9yS2V5ZnJhbWUmJnRoaXMuZWxlbWVudD8odGhpcy5kYXRhUXVldWUucHVzaChnKSx0aGlzLnN1Ym1pdERhdGEoKSk6dGhpcy5zdGFydEVuc3VyaW5nQnVmZmVyKCkpfWdldFN0YXRzKCl7cmV0dXJuIHRoaXMuc3RhdHMuZ2V0UmVwb3J0KCl9c2V0UmVhZHlTdGF0ZShBKXt0aGlzLmluZm8oYFJlYWR5U3RhdGUgY2hhbmdlZDogJHtRLlZpZGVvUmVhZHlTdGF0ZVt0aGlzLnJlYWR5U3RhdGVdfSA9PiAke1EuVmlkZW9SZWFkeVN0YXRlW0FdfWApLHRoaXMucmVhZHlTdGF0ZT1BLHRoaXMucmVhZHlTdGF0ZUNoYW5nZUV2ZW50Lmludm9rZShBKX1zdWJtaXREYXRhKCl7aWYoMCE9PXRoaXMuZGF0YVF1ZXVlLmxlbmd0aClpZih2b2lkIDAhPT10aGlzLm1lZGlhU291cmNlKWlmKHRoaXMuc291cmNlQnVmZmVyKXtpZighdGhpcy5zb3VyY2VCdWZmZXIudXBkYXRpbmcpaWYodGhpcy5lbGVtZW50KXtpZih0aGlzLnNvdXJjZUJ1ZmZlci5idWZmZXJlZC5sZW5ndGg+PTEpe2NvbnN0IEE9dGhpcy5zb3VyY2VCdWZmZXIuYnVmZmVyZWQuZW5kKHRoaXMuc291cmNlQnVmZmVyLmJ1ZmZlcmVkLmxlbmd0aC0xKTt0aGlzLmp1c3RDbGVhcmVkQnVmZmVyJiYodGhpcy5lbGVtZW50LmN1cnJlbnRUaW1lPUEsdGhpcy5qdXN0Q2xlYXJlZEJ1ZmZlcj0hMSksQT09PXRoaXMubGFzdEJ1ZmZlckVuZD8odGhpcy5mcmFtZXNGcm96ZW5Gb3IrKyx0aGlzLmRlYnVnKGBGcm96ZW4gZm9yICR7dGhpcy5mcmFtZXNGcm96ZW5Gb3J9IGZyYW1lcy4uLmApKTp0aGlzLmZyYW1lc0Zyb3plbkZvcj0wLHRoaXMubGFzdEJ1ZmZlckVuZD1BfWlmKHRoaXMuZnJhbWVzRnJvemVuRm9yPj00KXJldHVybiB0aGlzLnJlc3RhcnQoXCJzb3VyY2VCdWZmZXIgRnJvemVuRnJhbWVzXCIpLHZvaWQodGhpcy5mcmFtZXNGcm96ZW5Gb3I9MCk7dHJ5e2NvbnN0IEE9dGhpcy5kYXRhUXVldWVbMF07aWYoRShBKSYmIXRoaXMuanVzdENsZWFyZWRCdWZmZXIpcmV0dXJuIHRoaXMuZGVidWcoXCJHb3Qga2V5ZnJhbWUuIENsZWFyaW5nIHNvdXJjZWJ1ZmZlci5cIiksdGhpcy5nZXRTdGF0cygpLHRoaXMuc291cmNlQnVmZmVyLnJlbW92ZSgwLDEvMCksdm9pZCh0aGlzLmp1c3RDbGVhcmVkQnVmZmVyPSEwKTt0aGlzLmRhdGFRdWV1ZS5zaGlmdCgpLHRoaXMuc291cmNlQnVmZmVyLmFwcGVuZEJ1ZmZlcihBKSx0aGlzLnN0YXRzLnJlcG9ydEZyYW1lU3VibWl0dGVkKCl9Y2F0Y2goQSl7dC5SYWlud2F5TG9nZ2luZy5lcnJvcihTdHJpbmcoQSkpLHRoaXMucmVzdGFydChcInN1Ym1pdERhdGEsIHNvdXJjZUJ1ZmZlci5hcHBlbmRCdWZmZXIgZXJyb3IuXCIpfX1lbHNlIHRoaXMuZGVidWcoXCJJZGxpbmcgYmVjYXVzZSAhZWxlbWVudFwiKX1lbHNlIHRoaXMuZGVidWcoXCJJZGxpbmcgYmVjYXVzZSAhc291cmNlQnVmZmVyXCIpO2Vsc2UgdGhpcy5kZWJ1ZyhcIklkbGluZyBiZWNhdXNlIG1lZGlhU291cmNlID09PSB1bmRlZmluZWRcIil9aW5pdGlhbGl6ZU1lZGlhKCl7dmFyIEEsSTtyZXR1cm4gZSh0aGlzLHZvaWQgMCx2b2lkIDAsKGZ1bmN0aW9uKigpe2lmKHRoaXMuc2V0UmVhZHlTdGF0ZShRLlZpZGVvUmVhZHlTdGF0ZS5Jbml0aWFsaXppbmcpLHRoaXMuY2FuY2VsSW5pdGlhbGl6ZUV2ZW50Lmludm9rZSgpLHZvaWQgMCE9PXRoaXMubWVkaWFTb3VyY2UpcmV0dXJuIHRoaXMuc2V0UmVhZHlTdGF0ZShRLlZpZGVvUmVhZHlTdGF0ZS5QbGF5aW5nKSx2b2lkKG51bGw9PT0oQT10aGlzLmVsZW1lbnQpfHx2b2lkIDA9PT1BfHxBLnBsYXkoKSk7aWYoIXRoaXMuZWxlbWVudCl0aHJvdyBuZXcgRXJyb3IoXCJTdHJlYW0gbm90IGF0dGFjaGVkIHRvIGVsZW1lbnQuXCIpO3RyeXtjb25zdCBBPXlpZWxkIGkuY3JlYXRlTWVkaWFTb3VyY2UodGhpcy5lbGVtZW50LHRoaXMuY2FuY2VsSW5pdGlhbGl6ZUV2ZW50KTtpZighQSlyZXR1cm4gdm9pZCB0aGlzLnNldFJlYWR5U3RhdGUoUS5WaWRlb1JlYWR5U3RhdGUuV2FpdGluZ0ZvcktleWZyYW1lKTt0aGlzLm1lZGlhU291cmNlPUEsdGhpcy5zb3VyY2VCdWZmZXI9aS5jcmVhdGVTb3VyY2VCdWZmZXIodGhpcy5tZWRpYVNvdXJjZSx0aGlzLmNvZGVjU3RyaW5nKSx0aGlzLnNvdXJjZUJ1ZmZlci5hZGRFdmVudExpc3RlbmVyKFwidXBkYXRlZW5kXCIsdGhpcy5zb3VyY2VCdWZmZXJVcGRhdGVIYW5kbGVyKSx0aGlzLnNvdXJjZUJ1ZmZlci5hZGRFdmVudExpc3RlbmVyKFwiZXJyb3JcIiwoQT0+Y29uc29sZS5lcnJvcihcInNvdXJjZUJ1ZmZlciBlcnJvcjpcIixBKSkpLHRoaXMuc3RhcnRFbnN1cmluZ0J1ZmZlcigpLHRoaXMuc2V0UmVhZHlTdGF0ZShRLlZpZGVvUmVhZHlTdGF0ZS5QbGF5aW5nKSx0aGlzLnJlcXVlc3ROZXh0RnJhbWVDYWxsYmFjaygpLHRoaXMuc3VibWl0RGF0YSgpLG51bGw9PT0oST10aGlzLmVsZW1lbnQpfHx2b2lkIDA9PT1JfHxJLnBsYXkoKX1jYXRjaChBKXt0aGlzLnNldFJlYWR5U3RhdGUoUS5WaWRlb1JlYWR5U3RhdGUuV2FpdGluZ0ZvcktleWZyYW1lKX19KSl9c3RhcnRFbnN1cmluZ0J1ZmZlcigpe3ZvaWQgMD09PXRoaXMuZW5zdXJlQnVmZmVySW50ZXJ2YWwmJih0aGlzLmRlYnVnKFwiU3RhcnRpbmcgZW5zdXJlQnVmZmVyIGxvb3BcIiksdGhpcy5lbnN1cmVCdWZmZXJJbnRlcnZhbD13aW5kb3cuc2V0SW50ZXJ2YWwodGhpcy5lbnN1cmVCdWZmZXIsMWUzKSl9ZGVzdHJveU1lZGlhKCl7dmFyIEEsSTtpZih0aGlzLmRlYnVnKFwiZGVzdHJveU1lZGlhKCkgY2FsbGVkXCIpLHZvaWQgMCE9PXRoaXMubWVkaWFTb3VyY2Upe2lmKHRoaXMuY2FuY2VsRnJhbWVDYWxsYmFjaygpLG51bGw9PT0oQT10aGlzLmVsZW1lbnQpfHx2b2lkIDA9PT1BfHxBLnBhdXNlKCksbnVsbD09PShJPXRoaXMuc291cmNlQnVmZmVyKXx8dm9pZCAwPT09SXx8SS5yZW1vdmVFdmVudExpc3RlbmVyKFwidXBkYXRlZW5kXCIsdGhpcy5zb3VyY2VCdWZmZXJVcGRhdGVIYW5kbGVyKSx0aGlzLm1lZGlhU291cmNlKXtpZih0aGlzLnNvdXJjZUJ1ZmZlcil7dHJ5e3RoaXMubWVkaWFTb3VyY2UucmVtb3ZlU291cmNlQnVmZmVyKHRoaXMuc291cmNlQnVmZmVyKX1jYXRjaChBKXt9dGhpcy5zb3VyY2VCdWZmZXI9dm9pZCAwfWlmKFwib3BlblwiPT09dGhpcy5tZWRpYVNvdXJjZS5yZWFkeVN0YXRlKXRyeXt0aGlzLm1lZGlhU291cmNlLmVuZE9mU3RyZWFtKCl9Y2F0Y2goQSl7fXRoaXMubWVkaWFTb3VyY2U9dm9pZCAwLHRoaXMuZWxlbWVudCYmd2luZG93LlVSTC5yZXZva2VPYmplY3RVUkwodGhpcy5lbGVtZW50LnNyYyl9d2luZG93LmNsZWFySW50ZXJ2YWwodGhpcy5lbnN1cmVCdWZmZXJJbnRlcnZhbCksdGhpcy5lbnN1cmVCdWZmZXJJbnRlcnZhbD12b2lkIDAsdGhpcy5zZXRSZWFkeVN0YXRlKFEuVmlkZW9SZWFkeVN0YXRlLldhaXRpbmdGb3JLZXlmcmFtZSl9fXJlc3RhcnQoQT1cIlwiKXtjb25zdCBJPUE/YFJlc3RhcnRpbmcgVmlkZW8gU3RyZWFtLi4uIFJlYXNvbjogJyR7QX0nLmA6XCJSZXN0YXJ0aW5nIFZpZGVvIFN0cmVhbS5cIjt0aGlzLndhcm4oSSksdGhpcy5kYXRhUXVldWU9W10sdGhpcy5zZXRSZWFkeVN0YXRlKFEuVmlkZW9SZWFkeVN0YXRlLldhaXRpbmdGb3JLZXlmcmFtZSksdGhpcy5uZWVkc1Jlc3RhcnRFdmVudC5pbnZva2UoKX1yZXF1ZXN0TmV4dEZyYW1lQ2FsbGJhY2soKXt2YXIgQSxJLGcsZTtcInJlcXVlc3RWaWRlb0ZyYW1lQ2FsbGJhY2tcImluIEhUTUxWaWRlb0VsZW1lbnQucHJvdG90eXBlPyh0aGlzLmZyYW1lSGFuZGxlJiYobnVsbD09PShJPW51bGw9PT0oQT10aGlzLmVsZW1lbnQpfHx2b2lkIDA9PT1BP3ZvaWQgMDpBLmNhbmNlbFZpZGVvRnJhbWVDYWxsYmFjayl8fHZvaWQgMD09PUl8fEkuY2FsbChBLHRoaXMuZnJhbWVIYW5kbGUpLHRoaXMuZnJhbWVIYW5kbGU9dm9pZCAwKSx0aGlzLmZyYW1lSGFuZGxlPW51bGw9PT0oZT1udWxsPT09KGc9dGhpcy5lbGVtZW50KXx8dm9pZCAwPT09Zz92b2lkIDA6Zy5yZXF1ZXN0VmlkZW9GcmFtZUNhbGxiYWNrKXx8dm9pZCAwPT09ZT92b2lkIDA6ZS5jYWxsKGcsdGhpcy52aWRlb0ZyYW1lSGFuZGxlcikpOih0aGlzLmZyYW1lSGFuZGxlJiYod2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMuZnJhbWVIYW5kbGUpLHRoaXMuZnJhbWVIYW5kbGU9dm9pZCAwKSx0aGlzLmZyYW1lSGFuZGxlPXdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUodGhpcy5mYWxsYmFja1ZpZGVvRnJhbWVIYW5kbGVyKSl9Y2FuY2VsRnJhbWVDYWxsYmFjaygpe3ZhciBBLEk7XCJyZXF1ZXN0VmlkZW9GcmFtZUNhbGxiYWNrXCJpbiBIVE1MVmlkZW9FbGVtZW50LnByb3RvdHlwZT90aGlzLmZyYW1lSGFuZGxlJiYobnVsbD09PShJPW51bGw9PT0oQT10aGlzLmVsZW1lbnQpfHx2b2lkIDA9PT1BP3ZvaWQgMDpBLmNhbmNlbFZpZGVvRnJhbWVDYWxsYmFjayl8fHZvaWQgMD09PUl8fEkuY2FsbChBLHRoaXMuZnJhbWVIYW5kbGUpLHRoaXMuZnJhbWVIYW5kbGU9dm9pZCAwKTp0aGlzLmZyYW1lSGFuZGxlJiYod2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMuZnJhbWVIYW5kbGUpLHRoaXMuZnJhbWVIYW5kbGU9dm9pZCAwKX1kaXNwb3NlKCl7dGhpcy5jYW5jZWxGcmFtZUNhbGxiYWNrKCksdGhpcy5kZXN0cm95TWVkaWEoKSx3aW5kb3cuY2xlYXJJbnRlcnZhbCh0aGlzLmVuc3VyZUJ1ZmZlckludGVydmFsKSx0aGlzLnNldFJlYWR5U3RhdGUoUS5WaWRlb1JlYWR5U3RhdGUuRGlzcG9zZWQpfX19LDE0NjpmdW5jdGlvbihBLEksZyl7XCJ1c2Ugc3RyaWN0XCI7dmFyIGU9dGhpcyYmdGhpcy5fX2ltcG9ydERlZmF1bHR8fGZ1bmN0aW9uKEEpe3JldHVybiBBJiZBLl9fZXNNb2R1bGU/QTp7ZGVmYXVsdDpBfX07T2JqZWN0LmRlZmluZVByb3BlcnR5KEksXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksSS5WaWRlb1N0cmVhbVNvZnR3YXJlRGVjb2Rlcj12b2lkIDA7Y29uc3QgQj1nKDQzNCksaT1nKDI0KSxRPWcoNDI1KSx0PWUoZyg4NTkpKSxDPWUoZyg3NTYpKSxFPWUoZygzNDYpKSxvPWcoNDY0KSxhPWcoNDQxKTtJLlZpZGVvU3RyZWFtU29mdHdhcmVEZWNvZGVyPWNsYXNze2NvbnN0cnVjdG9yKEEsSSl7dGhpcy5jb2RlY1N0cmluZz1BLHRoaXMuZm9ybWF0PUksdGhpcy5yZWFkeVN0YXRlPUIuVmlkZW9SZWFkeVN0YXRlLkRldGFjaGVkLHRoaXMubmVlZHNSZXN0YXJ0RXZlbnQ9bmV3IGkuQWN0aW9uLHRoaXMucmVhZHlTdGF0ZUNoYW5nZUV2ZW50PW5ldyBpLkFjdGlvbix0aGlzLnZpZGVvRnJhbWVQcm9jZXNzaW5nRHVyYXRpb25FdmVudD1uZXcgaS5BY3Rpb24sdGhpcy52aWRlb0ZyYW1lRXZlbnQ9bmV3IGkuQWN0aW9uLHRoaXMuY3VycmVudEZyYW1lSW5mbz17Y29udGFpbnNTUFM6ITEsY29udGFpbnNQUFM6ITEsY29udGFpbnNGcmFtZURhdGE6ITB9LHRoaXMucGF1c2VkPSExLHRoaXMuc3RhdHM9bmV3IGEuVmlkZW9TdGF0cyx0aGlzLnRvdGFsRnJhbWVzPTAsdGhpcy53YWl0aW5nVG9EZWNvZGVRdWV1ZT1bXSx0aGlzLmRlY29kZVF1ZXVlPVtdLHRoaXMubWF4RGVjb2RlUXVldWVTaXplPTMsdGhpcy5tYXhMYXRlbmN5RnJhbWVDb3VudD03LHRoaXMubWF4Q29uc2VjdXRpdmVGcmFtZXNEcm9wcz0zLHRoaXMuZnJhbWVzRHJvcHBlZFNpbmNlTGFzdFJlbmRlcj0wLHRoaXMudG90YWxGcmFtZXNEcm9wcGVkPTAsdGhpcy5jYW52YXM9dm9pZCAwLHRoaXMuc2hhZGVyPXZvaWQgMCx0aGlzLnlUZXh0dXJlPXZvaWQgMCx0aGlzLnVUZXh0dXJlPXZvaWQgMCx0aGlzLnZUZXh0dXJlPXZvaWQgMCx0aGlzLm9uRGVjb2RlPSh7d2lkdGg6QSxoZWlnaHQ6SSxkYXRhOmd9KT0+e2lmKDA9PXRoaXMuZGVjb2RlUXVldWUubGVuZ3RoKXJldHVybiBvLlJhaW53YXlMb2dnaW5nLmVycm9yKFwiW1ZpZGVvU3RyZWFtU29mdHdhcmVEZWNvZGVyXSBvbkRlY29kZSBjYWxsZWQgd2l0aCBlbXB0eSBkZWNvZGVyIHF1ZXVlIVwiKSx2b2lkIHRoaXMuc2VuZERlY29kZXJXYWl0aW5nVG9EZWNvZGVGcmFtZXMoKTsrK3RoaXMudG90YWxGcmFtZXM7Y29uc3QgZT10aGlzLmRlY29kZVF1ZXVlLnNoaWZ0KCk7aWYoIXRoaXMucGF1c2VkKXtjb25zdCBCPURhdGUubm93KCk7aWYoZS5wcm9jZXNzaW5nRHVyYXRpb249KEItZS5tZWRpYVRpbWUpLzFlMyx0aGlzLnZpZGVvRnJhbWVQcm9jZXNzaW5nRHVyYXRpb25FdmVudC5pbnZva2UoZS5wcm9jZXNzaW5nRHVyYXRpb24pLHRoaXMuZGF0YVF1ZXVlTGVuZ3RoPnRoaXMubWF4TGF0ZW5jeUZyYW1lQ291bnQmJnRoaXMuZnJhbWVzRHJvcHBlZFNpbmNlTGFzdFJlbmRlcjx0aGlzLm1heENvbnNlY3V0aXZlRnJhbWVzRHJvcHMpKyt0aGlzLmZyYW1lc0Ryb3BwZWRTaW5jZUxhc3RSZW5kZXIsKyt0aGlzLnRvdGFsRnJhbWVzRHJvcHBlZDtlbHNle3RoaXMuZnJhbWVzRHJvcHBlZFNpbmNlTGFzdFJlbmRlcj0wO2NvbnN0IEI9ZS53aWR0aCxpPWUuaGVpZ2h0O2Uud2lkdGg9QSxlLmhlaWdodD1JLHRoaXMuc3RhdHMucHVzaEZyYW1lTWV0YWRhdGEoZSksdGhpcy5yZW5kZXJGcmFtZShCLGksZyxBLEkpLHRoaXMudmlkZW9GcmFtZUV2ZW50Lmludm9rZShbcGVyZm9ybWFuY2Uubm93KCksZV0pfX10aGlzLnNlbmREZWNvZGVyV2FpdGluZ1RvRGVjb2RlRnJhbWVzKCl9LHRoaXMuZW5zdXJlQnVmZmVyPSgpPT57dGhpcy5yZWFkeVN0YXRlPT09Qi5WaWRlb1JlYWR5U3RhdGUuV2FpdGluZ0ZvcktleWZyYW1lJiYwPT09dGhpcy5kYXRhUXVldWVMZW5ndGgmJihvLlJhaW53YXlMb2dnaW5nLmRlYnVnKFwiU2VuZGluZyBhbm90aGVyIHJlcXVlc3QgZm9yIGEga2V5ZnJhbWUuXCIpLHRoaXMucmVzdGFydCgpKX0sdGhpcy52aWRlb0Zvcm1hdD1JLHRoaXMuZGVjb2Rlcldvcmtlcj1uZXcgdC5kZWZhdWx0LHRoaXMuZGVjb2Rlcldvcmtlci5pbml0aWFsaXplKCksdGhpcy5kZWNvZGVyV29ya2VyLm9uRGVjb2RlPXRoaXMub25EZWNvZGUuYmluZCh0aGlzKSx0aGlzLmVuc3VyZUJ1ZmZlckludGVydmFsPXdpbmRvdy5zZXRJbnRlcnZhbCh0aGlzLmVuc3VyZUJ1ZmZlciwxZTMpfWdldCBkYXRhUXVldWVMZW5ndGgoKXtyZXR1cm4gdGhpcy53YWl0aW5nVG9EZWNvZGVRdWV1ZS5sZW5ndGgrdGhpcy5kZWNvZGVRdWV1ZS5sZW5ndGh9Y29uZmlndXJlKEEsSSxnKXt0aGlzLm1heERlY29kZVF1ZXVlU2l6ZT1BLHRoaXMubWF4TGF0ZW5jeUZyYW1lQ291bnQ9SSx0aGlzLm1heENvbnNlY3V0aXZlRnJhbWVzRHJvcHM9Z31hdHRhY2hUb0VsZW1lbnQoQSl7dGhpcy5zdGF0cy5yZXNldEZyYW1lQ291bnRzKCksdGhpcy5yZWFkeVN0YXRlIT1CLlZpZGVvUmVhZHlTdGF0ZS5XYWl0aW5nRm9yS2V5ZnJhbWUmJnRoaXMucmVzdGFydCgpfWF0dGFjaFRvQ2FudmFzKEEpe3RoaXMucmVhZHlTdGF0ZSE9Qi5WaWRlb1JlYWR5U3RhdGUuV2FpdGluZ0ZvcktleWZyYW1lJiZ0aGlzLnJlc3RhcnQoKSx0aGlzLmNhbnZhcyYmdGhpcy5kZXRhY2hGcm9tQ2FudmFzKCksdGhpcy5jYW52YXM9QTtjb25zdCBJPUEuZ2V0Q29udGV4dChcIndlYmdsXCIpO3RoaXMuc2hhZGVyPUMuZGVmYXVsdC5jcmVhdGUoSSksdGhpcy55VGV4dHVyZT1FLmRlZmF1bHQuY3JlYXRlKEkpLHRoaXMudVRleHR1cmU9RS5kZWZhdWx0LmNyZWF0ZShJKSx0aGlzLnZUZXh0dXJlPUUuZGVmYXVsdC5jcmVhdGUoSSl9ZGV0YWNoRnJvbUVsZW1lbnQoKXt0aGlzLnNldFJlYWR5U3RhdGUoQi5WaWRlb1JlYWR5U3RhdGUuRGV0YWNoZWQpfWRldGFjaEZyb21DYW52YXMoKXt0aGlzLmRlY29kZXJXb3JrZXIucmVsZWFzZSgpLHRoaXMueVRleHR1cmUmJnRoaXMueVRleHR1cmUuZGVsZXRlKCksdGhpcy51VGV4dHVyZSYmdGhpcy51VGV4dHVyZS5kZWxldGUoKSx0aGlzLnZUZXh0dXJlJiZ0aGlzLnZUZXh0dXJlLmRlbGV0ZSgpLHRoaXMuY2FudmFzPXZvaWQgMH1wYXVzZSgpe3RoaXMucGF1c2VkPSEwLHRoaXMuc2V0UmVhZHlTdGF0ZShCLlZpZGVvUmVhZHlTdGF0ZS5QYXVzZWQpfXBsYXkoKXt0aGlzLnBhdXNlZCYmKHRoaXMucGF1c2VkPSExLHRoaXMucmVzdGFydCgpKX1yZXN0YXJ0KCl7dGhpcy50b3RhbEZyYW1lcz0wLHRoaXMudG90YWxGcmFtZXNEcm9wcGVkPTAsdGhpcy5mcmFtZXNEcm9wcGVkU2luY2VMYXN0UmVuZGVyPTAsdGhpcy53YWl0aW5nVG9EZWNvZGVRdWV1ZT1bXSx0aGlzLnNldFJlYWR5U3RhdGUoQi5WaWRlb1JlYWR5U3RhdGUuV2FpdGluZ0ZvcktleWZyYW1lKSx0aGlzLm5lZWRzUmVzdGFydEV2ZW50Lmludm9rZSgpfXB1c2hEYXRhKEEsSSl7dmFyIGcsZSxpO2lmKHRoaXMuc3RhdHMucHVzaERhdGEoSSksdGhpcy5wYXVzZWQpcmV0dXJuO2NvbnN0IHQ9bmV3IFVpbnQ4QXJyYXkoSSk7bGV0IEM9ITE7aWYodGhpcy52aWRlb0Zvcm1hdD09US5SYWlud2F5VmlkZW9Gb3JtYXQuTGVuZ3RoUHJlZml4ZWQ/Qz10aGlzLmNvbnZlcnRUb0FubmV4YkZvcm1hdCh0KTp0aGlzLnJlYWR5U3RhdGU9PUIuVmlkZW9SZWFkeVN0YXRlLldhaXRpbmdGb3JLZXlmcmFtZSYmKEM9dGhpcy5wYXJzZUFubmV4YkZyYW1lSW5mbyh0KSksdGhpcy5yZWFkeVN0YXRlPT1CLlZpZGVvUmVhZHlTdGF0ZS5XYWl0aW5nRm9yS2V5ZnJhbWUpaWYoQyl0aGlzLnNldFJlYWR5U3RhdGUoQi5WaWRlb1JlYWR5U3RhdGUuUGxheWluZyk7ZWxzZSBpZighKG51bGw9PT0oZz10aGlzLmN1cnJlbnRGcmFtZUluZm8pfHx2b2lkIDA9PT1nP3ZvaWQgMDpnLmNvbnRhaW5zRnJhbWVEYXRhKSlyZXR1cm4oKG51bGw9PT0oZT10aGlzLmN1cnJlbnRGcmFtZUluZm8pfHx2b2lkIDA9PT1lP3ZvaWQgMDplLmNvbnRhaW5zU1BTKXx8KG51bGw9PT0oaT10aGlzLmN1cnJlbnRGcmFtZUluZm8pfHx2b2lkIDA9PT1pP3ZvaWQgMDppLmNvbnRhaW5zUFBTKSkmJnRoaXMuZGVjb2Rlcldvcmtlci5kZWNvZGUodCksdGhpcy5jdXJyZW50RnJhbWVJbmZvLmNvbnRhaW5zU1BTPSExLHRoaXMuY3VycmVudEZyYW1lSW5mby5jb250YWluc1BQUz0hMSx2b2lkKHRoaXMuY3VycmVudEZyYW1lSW5mby5jb250YWluc0ZyYW1lRGF0YT0hMCk7aWYodGhpcy5yZWFkeVN0YXRlIT1CLlZpZGVvUmVhZHlTdGF0ZS5XYWl0aW5nRm9yS2V5ZnJhbWUmJnRoaXMuY3VycmVudEZyYW1lSW5mby5jb250YWluc0ZyYW1lRGF0YSl7Y29uc3QgST17d2lkdGg6QS53aWR0aCxoZWlnaHQ6QS5oZWlnaHQsbWVkaWFUaW1lOkRhdGUubm93KCkscHJvY2Vzc2luZ0R1cmF0aW9uOjAsZXhwZWN0ZWREaXNwbGF5VGltZTowLHByZXNlbnRhdGlvblRpbWU6MCxwcmVzZW50ZWRGcmFtZXM6MH07dGhpcy5kZWNvZGUoSSx0KX19Y29udmVydFRvQW5uZXhiRm9ybWF0KEEpe2xldCBJPSExO3RoaXMuY3VycmVudEZyYW1lSW5mby5jb250YWluc0ZyYW1lRGF0YT0hMTtmb3IobGV0IGc9MDtnPEEubGVuZ3RoOyl7Y29uc3QgZT10aGlzLm50b2hsKEEsZyk7QVtnXT0wLEFbKytnXT0wLEFbKytnXT0wLEFbKytnXT0xLCsrZztjb25zdCBCPTMxJkFbZ107Qjw9NSYmQj49MT8oST01PT1CLHRoaXMuY3VycmVudEZyYW1lSW5mby5jb250YWluc0ZyYW1lRGF0YT0hMCk6Nz09Qj90aGlzLmN1cnJlbnRGcmFtZUluZm8uY29udGFpbnNTUFM9ITA6OD09QiYmKHRoaXMuY3VycmVudEZyYW1lSW5mby5jb250YWluc1BQUz0hMCksZys9ZX1yZXR1cm4gSX1udG9obChBLEkpe3JldHVybigyNTUmQVtJXSk8PDI0fCgyNTUmQVtJKzFdKTw8MTZ8KDI1NSZBW0krMl0pPDw4fDI1NSZBW0krM119cGFyc2VBbm5leGJGcmFtZUluZm8oQSl7bGV0IEk9ITE7dGhpcy5jdXJyZW50RnJhbWVJbmZvLmNvbnRhaW5zRnJhbWVEYXRhPSExO2ZvcihsZXQgZz0wO2c8QS5sZW5ndGg7KWlmKDA9PUFbZ10mJjA9PUFbZysxXSl7bGV0IGU9MDtpZigxPT1BW2crMl0/KGcrPTMsZT0zMSZBW2ddKTowPT1BW2crMl0mJjE9PUFbZyszXT8oZys9NCxlPTMxJkFbZ10pOisrZyxlPD01JiZlPj0xKXtpZih0aGlzLmN1cnJlbnRGcmFtZUluZm8uY29udGFpbnNGcmFtZURhdGE9ITAsNT09ZSl7ST0hMDticmVha319ZWxzZSA3PT1lP3RoaXMuY3VycmVudEZyYW1lSW5mby5jb250YWluc1NQUz0hMDo4PT1lJiYodGhpcy5jdXJyZW50RnJhbWVJbmZvLmNvbnRhaW5zUFBTPSEwKX1lbHNlKytnO3JldHVybiBJfWRlY29kZShBLEkpezA9PXRoaXMuZGVjb2RlUXVldWUubGVuZ3RoPygwIT10aGlzLndhaXRpbmdUb0RlY29kZVF1ZXVlLmxlbmd0aCYmKG8uUmFpbndheUxvZ2dpbmcuZXJyb3IoXCJbVmlkZW9TdHJlYW1Tb2Z0d2FyZURlY29kZXJdIGVtcHR5IGRlY29kZXIgcXVldWUsIGJ1dCB3YWl0aW5nIHRvIGRlY29kZSBxdWV1ZSBub3QgZW1wdHkhXCIpLHRoaXMud2FpdGluZ1RvRGVjb2RlUXVldWU9W10pLHRoaXMuc2VuZFRvRGVjb2RlcihBLEkpKToodGhpcy53YWl0aW5nVG9EZWNvZGVRdWV1ZS5wdXNoKHttZXRhZGF0YTpBLGRhdGE6SX0pLHRoaXMuZGVjb2RlUXVldWUubGVuZ3RoPHRoaXMubWF4RGVjb2RlUXVldWVTaXplJiZ0aGlzLnNlbmREZWNvZGVyV2FpdGluZ1RvRGVjb2RlRnJhbWVzKCkpfXNlbmREZWNvZGVyV2FpdGluZ1RvRGVjb2RlRnJhbWVzKCl7Zm9yKDt0aGlzLmRlY29kZVF1ZXVlLmxlbmd0aDx0aGlzLm1heERlY29kZVF1ZXVlU2l6ZSYmdGhpcy53YWl0aW5nVG9EZWNvZGVRdWV1ZS5sZW5ndGg+MDspe2NvbnN0IEE9dGhpcy53YWl0aW5nVG9EZWNvZGVRdWV1ZS5zaGlmdCgpO3RoaXMuc2VuZFRvRGVjb2RlcihBLm1ldGFkYXRhLEEuZGF0YSl9fXNlbmRUb0RlY29kZXIoQSxJKXt0aGlzLnN0YXRzLnJlcG9ydEZyYW1lU3VibWl0dGVkKCksdGhpcy5kZWNvZGVRdWV1ZS5wdXNoKEEpLHRoaXMuZGVjb2Rlcldvcmtlci5kZWNvZGUoSSl9cmVuZGVyRnJhbWUoQSxJLGcsZSxCKXt0aGlzLmNhbnZhcy53aWR0aD1BLHRoaXMuY2FudmFzLmhlaWdodD1JO2NvbnN0IGk9bmV3IFVpbnQ4QXJyYXkoZyksUT1lKkIsdD1pLnN1YmFycmF5KDAsUSksQz1RPj4yLEU9aS5zdWJhcnJheShRLFErQyksbz1pLnN1YmFycmF5KFErQyxRKzIqQyk7dGhpcy55VGV4dHVyZS51cGxvYWRCdWZmZXIodCxlLEIpO2NvbnN0IGE9ZT4+MSxuPUI+PjE7dGhpcy51VGV4dHVyZS51cGxvYWRCdWZmZXIoRSxhLG4pLHRoaXMudlRleHR1cmUudXBsb2FkQnVmZmVyKG8sYSxuKSx0aGlzLnNoYWRlci5iaW5kSW5wdXRUZXh0dXJlcyh0aGlzLnlUZXh0dXJlLHRoaXMudVRleHR1cmUsdGhpcy52VGV4dHVyZSk7Y29uc3Qgcz1BL2Uscj1JL0I7dGhpcy5zaGFkZXIudXBkYXRlKGUsQixzLHIpLHRoaXMuc2hhZGVyLmRyYXcoKX1nZXRTdGF0cygpe3JldHVybiB0aGlzLnN0YXRzLmNyZWF0ZVJlcG9ydCh0aGlzLnRvdGFsRnJhbWVzRHJvcHBlZCx0aGlzLnRvdGFsRnJhbWVzKX1zZXRSZWFkeVN0YXRlKEEpe3RoaXMucmVhZHlTdGF0ZT1BLHRoaXMucmVhZHlTdGF0ZUNoYW5nZUV2ZW50Lmludm9rZShBKX1kaXNwb3NlKCl7by5SYWlud2F5TG9nZ2luZy5kZWJ1ZyhcIkRpc3Bvc2luZyBWaWRlb1N0cmVhbVNvZnR3YXJlRGVjb2RlclwiKSx0aGlzLnJlYWR5U3RhdGU9Qi5WaWRlb1JlYWR5U3RhdGUuRGlzcG9zZWQsdGhpcy5kZWNvZGVyV29ya2VyLnJlbGVhc2UoKSx0aGlzLmRlY29kZXJXb3JrZXIuZGlzcG9zZSgpLHdpbmRvdy5jbGVhckludGVydmFsKHRoaXMuZW5zdXJlQnVmZmVySW50ZXJ2YWwpfX19LDEwNDpmdW5jdGlvbihBLEksZyl7XCJ1c2Ugc3RyaWN0XCI7dmFyIGUsQj10aGlzJiZ0aGlzLl9fYXdhaXRlcnx8ZnVuY3Rpb24oQSxJLGcsZSl7cmV0dXJuIG5ldyhnfHwoZz1Qcm9taXNlKSkoKGZ1bmN0aW9uKEIsaSl7ZnVuY3Rpb24gUShBKXt0cnl7QyhlLm5leHQoQSkpfWNhdGNoKEEpe2koQSl9fWZ1bmN0aW9uIHQoQSl7dHJ5e0MoZS50aHJvdyhBKSl9Y2F0Y2goQSl7aShBKX19ZnVuY3Rpb24gQyhBKXt2YXIgSTtBLmRvbmU/QihBLnZhbHVlKTooST1BLnZhbHVlLEkgaW5zdGFuY2VvZiBnP0k6bmV3IGcoKGZ1bmN0aW9uKEEpe0EoSSl9KSkpLnRoZW4oUSx0KX1DKChlPWUuYXBwbHkoQSxJfHxbXSkpLm5leHQoKSl9KSl9LGk9dGhpcyYmdGhpcy5fX2NsYXNzUHJpdmF0ZUZpZWxkR2V0fHxmdW5jdGlvbihBLEkpe2lmKCFJLmhhcyhBKSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiYXR0ZW1wdGVkIHRvIGdldCBwcml2YXRlIGZpZWxkIG9uIG5vbi1pbnN0YW5jZVwiKTtyZXR1cm4gSS5nZXQoQSl9LFE9dGhpcyYmdGhpcy5fX2NsYXNzUHJpdmF0ZUZpZWxkU2V0fHxmdW5jdGlvbihBLEksZyl7aWYoIUkuaGFzKEEpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJhdHRlbXB0ZWQgdG8gc2V0IHByaXZhdGUgZmllbGQgb24gbm9uLWluc3RhbmNlXCIpO3JldHVybiBJLnNldChBLGcpLGd9O09iamVjdC5kZWZpbmVQcm9wZXJ0eShJLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLEkuR2F0ZXdheT1JLmdldEhhbmRzaGFrZURhdGFCYXNlNjQ9SS5nZXRQZWVySWQ9SS5HYXRld2F5U3RhdHVzPXZvaWQgMDtjb25zdCB0PWcoMjkwKSxDPWcoOTk0KSxFPWcoNDY0KSxvPWcoOTA0KSxhPWcoMjQpO3ZhciBuO2Z1bmN0aW9uIHMoQSxJLGcpe2NvbnN0IGU9by5HYXRld2F5SWRlbnRpdHkuZW5jb2RlKHtpZDpBLGFwaUtleTpJLGV4dGVybmFsSWQ6Z30pO3JldHVybiBidG9hKFN0cmluZy5mcm9tQ2hhckNvZGUoLi4uZSkpLnJlcGxhY2UoLz0qJC8sXCJcIikucmVwbGFjZSgvXFwrL2csXCItXCIpLnJlcGxhY2UoL1xcLy9nLFwiX1wiKX0hZnVuY3Rpb24oQSl7QVtBLk9wZW49MF09XCJPcGVuXCIsQVtBLkNsb3NlZD0xXT1cIkNsb3NlZFwifShuPUkuR2F0ZXdheVN0YXR1c3x8KEkuR2F0ZXdheVN0YXR1cz17fSkpLEkuZ2V0UGVlcklkPWZ1bmN0aW9uKEEpe3ZhciBJO3JldHVybiBCKHRoaXMsdm9pZCAwLHZvaWQgMCwoZnVuY3Rpb24qKCl7Y29uc3QgZz15aWVsZCB0LmdldE9yZ2FuaXphdGlvbkluZm8oQSksZT1gcmFpbndheS1ob3N0bmFtZS0ke2cub3JnYW5pemF0aW9uSWQudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDgsXCIwXCIpfS0ke2cudW5pdmVyc2VGbGFnfWAsQj1CaWdJbnQobnVsbCE9PShJPWxvY2FsU3RvcmFnZS5nZXRJdGVtKGUpKSYmdm9pZCAwIT09ST9JOnlpZWxkIHQuZmV0Y2hOZXdQZWVySWQoKSk7cmV0dXJuIGxvY2FsU3RvcmFnZS5zZXRJdGVtKGUsQi50b1N0cmluZygpKSxCfSkpfSxJLmdldEhhbmRzaGFrZURhdGFCYXNlNjQ9cyxJLkdhdGV3YXk9Y2xhc3N7Y29uc3RydWN0b3IoQSxJLGcsaSxRLHQsQz1cIndzczovL2dhdGV3YXkucmFpbndheS5uZXR3b3JrXCIpe3RoaXMub3duUGVlcklkPUEsdGhpcy5hcGlLZXk9SSx0aGlzLmV4dGVybmFsSWQ9Zyx0aGlzLmhhbmRsZVBlZXJJbmZvPWksdGhpcy5jb25uZWN0aW9uUmVxdWVzdEhhbmRsZXI9USx0aGlzLmFkZEFjY2VwdGVkUGVlcj10LHRoaXMuY29ubmVjdGlvbnM9bmV3IE1hcCx0aGlzLmNvbm5lY3Rpb25Mb3N0RXZlbnQ9bmV3IGEuQWN0aW9uLGUuc2V0KHRoaXMsbi5DbG9zZWQpLHRoaXMuc3luY0tleT0wLHRoaXMucGVlcklkVG9FeHRlcm5hbElkPW5ldyBNYXAsdGhpcy5vbk1lc3NhZ2U9QT0+Qih0aGlzLHZvaWQgMCx2b2lkIDAsKGZ1bmN0aW9uKigpe3ZhciBJO2lmKHZvaWQgMCE9PXRoaXMuc29ja2V0JiZcIltvYmplY3QgQXJyYXlCdWZmZXJdXCI9PT1BLmRhdGEudG9TdHJpbmcoKSl7Y29uc3QgZz1vLkdhdGV3YXlEYXRhZ3JhbS5kZWNvZGUobmV3IFVpbnQ4QXJyYXkoQS5kYXRhKSkse2hlYWRlcjp7c3luY0tleTplfSxib2R5OkJ9PWc7c3dpdGNoKEIuZGlzY3JpbWluYXRvcil7Y2FzZSBvLkdhdGV3YXlSZXF1ZXN0LmRpc2NyaW1pbmF0b3I6RS5SYWlud2F5TG9nZ2luZy53YXJuaW5nKFwiZ290IEdhdGV3YXlSZXF1ZXN0PyEgaSBhbSBub3QgYSBnYXRld2F5LiBpZ25vcmluZ1wiKTticmVhaztjYXNlIG8uR2F0ZXdheVJlc3BvbnNlLmRpc2NyaW1pbmF0b3I6e2NvbnN0IEE9Qi52YWx1ZS5ib2R5LnZhbHVlO0UuUmFpbndheUxvZ2dpbmcudHJhY2UoXCJnb3QgR2F0ZXdheUhlbGxvXCIpLG51bGw9PT0oST10aGlzLnJlc29sdmVDb25uZWN0VG9HYXRld2F5UHJvbWlzZSl8fHZvaWQgMD09PUl8fEkuY2FsbCh0aGlzLEEpO2JyZWFrfWNhc2Ugby5HYXRld2F5QWxlcnQuZGlzY3JpbWluYXRvcjp7Y29uc3R7bGV2ZWw6QSxkZXNjcmlwdGlvbjpJfT1CLnZhbHVlO0E9PT1vLkdhdGV3YXlBbGVydExldmVsLkZhdGFsPyhFLlJhaW53YXlMb2dnaW5nLmVycm9yKFwiRmF0YWwgR2F0ZXdheUFsZXJ0OiBcIitvLkdhdGV3YXlBbGVydERlc2NyaXB0aW9uW0ldKSx0aGlzLmRpZShJLFwiVGhlIGNvbm5lY3Rpb24gdG8gdGhlIFJhaW53YXkgc2VydmVyIGVuY291bnRlcmVkIGEgZmF0YWwgZXJyb3IuXCIpKTp0aGlzLm9uTm9uRmF0YWxBbGVydChlLEkpO2JyZWFrfWNhc2Ugby5HYXRld2F5Rm9yd2FyZGFibGUuZGlzY3JpbWluYXRvcjp0aGlzLm9uRm9yd2FyZGFibGUoZSxCLnZhbHVlKX19fSkpLHRoaXMub25DbG9zZT1BPT57dGhpcy5kaWUoQSxcIlRoZSBjb25uZWN0aW9uIHRvIHRoZSBSYWlud2F5IHNlcnZlciB3YXMgY2xvc2VkLlwiKX0sdGhpcy5vbkVycm9yPUE9Pnt0aGlzLmRpZShBLFwiVGhlIGNvbm5lY3Rpb24gdG8gdGhlIFJhaW53YXkgc2VydmVyIHdhcyBsb3N0LlwiKX0sd2luZG93Ll9fcmFpbndheUdhdGV3YXk9dGhpcyx0aGlzLnVybD1DfWdldCBzdGF0dXMoKXtyZXR1cm4gaSh0aGlzLGUpfWNvbm5lY3QoKXt2YXIgQTtyZXR1cm4gQih0aGlzLHZvaWQgMCx2b2lkIDAsKGZ1bmN0aW9uKigpe3JldHVybiBudWxsIT09KEE9dGhpcy5jb25uZWN0VG9HYXRld2F5UHJvbWlzZSkmJnZvaWQgMCE9PUE/QTp0aGlzLmNvbm5lY3RUb0dhdGV3YXlQcm9taXNlPW5ldyBQcm9taXNlKCgoQSxJKT0+e3RoaXMucmVzb2x2ZUNvbm5lY3RUb0dhdGV3YXlQcm9taXNlPUEsdGhpcy5yZWplY3RDb25uZWN0VG9HYXRld2F5UHJvbWlzZT1JLHRoaXMub3BlbigpfSkpfSkpfW9wZW4oKXtyZXR1cm4gQih0aGlzLHZvaWQgMCx2b2lkIDAsKGZ1bmN0aW9uKigpe3RoaXMuc29ja2V0PXlpZWxkIHRoaXMubWFrZVdlYlNvY2tldCh0aGlzLnVybCksRS5SYWlud2F5TG9nZ2luZy5kZWJ1ZyhcIkdhdGV3YXk6IGNvbm5lY3RlZCBXZWJTb2NrZXRcIiksdGhpcy5zb2NrZXQuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIix0aGlzLm9uTWVzc2FnZSksdGhpcy5zb2NrZXQuYWRkRXZlbnRMaXN0ZW5lcihcImNsb3NlXCIsdGhpcy5vbkNsb3NlKSxRKHRoaXMsZSxuLk9wZW4pfSkpfW1ha2VXZWJTb2NrZXQoQSl7cmV0dXJuIG5ldyBQcm9taXNlKCgoSSxnKT0+e2NvbnN0IGU9bmV3IFdlYlNvY2tldChBLFtcImhhbmRzaGFrZVwiLHModGhpcy5vd25QZWVySWQsdGhpcy5hcGlLZXksdGhpcy5leHRlcm5hbElkKV0pO2UuYmluYXJ5VHlwZT1cImFycmF5YnVmZmVyXCIsZS5vbm9wZW49KCk9PntJKGUpfSxlLm9uZXJyb3I9QT0+e3RoaXMub25FcnJvcihBKSxnKEEpLHRoaXMuY29ubmVjdFRvR2F0ZXdheVByb21pc2U9dm9pZCAwfX0pKX1kaXNjb25uZWN0KCl7dmFyIEE7aWYoRS5SYWlud2F5TG9nZ2luZy5kZWJ1ZyhcIkdhdGV3YXk6IGNsb3NlKClcIiksdm9pZCAwIT09dGhpcy5zb2NrZXQpe3RoaXMuc29ja2V0LmNsb3NlKDNlMyxcIlNpZ25hbGluZyB3ZWJzb2NrZXQgY2xvc2VkLlwiKTtjb25zdCBBPXRoaXMuc29ja2V0O3dpbmRvdy5zZXRUaW1lb3V0KCgoKT0+e0EucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNsb3NlXCIsdGhpcy5vbkNsb3NlKSxBLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsdGhpcy5vbk1lc3NhZ2UpfSksMCl9bnVsbD09PShBPXRoaXMucmVqZWN0Q29ubmVjdFRvR2F0ZXdheVByb21pc2UpfHx2b2lkIDA9PT1BfHxBLmNhbGwodGhpcyx2b2lkIDApLFEodGhpcyxlLG4uQ2xvc2VkKSx0aGlzLmNvbm5lY3RUb0dhdGV3YXlQcm9taXNlPXZvaWQgMCx0aGlzLnJlc29sdmVDb25uZWN0VG9HYXRld2F5UHJvbWlzZT12b2lkIDAsdGhpcy5yZWplY3RDb25uZWN0VG9HYXRld2F5UHJvbWlzZT12b2lkIDAsdGhpcy5zb2NrZXQ9dm9pZCAwLHRoaXMuY29ubmVjdGlvbnMuY2xlYXIoKX1tYWtlRGF0YWdyYW0oQSl7cmV0dXJue2hlYWRlcjp7c3luY0tleTorK3RoaXMuc3luY0tleX0sYm9keTpBfX1tYWtlRm9yd2FyZGFibGUoQSxJKXtyZXR1cm4gdGhpcy5tYWtlRGF0YWdyYW0oe2Rpc2NyaW1pbmF0b3I6by5HYXRld2F5Rm9yd2FyZGFibGUuZGlzY3JpbWluYXRvcix2YWx1ZTp7dGFyZ2V0UGVlcklkOkEsYm9keTpJfX0pfWNvbm5lY3RUb0hvc3QoQSxJKXtjb25zdCBnPXRoaXMuY29ubmVjdGlvbnMuZ2V0KEEpO2lmKHZvaWQgMCE9PWcpe2lmKGcub3duZWQpdGhyb3cgbmV3IEMuUmFpbndheUVycm9yKFwiYWxyZWFkeSBjb25uZWN0ZWQgaW4gb3RoZXIgZGlyZWN0aW9uXCIpO3JldHVybiBnLnByb21pc2V9aWYodm9pZCAwPT09dGhpcy5zb2NrZXQpdGhyb3cgbmV3IEMuUmFpbndheUVycm9yKFwic29ja2V0IHVuZGVmaW5lZCBpbiBzZW5kSW5pdENvbm5lY3Rpb25SZXF1ZXN0XCIpO2lmKHRoaXMuc3RhdHVzIT09bi5PcGVuKXRocm93IG5ldyBDLlJhaW53YXlFcnJvcihcInNpZ25hbGluZyBjaGFubmVsIG5vdCBvcGVuIGluIHNlbmRJbml0Q29ubmVjdGlvblJlcXVlc3RcIik7Y29uc3QgZT10aGlzLnNvY2tldCxCPXtwZW5kaW5nOiEwfTtyZXR1cm4gQi5wcm9taXNlPW5ldyBQcm9taXNlKCgoZyxpKT0+e0IucmVzb2x2ZT1nLEIucmVqZWN0PWksRS5SYWlud2F5TG9nZ2luZy50cmFjZShgR2F0ZXdheTogQWRkaW5nICR7QX0gdG8gcGVuZGluZ0Nvbm5lY3Rpb25zYCk7Y29uc3QgUT10aGlzLm1ha2VEYXRhZ3JhbSh7ZGlzY3JpbWluYXRvcjpvLkdhdGV3YXlSZXF1ZXN0LmRpc2NyaW1pbmF0b3IsdmFsdWU6e2JvZHk6e2Rpc2NyaW1pbmF0b3I6by5Jbml0Q29ubmVjdGlvblJlcXVlc3QuZGlzY3JpbWluYXRvcix2YWx1ZTp7ZGVzaXJlZFRyYW5zcG9ydDpJLHRhcmdldFBlZXJJZDpBfX19fSk7Qi5zeW5jS2V5PVEuaGVhZGVyLnN5bmNLZXksdGhpcy5jb25uZWN0aW9ucy5zZXQoQSxCKSxlLnNlbmQoby5HYXRld2F5RGF0YWdyYW0uZW5jb2RlKFEpKX0pKSxCLnByb21pc2V9Y2FuY2VsQ29ubmVjdGlvbkF0dGVtcHQoQSl7Y29uc3QgST10aGlzLmNvbm5lY3Rpb25zLmdldChBKTt2b2lkIDAhPT1JJiZJLnBlbmRpbmcmJihJLnJlc29sdmUoe2NhbmNlbGVkOiEwfSksdGhpcy5jb25uZWN0aW9ucy5kZWxldGUoQSkpfWRlbGV0ZUNvbm5lY3Rpb24oQSl7dGhpcy5jb25uZWN0aW9ucy5kZWxldGUoQSl9c2VuZFBlZXJJbmZvKEEsSSxnKXtpZih2b2lkIDA9PT10aGlzLnNvY2tldCl0aHJvdyBuZXcgQy5SYWlud2F5RXJyb3IoXCJzb2NrZXQgdW5zZXQgaW4gR2F0ZXdheS5zZW5kUGVlckluZm9cIik7Y29uc3QgZT10aGlzLmNvbm5lY3Rpb25zLmdldChBKTtpZih2b2lkIDA9PT1lKXRocm93IG5ldyBDLlJhaW53YXlFcnJvcihgY2FuJ3Qgc2VuZCBwZWVyIGluZm8gdG8gdW5rbm93biBwZWVySWQgJHtBfWApO2lmKGUucGVuZGluZyl0aHJvdyBuZXcgQy5SYWlud2F5RXJyb3IoYGNhbid0IHNlbmQgcGVlciBpbmZvIHRvIHBlbmRpbmcgcGVlcklkICR7QX1gKTtjb25zdCBCPXRoaXMubWFrZUZvcndhcmRhYmxlKEEse2Rpc2NyaW1pbmF0b3I6by5QZWVyU2lnbmFsaW5nSW5mb3JtYXRpb24uZGlzY3JpbWluYXRvcix2YWx1ZTp7aWQ6ZS5jb25uZWN0aW9uUmVxdWVzdElkLHR5cGU6SSxkYXRhOmd9fSksaT1vLkdhdGV3YXlEYXRhZ3JhbS5lbmNvZGUoQik7dGhpcy5zb2NrZXQuc2VuZChpKX1zZW5kT2ZmZXIoQSxJKXtFLlJhaW53YXlMb2dnaW5nLmRlYnVnKFwic2VuZGluZyBvZmZlcjogXCIrSSksdGhpcy5zZW5kUGVlckluZm8oQSxvLlBlZXJJbmZvcm1hdGlvblR5cGUuT2ZmZXIsSSl9c2VuZEFuc3dlcihBLEkpe0UuUmFpbndheUxvZ2dpbmcuZGVidWcoXCJzZW5kaW5nIG9mZmVyOiBcIitJKSx0aGlzLnNlbmRQZWVySW5mbyhBLG8uUGVlckluZm9ybWF0aW9uVHlwZS5BbnN3ZXIsSSl9c2VuZENhbmRpZGF0ZShBLEkpe0UuUmFpbndheUxvZ2dpbmcuZGVidWcoXCJzZW5kaW5nIGNhbmRpZGF0ZVwiK0kuY2FuZGlkYXRlKSx0aGlzLnNlbmRQZWVySW5mbyhBLG8uUGVlckluZm9ybWF0aW9uVHlwZS5DYW5kaWRhdGUsSS5jYW5kaWRhdGUpfW9uTm9uRmF0YWxBbGVydChBLEkpe2lmKEk9PT1vLkdhdGV3YXlBbGVydERlc2NyaXB0aW9uLlBlZXJHb25lQXdheSlmb3IoY29uc3RbSSxnXW9mIHRoaXMuY29ubmVjdGlvbnMuZW50cmllcygpKWcucGVuZGluZyYmZy5zeW5jS2V5PT09QSYmKGcucmVqZWN0KFwiVGhlIHRhcmdldCBwZWVyIGlzIG5vdCBjb25uZWN0ZWQgdG8gUmFpbndheS5cIiksdGhpcy5jb25uZWN0aW9ucy5kZWxldGUoSSkpfW9uRm9yd2FyZGFibGUoQSxJKXtjb25zdHt0YXJnZXRQZWVySWQ6Zyxib2R5OmV9PUk7c3dpdGNoKGUuZGlzY3JpbWluYXRvcil7Y2FzZSBvLkNvbm5lY3Rpb25SZXF1ZXN0LmRpc2NyaW1pbmF0b3I6e2NvbnN0e3NvdXJjZVBlZXJJZDpJLHNvdXJjZUV4dGVybmFsSWQ6ZyxkZXNpcmVkVHJhbnNwb3J0OkIsaWQ6aSxleHBpcmF0aW9uRGF0ZTpRfT1lLnZhbHVlLHQ9aTt0aGlzLnBlZXJJZFRvRXh0ZXJuYWxJZC5zZXQoSSxnKSx0aGlzLmNvbm5lY3Rpb25SZXF1ZXN0SGFuZGxlcih7cGVlcklkOkksZXh0ZXJuYWxJZDplLnZhbHVlLnNvdXJjZUV4dGVybmFsSWQsYWNjZXB0OigpPT57aWYodm9pZCAwPT09dGhpcy5zb2NrZXQpdGhyb3cgbmV3IEMuUmFpbndheUVycm9yKFwiQ291bGRuJ3Qgc2VuZCBhY2NlcHQgbWVzc2FnZSBiZWNhdXNlIHRoZSBjb25uZWN0aW9uIHRvIFJhaW53YXkgd2FzIGxvc3QuXCIpO2NvbnN0IGU9by5HYXRld2F5RGF0YWdyYW0uZW5jb2RlKHtoZWFkZXI6e3N5bmNLZXk6QX0sYm9keTp7ZGlzY3JpbWluYXRvcjpvLkdhdGV3YXlGb3J3YXJkYWJsZS5kaXNjcmltaW5hdG9yLHZhbHVlOnt0YXJnZXRQZWVySWQ6SSxib2R5OntkaXNjcmltaW5hdG9yOm8uQWNjZXB0ZWRDb25uZWN0aW9uUmVxdWVzdC5kaXNjcmltaW5hdG9yLHZhbHVlOntzb3VyY2VQZWVySWQ6dGhpcy5vd25QZWVySWQsc291cmNlRXh0ZXJuYWxJZDp0aGlzLmV4dGVybmFsSWQsaWQ6aX19fX19KTt0aGlzLnNvY2tldC5zZW5kKGUpLHRoaXMuY29ubmVjdGlvbnMuc2V0KEkse3BlbmRpbmc6ITEsb3duZWQ6ITAsY29ubmVjdGlvblJlcXVlc3RJZDp0fSksdGhpcy5hZGRBY2NlcHRlZFBlZXIoSSxnLHQpfSxyZWplY3Q6Zz0+e2lmKHZvaWQgMD09PXRoaXMuc29ja2V0KXRocm93IG5ldyBDLlJhaW53YXlFcnJvcihcIkNvdWxkbid0IHNlbmQgcmVqZWN0IG1lc3NhZ2UgYmVjYXVzZSB0aGUgY29ubmVjdGlvbiB0byBSYWlud2F5IHdhcyBsb3N0LlwiKTtjb25zdCBlPW8uR2F0ZXdheURhdGFncmFtLmVuY29kZSh7aGVhZGVyOntzeW5jS2V5OkF9LGJvZHk6e2Rpc2NyaW1pbmF0b3I6by5HYXRld2F5Rm9yd2FyZGFibGUuZGlzY3JpbWluYXRvcix2YWx1ZTp7dGFyZ2V0UGVlcklkOkksYm9keTp7ZGlzY3JpbWluYXRvcjpvLlJlamVjdGVkQ29ubmVjdGlvblJlcXVlc3QuZGlzY3JpbWluYXRvcix2YWx1ZTp7c291cmNlUGVlcklkOnRoaXMub3duUGVlcklkLHNvdXJjZUV4dGVybmFsSWQ6dGhpcy5leHRlcm5hbElkLGlkOmkscmVhc29uOmd9fX19fSk7dGhpcy5zb2NrZXQuc2VuZChlKX19KTticmVha31jYXNlIG8uQWNjZXB0ZWRDb25uZWN0aW9uUmVxdWVzdC5kaXNjcmltaW5hdG9yOntjb25zdHtpZDpBLHNvdXJjZVBlZXJJZDpJLHNvdXJjZUV4dGVybmFsSWQ6Z309ZS52YWx1ZSxCPUEsaT10aGlzLmNvbm5lY3Rpb25zLmdldChJKTtpZih2b2lkIDA9PT1pKXJldHVybiB2b2lkIEUuUmFpbndheUxvZ2dpbmcud2FybmluZyhcIklnbm9yaW5nIEFjY2VwdGVkQ29ubmVjdGlvblJlcXVlc3QgZnJvbSB1bmV4cGVjdGVkIGhvc3RuYW1lOiBcIitJKTtpZighaS5wZW5kaW5nKXJldHVybiB2b2lkIEUuUmFpbndheUxvZ2dpbmcud2FybmluZyhcIklnbm9yaW5nIEFjY2VwdGVkQ29ubmVjdGlvblJlcXVlc3QgZnJvbSBhbHJlYWR5LWNvbm5lY3RlZCBob3N0bmFtZTogXCIrSSk7aS5yZXNvbHZlKHtjYW5jZWxlZDohMSxhY2NlcHRlZDohMCxjb25uZWN0aW9uUmVxdWVzdElkOkIsaG9zdEV4dGVybmFsSWQ6Zyx0cmFuc3BvcnRQcm90b2NvbDpvLlBlZXJUcmFuc3BvcnRUeXBlLlNDVFB9KSx0aGlzLmNvbm5lY3Rpb25zLnNldChJLHtwZW5kaW5nOiExLG93bmVkOiExLHByb21pc2U6aS5wcm9taXNlLGNvbm5lY3Rpb25SZXF1ZXN0SWQ6Qn0pO2JyZWFrfWNhc2Ugby5SZWplY3RlZENvbm5lY3Rpb25SZXF1ZXN0LmRpc2NyaW1pbmF0b3I6e2NvbnN0e2lkOkEsc291cmNlUGVlcklkOkksc291cmNlRXh0ZXJuYWxJZDpnfT1lLnZhbHVlLEI9QSxpPXRoaXMuY29ubmVjdGlvbnMuZ2V0KEkpO2lmKHZvaWQgMD09PWkpcmV0dXJuIHZvaWQgRS5SYWlud2F5TG9nZ2luZy53YXJuaW5nKFwiSWdub3JpbmcgUmVqZWN0ZWRDb25uZWN0aW9uUmVxdWVzdCBmcm9tIHVuZXhwZWN0ZWQgaG9zdG5hbWU6IFwiK0kpO2lmKCFpLnBlbmRpbmcpcmV0dXJuIHZvaWQgRS5SYWlud2F5TG9nZ2luZy53YXJuaW5nKFwiSWdub3JpbmcgUmVqZWN0ZWRDb25uZWN0aW9uUmVxdWVzdCBmcm9tIGFscmVhZHktY29ubmVjdGVkIGhvc3RuYW1lOiBcIitJKTtpLnJlc29sdmUoe2NhbmNlbGVkOiExLGFjY2VwdGVkOiExLGNvbm5lY3Rpb25SZXF1ZXN0SWQ6Qixob3N0RXh0ZXJuYWxJZDpnLHRyYW5zcG9ydFByb3RvY29sOm8uUGVlclRyYW5zcG9ydFR5cGUuU0NUUCxyZWFzb246ZS52YWx1ZS5yZWFzb259KSx0aGlzLmNvbm5lY3Rpb25zLmRlbGV0ZShJKTticmVha31jYXNlIG8uUGVlclNpZ25hbGluZ0luZm9ybWF0aW9uLmRpc2NyaW1pbmF0b3I6RS5SYWlud2F5TG9nZ2luZy50cmFjZShcIkdvdCBwZWVyIGluZm86XFxuXCIrSlNPTi5zdHJpbmdpZnkoZS52YWx1ZSkpLHRoaXMuaGFuZGxlUGVlckluZm8oZS52YWx1ZSl9fWRpZShBLEkpe3ZhciBnLGU7bnVsbD09PShnPXRoaXMucmVqZWN0Q29ubmVjdFRvR2F0ZXdheVByb21pc2UpfHx2b2lkIDA9PT1nfHxnLmNhbGwodGhpcyxBKSx0aGlzLmNvbm5lY3RUb0dhdGV3YXlQcm9taXNlPXZvaWQgMCx0aGlzLnJlc29sdmVDb25uZWN0VG9HYXRld2F5UHJvbWlzZT12b2lkIDAsdGhpcy5yZWplY3RDb25uZWN0VG9HYXRld2F5UHJvbWlzZT12b2lkIDA7Zm9yKGNvbnN0IEEgb2YgdGhpcy5jb25uZWN0aW9ucy52YWx1ZXMoKSlBLnBlbmRpbmcmJkEucmVqZWN0KEkpO3RoaXMuY29ubmVjdGlvbnMuY2xlYXIoKSxudWxsPT09KGU9dGhpcy5jb25uZWN0aW9uTG9zdEV2ZW50KXx8dm9pZCAwPT09ZXx8ZS5pbnZva2UobmV3IEMuUmFpbndheUVycm9yKEkpKX11bnNldENvbm5lY3RUb0dhdGV3YXlQcm9taXNlKCl7dGhpcy5jb25uZWN0VG9HYXRld2F5UHJvbWlzZT12b2lkIDAsdGhpcy5yZXNvbHZlQ29ubmVjdFRvR2F0ZXdheVByb21pc2U9dm9pZCAwLHRoaXMucmVqZWN0Q29ubmVjdFRvR2F0ZXdheVByb21pc2U9dm9pZCAwfX0sZT1uZXcgV2Vha01hcH0sNjQzOmZ1bmN0aW9uKEEsSSxnKXtcInVzZSBzdHJpY3RcIjt2YXIgZSxCPXRoaXMmJnRoaXMuX19hd2FpdGVyfHxmdW5jdGlvbihBLEksZyxlKXtyZXR1cm4gbmV3KGd8fChnPVByb21pc2UpKSgoZnVuY3Rpb24oQixpKXtmdW5jdGlvbiBRKEEpe3RyeXtDKGUubmV4dChBKSl9Y2F0Y2goQSl7aShBKX19ZnVuY3Rpb24gdChBKXt0cnl7QyhlLnRocm93KEEpKX1jYXRjaChBKXtpKEEpfX1mdW5jdGlvbiBDKEEpe3ZhciBJO0EuZG9uZT9CKEEudmFsdWUpOihJPUEudmFsdWUsSSBpbnN0YW5jZW9mIGc/STpuZXcgZygoZnVuY3Rpb24oQSl7QShJKX0pKSkudGhlbihRLHQpfUMoKGU9ZS5hcHBseShBLEl8fFtdKSkubmV4dCgpKX0pKX07T2JqZWN0LmRlZmluZVByb3BlcnR5KEksXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksSS5SYWlud2F5UmF0ZUNvbnRyb2xsZXI9SS5kZWZhdWx0UmF0ZUNvbnRyb2xQYXJhbWV0ZXJzPUkuUXVhbGl0eUFkanVzdG1lbnQ9dm9pZCAwO2NvbnN0IGk9ZygxOTgpLFE9Zyg0MzQpLHQ9Zyg0NjQpLEM9Zyg2OTUpO3ZhciBFOyFmdW5jdGlvbihBKXtBW0EuVXA9MF09XCJVcFwiLEFbQS5Eb3duPTFdPVwiRG93blwifShFPUkuUXVhbGl0eUFkanVzdG1lbnR8fChJLlF1YWxpdHlBZGp1c3RtZW50PXt9KSksSS5kZWZhdWx0UmF0ZUNvbnRyb2xQYXJhbWV0ZXJzPXtiZWF0TXM6MjUwMCx3aW5kb3dNczo0NTAwLGJhZEJlYXRzOjIsZ29vZEJlYXRzOjQsYmFja29mZkZhY3RvcjoyLGxhdGVuZXNzVGhyZXNob2xkTXM6MjAwLGxhdGVuZXNzU21vb3RoaW5nRmFjdG9yOi45Mzc1LGJhZExhdGVGcmFtZVJhdGlvOi43NSxpbml0aWFsQml0cmF0ZUticHM6TnVtYmVyKG51bGwhPT0oZT1uZXcgVVJMU2VhcmNoUGFyYW1zKHdpbmRvdy5sb2NhdGlvbi5zZWFyY2gpLmdldChcImluaXRpYWwtYml0cmF0ZVwiKSkmJnZvaWQgMCE9PWU/ZTo1ZTMpLHF1YWxpdHlTdGVwRmFjdG9yOjEuMTg3NX0sSS5SYWlud2F5UmF0ZUNvbnRyb2xsZXI9Y2xhc3N7Y29uc3RydWN0b3IoQT1JLmRlZmF1bHRSYXRlQ29udHJvbFBhcmFtZXRlcnMsZyxlLHQpe3RoaXMuY2hvc2VuVmlkZW9Db25maWc9Zyx0aGlzLnBlcmZvcm1hbmNlTW9uaXRvcj10LHRoaXMuYmFkQmVhdENvdW50PTAsdGhpcy5nb29kQmVhdENvdW50PTAsdGhpcy5sYXN0QWRqdXN0bWVudD12b2lkIDAsdGhpcy5oaXN0b3J5PVtdLHRoaXMubG93ZXN0RGVsdGE9dm9pZCAwLHRoaXMuc21vb3RoTGF0ZW5lc3M9MCx0aGlzLmZyYW1lc1RoaXNCZWF0PTAsdGhpcy5sYXRlRnJhbWVzVGhpc0JlYXQ9MCx0aGlzLmRlYnVnTGF0ZW5lc3NTbW9vdGhpbmc9ITEsdGhpcy5iYWRDcHVQZXJmVGhpc0JlYXQ9ITEsdGhpcy5iYWREZWNvZGVyUGVyZlRoaXNCZWF0PSExLHRoaXMuYmFkQ3B1UGVyZkhhbmRsZXI9KCk9Pnt0aGlzLmJhZENwdVBlcmZUaGlzQmVhdD0hMH0sdGhpcy5iYWREZWNvZGVyUGVyZkhhbmRsZXI9KCk9Pnt0aGlzLmJhZERlY29kZXJQZXJmVGhpc0JlYXQ9ITB9LHRoaXMuaGFuZGxlVmlkZW9SZWFkeVN0YXRlPUE9PntBPT09US5WaWRlb1JlYWR5U3RhdGUuRGV0YWNoZWR8fEE9PT1RLlZpZGVvUmVhZHlTdGF0ZS5QYXVzZWR8fEE9PT1RLlZpZGVvUmVhZHlTdGF0ZS5XYWl0aW5nRm9yS2V5ZnJhbWU/dGhpcy5zdG9wKCk6dGhpcy5zdGFydCgpfSx0aGlzLmNoZWNrPSgpPT5CKHRoaXMsdm9pZCAwLHZvaWQgMCwoZnVuY3Rpb24qKCl7MCE9PXRoaXMuZnJhbWVzVGhpc0JlYXQmJigoeWllbGQgdGhpcy5iZWF0SXNCYWQoKSk/dGhpcy5iYWRCZWF0KCk6dGhpcy5nb29kQmVhdCgpLHRoaXMuZnJhbWVzVGhpc0JlYXQ9MCx0aGlzLmxhdGVGcmFtZXNUaGlzQmVhdD0wLHRoaXMuYmFkQ3B1UGVyZlRoaXNCZWF0PSExLHRoaXMuYmFkRGVjb2RlclBlcmZUaGlzQmVhdD0hMSl9KSksdGhpcy5vd25NYXhpbXVtS2Jwcz0xLzAsdGhpcy5jaG9zZW5WaWRlb0NvbmZpZ01pbWVUeXBlPUMudmlkZW9Db2RlY01pbWVUeXBlKGcuY29kZWMpLHRoaXMucGFyYW1ldGVycz1PYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sSS5kZWZhdWx0UmF0ZUNvbnRyb2xQYXJhbWV0ZXJzKSxBKSx0aGlzLnN1Z2dlc3RCaXRyYXRlS2Jwcz1lLHRoaXMuY3VycmVudEJpdHJhdGVLYnBzPXRoaXMucGFyYW1ldGVycy5pbml0aWFsQml0cmF0ZUticHMsdGhpcy5mcmFtZVZhcmlhbmNlTXM9bmV3IGkuV2luZG93VHJhY2sodGhpcy5wYXJhbWV0ZXJzLndpbmRvd01zLGkuc3RhbmRhcmREZXZpYXRpb24pfWZvcm1hdChBKXtyZXR1cm5gW1JhdGVDb250cm9sOiAke3RoaXMuY3VycmVudEJpdHJhdGVLYnBzLnRvRml4ZWQoMCkrXCJrYnBzXCJ9LCArJHt0aGlzLnNtb290aExhdGVuZXNzLnRvRml4ZWQoMCl9bXNdICR7QX1gfWRlYnVnKEEpe3QuUmFpbndheUxvZ2dpbmcuZGVidWcodGhpcy5mb3JtYXQoQSkpfWluZm8oQSl7dC5SYWlud2F5TG9nZ2luZy5pbmZvcm1hdGlvbih0aGlzLmZvcm1hdChBKSl9c3RhcnQoKXt2YXIgQSxJO3RoaXMuY2hlY2tJbnRlcnZhbHx8KHRoaXMuaW5mbyhcIlN0YXJ0aW5nIHJhdGUgY29udHJvbCFcIiksdGhpcy5jaGVja0ludGVydmFsPXdpbmRvdy5zZXRJbnRlcnZhbCh0aGlzLmNoZWNrLHRoaXMucGFyYW1ldGVycy5iZWF0TXMpLG51bGw9PT0oQT10aGlzLnBlcmZvcm1hbmNlTW9uaXRvcil8fHZvaWQgMD09PUF8fEEuY3B1U3RhcnZhdGlvbkV2ZW50LmFkZEhhbmRsZXIodGhpcy5iYWRDcHVQZXJmSGFuZGxlciksbnVsbD09PShJPXRoaXMucGVyZm9ybWFuY2VNb25pdG9yKXx8dm9pZCAwPT09SXx8SS5kZWNvZGVyU3RydWdnbGluZ0V2ZW50LmFkZEhhbmRsZXIodGhpcy5iYWREZWNvZGVyUGVyZkhhbmRsZXIpKX1zdG9wKCl7dmFyIEEsSTt0aGlzLmNoZWNrSW50ZXJ2YWwmJih0aGlzLmluZm8oXCJTdG9wcGluZyByYXRlIGNvbnRyb2whXCIpLHdpbmRvdy5jbGVhckludGVydmFsKHRoaXMuY2hlY2tJbnRlcnZhbCksdGhpcy5jaGVja0ludGVydmFsPXZvaWQgMCxudWxsPT09KEE9dGhpcy5wZXJmb3JtYW5jZU1vbml0b3IpfHx2b2lkIDA9PT1BfHxBLmNwdVN0YXJ2YXRpb25FdmVudC5yZW1vdmVIYW5kbGVyKHRoaXMuYmFkQ3B1UGVyZkhhbmRsZXIpLG51bGw9PT0oST10aGlzLnBlcmZvcm1hbmNlTW9uaXRvcil8fHZvaWQgMD09PUl8fEkuZGVjb2RlclN0cnVnZ2xpbmdFdmVudC5yZW1vdmVIYW5kbGVyKHRoaXMuYmFkRGVjb2RlclBlcmZIYW5kbGVyKSl9ZmVlZEZyYW1lVGltZXN0YW1wKEEpe2NvbnN0IEk9cGVyZm9ybWFuY2Uubm93KCktQTsodm9pZCAwPT09dGhpcy5sb3dlc3REZWx0YXx8STx0aGlzLmxvd2VzdERlbHRhfHxNYXRoLmFicyh0aGlzLmxvd2VzdERlbHRhLUkpPjVlNCkmJih0aGlzLmxvd2VzdERlbHRhPUkpO2NvbnN0IGc9SS10aGlzLmxvd2VzdERlbHRhLGU9dGhpcy5wYXJhbWV0ZXJzLmxhdGVuZXNzU21vb3RoaW5nRmFjdG9yO2lmKHRoaXMuc21vb3RoTGF0ZW5lc3M9ZSp0aGlzLnNtb290aExhdGVuZXNzKygxLWUpKmcsdGhpcy5mcmFtZXNUaGlzQmVhdCsrLHRoaXMuc21vb3RoTGF0ZW5lc3M+PXRoaXMucGFyYW1ldGVycy5sYXRlbmVzc1RocmVzaG9sZE1zJiZ0aGlzLmxhdGVGcmFtZXNUaGlzQmVhdCsrLHRoaXMuZGVidWdMYXRlbmVzc1Ntb290aGluZyl7Y29uc3QgQT1uZXcgQXJyYXkoMTAwKTtBLmZpbGwoXCItXCIpO2NvbnN0IEk9ZyxlPXRoaXMuc21vb3RoTGF0ZW5lc3M7QVs1MF09XCIuXCIsQVtNYXRoLm1heCgwLE1hdGgubWluKE1hdGgucm91bmQoSS8xMCs1MCksOTkpKV09XCJMXCIsQVtNYXRoLm1heCgwLE1hdGgubWluKE1hdGgucm91bmQoZS8xMCs1MCksOTkpKV09XCJTXCIsdGhpcy5iZWF0SXNCYWQoKS50aGVuKChnPT50LlJhaW53YXlMb2dnaW5nLmRlYnVnKGAke0Euam9pbihcIlwiKX0gTD0ke0l9IFM9JHtlfSBiYWQ9JHtnfSBsZD0ke3RoaXMubG93ZXN0RGVsdGF9YCkpKX19ZGVjb2RpbmdJbmZvQXRCaXRyYXRlKEEpe3JldHVybiBuYXZpZ2F0b3IubWVkaWFDYXBhYmlsaXRpZXMuZGVjb2RpbmdJbmZvKHt0eXBlOlwibWVkaWEtc291cmNlXCIsdmlkZW86e3dpZHRoOnRoaXMuY2hvc2VuVmlkZW9Db25maWcuY29kZWMud2lkdGgsaGVpZ2h0OnRoaXMuY2hvc2VuVmlkZW9Db25maWcuY29kZWMuaGVpZ2h0LGZyYW1lcmF0ZTp0aGlzLmNob3NlblZpZGVvQ29uZmlnLmNvZGVjLnJlZnJlc2hSYXRlLGJpdHJhdGU6MWUzKkEsY29udGVudFR5cGU6Qy52aWRlb0NvZGVjTWltZVR5cGUodGhpcy5jaG9zZW5WaWRlb0NvbmZpZy5jb2RlYyl9fSl9Y2FwYWJpbGl0aWVzQmFkKCl7cmV0dXJuIEIodGhpcyx2b2lkIDAsdm9pZCAwLChmdW5jdGlvbiooKXtpZighKFwiTWVkaWFTb3VyY2VcImluIHdpbmRvdykpcmV0dXJuITE7aWYoIShcIm1lZGlhQ2FwYWJpbGl0aWVzXCJpbiBuYXZpZ2F0b3IpKXJldHVybiExO2NvbnN0IEE9eWllbGQgdGhpcy5kZWNvZGluZ0luZm9BdEJpdHJhdGUodGhpcy5jdXJyZW50Qml0cmF0ZUticHMpLEk9eWllbGQgdGhpcy5kZWNvZGluZ0luZm9BdEJpdHJhdGUodGhpcy5iaXRyYXRlT25lU3RlcERvd25LYnBzKCkpO3JldHVybiBJLnNtb290aCYmIUEuc21vb3RofHxJLnBvd2VyRWZmaWNpZW50JiYhQS5wb3dlckVmZmljaWVudH0pKX1sYXRlRnJhbWVSYXRpb0JhZCgpe3JldHVybiB0aGlzLmxhdGVGcmFtZXNUaGlzQmVhdC90aGlzLmZyYW1lc1RoaXNCZWF0Pj10aGlzLnBhcmFtZXRlcnMuYmFkTGF0ZUZyYW1lUmF0aW99YmVhdElzQmFkKCl7cmV0dXJuIEIodGhpcyx2b2lkIDAsdm9pZCAwLChmdW5jdGlvbiooKXtyZXR1cm4gdGhpcy5iYWREZWNvZGVyUGVyZlRoaXNCZWF0fHx0aGlzLmJhZENwdVBlcmZUaGlzQmVhdHx8dGhpcy5sYXRlRnJhbWVSYXRpb0JhZCgpfHwoeWllbGQgdGhpcy5jYXBhYmlsaXRpZXNCYWQoKSl9KSl9YmFkQmVhdCgpe2lmKHRoaXMuY3VycmVudEJpdHJhdGVLYnBzPD10aGlzLmxvd2VzdFN1cHBvcnRlZEJpdHJhdGVLYnBzKCkpcmV0dXJuIHZvaWQgdGhpcy5kZWJ1ZyhgY3Jhc2hlZCBhdCAke3RoaXMuY3VycmVudEJpdHJhdGVLYnBzLnRvRml4ZWQoMCl9a2JwcywgaWdub3JpbmcgYmFkIGJlYXRgKTt0aGlzLmJhZEJlYXRDb3VudCsrLHRoaXMuZ29vZEJlYXRDb3VudD0wLHRoaXMuY3VycmVudEJpdHJhdGVLYnBzO2NvbnN0IEE9dGhpcy5wYXJhbWV0ZXJzLmJhZEJlYXRzO2lmKHRoaXMuZGVidWcoYGJhZCBiZWF0OiAke3RoaXMuYmFkQmVhdENvdW50fS8ke0F9YCksdGhpcy5iYWRCZWF0Q291bnQ+PXRoaXMucGFyYW1ldGVycy5iYWRCZWF0cyl7dGhpcy5nb29kQmVhdENvdW50PXRoaXMuYmFkQmVhdENvdW50PTA7Y29uc3QgQT10aGlzLmxhc3RBZGp1c3RtZW50PT09RS5VcDt0aGlzLnF1YWxpdHlEb3duKCksdGhpcy5kZWJ1ZyhcIndlbnQgZG93biBpbiBxdWFsaXR5XCIpLEEmJnRoaXMuY3VycmVudEJpdHJhdGVLYnBzPHRoaXMub3duTWF4aW11bUticHMmJih0aGlzLm93bk1heGltdW1LYnBzPXRoaXMuY3VycmVudEJpdHJhdGVLYnBzLHRoaXMuaW5mbyhgc2V0dGluZyBhIG5ldyBtYXhpbXVtIGF0ICR7dGhpcy5vd25NYXhpbXVtS2Jwcy50b0ZpeGVkKDApfWticHNgKSl9fWdvb2RCZWF0KCl7aWYodGhpcy5jdXJyZW50Qml0cmF0ZUticHM+PXRoaXMub3duTWF4aW11bUticHN8fHRoaXMuY3VycmVudEJpdHJhdGVLYnBzPj10aGlzLmhpZ2hlc3RTdXBwb3J0ZWRCaXRyYXRlS2JwcygpKXJldHVybiB0aGlzLmRlYnVnKGBtYXhlZCBhdCAke3RoaXMuY3VycmVudEJpdHJhdGVLYnBzLnRvRml4ZWQoMCl9a2JwcywgaWdub3JpbmcgZ29vZCBiZWF0YCksdm9pZCh0aGlzLmJhZEJlYXRDb3VudD0wKTt0aGlzLmdvb2RCZWF0Q291bnQrKyx0aGlzLmJhZEJlYXRDb3VudD0wLHRoaXMuY3VycmVudEJpdHJhdGVLYnBzO2NvbnN0IEE9dGhpcy5wYXJhbWV0ZXJzLmdvb2RCZWF0czt0aGlzLmRlYnVnKGBnb29kIGJlYXQ6ICR7dGhpcy5nb29kQmVhdENvdW50fS8ke0F9YCksdGhpcy5nb29kQmVhdENvdW50Pj1BJiYodGhpcy5nb29kQmVhdENvdW50PXRoaXMuYmFkQmVhdENvdW50PTAsdGhpcy5xdWFsaXR5VXAoKSx0aGlzLmRlYnVnKFwid2VudCB1cCBpbiBxdWFsaXR5XCIpKX1iaXRyYXRlT25lU3RlcFVwS2Jwcygpe3JldHVybiBNYXRoLm1pbih0aGlzLmhpZ2hlc3RTdXBwb3J0ZWRCaXRyYXRlS2JwcygpLHRoaXMuY3VycmVudEJpdHJhdGVLYnBzKnRoaXMucGFyYW1ldGVycy5xdWFsaXR5U3RlcEZhY3Rvcil9Yml0cmF0ZU9uZVN0ZXBEb3duS2Jwcygpe3JldHVybiBNYXRoLm1heCh0aGlzLmxvd2VzdFN1cHBvcnRlZEJpdHJhdGVLYnBzKCksdGhpcy5jdXJyZW50Qml0cmF0ZUticHMvdGhpcy5wYXJhbWV0ZXJzLnF1YWxpdHlTdGVwRmFjdG9yKX1xdWFsaXR5VXAoKXt0aGlzLmN1cnJlbnRCaXRyYXRlS2Jwcz10aGlzLmJpdHJhdGVPbmVTdGVwVXBLYnBzKCksdGhpcy5zdWdnZXN0Qml0cmF0ZUticHModGhpcy5jdXJyZW50Qml0cmF0ZUticHMpLHRoaXMubGFzdEFkanVzdG1lbnQ9RS5VcCx0aGlzLmhpc3RvcnkucHVzaCh7dGltZTpwZXJmb3JtYW5jZS5ub3coKSxiaXRyYXRlOnRoaXMuY3VycmVudEJpdHJhdGVLYnBzfSl9cXVhbGl0eURvd24oKXt0aGlzLmN1cnJlbnRCaXRyYXRlS2Jwcz10aGlzLmJpdHJhdGVPbmVTdGVwRG93bkticHMoKSx0aGlzLnN1Z2dlc3RCaXRyYXRlS2Jwcyh0aGlzLmN1cnJlbnRCaXRyYXRlS2JwcyksdGhpcy5sYXN0QWRqdXN0bWVudD1FLkRvd24sdGhpcy5oaXN0b3J5LnB1c2goe3RpbWU6cGVyZm9ybWFuY2Uubm93KCksYml0cmF0ZTp0aGlzLmN1cnJlbnRCaXRyYXRlS2Jwc30pLHRoaXMubG93ZXN0RGVsdGE9dm9pZCAwfWxvd2VzdFN1cHBvcnRlZEJpdHJhdGVLYnBzKCl7dmFyIEE7cmV0dXJuIE51bWJlcihudWxsIT09KEE9bmV3IFVSTFNlYXJjaFBhcmFtcyh3aW5kb3cubG9jYXRpb24uc2VhcmNoKS5nZXQoXCJsb3dlc3QtYml0cmF0ZVwiKSkmJnZvaWQgMCE9PUE/QTo1ZTMpfWhpZ2hlc3RTdXBwb3J0ZWRCaXRyYXRlS2Jwcygpe3ZhciBBO3JldHVybiBOdW1iZXIobnVsbCE9PShBPW5ldyBVUkxTZWFyY2hQYXJhbXMod2luZG93LmxvY2F0aW9uLnNlYXJjaCkuZ2V0KFwibWF4LWJpdHJhdGVcIikpJiZ2b2lkIDAhPT1BP0E6MWU0KX19fSwxNDU6ZnVuY3Rpb24oQSxJLGcpe1widXNlIHN0cmljdFwiO3ZhciBlLEI9dGhpcyYmdGhpcy5fX2F3YWl0ZXJ8fGZ1bmN0aW9uKEEsSSxnLGUpe3JldHVybiBuZXcoZ3x8KGc9UHJvbWlzZSkpKChmdW5jdGlvbihCLGkpe2Z1bmN0aW9uIFEoQSl7dHJ5e0MoZS5uZXh0KEEpKX1jYXRjaChBKXtpKEEpfX1mdW5jdGlvbiB0KEEpe3RyeXtDKGUudGhyb3coQSkpfWNhdGNoKEEpe2koQSl9fWZ1bmN0aW9uIEMoQSl7dmFyIEk7QS5kb25lP0IoQS52YWx1ZSk6KEk9QS52YWx1ZSxJIGluc3RhbmNlb2YgZz9JOm5ldyBnKChmdW5jdGlvbihBKXtBKEkpfSkpKS50aGVuKFEsdCl9QygoZT1lLmFwcGx5KEEsSXx8W10pKS5uZXh0KCkpfSkpfSxpPXRoaXMmJnRoaXMuX19jbGFzc1ByaXZhdGVGaWVsZFNldHx8ZnVuY3Rpb24oQSxJLGcpe2lmKCFJLmhhcyhBKSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiYXR0ZW1wdGVkIHRvIHNldCBwcml2YXRlIGZpZWxkIG9uIG5vbi1pbnN0YW5jZVwiKTtyZXR1cm4gSS5zZXQoQSxnKSxnfSxRPXRoaXMmJnRoaXMuX19jbGFzc1ByaXZhdGVGaWVsZEdldHx8ZnVuY3Rpb24oQSxJKXtpZighSS5oYXMoQSkpdGhyb3cgbmV3IFR5cGVFcnJvcihcImF0dGVtcHRlZCB0byBnZXQgcHJpdmF0ZSBmaWVsZCBvbiBub24taW5zdGFuY2VcIik7cmV0dXJuIEkuZ2V0KEEpfTtPYmplY3QuZGVmaW5lUHJvcGVydHkoSSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxJLlJUQ1RyYW5zcG9ydD12b2lkIDA7Y29uc3QgdD1nKDk5NCksQz1nKDkpLEU9Zyg0NjQpLG89Zyg5MDQpLGE9Zyg5ODcpLG49Zyg0MjApLHM9Zyg3ODMpLHI9e2ljZVNlcnZlcnM6W3t1cmxzOlwic3R1bjpzdHVuLnJhaW53YXkuY29tOjM0NzhcIn1dfTtjbGFzcyBkIGV4dGVuZHMgQy5SYWlud2F5VHJhbnNwb3J0e2NvbnN0cnVjdG9yKEEsSSxnLEIsUSxhKXtzdXBlcigpLHRoaXMub3duUGVlcklkPUEsdGhpcy50YXJnZXRQZWVySWQ9SSx0aGlzLnNlbmRMb2NhbE9mZmVyU2RwPWcsdGhpcy5zZW5kTG9jYWxBbnN3ZXJTZHA9Qix0aGlzLnNlbmRMb2NhbEljZUNhbmRpZGF0ZT1RLHRoaXMucmVwb3J0U3RhdGVDaGFuZ2U9YSxlLnNldCh0aGlzLEMuUmFpbndheVRyYW5zcG9ydFN0YXR1cy5EaXNjb25uZWN0ZWQpLHRoaXMucnRjQ29uZmlndXJhdGlvbj1yLHRoaXMuZGF0YUNoYW5uZWxzQ29uZmlnPXt9LHRoaXMuc3luY0tleT0wLHRoaXMub25SYWlud2F5TWVzc2FnZT0oKT0+e30sdGhpcy5vbkFwcGxpY2F0aW9uTWVzc2FnZT0oKT0+e30sdGhpcy5vbkNsb3NlPSgpPT57fSx0aGlzLmhhbmRsZVBlZXJJbmZvPUE9Pnt2YXIgSSxnLGU7aWYoQS50eXBlPT09by5QZWVySW5mb3JtYXRpb25UeXBlLkFuc3dlcilFLlJhaW53YXlMb2dnaW5nLmRlYnVnKFwiR290IEFuc3dlciBpbiBDUklEIFwiK0EuaWQrXCJcXG5cIitBLmRhdGEpLG51bGw9PT0oST10aGlzLnBlZXJDb25uZWN0aW9uKXx8dm9pZCAwPT09SXx8SS5zZXRSZW1vdGVEZXNjcmlwdGlvbih7dHlwZTpcImFuc3dlclwiLHNkcDpBLmRhdGF9KTtlbHNlIGlmKEEudHlwZT09PW8uUGVlckluZm9ybWF0aW9uVHlwZS5PZmZlcilFLlJhaW53YXlMb2dnaW5nLmRlYnVnKFwiR290IE9mZmVyIGluIENSSUQgXCIrQS5pZCtcIlxcblwiK0EuZGF0YSksbnVsbD09PShnPXRoaXMucGVlckNvbm5lY3Rpb24pfHx2b2lkIDA9PT1nfHxnLnNldFJlbW90ZURlc2NyaXB0aW9uKHt0eXBlOlwib2ZmZXJcIixzZHA6QS5kYXRhfSksdGhpcy5zZW5kQW5zd2VyKCk7ZWxzZXtpZihBLnR5cGUhPT1vLlBlZXJJbmZvcm1hdGlvblR5cGUuQ2FuZGlkYXRlKXtjb25zdCBJPW8uUGVlckluZm9ybWF0aW9uVHlwZVtBLnR5cGVdO3Rocm93IG5ldyB0LlJhaW53YXlFcnJvcihgdW5leHBlY3RlZCBQZWVySW5mb3JtYXRpb25UeXBlICR7SX0gaW4gaGFuZGxlUGVlckluZm9gKX1FLlJhaW53YXlMb2dnaW5nLmRlYnVnKFwiR290IENhbmRpZGF0ZSBpbiBDUklEIFwiK0EuaWQrXCJcXG5cIitBLmRhdGEpLG51bGw9PT0oZT10aGlzLnBlZXJDb25uZWN0aW9uKXx8dm9pZCAwPT09ZXx8ZS5hZGRJY2VDYW5kaWRhdGUobmV3IFJUQ0ljZUNhbmRpZGF0ZSh7Y2FuZGlkYXRlOkEuZGF0YSxzZHBNaWQ6XCJcIixzZHBNTGluZUluZGV4OjB9KSl9fSx0aGlzLmhhbmRsZUxvY2FsSWNlQ2FuZGlkYXRlPUE9PntBLmNhbmRpZGF0ZSYmXCIxXCI9PT1BLmNhbmRpZGF0ZS5jYW5kaWRhdGUuc3BsaXQoXCIgXCIpWzFdJiZ0aGlzLnNlbmRMb2NhbEljZUNhbmRpZGF0ZShBLmNhbmRpZGF0ZSl9LHRoaXMuaGFuZGxlSWNlQ29ubmVjdGlvblN0YXRlQ2hhbmdlPSgpPT57aWYoIXRoaXMucGVlckNvbm5lY3Rpb24pcmV0dXJuO2NvbnN0IEE9dGhpcy5wZWVyQ29ubmVjdGlvbi5pY2VDb25uZWN0aW9uU3RhdGU7RS5SYWlud2F5TG9nZ2luZy5pbmZvcm1hdGlvbihgSUNFIGNvbm5lY3Rpb24gc3RhdGUgY2hhbmdlZCB0byAke0F9YCl9LHRoaXMuaGFuZGxlQ29ubmVjdGlvblN0YXRlQ2hhbmdlPSgpPT57dmFyIEE7aWYoIXRoaXMucGVlckNvbm5lY3Rpb24pcmV0dXJuO2NvbnN0IEk9dGhpcy5wZWVyQ29ubmVjdGlvbi5jb25uZWN0aW9uU3RhdGU7RS5SYWlud2F5TG9nZ2luZy5pbmZvcm1hdGlvbihgQ29ubmVjdGlvbiBzdGF0ZSBjaGFuZ2VkIHRvICR7SX1gKSxcImNsb3NlZFwiPT09SXx8XCJmYWlsZWRcIj09PUk/KHRoaXMucmVwb3J0U3RhdGVDaGFuZ2Uocy5SYWlud2F5UGVlclN0YXRlLkZhaWxlZCksbnVsbD09PShBPXRoaXMub3BlblJlamVjdCl8fHZvaWQgMD09PUF8fEEuY2FsbCh0aGlzKSx0aGlzLm9uQ2xvc2UoKSxpKHRoaXMsZSxDLlJhaW53YXlUcmFuc3BvcnRTdGF0dXMuRGlzY29ubmVjdGVkKSx0aGlzLmRpc3Bvc2UoKSk6XCJkaXNjb25uZWN0ZWRcIj09PUk/dGhpcy5yZXBvcnRTdGF0ZUNoYW5nZShzLlJhaW53YXlQZWVyU3RhdGUuRGlzY29ubmVjdGVkKTpcImNvbm5lY3RpbmdcIj09PUk/dGhpcy5yZXBvcnRTdGF0ZUNoYW5nZShzLlJhaW53YXlQZWVyU3RhdGUuQ29ubmVjdGluZyk6XCJjb25uZWN0ZWRcIj09PUk/dGhpcy5yZXBvcnRTdGF0ZUNoYW5nZShzLlJhaW53YXlQZWVyU3RhdGUuQ29ubmVjdGVkKTpcIm5ld1wiPT09SSYmdGhpcy5yZXBvcnRTdGF0ZUNoYW5nZShzLlJhaW53YXlQZWVyU3RhdGUuTmV3KX0sdGhpcy5oYW5kbGVEYXRhQ2hhbm5lbE1lc3NhZ2U9QT0+e2NvbnN0IEk9QS50YXJnZXQubGFiZWw7dGhpcy5oYW5kbGVMYWJlbEFuZERhdGEoSSxuZXcgVWludDhBcnJheShBLmRhdGEpKX0sdGhpcy5oYW5kbGVEYXRhQ2hhbm5lbENsb3NlPUE9Pntjb25zdCBJPUEudGFyZ2V0LmxhYmVsO0UuUmFpbndheUxvZ2dpbmcud2FybmluZyhcIlJUQyBjaGFubmVsIGNsb3NlZDogXCIrSSl9LHRoaXMuaGFuZGxlRGF0YUNoYW5uZWxFcnJvcj1BPT57Y29uc3QgST1BLnRhcmdldC5sYWJlbDtFLlJhaW53YXlMb2dnaW5nLndhcm5pbmcoXCJSVEMgY2hhbm5lbCBlcnJvcmVkOiBcIitJKX0sdGhpcy5jaHVua2VkTWVzc2FnZXM9bmV3IE1hcCx0aGlzLmhpZ2hlc3RDaHVua0dyb3VwPTA7Y29uc3Qgbj17cHJvdG9jb2w6XCJzY3RwXCIsbmVnb3RpYXRlZDohMX0sZD17b3JkZXJlZDohMSxtYXhSZXRyYW5zbWl0czowfTt0aGlzLmRhdGFDaGFubmVsc0NvbmZpZz17UldfTG9naWM6T2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHtpZDowfSxuKSx7b3JkZXJlZDohMH0pLFJXX1ZpZGVvOk9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7aWQ6MX0sbiksZCksUldfQXVkaW86T2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHtpZDoyfSxuKSxkKSxSV19JbnB1dDpPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe2lkOjN9LG4pLGQpfX1jcmVhdGVEYXRhQ2hhbm5lbChBLEkpe3ZhciBnLGU7Y29uc3QgQj17cHJvdG9jb2w6XCJzY3RwXCIsbmVnb3RpYXRlZDohMX0saT1udWxsPT09KGc9dGhpcy5wZWVyQ29ubmVjdGlvbil8fHZvaWQgMD09PWc/dm9pZCAwOmcuY3JlYXRlRGF0YUNoYW5uZWwoQSxJPT09bi5SYWlud2F5Q2hhbm5lbE1vZGUuUmVsaWFibGU/T2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LEIpLHtvcmRlcmVkOiEwfSk6T2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LEIpLHtvcmRlcmVkOiExLG1heFJldHJhbnNtaXRzOjB9KSk7cmV0dXJuIGkmJihpLmFkZEV2ZW50TGlzdGVuZXIoXCJjbG9zZVwiLHRoaXMuaGFuZGxlRGF0YUNoYW5uZWxDbG9zZSksaS5hZGRFdmVudExpc3RlbmVyKFwiZXJyb3JcIix0aGlzLmhhbmRsZURhdGFDaGFubmVsRXJyb3IpLGkuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIix0aGlzLmhhbmRsZURhdGFDaGFubmVsTWVzc2FnZSksbnVsbCE9PShlPXRoaXMuZGF0YUNoYW5uZWxzKSYmdm9pZCAwIT09ZXx8KHRoaXMuZGF0YUNoYW5uZWxzPXt9KSx0aGlzLmRhdGFDaGFubmVsc1tBXT1pKSxpfXNlbmRNZXNzYWdlKEEsSSl7dmFyIGc7aWYoIUEpdGhyb3cgbmV3IHQuUmFpbndheUVycm9yKFwic2VuZE1lc3NhZ2U6IG5vIGxhYmVsXCIpO2lmKCF0aGlzLmRhdGFDaGFubmVscyl0aHJvdyBuZXcgdC5SYWlud2F5RXJyb3IoXCJzZW5kTWVzc2FnZTogZGF0YUNoYW5uZWxzIG5vdCBpbml0aWFsaXplZFwiKTtjb25zdCBlPW51bGw9PT0oZz10aGlzLmRhdGFDaGFubmVscyl8fHZvaWQgMD09PWc/dm9pZCAwOmdbQV07aWYoIWUpdGhyb3cgbmV3IHQuUmFpbndheUVycm9yKGBzZW5kTWVzc2FnZTogY2hhbm5lbCBcIiR7QX1cIiBkb2VzIG5vdCBleGlzdGApO2lmKFwib3BlblwiIT09ZS5yZWFkeVN0YXRlKXRocm93IG5ldyB0LlJhaW53YXlFcnJvcihgc2VuZE1lc3NhZ2U6IGNoYW5uZWwgXCIke0F9XCIgaXMgbm90IG9wZW5gKTtlLnNlbmQoSSl9Z2V0IHN0YXR1cygpe3JldHVybiBRKHRoaXMsZSl9Z2V0IG1heE1lc3NhZ2VTaXplKCl7dmFyIEEsSSxnO3JldHVybiBudWxsIT09KGc9bnVsbD09PShJPW51bGw9PT0oQT10aGlzLnBlZXJDb25uZWN0aW9uKXx8dm9pZCAwPT09QT92b2lkIDA6QS5zY3RwKXx8dm9pZCAwPT09ST92b2lkIDA6SS5tYXhNZXNzYWdlU2l6ZSkmJnZvaWQgMCE9PWc/ZzoyNjIxNDR9Z2V0U3RhdHMoKXtyZXR1cm4gQih0aGlzLHZvaWQgMCx2b2lkIDAsKGZ1bmN0aW9uKigpe2lmKCF0aGlzLnBlZXJDb25uZWN0aW9uKXRocm93IG5ldyB0LlJhaW53YXlFcnJvcihcImdldFN0YXRzKCkgYnV0IG5vIHBlZXJDb25uZWN0aW9uXCIpO2NvbnN0IEE9eWllbGQgdGhpcy5wZWVyQ29ubmVjdGlvbi5nZXRTdGF0cyh2b2lkIDApLEk9e2NoYW5uZWxzOnt9LHJhdzpBfTtyZXR1cm4gQS5mb3JFYWNoKChBPT57XCJkYXRhLWNoYW5uZWxcIj09PUEudHlwZSYmKEkuY2hhbm5lbHNbQS5sYWJlbF09QSl9KSksSX0pKX1jaGVja0hlYWRlcihBKXtpZigyMDM2NDMwNjc0IT09QS5tYWdpY051bWJlcil0aHJvdyBuZXcgdC5SYWlud2F5RXJyb3IoXCJJbnZhbGlkIG1hZ2ljTnVtYmVyIGluIGNoZWNrSGVhZGVyLlwiKTtpZihBLnRhcmdldFBlZXJJZCE9PXRoaXMub3duUGVlcklkKXRocm93IG5ldyB0LlJhaW53YXlFcnJvcihcIkludmFsaWQgZGVzdGluYXRpb24gaG9zdCBuYW1lIChub3Qgb3VycykgaW4gY2hlY2tIZWFkZXIuXCIpfWhhbmRsZUxhYmVsQW5kRGF0YShBLEkpe2lmKFwiUldfTG9naWNcIj09PUEpe2NvbnN0IEE9by5Mb2dpY0RhdGFncmFtLmRlY29kZShJKTt0aGlzLmNoZWNrSGVhZGVyKEEuaGVhZGVyKSx0aGlzLm9uUmFpbndheU1lc3NhZ2Uoe2tpbmQ6XCJMb2dpY1wiLGJvZHk6QS5ib2R5fSl9ZWxzZSBpZihcIlJXX0lucHV0XCI9PT1BKXtjb25zdCBBPW8uSW5wdXREYXRhZ3JhbS5kZWNvZGUoSSk7dGhpcy5jaGVja0hlYWRlcihBLmhlYWRlciksdGhpcy5vblJhaW53YXlNZXNzYWdlKHtraW5kOlwiSW5wdXRcIixib2R5OkEuYm9keX0pfWVsc2UgaWYoXCJSV19BdWRpb1wiPT09QXx8XCJSV19WaWRlb1wiPT1BKXtjb25zdCBnPW8uTWVkaWFEYXRhZ3JhbS5kZWNvZGUoSSk7dGhpcy5jaGVja0hlYWRlcihnLmhlYWRlciksZy5ib2R5LmRpc2NyaW1pbmF0b3I9PT1vLk1lZGlhQ2h1bmsuZGlzY3JpbWluYXRvcj90aGlzLmhhbmRsZUNodW5rKEEsZy5ib2R5LnZhbHVlLmNodW5rKTp0aGlzLm9uUmFpbndheU1lc3NhZ2Uoe2tpbmQ6XCJNZWRpYVwiLGJvZHk6Zy5ib2R5fSl9ZWxzZSBpZigvXlJXXy8udGVzdChBKSlFLlJhaW53YXlMb2dnaW5nLndhcm5pbmcoYFVua25vd24gUmFpbndheS1yZXNlcnZlZCBSVEMgbGFiZWw/ICR7QX1gKTtlbHNle2NvbnN0IGc9by5BcmJpdHJhcnlEYXRhZ3JhbS5kZWNvZGUoSSk7dGhpcy5jaGVja0hlYWRlcihnLmhlYWRlciksdGhpcy5oYW5kbGVDaHVuayhBLGcuYm9keSl9fWdldERhdGFncmFtSGVhZGVyKEEpe3JldHVybnttYWdpY051bWJlcjoyMDM2NDMwNjc0LHN5bmNLZXk6QT8rK3RoaXMuc3luY0tleTowLHNvdXJjZVBlZXJJZDp0aGlzLm93blBlZXJJZCx0YXJnZXRQZWVySWQ6dGhpcy50YXJnZXRQZWVySWR9fXNlbmRBcmJpdHJhcnlEYXRhZ3JhbShBLEkpe2EuZWFjaENodW5rKEksKEk9Pnt0aGlzLnNlbmRNZXNzYWdlKEEsby5BcmJpdHJhcnlEYXRhZ3JhbS5lbmNvZGUoe2hlYWRlcjp0aGlzLmdldERhdGFncmFtSGVhZGVyKCEwKSxib2R5Okl9KSl9KSl9c2VuZExvZ2ljRGF0YWdyYW0oQSl7dGhpcy5zZW5kTWVzc2FnZShcIlJXX0xvZ2ljXCIsby5Mb2dpY0RhdGFncmFtLmVuY29kZSh7aGVhZGVyOnRoaXMuZ2V0RGF0YWdyYW1IZWFkZXIoITApLGJvZHk6QX0pKX1zZW5kSW5wdXREYXRhZ3JhbShBKXt0aGlzLnNlbmRNZXNzYWdlKFwiUldfSW5wdXRcIixvLklucHV0RGF0YWdyYW0uZW5jb2RlKHtoZWFkZXI6dGhpcy5nZXREYXRhZ3JhbUhlYWRlcighMSksYm9keTpBfSkpfW9wZW4oQSl7cmV0dXJuIEIodGhpcyx2b2lkIDAsdm9pZCAwLChmdW5jdGlvbiooKXt5aWVsZCBuZXcgUHJvbWlzZSgoKEksZyk9PkIodGhpcyx2b2lkIDAsdm9pZCAwLChmdW5jdGlvbiooKXt2YXIgQjt0aGlzLm9wZW5SZXNvbHZlPUksdGhpcy5vcGVuUmVqZWN0PWcsaSh0aGlzLGUsQy5SYWlud2F5VHJhbnNwb3J0U3RhdHVzLkNvbm5lY3RpbmcpLHRoaXMucGVlckNvbm5lY3Rpb249bmV3IFJUQ1BlZXJDb25uZWN0aW9uKHRoaXMucnRjQ29uZmlndXJhdGlvbiksdGhpcy5wZWVyQ29ubmVjdGlvbi5hZGRFdmVudExpc3RlbmVyKFwiaWNlY29ubmVjdGlvbnN0YXRlY2hhbmdlXCIsdGhpcy5oYW5kbGVJY2VDb25uZWN0aW9uU3RhdGVDaGFuZ2UpLHRoaXMucGVlckNvbm5lY3Rpb24uYWRkRXZlbnRMaXN0ZW5lcihcImNvbm5lY3Rpb25zdGF0ZWNoYW5nZVwiLHRoaXMuaGFuZGxlQ29ubmVjdGlvblN0YXRlQ2hhbmdlKSx0aGlzLmhhbmRsZUNvbm5lY3Rpb25TdGF0ZUNoYW5nZSgpLG51bGwhPT0oQj10aGlzLmRhdGFDaGFubmVscykmJnZvaWQgMCE9PUJ8fCh0aGlzLmRhdGFDaGFubmVscz17fSk7Y29uc3QgUT1PYmplY3Qua2V5cyh0aGlzLmRhdGFDaGFubmVsc0NvbmZpZykubGVuZ3RoO2xldCB0PTA7Y29uc3QgRT0oQSxnKT0+e2NvbnN0IEI9KCk9Pnt2YXIgQTsrK3QsdD09PVEmJihudWxsPT09KEE9dGhpcy5wZWVyQ29ubmVjdGlvbil8fHZvaWQgMD09PUF8fEEucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImljZWNhbmRpZGF0ZVwiLHRoaXMuaGFuZGxlTG9jYWxJY2VDYW5kaWRhdGUpLGkodGhpcyxlLEMuUmFpbndheVRyYW5zcG9ydFN0YXR1cy5Db25uZWN0ZWQpLEkoKSksZy5yZW1vdmVFdmVudExpc3RlbmVyKFwib3BlblwiLEIpfTtnLmFkZEV2ZW50TGlzdGVuZXIoXCJvcGVuXCIsQiksZy5hZGRFdmVudExpc3RlbmVyKFwiY2xvc2VcIix0aGlzLmhhbmRsZURhdGFDaGFubmVsQ2xvc2UpLGcuYWRkRXZlbnRMaXN0ZW5lcihcImVycm9yXCIsdGhpcy5oYW5kbGVEYXRhQ2hhbm5lbEVycm9yKSxnLmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsdGhpcy5oYW5kbGVEYXRhQ2hhbm5lbE1lc3NhZ2UpfTtpZihcIm9mZmVyXCI9PT1BKWZvcihjb25zdFtBLEldb2YgT2JqZWN0LmVudHJpZXModGhpcy5kYXRhQ2hhbm5lbHNDb25maWcpKXtjb25zdCBnPXRoaXMucGVlckNvbm5lY3Rpb24uY3JlYXRlRGF0YUNoYW5uZWwoQSxJKTt0aGlzLmRhdGFDaGFubmVsc1tBXT1nLGcuYmluYXJ5VHlwZT1cImFycmF5YnVmZmVyXCIsRSgwLGcpfWVsc2UgdGhpcy5wZWVyQ29ubmVjdGlvbi5hZGRFdmVudExpc3RlbmVyKFwiZGF0YWNoYW5uZWxcIiwoQT0+e3ZhciBJO2NvbnN0IGc9QS5jaGFubmVsLmxhYmVsO251bGwhPT0oST10aGlzLmRhdGFDaGFubmVscykmJnZvaWQgMCE9PUl8fCh0aGlzLmRhdGFDaGFubmVscz17fSksdGhpcy5kYXRhQ2hhbm5lbHNbZ109QS5jaGFubmVsLEUoQS5jaGFubmVsLmxhYmVsLEEuY2hhbm5lbCl9KSk7dGhpcy5wZWVyQ29ubmVjdGlvbi5hZGRFdmVudExpc3RlbmVyKFwiaWNlY2FuZGlkYXRlXCIsdGhpcy5oYW5kbGVMb2NhbEljZUNhbmRpZGF0ZSksXCJvZmZlclwiPT09QSYmKHlpZWxkIHRoaXMuc2VuZE9mZmVyKCkpfSkpKSl9KSl9c2VuZE9mZmVyKCl7cmV0dXJuIEIodGhpcyx2b2lkIDAsdm9pZCAwLChmdW5jdGlvbiooKXtpZih2b2lkIDA9PT10aGlzLnBlZXJDb25uZWN0aW9uKXRocm93IG5ldyB0LlJhaW53YXlFcnJvcihcInNlbmRPZmZlcigpOiBubyBwZWVyIGNvbm5lY3Rpb25cIik7Y29uc3QgQT15aWVsZCB0aGlzLnBlZXJDb25uZWN0aW9uLmNyZWF0ZU9mZmVyKCk7aWYoeWllbGQgdGhpcy5wZWVyQ29ubmVjdGlvbi5zZXRMb2NhbERlc2NyaXB0aW9uKEEpLCFBLnNkcCl0aHJvdyBuZXcgdC5SYWlud2F5RXJyb3IoXCJDcmVhdGVkIG9mZmVyIGNvbnRhaW5lZCBubyBzZHA/XCIpO3RoaXMuc2VuZExvY2FsT2ZmZXJTZHAoQS5zZHApfSkpfXNlbmRBbnN3ZXIoKXtyZXR1cm4gQih0aGlzLHZvaWQgMCx2b2lkIDAsKGZ1bmN0aW9uKigpe2lmKHZvaWQgMD09PXRoaXMucGVlckNvbm5lY3Rpb24pdGhyb3cgbmV3IHQuUmFpbndheUVycm9yKFwic2VuZE9mZmVyKCk6IG5vIHBlZXIgY29ubmVjdGlvblwiKTtjb25zdCBBPXlpZWxkIHRoaXMucGVlckNvbm5lY3Rpb24uY3JlYXRlQW5zd2VyKCk7aWYoeWllbGQgdGhpcy5wZWVyQ29ubmVjdGlvbi5zZXRMb2NhbERlc2NyaXB0aW9uKEEpLCFBLnNkcCl0aHJvdyBuZXcgdC5SYWlud2F5RXJyb3IoXCJDcmVhdGVkIGFuc3dlciBjb250YWluZWQgbm8gc2RwP1wiKTt0aGlzLnNlbmRMb2NhbEFuc3dlclNkcChBLnNkcCl9KSl9Y2xvc2UoKXt2YXIgQTt0aGlzLnN0YXR1cyE9PUMuUmFpbndheVRyYW5zcG9ydFN0YXR1cy5EaXNjb25uZWN0ZWQmJihFLlJhaW53YXlMb2dnaW5nLmRlYnVnKFwicnRjLXRyYW5zcG9ydCBjbG9zZSgpLlwiKSxudWxsPT09KEE9dGhpcy5wZWVyQ29ubmVjdGlvbil8fHZvaWQgMD09PUF8fEEuY2xvc2UoKSx0aGlzLm9uQ2xvc2UoKSx0aGlzLmRpc3Bvc2UoKSl9ZGlzcG9zZSgpe3ZhciBBLEksZztpZihudWxsPT09KEE9dGhpcy5wZWVyQ29ubmVjdGlvbil8fHZvaWQgMD09PUF8fEEucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImljZWNvbm5lY3Rpb25zdGF0ZWNoYW5nZVwiLHRoaXMuaGFuZGxlSWNlQ29ubmVjdGlvblN0YXRlQ2hhbmdlKSxudWxsPT09KEk9dGhpcy5wZWVyQ29ubmVjdGlvbil8fHZvaWQgMD09PUl8fEkucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNvbm5lY3Rpb25zdGF0ZWNoYW5nZVwiLHRoaXMuaGFuZGxlQ29ubmVjdGlvblN0YXRlQ2hhbmdlKSxudWxsPT09KGc9dGhpcy5wZWVyQ29ubmVjdGlvbil8fHZvaWQgMD09PWd8fGcucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImljZWNhbmRpZGF0ZVwiLHRoaXMuaGFuZGxlTG9jYWxJY2VDYW5kaWRhdGUpLHRoaXMuZGF0YUNoYW5uZWxzKWZvcihjb25zdCBBIG9mIE9iamVjdC52YWx1ZXModGhpcy5kYXRhQ2hhbm5lbHMpKUEucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIix0aGlzLmhhbmRsZURhdGFDaGFubmVsTWVzc2FnZSk7dGhpcy5kYXRhQ2hhbm5lbHM9dm9pZCAwLHRoaXMucGVlckNvbm5lY3Rpb249dm9pZCAwLHRoaXMub3BlblJlc29sdmU9dm9pZCAwLHRoaXMub3BlblJlamVjdD12b2lkIDB9aGFuZGxlQ2h1bmsoQSxJKXtJLmdyb3VwSWQ8dGhpcy5oaWdoZXN0Q2h1bmtHcm91cCYmKHRoaXMuY2h1bmtlZE1lc3NhZ2VzPW5ldyBNYXAsdGhpcy5oaWdoZXN0Q2h1bmtHcm91cD0wKTtsZXQgZz10aGlzLmNodW5rZWRNZXNzYWdlcy5nZXQoSS5ncm91cElkKTtpZihnfHwoZz17cmVjZWl2ZWRDaHVua0NvdW50OjAsY2h1bmtzOltdfSx0aGlzLmNodW5rZWRNZXNzYWdlcy5zZXQoSS5ncm91cElkLGcpKSxnLmNodW5rc1tJLmluZGV4XT1JLmRhdGEsZy5yZWNlaXZlZENodW5rQ291bnQrKyxnLnJlY2VpdmVkQ2h1bmtDb3VudD09PUkuY2h1bmtzSW5Hcm91cCl7dGhpcy5oaWdoZXN0Q2h1bmtHcm91cD1JLmdyb3VwSWQsdGhpcy5jaHVua2VkTWVzc2FnZXMuZGVsZXRlKEkuZ3JvdXBJZCk7Y29uc3QgZT1hLnJlYXNzZW1ibGUoZyk7L15SV18oTG9naWN8SW5wdXR8QXVkaW98VmlkZW8pJC8udGVzdChBKT90aGlzLmhhbmRsZUxhYmVsQW5kRGF0YShBLGUpOnRoaXMub25BcHBsaWNhdGlvbk1lc3NhZ2UoQSxlKX19fUkuUlRDVHJhbnNwb3J0PWQsZT1uZXcgV2Vha01hcH0sOTooQSxJKT0+e1widXNlIHN0cmljdFwiO3ZhciBnO09iamVjdC5kZWZpbmVQcm9wZXJ0eShJLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLEkuUmFpbndheVRyYW5zcG9ydD1JLlJhaW53YXlUcmFuc3BvcnRTdGF0dXM9dm9pZCAwLChnPUkuUmFpbndheVRyYW5zcG9ydFN0YXR1c3x8KEkuUmFpbndheVRyYW5zcG9ydFN0YXR1cz17fSkpW2cuRGlzY29ubmVjdGVkPTBdPVwiRGlzY29ubmVjdGVkXCIsZ1tnLkNvbm5lY3Rpbmc9MV09XCJDb25uZWN0aW5nXCIsZ1tnLkNvbm5lY3RlZD0yXT1cIkNvbm5lY3RlZFwiLEkuUmFpbndheVRyYW5zcG9ydD1jbGFzc3t9fSw0MjA6ZnVuY3Rpb24oQSxJLGcpe1widXNlIHN0cmljdFwiO3ZhciBlLEIsaSxRLHQ9dGhpcyYmdGhpcy5fX2F3YWl0ZXJ8fGZ1bmN0aW9uKEEsSSxnLGUpe3JldHVybiBuZXcoZ3x8KGc9UHJvbWlzZSkpKChmdW5jdGlvbihCLGkpe2Z1bmN0aW9uIFEoQSl7dHJ5e0MoZS5uZXh0KEEpKX1jYXRjaChBKXtpKEEpfX1mdW5jdGlvbiB0KEEpe3RyeXtDKGUudGhyb3coQSkpfWNhdGNoKEEpe2koQSl9fWZ1bmN0aW9uIEMoQSl7dmFyIEk7QS5kb25lP0IoQS52YWx1ZSk6KEk9QS52YWx1ZSxJIGluc3RhbmNlb2YgZz9JOm5ldyBnKChmdW5jdGlvbihBKXtBKEkpfSkpKS50aGVuKFEsdCl9QygoZT1lLmFwcGx5KEEsSXx8W10pKS5uZXh0KCkpfSkpfSxDPXRoaXMmJnRoaXMuX19jbGFzc1ByaXZhdGVGaWVsZFNldHx8ZnVuY3Rpb24oQSxJLGcpe2lmKCFJLmhhcyhBKSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiYXR0ZW1wdGVkIHRvIHNldCBwcml2YXRlIGZpZWxkIG9uIG5vbi1pbnN0YW5jZVwiKTtyZXR1cm4gSS5zZXQoQSxnKSxnfSxFPXRoaXMmJnRoaXMuX19jbGFzc1ByaXZhdGVGaWVsZEdldHx8ZnVuY3Rpb24oQSxJKXtpZighSS5oYXMoQSkpdGhyb3cgbmV3IFR5cGVFcnJvcihcImF0dGVtcHRlZCB0byBnZXQgcHJpdmF0ZSBmaWVsZCBvbiBub24taW5zdGFuY2VcIik7cmV0dXJuIEkuZ2V0KEEpfTtPYmplY3QuZGVmaW5lUHJvcGVydHkoSSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxJLlJhaW53YXlQZWVyPUkuUmFpbndheUNoYW5uZWxNb2RlPUkuUGVlclN0YXRlPXZvaWQgMDtjb25zdCBvPWcoOTA0KSxhPWcoODI0KSxuPWcoNDY0KSxzPWcoNTE0KSxyPWcoODc2KSxkPWcoOTk0KTt2YXIgaCxjOyFmdW5jdGlvbihBKXtBW0EuRXhjaGFuZ2luZ0luZm89MF09XCJFeGNoYW5naW5nSW5mb1wiLEFbQS5SZWFkeT0xXT1cIlJlYWR5XCIsQVtBLkRpc2Nvbm5lY3RlZD0yXT1cIkRpc2Nvbm5lY3RlZFwifShoPUkuUGVlclN0YXRlfHwoSS5QZWVyU3RhdGU9e30pKSwoYz1JLlJhaW53YXlDaGFubmVsTW9kZXx8KEkuUmFpbndheUNoYW5uZWxNb2RlPXt9KSlbYy5VbnJlbGlhYmxlPTBdPVwiVW5yZWxpYWJsZVwiLGNbYy5SZWxpYWJsZT0xXT1cIlJlbGlhYmxlXCIsSS5SYWlud2F5UGVlcj1jbGFzc3tjb25zdHJ1Y3RvcihBLEksZyx0LEUsbyxhKXt0aGlzLnRyYW5zcG9ydD1nLHRoaXMub3V0ZXJPbkNsb3NlPXQsdGhpcy5vbkVycm9yPUUsdGhpcy5vblN0cmVhbUFubm91bmNlbWVudD1vLHRoaXMub25TdHJlYW1TdG9wPWEsZS5zZXQodGhpcyxoLkV4Y2hhbmdpbmdJbmZvKSxCLnNldCh0aGlzLG5ldyBNYXApLGkuc2V0KHRoaXMsdm9pZCAwKSxRLnNldCh0aGlzLHZvaWQgMCksdGhpcy5sYXN0VGltZXN0YW1wPXZvaWQgMCxDKHRoaXMsaSxBKSxDKHRoaXMsUSxJKSxnLm9uUmFpbndheU1lc3NhZ2U9dGhpcy5vbk1lc3NhZ2UuYmluZCh0aGlzKSxnLm9uQ2xvc2U9dGhpcy5vbkNsb3NlLmJpbmQodGhpcyksdGhpcy5yZWFkeVRvU3RyZWFtPW5ldyBQcm9taXNlKCgoQSxJKT0+e3RoaXMucmVzb2x2ZVJlYWR5VG9TdHJlYW09QX0pKX1nZXQgc3RhdGUoKXtyZXR1cm4gRSh0aGlzLGUpfWdldCBzdHJlYW0oKXtjb25zdCBBPVsuLi5FKHRoaXMsQikuZW50cmllcygpXTtpZigwIT09QS5sZW5ndGgpcmV0dXJuIEEuc29ydCgoKEEsSSk9PkFbMF0tSVswXSkpLEFbMF1bMV19Z2V0IHN0cmVhbXMoKXtyZXR1cm4gRSh0aGlzLEIpfWdldCBwZWVySWQoKXtyZXR1cm4gRSh0aGlzLGkpfWdldCBleHRlcm5hbElkKCl7cmV0dXJuIEUodGhpcyxRKX1vbkNsb3NlKCl7Qyh0aGlzLGUsaC5EaXNjb25uZWN0ZWQpLHRoaXMub3V0ZXJPbkNsb3NlKCl9c2VuZERldmljZUluZm9BbmRFeGNoYW5nZUNvZGVjcygpe2lmKEUodGhpcyxlKT09PWguRGlzY29ubmVjdGVkKXRocm93IG5ldyBkLlJhaW53YXlFcnJvcihcIkNvdWxkbid0IHNlbmQgZGV2aWNlIGluZm8gYW5kIGV4Y2hhbmdlIGNvZGVjczogcGVlciBpcyBkaXNjb25uZWN0ZWRcIik7dGhpcy5zZW5kRGV2aWNlSW5mbygpLHRoaXMuZXhjaGFuZ2VDb2RlY3MoKS50aGVuKChBPT57dmFyIEksZzswPT09QS5sZW5ndGg/bnVsbD09PShJPXRoaXMucmVzb2x2ZVJlYWR5VG9TdHJlYW0pfHx2b2lkIDA9PT1JfHxJLmNhbGwodGhpcywhMSk6KHRoaXMudHJhbnNwb3J0LnNlbmRMb2dpY0RhdGFncmFtKHtkaXNjcmltaW5hdG9yOm8uQ2xpZW50Q2FwYWJpbGl0aWVzLmRpc2NyaW1pbmF0b3IsdmFsdWU6cy5tYWtlQ2xpZW50Q2FwYWJpbGl0aWVzKEEpfSksbnVsbD09PShnPXRoaXMucmVzb2x2ZVJlYWR5VG9TdHJlYW0pfHx2b2lkIDA9PT1nfHxnLmNhbGwodGhpcywhMCkpLEModGhpcyxlLGguUmVhZHkpfSkpfW9uTWVzc2FnZShBKXtcIkxvZ2ljXCI9PT1BLmtpbmQ/dGhpcy5oYW5kbGVMb2dpY01lc3NhZ2UoQS5ib2R5KTpcIklucHV0XCI9PT1BLmtpbmQ/dGhpcy5oYW5kbGVJbnB1dE1lc3NhZ2UoQS5ib2R5KTpcIk1lZGlhXCI9PT1BLmtpbmQmJnRoaXMuaGFuZGxlTWVkaWFNZXNzYWdlKEEuYm9keSl9c2VuZERldmljZUluZm8oKXtpZihFKHRoaXMsZSk9PT1oLkRpc2Nvbm5lY3RlZCl0aHJvdyBuZXcgZC5SYWlud2F5RXJyb3IoXCJDb3VsZG4ndCBzZW5kIGRldmljZSBpbmZvOiBwZWVyIGlzIGRpc2Nvbm5lY3RlZFwiKTt0aGlzLnRyYW5zcG9ydC5zZW5kTG9naWNEYXRhZ3JhbSh7ZGlzY3JpbWluYXRvcjpvLkRldmljZUluZm8uZGlzY3JpbWluYXRvcix2YWx1ZTp7aXNXZWI6ITAsZm9ybUZhY3RvcjpvLkZvcm1GYWN0b3IuQ29tcHV0ZXIsZGV2aWNlTmFtZTpcImRldmljZU5hbWVcIixkZXZpY2VJZDpcImRldmljZUlkXCIsZGV2aWNlTW9kZWw6XCJcIixkZXZpY2VPczpvLk9wZXJhdGluZ1N5c3RlbS5PdGhlcixkZXZpY2VPc1ZlcnNpb246XCJcIix1c2VyQWdlbnQ6bmF2aWdhdG9yLnVzZXJBZ2VudH19KX1zZW5kKEEsSSl7aWYoRSh0aGlzLGUpPT09aC5EaXNjb25uZWN0ZWQpdGhyb3cgbmV3IGQuUmFpbndheUVycm9yKFwiQ291bGRuJ3Qgc2VuZCBtZXNzYWdlOiBwZWVyIGlzIGRpc2Nvbm5lY3RlZFwiKTt0aGlzLnRyYW5zcG9ydC5zZW5kQXJiaXRyYXJ5RGF0YWdyYW0oQSxJKX1kaXNjb25uZWN0KCl7Zm9yKGNvbnN0IEEgb2YgRSh0aGlzLEIpLnZhbHVlcygpKUEubGVhdmUoKTtFKHRoaXMsQikuY2xlYXIoKSx0aGlzLnRyYW5zcG9ydC5jbG9zZSgpfXJlcXVlc3RTdHJlYW0oQSl7cmV0dXJuIHQodGhpcyx2b2lkIDAsdm9pZCAwLChmdW5jdGlvbiooKXtpZihFKHRoaXMsZSk9PT1oLkRpc2Nvbm5lY3RlZCl0aHJvdyBuZXcgZC5SYWlud2F5RXJyb3IoXCJDb3VsZG4ndCByZXF1ZXN0IHN0cmVhbTogcGVlciBpcyBkaXNjb25uZWN0ZWRcIik7cmV0dXJuIHlpZWxkIHRoaXMucmVhZHlUb1N0cmVhbSx0aGlzLnRyYW5zcG9ydC5zZW5kTG9naWNEYXRhZ3JhbSh7ZGlzY3JpbWluYXRvcjpvLlN0cmVhbVJlcXVlc3QuZGlzY3JpbWluYXRvcix2YWx1ZTp7aW5wdXRMZXZlbDpBfX0pLG5ldyBQcm9taXNlKCgoQSxJKT0+e3RoaXMucmVzb2x2ZVN0cmVhbT1BLHRoaXMucmVqZWN0U3RyZWFtPUl9KSl9KSl9aGFuZGxlTG9naWNNZXNzYWdlKEEpe3ZhciBJO3JldHVybiB0KHRoaXMsdm9pZCAwLHZvaWQgMCwoZnVuY3Rpb24qKCl7aWYoQS5kaXNjcmltaW5hdG9yPT09by5EZXZpY2VJbmZvLmRpc2NyaW1pbmF0b3Ipbi5SYWlud2F5TG9nZ2luZy5kZWJ1ZyhcIkdvdCByZW1vdGUgRGV2aWNlSW5mbzpcXG5cIitKU09OLnN0cmluZ2lmeShBLnZhbHVlKSk7ZWxzZSBpZihBLmRpc2NyaW1pbmF0b3I9PT1vLkNvZGVjUGFja1JlcXVlc3QuZGlzY3JpbWluYXRvcil0aGlzLnRyYW5zcG9ydC5zZW5kTG9naWNEYXRhZ3JhbSh7ZGlzY3JpbWluYXRvcjpvLkNvZGVjUGFja1Jlc3BvbnNlLmRpc2NyaW1pbmF0b3IsdmFsdWU6e3ZpZGVvQ29kZWNzOltdfX0pO2Vsc2UgaWYoQS5kaXNjcmltaW5hdG9yPT09by5Db2RlY1BhY2tSZXNwb25zZS5kaXNjcmltaW5hdG9yKW51bGw9PT0oST10aGlzLmNvZGVjc1Jlc29sdmUpfHx2b2lkIDA9PT1JfHxJLmNhbGwodGhpcyxBLnZhbHVlLnZpZGVvQ29kZWNzKTtlbHNlIGlmKEEuZGlzY3JpbWluYXRvcj09PW8uQ2xpZW50Q2FwYWJpbGl0aWVzLmRpc2NyaW1pbmF0b3Ipbi5SYWlud2F5TG9nZ2luZy5kZWJ1ZyhcIkdvdCByZW1vdGUgQ2xpZW50Q2FwYWJpbGl0aWVzOlxcblwiK0pTT04uc3RyaW5naWZ5KEEudmFsdWUpKTtlbHNlIGlmKEEuZGlzY3JpbWluYXRvcj09PW8uU3RyZWFtUmVxdWVzdC5kaXNjcmltaW5hdG9yKW4uUmFpbndheUxvZ2dpbmcud2FybmluZyhcIkdvdCByZW1vdGUgU3RyZWFtUmVxdWVzdD9cXG5cIitKU09OLnN0cmluZ2lmeShBLnZhbHVlKSk7ZWxzZSBpZihBLmRpc2NyaW1pbmF0b3I9PT1vLlN0cmVhbVN0YXJ0aW5nLmRpc2NyaW1pbmF0b3IpaWYodm9pZCAwPT09dGhpcy5yZXNvbHZlU3RyZWFtKXRoaXMub25TdHJlYW1Bbm5vdW5jZW1lbnQoe2luZm86QS52YWx1ZSxqb2luOigpPT50KHRoaXMsdm9pZCAwLHZvaWQgMCwoZnVuY3Rpb24qKCl7Y29uc3QgST15aWVsZCB0aGlzLmNyZWF0ZVN0cmVhbShBLnZhbHVlKTtyZXR1cm4gRSh0aGlzLEIpLnNldChJLnN0cmVhbUlkLEkpLHRoaXMudHJhbnNwb3J0LnNlbmRMb2dpY0RhdGFncmFtKHtkaXNjcmltaW5hdG9yOm8uSm9pblN0cmVhbS5kaXNjcmltaW5hdG9yLHZhbHVlOntzdHJlYW1JZDpBLnZhbHVlLnN0cmVhbUlkfX0pLEl9KSl9KTtlbHNle2NvbnN0IEk9eWllbGQgdGhpcy5jcmVhdGVTdHJlYW0oQS52YWx1ZSk7RSh0aGlzLEIpLnNldChJLnN0cmVhbUlkLEkpLHRoaXMudHJhbnNwb3J0LnNlbmRMb2dpY0RhdGFncmFtKHtkaXNjcmltaW5hdG9yOm8uSm9pblN0cmVhbS5kaXNjcmltaW5hdG9yLHZhbHVlOntzdHJlYW1JZDpBLnZhbHVlLnN0cmVhbUlkfX0pLHRoaXMucmVzb2x2ZVN0cmVhbShJKSx0aGlzLnJlc29sdmVTdHJlYW09dm9pZCAwLHRoaXMucmVqZWN0U3RyZWFtPXZvaWQgMH1lbHNlIEEuZGlzY3JpbWluYXRvcj09PW8uUmVqZWN0U3RyZWFtUmVxdWVzdC5kaXNjcmltaW5hdG9yP3ZvaWQgMCE9PXRoaXMucmVqZWN0U3RyZWFtPyh0aGlzLnJlamVjdFN0cmVhbShBLnZhbHVlLnJlYXNvbiksdGhpcy5yZXNvbHZlU3RyZWFtPXZvaWQgMCx0aGlzLnJlamVjdFN0cmVhbT12b2lkIDApOm4uUmFpbndheUxvZ2dpbmcud2FybmluZyhcIkdvdCBSZWplY3RTdHJlYW1SZXF1ZXN0LCBidXQgZGlkbid0IGFzayBmb3IgYSBzdHJlYW0uXCIpOkEuZGlzY3JpbWluYXRvcj09PW8uTGVhdmVTdHJlYW0uZGlzY3JpbWluYXRvcj9uLlJhaW53YXlMb2dnaW5nLndhcm5pbmcoXCJHb3QgcmVtb3RlIExlYXZlU3RyZWFtP1xcblwiK0pTT04uc3RyaW5naWZ5KEEudmFsdWUpKTpBLmRpc2NyaW1pbmF0b3I9PT1vLlN0cmVhbVN0b3BwaW5nLmRpc2NyaW1pbmF0b3ImJihuLlJhaW53YXlMb2dnaW5nLmRlYnVnKFwiR290IHJlbW90ZSBTdHJlYW1TdG9wcGluZzpcXG5cIitKU09OLnN0cmluZ2lmeShBLnZhbHVlKSksdGhpcy5kaXNjYXJkU3RyZWFtKEEudmFsdWUuc3RyZWFtSWQpKX0pKX1jcmVhdGVTdHJlYW0oQSl7cmV0dXJuIHIuUmFpbndheVN0cmVhbS5jcmVhdGVBbmRJbml0aWFsaXplKHRoaXMsQS5zdHJlYW1JZCxBLmlucHV0TGV2ZWwsQS5jaG9zZW5BdWRpb0NvbmZpZyxBLmNob3NlblZpZGVvQ29uZmlnLEEuY2FwdHVyZU1vZGUsKEE9PnRoaXMudHJhbnNwb3J0LnNlbmRJbnB1dERhdGFncmFtKEEpKSwoQT0+dGhpcy50cmFuc3BvcnQuc2VuZExvZ2ljRGF0YWdyYW0oQSkpLCgoKT0+dGhpcy50cmFuc3BvcnQuZ2V0U3RhdHMoKSksKCgpPT50aGlzLmRpc2NhcmRTdHJlYW0oQS5zdHJlYW1JZCkpKX1kaXNjYXJkU3RyZWFtKEEpe2NvbnN0IEk9RSh0aGlzLEIpLmdldChBKTt2b2lkIDAhPT1JJiZ0aGlzLm9uU3RyZWFtU3RvcChJKSxFKHRoaXMsQikuZGVsZXRlKEEpfWhhbmRsZUlucHV0TWVzc2FnZShBKXtpZihBLmRpc2NyaW1pbmF0b3I9PT1vLkdhbWVwYWRSdW1ibGUuZGlzY3JpbWluYXRvcil7Y29uc3QgST1BLnZhbHVlLmxlZnRNb3RvclNwZWVkLGc9QS52YWx1ZS5yaWdodE1vdG9yU3BlZWQ7YS5SYWlud2F5SW5wdXRNYW5hZ2VyLnZpYnJhdGVHYW1lcGFkKEEudmFsdWUucG9ydCx7ZHVyYXRpb246MTAwLHN0YXJ0RGVsYXk6MCxzdHJvbmdNYWduaXR1ZGU6TWF0aC5tYXgoSSxnKS82NTUzNSx3ZWFrTWFnbml0dWRlOjB9KX1lbHNlIGlmKEEuZGlzY3JpbWluYXRvcj09PW8uU2V0Q2xpcGJvYXJkVGV4dC5kaXNjcmltaW5hdG9yKXtjb25zdCBJPUEudmFsdWUudGV4dDtuYXZpZ2F0b3IuY2xpcGJvYXJkLndyaXRlVGV4dChJKS50aGVuKCgoKT0+e30pKX1lbHNlIG4uUmFpbndheUxvZ2dpbmcud2FybmluZyhgSWdub3JpbmcgdW5yZWNvZ25pemVkIElucHV0IGRpc2NyaW1pbmF0b3IgJHtBLmRpc2NyaW1pbmF0b3J9YCl9aGFuZGxlTWVkaWFNZXNzYWdlKEEpe2lmKEEuZGlzY3JpbWluYXRvcj09PW8uVmlkZW9EYXRhLmRpc2NyaW1pbmF0b3Ipe2NvbnN0e2RhdGE6SSxzZWdtZW50VGltZTpnLHR5cGU6ZSxkZXNrdG9wUmVjdDppLG1hc2s6USxzdHJlYW1JZDp0fT1BLnZhbHVlLEM9RSh0aGlzLEIpLmdldCh0KTtpZighQylyZXR1cm47Y29uc3QgYT1JLmJ1ZmZlci5zbGljZShJLmJ5dGVPZmZzZXQsSS5ieXRlT2Zmc2V0K0kubGVuZ3RoKSxzPTFlLTQqTnVtYmVyKGcpO2U9PT1vLlZpZGVvRGF0YVR5cGUuRnJhbWVEaWZmJiZ2b2lkIDAhPT10aGlzLmxhc3RUaW1lc3RhbXAmJnMtdGhpcy5sYXN0VGltZXN0YW1wPDMmJm4uUmFpbndheUxvZ2dpbmcud2FybmluZyhgRGlmZmVyZW5jZSBiZXR3ZWVuIHN1Y2Nlc3NpdmUgdGltZXN0YW1wcyB3YXMgJHsocy10aGlzLmxhc3RUaW1lc3RhbXApLnRvRml4ZWQoMSl9YCksZSE9PW8uVmlkZW9EYXRhVHlwZS5NZXRhZGF0YSYmKHRoaXMubGFzdFRpbWVzdGFtcD1zKSxDLnJlbmRlclZpZGVvRnJhbWUoe3RpbWVzdGFtcDpzLHg6aS5sZWZ0LHk6aS50b3Asd2lkdGg6aS53aWR0aCxoZWlnaHQ6aS5oZWlnaHQsbWFzazpRfSxhKX1lbHNlIGlmKEEuZGlzY3JpbWluYXRvcj09PW8uUG9pbnRlckRhdGEuZGlzY3JpbWluYXRvcil7Y29uc3QgST1FKHRoaXMsQikuZ2V0KEEudmFsdWUuc3RyZWFtSWQpO2lmKCFJKXJldHVybjtJLnByb2Nlc3NDdXJzb3Ioe3g6QS52YWx1ZS5wb3NpdGlvblgseTpBLnZhbHVlLnBvc2l0aW9uWSxzcG90WDpBLnZhbHVlLnNwb3RYLHNwb3RZOkEudmFsdWUuc3BvdFksc2hhcGVXaWR0aDpBLnZhbHVlLnNoYXBlV2lkdGgsc2hhcGVIZWlnaHQ6QS52YWx1ZS5zaGFwZUhlaWdodCxleHRlbnRXaWR0aDpBLnZhbHVlLm1vbml0b3JXaWR0aCxleHRlbnRIZWlnaHQ6QS52YWx1ZS5tb25pdG9ySGVpZ2h0LHZpc2libGU6QS52YWx1ZS52aXNpYmxlLGhhc1BvaW50ZXJJbWFnZTpBLnZhbHVlLmRhdGEubGVuZ3RoPjAscG9pbnRlckltYWdlOkEudmFsdWUuZGF0YX0pfWVsc2UgaWYoQS5kaXNjcmltaW5hdG9yPT09by5BdWRpb0RhdGEuZGlzY3JpbWluYXRvcil7Y29uc3QgST1FKHRoaXMsQikuZ2V0KEEudmFsdWUuc3RyZWFtSWQpO2lmKCFJKXJldHVybjtjb25zdHtkYXRhOmcsdHlwZTplfT1BLnZhbHVlLGk9Zy5idWZmZXIuc2xpY2UoZy5ieXRlT2Zmc2V0LGcuYnl0ZU9mZnNldCtnLmxlbmd0aCk7SS5wcm9jZXNzQXVkaW8oaSl9fWV4Y2hhbmdlQ29kZWNzKCl7cmV0dXJuIHQodGhpcyx2b2lkIDAsdm9pZCAwLChmdW5jdGlvbiooKXtpZihFKHRoaXMsZSk9PT1oLkRpc2Nvbm5lY3RlZCl0aHJvdyBuZXcgZC5SYWlud2F5RXJyb3IoXCJDb3VsZG4ndCBleGNoYW5nZSBjb2RlY3M6IHBlZXIgaXMgZGlzY29ubmVjdGVkXCIpO2NvbnN0IEE9eWllbGQgbmV3IFByb21pc2UoKEE9Pnt0aGlzLnRyYW5zcG9ydC5zZW5kTG9naWNEYXRhZ3JhbSh7ZGlzY3JpbWluYXRvcjpvLkNvZGVjUGFja1JlcXVlc3QuZGlzY3JpbWluYXRvcix2YWx1ZTp7fX0pLHRoaXMuY29kZWNzUmVzb2x2ZT1BfSkpO3JldHVybiB0aGlzLmNvZGVjc1Jlc29sdmU9dm9pZCAwLEF9KSl9Y3JlYXRlRGF0YUNoYW5uZWwoQSxJKXtpZigvXlJXXy8udGVzdChBKSl0aHJvdyBuZXcgZC5SYWlud2F5RXJyb3IoXCJEYXRhIGNoYW5uZWwgbmFtZXMgc3RhcnRpbmcgd2l0aCBSV18gYXJlIHJlc2VydmVkIGZvciBSYWlud2F5XCIpO3JldHVybiB2b2lkIDAhPT10aGlzLnRyYW5zcG9ydC5jcmVhdGVEYXRhQ2hhbm5lbChBLEkpfX0sZT1uZXcgV2Vha01hcCxCPW5ldyBXZWFrTWFwLGk9bmV3IFdlYWtNYXAsUT1uZXcgV2Vha01hcH0sNzgzOmZ1bmN0aW9uKEEsSSxnKXtcInVzZSBzdHJpY3RcIjt2YXIgZSxCLGksUSx0LEMsRT10aGlzJiZ0aGlzLl9fYXdhaXRlcnx8ZnVuY3Rpb24oQSxJLGcsZSl7cmV0dXJuIG5ldyhnfHwoZz1Qcm9taXNlKSkoKGZ1bmN0aW9uKEIsaSl7ZnVuY3Rpb24gUShBKXt0cnl7QyhlLm5leHQoQSkpfWNhdGNoKEEpe2koQSl9fWZ1bmN0aW9uIHQoQSl7dHJ5e0MoZS50aHJvdyhBKSl9Y2F0Y2goQSl7aShBKX19ZnVuY3Rpb24gQyhBKXt2YXIgSTtBLmRvbmU/QihBLnZhbHVlKTooST1BLnZhbHVlLEkgaW5zdGFuY2VvZiBnP0k6bmV3IGcoKGZ1bmN0aW9uKEEpe0EoSSl9KSkpLnRoZW4oUSx0KX1DKChlPWUuYXBwbHkoQSxJfHxbXSkpLm5leHQoKSl9KSl9LG89dGhpcyYmdGhpcy5fX2NsYXNzUHJpdmF0ZUZpZWxkU2V0fHxmdW5jdGlvbihBLEksZyl7aWYoIUkuaGFzKEEpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJhdHRlbXB0ZWQgdG8gc2V0IHByaXZhdGUgZmllbGQgb24gbm9uLWluc3RhbmNlXCIpO3JldHVybiBJLnNldChBLGcpLGd9LGE9dGhpcyYmdGhpcy5fX2NsYXNzUHJpdmF0ZUZpZWxkR2V0fHxmdW5jdGlvbihBLEkpe2lmKCFJLmhhcyhBKSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiYXR0ZW1wdGVkIHRvIGdldCBwcml2YXRlIGZpZWxkIG9uIG5vbi1pbnN0YW5jZVwiKTtyZXR1cm4gSS5nZXQoQSl9O09iamVjdC5kZWZpbmVQcm9wZXJ0eShJLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLEkuUmFpbndheVJ1bnRpbWU9SS5SYWlud2F5UGVlclN0YXRlPXZvaWQgMDtjb25zdCBuPWcoMTA0KSxzPWcoOTk0KSxyPWcoNDY0KSxkPWcoMTQ1KSxoPWcoOTA0KSxjPWcoNDIwKTt2YXIgRDtudWxsIT09KGU9KGk9RGF0YVZpZXcucHJvdG90eXBlKS5zZXRCaWdVaW50NjQpJiZ2b2lkIDAhPT1lfHwoaS5zZXRCaWdVaW50NjQ9ZnVuY3Rpb24oQSxJLGcpe2NvbnN0IGU9QmlnSW50KDQyOTQ5NjcyOTUpLEI9TnVtYmVyKEk+PkJpZ0ludCgzMikmZSksaT1OdW1iZXIoSSZlKSxbUSx0XT1nP1s0LDBdOlswLDRdO3RoaXMuc2V0VWludDMyKEErUSxCLGcpLHRoaXMuc2V0VWludDMyKEErdCxpLGcpfSksbnVsbCE9PShCPShRPURhdGFWaWV3LnByb3RvdHlwZSkuZ2V0QmlnVWludDY0KSYmdm9pZCAwIT09Qnx8KFEuZ2V0QmlnVWludDY0PWZ1bmN0aW9uKEEsSSl7Y29uc3RbZyxlXT1JP1s0LDBdOlswLDRdLEI9QmlnSW50KHRoaXMuZ2V0VWludDMyKEErZyxJKSksaT1CaWdJbnQodGhpcy5nZXRVaW50MzIoQStlLEkpKTtyZXR1cm4gQjw8QmlnSW50KDMyKXxpfSksZnVuY3Rpb24oQSl7QVtBLk5ldz0wXT1cIk5ld1wiLEFbQS5Db25uZWN0aW5nPTFdPVwiQ29ubmVjdGluZ1wiLEFbQS5Db25uZWN0ZWQ9Ml09XCJDb25uZWN0ZWRcIixBW0EuRGlzY29ubmVjdGVkPTNdPVwiRGlzY29ubmVjdGVkXCIsQVtBLkZhaWxlZD00XT1cIkZhaWxlZFwifShEPUkuUmFpbndheVBlZXJTdGF0ZXx8KEkuUmFpbndheVBlZXJTdGF0ZT17fSkpO2NsYXNzIHd7Y29uc3RydWN0b3IoQSxJKXt0LnNldCh0aGlzLHZvaWQgMCksQy5zZXQodGhpcyxuZXcgTWFwKSx0aGlzLmNvbm5lY3Rpb25UcmFuc3BvcnRzPW5ldyBNYXAsdGhpcy5kb2N1bWVudFZpc2liaWxpdHlDaGFuZ2VIYW5kbGVyPSgpPT57aWYoZG9jdW1lbnQuaGlkZGVuKWZvcihjb25zdCBBIG9mIHRoaXMucGVlcnMudmFsdWVzKCkpZm9yKGNvbnN0IEkgb2YgQS5zdHJlYW1zLnZhbHVlcygpKUkucmVsZWFzZUtleXMoKSxJLnBhdXNlKCk7ZWxzZSBmb3IoY29uc3QgQSBvZiB0aGlzLnBlZXJzLnZhbHVlcygpKWZvcihjb25zdCBJIG9mIEEuc3RyZWFtcy52YWx1ZXMoKSlJLnBsYXkoKX0sdGhpcy53aW5kb3dCbHVySGFuZGxlcj0oKT0+e2Zvcihjb25zdCBBIG9mIHRoaXMucGVlcnMudmFsdWVzKCkpZm9yKGNvbnN0IEkgb2YgQS5zdHJlYW1zLnZhbHVlcygpKUkucmVsZWFzZUtleXMoKX0sdGhpcy5iZWZvcmVVbmxvYWRIYW5kbGVyPUE9Pntjb25zdCBJPWxvY2F0aW9uLmhhc2g7cmV0dXJuWy4uLnRoaXMucGVlcnMudmFsdWVzKCldLnNvbWUoKEE9PkEuc3RyZWFtcy5zaXplPjApKSYmKHNldFRpbWVvdXQoKCgpPT57bG9jYXRpb24uaGFzaD1cIj9oaj1cIit+fig5OTk5Kk1hdGgucmFuZG9tKCkpLGxvY2F0aW9uLmhhc2g9SX0pLDApLEEucHJldmVudERlZmF1bHQoKSxBLnJldHVyblZhbHVlPVwiXCIpLCExfSx3aW5kb3cuX19yYWlud2F5UnVudGltZT10aGlzLG8odGhpcyx0LEEpLHRoaXMuY29uZmlnPU9iamVjdC5hc3NpZ24oe2V4dGVybmFsSWQ6XCJcIixwcmV2ZW50VW5sb2FkaW5nUGFnZTohMCxsb2dTaW5rOigpPT57fX0sSSksdGhpcy5zZXRMb2dTaW5rKHRoaXMuY29uZmlnLmxvZ1NpbmspLHRoaXMuZ2F0ZXdheT1uZXcgbi5HYXRld2F5KGEodGhpcyx0KSx0aGlzLmNvbmZpZy5hcGlLZXksdGhpcy5jb25maWcuZXh0ZXJuYWxJZCwoQT0+dGhpcy5oYW5kbGVQZWVySW5mbyhBKSksKEE9PnRoaXMuY29uZmlnLm9uQ29ubmVjdGlvblJlcXVlc3QoQSkpLCgoQSxJLGcpPT50aGlzLmFkZFBlZXIoQSxJLGcsXCJhbnN3ZXJcIikpKSx0aGlzLmdhdGV3YXkuY29ubmVjdGlvbkxvc3RFdmVudC5hZGRIYW5kbGVyKChBPT57YSh0aGlzLEMpLmNsZWFyKCksdGhpcy5jb25maWcub25SdW50aW1lQ29ubmVjdGlvbkxvc3QoQSl9KSl9Z2V0IHBlZXJzKCl7cmV0dXJuWy4uLmEodGhpcyxDKS52YWx1ZXMoKV19c3RhdGljIGluaXRpYWxpemUoQSl7cmV0dXJuIEUodGhpcyx2b2lkIDAsdm9pZCAwLChmdW5jdGlvbiooKXtpZih3LmluaXRpYWxpemVkKXRocm93IG5ldyBzLlJhaW53YXlFcnJvcihcIlJhaW53YXlSdW50aW1lIG1heSBvbmx5IGJlIGluaXRpYWxpemVkIG9uY2UuIERvbid0IHdvcnJ5OiB5b3UgY2FuIG1hbmFnZSBtdWx0aXBsZSBSYWlud2F5IGNvbm5lY3Rpb25zIGZyb20gYSBzaW5nbGUgUmFpbndheVJ1bnRpbWUgb2JqZWN0LlwiKTtjb25zdCBJPXlpZWxkIG4uZ2V0UGVlcklkKEEuYXBpS2V5KSxnPW5ldyB3KEksQSk7cmV0dXJuIHlpZWxkIGcuZ2F0ZXdheS5jb25uZWN0KCksd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJiZWZvcmV1bmxvYWRcIiwoQT0+Zy5iZWZvcmVVbmxvYWRIYW5kbGVyKEEpKSksd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJibHVyXCIsKEE9Pmcud2luZG93Qmx1ckhhbmRsZXIoKSkpLGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJ2aXNpYmlsaXR5Y2hhbmdlXCIsKEE9PmcuZG9jdW1lbnRWaXNpYmlsaXR5Q2hhbmdlSGFuZGxlcigpKSksdy5pbml0aWFsaXplZD0hMCxnfSkpfWdldFBlZXJJZCgpe3JldHVybiBhKHRoaXMsdCl9Y29ubmVjdChBKXtyZXR1cm4gRSh0aGlzLHZvaWQgMCx2b2lkIDAsKGZ1bmN0aW9uKigpe2lmKHlpZWxkIHRoaXMuZ2F0ZXdheS5jb25uZWN0KCksYSh0aGlzLEMpLmhhcyhBKSl0aHJvdyBuZXcgcy5SYWlud2F5RXJyb3IoYEFscmVhZHkgY29ubmVjdGVkIHRvICR7QX1gKTtjb25zdCBJPXlpZWxkIHRoaXMuZ2F0ZXdheS5jb25uZWN0VG9Ib3N0KEEsaC5QZWVyVHJhbnNwb3J0VHlwZS5TQ1RQKTtpZihJLmNhbmNlbGVkKXRocm93IG5ldyBzLlJhaW53YXlFcnJvcihcIlRoZSBjb25uZWN0aW9uIGF0dGVtcHQgd2FzIGNhbmNlbGVkLlwiKTtpZighSS5hY2NlcHRlZCl0aHJvdyBuZXcgcy5SYWlud2F5RXJyb3IoYFRoZSBwZWVyIGF0ICR7QX0gcmVqZWN0ZWQgdGhlIGNvbm5lY3Rpb24sIHdpdGggcmVhc29uOiAke0kucmVhc29ufWApO3JldHVybiB0aGlzLmFkZFBlZXIoQSxJLmhvc3RFeHRlcm5hbElkLEkuY29ubmVjdGlvblJlcXVlc3RJZCxcIm9mZmVyXCIpfSkpfWFkZFBlZXIoQSxJLGcsZSl7cmV0dXJuIEUodGhpcyx2b2lkIDAsdm9pZCAwLChmdW5jdGlvbiooKXtjb25zdCBCPW5ldyBkLlJUQ1RyYW5zcG9ydChhKHRoaXMsdCksQSwoST0+dGhpcy5nYXRld2F5LnNlbmRPZmZlcihBLEkpKSwoST0+dGhpcy5nYXRld2F5LnNlbmRBbnN3ZXIoQSxJKSksKEk9PnRoaXMuZ2F0ZXdheS5zZW5kQ2FuZGlkYXRlKEEsSSkpLChBPT57dGhpcy5jb25maWcub25QZWVyU3RhdGVDaGFuZ2UoaSxBKX0pKSxpPW5ldyBjLlJhaW53YXlQZWVyKEEsSSxCLCgoKT0+e3RoaXMuZ2F0ZXdheS5kZWxldGVDb25uZWN0aW9uKEEpLGEodGhpcyxDKS5kZWxldGUoQSl9KSwoQT0+e3RoaXMuY29uZmlnLm9uUGVlckVycm9yKGksQSl9KSwoQT0+e3RoaXMuY29uZmlnLm9uU3RyZWFtQW5ub3VuY2VtZW50KGksQSl9KSwoQT0+e3RoaXMuY29uZmlnLm9uU3RyZWFtU3RvcChBKX0pKTt0aGlzLmNvbm5lY3Rpb25UcmFuc3BvcnRzLnNldChnLEIpLEIub25BcHBsaWNhdGlvbk1lc3NhZ2U9KEEsSSk9PnRoaXMuY29uZmlnLm9uUGVlck1lc3NhZ2UoaSxBLEkpO3RyeXt5aWVsZCBCLm9wZW4oZSl9ZmluYWxseXt0aGlzLmNvbm5lY3Rpb25UcmFuc3BvcnRzLmRlbGV0ZShnKX1yZXR1cm4gaS5zZW5kRGV2aWNlSW5mb0FuZEV4Y2hhbmdlQ29kZWNzKCksYSh0aGlzLEMpLnNldChBLGkpLHRoaXMuY29uZmlnLm9uUGVlclN0YXRlQ2hhbmdlKGksRC5Db25uZWN0ZWQpLGl9KSl9Y2FuY2VsQ29ubmVjdGlvbkF0dGVtcHQoQSl7dGhpcy5nYXRld2F5LmNhbmNlbENvbm5lY3Rpb25BdHRlbXB0KEEpfWhhbmRsZVBlZXJJbmZvKEEpe2NvbnN0IEk9dGhpcy5jb25uZWN0aW9uVHJhbnNwb3J0cy5nZXQoQS5pZCk7dm9pZCAwIT09ST9JLmhhbmRsZVBlZXJJbmZvKEEpOkEudHlwZSE9PWguUGVlckluZm9ybWF0aW9uVHlwZS5DYW5kaWRhdGUmJnIuUmFpbndheUxvZ2dpbmcud2FybmluZyhcIkdvdCBwZWVyIGluZm8gZm9yIHVuZXhwZWN0ZWQgQ1JJRD8gXCIrQS5pZCl9Z2V0TWVkaWFDYXBhYmlsaXRpZXMoQSl7cmV0dXJuIG5hdmlnYXRvci5tZWRpYUNhcGFiaWxpdGllcy5kZWNvZGluZ0luZm8oQSl9c2V0TG9nU2luayhBKXtyLlJhaW53YXlMb2dnaW5nLnNldExvZ1NpbmsoQSl9fUkuUmFpbndheVJ1bnRpbWU9dyx0PW5ldyBXZWFrTWFwLEM9bmV3IFdlYWtNYXAsdy5pbml0aWFsaXplZD0hMX0sODc2OmZ1bmN0aW9uKEEsSSxnKXtcInVzZSBzdHJpY3RcIjt2YXIgZSxCPXRoaXMmJnRoaXMuX19hd2FpdGVyfHxmdW5jdGlvbihBLEksZyxlKXtyZXR1cm4gbmV3KGd8fChnPVByb21pc2UpKSgoZnVuY3Rpb24oQixpKXtmdW5jdGlvbiBRKEEpe3RyeXtDKGUubmV4dChBKSl9Y2F0Y2goQSl7aShBKX19ZnVuY3Rpb24gdChBKXt0cnl7QyhlLnRocm93KEEpKX1jYXRjaChBKXtpKEEpfX1mdW5jdGlvbiBDKEEpe3ZhciBJO0EuZG9uZT9CKEEudmFsdWUpOihJPUEudmFsdWUsSSBpbnN0YW5jZW9mIGc/STpuZXcgZygoZnVuY3Rpb24oQSl7QShJKX0pKSkudGhlbihRLHQpfUMoKGU9ZS5hcHBseShBLEl8fFtdKSkubmV4dCgpKX0pKX0saT10aGlzJiZ0aGlzLl9fY2xhc3NQcml2YXRlRmllbGRHZXR8fGZ1bmN0aW9uKEEsSSl7aWYoIUkuaGFzKEEpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJhdHRlbXB0ZWQgdG8gZ2V0IHByaXZhdGUgZmllbGQgb24gbm9uLWluc3RhbmNlXCIpO3JldHVybiBJLmdldChBKX0sUT10aGlzJiZ0aGlzLl9fY2xhc3NQcml2YXRlRmllbGRTZXR8fGZ1bmN0aW9uKEEsSSxnKXtpZighSS5oYXMoQSkpdGhyb3cgbmV3IFR5cGVFcnJvcihcImF0dGVtcHRlZCB0byBzZXQgcHJpdmF0ZSBmaWVsZCBvbiBub24taW5zdGFuY2VcIik7cmV0dXJuIEkuc2V0KEEsZyksZ307T2JqZWN0LmRlZmluZVByb3BlcnR5KEksXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksSS5SYWlud2F5U3RyZWFtPXZvaWQgMDtjb25zdCB0PWcoOTk0KSxDPWcoOTA0KSxFPWcoODI0KSxvPWcoNDI1KSxhPWcoNjQzKSxuPWcoNDY0KSxzPWcoNjk1KTtjbGFzcyBye2NvbnN0cnVjdG9yKEEsSSxnLEIsaSxRLHQsbixyLGQpe3RoaXMuaG9zdD1BLHRoaXMuc3RyZWFtSWQ9SSx0aGlzLmNob3NlbkF1ZGlvQ29uZmlnPUIsdGhpcy5jaG9zZW5WaWRlb0NvbmZpZz1pLHRoaXMuY2FwdHVyZU1vZGU9USx0aGlzLnNlbmRJbnB1dD10LHRoaXMuc2VuZExvZ2ljPW4sdGhpcy5wZWVyRGlzY2FyZFN0cmVhbT1kLHRoaXMucmVzaXplRGVib3VuY2VIYW5kbGU9dm9pZCAwLGUuc2V0KHRoaXMsITEpLHRoaXMuc2VuZEtleWZyYW1lUmVxdWVzdD0oKT0+e3RoaXMuc2VuZExvZ2ljKHtkaXNjcmltaW5hdG9yOkMuS2V5ZnJhbWVSZXF1ZXN0LmRpc2NyaW1pbmF0b3IsdmFsdWU6e3N0cmVhbUlkOnRoaXMuc3RyZWFtSWR9fSl9LHRoaXMuZmVlZFZpZGVvU3RhdGVJbnRvUmF0ZUNvbnRyb2xsZXI9QT0+e3RoaXMucmF0ZUNvbnRyb2xsZXIuaGFuZGxlVmlkZW9SZWFkeVN0YXRlKEEpfSx0aGlzLnNldFJlbW90ZUNsaXBib2FyZD0oKT0+e25hdmlnYXRvci5jbGlwYm9hcmQucmVhZFRleHQoKS50aGVuKChBPT57dGhpcy5zZW5kSW5wdXQoe2Rpc2NyaW1pbmF0b3I6Qy5TZXRDbGlwYm9hcmRUZXh0LmRpc2NyaW1pbmF0b3IsdmFsdWU6e3RleHQ6QX19KX0pKX07Y29uc3QgaD1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO2gudGFiSW5kZXg9MCxoLnN0eWxlLnRvdWNoQWN0aW9uPVwibm9uZVwiLGguc3R5bGUudXNlclNlbGVjdD1cIm5vbmVcIixoLnN0eWxlLndlYmtpdFVzZXJTZWxlY3Q9XCJub25lXCIsaC5zdHlsZS5wb3NpdGlvbj1cInJlbGF0aXZlXCIsaC5zdHlsZS53aWR0aD1cIjEwMCVcIixoLnN0eWxlLmhlaWdodD1cIjEwMCVcIixoLmNsYXNzTmFtZT1cInJhaW53YXktaW5uZXItY29udGFpbmVyXCIsaC5hZGRFdmVudExpc3RlbmVyKFwiZm9jdXNcIix0aGlzLnNldFJlbW90ZUNsaXBib2FyZCksdGhpcy5pbm5lckNvbnRhaW5lcj1oLHRoaXMuaW5wdXRNYW5hZ2VyPW5ldyBFLlJhaW53YXlJbnB1dE1hbmFnZXIodGhpcyksdGhpcy5tZWRpYU1hbmFnZXI9bmV3IG8uTWVkaWFNYW5hZ2VyKFEsaSx7dmlkZW86e2NvZGVjU3RyaW5nOnMudmlkZW9Db2RlY01pbWVUeXBlKGkuY29kZWMpfX0sciksdGhpcy5yYXRlQ29udHJvbGxlcj1uZXcgYS5SYWlud2F5UmF0ZUNvbnRyb2xsZXIodm9pZCAwLGksKEE9PnRoaXMuc2VuZExvZ2ljKHtkaXNjcmltaW5hdG9yOkMuVmlkZW9CaXRyYXRlUmVxdWVzdC5kaXNjcmltaW5hdG9yLHZhbHVlOntzdHJlYW1JZDpJLGJpdHNQZXJTZWNvbmQ6MWUzKkF9fSkpLHRoaXMubWVkaWFNYW5hZ2VyLnZpZGVvUGVyZm9ybWFuY2VNb25pdG9yKSxoLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCgoKT0+e3RoaXMucmVzdW1lQXVkaW8oKX0pKSx0aGlzLm1lZGlhTWFuYWdlci5zZXRDb250YWluZXIoaCksdGhpcy5tZWRpYU1hbmFnZXIudmlkZW9OZWVkc1Jlc3RhcnRFdmVudC5hZGRIYW5kbGVyKHRoaXMuc2VuZEtleWZyYW1lUmVxdWVzdCksdGhpcy5tZWRpYU1hbmFnZXIudmlkZW9SZWFkeVN0YXRlQ2hhbmdlRXZlbnQuYWRkSGFuZGxlcih0aGlzLmZlZWRWaWRlb1N0YXRlSW50b1JhdGVDb250cm9sbGVyKSx0aGlzLmlucHV0TWFuYWdlci5zZXRDb250YWluZXIoaCksdGhpcy5pbnB1dE1hbmFnZXIuc2V0SW5wdXRMZXZlbChnKSx0aGlzLmNvbnRhaW5lclJlc2l6ZU9ic2VydmVyPW5ldyBSZXNpemVPYnNlcnZlcigoKCk9Pnt0aGlzLnJlc2l6ZURlYm91bmNlSGFuZGxlJiZ3aW5kb3cuY2xlYXJUaW1lb3V0KHRoaXMucmVzaXplRGVib3VuY2VIYW5kbGUpLHRoaXMucmVzaXplRGVib3VuY2VIYW5kbGU9d2luZG93LnNldFRpbWVvdXQoKCgpPT57dGhpcy5zZW5kSW5wdXQoe2Rpc2NyaW1pbmF0b3I6Qy5WaWV3cG9ydFJlc2l6ZS5kaXNjcmltaW5hdG9yLHZhbHVlOnt3aWR0aDp0aGlzLmlubmVyQ29udGFpbmVyLmNsaWVudFdpZHRoLGhlaWdodDp0aGlzLmlubmVyQ29udGFpbmVyLmNsaWVudEhlaWdodH19KSx0aGlzLnJlc2l6ZURlYm91bmNlSGFuZGxlPXZvaWQgMH0pLDEwMCl9KSksdGhpcy5jb250YWluZXJSZXNpemVPYnNlcnZlci5vYnNlcnZlKGgpLHdpbmRvdy5fX3JhaW53YXlTdHJlYW09dGhpc31nZXQgZGVhZCgpe3JldHVybiBpKHRoaXMsZSl9Z2V0IGNvbnRhaW5lcigpe3JldHVybiB0aGlzLmlubmVyQ29udGFpbmVyfWdldCBpbnB1dExldmVsKCl7cmV0dXJuIHRoaXMuaW5wdXRNYW5hZ2VyLmdldElucHV0TGV2ZWwoKX1nZXQgY3VycmVudEZyYW1lU2l6ZSgpe2NvbnN0e2NvZGVjOkF9PXRoaXMuY2hvc2VuVmlkZW9Db25maWc7cmV0dXJue2NvZGVjV2lkdGg6QS53aWR0aCxjb2RlY0hlaWdodDpBLmhlaWdodCxzdHJlYW1Cb3VuZHM6dGhpcy5tZWRpYU1hbmFnZXIuY3VycmVudFN0cmVhbUJvdW5kcyxmdWxsRGVza3RvcEJvdW5kczp0aGlzLm1lZGlhTWFuYWdlci5jdXJyZW50RnVsbERlc2t0b3BCb3VuZHN9fXN0YXRpYyBjcmVhdGVBbmRJbml0aWFsaXplKEEsSSxnLGUsaSxRLHQsQyxFLG8pe3JldHVybiBCKHRoaXMsdm9pZCAwLHZvaWQgMCwoZnVuY3Rpb24qKCl7Y29uc3QgQj1uZXcgcihBLEksZyxlLGksUSx0LEMsRSxvKTtyZXR1cm4geWllbGQgQi5tZWRpYU1hbmFnZXIuaW5pdGlhbGl6ZSgpLEJ9KSl9cHJvY2Vzc0F1ZGlvKEEpe3RoaXMubWVkaWFNYW5hZ2VyLnByb2Nlc3NBdWRpbyhBKX1wcm9jZXNzQ3Vyc29yKEEpe3RoaXMuaW5wdXRNYW5hZ2VyLnByb2Nlc3NDdXJzb3IoQSl9cmVuZGVyVmlkZW9GcmFtZShBLEkpe3RoaXMucmF0ZUNvbnRyb2xsZXIuZmVlZEZyYW1lVGltZXN0YW1wKEEudGltZXN0YW1wKSx0aGlzLm1lZGlhTWFuYWdlci5yZW5kZXJWaWRlb0ZyYW1lKEEsSSl9dHJhbnNmb3JtUG9pbnRlck9mZnNldFRvUmVtb3RlKEEsSSl7Y29uc3QgZz10aGlzLm1lZGlhTWFuYWdlci5jdXJyZW50U3RyZWFtQm91bmRzO2lmKCFnKXJldHVybjtjb25zdCBlPXRoaXMubWVkaWFNYW5hZ2VyLmN1cnJlbnRGdWxsRGVza3RvcEJvdW5kcztpZighZSlyZXR1cm47Y29uc3R7bGVmdDpCLHRvcDppLHdpZHRoOlEsaGVpZ2h0OnR9PWUse2xlZnQ6Qyx0b3A6RSx3aWR0aDpvLGhlaWdodDphfT1nLG49dGhpcy5jaG9zZW5WaWRlb0NvbmZpZy5jb2RlYy53aWR0aCxzPXRoaXMuY2hvc2VuVmlkZW9Db25maWcuY29kZWMuaGVpZ2h0LHI9dGhpcy5pbm5lckNvbnRhaW5lci5jbGllbnRXaWR0aCxkPXRoaXMuaW5uZXJDb250YWluZXIuY2xpZW50SGVpZ2h0LGg9bypuL1EsYz1hKnMvdCxEPU1hdGgubWluKHIvaCxkL2MpO3JldHVybnt4OihBLShyLUQqaCkvMikvKEQqbi9RKStDLUIseTooSS0oZC1EKmMpLzIpLyhEKnMvdCkrRS1pfX1yZWxlYXNlS2V5cygpe3RoaXMuaW5wdXRNYW5hZ2VyLnJlbGVhc2VLZXlzKCl9ZW5hYmxlVmlkZW9TdGF0c092ZXJsYXkoKXt2YXIgQTtudWxsPT09KEE9dGhpcy5tZWRpYU1hbmFnZXIpfHx2b2lkIDA9PT1BfHxBLmVuYWJsZVN0YXRzT3ZlcmxheSgpfWRpc2FibGVWaWRlb1N0YXRzT3ZlcmxheSgpe3ZhciBBO251bGw9PT0oQT10aGlzLm1lZGlhTWFuYWdlcil8fHZvaWQgMD09PUF8fEEuZGlzYWJsZVN0YXRzT3ZlcmxheSgpfXJlcXVlc3RGdWxsc2NyZWVuKEEpe3ZhciBJLGcsZTtjb25zdCBCPW51bGw9PT0oST1udWxsPT1BP3ZvaWQgMDpBLmxvY2tLZXlib2FyZCl8fHZvaWQgMD09PUl8fEksaT1udWxsPT09KGc9bnVsbD09QT92b2lkIDA6QS5sb2NrUG9pbnRlcil8fHZvaWQgMD09PWd8fGc7aWYodGhpcy5pbm5lckNvbnRhaW5lci5yZXF1ZXN0RnVsbHNjcmVlbj90aGlzLmlubmVyQ29udGFpbmVyLnJlcXVlc3RGdWxsc2NyZWVuKHtuYXZpZ2F0aW9uVUk6XCJoaWRlXCJ9KTp0aGlzLmlubmVyQ29udGFpbmVyLndlYmtpdFJlcXVlc3RGdWxsc2NyZWVuKHtuYXZpZ2F0aW9uVUk6XCJoaWRlXCJ9KSxCJiZcImtleWJvYXJkXCJpbiBuYXZpZ2F0b3IpdHJ5e25hdmlnYXRvci5rZXlib2FyZC5sb2NrKCl9Y2F0Y2goQSl7fWkmJihudWxsPT09KGU9dGhpcy5pbnB1dE1hbmFnZXIpfHx2b2lkIDA9PT1lfHxlLmxvY2tQb2ludGVyKCkpfXBsYXkoKXtpZihpKHRoaXMsZSkpdGhyb3cgbmV3IHQuUmFpbndheUVycm9yKFwiQXR0ZW1wdGVkIHRvIHBsYXkgYSBkZWFkIHN0cmVhbVwiKTt0aGlzLm1lZGlhTWFuYWdlci5wbGF5KCksdGhpcy5yYXRlQ29udHJvbGxlci5zdGFydCgpfXBhdXNlKCl7aWYoaSh0aGlzLGUpKXRocm93IG5ldyB0LlJhaW53YXlFcnJvcihcIkF0dGVtcHRlZCB0byBwYXVzZSBhIGRlYWQgc3RyZWFtXCIpO3RoaXMubWVkaWFNYW5hZ2VyLnBhdXNlKCksdGhpcy5yYXRlQ29udHJvbGxlci5zdG9wKCl9bGVhdmUoKXtpKHRoaXMsZSk/bi5SYWlud2F5TG9nZ2luZy53YXJuaW5nKFwiQXR0ZW1wdGVkIHRvIGxlYXZlIGEgZGVhZCBzdHJlYW1cIik6KHRoaXMuc2VuZExvZ2ljKHtkaXNjcmltaW5hdG9yOkMuTGVhdmVTdHJlYW0uZGlzY3JpbWluYXRvcix2YWx1ZTp7c3RyZWFtSWQ6dGhpcy5zdHJlYW1JZH19KSx0aGlzLnBlZXJEaXNjYXJkU3RyZWFtKCksdGhpcy5pbm5lckNvbnRhaW5lci5yZW1vdmVFdmVudExpc3RlbmVyKFwiZm9jdXNcIix0aGlzLnNldFJlbW90ZUNsaXBib2FyZCksdGhpcy5jb250YWluZXJSZXNpemVPYnNlcnZlci5kaXNjb25uZWN0KCksdGhpcy5tZWRpYU1hbmFnZXIudmlkZW9OZWVkc1Jlc3RhcnRFdmVudC5yZW1vdmVIYW5kbGVyKHRoaXMuc2VuZEtleWZyYW1lUmVxdWVzdCksdGhpcy5tZWRpYU1hbmFnZXIudmlkZW9SZWFkeVN0YXRlQ2hhbmdlRXZlbnQucmVtb3ZlSGFuZGxlcih0aGlzLmZlZWRWaWRlb1N0YXRlSW50b1JhdGVDb250cm9sbGVyKSx0aGlzLmlucHV0TWFuYWdlci5kaXNwb3NlKCksdGhpcy5tZWRpYU1hbmFnZXIuZGlzcG9zZSgpLHRoaXMucmF0ZUNvbnRyb2xsZXIuc3RvcCgpLFEodGhpcyxlLCEwKSl9cmVzdW1lQXVkaW8oKXt2YXIgQSxJO251bGw9PT0oST1udWxsPT09KEE9dGhpcy5tZWRpYU1hbmFnZXIpfHx2b2lkIDA9PT1BP3ZvaWQgMDpBLmF1ZGlvQ29udGV4dCl8fHZvaWQgMD09PUl8fEkucmVzdW1lKCl9ZW5hYmxlR2VzdHVyZXMoKXt2YXIgQTtudWxsPT09KEE9dGhpcy5pbnB1dE1hbmFnZXIpfHx2b2lkIDA9PT1BfHxBLmVuYWJsZUdlc3R1cmVzKCl9ZGlzYWJsZUdlc3R1cmVzKCl7dmFyIEE7bnVsbD09PShBPXRoaXMuaW5wdXRNYW5hZ2VyKXx8dm9pZCAwPT09QXx8QS5kaXNhYmxlR2VzdHVyZXMoKX19SS5SYWlud2F5U3RyZWFtPXIsZT1uZXcgV2Vha01hcH0sOTk0OihBLEkpPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KEksXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksSS5SYWlud2F5RXJyb3I9dm9pZCAwO2NsYXNzIGcgZXh0ZW5kcyBFcnJvcntjb25zdHJ1Y3RvcihBKXtzdXBlcihgUmFpbndheSBTREsgRXJyb3I6ICR7QX1gKSx0aGlzLm5hbWU9dGhpcy5jb25zdHJ1Y3Rvci5uYW1lLFwiZnVuY3Rpb25cIj09dHlwZW9mIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlP0Vycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsdGhpcy5jb25zdHJ1Y3Rvcik6dGhpcy5zdGFjaz1uZXcgRXJyb3IoYFJhaW53YXkgU0RLIEVycm9yOiAke0F9YCkuc3RhY2ssT2JqZWN0LnNldFByb3RvdHlwZU9mKHRoaXMsZy5wcm90b3R5cGUpfX1JLlJhaW53YXlFcnJvcj1nfSw4NTk6QT0+e3NlbGYsQS5leHBvcnRzPSgoKT0+e1widXNlIHN0cmljdFwiO3ZhciBBPXsxMTQ6ZnVuY3Rpb24oQSxJLGcpe3ZhciBlPXRoaXMmJnRoaXMuX19pbXBvcnREZWZhdWx0fHxmdW5jdGlvbihBKXtyZXR1cm4gQSYmQS5fX2VzTW9kdWxlP0E6e2RlZmF1bHQ6QX19O09iamVjdC5kZWZpbmVQcm9wZXJ0eShJLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO2NvbnN0IEI9ZShnKDE3MCkpO2NsYXNzIGl7aW5pdGlhbGl6ZSgpe3JldHVybiB0aGlzLmlkPWkudW5pcXVlSWRDb3VudGVyKyssbmV3IFByb21pc2UoKChBLEkpPT57dGhpcy53b3JrZXI9bmV3IEIuZGVmYXVsdCx0aGlzLndvcmtlci5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLChJPT57dmFyIGc7Y29uc3QgZT1JLmRhdGE7XCJkZWNvZGVyUmVhZHlcIj09PWUudHlwZT9BKDApOlwicGljdHVyZVJlYWR5XCI9PT1lLnR5cGUmJihudWxsPT09KGc9dGhpcy5vbkRlY29kZSl8fHZvaWQgMD09PWd8fGcuY2FsbCh0aGlzLGUpKX0pKX0pKX1kZWNvZGUoQSl7dGhpcy53b3JrZXImJnRoaXMud29ya2VyLnBvc3RNZXNzYWdlKHt0eXBlOlwiZGVjb2RlXCIsZGF0YTpBLmJ1ZmZlcixvZmZzZXQ6QS5ieXRlT2Zmc2V0LGxlbmd0aDpBLmJ5dGVMZW5ndGgscmVuZGVyU3RhdGVJZDp0aGlzLmlkfSxbQS5idWZmZXJdKX1yZWxlYXNlKCl7dGhpcy53b3JrZXImJnRoaXMud29ya2VyLnBvc3RNZXNzYWdlKHt0eXBlOlwicmVsZWFzZVwiLHJlbmRlclN0YXRlSWQ6dGhpcy5pZH0pfWRpc3Bvc2UoKXt0aGlzLndvcmtlciYmKHRoaXMud29ya2VyLnRlcm1pbmF0ZSgpLHRoaXMud29ya2VyPXZvaWQgMCl9fUkuZGVmYXVsdD1pLGkudW5pcXVlSWRDb3VudGVyPTF9LDE3MDooQSxJLGcpPT57Zy5yKEkpLGcuZChJLHtkZWZhdWx0OigpPT5pfSk7dmFyIGU9Zyg2MTQpLEI9Zy5uKGUpO2Z1bmN0aW9uIGkoKXtyZXR1cm4gQigpKCcvKiEgRm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24gcGxlYXNlIHNlZSBpbmRleC53b3JrZXIuanMuTElDRU5TRS50eHQgKi9cXG4oKCk9Pnt2YXIgQT17NzE5OkE9Pnt2YXIgSSxnPShJPVwidW5kZWZpbmVkXCIhPXR5cGVvZiBkb2N1bWVudCYmZG9jdW1lbnQuY3VycmVudFNjcmlwdD9kb2N1bWVudC5jdXJyZW50U2NyaXB0LnNyYzp2b2lkIDAsZnVuY3Rpb24oQSl7KEE9QXx8e30pfHwoQT12b2lkIDAhPT1BP0E6e30pO3ZhciBnLEI9e307Zm9yKGcgaW4gQSlBLmhhc093blByb3BlcnR5KGcpJiYoQltnXT1BW2ddKTt2YXIgUSxDPVtdLEU9XCJcIjtFPXNlbGYubG9jYXRpb24uaHJlZixJJiYoRT1JKSxFPTAhPT1FLmluZGV4T2YoXCJibG9iOlwiKT9FLnN1YnN0cigwLEUubGFzdEluZGV4T2YoXCIvXCIpKzEpOlwiXCIsUT1mdW5jdGlvbihBKXt2YXIgST1uZXcgWE1MSHR0cFJlcXVlc3Q7cmV0dXJuIEkub3BlbihcIkdFVFwiLEEsITEpLEkucmVzcG9uc2VUeXBlPVwiYXJyYXlidWZmZXJcIixJLnNlbmQobnVsbCksbmV3IFVpbnQ4QXJyYXkoSS5yZXNwb25zZSl9O3ZhciBpLEQsbz1BLnByaW50fHxjb25zb2xlLmxvZy5iaW5kKGNvbnNvbGUpLGE9QS5wcmludEVycnx8Y29uc29sZS53YXJuLmJpbmQoY29uc29sZSk7Zm9yKGcgaW4gQilCLmhhc093blByb3BlcnR5KGcpJiYoQVtnXT1CW2ddKTtCPW51bGwsQS5hcmd1bWVudHMmJihDPUEuYXJndW1lbnRzKSxBLnRoaXNQcm9ncmFtJiZBLnRoaXNQcm9ncmFtLEEucXVpdCYmQS5xdWl0LEEud2FzbUJpbmFyeSYmKGk9QS53YXNtQmluYXJ5KSxBLm5vRXhpdFJ1bnRpbWUmJkEubm9FeGl0UnVudGltZSxcIm9iamVjdFwiIT10eXBlb2YgV2ViQXNzZW1ibHkmJmEoXCJubyBuYXRpdmUgd2FzbSBzdXBwb3J0IGRldGVjdGVkXCIpO3ZhciBHLFMsRixOLHcseSxSLGg9bmV3IFdlYkFzc2VtYmx5LlRhYmxlKHtpbml0aWFsOjEsbWF4aW11bToxLGVsZW1lbnQ6XCJhbnlmdW5jXCJ9KSxzPSExO2Z1bmN0aW9uIGsoSSl7Rz1JLEEuSEVBUDg9Uz1uZXcgSW50OEFycmF5KEkpLEEuSEVBUDE2PU49bmV3IEludDE2QXJyYXkoSSksQS5IRUFQMzI9dz1uZXcgSW50MzJBcnJheShJKSxBLkhFQVBVOD1GPW5ldyBVaW50OEFycmF5KEkpLEEuSEVBUFUxNj1uZXcgVWludDE2QXJyYXkoSSksQS5IRUFQVTMyPW5ldyBVaW50MzJBcnJheShJKSxBLkhFQVBGMzI9eT1uZXcgRmxvYXQzMkFycmF5KEkpLEEuSEVBUEY2ND1SPW5ldyBGbG9hdDY0QXJyYXkoSSl9dmFyIEw9QS5JTklUSUFMX01FTU9SWXx8MTY3NzcyMTY7ZnVuY3Rpb24gTShJKXtmb3IoO0kubGVuZ3RoPjA7KXt2YXIgZz1JLnNoaWZ0KCk7aWYoXCJmdW5jdGlvblwiIT10eXBlb2YgZyl7dmFyIEI9Zy5mdW5jO1wibnVtYmVyXCI9PXR5cGVvZiBCP3ZvaWQgMD09PWcuYXJnP0EuZHluQ2FsbF92KEIpOkEuZHluQ2FsbF92aShCLGcuYXJnKTpCKHZvaWQgMD09PWcuYXJnP251bGw6Zy5hcmcpfWVsc2UgZyhBKX19KEQ9QS53YXNtTWVtb3J5P0Eud2FzbU1lbW9yeTpuZXcgV2ViQXNzZW1ibHkuTWVtb3J5KHtpbml0aWFsOkwvNjU1MzYsbWF4aW11bTozMjc2OH0pKSYmKEc9RC5idWZmZXIpLEw9Ry5ieXRlTGVuZ3RoLGsoRyksd1syMTg4XT01MjUxNzkyO3ZhciBVPVtdLFk9W10sSj1bXSxxPVtdLEs9MCxIPW51bGwsdD1udWxsO2Z1bmN0aW9uIGMoSSl7dGhyb3cgQS5vbkFib3J0JiZBLm9uQWJvcnQoSSksbyhJKz1cIlwiKSxhKEkpLHM9ITAsST1cImFib3J0KFwiK0krXCIpLiBCdWlsZCB3aXRoIC1zIEFTU0VSVElPTlM9MSBmb3IgbW9yZSBpbmZvLlwiLG5ldyBXZWJBc3NlbWJseS5SdW50aW1lRXJyb3IoSSl9ZnVuY3Rpb24gZChBKXtyZXR1cm4gST1BLGc9XCJkYXRhOmFwcGxpY2F0aW9uL29jdGV0LXN0cmVhbTtiYXNlNjQsXCIsU3RyaW5nLnByb3RvdHlwZS5zdGFydHNXaXRoP0kuc3RhcnRzV2l0aChnKTowPT09SS5pbmRleE9mKGcpO3ZhciBJLGd9QS5wcmVsb2FkZWRJbWFnZXM9e30sQS5wcmVsb2FkZWRBdWRpb3M9e307dmFyIG4scD1cIlRpbnlIMjY0Lndhc21cIjtmdW5jdGlvbiBmKCl7dHJ5e2lmKGkpcmV0dXJuIG5ldyBVaW50OEFycmF5KGkpO2lmKFEpcmV0dXJuIFEocCk7dGhyb3dcImJvdGggYXN5bmMgYW5kIHN5bmMgZmV0Y2hpbmcgb2YgdGhlIHdhc20gZmFpbGVkXCJ9Y2F0Y2goQSl7YyhBKX19ZnVuY3Rpb24gcihBKXt0cnl7cmV0dXJuIEQuZ3JvdyhBLUcuYnl0ZUxlbmd0aCs2NTUzNT4+PjE2KSxrKEQuYnVmZmVyKSwxfWNhdGNoKEEpe319ZChwKXx8KG49cCxwPUEubG9jYXRlRmlsZT9BLmxvY2F0ZUZpbGUobixFKTpFK24pLFkucHVzaCh7ZnVuYzpmdW5jdGlvbigpe3goKX19KTt2YXIgZT17YTpmdW5jdGlvbihBLEksZyl7Ri5jb3B5V2l0aGluKEEsSSxJK2cpfSxiOmZ1bmN0aW9uKEEpe0E+Pj49MDt2YXIgST1GLmxlbmd0aCxnPTIxNDc0ODM2NDg7aWYoQT5nKXJldHVybiExO2Zvcih2YXIgQixRPTE7UTw9NDtRKj0yKXt2YXIgQz1JKigxKy4yL1EpO2lmKEM9TWF0aC5taW4oQyxBKzEwMDY2MzI5NikscihNYXRoLm1pbihnLCgoQj1NYXRoLm1heCgxNjc3NzIxNixBLEMpKSU2NTUzNj4wJiYoQis9NjU1MzYtQiU2NTUzNiksQikpKSlyZXR1cm4hMH1yZXR1cm4hMX0sbWVtb3J5OkQsdGFibGU6aH0sbT1mdW5jdGlvbigpe3ZhciBJPXthOmV9O2Z1bmN0aW9uIGcoSSxnKXt2YXIgQj1JLmV4cG9ydHM7QS5hc209QixmdW5jdGlvbihJKXtpZihLLS0sQS5tb25pdG9yUnVuRGVwZW5kZW5jaWVzJiZBLm1vbml0b3JSdW5EZXBlbmRlbmNpZXMoSyksMD09SyYmKG51bGwhPT1IJiYoY2xlYXJJbnRlcnZhbChIKSxIPW51bGwpLHQpKXt2YXIgZz10O3Q9bnVsbCxnKCl9fSgpfWZ1bmN0aW9uIEIoQSl7ZyhBLmluc3RhbmNlKX1mdW5jdGlvbiBRKEEpe3JldHVybihpfHxcImZ1bmN0aW9uXCIhPXR5cGVvZiBmZXRjaD9uZXcgUHJvbWlzZSgoZnVuY3Rpb24oQSxJKXtBKGYoKSl9KSk6ZmV0Y2gocCx7Y3JlZGVudGlhbHM6XCJzYW1lLW9yaWdpblwifSkudGhlbigoZnVuY3Rpb24oQSl7aWYoIUEub2spdGhyb3dcImZhaWxlZCB0byBsb2FkIHdhc20gYmluYXJ5IGZpbGUgYXQgXFwnXCIrcCtcIlxcJ1wiO3JldHVybiBBLmFycmF5QnVmZmVyKCl9KSkuY2F0Y2goKGZ1bmN0aW9uKCl7cmV0dXJuIGYoKX0pKSkudGhlbigoZnVuY3Rpb24oQSl7cmV0dXJuIFdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlKEEsSSl9KSkudGhlbihBLChmdW5jdGlvbihBKXthKFwiZmFpbGVkIHRvIGFzeW5jaHJvbm91c2x5IHByZXBhcmUgd2FzbTogXCIrQSksYyhBKX0pKX1pZihLKyssQS5tb25pdG9yUnVuRGVwZW5kZW5jaWVzJiZBLm1vbml0b3JSdW5EZXBlbmRlbmNpZXMoSyksQS5pbnN0YW50aWF0ZVdhc20pdHJ5e3JldHVybiBBLmluc3RhbnRpYXRlV2FzbShJLGcpfWNhdGNoKEEpe3JldHVybiBhKFwiTW9kdWxlLmluc3RhbnRpYXRlV2FzbSBjYWxsYmFjayBmYWlsZWQgd2l0aCBlcnJvcjogXCIrQSksITF9cmV0dXJuIGZ1bmN0aW9uKCl7aWYoaXx8XCJmdW5jdGlvblwiIT10eXBlb2YgV2ViQXNzZW1ibHkuaW5zdGFudGlhdGVTdHJlYW1pbmd8fGQocCl8fFwiZnVuY3Rpb25cIiE9dHlwZW9mIGZldGNoKXJldHVybiBRKEIpO2ZldGNoKHAse2NyZWRlbnRpYWxzOlwic2FtZS1vcmlnaW5cIn0pLnRoZW4oKGZ1bmN0aW9uKEEpe3JldHVybiBXZWJBc3NlbWJseS5pbnN0YW50aWF0ZVN0cmVhbWluZyhBLEkpLnRoZW4oQiwoZnVuY3Rpb24oQSl7YShcIndhc20gc3RyZWFtaW5nIGNvbXBpbGUgZmFpbGVkOiBcIitBKSxhKFwiZmFsbGluZyBiYWNrIHRvIEFycmF5QnVmZmVyIGluc3RhbnRpYXRpb25cIiksUShCKX0pKX0pKX0oKSx7fX0oKTtBLmFzbT1tO3ZhciBXLHg9QS5fX193YXNtX2NhbGxfY3RvcnM9ZnVuY3Rpb24oKXtyZXR1cm4oeD1BLl9fX3dhc21fY2FsbF9jdG9ycz1BLmFzbS5jKS5hcHBseShudWxsLGFyZ3VtZW50cyl9O2Z1bmN0aW9uIFgoSSl7ZnVuY3Rpb24gZygpe1d8fChXPSEwLEEuY2FsbGVkUnVuPSEwLHN8fChNKFkpLE0oSiksQS5vblJ1bnRpbWVJbml0aWFsaXplZCYmQS5vblJ1bnRpbWVJbml0aWFsaXplZCgpLGZ1bmN0aW9uKCl7aWYoQS5wb3N0UnVuKWZvcihcImZ1bmN0aW9uXCI9PXR5cGVvZiBBLnBvc3RSdW4mJihBLnBvc3RSdW49W0EucG9zdFJ1bl0pO0EucG9zdFJ1bi5sZW5ndGg7KUk9QS5wb3N0UnVuLnNoaWZ0KCkscS51bnNoaWZ0KEkpO3ZhciBJO00ocSl9KCkpKX1JPUl8fEMsSz4wfHwoZnVuY3Rpb24oKXtpZihBLnByZVJ1bilmb3IoXCJmdW5jdGlvblwiPT10eXBlb2YgQS5wcmVSdW4mJihBLnByZVJ1bj1bQS5wcmVSdW5dKTtBLnByZVJ1bi5sZW5ndGg7KUk9QS5wcmVSdW4uc2hpZnQoKSxVLnVuc2hpZnQoSSk7dmFyIEk7TShVKX0oKSxLPjB8fChBLnNldFN0YXR1cz8oQS5zZXRTdGF0dXMoXCJSdW5uaW5nLi4uXCIpLHNldFRpbWVvdXQoKGZ1bmN0aW9uKCl7c2V0VGltZW91dCgoZnVuY3Rpb24oKXtBLnNldFN0YXR1cyhcIlwiKX0pLDEpLGcoKX0pLDEpKTpnKCkpKX1pZihBLl9oMjY0YnNkSW5pdD1mdW5jdGlvbigpe3JldHVybihBLl9oMjY0YnNkSW5pdD1BLmFzbS5kKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LEEuX21hbGxvYz1mdW5jdGlvbigpe3JldHVybihBLl9tYWxsb2M9QS5hc20uZSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxBLl9mcmVlPWZ1bmN0aW9uKCl7cmV0dXJuKEEuX2ZyZWU9QS5hc20uZikuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxBLl9oMjY0YnNkRGVjb2RlPWZ1bmN0aW9uKCl7cmV0dXJuKEEuX2gyNjRic2REZWNvZGU9QS5hc20uZykuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxBLl9oMjY0YnNkU2h1dGRvd249ZnVuY3Rpb24oKXtyZXR1cm4oQS5faDI2NGJzZFNodXRkb3duPUEuYXNtLmgpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sQS5faDI2NGJzZEFsbG9jPWZ1bmN0aW9uKCl7cmV0dXJuKEEuX2gyNjRic2RBbGxvYz1BLmFzbS5pKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LEEuX2gyNjRic2RGcmVlPWZ1bmN0aW9uKCl7cmV0dXJuKEEuX2gyNjRic2RGcmVlPUEuYXNtLmopLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sQS5hc209bSxBLmdldFZhbHVlPWZ1bmN0aW9uKEEsSSxnKXtzd2l0Y2goXCIqXCI9PT0oST1JfHxcImk4XCIpLmNoYXJBdChJLmxlbmd0aC0xKSYmKEk9XCJpMzJcIiksSSl7Y2FzZVwiaTFcIjpjYXNlXCJpOFwiOnJldHVybiBTW0E+PjBdO2Nhc2VcImkxNlwiOnJldHVybiBOW0E+PjFdO2Nhc2VcImkzMlwiOmNhc2VcImk2NFwiOnJldHVybiB3W0E+PjJdO2Nhc2VcImZsb2F0XCI6cmV0dXJuIHlbQT4+Ml07Y2FzZVwiZG91YmxlXCI6cmV0dXJuIFJbQT4+M107ZGVmYXVsdDpjKFwiaW52YWxpZCB0eXBlIGZvciBnZXRWYWx1ZTogXCIrSSl9cmV0dXJuIG51bGx9LEEudGhlbj1mdW5jdGlvbihJKXtpZihXKUkoQSk7ZWxzZXt2YXIgZz1BLm9uUnVudGltZUluaXRpYWxpemVkO0Eub25SdW50aW1lSW5pdGlhbGl6ZWQ9ZnVuY3Rpb24oKXtnJiZnKCksSShBKX19cmV0dXJuIEF9LHQ9ZnVuY3Rpb24gQSgpe1d8fFgoKSxXfHwodD1BKX0sQS5ydW49WCxBLnByZUluaXQpZm9yKFwiZnVuY3Rpb25cIj09dHlwZW9mIEEucHJlSW5pdCYmKEEucHJlSW5pdD1bQS5wcmVJbml0XSk7QS5wcmVJbml0Lmxlbmd0aD4wOylBLnByZUluaXQucG9wKCkoKTtyZXR1cm4gWCgpLEF9KTtBLmV4cG9ydHM9Z30sMzQwOihBLEksZyk9PntcInVzZSBzdHJpY3RcIjtnLnIoSSksZy5kKEkse2luaXQ6KCk9Pm99KTt2YXIgQj1mdW5jdGlvbigpe2Z1bmN0aW9uIEEoQSxJKXt0aGlzLnRpbnlIMjY0TW9kdWxlPUEsdGhpcy5vblBpY3R1cmVSZWFkeT1JLHRoaXMucFN0b3JhZ2U9dGhpcy50aW55SDI2NE1vZHVsZS5faDI2NGJzZEFsbG9jKCksdGhpcy5wV2lkdGg9dGhpcy50aW55SDI2NE1vZHVsZS5fbWFsbG9jKDQpLHRoaXMucEhlaWdodD10aGlzLnRpbnlIMjY0TW9kdWxlLl9tYWxsb2MoNCksdGhpcy5wUGljdHVyZT10aGlzLnRpbnlIMjY0TW9kdWxlLl9tYWxsb2MoNCksdGhpcy5fZGVjQnVmZmVyPXRoaXMudGlueUgyNjRNb2R1bGUuX21hbGxvYygxMDQ4NTc2KSx0aGlzLnRpbnlIMjY0TW9kdWxlLl9oMjY0YnNkSW5pdCh0aGlzLnBTdG9yYWdlLDApfXZhciBJPUEucHJvdG90eXBlO3JldHVybiBJLnJlbGVhc2U9ZnVuY3Rpb24oKXt2YXIgQT10aGlzLnBTdG9yYWdlOzAhPT1BJiYodGhpcy50aW55SDI2NE1vZHVsZS5faDI2NGJzZFNodXRkb3duKEEpLHRoaXMudGlueUgyNjRNb2R1bGUuX2gyNjRic2RGcmVlKEEpKSx0aGlzLnRpbnlIMjY0TW9kdWxlLl9mcmVlKHRoaXMucFdpZHRoKSx0aGlzLnRpbnlIMjY0TW9kdWxlLl9mcmVlKHRoaXMucEhlaWdodCksdGhpcy50aW55SDI2NE1vZHVsZS5fZnJlZSh0aGlzLnBQaWN0dXJlKSx0aGlzLnBTdG9yYWdlPTAsdGhpcy5wV2lkdGg9MCx0aGlzLnBIZWlnaHQ9MH0sSS5kZWNvZGU9ZnVuY3Rpb24oSSl7aWYoSSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyJiYoST1uZXcgVWludDhBcnJheShJKSksdGhpcy50aW55SDI2NE1vZHVsZS5IRUFQVTguc2V0KEksdGhpcy5fZGVjQnVmZmVyKSx0aGlzLnRpbnlIMjY0TW9kdWxlLl9oMjY0YnNkRGVjb2RlKHRoaXMucFN0b3JhZ2UsdGhpcy5fZGVjQnVmZmVyLEkuYnl0ZUxlbmd0aCx0aGlzLnBQaWN0dXJlLHRoaXMucFdpZHRoLHRoaXMucEhlaWdodCk9PT1BLlBJQ19SRFkpe3ZhciBnPXRoaXMudGlueUgyNjRNb2R1bGUuZ2V0VmFsdWUodGhpcy5wV2lkdGgsXCJpMzJcIiksQj10aGlzLnRpbnlIMjY0TW9kdWxlLmdldFZhbHVlKHRoaXMucEhlaWdodCxcImkzMlwiKSxRPXRoaXMudGlueUgyNjRNb2R1bGUuZ2V0VmFsdWUodGhpcy5wUGljdHVyZSxcImk4KlwiKSxDPW5ldyBVaW50OEFycmF5KHRoaXMudGlueUgyNjRNb2R1bGUuSEVBUFU4LnN1YmFycmF5KFEsUStnKkIqMy8yKSk7dGhpcy5vblBpY3R1cmVSZWFkeShDLGcsQil9fSxBfSgpO0IuUkRZPTAsQi5QSUNfUkRZPTEsQi5IRFJTX1JEWT0yLEIuRVJST1I9MyxCLlBBUkFNX1NFVF9FUlJPUj00LEIuTUVNQUxMT0NfRVJST1I9NTtjb25zdCBRPUI7dmFyIEM9Zyg3MTkpLEU9Zy5uKEMpLGk9e1wiVGlueUgyNjQud2FzbVwiOlwiZGF0YTo7YmFzZTY0LEFHRnpiUUVBQUFBQmx3RVRZQUovZndGL1lBUi9mMzkvQVg5Z0FuOS9BR0FEZjM5L0FYOWdBWDhBWUFsL2YzOS9mMzkvZjM4QVlBRi9BWDlnQkg5L2YzOEFZQVovZjM5L2YzOEJmMkFJZjM5L2YzOS9mMzhBWUFOL2YzOEFZQVYvZjM5L2Z3Ri9ZQUFBWUFWL2YzOS9md0JnQm45L2YzOS9md0JnQ245L2YzOS9mMzkvZjM4QVlBQUJmMkFIZjM5L2YzOS9md0YvWUFoL2YzOS9mMzkvZndGL0FoMERBV0VCWVFBREFXRUJZZ0FHQVdFR2JXVnRiM0o1QWdHQUFvQ0FBZ05tWlFBQUJBQUJBd29CQmdBRkF3VUdCd0FIQmdBRERnTUhCd1VDQUFJREJBQUZCUVVGQ2dRQ0JBa0JCd0FEQmdZQ0FnRUdCQU1DQWdFTEFRRURBd3NOQWdFQUFBSUpDUWtQQWdVRkFBRUtBQklMRVFnSUJ3Z0lCd1FCQkFnSUJnRUVFQVFJQUFFTUJna0Jmd0ZCME1YQUFnc0hJUWdCWXdCbUFXUUFaQUZsQUFvQlpnQUVBV2NBWXdGb0FHSUJhUUJoQVdvQVlBckVxQVZsd0FJQkFuOGdBQkFQSWdKQmYwd0VRQ0FBUVFFUUN4b2dBVUVBTmdJQVFRQVBDd0pBQWtBZ0FrR0FnSUNBQkU4RVFDQUFRUU1RQzBGL1JnUkFRUUVQQ3lBQklBSkJIWFpCQVhGQkFXbzJBZ0FNQVFzZ0FrR0FnSUNBQWs4RVFDQUFRUVVRQzBGL1JnUkFRUUVQQ3lBQklBSkJHM1pCQTNGQkEybzJBZ0FNQVFzZ0FrR0FnSUNBQVU4RVFDQUFRUWNRQzBGL1JnUkFRUUVQQ3lBQklBSkJHWFpCQjNGQkIybzJBZ0FNQVFzZ0FoQXZJZ05CQkdvaUFrRWdSZ1JBSUFGQkFEWUNBQ0FBUVNBUUN4cEJBU0VDSUFCQkFSQURRUUZIRFFJZ0FCQVBJUU1nQUVFZ0VBdEJmMFlOQWlBRFFRRkxEUUlnQTBFQmF3UkFJQUZCZnpZQ0FBd0NDeUFCUVg4MkFnQkJBUThMSUFBZ0EwRUZhaEFMR2lBQUlBSVFBeUlBUVg5R0JFQkJBUThMSUFFZ0FFRi9JQUowUVg5emFqWUNBQXRCQUNFQ0N5QUNDNGdDQVFkL0lBQW9BZ1FoQkFKQUlBQW9BZ3hCQTNRaUJ5QUFLQUlRSWdocklnSkJJRTRFUUNBRUtBQUFJZ05CR0hRZ0EwRUlkRUdBZ1B3SGNYSWdBMEVJZGtHQS9nTnhJQU5CR0haeWNpRURJQUFvQWdnaUFrVU5BU0FESUFKMElBUXRBQVJCQ0NBQ2EzWnlJUU1NQVFzZ0FrRUJTQVJBREFFTElBUXRBQUFnQUNnQ0NDSUZRUmhxSWdaMElRTWdBaUFGYWtGNGFpSUNRUUZJRFFBRFFDQUVMUUFCSUFaQmVHb2lCblFnQTNJaEF5QUNRUWhLSVFVZ0JFRUJhaUVFSUFKQmVHb2hBaUFGRFFBTEN5QUFJQUVnQ0dvaUJEWUNFQ0FBSUFSQkIzRTJBZ2hCZnlFQ0lBUWdCMDBFZnlBQUlBQW9BZ0FnQkVFRGRtbzJBZ1FnQTBFZ0lBRnJkZ1ZCZndzTHFnMEJCMzhDUUNBQVJRMEFJQUJCZUdvaUF5QUFRWHhxS0FJQUlnRkJlSEVpQUdvaEJRSkFJQUZCQVhFTkFDQUJRUU54UlEwQklBTWdBeWdDQUNJQ2F5SURRY1RBQUNnQ0FDSUVTUTBCSUFBZ0Ftb2hBQ0FEUWNqQUFDZ0NBRWNFUUNBQ1FmOEJUUVJBSUFNb0FnZ2lCQ0FDUVFOMklnSkJBM1JCM01BQWFrY2FJQVFnQXlnQ0RDSUJSZ1JBUWJUQUFFRzB3QUFvQWdCQmZpQUNkM0UyQWdBTUF3c2dCQ0FCTmdJTUlBRWdCRFlDQ0F3Q0N5QURLQUlZSVFZQ1FDQURJQU1vQWd3aUFVY0VRQ0FFSUFNb0FnZ2lBazBFUUNBQ0tBSU1HZ3NnQWlBQk5nSU1JQUVnQWpZQ0NBd0JDd0pBSUFOQkZHb2lBaWdDQUNJRURRQWdBMEVRYWlJQ0tBSUFJZ1FOQUVFQUlRRU1BUXNEUUNBQ0lRY2dCQ0lCUVJScUlnSW9BZ0FpQkEwQUlBRkJFR29oQWlBQktBSVFJZ1FOQUFzZ0IwRUFOZ0lBQ3lBR1JRMEJBa0FnQXlBREtBSWNJZ0pCQW5SQjVNSUFhaUlFS0FJQVJnUkFJQVFnQVRZQ0FDQUJEUUZCdU1BQVFiakFBQ2dDQUVGK0lBSjNjVFlDQUF3REN5QUdRUkJCRkNBR0tBSVFJQU5HRzJvZ0FUWUNBQ0FCUlEwQ0N5QUJJQVkyQWhnZ0F5Z0NFQ0lDQkVBZ0FTQUNOZ0lRSUFJZ0FUWUNHQXNnQXlnQ0ZDSUNSUTBCSUFFZ0FqWUNGQ0FDSUFFMkFoZ01BUXNnQlNnQ0JDSUJRUU54UVFOSERRQkJ2TUFBSUFBMkFnQWdCU0FCUVg1eE5nSUVJQU1nQUVFQmNqWUNCQ0FBSUFOcUlBQTJBZ0FQQ3lBRklBTk5EUUFnQlNnQ0JDSUJRUUZ4UlEwQUFrQWdBVUVDY1VVRVFDQUZRY3pBQUNnQ0FFWUVRRUhNd0FBZ0F6WUNBRUhBd0FCQndNQUFLQUlBSUFCcUlnQTJBZ0FnQXlBQVFRRnlOZ0lFSUFOQnlNQUFLQUlBUncwRFFiekFBRUVBTmdJQVFjakFBRUVBTmdJQUR3c2dCVUhJd0FBb0FnQkdCRUJCeU1BQUlBTTJBZ0JCdk1BQVFiekFBQ2dDQUNBQWFpSUFOZ0lBSUFNZ0FFRUJjallDQkNBQUlBTnFJQUEyQWdBUEN5QUJRWGh4SUFCcUlRQUNRQ0FCUWY4QlRRUkFJQVVvQWd3aEFpQUZLQUlJSWdRZ0FVRURkaUlCUVFOMFFkekFBR29pQjBjRVFFSEV3QUFvQWdBYUN5QUNJQVJHQkVCQnRNQUFRYlRBQUNnQ0FFRitJQUYzY1RZQ0FBd0NDeUFDSUFkSEJFQkJ4TUFBS0FJQUdnc2dCQ0FDTmdJTUlBSWdCRFlDQ0F3QkN5QUZLQUlZSVFZQ1FDQUZJQVVvQWd3aUFVY0VRRUhFd0FBb0FnQWdCU2dDQ0NJQ1RRUkFJQUlvQWd3YUN5QUNJQUUyQWd3Z0FTQUNOZ0lJREFFTEFrQWdCVUVVYWlJQ0tBSUFJZ1FOQUNBRlFSQnFJZ0lvQWdBaUJBMEFRUUFoQVF3QkN3TkFJQUloQnlBRUlnRkJGR29pQWlnQ0FDSUVEUUFnQVVFUWFpRUNJQUVvQWhBaUJBMEFDeUFIUVFBMkFnQUxJQVpGRFFBQ1FDQUZJQVVvQWh3aUFrRUNkRUhrd2dCcUlnUW9BZ0JHQkVBZ0JDQUJOZ0lBSUFFTkFVRzR3QUJCdU1BQUtBSUFRWDRnQW5keE5nSUFEQUlMSUFaQkVFRVVJQVlvQWhBZ0JVWWJhaUFCTmdJQUlBRkZEUUVMSUFFZ0JqWUNHQ0FGS0FJUUlnSUVRQ0FCSUFJMkFoQWdBaUFCTmdJWUN5QUZLQUlVSWdKRkRRQWdBU0FDTmdJVUlBSWdBVFlDR0FzZ0F5QUFRUUZ5TmdJRUlBQWdBMm9nQURZQ0FDQURRY2pBQUNnQ0FFY05BVUc4d0FBZ0FEWUNBQThMSUFVZ0FVRitjVFlDQkNBRElBQkJBWEkyQWdRZ0FDQURhaUFBTmdJQUN5QUFRZjhCVFFSQUlBQkJBM1lpQVVFRGRFSGN3QUJxSVFBQ2YwRzB3QUFvQWdBaUFrRUJJQUYwSWdGeFJRUkFRYlRBQUNBQklBSnlOZ0lBSUFBTUFRc2dBQ2dDQ0FzaEFpQUFJQU0yQWdnZ0FpQUROZ0lNSUFNZ0FEWUNEQ0FESUFJMkFnZ1BDeUFEUWdBM0FoQWdBd0ovUVFBZ0FFRUlkaUlCUlEwQUdrRWZJQUJCLy8vL0Iwc05BQm9nQVNBQlFZRCtQMnBCRUhaQkNIRWlBWFFpQWlBQ1FZRGdIMnBCRUhaQkJIRWlBblFpQkNBRVFZQ0FEMnBCRUhaQkFuRWlCSFJCRDNZZ0FTQUNjaUFFY21zaUFVRUJkQ0FBSUFGQkZXcDJRUUZ4Y2tFY2Fnc2lBallDSENBQ1FRSjBRZVRDQUdvaEFRSkFBa0FDUUVHNHdBQW9BZ0FpQkVFQklBSjBJZ2R4UlFSQVFiakFBQ0FFSUFkeU5nSUFJQUVnQXpZQ0FDQURJQUUyQWhnTUFRc2dBRUVBUVJrZ0FrRUJkbXNnQWtFZlJodDBJUUlnQVNnQ0FDRUJBMEFnQVNJRUtBSUVRWGh4SUFCR0RRSWdBa0VkZGlFQklBSkJBWFFoQWlBRUlBRkJCSEZxSWdkQkVHb29BZ0FpQVEwQUN5QUhJQU0yQWhBZ0F5QUVOZ0lZQ3lBRElBTTJBZ3dnQXlBRE5nSUlEQUVMSUFRb0FnZ2lBQ0FETmdJTUlBUWdBellDQ0NBRFFRQTJBaGdnQXlBRU5nSU1JQU1nQURZQ0NBdEIxTUFBUWRUQUFDZ0NBRUYvYWlJQU5nSUFJQUFOQUVIOHd3QWhBd05BSUFNb0FnQWlBRUVJYWlFRElBQU5BQXRCMU1BQVFYODJBZ0FMQzNRQkFuOGpBRUVRYXlJQ0pBQWdBa0VBTmdJTUlBQWdBa0VNYWhBQ0lRQUNmeUFDS0FJTUlnTkJmMFlFUUVFQklBQkZEUUVhSUFGQmdJQ0FnSGcyQWdCQkFBd0JDMEVCSUFBTkFCb2dBU0FEUVFGcVFRRjJJZ0ZCQUNBQmF5QURRUUZ4R3pZQ0FFRUFDeUVBSUFKQkVHb2tBQ0FBQzdrTEFSUi9JQUZCb0QxcUxRQUFRUXhzSWdaQjFEeHFLQUlBSVFRZ0JrSFFQR29vQWdBZ0FVR1FQR290QUFBaUIzUWhCU0FDUlFSQUlBQWdBQ2dDQUNBRmJEWUNBQXNnQkNBSGRDRUJBa0FDUUNBRFFaei9BM0VFUUNBQUlBWkIyRHhxS0FJQUlBZDBJZ01nQUNnQ1BHdzJBandnQUNBQUtBSTRJQUZzTmdJNFFRRWhBaUFBSUFBb0Fpd2dCV3dpQnlBQUtBSU1JQVZzSWdScUlnd2dBQ2dDSUNBQmJDSU5JQUFvQWpRZ0FXd2lEa0VCZFdvaUVHc2lCallDTENBQUtBSW9JUkVnQUNBRUlBZHJJZ1FnRFVFQmRTQU9heUlOYXlJSE5nSW9JQUFvQWlRaENDQUFJQVFnRFdvaUJEWUNKQ0FBSUFBb0Fod2dBV3dpRGlBQUtBSUlJQUZzSWdwcUloSWdBQ2dDRUNBRGJDSVBJQUFvQWpBZ0Eyd2lDMEVCZFdvaUUyc2lEVFlDSENBQUtBSVlJUWtnQUNBS0lBNXJJZ29nRDBFQmRTQUxheUlQYXlJT05nSVlJQUFvQWhRaEN5QUFJQW9nRDJvaUNqWUNGQ0FBSUFVZ0Myd2lEeUFBS0FJQUlndHFJaFFnQUNnQ0JDQUJiQ0lWSUFFZ0NXd2lDVUVCZFdvaUZtc2lCVFlDRENBQUlBc2dEMnNpQ3lBVlFRRjFJQWxySWdscklnODJBZ2dnQUNBSklBdHFJZ3MyQWdRZ0FDQUJJQWhzSWdnZ0FDZ0NPQ0lKYXlJVklBTWdFV3dpRVVFQmRTQUFLQUk4SWhkcklnTnJJZ0UyQWpnZ0FDQURJQlZxSWdNMkFqUWdBQ0FJSUFscUlnZ2dGMEVCZFNBUmFpSUpheUlSTmdJOElBQWdGQ0FXYWlJVUlBd2dFR29pREd0QklHb2lFQ0FTSUJOcUloSkJBWFVnQ0NBSmFpSUlheUlUYTBFR2RTSUpOZ0lnSUFBZ0VDQVRha0VHZFNJUU5nSVFJQUFnRENBVWFrRWdhaUlNSUFoQkFYVWdFbW9pQ0d0QkJuVWlFallDTUNBQUlBZ2dER3BCQm5VaUREWUNBQ0FNUVlBRWFpQVFRWUFFYW5KQi93ZExEUUlnRWtHQUJHb2dDVUdBQkdweVFmOEhTdzBDSUFBZ0JDQUxha0VnYWlJTUlBTkJBWFVnQ21vaUVHdEJCblVpQ0RZQ05DQUFJQXNnQkd0QklHb2lCQ0FLUVFGMUlBTnJJZ05yUVFaMUlnbzJBaVFnQUNBRElBUnFRUVoxSWdNMkFoUWdBQ0FNSUJCcVFRWjFJZ1EyQWdRZ0JFR0FCR29nQTBHQUJHcHlRZjhIU3cwQ0lBaEJnQVJxSUFwQmdBUnFja0gvQjBzTkFpQUFJQWNnRDJwQklHb2lBeUFCUVFGMUlBNXFJZ1JyUVFaMUlnbzJBamdnQUNBUElBZHJRU0JxSWdjZ0RrRUJkU0FCYXlJQmEwRUdkU0lPTmdJb0lBQWdBU0FIYWtFR2RTSUJOZ0lZSUFBZ0F5QUVha0VHZFNJRE5nSUlJQU5CZ0FScUlBRkJnQVJxY2tIL0Iwc05BaUFLUVlBRWFpQU9RWUFFYW5KQi93ZExEUUlnQUNBRklBWnFRU0JxSWdFZ0VVRUJkU0FOYWlJRGEwRUdkU0lITmdJOElBQWdCU0FHYTBFZ2FpSUZJQTFCQVhVZ0VXc2lCbXRCQm5VaUJEWUNMQ0FBSUFVZ0JtcEJCblVpQlRZQ0hDQUFJQUVnQTJwQkJuVWlBRFlDRENBQVFZQUVhaUFGUVlBRWFuSkIvd2RMRFFJZ0IwR0FCR29nQkVHQUJHcHlRZjhIVFEwQkRBSUxJQU5CNGdCeFJRUkFRUUVoQWlBQUtBSUFRU0JxUVFaMUlnRkJnQVJxUWY4SFN3MENJQUFnQVRZQ09DQUFJQUUyQWp3Z0FDQUJOZ0kwSUFBZ0FUWUNNQ0FBSUFFMkFpd2dBQ0FCTmdJb0lBQWdBVFlDSkNBQUlBRTJBaUFnQUNBQk5nSWNJQUFnQVRZQ0dDQUFJQUUyQWhRZ0FDQUJOZ0lRSUFBZ0FUWUNEQ0FBSUFFMkFnZ2dBQ0FCTmdJRUlBQWdBVFlDQUF3QkMwRUJJUUlnQUNBQUtBSUVJQUZzSWdRZ0FDZ0NHQ0FCYkNJTlFRRjFhaUlESUFBb0FnQWlCaUFBS0FJVUlBVnNJZ2RxSWdWcVFTQnFRUVoxSWdFMkFqQWdBQ0FGSUFOclFTQnFRUVoxSWdNMkFnd2dBQ0FFUVFGMUlBMXJJZ1FnQmlBSGEycEJJR3BCQm5VaUJUWUNCQ0FBSUFFMkFnQWdBQ0FCTmdJZ0lBQWdCVFlDTkNBQUlBRTJBaEFnQUNBRk5nSWtJQUFnQlRZQ0ZDQUFJQU0yQWp3Z0FDQUdJQVFnQjJwclFTQnFRUVoxSWdZMkFnZ2dBQ0FHTmdJNElBQWdCallDS0NBQUlBWTJBaGdnQUNBRE5nSXNJQUFnQXpZQ0hDQURRWUFFYWlBQlFZQUVhaUFHUVlBRWFpQUZRWUFFYW5KeWNrSC9CMHNOQVF0QkFDRUNDeUFDQy9NQ0FnSi9BWDRDUUNBQ1JRMEFJQUFnQW1vaUEwRi9haUFCT2dBQUlBQWdBVG9BQUNBQ1FRTkpEUUFnQTBGK2FpQUJPZ0FBSUFBZ0FUb0FBU0FEUVgxcUlBRTZBQUFnQUNBQk9nQUNJQUpCQjBrTkFDQURRWHhxSUFFNkFBQWdBQ0FCT2dBRElBSkJDVWtOQUNBQVFRQWdBR3RCQTNFaUJHb2lBeUFCUWY4QmNVR0Jnb1FJYkNJQk5nSUFJQU1nQWlBRWEwRjhjU0lFYWlJQ1FYeHFJQUUyQWdBZ0JFRUpTUTBBSUFNZ0FUWUNDQ0FESUFFMkFnUWdBa0Y0YWlBQk5nSUFJQUpCZEdvZ0FUWUNBQ0FFUVJsSkRRQWdBeUFCTmdJWUlBTWdBVFlDRkNBRElBRTJBaEFnQXlBQk5nSU1JQUpCY0dvZ0FUWUNBQ0FDUVd4cUlBRTJBZ0FnQWtGb2FpQUJOZ0lBSUFKQlpHb2dBVFlDQUNBRUlBTkJCSEZCR0hJaUJHc2lBa0VnU1EwQUlBR3RJZ1ZDSUlZZ0JZUWhCU0FESUFScUlRRURRQ0FCSUFVM0F4Z2dBU0FGTndNUUlBRWdCVGNEQ0NBQklBVTNBd0FnQVVFZ2FpRUJJQUpCWUdvaUFrRWZTdzBBQ3dzZ0FBdnlBd0VEZnlBQktBSUFJZ05CLy8vL0IwY0VRQ0FCS0FJRUlRUWdBQ0FDSUFKQkEzRWdBa0VRU1NJQ0cwRUNkQ0lGUWZBcGFpZ0NBRUVRUVFnZ0Foc2lBbXhxSUFWQnNDbHFLQUlBYWlJQUlBTWdBQzBBQUdwQnNDNXFMUUFBT2dBQUlBRW9BZ2doQXlBQUlBUWdBQzBBQVdwQnNDNXFMUUFBT2dBQklBRW9BZ3doQkNBQUlBTWdBQzBBQW1wQnNDNXFMUUFBT2dBQ0lBQWdCQ0FBTFFBRGFrR3dMbW90QUFBNkFBTWdBU2dDRkNFRElBQWdBbW9pQUNBQktBSVFJQUF0QUFCcVFiQXVhaTBBQURvQUFDQUJLQUlZSVFRZ0FDQURJQUF0QUFGcVFiQXVhaTBBQURvQUFTQUJLQUljSVFNZ0FDQUVJQUF0QUFKcVFiQXVhaTBBQURvQUFpQUFJQU1nQUMwQUEycEJzQzVxTFFBQU9nQURJQUVvQWlRaEF5QUFJQUpxSWdBZ0FTZ0NJQ0FBTFFBQWFrR3dMbW90QUFBNkFBQWdBU2dDS0NFRUlBQWdBeUFBTFFBQmFrR3dMbW90QUFBNkFBRWdBU2dDTENFRElBQWdCQ0FBTFFBQ2FrR3dMbW90QUFBNkFBSWdBQ0FESUFBdEFBTnFRYkF1YWkwQUFEb0FBeUFCS0FJMElRTWdBQ0FDYWlJQUlBRW9BakFnQUMwQUFHcEJzQzVxTFFBQU9nQUFJQUVvQWpnaEFpQUFJQU1nQUMwQUFXcEJzQzVxTFFBQU9nQUJJQUVvQWp3aEFTQUFJQUlnQUMwQUFtcEJzQzVxTFFBQU9nQUNJQUFnQVNBQUxRQURha0d3TG1vdEFBQTZBQU1MQzlNUUFReC9Jd0JCZ0FGcklnb2tBQ0FBRUE4aEJFRUJJUVVDUUFKQUFuOGdBa0VCVFFSQUlBUkJBRWdOQWlBRVFSbDJRZjRBY1VHQUNHb2dCRUdBZ0lEZ0FFOE5BUm9nQkVFVmRrSCtEM0ZCd0FocUlBUkJnSUNBQ0U4TkFSb2dCRUVSZGtIKy93RnhRWkFKYWlBRVFZQ0FnQUZQRFFFYUlBUkJFSFpCQVhSQmtBcHFEQUVMSUFKQkEwMEVRQ0FFUVg5TUJFQkJBa0dpRUNBRVFZQ0FnSUFFY1JzaEJRd0RDeUFFUVJsMlFmNEFjVUhRQ21vZ0JFR0FnSUNBQVU4TkFSb2dCRUVXZGtIK0IzRkJrQXRxSUFSQmdJQ0FFRThOQVJvZ0JFRVJka0grL3dGeFFkQUxhZ3dCQ3lBQ1FRZE5CRUFnQkVFYWRpSUNRWGhxUVRoSkJFQWdBa0VCZEVIUURXb01BZ3NnQkVFVmRrSCtEM0ZCMEE1cURBRUxJQVJCR1haQi9nQnhRZEFRYWlBQ1FSQk5EUUFhSUFSQkhYWWlBZ1JBSUFKQkFYUkIwQkZxREFFTElBUkJGM1pCL2dOeFFlQVJhZ3N2QVFBaUJRMEFRUUVoQ3d3QkMwRUJJUXNnQlVFTGRpSUpJQU5MRFFCQklDQUZRUjl4SWdacklRSUNRQ0FKUlFSQURBRUxJQVFnQm5RaEJBSkFJQVZCQlhaQlAzRWlERVVFUUF3QkN5QUNJQXhKQkVBZ0FDQUdFQXRCZjBZTkF5QUFFQThoQkVFZ0lRSUxJQVFnREhRaEJrRUJJQXhCZjJwMElRY2dCRUVnSUF4cmRpRUVBMEFnQ2tGQWF5QUlRUUowYWtGL1FRRWdCQ0FIY1JzMkFnQWdDRUVCYWlFSUlBZEJBWFlpQncwQUN5QUNJQXhySVFJZ0JpRUVDeUFJSUFsSkJFQWdERUVEU1NJUElBVkIvNjhCUzNFaEJRTkFJQUpCRDAwRVFDQUFRU0FnQW1zUUMwRi9SZ1JBREFVTElBQVFEeUVFUVNBaEFndEJBQ0VHQWtBQ1FBSi9Ba0FnQkVFQVNBMEFRUUVoQmlBRVFmLy8vLzhEU3cwQVFRSWhCaUFFUWYvLy8vOEJTdzBBUVFNaEJpQUVRZi8vLy84QVN3MEFRUVFoQmlBRVFmLy8vejlMRFFCQkJTRUdJQVJCLy8vL0gwc05BRUVHSVFZZ0JFSC8vLzhQU3cwQVFRY2hCaUFFUWYvLy93ZExEUUJCQ0NFR0lBUkIvLy8vQTBzTkFFRUpJUVlnQkVILy8vOEJTdzBBUVFvaEJpQUVRZi8vL3dCTERRQkJDeUVHSUFSQi8vOC9TdzBBUVF3aEJpQUVRZi8vSDBzTkFFRU5JUVlnQkVILy93OUxEUUFDZndKQUlBUkIvLzhIVFFSQUlBUkJnSUI4Y1VHQWdBUkdEUUVNQ2dzZ0JVRUVJQVViSVFZZ0JFRVBkQ0VFUVE0aEJ5QUNRWEZxREFFTElBVkJBU0FGR3lFRklBUkJFSFFoQkVFTUlRWkJEeUVISUFKQmNHb0xJUUlnQnlBRmRDRUhJQVZGREFFTElBWWdCWFFoQjBFQklRNGdBaUFHUVFGcUlnWnJJUUlnQkNBR2RDRUVJQVZGRFFFZ0JTRUdRUUFMSVE0Z0FpQUdUd1IvSUFRRklBQkJJQ0FDYXhBTFFYOUdCRUFNQnd0QklDRUNJQUFRRHdzaERTQUNJQVpySVFJZ0RTQUdkQ0VFSUExQklDQUdhM1lnQjJvaEJ3d0JDMEVBSVFVTElBcEJRR3NnQ0VFQ2RHcEJBQ0FIUVFKcUlBY2dDQ0FNUmhzZ0J5QVBHeUlOUVFKcVFRRjJJZ1pySUFZZ0RVRUJjUnMyQWdCQkFTQUZJQTRiSWdVZ0JVRUdTU0FHUVFNZ0JVRi9hblJLY1dvaEJTQUlRUUZxSWdnZ0NVY05BQXNMUVFBaEJ3SkFJQWtnQTA4RVFFRUFJUWdNQVFzQ1FDQUNRUWhMQkVBZ0FpRUZEQUVMUVNBaEJTQUFRU0FnQW1zUUMwRi9SZzBESUFBUUR5RUVDd0pBQWtBQ2Z3SkFJQU5CQkVjRVFDQUpRWDlxSWdKQkRVc05Bd0pBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFJQUpCQVdzT0RRQUJBZ01FQlFZSENBa0tDd3dPQ3lBRVFScDJRZUFTYWd3T0N5QUVRUnAyUWFBVGFnd05DeUFFUVJ0MlFlQVRhZ3dNQ3lBRVFSdDJRWUFVYWd3TEN5QUVRUnAyUWFBVWFnd0tDeUFFUVJwMlFlQVVhZ3dKQ3lBRVFScDJRYUFWYWd3SUN5QUVRUnAyUWVBVmFnd0hDeUFFUVJ0MlFhQVdhZ3dHQ3lBRVFSeDJRY0FXYWd3RkN5QUVRUngyUWRBV2Fnd0VDeUFFUVIxMlFlQVdhZ3dEQ3lBRVFSNTJRZWdXYWd3Q0N5QUVRUUJJQkVCQkFTRUNEQVFMUVJFaEFpQUpRUU5HRFFOQkVpRUNJQVJCLy8vLy93TkxEUU5CSWlFQ0lBbEJBa1lOQTBFalFUTWdCRUgvLy8vL0FVc2JJUUlNQXdzZ0JFRWJka0dnRW1vZ0JFRVhka0hBRW1vZ0JFSC8vLy8vQUVzYkN5MEFBQ0lDRFFFTUJBdEJFVUVCSUFSQkFFZ2JJUUlMSUFKQkJIWWhDQ0FGSUFKQkQzRWlBMnNoQWlBRUlBTjBJUVFMSUFsQmYyb2lBd1JBQTBBQ2Z5QUlCRUFnQWtFS1RRUkFJQUJCSUNBQ2F4QUxRWDlHQkVBTUJ3c2dBQkFQSVFSQklDRUNDd0pBQW44Q1FDQUlRWDlxSWdWQkJVMEVRQUpBQWtBQ1FBSkFBa0FnQlVFQmF3NEZBQUVDQXdRR0N5QUVRUjUyUWU0V2Fnd0dDeUFFUVI1MlFmSVdhZ3dGQ3lBRVFSMTJRZllXYWd3RUN5QUVRUjEyUWY0V2Fnd0RDeUFFUVIxMlFZWVhhZ3dDQ3dKL1FmTUFJQVJCR1haQjhBQnhheUFFUVlDQWdJQUNUdzBBR2tIMEFDQUVRZi8vLy84QVN3MEFHa0dGQVNBRVFmLy8vejlMRFFBYVFaWUJJQVJCLy8vL0gwc05BQnBCcHdFZ0JFSC8vLzhQU3cwQUdrRzRBU0FFUWYvLy93ZExEUUFhUWNrQklBUkIvLy8vQTBzTkFCcEIyZ0VnQkVILy8vOEJTdzBBR2tFQVFlc0JJQVJCZ0lDQUFVa2JDeUlGUVFSMklBaE5EUUlNQ0FzZ0JFRWZka0hzRm1vTExRQUFJUVVMSUFWRkJFQU1CZ3NnQ2lBSFFRSjBhaUFGUVFSMklnWkJBV28yQWdBZ0FpQUZRUTl4SWdWcklRSWdCQ0FGZENFRUlBZ2dCbXNNQVFzZ0NpQUhRUUowYWtFQk5nSUFRUUFMSVFnZ0IwRUJhaUlISUFOSERRQUxJQUVnQ0VFQ2RHb2dDa0ZBYXlBRFFRSjBhaWdDQURZQ0FDQUpRWDVxSVFWQkFTQUlkQ0VIQTBBZ0FTQUtJQVVpQTBFQ2RDSUZhaWdDQUNBSWFpSUlRUUowYWlBS1FVQnJJQVZxS0FJQU5nSUFJQU5CZjJvaEJVRUJJQWgwSUFkeUlRY2dBdzBBQ3d3QkN5QUJJQWhCQW5ScUlBcEJRR3NnQTBFQ2RHb29BZ0EyQWdCQkFTQUlkQ0VIQ3lBQVFTQWdBbXNRQ3cwQUlBZEJFSFFnQ1VFRWRISWhDd3NnQ2tHQUFXb2tBQ0FMQzgwdUFRdC9Jd0JCRUdzaUN5UUFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUNBQVFmUUJUUVJBUWJUQUFDZ0NBQ0lHUVJBZ0FFRUxha0Y0Y1NBQVFRdEpHeUlGUVFOMklnQjJJZ0ZCQTNFRVFDQUJRWDl6UVFGeElBQnFJZ0pCQTNRaUJFSGt3QUJxS0FJQUlnRkJDR29oQUFKQUlBRW9BZ2dpQXlBRVFkekFBR29pQkVZRVFFRzB3QUFnQmtGK0lBSjNjVFlDQUF3QkMwSEV3QUFvQWdBYUlBTWdCRFlDRENBRUlBTTJBZ2dMSUFFZ0FrRURkQ0lDUVFOeU5nSUVJQUVnQW1vaUFTQUJLQUlFUVFGeU5nSUVEQXdMSUFWQnZNQUFLQUlBSWdoTkRRRWdBUVJBQWtCQkFpQUFkQ0lDUVFBZ0FtdHlJQUVnQUhSeElnQkJBQ0FBYTNGQmYyb2lBQ0FBUVF4MlFSQnhJZ0IySWdGQkJYWkJDSEVpQWlBQWNpQUJJQUoySWdCQkFuWkJCSEVpQVhJZ0FDQUJkaUlBUVFGMlFRSnhJZ0Z5SUFBZ0FYWWlBRUVCZGtFQmNTSUJjaUFBSUFGMmFpSUNRUU4wSWdOQjVNQUFhaWdDQUNJQktBSUlJZ0FnQTBIY3dBQnFJZ05HQkVCQnRNQUFJQVpCZmlBQ2QzRWlCallDQUF3QkMwSEV3QUFvQWdBYUlBQWdBellDRENBRElBQTJBZ2dMSUFGQkNHb2hBQ0FCSUFWQkEzSTJBZ1FnQVNBRmFpSUhJQUpCQTNRaUFpQUZheUlEUVFGeU5nSUVJQUVnQW1vZ0F6WUNBQ0FJQkVBZ0NFRURkaUlFUVFOMFFkekFBR29oQVVISXdBQW9BZ0FoQWdKL0lBWkJBU0FFZENJRWNVVUVRRUcwd0FBZ0JDQUdjallDQUNBQkRBRUxJQUVvQWdnTElRUWdBU0FDTmdJSUlBUWdBallDRENBQ0lBRTJBZ3dnQWlBRU5nSUlDMEhJd0FBZ0J6WUNBRUc4d0FBZ0F6WUNBQXdNQzBHNHdBQW9BZ0FpQ2tVTkFTQUtRUUFnQ210eFFYOXFJZ0FnQUVFTWRrRVFjU0lBZGlJQlFRVjJRUWh4SWdJZ0FISWdBU0FDZGlJQVFRSjJRUVJ4SWdGeUlBQWdBWFlpQUVFQmRrRUNjU0lCY2lBQUlBRjJJZ0JCQVhaQkFYRWlBWElnQUNBQmRtcEJBblJCNU1JQWFpZ0NBQ0lCS0FJRVFYaHhJQVZySVFNZ0FTRUNBMEFDUUNBQ0tBSVFJZ0JGQkVBZ0FpZ0NGQ0lBUlEwQkN5QUFLQUlFUVhoeElBVnJJZ0lnQXlBQ0lBTkpJZ0liSVFNZ0FDQUJJQUliSVFFZ0FDRUNEQUVMQ3lBQktBSVlJUWtnQVNBQktBSU1JZ1JIQkVCQnhNQUFLQUlBSUFFb0FnZ2lBRTBFUUNBQUtBSU1HZ3NnQUNBRU5nSU1JQVFnQURZQ0NBd0xDeUFCUVJScUlnSW9BZ0FpQUVVRVFDQUJLQUlRSWdCRkRRTWdBVUVRYWlFQ0N3TkFJQUloQnlBQUlnUkJGR29pQWlnQ0FDSUFEUUFnQkVFUWFpRUNJQVFvQWhBaUFBMEFDeUFIUVFBMkFnQU1DZ3RCZnlFRklBQkJ2MzlMRFFBZ0FFRUxhaUlBUVhoeElRVkJ1TUFBS0FJQUlnZEZEUUJCQUNBRmF5RUNBa0FDUUFKQUFuOUJBQ0FBUVFoMklnQkZEUUFhUVI4Z0JVSC8vLzhIU3cwQUdpQUFJQUJCZ1A0L2FrRVFka0VJY1NJQWRDSUJJQUZCZ09BZmFrRVFka0VFY1NJQmRDSURJQU5CZ0lBUGFrRVFka0VDY1NJRGRFRVBkaUFBSUFGeUlBTnlheUlBUVFGMElBVWdBRUVWYW5aQkFYRnlRUnhxQ3lJSVFRSjBRZVRDQUdvb0FnQWlBMFVFUUVFQUlRQU1BUXNnQlVFQVFSa2dDRUVCZG1zZ0NFRWZSaHQwSVFGQkFDRUFBMEFDUUNBREtBSUVRWGh4SUFWcklnWWdBazhOQUNBRElRUWdCaUlDRFFCQkFDRUNJQU1oQUF3REN5QUFJQU1vQWhRaUJpQUdJQU1nQVVFZGRrRUVjV29vQWhBaUEwWWJJQUFnQmhzaEFDQUJJQU5CQUVkMElRRWdBdzBBQ3dzZ0FDQUVja1VFUUVFQ0lBaDBJZ0JCQUNBQWEzSWdCM0VpQUVVTkF5QUFRUUFnQUd0eFFYOXFJZ0FnQUVFTWRrRVFjU0lBZGlJQlFRVjJRUWh4SWdNZ0FISWdBU0FEZGlJQVFRSjJRUVJ4SWdGeUlBQWdBWFlpQUVFQmRrRUNjU0lCY2lBQUlBRjJJZ0JCQVhaQkFYRWlBWElnQUNBQmRtcEJBblJCNU1JQWFpZ0NBQ0VBQ3lBQVJRMEJDd05BSUFBb0FnUkJlSEVnQldzaUF5QUNTU0VCSUFNZ0FpQUJHeUVDSUFBZ0JDQUJHeUVFSUFBb0FoQWlBUVIvSUFFRklBQW9BaFFMSWdBTkFBc0xJQVJGRFFBZ0FrRzh3QUFvQWdBZ0JXdFBEUUFnQkNnQ0dDRUlJQVFnQkNnQ0RDSUJSd1JBUWNUQUFDZ0NBQ0FFS0FJSUlnQk5CRUFnQUNnQ0RCb0xJQUFnQVRZQ0RDQUJJQUEyQWdnTUNRc2dCRUVVYWlJREtBSUFJZ0JGQkVBZ0JDZ0NFQ0lBUlEwRElBUkJFR29oQXdzRFFDQURJUVlnQUNJQlFSUnFJZ01vQWdBaUFBMEFJQUZCRUdvaEF5QUJLQUlRSWdBTkFBc2dCa0VBTmdJQURBZ0xRYnpBQUNnQ0FDSUJJQVZQQkVCQnlNQUFLQUlBSVFBQ1FDQUJJQVZySWdKQkVFOEVRRUc4d0FBZ0FqWUNBRUhJd0FBZ0FDQUZhaUlETmdJQUlBTWdBa0VCY2pZQ0JDQUFJQUZxSUFJMkFnQWdBQ0FGUVFOeU5nSUVEQUVMUWNqQUFFRUFOZ0lBUWJ6QUFFRUFOZ0lBSUFBZ0FVRURjallDQkNBQUlBRnFJZ0VnQVNnQ0JFRUJjallDQkFzZ0FFRUlhaUVBREFvTFFjREFBQ2dDQUNJQklBVkxCRUJCd01BQUlBRWdCV3NpQVRZQ0FFSE13QUJCek1BQUtBSUFJZ0FnQldvaUFqWUNBQ0FDSUFGQkFYSTJBZ1FnQUNBRlFRTnlOZ0lFSUFCQkNHb2hBQXdLQzBFQUlRQWdCVUV2YWlJRUFuOUJqTVFBS0FJQUJFQkJsTVFBS0FJQURBRUxRWmpFQUVKL053SUFRWkRFQUVLQW9JQ0FnSUFFTndJQVFZekVBQ0FMUVF4cVFYQnhRZGlxMWFvRmN6WUNBRUdneEFCQkFEWUNBRUh3d3dCQkFEWUNBRUdBSUFzaUFtb2lCa0VBSUFKcklnZHhJZ0lnQlUwTkNVSHN3d0FvQWdBaUF3UkFRZVREQUNnQ0FDSUlJQUpxSWdrZ0NFME5DaUFKSUFOTERRb0xRZkREQUMwQUFFRUVjUTBFQWtBQ1FFSE13QUFvQWdBaUF3UkFRZlREQUNFQUEwQWdBQ2dDQUNJSUlBTk5CRUFnQ0NBQUtBSUVhaUFEU3cwREN5QUFLQUlJSWdBTkFBc0xRUUFRRXlJQlFYOUdEUVVnQWlFR1FaREVBQ2dDQUNJQVFYOXFJZ01nQVhFRVFDQUNJQUZySUFFZ0EycEJBQ0FBYTNGcUlRWUxJQVlnQlUwTkJTQUdRZjcvLy84SFN3MEZRZXpEQUNnQ0FDSUFCRUJCNU1NQUtBSUFJZ01nQm1vaUJ5QURUUTBHSUFjZ0FFc05CZ3NnQmhBVElnQWdBVWNOQVF3SEN5QUdJQUZySUFkeElnWkIvdi8vL3dkTERRUWdCaEFUSWdFZ0FDZ0NBQ0FBS0FJRWFrWU5BeUFCSVFBTEFrQWdCVUV3YWlBR1RRMEFJQUJCZjBZTkFFR1V4QUFvQWdBaUFTQUVJQVpyYWtFQUlBRnJjU0lCUWY3Ly8vOEhTd1JBSUFBaEFRd0hDeUFCRUJOQmYwY0VRQ0FCSUFacUlRWWdBQ0VCREFjTFFRQWdCbXNRRXhvTUJBc2dBQ0lCUVg5SERRVU1Bd3RCQUNFRURBY0xRUUFoQVF3RkN5QUJRWDlIRFFJTFFmRERBRUh3d3dBb0FnQkJCSEkyQWdBTElBSkIvdi8vL3dkTERRRWdBaEFUSWdGQkFCQVRJZ0JQRFFFZ0FVRi9SZzBCSUFCQmYwWU5BU0FBSUFGcklnWWdCVUVvYWswTkFRdEI1TU1BUWVUREFDZ0NBQ0FHYWlJQU5nSUFJQUJCNk1NQUtBSUFTd1JBUWVqREFDQUFOZ0lBQ3dKQUFrQUNRRUhNd0FBb0FnQWlBd1JBUWZUREFDRUFBMEFnQVNBQUtBSUFJZ0lnQUNnQ0JDSUVha1lOQWlBQUtBSUlJZ0FOQUFzTUFndEJ4TUFBS0FJQUlnQkJBQ0FCSUFCUEcwVUVRRUhFd0FBZ0FUWUNBQXRCQUNFQVFmakRBQ0FHTmdJQVFmVERBQ0FCTmdJQVFkVEFBRUYvTmdJQVFkakFBRUdNeEFBb0FnQTJBZ0JCZ01RQVFRQTJBZ0FEUUNBQVFRTjBJZ0pCNU1BQWFpQUNRZHpBQUdvaUF6WUNBQ0FDUWVqQUFHb2dBellDQUNBQVFRRnFJZ0JCSUVjTkFBdEJ3TUFBSUFaQldHb2lBRUY0SUFGclFRZHhRUUFnQVVFSWFrRUhjUnNpQW1zaUF6WUNBRUhNd0FBZ0FTQUNhaUlDTmdJQUlBSWdBMEVCY2pZQ0JDQUFJQUZxUVNnMkFnUkIwTUFBUVp6RUFDZ0NBRFlDQUF3Q0N5QUFMUUFNUVFoeERRQWdBU0FEVFEwQUlBSWdBMHNOQUNBQUlBUWdCbW8yQWdSQnpNQUFJQU5CZUNBRGEwRUhjVUVBSUFOQkNHcEJCM0ViSWdCcUlnRTJBZ0JCd01BQVFjREFBQ2dDQUNBR2FpSUNJQUJySWdBMkFnQWdBU0FBUVFGeU5nSUVJQUlnQTJwQktEWUNCRUhRd0FCQm5NUUFLQUlBTmdJQURBRUxJQUZCeE1BQUtBSUFJZ1JKQkVCQnhNQUFJQUUyQWdBZ0FTRUVDeUFCSUFacUlRSkI5TU1BSVFBQ1FBSkFBa0FDUUFKQUFrQURRQ0FDSUFBb0FnQkhCRUFnQUNnQ0NDSUFEUUVNQWdzTElBQXRBQXhCQ0hGRkRRRUxRZlREQUNFQUEwQWdBQ2dDQUNJQ0lBTk5CRUFnQWlBQUtBSUVhaUlFSUFOTERRTUxJQUFvQWdnaEFBd0FBQXNBQ3lBQUlBRTJBZ0FnQUNBQUtBSUVJQVpxTmdJRUlBRkJlQ0FCYTBFSGNVRUFJQUZCQ0dwQkIzRWJhaUlKSUFWQkEzSTJBZ1FnQWtGNElBSnJRUWR4UVFBZ0FrRUlha0VIY1J0cUlnRWdDV3NnQldzaEFDQUZJQWxxSVFjZ0FTQURSZ1JBUWN6QUFDQUhOZ0lBUWNEQUFFSEF3QUFvQWdBZ0FHb2lBRFlDQUNBSElBQkJBWEkyQWdRTUF3c2dBVUhJd0FBb0FnQkdCRUJCeU1BQUlBYzJBZ0JCdk1BQVFiekFBQ2dDQUNBQWFpSUFOZ0lBSUFjZ0FFRUJjallDQkNBQUlBZHFJQUEyQWdBTUF3c2dBU2dDQkNJQ1FRTnhRUUZHQkVBZ0FrRjRjU0VLQWtBZ0FrSC9BVTBFUUNBQktBSUlJZ01nQWtFRGRpSUVRUU4wUWR6QUFHcEhHaUFESUFFb0Fnd2lBa1lFUUVHMHdBQkJ0TUFBS0FJQVFYNGdCSGR4TmdJQURBSUxJQU1nQWpZQ0RDQUNJQU0yQWdnTUFRc2dBU2dDR0NFSUFrQWdBU0FCS0FJTUlnWkhCRUFnQkNBQktBSUlJZ0pOQkVBZ0FpZ0NEQm9MSUFJZ0JqWUNEQ0FHSUFJMkFnZ01BUXNDUUNBQlFSUnFJZ01vQWdBaUJRMEFJQUZCRUdvaUF5Z0NBQ0lGRFFCQkFDRUdEQUVMQTBBZ0F5RUNJQVVpQmtFVWFpSURLQUlBSWdVTkFDQUdRUkJxSVFNZ0JpZ0NFQ0lGRFFBTElBSkJBRFlDQUFzZ0NFVU5BQUpBSUFFZ0FTZ0NIQ0lDUVFKMFFlVENBR29pQXlnQ0FFWUVRQ0FESUFZMkFnQWdCZzBCUWJqQUFFRzR3QUFvQWdCQmZpQUNkM0UyQWdBTUFnc2dDRUVRUVJRZ0NDZ0NFQ0FCUmh0cUlBWTJBZ0FnQmtVTkFRc2dCaUFJTmdJWUlBRW9BaEFpQWdSQUlBWWdBallDRUNBQ0lBWTJBaGdMSUFFb0FoUWlBa1VOQUNBR0lBSTJBaFFnQWlBR05nSVlDeUFCSUFwcUlRRWdBQ0FLYWlFQUN5QUJJQUVvQWdSQmZuRTJBZ1FnQnlBQVFRRnlOZ0lFSUFBZ0Iyb2dBRFlDQUNBQVFmOEJUUVJBSUFCQkEzWWlBVUVEZEVIY3dBQnFJUUFDZjBHMHdBQW9BZ0FpQWtFQklBRjBJZ0Z4UlFSQVFiVEFBQ0FCSUFKeU5nSUFJQUFNQVFzZ0FDZ0NDQXNoQVNBQUlBYzJBZ2dnQVNBSE5nSU1JQWNnQURZQ0RDQUhJQUUyQWdnTUF3c2dCd0ovUVFBZ0FFRUlkaUlCUlEwQUdrRWZJQUJCLy8vL0Iwc05BQm9nQVNBQlFZRCtQMnBCRUhaQkNIRWlBWFFpQWlBQ1FZRGdIMnBCRUhaQkJIRWlBblFpQXlBRFFZQ0FEMnBCRUhaQkFuRWlBM1JCRDNZZ0FTQUNjaUFEY21zaUFVRUJkQ0FBSUFGQkZXcDJRUUZ4Y2tFY2Fnc2lBVFlDSENBSFFnQTNBaEFnQVVFQ2RFSGt3Z0JxSVFJQ1FFRzR3QUFvQWdBaUEwRUJJQUYwSWdSeFJRUkFRYmpBQUNBRElBUnlOZ0lBSUFJZ0J6WUNBQXdCQ3lBQVFRQkJHU0FCUVFGMmF5QUJRUjlHRzNRaEF5QUNLQUlBSVFFRFFDQUJJZ0lvQWdSQmVIRWdBRVlOQXlBRFFSMTJJUUVnQTBFQmRDRURJQUlnQVVFRWNXb2lCQ2dDRUNJQkRRQUxJQVFnQnpZQ0VBc2dCeUFDTmdJWUlBY2dCellDRENBSElBYzJBZ2dNQWd0QndNQUFJQVpCV0dvaUFFRjRJQUZyUVFkeFFRQWdBVUVJYWtFSGNSc2lBbXNpQnpZQ0FFSE13QUFnQVNBQ2FpSUNOZ0lBSUFJZ0IwRUJjallDQkNBQUlBRnFRU2cyQWdSQjBNQUFRWnpFQUNnQ0FEWUNBQ0FESUFSQkp5QUVhMEVIY1VFQUlBUkJXV3BCQjNFYmFrRlJhaUlBSUFBZ0EwRVFha2tiSWdKQkd6WUNCQ0FDUWZ6REFDa0NBRGNDRUNBQ1FmVERBQ2tDQURjQ0NFSDh3d0FnQWtFSWFqWUNBRUg0d3dBZ0JqWUNBRUgwd3dBZ0FUWUNBRUdBeEFCQkFEWUNBQ0FDUVJocUlRQURRQ0FBUVFjMkFnUWdBRUVJYWlFQklBQkJCR29oQUNBRUlBRkxEUUFMSUFJZ0EwWU5BeUFDSUFJb0FnUkJmbkUyQWdRZ0F5QUNJQU5ySWdSQkFYSTJBZ1FnQWlBRU5nSUFJQVJCL3dGTkJFQWdCRUVEZGlJQlFRTjBRZHpBQUdvaEFBSi9RYlRBQUNnQ0FDSUNRUUVnQVhRaUFYRkZCRUJCdE1BQUlBRWdBbkkyQWdBZ0FBd0JDeUFBS0FJSUN5RUJJQUFnQXpZQ0NDQUJJQU0yQWd3Z0F5QUFOZ0lNSUFNZ0FUWUNDQXdFQ3lBRFFnQTNBaEFnQXdKL1FRQWdCRUVJZGlJQVJRMEFHa0VmSUFSQi8vLy9CMHNOQUJvZ0FDQUFRWUQrUDJwQkVIWkJDSEVpQUhRaUFTQUJRWURnSDJwQkVIWkJCSEVpQVhRaUFpQUNRWUNBRDJwQkVIWkJBbkVpQW5SQkQzWWdBQ0FCY2lBQ2Ntc2lBRUVCZENBRUlBQkJGV3AyUVFGeGNrRWNhZ3NpQURZQ0hDQUFRUUowUWVUQ0FHb2hBUUpBUWJqQUFDZ0NBQ0lDUVFFZ0FIUWlCbkZGQkVCQnVNQUFJQUlnQm5JMkFnQWdBU0FETmdJQUlBTWdBVFlDR0F3QkN5QUVRUUJCR1NBQVFRRjJheUFBUVI5R0czUWhBQ0FCS0FJQUlRRURRQ0FCSWdJb0FnUkJlSEVnQkVZTkJDQUFRUjEySVFFZ0FFRUJkQ0VBSUFJZ0FVRUVjV29pQmlnQ0VDSUJEUUFMSUFZZ0F6WUNFQ0FESUFJMkFoZ0xJQU1nQXpZQ0RDQURJQU0yQWdnTUF3c2dBaWdDQ0NJQUlBYzJBZ3dnQWlBSE5nSUlJQWRCQURZQ0dDQUhJQUkyQWd3Z0J5QUFOZ0lJQ3lBSlFRaHFJUUFNQlFzZ0FpZ0NDQ0lBSUFNMkFnd2dBaUFETmdJSUlBTkJBRFlDR0NBRElBSTJBZ3dnQXlBQU5nSUlDMEhBd0FBb0FnQWlBQ0FGVFEwQVFjREFBQ0FBSUFWcklnRTJBZ0JCek1BQVFjekFBQ2dDQUNJQUlBVnFJZ0kyQWdBZ0FpQUJRUUZ5TmdJRUlBQWdCVUVEY2pZQ0JDQUFRUWhxSVFBTUF3dEJzTUFBUVRBMkFnQkJBQ0VBREFJTEFrQWdDRVVOQUFKQUlBUW9BaHdpQUVFQ2RFSGt3Z0JxSWdNb0FnQWdCRVlFUUNBRElBRTJBZ0FnQVEwQlFiakFBQ0FIUVg0Z0FIZHhJZ2MyQWdBTUFnc2dDRUVRUVJRZ0NDZ0NFQ0FFUmh0cUlBRTJBZ0FnQVVVTkFRc2dBU0FJTmdJWUlBUW9BaEFpQUFSQUlBRWdBRFlDRUNBQUlBRTJBaGdMSUFRb0FoUWlBRVVOQUNBQklBQTJBaFFnQUNBQk5nSVlDd0pBSUFKQkQwMEVRQ0FFSUFJZ0JXb2lBRUVEY2pZQ0JDQUFJQVJxSWdBZ0FDZ0NCRUVCY2pZQ0JBd0JDeUFFSUFWQkEzSTJBZ1FnQkNBRmFpSURJQUpCQVhJMkFnUWdBaUFEYWlBQ05nSUFJQUpCL3dGTkJFQWdBa0VEZGlJQlFRTjBRZHpBQUdvaEFBSi9RYlRBQUNnQ0FDSUNRUUVnQVhRaUFYRkZCRUJCdE1BQUlBRWdBbkkyQWdBZ0FBd0JDeUFBS0FJSUN5RUJJQUFnQXpZQ0NDQUJJQU0yQWd3Z0F5QUFOZ0lNSUFNZ0FUWUNDQXdCQ3lBREFuOUJBQ0FDUVFoMklnQkZEUUFhUVI4Z0FrSC8vLzhIU3cwQUdpQUFJQUJCZ1A0L2FrRVFka0VJY1NJQWRDSUJJQUZCZ09BZmFrRVFka0VFY1NJQmRDSUZJQVZCZ0lBUGFrRVFka0VDY1NJRmRFRVBkaUFBSUFGeUlBVnlheUlBUVFGMElBSWdBRUVWYW5aQkFYRnlRUnhxQ3lJQU5nSWNJQU5DQURjQ0VDQUFRUUowUWVUQ0FHb2hBUUpBQWtBZ0IwRUJJQUIwSWdWeFJRUkFRYmpBQUNBRklBZHlOZ0lBSUFFZ0F6WUNBQXdCQ3lBQ1FRQkJHU0FBUVFGMmF5QUFRUjlHRzNRaEFDQUJLQUlBSVFVRFFDQUZJZ0VvQWdSQmVIRWdBa1lOQWlBQVFSMTJJUVVnQUVFQmRDRUFJQUVnQlVFRWNXb2lCaWdDRUNJRkRRQUxJQVlnQXpZQ0VBc2dBeUFCTmdJWUlBTWdBellDRENBRElBTTJBZ2dNQVFzZ0FTZ0NDQ0lBSUFNMkFnd2dBU0FETmdJSUlBTkJBRFlDR0NBRElBRTJBZ3dnQXlBQU5nSUlDeUFFUVFocUlRQU1BUXNDUUNBSlJRMEFBa0FnQVNnQ0hDSUFRUUowUWVUQ0FHb2lBaWdDQUNBQlJnUkFJQUlnQkRZQ0FDQUVEUUZCdU1BQUlBcEJmaUFBZDNFMkFnQU1BZ3NnQ1VFUVFSUWdDU2dDRUNBQlJodHFJQVEyQWdBZ0JFVU5BUXNnQkNBSk5nSVlJQUVvQWhBaUFBUkFJQVFnQURZQ0VDQUFJQVEyQWhnTElBRW9BaFFpQUVVTkFDQUVJQUEyQWhRZ0FDQUVOZ0lZQ3dKQUlBTkJEMDBFUUNBQklBTWdCV29pQUVFRGNqWUNCQ0FBSUFGcUlnQWdBQ2dDQkVFQmNqWUNCQXdCQ3lBQklBVkJBM0kyQWdRZ0FTQUZhaUlFSUFOQkFYSTJBZ1FnQXlBRWFpQUROZ0lBSUFnRVFDQUlRUU4ySWdWQkEzUkIzTUFBYWlFQVFjakFBQ2dDQUNFQ0FuOUJBU0FGZENJRklBWnhSUVJBUWJUQUFDQUZJQVp5TmdJQUlBQU1BUXNnQUNnQ0NBc2hCU0FBSUFJMkFnZ2dCU0FDTmdJTUlBSWdBRFlDRENBQ0lBVTJBZ2dMUWNqQUFDQUVOZ0lBUWJ6QUFDQUROZ0lBQ3lBQlFRaHFJUUFMSUF0QkVHb2tBQ0FBQzBRQkFYOGdBQ0FBS0FJUUlBRnFJZ0UyQWhBZ0FDQUJRUWR4TmdJSVFYOGhBaUFCSUFBb0FneEJBM1JOQkg4Z0FDQUFLQUlBSUFGQkEzWnFOZ0lFUVFBRlFYOExDK1VIQVFoL0lBQWdCRUVBSUFacklBSWdBaUFHYWtFQVNCc2lBaUFDSUFSS0d5SUNhaUFBSUFKQkFFb2JJZ2tnQlVFQUlBZHJJQU1nQXlBSGFrRUFTQnNpQUNBQUlBVktHeUlBSUFSc2FpQUpJQUJCQUVvYklRTWdCMEVBSUFCcklBQkJIM1Z4SWdscklBQWdCMm9pQUNBRmF5SU1RUUFnQUNBRlNoc2lEMnNoQ3lBR1FRQWdBbXNpRGlBQ1FSOTFjU0lOYXlBQ0lBWnFJZ0FnQkd0QkFDQUFJQVJLSWdVYklncHJJUUFDUUNBQ1FRQklJQVZ5SWhCRkJFQWdDUVJBQTBBZ0FTQURJQUFRRlNBSWFpRUJJQWxCZjJvaUNRMEFDd3NnQzBVTkFRTkFJQUVnQXlBQUVCVWdDR29oQVNBRElBUnFJUU1nQzBGL2FpSUxEUUFMREFFTEFrQWdDVVVOQUNBTlJRUkFBMEFnQUNFSElBRWhBaUFESVFVZ0FBUkFBMEFnQWlBRkxRQUFPZ0FBSUFKQkFXb2hBaUFGUVFGcUlRVWdCMEYvYWlJSERRQUxDeUFLQkVBZ0FpQUZRWDlxTFFBQUlBb1FCeG9MSUFFZ0NHb2hBU0FKUVg5cUlna05BQXdDQUFzQUN5QUJJQTVxSVFZRFFDQUJJQU10QUFBZ0RSQUhJUUVnQUNFSElBWWhBaUFESVFVZ0FBUkFBMEFnQWlBRkxRQUFPZ0FBSUFKQkFXb2hBaUFGUVFGcUlRVWdCMEYvYWlJSERRQUxDeUFLQkVBZ0FpQUZRWDlxTFFBQUlBb1FCeG9MSUFZZ0NHb2hCaUFCSUFocUlRRWdDVUYvYWlJSkRRQUxDeUFMUlEwQUlBMUZCRUFEUUNBQUlRY2dBU0VDSUFNaEJTQUFCRUFEUUNBQ0lBVXRBQUE2QUFBZ0FrRUJhaUVDSUFWQkFXb2hCU0FIUVg5cUlnY05BQXNMSUFvRVFDQUNJQVZCZjJvdEFBQWdDaEFIR2dzZ0FTQUlhaUVCSUFNZ0JHb2hBeUFMUVg5cUlnc05BQXdDQUFzQUN5QUJJQTVxSVFrRFFDQUJJQU10QUFBZ0RSQUhJUUVnQUNFSElBa2hBaUFESVFVZ0FBUkFBMEFnQWlBRkxRQUFPZ0FBSUFKQkFXb2hBaUFGUVFGcUlRVWdCMEYvYWlJSERRQUxDeUFLQkVBZ0FpQUZRWDlxTFFBQUlBb1FCeG9MSUFnZ0NXb2hDU0FCSUFocUlRRWdBeUFFYWlFRElBdEJmMm9pQ3cwQUN3c0NRQ0FQUlEwQUlBTWdCR3NoQXlBUVJRUkFBMEFnQVNBRElBQVFGU0FJYWlFQklBeEJmMm9pREEwQURBSUFDd0FMSUExRkJFQURRQ0FESVFJZ0FTRUZJQUFoQnlBQUJFQURRQ0FGSUFJdEFBQTZBQUFnQlVFQmFpRUZJQUpCQVdvaEFpQUhRWDlxSWdjTkFBc0xJQW9FUUNBRklBSkJmMm90QUFBZ0NoQUhHZ3NnQVNBSWFpRUJJQXhCZjJvaURBMEFEQUlBQ3dBTElBRWdEbW9oQ1FOQUlBRWdBeTBBQUNBTkVBY2hBU0FBSVFjZ0NTRUNJQU1oQlNBQUJFQURRQ0FDSUFVdEFBQTZBQUFnQWtFQmFpRUNJQVZCQVdvaEJTQUhRWDlxSWdjTkFBc0xJQW9FUUNBQ0lBVkJmMm90QUFBZ0NoQUhHZ3NnQ0NBSmFpRUpJQUVnQ0dvaEFTQU1RWDlxSWd3TkFBc0xDL1FDQVFOL0lBRkJBM1JCOERacUlnTW9BZ0FoQlNBRExRQUVJUU1nQVVFRGRFR3dOV29pQVMwQUJDRUVBa0FnQVNnQ0FFRUVSZ1JBSUFJZ0JFRUJkR291QVFBaEFTQUZRUVJHQkVBZ0FTQUNJQU5CQVhScUxnRUFha0VCYWtFQmRROExBbjhnQUNnQ3pBRWlBZ1JBSUFBb0FnUWdBaWdDQkVZTUFRdEJBQXRGRFFFZ0FTQUFLQUxNQVNBRFFRRjBhaTRCSEdwQkFXcEJBWFVQQ3lBRlFRUkdCRUFnQWlBRFFRRjBhaTRCQUNFQkFuOGdBQ2dDeUFFaUFnUkFJQUFvQWdRZ0FpZ0NCRVlNQVF0QkFBdEZEUUVnQVNBQUtBTElBU0FFUVFGMGFpNEJIR3BCQVdwQkFYVVBDd0ovQW44Z0FDZ0N5QUVpQVFSQUlBQW9BZ1FnQVNnQ0JFWU1BUXRCQUF0RkJFQkJBQ0VDUVFBTUFRdEJBU0VDSUFBb0FzZ0JJQVJCQVhScUxnRWNDeUVCQW44Z0FDZ0N6QUVpQkFSQUlBQW9BZ1FnQkNnQ0JFWU1BUXRCQUF0RkRRQWdBQ2dDekFFZ0EwRUJkR291QVJ3aEFDQUNSUVJBSUFBUEN5QUFJQUZxUVFGcVFRRjFJUUVMSUFFTGlRY0JCMzhnQXlBRmFpSU5JQUV1QVFBaURFRUNkV29oQXlBRUlBWnFJZzRnQVM0QkFpSVBRUUoxYWlFRUlBSW9BZ2hCQkhRaENTQUNLQUlFUVFSMElRb2dBQ0FHUVFSMGFpQUZhaUVMQWtBZ0RFRURjVUVFZENBUFFRTnhRUUowY2tIUU8yb29BZ0FpREVFT1RRUkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBSUF4QkFXc09EZ0VDQXdRRkJnY0lDUW9MREEwT0FBc2dBaWdDQUNBTElBTWdCQ0FLSUFrZ0J5QUlRUkFRREF3UEN5QUNLQUlBSUFzZ0F5QUVRWDVxSUFvZ0NTQUhJQWhCQUJBa0RBNExJQUlvQWdBZ0N5QURJQVJCZm1vZ0NpQUpJQWNnQ0JCSERBMExJQUlvQWdBZ0N5QURJQVJCZm1vZ0NpQUpJQWNnQ0VFQkVDUU1EQXNnQWlnQ0FDQUxJQU5CZm1vZ0JDQUtJQWtnQnlBSVFRQVFJd3dMQ3lBQ0tBSUFJQXNnQTBGK2FpQUVRWDVxSUFvZ0NTQUhJQWhCQUJBYURBb0xJQUlvQWdBZ0N5QURRWDVxSUFSQmZtb2dDaUFKSUFjZ0NFRUFFQ0VNQ1FzZ0FpZ0NBQ0FMSUFOQmZtb2dCRUYrYWlBS0lBa2dCeUFJUVFJUUdnd0lDeUFDS0FJQUlBc2dBMEYrYWlBRUlBb2dDU0FISUFnUVJnd0hDeUFDS0FJQUlBc2dBMEYrYWlBRVFYNXFJQW9nQ1NBSElBaEJBQkFpREFZTElBSW9BZ0FnQ3lBRFFYNXFJQVJCZm1vZ0NpQUpJQWNnQ0JCRkRBVUxJQUlvQWdBZ0N5QURRWDVxSUFSQmZtb2dDaUFKSUFjZ0NFRUJFQ0lNQkFzZ0FpZ0NBQ0FMSUFOQmZtb2dCQ0FLSUFrZ0J5QUlRUUVRSXd3REN5QUNLQUlBSUFzZ0EwRithaUFFUVg1cUlBb2dDU0FISUFoQkFSQWFEQUlMSUFJb0FnQWdDeUFEUVg1cUlBUkJmbW9nQ2lBSklBY2dDRUVCRUNFTUFRc2dBaWdDQUNBTElBTkJmbW9nQkVGK2FpQUtJQWtnQnlBSVFRTVFHZ3NnRFVFQmRpQUJMZ0VBSWdsQkEzVnFJUU1nRGtFQmRpQUJMZ0VDSWdGQkEzVnFJUVFnQWlnQ0FDQUNLQUlFSWdvZ0FpZ0NDQ0lMYkVFSWRHb2hBaUFBSUFaQkFuUkJlSEZxSUFWQkFYWnFRWUFDYWlFRklBaEJBWFloQmlBSFFRRjJJUWNnQVVFSGNTRUlJQXRCQTNRaEFDQUtRUU4wSVFFQ1FDQUpRUWR4SWdsRkRRQWdDRVVOQUNBQ0lBVWdBeUFFSUFFZ0FDQUpJQWdnQnlBR0VFZ1BDeUFKQkVBZ0FpQUZJQU1nQkNBQklBQWdDU0FISUFZUVN3OExJQWdFUUNBQ0lBVWdBeUFFSUFFZ0FDQUlJQWNnQmhCS0R3c2dBaUFGSUFNZ0JDQUJJQUFnQnlBR1FRZ1FEQ0FDSUFBZ0FXeHFJQVZCUUdzZ0F5QUVJQUVnQUNBSElBWkJDQkFNQzhjQkFRUi9JQUFvQWdRaEFnSkFJQUFvQWd4QkEzUWdBQ2dDRUdzaUEwRWdUZ1JBSUFJb0FBQWlBVUVZZENBQlFRaDBRWUNBL0FkeGNpQUJRUWgyUVlEK0EzRWdBVUVZZG5KeUlRRWdBQ2dDQ0NJQVJRMEJJQUVnQUhRZ0FpMEFCRUVJSUFCcmRuSVBDeUFEUVFGSUJFQkJBQThMSUFJdEFBQWdBQ2dDQ0NJQVFSaHFJZ1IwSVFFZ0FDQURha0Y0YWlJQVFRRklEUUFEUUNBQ0xRQUJJQVJCZUdvaUJIUWdBWEloQVNBQVFRaEtJUU1nQWtFQmFpRUNJQUJCZUdvaEFDQUREUUFMQ3lBQkM0d0VBUWQvQWtBZ0FFRi9haUlJTFFBQUlnVWdBQzBBQUNJR2F5SUVJQVJCSDNVaUJHb2dCSE1nQWlnQ0JFOE5BQ0FBUVg1cUxRQUFJZ1FnQldzaUJ5QUhRUjkxSWdkcUlBZHpJQUlvQWdnaUNVOE5BQ0FBTFFBQklnY2dCbXNpQ2lBS1FSOTFJZ3BxSUFweklBbFBEUUFnQVVFRFRRUkFJQWdnQlNBQklBSW9BZ0JxUVg5cUxRQUFJZ2hCZjNNaUNTQUlRUUZxSWdnZ0JpQUZhMEVDZENBSGF5QUVha0VFYWtFRGRTSUZJQVVnQ0VvYklBVWdDVWdiSWdWcVFiQXVhaTBBQURvQUFDQUFJQVlnQld0QnNDNXFMUUFBT2dBQURBRUxJQWdnQlNBSGFpQUVRUUYwYWtFQ2FrRUNkam9BQUNBQUlBWWdCMEVCZEdvZ0JHcEJBbXBCQW5ZNkFBQUxBa0FnQUNBRGFpSUFRWDlxSWdjdEFBQWlBeUFBTFFBQUlnVnJJZ1lnQmtFZmRTSUdhaUFHY3lBQ0tBSUVUdzBBSUFCQmZtb3RBQUFpQmlBRGF5SUVJQVJCSDNVaUJHb2dCSE1nQWlnQ0NDSUlUdzBBSUFBdEFBRWlCQ0FGYXlJSklBbEJIM1VpQ1dvZ0NYTWdDRThOQUNBQlFRTk5CRUFnQnlBQklBSW9BZ0JxUVg5cUxRQUFJZ0ZCZjNNaUFpQUJRUUZxSWdjZ0JTQURhMEVDZENBRWF5QUdha0VFYWtFRGRTSUJJQUVnQjBvYklBRWdBa2diSWdFZ0EycEJzQzVxTFFBQU9nQUFJQUFnQlNBQmEwR3dMbW90QUFBNkFBQVBDeUFISUFNZ0JHb2dCa0VCZEdwQkFtcEJBblk2QUFBZ0FDQUZJQVJCQVhScUlBWnFRUUpxUVFKMk9nQUFDd3RIQUFKQUlBRkJCRTBFUUFKQUFrQUNRQUpBSUFGQkFXc09CQUVDQXdVQUN5QUFLQUxJQVE4TElBQW9Bc3dCRHdzZ0FDZ0MwQUVQQ3lBQUtBTFVBUThMUVFBaEFBc2dBQXVsQXdFTGYwRUFJQU5ySWd0QkFYUWhCQ0FCSUFJb0FnQnFRWDlxTFFBQUlnRkJBV29oQ1NBQlFYOXpJUW9DUUNBQUlBTnJJZ2N0QUFBaUJTQUFMUUFBSWdacklnRWdBVUVmZFNJQmFpQUJjeUFDS0FJRUlnRlBEUUFnQUNBRWFpMEFBQ0lOSUFWcklnZ2dDRUVmZFNJSWFpQUljeUFDS0FJSUlnaFBEUUFnQUNBRGFpMEFBQ0lPSUFacklnd2dERUVmZFNJTWFpQU1jeUFJVHcwQUlBY2dDaUFKSUFZZ0JXdEJBblFnRG1zZ0RXcEJCR3BCQTNVaUFTQUJJQWxLR3lBQklBcElHeUlCSUFWcVFiQXVhaTBBQURvQUFDQUFJQVlnQVd0QnNDNXFMUUFBT2dBQUlBSW9BZ1FoQVFzQ1FDQUFRUUZxSWdVZ0Myb2lDeTBBQUNJR0lBQXRBQUVpQUdzaUJ5QUhRUjkxSWdkcUlBZHpJQUZQRFFBZ0JDQUZhaTBBQUNJQklBWnJJZ1FnQkVFZmRTSUVhaUFFY3lBQ0tBSUlJZ0pQRFFBZ0F5QUZhaTBBQUNJRElBQnJJZ1FnQkVFZmRTSUVhaUFFY3lBQ1R3MEFJQXNnQ2lBSklBQWdCbXRCQW5RZ0Eyc2dBV3BCQkdwQkEzVWlBU0FCSUFsS0d5QUJJQXBJR3lJQklBWnFRYkF1YWkwQUFEb0FBQ0FGSUFBZ0FXdEJzQzVxTFFBQU9nQUFDd3RWQVFKL1FiREVBQ2dDQUNJQklBQkJBMnBCZkhFaUFtb2hBQUpBSUFKQkFVNUJBQ0FBSUFGTkd3MEFJQUEvQUVFUWRFc0VRQ0FBRUFGRkRRRUxRYkRFQUNBQU5nSUFJQUVQQzBHd3dBQkJNRFlDQUVGL0N6UUJBWDhDUUNBQlFSQkxEUUFnQUNnQ0JDQUJRUUowYWlnQ0FDSUFSUTBBSUFBb0FoUkJBa2tOQUNBQUtBSUFJUUlMSUFJTGdnUUJBMzhnQWtHQUJFOEVRQ0FBSUFFZ0FoQUFHaUFBRHdzZ0FDQUNhaUVEQWtBZ0FDQUJjMEVEY1VVRVFBSkFJQUpCQVVnRVFDQUFJUUlNQVFzZ0FFRURjVVVFUUNBQUlRSU1BUXNnQUNFQ0EwQWdBaUFCTFFBQU9nQUFJQUZCQVdvaEFTQUNRUUZxSWdJZ0EwOE5BU0FDUVFOeERRQUxDd0pBSUFOQmZIRWlCRUhBQUVrTkFDQUNJQVJCUUdvaUJVc05BQU5BSUFJZ0FTZ0NBRFlDQUNBQ0lBRW9BZ1EyQWdRZ0FpQUJLQUlJTmdJSUlBSWdBU2dDRERZQ0RDQUNJQUVvQWhBMkFoQWdBaUFCS0FJVU5nSVVJQUlnQVNnQ0dEWUNHQ0FDSUFFb0FodzJBaHdnQWlBQktBSWdOZ0lnSUFJZ0FTZ0NKRFlDSkNBQ0lBRW9BaWcyQWlnZ0FpQUJLQUlzTmdJc0lBSWdBU2dDTURZQ01DQUNJQUVvQWpRMkFqUWdBaUFCS0FJNE5nSTRJQUlnQVNnQ1BEWUNQQ0FCUVVCcklRRWdBa0ZBYXlJQ0lBVk5EUUFMQ3lBQ0lBUlBEUUVEUUNBQ0lBRW9BZ0EyQWdBZ0FVRUVhaUVCSUFKQkJHb2lBaUFFU1EwQUN3d0JDeUFEUVFSSkJFQWdBQ0VDREFFTElBTkJmR29pQkNBQVNRUkFJQUFoQWd3QkN5QUFJUUlEUUNBQ0lBRXRBQUE2QUFBZ0FpQUJMUUFCT2dBQklBSWdBUzBBQWpvQUFpQUNJQUV0QUFNNkFBTWdBVUVFYWlFQklBSkJCR29pQWlBRVRRMEFDd3NnQWlBRFNRUkFBMEFnQWlBQkxRQUFPZ0FBSUFGQkFXb2hBU0FDUVFGcUlnSWdBMGNOQUFzTElBQUx3UmdCSUg4akFFSFFBMnNpQmlRQUlBRW9BZ2doRkNBQklBRW9BZ1FpQ2lBQ2JDSWFJQU5xRUIwZ0FTZ0NBQ0VKSUFCQkFEWUNDQ0FBUWlnM0FoUWdBRUlBTndJTUlBQkJCallDQUNBRFFRUjBJUWNDUUFKQUFrQWdCRUYrYWlJRVFRVkxEUUFDUUNBRVFRRnJEZ1FCQVFFQkFBc01BUXNnQmtFQU5nSU1JQVlnRkRZQ0dDQUdJQW8yQWhRZ0JpQUZOZ0lRSUFVRVFDQUdRZEFBYWlBR1FReHFJQVpCRUdvZ0J5QUNRUVIwUVFCQkFFRVFRUkFRRGd3Q0N3c2dCa0hRQUdwQkFFR0FBeEFIR2lBSklCcEJDSFJxSUFkcUlRd2dCa0lBTndOSUlBWkJRR3RDQURjREFDQUdRZ0EzQXpnZ0JrSUFOd013SUFaQ0FEY0RLQ0FHUWdBM0F5QWdCa0lBTndNWUlBWkNBRGNERUVFQUlRa0NmMEVBSUFKRkRRQWFRUUFnQUVFQUlBcHJRZGdCYkdvb0FzUUJSUTBBR2lBR0lBd2dDa0VFZEdzaUJDMEFCU0FFTFFBRWFpQUVMUUFHYWlBRUxRQUhhaUlYSUFRdEFBTWdCQzBBQWlBRUxRQUJJQVF0QUFCcWFtb2lGbW9pQlNBRUxRQUxJQVF0QUFvZ0JDMEFDU0FFTFFBSWFtcHFJaEpySUFRdEFBOGdCQzBBRGlBRUxRQU5JQVF0QUF4cWFtb2lFMnNpQ0RZQ0ZDQUdJQVVnRW1vZ0Uyb2lDVFlDRUVFQkN5RUZBbjhDUUNBQ0lCUkJmMnBIQkVBZ0FDQUtRZGdCYkdvb0FzUUJEUUVMSUFVTUFRc2dCaUFNSUFwQkNIUnFJZ0l0QUFVZ0FpMEFCR29nQWkwQUJtb2dBaTBBQjJvaUhpQUNMUUFESUFJdEFBSWdBaTBBQVNBQ0xRQUFhbXBxSWg5cUlnUWdBaTBBQ3lBQ0xRQUtJQUl0QUFrZ0FpMEFDR3BxYWlJWWF5QUNMUUFQSUFJdEFBNGdBaTBBRFNBQ0xRQU1hbXBxSWhscklBaHFJZ2cyQWhRZ0JpQUVJQmhxSUFscUlCbHFJZ2syQWhCQkFTRVFJQVZCQVdvTElRZEJBQ0VFQW44Q1FDQURSUTBBSUFCQmJHb29BZ0JGRFFBZ0JpQU1RWDlxSWdJZ0NrRUdkQ0lPYWlJRUlBcEJCSFFpQzJvdEFBQWdCQzBBQUdvZ0JDQUtRUVYwSWc5cUxRQUFhaUFFSUFwQk1Hd2lEV290QUFCcUloc2dBaUFOYWkwQUFDQUNJQTlxTFFBQUlBSWdDMm90QUFBZ0FpMEFBR3BxYWlJY2FpSVJJQVFnRG1vaUFpQUxhaTBBQUNBQ0xRQUFhaUFDSUE5cUxRQUFhaUFDSUExcUxRQUFhaUlWYXlBQ0lBNXFJZ0lnQzJvdEFBQWdBaTBBQUdvZ0FpQVBhaTBBQUdvZ0FpQU5haTBBQUdvaUQyc2lCRFlDSUNBR0lCRWdGV29nQ1dvZ0Qyb2lDVFlDRUNBSFFRRnFJUXRCQVF3QkN5QUhJUXRCQUFzaEFnSkFBa0FDUUFKQUFrQUNRQ0FESUFwQmYycEhCRUFnQUNnQ25BTU5BUXRCQUNFT0lBSkJBRWNoRVNBSERRRU1BZ3NnQmlBRUlBeEJFR29pQkNBS1FRWjBJaDFxSWdBZ0NrRUVkQ0lOYWkwQUFDQUFMUUFBYWlBQUlBcEJCWFFpRG1vdEFBQnFJQUFnQ2tFd2JDSVJhaTBBQUdvaUlDQUVJQkZxTFFBQUlBUWdEbW90QUFBZ0JDQU5haTBBQUNBTUxRQVFhbXBxSWlGcUlpSWdBQ0FkYWlJQUlBMXFMUUFBSUFBdEFBQnFJQUFnRG1vdEFBQnFJQUFnRVdvdEFBQnFJZ3hySUFBZ0hXb2lBQ0FOYWkwQUFDQUFMUUFBYWlBQUlBNXFMUUFBYWlBQUlCRnFMUUFBYWlJTmEyb2lCRFlDSUNBR0lBd2dJbW9nQ1dvZ0RXb2lDVFlDRUNBQ1FRQkhJUkZCQVNFT0lBSkJBV29oQUNBTFFRRnFJUXNDUUNBSERRQWdBa1VOQUNBR0lCc2dIR29nRldvZ0Qyb2dJV3NnSUdzZ0RHc2dEV3RCQlhVaUNEWUNGQXdEQ3lBSFJRMENJQUFoQWdzZ0JpQUlJQWRCQTJwMUlnZzJBaFFMQWtBZ0VFVU5BQ0FGUlEwQUlBSU5BQ0FHSUJZZ0Yyb2dFbW9nRTJvZ0dXc2dHR3NnSG1zZ0gydEJCWFVpQkRZQ0lFRUJJUkJCQVNFTkRBTUxJQkJCQUVjaEVDQUZRUUJISVEwZ0FrVU5BZ3dCQ3lBUVFRQkhJUkFnQlVFQVJ5RU5JQUFoQWdzZ0JpQUVJQUpCQTJwMUlnUTJBaUFMSUFZQ2Z5QUxRWDlxSWdCQkFrMEVRQUpBQWtBQ1FDQUFRUUZyRGdJQkFnQUxJQWxCQkhZTUF3c2dDVUVGZGd3Q0N5QUpRUlZzUVFwMURBRUxJQWxCQm5ZTElnQTJBaEFDUUNBRUlBaHlSUVJBSUFZZ0FEWUNTQ0FHSUFBMkFrd2dCaUFBTmdKRUlBWWdBRFlDUUNBR0lBQTJBandnQmlBQU5nSTRJQVlnQURZQ05DQUdJQUEyQWpBZ0JpQUFOZ0lzSUFZZ0FEWUNLQ0FHSUFBMkFpUWdCaUFBTmdJZ0lBWWdBRFlDSENBR0lBQTJBaGdnQmlBQU5nSVVEQUVMSUFZZ0FDQUlhaUlGSUFSck5nSkFJQVlnQlNBRVFRRjFJZ0pyTmdJd0lBWWdBaUFGYWpZQ0lDQUdJQVFnQldvMkFoQWdCaUFBSUFocklnVWdCR3MyQWt3Z0JpQUZJQUpyTmdJOElBWWdBaUFGYWpZQ0xDQUdJQVFnQldvMkFod2dCaUFBSUFoQkFYVWlCMm9pQlNBRWF6WUNSQ0FHSUFVZ0FtczJBalFnQmlBQ0lBVnFOZ0lrSUFZZ0JDQUZhallDRkNBR0lBQWdCMnNpQUNBRWF6WUNTQ0FHSUFBZ0FtczJBamdnQmlBQUlBSnFOZ0lvSUFZZ0FDQUVhallDR0FzZ0JrSFFBR29oQ0NBR1FSQnFJUUJCQUNFRUEwQWdDQ0FBSUFSQkRIRnFLQUlBSWdKQi93RWdBa0gvQVVnYklnSkJBQ0FDUVFCS0d6b0FBQ0FBSUFCQkVHb2dCRUVCYWlJRVFUOXhHeUVBSUFoQkFXb2hDQ0FFUVlBQ1J3MEFDeUFCS0FJQUlBb2dGR3dpQUVFSWRHb2dHa0VHZEdvZ0EwRURkR29oQXlBS1FRUjBJUXdnQ2tFR2RDRWFJQUJCQm5RaEhVRUFJQXBCQTNRaUMyc2hJQ0FHUWRBQ2FpRWhJQVpCUUdzaElrRUFJUVVEUUNBR1FnQTNBMGdnSWtJQU53TUFJQVpDQURjRE9DQUdRZ0EzQXpBZ0JrSUFOd01vSUFaQ0FEY0RJQ0FHUWdBM0F4Z2dCa0lBTndNUVFRQWhDRUVBSVFSQkFDRUpJQTBFUUNBR0lBTWdJR29pQUMwQUF5QUFMUUFDYWlJWElBQXRBQUVnQUMwQUFHb2lGbW9pQWlBQUxRQUZJQUF0QUFScUloSnJJQUF0QUFjZ0FDMEFCbW9pRTJzaUNEWUNGQ0FHSUFJZ0Vtb2dFMm9pQkRZQ0VFRUJJUWtMSUJBRVFDQUdJQU1nR21vaUFDMEFBeUFBTFFBQ2FpSWVJQUF0QUFFZ0FDMEFBR29pSDJvaUFpQUFMUUFGSUFBdEFBUnFJaGhySUFBdEFBY2dBQzBBQm1vaUdXc2dDR29pQ0RZQ0ZDQUdJQUlnR0dvZ0JHb2dHV29pQkRZQ0VDQUpRUUZxSVFrTFFRQWhBQUovSUJGRkJFQWdDU0VIUVFBTUFRc2dCaUFEUVg5cUlnQWdER29pQWlBTGFpMEFBQ0FDTFFBQWFpSWJJQUFnQzJvdEFBQWdBQzBBQUdvaUhHb2lCeUFDSUF4cUlnQWdDMm90QUFBZ0FDMEFBR29pRldzZ0FDQU1haUlBSUF0cUxRQUFJQUF0QUFCcUlnOXJJZ0EyQWlBZ0JpQUhJQlZxSUFScUlBOXFJZ1EyQWhBZ0NVRUJhaUVIUVFFTElRSUNRQ0FHQW44Q1FBSkFBa0FnRGtVRVFDQUpEUUVNQWdzZ0JpQUFJQU5CQ0dvaUNpQU1haUlBSUF0cUxRQUFJQUF0QUFCcUlpTWdDaUFMYWkwQUFDQURMUUFJYWlJa2FpSWxJQUFnREdvaUFDQUxhaTBBQUNBQUxRQUFhaUlLYXlBQUlBeHFJZ0FnQzJvdEFBQWdBQzBBQUdvaUZHdHFJZ0EyQWlBZ0JpQUtJQ1ZxSUFScUlCUnFJZ1EyQWhBZ0FrRUJhaUVDSUFkQkFXb2hCeUFSUVFGeklBbEJBRWR5UlFSQUlBWWdHeUFjYWlBVmFpQVBhaUFrYXlBamF5QUtheUFVYTBFRWRTSUlOZ0lVREFNTElBbEZEUUlMSUFZZ0NDQUpRUUpxZFNJSU5nSVVDeUFXSUJkcUlCSnFJQk5xSUJscklCaHJJQjVySUI5clFRUjFJQkFnRFNBQ1JYRnhRUUZHRFFFYUlBSkZEUUlMSUFBZ0FrRUNhblVMSWdBMkFpQUxJQVlDZnlBSFFYOXFJZ0pCQWswRVFBSkFBa0FDUUNBQ1FRRnJEZ0lCQWdBTElBUkJBM1lNQXdzZ0JFRUVkZ3dDQ3lBRVFSVnNRUWwyREFFTElBUkJCWFlMSWdRMkFoQUNRQ0FBSUFoeVJRUkFJQVlnQkRZQ1NDQUdJQVEyQWt3Z0JpQUVOZ0pFSUFZZ0JEWUNRQ0FHSUFRMkFqd2dCaUFFTmdJNElBWWdCRFlDTkNBR0lBUTJBakFnQmlBRU5nSXNJQVlnQkRZQ0tDQUdJQVEyQWlRZ0JpQUVOZ0lnSUFZZ0JEWUNIQ0FHSUFRMkFoZ2dCaUFFTmdJVURBRUxJQVlnQkNBSWFpSUhJQUJyTmdKQUlBWWdCeUFBUVFGMUlnSnJOZ0l3SUFZZ0FpQUhhallDSUNBR0lBQWdCMm8yQWhBZ0JpQUVJQWhySWdjZ0FHczJBa3dnQmlBSElBSnJOZ0k4SUFZZ0FpQUhhallDTENBR0lBQWdCMm8yQWh3Z0JpQUVJQWhCQVhVaUNXb2lCeUFBYXpZQ1JDQUdJQWNnQW1zMkFqUWdCaUFDSUFkcU5nSWtJQVlnQUNBSGFqWUNGQ0FHSUFRZ0NXc2lCQ0FBYXpZQ1NDQUdJQVFnQW1zMkFqZ2dCaUFDSUFScU5nSW9JQVlnQUNBRWFqWUNHQXNnSVNBRlFRWjBhaUVJUVFBaEFDQUdRUkJxSVFRRFFDQUlJQVFnQUVFQmRFRU1jV29vQWdBaUFrSC9BU0FDUWY4QlNCc2lBa0VBSUFKQkFFb2JPZ0FBSUFRZ0JFRVFhaUFBUVFGcUlnQkJEM0ViSVFRZ0NFRUJhaUVJSUFCQndBQkhEUUFMSUFNZ0hXb2hBeUFGUVFGcUlnVkJBa2NOQUFzTElBRWdCa0hRQUdvUUd5QUdRZEFEYWlRQUN6WUFJQUlFUUNBQUlBRVFBZzhMUVFFaEFpQUJJQUJCQVJBRElnQTJBZ0FnQUVGL1J3Ui9JQUVnQUVFQmN6WUNBRUVBQlVFQkN3dk1Bd0VTZnlBRFFRRjBJUThnQTBGOWJDRVFRUUFnQTJzaUVVRUJkQ0VTSUFFZ0FpZ0NBR3BCZjJvdEFBQWlCMEVCYWlFVFFRQWdCMnNoQ2tFRUlRRURRQUpBSUFBZ0VXb2lGQzBBQUNJRklBQXRBQUFpQ0dzaUJDQUVRUjkxSWdScUlBUnpJQUlvQWdSUERRQWdBQ0FTYWlJTExRQUFJZ3dnQldzaUJDQUVRUjkxSWdScUlBUnpJQUlvQWdnaUJrOE5BQ0FBSUFOcUloVXRBQUFpRFNBSWF5SUVJQVJCSDNVaUJHb2dCSE1nQms4TkFDQUhJUVFnQUNBUWFpMEFBQ0lKSUFWcklnNGdEa0VmZFNJT2FpQU9jeUFHU1FSQUlBc2dEQ0FLSUFjZ0JTQUlha0VCYWtFQmRpQU1RUUYwYXlBSmFrRUJkU0lFSUFRZ0Iwb2JJQVFnQ2tnYmFqb0FBQ0FDS0FJSUlRWWdFeUVFQ3lBVUlBVUNmeUFBSUE5cUxRQUFJZ3NnQ0dzaUNTQUpRUjkxSWdscUlBbHpJQVpKQkVBZ0ZTQU5JQW9nQnlBRklBaHFRUUZxUVFGMklBMUJBWFJySUF0cVFRRjFJZ1lnQmlBSFNoc2dCaUFLU0J0cU9nQUFJQVJCQVdvaEJBdEJBQ0FFYXlJR0N5QUVJQWdnQld0QkFuUWdEV3NnREdwQkJHcEJBM1VpQlNBRklBUktHeUFGSUFaSUd5SUVha0d3TG1vdEFBQTZBQUFnQUNBSUlBUnJRYkF1YWkwQUFEb0FBQXNnQUVFQmFpRUFJQUZCZjJvaUFRMEFDd3Y3QmdFT2Z5QUNLQUlJSVFvZ0FpZ0NCQ0VQQWtBZ0FVRUVUd1JBSUE5QkFuWkJBbW9oRUVFRUlRSURRQUpBSUFCQmYyb2lCUzBBQUNJSElBQXRBQUFpQ0dzaUFTQUJRUjkxSWdGcUlBRnpJZzBnRDA4TkFDQUFRWDVxSWc0dEFBQWlBU0FIYXlJRUlBUkJIM1VpQkdvZ0JITWdDazhOQUNBQUxRQUJJZ2tnQ0dzaUJDQUVRUjkxSWdScUlBUnpJQXBQRFFBQ1FDQU5JQkJKQkVBZ0FDMEFBaUVMQW44Z0FFRjlhaUlOTFFBQUlnUWdCMnNpQmlBR1FSOTFJZ1pxSUFaeklBcEpCRUJCQXlFR0lBVWdDU0FISUFocUlBRnFJZ1ZCQVhScUlBUnFRUVJxUVFOMk9nQUFJQTRnQkNBRmFrRUNha0VDZGpvQUFDQUVRUU5zSVE0Z0JVRUVhaUVNSUFCQmZHb3RBQUFNQVFzZ0J5QUphaUVNUVFJaERrRUNJUVlnQlNFTklBRUxJUVFnRFNBTUlBNXFJQVJCQVhScUlBWjJPZ0FBSUFzZ0NHc2lCU0FGUVI5MUlnVnFJQVZ6SUFwUERRRWdBQ0FISUFscUlBaHFJZ1VnQzJwQkFtcEJBblk2QUFFZ0FDQUZJQXRCQTJ4cUlBQXRBQU5CQVhScVFRUnFRUU4yT2dBQ0lBQWdBU0FGUVFGMGFpQUxha0VFYWtFRGRqb0FBQXdDQ3lBRklBY2dDV29nQVVFQmRHcEJBbXBCQW5ZNkFBQUxJQUFnQVNBSWFpQUpRUUYwYWtFQ2FrRUNkam9BQUFzZ0FDQURhaUVBSUFKQmYyb2lBZzBBQ3d3QkN5QUJJQUlvQWdCcVFYOXFMUUFBSWdWQkFXb2hEVUVBSUFWcklRaEJCQ0VDQTBBQ1FDQUFRWDlxSWc0dEFBQWlCQ0FBTFFBQUlnZHJJZ0VnQVVFZmRTSUJhaUFCY3lBUFR3MEFJQUJCZm1vaURDMEFBQ0lKSUFScklnRWdBVUVmZFNJQmFpQUJjeUFLVHcwQUlBQXRBQUVpQ3lBSGF5SUJJQUZCSDNVaUFXb2dBWE1nQ2s4TkFDQUFMUUFDSVFZZ0JTRUJJQUJCZldvdEFBQWlFQ0FFYXlJUklCRkJIM1VpRVdvZ0VYTWdDa2tFUUNBTUlBa2dDQ0FGSUFRZ0IycEJBV3BCQVhZZ0NVRUJkR3NnRUdwQkFYVWlBU0FCSUFWS0d5QUJJQWhJRzJvNkFBQWdEU0VCQ3lBT0lBUUNmeUFHSUFkcklnd2dERUVmZFNJTWFpQU1jeUFLU1FSQUlBQWdDeUFJSUFVZ0JDQUhha0VCYWtFQmRpQUxRUUYwYXlBR2FrRUJkU0lHSUFZZ0JVb2JJQVlnQ0VnYmFqb0FBU0FCUVFGcUlRRUxRUUFnQVdzaUJnc2dBU0FKSUF0cklBY2dCR3RCQW5ScVFRUnFRUU4xSWdRZ0JDQUJTaHNnQkNBR1NCc2lBV3BCc0M1cUxRQUFPZ0FBSUFBZ0J5QUJhMEd3TG1vdEFBQTZBQUFMSUFBZ0Eyb2hBQ0FDUVg5cUlnSU5BQXNMQzlvSEFRMS9Jd0JCd0FOckloRWtBQ0FHUVFWcUlRa0NRQUpBSUFKQkFFZ05BQ0FEUVFCSURRQWdBaUFKYWlBRVN3MEFJQU1nQjJwQkJXb2dCVXNOQUNBRUlRa2dBeUVLREFFTElBQWdFU0FDSUFNZ0JDQUZJQWtnQjBFRmFpQUpFQXdnRVNFQVFRQWhBZ3NDUUNBSFJRMEFJQUFnQ1NBS2JDQUNhbW9oRTBFUUlBWnJJUlFDUUNBR1FRSjJJaElFUUNBSklBWnJJUlVnRXlBSklBaEJBWFpCQVhGQkFuSnNha0VGYWlFQ0lBY2hCQU5BSUFKQmYyb3RBQUFoQUNBQ1FYNXFMUUFBSVFNZ0FrRjlhaTBBQUNFRklBSkJmR290QUFBaEN5QUNRWHRxTFFBQUlRMGdFaUVQQTBBZ0FTQUNMUUFBSWdvZ0RTQUFJQXRxSWd4cklBTWdCV3BCRkd4cUlBeEJBblJyYWtFUWFrRUZkVUd3TG1vdEFBQTZBQUFnQVNBQ0xRQUJJZ3dnQ3lBQUlBTnFRUlJzYWlBRklBcHFJZ3RySUF0QkFuUnJha0VRYWtFRmRVR3dMbW90QUFBNkFBRWdBU0FDTFFBQ0loQWdCU0FBSUFwcVFSUnNhaUFESUF4cUlnVnJJQVZCQW5ScmFrRVFha0VGZFVHd0xtb3RBQUE2QUFJZ0FTQUNMUUFESWc0Z0F5QUtJQXhxUVJSc2FpQUFJQkJxSWdOcklBTkJBblJyYWtFUWFrRUZkVUd3TG1vdEFBQTZBQU1nQVVFRWFpRUJJQUpCQkdvaEFpQUFJUTBnQ2lFTElBd2hCU0FRSVFNZ0RpRUFJQTlCZjJvaUR3MEFDeUFCSUJScUlRRWdBaUFWYWlFQ0lBUkJmMm9pQkEwQUN3d0JDeUFIUVg5cUlCUnNJQVpySUFGcVFSQnFJUUVMSUFkQkFuWWlCRVVOQUVIQUFDQUdheUVRSUFsQkFYUWhDaUFKUVFKMElBWnJJUXRCQUNBSmF5SU1RUUYwSVJJZ0FTQUhRUVIwYXlFQ0lBa2dFMm9nQ0VFQmNXcEJBbW9pQUNBSlFRVnNhaUVCQTBBZ0JpSURCRUFEUUNBQ0lBQWdDbW90QUFBaUJTQUJJQXBxTFFBQUlBRWdDV290QUFBaURpQUJJQkpxTFFBQUlnZHFJZ2hySUFoQkFuUnJhaUFCTFFBQUlnMGdBU0FNYWkwQUFDSUlha0VVYkdwQkVHcEJCWFZCc0M1cUxRQUFJQUl0QURCcVFRRnFRUUYyT2dBd0lBSWdBQ0FKYWkwQUFDSVBJQTRnQnlBSWFrRVViR29nQlNBTmFpSU9heUFPUVFKMGEycEJFR3BCQlhWQnNDNXFMUUFBSUFJdEFDQnFRUUZxUVFGMk9nQWdJQUlnQUMwQUFDSU9JQTBnQlNBSGFrRVViR29nQ0NBUGFpSU5heUFOUVFKMGEycEJFR3BCQlhWQnNDNXFMUUFBSUFJdEFCQnFRUUZxUVFGMk9nQVFJQUlnQUNBTWFpMEFBQ0FJSUFVZ0QycEJGR3hxSUFjZ0Rtb2lCV3NnQlVFQ2RHdHFRUkJxUVFWMVFiQXVhaTBBQUNBQ0xRQUFha0VCYWtFQmRqb0FBQ0FBUVFGcUlRQWdBa0VCYWlFQ0lBRkJBV29oQVNBRFFYOXFJZ01OQUFzTElBSWdFR29oQWlBQklBdHFJUUVnQUNBTGFpRUFJQVJCZjJvaUJBMEFDd3NnRVVIQUEyb2tBQXUxQlFFRWZ5QUFLQUlVSVFNZ0FDZ0NFQ0VFSUFBb0FnUWhCU0FBS0FJTUlnSWdBU2tDQURjQ0FDQUNJQUVwQWdnM0FnZ2dBaUFGUVFSMElnQnFJZ0lnQVNrQ0VEY0NBQ0FDSUFFcEFoZzNBZ2dnQUNBQ2FpSUNJQUVwQWlBM0FnQWdBaUFCS1FJb053SUlJQUFnQW1vaUFpQUJLUUl3TndJQUlBSWdBU2tDT0RjQ0NDQUFJQUpxSWdJZ0FTa0NRRGNDQUNBQ0lBRXBBa2czQWdnZ0FDQUNhaUlDSUFFcEFsQTNBZ0FnQWlBQktRSllOd0lJSUFBZ0Ftb2lBaUFCS1FKZ053SUFJQUlnQVNrQ2FEY0NDQ0FBSUFKcUlnSWdBU2tDY0RjQ0FDQUNJQUVwQW5nM0FnZ2dBQ0FDYWlJQ0lBRXBBb0FCTndJQUlBSWdBU2tDaUFFM0FnZ2dBQ0FDYWlJQ0lBRXBBcEFCTndJQUlBSWdBU2tDbUFFM0FnZ2dBQ0FDYWlJQ0lBRXBBcUFCTndJQUlBSWdBU2tDcUFFM0FnZ2dBQ0FDYWlJQ0lBRXBBckFCTndJQUlBSWdBU2tDdUFFM0FnZ2dBQ0FDYWlJQ0lBRXBBc0FCTndJQUlBSWdBU2tDeUFFM0FnZ2dBQ0FDYWlJQ0lBRXBBdEFCTndJQUlBSWdBU2tDMkFFM0FnZ2dBQ0FDYWlJQ0lBRXBBdUFCTndJQUlBSWdBU2tDNkFFM0FnZ2dBQ0FDYWlJQUlBRXBBdkFCTndJQUlBQWdBU2tDK0FFM0FnZ2dCQ0FCS1FLQUFqY0NBQ0FFSUFWQkEzUWlBR29pQkNBQktRS0lBamNDQUNBQUlBUnFJZ1FnQVNrQ2tBSTNBZ0FnQUNBRWFpSUVJQUVwQXBnQ053SUFJQUFnQkdvaUJDQUJLUUtnQWpjQ0FDQUFJQVJxSWdRZ0FTa0NxQUkzQWdBZ0FDQUVhaUlFSUFFcEFyQUNOd0lBSUFBZ0JHb2dBU2tDdUFJM0FnQWdBeUFCS1FMQUFqY0NBQ0FBSUFOcUlnTWdBU2tDeUFJM0FnQWdBQ0FEYWlJRElBRXBBdEFDTndJQUlBQWdBMm9pQXlBQktRTFlBamNDQUNBQUlBTnFJZ01nQVNrQzRBSTNBZ0FnQUNBRGFpSURJQUVwQXVnQ053SUFJQUFnQTJvaUF5QUJLUUx3QWpjQ0FDQUFJQU5xSUFFcEF2Z0NOd0lBQytnQ0FRVi9Ba0FnQUNBQkVBSWlBdzBBUVFFaEF5QUJJQUVvQWdCQkFXb2lBallDQUNBQ1FTQkxEUUFnQUVFRUVBTWlBa0YvUmcwQUlBRWdBallDQkNBQVFRUVFBeUlDUVg5R0RRQWdBU0FDTmdJSUlBRW9BZ0FFUUFOQUlBQWdBU0FGUVFKMGFpSUNJZ1JCREdvUUFpSUREUUpCQVNFRElBUW9BZ3dpQmtGL1JnMENJQVFnQmtFQmFpSUROZ0lNSUFRZ0F5QUJLQUlFUVFacWREWUNEQ0FBSUFKQmpBRnFFQUlpQXcwQ1FRRWhBeUFDS0FLTUFTSUVRWDlHRFFJZ0FpQUVRUUZxSWdRMkFvd0JJQUlnQkNBQktBSUlRUVJxZERZQ2pBRWdBRUVCRUFNaUJFRi9SZzBDSUFJZ0JFRUJSallDakFJZ0JVRUJhaUlGSUFFb0FnQkpEUUFMQ3lBQVFRVVFBeUlDUVg5R0RRQWdBU0FDUVFGcU5nS01BeUFBUVFVUUF5SUNRWDlHRFFBZ0FTQUNRUUZxTmdLUUF5QUFRUVVRQXlJQ1FYOUdEUUFnQVNBQ1FRRnFOZ0tVQXlBQVFRVVFBeUlBUVg5R0RRQWdBU0FBTmdLWUEwRUFJUU1MSUFNTFd3RURmeUFBSUFBb0FnQWlCQ0FCSUFBb0FnUWlBbkFpQTBFRWRHb2dBU0FEYXlJQlFRaDBhallDRENBQUlBUWdBaUFBS0FJSWJDSUNRUWgwYWlBQlFRWjBhaUFEUVFOMGFpSUJOZ0lRSUFBZ0FTQUNRUVowYWpZQ0ZBdFZBUUovSUFFZ0FrRUJhaUlESUFNZ0FVa2JJUU1nQUNBQ1FRSjBhaWdDQUNFRUEwQUNRQ0FDUVFGcUlnSWdBVThFUUNBRElRSU1BUXNnQUNBQ1FRSjBhaWdDQUNBRVJ3MEJDd3RCQUNBQ0lBRWdBa1liQ3ljQUlBQkJDQ0FBS0FJSUlnQnJFQU5CZjBZRVFBOExRUUFnQUd0QkFuUkJ6RDlxS0FJQUdndDZBUUovSXdCQklHc2lBaVFBSUFJZ0FDZ0NFRFlDRUNBQ0lBQXBBZ2czQXdnZ0FpQUFLUUlBTndNQUFrQWdBaUFDUVJ4cUVBSWlBQTBBSUFJZ0FrRWNhaEFDSWdBTkFDQUNJQUpCSEdvUUFpSUFEUUJCQVNFQUlBSW9BaHdpQTBIL0FVc05BQ0FCSUFNMkFnQkJBQ0VBQ3lBQ1FTQnFKQUFnQUF2bkJ3RVNmeU1BUVlBT2F5SU1KQUFnQmtFRmFpRUpBa0FDUUNBQ1FRQklEUUFnQTBFQVNBMEFJQUlnQ1dvZ0JFc05BQ0FESUFkcVFRVnFJQVZMRFFBZ0F5RUtEQUVMSUFBZ0RFSEFDbW9nQWlBRElBUWdCU0FKSUFkQkJXb2dDUkFNSUF4QndBcHFJUUFnQ1NFRVFRQWhBZ3NDUUNBSFFRSjJJaFJGRFFBZ0NVVU5BQ0FFUVFGMElSVkJBQ0FFYXlJV1FRRjBJUm9nQkVFQ2RDQUdhMEY3YWlFWElBQWdCQ0FLYkNBQ2Ftb2dCR29pQUNBRVFRVnNhaUVDSUF3Z0NVRUNkQ0lRYWlFRElBbEJBM1FoRFVFQUlBbHJRUUowSVE0Z0NVRURiRUVDZENFUEEwQWdDU0VGQTBBZ0F5QU5haUFBSUJWcUxRQUFJaEVnQWlBVmFpMEFBQ0FDSUFScUxRQUFJZ3NnQWlBYWFpMEFBQ0lTYWlJS2F5QUtRUUowYTJvZ0FpMEFBQ0lZSUFJZ0Ztb3RBQUFpRTJwQkZHeHFOZ0lBSUFNZ0VHb2dBQ0FFYWkwQUFDSVpJQXNnRWlBVGFrRVViR29nRVNBWWFpSUtheUFLUVFKMGEybzJBZ0FnQXlBQUxRQUFJZ3NnR0NBUklCSnFRUlJzYWlBVElCbHFJZ3BySUFwQkFuUnJhallDQUNBRElBNXFJQUFnRm1vdEFBQWdFeUFSSUJscVFSUnNhaUFMSUJKcUlncHJJQXBCQW5ScmFqWUNBQ0FBUVFGcUlRQWdBMEVFYWlFRElBSkJBV29oQWlBRlFYOXFJZ1VOQUFzZ0FpQVhhaUVDSUFBZ0Yyb2hBQ0FESUE5cUlRTWdGRUYvYWlJVURRQUxDeUFIQkVCQkVDQUdheUVRSUFaQkFuWWhDaUFNSUFoQkFuUnFRUWhxSVFBZ0RFRVVhaUVDQTBBZ0NnUkFJQUpCYkdvb0FnQWhCQ0FDUVhCcUtBSUFJUThnQWtGMGFpZ0NBQ0VOSUFKQmVHb29BZ0FoQlNBQ1FYeHFLQUlBSVFNZ0NpRUpBMEFnQVNBQ0tBSUFJZzRnQkNBRElBOXFJZ1JySUFVZ0RXcEJGR3hxSUFSQkFuUnJha0dBQkdwQkNuVkJzQzVxTFFBQUlBQW9BZ0JCRUdwQkJYVkJzQzVxTFFBQWFrRUJha0VCZGpvQUFDQUJJQUlvQWdRaUN5QVBJQU1nQldwQkZHeHFJQTBnRG1vaUJHc2dCRUVDZEd0cVFZQUVha0VLZFVHd0xtb3RBQUFnQUNnQ0JFRVFha0VGZFVHd0xtb3RBQUJxUVFGcVFRRjJPZ0FCSUFFZ0FpZ0NDQ0lJSUEwZ0F5QU9ha0VVYkdvZ0JTQUxhaUlFYXlBRVFRSjBhMnBCZ0FScVFRcDFRYkF1YWkwQUFDQUFLQUlJUVJCcVFRVjFRYkF1YWkwQUFHcEJBV3BCQVhZNkFBSWdBU0FDS0FJTUlnWWdCU0FMSUE1cVFSUnNhaUFESUFocUlnUnJJQVJCQW5ScmFrR0FCR3BCQ25WQnNDNXFMUUFBSUFBb0FneEJFR3BCQlhWQnNDNXFMUUFBYWtFQmFrRUJkam9BQXlBQlFRUnFJUUVnQUVFUWFpRUFJQUpCRUdvaEFpQURJUVFnRGlFUElBc2hEU0FJSVFVZ0JpRURJQWxCZjJvaUNRMEFDd3NnQVNBUWFpRUJJQUJCRkdvaEFDQUNRUlJxSVFJZ0IwRi9haUlIRFFBTEN5QU1RWUFPYWlRQUM5RUhBUXgvSXdCQmdBNXJJZzhrQUNBR1FRVnFJUWtDUUFKQUlBSkJBRWdOQUNBRFFRQklEUUFnQWlBSmFpQUVTdzBBSUFkQkJXb2lEaUFEYWlBRlN3MEFJQVFoQ1NBRElRb01BUXNnQUNBUFFjQUthaUFDSUFNZ0JDQUZJQWtnQjBFRmFpSU9JQWtRRENBUFFjQUthaUVBUVFBaEFnc0NRQ0FPUlEwQUlBWkJBbllpRWtVTkFDQUpJQVpySVJNZ0FDQUpJQXBzSUFKcWFrRUZhaUVDSUE4aEFBTkFJQUpCZjJvdEFBQWhDU0FDUVg1cUxRQUFJUU1nQWtGOWFpMEFBQ0VGSUFKQmZHb3RBQUFoQ2lBQ1FYdHFMUUFBSVF3Z0VpRU5BMEFnQUNBQ0xRQUFJZ1FnRENBSklBcHFJZ3RySUFNZ0JXcEJGR3hxSUF0QkFuUnJhallDQUNBQUlBSXRBQUVpQ3lBRElBbHFRUlJzSUFwcUlBUWdCV29pQ21zZ0NrRUNkR3RxTmdJRUlBQWdBaTBBQWlJUUlBUWdDV3BCRkd3Z0JXb2dBeUFMYWlJRmF5QUZRUUowYTJvMkFnZ2dBQ0FDTFFBREloUWdCQ0FMYWtFVWJDQURhaUFKSUJCcUlnTnJJQU5CQW5ScmFqWUNEQ0FBUVJCcUlRQWdBa0VFYWlFQ0lBa2hEQ0FFSVFvZ0N5RUZJQkFoQXlBVUlRa2dEVUYvYWlJTkRRQUxJQUlnRTJvaEFpQU9RWDlxSWc0TkFBc0xJQWRCQW5ZaUJ3UkFRY0FBSUFacklSUWdEeUFHUVFKMElnUnFJZ2tnQmtFVWJHb2hBaUFKSUFoQkFtb2dCbXhCQW5ScUlRQWdCa0VEYkVFQ2RDRUZRUUFnQm1zaURrRURkQ0VUSUFaQkEzUWhDQU5BSUFZaEF5QUdCRUFEUUNBQklBZ2dDV29vQWdBaUNpQUNJQWhxS0FJQUlBSWdCR29vQWdBaUVTQUNJQk5xS0FJQUlndHFJZ3hySUF4QkFuUnJhaUFDS0FJQUlnMGdBaUFPUVFKMEloQnFLQUlBSWd4cVFSUnNha0dBQkdwQkNuVkJzQzVxTFFBQUlBQWdDR29vQWdCQkVHcEJCWFZCc0M1cUxRQUFha0VCYWtFQmRqb0FNQ0FCSUFRZ0NXb29BZ0FpRWlBUklBc2dER3BCRkd4cUlBb2dEV29pRVdzZ0VVRUNkR3RxUVlBRWFrRUtkVUd3TG1vdEFBQWdBQ0FFYWlnQ0FFRVFha0VGZFVHd0xtb3RBQUJxUVFGcVFRRjJPZ0FnSUFFZ0NTZ0NBQ0lSSUEwZ0NpQUxha0VVYkdvZ0RDQVNhaUlOYXlBTlFRSjBhMnBCZ0FScVFRcDFRYkF1YWkwQUFDQUFLQUlBUVJCcVFRVjFRYkF1YWkwQUFHcEJBV3BCQVhZNkFCQWdBU0FKSUJCcUtBSUFJQXdnQ2lBU2FrRVViR29nQ3lBUmFpSUtheUFLUVFKMGEycEJnQVJxUVFwMVFiQXVhaTBBQUNBQUlCQnFLQUlBUVJCcVFRVjFRYkF1YWkwQUFHcEJBV3BCQVhZNkFBQWdBRUVFYWlFQUlBbEJCR29oQ1NBQlFRRnFJUUVnQWtFRWFpRUNJQU5CZjJvaUF3MEFDd3NnQVNBVWFpRUJJQUFnQldvaEFDQUNJQVZxSVFJZ0JTQUphaUVKSUFkQmYyb2lCdzBBQ3dzZ0QwR0FEbW9rQUF1MEJnRUpmeU1BUWNBRGF5SU5KQUFnQmtFRmFpRUpBa0FDUUNBQ1FRQklEUUFnQXlBSGFpQUZTdzBBSUFOQkFFZ05BQ0FDSUFscUlBUkxEUUFnQkNFSklBTWhDZ3dCQ3lBQUlBMGdBaUFESUFRZ0JTQUpJQWNnQ1JBTUlBMGhBRUVBSVFJTElBY0VRRUVRSUFacklSQWdDU0FHYXlFUklBWkJBblloRHlBQUlBa2dDbXdnQW1wcVFRVnFJUWtEUUFKQUlBOUZEUUFnQ1VGL2FpMEFBQ0VDSUFsQmZtb3RBQUFoQmlBSlFYMXFMUUFBSVFNZ0NVRjhhaTBBQUNFRklBbEJlMm90QUFBaENpQVBJZ0FoQ3lBSUJFQURRQ0FCSUFZZ0NTMEFBQ0lFSUFvZ0FpQUZhaUlLYXlBRElBWnFRUlJzYWlBS1FRSjBhMnBCRUdwQkJYVkJzQzVxTFFBQWFrRUJha0VCZGpvQUFDQUJJQUlnQ1MwQUFTSUxJQVVnQWlBR2FrRVViR29nQXlBRWFpSUZheUFGUVFKMGEycEJFR3BCQlhWQnNDNXFMUUFBYWtFQmFrRUJkam9BQVNBQklBUWdDUzBBQWlJTUlBTWdBaUFFYWtFVWJHb2dCaUFMYWlJRGF5QURRUUowYTJwQkVHcEJCWFZCc0M1cUxRQUFha0VCYWtFQmRqb0FBaUFCSUFzZ0NTMEFBeUlPSUFZZ0JDQUxha0VVYkdvZ0FpQU1haUlEYXlBRFFRSjBhMnBCRUdwQkJYVkJzQzVxTFFBQWFrRUJha0VCZGpvQUF5QUJRUVJxSVFFZ0NVRUVhaUVKSUFJaENpQUVJUVVnQ3lFRElBd2hCaUFPSVFJZ0FFRi9haUlBRFFBTUFnQUxBQXNEUUNBQklBTWdDUzBBQUNJQUlBb2dBaUFGYWlJRWF5QURJQVpxUVJSc2FpQUVRUUowYTJwQkVHcEJCWFZCc0M1cUxRQUFha0VCYWtFQmRqb0FBQ0FCSUFZZ0NTMEFBU0lFSUFVZ0FpQUdha0VVYkdvZ0FDQURhaUlGYXlBRlFRSjBhMnBCRUdwQkJYVkJzQzVxTFFBQWFrRUJha0VCZGpvQUFTQUJJQUlnQ1MwQUFpSU1JQU1nQUNBQ2FrRVViR29nQkNBR2FpSURheUFEUVFKMGEycEJFR3BCQlhWQnNDNXFMUUFBYWtFQmFrRUJkam9BQWlBQklBQWdDUzBBQXlJT0lBWWdBQ0FFYWtFVWJHb2dBaUFNYWlJRGF5QURRUUowYTJwQkVHcEJCWFZCc0M1cUxRQUFha0VCYWtFQmRqb0FBeUFCUVFScUlRRWdDVUVFYWlFSklBSWhDaUFBSVFVZ0JDRURJQXdoQmlBT0lRSWdDMEYvYWlJTERRQUxDeUFCSUJCcUlRRWdDU0FSYWlFSklBZEJmMm9pQncwQUN3c2dEVUhBQTJva0FBdkdCQUVMZnlNQVFjQURheUlOSkFBQ1FBSkFJQUpCQUVnTkFDQURRUUJJRFFBZ0FpQUdhaUFFU3cwQUlBTWdCMnBCQldvZ0JVc05BQ0FESVFrTUFRc2dBQ0FOSUFJZ0F5QUVJQVVnQmlBSFFRVnFJQVlRRENBTklRQWdCaUVFUVFBaEFnc2dCMEVDZGlJUUJFQkJ3QUFnQm1zaEVpQUVRUUYwSVFVZ0JFRUNkQ0FHYXlFT1FRQWdCR3NpRDBFQmRDRVRJQUFnQkNBSmJDQUNhbW9nQkdvaUFDQUVRUVZzYWlFQ0lBQWdCQ0FJUVFKcWJHb2hCd05BSUFZaEF5QUdCRUFEUUNBQklBQWdCV290QUFBaUNDQUNJQVZxTFFBQUlBSWdCR290QUFBaUNpQUNJQk5xTFFBQUlnbHFJZ3RySUF0QkFuUnJhaUFDTFFBQUlnd2dBaUFQYWkwQUFDSUxha0VVYkdwQkVHcEJCWFZCc0M1cUxRQUFJQVVnQjJvdEFBQnFRUUZxUVFGMk9nQXdJQUVnQUNBRWFpMEFBQ0lSSUFvZ0NTQUxha0VVYkdvZ0NDQU1haUlLYXlBS1FRSjBhMnBCRUdwQkJYVkJzQzVxTFFBQUlBUWdCMm90QUFCcVFRRnFRUUYyT2dBZ0lBRWdBQzBBQUNJS0lBd2dDQ0FKYWtFVWJHb2dDeUFSYWlJTWF5QU1RUUowYTJwQkVHcEJCWFZCc0M1cUxRQUFJQWN0QUFCcVFRRnFRUUYyT2dBUUlBRWdBQ0FQYWkwQUFDQUxJQWdnRVdwQkZHeHFJQWtnQ21vaUNHc2dDRUVDZEd0cVFSQnFRUVYxUWJBdWFpMEFBQ0FISUE5cUxRQUFha0VCYWtFQmRqb0FBQ0FIUVFGcUlRY2dBRUVCYWlFQUlBRkJBV29oQVNBQ1FRRnFJUUlnQTBGL2FpSUREUUFMQ3lBQklCSnFJUUVnQnlBT2FpRUhJQUlnRG1vaEFpQUFJQTVxSVFBZ0VFRi9haUlRRFFBTEN5QU5RY0FEYWlRQUM0OEhBUXgvSUFFb0FnZ2hDeUFCS0FJRUlRWUNRQUpBQWtBZ0FrRUZTdzBBSUFKQkFXc09CQUFBQUFBQkN5QUFLQUs0R2cwQURBRUxJQUJCeEFscUlRUURRQ0FFSUFNUUZDRUhJQU5CRGtzTkFTQURRUUZxSVFNZ0IwVU5BQXNMQWtBQ1FBSkFBa0FnQUNnQ21Ba2lDQVJBSUFBb0Fyd0pJUXBCQUNFRFFRQWhCQU5BSUFvZ0EwSFlBV3hxS0FMRUFVVUVRRUVBSUFSQkFXb2lCQ0FFSUFaR0lnVWJJUVFnQlNBSmFpRUpJQU5CQVdvaUF5QUlTUTBCQ3dzZ0F5QUlSdzBCQ3dKQUFrQWdBa0YrYWlJQ1FRVkxEUUFDUUNBQ1FRRnJEZ1FCQVFFQkFBc2dCMFVOQVNBQUtBSzRHa1VOQVF3REN5QUhEUUlMSUFFb0FnQkJnQUVnQmlBTGJFR0FBMndRQnhvTUFnc2dBQ2dDdkFrZ0JpQUpiRUhZQVd4cUlRZ2dCQVJBSUFRaEF3TkFJQWdnQTBGL2FpSURRZGdCYkdvaUNpQUJJQWtnQXlBQ0lBY1FGaUFLUVFFMkFzUUJJQUFnQUNnQ3RBbEJBV28yQXJRSklBTU5BQXNMSUFSQkFXb2lBeUFHU1FSQUEwQWdDQ0FEUWRnQmJHb2lCQ2dDeEFGRkJFQWdCQ0FCSUFrZ0F5QUNJQWNRRmlBRVFRRTJBc1FCSUFBZ0FDZ0N0QWxCQVdvMkFyUUpDeUFEUVFGcUlnTWdCa2NOQUFzTEFrQWdDVVVOQUNBR1JRMEFRUUFoQlNBSlFYOXFJZ3dnQm13aERTQU1SUVJBQTBBZ0FDZ0N2QWtnRFVIWUFXeHFJQVZCMkFGc2FpSUVJQUZCQUNBRklBSWdCeEFXSUFSQkFUWUN4QUVnQUNBQUtBSzBDVUVCYWpZQ3RBa2dCVUVCYWlJRklBWkhEUUFNQWdBTEFBc2dDVUYrYWlFSVFRQWdCbXRCMkFGc0lRNERRQ0FBS0FLOENTQU5RZGdCYkdvZ0JVSFlBV3hxSWdNZ0FTQU1JQVVnQWlBSEVCWWdBMEVCTmdMRUFTQUFJQUFvQXJRSlFRRnFOZ0swQ1NBSUlRUURRQ0FESUE1cUlnTWdBU0FFSWdvZ0JTQUNJQWNRRmlBRFFRRTJBc1FCSUFBZ0FDZ0N0QWxCQVdvMkFyUUpJQVJCZjJvaEJDQUtEUUFMSUFWQkFXb2lCU0FHUncwQUN3c2dDVUVCYWlJRklBdFBEUUlnQmtVTkFnTkFJQUFvQXJ3SklBVWdCbXhCMkFGc2FpRUlRUUFoQXdOQUlBZ2dBMEhZQVd4cUlnUW9Bc1FCUlFSQUlBUWdBU0FGSUFNZ0FpQUhFQllnQkVFQk5nTEVBU0FBSUFBb0FyUUpRUUZxTmdLMENRc2dBMEVCYWlJRElBWkhEUUFMSUFWQkFXb2lCU0FMUncwQUN3d0NDeUFCS0FJQUlBY2dCaUFMYkVHQUEyd1FGUm9MSUFBZ0FDZ0NtQWtpQVRZQ3RBa2dBVVVOQUNBQUtBSzhDU0VBUVFBaEF3TkFJQUFnQTBIWUFXeHFRUUUyQWdnZ0EwRUJhaUlESUFGSERRQUxDd3MyQVFKL0lBQW9BaWdpQWdSQUEwQWdBQ2dDQkNBQlFRSjBhaUFBS0FJQUlBRkJLR3hxTmdJQUlBRkJBV29pQVNBQ1J3MEFDd3NMOXdRQ0RIOEJma0VISVFVakFFRWdheUlJSVF3RFFDQUZJQUZKQkVBZ0FFRUFJQVZyUVNoc2FpRUtJQVVoQmdOQUlBQWdCa0VvYkdvaUFpZ0NDQ0VKSUFJcEFnQWhEaUFJSUFJcEFndzNBeGdnQWlnQ0dDRU5JQUlvQWhRaEN5QU1JQUlvQWlRMkFoQWdDQ0FDS1FJY053TUlBa0FnQmlJRElBVkpEUUFDUUNBTFJRUkFBMEFnQ2lBRFFTaHNJZ0pxSWdRb0FoUU5BaUFOUlEwQ0lBUW9BaGdOQWlBQUlBSnFJZ1FnQUNBRElBVnJJZ05CS0d4cUlnSXBBZ0EzQWdBZ0JDQUNLUUlnTndJZ0lBUWdBaWtDR0RjQ0dDQUVJQUlwQWhBM0FoQWdCQ0FDS1FJSU53SUlJQU1nQlU4TkFBd0RBQXNBQ3lBTFFYOXFRUUZOQkVBRFFBSi9Ba0FnQ2lBRFFTaHNJZ0pxSWdRb0FoUWlCMFVOQUNBSFFYOXFRUUZMRFFBZ0JDZ0NDQ0lISUFsS0RRUWdBQ0FDYWlJRUlBY2dDVWdOQVJvZ0JDRUNEQVVMSUFBZ0Ftb0xJZ1FnQUNBRElBVnJJZ05CS0d4cUlnSXBBZ0EzQWdBZ0JDQUNLUUlnTndJZ0lBUWdBaWtDR0RjQ0dDQUVJQUlwQWhBM0FoQWdCQ0FDS1FJSU53SUlJQU1nQlU4TkFBd0RBQXNBQ3dOQUlBb2dBMEVvYkNJQ2FpSUVLQUlVSWdjRVFDQUhRWDlxUVFKSkRRSWdCQ2dDQ0NBSlRBMENDeUFBSUFKcUlnUWdBQ0FESUFWcklnTkJLR3hxSWdJcEFnQTNBZ0FnQkNBQ0tRSWdOd0lnSUFRZ0Fpa0NHRGNDR0NBRUlBSXBBaEEzQWhBZ0JDQUNLUUlJTndJSUlBTWdCVThOQUFzTUFRc2dBQ0FEUVNoc2FpRUNDeUFDSUE0M0FnQWdBQ0FEUVNoc2FpSURJQWsyQWdnZ0NDa0RHQ0VPSUFNZ0RUWUNHQ0FESUFzMkFoUWdBeUFPTndJTUlBTWdDQ2tEQ0RjQ0hDQURJQXdvQWhBMkFpUWdCa0VCYWlJR0lBRkhEUUFMQ3lBRlFRRjJJZ1VOQUFzTHJRVUJBWDhDUUNBQUtBSUFJZ0VvQWhSRkRRQWdBVUVBTmdJVUlBRW9BaGdOQUNBQUlBQW9BaXhCZjJvMkFpd0xBa0FnQVNnQ1BFVU5BQ0FCUVFBMkFqd2dBVUZBYXlnQ0FBMEFJQUFnQUNnQ0xFRi9hallDTEFzQ1FDQUJLQUprUlEwQUlBRkJBRFlDWkNBQktBSm9EUUFnQUNBQUtBSXNRWDlxTmdJc0N3SkFJQUVvQW93QlJRMEFJQUZCQURZQ2pBRWdBU2dDa0FFTkFDQUFJQUFvQWl4QmYybzJBaXdMQWtBZ0FTZ0N0QUZGRFFBZ0FVRUFOZ0swQVNBQktBSzRBUTBBSUFBZ0FDZ0NMRUYvYWpZQ0xBc0NRQ0FCS0FMY0FVVU5BQ0FCUVFBMkF0d0JJQUVvQXVBQkRRQWdBQ0FBS0FJc1FYOXFOZ0lzQ3dKQUlBRW9Bb1FDUlEwQUlBRkJBRFlDaEFJZ0FTZ0NpQUlOQUNBQUlBQW9BaXhCZjJvMkFpd0xBa0FnQVNnQ3JBSkZEUUFnQVVFQU5nS3NBaUFCS0FLd0FnMEFJQUFnQUNnQ0xFRi9hallDTEFzQ1FDQUJLQUxVQWtVTkFDQUJRUUEyQXRRQ0lBRW9BdGdDRFFBZ0FDQUFLQUlzUVg5cU5nSXNDd0pBSUFFb0F2d0NSUTBBSUFGQkFEWUMvQUlnQVNnQ2dBTU5BQ0FBSUFBb0FpeEJmMm8yQWl3TEFrQWdBU2dDcEFORkRRQWdBVUVBTmdLa0F5QUJLQUtvQXcwQUlBQWdBQ2dDTEVGL2FqWUNMQXNDUUNBQktBTE1BMFVOQUNBQlFRQTJBc3dESUFFb0F0QUREUUFnQUNBQUtBSXNRWDlxTmdJc0N3SkFJQUVvQXZRRFJRMEFJQUZCQURZQzlBTWdBU2dDK0FNTkFDQUFJQUFvQWl4QmYybzJBaXdMQWtBZ0FTZ0NuQVJGRFFBZ0FVRUFOZ0tjQkNBQktBS2dCQTBBSUFBZ0FDZ0NMRUYvYWpZQ0xBc0NRQ0FCS0FMRUJFVU5BQ0FCUVFBMkFzUUVJQUVvQXNnRURRQWdBQ0FBS0FJc1FYOXFOZ0lzQ3dKQUlBRW9BdXdFUlEwQUlBRkJBRFlDN0FRZ0FTZ0M4QVFOQUNBQUlBQW9BaXhCZjJvMkFpd0xBMEFnQUJCZVJRMEFDeUFBUVFBMkFqQWdBRUwvL3dNM0FpUUwzUTRCQ1g4Z0FpZ0NBQ0FBS0FJSUlnSW9BZ0JHQkVBZ0FFRUFOZ0kwSUFBb0FqZ2lDMFVoRFFKQUlBRkZCRUFnQWlBRE5nSU1JQUpCQURZQ0ZDQUNJQTAyQWhnZ0FpQUVOZ0lRSUFJZ0F6WUNDQ0FMRFFFZ0FDQUFLQUlzUVFGcU5nSXNEQUVMSUFVRVFDQUFRZ0EzQWhBZ0FCQW9Ba0FnQVNnQ0FFVUVRQ0FBS0FJNFJRMEJDeUFBUWdBM0FoQUxJQUFvQWdnaUFrRURRUUlnQVNnQ0JDSUJHellDRkNBQVFRQkIvLzhESUFFYk5nSWtJQUlnRFRZQ0dDQUNRUUEyQWhBZ0FrSUFOd0lJSUFCQ2dZQ0FnQkEzQWlnTUFRc0NRQUpBQWtBZ0FTZ0NDQVJBUVFBaEN3TkFJQUVnQzBFVWJHb2lDQ2dDRENJQ1FRWkxEUUlDUUFKQUFrQUNRQUpBQWtBQ1FDQUNRUUZyRGdZQUFRSURCQVVKQ3lBQUtBSVlJZ2xGRFFnZ0F5QUlLQUlRYXlFTUlBQW9BZ0FoQ2tFQUlRZ0RRQUpBSUFvZ0NFRW9iR29pQWlnQ0ZFRi9ha0VCVFFSQUlBSW9BZ2dnREVZTkFRc2dDRUVCYWlJSUlBbEhEUUVNQ2dzTElBaEJBRWdOQ0NBQ1FRQTJBaFFnQUNBQUtBSW9RWDlxTmdJb0lBSW9BaGdOQlNBQUlBQW9BaXhCZjJvMkFpd2dDMEVCYWlFTERBWUxJQUFvQWhnaUNVVU5CeUFJS0FJVUlRd2dBQ2dDQUNFS1FRQWhDQU5BQWtBZ0NpQUlRU2hzYWlJQ0tBSVVRUU5HQkVBZ0FpZ0NDQ0FNUmcwQkN5QUlRUUZxSWdnZ0NVY05BUXdKQ3dzZ0NFRUFTQTBISUFKQkFEWUNGQ0FBSUFBb0FpaEJmMm8yQWlnZ0FpZ0NHQTBFSUFBZ0FDZ0NMRUYvYWpZQ0xDQUxRUUZxSVFzTUJRc2dBQ2dDSkNJQ1FmLy9BMFlOQmlBQ0lBZ29BaGdpREVrTkJpQUFLQUlZSWdsRkRRWWdDQ2dDRUNFT0lBQW9BZ0FoQ2tFQUlRSURRQUpBQWtBZ0NpQUNRU2hzYWlJSUtBSVVRUU5IRFFBZ0NDZ0NDQ0FNUncwQUlBaEJBRFlDRkNBQUlBQW9BaWhCZjJvMkFpZ2dDQ2dDR0EwQklBQWdBQ2dDTEVGL2FqWUNMQXdCQ3lBQ1FRRnFJZ0lnQ1VjTkFRc0xJQWxCQVNBSlFRRkxHeUVKSUFNZ0Rtc2hEa0VBSVFnRFFBSkFJQW9nQ0VFb2JHb2lBaWdDRkNJUFFYOXFRUUZOQkVBZ0FpZ0NDQ0FPUmcwQkN5QUlRUUZxSWdnZ0NVY05BUXdJQ3dzZ0NFRUFTQTBHSUE5QkFra05CaUFDUVFNMkFoUWdBaUFNTmdJSUlBdEJBV29oQ3d3RUN5QUFJQWdvQWh3aUNUWUNKQ0FBS0FJWUlneEZEUUlnQUNnQ0FDRUtRUUFoQWlBSlFmLy9BMFlFUUFOQUFrQWdDaUFDUVNoc2FpSUlLQUlVUVFOSERRQWdDRUVBTmdJVUlBQWdBQ2dDS0VGL2FqWUNLQ0FJS0FJWURRQWdBQ0FBS0FJc1FYOXFOZ0lzQ3lBQ1FRRnFJZ0lnREVjTkFBd0VBQXNBQ3dOQUFrQWdDaUFDUVNoc2FpSUlLQUlVUVFOSERRQWdDQ2dDQ0NBSlRRMEFJQWhCQURZQ0ZDQUFJQUFvQWloQmYybzJBaWdnQ0NnQ0dBMEFJQUFnQUNnQ0xFRi9hallDTEFzZ0FrRUJhaUlDSUF4SERRQUxEQUlMSUFBUUtDQUFRUUUyQWpSQkFDRURJQXRCQVdvaEN3d0NDeUFBS0FJa0lnSkIvLzhEUmcwRElBSWdDQ2dDR0NJTVNRMERJQUFvQWhnaUNrVU5BeUFBS0FJQUlRaEJBQ0VDQWtBRFFBSkFJQWdnQWtFb2JHb2lDU2dDRkVFRFJ3MEFJQWtvQWdnZ0RFY05BQ0FKUVFBMkFoUWdBQ0FBS0FJb1FYOXFJZ2cyQWlnZ0NTZ0NHQTBDSUFBZ0FDZ0NMRUYvYWpZQ0xBd0NDeUFDUVFGcUlnSWdDa2NOQUFzZ0FDZ0NLQ0VJQ3lBSUlBcFBEUU1nQUNnQ0NDSUNRUU0yQWhRZ0FpQUVOZ0lRSUFJZ0REWUNDQ0FDSUFNMkFnd2dBaUFBS0FJNFJUWUNHRUVCSVJBZ0FDQUlRUUZxTmdJb0lBQWdBQ2dDTEVFQmFqWUNMQXNnQzBFQmFpRUxEQUFBQ3dBTFFRQWhBaUFBS0FJb0lna2dBQ2dDR0NJTFNRMEJJQWxGQkVCQkFDRUpEQUlMSUFBb0FnQWhERUYvSVFFRFFDQU1JQUpCS0d4cUlnb29BaFJCZjJwQkFVMEVRQ0FLS0FJSUlnb2dDQ0FCUVg5R0lBb2dDRWh5SWdvYklRZ2dBaUFCSUFvYklRRUxJQUpCQVdvaUFpQUpSdzBBQ3lBQlFRQklEUUVnRENBQlFTaHNhaUlCUVFBMkFoUWdBQ0FKUVg5cUlnazJBaWdnQVNnQ0dBMEJJQUFnQUNnQ0xFRi9hallDTEF3QkN5QVFEUUVnQUNnQ0dDRUxJQUFvQWlnaENRc2dDU0FMVHcwQklBQW9BZ2dpQVNBTk5nSVlJQUZCQWpZQ0ZDQUJJQVEyQWhBZ0FTQUROZ0lJSUFFZ0F6WUNEQ0FBSUFsQkFXbzJBaWdnQUNBQUtBSXNRUUZxTmdJc0N3c2dBQ2dDQ0NJQklBYzJBaUFnQVNBR05nSWNJQUVnQlRZQ0pBSkFJQUFvQWpoRkJFQWdBQ2dDTENJSklBQW9BaHdpQTAwTkFTQUFLQUlBSVFRRFFFSC8vLy8vQnlFRlFRQWhCa0VBSVFJRFFDQUVJQUpCS0d4cUlnRW9BaGdFUUNBQklBWWdBU2dDRUNJQklBVklJZ2NiSVFZZ0FTQUZJQWNiSVFVTElBSkJBV29pQWlBRFRRMEFDd0pBSUFaRkRRQWdBQ2dDRENBQUtBSVFJZ0pCQkhScUlnRWdCaWdDQURZQ0FDQUJJQVlvQWlRMkFnd2dBU0FHS0FJY05nSUVJQUVnQmlnQ0lEWUNDQ0FBSUFKQkFXbzJBaEFnQmtFQU5nSVlJQVlvQWhRTkFDQUFJQWxCZjJvaUNUWUNMQXNnQ1NBRFN3MEFDd3dCQ3lBQktBSUFJUUlnQUNnQ0RDQUFLQUlRSWdOQkJIUnFJZ0VnQlRZQ0RDQUJJQUkyQWdBZ0FTQUhOZ0lJSUFFZ0JqWUNCQ0FBSUFOQkFXbzJBaEFnQUNnQ0hDRURDeUFBS0FJQUlBTkJBV29RSndzTDFBc0NBbjhCZmlNQVFaQUJheUlFSkFBZ0JFRUFOZ0lNQWtBQ1FBSkFJQUFvQXBBYVJRMEFJQUFvQXBRYUlBRkhEUUFnQkNBQVFhUWFhaWtDQURjREdDQUFLUUtjR2lFR0lBUkJBRFlDR0NBRUlBWTNBeEFnQkVFQU5nSWdJQVFnQmo0Q0ZDQURJQUFvQXBnYU5nSUFEQUVMUVFNaEJTQUJJQUlnQkVFUWFpQURFR1VOQVNBQUlBUXBBeEEzQXB3YUlBQkJyQnBxSUFRb0FpQTJBZ0FnQUVHa0dtb2dCQ2tER0RjQ0FDQURLQUlBSVFJZ0FDQUJOZ0tVR2lBQUlBSTJBcGdhQzBFQUlRVWdBRUVBTmdLUUdpQUVRUkJxSUFSQmlBRnFFRThFUUVFRElRVU1BUXNnQkNnQ2lBRkJmMnBCQzBzTkFDQUVRUkJxSUFSQmlBRnFJQUFnQkVFTWFoQXlJZ0VFUUVFRUlRVWdBVUh3L3dOR0RRRkJBeUVGREFFTEFrQWdCQ2dDREFSQUFrQWdBQ2dDb0FsRkRRQWdBQ2dDRUVVTkFFRURJUVVnQUNnQ3RCb05Bd0pBSUFBb0FxUUpSUVJBSUFCQnhBbHFJZ0lpQVNBQktBSUFJQUVvQWh4QktHeHFJZ0UyQWdnZ0FDQUJLQUlBTmdLNENpQUNFQ1lnQUNBQVFiZ0tha0VBRUNVTUFRc2dBQ0FBUWJnS2FpQUFRZHdLYWlnQ0FCQWxDeUFEUVFBMkFnQWdBRUVBTmdLY0NTQUFRUUUyQXBBYURBSUxJQUJCQURZQ25Ba2dBRUVBTmdLa0NRc2dCQ2dDaUFGQmYyb2lBVUVIU3cwQkFrQUNRQUpBSUFGQkFXc09Cd1FFQkFJRUFBRUNDeUFFUVJCcUlBUkJLR29RUXdSQUlBUW9BbEFRQkNBRVFRQTJBbEFnQkNnQ2ZCQUVJQVJCQURZQ2ZFRURJUVVNQkFzZ0FDQUVRU2hxRURjTUF3c2dCRUVRYWlBRVFTaHFFRXdFUUNBRUtBSThFQVFnQkVFQU5nSThJQVFvQWtBUUJDQUVRUUEyQWtBZ0JDZ0NSQkFFSUFSQkFEWUNSQ0FFS0FKVUVBUWdCRUVBTmdKVVFRTWhCUXdEQ3lBQUlBUkJLR29RTmd3Q0N5QUFLQUtjQ1EwQklBQkJBVFlDb0FrQ1FDQUFLQUtrQ1EwQUlBQkNBRGNDdEFrZ0JFRVFhaUFFUVNocUVDQWFJQUFvQWdnaEFTQUFJQVFvQWlnZ0JDZ0NpQUZCQlVZUU5TSUNCRUFnQUVLQWdvQ0FnQVEzQWdRZ0FFRUFOZ0swR2lBQVFnQTNBZ3hCQlVFRUlBSkIvLzhEUmhzaEJRd0RDeUFCSUFBb0FnaEdEUUFnQUNnQ0VDRUJJQVJCQVRZQ0NDQUFLQUlBSWdKQkgwMEVRQ0FBSUFKQkFuUnFLQUlVSVFVTElBTkJBRFlDQUNBQVFRRTJBcEFhQWtBQ1FBSkFJQVFvQW9nQlFRVkhEUUFnQkVFSWFpQUVRUkJxSUFFZ0FDZ0NEQkE0SUFRb0FnaHlEUUFnQlVVTkFDQUFRZndKYWlnQ0FBMEFJQVVvQWpRZ0FTZ0NORWNOQUNBRktBSTRJQUVvQWpoSERRQWdCU2dDV0NBQktBSllSZzBCQ3lBQVFZQUtha0VBTmdJQURBRUxJQUJCeEFscUVGa0xJQUFnQUNnQ0NEWUNBRUVDSVFVTUFnc2dBQ2dDdEJvRVFFRURJUVVNQWdzZ0JFRVFhaUFBUWJRU2FpSUNJQUFvQWhBZ0FDZ0NEQ0FFUVlnQmFoQStCRUJCQXlFRkRBSUxJQUFvQXFRSlJRUkFBa0FnQkNnQ2lBRkJCVVlOQUNBQVFjUUphaUFBUWNBU2FpZ0NBQ0FFS0FLTUFVRUFSeUFBS0FJUUtBSXdFRnBGRFFCQkF5RUZEQU1MSUFCQnhBbHFJZ0VnQVNnQ0FDQUJLQUljUVNoc2FpSUJOZ0lJSUFBZ0FTZ0NBRFlDdUFvTElBQkIyQXBxSUFKQjNBY1FGU0VCSUFCQkFUWUNwQWtnQUNBRUtRT0lBVGNDMEFvZ0FDZ0NsQWtnQUNnQ0RDQUFRWmdMYWlnQ0FDQUFLQUlRSWdJb0FqUWdBaWdDT0JBL0lBQkJ4QWxxSWdJUUppQUNJQUJCbkF0cUlBQkI1QXBxS0FJQUlBQkJoQXRxS0FJQUVGOEVRRUVESVFVTUFnc2dCRUVRYWlBQUlBQkJ1QXBxSUFFUVFRUkFJQUFnQUNnQzJBb1FRRUVESVFVTUFnc2dBQkF6UlEwQklBQkJBVFlDbkFrTElBQkJ1QXBxSWdFZ0FDZ0N2QWtRU1NBQUVEUWdBRUdFQ21vZ0FDZ0NFQ0FBUWRnS2FpQUFRZEFLYWhCTklRSUNRQ0FBS0FLa0NVVU5BQ0FBUWNRSmFpRURJQUJCMUFwcUtBSUFCRUFnQXlBQVFld01haUFCSUFCQjVBcHFLQUlBSUFJZ0FDZ0MwQXBCQlVZZ0FDZ0N1QWtnQUNnQ3RBa1FLUXdCQ3lBRFFRQWdBU0FBUWVRS2FpZ0NBQ0FDSUFBb0F0QUtRUVZHSUFBb0FyZ0pJQUFvQXJRSkVDa0xJQUJDQURjQ29BbEJBU0VGQ3lBRVFaQUJhaVFBSUFVTHFBd0JDMzhDUUNBQlFRUlBCRUJCQUNBRGF5SU5RUUYwSVFvQ1FDQUFJQU5ySWdVdEFBQWlCaUFBTFFBQUlnaHJJZ0VnQVVFZmRTSUJhaUFCY3lBQ0tBSUVJZ0ZQRFFBZ0FDQUthaTBBQUNJSElBWnJJZ1FnQkVFZmRTSUVhaUFFY3lBQ0tBSUlJZ3hQRFFBZ0FDQURhaTBBQUNJRUlBaHJJZ3NnQzBFZmRTSUxhaUFMY3lBTVR3MEFJQVVnQkNBR2FpQUhRUUYwYWtFQ2FrRUNkam9BQUNBQUlBZ2dCRUVCZEdvZ0IycEJBbXBCQW5ZNkFBQWdBaWdDQkNFQkN3SkFJQUJCQVdvaUJpQU5haUlNTFFBQUlnZ2dBQzBBQVNJSGF5SUVJQVJCSDNVaUJHb2dCSE1nQVU4TkFDQUdJQXBxTFFBQUlnUWdDR3NpQlNBRlFSOTFJZ1ZxSUFWeklBSW9BZ2dpQzA4TkFDQURJQVpxTFFBQUlnVWdCMnNpQ1NBSlFSOTFJZ2xxSUFseklBdFBEUUFnRENBRklBaHFJQVJCQVhScVFRSnFRUUoyT2dBQUlBWWdCeUFGUVFGMGFpQUVha0VDYWtFQ2Rqb0FBQ0FDS0FJRUlRRUxBa0FnQUVFQ2FpSUdJQTFxSWd3dEFBQWlDQ0FBTFFBQ0lnZHJJZ1FnQkVFZmRTSUVhaUFFY3lBQlR3MEFJQVlnQ21vdEFBQWlCQ0FJYXlJRklBVkJIM1VpQldvZ0JYTWdBaWdDQ0NJTFR3MEFJQU1nQm1vdEFBQWlCU0FIYXlJSklBbEJIM1VpQ1dvZ0NYTWdDMDhOQUNBTUlBVWdDR29nQkVFQmRHcEJBbXBCQW5ZNkFBQWdCaUFISUFWQkFYUnFJQVJxUVFKcVFRSjJPZ0FBSUFJb0FnUWhBUXNDUUNBQVFRTnFJZ1lnRFdvaURDMEFBQ0lJSUFBdEFBTWlCMnNpQkNBRVFSOTFJZ1JxSUFSeklBRlBEUUFnQmlBS2FpMEFBQ0lFSUFocklnVWdCVUVmZFNJRmFpQUZjeUFDS0FJSUlndFBEUUFnQXlBR2FpMEFBQ0lGSUFkcklna2dDVUVmZFNJSmFpQUpjeUFMVHcwQUlBd2dCU0FJYWlBRVFRRjBha0VDYWtFQ2Rqb0FBQ0FHSUFjZ0JVRUJkR29nQkdwQkFtcEJBblk2QUFBZ0FpZ0NCQ0VCQ3dKQUlBQkJCR29pQmlBTmFpSU1MUUFBSWdnZ0FDMEFCQ0lIYXlJRUlBUkJIM1VpQkdvZ0JITWdBVThOQUNBR0lBcHFMUUFBSWdRZ0NHc2lCU0FGUVI5MUlnVnFJQVZ6SUFJb0FnZ2lDMDhOQUNBRElBWnFMUUFBSWdVZ0Iyc2lDU0FKUVI5MUlnbHFJQWx6SUF0UERRQWdEQ0FGSUFocUlBUkJBWFJxUVFKcVFRSjJPZ0FBSUFZZ0J5QUZRUUYwYWlBRWFrRUNha0VDZGpvQUFDQUNLQUlFSVFFTEFrQWdBRUVGYWlJR0lBMXFJZ3d0QUFBaUNDQUFMUUFGSWdkcklnUWdCRUVmZFNJRWFpQUVjeUFCVHcwQUlBWWdDbW90QUFBaUJDQUlheUlGSUFWQkgzVWlCV29nQlhNZ0FpZ0NDQ0lMVHcwQUlBTWdCbW90QUFBaUJTQUhheUlKSUFsQkgzVWlDV29nQ1hNZ0MwOE5BQ0FNSUFVZ0NHb2dCRUVCZEdwQkFtcEJBblk2QUFBZ0JpQUhJQVZCQVhScUlBUnFRUUpxUVFKMk9nQUFJQUlvQWdRaEFRc0NRQ0FBUVFacUlnWWdEV29pREMwQUFDSUlJQUF0QUFZaUIyc2lCQ0FFUVI5MUlnUnFJQVJ6SUFGUERRQWdCaUFLYWkwQUFDSUVJQWhySWdVZ0JVRWZkU0lGYWlBRmN5QUNLQUlJSWd0UERRQWdBeUFHYWkwQUFDSUZJQWRySWdrZ0NVRWZkU0lKYWlBSmN5QUxUdzBBSUF3Z0JTQUlhaUFFUVFGMGFrRUNha0VDZGpvQUFDQUdJQWNnQlVFQmRHb2dCR3BCQW1wQkFuWTZBQUFnQWlnQ0JDRUJDeUFOSUFCQkIyb2lEV29pQ0MwQUFDSUdJQUF0QUFjaUFHc2lCeUFIUVI5MUlnZHFJQWR6SUFGUERRRWdDaUFOYWkwQUFDSUJJQVpySWdvZ0NrRWZkU0lLYWlBS2N5QUNLQUlJSWdwUERRRWdBeUFOYWkwQUFDSUNJQUJySWdNZ0EwRWZkU0lEYWlBRGN5QUtUdzBCSUFnZ0FpQUdhaUFCUVFGMGFrRUNha0VDZGpvQUFDQU5JQUFnQWtFQmRHb2dBV3BCQW1wQkFuWTZBQUFQQzBFQUlBTnJJZ2RCQVhRaEJDQUJJQUlvQWdCcVFYOXFMUUFBSWdGQkFXb2hCaUFCUVg5eklRaEJDQ0VCQTBBQ1FDQUFJQWRxSWdVdEFBQWlDaUFBTFFBQUlnMXJJZ3dnREVFZmRTSU1haUFNY3lBQ0tBSUVUdzBBSUFBZ0JHb3RBQUFpRENBS2F5SUxJQXRCSDNVaUMyb2dDM01nQWlnQ0NDSUxUdzBBSUFBZ0Eyb3RBQUFpQ1NBTmF5SU9JQTVCSDNVaURtb2dEbk1nQzA4TkFDQUZJQW9nQ0NBR0lBMGdDbXRCQW5RZ0NXc2dER3BCQkdwQkEzVWlDaUFLSUFaS0d5QUtJQWhJR3lJS2FrR3dMbW90QUFBNkFBQWdBQ0FOSUFwclFiQXVhaTBBQURvQUFBc2dBRUVCYWlFQUlBRkJmMm9pQVEwQUN3c0w2Z2dCQW44Z0FVRUFRYmdIRUFjaEFrRUJJUUVDUUFKQUlBQkJBUkFESWdOQmYwWU5BQ0FDSUFOQkFVWTJBZ0FDUUNBRFFRRkhEUUFnQUVFSUVBTWlBMEYvUmcwQklBSWdBellDQkNBRFFmOEJSdzBBSUFCQkVCQURJZ05CZjBZTkFTQUNJQU0yQWdnZ0FFRVFFQU1pQTBGL1JnMEJJQUlnQXpZQ0RBc2dBRUVCRUFNaUEwRi9SZzBBSUFJZ0EwRUJSallDRUNBRFFRRkdCRUFnQUVFQkVBTWlBMEYvUmcwQklBSWdBMEVCUmpZQ0ZBc2dBRUVCRUFNaUEwRi9SZzBBSUFJZ0EwRUJSallDR0FKQUFrQWdBMEVCUmdSQUlBQkJBeEFESWdOQmYwWU5BeUFDSUFNMkFod2dBRUVCRUFNaUEwRi9SZzBESUFJZ0EwRUJSallDSUNBQVFRRVFBeUlEUVg5R0RRTWdBaUFEUVFGR05nSWtJQU5CQVVjTkFTQUFRUWdRQXlJRFFYOUdEUU1nQWlBRE5nSW9JQUJCQ0JBRElnTkJmMFlOQXlBQ0lBTTJBaXdnQUVFSUVBTWlBMEYvUncwQ0RBTUxJQUpCQlRZQ0hBc2dBa0tDZ0lDQUlEY0NLRUVDSVFNTElBSWdBellDTUNBQVFRRVFBeUlEUVg5R0RRQWdBaUFEUVFGR05nSTBBa0FnQTBFQlJ3MEFJQUFnQWtFNGFoQUNJZ0VOQVNBQ0tBSTRRUVZMRFFJZ0FDQUNRVHhxRUFJaUFRMEJJQUlvQWp4QkJVME5BQXdDQzBFQklRRWdBRUVCRUFNaUEwRi9SZzBBSUFJZ0EwRUJSallDUUNBRFFRRkdCRUFnQUJBUElRRWdBRUVnRUFzaEF5QUJSUTBDSUFOQmYwWU5BaUFDSUFFMkFrUWdBQkFQSVFFZ0FFRWdFQXNoQXlBQlJRMENJQU5CZjBZTkFpQUNJQUUyQWtoQkFTRUJJQUJCQVJBRElnTkJmMFlOQVNBQ0lBTkJBVVkyQWt3TElBQkJBUkFESWdOQmYwWU5BQ0FDSUFOQkFVWTJBbEFDUUNBRFFRRkdCRUFnQUNBQ1FkUUFhaEFjSWdGRkRRRU1BZ3NnQWtFQk5nSlVJQUpDbUlDQWdJQUROd0xvQXlBQ1FwaUFnSUNBQXpjQzRBTWdBa0dCa0txSkFUWUM0QUVnQWtHQmtLcUpBVFlDWUF0QkFTRUJJQUJCQVJBRElnTkJmMFlOQUNBQ0lBTkJBVVkyQXZBREFrQWdBMEVCUmdSQUlBQWdBa0gwQTJvUUhDSUJSUTBCREFJTElBSkJBVFlDOUFNZ0FrS1lnSUNBZ0FNM0FvZ0hJQUpDbUlDQWdJQUROd0tBQnlBQ1FZRzR1UElBTmdLQUJTQUNRWUc0dVBJQU5nS0FCQXNDUUNBQ0tBSlFSUVJBSUFJb0F2QURSUTBCQzBFQklRRWdBRUVCRUFNaUEwRi9SZzBCSUFJZ0EwRUJSallDa0FjTFFRRWhBU0FBUVFFUUF5SURRWDlHRFFBZ0FpQURRUUZHTmdLVUJ5QUFRUUVRQXlJRFFYOUdEUUFnQWlBRFFRRkdOZ0tZQndKQUlBTkJBVVlFUUNBQVFRRVFBeUlEUVg5R0RRSWdBaUFEUVFGR05nS2NCeUFBSUFKQm9BZHFFQUlpQVEwQ0lBSW9BcUFIUVJCTERRTWdBQ0FDUWFRSGFoQUNJZ0VOQWlBQ0tBS2tCMEVRU3cwRElBQWdBa0dvQjJvUUFpSUJEUUlnQWlnQ3FBZEJFRXNOQXlBQUlBSkJyQWRxRUFJaUFRMENRUUVoQVNBQ0tBS3NCMEVRU3cwQ0lBQWdBa0d3QjJvUUFpSUJEUUlnQUNBQ1FiUUhhaEFDSWdGRkRRRU1BZ3NnQWtFUU5nSzBCeUFDUXBDQWdJQ0FBamNDckFjZ0FrS0JnSUNBZ0FJM0FxUUhJQUpDZ1lDQWdDQTNBcHdIQzBFQUlRRUxJQUVQQzBFQkMwMEJBbjhqQUVFUWF5SURKQUJCQVNFRUFrQWdBQ0FEUVF4cUVBSU5BQ0FES0FJTUlnQkJMMHNOQUNBQlFkQS9RWURBQUNBQ0d5QUFhaTBBQURZQ0FFRUFJUVFMSUFOQkVHb2tBQ0FFQ3o0QkFuOENRQ0FBS0FJTVFRTjBJQUFvQWhCcklnRkZCRUFNQVF0QkFTRUNJQUZCQ0VzTkFFRUJJQUZCZjJwMElBQVFEMEVnSUFGcmRrY1BDeUFDQ3pJQkFuOENRRUdBZ0lEQUFDSUJJQUJ4RFFBRFFDQUNRUUZxSVFJZ0FVRUJkaUlCUlEwQklBQWdBWEZGRFFBTEN5QUNDNG9DQVFkL0lBRkJvRDFxTFFBQVFReHNRZEE4YWlnQ0FDRUNRUUVoQXlBQlFRWlBCRUJCQUNFRElBSWdBVUdRUEdvdEFBQkJmMnAwSVFJTElBQWdBQ2dDQUNJQklBQW9BZ2dpQkdzaUJTQUFLQUlFSWdZZ0FDZ0NEQ0lIYXlJSWF5QUNiQ0FEZFRZQ0RDQUFJQVVnQ0dvZ0Ftd2dBM1UyQWdnZ0FDQUJJQVJxSWdFZ0JpQUhhaUlFYXlBQ2JDQURkVFlDQkNBQUlBRWdCR29nQW13Z0EzVTJBZ0FnQUNBQUtBSWNJZ0VnQUNnQ0ZDSUVhaUlGSUFBb0FoZ2lCaUFBS0FJUUlnZHFJZ2hxSUFKc0lBTjFOZ0lRSUFBZ0JDQUJheUlCSUFjZ0Jtc2lCR29nQW13Z0EzVTJBaGdnQUNBSUlBVnJJQUpzSUFOMU5nSVVJQUFnQkNBQmF5QUNiQ0FEZFRZQ0hBdlBDQUVVZnlBQUlBQW9BaXdpQWlBQUtBSU1JZ1pxSWdVZ0FDZ0NOQ0lFSUFBb0FpQWlFR29pQ21zaUVUWUNMQ0FBS0FJb0lRTWdBQ0FHSUFKcklnY2dFQ0FFYXlJRWF5SUdOZ0lvSUFBb0FpUWhBaUFBSUFRZ0Iyb2lCRFlDSkNBQUlBVWdDbW9pQlRZQ0lDQUFJQUFvQWh3aUNpQUFLQUlJSWdkcUlnZ2dBQ2dDTUNJTUlBQW9BaEFpQ1dvaUMyc2lFRFlDSENBQUtBSVlJUThnQUNBSElBcHJJZ2NnQ1NBTWF5SU1heUlLTmdJWUlBQW9BaFFoQ1NBQUlBY2dER29pQnpZQ0ZDQUFJQWdnQzJvaUNEWUNFQ0FBSUFrZ0FDZ0NBQ0lMYWlJU0lBOGdBQ2dDQkNJTmFpSU9heUlNTmdJTUlBQWdDeUFKYXlJSklBMGdEMnNpQzJzaUR6WUNDQ0FBSUFrZ0Myb2lDVFlDQkNBQUlBNGdFbW9pQ3pZQ0FDQUFJQUlnQUNnQ09DSU5haUlUSUFNZ0FDZ0NQQ0lPYWlJVWF5SVNOZ0k4SUFBZ0FpQU5heUlDSUFNZ0Rtc2lBMnNpRFRZQ09DQUFJQUlnQTJvaURqWUNOQ0FBSUJNZ0ZHb2lFellDTUNBQlFaQThhaTBBQUNFQ0lBRkJvRDFxTFFBQVFReHNRZEE4YWlnQ0FDRURJQUZCREU4RVFDQUFJQU1nQWtGK2FuUWlBU0FGSUF0cUlnTWdDQ0FUYWlJQ2EydzJBakFnQUNBTElBVnJJZ1VnQ0NBVGF5SUlheUFCYkRZQ0lDQUFJQVVnQ0dvZ0FXdzJBaEFnQUNBQ0lBTnFJQUZzTmdJQUlBQWdCQ0FKYWlJRElBY2dEbW9pQW1zZ0FXdzJBalFnQUNBSklBUnJJZ1FnQnlBT2F5SUZheUFCYkRZQ0pDQUFJQVFnQldvZ0FXdzJBaFFnQUNBQ0lBTnFJQUZzTmdJRUlBQWdCaUFQYWlJRElBb2dEV29pQW1zZ0FXdzJBamdnQUNBUElBWnJJZ1lnQ2lBTmF5SUVheUFCYkRZQ0tDQUFJQVFnQm1vZ0FXdzJBaGdnQUNBQ0lBTnFJQUZzTmdJSUlBQWdEQ0FSYXlJRElCQWdFbXNpQW1zZ0FXdzJBaXdnQUNBQ0lBTnFJQUZzTmdJY0lBQWdFQ0FTYWlJRElBd2dFV29pQW1vZ0FXdzJBZ3dnQUNBQ0lBTnJJQUZzTmdJOER3c2dBRUVCUVFJZ0FVRjZha0VHU1JzaUFTQUZJQXRxSWhRZ0NDQVRhaUlWYXlBRGJHcEJBaUFDYXlJQ2RUWUNNQ0FBSUFzZ0JXc2lCU0FJSUJOcklnaHJJQU5zSUFGcUlBSjFOZ0lnSUFBZ0JTQUlhaUFEYkNBQmFpQUNkVFlDRUNBQUlCUWdGV29nQTJ3Z0FXb2dBblUyQWdBZ0FDQUVJQWxxSWdVZ0J5QU9haUlJYXlBRGJDQUJhaUFDZFRZQ05DQUFJQWtnQkdzaUJDQUhJQTVySWdkcklBTnNJQUZxSUFKMU5nSWtJQUFnQkNBSGFpQURiQ0FCYWlBQ2RUWUNGQ0FBSUFVZ0NHb2dBMndnQVdvZ0FuVTJBZ1FnQUNBR0lBOXFJZ1FnQ2lBTmFpSUZheUFEYkNBQmFpQUNkVFlDT0NBQUlBOGdCbXNpQmlBS0lBMXJJZ3BySUFOc0lBRnFJQUoxTmdJb0lBQWdCaUFLYWlBRGJDQUJhaUFDZFRZQ0dDQUFJQVFnQldvZ0Eyd2dBV29nQW5VMkFnZ2dBQ0FNSUJGcklnWWdFQ0FTYXlJRWF5QURiQ0FCYWlBQ2RUWUNMQ0FBSUFRZ0Jtb2dBMndnQVdvZ0FuVTJBaHdnQUNBUUlCSnFJZ1lnRENBUmFpSVJhaUFEYkNBQmFpQUNkVFlDRENBQUlCRWdCbXNnQTJ3Z0FXb2dBblUyQWp3THZRVUJCbjhqQUVFZ2F5SUZKQUFnQTBFQU5nSUFBa0FnQVNnQ0FDSUdRUkpMRFFCQkFTQUdkQ0lHUWNEZkgzRkZCRUFnQmtFaWNVVU5BU0FDUWJRS2FpZ0NBQVJBSUFOQkFUWUNBQ0FDUVFBMkFyUUtDeUFBSUFWQkhHb1FJQ0lFRFFGQjhQOERJUVFnQWlBRktBSWNRUUowYWlnQ2xBRWlDRVVOQVNBQ0lBZ29BZ1FpQmtFQ2RHb29BaFFpQjBVTkFRSkFJQUlvQWdnaUNVRWdSZzBBSUFZZ0NVWU5BQ0FCS0FJQVFRVkhEUUlMQWtBZ0FrR1lDbW9vQWdBaUJDQUJLQUlFSWdaR0RRQWdCRUVBSUFZYkRRQWdBMEVCTmdJQUN5QUJLQUlBSVFRQ1FBSkFJQUlvQXBRS1FRVkdCRUFnQkVFRlJ3MEJEQUlMSUFSQkJVY05BUXNnQTBFQk5nSUFDMEVCSVFRZ0FDQUhLQUlNSUFWQkdHb1FQUTBCSUFVb0FoZ2lCaUFDUVp3S2FpZ0NBRWNFUUNBQ0lBWTJBcHdLSUFOQkFUWUNBQXNnQVNnQ0FFRUZSZ1JBSUFBZ0J5Z0NEQ0FGUVJScUVEd05BZ0pBSUFJb0FwUUtRUVZIQkVBZ0JTZ0NGQ0VFREFFTElBSkJvQXBxS0FJQUlnUWdCU2dDRkNJR1JnMEFJQU5CQVRZQ0FDQUdJUVFMSUFKQm9BcHFJQVEyQWdBTEFrQWdCeWdDRUNJRVFRRkxEUUFnQkVFQmF3UkFRUUVoQkNBQUlBY2dBU2dDQUNBRlFRaHFFRHNOQXlBRktBSUlJZ1FnQWtHa0Ntb29BZ0JIQkVBZ0FpQUVOZ0trQ2lBRFFRRTJBZ0FMSUFnb0FnaEZEUUVnQUNBSElBRW9BZ0FnQlVFUWFoQTZJZ1FOQXlBRktBSVFJZ0FnQWtHb0Ntb29BZ0JHRFFFZ0FpQUFOZ0tvQ2lBRFFRRTJBZ0FNQVFzZ0J5Z0NHQTBBSUFBZ0J5QUJLQUlBSUFnb0FnZ2dCVUVJYWhBNUlnUU5BaUFGS0FJSUlnQWdBa0dzQ21vb0FnQkhCRUFnQWlBQU5nS3NDaUFEUVFFMkFnQUxJQWdvQWdoRkRRQWdCU2dDRENJQUlBSkJzQXBxS0FJQVJnMEFJQUlnQURZQ3NBb2dBMEVCTmdJQUN5QUNJQUVwQWdBM0FwUUtRUUFoQkF3QkN5QURRUUUyQWdBTElBVkJJR29rQUNBRUMzOEJBMzhDUUFKQUFrQWdBRUg4Q21vb0FnQUVRQ0FBS0FLWUNTSUREUUZCQVE4TFFRRWhBU0FBUWF3SmFpZ0NBQ0FBS0FLWUNVY05BUXdDQ3lBQUtBSzhDU0VCUVFBaEFBTkFJQUlnQVNBQVFkZ0JiR29vQXNRQlFRQkhhaUVDSUFCQkFXb2lBQ0FEUncwQUMwRUJJUUVnQWlBRFJnMEJDMEVBSVFFTElBRUxTZ0VEZnlBQVFnQTNBcWdKSUFBb0FwZ0pJZ0VFUUNBQUtBSzhDU0VDUVFBaEFBTkFJQUlnQUVIWUFXeHFJZ05CQURZQ3hBRWdBMEVBTmdJRUlBQkJBV29pQUNBQlJ3MEFDd3NMZ3dZQkRIOUJBU0VHQWtBZ0FDQUJRUUowYWlnQ2xBRWlCRVVOQUNBQUlBUW9BZ1FpQ1VFQ2RHb2lDa0VVYWlnQ0FDSURSUTBBQWtBZ0JDZ0NEQ0lGUVFKSkRRQWdBeWdDTkNJSElBTW9BamhzSVFnQ1FDQUVLQUlRSWdOQkFrc05BQUpBQWtBQ1FDQURRUUZyRGdJREFBRUxJQVZCZjJvaEN5QUVLQUljSVF3Z0JDZ0NHQ0VOUVFBaEF3d0JDeUFFS0FJVUlRZEJBQ0VEQTBBZ0J5QURRUUowYWlnQ0FDQUlUUVJBSUFVZ0EwRUJhaUlEUncwQkRBUUxDMEVCRHdzRFFDQU5JQU5CQW5RaUJXb29BZ0FpRGlBRklBeHFLQUlBSWdWTERRTWdCU0FJVHcwRElBNGdCM0FnQlNBSGNFMEVRQ0FEUVFGcUlnTWdDMFlOQXd3QkN3dEJBUThMSUFOQmZXcEJBazBFUUNBRUtBSWtJQWhORFFFTUFnc2dBMEVHUncwQUlBUW9BaWdnQ0VrTkFRc0NRQ0FBS0FJRUlnTkJnQUpHQkVBZ0FDQUVOZ0lNSUFBZ0FUWUNCQ0FBSUFrMkFnZ2dBQ0FLS0FJVUlnRTJBaEFnQVNnQ05DRUNJQUVvQWpnaEFTQUFRUUUyQXJRYUlBQkJ3QXBxSUFFMkFnQWdBRUc4Q21vZ0FqWUNBQ0FBSUFFZ0FtdzJBcGdKREFFTElBQW9BclFhQkVBZ0FFRUFOZ0swR2lBQUtBSzhDUkFFSUFCQkFEWUN2QWtnQUNnQ2xBa1FCQ0FBSUFBb0FwZ0pJZ0ZCMkFGc0lnUVFDaUlDTmdLOENTQUFJQUZCQW5RUUNpSUROZ0tVQ1VILy93TWhCaUFDUlEwQ0lBTkZEUUlnQWtFQUlBUVFCeUFBS0FJUUtBSTBJQUVRVGlBQUtBSVFJUUZCQVNFQ0FrQWdBQ2dDd0FrTkFDQUJLQUlRUVFKR0RRQUNRQ0FCS0FKUVJRMEFJQUVvQWxRaUJDZ0NtQWRGRFFBZ0JDZ0NzQWRGRFFFTFFRQWhBZ3NnQUVIRUNXb2dBU2dDT0NBQktBSTBiQ0FCS0FKWUlBRW9BaXdnQVNnQ0RDQUNFRndpQmtVTkFRd0NDeUFCSUFOR0RRQWdBQ2dDQ0NBSlJ3UkFJQUpGRFFJZ0FDQUVOZ0lNSUFBZ0FUWUNCQ0FBSUFrMkFnZ2dBQ0FLS0FJVUlnRTJBaEFnQVNnQ05DRUNJQUVvQWpnaEFTQUFRUUUyQXJRYUlBQkJ3QXBxSUFFMkFnQWdBRUc4Q21vZ0FqWUNBQ0FBSUFFZ0FtdzJBcGdKREFFTElBQWdCRFlDRENBQUlBRTJBZ1FMUVFBaEJnc2dCZ3UyQVFFRGZ3SkFJQUFnQVNnQ0FDSURRUUowYWlJQ0tBS1VBU0lFUlFSQUlBSkJ5QUFRQ2lJQU5nS1VBU0FBRFFFUEN3SkFJQU1nQUNnQ0JFY05BQ0FCS0FJRUlBQW9BZ2hHRFFBZ0FFR0JBallDQkFzZ0JDZ0NGQkFFSUFJb0FwUUJRUUEyQWhRZ0FpZ0NsQUVvQWhnUUJDQUNLQUtVQVVFQU5nSVlJQUlvQXBRQktBSWNFQVFnQWlnQ2xBRkJBRFlDSENBQ0tBS1VBU2dDTEJBRUlBSW9BcFFCUVFBMkFpd0xJQUlvQXBRQklBRkJ5QUFRRlJvTDFnRUJBMzhDUUNBQUlBRW9BZ2dpQTBFQ2RHb2lBaWdDRkNJRVJRUkFJQUpCM0FBUUNpSUFOZ0lVSUFBTkFROExJQUFvQWdnZ0EwWUVRQ0FCSUFBb0FoQVFRZ1JBSUFJb0FoUW9BaWdRQkNBQ0tBSVVRUUEyQWlnZ0FpZ0NGQ2dDVkJBRUlBSW9BaFJCQURZQ1ZDQUFRUUEyQWhBZ0FFR0JBallDQkNBQVFpRTNBZ2dNQWdzZ0FTZ0NLQkFFSUFGQkFEWUNLQ0FCS0FKVUVBUWdBVUVBTmdKVUR3c2dCQ2dDS0JBRUlBSW9BaFJCQURZQ0tDQUNLQUlVS0FKVUVBUWdBaWdDRkVFQU5nSlVDeUFDS0FJVUlBRkIzQUFRRlJvTDBnSUJBMzhqQUVFZ2F5SUVKQUFnQkNBQktBSVFOZ0lRSUFRZ0FTa0NDRGNEQ0NBRUlBRXBBZ0EzQXdBQ1FDQUVJQVJCSEdvUUFpSUJEUUFnQkNBRVFSeHFFQUlpQVEwQUlBUWdCRUVjYWhBQ0lnRU5BQ0FDS0FJTUlRWkJBQ0VCQTBBZ0FTSUZRUUZxSVFFZ0JpQUZkZzBBQ3lBRUlBVkJmMm9RQTBGL1JnUkFRUUVoQVF3QkN5QUVJQVJCSEdvUUFpSUJEUUFDUUNBQ0tBSVFJZ0VFZnlBQkJTQUNLQUlVSVFaQkFDRUJBMEFnQVNJRlFRRnFJUUVnQmlBRmRnMEFDeUFFSUFWQmYyb1FBMEYvUmdSQVFRRWhBUXdEQ3lBREtBSUlCRUFnQkNBRVFSaHFFQVVpQVEwREN5QUNLQUlRQzBFQlJ3MEFJQUlvQWhnTkFDQUVJQVJCR0dvUUJTSUJEUUVnQXlnQ0NFVU5BQ0FFSUFSQkdHb1FCU0lCRFFFTElBTW9Ba1FFUUNBRUlBUkJIR29RQWlJQkRRRUxJQUFnQkVFQkVBTWlBRFlDQUNBQVFYOUdJUUVMSUFSQklHb2tBQ0FCQzhZQkFRSi9Jd0JCSUdzaUJTUUFJQVVnQUNnQ0VEWUNFQ0FGSUFBcEFnZzNBd2dnQlNBQUtRSUFOd01BQWtBZ0JTQUZRUnhxRUFJaUFBMEFJQVVnQlVFY2FoQUNJZ0FOQUNBRklBVkJIR29RQWlJQURRQWdBU2dDRENFR1FRQWhBQU5BSUFBaUFVRUJhaUVBSUFZZ0FYWU5BQXNnQlNBQlFYOXFFQU5CZjBZRVFFRUJJUUFNQVFzZ0FrRUZSZ1JBSUFVZ0JVRWNhaEFDSWdBTkFRc2dCU0FFRUFVaUFBMEFJQU1FUUNBRklBUkJCR29RQlNJQURRRUxRUUFoQUFzZ0JVRWdhaVFBSUFBTDRRRUJBMzhqQUVFZ2F5SUVKQUFnQkNBQUtBSVFOZ0lRSUFRZ0FDa0NDRGNEQ0NBRUlBQXBBZ0EzQXdBQ1FDQUVJQVJCSEdvUUFpSUFEUUFnQkNBRVFSeHFFQUlpQUEwQUlBUWdCRUVjYWhBQ0lnQU5BQ0FCS0FJTUlRWkJBQ0VBQTBBZ0FDSUZRUUZxSVFBZ0JpQUZkZzBBQ3lBRUlBVkJmMm9RQTBGL1JnUkFRUUVoQUF3QkN5QUNRUVZHQkVBZ0JDQUVRUnhxRUFJaUFBMEJDeUFCS0FJVUlRSkJBQ0VBQTBBZ0FDSUJRUUZxSVFBZ0FpQUJkZzBBQ3lBRUlBRkJmMm9RQTBGL1JnUkFRUUVoQUF3QkN5QUVJQU1RQlNFQUN5QUVRU0JxSkFBZ0FBdm1BUUVEZnlNQVFTQnJJZ1FrQUNBRUlBQW9BaEEyQWhBZ0JDQUFLUUlJTndNSUlBUWdBQ2tDQURjREFBSkFJQVFnQkVFY2FoQUNJZ0FOQUNBRUlBUkJIR29RQWlJQURRQWdCQ0FFUVJ4cUVBSWlBQTBBSUFFb0Fnd2hCa0VBSVFBRFFDQUFJZ1ZCQVdvaEFDQUdJQVYyRFFBTElBUWdCVUYvYWhBRFFYOUdCRUJCQVNFQURBRUxJQUpCQlVZRVFDQUVJQVJCSEdvUUFpSUFEUUVMSUFFb0FoUWhBa0VBSVFBRFFDQUFJZ0ZCQVdvaEFDQUNJQUYyRFFBTElBUWdBVUYvYWhBRElnQkJmMFlFUUVFQklRQU1BUXNnQXlBQU5nSUFRUUFoQUFzZ0JFRWdhaVFBSUFBTGtnRUJBbjhqQUVFZ2F5SURKQUFnQXlBQUtBSVFOZ0lRSUFNZ0FDa0NBRGNEQUNBRElBQXBBZ2czQXdnQ1FDQURJQU5CSEdvUUFpSUFEUUFnQXlBRFFSeHFFQUlpQUEwQUlBTWdBMEVjYWhBQ0lnQU5BRUVBSVFBRFFDQUFJZ1JCQVdvaEFDQUJJQVIyRFFBTElBTWdCRUYvYWhBRFFYOUdCRUJCQVNFQURBRUxJQU1nQWhBQ0lRQUxJQU5CSUdva0FDQUFDNWNCQVFKL0l3QkJJR3NpQXlRQUlBTWdBQ2dDRURZQ0VDQURJQUFwQWdnM0F3Z2dBeUFBS1FJQU53TUFBa0FnQXlBRFFSeHFFQUlpQUEwQUlBTWdBMEVjYWhBQ0lnQU5BQ0FESUFOQkhHb1FBaUlBRFFCQkFDRUFBMEFnQUNJRVFRRnFJUUFnQVNBRWRnMEFDeUFESUFSQmYyb1FBeUlBUVg5R0JFQkJBU0VBREFFTElBSWdBRFlDQUVFQUlRQUxJQU5CSUdva0FDQUFDNjhPQVFwL0l3QkJFR3NpQlNRQUlBRkJBRUhjQnhBSElRY2dBaWdDTkNFR0lBSW9BamdoQ0FKQUlBQWdCVUVFYWhBQ0lnRU5BQ0FISUFVb0FnUWlBVFlDQUNBQklBWWdDR3dpQzA4RVFFRUJJUUVNQVFzZ0FDQUZRUVJxRUFJaUFRMEFJQWNnQlNnQ0JDSUdOZ0lFSUFaQkIwc0VRRUVCSVFFTUFRdEJBU0VCQWtBQ1FDQUdRUUZyRGdjQ0FRSUNBQUlCQUFzZ0JDZ0NBRUVGUmdSQURBSUxJQUlvQWl3TkFBd0JDeUFBSUFWQkJHb1FBaUlCRFFBZ0J5QUZLQUlFSWdZMkFnaEJBU0VCSUFZZ0F5Z0NBRWNOQUNBQ0tBSU1JUWhCQUNFQkEwQWdBU0lHUVFGcUlRRWdDQ0FHZGcwQUMwRUJJUUVnQUNBR1FYOXFFQU1pQmtGL1JnMEFJQVpCQUNBRUtBSUFJZ2hCQlVZYkRRQWdCeUFHTmdJTUlBaEJCVVlFUUNBQUlBVkJCR29RQWlJQkRRRWdCeUFGS0FJRUlnWTJBaEJCQVNFQklBWkIvLzhEU3cwQkN3SkFJQUlvQWhBaUFRUi9JQUVGSUFJb0FoUWhDRUVBSVFFRFFDQUJJZ1pCQVdvaEFTQUlJQVoyRFFBTElBQWdCa0YvYWhBRElnRkJmMFlFUUVFQklRRU1Bd3NnQnlBQk5nSVVJQU1vQWdnRVFDQUFJQVVRQlNJQkRRTWdCeUFGS0FJQU5nSVlDeUFFS0FJQVFRVkdCRUJCQVNFQklBY29BaFFpQmlBQ0tBSVVRUUYyU3cwRElBWkJBQ0FIS0FJWUlnaEJIM1VnQ0hGclJ3MERDeUFDS0FJUUMwRUJSdzBBSUFJb0FoZ05BQ0FBSUFVUUJTSUJEUUVnQnlBRktBSUFOZ0ljSUFNb0FnZ0VRQ0FBSUFVUUJTSUJEUUlnQnlBRktBSUFOZ0lnQ3lBRUtBSUFRUVZIRFFCQkFTRUJJQWNvQWh3aUJpQUhLQUlnSUFZZ0FpZ0NJR3BxSWdnZ0JpQUlTQnNOQVFzZ0F5Z0NSQVJBSUFBZ0JVRUVhaEFDSWdFTkFTQUhJQVVvQWdRaUJqWUNKRUVCSVFFZ0JrSC9BRXNOQVFzQ1FDQUhLQUlFSWdGQkJVc05BQUpBSUFGQkFXc09CQUVCQVFFQUMwRUJJUUVnQUVFQkVBTWlCa0YvUmcwQklBY2dCallDS0FKQUlBWUVRQ0FBSUFWQkJHb1FBaUlCRFFOQkFTRUJJQVVvQWdRaUJrRVBTdzBESUFaQkFXb2hCZ3dCQ3lBREtBSXdJZ1pCRUVzTkFnc2dCeUFHTmdJc0lBY29BZ1FoQVFzQ1FDQUJRUVZMRFFBQ1FDQUJRUUZyRGdRQkFRRUJBQXNnQWlnQ0RDRUpJQWNvQWl3aENrRUJJUUVnQUVFQkVBTWlCa0YvUmcwQklBY2dCallDUkNBR1JRMEFRUUFoQVFOQUlBRWlCaUFLU3dSQVFRRWhBUXdEQ3lBQUlBVkJDR29RQWlJQkRRSWdCU2dDQ0NJQlFRTkxCRUJCQVNFQkRBTUxJQWNnQmtFTWJHb2lDQ0FCTmdKSUFrQWdBVUVCVFFSQUlBQWdCVUVNYWhBQ0lnRU5CQ0FGS0FJTUlnRWdDVThFUUVFQklRRU1CUXNnQ0NBQlFRRnFOZ0pNREFFTElBRkJBa2NOQUNBQUlBVkJER29RQWlJQkRRTWdDQ0FGS0FJTU5nSlFDeUFHUVFGcUlRRWdCU2dDQ0VFRFJ3MEFDMEVCSVFFZ0JrVU5BUXNDUUNBRUtBSUVSUTBBSUFRb0FnQWhCQ0FDS0FJc0lRbEJBU0VCSUFCQkFSQURJUUlnQkVFRlJnUkFJQUpCZjBZTkFpQUhJQUkyQXBRQ0lBQkJBUkFESWdKQmYwWU5BaUFISUFJMkFwZ0NJQWtOQVNBQ1JRMEJEQUlMSUFKQmYwWU5BU0FISUFJMkFwd0NJQUpGRFFBZ0NVRUJkRUVEYWlFT1FRQWhCa0VBSVFwQkFDRUVBMEFnQmlBT1JnUkFRUUVoQVF3REN5QUFJQVZCQ0dvUUFpSUJEUUlnQlNnQ0NDSUNRUVpMQkVCQkFTRUJEQU1MSUFjZ0JrRVViR29pQ0NBQ05nS2dBZ0ovSUFKQmZYRkJBVVlFUUNBQUlBVkJER29RQWlJQkRRUWdDQ0FGS0FJTVFRRnFOZ0trQWlBRktBSUlJUUlMSUFKQkFrWUxCRUFnQUNBRlFReHFFQUlpQVEwRElBZ2dCU2dDRERZQ3FBSWdCU2dDQ0NFQ0N3SkFJQUpCZldvaUFVRURTdzBBQWtBZ0FVRUJhdzRDQVFFQUN5QUFJQVZCREdvUUFpSUJEUU1nQ0NBRktBSU1OZ0tzQWlBRktBSUlJUUlMSUFKQkJFWUVRQ0FBSUFWQkRHb1FBaUlCRFFNZ0JTZ0NEQ0lCSUFsTEJFQkJBU0VCREFRTElBZ2dBVUYvYWtILy93TWdBUnMyQXJBQ0lBcEJBV29oQ2lBRktBSUlJUUlMSUFaQkFXb2hCaUFNSUFKQkJrWnFJUXdnQkNBQ1FRVkdhaUVFSUEwZ0FrRi9ha0VEU1dvaERTQUNEUUFMUVFFaEFTQUVJQXB5SUF4eVFRRkxEUUVnQkVVTkFDQU5EUUVMSUFBZ0JSQUZJZ0VOQUNBSElBVW9BZ0FpQVRZQ01DQUZJQUVnQXlnQ05Hb2lBallDQUVFQklRRWdBa0V6U3cwQUFrQWdBeWdDUEVVTkFDQUFJQVZCQkdvUUFpSUJEUUVnQnlBRktBSUVJZ0kyQWpSQkFTRUJJQUpCQWtzTkFTQUNRUUZHRFFBZ0FDQUZFQVVpQVEwQlFRRWhBU0FGS0FJQUlnSkJCbXBCREVzTkFTQUhJQUpCQVhRMkFqZ2dBQ0FGRUFVaUFRMEJRUUVoQVNBRktBSUFJZ0pCQm1wQkRFc05BU0FISUFKQkFYUTJBandMQWtBZ0F5Z0NERUVDU1EwQUlBTW9BaEJCZldwQkFrc05BRUVDUVFFZ0N5QUxJQU1vQWlRaUFXNGlBaUFCYkdzYklBSnFJUVJCQUNFQ0EwQWdCQ0FDSWdGQkFXb2lBbllOQUFzZ0JTQUFJQUlnQVNBRVFYOGdBWFJCZjNOeEd4QURJZ0EyQWdSQkFTRUJJQUJCZjBZTkFTQUhJQUEyQWtBZ0FDQUxJQU1vQWlRaUFHcEJmMm9nQUc1TERRRUxRUUFoQVFzZ0JVRVFhaVFBSUFFTHdRa0JEWDhnQXlBRWJDRUZJQUVvQWd3aUNVRUJSZ1JBSUFCQkFDQUZRUUowRUFjYUR3c0NRQUpBQWtBQ1FDQUJLQUlRSWdaQmZXcEJBazBFUUNBQktBSWtJQUpzSWdJZ0JTQUNJQVZKR3lFTElBWkJmbkZCQkVjTkFTQUZJQXRySUFzZ0FTZ0NJQnNoQndzQ1FBSkFBa0FnQmtFRlRRUkFJQVpCQVdzT0JRWUZCQU1DQVFzZ0JVVU5CaUFCS0FJc0lRSkJBQ0VCQTBBZ0FDQUJRUUowSWdOcUlBSWdBMm9vQWdBMkFnQWdBVUVCYWlJQklBVkhEUUFMREFZTEFrQWdDUVJBSUFFb0FoUWhBa0VBSVFZTUFRc2dCVVVOQmdOQURBQUFDd0FMQTBCQkFDRUVJQVlnQlU4TkJnTkFRUUFoQndKQUlBSWdCRUVDZEdvaUF5Z0NBQ0lCUlEwQUlBRWhCeUFGSUFaTkRRQkJBQ0VCUVFBZ0JTQUdheUlISUFjZ0JVc2JJUWdEUUNBQUlBRWdCbXBCQW5ScUlBUTJBZ0FnQVVFQmFpSUJJQU1vQWdBaUIwOE5BU0FCSUFoSERRQUxDeUFFUVFGcUlnUWdDVWxCQUNBR0lBZHFJZ1lnQlVrYkRRQUxJQVlnQlVrTkFBc01CUXNnQTBVTkJDQUVSUTBFUVFFZ0FTZ0NJQ0lKYXlFSVFRQWhCVUVBSVFJRFFFRUFJUUVnQlNFR0EwQWdBQ0FCSUFOc0lBSnFRUUowYWlBSklBZ2dCaUFIU1JzMkFnQWdCa0VCYWlFR0lBRkJBV29pQVNBRVJ3MEFDeUFFSUFWcUlRVWdBa0VCYWlJQ0lBTkhEUUFMREFRTElBVkZEUU5CQVNBQktBSWdJZ0pySVFOQkFDRUJBMEFnQUNBQlFRSjBhaUFDSUFNZ0FTQUhTUnMyQWdBZ0FVRUJhaUlCSUFWSERRQUxEQU1MSUFFb0FpQWhBaUFGQkVCQkFDRUJBMEFnQUNBQlFRSjBha0VCTmdJQUlBRkJBV29pQVNBRlJ3MEFDd3NnQzBVTkFpQURRWDlxSVE4Z0JFRi9haUVRSUFKQmYyb2hCa0VCSUFKQkFYUWlBV3NoQlNBQlFYOXFJUWtnQkNBQ2EwRUJkaUlLSVF3Z0F5QUNhMEVCZGlJTklRUWdDaUVJSUEwaEFVRUFJUWNEUUNBQUlBTWdDR3dnQVdwQkFuUnFJZzRvQWdBaUVVRUJSZ1JBSUE1QkFEWUNBQXNnRVVFQlJpRU9Ba0FDUUNBR1FYOUhEUUFnQVNBRVJ3MEFRUUFoQmlBSklRSWdCRUVCSUFSQkFVb2JRWDlxSWdFaEJBd0JDd0pBSUFaQkFVY05BQ0FCSUExSERRQkJBQ0VHSUFVaEFpQU5RUUZxSWdFZ0R5QUJJQTlJR3lJQklRME1BUXNDUUNBQ1FYOUhEUUFnQ0NBTVJ3MEFRUUFoQWlBRklRWWdERUVCSUF4QkFVb2JRWDlxSWdnaERBd0JDd0pBSUFKQkFVY05BQ0FJSUFwSERRQkJBQ0VDSUFraEJpQUtRUUZxSWdnZ0VDQUlJQkJJR3lJSUlRb01BUXNnQWlBSWFpRUlJQUVnQm1vaEFRc2dCeUFPYWlJSElBdEpEUUFMREFJTElBRW9BaHdoQnlBQktBSVlJUWdnQlFSQUlBbEJmMm9oQWtFQUlRRURRQ0FBSUFGQkFuUnFJQUkyQWdBZ0FVRUJhaUlCSUFWSERRQUxJQUpGRFFJTElBbEJmbW9oQVFOQUFrQWdDQ0FCSWdSQkFuUWlBV29vQWdBaUJpQURiaUlDSUFFZ0Iyb29BZ0FpQVNBRGJpSUZTdzBBSUFZZ0FpQURiR3NpQmlBQklBTWdCV3hySWdsTEJFQURRQ0FDUVFGcUlnSWdCVTBOQUF3Q0FBc0FDd05BSUFJZ0Eyd2hDaUFHSVFFRFFDQUFJQUVnQ21wQkFuUnFJQVEyQWdBZ0FVRUJhaUlCSUFsTkRRQUxJQUpCQVdvaUFpQUZUUTBBQ3dzZ0JFRi9haUVCSUFRTkFBc01BUXNnQlVVTkFFRUFJUUVEUUNBQUlBRkJBblJxSUFFZ0EyNGlBaUFKYkVFQmRpQUJJQUlnQTJ4cmFpQUpjRFlDQUNBQlFRRnFJZ0VnQlVjTkFBc0xDOFFCQVFWL0lBQW9BcWdKSVFRQ1FDQUFRYkFKYWlnQ0FDSUNSUTBBSUFKQmYyb2lBaUFCVFFSQUlBSWhBUXdCQ3lBQUtBSzhDU0VGQTBBQ1FDQUZJQUpCMkFGc2FpZ0NCQ0FFUncwQUlBTkJBV29pQXlBQUtBSVFLQUkwSWdaQkNpQUdRUXBMRzBrTkFDQUNJUUVNQWdzZ0FrRi9haUlDSUFGTERRQUxDd05BQWtBZ0FDZ0N2QWtnQVVIWUFXeHFJZ0lvQWdRZ0JFY05BQ0FDS0FMRUFTSURSUTBBSUFJZ0EwRi9hallDeEFFZ0FDZ0NsQWtnQUNnQ21Ba2dBUkFlSWdFTkFRc0xDNzBFQWd0L0FYNGpBRUhBQTJzaUJTUUFJQU1vQWdBaEJ5QUJLQUt3R2lFSUlBVkJBRFlDRENBQlFiQUpha0VBTmdJQUlBRWdBU2dDcUFsQkFXbzJBcWdKSUFVZ0F5Z0NNQ0FCS0FJTUtBSTBhallDQ0NBQlFjUUphaUVOSUFoQkRHb2hEZ0pBQTBBZ0FTZ0N2QWtoQkFKQUlBTW9BaVFOQUNBRUlBZEIyQUZzYWlnQ3hBRkZEUUJCQVNFRURBSUxJQU1wQWpRaER5QURLQUk4SVFzZ0FTZ0NxQWtoRENBRUlBZEIyQUZzSWdacUlnUWdBU2dDRENnQ09EWUNHQ0FFSUFzMkFoQWdCQ0FQTndJSUlBUWdERFlDQkFKQUlBTW9BZ1FpQkVFQ1JnMEFJQWtOQUNBRVFRZEdEUUFnQUNBRlFReHFFQUlpQkEwQ0lBVW9BZ3dpQkNBQktBS1lDU0FIYTBzRVFFRUJJUVFNQXdzZ0JFVUVRRUVBSVFrTUFRc2dEa0VBUWFRQkVBY2FJQWhCQURZQ0FFRUJJUWtMQWtBZ0JTZ0NEQ0lFQkVBZ0JTQUVRWDlxTmdJTURBRUxRUUFoQ1NBQUlBZ2dBU2dDdkFrZ0Jtb2dBeWdDQkNBREtBSXNFRkVpQkEwQ0N5QUJLQUs4Q1NBR2FpQUlJQUlnRFNBRlFRaHFJQWNnQVNnQ0RDZ0NRQ0FGUVJCcUVGQWlCQTBCSUFFb0Fyd0pJQVpxS0FMRUFTRUxJQUFRTGlFRUlBVW9BZ3doQmdKQUlBTW9BZ1JCZm1vaURFRUZTdzBBQWtBZ0RFRUJhdzRFQVFFQkFRQUxJQUVnQnpZQ3NBa0xJQVFnQm5JaEJrRUJJUVFnQVNnQ2xBa2dBU2dDbUFrZ0J4QWVJZ2RGUVFBZ0Joc05BU0FLSUF0QkFVWnFJUW9nQmcwQUN5QUJRYXdKYWlnQ0FDQUthaUlBSUFFb0FwZ0pTdzBBSUFFZ0FEWUNyQWxCQUNFRUN5QUZRY0FEYWlRQUlBUUw1Z0lCQjM5QkFTRUNBa0FnQUNnQ0FDQUJLQUlBUncwQUlBQW9BZ1FnQVNnQ0JFY05BQ0FBS0FJTUlBRW9BZ3hIRFFBZ0FDZ0NFQ0lESUFFb0FoQkhEUUFnQUNnQ0xDQUJLQUlzUncwQUlBQW9BakFnQVNnQ01FY05BQ0FBS0FJMElBRW9BalJIRFFBZ0FDZ0NPQ0FCS0FJNFJ3MEFJQUFvQWp3aUJTQUJLQUk4UncwQUlBQW9BbEFnQVNnQ1VFY05BQUpBSUFOQkFVc05BQ0FEUVFGclJRUkFJQUFvQWhnZ0FTZ0NHRWNOQWlBQUtBSWNJQUVvQWh4SERRSWdBQ2dDSUNBQktBSWdSdzBDSUFBb0FpUWlCQ0FCS0FJa1J3MENJQVJGRFFFZ0FTZ0NLQ0VHSUFBb0FpZ2hCMEVBSVFNRFFDQUhJQU5CQW5RaUNHb29BZ0FnQmlBSWFpZ0NBRWNOQXlBRUlBTkJBV29pQTBjTkFBc01BUXNnQUNnQ0ZDQUJLQUlVUncwQkN5QUZCRUFnQUNnQ1FDQUJLQUpBUncwQklBQW9Ba1FnQVNnQ1JFY05BU0FBS0FKSUlBRW9Ba2hIRFFFZ0FDZ0NUQ0FCS0FKTVJ3MEJDMEVBSVFJTElBSUwvd2tCQm44akFFRVFheUlFSkFBZ0FVRUFRZHdBRUFjaEF3SkFJQUJCQ0JBRElnRkJmMFlFUUVFQklRRU1BUXNnQXlBQk5nSUFJQUJCQVJBREdpQUFRUUVRQXhvZ0FFRUJFQU5CZjBZRVFFRUJJUUVNQVFzZ0FFRUZFQU5CZjBZRVFFRUJJUUVNQVFzZ0FFRUlFQU1pQVVGL1JnUkFRUUVoQVF3QkN5QURJQUUyQWdRZ0FDQURRUWhxRUFJaUFRMEFJQU1vQWdoQkgwc0VRRUVCSVFFTUFRc2dBQ0FFUVF4cUVBSWlBUTBBUVFFaEFTQUVLQUlNSWdKQkRFc05BQ0FEUVFFZ0FrRUVhblEyQWd3Z0FDQUVRUXhxRUFJaUFRMEFRUUVoQVNBRUtBSU1JZ0pCQWtzTkFDQURJQUkyQWhBQ1FDQUNRUUZMRFFBZ0FrRUJhd1JBSUFBZ0JFRU1haEFDSWdFTkFrRUJJUUVnQkNnQ0RDSUNRUXhMRFFJZ0EwRUJJQUpCQkdwME5nSVVEQUVMSUFCQkFSQURJZ0pCZjBZTkFTQURJQUpCQVVZMkFoZ2dBQ0FEUVJ4cUVBVWlBUTBCSUFBZ0EwRWdhaEFGSWdFTkFTQUFJQU5CSkdvUUFpSUJEUUZCQVNFQklBTW9BaVFpQWtIL0FVc05BU0FDQkVBZ0F5QUNRUUowRUFvaUFUWUNLQ0FCUlFSQVFmLy9BeUVCREFNTElBQWdBUkFGSWdFTkFrRUJJUUlEUUNBQ0lBTW9BaVJQRFFJZ0FrRUNkQ0VCSUFKQkFXb2hBaUFBSUFFZ0F5Z0NLR29RQlNJQlJRMEFDd3dDQ3lBRFFRQTJBaWdMSUFBZ0EwRXNhaEFDSWdFTkFFRUJJUUVnQXlnQ0xFRVFTdzBBSUFCQkFSQURJZ0pCZjBZTkFDQURJQUpCQVVZMkFqQWdBQ0FFUVF4cUVBSWlBUTBBSUFNZ0JDZ0NERUVCYWpZQ05DQUFJQVJCREdvUUFpSUJEUUJCQVNFQklBTWdCQ2dDREVFQmFqWUNPQ0FBUVFFUUEwRUJha0VDU1EwQUlBQkJBUkFEUVg5R0RRQWdBRUVCRUFNaUFrRi9SZzBBSUFNZ0FrRUJSaUlCTmdJOEFrQWdBVVVFUUNBREtBSTRJUVVnQXlnQ05DRUdEQUVMSUFBZ0EwRkFheEFDSWdFTkFTQUFJQU5CeEFCcUVBSWlBUTBCSUFBZ0EwSElBR29RQWlJQkRRRWdBQ0FEUWN3QWFoQUNJZ0VOQVVFQklRRWdBeWdDUUNBREtBSkVRWDl6SUFNb0FqUWlCa0VEZEdwS0RRRWdBeWdDU0NBREtBSk1RWDl6SUFNb0FqZ2lCVUVEZEdwS0RRRUxBa0FDUUFKQUFrQWdBeWdDQkVGMmFpSUhRU2xMRFFCQjR3QWhBVUdBcEFraEFnSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FnQjBFQmF3NHBBQUVCQ3dzTEN3c0xBUUlEQ3dzTEN3c0xDd01FQlFzTEN3c0xDd3NHQmdjTEN3c0xDd3NMQ0FrS0MwR01BeUVCUVlDTUZTRUNEQWtMUVl3RElRRkJnTmczSVFJTUNBdEJtQVloQVVHQXNPOEFJUUlNQnd0QjFBd2hBVUdBN0wwQklRSU1CZ3RCa0J3aEFVR0E4S1VESVFJTUJRdEJnQ2doQVVHQWdPQURJUUlNQkF0QmdNQUFJUUZCZ0lDQUJpRUNEQU1MUVlERUFDRUJRWUNBc0FZaEFnd0NDMEhBckFFaEFVR0F3SnNVSVFJTUFRdEJnS0FDSVFGQmdJRGdJU0VDQ3lBQklBVWdCbXdpQVU4TkFRc2dCRUgvLy8vL0J6WUNEQ0FES0FJc0lRSU1BUXNnQkNBQ0lBRkJnQU5zYmlJQlFSQWdBVUVRU1JzaUFUWUNEQ0FES0FJc0lnSWdBVTBOQVFzZ0JDQUNOZ0lNSUFJaEFRc2dBeUFCTmdKWVFRRWhBU0FBUVFFUUF5SUNRWDlHRFFBZ0F5QUNRUUZHTmdKUUFrQWdBa0VCUncwQUlBTkJ1QWNRQ2lJQk5nSlVJQUZGQkVCQi8vOERJUUVNQWdzZ0FDQUJFQ3dpQVEwQklBTW9BbFFpQWlnQ21BZEZEUUJCQVNFQklBSW9BckFISUFJb0FyUUhJZ0pMRFFFZ0FpQURLQUlzU1EwQklBSWdBeWdDV0VzTkFTQURJQUpCQVNBQ0d6WUNXQXNnQUJBZlFRQWhBUXNnQkVFUWFpUUFJQUVMalFRQkRuOGdBUUovQWtBZ0FDOEJJQ0lIRFFBZ0FDOEJIQTBBUVFBTUFRdEJBZ3MyQWlBZ0FRSi9Ba0FnQUM4QklpSUNEUUFnQUM4QkhnMEFRUUFNQVF0QkFnczJBaWdnQVFKL0FrQWdBQzhCS0NJRERRQWdBQzhCSkEwQVFRQU1BUXRCQWdzMkFqQWdBUUovQWtBZ0FDOEJLaUlJRFFBZ0FDOEJKZzBBUVFBTUFRdEJBZ3MyQWpnZ0FTQUhJQUF2QVN3aUNYSkJBRWRCQVhRMkFrQWdBU0FDSUFBdkFTNGlCSEpCQUVkQkFYUTJBa2dnQVNBRElBQXZBVFFpQlhKQkFFZEJBWFEyQWxBZ0FTQUlJQUF2QVRZaUNuSkJBRWRCQVhRMkFsZ2dBU0FBTHdFd0lnMGdDWEpCQUVkQkFYUTJBbUFnQVNBQUx3RXlJZ3NnQkhKQkFFZEJBWFEyQW1nZ0FTQUFMd0U0SWd3Z0JYSkJBRWRCQVhRMkFuQWdBU0FBTHdFNklnNGdDbkpCQUVkQkFYUTJBbmhCQWlFR0lBRWdBQzhCSGlJUEJIOUJBZ1VnQUM4QkhFRUFSMEVCZEFzMkFnd2dBU0FQSUFBdkFTUWlCbkpCQUVkQkFYUTJBaFFnQUM4QkppRUFJQUVnRENBT2NrRUFSMEVCZERZQ2ZDQUJJQXNnREhKQkFFZEJBWFEyQW5RZ0FTQUxJQTF5UVFCSFFRRjBOZ0pzSUFFZ0JTQUtja0VBUjBFQmREWUNYQ0FCSUFRZ0JYSkJBRWRCQVhRMkFsUWdBU0FFSUFseVFRQkhRUUYwTmdKTUlBRWdBeUFJY2tFQVIwRUJkRFlDUENBQklBSWdBM0pCQUVkQkFYUTJBalFnQVNBQ0lBZHlRUUJIUVFGME5nSXNJQUVnQUNBR2NrRUFSMEVCZERZQ0hBdk1CZ0VMZnlNQVFZQU9heUlPSkFBZ0JrRUZhaUVJQWtBQ1FDQUNRUUJJRFFBZ0EwRUFTQTBBSUFJZ0NHb2dCRXNOQUNBSFFRVnFJZ29nQTJvZ0JVc05BQ0FFSVFnZ0F5RUpEQUVMSUFBZ0RrSEFDbW9nQWlBRElBUWdCU0FJSUFkQkJXb2lDaUFJRUF3Z0RrSEFDbW9oQUVFQUlRSUxBa0FnQ2tVTkFDQUdRUUoySWhCRkRRQWdDQ0FHYXlFUklBQWdDQ0FKYkNBQ2FtcEJCV29oQWlBT0lRQURRQ0FDUVg5cUxRQUFJUWdnQWtGK2FpMEFBQ0VESUFKQmZXb3RBQUFoQlNBQ1FYeHFMUUFBSVFRZ0FrRjdhaTBBQUNFTUlCQWhEUU5BSUFBZ0FpMEFBQ0lKSUF3Z0JDQUlhaUlMYXlBRElBVnFRUlJzYWlBTFFRSjBhMm8yQWdBZ0FDQUNMUUFCSWdzZ0F5QUlha0VVYkNBRWFpQUZJQWxxSWdScklBUkJBblJyYWpZQ0JDQUFJQUl0QUFJaUR5QUlJQWxxUVJSc0lBVnFJQU1nQzJvaUJHc2dCRUVDZEd0cU5nSUlJQUFnQWkwQUF5SVNJQWtnQzJwQkZHd2dBMm9nQ0NBUGFpSURheUFEUVFKMGEybzJBZ3dnQUVFUWFpRUFJQUpCQkdvaEFpQUlJUXdnQ1NFRUlBc2hCU0FQSVFNZ0VpRUlJQTFCZjJvaURRMEFDeUFDSUJGcUlRSWdDa0YvYWlJS0RRQUxDd0pBSUFkQkFuWWlCMFVOQUNBR1JRMEFRY0FBSUFacklROGdEaUFHUVFKMGFpSUlJQVpCRkd4cUlRSkJBQ0FHYXlJUVFRTjBJUklnQmtFRGRDRUpJQVpCQTJ4QkFuUWhDd05BSUFZaEJBTkFJQUVnQ0NBSmFpZ0NBQ0lBSUFJZ0NXb29BZ0FnQWlBR1FRSjBJZzFxS0FJQUlnb2dBaUFTYWlnQ0FDSURhaUlGYXlBRlFRSjBhMm9nQWlnQ0FDSU1JQUlnRUVFQ2RDSVJhaWdDQUNJRmFrRVViR3BCZ0FScVFRcDFRYkF1YWkwQUFEb0FNQ0FCSUFnZ0RXb29BZ0FpRFNBS0lBTWdCV3BCRkd4cUlBQWdER29pQ21zZ0NrRUNkR3RxUVlBRWFrRUtkVUd3TG1vdEFBQTZBQ0FnQVNBSUtBSUFJZ29nRENBQUlBTnFRUlJzYWlBRklBMXFJZ3hySUF4QkFuUnJha0dBQkdwQkNuVkJzQzVxTFFBQU9nQVFJQUVnQ0NBUmFpZ0NBQ0FGSUFBZ0RXcEJGR3hxSUFNZ0Ntb2lBR3NnQUVFQ2RHdHFRWUFFYWtFS2RVR3dMbW90QUFBNkFBQWdDRUVFYWlFSUlBRkJBV29oQVNBQ1FRUnFJUUlnQkVGL2FpSUVEUUFMSUFFZ0Qyb2hBU0FDSUF0cUlRSWdDQ0FMYWlFSUlBZEJmMm9pQncwQUN3c2dEa0dBRG1va0FBdmxBd0VKZnlNQVFjQURheUlLSkFBZ0JrRUZhaUVJQWtBQ1FDQUNRUUJJRFFBZ0F5QUhhaUFGU3cwQUlBTkJBRWdOQUNBQ0lBaHFJQVJMRFFBZ0JDRUlJQU1oQ1F3QkN5QUFJQW9nQWlBRElBUWdCU0FJSUFjZ0NCQU1JQW9oQUVFQUlRSUxBa0FnQjBVTkFDQUdRUUoySWcxRkRRQkJFQ0FHYXlFT0lBZ2dCbXNoRHlBQUlBZ2dDV3dnQW1wcVFRVnFJUUlEUUNBQ1FYOXFMUUFBSVFnZ0FrRithaTBBQUNFR0lBSkJmV290QUFBaEFDQUNRWHhxTFFBQUlRVWdBa0Y3YWkwQUFDRUpJQTBoQ3dOQUlBRWdBaTBBQUNJRElBa2dCU0FJYWlJRWF5QUFJQVpxUVJSc2FpQUVRUUowYTJwQkVHcEJCWFZCc0M1cUxRQUFPZ0FBSUFFZ0FpMEFBU0lFSUFVZ0JpQUlha0VVYkdvZ0FDQURhaUlGYXlBRlFRSjBhMnBCRUdwQkJYVkJzQzVxTFFBQU9nQUJJQUVnQWkwQUFpSU1JQUFnQXlBSWFrRVViR29nQkNBR2FpSUFheUFBUVFKMGEycEJFR3BCQlhWQnNDNXFMUUFBT2dBQ0lBRWdBaTBBQXlJUUlBWWdBeUFFYWtFVWJHb2dDQ0FNYWlJQWF5QUFRUUowYTJwQkVHcEJCWFZCc0M1cUxRQUFPZ0FESUFGQkJHb2hBU0FDUVFScUlRSWdDQ0VKSUFNaEJTQUVJUUFnRENFR0lCQWhDQ0FMUVg5cUlnc05BQXNnQVNBT2FpRUJJQUlnRDJvaEFpQUhRWDlxSWdjTkFBc0xJQXBCd0FOcUpBQUw5UU1CQzM4akFFSEFBMnNpQ3lRQUFrQUNRQ0FDUVFCSURRQWdBMEVBU0EwQUlBSWdCbW9nQkVzTkFDQURJQWRxUVFWcUlBVkxEUUFnQXlFSURBRUxJQUFnQ3lBQ0lBTWdCQ0FGSUFZZ0IwRUZhaUFHRUF3Z0N5RUFJQVloQkVFQUlRSUxBa0FnQjBFQ2RpSU1SUTBBSUFaRkRRQkJ3QUFnQm1zaEVTQUVRUUYwSVEwZ0JFRUNkQ0FHYXlFT1FRQWdCR3NpRDBFQmRDRVNJQUFnQkNBSWJDQUNhbW9nQkdvaUJ5QUVRUVZzYWlFQ0EwQWdCaUVBQTBBZ0FTQUhJQTFxTFFBQUlnTWdBaUFOYWkwQUFDQUNJQVJxTFFBQUlna2dBaUFTYWkwQUFDSUZhaUlJYXlBSVFRSjBhMm9nQWkwQUFDSUtJQUlnRDJvdEFBQWlDR3BCRkd4cVFSQnFRUVYxUWJBdWFpMEFBRG9BTUNBQklBUWdCMm90QUFBaUVDQUpJQVVnQ0dwQkZHeHFJQU1nQ21vaUNXc2dDVUVDZEd0cVFSQnFRUVYxUWJBdWFpMEFBRG9BSUNBQklBY3RBQUFpQ1NBS0lBTWdCV3BCRkd4cUlBZ2dFR29pQ21zZ0NrRUNkR3RxUVJCcVFRVjFRYkF1YWkwQUFEb0FFQ0FCSUFjZ0Qyb3RBQUFnQ0NBRElCQnFRUlJzYWlBRklBbHFJZ05ySUFOQkFuUnJha0VRYWtFRmRVR3dMbW90QUFBNkFBQWdCMEVCYWlFSElBRkJBV29oQVNBQ1FRRnFJUUlnQUVGL2FpSUFEUUFMSUFFZ0VXb2hBU0FDSUE1cUlRSWdCeUFPYWlFSElBeEJmMm9pREEwQUN3c2dDMEhBQTJva0FBdXFCZ0VOZnlNQVFiQUJheUlSSkFBZ0NFRUJhaUVLQWtBQ1FDQUNRUUJJRFFBZ0EwRUFTQTBBSUFJZ0Ntb2dCRXNOQUNBRElBbHFRUUZxSUFWTERRQWdCU0VNSUFRaENpQURJUThNQVFzZ0FDQVJJQUlnQXlBRUlBVWdDaUFKUVFGcUlnd2dDaEFNSUFBZ0JDQUZiR29nRVNBS0lBeHNhaUFDSUFNZ0JDQUZJQW9nRENBS0VBd2dFU0VBUVFBaEFnc0NRQ0FKUVFGMklnVkZEUUFnQ0VFQmRpSUVSUTBBUVJBZ0NHc2hFMEVJSUFkcklRdEJDQ0FHYXlFTklBcEJBWFFpRGlBSWF5RVVJQUFnQW1vaUZpQUtJQTlzYWlFQ0lBRWhBQ0FGSVJVRFFDQUNJQTVxTFFBQUlBZHNJQXNnQWlBS2FpMEFBQ0lEYkdvaENDQURJQWRzSUFzZ0FpMEFBR3hxSVFrZ0JDRURBMEFnQWtFQmFpSVFJQTVxTFFBQUlSSWdBQ0FKSUExc0lBb2dFR290QUFBaUNTQUhiQ0FMSUFJdEFBRnNhaUlRSUFac2FrRWdha0VHZGpvQUFDQUFJQWdnRFd3Z0J5QVNiQ0FKSUF0c2FpSUlJQVpzYWtFZ2FrRUdkam9BQ0NBQ0xRQUNJUWtnQWtFQ2FpSUNJQTVxTFFBQUlSSWdBQ0FOSUJCc0lBSWdDbW90QUFBaUVDQUhiQ0FKSUF0c2FpSUpJQVpzYWtFZ2FrRUdkam9BQVNBQUlBZ2dEV3dnQnlBU2JDQUxJQkJzYWlJSUlBWnNha0VnYWtFR2Rqb0FDU0FBUVFKcUlRQWdBMEYvYWlJRERRQUxJQUlnRkdvaEFpQUFJQk5xSVFBZ0ZVRi9haUlWRFFBTElBRkJRR3NoQUNBV0lBd2dEMm9nQ214cUlRSURRQ0FDSUE1cUxRQUFJQWRzSUFzZ0FpQUthaTBBQUNJQmJHb2hDQ0FCSUFkc0lBc2dBaTBBQUd4cUlRa2dCQ0VEQTBBZ0FrRUJhaUlCSUE1cUxRQUFJUXdnQUNBSklBMXNJQUVnQ21vdEFBQWlBU0FIYkNBTElBSXRBQUZzYWlJSklBWnNha0VnYWtFR2Rqb0FBQ0FBSUFnZ0RXd2dCeUFNYkNBQklBdHNhaUlCSUFac2FrRWdha0VHZGpvQUNDQUNMUUFDSVFnZ0FrRUNhaUlDSUE1cUxRQUFJUXdnQUNBSklBMXNJQUlnQ21vdEFBQWlEeUFIYkNBSUlBdHNhaUlKSUFac2FrRWdha0VHZGpvQUFTQUFJQUVnRFd3Z0J5QU1iQ0FMSUE5c2FpSUlJQVpzYWtFZ2FrRUdkam9BQ1NBQVFRSnFJUUFnQTBGL2FpSUREUUFMSUFJZ0ZHb2hBaUFBSUJOcUlRQWdCVUYvYWlJRkRRQUxDeUFSUWJBQmFpUUFDLzlFQVVGL0l3QkJzQUZySWdNa0FDQUFLQUlJSWdRRVFDQUFLQUlFSWg5QkEzUWhGaUFFSUI5c0lnUkJCblFoT3lBRVFRaDBJVHdnSDBFR2RDRTlJQjlCTUd3aFBpQWZRUVYwSVNVZ0gwRlFiQ0VyUVFBZ0gwRUVkQ0lhYXlJb1FRSjBJVDhnS0VFQmRDRXNJQU5CR0dvaElpQURRUXh5SVNNRFFBSkFJQUVvQWdnaUNVRUJSZzBBQWtBQ1FBSkFBa0FnQVNnQ3lBRWlBa1VFUUVFQklRWU1BUXRCQlNFR0lBbEJBa2NOQUVFRlFRRWdBU2dDQkNJSklBSW9BZ1JHR3lFR0lBRW9Bc3dCSWdRTkFVRUFJUVFNQXdzZ0FTZ0N6QUVpQkVVRVFFRUFJUVFNQXdzZ0NVRUNSdzBCSUFFb0FnUWhDUXNnQ1NBRUtBSUVSdzBCQ3lBR1FRSnlJUVlMQW44Z0JrRUNjU0l0QkVBQ1FDQUJLQUlBUVFWTkJFQWdCQ2dDQUVFR1NRMEJDeUFEUVFRMkFrQWdBMEVFTmdKSUlBTkJCRFlDT0NBRFFRUTJBakJCQVF3Q0MwRUNJUTlCQWlFSkFrQWdBUzhCSEEwQUlBUXZBVEFOQUVFQklRa2dBU2dDZENBRUtBSjhSdzBBSUFFdUFZUUJJQVF1QWF3QmF5SUZJQVZCSDNVaUJXb2dCWE5CQTBzTkFDQUJMZ0dHQVNBRUxnR3VBV3NpQ1NBSlFSOTFJZ2xxSUFselFRTkxJUWtMSUFNZ0NUWUNNQUpBSUFFdkFSNE5BQ0FFTHdFeURRQkJBU0VQSUFFb0FuUWdCQ2dDZkVjTkFDQUJMZ0dJQVNBRUxnR3dBV3NpQlNBRlFSOTFJZ1ZxSUFWelFRTkxEUUFnQVM0QmlnRWdCQzRCc2dGcklnVWdCVUVmZFNJRmFpQUZjMEVEU3lFUEN5QURJQTgyQWpoQkFpRUZRUUloQ2dKQUlBRXZBU1FOQUNBRUx3RTREUUJCQVNFS0lBRW9BbmdnQkNnQ2dBRkhEUUFnQVM0QmxBRWdCQzRCdkFGcklnZ2dDRUVmZFNJSWFpQUljMEVEU3cwQUlBRXVBWllCSUFRdUFiNEJheUlJSUFoQkgzVWlDR29nQ0hOQkEwc2hDZ3NnQXlBS05nSkFBa0FnQVM4QkpnMEFJQVF2QVRvTkFFRUJJUVVnQVNnQ2VDQUVLQUtBQVVjTkFDQUJMZ0dZQVNBRUxnSEFBV3NpQ0NBSVFSOTFJZ2hxSUFoelFRTkxEUUFnQVM0Qm1nRWdCQzRCd2dGcklnUWdCRUVmZFNJRWFpQUVjMEVEU3lFRkN5QURJQVUyQWtnZ0NTQVBjaUFLY2lBRmNrRUFSd3dCQ3lBRFFRQTJBa0FnQTBFQU5nSklJQU5CQURZQ09DQURRUUEyQWpCQkFBc2hDUUpBQWtBQ1FBSkFJQVpCQkhFaUxnUkFBa0FnQVNnQ0FDSUdRUVZOQkVBZ0FpZ0NBRUVHU1EwQkN5QURRUVEyQW5RZ0EwRUVOZ0tVQVNBRFFRUTJBbFFnQTBFRU5nSTBRUUVoQ1F3Q0MwRUNJUTlCQWlFRUFrQWdBUzhCSEEwQUlBSXZBU1lOQUVFQklRUWdBU2dDZENBQ0tBSjRSdzBBSUFFdUFZUUJJQUl1QVpnQmF5SUZJQVZCSDNVaUJXb2dCWE5CQTBzTkFDQUJMZ0dHQVNBQ0xnR2FBV3NpQkNBRVFSOTFJZ1JxSUFSelFRTkxJUVFMSUFNZ0JEWUNOQUpBSUFFdkFTQU5BQ0FDTHdFcURRQkJBU0VQSUFFb0FuUWdBaWdDZUVjTkFDQUJMZ0dNQVNBQ0xnR2dBV3NpQlNBRlFSOTFJZ1ZxSUFWelFRTkxEUUFnQVM0QmpnRWdBaTRCb2dGcklnVWdCVUVmZFNJRmFpQUZjMEVEU3lFUEN5QURJQTgyQWxSQkFpRUZRUUloQ2dKQUlBRXZBU3dOQUNBQ0x3RTJEUUJCQVNFS0lBRW9BbndnQWlnQ2dBRkhEUUFnQVM0QnBBRWdBaTRCdUFGcklnZ2dDRUVmZFNJSWFpQUljMEVEU3cwQUlBRXVBYVlCSUFJdUFib0JheUlJSUFoQkgzVWlDR29nQ0hOQkEwc2hDZ3NnQXlBS05nSjBBa0FnQVM4Qk1BMEFJQUl2QVRvTkFFRUJJUVVnQVNnQ2ZDQUNLQUtBQVVjTkFDQUJMZ0dzQVNBQ0xnSEFBV3NpQ0NBSVFSOTFJZ2hxSUFoelFRTkxEUUFnQVM0QnJnRWdBaTRCd2dGcklnVWdCVUVmZFNJRmFpQUZjMEVEU3lFRkN5QURJQVUyQXBRQklBbEZEUUpCQVNFSkRBTUxJQU5CQURZQ2RDQURRUUEyQXBRQklBTkJBRFlDVkNBRFFRQTJBalFnQVNnQ0FDRUdDeUFHUVFaSkRRRWdBMEVETmdLZ0FTQURRb09BZ0lBd053S2tBU0FEUVFNMkFwQUJJQU5CQXpZQ2NDQURRUU0yQXF3QklBTkNnNENBZ0RBM0E1Z0JJQU5DZzRDQWdEQTNBNGdCSUFOQ2c0Q0FnREEzQTRBQklBTkNnNENBZ0RBM0EzZ2dBMEtEZ0lDQU1EY0RhQ0FEUW9PQWdJQXdOd05nSUFOQ2c0Q0FnREEzQTFnZ0EwS0RnSUNBTURjQ1RDQURRUU0yQWtRZ0EwRUROZ0k4REFJTElBUWdEM0lnQ25JZ0JYSkJBRWNoQ1FzQ1FBSi9JQVpCQTAwRVFDQUdRUUowUVl3MWFpZ0NBQXdCQzBFRUMwRUJSZ1JBSUFFZ0EwRXdhaEJFSUFNb0Fxd0JJUWNnQXlnQ3BBRWhEaUFES0FLY0FTRVFJQU1vQW93QklSa2dBeWdDaEFFaEJpQURLQUo4SVJjZ0F5Z0NiQ0VJSUFNb0FtUWhCQ0FES0FKY0lSUWdBeWdDVENFTUlBTW9Ba1FoQWlBREtBSThJUkVnQXlnQ3FBRWhIQ0FES0FLZ0FTRW1JQU1vQXBnQklRMGdBeWdDa0FFaEhTQURLQUtJQVNFU0lBTW9Bb0FCSVJVZ0F5Z0NlQ0ViSUFNb0FuQWhFeUFES0FKb0lRb2dBeWdDWUNFUElBTW9BbGdoQlNBREtBSlFJU2NNQVFzZ0F3Si9Ba0FnQXdKL0FrQUNRQ0FCS0FJQVFYNXFJZ1JCQVUwRVFDQUVRUUZyQkVBZ0F3Si9Ba0FnQVM4QklDSUVEUUFnQVM4QkhBMEFRUUFNQVF0QkFnc2lKellDVUNBREFuOENRQ0FCTHdFaUlnY05BQ0FCTHdFZURRQkJBQXdCQzBFQ0N5SUZOZ0pZSUFNQ2Z3SkFJQUV2QVNnaUJnMEFJQUV2QVNRTkFFRUFEQUVMUVFJTElnODJBbUFnQXdKL0FrQWdBUzhCS2lJT0RRQWdBUzhCSmcwQVFRQU1BUXRCQWdzaUNqWUNhQ0FEQW44Q1FDQUJMd0V3SWg0TkFDQUJMd0VzRFFCQkFBd0JDMEVDQ3lJZE5nS1FBU0FEQW44Q1FDQUJMd0V5SWhBTkFDQUJMd0V1RFFCQkFBd0JDMEVDQ3lJTk5nS1lBU0FEQW44Q1FDQUJMd0U0SWdzTkFDQUJMd0UwRFFCQkFBd0JDMEVDQ3lJbU5nS2dBU0FEQW44Q1FDQUJMd0U2SWhnTkFDQUJMd0UyRFFCQkFBd0JDMEVDQ3lJY05nS29BVUVDSVJ0QkFpRVRBa0FnQkNBQkx3RXNJaGR5RFFCQkFTRVRJQUV1QWFRQklBRXVBWXdCYXlJQ0lBSkJIM1VpQW1vZ0FuTkJBMHNOQUNBQkxnR21BU0FCTGdHT0FXc2lBaUFDUVI5MUlnSnFJQUp6UVFOTERRQWdBU2dDZkNBQktBSjBSeUVUQ3lBRElCTTJBbkFDUUNBSElBRXZBUzRpSUhJTkFFRUJJUnNnQVM0QnFBRWdBUzRCa0FGcklnSWdBa0VmZFNJQ2FpQUNjMEVEU3cwQUlBRXVBYW9CSUFFdUFaSUJheUlDSUFKQkgzVWlBbW9nQW5OQkEwc05BQ0FCS0FKOElBRW9BblJISVJzTElBTWdHellDZUVFQ0lSSkJBaUVWQWtBZ0JpQUJMd0UwSWhseURRQkJBU0VWSUFFdUFiUUJJQUV1QVp3QmF5SUNJQUpCSDNVaUFtb2dBbk5CQTBzTkFDQUJMZ0cyQVNBQkxnR2VBV3NpQWlBQ1FSOTFJZ0pxSUFKelFRTkxEUUFnQVNnQ2dBRWdBU2dDZUVjaEZRc2dBeUFWTmdLQUFRSkFJQTRnQVM4Qk5pSWhjZzBBUVFFaEVpQUJMZ0c0QVNBQkxnR2dBV3NpQWlBQ1FSOTFJZ0pxSUFKelFRTkxEUUFnQVM0QnVnRWdBUzRCb2dGcklnSWdBa0VmZFNJQ2FpQUNjMEVEU3cwQUlBRW9Bb0FCSUFFb0FuaEhJUklMSUFNZ0VqWUNpQUVnQVM4QkhnMENJQUV2QVJ3RVFFRUNJUkVnQTBFQ05nSThJQUV2QVNRaUNBMEdRUUFoREVFQURBY0xRUUFoRVNBRFFRQTJBanhCQUNFTVFRQWdBUzhCSkNJSVJRMEdHZ3dGQ3lBREFuOENRQ0FCTHdFZ0lnSU5BQ0FCTHdFY0RRQkJBQXdCQzBFQ0N5SW5OZ0pRSUFNQ2Z3SkFJQUV2QVNJaUJnMEFJQUV2QVI0TkFFRUFEQUVMUVFJTElnVTJBbGdnQXdKL0FrQWdBUzhCS0NJT0RRQWdBUzhCSkEwQVFRQU1BUXRCQWdzaUR6WUNZQ0FEQW44Q1FDQUJMd0VxSWdnTkFDQUJMd0VtRFFCQkFBd0JDMEVDQ3lJS05nSm9JQU1nQWlBQkx3RXNJaGR5UVFCSFFRRjBJaE0yQW5BZ0F5QUdJQUV2QVM0aUMzSkJBRWRCQVhRaUd6WUNlQ0FESUE0Z0FTOEJOQ0llY2tFQVIwRUJkQ0lWTmdLQUFTQURJQWdnQVM4Qk5pSVpja0VBUjBFQmRDSVNOZ0tJQVNBRElBRXZBVEFpRUNBWGNrRUFSMEVCZENJZE5nS1FBU0FESUFFdkFUSWlJQ0FMY2tFQVIwRUJkQ0lOTmdLWUFTQURJQUV2QVRnaUlTQWVja0VBUjBFQmRDSW1OZ0tnQVNBRElBRXZBVG9pQnlBWmNrRUFSMEVCZENJY05nS29BU0FEQW44Q1FDQUJMd0VlSWlRTkFDQUJMd0VjRFFCQkFBd0JDMEVDQ3lJUk5nSThJQUV2QVNZRVFDQUJMd0VrSVJnTUF3c2dBUzhCSkNJWURRSkJBQ0VZUVFBTUF3c2dBUzRCaGdFaEZDQUJMZ0dPQVNFRVFRSWhCU0FEQW45QkFpQUJMd0VjSWhFZ0FTOEJJQ0l2Y2cwQUdrRUJJQUV1QVl3QklBRXVBWVFCYXlJR0lBWkJIM1VpQm1vZ0JuTkJBMHNOQUJvZ0JDQVVheUlHSUFaQkgzVWlCbW9nQm5OQkEwc0xJaWMyQWxBZ0FTNEJpZ0VoQ0NBQkxnR1NBU0VHQWtBZ0FTOEJIaUl3SUFFdkFTSWlFSElOQUVFQklRVWdBUzRCa0FFZ0FTNEJpQUZySWdJZ0FrRWZkU0lDYWlBQ2MwRURTdzBBSUFZZ0NHc2lCU0FGUVI5MUlnVnFJQVZ6UVFOTElRVUxJQU1nQlRZQ1dDQUJMZ0dXQVNFTUlBRXVBWjRCSVFkQkFpRUtJQU1DZjBFQ0lBRXZBU1FpTVNBQkx3RW9JaGR5RFFBYVFRRWdBUzRCbkFFZ0FTNEJsQUZySWdJZ0FrRWZkU0lDYWlBQ2MwRURTdzBBR2lBSElBeHJJZ0lnQWtFZmRTSUNhaUFDYzBFRFN3c2lEellDWUNBQkxnR2FBU0V5SUFFdUFhSUJJUXNDUUNBQkx3RW1Ja0FnQVM4QktpSXpjZzBBUVFFaENpQUJMZ0dnQVNBQkxnR1lBV3NpQWlBQ1FSOTFJZ0pxSUFKelFRTkxEUUFnQ3lBeWF5SUNJQUpCSDNVaUFtb2dBbk5CQTBzaENnc2dBeUFLTmdKb0lBRXVBYVlCSVI1QkFpRWJRUUloRXdKQUlDOGdBUzhCTENJMGNnMEFRUUVoRXlBQkxnR2tBU0FCTGdHTUFXc2lBaUFDUVI5MUlnSnFJQUp6UVFOTERRQWdIaUFFYXlJQ0lBSkJIM1VpQW1vZ0FuTkJBMHNOQUNBQktBSjhJQUVvQW5SSElSTUxJQU1nRXpZQ2NDQUJMZ0dxQVNFT0FrQWdFQ0FCTHdFdUloaHlEUUJCQVNFYklBRXVBYWdCSUFFdUFaQUJheUlDSUFKQkgzVWlBbW9nQW5OQkEwc05BQ0FPSUFacklnSWdBa0VmZFNJQ2FpQUNjMEVEU3cwQUlBRW9BbndnQVNnQ2RFY2hHd3NnQXlBYk5nSjRJQUV1QWJZQklSbEJBaUVTUVFJaEZRSkFJQmNnQVM4Qk5DSWdjZzBBUVFFaEZTQUJMZ0cwQVNBQkxnR2NBV3NpQWlBQ1FSOTFJZ0pxSUFKelFRTkxEUUFnR1NBSGF5SUNJQUpCSDNVaUFtb2dBbk5CQTBzTkFDQUJLQUtBQVNBQktBSjRSeUVWQ3lBRElCVTJBb0FCSUFFdUFib0JJU0VDUUNBeklBRXZBVFlpTlhJTkFFRUJJUklnQVM0QnVBRWdBUzRCb0FGcklnSWdBa0VmZFNJQ2FpQUNjMEVEU3cwQUlDRWdDMnNpQWlBQ1FSOTFJZ0pxSUFKelFRTkxEUUFnQVNnQ2dBRWdBU2dDZUVjaEVnc2dBeUFTTmdLSUFTQUJMZ0d1QVNFMlFRSWhEU0FEQW45QkFpQTBJQUV2QVRBaVFYSU5BQnBCQVNBQkxnR3NBU0FCTGdHa0FXc2lBaUFDUVI5MUlnSnFJQUp6UVFOTERRQWFJRFlnSG1zaUFpQUNRUjkxSWdKcUlBSnpRUU5MQ3lJZE5nS1FBU0FCTGdHeUFTRWtBa0FnR0NBQkx3RXlJamR5RFFCQkFTRU5JQUV1QWJBQklBRXVBYWdCYXlJQ0lBSkJIM1VpQW1vZ0FuTkJBMHNOQUNBa0lBNXJJZ0lnQWtFZmRTSUNhaUFDYzBFRFN5RU5DeUFESUEwMkFwZ0JJQUV1QWI0QklTbEJBaUVjSUFNQ2YwRUNJQ0FnQVM4Qk9DSTRjZzBBR2tFQklBRXVBYndCSUFFdUFiUUJheUlDSUFKQkgzVWlBbW9nQW5OQkEwc05BQm9nS1NBWmF5SUNJQUpCSDNVaUFtb2dBbk5CQTBzTElpWTJBcUFCSUFFdUFjSUJJVGtDUUNBMUlBRXZBVG9pUW5JTkFFRUJJUndnQVM0QndBRWdBUzRCdUFGcklnSWdBa0VmZFNJQ2FpQUNjMEVEU3cwQUlEa2dJV3NpQWlBQ1FSOTFJZ0pxSUFKelFRTkxJUndMSUFNZ0hEWUNxQUZCQWlFQ0lBTUNmMEVDSUJFZ01ISU5BQnBCQVNBQkxnR0lBU0FCTGdHRUFXc2lFU0FSUVI5MUloRnFJQkZ6UVFOTERRQWFJQWdnRkdzaUZDQVVRUjkxSWhScUlCUnpRUU5MQ3lJUk5nSThBa0FnTUNBeGNnMEFRUUVoQWlBQkxnR1VBU0FCTGdHSUFXc2lGQ0FVUVI5MUloUnFJQlJ6UVFOTERRQWdEQ0FJYXlJSUlBaEJIM1VpQ0dvZ0NITkJBMHNOQUNBQktBSjRJQUVvQW5SSElRSUxJQU1nQWpZQ1JFRUNJUlFnQXdKL1FRSWdNU0JBY2cwQUdrRUJJQUV1QVpnQklBRXVBWlFCYXlJSUlBaEJIM1VpQ0dvZ0NITkJBMHNOQUJvZ01pQU1heUlJSUFoQkgzVWlDR29nQ0hOQkEwc0xJZ3cyQWt3Q1FDQVFJQzl5RFFCQkFTRVVJQUV1QVpBQklBRXVBWXdCYXlJSUlBaEJIM1VpQ0dvZ0NITkJBMHNOQUNBR0lBUnJJZ1FnQkVFZmRTSUVhaUFFYzBFRFN5RVVDeUFESUJRMkFseEJBaUVJUVFJaEJBSkFJQkFnRjNJTkFFRUJJUVFnQVM0Qm5BRWdBUzRCa0FGckloQWdFRUVmZFNJUWFpQVFjMEVEU3cwQUlBY2dCbXNpQmlBR1FSOTFJZ1pxSUFaelFRTkxEUUFnQVNnQ2VDQUJLQUowUnlFRUN5QURJQVEyQW1RQ1FDQVhJRE55RFFCQkFTRUlJQUV1QWFBQklBRXVBWndCYXlJR0lBWkJIM1VpQm1vZ0JuTkJBMHNOQUNBTElBZHJJZ1lnQmtFZmRTSUdhaUFHYzBFRFN5RUlDeUFESUFnMkFteEJBaUVHSUFNQ2YwRUNJQmdnTkhJTkFCcEJBU0FCTGdHb0FTQUJMZ0drQVdzaUJ5QUhRUjkxSWdkcUlBZHpRUU5MRFFBYUlBNGdIbXNpQnlBSFFSOTFJZ2RxSUFkelFRTkxDeUlYTmdKOEFrQWdHQ0FnY2cwQVFRRWhCaUFCTGdHMEFTQUJMZ0dvQVdzaUJ5QUhRUjkxSWdkcUlBZHpRUU5MRFFBZ0dTQU9heUlISUFkQkgzVWlCMm9nQjNOQkEwc05BQ0FCS0FLQUFTQUJLQUo4UnlFR0N5QURJQVkyQW9RQlFRSWhFQ0FEQW45QkFpQWdJRFZ5RFFBYVFRRWdBUzRCdUFFZ0FTNEJ0QUZySWdjZ0IwRWZkU0lIYWlBSGMwRURTdzBBR2lBaElCbHJJZ2NnQjBFZmRTSUhhaUFIYzBFRFN3c2lHVFlDakFFQ1FDQTNJRUZ5RFFCQkFTRVFJQUV1QWJBQklBRXVBYXdCYXlJSElBZEJIM1VpQjJvZ0IzTkJBMHNOQUNBa0lEWnJJZ2NnQjBFZmRTSUhhaUFIYzBFRFN5RVFDeUFESUJBMkFwd0JRUUloQjBFQ0lRNENRQ0EzSURoeURRQkJBU0VPSUFFdUFid0JJQUV1QWJBQmF5SUxJQXRCSDNVaUMyb2dDM05CQTBzTkFDQXBJQ1JySWdzZ0MwRWZkU0lMYWlBTGMwRURTdzBBSUFFb0FvQUJJQUVvQW54SElRNExJQU1nRGpZQ3BBRUNRQ0E0SUVKeURRQkJBU0VISUFFdUFjQUJJQUV1QWJ3QmF5SUxJQXRCSDNVaUMyb2dDM05CQTBzTkFDQTVJQ2xySWdjZ0IwRWZkU0lIYWlBSGMwRURTeUVIQ3lBRElBYzJBcXdCREFVTFFRSWhFU0FEUVFJMkFqd2dBUzhCSkNFSURBSUxRUUlMSWd3MkFreEJBaUVFSUFOQkFpQUlRUUJIUVFGMElBNGJJZ2cyQW13Z0EwRUNJQVpCQUVkQkFYUWdBaHNpRkRZQ1hDQURJQWNnSVhKQkFFZEJBWFFpQnpZQ3JBRWdBeUFRSUNCeVFRQkhRUUYwSWhBMkFwd0JJQU1nR1NBZWNrRUFSMEVCZENJWk5nS01BU0FESUFzZ0YzSkJBRWRCQVhRaUZ6WUNmRUVDSVFJQ1FDQVlJQ1J5RFFCQkFTRUNJQUV1QVpRQklBRXVBWWdCYXlJWUlCaEJIM1VpR0dvZ0dITkJBMHNOQUNBQkxnR1dBU0FCTGdHS0FXc2lHQ0FZUVI5MUloaHFJQmh6UVFOTERRQWdBU2dDZUNBQktBSjBSeUVDQ3lBRElBSTJBa1FDUUNBR0lBNXlEUUJCQVNFRUlBRXVBWndCSUFFdUFaQUJheUlHSUFaQkgzVWlCbW9nQm5OQkEwc05BQ0FCTGdHZUFTQUJMZ0dTQVdzaUJpQUdRUjkxSWdacUlBWnpRUU5MRFFBZ0FTZ0NlQ0FCS0FKMFJ5RUVDeUFESUFRMkFtUkJBaUVPUVFJaEJnSkFJQXNnSG5JTkFFRUJJUVlnQVM0QnRBRWdBUzRCcUFGcklnc2dDMEVmZFNJTGFpQUxjMEVEU3cwQUlBRXVBYllCSUFFdUFhb0JheUlMSUF0QkgzVWlDMm9nQzNOQkEwc05BQ0FCS0FLQUFTQUJLQUo4UnlFR0N5QURJQVkyQW9RQkFrQWdJQ0FoY2cwQVFRRWhEaUFCTGdHOEFTQUJMZ0d3QVdzaUN5QUxRUjkxSWd0cUlBdHpRUU5MRFFBZ0FTNEJ2Z0VnQVM0QnNnRnJJZ3NnQzBFZmRTSUxhaUFMYzBFRFN3MEFJQUVvQW9BQklBRW9BbnhISVE0TElBTWdEallDcEFFTUFnc2dDQ0VNUVFJTElnSTJBa1FnQXlBQkx3RW1JQXhCLy84RGNYSkJBRWRCQVhRaUREWUNUQ0FEQW44Q1FDQUhSUVJBSUFRRVFFRUNJUlFnQTBFQ05nSmNJQVlOQWtFQURBTUxRUUFoRkNBRFFRQTJBbHhCQUNBR1JRMENHZ3dCQzBFQ0lSUWdBMEVDTmdKY0MwRUNDeUlFTmdKa0lBTkJBaUFPUVFCSFFRRjBJQVliSWdnMkFtd2dBd0ovQWtBZ0lFVUVRQ0FYQkVCQkFpRVhJQU5CQWpZQ2ZDQVpEUUpCQUF3REMwRUFJUmNnQTBFQU5nSjhRUUFnR1VVTkFob01BUXRCQWlFWElBTkJBallDZkF0QkFnc2lCallDaEFFZ0F5QUxJQmh5UVFCSFFRRjBJZ2MyQXF3QklBTWdDeUFRY2tFQVIwRUJkQ0lPTmdLa0FTQURRUUlnRUVFQVIwRUJkQ0FlR3lJUU5nS2NBU0FESUJrZ0lYSkJBRWRCQVhRaUdUWUNqQUVMSUFrZ0ozSWdCWElnRDNJZ0NuSWdFM0lnRzNJZ0ZYSWdFbklnSFhJZ0RYSWdKbklnSEhJZ0VYSWdBbklnREhJZ0ZISWdCSElnQ0hJZ0YzSWdCbklnR1hJZ0VISWdEbklnQjNKRkRRRUxJQUVvQWd3aENTQURJQUVvQWhBaUJTQUJLQUlVSWdScUlnWkJNeUFHUVROSUd5SUdRUUFnQmtFQVNodEIwQmRxTFFBQUlnWTJBaUFnQXlBRUlBbHFJZ0pCTXlBQ1FUTklHeUlDUVFBZ0FrRUFTaHNpQ0VHUUYyb3RBQUFpQWpZQ0hDQURJQWhCQTJ4QmtCaHFJZ2cyQWhnQ1FDQXRSUTBBSUFRZ0FTZ0N6QUVvQWhRaUIwY0VRQ0FESUFRZ0IycEJBV3BCQVhZaUJ5QUZhaUlOUVRNZ0RVRXpTQnNpRFVFQUlBMUJBRW9iUWRBWGFpMEFBRFlDQ0NBRElBY2dDV29pQjBFeklBZEJNMGdiSWdkQkFDQUhRUUJLR3lJSFFaQVhhaTBBQURZQ0JDQURJQWRCQTJ4QmtCaHFOZ0lBREFFTElBTWdCallDQ0NBRElBSTJBZ1FnQXlBSU5nSUFDd0pBSUM1RkRRQWdCQ0FCS0FMSUFTZ0NGQ0lIUndSQUlBTWdCQ0FIYWtFQmFrRUJkaUlFSUFWcUlnVkJNeUFGUVROSUd5SUZRUUFnQlVFQVNodEIwQmRxTFFBQU5nSVVJQU1nQkNBSmFpSUVRVE1nQkVFelNCc2lCRUVBSUFSQkFFb2JJZ1JCa0JkcUxRQUFOZ0lRSUFNZ0JFRURiRUdRR0dvMkFnd01BUXNnQXlBR05nSVVJQU1nQWpZQ0VDQURJQWcyQWd3TElBQW9BZ0FnSHlBNmJDSVVRUWgwYWlBcVFRUjBhaUVKUVFBaEFrRURJUVFnQTBFd2FpRUdBMEFnQmlnQ0JDSUZCRUFnQ1NBRklDTWdHaEFaQ3lBR0tBSU1JZ1VFUUNBSlFRUnFJQVVnSWlBYUVCa0xJQVlvQWhRaUJRUkFJQWxCQ0dvZ0JTQWlJQm9RR1FzZ0JpZ0NIQ0lGQkVBZ0NVRU1haUFGSUNJZ0doQVpDeUFFSVFnQ1FBSkFBa0FnQmlnQ0FDSUVJQVlvQWdnaUQwY05BQ0FFSUFZb0FoQkhEUUFnQkNBR0tBSVlSdzBBSUFSRkRRSWdBeUFDUVF4c2FpSUZLQUlJSVF3Z0JTZ0NCQ0ViSUFSQkJFa05BU0FiUVFKMlFRSnFJUkJCRUNFUElBa2hCQU5BQWtBZ0JDQW9haUlDTFFBQUlnb2dCQzBBQUNJT2F5SUZJQVZCSDNVaUJXb2dCWE1pQnlBYlR3MEFJQVFnTEdvaUVTMEFBQ0lGSUFwcklnMGdEVUVmZFNJTmFpQU5jeUFNVHcwQUlBUWdHbW9pSEMwQUFDSVNJQTVySWcwZ0RVRWZkU0lOYWlBTmN5QU1UdzBBQWtBZ0J5QVFTUVJBSUFRZ0pXb2lGeTBBQUNFVkFuOGdCQ0FyYWlJTkxRQUFJaE1nQ21zaUJ5QUhRUjkxSWdkcUlBZHpJQXhKQkVCQkF5RWRJQUlnRWlBS0lBNXFJQVZxSWdKQkFYUnFJQk5xUVFScVFRTjJPZ0FBSUJFZ0FpQVRha0VDYWtFQ2Rqb0FBQ0FDUVFScUlSRWdCQ0EvYWkwQUFDRUhJQk5CQTJ3TUFRc2dDaUFTYWlFUklBVWhCMEVDSVIwZ0FpRU5RUUlMSVFJZ0RTQUNJQkZxSUFkQkFYUnFJQjEyT2dBQUlCVWdEbXNpQWlBQ1FSOTFJZ0pxSUFKeklBeFBEUUVnQkNBRklBb2dFbW9nRG1vaUFrRUJkR29nRldwQkJHcEJBM1k2QUFBZ0hDQUNJQlZxUVFKcVFRSjJPZ0FBSUJjZ0FpQVZRUU5zYWlBRUlENXFMUUFBUVFGMGFrRUVha0VEZGpvQUFBd0NDeUFDSUFvZ0Vtb2dCVUVCZEdwQkFtcEJBblk2QUFBTElBUWdCU0FPYWlBU1FRRjBha0VDYWtFQ2Rqb0FBQXNnQkVFQmFpRUVJQTlCZjJvaUR3MEFDd3dDQ3dKL0lBUUVRQ0FKSUFRZ0F5QUNRUXhzYWlBYUVCZ2dCaWdDQ0NFUEN5QVBDd1JBSUFsQkJHb2dEeUFESUFKQkRHeHFJQm9RR0FzZ0JpZ0NFQ0lFQkVBZ0NVRUlhaUFFSUFNZ0FrRU1iR29nR2hBWUN5QUdLQUlZSWdSRkRRRWdDVUVNYWlBRUlBTWdBa0VNYkdvZ0doQVlEQUVMSUFRZ0JTZ0NBR3BCZjJvdEFBQWlBa0VCYWlFSFFRQWdBbXNoRGtFUUlROGdDU0VFQTBBQ1FDQUVJQ2hxSWhNdEFBQWlEU0FFTFFBQUlncHJJZ1VnQlVFZmRTSUZhaUFGY3lBYlR3MEFJQVFnTEdvaUVTMEFBQ0lTSUExcklnVWdCVUVmZFNJRmFpQUZjeUFNVHcwQUlBUWdHbW9pRUMwQUFDSVZJQXBySWdVZ0JVRWZkU0lGYWlBRmN5QU1UdzBBSUFJaEJTQUVJQ3RxTFFBQUlod2dEV3NpSFNBZFFSOTFJaDFxSUIxeklBeEpCRUFnRVNBU0lBNGdBaUFLSUExcVFRRnFRUUYySUJKQkFYUnJJQnhxUVFGMUlnVWdCU0FDU2hzZ0JTQU9TQnRxT2dBQUlBY2hCUXNnRXlBTkFuOGdCQ0FsYWkwQUFDSVRJQXBySWhFZ0VVRWZkU0lSYWlBUmN5QU1TUVJBSUJBZ0ZTQU9JQUlnQ2lBTmFrRUJha0VCZGlBVlFRRjBheUFUYWtFQmRTSVRJQk1nQWtvYklCTWdEa2diYWpvQUFDQUZRUUZxSVFVTFFRQWdCV3NpRXdzZ0JTQVNJQlZySUFvZ0RXdEJBblJxUVFScVFRTjFJaElnRWlBRlNoc2dFaUFUU0JzaUJXcEJzQzVxTFFBQU9nQUFJQVFnQ2lBRmEwR3dMbW90QUFBNkFBQUxJQVJCQVdvaEJDQVBRWDlxSWc4TkFBc0xJQWhCZjJvaEJDQUdRU0JxSVFZZ0NTQTlhaUVKUVFJaEFpQUlEUUFMSUFFb0Fnd2hCQ0FESUFFb0FoQWlCU0FCS0FJVUlnWWdBU2dDR0NJQ2FpSUpRVE1nQ1VFelNCc2lDVUVBSUFsQkFFb2JRUUowUWVBOWFpZ0NBQ0lKYWlJSVFUTWdDRUV6U0JzaUNFRUFJQWhCQUVvYlFkQVhhaTBBQUNJSU5nSWdJQU1nQkNBSmFpSUhRVE1nQjBFelNCc2lCMEVBSUFkQkFFb2JJZzFCa0JkcUxRQUFJZ2MyQWh3Z0F5QU5RUU5zUVpBWWFpSU5OZ0lZQWtBZ0xVVU5BQ0FHSUFFb0Fzd0JLQUlVSWd4SEJFQWdBeUFKSUFJZ0RHb2lERUV6SUF4Qk0wZ2JJZ3hCQUNBTVFRQktHMEVDZEVIZ1BXb29BZ0JxUVFGcVFRRjJJZ3dnQldvaUQwRXpJQTlCTTBnYklnOUJBQ0FQUVFCS0cwSFFGMm90QUFBMkFnZ2dBeUFFSUF4cUlneEJNeUFNUVROSUd5SU1RUUFnREVFQVNoc2lERUdRRjJvdEFBQTJBZ1FnQXlBTVFRTnNRWkFZYWpZQ0FBd0JDeUFESUFnMkFnZ2dBeUFITmdJRUlBTWdEVFlDQUFzQ1FDQXVSUTBBSUFZZ0FTZ0N5QUVvQWhRaURFY0VRQ0FESUFVZ0NTQUNJQXhxSWdaQk15QUdRVE5JR3lJR1FRQWdCa0VBU2h0QkFuUkI0RDFxS0FJQWFrRUJha0VCZGlJSmFpSUZRVE1nQlVFelNCc2lCVUVBSUFWQkFFb2JRZEFYYWkwQUFEWUNGQ0FESUFRZ0NXb2lCRUV6SUFSQk0wZ2JJZ1JCQUNBRVFRQktHeUlFUVpBWGFpMEFBRFlDRUNBRElBUkJBMnhCa0JocU5nSU1EQUVMSUFNZ0NEWUNGQ0FESUFjMkFoQWdBeUFOTmdJTUN5QUFLQUlBSUR4cUlCUkJCblJxSUNwQkEzUnFJZ2tnTzJvaEJFRUFJUW9nQTBFd2FpRUdRUUFoQWdOQUlBWW9BZ1FpQlFSQUlBa2dCU0FqSUJZUUVDQUVJQVlvQWdRZ0l5QVdFQkFMSUFZb0FpUWlCUVJBSUFrZ0dtb2dCU0FqSUJZUUVDQUVJQnBxSUFZb0FpUWdJeUFXRUJBTElBWW9BaFFpQlFSQUlBbEJCR29nQlNBaUlCWVFFQ0FFUVFScUlBWW9BaFFnSWlBV0VCQUxJQVlvQWpRaUJRUkFJQWtnR21wQkJHb2dCU0FpSUJZUUVDQUVJQnBxUVFScUlBWW9BalFnSWlBV0VCQUxJQUloQlFKQUFrQWdCaWdDQUNJQ0lBWW9BZ2dpRDBjTkFDQUNJQVlvQWhCSERRQWdBaUFHS0FJWVJ3MEFJQUpGRFFFZ0NTQUNJQU1nQ2tFTWJHb2lBaUFXRUNzZ0JDQUdLQUlBSUFJZ0ZoQXJEQUVMQW44Z0FnUkFJQWtnQWlBRElBcEJER3hxSWdJZ0ZoQVNJQVFnQmlnQ0FDQUNJQllRRWlBR0tBSUlJUThMSUE4TEJFQWdDVUVDYWlBUElBTWdDa0VNYkdvaUFpQVdFQklnQkVFQ2FpQUdLQUlJSUFJZ0ZoQVNDeUFHS0FJUUlnSUVRQ0FKUVFScUlBSWdBeUFLUVF4c2FpSUNJQllRRWlBRVFRUnFJQVlvQWhBZ0FpQVdFQklMSUFZb0FoZ2lBa1VOQUNBSlFRWnFJQUlnQXlBS1FReHNhaUlDSUJZUUVpQUVRUVpxSUFZb0FoZ2dBaUFXRUJJTElBUWdKV29oQkNBSklDVnFJUWtnQmtGQWF5RUdRUUVoQWtFQ0lRb2dCVVVOQUFzTFFRQWdLa0VCYWlJRUlBUWdIMFlpQkJzaEtpQUJRZGdCYWlFQklBUWdPbW9pT2lBQUtBSUlTUTBBQ3dzZ0EwR3dBV29rQUF1Q0JRRUtmeU1BUVpBQmF5SUxKQUFDUUFKQUlBSkJBRWdOQUNBRFFRQklEUUFnQWlBSGFpQUVTdzBBSUFNZ0NHcEJBV29nQlVzTkFDQUZJUXdnQXlFT0RBRUxJQUFnQ3lBQ0lBTWdCQ0FGSUFjZ0NFRUJhaUlNSUFjUURDQUFJQVFnQld4cUlBc2dCeUFNYkdvZ0FpQURJQVFnQlNBSElBd2dCeEFNSUFzaEFDQUhJUVJCQUNFQ0N3SkFJQWhCQVhZaUJVVU5BQ0FIUVFGMklnTkZEUUJCRUNBSGF5RVFRUWdnQm1zaENTQUVRUUYwSWcwZ0Iyc2hFU0FBSUFKcUloSWdCQ0FPYkdvaEJ5QUJJUUlnQlNFSUEwQWdBeUVBQTBBZ0J5QU5haTBBQUNFS0lBSWdDU0FITFFBQWJDQUVJQWRxTFFBQUlnOGdCbXhxUVFOMFFTQnFRUVoyT2dBQUlBSWdDU0FQYkNBR0lBcHNha0VEZEVFZ2FrRUdkam9BQ0NBSFFRRnFJZ29nRFdvdEFBQWhEeUFDSUFrZ0J5MEFBV3dnQkNBS2FpMEFBQ0lLSUFac2FrRURkRUVnYWtFR2Rqb0FBU0FDSUFrZ0Ntd2dCaUFQYkdwQkEzUkJJR3BCQm5ZNkFBa2dBa0VDYWlFQ0lBZEJBbW9oQnlBQVFYOXFJZ0FOQUFzZ0J5QVJhaUVISUFJZ0VHb2hBaUFJUVg5cUlnZ05BQXNnQVVGQWF5RUNJQklnRENBT2FpQUViR29oQndOQUlBTWhBQU5BSUFjZ0RXb3RBQUFoQVNBQ0lBa2dCeTBBQUd3Z0JDQUhhaTBBQUNJSUlBWnNha0VEZEVFZ2FrRUdkam9BQUNBQ0lBZ2dDV3dnQVNBR2JHcEJBM1JCSUdwQkJuWTZBQWdnQjBFQmFpSUJJQTFxTFFBQUlRZ2dBaUFKSUFjdEFBRnNJQUVnQkdvdEFBQWlBU0FHYkdwQkEzUkJJR3BCQm5ZNkFBRWdBaUFCSUFsc0lBWWdDR3hxUVFOMFFTQnFRUVoyT2dBSklBSkJBbW9oQWlBSFFRSnFJUWNnQUVGL2FpSUFEUUFMSUFjZ0VXb2hCeUFDSUJCcUlRSWdCVUYvYWlJRkRRQUxDeUFMUVpBQmFpUUFDLzBFQVF0L0l3QkJrQUZySWd3a0FDQUhRUUZxSVFrQ1FBSkFJQUpCQUVnTkFDQURJQWhxSUFWTERRQWdBMEVBU0EwQUlBSWdDV29nQkVzTkFDQUVJUWtnQXlFTERBRUxJQUFnRENBQ0lBTWdCQ0FGSUFrZ0NDQUpFQXdnQUNBRUlBVnNhaUFNSUFnZ0NXeHFJQUlnQXlBRUlBVWdDU0FJSUFrUURDQU1JUUFnQ0NFRlFRQWhBZ3NDUUNBSVFRRjJJZ2hGRFFBZ0IwRUJkaUlFUlEwQVFSQWdCMnNoRGtFSUlBWnJJUW9nQ1VFQmRDQUhheUVQSUFBZ0Ftb2lFU0FKSUF0c2FpRUNJQUVoQXlBSUlRQURRQ0FFSVFjRFFDQUNRUUZxSUFscUxRQUFJUkFnQWlBSmFpMEFBQ0VOSUFNZ0FpMEFBU0lTSUFac0lBb2dBaTBBQUd4cVFRTjBRU0JxUVFaMk9nQUFJQU1nQmlBUWJDQUtJQTFzYWtFRGRFRWdha0VHZGpvQUNDQUNMUUFDSVEwZ0FrRUNhaUlDSUFscUxRQUFJUk1nQXlBR0lBMXNJQW9nRW14cVFRTjBRU0JxUVFaMk9nQUJJQU1nQmlBVGJDQUtJQkJzYWtFRGRFRWdha0VHZGpvQUNTQURRUUpxSVFNZ0IwRi9haUlIRFFBTElBSWdEMm9oQWlBRElBNXFJUU1nQUVGL2FpSUFEUUFMSUFGQlFHc2hBeUFSSUFVZ0Myb2dDV3hxSVFJRFFDQUVJUWNEUUNBQ1FRRnFJQWxxTFFBQUlRQWdBaUFKYWkwQUFDRUJJQU1nQWkwQUFTSUZJQVpzSUFvZ0FpMEFBR3hxUVFOMFFTQnFRUVoyT2dBQUlBTWdBQ0FHYkNBQklBcHNha0VEZEVFZ2FrRUdkam9BQ0NBQ0xRQUNJUUVnQWtFQ2FpSUNJQWxxTFFBQUlRc2dBeUFCSUFac0lBVWdDbXhxUVFOMFFTQnFRUVoyT2dBQklBTWdCaUFMYkNBQUlBcHNha0VEZEVFZ2FrRUdkam9BQ1NBRFFRSnFJUU1nQjBGL2FpSUhEUUFMSUFJZ0Qyb2hBaUFESUE1cUlRTWdDRUYvYWlJSURRQUxDeUFNUVpBQmFpUUFDN2tIQVFWL0l3QkJFR3NpQkNRQUFrQWdBQ0FCUVFCQnlBQVFCeUlERUFJaUFRMEFRUUVoQVNBREtBSUFRZjhCU3cwQUlBQWdBMEVFYWhBQ0lnRU5BRUVCSVFFZ0F5Z0NCRUVmU3cwQUlBQkJBUkFERFFBZ0FFRUJFQU1pQWtGL1JnMEFJQU1nQWtFQlJqWUNDQ0FBSUFSQkRHb1FBaUlCRFFBZ0F5QUVLQUlNUVFGcUlnRTJBZ3dnQVVFSVN3UkFRUUVoQVF3QkN3SkFJQUZCQWtrTkFDQUFJQU5CRUdvUUFpSUJEUUVnQXlnQ0VDSUJRUVpMSWdJRVFFRUJJUUVNQWdzZ0FnMEFBa0FDUUFKQUFrQWdBVUVCYXc0R0JBRUNBZ0lEQUFzZ0F5QURLQUlNSWdGQkFuUVFDaUlDTmdJVUlBSkZCRUJCLy84RElRRU1CUXNnQVVVTkEwRUFJUUlEUUNBQUlBUkJER29RQWlJQkRRVWdBeWdDRkNBQ1FRSjBhaUFFS0FJTVFRRnFOZ0lBSUFKQkFXb2lBaUFES0FJTVNRMEFDd3dEQ3lBRElBTW9BZ3dpQWtFQ2RFRjhhaUlCRUFvaUJUWUNHQ0FESUFFUUNpSUdOZ0ljUWYvL0F5RUJJQVZGRFFNZ0JrVU5BeUFDUVFGR0RRSkJBQ0VDQTBBZ0FDQUVRUXhxRUFJaUFRMEVJQUpCQW5RaUJTQURLQUlZYWlBRUtBSU1OZ0lBSUFBZ0JFRU1haEFDSWdFTkJDQURLQUljSUFWcUlBUW9BZ3cyQWdBZ0FrRUJhaUlDSUFNb0FneEJmMnBKRFFBTERBSUxRUUVoQVNBQVFRRVFBeUlDUVg5R0RRSWdBeUFDUVFGR05nSWdJQUFnQkVFTWFoQUNJZ0VOQWlBRElBUW9BZ3hCQVdvMkFpUU1BUXNnQUNBRVFReHFFQUlpQVEwQklBTWdCQ2dDREVFQmFpSUJOZ0lvSUFNZ0FVRUNkQkFLSWdJMkFpd2dBa1VFUUVILy93TWhBUXdDQ3lBQlJRMEFJQU1vQWd4QkFuUkJyRHRxS0FJQUlRWkJBQ0VDQTBBZ0FDQUdFQU1oQlNBREtBSXNJQUpCQW5ScUlBVTJBZ0JCQVNFQklBVWdBeWdDREU4TkFpQUNRUUZxSWdJZ0F5Z0NLRWtOQUFzTElBQWdCRUVNYWhBQ0lnRU5BRUVCSVFFZ0JDZ0NEQ0lDUVI5TERRQWdBeUFDUVFGcU5nSXdJQUFnQkVFTWFoQUNJZ0VOQUVFQklRRWdCQ2dDREVFZlN3MEFJQUJCQVJBREJFQU1BUXNnQUVFQ0VBTkJBa3NFUUF3QkN5QUFJQVJCQ0dvUUJTSUJEUUFnQkNnQ0NFRWFhaUlCUVROTEJFQkJBU0VCREFFTElBTWdBVFlDTkNBQUlBUkJDR29RQlNJQkRRQWdCQ2dDQ0VFYWFrRXpTd1JBUVFFaEFRd0JDeUFBSUFSQkNHb1FCU0lCRFFCQkFTRUJJQVFvQWdnaUFrRU1ha0VZU3cwQUlBTWdBallDT0NBQVFRRVFBeUlDUVg5R0RRQWdBeUFDUVFGR05nSThJQUJCQVJBRElnSkJmMFlOQUNBRElBSkJBVVkyQWtBZ0FFRUJFQU1pQWtGL1JnMEFJQU1nQWtFQlJqWUNSQ0FBRUI5QkFDRUJDeUFFUVJCcUpBQWdBUXZxQlFFSmZ3SkFJQUlvQXB3Q1JRUkFEQUVMUVFFaEJnTkFBa0FDUUNBQ0lBVkJGR3hxS0FLZ0FpSUVRUVZMRFFBZ0JFRUJhdzRGQUFBQUFBTUJDeUFGUVFGcUlRVU1BUXNMSUFRaEJnc0Nmd0pBSUFFb0FoQWlCRUVCVFFSQUlBUkJBV3NFUUNBREtBSUFRUVZHQkVBZ0FFSUFOd0lBSUFJb0FoUWhCVUVBSVFRTUF3c2dBQ2dDQUNJRUlBSW9BaFFpQlUwTkFpQUVJQVZySUFFb0FoUWlCMEVCZGtrTkFpQUFLQUlFSUFkcURBTUxRUUFoQlFKL1FRQWdBeWdDQUVFRlJnMEFHaUFBS0FJTUlnY2dBQ2dDQ0NBQ0tBSU1UUTBBR2lBQktBSU1JQWRxQ3lFSFFRQWhCQUovSUFFb0FpUWlDQVJBSUFJb0Fnd2dCMm9oQlFzZ0JTQURLQUlFSWdwRklBVkJBRWR4YXlJSkN3UkFJQWxCZjJvaUF5QURJQWh1SWdzZ0NHeHJJUU1MSUFnRVFDQUJLQUlvSVF4QkFDRUZBMEFnRENBRlFRSjBhaWdDQUNBRWFpRUVJQVZCQVdvaUJTQUlSdzBBQ3dzQ1FDQUpSUVJBUVFBaEJBd0JDeUFFSUF0c0lRUWdBU2dDS0NFSVFRQWhCUU5BSUFnZ0JVRUNkR29vQWdBZ0JHb2hCQ0FGUVFGcUlnVWdBMDBOQUFzTElBcEZCRUFnQVNnQ0hDQUVhaUVFQ3lBR1JRUkFJQUlvQWlBaEF5QUJLQUlnSVFFZ0FpZ0NIQ0VHSUFBZ0J6WUNEQ0FBSUFJb0FndzJBZ2dnQmlBQklBTnFJZ0JCSDNVZ0FIRWdCR3BxRHdzZ0FFSUFOd0lJUVFBUEMwRUFJUVZCQUNFRUlBTW9BZ0JCQlVjRVFDQUFLQUlNSVFVZ0FDZ0NDQ0FDS0FJTUlnUkxCRUFnQVNnQ0RDQUZhaUVGQ3lBRUlBVnFRUUYwSUFNb0FnUkZheUVFQ3lBR1JRUkFJQUFnQlRZQ0RDQUFJQUlvQWd3MkFnZ2dCQThMSUFCQ0FEY0NDRUVBRHdzQ1FDQUZJQVJORFFBZ0JTQUVheUFCS0FJVUlnRkJBWFpORFFBZ0FDZ0NCQ0FCYXd3QkN5QUFLQUlFQ3lFRUlBTW9BZ1JGQkVBZ0JDQUZhaUFDS0FJWUlnQkJIM1VnQUhGcUR3c2dBQ0FFTmdJRUlBSW9BaGdoQVNBR0JFQWdBRUVBTmdJRUlBQkJBQ0FCYXlBQlFSOTFjVFlDQUVFQUR3c2dBQ0FGTmdJQUlBUWdCV29nQVVFZmRTQUJjV29MdkFFQkNIOGdBZ1JBSUFGQmYyb2hCMEVBSUFGclFkZ0JiQ0VJUVFFZ0FXdEIyQUZzSVFrZ0FVRi9jMEhZQVd3aENnTkFJQUFnQmtIWUFXeHFJZ01nQTBHb2ZtcEJBQ0FFR3pZQ3lBRWdBd0ovSUFWRkJFQWdBMEVBTmdMTUFVRUFEQUVMSUFNZ0F5QUlhallDekFFZ0F5QUpha0VBSUFRZ0Iwa2JDellDMEFFZ0F5QURJQXBxUVFBZ0JCdEJBQ0FGR3pZQzFBRkJBQ0FFUVFGcUlnTWdBU0FEUmlJREd5RUVJQU1nQldvaEJTQUdRUUZxSWdZZ0FrY05BQXNMQzNjQkFuOUJBU0VDQWtBZ0FFRUJFQU5CZjBZTkFDQUJJQUJCQWhBRE5nSUVJQUVnQUVFRkVBTWlBRFlDQUNBQVFYNXFRUU5KRFFBQ1FDQUFRUXhMRFFCQkFTQUFkQ0lEUWNBOGNVVUVRQ0FEUWFBRGNVVU5BU0FBUVFaR0RRSWdBU2dDQkEwQkRBSUxJQUVvQWdRTkFRdEJBQ0VDQ3lBQ0M1SVRBUVovSUFBZ0FTZ0NBQ0lOTmdJQUlBQWdBQ2dDeEFGQkFXbzJBc1FCSUFJZ0JSQWRBa0FDUUFKQUFrQUNRQ0FOUVI5R0JFQWdBRUVBTmdJVUlBQW9Bc1FCUVFGTERRRWdBRUVjYWlFSklBRkJ5QUpxSVFSQkZ5RUJJQWNoQUFOQUlBbEJFRHNCQUNBQUlBUW9BZ0E2QUFBZ0FDQUVLQUlFT2dBQklBQWdCQ2dDQ0RvQUFpQUFJQVFvQWd3NkFBTWdBQ0FFS0FJUU9nQUVJQUFnQkNnQ0ZEb0FCU0FBSUFRb0FoZzZBQVlnQUNBRUtBSWNPZ0FISUFBZ0JDZ0NJRG9BQ0NBQUlBUW9BaVE2QUFrZ0FDQUVLQUlvT2dBS0lBQWdCQ2dDTERvQUN5QUFJQVFvQWpBNkFBd2dBQ0FFS0FJME9nQU5JQUFnQkNnQ09Eb0FEaUFBSUFRb0FqdzZBQThnQVNJRFFYOXFJUUVnQ1VFQ2FpRUpJQUJCRUdvaEFDQUVRVUJySVFRZ0F3MEFDeUFDSUFjUUd3d0VDeUFBUVJ4cUlRa2dEUVJBSUFrZ0FTa0NrQUkzQWdBZ0NTQUJLUUcrQWpjQkxpQUpJQUVwQXJnQ053SW9JQWtnQVNrQ3NBSTNBaUFnQ1NBQktRS29BamNDR0NBSklBRXBBcUFDTndJUUlBa2dBU2tDbUFJM0FnZ2dCQ2dDQUNFS0FrQWdBU2dDQ0NJTFJRMEFJQVFnQ2lBTGFpSUtOZ0lBSUFRZ0NrRi9UQVIvSUFwQk5Hb0ZJQXBCTkVnTkFTQUtRVXhxQ3lJS05nSUFDeUFBSUFvMkFoUWdBVUhJRDJvaERDQUJRY2dDYWlFRUFrQUNRQ0FBS0FJQVFRWk5CRUFnQ1M4QkFFVU5BVUVCSVFnZ0JDQUtRUUFnRENnQ0FCQUdSUTBDREFnTElBQXZBVXdFUUNBQlFjZ09haUFLRURFTFFiQTBJUXBCRHlFSUEwQWdDQ0VMSUFRZ0FTQUtLQUlBUVFKMGFrSElEbW9vQWdBaUNEWUNBQUpBQWtBZ0NFVUVRQ0FKTHdFQVJRMEJDMEVCSVFnZ0JDQUFLQUlVUVFFZ0RDZ0NBQkFHUlEwQkRBb0xJQVJCLy8vL0J6WUNBQXNnQ2tFRWFpRUtJQXRCZjJvaENDQU1RUVJxSVF3Z0NVRUNhaUVKSUFSQlFHc2hCQ0FMRFFBTERBUUxJQVJCLy8vL0J6WUNBQXNnQVVHSUEyb2hCQUpBSUFBdkFSNEVRRUVCSVFnZ0JDQUFLQUlVUVFBZ0FVSE1EMm9vQWdBUUJrVU5BUXdIQ3lBRVFmLy8vd2MyQWdBTElBRkJ5QU5xSVFRQ1FDQUFMd0VnQkVCQkFTRUlJQVFnQUNnQ0ZFRUFJQUZCMEE5cUtBSUFFQVpGRFFFTUJ3c2dCRUgvLy84SE5nSUFDeUFCUVlnRWFpRUVBa0FnQUM4QklnUkFRUUVoQ0NBRUlBQW9BaFJCQUNBQlFkUVBhaWdDQUJBR1JRMEJEQWNMSUFSQi8vLy9CellDQUFzZ0FVSElCR29oQkFKQUlBQXZBU1FFUUVFQklRZ2dCQ0FBS0FJVVFRQWdBVUhZRDJvb0FnQVFCa1VOQVF3SEN5QUVRZi8vL3djMkFnQUxJQUZCaUFWcUlRUUNRQ0FBTHdFbUJFQkJBU0VJSUFRZ0FDZ0NGRUVBSUFGQjNBOXFLQUlBRUFaRkRRRU1Cd3NnQkVILy8vOEhOZ0lBQ3lBQlFjZ0ZhaUVFQWtBZ0FDOEJLQVJBUVFFaENDQUVJQUFvQWhSQkFDQUJRZUFQYWlnQ0FCQUdSUTBCREFjTElBUkIvLy8vQnpZQ0FBc2dBVUdJQm1vaEJBSkFJQUF2QVNvRVFFRUJJUWdnQkNBQUtBSVVRUUFnQVVIa0Qyb29BZ0FRQmtVTkFRd0hDeUFFUWYvLy93YzJBZ0FMSUFGQnlBWnFJUVFDUUNBQUx3RXNCRUJCQVNFSUlBUWdBQ2dDRkVFQUlBRkI2QTlxS0FJQUVBWkZEUUVNQndzZ0JFSC8vLzhITmdJQUN5QUJRWWdIYWlFRUFrQWdBQzhCTGdSQVFRRWhDQ0FFSUFBb0FoUkJBQ0FCUWV3UGFpZ0NBQkFHUlEwQkRBY0xJQVJCLy8vL0J6WUNBQXNnQVVISUIyb2hCQUpBSUFBdkFUQUVRRUVCSVFnZ0JDQUFLQUlVUVFBZ0FVSHdEMm9vQWdBUUJrVU5BUXdIQ3lBRVFmLy8vd2MyQWdBTElBRkJpQWhxSVFRQ1FDQUFMd0V5QkVCQkFTRUlJQVFnQUNnQ0ZFRUFJQUZCOUE5cUtBSUFFQVpGRFFFTUJ3c2dCRUgvLy84SE5nSUFDeUFCUWNnSWFpRUVBa0FnQUM4Qk5BUkFRUUVoQ0NBRUlBQW9BaFJCQUNBQlFmZ1BhaWdDQUJBR1JRMEJEQWNMSUFSQi8vLy9CellDQUFzZ0FVR0lDV29oQkFKQUlBQXZBVFlFUUVFQklRZ2dCQ0FBS0FJVVFRQWdBVUg4RDJvb0FnQVFCa1VOQVF3SEN5QUVRZi8vL3djMkFnQUxJQUZCeUFscUlRUUNRQ0FBTHdFNEJFQkJBU0VJSUFRZ0FDZ0NGRUVBSUFGQmdCQnFLQUlBRUFaRkRRRU1Cd3NnQkVILy8vOEhOZ0lBQ3lBQlFZZ0thaUVFQWtBZ0FDOEJPZ1JBUVFFaENDQUVJQUFvQWhSQkFDQUJRWVFRYWlnQ0FCQUdSUTBCREFjTElBUkIvLy8vQnpZQ0FBc2dBVUdJRUdvaERDQUJRY2dLYWlFRURBSUxJQWxDQURjQ0FDQUpRZ0EzQVM0Z0NVSUFOd0lvSUFsQ0FEY0NJQ0FKUWdBM0FoZ2dDVUlBTndJUUlBbENBRGNDQ0NBQUlBUW9BZ0EyQWhRTUFnc2dBRUtRZ01DQWdJS0FDRGNCSENBQVFwQ0F3SUNBZ29BSU53RkVJQUJDa0lEQWdJQ0NnQWczQVR3Z0FFS1FnTUNBZ0lLQUNEY0JOQ0FBUXBDQXdJQ0Fnb0FJTndFc0lBQkNrSURBZ0lDQ2dBZzNBU1JCQUE4TElBQW9BaGdnQUNnQ0ZHb2lDMEV6SUF0Qk0wZ2JJZ3RCQUNBTFFRQktHMEVDZEVIZ1BXb29BZ0FoQ1FKQUlBQXZBVTVGQkVBZ0FDOEJVRVVOQVFzZ0FVR0lEMm9nQ1JBd0N5QUVJQUZCaUE5cUtBSUFJZ3MyQWdBQ1FBSkFJQXRGQkVBZ0FDOEJQRVVOQVF0QkFTRUlJQVFnQ1VFQklBd29BZ0FRQmtVTkFRd0VDeUFFUWYvLy93YzJBZ0FMSUFRZ0FTZ0NqQThpQ3pZQ1FDQUVRVUJySVFvQ1FBSkFJQXRGQkVBZ0FDOEJQa1VOQVF0QkFTRUlJQW9nQ1VFQklBd29BZ1FRQmtVTkFRd0VDeUFLUWYvLy93YzJBZ0FMSUFRZ0FTZ0NrQThpQ3pZQ2dBRWdCRUdBQVdvaENnSkFBa0FnQzBVRVFDQUFRVUJyTHdFQVJRMEJDMEVCSVFnZ0NpQUpRUUVnRENnQ0NCQUdSUTBCREFRTElBcEIvLy8vQnpZQ0FBc2dCQ0FCS0FLVUR5SUxOZ0xBQVNBRVFjQUJhaUVLQWtBQ1FDQUxSUVJBSUFBdkFVSkZEUUVMUVFFaENDQUtJQWxCQVNBTUtBSU1FQVpGRFFFTUJBc2dDa0gvLy84SE5nSUFDeUFFSUFFb0FwZ1BJZ3MyQW9BQ0lBUkJnQUpxSVFvQ1FBSkFJQXRGQkVBZ0FDOEJSRVVOQVF0QkFTRUlJQW9nQ1VFQklBd29BaEFRQmtVTkFRd0VDeUFLUWYvLy93YzJBZ0FMSUFRZ0FTZ0NuQThpQ3pZQ3dBSWdCRUhBQW1vaENnSkFBa0FnQzBVRVFDQUFMd0ZHUlEwQkMwRUJJUWdnQ2lBSlFRRWdEQ2dDRkJBR1JRMEJEQVFMSUFwQi8vLy9CellDQUFzZ0JDQUJLQUtnRHlJTE5nS0FBeUFFUVlBRGFpRUtBa0FDUUNBTFJRUkFJQUF2QVVoRkRRRUxRUUVoQ0NBS0lBbEJBU0FNS0FJWUVBWkZEUUVNQkFzZ0NrSC8vLzhITmdJQUN5QUVJQUVvQXFRUElnczJBc0FESUFSQndBTnFJUVFDUUFKQUlBdEZCRUFnQUM4QlNrVU5BUXRCQVNFSUlBUWdDVUVCSUF3b0Fod1FCa1VOQVF3RUN5QUVRZi8vL3djMkFnQUxJQTFCQmtrTkFDQUFJQUVnQWlBRklBWWdCeEJXSWdoRkRRRU1BZ3NnQUNBQklBTWdCU0FDSUFjUVZ5SUlEUUVMUVFBaENBc2dDQXVXSFFFSGZ5TUFRUkJySWdja0FDQUJRUUJCcUJBUUJ5RUZJQUFnQjBFRWFoQUNJUUVnQnlnQ0JDRUlBa0FDUUFKQUlBTkJmbW9pQTBFRlN3MEFBa0FnQTBFQmF3NEVBUUVCQVFBTFFRRWhBeUFCRFFJZ0NFRUdhaUlHUVI5TkRRRU1BZ3RCQVNFRElBRU5BU0FJUVFGcUlnWkJIMHNOQVFzZ0JTQUdOZ0lBQWtBZ0JrRWZSZ1JBQTBBZ0FDZ0NDQVJBSUFCQkFSQURSUTBCREFRTEN5QUZRY2dDYWlFR0EwQWdCeUFBUVFnUUF5SUJOZ0lFSUFGQmYwWU5BeUFHSUFFMkFnQWdCa0VFYWlFR0lBbEJBV29pQ1VHQUEwY05BQXNNQVF0QkFpQUdRUVpISUFaQkJra2JJUW9DUUFKQUlBWkJCRWtOQUNBR1FRVkxEUUFnQUNBSFFReHFFQUlOQVNBSEtBSU1JZ0ZCQTBzTkFTQUZJQUUyQXJBQklBQWdCMEVNYWhBQ0RRRWdCeWdDRENJQlFRTkxEUUVnQlNBQk5nSzBBU0FBSUFkQkRHb1FBZzBCSUFjb0Fnd2lBVUVEU3cwQklBVWdBVFlDdUFFZ0FDQUhRUXhxRUFJTkFTQUhLQUlNSWdGQkEwc05BU0FGSUFFMkFyd0JBa0FnQkVFQ1NRMEFJQVpCQlVZTkFDQUFJQWRCREdvZ0JFRUNTeUlCRUJjTkFpQUhLQUlNSWdnZ0JFOE5BaUFGSUFnMkFzQUJJQUFnQjBFTWFpQUJFQmNOQWlBSEtBSU1JZ2dnQkU4TkFpQUZJQWcyQXNRQklBQWdCMEVNYWlBQkVCY05BaUFIS0FJTUlnZ2dCRThOQWlBRklBZzJBc2dCSUFBZ0IwRU1haUFCRUJjTkFpQUhLQUlNSWdFZ0JFOE5BaUFGSUFFMkFzd0JDeUFISUFVb0FyQUJJZ0ZCQWswRWZ5QUJRUUowUWZBMGFpZ0NBQVZCQXdzMkFneEJBQ0VHQTBBZ0FDQUhRUWhxRUFVaUF3MENJQVVnQmtFQ2RHb2lBU0FIS0FJSU93SFFBU0FBSUFkQkNHb1FCU0lERFFJZ0FTQUhLQUlJT3dIU0FTQUhJQWNvQWd3aUFVRi9hallDRENBR1FRRnFJUVlnQVEwQUN5QUhJQVVvQXJRQklnRkJBazBFZnlBQlFRSjBRZkEwYWlnQ0FBVkJBd3MyQWd4QkFDRUdBMEFnQUNBSFFRaHFFQVVpQXcwQ0lBVWdCa0VDZEdvaUFTQUhLQUlJT3dIZ0FTQUFJQWRCQ0dvUUJTSUREUUlnQVNBSEtBSUlPd0hpQVNBSElBY29BZ3dpQVVGL2FqWUNEQ0FHUVFGcUlRWWdBUTBBQ3lBSElBVW9BcmdCSWdGQkFrMEVmeUFCUVFKMFFmQTBhaWdDQUFWQkF3czJBZ3hCQUNFR0EwQWdBQ0FIUVFocUVBVWlBdzBDSUFVZ0JrRUNkR29pQVNBSEtBSUlPd0h3QVNBQUlBZEJDR29RQlNJRERRSWdBU0FIS0FJSU93SHlBU0FISUFjb0Fnd2lBVUYvYWpZQ0RDQUdRUUZxSVFZZ0FRMEFDeUFISUFVb0Fyd0JJZ0ZCQWswRWZ5QUJRUUowUWZBMGFpZ0NBQVZCQXdzMkFneEJBQ0VHQTBBZ0FDQUhRUWhxRUFVaUF3MENJQVVnQmtFQ2RHb2lBU0FIS0FJSU93R0FBaUFBSUFkQkNHb1FCU0lERFFJZ0FTQUhLQUlJT3dHQ0FpQUhJQWNvQWd3aUFVRi9hallDRENBR1FRRnFJUVpCQUNFRElBRU5BQXNNQVF0QkFDRURJQXBCQWtzTkFBSkFBbjhDUUFKQUFrQWdDa0VCYXc0Q0JBRUFDeUFIUVFBMkFnZ2dCU0FBRUE4aUFVRWZkallDRENBQlFRQk9EUUVnQVVFQmRDRUdRUUFNQWdzZ0JFRUNUd1JBUVFNaEFTQUdRUU5OQkVBZ0JrRUNkRUg4Tkdvb0FnQWhBUXNnQkVFQ1N5RUxRUUVoQXdOQUlBQWdCMEVNYWlBTEVCY05CU0FIS0FJTUlnZ2dCRThOQlNBRklBbEJBblJxSUFnMkFwQUJJQUVpQ0VGL2FpRUJJQWxCQVdvaENTQUlEUUFMQzBFRElRTWdCa0VEVFFSQUlBWkJBblJCL0RScUtBSUFJUU1MUVFBaEJnTkFJQU1oQVNBQUlBZEJDR29RQlNJRERRUWdCU0FHUVFKMGFpSUVJQWNvQWdnN0FhQUJJQUFnQjBFSWFoQUZJZ01OQkNBRUlBY29BZ2c3QWFJQklBRkJmMm9oQXlBR1FRRnFJUVlnQVEwQUMwRUFJUU1NQXdzZ0JTQUJRUngyTmdKTUlBRkJCSFFoQmtFQkN5RURJQVVnQmtFZmRqWUNFQ0FGSUFaQkFFZ0VmeUFHUVFGMEJTQUZJQVpCSEhZMkFsQWdBMEVCYWlFRElBWkJCSFFMSWdGQkgzWTJBaFFnQlNBQlFRQklCSDhnQVVFQmRBVWdCU0FCUVJ4Mk5nSlVJQU5CQVdvaEF5QUJRUVIwQ3lJQlFSOTJOZ0lZSUFVZ0FVRUFTQVIvSUFGQkFYUUZJQVVnQVVFY2RqWUNXQ0FEUVFGcUlRTWdBVUVFZEFzaUFVRWZkallDSENBRklBRkJBRWdFZnlBQlFRRjBCU0FGSUFGQkhIWTJBbHdnQTBFQmFpRURJQUZCQkhRTElnRkJIM1kyQWlBZ0JTQUJRUUJJQkg4Z0FVRUJkQVVnQlNBQlFSeDJOZ0pnSUFOQkFXb2hBeUFCUVFSMEN5SUJRUjkyTmdJa0lBVWdBVUVBU0FSL0lBRkJBWFFGSUFVZ0FVRWNkallDWkNBRFFRRnFJUU1nQVVFRWRBc2lBVUVmZGpZQ0tDQUJRUUJJQkg4Z0FVRUJkQVVnQlNBQlFSeDJOZ0pvSUFOQkFXb2hBeUFCUVFSMEN5RUdBa0FnQUNBRFFRTnNRUWhxRUF0QmYwWU5BQ0FIUVFFMkFnZ2dCU0FBRUE4aUFVRWZkallDTEFKL0lBRkJBRWdFUUNBQlFRRjBJUVpCQUF3QkN5QUZJQUZCSEhZMkFtd2dBVUVFZENFR1FRRUxJUU1nQlNBR1FSOTJOZ0l3SUFVZ0JrRUFTQVIvSUFaQkFYUUZJQVVnQmtFY2RqWUNjQ0FEUVFGcUlRTWdCa0VFZEFzaUFVRWZkallDTkNBRklBRkJBRWdFZnlBQlFRRjBCU0FGSUFGQkhIWTJBblFnQTBFQmFpRURJQUZCQkhRTElnRkJIM1kyQWpnZ0JTQUJRUUJJQkg4Z0FVRUJkQVVnQlNBQlFSeDJOZ0o0SUFOQkFXb2hBeUFCUVFSMEN5SUJRUjkyTmdJOElBVkJRR3NnQVVFQVNBUi9JQUZCQVhRRklBVWdBVUVjZGpZQ2ZDQURRUUZxSVFNZ0FVRUVkQXNpQVVFZmRqWUNBQ0FGSUFGQkFFZ0VmeUFCUVFGMEJTQUZJQUZCSEhZMkFvQUJJQU5CQVdvaEF5QUJRUVIwQ3lJQlFSOTJOZ0pFSUFVZ0FVRUFTQVIvSUFGQkFYUUZJQVVnQVVFY2RqWUNoQUVnQTBFQmFpRURJQUZCQkhRTElnRkJIM1kyQWtnZ0FVRUFTQVIvSUFGQkFYUUZJQVVnQVVFY2RqWUNpQUVnQTBFQmFpRURJQUZCQkhRTElRWWdBQ0FEUVFOc1FRaHFFQXRCZjBZTkFDQUhJQVkyQWd3Z0IwRUNOZ0lJREFFTElBY2dCallDREVFQklRTU1BUXRCQVNFRElBQWdCMEVNYWhBQ0RRQWdCeWdDRENJQlFRTkxEUUFnQlNBQk5nS01BVUVBSVFNTElBTU5BUUpBSUFwQkFVY0VRQ0FBSUFkQkJHb2dDa1VRTFNJRERRTWdCU0FIS0FJRUlnRTJBZ1FnQVVVTkFnd0JDeUFGSUFVb0FnQWlBVUY1YWlJRFFRSjBRWEJ4SWdSQlVHb2dCQ0FEUVF0TEcwRVBRUUFnQVVFU1N4dHlOZ0lFQzBFQklRTWdBQ0FIUVF4cUVBVU5BU0FIS0FJTUlnRkJHbXBCTTBzTkFTQUZJQUUyQWdnZ0JVR1FBbW9oQ0NBRktBSUVJUVFDUUFKQUlBVW9BZ0JCQjBrRVFFRUFJUWxCQXlFREEwQWdBeUVCSUFSQkFYRUVRQ0FJSUFsQkFuUnFRYmdOYWlBQUlBZ2dDVUVHZEdwQk9Hb2dBaUFKSUFnUURVRVFFQWtpQTBFUWRqWUNBQ0FEUVE5eERRUWdDQ0FKUVFGMGFpQURRUVIyUWY4QmNUc0JBQ0FJSUFsQkFYSWlCa0VDZEdwQnVBMXFJQUFnQ0NBR1FRWjBha0U0YWlBQ0lBWWdDQkFOUVJBUUNTSURRUkIyTmdJQUlBTkJEM0VOQkNBSUlBWkJBWFJxSUFOQkJIWkIvd0Z4T3dFQUlBZ2dDVUVDY2lJR1FRSjBha0c0RFdvZ0FDQUlJQVpCQm5ScVFUaHFJQUlnQmlBSUVBMUJFQkFKSWdOQkVIWTJBZ0FnQTBFUGNRMEVJQWdnQmtFQmRHb2dBMEVFZGtIL0FYRTdBUUFnQ0NBSlFRTnlJZ1pCQW5ScVFiZ05haUFBSUFnZ0JrRUdkR3BCT0dvZ0FpQUdJQWdRRFVFUUVBa2lBMEVRZGpZQ0FDQURRUTl4RFFRZ0JTQUdRUUYwYWlBRFFRUjJRZjhCY1RzQmtBSUxJQVJCQVhZaEJDQUJRWDlxSVFNZ0NVRUVhaUVKSUFFTkFBc01BUXRCQUNFSklBQWdCVUhJRG1vZ0FrRUFJQWdRRFVFUUVBa2lBMEVQY1EwQklBVWdBMEVFZGtIL0FYRTdBY0FDSUFWQmtBSnFJUVpCQXlFREEwQWdBeUVCSUFSQkFYRUVRQ0FHSUFsQkFuUnFRYmdOYWlBQUlBWWdDVUVHZEdwQlBHb2dBaUFKSUFnUURVRVBFQWtpQTBFUGRqWUNBQ0FEUVE5eERRTWdCaUFKUVFGMGFpQURRUVIyUWY4QmNUc0JBQ0FHSUFsQkFYSWlDa0VDZEdwQnVBMXFJQUFnQmlBS1FRWjBha0U4YWlBQ0lBb2dDQkFOUVE4UUNTSURRUTkyTmdJQUlBTkJEM0VOQXlBR0lBcEJBWFJxSUFOQkJIWkIvd0Z4T3dFQUlBWWdDVUVDY2lJS1FRSjBha0c0RFdvZ0FDQUdJQXBCQm5ScVFUeHFJQUlnQ2lBSUVBMUJEeEFKSWdOQkQzWTJBZ0FnQTBFUGNRMERJQVlnQ2tFQmRHb2dBMEVFZGtIL0FYRTdBUUFnQmlBSlFRTnlJZ3BCQW5ScVFiZ05haUFBSUFZZ0NrRUdkR3BCUEdvZ0FpQUtJQWdRRFVFUEVBa2lBMEVQZGpZQ0FDQURRUTl4RFFNZ0JTQUtRUUYwYWlBRFFRUjJRZjhCY1RzQmtBSUxJQVJCQVhZaEJDQUJRWDlxSVFNZ0NVRUVhaUVKSUFFTkFBc0xJQVJCQTNFRVFDQUFJQVZCaUE5cVFYOUJCQkFKSWdOQkQzRU5BU0FGSUFOQkJIWkIvd0Z4T3dIQ0FpQUFJQVZCbUE5cVFYOUJCQkFKSWdOQkQzRU5BU0FGSUFOQkJIWkIvd0Z4T3dIRUFndEJBQ0VESUFSQkFuRkZEUUFnQUNBRlFjd0thaUFDUVJBZ0NCQU5RUThRQ1NJQlFROXhCRUFnQVNFRERBRUxJQVZCaUJCcUlBRkJEM1kyQWdBZ0JTQUJRUVIyUWY4QmNUc0JzQUlnQUNBRlFZd0xhaUFDUVJFZ0NCQU5RUThRQ1NJQlFROXhCRUFnQVNFRERBRUxJQVZCakJCcUlBRkJEM1kyQWdBZ0JTQUJRUVIyUWY4QmNUc0JzZ0lnQUNBRlFjd0xhaUFDUVJJZ0NCQU5RUThRQ1NJQlFROXhCRUFnQVNFRERBRUxJQVZCa0JCcUlBRkJEM1kyQWdBZ0JTQUJRUVIyUWY4QmNUc0J0QUlnQUNBRlFZd01haUFDUVJNZ0NCQU5RUThRQ1NJQlFROXhCRUFnQVNFRERBRUxJQVZCbEJCcUlBRkJEM1kyQWdBZ0JTQUJRUVIyUWY4QmNUc0J0Z0lnQUNBRlFjd01haUFDUVJRZ0NCQU5RUThRQ1NJQlFROXhCRUFnQVNFRERBRUxJQVZCbUJCcUlBRkJEM1kyQWdBZ0JTQUJRUVIyUWY4QmNUc0J1QUlnQUNBRlFZd05haUFDUVJVZ0NCQU5RUThRQ1NJQlFROXhCRUFnQVNFRERBRUxJQVZCbkJCcUlBRkJEM1kyQWdBZ0JTQUJRUVIyUWY4QmNUc0J1Z0lnQUNBRlFjd05haUFDUVJZZ0NCQU5RUThRQ1NJQlFROXhCRUFnQVNFRERBRUxJQVZCb0JCcUlBRkJEM1kyQWdBZ0JTQUJRUVIyUWY4QmNUc0J2QUlnQUNBRlFZd09haUFDUVJjZ0NCQU5RUThRQ1NJQlFROXhCRUFnQVNFRERBRUxJQVZCcEJCcUlBRkJEM1kyQWdBZ0JTQUJRUVIyUWY4QmNUc0J2Z0lMSUFBZ0FDZ0NDQ0FBS0FJRUlBQW9BZ0JyUVFOMGFqWUNFQ0FERFFFTFFRQWhBd3NnQjBFUWFpUUFJQU1McFJRQkRIOENmeUFBS0FMSUFTSUhCRUFnQUNnQ0JDQUhLQUlFUmd3QkMwRUFDeUVLQWtBZ0JrVU5BQ0FLUlEwQVFRQWdDa0VDSUFBb0FzZ0JLQUlBSWdkQkJrY2dCMEVHU1J0QkFrWWJJUW9MQW44Z0FDZ0N6QUVpQndSQUlBQW9BZ1FnQnlnQ0JFWU1BUXRCQUFzaEJ3SkFJQVpGRFFBZ0IwVU5BRUVBSUFkQkFpQUFLQUxNQVNnQ0FDSUhRUVpISUFkQkJra2JRUUpHR3lFSEN3Si9JQUFvQXRRQklna0VRQ0FBS0FJRUlBa29BZ1JHREFFTFFRQUxJUWtDUUNBR1JRMEFJQWxGRFFCQkFpQUFLQUxVQVNnQ0FDSUFRUVpISUFCQkJra2JRUUpISVFrTElBcEJBRWNnQjBFQVIzRWlEU0FKUVFCSGNTRU9JQVZCQWtzaEQwRVFJUXNEUUFKQUlBOUZCRUFDUUFKQUFrQWdCVUVCYXc0Q0FRSUFDeUFCQW44Z0RRUkFJQVF0QUFNZ0JDMEFBaUFFTFFBQklBUXRBQUFnQXkwQUJDQURMUUFESUFNdEFBRWdBeTBBQW1wcWFtcHFhbXBCQkdwQkEzWWhCaUFETFFBSUlBTXRBQWNnQXkwQUJTQURMUUFHYW1wcVFRSnFRUUoyREFFTElBY0VRQ0FETFFBRUlBTXRBQU1nQXkwQUFTQURMUUFDYW1wcVFRSnFRUUoySVFZZ0F5MEFDQ0FETFFBSElBTXRBQVVnQXkwQUJtcHFha0VDYWtFQ2Rnd0JDeUFLUlFSQVFZQUJJUVpCZ0FFTUFRc2dCQzBBQXlBRUxRQUNJQVF0QUFBZ0JDMEFBV3BxYWtFQ2FrRUNkaUlHQzBIL0FYRkJnWUtFQ0d3aUFEWUFIQ0FCSUFaQi93RnhRWUdDaEFoc0lnWTJBQmdnQVNBQU5nQVVJQUVnQmpZQUVDQUJJQUEyQUF3Z0FTQUdOZ0FJSUFFZ0FEWUFCQ0FCSUFZMkFBQUNmeUFLQkVBZ0JDMEFCeUFFTFFBR0lBUXRBQVVnQkMwQUJHcHFhaUlHUVFKcVFRSjJJZ0FnQjBVTkFSb2dBeTBBQ0NBRExRQUhJQU10QUFZZ0JpQURMUUFGYW1wcWFrRUVha0VEZGd3QkN5QUhSUVJBUVlBQklRQkJnQUVNQVFzZ0F5MEFCQ0FETFFBRElBTXRBQUVnQXkwQUFtcHFha0VDYWtFQ2RpRUFJQU10QUFnZ0F5MEFCeUFETFFBRklBTXRBQVpxYW1wQkFtcEJBbllMSVFZZ0FTQUFRZjhCY1VHQmdvUUliQ0lBTmdBZ0lBRWdCa0gvQVhGQmdZS0VDR3dpQmpZQVBDQUJJQUEyQURnZ0FTQUdOZ0EwSUFFZ0FEWUFNQ0FCSUFZMkFDd2dBU0FBTmdBb0lBRWdCallBSkF3REN5QUtSUVJBUVFFUEN5QUJJQVF0QUFBNkFBQWdBU0FFTFFBQU9nQUJJQUVnQkMwQUFEb0FBaUFCSUFRdEFBQTZBQU1nQVNBRUxRQUFPZ0FFSUFFZ0JDMEFBRG9BQlNBQklBUXRBQUE2QUFZZ0FTQUVMUUFBT2dBSElBRWdCQzBBQVRvQUNDQUJJQVF0QUFFNkFBa2dBU0FFTFFBQk9nQUtJQUVnQkMwQUFUb0FDeUFCSUFRdEFBRTZBQXdnQVNBRUxRQUJPZ0FOSUFFZ0JDMEFBVG9BRGlBQklBUXRBQUU2QUE4Z0FTQUVMUUFDT2dBUUlBRWdCQzBBQWpvQUVTQUJJQVF0QUFJNkFCSWdBU0FFTFFBQ09nQVRJQUVnQkMwQUFqb0FGQ0FCSUFRdEFBSTZBQlVnQVNBRUxRQUNPZ0FXSUFFZ0JDMEFBam9BRnlBQklBUXRBQU02QUJnZ0FTQUVMUUFET2dBWklBRWdCQzBBQXpvQUdpQUJJQVF0QUFNNkFCc2dBU0FFTFFBRE9nQWNJQUVnQkMwQUF6b0FIU0FCSUFRdEFBTTZBQjRnQVNBRUxRQURPZ0FmSUFFZ0JDMEFCRG9BSUNBQklBUXRBQVE2QUNFZ0FTQUVMUUFFT2dBaUlBRWdCQzBBQkRvQUl5QUJJQVF0QUFRNkFDUWdBU0FFTFFBRU9nQWxJQUVnQkMwQUJEb0FKaUFCSUFRdEFBUTZBQ2NnQVNBRUxRQUZPZ0FvSUFFZ0JDMEFCVG9BS1NBQklBUXRBQVU2QUNvZ0FTQUVMUUFGT2dBcklBRWdCQzBBQlRvQUxDQUJJQVF0QUFVNkFDMGdBU0FFTFFBRk9nQXVJQUVnQkMwQUJUb0FMeUFCSUFRdEFBWTZBREFnQVNBRUxRQUdPZ0F4SUFFZ0JDMEFCam9BTWlBQklBUXRBQVk2QURNZ0FTQUVMUUFHT2dBMElBRWdCQzBBQmpvQU5TQUJJQVF0QUFZNkFEWWdBU0FFTFFBR09nQTNJQUVnQkMwQUJ6b0FPQ0FCSUFRdEFBYzZBRGtnQVNBRUxRQUhPZ0E2SUFFZ0JDMEFCem9BT3lBQklBUXRBQWM2QUR3Z0FTQUVMUUFIT2dBOUlBRWdCQzBBQnpvQVBpQUJJQVF0QUFjNkFEOE1BZ3NnQjBVRVFFRUJEd3NnQVNBRExRQUJPZ0FBSUFFZ0F5MEFBVG9BQ0NBQklBTXRBQUU2QUJBZ0FTQURMUUFCT2dBWUlBRWdBeTBBQVRvQUlDQUJJQU10QUFFNkFDZ2dBU0FETFFBQk9nQXdJQUVnQXkwQUFUb0FPQ0FCSUFNdEFBSTZBQUVnQVNBRExRQUNPZ0FKSUFFZ0F5MEFBam9BRVNBQklBTXRBQUk2QUJrZ0FTQURMUUFDT2dBaElBRWdBeTBBQWpvQUtTQUJJQU10QUFJNkFERWdBU0FETFFBQ09nQTVJQUVnQXkwQUF6b0FBaUFCSUFNdEFBTTZBQW9nQVNBRExRQURPZ0FTSUFFZ0F5MEFBem9BR2lBQklBTXRBQU02QUNJZ0FTQURMUUFET2dBcUlBRWdBeTBBQXpvQU1pQUJJQU10QUFNNkFEb2dBU0FETFFBRU9nQURJQUVnQXkwQUJEb0FDeUFCSUFNdEFBUTZBQk1nQVNBRExRQUVPZ0FiSUFFZ0F5MEFCRG9BSXlBQklBTXRBQVE2QUNzZ0FTQURMUUFFT2dBeklBRWdBeTBBQkRvQU95QUJJQU10QUFVNkFBUWdBU0FETFFBRk9nQU1JQUVnQXkwQUJUb0FGQ0FCSUFNdEFBVTZBQndnQVNBRExRQUZPZ0FrSUFFZ0F5MEFCVG9BTENBQklBTXRBQVU2QURRZ0FTQURMUUFGT2dBOElBRWdBeTBBQmpvQUJTQUJJQU10QUFZNkFBMGdBU0FETFFBR09nQVZJQUVnQXkwQUJqb0FIU0FCSUFNdEFBWTZBQ1VnQVNBRExRQUdPZ0F0SUFFZ0F5MEFCam9BTlNBQklBTXRBQVk2QUQwZ0FTQURMUUFIT2dBR0lBRWdBeTBBQnpvQURpQUJJQU10QUFjNkFCWWdBU0FETFFBSE9nQWVJQUVnQXkwQUJ6b0FKaUFCSUFNdEFBYzZBQzRnQVNBRExRQUhPZ0EySUFFZ0F5MEFCem9BUGlBQklBTXRBQWc2QUFjZ0FTQURMUUFJT2dBUElBRWdBeTBBQ0RvQUZ5QUJJQU10QUFnNkFCOGdBU0FETFFBSU9nQW5JQUVnQXkwQUNEb0FMeUFCSUFNdEFBZzZBRGNnQVNBRExRQUlPZ0EvREFFTElBNUZCRUJCQVE4TElBTXRBQVVnQXkwQUEyc2dBeTBBQmlBRExRQUNhMEVCZEdvZ0F5MEFCeUFETFFBQmEwRURiR29nQXkwQUNDSUFJQU10QUFBaUNXdEJBblJxUVJGc1FSQnFRUVYxSWdaQmZXd2hFQ0FBSUFRdEFBY2lER3BCQkhRZ0JDMEFCQ0FFTFFBQ2F5QU1JQWxyUVFKMGFpQUVMUUFGSUFRdEFBRnJRUUYwYWlBRUxRQUdJQVF0QUFCclFRTnNha0VSYkVFUWFrRUZkU0lSUVgxc2FrRVFhaUVKUVFnaERDQUJJUUFEUUNBQUlBa2dFR29pQ0VFRmRVR3dMbW90QUFBNkFBQWdBQ0FHSUFocUlnaEJCWFZCc0M1cUxRQUFPZ0FCSUFBZ0JpQUlhaUlJUVFWMVFiQXVhaTBBQURvQUFpQUFJQVlnQ0dvaUNFRUZkVUd3TG1vdEFBQTZBQU1nQUNBR0lBaHFJZ2hCQlhWQnNDNXFMUUFBT2dBRUlBQWdCaUFJYWlJSVFRVjFRYkF1YWkwQUFEb0FCU0FBSUFZZ0NHb2lDRUVGZFVHd0xtb3RBQUE2QUFZZ0FDQUdJQWhxUVFWMVFiQXVhaTBBQURvQUJ5QUpJQkZxSVFrZ0FFRUlhaUVBSUF4QmYyb2lEQTBBQ3dzZ0FTQUNJQXNRQ0NBQklBSkJRR3NnQzBFQmNoQUlJQUVnQWtHQUFXb2dDMEVDY2hBSUlBRWdBa0hBQVdvZ0MwRURjaEFJSUFKQmdBSnFJUUlnQkVFSWFpRUVJQU5CQ1dvaEF5QUJRVUJySVFFZ0MwRUVhaUVMSUJKQkFXb2lFa0VDUncwQUMwRUFDNkVWQWhoL0FuNENmd05BQW44Z0FDSUlJQlpCQTNSQnNEVnFLUUlBSWg2bkVCRWlDU0lHQkVBZ0NDZ0NCQ0FHS0FJRVJnd0JDMEVBQ3lFTkFrQWdCVVVOQUNBTlJRMEFRUUFnRFVFQ0lBa29BZ0FpQmtFR1J5QUdRUVpKRzBFQ1Joc2hEUXNDZnlBSUlCWkJBM1JCOERacUtRSUFJaCtuRUJFaUJ5SUdCRUFnQ0NnQ0JDQUdLQUlFUmd3QkMwRUFDeUVQQWtBZ0JVVU5BQ0FQUlEwQVFRQWdEMEVDSUFjb0FnQWlCa0VHUnlBR1FRWkpHMEVDUmhzaER3dEJBaUVNSUExQkFFY2dEMEVBUjNFaUVrRUJSZ1JBUVFJaEJnSi9RUUlnQ1NnQ0FDSUxRUVpISUF0QkJra2JSUVJBSUFrZ0hrSWdpS2RCL3dGeGFpMEFVaUVHQ3lBR0N3Si9RUUlnQnlnQ0FDSUpRUVpISUFsQkJra2JSUVJBSUFjZ0gwSWdpS2RCL3dGeGFpMEFVaUVNQ3lBTUN5QUdJQXhKR3lFTUN5QUNJQlpCQW5RaUNXb2lCaWdDREVVRVFDQUdLQUpNSWdZZ0JpQU1UMm9oREFzZ0NDQVdhaUFNT2dCU0FuOGdDQ0FXUVFOMFFiQTRhaWdDQUJBUklnWWlCd1JBSUFnb0FnUWdCeWdDQkVZTUFRdEJBQXNoRGdKQUlBVkZEUUFnRGtVTkFFRUFJQTVCQWlBR0tBSUFJZ1pCQmtjZ0JrRUdTUnRCQWtZYklRNExBbjhnQUNBV1FRTjBRZkE1YWlnQ0FCQVJJZ2dpQmdSQUlBQW9BZ1FnQmlnQ0JFWU1BUXRCQUFzaEVRSkFJQVZGRFFBZ0VVVU5BRUVBSUJGQkFpQUlLQUlBSWdoQkJrY2dDRUVHU1J0QkFrWWJJUkVMSUFsQjhDbHFLQUlBSVJjZ0NVR3dLV29vQWdBaEdBSi9RWVVLSUJaMlFRRnhJaHdFUUNBWFFRTnFJUWNnQkNBWGFpSUlRUUpxSVFZZ0NFRUJhaUVMSUFRTUFRc2dGMEVFZENBWWFpSUlRUzlxSVFjZ0FTQUlhaUlJUVI5cUlRWWdDRUVQYWlFTElBaEJmMm9oQ0NBQkN5RUpJQWNnQ1dvdEFBQWhDaUFHTFFBQUlSQWdDeTBBQUNFVElBZ3RBQUFoRkFKQVFUTWdGblpCQVhFRVFDQURJQmhxSWdjdEFBZ2hHeUFITFFBSElSa2dCeTBBQmlFVklBY3RBQVVoR2lBSExRQUVJUVlnQnkwQUF5RUxJQWN0QUFJaENTQUhMUUFCSVFnTUFRc2dBU0FYUVg5cUloMUJCSFFnR0dwcUlnY3RBQUFoQ0NBSExRQUhJUnNnQnkwQUJpRVpJQWN0QUFVaEZTQUhMUUFFSVJvZ0J5MEFBeUVHSUFjdEFBSWhDeUFITFFBQklRa2dIQVJBSUFRZ0hXb2hCd3dCQ3lBSFFYOXFJUWNMQWtBZ0RFRUhUUVJBSUFjdEFBQWhCd0pBQWtBQ1FBSkFBa0FDUUFKQUFrQWdERUVCYXc0SEFRSURCQVVHQndBTElBOUZCRUJCQVE4TElBaEIvd0Z4SUF0Qi93RnhRUkIwSUFaQkdIUnljaUFKUWY4QmNVRUlkSEloRlNBSUlnd2hEU0FKSWc0aEVpQUxJZzhoQ2lBR0loRWhCd3dJQ3lBTlJRUkFRUUVQQ3lBS1FZR0NoQWhzSVJVZ0VFR0Jnb1FJYkNJTlFSaDJJUWNnRFVFUWRpRUtJQTFCQ0hZaEVpQVRRWUdDaEFoc0lneEJHSFloRVNBTVFSQjJJUThnREVFSWRpRU9JQlJCZ1lLRUNHd2lDRUVZZGlFR0lBaEJFSFloQ3lBSVFRaDJJUWtNQndzQ2Z5QVRJQlJxSUFwcUlCQnFJQVpCL3dGeGFpQUxRZjhCY1dvZ0NVSC9BWEZxSUFoQi93Rnhha0VFYWtFRGRpQVNEUUFhSUJNZ0ZHb2dDbW9nRUdwQkFtcEJBbllnRFEwQUdrR0FBU0FQUlEwQUdpQUdRZjhCY1NBTFFmOEJjV29nQ1VIL0FYRnFJQWhCL3dGeGFrRUNha0VDZGdzaUNFR0Jnb1FJYkNFVklBZ2lDU0lMSWdZaURDSU9JZzhpRVNJTkloSWlDaUVIREFZTElBOUZCRUJCQVE4TElBWkIvd0Z4SWcxQkFtb2lFU0FWSUFZZ0RodEIvd0Z4SWdkcUlCb2dCaUFPRzBIL0FYRWlDa0VCZEdwQkFuWWlEeUFaSUFZZ0RodEIvd0Z4SWd3Z0d5QUdJQTRiUWY4QmNTSUdRUU5zYWtFV2RFR0FnSUFFYWtHQWdJQjRjWElnQ2lBTWFpQUhRUUYwYWtFQ2FpSVFRUVowUVlEK0EzRnlJQVlnQjJvZ0RFRUJkR3BCQW1vaUJrRU9kRUdBZ1B3SGNYSWhGU0FHUVFKMklRY2dDMEgvQVhFaUJrRUNhaUlMSUFoQi93RnhhaUFKUWY4QmNTSUpRUUYwYWtFQ2RpRUlJQWtnRVdvZ0JrRUJkR3BCQW5ZaUNTRU1JQW9nQzJvZ0RVRUJkR3BCQW5ZaUN5RU9JQXNoRFNBUElnWWhFaUFRUVFKMkloRWhDZ3dGQzBFQklCRkZJQkpCQVhOeURRWWFJQlFnRTBFQmRHb2dFR3BCQW1vaURrRUdkRUdBL2dOeElBb2dFMEVDYWlJUGFpQVFRUUYwYWtFQ2RuSWdDRUgvQVhFaUNrRUNhaUlNSUJScUlBZEJBWFJxUVFKMklnaEJHSFJ5SUE4Z0ZFRUJkR29nQjJvaUVFRU9kRUdBZ1B3SGNYSWhGU0FKUWY4QmNTSVJRUUpxSWdrZ0JrSC9BWEZxSUF0Qi93RnhJZ3RCQVhScVFRSjJJUVlnRGtFQ2RpRU5JQWtnQ2tFQmRHb2dCMnBCQW5ZaUNTRVBJQkZCQVhRZ0Myb2dER3BCQW5ZaUN5RVJJQkJCQW5ZaURDRVNJQWdpRGlFS0lBa2hCd3dFQzBFQklCRkZJQkpCQVhOeURRVWFJQWhCL3dGeElncEJBbW9pRGlBTFFmOEJjU0lJSUFsQi93RnhJZ3RCQVhScWFrRUNkaUlQUVJoMElCUWdFMEVCZEdvZ0VHcEJBbXBCQW5aeUlBNGdGR29nQjBFQmRHb2lDVUVHZEVHQS9nTnhjaUFMUVFKcUlnNGdDa0VCZEdvZ0Iyb2lEVUVPZEVHQWdQd0hjWEloRlNBSVFRRnFJaEFnQmtIL0FYRWlER3BCQVhZaEJpQU1JQTVxSUFoQkFYUnFRUUoySVJFZ0NVRUNkaUVNSUExQkFuWWhEaUFUSUJSQkFYUnFJQWRxUVFKcVFRSjJJUTBnQnlBS2FrRUJha0VCZGlJSUlSSWdDaUFMYWtFQmFrRUJkaUlKSVFvZ0N5QVFha0VCZGlJTElRY01Bd3RCQVNBUlJTQVNRUUZ6Y2cwRUdpQVRRUUpxSWc0Z0Ntb2dFRUVCZEdwQkJuUkJnUDREY1NBUUlCTnFRUUZxSWc5QkQzUkJnSUQ4QjNFZ0ZFRUNhaUlNSUJOQkFYUnFJQkJxUVFKMkloSkJHSFJ5SUFvZ0VHcEJBV3BCQVhaeWNpRVZJQWhCL3dGeElnZ2dDMEgvQVhGcUlBbEIvd0Z4SWdsQkFYUnFRUUpxUVFKMklRWWdDU0FJUVFGMGFpQUhha0VDYWtFQ2RpRUxJQTlCQVhZaERTQUlJQXhxSUFkQkFYUnFRUUoySWhFaENTQVVRUUZxSWdvZ0IycEJBWFlpQ0NFUElBb2dFMnBCQVhZaURDRUtJQTRnRkVFQmRHb2dCMnBCQW5ZaURpRUhEQUlMSUE5RkJFQkJBUThMSUJvZ0JpQU9HMEgvQVhFaUNpQVpJQVlnRGh0Qi93RnhhaUFWSUFZZ0RodEIvd0Z4SWdkQkFYUnFRUlowSUF0Qi93RnhJZ3RCQW1vaURDQUthaUFHUWY4QmNTSUdRUUYwYWlJUFFRWjBja0dBZ0lBRWFrR0Evb040Y1NBR1FRSnFJZzBnQ1VIL0FYRWlDV29nQzBFQmRHcEJBbllpRG5JZ0J5QU5haUFLUVFGMGFpSU5RUTUwUVlDQS9BZHhjaUVWSUFjZ0NtcEJBV3BCQVhZaEJ5QU5RUUoySVJFZ0NTQUlRZjhCY1NJTmFrRUJha0VCZGlFSUlBOUJBblloRHlBTUlBMXFJQWxCQVhScVFRSjJJUXdnQ1NBTGFrRUJha0VCZGlJSklRMGdCa0VCYWlJR0lBdHFRUUYySWdzaEVpQUdJQXBxUVFGMklnWWhDZ3dCQ3lBTlJRUkFRUUVQQ3lBS1FRaDBJQXB5SUFwQkVIUnlJQXBCR0hSeUlSVWdFRUVDYWlJSElCUnFJQk5CQVhScVFRSjJJUWtnRTBFQmFpSUdJQlJxUVFGMklRZ2dCaUFRYWtFQmRpSUxJUXdnQ2lBVGFpQVFRUUYwYWtFQ2FrRUNkaUlHSVE0Z0NpQVFha0VCYWtFQmRpSVBJUTBnQnlBS1FRTnNha0VDZGlJUklSSWdDaUVIQ3lBQklCZEJCSFFnR0dwcUloQWdGVFlDTUNBUUlBMUIvd0Z4SUJKQi93RnhRUWgwY2lBS1FmOEJjVUVRZEhJZ0IwRVlkSEkyQWlBZ0VDQU1RZjhCY1NBT1FmOEJjVUVJZEhJZ0QwSC9BWEZCRUhSeUlCRkJHSFJ5TmdJUUlCQWdDRUgvQVhFZ0NVSC9BWEZCQ0hSeUlBdEIvd0Z4UVJCMGNpQUdRUmgwY2pZQ0FDQUJJQUlnRmtFR2RHcEJ5QUpxSUJZUUNDQVdRUUZxSWhaQkVFY05BQXRCQUFzTHhSSUJFSDhDZnlBQUtBTElBU0lIQkVBZ0FDZ0NCQ0FIS0FJRVJnd0JDMEVBQ3lFSEFrQWdCVVVOQUNBSFJRMEFRUUFnQjBFQ0lBQW9Bc2dCS0FJQUlnZEJCa2NnQjBFR1NSdEJBa1liSVFjTEFuOGdBQ2dDekFFaUNBUkFJQUFvQWdRZ0NDZ0NCRVlNQVF0QkFBc2hDQUpBSUFWRkRRQWdDRVVOQUVFQUlBaEJBaUFBS0FMTUFTZ0NBQ0lJUVFaSElBaEJCa2tiUVFKR0d5RUlDd0ovSUFBb0F0UUJJZ2tFUUNBQUtBSUVJQWtvQWdSR0RBRUxRUUFMSVFrQ1FDQUZSUTBBSUFsRkRRQkJBaUFBS0FMVUFTZ0NBQ0lGUVFaSElBVkJCa2tiUVFKSElRa0xBa0FDUUNBQUtBSUFRUUZxUVFOeElnQkJBazBFUUFKQUFrQUNRQ0FBUVFGckRnSUJBZ0FMSUFoRkJFQkJBUThMUVFBaEJTQUJJUUFEUUNBQUlBTXRBQUU2QUFBZ0FDQURMUUFDT2dBQklBQWdBeTBBQXpvQUFpQUFJQU10QUFRNkFBTWdBQ0FETFFBRk9nQUVJQUFnQXkwQUJqb0FCU0FBSUFNdEFBYzZBQVlnQUNBRExRQUlPZ0FISUFBZ0F5MEFDVG9BQ0NBQUlBTXRBQW82QUFrZ0FDQURMUUFMT2dBS0lBQWdBeTBBRERvQUN5QUFJQU10QUEwNkFBd2dBQ0FETFFBT09nQU5JQUFnQXkwQUR6b0FEaUFBSUFNdEFCQTZBQThnQUVFUWFpRUFJQVZCQVdvaUJVRVFSdzBBQ3d3REN5QUhSUVJBUVFFUEMwRUFJUVVnQVNFQUEwQWdBQ0FFSUFWcUlnTXRBQUE2QUFBZ0FDQURMUUFBT2dBQklBQWdBeTBBQURvQUFpQUFJQU10QUFBNkFBTWdBQ0FETFFBQU9nQUVJQUFnQXkwQUFEb0FCU0FBSUFNdEFBQTZBQVlnQUNBRExRQUFPZ0FISUFBZ0F5MEFBRG9BQ0NBQUlBTXRBQUE2QUFrZ0FDQURMUUFBT2dBS0lBQWdBeTBBQURvQUN5QUFJQU10QUFBNkFBd2dBQ0FETFFBQU9nQU5JQUFnQXkwQUFEb0FEaUFBSUFNdEFBQTZBQThnQUVFUWFpRUFJQVZCQVdvaUJVRVFSdzBBQ3d3Q0N5QUJBbjhDUUNBSFJRMEFJQWhGRFFBZ0JDMEFEeUFETFFBUUlBUXRBQTRnQXkwQUR5QUVMUUFOSUFNdEFBNGdCQzBBRENBRExRQU5JQVF0QUFzZ0F5MEFEQ0FFTFFBS0lBTXRBQXNnQkMwQUNTQURMUUFLSUFRdEFBZ2dBeTBBQ1NBRUxRQUhJQU10QUFnZ0JDMEFCaUFETFFBSElBUXRBQVVnQXkwQUJpQUVMUUFFSUFNdEFBVWdCQzBBQXlBRExRQUVJQVF0QUFJZ0F5MEFBeUFFTFFBQklBTXRBQUlnQXkwQUFTQUVMUUFBYW1wcWFtcHFhbXBxYW1wcWFtcHFhbXBxYW1wcWFtcHFhbXBxYW1wcWFrRVFha0VGZGd3QkN5QUhCRUFnQkMwQUR5QUVMUUFPSUFRdEFBMGdCQzBBRENBRUxRQUxJQVF0QUFvZ0JDMEFDU0FFTFFBSUlBUXRBQWNnQkMwQUJpQUVMUUFGSUFRdEFBUWdCQzBBQXlBRUxRQUNJQVF0QUFBZ0JDMEFBV3BxYW1wcWFtcHFhbXBxYW1wcWFrRUlha0VFZGd3QkMwR0FBU0FJUlEwQUdpQURMUUFRSUFNdEFBOGdBeTBBRGlBRExRQU5JQU10QUF3Z0F5MEFDeUFETFFBS0lBTXRBQWtnQXkwQUNDQURMUUFISUFNdEFBWWdBeTBBQlNBRExRQUVJQU10QUFNZ0F5MEFBU0FETFFBQ2FtcHFhbXBxYW1wcWFtcHFhbXBxUVFocVFRUjJDMEdBQWhBSEdnd0JDMEVCSVFBZ0IwVU5BU0FJUlEwQklBbEZEUUVnQkMwQUNDQUVMUUFHYXlBRUxRQVBJZ0FnQXkwQUFDSUZhMEVEZEdvZ0JDMEFDU0FFTFFBRmEwRUJkR29nQkMwQUNpQUVMUUFFYTBFRGJHb2dCQzBBQ3lBRUxRQURhMEVDZEdvZ0JDMEFEQ0FFTFFBQ2EwRUZiR29nQkMwQURTQUVMUUFCYTBFR2JHb2dCQzBBRGlBRUxRQUFhMEVIYkdwQkJXeEJJR3BCQm5VaEJ5QURMUUFKSUFNdEFBZHJJQU10QUFvZ0F5MEFCbXRCQVhScUlBTXRBQXNnQXkwQUJXdEJBMnhxSUFNdEFBd2dBeTBBQkd0QkFuUnFJQU10QUEwZ0F5MEFBMnRCQld4cUlBTXRBQTRnQXkwQUFtdEJCbXhxSUFNdEFBOGdBeTBBQVd0QkIyeHFJQU10QUJBaUF5QUZhMEVEZEdwQkJXeEJJR3BCQm5VaUJFRURkQ0VJSUFSQkIyd2hDU0FFUVFac0lRb2dCRUVGYkNFTElBUkJBMndoRENBRVFYMXNJUTBnQkVGN2JDRU9JQVJCZW13aER5QUVRWGxzSVJCQkFDQUVRUUYwSWhGcklSSkJBQ0FFUVFKMEloTnJJUlFnQUNBRGFrRUVkRUVRYWlFVlFRQWhCUU5BSUFFZ0JVRUVkQ0lBYWlBVklBVkJlV29nQjJ4cUlnTWdFR3BCQlhVaUJrSC9BU0FHUWY4QlNCc2lCa0VBSUFaQkFFb2JPZ0FBSUFFZ0FFRUJjbW9nQXlBUGFrRUZkU0lHUWY4QklBWkIvd0ZJR3lJR1FRQWdCa0VBU2hzNkFBQWdBU0FBUVFKeWFpQURJQTVxUVFWMUlnWkIvd0VnQmtIL0FVZ2JJZ1pCQUNBR1FRQktHem9BQUNBQklBQkJBM0pxSUFNZ0ZHcEJCWFVpQmtIL0FTQUdRZjhCU0JzaUJrRUFJQVpCQUVvYk9nQUFJQUVnQUVFRWNtb2dBeUFOYWtFRmRTSUdRZjhCSUFaQi93RklHeUlHUVFBZ0JrRUFTaHM2QUFBZ0FTQUFRUVZ5YWlBRElCSnFRUVYxSWdaQi93RWdCa0gvQVVnYklnWkJBQ0FHUVFCS0d6b0FBQ0FCSUFCQkJuSnFJQU1nQkd0QkJYVWlCa0gvQVNBR1FmOEJTQnNpQmtFQUlBWkJBRW9iT2dBQUlBRWdBRUVIY21vZ0EwRUZkU0lHUWY4QklBWkIvd0ZJR3lJR1FRQWdCa0VBU2hzNkFBQWdBU0FBUVFoeWFpQURJQVJxUVFWMUlnWkIvd0VnQmtIL0FVZ2JJZ1pCQUNBR1FRQktHem9BQUNBQklBQkJDWEpxSUFNZ0VXcEJCWFVpQmtIL0FTQUdRZjhCU0JzaUJrRUFJQVpCQUVvYk9nQUFJQUVnQUVFS2Ntb2dBeUFNYWtFRmRTSUdRZjhCSUFaQi93RklHeUlHUVFBZ0JrRUFTaHM2QUFBZ0FTQUFRUXR5YWlBRElCTnFRUVYxSWdaQi93RWdCa0gvQVVnYklnWkJBQ0FHUVFCS0d6b0FBQ0FCSUFCQkRISnFJQU1nQzJwQkJYVWlCa0gvQVNBR1FmOEJTQnNpQmtFQUlBWkJBRW9iT2dBQUlBRWdBRUVOY21vZ0F5QUtha0VGZFNJR1FmOEJJQVpCL3dGSUd5SUdRUUFnQmtFQVNoczZBQUFnQVNBQVFRNXlhaUFESUFscVFRVjFJZ1pCL3dFZ0JrSC9BVWdiSWdaQkFDQUdRUUJLR3pvQUFDQUJJQUJCRDNKcUlBTWdDR3BCQlhVaUFFSC9BU0FBUWY4QlNCc2lBRUVBSUFCQkFFb2JPZ0FBSUFWQkFXb2lCVUVRUncwQUN3dEJBQ0VBSUFFZ0FrRUFFQWdnQVNBQ1FVQnJRUUVRQ0NBQklBSkJnQUZxUVFJUUNDQUJJQUpCd0FGcVFRTVFDQ0FCSUFKQmdBSnFRUVFRQ0NBQklBSkJ3QUpxUVFVUUNDQUJJQUpCZ0FOcVFRWVFDQ0FCSUFKQndBTnFRUWNRQ0NBQklBSkJnQVJxUVFnUUNDQUJJQUpCd0FScVFRa1FDQ0FCSUFKQmdBVnFRUW9RQ0NBQklBSkJ3QVZxUVFzUUNDQUJJQUpCZ0FacVFRd1FDQ0FCSUFKQndBWnFRUTBRQ0NBQklBSkJnQWRxUVE0UUNDQUJJQUpCd0FkcVFROFFDQXNnQUF2QkNBRUhmd0pBSUFORkRRQWdBQ2dDQUNBRElBQW9BZ1FpQlc0aUNDQUZiQ0lFUVFoMGFpQURJQVJySWdkQkJIUnFJUVlnQlVFRWRDRUVJQUFvQWdnaENTQUZJQU5MSWdwRkJFQWdBU0FHSUFSQmYzTnFJZ010QUFBNkFBQWdBU0FHSUFSckxRQUFPZ0FCSUFFZ0F5MEFBam9BQWlBQklBTXRBQU02QUFNZ0FTQURMUUFFT2dBRUlBRWdBeTBBQlRvQUJTQUJJQU10QUFZNkFBWWdBU0FETFFBSE9nQUhJQUVnQXkwQUNEb0FDQ0FCSUFNdEFBazZBQWtnQVNBRExRQUtPZ0FLSUFFZ0F5MEFDem9BQ3lBQklBTXRBQXc2QUF3Z0FTQURMUUFOT2dBTklBRWdBeTBBRGpvQURpQUJJQU10QUE4NkFBOGdBU0FETFFBUU9nQVFJQUVnQXkwQUVUb0FFU0FCSUFNdEFCSTZBQklnQVNBRExRQVRPZ0FUSUFFZ0F5MEFGRG9BRkNBQlFSVnFJUUVMSUFjRVFDQUNJQVpCZjJvaUF5MEFBRG9BQUNBQ0lBTWdCR29pQXkwQUFEb0FBU0FDSUFNZ0JHb2lBeTBBQURvQUFpQUNJQU1nQkdvaUF5MEFBRG9BQXlBQ0lBTWdCR29pQXkwQUFEb0FCQ0FDSUFNZ0JHb2lBeTBBQURvQUJTQUNJQU1nQkdvaUF5MEFBRG9BQmlBQ0lBTWdCR29pQXkwQUFEb0FCeUFDSUFNZ0JHb2lBeTBBQURvQUNDQUNJQU1nQkdvaUF5MEFBRG9BQ1NBQ0lBTWdCR29pQXkwQUFEb0FDaUFDSUFNZ0JHb2lBeTBBQURvQUN5QUNJQU1nQkdvaUF5MEFBRG9BRENBQ0lBTWdCR29pQXkwQUFEb0FEU0FDSUFNZ0JHb2lBeTBBQURvQURpQUNJQU1nQkdvdEFBQTZBQThnQWtFUWFpRUNDeUFBS0FJQUlBVWdDV3dpQmtFSWRHb2dDQ0FGUVFOMElnQnNRUU4wYWlBSFFRTjBhaUVFSUFCQitQLy8vd2R4SVFBZ0NrVUVRQ0FCSUFRZ0FFRi9jMm9pQXkwQUFEb0FBQ0FCSUFRZ0FHc3RBQUE2QUFFZ0FTQURMUUFDT2dBQ0lBRWdBeTBBQXpvQUF5QUJJQU10QUFRNkFBUWdBU0FETFFBRk9nQUZJQUVnQXkwQUJqb0FCaUFCSUFNdEFBYzZBQWNnQVNBRFFRaHFJZ010QUFBNkFBZ2dBU0FHUVFaMElBTnFJZ05CZUdvdEFBQTZBQWtnQVNBRFFYbHFMUUFBT2dBS0lBRWdBMEY2YWkwQUFEb0FDeUFCSUFOQmUyb3RBQUE2QUF3Z0FTQURRWHhxTFFBQU9nQU5JQUVnQTBGOWFpMEFBRG9BRGlBQklBTkJmbW90QUFBNkFBOGdBU0FEUVg5cUxRQUFPZ0FRSUFFZ0F5MEFBRG9BRVFzZ0IwVU5BQ0FDSUFSQmYyb2lBUzBBQURvQUFDQUNJQUFnQVdvaUFTMEFBRG9BQVNBQ0lBQWdBV29pQVMwQUFEb0FBaUFDSUFBZ0FXb2lBUzBBQURvQUF5QUNJQUFnQVdvaUFTMEFBRG9BQkNBQ0lBQWdBV29pQVMwQUFEb0FCU0FDSUFBZ0FXb2lBUzBBQURvQUJpQUNJQUFnQVdvaUFTMEFBRG9BQnlBQ0lBQWdBV29nQmlBRmEwRUdkR29pQVMwQUFEb0FDQ0FDSUFBZ0FXb2lBUzBBQURvQUNTQUNJQUFnQVdvaUFTMEFBRG9BQ2lBQ0lBQWdBV29pQVMwQUFEb0FDeUFDSUFBZ0FXb2lBUzBBQURvQURDQUNJQUFnQVdvaUFTMEFBRG9BRFNBQ0lBQWdBV29pQVMwQUFEb0FEaUFDSUFBZ0FXb3RBQUE2QUE4TEM2OEJBUUYvSXdCQjBBQnJJZ1lrQUNBQ0lBWkJJR29nQmlBREVGVUNRQUpBUVFJZ0FDZ0NBQ0lEUVFaSElBTkJCa2tiUVFGR0JFQWdBQ0FGSUFGQnlBSnFJQVpCSUdvZ0JpQUVFRlFpQTBVTkFRd0NDeUFBSUFVZ0FTQUdRU0JxSUFZZ0JCQlRJZ01OQVFzZ0FDQUZRWUFDYWlBQlFjZ0thaUFHUVRWcUlBWkJFR29nQVNnQ2pBRWdCQkJTSWdNTkFFRUFJUU1nQUNnQ3hBRkJBVXNOQUNBQ0lBVVFHd3NnQmtIUUFHb2tBQ0FEQzZNcUFTUi9Jd0JCSUdzaUVDUUFJQkFnQkNnQ0JDSUlOZ0lNSUJBZ0JDZ0NDRFlDRUNBRElBaHVJZ1pCQkhRaEZDQURJQVlnQ0d4clFRUjBJUlVDUUFKQUFrQUNRQUpBQWtBQ1FBSkFJQUFvQWdBaUJrRURUUVJBQWtBQ1FBSkFJQVpCQW1zT0FnRUNBQXNnQVNnQ2tBRWhFeUFBS0FJRUlRNUJmeUVQQW44Z0FDZ0N5QUVpQ1VVRVFFRUFJUWhCZnd3QkMwRUFJUWhCZnlBSktBSUVJQTVIRFFBYVFRRWhFa0YvSUFrb0FnQkJCVXNOQUJvZ0NTZ0NtQUVpQ0VFUWRpRUhJQWtvQW1nTElRMGdBQ2dDekFFaUNVVU5DQ0FKS0FJRUlBNUhEUWhCQVNFV0lBa29BZ0JCQlVzTkNDQUpLQUtzQVNJUlFSQjJJUW9nQ1NnQ2JDRVBEQWdMSUFFb0FwQUJJUk1nQVM4Qm9nRWhEU0FCTHdHZ0FTRU1JQUFvQWdRaEMwRi9JUWNDUUNBQUtBTE1BU0lHUlEwQUlBc2dCaWdDQkVjRVFBd0JDMEVCSVJJZ0JpZ0NBRUVGU3cwQUlBWW9BcXdCSWdsQkVIWWhDaUFHS0FKc0lRY0xJQWNnRTBZRVFDQUtJUWNnQ1NFR0RBY0xRWDhoRHdKQUFrQUNRQ0FBS0FMSUFTSUlSUVJBUVFBaEJ3d0JDMEVBSVFjZ0NDZ0NCQ0FMUmcwQkMwRUFJUVlNQVF0QkFTRVhJQWdvQWdCQkJVc0VRRUVBSVFZTUFRc2dDQ2dDbUFFaUJrRVFkaUVISUFnb0FtZ2hEd3NDUUFKQUlBQW9BdEFCSWdoRkRRQWdDQ2dDQkNBTFJ3MEFJQWdvQWdCQkJVME5BUXdHQ3dKQUlBQW9BdFFCSWdoRkRRQWdDQ2dDQkNBTFJ3MEFJQWdvQWdCQkJVc05CaUFJS0FKd0lSWWdDQ2dDd0FFaENBd0hDMEVBSVFoQmZ5RVdJQklOQmlBWFJRMEdEQWNMSUFnb0Ftd2hGaUFJS0FLc0FTRUlEQVVMSUFFb0FwQUJJUThnQVM4Qm9nRWhEU0FCTHdHZ0FTRU1JQUFvQWdRaEJrRi9JUWNDUUNBQUtBTElBU0lLUlFSQVFRQWhDQXdCQzBFQUlRZ2dCaUFLS0FJRVJ3UkFEQUVMUVFFaEVTQUtLQUlBUVFWTERRQWdDaWdDbUFFaUNVRVFkaUVJSUFvb0FtZ2hCd3NnQnlBUFJnMEJBbjhDZndKQUFrQWdBQ2dDekFFaUIwVU5BQ0FIS0FJRUlBWkhEUUFnQnlnQ0FFRUZTdzBCSUFjb0FuQWhFU0FIS0FLOEFTRUtJQWNvQW13aEVpQUhLQUtzQVNJR1FSQjJEQU1MQWtBZ0FDZ0MxQUVpQjBVTkFDQUhLQUlFSUFaSERRQkJBQ0VHUVg4aEVpQUhLQUlBUVFWTEJFQkJmeUVSUVFBTUF3c2dCeWdDY0NFUklBY29Bc0FCREFJTElCRU5CQXRCZnlFUlFYOGhFa0VBSVFaQkFBc2hDa0VBQ3lFSElBOGdFa1lpQ3lBUElCRkdha0VCUndSQUlBY2dDQ0FIUVJCMFFSQjFJZ3NnQ0VFUWRFRVFkU0lPU2lJSUd5SUhJQTRnQ3lBT0lBc2dEa2diSUFnYklnZ2dDa0VRZFNJTElBZ2dDMG9iSUFkQkVIUkJFSFVnQzBnYklRY2dCaUFKSUFaQkVIUkJFSFVpQ3lBSlFSQjBRUkIxSWdsS0lnWWJJZ2hCLy84RGNTQUpJQXNnQ1NBTElBbElHeUFHR3lJR0lBcEJFSFJCRUhVaUNTQUdJQWxLR3lBSVFSQjBRUkIxSUFsSUd5RUdEQU1MSUFzTkFpQUtRUkIySVFjZ0NpRUdEQUlMUVFFaEd5QUFRWVFCYWlFY0EwQUNmeUFCSUIxQkFuUWlIbW9pSUNJa0tBS3dBU0lHUVFKTkJFQWdCa0VDZEVHY05Xb29BZ0FNQVF0QkJBc2hJaUFBSUI1cUlnWWdJQ2dDd0FFMkFtUWdCaUFDSUNBb0FzQUJFQlFpQmpZQ2RDQUdSUTBJSUNJRVFDQWNJQjFCQkhRaUgyb2lKU0VtSUJ3Z0gwRU1jbW9pSjBFQ2FpRW9JQndnSDBFSWNtb2lLU0VSSUJ3Z0gwRUVjbW9pRmlFVFFRQWhCZ05BSUFFZ0gyb2dCa0VDZEdvaUNDOEIwZ0VoRHlBSUx3SFFBU0VPSUNBb0FzQUJJU0ZCZnlFWEFuOGdBQ0FkUVFkMElDUW9BckFCSWlOQkJYUnFJQVpCQTNScUlocEJzQmxxS0FJQUVCRWlDVVVFUUVFQUlReEJBQ0VJUVFBaENrRi9EQUVMUVFBaERFRUFJUWhCQUNFS1FYOGdDU2dDQkNBQUtBSUVSdzBBR2tFQklRcEJmeUFKS0FJQVFRVkxEUUFhSUFrZ0drRzBHV290QUFBaUIwRUNkR29vQW9RQklnaEJFSFloRENBSklBZEIvQUZ4YWlnQ1pBc2hEUUpBQWtBQ1FDQUFJQnBCc0IxcUtBSUFFQkVpR0VVRVFFRUFJUWtNQVF0QkFDRUpJQmdvQWdRZ0FDZ0NCRVlOQVF0QkFDRVNRUUFoQ3d3QkMwRUJJUXNnR0NnQ0FFRUZTd1JBUVFBaEVnd0JDeUFZSUJwQnRCMXFMUUFBSWdkQkFuUnFLQUtFQVNJU1FSQjJJUWtnR0NBSFFmd0JjV29vQW1RaEZ3c0NRQUpBQWtBQ1FBSkFJQUFnR2tHd0lXb29BZ0FRRVNJWlJRMEFJQmtvQWdRZ0FDZ0NCRWNOQUNBWktBSUFRUVZORFFFTUFnc0NRQ0FBSUJwQnNDVnFLQUlBRUJFaUdVVU5BQ0FaS0FJRUlBQW9BZ1JIRFFBZ0dTZ0NBRUVGU3cwQ0lCa2dHa0cwSldvdEFBQWlCMEg4QVhGcUtBSmtJUmdnR1NBSFFRSjBhaWdDaEFFaEJ3d0RDMEVBSVFkQmZ5RVlJQXBGRFFJZ0N3MENEQU1MSUJrZ0drRzBJV290QUFBaUIwSDhBWEZxS0FKa0lSZ2dHU0FIUVFKMGFpZ0NoQUVoQnd3QkMwRUFJUWRCZnlFWUN5QVhJQ0ZHSWdvZ0RTQWhSaUlMYWlBWUlDRkdha0VCUndSQUlBa2dEQ0FKUVJCMFFSQjFJZ3NnREVFUWRFRVFkU0lNU2lJSkd5SUtJQXdnQ3lBTUlBc2dERWdiSUFrYklna2dCMEVRZFNJTElBa2dDMG9iSUFwQkVIUkJFSFVnQzBnYklRd2dFaUFJSUJKQkVIUkJFSFVpQ2lBSVFSQjBRUkIxSWd0S0lnZ2JJZ2xCLy84RGNTQUxJQW9nQ3lBS0lBdElHeUFJR3lJSUlBZEJFSFJCRUhVaUJ5QUlJQWRLR3lBSlFSQjBRUkIxSUFkSUd5RUlEQUVMSUFnZ0VpQUxHeUVJSUF3Z0NTQUxHeUVNSUFzTkFDQUtEUUFnQjBFUWRpRU1JQWNoQ0FzZ0NDQU9haUlLUVJCMFFSQjFRWUJBYTBILy93QkxEUW9nRENBUGFpSUpRUkIwUVJCMVFZQVFha0gvSDBzTkNpQWpRUU5OQkVBQ2Z3SkFBa0FDUUFKQUlDTkJBV3NPQXdFQ0F3QUxJQ1VnQ2pzQkFDQW1JQWs3QVFJZ0ZpQUtPd0VBSUJNZ0NUc0JBaUFwSUFvN0FRQWdFU0FKT3dFQ0lDY2dDanNCQUNBb0RBTUxJQndnQmtFQmRDQWVha0VDZENJSGFpSUlJQWs3QVFJZ0NDQUtPd0VBSUJ3Z0IwRUVjbW9pQ0NBS093RUFJQWhCQW1vTUFnc2dBQ0FHSUI1cVFRSjBhaUlJSUFvN0FZd0JJQWdnQ1RzQmhnRWdDQ0FLT3dHRUFTQUlRWTRCYWd3QkN5QUFJQVlnSG1wQkFuUnFJZ2dnQ2pzQmhBRWdDRUdHQVdvTElBazdBUUFMSUFaQkFXb2lCaUFpUncwQUN3c2dIVUVCYWlJZFFRUkhEUUFMUVFBaERBTkFJQkFnQUNBTVFRSjBJZ0pxS0FKME5nSUlJQXhCQVV0QkEzUWhDU0FNUVFOMFFRaHhJUWNDUUNBQklBSnFLQUt3QVNJQ1FRSk5CRUFDUUFKQUFrQWdBa0VCYXc0Q0FRSUFDeUFGSUFBZ0RFRUVkR3BCaEFGcUlCQkJDR29nRlNBVUlBY2dDVUVJUVFnUURnd0RDeUFGSUFBZ0RFRUVkR29pQWtHRUFXb2dFRUVJYWlBVklCUWdCeUFKUVFoQkJCQU9JQVVnQWtHTUFXb2dFRUVJYWlBVklCUWdCeUFKUVFSeVFRaEJCQkFPREFJTElBVWdBQ0FNUVFSMGFpSUNRWVFCYWlBUVFRaHFJQlVnRkNBSElBbEJCRUVJRUE0Z0JTQUNRWWdCYWlBUVFRaHFJQlVnRkNBSFFRUnlJQWxCQkVFSUVBNE1BUXNnQlNBQUlBeEJCSFJxSWdoQmhBRnFJQkJCQ0dvZ0ZTQVVJQWNnQ1VFRVFRUVFEaUFGSUFoQmlBRnFJQkJCQ0dvZ0ZTQVVJQWRCQkhJaUJpQUpRUVJCQkJBT0lBVWdDRUdNQVdvZ0VFRUlhaUFWSUJRZ0J5QUpRUVJ5SWdKQkJFRUVFQTRnQlNBSVFaQUJhaUFRUVFocUlCVWdGQ0FHSUFKQkJFRUVFQTRMSUF4QkFXb2lERUVFUncwQUN3d0dDeUFJSVFjZ0NTRUdDMEVCSVJzZ0JpQU1haUlJUVJCMFFSQjFRWUJBYTBILy93QkxEUVVnQnlBTmFpSUdRUkIwUVJCMVFZQVFha0gvSDBzTkJTQUNJQThRRkNJSFJRMEZJQUFnQmpzQnNnRWdBQ0FJT3dHd0FTQUFJQWMyQW5RZ0FDQVBOZ0prSUFBZ0J6WUNmQ0FBSUE4MkFtd2dBQ0FBS0FLd0FTSUdOZ0tzQVNBQUlBWTJBcWdCSUFBZ0JqWUNwQUVnQUNBR05nS1FBU0FBSUFZMkFvd0JJQUFnQmpZQ2lBRWdBQ0FHTmdLRUFTQUJLQUtVQVNFT0lBRXZBYVlCSVF3Z0FTOEJwQUVoQ3lBQUtBSUVJUWtDUUFKQUlBQW9BdEFCSWdkRkRRQWdCeWdDQkNBSlJ3MEFRUUVoRVNBSEtBSUFRUVZMQkVCQmZ5RUlRUUFoQnd3Q0N5QUhLQUpzSVFnZ0J5Z0NyQUVoQnd3QkMwRi9JUWhCQUNFSElBQW9Bc3dCSWdwRkJFQkJBQ0VSREFFTElBa2dDaWdDQkVjRVFFRUFJUkVNQVF0QkFTRVJJQW9vQWdCQkJVc05BQ0FLS0FKc0lRZ2dDaWdDc0FFaEJ3c0NRQ0FJSUE1R1JRUkFJQVpCRUhZaENBSi9Ba0FDUUNBQUtBTE1BU0lOUlEwQUlBMG9BZ1FnQ1VjTkFDQU5LQUlBUVFWTERRRWdEU2dDdkFFaUVVRVFkaUVLSUEwb0FuQU1BZ3NnRVVVTkF3dEJBQ0VSUVFBaENrRi9DeUVOSUE0Z0QwWWlDU0FOSUE1R2FrRUJSd1JBSUFvZ0NDQUtRUkIwUVJCMUlnMGdDRUVRZEVFUWRVb2lDQnNpQ1NBR1FSQjFJZ29nRFNBS0lBb2dEVW9iSUFnYklnZ2dCMEVRZFNJS0lBZ2dDa29iSUFsQkVIUkJFSFVnQ2tnYklRZ2dFU0FHSUJGQkVIUkJFSFVpQ2lBR1FSQjBRUkIxSWcxS0lnWWJJZ2xCLy84RGNTQU5JQW9nRFNBTklBcEtHeUFHR3lJR0lBZEJFSFJCRUhVaUJ5QUdJQWRLR3lBSlFSQjBRUkIxSUFkSUd5RUdEQUlMSUFrTkFTQU5JQTVHQkVBZ0VVSC8vd054SUFwQkVIUnlJUVlnQ2lFSURBSUxDeUFIUVJCMklRZ2dCeUVHQ3lBR0lBdHFJZ2RCRUhSQkVIVkJnRUJyUWYvL0FFc05CU0FJSUF4cUlnWkJFSFJCRUhWQmdCQnFRZjhmU3cwRklBSWdEaEFVSWdKRkRRVWdBQ0FHT3dIQ0FTQUFJQWM3QWNBQklBQWdBallDZ0FFZ0FDQUNOZ0o0SUFBZ0RqWUNjQ0FBSUE0MkFtZ2dBQ0FBS0FMQUFTSUdOZ0s4QVNBQUlBWTJBcmdCSUFBZ0JqWUN0QUVnQUNBR05nS2dBU0FBSUFZMkFwd0JJQUFnQmpZQ21BRWdBRUdVQVdvaUFpQUdOZ0lBSUJBZ0FDZ0NkRFlDQ0NBRklBQkJoQUZxSUJCQkNHb2dGU0FVUVFCQkFFRUlRUkFRRGlBUUlBQW9BbmcyQWdnZ0JTQUNJQkJCQ0dvZ0ZTQVVRUWhCQUVFSVFSQVFEZ3dFQzBFQUlRaEJmeUVXQ3lBUElCTkdJZ3NnRXlBV1JtcEJBVWNFUUNBS0lBY2dDa0VRZEVFUWRTSUxJQWRCRUhSQkVIVWlEa29pQnhzaUNpQU9JQXNnRGlBTElBNUlHeUFIR3lJSElBaEJFSFVpQ3lBSElBdEtHeUFLUVJCMFFSQjFJQXRJR3lFSElBa2dCaUFKUVJCMFFSQjFJZ29nQmtFUWRFRVFkU0lMU2lJR0d5SUpRZi8vQTNFZ0N5QUtJQXNnQ2lBTFNCc2dCaHNpQmlBSVFSQjBRUkIxSWdnZ0JpQUlTaHNnQ1VFUWRFRVFkU0FJU0JzaEJnd0JDeUFMRFFBZ0NFRVFkaUVISUFnaEJndEJBU0ViSUFZZ0RHb2lDRUVRZEVFUWRVR0FRR3RCLy84QVN3MENJQWNnRFdvaUJrRVFkRUVRZFVHQUVHcEIveDlMRFFJZ0FpQVRFQlFpQjBVTkFpQUFJQVk3QWFJQklBQWdDRHNCb0FFZ0FDQUhOZ0owSUFBZ0V6WUNaQ0FBSUFjMkFuZ2dBQ0FUTmdKb0lBQWdBQ2dDb0FFaUR6WUNuQUVnQUNBUE5nS1lBU0FBSUE4MkFwUUJJQUFnRHpZQ2tBRWdBQ0FQTmdLTUFTQUFJQTgyQW9nQklBQWdEellDaEFFZ0FTZ0NsQUVoRGlBQkx3R21BU0VOSUFFdkFhUUJJUXdDZndKQUFrQUNRQ0FBS0FMSUFTSUdCRUFnQmlnQ0JDQUFLQUlFUmdSQUlBWW9BZ0JCQlUwRVFDQUdLQUs0QVNJTFFSQjJJUWNnQmlnQ2NDQU9SdzBFSUFzaENRd0RDMEYvSVJKQkFDRUpRUUFoQjBFQUlRdEJBQ0VLSUE1QmYwWU5BZ3dFQzBGL0lSSkJBQ0VKUVFBaEIwRUFJUXRCQUNFS0lBNUJmMFlOQVF3REMwRi9JUkpCQUNFSlFRQWhCMEVBSVF0QkFDRUtJQTVCZjBjTkFnc2dDVUgvL3dOeElBZEJFSFJ5REFJTElBWW9BbWdoRWlBR0tBS2dBU0VLSUFjaENRc2dEMEVRZGlFSUlBNGdFMFlpQmlBT0lCSkdha0VCUndSQUlBZ2dDU0FKUVJCMFFSQjFJZ2tnQ0VFUWRFRVFkVWdpQnhzaUNDQUpJQTlCRUhVaUJpQUpJQVlnQ1VnYklBY2JJZ1lnQ2tFUWRTSUhJQVlnQjBvYklBaEJFSFJCRUhVZ0IwZ2JJUWNnRHlBTElBdEJFSFJCRUhVaUN5QVBRUkIwUVJCMUlnbElJZ1liSWdoQi8vOERjU0FMSUFrZ0N5QUpJQXRJR3lBR0d5SUdJQXBCRUhSQkVIVWlDU0FHSUFsS0d5QUlRUkIwUVJCMUlBbElHd3dCQ3lBSUlBcEJFSFlnQmhzaEJ5QVBJQW9nQmhzTElBeHFJZ2hCRUhSQkVIVkJnRUJyUWYvL0FFc05BaUFISUExcUlnWkJFSFJCRUhWQmdCQnFRZjhmU3cwQ0lBSWdEaEFVSWdKRkRRSWdBQ0FHT3dIQ0FTQUFJQWc3QWNBQklBQWdBallDZ0FFZ0FDQUNOZ0o4SUFBZ0RqWUNjQ0FBSUE0MkFtd2dBQ0FBS0FMQUFTSUdOZ0s4QVNBQUlBWTJBcmdCSUFBZ0JqWUN0QUVnQUNBR05nS3dBU0FBSUFZMkFxd0JJQUFnQmpZQ3FBRWdBRUdrQVdvaUFpQUdOZ0lBSUJBZ0FDZ0NkRFlDQ0NBRklBQkJoQUZxSUJCQkNHb2dGU0FVUVFCQkFFRVFRUWdRRGlBUUlBQW9BbncyQWdnZ0JTQUNJQkJCQ0dvZ0ZTQVVRUUJCQ0VFUVFRZ1FEZ3dCQ3dKQUlBWkZCRUFnRWtVRVFFRUFJUWtNQWdzZ0ZrVUVRRUVBSVFrTUFnc2dDRUgvL3dOeElBZEJFSFJ5SUExeVJRUkFRUUFoQ1F3Q0MwRUFJUWtnRVVILy93TnhJQXBCRUhSeUlBOXlSUTBCQ3lBQkx3R2lBU0VMSUFFdkFhQUJJUWtDUUFKQUFrQUNRQUpBSUFBb0F0QUJJZ1pGRFFBZ0JpZ0NCQ0FPUncwQUlBWW9BZ0JCQlUwTkFRd0NDd0pBSUFBb0F0UUJJZ1pGRFFBZ0JpZ0NCQ0FPUncwQUlBWW9BZ0JCQlVzTkFpQUdLQUp3SVJjZ0JpZ0N3QUVoREF3REMwRi9JUmNnRWtVTkFpQVdEUUlNQXdzZ0JpZ0NiQ0VYSUFZb0Fxd0JJUXdNQVF0QmZ5RVhDeUFQSUJOR0lnWWdEU0FUUmlJTmFpQVRJQmRHYWtFQlJ3UkFJQW9nQnlBS1FSQjBRUkIxSWdvZ0IwRVFkRUVRZFNJTlNpSUdHeUlISUEwZ0NpQU5JQW9nRFVnYklBWWJJZ1lnREVFUWRTSUtJQVlnQ2tvYklBZEJFSFJCRUhVZ0NrZ2JJUWNnRVNBSUlCRkJFSFJCRUhVaUNpQUlRUkIwUVJCMUlnMUtJZ1liSWdoQi8vOERjU0FOSUFvZ0RTQUtJQTFJR3lBR0d5SUdJQXhCRUhSQkVIVWlDaUFHSUFwS0d5QUlRUkIwUVJCMUlBcElHeUVJREFFTElBZ2dFU0FOR3lFSUlBY2dDaUFOR3lFSElBME5BQ0FHRFFBZ0RFRVFkaUVISUF3aENBdEJBU0ViSUFnZ0NXb2lERUVRZEVFUWRVR0FRR3RCLy84QVN3MENJQWNnQzJvaUNVRVFkRUVRZFVHQUVHcEIveDlMRFFJTElBSWdFeEFVSWdKRkJFQkJBU0ViREFJTElBQWdDVHNCd2dFZ0FDQU1Pd0hBQVNBQUlBSTJBblFnQUNBVE5nSmtJQUFnQWpZQ2dBRWdBQ0FDTmdKOElBQWdBallDZUNBQUlCTTJBbkFnQUNBVE5nSnNJQUFnRXpZQ2FDQUFJQUFvQXNBQklnWTJBcndCSUFBZ0JqWUN1QUVnQUNBR05nSzBBU0FBSUFZMkFyQUJJQUFnQmpZQ3JBRWdBQ0FHTmdLb0FTQUFJQVkyQXFRQklBQWdCallDb0FFZ0FDQUdOZ0tjQVNBQUlBWTJBcGdCSUFBZ0JqWUNsQUVnQUNBR05nS1FBU0FBSUFZMkFvd0JJQUFnQmpZQ2lBRWdBQ0FHTmdLRUFTQVFJQUkyQWdnZ0JTQUFRWVFCYWlBUVFRaHFJQlVnRkVFQVFRQkJFRUVRRUE0TFFRQWhHeUFBS0FMRUFVRUJTdzBBSUFBb0FnQUVRQ0FFSUFNZ0JTQUJRY2dDYWhCWURBRUxJQVFnQlJBYkN5QVFRU0JxSkFBZ0d3dVRDd0VQZnlBQUtBSUFJaEVnQVNBQklBQW9BZ1FpQ25BaUFXc2lCRUVJZEdvZ0FVRUVkR29oQlNBS1FRUjBJUXNnQUNnQ0NDQUtiQ0lBUVFaMElRWWdBVUVEZENFSklBQkJDSFFoRENBRVFRWjBJUklnQ2tFQ2RFSDgvLy8vQTNGQkFuUWhFQU5BSUFVZ0RrRUNkQ0lBUWZBcGFpZ0NBQ0lCSUF0c2FpQUFRYkFwYWlnQ0FDSUFhaUVFSUFJZ0FVRUVkR29nQUdvaEFBSkFJQU1nRGtFR2RHb2lBU2dDQUNJSFFmLy8vd2RIQkVBZ0FTZ0NCQ0VJSUFBdEFBRWhEU0FFSUFjZ0FDMEFBR3BCc0M1cUxRQUFPZ0FBSUFFb0FnZ2hCeUFBTFFBQ0lROGdCQ0FJSUExcVFiQXVhaTBBQURvQUFTQUJLQUlNSVFnZ0FDMEFBeUVOSUFRZ0J5QVBha0d3TG1vdEFBQTZBQUlnQkNBSUlBMXFRYkF1YWkwQUFEb0FBeUFCS0FJVUlRY2dBQzBBRVNFSUlBUWdDMm9pQkNBQktBSVFJQUF0QUJCcVFiQXVhaTBBQURvQUFDQUJLQUlZSVEwZ0FDMEFFaUVQSUFRZ0J5QUlha0d3TG1vdEFBQTZBQUVnQVNnQ0hDRUhJQUF0QUJNaENDQUVJQTBnRDJwQnNDNXFMUUFBT2dBQ0lBUWdCeUFJYWtHd0xtb3RBQUE2QUFNZ0FTZ0NKQ0VISUFBdEFDRWhDQ0FFSUF0cUlnUWdBU2dDSUNBQUxRQWdha0d3TG1vdEFBQTZBQUFnQVNnQ0tDRU5JQUF0QUNJaER5QUVJQWNnQ0dwQnNDNXFMUUFBT2dBQklBRW9BaXdoQnlBQUxRQWpJUWdnQkNBTklBOXFRYkF1YWkwQUFEb0FBaUFFSUFjZ0NHcEJzQzVxTFFBQU9nQURJQUVvQWpRaEJ5QUFMUUF4SVFnZ0JDQUxhaUlFSUFFb0FqQWdBQzBBTUdwQnNDNXFMUUFBT2dBQUlBRW9BamdoRFNBQUxRQXlJUThnQkNBSElBaHFRYkF1YWkwQUFEb0FBU0FCS0FJOElRRWdBQzBBTXlFQUlBUWdEU0FQYWtHd0xtb3RBQUE2QUFJZ0JDQUFJQUZxUWJBdWFpMEFBRG9BQXd3QkN5QUFLQUlRSVFFZ0JDQUFLQUlBTmdJQUlBUWdFR29pQkNBQk5nSUFJQUFvQWpBaEFTQUVJQkJxSWdRZ0FDZ0NJRFlDQUNBRUlCQnFJQUUyQWdBTElBNUJBV29pRGtFUVJ3MEFDeUFNSUJGcUlCSnFJQWxxSWhBZ0Jtb2hFU0FLUVFOMFFmai8vLzhIY1NJTFFRSjJRUUowSVE1QkVDRUtBMEFnQ2tFQ2RFRU1jU0lBUWZBcGFpZ0NBQ0lCSUF0c0lBQkJzQ2xxS0FJQUlnQnFJQkVnRUNBS1FSTkxJZ1ViYWlFRUlBSkJ3QUpCZ0FJZ0JSdHFJQUZCQTNRZ0FHcHFJUUFDUUNBRElBcEJCblJxSWdFb0FnQWlCVUgvLy84SFJ3UkFJQUVvQWdRaEJpQUFMUUFCSVFrZ0JDQUZJQUF0QUFCcVFiQXVhaTBBQURvQUFDQUJLQUlJSVFVZ0FDMEFBaUVNSUFRZ0JpQUpha0d3TG1vdEFBQTZBQUVnQVNnQ0RDRUdJQUF0QUFNaENTQUVJQVVnREdwQnNDNXFMUUFBT2dBQ0lBUWdCaUFKYWtHd0xtb3RBQUE2QUFNZ0FTZ0NGQ0VGSUFBdEFBa2hCaUFFSUF0cUlnUWdBU2dDRUNBQUxRQUlha0d3TG1vdEFBQTZBQUFnQVNnQ0dDRUpJQUF0QUFvaERDQUVJQVVnQm1wQnNDNXFMUUFBT2dBQklBRW9BaHdoQlNBQUxRQUxJUVlnQkNBSklBeHFRYkF1YWkwQUFEb0FBaUFFSUFVZ0JtcEJzQzVxTFFBQU9nQURJQUVvQWlRaEJTQUFMUUFSSVFZZ0JDQUxhaUlFSUFFb0FpQWdBQzBBRUdwQnNDNXFMUUFBT2dBQUlBRW9BaWdoQ1NBQUxRQVNJUXdnQkNBRklBWnFRYkF1YWkwQUFEb0FBU0FCS0FJc0lRVWdBQzBBRXlFR0lBUWdDU0FNYWtHd0xtb3RBQUE2QUFJZ0JDQUZJQVpxUWJBdWFpMEFBRG9BQXlBQktBSTBJUVVnQUMwQUdTRUdJQVFnQzJvaUJDQUJLQUl3SUFBdEFCaHFRYkF1YWkwQUFEb0FBQ0FCS0FJNElRa2dBQzBBR2lFTUlBUWdCU0FHYWtHd0xtb3RBQUE2QUFFZ0FTZ0NQQ0VCSUFBdEFCc2hBQ0FFSUFrZ0RHcEJzQzVxTFFBQU9nQUNJQVFnQUNBQmFrR3dMbW90QUFBNkFBTU1BUXNnQUNnQ0NDRUJJQVFnQUNnQ0FEWUNBQ0FFSUE1cUlnUWdBVFlDQUNBQUtBSVlJUUVnQkNBT2FpSUVJQUFvQWhBMkFnQWdCQ0FPYWlBQk5nSUFDeUFLUVFGcUlncEJHRWNOQUFzTDVnRUJCMzhDUUNBQUtBSUFJZ1ZGRFFBZ0FFRUJOZ0k4SUFBb0FqZ05BQ0FBS0FJY0lRWkIvLy8vL3djaEFnTkFBMEFnQlNBRFFTaHNhaUlFS0FJWUJFQWdCQ0FCSUFRb0FoQWlCQ0FDU0NJSEd5RUJJQVFnQWlBSEd5RUNDeUFEUVFGcUlnTWdCazBOQUNBQlJRMENJQUFvQWd3Z0FDZ0NFQ0lEUVFSMGFpSUNJQUVvQWdBMkFnQWdBaUFCS0FJa05nSU1JQUlnQVNnQ0hEWUNCQ0FDSUFFb0FpQTJBZ2dnQUNBRFFRRnFOZ0lRUVFBaEF5QUJRUUEyQWhnZ0FTZ0NGQ0VFUVFBaEFVSC8vLy8vQnlFQ0lBUU5BQXNnQUNBQUtBSXNRWDlxTmdJc0RBQUFDd0FMQzl3R0FRcC9JQUJDQURjQ0VBSkFBa0FDUUNBRFJRMEFBa0FDUUNBQklBQW9BakFpQTBjRVFDQURRUUZxSUFBb0FpQWlCSEFpQ1NBQlJnMEJJQUFvQWdBZ0FDZ0NIRUVvYkdvb0FnQWhDd05BQWtBQ1FDQUFLQUlvSWdjRVFDQUFLQUlBSVFoQkFDRURBMEFnQ0NBRFFTaHNhaUlGS0FJVVFYOXFRUUZOQkVBZ0JTQUZLQUlNSWdVZ0JFRUFJQVVnQ1VzYmF6WUNDQXNnQTBFQmFpSURJQWRIRFFBTElBY2dBQ2dDR0VrTkFrRi9JUVZCQUNFRFFRQWhCQU5BSUFnZ0EwRW9iR29pQmlnQ0ZFRi9ha0VCVFFSQUlBWW9BZ2dpQmlBRUlBVkJmMFlnQmlBRVNISWlCaHNoQkNBRElBVWdCaHNoQlFzZ0EwRUJhaUlESUFkSERRQUxJQVZCQUU0TkFVRUJEd3RCQUNFSElBQW9BaGdOQVVFQkR3c2dDQ0FGUVNoc2FpSURRUUEyQWhRZ0FDQUhRWDlxSWdjMkFpZ2dBeWdDR0EwQUlBQWdBQ2dDTEVGL2FqWUNMQXNnQUNnQ0xDSUZJQUFvQWh3aUNFOEVRQ0FBS0FJNERRWWdBQ2dDQUNFTUEwQkJBQ0VFUWYvLy8vOEhJUVpCQUNFREEwQWdEQ0FEUVNoc2FpSUtLQUlZQkVBZ0NpQUVJQW9vQWhBaUNpQUdTQ0lOR3lFRUlBb2dCaUFOR3lFR0N5QURRUUZxSWdNZ0NFME5BQXNDUUNBRVJRMEFJQUFvQWd3Z0FDZ0NFQ0lHUVFSMGFpSURJQVFvQWdBMkFnQWdBeUFFS0FJa05nSU1JQU1nQkNnQ0hEWUNCQ0FESUFRb0FpQTJBZ2dnQUNBR1FRRnFOZ0lRSUFSQkFEWUNHQ0FFS0FJVURRQWdBQ0FGUVg5cUlnVTJBaXdMSUFVZ0NFOE5BQXNMSUFBb0FnQWlCQ0FJUVNoc2FpSURJQWsyQWd3Z0EwS0FnSUNBRURjQ0VDQURRUUEyQWhnZ0F5QUpOZ0lJSUFBZ0IwRUJhallDS0NBQUlBVkJBV28yQWl3Z0JDQUlRUUZxRUNjZ0NVRUJhaUFBS0FJZ0lnUndJZ2tnQVVjTkFBc0NRQ0FBS0FJUUlnbEZEUUFnQUNnQ0FDSUZJQUFvQWh3aUJFRW9iR29pQ0NnQ0FDRUhJQUFvQWd3aEJrRUFJUU1EUUNBSElBWWdBMEVFZEdvb0FnQkhCRUFnQ1NBRFFRRnFJZ05IRFFFTUFnc0xJQVJGRFFCQkFDRURBMEFnQ3lBRklBTkJLR3hxSWdrb0FnQkhCRUFnQkNBRFFRRnFJZ05IRFFFTUFnc0xJQWtnQnpZQ0FDQUlJQXMyQWdBTElBSU5CU0FBS0FJd0lRTU1BZ3NnQWtFQVJ3OExJQUlOQXdzZ0FTQURSZzBBSUFBZ0FTQUFLQUlnSWdCcVFYOXFJQUJ3TmdJd0MwRUFEd3NEUUF3QUFBc0FDeUFBSUFFMkFqQkJBQXQxQVFOL0FrQWdBQ2dDQUNJQlJRMEFJQUFvQWh4QmYwWU5BQU5BSUFFZ0FrRW9iQ0lEYWlnQ0JCQUVJQUFvQWdBaUFTQURha0VBTmdJRUlBSkJBV29pQWlBQUtBSWNRUUZxU1EwQUN3c2dBUkFFSUFCQkFEWUNBQ0FBS0FJRUVBUWdBRUVBTmdJRUlBQW9BZ3dRQkNBQVFRQTJBZ3dMZ3dFQkEzOENRQ0FBS0FJQUlnWkZEUUFnQUNnQ0hFRi9SZzBBQTBBZ0JpQUhRU2hzSWdocUtBSUVFQVFnQUNnQ0FDSUdJQWhxUVFBMkFnUWdCMEVCYWlJSElBQW9BaHhCQVdwSkRRQUxDeUFHRUFRZ0FFRUFOZ0lBSUFBb0FnUVFCQ0FBUVFBMkFnUWdBQ2dDREJBRUlBQkJBRFlDRENBQUlBRWdBaUFESUFRZ0JSQmRDNEFDQVFKL0lBQWdCVFlDT0NBQUlBUTJBaUFnQUVMLy93TTNBaVFnQUVJQU53SXNJQUFnQTBFQklBTkJBVXNiSWdNMkFoZ2dBQ0FESUFJZ0JSc2lBallDSENBQVFhZ0ZFQW9pQXpZQ0FFSC8vd01oQkFKQUlBTkZEUUJCQUNFRklBTkJBRUdvQlJBSElRWWdBa0YvUndSQUlBRkJnQU5zUVM5eUlRVkJBQ0VEQTBBZ0JpQURRU2hzYWlJSElBVVFDaUlCTmdJRUlBRkZEUUlnQnlBQlFRQWdBV3RCRDNGcU5nSUFJQU1nQWtraEFTQURRUUZxSVFNZ0FRMEFDeUFDUVFSMFFSQnFJUVVMSUFCQnhBQVFDaUlCTmdJRUlBQWdCUkFLSWdJMkFnd2dBa1VOQUNBQlJRMEFRUUFoQkNBQlFRQkJ4QUFRQnhvZ0FFSUFOd0lRQ3lBRUM5TUJBUWQvUVFFaEFRSkFJQUFvQWpnTkFDQUFLQUljSVFVZ0FDZ0NBQ0VHUWYvLy8vOEhJUU5CQUNFQkEwQWdCaUFCUVNoc2FpSUVLQUlZQkVBZ0JDQUNJQVFvQWhBaUJDQURTQ0lIR3lFQ0lBUWdBeUFIR3lFREN5QUJRUUZxSWdFZ0JVME5BQXNnQWtVRVFFRUJEd3NnQUNnQ0RDQUFLQUlRSWdOQkJIUnFJZ0VnQWlnQ0FEWUNBQ0FCSUFJb0FpUTJBZ3dnQVNBQ0tBSWNOZ0lFSUFFZ0FpZ0NJRFlDQ0NBQUlBTkJBV28yQWhCQkFDRUJJQUpCQURZQ0dDQUNLQUlVRFFBZ0FDQUFLQUlzUVg5cU5nSXNDeUFCQy9VRUFRaC9JQUFvQWlnaUJBUkFJQUFvQWdBaEJ3TkFJQWNnQlVFb2JHb2lCaWdDRkVGL2FrRUJUUVJBSUFZZ0JpZ0NEQ0lJSUFKTEJIOGdDQ0FBS0FJZ2F3VWdDQXMyQWdnTElBVkJBV29pQlNBRVJ3MEFDd3RCQUNFRUFrQWdBU2dDQUVVTkFDQUJLQUlFSWdWQkFrc05BRUVBSVFjZ0FpRUdBMEFDUUFKQUFrQWdCVUVDUndSQUlBRWdCMEVNYkdvb0FnZ2hCQUpBSUFWRkJFQWdCaUFFYXlJR1FYOUtEUUVnQUNnQ0lDQUdhaUVHREFFTElBUWdCbW9pQmtFQUlBQW9BaUFpQlNBR0lBVklHMnNoQmdzZ0JpRUpJQVlnQWtzRVFDQUdJQUFvQWlCcklRa0xJQUFvQWhnaUNrVUVRRUVCRHdzZ0FDZ0NBQ0VJUVFBaEJRTkFJQWdnQlVFb2JHb2lCQ2dDRkNJTFFYOXFRUUZOQkVBZ0JDZ0NDQ0FKUmcwREMwRUJJUVFnQlVFQmFpSUZJQXBIRFFBTERBVUxRUUVoQkNBQUtBSVlJZ2xGRFFRZ0FTQUhRUXhzYWlnQ0RDRUtJQUFvQWdBaENFRUFJUVVEUUNBSUlBVkJLR3hxSWdRb0FoUkJBMFlFUUNBRUtBSUlJQXBHRFFNTFFRRWhCQ0FGUVFGcUlnVWdDVWNOQUFzTUJBc2dCVUVBU0FSQVFRRVBDMEVCSVFRZ0MwRUJTdzBCREFNTFFRRWhCQ0FGUVFCSURRSUxJQWNnQXlJRVNRUkFBMEFnQUNnQ0JDSUpJQVJCQW5ScUlBa2dCRUYvYWlJRVFRSjBhaWdDQURZQ0FDQUVJQWRMRFFBTElBQW9BZ0FoQ0FzZ0FDZ0NCQ0FIUVFKMGFpQUlJQVZCS0d3aUNXbzJBZ0FnQjBFQmFpSUhJUVFnQnlJRklBTk5CRUFEUUNBQUtBSUVJZ2dnQlVFQ2RHb29BZ0FpQ2lBQUtBSUFJQWxxUndSQUlBZ2dCRUVDZEdvZ0NqWUNBQ0FFUVFGcUlRUUxJQVZCQVdvaUJTQURUUTBBQ3d0QkFDRUVJQUVnQjBFTWJHb29BZ1FpQlVFRFNRMEFDd3NnQkFzR0FDQUFFQVFMQndCQnhCb1FDZ3U0QWdFRGZ3TkFJQUFnQWtFQ2RHb2lBVUVVYWlnQ0FDSURCRUFnQXlnQ0tCQUVJQUVvQWhSQkFEWUNLQ0FCS0FJVUtBSlVFQVFnQVNnQ0ZFRUFOZ0pVSUFFb0FoUVFCQ0FCUVFBMkFoUUxJQUpCQVdvaUFrRWdSdzBBQzBFQUlRSURRQ0FBSUFKQkFuUnFJZ0ZCbEFGcUtBSUFJZ01FUUNBREtBSVVFQVFnQVNnQ2xBRkJBRFlDRkNBQktBS1VBU2dDR0JBRUlBRW9BcFFCUVFBMkFoZ2dBU2dDbEFFb0Fod1FCQ0FCS0FLVUFVRUFOZ0ljSUFFb0FwUUJLQUlzRUFRZ0FTZ0NsQUZCQURZQ0xDQUJLQUtVQVJBRUlBRkJBRFlDbEFFTElBSkJBV29pQWtHQUFrY05BQXNnQUNnQ3NCb1FCQ0FBUVFBMkFyQWFJQUFvQXJ3SkVBUWdBRUVBTmdLOENTQUFLQUtVQ1JBRUlBQkJBRFlDbEFrZ0FDZ0N2Qm9pQVFSQUlBRVFCQ0FBUVFBMkFyd2FDeUFBUWNRSmFoQmJDN2NCQVFKL0l3QkJFR3NpQmlRQUlBWkJBRFlDRENBQUlBRWdBaUFHUVF4cUVDb2lCMEY5Y1VVRVFBTkFJQUFnQVNBR0tBSU1JZ2RxSWdFZ0FpQUhheUlDSUFaQkRHb1FLaUlIUVgxeFJRMEFDd3NnQjBFQlJnUkFJQVFnQUNnQ0VDSUJLQUkwUVFSME5nSUFJQVVnQVNnQ09FRUVkRFlDQUNBRElBQkJ4QWxxSWdBb0FoUWlBU0FBS0FJUVNRUi9JQUFnQVVFQmFqWUNGQ0FBS0FJTUlBRkJCSFJxQlVFQUN5Z0NBRFlDQUFzZ0JrRVFhaVFBSUFjTFNRRUJmeUFBUVFCQnhCb1FCeUlDUWJRS2FrRUJOZ0lBSUFKQ2dJS0FnSUFFTndJRUlBQkJ3QkFRQ2lJQ05nS3dHaUFDUlFSQVFRRVBDeUFCQkVBZ0FFRUJOZ0xBQ1F0QkFBdTZCQUVKZndKQUFrQWdBVUVFU1EwQUlBQXRBQUFOQUNBQUxRQUJEUUFnQUMwQUFpSUhRUUZMRFFCQkF5RUVJQUJCQTJvaEJVRUNJUWhCZlNFTUFrQURRQ0FGSVFZQ2Z5QUlRUUZxSUFkQi93RnhJZ1ZGRFFBYVFRQWhCeUFGUVFGR1FRQWdDRUVCU3hzTkFrRUFDeUVJSUFSQmYzTWhEQ0FHUVFGcUlRVWdCaTBBQUNFSElBUkJBV29pQkNBQlJ3MEFDeUFESUFFMkFnQkJBUThMSUFRaENrRUFJUWhCQUNFRkEwQkJBU0FJSUFjZ0JpMEFBQ0lMUldvaUNVRUNSaHNnQ0NBTFFRTkdHeUVJSUFwQkFXb2hDZ0pBSUF0QkFVY05BQ0FKUVFKSkRRQWdBaUFLSUF4cUlBbEJmM05xSWdFMkFneEJBQ0FKUVgxcUlnWWdCaUFKU3hzaEJ3d0RDMEVBSUFrZ0N4c2hCMEVCSUFVZ0NVRUNTeHNnQlNBTEd5RUZJQVpCQVdvaEJpQUJJQXBIRFFBTElBSWdBU0FNYWlBSGF5SUJOZ0lNREFFTElBSWdBVFlDREVFQklRaEJBQ0VIQ3lBQ1FRQTJBaEFnQWtFQU5nSUlJQUlnQUNBRWFpSUFOZ0lFSUFJZ0FEWUNBQ0FESUFRZ0Iyb2dBV28yQWdCQkFTRURBa0FnQlEwQVFRQWhBeUFJUlEwQUlBSUNmeUFDS0FJTUlnRkZCRUFnQUNFRVFRQU1BUXNnQUNFRVFRQWhCZ05BSUFGQmYyb2hBU0FFTFFBQUlRVUNmd0pBSUFaQkFrY05BQ0FGUVFOR0JFQWdBVVVFUUVFQkR3c2dCQzBBQVVFRFN3UkFRUUVQQzBFQUlRWWdCRUVCYWd3Q0N5QUZRUU5QRFFCQkFROExJQUFnQlRvQUFFRUFJQVpCQVdvZ0JSc2hCaUFBUVFGcUlRQWdCRUVCYWdzaEJDQUJEUUFMSUFJb0Fnd0xJQUFnQkd0cU5nSU1DeUFEQ3dNQUFRc0w3VElaQUVHR0NBdktCV1lnSmhBR0NHVVlaUmhERUVNUVF4QkRFRU1RUXhCREVFTVFJZ2dpQ0NJSUlnZ2lDQ0lJSWdnaUNDSUlJZ2dpQ0NJSUlnZ2lDQ0lJSWdnQUFBQUFBQUFBQUdwQVNqQXFLQW9nYVRocE9Fa29TU2dwSUNrZ0NSZ0pHR2d3YURCb01HZ3dTQ0JJSUVnZ1NDQW9HQ2dZS0Jnb0dBZ1FDQkFJRUFnUVp5aG5LR2NvWnlobktHY29aeWhuS0VjWVJ4aEhHRWNZUnhoSEdFY1lSeGh1WUU1WUxsQU9VRzVZVGxBdVNBNUlEVUFOUUUxSVRVZ3RRQzFBRFRnTk9HMVFiVkJOUUUxQUxUZ3RPQTB3RFRCclNHdElhMGhyU0d0SWEwaHJTR3RJU3poTE9FczRTemhMT0VzNFN6aExPQ3N3S3pBck1Dc3dLekFyTUNzd0t6QUxLQXNvQ3lnTEtBc29DeWdMS0Fzb0FBQUFBQzlvTDJnUWdGQ0FNSUFRZUhDQVVIZ3dlQkJ3Y0hoUWNEQndFR2h2Y0c5d1QyaFBhQzlnTDJBUFlBOWdiMmh2YUU5Z1QyQXZXQzlZRDFnUFdBQUFBQUFBQUFBQVpqaEdJQ1lnQmhCbU1FWVlKaGdHQ0dVb1pTZ2xFQ1VRWkNCa0lHUWdaQ0JrR0dRWVpCaGtHRU1RUXhCREVFTVFReEJERUVNUVF4QUFBQUFBQUFBQUFHbElTVGdwT0Frd0NDZ0lLRWd3U0RBb01DZ3dDQ0FJSUdkQVowQm5RR2RBUnloSEtFY29SeWduS0Njb0p5Z25LQWNZQnhnSEdBY1lBQUFBQUcxNGJYaHVnRTZBTG9BT2dDNTREbmhPZUM1d1RYQk5jQTF3RFhCdGNHMXdUV2hOYUMxb0xXZ05hQTFvYldodGFFMWdUV0F0WUMxZ0RXQU5ZQXhZREZnTVdBeFlURmhNV0V4WVRGZ3NXQ3hZTEZnc1dBeFFERkFNVUF4UWJHQnNZR3hnYkdCTVVFeFFURkJNVUN4UUxGQXNVQ3hRREVnTVNBeElERWhyV0d0WWExaHJXR3RZYTFocldHdFlTMGhMU0V0SVMwaExTRXRJUzBoTFNDdElLMGdyU0N0SUswZ3JTQ3RJSzBnTFFBdEFDMEFMUUF0QUMwQUxRQXRBYTFCclVHdFFhMUJyVUd0UWExQnJVRXRBUzBCTFFFdEFTMEJMUUV0QVMwQXJRQ3RBSzBBclFDdEFLMEFyUUN0QUN6Z0xPQXM0Q3pnTE9BczRDemdMT0FCQjRBMExyZ2tHR0VZNEpqZ0dFR1pJUmpBbU1BWUlKU2dsS0VVb1JTZ2xJQ1VnUlNCRklDVVlKUmhsUUdWQVJSaEZHQ1VRSlJCa09HUTRaRGhrT0dRd1pEQmtNR1F3WkNoa0tHUW9aQ2hrSUdRZ1pDQmtJR1FZWkJoa0dHUVlSQkJFRUVRUVJCQWtDQ1FJSkFna0NBUUFCQUFFQUFRQUFBQUtnR3FBU29BcWdBcDRhbmhLZUNwNENuQnFjRXB3S25BS2FDbG9LV2dKWUFsZ1NXaEphQ2xnS1dBSldBbFlhV2hwYUVsZ1NXQXBXQ2xZQ1ZBSlVHaGdhR0JvWUdoZ1NGaElXRWhZU0Znb1VDaFFLRkFvVUFoSUNFZ0lTQWhJYUZob1dHaFlhRmhJVUVoUVNGQklVQ2hJS0Vnb1NDaElDRUFJUUFoQUNFQUhPQWM0QnpnSE9BYzRCemdIT0FjNEJ6QUhNQWN3QnpBSE1BY3dCekFITUVkSVIwaEhTRWRJUjBoSFNFZElSMGdIS0Fjb0J5Z0hLQWNvQnlnSEtBY29aMUJuVUdkUVoxQm5VR2RRWjFCblVFZEFSMEJIUUVkQVIwQkhRRWRBUjBBblFDZEFKMEFuUUNkQUowQW5RQ2RBQnlBSElBY2dCeUFISUFjZ0J5QUhJQVlJSmdnQUFBWUFCaEFtRUVZUUFBQUdHQ1lZUmhobUdBWWdKaUJHSUdZZ0JpZ21LRVlvWmlnR01DWXdSakJtTUFZNEpqaEdPR1k0QmtBbVFFWkFaa0FHU0NaSVJraG1TQVpRSmxCR1VHWlFCbGdtV0VaWVpsZ0dZQ1pnUm1CbVlBWm9KbWhHYUdab0JuQW1jRVp3Wm5BR2VDWjRSbmhtZUFhQUpvQkdnR2FBQUFCREVBSUFBZ0FoQ0NFSUlRZ2hDR2NnWnlCSUlDZ2dSeGhIR0NjWUp4Z0dJQVlnQmlBR0lBWVlCaGdHR0FZWUJoQUdFQVlRQmhCbUdHWVlaaGhtR0NZUUpoQW1FQ1lRQmdnR0NBWUlCZ2dBQUdWVlJFUTBOQ01qSXlNVEV4TVRBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRDU2ZG5JeUxpNHA2ZW5wNWVYbDVlR2hvYUdob2FHaG5aMmRuWjJkbloyNXRiR3RxV2xsWldFaElTRWRIUjBkR1JrWkdSVVZGUlVRME5EUTBORFEwTXpNek16TXpNek15TWpJeU1qSXlNakV4TVRFeE1URXhNREF3TURBd01EQTlhMnhjV2xwWldWaElTRWhGUlVWRlJFUkVSRUJBUUVCSE56YzNOemMzTnpZMk5qWTJOalkyTXpNek16TXpNek15TWpJeU1qSXlNakV4TVRFeE1URXhQRnRhVUZsSlIwZERRMEpDU0RnNE9EWTJOalkxTlRVMU5EUTBOREV4TVRFN1dWcEtTRWhDUWtGQlFFQkhOemMzTmpZMk5qVTFOVFUwTkRRME16TXpNenBnWVZGWVNFaElTVGs1T1RrNU9UazNOemMzTnpjM056WTJOalkyTmpZMk5UVTFOVFUxTlRVME5EUTBORFEwTkRNek16TXpNek16TWpJeU1qSXlNakk1WUdGUlYwZEhSMGc0T0RnNE9EZzROalkyTmpZMk5qWTBORFEwTkRRME5ETXpNek16TXpNek1qSXlNakl5TWpJMUpTVWxKU1VsSlNVbEpTVWxKU1VsS0dCaVVsRkJRVUZITnpjM056YzNOelkyTmpZMk5qWTJNek16TXpNek16TTFKU1VsSlNVbEpTVWxKU1VsSlNVbEpDUWtKQ1FrSkNRa0pDUWtKQ1FrSkNGZ1oxZFNRa0pDUlRVMU5UVTFOVFUySmlZbUppWW1KaVltSmlZbUppWW1KQ1FrSkNRa0pDUWtKQ1FrSkNRa0pDTWpJeU1qSXlNakl5TWpJeU1qSXlNaFVGWkdRakl5TWpVbEpTVWxKU1VsSkNRa0pDUWtKQ1FqSXlNakl5TWpJeUJCUWpJek16VTFOQlFVRkJRVUZCUVFRVVEwTWlJaUlpTVRFeE1URXhNVEVERXpJeUlTRWhJUUlTSVNFUkFTSVNBUUV5SWhJQ1F6TWlJaElTQWdKVFF6TWpFaElDQWhNalF6TmpVd0lDQUVHZ0Z3c2tCQVFGQmdjSUNRb01EUThSRkJZWkhDQWtLQzB5T0Q5SFVGcGxjWCtRb3JiTDR2Ly9BRUhnRndza0FnSUNBd01EQXdRRUJBWUdCd2NJQ0FrSkNnb0xDd3dNRFEwT0RnOFBFQkFSRVJJU0FFSEZHQXVFQVFFQUFBRUFBQUVBQUFFQUFRRUFBUUVCQVFFQkFRRUJBUUVCQVFFQkFRSUJBUUlCQVFJQkFRSUJBZ01CQWdNQ0FnTUNBZ1FDQXdRQ0F3UURBd1VEQkFZREJBWUVCUWNFQlFnRUJna0ZCd29HQ0FzR0NBMEhDZzRJQ3hBSkRCSUtEUlFMRHhjTkVSa0FBQUFBQUFBQUFBVUFBQUQvQUFBQUFBQUFBUDhBQUFBQUFBQUEvd0JCMUJrTEZRVUFBQUFBQUFBQUJ3QUFBUDhBQUFBQUFBQUEvd0JCOUJrTEZRVUFBQUFFQUFBQUFBQUFBUDhBQUFBQUFBQUEvd0JCbEJvTEJRVUFBQUFFQUVHa0dndWxBUWNBQUFBRUFBQUFBZ0FBQUFRQUFBQUJBQUFBL3dBQUFBQUFBQUQvQUFBQUFBQUFBUDhBQUFBQUFBQUFCQUFBQUFFQUFBQUVBQUFBQXdBQUFQOEFBQUFBQUFBQS93QUFBQUFBQUFBRUFBQUFBUUFBQUFRQUFBQUVBQUFBL3dBQUFBQUFBQUQvQUFBQUFBQUFBQVFBQUFBQkFBQUFCQUFBQUFRQUFBQUVBQUFBQXdBQUFBUUFBQUFHQUFBQUFBQUFBQTBBQUFEL0FBQUFBQUFBQVA4QUFBQUFBQUFBL3dCQjFCc0xGUTBBQUFBQUFBQUFEd0FBQVA4QUFBQUFBQUFBL3dCQjlCc0xGUTBBQUFBRUFBQUFDQUFBQVA4QUFBQUFBQUFBL3dCQmxCd0x0UXNOQUFBQUJBQUFBQWdBQUFBQUFBQUFEd0FBQUFRQUFBQUtBQUFBQkFBQUFBa0FBQUQvQUFBQUFBQUFBUDhBQUFBQUFBQUEvd0FBQUFBQUFBQUVBQUFBQ1FBQUFBUUFBQUFMQUFBQS93QUFBQUFBQUFEL0FBQUFBQUFBQUFRQUFBQUpBQUFBQkFBQUFBd0FBQUQvQUFBQUFBQUFBUDhBQUFBQUFBQUFCQUFBQUFrQUFBQUVBQUFBREFBQUFBUUFBQUFMQUFBQUJBQUFBQTRBQUFBQkFBQUFDZ0FBQVA4QUFBQUFBQUFBL3dBQUFBQUFBQUQvQUFBQUFBQUFBQUVBQUFBS0FBQUFCQUFBQUFBQUFBRC9BQUFBQUFBQUFQOEFBQUFBQUFBQUFRQUFBQW9BQUFBQkFBQUFDd0FBQVA4QUFBQUFBQUFBL3dBQUFBQUFBQUFCQUFBQUNnQUFBQUVBQUFBTEFBQUFCQUFBQUFBQUFBQUVBQUFBQVFBQUFBRUFBQUFPQUFBQS93QUFBQUFBQUFEL0FBQUFBQUFBQVA4QUFBQUFBQUFBQVFBQUFBNEFBQUFFQUFBQUJBQUFBUDhBQUFBQUFBQUEvd0FBQUFBQUFBQUJBQUFBRGdBQUFBRUFBQUFQQUFBQS93QUFBQUFBQUFEL0FBQUFBQUFBQUFFQUFBQU9BQUFBQVFBQUFBOEFBQUFFQUFBQUJBQUFBQVFBQUFBRkFBQUFCQUFBQUFJQUFBRC9BQUFBQUFBQUFQOEFBQUFBQUFBQS93QUFBQUFBQUFBRUFBQUFBZ0FBQUFRQUFBQUlBQUFBL3dBQUFBQUFBQUQvQUFBQUFBQUFBQVFBQUFBQ0FBQUFCQUFBQUFNQUFBRC9BQUFBQUFBQUFQOEFBQUFBQUFBQUJBQUFBQUlBQUFBRUFBQUFBd0FBQUFRQUFBQUlBQUFBQkFBQUFBa0FBQUFFQUFBQUJnQUFBUDhBQUFBQUFBQUEvd0FBQUFBQUFBRC9BQUFBQUFBQUFBUUFBQUFHQUFBQUJBQUFBQXdBQUFEL0FBQUFBQUFBQVA4QUFBQUFBQUFBQkFBQUFBWUFBQUFFQUFBQUJ3QUFBUDhBQUFBQUFBQUEvd0FBQUFBQUFBQUVBQUFBQmdBQUFBUUFBQUFIQUFBQUJBQUFBQXdBQUFBRUFBQUFEUUFBQUFFQUFBQU9BQUFBL3dBQUFBQUFBQUQvQUFBQUFBQUFBUDhBQUFBQUFBQUFBUUFBQUE0QUFBRC9BQUFBQkFBQUFQOEFBQUFBQUFBQS93QUFBQUFBQUFBQkFBQUFDd0FBQUFFQUFBQU9BQUFBL3dBQUFBQUFBQUQvQUFBQUFBQUFBQUVBQUFBTEFBQUFBUUFBQUE0QUFBQUVBQUFBQVFBQUFQOEFBQUFFQUFBQUFnQUFBQW9BQUFEL0FBQUFBQUFBQVA4QUFBQUFBQUFBL3dBQUFBQUFBQUFDQUFBQUNnQUFBUDhBQUFBQUFBQUEvd0FBQUFBQUFBRC9BQUFBQUFBQUFBRUFBQUFQQUFBQUFnQUFBQW9BQUFEL0FBQUFBQUFBQVA4QUFBQUFBQUFBQVFBQUFBOEFBQUFDQUFBQUNnQUFBQVFBQUFBRkFBQUEvd0FBQUFBQUFBQUVBQUFBQmdBQUFQOEFBQUFBQUFBQS93QUFBQUFBQUFEL0FBQUFBQUFBQUFRQUFBQUdBQUFBL3dBQUFBd0FBQUQvQUFBQUFBQUFBUDhBQUFBQUFBQUFCQUFBQUFNQUFBQUVBQUFBQmdBQUFQOEFBQUFBQUFBQS93QUFBQUFBQUFBRUFBQUFBd0FBQUFRQUFBQUdBQUFBQkFBQUFBa0FBQUQvQUFBQURBQUFBUDhBQUFBQ0FBQUEvd0FBQUFBQUFBRC9BQUFBQUFBQUFQOEFBQUFBQUFBQS93QUFBQUlBQUFEL0FBQUFDQUFBQVA4QUFBQUFBQUFBL3dBQUFBQUFBQUFFQUFBQUJ3QUFBUDhBQUFBQ0FBQUEvd0FBQUFBQUFBRC9BQUFBQUFBQUFBUUFBQUFIQUFBQS93QUFBQUlBQUFBRUFBQUFEUUFBQVA4QUFBQUlBQUFBQXdBQUFBOEFBQUQvQUFBQUFBQUFBUDhBQUFBQUFBQUEvd0FBQUFBQUFBQURBQUFBRHdBQUFBQUFBQUFGQUFBQS93QUFBQUFBQUFEL0FBQUFBQUFBQUFNQUFBQVBBQUFBQVFBQUFBb0FBQUQvQUFBQUFBQUFBUDhBQUFBQUFBQUFBd0FBQUE4QUFBQUJBQUFBQ2dBQUFBQUFBQUFGQUFBQUJBQUFBQUFBQUFBQkFBQUFDd0FBQVA4QUFBQUFBQUFBL3dBQUFBQUFBQUQvQUFBQUFBQUFBQUVBQUFBTEFBQUFCQUFBQUFFQUFBRC9BQUFBQUFBQUFQOEFBQUFBQUFBQUFRQUFBQXNBQUFBQkFBQUFEZ0FBQVA4QUFBQUFBQUFBL3dBQUFBQUFBQUFCQUFBQUN3QUFBQUVBQUFBT0FBQUFCQUFBQUFFQUFBQUVBQUFBQkFBQUFBQUFBQUFIQUFBQS93QUFBQUFBQUFEL0FBQUFBQUFBQVA4QVFkUW5DeFVIQUFBQUFBQUFBQTBBQUFEL0FBQUFBQUFBQVA4QVFmUW5DeFVIQUFBQUJBQUFBQUlBQUFEL0FBQUFBQUFBQVA4QVFaUW9DOWtCQndBQUFBUUFBQUFDQUFBQUFBQUFBQTBBQUFBRUFBQUFDQUFBQUFRQUFBQURBQUFBL3dBQUFBQUFBQUQvQUFBQUFBQUFBUDhBQUFBQUFBQUFCQUFBQUFNQUFBQUVBQUFBQ1FBQUFQOEFBQUFBQUFBQS93QUFBQUFBQUFBRUFBQUFBd0FBQUFRQUFBQUdBQUFBL3dBQUFBQUFBQUQvQUFBQUFBQUFBQVFBQUFBREFBQUFCQUFBQUFZQUFBQUVBQUFBQ1FBQUFBUUFBQUFNQUFBQUFBQUFBQVFBQUFBQUFBQUFCQUFBQUFnQUFBQU1BQUFBQ0FBQUFBd0FBQUFBQUFBQUJBQUFBQUFBQUFBRUFBQUFDQUFBQUF3QUFBQUlBQUFBREFCQitDa0xCUVFBQUFBRUFFR0lLZ3NsQkFBQUFBUUFBQUFJQUFBQUNBQUFBQXdBQUFBTUFBQUFDQUFBQUFnQUFBQU1BQUFBREFCQnNTNEx5QVlCQWdNRUJRWUhDQWtLQ3d3TkRnOFFFUklURkJVV0Z4Z1pHaHNjSFI0ZklDRWlJeVFsSmljb0tTb3JMQzB1THpBeE1qTTBOVFkzT0RrNk96dzlQajlBUVVKRFJFVkdSMGhKU2t0TVRVNVBVRkZTVTFSVlZsZFlXVnBiWEYxZVgyQmhZbU5rWldabmFHbHFhMnh0Ym05d2NYSnpkSFYyZDNoNWVudDhmWDUvZ0lHQ2c0U0Zob2VJaVlxTGpJMk9qNUNSa3BPVWxaYVhtSm1hbTV5ZG5wK2dvYUtqcEtXbXA2aXBxcXVzcmE2dnNMR3lzN1MxdHJlNHVicTd2TDIrdjhEQndzUEV4Y2JIeU1uS3k4ek56cy9RMGRMVDFOWFcxOWpaMnR2YzNkN2Y0T0hpNCtUbDV1Zm82ZXJyN08zdTcvRHg4dlAwOWZiMytQbjYrL3o5L3YvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL3dBQUFBQUJBQUFBQkFBQUFBVUFBQUFDQUFBQUF3QUFBQVlBQUFBSEFBQUFDQUFBQUFrQUFBQU1BQUFBRFFBQUFBb0FBQUFMQUFBQURnQUFBQThBQUFBQUFBQUFBUUFBQUFFQVFZUTFDeUVCQUFBQUFRQUFBQUVBQUFBQkFBQUFBZ0FBQUFJQUFBQUJBQUFBQWdBQUFBSUFRYlExQ3dVRkFBQUFCQUJCeERVTHlRWUhBQUFBQkFBQUFBSUFBQUFFQUFBQUFRQUFBQVFBQUFBRUFBQUFCQUFBQUFNQUFBQUVBQUFBQmdBQUFBQUFBQUFOQUFBQUJBQUFBQWdBQUFBQUFBQUFEd0FBQUFRQUFBQUtBQUFBQkFBQUFBa0FBQUFFQUFBQURBQUFBQVFBQUFBTEFBQUFCQUFBQUE0QUFBQUFBQUFBRVFBQUFBUUFBQUFRQUFBQUFBQUFBQk1BQUFBRUFBQUFFZ0FBQUFBQUFBQVZBQUFBQkFBQUFCUUFBQUFBQUFBQUZ3QUFBQVFBQUFBV0FBQUFBUUFBQUFvQUFBQUJBQUFBQ3dBQUFBUUFBQUFBQUFBQUJBQUFBQUVBQUFBQkFBQUFEZ0FBQUFFQUFBQVBBQUFBQkFBQUFBUUFBQUFFQUFBQUJRQUFBQVFBQUFBQ0FBQUFCQUFBQUFNQUFBQUVBQUFBQ0FBQUFBUUFBQUFKQUFBQUJBQUFBQVlBQUFBRUFBQUFCd0FBQUFRQUFBQU1BQUFBQkFBQUFBMEFBQUFCQUFBQUVnQUFBQUVBQUFBVEFBQUFCQUFBQUJBQUFBQUVBQUFBRVFBQUFBRUFBQUFXQUFBQUFRQUFBQmNBQUFBRUFBQUFGQUFBQUFRQUFBQVZBQUFBQVFBQUFBc0FBQUFCQUFBQURnQUFBQVFBQUFBQkFBQUEvd0FBQUFRQUFBQUJBQUFBRHdBQUFBSUFBQUFLQUFBQUJBQUFBQVVBQUFEL0FBQUFBQUFBQUFRQUFBQURBQUFBQkFBQUFBWUFBQUFFQUFBQUNRQUFBUDhBQUFBTUFBQUFCQUFBQUFjQUFBRC9BQUFBQWdBQUFBUUFBQUFOQUFBQS93QUFBQWdBQUFBQkFBQUFFd0FBQUFJQUFBQVNBQUFBQkFBQUFCRUFBQUQvQUFBQUVBQUFBQUVBQUFBWEFBQUFBZ0FBQUJZQUFBQUVBQUFBRlFBQUFQOEFBQUFVQUFBQUF3QUFBQThBQUFBQkFBQUFDZ0FBQUFBQUFBQUZBQUFBQkFBQUFBQUFBQUFCQUFBQUN3QUFBQUVBQUFBT0FBQUFCQUFBQUFFQUFBQUVBQUFBQkFBQUFBQUFBQUFIQUFBQUJBQUFBQUlBQUFBQUFBQUFEUUFBQUFRQUFBQUlBQUFBQkFBQUFBTUFBQUFFQUFBQUJnQUFBQVFBQUFBSkFBQUFCQUFBQUF3QUFBQURBQUFBRXdBQUFBRUFBQUFTQUFBQUFBQUFBQkVBQUFBRUFBQUFFQUFBQUFNQUFBQVhBQUFBQVFBQUFCWUFBQUFBQUFBQUZRQUFBQVFBQUFBVUFBQUFBUUFBQUFFQUFBQUNBQUFBQWdBQUFBTUFBQUFEQUFBQUF3QUFBQU1BQUFBQUFBQUFBUUFBQUFJQUFBQURBQUFBQkFBQUFBVUFBQUFHQUFBQUJ3QUFBQWdBQUFBSkFBQUFDZ0FBQUFzQUFBQU1BQUFBRFFBQUFBNEFBQUFQQUVHV1BBc3VBUUVCQVFFQkFnSUNBZ0lDQXdNREF3TURCQVFFQkFRRUJRVUZCUVVGQmdZR0JnWUdCd2NIQndjSENBZ0lDQUJCMER3TFJRb0FBQUFOQUFBQUVBQUFBQXNBQUFBT0FBQUFFZ0FBQUEwQUFBQVFBQUFBRkFBQUFBNEFBQUFTQUFBQUZ3QUFBQkFBQUFBVUFBQUFHUUFBQUJJQUFBQVhBQUFBSFFCQm9UMExNd0VDQXdRRkFBRUNBd1FGQUFFQ0F3UUZBQUVDQXdRRkFBRUNBd1FGQUFFQ0F3UUZBQUVDQXdRRkFBRUNBd1FGQUFFQ0F3QkI1RDBMekFJQkFBQUFBZ0FBQUFNQUFBQUVBQUFBQlFBQUFBWUFBQUFIQUFBQUNBQUFBQWtBQUFBS0FBQUFDd0FBQUF3QUFBQU5BQUFBRGdBQUFBOEFBQUFRQUFBQUVRQUFBQklBQUFBVEFBQUFGQUFBQUJVQUFBQVdBQUFBRndBQUFCZ0FBQUFaQUFBQUdnQUFBQnNBQUFBY0FBQUFIUUFBQUIwQUFBQWVBQUFBSHdBQUFDQUFBQUFnQUFBQUlRQUFBQ0lBQUFBaUFBQUFJd0FBQUNNQUFBQWtBQUFBSkFBQUFDVUFBQUFsQUFBQUpRQUFBQ1lBQUFBbUFBQUFKZ0FBQUNjQUFBQW5BQUFBSndBQUFDY0FBQUFCQUFBQUFnQUFBQVFBQUFBSUFBQUFFQUFBQUNBQUFBQkFBQUFBZ0FBQUFDOGZEd0FYR3gwZUJ3c05EaWNyTFM0UUF3VUtEQk1WR2h3akpTb3NBUUlFQ0JFU0ZCZ0dDUllaSUNFaUpDZ21LUUFRQVFJRUNDQURCUW9NRHk4SEN3ME9CZ2tmSXlVcUxDRWlKQ2duS3kwdUVSSVVHQk1WR2h3WEd4MGVGaGttS1E9PVwifSxEPXt9O2Z1bmN0aW9uIG8oKXt2YXIgQSxJPUUoKSh7bG9jYXRlRmlsZTpmdW5jdGlvbihBKXtyZXR1cm4gaVtBXX19KTtyZXR1cm4oQT1JLG5ldyBQcm9taXNlKChmdW5jdGlvbihJKXtBLmNhbGxlZFJ1bj9JKCk6QS5vblJ1bnRpbWVJbml0aWFsaXplZD1mdW5jdGlvbigpe3JldHVybiBJKCl9fSkpKS50aGVuKChmdW5jdGlvbigpe3NlbGYuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwoZnVuY3Rpb24oQSl7dmFyIGc9QS5kYXRhLEI9Zy5yZW5kZXJTdGF0ZUlkO3N3aXRjaChnLnR5cGUpe2Nhc2VcImRlY29kZVwiOnZhciBDPURbQl07Q3x8KEM9bmV3IFEoSSwoZnVuY3Rpb24oQSxJLGcpe3Bvc3RNZXNzYWdlKHt0eXBlOlwicGljdHVyZVJlYWR5XCIsd2lkdGg6SSxoZWlnaHQ6ZyxyZW5kZXJTdGF0ZUlkOkIsZGF0YTpBLmJ1ZmZlcn0sW0EuYnVmZmVyXSl9KSksRFtCXT1DKSxDLmRlY29kZShuZXcgVWludDhBcnJheShnLmRhdGEsZy5vZmZzZXQsZy5sZW5ndGgpKTticmVhaztjYXNlXCJyZWxlYXNlXCI6dmFyIEU9RFtCXTtFJiYoRS5yZWxlYXNlKCksZGVsZXRlIERbQl0pfX0pKSxzZWxmLnBvc3RNZXNzYWdlKHt0eXBlOlwiZGVjb2RlclJlYWR5XCJ9KX0pKX19fSxJPXt9O2Z1bmN0aW9uIGcoQil7dmFyIFE9SVtCXTtpZih2b2lkIDAhPT1RKXJldHVybiBRLmV4cG9ydHM7dmFyIEM9SVtCXT17ZXhwb3J0czp7fX07cmV0dXJuIEFbQl0oQyxDLmV4cG9ydHMsZyksQy5leHBvcnRzfWcubj1BPT57dmFyIEk9QSYmQS5fX2VzTW9kdWxlPygpPT5BLmRlZmF1bHQ6KCk9PkE7cmV0dXJuIGcuZChJLHthOkl9KSxJfSxnLmQ9KEEsSSk9Pntmb3IodmFyIEIgaW4gSSlnLm8oSSxCKSYmIWcubyhBLEIpJiZPYmplY3QuZGVmaW5lUHJvcGVydHkoQSxCLHtlbnVtZXJhYmxlOiEwLGdldDpJW0JdfSl9LGcubz0oQSxJKT0+T2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKEEsSSksZy5yPUE9PntcInVuZGVmaW5lZFwiIT10eXBlb2YgU3ltYm9sJiZTeW1ib2wudG9TdHJpbmdUYWcmJk9iamVjdC5kZWZpbmVQcm9wZXJ0eShBLFN5bWJvbC50b1N0cmluZ1RhZyx7dmFsdWU6XCJNb2R1bGVcIn0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pfSwoKCk9PntcInVzZSBzdHJpY3RcIjtnKDM0MCkuaW5pdCgpfSkoKX0pKCk7JyxcIldvcmtlclwiLHZvaWQgMCx2b2lkIDApfX0sNjE0OkE9PntBLmV4cG9ydHM9ZnVuY3Rpb24oQSxJLGcsZSl7dmFyIEI9c2VsZnx8d2luZG93O3RyeXt0cnl7dmFyIGk7dHJ5e2k9bmV3IEIuQmxvYihbQV0pfWNhdGNoKEkpeyhpPW5ldyhCLkJsb2JCdWlsZGVyfHxCLldlYktpdEJsb2JCdWlsZGVyfHxCLk1vekJsb2JCdWlsZGVyfHxCLk1TQmxvYkJ1aWxkZXIpKS5hcHBlbmQoQSksaT1pLmdldEJsb2IoKX12YXIgUT1CLlVSTHx8Qi53ZWJraXRVUkwsdD1RLmNyZWF0ZU9iamVjdFVSTChpKSxDPW5ldyBCW0ldKHQsZyk7cmV0dXJuIFEucmV2b2tlT2JqZWN0VVJMKHQpLEN9Y2F0Y2goZSl7cmV0dXJuIG5ldyBCW0ldKFwiZGF0YTphcHBsaWNhdGlvbi9qYXZhc2NyaXB0LFwiLmNvbmNhdChlbmNvZGVVUklDb21wb25lbnQoQSkpLGcpfX1jYXRjaChBKXtpZighZSl0aHJvdyBFcnJvcihcIklubGluZSB3b3JrZXIgaXMgbm90IHN1cHBvcnRlZFwiKTtyZXR1cm4gbmV3IEJbSV0oZSxnKX19fX0sST17fTtmdW5jdGlvbiBnKGUpe3ZhciBCPUlbZV07aWYodm9pZCAwIT09QilyZXR1cm4gQi5leHBvcnRzO3ZhciBpPUlbZV09e2V4cG9ydHM6e319O3JldHVybiBBW2VdLmNhbGwoaS5leHBvcnRzLGksaS5leHBvcnRzLGcpLGkuZXhwb3J0c31yZXR1cm4gZy5uPUE9Pnt2YXIgST1BJiZBLl9fZXNNb2R1bGU/KCk9PkEuZGVmYXVsdDooKT0+QTtyZXR1cm4gZy5kKEkse2E6SX0pLEl9LGcuZD0oQSxJKT0+e2Zvcih2YXIgZSBpbiBJKWcubyhJLGUpJiYhZy5vKEEsZSkmJk9iamVjdC5kZWZpbmVQcm9wZXJ0eShBLGUse2VudW1lcmFibGU6ITAsZ2V0OklbZV19KX0sZy5vPShBLEkpPT5PYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoQSxJKSxnLnI9QT0+e1widW5kZWZpbmVkXCIhPXR5cGVvZiBTeW1ib2wmJlN5bWJvbC50b1N0cmluZ1RhZyYmT2JqZWN0LmRlZmluZVByb3BlcnR5KEEsU3ltYm9sLnRvU3RyaW5nVGFnLHt2YWx1ZTpcIk1vZHVsZVwifSksT2JqZWN0LmRlZmluZVByb3BlcnR5KEEsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSl9LGcoMTE0KX0pKCl9LDUzOkE9PntzZWxmLEEuZXhwb3J0cz0oKCk9PntcInVzZSBzdHJpY3RcIjt2YXIgQT17MTE0OmZ1bmN0aW9uKEEsSSxnKXt2YXIgZT10aGlzJiZ0aGlzLl9faW1wb3J0RGVmYXVsdHx8ZnVuY3Rpb24oQSl7cmV0dXJuIEEmJkEuX19lc01vZHVsZT9BOntkZWZhdWx0OkF9fTtPYmplY3QuZGVmaW5lUHJvcGVydHkoSSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTtjb25zdCBCPWUoZygyODkpKTtJLmRlZmF1bHQ9Y2xhc3N7aW5pdGlhbGl6ZSgpe3JldHVybiBuZXcgUHJvbWlzZSgoKEEsSSk9Pnt0aGlzLndvcmtlcj1uZXcgQi5kZWZhdWx0LHRoaXMud29ya2VyLmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsKEk9Pnt2YXIgZztjb25zdCBlPUkuZGF0YTtcImRlY29kZXJSZWFkeVwiPT09ZS50eXBlP0EoMCk6XCJkZWNvZGVEb25lXCI9PT1lLnR5cGUmJihudWxsPT09KGc9dGhpcy5vbkRlY29kZSl8fHZvaWQgMD09PWd8fGcuY2FsbCh0aGlzLGUpKX0pKX0pKX1zdGFydFN0cmVhbShBLEksZyl7dGhpcy53b3JrZXImJnRoaXMud29ya2VyLnBvc3RNZXNzYWdlKHt0eXBlOlwic3RhcnRTdHJlYW1cIixzYW1wbGVSYXRlSHo6QSxjaGFubmVsQ291bnQ6SSxkZWNvZGVkU2FtcGxlc1BlckZyYW1lOmd9KX1zdG9wU3RyZWFtKCl7dGhpcy53b3JrZXImJnRoaXMud29ya2VyLnBvc3RNZXNzYWdlKHt0eXBlOlwic3RvcFN0cmVhbVwifSl9ZGVjb2RlKEEsSSl7dGhpcy53b3JrZXImJnRoaXMud29ya2VyLnBvc3RNZXNzYWdlKHt0eXBlOlwiZGVjb2RlXCIsc3RhcnRUaW1lc3RhbXA6QSxpbnB1dERhdGE6SX0sW0ldKX1yZWxlYXNlKCl7dGhpcy53b3JrZXImJnRoaXMud29ya2VyLnBvc3RNZXNzYWdlKHt0eXBlOlwicmVsZWFzZVwifSl9ZGlzcG9zZSgpe3RoaXMud29ya2VyJiYodGhpcy53b3JrZXIudGVybWluYXRlKCksdGhpcy53b3JrZXI9dm9pZCAwKX19fSwyODk6KEEsSSxnKT0+e2cucihJKSxnLmQoSSx7ZGVmYXVsdDooKT0+aX0pO3ZhciBlPWcoNjE0KSxCPWcubihlKTtmdW5jdGlvbiBpKCl7cmV0dXJuIEIoKSgnKCgpPT57dmFyIEE9ezMwNTpBPT57dmFyIEksZz0oST1cInVuZGVmaW5lZFwiIT10eXBlb2YgZG9jdW1lbnQmJmRvY3VtZW50LmN1cnJlbnRTY3JpcHQ/ZG9jdW1lbnQuY3VycmVudFNjcmlwdC5zcmM6dm9pZCAwLGZ1bmN0aW9uKEEpe3ZhciBnLEI7KEE9dm9pZCAwIT09KEE9QXx8e30pP0E6e30pLnJlYWR5PW5ldyBQcm9taXNlKChmdW5jdGlvbihBLEkpe2c9QSxCPUl9KSk7dmFyIFEsQz17fTtmb3IoUSBpbiBBKUEuaGFzT3duUHJvcGVydHkoUSkmJihDW1FdPUFbUV0pO3ZhciBFPVtdLGk9XCIuL3RoaXMucHJvZ3JhbVwiLEQ9ZnVuY3Rpb24oQSxJKXt0aHJvdyBJfSxvPVwiXCI7XCJ1bmRlZmluZWRcIiE9dHlwZW9mIGRvY3VtZW50JiZkb2N1bWVudC5jdXJyZW50U2NyaXB0JiYobz1kb2N1bWVudC5jdXJyZW50U2NyaXB0LnNyYyksSSYmKG89SSksbz0wIT09by5pbmRleE9mKFwiYmxvYjpcIik/by5zdWJzdHIoMCxvLmxhc3RJbmRleE9mKFwiL1wiKSsxKTpcIlwiO3ZhciB3LEYsRz1BLnByaW50fHxjb25zb2xlLmxvZy5iaW5kKGNvbnNvbGUpLFI9QS5wcmludEVycnx8Y29uc29sZS53YXJuLmJpbmQoY29uc29sZSk7Zm9yKFEgaW4gQylDLmhhc093blByb3BlcnR5KFEpJiYoQVtRXT1DW1FdKTtDPW51bGwsQS5hcmd1bWVudHMmJihFPUEuYXJndW1lbnRzKSxBLnRoaXNQcm9ncmFtJiYoaT1BLnRoaXNQcm9ncmFtKSxBLnF1aXQmJihEPUEucXVpdCksQS53YXNtQmluYXJ5JiYodz1BLndhc21CaW5hcnkpLEEubm9FeGl0UnVudGltZSYmKEY9QS5ub0V4aXRSdW50aW1lKSxcIm9iamVjdFwiIT10eXBlb2YgV2ViQXNzZW1ibHkmJm4oXCJubyBuYXRpdmUgd2FzbSBzdXBwb3J0IGRldGVjdGVkXCIpO3ZhciBTPSExO2Z1bmN0aW9uIFUoSSl7dmFyIGcsQj1BW1wiX1wiK0ldO3JldHVybiBnPVwiQ2Fubm90IGNhbGwgdW5rbm93biBmdW5jdGlvbiBcIitJK1wiLCBtYWtlIHN1cmUgaXQgaXMgZXhwb3J0ZWRcIixCfHxuKFwiQXNzZXJ0aW9uIGZhaWxlZDogXCIrZyksQn1mdW5jdGlvbiBhKEEsSSxnLEIsUSl7dmFyIEM9e3N0cmluZzpmdW5jdGlvbihBKXt2YXIgST0wO2lmKG51bGwhPUEmJjAhPT1BKXt2YXIgZz0xKyhBLmxlbmd0aDw8Mik7IWZ1bmN0aW9uKEEsSSxnKXtKKEEsayxJLGcpfShBLEk9VihnKSxnKX1yZXR1cm4gSX0sYXJyYXk6ZnVuY3Rpb24oQSl7dmFyIEksZyxCPVYoQS5sZW5ndGgpO3JldHVybiBJPUEsZz1CLHMuc2V0KEksZyksQn19LEU9VShBKSxpPVtdLEQ9MDtpZihCKWZvcih2YXIgbz0wO288Qi5sZW5ndGg7bysrKXt2YXIgdz1DW2dbb11dO3c/KDA9PT1EJiYoRD1YKCkpLGlbb109dyhCW29dKSk6aVtvXT1CW29dfXZhciBGPUUuYXBwbHkobnVsbCxpKTtyZXR1cm4gRj1mdW5jdGlvbihBKXtyZXR1cm5cInN0cmluZ1wiPT09ST9IKEEpOlwiYm9vbGVhblwiPT09ST9Cb29sZWFuKEEpOkF9KEYpLDAhPT1EJiZaKEQpLEZ9dmFyIHMsayxoLE49XCJ1bmRlZmluZWRcIiE9dHlwZW9mIFRleHREZWNvZGVyP25ldyBUZXh0RGVjb2RlcihcInV0ZjhcIik6dm9pZCAwO2Z1bmN0aW9uIHkoQSxJLGcpe2Zvcih2YXIgQj1JK2csUT1JO0FbUV0mJiEoUT49Qik7KSsrUTtpZihRLUk+MTYmJkEuc3ViYXJyYXkmJk4pcmV0dXJuIE4uZGVjb2RlKEEuc3ViYXJyYXkoSSxRKSk7Zm9yKHZhciBDPVwiXCI7STxROyl7dmFyIEU9QVtJKytdO2lmKDEyOCZFKXt2YXIgaT02MyZBW0krK107aWYoMTkyIT0oMjI0JkUpKXt2YXIgRD02MyZBW0krK107aWYoKEU9MjI0PT0oMjQwJkUpPygxNSZFKTw8MTJ8aTw8NnxEOig3JkUpPDwxOHxpPDwxMnxEPDw2fDYzJkFbSSsrXSk8NjU1MzYpQys9U3RyaW5nLmZyb21DaGFyQ29kZShFKTtlbHNle3ZhciBvPUUtNjU1MzY7Qys9U3RyaW5nLmZyb21DaGFyQ29kZSg1NTI5NnxvPj4xMCw1NjMyMHwxMDIzJm8pfX1lbHNlIEMrPVN0cmluZy5mcm9tQ2hhckNvZGUoKDMxJkUpPDw2fGkpfWVsc2UgQys9U3RyaW5nLmZyb21DaGFyQ29kZShFKX1yZXR1cm4gQ31mdW5jdGlvbiBIKEEsSSl7cmV0dXJuIEE/eShrLEEsSSk6XCJcIn1mdW5jdGlvbiBKKEEsSSxnLEIpe2lmKCEoQj4wKSlyZXR1cm4gMDtmb3IodmFyIFE9ZyxDPWcrQi0xLEU9MDtFPEEubGVuZ3RoOysrRSl7dmFyIGk9QS5jaGFyQ29kZUF0KEUpO2lmKGk+PTU1Mjk2JiZpPD01NzM0MyYmKGk9NjU1MzYrKCgxMDIzJmkpPDwxMCl8MTAyMyZBLmNoYXJDb2RlQXQoKytFKSksaTw9MTI3KXtpZihnPj1DKWJyZWFrO0lbZysrXT1pfWVsc2UgaWYoaTw9MjA0Nyl7aWYoZysxPj1DKWJyZWFrO0lbZysrXT0xOTJ8aT4+NixJW2crK109MTI4fDYzJml9ZWxzZSBpZihpPD02NTUzNSl7aWYoZysyPj1DKWJyZWFrO0lbZysrXT0yMjR8aT4+MTIsSVtnKytdPTEyOHxpPj42JjYzLElbZysrXT0xMjh8NjMmaX1lbHNle2lmKGcrMz49QylicmVhaztJW2crK109MjQwfGk+PjE4LElbZysrXT0xMjh8aT4+MTImNjMsSVtnKytdPTEyOHxpPj42JjYzLElbZysrXT0xMjh8NjMmaX19cmV0dXJuIElbZ109MCxnLVF9ZnVuY3Rpb24gTChBKXt2YXIgST1mdW5jdGlvbihBKXtmb3IodmFyIEk9MCxnPTA7ZzxBLmxlbmd0aDsrK2cpe3ZhciBCPUEuY2hhckNvZGVBdChnKTtCPj01NTI5NiYmQjw9NTczNDMmJihCPTY1NTM2KygoMTAyMyZCKTw8MTApfDEwMjMmQS5jaGFyQ29kZUF0KCsrZykpLEI8PTEyNz8rK0k6SSs9Qjw9MjA0Nz8yOkI8PTY1NTM1PzM6NH1yZXR1cm4gSX0oQSkrMSxnPVYoSSk7cmV0dXJuIEooQSxzLGcsSSksZ31BLklOSVRJQUxfTUVNT1JZO3ZhciBxLE09W10sSz1bXSxjPVtdLFk9W107Sy5wdXNoKHtmdW5jOmZ1bmN0aW9uKCl7bCgpfX0pO3ZhciBkPTAsUD1udWxsLHQ9bnVsbDtmdW5jdGlvbiBuKEkpe0Eub25BYm9ydCYmQS5vbkFib3J0KEkpLFIoSSs9XCJcIiksUz0hMCxJPVwiYWJvcnQoXCIrSStcIikuIEJ1aWxkIHdpdGggLXMgQVNTRVJUSU9OUz0xIGZvciBtb3JlIGluZm8uXCI7dmFyIGc9bmV3IFdlYkFzc2VtYmx5LlJ1bnRpbWVFcnJvcihJKTt0aHJvdyBCKGcpLGd9QS5wcmVsb2FkZWRJbWFnZXM9e30sQS5wcmVsb2FkZWRBdWRpb3M9e307dmFyIHI9XCJkYXRhOmFwcGxpY2F0aW9uL29jdGV0LXN0cmVhbTtiYXNlNjQsXCI7ZnVuY3Rpb24gZihBKXtyZXR1cm4gST1BLGc9cixTdHJpbmcucHJvdG90eXBlLnN0YXJ0c1dpdGg/SS5zdGFydHNXaXRoKGcpOjA9PT1JLmluZGV4T2YoZyk7dmFyIEksZ312YXIgVyxiPVwiZGF0YTphcHBsaWNhdGlvbi9vY3RldC1zdHJlYW07YmFzZTY0LEFHRnpiUUVBQUFBQmhBTW9ZQU4vZjM4QmYyQURmMzkvQUdBRWYzOS9md0JnQVg4QmYyQUNmMzhCZjJBRmYzOS9mMzhBWUFKL2Z3QmdCMzkvZjM5L2YzOEFZQVovZjM5L2YzOEFZQUYvQUdBRWYzOS9md0YvWUFWL2YzOS9md0YvWUFBQVlBaC9mMzkvZjM5L2Z3QmdDWDkvZjM5L2YzOS9md0JnQm45L2YzOS9md0YvWUFkL2YzOS9mMzkvQVg5Z0FuNS9BWDlnQkg5L2YzOEJmV0FCZkFGOFlBSjhmQUY4WUF0L2YzOS9mMzkvZjM5L2Z3QmdEWDkvZjM5L2YzOS9mMzkvZjM4QVlBNS9mMzkvZjM5L2YzOS9mMzkvZndCZ0ZIOS9mMzkvZjM5L2YzOS9mMzkvZjM5L2YzOS9BR0FNZjM5L2YzOTlmWDkvZjM5L0FHQUVmMzk5ZndCZ0FBRi9ZQWgvZjM5L2YzOS9md0YvWUF0L2YzOS9mMzkvZjM5L2Z3Ri9ZQkIvZjM5L2YzOS9mMzkvZjM5L2YzOS9BWDlnQzM5L2YzOS9mMzkvZlg5L0FYOWdDWDkvZjM5L2YzOTlmd0YvWUFkL2YzOS9mMzk5QVg5Z0NYOS9mMzkvZjMxL2Z3Ri9ZQVovZkg5L2YzOEJmMkFEZm45L0FYOWdBbngvQVg5Z0EzOStmd0YrWUFKOGZ3RjhBaE1EQVdFQllRQUtBV0VCWWdBQUFXRUJZd0FEQTU4Qm5RRUFBQUFFQUFrRUh3TURCUUFEQVNBT0N5Y0RCQWNQR1FJR0R3UUdFd1lDRmhVZEJnTUZCUUVCQWdzVUdnZ0FBZ3dGQ0FFQkVBTUhCQVlDQWdJRUFnSUtIQU1DQWdVQUFBQUJBd1FRRkJNQkJBRU9BUUlTQWdnRkFRQUFBZ01DR0FRWENBWUJCUUFEQlFBSkJRRUNDQU1CRFFFQkFRRUtBZ2tIQkFRTEFBQUVBd0FEQ1JzUkVTUUVBUUVEQkFRbUF3QUtKUXNoQUNJU0JoNERCdzBNQkFVQmNBRUZCUVVHQVFHQUFvQUNCZ2tCZndGQjRJZkNBZ3NITmd3QlpBSUFBV1VCQUFGbUFESUJad0NmQVFGb0FJRUJBV2tBZUFGcUFIRUJhd0JzQVd3QVlnRnRBSVlCQVc0QWhRRUJid0NFQVFrTkFRQkJBUXNFZTVFQmtnR1FBUXFkN2dXZEFZRUNBUWgvSUFBb0Fod2lBeUFDZGlFSElBQW9BaUFoQkVGL0lRSURRQ0FESVFVZ0JDQUhJQUVnQWtFQmFpSUNhaTBBQUd3aUEwa05BQXNnQUNBRklBTnJJZ0UyQWh3Z0FDQUVJQU5ySWdnMkFpQWdBVUdBZ0lBRVRRUkFJQUFvQWhnaEJpQUFLQUlvSVFRZ0FDZ0NGQ0VKSUFBb0FnUWhDZ05BSUFBZ0FVRUlkQ0lITmdJY0lBQWdDVUVJYWlJSk5nSVVRUUFoQXlBR0lBcEpCRUFnQUNBR1FRRnFJZ1UyQWhnZ0FDZ0NBQ0FHYWkwQUFDRURJQVVoQmdzZ0FDQUROZ0lvSUFBZ0NFRUlkRUdBL3YvL0IzRWdBeUFFUVFoMGNrRUJka0gvQVhGeVFmOEJjeUlJTmdJZ0lBRkJnWUFDU1NFRklBTWhCQ0FISVFFZ0JRMEFDd3NnQWd1Q0JBRURmeUFDUVlBRVR3UkFJQUFnQVNBQ0VBRWFJQUFQQ3lBQUlBSnFJUU1DUUNBQUlBRnpRUU54UlFSQUFrQWdBa0VCU0FSQUlBQWhBZ3dCQ3lBQVFRTnhSUVJBSUFBaEFnd0JDeUFBSVFJRFFDQUNJQUV0QUFBNkFBQWdBVUVCYWlFQklBSkJBV29pQWlBRFR3MEJJQUpCQTNFTkFBc0xBa0FnQTBGOGNTSUVRY0FBU1EwQUlBSWdCRUZBYWlJRlN3MEFBMEFnQWlBQktBSUFOZ0lBSUFJZ0FTZ0NCRFlDQkNBQ0lBRW9BZ2cyQWdnZ0FpQUJLQUlNTmdJTUlBSWdBU2dDRURZQ0VDQUNJQUVvQWhRMkFoUWdBaUFCS0FJWU5nSVlJQUlnQVNnQ0hEWUNIQ0FDSUFFb0FpQTJBaUFnQWlBQktBSWtOZ0lrSUFJZ0FTZ0NLRFlDS0NBQ0lBRW9BaXcyQWl3Z0FpQUJLQUl3TmdJd0lBSWdBU2dDTkRZQ05DQUNJQUVvQWpnMkFqZ2dBaUFCS0FJOE5nSThJQUZCUUdzaEFTQUNRVUJySWdJZ0JVME5BQXNMSUFJZ0JFOE5BUU5BSUFJZ0FTZ0NBRFlDQUNBQlFRUnFJUUVnQWtFRWFpSUNJQVJKRFFBTERBRUxJQU5CQkVrRVFDQUFJUUlNQVFzZ0FDQURRUVJySWdSTEJFQWdBQ0VDREFFTElBQWhBZ05BSUFJZ0FTMEFBRG9BQUNBQ0lBRXRBQUU2QUFFZ0FpQUJMUUFDT2dBQ0lBSWdBUzBBQXpvQUF5QUJRUVJxSVFFZ0FrRUVhaUlDSUFSTkRRQUxDeUFDSUFOSkJFQURRQ0FDSUFFdEFBQTZBQUFnQVVFQmFpRUJJQUpCQVdvaUFpQURSdzBBQ3dzZ0FBdnpBZ0lDZndGK0FrQWdBa1VOQUNBQUlBSnFJZ05CQVdzZ0FUb0FBQ0FBSUFFNkFBQWdBa0VEU1EwQUlBTkJBbXNnQVRvQUFDQUFJQUU2QUFFZ0EwRURheUFCT2dBQUlBQWdBVG9BQWlBQ1FRZEpEUUFnQTBFRWF5QUJPZ0FBSUFBZ0FUb0FBeUFDUVFsSkRRQWdBRUVBSUFCclFRTnhJZ1JxSWdNZ0FVSC9BWEZCZ1lLRUNHd2lBVFlDQUNBRElBSWdCR3RCZkhFaUJHb2lBa0VFYXlBQk5nSUFJQVJCQ1VrTkFDQURJQUUyQWdnZ0F5QUJOZ0lFSUFKQkNHc2dBVFlDQUNBQ1FReHJJQUUyQWdBZ0JFRVpTUTBBSUFNZ0FUWUNHQ0FESUFFMkFoUWdBeUFCTmdJUUlBTWdBVFlDRENBQ1FSQnJJQUUyQWdBZ0FrRVVheUFCTmdJQUlBSkJHR3NnQVRZQ0FDQUNRUnhySUFFMkFnQWdCQ0FEUVFSeFFSaHlJZ1JySWdKQklFa05BQ0FCclNJRlFpQ0dJQVdFSVFVZ0F5QUVhaUVCQTBBZ0FTQUZOd01ZSUFFZ0JUY0RFQ0FCSUFVM0F3Z2dBU0FGTndNQUlBRkJJR29oQVNBQ1FTQnJJZ0pCSDBzTkFBc0xJQUFMNndFQkNYOGdBQ2dDSUNJRUlBQW9BaHdpQWlBQmRpSUJTU0lHUlFSQUlBQWdCQ0FCYXlJRU5nSWdDeUFBSUFFZ0FpQUJheUFHR3lJRk5nSWNJQVZCZ0lDQUJFMEVRQ0FBS0FJWUlRTWdBQ2dDS0NFSElBQW9BaFFoQ0NBQUtBSUVJUWtEUUNBQUlBVkJDSFFpQ2pZQ0hDQUFJQWhCQ0dvaUNEWUNGRUVBSVFFZ0F5QUpTUVJBSUFBZ0EwRUJhaUlDTmdJWUlBQW9BZ0FnQTJvdEFBQWhBU0FDSVFNTElBQWdBVFlDS0NBQUlBUkJDSFJCZ1A3Ly93ZHhJQUVnQjBFSWRISkJBWFpCL3dGeGNrSC9BWE1pQkRZQ0lDQUZRWUdBQWtraEFpQUJJUWNnQ2lFRklBSU5BQXNMSUFZTHJ3WUJCWDhqQUVFUWF5SURKQUFnQXlBQ05nSU1RWHNoQWdKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQWdBVUc3SDJzT0ZRRUNDZ29HQ2dNS0Nnb0tDZ29LQ2dvS0Nnb0hDQUFMQWtBQ1FBSkFBa0FnQVVHWHpnQnJEZ29EQWcwQURRRU5EUWNJRFFzZ0F5QURLQUlNSWdGQkJHbzJBZ3hCZnlFQ0lBRW9BZ0FpQVVFQVNBME1JQUVnQUNnQ0FDZ0NDRTRORENBQUlBRTJBaFFNQ3dzZ0F5QURLQUlNSWdGQkJHbzJBZ3hCZnlFQ0lBRW9BZ0FpQVVFQlNBMExJQUVnQUNnQ0FDZ0NDRW9OQ3lBQUlBRTJBaGdNQ2dzZ0F5QURLQUlNSWdGQkJHbzJBZ3hCZnlFQ0lBRW9BZ0FpQVVFQmEwRUJTdzBLSUFBZ0FUWUNEQXdKQ3lBRElBTW9BZ3dpQVVFRWFqWUNEQ0FCS0FJQUlnRkZCRUJCZnlFQ0RBb0xJQUVnQUNnQ0xEWUNBRUVBSVFJZ0FFRUFOZ0lzREFrTElBTWdBeWdDRENJQlFRUnFOZ0lNSUFFb0FnQWlBVVVFUUVGL0lRSU1DUXNnQVNBQUtBSUVJQUFvQWhCdE5nSUFEQWNMSUFBb0FnUWhCa0VBSVFJZ0FFRW9ha0VBSUFBb0FnQWlCQ2dDQ0NJQlFRVjBJQUFvQWdnaUJTQUVLQUlFUVFKMFFlREFBR3BzYWtFMGFoQUZHaUFCUVFGT0JFQWdBVUVEZENJRUlBQWdCa0dBRUdvZ0JXeEJBblJxSUFWQjRBQnNhbXBCM0FCcUlnVWdCR29oQmlBQlFRRjBJZ0ZCQVNBQlFRRktHeUVFUVFBaEFRTkFJQVlnQVVFQ2RDSUhha0dBZ0lDUGZEWUNBQ0FGSUFkcVFZQ0FnSTk4TmdJQUlBRkJBV29pQVNBRVJ3MEFDd3NnQUVFQk5nSTREQWNMSUFNZ0F5Z0NEQ0lCUVFScU5nSU1JQUVvQWdBaUFVVUVRRUYvSVFJTUJ3c2dBU0FBS0FJOE5nSUFEQVVMSUFNZ0F5Z0NEQ0lCUVFScU5nSU1JQUVvQWdBaUFVVUVRRUYvSVFJTUJnc2dBU0FBS0FJQU5nSUFEQVFMSUFNZ0F5Z0NEQ0lCUVFScU5nSU1JQUFnQVNnQ0FEWUNIQXdEQ3lBRElBTW9BZ3dpQVVFRWFqWUNEQ0FCS0FJQUlnRkZCRUJCZnlFQ0RBUUxJQUVnQUNnQ0tEWUNBQXdDQ3lBRElBTW9BZ3dpQVVFRWFqWUNERUYvSVFJZ0FTZ0NBQ0lCUVFGTERRSWdBQ0FCTmdJZ0RBRUxJQU1nQXlnQ0RDSUJRUVJxTmdJTUlBRW9BZ0FpQVVVRVFFRi9JUUlNQWdzZ0FTQUFLQUlnTmdJQUMwRUFJUUlMSUFOQkVHb2tBQ0FDQzRJTkFRZC9Ba0FnQUVVTkFDQUFRUWhySWdNZ0FFRUVheWdDQUNJQlFYaHhJZ0JxSVFVQ1FDQUJRUUZ4RFFBZ0FVRURjVVVOQVNBRElBTW9BZ0FpQW1zaUEwR3crd0VvQWdBaUJFa05BU0FBSUFKcUlRQWdBMEcwK3dFb0FnQkhCRUFnQWtIL0FVMEVRQ0FES0FJSUlnUWdBa0VEZGlJQ1FRTjBRY2o3QVdwSEdpQUVJQU1vQWd3aUFVWUVRRUdnK3dGQm9Qc0JLQUlBUVg0Z0FuZHhOZ0lBREFNTElBUWdBVFlDRENBQklBUTJBZ2dNQWdzZ0F5Z0NHQ0VHQWtBZ0F5QURLQUlNSWdGSEJFQWdBeWdDQ0NJQ0lBUlBCRUFnQWlnQ0RCb0xJQUlnQVRZQ0RDQUJJQUkyQWdnTUFRc0NRQ0FEUVJScUlnSW9BZ0FpQkEwQUlBTkJFR29pQWlnQ0FDSUVEUUJCQUNFQkRBRUxBMEFnQWlFSElBUWlBVUVVYWlJQ0tBSUFJZ1FOQUNBQlFSQnFJUUlnQVNnQ0VDSUVEUUFMSUFkQkFEWUNBQXNnQmtVTkFRSkFJQU1nQXlnQ0hDSUNRUUowUWREOUFXb2lCQ2dDQUVZRVFDQUVJQUUyQWdBZ0FRMEJRYVQ3QVVHayt3RW9BZ0JCZmlBQ2QzRTJBZ0FNQXdzZ0JrRVFRUlFnQmlnQ0VDQURSaHRxSUFFMkFnQWdBVVVOQWdzZ0FTQUdOZ0lZSUFNb0FoQWlBZ1JBSUFFZ0FqWUNFQ0FDSUFFMkFoZ0xJQU1vQWhRaUFrVU5BU0FCSUFJMkFoUWdBaUFCTmdJWURBRUxJQVVvQWdRaUFVRURjVUVEUncwQVFhajdBU0FBTmdJQUlBVWdBVUYrY1RZQ0JDQURJQUJCQVhJMkFnUWdBQ0FEYWlBQU5nSUFEd3NnQXlBRlR3MEFJQVVvQWdRaUFVRUJjVVVOQUFKQUlBRkJBbkZGQkVBZ0JVRzQrd0VvQWdCR0JFQkJ1UHNCSUFNMkFnQkJyUHNCUWF6N0FTZ0NBQ0FBYWlJQU5nSUFJQU1nQUVFQmNqWUNCQ0FEUWJUN0FTZ0NBRWNOQTBHbyt3RkJBRFlDQUVHMCt3RkJBRFlDQUE4TElBVkJ0UHNCS0FJQVJnUkFRYlQ3QVNBRE5nSUFRYWo3QVVHbyt3RW9BZ0FnQUdvaUFEWUNBQ0FESUFCQkFYSTJBZ1FnQUNBRGFpQUFOZ0lBRHdzZ0FVRjRjU0FBYWlFQUFrQWdBVUgvQVUwRVFDQUZLQUlNSVFJZ0JTZ0NDQ0lFSUFGQkEzWWlBVUVEZEVISSt3RnFJZ2RIQkVCQnNQc0JLQUlBR2dzZ0FpQUVSZ1JBUWFEN0FVR2crd0VvQWdCQmZpQUJkM0UyQWdBTUFnc2dBaUFIUndSQVFiRDdBU2dDQUJvTElBUWdBallDRENBQ0lBUTJBZ2dNQVFzZ0JTZ0NHQ0VHQWtBZ0JTQUZLQUlNSWdGSEJFQWdCU2dDQ0NJQ1FiRDdBU2dDQUU4RVFDQUNLQUlNR2dzZ0FpQUJOZ0lNSUFFZ0FqWUNDQXdCQ3dKQUlBVkJGR29pQWlnQ0FDSUVEUUFnQlVFUWFpSUNLQUlBSWdRTkFFRUFJUUVNQVFzRFFDQUNJUWNnQkNJQlFSUnFJZ0lvQWdBaUJBMEFJQUZCRUdvaEFpQUJLQUlRSWdRTkFBc2dCMEVBTmdJQUN5QUdSUTBBQWtBZ0JTQUZLQUljSWdKQkFuUkIwUDBCYWlJRUtBSUFSZ1JBSUFRZ0FUWUNBQ0FCRFFGQnBQc0JRYVQ3QVNnQ0FFRitJQUozY1RZQ0FBd0NDeUFHUVJCQkZDQUdLQUlRSUFWR0cyb2dBVFlDQUNBQlJRMEJDeUFCSUFZMkFoZ2dCU2dDRUNJQ0JFQWdBU0FDTmdJUUlBSWdBVFlDR0FzZ0JTZ0NGQ0lDUlEwQUlBRWdBallDRkNBQ0lBRTJBaGdMSUFNZ0FFRUJjallDQkNBQUlBTnFJQUEyQWdBZ0EwRzArd0VvQWdCSERRRkJxUHNCSUFBMkFnQVBDeUFGSUFGQmZuRTJBZ1FnQXlBQVFRRnlOZ0lFSUFBZ0Eyb2dBRFlDQUFzZ0FFSC9BVTBFUUNBQVFRTjJJZ0ZCQTNSQnlQc0JhaUVBQW45Qm9Qc0JLQUlBSWdKQkFTQUJkQ0lCY1VVRVFFR2crd0VnQVNBQ2NqWUNBQ0FBREFFTElBQW9BZ2dMSVFJZ0FDQUROZ0lJSUFJZ0F6WUNEQ0FESUFBMkFnd2dBeUFDTmdJSUR3dEJIeUVDSUFOQ0FEY0NFQ0FBUWYvLy93ZE5CRUFnQUVFSWRpSUJJQUZCZ1A0L2FrRVFka0VJY1NJQmRDSUNJQUpCZ09BZmFrRVFka0VFY1NJQ2RDSUVJQVJCZ0lBUGFrRVFka0VDY1NJRWRFRVBkaUFCSUFKeUlBUnlheUlCUVFGMElBQWdBVUVWYW5aQkFYRnlRUnhxSVFJTElBTWdBallDSENBQ1FRSjBRZEQ5QVdvaEFRSkFBa0FDUUVHayt3RW9BZ0FpQkVFQklBSjBJZ2R4UlFSQVFhVDdBU0FFSUFkeU5nSUFJQUVnQXpZQ0FDQURJQUUyQWhnTUFRc2dBRUVBUVJrZ0FrRUJkbXNnQWtFZlJodDBJUUlnQVNnQ0FDRUJBMEFnQVNJRUtBSUVRWGh4SUFCR0RRSWdBa0VkZGlFQklBSkJBWFFoQWlBRUlBRkJCSEZxSWdkQkVHb29BZ0FpQVEwQUN5QUhJQU0yQWhBZ0F5QUVOZ0lZQ3lBRElBTTJBZ3dnQXlBRE5nSUlEQUVMSUFRb0FnZ2lBQ0FETmdJTUlBUWdBellDQ0NBRFFRQTJBaGdnQXlBRU5nSU1JQU1nQURZQ0NBdEJ3UHNCUWNEN0FTZ0NBRUVCYXlJQVFYOGdBQnMyQWdBTEM2TUJBUVovSUFBb0Fnd2hBd0pBSUFFZ0FDZ0NFQ0lDVFFSQUlBSWhCQXdCQ3lBQUtBSUlJUVVnQUNnQ0JDRUdBMEJCQUNFRUlBVWdCa2tFZnlBQUlBVkJBV29pQlRZQ0NDQUFLQUlBSUFZZ0JXdHFMUUFBQlVFQUN5QUNkQ0FEY2lFRElBSkJFVWdoQnlBQ1FRaHFJZ1FoQWlBSERRQUxDeUFBSUFRZ0FXczJBaEFnQUNBRElBRjJOZ0lNSUFBZ0FDZ0NGQ0FCYWpZQ0ZDQURRWDhnQVhSQmYzTnhDOEVRQWc1L0FuMGdBaUFFYmlFVElBQW9BZ0FoRndKQUlBSkJBVVlFUUNBQUtBSWdJUU1nQUNnQ0hDRUNBa0FnRndSQUlBTkJCMG9FUUNBQ0lBRXFBZ0JEQUFBQUFGMGlEUkFnSUFBZ0FDZ0NJRUVJYXpZQ0lBc2dBQ2dDQkVVTkFTQUJRd0FBZ0w5REFBQ0FQeUFOR3pnQ0FBd0JDeUFEUVFoT0JFQWdBa0VCRUFraERTQUFJQUFvQWlCQkNHczJBaUFMSUFBb0FnUkZEUUFnQVVNQUFJQy9Rd0FBZ0Q4Z0RSczRBZ0FMUVFFaENpQUhSUTBCSUFjZ0FTb0NBRGdDQUVFQkR3c2dBQ2dDR0NJU1FRQktJUXNDUUNBRlJRUkFJQVVoQ1F3QkN5QUpSUVJBSUFVaENRd0JDd0pBSUJKQkFFb05BQ0FFUVFGS0RRQWdFMEVCY1VVZ0VrRUFSM0VOQUNBRklRa01BUXNnQ1NBRklBSkJBblFRQkJvTElCSkJBQ0FMR3lFUUFrQWdFa0VCU0EwQUlCZEZCRUFEUUFKQUlBbEZEUUFnREVFZlJnMEFJQUlnREhVaUJVRUNTQTBBUVFFZ0RIUWlFVUVCZENFT0lBVkJBWFVpQlVFQklBVkJBVW9iSVE5QkFDRU5BMEJCQUNFRkEwQWdDU0FGSUE1c0lBMXFRUUowYWlJTElBc3FBZ0JEOHdRMVA1UWlHaUFKSUFWQkFYUkJBWElnREhRZ0RXcEJBblJxSWdzcUFnQkQ4d1ExUDVRaUdaSTRBZ0FnQ3lBYUlCbVRPQUlBSUFWQkFXb2lCU0FQUncwQUN5QU5RUUZxSWcwZ0VVY05BQXNMSUFwQkQzRkIwRGxxTFFBQUlBcEJCSFZCMERscUxRQUFRUUowY2lFS0lBeEJBV29pRENBUVJ3MEFEQUlMQUFzRFFBSkFJQXhCSDBZaURnMEFJQUlnREhVaUJVRUNTQ0lQRFFCQkFTQU1kQ0lWUVFGMElSWWdCVUVCZFNJRlFRRWdCVUVCU2hzaEVVRUFJUTBEUUVFQUlRVURRQ0FCSUFVZ0Ztd2dEV3BCQW5ScUlnc2dDeW9DQUVQekJEVS9sQ0lhSUFFZ0JVRUJkRUVCY2lBTWRDQU5ha0VDZEdvaUN5b0NBRVB6QkRVL2xDSVpramdDQUNBTElCb2dHWk00QWdBZ0JVRUJhaUlGSUJGSERRQUxJQTFCQVdvaURTQVZSdzBBQ3lBSlJRMEFJQTROQUNBUERRQkJBQ0VOQTBCQkFDRUZBMEFnQ1NBRklCWnNJQTFxUVFKMGFpSUxJQXNxQWdCRDh3UTFQNVFpR2lBSklBVkJBWFJCQVhJZ0RIUWdEV3BCQW5ScUlnc3FBZ0JEOHdRMVA1UWlHWkk0QWdBZ0N5QWFJQm1UT0FJQUlBVkJBV29pQlNBUlJ3MEFDeUFOUVFGcUlnMGdGVWNOQUFzTElBcEJEM0ZCMERscUxRQUFJQXBCQkhWQjBEbHFMUUFBUVFKMGNpRUtJQXhCQVdvaURDQVFSdzBBQ3dzZ0JDQVFkU0VNQWtBQ1FDQVRJQkIwSWc5QkFYRU5BQ0FTUVg5S0RRQWdGd1JBSUJJaEVRTkFJQTlCQVhVaERnSkFJQXhCQVVnaUZRMEFJQTlCQWtnaUZnMEFJQXhCQVhRaEdDQU9RUUVnRGtFQlNoc2hFMEVBSVEwRFFFRUFJUVVEUUNBQklBVWdHR3dnRFdwQkFuUnFJZ3NnQ3lvQ0FFUHpCRFUvbENJYUlBRWdCVUVCZEVFQmNpQU1iQ0FOYWtFQ2RHb2lDeW9DQUVQekJEVS9sQ0laa2pnQ0FDQUxJQm9nR1pNNEFnQWdCVUVCYWlJRklCTkhEUUFMSUExQkFXb2lEU0FNUncwQUN5QUpSUTBBSUJVTkFDQVdEUUJCQUNFTkEwQkJBQ0VGQTBBZ0NTQUZJQmhzSUExcVFRSjBhaUlMSUFzcUFnQkQ4d1ExUDVRaUdpQUpJQVZCQVhSQkFYSWdER3dnRFdwQkFuUnFJZ3NxQWdCRDh3UTFQNVFpR1pJNEFnQWdDeUFhSUJtVE9BSUFJQVZCQVdvaUJTQVRSdzBBQ3lBTlFRRnFJZzBnREVjTkFBc0xJQlJCQVdvaEZDQU1RUUYwSVFzZ0NpQU1kQ0FLY2lFS0lBOUJBbkVOQXlBUlFYOUlJUVVnRVVFQmFpRVJJQXNoRENBT0lROGdCUTBBQ3d3Q0N5QUpRUUJIUVFGeklSTWdFaUVSQTBBZ0QwRUJkU0VPQWtBZ0RFRUJTQ0FUY2cwQUlBOUJBa2dOQUNBTVFRRjBJUlVnRGtFQklBNUJBVW9iSVJaQkFDRU5BMEJCQUNFRkEwQWdDU0FGSUJWc0lBMXFRUUowYWlJTElBc3FBZ0JEOHdRMVA1UWlHaUFKSUFWQkFYUkJBWElnREd3Z0RXcEJBblJxSWdzcUFnQkQ4d1ExUDVRaUdaSTRBZ0FnQ3lBYUlCbVRPQUlBSUFWQkFXb2lCU0FXUncwQUN5QU5RUUZxSWcwZ0RFY05BQXNMSUJSQkFXb2hGQ0FNUVFGMElRc2dDaUFNZENBS2NpRUtJQTlCQW5FTkFpQVJRWDlJSVFVZ0VVRUJhaUVSSUFzaERDQU9JUThnQlEwQUN3d0JDeUFQSVE0Z0RDRUxDeUFFUVFGR0lRUUNRQ0FMUVFKSURRQWdGd1JBSUFFZ0RpQVFkU0FMSUJCMElBUVFQQXNnQ1VVTkFDQUpJQTRnRUhVZ0N5QVFkQ0FFRUR3TElBQWdBU0FDSUFNZ0N5QUpJQVlnQ0NBS0VCRWhDaUFBS0FJRVJRMEFJQXRCQWs0RVFDQUJJQTRnRUhVZ0N5QVFkQ0FFRUdBTElCUUVRRUVBSVE4RFFDQU9RUUYwSVE0Z0NpQUxJZ0JCQVhVaUMzWWhCZ0pBSUFCQkFrZ05BQ0FPUVFKSURRQWdBRUYrY1NFRUlBNUJBWFVpQUVFQklBQkJBVW9iSVFOQkFDRUpBMEJCQUNFRkEwQWdBU0FFSUFWc0lBbHFRUUowYWlJQUlBQXFBZ0JEOHdRMVA1UWlHU0FCSUFWQkFYUkJBWElnQzJ3Z0NXcEJBblJxSWdBcUFnQkQ4d1ExUDVRaUNKSTRBZ0FnQUNBWklBaVRPQUlBSUFWQkFXb2lCU0FEUncwQUN5QUpRUUZxSWdrZ0MwY05BQXNMSUFZZ0NuSWhDaUFQUVFGcUlnOGdGRWNOQUFzTFFRQWhEQ0FTUVFCS0JFQURRQ0FLUWVBNWFpMEFBQ0VLQWtBZ0RFRWZSZzBBSUFJZ0RIVWlBRUVDU0EwQVFRRWdESFFpQmtFQmRDRUVJQUJCQVhVaUFFRUJJQUJCQVVvYklRTkJBQ0VKQTBCQkFDRUZBMEFnQVNBRUlBVnNJQWxxUVFKMGFpSUFJQUFxQWdCRDh3UTFQNVFpR1NBQklBVkJBWFJCQVhJZ0RIUWdDV3BCQW5ScUlnQXFBZ0JEOHdRMVA1UWlDSkk0QWdBZ0FDQVpJQWlUT0FJQUlBVkJBV29pQlNBRFJ3MEFDeUFKUVFGcUlna2dCa2NOQUFzTElBeEJBV29pRENBUVJ3MEFDd3NnQ3lBUWRDRURBa0FnQjBVTkFDQUNRUUZJRFFBZ0FyZWZ0aUVJUVFBaEJRTkFJQWNnQlVFQ2RDSUFhaUFBSUFGcUtnSUFJQWlVT0FJQUlBVkJBV29pQlNBQ1J3MEFDd3NnQ2tGL0lBTjBRWDl6Y1NFS0N5QUtDejhCQVg4Z0FDZ0NGRUVEZENBQUtBSWNJZ0JuSWdGQkEzUnFJQUJCRUNBQmEzWWlBQ0FBUVF4MklnQkJBblJCZ05rQmFpZ0NBRXRySUFCclFmZ0Jhd3RoQVFKL0l3QkJFR3NpQVNRQUlBQkJBV3RCQVUwRVFDQUJRZWpDQURZQ0RDQUJJQUVvQWd4QkEycEJmSEUyQWd3Z0FTZ0NERUdnUFNnQ0FFRUNkRUhnd0FCcUlBQnNRYVE5S0FJQVFRVjBhbXBCdEFGcUlRSUxJQUZCRUdva0FDQUNDMjhCQVg4akFFR0FBbXNpQlNRQUFrQWdBaUFEVEEwQUlBUkJnTUFFY1EwQUlBVWdBVUgvQVhFZ0FpQURheUlDUVlBQ0lBSkJnQUpKSWdFYkVBVWFJQUZGQkVBRFFDQUFJQVZCZ0FJUUVDQUNRWUFDYXlJQ1FmOEJTdzBBQ3dzZ0FDQUZJQUlRRUFzZ0JVR0FBbW9rQUF2cEFnRUJmd0pBSUFBZ0FVWU5BQ0FCSUFCcklBSnJRUUFnQWtFQmRHdE5CRUFnQUNBQklBSVFCQThMSUFBZ0FYTkJBM0VoQXdKQUFrQWdBQ0FCU1FSQUlBTUVRQ0FBSVFNTUF3c2dBRUVEY1VVRVFDQUFJUU1NQWdzZ0FDRURBMEFnQWtVTkJDQURJQUV0QUFBNkFBQWdBVUVCYWlFQklBSkJBV3NoQWlBRFFRRnFJZ05CQTNFTkFBc01BUXNDUUNBRERRQWdBQ0FDYWtFRGNRUkFBMEFnQWtVTkJTQUFJQUpCQVdzaUFtb2lBeUFCSUFKcUxRQUFPZ0FBSUFOQkEzRU5BQXNMSUFKQkEwME5BQU5BSUFBZ0FrRUVheUlDYWlBQklBSnFLQUlBTmdJQUlBSkJBMHNOQUFzTElBSkZEUUlEUUNBQUlBSkJBV3NpQW1vZ0FTQUNhaTBBQURvQUFDQUNEUUFMREFJTElBSkJBMDBOQUFOQUlBTWdBU2dDQURZQ0FDQUJRUVJxSVFFZ0EwRUVhaUVESUFKQkJHc2lBa0VEU3cwQUN3c2dBa1VOQUFOQUlBTWdBUzBBQURvQUFDQURRUUZxSVFNZ0FVRUJhaUVCSUFKQkFXc2lBZzBBQ3dzZ0FBdFZBUUovUVpENEFTZ0NBQ0lCSUFCQkEycEJmSEVpQW1vaEFBSkFJQUpCQVU1QkFDQUFJQUZOR3cwQVB3QkJFSFFnQUVrRVFDQUFFQUpGRFFFTFFaRDRBU0FBTmdJQUlBRVBDMEdjK3dGQk1EWUNBRUYvQ3hjQUlBQXRBQUJCSUhGRkJFQWdBU0FDSUFBUWpBRUxDODROQWd0L0FuMGpBRUVnYXlJTkpBQWdEU0FJTmdJWUlBMGdBellDSENBQUtBSUlJZ2tvQW1RaUNpQUpLQUpnSWdzZ0FDZ0NEQ0lQSUFrb0FnZ2dCa0VCYW14cVFRRjBhaTRCQUdvaERrRi9JUXdnQUNnQ0hDRVJJQUFvQWhRaEVpQUFLQUlBSVJNQ1FBSkFBa0FDUUFKQUFuOGdCa0YvUmdSQUlBb2dDeUFQUVFGMGFpNEJBR29pQ1MwQUFDSUdJQVpCQVdwQkFYWWlDaUFEUVFGcklnWWdDU0FLYWkwQUFFb2lBeHNpQ3lBTElBcEJBQ0FER3lJS2FrRUJha0VCZGlJRElBWWdBeUFKYWkwQUFFb2lDeHNpRHlBUElBTWdDaUFMR3lJS2FrRUJha0VCZGlJRElBWWdBeUFKYWkwQUFFb2lDeHNpRHlBUElBTWdDaUFMR3lJS2FrRUJha0VCZGlJRElBWWdBeUFKYWkwQUFFb2lDeHNpRHlBUElBTWdDaUFMR3lJS2FrRUJha0VCZFNJRElBWWdBeUFKYWkwQUFFb2lDeHNpRHlBUElBTWdDaUFMR3lJTGFrRUJha0VCZFNJRElBWWdBeUFKYWkwQUFFb2lEeHNoQ2lBRElBc2dEeHNpQ3dSQUlBa2dDMm90QUFBaERBdEJBQ0FLSUFzZ0JpQU1heUFKSUFwcUxRQUFJQVpyU2hzaUJrVU5BUm9nQmlBSmFpMEFBRUVCYWlFUUlBWU1BUXNnRGkwQUFDRUpJQUpCQTA0RVFDQUpJQTVxTFFBQVFReHFJQU5JRFFJTElBa2dDVUVCYWtFQmRpSUpJQU5CQVdzaUJpQUpJQTVxTFFBQVNpSURHeUlLSUFvZ0NVRUFJQU1iSWdscVFRRnFRUUYySWdNZ0JpQURJQTVxTFFBQVNpSUtHeUlMSUFzZ0F5QUpJQW9iSWdscVFRRnFRUUYySWdNZ0JpQURJQTVxTFFBQVNpSUtHeUlMSUFzZ0F5QUpJQW9iSWdscVFRRnFRUUYySWdNZ0JpQURJQTVxTFFBQVNpSUtHeUlMSUFzZ0F5QUpJQW9iSWdscVFRRnFRUUYxSWdNZ0JpQURJQTVxTFFBQVNpSUtHeUlMSUFzZ0F5QUpJQW9iSWdwcVFRRnFRUUYxSWdNZ0JpQURJQTVxTFFBQVNpSUxHeUVKSUFNZ0NpQUxHeUlLQkVBZ0NpQU9haTBBQUNFTUMwRUFJQWtnQ2lBR0lBeHJJQWtnRG1vdEFBQWdCbXRLR3lJR1JRMEFHaUFHSUE1cUxRQUFRUUZxSVJBZ0Jnc2hBeUFBSUFBb0FpQWdFR3NpQ1RZQ0lDQUpRWDlNRFFFZ0F5RUdEQUlMSUFaQkFXc2hBMEVCSVFrZ0FTQUNRUUYySWdKQkFuUnFJUTRDUUNBRVFRRkhCRUFnQUNBTklBRWdEaUFDSUExQkhHb2dCRUVCYWtFQmRTSUpJQVFnQTBFQUlBMUJHR29RSXd3QkN5QU5JQWhCQVhFZ0NFRUJkSEkyQWhnZ0FDQU5JQUVnRGlBQ0lBMUJIR3BCQVVFQklBTkJBQ0FOUVJocUVDTUxJQTBvQWhBaENDQU5LQUlJc2lFVUlBMG9BZ1N5SVJVZ0RTZ0NGQ0VRSUEwb0Fnd2hEQUpBSUFSQkFrZ05BQ0FJUWYvL0FIRkZEUUFnQ0VHQndBQk9CRUFnRENBTVFRVWdCbXQxYXlFTURBRUxJQXdnQWtFRGRFRUdJQVpyZFdvaUJrRWZkU0FHY1NFTUN5QVVRd0FBQURpVUlSUWdGVU1BQUFBNGxDRVZJQTBvQWh3aEJpQUFJQUFvQWlBZ0VHc2lFRFlDSUNBRklBSkJBblJxUVFBZ0JSc2hFU0FHSUFZZ0RHdEJBbTBpRENBR0lBeElHeUlNUVFBZ0RFRUFTaHNpRENBR0lBeHJJZ1pPQkVBZ0FDQUJJQUlnRENBSklBVWdBeUFWSUFlVUlBMG9BaGdpQVJBUklBQWdEaUFDSUFBb0FpQWdFR3NnREdvaUFFRVlhMEVBSUFCQkdFb2JRUUFnQ0JzZ0Jtb2dDU0FSSUFNZ0ZDQUhsQ0FCSUFsMUVCRWdCRUVCZFhSeUlRa01CQXNnQUNBT0lBSWdCaUFKSUJFZ0F5QVVJQWVVSUEwb0FoZ2lEaUFKZFJBUklSRWdBQ0FCSUFJZ0FDZ0NJQ0FRYXlBR2FpSUFRUmhyUVFBZ0FFRVlTaHRCQUNBSVFZQ0FBVWNiSUF4cUlBa2dCU0FESUJVZ0I1UWdEaEFSSUJFZ0JFRUJkWFJ5SVFrTUF3c2dBMEVCU0FSQUlBTWhCZ3dCQ3dOQUlBQWdDU0FRYWlJSk5nSWdJQU5CQVdzaUJrVUVRQ0FBSUFrMkFpQU1Bd3NnQUNBSklBWWdEbW90QUFCQkFXb2lFR3NpQ1RZQ0lDQUpRWDlLRFFFZ0EwRUJTaUVNSUFZaEF5QU1EUUFMQ3lBR1JRMEFJQVpCQ0U0RVFDQUdRUWR4UVFoeUlBWkJBM1pCQVd0MElRWUxJQk1FUUNBQklBSWdCaUFTSUFRZ0VTQUhJQUFvQWdRZ0FDZ0NMQkNZQVNFSkRBSUxJQUVnQWlBR0lCSWdCQ0FSSUFjUWxnRWhDUXdCQ3lBQUtBSUVSUVJBUVFBaENRd0JDeUFOUVg4Z0JIUkJmM01pQ1NBSWNTSUVOZ0lZSUFSRkJFQkJBQ0VKSUFGQkFDQUNRUUowRUFVYURBRUxBa0FnQlFSQUlBSkJBVTRFUUNBQUtBSW9JUU5CQUNFR0EwQWdBU0FHUVFKMElnaHFJQVVnQ0dvcUFnQkRBQUNBTzBNQUFJQzdJQU5CamN6bEFHeEIzK2E3NHdOcUlnTkJnSUFDY1J1U09BSUFJQVpCQVdvaUJpQUNSdzBBQ3lBQUlBTTJBaWdMSUFRaENRd0JDeUFDUVFGSURRQWdBQ2dDS0NFRFFRQWhCZ05BSUFFZ0JrRUNkR29nQTBHTnpPVUFiRUhmNXJ2akEyb2lBMEVVZGJJNEFnQWdCa0VCYWlJR0lBSkhEUUFMSUFBZ0F6WUNLQXNnQVNBQ0lBY2dBQ2dDTEJBdUN5QU5RU0JxSkFBZ0NRdXJBZ0lGZndGOUlBQW9BaXdnQm13aENpQUFLQUlnSWdzZ0JVRUJkR291QVFBZ0Jtd2hBQ0FIUVFGSEJFQWdBQ0FLSUFkdElnY2dBQ0FIU0JzaEFBdEJBQ0FGSUFnYklRd2dDMEVBSUFRZ0NCc2lCRUVCZEdvdUFRQWlEU0FHYkNJSlFRSjBJUWNnQWlFRklBbEJBVTRFUUNBQ1FRQWdCeEFGSUFkcUlRVUxRUUFnQUNBSUd5RUpJQVFnREVnRVFDQUJJQWRxSVFnRFFDQURJQVJCQW5RaUFHb3FBZ0FnQUVIQTJRRnFLZ0lBa2tNQUFBQkNscnRFN3puNi9rSXU1aitpRUIrMklRNGdCaUFOYkNFQUlBc2dCRUVCYWlJRVFRRjBhaTRCQUNJTklBWnNJUUVEUUNBRklBZ3FBZ0FnRHBRNEFnQWdCVUVFYWlFRklBaEJCR29oQ0NBQVFRRnFJZ0FnQVVnTkFBc2dCQ0FNUncwQUN3c2dBaUFKUVFKMGFrRUFJQW9nQ1d0QkFuUVFCUm9MZ3hnREYzOEJmUUY4SXdCQndBRnJJZ1lrQUNBR1FRQTJBb2dCUVg0aEJRSkFJQUFvQWd3aUZVRXliU0lQUVFOMUloQWdCRW9OQUNBQUtBSUFJUm9nQUNnQ0JDRUlJQTlCQW5VaERDQVBRUUYxSVFzZ0JDQVZRUmx0UVFOc0lnVWdCQ0FGU0JzaEJRSkFBbjhDUUFKQUFrQWdCZ0ovQWtBQ1FBSkFBa0FDUUFKQUFrQWdBa0VCVEFSQUlBVWdBQ2dDUUNJQklBRWdCVW9iSVFVTUFRc2dBUTBCQ3lBQUtBSThJZ1JGQkVBZ0FDZ0NDQ0FGYkNJQVFRRklEUTBnQTBFQUlBQkJBblFRQlJvTURRc2dCU0FQU2dSQUlBVWhCQU5BSUFCQkFFRUFJQU1nQkNBUElBUWdEMGdiRUJNaUFVRUFTQVJBSUFFaEJRd1BDeUFESUFBb0FnZ2dBV3hCQW5ScUlRTWdCQ0FCYXlJRVFRQktEUUFMREEwTElBVWdEMDROQVVFQklSRWdCU0FMU2dSQUlBc2hDUXdFQ3lBRVFlZ0hSZ1JBUVFBaEFVSG9CeUVFSUFVaENRd0dDeUFNSUFVZ0JTQUxTQnNnQlNBRklBeEtHeUVKREFNTElBQW9BalFoRkNBQUtBSTRJUVFnQUNnQ1FDRUpJQVpCa0FGcUlBRWdBaEJUUVFFaERTQUFLQUk4SWdwQkFVZ0VRRUVCSVJFTUJBc0NRQUpBQWtBZ0NrSHFCMFlOQUNBRVFlb0hSdzBBSUFBb0FrUkZEUUVMSUFSQjZnZEdCRUJCNmdjaEJFRUJJUkVNQmdzZ0NrSHFCMFlOQVVFQklSRU1CUXNnQkVIcUIwWU5BZ3NnQUNnQ0NDQU1iQ0VSUVFFaEZ3d0RDeUFFUWVvSFJ3UkFRUUVoRVVFQUlRRWdCU0VKREFRTElBWkJFR3NpQ3lJWUpBQkJBU0VSSUFVaENVRUFJUUZCQVNFU0RBVUxJQVlnQUNnQ0NDQU1iRUVDZEVFUGFrRndjV3NpQ2lJRUpBQWdBRUVBUVFBZ0NpQU1JQWtnQ1NBTVNoc1FFeG9nQlNBSlNDRUxRWDhoQlNBTERRZ2dCRUVRYXlJTEloZ2tBRUVCSVJkQkFTRVJRUUVoRWd3RUMwRUFJUUVMSUFVZ0NVZ2hDa0YvSVFVZ0NnMEdRZW9ISVJOQkFTRVNRUUVnQkVIcUIwWU5BUm9MUVFBaEVpQUVJUk1nQUNnQ0NDQUxJQWtnQ1NBTFNCdHNDMEVCZEVFUGFrRndjV3NpQ3lJWUpBQkJBQ0VLSUJOQjZnZEhJZzROQVF0QjZnY2hFMEVBSVE0TUFRc2dBQ0FJYWlFS0lBQW9BanhCNmdkR0JFQWdDaEJFR2dzZ0FDQUpRZWdIYkNBQUtBSU1iU0lFUVFvZ0JFRUtTaHMyQWlBZ0RRUkFJQUFnQUNnQ01EWUNGRUdBL1FBaEJBSkFJQk5CNkFkSERRQWdGRUhOQ0dzaUJVRUNTdzBBSUFWQm9COXNRY0ErYWlFRUN5QUFJQVEyQWh3TElBQkJFR29oRmtFQUlRUUNRQ0FCUlNJWlJRUkFJQXNoQlFOQUlBb2dGa0VBSUFSRklBWkJrQUZxSUFVZ0JrR01BV29nQUNnQ0xCQkRCRUJCZlNFRkRBWUxJQVVnQmlnQ2pBRWlDQ0FBS0FJSWJFRUJkR29oQlNBRUlBaHFJZ1FnQ1VnTkFBc01BUXNnQ3lFRkEwQUNRQ0FLSUJZZ0dTQUVSU0FHUVpBQmFpQUZJQVpCakFGcUlBQW9BaXdRUTBVRVFDQUdLQUtNQVNJSUlBQW9BZ2hzSVFjTUFRc2dCaUFKTmdLTUFTQUFLQUlJSUFsc0lnZEJBVTRFUUNBRlFRQWdCMEVCZEJBRkdnc2dDU0VJQ3lBRklBZEJBWFJxSVFVZ0JDQUlhaUlFSUFsSURRQUxDMEVBSVFwQkVTRVpJQTFCQVhGRkRRQWdCaWdDcEFFZ0JpZ0NyQUZuYWtFVVFRQWdBQ2dDT0VIcEIwWWJha0VQYXlBQ1FRTjBTZzBBQWtBZ0UwSHBCMFlFUUNBR1FaQUJha0VNRUFZaUNFVUVRRUhwQnlFVERBTUxJQVpCa0FGcVFRRVFCaUVISUFaQmtBRnFRWUFDRUJaQkFtb2hCQ0FHS0FLc0FXY2hCU0FHS0FLa0FTRU5EQUVMUVFFaENDQUdRWkFCYWtFQkVBWWhCeUFDSUFZb0FxUUJJZzBnQmlnQ3JBRm5JZ1ZxUVJsclFRTjFheUVFQ3lBR0lBWW9BcFFCUVFBZ0JDQUZJQTFxUVNCcklBSWdCR3NpQWtFRGRFb2lCQnNpRFdzMkFwUUJRUUFnQWlBRUd5RUNRUUFnQ0NBRUd3d0JDMEVBSVExQkFDRUhRUUFMSWhaRkloc2dGM0VoRnlBWVFRRWdFU0FXRzBFQ2RFRVBha0Z3Y1dzaUJDSUlKQUFDUUNBT1JRMEFJQmRGRFFBZ0FFRUFRUUFnQkNBTUlBa2dDU0FNU2hzUUV4b2dCQ0VLQ3lBQUlCcHFJUVFDUUFKQUFrQUNRQUpBQWtBZ0ZFSE5DR3NPQkFBQkFRSURDMEVOSVFVTUF3dEJFU0VGREFJTFFSTWhCUXdCQzBFVklRVWdGRVVOQVFzZ0JpQUZOZ0tBQVVGOUlRVWdCRUdjemdBZ0JrR0FBV29RQncwQkN5QUdJQUFvQWpBMkFuQkJmU0VGSUFSQm1NNEFJQVpCOEFCcUVBY05BQUovSUJaRkJFQkJBQ0VPSUFoQkVHc2lDQ1FBSUFkQkFFY01BUXNnQ0NBQUtBSUlJQXhzUVFKMFFROXFRWEJ4YXlJSUpBQWdCMFVFUUVFQUlRNUJBQXdCQ3lBR1FRQTJBbUFnQkVHYXpnQWdCa0hnQUdvUUJ3MEJJQVFnQVNBQ2FpQU5JQWdnREVFQUVCZ2FJQVlnQmtHSUFXbzJBbEFnQkVHL0h5QUdRZEFBYWhBSERRRkJBU0VPUVFFTElSRWdCaUFaTmdKQUlBUkJtczRBSUFaQlFHc1FCdzBBQW44Z0UwSG9CMGNFUUFKQUlCTWdBQ2dDUENJSFJnMEFJQWRCQVVnTkFDQUFLQUpFRFFBZ0JFRzhIMEVBRUFjTkF3c2dCQ0FCSUFJZ0F5QVBJQWtnQ1NBUFNoc2dCa0dRQVdvUUdBd0JDeUFHUWYvL0F6c0JoQUVnQUNnQ0NDQUpiQ0lIUVFGT0JFQWdBMEVBSUFkQkFuUVFCUm9MQWtBZ0FDZ0NQRUhwQjBjTkFDQU9CRUFnQUNnQ1JBMEJDeUFHUVFBMkFqQWdCRUdhemdBZ0JrRXdhaEFIRFFJZ0JDQUdRWVFCYWtFQ0lBTWdFRUVBRUJnYUMwRUFDeUVQQWtBZ0VnMEFJQUFvQWdnZ0NXd2lFa0VCU0EwQVFRQWhCd05BSUFNZ0IwRUNkR29pRkNBVUtnSUFJQXNnQjBFQmRHb3VBUUN5UXdBQUFEaVVramdDQUNBSFFRRnFJZ2NnRWtjTkFBc0xJQVlnQmtHRUFXbzJBaUFnQkVHZnpnQWdCa0VnYWhBSERRQWdCaWdDaEFFb0Fqd2hDd0pBSUJFZ0czSU5BQ0FFUWJ3ZlFRQVFCdzBCSUFaQkFEWUNFQ0FFUVpyT0FDQUdRUkJxRUFjTkFVRUFJUWNnQkNBQklBSnFJQTBnQ0NBTVFRQVFHQm9nQmlBR1FZZ0JhallDQUNBRVFiOGZJQVlRQncwQlFZRDNBaUFBS0FJTWJTRUZJQlZCa0FOSURRQWdBQ2dDQ0NJQlFRRklEUUFnQ0NBQklCQnNRUUowYWlFTklBTWdBU0FKSUJCcmJFRUNkR29oRWdOQVFRQWhCQU5BSUJJZ0FTQUViQ0FIYWtFQ2RDSVVhaUlZSUFzZ0JDQUZiRUVDZEdvcUFnQWlIQ0FjbENJY0lBMGdGR29xQWdDVVF3QUFnRDhnSEpNZ0dDb0NBSlNTT0FJQUlBUkJBV29pQkNBUVJ3MEFDeUFIUVFGcUlnY2dBVWNOQUFzTEFrQWdEa1VOQUFKQUlBQW9BZ2dpQlVFQlNBMEFJQlZCa0FOSURRQWdCVUVCSUFWQkFVb2JJUWNnRUVFQklCQkJBVW9iSVE1QkFDRUJBMEJCQUNFRUEwQWdBeUFFSUFWc0lBRnFRUUowSWcxcUlBZ2dEV29xQWdBNEFnQWdCRUVCYWlJRUlBNUhEUUFMSUFGQkFXb2lBU0FIUncwQUN3dEJnUGNDSUFBb0FneHRJUWNnRlVHUUEwZ05BQ0FGUVFGSURRQWdBeUFGSUJCc1FRSjBJZ0ZxSVE0Z0FTQUlhaUVJUVFBaEFRTkFRUUFoQkFOQUlBNGdCQ0FGYkNBQmFrRUNkQ0lOYWlJU0lBc2dCQ0FIYkVFQ2RHb3FBZ0FpSENBY2xDSWNJQklxQWdDVVF3QUFnRDhnSEpNZ0NDQU5haW9DQUpTU09BSUFJQVJCQVdvaUJDQVFSdzBBQ3lBQlFRRnFJZ0VnQlVjTkFBc0xBa0FnRjBVTkFDQUFLQUlJSVFVZ0NTQU1UZ1JBSUFVZ0VHd2lBVUVCVGdSQVFRQWhCQU5BSUFNZ0JFRUNkQ0lJYWlBSUlBcHFLZ0lBT0FJQUlBUkJBV29pQkNBQlJ3MEFDd3RCZ1BjQ0lBQW9BZ3h0SVFnZ0ZVR1FBMGdOQVNBRlFRRklEUUVnQXlBQlFRSjBJZ0ZxSVFjZ0FTQUthaUVCUVFBaENnTkFRUUFoQkFOQUlBY2dCQ0FGYkNBS2FrRUNkQ0lNYWlJT0lBc2dCQ0FJYkVFQ2RHb3FBZ0FpSENBY2xDSWNJQTRxQWdDVVF3QUFnRDhnSEpNZ0FTQU1haW9DQUpTU09BSUFJQVJCQVdvaUJDQVFSdzBBQ3lBS1FRRnFJZ29nQlVjTkFBc01BUXRCZ1BjQ0lBQW9BZ3h0SVFnZ0ZVR1FBMGdOQUNBRlFRRklEUUJCQUNFQkEwQkJBQ0VFQTBBZ0F5QUVJQVZzSUFGcVFRSjBJZ2RxSWd3Z0N5QUVJQWhzUVFKMGFpb0NBQ0ljSUJ5VUlod2dEQ29DQUpSREFBQ0FQeUFja3lBSElBcHFLZ0lBbEpJNEFnQWdCRUVCYWlJRUlCQkhEUUFMSUFGQkFXb2lBU0FGUncwQUN3c0NRQ0FBS0FJb0lnRkZEUUFnQUNnQ0NDRUVJQUd5UXkwVktqcVV1MFR2T2ZyK1FpN21QNklRSHlFZElBUWdDV3dpQVVFQlNBMEFJQjIySVJ4QkFDRUVBMEFnQXlBRVFRSjBhaUlGSUFVcUFnQWdISlE0QWdBZ0JFRUJhaUlFSUFGSERRQUxDeUFHS0FLSUFTRUJJQVlvQXF3QklRTWdBQ0FUTmdJOElBQWdFVUVCY3lBV1FRQkhjVFlDUkNBQVFRQWdBU0FEY3lBQ1FRSklHellDVkNBUElBa2dEMEVBU0JzaEJRc0xJQVpCd0FGcUpBQWdCUXVvQVFBQ1FDQUJRWUFJVGdSQUlBQkVBQUFBQUFBQTRIK2lJUUFnQVVIL0QwZ0VRQ0FCUWY4SGF5RUJEQUlMSUFCRUFBQUFBQUFBNEgraUlRQWdBVUg5RnlBQlFmMFhTQnRCL2c5cklRRU1BUXNnQVVHQmVFb05BQ0FBUkFBQUFBQUFBQkFBb2lFQUlBRkJnM0JLQkVBZ0FVSCtCMm9oQVF3QkN5QUFSQUFBQUFBQUFCQUFvaUVBSUFGQmhtZ2dBVUdHYUVvYlFmd1BhaUVCQ3lBQUlBRkIvd2RxclVJMGhyK2lDOUF1QVF4L0l3QkJFR3NpRENRQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBSUFCQjlBRk5CRUJCb1BzQktBSUFJZ1ZCRUNBQVFRdHFRWGh4SUFCQkMwa2JJZ2hCQTNZaUFuWWlBVUVEY1FSQUlBRkJmM05CQVhFZ0Ftb2lBMEVEZENJQlFkRDdBV29vQWdBaUJFRUlhaUVBQWtBZ0JDZ0NDQ0lDSUFGQnlQc0JhaUlCUmdSQVFhRDdBU0FGUVg0Z0EzZHhOZ0lBREFFTFFiRDdBU2dDQUJvZ0FpQUJOZ0lNSUFFZ0FqWUNDQXNnQkNBRFFRTjBJZ0ZCQTNJMkFnUWdBU0FFYWlJQklBRW9BZ1JCQVhJMkFnUU1EUXNnQ0VHbyt3RW9BZ0FpQ2swTkFTQUJCRUFDUUVFQ0lBSjBJZ0JCQUNBQWEzSWdBU0FDZEhFaUFFRUFJQUJyY1VFQmF5SUFJQUJCREhaQkVIRWlBbllpQVVFRmRrRUljU0lBSUFKeUlBRWdBSFlpQVVFQ2RrRUVjU0lBY2lBQklBQjJJZ0ZCQVhaQkFuRWlBSElnQVNBQWRpSUJRUUYyUVFGeElnQnlJQUVnQUhacUlnTkJBM1FpQUVIUSt3RnFLQUlBSWdRb0FnZ2lBU0FBUWNqN0FXb2lBRVlFUUVHZyt3RWdCVUYrSUFOM2NTSUZOZ0lBREFFTFFiRDdBU2dDQUJvZ0FTQUFOZ0lNSUFBZ0FUWUNDQXNnQkVFSWFpRUFJQVFnQ0VFRGNqWUNCQ0FFSUFocUlnSWdBMEVEZENJQklBaHJJZ05CQVhJMkFnUWdBU0FFYWlBRE5nSUFJQW9FUUNBS1FRTjJJZ0ZCQTNSQnlQc0JhaUVIUWJUN0FTZ0NBQ0VFQW44Z0JVRUJJQUYwSWdGeFJRUkFRYUQ3QVNBQklBVnlOZ0lBSUFjTUFRc2dCeWdDQ0FzaEFTQUhJQVEyQWdnZ0FTQUVOZ0lNSUFRZ0J6WUNEQ0FFSUFFMkFnZ0xRYlQ3QVNBQ05nSUFRYWo3QVNBRE5nSUFEQTBMUWFUN0FTZ0NBQ0lHUlEwQklBWkJBQ0FHYTNGQkFXc2lBQ0FBUVF4MlFSQnhJZ0oySWdGQkJYWkJDSEVpQUNBQ2NpQUJJQUIySWdGQkFuWkJCSEVpQUhJZ0FTQUFkaUlCUVFGMlFRSnhJZ0J5SUFFZ0FIWWlBVUVCZGtFQmNTSUFjaUFCSUFCMmFrRUNkRUhRL1FGcUtBSUFJZ0VvQWdSQmVIRWdDR3NoQkNBQklRSURRQUpBSUFJb0FoQWlBRVVFUUNBQ0tBSVVJZ0JGRFFFTElBQW9BZ1JCZUhFZ0NHc2lBaUFFSUFJZ0JFa2lBaHNoQkNBQUlBRWdBaHNoQVNBQUlRSU1BUXNMSUFFZ0NHb2lDU0FCVFEwQ0lBRW9BaGdoQ3lBQklBRW9BZ3dpQTBjRVFDQUJLQUlJSWdCQnNQc0JLQUlBVHdSQUlBQW9BZ3dhQ3lBQUlBTTJBZ3dnQXlBQU5nSUlEQXdMSUFGQkZHb2lBaWdDQUNJQVJRUkFJQUVvQWhBaUFFVU5CQ0FCUVJCcUlRSUxBMEFnQWlFSElBQWlBMEVVYWlJQ0tBSUFJZ0FOQUNBRFFSQnFJUUlnQXlnQ0VDSUFEUUFMSUFkQkFEWUNBQXdMQzBGL0lRZ2dBRUcvZjBzTkFDQUFRUXRxSWdCQmVIRWhDRUdrK3dFb0FnQWlDVVVOQUVFZklRVkJBQ0FJYXlFRUFrQUNRQUpBQW44Z0NFSC8vLzhIVFFSQUlBQkJDSFlpQUNBQVFZRCtQMnBCRUhaQkNIRWlBblFpQUNBQVFZRGdIMnBCRUhaQkJIRWlBWFFpQUNBQVFZQ0FEMnBCRUhaQkFuRWlBSFJCRDNZZ0FTQUNjaUFBY21zaUFFRUJkQ0FJSUFCQkZXcDJRUUZ4Y2tFY2FpRUZDeUFGUVFKMFFkRDlBV29vQWdBaUFrVUxCRUJCQUNFQURBRUxRUUFoQUNBSVFRQkJHU0FGUVFGMmF5QUZRUjlHRzNRaEFRTkFBa0FnQWlnQ0JFRjRjU0FJYXlJSElBUlBEUUFnQWlFRElBY2lCQTBBUVFBaEJDQUNJUUFNQXdzZ0FDQUNLQUlVSWdjZ0J5QUNJQUZCSFhaQkJIRnFLQUlRSWdKR0d5QUFJQWNiSVFBZ0FVRUJkQ0VCSUFJTkFBc0xJQUFnQTNKRkJFQkJBaUFGZENJQVFRQWdBR3R5SUFseElnQkZEUU1nQUVFQUlBQnJjVUVCYXlJQUlBQkJESFpCRUhFaUFuWWlBVUVGZGtFSWNTSUFJQUp5SUFFZ0FIWWlBVUVDZGtFRWNTSUFjaUFCSUFCMklnRkJBWFpCQW5FaUFISWdBU0FBZGlJQlFRRjJRUUZ4SWdCeUlBRWdBSFpxUVFKMFFkRDlBV29vQWdBaEFBc2dBRVVOQVFzRFFDQUFLQUlFUVhoeElBaHJJZ0VnQkVraEFpQUJJQVFnQWhzaEJDQUFJQU1nQWhzaEF5QUFLQUlRSWdFRWZ5QUJCU0FBS0FJVUN5SUFEUUFMQ3lBRFJRMEFJQVJCcVBzQktBSUFJQWhyVHcwQUlBTWdDR29pQmlBRFRRMEJJQU1vQWhnaEJTQURJQU1vQWd3aUFVY0VRQ0FES0FJSUlnQkJzUHNCS0FJQVR3UkFJQUFvQWd3YUN5QUFJQUUyQWd3Z0FTQUFOZ0lJREFvTElBTkJGR29pQWlnQ0FDSUFSUVJBSUFNb0FoQWlBRVVOQkNBRFFSQnFJUUlMQTBBZ0FpRUhJQUFpQVVFVWFpSUNLQUlBSWdBTkFDQUJRUkJxSVFJZ0FTZ0NFQ0lBRFFBTElBZEJBRFlDQUF3SkN5QUlRYWo3QVNnQ0FDSUNUUVJBUWJUN0FTZ0NBQ0VEQWtBZ0FpQUlheUlCUVJCUEJFQkJxUHNCSUFFMkFnQkJ0UHNCSUFNZ0NHb2lBRFlDQUNBQUlBRkJBWEkyQWdRZ0FpQURhaUFCTmdJQUlBTWdDRUVEY2pZQ0JBd0JDMEcwK3dGQkFEWUNBRUdvK3dGQkFEWUNBQ0FESUFKQkEzSTJBZ1FnQWlBRGFpSUFJQUFvQWdSQkFYSTJBZ1FMSUFOQkNHb2hBQXdMQ3lBSVFhejdBU2dDQUNJR1NRUkFRYXo3QVNBR0lBaHJJZ0UyQWdCQnVQc0JRYmo3QVNnQ0FDSUNJQWhxSWdBMkFnQWdBQ0FCUVFGeU5nSUVJQUlnQ0VFRGNqWUNCQ0FDUVFocUlRQU1Dd3RCQUNFQUlBaEJMMm9pQ1FKL1FmaitBU2dDQUFSQVFZRC9BU2dDQUF3QkMwR0Uvd0ZDZnpjQ0FFSDgvZ0ZDZ0tDQWdJQ0FCRGNDQUVINC9nRWdERUVNYWtGd2NVSFlxdFdxQlhNMkFnQkJqUDhCUVFBMkFnQkIzUDRCUVFBMkFnQkJnQ0FMSWdGcUlnVkJBQ0FCYXlJSGNTSUNJQWhORFFwQjJQNEJLQUlBSWdRRVFFSFEvZ0VvQWdBaUF5QUNhaUlCSUFOTkRRc2dBU0FFU3cwTEMwSGMvZ0V0QUFCQkJIRU5CUUpBQWtCQnVQc0JLQUlBSWdNRVFFSGcvZ0VoQUFOQUlBTWdBQ2dDQUNJQlR3UkFJQUVnQUNnQ0JHb2dBMHNOQXdzZ0FDZ0NDQ0lBRFFBTEMwRUFFQThpQVVGL1JnMEdJQUloQlVIOC9nRW9BZ0FpQTBFQmF5SUFJQUZ4QkVBZ0FpQUJheUFBSUFGcVFRQWdBMnR4YWlFRkN5QUZJQWhORFFZZ0JVSCsvLy8vQjBzTkJrSFkvZ0VvQWdBaUJBUkFRZEQrQVNnQ0FDSURJQVZxSWdBZ0EwME5CeUFBSUFSTERRY0xJQVVRRHlJQUlBRkhEUUVNQ0FzZ0JTQUdheUFIY1NJRlFmNy8vLzhIU3cwRklBVVFEeUlCSUFBb0FnQWdBQ2dDQkdwR0RRUWdBU0VBQ3dKQUlBaEJNR29nQlUwTkFDQUFRWDlHRFFCQmdQOEJLQUlBSWdFZ0NTQUZhMnBCQUNBQmEzRWlBVUgrLy8vL0Iwc0VRQ0FBSVFFTUNBc2dBUkFQUVg5SEJFQWdBU0FGYWlFRklBQWhBUXdJQzBFQUlBVnJFQThhREFVTElBQWlBVUYvUncwR0RBUUxBQXRCQUNFRERBY0xRUUFoQVF3RkN5QUJRWDlIRFFJTFFkeitBVUhjL2dFb0FnQkJCSEkyQWdBTElBSkIvdi8vL3dkTERRRWdBaEFQSWdGQkFCQVBJZ0JQRFFFZ0FVRi9SZzBCSUFCQmYwWU5BU0FBSUFGcklnVWdDRUVvYWswTkFRdEIwUDRCUWREK0FTZ0NBQ0FGYWlJQU5nSUFRZFQrQVNnQ0FDQUFTUVJBUWRUK0FTQUFOZ0lBQ3dKQUFrQUNRRUc0K3dFb0FnQWlCd1JBUWVEK0FTRUFBMEFnQVNBQUtBSUFJZ01nQUNnQ0JDSUNha1lOQWlBQUtBSUlJZ0FOQUFzTUFndEJzUHNCS0FJQUlnQkJBQ0FBSUFGTkcwVUVRRUd3K3dFZ0FUWUNBQXRCQUNFQVFlVCtBU0FGTmdJQVFlRCtBU0FCTmdJQVFjRDdBVUYvTmdJQVFjVDdBVUg0L2dFb0FnQTJBZ0JCN1A0QlFRQTJBZ0FEUUNBQVFRTjBJZ05CMFBzQmFpQURRY2o3QVdvaUFqWUNBQ0FEUWRUN0FXb2dBallDQUNBQVFRRnFJZ0JCSUVjTkFBdEJyUHNCSUFWQktHc2lBMEY0SUFGclFRZHhRUUFnQVVFSWFrRUhjUnNpQUdzaUFqWUNBRUc0K3dFZ0FDQUJhaUlBTmdJQUlBQWdBa0VCY2pZQ0JDQUJJQU5xUVNnMkFnUkJ2UHNCUVlqL0FTZ0NBRFlDQUF3Q0N5QUFMUUFNUVFoeERRQWdBU0FIVFEwQUlBTWdCMHNOQUNBQUlBSWdCV28yQWdSQnVQc0JJQWRCZUNBSGEwRUhjVUVBSUFkQkNHcEJCM0ViSWdCcUlnSTJBZ0JCclBzQlFhejdBU2dDQUNBRmFpSUJJQUJySWdBMkFnQWdBaUFBUVFGeU5nSUVJQUVnQjJwQktEWUNCRUc4K3dGQmlQOEJLQUlBTmdJQURBRUxRYkQ3QVNnQ0FDSURJQUZMQkVCQnNQc0JJQUUyQWdBZ0FTRURDeUFCSUFWcUlRSkI0UDRCSVFBQ1FBSkFBa0FDUUFKQUFrQURRQ0FDSUFBb0FnQkhCRUFnQUNnQ0NDSUFEUUVNQWdzTElBQXRBQXhCQ0hGRkRRRUxRZUQrQVNFQUEwQWdCeUFBS0FJQUlnSlBCRUFnQWlBQUtBSUVhaUlFSUFkTERRTUxJQUFvQWdnaEFBd0FDd0FMSUFBZ0FUWUNBQ0FBSUFBb0FnUWdCV28yQWdRZ0FVRjRJQUZyUVFkeFFRQWdBVUVJYWtFSGNSdHFJZ2tnQ0VFRGNqWUNCQ0FDUVhnZ0FtdEJCM0ZCQUNBQ1FRaHFRUWR4RzJvaUJTQUpheUFJYXlFQ0lBZ2dDV29oQmlBRklBZEdCRUJCdVBzQklBWTJBZ0JCclBzQlFhejdBU2dDQUNBQ2FpSUFOZ0lBSUFZZ0FFRUJjallDQkF3REN5QUZRYlQ3QVNnQ0FFWUVRRUcwK3dFZ0JqWUNBRUdvK3dGQnFQc0JLQUlBSUFKcUlnQTJBZ0FnQmlBQVFRRnlOZ0lFSUFBZ0Jtb2dBRFlDQUF3REN5QUZLQUlFSWdCQkEzRkJBVVlFUUNBQVFYaHhJUWNDUUNBQVFmOEJUUVJBSUFVb0FnZ2lBeUFBUVFOMklnQkJBM1JCeVBzQmFrY2FJQU1nQlNnQ0RDSUJSZ1JBUWFEN0FVR2crd0VvQWdCQmZpQUFkM0UyQWdBTUFnc2dBeUFCTmdJTUlBRWdBellDQ0F3QkN5QUZLQUlZSVFnQ1FDQUZJQVVvQWd3aUFVY0VRQ0FGS0FJSUlnQWdBMDhFUUNBQUtBSU1HZ3NnQUNBQk5nSU1JQUVnQURZQ0NBd0JDd0pBSUFWQkZHb2lBQ2dDQUNJRURRQWdCVUVRYWlJQUtBSUFJZ1FOQUVFQUlRRU1BUXNEUUNBQUlRTWdCQ0lCUVJScUlnQW9BZ0FpQkEwQUlBRkJFR29oQUNBQktBSVFJZ1FOQUFzZ0EwRUFOZ0lBQ3lBSVJRMEFBa0FnQlNBRktBSWNJZ05CQW5SQjBQMEJhaUlBS0FJQVJnUkFJQUFnQVRZQ0FDQUJEUUZCcFBzQlFhVDdBU2dDQUVGK0lBTjNjVFlDQUF3Q0N5QUlRUkJCRkNBSUtBSVFJQVZHRzJvZ0FUWUNBQ0FCUlEwQkN5QUJJQWcyQWhnZ0JTZ0NFQ0lBQkVBZ0FTQUFOZ0lRSUFBZ0FUWUNHQXNnQlNnQ0ZDSUFSUTBBSUFFZ0FEWUNGQ0FBSUFFMkFoZ0xJQVVnQjJvaEJTQUNJQWRxSVFJTElBVWdCU2dDQkVGK2NUWUNCQ0FHSUFKQkFYSTJBZ1FnQWlBR2FpQUNOZ0lBSUFKQi93Rk5CRUFnQWtFRGRpSUFRUU4wUWNqN0FXb2hBZ0ovUWFEN0FTZ0NBQ0lCUVFFZ0FIUWlBSEZGQkVCQm9Qc0JJQUFnQVhJMkFnQWdBZ3dCQ3lBQ0tBSUlDeUVBSUFJZ0JqWUNDQ0FBSUFZMkFnd2dCaUFDTmdJTUlBWWdBRFlDQ0F3REMwRWZJUUFnQWtILy8vOEhUUVJBSUFKQkNIWWlBQ0FBUVlEK1AycEJFSFpCQ0hFaUEzUWlBQ0FBUVlEZ0gycEJFSFpCQkhFaUFYUWlBQ0FBUVlDQUQycEJFSFpCQW5FaUFIUkJEM1lnQVNBRGNpQUFjbXNpQUVFQmRDQUNJQUJCRldwMlFRRnhja0VjYWlFQUN5QUdJQUEyQWh3Z0JrSUFOd0lRSUFCQkFuUkIwUDBCYWlFRUFrQkJwUHNCS0FJQUlnTkJBU0FBZENJQmNVVUVRRUdrK3dFZ0FTQURjallDQUNBRUlBWTJBZ0FnQmlBRU5nSVlEQUVMSUFKQkFFRVpJQUJCQVhacklBQkJIMFliZENFQUlBUW9BZ0FoQVFOQUlBRWlBeWdDQkVGNGNTQUNSZzBESUFCQkhYWWhBU0FBUVFGMElRQWdBeUFCUVFSeGFpSUVLQUlRSWdFTkFBc2dCQ0FHTmdJUUlBWWdBellDR0FzZ0JpQUdOZ0lNSUFZZ0JqWUNDQXdDQzBHcyt3RWdCVUVvYXlJRFFYZ2dBV3RCQjNGQkFDQUJRUWhxUVFkeEd5SUFheUlDTmdJQVFiajdBU0FBSUFGcUlnQTJBZ0FnQUNBQ1FRRnlOZ0lFSUFFZ0EycEJLRFlDQkVHOCt3RkJpUDhCS0FJQU5nSUFJQWNnQkVFbklBUnJRUWR4UVFBZ0JFRW5hMEVIY1J0cVFTOXJJZ0FnQUNBSFFSQnFTUnNpQWtFYk5nSUVJQUpCNlA0QktRSUFOd0lRSUFKQjRQNEJLUUlBTndJSVFlaitBU0FDUVFocU5nSUFRZVQrQVNBRk5nSUFRZUQrQVNBQk5nSUFRZXorQVVFQU5nSUFJQUpCR0dvaEFBTkFJQUJCQnpZQ0JDQUFRUWhxSVFFZ0FFRUVhaUVBSUFFZ0JFa05BQXNnQWlBSFJnMERJQUlnQWlnQ0JFRitjVFlDQkNBSElBSWdCMnNpQkVFQmNqWUNCQ0FDSUFRMkFnQWdCRUgvQVUwRVFDQUVRUU4ySWdCQkEzUkJ5UHNCYWlFQ0FuOUJvUHNCS0FJQUlnRkJBU0FBZENJQWNVVUVRRUdnK3dFZ0FDQUJjallDQUNBQ0RBRUxJQUlvQWdnTElRQWdBaUFITmdJSUlBQWdCellDRENBSElBSTJBZ3dnQnlBQU5nSUlEQVFMUVI4aEFDQUhRZ0EzQWhBZ0JFSC8vLzhIVFFSQUlBUkJDSFlpQUNBQVFZRCtQMnBCRUhaQkNIRWlBblFpQUNBQVFZRGdIMnBCRUhaQkJIRWlBWFFpQUNBQVFZQ0FEMnBCRUhaQkFuRWlBSFJCRDNZZ0FTQUNjaUFBY21zaUFFRUJkQ0FFSUFCQkZXcDJRUUZ4Y2tFY2FpRUFDeUFISUFBMkFod2dBRUVDZEVIUS9RRnFJUU1DUUVHayt3RW9BZ0FpQWtFQklBQjBJZ0Z4UlFSQVFhVDdBU0FCSUFKeU5nSUFJQU1nQnpZQ0FDQUhJQU0yQWhnTUFRc2dCRUVBUVJrZ0FFRUJkbXNnQUVFZlJodDBJUUFnQXlnQ0FDRUJBMEFnQVNJQ0tBSUVRWGh4SUFSR0RRUWdBRUVkZGlFQklBQkJBWFFoQUNBQ0lBRkJCSEZxSWdNb0FoQWlBUTBBQ3lBRElBYzJBaEFnQnlBQ05nSVlDeUFISUFjMkFnd2dCeUFITmdJSURBTUxJQU1vQWdnaUFDQUdOZ0lNSUFNZ0JqWUNDQ0FHUVFBMkFoZ2dCaUFETmdJTUlBWWdBRFlDQ0FzZ0NVRUlhaUVBREFVTElBSW9BZ2dpQUNBSE5nSU1JQUlnQnpZQ0NDQUhRUUEyQWhnZ0J5QUNOZ0lNSUFjZ0FEWUNDQXRCclBzQktBSUFJZ0FnQ0UwTkFFR3Mrd0VnQUNBSWF5SUJOZ0lBUWJqN0FVRzQrd0VvQWdBaUFpQUlhaUlBTmdJQUlBQWdBVUVCY2pZQ0JDQUNJQWhCQTNJMkFnUWdBa0VJYWlFQURBTUxRWno3QVVFd05nSUFRUUFoQUF3Q0N3SkFJQVZGRFFBQ1FDQURLQUljSWdKQkFuUkIwUDBCYWlJQUtBSUFJQU5HQkVBZ0FDQUJOZ0lBSUFFTkFVR2srd0VnQ1VGK0lBSjNjU0lKTmdJQURBSUxJQVZCRUVFVUlBVW9BaEFnQTBZYmFpQUJOZ0lBSUFGRkRRRUxJQUVnQlRZQ0dDQURLQUlRSWdBRVFDQUJJQUEyQWhBZ0FDQUJOZ0lZQ3lBREtBSVVJZ0JGRFFBZ0FTQUFOZ0lVSUFBZ0FUWUNHQXNDUUNBRVFROU5CRUFnQXlBRUlBaHFJZ0JCQTNJMkFnUWdBQ0FEYWlJQUlBQW9BZ1JCQVhJMkFnUU1BUXNnQXlBSVFRTnlOZ0lFSUFZZ0JFRUJjallDQkNBRUlBWnFJQVEyQWdBZ0JFSC9BVTBFUUNBRVFRTjJJZ0JCQTNSQnlQc0JhaUVDQW45Qm9Qc0JLQUlBSWdGQkFTQUFkQ0lBY1VVRVFFR2crd0VnQUNBQmNqWUNBQ0FDREFFTElBSW9BZ2dMSVFBZ0FpQUdOZ0lJSUFBZ0JqWUNEQ0FHSUFJMkFnd2dCaUFBTmdJSURBRUxRUjhoQUNBRVFmLy8vd2ROQkVBZ0JFRUlkaUlBSUFCQmdQNC9ha0VRZGtFSWNTSUNkQ0lBSUFCQmdPQWZha0VRZGtFRWNTSUJkQ0lBSUFCQmdJQVBha0VRZGtFQ2NTSUFkRUVQZGlBQklBSnlJQUJ5YXlJQVFRRjBJQVFnQUVFVmFuWkJBWEZ5UVJ4cUlRQUxJQVlnQURZQ0hDQUdRZ0EzQWhBZ0FFRUNkRUhRL1FGcUlRSUNRQUpBSUFsQkFTQUFkQ0lCY1VVRVFFR2srd0VnQVNBSmNqWUNBQ0FDSUFZMkFnQWdCaUFDTmdJWURBRUxJQVJCQUVFWklBQkJBWFpySUFCQkgwWWJkQ0VBSUFJb0FnQWhDQU5BSUFnaUFTZ0NCRUY0Y1NBRVJnMENJQUJCSFhZaEFpQUFRUUYwSVFBZ0FTQUNRUVJ4YWlJQ0tBSVFJZ2dOQUFzZ0FpQUdOZ0lRSUFZZ0FUWUNHQXNnQmlBR05nSU1JQVlnQmpZQ0NBd0JDeUFCS0FJSUlnQWdCallDRENBQklBWTJBZ2dnQmtFQU5nSVlJQVlnQVRZQ0RDQUdJQUEyQWdnTElBTkJDR29oQUF3QkN3SkFJQXRGRFFBQ1FDQUJLQUljSWdKQkFuUkIwUDBCYWlJQUtBSUFJQUZHQkVBZ0FDQUROZ0lBSUFNTkFVR2srd0VnQmtGK0lBSjNjVFlDQUF3Q0N5QUxRUkJCRkNBTEtBSVFJQUZHRzJvZ0F6WUNBQ0FEUlEwQkN5QURJQXMyQWhnZ0FTZ0NFQ0lBQkVBZ0F5QUFOZ0lRSUFBZ0F6WUNHQXNnQVNnQ0ZDSUFSUTBBSUFNZ0FEWUNGQ0FBSUFNMkFoZ0xBa0FnQkVFUFRRUkFJQUVnQkNBSWFpSUFRUU55TmdJRUlBQWdBV29pQUNBQUtBSUVRUUZ5TmdJRURBRUxJQUVnQ0VFRGNqWUNCQ0FKSUFSQkFYSTJBZ1FnQkNBSmFpQUVOZ0lBSUFvRVFDQUtRUU4ySWdCQkEzUkJ5UHNCYWlFRFFiVDdBU2dDQUNFQ0FuOUJBU0FBZENJQUlBVnhSUVJBUWFEN0FTQUFJQVZ5TmdJQUlBTU1BUXNnQXlnQ0NBc2hBQ0FESUFJMkFnZ2dBQ0FDTmdJTUlBSWdBellDRENBQ0lBQTJBZ2dMUWJUN0FTQUpOZ0lBUWFqN0FTQUVOZ0lBQ3lBQlFRaHFJUUFMSUF4QkVHb2tBQ0FBQy9ZRkFRdC9Ba0FnQVVFQmF5SUtRWUFDVHdSQUlBQWdBQ2dDSENJRElBcEJHQ0FLWjJzaUJuWWlBa0VCYWlJRWJpSUJOZ0lrSUFBZ0FDZ0NJQ0lGSUFKQkFDQUZJQUZ1SWdWQkFXb2lDQ0FFYXlJRUlBUWdDRXNiSUFJZ0JXdHFJZ3RySUFGc0lnSnJJZ2MyQWlBZ0FDQUJJQU1nQW1zZ0N4c2lBallDSENBQ1FZQ0FnQVJOQkVBZ0FDZ0NHQ0VESUFBb0FpZ2hCQ0FBS0FJVUlRVWdBQ2dDQkNFTUEwQWdBQ0FDUVFoMElnZzJBaHdnQUNBRlFRaHFJZ1UyQWhSQkFDRUJJQU1nREVrRVFDQUFJQU5CQVdvaUNUWUNHQ0FBS0FJQUlBTnFMUUFBSVFFZ0NTRURDeUFBSUFFMkFpZ2dBQ0FCSUFSQkNIUnlRUUYyUWY4QmNTQUhRUWgwUVlEKy8vOEhjWEpCL3dGeklnYzJBaUFnQWtHQmdBSkpJUWtnQVNFRUlBZ2hBaUFKRFFBTEN5QUxJQVowSVFnZ0FDZ0NEQ0VIQWtBZ0JpQUFLQUlRSWdGTkJFQWdBU0VGREFFTElBQW9BZ2doQWlBQUtBSUVJUVFEUUVFQUlRTWdBaUFFU1FSL0lBQWdBa0VCYWlJQ05nSUlJQUFvQWdBZ0JDQUNhMm90QUFBRlFRQUxJQUYwSUFkeUlRY2dBVUVSU0NFRElBRkJDR29pQlNFQklBTU5BQXNMSUFBZ0JTQUdhellDRUNBQUlBY2dCblkyQWd3Z0FDQUFLQUlVSUFacU5nSVVJQWRCZnlBR2RFRi9jM0VnQ0hJaUJpQUtUUTBCSUFCQkFUWUNMQ0FLRHdzZ0FDQUFLQUljSWdNZ0FXNGlBallDSkNBQUlBQW9BaUFpQkNBQklBUWdBbTRpQkVGL2N5QUJha0VBSUFSQkFXb2lCQ0FCYXlJQklBRWdCRXNiYWlJR1FYOXphaUFDYkNJQmF5SUhOZ0lnSUFBZ0FpQURJQUZySUFZYklnSTJBaHdnQWtHQWdJQUVTdzBBSUFBb0FoZ2hBeUFBS0FJb0lRUWdBQ2dDRkNFRklBQW9BZ1FoQ2dOQUlBQWdBa0VJZENJSU5nSWNJQUFnQlVFSWFpSUZOZ0lVUVFBaEFTQURJQXBKQkVBZ0FDQURRUUZxSWdrMkFoZ2dBQ2dDQUNBRGFpMEFBQ0VCSUFraEF3c2dBQ0FCTmdJb0lBQWdBU0FFUVFoMGNrRUJka0gvQVhFZ0IwRUlkRUdBL3YvL0IzRnlRZjhCY3lJSE5nSWdJQUpCZ1lBQ1NTRUpJQUVoQkNBSUlRSWdDUTBBQ3dzZ0JndUVCUUlLZndaOUlBQW9BaGdoQ0NBQUtBSUFJUWtnQlVFQlRnUkFBMEFnQ0NBSlFRRjFJZ2xCQW5ScUlRZ2dCMEVCYWlJSElBVkhEUUFMQ3lBQ0lBUkJBWFJCZkhGcUlRY2dBQ0FGUVFKMGFpZ0NDQ0VMQWtBZ0NVRURUQVJBSUFzZ0J4QTdEQUVMSUFsQkFuVWlDa0VCSUFwQkFVb2JJUTVCQUNFRklBRWdDVUVCZFNJTlFRRnJJQVpzUVFKMGFpRUFJQXNvQWl3aERFRUFJQVpCQVhRaUJtdEJBblFoRHdOQUlBY2dEQzRCQUVFRGRDSVFRUVJ5YWlBQUtnSUFJaE1nQ0NBRlFRSjBhaW9DQUNJVWxDQUJLZ0lBSWhFZ0NDQUZJQXBxUVFKMGFpb0NBQ0lTbEpJNEFnQWdCeUFRYWlBVUlCR1VJQk1nRXBTVE9BSUFJQXhCQW1vaERDQUFJQTlxSVFBZ0FTQUdRUUowYWlFQklBVkJBV29pQlNBT1J3MEFDeUFMSUFjUU95QUpRUVJJRFFBZ0NrRUJha0VCZFNJQVFRRWdBRUVCU2hzaEFDQUhJQTFCQW5ScUlRRkJBQ0VGQTBBZ0FVRUVheUlHS2dJQUlSTWdBVUVJYXlJQktnSUFJUlFnQnlBSEtnSUVJaEVnQ0NBRlFRSjBhaW9DQUNJU2xDQUhLZ0lBSWhVZ0NDQUZJQXBxUVFKMGFpb0NBQ0lXbEpJNEFnQWdCaUFSSUJhVUlCVWdFcFNUT0FJQUlBRWdFeUFJSUFvZ0JVRi9jeUlHYWtFQ2RHb3FBZ0FpRVpRZ0ZDQUlJQVlnRFdwQkFuUnFLZ0lBSWhLVWtqZ0NBQ0FISUJNZ0VwUWdGQ0FSbEpNNEFnUWdCMEVJYWlFSElBVkJBV29pQlNBQVJ3MEFDd3NnQkVFQ2JTRUFJQVJCQWs0RVFDQUNJQVJCQW5RaUFXb2hDQ0FCSUFOcUlRZEJBQ0VGQTBBZ0FpQUNLZ0lBSWhNZ0IwRUVheUlIS2dJQUloU1VJQWhCQkdzaUNDb0NBQ0lSSUFNcUFnQWlFcFNUT0FJQUlBZ2dFU0FVbENBVElCS1VramdDQUNBRFFRUnFJUU1nQWtFRWFpRUNJQVZCQVdvaUJTQUFSdzBBQ3dzTHFSb0NKbjhEZlNNQVFkQUFheUlNSkFBZ0FDZ0NDQ0VZSUF4QkFEWUNEQ0FNUVFBMkFnaEJmeUVIQWtBZ0FDZ0NBQ0lLS0FJa0lnaEJBRWdOQUNBQUlBb29BZ1FpSEVHQUVHb2lGaUFZYkVFQ2RHb2dHRUhnQUd4cVFkd0FhaUlOSUFvb0FnZ2lDMEVEZENJR2FpSVVJQVpxSWhrZ0Jtb2hKeUFBS0FJUUlBUnNJUkVnQUNnQ0dDRUpJQUFvQWhRaER5QUFLQUlNSVJBZ0NpZ0NJQ0ViSUFvb0Fpd2hCQU5BSUJFZ0JDQU9kRWNFUUNBSUlBNUtJUVlnRGtFQmFpRU9JQVlOQVF3Q0N3c2dBa0g3Q1VzTkFDQURSUTBBSUJoQkFTQVlRUUZLR3lFZFFRQWhCa0VBSUJGclFRSjBJUVFEUUNBR1FRSjBJZ2NnREVFWWFtb2dBQ0FHSUJac1FRSjBha0hjQUdvaUNEWUNBQ0FNUVJCcUlBZHFJQVFnQ0dwQmdFQnJOZ0lBSUFaQkFXb2lCaUFkUncwQUN5QUJRUUFnQWtFQlNodEZCRUFnQUNBUklBNFFXeUFNUVJCcUlBTWdFU0FZSUFBb0FoQWdDa0VRYWlBQVFkUUFhaEE1SUJFZ0FDZ0NFRzBoQnd3QkN5QUtLQUlNSVI1QkFDRUdJQUFnQUNnQ05FRUFSellDT0NBRlJRUkFJQXhCSUdvZ0FTQUNFRk1nREVFZ2FpRUZDMEVCSVNNQ1FDQVFRUUZIRFFBZ0MwRUJTQTBBQTBBZ0RTQUdRUUowYWlJQklBRXFBZ0FpTENBTklBWWdDMnBCQW5ScUtnSUFJaTBnTENBdFhoczRBZ0FnQmtFQmFpSUdJQXRIRFFBTEN3Si9JQVVvQWhRaUNDQUZLQUljWnlJRWFrRWdheUlHSUFKQkEzUWlGVWdFUUVFQUlTTkJBU0FHUVFGSERRRWFJQVZCRHhBR0lnRkZCRUJCQVNFR1FRRU1BZ3NnQlNnQ0ZDRUlJQUVoSXlBRktBSWNaeUVFQ3lBRklCVWdDR3NnQkdzZ0NHcEJJR28yQWhRZ0ZTRUdRUUFMSVNoREFBQUFBQ0VzQWtBZ0R3MEFJQVpCRUdvZ0ZVb05BQUo5UXdBQUFBQWdCVUVCRUFaRkRRQWFJQVVnQlVFR0VCWWlBVUVFYWhBSlFSQWdBWFJxSVFFZ0JVRURFQWtoQkNBVklBVW9BaFFnQlNnQ0hHZHFRUjVyVGdSQUlBVkJoejFCQWhBRElSOExJQUZCQVdzaEpDQUVRUUZxc2tNQUFNQTlsQXNoTENBRktBSVVJQVVvQWh4bmFrRWdheUVHQ3lBR1FRTnFJUVlDUUNBT1JRMEFJQVlnRlVvTkFDQUZRUU1RQmlFWElBVW9BaFFnQlNnQ0hHZHFRUjFySVFZTElBb2dEeUFKSUEwZ0JpQVZUQVIvSUFWQkF4QUdCVUVBQ3lBRklCQWdEaENlQVNBTUlBdEJBblJCRDJwQmNIRnJJaUFpRXlRQUlBNUJBRWNnQlNnQ0JFRURkQ0lHSUFVb0FoUWdCU2dDSEdkcVFTQnJJZ1JCQWtFRUlCY2JJZ0ZCQVhKcVQzRWhGa0VBSVFjQ1FDQUpJQTlNSWhJTkFDQUdJQlpySWhvZ0FTQUVhazhFUUNBRklBRVFCaUVISUFVb0FoUWdCU2dDSEdkcVFTQnJJUVFMSUNBZ0QwRUNkR29nQnpZQ0FDQVBRUUZxSWdZZ0NVWU5BRUVFUVFVZ0Z4c2hBU0FISVFnRFFDQWFJQUVnQkdwUEJFQWdCU0FCRUFZZ0NITWlDQ0FIY2lFSElBVW9BaFFnQlNnQ0hHZHFRU0JySVFRTElDQWdCa0VDZEdvZ0NEWUNBQ0FHUVFGcUlnWWdDVWNOQUFzTFFRQWhCZ0pBSUJaRkRRQWdEa0VEZEVHd08yb2lBU0FISUJkQkFuUWlCR3BxTFFBQUlBRWdCRUVDY2lBSGFtb3RBQUJHRFFBZ0JVRUJFQVpCQVhRaEJnc2dFa1VFUUNBR0lCZEJBblJxSVFFZ0RrRURkRUd3TzJvaEJDQVBJUVlEUUNBZ0lBWkJBblJxSWdjZ0JDQUJJQWNvQWdCcWFpd0FBRFlDQUNBR1FRRnFJZ1lnQ1VjTkFBc0xRUUloSlNBVklBVW9BaFFnQlNnQ0hHZHFRUnhyVGdSQUlBVkJpajFCQlJBRElTVUxJQk1nQzBFQ2RFRVBha0Z3Y1NJQmF5SWFJZ1FrQUNBS0lCb2dEaUFRRUY1QkJpRVRJQUpCQm5RaEZpQUVJQUZySWlFaUppUUFJQVVRQ3lFQ0FrQWdFZ1JBSUJZaEJBd0JDeUFQSVFZZ0ZpRUVBMEFnR3lBR0lnRkJBV29pQmtFQmRHb3VBUUFnR3lBQlFRRjBhaTRCQUdzZ0VHd2dEblFpQjBFRGRDSUlJQWRCTUNBSFFUQktHeUlISUFjZ0NFb2JJU0lnR2lBQlFRSjBJaWxxSVNvZ0JDRUJJQk1oQ0VFQUlRY0RRQUpBSUFjaEVpQUJJZ1FnQ0VFRGRDQUNha3dOQUNBU0lDb29BZ0JPRFFBZ0JDQWlheUVCSUJJZ0ltb2hCeUFGSUFnUUJpRXJJQVVRQ3lFQ1FRRWhDQ0FyRFFFTEN5QWhJQ2xxSUJJMkFnQWdFMEVCYTBFQ0lCTkJBa29iSUJNZ0VrRUFTaHNoRXlBR0lBbEhEUUFMQ3lBbUlBdEJBblJCRDJwQmNIRnJJZ2NpQVNRQVFRVWhDQ0FFSUFKQk1HcE9CRUFnQlVHT1BVRUhFQU1oQ0FzZ0MwRUJkQ0VFSUJZZ0JSQUxRWDl6YWlFQ1FRQWhCaUFlSUFrZ0NTQWVTaHNoRzBFQklBNTBJaDVCQUNBWEd5RWlJQUVnQzBFQ2RFRVBha0Z3Y1NJQmF5SVRJaElrQUNBU0lBRnJJaElpSmlRQUlBb2dEeUFKSUNFZ0dpQUlJQXhCREdvZ0RFRUlhaUFDQW44Z0RrRUNTUVJBUVFBaEFVRUFEQUVMUVFBaEFVRUFJQmRGRFFBYUlBSWdEa0VEZEVFUWFrNGlBVUVEZEFzaUdtc2dERUVFYWlBVElBY2dFaUFRSUE0Z0JSQ2JBU0VoSUFvZ0R5QUpJQTBnQnlBRklCQVFuUUVnSEVFQ2JTQVJhMEVDZEVHQVFHc2hBZ05BSUF4QkdHb2dCa0VDZEdvb0FnQWlDQ0FJSUJGQkFuUnFJQUlRRGhvZ0JrRUJhaUlHSUIxSERRQUxJQ1lnQ3lBUWJDSUlRUTlxUVhCeGF5SUdJZ0lrQUNBQ0lCQWdFV3hCQW5SQkQycEJjSEZySWdJa0FDQUtJQThnQ1NBQ0lBSWdFVUVDZEdwQkFDQVFRUUpHR3lBR0lCTWdJaUFsSUF3b0FnZ2dEQ2dDRENBZ0lCWWdHbXNnRENnQ0JDQUZJQTRnSVNBQVFTaHFJQUFvQWlRZ0FDZ0NJQkJoQWtBZ0FRUkFJQVZCQVJBSklRRWdDaUFQSUFrZ0RTQUhJQklnRlNBRktBSVVheUFGS0FJY1oydEJJR29nQlNBUUVGUWdBVVVOQVNBS0lBSWdCaUFPSUJBZ0VTQVBJQWtnRFNBVUlCa2dFeUFBS0FJb0lBQW9BaVFRWXd3QkN5QUtJQThnQ1NBTklBY2dFaUFWSUFVb0FoUnJJQVVvQWh4bmEwRWdhaUFGSUJBUVZBc0NmeUFvUlFSQVFRQWhCaUFJUVFCS0JFQURRQ0FOSUFaQkFuUnFRWUNBZ0k5OE5nSUFJQVpCQVdvaUJpQUlSdzBBQ3dzZ0NpQUNJQXhCRUdvZ0RTQVBJQnNnRUNBWUlCY2dEaUFBS0FJUUlDTWdBQ2dDSkJBaUlBeEJFR29NQVFzZ0NpQUNJQXhCRUdvZ0RTQVBJQnNnRUNBWUlCY2dEaUFBS0FJUVFRQWdBQ2dDSkJBaUlBeEJFR29MSVFKQkFDRUdBa0FnRGtVRVFBTkFJQUFnQUNnQ1BDSUJRUThnQVVFUFNoc2lBVFlDUENBQUlBQW9Ba0FpQjBFUElBZEJEMG9iSWdjMkFrQWdERUVRYWlBR1FRSjBhaWdDQUNJSUlBZ2dCeUFCSUFvb0Fpd2dBQ29DU0NBQUtnSkVJQUFvQWxBZ0FDZ0NUQ0FLS0FJOElCd2dBQ2dDSkJBWklBWkJBV29pQmlBZFJ3MEFEQUlMQUFzRFFDQUFJQUFvQWp3aUFVRVBJQUZCRDBvYklnYzJBandnQUNBQUtBSkFJZ0ZCRHlBQlFROUtHeUlJTmdKQUlBeEJFR29nQmtFQ2RHb29BZ0FpQVNBQklBZ2dCeUFLS0FJc0lBQXFBa2dnQUNvQ1JDQUFLQUpRSUFBb0Frd2dDaWdDUENBY0lBQW9BaVFRR1NBQklBb29BaXdpQjBFQ2RHb2lBU0FCSUFBb0Fqd2dKQ0FSSUFkcklBQXFBa1FnTENBQUtBSk1JQjhnQ2lnQ1BDQWNJQUFvQWlRUUdTQUdRUUZxSWdZZ0hVY05BQXNMSUFBZ0FDZ0NQRFlDUUNBQUtnSkVJUzBnQUNBc09BSkVJQUFnTFRnQ1NDQUFLQUpNSVFFZ0FDQWZOZ0pNSUFBZ0FUWUNVQ0FBSUNRMkFqd2dEZ1JBSUFBZ0h6WUNVQ0FBSUN3NEFrZ2dBQ0FrTmdKQUN5QVFRUUZHQkVBZ0RTQUxRUUowSWdGcUlBMGdBUkFFR2dzQ1FDQVhCRUFnQzBFQlNBMEJJQVJCQVNBRVFRRktHeUVCUVFBaEJnTkFJQlFnQmtFQ2RDSUVhaUlISUFjcUFnQWlMQ0FFSUExcUtnSUFJaTBnTENBdFhSczRBZ0FnQmtFQmFpSUdJQUZIRFFBTERBRUxJQmtnRkNBTFFRTjBJZ0VRQkJvZ0ZDQU5JQUVRQkJvZ0MwRUJTQTBBSUI2eVEyOFNnenFVUXdBQWdEOGdBQ2dDTkVFS1NCc2hMQ0FFUVFFZ0JFRUJTaHNoQVVFQUlRWURRQ0FuSUFaQkFuUWlCR29pQnlBc0lBY3FBZ0NTSWkwZ0JDQU5haW9DQUNJdUlDMGdMbDBiT0FJQUlBWkJBV29pQmlBQlJ3MEFDd3RCQUNFR0FrQWdEMEVBU2dSQUEwQWdEU0FHUVFKMElnRnFRUUEyQWdBZ0FTQVpha0dBZ0lDUGZEWUNBQ0FCSUJScVFZQ0FnSTk4TmdJQUlBWkJBV29pQmlBUFJ3MEFDeUFKSUF0SUJFQWdDU0VHQTBBZ0RTQUdRUUowSWdGcVFRQTJBZ0FnQVNBWmFrR0FnSUNQZkRZQ0FDQUJJQlJxUVlDQWdJOThOZ0lBSUFaQkFXb2lCaUFMUncwQUN3dEJBQ0VHQTBBZ0RTQUdJQXRxUVFKMElnRnFRUUEyQWdBZ0FTQVpha0dBZ0lDUGZEWUNBQ0FCSUJScVFZQ0FnSTk4TmdJQUlBWkJBV29pQmlBUFJ3MEFDeUFKSUF0T0RRRURRQ0FOSUFrZ0MycEJBblFpQVdwQkFEWUNBQ0FCSUJscVFZQ0FnSTk4TmdJQUlBRWdGR3BCZ0lDQWozdzJBZ0FnQ1VFQmFpSUpJQXRIRFFBTERBRUxJQWtnQzA0TkFDQUpJUVlEUUNBTklBWkJBblFpQVdwQkFEWUNBQ0FCSUJscVFZQ0FnSTk4TmdJQUlBRWdGR3BCZ0lDQWozdzJBZ0FnQmtFQmFpSUdJQXRIRFFBTEEwQWdEU0FKSUF0cVFRSjBJZ0ZxUVFBMkFnQWdBU0FaYWtHQWdJQ1BmRFlDQUNBQklCUnFRWUNBZ0k5OE5nSUFJQWxCQVdvaUNTQUxSdzBBQ3dzZ0FDQUZLQUljTmdJb0lBSWdBeUFSSUJnZ0FDZ0NFQ0FLUVJCcUlBQkIxQUJxRURrZ0FFRUFOZ0kwUVgwaEJ5QVZJQVVvQWhRZ0JTZ0NIR2RxUVNCclRnUkFJQVVvQWl3RVFDQUFRUUUyQWl3TElCRWdBQ2dDRUcwaEJ3c0xJQXhCMEFCcUpBQWdCd3ZIQlFJRmZ3cDlBa0FDUUNBRlF3QUFBQUJjRFFBZ0JrTUFBQUFBWEEwQUlBQWdBVVlOQVNBQUlBRWdCRUVDZEJBT0dnOExRUUFoQzBGK0lBTkJEeUFEUVE5S0d5SU1heUVOSUF4QmYzTWhEa0VCSUF4cklROUJBQ0FNYXlFUUlBaEJER3dpQTBHSU8yb3FBZ0FnQnBRaEZDQURRWVE3YWlvQ0FDQUdsQ0VWSUFOQmdEdHFLZ0lBSUFhVUlSWkJBQ0FLSUFjZ0NFWWJJQW9nQlNBR1d4c2dDaUFDUVE4Z0FrRVBTaHNpQ0NBTVJoc2lBa0VCVGdSQUlBZEJER3dpQTBHSU8yb3FBZ0FnQlpRaEZ5QURRWVE3YWlvQ0FDQUZsQ0VZSUFOQmdEdHFLZ0lBSUFXVUlSbEJBaUFNYXlFRElBRWdEMEVDZEdvcUFnQWhFU0FCSUJCQkFuUnFLZ0lBSVJJZ0FTQU9RUUowYWlvQ0FDRVRJQUVnRFVFQ2RHb3FBZ0FoQlVFQUlRb0RRQ0FBSUFwQkFuUWlCMm9nQlNBQklBTWdDbXBCQW5ScUtnSUFJaHFTSUJRZ0J5QUphaW9DQUNJRklBV1VJZ1dVbENBUklCT1NJQlVnQlpTVUlCSWdGaUFGbEpRZ0FTQUhhaW9DQUNBQklBb2dDR3RCQW5ScUlnY3FBZ0FnR1VNQUFJQS9JQVdUSWdXVWxKSWdHQ0FGbENBSEtnSUVJQWRCQkdzcUFnQ1NsSklnRnlBRmxDQUhLZ0lJSUFkQkNHc3FBZ0NTbEpLU2twSTRBZ0FnRXlFRklCSWhFeUFSSVJJZ0dpRVJJQXBCQVdvaUNpQUNSdzBBQ3lBQ0lRc0xJQVpEQUFBQUFGc0VRQ0FBSUFGR0RRRWdBQ0FDUVFKMElnTnFJQUVnQTJvZ0JDQUNhMEVDZEJBT0dnOExJQVFnQzJzaUIwRUJTQTBBSUFBZ0MwRUNkQ0lFYWlFRFFRSWdER3NoQWlBQklBUnFJZ0VnRFVFQ2RHb3FBZ0FoRXlBQklBNUJBblJxS2dJQUlRVWdBU0FRUVFKMGFpb0NBQ0VSSUFFZ0QwRUNkR29xQWdBaEVrRUFJUW9EUUNBRElBcEJBblFpQUdvZ0ZDQVRJQUVnQWlBS2FrRUNkR29xQWdBaUJwS1VJQlVnQlNBU2twUWdGaUFSbENBQUlBRnFLZ0lBa3BLU09BSUFJQVVoRXlBUklRVWdFaUVSSUFZaEVpQUtRUUZxSWdvZ0IwY05BQXNMQzZBQ0FRWi9JQU5CQVdzaENFRWZJQU5uSWdkcklRVUNRQ0FEUVFKSUJFQWdBeUVFREFFTElBTWhCQU5BSUFRZ0FpQUdRUUYwSWdSQkFuSnFMZ0VBSWdrZ0NXd2dBaUFFYWk0QkFDSUVJQVJzYWlBRmRtb2hCQ0FHUVFKcUlnWWdDRWdOQUFzZ0EwRitjU0VHQ3lBRElBWktCRUFnQkNBQ0lBWkJBWFJxTGdFQUlnUWdCR3dnQlhacUlRUUxRUUFoQlVFaUlBY2dCR2RxYXlJRVFRQWdCRUVBU2hzaEJDQURRUUpJQkg5QkFBVkJBQ0VHQTBBZ0JTQUNJQVpCQVhRaUJVRUNjbW91QVFBaUJ5QUhiQ0FDSUFWcUxnRUFJZ1VnQld4cUlBUjJhaUVGSUFaQkFtb2lCaUFJU0EwQUN5QURRWDV4Q3lJR0lBTklCRUFnQWlBR1FRRjBhaTRCQUNJQ0lBSnNJQVIySUFWcUlRVUxJQUVnQkRZQ0FDQUFJQVUyQWdBTDB3RUJCWDhnQUVHd01FRUlFQU1oQWlBQVFmNHdRUWdRQXlFRElBQkJoVEZCQ0JBRElRUWdBU0FBUWY0d1FRZ1FBeUFDSUFKQkJXMGlCVUY3YkdwQkEyeHFRUUYwUVpBd2FpSUNMZ0VDSUFJdUFRQWlBbXNpQmtILy93TnhRWm96YkVFUWRpQUdRUkIxUVpvemJHb2dBRUdGTVVFSUVBTkJFWFJCRUhWQkFYSnNJQUpxSWdBMkFnUWdBU0FESUFWQkEyeHFRUUYwUVpBd2FpSUJMZ0VDSUFFdUFRQWlBV3NpQWtILy93TnhRWm96YkVFUWRpQUNRUkIxUVpvemJHb2dCRUVSZEVFUWRVRUJjbXdnQVdvZ0FHczJBZ0FMeFFJQkEzOGpBRUdRQVdzaUJpUUFJQUFvQXBnU0lRY2dCa0VBTmdLSUFRSkFBa0FDUUFKQUlBUU9Bd0VDQUFJTElBQWdBQ2dDMUJKQkFuUnFRZlFTYWlnQ0FFRUJSdzBCQ3lBR0lBZEJEMnBCOFAvLy93ZHhRUUYwYXlJSUpBQWdBQ0FCSUFBb0F0UVNJQVFnQlJBb0lBRWdDQ0FBUWMwVmFpSUJMQUFBSUFCQnpoVnFMQUFBSUFBb0FwZ1NFQ2NnQUNBR0lBVVFiaUFBSUFZZ0FpQUlFRzhnQUNBR0lBSkJBQkJGSUFCQkFEWUN3Q0FnQUVFQU5nTElFaUFBSUFFc0FBQTJBc1FnREFFTElBQWdCaUFDUVFFUVJRc2dBRUhFQ21vaUFTQUJJQUFvQXBnU0lnUkJBWFJxSUFBb0FxQVNJQVJyUVFGMElnRVFEaUFCYWlBQ0lBQW9BcGdTUVFGMEVBUWFJQUFnQmlBQ0lBY1FlU0FBSUFJZ0J4QnlJQUFnQUNnQ2xCSkJBblFnQm1wQkJHc29BZ0EyQW9RU0lBTWdCellDQUNBR1FaQUJhaVFBUVFBTDlRWUNDbjhFZmlNQVFlQUFheUVHQW44Q1FDQUJRUUJLQkVBRFFDQUdJQUpCQW5ScUlBQWdBa0VCZEdvdUFRQWlCVUVNZERZQ0FDQUVJQVZxSVFRZ0FrRUJhaUlDSUFGSERRQUxJQVJCL3g5S0JFQkJBQThMSUFGQkFXc2hBa0tBZ0lDQUJDRU1JQUZCQWtnRVFDQUNJUVFNQWdzRFFDQUdJQUlpQUVFQ2RHb29BZ0FpQkVHZTMvOEhha0c4dnY4UFN3UkFRUUFQQzBFQUlBeEJnSUNBZ0FSQkFDQUVRUWQwYTZ3aURTQU5ma0lnaUtkcklnV3Nma0llaUtkQmZIRWlDa0h1eGdaSURRTWFRUUFoQkVFQVFmLy8vLzhCSUFVZ0JTQUZRUjkxSWdKcUlBSnpaeUlGUVFGcmRDSURRUkIxSWdodElnZEJFSFFpQ1VFUWRTSUNJQU5CLy84RGNXeEJFSFVnQWlBSWJHcEJBM1JySWdNZ0IwRVBkVUVCYWtFQmRXd2dDV29nQTBFUWRTQUNiR29nQTBINC93TnhJQUpzUVJCMWFxd2hEaUFCUVFGMklnRkJBU0FCUVFGTEd5RUpRUjhnQld1dElROERRQ0FHSUFSQkFuUnFJZ01vQWdBaUFpQUdJQUFnQkVGL2MycEJBblJxSWdzb0FnQWlBYXdnRFg1Q0hvaENBWHhDQVlpbklnaHJJZ2RCZ0lDQWdIaEIvLy8vL3djZ0IwRi9TaUlIR3lBSUlBSWdCeHRCZjNNZ0FpQUlJQWNiY1VGL1NodXNJQTUrSVF3Q2ZnSkFBa0FnQlVFZlJnUkFJQXhDQVlNZ0RFSUJoM3dpREVLQWdJQ0FDSHhDLy8vLy93OVlEUUZCQUE4TElBd2dENGRDQVh4Q0FZY2lERUtBZ0lDQUNIeEMvLy8vL3c5WURRRkJBQThMSUFNZ0RENENBQ0FCSUFLc0lBMStRaDZJUWdGOFFnR0lweUlDYXlJRFFZQ0FnSUI0UWYvLy8vOEhJQU5CZjBvaUF4c2dBaUFCSUFNYlFYOXpJQUVnQWlBREczRkJmMG9ickNBT2ZpSU1RZ0dESUF4Q0FZZDhEQUVMSUFNZ0RENENBQ0FCSUFLc0lBMStRaDZJUWdGOFFnR0lweUlDYXlJRFFZQ0FnSUI0UWYvLy8vOEhJQU5CZjBvaUF4c2dBaUFCSUFNYlFYOXpJQUVnQWlBREczRkJmMG9ickNBT2ZpQVBoMElCZkVJQmh3c2lERUtBZ0lDQUNIeEMvLy8vL3c5V0JFQkJBQThMSUFzZ0RENENBQ0FFUVFGcUlnUWdDVWNOQUFzZ0FFRUJheUVDSUFxc0lReEJBQ0VFSUFBaUFVRUJTZzBBQ3d3QkN5QUJRUUZySVFSQ2dJQ0FnQVFoREF0QkFDQUdJQVJCQW5ScUtBSUFRWjdmL3dkcVFieSsvdzlMRFFBYVFRQWdERUtBZ0lDQWdJQ0FnTUFBUVFBZ0JpZ0NBRUVIZEd1c0lnd2dESDVDZ0lDQWdQRC8vLy8vQUlOOVFpQ0hma0llaUtkQmZIRWlBQ0FBUWU3R0JrZ2JDd3NwQVFGL0l3QkJFR3NpQWlRQUlBSWdBVFlDREVHUTlBRW9BZ0FnQUNBQkVJc0JJQUpCRUdva0FBdTVBd01DZndGK0Fud2dBTDBpQTBJL2lLY2hBUUpBQWtBQ2ZBSkFJQUFDZndKQUFrQWdBMElnaUtkQi8vLy8vd2R4SWdKQnE4YVloQVJQQkVBZ0FMMUMvLy8vLy8vLy8vLy9BSU5DZ0lDQWdJQ0FnUGovQUZZRVFDQUFEd3NnQUVUdk9mcitRaTZHUUdSQkFYTkZCRUFnQUVRQUFBQUFBQURnZjZJUEN5QUFSTks4ZXQwckk0YkFZMEVCY3cwQklBQkVVVEF0MVJCSmg4QmpSUTBCREFZTElBSkJ3OXpZL2dOSkRRTWdBa0d5eGNML0Ewa05BUXNnQUVUK2dpdGxSeFgzUDZJZ0FVRURkRUhnM1FGcUt3TUFvQ0lBbVVRQUFBQUFBQURnUVdNRVFDQUFxZ3dDQzBHQWdJQ0FlQXdCQ3lBQlFRRnpJQUZyQ3lJQnR5SUVSQUFBNFA1Q0x1YS9vcUFpQUNBRVJIWThlVFh2T2VvOW9pSUZvUXdCQ3lBQ1FZQ0F3UEVEVFEwQ1FRQWhBU0FBQ3lFRUlBQWdCQ0FFSUFRZ0JLSWlBQ0FBSUFBZ0FDQUFSTkNrdm5KcE4yWStva1R4YTlMRlFiMjd2cUNpUkN6ZUphOXFWaEUvb0tKRWs3MitGbXpCWnIrZ29rUStWVlZWVlZYRlA2Q2lvU0lBb2tRQUFBQUFBQUFBUUNBQW9hTWdCYUdnUkFBQUFBQUFBUEEvb0NFRUlBRkZEUUFnQkNBQkVCUWhCQXNnQkE4TElBQkVBQUFBQUFBQThEK2dDN0FCQVFSL0lBQW9BZ3doQkFKQUlBQW9BaEFpQlVFQmFpSUNRU0ZKQkVBZ0JTRUREQUVMQTBBZ0FDQUFLQUlFSWdNZ0FDZ0NDQ0lDSUFBb0FoaHFTd1IvSUFBZ0FrRUJhaUlDTmdJSUlBQW9BZ0FnQXlBQ2Eyb2dCRG9BQUVFQUJVRi9DeUFBS0FJc2NqWUNMQ0FFUVFoMklRUWdCVUVQU2lFQ0lBVkJDR3NpQXlFRklBSU5BQXNnQTBFQmFpRUNDeUFBSUFJMkFoQWdBQ0FCSUFOMElBUnlOZ0lNSUFBZ0FDZ0NGRUVCYWpZQ0ZBdVNBd0VDZnlBQUtBSWNJZ1FnQTI0aEJTQUFBbjhnQVFSQUlBQWdBQ2dDSUNBRklBRWdBMnRzSUFScWFqWUNJQ0FGSUFJZ0FXdHNEQUVMSUFVZ0FpQURhMndnQkdvTElnTTJBaHdnQTBHQWdJQUVUUVJBSUFBb0FpQWhBUU5BQWtBZ0FVRVhkaUlGUWY4QlJ3UkFJQUZCSDNZaEFpQUFLQUlvSWdSQkFFNEVRRUYvSVFFZ0FDQUFLQUlFSUFBb0FoZ2lBeUFBS0FJSWFrc0VmeUFBSUFOQkFXbzJBaGdnQUNnQ0FDQURhaUFDSUFScU9nQUFRUUFGUVg4TElBQW9BaXh5TmdJc0N5QUFLQUlrSWdFRVFDQUNRUUZySVFRRFFFRi9JUU1nQUNBQUtBSUVJQUFvQWhnaUFpQUFLQUlJYWtzRWZ5QUFJQUpCQVdvMkFoZ2dBQ2dDQUNBQ2FpQUVPZ0FBUVFBaEF5QUFLQUlrQlNBQkMwRUJheUlCTmdJa0lBQWdBQ2dDTENBRGNqWUNMQ0FCRFFBTEN5QUFJQVZCL3dGeE5nSW9JQUFvQWh3aEF5QUFLQUlnSVFFTUFRc2dBQ0FBS0FJa1FRRnFOZ0lrQ3lBQUlBTkJDSFFpQXpZQ0hDQUFJQUZCQ0hSQmdQNy8vd2R4SWdFMkFpQWdBQ0FBS0FJVVFRaHFOZ0lVSUFOQmdZQ0FCRWtOQUFzTEM5OEZBUXAvSXdBaURTRVZJQUFvQWdnaEV5QUFLQUlFSVJBZ0RTQUFLQUlzSWhRZ0NYUWlEMEVDZEVFUGFrRndjV3NpRGlRQUlBQW9BaVJCQUNBSklBZ2JheUVTUVFFZ0NYUWlFVUVCSUFnYklRMGdGQ0FQSUFnYklRZ0NRQUpBSUFaQkFVY05BQ0FIUVFKSERRQWdBQ0FCSUE0Z0F5QUVJQVVnRVNBS0lBc1FFaUFDS0FJRUlCQkJBbTFCQW5ScUlBNGdEMEVDZEJBRUlRRWdEVUVCU0EwQklBQkJRR3NoQTBFQUlRa0RRQ0FESUFFZ0NVRUNkR29nQWlnQ0FDQUlJQWxzUVFKMGFpQUFLQUk4SUJBZ0VpQU5FQmNnQ1VFQmFpSUpJQTFIRFFBTElBMUJBVWdOQVNBQVFVQnJJUUZCQUNFSkEwQWdBU0FPSUFsQkFuUnFJQUlvQWdRZ0NDQUpiRUVDZEdvZ0FDZ0NQQ0FRSUJJZ0RSQVhJQWxCQVdvaUNTQU5SdzBBQ3d3QkN3SkFJQVpCQWtaQkFDQUhRUUZHRzBVRVFDQUhRUUVnQjBFQlNoc2hCMEVBSVFZZ0RVRUJTQTBCSUFCQlFHc2hGQU5BSUFBZ0FTQUdJQTlzUVFKMGFpQU9JQU1nQmlBVGJFRUNkR29nQkNBRklCRWdDaUFMRUJJZ0FpQUdRUUowYWlFV1FRQWhDUU5BSUJRZ0RpQUpRUUowYWlBV0tBSUFJQWdnQ1d4QkFuUnFJQUFvQWp3Z0VDQVNJQTBRRnlBSlFRRnFJZ2tnRFVjTkFBc2dCa0VCYWlJR0lBZEhEUUFMREFJTElBSW9BZ0FoQmlBQUlBRWdEaUFESUFRZ0JTQVJJQW9nQ3hBU0lBQWdBU0FQUVFKMGFpQUdJQkJCQW0xQkFuUnFJZ0VnQXlBVFFRSjBhaUFFSUFVZ0VTQUtJQXNRRWtFQUlRa2dEMEVBU2dSQUEwQWdEaUFKUVFKMElnTnFJZ1FnQkNvQ0FFTUFBQUEvbENBQklBTnFLZ0lBUXdBQUFEK1VramdDQUNBSlFRRnFJZ2tnRDBjTkFBc0xJQTFCQVVnTkFTQUFRVUJySVFGQkFDRUpBMEFnQVNBT0lBbEJBblJxSUFJb0FnQWdDQ0FKYkVFQ2RHb2dBQ2dDUENBUUlCSWdEUkFYSUFsQkFXb2lDU0FOUncwQUN3d0JDd05BSUFBZ0FTQUdJQTlzUVFKMGFpQU9JQU1nQmlBVGJFRUNkR29nQkNBRklCRWdDaUFMRUJJZ0JrRUJhaUlHSUFkSERRQUxDeUFWSkFBTG14SUNDbjhEZlNBQUtBSVFJUkFnQUNnQ0FDRU1RUUVoQ3lBRktBSUFJZzBnQUNnQ0NDSVRLQUk0SUFBb0Fnd2lEMEVCZEdvdUFRQWdDRUVEZEdvaUNHdEJJR3NpRVNBSVFRRjFRWEJCZkNBRVFRSkdJQWxCQUVkeElnZ2JhaUFFUVFGMFFYNUJmeUFJRzJvaUNHd2dEV29nQ0cwaUNDQUlJQkZLR3lJSVFjQUFJQWhCd0FCSUd5SUlRUVJPQkVBZ0NFRUhjVUVCZEVId09tb3VBUUJCRGlBSVFRTjJhM1ZCQVdwQmZuRWhDd3NnQUNnQ0hDRU5JQXRCQVNBTElBa2JJQThnRUVnYklRc0Nmd0pBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFJQXdFUUNBQUtBSWtJUkFnQWlBRElBa2dCQ0FBS0FJc0VKVUJJUWdnRFJBTElSRWdDMEVCUmcwRUFuOENRQ0FKQkVBZ0FDZ0NNQ0lBRFFFZ0NDQUxiRUdBUUd0QkRuVU1BZ3NDUUNBTElBZ2dDMndpREVHQVFHc2lEa0VPZFNJSVRBUkFJQWdoQUF3QkN5QU1RWURBQUVnRVFDQUlJUUFNQVFzZ0FDZ0NPRVVFUUNBSUlRQU1BUXNnRGtHQWdIOXhJQXNpQUc1QkVIUWlEa0VOZFNBT1FSQjFiRUdBZ0FKcVFSQjFJZ3dnREVHT2UyeEJnSUFCYWtFUGRVSFZ3QUJxYkVFQmRFR0FnSXJ2QVd0QkVIVWdER3hCZ0lBQmFrRVBkaUFNYTBFUWRFR0FnSUNBZUd0QkVIVWlFbWNpRkVHQWdJQ0FCQ0FPYXlJTVFRMTFJQXhCRUhWc1FZQ0FBbXBCRUhVaURDQU1RWTU3YkVHQWdBRnFRUTkxUWRYQUFHcHNRUUYwUVlDQWl1OEJhMEVRZFNBTWJFR0FnQUZxUVE5MklBeHJRUkIwUVlDQWdJQjRhMEVRZFNJTVp5SU9hMEVMZENBU0lCUkJFV3QwUVJCMFFSQjFJaEpCMjJ0c1FZQ0FBV3BCRDNWQi9EMXFJQkpzUVlDQUFXcEJEM1pySUF3Z0RrRVJhM1JCRUhSQkVIVWlERUhiYTJ4QmdJQUJha0VQZFVIOFBXb2dER3hCZ0lBQmFrRVBkbXBCRUhSQkVIVWdCRUVYZEVHQWdJQUVhMEVRZFd4QmdJQUJha0VQZFNJTUlBVW9BZ0FpRGtvTkFFRUFJQWdnREVFQUlBNXJTQnNoQUFzZ0IwRUJUQTBEREFrTElBQkJmM05CSDNaQkFDQUlJQXRzUWYvL0FVR0JnSDRnQ0VHQXdBQktHeUFMYldvaUFFRU9kU0FBUVFCSUd5SUFJQXRCQVdzZ0FDQUxTQnRxQ3lFQUlBUkJBa3dOQnlBTklBdEJBbTBpQjBFRGJFRURhaUlJSUFkQmYzTnFJQUJxSUFCQkEyd2lDU0FBSUFkS0lnd2JJQWdnQjJzZ0FHb2dDVUVEYWlBTUd5QUhJQWhxRUNFZ0FFRU9kQ0lBSUF0dUlRZ01DQXNnRFJBTElSRWdDMEVCUmcwRUFrQWdCRUVEU0EwQUlBbEZEUUFnRFFKL0lBMGdDMEVDYlNJQVFRRnFJZ2RCQTJ3aUFpQUFhaUlJRUZJaUF5QUNTQVJBSUFOQkEyME1BUXNnQXlBSFFRRjBhd3NpQ1NBQ0lBQkJmM05xYWlBSlFRTnNJZ01nQUNBSlNDSUhHeUFDSUFCcklBbHFJQU5CQTJvZ0J4c2dDQkF4REFNTFFRQWdCMEVCVENBSkd3MEJJQTBnQzBFQmFoQVdJUWtNQWdzZ0N5QUFheUlEUVFGcUlnY2dBRUVCYWlJSUlBQWdDMEVCZFNJQ1NpSUpHeUVQSUFKQkFXb2lBaUFDYkNFQ0lBMGdDUVIvSUFJZ0J5QURRUUpxYkVFQmRXc0ZJQUFnQ0d4QkFYVUxJZ2tnQ1NBUGFpQUNFQ0VnQUVFT2RDQUxiaUVJREFnTElBMENmeUFOSUF0QkFYVWlCMEVCYWlJQUlBQnNJZ01RVWlJQ0lBQWdCMnhCQVhWSUJFQWdBa0VEZEVFQmNoQTRRUUZyUVFGMklnbEJBV29pQUNBSmJFRUJkZ3dCQ3lBRElBdEJBV29pQUNBQVFRRjBJQU1nQWtGL2MycEJBM1JCQVhJUU9HdEJBWFlpQ1dzaUFDQUxJQWxyUVFKcWJFRUJkV3NMSWdJZ0FDQUNhaUFERURFTElBbEJEblFnQzI0aENBd0dDeUFKUlEwRlFRQWhDVUVBSVFjQ1FDQUlRWUhBQUVnTkFDQUFLQUkwRFFCQkFTRUhJQVJCQVVnTkFFRUFJUXNEUUNBRElBdEJBblJxSWdjZ0J5b0NBSXc0QWdCQkFTRUhJQXRCQVdvaUN5QUVSdzBBQ3dzZ0JFRUJTQTBCSUJBZ0V5Z0NDQ0FQYWtFQ2RHb3FBZ0FpRlNBUUlBOUJBblJxS2dJQUloWWdGcFJEZlIyUUpwSWdGU0FWbEpLUlEzMGRrQ2FTSWhXVklSY2dGaUFWbFNFVkEwQWdBaUFKUVFKMElnaHFJZ3NnRlNBTEtnSUFsQ0FYSUFNZ0NHb3FBZ0NVa2pnQ0FDQUpRUUZxSWdrZ0JFY05BQXNNQVF0QkFDRUhJQWxGRFFNTFFRQUNmMEVBSUFVb0FnQkJFVWdOQUJwQkFDQUFLQUlnUVJGSURRQWFJQXdFUUNBTklBY1FtZ0VnQnd3QkN5QU5RUUlRQmdzZ0FDZ0NOQnNoQnd3Q0N5QU5JQUFnQzBFQmFoQlJJQUJCRG5RaUFDQUxiaUVJSUFsRkRRSUxJQUFnQzBrRVFFRUFJUWNnQkVFQlNBMEJJQkFnRXlnQ0NDQVBha0VDZEdvcUFnQWlGU0FRSUE5QkFuUnFLZ0lBSWhZZ0ZwUkRmUjJRSnBJZ0ZTQVZsSktSUTMwZGtDYVNJaFdWSVJjZ0ZpQVZsU0VWUVFBaENRTkFJQUlnQ1VFQ2RDSUFhaUlJSUJVZ0NDb0NBSlFnRnlBQUlBTnFLZ0lBbEpJNEFnQWdDVUVCYWlJSklBUkhEUUFMREFFTElBUkJBVWdOQVVFQUlRa0RRQ0FDSUFsQkFuUWlBR29pQnlBSEtnSUFRL01FTlQrVUloVWdBQ0FEYWlJQUtnSUFRL01FTlQrVUloYVNPQUlBSUFBZ0ZpQVZremdDQUNBSlFRRnFJZ2tnQkVjTkFBc01BUXNnRFJBTElRQWdCU0FGS0FJQUlBQWdFV3NpQUdzMkFnQU1BUXNnRFJBTElRQWdCU0FGS0FJQUlBQWdFV3NpQUdzMkFnQkJnSUFCSVFrZ0NFR0FnQUZHRFFFZ0NBMENJQWdoQndzZ0NpQUtLQUlBUVg4Z0JuUkJmM054TmdJQVFmLy9BU0VEUVFBaENVRUFJUUpCZ0lCL0RBSUxJQW9nQ2lnQ0FFRi9JQVowUVg5eklBWjBjVFlDQUVILy93RWhBa0VBSVFkQkFDRURRWUNBQVF3QkMwRUFJUWNnQ0NFSklBaEJFSFFpQlVFTmRTQUZRUkIxYkVHQWdBSnFRUkIxSWdJZ0FrR09lMnhCZ0lBQmFrRVBkVUhWd0FCcWJFRUJkRUdBZ0lydkFXdEJFSFVnQW14QmdJQUJha0VQZGlBQ2EwRVFkRUdBZ0lDQWVHdEJFSFVpQTJjaUJrR0FnSUNBQkNBRmF5SUNRUTExSUFKQkVIVnNRWUNBQW1wQkVIVWlBaUFDUVk1N2JFR0FnQUZxUVE5MVFkWEFBR3BzUVFGMFFZQ0FpdThCYTBFUWRTQUNiRUdBZ0FGcVFROTJJQUpyUVJCMFFZQ0FnSUI0YTBFUWRTSUNaeUlGYTBFTGRDQURJQVpCRVd0MFFSQjBRUkIxSWdaQjIydHNRWUNBQVdwQkQzVkIvRDFxSUFac1FZQ0FBV3BCRDNacklBSWdCVUVSYTNSQkVIUkJFSFVpQlVIYmEyeEJnSUFCYWtFUGRVSDhQV29nQld4QmdJQUJha0VQZG1wQkVIUkJFSFVnQkVFWGRFR0FnSUFFYTBFUWRXeEJnSUFCYWtFUGRRc2hCQ0FCSUFBMkFoUWdBU0FKTmdJUUlBRWdCRFlDRENBQklBSTJBZ2dnQVNBRE5nSUVJQUVnQnpZQ0FBdVpDd0lJZndWOUl3QkJJR3NpRENRQUlBd2dDallDR0NBTUlBUTJBaHdnQUNnQ0hDRUVJQUFvQWdBaER3SkFJQU5CQVVZRVFFRUNRUUVnQWhzaUEwRUJJQU5CQVVzYklRWWdBQ2dDSUNFREFrQWdEd1JBUVFBaEJTQURRUWhPQkVBZ0JDQUJLZ0lBUXdBQUFBQmRJZ1VRSUNBQUlBQW9BaUJCQ0dzaUF6WUNJQXNnQUNnQ0JBUkFJQUZEQUFDQXYwTUFBSUEvSUFVYk9BSUFDeUFDUlEwQlFRRWhDZ05BUVFBaEJTQURRUWhPQkVBZ0JDQUNLZ0lBUXdBQUFBQmRJZ1VRSUNBQUlBQW9BaUJCQ0dzaUF6WUNJQXNnQUNnQ0JBUkFJQUpEQUFDQXYwTUFBSUEvSUFVYk9BSUFDeUFLUVFGcUlnb2dCa2NOQUFzTUFRdEJBQ0VGSUFOQkNFNEVRQ0FFUVFFUUNTRUZJQUFnQUNnQ0lFRUlheUlETmdJZ0N5QUFLQUlFQkVBZ0FVTUFBSUMvUXdBQWdEOGdCUnM0QWdBTElBSkZEUUJCQVNFS0EwQkJBQ0VGSUFOQkNFNEVRQ0FFUVFFUUNTRUZJQUFnQUNnQ0lFRUlheUlETmdJZ0N5QUFLQUlFQkVBZ0FrTUFBSUMvUXdBQWdEOGdCUnM0QWdBTElBcEJBV29pQ2lBR1J3MEFDd3RCQVNFSElBaEZEUUVnQ0NBQktnSUFPQUlBREFFTElBQWdEQ0FCSUFJZ0F5QU1RUnhxSUFVZ0JTQUhRUUVnREVFWWFoQWpJQXdvQWdpeVF3QUFBRGlVSVJNZ0RDZ0NCTEpEQUFBQU9KUWhGU0FNS0FJVUlRc2dEQ2dDRUNFTklBd29BZ0FoRVFKQUlBTkJBa1lFUUNBTUtBSWNJUTRnQUNBQUtBSWdJQTFCLy85K2NTSVNRUUJIUVFOMEloQWdDMnByTmdJZ0lBRWdBaUFOUVlEQUFFb2lEUnNoQ3lBQ0lBRWdEUnNoRFNBT0lCQnJJUkJCQUNFT0FrQWdFa1VOQUNBUEJFQWdCQ0FOS2dJQUlBc3FBZ1NVSUEwcUFnUWdDeW9DQUpTVFF3QUFBQUJkSWc0UUlBd0JDeUFFUVFFUUNTRU9DeUFBSUExQkFpQVFJQVVnQmlBSElBaERBQUNBUHlBSklBb1FDaUVISUFzZ0RTb0NCRUVBUVFFZ0RrRUJkR3NpQkd1eWxEZ0NBQ0FMSUEwcUFnQWdCTEtVT0FJRUlBQW9BZ1JGRFFFZ0FTQVZJQUVxQWdDVU9BSUFJQUVnRlNBQktnSUVsRGdDQkNBQ0lCTWdBaW9DQUpRaUZEZ0NBQ0FDSUJNZ0Fpb0NCSlE0QWdRZ0FTQUJLZ0lBSWhNZ0ZKTTRBZ0FnQWlBVElBSXFBZ0NTT0FJQUlBRWdBU29DQkNJVElBSXFBZ1NUT0FJRUlBSWdFeUFDS2dJRWtqZ0NCQXdCQ3lBTUtBSWNJUVFnRENnQ0RDRVBJQUFnQUNnQ0lDQUxheUlPTmdJZ0lBd29BaGdoQ2lBRUlBUWdEMnRCQW0waUN5QUVJQXRJR3lJTFFRQWdDMEVBU2hzaUN5QUVJQXRySWdST0JFQWdBQ0FCSUFNZ0N5QUZJQVlnQnlBSVF3QUFnRDhnQ1NBS0VBb2dBQ0FDSUFNZ0JDQUFLQUlnSUE1cklBdHFJZ1JCR0d0QkFDQUVRUmhLRzBFQUlBMGJhaUFGUVFBZ0IwRUFJQk5CQUNBS0lBVjFFQXB5SVFjTUFRc2dBQ0FDSUFNZ0JDQUZRUUFnQjBFQUlCTkJBQ0FLSUFWMUVBb2dBQ0FCSUFNZ0FDZ0NJQ0FPYXlBRWFpSUVRUmhyUVFBZ0JFRVlTaHRCQUNBTlFZQ0FBVWNiSUF0cUlBVWdCaUFISUFoREFBQ0FQeUFKSUFvUUNuSWhCd3NnQUNnQ0JFVU5BQUpBSUFOQkFrWU5BRU1BQUFBQUlSUUNRQ0FEUVFGSUJFQkRBQUFBQUNFVERBRUxRUUFoQUVNQUFBQUFJUk1EUUNBVElBSWdBRUVDZENJRWFpb0NBQ0lXSUFFZ0JHb3FBZ0NVa2lFVElCUWdGaUFXbEpJaEZDQUFRUUZxSWdBZ0EwY05BQXNMQWtBZ0ZTQVZsQ0FVa2lJVUlCVWdFNVFpRXlBVGtpSVRraUlXUTFKSkhUcGRSUVJBSUJRZ0U1TWlFME5TU1IwNlhVRUJjdzBCQ3lBQ0lBRWdBMEVDZEJBRUdnd0JDeUFEUVFGSURRRkRBQUNBUHlBV2taVWhGRU1BQUlBL0lCT1JsU0VUUVFBaEFBTkFJQUVnQUVFQ2RDSUVhaUlGSUJNZ0ZTQUZLZ0lBbENJV0lBSWdCR29pQkNvQ0FDSVhrNVE0QWdBZ0JDQVVJQllnRjVLVU9BSUFJQUJCQVdvaUFDQURSdzBBQ3dzZ0VVVU5BQ0FEUVFGSURRQkJBQ0VBQTBBZ0FpQUFRUUowYWlJQklBRXFBZ0NNT0FJQUlBQkJBV29pQUNBRFJ3MEFDd3NnREVFZ2FpUUFJQWNMRUFBZ0FTQUFRY2t3UVFnUUF6WUNBQXRmQUNBQVFRUnFRUUJCcENFUUJSb2dBRUVBTmdMSUlDQUFRWUNBQkRZQ0FDQUFRUUUyQXNnU0lBQVFlaUFBUVpRaGFrS0FnSVNBZ0lEQUFEY0NBQ0FBUWFBaGFrS0NnSUNBd0FJM0FnQWdBQ0FBS0FLWUVrRUhkRFlDekNCQkFBdXBDUUVJZnlNQVFhQUJheUlKSkFBZ0FDQUNRUUYxUVFsc1FlQXpha0VJRUFNaEJRSkFJQVJCQkhVZ0JFRndjU0FFU0dvaUMwRUFUQTBBSUFWQkVteEJvREpxSVFjRFFFRUFJUVVnQ1NBR1FRSjBJZ2hxSWdwQkFEWUNBQ0FKUWRBQWFpQUlhaUlJSUFBZ0IwRUlFQU1pRERZQ0FDQU1RUkZHQkVBRFFDQUlJQUFnQlVFQmFpSUZRUXBHUWNJemFrRUlFQU1pRERZQ0FDQU1RUkZHRFFBTElBb2dCVFlDQUFzZ0JrRUJhaUlHSUF0SERRQUxRUUFoQlNBTFFRQk1EUUFEUUNBQklBVkJFSFJCQzNWcUlRWUNRQ0FKUWRBQWFpQUZRUUowYWlnQ0FDSUhRUUZPQkVBZ0JpQUFJQWNRWmd3QkN5QUdRZ0EzQVFBZ0JrSUFOd0VZSUFaQ0FEY0JFQ0FHUWdBM0FRZ0xJQVZCQVdvaUJTQUxSdzBBQzBFQUlRb2dDMEVBVEEwQUEwQWdDU0FLUVFKMElneHFLQUlBSWdoQkFVNEVRQ0FCSUFwQkVIUkJDM1ZxSWdjdkFRQWhCVUVBSVFZRFFDQUFRZUF3UVFnUUF5QUZRUUYwYWlFRklBWkJBV29pQmlBSVJ3MEFDeUFISUFVN0FRQWdCeThCQWlFRlFRQWhCZ05BSUFCQjREQkJDQkFESUFWQkFYUnFJUVVnQmtFQmFpSUdJQWhIRFFBTElBY2dCVHNCQWlBSEx3RUVJUVZCQUNFR0EwQWdBRUhnTUVFSUVBTWdCVUVCZEdvaEJTQUdRUUZxSWdZZ0NFY05BQXNnQnlBRk93RUVJQWN2QVFZaEJVRUFJUVlEUUNBQVFlQXdRUWdRQXlBRlFRRjBhaUVGSUFaQkFXb2lCaUFJUncwQUN5QUhJQVU3QVFZZ0J5OEJDQ0VGUVFBaEJnTkFJQUJCNERCQkNCQURJQVZCQVhScUlRVWdCa0VCYWlJR0lBaEhEUUFMSUFjZ0JUc0JDQ0FITHdFS0lRVkJBQ0VHQTBBZ0FFSGdNRUVJRUFNZ0JVRUJkR29oQlNBR1FRRnFJZ1lnQ0VjTkFBc2dCeUFGT3dFS0lBY3ZBUXdoQlVFQUlRWURRQ0FBUWVBd1FRZ1FBeUFGUVFGMGFpRUZJQVpCQVdvaUJpQUlSdzBBQ3lBSElBVTdBUXdnQnk4QkRpRUZRUUFoQmdOQUlBQkI0REJCQ0JBRElBVkJBWFJxSVFVZ0JrRUJhaUlHSUFoSERRQUxJQWNnQlRzQkRpQUhMd0VRSVFWQkFDRUdBMEFnQUVIZ01FRUlFQU1nQlVFQmRHb2hCU0FHUVFGcUlnWWdDRWNOQUFzZ0J5QUZPd0VRSUFjdkFSSWhCVUVBSVFZRFFDQUFRZUF3UVFnUUF5QUZRUUYwYWlFRklBWkJBV29pQmlBSVJ3MEFDeUFISUFVN0FSSWdCeThCRkNFRlFRQWhCZ05BSUFCQjREQkJDQkFESUFWQkFYUnFJUVVnQmtFQmFpSUdJQWhIRFFBTElBY2dCVHNCRkNBSEx3RVdJUVZCQUNFR0EwQWdBRUhnTUVFSUVBTWdCVUVCZEdvaEJTQUdRUUZxSWdZZ0NFY05BQXNnQnlBRk93RVdJQWN2QVJnaEJVRUFJUVlEUUNBQVFlQXdRUWdRQXlBRlFRRjBhaUVGSUFaQkFXb2lCaUFJUncwQUN5QUhJQVU3QVJnZ0J5OEJHaUVGUVFBaEJnTkFJQUJCNERCQkNCQURJQVZCQVhScUlRVWdCa0VCYWlJR0lBaEhEUUFMSUFjZ0JUc0JHaUFITHdFY0lRVkJBQ0VHQTBBZ0FFSGdNRUVJRUFNZ0JVRUJkR29oQlNBR1FRRnFJZ1lnQ0VjTkFBc2dCeUFGT3dFY0lBY3ZBUjRoQlVFQUlRWURRQ0FBUWVBd1FRZ1FBeUFGUVFGMGFpRUZJQVpCQVdvaUJpQUlSdzBBQ3lBSElBVTdBUjRnQ1VIUUFHb2dER29pQlNBRktBSUFJQWhCQlhSeU5nSUFDeUFLUVFGcUlnb2dDMGNOQUFzTElBQWdBU0FFSUFJZ0F5QUpRZEFBYWhCd0lBbEJvQUZxSkFBTHhRWUJBWDhqQUVFd2F5SUZKQUFnQUVIT0ZXb0Nmd0pBSUFORkJFQWdBQ0FDUVFKMGFrSGtFbW9vQWdCRkRRRUxJQUZCNVRCQkNCQURRUUpxREFFTElBRkI2VEJCQ0JBREN5SURRUUZ4T2dBQUlBQkJ6UlZxSUFOQkFYWWlBam9BQUFKQUlBUkJBa1lFUUNBQUlBRkI0QzlCQ0JBRE9nQ3dGUXdCQ3lBQUlBRWdBa0VZZEVFVmRVSEFMMnBCQ0JBRFFRTjBPZ0N3RlNBQUlBRkJrREZCQ0JBRElBQXRBTEFWYWpvQXNCVUxJQUFvQXBRU1FRSk9CRUJCQVNFREEwQWdBQ0FEYWtHd0ZXb2dBVUhnTDBFSUVBTTZBQUFnQTBFQmFpSURJQUFvQXBRU1NBMEFDd3NnQUVHNEZXb2dBU0FBS0FLc0ZTSUNLQUlRSUFJdUFRQWdBQ3dBelJWQkFYVnNha0VJRUFNaUFqb0FBQ0FGUVJCcUlBVWdBQ2dDckJVZ0FrRVlkRUVZZFJCR0lBQW9BcXdWSWdJdUFRSkJBVTRFUUVFQUlRTURRQUpBQWtBQ1FDQUJJQUlvQWh3Z0JVRVFhaUFEUVFGMGFpNEJBR3BCQ0JBRElnSU9DUUFDQWdJQ0FnSUNBUUlMUVFBZ0FVR1lNVUVJRUFOcklRSU1BUXNnQVVHWU1VRUlFQU5CQ0dvaEFnc2dBQ0FEUVFGcUlnTnFRYmdWYWlBQ1FRUnJPZ0FBSUFNZ0FDZ0NyQlVpQWk0QkFrZ05BQXNMUVFRaEF5QUFRYzhWYWlBQUtBS1VFa0VFUmdSL0lBRkI2ekJCQ0JBREJVRUVDem9BQUNBQUxRRE5GVUVDUmdSQUFrQUNRQ0FFUVFKSERRQWdBQ2dDM0JKQkFrY05BQ0FCUWNBeFFRZ1FBeUlDUVJCMFFRRklEUUFnQUVIS0ZXb2dBaUFBTHdIZ0VtcEJDV3NpQWpzQkFBd0JDeUFBUWNvVmFpSUNJQUZCb0RGQkNCQURJQUFvQW93U1FRRjJiRHNCQUNBQ0lBRWdBQ2dDekJKQkNCQURJQUl2QVFCcUlnSTdBUUFMSUFBZ0Fqc0I0QklnQUVITUZXb2dBU0FBS0FMUUVrRUlFQU02QUFBZ0FFSFFGV29nQVVIU0VFRUlFQU1pQWpvQUFFRUJJUU1DUUNBQUtBS1VFa0VCU0EwQUlBQkJ0QlZxSUFFZ0FrRVlkRUVXZFVHUUVXb29BZ0JCQ0JBRE9nQUFJQUFvQXBRU1FRSklEUUFEUUNBQUlBTnFRYlFWYWlBQklBQXNBTkFWUVFKMFFaQVJhaWdDQUVFSUVBTTZBQUFnQTBFQmFpSURJQUFvQXBRU1NBMEFDd3RCQUNFRElBQkIwUlZxSUFRRWYwRUFCU0FCUWVJd1FRZ1FBd3M2QUFBTElBQWdBQ3dBelJVMkF0d1NJQUJCMGhWcUlBRkJnVEZCQ0JBRE9nQUFJQVZCTUdva0FBdkFBUUVFZnlBQlFRRnJJUVFnQVVFQ1RnUkFJQUpCZ0lBRWF5RUZRUUFoQVFOQUlBQWdBVUVDZEdvaUF5QURLQUlBSWdOQkVIUkJFSFVpQmlBQ1FmLy9BM0ZzUVJCMUlBWWdBa0VRZFd4cUlBTkJEM1ZCQVdwQkFYVWdBbXhxTmdJQUlBSWdCV3hCRDNWQkFXcEJBWFVnQW1vaEFpQUJRUUZxSWdFZ0JFY05BQXNMSUFBZ0JFRUNkR29pQUNBQUtBSUFJZ0JCRUhSQkVIVWlBU0FDUWYvL0EzRnNRUkIxSUFFZ0FrRVFkV3hxSUFCQkQzVkJBV3BCQVhVZ0FteHFOZ0lBQzM0QkEzOGdBVUVCYXlFRElBRkJBazRFUUNBQ1FZQ0FCR3NoQkVFQUlRRURRQ0FBSUFGQkFYUnFJZ1VnQWlBRkxnRUFiRUVQZGtFQmFrRUJkanNCQUNBQ0lBUnNRUTkxUVFGcVFRRjFJQUpxSVFJZ0FVRUJhaUlCSUFOSERRQUxDeUFBSUFOQkFYUnFJZ0FnQWlBQUxnRUFiRUVQZGtFQmFrRUJkanNCQUF2SkNBSUtmd0YrSXdCQndBSnJJZ1FrQUVFQklRTWdBa0VCVGdSQVFaQUpRYUFKSUFKQkVFWWJJUWtEUUNBRVFlQUJhaUFGSUFscUxRQUFRUUowYWlBQklBVkJBWFJxTGdFQUlnWkJDSFZCQVhSQjBBNXFJZ2N1QVFJZ0J5NEJBQ0lIYXlBR1FmOEJjV3dnQjBFSWRHcEJBM1ZCQVdwQkFYVTJBZ0FnQlVFQmFpSUZJQUpIRFFBTElBUW9BdUFCSVFVTFFZQ0FCQ0VHSUFSQmdJQUVOZ0tnQVNBRVFRQWdCV3NpQlRZQ3BBRWdBa0VCZFNFSEFrQWdBa0VFU0NJTERRQWdCU0VCQTBBZ0JFR2dBV29nQTBFQmFpSUpRUUowYWlJTUlBWkJBWFFnQkVIZ0FXb2dBMEVEZEdvb0FnQWlEYXdpRGlBQnJINUNENGhDQVh4Q0FZaW5hellDQUNBRFFRSjBJZ2dnQkVHZ0FXcHFJUW9nQkNBRFFRSlBCSDhnQ2lBRUlBaHFLQUtZQVNJRklBRnFJQWFzSUE1K1FnK0lRZ0Y4UWdHSXAyczJBZ0FnQTBFQ1J3UkFBMEFnQkVHZ0FXb2dBMEVCYXlJQlFRSjBhaUlJSUFOQkFuUWdCR29vQXBRQklnWWdDQ2dDQUdvZ0Jhd2dEbjVDRDRoQ0FYeENBWWluYXpZQ0FDQURRUU5LSVFnZ0FTRURJQVloQlNBSURRQUxDeUFFS0FLa0FRVWdCUXNnRFdzaUJUWUNwQUVnQnlBSlJnMEJJQXdvQWdBaEFTQUtLQUlBSVFZZ0NTRUREQUFMQUF0QmdJQUVJUVlnQkVHQWdBUTJBbUFnQkVFQUlBUW9BdVFCYXlJRk5nSmtBa0FnQ3cwQUlBUkI0QUZxUVFSeUlRdEJBU0VESUFVaEFRTkFJQVJCNEFCcUlBTkJBV29pQ1VFQ2RHb2lEQ0FHUVFGMElBc2dBMEVEZEdvb0FnQWlEYXdpRGlBQnJINUNENGhDQVh4Q0FZaW5hellDQUNBRFFRSjBJZ2dnQkVIZ0FHcHFJUW9nQkNBRFFRSlBCSDhnQ2lBRUlBaHFLQUpZSWdVZ0FXb2dCcXdnRG41Q0Q0aENBWHhDQVlpbmF6WUNBQ0FEUVFKSEJFQURRQ0FFUWVBQWFpQURRUUZySWdGQkFuUnFJZ2dnQTBFQ2RDQUVhaWdDVkNJR0lBZ29BZ0JxSUFXc0lBNStRZytJUWdGOFFnR0lwMnMyQWdBZ0EwRURTaUVJSUFFaEF5QUdJUVVnQ0EwQUN3c2dCQ2dDWkFVZ0JRc2dEV3NpQlRZQ1pDQUhJQWxHRFFFZ0RDZ0NBQ0VCSUFvb0FnQWhCaUFKSVFNTUFBc0FDeUFDUVFKT0JFQWdCMEVCSUFkQkFVb2JJUW9nQkNnQ1lDRUdJQVFvQXFBQklRRkJBQ0VEQTBBZ0JDQURRUUowYWtFQUlBTkJBV29pQlVFQ2RDSUhJQVJCNEFCcWFpZ0NBQ0lKSUFacklnWWdBU0FFUWFBQmFpQUhhaWdDQUNJSGFpSUJhbXMyQWdBZ0JDQURRWDl6SUFKcVFRSjBhaUFHSUFGck5nSUFJQWtoQmlBSElRRWdCU0lESUFwSERRQUxDeUFBSUFRZ0FoQjNBa0FnQUNBQ0VCME5BRUVBSVFVZ0FrRUJUZ1JBQTBBZ0JDQUNRWDRnQlhSQmdJQUVhaEFwUVFBaEF3TkFJQUFnQTBFQmRHb2dCQ0FEUVFKMGFpZ0NBRUVFZGtFQmFrRUJkanNCQUNBRFFRRnFJZ01nQWtjTkFBc2dBQ0FDRUIwaEFTQUZRUTVMRFFJZ0JVRUJhaUVGSUFGRkRRQU1BZ3NBQ3dOQUlBUWdBa0YrSUFWMFFZQ0FCR29RS1NBQUlBSVFIU0VCSUFWQkRrc05BU0FGUVFGcUlRVWdBVVVOQUFzTElBUkJ3QUpxSkFBTG54RUNEMzhCZmlNQVFkQUFheUlGSkFBZ0JTQUJOZ0pNSUFWQk4yb2hFeUFGUVRocUlSRkJBQ0VCQWtBRFFBSkFJQTVCQUVnTkFFSC8vLy8vQnlBT2F5QUJTQVJBUVp6N0FVRTlOZ0lBUVg4aERnd0JDeUFCSUE1cUlRNExJQVVvQWt3aUNpRUJBa0FDUUFKQUlBb3RBQUFpQmdSQUEwQUNRQUpBSUFaQi93RnhJZ1pGQkVBZ0FTRUdEQUVMSUFaQkpVY05BU0FCSVFZRFFDQUJMUUFCUVNWSERRRWdCU0FCUVFKcUlnZzJBa3dnQmtFQmFpRUdJQUV0QUFJaENTQUlJUUVnQ1VFbFJnMEFDd3NnQmlBS2F5RUJJQUFFUUNBQUlBb2dBUkFRQ3lBQkRRWWdCU2dDVENFQklBVUNmd0pBSUFVb0Frd3NBQUZCTUd0QkNrOE5BQ0FCTFFBQ1FTUkhEUUFnQVN3QUFVRXdheUVRUVFFaEVpQUJRUU5xREFFTFFYOGhFQ0FCUVFGcUN5SUJOZ0pNUVFBaER3SkFJQUVzQUFBaUMwRWdheUlJUVI5TEJFQWdBU0VHREFFTElBRWhCa0VCSUFoMElnbEJpZEVFY1VVTkFBTkFJQVVnQVVFQmFpSUdOZ0pNSUFrZ0QzSWhEeUFCTEFBQklndEJJR3NpQ0VFZ1R3MEJJQVloQVVFQklBaDBJZ2xCaWRFRWNRMEFDd3NDUUNBTFFTcEdCRUFnQlFKL0FrQWdCaXdBQVVFd2EwRUtUdzBBSUFVb0Frd2lBUzBBQWtFa1J3MEFJQUVzQUFGQkFuUWdCR3BCd0FGclFRbzJBZ0FnQVN3QUFVRURkQ0FEYWtHQUEyc29BZ0FoREVFQklSSWdBVUVEYWd3QkN5QVNEUVpCQUNFU1FRQWhEQ0FBQkVBZ0FpQUNLQUlBSWdGQkJHbzJBZ0FnQVNnQ0FDRU1DeUFGS0FKTVFRRnFDeUlCTmdKTUlBeEJmMG9OQVVFQUlBeHJJUXdnRDBHQXdBQnlJUThNQVFzZ0JVSE1BR29RVENJTVFRQklEUVFnQlNnQ1RDRUJDMEYvSVFjQ1FDQUJMUUFBUVM1SERRQWdBUzBBQVVFcVJnUkFBa0FnQVN3QUFrRXdhMEVLVHcwQUlBVW9Ba3dpQVMwQUEwRWtSdzBBSUFFc0FBSkJBblFnQkdwQndBRnJRUW8yQWdBZ0FTd0FBa0VEZENBRGFrR0FBMnNvQWdBaEJ5QUZJQUZCQkdvaUFUWUNUQXdDQ3lBU0RRVWdBQVIvSUFJZ0FpZ0NBQ0lCUVFScU5nSUFJQUVvQWdBRlFRQUxJUWNnQlNBRktBSk1RUUpxSWdFMkFrd01BUXNnQlNBQlFRRnFOZ0pNSUFWQnpBQnFFRXdoQnlBRktBSk1JUUVMUVFBaEJnTkFJQVloQ1VGL0lRMGdBU3dBQUVIQkFHdEJPVXNOQ0NBRklBRkJBV29pQ3pZQ1RDQUJMQUFBSVFZZ0N5RUJJQVlnQ1VFNmJHcEI3L01CYWkwQUFDSUdRUUZyUVFoSkRRQUxBa0FDUUNBR1FSTkhCRUFnQmtVTkNpQVFRUUJPQkVBZ0JDQVFRUUowYWlBR05nSUFJQVVnQXlBUVFRTjBhaWtEQURjRFFBd0NDeUFBUlEwSUlBVkJRR3NnQmlBQ0VFc2dCU2dDVENFTERBSUxJQkJCZjBvTkNRdEJBQ0VCSUFCRkRRY0xJQTlCLy85N2NTSUlJQThnRDBHQXdBQnhHeUVHUVFBaERVR1U5QUVoRUNBUklROENRQUpBQWtBQ2Z3SkFBa0FDUUFKQUFuOENRQUpBQWtBQ1FBSkFBa0FDUUNBTFFRRnJMQUFBSWdGQlgzRWdBU0FCUVE5eFFRTkdHeUFCSUFrYklnRkIyQUJyRGlFRUZCUVVGQlFVRkJRT0ZBOEdEZzRPRkFZVUZCUVVBZ1VERkJRSkZBRVVGQVFBQ3dKQUlBRkJ3UUJyRGdjT0ZBc1VEZzRPQUFzZ0FVSFRBRVlOQ1F3VEN5QUZLUU5BSVJSQmxQUUJEQVVMUVFBaEFRSkFBa0FDUUFKQUFrQUNRQUpBSUFsQi93RnhEZ2dBQVFJREJCb0ZCaG9MSUFVb0FrQWdEallDQUF3WkN5QUZLQUpBSUE0MkFnQU1HQXNnQlNnQ1FDQU9yRGNEQUF3WEN5QUZLQUpBSUE0N0FRQU1GZ3NnQlNnQ1FDQU9PZ0FBREJVTElBVW9Ba0FnRGpZQ0FBd1VDeUFGS0FKQUlBNnNOd01BREJNTElBZEJDQ0FIUVFoTEd5RUhJQVpCQ0hJaEJrSDRBQ0VCQ3lBRktRTkFJQkVnQVVFZ2NSQ0pBU0VLSUFaQkNIRkZEUU1nQlNrRFFGQU5BeUFCUVFSMlFaVDBBV29oRUVFQ0lRME1Bd3NnQlNrRFFDQVJFSWdCSVFvZ0JrRUljVVVOQWlBSElCRWdDbXNpQVVFQmFpQUJJQWRJR3lFSERBSUxJQVVwQTBBaUZFSi9Wd1JBSUFWQ0FDQVVmU0lVTndOQVFRRWhEVUdVOUFFTUFRc2dCa0dBRUhFRVFFRUJJUTFCbGZRQkRBRUxRWmIwQVVHVTlBRWdCa0VCY1NJTkd3c2hFQ0FVSUJFUWh3RWhDZ3NnQmtILy8zdHhJQVlnQjBGL1Noc2hCaUFGS1FOQUlSUUNRQ0FIRFFBZ0ZGQkZEUUJCQUNFSElCRWhDZ3dNQ3lBSElCUlFJQkVnQ210cUlnRWdBU0FIU0JzaEJ3d0xDeUFGS0FKQUlnRkJudlFCSUFFYklnb2dCeENQQVNJQklBY2dDbW9nQVJzaER5QUlJUVlnQVNBS2F5QUhJQUViSVFjTUNnc2dCd1JBSUFVb0FrQU1BZ3RCQUNFQklBQkJJQ0FNUVFBZ0JoQU5EQUlMSUFWQkFEWUNEQ0FGSUFVcEEwQStBZ2dnQlNBRlFRaHFOZ0pBUVg4aEJ5QUZRUWhxQ3lFSlFRQWhBUUpBQTBBZ0NTZ0NBQ0lJUlEwQkFrQWdCVUVFYWlBSUVFMGlDa0VBU0NJSURRQWdDaUFISUFGclN3MEFJQWxCQkdvaENTQUhJQUVnQ21vaUFVc05BUXdDQ3d0QmZ5RU5JQWdOQ3dzZ0FFRWdJQXdnQVNBR0VBMGdBVVVFUUVFQUlRRU1BUXRCQUNFSklBVW9Ba0FoQ3dOQUlBc29BZ0FpQ0VVTkFTQUZRUVJxSUFnUVRTSUlJQWxxSWdrZ0FVb05BU0FBSUFWQkJHb2dDQkFRSUF0QkJHb2hDeUFCSUFsTERRQUxDeUFBUVNBZ0RDQUJJQVpCZ01BQWN4QU5JQXdnQVNBQklBeElHeUVCREFnTElBQWdCU3NEUUNBTUlBY2dCaUFCUVFBUkl3QWhBUXdIQ3lBRklBVXBBMEE4QURkQkFTRUhJQk1oQ2lBSUlRWU1CQXNnQlNBQlFRRnFJZ2cyQWt3Z0FTMEFBU0VHSUFnaEFRd0FDd0FMSUE0aERTQUFEUVFnRWtVTkFrRUJJUUVEUUNBRUlBRkJBblJxS0FJQUlnQUVRQ0FESUFGQkEzUnFJQUFnQWhCTFFRRWhEU0FCUVFGcUlnRkJDa2NOQVF3R0N3dEJBU0VOSUFGQkNrOE5CQU5BSUFRZ0FVRUNkR29vQWdBTkFTQUJRUUZxSWdGQkNrY05BQXNNQkF0QmZ5RU5EQU1MSUFCQklDQU5JQThnQ21zaUNTQUhJQWNnQ1VnYklnaHFJZ3NnRENBTElBeEtHeUlCSUFzZ0JoQU5JQUFnRUNBTkVCQWdBRUV3SUFFZ0N5QUdRWUNBQkhNUURTQUFRVEFnQ0NBSlFRQVFEU0FBSUFvZ0NSQVFJQUJCSUNBQklBc2dCa0dBd0FCekVBME1BUXNMUVFBaERRc2dCVUhRQUdva0FDQU5DNUlCQVFOOFJBQUFBQUFBQVBBL0lBQWdBS0lpQWtRQUFBQUFBQURnUDZJaUE2RWlCRVFBQUFBQUFBRHdQeUFFb1NBRG9TQUNJQUlnQWlBQ1JKQVZ5eG1nQWZvK29rUjNVY0VXYk1GV3Y2Q2lSRXhWVlZWVlZhVS9vS0lnQWlBQ29pSURJQU9pSUFJZ0FrVFVPSWkrNmZxb3ZhSkV4TEcwdlo3dUlUNmdva1N0VXB5QVQzNlN2cUNpb0tJZ0FDQUJvcUdnb0F0NEFRRjlBa0FnQVVFQlNBMEFRUUFoQXdOQUlBUWdBQ0FEUVFKMGFpb0NBQ0lFSUFTVWtpRUVJQU5CQVdvaUF5QUJSdzBBQ3lBQlFRRklEUUJEQUFDQVB5QUVRMzBka0NhU2taVWdBcFFoQWtFQUlRTURRQ0FBSUFJZ0FDb0NBSlE0QWdBZ0FFRUVhaUVBSUFOQkFXb2lBeUFCUncwQUN3c0w5UWNEQ1g4RWZRSjhBa0FnQkVFQmRDQUJUZzBBSUFWRkRRQWdBYklnQlVFQ2RFSEUzUUZxS0FJQUlBUnNJQUZxc3BVaUR5QVBsRU1BQUFBL2xDSVBROXNQeVQrVXV4QlFJUk5EQUFDQVB5QVBrMFBiRDhrL2xMc1FVQ0VVUVFBaEJTQUJJQU5CQTNST0JFQWdBMEVDZFNFSVFRRWhCQU5BSUFRaUJVRUJhaUVFSUFVZ0JTQUZiR29nQTJ3Z0NHb2dBVWdOQUFzTElBRWdBMjRoQ2lBRFFRRklEUUFnRTdZaER5QVV0aUVSSUFwQkFXc2lDeUFGUVFGMGF5RUlJQW9nQldzaERDQUtRUU5ySVFrZ0FrRi9TaUVOUVFBaEFnTkFJQUlnQ213aEJnSkFJQTFGQkVBQ1FDQUZSUTBBUVFBaEFTQUFJQVpCQW5ScUlnY2hCQ0FNUVFGT0JFQURRQ0FFSUFWQkFuUnFJZzRnQkNvQ0FDSVFJQStVSUE0cUFnQWlFaUFSbEpJNEFnQWdCQ0FRSUJHVUlCSWdENVNUT0FJQUlBUkJCR29oQkNBQlFRRnFJZ0VnREVjTkFBc0xJQWhCQUVnTkFDQUhJQWhCQW5ScUlRUWdDQ0VCQTBBZ0JDQUZRUUowYWlJSElBUXFBZ0FpRUNBUGxDQUhLZ0lBSWhJZ0VaU1NPQUlBSUFRZ0VDQVJsQ0FTSUErVWt6Z0NBQ0FFUVFScklRUWdBVUVBU2lFSElBRkJBV3NoQVNBSERRQUxDeUFBSUFaQkFuUnFJUVlnQzBFQlRnUkFJQVlxQWdBaEVFRUFJUUVnQmlFRUEwQWdCQ0FRSUErVUlBUXFBZ1FpRWlBUmxKTTRBZ0FnQkNBUUlCR1VJQklnRDVTU0loQTRBZ1FnQkVFRWFpRUVJQUZCQVdvaUFTQUxSdzBBQ3dzZ0NVRUFTQTBCSUFZZ0NVRUNkR29oQkNBSklRRURRQ0FFSUFRcUFnQWlFQ0FSbENBRUtnSUVJaElnRDVTU09BSUVJQVFnRUNBUGxDQVNJQkdVa3pnQ0FDQUVRUVJySVFRZ0FVRUFTaUVHSUFGQkFXc2hBU0FHRFFBTERBRUxJQUFnQmtFQ2RHb2hCaUFMUVFGT0JFQWdCaW9DQUNFUVFRQWhBU0FHSVFRRFFDQUVJQkFnRDVRZ0JDb0NCQ0lTSUJHVWtqZ0NBQ0FFSUJJZ0Q1UWdFQ0FSbEpNaUVEZ0NCQ0FFUVFScUlRUWdBVUVCYWlJQklBdEhEUUFMQ3lBSlFRQk9CRUFnQmlBSlFRSjBhaUVFSUFraEFRTkFJQVFnQkNvQ0JDSVFJQStVSUFRcUFnQWlFaUFSbEpNNEFnUWdCQ0FTSUErVUlCQWdFWlNTT0FJQUlBUkJCR3NoQkNBQlFRQktJUWNnQVVFQmF5RUJJQWNOQUFzTElBVkZEUUJCQUNFQklBWWhCQ0FNUVFGT0JFQURRQ0FFSUFWQkFuUnFJZ2NnQnlvQ0FDSVFJQkdVSUFRcUFnQWlFaUFQbEpNNEFnQWdCQ0FTSUJHVUlCQWdENVNTT0FJQUlBUkJCR29oQkNBQlFRRnFJZ0VnREVjTkFBc0xJQWhCQUVnTkFDQUdJQWhCQW5ScUlRUWdDQ0VCQTBBZ0JDQUZRUUowYWlJR0lBWXFBZ0FpRUNBUmxDQUVLZ0lBSWhJZ0Q1U1RPQUlBSUFRZ0VpQVJsQ0FRSUErVWtqZ0NBQ0FFUVFScklRUWdBVUVBU2lFR0lBRkJBV3NoQVNBR0RRQUxDeUFDUVFGcUlnSWdBMGNOQUFzTEM5Y0NBUU4vSXdCQkVHc2lBeVFBUVg4aEJRSkFBa0FnQVVILy9BQk1CRUFnQVVIQVBrWU5BU0FCUWVEZEFFWU5BUXdDQ3lBQlFZRDlBRVlOQUNBQlFZRDNBa1lOQUNBQlFjQzdBVWNOQVFzZ0FrRUJhMEVCU3cwQUlBQkJBQUovSUFOQjZNSUFOZ0lNUVFBTEJIOUJBQVVnQXlBREtBSU1RUU5xUVh4eE5nSU1JQU1vQWd4Qm9EMG9BZ0JCQW5SQjRNQUFhaUFDYkVHa1BTZ0NBRUVGZEdwcVFiUUJhZ3NRQlNFQVFYMGhCU0FEUWVqQ0FEWUNDQ0FESUFNb0FnaEJBMnBCZkhFaUJEWUNDQ0FBSUFJMkFqQWdBQ0FDTmdJSUlBQkIyQUEyQWdRZ0FDQUJOZ0lZSUFBZ0FUWUNEQ0FBSUFJMkFoQWdBQ0FFUWRnQWFpSUVOZ0lBSUFCQjJBQnFFRVFOQUNBQUlBUnFJZ1FnQVNBQ0VGd05BRUVBSVFVZ0EwRUFOZ0lBSUFSQm9NNEFJQU1RQnhvZ0FDQUJRZi8vQTNGQmtBTnVOZ0pBSUFCQkFEWUNQQ0FBUVFBMkFpd0xJQU5CRUdva0FDQUZDK3NCQVFaL0lBQWdBQ2dDSUNBQUtBSWtJZ1FnQXlBQ2Eyd2lBMnNpQmpZQ0lDQUFJQUVFZnlBRUlBSWdBV3RzQlNBQUtBSWNJQU5yQ3lJQ05nSWNJQUpCZ0lDQUJFMEVRQ0FBS0FJWUlRTWdBQ2dDS0NFRUlBQW9BaFFoQnlBQUtBSUVJUWdEUUNBQUlBSkJDSFFpQ1RZQ0hDQUFJQWRCQ0dvaUJ6WUNGRUVBSVFFZ0F5QUlTUVJBSUFBZ0EwRUJhaUlGTmdJWUlBQW9BZ0FnQTJvdEFBQWhBU0FGSVFNTElBQWdBVFlDS0NBQUlBWkJDSFJCZ1A3Ly93ZHhJQUVnQkVFSWRISkJBWFpCL3dGeGNrSC9BWE1pQmpZQ0lDQUNRWUdBQWtraEJTQUJJUVFnQ1NFQ0lBVU5BQXNMQ3dNQUFRdWJCZ0lLZnc5OUlBUkJCRTRFUUNBRVFRTnJJUXdnQTBGOGNTRUxJQU5CQTJzaERTQURRUVJJSVE0RFFDQUJJQWxCQW5RaUNtb2lCVUVNYWlFSElBVXFBZ2doRVNBRktnSUVJUllnQlNvQ0FDRVhRd0FBQUFBaEZFTUFBQUFBSVJoREFBQUFBQ0VaUXdBQUFBQWhEeUFBSVFaQkFDRUlRd0FBQUFBaEVFTUFBQUFBSVJKREFBQUFBQ0VUUXdBQUFBQWhGVUVBSVFVZ0RrVUVRQU5BSUJRZ0Jpb0NBQ0lhSUFjcUFnQWlGWlNTSUFZcUFnUWlHeUFIS2dJRUloQ1VraUFHS2dJSUlod2dCeW9DQ0NJU2xKSWdCaW9DRENJZElBY3FBZ3dpRTVTU0lSUWdHQ0FSSUJxVWtpQVZJQnVVa2lBUUlCeVVraUFTSUIyVWtpRVlJQmtnRmlBYWxKSWdFU0FibEpJZ0ZTQWNsSklnRUNBZGxKSWhHU0FQSUJjZ0dwU1NJQllnRzVTU0lCRWdISlNTSUJVZ0haU1NJUThnQjBFUWFpRUhJQVpCRUdvaEJpQVFJUmNnRXlFUklCSWhGaUFJUVFScUlnZ2dEVWdOQUFzZ0R5RVFJQmtoRWlBWUlSTWdDeUVGQ3lBRlFRRnlJUWdDZnlBRElBVk1CRUFnQmlFRklBY01BUXNnQmtFRWFpRUZJQlFnQmlvQ0FDSVBJQWNxQWdBaUZaU1NJUlFnRXlBUklBK1VraUVUSUJJZ0ZpQVBsSkloRWlBUUlCY2dENVNTSVJBZ0IwRUVhZ3NoQnlBSVFRRnFJUVlDZnlBRElBaE1CRUFnQlNFSUlBY01BUXNnQlVFRWFpRUlJQlFnQlNvQ0FDSVBJQWNxQWdBaUY1U1NJUlFnRXlBVklBK1VraUVUSUJJZ0VTQVBsSkloRWlBUUlCWWdENVNTSVJBZ0IwRUVhZ3NoQlNBRElBWktCRUFnRkNBSUtnSUFJZzhnQlNvQ0FKU1NJUlFnRWlBVklBK1VraUVTSUJBZ0VTQVBsSkloRUNBVElCY2dENVNTSVJNTElBSWdDbW9nRURnQ0FDQUNJQXBCQkhKcUlCSTRBZ0FnQWlBS1FRaHlhaUFUT0FJQUlBSWdDa0VNY21vZ0ZEZ0NBQ0FKUVFScUlna2dERWdOQUFzTEFrQWdCQ0FKVEEwQUlBTkJBRW9FUUFOQUlBRWdDVUVDZENJSWFpRUxRUUFoQmtNQUFBQUFJUkVEUUNBUklBQWdCa0VDZENJRmFpb0NBQ0FGSUF0cUtnSUFsSkloRVNBR1FRRnFJZ1lnQTBjTkFBc2dBaUFJYWlBUk9BSUFJQWxCQVdvaUNTQUVSdzBBREFJTEFBc2dBaUFKUVFKMGFrRUFJQVFnQ1d0QkFuUVFCUm9MQzVVQ0FnTi9BWDBqQUNJRklRZ2dCVUdBSUdzaUJTUUFBbjhnQXdSQUlBVWdBRUdBSUJBRUdpQURRUUZPQkVBRFFDQUZJQVpCQW5RaUIyb2dBQ0FIYWlvQ0FDQUNJQWRxS2dJQUlnbVVPQUlBSUFVZ0JrRi9jMEdBQ0dwQkFuUWlCMm9nQ1NBQUlBZHFLZ0lBbERnQ0FDQUdRUUZxSWdZZ0EwY05BQXNMSUFVaEFBc2dBQXNnQUNBQlFZQUlJQVJySWdNZ0JFRUJhaEF6UVFBaEFpQUVRUUJPQkVBRFFFTUFBQUFBSVFrZ0FpQURhaUlHUVlBSVNBUkFBMEFnQ1NBQUlBWkJBblJxS2dJQUlBQWdCaUFDYTBFQ2RHb3FBZ0NVa2lFSklBWkJBV29pQmtHQUNFY05BQXNMSUFFZ0FrRUNkR29pQlNBSklBVXFBZ0NTT0FJQUlBSWdCRWNoQlNBQ1FRRnFJUUlnQlEwQUN3c2dDQ1FBQzlrREFnRi9DWDBnQVVFTWFpRURJQUVxQWdnaEN5QUJLZ0lFSVFZZ0FTb0NBQ0VGQW44Z0Fpb0NEQ0VISUFJcUFnZ2hDQ0FDS2dJRUlRa2dBaW9DQUNFS1FRQWhBUU5BSUFJZ0FDb0NBQ0lFSUFNcUFnQWlESlFnQjVJaUJ6Z0NEQ0FDSUFzZ0JKUWdDSklpQ0RnQ0NDQUNJQVlnQkpRZ0NaSWlDVGdDQkNBQ0lBVWdCSlFnQ3BJaUNqZ0NBQ0FDSUFjZ0FDb0NCQ0lFSUFNcUFnUWlCWlNTSWdjNEFnd2dBaUFJSUF3Z0JKU1NJZ2c0QWdnZ0FpQUpJQXNnQkpTU0lnazRBZ1FnQWlBS0lBWWdCSlNTSWdvNEFnQWdBaUFISUFBcUFnZ2lCQ0FES2dJSUlnYVVraUlIT0FJTUlBSWdDQ0FGSUFTVWtpSUlPQUlJSUFJZ0NTQU1JQVNVa2lJSk9BSUVJQUlnQ2lBTElBU1VraUlLT0FJQUlBSWdCeUFBS2dJTUlnUWdBeW9DRENJTGxKSWlCemdDRENBQ0lBZ2dCaUFFbEpJaUNEZ0NDQ0FDSUFrZ0JTQUVsSklpQ1RnQ0JDQUNJQW9nRENBRWxKSWlDamdDQUNBRFFSQnFJUU1nQUVFUWFpRUFJQUZCQkdvaUFVRVZTQTBBQzBFQUN3UkFJQU1xQWdBaERDQUNJQVVnQUNvQ0FDSUZsQ0FDS2dJQWtqZ0NBQ0FDSUFZZ0JaUWdBaW9DQkpJNEFnUWdBaUFMSUFXVUlBSXFBZ2lTT0FJSUlBSWdCU0FNbENBQ0tnSU1ramdDRENBRFFRUnFJUU1nQUVFRWFpRUFDd3VvQWdJR2Z3UjlJQUVxQWdBaENpQUFRUUFnQWtFQ2RCQUZJUVFDUUNBQktnSUFRd0FBQUFCYkRRQWdBa0VBSUFKQkFFb2JJUWRCQVNFRkEwQWdBeUFIUmcwQlFRQWhBa01BQUFBQUlRa2dBd1JBQTBBZ0NTQUVJQUpCQW5ScUtnSUFJQUVnQXlBQ2EwRUNkR29xQWdDVWtpRUpJQUpCQVdvaUFpQURSdzBBQ3dzZ0JDQURRUUowYWlBSklBRWdBMEVCYWlJQVFRSjBhaW9DQUpLTUlBcVZJZ2s0QWdBZ0F3UkFJQVZCQVhZaENFRUFJUUlEUUNBRUlBSkJBblJxSWdZZ0Jpb0NBQ0lMSUFrZ0JDQURJQUpCZjNOcVFRSjBhaUlHS2dJQUlneVVramdDQUNBR0lBd2dDU0FMbEpJNEFnQWdBa0VCYWlJQ0lBaEhEUUFMQ3lBRlFRRnFJUVVnQUNFRElBb2dDaUFKSUFtVWxKTWlDaUFCS2dJQVEyOFNnenFVWFVFQmN3MEFDd3NMelFnQkMzOUJmeUVQQWtBZ0FVRUFTQTBBSUFSRkRRQkJmQ0VQSUFGRkRRQUNmeUFBTFFBQUlnNUJnQUZ4QkVCQmdQY0NJQTVCQTNaQkEzRjBRWkFEYmd3QkMwSEFCMEhnQXlBT1FRaHhHeUFPUWVBQWNVSGdBRVlOQUJwQndCWWdEa0VEZGtFRGNTSUhRUU5HRFFBYVFZRDNBaUFIZEVIa0FHNExJUXRCQVNFSUlBQkJBV29oQ1NBQlFRRnJJZ2NoQ2dKQUFrQUNRQUpBQWtBQ1FBSkFJQTVCQTNFaURBNERBd0FCQWdzZ0FnUkFRUUloQ0VFQklRMUJBQ0VNSUFjaENnd0VDeUFIUVFGeERRWWdCQ0FIUVFGMklnbzdBUUJCQWlFSVFRQWhEQXdFQ3lBQlFRRk1CRUFnQkVILy93TTdBUUJCZkE4TElBa3RBQUFpREVIOEFVOEVRRUVDSVFnZ0FVRUNUQVJBSUFSQi8vOERPd0VBUVh3UEN5QUFMUUFDUVFKMElBeHFJUXdMSUFRZ0REc0JBQ0FISUFocklnY2dERWdOQlNBSElBeHJJUW9nQ0NBSmFpRUpRUUloQ0VFQUlRd01BUXNnQVVFQ1NBMEVJQUF0QUFFaURVRS9jU0lJUlEwRUlBZ2dDMnhCZ0MxTERRUWdBRUVDYWlFS0lBRkJBbXNoQVVFQUlRd0NRQ0FOUWNBQWNVVUVRQ0FLSVFrTUFRc0RRQ0FCUVFGSURRWWdERUYrSUFvdEFBQWlDU0FKUWY4QlJpSUxHMEgvQVhFaUNXb2hEQ0FCSUFsQmYzTnFJUUVnQ2tFQmFpSUpJUW9nQ3cwQUN5QUJRUUJJRFFVTElBMUJnQUZ4QkVCQkFDRU5JQWhCQWtrRVFDQUJJZ2NoQ2d3Q0N5QUlRUUZySVJFZ0FTSUtJUWNEUUNBRUlBMUJBWFJxSVJBZ0IwRUFUQVJBSUJCQi8vOERPd0VBUVh3UEMwRUJJUXNnQ1MwQUFDSUJRZndCVHdSQUlBZEJBVXdFUUNBUVFmLy9BenNCQUVGOER3dEJBaUVMSUFrdEFBRkJBblFnQVdvaEFRc2dFQ0FCT3dFQUlBY2dDMnNpQnlBQlNBMEdJQWtnQzJvaENTQUtJQXRySUFGcklRb2dEVUVCYWlJTklCRkhEUUFMUVFBaERTQUtRUUJPRFFFTUJRdEJBU0VOSUFJRVFDQUhJUW9nQVNFSERBSUxJQUVnQ0cwaUNpQUliQ0FCUncwRUlBaEJBa2tOQWlBSVFRRnJJUXRCQUNFSEEwQWdCQ0FIUVFGMGFpQUtPd0VBSUFkQkFXb2lCeUFMUncwQUN5QUJJUWNMSUFKRkRRRUxJQVFnQ0VFQmRHcEJBbXNoQzBILy93TWhBUUovUVg4Z0IwRUJTQTBBR2lBSkxRQUFJZ0pCL0FGSkJFQWdBaUVCUVFFTUFRdEJmeUFIUVFKSURRQWFJQWt0QUFGQkFuUWdBbW9oQVVFQ0N5RUNJQXNnQVRzQkFDQUJRUkIwUVJCMUlndEJBRWdOQWlBSElBSnJJZ2NnQzBnTkFpQUNJQWxxSVFrZ0RRUkFJQWdnQzJ3Z0Iwb05BeUFJUVFKSkRRSWdCQ0FCT3dFQVFRRWhBU0FJUVFGcklnSkJBVVlOQWlBRUlBSkJBWFJxSVFjRFFDQUVJQUZCQVhScUlBY3ZBUUE3QVFBZ0FVRUJhaUlCSUFKSERRQUxEQUlMSUFJZ0Myb2dDa29OQWd3QkN5QUtRZnNKU2cwQklBaEJBWFFnQkdwQkFtc2dDanNCQUFzZ0JRUkFJQVVnQ1NBQWF6WUNBQXNnQ0FSQVFRQWhBUU5BSUFrZ0JDQUJRUUYwYWk0QkFHb2hDU0FCUVFGcUlnRWdDRWNOQUFzTElBWUVRQ0FHSUF3Z0FHc2dDV28yQWdBTElBTUVRQ0FESUE0NkFBQUxJQWdoRHdzZ0R3dGFBUVIvUVFGQkh5QUFaMnRCQVhVaUFuUWhBd05BSUFCQkFDQUVRUUYwSUFOcUlBSjBJZ0VnQUNBQlNTSUJHMnNoQUVFQUlBTWdBUnNnQkdvaEJDQUNRUUJLSVFFZ0EwRUJkaUVESUFKQkFXc2hBaUFCRFFBTElBUUx4UVFDQ0g4RWZTTUFJUWNDUUNBRFFRSkhEUUFnQkVFQlJ3MEFJQVlxQWdRaER5QUdLZ0lBSVJBZ0FrRUJUZ1JBSUFBb0FnUWhBeUFBS0FJQUlRQWdCU29DQUNFUlFRQWhCUU5BSUFNZ0JVRUNkQ0lFYWlvQ0FDRVNJQUVnQlVFRGRDSUhhaUFRSUFBZ0JHb3FBZ0JEWUVLaURaS1NJaEJEQUFBQU9KUTRBZ0FnQVNBSFFRUnlhaUFQSUJKRFlFS2lEWktTSWc5REFBQUFPSlE0QWdBZ0VTQVBsQ0VQSUJFZ0VKUWhFQ0FGUVFGcUlnVWdBa2NOQUFzTElBWWdEemdDQkNBR0lCQTRBZ0FQQ3lBRFFRRWdBMEVCU2hzaEN5QUNJQVJ0SVFrZ0J5QUNRUUowUVE5cVFYQnhheUVLSUFVcUFnQWhFRUVBSVFjQ1FDQUVRUUpPQkVBRFFFRUFJUVVnQmlBSFFRSjBJZ2hxSWd3cUFnQWhEeUFDUVFCS0JFQWdBQ0FJYWlnQ0FDRU5BMEFnQ2lBRlFRSjBJZzVxSUE4Z0RTQU9haW9DQUVOZ1FxSU5rcElpRHpnQ0FDQVFJQStVSVE4Z0JVRUJhaUlGSUFKSERRQUxDeUFNSUE4NEFnQWdDVUVCVGdSQUlBRWdDR29oQ0VFQUlRVURRQ0FJSUFNZ0JXeEJBblJxSUFvZ0JDQUZiRUVDZEdvcUFnQkRBQUFBT0pRNEFnQWdCVUVCYWlJRklBbEhEUUFMQ3lBSFFRRnFJZ2NnQzBjTkFBd0NDd0FMSUFKQkFVZ2hDUU5BSUFZZ0IwRUNkQ0lFYWlJS0tnSUFJUThnQ1VVRVFDQUJJQVJxSVFnZ0FDQUVhaWdDQUNFRVFRQWhCUU5BSUFnZ0F5QUZiRUVDZEdvZ0R5QUVJQVZCQW5ScUtnSUFRMkJDb2cyU2tpSVBRd0FBQURpVU9BSUFJQkFnRDVRaER5QUZRUUZxSWdVZ0FrY05BQXNMSUFvZ0R6Z0NBQ0FIUVFGcUlnY2dDMGNOQUFzTEMyVUFJQUF0QUFBaUFFR0FBWEVFUUNBQklBQkJBM1pCQTNGMFFaQURiUThMSUFCQjRBQnhRZUFBUmdSQUlBQkJDSEVFUUNBQlFUSnREd3NnQVVIa0FHMFBDeUFBUVFOMlFRTnhJZ0JCQTBZRVFDQUJRVHhzUWVnSGJROExJQUVnQUhSQjVBQnRDLzBSQWhWL0hIMGdBQ2dDQ0NFSkl3QkJJR3NpRWtFQk5nSUFJQUJCREdvaERFRUJJUVFEUUNBTUlBTWlBa0VDZENJRlFRSnlhaThCQUNFR0lCSWdBa0VCYWlJRFFRSjBhaUFFSUFVZ0RHb3VBUUJzSWdRMkFnQWdCa0VCUncwQUN5QUpRUUFnQ1VFQVNoc2hGaUFEUVFKMElBQnFMZ0VLSVF3RFFDQU1JUVZCQUNFRFFRRWhEQUpBQWtBQ1FBSkFBa0FnQUNBQ0lna0VmeUFKUVFKMElBQnFMZ0VLSVF3Z0NVRUJkQVZCQUF0QkFYUnFMZ0VNUVFKckRnUUFBZ0VEQkFzZ0FTRUNJQklnQ1VFQ2RHb29BZ0FpQmtFQlNBMERBMEFnQWlBQ0tnSUFJaGdnQWlvQ0lDSVhremdDSUNBQ0lCY2dHSkk0QWdBZ0FpQUNRU1JxS2dJQUloZ2dBaW9DQkNJWGtqZ0NCQ0FDSUJjZ0dKTTRBaVFnQWlBQ0tnSUlJaHNnQWlvQ0tDSWFJQUpCTEdvcUFnQWlGNUpEOHdRMVA1UWlHWk00QWlnZ0FpQUNRUXhxS2dJQUloZ2dGeUFhazBQekJEVS9sQ0lYa3pnQ0xDQUNJQnNnR1pJNEFnZ2dBaUFYSUJpU09BSU1JQUlxQWpBaEdpQUNJQUlxQWhBaUdTQUNRVFJxS2dJQUloaVRPQUl3SUFJZ0dpQUNRUlJxS2dJQUloZVNPQUkwSUFJZ0Z5QWFremdDRkNBQ0lCZ2dHWkk0QWhBZ0FpQUNLZ0lZSWhzZ0FrRThhaW9DQUNJYUlBSXFBamdpRjVORDh3UTFQNVFpR1pNNEFqZ2dBaUFDUVJ4cUtnSUFJaGdnR2lBWGtrUHpCRFcvbENJWGt6Z0NQQ0FDSUJjZ0dKSTRBaHdnQWlBYklCbVNPQUlZSUFKQlFHc2hBaUFEUVFGcUlnTWdCa2NOQUFzTUF3c2dFaUFKUVFKMGFpZ0NBQ0VUSUFWQkFVWUVRQ0FCSVFJZ0UwRUJTQTBEQTBBZ0FpQUNLZ0lBSWh3Z0Fpb0NFQ0lna2lJWUlBSXFBZ2dpSVNBQ0tnSVlJaDJTSWhlVE9BSVFJQUlnR0NBWGtqZ0NBQ0FDUVJScUlBSXFBZ1FpR1NBQ0tnSVVJaGlTSWg0Z0FrRU1haW9DQUNJZklBSkJIR29xQWdBaUY1SWlHNU00QWdBZ0FpQVpJQmlUSWhvZ0lTQWRreUlaa2pnQ0hDQUNJQndnSUpNaUdDQWZJQmVUSWhlVE9BSVlJQUlnR2lBWmt6Z0NEQ0FDSUJnZ0Y1STRBZ2dnQWlBZUlCdVNPQUlFSUFKQklHb2hBaUFEUVFGcUlnTWdFMGNOQUFzTUF3c2dFMEVCU0EwQ0lBVkJBVWdOQWlBRlFRTnNJUThnQlVFQmRDRVFJQk1nRm5RaURVRURiQ0VVSUExQkFYUWhGU0FBS0FJd0lRWkJBQ0VMQTBBZ0FTQUxJQXhzUVFOMGFpRUNRUUFoRVNBR0lnTWhDQ0FESVFRRFFDQUNLZ0lBSVNRZ0FpQVFRUU4wYWlJT0lBZ3FBZ0FpS1NBT0tnSUVJaXFVSUE0cUFnQWlHeUFJS2dJRUlocVVraUlySUFJcUFnUWlMSklpSWlBRUtnSUFJaTBnQWlBRlFRTjBhaUlIS2dJRUlpT1VJQWNxQWdBaUhDQUVLZ0lFSWhtVWtpSWdJQU1xQWdBaUlTQUNJQTlCQTNScUlnb3FBZ1FpSFpRZ0Npb0NBQ0lZSUFNcUFnUWlGNVNTSWg2U0loK1RPQUlFSUE0Z0pDQWJJQ21VSUNvZ0dwU1RJaHVTSWhvZ0hDQXRsQ0FqSUJtVWt5SVpJQmdnSVpRZ0hTQVhsSk1pR0pJaUY1TTRBZ0FnQWlBZklDS1NPQUlFSUFJZ0dpQVhramdDQUNBSElDd2dLNU1pR2lBWklCaVRJaG1UT0FJRUlBY2dKQ0Fia3lJWUlDQWdIcE1pRjVJNEFnQWdDaUFhSUJtU09BSUVJQW9nR0NBWGt6Z0NBQ0FDUVFocUlRSWdBeUFVUVFOMGFpRURJQWdnRlVFRGRHb2hDQ0FFSUExQkEzUnFJUVFnRVVFQmFpSVJJQVZIRFFBTElBdEJBV29pQ3lBVFJ3MEFDd3dDQ3lBU0lBbEJBblJxS0FJQUlnOUJBVWdOQVNBQUtBSXdJZ1lnRHlBV2RDSVFJQVZzUVFOMGFpb0NCQ0VqSUFWQkFYUWhGQ0FRUVFGMElSVkJBQ0VLQTBBZ0FTQUtJQXhzUVFOMGFpRUNJQVlpQ0NFRUlBVWhBd05BSUFJZ0JVRURkR29pQnlBQ0tnSUFJQWNxQWdBaUhDQUVLZ0lBSWlDVUlBY3FBZ1FpSVNBRUtnSUVJaG1Va3lJZElBSWdGRUVEZEdvaURTb0NBQ0llSUFncUFnQWlINVFnRFNvQ0JDSVlJQWdxQWdRaUY1U1RJaHVTSWhwREFBQUFQNVNUT0FJQUlBY2dBaW9DQkNBZ0lDR1VJQndnR1pTU0loa2dIeUFZbENBZUlCZVVraUlZa2lJWFF3QUFBRCtVa3pnQ0JDQUNJQm9nQWlvQ0FKSTRBZ0FnQWlBWElBSXFBZ1NTT0FJRUlBMGdJeUFaSUJpVGxDSVlJQWNxQWdDU09BSUFJQTBnQnlvQ0JDQWpJQjBnRzVPVUloZVRPQUlFSUFjZ0J5b0NBQ0FZa3pnQ0FDQUhJQmNnQnlvQ0JKSTRBZ1FnQWtFSWFpRUNJQWdnRlVFRGRHb2hDQ0FFSUJCQkEzUnFJUVFnQTBFQmF5SUREUUFMSUFwQkFXb2lDaUFQUncwQUN3d0JDeUFTSUFsQkFuUnFLQUlBSWcxQkFVZ05BQ0FBS0FJd0lnNGdEU0FXZENJUElBVnNJZ1pCQkhScUlnSXFBZ1FoSlNBQ0tnSUFJU1lnRGlBR1FRTjBhaUlDS2dJRUlTY2dBaW9DQUNFb0lBVkJBblFoRUNBRlFRTnNJUlFnQlVFQmRDRVZRUUFoQndOQUlBVkJBVTRFUUNBQklBY2dER3hCQTNScUlnSWdCVUVEZEdvaEF5QUNJQlZCQTNScUlRZ2dBaUFVUVFOMGFpRUVJQUlnRUVFRGRHb2hDMEVBSVJFRFFDQUNLZ0lBSVM0Z0FpQUNLZ0lFSWk4Z0RpQVBJQkZzSWdwQkJIUnFJZ1lxQWdBaU1pQUlLZ0lFSWlTVUlBZ3FBZ0FpS1NBR0tnSUVJaHFVa2lJcUlBNGdDa0VZYkdvaUJpb0NBQ0lySUFRcUFnUWlMSlFnQkNvQ0FDSWlJQVlxQWdRaUdaU1NJaTJTSWpBZ0RpQUtRUU4wYWlJR0tnSUFJaU1nQXlvQ0JDSWNsQ0FES2dJQUloMGdCaW9DQkNJWWxKSWlJQ0FPSUFwQkJYUnFJZ1lxQWdBaUhpQUxLZ0lFSWgrVUlBc3FBZ0FpR3lBR0tnSUVJaGVVa2lJaGtpSXhrcEk0QWdRZ0FpQXVJQ2tnTXBRZ0pDQWFsSk1pR2lBaUlDdVVJQ3dnR1pTVElobVNJaUlnSFNBamxDQWNJQmlVa3lJWUlCc2dIcFFnSHlBWGxKTWlGNUlpSEpLU09BSUFJQU1nSlNBYUlCbVRJaDJVSUNjZ0dDQVhreUllbEpJaUh5QXZJQ1lnTUpRZ0tDQXhsSktTSWhxU09BSUVJQU1nTGlBbUlDS1VJQ2dnSEpTU2tpSVpJQ1VnS2lBdGt5SWJsQ0FuSUNBZ0laTWlHSlNTSWhlVE9BSUFJQXNnR2lBZmt6Z0NCQ0FMSUJjZ0daSTRBZ0FnQ0NBbElCNlVJQ2NnSFpTVElob2dMeUFvSURDVUlDWWdNWlNTa2lJWmtqZ0NCQ0FJSUNjZ0c1UWdKU0FZbEpNaUdDQXVJQ2dnSXBRZ0ppQWNsSktTSWhlU09BSUFJQVFnR1NBYWt6Z0NCQ0FFSUJjZ0dKTTRBZ0FnQzBFSWFpRUxJQVJCQ0dvaEJDQUlRUWhxSVFnZ0EwRUlhaUVESUFKQkNHb2hBaUFSUVFGcUloRWdCVWNOQUFzTElBZEJBV29pQnlBTlJ3MEFDd3NnQ1VFQmF5RUNJQWxCQUVvTkFBc0xoQUlCQm44akFDSUVJUWNnQkNBQklBSnNJZ2hCQW5SQkQycEJjSEZySWdVa0FBSkFJQU5GQkVBZ0FrRUJTQTBCSUFGQkFVZ05BVUVBSVFRRFFDQUJJQVJzSVFaQkFDRURBMEFnQlNBRElBWnFRUUowYWlBQUlBSWdBMndnQkdwQkFuUnFLZ0lBT0FJQUlBTkJBV29pQXlBQlJ3MEFDeUFFUVFGcUlnUWdBa2NOQUFzTUFRc2dBa0VCU0EwQUlBRkJBVWdOQUNBQ1FRSjBRZWc1YWlFR1FRQWhCQU5BSUFZZ0JFRUNkR29vQWdBZ0FXd2hDVUVBSVFNRFFDQUZJQU1nQ1dwQkFuUnFJQUFnQWlBRGJDQUVha0VDZEdvcUFnQTRBZ0FnQTBFQmFpSURJQUZIRFFBTElBUkJBV29pQkNBQ1J3MEFDd3NnQUNBRklBaEJBblFRQkJvZ0J5UUFDd3dBSUFBZ0FTQUNJQU1RUGd2YkF3RU9meUFEUVFGT0JFQWdBQ2dDRkNFSUlBQW9BaEFoQmlBQUtBSU1JUVFnQUNnQ0NDRUpJQUFvQWdRaEJ5QUFLQUlBSVFVRFFDQUJJQXBCQW5RaUMycEIvLzhCSUFjZ0JTQUNJQXBCQVhScUxnRUFRUXAwSWd3Z0JXc2lCVUgvL3dOeFFkSU5iRUVRZGlBRlFSQjFRZElOYkdvaURXb2lEaUFIYXlJSFFmLy9BM0ZCaXZVQWJFRVFkaUFIUVJCMVFZcjFBR3hxSWc5cUlnVWdDV3NpQjBILy93TnhRYXV4Zm14QkVIVWdCMEVRZFVHcnNYNXNhaUFGYWlJRlFRbDFRUUZxUVFGMUlnbEJnSUIrSUFsQmdJQitTaHNnQlVILysvOFBTaHM3QVFBZ0FTQUxRUUp5YWtILy93RWdCaUFFSUF3Z0JHc2lCRUgvL3dOeFFjWTFiRUVRZGlBRVFSQjFRY1kxYkdvaUMyb2lFQ0FHYXlJR1FmLy9BM0ZCcWNrQmJFRVFkaUFHUVJCMVFhbkpBV3hxSWhGcUlnUWdDR3NpQmtILy93TnhRZmF4ZjJ4QkVIVWdCa0VRZFVIMnNYOXNhaUFFYWlJRVFRbDFRUUZxUVFGMUlnaEJnSUIrSUFoQmdJQitTaHNnQkVILysvOFBTaHM3QVFBZ0JDQUdhaUVJSUFVZ0Iyb2hDU0FRSUJGcUlRWWdEaUFQYWlFSElBc2dER29oQkNBTUlBMXFJUVVnQ2tFQmFpSUtJQU5IRFFBTElBQWdDRFlDRkNBQUlBWTJBaEFnQUNBRU5nSU1JQUFnQ1RZQ0NDQUFJQWMyQWdRZ0FDQUZOZ0lBQ3d0b0FRSi9Jd0JCRUdzaUFpUUFBa0FDUUNBQklBQW9BZ0JHQkVBZ0FSQUlJQUFvQWdRaEFTQUFFQWdNQVFzZ0FDZ0NCQ0lERFFFZ0FpQUJOZ0lBUWVzSUlBSVFIa0VBSVFFTElBSkJFR29rQUNBQkR3c2dBQ0FESUFFUVB6WUNCQ0FDUVJCcUpBQWdBQXVqRWdFUmZ5TUFJZ2NoRWlBSElBQW9BcFFDSWdnZ0FDZ0NqQUlpQkdwQkFuUkJEMnBCY0hGcklnY2tBQ0FISUFCQkdHb2lFeUFJUVFKMEVBUWhEQ0FBS0FLb0FpSUhRUVJxSVJBZ0FDZ0NrQUloRHlBSElRVURRQ0FBSUF3Z0NFRUNkR29nQWlBRklBTWdCQ0FESUFSSUd5SU9FR2NnRGtFUWRDRU5Ba0FDUUFKQUFrQWdBQ2dDbEFJaUVVRVNhdzRUQUFNREF3TURBUU1EQXdNREF3TURBd01EQWdNTElBMUJBVWdOQWlBQUtBS1lBaUlHUVJCMFFSQjFJUlJCQUNFRkEwQWdBVUgvL3dFZ0VDQUZRZi8vQTNFZ0ZHeEJFSFVpQ2tFU2JHb2lCQzRCQUNJSklBd2dCVUVRZFVFQ2RHb2lDQ2dDQUNJTFFmLy9BM0ZzUVJCMUlBdEJFSFVnQ1d4cUlBUXVBUUlpQ1NBSUtBSUVJZ3RCRUhWc2FpQUxRZi8vQTNFZ0NXeEJFSFZxSUFRdUFRUWlDU0FJS0FJSUlndEJFSFZzYWlBTFFmLy9BM0VnQ1d4QkVIVnFJQVF1QVFZaUNTQUlLQUlNSWd0QkVIVnNhaUFMUWYvL0EzRWdDV3hCRUhWcUlBUXVBUWdpQ1NBSUtBSVFJZ3RCRUhWc2FpQUxRZi8vQTNFZ0NXeEJFSFZxSUFRdUFRb2lDU0FJS0FJVUlndEJFSFZzYWlBTFFmLy9BM0VnQ1d4QkVIVnFJQVF1QVF3aUNTQUlLQUlZSWd0QkVIVnNhaUFMUWYvL0EzRWdDV3hCRUhWcUlBUXVBUTRpQ1NBSUtBSWNJZ3RCRUhWc2FpQUxRZi8vQTNFZ0NXeEJFSFZxSUFRdUFSQWlCQ0FJS0FJZ0lnbEJFSFZzYWlBSlFmLy9BM0VnQkd4QkVIVnFJQkFnQmlBS1FYOXpha0VTYkdvaUJDNEJBQ0lLSUFnb0FrUWlDVUVRZFd4cUlBbEIvLzhEY1NBS2JFRVFkV29nQkM0QkFpSUtJQWdvQWtBaUNVRVFkV3hxSUFsQi8vOERjU0FLYkVFUWRXb2dCQzRCQkNJS0lBZ29BandpQ1VFUWRXeHFJQWxCLy84RGNTQUtiRUVRZFdvZ0JDNEJCaUlLSUFnb0FqZ2lDVUVRZFd4cUlBbEIvLzhEY1NBS2JFRVFkV29nQkM0QkNDSUtJQWdvQWpRaUNVRVFkV3hxSUFsQi8vOERjU0FLYkVFUWRXb2dCQzRCQ2lJS0lBZ29BakFpQ1VFUWRXeHFJQWxCLy84RGNTQUtiRUVRZFdvZ0JDNEJEQ0lLSUFnb0Fpd2lDVUVRZFd4cUlBbEIvLzhEY1NBS2JFRVFkV29nQkM0QkRpSUtJQWdvQWlnaUNVRVFkV3hxSUFsQi8vOERjU0FLYkVFUWRXb2dCQzRCRUNJRUlBZ29BaVFpQ0VFUWRXeHFJQWhCLy84RGNTQUViRUVRZFdvaUNFRUZkVUVCYWtFQmRTSUVRWUNBZmlBRVFZQ0Fma29iSUFoQjMvLy9BRW9iT3dFQUlBRkJBbW9oQVNBRklBOXFJZ1VnRFVnTkFBc01BZ3RCQUNFSUlBMUJBRXdOQVFOQUlBRkIvLzhCSUFjdUFRUWlCQ0FNSUFoQkVIVkJBblJxSWdVb0Fsd2dCU2dDQUdvaUJrSC8vd054YkVFUWRTQUdRUkIxSUFSc2FpQUhMZ0VHSWdRZ0JTZ0NXQ0FGS0FJRWFpSUdRUkIxYkdvZ0JrSC8vd054SUFSc1FSQjFhaUFITGdFSUlnUWdCU2dDVkNBRktBSUlhaUlHUVJCMWJHb2dCa0gvL3dOeElBUnNRUkIxYWlBSExnRUtJZ1FnQlNnQ1VDQUZLQUlNYWlJR1FSQjFiR29nQmtILy93TnhJQVJzUVJCMWFpQUhMZ0VNSWdRZ0JTZ0NUQ0FGS0FJUWFpSUdRUkIxYkdvZ0JrSC8vd054SUFSc1FSQjFhaUFITGdFT0lnUWdCU2dDU0NBRktBSVVhaUlHUVJCMWJHb2dCa0gvL3dOeElBUnNRUkIxYWlBSExnRVFJZ1FnQlNnQ1JDQUZLQUlZYWlJR1FSQjFiR29nQmtILy93TnhJQVJzUVJCMWFpQUhMZ0VTSWdRZ0JTZ0NRQ0FGS0FJY2FpSUdRUkIxYkdvZ0JrSC8vd054SUFSc1FSQjFhaUFITGdFVUlnUWdCU2dDUENBRktBSWdhaUlHUVJCMWJHb2dCa0gvL3dOeElBUnNRUkIxYWlBSExnRVdJZ1FnQlNnQ09DQUZLQUlrYWlJR1FSQjFiR29nQmtILy93TnhJQVJzUVJCMWFpQUhMZ0VZSWdRZ0JTZ0NOQ0FGS0FJb2FpSUdRUkIxYkdvZ0JrSC8vd054SUFSc1FSQjFhaUFITGdFYUlnUWdCU2dDTUNBRktBSXNhaUlGUVJCMWJHb2dCVUgvL3dOeElBUnNRUkIxYWlJRlFRVjFRUUZxUVFGMUlnUkJnSUIrSUFSQmdJQitTaHNnQlVIZi8vOEFTaHM3QVFBZ0FVRUNhaUVCSUFnZ0Qyb2lDQ0FOU0EwQUN3d0JDMEVBSVFnZ0RVRUFUQTBBQTBBZ0FVSC8vd0VnQnk0QkJDSUVJQXdnQ0VFUWRVRUNkR29pQlNnQ2pBRWdCU2dDQUdvaUJrSC8vd054YkVFUWRTQUdRUkIxSUFSc2FpQUhMZ0VHSWdRZ0JTZ0NpQUVnQlNnQ0JHb2lCa0VRZFd4cUlBWkIvLzhEY1NBRWJFRVFkV29nQnk0QkNDSUVJQVVvQW9RQklBVW9BZ2hxSWdaQkVIVnNhaUFHUWYvL0EzRWdCR3hCRUhWcUlBY3VBUW9pQkNBRktBS0FBU0FGS0FJTWFpSUdRUkIxYkdvZ0JrSC8vd054SUFSc1FSQjFhaUFITGdFTUlnUWdCU2dDZkNBRktBSVFhaUlHUVJCMWJHb2dCa0gvL3dOeElBUnNRUkIxYWlBSExnRU9JZ1FnQlNnQ2VDQUZLQUlVYWlJR1FSQjFiR29nQmtILy93TnhJQVJzUVJCMWFpQUhMZ0VRSWdRZ0JTZ0NkQ0FGS0FJWWFpSUdRUkIxYkdvZ0JrSC8vd054SUFSc1FSQjFhaUFITGdFU0lnUWdCU2dDY0NBRktBSWNhaUlHUVJCMWJHb2dCa0gvL3dOeElBUnNRUkIxYWlBSExnRVVJZ1FnQlNnQ2JDQUZLQUlnYWlJR1FSQjFiR29nQmtILy93TnhJQVJzUVJCMWFpQUhMZ0VXSWdRZ0JTZ0NhQ0FGS0FJa2FpSUdRUkIxYkdvZ0JrSC8vd054SUFSc1FSQjFhaUFITGdFWUlnUWdCU2dDWkNBRktBSW9haUlHUVJCMWJHb2dCa0gvL3dOeElBUnNRUkIxYWlBSExnRWFJZ1FnQlNnQ1lDQUZLQUlzYWlJR1FSQjFiR29nQmtILy93TnhJQVJzUVJCMWFpQUhMZ0VjSWdRZ0JTZ0NYQ0FGS0FJd2FpSUdRUkIxYkdvZ0JrSC8vd054SUFSc1FSQjFhaUFITGdFZUlnUWdCU2dDV0NBRktBSTBhaUlHUVJCMWJHb2dCa0gvL3dOeElBUnNRUkIxYWlBSExnRWdJZ1FnQlNnQ1ZDQUZLQUk0YWlJR1FSQjFiR29nQmtILy93TnhJQVJzUVJCMWFpQUhMZ0VpSWdRZ0JTZ0NVQ0FGS0FJOGFpSUdRUkIxYkdvZ0JrSC8vd054SUFSc1FSQjFhaUFITGdFa0lnUWdCU2dDVENBRktBSkFhaUlHUVJCMWJHb2dCa0gvL3dOeElBUnNRUkIxYWlBSExnRW1JZ1FnQlNnQ1NDQUZLQUpFYWlJRlFSQjFiR29nQlVILy93TnhJQVJzUVJCMWFpSUZRUVYxUVFGcVFRRjFJZ1JCZ0lCK0lBUkJnSUIrU2hzZ0JVSGYvLzhBU2hzN0FRQWdBVUVDYWlFQklBZ2dEMm9pQ0NBTlNBMEFDd3NnQXlBT2F5SURRUUpPQkVBZ0RDQU1JQTVCQW5ScUlCRkJBblFRQkJvZ0FpQU9RUUYwYWlFQ0lBQW9BcWdDSVFVZ0FDZ0NsQUloQ0NBQUtBS01BaUVFREFFTEN5QVRJQXdnRGtFQ2RHb2dFVUVDZEJBRUdpQVNKQUFMbUFNQkNuOGpBQ0lGSVFrZ0JTQUFLQUtNQWlJRVFRSjBRUjlxUVhCeGF5SUZKQUFnQlNBQUtRSWdOd0lJSUFVZ0FDa0NHRGNDQUNBRlFSQnFJUW9nQUNnQ2tBSWhDd05BSUFBZ0NpQUNJQU1nQkNBRElBUklHeUlIRUQ1QkFDRUlJQWRCRVhRaURFRUJUZ1JBQTBBZ0FVSC8vd0VnQ0VILy93TnhRUXhzUVJCMklnMUJBM1JCOEExcUlnWXVBUUlnQlNBSVFSQjFRUUYwYWlJRUxnRUNiQ0FHTGdFQUlBUXVBUUJzYWlBR0xnRUVJQVF1QVFSc2FpQUdMZ0VHSUFRdUFRWnNha0VBSUExclFRTjBRY2dPYWlJR0xnRUdJQVF1QVFoc2FpQUdMZ0VFSUFRdUFRcHNhaUFHTGdFQ0lBUXVBUXhzYWlBR0xnRUFJQVF1QVE1c2FpSUVRUTUxUVFGcVFRRjFJZ1pCZ0lCK0lBWkJnSUIrU2hzZ0JFSC8vLzcvQTBvYk93RUFJQUZCQW1vaEFTQUlJQXRxSWdnZ0RFZ05BQXNMSUFNZ0Iyc2lBMEVCVGdSQUlBVWdCU0FIUVFKMGFpSUVLUUlBTndJQUlBVWdCQ2tDQ0RjQ0NDQUNJQWRCQVhScUlRSWdBQ2dDakFJaEJBd0JDd3NnQUNBRklBZEJBblJxSWdFcEFnQTNBaGdnQUNBQktRSUlOd0lnSUFra0FBdWRBZ0VDZnlBQVFhZ0JhaUlGSUFBb0FxUUNJZ1JCQVhScUlBSWdBQ2dDbkFJZ0JHdEJBWFFpQkJBRUdnSkFBa0FDUUFKQUFrQWdBQ2dDaUFKQkFXc09Bd0FCQWdNTElBQWdBU0FGSUFBb0Fwd0NFRDBnQUNBQklBQW9BcUFDUVFGMGFpQUNJQVJxSUFNZ0FDZ0NuQUpyRUQwTUF3c2dBQ0FCSUFVZ0FDZ0NuQUlRUVNBQUlBRWdBQ2dDb0FKQkFYUnFJQUlnQkdvZ0F5QUFLQUtjQW1zUVFRd0NDeUFBSUFFZ0JTQUFLQUtjQWhCQUlBQWdBU0FBS0FLZ0FrRUJkR29nQWlBRWFpQURJQUFvQXB3Q2F4QkFEQUVMSUFFZ0JTQUFLQUtjQWtFQmRCQUVJQUFvQXFBQ1FRRjBhaUFDSUFScUlBTWdBQ2dDbkFKclFRRjBFQVFhQ3lBRklBSWdBeUFBS0FLa0FpSUFhMEVCZEdvZ0FFRUJkQkFFR2tFQUM4d1hBUXQvSXdCQmtBVnJJZzhrQUNBUElncEJBRFlDakFVZ0NrSUFOd09BQlNBQktBSUVJUWdDUUNBRFJRMEFJQWhCQVVnTkFBTkFJQUFnQ1VHb0lXeHFRUUEyQXRRU0lBbEJBV29pQ1NBSVJ3MEFDd3NnQUNnQzRFSWdDRWdFUUNBQVFhZ2hhaEFtSVEwZ0FTZ0NCQ0VJQ3dKQUlBaEJBVWNOQUNBQUtBTGdRa0VDUncwQUlBRW9BZ3dnQUNnQ2pCSkI2QWRzUmlFU0N3SkFBa0FnQUNnQzFCSU5BQ0FJUVFGSURRQkJBQ0VKQTBCQkFpRURRUUVoRGtHMWZpRUxBa0FDUUFKQUFrQWdBU2dDRUNJTURoVURCZ1lHQmdZR0JnWUdBd1lHQmdZR0JnWUdCZ0VBQ3lBTVFTaEdEUUVnREVFOFJ3MEZRUVFoQTBFRElRNE1BZ3RCQkNFRERBRUxRUVFoQTBFQ0lRNExJQUFnQ1VHb0lXeHFJZ3dnQXpZQ2xCSWdEQ0FPTmdMWUVrRzRmaUVMSUFFb0FneEJDblVpQTBFUFN3MENRUUVnQTNSQmdKRUNjVVVOQWlBTUlBTkJBV29nQVNnQ0NCQnJJQTFxSVEwZ0NVRUJhaUlKSUFFb0FnUWlDRWdOQUFzTFFRSWhDUUpBSUFFb0FnQWlBMEVDUndSQUlBTWhDUXdCQ3lBSVFRSkhEUUFnQUNnQzNFSkJBVWNFUUVFQ0lRZ2dBQ2dDNEVKQkFVY05BUXNnQUVFQU5nTFlRaUFBUVFBMkF0QkNJQUJCcURScUlBQkJnQk5xUWF3Q0VBUWFJQUVvQWdRaENDQUJLQUlBSVFrTElBQWdDRFlDNEVJZ0FDQUpOZ0xjUWtHNGZpRUxJQUVvQWdoQndENXJRY0M0QWtzTkFBSkFJQUpCQVVZTkFDQUFLQUxVRWcwQUFrQWdDRUVCU0EwQVFRQWhEZ05BUVFBaENDQUFJQTVCcUNGc2FpSU1LQUxZRWtFQVNnUkFJQXhCMkJKcUlRTURRQ0FNSUFoQkFuUnFRZVFTYWlBRVFRRVFCallDQUNBSVFRRnFJZ2dnQXlnQ0FFZ05BQXNMSUF3Z0JFRUJFQVkyQXZBU0lBNUJBV29pRGlBQktBSUVJZ2hJRFFBTFFRQWhDeUFJUVFCTURRQURRQ0FBSUF0QnFDRnNhaUlKUWdBM0F2UVNJQWxCL0JKcVFRQTJBZ0FDUUNBSktBTHdFa1VOQUNBSktBTFlFaUlEUVFGR0JFQWdDVUgwRW1wQkFUWUNBQXdCQ3lBRUlBTkJBblJCMERCcUtBSUFRUWdRQXlFRElBbEIyQkpxS0FJQUlneEJBVWdOQUNBRFFRRnFJUU5CQUNFSUEwQWdDU0FJUVFKMGFrSDBFbW9nQXlBSWRrRUJjVFlDQUNBSVFRRnFJZ2dnREVnTkFBc0xJQXRCQVdvaUN5QUJLQUlFSWdoSURRQUxDeUFDRFFBZ0FDZ0MyQkpCQVVnTkFDQUFRWncwYWlFT1FRQWhDd05BQWtBZ0NFRUJTQTBBSUE0Z0MwRUNkQ0lNYWlFUlFRQWhDU0FMQkVBZ0MwRUJheUVEQTBBZ0FDQUpRYWdoYkdvaUVDQU1ha0gwRW1vb0FnQUVRQUpBSUFrTkFDQUlRUUpIRFFBZ0JDQUtRWUFGYWhBYklCRW9BZ0FOQUNBRUlBcEJqQVZxRUNVTElCQWdCQ0FMUVFFZ0VDQURRUUowYWtIMEVtb29BZ0JCQUVkQkFYUVFLQ0FFSUFvZ0VFSE5GV29zQUFBZ0VFSE9GV29zQUFBZ0VDZ0NtQklRSnlBQktBSUVJUWdMSUFsQkFXb2lDU0FJU0EwQUN3d0JDd05BSUFBZ0NVR29JV3hxSWdNb0F2UVNCRUFDUUNBSkRRQWdDRUVDUncwQUlBUWdDa0dBQldvUUd5QVJLQUlBRFFBZ0JDQUtRWXdGYWhBbEN5QURJQVJCQUVFQlFRQVFLQ0FFSUFvZ0EwSE5GV29zQUFBZ0EwSE9GV29zQUFBZ0F5Z0NtQklRSnlBQktBSUVJUWdMSUFsQkFXb2lDU0FJU0EwQUN3c2dDMEVCYWlJTElBQW9BdGdTU0EwQUN3c0NRQ0FJUVFKSERRQUNRQUpBQWtBQ1FBSkFBa0FnQWc0REFBSUJBZ3NnQkNBS1FZQUZhaEFiSUFBZ0FDZ0MxQkpCQW5ScVFZdzBhaWdDQUVVTkF3d0VDeUFBSUFBb0F0UVNRUUowYWtIMEVtb29BZ0JCQVVZTkFRc2dDaUFBTGdIUVFqWUNnQVVnQ2lBQUxnSFNRallDaEFVTUF3c2dCQ0FLUVlBRmFoQWJJQUFnQUNnQzFCSkJBblJxUVp3MGFpZ0NBQTBCQ3lBRUlBcEJqQVZxRUNVTUFRc2dDa0VBTmdLTUJRc0NRQ0FCS0FJRUlnaEJBa2NOQUNBS0tBS01CUTBBUVFJaENDQUFLQUxrUWtFQlJ3MEFJQUJCckN0cVFRQkJnQWdRQlJvZ0FFRUFOZ0xzUVNBQVFRbzZBTEF6SUFCQjVBQTJBcXd6SUFCQkFUWUM4RE1nQVNnQ0JDRUlDd0ovSUFnZ0FTZ0NER3dnQVNnQ0FDQUJLQUlJYkU0aUVVVUVRQ0FGSVF3Z0FFR1lFbW9NQVFzZ0NpQUFLQUtZRWtFQ2FpQUliRUVCZEVFUGFrRndjV3NpRENJUEpBQWdBRUdZRW1vTEtBSUFJUU5CQVNFSUlBb2dERFlDQUNBS0lBd2dBMEVCZEdwQkJHb2lEallDQkFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FnQWtVRVFDQUtLQUtNQlVVaENBd0JDeUFBS0FMa1FrVU5BQ0FCS0FJRUlRTWdBa0VDUncwQklBTkJBa2NOQVNBQUlBQW9Bdnd6UVFKMGFrR2NOR29vQWdCQkFVWWhDQXNnQVNnQ0JFRUFTZzBCREFVTElBTkJBVWdOQkNBQ1FRSkhEUUVNQWdzZ0NBUkFRUUVoQ0NBQUtBTFVFaUlMUVFCS1FRRjBJUU1DUUNBTFFRRklEUUFnQWtFQ1J3MEFJQXRCQW5RZ0FHcEI4QkpxS0FJQVFRQkhRUUYwSVFNTElBQWdCQ0FLS0FJQVFRUnFJQXBCaUFWcUlBSWdBeEFjSVFNZ0FDQUFLQUxVRWtFQmFqWUMxQklnQXlBTmFpRU5JQUVvQWdRaUNVRUNTQTBEQTBBQ2YwRUFJQUFvQXRRU0lBaHJJZ3RCQVVnTkFCb2dBa0VDUndSQVFRRkJBaUFBS0FMa1Foc01BUXNnQUNBSVFhZ2hiR29nQzBFQ2RHcEI4QkpxS0FJQVFRQkhRUUYwQ3lFRElBQWdDRUdvSVd4cUlnc2dCQ0FLSUFoQkFuUnFLQUlBUVFScUlBcEJpQVZxSUFJZ0F4QWNJUU1nQ3lBTEtBTFVFa0VCYWpZQzFCSWdBeUFOYWlFTklBaEJBV29pQ0NBQktBSUVJZ2xJRFFBTERBTUxJQUpCQWtZTkFRc2dBQ0FFSUF4QkJHb2dDa0dJQldvZ0FpQUFLQUxVRWtFQVNrRUJkQkFjSVFNZ0FDQUFLQUxVRWtFQmFqWUMxQklnQXlBTmFpRU5JQUVvQWdRaUNVRUNTQTBCSUFvb0FvZ0ZRUUYwSVFSQkFTRUlBMEFnQ2lBSVFRSjBhaWdDQUVFRWFrRUFJQVFRQlJvZ0FDQUlRYWdoYkdvaUF5QURLQUxVRWtFQmFqWUMxQklnQ0VFQmFpSUlJQUVvQWdRaUNVZ05BQXNNQVFzZ0FDQUVJQXhCQkdvZ0NrR0lCV3BCQWdKL1FRQWdBQ2dDMUJJaUEwRUJTQTBBR2lBRFFRSjBJQUJxUWZBU2FpZ0NBRUVBUjBFQmRBc1FIQ0VESUFBZ0FDZ0MxQkpCQVdvMkF0UVNJQU1nRFdvaERTQUJLQUlFSWdsQkFrZ05BQ0FLS0FLSUJVRUJkQ0VFUVFFaENBTkFJQW9nQ0VFQ2RHb29BZ0JCQkdwQkFDQUVFQVVhSUFBZ0NFR29JV3hxSWdNZ0F5Z0MxQkpCQVdvMkF0UVNJQWhCQVdvaUNDQUJLQUlFSWdsSURRQUxDeUFKUVFKSERRQWdBU2dDQUVFQ1J3MEFJQUJCME1JQWFpQU1JQTRnQ2tHQUJXb2dBQ2dDakJJZ0NpZ0NpQVVRWkNBS0tBS0lCU0VFREFFTElBd2dBQ2dDMUVJMkFRQWdBQ0FNSUFvb0FvZ0ZJZ1JCQVhScUtBRUFOZ0xVUWdzZ0JpQUJLQUlJSUFSc0lBQXVBWXdTUWVnSGJHMGlBellDQUNBUElBTkJBU0FCS0FJQUlndEJBa1lpQ1J0QkFYUkJEMnBCY0hGcklnOGlBeVFBSUFFb0FnUWhDQ0FSUlFSQUlBTWdBQ2dDbUJJaUIwRUNhaUFJYkVFQmRDSURRUTlxUVhCeGF5SU1KQUFnQ2lBTUlBVWdBeEFFSWdNZ0IwRUJkR3BCQkdvMkFnUWdDaUFETmdJQUN5QVBJQVVnQ1JzaER3SkFJQXNnQ0NBSUlBdEtHMEVCU0EwQVFRQWhDU0FNSVFnRFFDQUFJQWxCcUNGc2FrR0FFMm9nRHlBSVFRSnFJQVFRUWlFSEFrQWdBU2dDQUNJTFFRSkhEUUJCQUNFSUlBWW9BZ0FpQkVFQlNBMEFBMEFnQlNBSVFRRjBJZ01nQ1dwQkFYUnFJQU1nRDJvdkFRQTdBUUFnQ0VFQmFpSUlJQVJIRFFBTEN5QUhJQTFxSVEwZ0NVRUJhaUlKSUFzZ0FTZ0NCQ0lJSUFnZ0Mwb2JUZzBCSUFvZ0NVRUNkR29vQWdBaENDQUtLQUtJQlNFRURBQUxBQXNDUUFKQUFrQWdDMEVDUncwQUlBaEJBVWNOQUNBU0RRRkJBQ0VJSUFZb0FnQWlCRUVBVEEwQUEwQWdCU0FJUVFKMElnTkJBbkpxSUFNZ0JXb3ZBUUE3QVFBZ0NFRUJhaUlJSUFSSERRQUxDeUFOSVFzTUFRc2dBRUdvTkdvZ0R5QU1RUUpxSUFvb0FvZ0ZFRUlnRFdvaEN5QUdLQUlBSWdOQkFVZ05BRUVBSVFnRFFDQUZJQWhCQW5SQkFuSnFJQThnQ0VFQmRHb3ZBUUE3QVFBZ0NFRUJhaUlJSUFOSERRQUxDMEVBSVFnZ0FTQUFLQUxFSUVFQ1JnUi9JQUFvQW93U1FRaHJRWHh4UWJnSmFpZ0NBQ0FBS0FLRUVtd0ZRUUFMTmdJVUFrQWdBa0VCUmdSQUlBQW9BdUJDSWdGQkFVZ05BUU5BSUFBZ0NFR29JV3hxUVFvNkFJZ1NJQWhCQVdvaUNDQUJSdzBBQ3d3QkN5QUFJQW9vQW93Rk5nTGtRZ3NMSUFwQmtBVnFKQUFnQ3dzeEFRRi9JQUFRSmhvZ0FFR29JV29RSmlFQklBQkIyTUlBYWtFQU5nSUFJQUJDQURjQzBFSWdBRUVBTmdMa1FpQUJDL3dFQVFkL0lBQW9Bb3dTSWdRZ0FFR2NJV29vQWdCSEJFQWdBQ0FFTmdLY0lTQUFRWlFoYWtLQWdJU0FnSURBQURjQ0FDQUFRYUFoYWtLQ2dJQ0F3QUkzQWdBZ0FDQUFLQUtZRWtFSGREWUN6Q0FMSUFNRVFDQUFJQUVnQWhCMElBQWdBQ2dDd0NCQkFXbzJBc0FnRHdzZ0FDQUFRYzBWYWl3QUFDSUNOZ0xFSUFKQUlBSkJBa1lFUUVFQUlRTUNRQ0FBS0FLVUVpSUNSUTBBSUFKQkFuUWdBV3BCQkdzaUNTZ0NBQ0lHUVFGSURRQWdBRUhRSUdvaEJ5QUFLQUtjRWlFS0EwQWdBeUFCSUFJZ0JVRi9jMm9pQ0VFS2JHb2lCQzRCWWlBRUxnRmdhaUFFTGdGa2FpQUVMZ0ZtYWlBRUxnRm9haUlFU0FSQUlBY2dBU0FJUVJCMFFSQjFRUXBzYWlJREx3Rm9Pd0VJSUFjZ0F5a0JZRGNCQUNBQUlBRWdDRUVDZEdvb0FnQkJDSFEyQXN3Z0lBa29BZ0FoQmlBRUlRTUxJQVZCQVdvaUJTQUNSZzBCSUFVZ0Ntd2dCa2dOQUFzTElBQkIwQ0JxSWdSQ0FEY0NBQ0FBUWRnZ2FrRUFPd0VBSUFCQjFDQnFJQU03QVFBZ0EwSE0yUUJNQkVBZ0FFSFdJR3BCQURZQkFDQUVRUUEyQVFBZ0FFR0E2TXdGSUFOQkFTQURRUUZLRzI1QkVIUkJFSFVnQTBFUWRFRVFkV3hCQ25ZN0FkUWdEQUlMSUFOQnp2a0FTQTBCSUFCQjFpQnFRUUEyQVFBZ0FFSFFJR3BCQURZQkFDQUFRWUNBemZrQUlBTnVJQU5CRUhSQkVIVnNRUTUyT3dIVUlBd0JDeUFBUWRBZ2FrSUFOd0lBSUFCQjJDQnFRUUE3QVFBZ0FDQUVRUkIwUVJCMVFZQWtiRFlDekNBZ0FDZ0NsQkloQWdzZ0FFSGFJR29nQVVGQWF5QUFLQUtrRWtFQmRCQUVHaUFBUVpBaGFpQUJLQUtJQVRzQkFDQUFRWlFoYWlBQ1FRSjBJQUZxS1FJSU53SUFJQUJCcENGcUlBQW9BcHdTTmdJQUlBQkJvQ0ZxSUFJMkFnQUx2UUVCQTM4Z0FpNEJBaUlFUVFGT0JFQWdBaWdDR0NBRVFmLy9BM0VnQTJ4QkFtMXFJUVJCQUNFREEwQWdBQ0FEUVFGMGFpQUVMUUFBSWdWQkFYWkJCM0ZCQ1d3N0FRQWdBU0FEYWlBQ0tBSVVJQUl1QVFKQkFXc2dCVUVCY1d3Z0EycHFMUUFBT2dBQUlBQWdBMEVCY2lJR1FRRjBhaUFGUVFWMlFRbHNPd0VBSUFFZ0Jtb2dBaWdDRkNBR0lBSXVBUUpCQVdzZ0JVRUVka0VCY1d4cWFpMEFBRG9BQUNBRVFRRnFJUVFnQTBFQ2FpSURJQUl1QVFKSURRQUxDd3ZMQXdFSGZ3SkFJQU1nQkV3TkFDQUVRUWRPQkVBZ0JDRUdBMEFnQWk0QkFpQUdRUUYwSWdzZ0FXb2lCVUVFYXk0QkFHd2dBaTRCQUNBRlFRSnJJZ2t1QVFCc2FpQUNMZ0VFSUFWQkJtc3VBUUJzYWlBQ0xnRUdJQVZCQ0dzdUFRQnNhaUFDTGdFSUlBVkJDbXN1QVFCc2FpQUNMZ0VLSUFWQkRHc3VBUUJzYWlFSVFRWWhCd05BSUFnZ0FpQUhRUUYwSWdwcUxnRUFJQWtnQ21zdUFRQnNhaUFDSUFwQkFuSnFMZ0VBSUFrZ0IwRi9jMEVCZEdvdUFRQnNhaUVJSUFkQkFtb2lCeUFFU0EwQUN5QUFJQXRxSUFVdUFRQkJESFFnQ0d0QkMzVkJBV3BCQVhVaUJVR0FnSDRnQlVHQWdINUtHeUlGUWYvL0FTQUZRZi8vQVVnYk93RUFJQVpCQVdvaUJpQURSdzBBQ3d3QkN5QUVJUVlEUUNBQUlBWkJBWFFpQldvZ0FTQUZhaUlGTGdFQVFReDBJQUl1QVFJZ0JVRUVheTRCQUd3Z0FpNEJBQ0FGUVFKckxnRUFiR29nQWk0QkJDQUZRUVpyTGdFQWJHb2dBaTRCQmlBRlFRaHJMZ0VBYkdvZ0FpNEJDQ0FGUVFwckxnRUFiR29nQWk0QkNpQUZRUXhyTGdFQWJHcHJRUXQxUVFGcVFRRjFJZ1ZCZ0lCK0lBVkJnSUIrU2hzaUJVSC8vd0VnQlVILy93RklHenNCQUNBR1FRRnFJZ1lnQTBjTkFBc0xJQUJCQUNBRVFRRjBFQVVhQzBvQkFYOUJBQ0FDUVFGcUlBSkJBRWdiSWdJZ0FDZ0NBQ0lEU0FSQUlBQW9BZ2dnQVdvaEFRTkFJQUFnQW1vdEFBd2dBVVlFUUNBQ0R3c2dBa0VCYWlJQ0lBTklEUUFMQzBGL0Mwb0JBWDlCQUNBQ1FRRnFJQUpCQUVnYklnSWdBQ2dDQUNJRFNBUkFJQUZCQVhSQkFYSWhBUU5BSUFBZ0Ftb3RBQXdnQVVZRVFDQUNEd3NnQWtFQmFpSUNJQU5JRFFBTEMwRi9DMGNCQVg5QkFDQUNRUUZxSUFKQkFFZ2JJZ0lnQUNnQ0FDSURTQVJBSUFGQkFYUWhBUU5BSUFBZ0Ftb3RBQXdnQVVZRVFDQUNEd3NnQWtFQmFpSUNJQU5JRFFBTEMwRi9DN3NDQUFKQUlBRkJGRXNOQUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUlBRkJDV3NPQ2dBQkFnTUVCUVlIQ0FrS0N5QUNJQUlvQWdBaUFVRUVhallDQUNBQUlBRW9BZ0EyQWdBUEN5QUNJQUlvQWdBaUFVRUVhallDQUNBQUlBRTBBZ0EzQXdBUEN5QUNJQUlvQWdBaUFVRUVhallDQUNBQUlBRTFBZ0EzQXdBUEN5QUNJQUlvQWdCQkIycEJlSEVpQVVFSWFqWUNBQ0FBSUFFcEF3QTNBd0FQQ3lBQ0lBSW9BZ0FpQVVFRWFqWUNBQ0FBSUFFeUFRQTNBd0FQQ3lBQ0lBSW9BZ0FpQVVFRWFqWUNBQ0FBSUFFekFRQTNBd0FQQ3lBQ0lBSW9BZ0FpQVVFRWFqWUNBQ0FBSUFFd0FBQTNBd0FQQ3lBQ0lBSW9BZ0FpQVVFRWFqWUNBQ0FBSUFFeEFBQTNBd0FQQ3lBQ0lBSW9BZ0JCQjJwQmVIRWlBVUVJYWpZQ0FDQUFJQUVyQXdBNUF3QVBDeUFBSUFKQkFCRUdBQXNMU2dFRGZ5QUFLQUlBTEFBQVFUQnJRUXBKQkVBRFFDQUFLQUlBSWdFc0FBQWhBeUFBSUFGQkFXbzJBZ0FnQXlBQ1FRcHNha0V3YXlFQ0lBRXNBQUZCTUd0QkNra05BQXNMSUFJTEVnQWdBRVVFUUVFQUR3c2dBQ0FCRUk0QkMvRURBUVovSXdCQjhBQnJJZ2drQUVGL0lRY0NRQUpBQWtBZ0FVVU5BQ0FDUlEwQURBRUxJQVFnQUNnQ0RFR1FBMjF2RFFFTElBRkJBQ0FDRzBVRVFFRUFJUUlEUUNBQVFRQkJBQ0FESUFBb0FnZ2dBbXhCQW5ScUlBUWdBbXNRRXlJSFFRQklJZ0VOQWlBQ0lBSWdCMm9pQnlBQkd5RUJJQWNoQWlBQklBUklEUUFMSUFBZ0FUWUNTQXdCQ3lBQ1FRQklEUUFDUUNBQkxRQUFJZ2RCZ0FGeEJFQWdCMEVGZGtFRGNTSUhRYzRJYWtITkNDQUhHeUVLUWVvSElRa01BUXNDZnlBSFFlQUFjVUhnQUVZRVFFSHBCeUVKUWRFSVFkQUlJQWRCRUhFYkRBRUxRZWdISVFrZ0IwRUZka0VEY1VITkNHb0xJUW9MSUFFZ0FDZ0NEQkE2SVFzZ0FTMEFBQ0VNSUFFZ0FpQUZJQWhCNndCcUlBZ2dDRUhzQUdvZ0JoQTNJZ1ZCQUVnRVFDQUZJUWNNQVFzZ0FTQUlLQUpzYWlFQlFYNGhCeUFGSUF0c0lBUktEUUFnQUNBTE5nSkFJQUFnQ2pZQ05DQUFJQWsyQWpnZ0FFRUNRUUVnREVFRWNSczJBakFDUUNBRlFRRklCRUJCQUNFSERBRUxRUUFoQWtFQUlRY0RRQ0FBSUFFZ0NDQUNRUUYwYWlJSkxnRUFJQU1nQUNnQ0NDQUhiRUVDZEdvZ0JDQUhheEFUSWdaQkFFZ0VRQ0FHSVFjTUF3c2dCaUFIYWlFSElBRWdDUzRCQUdvaEFTQUNRUUZxSWdJZ0JVY05BQXNMSUFBZ0J6WUNTQ0FBUWdBM0Frd0xJQWhCOEFCcUpBQWdCd3Q3QVFKOElBQWdBS0lpQWlBQ0lBS2lvaUFDUkh6VnoxbzYyZVU5b2tUcm5DdUs1dVZhdnFDaUlBSWdBa1I5L3JGWDR4M0hQcUpFMVdIQkdhQUJLcitnb2tTbStCQVJFUkdCUDZDZ0lRTWdBQ0FDSUFGRUFBQUFBQUFBNEQraUlBSWdBS0lpQUNBRG9xR2lJQUdoSUFCRVNWVlZWVlZWeFQraW9LRUx2Z0VCQW44akFFRVFheUlCSkFBQ2ZDQUF2VUlnaUtkQi8vLy8vd2R4SWdKQis4T2svd05OQkVCRUFBQUFBQUFBOEQ4Z0FrR2V3WnJ5QTBrTkFSb2dBRVFBQUFBQUFBQUFBQkF0REFFTElBQWdBS0VnQWtHQWdNRC9CMDhOQUJvQ1FBSkFBa0FDUUNBQUlBRVFsQUZCQTNFT0F3QUJBZ01MSUFFckF3QWdBU3NEQ0JBdERBTUxJQUVyQXdBZ0FTc0RDQkJQbWd3Q0N5QUJLd01BSUFFckF3Z1FMWm9NQVFzZ0FTc0RBQ0FCS3dNSUVFOExJUUFnQVVFUWFpUUFJQUFMK3dFQkJYOGdBa0VCYXlJRFFZQUNUd1JBSUFBZ0FVRVlJQU5uYXlJRmRpSUNJQUpCQVdvZ0F5QUZka0VCYWhBaFFYOGdCWFJCZjNNZ0FYRWhCaUFBS0FJTUlRSUNRQ0FBS0FJUUlnRWdCV29pQkVFaFNRUkFJQUVoQXd3QkN3TkFRWDhoQkNBQUlBQW9BZ1FpQXlBQUtBSUlJZ2NnQUNnQ0dHcExCSDhnQUNBSFFRRnFJZ1EyQWdnZ0FDZ0NBQ0FESUFScmFpQUNPZ0FBUVFBRlFYOExJQUFvQWl4eU5nSXNJQUpCQ0hZaEFpQUJRUTlLSVFRZ0FVRUlheUlESVFFZ0JBMEFDeUFESUFWcUlRUUxJQUFnQkRZQ0VDQUFJQVlnQTNRZ0FuSTJBZ3dnQUNBQUtBSVVJQVZxTmdJVUR3c2dBQ0FCSUFGQkFXb2dBaEFoQ3pnQkFYOGdBQ0FBS0FJY0lBRnVJZ0kyQWlRZ0FDZ0NJQ0FDYmlJQVFYOXpJQUZxUVFBZ0FFRUJhaUlBSUFGcklnRWdBQ0FCU1J0cUMvb0NBUVovSUFCQ2dJQ0FnSUFRTndJWUlBQkNnSUNBZ0pBQk53SVFJQUJDQURjQ0NDQUFJQUkyQWdRZ0FDQUJOZ0lBSUFJRVFDQUFRUUUyQWhnZ0FTMEFBQ0VFUVFFaEF3c2dBRUVBTmdJc0lBQWdCRFlDS0NBQVFZQ0FBallDSENBQVFSRTJBaFFnQUNBRVFRRjJRZjhBY3lJR05nSWdBa0FnQWlBRFRRUkFJQU1oQlF3QkN5QUFJQU5CQVdvaUJUWUNHQ0FCSUFOcUxRQUFJUWNMSUFBZ0J6WUNLQ0FBUVlDQWdBUTJBaHdnQUVFWk5nSVVJQUFnQnlBRVFRaDBja0VCZGtIL0FYRWdCa0VJZEhKQi93RnpJZ2cyQWlCQkFDRURJQUFDZnlBQ0lBVk5CRUFnQlNFR1FRQU1BUXNnQUNBRlFRRnFJZ1kyQWhnZ0FTQUZhaTBBQUFzaUJEWUNLQ0FBUVlDQWdJQjROZ0ljSUFCQklUWUNGQ0FBSUFRZ0IwRUlkSEpCQVhaQi93RnhJQWhCQ0hSeVFmOEJjeUlGTmdJZ0lBSWdCa3NFUUNBQUlBWkJBV28yQWhnZ0FTQUdhaTBBQUNFREN5QUFJQU0yQWlnZ0FDQURJQVJCQ0hSeVFRRjJRZjhCY1NBRlFRaDBja0gvQVhNMkFpQUwxQUlCQm44Q1FDQUJJQUpPRFFBZ0NFRUJJQWhCQVVvYklRc0NRQ0FHSUFoSURRQWdBU0VLQTBBQ1FDQUVJQXBCQW5RaUNXb2lEQ2dDQUVFSFNnMEFJQVVnQ1dvb0FnQU5BRUVBSVFrRFFDQUhRUUVRQ1NFTklBTWdBQ2dDQ0NBSmJDQUtha0VDZEdvaURpQU9LZ0lBSUEyeVF3QUFBTCtTUVFGQkRTQU1LQUlBYTNTeWxFTUFBSUE0bEpJNEFnQWdDVUVCYWlJSklBdEhEUUFMSUFZZ0Myc2hCZ3NnQ2tFQmFpSUtJQUpPRFFFZ0JpQUlUZzBBQ3dzZ0JpQUlTQTBBQTBBQ1FDQUVJQUZCQW5RaUNtb2lEQ2dDQUVFSFNnMEFRUUFoQ1NBRklBcHFLQUlBUVFGSERRQURRQ0FIUVFFUUNTRUtJQU1nQUNnQ0NDQUpiQ0FCYWtFQ2RHb2lEU0FOS2dJQUlBcXlRd0FBQUwrU1FRRkJEU0FNS0FJQWEzU3lsRU1BQUlBNGxKSTRBZ0FnQ1VFQmFpSUpJQXRIRFFBTElBWWdDMnNoQmdzZ0FVRUJhaUlCSUFKT0RRRWdCaUFJVGcwQUN3c0xuQWNDQ1g4R2ZTTUFJZ01oQ2lBRFFiQUtheUlFSWdNa0FDQURRYUFQYXlJR0lnTWtBQ0FEUWVBSmF5SUhKQUJCQUNFREEwQWdCQ0FEUVFKMGFpQUFJQU5CQTNScUtnSUFPQUlBSUFOQkFXb2lBMEhNQWtjTkFBdEJBQ0VEQTBBZ0JpQURRUUowYWlBQklBTkJBM1JxS2dJQU9BSUFJQU5CQVdvaUEwSG5BMGNOQUFzZ0JDQUdJQWRCekFKQm13RVFNME1BQUlBL0lReEJBQ0VEQTBBZ0RDQUdJQU5CQW5ScUtnSUFJZzRnRHBTU0lRd2dBMEVCYWlJRFFjd0NSdzBBQzBNQUFJQy9JUkZCQVNFRVFRQWhBME1BQUlDL0lRNERRQUpBSUFjZ0EwRUNkQ0lKYWlvQ0FDSU5Rd0FBQUFCZVFRRnpEUUFnRUNBTlE4eThqQ3VVSWcwZ0RaUWlEWlFnRGlBTWxGNUJBWE1OQUNBUElBMlVJQkVnREpSZUJFQWdCU0VFSUFNaEJTQVJJUTRnRFNFUklBOGhFQ0FNSVE4TUFRc2dBeUVFSUEwaERpQU1JUkFMSUF3Z0JpQURRY3dDYWtFQ2RHb3FBZ0FpRENBTWxDQUdJQWxxS2dJQUlnd2dESlNUa2tNQUFJQS9seUVNSUFOQkFXb2lBMEdiQVVjTkFBdEJBQ0FFUVFGMGF5RUxRUUFnQlVFQmRHc2hCZ05BSUFjZ0NFRUNkQ0lFYWlJSlFRQTJBZ0FDUUNBR0lBaHFJZ01nQTBFZmRTSURhaUFEYzBFRFR3UkFJQWdnQzJvaUF5QURRUjkxSWdOcUlBTnpRUUpMRFFFTElBRWdCR29oQlVFQUlRTkRBQUFBQUNFTUEwQWdEQ0FBSUFOQkFuUWlCR29xQWdBZ0JDQUZhaW9DQUpTU0lRd2dBMEVCYWlJRFFaZ0ZSdzBBQ3lBSklBeERBQUNBdjVjNEFnQUxJQWhCQVdvaUNFRzJBa2NOQUF0REFBQ0FQeUVNUVFBaEF3TkFJQXdnQVNBRFFRSjBhaW9DQUNJUElBK1VraUVNSUFOQkFXb2lBMEdZQlVjTkFBdEJBQ0VGUXdBQWdMOGhFVU1BQUFBQUlROUJBQ0VBUVFBaEEwTUFBQUFBSVJCREFBQ0F2eUVPQTBBQ1FDQUhJQU5CQW5RaUJHb3FBZ0FpRFVNQUFBQUFYa0VCY3cwQUlCQWdEVVBNdkl3cmxDSU5JQTJVSWcyVUlBNGdESlJlUVFGekRRQWdEeUFObENBUklBeVVYZ1JBSUFNaEFDQVJJUTRnRFNFUklBOGhFQ0FNSVE4TUFRc2dEU0VPSUF3aEVBc2dEQ0FCSUFOQm1BVnFRUUowYWlvQ0FDSU1JQXlVSUFFZ0JHb3FBZ0FpRENBTWxKT1NRd0FBZ0QrWElRd2dBMEVCYWlJRFFiWUNSdzBBQ3dKQUlBQkJBVWdOQUNBQVFiVUNUZzBBSUFjZ0FFRUNkR29pQVNvQ0JDSU9JQUZCQkdzcUFnQWlFSk1nQVNvQ0FDSVBJQkNUUXpNek16K1VYZ1JBUVg4aEJRd0JDeUFRSUE2VElBOGdEcE5ETXpNelA1UmVSUTBBUVFFaEJRc2dBaUFGSUFCQkFYUnFOZ0lBSUFva0FBdjJCQUlGZnd0OUl3QkJNR3NpQkNRQUlBQW9BZ0FoQmtFQklRVURRQ0FCSUFWQkFuUnFJQVZCQTNRaUJ5QUdhaUlJS2dJQUlBaEJCR3NxQWdBZ0JpQUhRUVJ5YWlvQ0FKSkRBQUFBUDVTU1F3QUFBRCtVT0FJQUlBVkJBV29pQlVHQUNFY05BQXNnQVNBR0tnSUVRd0FBQUQrVUlBWXFBZ0NTUXdBQUFEK1VJZ2s0QWdBZ0FrRUNSZ1JBSUFBb0FnUWhBRUVCSVFVRFFDQUJJQVZCQW5ScUlnSWdBaW9DQUNBRlFRTjBJZ0lnQUdvaUJpb0NBQ0FHUVFScktnSUFJQUFnQWtFRWNtb3FBZ0NTUXdBQUFEK1Vra01BQUFBL2xKSTRBZ0FnQlVFQmFpSUZRWUFJUncwQUN5QUJJQWtnQUNvQ0JFTUFBQUEvbENBQUtnSUFra01BQUFBL2xKSTRBZ0FMUVFBaEJTQUJJQVJCRUdwQkFFRUFRUVFnQXhBMElBUWdCQ29DRUVOSEE0QS9sRGdDRUNBRUlBUXFBaFFpQ1NBSlEyOFNBenlVUTI4U0F6eVVremdDRkNBRUlBUXFBaGdpQ1NBSlEyOFNnenlVUTI4U2d6eVVremdDR0NBRUlBUXFBaHdpQ1NBSlE2YWJ4RHlVUTZhYnhEeVVremdDSENBRUlBUXFBaUFpQ1NBSlEyOFNBejJVUTI4U0F6MlVremdDSUNBRUlBUkJFR3BCQkJBMklBUXFBZ3hES3ZZblA1UWlDU0FFS2dJSVE3MmZPaitVSWdwRHpjeE1QNVNTSVEwZ0NpQUVLZ0lFUXloY1R6K1VJZ3BEemN4TVA1U1NJUTRnQ2lBRUtnSUFRMlptWmorVUlncER6Y3hNUDVTU0lROGdDVVBOekV3L2xDRVFJQXBEemN4TVA1SWhFVU1BQUFBQUlRbERBQUFBQUNFS0EwQWdBU0FGUVFKMGFpSUFJQkFnRXBRZ0RTQUxsQ0FPSUF5VUlBOGdDWlFnRVNBS2xDQUFLZ0lBSWhPU2twS1NramdDQUNBTElSSWdEQ0VMSUFraERDQUtJUWtnRXlFS0lBVkJBV29pQlVHQUNFY05BQXNnQkVFd2FpUUFDKzBFQWdaL0FYMGdBeUFDUVFGcUlnTWdBU0FCSUFKS0lnVWJRUUowUVlDeEFXb29BZ0FnQVNBRElBRWdBMG9iUVFKMGFpZ0NBQ0FCSUFJZ0FTQUNTQnRCQW5SQmdMRUJhaWdDQUNBQklBSWdCUnRCQW5ScUtBSUFhaEFXSVFRZ0FVRURUZ1JBQTBBQ2Z5QUJJZ1VnQWt3RVFDQUNJUU1DUUNBRlFRSjBJZ1pCZ0xFQmFpZ0NBQ0lJSUFacUtBSUFJQVFnQWtFQ2RDQUlhaWdDQkNJSFFYOUJBQ0FFSUFkUEd5SUhjV3NpQkVzRVFBTkFJQUZCQVdzaUFVRUNkRUdBc1FGcUtBSUFJQVpxS0FJQUlna2dCRXNOQUF3Q0N3QUxBMEFnQXlJQlFRRnJJUU1nQ0NBQlFRSjBhaWdDQUNJSklBUkxEUUFMQ3lBQUlBSWdCMm9nQVdzZ0IzTkJFSFJCRUhVaUFqWUNBQ0FLSUFLeUlnb2dDcFNTSVFvZ0FTRUNJQVFnQ1dzTUFRc2dCVUVDZENJRElBSkJBV29pQ0VFQ2RFR0FzUUZxS0FJQWFpZ0NBQ0VCQWtBZ0JDQUNRUUowUVlDeEFXb29BZ0FnQTJvb0FnQWlCa2tOQUNBQklBUk5EUUFnQUVFQU5nSUFJQVFnQm1zTUFRc2dCQ0FCUVg5QkFDQUJJQVJOR3lJRWNXc2hCZ05BSUFZZ0FpSUJRUUZySWdKQkFuUkJnTEVCYWlnQ0FDQURhaWdDQUNJSFNRMEFDeUFBSUFRZ0NHb2dBV3NnQkhOQkVIUkJFSFVpQVRZQ0FDQUtJQUd5SWdvZ0NwU1NJUW9nQmlBSGF3c2hCQ0FGUVFGcklRRWdBRUVFYWlFQUlBVkJBMG9OQUFzTElBQWdBaUFFSUFKQkFYUkJBWElpQVU4aUFtc2dCQ0FCUVg5QkFDQUNHeUlDY1dzaUEwRUJhaUlGUVFGMklnRnJJQUp6UVJCMFFSQjFJZ0kyQWdBZ0FDQUJJQU1nQlVGK2NVRUJhMEVBSUFFYmF5SUFhMEVBSUFCcmMwRVFkRUVRZFNJQU5nSUVJQW9nQXJJaUNpQUtsSklnQUxJaUNpQUtsSklMblFJQkJuOGdBQ0FCUVFGcklnaEJBblJxS0FJQUlnY2dCMEVmZFNJRWFpQUVjeUVFSUFkQkgzWWhCUU5BSUFFZ0NFRUJheUlIYXlJR0lBUWdCQ0FHU2h0QkFuUkJnTEVCYWlnQ0FDQUdJQVFnQkNBR1NCdEJBblJxS0FJQUlBVnFJUVVnQkNBQUlBZEJBblJxS0FJQUlna2dDVUVmZFNJRWFpQUVjMm9oQkNBSlFYOU1CRUFnQlNBRVFRRnFJZ1VnQmlBRUlBWklHMEVDZEVHQXNRRnFLQUlBSUFZZ0JTQUZJQVpJRzBFQ2RHb29BZ0JxSVFVTElBaEJBVW9oQmlBSElRZ2dCZzBBQ3lBRElBVWdBa0VCYWlJQUlBRWdBU0FDU2lJREcwRUNkRUdBc1FGcUtBSUFJQUVnQUNBQUlBRklHMEVDZEdvb0FnQWdBU0FDSUFFZ0FrZ2JRUUowUVlDeEFXb29BZ0FnQVNBQ0lBTWJRUUowYWlnQ0FHb1FVUXY3QkFJSmZ3TjlJd0JCRUdzaUJTRUhJQVVrQUNBRlFlQUFheUlKSWdVa0FDQUZJQU5CR0dvaUJrRUNkRUVQYWtGd2NXc2lDQ1FBSUFZQ2YwRUFJZ1ZCQUEwQUdnTkFJQWtnQlVFQ2RHb2dBU0FGUVg5elFSaHFRUUowYWlvQ0FEZ0NBQ0FGUVFGcUlnVkJHRWNOQUF0QkFDSUZRUUFOQUJvRFFDQUlJQVZCQW5ScUlBUWdCVUYvYzBFWWFrRUNkR29xQWdDTU9BSUFJQVZCQVdvaUJVRVlSdzBBQzBFWUN5SUZTZ1JBSUFnZ0JVRUNkR3BCQUNBR0lBVnJRUUowRUFVYUMwRUFJUVlnQTBFRVRnUkFJQU5CQTJzaEN3TkFJQWNnQUNBR1FRSjBJZ1ZxS2dJQU9BSUFJQWNnQUNBRlFRUnlJZ3hxS2dJQU9BSUVJQWNnQUNBRlFRaHlJZzFxS2dJQU9BSUlJQWNnQUNBRlFReHlJZzVxS2dJQU9BSU1JQWtnQlNBSWFpQUhFRFVnQ0NBR1FSaHFRUUowYWlJS0lBY3FBZ0FpRDR3NEFnQWdBaUFGYWlBUE9BSUFJQW9nQnlvQ0JDQVBJQUVxQWdDVWt5SVFqRGdDQkNBQ0lBeHFJQkE0QWdBZ0NpQUhLZ0lJSUJBZ0FTb0NBSlNUSUE4Z0FTb0NCSlNUSWhHTU9BSUlJQUlnRFdvZ0VUZ0NBQ0FLSUFjcUFnd2dFU0FCS2dJQWxKTWdFQ0FCS2dJRWxKTWdEeUFCS2dJSWxKTWlENHc0QWd3Z0FpQU9haUFQT0FJQUlBWkJCR29pQmlBTFNBMEFDd3NnQXlBR1NnUkFBMEFnQUNBR1FRSjBJZ0ZxS2dJQUlROUJBQ0VGQTBBZ0R5QUpJQVZCQW5ScUtnSUFJQWdnQlNBR2FrRUNkR29xQWdDVWt5RVBJQVZCQVdvaUJVRVlSdzBBQ3lBSUlBWkJHR3BCQW5ScUlBODRBZ0FnQVNBQ2FpQVBPQUlBSUFaQkFXb2lCaUFEUncwQUN3dEJBQ0VGQTBBZ0JDQUZRUUowYWlBQ0lBVkJmM01nQTJwQkFuUnFLZ0lBT0FJQUlBVkJBV29pQlVFWVJ3MEFDeUFIUVJCcUpBQUw2QUlDQjM4QmZTTUFRUkJySWdVaEJDQUZKQUFnQlVIZ0FHc2lCaVFBUVFBaEJRTkFJQVlnQlVFQ2RHb2dBU0FGUVg5elFSaHFRUUowYWlvQ0FEZ0NBQ0FGUVFGcUlnVkJHRWNOQUF0QkFDRUJJQU5CQkU0RVFDQURRUU5ySVFjRFFDQUVJQUFnQVVFQ2RDSUZhaUlJS2dJQU9BSUFJQVFnQUNBRlFRUnlJZ2xxS2dJQU9BSUVJQVFnQUNBRlFRaHlJZ3BxS2dJQU9BSUlJQVFnQUNBRlFReHlJZ3RxS2dJQU9BSU1JQVlnQ0VIZ0FHc2dCQkExSUFJZ0JXb2dCQ29DQURnQ0FDQUNJQWxxSUFRcUFnUTRBZ0FnQWlBS2FpQUVLZ0lJT0FJQUlBSWdDMm9nQkNvQ0REZ0NBQ0FCUVFScUlnRWdCMGdOQUFzTElBRWdBMGdFUUFOQUlBRkJHR3NoQnlBQUlBRkJBblFpQ0dvcUFnQWhERUVBSVFVRFFDQU1JQVlnQlVFQ2RHb3FBZ0FnQUNBRklBZHFRUUowYWlvQ0FKU1NJUXdnQlVFQmFpSUZRUmhIRFFBTElBSWdDR29nRERnQ0FDQUJRUUZxSWdFZ0EwY05BQXNMSUFSQkVHb2tBQXVmR1FJMWZ3VjlJd0JCNENGcklnWWhBeUFHSkFBZ0FDZ0NDQ0lJUVFFZ0NFRUJTaHNoRlVFQUlBRnJJUkVnQUNnQ0FDSUtLQUlFSWdsQmdCQnFJUVFnQ2lnQ0lDRVNJQW9vQWdnaEN3TkFJQVZCQW5RaUJ5QURRZGdoYW1vZ0FDQUVJQVZzUVFKMGFrSGNBR29pRXpZQ0FDQURRZEFoYWlBSGFpQVRJQkZCQW5ScVFZQkFhellDQUNBRlFRRnFJZ1VnRlVjTkFBc2dBQ0FFSUFoc1FRSjBha0hjQUdvaERDQUFLQUlVSVFRQ1FBSkFBa0FnQUNnQ05DSVRRUVJLRFFBZ0JBMEFJQUFvQWpoRkRRRUxJQXdnQ0VIZ0FHeHFJUTRnQkNBQUtBSVlJZ2NnQ2lnQ0RDSUZJQVVnQjBvYklneEtJUkVnQmlBQklBaHNRUUowUVE5cVFYQnhheUlQSkFBZ0JDQUhTQVJBSUE0Z0MwRURkQ0lGYWlBRmFpQUZhaUVOUXdBQUFEOURBQURBUHlBVEd5RTRRUUFoQmdOQUlBWWdDMndoRkNBRUlRVURRQ0FPSUFVZ0ZHcEJBblFpRm1vaUZ5QU5JQlpxS2dJQUlqa2dGeW9DQUNBNGt5STZJRGtnT2w0Yk9BSUFJQVZCQVdvaUJTQUhSdzBBQ3lBR1FRRnFJZ1lnRlVjTkFBc0xJQVFnRENBUkd5RVJJQUFvQWlnaEJnSkFJQWhCQVVnTkFDQUVJQXhPRFFCQkFDRUxBMEFnQVNBTGJDRVVJQVFoQndOQVFRQWhCU0FTSUFkQkFYUnFMZ0VBSWcwZ0FuUWdGR29oRENBU0lBZEJBV29pQjBFQmRHb3VBUUFnRFdzZ0FuUWlEVUVBU2dSQUEwQWdEeUFGSUF4cVFRSjBhaUFHUVkzTTVRQnNRZC9tdStNRGFpSUdRUlIxc2pnQ0FDQUZRUUZxSWdVZ0RVY05BQXNMSUE4Z0RFRUNkR29nRFVNQUFJQS9JQUFvQWlRUUxpQUhJQkZIRFFBTElBdEJBV29pQ3lBSVJ3MEFDd3NnQUNBR05nSW9JQWxCQVhZZ0FXdEJBblJCZ0VCcklRWkJBQ0VGQTBBZ0EwSFlJV29nQlVFQ2RHb29BZ0FpQ1NBSklBRkJBblJxSUFZUURob2dCVUVCYWlJRklCVkhEUUFMSUFvZ0R5QURRZEFoYWlBT0lBUWdFU0FJSUFoQkFDQUNJQUFvQWhCQkFDQUFLQUlrRUNJTUFRc0NmU0FUUlFSQUlBTkIyQ0ZxSUFOQjhBQnFJQWdnQUNnQ0pCQldJQU5Ca0F4cUlBTkI4QUJxSUFNUVZTQUFRZEFGSUFNb0FnQnJJZ0kyQWpCREFBQ0FQd3dCQ3lBQUtBSXdJUUpEemN4TVB3c2hQQ0FDUVFGMElnUkJnQWdnQkVHQUNFZ2JJZ2RCZnlBSFFYOUtHeUlFUVFFZ0JFRUJTQnNnQjBFQUlBZHJJZ1FnQkNBSFNCdEJBWFpzSWdSQkFTQUVRUUZLR3lFWklBWWdDVUVDZEVFUGFrRndjV3NpRWlJRUpBQkJnQWdnQjJzaEdrR0FDQ0FIUVFGMWF5RWJJQU1nQjBFQ2RDSU5hMEhRSVdvaEZDQUpRUUp0SVJ4QmdBZ2dBbXNoSFNBQklBbHFJZ2hCQW5RaEhrR0FFQ0FCYXlJT1FRSjBJUllnQkNBTlFROXFRWEJ4YXlJWEpBQWdBMEhRQVdvaER5QUtLQUk4SVF0Qi93OGdBV3RCQW5RaEgwSCtEeUFCYTBFQ2RDRWdRZjBQSUFGclFRSjBJU0ZCL0E4Z0FXdEJBblFoSWtIN0R5QUJhMEVDZENFalFmb1BJQUZyUVFKMElTUkIrUThnQVd0QkFuUWhKVUg0RHlBQmEwRUNkQ0VtUWZjUElBRnJRUUowSVNkQjlnOGdBV3RCQW5RaEtFSDFEeUFCYTBFQ2RDRXBRZlFQSUFGclFRSjBJU3BCOHc4Z0FXdEJBblFoSzBIeUR5QUJhMEVDZENFc1FmRVBJQUZyUVFKMElTMUI4QThnQVd0QkFuUWhMa0h2RHlBQmEwRUNkQ0V2UWU0UElBRnJRUUowSVRCQjdROGdBV3RCQW5RaE1VSHNEeUFCYTBFQ2RDRXlRZXNQSUFGclFRSjBJVE5CNmc4Z0FXdEJBblFoTkVIcER5QUJhMEVDZENFMVFlZ1BJQUZyUVFKMElUWkJBQ0VLQTBBZ0EwSFlJV29nQ2tFQ2RHb29BZ0FoQkVFQUlRVURRQ0FGUVFKMElnWWdBMEh3QUdwcUlBUWdCbXBCb0I5cUtnSUFPQUlBSUFWQkFXb2lCVUdZQ0VjTkFBc0NRQ0FUQkVBZ0NrRVliQ0VGREFFTElBOGdBeUFMSUFsQkdDQUFLQUlrRURRZ0F5QURLZ0lBUTBjRGdEK1VPQUlBSUFNZ0F5b0NCQ0k0SURoRHZqZUdPSlNUT0FJRUlBTWdBeW9DQ0NJNElEaER2amVHT0pRaU9DQTRraUk0SURpU2t6Z0NDQ0FESUFNcUFnd2lPQ0E0UTc0M2hqaVVRd0FBUUVDVVF3QUFRRUNVa3pnQ0RDQURJQU1xQWhBaU9DQTRRNzQzaGppVVF3QUFnRUNVUXdBQWdFQ1VremdDRUNBRElBTXFBaFFpT0NBNFE3NDNoamlVUXdBQW9FQ1VRd0FBb0VDVWt6Z0NGQ0FESUFNcUFoZ2lPQ0E0UTc0M2hqaVVRd0FBd0VDVVF3QUF3RUNVa3pnQ0dDQURJQU1xQWh3aU9DQTRRNzQzaGppVVF3QUE0RUNVUXdBQTRFQ1VremdDSENBRElBTXFBaUFpT0NBNFE3NDNoamlVUXdBQUFFR1VRd0FBQUVHVWt6Z0NJQ0FESUFNcUFpUWlPQ0E0UTc0M2hqaVVRd0FBRUVHVVF3QUFFRUdVa3pnQ0pDQURJQU1xQWlnaU9DQTRRNzQzaGppVVF3QUFJRUdVUXdBQUlFR1VremdDS0NBRElBTXFBaXdpT0NBNFE3NDNoamlVUXdBQU1FR1VRd0FBTUVHVWt6Z0NMQ0FESUFNcUFqQWlPQ0E0UTc0M2hqaVVRd0FBUUVHVVF3QUFRRUdVa3pnQ01DQURJQU1xQWpRaU9DQTRRNzQzaGppVVF3QUFVRUdVUXdBQVVFR1VremdDTkNBRElBTXFBamdpT0NBNFE3NDNoamlVUXdBQVlFR1VRd0FBWUVHVWt6Z0NPQ0FESUFNcUFqd2lPQ0E0UTc0M2hqaVVRd0FBY0VHVVF3QUFjRUdVa3pnQ1BDQURJQU1xQWtBaU9DQTRRNzQzaGppVVF3QUFnRUdVUXdBQWdFR1VremdDUUNBRElBTXFBa1FpT0NBNFE3NDNoamlVUXdBQWlFR1VRd0FBaUVHVWt6Z0NSQ0FESUFNcUFrZ2lPQ0E0UTc0M2hqaVVRd0FBa0VHVVF3QUFrRUdVa3pnQ1NDQURJQU1xQWt3aU9DQTRRNzQzaGppVVF3QUFtRUdVUXdBQW1FR1VremdDVENBRElBTXFBbEFpT0NBNFE3NDNoamlVUXdBQW9FR1VRd0FBb0VHVWt6Z0NVQ0FESUFNcUFsUWlPQ0E0UTc0M2hqaVVRd0FBcUVHVVF3QUFxRUdVa3pnQ1ZDQURJQU1xQWxnaU9DQTRRNzQzaGppVVF3QUFzRUdVUXdBQXNFR1VremdDV0NBRElBTXFBbHdpT0NBNFE3NDNoamlVUXdBQXVFR1VRd0FBdUVHVWt6Z0NYQ0FESUFNcUFtQWlPQ0E0UTc0M2hqaVVRd0FBd0VHVVF3QUF3RUdVa3pnQ1lDQU1JQXBCR0d3aUJVRUNkR29nQTBFWUVEWUxJQlFnRENBRlFRSjBhaUkzSUJjZ0J5QUFLQUlrRUZvZ0ZDQVhJQTBRQkJwREFBQ0FQeUU0UVFBaEJVTUFBSUEvSVRzZ0FrRUJUZ1JBQTBBZ09DQVBJQVVnR21wQkFuUnFLZ0lBSWpnZ09KU1NJVGdnT3lBUElBVWdHMnBCQW5ScUtnSUFJamtnT1pTU0lUc2dCVUVCYWlJRklCbEhEUUFMQ3lBRUlBUWdBVUVDZEdvZ0ZoQU9JUVJEQUFBQUFDRTZRd0FBQUFBaE9TQUlRUUZJSWhCRkJFQWdQQ0E3SURnZ09DQTdYaHNnT0pXUklqdVVJVGhCQUNFR1FRQWhCUU5BSUFRZ0JpQU9ha0VDZEdvZ09DQTdJRGlVSUFJZ0JVb2lHQnNpT0NBUElBVkJBQ0FDSUJnYmF5SUZJQjFxSWhoQkFuUnFLZ0lBbERnQ0FDQUZRUUZxSVFVZ09TQVlJQUZyUVFKMElBUnFRWUFnYWlvQ0FDSTVJRG1Va2lFNUlBWkJBV29pQmlBSVJ3MEFDd3NnQXlBRUlCOXFLZ0lBT0FJQUlBTWdCQ0FnYWlvQ0FEZ0NCQ0FESUFRZ0lXb3FBZ0E0QWdnZ0F5QUVJQ0pxS2dJQU9BSU1JQU1nQkNBamFpb0NBRGdDRUNBRElBUWdKR29xQWdBNEFoUWdBeUFFSUNWcUtnSUFPQUlZSUFNZ0JDQW1haW9DQURnQ0hDQURJQVFnSjJvcUFnQTRBaUFnQXlBRUlDaHFLZ0lBT0FJa0lBTWdCQ0FwYWlvQ0FEZ0NLQ0FESUFRZ0ttb3FBZ0E0QWl3Z0F5QUVJQ3RxS2dJQU9BSXdJQU1nQkNBc2Fpb0NBRGdDTkNBRElBUWdMV29xQWdBNEFqZ2dBeUFFSUM1cUtnSUFPQUk4SUFNZ0JDQXZhaW9DQURnQ1FDQURJQVFnTUdvcUFnQTRBa1FnQXlBRUlERnFLZ0lBT0FKSUlBTWdCQ0F5YWlvQ0FEZ0NUQ0FESUFRZ00yb3FBZ0E0QWxBZ0F5QUVJRFJxS2dJQU9BSlVJQU1nQkNBMWFpb0NBRGdDV0NBRElBUWdObW9xQWdBNEFsd2dCRUdBUUdzaUJTQVJRUUowYWlJR0lEY2dCaUFJSUFNZ0FDZ0NKQkJaUVFBaEJnSkFBa0FnRUVVRVFBTkFJRG9nQkNBR0lBNXFRUUowYWlvQ0FDSTRJRGlVa2lFNklBWkJBV29pQmlBSVJ3MEFDeUE1SURwRHpjeE1QcFJlRFFFZ0VBMENJQVFnRm1wQkFDQWVFQVVhREFJTElEbERBQUFBQUY1RkRRRUxJRGtnT2wxQkFYTU5BQ0E1UXdBQWdEK1NJRHBEQUFDQVA1S1ZrU0U0SUFsQkFVNEVRRU1BQUlBL0lEaVRJVGxCQUNFR0EwQWdCQ0FHSUE1cVFRSjBhaUlRSUJBcUFnQkRBQUNBUHlBNUlBc2dCa0VDZEdvcUFnQ1VrNVE0QWdBZ0JrRUJhaUlHSUFsSERRQUxDeUFKSVFZZ0FVRUFUQTBBQTBBZ0JDQUdJQTVxUVFKMGFpSVFJRGdnRUNvQ0FKUTRBZ0FnQmtFQmFpSUdJQWhJRFFBTEMwRUFJUVlnRWlBRklBQW9BandpQlNBRklBa2dBQ29DUkl3aU9DQTRJQUFvQWt3aUJTQUZRUUJCQUNBQUtBSWtFQmtnQ1VFQ1RnUkFBMEFnQmtFQ2RDSUZJQVJxUVlCQWF5QUZJQXRxS2dJQUlCSWdDU0FHUVg5emFrRUNkQ0lRYWlvQ0FKUWdDeUFRYWlvQ0FDQUZJQkpxS2dJQWxKSTRBZ0FnQmtFQmFpSUdJQnhIRFFBTEN5QUtRUUZxSWdvZ0ZVY05BQXNMSUFBZ0UwRUJhallDTkNBRFFlQWhhaVFBQzYwQkFRRi9Ba0FnQWtFQ1RRUi9JQUFOQVVGNUJVRi9DdzhMSUFCQkFFR2dQU2dDQUVFQ2RFSGd3QUJxSUFKc1FhUTlLQUlBUVFWMGFrSGNBR29RQlNJQVFadzlOZ0lBUWFBOUtBSUFJUU1nQUVJQk53SVFJQUFnQWpZQ0RDQUFJQUkyQWdnZ0FDQUROZ0lFUWFnOUtBSUFJUU1nQUVFQk5nSWNJQUFnQWtFQlJqWUNJQ0FBUVFBMkFpUWdBQ0FETmdJWUlBQkJ2QjlCQUJBSEdpQUFJQUVRWHlJQU5nSVFRUUJCZnlBQUd3dmJBUUVHZndKQUlBRWdBQkNjQVNJSFN3UkFJQUVoQmd3QkMwRUJJUVlDUUFKQVFZQ0FBU0FDYTBIZy93RWdBV3RzUVE5MklnVkZCRUFnQVNFRVFRRWhBd3dCQzBFQklRTURRQ0FGUVFGcUlnVkJBWFFpQ0NBQmFpSUVJQWRMQkVBZ0JTRUdEQU1MSUFOQkFXb2hBeUFFSVFFZ0NFRUNheUFDYkVFUGRpSUZEUUFMQ3lBSElBUnJJZ0pCZm5FZ0JHb2hBU0FDUVFGMklBTnFJUU1MUVFBZ0Eyc2dBeUFISUFFZ0Jtb2lBa2tpQlJzaEJDQUJJQUlnQlJzaEF3c2dBQ0FESUFNZ0Jtb2lBRUdBZ0FJZ0FFR0FnQUpKRzBHQWdBSVFNU0FFQzRVQkFRZC9JQUFvQWdnaUJVRUJUZ1JBSUFNZ0FrRUJkR3BCQVdzaEJ5QUFLQUpvSVFnZ0FDZ0NJQ0lKTHdFQUlRWURRQ0FHUVJCMElRb2dBU0FFUVFKMGFpQUlJQVVnQjJ3Z0JHcHFMUUFBUVVCcklBa2dCRUVCYWlJRVFRRjBhaTRCQUNJR0lBcEJFSFZySUFKMElBTnNiRUVDZFRZQ0FDQUVJQUFvQWdnaUJVZ05BQXNMQzFNQUFuOENRQUpBSUFCQi8vd0FUQVJBSUFCQndENUdEUUVnQUVIZzNRQkhEUUpCQkE4TElBQkJnUDBBUndSQVFRRWdBRUdBOXdKR0RRTWFJQUJCd0xzQlJ3MENRUUlQQzBFRER3dEJCZzhMUVFBTEM0UUNBUVovSXdBaUJDRUhJQVFnQVNBQ2JDSUlRUUowUVE5cVFYQnhheUlGSkFBQ1FDQURSUVJBSUFKQkFVZ05BU0FCUVFGSURRRkJBQ0VFQTBBZ0FTQUViQ0VHUVFBaEF3TkFJQVVnQWlBRGJDQUVha0VDZEdvZ0FDQURJQVpxUVFKMGFpb0NBRGdDQUNBRFFRRnFJZ01nQVVjTkFBc2dCRUVCYWlJRUlBSkhEUUFMREFFTElBSkJBVWdOQUNBQlFRRklEUUFnQWtFQ2RFSG9PV29oQmtFQUlRUURRQ0FHSUFSQkFuUnFLQUlBSUFGc0lRbEJBQ0VEQTBBZ0JTQUNJQU5zSUFScVFRSjBhaUFBSUFNZ0NXcEJBblJxS2dJQU9BSUFJQU5CQVdvaUF5QUJSdzBBQ3lBRVFRRnFJZ1FnQWtjTkFBc0xJQUFnQlNBSVFRSjBFQVFhSUFja0FBdmNHQU5NZndGK0JYMGpBRUdnREdzaUZTRVVJQlVrQUNBVlFRSkJBU0FFR3lJcElBQW9BaUFpSVNBQUtBSUlRUUYwYWtFQ2F5NEJBQ0FoSUFGQkFYUnFJanN1QVFBaUttc2dEM1JzUVFKMFFROXFRWEJ4YXlJYUloWWtBQ0FoSUFBb0FnaEJBWFJxUVFKckxnRUFJQTkwUVFKMEloc2dBMm9oSENBV1FSQnJJandpRlNRQUlCVkJFR3NpUFNJVkpBQWdGVUVRYXlJK0loVWtBQ0FWUVJCcklqOGlGU1FBSUJWQkVHc2lNU1FBSUJRZ0RqWUMvQXNnRkVFQU5nS0VEQ0FVSUFvMkF2QUxJQlJCQURZQzRBc2dGQ0FBTmdMb0N5QVJLQUlBSVJVZ0ZDQVROZ0tVRENBVUlCSTJBb3dNSUJRZ0NEWUM5QXNnRkNBVk5nS0lEQ0FVUVFFZ0QzUkJBU0FIR3lJZlFRRktJZ2MyQXBnTUlCUkJBRFlDa0F3Z0ZFRUJOZ0xrQ3lBUklBRWdBa2dFZnlBYVFRQWdCQnNoUUNBSVFRTkhJQWR5SVVFZ0tVRUJheUV5SUFGQkFtb2hNeUFCUVFGcUlTZ2dBa0VCYXlFMElCb2dHMm9nS2lBUGRDSTFRUUowYXlJbFFRQWdOV3RCQW5RaUIyb2hRaUFISUJwcUlTSkJmeUFmZEVGL2N5RVRJQUVoQ0VFQUlSdEJBU0VTQTBBZ0ZDQUlJaFUyQXV3TElDRWdGVUVCZEdvaUhTNEJBQ0VISUNFZ0ZVRUJhaUlJUVFGMGFpNEJBQ0VXSUJRZ0RDQU9FQXNpTm1zaUVVRUJhellDZ0F3Z0J5QVBkQ0VYSUExQkFDQTJJQUVnRlVZYmF5RTNBbjlCQUNBUUlCVk1EUUFhUWYvL0FDQVJJQVlnRlVFQ2RHb29BZ0FnTnlBUUlCVnJJZzFCQXlBTlFRTklHMjFxSWcwZ0RTQVJTaHNpRFVILy93QktEUUFhSUExQkFDQU5RUUJLR3dzaEpDQVhRUUowSVEwZ0ZpQUhheUVIQWtBZ0ZTQW9Sd1JBSUIwdUFRQWdCMnNnRDNRZ095NEJBQ0FQZEVnTkFRc2dGU0FiSUJVZ0d4c2dFaHNoR3dzZ0JDQU5haUVXQWtBZ0ZTQW9SeUpERFFBZ0dpQUFLQUlnSWhFZ0tFRUJkR291QVFBaUZ5QVJJQUZCQVhScUxnRUFheUFQZENJU1FRSjBJaGxxSUJvZ0VrRUJkQ0FSSUROQkFYUnFMZ0VBSUJkcklBOTBJaEZyUVFKMEloZHFJQkVnRW10QkFuUWlFUkFFR2lBSlJRMEFJQmtnSldvZ0Z5QWxhaUFSRUFRYUN5QVdRUUFnQkJzaElDQURJQTFxSVNNZ0J5QVBkQ0VYSUJRZ0N5QVZRUUowSWpocUtBSUFJaEkyQXZnTFFRQWdIRUVBSUJVZ0FDZ0NERWdpR0JzaUhDQVZJRFJHSWg0YklTWkJmeUVaQWtBZ0cwVUVRQ0FUSWhFaERRd0JDeUFUSWhFaERTQkJJQkpCQUVoeVJRMEFJQ0VnRzBFQmRHb3VBUUFnQnlBcWFtc2dEM1FpQjBFQUlBZEJBRW9iSWhrZ05Xb2hEU0FiSVFjRFFDQWhJQWNpRWtFQmF5SUhRUUYwYWk0QkFDQVBkQ0FOU2cwQUN5QU5JQmRxSVNjZ0cwRUJheUVXSUJzZ0ZTQVZJQnRJRzBFQmF5RVJBMEFDUUNBUklCWWlEVVlFUUNBUklRME1BUXNnSVNBTlFRRnFJaFpCQVhScUxnRUFJQTkwSUNkSURRRUxDeUFISUEwZ0RTQVNTQnNoRWtFQUlSRkJBQ0VOQTBBZ0VTQUZJQWNnS1d3aUZtb3RBQUJ5SVJFZ0RTQUZJQllnTW1wcUxRQUFjaUVOSUFjZ0VrY2hGaUFIUVFGcUlRY2dGZzBBQ3dzZ0ppRWNJQ01nR2lBWUd5RVNJQ0FnUUNBWUd5RVlBbjhDUUNBSlJRMEFJQW9nRlVZRVFFRUFJUWNnSFM0QkFDQXFheUFQZENJSlFRRklEUUVEUUNBYUlBZEJBblFpRm1vaUlDQWdLZ0lBSUJZZ0pXb3FBZ0NTUXdBQUFEK1VPQUlBSUFkQkFXb2lCeUFKUncwQUN3d0JDeUFLSUJWR0RRQkJBQ0FhSUJsQkFuUWlCMm9nR1VGL1JpSVdHeUVlSUJSQjRBdHFJQmdnRnlBa1FRRjJJaGdnSHdKL0lCVWdORVlFUUVFQUlSa2dGRUhnQzJvZ0VpQVhJQmdnSHlBZUlBOUJBRU1BQUlBL0lCd2dFUkFLSVJGQkFDQUhJQ1ZxSUJZYkRBRUxJQlJCNEF0cUlCSWdGeUFZSUI4Z0hpQVBJQ0lnSFM0QkFDQVBkRUVDZEdwREFBQ0FQeUFjSUJFUUNpRVJJRUlnSFM0QkFDQVBkRUVDZEdvaEdVRUFJQWNnSldvZ0Zoc0xJQThnR1VNQUFJQS9JQndnRFJBS0RBRUxBa0FnR0FSQVFRRkZCRUFnT0NvQ0FDRmtJQUFvQWdnZ0ZXcEJBblFxQWdBaFl5QU9LQUlFSVRrZ0RpZ0NBQ0U2SUJSQjJBdHFJa1FnRGlrQ0VEY0RBQ0FVSUE0cEFnZzNBOUFMSUE0b0FoZ2hJeUFVUWNnTGFpSkZJQTRvQWl3MkFnQWdGRUhBQzJvaVJpQU9LUUlrTndNQUlCUWdEaWtDSERjRHVBc2dGRUdBQzJvaVJ5QVVRWmdNYWlJbUtBSUFOZ0lBSUJSQitBcHFJa2dnRkVHUURHb2lJQ2tEQURjREFDQVVRZkFLYWlKSklCUkJpQXhxSWljcEF3QTNBd0FnRkVIb0Ntb2lTaUFVUVlBTWFpSXJLUU1BTndNQUlCUkI0QXBxSWtzZ0ZFSDRDMm9pTENrREFEY0RBQ0FVUWRnS2FpSk1JQlJCOEF0cUlpMHBBd0EzQXdBZ0ZFSFFDbW9pVFNBVVFlZ0xhaUl1S1FNQU53TUFJQlFnRkNrRDRBczNBOGdLSUR3Z0VpQVhRUUowSWhZUUJDRXZJRDBnR0NBV0VBUWhNQ0FnUVg4MkFnQkJBQ0VISUEwZ0VYSWhFVU1BQUFBQUlXRWdGRUhnQzJvZ0VpQVlJQmNnSkNBZlFRQWdHaUFaUVFKMGFpQVpRWDlHR3lKT0lBOGdIZ1IvUVFBRklDSWdIUzRCQUNBUGRFRUNkR29MSUJ3Z0VSQWtJUWxEQUFBQUFDRmlJQmRCQVVnaVQwVUVRQU5BSUdJZ0x5QUhRUUowSWcxcUtnSUFJQTBnRW1vcUFnQ1VraUZpSUFkQkFXb2lCeUFYUncwQUMwRUFJUWNEUUNCaElEQWdCMEVDZENJTmFpb0NBQ0FOSUJocUtnSUFsSkloWVNBSFFRRnFJZ2NnRjBjTkFBc0xJQlJCc0F0cUlsQWdEaWtDS0RjREFDQVVRYWdMYWlKUklBNHBBaUEzQXdBZ0ZFR2dDMm9pVWlBT0tRSVlOd01BSUJSQm1BdHFJbE1nRGlrQ0VEY0RBQ0FVUVpBTGFpSlVJQTRwQWdnM0F3QWdEaWtDQUNGZ0lCUkJrQXBxSWxVZ0xpa0RBRGNEQUNBVVFaZ0thaUpXSUMwcEF3QTNBd0FnRkVHZ0Ntb2lWeUFzS1FNQU53TUFJQlJCcUFwcUlsZ2dLeWtEQURjREFDQVVRYkFLYWlKWklDY3BBd0EzQXdBZ0ZFRzRDbW9pV2lBZ0tRTUFOd01BSUJSQndBcHFJbHNnSmlnQ0FEWUNBQ0FVSUdBM0E0Z0xJQlFnRkNrRDRBczNBNGdLSUQ0Z0VpQVdFQVFoWENBL0lCZ2dGaEFFSVYwZ0hrVUVRQ0F4SUNJZ0hTNEJBQ0FQZEVFQ2RHb2dGaEFFR2dzZ0ZDQWpJRHBxSWw0Z09TQWpheUpmRUFRaERTQU9JRGsyQWdRZ0RpQTZOZ0lBSUE0Z1JDa0RBRGNDRUNBT0lBMHBBOUFMTndJSUlBNGdJellDR0NBT0lFVW9BZ0EyQWl3Z0RpQkdLUU1BTndJa0lBNGdEU2tEdUFzM0Fod2dMaUJOS1FNQU53TUFJQzBnVENrREFEY0RBQ0FzSUVzcEF3QTNBd0FnS3lCS0tRTUFOd01BSUNjZ1NTa0RBRGNEQUNBZ0lFZ3BBd0EzQXdBZ0ppQkhLQUlBTmdJQUlBMGdEU2tEeUFvM0ErQUxJQklnTHlBV0VBUWhFaUFZSURBZ0ZoQUVJUmtnUTBVRVFDQWFJQUFvQWlBaUJ5QW9RUUYwYWk0QkFDSWpJQWNnQVVFQmRHb3VBUUJySUE5MEloaEJBblJxSUJvZ0dFRUJkQ0FISUROQkFYUnFMZ0VBSUNOcklBOTBJZ2RyUVFKMGFpQUhJQmhyUVFKMEVBUWFDeUFOUVFFMkFwQU1RUUFoQnlCaklHUWdZeUJqSUdSZUcwTUFBRUJBbFNKbGtpRmpJR1FnWlpJaVpDQmlsQ0JqSUdHVWtpRmxRd0FBQUFBaFlTQU5RZUFMYWlBU0lCa2dGeUFrSUI4Z1RpQVBJQjRFZjBFQUJTQWlJQjB1QVFBZ0QzUkJBblJxQ3lBY0lCRVFKQ0VSUXdBQUFBQWhZaUJQUlFSQUEwQWdZaUF2SUFkQkFuUWlHR29xQWdBZ0VpQVlhaW9DQUpTU0lXSWdCMEVCYWlJSElCZEhEUUFMUVFBaEJ3TkFJR0VnTUNBSFFRSjBJaGhxS2dJQUlCZ2dHV29xQWdDVWtpRmhJQWRCQVdvaUJ5QVhSdzBBQ3dzZ1pTQmtJR0tVSUdNZ1laU1NZRUVCYzBVRVFDQU9JQTBwQTRnTE53SUFJQTRnVUNrREFEY0NLQ0FPSUZFcEF3QTNBaUFnRGlCU0tRTUFOd0lZSUE0Z1V5a0RBRGNDRUNBT0lGUXBBd0EzQWdnZ0xpQlZLUU1BTndNQUlDMGdWaWtEQURjREFDQXNJRmNwQXdBM0F3QWdLeUJZS1FNQU53TUFJQ2NnV1NrREFEY0RBQ0FnSUZvcEF3QTNBd0FnSmlCYktBSUFOZ0lBSUEwZ0RTa0RpQW8zQStBTElCSWdYQ0FXRUFRYUlCa2dYU0FXRUFRYUlCNUZCRUFnSWlBZExnRUFJQTkwUVFKMGFpQXhJQllRQkJvTElGNGdEU0JmRUFRYUlBa2hFUXRCQUNFSkRBSUxRUUFoQ1NBVVFRQTJBcEFNSUJSQjRBdHFJQklnR0NBWElDUWdIMEVBSUJvZ0dVRUNkR29nR1VGL1Joc2dEeUFlQkg5QkFBVWdJaUFkTGdFQUlBOTBRUUowYWdzZ0hDQU5JQkZ5RUNRaEVRd0JDMEVBSVFrZ0ZFSGdDMm9nRWlBWElDUWdIMEVBSUJvZ0dVRUNkR29nR1VGL1Joc2dEeUFlQkg5QkFBVWdJaUFkTGdFQUlBOTBRUUowYWd0REFBQ0FQeUFjSUEwZ0VYSVFDaUVSQ3lBUkN5RUhJQVVnRlNBcGJDSU5haUFST2dBQUlBVWdEU0F5YW1vZ0J6b0FBQ0FHSURocUtBSUFJUWNnRkVFQU5nS1lEQ0FISURZZ04ycHFJUTBnSkNBWFFRTjBTaUVTSUFJZ0NFY05BQXNnRkNnQ2lBd0ZJQlVMTmdJQUlCUkJvQXhxSkFBTEJBQkJBQXZXQkFNUGZ3VjlBWHdnQmlBSFNBUkFRUUVnQTNRaUVFRUJJQkJCQVVvYklSUWdCRUVCSUFSQkFVb2JJUmNnQTBFRFJpRVlJQU5CSDBZaEdRTkFRd0FBZ0Q4Z0FDZ0NJQ0lPSUFZaUVFRUJhaUlHUVFGMGFpNEJBQ0FPSUJCQkFYUWlHbW91QVFCckloTWdBM1FpRzdlZnRwVWhJU0FMSUJCQkFuUnFLQUlBUVFGcUlCTnVJQU4yc2tNQUFBQytsTHRFN3puNi9rSXU1aitpRUIrMlF3QUFBRCtVSVNBZ0JDQVFiQ0VjUVFBaEVnTkFJQW9nQUNnQ0NDSVBJQkpzSUJCcVFRSjBJZzVxS2dJQUlSMGdDU0FPYWlvQ0FDRWVJQWdnRG1vcUFnQUNmU0FFUVFGR0JFQWdIU0FLSUE4Z0VHcEJBblFpRDJvcUFnQWlIeUFkSUI5ZUd5RWRJQjRnQ1NBUGFpb0NBQ0lmSUI0Z0gxNGJJUjRMSUI0TElCMGdIU0FlWGh1VFF3QUFBQUNYdTBUdk9mcitRaTdtdjZJUUh5RWlBa0FnR1EwQUlBRWdCU0FTYkVFQ2RHb2dBQ2dDSUNBYWFpNEJBQ0FEZEVFQ2RHb2hGU0FDSUJJZ0hHcHFJUlpCQUNFUEFrQWdFMEVBU2dSQUlDRWdJQ0FpdGlJZElCMlNJaDFEOHdTMVA1UWdIU0FZR3lJZElCMGdJRjRibENJZGpDRWVRUUFoRVFOQVFRQWhEaUFXTFFBQUlCRjJRUUZ4UlFSQUEwQWdGU0FPSUFOMElCRnFRUUowYWlBZElCNGdERUdOek9VQWJFSGY1cnZqQTJvaURFR0FnQUp4R3pnQ0FFRUJJUThnRGtFQmFpSU9JQk5IRFFBTEN5QVJRUUZxSWhFZ0ZFY05BQXNNQVFzZ0ZpMEFBQ0VSUVFBaERnTkFJQTlCQVNBUklBNTJRUUZ4R3lFUElBNUJBV29pRGlBVVJ3MEFDd3NnRDBVTkFDQVZJQnREQUFDQVB5QU5FQzRMSUJKQkFXb2lFaUFYUncwQUN5QUdJQWRIRFFBTEN3dTdCUUVMZnlBQklBQW9BUVEyQVFBZ0FpQUFLQUVJTmdFQUlBQWdBU0FGUVFGMElnWnFLQUVBTmdFRUlBQWdBaUFHYWlnQkFEWUJDRUdBZ0FRZ0JFRURkQ0lHYlNFSElBTW9BZ1FoQ2lBREtBSUFJUXNnQkVFQlRnUkFJQWRCRUhSQkVIVWlBeUFLSUFBdkFRSWlCMnRCRUhSQkVIVnNRUTkxUVFGcVFRRjFJUTBnQXlBTElBQXZBUUFpQ0d0QkVIUkJFSFZzUVE5MVFRRnFRUUYxSVE0Z0JrRUJJQVpCQVVvYklROUJBQ0VEQTBBZ0FpQURRUUZxSWdSQkFYUWlDV29pREVILy93RWdCeUFOYWlJSFFSQjBRUkIxSWhBZ0FTQUphaTRCQUNJSlFRVjFiQ0FNTGdFQVFRaDBhaUFKUVF0MFFZRHdBM0VnRUd4QkVIVnFJQWdnRG1vaUNFRVFkRUVRZFNJTUlBRWdBMEVCZEdvaUF5NEJCQ0FETGdFQWFpQUpRUUYwYWlJRFFRZDFiR29nQTBFSmRFR0EvQU54SUF4c1FSQjFhaUlEUVFkMVFRRnFRUUYxSWdsQmdJQitJQWxCZ0lCK1Noc2dBMEgvL3Y4RFNoczdBUUFnQkNJRElBOUhEUUFMQ3lBRklBWktCRUFnQ2tFUWRFRVFkU0VESUF0QkVIUkJFSFVoQkFOQUlBWkJBWFFoQ0NBQ0lBWkJBV29pQmtFQmRDSUhhaUlKUWYvL0FTQUJJQWRxTGdFQUlnZEJCWFVnQTJ3Z0NTNEJBRUVJZEdvZ0IwRUxkRUdBOEFOeElBTnNRUkIxYWlBQklBaHFJZ2d1QVFRZ0NDNEJBR29nQjBFQmRHb2lCMEVIZFNBRWJHb2dCMEVKZEVHQS9BTnhJQVJzUVJCMWFpSUhRUWQxUVFGcVFRRjFJZ2hCZ0lCK0lBaEJnSUIrU2hzZ0IwSC8vdjhEU2hzN0FRQWdCU0FHUncwQUN3c2dBQ0FLT3dFQ0lBQWdDenNCQUNBRlFRRk9CRUJCQUNFR0EwQWdBU0FHUVFGcUlnWkJBWFFpQUdvaUF5QURMZ0VBSWdNZ0FDQUNhaUlBTGdFQUlnUnFJZ3BCLy84QklBcEIvLzhCU0JzaUNrR0FnSDRnQ2tHQWdINUtHenNCQUNBQUlBTWdCR3NpQUVILy93RWdBRUgvL3dGSUd5SUFRWUNBZmlBQVFZQ0Fma29iT3dFQUlBVWdCa2NOQUFzTEMzb0JCWDhnQVVFQ1RnUkFRUUVoQXdOQUlBQWdBMEVCZEdvdUFRQWhCU0FESVFJQ1FBTkFJQVVnQUNBQ1FRRnJJZ1pCQVhScUxnRUFJZ1JPRFFFZ0FDQUNRUUYwYWlBRU93RUFJQUpCQVVvaEJDQUdJUUlnQkEwQUMwRUFJUUlMSUFBZ0FrRUJkR29nQlRzQkFDQURRUUZxSWdNZ0FVY05BQXNMQzRrSEFRUi9JQUFDZndKQUlBSkJBVWdOQUNBQ0lBRWdBa0dBT1dvdEFBQkI0RGRxUVFnUUF5SUNheUVGSUFKQkVIUWlBa0VCU0FSQURBRUxJQUpCRUhVaUFpQUJJQUpCZ0RscUxRQUFRY0EyYWtFSUVBTWlBbXNoQXlBQ1FSQjBJZ0pCQUV3TkFDQUNRUkIxSWdJZ0FTQUNRWUE1YWkwQUFFR2dOV3BCQ0JBRElnSnJJUVFnQWtFUWRFRUJTQTBBSUFBZ0FTQUNRZi8vQTNGQmdEbHFMUUFBUVlBMGFrRUlFQU1pQmpzQkFDQUNJQVpyREFFTElBQkJBRHNCQUVFQUN6c0JBaUFBQW44Z0JFRVFkRUVCVGdSQUlBQWdBU0FFUWYvL0EzRkJnRGxxTFFBQVFZQTBha0VJRUFNaUFqc0JCQ0FFSUFKckRBRUxJQUJCQURzQkJFRUFDenNCQmtFQUlRUWdBQUovQWtBZ0EwRVFkQ0lDUVFCTUJFQWdBRUVJYWlFRERBRUxJQUJCQ0dvaEF5QUNRUkIxSWdJZ0FTQUNRWUE1YWkwQUFFR2dOV3BCQ0JBRElnSnJJUVFnQWtFUWRFRUJTQTBBSUFBZ0FTQUNRZi8vQTNGQmdEbHFMUUFBUVlBMGFrRUlFQU1pQXpzQkNDQUNJQU5yREFFTElBTkJBRHNCQUVFQUN6c0JDaUFBQW44Z0JFRVFkRUVCVGdSQUlBQWdBU0FFUWYvL0EzRkJnRGxxTFFBQVFZQTBha0VJRUFNaUFqc0JEQ0FFSUFKckRBRUxJQUJCQURzQkRFRUFDenNCRGtFQUlRUkJBQ0VDSUFBQ2Z3SkFBa0FnQlVFUWRDSURRUUZPQkVBZ0EwRVFkU0lDSUFFZ0FrR0FPV290QUFCQndEWnFRUWdRQXlJRGF5RUNJQU5CRUhRaUEwRUFTZzBCQ3lBQVFSQnFJUVVNQVFzZ0FFRVFhaUVGSUFOQkVIVWlCQ0FCSUFSQmdEbHFMUUFBUWFBMWFrRUlFQU1pQTJzaEJDQURRUkIwUVFGSURRQWdBQ0FCSUFOQi8vOERjVUdBT1dvdEFBQkJnRFJxUVFnUUF5SUZPd0VRSUFNZ0JXc01BUXNnQlVFQU93RUFRUUFMT3dFU0lBQUNmeUFFUVJCMFFRRk9CRUFnQUNBQklBUkIvLzhEY1VHQU9Xb3RBQUJCZ0RScVFRZ1FBeUlET3dFVUlBUWdBMnNNQVFzZ0FFRUFPd0VVUVFBTE93RVdRUUFoQkNBQUFuOENRQ0FDUVJCMElnSkJBRXdFUUNBQVFSaHFJUU1NQVFzZ0FFRVlhaUVESUFKQkVIVWlBaUFCSUFKQmdEbHFMUUFBUWFBMWFrRUlFQU1pQW1zaEJDQUNRUkIwUVFGSURRQWdBQ0FCSUFKQi8vOERjVUdBT1dvdEFBQkJnRFJxUVFnUUF5SURPd0VZSUFJZ0Eyc01BUXNnQTBFQU93RUFRUUFMT3dFYUlBUkJFSFJCQVU0RVFDQUFJQUVnQkVILy93TnhRWUE1YWkwQUFFR0FOR3BCQ0JBRElnRTdBUndnQUNBRUlBRnJPd0VlRHdzZ0FFRUFPd0VjSUFCQkFEc0JIZ3VWQVFFRmZ5QUVRUUZPQkVBZ0FDZ0NBQ0VGSUFNdUFRSWhCaUFETGdFQUlRZEJBQ0VEQTBBZ0FTQURRUUowYWlBQ0lBTkJBWFJxTGdFQVFRaDBJQVZxSWdVMkFnQWdBQ2dDQkNFSUlBQWdCVUVDZENJRlFmei9BM0VpQ1NBR2JFRVFkU0FGUVJCMUlnVWdCbXhxTmdJRUlBQWdDQ0FGSUFkc2FpQUhJQWxzUVJCMWFpSUZOZ0lBSUFOQkFXb2lBeUFFUncwQUN3c0w2d1FCQkg4Q1FDQUFRUUJCckFJUUJTSURBbjlCZnlFQUFrQWdBVUhBUGtZTkFDQUJRWUQ5QUVZTkFDQUJRZURkQUVjTkFnc0NRQ0FDUWYvOEFFd0VRQ0FDUWNBK1JnMEJJQUpCNE4wQVJnMEJEQU1MSUFKQmdQMEFSZzBBSUFKQmdQY0NSZzBBSUFKQndMc0JSdzBDQ3lBQlFReDJRUVZzSUFKQkRIWWdBa0dBL1FCS2F5QUNRY0M3QVVwMWFrR3hDMm9zQUFBTE5nS2tBaUFESUFKQi8vOERjVUhvQjI0MkFxQUNJQU1nQVVILy93TnhRZWdIYmlJQU5nS2NBaUFESUFCQkNtdzJBb3dDQWtBZ0FTQUNTQVJBUVFFaEFDQUNJQUZCQVhSR0JFQWdBMEVCTmdLSUFrRUFJUUFNQWdzZ0EwRUNOZ0tJQWd3QkN5QUJJQUpLQkVBZ0EwRUROZ0tJQWlBQ1FRSjBJZ0FnQVVFRGJFWUVRQ0FEUWRBTE5nS29BaUFEUXBLQWdJQXdOd0tVQWtFQUlRQU1BZ3NnQWtFRGJDSUVJQUZCQVhSR0JFQWdBMEdRRERZQ3FBSWdBMEtTZ0lDQUlEY0NsQUpCQUNFQURBSUxJQUVnQWtFQmRFWUVRQ0FEUWNBTU5nS29BaUFEUXBpQWdJQVFOd0tVQWtFQUlRQU1BZ3NnQVNBRVJnUkFJQU5CNEF3MkFxZ0NJQU5DcElDQWdCQTNBcFFDUVFBaEFBd0NDeUFBSUFGR0JFQWdBMEdRRFRZQ3FBSWdBMEtrZ0lDQUVEY0NsQUpCQUNFQURBSUxRWDhoQUNBQ1FRWnNJQUZIRFFJZ0EwSEFEVFlDcUFJZ0EwS2tnSUNBRURjQ2xBSkJBQ0VBREFFTFFRQWhBQ0FEUVFBMkFvZ0NDeUFCSUFCMElRVWdBa0VRZEVFUWRTRUVJQUpCRDNaQkFXcEJBWFloQmlBQklBQkJEbkowSUFKdFFRSjBJUUlEUUNBQ0lnQkJBV29oQWlBQVFSQjFJQVJzSUFBZ0JteHFJQUJCLy84RGNTQUViRUVRZFdvZ0JVZ05BQXNnQXlBQU5nS1FBa0VBSVFBTElBQUxjd0VEZndKL1FRQWdBRUVBU0EwQUdrSC8vLy8vQnlBQVFmNGVTZzBBR2lBQVFmOEFjU0VCUVFFZ0FFRUhkaUlEZENFQ0lBQkIvdzlNQkg4Z0FVR0FBU0FCYTJ4QjBuNXNRUkIxSUFGcUlBTjBRUWQxQlNBQlFZQUJJQUZyYkVIU2ZteEJFSFVnQVdvZ0FrRUhkbXdMSUFKcUN3dklBUUVFZnlBRVFRRk9CRUFEUUNBQ0FuOGdBeUFHY2tVRVFDQUJMQUFBSWdVZ0Fpd0FBRUVRYXlJSElBVWdCMG9iREFFTElBRWdCbW9zQUFCQkJHc2lCU0FDTEFBQUlnZEJDR29pQ0VvRVFDQUhJQVZCQVhRZ0NHdHFEQUVMSUFVZ0Iyb0xJZ1ZCQUNBRlFSaDBRUmgxUVFCS0d5SUZRVDhnQlVFWWRFRVlkVUUvU0JzaUJUb0FBQ0FBSUFaQkFuUnFJQVZCL3dGeElnVkI4VGhzUVJCMklBVkJIV3hxSWdWQjFRNGdCVUhWRGtrYlFhb1FhaEJwTmdJQUlBWkJBV29pQmlBRVJ3MEFDd3NMMUFJQkJIOGdBQ0FCUVJCMFFSQjFJZ05CQld3MkFwd1NJQUF1QVpRU0lBTkJnSUFVYkVFUWRXd2hCQUpBQWtBQ1FDQUJJQUFvQW93U1JnUkFJQUFvQXBBU0lBSkdEUUVMSUFCQmdCTnFJQU5CNkFkc0lBSVFhQ0VGSUFBZ0FqWUNrQklnQUNnQ2pCSWdBVWNOQVF0QkFTRUdJQVFnQUNnQ21CSkdEUUVMSUFCQmdqSkJtVElnQUNnQ2xCSkJCRVlpQWh0QjRERkJqVElnQWhzZ0FVRUlSaHMyQXRBU0lBWkZCRUFnQUNBRFFSUnNOZ0tnRWlBQVFjZ2VRWlF2SUFGQmUzRkJDRVlpQWhzMkFxd1ZJQUJCQ2tFUUlBSWJOZ0trRWtHUU1TRUNBa0FDUUFKQUFrQWdBVUVNYXc0RkFBRUJBUUlCQzBHS01TRUNEQUVMUVlFeElRSWdBVUVJUncwQkN5QUFJQUkyQXN3U0N5QUFRUUEyQXNRZ0lBQkJDam9BaUJJZ0FFSGtBRFlDaEJJZ0FFRUJOZ0xJRWlBQVFZUUtha0VBUVlBSUVBVWFDeUFBSUFRMkFwZ1NJQUFnQVRZQ2pCSUxJQVVMUmdFQ2Z5TUFRUkJySWdFa0FBSkFJQUJGRFFCQm1Qc0JLQUlBSWdKRkJFQWdBU0FBTmdJQVFlc0lJQUVRSGd3QkMwR1krd0VnQWlBQUVEODJBZ0FMSUFGQkVHb2tBQXZrQVFFRmZ3SkFJQVJCQVVnTkFFSHdDVUhFQ1NBRVFRUkdJZ1ViUWFBS1FkQUpJQVViSUFOQkNFWWlCeHNoQ0VFTFFRTWdCUnRCSWtFTUlBVWJJQWNiSVFjZ0EwRVFkQ0lGUVE5MUlnTWdBR29oQ1VFQUlRQWdCVUVRZFVFU2JDSUZJQU5JQkVBRFFDQUNJQUJCQW5ScUlBTWdCU0FKSUFnZ0FDQUhiQ0FCYW1vc0FBQnFJZ1lnQlNBR1Noc2dBeUFHU0JzMkFnQWdBRUVCYWlJQUlBUkhEUUFNQWdzQUN3TkFJQUlnQUVFQ2RHb2dCU0FESUFrZ0NDQUFJQWRzSUFGcWFpd0FBR29pQmlBRElBWktHeUFGSUFaSUd6WUNBQ0FBUVFGcUlnQWdCRWNOQUFzTEM4Z0VBUWQvSXdCQlFHb2lCQ1FBSUFGQkVHb2dBRUd3RldvZ0FFR0lFbW9nQWtFQ1JpQUFLQUtVRWhCcUlBUkJJR29nQUVHNEZXb2dBQ2dDckJVUWRpQUJRVUJySWdVZ0JFRWdhaUFBS0FLa0VpQUFLQUxJSUJBcklBRkJJR29oQXdKQUFrQWdBQ2dDeUJKQkFVWUVRQ0FBUVFRNkFNOFZEQUVMSUFBc0FNOFZJZ2hCQTBvTkFDQUFLQUtrRWlJR1FRRk9CRUJCQUNFQ0EwQWdCQ0FDUVFGMElnZHFJQUFnQjJwQnFCSnFMZ0VBSWdrZ0JFRWdhaUFIYWk0QkFDQUpheUFJYkVFQ2RtbzdBUUFnQWtFQmFpSUNJQVpIRFFBTEN5QURJQVFnQmlBQUtBTElJQkFyREFFTElBTWdCU0FBS0FLa0VrRUJkQkFFR2dzZ0FFR29FbW9nQkVFZ2FpQUFLQUtrRWlJQ1FRRjBFQVFhSUFBb0FzQWdCRUFnQXlBQ1FkTHdBeEFxSUFVZ0FDZ0NwQkpCMHZBREVDb0xJQUVDZnlBQVFjMFZhaTBBQUVFQ1JnUkFJQUJCeWhWcUxnRUFJQUJCekJWcUxBQUFJQUVnQUNnQ2pCSWdBQ2dDbEJJUWJTQUFLQUtVRWlJR1FRRk9CRUFnQUVIUUZXb3NBQUJCQW5SQndCTnFLQUlBSVFkQkFDRUNBMEFnQVNBQ1FRcHNhaUlESUFjZ0FDQUNha0cwRldvc0FBQkJCV3hxSWdVc0FBQkJCM1E3QVdBZ0F5QUZMQUFCUVFkME93RmlJQU1nQlN3QUFrRUhkRHNCWkNBRElBVXNBQU5CQjNRN0FXWWdBeUFGTEFBRVFRZDBPd0ZvSUFKQkFXb2lBaUFHUncwQUN3c2dBRUhSRldvc0FBQkJBWFJCK0RCcUxnRUFEQUVMSUFGQkFDQUFLQUtVRWtFQ2RCQUZRZUFBYWtFQUlBQW9BcFFTUVFwc0VBVWFJQUJCMEJWcVFRQTZBQUJCQUFzMkFvZ0JJQVJCUUdza0FBdjNHd0VvZnlNQVFTQnJJZ1FoRmlBRUpBQWdCQ0FBS0FLZ0VrRUJkRUVQYWtGd2NXc2lGeUlFSkFBZ0JDQUFLQUtZRWlJRUlBQW9BcUFTYWtFQ2RFRVBha0Z3Y1dzaUVpSUtKQUFnQ2lBQUtBS2NFa0VDZENJS1FROXFRWEJ4YXlJWUlnWWtBQ0FHSUFwQnp3QnFRWEJ4YXlJRkpBQWdBRUhQRldvc0FBQWhFU0FFUVFGT0JFQWdBQ3dBelJWQkFYUkJmSEZCOERCcUlBQkJ6aFZxTEFBQVFRRjBhaTRCQUVFRWRDRU1JQUJCMGhWcUxBQUFJUVlEUUNBQUlBZEJBblJxSWdvZ0F5QUhRUUYwYWk0QkFDSUVRUTUwSWdnMkFnUWdCa0cxaU03ZEFHeEI2OGJsc0FOcUlRWUNRQ0FLSUFSQkFVNEVmeUFJUVlBS2F3VWdCRUYvU2cwQklBaEJnQXB5Q3lJSU5nSUVDeUFLUVFBZ0NDQU1haUlLYXlBS0lBWkJBRWdiTmdJRUlBUWdCbW9oQmlBSFFRRnFJZ2NnQUNnQ21CSklEUUFMQ3lBRklBQXBBb1FLTndJQUlBVWdBRUc4Q21vcEFnQTNBamdnQlNBQVFiUUthaWtDQURjQ01DQUZJQUJCckFwcUtRSUFOd0lvSUFVZ0FFR2tDbW9wQWdBM0FpQWdCU0FBUVp3S2Fpa0NBRGNDR0NBRklBQkJsQXBxS1FJQU53SVFJQVVnQUVHTUNtb3BBZ0EzQWdnZ0FDZ0NsQkpCQVU0RVFDQUFRUVJxSVJNZ0FDZ0NvQkloRUNBUlFRUklJU1lnQWlFUkEwQWdGaUFCSUE1QkJIUkJZSEZxUVNCcUlnMGdBQ2dDcEJKQkFYUVFCQ0VNUVFBZ0FTQU9RUUowYWlJSUtBSVFJZzhnRHlBUFFSOTFJZ05xSUFOeklncG5JZ1pCQVd0MElnbEIvLzhEY1VILy8vLy9BU0FKUVJCMUlnUnRJZ2RCRUhRaUMwRVFkU0lEYkVFUWRTQURJQVJzYWtFRGRHc2lCQ0FIUVE5MVFRRnFRUUYxYkNBTGFpQUVRUkIxSUFOc2FpQUVRZmovQTNFZ0EyeEJFSFZxSVFRQ2Z5QUtRZi8vQjAwRVFFSC8vLy8vQnlBR1FROXJJZ3AySWdkQmdJQ0FnSGdnQ25VaUN5QUVJQVFnQzBnYklBUWdCMG9iSUFwMERBRUxJQVJCRHlBR2EzVUxJUW9nQUMwQXpSVWhDMEdBZ0FRaEJ5QUFLQUlBSWdRZ0QwY0VRQ0FFSUFRZ0JFRWZkU0lIYWlBSGMyY2lCMEVCYTNRaUJDQUVRUkIxSUFOc0lBUkIvLzhEY1NBRGJFRVFkV29pQkt3Z0NheCtRaDJJcDBGNGNXc2lDVUVRZFNBRGJDQUVhaUFKUWYvL0EzRWdBMnhCRUhWcUlRTWdCU0FGS0FJQUlnbEJFSFJCRUhVaUZBSi9JQWNnQm10QkhXb2lCRUVQVEFSQVFmLy8vLzhIUVJBZ0JHc2lCSFlpQmtHQWdJQ0FlQ0FFZFNJSElBTWdBeUFIU0JzZ0F5QUdTaHNnQkhRTUFRc2dBeUFFUVJCcmRVRUFJQVJCTUVnYkN5SUhRZi8vQTNFaUEyeEJFSFVnRkNBSFFSQjFJZ1JzYWlBSlFROTFRUUZxUVFGMUlBZHNhallDQUNBRklBVW9BZ1FpQmtFUWRFRVFkU0lKSUFOc1FSQjFJQVFnQ1d4cUlBWkJEM1ZCQVdwQkFYVWdCMnhxTmdJRUlBVWdCU2dDQ0NJR1FSQjBRUkIxSWdrZ0EyeEJFSFVnQkNBSmJHb2dCa0VQZFVFQmFrRUJkU0FIYkdvMkFnZ2dCU0FGS0FJTUlnWkJFSFJCRUhVaUNTQURiRUVRZFNBRUlBbHNhaUFHUVE5MVFRRnFRUUYxSUFkc2FqWUNEQ0FGSUFVb0FoQWlCa0VRZEVFUWRTSUpJQU5zUVJCMUlBUWdDV3hxSUFaQkQzVkJBV3BCQVhVZ0IyeHFOZ0lRSUFVZ0JTZ0NGQ0lHUVJCMFFSQjFJZ2tnQTJ4QkVIVWdCQ0FKYkdvZ0JrRVBkVUVCYWtFQmRTQUhiR28yQWhRZ0JTQUZLQUlZSWdaQkVIUkJFSFVpQ1NBRGJFRVFkU0FFSUFsc2FpQUdRUTkxUVFGcVFRRjFJQWRzYWpZQ0dDQUZJQVVvQWh3aUJrRVFkRUVRZFNJSklBTnNRUkIxSUFRZ0NXeHFJQVpCRDNWQkFXcEJBWFVnQjJ4cU5nSWNJQVVnQlNnQ0lDSUdRUkIwUVJCMUlna2dBMnhCRUhVZ0JDQUpiR29nQmtFUGRVRUJha0VCZFNBSGJHbzJBaUFnQlNBRktBSWtJZ1pCRUhSQkVIVWlDU0FEYkVFUWRTQUVJQWxzYWlBR1FROTFRUUZxUVFGMUlBZHNhallDSkNBRklBVW9BaWdpQmtFUWRFRVFkU0lKSUFOc1FSQjFJQVFnQ1d4cUlBWkJEM1ZCQVdwQkFYVWdCMnhxTmdJb0lBVWdCU2dDTENJR1FSQjBRUkIxSWdrZ0EyeEJFSFVnQkNBSmJHb2dCa0VQZFVFQmFrRUJkU0FIYkdvMkFpd2dCU0FGS0FJd0lnWkJFSFJCRUhVaUNTQURiRUVRZFNBRUlBbHNhaUFHUVE5MVFRRnFRUUYxSUFkc2FqWUNNQ0FGSUFVb0FqUWlCa0VRZEVFUWRTSUpJQU5zUVJCMUlBUWdDV3hxSUFaQkQzVkJBV3BCQVhVZ0IyeHFOZ0kwSUFVZ0JTZ0NPQ0lHUVJCMFFSQjFJZ2tnQTJ4QkVIVWdCQ0FKYkdvZ0JrRVBkVUVCYWtFQmRTQUhiR28yQWpnZ0JTQURJQVVvQWp3aUJrRVFkRUVRZFNJSmJFRVFkU0FFSUFsc2FpQUdRUTkxUVFGcVFRRjFJQWRzYWpZQ1BBc2dEa0VLYkNBQmFpRURJQUFnRHpZQ0FBSkFBbjhDUUFKQUlBQW9Bc0FnUlEwQUlBQW9Bc1FnUVFKSERRQWdEa0VCU3cwQUlBdEJBa1lOQUNBRFFnQTNBV0FnQTBFQU93Rm9JQU5CZ0NBN0FXUWdDQ0FBS0FLRUVpSUdOZ0lBREFFTElBdEJBa2NFUUNBQUtBS2NFaUVKSUJNTUFnc2dDQ2dDQUNFR0N3SkFRUUFnRGlBbUlBNUJBa1p4RzBVRVFDQUFLQUtnRWlJSElBWWdBQ2dDcEJJaUJHcHJRUUpySVFnZ0RrRUNSZ1JBSUFBZ0IwRUJkR3BCeEFwcUlBSWdBQ2dDbkJKQkFuUVFCQm9nQUNnQ29CSWhCeUFBS0FLa0VpRUVDeUFYSUFoQkFYUnFJQUFnQUNnQ25CSWdEbXdnQ0dwQkFYUnFRY1FLYWlBTklBY2dDR3NnQkJCSElBNUZCRUFnQVM0QmlBRWlCQ0FLUWYvL0EzRnNRUkIxSUFRZ0NrRVFkV3hxUVFKMElRb0xJQVpCZjBnTkFTQUdRUUZxSVFRZ0NrSC8vd054SVFjZ0NrRVFkU0VLSUFBb0FxQVNJUWxCQUNFSUEwQWdFaUFRSUFoQmYzTWlDMnBCQW5ScUlBY2dGeUFKSUF0cVFRRjBhaTRCQUNJTGJFRVFkU0FLSUF0c2FqWUNBQ0FFSUFoR0lRc2dDRUVCYWlFSUlBdEZEUUFMREFFTElBZEJnSUFFUmcwQUlBWkJmMGdOQUNBR1FRRnFJUVFnQjBILy93TnhJUW9nQjBFUWRTRUpRUUFoQ0FOQUlCSWdFQ0FJUVg5emFrRUNkR29pQ3lBTEtBSUFJZ3RCRUhSQkVIVWlEU0FLYkVFUWRTQUpJQTFzYWlBTFFROTFRUUZxUVFGMUlBZHNhallDQUNBRUlBaEhJUXNnQ0VFQmFpRUlJQXNOQUFzTElBQW9BcHdTSWdsQkFVZ05BU0FRSUFaclFRSjBJQkpxUVFocUlRZ2dBeTRCYUNFRUlBTXVBV1loQ2lBRExnRmtJUVlnQXk0QllpRUxJQU11QVdBaEEwRUFJUWNEUUNBWUlBZEJBblFpRFdvZ0RTQVRhaWdDQUNBSUtBSUFJZzFCRUhVZ0Eyd2dEVUgvL3dOeElBTnNRUkIxYWlBSVFRUnJLQUlBSWcxQkVIVWdDMnhxSUExQi8vOERjU0FMYkVFUWRXb2dDRUVJYXlnQ0FDSU5RUkIxSUFac2FpQU5RZi8vQTNFZ0JteEJFSFZxSUFoQkRHc29BZ0FpRFVFUWRTQUtiR29nRFVILy93TnhJQXBzUVJCMWFpQUlRUkJyS0FJQUlnMUJFSFVnQkd4cUlBMUIvLzhEY1NBRWJFRVFkV3BCQVhScVFRUnFJZzAyQWdBZ0VpQVFRUUowYWlBTlFRRjBOZ0lBSUJCQkFXb2hFQ0FJUVFScUlRZ2dCMEVCYWlJSElBbEhEUUFMSUJnTElTY2dDVUVCU0EwQUlBOUJDblJCRUhVaEN5QUFLQUtrRWlJb1FRRjFJU2tnRDBFVmRVRUJha0VCZFNFcUlBVW9BaHdoQkNBRktBSWtJUVlnQlNnQ0xDRUtJQVVvQWpRaEF5QUZLQUk4SVFoQkFDRUhJQXd1QVI0aER5QU1MZ0VjSVEwZ0RDNEJHaUVVSUF3dUFSZ2hHU0FNTGdFV0lSb2dEQzRCRkNFYklBd3VBUkloSENBTUxnRVFJUjBnREM0QkRpRWVJQXd1QVF3aEh5QU1MZ0VLSVNBZ0RDNEJDQ0VoSUF3dUFRWWhJaUFNTGdFRUlTTWdEQzRCQWlFa0lBd3VBUUFoSlFOQUlBaEJFSFVnSld3Z0tXb2dDRUgvL3dOeElDVnNRUkIxYWlBSFFRSjBJaFVnQldvaUNDZ0NPQ0lNUVJCMUlDUnNhaUFNUWYvL0EzRWdKR3hCRUhWcUlBTkJFSFVnSTJ4cUlBTkIvLzhEY1NBamJFRVFkV29nQ0NnQ01DSURRUkIxSUNKc2FpQURRZi8vQTNFZ0lteEJFSFZxSUFwQkVIVWdJV3hxSUFwQi8vOERjU0FoYkVFUWRXb2dDQ2dDS0NJS1FSQjFJQ0JzYWlBS1FmLy9BM0VnSUd4QkVIVnFJQVpCRUhVZ0gyeHFJQVpCLy84RGNTQWZiRUVRZFdvZ0NDZ0NJQ0lHUVJCMUlCNXNhaUFHUWYvL0EzRWdIbXhCRUhWcUlBUkJFSFVnSFd4cUlBUkIvLzhEY1NBZGJFRVFkV29nQ0NnQ0dDSUVRUkIxSUJ4c2FpQUVRZi8vQTNFZ0hHeEJFSFZxSVFRZ0JTQUhRUkJxUVFKMGFnSi9BbjhnS0VFUVJnUkFJQVFnQ0NnQ0ZDSXJRUkIxSUJ0c2FpQXJRZi8vQTNFZ0cyeEJFSFZxSUFnb0FoQWlCRUVRZFNBYWJHb2dCRUgvL3dOeElCcHNRUkIxYWlBSUtBSU1JZ1JCRUhVZ0dXeHFJQVJCLy84RGNTQVpiRUVRZFdvZ0NDZ0NDQ0lFUVJCMUlCUnNhaUFFUWYvL0EzRWdGR3hCRUhWcUlBZ29BZ1FpQkVFUWRTQU5iR29nQkVILy93TnhJQTFzUVJCMWFpQUlLQUlBSWdSQkVIVWdEMnhxSUFSQi8vOERjU0FQYkVFUWRXb2hCQXNnQkF0QmdJQ0FRQ0FFUVlDQWdFQktHeUlFUWYvLy96OGdCRUgvLy84L1NCdEJCSFFpQkNBVklDZHFLQUlBSWdocUloVkJBRTRFUUNBVlFZQ0FnSUI0SUFRZ0NIRkJmMG9iREFFTFFmLy8vLzhISUJVZ0JDQUlja0YvU2hzTElnZzJBZ0FnRVNBSFFRRjBha0gvL3dGQmdJQitJQWhCRUhVZ0Myd2dDQ0FxYkdvZ0NFSC8vd054SUF0c1FSQjFhaUlFUVFkMlFRRnFRUUYySUFSQmdQLy9lMGdiSUFSQi8vNy9BMG9iT3dFQUlBWWhCQ0FLSVFZZ0F5RUtJQXdoQXlBSFFRRnFJZ2NnQ1VjTkFBc0xJQVVnQlNBSlFRSjBJZ1JxSWdNcEFnQTNBZ0FnQlNBREtRSTROd0k0SUFVZ0F5a0NNRGNDTUNBRklBTXBBaWczQWlnZ0JTQURLUUlnTndJZ0lBVWdBeWtDR0RjQ0dDQUZJQU1wQWhBM0FoQWdCU0FES1FJSU53SUlJQkVnQ1VFQmRHb2hFU0FFSUJOcUlSTWdEa0VCYWlJT0lBQW9BcFFTU0EwQUN3c2dBRUdFQ21vaUFDQUZLUUlBTndJQUlBQWdCU2tDT0RjQ09DQUFJQVVwQWpBM0FqQWdBQ0FGS1FJb053SW9JQUFnQlNrQ0lEY0NJQ0FBSUFVcEFoZzNBaGdnQUNBRktRSVFOd0lRSUFBZ0JTa0NDRGNDQ0NBV1FTQnFKQUFMaGdZQkFuOGpBRUVRYXlJR0pBQWdCa0VBT2dBUElBSkJDRTRFUUNBRFFRRjBJQVJxUVJCMFFSQjFRUWRzUWFBNWFpRURJQUpCQ0dwQkJIVWlBa0VCSUFKQkFVb2JJUVJCQUNFQ0EwQUNRQ0FGSUFKQkFuUnFLQUlBSWdkQkFVZ05BQ0FHSUFNZ0IwRWZjU0lIUVFZZ0IwRUdTUnRxTFFBQU9nQU9JQUV1QVFCQkFVNEVRQ0FCSUFBZ0JrRU9ha0VJRUFOQkFYUkJBV3NnQVM4QkFHdzdBUUFMSUFFdUFRSkJBRW9FUUNBQklBQWdCa0VPYWtFSUVBTkJBWFJCQVdzZ0FTOEJBbXc3QVFJTElBRXVBUVJCQVU0RVFDQUJJQUFnQmtFT2FrRUlFQU5CQVhSQkFXc2dBUzhCQkd3N0FRUUxJQUV1QVFaQkFVNEVRQ0FCSUFBZ0JrRU9ha0VJRUFOQkFYUkJBV3NnQVM4QkJtdzdBUVlMSUFFdUFRaEJBVTRFUUNBQklBQWdCa0VPYWtFSUVBTkJBWFJCQVdzZ0FTOEJDR3c3QVFnTElBRXVBUXBCQVU0RVFDQUJJQUFnQmtFT2FrRUlFQU5CQVhSQkFXc2dBUzhCQ213N0FRb0xJQUV1QVF4QkFVNEVRQ0FCSUFBZ0JrRU9ha0VJRUFOQkFYUkJBV3NnQVM4QkRHdzdBUXdMSUFFdUFRNUJBVTRFUUNBQklBQWdCa0VPYWtFSUVBTkJBWFJCQVdzZ0FTOEJEbXc3QVE0TElBRXVBUkJCQVU0RVFDQUJJQUFnQmtFT2FrRUlFQU5CQVhSQkFXc2dBUzhCRUd3N0FSQUxJQUV1QVJKQkFVNEVRQ0FCSUFBZ0JrRU9ha0VJRUFOQkFYUkJBV3NnQVM4QkVtdzdBUklMSUFFdUFSUkJBVTRFUUNBQklBQWdCa0VPYWtFSUVBTkJBWFJCQVdzZ0FTOEJGR3c3QVJRTElBRXVBUlpCQVU0RVFDQUJJQUFnQmtFT2FrRUlFQU5CQVhSQkFXc2dBUzhCRm13N0FSWUxJQUV1QVJoQkFVNEVRQ0FCSUFBZ0JrRU9ha0VJRUFOQkFYUkJBV3NnQVM4QkdHdzdBUmdMSUFFdUFScEJBVTRFUUNBQklBQWdCa0VPYWtFSUVBTkJBWFJCQVdzZ0FTOEJHbXc3QVJvTElBRXVBUnhCQVU0RVFDQUJJQUFnQmtFT2FrRUlFQU5CQVhSQkFXc2dBUzhCSEd3N0FSd0xJQUV1QVI1QkFVZ05BQ0FCSUFBZ0JrRU9ha0VJRUFOQkFYUkJBV3NnQVM4QkhtdzdBUjRMSUFGQklHb2hBU0FDUVFGcUlnSWdCRWNOQUFzTElBWkJFR29rQUF0aEFRSi9JQUFRRlNJQkJFQkJtUHNCS0FJQUlnQkZCRUJCQ0JBVklnQkJBRFlDQkNBQUlBRTJBZ0JCbVBzQklBQTJBZ0FnQVE4TEEwQWdBQ0lDS0FJRUlnQU5BQXRCQ0JBVklnQkJBRFlDQkNBQUlBRTJBZ0FnQWlBQU5nSUVDeUFCQzlNREFRWi9Jd0JCRUdzaUJTUUFBa0FnQUNnQ3dDQUVRQ0FBUVlnaGFpQUFRWXdoYWlBQklBSVFHaUFBUWZ3Z2FrRUJOZ0lBREFFTEFrQWdBRUg4SUdvb0FnQkZEUUFnQlVFSWFpQUZRUXhxSUFFZ0FoQWFBa0FnQlNnQ0RDSURJQUJCakNGcUtBSUFJZ1JLQkVBZ0FFR0lJV29pQnlBSEtBSUFJQU1nQkd0MU5nSUFEQUVMSUFNZ0JFNE5BQ0FGSUFVb0FnZ2dCQ0FEYTNVMkFnZ0xJQVVvQWdnaUJpQUFRWWdoYWlnQ0FDSURUQTBBSUFBZ0F5QURaeUlEUVFGcmRDSUlOZ0tJSVVFQUlRZEJBQ0VFSUFnZ0JrRVpJQU5ySWdOQkFDQURRUUJLRzNVaUEwRUJJQU5CQVVvYmJTSURRUUZPQkVBQ1FFRVlJQU5uSWdScklnWkZEUUFnQTBIL0FFMEVRQ0FESUFSQkdHdDBJQU5CT0NBRWEzWnlJUU1NQVFzZ0F5QUVRUWhxZENBRElBWjJjaUVEQzBHQWdBSkJodWtDSUFSQkFYRWJJQVJCQVhaMklnUWdBMEgvQUhGQmdJRFVCbXhCRUhac1FSQjJJQVJxUVFSMElRUUxRWUNBQkNBRWF5QUNiU0VESUFKQkFVZ05BQ0FEUVFKMElRTURRQ0FCSUFkQkFYUnFJZ1lnQmk0QkFDSUdJQVJCL1A4RGNXeEJFSFlnQkVFUWRpQUdiR283QVFBZ0F5QUVhaUlFUVlDQUJFb05BU0FIUVFGcUlnY2dBa2dOQUFzTElBQkJBRFlDL0NBTElBVkJFR29rQUF2bUFnRUhmeU1BSWdnaERTQUlJQVpCQW5SQkQycEJjSEZySWdva0FDQUdRUUZPQkVBZ0IwRUNheUFHYkNFTUlBVW9BZ0FpQ0VFUWRFRVFkU0VMSUFoQkQzVkJBV3BCQVhVaERrRUFJUWdEUUNBS0lBaEJBWFJxUWYvL0FVR0FnSDRnQ3lBRUlBZ2dER3BCQW5ScUtBSUFJZ2xCLy84RGNXeEJFSFVnQ3lBSlFSQjFiR29nQ1NBT2JHb2lDVUVJZGlBSlFZQ0FnSHhJR3lBSlFmLy8vd05LR3pzQkFDQUlRUUZxSWdnZ0JrY05BQXNnQjBFQmF5QUdiQ0VMSUFvZ0JrRUJkR29oQ1NBRktBSUVJZ2RCRUhSQkVIVWhCU0FIUVE5MVFRRnFRUUYxSVF4QkFDRUlBMEFnQ1NBSVFRRjBha0gvL3dGQmdJQitJQVVnQkNBSUlBdHFRUUowYWlnQ0FDSUhRZi8vQTNGc1FSQjFJQVVnQjBFUWRXeHFJQWNnREd4cUlnZEJDSFlnQjBHQWdJQjhTQnNnQjBILy8vOERTaHM3QVFBZ0NFRUJhaUlJSUFaSERRQUxDeUFBSUFFZ0NpQUdFQm9nQWlBRElBb2dCa0VCZEdvZ0JoQWFJQTBrQUF2d0ZBRWZmeU1BUVVCcUlnY2tBQ0FISUFBb0FwZ1NJQUFvQXFBU2FrRUNkRUVQYWtGd2NXc2lEeUlFSkFBZ0JDQUFLQUtnRWtFQmRFRVBha0Z3Y1dzaURDUUFJQWNnQUVHVUlXb29BZ0JCQm5VMkFnZ2dCeUFBUVpnaGFpZ0NBQ0lXUVFaMUloYzJBZ3dnQUNnQ3lCSUVRQ0FBUWZJZ2FrSUFOd0VBSUFCQjZpQnFRZ0EzQVFBZ0FFSGlJR3BDQURjQkFDQUFRZG9nYWtJQU53RUFDeUFIUVRScUlBZEJQR29nQjBFd2FpQUhRVGhxSUFCQkJHb2dCMEVJYWlBQUtBS2NFaUFBS0FLVUVoQnpJQUJCb0NGcUtBSUFJUWdDUUNBSEtBSTBJQWNvQWpoMUlBY29BakFnQnlnQ1BIVklCRUFnQ0VFQmF5RU5JQUJCcENGcUtBSUFJUWdNQVFzZ0FFR2tJV29vQWdBaERRc2dBRUdFSVdvdkFRQWhDU0FBS0FMQUlDRUVJQUFvQXNRZ0lRWWdBRUhhSUdvaUJTQUFLQUtrRWtIeCtnTVFLaUFIUVJCcUlBVWdBQ2dDcEJJaUEwRUJkQkFFR2lBRVFRRWdCRUVCU0J0QkFYUWlDMEd1Q1dvZ0MwR3lDV29nQmtFQ1Joc3VBUUFoRGdKQUlBQW9Bc0FnRFFBZ0FDZ0N4Q0JCQWtZRVFDQUFRWkFoYWk0QkFFR0FnQUVnQUVIWUlHb3ZBUUFnQUVIV0lHb3ZBUUFnQUVIVUlHb3ZBUUFnQUM4QjBDQWdBRUhTSUdvdkFRQnFhbXBxYXlJRVFjMFpJQVJCRUhSQkVIVkJ6UmxLRzBILy93TnhiRUVPZGlFSkRBRUxJQVVnQXhBZElnUkJnSUNBd0FBZ0JFR0FnSURBQUVnYklnUkJnSUNBQWlBRVFZQ0FnQUpLR3lJRVFRTjBRZmovQTNFZ0RteEJFSFVnQkVFTmRrSC8vd054SUE1c2FrRU9kU0VPSUFBb0FxUVNJUU5CZ0lBQklRa0xJQUJCZ0NGcUtBSUFJUndnRENBQUtBS2dFaUlFSUFOcklBQW9Bc3dnUVFkMVFRRnFRUUYxSWhOclFRSnJJZ1pCQVhRaUJXb2dBQ0FGYWtIRUNtb2dCMEVRYWlBRUlBWnJJQU1RUjBFQUlBQW9BcGdoSWdVZ0JTQUZRUjkxSWdOcUlBTnpJaEJuSWdOQkFXdDBJZ1ZCLy84RGNVSC8vLy8vQVNBRlFSQjFJZ3B0SWhGQkVIUWlFa0VRZFNJRmJFRVFkU0FGSUFwc2FrRURkR3NpQ2lBUlFROTFRUUZxUVFGMWJDQVNhaUFLUVJCMUlBVnNhaUFLUWZqL0EzRWdCV3hCRUhWcUlRVUNmeUFRUWYvL0EwMEVRRUgvLy8vL0J5QURRUkJySWdOMklncEJnSUNBZ0hnZ0EzVWlFQ0FGSUFVZ0VFZ2JJQVVnQ2tvYklBTjBEQUVMSUFWQkVDQURhM1VMSVFVZ0FDZ0NwQklpRUNBR2FpSURJQUFvQXFBU0loRklCRUFnQlVILy8vLy9BeUFGUWYvLy8vOERTQnNpQlVILy93TnhJUVlnQlVFUWRTRUZBMEFnRHlBRFFRSjBhaUFHSUF3Z0EwRUJkR291QVFBaUNteEJFSFVnQlNBS2JHbzJBZ0FnQTBFQmFpSURJQkZJRFFBTEN5QUFLQUtVRWlJWVFRRk9CRUFnQ0NBTmJDSUZRWUFCSUFWQmdBRktHMEVDZENBQWFrSDhBMnNoR1NBTFFhb0phaTRCQUNFS0lBQXVBWXdTUVlBa2JDRVNJQTVCRUhSQkVIVWhHaUFBUWRnZ2FpOEJBQ0VESUFCQjFpQnFMd0VBSVFzZ0FFSFVJR292QVFBaEJTQUFRZElnYWk4QkFDRUlJQUF2QWRBZ0lRWWdBQ2dDbkJJaEZBTkFBa0FnRkVFQVRBUkFJQWxCRUhSQkVIVWhEU0FEUVJCMFFSQjFJUXdnQzBFUWRFRVFkU0VMSUFWQkVIUkJFSFVoQlNBSVFSQjBRUkIxSVFnZ0JrRVFkRUVRZFNFR0RBRUxJQWxCRUhSQkVIVWhEU0FEUVJCMFFSQjFJUXdnQzBFUWRFRVFkU0VMSUFWQkVIUkJFSFVoQlNBSVFSQjBRUkIxSVFnZ0JrRVFkRUVRZFNFR0lBUWdFMnRCQW5RZ0QycEJDR29oQTBFQUlRNERRQ0FQSUFSQkFuUnFJQU1vQWdBaUNVRVFkU0FHYkNBSlFmLy9BM0VnQm14QkVIVnFJQU5CQkdzb0FnQWlDVUVRZFNBSWJHb2dDVUgvL3dOeElBaHNRUkIxYWlBRFFRaHJLQUlBSWdsQkVIVWdCV3hxSUFsQi8vOERjU0FGYkVFUWRXb2dBMEVNYXlnQ0FDSUpRUkIxSUF0c2FpQUpRZi8vQTNFZ0MyeEJFSFZxSUFOQkVHc29BZ0FpQ1VFUWRTQU1iR29nQ1VILy93TnhJQXhzUVJCMWFpQVpJQnhCdFlqTzNRQnNRZXZHNWJBRGFpSWNRUmQyUWZ3RGNXb29BZ0FpQ1VFUWRTQU5iR29nQ1VILy93TnhJQTFzUVJCMWFrRUNkRUVJYWpZQ0FDQUVRUUZxSVFRZ0EwRUVhaUVESUE1QkFXb2lEaUFVUncwQUN3c2dBQ0FBS0FMTUlDSURRUkIxUVk4RmJDQURhaUFEUWYvL0EzRkJqd1ZzUVJCMmFpSURJQklnQXlBU1NCc2lBellDekNBZ0EwRUhkVUVCYWtFQmRTRVRJQTBnR214QkQzWWhDU0FLSUF4c1FROTJJUU1nQ2lBTGJFRVBkaUVMSUFVZ0NteEJEM1loQlNBSUlBcHNRUTkySVFnZ0JpQUtiRUVQZGlFR0lCdEJBV29pR3lBWVJ3MEFDeUFBSUFNN0FkZ2dJQUFnQ3pzQjFpQWdBQ0FGT3dIVUlDQUFJQWc3QWRJZ0lBQWdCanNCMENBTElCRkJBblFnRDJwQlFHb2lCaUFBS1FLRUNqY0NBQ0FHSUFCQnZBcHFLUUlBTndJNElBWWdBRUcwQ21vcEFnQTNBakFnQmlBQVFhd0thaWtDQURjQ0tDQUdJQUJCcEFwcUtRSUFOd0lnSUFZZ0FFR2NDbW9wQWdBM0FoZ2dCaUFBUVpRS2Fpa0NBRGNDRUNBR0lBQkJqQXBxS1FJQU53SUlJQUFvQXBnU0lnNUJBVTRFUUNBUVFRRjFJUjRnRjBFUWRFRVFkU0VLSUJaQkZYVkJBV3BCQVhVaEh5QUdLQUljSVFRZ0JpZ0NKQ0VOSUFZb0Fpd2hEQ0FHS0FJMElRVWdCaWdDUENFRElBY3VBU0loRHlBSExnRWdJUkVnQnk0QkhpRVNJQWN1QVJ3aEZDQUhMZ0VhSVJZZ0J5NEJHQ0VYSUFjdUFSWWhHQ0FITGdFVUlSa2dCeTRCRWlFYUlBY3VBUkFoR3lBUVFRdElJU0JCQUNFSUEwQWdBMEVRZFNBYmJDQWVhaUFEUWYvL0EzRWdHMnhCRUhWcUlBaEJBblFnQm1vaUF5Z0NPQ0lMUVJCMUlCcHNhaUFMUWYvL0EzRWdHbXhCRUhWcUlBVkJFSFVnR1d4cUlBVkIvLzhEY1NBWmJFRVFkV29nQXlnQ01DSUZRUkIxSUJoc2FpQUZRZi8vQTNFZ0dHeEJFSFZxSUF4QkVIVWdGMnhxSUF4Qi8vOERjU0FYYkVFUWRXb2dBeWdDS0NJTVFSQjFJQlpzYWlBTVFmLy9BM0VnRm14QkVIVnFJQTFCRUhVZ0ZHeHFJQTFCLy84RGNTQVViRUVRZFdvZ0F5Z0NJQ0lOUVJCMUlCSnNhaUFOUWYvL0EzRWdFbXhCRUhWcUlBUkJFSFVnRVd4cUlBUkIvLzhEY1NBUmJFRVFkV29nQXlnQ0dDSUVRUkIxSUE5c2FpQUVRZi8vQTNFZ0QyeEJFSFZxSVFRZ0NFRVFhaUVWUVFvaEF5QWdSUVJBQTBBZ0JDQUhRUkJxSUFOQkFYUnFMZ0VBSWgwZ0JpQVZJQU5CZjNOcVFRSjBhaWdDQUNJaFFSQjFiR29nSVVILy93TnhJQjFzUVJCMWFpRUVJQU5CQVdvaUF5QVFSdzBBQ3dzQ2Z5QUdJQlZCQW5ScUloMG9BZ0FpQXlBRVFZQ0FnRUFnQkVHQWdJQkFTaHNpQkVILy8vOC9JQVJCLy8vL1AwZ2JRUVIwSWdScUloVkJBRTRFUUNBVlFZQ0FnSUI0SUFNZ0JIRkJmMG9iREFFTFFmLy8vLzhISUJVZ0F5QUVja0YvU2hzTElRTWdIU0FETmdJQUlBSWdDRUVCZEdwQi8vOEJRWUNBZmlBRFFSQjFJQXBzSUFNZ0gyeHFJQU5CLy84RGNTQUtiRUVRZFdvaUJFRUhka0VCYWtFQmRpQUVRWUQvLzN0SUd5QUVRZi8rL3dOS0d6c0JBQ0FOSVFRZ0RDRU5JQVVoRENBTElRVWdDRUVCYWlJSUlBNUhEUUFMQ3lBQVFZUUthaUlDSUFZZ0RrRUNkR29pQkNrQ0FEY0NBQ0FDSUFRcEFqZzNBamdnQWlBRUtRSXdOd0l3SUFJZ0JDa0NLRGNDS0NBQ0lBUXBBaUEzQWlBZ0FpQUVLUUlZTndJWUlBSWdCQ2tDRURjQ0VDQUNJQVFwQWdnM0FnZ2dBQ0FKT3dHRUlTQUFJQncyQW9BaElBRWdFellDRENBQklCTTJBZ2dnQVNBVE5nSUVJQUVnRXpZQ0FDQUhRVUJySkFBTGd3WUJEbjhnQVNBQ1FRRjBhaUVNSUFBZ0FrRUJheUlMUVFGMGFpRUpJQUpCQWtnaERnSkFBMEFnQUM0QkFDSUZJQUV1QVFBaUNHc2hCRUVCSVFOQkFDRUdJQTVGQkVBRFFDQUZRUkIwSVFjZ0FDQURRUUYwSWdwcUxnRUFJZ1VnQjBFUWRXc2dBU0FLYWk0QkFHc2lCeUFFSUFRZ0Iwb2lCeHNoQkNBRElBWWdCeHNoQmlBRFFRRnFJZ01nQWtjTkFBc0xRWUNBQWlBTUxnRUFJZ2NnQ1M0QkFHcHJJZ01nQkNBRElBUklJZ01iUVg5S0RRRUNRQ0FDSUFZZ0F4c2lCVVVFUUNBQUlBZzdBUUFNQVFzQ1FBSkFJQUlnQlVjRVFDQUZRUUZPRFFGQkFDRUlEQUlMSUFsQmdJQitJQWRyT3dFQURBSUxRUUVoQXlBRlFRRkdEUUFEUUNBSUlBRWdBMEVCZEdvdUFRQnFJUWdnQTBFQmFpSURJQVZIRFFBTEN5QUlJQUVnQlVFQmRDSVBhaUlRTGdFQVFRRjFJZ3BxSVFSQmdJQUNJUVlDUUNBQ0lBVk1EUUJCZ0lBQ0lBZHJJUVlnQlNBTElnTk9EUUFEUUNBR0lBRWdBMEVCZEdvdUFRQnJJUVlnQTBFQmF5SURJQVZLRFFBTEN5QUFJQTlxSWdndUFRQWdBQ0FGUVFGclFRRjBhaUlITGdFQWFpSURRUUYxSUFOQkFYRnFJUVVDUUNBR0lBcHJJZ01nQkVnRVFDQUZJQVFpQmtvTkFTQURJQVVnQXlBRlNoc2hCZ3dCQ3lBRElnWWdCVWdOQUNBRUlBVWdCQ0FGU2hzaEJnc2dCeUFHSUFwcklnWTdBUUFnQ0NBR0lCQXZBUUJxT3dFQUN5QU5RUUZxSWcxQkZFY05BQXNnQUNBQ0VHVWdBQ0FBTGdFQUlnWWdBUzRCQUNJRElBTWdCa2diSWdRN0FRQWdBa0VDU0NJR1JRUkFRUUVoQXdOQUlBQWdBMEVCZENJTGFpSUZJQVV1QVFBaUJTQUJJQXRxTGdFQUlBUkJFSFJCRUhWcUlnUkIvLzhCSUFSQi8vOEJTQnNpQkVHQWdINGdCRUdBZ0g1S0d5SUVJQVFnQlVnYklnUTdBUUFnQTBFQmFpSURJQUpIRFFBTEN5QUpJQWt1QVFBaUEwR0FnQUlnREM0QkFHc2lCQ0FESUFSSUd5SUVPd0VBSUFZTkFDQUNRUUpySVFNRFFDQUFJQU5CQVhRaUFtb2lCaUFHTGdFQUlnWWdCRUVRZEVFUWRTQUJJQUpxTGdFQ2F5SUNJQUlnQmtvYklnUTdBUUFnQTBFQVNpRUNJQU5CQVdzaEF5QUNEUUFMQ3d2TUFnRUpmeU1BUWRBQWF5SUZKQUFnQlVFZ2FpQUZRVUJySUFJZ0FTd0FBQkJHSUFJdkFRSWlBMEVRZEVFUWRTSUhRUUZJSWd0RkJFQWdBaTRCQkNFSUEwQWdCU0FEUVFGcklnWkJBWFJxSUFFZ0Eyb3NBQUFpQ2tFS2RDSUVRZVlBYXlBRVFlWUFjaUFLUVI5MWNTQUtRUUJLR3lJRVFSQjFJQWhzSUFWQlFHc2dCbW90QUFBZ0NVRVFkRUVRZFd4QkNIVnFJQVJCL3Y4RGNTQUliRUVRZFdvaUNUc0JBQ0FEUVFGS0lRUWdCaUVESUFRTkFBc0xJQXRGQkVBZ0FTd0FBQ0FIYkNJQklBSW9BZ2hxSVFRZ0FpZ0NEQ0FCUVFGMGFpRUdRUUFoQXdOQUlBQWdBMEVCZENJQmFpQUJJQVZxTGdFQVFRNTBJQUVnQm1vdUFRQnRJQU1nQkdvdEFBQkJCM1JxSWdGQkFDQUJRUUJLR3lJQlFmLy9BU0FCUWYvL0FVZ2JPd0VBSUFOQkFXb2lBeUFDTGdFQ0lnZElEUUFMQ3lBQUlBSW9BaVFnQnhCMUlBVkIwQUJxSkFBTDJBSUJCWDhDUUNBQ1FRRklEUUFDUUFOQVFRQWhBMEVBSVFRRFFDQUJJQU5CQW5ScUtBSUFJZ1VnQlVFZmRTSUZhaUFGY3lJRklBUWdCQ0FGU0NJRkd5RUVJQU1nQmlBRkd5RUdJQU5CQVdvaUF5QUNSdzBBQ3lBRVFRUjJRUUZxUVFGMklnTkJnSUFDVHdSQUlBRWdBa0crL3dNZ0EwSCsvd2tnQTBIKy93bElHeUlEUVE1MFFZQ0EvLzhCYXlBRElBWkJBV3BzUVFKMWJXc1FLU0FIUVFGcUlnZEJDa2NOQVF3Q0N3c2dCMEVLUmcwQUlBSkJBVWdOQVVFQUlRTURRQ0FBSUFOQkFYUnFJQUVnQTBFQ2RHb29BZ0JCQkhWQkFXcEJBWFk3QVFBZ0EwRUJhaUlESUFKSERRQUxEQUVMSUFKQkFVZ05BRUVBSVFNRFFDQUFJQU5CQVhScUFuOUIvLzhCSUFFZ0EwRUNkR29pQmlnQ0FFRUVkU0lFUWY3L0Ewb05BQnBCZ0lCK0lBUkIvLzk3U0EwQUdpQUVRUUZxUVFGMUN5SUVPd0VBSUFZZ0JFRUZkRFlDQUNBRFFRRnFJZ01nQWtjTkFBc0xDNG9CQVFOL0l3QkJFR3NpQkNRQUFrQUNRQUovUVpEN0FTZ0NBQ0lGQkVBZ0EwRUJTQVIvUVg4RklBVWdBQ0FCSUFJZ0EwRUFRUUFRVGdzTUFRdEJsUHNCS0FJQUlnVkZEUUVnQlNBQUlBRWdBaUFERUg0TElnWkJBRW9OQVFzZ0JDQUROZ0lNSUFRZ0FqWUNDQ0FFSUFFMkFnUWdCQ0FBTmdJQVFiUUlJQVFRSGdzZ0JFRVFhaVFBSUFZTGt4SUJIbjhqQUVFZ2F5SUtJUWdnQ2lRQUlBQW9Bb3dTSWdrZ0FFRzhJR29vQWdCSEJFQkIvLzhCSUFBb0FxUVNJZ1pCQVdwdElRY2dCa0VCVGdSQUEwQWdBQ0FFUVFGMGFrSFVIMm9nQlNBSGFpSUZPd0VBSUFSQkFXb2lCQ0FHUncwQUN3c2dBQ0FKTmdLOElDQUFRYlFnYWtLQWdJQ0FnSkNlR0RjQ0FBc0NRQUpBSUFBb0FzQWdSUVJBQWtBZ0FDZ0N4Q0FOQUVFQUlRUWdBQ2dDcEJJaUJVRUFTZ1JBQTBBZ0FDQUVRUUYwYWlJR1FkUWZhaUlKSUFrdUFRQWlDU0FHUWFnU2FpNEJBQ0FKYXlJR1FmLy9BM0ZCM1A4QWJFRVFkaUFHUVJCMlFkei9BR3hxYWpzQkFDQUVRUUZxSWdRZ0JVY05BQXNMSUFCQjFCVnFJUWxCQUNFRUFrQWdBQ2dDbEJJaUIwRUFUQVJBUVFBaEJnd0JDMEVBSVFaQkFDRUZBMEFnQVNBRVFRSjBhaWdDRUNJTElBVWdCU0FMU0NJTEd5RUZJQVFnQmlBTEd5RUdJQVJCQVdvaUJDQUhSdzBBQ3dzZ0FDQUFLQUtjRWlJRlFRSjBha0hVRldvZ0NTQUhRUUowUVFScklBVnNFQTRhSUFrZ0FDQUFLQUtjRWlJRklBWnNRUUowYWtFRWFpQUZRUUowRUFRYUlBQW9BcFFTSWdsQkFVZ05BQ0FBUWJRZ2FpZ0NBQ0VFUVFBaEJRTkFJQUFnQkNBQklBVkJBblJxSWdaQkVHb29BZ0FnQkdzaUJFRVFkVUdhSkd4cUlBUkIvLzhEY1VHYUpHeEJFSFpxSWdRMkFyUWdJQVlvQWhBaUJpQUVRUkIxUWJ6cWZtd2dCR29nQkVILy93TnhRYnpxZm14QkVIVnFTQVJBSUFBZ0JqWUN0Q0FnQmlFRUN5QUZRUUZxSWdVZ0NVY05BQXNMSUFBb0FzQWdSUTBCQ3lBS0lBTkJBblJCendCcVFYQnhheUlISkFBZ0FFR1lJV29vQWdBaUFVRVFkRUVRZFNJRklBQkJoQ0ZxTHdFQUlnUnNRUkIxSUFVZ0JFRVFkQ0lFUVI5MWJHb2dBVUVQZFVFQmFrRUJkU0FFUVJCMWJHb2lCVUVRZFNFRUFuOGdCVUgvLy84QVRFRUFJQUJCdENCcUtBSUFJZ0ZCZ1lDQUJFZ2JSUVJBUVFBZ0FVRVFkU0lCSUFGc0lBUWdCR3hCQlhScklnUkJBVWdOQVJvQ1FFRVlJQVJuSWdGcklnVkZEUUFnQkVIL0FFMEVRQ0FFSUFGQkdHdDBJQVJCT0NBQmEzWnlJUVFNQVFzZ0JDQUJRUWhxZENBRUlBVjJjaUVFQ3lBRVFmOEFjVUdBZ05RR2JFRVFka0dBZ0FSeVFZQ0FBa0dHNlFJZ0FVRUJjUnNnQVVFQmRuWnNRWUNBZkhFTUFRdEJBQ0FCUVJCMFFSQjFJZ1lnQVVFUWRXd2dCVUVRZEVFUWRTSUtJQVZCLy84RGNXeEJFSFVnQkNBS2JHb2dCVUVQZFVFQmFrRUJkaUFGYkdwQkJYUnJJQVlnQVVILy93TnhiRUVRZFdvZ0FVRVBkVUVCYWtFQmRTQUJiR29pQkVFQlNBMEFHZ0pBUVJnZ0JHY2lBV3NpQlVVTkFDQUVRZjhBVFFSQUlBUWdBVUVZYTNRZ0JFRTRJQUZyZG5JaEJBd0JDeUFFSUFGQkNHcDBJQVFnQlhaeUlRUUxRWUNBQWtHRzZRSWdBVUVCY1JzZ0FVRUJkbllpQVNBRVFmOEFjVUdBZ05RR2JFRVFkbXhCRUhZZ0FXcEJDSFFMSVFFZ0IwRkFheUVLUWY4QklRVURRQ0FGSWdSQkFYVWhCU0FESUFSSURRQUxJQUJCdUNCcUtBSUFJUVlnQTBFQlNDSUpSUVJBUVFBaEJRTkFJQW9nQlVFQ2RHb2dBQ0FHUWJXSXp0MEFiRUhyeHVXd0Eyb2lCa0VZZFNBRWNVRUNkR3BCMUJWcUtBSUFOZ0lBSUFWQkFXb2lCU0FEUncwQUN3c2dBQ0FHTmdLNElDQUlJQUJCMUI5cUlBQW9BcVFTSUFBb0FzZ2dFQ3NnQnlBQVFhd2dhaWtDQURjQ09DQUhJQUJCcENCcUtRSUFOd0l3SUFjZ0FFR2NJR29wQWdBM0FpZ2dCeUFBUVpRZ2Fpa0NBRGNDSUNBSElBQkJqQ0JxS1FJQU53SVlJQWNnQUVHRUlHb3BBZ0EzQWhBZ0J5QUFRZndmYWlrQ0FEY0NDQ0FISUFCQjlCOXFJZ3NwQWdBM0FnQWdDVVVFUUNBQlFRcDBRUkIxSVF3Z0FDZ0NwQklpSGtFQmRTRWZJQUZCRlhWQkFXcEJBWFVoSUNBSEtBSWNJUVVnQnlnQ0pDRUdJQWNvQWl3aENpQUhLQUkwSVFFZ0J5Z0NQQ0VFSUFndUFSNGhEU0FJTGdFY0lRNGdDQzRCR2lFUElBZ3VBUmdoRUNBSUxnRVdJUkVnQ0M0QkZDRVNJQWd1QVJJaEV5QUlMZ0VRSVJRZ0NDNEJEaUVWSUFndUFRd2hGaUFJTGdFS0lSY2dDQzRCQ0NFWUlBZ3VBUVloR1NBSUxnRUVJUm9nQ0M0QkFpRWJJQWd1QVFBaEhFRUFJUUFEUUNBRVFSQjFJQnhzSUI5cUlBUkIvLzhEY1NBY2JFRVFkV29nQUVFQ2RDQUhhaUlFS0FJNElnbEJFSFVnRzJ4cUlBbEIvLzhEY1NBYmJFRVFkV29nQVVFUWRTQWFiR29nQVVILy93TnhJQnBzUVJCMWFpQUVLQUl3SWdGQkVIVWdHV3hxSUFGQi8vOERjU0FaYkVFUWRXb2dDa0VRZFNBWWJHb2dDa0gvL3dOeElCaHNRUkIxYWlBRUtBSW9JZ3BCRUhVZ0YyeHFJQXBCLy84RGNTQVhiRUVRZFdvZ0JrRVFkU0FXYkdvZ0JrSC8vd054SUJac1FSQjFhaUFFS0FJZ0lnWkJFSFVnRld4cUlBWkIvLzhEY1NBVmJFRVFkV29nQlVFUWRTQVViR29nQlVILy93TnhJQlJzUVJCMWFpQUVLQUlZSWdWQkVIVWdFMnhxSUFWQi8vOERjU0FUYkVFUWRXb2hCUUovQW44Z0hrRVFSZ1JBSUFVZ0JDZ0NGQ0lGUVJCMUlCSnNhaUFGUWYvL0EzRWdFbXhCRUhWcUlBUW9BaEFpQlVFUWRTQVJiR29nQlVILy93TnhJQkZzUVJCMWFpQUVLQUlNSWdWQkVIVWdFR3hxSUFWQi8vOERjU0FRYkVFUWRXb2dCQ2dDQ0NJRlFSQjFJQTlzYWlBRlFmLy9BM0VnRDJ4QkVIVnFJQVFvQWdRaUJVRVFkU0FPYkdvZ0JVSC8vd054SUE1c1FSQjFhaUFFS0FJQUlnVkJFSFVnRFd4cUlBVkIvLzhEY1NBTmJFRVFkV29oQlFzZ0JRdEJnSUNBUUNBRlFZQ0FnRUJLR3lJRlFmLy8vejhnQlVILy8vOC9TQnRCQkhRaUJTQUhJQUJCRUdwQkFuUnFJaUVvQWdBaUJHb2lIVUVBVGdSQUlCMUJnSUNBZ0hnZ0JDQUZjVUYvU2hzTUFRdEIvLy8vL3djZ0hTQUVJQVZ5UVg5S0d3c2hCQ0FoSUFRMkFnQWdBaUFBUVFGMGFpSUZJQVV1QVFCQi8vOEJRWUNBZmlBRVFSQjFJQXhzSUFRZ0lHeHFJQVJCLy84RGNTQU1iRUVRZFdvaUJVRUhkVUVCYWtFQmRTQUZRWUQvLzN0SUd5QUZRZi8rL3dOS0cyb2lCVUdBZ0g0Z0JVR0FnSDVLR3lJRlFmLy9BU0FGUWYvL0FVZ2JPd0VBSUFZaEJTQUtJUVlnQVNFS0lBa2hBU0FBUVFGcUlnQWdBMGNOQUFzTElBc2dCeUFEUVFKMGFpSUFLUUlBTndJQUlBc2dBQ2tDT0RjQ09DQUxJQUFwQWpBM0FqQWdDeUFBS1FJb053SW9JQXNnQUNrQ0lEY0NJQ0FMSUFBcEFoZzNBaGdnQ3lBQUtRSVFOd0lRSUFzZ0FDa0NDRGNDQ0F3QkN5QUFRZlFmYWtFQUlBQW9BcVFTUVFKMEVBVWFDeUFJUVNCcUpBQUxWUUVFZjBILy93RWdBQ2dDcEJJaUFrRUJhbTBoQkNBQ1FRRk9CRUFEUUNBQUlBRkJBWFJxUWRRZmFpQURJQVJxSWdNN0FRQWdBVUVCYWlJQklBSkhEUUFMQ3lBQVFiUWdha0tBZ0lDQWdKQ2VHRGNDQUF0eUFBSkFJQU1FUUVFQUlRWWdCVUVBVEEwQkEwQWdBQ0FCSUFac0lBSnFRUUowYWlBRElBUWdCbXhCQW5ScUtnSUFPQUlBSUFaQkFXb2lCaUFGUncwQUN3d0JDMEVBSVFZZ0JVRUFUQTBBQTBBZ0FDQUJJQVpzSUFKcVFRSjBha0VBTmdJQUlBWkJBV29pQmlBRlJ3MEFDd3NMTndFQmZ5TUFRVEJySWdJa0FFRUNFQXdhUVFFUURCb2dBaUFCS0FJQU5nSUFJQUJCakFKcUlBSVFpZ0VoQUNBQ1FUQnFKQUFnQUFzbEFRRi9Jd0JCRUdzaUFpUUFJQUlnQVRZQ0RDQUFJQUVRZkNFQUlBSkJFR29rQUNBQUM1c0dBUTEvSXdCQmdBRnJJZ2doQnlBSUpBQUNRQ0FFUVFGSUJFQkJmeUVGREFFTElBY2dCMEVJYWpZQ0FFRjlJUVVnQUNBSEVIME5BQ0FJSUFRZ0J5Z0NDRUVaYlVFRGJDSUZJQVFnQlVnYklnUkJBM1JCRDJwQmNIRnJJZ3drQUVFQ0VBd2hFRUVCRUF3aEVRSkFJQUpCQUVnRVFFRi9JUVVNQVFzZ0FnUkFRWHdoQlNBQUtBSUVJZ3BCQVhSQkFXc2dBa29OQVFKQUlBcEJBVWdOQUNBS1FRRnJJUTRnQnlnQ0NDRVBRUUFoQ0NBQklRc2dBaUVGQTBCQmZDRUdJQVZCQVVnTkFTQUxJQVVnQ1NBT1J5QUhRZjhBYWlBSFFSQnFRUUFnQjBFTWFoQTNJZ1pCQUVnTkFTQUxJQWNvQWd3Z0R4Q0RBU0VOSUFrRVFFRjhJUVlnQ0NBTlJ3MENDeUFGSUFjb0Fnd2lDR3NoQlNBSUlBdHFJUXNnRFNJSUlRWWdDVUVCYWlJSklBcEhEUUFMQ3lBR1FYNGdCa0VBU0JzaEJTQUVJQVpJRFFFZ0JrRUFTQTBCQ3lBQUtBSUVJZ1ZCQVU0RVFDQUNRUUJISVFzZ0FFR01BbW9oQ0NBTVFRUnFJUTBnQWlFSlFRQWhCZ05BSUFzZ0NVRUJTSEVFUUVGOUlRVU1Bd3NnQUNnQ0NDRUtJQWRCQURZQ0VDQUlJQUVnQ1NBTUlBUWdCaUFGUVFGclJ5QUhRUkJxRUU0aUJFRUJTQVJBSUFRaEJRd0RDeUFRSUJFZ0JpQUtTQnRCQTJwQmZIRWhDaUFIS0FJUUlnVkJBQ0FDR3lFT0lBRWdCV29oRHdKQUlBQW9BZ2dnQmt3RVFDQUFJQVpCZnhCSUlnVkJmMFlOQVFOQUlBTWdBQ2dDQUNBRklBeEJBU0FFUVFCQkFSRUhBQ0FBSUFZZ0JSQklJZ1ZCZjBjTkFBc01BUXNnQUNBR1FYOFFTaUlGUVg5SEJFQURRQ0FESUFBb0FnQWdCU0FNUVFJZ0JFRUFRUUVSQndBZ0FDQUdJQVVRU2lJRlFYOUhEUUFMQ3lBQUlBWkJmeEJKSWdWQmYwWU5BQU5BSUFNZ0FDZ0NBQ0FGSUExQkFpQUVRUUJCQVJFSEFDQUFJQVlnQlJCSklnVkJmMGNOQUFzTElBZ2dDbW9oQ0NBSklBNXJJUWtnRHlBQklBSWJJUUVnQmtFQmFpSUdJQUFvQWdRaUJVZ05BQXNMUVFBaEJpQUFLQUlBSWdWQkFFb0VRQU5BSUFBZ0Jtb3RBQXhCL3dGR0JFQWdBeUFGSUFaQkFFRUFJQVJCQUVFQkVRY0FJQUFvQWdBaEJRc2dCa0VCYWlJR0lBVklEUUFMQ3lBRUlRVUxDeUFIUVlBQmFpUUFJQVVMZ2dFQkFYOENRQ0FCUVFGclFmNEJTd1JBSUFKRkRRRWdBa0YvTmdJQVFRQVBDMEVDRUF4QkEycEJmSEZCQVhSQkFSQU1RUU5xUVh4eFFRRjBha0dNQW1vUUZTSURSUVJBUVFBaEF5QUNSUTBCSUFKQmVUWUNBRUVBRHdzZ0F5QUFJQUVRZ0FFaEFDQUNCRUFnQWlBQU5nSUFDeUFBUlEwQUlBTVFDRUVBSVFNTElBTUw3Z0VCQkg5QmZ5RUVBa0FnQWtFQmEwSCtBVXNOQUNBQVFRSTJBZ2dnQUVFRU5nSUVJQUFnQWpZQ0FBTkFJQUFnQTJvZ0EwR0FDR290QUFBNkFBd2dBMEVCYWlJRElBSkhEUUFMSUFBUWdnRkZEUUFnQUVHTUFtb2hBMEVDRUF3aEFrRUJFQXdoQlFKQUlBQW9BZ2hCQVVnRVFFRUFJUUlNQVFzZ0FrRURha0Y4Y1NFR1FRQWhBZ05BSUFNZ0FVRUNFREFpQkEwQ0lBTWdCbW9oQXlBQ1FRRnFJZ0lnQUNnQ0NFZ05BQXNMSUFBb0FnUWdBa29FUUNBRlFRTnFRWHh4SVFVRFFDQURJQUZCQVJBd0lnUU5BaUFESUFWcUlRTWdBa0VCYWlJQ0lBQW9BZ1JJRFFBTEMwRUFJUVFMSUFRTGlBSUJBMzhqQUVFUWF5SURKQUFDUUVFQVFaRDdBU2dDQUNJQ1JVR1Urd0VvQWdBaUJCc05BQUpBSUFJRVFDQUNFQWhCa1BzQlFRQTJBZ0FNQVFzZ0JFVU5BQ0FFRUFoQmxQc0JRUUEyQWdBTFFaajdBU2dDQUNJQ1JRMEFBMEFnQWlnQ0FCQUlJQUlvQWdRaEJDQUNFQWdnQkNJQ0RRQUxRWmo3QVVFQU5nSUFDeUFEUVFBMkFnd0NRQ0FCUVFGclFRRk5CRUJCa1BzQklBQWdBU0FEUVF4cUVKY0JOZ0lBREFFTFFaVDdBU0FBSUFFZ0EwRU1haEIvTmdJQUN5QURLQUlNSWdKQmYwd0VRQ0FESUFKQkIycEJCMDBFZjBIUU95QUNRUUowYXlnQ0FBVkIrVHdMTmdJRUlBTWdBallDQUVHR0NDQURFQjRnQXlnQ0RDRUNDeUFEUVJCcUpBQWdBZ3RYQVFSL0lBQW9BZ2dnQUNnQ0JHb2lBa0gvQVV3RVFDQUFLQUlBSWdOQkFFd0VRRUVCRHdzQ1FBTkFJQUFnQVdvdEFBd2lCRUgvQVVkQkFDQUNJQVJNR3cwQklBRkJBV29pQVNBRFNBMEFDMEVCRHdzTFFRQUxhZ0VCZjBFQklRTUNRQ0FCUVFGSUJFQkJmeUVEREFFTEFrQUNRQUpBSUFBdEFBQkJBM0ZCQVdzT0F3QUFBUUlMUVFJaEF3d0JDMEY4SVFNZ0FVRUNTQTBCSUFBdEFBRkJQM0VoQXd0QmZDQUFJQUlRT2lBRGJDSUFJQUJCR1d3Z0FrRURiRW9iRHdzZ0F3c1FBQ01BSUFCclFYQnhJZ0FrQUNBQUN3WUFJQUFrQUFzRUFDTUFDNE1CQWdOL0FYNENRQ0FBUW9DQWdJQVFWQVJBSUFBaEJRd0JDd05BSUFGQkFXc2lBU0FBSUFCQ0NvQWlCVUlLZm4yblFUQnlPZ0FBSUFCQy8vLy8vNThCVmlFQ0lBVWhBQ0FDRFFBTEN5QUZweUlDQkVBRFFDQUJRUUZySWdFZ0FpQUNRUXB1SWdOQkNteHJRVEJ5T2dBQUlBSkJDVXNoQkNBRElRSWdCQTBBQ3dzZ0FRc3RBQ0FBVUVVRVFBTkFJQUZCQVdzaUFTQUFwMEVIY1VFd2Nqb0FBQ0FBUWdPSUlnQkNBRklOQUFzTElBRUxOUUFnQUZCRkJFQURRQ0FCUVFGcklnRWdBS2RCRDNGQmdQZ0JhaTBBQUNBQ2Nqb0FBQ0FBUWdTSUlnQkNBRklOQUFzTElBRUxWZ0VCZnlNQVFUQnJJZ0lrQUNBQUtBSUVHaUFBS0FJQUdpQUNJQUUyQWl3Q2Z5QUNJQUlvQWl3aUFVRUVhallDTEVGL0lBRW9BZ0FpQVVVTkFCb2dBU0FBS0FJTU5nSUFRUUFMSVFFZ0FrRXdhaVFBSUFFTHh3SUJBMzhqQUVIUUFXc2lBeVFBSUFNZ0FqWUN6QUZCQUNFQ0lBTkJvQUZxUVFCQktCQUZHaUFESUFNb0Fzd0JOZ0xJQVFKQVFRQWdBU0FEUWNnQmFpQURRZEFBYWlBRFFhQUJhaEFzUVFCSURRQWdBQ2dDVEVFQVRpRUNJQUFvQWdBaEJDQUFMQUJLUVFCTUJFQWdBQ0FFUVY5eE5nSUFDeUFFUVNCeElRVUNmeUFBS0FJd0JFQWdBQ0FCSUFOQnlBRnFJQU5CMEFCcUlBTkJvQUZxRUN3TUFRc2dBRUhRQURZQ01DQUFJQU5CMEFCcU5nSVFJQUFnQXpZQ0hDQUFJQU0yQWhRZ0FDZ0NMQ0VFSUFBZ0F6WUNMQ0FBSUFFZ0EwSElBV29nQTBIUUFHb2dBMEdnQVdvUUxDQUVSUTBBR2lBQVFRQkJBQ0FBS0FJa0VRQUFHaUFBUVFBMkFqQWdBQ0FFTmdJc0lBQkJBRFlDSENBQVFRQTJBaEFnQUNnQ0ZCb2dBRUVBTmdJVVFRQUxHaUFBSUFBb0FnQWdCWEkyQWdBZ0FrVU5BQXNnQTBIUUFXb2tBQXVwQVFFRGZ3SkFJQUVnQWlnQ0VDSUVCSDhnQkFVZ0FoQ05BUTBCSUFJb0FoQUxJQUlvQWhRaUJXdExCRUFnQWlBQUlBRWdBaWdDSkJFQUFCb1BDd0pBSUFJc0FFdEJBRWdOQUNBQklRUURRQ0FFSWdORkRRRWdBQ0FEUVFGcklnUnFMUUFBUVFwSERRQUxJQUlnQUNBRElBSW9BaVFSQUFBZ0Ewa05BU0FBSUFOcUlRQWdBU0FEYXlFQklBSW9BaFFoQlFzZ0JTQUFJQUVRQkJvZ0FpQUNLQUlVSUFGcU5nSVVDd3RaQVFGL0lBQWdBQzBBU2lJQlFRRnJJQUZ5T2dCS0lBQW9BZ0FpQVVFSWNRUkFJQUFnQVVFZ2NqWUNBRUYvRHdzZ0FFSUFOd0lFSUFBZ0FDZ0NMQ0lCTmdJY0lBQWdBVFlDRkNBQUlBRWdBQ2dDTUdvMkFoQkJBQXVMQWdBQ1FDQUFCSDhnQVVIL0FFME5BUUpBUWRUNkFTZ0NBQ2dDQUVVRVFDQUJRWUIvY1VHQXZ3TkdEUU1NQVFzZ0FVSC9EMDBFUUNBQUlBRkJQM0ZCZ0FGeU9nQUJJQUFnQVVFR2RrSEFBWEk2QUFCQkFnOExJQUZCZ0xBRFQwRUFJQUZCZ0VCeFFZREFBMGNiUlFSQUlBQWdBVUUvY1VHQUFYSTZBQUlnQUNBQlFReDJRZUFCY2pvQUFDQUFJQUZCQm5aQlAzRkJnQUZ5T2dBQlFRTVBDeUFCUVlDQUJHdEIvLzgvVFFSQUlBQWdBVUUvY1VHQUFYSTZBQU1nQUNBQlFSSjJRZkFCY2pvQUFDQUFJQUZCQm5aQlAzRkJnQUZ5T2dBQ0lBQWdBVUVNZGtFL2NVR0FBWEk2QUFGQkJBOExDMEdjK3dGQkdUWUNBRUYvQlVFQkN3OExJQUFnQVRvQUFFRUJDN29CQVFGL0lBRkJBRWNoQWdKQUFrQUNRQ0FCUlEwQUlBQkJBM0ZGRFFBRFFDQUFMUUFBUlEwQ0lBQkJBV29oQUNBQlFRRnJJZ0ZCQUVjaEFpQUJSUTBCSUFCQkEzRU5BQXNMSUFKRkRRRUxBa0FnQUMwQUFFVU5BQ0FCUVFSSkRRQURRQ0FBS0FJQUlnSkJmM01nQWtHQmdvUUlhM0ZCZ0lHQ2hIaHhEUUVnQUVFRWFpRUFJQUZCQkdzaUFVRURTdzBBQ3dzZ0FVVU5BQU5BSUFBdEFBQkZCRUFnQUE4TElBQkJBV29oQUNBQlFRRnJJZ0VOQUFzTFFRQUxCQUJDQUFzRUFFRUFDL29DQVFkL0l3QkJJR3NpQXlRQUlBTWdBQ2dDSENJRk5nSVFJQUFvQWhRaEJDQURJQUkyQWh3Z0F5QUJOZ0lZSUFNZ0JDQUZheUlCTmdJVUlBRWdBbW9oQlVFQ0lRY2dBMEVRYWlFQkFuOENRQUpBQW45QkFDQUFLQUk4SUFOQkVHcEJBaUFEUVF4cUVBQWlCRVVOQUJwQm5Qc0JJQVEyQWdCQmZ3dEZCRUFEUUNBRklBTW9BZ3dpQkVZTkFpQUVRWDlNRFFNZ0FTQUVJQUVvQWdRaUNFc2lCa0VEZEdvaUNTQUVJQWhCQUNBR0cyc2lDQ0FKS0FJQWFqWUNBQ0FCUVF4QkJDQUdHMm9pQ1NBSktBSUFJQWhyTmdJQUlBVWdCR3NoQlFKL1FRQWdBQ2dDUENBQlFRaHFJQUVnQmhzaUFTQUhJQVpySWdjZ0EwRU1haEFBSWdSRkRRQWFRWno3QVNBRU5nSUFRWDhMUlEwQUN3c2dCVUYvUncwQkN5QUFJQUFvQWl3aUFUWUNIQ0FBSUFFMkFoUWdBQ0FCSUFBb0FqQnFOZ0lRSUFJTUFRc2dBRUVBTmdJY0lBQkNBRGNERUNBQUlBQW9BZ0JCSUhJMkFnQkJBQ0FIUVFKR0RRQWFJQUlnQVNnQ0JHc0xJUUFnQTBFZ2FpUUFJQUFMdUE0Q0VIOENmQ01BUWJBRWF5SUdKQUFnQWlBQ1FRTnJRUmh0SWdSQkFDQUVRUUJLR3lJTlFXaHNhaUVJUWZUZEFTZ0NBQ0lKSUFOQkFXc2lCMnBCQUU0RVFDQURJQWxxSVFRZ0RTQUhheUVDQTBBZ0JrSEFBbW9nQlVFRGRHb2dBa0VBU0FSOFJBQUFBQUFBQUFBQUJTQUNRUUowUVlEZUFXb29BZ0MzQ3prREFDQUNRUUZxSVFJZ0JVRUJhaUlGSUFSSERRQUxDeUFJUVJocklRcEJBQ0VFSUFsQkFDQUpRUUJLR3lFRklBTkJBVWdoQ3dOQUFrQWdDd1JBUkFBQUFBQUFBQUFBSVJRTUFRc2dCQ0FIYWlFTVFRQWhBa1FBQUFBQUFBQUFBQ0VVQTBBZ0ZDQUFJQUpCQTNScUt3TUFJQVpCd0FKcUlBd2dBbXRCQTNScUt3TUFvcUFoRkNBQ1FRRnFJZ0lnQTBjTkFBc0xJQVlnQkVFRGRHb2dGRGtEQUNBRUlBVkdJUUlnQkVFQmFpRUVJQUpGRFFBTFFTOGdDR3NoRUVFd0lBaHJJUTRnQ0VFWmF5RVJJQWtoQkFKQUEwQWdCaUFFUVFOMGFpc0RBQ0VVUVFBaEFpQUVJUVVnQkVFQlNDSUhSUVJBQTBBZ0JrSGdBMm9nQWtFQ2RHb0NmeUFVQW44Z0ZFUUFBQUFBQUFCd1BxSWlGSmxFQUFBQUFBQUE0RUZqQkVBZ0ZLb01BUXRCZ0lDQWdIZ0x0eUlVUkFBQUFBQUFBSERCb3FBaUZabEVBQUFBQUFBQTRFRmpCRUFnRmFvTUFRdEJnSUNBZ0hnTE5nSUFJQVlnQlVFQmF5SUZRUU4wYWlzREFDQVVvQ0VVSUFKQkFXb2lBaUFFUncwQUN3c0NmeUFVSUFvUUZDSVVJQlJFQUFBQUFBQUF3RCtpbkVRQUFBQUFBQUFnd0tLZ0loU1pSQUFBQUFBQUFPQkJZd1JBSUJTcURBRUxRWUNBZ0lCNEN5RUxJQlFnQzdlaElSUUNRQUpBQWtBQ2Z5QUtRUUZJSWhKRkJFQWdCRUVDZENBR2FpSUNJQUlvQXR3RElnSWdBaUFPZFNJQ0lBNTBheUlGTmdMY0F5QUNJQXRxSVFzZ0JTQVFkUXdCQ3lBS0RRRWdCRUVDZENBR2FpZ0MzQU5CRjNVTElneEJBVWdOQWd3QkMwRUNJUXdnRkVRQUFBQUFBQURnUDJaQkFYTkZEUUJCQUNFTURBRUxRUUFoQWtFQUlRVWdCMFVFUUFOQUlBWkI0QU5xSUFKQkFuUnFJaE1vQWdBaEQwSC8vLzhISVFjQ2Z3SkFJQVVOQUVHQWdJQUlJUWNnRHcwQVFRQU1BUXNnRXlBSElBOXJOZ0lBUVFFTElRVWdBa0VCYWlJQ0lBUkhEUUFMQ3dKQUlCSU5BQUpBQWtBZ0VRNENBQUVDQ3lBRVFRSjBJQVpxSWdJZ0FpZ0MzQU5CLy8vL0EzRTJBdHdEREFFTElBUkJBblFnQm1vaUFpQUNLQUxjQTBILy8vOEJjVFlDM0FNTElBdEJBV29oQ3lBTVFRSkhEUUJFQUFBQUFBQUE4RDhnRktFaEZFRUNJUXdnQlVVTkFDQVVSQUFBQUFBQUFQQS9JQW9RRktFaEZBc2dGRVFBQUFBQUFBQUFBR0VFUUVFQUlRVUNRQ0FKSUFRaUFrNE5BQU5BSUFaQjRBTnFJQUpCQVdzaUFrRUNkR29vQWdBZ0JYSWhCU0FDSUFsS0RRQUxJQVZGRFFBZ0NpRUlBMEFnQ0VFWWF5RUlJQVpCNEFOcUlBUkJBV3NpQkVFQ2RHb29BZ0JGRFFBTERBTUxRUUVoQWdOQUlBSWlCVUVCYWlFQ0lBWkI0QU5xSUFrZ0JXdEJBblJxS0FJQVJRMEFDeUFFSUFWcUlRVURRQ0FHUWNBQ2FpQURJQVJxSWdkQkEzUnFJQVJCQVdvaUJDQU5ha0VDZEVHQTNnRnFLQUlBdHprREFFRUFJUUpFQUFBQUFBQUFBQUFoRkNBRFFRRk9CRUFEUUNBVUlBQWdBa0VEZEdvckF3QWdCa0hBQW1vZ0J5QUNhMEVEZEdvckF3Q2lvQ0VVSUFKQkFXb2lBaUFEUncwQUN3c2dCaUFFUVFOMGFpQVVPUU1BSUFRZ0JVZ05BQXNnQlNFRURBRUxDd0pBSUJSQkdDQUlheEFVSWhSRUFBQUFBQUFBY0VGbVFRRnpSUVJBSUFaQjRBTnFJQVJCQW5ScUFuOGdGQUovSUJSRUFBQUFBQUFBY0Q2aUloU1pSQUFBQUFBQUFPQkJZd1JBSUJTcURBRUxRWUNBZ0lCNEN5SUN0MFFBQUFBQUFBQnd3YUtnSWhTWlJBQUFBQUFBQU9CQll3UkFJQlNxREFFTFFZQ0FnSUI0Q3pZQ0FDQUVRUUZxSVFRTUFRc0NmeUFVbVVRQUFBQUFBQURnUVdNRVFDQVVxZ3dCQzBHQWdJQ0FlQXNoQWlBS0lRZ0xJQVpCNEFOcUlBUkJBblJxSUFJMkFnQUxSQUFBQUFBQUFQQS9JQWdRRkNFVUFrQWdCRUYvVEEwQUlBUWhBZ05BSUFZZ0FrRURkR29nRkNBR1FlQURhaUFDUVFKMGFpZ0NBTGVpT1FNQUlCUkVBQUFBQUFBQWNENmlJUlFnQWtFQVNpRUFJQUpCQVdzaEFpQUFEUUFMUVFBaEJ5QUVRUUJJRFFBZ0NVRUFJQWxCQUVvYklRQWdCQ0VGQTBBZ0FDQUhJQUFnQjBrYklRTWdCQ0FGYXlFSVFRQWhBa1FBQUFBQUFBQUFBQ0VVQTBBZ0ZDQUNRUU4wUWREekFXb3JBd0FnQmlBQ0lBVnFRUU4wYWlzREFLS2dJUlFnQWlBRFJ5RUtJQUpCQVdvaEFpQUtEUUFMSUFaQm9BRnFJQWhCQTNScUlCUTVBd0FnQlVFQmF5RUZJQVFnQjBjaEFpQUhRUUZxSVFjZ0FnMEFDd3RFQUFBQUFBQUFBQUFoRkNBRVFRQk9CRUFnQkNFQ0EwQWdGQ0FHUWFBQmFpQUNRUU4wYWlzREFLQWhGQ0FDUVFCS0lRQWdBa0VCYXlFQ0lBQU5BQXNMSUFFZ0ZKb2dGQ0FNR3prREFDQUdLd09nQVNBVW9TRVVRUUVoQWlBRVFRRk9CRUFEUUNBVUlBWkJvQUZxSUFKQkEzUnFLd01Bb0NFVUlBSWdCRWNoQUNBQ1FRRnFJUUlnQUEwQUN3c2dBU0FVbWlBVUlBd2JPUU1JSUFaQnNBUnFKQUFnQzBFSGNRdk1DUU1GZndGK0JId2pBRUV3YXlJRUpBQUNRQUpBQWtBZ0FMMGlCMElnaUtjaUFrSC8vLy8vQjNFaUEwSDYxTDJBQkUwRVFDQUNRZi8vUDNGQis4TWtSZzBCSUFOQi9MS0xnQVJOQkVBZ0IwSUFXUVJBSUFFZ0FFUUFBRUJVK3lINXY2QWlBRVF4WTJJYVliVFF2YUFpQ0RrREFDQUJJQUFnQ0tGRU1XTmlHbUcwMEwyZ09RTUlRUUVoQWd3RkN5QUJJQUJFQUFCQVZQc2grVCtnSWdCRU1XTmlHbUcwMEQyZ0lnZzVBd0FnQVNBQUlBaWhSREZqWWhwaHROQTlvRGtEQ0VGL0lRSU1CQXNnQjBJQVdRUkFJQUVnQUVRQUFFQlUreUVKd0tBaUFFUXhZMklhWWJUZ3ZhQWlDRGtEQUNBQklBQWdDS0ZFTVdOaUdtRzA0TDJnT1FNSVFRSWhBZ3dFQ3lBQklBQkVBQUJBVlBzaENVQ2dJZ0JFTVdOaUdtRzA0RDJnSWdnNUF3QWdBU0FBSUFpaFJERmpZaHBodE9BOW9Ea0RDRUYrSVFJTUF3c2dBMEc3alBHQUJFMEVRQ0FEUWJ6NzE0QUVUUVJBSUFOQi9MTExnQVJHRFFJZ0IwSUFXUVJBSUFFZ0FFUUFBREIvZk5rU3dLQWlBRVRLbEpPbmtRN3B2YUFpQ0RrREFDQUJJQUFnQ0tGRXlwU1RwNUVPNmIyZ09RTUlRUU1oQWd3RkN5QUJJQUJFQUFBd2YzelpFa0NnSWdCRXlwU1RwNUVPNlQyZ0lnZzVBd0FnQVNBQUlBaWhSTXFVazZlUkR1azlvRGtEQ0VGOUlRSU1CQXNnQTBIN3crU0FCRVlOQVNBSFFnQlpCRUFnQVNBQVJBQUFRRlQ3SVJuQW9DSUFSREZqWWhwaHRQQzlvQ0lJT1FNQUlBRWdBQ0FJb1VReFkySWFZYlR3dmFBNUF3aEJCQ0VDREFRTElBRWdBRVFBQUVCVSt5RVpRS0FpQUVReFkySWFZYlR3UGFBaUNEa0RBQ0FCSUFBZ0NLRkVNV05pR21HMDhEMmdPUU1JUVh3aEFnd0RDeUFEUWZyRDVJa0VTdzBCQ3lBQklBQWdBRVNEeU1sdE1GL2tQNkpFQUFBQUFBQUFPRU9nUkFBQUFBQUFBRGpEb0NJSlJBQUFRRlQ3SWZtL29xQWlDQ0FKUkRGallocGh0TkE5b2lJTG9TSUFPUU1BSUFOQkZIWWlCU0FBdlVJMGlLZEIvdzl4YTBFUlNDRURBbjhnQ1psRUFBQUFBQUFBNEVGakJFQWdDYW9NQVF0QmdJQ0FnSGdMSVFJQ1FDQUREUUFnQVNBSUlBbEVBQUJnR21HMDBEMmlJZ0NoSWdvZ0NVUnpjQU11aWhtak82SWdDQ0FLb1NBQW9hRWlDNkVpQURrREFDQUZJQUM5UWpTSXAwSC9EM0ZyUVRKSUJFQWdDaUVJREFFTElBRWdDaUFKUkFBQUFDNktHYU03b2lJQW9TSUlJQWxFd1VrZ0pacURlem1pSUFvZ0NLRWdBS0doSWd1aElnQTVBd0FMSUFFZ0NDQUFvU0FMb1RrRENBd0JDeUFEUVlDQXdQOEhUd1JBSUFFZ0FDQUFvU0lBT1FNQUlBRWdBRGtEQ0VFQUlRSU1BUXNnQjBMLy8vLy8vLy8vQjROQ2dJQ0FnSUNBZ0xEQkFJUy9JUUJCQUNFQ1FRRWhCUU5BSUFSQkVHb2dBa0VEZEdvQ2Z5QUFtVVFBQUFBQUFBRGdRV01FUUNBQXFnd0JDMEdBZ0lDQWVBdTNJZ2c1QXdBZ0FDQUlvVVFBQUFBQUFBQndRYUloQUVFQklRSWdCVUVCY1NFR1FRQWhCU0FHRFFBTElBUWdBRGtESUFKQUlBQkVBQUFBQUFBQUFBQmlCRUJCQWlFQ0RBRUxRUUVoQlFOQUlBVWlBa0VCYXlFRklBUkJFR29nQWtFRGRHb3JBd0JFQUFBQUFBQUFBQUJoRFFBTEN5QUVRUkJxSUFRZ0EwRVVka0dXQ0dzZ0FrRUJhaENUQVNFQ0lBUXJBd0FoQUNBSFFuOVhCRUFnQVNBQW1qa0RBQ0FCSUFRckF3aWFPUU1JUVFBZ0Ftc2hBZ3dCQ3lBQklBQTVBd0FnQVNBRUt3TUlPUU1JQ3lBRVFUQnFKQUFnQWd1dkF3RUVmUUpBSUFJRVFFTjlIWkFtSVFZZ0EwRUJTQVJBUTMwZGtDWWhCUXdDQzBFQUlRSkRmUjJRSmlFRkEwQWdCU0FBSUFKQkFuUWlCR29xQWdBaUJ5QUJJQVJxS2dJQUlnaVRJZ1VnQlpTU0lRVWdCaUFISUFpU0lnWWdCcFNTSVFZZ0FrRUJhaUlDSUFOSERRQUxEQUVMSUFOQkFVZ0VRRU45SFpBbUlRVkRmUjJRSmlFR0RBRUxRUUFoQWdOQUlBWWdBQ0FDUVFKMGFpb0NBQ0lGSUFXVWtpRUdJQUpCQVdvaUFpQURSdzBBQ3lBR1EzMGRrQ2FTSVFaQkFDRUNRd0FBQUFBaEJRTkFJQVVnQVNBQ1FRSjBhaW9DQUNJRklBV1VraUVGSUFKQkFXb2lBaUFEUncwQUN5QUZRMzBka0NhU0lRVUxBbjFEQUFBQUFDQUZrU0lJSUFpVUlnVWdCcEVpQnlBSGxDSUdra1B2a3BNaFhRMEFHa1BiRDhrL0lBZ2dCNVFnQlNBR1F3WDQzRDZVa3BRZ0JTQUdReUd4TFQrVWtpQUZJQVpEWlFtd1BaU1NsSldUSUFVZ0JsNUJBWE5GRFFBYUlBZ2dCNVFnQmlBRlF3WDQzRDZVa3BRZ0JpQUZReUd4TFQrVWtpQUdJQVZEWlFtd1BaU1NsSlZEMncvSlA1SkQydy9KdjVJTFE0ZjVJa2FVUXdBQUFEK1NqaUlGaTBNQUFBQlBYUVJBSUFXb0R3dEJnSUNBZ0hnTDhBRUJCSDhqQUNJSElRb2dBVUVCSUFGQkFVb2JJUWdnQnlBQlFRSjBRUTlxUVhCeGF5SUhKQUJEQUFDQVB5QUhJQUVnQWlBRkVGZVJsU0FHbENFR1FRQWhCUU5BSUFBZ0JVRUNkQ0lKYWlBR0lBY2dDV29vQWdDeWxEZ0NBQ0FGUVFGcUlnVWdDRWNOQUFzZ0FDQUJRWDhnQkNBQ0lBTVFMMEVCSVFJZ0JFRUNUZ1JBSUFFZ0JHNGlBMEVCSUFOQkFVb2JJUWhCQUNFQ1FRQWhBUU5BSUFFZ0Eyd2hDVUVBSVFWQkFDRUFBMEFnQnlBRklBbHFRUUowYWlnQ0FDQUFjaUVBSUFWQkFXb2lCU0FJUncwQUN5QUFRUUJISUFGMElBSnlJUUlnQVVFQmFpSUJJQVJIRFFBTEN5QUtKQUFnQWd2NEFRRUNmeU1BUVJCcklnTWtBQUpBQWtBQ1FBSkFJQUJCLy93QVRBUkFJQUJCd0Q1R0RRRWdBRUhnM1FCR0RRRU1BZ3NnQUVHQS9RQkdEUUFnQUVHQTl3SkdEUUFnQUVIQXV3RkhEUUVMSUFGQkFXdEJBa2tOQVFzZ0FrVU5BU0FDUVg4MkFnQU1BUXNDZnlBRFFlakNBRFlDREVFQUN3Ui9RUUFGSUFNZ0F5Z0NERUVEYWtGOGNUWUNEQ0FES0FJTVFhQTlLQUlBUVFKMFFlREFBR29nQVd4QnBEMG9BZ0JCQlhScWFrRzBBV29MRUJVaUJFVUVRRUVBSVFRZ0FrVU5BU0FDUVhrMkFnQU1BUXNnQkNBQUlBRVFNQ0VBSUFJRVFDQUNJQUEyQWdBTElBQkZEUUFnQkJBSVFRQWhCQXNnQTBFUWFpUUFJQVFMbEFJQ0EzOEJmU01BSWdnaENpQUlJQUZCQW5SQkcycEJjSEZySWdna0FFRUJJUWtnQUNBQlFRRWdCQ0FDSUFNUUx5QUFJQWdnQWlBQkVKa0JJUXdnQ0NBQklBSWdCUkJZSUFjRVFDQUJRUUVnQVVFQlNoc2hCVU1BQUlBL0lBeVJsU0FHbENFR1FRQWhCd05BSUFBZ0IwRUNkQ0lMYWlBR0lBZ2dDMm9vQWdDeWxEZ0NBQ0FIUVFGcUlnY2dCVWNOQUFzZ0FDQUJRWDhnQkNBQ0lBTVFMd3NnQkVFQ1RnUkFJQUVnQkc0aUFFRUJJQUJCQVVvYklRSkJBQ0VKUVFBaEFRTkFJQUFnQVd3aEEwRUFJUWRCQUNFRkEwQWdDQ0FESUFkcVFRSjBhaWdDQUNBRmNpRUZJQWRCQVdvaUJ5QUNSdzBBQ3lBRlFRQkhJQUYwSUFseUlRa2dBVUVCYWlJQklBUkhEUUFMQ3lBS0pBQWdDUXZ6QlFJSWZ3ZDlJd0FpQkNFS0lBUWdBMEVDZEVFUGFrRndjU0lFYXlJRklnY2tBQ0FISUFScklna2tBQ0FGUVFBZ0EwRUJJQU5CQVVvYklnaEJBblFRQlNFSFFRQWhCQU5BSUFrZ0JFRUNkQ0lGYWlBQUlBVnFJZ1lxQWdBaURFTUFBQUFBWFRZQ0FDQUdJQXlMT0FJQUlBRWdCV3BCQURZQ0FDQUVRUUZxSWdRZ0NFY05BQXREQUFBQUFDRU1JQU5CQVhVZ0FrZ0VRRUVBSVFRRFFDQU1JQUFnQkVFQ2RHb3FBZ0NTSVF3Z0JFRUJhaUlFSUFoSERRQUxJQUt5UTgzTVREK1NRd0FBZ0Q4Z0RFTjlIWkFtWGtFQmMwVkJBQ0FNUXdBQWdFSmRHd1I5SUF3RklBQkJnSUNBL0FNMkFnQWdBRUVFYWtFQUlBTkJBaUFEUVFKS0cwRUNkRUVFYXhBRkdrTUFBSUEvQzVXVUlROUJBQ0VGUXdBQUFBQWhEQU5BSUFFZ0JVRUNkQ0lFYWdKL0lBOGdBQ0FFYWlvQ0FDSVFsSTRpRFl0REFBQUFUMTBFUUNBTnFBd0JDMEdBZ0lDQWVBc2lCallDQUNBRUlBZHFJQWF5SWcwZ0RaSTRBZ0FnRGlBUUlBMlVraUVPSUFJZ0Jtc2hBaUFNSUEwZ0RaU1NJUXdnQlVFQmFpSUZJQWhIRFFBTEN3SkFJQU5CQTJvZ0FrZ0VRQ0FIS2dJQUlRNGdBU0FCS0FJQUlBSnFOZ0lBSUF3Z0FySWlEQ0FNbEpJZ0RpQU1sSkloREF3QkN5QUNRUUZJRFFBZ0EwRUNJQU5CQWtvYklRc2dBQ29DQUNFUVFRQWhBd05BSUF4REFBQ0FQNUlpRHlBSEtnSUFraUVNSUE0Z0VKSWlEU0FObENFTlFRRWhCRUVBSVFVRFFDQVBJQWNnQkVFQ2RDSUdhaW9DQUpJaUVTQU1JQXdnRGlBQUlBWnFLZ0lBa2lJTUlBeVVJaEtVSUEwZ0VaUmVJZ1liSVF3Z0VpQU5JQVliSVEwZ0JDQUZJQVliSVFVZ0JFRUJhaUlFSUF0SERRQUxJQUFnQlVFQ2RDSUVhaW9DQUNFTklBUWdCMm9pQlNBRktnSUFJZ3hEQUFBQVFKSTRBZ0FnQVNBRWFpSUVJQVFvQWdCQkFXbzJBZ0FnRHlBTWtpRU1JQTRnRFpJaERpQURRUUZxSWdNZ0FrY05BQXNMUVFBaEJBTkFJQUVnQkVFQ2RDSUFhaUlDSUFJb0FnQkJBQ0FBSUFscUtBSUFJZ0JyY3lBQWFqWUNBQ0FFUVFGcUlnUWdDRWNOQUFzZ0NpUUFJQXdML0FJQkJIOGdBQ2dDSENJRElBTkJBbllpQW1zaEF3SkFJQUZGQkVBZ0F5RUNEQUVMSUFBZ0FDZ0NJQ0FEYWpZQ0lBc2dBQ0FDTmdJY0lBSkJnSUNBQkUwRVFDQUFLQUlnSVFFRFFBSkFJQUZCRjNZaUJVSC9BVWNFUUNBQlFSOTJJUUlnQUNnQ0tDSUJRUUJPQkVBZ0FDQUFLQUlFSUFBb0FoZ2lBeUFBS0FJSWFrc0VmeUFBSUFOQkFXbzJBaGdnQUNnQ0FDQURhaUFCSUFKcU9nQUFRUUFGUVg4TElBQW9BaXh5TmdJc0N5QUFLQUlrSWdFRVFDQUNRUUZySVFNRFFFRi9JUUlnQUNBQUtBSUVJQUFvQWhnaUJDQUFLQUlJYWtzRWZ5QUFJQVJCQVdvMkFoZ2dBQ2dDQUNBRWFpQURPZ0FBUVFBaEFpQUFLQUlrQlNBQkMwRUJheUlCTmdJa0lBQWdBQ2dDTENBQ2NqWUNMQ0FCRFFBTEN5QUFJQVZCL3dGeE5nSW9JQUFvQWh3aEFpQUFLQUlnSVFFTUFRc2dBQ0FBS0FJa1FRRnFOZ0lrQ3lBQUlBSkJDSFFpQWpZQ0hDQUFJQUZCQ0hSQmdQNy8vd2R4SWdFMkFpQWdBQ0FBS0FJVVFRaHFOZ0lVSUFKQmdZQ0FCRWtOQUFzTEMva2JBUmwvSXdBaUVDRW1JQWhCQUNBSVFRQktHeUlJSUFoQkIwcEJBM1FpSkdzaEZpQUFLQUlJSVJRQ1FDQU5RUUpIRFFBZ0FpQUJhMEd3M1FGcUxRQUFJaHdnRmtvRVFFRUFJUndNQVFzZ0ZpQWNheUlJSUFoQkIwcEJBM1FpSldzaEZnc2dFQ0FVUVFKMFFROXFRWEJ4SWdockloa2lFQ1FBSUJBZ0NHc2lHaUlRSkFBZ0VDQUlheUliSWhBa0FDQU5RUU4wSVJjZ0VDQUlheUlkSkFBQ1FBSkFBa0FnQVNBQ1NDSVRSUVJBSUFCQk5Hb2hIaUFBUVNCcUlTQWdBQ2dDTUNJaVFRRnJJUkVNQVFzZ0RrRURhaUVSSUFVZ0RtdEJCV3NnRFd3aEZTQUFLQUlnSWlBZ0FVRUJkR292QVFBaEVpQUJJUWdEUUNBU1FSQjBJUkFnR3lBSVFRSjBJaGhxSUJjZ0lDQUlRUUZxSWdWQkFYUnFMZ0VBSWhJZ0VFRVFkV3NpRUVFRGJDQU9kRUVEZEVFRWRTSWVJQmNnSGtvYk5nSUFJQmdnSFdvZ0ZTQUlRWDl6SUFKcWJDQVFiQ0FSZEVFR2RTQVhRUUFnRUNBT2RFRUJSaHRyTmdJQUlBVWlDQ0FDUncwQUN5QUFRVFJxSVI0Z0FFRWdhaUVnSUFBb0FqQWlJa0VCYXlFUklCTU5BUXNnRmtFQVNDRUZRUUVoRlFOQUlCVWdFU0FWYWtFQmRTSUlRUUZxSUFVYkloVWdDRUVCYXlBUklBVWJJaEZNRFFBTERBRUxJQUFvQWlBaUl5QUNRUUYwYWk4QkFDRUZJQUFvQWpRaEowRUJJUlVEUUNBUklCVnFRUUYxSWlFZ0ZHd2hLQ0FGSVJCQkFDRVNRUUFoRXlBQ0lRZ0RRQ0FRUVJCMFFSQjFJQ01nQ0VFQmF5SUlRUUYwYWk0QkFDSVFheUFOYkNBbklBZ2dLR3BxTFFBQWJDQU9kQ0lmUVFKMUlSZ2dIMEVFVGdSL0lCMGdDRUVDZEdvb0FnQWdHR29pR0VFQUlCaEJBRW9iQlNBWUN5QURJQWhCQW5RaUgyb29BZ0JxSVJnQ2Z3SkFJQk1OQUNBWUlCc2dIMm9vQWdCT0RRQkJBQ0VUUVFBZ0Z5QVhJQmhLR3d3QkMwRUJJUk1nR0NBRUlCOXFLQUlBSWg4Z0dDQWZTQnNMSUJKcUlSSWdBU0FJU0EwQUN5QVZJQ0ZCQVdvZ0VpQVdTaUlJR3lJVklDRkJBV3NnRVNBSUd5SVJUQTBBQ3d0QkFDRUlJQUVoQlFKQUlBRWdBazRpSXcwQUlCVkJBV3NnRkd3aElTQWdLQUlBSWg4Z0FVRUJkR292QVFBaEVDQWVLQUlBSVJnQ1FDQVZJQ0pJQkVBZ0ZDQVZiQ0VpSUFFaUNDRUZBMEFnRUVFUWRDRVJJQjhnQ0VFQmFpSVNRUUYwYWk0QkFDSVFJQkZCRUhWcklBMXNJaE1nR0NBSUlDSnFhaTBBQUd3Z0RuUWhFU0FUSUJnZ0NDQWhhbW90QUFCc0lBNTBJaFJCQW5VaEV5QVVRUVJPQkVBZ0hTQUlRUUowYWlnQ0FDQVRhaUlUUVFBZ0UwRUFTaHNoRXdzZ0VVRUNkU0VVSUJGQkJFNEVRQ0FkSUFoQkFuUnFLQUlBSUJScUloRkJBQ0FSUVFCS0d5RVVDeUFaSUFoQkFuUWlFV29nRXlBRElCRnFLQUlBSWg1QkFDQVZRUUZLRzJvaUV6WUNBQ0FSSUJwcUlCNGdGQ0FUYTJvaUVVRUFJQkZCQUVvYk5nSUFJQWdnQlNBZVFRQktHeUVGSUJJaUNDQUNSdzBBQ3d3QkN5QUJJaEVoQlFOQUlCQkJFSFFoRWlBWUlCRWdJV3BxTFFBQUlCOGdFVUVCYWlJSVFRRjBhaTRCQUNJUUlCSkJFSFZySUExc2JDQU9kQ0llUVFKMUlSUWdCQ0FSUVFKMEloTnFLQUlBSVJJZ0hrRUVUZ1JBSUJNZ0hXb29BZ0FnRkdvaUZFRUFJQlJCQUVvYklSUUxJQkpCQVU0RVFDQVRJQjFxS0FJQUlCSnFJaEpCQUNBU1FRQktHeUVTQ3lBVElCbHFJQlFnQXlBVGFpZ0NBQ0llUVFBZ0ZVRUJTaHRxSWhRMkFnQWdFeUFhYWlBZUlCSWdGR3RxSWhKQkFDQVNRUUJLR3pZQ0FDQVJJQVVnSGtFQVNoc2hCU0FJSWhFZ0FrY05BQXNMUVFBaENDQWpEUUFnQWlFUVFRQWhFd05BSUJvZ0VFRUJheUlRUVFKMEloSnFLQUlBUVFGMUlCSWdHV29vQWdCcUlRTUNmd0pBSUJNTkFDQURJQklnRzJvb0FnQk9EUUJCQUNFVFFRQWdGeUFESUJkSUd3d0JDMEVCSVJNZ0F5QUVJQkpxS0FJQUloSWdBeUFTU0JzTElBaHFJUWdnQVNBUVNBMEFDMEVRUVRBZ0NDQVdTaUlER3lFVlFTQkJ3QUFnQXhzaEZFRUFJUk1nQWlFUVFRQWhBd05BSUJvZ0VFRUJheUlRUVFKMEloRnFLQUlBSUJWc1FRWjFJQkVnR1dvb0FnQnFJUklDZndKQUlBTU5BQ0FTSUJFZ0cyb29BZ0JPRFFCQkFDQVhJQklnRjBnYklSRkJBQXdCQ3lBU0lBUWdFV29vQWdBaUF5QURJQkpLR3lFUlFRRUxJUU1nRVNBVGFpRVRJQUVnRUVnTkFBc2dDQ0FXVEVFRmRDQVZJQk1nRmtvaUF4c2lIU0FWSUJRZ0F4c2lGV3BCQVhZaENFRUFJUkFnQWlFU1FRQWhFd05BSUJvZ0VrRUJheUlTUVFKMEloRnFLQUlBSUFoc1FRWjFJQkVnR1dvb0FnQnFJUU1DZndKQUlCTU5BQ0FESUJFZ0cyb29BZ0JPRFFCQkFDRVRRUUFnRnlBRElCZElHd3dCQzBFQklSTWdBeUFFSUJGcUtBSUFJaEVnQXlBUlNCc0xJQkJxSVJBZ0FTQVNTQTBBQ3lBZElBZ2dFQ0FXU2lJREd5SVVJQWdnRlNBREd5SVZha0VCZGlFSVFRQWhFQ0FDSVJKQkFDRVRBMEFnR2lBU1FRRnJJaEpCQW5RaUVXb29BZ0FnQ0d4QkJuVWdFU0FaYWlnQ0FHb2hBd0ovQWtBZ0V3MEFJQU1nRVNBYmFpZ0NBRTROQUVFQUlSTkJBQ0FYSUFNZ0YwZ2JEQUVMUVFFaEV5QURJQVFnRVdvb0FnQWlFU0FESUJGSUd3c2dFR29oRUNBQklCSklEUUFMSUJRZ0NDQVFJQlpLSWdNYkloUWdDQ0FWSUFNYkloVnFRUUYySVFoQkFDRVFJQUloRWtFQUlSTURRQ0FhSUJKQkFXc2lFa0VDZENJUmFpZ0NBQ0FJYkVFR2RTQVJJQmxxS0FJQWFpRURBbjhDUUNBVERRQWdBeUFSSUJ0cUtBSUFUZzBBUVFBaEUwRUFJQmNnQXlBWFNCc01BUXRCQVNFVElBTWdCQ0FSYWlnQ0FDSVJJQU1nRVVnYkN5QVFhaUVRSUFFZ0VrZ05BQXNnRkNBSUlCQWdGa29pQXhzaUZDQUlJQlVnQXh0cVFRRjJJUkZCQUNFUUlBSWhFa0VBSVJNRFFDQWFJQkpCQVdzaUVrRUNkQ0lJYWlnQ0FDQVJiRUVHZFNBSUlCbHFLQUlBYWlFREFuOENRQ0FURFFBZ0F5QUlJQnRxS0FJQVRnMEFRUUFoRTBFQUlCY2dBeUFYU0JzTUFRdEJBU0VUSUFNZ0JDQUlhaWdDQUNJSUlBTWdDRWdiQ3lBUWFpRVFJQUVnRWtnTkFBc2dGQ0FSSUJBZ0Zrb2JJUkVnQWlFUVFRQWhDRUVBSVJNRFFDQUtJQkJCQVdzaUVFRUNkQ0lEYWlBRElCbHFLQUlBSUFNZ0dtb29BZ0FnRVd4QkJuVnFJaElnRWtFQUlCY2dFaUFYU0JzZ0VpQURJQnRxS0FJQVRpSVNHeUFUR3lJVklBTWdCR29vQWdBaUF5QURJQlZLR3lJRE5nSUFJQU1nQ0dvaENDQVNJQk55SVJNZ0FTQVFTQTBBQ3dzZ0JnSi9Ba0FDUUFKL0lBVWdBa0VCYXlJVFRnUkFJQUloRVNBY0lSQWdGaUFrYWd3QkN5QVhRUWhxSVFNZ0FpRVNBa0FDUUFOQUlDQW9BZ0FpRUNBU1FRRjBhaTRCQUNJVklCQWdFeUlSUVFGMGFpNEJBQ0lUYXlBV0lBaHJJaG9nRlNBUUlBRkJBWFJxTGdFQUloQnJiaUlkYkNBS0lCRkJBblFpR0dvaUdTZ0NBQ0lVYWlBUUlCVnJJQjFzSUJwcUlCQWdFMnRxSWhCQkFDQVFRUUJLRzJvaUV5QVlJQnRxS0FJQUloQWdBeUFESUJCSUcwNEVRQ0FQUVFFUUJnMENJQk5CQ0dzaEV5QVpLQUlBSVJRZ0NFRUlhaUVJQ3lBY0loQkJBVTRFUUNBUklBRnJRYkRkQVdvdEFBQWhFQXNnR1VFQUlCY2dFeUFYU0JzaUVqWUNBQ0FJSUJRZ0hHcHJJQkpxSUJCcUlRZ2dFQ0VjSUJFaUVrRUJheUlUSUFWS0RRQUxEQUVMSUJ4QkFFb05BZ3dEQ3lBV0lDUnFDeUVXSUJCQkFFd0VRQ0FSSVJJTUFnc2dFU0VTQ3lBUElCSWdBV3RCQVdvUUZpQUJhZ3dCQzBFQUN5SUROZ0lBUVFBZ0pTQUJJQU5JR3lFRkFrQUNRQ0FsUlEwQUlBRWdBMDROQUNBSElBOUJBUkFHTmdJQURBRUxJQWRCQURZQ0FBc2dEVUVCU2lFYklCWWdDR3NnQldvaUNDQWdLQUlBSWh3Z0VrRUJkR291QVFBaUR5QWNJQUZCQVhScUxnRUFJaE5yYmlFRlFRQWhBeUFCSUJKSUJFQWdEa0VEZENFWklCTWdEMnNnQld3Z0NHb2hDQ0FUSVJBZ0FTRVJBMEFnRUVFUWRDRURJQW9nRVVFQ2RHb2lEeUFQS0FJQUlCd2dFVUVCYWlJUlFRRjBhaTRCQUNJUUlBTkJFSFZySUFWc2FqWUNBQ0FSSUJKSERRQUxJQk1oRUNBQklSRURRQ0FRUVJCMElRTWdDaUFSUVFKMGFpSUZJQWdnSENBUlFRRnFJaEZCQVhScUxnRUFJaEFnQTBFUWRXc2lBeUFESUFoS0d5SURJQVVvQWdCcU5nSUFJQWdnQTJzaENDQVJJQkpIRFFBTFFRUkJBeUFOUVFGS0d5RWFRUUFnRFVFRGRHc2hIVUVBSVFNRFFDQVRRUkIwSVJBZ0NpQUJRUUowSWc5cUloRW9BZ0FnQTJvaEJRSkFJQndnQVVFQmFpSUlRUUYwYWk0QkFDSVRJQkJCRUhWcklBNTBJaFpCQWs0RVFFRUFJUlVnRVNBRklBVWdCQ0FQYWlnQ0FHc2lCVUVBSUFWQkFFb2JJZ1ZySWhRMkFnQWdEU0FXYkNFUUFrQWdEVUVDUncwQUlCWkJBa1lOQUNBSEtBSUFEUUFnQVNBR0tBSUFTQ0VWQ3dKQUlCQWdGV29pRUVFRGRDSVZRUUoxUVFBZ0ZrRUNSaHNnRUVGcmJHb2dHU0FBS0FJNElBRkJBWFJxTGdFQWFpQVFiQ0lXUVFGMWFpSUJJQlJxSWlBZ0VFRUVkRWdFUUNBQklCWkJBblZxSVFFTUFRc2dJQ0FRUVJoc1RnMEFJQUVnRmtFRGRXb2hBUXNnQ3lBUGFpSVdJQkJCQW5RZ0ZHb2dBV29pRkVFQUlCUkJBRW9iSUJCdVFRTjJJaEEyQWdBZ0RTQVFiQ0FSS0FJQUloUkJBM1ZLQkVBZ0ZpQVVJQnQxUVFOMUloQTJBZ0FMSUJZZ0VFRUlJQkJCQ0VnYkloQTJBZ0FnRENBUGFpQVJLQUlBSUFGcUlCQWdGV3hNTmdJQUlCRWdFU2dDQUNBZElCWW9BZ0JzYWpZQ0FBd0JDeUFSSUFVZ0JTQVhheUlCUVFBZ0FVRUFTaHNpQldzMkFnQWdDeUFQYWtFQU5nSUFJQXdnRDJwQkFUWUNBQXNnQlFSL0lBc2dEMm9pQVNBRklCcDJJaEJCQ0NBQktBSUFJZ0ZySWhFZ0VDQVJTQnNpRUNBQmFqWUNBQ0FNSUE5cUlCQWdGMndpQVNBRklBTnJUallDQUNBRklBRnJCVUVBQ3lFRElBZ2lBU0FTUncwQUN5QVNJUUVMSUFrZ0F6WUNBQ0FCSUFKSUJFQURRQ0FMSUFGQkFuUWlBR29pQXlBQUlBcHFJZ1FvQWdBZ0czVkJBM1UyQWdBZ0JFRUFOZ0lBSUFBZ0RHb2dBeWdDQUVFQlNEWUNBQ0FCUVFGcUlnRWdBa2NOQUFzTElDWWtBQ0FTQ3p3QkFYOGdBQ0FBS0FJY1FROTJJZ0UyQWlRZ0FDZ0NJQ0FCYmlJQVFYOXpRWUNBQW1wQkFDQUFRUUZxSWdCQmdJQUNheUlCSUFBZ0FVa2JhZ3VYQVFFRWZ5QUJJQUpJQkVBZ0JrRUJJQVpCQVVvYklRZ0RRRUVBSVFZZ0JDQUJRUUowYWlJSktBSUFJZ2RCQVU0RVFBTkFJQVVnQnhBSklRY2dBeUFBS0FJSUlBWnNJQUZxUVFKMGFpSUtJQW9xQWdBZ0I3SkRBQUFBUDVKQkFVRU9JQWtvQWdBaUIydDBzcFJEQUFDQU9KUkRBQUFBdjVLU09BSUFJQVpCQVdvaUJpQUlSdzBBQ3dzZ0FVRUJhaUlCSUFKSERRQUxDd3Z4QWdJSGZ3UjlJd0JCRUdzaUNTUUFJQWxDQURjRENBSjlJQVFFUUVNQW1CaytEQUVMSUFkQkFuUWlDRUdBM1FGcUtnSUFJUThnQ0VHUTNRRnFLZ0lBQ3lFUklBRWdBa2dFUUNBR1FRRWdCa0VCU2hzaENpQUZLQUlFUVFOMFFTQnFJUXNnQjBIVUFHd2dCRUVxYkdwQnNOb0JhaUVIQTBBZ0J5QUJRUlFnQVVFVVNCdEJBWFFpQkdvaERDQUhJQVJCQVhKcUlRMUJBQ0VFQTBBQ2Z5QUxJQVVvQWhScklBVW9BaHhuYXlJSVFROU9CRUFnQlNBTUxRQUFRUWQwSUEwdEFBQkJCblFRWFF3QkN5QUlRUUpPQkVBZ0JVR2czUUZCQWhBRElnWkJBWFZCQUNBR1FRRnhhM01NQVF0QmZ5QUlRUUZIRFFBYVFRQWdCVUVCRUFackN5RUdJQU1nQUNnQ0NDQUViQ0FCYWtFQ2RHb2lDQ0FKUVFocUlBUkJBblJxSWc0cUFnQWlFaUFQSUFncUFnQkRBQUFRd1plVWtpQUdzaUlRa2pnQ0FDQU9JQklnRUpJZ0VTQVFsSk00QWdBZ0JFRUJhaUlFSUFwSERRQUxJQUZCQVdvaUFTQUNSdzBBQ3dzZ0NVRVFhaVFBQzJzQkFuOENRRUdRK3dFb0FnQWlBQVJBSUFBUUNFR1Erd0ZCQURZQ0FBd0JDMEdVK3dFb0FnQWlBRVVOQUNBQUVBaEJsUHNCUVFBMkFnQUxRWmo3QVNnQ0FDSUJCRUFEUUNBQktBSUFFQWdnQVNnQ0JDRUFJQUVRQ0NBQUlnRU5BQXRCbVBzQlFRQTJBZ0FMQ3d1czZBRTNBRUdCQ0F2bkFRUUJBZ01GUm1GcGJHVmtJSFJ2SUdOeVpXRjBaU0JQVUZWVElHUmxZMjlrWlhJc0lHTnZaR1U2SUNWa0lDY2xjeWN1QUVaaGFXeGxaQ0IwYnlCa1pXTnZaR1VnVDNCMWN5QmtZWFJoTENCcGJuQjFkQ0FsY0NBbFpDd2diM1YwY0hWMElDVndJQ1ZrTGdCRFlXNG5kQ0JtY21WbElIVnVkSEpoWTJ0bFpDQmlkV1ptWlhJZ0pYQXVBQUFBQUFBQUFBOElCd1FMREFNQ0RRb0ZCZ2tPQVFBSkJnTUVCUWdCQWdlNGZwcDVtbmxtWnJoK00zTUFBQVlBQUFBRUFBQUFBd0FBQUFBQkFBQUFBUUFBQUFBQUFBQUFBZjhCL3dMK0F2NEQvUUFCQUFIL0F2OEMvZ1ArQXdCQjhRa0wxUUVDLy8vL0FBQUJBUUFCQUFFQUFBQUFBQUVBQUFBQUFBRUFBQUFCQUFBQUFBRC9BZ0VBQVFFQUFQLy9BQUFBQUFBQUFmOEFBZjhBL3dIK0F2NytBdjBDQS8zOEEvd0VCUHNGK3ZzRytRWUZDUGNBQUFFQUFBQUFBQUFBL3dFQUFBSC9BQUgvL3dIL0FnSC9BdjcrQXY0Q0FnUDlBQUVBQUFBQUFBQUJBQUVBQUFIL0FRQUFBZ0gvQXYvL0F2OENBdjhEL3Y3K0F3QUJBQUFCQUFIL0F2OEMvd0lEL2dQKy9nUUUvUVg5L0FiOEJnWDdDUHI3K1FrR0FBTUFCd01BQVFvQUFnWVNDZ3dFQUFJQUFBQUpCQWNFQUFNTUJ3Y0FRZEFMQzVJUUtxL1Z5Yy8vUUFBUkFHUC9ZUUVRL3FNQUp5dTlWdG4vQmdCYkFGYi91Z0FYQUlEOHdCallUZTMvM1A5bUFLZi82UDlJQVVuOENBb2xQZ0FBQUFBQUFJZkhQY2xBQUlBQWh2OGtBRFlCQVAxSUFqTWtSVVVNQUlBQUVnQnkveUFCaS8rZi9Cc1FlemdBQUFBQUFBQUFBR2dDRGNqMi95Y0FPZ0RTLzZ6L2VBQzRBTVgrNC8wRUJRUVZRQ01BQUFBQTVqN0d4UFAvQUFBVUFCb0FCUURoLzlYLy9QOUJBRm9BQndCai93ai8xUDlSQWk4R05BckhEQUFBQUFBQUFBQUE1RmNGeFFNQTh2L3MvL0gvQWdBWkFDVUFHUUR3LzduL2xmK3gveklBSkFGdkF0WURDQVc0QlFBQUFBQUFBQUFBbEd0bnhCRUFEQUFJQUFFQTl2L3EvK0wvNFAvcS93TUFMQUJrQUtnQTh3QTlBWDBCclFISEFRQUFBQUFBQUFBQXZRQ28vV2tDWjNkMUFHSC8wdnNJZERRQTNRQ285blJ1L1A4UkF1cnk1V2JRLy9ZQ2pQQ2xYYkQvaVFOMTd3WlRuZi9NQTRMdlprZVYvOGNEaS9Bbk81bi9nQU5oOHE0dXBmOEZBOC8wWGlLNS8yTUNvZmVZRnRML3FRR2grclFMQUNEK0gvWWY2aC9ZSDhJZnFCK0lIMklmT2g4S0g5Z2VvQjVpSGlJZTNCMlFIVUlkN2h5V0hEb2MyQnR5R3dvYm5Cb3FHclFaT2htOEdEd1l0aGN1RjZBV0VCWitGZWdVVGhTd0V4QVRiaExJRVI0UmRCREdEeFlQWkE2dURmZ01RQXlFQzhnS0NncEtDWW9JeGdjQ0J6NEdlQVd5Qk9vRElnTmFBcElCeWdBQUFEYi9idjZtL2Q3OEZ2eE8rNGo2d3ZuKytEcjRkdmUyOXZiMU9QVjg5TUR6Q1BOUzhweng2dkE2OEl6djR1NDQ3cEx0OE94UTdMTHJHT3VDNnZEcFlPblM2RXJveE9kRTU4Ym1UT2JXNVdUbDl1U081Q2preHVOcTR4TGp2dUp3NGlUaTN1R2U0V0RoS09IMjRNYmdudUI0NEZqZ1B1QW80QmJnQ3VBQzRBRGdzMk1BUnpnckhoVU1CZ0FBQUFESHBaQjhiV0JVUnowektpQVhEd2dBOGVIVHg3dXZwSm1PaEh0eWFXQllVRWhBT1RJc0ppRWRHQlFRREFrRkFnQlZDQUFBWUFnQUFIQUlBQUFBQUFBQUJBWVlCd1VBQUFJQUFBd2NLUTM4OXc4cUdRNEIvajRwOS9ZbFFmd0QrZ1JDQi9nUURpYjlJUUFBQUFBQUFBQUFEUlluRnd6L0pFQWIrdmtLTnlzUkFRRUlBUUVHOVVvMTkvUTNUUFFJL1FOZEcvd2FKenNEK0FJQVRRc0orQllzK2djb0NSb0RDZmtVWmZrRUEvZ3FHZ0R4SVVRQ0YvNDNMdjRQQS84VkVDbjZHejBuQmZVcVdBUUIvanhCQnZ6LyswazRBZmNUWGgzM0FBeGpCZ1FJN1dZdTh3TUNEUU1DQ2V0VVNPNzFMbWpxQ0JJbU1CY0E4RVpUNndzRjlYVVcrUG9YZGZRREEvaGZIQVQyRDAwODhmOEVmQUw4QXlaVUdPY0NEU29OSHhYOE9DNy8veU5QOHhQNVFWajM4aFFFVVRIakZBQkxBKzhGOXl4YytBSDlGa1VmK2w4cDlBVW5ReEQ4QVFENmVEZmM4eXg2Qk9oUkJRc0RCd0lBQ1FwWW9BZ0FBTkFJQUFBZ0NRQUFBQUFBQUF3alBGTnNoSjIwenVRUElEZE5aWDJYcjhuaEV5cENXWEtKb3JqUjVnd1pNa2hoZUpPc3lOOGFMRVZhY29lZnRNM2hEUlkxVUdxQ25MVE41QThaTEVCYWM0Nm94TjRUR0Q1U1pIaVJxTDdXRmg4eVQyZDRsNnJMNHhVZExVRnFmSmFyeE9BZU1VdGhlWTZsdXRIbEV4azBSbDEwajZiQTJ4b2lQa3RoZHBHbnd0a1pJVGhHVzNHUHBjVGZGU0l6U0dGMWthdkUzaFFkTWtOYWRaQ294ZDBXSHpCQ1gzV1NxTVRlR0NFelRYU0duclRJNEJVY1JsZHFmSldxd3RrYUlUVkFVM1dZcmN6aEd5SkJYMnlCbTY3UzRSUWFTR054ZzVxd3lOc2lLejFPWFhLYnNjM2xGeDAyWVh5S283UFI1UjRtT0ZsMmdaNnl5T2NWSFRFL1ZXK09vOEhlR3pCTlo0V2VzOFRYNkIwdlNtTjhsN0RHM08waEtqMU1YWG1icnMvaEhUVlhjSWlhcXJ6UTR4Z2VORlNEbHFhNnkrVWxNRUJVYUhhY3Njbm1VUXNLQ1FvSkNnbnZDTzhJQ2duOENCY0o3d2hJQ3hRS1dnay9DUW9KNGdqaUNPSUk0Z2lTQ0xjSkpBa2tDUW9KQ2drS0NTUUpKQWsvQ1RJSmtBek9DaVFKSkFrS0NlSUlyUWlmQ05VSWtnaWNDYW9KUHdsYUNWb0pXZ2xhQ1Q4Slp3a0tDWmNOOEF0UENKOEk0Z2ppQ09JSTd3Z0tDZFVJMGd4RkRCUUtXZ25IQ0swSW53aVNDSklJUWdnQUVBVVByUWc4Q2p3S1p3a0tDVm9KUHdrYUNHb01yQXcvQ2EwSStRbUNDU1FKQ2dsM0NLMElDZzJnRGFZS2tnalZDSndKTWdrL0NaOElOUWd5Q1hRSkZ3ay9DVm9KZEFsMENYUUpuQWsvQ2NNT0xRNkNDZDhKUHduaUNPSUkvQWlmQ0FBSXRneVpESmtLSGd1UENSY0ovQWo4Q09JSVR3aS9ET1FNd1FyMkNvOEoxUWpWQ01jSVR3ZzFDRGtMcFF0SkNqOEpad2t5Q1pJSXh3akhDRUlJbVF4OURFa0tGQXJpQ0lVSXh3aXRDSzBJWFFocURPNE10QXBuQ2VJSTRnamlDTzhJa2doQ0NFVU15QXljQ1EwSTd3akVDVDhKdHdtQ0NZVUlzdzNTREFvSmpBcFhDcW9KUHdsYUNTUUpUd2hmRGM4TjNndndDL3dJbmdldENPSUk0Z2ppQ0V3TkpnMG5DSDhLT1FzeUNYUUo0Z2lxQ2V3SnNBNmdEWjRIWkFwUkM5OEpXZ2svQ1p3SjFRalVDOGdNdEFwSUM3UUthZ2hQQ084SXVnakhDRzhPU1E3cEI3RUhaQXFNQ2hRS3hBa1hDVDhKaHd4VkRUSUpHZ2hJQzBnTEpBbTNDY2NJZHdnS0RTWU5IZ3ZjQ2hjSmFnamlDTzhJUWdnTkNCY0ovQWlGQ0hjSWhRZy9DVWtLakFxTUN2a0pad21DQ2EwSTFRaXRDSzBJSkFsMENTOEtqQXJlQzZ3TTlncElDNm9KR2dqOENBb0pNZ2xNQ2EwSWFnaFBDTzhJeEFucEN1a0tQQW9VQ2o4SlhBNkJEcm9JTGdlRkNNRUtwZ3B4Q3RFSm53anBDbGdNcGdyNUNSNEwwUW1GQ0ZvSnJRaUZDTlN5bElGc1lGVlNUMDA5T3prNE16RXdMU29wS0NZa0loOGVGUXdLQXdFQS8vWDA3T25oMmN1K3NLK2hsWWg5Y21aYlVVYzhOQ3NqSEJRVEVnd0xCUUN6aW95VWw1V1psNk4wUTFJN1hFaGtXVndBUWZBYkMrY0JFQUFBQUFCalFpUWtJaVFpSWlJaVUwVWtOQ0owWmtaRVJMQm1SRVFpUVZWRVZDUjBqWmlMcW9TN3VOaUpoUG1vdVl0b1ptUkVSTExhdWJtcTlOaTd1NnIwdTd2YmltZWJ1TG1KZExlYm1JaUUyYmk0cXFUWnE1dUw5S200dWFxazJOL2FpdGFQdk5xbzlJMkltNnFvaXR6Ymk2VGJ5dGlKcUxyMnVZdDB1ZHU1aW1Sa2htUm1Ja1JFWkVTb3k5M2FxS2VhaUdoR3BQYXJpWXVKbTlyYmkvLysvZTRPQXdJQkFQLysvTm9qQXdJQkFQLysrdEE3QkFJQkFQLys5c0pIQ2dJQkFQLzg3TGRTQ0FJQkFQLzg2N1JhRVFJQkFQLzQ0S3RoSGdRQkFQLys3SzFmSlFjQkFFSGdIUXZ1RGYvLy80TUdrZi8vLy8vLzdGMFBZUC8vLy8vL3dsTVpSOTMvLy8vL29ra2lRcUwvLy8vU2Zra3JPYTMvLy8vSmZVY3dPb0wvLy8rbWJrazVQbWpTLy8vN2UwRTNSR1NyL3dBQUFBQUFBQUFBK2dBREFBWUFBd0FEQUFNQUJBQURBQU1BQXdETkFRQUFJQUFLQUJRdVpBSFFDUUFBRUFzQUFKQU5BQURRRFFBQThBMEFBSkFPQUFEZ0RnQUFNQThBQUFjWEpqWkZWV1IwZzVPaXNzSFEzKzhOR1NrM1JWTmljSCtPbmF1N3k5enNEeFVpTXoxT1hHcCtpSmludWMzaDhBb1ZKREkvVDE5dWZvMmRyYjNOM2UwUkZDVXpPMDVaYTN1R2xxUzR6ZUR3Q2c4Z00wTlJZSENCanA2dHZjemM3QWdWSlROQlQySnhmb3FicUxQQTBkb01EeUkzUDA1WGJIYURsS2U1eTl2c0VCTWdKRGhQVzJ4MmlKcXJ1c3pjN1FzY0t6cEtXV2w0aDVhbHRNVFQ0dkVHRUNFdVBFdGNhM3VKbkttNXg5YmhDeE1lTERsS1dXbDVoNWlwdXNyYTZnd1RIUzQ1UjFoa2VJU1VwYmJIMk9rUkZ5TXVPRTFjYW51R21LZTV6Tjd0RGhFdE5UOUxXV3R6aEplcnZNN2Q4QWtRSFNnNFIxaG5kNG1hcTczTjN1MFFFeVF3T1V4WGFYYUVscWU1eXRyc0RCRWROa2RSWG1oK2lKV2t0c25kN1E4Y0x6NVBZWE9CanB1b3RNTFEzKzRJRGg0dFBrNWViMytQbjYvQXo5L3ZFUjR4UGs5Y2EzZUVrYUN1dnN6YzZ3NFRKQzA5VEZ0c2VZcWFyTDNOM3U0TUVoOHRQRXhiYTN1S21xdTd6TjNzRFJFZkt6VkdVMmR5ZzVXbnVjdmM3UkVXSXlvNlRsMXVmWXVicXJ6TzRQQUlEeUl5UTFOamM0T1NvckxCMGVEdkRSQXBRa2xXWDIrQWlaYWp0ODdoOFJFWkpUUS9TMXhtZDRTUW9LKy8xT2NUSHpGQlUyUjFoWk9ocnJ2STFlUHlFaDgwUkZobmRYNktsYU94d00vZjd4QWRMejFNV21wM2haT2hzTUhSNFBBUEZTTXlQVWxXWVc1M2dZMnZ4dHJ0U1E1dEMyMExiUXR0QzIwTGJRdHRDMjBMYlF0dEMyMExrd3VUQzIwTEhndVFEQTBNbkF2d0MvQUx3Z3ZDQzhJTGt3dVRDOElMbkF0SUN4NExIZ3VtQ2xBUHJnK2xDNGNNaHd4MkMvQUxIZ3N5REt3TWJRc2VDendLK1FuY0NtMEx2QTE5RE1JTEh3ekxDMGdMYlF0dEMyMExiUXRJQzBnTFNBdElDMGdMd1FxK0U3NFRkZ3YxRFRrTjhBc05ET2tLV0F4WURKd0xIZ3ZSQ2V3SndRcElDMHdSTlJDTUNzRUtuQXZDQzIwTEhndWxDOHNMYlF0dEMyMExiUXRJQzZZS0pBN0xDNXdMOEF2d0N6a0w5Z3J3QzVBTTV3dWxDOXNNMnd5bEMrNE1yd3RyRkpZVDdBa0tEY1lOT1ExOURCWU1NQTJsQzR3S1Z3cC9DdWtLSGd0eEN0a1ROaFFIRWt3Um5BbFJDK2NMaHd4aERIOEt0QXBJQ3g0TDZRb2VDNHdLTWd4SUM1TUxiUXR0QzIwTGJRdVRDNU1Ma3d1VEMyMExiUXVUQzVNTGt3dHFFSWNNcFFzZkRNSUxTQXRJQzIwTG5BczVDMlFMeXd1Y0M4SUxmUXc1QzdBT3NBNnNEQjhNcFF0SUMyMExTQXVjQzNZTDZRcnBDaDRMU0F0SUMyUUtEZyt1RDRjTU1neXNESFlMNXd1VEM1TUxEUXdlQytrSzZRcnBDdWtLRkFvRkQvQVBIUTI4RFJZTXRBckNDM1lMTWd3TkRCNExIZ3RYQ2xjS0hndjJDaHNVSGhPWkRBVVBjUTFoREZFTFZRMTdEWXdLRkFweENyUUtIZ3YyQ3NFS0RSRE5EdHNNV0F4dEMwZ0xTQXR0QytrS3RBcnBDclFLNlFvZUMwZ0w5Z3JaRTc0VDV3dlpEYXdNOEFzTkRJQUxId3hSQzdRS3RBcTBDaDRMNlFvOEN0VVExUkFzQzk4Smh3d3dEVEFOQXd3REREQU44QXNlQzFjS0ZBcW1Dc0VLOEF0a0MvWUtTQXUwQ244S1VRc2ZERTRNVGd5UURHRU04QXZDQzVNTEhnc1hFU29QYlF0SUN4NExTQXNlQ3g0TFNBdElDMGdMSGd0SUMyMExTQXNlQzZVTFpBdGtDNlVMcFF2d0N6SU1rQXhPRFBBTHdndWNDNXdMbkF0dEM3UUtoUkExRU80TUV3MXRDNU1MU0F1bEM2VUxIZ3ZwQ3JRS0hnc2VDeDRMNlFyd0Q2NFBId3pDQzIwTGJRdHRDMGdMYlF0dEN4NExIZ3NlQytrS1NBdmNDZ2NTM3hGaERIRU5od3lsQzFFTDNnc3lETFFLZndwL0NuOEt0QXJwQ293S05SQ3RFTTBPU1E2bUN0d0tTQXRJQzhJTG5BdHRDeDRMZndwL0N1a0tTQXQzRU9JTndRb2VDeDRMU0F0SUMwZ0xiUXR0QzBnTGJRdHRDMjBMa3d0SUN6WVVPUlBWQ0dnTnpRNlhEUk1OSGd2dURKY05UZ3hSQzV3SnR3bkJDbTBMZXcxbERqSU1mUXdkRGVjTGh3eUhES1VMa0F3TkRHMExiUXQvQ3V3SmdnbWxDOElMNlFycENyUUs2UW9lQzV3TDhBc2ZERTRNVGd4T0RCOE13Z3ZDQzRBTE9RdC9DcVlLM0FyQ0MyZ04yUTBkRGF3TThBdkNDNU1MYlF0SUN4NEx5d3VBQzFFTHdndkNDNXdMeXdzZkRQQUw4QXZDQzBnTEhndHRDMjBMU0F0UUQzOFB3Z3Q5REIwTmtBemJETnNNbHcxNERuRU5wZ3FGQ0p3SkZBb3ZDdUhNeWJpM3I1NmFtWWQzYzNGdWJXTmlYMDlFTkRJd0xTc2dIeHNTQ2dNQS8vdnI1dFRKeExhbnBxT1hpbnh1YUZwT1RFWkZPUzBpR0JVTEJnVUVBd0N2bEtDd3NxMnVwTEd1eExiR3dMWkVQa0k4U0hWVlduYUlsNDZnanBzQVFkY3JDOEFDQVdSbVprUkVKQ0pncEd1ZXViUzVpMlpBUWlRaUlnQUJJTkNMamIrWXVadG9ZS3RvcG1abVpvUUJBQUFBQUJBUUFGQnRUbXU1aTJkbDBOU05pNjJaZTJja0FBQUFBQUFBQVRBQUFBQUFBQUFnUklkN2QzZG5SV0pFWjNoMmRtWkhZb2FJbmJpMm1ZdUcwS2o0UzcyUGVXc2dNU0lpSWdBUkF0THJpM3U1aVdtR1lvZG90bVMzcTRaa1JrUkdRa0lpZzBDbVprUWtBZ0VBaHFabVJDSWlRb1RVOXA2TGEydFhabVRiZlhxSmRtZUVjb2VKYWF0cU1pS2sxbzJQdVpkNVo4QWlBQUFBQUFBQjBHMUt1NGI1bjRsbWJwcDJWMlYzWlFBQ0FDUWtRa1FqWUtSbVpDUUFBaUduaXE1bVpGUUNBbVJyZUhja3hSZ0EvLzc5OUF3REFnRUEvLzc4NENZREFnRUEvLzc3MFRrRUFnRUEvLzcwdzBVRUFnRUEvL3ZvdUZRSEFnRUEvLzd3dWxZT0FnRUEvLzd2c2xzZUJRRUEvL2pqc1dRVEFnRUFRYUF1QzdjQi8vLy9uQVNhLy8vLy8vL2paZzljLy8vLy8vL1ZVeGhJN1AvLy8vK1dUQ0UvMXYvLy83NTVUU3MzdWYvLy8vV0pSeXM3aS8vLy8vK0RRakpDYThMLy82WjBURGMxZmYvL0FBQUFBQUFBQUFCa0FBTUFLQUFEQUFNQUF3QUZBQTRBRGdBS0FBc0FBd0FJQUFrQUJ3QURBRnNCQUFBZ0FCQUFaaWFyQVhBUEFBQndFUUFBY0JVQUFMQVZBQURRRlFBQTBCWUFBQ0FYQUFCd0Z3QUFBQUFBQU9Cd0xBOERBZ0VBL3UzQWhFWVhCQUQvL09LYlBRc0NBRUhnTHd2MEFmcjE2c3RITWlvbUl5RWZIUndiR2hrWUZ4WVZGQk1TRVJBUERnME1Dd29KQ0FjR0JRUURBZ0VBQUFBQUFBQUFBRnpLdnRpMjM1cmluT1o0N0hyMHpQdzBBNFlMaUJOa0dXWWRTaUJDSjZRMStmZjI5ZlRxMHNySnlNV3VVanM0TnpZdUZnd0xDZ2tIQUVBQXk1WUExOE9tZlc1U0FBQUFBRXNZQUFCT0dBQUFlQUNBUUFEb25nb0E1Z0R6M2NDMUFHUUE4QUFnQUdRQXpUd0FNQUFncTFVQXdJQkFBTTJhWmpNQTFhdUFWU3NBNE1DZ2dHQkFJQUJrS0JBSEF3RUFBUDM2OU9uVXRwYURlRzVpVlVnOE1TZ2dHUk1QRFFzSkNBY0dCUVFEQWdFQTB0RE95OGZCdDZpT2FFbzBKUnNVRGdvR0JBSUFRZUF4Qy9NQjM4bTNwNWlLZkc5aVdFOUdQamd5TENjakh4c1lGUklRRGd3S0NBWUVBd0lCQUx5d200cDNZVU1yR2dvQXBYZFFQUzhqR3hRT0NRUUFjVDhBQUFBQUFIMHpHaElQREFzS0NRZ0hCZ1VFQXdJQkFNWnBMUllQREFzS0NRZ0hCZ1VFQXdJQkFOV2lkRk03S3lBWUVnOE1DUWNHQlFNQ0FPKzdkRHNjRUFzS0NRZ0hCZ1VFQXdJQkFQcmx2SWRXTXg0VERRb0lCZ1VFQXdJQkFQbnIxYm1jZ0dkVFFqVXFJUm9WRVEwS0FQNzU2ODZrZGswdUd4QUtCd1VFQXdJQkFQLzkrZS9jdjV4M1ZUa2xGdzhLQmdRQ0FQLzkrL2J0Mzh1em1IeGlTemNvSFJVUEFQLysvZmZjb21wREtod1NEQWtHQkFNQ0FFSGdNd3NSOGI2eWhGZEtLUTRBMzhHZGpHbzVKeElBUVlBMEM1Y0JnQURXS2dEcmdCVUE5TGhJQ3dENDFvQXFCd0Q0NGFwUUdRVUErK3pHZmpZU0F3RDY3dE9mVWlNUEJRRDY1OHVvZ0ZnMUdRWUEvTzdZdVpSc1J5Z1NCQUQ5OCtISHBvQmFPUjhOQXdEKzl1blV0NU50U1N3WENnSUEvL3J3MzhhbWdGbzZJUkFHQVFELysvVG4wcldTYmtzdUdRd0ZBUUQvL2ZqdTNjU2tnRnc4SXhJSUF3RUEvLzM1OHVYUXRKSnVUREFiRGdjREFRQkJvRFVMbHdHQkFNOHlBT3lCRkFEMXVVZ0tBUG5WZ1NvR0FQcmlxVmNiQkFENzZjS0NQaFFFQVByc3o2QmpMeEVEQVAvdzJiYURVU2tMQVFELy91bkpuMnM5RkFJQkFQLzU2YzZxZ0ZZeUZ3Y0JBUC82N3RtNmxHeEdKeElHQVFELy9QUGl5S2FBV2pnZURRUUJBUC84OWVmUnRKSnVUQzhaQ3dRQkFQLzkrTzNid3FPQVhUNGxFd2dEQVFELy92cng0czJ4a1c5UE14NFBCZ0lCQUVIQU5ndVhBWUVBeXpZQTZvRVhBUFc0U1FvQSt0ZUJLUVVBL09pdFZoZ0RBUDN3eUlFNER3SUEvZlRacEY0bUNnRUEvZlhpdllSSEd3Y0JBUDMyNTh1ZmFUZ1hCZ0VBLy9qcjFiT0ZWUzhUQlFFQS8vN3ozY0tmZFVZbERBSUJBUC8rK09yUXE0QlZNQllJQWdFQS8vNzY4Tnk5bFd0REpCQUdBZ0VBLy83NzgrUEpwb0JhTngwTkJRSUJBUC8rL1BicTFiZVRiVWtyRmdvRUFnRUFRZUEzQzVjQmdnRElPZ0RuZ2hvQTlMaE1EQUQ1MW9JckJnRDg2SzFYR0FNQS9mSExnemdPQWdEKzl0Mm5YaU1JQVFEKytlakJna0VYQlFFQS8vdnYwNkpqTFE4RUFRRC8rL1BmdW9OS0lRc0RBUUQvL1BYbXlwNXBPUmdJQWdFQS8vMzM2OWF6aEZRc0V3Y0NBUUQvL3ZydzM4U2ZjRVVrRHdZQ0FRRC8vdjMxNTlHd2lGMDNHd3NEQWdFQS8vNzkvTy9kd3A1MVRDb1NCQU1DQVFCQmdqa0xEd0lGQ1E0VUd5TXNOa0ZOV21oM2h3QkJvRGtMeFFIK01VTk5VbDFqeGdzU0dCOGtMZjh1UWs1WFhtalFEaFVnS2pOQy8xNW9iWEJ6ZHZnMVJWQllYMllBQUFBQUFBQUFBUUVCQWdNREF3SURBd01DQXdNREFBTU1EekF6UEQvQXc4elA4UFA4L3dFQUFBQUFBQUFBQXdBQUFBQUFBQUFDQUFBQUFRQUFBQWNBQUFBQUFBQUFCQUFBQUFNQUFBQUdBQUFBQVFBQUFBVUFBQUFDQUFBQUR3QUFBQUFBQUFBSUFBQUFCd0FBQUF3QUFBQURBQUFBQ3dBQUFBUUFBQUFPQUFBQUFRQUFBQWtBQUFBR0FBQUFEUUFBQUFJQUFBQUtBQUFBQlFCQjhUb0xMMERLUlJ0TS8xS0NXck5pb210Z2RRQUFuVDRBUUY0K0FNQUVQZ0NBN1Q0QVFJaytBQUFBQUFEQVREOEFBTTA5QUVHeE93dlZBdjhBL3dEL0FQOEEvd0QrQVFBQi93RCtBUDBDQUFIL0FQNEEvUU1BQWYvd0hRQUErQjBBQUFrZUFBQWFIZ0FBS1I0QUFEb2VBQUJTSGdBQVlCNEFBSE4xWTJObGMzTUFhVzUyWVd4cFpDQmhjbWQxYldWdWRBQmlkV1ptWlhJZ2RHOXZJSE50WVd4c0FHbHVkR1Z5Ym1Gc0lHVnljbTl5QUdOdmNuSjFjSFJsWkNCemRISmxZVzBBY21WeGRXVnpkQ0J1YjNRZ2FXMXdiR1Z0Wlc1MFpXUUFhVzUyWVd4cFpDQnpkR0YwWlFCdFpXMXZjbmtnWVd4c2IyTmhkR2x2YmlCbVlXbHNaV1FBZFc1cmJtOTNiaUJsY25KdmNnQUNBUUFaRndJQWZueDNiVmNwRXdrRUFnQUFBQUNBdXdBQWVBQUFBQlVBQUFBVkFBQUFBSnBaUHdBQUFBQUFBSUEvQUFDQVB4QWZBQUFEQUFBQUNBQUFBSGdBQUFBTEFBQUFRQjhBQURBZ0FBQmdJQUFBZ0FjQUFBTUFBQUJBSWdBQVlGWUFBSkJYQUFCSVdBQUFnQ0lBQUlnQkFBQ2dQZ0FBZ0Q4QUFCQkJBRUdTUGdzcEFRQUNBQU1BQkFBRkFBWUFCd0FJQUFvQURBQU9BQkFBRkFBWUFCd0FJZ0FvQURBQVBBQk9BR1FBUWRVK0M5SUJXbEJMUlQ4NE1TZ2lIUlFTQ2dBQUFBQUFBQUFBYm1SYVZFNUhRVG96TFNjZ0doUU1BQUFBQUFBQWRtNW5YVlpRUzBaQk96VXZLQjhYRHdRQUFBQUFmbmR3YUY5WlUwNUlRancyTHljZ0dSRU1BUUFBaG45NGNtZGhXMVZPU0VJOE5pOHBJeDBYRUFvQmtJbUNmSEZyWlY5WVVreEdRRGt6TFNjaEdnOEJtSkdLaEh0MWIybGlYRlpRU2tNOU56RXJKQlFCb3B1VWpvVi9lWE5zWm1CYVZFMUhRVHMxTGg0QnJLV2VtSStKZzMxMmNHcGtYbGRSUzBVL09DMFV5TWpJeU1qSXlNakd3Ynkzc3Eyb281NlpsSUZvQUVIQXdBQUxud1FJQUFnQUNBQUlBQkFBRUFBUUFCVUFGUUFZQUIwQUlnQWtBQUFBQUFBQUFHb2NqVGhTdXg0NkNHbmNPb0x0Vnp1Slk3STdBeW9GUEREY09UeTBQbmM4SEtPZVBOSHl4VHoraHZFOG02c1FQUVd0S2oyRXdrWTlVK1prUFJHSmdqMkhuNU05eTdLbFBkRyt1RDA2djh3OVZLL2hQUlNLOXowT0pRYysyZlFTUGw4eEh6NW8xeXMraXVNNFBqQlNSajZVSDFRK3YwZGlQbzdHY0Q2d2wzOCtVbHVIUG1BUGp6Nlk1WlkrZWR1ZVBuRHVwajdZRzY4KysyQzNQaEc3dno1R0o4Zyt0NkxRUG5ncTJUNlV1K0UrREZQcVB0N3Q4ajRHaWZzK3ZoQUNQeDlhQmo4a253by9VTjRPUHlzV0V6OUJSUmMvSldvYlAzT0RIei9PanlNLzVvMG5QM1I4S3o4L1dpOC9HU1l6UCtmZU5qK1pnem8vTXhNK1A4V01RVDkzNzBRL2Z6cElQeWR0U3ovT2hrNC81WVpSUC9Gc1ZEK09PRmMvYWVsWlAwVi9YRC82K1Y0L2MxbGhQNitkWXovQnhtVS96OVJuUHhISWFUL1NvR3MvYmw5dFAxQUViei8wajNBLzVnSnlQNzFkY3o4Zm9YUS92ODExUDFma2RqK3c1WGMvbDlKNFArT3JlVDl6Y25vL0p5ZDdQK2ZLZXorZFhudy9OZU44UDV4WmZUKzl3bjAvaGg5K1A5NXdmaitydDM0L3ovUitQeVlwZnorR1ZYOC92bnAvUDVhWmZ6L01zbjgvRk1kL1B4elhmeitDNDM4LzNleC9QN2J6ZnorSytIOC95UHQvUDliOWZ6OEgvMzgvcGY5L1Arai9mei85LzM4L0FBQ0FQK0FCQUFDSGlBZzcvLy8vL3dVQVlBQURBQ0FBQkFBSUFBSUFCQUFFQUFFQVFlekVBQXNHd0VFQUFJQkZBRUdBeFFBTHlUai8vMzgvanY5L1AycitmeitUL0g4L0IvcC9QOGoyZnovVzhuOC9NTzUvUDlib2Z6L0k0bjgvQjl4L1A1UFVmejlyekg4L2o4Ti9Qd0M2ZnorOXIzOC94NlIvUHgyWmZ6L0FqSDgvc0g5L1AreHhmejkyWTM4L1MxUi9QMjVFZnovZU0zOC9taUovUDZNUWZ6LzYvWDQvbmVwK1A0M1dmai9Md1g0L1ZxeCtQeTZXZmo5VGYzNC94bWQrUDRaUGZqK1VObjQvN3h4K1A1Z0NmaitQNTMwLzA4dDlQMmF2ZlQ5R2tuMC9kSFI5UC9GVmZUKzhObjAvMVJaOVB6ejJmRC95MUh3LzlySjhQMG1RZkQvcmJIdy8yMGg4UHhza2ZEK3AvbnMvaDloN1A3U3hlejh3aW5zLy9HRjdQeGM1ZXorQ0Qzcy9QZVY2UDBpNmVqK2lqbm8vVFdKNlAwZzFlaitVQjNvL01ObDVQeDJxZVQ5YWVuay82VWw1UDhnWWVULzU1bmcvZTdSNFAwNkJlRDl6VFhnLzZoaDRQN0xqZHovTnJYYy9PbmQzUC9rL2R6OEtDSGMvYnM5MlB5V1dkajh2WEhZL2pDRjJQenptZFQ5QXFuVS9sMjExUDBJd2RUOUI4blEvbExOMFB6dDBkRDgzTkhRL2gvTnpQeXl5Y3o4bWNITS9kaTF6UHhycWNqOFVwbkkvWkdGeVB3b2NjajhGMW5FL1Y0OXhQd0JJY1QvLy8zQS9WYmR3UHdKdWNEOEdKSEEvWXRsdlB4V09iejhnUW04L2hQVnVQeitvYmo5VFdtNC93QXR1UDRhOGJUK2xiRzAvSFJ4dFArL0tiRDhiZVd3L29TWnNQNERUYXorN2Yycy9VQ3RyUDBEV2FqK01nR28vTWlwcVB6WFRhVCtUZTJrL1RTTnBQMlRLYUQvWWNHZy9xQlpvUDlXN1p6OWdZR2MvU0FSblA0K25aajh6U21ZL051eGxQNWVOWlQ5WExtVS9kODVrUC9WdFpEL1VER1EvRXF0alA3RklZeit3NVdJL0VJSmlQOUVkWWovenVHRS9kMU5oUDF6dFlEK2tobUEvVGg5Z1AxdTNYei9MVGw4L251VmVQOVY3WGo5d0VWNC9icVpkUDlJNlhUK2F6bHcveG1GY1AxbjBXejlSaGxzL3JoZGJQM0tvV2orZE9Gby9Mc2haUHlkWFdUK0g1VmcvVDNOWVAzOEFXRDhYalZjL0dCbFhQNEtrVmo5V0wxWS9rN2xWUHpwRFZUOUx6RlEveDFSVVA2N2NVejhCWkZNL3YrcFNQK2x3VWo5LzlsRS9nbnRSUC9ML1VEL1BnMUEvR2dkUVA5S0pUei82QzA4L2tJMU9QNVFPVGo4SmowMC83UTVOUDBHT1REOEZEVXcvTzR0TFArRUlTei81aFVvL2d3SktQMzkrU1QvdStVZy96M1JJUHlUdlJ6L3RhRWMvS2VKR1A5cGFSajhBMDBVL20wcEZQNnpCUkQ4eU9FUS9MNjVEUDZJalF6K05tRUkvN3d4Q1A4aUFRVDhhOUVBLzVXWkFQeWpaUHovbFNqOC9HN3crUDh3c1BqLzNuRDAvblF3OVA3NTdQRDljNmpzL2RWZzdQd3JHT2o4ZE16by9yWjg1UDdzTE9UOUhkemcvVWVJM1A5cE1Oei9qdGpZL2F5QTJQM1NKTlQvOThUUS9CMW8wUDVQQk16K2dLRE0vTUk4eVAwTDFNVC9ZV2pFLzhiOHdQNDRrTUQrdmlDOC9WZXd1UDRGUExqOHlzaTAvYVJRdFB5ZDJMRDlyMXlzL056Z3JQNHVZS2o5bitDay96RmNwUDdxMktEOHlGU2cvTTNNblA3L1FKai9XTFNZL2VZb2xQNmZtSkQ5aFFpUS9xWjBqUDMzNElqL2ZVaUkvejZ3aFAwMEdJVDliWHlBLytMY2ZQeVVRSHovaVp4NC9NTDhkUHhBV0hUK0JiQncvaE1JYlB4b1lHejlEYlJvL0FNSVpQMUVXR1Q4MmFoZy9zYjBYUDhFUUZ6OW5ZeFkvbzdVVlAzWUhGVC9oV0JRLzVLa1RQMy82RWorelNoSS9nSm9SUCtmcEVEL29PQkEvaEljUFA3dlZEaitPSXc0Ly9uQU5Qd3ErREQrekNndy8rbFlMUDkraUNqOWo3Z2svaGprSlAwbUVDRCtzemdjL3J4Z0hQMVJpQmorYnF3VS9nL1FFUHc4OUJEODloUU0vRDgwQ1A0WVVBaitoV3dFL1lhSUFQNC9SL3o2blhmNCtEdW44UHNKeit6N0cvZmsrRzRmNFBzRVA5ejY2bC9VK0JoLzBQcWlsOGo2ZUsvRSs3TER2UHBFMTdqNlF1ZXcrNkR6clBwcS82VDZwUWVnK0ZjUG1QdDlENVQ0SXhPTStrVVBpUG56QzREN0lRTjgrZUw3ZFBvdzczRDRHdU5vKzVqUFpQaTZ2MXo3ZktkWSsrYVBVUG4wZDB6NXVsdEUrekE3UVBwZUd6ajdTL2N3K2ZYVExQcG5xeVQ0bllNZytLTlhHUHA5SnhUNkt2Y00rN0REQ1BzYWp3RDRaRnI4KzVvZTlQaTM1dXo3eGFibytNdHE0UHZGSnR6NHZ1YlUrN2llMFBpK1dzajd5QTdFK09YR3ZQZ1RlclQ1V1NxdytMN2FxUHBBaHFUNTZqS2MrNy9hbFB1OWdwRDU4eXFJK2x6T2hQa0Njbno1NkJKNCtSR3ljUHFIVG1qNlJPcGsrRnFHWFBqQUhsajdoYkpRK0tkS1NQZ3Mza1Q2SG00OCtuditOUGxGampENml4b28ra1NtSlBpQ01oejVRN29VK0lsQ0VQcGV4Z2o2d0VvRSszdVorUHFtbmV6N0RaM2crTHlkMVB1N2xjVDRFcEc0K2MyRnJQandlYUQ1aTJtUSs2SlZoUHM5UVhqNGFDMXMrek1SWFB1WjlWRDVyTmxFK1hlNU5QcitsU2o2U1hFYysyaEpFUHBmSVFEN09mVDArZ0RJNlBxN21OajVkbWpNK2pVMHdQa0lBTFQ1OXNpaytRbVFtUHBFVkl6NXV4aDgrMjNZY1B0b21HVDV0MWhVK21JVVNQbHMwRHo2NjRncyt0NUFJUGxRK0JUNlU2d0UrOEREOVBRYUs5ajF4NHU4OU16cnBQVStSNGozUDU5czl0VDNWUFFPVHpqM0E1OGM5OGp2QlBaeVB1ajNENHJNOWJEV3RQWnVIcGoxVjJaODlueXFaUFg1N2tqMzJ5NHM5Q3h5RlBZZlhmRDFHZG04OVhSUmlQZGF4VkQyNVRrYzlFT3M1UGVXR0xEMUFJaDg5TEwwUlBiSlhCRDIxNCswOFlCZlRQSFpLdUR3TGZaMDhNcStDUFByQlR6eitKQm84S2cvSk81bW5PenN1ZmRhNTBrWnh1NnZlNDd1bWpDZThnU2xkdk9GaWlieWdNS1M4N1AyK3ZMUEsyYnpnbHZTOE1iRUh2Wk1XRmIyTWV5SzlFK0F2dlI1RVBiMmxwMHE5blFwWXZmNXNaYjIrem5LOTZoZUF2UnZJaHIzdGQ0MjlYQ2VVdldQV21yMzloS0c5SmpPb3ZkbmdycjBSanJXOXlqcTh2Zjdtd3IycWtzbTl5RDNRdlZUbzFyMUtrdDI5cER2a3ZWM2s2cjF5alBHOTNUUDR2WnJhL3IxU3dBSysvQklHdmtkbENiNHl0d3krdWdnUXZ0MVpFNzZZcWhhKzZ2b1p2dEJLSGI1SG1pQytUdWtqdnVFM0o3NEFoaXErcHRNdHZ0TWdNYjZEYlRTK3RiazN2bVVGTzc2VFVENitPcHRCdmxybFJMN3dMa2krK1hkTHZuVEFUcjVkQ0ZLK3MwOVZ2bk9XV0w2YzNGdStLaUpmdmh0bllyNXRxMlcrSCs5b3Zpd3liTDZVZEcrK1ZMWnl2bXIzZGI3VE4zbStqWGQ4dnBhMmY3NTFlb0crUlJtRHZybTNoTDdRVllhK2lQT0h2dUdRaWI3YUxZdStjTXFNdnFSbWpyNTBBcEMrMzUyUnZ1UTRrNzZCMDVTK3RtMld2b0VIbUw3aW9KbSsxem1idmwvU25MNTVhcDYrSXdLZ3ZsNlpvYjRtTUtPK2ZjYWt2bUJjcHI3TzhhZSt4b2FwdmtjYnE3NVFyNnkrNEVLdXZ2WFZyNzZQYUxHK3JmcXl2azJNdEw1dUhiYStFSzYzdmpBK3ViN1B6YnErNmx5OHZvTHJ2YjZVZWIrK0h3ZkJ2aU9Vd3I2ZklNUytrYXpGdnZnM3g3N1R3c2krSWszS3Z1TFd5NzRUWU0yK3Rlak92c1Z3MEw1QytORytMWC9Udm9NRjFiNURpOWErYlJEWXZ2K1UyYjc1R051K1daemN2aDBmM3I1R29kKysweUxodnNHajRyNFFKT1MrdnFQbHZzd2k1NzQ0b2VpK0FCL3F2aVNjNjc2aUdPMitlcFR1dnFzUDhMNHppdkcrRWdUenZrWjk5TDdQOWZXK3FtMzN2dG5rK0w1WVcvcStLTkg3dmtkRy9iNjF1djYrT0JjQXY3dlFBTC9raVFHL3NrSUN2eVg3QXI4N3N3Ty85bW9FdjFNaUJiOVQyUVcvOVk4R3Z6aEdCNzhkL0FlL29yRUl2OGRtQ2IrTUd3cS84TThLdi9PREM3K1ROd3kvMGVvTXY2eWREYjhrVUE2L09BSVB2K2l6RDc4eVpSQy9HQllSdjVmR0ViK3dkaEsvWXlZVHY2N1ZFNytSaEJTL0RUTVZ2eC9oRmIvSWpoYS9DRHdYdjkzb0Y3OUlsUmkvU0VFWnY5enNHYjhFbUJxL3dFSWJ2dy90Rzcvd2xoeS9ZMEFkdjJqcEhiLytrUjYvSlRvZnY5emhINzhqaVNDLytpOGh2MS9XSWI5U2ZDSy8xQ0VqditQR0k3OS9heVMvcHc4bHYxeXpKYitkVmlhL2FQa212NytiSjcrZ1BTaS9DOThvdi85L0tiOTlJQ3EvZzhBcXZ4RmdLNzhuL3l1L3hKMHN2K2c3TGIrUzJTMi93M1l1djNrVEw3KzByeSsvYzBzd3Y3Zm1NTDkvZ1RHL3l4c3l2NW0xTXIvcVRqTy92ZWN6dnhLQU5ML29GelcvUDY4MXZ4WkdOcjl1M0RhL1JYSTN2NXdIT0w5eG5EaS94VEE1djViRU9iL21WenEvc3VvNnYveDhPNy9DRGp5L0E2QTh2OEV3UGIvNndEMi9yVkErdjl2ZlByK0RiaisvcGZ3L3YwQ0tRTDlURjBHLzRLTkJ2K1F2UXI5Z3UwSy9VMFpEdjc3UVE3K2VXa1MvOXVORXY4SnNSYjhGOVVXL3ZIeEd2K2dEUjcrSmlrZS9uUkJJdnlXV1NMOGdHMG0vanA5SnYyOGpTci9CcGtxL2hpbEx2N3lyUzc5akxVeS9lcTVNdndJdlRiLzZyazIvWWk1T3Z6bXRUcjkrSzArL002bFB2MVVtVUwvbW9sQy81QjVSdjFDYVViOG9GVksvYlk5U3Z4NEpVNzg3Z2xPL3cvcFR2N2R5Vkw4VzZsUy8zMkJWdnhMWFZiK3dURmEvdDhGV3Z5YzJWNzhBcWxlL1FoMVl2K3lQV0wvK0FWbS9lSE5adjFua1diK2lWRnEvVWNSYXYyWXpXNy9pb1Z1L3d3OWN2d3A5WEwrMzZWeS95RlZkdno3QlhiOFlMRjYvVjVaZXYvbi9Yci8vYUYrL2FORmZ2ek01WUw5aW9HQy84d1poditWc1liODYwbUcvOERaaXZ3aWJZcitBL21LL1dXRmp2NUxEWTc4c0pXUy9KWVprdjM3bVpMODNSbVcvVHFWbHY4VURacithWVdhL3piNW12MTRiWjc5TmQyZS9tdEpudjBRdGFMOUxoMmkvcnVCb3YyODVhYitMa1dtL0JPbHB2OWsvYXI4SmxtcS9sT3RxdjN0QWE3KzhsR3UvV2VocnYwODdiTCtnald5L1M5OXN2MDh3YmIrdGdHMi9aZEJ0djNVZmJyL2ZiVzYvb2J0dXY3c0liNzh1VlcrLytLQnZ2eHZzYjcrVk5uQy9aNEJ3djVESmNMOFBFbkcvNWxseHZ4T2hjYitYNTNHL2NTMXl2NkJ5Y3I4bXQzSy9BZnR5dnpJK2M3KzRnSE8vbE1KenY4UURkTDlKUkhTL0lvUjB2MUREZEwvU0FYVy9xRDkxdjlKOGRiOVF1WFcvSWZWMXYwVXdkcis5YW5hL2lLUjJ2NmJkZHI4V0ZuZS8yVTEzdisrRWQ3OVh1M2UvRWZGM3Z4MG1lTDk2V25pL0tvNTR2eXZCZUw5OTgzaS9JU1Y1dnhaV2ViOWNobm0vOHJWNXY5cmtlYjhTRTNxL21rQjZ2M050ZXIrZG1YcS9Gc1Y2djkvdmVyLzRHWHUvWVVON3Z4cHNlNzhpbEh1L2VydDd2eURpZTc4WENIeS9YQzE4di9CUmZML1RkWHkvQlpsOHY0YTdmTDlWM1h5L2MvNTh2OThlZmIrYVBuMi9vMTE5di9wN2ZiK2ZtWDIva3JaOXY5UFNmYjlpN24yL1B3bCt2MmtqZnIvaFBINi9wMVYrdjdwdGZyOGJoWDYveVp0K3Y4U3hmcjhOeDM2L290dCt2NFh2ZnIrMUFuKy9NaFYvdi93bWY3OFRPSCsvZGtoL3Z5ZFlmNzhrWjMrL2JuVi92d1dEZjcvb2ozKy9HWngvdjVXbmY3OWZzbisvZEx4L3Y5ZkZmNytGem4rL2dkWi92OGpkZjc5ZDVIKy9QZXAvdjJydmY3L2o4MysvcWZkL3Y3djZmNzhaL1grL3hQNS92N3YvZjcvNi8zOC9PZjUvUDZuNWZ6OUw4bjgvSHVoL1B5UGJmejlaeTM4L3diaC9QMXVqZno4b2kzOC9KM0IvUDFwU2Z6Ky9NWDgvV0E1L1B5WG9majhtdjM0L1hKTitQOGhrZmo5cE0zNC9RZjk5UDAvSWZUK1dqbjAvRkZKOVA4c1NmVCs4MEh3LzU0dDhQMDFFZkQvditYcy96YXg3UCtsY2V6OURDbnMvM2JSNlA3WmNlai9SQVhvL0xxUjVQODVEZVQreTRIZy8zSHA0UDB3U2VEOEVwM2MvQkRsM1AwL0lkai9rVkhZL3h0NTFQL1psZFQ5MTZuUS9SR3gwUDJYcmN6L2FaM00vbytGeVA4Slljajg1elhFL0NUOXhQelN1Y0QrN0duQS9vSVJ2UCtUcmJqK0tVRzQvazdKdFB3RVNiVC9WYm13L0VjbHJQN2NnYXovSmRXby9TY2hwUHprWWFUK2JaV2cvYjdCblA3cjRaajk4UG1ZL3VJRmxQMi9DWkQra0FHUS9XanhqUDVGMVlqOU1yR0UvanVCZ1Axa1NZRCt1UVY4L2tXNWVQd09aWFQ4SXdWdy9vT1piUDg4Sld6K1lLbG8vKzBoWlAvMWtXRCtmZmxjLzVaVldQOUNxVlQ5anZWUS9vYzFUUDR6YlVqOG41MUUvZGZCUVAzbjNUejgwL0U0L3EvNU5QOS8rVEQvVS9Fcy9qUGhLUHdyeVNUOVM2VWcvWmQ1SFAwZlJSai83d1VVL2hMQkVQK1djUXo4Z2gwSS9PbTlCUHpSVlFEOFRPVDgvMkJvK1A0ajZQRDhtMkRzL3RMTTZQemFOT1QrdlpEZy9Jam8zUDVNTk5qOEYzelEvZks0elAvbDdNaitDUnpFL0dSRXdQOExZTGo5L25pMC9WbUlzUDBna0t6OWE1Q2sva0tJb1ArdGVKejl4R1NZL0pkSWtQd21KSXo4alBpSS9kZkVnUHdTakh6L1NVaDQvNUFBZFB6MnRHei9oVnhvLzB3QVpQeG1vRnorMFRSWS9xdkVVUC8yVEV6K3lOQkkvek5NUVAxQnhEejlDRFE0L3BLY01QM3hBQ3ovTjF3ay9tbTBJUCtrQkJ6KzlsQVUvR1NZRVB3TzJBajkrUkFFL0hLUC9QbTY2L0Q3Nnp2ayt5dUQyUHVUdjh6NVIvUEErR2didVBrY042ejdnRWVnKzdSUGxQbmNUNGo2SEVOOCtKQXZjUGxnRDJUNHErZFUrcE96U1BzM2R6ejZ2ek13K1VybkpQcitqeGo3K2k4TStHSExBUGhaV3ZUNEFPTG8rNEJlM1ByMzFzejZoMGJBK2xhdXRQcUtEcWo3UFdhYytKeTZrUHJJQW9UNTUwWjAraGFDYVB0OXRsejZQT1pRK29BT1JQaHJNalQ0Rms0bythMWlIUGxZY2hEN04zb0ErdGo5N1BoQy9kRDY3TzI0K3liVm5QazB0WVQ1Wm9sbysveFJVUGxHRlRUNWo4MFkrUmw5QVBnM0pPVDdLTURNK2tKWXNQbkw2SlQ2Q1hCOCswcndZUG5ZYkVqNS9lQXMrQWRRRVBoMWMvRDF5RGU4OUtiemhQV1pvMUQxT0VzYzlDTHE1UGJoZnJEMkVBNTg5a3FXUlBRZEdoRDBTeW0wOWVnVlRQWkUrT0Qya2RSMDkvS29DUGNxOXp6eFdJNW84WVE1SlBNV251enM5ZWxhNkNVYnh1eExkWTd4UWlxZThRU1Rkdk9OZENiMGpLQ1M5bHZBK3ZmSzJXYjNxZW5TOUdwNkh2VUw5bEwzSVdxSzlocmF2dlZjUXZiMFdhTXE5bTczWHZjTVE1YjFwWWZLOVphLy92VXA5QnI1b0lRMisrc01UdnUxa0dyNHVCQ0crcktFbnZsTTlMcjRRMXpTKzBtNDd2b1lFUXI0Wm1FaStlU2xQdnBTNFZiNVdSVnkrcnM5aXZvbFhhYjdXM0crK2dGOTJ2bmpmZkw1VXJvRytnZXVFdmpnbmlMNXlZWXUrSkpxT3ZrWFJrYjdOQnBXK3N6cVl2dTVzbTc1MG5aNitQY3lodmtENXBMNXpKS2krejAycnZrbDFycjdhbXJHK2VMNjB2aHZndDc2Ni83cStTeDIrdnNjNHdiNGxVc1MrVzJuSHZtRit5cjR3a2MyK3ZLSFF2Z0N3MDc3eHU5YStoOFhadnJyTTNMNkIwZCsrMDlQaXZxblQ1Yjc2ME9pK3ZjdnJ2dXJEN3I1NHVmRytZS3owdnBxYzk3NGNpdnErMzNUOXZtMHVBTDhEb1FHL0xSSUR2K2FCQkw4czhBVy8rbHdIdjB6SUNMOGVNZ3EvYkpvTHZ6SUJEYjlzWmc2L0Y4b1B2eTBzRWIrc2pCSy9rT3NUdjlWSUZiOTJwQmEvY2Y0WHY4QldHYjlpclJxL1VRSWN2NHBWSGI4SnB4Ni95L1lmdjh4RUliOEprU0svZk5zanZ5UWtKYi85YWlhL0FyQW52ekR6S0wrRU5DcS8rbk1ydjQreExMOC83UzIvQnljdnYrTmVNTC9RbERHL3lzZ3l2ODc2TTcvYUtqVy82Rmcydi9lRU43OENyemkvQjljNXZ3UDlPci94SUR5L3owSTl2NXBpUHI5UGdEKy82WnRBdjJpMVFiL0d6RUsvQWVKRHZ4ZjFSTDhEQmthL3hCUkh2MVloU0wrMkswbS80VE5LdjlRNVM3K05QVXkvQ1Q5TnYwUStUcjg5TzArLzhEVlF2MW91VWI5NUpGSy9TaGhUdjhvSlZMLzMrRlMvenVWVnYwM1FWcjl3dUZlL041NVl2NXlCV2IrZ1lscS9Qa0ZidjNVZFhMOUI5MXkvb3M1ZHY1U2pYcjhVZGwrL0lrWmd2N29UWWIvWjNtRy9mNmRpdjZsdFk3OVVNV1MvZnZKa3Z5YXhaYjlKYldhLzVTWm52L2pkWjcrQWttaS9lMFJwditqemFiL0RvR3EvREV0cnY4RHlhNy9lbDJ5L1pEcHR2MURhYmIrZ2QyNi9VeEp2djJhcWI3L1pQM0MvcWRKd3Y5VmljYjliOEhHL09udHl2M0VEYzcvOWlITy8zZ3QwdnhHTWRMK1dDWFcvYTRSMXY0LzhkYjhBY25hL3ZlUjJ2OFpVZDc4WXduZS9zaXg0djVPVWVMKzcrWGkvS0Z4NXY5bTdlYi9OR0hxL0FuTjZ2M25LZXI4dkgzdS9KSEY3djFqQWU3L0pESHkvZGxaOHYxK2RmTCtDNFh5LzRDSjl2M2RoZmI5SG5YMi9UOVo5djQ0TWZyOEVRSDYvc0hCK3Y1S2VmcitweVg2LzlmRit2M1VYZjc4cE9uKy9FRnAvdnl0M2Y3OTRrWCsvK0toL3Y2cTlmNytQejMrL3BkNS92KzNxZjc5bTlIKy9FZnQvdiszK2Y3L3EvMzgvNWZoL1A2Ym1mejh0eVg4L2ZLQi9QNVZzZno5NUxYOC9MT04rUDdHTmZqOExMWDQvUDhGOVAxSktmVDlJeUh3L0tEdDhQL2VpZXorOS8zby9nRkY2UDBpWWVUOGUxSGcvQ1FWNFB4TXJkejlHUm5ZL3JGWjFQMDVjZEQ4NFYzTS9ka2R5UHhNdGNUOGNDSEEvbnRodVA2V2ViVDlBV213L2ZndHJQMnV5YVQ4WlQyZy9sdUZtUC9KcFpUOCs2R00vaTF4aVArckdZRDl0SjE4L0puNWRQeWpMV3orRkRsby9VMGhZUDZONFZqK0xuMVEvSUwxU1AzYlJVRCtqM0U0L3ZkNU1QOXZYU2o4VHlFZy9mSzlHUHk2T1JEOUJaRUkvempGQVArejJQVCswc3pzL1FtZzVQNjBVTno4UXVUUS9obFV5UHlucUx6OFZkeTAvWmZ3cVB6VjZLRCtoOENVL3hsOGpQOERISUQrc0tCNC9xWUliUDlUVkdEOUtJaFkvS21nVFA1T25FRCtrNEEwL2V4TUxQemxBQ0QvOVpnVS81NGNDUHkxRy96NWJjZmsrbDVIelBpU243VDVGc3VjK1BMUGhQa3lxMno2Nmw5VSt5WHZQUHI1V3lUN2ZLTU0rY1BLOFByZXp0ajc3YkxBK2dSNnFQcExJb3o1emE1MCtiQWVYUHNXY2tEN0hLNG8rdWJTRFBzZHZlajRoYTIwK0VWeGdQaWxEVXo3OUlFWStJUFk0UGliREt6NmtpQjQrTFVjUlBsZi9BejV1WSswOXdyM1NQZG9PdUQzZVY1MDkrNW1DUGJ5c1R6MWxIQm85bVFySlBDcW5PenpCZU5hNkxVUnh2RmZYNDd4TWdTZTlsQTlkdlJWS2liMWFCcVM5YmJ1K3ZTSm8yYjFPQy9TOTQxRUh2aStZRkw3MzF5RytwUkF2dnFaQlBMNWtha20rVFlwV3ZzMmdZNzVRclhDK1JhOTl2ZzFUaGI2ZXlJdStEVGlTdmhLaG1MNW1BNSsrdjE2bHZ0aXlxNzVwLzdHK0swUzR2dGlBdnI0cXRjUysyK0RLdnFVRDBiNUZIZGUrZFMzZHZ2RXo0NzUyTU9tK3dDTHZ2bzBLOWI2YjUvcSswMXdBdnpoQUE3L2JIUWEvbS9VSXYxckhDNy8za2c2L1ZGZ1J2MUFYRkwvTnp4YS9ySUVadjlBc0hMOGEwUjYvYlc0aHY2c0VKTCsza3lhL2RCc3B2OGViSzcrVEZDNi91NFV3dnlidk1yKzNVRFcvVmFvM3YrUDdPYjlLUlR5L2JvWSt2emUvUUwrTDcwSy9VeGRGdjNVMlI3L2FURW0vYTFwTHZ4QmZUYit6V2srL1BrMVJ2NW8yVTcrekZsVy9jdTFXdjhXNldMK1ZmbHEvMERoY3YyTHBYYjg0a0YrL1FDMWh2MmZBWXIrY1NXUy96c2hsditzOVo3L2pxR2kvcHdscXZ5ZGdhNzlVckd5L0grNXR2M29sYjc5WVVuQy9xM1J4djJlTWNyOS9tWE8vNTV0MHY1V1RkYjkrZ0hhL2xtSjN2OVE1ZUw4dkJubS9uc2Q1dnhkK2VyK1VLWHUvRGNwN3YzcGZmTC9WNlh5L0dHbDl2ejdkZmI5QVJuNi9IS1Irdjh6MmZyOU5QbisvbkhwL3Y3YXJmNytaMFgrL1EreC92N1Q3ZjcrbS8zOC9sT04vUDV5YWZ6L01KSDgvT0lKK1AvMnlmVDgvdDN3L0tvOTdQL002ZWovVXVuZy9FUTkzUC9ZM2RUL1ZOWE0vQ0FseFAvR3hiai81TUd3L2tJWnBQeSt6Wmo5VHQyTS9oSk5nUDA1SVhUOUYxbGsvQXo1V1B5dUFVajlsblU0L1hwWktQOHhyUmo5cUhrSS8rYTQ5UDBBZU9UOE5iVFEvTXB3dlA0ZXNLai9ybmlVL1AzUWdQMjB0R3o5aHl4VS9EVThRUDJpNUNqOXJDd1UvTG96K1B0M1U4ajd4OHVZK2YramFQcWEzemo2SVlzSStUdXUxUGlwVXFUNVJuNXcrL2M2UFBtM2xnajdPeVdzK1lwOVJQakJRTno3VDRCdys4VlVDUG1Kb3p6MThBSm85SlB0SVBSdWt1enp6ZDFhN1pEM3h2THZBWTcxblhhZTlGTDNjdlFQN0NMNXpmeU8rTk9jOXZxUXRXTDRtVG5LK0VpS0d2b2tGazc0MHo1KysxWHlzdmpNTXViNGFlOFcrVzhmUnZzM3UzYjVRNyttK3g4YjF2cEM1QUw4bWVRYS9KQ0VNdjQyd0ViOW1KaGUvdW9FY3Y1akJJYjhWNVNhL1N1c3J2MWJUTUw5Ym5EVy9nMFU2di8zTlByLzhORU8vdkhsSHYzMmJTNytFbVUrL0gzTlR2NkVuVjc5anRscS94aDVldnpCZ1liOFBlbVMvMkd0bnZ3YzFhcjhmMVd5L3FVdHZ2emVZY2I5aXVuTy95YkYxdnhaK2Q3LzJIbm0vSVpSNnYxWGRlNzlaK255Lyt1cDl2dzZ2ZnI5MFJuKy9EN0Yvdjg3dWY3Ly8vLy8vLy8vLy8vLy8vLy8vLy8vL0FBQUFBQUFBQUFBcEFDa0FLUUJTQUZJQWV3Q2tBTWdBM2dCQjJ2MEFDNWdCS1FBcEFDa0FLUUI3QUhzQWV3Q2tBS1FBOEFBS0FSc0JKd0VwQUNrQUtRQXBBQ2tBS1FBcEFDa0Fld0I3QUhzQWV3RHdBUEFBOEFBS0FRb0JNUUUrQVVnQlVBRjdBSHNBZXdCN0FIc0Fld0I3QUhzQThBRHdBUEFBOEFBeEFURUJNUUUrQVQ0QlZ3RmZBV1lCYkFId0FQQUE4QUR3QVBBQThBRHdBUEFBTVFFeEFURUJNUUZYQVZjQlZ3RmZBVjhCY2dGNEFYNEJnd0VBUVlEL0FBdTRCQ2dIQndjSEJ3Y0hCd2NIQndjSEJ3Y0hCd2NIQndjSEJ3Y0hCd2NIQndjSEJ3Y0hCd2NIQndjSEtBOFhIQjhpSkNZbktTb3JMQzB1THk4eE1qTTBOVFkzTnprNk96dzlQajgvUVVKRFJFVkdSMGNvRkNFcE1EVTVQVUJDUlVkSlMweE9VRkpWVjFsYlhGNWdZbVZuYVd0c2JuQnlkWGQ1ZTN4K2dDZ1hKek04UTBsUFUxZGJYbUZrWm1scmIzTjJlWHgrZ1lPSGk0NlJsSmFabTUranBxbXNyckd6SXh3eFFVNVpZMnR5ZUg2RWlJMlJsWm1mcGF1d3RMbTl3TWZOMDlqYzRlWG83L1g3RlNFNlQyRndmWW1VbmFhdXRyM0R5Yy9aNCt2eit4RWpQMVpxZTR1WXBiRzd4YzdXM3VidCtoa2ZOMHRiYVhXQWlwS2FvYWl1dExtK3lORFgzdVhyOFBYL0VDUkJXVzZBa0ordHVjVFAyZUxxOHZvTEtVcG5nSmVzdjlIaDhmOEpLMDl1aXFPNnorUDJEQ2RIWTN1UXBMYkcxdVR4L1Frc1VYR09xTURXNi84SE1WcC9vTC9jOXdZelg0YXF5K29ITDFkN203alU3UVkwWVltdTBQQUZPV3FYd09jRk8yK2V5dk1GTjJlVHUrQUZQSEdoenZnRVFYcXY0QVJEZjdicUFBQUFBQUFBQUFEZzRPRGc0T0RnNEtDZ29LQzV1Ym15c3FpR1BTWGc0T0RnNE9EZzRQRHc4UERQejgvR3hyZVFRaWlnb0tDZ29LQ2dvTG01dWJuQndjRzN0NnlLUUNidzhQRHc4UER3OE0vUHo4L016TXpCd2JTUFFpaTV1Ym01dWJtNXVjSEJ3Y0hCd2NHM3Q2eUtRU2ZQejgvUHo4L1B6OHpNek16SnljbTh2TENOUWlqQndjSEJ3Y0hCd2NIQndjSEN3c0s0dUsyTFFTZk16TXpNek16TXpNbkp5Y25HeHNhN3U2K01RaWdBUWNLREFRdTVLV0FBd0FBZ0FZQUJJQUNBQU9BQVFBR2dBVUFBb0FBQUFXQUJ3QUVJQUdnQXlBQW9BWWdCS0FDSUFPZ0FTQUdvQVVnQXFBQUlBV2dCeUFFUUFIQUEwQUF3QVpBQk1BQ1FBUEFBVUFHd0FWQUFzQUFRQVhBQjBBRVlBSGdBMkFBNEFaZ0JPQUNZQVBnQVdBRzRBVmdBdUFBWUFYZ0IyQUVFQUdRQXhBQWtBWVFCSkFDRUFPUUFSQUdrQVVRQXBBQUVBV1FCeEFFTUFHd0F6QUFzQVl3QkxBQ01BT3dBVEFHc0FVd0FyQUFNQVd3QnpBRVVBSFFBMUFBMEFaUUJOQUNVQVBRQVZBRzBBVlFBdEFBVUFYUUIxQUVjQUh3QTNBQThBWndCUEFDY0FQd0FYQUc4QVZ3QXZBQWNBWHdCM0FFQkFHRUF3UUFoQVlFQklRQ0JBT0VBUVFHaEFVRUFvUUFCQVdFQndRRUpBR2tBeVFBcEFZa0JLUUNKQU9rQVNRR3BBVWtBcVFBSkFXa0J5UUVSQUhFQTBRQXhBWkVCTVFDUkFQRUFVUUd4QVZFQXNRQVJBWEVCMFFFWkFIa0EyUUE1QVprQk9RQ1pBUGtBV1FHNUFWa0F1UUFaQVhrQjJRRUZBR1VBeFFBbEFZVUJKUUNGQU9VQVJRR2xBVVVBcFFBRkFXVUJ4UUVOQUcwQXpRQXRBWTBCTFFDTkFPMEFUUUd0QVUwQXJRQU5BVzBCelFFVkFIVUExUUExQVpVQk5RQ1ZBUFVBVlFHMUFWVUF0UUFWQVhVQjFRRWRBSDBBM1FBOUFaMEJQUUNkQVAwQVhRRzlBVjBBdlFBZEFYMEIzUUVDQUdJQXdnQWlBWUlCSWdDQ0FPSUFRZ0dpQVVJQW9nQUNBV0lCd2dFS0FHb0F5Z0FxQVlvQktnQ0tBT29BU2dHcUFVb0FxZ0FLQVdvQnlnRVNBSElBMGdBeUFaSUJNZ0NTQVBJQVVnR3lBVklBc2dBU0FYSUIwZ0VhQUhvQTJnQTZBWm9CT2dDYUFQb0FXZ0c2QVZvQXVnQWFBWG9CMmdFR0FHWUF4Z0FtQVlZQkpnQ0dBT1lBUmdHbUFVWUFwZ0FHQVdZQnhnRU9BRzRBemdBdUFZNEJMZ0NPQU80QVRnR3VBVTRBcmdBT0FXNEJ6Z0VXQUhZQTFnQTJBWllCTmdDV0FQWUFWZ0cyQVZZQXRnQVdBWFlCMWdFZUFINEEzZ0ErQVo0QlBnQ2VBUDRBWGdHK0FWNEF2Z0FlQVg0QjNnRURBR01Bd3dBakFZTUJJd0NEQU9NQVF3R2pBVU1Bb3dBREFXTUJ3d0VMQUdzQXl3QXJBWXNCS3dDTEFPc0FTd0dyQVVzQXF3QUxBV3NCeXdFVEFITUEwd0F6QVpNQk13Q1RBUE1BVXdHekFWTUFzd0FUQVhNQjB3RWJBSHNBMndBN0Fac0JPd0NiQVBzQVd3RzdBVnNBdXdBYkFYc0Iyd0VIQUdjQXh3QW5BWWNCSndDSEFPY0FSd0duQVVjQXB3QUhBV2NCeHdFUEFHOEF6d0F2QVk4Qkx3Q1BBTzhBVHdHdkFVOEFyd0FQQVc4Qnp3RVhBSGNBMXdBM0FaY0JOd0NYQVBjQVZ3RzNBVmNBdHdBWEFYY0Ixd0VmQUg4QTN3QS9BWjhCUHdDZkFQOEFYd0cvQVY4QXZ3QWZBWDhCM3dFQUFJQS9BQUFBZ0dQNmZ6Ky9kVmE4aStsL1B3cHgxcng1elg4LzU4NGd2UyttZno4NlhsYTlyM04vUHhQeWhiMzVOWDgvS3ErZ3ZSTHRmajh6WmJ1OS9aaCtQd1FUMXIyOE9YNC9jN2Z3dlZYUGZUK29xQVcreTFsOVA3dnZFcjRsMlh3L1hEQWd2bWROZkQvMWFTMittTFo3UC9PYk9yNitGSHMvd3NWSHZ1Sm5lai9ONWxTK0NiQjVQNEwrWWI0ODdYZy9UUXh2dm9RZmVEK2NEM3krNmtaM1ArNkRoTDUzWTNZL1B2cUt2aloxZFQ5MWFwRytNSHgwUDB6VWw3NXhlSE0vZWplZXZnTnFjaiszazZTKzlGQnhQN3pvcXI1UExYQS9RVGF4dmlIL2JqOEJmTGUrZHNadFA3UzV2YjVlZzJ3L0ZlL0R2dWMxYXovZUc4cStIdDVwUDhrLzBMNFNmR2cva2xyV3Z0UVBaei96YTl5K2RKbGxQNnB6NHI0QkdXUS9jWEhvdm8yT1lqOEhaZTYrS1BwZ1B5ZE85TDdtVzE4L2tDejZ2dGV6WFQ4QUFBQy9Ed0pjUHh2a0FyK2dSbG8vZDhJRnY1NkJXRC8ybWdpL0hiTldQM2R0Qzc4eDIxUS8yamtPdisvNVVqOEFBQkcvYkE5UlA4cS9FNys5RzA4L0dIa1d2L2dlVFQvTkt4bS9OQmxMUDhyWEc3K0lDa2svOFh3ZXZ3cnpSajhrR3lHLzBkSkVQMGF5STcvM3FVSS9Pa0ltdjVONFFEL2p5aWkvdlQ0K1B5Vk1LNytQL0RzLzQ4VXR2eUt5T1Q4Qk9EQy9rRjgzUDJXaU1yL3pCRFUvOHdRMXYyV2lNaitRWHplL0FUZ3dQeUt5T2IvanhTMC9qL3c3dnlWTUt6KzlQajYvNDhvb1A1TjRRTDg2UWlZLzk2bEN2MGF5SXovUjBrUy9KQnNoUHdyelJyL3hmQjQvaUFwSnY4clhHejgwR1V1L3pTc1pQL2dlVGI4WWVSWS92UnRQdjhxL0V6OXNEMUcvQUFBUlArLzVVci9hT1E0L01kdFV2M2R0Q3o4ZHMxYS85cG9JUDU2QldMOTN3Z1Uvb0VaYXZ4dmtBajhQQWx5L0FBQUFQOWV6WGIrUUxQbys1bHRmdnlkTzlENG8rbUMvQjJYdVBvMk9Zcjl4Y2VnK0FSbGt2NnB6NGo1MG1XVy84MnZjUHRRUFo3K1NXdFkrRW54b3Y4ay8wRDRlM21tLzNodktQdWMxYTc4Vjc4TStYb05zdjdTNXZUNTJ4bTIvQVh5M1BpSC9icjlCTnJFK1R5MXd2N3pvcWo3MFVIRy90NU9rUGdOcWNyOTZONTQrY1hoenYwelVsejR3ZkhTL2RXcVJQaloxZGI4KytvbytkMk4ydis2RGhEN3FSbmUvbkE5OFBvUWZlTDlOREc4K1BPMTR2NEwrWVQ0SnNIbS96ZVpVUHVKbmVyL0N4VWMrdmhSN3YvT2JPajZZdG51LzlXa3RQbWROZkw5Y01DQStKZGw4djd2dkVqN0xXWDIvcUtnRlBsWFBmYjl6dC9BOXZEbCt2d1FUMWozOW1INi9NMlc3UFJMdGZyOHFyNkE5K1RWL3Z4UHloVDJ2YzMrL09sNVdQUyttZjcvbnppQTllYzEvdndweDFqeUw2WCsvdjNWV1BHUDZmNzhBTUkwa0FBQ0F2NzkxVnJ4aituKy9DbkhXdkl2cGY3L256aUM5ZWMxL3Z6cGVWcjB2cG4rL0UvS0Z2YTl6Zjc4cXI2QzkrVFYvdnpObHU3MFM3WDYvQkJQV3ZmMllmcjl6dC9DOXZEbCt2NmlvQmI1VnozMi91KzhTdnN0WmZiOWNNQ0MrSmRsOHYvVnBMYjVuVFh5Lzg1czZ2cGkyZTcvQ3hVZSt2aFI3djgzbVZMN2laM3EvZ3Y1aHZnbXdlYjlOREcrK1BPMTR2NXdQZkw2RUgzaS83b09FdnVwR2Q3OCsrb3ErZDJOMnYzVnFrYjQyZFhXL1ROU1h2akI4ZEw5Nk41NitjWGh6djdlVHBMNERhbksvdk9pcXZ2UlFjYjlCTnJHK1R5MXd2d0Y4dDc0aC8yNi90TG05dm5iR2JiOFY3OE8rWG9Oc3Y5NGJ5cjduTld1L3lUL1F2aDdlYWIrU1d0YStFbnhvdi9OcjNMN1VEMmUvcW5QaXZuU1paYjl4Y2VpK0FSbGt2d2RsN3I2TmptSy9KMDcwdmlqNllMK1FMUHErNWx0ZnZ3QUFBTC9YczEyL0crUUN2dzhDWEw5M3dnVy9vRVphdi9hYUNMK2VnVmkvZDIwTHZ4MnpWci9hT1E2L01kdFV2d0FBRWIvditWSy95cjhUdjJ3UFViOFllUmEvdlJ0UHY4MHJHYi80SGsyL3l0Y2J2elFaUzcveGZCNi9pQXBKdnlRYkliOEs4MGEvUnJJanY5SFNSTDg2UWlhLzk2bEN2K1BLS0wrVGVFQy9KVXdydjcwK1ByL2p4UzIvai93N3Z3RTRNTDhpc2ptL1phSXl2NUJmTjcvekJEVy84d1ExdjVCZk43OWxvaksvSXJJNXZ3RTRNTCtQL0R1LzQ4VXR2NzArUHI4bFRDdS9rM2hBditQS0tMLzNxVUsvT2tJbXY5SFNSTDlHc2lPL0N2Tkd2eVFiSWIrSUNrbS84WHdldnpRWlM3L0sxeHUvK0I1TnY4MHJHYis5RzArL0dIa1d2MndQVWIvS3Z4Ty83L2xTdndBQUViOHgyMVMvMmprT3Z4MnpWcjkzYlF1L25vRll2L2FhQ0wrZ1JscS9kOElGdnc4Q1hMOGI1QUsvMTdOZHZ3QUFBTC9tVzErL2tDejZ2aWo2WUw4blR2UytqWTVpdndkbDdyNEJHV1MvY1hIb3ZuU1paYitxYytLKzFBOW52L05yM0w0U2ZHaS9rbHJXdmg3ZWFiL0pQOUMrNXpWcnY5NGJ5cjVlZzJ5L0ZlL0R2bmJHYmIrMHViMitJZjl1dndGOHQ3NVBMWEMvUVRheHZ2UlFjYis4NktxK0EycHl2N2VUcEw1eGVITy9lamVldmpCOGRMOU0xSmUrTm5WMXYzVnFrYjUzWTNhL1B2cUt2dXBHZDcvdWc0UytoQjk0djV3UGZMNDg3WGkvVFF4dnZnbXdlYitDL21HKzRtZDZ2ODNtVkw2K0ZIdS93c1ZIdnBpMmU3L3ptenErWjAxOHYvVnBMYjRsMlh5L1hEQWd2c3RaZmIrNzd4SytWYzk5djZpb0JiNjhPWDYvYzdmd3ZmMllmcjhFRTlhOUV1MSt2ek5sdTczNU5YKy9LcStndmE5emY3OFQ4b1c5TDZaL3Z6cGVWcjE1elgrLzU4NGd2WXZwZjc4S2NkYThZL3Avdjc5MVZyd0FBSUMvQURBTnBXUDZmNysvZFZZOGkrbC92d3B4MWp4NXpYKy81ODRnUFMrbWY3ODZYbFk5cjNOL3Z4UHloVDM1TlgrL0txK2dQUkx0ZnI4elpiczkvWmgrdndRVDFqMjhPWDYvYzdmd1BWWFBmYitvcUFVK3kxbDl2N3Z2RWo0bDJYeS9YREFnUG1kTmZMLzFhUzArbUxaN3YvT2JPajYrRkh1L3dzVkhQdUpuZXIvTjVsUStDYkI1djRMK1lUNDg3WGkvVFF4dlBvUWZlTCtjRDN3KzZrWjN2KzZEaEQ1M1kzYS9QdnFLUGpaMWRiOTFhcEUrTUh4MHYwelVsejV4ZUhPL2VqZWVQZ05xY3IrM2s2USs5RkJ4djd6b3FqNVBMWEMvUVRheFBpSC9icjhCZkxjK2RzWnR2N1M1dlQ1ZWcyeS9GZS9EUHVjMWE3L2VHOG8rSHQ1cHY4ay8wRDRTZkdpL2tscldQdFFQWjcvemE5dytkSmxsdjZwejRqNEJHV1MvY1hIb1BvMk9ZcjhIWmU0K0tQcGd2eWRPOUQ3bVcxKy9rQ3o2UHRlelhiOEFBQUEvRHdKY3Z4dmtBaitnUmxxL2Q4SUZQNTZCV0wvMm1nZy9IYk5XdjNkdEN6OHgyMVMvMmprT1ArLzVVcjhBQUJFL2JBOVJ2OHEvRXorOUcwKy9HSGtXUC9nZVRiL05LeGsvTkJsTHY4clhHeitJQ2ttLzhYd2VQd3J6UnI4a0d5RS8wZEpFdjBheUl6LzNxVUsvT2tJbVA1TjRRTC9qeWlnL3ZUNCt2eVZNS3orUC9EdS80OFV0UHlLeU9iOEJPREEva0Y4M3YyV2lNai96QkRXLzh3UTFQMldpTXIrUVh6Yy9BVGd3dnlLeU9UL2p4UzIvai93N1B5Vk1LNys5UGo0LzQ4b292NU40UUQ4NlFpYS85NmxDUDBheUk3L1Iwa1EvSkJzaHZ3cnpSai94ZkI2L2lBcEpQOHJYRzc4MEdVcy96U3Nadi9nZVRUOFllUmEvdlJ0UFA4cS9FNzlzRDFFL0FBQVJ2Ky81VWovYU9RNi9NZHRVUDNkdEM3OGRzMVkvOXBvSXY1NkJXRDkzd2dXL29FWmFQeHZrQXI4UEFsdy9BQUFBdjllelhUK1FMUHErNWx0ZlB5ZE85TDRvK21BL0IyWHV2bzJPWWo5eGNlaStBUmxrUDZwejRyNTBtV1UvODJ2Y3Z0UVBaeitTV3RhK0VueG9QOGsvMEw0ZTNtay8zaHZLdnVjMWF6OFY3OE8rWG9Oc1A3UzV2YjUyeG0wL0FYeTN2aUgvYmo5Qk5yRytUeTF3UDd6b3FyNzBVSEUvdDVPa3ZnTnFjajk2TjU2K2NYaHpQMHpVbDc0d2ZIUS9kV3FSdmpaMWRUOCsrb3ErZDJOMlArNkRoTDdxUm5jL25BOTh2b1FmZUQ5TkRHKytQTzE0UDRMK1liNEpzSGsvemVaVXZ1Sm5lai9DeFVlK3ZoUjdQL09iT3I2WXRucy85V2t0dm1kTmZEOWNNQ0MrSmRsOFA3dnZFcjdMV1gwL3FLZ0Z2bFhQZlQ5enQvQzl2RGwrUHdRVDFyMzltSDQvTTJXN3ZSTHRmajhxcjZDOStUVi9QeFB5aGIydmMzOC9PbDVXdlMrbWZ6L256aUM5ZWMxL1B3cHgxcnlMNlg4L3YzVld2R1A2Zno4QXlGT2xBQUNBUDc5MVZqeGorbjgvQ25IV1BJdnBmei9uemlBOWVjMS9QenBlVmowdnBuOC9FL0tGUGE5emZ6OHFyNkE5K1RWL1B6Tmx1ejBTN1g0L0JCUFdQZjJZZmo5enQvQTl2RGwrUDZpb0JUNVZ6MzAvdSs4U1BzdFpmVDljTUNBK0pkbDhQL1ZwTFQ1blRYdy84NXM2UHBpMmV6L0N4VWMrdmhSN1A4M21WRDdpWjNvL2d2NWhQZ213ZVQ5TkRHOCtQTzE0UDV3UGZENkVIM2cvN29PRVB1cEdkejgrK29vK2QyTjJQM1Zxa1Q0MmRYVS9UTlNYUGpCOGREOTZONTQrY1hoelA3ZVRwRDREYW5JL3ZPaXFQdlJRY1Q5Qk5yRStUeTF3UHdGOHR6NGgvMjQvdExtOVBuYkdiVDhWNzhNK1hvTnNQOTRieWo3bk5Xcy95VC9RUGg3ZWFUK1NXdFkrRW54b1AvTnIzRDdVRDJjL3FuUGlQblNaWlQ5eGNlZytBUmxrUHdkbDdqNk5qbUkvSjA3MFBpajZZRCtRTFBvKzVsdGZQd0FBQUQvWHMxMC9HK1FDUHc4Q1hEOTN3Z1Uvb0VaYVAvYWFDRCtlZ1ZnL2QyMExQeDJ6VmovYU9RNC9NZHRVUHdBQUVUL3YrVkkveXI4VFAyd1BVVDhZZVJZL3ZSdFBQODByR1QvNEhrMC95dGNiUHpRWlN6L3hmQjQvaUFwSlB5UWJJVDhLODBZL1JySWpQOUhTUkQ4NlFpWS85NmxDUCtQS0tEK1RlRUEvSlV3clA3MCtQai9qeFMwL2ovdzdQd0U0TUQ4aXNqay9aYUl5UDVCZk56L3pCRFUvOHdRMVA1QmZOejlsb2pJL0lySTVQd0U0TUQrUC9Ecy80OFV0UDcwK1BqOGxUQ3MvazNoQVArUEtLRC8zcVVJL09rSW1QOUhTUkQ5R3NpTS9Ddk5HUHlRYklUK0lDa2svOFh3ZVB6UVpTei9LMXhzLytCNU5QODByR1QrOUcwOC9HSGtXUDJ3UFVUL0t2eE0vNy9sU1B3QUFFVDh4MjFRLzJqa09QeDJ6Vmo5M2JRcy9ub0ZZUC9hYUNEK2dSbG8vZDhJRlB3OENYRDhiNUFJLzE3TmRQd0FBQUQvbVcxOC9rQ3o2UGlqNllEOG5UdlEralk1aVB3ZGw3ajRCR1dRL2NYSG9QblNaWlQrcWMrSSsxQTluUC9OcjNENFNmR2cva2xyV1BoN2VhVC9KUDlBKzV6VnJQOTRieWo1ZWcydy9GZS9EUG5iR2JUKzB1YjArSWY5dVB3Rjh0ejVQTFhBL1FUYXhQdlJRY1QrODZLbytBMnB5UDdlVHBENXhlSE0vZWplZVBqQjhkRDlNMUpjK05uVjFQM1Zxa1Q1M1kzWS9QdnFLUHVwR2R6L3VnNFEraEI5NFA1d1BmRDQ4N1hnL1RReHZQZ213ZVQrQy9tRSs0bWQ2UDgzbVZENitGSHMvd3NWSFBwaTJlei96bXpvK1owMThQL1ZwTFQ0bDJYdy9YREFnUHN0WmZUKzc3eEkrVmM5OVA2aW9CVDY4T1g0L2M3ZndQZjJZZmo4RUU5WTlFdTErUHpObHV6MzVOWDgvS3ErZ1BhOXpmejhUOG9VOUw2Wi9QenBlVmoxNXpYOC81ODRnUFl2cGZ6OEtjZFk4WS9wL1A3OTFWandBQURBQVlBQ1FBTUFBRUFCQUFIQUFvQURRQUNBQVVBQ0FBTEFBNEFBRUFEUUFaQUNVQU1RQUZBQkVBSFFBcEFEVUFDUUFWQUNFQUxRQTVBQUlBRGdBYUFDWUFNZ0FHQUJJQUhnQXFBRFlBQ2dBV0FDSUFMZ0E2QUFNQUR3QWJBQ2NBTXdBSEFCTUFId0FyQURjQUN3QVhBQ01BTHdBN0FBQkFERUFZUUNSQU1FQUVRQkJBSEVBb1FEUkFDRUFVUUNCQUxFQTRRQUZBRFVBWlFDVkFNVUFGUUJGQUhVQXBRRFZBQ1VBVlFDRkFMVUE1UUFKQURrQWFRQ1pBTWtBR1FCSkFIa0FxUURaQUNrQVdRQ0pBTGtBNlFBTkFEMEFiUUNkQU0wQUhRQk5BSDBBclFEZEFDMEFYUUNOQUwwQTdRQUNBRElBWWdDU0FNSUFFZ0JDQUhJQW9nRFNBQ0lBVWdDQ0FMSUE0Z0FHQURZQVpnQ1dBTVlBRmdCR0FIWUFwZ0RXQUNZQVZnQ0dBTFlBNWdBS0FEb0FhZ0NhQU1vQUdnQktBSG9BcWdEYUFDb0FXZ0NLQUxvQTZnQU9BRDRBYmdDZUFNNEFIZ0JPQUg0QXJnRGVBQzRBWGdDT0FMNEE3Z0FEQURNQVl3Q1RBTU1BRXdCREFITUFvd0RUQUNNQVV3Q0RBTE1BNHdBSEFEY0Fad0NYQU1jQUZ3QkhBSGNBcHdEWEFDY0FWd0NIQUxjQTV3QUxBRHNBYXdDYkFNc0FHd0JMQUhzQXF3RGJBQ3NBV3dDTEFMc0E2d0FQQUQ4QWJ3Q2ZBTThBSHdCUEFIOEFyd0RmQUM4QVh3Q1BBTDhBN3dEd0FBQUFpWWlJT3dFQUFBQUZBREFBQXdBUUFBUUFCQUFFQUFFQVFZeXRBUXNHZ0ZRQUFJQkZBRUdpclFFTGlRSVlBREFBU0FCZ0FBZ0FJQUE0QUZBQWFBQVFBQ2dBUUFCWUFIQUFCQUFjQURRQVRBQmtBQXdBSkFBOEFGUUFiQUFVQUN3QVJBQmNBSFFBQVFBWkFERUFTUUJoQUFrQUlRQTVBRkVBYVFBUkFDa0FRUUJaQUhFQUJRQWRBRFVBVFFCbEFBMEFKUUE5QUZVQWJRQVZBQzBBUlFCZEFIVUFBZ0FhQURJQVNnQmlBQW9BSWdBNkFGSUFhZ0FTQUNvQVFnQmFBSElBQmdBZUFEWUFUZ0JtQUE0QUpnQStBRllBYmdBV0FDNEFSZ0JlQUhZQUF3QWJBRE1BU3dCakFBc0FJd0E3QUZNQWF3QVRBQ3NBUXdCYkFITUFCd0FmQURjQVR3Qm5BQThBSndBL0FGY0Fid0FYQUM4QVJ3QmZBSGNBZUFBQUFJaUlDRHdDQUFBQUJRQVlBQU1BQ0FBQ0FBUUFCQUFCQUVHOHJ3RUxCcUJXQUFDQVJRQkIwcThCQzQwQkRBQVlBQ1FBTUFBRUFCQUFIQUFvQURRQUNBQVVBQ0FBTEFBNEFBRUFEUUFaQUNVQU1RQUZBQkVBSFFBcEFEVUFDUUFWQUNFQUxRQTVBQUlBRGdBYUFDWUFNZ0FHQUJJQUhnQXFBRFlBQ2dBV0FDSUFMZ0E2QUFNQUR3QWJBQ2NBTXdBSEFCTUFId0FyQURjQUN3QVhBQ01BTHdBN0FEd0FBQUNKaUlnOEF3QUFBQVVBREFBREFBUUFCQUFCQUVIMHNBRUxUZEJYQUFDQVJRQUFBQUFBQU1CWUFBQ0FXd0FBUEY0QUFQUmdBQUNvWXdBQVdHWUFBQVJwQUFCc2FnQUFLR3NBQUp4ckFBRG9hd0FBSUd3QUFFQnNBQUJZYkFBQVpHd0FBQUFBQUFBQkFFR0V0d0VMb0NNQkFBQUFBUUFBQUFFQUFBQUJBQUFBQVFBQUFBRUFBQUFCQUFBQUFRQUFBQUVBQUFBQkFBQUFBUUFBQUFFQUFBQUJBQUFBQVFBQUFBRUFBQUFCQUFBQUFRQUFBQUVBQUFBQkFBQUFBUUFBQUFFQUFBQUJBQUFBQVFBQUFBRUFBQUFCQUFBQUFRQUFBQUVBQUFBQkFBQUFBUUFBQUFFQUFBQUJBQUFBQVFBQUFBRUFBQUFCQUFBQUFRQUFBQUVBQUFBQkFBQUFBUUFBQUFFQUFBQUJBQUFBQVFBQUFBRUFBQUFCQUFBQUFRQUFBQUVBQUFBQkFBQUFBUUFBQUFFQUFBQUJBQUFBQVFBQUFBRUFBQUFCQUFBQUFRQUFBQUVBQUFBQkFBQUFBUUFBQUFFQUFBQUJBQUFBQVFBQUFBRUFBQUFCQUFBQUFRQUFBQUVBQUFBQkFBQUFBUUFBQUFFQUFBQUJBQUFBQVFBQUFBRUFBQUFCQUFBQUFRQUFBQUVBQUFBQkFBQUFBUUFBQUFFQUFBQUJBQUFBQVFBQUFBRUFBQUFCQUFBQUFRQUFBQUVBQUFBQkFBQUFBUUFBQUFFQUFBQUJBQUFBQVFBQUFBRUFBQUFCQUFBQUFRQUFBQUVBQUFBQkFBQUFBUUFBQUFFQUFBQUJBQUFBQVFBQUFBRUFBQUFCQUFBQUFRQUFBQUVBQUFBQkFBQUFBUUFBQUFFQUFBQUJBQUFBQVFBQUFBRUFBQUFCQUFBQUFRQUFBQUVBQUFBQkFBQUFBUUFBQUFFQUFBQUJBQUFBQVFBQUFBRUFBQUFCQUFBQUFRQUFBQUVBQUFBQkFBQUFBUUFBQUFFQUFBQUJBQUFBQVFBQUFBRUFBQUFCQUFBQUFRQUFBQUVBQUFBQkFBQUFBUUFBQUFFQUFBQUJBQUFBQVFBQUFBRUFBQUFCQUFBQUFRQUFBQUVBQUFBQkFBQUFBUUFBQUFFQUFBQUJBQUFBQVFBQUFBRUFBQUFCQUFBQUFRQUFBQUVBQUFBQkFBQUFBUUFBQUFFQUFBQUJBQUFBQVFBQUFBRUFBQUFCQUFBQUFRQUFBQUVBQUFBQkFBQUFBUUFBQUFFQUFBQUJBQUFBQVFBQUFBRUFBQUFCQUFBQUFRQUFBQUVBQUFBQkFBQUFBUUFBQUFFQUFBQUJBQUFBQVFBQUFBRUFBQUFCQUFBQUFRQUFBQUVBQUFBQkFBQUFBUUFBQUFFQUFBQUJBQUFBQVFBQUFBTUFBQUFGQUFBQUJ3QUFBQWtBQUFBTEFBQUFEUUFBQUE4QUFBQVJBQUFBRXdBQUFCVUFBQUFYQUFBQUdRQUFBQnNBQUFBZEFBQUFId0FBQUNFQUFBQWpBQUFBSlFBQUFDY0FBQUFwQUFBQUt3QUFBQzBBQUFBdkFBQUFNUUFBQURNQUFBQTFBQUFBTndBQUFEa0FBQUE3QUFBQVBRQUFBRDhBQUFCQkFBQUFRd0FBQUVVQUFBQkhBQUFBU1FBQUFFc0FBQUJOQUFBQVR3QUFBRkVBQUFCVEFBQUFWUUFBQUZjQUFBQlpBQUFBV3dBQUFGMEFBQUJmQUFBQVlRQUFBR01BQUFCbEFBQUFad0FBQUdrQUFBQnJBQUFBYlFBQUFHOEFBQUJ4QUFBQWN3QUFBSFVBQUFCM0FBQUFlUUFBQUhzQUFBQjlBQUFBZndBQUFJRUFBQUNEQUFBQWhRQUFBSWNBQUFDSkFBQUFpd0FBQUkwQUFBQ1BBQUFBa1FBQUFKTUFBQUNWQUFBQWx3QUFBSmtBQUFDYkFBQUFuUUFBQUo4QUFBQ2hBQUFBb3dBQUFLVUFBQUNuQUFBQXFRQUFBS3NBQUFDdEFBQUFyd0FBQUxFQUFBQ3pBQUFBdFFBQUFMY0FBQUM1QUFBQXV3QUFBTDBBQUFDL0FBQUF3UUFBQU1NQUFBREZBQUFBeHdBQUFNa0FBQURMQUFBQXpRQUFBTThBQUFEUkFBQUEwd0FBQU5VQUFBRFhBQUFBMlFBQUFOc0FBQURkQUFBQTN3QUFBT0VBQUFEakFBQUE1UUFBQU9jQUFBRHBBQUFBNndBQUFPMEFBQUR2QUFBQThRQUFBUE1BQUFEMUFBQUE5d0FBQVBrQUFBRDdBQUFBL1FBQUFQOEFBQUFCQVFBQUF3RUFBQVVCQUFBSEFRQUFDUUVBQUFzQkFBQU5BUUFBRHdFQUFCRUJBQUFUQVFBQUZRRUFBQmNCQUFBWkFRQUFHd0VBQUIwQkFBQWZBUUFBSVFFQUFDTUJBQUFsQVFBQUp3RUFBQ2tCQUFBckFRQUFMUUVBQUM4QkFBQXhBUUFBTXdFQUFEVUJBQUEzQVFBQU9RRUFBRHNCQUFBOUFRQUFQd0VBQUVFQkFBQkRBUUFBUlFFQUFFY0JBQUJKQVFBQVN3RUFBRTBCQUFCUEFRQUFVUUVBQUZNQkFBQlZBUUFBVndFQUFGa0JBQUJiQVFBQVhRRUFBRjhCQUFBTkFBQUFHUUFBQUNrQUFBQTlBQUFBVlFBQUFIRUFBQUNSQUFBQXRRQUFBTjBBQUFBSkFRQUFPUUVBQUcwQkFBQ2xBUUFBNFFFQUFDRUNBQUJsQWdBQXJRSUFBUGtDQUFCSkF3QUFuUU1BQVBVREFBQlJCQUFBc1FRQUFCVUZBQUI5QlFBQTZRVUFBRmtHQUFETkJnQUFSUWNBQU1FSEFBQkJDQUFBeFFnQUFFMEpBQURaQ1FBQWFRb0FBUDBLQUFDVkN3QUFNUXdBQU5FTUFBQjFEUUFBSFE0QUFNa09BQUI1RHdBQUxSQUFBT1VRQUFDaEVRQUFZUklBQUNVVEFBRHRFd0FBdVJRQUFJa1ZBQUJkRmdBQU5SY0FBQkVZQUFEeEdBQUExUmtBQUwwYUFBQ3BHd0FBbVJ3QUFJMGRBQUNGSGdBQWdSOEFBSUVnQUFDRklRQUFqU0lBQUprakFBQ3BKQUFBdlNVQUFOVW1BQUR4SndBQUVTa0FBRFVxQUFCZEt3QUFpU3dBQUxrdEFBRHRMZ0FBSlRBQUFHRXhBQUNoTWdBQTVUTUFBQzAxQUFCNU5nQUF5VGNBQUIwNUFBQjFPZ0FBMFRzQUFERTlBQUNWUGdBQS9UOEFBR2xCQUFEWlFnQUFUVVFBQU1WRkFBQkJSd0FBd1VnQUFFVktBQUROU3dBQVdVMEFBT2xPQUFCOVVBQUFGVklBQUxGVEFBQlJWUUFBOVZZQUFKMVlBQUJKV2dBQStWc0FBSzFkQUFCbFh3QUFJV0VBQU9GaUFBQ2xaQUFBYldZQUFEbG9BQUFKYWdBQTNXc0FBTFZ0QUFDUmJ3QUFjWEVBQUZWekFBQTlkUUFBS1hjQUFCbDVBQUFOZXdBQUJYMEFBQUYvQUFBQmdRQUFCWU1BQUEyRkFBQVpod0FBS1lrQUFEMkxBQUJWalFBQWNZOEFBSkdSQUFDMWt3QUEzWlVBQUFtWUFBQTVtZ0FBYlp3QUFLV2VBQURob0FBQUlhTUFBR1dsQUFDdHB3QUErYWtBQUVtc0FBQ2RyZ0FBOWJBQUFGR3pBQUN4dFFBQUZiZ0FBSDI2QUFEcHZBQUFXYjhBQU0zQkFBQkZ4QUFBd2NZQUFFSEpBQURGeXdBQVRjNEFBTm5RQUFCcDB3QUEvZFVBQUpYWUFBQXgyd0FBMGQwQUFIWGdBQUFkNHdBQXllVUFBSG5vQUFBdDZ3QUE1ZTBBQUtId0FBQS9BQUFBZ1FBQUFPY0FBQUI1QVFBQVB3SUFBRUVEQUFDSEJBQUFHUVlBQVA4SEFBQkJDZ0FBNXd3QUFQa1BBQUIvRXdBQWdSY0FBQWNjQUFBWklRQUF2eVlBQUFFdEFBRG5Nd0FBZVRzQUFMOURBQURCVEFBQWgxWUFBQmxoQUFCL2JBQUF3WGdBQU9lRkFBRDVrd0FBLzZJQUFBR3pBQUFIeEFBQUdkWUFBRC9wQUFDQi9RQUE1eElCQUhrcEFRQS9RUUVBUVZvQkFJZDBBUUFaa0FFQS82d0JBRUhMQVFEbjZnRUErUXNDQUg4dUFnQ0JVZ0lBQjNnQ0FCbWZBZ0MveHdJQUFmSUNBT2NkQXdCNVN3TUF2M29EQU1HckF3Q0gzZ01BR1JNRUFIOUpCQURCZ1FRQTU3c0VBUG4zQkFEL05RVUFBWFlGQUFlNEJRQVovQVVBUDBJR0FJR0tCZ0RuMUFZQWVTRUhBRDl3QndCQndRY0FoeFFJQUJscUNBRC93UWdBUVJ3SkFPZDRDUUQ1MXdrQWZ6a0tBSUdkQ2dBSEJBc0FHVzBMQUwvWUN3QUJSd3dBNTdjTUFIa3JEUUMvb1EwQXdSb09BSWVXRGdBWkZROEFmNVlQQU1FYUVBRG5vUkFBK1NzUkFQKzRFUUFCU1JJQUI5d1NBQmx5RXdBL0N4UUFnYWNVQU9kR0ZRQjU2UlVBUDQ4V0FFRTRGd0NINUJjQUdaUVlBUDlHR1FCQi9Sa0E1N1lhQVBsekd3Qi9OQndBZ2ZnY0FBZkFIUUFaaXg0QXYxa2ZBQUVzSUFEbkFTRUFlZHNoQUwrNElnREJtU01BaDM0a0FCbG5KUUIvVXlZQXdVTW5BT2MzS0FENUx5a0EveXNxQUFFc0t3QUhNQ3dBR1RndEFEOUVMZ0NCVkM4QTUyZ3dBSG1CTVFBL25qSUFRYjh6QUlma05BQVpEallBL3pzM0FFRnVPQURucERrQStkODZBSDhmUEFDQll6MEFCNncrQUJuNVB3Qy9Ta0VBQWFGQ0FPZjdRd0I1VzBVQXY3OUdBTUVvU0FDSGxra0FHUWxMQUgrQVRBREIvRTBBNTMxUEFQa0RVUUQvamxJQUFSOVVBQWUwVlFBWlRsY0FQKzFZQUlHUldnRG5PbHdBZWVsZEFEK2RYd0JCVm1FQWh4UmpBQm5ZWkFEL29HWUFRVzlvQU9kQ2FnRDVHMndBZi9wdEFFRUJBQUNwQWdBQUNRVUFBTUVJQUFCQkRnQUFDUllBQUtrZ0FBREJMZ0FBQVVFQUFDbFlBQUFKZFFBQWdaZ0FBSUhEQUFBSjl3QUFLVFFCQUFGOEFRREJ6d0VBcVRBQ0FBbWdBZ0JCSHdNQXdhOERBQWxUQkFDcENnVUFRZGdGQUlHOUJnQXB2QWNBQ2RZSUFBRU5DZ0FCWXdzQUNkb01BQ2wwRGdDQk14QUFRUm9TQUtrcUZBQUpaeFlBd2RFWUFFRnRHd0FKUEI0QXFVQWhBTUY5SkFBQjlpY0FLYXdyQUFtakx3Q0IzVE1BZ1Y0NEFBa3BQUUFwUUVJQUFhZEhBTUZnVFFDcGNGTUFDZHBaQUVHZ1lBREJ4bWNBQ1ZGdkFLbENkd0JCbjM4QWdXcUlBQ21va1FBSlhKc0FBWXFsQUFFMnNBQUpaTHNBS1JqSEFJRlcwd0JCSStBQXFZTHRBQWw1K3dEQkNnb0JRVHdaQVFrU0tRR3BrRGtCd2J4S0FRR2JYQUVwTUc4QkNZR0NBWUdTbGdHQmFhc0JDUXZCQVNsODF3RUJ3dTRCd2VFR0FxbmdId0lKeERrQ1FaRlVBc0ZOY0FJSi80d0NxYXFxQWtGV3lRS0JCK2tDS2NRSkF3bVNLd01CZDA0REFYbHlBd21lbHdNcDdMMERnV25sQTBFY0RnU3BDamdFQ1R0akJNR3pqd1JCZTcwRUNaanNCS2tRSFFYQjYwNEZBVENDQlNua3RnVUpEKzBGZ2Jja0JvSGtYUVlKblpnR0tlalVCZ0hORWdmQlVsSUhxWUNUQndsZTFnZEI4aG9Jd1VSaENBbGRxUWlwUXZNSVFmMCtDWUdVakFrcEVOd0pDWGd0Q2dIVWdBb0JMTllLQ1lndEN5bndoZ3VCYk9JTFFRVkFES25Dbnd3SnJRRU53Y3hsRFVFcXpBMEp6alFPcWNDZkRzRUtEUThCdFh3UEtjanVEd2xOWXhDQlROb1FnYzlURVFuZnp4RXBoRTRTQWNqUEVzR3pVeE9wVU5vVENhaGpGRUhEN3hUQnEzNFZDV3NRRnFrS3BSWkJsRHdYZ1JIWEZ5bU1kQmdKRGhVWkFhRzRHUUZQWHhvSklna2JLU1MyRzRGZlpoeEIzaGtkcWFyUUhRblBpaDdCVlVnZlFVa0pJQW0welNDcG9KVWh3UmxoSWdFcU1DTXAzQUlrQ1R2WkpJRlJzeVdUQmdBQVJRNEFBQThjQUFBUk13QUFXMWNBQUEyT0FBQjMzUUFBT1UwQkFHUG1BUUNWc3dJQUg4RURBQ0VkQlFDcjF3WUEzUUlKQUFlekN3REovZzRBTS84U0FPWFBGd0F2angwQU1WNGtBUHRnTEFDdHZqVUFsNkZBQUZrM1RRQURzVnNBTlVOc0FEOG1md0JCbHBRQVM5T3NBSDBoeUFBbnllWUE2UllKQWROYkx3R0Y3VmtCVHlhSkFWRmx2UUdiRHZjQlRZczJBcmRKZkFKNXZjZ0NvMThjQTlXdWR3TmZMOXNEWVd0SEJPdnl2QVFkWER3RlIwUEdCUWxMV3daekhQd0dKV2VwQjIvaFl3aHhTQ3dKTzJBREN1M3o2UXJYMWVBTG1kL29ERVB5QWc1MTlpOFBmOXh3RUlHY3hoR0xOaklUdmJLMEZHY2hUeFlwbXdJWUUwSFFHY1U4dVJ1UHdMNGRrUWZpSDl0VkpDS04rSVlrOTBVTEo3bWRzaW5qYUg0c0ZScHdMNTh0aVRLaEtjczFLNTQzT1YwbDBEeUhZNVpBU1FlTVJMUEpza2hsYmd4TnI4T2FVYkdpWDFaNzcxeGJMWm1VWUJlYUNHYlo5N3ByZzhPdGNiVVo0M2UvSWwxK0hTTUFBSEZOQUFDUm5BQUEvU1lCQUdVTUFnRHBkd01BbWFJRkFEWFdDQUF0Y0EwQTRlUVRBQ0hESEFEdHR5Z0FkWkk0QUZsSVRRQXArbWNBSmZpSkFEM0h0QUJSSnVvQXNSTXNBZDNTZkFHRjh0NEJ5VkpWQXJrcjR3SVZGSXdEVFFoVUJNRnhQd1ZCTGxNR3paZVVCNVdNQ1FrNWQ3Z0tTVmVvREFYSzRBNWRFMm9STVNkTkZOR3lreGU5SmtnYnBjQjFINm1WS0NUWm5HMHA5YmxTTDIzSTVqV2hwams5WVVGY1JhMmZZRTYxN2xsWUdZNWNZMmtjZm0vbGc5VjgvNzBBQUFHb0FRQ1Bhd01BOFo0R0FEOGpEQURCUFJVQWo3WWpBUEg4T1FEL1VWc0FBZnFMQUE5MTBRQnh2eklCUDVxNEFjSGNiUUlQejE4RGNZNmVCUDk3UFFZQnRsTUlqNXo4Q3ZGaFdBNC9wNHdTd1NYRkY0OWxOQjd4Z1JRbS8vdW5Md0djT2pzUFlpSkpjWWJBV1QrS2dtM0JXT09FQVE0RUFKRWhDUUFSTEJNQVFlNGxBRUZQUndDUlE0QUFFZmZkQUFGR2N3RUJrbG9DRVFHNEE1RTF2QVZCajZjSVFRYk9EQkd5bXhLUkQ1b2FBUnAySlFGTUJ6U1JubGRIRVoyc1lFR21rWUVqVVJZQXhaNHlBQmU1YXdDWjl0Z0FhNG1nQVEzRS9nSWZBVkFGSWRrZENUTnNNQS9Wb3FRWXAyY0lKeW45ZlR4N3RlZGJIWGNkaWErZ0xjbXRqbnNBaWVZWkFUbVdYZ0k5RnRnRXRXTjNDZUVveGhFaEF6UWdkVWlDT0gxWFYyQy9XNjhDZ2RnbkJ2ZUVYZzNwL3EwYmY0dnJOb0czNVdnWEE1ekJ3UXovRGpscWhTSVo3cEZMZ1hncm5qUGhDVlNWaXdBQU41Z0FBUCtsQUFBRXRRQUFaOFVBQUVYWEFBREI2Z0FBLy84QUFBQUF6a0FBQU1oQUFBQzRRQUFBcWtBQUFLSkFBQUNhUUFBQWtFQUFBSXhBQUFDY1FBQUFsa0FBQUpKQUFBQ09RQUFBbkVBQUFKUkFBQUNLUUFBQWtFQUFBSXhBQUFDVVFBQUFtRUFBQUk1QUFBQndRQUFBY0VBQUFIQkFBQUJ3UUFBQWNFQUFRYkRhQVF2eUFraC9RWUZDZ0VHQVFJQStnRUNBUUlCY1RseFBYRTVhVDNRcGN5aHlLSVFhaEJxUkVhRU1zQXF4Q3hpek1JbzJoemFFTllZNGhUZUVONFE5Y2taZ1NsaExXRmRLV1VKYlEyUTdiREo0S0hvbFlTdE9NbE5PVkZGWVMxWktWMGRhU1YxS1hVcHRLSElrZFNKMUlvOFJrUktTRTZJTXBRcXlCNzBHdmdpeENSZXlObk0vWmtKaVJXTktXVWRiU1Z0T1dWWlFYRUpkUUdZN1p6eG9QSFUwZXl5S0k0VWZZU1pOTFQxYVhUeHBLbXNwYmkxMEpuRW1jQ1o4R29RYmlCT01GSnNPbnhDZUVxb05zUXE3Q01BR3J3bWZDaFd5TzI1SFZrdFZWRk5iUWxoSlYwaGNTMkpJYVRwck5uTTBjamR3T0lFemhDaVdJWXdkWWlOTktpcDVZRUpzSzI4b2RTeDdJSGdrZHlGL0lZWWlpeFdURjVnVW5obWFHcVlWclJDNERiZ0tsZzJMRHhheVAzSktVbFJUWEZKblBtQklZRU5sU1d0SWNUZDJOSDAwZGpSMU40Y3hpU2VkSUpFZFlTRk5LQUFBWmo4QUFFdy9BQUFtUHdBQUFEOEFobXMvQUJRdVB3Qnd2VDRBMEV3K0FnRUFRYkhkQVFzZ0NBMFFFeFVYR0JvYkhCMGVIeUFnSVNJaUl5UWtKU1VQQUFBQUNnQUFBQVVBUWViZEFRdmhGZUEvQUFBQUFBQUE0TDhEQUFBQUJBQUFBQVFBQUFBR0FBQUFnL21pQUVST2JnRDhLUlVBMFZjbkFOMDA5UUJpMjhBQVBKbVZBRUdRUXdCalVmNEF1OTZyQUxkaHhRQTZiaVFBMGsxQ0FFa0c0QUFKNmk0QUhKTFJBT3NkL2dBcHNSd0E2RDZuQVBVMWdnQkV1eTRBbk9tRUFMUW1jQUJCZmw4QTFwRTVBRk9ET1FDYzlEa0FpMStFQUNqNXZRRDRIenNBM3YrWEFBK1lCUUFSTCs4QUNscUxBRzBmYlFEUGZqWUFDY3NuQUVaUHR3Q2VaajhBTGVwZkFMb25kUURsNjhjQVBYdnhBUGM1QndDU1Vvb0ErMnZxQUIreFh3QUlYWTBBTUFOV0FIdjhSZ0R3cTJzQUlMelBBRGIwbWdEanFSMEFYbUdSQUFnYjVnQ0ZtV1VBb0JSZkFJMUFhQUNBMlA4QUozTk5BQVlHTVFES1ZoVUF5YWh6QUh2aVlBQnJqTUFBR2NSSEFNMW53d0FKNk53QVdZTXFBSXQyeEFDbUhKWUFSSy9kQUJsWDBRQ2xQZ1VBQlFmL0FETitQd0RDTXVnQW1FL2VBTHQ5TWdBbVBjTUFIbXZ2QUovNFhnQTFIem9BZi9MS0FQR0hIUUI4a0NFQWFpUjhBTlZ1K2dBd0xYY0FGVHREQUxVVXhnRERHWjBBcmNUQ0FDeE5RUUFNQUYwQWhuMUdBT054TFFDYnhwb0FNMklBQUxUU2ZBQzBwNWNBTjFYVkFOYys5Z0NqRUJnQVRYYjhBR1NkS2dCdzE2c0FZM3o0QUhxd1Z3QVhGZWNBd0VsV0FEdlcyUUNuaERnQUpDUExBTmFLZHdCYVZDTUFBQis1QVBFS0d3QVp6dDhBbnpIL0FHWWVhZ0NaVjJFQXJQdEhBSDUvMkFBaVpiY0FNdWlKQU9hL1lBRHZ4TTBBYkRZSkFGMC8xQUFXM3RjQVdEdmVBTjZia2dEU0lpZ0FLSWJvQU9KWVRRREd5aklBQ09NV0FPQjl5d0FYd0ZBQTh4Mm5BQmpnV3dBdUV6UUFneEppQUlOSUFRRDFqbHNBcmJCL0FCN3A4Z0JJU2tNQUVHZlRBS3JkMkFDdVgwSUFhbUhPQUFvb3BBRFRtYlFBQnFieUFGeDNmd0Nqd29NQVlUeUlBSXB6ZUFDdmpGb0FiOWU5QUMybVl3RDB2OHNBallIdkFDYkJad0JWeWtVQXl0azJBQ2lvMGdEQ1lZMEFFc2wzQUFRbUZBQVNScHNBeEZuRUFNakZSQUJOc3BFQUFCZnpBTlJEclFBcFNlVUEvZFVRQUFDKy9BQWVsTXdBY003dUFCTSs5UURzOFlBQXMrZkRBTWY0S0FDVEJaUUF3WEUrQUM0SnN3QUxSZk1BaUJLY0FLc2dld0F1dFo4QVI1TENBSHN5THdBTVZXMEFjcWVRQUd2bkh3QXh5NVlBZVJaS0FFRjU0Z0QwMzRrQTZKU1hBT0xtaEFDWk1aY0FpTzFyQUY5Zk5nQzcvUTRBU0pxMEFHZWtiQUJ4Y2tJQWpWMHlBSjhWdUFDODVRa0FqVEVsQVBkME9RQXdCUndBRFF3QkFFc0lhQUFzN2xnQVI2cVFBSFRuQWdDOTFpUUE5MzJtQUc1SWNnQ2ZGdThBanBTbUFMU1I5Z0RSVTFFQXp3cnlBQ0NZTXdEMVMzNEFzbU5vQU4wK1h3QkFYUU1BaFlsL0FGVlNLUUEzWk1BQWJkZ1FBREpJTWdCYlRIVUFUbkhVQUVWVWJnQUxDY0VBS3ZWcEFCUm0xUUFuQjUwQVhRUlFBTFE3MndEcWRzVUFoL2tYQUVscmZRQWRKN29BbG1rcEFNYk1yQUN0RkZRQWtPSnFBSWpaaVFBc2NsQUFCS1MrQUhjSGxBRHpNSEFBQVB3bkFPcHhxQUJtd2trQVpPQTlBSmZkZ3dDalA1Y0FRNVQ5QUEyR2pBQXhRZDRBa2ptZEFOMXdqQUFYdCtjQUNOODdBQlUzS3dCY2dLQUFXb0NUQUJBUmtnQVA2TmdBYklDdkFOdi9Td0E0a0E4QVdSaDJBR0tsRlFCaHk3c0F4NG01QUJCQXZRRFM4Z1FBU1hVbkFPdTI5Z0RiSXJzQUNoU3FBSWttTHdCa2czWUFDVHN6QUE2VUdnQlJPcW9BSGFQQ0FLL3RyZ0JjSmhJQWJjSk5BQzE2bkFEQVZwY0FBeitEQUFudzlnQXJRSXdBYlRHWkFEbTBCd0FNSUJVQTJNTmJBUFdTeEFER3JVc0FUc3FsQUtjM3pRRG1xVFlBcTVLVUFOMUNhQUFaWTk0QWRvenZBR2lMVWdEODJ6Y0FycUdyQU44Vk1RQUFycUVBRFB2YUFHUk5aZ0R0QmJjQUtXVXdBRmRXdndCSC96b0Fhdm01QUhXKzh3QW9rOThBcTRBd0FHYU05Z0FFeXhVQStpSUdBTm5rSFFBOXM2UUFWeHVQQURiTkNRQk9RdWtBRTc2a0FETWp0UUR3cWhvQVQyV29BTkxCcFFBTFB3OEFXM2pOQUNQNWRnQjdpd1FBaVJkeUFNYW1Vd0J2YnVJQTcrc0FBSnRLV0FERTJyY0FxbWE2QUhiUHp3RFJBaDBBc2ZFdEFJeVp3UUREclhjQWhramFBUGRkb0FER2dQUUFyUEF2QU4zc21nQS9YTHdBME41dEFKREhId0FxMjdZQW95VTZBQUN2bWdDdFU1TUF0bGNFQUNrdHRBQkxnSDRBMmdlbkFIYXFEZ0I3V2FFQUZoSXFBTnkzTFFENjVmMEFpZHYrQUltKy9RRGtkbXdBQnFuOEFENkFjQUNGYmhVQS9ZZi9BQ2crQndCaFp6TUFLaGlHQUUyOTZnQ3o1NjhBajIxdUFKVm5PUUF4djFzQWhOZElBRERmRmdESExVTUFKV0UxQU1sd3pnQXd5N2dBdjJ6OUFLUUFvZ0FGYk9RQVd0MmdBQ0Z2UndCaUV0SUF1VnlFQUhCaFNRQnJWdUFBbVZJQkFGQlZOd0FlMWJjQU0vSEVBQk51WHdCZE1PUUFoUzZwQUIyeXd3Q2hNallBQ0xla0FPcXgxQUFXOXlFQWoybmtBQ2YvZHdBTUE0QUFqVUF0QUUvTm9BQWdwWmtBczZMVEFDOWRDZ0MwK1VJQUVkckxBSDIrMEFDYjI4RUFxeGU5QU1xaWdRQUlhbHdBTGxVWEFDY0FWUUIvRlBBQTRRZUdBQlFMWkFDV1FZMEFoNzdlQU5yOUtnQnJKYllBZTRrMEFBWHovZ0M1djU0QWFHcFBBRW9xcUFCUHhGb0FMZmk4QU5kYW1BRDB4NVVBRFUyTkFDQTZwZ0NrVjE4QUZEK3hBSUE0bFFETUlBRUFjZDJHQU1uZXRnQy9ZUFVBVFdVUkFBRUhhd0NNc0t3QXNzRFFBRkZWU0FBZSt3NEFsWExEQUtNR093REFRRFVBQnR4N0FPQkZ6QUJPS2ZvQTFzcklBT2p6UVFCOFpONEFtMlRZQU5tK01RQ2tsOE1BZDFqVUFHbmp4UUR3MmhNQXVqbzhBRVlZUmdCVmRWOEEwcjMxQUc2U3hnQ3NMbDBBRGtUdEFCdytRZ0JoeEljQUtmM3BBT2ZXOHdBaWZNb0FiNUUxQUFqZ3hRRC8xNDBBYm1yaUFMRDl4Z0NUQ01FQWZGMTBBR3V0c2dETmJwMEFQbko3QU1ZUmFnRDN6NmtBS1hQZkFMWEp1Z0MzQUZFQTRySU5BSFM2SkFEbGZXQUFkTmlLQUEwVkxBQ0JHQXdBZm1hVUFBRXBGZ0NmZW5ZQS9mMitBRlpGN3dEWmZqWUE3TmtUQUl1NnVRREVsL3dBTWFnbkFQRnV3d0NVeFRZQTJLaFdBTFNvdFFEUHpBNEFFb2t0QUc5WE5BQXNWb2tBbWM3akFOWWd1UUJyWHFvQVBpcWNBQkZmekFEOUMwb0E0ZlQ3QUk0N2JRRGloaXdBNmRTRUFQeTBxUUR2N3RFQUxqWEpBQzg1WVFBNElVUUFHOW5JQUlIOENnRDdTbW9BTHh6WUFGTzBoQUJPbVl3QVZDTE1BQ3BWM0FEQXh0WUFDeG1XQUJwd3VBQnBsV1FBSmxwZ0FEOVM3Z0IvRVE4QTlMVVJBUHpMOVFBMHZDMEFOTHp1QU9oZHpBRGRYbUFBWjQ2YkFKSXo3d0RKRjdnQVlWaWJBT0ZYdkFCUmc4WUEyRDRRQU4xeFNBQXRITjBBcnhpaEFDRXNSZ0JaODljQTJYcVlBSjVVd0FCUGh2b0FWZ2I4QU9WNXJnQ0pJallBT0swaUFHZVQzQUJWNktvQWdpWTRBTXJubXdCUkRhUUFtVE94QUtuWERnQnBCVWdBWmJMd0FIK0lwd0NJVEpjQStkRTJBQ0dTc3dCN2drb0FtTThoQUVDZjNBRGNSMVVBNFhRNkFHZnJRZ0QrbmQ4QVh0UmZBSHRucEFDNnJIb0FWZmFpQUN1SUl3QkJ1bFVBV1c0SUFDRXFoZ0E1UjRNQWllUG1BT1dlMUFCSiswQUEvMWJwQUJ3UHlnREZXWW9BbFBvckFOUEJ4UUFQeGM4QTIxcXVBRWZGaGdDRlEySUFJWVk3QUN4NWxBQVFZWWNBS2t4N0FJQXNHZ0JEdnhJQWlDYVFBSGc4aVFDb3hPUUE1ZHQ3QU1RNndnQW05T29BOTJlS0FBMlN2d0Jsb3lzQVBaT3hBTDE4Q3dDa1Vkd0FKOTFqQUduaDNRQ2FsQmtBcUNtVkFHak9LQUFKN2JRQVJKOGdBRTZZeWdCd2dtTUFmbndqQUErNU1nQ245WTRBRkZibkFDSHhDQUMxblNvQWIzNU5BS1VaVVFDMSthc0FndC9XQUpiZFlRQVdOZ0lBeERxZkFJT2lvUUJ5N1cwQU9ZMTZBSUs0cVFCck1sd0FSaWRiQUFBMDdRRFNBSGNBL1BSVkFBRlpUUURnY1lBQVFkUHpBUXRSUVBzaCtUOEFBQUFBTFVSMFBnQUFBSUNZUnZnOEFBQUFZRkhNZURzQUFBQ0FneHZ3T1FBQUFFQWdKWG80QUFBQWdDS0M0ellBQUFBQUhmTnBOUmg4QUFBdEt5QWdJREJZTUhnQUtHNTFiR3dwQUVHdzlBRUxRUkVBQ2dBUkVSRUFBQUFBQlFBQUFBQUFBQWtBQUFBQUN3QUFBQUFBQUFBQUVRQVBDaEVSRVFNS0J3QUJBQWtMQ3dBQUNRWUxBQUFMQUFZUkFBQUFFUkVSQUVHQjlRRUxJUXNBQUFBQUFBQUFBQkVBQ2dvUkVSRUFDZ0FBQWdBSkN3QUFBQWtBQ3dBQUN3QkJ1L1VCQ3dFTUFFSEg5UUVMRlF3QUFBQUFEQUFBQUFBSkRBQUFBQUFBREFBQURBQkI5ZlVCQ3dFT0FFR0I5Z0VMRlEwQUFBQUVEUUFBQUFBSkRnQUFBQUFBRGdBQURnQkJyL1lCQ3dFUUFFRzc5Z0VMSGc4QUFBQUFEd0FBQUFBSkVBQUFBQUFBRUFBQUVBQUFFZ0FBQUJJU0VnQkI4dllCQ3c0U0FBQUFFaElTQUFBQUFBQUFDUUJCby9jQkN3RUxBRUd2OXdFTEZRb0FBQUFBQ2dBQUFBQUpDd0FBQUFBQUN3QUFDd0JCM2ZjQkN3RU1BRUhwOXdFTEp3d0FBQUFBREFBQUFBQUpEQUFBQUFBQURBQUFEQUFBTURFeU16UTFOamM0T1VGQ1EwUkZSZ0JCa1BnQkN3bmdnMUFBQUFBQUFBVUFRYVQ0QVFzQkFnQkJ2UGdCQ3c0REFBQUFCQUFBQUpoL0FBQUFCQUJCMVBnQkN3RUJBRUhqK0FFTEJRci8vLy8vQUVIVStnRUxBc0NEXCI7ZnVuY3Rpb24gZShBKXt0cnl7aWYoQT09YiYmdylyZXR1cm4gbmV3IFVpbnQ4QXJyYXkodyk7dmFyIEk9ZnVuY3Rpb24oQSl7aWYoZihBKSlyZXR1cm4gZnVuY3Rpb24oQSl7dHJ5e2Zvcih2YXIgST1wKEEpLGc9bmV3IFVpbnQ4QXJyYXkoSS5sZW5ndGgpLEI9MDtCPEkubGVuZ3RoOysrQilnW0JdPUkuY2hhckNvZGVBdChCKTtyZXR1cm4gZ31jYXRjaChBKXt0aHJvdyBuZXcgRXJyb3IoXCJDb252ZXJ0aW5nIGJhc2U2NCBzdHJpbmcgdG8gYnl0ZXMgZmFpbGVkLlwiKX19KEEuc2xpY2Uoci5sZW5ndGgpKX0oQSk7aWYoSSlyZXR1cm4gSTt0aHJvd1wiYm90aCBhc3luYyBhbmQgc3luYyBmZXRjaGluZyBvZiB0aGUgd2FzbSBmYWlsZWRcIn1jYXRjaChBKXtuKEEpfX1mdW5jdGlvbiB4KEkpe2Zvcig7SS5sZW5ndGg+MDspe3ZhciBnPUkuc2hpZnQoKTtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiBnKXt2YXIgQj1nLmZ1bmM7XCJudW1iZXJcIj09dHlwZW9mIEI/dm9pZCAwPT09Zy5hcmc/cS5nZXQoQikoKTpxLmdldChCKShnLmFyZyk6Qih2b2lkIDA9PT1nLmFyZz9udWxsOmcuYXJnKX1lbHNlIGcoQSl9fWYoYil8fChXPWIsYj1BLmxvY2F0ZUZpbGU/QS5sb2NhdGVGaWxlKFcsbyk6bytXKTt2YXIgdj17bWFwcGluZ3M6e30sYnVmZmVyczpbbnVsbCxbXSxbXV0scHJpbnRDaGFyOmZ1bmN0aW9uKEEsSSl7dmFyIGc9di5idWZmZXJzW0FdOzA9PT1JfHwxMD09PUk/KCgxPT09QT9HOlIpKHkoZywwKSksZy5sZW5ndGg9MCk6Zy5wdXNoKEkpfSx2YXJhcmdzOnZvaWQgMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdi52YXJhcmdzKz00LGhbdi52YXJhcmdzLTQ+PjJdfSxnZXRTdHI6ZnVuY3Rpb24oQSl7cmV0dXJuIEgoQSl9LGdldDY0OmZ1bmN0aW9uKEEsSSl7cmV0dXJuIEF9fSxwPVwiZnVuY3Rpb25cIj09dHlwZW9mIGF0b2I/YXRvYjpmdW5jdGlvbihBKXt2YXIgSSxnLEIsUSxDLEUsaT1cIkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky89XCIsRD1cIlwiLG89MDtBPUEucmVwbGFjZSgvW15BLVphLXowLTlcXFxcK1xcXFwvXFxcXD1dL2csXCJcIik7ZG97ST1pLmluZGV4T2YoQS5jaGFyQXQobysrKSk8PDJ8KFE9aS5pbmRleE9mKEEuY2hhckF0KG8rKykpKT4+NCxnPSgxNSZRKTw8NHwoQz1pLmluZGV4T2YoQS5jaGFyQXQobysrKSkpPj4yLEI9KDMmQyk8PDZ8KEU9aS5pbmRleE9mKEEuY2hhckF0KG8rKykpKSxEKz1TdHJpbmcuZnJvbUNoYXJDb2RlKEkpLDY0IT09QyYmKEQrPVN0cmluZy5mcm9tQ2hhckNvZGUoZykpLDY0IT09RSYmKEQrPVN0cmluZy5mcm9tQ2hhckNvZGUoQikpfXdoaWxlKG88QS5sZW5ndGgpO3JldHVybiBEfTt2YXIgVCxPPXtiOmZ1bmN0aW9uKEEsSSxnKXtrLmNvcHlXaXRoaW4oQSxJLEkrZyl9LGM6ZnVuY3Rpb24oQSl7bihcIk9PTVwiKX0sYTpmdW5jdGlvbihBLEksZyxCKXtmb3IodmFyIFE9MCxDPTA7QzxnO0MrKyl7Zm9yKHZhciBFPWhbSSs4KkM+PjJdLGk9aFtJKyg4KkMrNCk+PjJdLEQ9MDtEPGk7RCsrKXYucHJpbnRDaGFyKEEsa1tFK0RdKTtRKz1pfXJldHVybiBoW0I+PjJdPVEsMH19LGw9KGZ1bmN0aW9uKCl7dmFyIEk9e2E6T307ZnVuY3Rpb24gZyhJLGcpe3ZhciBCLFE9SS5leHBvcnRzO0EuYXNtPVEsQj1BLmFzbS5kLmJ1ZmZlcixBLkhFQVA4PXM9bmV3IEludDhBcnJheShCKSxBLkhFQVAxNj1uZXcgSW50MTZBcnJheShCKSxBLkhFQVAzMj1oPW5ldyBJbnQzMkFycmF5KEIpLEEuSEVBUFU4PWs9bmV3IFVpbnQ4QXJyYXkoQiksQS5IRUFQVTE2PW5ldyBVaW50MTZBcnJheShCKSxBLkhFQVBVMzI9bmV3IFVpbnQzMkFycmF5KEIpLEEuSEVBUEYzMj1uZXcgRmxvYXQzMkFycmF5KEIpLEEuSEVBUEY2ND1uZXcgRmxvYXQ2NEFycmF5KEIpLHE9QS5hc20uZSxmdW5jdGlvbihJKXtpZihkLS0sQS5tb25pdG9yUnVuRGVwZW5kZW5jaWVzJiZBLm1vbml0b3JSdW5EZXBlbmRlbmNpZXMoZCksMD09ZCYmKG51bGwhPT1QJiYoY2xlYXJJbnRlcnZhbChQKSxQPW51bGwpLHQpKXt2YXIgZz10O3Q9bnVsbCxnKCl9fSgpfWZ1bmN0aW9uIFEoQSl7ZyhBLmluc3RhbmNlKX1mdW5jdGlvbiBDKEEpe3JldHVybih3fHxcImZ1bmN0aW9uXCIhPXR5cGVvZiBmZXRjaD9Qcm9taXNlLnJlc29sdmUoKS50aGVuKChmdW5jdGlvbigpe3JldHVybiBlKGIpfSkpOmZldGNoKGIse2NyZWRlbnRpYWxzOlwic2FtZS1vcmlnaW5cIn0pLnRoZW4oKGZ1bmN0aW9uKEEpe2lmKCFBLm9rKXRocm93XCJmYWlsZWQgdG8gbG9hZCB3YXNtIGJpbmFyeSBmaWxlIGF0IFxcJ1wiK2IrXCJcXCdcIjtyZXR1cm4gQS5hcnJheUJ1ZmZlcigpfSkpLmNhdGNoKChmdW5jdGlvbigpe3JldHVybiBlKGIpfSkpKS50aGVuKChmdW5jdGlvbihBKXtyZXR1cm4gV2ViQXNzZW1ibHkuaW5zdGFudGlhdGUoQSxJKX0pKS50aGVuKEEsKGZ1bmN0aW9uKEEpe1IoXCJmYWlsZWQgdG8gYXN5bmNocm9ub3VzbHkgcHJlcGFyZSB3YXNtOiBcIitBKSxuKEEpfSkpfWlmKGQrKyxBLm1vbml0b3JSdW5EZXBlbmRlbmNpZXMmJkEubW9uaXRvclJ1bkRlcGVuZGVuY2llcyhkKSxBLmluc3RhbnRpYXRlV2FzbSl0cnl7cmV0dXJuIEEuaW5zdGFudGlhdGVXYXNtKEksZyl9Y2F0Y2goQSl7cmV0dXJuIFIoXCJNb2R1bGUuaW5zdGFudGlhdGVXYXNtIGNhbGxiYWNrIGZhaWxlZCB3aXRoIGVycm9yOiBcIitBKSwhMX0od3x8XCJmdW5jdGlvblwiIT10eXBlb2YgV2ViQXNzZW1ibHkuaW5zdGFudGlhdGVTdHJlYW1pbmd8fGYoYil8fFwiZnVuY3Rpb25cIiE9dHlwZW9mIGZldGNoP0MoUSk6ZmV0Y2goYix7Y3JlZGVudGlhbHM6XCJzYW1lLW9yaWdpblwifSkudGhlbigoZnVuY3Rpb24oQSl7cmV0dXJuIFdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlU3RyZWFtaW5nKEEsSSkudGhlbihRLChmdW5jdGlvbihBKXtyZXR1cm4gUihcIndhc20gc3RyZWFtaW5nIGNvbXBpbGUgZmFpbGVkOiBcIitBKSxSKFwiZmFsbGluZyBiYWNrIHRvIEFycmF5QnVmZmVyIGluc3RhbnRpYXRpb25cIiksQyhRKX0pKX0pKSkuY2F0Y2goQil9KCksQS5fX193YXNtX2NhbGxfY3RvcnM9ZnVuY3Rpb24oKXtyZXR1cm4obD1BLl9fX3dhc21fY2FsbF9jdG9ycz1BLmFzbS5mKS5hcHBseShudWxsLGFyZ3VtZW50cyl9KSxYPShBLl9zdG9wU3RyZWFtPWZ1bmN0aW9uKCl7cmV0dXJuKEEuX3N0b3BTdHJlYW09QS5hc20uZykuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxBLl9zdGFydFN0cmVhbT1mdW5jdGlvbigpe3JldHVybihBLl9zdGFydFN0cmVhbT1BLmFzbS5oKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LEEuX2RlY29kZT1mdW5jdGlvbigpe3JldHVybihBLl9kZWNvZGU9QS5hc20uaSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxBLl9jcmVhdGVCdWZmZXI9ZnVuY3Rpb24oKXtyZXR1cm4oQS5fY3JlYXRlQnVmZmVyPUEuYXNtLmopLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sQS5fZnJlZUJ1ZmZlcj1mdW5jdGlvbigpe3JldHVybihBLl9mcmVlQnVmZmVyPUEuYXNtLmspLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sQS5fbWFpbj1mdW5jdGlvbigpe3JldHVybihBLl9tYWluPUEuYXNtLmwpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sQS5zdGFja1NhdmU9ZnVuY3Rpb24oKXtyZXR1cm4oWD1BLnN0YWNrU2F2ZT1BLmFzbS5tKS5hcHBseShudWxsLGFyZ3VtZW50cyl9KSxaPUEuc3RhY2tSZXN0b3JlPWZ1bmN0aW9uKCl7cmV0dXJuKFo9QS5zdGFja1Jlc3RvcmU9QS5hc20ubikuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxWPUEuc3RhY2tBbGxvYz1mdW5jdGlvbigpe3JldHVybihWPUEuc3RhY2tBbGxvYz1BLmFzbS5vKS5hcHBseShudWxsLGFyZ3VtZW50cyl9O2Z1bmN0aW9uIHooQSl7dGhpcy5uYW1lPVwiRXhpdFN0YXR1c1wiLHRoaXMubWVzc2FnZT1cIlByb2dyYW0gdGVybWluYXRlZCB3aXRoIGV4aXQoXCIrQStcIilcIix0aGlzLnN0YXR1cz1BfWZ1bmN0aW9uIGooSSl7ZnVuY3Rpb24gQigpe1R8fChUPSEwLEEuY2FsbGVkUnVuPSEwLFN8fCh4KEspLHgoYyksZyhBKSxBLm9uUnVudGltZUluaXRpYWxpemVkJiZBLm9uUnVudGltZUluaXRpYWxpemVkKCksdSYmZnVuY3Rpb24oSSl7dmFyIGcsQj1BLl9tYWluLFE9KEk9SXx8W10pLmxlbmd0aCsxLEM9Vig0KihRKzEpKTtoW0M+PjJdPUwoaSk7Zm9yKHZhciBFPTE7RTxRO0UrKyloWyhDPj4yKStFXT1MKElbRS0xXSk7aFsoQz4+MikrUV09MDt0cnl7Zz1CKFEsQyksRiYmMD09PWd8fChGfHwoQS5vbkV4aXQmJkEub25FeGl0KGcpLFM9ITApLEQoZyxuZXcgeihnKSkpfWNhdGNoKEEpe2lmKEEgaW5zdGFuY2VvZiB6KXJldHVybjtpZihcInVud2luZFwiPT1BKXJldHVybiB2b2lkKEY9ITApO3ZhciBvPUE7QSYmXCJvYmplY3RcIj09dHlwZW9mIEEmJkEuc3RhY2smJihvPVtBLEEuc3RhY2tdKSxSKFwiZXhjZXB0aW9uIHRocm93bjogXCIrbyksRCgxLEEpfX0oSSksZnVuY3Rpb24oKXtpZihBLnBvc3RSdW4pZm9yKFwiZnVuY3Rpb25cIj09dHlwZW9mIEEucG9zdFJ1biYmKEEucG9zdFJ1bj1bQS5wb3N0UnVuXSk7QS5wb3N0UnVuLmxlbmd0aDspST1BLnBvc3RSdW4uc2hpZnQoKSxZLnVuc2hpZnQoSSk7dmFyIEk7eChZKX0oKSkpfUk9SXx8RSxkPjB8fChmdW5jdGlvbigpe2lmKEEucHJlUnVuKWZvcihcImZ1bmN0aW9uXCI9PXR5cGVvZiBBLnByZVJ1biYmKEEucHJlUnVuPVtBLnByZVJ1bl0pO0EucHJlUnVuLmxlbmd0aDspST1BLnByZVJ1bi5zaGlmdCgpLE0udW5zaGlmdChJKTt2YXIgSTt4KE0pfSgpLGQ+MHx8KEEuc2V0U3RhdHVzPyhBLnNldFN0YXR1cyhcIlJ1bm5pbmcuLi5cIiksc2V0VGltZW91dCgoZnVuY3Rpb24oKXtzZXRUaW1lb3V0KChmdW5jdGlvbigpe0Euc2V0U3RhdHVzKFwiXCIpfSksMSksQigpfSksMSkpOkIoKSkpfWlmKEEuY3dyYXA9ZnVuY3Rpb24oQSxJLGcsQil7dmFyIFE9KGc9Z3x8W10pLmV2ZXJ5KChmdW5jdGlvbihBKXtyZXR1cm5cIm51bWJlclwiPT09QX0pKTtyZXR1cm5cInN0cmluZ1wiIT09SSYmUSYmIUI/VShBKTpmdW5jdGlvbigpe3JldHVybiBhKEEsSSxnLGFyZ3VtZW50cyl9fSx0PWZ1bmN0aW9uIEEoKXtUfHxqKCksVHx8KHQ9QSl9LEEucnVuPWosQS5wcmVJbml0KWZvcihcImZ1bmN0aW9uXCI9PXR5cGVvZiBBLnByZUluaXQmJihBLnByZUluaXQ9W0EucHJlSW5pdF0pO0EucHJlSW5pdC5sZW5ndGg+MDspQS5wcmVJbml0LnBvcCgpKCk7dmFyIHU9ITA7cmV0dXJuIEEubm9Jbml0aWFsUnVuJiYodT0hMSksRj0hMCxqKCksQS5yZWFkeX0pO0EuZXhwb3J0cz1nfX0sST17fTtmdW5jdGlvbiBnKEIpe3ZhciBRPUlbQl07aWYodm9pZCAwIT09USlyZXR1cm4gUS5leHBvcnRzO3ZhciBDPUlbQl09e2V4cG9ydHM6e319O3JldHVybiBBW0JdKEMsQy5leHBvcnRzLGcpLEMuZXhwb3J0c31nLm49QT0+e3ZhciBJPUEmJkEuX19lc01vZHVsZT8oKT0+QS5kZWZhdWx0OigpPT5BO3JldHVybiBnLmQoSSx7YTpJfSksSX0sZy5kPShBLEkpPT57Zm9yKHZhciBCIGluIEkpZy5vKEksQikmJiFnLm8oQSxCKSYmT2JqZWN0LmRlZmluZVByb3BlcnR5KEEsQix7ZW51bWVyYWJsZTohMCxnZXQ6SVtCXX0pfSxnLm89KEEsSSk9Pk9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChBLEkpLCgoKT0+e1widXNlIHN0cmljdFwiO3ZhciBBLEk9ZygzMDUpLEI9Zy5uKEkpLFE9MCxDPTAsRT0wLGk9MCxEPTAsbz0wOyFhc3luYyBmdW5jdGlvbigpe0E9YXdhaXQgQigpKCksc2VsZi5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLChhc3luYyBmdW5jdGlvbihJKXt2YXIgZz1JLmRhdGE7c3dpdGNoKGcudHlwZSl7Y2FzZVwic3RhcnRTdHJlYW1cIjpvPWcuZGVjb2RlZFNhbXBsZXNQZXJGcmFtZSxEPW8qZy5jaGFubmVsQ291bnQsQS5fc3RhcnRTdHJlYW0oZy5zYW1wbGVSYXRlSHosZy5jaGFubmVsQ291bnQpO2JyZWFrO2Nhc2VcInN0b3BTdHJlYW1cIjpBLl9zdG9wU3RyZWFtKCk7YnJlYWs7Y2FzZVwiZGVjb2RlXCI6e2NvbnN0IEk9Zy5zdGFydFRpbWVzdGFtcCxCPWZ1bmN0aW9uKEkpe2NvbnN0IGc9SS5ieXRlTGVuZ3RoO3JldHVybiAwIT1RJiZDPGcmJihBLl9mcmVlQnVmZmVyKFEpLFE9MCxDPTApLDA9PVEmJihRPUEuX2NyZWF0ZUJ1ZmZlcihJLkJZVEVTX1BFUl9FTEVNRU5UKmcpLEM9ZyksQS5IRUFQVTguc2V0KEksUSksUX0obmV3IFVpbnQ4QXJyYXkoZy5pbnB1dERhdGEpKSx3PSgwIT1FJiZpPEQmJihBLl9mcmVlQnVmZmVyKEUpLEU9MCxpPTApLDA9PUUmJihFPUEuX2NyZWF0ZUJ1ZmZlcihGbG9hdDMyQXJyYXkuQllURVNfUEVSX0VMRU1FTlQqRCksaT1EKSxFKSxGPW5ldyBGbG9hdDMyQXJyYXkoQS5IRUFQRjMyLmJ1ZmZlcix3LEQpLEc9QS5fZGVjb2RlKEIsZy5pbnB1dERhdGEuYnl0ZUxlbmd0aCx3LG8pLFI9Ri5idWZmZXIuc2xpY2Uodyx3K0QqRi5CWVRFU19QRVJfRUxFTUVOVCk7cG9zdE1lc3NhZ2Uoe3R5cGU6XCJkZWNvZGVEb25lXCIsc3RhcnRUaW1lc3RhbXA6SSxvdXRwdXREYXRhOlIsc2FtcGxlc0RlY29kZWQ6R30sW1JdKTticmVha31jYXNlXCJyZWxlYXNlXCI6MCE9USYmKEEuX2ZyZWVCdWZmZXIoUSksUT0wLEM9MCksMCE9RSYmKEEuX2ZyZWVCdWZmZXIoRSksRT0wLGk9MCksQS5fc3RvcFN0cmVhbSgpfX0pKSxwb3N0TWVzc2FnZSh7dHlwZTpcImRlY29kZXJSZWFkeVwifSl9KCl9KSgpfSkoKTsnLFwiV29ya2VyXCIsdm9pZCAwLHZvaWQgMCl9fSw2MTQ6QT0+e0EuZXhwb3J0cz1mdW5jdGlvbihBLEksZyxlKXt2YXIgQj1zZWxmfHx3aW5kb3c7dHJ5e3RyeXt2YXIgaTt0cnl7aT1uZXcgQi5CbG9iKFtBXSl9Y2F0Y2goSSl7KGk9bmV3KEIuQmxvYkJ1aWxkZXJ8fEIuV2ViS2l0QmxvYkJ1aWxkZXJ8fEIuTW96QmxvYkJ1aWxkZXJ8fEIuTVNCbG9iQnVpbGRlcikpLmFwcGVuZChBKSxpPWkuZ2V0QmxvYigpfXZhciBRPUIuVVJMfHxCLndlYmtpdFVSTCx0PVEuY3JlYXRlT2JqZWN0VVJMKGkpLEM9bmV3IEJbSV0odCxnKTtyZXR1cm4gUS5yZXZva2VPYmplY3RVUkwodCksQ31jYXRjaChlKXtyZXR1cm4gbmV3IEJbSV0oXCJkYXRhOmFwcGxpY2F0aW9uL2phdmFzY3JpcHQsXCIuY29uY2F0KGVuY29kZVVSSUNvbXBvbmVudChBKSksZyl9fWNhdGNoKEEpe2lmKCFlKXRocm93IEVycm9yKFwiSW5saW5lIHdvcmtlciBpcyBub3Qgc3VwcG9ydGVkXCIpO3JldHVybiBuZXcgQltJXShlLGcpfX19fSxJPXt9O2Z1bmN0aW9uIGcoZSl7dmFyIEI9SVtlXTtpZih2b2lkIDAhPT1CKXJldHVybiBCLmV4cG9ydHM7dmFyIGk9SVtlXT17ZXhwb3J0czp7fX07cmV0dXJuIEFbZV0uY2FsbChpLmV4cG9ydHMsaSxpLmV4cG9ydHMsZyksaS5leHBvcnRzfXJldHVybiBnLm49QT0+e3ZhciBJPUEmJkEuX19lc01vZHVsZT8oKT0+QS5kZWZhdWx0OigpPT5BO3JldHVybiBnLmQoSSx7YTpJfSksSX0sZy5kPShBLEkpPT57Zm9yKHZhciBlIGluIEkpZy5vKEksZSkmJiFnLm8oQSxlKSYmT2JqZWN0LmRlZmluZVByb3BlcnR5KEEsZSx7ZW51bWVyYWJsZTohMCxnZXQ6SVtlXX0pfSxnLm89KEEsSSk9Pk9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChBLEkpLGcucj1BPT57XCJ1bmRlZmluZWRcIiE9dHlwZW9mIFN5bWJvbCYmU3ltYm9sLnRvU3RyaW5nVGFnJiZPYmplY3QuZGVmaW5lUHJvcGVydHkoQSxTeW1ib2wudG9TdHJpbmdUYWcse3ZhbHVlOlwiTW9kdWxlXCJ9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoQSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KX0sZygxMTQpfSkoKX0sNzAwOigpPT57fX0sST17fTtmdW5jdGlvbiBnKGUpe3ZhciBCPUlbZV07aWYodm9pZCAwIT09QilyZXR1cm4gQi5leHBvcnRzO3ZhciBpPUlbZV09e2V4cG9ydHM6e319O3JldHVybiBBW2VdLmNhbGwoaS5leHBvcnRzLGksaS5leHBvcnRzLGcpLGkuZXhwb3J0c31yZXR1cm4gZy5nPWZ1bmN0aW9uKCl7aWYoXCJvYmplY3RcIj09dHlwZW9mIGdsb2JhbFRoaXMpcmV0dXJuIGdsb2JhbFRoaXM7dHJ5e3JldHVybiB0aGlzfHxuZXcgRnVuY3Rpb24oXCJyZXR1cm4gdGhpc1wiKSgpfWNhdGNoKEEpe2lmKFwib2JqZWN0XCI9PXR5cGVvZiB3aW5kb3cpcmV0dXJuIHdpbmRvd319KCksZygxNCl9KSgpfSkpOyIsIi8qKiBAbGljZW5zZSBSZWFjdCB2MTcuMC4yXG4gKiByZWFjdC1kb20uZGV2ZWxvcG1lbnQuanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgKGZ1bmN0aW9uKCkge1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xudmFyIF9hc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG52YXIgU2NoZWR1bGVyID0gcmVxdWlyZSgnc2NoZWR1bGVyJyk7XG52YXIgdHJhY2luZyA9IHJlcXVpcmUoJ3NjaGVkdWxlci90cmFjaW5nJyk7XG5cbnZhciBSZWFjdFNoYXJlZEludGVybmFscyA9IFJlYWN0Ll9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEO1xuXG4vLyBieSBjYWxscyB0byB0aGVzZSBtZXRob2RzIGJ5IGEgQmFiZWwgcGx1Z2luLlxuLy9cbi8vIEluIFBST0QgKG9yIGluIHBhY2thZ2VzIHdpdGhvdXQgYWNjZXNzIHRvIFJlYWN0IGludGVybmFscyksXG4vLyB0aGV5IGFyZSBsZWZ0IGFzIHRoZXkgYXJlIGluc3RlYWQuXG5cbmZ1bmN0aW9uIHdhcm4oZm9ybWF0KSB7XG4gIHtcbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICBwcmludFdhcm5pbmcoJ3dhcm4nLCBmb3JtYXQsIGFyZ3MpO1xuICB9XG59XG5mdW5jdGlvbiBlcnJvcihmb3JtYXQpIHtcbiAge1xuICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMiA+IDEgPyBfbGVuMiAtIDEgOiAwKSwgX2tleTIgPSAxOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICBhcmdzW19rZXkyIC0gMV0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgIH1cblxuICAgIHByaW50V2FybmluZygnZXJyb3InLCBmb3JtYXQsIGFyZ3MpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHByaW50V2FybmluZyhsZXZlbCwgZm9ybWF0LCBhcmdzKSB7XG4gIC8vIFdoZW4gY2hhbmdpbmcgdGhpcyBsb2dpYywgeW91IG1pZ2h0IHdhbnQgdG8gYWxzb1xuICAvLyB1cGRhdGUgY29uc29sZVdpdGhTdGFja0Rldi53d3cuanMgYXMgd2VsbC5cbiAge1xuICAgIHZhciBSZWFjdERlYnVnQ3VycmVudEZyYW1lID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZTtcbiAgICB2YXIgc3RhY2sgPSBSZWFjdERlYnVnQ3VycmVudEZyYW1lLmdldFN0YWNrQWRkZW5kdW0oKTtcblxuICAgIGlmIChzdGFjayAhPT0gJycpIHtcbiAgICAgIGZvcm1hdCArPSAnJXMnO1xuICAgICAgYXJncyA9IGFyZ3MuY29uY2F0KFtzdGFja10pO1xuICAgIH1cblxuICAgIHZhciBhcmdzV2l0aEZvcm1hdCA9IGFyZ3MubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICByZXR1cm4gJycgKyBpdGVtO1xuICAgIH0pOyAvLyBDYXJlZnVsOiBSTiBjdXJyZW50bHkgZGVwZW5kcyBvbiB0aGlzIHByZWZpeFxuXG4gICAgYXJnc1dpdGhGb3JtYXQudW5zaGlmdCgnV2FybmluZzogJyArIGZvcm1hdCk7IC8vIFdlIGludGVudGlvbmFsbHkgZG9uJ3QgdXNlIHNwcmVhZCAob3IgLmFwcGx5KSBkaXJlY3RseSBiZWNhdXNlIGl0XG4gICAgLy8gYnJlYWtzIElFOTogaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xMzYxMFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmdcblxuICAgIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5jYWxsKGNvbnNvbGVbbGV2ZWxdLCBjb25zb2xlLCBhcmdzV2l0aEZvcm1hdCk7XG4gIH1cbn1cblxuaWYgKCFSZWFjdCkge1xuICB7XG4gICAgdGhyb3cgRXJyb3IoIFwiUmVhY3RET00gd2FzIGxvYWRlZCBiZWZvcmUgUmVhY3QuIE1ha2Ugc3VyZSB5b3UgbG9hZCB0aGUgUmVhY3QgcGFja2FnZSBiZWZvcmUgbG9hZGluZyBSZWFjdERPTS5cIiApO1xuICB9XG59XG5cbnZhciBGdW5jdGlvbkNvbXBvbmVudCA9IDA7XG52YXIgQ2xhc3NDb21wb25lbnQgPSAxO1xudmFyIEluZGV0ZXJtaW5hdGVDb21wb25lbnQgPSAyOyAvLyBCZWZvcmUgd2Uga25vdyB3aGV0aGVyIGl0IGlzIGZ1bmN0aW9uIG9yIGNsYXNzXG5cbnZhciBIb3N0Um9vdCA9IDM7IC8vIFJvb3Qgb2YgYSBob3N0IHRyZWUuIENvdWxkIGJlIG5lc3RlZCBpbnNpZGUgYW5vdGhlciBub2RlLlxuXG52YXIgSG9zdFBvcnRhbCA9IDQ7IC8vIEEgc3VidHJlZS4gQ291bGQgYmUgYW4gZW50cnkgcG9pbnQgdG8gYSBkaWZmZXJlbnQgcmVuZGVyZXIuXG5cbnZhciBIb3N0Q29tcG9uZW50ID0gNTtcbnZhciBIb3N0VGV4dCA9IDY7XG52YXIgRnJhZ21lbnQgPSA3O1xudmFyIE1vZGUgPSA4O1xudmFyIENvbnRleHRDb25zdW1lciA9IDk7XG52YXIgQ29udGV4dFByb3ZpZGVyID0gMTA7XG52YXIgRm9yd2FyZFJlZiA9IDExO1xudmFyIFByb2ZpbGVyID0gMTI7XG52YXIgU3VzcGVuc2VDb21wb25lbnQgPSAxMztcbnZhciBNZW1vQ29tcG9uZW50ID0gMTQ7XG52YXIgU2ltcGxlTWVtb0NvbXBvbmVudCA9IDE1O1xudmFyIExhenlDb21wb25lbnQgPSAxNjtcbnZhciBJbmNvbXBsZXRlQ2xhc3NDb21wb25lbnQgPSAxNztcbnZhciBEZWh5ZHJhdGVkRnJhZ21lbnQgPSAxODtcbnZhciBTdXNwZW5zZUxpc3RDb21wb25lbnQgPSAxOTtcbnZhciBGdW5kYW1lbnRhbENvbXBvbmVudCA9IDIwO1xudmFyIFNjb3BlQ29tcG9uZW50ID0gMjE7XG52YXIgQmxvY2sgPSAyMjtcbnZhciBPZmZzY3JlZW5Db21wb25lbnQgPSAyMztcbnZhciBMZWdhY3lIaWRkZW5Db21wb25lbnQgPSAyNDtcblxuLy8gRmlsdGVyIGNlcnRhaW4gRE9NIGF0dHJpYnV0ZXMgKGUuZy4gc3JjLCBocmVmKSBpZiB0aGVpciB2YWx1ZXMgYXJlIGVtcHR5IHN0cmluZ3MuXG5cbnZhciBlbmFibGVQcm9maWxlclRpbWVyID0gdHJ1ZTsgLy8gUmVjb3JkIGR1cmF0aW9ucyBmb3IgY29tbWl0IGFuZCBwYXNzaXZlIGVmZmVjdHMgcGhhc2VzLlxuXG52YXIgZW5hYmxlRnVuZGFtZW50YWxBUEkgPSBmYWxzZTsgLy8gRXhwZXJpbWVudGFsIFNjb3BlIHN1cHBvcnQuXG52YXIgZW5hYmxlTmV3UmVjb25jaWxlciA9IGZhbHNlOyAvLyBFcnJvcnMgdGhhdCBhcmUgdGhyb3duIHdoaWxlIHVubW91bnRpbmcgKG9yIGFmdGVyIGluIHRoZSBjYXNlIG9mIHBhc3NpdmUgZWZmZWN0cylcbnZhciB3YXJuQWJvdXRTdHJpbmdSZWZzID0gZmFsc2U7XG5cbnZhciBhbGxOYXRpdmVFdmVudHMgPSBuZXcgU2V0KCk7XG4vKipcbiAqIE1hcHBpbmcgZnJvbSByZWdpc3RyYXRpb24gbmFtZSB0byBldmVudCBuYW1lXG4gKi9cblxuXG52YXIgcmVnaXN0cmF0aW9uTmFtZURlcGVuZGVuY2llcyA9IHt9O1xuLyoqXG4gKiBNYXBwaW5nIGZyb20gbG93ZXJjYXNlIHJlZ2lzdHJhdGlvbiBuYW1lcyB0byB0aGUgcHJvcGVybHkgY2FzZWQgdmVyc2lvbixcbiAqIHVzZWQgdG8gd2FybiBpbiB0aGUgY2FzZSBvZiBtaXNzaW5nIGV2ZW50IGhhbmRsZXJzLiBBdmFpbGFibGVcbiAqIG9ubHkgaW4gdHJ1ZS5cbiAqIEB0eXBlIHtPYmplY3R9XG4gKi9cblxudmFyIHBvc3NpYmxlUmVnaXN0cmF0aW9uTmFtZXMgPSAge30gOyAvLyBUcnVzdCB0aGUgZGV2ZWxvcGVyIHRvIG9ubHkgdXNlIHBvc3NpYmxlUmVnaXN0cmF0aW9uTmFtZXMgaW4gdHJ1ZVxuXG5mdW5jdGlvbiByZWdpc3RlclR3b1BoYXNlRXZlbnQocmVnaXN0cmF0aW9uTmFtZSwgZGVwZW5kZW5jaWVzKSB7XG4gIHJlZ2lzdGVyRGlyZWN0RXZlbnQocmVnaXN0cmF0aW9uTmFtZSwgZGVwZW5kZW5jaWVzKTtcbiAgcmVnaXN0ZXJEaXJlY3RFdmVudChyZWdpc3RyYXRpb25OYW1lICsgJ0NhcHR1cmUnLCBkZXBlbmRlbmNpZXMpO1xufVxuZnVuY3Rpb24gcmVnaXN0ZXJEaXJlY3RFdmVudChyZWdpc3RyYXRpb25OYW1lLCBkZXBlbmRlbmNpZXMpIHtcbiAge1xuICAgIGlmIChyZWdpc3RyYXRpb25OYW1lRGVwZW5kZW5jaWVzW3JlZ2lzdHJhdGlvbk5hbWVdKSB7XG4gICAgICBlcnJvcignRXZlbnRSZWdpc3RyeTogTW9yZSB0aGFuIG9uZSBwbHVnaW4gYXR0ZW1wdGVkIHRvIHB1Ymxpc2ggdGhlIHNhbWUgJyArICdyZWdpc3RyYXRpb24gbmFtZSwgYCVzYC4nLCByZWdpc3RyYXRpb25OYW1lKTtcbiAgICB9XG4gIH1cblxuICByZWdpc3RyYXRpb25OYW1lRGVwZW5kZW5jaWVzW3JlZ2lzdHJhdGlvbk5hbWVdID0gZGVwZW5kZW5jaWVzO1xuXG4gIHtcbiAgICB2YXIgbG93ZXJDYXNlZE5hbWUgPSByZWdpc3RyYXRpb25OYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgcG9zc2libGVSZWdpc3RyYXRpb25OYW1lc1tsb3dlckNhc2VkTmFtZV0gPSByZWdpc3RyYXRpb25OYW1lO1xuXG4gICAgaWYgKHJlZ2lzdHJhdGlvbk5hbWUgPT09ICdvbkRvdWJsZUNsaWNrJykge1xuICAgICAgcG9zc2libGVSZWdpc3RyYXRpb25OYW1lcy5vbmRibGNsaWNrID0gcmVnaXN0cmF0aW9uTmFtZTtcbiAgICB9XG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGRlcGVuZGVuY2llcy5sZW5ndGg7IGkrKykge1xuICAgIGFsbE5hdGl2ZUV2ZW50cy5hZGQoZGVwZW5kZW5jaWVzW2ldKTtcbiAgfVxufVxuXG52YXIgY2FuVXNlRE9NID0gISEodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdy5kb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50ICE9PSAndW5kZWZpbmVkJyk7XG5cbi8vIEEgcmVzZXJ2ZWQgYXR0cmlidXRlLlxuLy8gSXQgaXMgaGFuZGxlZCBieSBSZWFjdCBzZXBhcmF0ZWx5IGFuZCBzaG91bGRuJ3QgYmUgd3JpdHRlbiB0byB0aGUgRE9NLlxudmFyIFJFU0VSVkVEID0gMDsgLy8gQSBzaW1wbGUgc3RyaW5nIGF0dHJpYnV0ZS5cbi8vIEF0dHJpYnV0ZXMgdGhhdCBhcmVuJ3QgaW4gdGhlIGZpbHRlciBhcmUgcHJlc3VtZWQgdG8gaGF2ZSB0aGlzIHR5cGUuXG5cbnZhciBTVFJJTkcgPSAxOyAvLyBBIHN0cmluZyBhdHRyaWJ1dGUgdGhhdCBhY2NlcHRzIGJvb2xlYW5zIGluIFJlYWN0LiBJbiBIVE1MLCB0aGVzZSBhcmUgY2FsbGVkXG4vLyBcImVudW1lcmF0ZWRcIiBhdHRyaWJ1dGVzIHdpdGggXCJ0cnVlXCIgYW5kIFwiZmFsc2VcIiBhcyBwb3NzaWJsZSB2YWx1ZXMuXG4vLyBXaGVuIHRydWUsIGl0IHNob3VsZCBiZSBzZXQgdG8gYSBcInRydWVcIiBzdHJpbmcuXG4vLyBXaGVuIGZhbHNlLCBpdCBzaG91bGQgYmUgc2V0IHRvIGEgXCJmYWxzZVwiIHN0cmluZy5cblxudmFyIEJPT0xFQU5JU0hfU1RSSU5HID0gMjsgLy8gQSByZWFsIGJvb2xlYW4gYXR0cmlidXRlLlxuLy8gV2hlbiB0cnVlLCBpdCBzaG91bGQgYmUgcHJlc2VudCAoc2V0IGVpdGhlciB0byBhbiBlbXB0eSBzdHJpbmcgb3IgaXRzIG5hbWUpLlxuLy8gV2hlbiBmYWxzZSwgaXQgc2hvdWxkIGJlIG9taXR0ZWQuXG5cbnZhciBCT09MRUFOID0gMzsgLy8gQW4gYXR0cmlidXRlIHRoYXQgY2FuIGJlIHVzZWQgYXMgYSBmbGFnIGFzIHdlbGwgYXMgd2l0aCBhIHZhbHVlLlxuLy8gV2hlbiB0cnVlLCBpdCBzaG91bGQgYmUgcHJlc2VudCAoc2V0IGVpdGhlciB0byBhbiBlbXB0eSBzdHJpbmcgb3IgaXRzIG5hbWUpLlxuLy8gV2hlbiBmYWxzZSwgaXQgc2hvdWxkIGJlIG9taXR0ZWQuXG4vLyBGb3IgYW55IG90aGVyIHZhbHVlLCBzaG91bGQgYmUgcHJlc2VudCB3aXRoIHRoYXQgdmFsdWUuXG5cbnZhciBPVkVSTE9BREVEX0JPT0xFQU4gPSA0OyAvLyBBbiBhdHRyaWJ1dGUgdGhhdCBtdXN0IGJlIG51bWVyaWMgb3IgcGFyc2UgYXMgYSBudW1lcmljLlxuLy8gV2hlbiBmYWxzeSwgaXQgc2hvdWxkIGJlIHJlbW92ZWQuXG5cbnZhciBOVU1FUklDID0gNTsgLy8gQW4gYXR0cmlidXRlIHRoYXQgbXVzdCBiZSBwb3NpdGl2ZSBudW1lcmljIG9yIHBhcnNlIGFzIGEgcG9zaXRpdmUgbnVtZXJpYy5cbi8vIFdoZW4gZmFsc3ksIGl0IHNob3VsZCBiZSByZW1vdmVkLlxuXG52YXIgUE9TSVRJVkVfTlVNRVJJQyA9IDY7XG5cbi8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4gKi9cbnZhciBBVFRSSUJVVEVfTkFNRV9TVEFSVF9DSEFSID0gXCI6QS1aX2EtelxcXFx1MDBDMC1cXFxcdTAwRDZcXFxcdTAwRDgtXFxcXHUwMEY2XFxcXHUwMEY4LVxcXFx1MDJGRlxcXFx1MDM3MC1cXFxcdTAzN0RcXFxcdTAzN0YtXFxcXHUxRkZGXFxcXHUyMDBDLVxcXFx1MjAwRFxcXFx1MjA3MC1cXFxcdTIxOEZcXFxcdTJDMDAtXFxcXHUyRkVGXFxcXHUzMDAxLVxcXFx1RDdGRlxcXFx1RjkwMC1cXFxcdUZEQ0ZcXFxcdUZERjAtXFxcXHVGRkZEXCI7XG4vKiBlc2xpbnQtZW5hYmxlIG1heC1sZW4gKi9cblxudmFyIEFUVFJJQlVURV9OQU1FX0NIQVIgPSBBVFRSSUJVVEVfTkFNRV9TVEFSVF9DSEFSICsgXCJcXFxcLS4wLTlcXFxcdTAwQjdcXFxcdTAzMDAtXFxcXHUwMzZGXFxcXHUyMDNGLVxcXFx1MjA0MFwiO1xudmFyIFJPT1RfQVRUUklCVVRFX05BTUUgPSAnZGF0YS1yZWFjdHJvb3QnO1xudmFyIFZBTElEX0FUVFJJQlVURV9OQU1FX1JFR0VYID0gbmV3IFJlZ0V4cCgnXlsnICsgQVRUUklCVVRFX05BTUVfU1RBUlRfQ0hBUiArICddWycgKyBBVFRSSUJVVEVfTkFNRV9DSEFSICsgJ10qJCcpO1xudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBpbGxlZ2FsQXR0cmlidXRlTmFtZUNhY2hlID0ge307XG52YXIgdmFsaWRhdGVkQXR0cmlidXRlTmFtZUNhY2hlID0ge307XG5mdW5jdGlvbiBpc0F0dHJpYnV0ZU5hbWVTYWZlKGF0dHJpYnV0ZU5hbWUpIHtcbiAgaWYgKGhhc093blByb3BlcnR5LmNhbGwodmFsaWRhdGVkQXR0cmlidXRlTmFtZUNhY2hlLCBhdHRyaWJ1dGVOYW1lKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoaWxsZWdhbEF0dHJpYnV0ZU5hbWVDYWNoZSwgYXR0cmlidXRlTmFtZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoVkFMSURfQVRUUklCVVRFX05BTUVfUkVHRVgudGVzdChhdHRyaWJ1dGVOYW1lKSkge1xuICAgIHZhbGlkYXRlZEF0dHJpYnV0ZU5hbWVDYWNoZVthdHRyaWJ1dGVOYW1lXSA9IHRydWU7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpbGxlZ2FsQXR0cmlidXRlTmFtZUNhY2hlW2F0dHJpYnV0ZU5hbWVdID0gdHJ1ZTtcblxuICB7XG4gICAgZXJyb3IoJ0ludmFsaWQgYXR0cmlidXRlIG5hbWU6IGAlc2AnLCBhdHRyaWJ1dGVOYW1lKTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIHNob3VsZElnbm9yZUF0dHJpYnV0ZShuYW1lLCBwcm9wZXJ0eUluZm8sIGlzQ3VzdG9tQ29tcG9uZW50VGFnKSB7XG4gIGlmIChwcm9wZXJ0eUluZm8gIT09IG51bGwpIHtcbiAgICByZXR1cm4gcHJvcGVydHlJbmZvLnR5cGUgPT09IFJFU0VSVkVEO1xuICB9XG5cbiAgaWYgKGlzQ3VzdG9tQ29tcG9uZW50VGFnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKG5hbWUubGVuZ3RoID4gMiAmJiAobmFtZVswXSA9PT0gJ28nIHx8IG5hbWVbMF0gPT09ICdPJykgJiYgKG5hbWVbMV0gPT09ICduJyB8fCBuYW1lWzFdID09PSAnTicpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBzaG91bGRSZW1vdmVBdHRyaWJ1dGVXaXRoV2FybmluZyhuYW1lLCB2YWx1ZSwgcHJvcGVydHlJbmZvLCBpc0N1c3RvbUNvbXBvbmVudFRhZykge1xuICBpZiAocHJvcGVydHlJbmZvICE9PSBudWxsICYmIHByb3BlcnR5SW5mby50eXBlID09PSBSRVNFUlZFRCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHN3aXRjaCAodHlwZW9mIHZhbHVlKSB7XG4gICAgY2FzZSAnZnVuY3Rpb24nOiAvLyAkRmxvd0lzc3VlIHN5bWJvbCBpcyBwZXJmZWN0bHkgdmFsaWQgaGVyZVxuXG4gICAgY2FzZSAnc3ltYm9sJzpcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICAgIHJldHVybiB0cnVlO1xuXG4gICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICB7XG4gICAgICAgIGlmIChpc0N1c3RvbUNvbXBvbmVudFRhZykge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwcm9wZXJ0eUluZm8gIT09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gIXByb3BlcnR5SW5mby5hY2NlcHRzQm9vbGVhbnM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIHByZWZpeCA9IG5hbWUudG9Mb3dlckNhc2UoKS5zbGljZSgwLCA1KTtcbiAgICAgICAgICByZXR1cm4gcHJlZml4ICE9PSAnZGF0YS0nICYmIHByZWZpeCAhPT0gJ2FyaWEtJztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuZnVuY3Rpb24gc2hvdWxkUmVtb3ZlQXR0cmlidXRlKG5hbWUsIHZhbHVlLCBwcm9wZXJ0eUluZm8sIGlzQ3VzdG9tQ29tcG9uZW50VGFnKSB7XG4gIGlmICh2YWx1ZSA9PT0gbnVsbCB8fCB0eXBlb2YgdmFsdWUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAoc2hvdWxkUmVtb3ZlQXR0cmlidXRlV2l0aFdhcm5pbmcobmFtZSwgdmFsdWUsIHByb3BlcnR5SW5mbywgaXNDdXN0b21Db21wb25lbnRUYWcpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAoaXNDdXN0b21Db21wb25lbnRUYWcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAocHJvcGVydHlJbmZvICE9PSBudWxsKSB7XG5cbiAgICBzd2l0Y2ggKHByb3BlcnR5SW5mby50eXBlKSB7XG4gICAgICBjYXNlIEJPT0xFQU46XG4gICAgICAgIHJldHVybiAhdmFsdWU7XG5cbiAgICAgIGNhc2UgT1ZFUkxPQURFRF9CT09MRUFOOlxuICAgICAgICByZXR1cm4gdmFsdWUgPT09IGZhbHNlO1xuXG4gICAgICBjYXNlIE5VTUVSSUM6XG4gICAgICAgIHJldHVybiBpc05hTih2YWx1ZSk7XG5cbiAgICAgIGNhc2UgUE9TSVRJVkVfTlVNRVJJQzpcbiAgICAgICAgcmV0dXJuIGlzTmFOKHZhbHVlKSB8fCB2YWx1ZSA8IDE7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gZ2V0UHJvcGVydHlJbmZvKG5hbWUpIHtcbiAgcmV0dXJuIHByb3BlcnRpZXMuaGFzT3duUHJvcGVydHkobmFtZSkgPyBwcm9wZXJ0aWVzW25hbWVdIDogbnVsbDtcbn1cblxuZnVuY3Rpb24gUHJvcGVydHlJbmZvUmVjb3JkKG5hbWUsIHR5cGUsIG11c3RVc2VQcm9wZXJ0eSwgYXR0cmlidXRlTmFtZSwgYXR0cmlidXRlTmFtZXNwYWNlLCBzYW5pdGl6ZVVSTCwgcmVtb3ZlRW1wdHlTdHJpbmcpIHtcbiAgdGhpcy5hY2NlcHRzQm9vbGVhbnMgPSB0eXBlID09PSBCT09MRUFOSVNIX1NUUklORyB8fCB0eXBlID09PSBCT09MRUFOIHx8IHR5cGUgPT09IE9WRVJMT0FERURfQk9PTEVBTjtcbiAgdGhpcy5hdHRyaWJ1dGVOYW1lID0gYXR0cmlidXRlTmFtZTtcbiAgdGhpcy5hdHRyaWJ1dGVOYW1lc3BhY2UgPSBhdHRyaWJ1dGVOYW1lc3BhY2U7XG4gIHRoaXMubXVzdFVzZVByb3BlcnR5ID0gbXVzdFVzZVByb3BlcnR5O1xuICB0aGlzLnByb3BlcnR5TmFtZSA9IG5hbWU7XG4gIHRoaXMudHlwZSA9IHR5cGU7XG4gIHRoaXMuc2FuaXRpemVVUkwgPSBzYW5pdGl6ZVVSTDtcbiAgdGhpcy5yZW1vdmVFbXB0eVN0cmluZyA9IHJlbW92ZUVtcHR5U3RyaW5nO1xufSAvLyBXaGVuIGFkZGluZyBhdHRyaWJ1dGVzIHRvIHRoaXMgbGlzdCwgYmUgc3VyZSB0byBhbHNvIGFkZCB0aGVtIHRvXG4vLyB0aGUgYHBvc3NpYmxlU3RhbmRhcmROYW1lc2AgbW9kdWxlIHRvIGVuc3VyZSBjYXNpbmcgYW5kIGluY29ycmVjdFxuLy8gbmFtZSB3YXJuaW5ncy5cblxuXG52YXIgcHJvcGVydGllcyA9IHt9OyAvLyBUaGVzZSBwcm9wcyBhcmUgcmVzZXJ2ZWQgYnkgUmVhY3QuIFRoZXkgc2hvdWxkbid0IGJlIHdyaXR0ZW4gdG8gdGhlIERPTS5cblxudmFyIHJlc2VydmVkUHJvcHMgPSBbJ2NoaWxkcmVuJywgJ2Rhbmdlcm91c2x5U2V0SW5uZXJIVE1MJywgLy8gVE9ETzogVGhpcyBwcmV2ZW50cyB0aGUgYXNzaWdubWVudCBvZiBkZWZhdWx0VmFsdWUgdG8gcmVndWxhclxuLy8gZWxlbWVudHMgKG5vdCBqdXN0IGlucHV0cykuIE5vdyB0aGF0IFJlYWN0RE9NSW5wdXQgYXNzaWducyB0byB0aGVcbi8vIGRlZmF1bHRWYWx1ZSBwcm9wZXJ0eSAtLSBkbyB3ZSBuZWVkIHRoaXM/XG4nZGVmYXVsdFZhbHVlJywgJ2RlZmF1bHRDaGVja2VkJywgJ2lubmVySFRNTCcsICdzdXBwcmVzc0NvbnRlbnRFZGl0YWJsZVdhcm5pbmcnLCAnc3VwcHJlc3NIeWRyYXRpb25XYXJuaW5nJywgJ3N0eWxlJ107XG5yZXNlcnZlZFByb3BzLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgcHJvcGVydGllc1tuYW1lXSA9IG5ldyBQcm9wZXJ0eUluZm9SZWNvcmQobmFtZSwgUkVTRVJWRUQsIGZhbHNlLCAvLyBtdXN0VXNlUHJvcGVydHlcbiAgbmFtZSwgLy8gYXR0cmlidXRlTmFtZVxuICBudWxsLCAvLyBhdHRyaWJ1dGVOYW1lc3BhY2VcbiAgZmFsc2UsIC8vIHNhbml0aXplVVJMXG4gIGZhbHNlKTtcbn0pOyAvLyBBIGZldyBSZWFjdCBzdHJpbmcgYXR0cmlidXRlcyBoYXZlIGEgZGlmZmVyZW50IG5hbWUuXG4vLyBUaGlzIGlzIGEgbWFwcGluZyBmcm9tIFJlYWN0IHByb3AgbmFtZXMgdG8gdGhlIGF0dHJpYnV0ZSBuYW1lcy5cblxuW1snYWNjZXB0Q2hhcnNldCcsICdhY2NlcHQtY2hhcnNldCddLCBbJ2NsYXNzTmFtZScsICdjbGFzcyddLCBbJ2h0bWxGb3InLCAnZm9yJ10sIFsnaHR0cEVxdWl2JywgJ2h0dHAtZXF1aXYnXV0uZm9yRWFjaChmdW5jdGlvbiAoX3JlZikge1xuICB2YXIgbmFtZSA9IF9yZWZbMF0sXG4gICAgICBhdHRyaWJ1dGVOYW1lID0gX3JlZlsxXTtcbiAgcHJvcGVydGllc1tuYW1lXSA9IG5ldyBQcm9wZXJ0eUluZm9SZWNvcmQobmFtZSwgU1RSSU5HLCBmYWxzZSwgLy8gbXVzdFVzZVByb3BlcnR5XG4gIGF0dHJpYnV0ZU5hbWUsIC8vIGF0dHJpYnV0ZU5hbWVcbiAgbnVsbCwgLy8gYXR0cmlidXRlTmFtZXNwYWNlXG4gIGZhbHNlLCAvLyBzYW5pdGl6ZVVSTFxuICBmYWxzZSk7XG59KTsgLy8gVGhlc2UgYXJlIFwiZW51bWVyYXRlZFwiIEhUTUwgYXR0cmlidXRlcyB0aGF0IGFjY2VwdCBcInRydWVcIiBhbmQgXCJmYWxzZVwiLlxuLy8gSW4gUmVhY3QsIHdlIGxldCB1c2VycyBwYXNzIGB0cnVlYCBhbmQgYGZhbHNlYCBldmVuIHRob3VnaCB0ZWNobmljYWxseVxuLy8gdGhlc2UgYXJlbid0IGJvb2xlYW4gYXR0cmlidXRlcyAodGhleSBhcmUgY29lcmNlZCB0byBzdHJpbmdzKS5cblxuWydjb250ZW50RWRpdGFibGUnLCAnZHJhZ2dhYmxlJywgJ3NwZWxsQ2hlY2snLCAndmFsdWUnXS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gIHByb3BlcnRpZXNbbmFtZV0gPSBuZXcgUHJvcGVydHlJbmZvUmVjb3JkKG5hbWUsIEJPT0xFQU5JU0hfU1RSSU5HLCBmYWxzZSwgLy8gbXVzdFVzZVByb3BlcnR5XG4gIG5hbWUudG9Mb3dlckNhc2UoKSwgLy8gYXR0cmlidXRlTmFtZVxuICBudWxsLCAvLyBhdHRyaWJ1dGVOYW1lc3BhY2VcbiAgZmFsc2UsIC8vIHNhbml0aXplVVJMXG4gIGZhbHNlKTtcbn0pOyAvLyBUaGVzZSBhcmUgXCJlbnVtZXJhdGVkXCIgU1ZHIGF0dHJpYnV0ZXMgdGhhdCBhY2NlcHQgXCJ0cnVlXCIgYW5kIFwiZmFsc2VcIi5cbi8vIEluIFJlYWN0LCB3ZSBsZXQgdXNlcnMgcGFzcyBgdHJ1ZWAgYW5kIGBmYWxzZWAgZXZlbiB0aG91Z2ggdGVjaG5pY2FsbHlcbi8vIHRoZXNlIGFyZW4ndCBib29sZWFuIGF0dHJpYnV0ZXMgKHRoZXkgYXJlIGNvZXJjZWQgdG8gc3RyaW5ncykuXG4vLyBTaW5jZSB0aGVzZSBhcmUgU1ZHIGF0dHJpYnV0ZXMsIHRoZWlyIGF0dHJpYnV0ZSBuYW1lcyBhcmUgY2FzZS1zZW5zaXRpdmUuXG5cblsnYXV0b1JldmVyc2UnLCAnZXh0ZXJuYWxSZXNvdXJjZXNSZXF1aXJlZCcsICdmb2N1c2FibGUnLCAncHJlc2VydmVBbHBoYSddLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgcHJvcGVydGllc1tuYW1lXSA9IG5ldyBQcm9wZXJ0eUluZm9SZWNvcmQobmFtZSwgQk9PTEVBTklTSF9TVFJJTkcsIGZhbHNlLCAvLyBtdXN0VXNlUHJvcGVydHlcbiAgbmFtZSwgLy8gYXR0cmlidXRlTmFtZVxuICBudWxsLCAvLyBhdHRyaWJ1dGVOYW1lc3BhY2VcbiAgZmFsc2UsIC8vIHNhbml0aXplVVJMXG4gIGZhbHNlKTtcbn0pOyAvLyBUaGVzZSBhcmUgSFRNTCBib29sZWFuIGF0dHJpYnV0ZXMuXG5cblsnYWxsb3dGdWxsU2NyZWVuJywgJ2FzeW5jJywgLy8gTm90ZTogdGhlcmUgaXMgYSBzcGVjaWFsIGNhc2UgdGhhdCBwcmV2ZW50cyBpdCBmcm9tIGJlaW5nIHdyaXR0ZW4gdG8gdGhlIERPTVxuLy8gb24gdGhlIGNsaWVudCBzaWRlIGJlY2F1c2UgdGhlIGJyb3dzZXJzIGFyZSBpbmNvbnNpc3RlbnQuIEluc3RlYWQgd2UgY2FsbCBmb2N1cygpLlxuJ2F1dG9Gb2N1cycsICdhdXRvUGxheScsICdjb250cm9scycsICdkZWZhdWx0JywgJ2RlZmVyJywgJ2Rpc2FibGVkJywgJ2Rpc2FibGVQaWN0dXJlSW5QaWN0dXJlJywgJ2Rpc2FibGVSZW1vdGVQbGF5YmFjaycsICdmb3JtTm9WYWxpZGF0ZScsICdoaWRkZW4nLCAnbG9vcCcsICdub01vZHVsZScsICdub1ZhbGlkYXRlJywgJ29wZW4nLCAncGxheXNJbmxpbmUnLCAncmVhZE9ubHknLCAncmVxdWlyZWQnLCAncmV2ZXJzZWQnLCAnc2NvcGVkJywgJ3NlYW1sZXNzJywgLy8gTWljcm9kYXRhXG4naXRlbVNjb3BlJ10uZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICBwcm9wZXJ0aWVzW25hbWVdID0gbmV3IFByb3BlcnR5SW5mb1JlY29yZChuYW1lLCBCT09MRUFOLCBmYWxzZSwgLy8gbXVzdFVzZVByb3BlcnR5XG4gIG5hbWUudG9Mb3dlckNhc2UoKSwgLy8gYXR0cmlidXRlTmFtZVxuICBudWxsLCAvLyBhdHRyaWJ1dGVOYW1lc3BhY2VcbiAgZmFsc2UsIC8vIHNhbml0aXplVVJMXG4gIGZhbHNlKTtcbn0pOyAvLyBUaGVzZSBhcmUgdGhlIGZldyBSZWFjdCBwcm9wcyB0aGF0IHdlIHNldCBhcyBET00gcHJvcGVydGllc1xuLy8gcmF0aGVyIHRoYW4gYXR0cmlidXRlcy4gVGhlc2UgYXJlIGFsbCBib29sZWFucy5cblxuWydjaGVja2VkJywgLy8gTm90ZTogYG9wdGlvbi5zZWxlY3RlZGAgaXMgbm90IHVwZGF0ZWQgaWYgYHNlbGVjdC5tdWx0aXBsZWAgaXNcbi8vIGRpc2FibGVkIHdpdGggYHJlbW92ZUF0dHJpYnV0ZWAuIFdlIGhhdmUgc3BlY2lhbCBsb2dpYyBmb3IgaGFuZGxpbmcgdGhpcy5cbidtdWx0aXBsZScsICdtdXRlZCcsICdzZWxlY3RlZCcgLy8gTk9URTogaWYgeW91IGFkZCBhIGNhbWVsQ2FzZWQgcHJvcCB0byB0aGlzIGxpc3QsXG4vLyB5b3UnbGwgbmVlZCB0byBzZXQgYXR0cmlidXRlTmFtZSB0byBuYW1lLnRvTG93ZXJDYXNlKClcbi8vIGluc3RlYWQgaW4gdGhlIGFzc2lnbm1lbnQgYmVsb3cuXG5dLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgcHJvcGVydGllc1tuYW1lXSA9IG5ldyBQcm9wZXJ0eUluZm9SZWNvcmQobmFtZSwgQk9PTEVBTiwgdHJ1ZSwgLy8gbXVzdFVzZVByb3BlcnR5XG4gIG5hbWUsIC8vIGF0dHJpYnV0ZU5hbWVcbiAgbnVsbCwgLy8gYXR0cmlidXRlTmFtZXNwYWNlXG4gIGZhbHNlLCAvLyBzYW5pdGl6ZVVSTFxuICBmYWxzZSk7XG59KTsgLy8gVGhlc2UgYXJlIEhUTUwgYXR0cmlidXRlcyB0aGF0IGFyZSBcIm92ZXJsb2FkZWQgYm9vbGVhbnNcIjogdGhleSBiZWhhdmUgbGlrZVxuLy8gYm9vbGVhbnMsIGJ1dCBjYW4gYWxzbyBhY2NlcHQgYSBzdHJpbmcgdmFsdWUuXG5cblsnY2FwdHVyZScsICdkb3dubG9hZCcgLy8gTk9URTogaWYgeW91IGFkZCBhIGNhbWVsQ2FzZWQgcHJvcCB0byB0aGlzIGxpc3QsXG4vLyB5b3UnbGwgbmVlZCB0byBzZXQgYXR0cmlidXRlTmFtZSB0byBuYW1lLnRvTG93ZXJDYXNlKClcbi8vIGluc3RlYWQgaW4gdGhlIGFzc2lnbm1lbnQgYmVsb3cuXG5dLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgcHJvcGVydGllc1tuYW1lXSA9IG5ldyBQcm9wZXJ0eUluZm9SZWNvcmQobmFtZSwgT1ZFUkxPQURFRF9CT09MRUFOLCBmYWxzZSwgLy8gbXVzdFVzZVByb3BlcnR5XG4gIG5hbWUsIC8vIGF0dHJpYnV0ZU5hbWVcbiAgbnVsbCwgLy8gYXR0cmlidXRlTmFtZXNwYWNlXG4gIGZhbHNlLCAvLyBzYW5pdGl6ZVVSTFxuICBmYWxzZSk7XG59KTsgLy8gVGhlc2UgYXJlIEhUTUwgYXR0cmlidXRlcyB0aGF0IG11c3QgYmUgcG9zaXRpdmUgbnVtYmVycy5cblxuWydjb2xzJywgJ3Jvd3MnLCAnc2l6ZScsICdzcGFuJyAvLyBOT1RFOiBpZiB5b3UgYWRkIGEgY2FtZWxDYXNlZCBwcm9wIHRvIHRoaXMgbGlzdCxcbi8vIHlvdSdsbCBuZWVkIHRvIHNldCBhdHRyaWJ1dGVOYW1lIHRvIG5hbWUudG9Mb3dlckNhc2UoKVxuLy8gaW5zdGVhZCBpbiB0aGUgYXNzaWdubWVudCBiZWxvdy5cbl0uZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICBwcm9wZXJ0aWVzW25hbWVdID0gbmV3IFByb3BlcnR5SW5mb1JlY29yZChuYW1lLCBQT1NJVElWRV9OVU1FUklDLCBmYWxzZSwgLy8gbXVzdFVzZVByb3BlcnR5XG4gIG5hbWUsIC8vIGF0dHJpYnV0ZU5hbWVcbiAgbnVsbCwgLy8gYXR0cmlidXRlTmFtZXNwYWNlXG4gIGZhbHNlLCAvLyBzYW5pdGl6ZVVSTFxuICBmYWxzZSk7XG59KTsgLy8gVGhlc2UgYXJlIEhUTUwgYXR0cmlidXRlcyB0aGF0IG11c3QgYmUgbnVtYmVycy5cblxuWydyb3dTcGFuJywgJ3N0YXJ0J10uZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICBwcm9wZXJ0aWVzW25hbWVdID0gbmV3IFByb3BlcnR5SW5mb1JlY29yZChuYW1lLCBOVU1FUklDLCBmYWxzZSwgLy8gbXVzdFVzZVByb3BlcnR5XG4gIG5hbWUudG9Mb3dlckNhc2UoKSwgLy8gYXR0cmlidXRlTmFtZVxuICBudWxsLCAvLyBhdHRyaWJ1dGVOYW1lc3BhY2VcbiAgZmFsc2UsIC8vIHNhbml0aXplVVJMXG4gIGZhbHNlKTtcbn0pO1xudmFyIENBTUVMSVpFID0gL1tcXC1cXDpdKFthLXpdKS9nO1xuXG52YXIgY2FwaXRhbGl6ZSA9IGZ1bmN0aW9uICh0b2tlbikge1xuICByZXR1cm4gdG9rZW5bMV0udG9VcHBlckNhc2UoKTtcbn07IC8vIFRoaXMgaXMgYSBsaXN0IG9mIGFsbCBTVkcgYXR0cmlidXRlcyB0aGF0IG5lZWQgc3BlY2lhbCBjYXNpbmcsIG5hbWVzcGFjaW5nLFxuLy8gb3IgYm9vbGVhbiB2YWx1ZSBhc3NpZ25tZW50LiBSZWd1bGFyIGF0dHJpYnV0ZXMgdGhhdCBqdXN0IGFjY2VwdCBzdHJpbmdzXG4vLyBhbmQgaGF2ZSB0aGUgc2FtZSBuYW1lcyBhcmUgb21pdHRlZCwganVzdCBsaWtlIGluIHRoZSBIVE1MIGF0dHJpYnV0ZSBmaWx0ZXIuXG4vLyBTb21lIG9mIHRoZXNlIGF0dHJpYnV0ZXMgY2FuIGJlIGhhcmQgdG8gZmluZC4gVGhpcyBsaXN0IHdhcyBjcmVhdGVkIGJ5XG4vLyBzY3JhcGluZyB0aGUgTUROIGRvY3VtZW50YXRpb24uXG5cblxuWydhY2NlbnQtaGVpZ2h0JywgJ2FsaWdubWVudC1iYXNlbGluZScsICdhcmFiaWMtZm9ybScsICdiYXNlbGluZS1zaGlmdCcsICdjYXAtaGVpZ2h0JywgJ2NsaXAtcGF0aCcsICdjbGlwLXJ1bGUnLCAnY29sb3ItaW50ZXJwb2xhdGlvbicsICdjb2xvci1pbnRlcnBvbGF0aW9uLWZpbHRlcnMnLCAnY29sb3ItcHJvZmlsZScsICdjb2xvci1yZW5kZXJpbmcnLCAnZG9taW5hbnQtYmFzZWxpbmUnLCAnZW5hYmxlLWJhY2tncm91bmQnLCAnZmlsbC1vcGFjaXR5JywgJ2ZpbGwtcnVsZScsICdmbG9vZC1jb2xvcicsICdmbG9vZC1vcGFjaXR5JywgJ2ZvbnQtZmFtaWx5JywgJ2ZvbnQtc2l6ZScsICdmb250LXNpemUtYWRqdXN0JywgJ2ZvbnQtc3RyZXRjaCcsICdmb250LXN0eWxlJywgJ2ZvbnQtdmFyaWFudCcsICdmb250LXdlaWdodCcsICdnbHlwaC1uYW1lJywgJ2dseXBoLW9yaWVudGF0aW9uLWhvcml6b250YWwnLCAnZ2x5cGgtb3JpZW50YXRpb24tdmVydGljYWwnLCAnaG9yaXotYWR2LXgnLCAnaG9yaXotb3JpZ2luLXgnLCAnaW1hZ2UtcmVuZGVyaW5nJywgJ2xldHRlci1zcGFjaW5nJywgJ2xpZ2h0aW5nLWNvbG9yJywgJ21hcmtlci1lbmQnLCAnbWFya2VyLW1pZCcsICdtYXJrZXItc3RhcnQnLCAnb3ZlcmxpbmUtcG9zaXRpb24nLCAnb3ZlcmxpbmUtdGhpY2tuZXNzJywgJ3BhaW50LW9yZGVyJywgJ3Bhbm9zZS0xJywgJ3BvaW50ZXItZXZlbnRzJywgJ3JlbmRlcmluZy1pbnRlbnQnLCAnc2hhcGUtcmVuZGVyaW5nJywgJ3N0b3AtY29sb3InLCAnc3RvcC1vcGFjaXR5JywgJ3N0cmlrZXRocm91Z2gtcG9zaXRpb24nLCAnc3RyaWtldGhyb3VnaC10aGlja25lc3MnLCAnc3Ryb2tlLWRhc2hhcnJheScsICdzdHJva2UtZGFzaG9mZnNldCcsICdzdHJva2UtbGluZWNhcCcsICdzdHJva2UtbGluZWpvaW4nLCAnc3Ryb2tlLW1pdGVybGltaXQnLCAnc3Ryb2tlLW9wYWNpdHknLCAnc3Ryb2tlLXdpZHRoJywgJ3RleHQtYW5jaG9yJywgJ3RleHQtZGVjb3JhdGlvbicsICd0ZXh0LXJlbmRlcmluZycsICd1bmRlcmxpbmUtcG9zaXRpb24nLCAndW5kZXJsaW5lLXRoaWNrbmVzcycsICd1bmljb2RlLWJpZGknLCAndW5pY29kZS1yYW5nZScsICd1bml0cy1wZXItZW0nLCAndi1hbHBoYWJldGljJywgJ3YtaGFuZ2luZycsICd2LWlkZW9ncmFwaGljJywgJ3YtbWF0aGVtYXRpY2FsJywgJ3ZlY3Rvci1lZmZlY3QnLCAndmVydC1hZHYteScsICd2ZXJ0LW9yaWdpbi14JywgJ3ZlcnQtb3JpZ2luLXknLCAnd29yZC1zcGFjaW5nJywgJ3dyaXRpbmctbW9kZScsICd4bWxuczp4bGluaycsICd4LWhlaWdodCcgLy8gTk9URTogaWYgeW91IGFkZCBhIGNhbWVsQ2FzZWQgcHJvcCB0byB0aGlzIGxpc3QsXG4vLyB5b3UnbGwgbmVlZCB0byBzZXQgYXR0cmlidXRlTmFtZSB0byBuYW1lLnRvTG93ZXJDYXNlKClcbi8vIGluc3RlYWQgaW4gdGhlIGFzc2lnbm1lbnQgYmVsb3cuXG5dLmZvckVhY2goZnVuY3Rpb24gKGF0dHJpYnV0ZU5hbWUpIHtcbiAgdmFyIG5hbWUgPSBhdHRyaWJ1dGVOYW1lLnJlcGxhY2UoQ0FNRUxJWkUsIGNhcGl0YWxpemUpO1xuICBwcm9wZXJ0aWVzW25hbWVdID0gbmV3IFByb3BlcnR5SW5mb1JlY29yZChuYW1lLCBTVFJJTkcsIGZhbHNlLCAvLyBtdXN0VXNlUHJvcGVydHlcbiAgYXR0cmlidXRlTmFtZSwgbnVsbCwgLy8gYXR0cmlidXRlTmFtZXNwYWNlXG4gIGZhbHNlLCAvLyBzYW5pdGl6ZVVSTFxuICBmYWxzZSk7XG59KTsgLy8gU3RyaW5nIFNWRyBhdHRyaWJ1dGVzIHdpdGggdGhlIHhsaW5rIG5hbWVzcGFjZS5cblxuWyd4bGluazphY3R1YXRlJywgJ3hsaW5rOmFyY3JvbGUnLCAneGxpbms6cm9sZScsICd4bGluazpzaG93JywgJ3hsaW5rOnRpdGxlJywgJ3hsaW5rOnR5cGUnIC8vIE5PVEU6IGlmIHlvdSBhZGQgYSBjYW1lbENhc2VkIHByb3AgdG8gdGhpcyBsaXN0LFxuLy8geW91J2xsIG5lZWQgdG8gc2V0IGF0dHJpYnV0ZU5hbWUgdG8gbmFtZS50b0xvd2VyQ2FzZSgpXG4vLyBpbnN0ZWFkIGluIHRoZSBhc3NpZ25tZW50IGJlbG93LlxuXS5mb3JFYWNoKGZ1bmN0aW9uIChhdHRyaWJ1dGVOYW1lKSB7XG4gIHZhciBuYW1lID0gYXR0cmlidXRlTmFtZS5yZXBsYWNlKENBTUVMSVpFLCBjYXBpdGFsaXplKTtcbiAgcHJvcGVydGllc1tuYW1lXSA9IG5ldyBQcm9wZXJ0eUluZm9SZWNvcmQobmFtZSwgU1RSSU5HLCBmYWxzZSwgLy8gbXVzdFVzZVByb3BlcnR5XG4gIGF0dHJpYnV0ZU5hbWUsICdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rJywgZmFsc2UsIC8vIHNhbml0aXplVVJMXG4gIGZhbHNlKTtcbn0pOyAvLyBTdHJpbmcgU1ZHIGF0dHJpYnV0ZXMgd2l0aCB0aGUgeG1sIG5hbWVzcGFjZS5cblxuWyd4bWw6YmFzZScsICd4bWw6bGFuZycsICd4bWw6c3BhY2UnIC8vIE5PVEU6IGlmIHlvdSBhZGQgYSBjYW1lbENhc2VkIHByb3AgdG8gdGhpcyBsaXN0LFxuLy8geW91J2xsIG5lZWQgdG8gc2V0IGF0dHJpYnV0ZU5hbWUgdG8gbmFtZS50b0xvd2VyQ2FzZSgpXG4vLyBpbnN0ZWFkIGluIHRoZSBhc3NpZ25tZW50IGJlbG93LlxuXS5mb3JFYWNoKGZ1bmN0aW9uIChhdHRyaWJ1dGVOYW1lKSB7XG4gIHZhciBuYW1lID0gYXR0cmlidXRlTmFtZS5yZXBsYWNlKENBTUVMSVpFLCBjYXBpdGFsaXplKTtcbiAgcHJvcGVydGllc1tuYW1lXSA9IG5ldyBQcm9wZXJ0eUluZm9SZWNvcmQobmFtZSwgU1RSSU5HLCBmYWxzZSwgLy8gbXVzdFVzZVByb3BlcnR5XG4gIGF0dHJpYnV0ZU5hbWUsICdodHRwOi8vd3d3LnczLm9yZy9YTUwvMTk5OC9uYW1lc3BhY2UnLCBmYWxzZSwgLy8gc2FuaXRpemVVUkxcbiAgZmFsc2UpO1xufSk7IC8vIFRoZXNlIGF0dHJpYnV0ZSBleGlzdHMgYm90aCBpbiBIVE1MIGFuZCBTVkcuXG4vLyBUaGUgYXR0cmlidXRlIG5hbWUgaXMgY2FzZS1zZW5zaXRpdmUgaW4gU1ZHIHNvIHdlIGNhbid0IGp1c3QgdXNlXG4vLyB0aGUgUmVhY3QgbmFtZSBsaWtlIHdlIGRvIGZvciBhdHRyaWJ1dGVzIHRoYXQgZXhpc3Qgb25seSBpbiBIVE1MLlxuXG5bJ3RhYkluZGV4JywgJ2Nyb3NzT3JpZ2luJ10uZm9yRWFjaChmdW5jdGlvbiAoYXR0cmlidXRlTmFtZSkge1xuICBwcm9wZXJ0aWVzW2F0dHJpYnV0ZU5hbWVdID0gbmV3IFByb3BlcnR5SW5mb1JlY29yZChhdHRyaWJ1dGVOYW1lLCBTVFJJTkcsIGZhbHNlLCAvLyBtdXN0VXNlUHJvcGVydHlcbiAgYXR0cmlidXRlTmFtZS50b0xvd2VyQ2FzZSgpLCAvLyBhdHRyaWJ1dGVOYW1lXG4gIG51bGwsIC8vIGF0dHJpYnV0ZU5hbWVzcGFjZVxuICBmYWxzZSwgLy8gc2FuaXRpemVVUkxcbiAgZmFsc2UpO1xufSk7IC8vIFRoZXNlIGF0dHJpYnV0ZXMgYWNjZXB0IFVSTHMuIFRoZXNlIG11c3Qgbm90IGFsbG93IGphdmFzY3JpcHQ6IFVSTFMuXG4vLyBUaGVzZSB3aWxsIGFsc28gbmVlZCB0byBhY2NlcHQgVHJ1c3RlZCBUeXBlcyBvYmplY3QgaW4gdGhlIGZ1dHVyZS5cblxudmFyIHhsaW5rSHJlZiA9ICd4bGlua0hyZWYnO1xucHJvcGVydGllc1t4bGlua0hyZWZdID0gbmV3IFByb3BlcnR5SW5mb1JlY29yZCgneGxpbmtIcmVmJywgU1RSSU5HLCBmYWxzZSwgLy8gbXVzdFVzZVByb3BlcnR5XG4neGxpbms6aHJlZicsICdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rJywgdHJ1ZSwgLy8gc2FuaXRpemVVUkxcbmZhbHNlKTtcblsnc3JjJywgJ2hyZWYnLCAnYWN0aW9uJywgJ2Zvcm1BY3Rpb24nXS5mb3JFYWNoKGZ1bmN0aW9uIChhdHRyaWJ1dGVOYW1lKSB7XG4gIHByb3BlcnRpZXNbYXR0cmlidXRlTmFtZV0gPSBuZXcgUHJvcGVydHlJbmZvUmVjb3JkKGF0dHJpYnV0ZU5hbWUsIFNUUklORywgZmFsc2UsIC8vIG11c3RVc2VQcm9wZXJ0eVxuICBhdHRyaWJ1dGVOYW1lLnRvTG93ZXJDYXNlKCksIC8vIGF0dHJpYnV0ZU5hbWVcbiAgbnVsbCwgLy8gYXR0cmlidXRlTmFtZXNwYWNlXG4gIHRydWUsIC8vIHNhbml0aXplVVJMXG4gIHRydWUpO1xufSk7XG5cbi8vIGFuZCBhbnkgbmV3bGluZSBvciB0YWIgYXJlIGZpbHRlcmVkIG91dCBhcyBpZiB0aGV5J3JlIG5vdCBwYXJ0IG9mIHRoZSBVUkwuXG4vLyBodHRwczovL3VybC5zcGVjLndoYXR3Zy5vcmcvI3VybC1wYXJzaW5nXG4vLyBUYWIgb3IgbmV3bGluZSBhcmUgZGVmaW5lZCBhcyBcXHJcXG5cXHQ6XG4vLyBodHRwczovL2luZnJhLnNwZWMud2hhdHdnLm9yZy8jYXNjaWktdGFiLW9yLW5ld2xpbmVcbi8vIEEgQzAgY29udHJvbCBpcyBhIGNvZGUgcG9pbnQgaW4gdGhlIHJhbmdlIFxcdTAwMDAgTlVMTCB0byBcXHUwMDFGXG4vLyBJTkZPUk1BVElPTiBTRVBBUkFUT1IgT05FLCBpbmNsdXNpdmU6XG4vLyBodHRwczovL2luZnJhLnNwZWMud2hhdHdnLm9yZy8jYzAtY29udHJvbC1vci1zcGFjZVxuXG4vKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuICovXG5cbnZhciBpc0phdmFTY3JpcHRQcm90b2NvbCA9IC9eW1xcdTAwMDAtXFx1MDAxRiBdKmpbXFxyXFxuXFx0XSphW1xcclxcblxcdF0qdltcXHJcXG5cXHRdKmFbXFxyXFxuXFx0XSpzW1xcclxcblxcdF0qY1tcXHJcXG5cXHRdKnJbXFxyXFxuXFx0XSppW1xcclxcblxcdF0qcFtcXHJcXG5cXHRdKnRbXFxyXFxuXFx0XSpcXDovaTtcbnZhciBkaWRXYXJuID0gZmFsc2U7XG5cbmZ1bmN0aW9uIHNhbml0aXplVVJMKHVybCkge1xuICB7XG4gICAgaWYgKCFkaWRXYXJuICYmIGlzSmF2YVNjcmlwdFByb3RvY29sLnRlc3QodXJsKSkge1xuICAgICAgZGlkV2FybiA9IHRydWU7XG5cbiAgICAgIGVycm9yKCdBIGZ1dHVyZSB2ZXJzaW9uIG9mIFJlYWN0IHdpbGwgYmxvY2sgamF2YXNjcmlwdDogVVJMcyBhcyBhIHNlY3VyaXR5IHByZWNhdXRpb24uICcgKyAnVXNlIGV2ZW50IGhhbmRsZXJzIGluc3RlYWQgaWYgeW91IGNhbi4gSWYgeW91IG5lZWQgdG8gZ2VuZXJhdGUgdW5zYWZlIEhUTUwgdHJ5ICcgKyAndXNpbmcgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwgaW5zdGVhZC4gUmVhY3Qgd2FzIHBhc3NlZCAlcy4nLCBKU09OLnN0cmluZ2lmeSh1cmwpKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBHZXQgdGhlIHZhbHVlIGZvciBhIHByb3BlcnR5IG9uIGEgbm9kZS4gT25seSB1c2VkIGluIERFViBmb3IgU1NSIHZhbGlkYXRpb24uXG4gKiBUaGUgXCJleHBlY3RlZFwiIGFyZ3VtZW50IGlzIHVzZWQgYXMgYSBoaW50IG9mIHdoYXQgdGhlIGV4cGVjdGVkIHZhbHVlIGlzLlxuICogU29tZSBwcm9wZXJ0aWVzIGhhdmUgbXVsdGlwbGUgZXF1aXZhbGVudCB2YWx1ZXMuXG4gKi9cbmZ1bmN0aW9uIGdldFZhbHVlRm9yUHJvcGVydHkobm9kZSwgbmFtZSwgZXhwZWN0ZWQsIHByb3BlcnR5SW5mbykge1xuICB7XG4gICAgaWYgKHByb3BlcnR5SW5mby5tdXN0VXNlUHJvcGVydHkpIHtcbiAgICAgIHZhciBwcm9wZXJ0eU5hbWUgPSBwcm9wZXJ0eUluZm8ucHJvcGVydHlOYW1lO1xuICAgICAgcmV0dXJuIG5vZGVbcHJvcGVydHlOYW1lXTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKCBwcm9wZXJ0eUluZm8uc2FuaXRpemVVUkwpIHtcbiAgICAgICAgLy8gSWYgd2UgaGF2ZW4ndCBmdWxseSBkaXNhYmxlZCBqYXZhc2NyaXB0OiBVUkxzLCBhbmQgaWZcbiAgICAgICAgLy8gdGhlIGh5ZHJhdGlvbiBpcyBzdWNjZXNzZnVsIG9mIGEgamF2YXNjcmlwdDogVVJMLCB3ZVxuICAgICAgICAvLyBzdGlsbCB3YW50IHRvIHdhcm4gb24gdGhlIGNsaWVudC5cbiAgICAgICAgc2FuaXRpemVVUkwoJycgKyBleHBlY3RlZCk7XG4gICAgICB9XG5cbiAgICAgIHZhciBhdHRyaWJ1dGVOYW1lID0gcHJvcGVydHlJbmZvLmF0dHJpYnV0ZU5hbWU7XG4gICAgICB2YXIgc3RyaW5nVmFsdWUgPSBudWxsO1xuXG4gICAgICBpZiAocHJvcGVydHlJbmZvLnR5cGUgPT09IE9WRVJMT0FERURfQk9PTEVBTikge1xuICAgICAgICBpZiAobm9kZS5oYXNBdHRyaWJ1dGUoYXR0cmlidXRlTmFtZSkpIHtcbiAgICAgICAgICB2YXIgdmFsdWUgPSBub2RlLmdldEF0dHJpYnV0ZShhdHRyaWJ1dGVOYW1lKTtcblxuICAgICAgICAgIGlmICh2YWx1ZSA9PT0gJycpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChzaG91bGRSZW1vdmVBdHRyaWJ1dGUobmFtZSwgZXhwZWN0ZWQsIHByb3BlcnR5SW5mbywgZmFsc2UpKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHZhbHVlID09PSAnJyArIGV4cGVjdGVkKSB7XG4gICAgICAgICAgICByZXR1cm4gZXhwZWN0ZWQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKG5vZGUuaGFzQXR0cmlidXRlKGF0dHJpYnV0ZU5hbWUpKSB7XG4gICAgICAgIGlmIChzaG91bGRSZW1vdmVBdHRyaWJ1dGUobmFtZSwgZXhwZWN0ZWQsIHByb3BlcnR5SW5mbywgZmFsc2UpKSB7XG4gICAgICAgICAgLy8gV2UgaGFkIGFuIGF0dHJpYnV0ZSBidXQgc2hvdWxkbid0IGhhdmUgaGFkIG9uZSwgc28gcmVhZCBpdFxuICAgICAgICAgIC8vIGZvciB0aGUgZXJyb3IgbWVzc2FnZS5cbiAgICAgICAgICByZXR1cm4gbm9kZS5nZXRBdHRyaWJ1dGUoYXR0cmlidXRlTmFtZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocHJvcGVydHlJbmZvLnR5cGUgPT09IEJPT0xFQU4pIHtcbiAgICAgICAgICAvLyBJZiB0aGlzIHdhcyBhIGJvb2xlYW4sIGl0IGRvZXNuJ3QgbWF0dGVyIHdoYXQgdGhlIHZhbHVlIGlzXG4gICAgICAgICAgLy8gdGhlIGZhY3QgdGhhdCB3ZSBoYXZlIGl0IGlzIHRoZSBzYW1lIGFzIHRoZSBleHBlY3RlZC5cbiAgICAgICAgICByZXR1cm4gZXhwZWN0ZWQ7XG4gICAgICAgIH0gLy8gRXZlbiBpZiB0aGlzIHByb3BlcnR5IHVzZXMgYSBuYW1lc3BhY2Ugd2UgdXNlIGdldEF0dHJpYnV0ZVxuICAgICAgICAvLyBiZWNhdXNlIHdlIGFzc3VtZSBpdHMgbmFtZXNwYWNlZCBuYW1lIGlzIHRoZSBzYW1lIGFzIG91ciBjb25maWcuXG4gICAgICAgIC8vIFRvIHVzZSBnZXRBdHRyaWJ1dGVOUyB3ZSBuZWVkIHRoZSBsb2NhbCBuYW1lIHdoaWNoIHdlIGRvbid0IGhhdmVcbiAgICAgICAgLy8gaW4gb3VyIGNvbmZpZyBhdG0uXG5cblxuICAgICAgICBzdHJpbmdWYWx1ZSA9IG5vZGUuZ2V0QXR0cmlidXRlKGF0dHJpYnV0ZU5hbWUpO1xuICAgICAgfVxuXG4gICAgICBpZiAoc2hvdWxkUmVtb3ZlQXR0cmlidXRlKG5hbWUsIGV4cGVjdGVkLCBwcm9wZXJ0eUluZm8sIGZhbHNlKSkge1xuICAgICAgICByZXR1cm4gc3RyaW5nVmFsdWUgPT09IG51bGwgPyBleHBlY3RlZCA6IHN0cmluZ1ZhbHVlO1xuICAgICAgfSBlbHNlIGlmIChzdHJpbmdWYWx1ZSA9PT0gJycgKyBleHBlY3RlZCkge1xuICAgICAgICByZXR1cm4gZXhwZWN0ZWQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gc3RyaW5nVmFsdWU7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG4vKipcbiAqIEdldCB0aGUgdmFsdWUgZm9yIGEgYXR0cmlidXRlIG9uIGEgbm9kZS4gT25seSB1c2VkIGluIERFViBmb3IgU1NSIHZhbGlkYXRpb24uXG4gKiBUaGUgdGhpcmQgYXJndW1lbnQgaXMgdXNlZCBhcyBhIGhpbnQgb2Ygd2hhdCB0aGUgZXhwZWN0ZWQgdmFsdWUgaXMuIFNvbWVcbiAqIGF0dHJpYnV0ZXMgaGF2ZSBtdWx0aXBsZSBlcXVpdmFsZW50IHZhbHVlcy5cbiAqL1xuXG5mdW5jdGlvbiBnZXRWYWx1ZUZvckF0dHJpYnV0ZShub2RlLCBuYW1lLCBleHBlY3RlZCkge1xuICB7XG4gICAgaWYgKCFpc0F0dHJpYnV0ZU5hbWVTYWZlKG5hbWUpKSB7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBJZiB0aGUgb2JqZWN0IGlzIGFuIG9wYXF1ZSByZWZlcmVuY2UgSUQsIGl0J3MgZXhwZWN0ZWQgdGhhdFxuICAgIC8vIHRoZSBuZXh0IHByb3AgaXMgZGlmZmVyZW50IHRoYW4gdGhlIHNlcnZlciB2YWx1ZSwgc28ganVzdCByZXR1cm5cbiAgICAvLyBleHBlY3RlZFxuXG5cbiAgICBpZiAoaXNPcGFxdWVIeWRyYXRpbmdPYmplY3QoZXhwZWN0ZWQpKSB7XG4gICAgICByZXR1cm4gZXhwZWN0ZWQ7XG4gICAgfVxuXG4gICAgaWYgKCFub2RlLmhhc0F0dHJpYnV0ZShuYW1lKSkge1xuICAgICAgcmV0dXJuIGV4cGVjdGVkID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiBudWxsO1xuICAgIH1cblxuICAgIHZhciB2YWx1ZSA9IG5vZGUuZ2V0QXR0cmlidXRlKG5hbWUpO1xuXG4gICAgaWYgKHZhbHVlID09PSAnJyArIGV4cGVjdGVkKSB7XG4gICAgICByZXR1cm4gZXhwZWN0ZWQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG59XG4vKipcbiAqIFNldHMgdGhlIHZhbHVlIGZvciBhIHByb3BlcnR5IG9uIGEgbm9kZS5cbiAqXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR9IG5vZGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKiBAcGFyYW0geyp9IHZhbHVlXG4gKi9cblxuZnVuY3Rpb24gc2V0VmFsdWVGb3JQcm9wZXJ0eShub2RlLCBuYW1lLCB2YWx1ZSwgaXNDdXN0b21Db21wb25lbnRUYWcpIHtcbiAgdmFyIHByb3BlcnR5SW5mbyA9IGdldFByb3BlcnR5SW5mbyhuYW1lKTtcblxuICBpZiAoc2hvdWxkSWdub3JlQXR0cmlidXRlKG5hbWUsIHByb3BlcnR5SW5mbywgaXNDdXN0b21Db21wb25lbnRUYWcpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKHNob3VsZFJlbW92ZUF0dHJpYnV0ZShuYW1lLCB2YWx1ZSwgcHJvcGVydHlJbmZvLCBpc0N1c3RvbUNvbXBvbmVudFRhZykpIHtcbiAgICB2YWx1ZSA9IG51bGw7XG4gIH0gLy8gSWYgdGhlIHByb3AgaXNuJ3QgaW4gdGhlIHNwZWNpYWwgbGlzdCwgdHJlYXQgaXQgYXMgYSBzaW1wbGUgYXR0cmlidXRlLlxuXG5cbiAgaWYgKGlzQ3VzdG9tQ29tcG9uZW50VGFnIHx8IHByb3BlcnR5SW5mbyA9PT0gbnVsbCkge1xuICAgIGlmIChpc0F0dHJpYnV0ZU5hbWVTYWZlKG5hbWUpKSB7XG4gICAgICB2YXIgX2F0dHJpYnV0ZU5hbWUgPSBuYW1lO1xuXG4gICAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgbm9kZS5yZW1vdmVBdHRyaWJ1dGUoX2F0dHJpYnV0ZU5hbWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoX2F0dHJpYnV0ZU5hbWUsICAnJyArIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgbXVzdFVzZVByb3BlcnR5ID0gcHJvcGVydHlJbmZvLm11c3RVc2VQcm9wZXJ0eTtcblxuICBpZiAobXVzdFVzZVByb3BlcnR5KSB7XG4gICAgdmFyIHByb3BlcnR5TmFtZSA9IHByb3BlcnR5SW5mby5wcm9wZXJ0eU5hbWU7XG5cbiAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICAgIHZhciB0eXBlID0gcHJvcGVydHlJbmZvLnR5cGU7XG4gICAgICBub2RlW3Byb3BlcnR5TmFtZV0gPSB0eXBlID09PSBCT09MRUFOID8gZmFsc2UgOiAnJztcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQ29udHJhcnkgdG8gYHNldEF0dHJpYnV0ZWAsIG9iamVjdCBwcm9wZXJ0aWVzIGFyZSBwcm9wZXJseVxuICAgICAgLy8gYHRvU3RyaW5nYGVkIGJ5IElFOC85LlxuICAgICAgbm9kZVtwcm9wZXJ0eU5hbWVdID0gdmFsdWU7XG4gICAgfVxuXG4gICAgcmV0dXJuO1xuICB9IC8vIFRoZSByZXN0IGFyZSB0cmVhdGVkIGFzIGF0dHJpYnV0ZXMgd2l0aCBzcGVjaWFsIGNhc2VzLlxuXG5cbiAgdmFyIGF0dHJpYnV0ZU5hbWUgPSBwcm9wZXJ0eUluZm8uYXR0cmlidXRlTmFtZSxcbiAgICAgIGF0dHJpYnV0ZU5hbWVzcGFjZSA9IHByb3BlcnR5SW5mby5hdHRyaWJ1dGVOYW1lc3BhY2U7XG5cbiAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgbm9kZS5yZW1vdmVBdHRyaWJ1dGUoYXR0cmlidXRlTmFtZSk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIF90eXBlID0gcHJvcGVydHlJbmZvLnR5cGU7XG4gICAgdmFyIGF0dHJpYnV0ZVZhbHVlO1xuXG4gICAgaWYgKF90eXBlID09PSBCT09MRUFOIHx8IF90eXBlID09PSBPVkVSTE9BREVEX0JPT0xFQU4gJiYgdmFsdWUgPT09IHRydWUpIHtcbiAgICAgIC8vIElmIGF0dHJpYnV0ZSB0eXBlIGlzIGJvb2xlYW4sIHdlIGtub3cgZm9yIHN1cmUgaXQgd29uJ3QgYmUgYW4gZXhlY3V0aW9uIHNpbmtcbiAgICAgIC8vIGFuZCB3ZSB3b24ndCByZXF1aXJlIFRydXN0ZWQgVHlwZSBoZXJlLlxuICAgICAgYXR0cmlidXRlVmFsdWUgPSAnJztcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gYHNldEF0dHJpYnV0ZWAgd2l0aCBvYmplY3RzIGJlY29tZXMgb25seSBgW29iamVjdF1gIGluIElFOC85LFxuICAgICAgLy8gKCcnICsgdmFsdWUpIG1ha2VzIGl0IG91dHB1dCB0aGUgY29ycmVjdCB0b1N0cmluZygpLXZhbHVlLlxuICAgICAge1xuICAgICAgICBhdHRyaWJ1dGVWYWx1ZSA9ICcnICsgdmFsdWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChwcm9wZXJ0eUluZm8uc2FuaXRpemVVUkwpIHtcbiAgICAgICAgc2FuaXRpemVVUkwoYXR0cmlidXRlVmFsdWUudG9TdHJpbmcoKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGF0dHJpYnV0ZU5hbWVzcGFjZSkge1xuICAgICAgbm9kZS5zZXRBdHRyaWJ1dGVOUyhhdHRyaWJ1dGVOYW1lc3BhY2UsIGF0dHJpYnV0ZU5hbWUsIGF0dHJpYnV0ZVZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoYXR0cmlidXRlTmFtZSwgYXR0cmlidXRlVmFsdWUpO1xuICAgIH1cbiAgfVxufVxuXG4vLyBBVFRFTlRJT05cbi8vIFdoZW4gYWRkaW5nIG5ldyBzeW1ib2xzIHRvIHRoaXMgZmlsZSxcbi8vIFBsZWFzZSBjb25zaWRlciBhbHNvIGFkZGluZyB0byAncmVhY3QtZGV2dG9vbHMtc2hhcmVkL3NyYy9iYWNrZW5kL1JlYWN0U3ltYm9scydcbi8vIFRoZSBTeW1ib2wgdXNlZCB0byB0YWcgdGhlIFJlYWN0RWxlbWVudC1saWtlIHR5cGVzLiBJZiB0aGVyZSBpcyBubyBuYXRpdmUgU3ltYm9sXG4vLyBub3IgcG9seWZpbGwsIHRoZW4gYSBwbGFpbiBudW1iZXIgaXMgdXNlZCBmb3IgcGVyZm9ybWFuY2UuXG52YXIgUkVBQ1RfRUxFTUVOVF9UWVBFID0gMHhlYWM3O1xudmFyIFJFQUNUX1BPUlRBTF9UWVBFID0gMHhlYWNhO1xudmFyIFJFQUNUX0ZSQUdNRU5UX1RZUEUgPSAweGVhY2I7XG52YXIgUkVBQ1RfU1RSSUNUX01PREVfVFlQRSA9IDB4ZWFjYztcbnZhciBSRUFDVF9QUk9GSUxFUl9UWVBFID0gMHhlYWQyO1xudmFyIFJFQUNUX1BST1ZJREVSX1RZUEUgPSAweGVhY2Q7XG52YXIgUkVBQ1RfQ09OVEVYVF9UWVBFID0gMHhlYWNlO1xudmFyIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgPSAweGVhZDA7XG52YXIgUkVBQ1RfU1VTUEVOU0VfVFlQRSA9IDB4ZWFkMTtcbnZhciBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUgPSAweGVhZDg7XG52YXIgUkVBQ1RfTUVNT19UWVBFID0gMHhlYWQzO1xudmFyIFJFQUNUX0xBWllfVFlQRSA9IDB4ZWFkNDtcbnZhciBSRUFDVF9CTE9DS19UWVBFID0gMHhlYWQ5O1xudmFyIFJFQUNUX1NFUlZFUl9CTE9DS19UWVBFID0gMHhlYWRhO1xudmFyIFJFQUNUX0ZVTkRBTUVOVEFMX1RZUEUgPSAweGVhZDU7XG52YXIgUkVBQ1RfU0NPUEVfVFlQRSA9IDB4ZWFkNztcbnZhciBSRUFDVF9PUEFRVUVfSURfVFlQRSA9IDB4ZWFlMDtcbnZhciBSRUFDVF9ERUJVR19UUkFDSU5HX01PREVfVFlQRSA9IDB4ZWFlMTtcbnZhciBSRUFDVF9PRkZTQ1JFRU5fVFlQRSA9IDB4ZWFlMjtcbnZhciBSRUFDVF9MRUdBQ1lfSElEREVOX1RZUEUgPSAweGVhZTM7XG5cbmlmICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC5mb3IpIHtcbiAgdmFyIHN5bWJvbEZvciA9IFN5bWJvbC5mb3I7XG4gIFJFQUNUX0VMRU1FTlRfVFlQRSA9IHN5bWJvbEZvcigncmVhY3QuZWxlbWVudCcpO1xuICBSRUFDVF9QT1JUQUxfVFlQRSA9IHN5bWJvbEZvcigncmVhY3QucG9ydGFsJyk7XG4gIFJFQUNUX0ZSQUdNRU5UX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LmZyYWdtZW50Jyk7XG4gIFJFQUNUX1NUUklDVF9NT0RFX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LnN0cmljdF9tb2RlJyk7XG4gIFJFQUNUX1BST0ZJTEVSX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LnByb2ZpbGVyJyk7XG4gIFJFQUNUX1BST1ZJREVSX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LnByb3ZpZGVyJyk7XG4gIFJFQUNUX0NPTlRFWFRfVFlQRSA9IHN5bWJvbEZvcigncmVhY3QuY29udGV4dCcpO1xuICBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5mb3J3YXJkX3JlZicpO1xuICBSRUFDVF9TVVNQRU5TRV9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5zdXNwZW5zZScpO1xuICBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LnN1c3BlbnNlX2xpc3QnKTtcbiAgUkVBQ1RfTUVNT19UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5tZW1vJyk7XG4gIFJFQUNUX0xBWllfVFlQRSA9IHN5bWJvbEZvcigncmVhY3QubGF6eScpO1xuICBSRUFDVF9CTE9DS19UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5ibG9jaycpO1xuICBSRUFDVF9TRVJWRVJfQkxPQ0tfVFlQRSA9IHN5bWJvbEZvcigncmVhY3Quc2VydmVyLmJsb2NrJyk7XG4gIFJFQUNUX0ZVTkRBTUVOVEFMX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LmZ1bmRhbWVudGFsJyk7XG4gIFJFQUNUX1NDT1BFX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LnNjb3BlJyk7XG4gIFJFQUNUX09QQVFVRV9JRF9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5vcGFxdWUuaWQnKTtcbiAgUkVBQ1RfREVCVUdfVFJBQ0lOR19NT0RFX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LmRlYnVnX3RyYWNlX21vZGUnKTtcbiAgUkVBQ1RfT0ZGU0NSRUVOX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0Lm9mZnNjcmVlbicpO1xuICBSRUFDVF9MRUdBQ1lfSElEREVOX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LmxlZ2FjeV9oaWRkZW4nKTtcbn1cblxudmFyIE1BWUJFX0lURVJBVE9SX1NZTUJPTCA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLml0ZXJhdG9yO1xudmFyIEZBVVhfSVRFUkFUT1JfU1lNQk9MID0gJ0BAaXRlcmF0b3InO1xuZnVuY3Rpb24gZ2V0SXRlcmF0b3JGbihtYXliZUl0ZXJhYmxlKSB7XG4gIGlmIChtYXliZUl0ZXJhYmxlID09PSBudWxsIHx8IHR5cGVvZiBtYXliZUl0ZXJhYmxlICE9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIG1heWJlSXRlcmF0b3IgPSBNQVlCRV9JVEVSQVRPUl9TWU1CT0wgJiYgbWF5YmVJdGVyYWJsZVtNQVlCRV9JVEVSQVRPUl9TWU1CT0xdIHx8IG1heWJlSXRlcmFibGVbRkFVWF9JVEVSQVRPUl9TWU1CT0xdO1xuXG4gIGlmICh0eXBlb2YgbWF5YmVJdGVyYXRvciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBtYXliZUl0ZXJhdG9yO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbi8vIEhlbHBlcnMgdG8gcGF0Y2ggY29uc29sZS5sb2dzIHRvIGF2b2lkIGxvZ2dpbmcgZHVyaW5nIHNpZGUtZWZmZWN0IGZyZWVcbi8vIHJlcGxheWluZyBvbiByZW5kZXIgZnVuY3Rpb24uIFRoaXMgY3VycmVudGx5IG9ubHkgcGF0Y2hlcyB0aGUgb2JqZWN0XG4vLyBsYXppbHkgd2hpY2ggd29uJ3QgY292ZXIgaWYgdGhlIGxvZyBmdW5jdGlvbiB3YXMgZXh0cmFjdGVkIGVhZ2VybHkuXG4vLyBXZSBjb3VsZCBhbHNvIGVhZ2VybHkgcGF0Y2ggdGhlIG1ldGhvZC5cbnZhciBkaXNhYmxlZERlcHRoID0gMDtcbnZhciBwcmV2TG9nO1xudmFyIHByZXZJbmZvO1xudmFyIHByZXZXYXJuO1xudmFyIHByZXZFcnJvcjtcbnZhciBwcmV2R3JvdXA7XG52YXIgcHJldkdyb3VwQ29sbGFwc2VkO1xudmFyIHByZXZHcm91cEVuZDtcblxuZnVuY3Rpb24gZGlzYWJsZWRMb2coKSB7fVxuXG5kaXNhYmxlZExvZy5fX3JlYWN0RGlzYWJsZWRMb2cgPSB0cnVlO1xuZnVuY3Rpb24gZGlzYWJsZUxvZ3MoKSB7XG4gIHtcbiAgICBpZiAoZGlzYWJsZWREZXB0aCA9PT0gMCkge1xuICAgICAgLyogZXNsaW50LWRpc2FibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgICBwcmV2TG9nID0gY29uc29sZS5sb2c7XG4gICAgICBwcmV2SW5mbyA9IGNvbnNvbGUuaW5mbztcbiAgICAgIHByZXZXYXJuID0gY29uc29sZS53YXJuO1xuICAgICAgcHJldkVycm9yID0gY29uc29sZS5lcnJvcjtcbiAgICAgIHByZXZHcm91cCA9IGNvbnNvbGUuZ3JvdXA7XG4gICAgICBwcmV2R3JvdXBDb2xsYXBzZWQgPSBjb25zb2xlLmdyb3VwQ29sbGFwc2VkO1xuICAgICAgcHJldkdyb3VwRW5kID0gY29uc29sZS5ncm91cEVuZDsgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xOTA5OVxuXG4gICAgICB2YXIgcHJvcHMgPSB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IGRpc2FibGVkTG9nLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgfTsgLy8gJEZsb3dGaXhNZSBGbG93IHRoaW5rcyBjb25zb2xlIGlzIGltbXV0YWJsZS5cblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoY29uc29sZSwge1xuICAgICAgICBpbmZvOiBwcm9wcyxcbiAgICAgICAgbG9nOiBwcm9wcyxcbiAgICAgICAgd2FybjogcHJvcHMsXG4gICAgICAgIGVycm9yOiBwcm9wcyxcbiAgICAgICAgZ3JvdXA6IHByb3BzLFxuICAgICAgICBncm91cENvbGxhcHNlZDogcHJvcHMsXG4gICAgICAgIGdyb3VwRW5kOiBwcm9wc1xuICAgICAgfSk7XG4gICAgICAvKiBlc2xpbnQtZW5hYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgIH1cblxuICAgIGRpc2FibGVkRGVwdGgrKztcbiAgfVxufVxuZnVuY3Rpb24gcmVlbmFibGVMb2dzKCkge1xuICB7XG4gICAgZGlzYWJsZWREZXB0aC0tO1xuXG4gICAgaWYgKGRpc2FibGVkRGVwdGggPT09IDApIHtcbiAgICAgIC8qIGVzbGludC1kaXNhYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgICAgdmFyIHByb3BzID0ge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICB9OyAvLyAkRmxvd0ZpeE1lIEZsb3cgdGhpbmtzIGNvbnNvbGUgaXMgaW1tdXRhYmxlLlxuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhjb25zb2xlLCB7XG4gICAgICAgIGxvZzogX2Fzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkxvZ1xuICAgICAgICB9KSxcbiAgICAgICAgaW5mbzogX2Fzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkluZm9cbiAgICAgICAgfSksXG4gICAgICAgIHdhcm46IF9hc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZXYXJuXG4gICAgICAgIH0pLFxuICAgICAgICBlcnJvcjogX2Fzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkVycm9yXG4gICAgICAgIH0pLFxuICAgICAgICBncm91cDogX2Fzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkdyb3VwXG4gICAgICAgIH0pLFxuICAgICAgICBncm91cENvbGxhcHNlZDogX2Fzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkdyb3VwQ29sbGFwc2VkXG4gICAgICAgIH0pLFxuICAgICAgICBncm91cEVuZDogX2Fzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkdyb3VwRW5kXG4gICAgICAgIH0pXG4gICAgICB9KTtcbiAgICAgIC8qIGVzbGludC1lbmFibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgfVxuXG4gICAgaWYgKGRpc2FibGVkRGVwdGggPCAwKSB7XG4gICAgICBlcnJvcignZGlzYWJsZWREZXB0aCBmZWxsIGJlbG93IHplcm8uICcgKyAnVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gICAgfVxuICB9XG59XG5cbnZhciBSZWFjdEN1cnJlbnREaXNwYXRjaGVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3RDdXJyZW50RGlzcGF0Y2hlcjtcbnZhciBwcmVmaXg7XG5mdW5jdGlvbiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZShuYW1lLCBzb3VyY2UsIG93bmVyRm4pIHtcbiAge1xuICAgIGlmIChwcmVmaXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gRXh0cmFjdCB0aGUgVk0gc3BlY2lmaWMgcHJlZml4IHVzZWQgYnkgZWFjaCBsaW5lLlxuICAgICAgdHJ5IHtcbiAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgdmFyIG1hdGNoID0geC5zdGFjay50cmltKCkubWF0Y2goL1xcbiggKihhdCApPykvKTtcbiAgICAgICAgcHJlZml4ID0gbWF0Y2ggJiYgbWF0Y2hbMV0gfHwgJyc7XG4gICAgICB9XG4gICAgfSAvLyBXZSB1c2UgdGhlIHByZWZpeCB0byBlbnN1cmUgb3VyIHN0YWNrcyBsaW5lIHVwIHdpdGggbmF0aXZlIHN0YWNrIGZyYW1lcy5cblxuXG4gICAgcmV0dXJuICdcXG4nICsgcHJlZml4ICsgbmFtZTtcbiAgfVxufVxudmFyIHJlZW50cnkgPSBmYWxzZTtcbnZhciBjb21wb25lbnRGcmFtZUNhY2hlO1xuXG57XG4gIHZhciBQb3NzaWJseVdlYWtNYXAgPSB0eXBlb2YgV2Vha01hcCA9PT0gJ2Z1bmN0aW9uJyA/IFdlYWtNYXAgOiBNYXA7XG4gIGNvbXBvbmVudEZyYW1lQ2FjaGUgPSBuZXcgUG9zc2libHlXZWFrTWFwKCk7XG59XG5cbmZ1bmN0aW9uIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUoZm4sIGNvbnN0cnVjdCkge1xuICAvLyBJZiBzb21ldGhpbmcgYXNrZWQgZm9yIGEgc3RhY2sgaW5zaWRlIGEgZmFrZSByZW5kZXIsIGl0IHNob3VsZCBnZXQgaWdub3JlZC5cbiAgaWYgKCFmbiB8fCByZWVudHJ5KSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAge1xuICAgIHZhciBmcmFtZSA9IGNvbXBvbmVudEZyYW1lQ2FjaGUuZ2V0KGZuKTtcblxuICAgIGlmIChmcmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZnJhbWU7XG4gICAgfVxuICB9XG5cbiAgdmFyIGNvbnRyb2w7XG4gIHJlZW50cnkgPSB0cnVlO1xuICB2YXIgcHJldmlvdXNQcmVwYXJlU3RhY2tUcmFjZSA9IEVycm9yLnByZXBhcmVTdGFja1RyYWNlOyAvLyAkRmxvd0ZpeE1lIEl0IGRvZXMgYWNjZXB0IHVuZGVmaW5lZC5cblxuICBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZSA9IHVuZGVmaW5lZDtcbiAgdmFyIHByZXZpb3VzRGlzcGF0Y2hlcjtcblxuICB7XG4gICAgcHJldmlvdXNEaXNwYXRjaGVyID0gUmVhY3RDdXJyZW50RGlzcGF0Y2hlci5jdXJyZW50OyAvLyBTZXQgdGhlIGRpc3BhdGNoZXIgaW4gREVWIGJlY2F1c2UgdGhpcyBtaWdodCBiZSBjYWxsIGluIHRoZSByZW5kZXIgZnVuY3Rpb25cbiAgICAvLyBmb3Igd2FybmluZ3MuXG5cbiAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyLmN1cnJlbnQgPSBudWxsO1xuICAgIGRpc2FibGVMb2dzKCk7XG4gIH1cblxuICB0cnkge1xuICAgIC8vIFRoaXMgc2hvdWxkIHRocm93LlxuICAgIGlmIChjb25zdHJ1Y3QpIHtcbiAgICAgIC8vIFNvbWV0aGluZyBzaG91bGQgYmUgc2V0dGluZyB0aGUgcHJvcHMgaW4gdGhlIGNvbnN0cnVjdG9yLlxuICAgICAgdmFyIEZha2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICB9OyAvLyAkRmxvd0ZpeE1lXG5cblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZha2UucHJvdG90eXBlLCAncHJvcHMnLCB7XG4gICAgICAgIHNldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIC8vIFdlIHVzZSBhIHRocm93aW5nIHNldHRlciBpbnN0ZWFkIG9mIGZyb3plbiBvciBub24td3JpdGFibGUgcHJvcHNcbiAgICAgICAgICAvLyBiZWNhdXNlIHRoYXQgd29uJ3QgdGhyb3cgaW4gYSBub24tc3RyaWN0IG1vZGUgZnVuY3Rpb24uXG4gICAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gJ29iamVjdCcgJiYgUmVmbGVjdC5jb25zdHJ1Y3QpIHtcbiAgICAgICAgLy8gV2UgY29uc3RydWN0IGEgZGlmZmVyZW50IGNvbnRyb2wgZm9yIHRoaXMgY2FzZSB0byBpbmNsdWRlIGFueSBleHRyYVxuICAgICAgICAvLyBmcmFtZXMgYWRkZWQgYnkgdGhlIGNvbnN0cnVjdCBjYWxsLlxuICAgICAgICB0cnkge1xuICAgICAgICAgIFJlZmxlY3QuY29uc3RydWN0KEZha2UsIFtdKTtcbiAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgIGNvbnRyb2wgPSB4O1xuICAgICAgICB9XG5cbiAgICAgICAgUmVmbGVjdC5jb25zdHJ1Y3QoZm4sIFtdLCBGYWtlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgRmFrZS5jYWxsKCk7XG4gICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICBjb250cm9sID0geDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZuLmNhbGwoRmFrZS5wcm90b3R5cGUpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0cnkge1xuICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICBjb250cm9sID0geDtcbiAgICAgIH1cblxuICAgICAgZm4oKTtcbiAgICB9XG4gIH0gY2F0Y2ggKHNhbXBsZSkge1xuICAgIC8vIFRoaXMgaXMgaW5saW5lZCBtYW51YWxseSBiZWNhdXNlIGNsb3N1cmUgZG9lc24ndCBkbyBpdCBmb3IgdXMuXG4gICAgaWYgKHNhbXBsZSAmJiBjb250cm9sICYmIHR5cGVvZiBzYW1wbGUuc3RhY2sgPT09ICdzdHJpbmcnKSB7XG4gICAgICAvLyBUaGlzIGV4dHJhY3RzIHRoZSBmaXJzdCBmcmFtZSBmcm9tIHRoZSBzYW1wbGUgdGhhdCBpc24ndCBhbHNvIGluIHRoZSBjb250cm9sLlxuICAgICAgLy8gU2tpcHBpbmcgb25lIGZyYW1lIHRoYXQgd2UgYXNzdW1lIGlzIHRoZSBmcmFtZSB0aGF0IGNhbGxzIHRoZSB0d28uXG4gICAgICB2YXIgc2FtcGxlTGluZXMgPSBzYW1wbGUuc3RhY2suc3BsaXQoJ1xcbicpO1xuICAgICAgdmFyIGNvbnRyb2xMaW5lcyA9IGNvbnRyb2wuc3RhY2suc3BsaXQoJ1xcbicpO1xuICAgICAgdmFyIHMgPSBzYW1wbGVMaW5lcy5sZW5ndGggLSAxO1xuICAgICAgdmFyIGMgPSBjb250cm9sTGluZXMubGVuZ3RoIC0gMTtcblxuICAgICAgd2hpbGUgKHMgPj0gMSAmJiBjID49IDAgJiYgc2FtcGxlTGluZXNbc10gIT09IGNvbnRyb2xMaW5lc1tjXSkge1xuICAgICAgICAvLyBXZSBleHBlY3QgYXQgbGVhc3Qgb25lIHN0YWNrIGZyYW1lIHRvIGJlIHNoYXJlZC5cbiAgICAgICAgLy8gVHlwaWNhbGx5IHRoaXMgd2lsbCBiZSB0aGUgcm9vdCBtb3N0IG9uZS4gSG93ZXZlciwgc3RhY2sgZnJhbWVzIG1heSBiZVxuICAgICAgICAvLyBjdXQgb2ZmIGR1ZSB0byBtYXhpbXVtIHN0YWNrIGxpbWl0cy4gSW4gdGhpcyBjYXNlLCBvbmUgbWF5YmUgY3V0IG9mZlxuICAgICAgICAvLyBlYXJsaWVyIHRoYW4gdGhlIG90aGVyLiBXZSBhc3N1bWUgdGhhdCB0aGUgc2FtcGxlIGlzIGxvbmdlciBvciB0aGUgc2FtZVxuICAgICAgICAvLyBhbmQgdGhlcmUgZm9yIGN1dCBvZmYgZWFybGllci4gU28gd2Ugc2hvdWxkIGZpbmQgdGhlIHJvb3QgbW9zdCBmcmFtZSBpblxuICAgICAgICAvLyB0aGUgc2FtcGxlIHNvbWV3aGVyZSBpbiB0aGUgY29udHJvbC5cbiAgICAgICAgYy0tO1xuICAgICAgfVxuXG4gICAgICBmb3IgKDsgcyA+PSAxICYmIGMgPj0gMDsgcy0tLCBjLS0pIHtcbiAgICAgICAgLy8gTmV4dCB3ZSBmaW5kIHRoZSBmaXJzdCBvbmUgdGhhdCBpc24ndCB0aGUgc2FtZSB3aGljaCBzaG91bGQgYmUgdGhlXG4gICAgICAgIC8vIGZyYW1lIHRoYXQgY2FsbGVkIG91ciBzYW1wbGUgZnVuY3Rpb24gYW5kIHRoZSBjb250cm9sLlxuICAgICAgICBpZiAoc2FtcGxlTGluZXNbc10gIT09IGNvbnRyb2xMaW5lc1tjXSkge1xuICAgICAgICAgIC8vIEluIFY4LCB0aGUgZmlyc3QgbGluZSBpcyBkZXNjcmliaW5nIHRoZSBtZXNzYWdlIGJ1dCBvdGhlciBWTXMgZG9uJ3QuXG4gICAgICAgICAgLy8gSWYgd2UncmUgYWJvdXQgdG8gcmV0dXJuIHRoZSBmaXJzdCBsaW5lLCBhbmQgdGhlIGNvbnRyb2wgaXMgYWxzbyBvbiB0aGUgc2FtZVxuICAgICAgICAgIC8vIGxpbmUsIHRoYXQncyBhIHByZXR0eSBnb29kIGluZGljYXRvciB0aGF0IG91ciBzYW1wbGUgdGhyZXcgYXQgc2FtZSBsaW5lIGFzXG4gICAgICAgICAgLy8gdGhlIGNvbnRyb2wuIEkuZS4gYmVmb3JlIHdlIGVudGVyZWQgdGhlIHNhbXBsZSBmcmFtZS4gU28gd2UgaWdub3JlIHRoaXMgcmVzdWx0LlxuICAgICAgICAgIC8vIFRoaXMgY2FuIGhhcHBlbiBpZiB5b3UgcGFzc2VkIGEgY2xhc3MgdG8gZnVuY3Rpb24gY29tcG9uZW50LCBvciBub24tZnVuY3Rpb24uXG4gICAgICAgICAgaWYgKHMgIT09IDEgfHwgYyAhPT0gMSkge1xuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICBzLS07XG4gICAgICAgICAgICAgIGMtLTsgLy8gV2UgbWF5IHN0aWxsIGhhdmUgc2ltaWxhciBpbnRlcm1lZGlhdGUgZnJhbWVzIGZyb20gdGhlIGNvbnN0cnVjdCBjYWxsLlxuICAgICAgICAgICAgICAvLyBUaGUgbmV4dCBvbmUgdGhhdCBpc24ndCB0aGUgc2FtZSBzaG91bGQgYmUgb3VyIG1hdGNoIHRob3VnaC5cblxuICAgICAgICAgICAgICBpZiAoYyA8IDAgfHwgc2FtcGxlTGluZXNbc10gIT09IGNvbnRyb2xMaW5lc1tjXSkge1xuICAgICAgICAgICAgICAgIC8vIFY4IGFkZHMgYSBcIm5ld1wiIHByZWZpeCBmb3IgbmF0aXZlIGNsYXNzZXMuIExldCdzIHJlbW92ZSBpdCB0byBtYWtlIGl0IHByZXR0aWVyLlxuICAgICAgICAgICAgICAgIHZhciBfZnJhbWUgPSAnXFxuJyArIHNhbXBsZUxpbmVzW3NdLnJlcGxhY2UoJyBhdCBuZXcgJywgJyBhdCAnKTtcblxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50RnJhbWVDYWNoZS5zZXQoZm4sIF9mcmFtZSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSAvLyBSZXR1cm4gdGhlIGxpbmUgd2UgZm91bmQuXG5cblxuICAgICAgICAgICAgICAgIHJldHVybiBfZnJhbWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gd2hpbGUgKHMgPj0gMSAmJiBjID49IDApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9IGZpbmFsbHkge1xuICAgIHJlZW50cnkgPSBmYWxzZTtcblxuICAgIHtcbiAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIuY3VycmVudCA9IHByZXZpb3VzRGlzcGF0Y2hlcjtcbiAgICAgIHJlZW5hYmxlTG9ncygpO1xuICAgIH1cblxuICAgIEVycm9yLnByZXBhcmVTdGFja1RyYWNlID0gcHJldmlvdXNQcmVwYXJlU3RhY2tUcmFjZTtcbiAgfSAvLyBGYWxsYmFjayB0byBqdXN0IHVzaW5nIHRoZSBuYW1lIGlmIHdlIGNvdWxkbid0IG1ha2UgaXQgdGhyb3cuXG5cblxuICB2YXIgbmFtZSA9IGZuID8gZm4uZGlzcGxheU5hbWUgfHwgZm4ubmFtZSA6ICcnO1xuICB2YXIgc3ludGhldGljRnJhbWUgPSBuYW1lID8gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUobmFtZSkgOiAnJztcblxuICB7XG4gICAgaWYgKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY29tcG9uZW50RnJhbWVDYWNoZS5zZXQoZm4sIHN5bnRoZXRpY0ZyYW1lKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc3ludGhldGljRnJhbWU7XG59XG5cbmZ1bmN0aW9uIGRlc2NyaWJlQ2xhc3NDb21wb25lbnRGcmFtZShjdG9yLCBzb3VyY2UsIG93bmVyRm4pIHtcbiAge1xuICAgIHJldHVybiBkZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lKGN0b3IsIHRydWUpO1xuICB9XG59XG5mdW5jdGlvbiBkZXNjcmliZUZ1bmN0aW9uQ29tcG9uZW50RnJhbWUoZm4sIHNvdXJjZSwgb3duZXJGbikge1xuICB7XG4gICAgcmV0dXJuIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUoZm4sIGZhbHNlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzaG91bGRDb25zdHJ1Y3QoQ29tcG9uZW50KSB7XG4gIHZhciBwcm90b3R5cGUgPSBDb21wb25lbnQucHJvdG90eXBlO1xuICByZXR1cm4gISEocHJvdG90eXBlICYmIHByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50KTtcbn1cblxuZnVuY3Rpb24gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKHR5cGUsIHNvdXJjZSwgb3duZXJGbikge1xuXG4gIGlmICh0eXBlID09IG51bGwpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICB7XG4gICAgICByZXR1cm4gZGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZSh0eXBlLCBzaG91bGRDb25zdHJ1Y3QodHlwZSkpO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUodHlwZSk7XG4gIH1cblxuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX1RZUEU6XG4gICAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoJ1N1c3BlbnNlJyk7XG5cbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTpcbiAgICAgIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSgnU3VzcGVuc2VMaXN0Jyk7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgc3dpdGNoICh0eXBlLiQkdHlwZW9mKSB7XG4gICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XG4gICAgICAgIHJldHVybiBkZXNjcmliZUZ1bmN0aW9uQ29tcG9uZW50RnJhbWUodHlwZS5yZW5kZXIpO1xuXG4gICAgICBjYXNlIFJFQUNUX01FTU9fVFlQRTpcbiAgICAgICAgLy8gTWVtbyBtYXkgY29udGFpbiBhbnkgY29tcG9uZW50IHR5cGUgc28gd2UgcmVjdXJzaXZlbHkgcmVzb2x2ZSBpdC5cbiAgICAgICAgcmV0dXJuIGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVih0eXBlLnR5cGUsIHNvdXJjZSwgb3duZXJGbik7XG5cbiAgICAgIGNhc2UgUkVBQ1RfQkxPQ0tfVFlQRTpcbiAgICAgICAgcmV0dXJuIGRlc2NyaWJlRnVuY3Rpb25Db21wb25lbnRGcmFtZSh0eXBlLl9yZW5kZXIpO1xuXG4gICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBsYXp5Q29tcG9uZW50ID0gdHlwZTtcbiAgICAgICAgICB2YXIgcGF5bG9hZCA9IGxhenlDb21wb25lbnQuX3BheWxvYWQ7XG4gICAgICAgICAgdmFyIGluaXQgPSBsYXp5Q29tcG9uZW50Ll9pbml0O1xuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIExhenkgbWF5IGNvbnRhaW4gYW55IGNvbXBvbmVudCB0eXBlIHNvIHdlIHJlY3Vyc2l2ZWx5IHJlc29sdmUgaXQuXG4gICAgICAgICAgICByZXR1cm4gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKGluaXQocGF5bG9hZCksIHNvdXJjZSwgb3duZXJGbik7XG4gICAgICAgICAgfSBjYXRjaCAoeCkge31cbiAgICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiAnJztcbn1cblxuZnVuY3Rpb24gZGVzY3JpYmVGaWJlcihmaWJlcikge1xuICB2YXIgb3duZXIgPSAgZmliZXIuX2RlYnVnT3duZXIgPyBmaWJlci5fZGVidWdPd25lci50eXBlIDogbnVsbCA7XG4gIHZhciBzb3VyY2UgPSAgZmliZXIuX2RlYnVnU291cmNlIDtcblxuICBzd2l0Y2ggKGZpYmVyLnRhZykge1xuICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZShmaWJlci50eXBlKTtcblxuICAgIGNhc2UgTGF6eUNvbXBvbmVudDpcbiAgICAgIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSgnTGF6eScpO1xuXG4gICAgY2FzZSBTdXNwZW5zZUNvbXBvbmVudDpcbiAgICAgIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSgnU3VzcGVuc2UnKTtcblxuICAgIGNhc2UgU3VzcGVuc2VMaXN0Q29tcG9uZW50OlxuICAgICAgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKCdTdXNwZW5zZUxpc3QnKTtcblxuICAgIGNhc2UgRnVuY3Rpb25Db21wb25lbnQ6XG4gICAgY2FzZSBJbmRldGVybWluYXRlQ29tcG9uZW50OlxuICAgIGNhc2UgU2ltcGxlTWVtb0NvbXBvbmVudDpcbiAgICAgIHJldHVybiBkZXNjcmliZUZ1bmN0aW9uQ29tcG9uZW50RnJhbWUoZmliZXIudHlwZSk7XG5cbiAgICBjYXNlIEZvcndhcmRSZWY6XG4gICAgICByZXR1cm4gZGVzY3JpYmVGdW5jdGlvbkNvbXBvbmVudEZyYW1lKGZpYmVyLnR5cGUucmVuZGVyKTtcblxuICAgIGNhc2UgQmxvY2s6XG4gICAgICByZXR1cm4gZGVzY3JpYmVGdW5jdGlvbkNvbXBvbmVudEZyYW1lKGZpYmVyLnR5cGUuX3JlbmRlcik7XG5cbiAgICBjYXNlIENsYXNzQ29tcG9uZW50OlxuICAgICAgcmV0dXJuIGRlc2NyaWJlQ2xhc3NDb21wb25lbnRGcmFtZShmaWJlci50eXBlKTtcblxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gJyc7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0U3RhY2tCeUZpYmVySW5EZXZBbmRQcm9kKHdvcmtJblByb2dyZXNzKSB7XG4gIHRyeSB7XG4gICAgdmFyIGluZm8gPSAnJztcbiAgICB2YXIgbm9kZSA9IHdvcmtJblByb2dyZXNzO1xuXG4gICAgZG8ge1xuICAgICAgaW5mbyArPSBkZXNjcmliZUZpYmVyKG5vZGUpO1xuICAgICAgbm9kZSA9IG5vZGUucmV0dXJuO1xuICAgIH0gd2hpbGUgKG5vZGUpO1xuXG4gICAgcmV0dXJuIGluZm87XG4gIH0gY2F0Y2ggKHgpIHtcbiAgICByZXR1cm4gJ1xcbkVycm9yIGdlbmVyYXRpbmcgc3RhY2s6ICcgKyB4Lm1lc3NhZ2UgKyAnXFxuJyArIHguc3RhY2s7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0V3JhcHBlZE5hbWUob3V0ZXJUeXBlLCBpbm5lclR5cGUsIHdyYXBwZXJOYW1lKSB7XG4gIHZhciBmdW5jdGlvbk5hbWUgPSBpbm5lclR5cGUuZGlzcGxheU5hbWUgfHwgaW5uZXJUeXBlLm5hbWUgfHwgJyc7XG4gIHJldHVybiBvdXRlclR5cGUuZGlzcGxheU5hbWUgfHwgKGZ1bmN0aW9uTmFtZSAhPT0gJycgPyB3cmFwcGVyTmFtZSArIFwiKFwiICsgZnVuY3Rpb25OYW1lICsgXCIpXCIgOiB3cmFwcGVyTmFtZSk7XG59XG5cbmZ1bmN0aW9uIGdldENvbnRleHROYW1lKHR5cGUpIHtcbiAgcmV0dXJuIHR5cGUuZGlzcGxheU5hbWUgfHwgJ0NvbnRleHQnO1xufVxuXG5mdW5jdGlvbiBnZXRDb21wb25lbnROYW1lKHR5cGUpIHtcbiAgaWYgKHR5cGUgPT0gbnVsbCkge1xuICAgIC8vIEhvc3Qgcm9vdCwgdGV4dCBub2RlIG9yIGp1c3QgaW52YWxpZCB0eXBlLlxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAge1xuICAgIGlmICh0eXBlb2YgdHlwZS50YWcgPT09ICdudW1iZXInKSB7XG4gICAgICBlcnJvcignUmVjZWl2ZWQgYW4gdW5leHBlY3RlZCBvYmplY3QgaW4gZ2V0Q29tcG9uZW50TmFtZSgpLiAnICsgJ1RoaXMgaXMgbGlrZWx5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICB9XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gdHlwZS5kaXNwbGF5TmFtZSB8fCB0eXBlLm5hbWUgfHwgbnVsbDtcbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gdHlwZTtcbiAgfVxuXG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgUkVBQ1RfRlJBR01FTlRfVFlQRTpcbiAgICAgIHJldHVybiAnRnJhZ21lbnQnO1xuXG4gICAgY2FzZSBSRUFDVF9QT1JUQUxfVFlQRTpcbiAgICAgIHJldHVybiAnUG9ydGFsJztcblxuICAgIGNhc2UgUkVBQ1RfUFJPRklMRVJfVFlQRTpcbiAgICAgIHJldHVybiAnUHJvZmlsZXInO1xuXG4gICAgY2FzZSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFOlxuICAgICAgcmV0dXJuICdTdHJpY3RNb2RlJztcblxuICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfVFlQRTpcbiAgICAgIHJldHVybiAnU3VzcGVuc2UnO1xuXG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEU6XG4gICAgICByZXR1cm4gJ1N1c3BlbnNlTGlzdCc7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgc3dpdGNoICh0eXBlLiQkdHlwZW9mKSB7XG4gICAgICBjYXNlIFJFQUNUX0NPTlRFWFRfVFlQRTpcbiAgICAgICAgdmFyIGNvbnRleHQgPSB0eXBlO1xuICAgICAgICByZXR1cm4gZ2V0Q29udGV4dE5hbWUoY29udGV4dCkgKyAnLkNvbnN1bWVyJztcblxuICAgICAgY2FzZSBSRUFDVF9QUk9WSURFUl9UWVBFOlxuICAgICAgICB2YXIgcHJvdmlkZXIgPSB0eXBlO1xuICAgICAgICByZXR1cm4gZ2V0Q29udGV4dE5hbWUocHJvdmlkZXIuX2NvbnRleHQpICsgJy5Qcm92aWRlcic7XG5cbiAgICAgIGNhc2UgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTpcbiAgICAgICAgcmV0dXJuIGdldFdyYXBwZWROYW1lKHR5cGUsIHR5cGUucmVuZGVyLCAnRm9yd2FyZFJlZicpO1xuXG4gICAgICBjYXNlIFJFQUNUX01FTU9fVFlQRTpcbiAgICAgICAgcmV0dXJuIGdldENvbXBvbmVudE5hbWUodHlwZS50eXBlKTtcblxuICAgICAgY2FzZSBSRUFDVF9CTE9DS19UWVBFOlxuICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50TmFtZSh0eXBlLl9yZW5kZXIpO1xuXG4gICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBsYXp5Q29tcG9uZW50ID0gdHlwZTtcbiAgICAgICAgICB2YXIgcGF5bG9hZCA9IGxhenlDb21wb25lbnQuX3BheWxvYWQ7XG4gICAgICAgICAgdmFyIGluaXQgPSBsYXp5Q29tcG9uZW50Ll9pbml0O1xuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBnZXRDb21wb25lbnROYW1lKGluaXQocGF5bG9hZCkpO1xuICAgICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG52YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0RGVidWdDdXJyZW50RnJhbWU7XG52YXIgY3VycmVudCA9IG51bGw7XG52YXIgaXNSZW5kZXJpbmcgPSBmYWxzZTtcbmZ1bmN0aW9uIGdldEN1cnJlbnRGaWJlck93bmVyTmFtZUluRGV2T3JOdWxsKCkge1xuICB7XG4gICAgaWYgKGN1cnJlbnQgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHZhciBvd25lciA9IGN1cnJlbnQuX2RlYnVnT3duZXI7XG5cbiAgICBpZiAob3duZXIgIT09IG51bGwgJiYgdHlwZW9mIG93bmVyICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgcmV0dXJuIGdldENvbXBvbmVudE5hbWUob3duZXIudHlwZSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIGdldEN1cnJlbnRGaWJlclN0YWNrSW5EZXYoKSB7XG4gIHtcbiAgICBpZiAoY3VycmVudCA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuICcnO1xuICAgIH0gLy8gU2FmZSBiZWNhdXNlIGlmIGN1cnJlbnQgZmliZXIgZXhpc3RzLCB3ZSBhcmUgcmVjb25jaWxpbmcsXG4gICAgLy8gYW5kIGl0IGlzIGd1YXJhbnRlZWQgdG8gYmUgdGhlIHdvcmstaW4tcHJvZ3Jlc3MgdmVyc2lvbi5cblxuXG4gICAgcmV0dXJuIGdldFN0YWNrQnlGaWJlckluRGV2QW5kUHJvZChjdXJyZW50KTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZXNldEN1cnJlbnRGaWJlcigpIHtcbiAge1xuICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWUuZ2V0Q3VycmVudFN0YWNrID0gbnVsbDtcbiAgICBjdXJyZW50ID0gbnVsbDtcbiAgICBpc1JlbmRlcmluZyA9IGZhbHNlO1xuICB9XG59XG5mdW5jdGlvbiBzZXRDdXJyZW50RmliZXIoZmliZXIpIHtcbiAge1xuICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWUuZ2V0Q3VycmVudFN0YWNrID0gZ2V0Q3VycmVudEZpYmVyU3RhY2tJbkRldjtcbiAgICBjdXJyZW50ID0gZmliZXI7XG4gICAgaXNSZW5kZXJpbmcgPSBmYWxzZTtcbiAgfVxufVxuZnVuY3Rpb24gc2V0SXNSZW5kZXJpbmcocmVuZGVyaW5nKSB7XG4gIHtcbiAgICBpc1JlbmRlcmluZyA9IHJlbmRlcmluZztcbiAgfVxufVxuZnVuY3Rpb24gZ2V0SXNSZW5kZXJpbmcoKSB7XG4gIHtcbiAgICByZXR1cm4gaXNSZW5kZXJpbmc7XG4gIH1cbn1cblxuLy8gRmxvdyBkb2VzIG5vdCBhbGxvdyBzdHJpbmcgY29uY2F0ZW5hdGlvbiBvZiBtb3N0IG5vbi1zdHJpbmcgdHlwZXMuIFRvIHdvcmtcbi8vIGFyb3VuZCB0aGlzIGxpbWl0YXRpb24sIHdlIHVzZSBhbiBvcGFxdWUgdHlwZSB0aGF0IGNhbiBvbmx5IGJlIG9idGFpbmVkIGJ5XG4vLyBwYXNzaW5nIHRoZSB2YWx1ZSB0aHJvdWdoIGdldFRvU3RyaW5nVmFsdWUgZmlyc3QuXG5mdW5jdGlvbiB0b1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gJycgKyB2YWx1ZTtcbn1cbmZ1bmN0aW9uIGdldFRvU3RyaW5nVmFsdWUodmFsdWUpIHtcbiAgc3dpdGNoICh0eXBlb2YgdmFsdWUpIHtcbiAgICBjYXNlICdib29sZWFuJzpcbiAgICBjYXNlICdudW1iZXInOlxuICAgIGNhc2UgJ29iamVjdCc6XG4gICAgY2FzZSAnc3RyaW5nJzpcbiAgICBjYXNlICd1bmRlZmluZWQnOlxuICAgICAgcmV0dXJuIHZhbHVlO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIC8vIGZ1bmN0aW9uLCBzeW1ib2wgYXJlIGFzc2lnbmVkIGFzIGVtcHR5IHN0cmluZ3NcbiAgICAgIHJldHVybiAnJztcbiAgfVxufVxuXG52YXIgaGFzUmVhZE9ubHlWYWx1ZSA9IHtcbiAgYnV0dG9uOiB0cnVlLFxuICBjaGVja2JveDogdHJ1ZSxcbiAgaW1hZ2U6IHRydWUsXG4gIGhpZGRlbjogdHJ1ZSxcbiAgcmFkaW86IHRydWUsXG4gIHJlc2V0OiB0cnVlLFxuICBzdWJtaXQ6IHRydWVcbn07XG5mdW5jdGlvbiBjaGVja0NvbnRyb2xsZWRWYWx1ZVByb3BzKHRhZ05hbWUsIHByb3BzKSB7XG4gIHtcbiAgICBpZiAoIShoYXNSZWFkT25seVZhbHVlW3Byb3BzLnR5cGVdIHx8IHByb3BzLm9uQ2hhbmdlIHx8IHByb3BzLm9uSW5wdXQgfHwgcHJvcHMucmVhZE9ubHkgfHwgcHJvcHMuZGlzYWJsZWQgfHwgcHJvcHMudmFsdWUgPT0gbnVsbCkpIHtcbiAgICAgIGVycm9yKCdZb3UgcHJvdmlkZWQgYSBgdmFsdWVgIHByb3AgdG8gYSBmb3JtIGZpZWxkIHdpdGhvdXQgYW4gJyArICdgb25DaGFuZ2VgIGhhbmRsZXIuIFRoaXMgd2lsbCByZW5kZXIgYSByZWFkLW9ubHkgZmllbGQuIElmICcgKyAndGhlIGZpZWxkIHNob3VsZCBiZSBtdXRhYmxlIHVzZSBgZGVmYXVsdFZhbHVlYC4gT3RoZXJ3aXNlLCAnICsgJ3NldCBlaXRoZXIgYG9uQ2hhbmdlYCBvciBgcmVhZE9ubHlgLicpO1xuICAgIH1cblxuICAgIGlmICghKHByb3BzLm9uQ2hhbmdlIHx8IHByb3BzLnJlYWRPbmx5IHx8IHByb3BzLmRpc2FibGVkIHx8IHByb3BzLmNoZWNrZWQgPT0gbnVsbCkpIHtcbiAgICAgIGVycm9yKCdZb3UgcHJvdmlkZWQgYSBgY2hlY2tlZGAgcHJvcCB0byBhIGZvcm0gZmllbGQgd2l0aG91dCBhbiAnICsgJ2BvbkNoYW5nZWAgaGFuZGxlci4gVGhpcyB3aWxsIHJlbmRlciBhIHJlYWQtb25seSBmaWVsZC4gSWYgJyArICd0aGUgZmllbGQgc2hvdWxkIGJlIG11dGFibGUgdXNlIGBkZWZhdWx0Q2hlY2tlZGAuIE90aGVyd2lzZSwgJyArICdzZXQgZWl0aGVyIGBvbkNoYW5nZWAgb3IgYHJlYWRPbmx5YC4nKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNDaGVja2FibGUoZWxlbSkge1xuICB2YXIgdHlwZSA9IGVsZW0udHlwZTtcbiAgdmFyIG5vZGVOYW1lID0gZWxlbS5ub2RlTmFtZTtcbiAgcmV0dXJuIG5vZGVOYW1lICYmIG5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdpbnB1dCcgJiYgKHR5cGUgPT09ICdjaGVja2JveCcgfHwgdHlwZSA9PT0gJ3JhZGlvJyk7XG59XG5cbmZ1bmN0aW9uIGdldFRyYWNrZXIobm9kZSkge1xuICByZXR1cm4gbm9kZS5fdmFsdWVUcmFja2VyO1xufVxuXG5mdW5jdGlvbiBkZXRhY2hUcmFja2VyKG5vZGUpIHtcbiAgbm9kZS5fdmFsdWVUcmFja2VyID0gbnVsbDtcbn1cblxuZnVuY3Rpb24gZ2V0VmFsdWVGcm9tTm9kZShub2RlKSB7XG4gIHZhciB2YWx1ZSA9ICcnO1xuXG4gIGlmICghbm9kZSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuXG4gIGlmIChpc0NoZWNrYWJsZShub2RlKSkge1xuICAgIHZhbHVlID0gbm9kZS5jaGVja2VkID8gJ3RydWUnIDogJ2ZhbHNlJztcbiAgfSBlbHNlIHtcbiAgICB2YWx1ZSA9IG5vZGUudmFsdWU7XG4gIH1cblxuICByZXR1cm4gdmFsdWU7XG59XG5cbmZ1bmN0aW9uIHRyYWNrVmFsdWVPbk5vZGUobm9kZSkge1xuICB2YXIgdmFsdWVGaWVsZCA9IGlzQ2hlY2thYmxlKG5vZGUpID8gJ2NoZWNrZWQnIDogJ3ZhbHVlJztcbiAgdmFyIGRlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG5vZGUuY29uc3RydWN0b3IucHJvdG90eXBlLCB2YWx1ZUZpZWxkKTtcbiAgdmFyIGN1cnJlbnRWYWx1ZSA9ICcnICsgbm9kZVt2YWx1ZUZpZWxkXTsgLy8gaWYgc29tZW9uZSBoYXMgYWxyZWFkeSBkZWZpbmVkIGEgdmFsdWUgb3IgU2FmYXJpLCB0aGVuIGJhaWxcbiAgLy8gYW5kIGRvbid0IHRyYWNrIHZhbHVlIHdpbGwgY2F1c2Ugb3ZlciByZXBvcnRpbmcgb2YgY2hhbmdlcyxcbiAgLy8gYnV0IGl0J3MgYmV0dGVyIHRoZW4gYSBoYXJkIGZhaWx1cmVcbiAgLy8gKG5lZWRlZCBmb3IgY2VydGFpbiB0ZXN0cyB0aGF0IHNweU9uIGlucHV0IHZhbHVlcyBhbmQgU2FmYXJpKVxuXG4gIGlmIChub2RlLmhhc093blByb3BlcnR5KHZhbHVlRmllbGQpIHx8IHR5cGVvZiBkZXNjcmlwdG9yID09PSAndW5kZWZpbmVkJyB8fCB0eXBlb2YgZGVzY3JpcHRvci5nZXQgIT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGRlc2NyaXB0b3Iuc2V0ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGdldCA9IGRlc2NyaXB0b3IuZ2V0LFxuICAgICAgc2V0ID0gZGVzY3JpcHRvci5zZXQ7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShub2RlLCB2YWx1ZUZpZWxkLCB7XG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGdldC5jYWxsKHRoaXMpO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIGN1cnJlbnRWYWx1ZSA9ICcnICsgdmFsdWU7XG4gICAgICBzZXQuY2FsbCh0aGlzLCB2YWx1ZSk7XG4gICAgfVxuICB9KTsgLy8gV2UgY291bGQndmUgcGFzc2VkIHRoaXMgdGhlIGZpcnN0IHRpbWVcbiAgLy8gYnV0IGl0IHRyaWdnZXJzIGEgYnVnIGluIElFMTEgYW5kIEVkZ2UgMTQvMTUuXG4gIC8vIENhbGxpbmcgZGVmaW5lUHJvcGVydHkoKSBhZ2FpbiBzaG91bGQgYmUgZXF1aXZhbGVudC5cbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xMTc2OFxuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShub2RlLCB2YWx1ZUZpZWxkLCB7XG4gICAgZW51bWVyYWJsZTogZGVzY3JpcHRvci5lbnVtZXJhYmxlXG4gIH0pO1xuICB2YXIgdHJhY2tlciA9IHtcbiAgICBnZXRWYWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGN1cnJlbnRWYWx1ZTtcbiAgICB9LFxuICAgIHNldFZhbHVlOiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIGN1cnJlbnRWYWx1ZSA9ICcnICsgdmFsdWU7XG4gICAgfSxcbiAgICBzdG9wVHJhY2tpbmc6IGZ1bmN0aW9uICgpIHtcbiAgICAgIGRldGFjaFRyYWNrZXIobm9kZSk7XG4gICAgICBkZWxldGUgbm9kZVt2YWx1ZUZpZWxkXTtcbiAgICB9XG4gIH07XG4gIHJldHVybiB0cmFja2VyO1xufVxuXG5mdW5jdGlvbiB0cmFjayhub2RlKSB7XG4gIGlmIChnZXRUcmFja2VyKG5vZGUpKSB7XG4gICAgcmV0dXJuO1xuICB9IC8vIFRPRE86IE9uY2UgaXQncyBqdXN0IEZpYmVyIHdlIGNhbiBtb3ZlIHRoaXMgdG8gbm9kZS5fd3JhcHBlclN0YXRlXG5cblxuICBub2RlLl92YWx1ZVRyYWNrZXIgPSB0cmFja1ZhbHVlT25Ob2RlKG5vZGUpO1xufVxuZnVuY3Rpb24gdXBkYXRlVmFsdWVJZkNoYW5nZWQobm9kZSkge1xuICBpZiAoIW5vZGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgdHJhY2tlciA9IGdldFRyYWNrZXIobm9kZSk7IC8vIGlmIHRoZXJlIGlzIG5vIHRyYWNrZXIgYXQgdGhpcyBwb2ludCBpdCdzIHVubGlrZWx5XG4gIC8vIHRoYXQgdHJ5aW5nIGFnYWluIHdpbGwgc3VjY2VlZFxuXG4gIGlmICghdHJhY2tlcikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgdmFyIGxhc3RWYWx1ZSA9IHRyYWNrZXIuZ2V0VmFsdWUoKTtcbiAgdmFyIG5leHRWYWx1ZSA9IGdldFZhbHVlRnJvbU5vZGUobm9kZSk7XG5cbiAgaWYgKG5leHRWYWx1ZSAhPT0gbGFzdFZhbHVlKSB7XG4gICAgdHJhY2tlci5zZXRWYWx1ZShuZXh0VmFsdWUpO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBnZXRBY3RpdmVFbGVtZW50KGRvYykge1xuICBkb2MgPSBkb2MgfHwgKHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgPyBkb2N1bWVudCA6IHVuZGVmaW5lZCk7XG5cbiAgaWYgKHR5cGVvZiBkb2MgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB0cnkge1xuICAgIHJldHVybiBkb2MuYWN0aXZlRWxlbWVudCB8fCBkb2MuYm9keTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBkb2MuYm9keTtcbiAgfVxufVxuXG52YXIgZGlkV2FyblZhbHVlRGVmYXVsdFZhbHVlID0gZmFsc2U7XG52YXIgZGlkV2FybkNoZWNrZWREZWZhdWx0Q2hlY2tlZCA9IGZhbHNlO1xudmFyIGRpZFdhcm5Db250cm9sbGVkVG9VbmNvbnRyb2xsZWQgPSBmYWxzZTtcbnZhciBkaWRXYXJuVW5jb250cm9sbGVkVG9Db250cm9sbGVkID0gZmFsc2U7XG5cbmZ1bmN0aW9uIGlzQ29udHJvbGxlZChwcm9wcykge1xuICB2YXIgdXNlc0NoZWNrZWQgPSBwcm9wcy50eXBlID09PSAnY2hlY2tib3gnIHx8IHByb3BzLnR5cGUgPT09ICdyYWRpbyc7XG4gIHJldHVybiB1c2VzQ2hlY2tlZCA/IHByb3BzLmNoZWNrZWQgIT0gbnVsbCA6IHByb3BzLnZhbHVlICE9IG51bGw7XG59XG4vKipcbiAqIEltcGxlbWVudHMgYW4gPGlucHV0PiBob3N0IGNvbXBvbmVudCB0aGF0IGFsbG93cyBzZXR0aW5nIHRoZXNlIG9wdGlvbmFsXG4gKiBwcm9wczogYGNoZWNrZWRgLCBgdmFsdWVgLCBgZGVmYXVsdENoZWNrZWRgLCBhbmQgYGRlZmF1bHRWYWx1ZWAuXG4gKlxuICogSWYgYGNoZWNrZWRgIG9yIGB2YWx1ZWAgYXJlIG5vdCBzdXBwbGllZCAob3IgbnVsbC91bmRlZmluZWQpLCB1c2VyIGFjdGlvbnNcbiAqIHRoYXQgYWZmZWN0IHRoZSBjaGVja2VkIHN0YXRlIG9yIHZhbHVlIHdpbGwgdHJpZ2dlciB1cGRhdGVzIHRvIHRoZSBlbGVtZW50LlxuICpcbiAqIElmIHRoZXkgYXJlIHN1cHBsaWVkIChhbmQgbm90IG51bGwvdW5kZWZpbmVkKSwgdGhlIHJlbmRlcmVkIGVsZW1lbnQgd2lsbCBub3RcbiAqIHRyaWdnZXIgdXBkYXRlcyB0byB0aGUgZWxlbWVudC4gSW5zdGVhZCwgdGhlIHByb3BzIG11c3QgY2hhbmdlIGluIG9yZGVyIGZvclxuICogdGhlIHJlbmRlcmVkIGVsZW1lbnQgdG8gYmUgdXBkYXRlZC5cbiAqXG4gKiBUaGUgcmVuZGVyZWQgZWxlbWVudCB3aWxsIGJlIGluaXRpYWxpemVkIGFzIHVuY2hlY2tlZCAob3IgYGRlZmF1bHRDaGVja2VkYClcbiAqIHdpdGggYW4gZW1wdHkgdmFsdWUgKG9yIGBkZWZhdWx0VmFsdWVgKS5cbiAqXG4gKiBTZWUgaHR0cDovL3d3dy53My5vcmcvVFIvMjAxMi9XRC1odG1sNS0yMDEyMTAyNS90aGUtaW5wdXQtZWxlbWVudC5odG1sXG4gKi9cblxuXG5mdW5jdGlvbiBnZXRIb3N0UHJvcHMoZWxlbWVudCwgcHJvcHMpIHtcbiAgdmFyIG5vZGUgPSBlbGVtZW50O1xuICB2YXIgY2hlY2tlZCA9IHByb3BzLmNoZWNrZWQ7XG5cbiAgdmFyIGhvc3RQcm9wcyA9IF9hc3NpZ24oe30sIHByb3BzLCB7XG4gICAgZGVmYXVsdENoZWNrZWQ6IHVuZGVmaW5lZCxcbiAgICBkZWZhdWx0VmFsdWU6IHVuZGVmaW5lZCxcbiAgICB2YWx1ZTogdW5kZWZpbmVkLFxuICAgIGNoZWNrZWQ6IGNoZWNrZWQgIT0gbnVsbCA/IGNoZWNrZWQgOiBub2RlLl93cmFwcGVyU3RhdGUuaW5pdGlhbENoZWNrZWRcbiAgfSk7XG5cbiAgcmV0dXJuIGhvc3RQcm9wcztcbn1cbmZ1bmN0aW9uIGluaXRXcmFwcGVyU3RhdGUoZWxlbWVudCwgcHJvcHMpIHtcbiAge1xuICAgIGNoZWNrQ29udHJvbGxlZFZhbHVlUHJvcHMoJ2lucHV0JywgcHJvcHMpO1xuXG4gICAgaWYgKHByb3BzLmNoZWNrZWQgIT09IHVuZGVmaW5lZCAmJiBwcm9wcy5kZWZhdWx0Q2hlY2tlZCAhPT0gdW5kZWZpbmVkICYmICFkaWRXYXJuQ2hlY2tlZERlZmF1bHRDaGVja2VkKSB7XG4gICAgICBlcnJvcignJXMgY29udGFpbnMgYW4gaW5wdXQgb2YgdHlwZSAlcyB3aXRoIGJvdGggY2hlY2tlZCBhbmQgZGVmYXVsdENoZWNrZWQgcHJvcHMuICcgKyAnSW5wdXQgZWxlbWVudHMgbXVzdCBiZSBlaXRoZXIgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgJyArICcoc3BlY2lmeSBlaXRoZXIgdGhlIGNoZWNrZWQgcHJvcCwgb3IgdGhlIGRlZmF1bHRDaGVja2VkIHByb3AsIGJ1dCBub3QgJyArICdib3RoKS4gRGVjaWRlIGJldHdlZW4gdXNpbmcgYSBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCBpbnB1dCAnICsgJ2VsZW1lbnQgYW5kIHJlbW92ZSBvbmUgb2YgdGhlc2UgcHJvcHMuIE1vcmUgaW5mbzogJyArICdodHRwczovL3JlYWN0anMub3JnL2xpbmsvY29udHJvbGxlZC1jb21wb25lbnRzJywgZ2V0Q3VycmVudEZpYmVyT3duZXJOYW1lSW5EZXZPck51bGwoKSB8fCAnQSBjb21wb25lbnQnLCBwcm9wcy50eXBlKTtcblxuICAgICAgZGlkV2FybkNoZWNrZWREZWZhdWx0Q2hlY2tlZCA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKHByb3BzLnZhbHVlICE9PSB1bmRlZmluZWQgJiYgcHJvcHMuZGVmYXVsdFZhbHVlICE9PSB1bmRlZmluZWQgJiYgIWRpZFdhcm5WYWx1ZURlZmF1bHRWYWx1ZSkge1xuICAgICAgZXJyb3IoJyVzIGNvbnRhaW5zIGFuIGlucHV0IG9mIHR5cGUgJXMgd2l0aCBib3RoIHZhbHVlIGFuZCBkZWZhdWx0VmFsdWUgcHJvcHMuICcgKyAnSW5wdXQgZWxlbWVudHMgbXVzdCBiZSBlaXRoZXIgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgJyArICcoc3BlY2lmeSBlaXRoZXIgdGhlIHZhbHVlIHByb3AsIG9yIHRoZSBkZWZhdWx0VmFsdWUgcHJvcCwgYnV0IG5vdCAnICsgJ2JvdGgpLiBEZWNpZGUgYmV0d2VlbiB1c2luZyBhIGNvbnRyb2xsZWQgb3IgdW5jb250cm9sbGVkIGlucHV0ICcgKyAnZWxlbWVudCBhbmQgcmVtb3ZlIG9uZSBvZiB0aGVzZSBwcm9wcy4gTW9yZSBpbmZvOiAnICsgJ2h0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9jb250cm9sbGVkLWNvbXBvbmVudHMnLCBnZXRDdXJyZW50RmliZXJPd25lck5hbWVJbkRldk9yTnVsbCgpIHx8ICdBIGNvbXBvbmVudCcsIHByb3BzLnR5cGUpO1xuXG4gICAgICBkaWRXYXJuVmFsdWVEZWZhdWx0VmFsdWUgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHZhciBub2RlID0gZWxlbWVudDtcbiAgdmFyIGRlZmF1bHRWYWx1ZSA9IHByb3BzLmRlZmF1bHRWYWx1ZSA9PSBudWxsID8gJycgOiBwcm9wcy5kZWZhdWx0VmFsdWU7XG4gIG5vZGUuX3dyYXBwZXJTdGF0ZSA9IHtcbiAgICBpbml0aWFsQ2hlY2tlZDogcHJvcHMuY2hlY2tlZCAhPSBudWxsID8gcHJvcHMuY2hlY2tlZCA6IHByb3BzLmRlZmF1bHRDaGVja2VkLFxuICAgIGluaXRpYWxWYWx1ZTogZ2V0VG9TdHJpbmdWYWx1ZShwcm9wcy52YWx1ZSAhPSBudWxsID8gcHJvcHMudmFsdWUgOiBkZWZhdWx0VmFsdWUpLFxuICAgIGNvbnRyb2xsZWQ6IGlzQ29udHJvbGxlZChwcm9wcylcbiAgfTtcbn1cbmZ1bmN0aW9uIHVwZGF0ZUNoZWNrZWQoZWxlbWVudCwgcHJvcHMpIHtcbiAgdmFyIG5vZGUgPSBlbGVtZW50O1xuICB2YXIgY2hlY2tlZCA9IHByb3BzLmNoZWNrZWQ7XG5cbiAgaWYgKGNoZWNrZWQgIT0gbnVsbCkge1xuICAgIHNldFZhbHVlRm9yUHJvcGVydHkobm9kZSwgJ2NoZWNrZWQnLCBjaGVja2VkLCBmYWxzZSk7XG4gIH1cbn1cbmZ1bmN0aW9uIHVwZGF0ZVdyYXBwZXIoZWxlbWVudCwgcHJvcHMpIHtcbiAgdmFyIG5vZGUgPSBlbGVtZW50O1xuXG4gIHtcbiAgICB2YXIgY29udHJvbGxlZCA9IGlzQ29udHJvbGxlZChwcm9wcyk7XG5cbiAgICBpZiAoIW5vZGUuX3dyYXBwZXJTdGF0ZS5jb250cm9sbGVkICYmIGNvbnRyb2xsZWQgJiYgIWRpZFdhcm5VbmNvbnRyb2xsZWRUb0NvbnRyb2xsZWQpIHtcbiAgICAgIGVycm9yKCdBIGNvbXBvbmVudCBpcyBjaGFuZ2luZyBhbiB1bmNvbnRyb2xsZWQgaW5wdXQgdG8gYmUgY29udHJvbGxlZC4gJyArICdUaGlzIGlzIGxpa2VseSBjYXVzZWQgYnkgdGhlIHZhbHVlIGNoYW5naW5nIGZyb20gdW5kZWZpbmVkIHRvICcgKyAnYSBkZWZpbmVkIHZhbHVlLCB3aGljaCBzaG91bGQgbm90IGhhcHBlbi4gJyArICdEZWNpZGUgYmV0d2VlbiB1c2luZyBhIGNvbnRyb2xsZWQgb3IgdW5jb250cm9sbGVkIGlucHV0ICcgKyAnZWxlbWVudCBmb3IgdGhlIGxpZmV0aW1lIG9mIHRoZSBjb21wb25lbnQuIE1vcmUgaW5mbzogaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL2NvbnRyb2xsZWQtY29tcG9uZW50cycpO1xuXG4gICAgICBkaWRXYXJuVW5jb250cm9sbGVkVG9Db250cm9sbGVkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAobm9kZS5fd3JhcHBlclN0YXRlLmNvbnRyb2xsZWQgJiYgIWNvbnRyb2xsZWQgJiYgIWRpZFdhcm5Db250cm9sbGVkVG9VbmNvbnRyb2xsZWQpIHtcbiAgICAgIGVycm9yKCdBIGNvbXBvbmVudCBpcyBjaGFuZ2luZyBhIGNvbnRyb2xsZWQgaW5wdXQgdG8gYmUgdW5jb250cm9sbGVkLiAnICsgJ1RoaXMgaXMgbGlrZWx5IGNhdXNlZCBieSB0aGUgdmFsdWUgY2hhbmdpbmcgZnJvbSBhIGRlZmluZWQgdG8gJyArICd1bmRlZmluZWQsIHdoaWNoIHNob3VsZCBub3QgaGFwcGVuLiAnICsgJ0RlY2lkZSBiZXR3ZWVuIHVzaW5nIGEgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgaW5wdXQgJyArICdlbGVtZW50IGZvciB0aGUgbGlmZXRpbWUgb2YgdGhlIGNvbXBvbmVudC4gTW9yZSBpbmZvOiBodHRwczovL3JlYWN0anMub3JnL2xpbmsvY29udHJvbGxlZC1jb21wb25lbnRzJyk7XG5cbiAgICAgIGRpZFdhcm5Db250cm9sbGVkVG9VbmNvbnRyb2xsZWQgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHVwZGF0ZUNoZWNrZWQoZWxlbWVudCwgcHJvcHMpO1xuICB2YXIgdmFsdWUgPSBnZXRUb1N0cmluZ1ZhbHVlKHByb3BzLnZhbHVlKTtcbiAgdmFyIHR5cGUgPSBwcm9wcy50eXBlO1xuXG4gIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgaWYgKHR5cGUgPT09ICdudW1iZXInKSB7XG4gICAgICBpZiAodmFsdWUgPT09IDAgJiYgbm9kZS52YWx1ZSA9PT0gJycgfHwgLy8gV2UgZXhwbGljaXRseSB3YW50IHRvIGNvZXJjZSB0byBudW1iZXIgaGVyZSBpZiBwb3NzaWJsZS5cbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgICAgbm9kZS52YWx1ZSAhPSB2YWx1ZSkge1xuICAgICAgICBub2RlLnZhbHVlID0gdG9TdHJpbmcodmFsdWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobm9kZS52YWx1ZSAhPT0gdG9TdHJpbmcodmFsdWUpKSB7XG4gICAgICBub2RlLnZhbHVlID0gdG9TdHJpbmcodmFsdWUpO1xuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlID09PSAnc3VibWl0JyB8fCB0eXBlID09PSAncmVzZXQnKSB7XG4gICAgLy8gU3VibWl0L3Jlc2V0IGlucHV0cyBuZWVkIHRoZSBhdHRyaWJ1dGUgcmVtb3ZlZCBjb21wbGV0ZWx5IHRvIGF2b2lkXG4gICAgLy8gYmxhbmstdGV4dCBidXR0b25zLlxuICAgIG5vZGUucmVtb3ZlQXR0cmlidXRlKCd2YWx1ZScpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHtcbiAgICAvLyBXaGVuIHN5bmNpbmcgdGhlIHZhbHVlIGF0dHJpYnV0ZSwgdGhlIHZhbHVlIGNvbWVzIGZyb20gYSBjYXNjYWRlIG9mXG4gICAgLy8gcHJvcGVydGllczpcbiAgICAvLyAgMS4gVGhlIHZhbHVlIFJlYWN0IHByb3BlcnR5XG4gICAgLy8gIDIuIFRoZSBkZWZhdWx0VmFsdWUgUmVhY3QgcHJvcGVydHlcbiAgICAvLyAgMy4gT3RoZXJ3aXNlIHRoZXJlIHNob3VsZCBiZSBubyBjaGFuZ2VcbiAgICBpZiAocHJvcHMuaGFzT3duUHJvcGVydHkoJ3ZhbHVlJykpIHtcbiAgICAgIHNldERlZmF1bHRWYWx1ZShub2RlLCBwcm9wcy50eXBlLCB2YWx1ZSk7XG4gICAgfSBlbHNlIGlmIChwcm9wcy5oYXNPd25Qcm9wZXJ0eSgnZGVmYXVsdFZhbHVlJykpIHtcbiAgICAgIHNldERlZmF1bHRWYWx1ZShub2RlLCBwcm9wcy50eXBlLCBnZXRUb1N0cmluZ1ZhbHVlKHByb3BzLmRlZmF1bHRWYWx1ZSkpO1xuICAgIH1cbiAgfVxuXG4gIHtcbiAgICAvLyBXaGVuIHN5bmNpbmcgdGhlIGNoZWNrZWQgYXR0cmlidXRlLCBpdCBvbmx5IGNoYW5nZXMgd2hlbiBpdCBuZWVkc1xuICAgIC8vIHRvIGJlIHJlbW92ZWQsIHN1Y2ggYXMgdHJhbnNpdGlvbmluZyBmcm9tIGEgY2hlY2tib3ggaW50byBhIHRleHQgaW5wdXRcbiAgICBpZiAocHJvcHMuY2hlY2tlZCA9PSBudWxsICYmIHByb3BzLmRlZmF1bHRDaGVja2VkICE9IG51bGwpIHtcbiAgICAgIG5vZGUuZGVmYXVsdENoZWNrZWQgPSAhIXByb3BzLmRlZmF1bHRDaGVja2VkO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gcG9zdE1vdW50V3JhcHBlcihlbGVtZW50LCBwcm9wcywgaXNIeWRyYXRpbmcpIHtcbiAgdmFyIG5vZGUgPSBlbGVtZW50OyAvLyBEbyBub3QgYXNzaWduIHZhbHVlIGlmIGl0IGlzIGFscmVhZHkgc2V0LiBUaGlzIHByZXZlbnRzIHVzZXIgdGV4dCBpbnB1dFxuICAvLyBmcm9tIGJlaW5nIGxvc3QgZHVyaW5nIFNTUiBoeWRyYXRpb24uXG5cbiAgaWYgKHByb3BzLmhhc093blByb3BlcnR5KCd2YWx1ZScpIHx8IHByb3BzLmhhc093blByb3BlcnR5KCdkZWZhdWx0VmFsdWUnKSkge1xuICAgIHZhciB0eXBlID0gcHJvcHMudHlwZTtcbiAgICB2YXIgaXNCdXR0b24gPSB0eXBlID09PSAnc3VibWl0JyB8fCB0eXBlID09PSAncmVzZXQnOyAvLyBBdm9pZCBzZXR0aW5nIHZhbHVlIGF0dHJpYnV0ZSBvbiBzdWJtaXQvcmVzZXQgaW5wdXRzIGFzIGl0IG92ZXJyaWRlcyB0aGVcbiAgICAvLyBkZWZhdWx0IHZhbHVlIHByb3ZpZGVkIGJ5IHRoZSBicm93c2VyLiBTZWU6ICMxMjg3MlxuXG4gICAgaWYgKGlzQnV0dG9uICYmIChwcm9wcy52YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHByb3BzLnZhbHVlID09PSBudWxsKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBpbml0aWFsVmFsdWUgPSB0b1N0cmluZyhub2RlLl93cmFwcGVyU3RhdGUuaW5pdGlhbFZhbHVlKTsgLy8gRG8gbm90IGFzc2lnbiB2YWx1ZSBpZiBpdCBpcyBhbHJlYWR5IHNldC4gVGhpcyBwcmV2ZW50cyB1c2VyIHRleHQgaW5wdXRcbiAgICAvLyBmcm9tIGJlaW5nIGxvc3QgZHVyaW5nIFNTUiBoeWRyYXRpb24uXG5cbiAgICBpZiAoIWlzSHlkcmF0aW5nKSB7XG4gICAgICB7XG4gICAgICAgIC8vIFdoZW4gc3luY2luZyB0aGUgdmFsdWUgYXR0cmlidXRlLCB0aGUgdmFsdWUgcHJvcGVydHkgc2hvdWxkIHVzZVxuICAgICAgICAvLyB0aGUgd3JhcHBlclN0YXRlLl9pbml0aWFsVmFsdWUgcHJvcGVydHkuIFRoaXMgdXNlczpcbiAgICAgICAgLy9cbiAgICAgICAgLy8gICAxLiBUaGUgdmFsdWUgUmVhY3QgcHJvcGVydHkgd2hlbiBwcmVzZW50XG4gICAgICAgIC8vICAgMi4gVGhlIGRlZmF1bHRWYWx1ZSBSZWFjdCBwcm9wZXJ0eSB3aGVuIHByZXNlbnRcbiAgICAgICAgLy8gICAzLiBBbiBlbXB0eSBzdHJpbmdcbiAgICAgICAgaWYgKGluaXRpYWxWYWx1ZSAhPT0gbm9kZS52YWx1ZSkge1xuICAgICAgICAgIG5vZGUudmFsdWUgPSBpbml0aWFsVmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB7XG4gICAgICAvLyBPdGhlcndpc2UsIHRoZSB2YWx1ZSBhdHRyaWJ1dGUgaXMgc3luY2hyb25pemVkIHRvIHRoZSBwcm9wZXJ0eSxcbiAgICAgIC8vIHNvIHdlIGFzc2lnbiBkZWZhdWx0VmFsdWUgdG8gdGhlIHNhbWUgdGhpbmcgYXMgdGhlIHZhbHVlIHByb3BlcnR5XG4gICAgICAvLyBhc3NpZ25tZW50IHN0ZXAgYWJvdmUuXG4gICAgICBub2RlLmRlZmF1bHRWYWx1ZSA9IGluaXRpYWxWYWx1ZTtcbiAgICB9XG4gIH0gLy8gTm9ybWFsbHksIHdlJ2QganVzdCBkbyBgbm9kZS5jaGVja2VkID0gbm9kZS5jaGVja2VkYCB1cG9uIGluaXRpYWwgbW91bnQsIGxlc3MgdGhpcyBidWdcbiAgLy8gdGhpcyBpcyBuZWVkZWQgdG8gd29yayBhcm91bmQgYSBjaHJvbWUgYnVnIHdoZXJlIHNldHRpbmcgZGVmYXVsdENoZWNrZWRcbiAgLy8gd2lsbCBzb21ldGltZXMgaW5mbHVlbmNlIHRoZSB2YWx1ZSBvZiBjaGVja2VkIChldmVuIGFmdGVyIGRldGFjaG1lbnQpLlxuICAvLyBSZWZlcmVuY2U6IGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTYwODQxNlxuICAvLyBXZSBuZWVkIHRvIHRlbXBvcmFyaWx5IHVuc2V0IG5hbWUgdG8gYXZvaWQgZGlzcnVwdGluZyByYWRpbyBidXR0b24gZ3JvdXBzLlxuXG5cbiAgdmFyIG5hbWUgPSBub2RlLm5hbWU7XG5cbiAgaWYgKG5hbWUgIT09ICcnKSB7XG4gICAgbm9kZS5uYW1lID0gJyc7XG4gIH1cblxuICB7XG4gICAgLy8gV2hlbiBzeW5jaW5nIHRoZSBjaGVja2VkIGF0dHJpYnV0ZSwgYm90aCB0aGUgY2hlY2tlZCBwcm9wZXJ0eSBhbmRcbiAgICAvLyBhdHRyaWJ1dGUgYXJlIGFzc2lnbmVkIGF0IHRoZSBzYW1lIHRpbWUgdXNpbmcgZGVmYXVsdENoZWNrZWQuIFRoaXMgdXNlczpcbiAgICAvL1xuICAgIC8vICAgMS4gVGhlIGNoZWNrZWQgUmVhY3QgcHJvcGVydHkgd2hlbiBwcmVzZW50XG4gICAgLy8gICAyLiBUaGUgZGVmYXVsdENoZWNrZWQgUmVhY3QgcHJvcGVydHkgd2hlbiBwcmVzZW50XG4gICAgLy8gICAzLiBPdGhlcndpc2UsIGZhbHNlXG4gICAgbm9kZS5kZWZhdWx0Q2hlY2tlZCA9ICFub2RlLmRlZmF1bHRDaGVja2VkO1xuICAgIG5vZGUuZGVmYXVsdENoZWNrZWQgPSAhIW5vZGUuX3dyYXBwZXJTdGF0ZS5pbml0aWFsQ2hlY2tlZDtcbiAgfVxuXG4gIGlmIChuYW1lICE9PSAnJykge1xuICAgIG5vZGUubmFtZSA9IG5hbWU7XG4gIH1cbn1cbmZ1bmN0aW9uIHJlc3RvcmVDb250cm9sbGVkU3RhdGUoZWxlbWVudCwgcHJvcHMpIHtcbiAgdmFyIG5vZGUgPSBlbGVtZW50O1xuICB1cGRhdGVXcmFwcGVyKG5vZGUsIHByb3BzKTtcbiAgdXBkYXRlTmFtZWRDb3VzaW5zKG5vZGUsIHByb3BzKTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlTmFtZWRDb3VzaW5zKHJvb3ROb2RlLCBwcm9wcykge1xuICB2YXIgbmFtZSA9IHByb3BzLm5hbWU7XG5cbiAgaWYgKHByb3BzLnR5cGUgPT09ICdyYWRpbycgJiYgbmFtZSAhPSBudWxsKSB7XG4gICAgdmFyIHF1ZXJ5Um9vdCA9IHJvb3ROb2RlO1xuXG4gICAgd2hpbGUgKHF1ZXJ5Um9vdC5wYXJlbnROb2RlKSB7XG4gICAgICBxdWVyeVJvb3QgPSBxdWVyeVJvb3QucGFyZW50Tm9kZTtcbiAgICB9IC8vIElmIGByb290Tm9kZS5mb3JtYCB3YXMgbm9uLW51bGwsIHRoZW4gd2UgY291bGQgdHJ5IGBmb3JtLmVsZW1lbnRzYCxcbiAgICAvLyBidXQgdGhhdCBzb21ldGltZXMgYmVoYXZlcyBzdHJhbmdlbHkgaW4gSUU4LiBXZSBjb3VsZCBhbHNvIHRyeSB1c2luZ1xuICAgIC8vIGBmb3JtLmdldEVsZW1lbnRzQnlOYW1lYCwgYnV0IHRoYXQgd2lsbCBvbmx5IHJldHVybiBkaXJlY3QgY2hpbGRyZW5cbiAgICAvLyBhbmQgd29uJ3QgaW5jbHVkZSBpbnB1dHMgdGhhdCB1c2UgdGhlIEhUTUw1IGBmb3JtPWAgYXR0cmlidXRlLiBTaW5jZVxuICAgIC8vIHRoZSBpbnB1dCBtaWdodCBub3QgZXZlbiBiZSBpbiBhIGZvcm0uIEl0IG1pZ2h0IG5vdCBldmVuIGJlIGluIHRoZVxuICAgIC8vIGRvY3VtZW50LiBMZXQncyBqdXN0IHVzZSB0aGUgbG9jYWwgYHF1ZXJ5U2VsZWN0b3JBbGxgIHRvIGVuc3VyZSB3ZSBkb24ndFxuICAgIC8vIG1pc3MgYW55dGhpbmcuXG5cblxuICAgIHZhciBncm91cCA9IHF1ZXJ5Um9vdC5xdWVyeVNlbGVjdG9yQWxsKCdpbnB1dFtuYW1lPScgKyBKU09OLnN0cmluZ2lmeSgnJyArIG5hbWUpICsgJ11bdHlwZT1cInJhZGlvXCJdJyk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGdyb3VwLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgb3RoZXJOb2RlID0gZ3JvdXBbaV07XG5cbiAgICAgIGlmIChvdGhlck5vZGUgPT09IHJvb3ROb2RlIHx8IG90aGVyTm9kZS5mb3JtICE9PSByb290Tm9kZS5mb3JtKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfSAvLyBUaGlzIHdpbGwgdGhyb3cgaWYgcmFkaW8gYnV0dG9ucyByZW5kZXJlZCBieSBkaWZmZXJlbnQgY29waWVzIG9mIFJlYWN0XG4gICAgICAvLyBhbmQgdGhlIHNhbWUgbmFtZSBhcmUgcmVuZGVyZWQgaW50byB0aGUgc2FtZSBmb3JtIChzYW1lIGFzICMxOTM5KS5cbiAgICAgIC8vIFRoYXQncyBwcm9iYWJseSBva2F5OyB3ZSBkb24ndCBzdXBwb3J0IGl0IGp1c3QgYXMgd2UgZG9uJ3Qgc3VwcG9ydFxuICAgICAgLy8gbWl4aW5nIFJlYWN0IHJhZGlvIGJ1dHRvbnMgd2l0aCBub24tUmVhY3Qgb25lcy5cblxuXG4gICAgICB2YXIgb3RoZXJQcm9wcyA9IGdldEZpYmVyQ3VycmVudFByb3BzRnJvbU5vZGUob3RoZXJOb2RlKTtcblxuICAgICAgaWYgKCFvdGhlclByb3BzKSB7XG4gICAgICAgIHtcbiAgICAgICAgICB0aHJvdyBFcnJvciggXCJSZWFjdERPTUlucHV0OiBNaXhpbmcgUmVhY3QgYW5kIG5vbi1SZWFjdCByYWRpbyBpbnB1dHMgd2l0aCB0aGUgc2FtZSBgbmFtZWAgaXMgbm90IHN1cHBvcnRlZC5cIiApO1xuICAgICAgICB9XG4gICAgICB9IC8vIFdlIG5lZWQgdXBkYXRlIHRoZSB0cmFja2VkIHZhbHVlIG9uIHRoZSBuYW1lZCBjb3VzaW4gc2luY2UgdGhlIHZhbHVlXG4gICAgICAvLyB3YXMgY2hhbmdlZCBidXQgdGhlIGlucHV0IHNhdyBubyBldmVudCBvciB2YWx1ZSBzZXRcblxuXG4gICAgICB1cGRhdGVWYWx1ZUlmQ2hhbmdlZChvdGhlck5vZGUpOyAvLyBJZiB0aGlzIGlzIGEgY29udHJvbGxlZCByYWRpbyBidXR0b24gZ3JvdXAsIGZvcmNpbmcgdGhlIGlucHV0IHRoYXRcbiAgICAgIC8vIHdhcyBwcmV2aW91c2x5IGNoZWNrZWQgdG8gdXBkYXRlIHdpbGwgY2F1c2UgaXQgdG8gYmUgY29tZSByZS1jaGVja2VkXG4gICAgICAvLyBhcyBhcHByb3ByaWF0ZS5cblxuICAgICAgdXBkYXRlV3JhcHBlcihvdGhlck5vZGUsIG90aGVyUHJvcHMpO1xuICAgIH1cbiAgfVxufSAvLyBJbiBDaHJvbWUsIGFzc2lnbmluZyBkZWZhdWx0VmFsdWUgdG8gY2VydGFpbiBpbnB1dCB0eXBlcyB0cmlnZ2VycyBpbnB1dCB2YWxpZGF0aW9uLlxuLy8gRm9yIG51bWJlciBpbnB1dHMsIHRoZSBkaXNwbGF5IHZhbHVlIGxvc2VzIHRyYWlsaW5nIGRlY2ltYWwgcG9pbnRzLiBGb3IgZW1haWwgaW5wdXRzLFxuLy8gQ2hyb21lIHJhaXNlcyBcIlRoZSBzcGVjaWZpZWQgdmFsdWUgPHg+IGlzIG5vdCBhIHZhbGlkIGVtYWlsIGFkZHJlc3NcIi5cbi8vXG4vLyBIZXJlIHdlIGNoZWNrIHRvIHNlZSBpZiB0aGUgZGVmYXVsdFZhbHVlIGhhcyBhY3R1YWxseSBjaGFuZ2VkLCBhdm9pZGluZyB0aGVzZSBwcm9ibGVtc1xuLy8gd2hlbiB0aGUgdXNlciBpcyBpbnB1dHRpbmcgdGV4dFxuLy9cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvNzI1M1xuXG5cbmZ1bmN0aW9uIHNldERlZmF1bHRWYWx1ZShub2RlLCB0eXBlLCB2YWx1ZSkge1xuICBpZiAoIC8vIEZvY3VzZWQgbnVtYmVyIGlucHV0cyBzeW5jaHJvbml6ZSBvbiBibHVyLiBTZWUgQ2hhbmdlRXZlbnRQbHVnaW4uanNcbiAgdHlwZSAhPT0gJ251bWJlcicgfHwgZ2V0QWN0aXZlRWxlbWVudChub2RlLm93bmVyRG9jdW1lbnQpICE9PSBub2RlKSB7XG4gICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgIG5vZGUuZGVmYXVsdFZhbHVlID0gdG9TdHJpbmcobm9kZS5fd3JhcHBlclN0YXRlLmluaXRpYWxWYWx1ZSk7XG4gICAgfSBlbHNlIGlmIChub2RlLmRlZmF1bHRWYWx1ZSAhPT0gdG9TdHJpbmcodmFsdWUpKSB7XG4gICAgICBub2RlLmRlZmF1bHRWYWx1ZSA9IHRvU3RyaW5nKHZhbHVlKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIGRpZFdhcm5TZWxlY3RlZFNldE9uT3B0aW9uID0gZmFsc2U7XG52YXIgZGlkV2FybkludmFsaWRDaGlsZCA9IGZhbHNlO1xuXG5mdW5jdGlvbiBmbGF0dGVuQ2hpbGRyZW4oY2hpbGRyZW4pIHtcbiAgdmFyIGNvbnRlbnQgPSAnJzsgLy8gRmxhdHRlbiBjaGlsZHJlbi4gV2UnbGwgd2FybiBpZiB0aGV5IGFyZSBpbnZhbGlkXG4gIC8vIGR1cmluZyB2YWxpZGF0ZVByb3BzKCkgd2hpY2ggcnVucyBmb3IgaHlkcmF0aW9uIHRvby5cbiAgLy8gTm90ZSB0aGF0IHRoaXMgd291bGQgdGhyb3cgb24gbm9uLWVsZW1lbnQgb2JqZWN0cy5cbiAgLy8gRWxlbWVudHMgYXJlIHN0cmluZ2lmaWVkICh3aGljaCBpcyBub3JtYWxseSBpcnJlbGV2YW50XG4gIC8vIGJ1dCBtYXR0ZXJzIGZvciA8ZmJ0PikuXG5cbiAgUmVhY3QuQ2hpbGRyZW4uZm9yRWFjaChjaGlsZHJlbiwgZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgaWYgKGNoaWxkID09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb250ZW50ICs9IGNoaWxkOyAvLyBOb3RlOiB3ZSBkb24ndCB3YXJuIGFib3V0IGludmFsaWQgY2hpbGRyZW4gaGVyZS5cbiAgICAvLyBJbnN0ZWFkLCB0aGlzIGlzIGRvbmUgc2VwYXJhdGVseSBiZWxvdyBzbyB0aGF0XG4gICAgLy8gaXQgaGFwcGVucyBkdXJpbmcgdGhlIGh5ZHJhdGlvbiBjb2RlIHBhdGggdG9vLlxuICB9KTtcbiAgcmV0dXJuIGNvbnRlbnQ7XG59XG4vKipcbiAqIEltcGxlbWVudHMgYW4gPG9wdGlvbj4gaG9zdCBjb21wb25lbnQgdGhhdCB3YXJucyB3aGVuIGBzZWxlY3RlZGAgaXMgc2V0LlxuICovXG5cblxuZnVuY3Rpb24gdmFsaWRhdGVQcm9wcyhlbGVtZW50LCBwcm9wcykge1xuICB7XG4gICAgLy8gVGhpcyBtaXJyb3JzIHRoZSBjb2RlIHBhdGggYWJvdmUsIGJ1dCBydW5zIGZvciBoeWRyYXRpb24gdG9vLlxuICAgIC8vIFdhcm4gYWJvdXQgaW52YWxpZCBjaGlsZHJlbiBoZXJlIHNvIHRoYXQgY2xpZW50IGFuZCBoeWRyYXRpb24gYXJlIGNvbnNpc3RlbnQuXG4gICAgLy8gVE9ETzogdGhpcyBzZWVtcyBsaWtlIGl0IGNvdWxkIGNhdXNlIGEgREVWLW9ubHkgdGhyb3cgZm9yIGh5ZHJhdGlvblxuICAgIC8vIGlmIGNoaWxkcmVuIGNvbnRhaW5zIGEgbm9uLWVsZW1lbnQgb2JqZWN0LiBXZSBzaG91bGQgdHJ5IHRvIGF2b2lkIHRoYXQuXG4gICAgaWYgKHR5cGVvZiBwcm9wcy5jaGlsZHJlbiA9PT0gJ29iamVjdCcgJiYgcHJvcHMuY2hpbGRyZW4gIT09IG51bGwpIHtcbiAgICAgIFJlYWN0LkNoaWxkcmVuLmZvckVhY2gocHJvcHMuY2hpbGRyZW4sIGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICBpZiAoY2hpbGQgPT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgY2hpbGQgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBjaGlsZCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGNoaWxkLnR5cGUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFkaWRXYXJuSW52YWxpZENoaWxkKSB7XG4gICAgICAgICAgZGlkV2FybkludmFsaWRDaGlsZCA9IHRydWU7XG5cbiAgICAgICAgICBlcnJvcignT25seSBzdHJpbmdzIGFuZCBudW1iZXJzIGFyZSBzdXBwb3J0ZWQgYXMgPG9wdGlvbj4gY2hpbGRyZW4uJyk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gLy8gVE9ETzogUmVtb3ZlIHN1cHBvcnQgZm9yIGBzZWxlY3RlZGAgaW4gPG9wdGlvbj4uXG5cblxuICAgIGlmIChwcm9wcy5zZWxlY3RlZCAhPSBudWxsICYmICFkaWRXYXJuU2VsZWN0ZWRTZXRPbk9wdGlvbikge1xuICAgICAgZXJyb3IoJ1VzZSB0aGUgYGRlZmF1bHRWYWx1ZWAgb3IgYHZhbHVlYCBwcm9wcyBvbiA8c2VsZWN0PiBpbnN0ZWFkIG9mICcgKyAnc2V0dGluZyBgc2VsZWN0ZWRgIG9uIDxvcHRpb24+LicpO1xuXG4gICAgICBkaWRXYXJuU2VsZWN0ZWRTZXRPbk9wdGlvbiA9IHRydWU7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBwb3N0TW91bnRXcmFwcGVyJDEoZWxlbWVudCwgcHJvcHMpIHtcbiAgLy8gdmFsdWU9XCJcIiBzaG91bGQgbWFrZSBhIHZhbHVlIGF0dHJpYnV0ZSAoIzYyMTkpXG4gIGlmIChwcm9wcy52YWx1ZSAhPSBudWxsKSB7XG4gICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3ZhbHVlJywgdG9TdHJpbmcoZ2V0VG9TdHJpbmdWYWx1ZShwcm9wcy52YWx1ZSkpKTtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0SG9zdFByb3BzJDEoZWxlbWVudCwgcHJvcHMpIHtcbiAgdmFyIGhvc3RQcm9wcyA9IF9hc3NpZ24oe1xuICAgIGNoaWxkcmVuOiB1bmRlZmluZWRcbiAgfSwgcHJvcHMpO1xuXG4gIHZhciBjb250ZW50ID0gZmxhdHRlbkNoaWxkcmVuKHByb3BzLmNoaWxkcmVuKTtcblxuICBpZiAoY29udGVudCkge1xuICAgIGhvc3RQcm9wcy5jaGlsZHJlbiA9IGNvbnRlbnQ7XG4gIH1cblxuICByZXR1cm4gaG9zdFByb3BzO1xufVxuXG52YXIgZGlkV2FyblZhbHVlRGVmYXVsdFZhbHVlJDE7XG5cbntcbiAgZGlkV2FyblZhbHVlRGVmYXVsdFZhbHVlJDEgPSBmYWxzZTtcbn1cblxuZnVuY3Rpb24gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKCkge1xuICB2YXIgb3duZXJOYW1lID0gZ2V0Q3VycmVudEZpYmVyT3duZXJOYW1lSW5EZXZPck51bGwoKTtcblxuICBpZiAob3duZXJOYW1lKSB7XG4gICAgcmV0dXJuICdcXG5cXG5DaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBgJyArIG93bmVyTmFtZSArICdgLic7XG4gIH1cblxuICByZXR1cm4gJyc7XG59XG5cbnZhciB2YWx1ZVByb3BOYW1lcyA9IFsndmFsdWUnLCAnZGVmYXVsdFZhbHVlJ107XG4vKipcbiAqIFZhbGlkYXRpb24gZnVuY3Rpb24gZm9yIGB2YWx1ZWAgYW5kIGBkZWZhdWx0VmFsdWVgLlxuICovXG5cbmZ1bmN0aW9uIGNoZWNrU2VsZWN0UHJvcFR5cGVzKHByb3BzKSB7XG4gIHtcbiAgICBjaGVja0NvbnRyb2xsZWRWYWx1ZVByb3BzKCdzZWxlY3QnLCBwcm9wcyk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlUHJvcE5hbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgcHJvcE5hbWUgPSB2YWx1ZVByb3BOYW1lc1tpXTtcblxuICAgICAgaWYgKHByb3BzW3Byb3BOYW1lXSA9PSBudWxsKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICB2YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkocHJvcHNbcHJvcE5hbWVdKTtcblxuICAgICAgaWYgKHByb3BzLm11bHRpcGxlICYmICFpc0FycmF5KSB7XG4gICAgICAgIGVycm9yKCdUaGUgYCVzYCBwcm9wIHN1cHBsaWVkIHRvIDxzZWxlY3Q+IG11c3QgYmUgYW4gYXJyYXkgaWYgJyArICdgbXVsdGlwbGVgIGlzIHRydWUuJXMnLCBwcm9wTmFtZSwgZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKCkpO1xuICAgICAgfSBlbHNlIGlmICghcHJvcHMubXVsdGlwbGUgJiYgaXNBcnJheSkge1xuICAgICAgICBlcnJvcignVGhlIGAlc2AgcHJvcCBzdXBwbGllZCB0byA8c2VsZWN0PiBtdXN0IGJlIGEgc2NhbGFyICcgKyAndmFsdWUgaWYgYG11bHRpcGxlYCBpcyBmYWxzZS4lcycsIHByb3BOYW1lLCBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZU9wdGlvbnMobm9kZSwgbXVsdGlwbGUsIHByb3BWYWx1ZSwgc2V0RGVmYXVsdFNlbGVjdGVkKSB7XG4gIHZhciBvcHRpb25zID0gbm9kZS5vcHRpb25zO1xuXG4gIGlmIChtdWx0aXBsZSkge1xuICAgIHZhciBzZWxlY3RlZFZhbHVlcyA9IHByb3BWYWx1ZTtcbiAgICB2YXIgc2VsZWN0ZWRWYWx1ZSA9IHt9O1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWxlY3RlZFZhbHVlcy5sZW5ndGg7IGkrKykge1xuICAgICAgLy8gUHJlZml4IHRvIGF2b2lkIGNoYW9zIHdpdGggc3BlY2lhbCBrZXlzLlxuICAgICAgc2VsZWN0ZWRWYWx1ZVsnJCcgKyBzZWxlY3RlZFZhbHVlc1tpXV0gPSB0cnVlO1xuICAgIH1cblxuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBvcHRpb25zLmxlbmd0aDsgX2krKykge1xuICAgICAgdmFyIHNlbGVjdGVkID0gc2VsZWN0ZWRWYWx1ZS5oYXNPd25Qcm9wZXJ0eSgnJCcgKyBvcHRpb25zW19pXS52YWx1ZSk7XG5cbiAgICAgIGlmIChvcHRpb25zW19pXS5zZWxlY3RlZCAhPT0gc2VsZWN0ZWQpIHtcbiAgICAgICAgb3B0aW9uc1tfaV0uc2VsZWN0ZWQgPSBzZWxlY3RlZDtcbiAgICAgIH1cblxuICAgICAgaWYgKHNlbGVjdGVkICYmIHNldERlZmF1bHRTZWxlY3RlZCkge1xuICAgICAgICBvcHRpb25zW19pXS5kZWZhdWx0U2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBEbyBub3Qgc2V0IGBzZWxlY3QudmFsdWVgIGFzIGV4YWN0IGJlaGF2aW9yIGlzbid0IGNvbnNpc3RlbnQgYWNyb3NzIGFsbFxuICAgIC8vIGJyb3dzZXJzIGZvciBhbGwgY2FzZXMuXG4gICAgdmFyIF9zZWxlY3RlZFZhbHVlID0gdG9TdHJpbmcoZ2V0VG9TdHJpbmdWYWx1ZShwcm9wVmFsdWUpKTtcblxuICAgIHZhciBkZWZhdWx0U2VsZWN0ZWQgPSBudWxsO1xuXG4gICAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgb3B0aW9ucy5sZW5ndGg7IF9pMisrKSB7XG4gICAgICBpZiAob3B0aW9uc1tfaTJdLnZhbHVlID09PSBfc2VsZWN0ZWRWYWx1ZSkge1xuICAgICAgICBvcHRpb25zW19pMl0uc2VsZWN0ZWQgPSB0cnVlO1xuXG4gICAgICAgIGlmIChzZXREZWZhdWx0U2VsZWN0ZWQpIHtcbiAgICAgICAgICBvcHRpb25zW19pMl0uZGVmYXVsdFNlbGVjdGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKGRlZmF1bHRTZWxlY3RlZCA9PT0gbnVsbCAmJiAhb3B0aW9uc1tfaTJdLmRpc2FibGVkKSB7XG4gICAgICAgIGRlZmF1bHRTZWxlY3RlZCA9IG9wdGlvbnNbX2kyXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZGVmYXVsdFNlbGVjdGVkICE9PSBudWxsKSB7XG4gICAgICBkZWZhdWx0U2VsZWN0ZWQuc2VsZWN0ZWQgPSB0cnVlO1xuICAgIH1cbiAgfVxufVxuLyoqXG4gKiBJbXBsZW1lbnRzIGEgPHNlbGVjdD4gaG9zdCBjb21wb25lbnQgdGhhdCBhbGxvd3Mgb3B0aW9uYWxseSBzZXR0aW5nIHRoZVxuICogcHJvcHMgYHZhbHVlYCBhbmQgYGRlZmF1bHRWYWx1ZWAuIElmIGBtdWx0aXBsZWAgaXMgZmFsc2UsIHRoZSBwcm9wIG11c3QgYmUgYVxuICogc3RyaW5nYWJsZS4gSWYgYG11bHRpcGxlYCBpcyB0cnVlLCB0aGUgcHJvcCBtdXN0IGJlIGFuIGFycmF5IG9mIHN0cmluZ2FibGVzLlxuICpcbiAqIElmIGB2YWx1ZWAgaXMgbm90IHN1cHBsaWVkIChvciBudWxsL3VuZGVmaW5lZCksIHVzZXIgYWN0aW9ucyB0aGF0IGNoYW5nZSB0aGVcbiAqIHNlbGVjdGVkIG9wdGlvbiB3aWxsIHRyaWdnZXIgdXBkYXRlcyB0byB0aGUgcmVuZGVyZWQgb3B0aW9ucy5cbiAqXG4gKiBJZiBpdCBpcyBzdXBwbGllZCAoYW5kIG5vdCBudWxsL3VuZGVmaW5lZCksIHRoZSByZW5kZXJlZCBvcHRpb25zIHdpbGwgbm90XG4gKiB1cGRhdGUgaW4gcmVzcG9uc2UgdG8gdXNlciBhY3Rpb25zLiBJbnN0ZWFkLCB0aGUgYHZhbHVlYCBwcm9wIG11c3QgY2hhbmdlIGluXG4gKiBvcmRlciBmb3IgdGhlIHJlbmRlcmVkIG9wdGlvbnMgdG8gdXBkYXRlLlxuICpcbiAqIElmIGBkZWZhdWx0VmFsdWVgIGlzIHByb3ZpZGVkLCBhbnkgb3B0aW9ucyB3aXRoIHRoZSBzdXBwbGllZCB2YWx1ZXMgd2lsbCBiZVxuICogc2VsZWN0ZWQuXG4gKi9cblxuXG5mdW5jdGlvbiBnZXRIb3N0UHJvcHMkMihlbGVtZW50LCBwcm9wcykge1xuICByZXR1cm4gX2Fzc2lnbih7fSwgcHJvcHMsIHtcbiAgICB2YWx1ZTogdW5kZWZpbmVkXG4gIH0pO1xufVxuZnVuY3Rpb24gaW5pdFdyYXBwZXJTdGF0ZSQxKGVsZW1lbnQsIHByb3BzKSB7XG4gIHZhciBub2RlID0gZWxlbWVudDtcblxuICB7XG4gICAgY2hlY2tTZWxlY3RQcm9wVHlwZXMocHJvcHMpO1xuICB9XG5cbiAgbm9kZS5fd3JhcHBlclN0YXRlID0ge1xuICAgIHdhc011bHRpcGxlOiAhIXByb3BzLm11bHRpcGxlXG4gIH07XG5cbiAge1xuICAgIGlmIChwcm9wcy52YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHByb3BzLmRlZmF1bHRWYWx1ZSAhPT0gdW5kZWZpbmVkICYmICFkaWRXYXJuVmFsdWVEZWZhdWx0VmFsdWUkMSkge1xuICAgICAgZXJyb3IoJ1NlbGVjdCBlbGVtZW50cyBtdXN0IGJlIGVpdGhlciBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCAnICsgJyhzcGVjaWZ5IGVpdGhlciB0aGUgdmFsdWUgcHJvcCwgb3IgdGhlIGRlZmF1bHRWYWx1ZSBwcm9wLCBidXQgbm90ICcgKyAnYm90aCkuIERlY2lkZSBiZXR3ZWVuIHVzaW5nIGEgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgc2VsZWN0ICcgKyAnZWxlbWVudCBhbmQgcmVtb3ZlIG9uZSBvZiB0aGVzZSBwcm9wcy4gTW9yZSBpbmZvOiAnICsgJ2h0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9jb250cm9sbGVkLWNvbXBvbmVudHMnKTtcblxuICAgICAgZGlkV2FyblZhbHVlRGVmYXVsdFZhbHVlJDEgPSB0cnVlO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gcG9zdE1vdW50V3JhcHBlciQyKGVsZW1lbnQsIHByb3BzKSB7XG4gIHZhciBub2RlID0gZWxlbWVudDtcbiAgbm9kZS5tdWx0aXBsZSA9ICEhcHJvcHMubXVsdGlwbGU7XG4gIHZhciB2YWx1ZSA9IHByb3BzLnZhbHVlO1xuXG4gIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgdXBkYXRlT3B0aW9ucyhub2RlLCAhIXByb3BzLm11bHRpcGxlLCB2YWx1ZSwgZmFsc2UpO1xuICB9IGVsc2UgaWYgKHByb3BzLmRlZmF1bHRWYWx1ZSAhPSBudWxsKSB7XG4gICAgdXBkYXRlT3B0aW9ucyhub2RlLCAhIXByb3BzLm11bHRpcGxlLCBwcm9wcy5kZWZhdWx0VmFsdWUsIHRydWUpO1xuICB9XG59XG5mdW5jdGlvbiBwb3N0VXBkYXRlV3JhcHBlcihlbGVtZW50LCBwcm9wcykge1xuICB2YXIgbm9kZSA9IGVsZW1lbnQ7XG4gIHZhciB3YXNNdWx0aXBsZSA9IG5vZGUuX3dyYXBwZXJTdGF0ZS53YXNNdWx0aXBsZTtcbiAgbm9kZS5fd3JhcHBlclN0YXRlLndhc011bHRpcGxlID0gISFwcm9wcy5tdWx0aXBsZTtcbiAgdmFyIHZhbHVlID0gcHJvcHMudmFsdWU7XG5cbiAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICB1cGRhdGVPcHRpb25zKG5vZGUsICEhcHJvcHMubXVsdGlwbGUsIHZhbHVlLCBmYWxzZSk7XG4gIH0gZWxzZSBpZiAod2FzTXVsdGlwbGUgIT09ICEhcHJvcHMubXVsdGlwbGUpIHtcbiAgICAvLyBGb3Igc2ltcGxpY2l0eSwgcmVhcHBseSBgZGVmYXVsdFZhbHVlYCBpZiBgbXVsdGlwbGVgIGlzIHRvZ2dsZWQuXG4gICAgaWYgKHByb3BzLmRlZmF1bHRWYWx1ZSAhPSBudWxsKSB7XG4gICAgICB1cGRhdGVPcHRpb25zKG5vZGUsICEhcHJvcHMubXVsdGlwbGUsIHByb3BzLmRlZmF1bHRWYWx1ZSwgdHJ1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFJldmVydCB0aGUgc2VsZWN0IGJhY2sgdG8gaXRzIGRlZmF1bHQgdW5zZWxlY3RlZCBzdGF0ZS5cbiAgICAgIHVwZGF0ZU9wdGlvbnMobm9kZSwgISFwcm9wcy5tdWx0aXBsZSwgcHJvcHMubXVsdGlwbGUgPyBbXSA6ICcnLCBmYWxzZSk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiByZXN0b3JlQ29udHJvbGxlZFN0YXRlJDEoZWxlbWVudCwgcHJvcHMpIHtcbiAgdmFyIG5vZGUgPSBlbGVtZW50O1xuICB2YXIgdmFsdWUgPSBwcm9wcy52YWx1ZTtcblxuICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgIHVwZGF0ZU9wdGlvbnMobm9kZSwgISFwcm9wcy5tdWx0aXBsZSwgdmFsdWUsIGZhbHNlKTtcbiAgfVxufVxuXG52YXIgZGlkV2FyblZhbERlZmF1bHRWYWwgPSBmYWxzZTtcblxuLyoqXG4gKiBJbXBsZW1lbnRzIGEgPHRleHRhcmVhPiBob3N0IGNvbXBvbmVudCB0aGF0IGFsbG93cyBzZXR0aW5nIGB2YWx1ZWAsIGFuZFxuICogYGRlZmF1bHRWYWx1ZWAuIFRoaXMgZGlmZmVycyBmcm9tIHRoZSB0cmFkaXRpb25hbCBET00gQVBJIGJlY2F1c2UgdmFsdWUgaXNcbiAqIHVzdWFsbHkgc2V0IGFzIFBDREFUQSBjaGlsZHJlbi5cbiAqXG4gKiBJZiBgdmFsdWVgIGlzIG5vdCBzdXBwbGllZCAob3IgbnVsbC91bmRlZmluZWQpLCB1c2VyIGFjdGlvbnMgdGhhdCBhZmZlY3QgdGhlXG4gKiB2YWx1ZSB3aWxsIHRyaWdnZXIgdXBkYXRlcyB0byB0aGUgZWxlbWVudC5cbiAqXG4gKiBJZiBgdmFsdWVgIGlzIHN1cHBsaWVkIChhbmQgbm90IG51bGwvdW5kZWZpbmVkKSwgdGhlIHJlbmRlcmVkIGVsZW1lbnQgd2lsbFxuICogbm90IHRyaWdnZXIgdXBkYXRlcyB0byB0aGUgZWxlbWVudC4gSW5zdGVhZCwgdGhlIGB2YWx1ZWAgcHJvcCBtdXN0IGNoYW5nZSBpblxuICogb3JkZXIgZm9yIHRoZSByZW5kZXJlZCBlbGVtZW50IHRvIGJlIHVwZGF0ZWQuXG4gKlxuICogVGhlIHJlbmRlcmVkIGVsZW1lbnQgd2lsbCBiZSBpbml0aWFsaXplZCB3aXRoIGFuIGVtcHR5IHZhbHVlLCB0aGUgcHJvcFxuICogYGRlZmF1bHRWYWx1ZWAgaWYgc3BlY2lmaWVkLCBvciB0aGUgY2hpbGRyZW4gY29udGVudCAoZGVwcmVjYXRlZCkuXG4gKi9cbmZ1bmN0aW9uIGdldEhvc3RQcm9wcyQzKGVsZW1lbnQsIHByb3BzKSB7XG4gIHZhciBub2RlID0gZWxlbWVudDtcblxuICBpZiAoIShwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTCA9PSBudWxsKSkge1xuICAgIHtcbiAgICAgIHRocm93IEVycm9yKCBcImBkYW5nZXJvdXNseVNldElubmVySFRNTGAgZG9lcyBub3QgbWFrZSBzZW5zZSBvbiA8dGV4dGFyZWE+LlwiICk7XG4gICAgfVxuICB9IC8vIEFsd2F5cyBzZXQgY2hpbGRyZW4gdG8gdGhlIHNhbWUgdGhpbmcuIEluIElFOSwgdGhlIHNlbGVjdGlvbiByYW5nZSB3aWxsXG4gIC8vIGdldCByZXNldCBpZiBgdGV4dENvbnRlbnRgIGlzIG11dGF0ZWQuICBXZSBjb3VsZCBhZGQgYSBjaGVjayBpbiBzZXRUZXh0Q29udGVudFxuICAvLyB0byBvbmx5IHNldCB0aGUgdmFsdWUgaWYvd2hlbiB0aGUgdmFsdWUgZGlmZmVycyBmcm9tIHRoZSBub2RlIHZhbHVlICh3aGljaCB3b3VsZFxuICAvLyBjb21wbGV0ZWx5IHNvbHZlIHRoaXMgSUU5IGJ1ZyksIGJ1dCBTZWJhc3RpYW4rU29waGllIHNlZW1lZCB0byBsaWtlIHRoaXNcbiAgLy8gc29sdXRpb24uIFRoZSB2YWx1ZSBjYW4gYmUgYSBib29sZWFuIG9yIG9iamVjdCBzbyB0aGF0J3Mgd2h5IGl0J3MgZm9yY2VkXG4gIC8vIHRvIGJlIGEgc3RyaW5nLlxuXG5cbiAgdmFyIGhvc3RQcm9wcyA9IF9hc3NpZ24oe30sIHByb3BzLCB7XG4gICAgdmFsdWU6IHVuZGVmaW5lZCxcbiAgICBkZWZhdWx0VmFsdWU6IHVuZGVmaW5lZCxcbiAgICBjaGlsZHJlbjogdG9TdHJpbmcobm9kZS5fd3JhcHBlclN0YXRlLmluaXRpYWxWYWx1ZSlcbiAgfSk7XG5cbiAgcmV0dXJuIGhvc3RQcm9wcztcbn1cbmZ1bmN0aW9uIGluaXRXcmFwcGVyU3RhdGUkMihlbGVtZW50LCBwcm9wcykge1xuICB2YXIgbm9kZSA9IGVsZW1lbnQ7XG5cbiAge1xuICAgIGNoZWNrQ29udHJvbGxlZFZhbHVlUHJvcHMoJ3RleHRhcmVhJywgcHJvcHMpO1xuXG4gICAgaWYgKHByb3BzLnZhbHVlICE9PSB1bmRlZmluZWQgJiYgcHJvcHMuZGVmYXVsdFZhbHVlICE9PSB1bmRlZmluZWQgJiYgIWRpZFdhcm5WYWxEZWZhdWx0VmFsKSB7XG4gICAgICBlcnJvcignJXMgY29udGFpbnMgYSB0ZXh0YXJlYSB3aXRoIGJvdGggdmFsdWUgYW5kIGRlZmF1bHRWYWx1ZSBwcm9wcy4gJyArICdUZXh0YXJlYSBlbGVtZW50cyBtdXN0IGJlIGVpdGhlciBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCAnICsgJyhzcGVjaWZ5IGVpdGhlciB0aGUgdmFsdWUgcHJvcCwgb3IgdGhlIGRlZmF1bHRWYWx1ZSBwcm9wLCBidXQgbm90ICcgKyAnYm90aCkuIERlY2lkZSBiZXR3ZWVuIHVzaW5nIGEgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgdGV4dGFyZWEgJyArICdhbmQgcmVtb3ZlIG9uZSBvZiB0aGVzZSBwcm9wcy4gTW9yZSBpbmZvOiAnICsgJ2h0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9jb250cm9sbGVkLWNvbXBvbmVudHMnLCBnZXRDdXJyZW50RmliZXJPd25lck5hbWVJbkRldk9yTnVsbCgpIHx8ICdBIGNvbXBvbmVudCcpO1xuXG4gICAgICBkaWRXYXJuVmFsRGVmYXVsdFZhbCA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgdmFyIGluaXRpYWxWYWx1ZSA9IHByb3BzLnZhbHVlOyAvLyBPbmx5IGJvdGhlciBmZXRjaGluZyBkZWZhdWx0IHZhbHVlIGlmIHdlJ3JlIGdvaW5nIHRvIHVzZSBpdFxuXG4gIGlmIChpbml0aWFsVmFsdWUgPT0gbnVsbCkge1xuICAgIHZhciBjaGlsZHJlbiA9IHByb3BzLmNoaWxkcmVuLFxuICAgICAgICBkZWZhdWx0VmFsdWUgPSBwcm9wcy5kZWZhdWx0VmFsdWU7XG5cbiAgICBpZiAoY2hpbGRyZW4gIT0gbnVsbCkge1xuICAgICAge1xuICAgICAgICBlcnJvcignVXNlIHRoZSBgZGVmYXVsdFZhbHVlYCBvciBgdmFsdWVgIHByb3BzIGluc3RlYWQgb2Ygc2V0dGluZyAnICsgJ2NoaWxkcmVuIG9uIDx0ZXh0YXJlYT4uJyk7XG4gICAgICB9XG5cbiAgICAgIHtcbiAgICAgICAgaWYgKCEoZGVmYXVsdFZhbHVlID09IG51bGwpKSB7XG4gICAgICAgICAge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoIFwiSWYgeW91IHN1cHBseSBgZGVmYXVsdFZhbHVlYCBvbiBhIDx0ZXh0YXJlYT4sIGRvIG5vdCBwYXNzIGNoaWxkcmVuLlwiICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pKSB7XG4gICAgICAgICAgaWYgKCEoY2hpbGRyZW4ubGVuZ3RoIDw9IDEpKSB7XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHRocm93IEVycm9yKCBcIjx0ZXh0YXJlYT4gY2FuIG9ubHkgaGF2ZSBhdCBtb3N0IG9uZSBjaGlsZC5cIiApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGNoaWxkcmVuID0gY2hpbGRyZW5bMF07XG4gICAgICAgIH1cblxuICAgICAgICBkZWZhdWx0VmFsdWUgPSBjaGlsZHJlbjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZGVmYXVsdFZhbHVlID09IG51bGwpIHtcbiAgICAgIGRlZmF1bHRWYWx1ZSA9ICcnO1xuICAgIH1cblxuICAgIGluaXRpYWxWYWx1ZSA9IGRlZmF1bHRWYWx1ZTtcbiAgfVxuXG4gIG5vZGUuX3dyYXBwZXJTdGF0ZSA9IHtcbiAgICBpbml0aWFsVmFsdWU6IGdldFRvU3RyaW5nVmFsdWUoaW5pdGlhbFZhbHVlKVxuICB9O1xufVxuZnVuY3Rpb24gdXBkYXRlV3JhcHBlciQxKGVsZW1lbnQsIHByb3BzKSB7XG4gIHZhciBub2RlID0gZWxlbWVudDtcbiAgdmFyIHZhbHVlID0gZ2V0VG9TdHJpbmdWYWx1ZShwcm9wcy52YWx1ZSk7XG4gIHZhciBkZWZhdWx0VmFsdWUgPSBnZXRUb1N0cmluZ1ZhbHVlKHByb3BzLmRlZmF1bHRWYWx1ZSk7XG5cbiAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAvLyBDYXN0IGB2YWx1ZWAgdG8gYSBzdHJpbmcgdG8gZW5zdXJlIHRoZSB2YWx1ZSBpcyBzZXQgY29ycmVjdGx5LiBXaGlsZVxuICAgIC8vIGJyb3dzZXJzIHR5cGljYWxseSBkbyB0aGlzIGFzIG5lY2Vzc2FyeSwganNkb20gZG9lc24ndC5cbiAgICB2YXIgbmV3VmFsdWUgPSB0b1N0cmluZyh2YWx1ZSk7IC8vIFRvIGF2b2lkIHNpZGUgZWZmZWN0cyAoc3VjaCBhcyBsb3NpbmcgdGV4dCBzZWxlY3Rpb24pLCBvbmx5IHNldCB2YWx1ZSBpZiBjaGFuZ2VkXG5cbiAgICBpZiAobmV3VmFsdWUgIT09IG5vZGUudmFsdWUpIHtcbiAgICAgIG5vZGUudmFsdWUgPSBuZXdWYWx1ZTtcbiAgICB9XG5cbiAgICBpZiAocHJvcHMuZGVmYXVsdFZhbHVlID09IG51bGwgJiYgbm9kZS5kZWZhdWx0VmFsdWUgIT09IG5ld1ZhbHVlKSB7XG4gICAgICBub2RlLmRlZmF1bHRWYWx1ZSA9IG5ld1ZhbHVlO1xuICAgIH1cbiAgfVxuXG4gIGlmIChkZWZhdWx0VmFsdWUgIT0gbnVsbCkge1xuICAgIG5vZGUuZGVmYXVsdFZhbHVlID0gdG9TdHJpbmcoZGVmYXVsdFZhbHVlKTtcbiAgfVxufVxuZnVuY3Rpb24gcG9zdE1vdW50V3JhcHBlciQzKGVsZW1lbnQsIHByb3BzKSB7XG4gIHZhciBub2RlID0gZWxlbWVudDsgLy8gVGhpcyBpcyBpbiBwb3N0TW91bnQgYmVjYXVzZSB3ZSBuZWVkIGFjY2VzcyB0byB0aGUgRE9NIG5vZGUsIHdoaWNoIGlzIG5vdFxuICAvLyBhdmFpbGFibGUgdW50aWwgYWZ0ZXIgdGhlIGNvbXBvbmVudCBoYXMgbW91bnRlZC5cblxuICB2YXIgdGV4dENvbnRlbnQgPSBub2RlLnRleHRDb250ZW50OyAvLyBPbmx5IHNldCBub2RlLnZhbHVlIGlmIHRleHRDb250ZW50IGlzIGVxdWFsIHRvIHRoZSBleHBlY3RlZFxuICAvLyBpbml0aWFsIHZhbHVlLiBJbiBJRTEwL0lFMTEgdGhlcmUgaXMgYSBidWcgd2hlcmUgdGhlIHBsYWNlaG9sZGVyIGF0dHJpYnV0ZVxuICAvLyB3aWxsIHBvcHVsYXRlIHRleHRDb250ZW50IGFzIHdlbGwuXG4gIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1pY3Jvc29mdC5jb20vbWljcm9zb2Z0LWVkZ2UvcGxhdGZvcm0vaXNzdWVzLzEwMTUyNS9cblxuICBpZiAodGV4dENvbnRlbnQgPT09IG5vZGUuX3dyYXBwZXJTdGF0ZS5pbml0aWFsVmFsdWUpIHtcbiAgICBpZiAodGV4dENvbnRlbnQgIT09ICcnICYmIHRleHRDb250ZW50ICE9PSBudWxsKSB7XG4gICAgICBub2RlLnZhbHVlID0gdGV4dENvbnRlbnQ7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiByZXN0b3JlQ29udHJvbGxlZFN0YXRlJDIoZWxlbWVudCwgcHJvcHMpIHtcbiAgLy8gRE9NIGNvbXBvbmVudCBpcyBzdGlsbCBtb3VudGVkOyB1cGRhdGVcbiAgdXBkYXRlV3JhcHBlciQxKGVsZW1lbnQsIHByb3BzKTtcbn1cblxudmFyIEhUTUxfTkFNRVNQQUNFID0gJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWwnO1xudmFyIE1BVEhfTkFNRVNQQUNFID0gJ2h0dHA6Ly93d3cudzMub3JnLzE5OTgvTWF0aC9NYXRoTUwnO1xudmFyIFNWR19OQU1FU1BBQ0UgPSAnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnO1xudmFyIE5hbWVzcGFjZXMgPSB7XG4gIGh0bWw6IEhUTUxfTkFNRVNQQUNFLFxuICBtYXRobWw6IE1BVEhfTkFNRVNQQUNFLFxuICBzdmc6IFNWR19OQU1FU1BBQ0Vcbn07IC8vIEFzc3VtZXMgdGhlcmUgaXMgbm8gcGFyZW50IG5hbWVzcGFjZS5cblxuZnVuY3Rpb24gZ2V0SW50cmluc2ljTmFtZXNwYWNlKHR5cGUpIHtcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSAnc3ZnJzpcbiAgICAgIHJldHVybiBTVkdfTkFNRVNQQUNFO1xuXG4gICAgY2FzZSAnbWF0aCc6XG4gICAgICByZXR1cm4gTUFUSF9OQU1FU1BBQ0U7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIEhUTUxfTkFNRVNQQUNFO1xuICB9XG59XG5mdW5jdGlvbiBnZXRDaGlsZE5hbWVzcGFjZShwYXJlbnROYW1lc3BhY2UsIHR5cGUpIHtcbiAgaWYgKHBhcmVudE5hbWVzcGFjZSA9PSBudWxsIHx8IHBhcmVudE5hbWVzcGFjZSA9PT0gSFRNTF9OQU1FU1BBQ0UpIHtcbiAgICAvLyBObyAob3IgZGVmYXVsdCkgcGFyZW50IG5hbWVzcGFjZTogcG90ZW50aWFsIGVudHJ5IHBvaW50LlxuICAgIHJldHVybiBnZXRJbnRyaW5zaWNOYW1lc3BhY2UodHlwZSk7XG4gIH1cblxuICBpZiAocGFyZW50TmFtZXNwYWNlID09PSBTVkdfTkFNRVNQQUNFICYmIHR5cGUgPT09ICdmb3JlaWduT2JqZWN0Jykge1xuICAgIC8vIFdlJ3JlIGxlYXZpbmcgU1ZHLlxuICAgIHJldHVybiBIVE1MX05BTUVTUEFDRTtcbiAgfSAvLyBCeSBkZWZhdWx0LCBwYXNzIG5hbWVzcGFjZSBiZWxvdy5cblxuXG4gIHJldHVybiBwYXJlbnROYW1lc3BhY2U7XG59XG5cbi8qIGdsb2JhbHMgTVNBcHAgKi9cblxuLyoqXG4gKiBDcmVhdGUgYSBmdW5jdGlvbiB3aGljaCBoYXMgJ3Vuc2FmZScgcHJpdmlsZWdlcyAocmVxdWlyZWQgYnkgd2luZG93czggYXBwcylcbiAqL1xudmFyIGNyZWF0ZU1pY3Jvc29mdFVuc2FmZUxvY2FsRnVuY3Rpb24gPSBmdW5jdGlvbiAoZnVuYykge1xuICBpZiAodHlwZW9mIE1TQXBwICE9PSAndW5kZWZpbmVkJyAmJiBNU0FwcC5leGVjVW5zYWZlTG9jYWxGdW5jdGlvbikge1xuICAgIHJldHVybiBmdW5jdGlvbiAoYXJnMCwgYXJnMSwgYXJnMiwgYXJnMykge1xuICAgICAgTVNBcHAuZXhlY1Vuc2FmZUxvY2FsRnVuY3Rpb24oZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZnVuYyhhcmcwLCBhcmcxLCBhcmcyLCBhcmczKTtcbiAgICAgIH0pO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZ1bmM7XG4gIH1cbn07XG5cbnZhciByZXVzYWJsZVNWR0NvbnRhaW5lcjtcbi8qKlxuICogU2V0IHRoZSBpbm5lckhUTUwgcHJvcGVydHkgb2YgYSBub2RlXG4gKlxuICogQHBhcmFtIHtET01FbGVtZW50fSBub2RlXG4gKiBAcGFyYW0ge3N0cmluZ30gaHRtbFxuICogQGludGVybmFsXG4gKi9cblxudmFyIHNldElubmVySFRNTCA9IGNyZWF0ZU1pY3Jvc29mdFVuc2FmZUxvY2FsRnVuY3Rpb24oZnVuY3Rpb24gKG5vZGUsIGh0bWwpIHtcbiAgaWYgKG5vZGUubmFtZXNwYWNlVVJJID09PSBOYW1lc3BhY2VzLnN2Zykge1xuXG4gICAgaWYgKCEoJ2lubmVySFRNTCcgaW4gbm9kZSkpIHtcbiAgICAgIC8vIElFIGRvZXMgbm90IGhhdmUgaW5uZXJIVE1MIGZvciBTVkcgbm9kZXMsIHNvIGluc3RlYWQgd2UgaW5qZWN0IHRoZVxuICAgICAgLy8gbmV3IG1hcmt1cCBpbiBhIHRlbXAgbm9kZSBhbmQgdGhlbiBtb3ZlIHRoZSBjaGlsZCBub2RlcyBhY3Jvc3MgaW50b1xuICAgICAgLy8gdGhlIHRhcmdldCBub2RlXG4gICAgICByZXVzYWJsZVNWR0NvbnRhaW5lciA9IHJldXNhYmxlU1ZHQ29udGFpbmVyIHx8IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgcmV1c2FibGVTVkdDb250YWluZXIuaW5uZXJIVE1MID0gJzxzdmc+JyArIGh0bWwudmFsdWVPZigpLnRvU3RyaW5nKCkgKyAnPC9zdmc+JztcbiAgICAgIHZhciBzdmdOb2RlID0gcmV1c2FibGVTVkdDb250YWluZXIuZmlyc3RDaGlsZDtcblxuICAgICAgd2hpbGUgKG5vZGUuZmlyc3RDaGlsZCkge1xuICAgICAgICBub2RlLnJlbW92ZUNoaWxkKG5vZGUuZmlyc3RDaGlsZCk7XG4gICAgICB9XG5cbiAgICAgIHdoaWxlIChzdmdOb2RlLmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgbm9kZS5hcHBlbmRDaGlsZChzdmdOb2RlLmZpcnN0Q2hpbGQpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG5cbiAgbm9kZS5pbm5lckhUTUwgPSBodG1sO1xufSk7XG5cbi8qKlxuICogSFRNTCBub2RlVHlwZSB2YWx1ZXMgdGhhdCByZXByZXNlbnQgdGhlIHR5cGUgb2YgdGhlIG5vZGVcbiAqL1xudmFyIEVMRU1FTlRfTk9ERSA9IDE7XG52YXIgVEVYVF9OT0RFID0gMztcbnZhciBDT01NRU5UX05PREUgPSA4O1xudmFyIERPQ1VNRU5UX05PREUgPSA5O1xudmFyIERPQ1VNRU5UX0ZSQUdNRU5UX05PREUgPSAxMTtcblxuLyoqXG4gKiBTZXQgdGhlIHRleHRDb250ZW50IHByb3BlcnR5IG9mIGEgbm9kZS4gRm9yIHRleHQgdXBkYXRlcywgaXQncyBmYXN0ZXJcbiAqIHRvIHNldCB0aGUgYG5vZGVWYWx1ZWAgb2YgdGhlIFRleHQgbm9kZSBkaXJlY3RseSBpbnN0ZWFkIG9mIHVzaW5nXG4gKiBgLnRleHRDb250ZW50YCB3aGljaCB3aWxsIHJlbW92ZSB0aGUgZXhpc3Rpbmcgbm9kZSBhbmQgY3JlYXRlIGEgbmV3IG9uZS5cbiAqXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR9IG5vZGVcbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0XG4gKiBAaW50ZXJuYWxcbiAqL1xuXG52YXIgc2V0VGV4dENvbnRlbnQgPSBmdW5jdGlvbiAobm9kZSwgdGV4dCkge1xuICBpZiAodGV4dCkge1xuICAgIHZhciBmaXJzdENoaWxkID0gbm9kZS5maXJzdENoaWxkO1xuXG4gICAgaWYgKGZpcnN0Q2hpbGQgJiYgZmlyc3RDaGlsZCA9PT0gbm9kZS5sYXN0Q2hpbGQgJiYgZmlyc3RDaGlsZC5ub2RlVHlwZSA9PT0gVEVYVF9OT0RFKSB7XG4gICAgICBmaXJzdENoaWxkLm5vZGVWYWx1ZSA9IHRleHQ7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG5cbiAgbm9kZS50ZXh0Q29udGVudCA9IHRleHQ7XG59O1xuXG4vLyBMaXN0IGRlcml2ZWQgZnJvbSBHZWNrbyBzb3VyY2UgY29kZTpcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9tb3ppbGxhL2dlY2tvLWRldi9ibG9iLzRlNjM4ZWZjNzEvbGF5b3V0L3N0eWxlL3Rlc3QvcHJvcGVydHlfZGF0YWJhc2UuanNcbnZhciBzaG9ydGhhbmRUb0xvbmdoYW5kID0ge1xuICBhbmltYXRpb246IFsnYW5pbWF0aW9uRGVsYXknLCAnYW5pbWF0aW9uRGlyZWN0aW9uJywgJ2FuaW1hdGlvbkR1cmF0aW9uJywgJ2FuaW1hdGlvbkZpbGxNb2RlJywgJ2FuaW1hdGlvbkl0ZXJhdGlvbkNvdW50JywgJ2FuaW1hdGlvbk5hbWUnLCAnYW5pbWF0aW9uUGxheVN0YXRlJywgJ2FuaW1hdGlvblRpbWluZ0Z1bmN0aW9uJ10sXG4gIGJhY2tncm91bmQ6IFsnYmFja2dyb3VuZEF0dGFjaG1lbnQnLCAnYmFja2dyb3VuZENsaXAnLCAnYmFja2dyb3VuZENvbG9yJywgJ2JhY2tncm91bmRJbWFnZScsICdiYWNrZ3JvdW5kT3JpZ2luJywgJ2JhY2tncm91bmRQb3NpdGlvblgnLCAnYmFja2dyb3VuZFBvc2l0aW9uWScsICdiYWNrZ3JvdW5kUmVwZWF0JywgJ2JhY2tncm91bmRTaXplJ10sXG4gIGJhY2tncm91bmRQb3NpdGlvbjogWydiYWNrZ3JvdW5kUG9zaXRpb25YJywgJ2JhY2tncm91bmRQb3NpdGlvblknXSxcbiAgYm9yZGVyOiBbJ2JvcmRlckJvdHRvbUNvbG9yJywgJ2JvcmRlckJvdHRvbVN0eWxlJywgJ2JvcmRlckJvdHRvbVdpZHRoJywgJ2JvcmRlckltYWdlT3V0c2V0JywgJ2JvcmRlckltYWdlUmVwZWF0JywgJ2JvcmRlckltYWdlU2xpY2UnLCAnYm9yZGVySW1hZ2VTb3VyY2UnLCAnYm9yZGVySW1hZ2VXaWR0aCcsICdib3JkZXJMZWZ0Q29sb3InLCAnYm9yZGVyTGVmdFN0eWxlJywgJ2JvcmRlckxlZnRXaWR0aCcsICdib3JkZXJSaWdodENvbG9yJywgJ2JvcmRlclJpZ2h0U3R5bGUnLCAnYm9yZGVyUmlnaHRXaWR0aCcsICdib3JkZXJUb3BDb2xvcicsICdib3JkZXJUb3BTdHlsZScsICdib3JkZXJUb3BXaWR0aCddLFxuICBib3JkZXJCbG9ja0VuZDogWydib3JkZXJCbG9ja0VuZENvbG9yJywgJ2JvcmRlckJsb2NrRW5kU3R5bGUnLCAnYm9yZGVyQmxvY2tFbmRXaWR0aCddLFxuICBib3JkZXJCbG9ja1N0YXJ0OiBbJ2JvcmRlckJsb2NrU3RhcnRDb2xvcicsICdib3JkZXJCbG9ja1N0YXJ0U3R5bGUnLCAnYm9yZGVyQmxvY2tTdGFydFdpZHRoJ10sXG4gIGJvcmRlckJvdHRvbTogWydib3JkZXJCb3R0b21Db2xvcicsICdib3JkZXJCb3R0b21TdHlsZScsICdib3JkZXJCb3R0b21XaWR0aCddLFxuICBib3JkZXJDb2xvcjogWydib3JkZXJCb3R0b21Db2xvcicsICdib3JkZXJMZWZ0Q29sb3InLCAnYm9yZGVyUmlnaHRDb2xvcicsICdib3JkZXJUb3BDb2xvciddLFxuICBib3JkZXJJbWFnZTogWydib3JkZXJJbWFnZU91dHNldCcsICdib3JkZXJJbWFnZVJlcGVhdCcsICdib3JkZXJJbWFnZVNsaWNlJywgJ2JvcmRlckltYWdlU291cmNlJywgJ2JvcmRlckltYWdlV2lkdGgnXSxcbiAgYm9yZGVySW5saW5lRW5kOiBbJ2JvcmRlcklubGluZUVuZENvbG9yJywgJ2JvcmRlcklubGluZUVuZFN0eWxlJywgJ2JvcmRlcklubGluZUVuZFdpZHRoJ10sXG4gIGJvcmRlcklubGluZVN0YXJ0OiBbJ2JvcmRlcklubGluZVN0YXJ0Q29sb3InLCAnYm9yZGVySW5saW5lU3RhcnRTdHlsZScsICdib3JkZXJJbmxpbmVTdGFydFdpZHRoJ10sXG4gIGJvcmRlckxlZnQ6IFsnYm9yZGVyTGVmdENvbG9yJywgJ2JvcmRlckxlZnRTdHlsZScsICdib3JkZXJMZWZ0V2lkdGgnXSxcbiAgYm9yZGVyUmFkaXVzOiBbJ2JvcmRlckJvdHRvbUxlZnRSYWRpdXMnLCAnYm9yZGVyQm90dG9tUmlnaHRSYWRpdXMnLCAnYm9yZGVyVG9wTGVmdFJhZGl1cycsICdib3JkZXJUb3BSaWdodFJhZGl1cyddLFxuICBib3JkZXJSaWdodDogWydib3JkZXJSaWdodENvbG9yJywgJ2JvcmRlclJpZ2h0U3R5bGUnLCAnYm9yZGVyUmlnaHRXaWR0aCddLFxuICBib3JkZXJTdHlsZTogWydib3JkZXJCb3R0b21TdHlsZScsICdib3JkZXJMZWZ0U3R5bGUnLCAnYm9yZGVyUmlnaHRTdHlsZScsICdib3JkZXJUb3BTdHlsZSddLFxuICBib3JkZXJUb3A6IFsnYm9yZGVyVG9wQ29sb3InLCAnYm9yZGVyVG9wU3R5bGUnLCAnYm9yZGVyVG9wV2lkdGgnXSxcbiAgYm9yZGVyV2lkdGg6IFsnYm9yZGVyQm90dG9tV2lkdGgnLCAnYm9yZGVyTGVmdFdpZHRoJywgJ2JvcmRlclJpZ2h0V2lkdGgnLCAnYm9yZGVyVG9wV2lkdGgnXSxcbiAgY29sdW1uUnVsZTogWydjb2x1bW5SdWxlQ29sb3InLCAnY29sdW1uUnVsZVN0eWxlJywgJ2NvbHVtblJ1bGVXaWR0aCddLFxuICBjb2x1bW5zOiBbJ2NvbHVtbkNvdW50JywgJ2NvbHVtbldpZHRoJ10sXG4gIGZsZXg6IFsnZmxleEJhc2lzJywgJ2ZsZXhHcm93JywgJ2ZsZXhTaHJpbmsnXSxcbiAgZmxleEZsb3c6IFsnZmxleERpcmVjdGlvbicsICdmbGV4V3JhcCddLFxuICBmb250OiBbJ2ZvbnRGYW1pbHknLCAnZm9udEZlYXR1cmVTZXR0aW5ncycsICdmb250S2VybmluZycsICdmb250TGFuZ3VhZ2VPdmVycmlkZScsICdmb250U2l6ZScsICdmb250U2l6ZUFkanVzdCcsICdmb250U3RyZXRjaCcsICdmb250U3R5bGUnLCAnZm9udFZhcmlhbnQnLCAnZm9udFZhcmlhbnRBbHRlcm5hdGVzJywgJ2ZvbnRWYXJpYW50Q2FwcycsICdmb250VmFyaWFudEVhc3RBc2lhbicsICdmb250VmFyaWFudExpZ2F0dXJlcycsICdmb250VmFyaWFudE51bWVyaWMnLCAnZm9udFZhcmlhbnRQb3NpdGlvbicsICdmb250V2VpZ2h0JywgJ2xpbmVIZWlnaHQnXSxcbiAgZm9udFZhcmlhbnQ6IFsnZm9udFZhcmlhbnRBbHRlcm5hdGVzJywgJ2ZvbnRWYXJpYW50Q2FwcycsICdmb250VmFyaWFudEVhc3RBc2lhbicsICdmb250VmFyaWFudExpZ2F0dXJlcycsICdmb250VmFyaWFudE51bWVyaWMnLCAnZm9udFZhcmlhbnRQb3NpdGlvbiddLFxuICBnYXA6IFsnY29sdW1uR2FwJywgJ3Jvd0dhcCddLFxuICBncmlkOiBbJ2dyaWRBdXRvQ29sdW1ucycsICdncmlkQXV0b0Zsb3cnLCAnZ3JpZEF1dG9Sb3dzJywgJ2dyaWRUZW1wbGF0ZUFyZWFzJywgJ2dyaWRUZW1wbGF0ZUNvbHVtbnMnLCAnZ3JpZFRlbXBsYXRlUm93cyddLFxuICBncmlkQXJlYTogWydncmlkQ29sdW1uRW5kJywgJ2dyaWRDb2x1bW5TdGFydCcsICdncmlkUm93RW5kJywgJ2dyaWRSb3dTdGFydCddLFxuICBncmlkQ29sdW1uOiBbJ2dyaWRDb2x1bW5FbmQnLCAnZ3JpZENvbHVtblN0YXJ0J10sXG4gIGdyaWRDb2x1bW5HYXA6IFsnY29sdW1uR2FwJ10sXG4gIGdyaWRHYXA6IFsnY29sdW1uR2FwJywgJ3Jvd0dhcCddLFxuICBncmlkUm93OiBbJ2dyaWRSb3dFbmQnLCAnZ3JpZFJvd1N0YXJ0J10sXG4gIGdyaWRSb3dHYXA6IFsncm93R2FwJ10sXG4gIGdyaWRUZW1wbGF0ZTogWydncmlkVGVtcGxhdGVBcmVhcycsICdncmlkVGVtcGxhdGVDb2x1bW5zJywgJ2dyaWRUZW1wbGF0ZVJvd3MnXSxcbiAgbGlzdFN0eWxlOiBbJ2xpc3RTdHlsZUltYWdlJywgJ2xpc3RTdHlsZVBvc2l0aW9uJywgJ2xpc3RTdHlsZVR5cGUnXSxcbiAgbWFyZ2luOiBbJ21hcmdpbkJvdHRvbScsICdtYXJnaW5MZWZ0JywgJ21hcmdpblJpZ2h0JywgJ21hcmdpblRvcCddLFxuICBtYXJrZXI6IFsnbWFya2VyRW5kJywgJ21hcmtlck1pZCcsICdtYXJrZXJTdGFydCddLFxuICBtYXNrOiBbJ21hc2tDbGlwJywgJ21hc2tDb21wb3NpdGUnLCAnbWFza0ltYWdlJywgJ21hc2tNb2RlJywgJ21hc2tPcmlnaW4nLCAnbWFza1Bvc2l0aW9uWCcsICdtYXNrUG9zaXRpb25ZJywgJ21hc2tSZXBlYXQnLCAnbWFza1NpemUnXSxcbiAgbWFza1Bvc2l0aW9uOiBbJ21hc2tQb3NpdGlvblgnLCAnbWFza1Bvc2l0aW9uWSddLFxuICBvdXRsaW5lOiBbJ291dGxpbmVDb2xvcicsICdvdXRsaW5lU3R5bGUnLCAnb3V0bGluZVdpZHRoJ10sXG4gIG92ZXJmbG93OiBbJ292ZXJmbG93WCcsICdvdmVyZmxvd1knXSxcbiAgcGFkZGluZzogWydwYWRkaW5nQm90dG9tJywgJ3BhZGRpbmdMZWZ0JywgJ3BhZGRpbmdSaWdodCcsICdwYWRkaW5nVG9wJ10sXG4gIHBsYWNlQ29udGVudDogWydhbGlnbkNvbnRlbnQnLCAnanVzdGlmeUNvbnRlbnQnXSxcbiAgcGxhY2VJdGVtczogWydhbGlnbkl0ZW1zJywgJ2p1c3RpZnlJdGVtcyddLFxuICBwbGFjZVNlbGY6IFsnYWxpZ25TZWxmJywgJ2p1c3RpZnlTZWxmJ10sXG4gIHRleHREZWNvcmF0aW9uOiBbJ3RleHREZWNvcmF0aW9uQ29sb3InLCAndGV4dERlY29yYXRpb25MaW5lJywgJ3RleHREZWNvcmF0aW9uU3R5bGUnXSxcbiAgdGV4dEVtcGhhc2lzOiBbJ3RleHRFbXBoYXNpc0NvbG9yJywgJ3RleHRFbXBoYXNpc1N0eWxlJ10sXG4gIHRyYW5zaXRpb246IFsndHJhbnNpdGlvbkRlbGF5JywgJ3RyYW5zaXRpb25EdXJhdGlvbicsICd0cmFuc2l0aW9uUHJvcGVydHknLCAndHJhbnNpdGlvblRpbWluZ0Z1bmN0aW9uJ10sXG4gIHdvcmRXcmFwOiBbJ292ZXJmbG93V3JhcCddXG59O1xuXG4vKipcbiAqIENTUyBwcm9wZXJ0aWVzIHdoaWNoIGFjY2VwdCBudW1iZXJzIGJ1dCBhcmUgbm90IGluIHVuaXRzIG9mIFwicHhcIi5cbiAqL1xudmFyIGlzVW5pdGxlc3NOdW1iZXIgPSB7XG4gIGFuaW1hdGlvbkl0ZXJhdGlvbkNvdW50OiB0cnVlLFxuICBib3JkZXJJbWFnZU91dHNldDogdHJ1ZSxcbiAgYm9yZGVySW1hZ2VTbGljZTogdHJ1ZSxcbiAgYm9yZGVySW1hZ2VXaWR0aDogdHJ1ZSxcbiAgYm94RmxleDogdHJ1ZSxcbiAgYm94RmxleEdyb3VwOiB0cnVlLFxuICBib3hPcmRpbmFsR3JvdXA6IHRydWUsXG4gIGNvbHVtbkNvdW50OiB0cnVlLFxuICBjb2x1bW5zOiB0cnVlLFxuICBmbGV4OiB0cnVlLFxuICBmbGV4R3JvdzogdHJ1ZSxcbiAgZmxleFBvc2l0aXZlOiB0cnVlLFxuICBmbGV4U2hyaW5rOiB0cnVlLFxuICBmbGV4TmVnYXRpdmU6IHRydWUsXG4gIGZsZXhPcmRlcjogdHJ1ZSxcbiAgZ3JpZEFyZWE6IHRydWUsXG4gIGdyaWRSb3c6IHRydWUsXG4gIGdyaWRSb3dFbmQ6IHRydWUsXG4gIGdyaWRSb3dTcGFuOiB0cnVlLFxuICBncmlkUm93U3RhcnQ6IHRydWUsXG4gIGdyaWRDb2x1bW46IHRydWUsXG4gIGdyaWRDb2x1bW5FbmQ6IHRydWUsXG4gIGdyaWRDb2x1bW5TcGFuOiB0cnVlLFxuICBncmlkQ29sdW1uU3RhcnQ6IHRydWUsXG4gIGZvbnRXZWlnaHQ6IHRydWUsXG4gIGxpbmVDbGFtcDogdHJ1ZSxcbiAgbGluZUhlaWdodDogdHJ1ZSxcbiAgb3BhY2l0eTogdHJ1ZSxcbiAgb3JkZXI6IHRydWUsXG4gIG9ycGhhbnM6IHRydWUsXG4gIHRhYlNpemU6IHRydWUsXG4gIHdpZG93czogdHJ1ZSxcbiAgekluZGV4OiB0cnVlLFxuICB6b29tOiB0cnVlLFxuICAvLyBTVkctcmVsYXRlZCBwcm9wZXJ0aWVzXG4gIGZpbGxPcGFjaXR5OiB0cnVlLFxuICBmbG9vZE9wYWNpdHk6IHRydWUsXG4gIHN0b3BPcGFjaXR5OiB0cnVlLFxuICBzdHJva2VEYXNoYXJyYXk6IHRydWUsXG4gIHN0cm9rZURhc2hvZmZzZXQ6IHRydWUsXG4gIHN0cm9rZU1pdGVybGltaXQ6IHRydWUsXG4gIHN0cm9rZU9wYWNpdHk6IHRydWUsXG4gIHN0cm9rZVdpZHRoOiB0cnVlXG59O1xuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gcHJlZml4IHZlbmRvci1zcGVjaWZpYyBwcmVmaXgsIGVnOiBXZWJraXRcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgc3R5bGUgbmFtZSwgZWc6IHRyYW5zaXRpb25EdXJhdGlvblxuICogQHJldHVybiB7c3RyaW5nfSBzdHlsZSBuYW1lIHByZWZpeGVkIHdpdGggYHByZWZpeGAsIHByb3Blcmx5IGNhbWVsQ2FzZWQsIGVnOlxuICogV2Via2l0VHJhbnNpdGlvbkR1cmF0aW9uXG4gKi9cblxuZnVuY3Rpb24gcHJlZml4S2V5KHByZWZpeCwga2V5KSB7XG4gIHJldHVybiBwcmVmaXggKyBrZXkuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBrZXkuc3Vic3RyaW5nKDEpO1xufVxuLyoqXG4gKiBTdXBwb3J0IHN0eWxlIG5hbWVzIHRoYXQgbWF5IGNvbWUgcGFzc2VkIGluIHByZWZpeGVkIGJ5IGFkZGluZyBwZXJtdXRhdGlvbnNcbiAqIG9mIHZlbmRvciBwcmVmaXhlcy5cbiAqL1xuXG5cbnZhciBwcmVmaXhlcyA9IFsnV2Via2l0JywgJ21zJywgJ01veicsICdPJ107IC8vIFVzaW5nIE9iamVjdC5rZXlzIGhlcmUsIG9yIGVsc2UgdGhlIHZhbmlsbGEgZm9yLWluIGxvb3AgbWFrZXMgSUU4IGdvIGludG8gYW5cbi8vIGluZmluaXRlIGxvb3AsIGJlY2F1c2UgaXQgaXRlcmF0ZXMgb3ZlciB0aGUgbmV3bHkgYWRkZWQgcHJvcHMgdG9vLlxuXG5PYmplY3Qua2V5cyhpc1VuaXRsZXNzTnVtYmVyKS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XG4gIHByZWZpeGVzLmZvckVhY2goZnVuY3Rpb24gKHByZWZpeCkge1xuICAgIGlzVW5pdGxlc3NOdW1iZXJbcHJlZml4S2V5KHByZWZpeCwgcHJvcCldID0gaXNVbml0bGVzc051bWJlcltwcm9wXTtcbiAgfSk7XG59KTtcblxuLyoqXG4gKiBDb252ZXJ0IGEgdmFsdWUgaW50byB0aGUgcHJvcGVyIGNzcyB3cml0YWJsZSB2YWx1ZS4gVGhlIHN0eWxlIG5hbWUgYG5hbWVgXG4gKiBzaG91bGQgYmUgbG9naWNhbCAobm8gaHlwaGVucyksIGFzIHNwZWNpZmllZFxuICogaW4gYENTU1Byb3BlcnR5LmlzVW5pdGxlc3NOdW1iZXJgLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIENTUyBwcm9wZXJ0eSBuYW1lIHN1Y2ggYXMgYHRvcE1hcmdpbmAuXG4gKiBAcGFyYW0geyp9IHZhbHVlIENTUyBwcm9wZXJ0eSB2YWx1ZSBzdWNoIGFzIGAxMHB4YC5cbiAqIEByZXR1cm4ge3N0cmluZ30gTm9ybWFsaXplZCBzdHlsZSB2YWx1ZSB3aXRoIGRpbWVuc2lvbnMgYXBwbGllZC5cbiAqL1xuXG5mdW5jdGlvbiBkYW5nZXJvdXNTdHlsZVZhbHVlKG5hbWUsIHZhbHVlLCBpc0N1c3RvbVByb3BlcnR5KSB7XG4gIC8vIE5vdGUgdGhhdCB3ZSd2ZSByZW1vdmVkIGVzY2FwZVRleHRGb3JCcm93c2VyKCkgY2FsbHMgaGVyZSBzaW5jZSB0aGVcbiAgLy8gd2hvbGUgc3RyaW5nIHdpbGwgYmUgZXNjYXBlZCB3aGVuIHRoZSBhdHRyaWJ1dGUgaXMgaW5qZWN0ZWQgaW50b1xuICAvLyB0aGUgbWFya3VwLiBJZiB5b3UgcHJvdmlkZSB1bnNhZmUgdXNlciBkYXRhIGhlcmUgdGhleSBjYW4gaW5qZWN0XG4gIC8vIGFyYml0cmFyeSBDU1Mgd2hpY2ggbWF5IGJlIHByb2JsZW1hdGljIChJIGNvdWxkbid0IHJlcHJvIHRoaXMpOlxuICAvLyBodHRwczovL3d3dy5vd2FzcC5vcmcvaW5kZXgucGhwL1hTU19GaWx0ZXJfRXZhc2lvbl9DaGVhdF9TaGVldFxuICAvLyBodHRwOi8vd3d3LnRoZXNwYW5uZXIuY28udWsvMjAwNy8xMS8yNi91bHRpbWF0ZS14c3MtY3NzLWluamVjdGlvbi9cbiAgLy8gVGhpcyBpcyBub3QgYW4gWFNTIGhvbGUgYnV0IGluc3RlYWQgYSBwb3RlbnRpYWwgQ1NTIGluamVjdGlvbiBpc3N1ZVxuICAvLyB3aGljaCBoYXMgbGVhZCB0byBhIGdyZWF0ZXIgZGlzY3Vzc2lvbiBhYm91dCBob3cgd2UncmUgZ29pbmcgdG9cbiAgLy8gdHJ1c3QgVVJMcyBtb3ZpbmcgZm9yd2FyZC4gU2VlICMyMTE1OTAxXG4gIHZhciBpc0VtcHR5ID0gdmFsdWUgPT0gbnVsbCB8fCB0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJyB8fCB2YWx1ZSA9PT0gJyc7XG5cbiAgaWYgKGlzRW1wdHkpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICBpZiAoIWlzQ3VzdG9tUHJvcGVydHkgJiYgdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyAmJiB2YWx1ZSAhPT0gMCAmJiAhKGlzVW5pdGxlc3NOdW1iZXIuaGFzT3duUHJvcGVydHkobmFtZSkgJiYgaXNVbml0bGVzc051bWJlcltuYW1lXSkpIHtcbiAgICByZXR1cm4gdmFsdWUgKyAncHgnOyAvLyBQcmVzdW1lcyBpbXBsaWNpdCAncHgnIHN1ZmZpeCBmb3IgdW5pdGxlc3MgbnVtYmVyc1xuICB9XG5cbiAgcmV0dXJuICgnJyArIHZhbHVlKS50cmltKCk7XG59XG5cbnZhciB1cHBlcmNhc2VQYXR0ZXJuID0gLyhbQS1aXSkvZztcbnZhciBtc1BhdHRlcm4gPSAvXm1zLS87XG4vKipcbiAqIEh5cGhlbmF0ZXMgYSBjYW1lbGNhc2VkIENTUyBwcm9wZXJ0eSBuYW1lLCBmb3IgZXhhbXBsZTpcbiAqXG4gKiAgID4gaHlwaGVuYXRlU3R5bGVOYW1lKCdiYWNrZ3JvdW5kQ29sb3InKVxuICogICA8IFwiYmFja2dyb3VuZC1jb2xvclwiXG4gKiAgID4gaHlwaGVuYXRlU3R5bGVOYW1lKCdNb3pUcmFuc2l0aW9uJylcbiAqICAgPCBcIi1tb3otdHJhbnNpdGlvblwiXG4gKiAgID4gaHlwaGVuYXRlU3R5bGVOYW1lKCdtc1RyYW5zaXRpb24nKVxuICogICA8IFwiLW1zLXRyYW5zaXRpb25cIlxuICpcbiAqIEFzIE1vZGVybml6ciBzdWdnZXN0cyAoaHR0cDovL21vZGVybml6ci5jb20vZG9jcy8jcHJlZml4ZWQpLCBhbiBgbXNgIHByZWZpeFxuICogaXMgY29udmVydGVkIHRvIGAtbXMtYC5cbiAqL1xuXG5mdW5jdGlvbiBoeXBoZW5hdGVTdHlsZU5hbWUobmFtZSkge1xuICByZXR1cm4gbmFtZS5yZXBsYWNlKHVwcGVyY2FzZVBhdHRlcm4sICctJDEnKS50b0xvd2VyQ2FzZSgpLnJlcGxhY2UobXNQYXR0ZXJuLCAnLW1zLScpO1xufVxuXG52YXIgd2FyblZhbGlkU3R5bGUgPSBmdW5jdGlvbiAoKSB7fTtcblxue1xuICAvLyAnbXNUcmFuc2Zvcm0nIGlzIGNvcnJlY3QsIGJ1dCB0aGUgb3RoZXIgcHJlZml4ZXMgc2hvdWxkIGJlIGNhcGl0YWxpemVkXG4gIHZhciBiYWRWZW5kb3JlZFN0eWxlTmFtZVBhdHRlcm4gPSAvXig/OndlYmtpdHxtb3p8bylbQS1aXS87XG4gIHZhciBtc1BhdHRlcm4kMSA9IC9eLW1zLS87XG4gIHZhciBoeXBoZW5QYXR0ZXJuID0gLy0oLikvZzsgLy8gc3R5bGUgdmFsdWVzIHNob3VsZG4ndCBjb250YWluIGEgc2VtaWNvbG9uXG5cbiAgdmFyIGJhZFN0eWxlVmFsdWVXaXRoU2VtaWNvbG9uUGF0dGVybiA9IC87XFxzKiQvO1xuICB2YXIgd2FybmVkU3R5bGVOYW1lcyA9IHt9O1xuICB2YXIgd2FybmVkU3R5bGVWYWx1ZXMgPSB7fTtcbiAgdmFyIHdhcm5lZEZvck5hTlZhbHVlID0gZmFsc2U7XG4gIHZhciB3YXJuZWRGb3JJbmZpbml0eVZhbHVlID0gZmFsc2U7XG5cbiAgdmFyIGNhbWVsaXplID0gZnVuY3Rpb24gKHN0cmluZykge1xuICAgIHJldHVybiBzdHJpbmcucmVwbGFjZShoeXBoZW5QYXR0ZXJuLCBmdW5jdGlvbiAoXywgY2hhcmFjdGVyKSB7XG4gICAgICByZXR1cm4gY2hhcmFjdGVyLnRvVXBwZXJDYXNlKCk7XG4gICAgfSk7XG4gIH07XG5cbiAgdmFyIHdhcm5IeXBoZW5hdGVkU3R5bGVOYW1lID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICBpZiAod2FybmVkU3R5bGVOYW1lcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSAmJiB3YXJuZWRTdHlsZU5hbWVzW25hbWVdKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgd2FybmVkU3R5bGVOYW1lc1tuYW1lXSA9IHRydWU7XG5cbiAgICBlcnJvcignVW5zdXBwb3J0ZWQgc3R5bGUgcHJvcGVydHkgJXMuIERpZCB5b3UgbWVhbiAlcz8nLCBuYW1lLCAvLyBBcyBBbmRpIFNtaXRoIHN1Z2dlc3RzXG4gICAgLy8gKGh0dHA6Ly93d3cuYW5kaXNtaXRoLmNvbS9ibG9nLzIwMTIvMDIvbW9kZXJuaXpyLXByZWZpeGVkLyksIGFuIGAtbXNgIHByZWZpeFxuICAgIC8vIGlzIGNvbnZlcnRlZCB0byBsb3dlcmNhc2UgYG1zYC5cbiAgICBjYW1lbGl6ZShuYW1lLnJlcGxhY2UobXNQYXR0ZXJuJDEsICdtcy0nKSkpO1xuICB9O1xuXG4gIHZhciB3YXJuQmFkVmVuZG9yZWRTdHlsZU5hbWUgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIGlmICh3YXJuZWRTdHlsZU5hbWVzLmhhc093blByb3BlcnR5KG5hbWUpICYmIHdhcm5lZFN0eWxlTmFtZXNbbmFtZV0pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB3YXJuZWRTdHlsZU5hbWVzW25hbWVdID0gdHJ1ZTtcblxuICAgIGVycm9yKCdVbnN1cHBvcnRlZCB2ZW5kb3ItcHJlZml4ZWQgc3R5bGUgcHJvcGVydHkgJXMuIERpZCB5b3UgbWVhbiAlcz8nLCBuYW1lLCBuYW1lLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgbmFtZS5zbGljZSgxKSk7XG4gIH07XG5cbiAgdmFyIHdhcm5TdHlsZVZhbHVlV2l0aFNlbWljb2xvbiA9IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkge1xuICAgIGlmICh3YXJuZWRTdHlsZVZhbHVlcy5oYXNPd25Qcm9wZXJ0eSh2YWx1ZSkgJiYgd2FybmVkU3R5bGVWYWx1ZXNbdmFsdWVdKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgd2FybmVkU3R5bGVWYWx1ZXNbdmFsdWVdID0gdHJ1ZTtcblxuICAgIGVycm9yKFwiU3R5bGUgcHJvcGVydHkgdmFsdWVzIHNob3VsZG4ndCBjb250YWluIGEgc2VtaWNvbG9uLiBcIiArICdUcnkgXCIlczogJXNcIiBpbnN0ZWFkLicsIG5hbWUsIHZhbHVlLnJlcGxhY2UoYmFkU3R5bGVWYWx1ZVdpdGhTZW1pY29sb25QYXR0ZXJuLCAnJykpO1xuICB9O1xuXG4gIHZhciB3YXJuU3R5bGVWYWx1ZUlzTmFOID0gZnVuY3Rpb24gKG5hbWUsIHZhbHVlKSB7XG4gICAgaWYgKHdhcm5lZEZvck5hTlZhbHVlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgd2FybmVkRm9yTmFOVmFsdWUgPSB0cnVlO1xuXG4gICAgZXJyb3IoJ2BOYU5gIGlzIGFuIGludmFsaWQgdmFsdWUgZm9yIHRoZSBgJXNgIGNzcyBzdHlsZSBwcm9wZXJ0eS4nLCBuYW1lKTtcbiAgfTtcblxuICB2YXIgd2FyblN0eWxlVmFsdWVJc0luZmluaXR5ID0gZnVuY3Rpb24gKG5hbWUsIHZhbHVlKSB7XG4gICAgaWYgKHdhcm5lZEZvckluZmluaXR5VmFsdWUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB3YXJuZWRGb3JJbmZpbml0eVZhbHVlID0gdHJ1ZTtcblxuICAgIGVycm9yKCdgSW5maW5pdHlgIGlzIGFuIGludmFsaWQgdmFsdWUgZm9yIHRoZSBgJXNgIGNzcyBzdHlsZSBwcm9wZXJ0eS4nLCBuYW1lKTtcbiAgfTtcblxuICB3YXJuVmFsaWRTdHlsZSA9IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkge1xuICAgIGlmIChuYW1lLmluZGV4T2YoJy0nKSA+IC0xKSB7XG4gICAgICB3YXJuSHlwaGVuYXRlZFN0eWxlTmFtZShuYW1lKTtcbiAgICB9IGVsc2UgaWYgKGJhZFZlbmRvcmVkU3R5bGVOYW1lUGF0dGVybi50ZXN0KG5hbWUpKSB7XG4gICAgICB3YXJuQmFkVmVuZG9yZWRTdHlsZU5hbWUobmFtZSk7XG4gICAgfSBlbHNlIGlmIChiYWRTdHlsZVZhbHVlV2l0aFNlbWljb2xvblBhdHRlcm4udGVzdCh2YWx1ZSkpIHtcbiAgICAgIHdhcm5TdHlsZVZhbHVlV2l0aFNlbWljb2xvbihuYW1lLCB2YWx1ZSk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgIGlmIChpc05hTih2YWx1ZSkpIHtcbiAgICAgICAgd2FyblN0eWxlVmFsdWVJc05hTihuYW1lLCB2YWx1ZSk7XG4gICAgICB9IGVsc2UgaWYgKCFpc0Zpbml0ZSh2YWx1ZSkpIHtcbiAgICAgICAgd2FyblN0eWxlVmFsdWVJc0luZmluaXR5KG5hbWUsIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG5cbnZhciB3YXJuVmFsaWRTdHlsZSQxID0gd2FyblZhbGlkU3R5bGU7XG5cbi8qKlxuICogT3BlcmF0aW9ucyBmb3IgZGVhbGluZyB3aXRoIENTUyBwcm9wZXJ0aWVzLlxuICovXG5cbi8qKlxuICogVGhpcyBjcmVhdGVzIGEgc3RyaW5nIHRoYXQgaXMgZXhwZWN0ZWQgdG8gYmUgZXF1aXZhbGVudCB0byB0aGUgc3R5bGVcbiAqIGF0dHJpYnV0ZSBnZW5lcmF0ZWQgYnkgc2VydmVyLXNpZGUgcmVuZGVyaW5nLiBJdCBieS1wYXNzZXMgd2FybmluZ3MgYW5kXG4gKiBzZWN1cml0eSBjaGVja3Mgc28gaXQncyBub3Qgc2FmZSB0byB1c2UgdGhpcyB2YWx1ZSBmb3IgYW55dGhpbmcgb3RoZXIgdGhhblxuICogY29tcGFyaXNvbi4gSXQgaXMgb25seSB1c2VkIGluIERFViBmb3IgU1NSIHZhbGlkYXRpb24uXG4gKi9cblxuZnVuY3Rpb24gY3JlYXRlRGFuZ2Vyb3VzU3RyaW5nRm9yU3R5bGVzKHN0eWxlcykge1xuICB7XG4gICAgdmFyIHNlcmlhbGl6ZWQgPSAnJztcbiAgICB2YXIgZGVsaW1pdGVyID0gJyc7XG5cbiAgICBmb3IgKHZhciBzdHlsZU5hbWUgaW4gc3R5bGVzKSB7XG4gICAgICBpZiAoIXN0eWxlcy5oYXNPd25Qcm9wZXJ0eShzdHlsZU5hbWUpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICB2YXIgc3R5bGVWYWx1ZSA9IHN0eWxlc1tzdHlsZU5hbWVdO1xuXG4gICAgICBpZiAoc3R5bGVWYWx1ZSAhPSBudWxsKSB7XG4gICAgICAgIHZhciBpc0N1c3RvbVByb3BlcnR5ID0gc3R5bGVOYW1lLmluZGV4T2YoJy0tJykgPT09IDA7XG4gICAgICAgIHNlcmlhbGl6ZWQgKz0gZGVsaW1pdGVyICsgKGlzQ3VzdG9tUHJvcGVydHkgPyBzdHlsZU5hbWUgOiBoeXBoZW5hdGVTdHlsZU5hbWUoc3R5bGVOYW1lKSkgKyAnOic7XG4gICAgICAgIHNlcmlhbGl6ZWQgKz0gZGFuZ2Vyb3VzU3R5bGVWYWx1ZShzdHlsZU5hbWUsIHN0eWxlVmFsdWUsIGlzQ3VzdG9tUHJvcGVydHkpO1xuICAgICAgICBkZWxpbWl0ZXIgPSAnOyc7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHNlcmlhbGl6ZWQgfHwgbnVsbDtcbiAgfVxufVxuLyoqXG4gKiBTZXRzIHRoZSB2YWx1ZSBmb3IgbXVsdGlwbGUgc3R5bGVzIG9uIGEgbm9kZS4gIElmIGEgdmFsdWUgaXMgc3BlY2lmaWVkIGFzXG4gKiAnJyAoZW1wdHkgc3RyaW5nKSwgdGhlIGNvcnJlc3BvbmRpbmcgc3R5bGUgcHJvcGVydHkgd2lsbCBiZSB1bnNldC5cbiAqXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR9IG5vZGVcbiAqIEBwYXJhbSB7b2JqZWN0fSBzdHlsZXNcbiAqL1xuXG5mdW5jdGlvbiBzZXRWYWx1ZUZvclN0eWxlcyhub2RlLCBzdHlsZXMpIHtcbiAgdmFyIHN0eWxlID0gbm9kZS5zdHlsZTtcblxuICBmb3IgKHZhciBzdHlsZU5hbWUgaW4gc3R5bGVzKSB7XG4gICAgaWYgKCFzdHlsZXMuaGFzT3duUHJvcGVydHkoc3R5bGVOYW1lKSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgdmFyIGlzQ3VzdG9tUHJvcGVydHkgPSBzdHlsZU5hbWUuaW5kZXhPZignLS0nKSA9PT0gMDtcblxuICAgIHtcbiAgICAgIGlmICghaXNDdXN0b21Qcm9wZXJ0eSkge1xuICAgICAgICB3YXJuVmFsaWRTdHlsZSQxKHN0eWxlTmFtZSwgc3R5bGVzW3N0eWxlTmFtZV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBzdHlsZVZhbHVlID0gZGFuZ2Vyb3VzU3R5bGVWYWx1ZShzdHlsZU5hbWUsIHN0eWxlc1tzdHlsZU5hbWVdLCBpc0N1c3RvbVByb3BlcnR5KTtcblxuICAgIGlmIChzdHlsZU5hbWUgPT09ICdmbG9hdCcpIHtcbiAgICAgIHN0eWxlTmFtZSA9ICdjc3NGbG9hdCc7XG4gICAgfVxuXG4gICAgaWYgKGlzQ3VzdG9tUHJvcGVydHkpIHtcbiAgICAgIHN0eWxlLnNldFByb3BlcnR5KHN0eWxlTmFtZSwgc3R5bGVWYWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0eWxlW3N0eWxlTmFtZV0gPSBzdHlsZVZhbHVlO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBpc1ZhbHVlRW1wdHkodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID09IG51bGwgfHwgdHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicgfHwgdmFsdWUgPT09ICcnO1xufVxuLyoqXG4gKiBHaXZlbiB7Y29sb3I6ICdyZWQnLCBvdmVyZmxvdzogJ2hpZGRlbid9IHJldHVybnMge1xuICogICBjb2xvcjogJ2NvbG9yJyxcbiAqICAgb3ZlcmZsb3dYOiAnb3ZlcmZsb3cnLFxuICogICBvdmVyZmxvd1k6ICdvdmVyZmxvdycsXG4gKiB9LiBUaGlzIGNhbiBiZSByZWFkIGFzIFwidGhlIG92ZXJmbG93WSBwcm9wZXJ0eSB3YXMgc2V0IGJ5IHRoZSBvdmVyZmxvd1xuICogc2hvcnRoYW5kXCIuIFRoYXQgaXMsIHRoZSB2YWx1ZXMgYXJlIHRoZSBwcm9wZXJ0eSB0aGF0IGVhY2ggd2FzIGRlcml2ZWQgZnJvbS5cbiAqL1xuXG5cbmZ1bmN0aW9uIGV4cGFuZFNob3J0aGFuZE1hcChzdHlsZXMpIHtcbiAgdmFyIGV4cGFuZGVkID0ge307XG5cbiAgZm9yICh2YXIga2V5IGluIHN0eWxlcykge1xuICAgIHZhciBsb25naGFuZHMgPSBzaG9ydGhhbmRUb0xvbmdoYW5kW2tleV0gfHwgW2tleV07XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxvbmdoYW5kcy5sZW5ndGg7IGkrKykge1xuICAgICAgZXhwYW5kZWRbbG9uZ2hhbmRzW2ldXSA9IGtleTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZXhwYW5kZWQ7XG59XG4vKipcbiAqIFdoZW4gbWl4aW5nIHNob3J0aGFuZCBhbmQgbG9uZ2hhbmQgcHJvcGVydHkgbmFtZXMsIHdlIHdhcm4gZHVyaW5nIHVwZGF0ZXMgaWZcbiAqIHdlIGV4cGVjdCBhbiBpbmNvcnJlY3QgcmVzdWx0IHRvIG9jY3VyLiBJbiBwYXJ0aWN1bGFyLCB3ZSB3YXJuIGZvcjpcbiAqXG4gKiBVcGRhdGluZyBhIHNob3J0aGFuZCBwcm9wZXJ0eSAobG9uZ2hhbmQgZ2V0cyBvdmVyd3JpdHRlbik6XG4gKiAgIHtmb250OiAnZm9vJywgZm9udFZhcmlhbnQ6ICdiYXInfSAtPiB7Zm9udDogJ2JheicsIGZvbnRWYXJpYW50OiAnYmFyJ31cbiAqICAgYmVjb21lcyAuc3R5bGUuZm9udCA9ICdiYXonXG4gKiBSZW1vdmluZyBhIHNob3J0aGFuZCBwcm9wZXJ0eSAobG9uZ2hhbmQgZ2V0cyBsb3N0IHRvbyk6XG4gKiAgIHtmb250OiAnZm9vJywgZm9udFZhcmlhbnQ6ICdiYXInfSAtPiB7Zm9udFZhcmlhbnQ6ICdiYXInfVxuICogICBiZWNvbWVzIC5zdHlsZS5mb250ID0gJydcbiAqIFJlbW92aW5nIGEgbG9uZ2hhbmQgcHJvcGVydHkgKHNob3VsZCByZXZlcnQgdG8gc2hvcnRoYW5kOyBkb2Vzbid0KTpcbiAqICAge2ZvbnQ6ICdmb28nLCBmb250VmFyaWFudDogJ2Jhcid9IC0+IHtmb250OiAnZm9vJ31cbiAqICAgYmVjb21lcyAuc3R5bGUuZm9udFZhcmlhbnQgPSAnJ1xuICovXG5cblxuZnVuY3Rpb24gdmFsaWRhdGVTaG9ydGhhbmRQcm9wZXJ0eUNvbGxpc2lvbkluRGV2KHN0eWxlVXBkYXRlcywgbmV4dFN0eWxlcykge1xuICB7XG4gICAgaWYgKCFuZXh0U3R5bGVzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGV4cGFuZGVkVXBkYXRlcyA9IGV4cGFuZFNob3J0aGFuZE1hcChzdHlsZVVwZGF0ZXMpO1xuICAgIHZhciBleHBhbmRlZFN0eWxlcyA9IGV4cGFuZFNob3J0aGFuZE1hcChuZXh0U3R5bGVzKTtcbiAgICB2YXIgd2FybmVkQWJvdXQgPSB7fTtcblxuICAgIGZvciAodmFyIGtleSBpbiBleHBhbmRlZFVwZGF0ZXMpIHtcbiAgICAgIHZhciBvcmlnaW5hbEtleSA9IGV4cGFuZGVkVXBkYXRlc1trZXldO1xuICAgICAgdmFyIGNvcnJlY3RPcmlnaW5hbEtleSA9IGV4cGFuZGVkU3R5bGVzW2tleV07XG5cbiAgICAgIGlmIChjb3JyZWN0T3JpZ2luYWxLZXkgJiYgb3JpZ2luYWxLZXkgIT09IGNvcnJlY3RPcmlnaW5hbEtleSkge1xuICAgICAgICB2YXIgd2FybmluZ0tleSA9IG9yaWdpbmFsS2V5ICsgJywnICsgY29ycmVjdE9yaWdpbmFsS2V5O1xuXG4gICAgICAgIGlmICh3YXJuZWRBYm91dFt3YXJuaW5nS2V5XSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgd2FybmVkQWJvdXRbd2FybmluZ0tleV0gPSB0cnVlO1xuXG4gICAgICAgIGVycm9yKCclcyBhIHN0eWxlIHByb3BlcnR5IGR1cmluZyByZXJlbmRlciAoJXMpIHdoZW4gYSAnICsgJ2NvbmZsaWN0aW5nIHByb3BlcnR5IGlzIHNldCAoJXMpIGNhbiBsZWFkIHRvIHN0eWxpbmcgYnVncy4gVG8gJyArIFwiYXZvaWQgdGhpcywgZG9uJ3QgbWl4IHNob3J0aGFuZCBhbmQgbm9uLXNob3J0aGFuZCBwcm9wZXJ0aWVzIFwiICsgJ2ZvciB0aGUgc2FtZSB2YWx1ZTsgaW5zdGVhZCwgcmVwbGFjZSB0aGUgc2hvcnRoYW5kIHdpdGggJyArICdzZXBhcmF0ZSB2YWx1ZXMuJywgaXNWYWx1ZUVtcHR5KHN0eWxlVXBkYXRlc1tvcmlnaW5hbEtleV0pID8gJ1JlbW92aW5nJyA6ICdVcGRhdGluZycsIG9yaWdpbmFsS2V5LCBjb3JyZWN0T3JpZ2luYWxLZXkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vLyBGb3IgSFRNTCwgY2VydGFpbiB0YWdzIHNob3VsZCBvbWl0IHRoZWlyIGNsb3NlIHRhZy4gV2Uga2VlcCBhIGxpc3QgZm9yXG4vLyB0aG9zZSBzcGVjaWFsLWNhc2UgdGFncy5cbnZhciBvbWl0dGVkQ2xvc2VUYWdzID0ge1xuICBhcmVhOiB0cnVlLFxuICBiYXNlOiB0cnVlLFxuICBicjogdHJ1ZSxcbiAgY29sOiB0cnVlLFxuICBlbWJlZDogdHJ1ZSxcbiAgaHI6IHRydWUsXG4gIGltZzogdHJ1ZSxcbiAgaW5wdXQ6IHRydWUsXG4gIGtleWdlbjogdHJ1ZSxcbiAgbGluazogdHJ1ZSxcbiAgbWV0YTogdHJ1ZSxcbiAgcGFyYW06IHRydWUsXG4gIHNvdXJjZTogdHJ1ZSxcbiAgdHJhY2s6IHRydWUsXG4gIHdicjogdHJ1ZSAvLyBOT1RFOiBtZW51aXRlbSdzIGNsb3NlIHRhZyBzaG91bGQgYmUgb21pdHRlZCwgYnV0IHRoYXQgY2F1c2VzIHByb2JsZW1zLlxuXG59O1xuXG4vLyBgb21pdHRlZENsb3NlVGFnc2AgZXhjZXB0IHRoYXQgYG1lbnVpdGVtYCBzaG91bGQgc3RpbGwgaGF2ZSBpdHMgY2xvc2luZyB0YWcuXG5cbnZhciB2b2lkRWxlbWVudFRhZ3MgPSBfYXNzaWduKHtcbiAgbWVudWl0ZW06IHRydWVcbn0sIG9taXR0ZWRDbG9zZVRhZ3MpO1xuXG52YXIgSFRNTCA9ICdfX2h0bWwnO1xuXG5mdW5jdGlvbiBhc3NlcnRWYWxpZFByb3BzKHRhZywgcHJvcHMpIHtcbiAgaWYgKCFwcm9wcykge1xuICAgIHJldHVybjtcbiAgfSAvLyBOb3RlIHRoZSB1c2Ugb2YgYD09YCB3aGljaCBjaGVja3MgZm9yIG51bGwgb3IgdW5kZWZpbmVkLlxuXG5cbiAgaWYgKHZvaWRFbGVtZW50VGFnc1t0YWddKSB7XG4gICAgaWYgKCEocHJvcHMuY2hpbGRyZW4gPT0gbnVsbCAmJiBwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTCA9PSBudWxsKSkge1xuICAgICAge1xuICAgICAgICB0aHJvdyBFcnJvciggdGFnICsgXCIgaXMgYSB2b2lkIGVsZW1lbnQgdGFnIGFuZCBtdXN0IG5laXRoZXIgaGF2ZSBgY2hpbGRyZW5gIG5vciB1c2UgYGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MYC5cIiApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTCAhPSBudWxsKSB7XG4gICAgaWYgKCEocHJvcHMuY2hpbGRyZW4gPT0gbnVsbCkpIHtcbiAgICAgIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoIFwiQ2FuIG9ubHkgc2V0IG9uZSBvZiBgY2hpbGRyZW5gIG9yIGBwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTGAuXCIgKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoISh0eXBlb2YgcHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwgPT09ICdvYmplY3QnICYmIEhUTUwgaW4gcHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwpKSB7XG4gICAgICB7XG4gICAgICAgIHRocm93IEVycm9yKCBcImBwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTGAgbXVzdCBiZSBpbiB0aGUgZm9ybSBge19faHRtbDogLi4ufWAuIFBsZWFzZSB2aXNpdCBodHRwczovL3JlYWN0anMub3JnL2xpbmsvZGFuZ2Vyb3VzbHktc2V0LWlubmVyLWh0bWwgZm9yIG1vcmUgaW5mb3JtYXRpb24uXCIgKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB7XG4gICAgaWYgKCFwcm9wcy5zdXBwcmVzc0NvbnRlbnRFZGl0YWJsZVdhcm5pbmcgJiYgcHJvcHMuY29udGVudEVkaXRhYmxlICYmIHByb3BzLmNoaWxkcmVuICE9IG51bGwpIHtcbiAgICAgIGVycm9yKCdBIGNvbXBvbmVudCBpcyBgY29udGVudEVkaXRhYmxlYCBhbmQgY29udGFpbnMgYGNoaWxkcmVuYCBtYW5hZ2VkIGJ5ICcgKyAnUmVhY3QuIEl0IGlzIG5vdyB5b3VyIHJlc3BvbnNpYmlsaXR5IHRvIGd1YXJhbnRlZSB0aGF0IG5vbmUgb2YgJyArICd0aG9zZSBub2RlcyBhcmUgdW5leHBlY3RlZGx5IG1vZGlmaWVkIG9yIGR1cGxpY2F0ZWQuIFRoaXMgaXMgJyArICdwcm9iYWJseSBub3QgaW50ZW50aW9uYWwuJyk7XG4gICAgfVxuICB9XG5cbiAgaWYgKCEocHJvcHMuc3R5bGUgPT0gbnVsbCB8fCB0eXBlb2YgcHJvcHMuc3R5bGUgPT09ICdvYmplY3QnKSkge1xuICAgIHtcbiAgICAgIHRocm93IEVycm9yKCBcIlRoZSBgc3R5bGVgIHByb3AgZXhwZWN0cyBhIG1hcHBpbmcgZnJvbSBzdHlsZSBwcm9wZXJ0aWVzIHRvIHZhbHVlcywgbm90IGEgc3RyaW5nLiBGb3IgZXhhbXBsZSwgc3R5bGU9e3ttYXJnaW5SaWdodDogc3BhY2luZyArICdlbSd9fSB3aGVuIHVzaW5nIEpTWC5cIiApO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBpc0N1c3RvbUNvbXBvbmVudCh0YWdOYW1lLCBwcm9wcykge1xuICBpZiAodGFnTmFtZS5pbmRleE9mKCctJykgPT09IC0xKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBwcm9wcy5pcyA9PT0gJ3N0cmluZyc7XG4gIH1cblxuICBzd2l0Y2ggKHRhZ05hbWUpIHtcbiAgICAvLyBUaGVzZSBhcmUgcmVzZXJ2ZWQgU1ZHIGFuZCBNYXRoTUwgZWxlbWVudHMuXG4gICAgLy8gV2UgZG9uJ3QgbWluZCB0aGlzIGxpc3QgdG9vIG11Y2ggYmVjYXVzZSB3ZSBleHBlY3QgaXQgdG8gbmV2ZXIgZ3Jvdy5cbiAgICAvLyBUaGUgYWx0ZXJuYXRpdmUgaXMgdG8gdHJhY2sgdGhlIG5hbWVzcGFjZSBpbiBhIGZldyBwbGFjZXMgd2hpY2ggaXMgY29udm9sdXRlZC5cbiAgICAvLyBodHRwczovL3czYy5naXRodWIuaW8vd2ViY29tcG9uZW50cy9zcGVjL2N1c3RvbS8jY3VzdG9tLWVsZW1lbnRzLWNvcmUtY29uY2VwdHNcbiAgICBjYXNlICdhbm5vdGF0aW9uLXhtbCc6XG4gICAgY2FzZSAnY29sb3ItcHJvZmlsZSc6XG4gICAgY2FzZSAnZm9udC1mYWNlJzpcbiAgICBjYXNlICdmb250LWZhY2Utc3JjJzpcbiAgICBjYXNlICdmb250LWZhY2UtdXJpJzpcbiAgICBjYXNlICdmb250LWZhY2UtZm9ybWF0JzpcbiAgICBjYXNlICdmb250LWZhY2UtbmFtZSc6XG4gICAgY2FzZSAnbWlzc2luZy1nbHlwaCc6XG4gICAgICByZXR1cm4gZmFsc2U7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIHRydWU7XG4gIH1cbn1cblxuLy8gV2hlbiBhZGRpbmcgYXR0cmlidXRlcyB0byB0aGUgSFRNTCBvciBTVkcgYWxsb3dlZCBhdHRyaWJ1dGUgbGlzdCwgYmUgc3VyZSB0b1xuLy8gYWxzbyBhZGQgdGhlbSB0byB0aGlzIG1vZHVsZSB0byBlbnN1cmUgY2FzaW5nIGFuZCBpbmNvcnJlY3QgbmFtZVxuLy8gd2FybmluZ3MuXG52YXIgcG9zc2libGVTdGFuZGFyZE5hbWVzID0ge1xuICAvLyBIVE1MXG4gIGFjY2VwdDogJ2FjY2VwdCcsXG4gIGFjY2VwdGNoYXJzZXQ6ICdhY2NlcHRDaGFyc2V0JyxcbiAgJ2FjY2VwdC1jaGFyc2V0JzogJ2FjY2VwdENoYXJzZXQnLFxuICBhY2Nlc3NrZXk6ICdhY2Nlc3NLZXknLFxuICBhY3Rpb246ICdhY3Rpb24nLFxuICBhbGxvd2Z1bGxzY3JlZW46ICdhbGxvd0Z1bGxTY3JlZW4nLFxuICBhbHQ6ICdhbHQnLFxuICBhczogJ2FzJyxcbiAgYXN5bmM6ICdhc3luYycsXG4gIGF1dG9jYXBpdGFsaXplOiAnYXV0b0NhcGl0YWxpemUnLFxuICBhdXRvY29tcGxldGU6ICdhdXRvQ29tcGxldGUnLFxuICBhdXRvY29ycmVjdDogJ2F1dG9Db3JyZWN0JyxcbiAgYXV0b2ZvY3VzOiAnYXV0b0ZvY3VzJyxcbiAgYXV0b3BsYXk6ICdhdXRvUGxheScsXG4gIGF1dG9zYXZlOiAnYXV0b1NhdmUnLFxuICBjYXB0dXJlOiAnY2FwdHVyZScsXG4gIGNlbGxwYWRkaW5nOiAnY2VsbFBhZGRpbmcnLFxuICBjZWxsc3BhY2luZzogJ2NlbGxTcGFjaW5nJyxcbiAgY2hhbGxlbmdlOiAnY2hhbGxlbmdlJyxcbiAgY2hhcnNldDogJ2NoYXJTZXQnLFxuICBjaGVja2VkOiAnY2hlY2tlZCcsXG4gIGNoaWxkcmVuOiAnY2hpbGRyZW4nLFxuICBjaXRlOiAnY2l0ZScsXG4gIGNsYXNzOiAnY2xhc3NOYW1lJyxcbiAgY2xhc3NpZDogJ2NsYXNzSUQnLFxuICBjbGFzc25hbWU6ICdjbGFzc05hbWUnLFxuICBjb2xzOiAnY29scycsXG4gIGNvbHNwYW46ICdjb2xTcGFuJyxcbiAgY29udGVudDogJ2NvbnRlbnQnLFxuICBjb250ZW50ZWRpdGFibGU6ICdjb250ZW50RWRpdGFibGUnLFxuICBjb250ZXh0bWVudTogJ2NvbnRleHRNZW51JyxcbiAgY29udHJvbHM6ICdjb250cm9scycsXG4gIGNvbnRyb2xzbGlzdDogJ2NvbnRyb2xzTGlzdCcsXG4gIGNvb3JkczogJ2Nvb3JkcycsXG4gIGNyb3Nzb3JpZ2luOiAnY3Jvc3NPcmlnaW4nLFxuICBkYW5nZXJvdXNseXNldGlubmVyaHRtbDogJ2Rhbmdlcm91c2x5U2V0SW5uZXJIVE1MJyxcbiAgZGF0YTogJ2RhdGEnLFxuICBkYXRldGltZTogJ2RhdGVUaW1lJyxcbiAgZGVmYXVsdDogJ2RlZmF1bHQnLFxuICBkZWZhdWx0Y2hlY2tlZDogJ2RlZmF1bHRDaGVja2VkJyxcbiAgZGVmYXVsdHZhbHVlOiAnZGVmYXVsdFZhbHVlJyxcbiAgZGVmZXI6ICdkZWZlcicsXG4gIGRpcjogJ2RpcicsXG4gIGRpc2FibGVkOiAnZGlzYWJsZWQnLFxuICBkaXNhYmxlcGljdHVyZWlucGljdHVyZTogJ2Rpc2FibGVQaWN0dXJlSW5QaWN0dXJlJyxcbiAgZGlzYWJsZXJlbW90ZXBsYXliYWNrOiAnZGlzYWJsZVJlbW90ZVBsYXliYWNrJyxcbiAgZG93bmxvYWQ6ICdkb3dubG9hZCcsXG4gIGRyYWdnYWJsZTogJ2RyYWdnYWJsZScsXG4gIGVuY3R5cGU6ICdlbmNUeXBlJyxcbiAgZW50ZXJrZXloaW50OiAnZW50ZXJLZXlIaW50JyxcbiAgZm9yOiAnaHRtbEZvcicsXG4gIGZvcm06ICdmb3JtJyxcbiAgZm9ybW1ldGhvZDogJ2Zvcm1NZXRob2QnLFxuICBmb3JtYWN0aW9uOiAnZm9ybUFjdGlvbicsXG4gIGZvcm1lbmN0eXBlOiAnZm9ybUVuY1R5cGUnLFxuICBmb3Jtbm92YWxpZGF0ZTogJ2Zvcm1Ob1ZhbGlkYXRlJyxcbiAgZm9ybXRhcmdldDogJ2Zvcm1UYXJnZXQnLFxuICBmcmFtZWJvcmRlcjogJ2ZyYW1lQm9yZGVyJyxcbiAgaGVhZGVyczogJ2hlYWRlcnMnLFxuICBoZWlnaHQ6ICdoZWlnaHQnLFxuICBoaWRkZW46ICdoaWRkZW4nLFxuICBoaWdoOiAnaGlnaCcsXG4gIGhyZWY6ICdocmVmJyxcbiAgaHJlZmxhbmc6ICdocmVmTGFuZycsXG4gIGh0bWxmb3I6ICdodG1sRm9yJyxcbiAgaHR0cGVxdWl2OiAnaHR0cEVxdWl2JyxcbiAgJ2h0dHAtZXF1aXYnOiAnaHR0cEVxdWl2JyxcbiAgaWNvbjogJ2ljb24nLFxuICBpZDogJ2lkJyxcbiAgaW5uZXJodG1sOiAnaW5uZXJIVE1MJyxcbiAgaW5wdXRtb2RlOiAnaW5wdXRNb2RlJyxcbiAgaW50ZWdyaXR5OiAnaW50ZWdyaXR5JyxcbiAgaXM6ICdpcycsXG4gIGl0ZW1pZDogJ2l0ZW1JRCcsXG4gIGl0ZW1wcm9wOiAnaXRlbVByb3AnLFxuICBpdGVtcmVmOiAnaXRlbVJlZicsXG4gIGl0ZW1zY29wZTogJ2l0ZW1TY29wZScsXG4gIGl0ZW10eXBlOiAnaXRlbVR5cGUnLFxuICBrZXlwYXJhbXM6ICdrZXlQYXJhbXMnLFxuICBrZXl0eXBlOiAna2V5VHlwZScsXG4gIGtpbmQ6ICdraW5kJyxcbiAgbGFiZWw6ICdsYWJlbCcsXG4gIGxhbmc6ICdsYW5nJyxcbiAgbGlzdDogJ2xpc3QnLFxuICBsb29wOiAnbG9vcCcsXG4gIGxvdzogJ2xvdycsXG4gIG1hbmlmZXN0OiAnbWFuaWZlc3QnLFxuICBtYXJnaW53aWR0aDogJ21hcmdpbldpZHRoJyxcbiAgbWFyZ2luaGVpZ2h0OiAnbWFyZ2luSGVpZ2h0JyxcbiAgbWF4OiAnbWF4JyxcbiAgbWF4bGVuZ3RoOiAnbWF4TGVuZ3RoJyxcbiAgbWVkaWE6ICdtZWRpYScsXG4gIG1lZGlhZ3JvdXA6ICdtZWRpYUdyb3VwJyxcbiAgbWV0aG9kOiAnbWV0aG9kJyxcbiAgbWluOiAnbWluJyxcbiAgbWlubGVuZ3RoOiAnbWluTGVuZ3RoJyxcbiAgbXVsdGlwbGU6ICdtdWx0aXBsZScsXG4gIG11dGVkOiAnbXV0ZWQnLFxuICBuYW1lOiAnbmFtZScsXG4gIG5vbW9kdWxlOiAnbm9Nb2R1bGUnLFxuICBub25jZTogJ25vbmNlJyxcbiAgbm92YWxpZGF0ZTogJ25vVmFsaWRhdGUnLFxuICBvcGVuOiAnb3BlbicsXG4gIG9wdGltdW06ICdvcHRpbXVtJyxcbiAgcGF0dGVybjogJ3BhdHRlcm4nLFxuICBwbGFjZWhvbGRlcjogJ3BsYWNlaG9sZGVyJyxcbiAgcGxheXNpbmxpbmU6ICdwbGF5c0lubGluZScsXG4gIHBvc3RlcjogJ3Bvc3RlcicsXG4gIHByZWxvYWQ6ICdwcmVsb2FkJyxcbiAgcHJvZmlsZTogJ3Byb2ZpbGUnLFxuICByYWRpb2dyb3VwOiAncmFkaW9Hcm91cCcsXG4gIHJlYWRvbmx5OiAncmVhZE9ubHknLFxuICByZWZlcnJlcnBvbGljeTogJ3JlZmVycmVyUG9saWN5JyxcbiAgcmVsOiAncmVsJyxcbiAgcmVxdWlyZWQ6ICdyZXF1aXJlZCcsXG4gIHJldmVyc2VkOiAncmV2ZXJzZWQnLFxuICByb2xlOiAncm9sZScsXG4gIHJvd3M6ICdyb3dzJyxcbiAgcm93c3BhbjogJ3Jvd1NwYW4nLFxuICBzYW5kYm94OiAnc2FuZGJveCcsXG4gIHNjb3BlOiAnc2NvcGUnLFxuICBzY29wZWQ6ICdzY29wZWQnLFxuICBzY3JvbGxpbmc6ICdzY3JvbGxpbmcnLFxuICBzZWFtbGVzczogJ3NlYW1sZXNzJyxcbiAgc2VsZWN0ZWQ6ICdzZWxlY3RlZCcsXG4gIHNoYXBlOiAnc2hhcGUnLFxuICBzaXplOiAnc2l6ZScsXG4gIHNpemVzOiAnc2l6ZXMnLFxuICBzcGFuOiAnc3BhbicsXG4gIHNwZWxsY2hlY2s6ICdzcGVsbENoZWNrJyxcbiAgc3JjOiAnc3JjJyxcbiAgc3JjZG9jOiAnc3JjRG9jJyxcbiAgc3JjbGFuZzogJ3NyY0xhbmcnLFxuICBzcmNzZXQ6ICdzcmNTZXQnLFxuICBzdGFydDogJ3N0YXJ0JyxcbiAgc3RlcDogJ3N0ZXAnLFxuICBzdHlsZTogJ3N0eWxlJyxcbiAgc3VtbWFyeTogJ3N1bW1hcnknLFxuICB0YWJpbmRleDogJ3RhYkluZGV4JyxcbiAgdGFyZ2V0OiAndGFyZ2V0JyxcbiAgdGl0bGU6ICd0aXRsZScsXG4gIHR5cGU6ICd0eXBlJyxcbiAgdXNlbWFwOiAndXNlTWFwJyxcbiAgdmFsdWU6ICd2YWx1ZScsXG4gIHdpZHRoOiAnd2lkdGgnLFxuICB3bW9kZTogJ3dtb2RlJyxcbiAgd3JhcDogJ3dyYXAnLFxuICAvLyBTVkdcbiAgYWJvdXQ6ICdhYm91dCcsXG4gIGFjY2VudGhlaWdodDogJ2FjY2VudEhlaWdodCcsXG4gICdhY2NlbnQtaGVpZ2h0JzogJ2FjY2VudEhlaWdodCcsXG4gIGFjY3VtdWxhdGU6ICdhY2N1bXVsYXRlJyxcbiAgYWRkaXRpdmU6ICdhZGRpdGl2ZScsXG4gIGFsaWdubWVudGJhc2VsaW5lOiAnYWxpZ25tZW50QmFzZWxpbmUnLFxuICAnYWxpZ25tZW50LWJhc2VsaW5lJzogJ2FsaWdubWVudEJhc2VsaW5lJyxcbiAgYWxsb3dyZW9yZGVyOiAnYWxsb3dSZW9yZGVyJyxcbiAgYWxwaGFiZXRpYzogJ2FscGhhYmV0aWMnLFxuICBhbXBsaXR1ZGU6ICdhbXBsaXR1ZGUnLFxuICBhcmFiaWNmb3JtOiAnYXJhYmljRm9ybScsXG4gICdhcmFiaWMtZm9ybSc6ICdhcmFiaWNGb3JtJyxcbiAgYXNjZW50OiAnYXNjZW50JyxcbiAgYXR0cmlidXRlbmFtZTogJ2F0dHJpYnV0ZU5hbWUnLFxuICBhdHRyaWJ1dGV0eXBlOiAnYXR0cmlidXRlVHlwZScsXG4gIGF1dG9yZXZlcnNlOiAnYXV0b1JldmVyc2UnLFxuICBhemltdXRoOiAnYXppbXV0aCcsXG4gIGJhc2VmcmVxdWVuY3k6ICdiYXNlRnJlcXVlbmN5JyxcbiAgYmFzZWxpbmVzaGlmdDogJ2Jhc2VsaW5lU2hpZnQnLFxuICAnYmFzZWxpbmUtc2hpZnQnOiAnYmFzZWxpbmVTaGlmdCcsXG4gIGJhc2Vwcm9maWxlOiAnYmFzZVByb2ZpbGUnLFxuICBiYm94OiAnYmJveCcsXG4gIGJlZ2luOiAnYmVnaW4nLFxuICBiaWFzOiAnYmlhcycsXG4gIGJ5OiAnYnknLFxuICBjYWxjbW9kZTogJ2NhbGNNb2RlJyxcbiAgY2FwaGVpZ2h0OiAnY2FwSGVpZ2h0JyxcbiAgJ2NhcC1oZWlnaHQnOiAnY2FwSGVpZ2h0JyxcbiAgY2xpcDogJ2NsaXAnLFxuICBjbGlwcGF0aDogJ2NsaXBQYXRoJyxcbiAgJ2NsaXAtcGF0aCc6ICdjbGlwUGF0aCcsXG4gIGNsaXBwYXRodW5pdHM6ICdjbGlwUGF0aFVuaXRzJyxcbiAgY2xpcHJ1bGU6ICdjbGlwUnVsZScsXG4gICdjbGlwLXJ1bGUnOiAnY2xpcFJ1bGUnLFxuICBjb2xvcjogJ2NvbG9yJyxcbiAgY29sb3JpbnRlcnBvbGF0aW9uOiAnY29sb3JJbnRlcnBvbGF0aW9uJyxcbiAgJ2NvbG9yLWludGVycG9sYXRpb24nOiAnY29sb3JJbnRlcnBvbGF0aW9uJyxcbiAgY29sb3JpbnRlcnBvbGF0aW9uZmlsdGVyczogJ2NvbG9ySW50ZXJwb2xhdGlvbkZpbHRlcnMnLFxuICAnY29sb3ItaW50ZXJwb2xhdGlvbi1maWx0ZXJzJzogJ2NvbG9ySW50ZXJwb2xhdGlvbkZpbHRlcnMnLFxuICBjb2xvcnByb2ZpbGU6ICdjb2xvclByb2ZpbGUnLFxuICAnY29sb3ItcHJvZmlsZSc6ICdjb2xvclByb2ZpbGUnLFxuICBjb2xvcnJlbmRlcmluZzogJ2NvbG9yUmVuZGVyaW5nJyxcbiAgJ2NvbG9yLXJlbmRlcmluZyc6ICdjb2xvclJlbmRlcmluZycsXG4gIGNvbnRlbnRzY3JpcHR0eXBlOiAnY29udGVudFNjcmlwdFR5cGUnLFxuICBjb250ZW50c3R5bGV0eXBlOiAnY29udGVudFN0eWxlVHlwZScsXG4gIGN1cnNvcjogJ2N1cnNvcicsXG4gIGN4OiAnY3gnLFxuICBjeTogJ2N5JyxcbiAgZDogJ2QnLFxuICBkYXRhdHlwZTogJ2RhdGF0eXBlJyxcbiAgZGVjZWxlcmF0ZTogJ2RlY2VsZXJhdGUnLFxuICBkZXNjZW50OiAnZGVzY2VudCcsXG4gIGRpZmZ1c2Vjb25zdGFudDogJ2RpZmZ1c2VDb25zdGFudCcsXG4gIGRpcmVjdGlvbjogJ2RpcmVjdGlvbicsXG4gIGRpc3BsYXk6ICdkaXNwbGF5JyxcbiAgZGl2aXNvcjogJ2Rpdmlzb3InLFxuICBkb21pbmFudGJhc2VsaW5lOiAnZG9taW5hbnRCYXNlbGluZScsXG4gICdkb21pbmFudC1iYXNlbGluZSc6ICdkb21pbmFudEJhc2VsaW5lJyxcbiAgZHVyOiAnZHVyJyxcbiAgZHg6ICdkeCcsXG4gIGR5OiAnZHknLFxuICBlZGdlbW9kZTogJ2VkZ2VNb2RlJyxcbiAgZWxldmF0aW9uOiAnZWxldmF0aW9uJyxcbiAgZW5hYmxlYmFja2dyb3VuZDogJ2VuYWJsZUJhY2tncm91bmQnLFxuICAnZW5hYmxlLWJhY2tncm91bmQnOiAnZW5hYmxlQmFja2dyb3VuZCcsXG4gIGVuZDogJ2VuZCcsXG4gIGV4cG9uZW50OiAnZXhwb25lbnQnLFxuICBleHRlcm5hbHJlc291cmNlc3JlcXVpcmVkOiAnZXh0ZXJuYWxSZXNvdXJjZXNSZXF1aXJlZCcsXG4gIGZpbGw6ICdmaWxsJyxcbiAgZmlsbG9wYWNpdHk6ICdmaWxsT3BhY2l0eScsXG4gICdmaWxsLW9wYWNpdHknOiAnZmlsbE9wYWNpdHknLFxuICBmaWxscnVsZTogJ2ZpbGxSdWxlJyxcbiAgJ2ZpbGwtcnVsZSc6ICdmaWxsUnVsZScsXG4gIGZpbHRlcjogJ2ZpbHRlcicsXG4gIGZpbHRlcnJlczogJ2ZpbHRlclJlcycsXG4gIGZpbHRlcnVuaXRzOiAnZmlsdGVyVW5pdHMnLFxuICBmbG9vZG9wYWNpdHk6ICdmbG9vZE9wYWNpdHknLFxuICAnZmxvb2Qtb3BhY2l0eSc6ICdmbG9vZE9wYWNpdHknLFxuICBmbG9vZGNvbG9yOiAnZmxvb2RDb2xvcicsXG4gICdmbG9vZC1jb2xvcic6ICdmbG9vZENvbG9yJyxcbiAgZm9jdXNhYmxlOiAnZm9jdXNhYmxlJyxcbiAgZm9udGZhbWlseTogJ2ZvbnRGYW1pbHknLFxuICAnZm9udC1mYW1pbHknOiAnZm9udEZhbWlseScsXG4gIGZvbnRzaXplOiAnZm9udFNpemUnLFxuICAnZm9udC1zaXplJzogJ2ZvbnRTaXplJyxcbiAgZm9udHNpemVhZGp1c3Q6ICdmb250U2l6ZUFkanVzdCcsXG4gICdmb250LXNpemUtYWRqdXN0JzogJ2ZvbnRTaXplQWRqdXN0JyxcbiAgZm9udHN0cmV0Y2g6ICdmb250U3RyZXRjaCcsXG4gICdmb250LXN0cmV0Y2gnOiAnZm9udFN0cmV0Y2gnLFxuICBmb250c3R5bGU6ICdmb250U3R5bGUnLFxuICAnZm9udC1zdHlsZSc6ICdmb250U3R5bGUnLFxuICBmb250dmFyaWFudDogJ2ZvbnRWYXJpYW50JyxcbiAgJ2ZvbnQtdmFyaWFudCc6ICdmb250VmFyaWFudCcsXG4gIGZvbnR3ZWlnaHQ6ICdmb250V2VpZ2h0JyxcbiAgJ2ZvbnQtd2VpZ2h0JzogJ2ZvbnRXZWlnaHQnLFxuICBmb3JtYXQ6ICdmb3JtYXQnLFxuICBmcm9tOiAnZnJvbScsXG4gIGZ4OiAnZngnLFxuICBmeTogJ2Z5JyxcbiAgZzE6ICdnMScsXG4gIGcyOiAnZzInLFxuICBnbHlwaG5hbWU6ICdnbHlwaE5hbWUnLFxuICAnZ2x5cGgtbmFtZSc6ICdnbHlwaE5hbWUnLFxuICBnbHlwaG9yaWVudGF0aW9uaG9yaXpvbnRhbDogJ2dseXBoT3JpZW50YXRpb25Ib3Jpem9udGFsJyxcbiAgJ2dseXBoLW9yaWVudGF0aW9uLWhvcml6b250YWwnOiAnZ2x5cGhPcmllbnRhdGlvbkhvcml6b250YWwnLFxuICBnbHlwaG9yaWVudGF0aW9udmVydGljYWw6ICdnbHlwaE9yaWVudGF0aW9uVmVydGljYWwnLFxuICAnZ2x5cGgtb3JpZW50YXRpb24tdmVydGljYWwnOiAnZ2x5cGhPcmllbnRhdGlvblZlcnRpY2FsJyxcbiAgZ2x5cGhyZWY6ICdnbHlwaFJlZicsXG4gIGdyYWRpZW50dHJhbnNmb3JtOiAnZ3JhZGllbnRUcmFuc2Zvcm0nLFxuICBncmFkaWVudHVuaXRzOiAnZ3JhZGllbnRVbml0cycsXG4gIGhhbmdpbmc6ICdoYW5naW5nJyxcbiAgaG9yaXphZHZ4OiAnaG9yaXpBZHZYJyxcbiAgJ2hvcml6LWFkdi14JzogJ2hvcml6QWR2WCcsXG4gIGhvcml6b3JpZ2lueDogJ2hvcml6T3JpZ2luWCcsXG4gICdob3Jpei1vcmlnaW4teCc6ICdob3Jpek9yaWdpblgnLFxuICBpZGVvZ3JhcGhpYzogJ2lkZW9ncmFwaGljJyxcbiAgaW1hZ2VyZW5kZXJpbmc6ICdpbWFnZVJlbmRlcmluZycsXG4gICdpbWFnZS1yZW5kZXJpbmcnOiAnaW1hZ2VSZW5kZXJpbmcnLFxuICBpbjI6ICdpbjInLFxuICBpbjogJ2luJyxcbiAgaW5saXN0OiAnaW5saXN0JyxcbiAgaW50ZXJjZXB0OiAnaW50ZXJjZXB0JyxcbiAgazE6ICdrMScsXG4gIGsyOiAnazInLFxuICBrMzogJ2szJyxcbiAgazQ6ICdrNCcsXG4gIGs6ICdrJyxcbiAga2VybmVsbWF0cml4OiAna2VybmVsTWF0cml4JyxcbiAga2VybmVsdW5pdGxlbmd0aDogJ2tlcm5lbFVuaXRMZW5ndGgnLFxuICBrZXJuaW5nOiAna2VybmluZycsXG4gIGtleXBvaW50czogJ2tleVBvaW50cycsXG4gIGtleXNwbGluZXM6ICdrZXlTcGxpbmVzJyxcbiAga2V5dGltZXM6ICdrZXlUaW1lcycsXG4gIGxlbmd0aGFkanVzdDogJ2xlbmd0aEFkanVzdCcsXG4gIGxldHRlcnNwYWNpbmc6ICdsZXR0ZXJTcGFjaW5nJyxcbiAgJ2xldHRlci1zcGFjaW5nJzogJ2xldHRlclNwYWNpbmcnLFxuICBsaWdodGluZ2NvbG9yOiAnbGlnaHRpbmdDb2xvcicsXG4gICdsaWdodGluZy1jb2xvcic6ICdsaWdodGluZ0NvbG9yJyxcbiAgbGltaXRpbmdjb25lYW5nbGU6ICdsaW1pdGluZ0NvbmVBbmdsZScsXG4gIGxvY2FsOiAnbG9jYWwnLFxuICBtYXJrZXJlbmQ6ICdtYXJrZXJFbmQnLFxuICAnbWFya2VyLWVuZCc6ICdtYXJrZXJFbmQnLFxuICBtYXJrZXJoZWlnaHQ6ICdtYXJrZXJIZWlnaHQnLFxuICBtYXJrZXJtaWQ6ICdtYXJrZXJNaWQnLFxuICAnbWFya2VyLW1pZCc6ICdtYXJrZXJNaWQnLFxuICBtYXJrZXJzdGFydDogJ21hcmtlclN0YXJ0JyxcbiAgJ21hcmtlci1zdGFydCc6ICdtYXJrZXJTdGFydCcsXG4gIG1hcmtlcnVuaXRzOiAnbWFya2VyVW5pdHMnLFxuICBtYXJrZXJ3aWR0aDogJ21hcmtlcldpZHRoJyxcbiAgbWFzazogJ21hc2snLFxuICBtYXNrY29udGVudHVuaXRzOiAnbWFza0NvbnRlbnRVbml0cycsXG4gIG1hc2t1bml0czogJ21hc2tVbml0cycsXG4gIG1hdGhlbWF0aWNhbDogJ21hdGhlbWF0aWNhbCcsXG4gIG1vZGU6ICdtb2RlJyxcbiAgbnVtb2N0YXZlczogJ251bU9jdGF2ZXMnLFxuICBvZmZzZXQ6ICdvZmZzZXQnLFxuICBvcGFjaXR5OiAnb3BhY2l0eScsXG4gIG9wZXJhdG9yOiAnb3BlcmF0b3InLFxuICBvcmRlcjogJ29yZGVyJyxcbiAgb3JpZW50OiAnb3JpZW50JyxcbiAgb3JpZW50YXRpb246ICdvcmllbnRhdGlvbicsXG4gIG9yaWdpbjogJ29yaWdpbicsXG4gIG92ZXJmbG93OiAnb3ZlcmZsb3cnLFxuICBvdmVybGluZXBvc2l0aW9uOiAnb3ZlcmxpbmVQb3NpdGlvbicsXG4gICdvdmVybGluZS1wb3NpdGlvbic6ICdvdmVybGluZVBvc2l0aW9uJyxcbiAgb3ZlcmxpbmV0aGlja25lc3M6ICdvdmVybGluZVRoaWNrbmVzcycsXG4gICdvdmVybGluZS10aGlja25lc3MnOiAnb3ZlcmxpbmVUaGlja25lc3MnLFxuICBwYWludG9yZGVyOiAncGFpbnRPcmRlcicsXG4gICdwYWludC1vcmRlcic6ICdwYWludE9yZGVyJyxcbiAgcGFub3NlMTogJ3Bhbm9zZTEnLFxuICAncGFub3NlLTEnOiAncGFub3NlMScsXG4gIHBhdGhsZW5ndGg6ICdwYXRoTGVuZ3RoJyxcbiAgcGF0dGVybmNvbnRlbnR1bml0czogJ3BhdHRlcm5Db250ZW50VW5pdHMnLFxuICBwYXR0ZXJudHJhbnNmb3JtOiAncGF0dGVyblRyYW5zZm9ybScsXG4gIHBhdHRlcm51bml0czogJ3BhdHRlcm5Vbml0cycsXG4gIHBvaW50ZXJldmVudHM6ICdwb2ludGVyRXZlbnRzJyxcbiAgJ3BvaW50ZXItZXZlbnRzJzogJ3BvaW50ZXJFdmVudHMnLFxuICBwb2ludHM6ICdwb2ludHMnLFxuICBwb2ludHNhdHg6ICdwb2ludHNBdFgnLFxuICBwb2ludHNhdHk6ICdwb2ludHNBdFknLFxuICBwb2ludHNhdHo6ICdwb2ludHNBdFonLFxuICBwcmVmaXg6ICdwcmVmaXgnLFxuICBwcmVzZXJ2ZWFscGhhOiAncHJlc2VydmVBbHBoYScsXG4gIHByZXNlcnZlYXNwZWN0cmF0aW86ICdwcmVzZXJ2ZUFzcGVjdFJhdGlvJyxcbiAgcHJpbWl0aXZldW5pdHM6ICdwcmltaXRpdmVVbml0cycsXG4gIHByb3BlcnR5OiAncHJvcGVydHknLFxuICByOiAncicsXG4gIHJhZGl1czogJ3JhZGl1cycsXG4gIHJlZng6ICdyZWZYJyxcbiAgcmVmeTogJ3JlZlknLFxuICByZW5kZXJpbmdpbnRlbnQ6ICdyZW5kZXJpbmdJbnRlbnQnLFxuICAncmVuZGVyaW5nLWludGVudCc6ICdyZW5kZXJpbmdJbnRlbnQnLFxuICByZXBlYXRjb3VudDogJ3JlcGVhdENvdW50JyxcbiAgcmVwZWF0ZHVyOiAncmVwZWF0RHVyJyxcbiAgcmVxdWlyZWRleHRlbnNpb25zOiAncmVxdWlyZWRFeHRlbnNpb25zJyxcbiAgcmVxdWlyZWRmZWF0dXJlczogJ3JlcXVpcmVkRmVhdHVyZXMnLFxuICByZXNvdXJjZTogJ3Jlc291cmNlJyxcbiAgcmVzdGFydDogJ3Jlc3RhcnQnLFxuICByZXN1bHQ6ICdyZXN1bHQnLFxuICByZXN1bHRzOiAncmVzdWx0cycsXG4gIHJvdGF0ZTogJ3JvdGF0ZScsXG4gIHJ4OiAncngnLFxuICByeTogJ3J5JyxcbiAgc2NhbGU6ICdzY2FsZScsXG4gIHNlY3VyaXR5OiAnc2VjdXJpdHknLFxuICBzZWVkOiAnc2VlZCcsXG4gIHNoYXBlcmVuZGVyaW5nOiAnc2hhcGVSZW5kZXJpbmcnLFxuICAnc2hhcGUtcmVuZGVyaW5nJzogJ3NoYXBlUmVuZGVyaW5nJyxcbiAgc2xvcGU6ICdzbG9wZScsXG4gIHNwYWNpbmc6ICdzcGFjaW5nJyxcbiAgc3BlY3VsYXJjb25zdGFudDogJ3NwZWN1bGFyQ29uc3RhbnQnLFxuICBzcGVjdWxhcmV4cG9uZW50OiAnc3BlY3VsYXJFeHBvbmVudCcsXG4gIHNwZWVkOiAnc3BlZWQnLFxuICBzcHJlYWRtZXRob2Q6ICdzcHJlYWRNZXRob2QnLFxuICBzdGFydG9mZnNldDogJ3N0YXJ0T2Zmc2V0JyxcbiAgc3RkZGV2aWF0aW9uOiAnc3RkRGV2aWF0aW9uJyxcbiAgc3RlbWg6ICdzdGVtaCcsXG4gIHN0ZW12OiAnc3RlbXYnLFxuICBzdGl0Y2h0aWxlczogJ3N0aXRjaFRpbGVzJyxcbiAgc3RvcGNvbG9yOiAnc3RvcENvbG9yJyxcbiAgJ3N0b3AtY29sb3InOiAnc3RvcENvbG9yJyxcbiAgc3RvcG9wYWNpdHk6ICdzdG9wT3BhY2l0eScsXG4gICdzdG9wLW9wYWNpdHknOiAnc3RvcE9wYWNpdHknLFxuICBzdHJpa2V0aHJvdWdocG9zaXRpb246ICdzdHJpa2V0aHJvdWdoUG9zaXRpb24nLFxuICAnc3RyaWtldGhyb3VnaC1wb3NpdGlvbic6ICdzdHJpa2V0aHJvdWdoUG9zaXRpb24nLFxuICBzdHJpa2V0aHJvdWdodGhpY2tuZXNzOiAnc3RyaWtldGhyb3VnaFRoaWNrbmVzcycsXG4gICdzdHJpa2V0aHJvdWdoLXRoaWNrbmVzcyc6ICdzdHJpa2V0aHJvdWdoVGhpY2tuZXNzJyxcbiAgc3RyaW5nOiAnc3RyaW5nJyxcbiAgc3Ryb2tlOiAnc3Ryb2tlJyxcbiAgc3Ryb2tlZGFzaGFycmF5OiAnc3Ryb2tlRGFzaGFycmF5JyxcbiAgJ3N0cm9rZS1kYXNoYXJyYXknOiAnc3Ryb2tlRGFzaGFycmF5JyxcbiAgc3Ryb2tlZGFzaG9mZnNldDogJ3N0cm9rZURhc2hvZmZzZXQnLFxuICAnc3Ryb2tlLWRhc2hvZmZzZXQnOiAnc3Ryb2tlRGFzaG9mZnNldCcsXG4gIHN0cm9rZWxpbmVjYXA6ICdzdHJva2VMaW5lY2FwJyxcbiAgJ3N0cm9rZS1saW5lY2FwJzogJ3N0cm9rZUxpbmVjYXAnLFxuICBzdHJva2VsaW5lam9pbjogJ3N0cm9rZUxpbmVqb2luJyxcbiAgJ3N0cm9rZS1saW5lam9pbic6ICdzdHJva2VMaW5lam9pbicsXG4gIHN0cm9rZW1pdGVybGltaXQ6ICdzdHJva2VNaXRlcmxpbWl0JyxcbiAgJ3N0cm9rZS1taXRlcmxpbWl0JzogJ3N0cm9rZU1pdGVybGltaXQnLFxuICBzdHJva2V3aWR0aDogJ3N0cm9rZVdpZHRoJyxcbiAgJ3N0cm9rZS13aWR0aCc6ICdzdHJva2VXaWR0aCcsXG4gIHN0cm9rZW9wYWNpdHk6ICdzdHJva2VPcGFjaXR5JyxcbiAgJ3N0cm9rZS1vcGFjaXR5JzogJ3N0cm9rZU9wYWNpdHknLFxuICBzdXBwcmVzc2NvbnRlbnRlZGl0YWJsZXdhcm5pbmc6ICdzdXBwcmVzc0NvbnRlbnRFZGl0YWJsZVdhcm5pbmcnLFxuICBzdXBwcmVzc2h5ZHJhdGlvbndhcm5pbmc6ICdzdXBwcmVzc0h5ZHJhdGlvbldhcm5pbmcnLFxuICBzdXJmYWNlc2NhbGU6ICdzdXJmYWNlU2NhbGUnLFxuICBzeXN0ZW1sYW5ndWFnZTogJ3N5c3RlbUxhbmd1YWdlJyxcbiAgdGFibGV2YWx1ZXM6ICd0YWJsZVZhbHVlcycsXG4gIHRhcmdldHg6ICd0YXJnZXRYJyxcbiAgdGFyZ2V0eTogJ3RhcmdldFknLFxuICB0ZXh0YW5jaG9yOiAndGV4dEFuY2hvcicsXG4gICd0ZXh0LWFuY2hvcic6ICd0ZXh0QW5jaG9yJyxcbiAgdGV4dGRlY29yYXRpb246ICd0ZXh0RGVjb3JhdGlvbicsXG4gICd0ZXh0LWRlY29yYXRpb24nOiAndGV4dERlY29yYXRpb24nLFxuICB0ZXh0bGVuZ3RoOiAndGV4dExlbmd0aCcsXG4gIHRleHRyZW5kZXJpbmc6ICd0ZXh0UmVuZGVyaW5nJyxcbiAgJ3RleHQtcmVuZGVyaW5nJzogJ3RleHRSZW5kZXJpbmcnLFxuICB0bzogJ3RvJyxcbiAgdHJhbnNmb3JtOiAndHJhbnNmb3JtJyxcbiAgdHlwZW9mOiAndHlwZW9mJyxcbiAgdTE6ICd1MScsXG4gIHUyOiAndTInLFxuICB1bmRlcmxpbmVwb3NpdGlvbjogJ3VuZGVybGluZVBvc2l0aW9uJyxcbiAgJ3VuZGVybGluZS1wb3NpdGlvbic6ICd1bmRlcmxpbmVQb3NpdGlvbicsXG4gIHVuZGVybGluZXRoaWNrbmVzczogJ3VuZGVybGluZVRoaWNrbmVzcycsXG4gICd1bmRlcmxpbmUtdGhpY2tuZXNzJzogJ3VuZGVybGluZVRoaWNrbmVzcycsXG4gIHVuaWNvZGU6ICd1bmljb2RlJyxcbiAgdW5pY29kZWJpZGk6ICd1bmljb2RlQmlkaScsXG4gICd1bmljb2RlLWJpZGknOiAndW5pY29kZUJpZGknLFxuICB1bmljb2RlcmFuZ2U6ICd1bmljb2RlUmFuZ2UnLFxuICAndW5pY29kZS1yYW5nZSc6ICd1bmljb2RlUmFuZ2UnLFxuICB1bml0c3BlcmVtOiAndW5pdHNQZXJFbScsXG4gICd1bml0cy1wZXItZW0nOiAndW5pdHNQZXJFbScsXG4gIHVuc2VsZWN0YWJsZTogJ3Vuc2VsZWN0YWJsZScsXG4gIHZhbHBoYWJldGljOiAndkFscGhhYmV0aWMnLFxuICAndi1hbHBoYWJldGljJzogJ3ZBbHBoYWJldGljJyxcbiAgdmFsdWVzOiAndmFsdWVzJyxcbiAgdmVjdG9yZWZmZWN0OiAndmVjdG9yRWZmZWN0JyxcbiAgJ3ZlY3Rvci1lZmZlY3QnOiAndmVjdG9yRWZmZWN0JyxcbiAgdmVyc2lvbjogJ3ZlcnNpb24nLFxuICB2ZXJ0YWR2eTogJ3ZlcnRBZHZZJyxcbiAgJ3ZlcnQtYWR2LXknOiAndmVydEFkdlknLFxuICB2ZXJ0b3JpZ2lueDogJ3ZlcnRPcmlnaW5YJyxcbiAgJ3ZlcnQtb3JpZ2luLXgnOiAndmVydE9yaWdpblgnLFxuICB2ZXJ0b3JpZ2lueTogJ3ZlcnRPcmlnaW5ZJyxcbiAgJ3ZlcnQtb3JpZ2luLXknOiAndmVydE9yaWdpblknLFxuICB2aGFuZ2luZzogJ3ZIYW5naW5nJyxcbiAgJ3YtaGFuZ2luZyc6ICd2SGFuZ2luZycsXG4gIHZpZGVvZ3JhcGhpYzogJ3ZJZGVvZ3JhcGhpYycsXG4gICd2LWlkZW9ncmFwaGljJzogJ3ZJZGVvZ3JhcGhpYycsXG4gIHZpZXdib3g6ICd2aWV3Qm94JyxcbiAgdmlld3RhcmdldDogJ3ZpZXdUYXJnZXQnLFxuICB2aXNpYmlsaXR5OiAndmlzaWJpbGl0eScsXG4gIHZtYXRoZW1hdGljYWw6ICd2TWF0aGVtYXRpY2FsJyxcbiAgJ3YtbWF0aGVtYXRpY2FsJzogJ3ZNYXRoZW1hdGljYWwnLFxuICB2b2NhYjogJ3ZvY2FiJyxcbiAgd2lkdGhzOiAnd2lkdGhzJyxcbiAgd29yZHNwYWNpbmc6ICd3b3JkU3BhY2luZycsXG4gICd3b3JkLXNwYWNpbmcnOiAnd29yZFNwYWNpbmcnLFxuICB3cml0aW5nbW9kZTogJ3dyaXRpbmdNb2RlJyxcbiAgJ3dyaXRpbmctbW9kZSc6ICd3cml0aW5nTW9kZScsXG4gIHgxOiAneDEnLFxuICB4MjogJ3gyJyxcbiAgeDogJ3gnLFxuICB4Y2hhbm5lbHNlbGVjdG9yOiAneENoYW5uZWxTZWxlY3RvcicsXG4gIHhoZWlnaHQ6ICd4SGVpZ2h0JyxcbiAgJ3gtaGVpZ2h0JzogJ3hIZWlnaHQnLFxuICB4bGlua2FjdHVhdGU6ICd4bGlua0FjdHVhdGUnLFxuICAneGxpbms6YWN0dWF0ZSc6ICd4bGlua0FjdHVhdGUnLFxuICB4bGlua2FyY3JvbGU6ICd4bGlua0FyY3JvbGUnLFxuICAneGxpbms6YXJjcm9sZSc6ICd4bGlua0FyY3JvbGUnLFxuICB4bGlua2hyZWY6ICd4bGlua0hyZWYnLFxuICAneGxpbms6aHJlZic6ICd4bGlua0hyZWYnLFxuICB4bGlua3JvbGU6ICd4bGlua1JvbGUnLFxuICAneGxpbms6cm9sZSc6ICd4bGlua1JvbGUnLFxuICB4bGlua3Nob3c6ICd4bGlua1Nob3cnLFxuICAneGxpbms6c2hvdyc6ICd4bGlua1Nob3cnLFxuICB4bGlua3RpdGxlOiAneGxpbmtUaXRsZScsXG4gICd4bGluazp0aXRsZSc6ICd4bGlua1RpdGxlJyxcbiAgeGxpbmt0eXBlOiAneGxpbmtUeXBlJyxcbiAgJ3hsaW5rOnR5cGUnOiAneGxpbmtUeXBlJyxcbiAgeG1sYmFzZTogJ3htbEJhc2UnLFxuICAneG1sOmJhc2UnOiAneG1sQmFzZScsXG4gIHhtbGxhbmc6ICd4bWxMYW5nJyxcbiAgJ3htbDpsYW5nJzogJ3htbExhbmcnLFxuICB4bWxuczogJ3htbG5zJyxcbiAgJ3htbDpzcGFjZSc6ICd4bWxTcGFjZScsXG4gIHhtbG5zeGxpbms6ICd4bWxuc1hsaW5rJyxcbiAgJ3htbG5zOnhsaW5rJzogJ3htbG5zWGxpbmsnLFxuICB4bWxzcGFjZTogJ3htbFNwYWNlJyxcbiAgeTE6ICd5MScsXG4gIHkyOiAneTInLFxuICB5OiAneScsXG4gIHljaGFubmVsc2VsZWN0b3I6ICd5Q2hhbm5lbFNlbGVjdG9yJyxcbiAgejogJ3onLFxuICB6b29tYW5kcGFuOiAnem9vbUFuZFBhbidcbn07XG5cbnZhciBhcmlhUHJvcGVydGllcyA9IHtcbiAgJ2FyaWEtY3VycmVudCc6IDAsXG4gIC8vIHN0YXRlXG4gICdhcmlhLWRldGFpbHMnOiAwLFxuICAnYXJpYS1kaXNhYmxlZCc6IDAsXG4gIC8vIHN0YXRlXG4gICdhcmlhLWhpZGRlbic6IDAsXG4gIC8vIHN0YXRlXG4gICdhcmlhLWludmFsaWQnOiAwLFxuICAvLyBzdGF0ZVxuICAnYXJpYS1rZXlzaG9ydGN1dHMnOiAwLFxuICAnYXJpYS1sYWJlbCc6IDAsXG4gICdhcmlhLXJvbGVkZXNjcmlwdGlvbic6IDAsXG4gIC8vIFdpZGdldCBBdHRyaWJ1dGVzXG4gICdhcmlhLWF1dG9jb21wbGV0ZSc6IDAsXG4gICdhcmlhLWNoZWNrZWQnOiAwLFxuICAnYXJpYS1leHBhbmRlZCc6IDAsXG4gICdhcmlhLWhhc3BvcHVwJzogMCxcbiAgJ2FyaWEtbGV2ZWwnOiAwLFxuICAnYXJpYS1tb2RhbCc6IDAsXG4gICdhcmlhLW11bHRpbGluZSc6IDAsXG4gICdhcmlhLW11bHRpc2VsZWN0YWJsZSc6IDAsXG4gICdhcmlhLW9yaWVudGF0aW9uJzogMCxcbiAgJ2FyaWEtcGxhY2Vob2xkZXInOiAwLFxuICAnYXJpYS1wcmVzc2VkJzogMCxcbiAgJ2FyaWEtcmVhZG9ubHknOiAwLFxuICAnYXJpYS1yZXF1aXJlZCc6IDAsXG4gICdhcmlhLXNlbGVjdGVkJzogMCxcbiAgJ2FyaWEtc29ydCc6IDAsXG4gICdhcmlhLXZhbHVlbWF4JzogMCxcbiAgJ2FyaWEtdmFsdWVtaW4nOiAwLFxuICAnYXJpYS12YWx1ZW5vdyc6IDAsXG4gICdhcmlhLXZhbHVldGV4dCc6IDAsXG4gIC8vIExpdmUgUmVnaW9uIEF0dHJpYnV0ZXNcbiAgJ2FyaWEtYXRvbWljJzogMCxcbiAgJ2FyaWEtYnVzeSc6IDAsXG4gICdhcmlhLWxpdmUnOiAwLFxuICAnYXJpYS1yZWxldmFudCc6IDAsXG4gIC8vIERyYWctYW5kLURyb3AgQXR0cmlidXRlc1xuICAnYXJpYS1kcm9wZWZmZWN0JzogMCxcbiAgJ2FyaWEtZ3JhYmJlZCc6IDAsXG4gIC8vIFJlbGF0aW9uc2hpcCBBdHRyaWJ1dGVzXG4gICdhcmlhLWFjdGl2ZWRlc2NlbmRhbnQnOiAwLFxuICAnYXJpYS1jb2xjb3VudCc6IDAsXG4gICdhcmlhLWNvbGluZGV4JzogMCxcbiAgJ2FyaWEtY29sc3Bhbic6IDAsXG4gICdhcmlhLWNvbnRyb2xzJzogMCxcbiAgJ2FyaWEtZGVzY3JpYmVkYnknOiAwLFxuICAnYXJpYS1lcnJvcm1lc3NhZ2UnOiAwLFxuICAnYXJpYS1mbG93dG8nOiAwLFxuICAnYXJpYS1sYWJlbGxlZGJ5JzogMCxcbiAgJ2FyaWEtb3ducyc6IDAsXG4gICdhcmlhLXBvc2luc2V0JzogMCxcbiAgJ2FyaWEtcm93Y291bnQnOiAwLFxuICAnYXJpYS1yb3dpbmRleCc6IDAsXG4gICdhcmlhLXJvd3NwYW4nOiAwLFxuICAnYXJpYS1zZXRzaXplJzogMFxufTtcblxudmFyIHdhcm5lZFByb3BlcnRpZXMgPSB7fTtcbnZhciByQVJJQSA9IG5ldyBSZWdFeHAoJ14oYXJpYSktWycgKyBBVFRSSUJVVEVfTkFNRV9DSEFSICsgJ10qJCcpO1xudmFyIHJBUklBQ2FtZWwgPSBuZXcgUmVnRXhwKCdeKGFyaWEpW0EtWl1bJyArIEFUVFJJQlVURV9OQU1FX0NIQVIgKyAnXSokJyk7XG52YXIgaGFzT3duUHJvcGVydHkkMSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbmZ1bmN0aW9uIHZhbGlkYXRlUHJvcGVydHkodGFnTmFtZSwgbmFtZSkge1xuICB7XG4gICAgaWYgKGhhc093blByb3BlcnR5JDEuY2FsbCh3YXJuZWRQcm9wZXJ0aWVzLCBuYW1lKSAmJiB3YXJuZWRQcm9wZXJ0aWVzW25hbWVdKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAockFSSUFDYW1lbC50ZXN0KG5hbWUpKSB7XG4gICAgICB2YXIgYXJpYU5hbWUgPSAnYXJpYS0nICsgbmFtZS5zbGljZSg0KS50b0xvd2VyQ2FzZSgpO1xuICAgICAgdmFyIGNvcnJlY3ROYW1lID0gYXJpYVByb3BlcnRpZXMuaGFzT3duUHJvcGVydHkoYXJpYU5hbWUpID8gYXJpYU5hbWUgOiBudWxsOyAvLyBJZiB0aGlzIGlzIGFuIGFyaWEtKiBhdHRyaWJ1dGUsIGJ1dCBpcyBub3QgbGlzdGVkIGluIHRoZSBrbm93biBET01cbiAgICAgIC8vIERPTSBwcm9wZXJ0aWVzLCB0aGVuIGl0IGlzIGFuIGludmFsaWQgYXJpYS0qIGF0dHJpYnV0ZS5cblxuICAgICAgaWYgKGNvcnJlY3ROYW1lID09IG51bGwpIHtcbiAgICAgICAgZXJyb3IoJ0ludmFsaWQgQVJJQSBhdHRyaWJ1dGUgYCVzYC4gQVJJQSBhdHRyaWJ1dGVzIGZvbGxvdyB0aGUgcGF0dGVybiBhcmlhLSogYW5kIG11c3QgYmUgbG93ZXJjYXNlLicsIG5hbWUpO1xuXG4gICAgICAgIHdhcm5lZFByb3BlcnRpZXNbbmFtZV0gPSB0cnVlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0gLy8gYXJpYS0qIGF0dHJpYnV0ZXMgc2hvdWxkIGJlIGxvd2VyY2FzZTsgc3VnZ2VzdCB0aGUgbG93ZXJjYXNlIHZlcnNpb24uXG5cblxuICAgICAgaWYgKG5hbWUgIT09IGNvcnJlY3ROYW1lKSB7XG4gICAgICAgIGVycm9yKCdJbnZhbGlkIEFSSUEgYXR0cmlidXRlIGAlc2AuIERpZCB5b3UgbWVhbiBgJXNgPycsIG5hbWUsIGNvcnJlY3ROYW1lKTtcblxuICAgICAgICB3YXJuZWRQcm9wZXJ0aWVzW25hbWVdID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHJBUklBLnRlc3QobmFtZSkpIHtcbiAgICAgIHZhciBsb3dlckNhc2VkTmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgIHZhciBzdGFuZGFyZE5hbWUgPSBhcmlhUHJvcGVydGllcy5oYXNPd25Qcm9wZXJ0eShsb3dlckNhc2VkTmFtZSkgPyBsb3dlckNhc2VkTmFtZSA6IG51bGw7IC8vIElmIHRoaXMgaXMgYW4gYXJpYS0qIGF0dHJpYnV0ZSwgYnV0IGlzIG5vdCBsaXN0ZWQgaW4gdGhlIGtub3duIERPTVxuICAgICAgLy8gRE9NIHByb3BlcnRpZXMsIHRoZW4gaXQgaXMgYW4gaW52YWxpZCBhcmlhLSogYXR0cmlidXRlLlxuXG4gICAgICBpZiAoc3RhbmRhcmROYW1lID09IG51bGwpIHtcbiAgICAgICAgd2FybmVkUHJvcGVydGllc1tuYW1lXSA9IHRydWU7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0gLy8gYXJpYS0qIGF0dHJpYnV0ZXMgc2hvdWxkIGJlIGxvd2VyY2FzZTsgc3VnZ2VzdCB0aGUgbG93ZXJjYXNlIHZlcnNpb24uXG5cblxuICAgICAgaWYgKG5hbWUgIT09IHN0YW5kYXJkTmFtZSkge1xuICAgICAgICBlcnJvcignVW5rbm93biBBUklBIGF0dHJpYnV0ZSBgJXNgLiBEaWQgeW91IG1lYW4gYCVzYD8nLCBuYW1lLCBzdGFuZGFyZE5hbWUpO1xuXG4gICAgICAgIHdhcm5lZFByb3BlcnRpZXNbbmFtZV0gPSB0cnVlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gd2FybkludmFsaWRBUklBUHJvcHModHlwZSwgcHJvcHMpIHtcbiAge1xuICAgIHZhciBpbnZhbGlkUHJvcHMgPSBbXTtcblxuICAgIGZvciAodmFyIGtleSBpbiBwcm9wcykge1xuICAgICAgdmFyIGlzVmFsaWQgPSB2YWxpZGF0ZVByb3BlcnR5KHR5cGUsIGtleSk7XG5cbiAgICAgIGlmICghaXNWYWxpZCkge1xuICAgICAgICBpbnZhbGlkUHJvcHMucHVzaChrZXkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciB1bmtub3duUHJvcFN0cmluZyA9IGludmFsaWRQcm9wcy5tYXAoZnVuY3Rpb24gKHByb3ApIHtcbiAgICAgIHJldHVybiAnYCcgKyBwcm9wICsgJ2AnO1xuICAgIH0pLmpvaW4oJywgJyk7XG5cbiAgICBpZiAoaW52YWxpZFByb3BzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgZXJyb3IoJ0ludmFsaWQgYXJpYSBwcm9wICVzIG9uIDwlcz4gdGFnLiAnICsgJ0ZvciBkZXRhaWxzLCBzZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL2ludmFsaWQtYXJpYS1wcm9wcycsIHVua25vd25Qcm9wU3RyaW5nLCB0eXBlKTtcbiAgICB9IGVsc2UgaWYgKGludmFsaWRQcm9wcy5sZW5ndGggPiAxKSB7XG4gICAgICBlcnJvcignSW52YWxpZCBhcmlhIHByb3BzICVzIG9uIDwlcz4gdGFnLiAnICsgJ0ZvciBkZXRhaWxzLCBzZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL2ludmFsaWQtYXJpYS1wcm9wcycsIHVua25vd25Qcm9wU3RyaW5nLCB0eXBlKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVQcm9wZXJ0aWVzKHR5cGUsIHByb3BzKSB7XG4gIGlmIChpc0N1c3RvbUNvbXBvbmVudCh0eXBlLCBwcm9wcykpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB3YXJuSW52YWxpZEFSSUFQcm9wcyh0eXBlLCBwcm9wcyk7XG59XG5cbnZhciBkaWRXYXJuVmFsdWVOdWxsID0gZmFsc2U7XG5mdW5jdGlvbiB2YWxpZGF0ZVByb3BlcnRpZXMkMSh0eXBlLCBwcm9wcykge1xuICB7XG4gICAgaWYgKHR5cGUgIT09ICdpbnB1dCcgJiYgdHlwZSAhPT0gJ3RleHRhcmVhJyAmJiB0eXBlICE9PSAnc2VsZWN0Jykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChwcm9wcyAhPSBudWxsICYmIHByb3BzLnZhbHVlID09PSBudWxsICYmICFkaWRXYXJuVmFsdWVOdWxsKSB7XG4gICAgICBkaWRXYXJuVmFsdWVOdWxsID0gdHJ1ZTtcblxuICAgICAgaWYgKHR5cGUgPT09ICdzZWxlY3QnICYmIHByb3BzLm11bHRpcGxlKSB7XG4gICAgICAgIGVycm9yKCdgdmFsdWVgIHByb3Agb24gYCVzYCBzaG91bGQgbm90IGJlIG51bGwuICcgKyAnQ29uc2lkZXIgdXNpbmcgYW4gZW1wdHkgYXJyYXkgd2hlbiBgbXVsdGlwbGVgIGlzIHNldCB0byBgdHJ1ZWAgJyArICd0byBjbGVhciB0aGUgY29tcG9uZW50IG9yIGB1bmRlZmluZWRgIGZvciB1bmNvbnRyb2xsZWQgY29tcG9uZW50cy4nLCB0eXBlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVycm9yKCdgdmFsdWVgIHByb3Agb24gYCVzYCBzaG91bGQgbm90IGJlIG51bGwuICcgKyAnQ29uc2lkZXIgdXNpbmcgYW4gZW1wdHkgc3RyaW5nIHRvIGNsZWFyIHRoZSBjb21wb25lbnQgb3IgYHVuZGVmaW5lZGAgJyArICdmb3IgdW5jb250cm9sbGVkIGNvbXBvbmVudHMuJywgdHlwZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbnZhciB2YWxpZGF0ZVByb3BlcnR5JDEgPSBmdW5jdGlvbiAoKSB7fTtcblxue1xuICB2YXIgd2FybmVkUHJvcGVydGllcyQxID0ge307XG4gIHZhciBfaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuICB2YXIgRVZFTlRfTkFNRV9SRUdFWCA9IC9eb24uLztcbiAgdmFyIElOVkFMSURfRVZFTlRfTkFNRV9SRUdFWCA9IC9eb25bXkEtWl0vO1xuICB2YXIgckFSSUEkMSA9IG5ldyBSZWdFeHAoJ14oYXJpYSktWycgKyBBVFRSSUJVVEVfTkFNRV9DSEFSICsgJ10qJCcpO1xuICB2YXIgckFSSUFDYW1lbCQxID0gbmV3IFJlZ0V4cCgnXihhcmlhKVtBLVpdWycgKyBBVFRSSUJVVEVfTkFNRV9DSEFSICsgJ10qJCcpO1xuXG4gIHZhbGlkYXRlUHJvcGVydHkkMSA9IGZ1bmN0aW9uICh0YWdOYW1lLCBuYW1lLCB2YWx1ZSwgZXZlbnRSZWdpc3RyeSkge1xuICAgIGlmIChfaGFzT3duUHJvcGVydHkuY2FsbCh3YXJuZWRQcm9wZXJ0aWVzJDEsIG5hbWUpICYmIHdhcm5lZFByb3BlcnRpZXMkMVtuYW1lXSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgdmFyIGxvd2VyQ2FzZWROYW1lID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuXG4gICAgaWYgKGxvd2VyQ2FzZWROYW1lID09PSAnb25mb2N1c2luJyB8fCBsb3dlckNhc2VkTmFtZSA9PT0gJ29uZm9jdXNvdXQnKSB7XG4gICAgICBlcnJvcignUmVhY3QgdXNlcyBvbkZvY3VzIGFuZCBvbkJsdXIgaW5zdGVhZCBvZiBvbkZvY3VzSW4gYW5kIG9uRm9jdXNPdXQuICcgKyAnQWxsIFJlYWN0IGV2ZW50cyBhcmUgbm9ybWFsaXplZCB0byBidWJibGUsIHNvIG9uRm9jdXNJbiBhbmQgb25Gb2N1c091dCAnICsgJ2FyZSBub3QgbmVlZGVkL3N1cHBvcnRlZCBieSBSZWFjdC4nKTtcblxuICAgICAgd2FybmVkUHJvcGVydGllcyQxW25hbWVdID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gLy8gV2UgY2FuJ3QgcmVseSBvbiB0aGUgZXZlbnQgc3lzdGVtIGJlaW5nIGluamVjdGVkIG9uIHRoZSBzZXJ2ZXIuXG5cblxuICAgIGlmIChldmVudFJlZ2lzdHJ5ICE9IG51bGwpIHtcbiAgICAgIHZhciByZWdpc3RyYXRpb25OYW1lRGVwZW5kZW5jaWVzID0gZXZlbnRSZWdpc3RyeS5yZWdpc3RyYXRpb25OYW1lRGVwZW5kZW5jaWVzLFxuICAgICAgICAgIHBvc3NpYmxlUmVnaXN0cmF0aW9uTmFtZXMgPSBldmVudFJlZ2lzdHJ5LnBvc3NpYmxlUmVnaXN0cmF0aW9uTmFtZXM7XG5cbiAgICAgIGlmIChyZWdpc3RyYXRpb25OYW1lRGVwZW5kZW5jaWVzLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVnaXN0cmF0aW9uTmFtZSA9IHBvc3NpYmxlUmVnaXN0cmF0aW9uTmFtZXMuaGFzT3duUHJvcGVydHkobG93ZXJDYXNlZE5hbWUpID8gcG9zc2libGVSZWdpc3RyYXRpb25OYW1lc1tsb3dlckNhc2VkTmFtZV0gOiBudWxsO1xuXG4gICAgICBpZiAocmVnaXN0cmF0aW9uTmFtZSAhPSBudWxsKSB7XG4gICAgICAgIGVycm9yKCdJbnZhbGlkIGV2ZW50IGhhbmRsZXIgcHJvcGVydHkgYCVzYC4gRGlkIHlvdSBtZWFuIGAlc2A/JywgbmFtZSwgcmVnaXN0cmF0aW9uTmFtZSk7XG5cbiAgICAgICAgd2FybmVkUHJvcGVydGllcyQxW25hbWVdID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChFVkVOVF9OQU1FX1JFR0VYLnRlc3QobmFtZSkpIHtcbiAgICAgICAgZXJyb3IoJ1Vua25vd24gZXZlbnQgaGFuZGxlciBwcm9wZXJ0eSBgJXNgLiBJdCB3aWxsIGJlIGlnbm9yZWQuJywgbmFtZSk7XG5cbiAgICAgICAgd2FybmVkUHJvcGVydGllcyQxW25hbWVdID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChFVkVOVF9OQU1FX1JFR0VYLnRlc3QobmFtZSkpIHtcbiAgICAgIC8vIElmIG5vIGV2ZW50IHBsdWdpbnMgaGF2ZSBiZWVuIGluamVjdGVkLCB3ZSBhcmUgaW4gYSBzZXJ2ZXIgZW52aXJvbm1lbnQuXG4gICAgICAvLyBTbyB3ZSBjYW4ndCB0ZWxsIGlmIHRoZSBldmVudCBuYW1lIGlzIGNvcnJlY3QgZm9yIHN1cmUsIGJ1dCB3ZSBjYW4gZmlsdGVyXG4gICAgICAvLyBvdXQga25vd24gYmFkIG9uZXMgbGlrZSBgb25jbGlja2AuIFdlIGNhbid0IHN1Z2dlc3QgYSBzcGVjaWZpYyByZXBsYWNlbWVudCB0aG91Z2guXG4gICAgICBpZiAoSU5WQUxJRF9FVkVOVF9OQU1FX1JFR0VYLnRlc3QobmFtZSkpIHtcbiAgICAgICAgZXJyb3IoJ0ludmFsaWQgZXZlbnQgaGFuZGxlciBwcm9wZXJ0eSBgJXNgLiAnICsgJ1JlYWN0IGV2ZW50cyB1c2UgdGhlIGNhbWVsQ2FzZSBuYW1pbmcgY29udmVudGlvbiwgZm9yIGV4YW1wbGUgYG9uQ2xpY2tgLicsIG5hbWUpO1xuICAgICAgfVxuXG4gICAgICB3YXJuZWRQcm9wZXJ0aWVzJDFbbmFtZV0gPSB0cnVlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSAvLyBMZXQgdGhlIEFSSUEgYXR0cmlidXRlIGhvb2sgdmFsaWRhdGUgQVJJQSBhdHRyaWJ1dGVzXG5cblxuICAgIGlmIChyQVJJQSQxLnRlc3QobmFtZSkgfHwgckFSSUFDYW1lbCQxLnRlc3QobmFtZSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmIChsb3dlckNhc2VkTmFtZSA9PT0gJ2lubmVyaHRtbCcpIHtcbiAgICAgIGVycm9yKCdEaXJlY3RseSBzZXR0aW5nIHByb3BlcnR5IGBpbm5lckhUTUxgIGlzIG5vdCBwZXJtaXR0ZWQuICcgKyAnRm9yIG1vcmUgaW5mb3JtYXRpb24sIGxvb2t1cCBkb2N1bWVudGF0aW9uIG9uIGBkYW5nZXJvdXNseVNldElubmVySFRNTGAuJyk7XG5cbiAgICAgIHdhcm5lZFByb3BlcnRpZXMkMVtuYW1lXSA9IHRydWU7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAobG93ZXJDYXNlZE5hbWUgPT09ICdhcmlhJykge1xuICAgICAgZXJyb3IoJ1RoZSBgYXJpYWAgYXR0cmlidXRlIGlzIHJlc2VydmVkIGZvciBmdXR1cmUgdXNlIGluIFJlYWN0LiAnICsgJ1Bhc3MgaW5kaXZpZHVhbCBgYXJpYS1gIGF0dHJpYnV0ZXMgaW5zdGVhZC4nKTtcblxuICAgICAgd2FybmVkUHJvcGVydGllcyQxW25hbWVdID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmIChsb3dlckNhc2VkTmFtZSA9PT0gJ2lzJyAmJiB2YWx1ZSAhPT0gbnVsbCAmJiB2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIGVycm9yKCdSZWNlaXZlZCBhIGAlc2AgZm9yIGEgc3RyaW5nIGF0dHJpYnV0ZSBgaXNgLiBJZiB0aGlzIGlzIGV4cGVjdGVkLCBjYXN0ICcgKyAndGhlIHZhbHVlIHRvIGEgc3RyaW5nLicsIHR5cGVvZiB2YWx1ZSk7XG5cbiAgICAgIHdhcm5lZFByb3BlcnRpZXMkMVtuYW1lXSA9IHRydWU7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyAmJiBpc05hTih2YWx1ZSkpIHtcbiAgICAgIGVycm9yKCdSZWNlaXZlZCBOYU4gZm9yIHRoZSBgJXNgIGF0dHJpYnV0ZS4gSWYgdGhpcyBpcyBleHBlY3RlZCwgY2FzdCAnICsgJ3RoZSB2YWx1ZSB0byBhIHN0cmluZy4nLCBuYW1lKTtcblxuICAgICAgd2FybmVkUHJvcGVydGllcyQxW25hbWVdID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHZhciBwcm9wZXJ0eUluZm8gPSBnZXRQcm9wZXJ0eUluZm8obmFtZSk7XG4gICAgdmFyIGlzUmVzZXJ2ZWQgPSBwcm9wZXJ0eUluZm8gIT09IG51bGwgJiYgcHJvcGVydHlJbmZvLnR5cGUgPT09IFJFU0VSVkVEOyAvLyBLbm93biBhdHRyaWJ1dGVzIHNob3VsZCBtYXRjaCB0aGUgY2FzaW5nIHNwZWNpZmllZCBpbiB0aGUgcHJvcGVydHkgY29uZmlnLlxuXG4gICAgaWYgKHBvc3NpYmxlU3RhbmRhcmROYW1lcy5oYXNPd25Qcm9wZXJ0eShsb3dlckNhc2VkTmFtZSkpIHtcbiAgICAgIHZhciBzdGFuZGFyZE5hbWUgPSBwb3NzaWJsZVN0YW5kYXJkTmFtZXNbbG93ZXJDYXNlZE5hbWVdO1xuXG4gICAgICBpZiAoc3RhbmRhcmROYW1lICE9PSBuYW1lKSB7XG4gICAgICAgIGVycm9yKCdJbnZhbGlkIERPTSBwcm9wZXJ0eSBgJXNgLiBEaWQgeW91IG1lYW4gYCVzYD8nLCBuYW1lLCBzdGFuZGFyZE5hbWUpO1xuXG4gICAgICAgIHdhcm5lZFByb3BlcnRpZXMkMVtuYW1lXSA9IHRydWU7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIWlzUmVzZXJ2ZWQgJiYgbmFtZSAhPT0gbG93ZXJDYXNlZE5hbWUpIHtcbiAgICAgIC8vIFVua25vd24gYXR0cmlidXRlcyBzaG91bGQgaGF2ZSBsb3dlcmNhc2UgY2FzaW5nIHNpbmNlIHRoYXQncyBob3cgdGhleVxuICAgICAgLy8gd2lsbCBiZSBjYXNlZCBhbnl3YXkgd2l0aCBzZXJ2ZXIgcmVuZGVyaW5nLlxuICAgICAgZXJyb3IoJ1JlYWN0IGRvZXMgbm90IHJlY29nbml6ZSB0aGUgYCVzYCBwcm9wIG9uIGEgRE9NIGVsZW1lbnQuIElmIHlvdSAnICsgJ2ludGVudGlvbmFsbHkgd2FudCBpdCB0byBhcHBlYXIgaW4gdGhlIERPTSBhcyBhIGN1c3RvbSAnICsgJ2F0dHJpYnV0ZSwgc3BlbGwgaXQgYXMgbG93ZXJjYXNlIGAlc2AgaW5zdGVhZC4gJyArICdJZiB5b3UgYWNjaWRlbnRhbGx5IHBhc3NlZCBpdCBmcm9tIGEgcGFyZW50IGNvbXBvbmVudCwgcmVtb3ZlICcgKyAnaXQgZnJvbSB0aGUgRE9NIGVsZW1lbnQuJywgbmFtZSwgbG93ZXJDYXNlZE5hbWUpO1xuXG4gICAgICB3YXJuZWRQcm9wZXJ0aWVzJDFbbmFtZV0gPSB0cnVlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nICYmIHNob3VsZFJlbW92ZUF0dHJpYnV0ZVdpdGhXYXJuaW5nKG5hbWUsIHZhbHVlLCBwcm9wZXJ0eUluZm8sIGZhbHNlKSkge1xuICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIGVycm9yKCdSZWNlaXZlZCBgJXNgIGZvciBhIG5vbi1ib29sZWFuIGF0dHJpYnV0ZSBgJXNgLlxcblxcbicgKyAnSWYgeW91IHdhbnQgdG8gd3JpdGUgaXQgdG8gdGhlIERPTSwgcGFzcyBhIHN0cmluZyBpbnN0ZWFkOiAnICsgJyVzPVwiJXNcIiBvciAlcz17dmFsdWUudG9TdHJpbmcoKX0uJywgdmFsdWUsIG5hbWUsIG5hbWUsIHZhbHVlLCBuYW1lKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVycm9yKCdSZWNlaXZlZCBgJXNgIGZvciBhIG5vbi1ib29sZWFuIGF0dHJpYnV0ZSBgJXNgLlxcblxcbicgKyAnSWYgeW91IHdhbnQgdG8gd3JpdGUgaXQgdG8gdGhlIERPTSwgcGFzcyBhIHN0cmluZyBpbnN0ZWFkOiAnICsgJyVzPVwiJXNcIiBvciAlcz17dmFsdWUudG9TdHJpbmcoKX0uXFxuXFxuJyArICdJZiB5b3UgdXNlZCB0byBjb25kaXRpb25hbGx5IG9taXQgaXQgd2l0aCAlcz17Y29uZGl0aW9uICYmIHZhbHVlfSwgJyArICdwYXNzICVzPXtjb25kaXRpb24gPyB2YWx1ZSA6IHVuZGVmaW5lZH0gaW5zdGVhZC4nLCB2YWx1ZSwgbmFtZSwgbmFtZSwgdmFsdWUsIG5hbWUsIG5hbWUsIG5hbWUpO1xuICAgICAgfVxuXG4gICAgICB3YXJuZWRQcm9wZXJ0aWVzJDFbbmFtZV0gPSB0cnVlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSAvLyBOb3cgdGhhdCB3ZSd2ZSB2YWxpZGF0ZWQgY2FzaW5nLCBkbyBub3QgdmFsaWRhdGVcbiAgICAvLyBkYXRhIHR5cGVzIGZvciByZXNlcnZlZCBwcm9wc1xuXG5cbiAgICBpZiAoaXNSZXNlcnZlZCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSAvLyBXYXJuIHdoZW4gYSBrbm93biBhdHRyaWJ1dGUgaXMgYSBiYWQgdHlwZVxuXG5cbiAgICBpZiAoc2hvdWxkUmVtb3ZlQXR0cmlidXRlV2l0aFdhcm5pbmcobmFtZSwgdmFsdWUsIHByb3BlcnR5SW5mbywgZmFsc2UpKSB7XG4gICAgICB3YXJuZWRQcm9wZXJ0aWVzJDFbbmFtZV0gPSB0cnVlO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gLy8gV2FybiB3aGVuIHBhc3NpbmcgdGhlIHN0cmluZ3MgJ2ZhbHNlJyBvciAndHJ1ZScgaW50byBhIGJvb2xlYW4gcHJvcFxuXG5cbiAgICBpZiAoKHZhbHVlID09PSAnZmFsc2UnIHx8IHZhbHVlID09PSAndHJ1ZScpICYmIHByb3BlcnR5SW5mbyAhPT0gbnVsbCAmJiBwcm9wZXJ0eUluZm8udHlwZSA9PT0gQk9PTEVBTikge1xuICAgICAgZXJyb3IoJ1JlY2VpdmVkIHRoZSBzdHJpbmcgYCVzYCBmb3IgdGhlIGJvb2xlYW4gYXR0cmlidXRlIGAlc2AuICcgKyAnJXMgJyArICdEaWQgeW91IG1lYW4gJXM9eyVzfT8nLCB2YWx1ZSwgbmFtZSwgdmFsdWUgPT09ICdmYWxzZScgPyAnVGhlIGJyb3dzZXIgd2lsbCBpbnRlcnByZXQgaXQgYXMgYSB0cnV0aHkgdmFsdWUuJyA6ICdBbHRob3VnaCB0aGlzIHdvcmtzLCBpdCB3aWxsIG5vdCB3b3JrIGFzIGV4cGVjdGVkIGlmIHlvdSBwYXNzIHRoZSBzdHJpbmcgXCJmYWxzZVwiLicsIG5hbWUsIHZhbHVlKTtcblxuICAgICAgd2FybmVkUHJvcGVydGllcyQxW25hbWVdID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9O1xufVxuXG52YXIgd2FyblVua25vd25Qcm9wZXJ0aWVzID0gZnVuY3Rpb24gKHR5cGUsIHByb3BzLCBldmVudFJlZ2lzdHJ5KSB7XG4gIHtcbiAgICB2YXIgdW5rbm93blByb3BzID0gW107XG5cbiAgICBmb3IgKHZhciBrZXkgaW4gcHJvcHMpIHtcbiAgICAgIHZhciBpc1ZhbGlkID0gdmFsaWRhdGVQcm9wZXJ0eSQxKHR5cGUsIGtleSwgcHJvcHNba2V5XSwgZXZlbnRSZWdpc3RyeSk7XG5cbiAgICAgIGlmICghaXNWYWxpZCkge1xuICAgICAgICB1bmtub3duUHJvcHMucHVzaChrZXkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciB1bmtub3duUHJvcFN0cmluZyA9IHVua25vd25Qcm9wcy5tYXAoZnVuY3Rpb24gKHByb3ApIHtcbiAgICAgIHJldHVybiAnYCcgKyBwcm9wICsgJ2AnO1xuICAgIH0pLmpvaW4oJywgJyk7XG5cbiAgICBpZiAodW5rbm93blByb3BzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgZXJyb3IoJ0ludmFsaWQgdmFsdWUgZm9yIHByb3AgJXMgb24gPCVzPiB0YWcuIEVpdGhlciByZW1vdmUgaXQgZnJvbSB0aGUgZWxlbWVudCwgJyArICdvciBwYXNzIGEgc3RyaW5nIG9yIG51bWJlciB2YWx1ZSB0byBrZWVwIGl0IGluIHRoZSBET00uICcgKyAnRm9yIGRldGFpbHMsIHNlZSBodHRwczovL3JlYWN0anMub3JnL2xpbmsvYXR0cmlidXRlLWJlaGF2aW9yICcsIHVua25vd25Qcm9wU3RyaW5nLCB0eXBlKTtcbiAgICB9IGVsc2UgaWYgKHVua25vd25Qcm9wcy5sZW5ndGggPiAxKSB7XG4gICAgICBlcnJvcignSW52YWxpZCB2YWx1ZXMgZm9yIHByb3BzICVzIG9uIDwlcz4gdGFnLiBFaXRoZXIgcmVtb3ZlIHRoZW0gZnJvbSB0aGUgZWxlbWVudCwgJyArICdvciBwYXNzIGEgc3RyaW5nIG9yIG51bWJlciB2YWx1ZSB0byBrZWVwIHRoZW0gaW4gdGhlIERPTS4gJyArICdGb3IgZGV0YWlscywgc2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9hdHRyaWJ1dGUtYmVoYXZpb3IgJywgdW5rbm93blByb3BTdHJpbmcsIHR5cGUpO1xuICAgIH1cbiAgfVxufTtcblxuZnVuY3Rpb24gdmFsaWRhdGVQcm9wZXJ0aWVzJDIodHlwZSwgcHJvcHMsIGV2ZW50UmVnaXN0cnkpIHtcbiAgaWYgKGlzQ3VzdG9tQ29tcG9uZW50KHR5cGUsIHByb3BzKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHdhcm5Vbmtub3duUHJvcGVydGllcyh0eXBlLCBwcm9wcywgZXZlbnRSZWdpc3RyeSk7XG59XG5cbnZhciBJU19FVkVOVF9IQU5ETEVfTk9OX01BTkFHRURfTk9ERSA9IDE7XG52YXIgSVNfTk9OX0RFTEVHQVRFRCA9IDEgPDwgMTtcbnZhciBJU19DQVBUVVJFX1BIQVNFID0gMSA8PCAyO1xudmFyIElTX1JFUExBWUVEID0gMSA8PCA0O1xuLy8gc2V0IHRvIExFR0FDWV9GQl9TVVBQT1JULiBMRUdBQ1lfRkJfU1VQUE9SVCBvbmx5IGdldHMgc2V0IHdoZW5cbi8vIHdlIGNhbGwgd2lsbERlZmVyTGF0ZXJGb3JMZWdhY3lGQlN1cHBvcnQsIHRodXMgbm90IGJhaWxpbmcgb3V0XG4vLyB3aWxsIHJlc3VsdCBpbiBlbmRsZXNzIGN5Y2xlcyBsaWtlIGFuIGluZmluaXRlIGxvb3AuXG4vLyBXZSBhbHNvIGRvbid0IHdhbnQgdG8gZGVmZXIgZHVyaW5nIGV2ZW50IHJlcGxheWluZy5cblxudmFyIFNIT1VMRF9OT1RfUFJPQ0VTU19QT0xZRklMTF9FVkVOVF9QTFVHSU5TID0gSVNfRVZFTlRfSEFORExFX05PTl9NQU5BR0VEX05PREUgfCBJU19OT05fREVMRUdBVEVEIHwgSVNfQ0FQVFVSRV9QSEFTRTtcblxuLyoqXG4gKiBHZXRzIHRoZSB0YXJnZXQgbm9kZSBmcm9tIGEgbmF0aXZlIGJyb3dzZXIgZXZlbnQgYnkgYWNjb3VudGluZyBmb3JcbiAqIGluY29uc2lzdGVuY2llcyBpbiBicm93c2VyIERPTSBBUElzLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEByZXR1cm4ge0RPTUV2ZW50VGFyZ2V0fSBUYXJnZXQgbm9kZS5cbiAqL1xuXG5mdW5jdGlvbiBnZXRFdmVudFRhcmdldChuYXRpdmVFdmVudCkge1xuICAvLyBGYWxsYmFjayB0byBuYXRpdmVFdmVudC5zcmNFbGVtZW50IGZvciBJRTlcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xMjUwNlxuICB2YXIgdGFyZ2V0ID0gbmF0aXZlRXZlbnQudGFyZ2V0IHx8IG5hdGl2ZUV2ZW50LnNyY0VsZW1lbnQgfHwgd2luZG93OyAvLyBOb3JtYWxpemUgU1ZHIDx1c2U+IGVsZW1lbnQgZXZlbnRzICM0OTYzXG5cbiAgaWYgKHRhcmdldC5jb3JyZXNwb25kaW5nVXNlRWxlbWVudCkge1xuICAgIHRhcmdldCA9IHRhcmdldC5jb3JyZXNwb25kaW5nVXNlRWxlbWVudDtcbiAgfSAvLyBTYWZhcmkgbWF5IGZpcmUgZXZlbnRzIG9uIHRleHQgbm9kZXMgKE5vZGUuVEVYVF9OT0RFIGlzIDMpLlxuICAvLyBAc2VlIGh0dHA6Ly93d3cucXVpcmtzbW9kZS5vcmcvanMvZXZlbnRzX3Byb3BlcnRpZXMuaHRtbFxuXG5cbiAgcmV0dXJuIHRhcmdldC5ub2RlVHlwZSA9PT0gVEVYVF9OT0RFID8gdGFyZ2V0LnBhcmVudE5vZGUgOiB0YXJnZXQ7XG59XG5cbnZhciByZXN0b3JlSW1wbCA9IG51bGw7XG52YXIgcmVzdG9yZVRhcmdldCA9IG51bGw7XG52YXIgcmVzdG9yZVF1ZXVlID0gbnVsbDtcblxuZnVuY3Rpb24gcmVzdG9yZVN0YXRlT2ZUYXJnZXQodGFyZ2V0KSB7XG4gIC8vIFdlIHBlcmZvcm0gdGhpcyB0cmFuc2xhdGlvbiBhdCB0aGUgZW5kIG9mIHRoZSBldmVudCBsb29wIHNvIHRoYXQgd2VcbiAgLy8gYWx3YXlzIHJlY2VpdmUgdGhlIGNvcnJlY3QgZmliZXIgaGVyZVxuICB2YXIgaW50ZXJuYWxJbnN0YW5jZSA9IGdldEluc3RhbmNlRnJvbU5vZGUodGFyZ2V0KTtcblxuICBpZiAoIWludGVybmFsSW5zdGFuY2UpIHtcbiAgICAvLyBVbm1vdW50ZWRcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoISh0eXBlb2YgcmVzdG9yZUltcGwgPT09ICdmdW5jdGlvbicpKSB7XG4gICAge1xuICAgICAgdGhyb3cgRXJyb3IoIFwic2V0UmVzdG9yZUltcGxlbWVudGF0aW9uKCkgbmVlZHMgdG8gYmUgY2FsbGVkIHRvIGhhbmRsZSBhIHRhcmdldCBmb3IgY29udHJvbGxlZCBldmVudHMuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCIgKTtcbiAgICB9XG4gIH1cblxuICB2YXIgc3RhdGVOb2RlID0gaW50ZXJuYWxJbnN0YW5jZS5zdGF0ZU5vZGU7IC8vIEd1YXJkIGFnYWluc3QgRmliZXIgYmVpbmcgdW5tb3VudGVkLlxuXG4gIGlmIChzdGF0ZU5vZGUpIHtcbiAgICB2YXIgX3Byb3BzID0gZ2V0RmliZXJDdXJyZW50UHJvcHNGcm9tTm9kZShzdGF0ZU5vZGUpO1xuXG4gICAgcmVzdG9yZUltcGwoaW50ZXJuYWxJbnN0YW5jZS5zdGF0ZU5vZGUsIGludGVybmFsSW5zdGFuY2UudHlwZSwgX3Byb3BzKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzZXRSZXN0b3JlSW1wbGVtZW50YXRpb24oaW1wbCkge1xuICByZXN0b3JlSW1wbCA9IGltcGw7XG59XG5mdW5jdGlvbiBlbnF1ZXVlU3RhdGVSZXN0b3JlKHRhcmdldCkge1xuICBpZiAocmVzdG9yZVRhcmdldCkge1xuICAgIGlmIChyZXN0b3JlUXVldWUpIHtcbiAgICAgIHJlc3RvcmVRdWV1ZS5wdXNoKHRhcmdldCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3RvcmVRdWV1ZSA9IFt0YXJnZXRdO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByZXN0b3JlVGFyZ2V0ID0gdGFyZ2V0O1xuICB9XG59XG5mdW5jdGlvbiBuZWVkc1N0YXRlUmVzdG9yZSgpIHtcbiAgcmV0dXJuIHJlc3RvcmVUYXJnZXQgIT09IG51bGwgfHwgcmVzdG9yZVF1ZXVlICE9PSBudWxsO1xufVxuZnVuY3Rpb24gcmVzdG9yZVN0YXRlSWZOZWVkZWQoKSB7XG4gIGlmICghcmVzdG9yZVRhcmdldCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciB0YXJnZXQgPSByZXN0b3JlVGFyZ2V0O1xuICB2YXIgcXVldWVkVGFyZ2V0cyA9IHJlc3RvcmVRdWV1ZTtcbiAgcmVzdG9yZVRhcmdldCA9IG51bGw7XG4gIHJlc3RvcmVRdWV1ZSA9IG51bGw7XG4gIHJlc3RvcmVTdGF0ZU9mVGFyZ2V0KHRhcmdldCk7XG5cbiAgaWYgKHF1ZXVlZFRhcmdldHMpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHF1ZXVlZFRhcmdldHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHJlc3RvcmVTdGF0ZU9mVGFyZ2V0KHF1ZXVlZFRhcmdldHNbaV0pO1xuICAgIH1cbiAgfVxufVxuXG4vLyB0aGUgcmVuZGVyZXIuIFN1Y2ggYXMgd2hlbiB3ZSdyZSBkaXNwYXRjaGluZyBldmVudHMgb3IgaWYgdGhpcmQgcGFydHlcbi8vIGxpYnJhcmllcyBuZWVkIHRvIGNhbGwgYmF0Y2hlZFVwZGF0ZXMuIEV2ZW50dWFsbHksIHRoaXMgQVBJIHdpbGwgZ28gYXdheSB3aGVuXG4vLyBldmVyeXRoaW5nIGlzIGJhdGNoZWQgYnkgZGVmYXVsdC4gV2UnbGwgdGhlbiBoYXZlIGEgc2ltaWxhciBBUEkgdG8gb3B0LW91dCBvZlxuLy8gc2NoZWR1bGVkIHdvcmsgYW5kIGluc3RlYWQgZG8gc3luY2hyb25vdXMgd29yay5cbi8vIERlZmF1bHRzXG5cbnZhciBiYXRjaGVkVXBkYXRlc0ltcGwgPSBmdW5jdGlvbiAoZm4sIGJvb2trZWVwaW5nKSB7XG4gIHJldHVybiBmbihib29ra2VlcGluZyk7XG59O1xuXG52YXIgZGlzY3JldGVVcGRhdGVzSW1wbCA9IGZ1bmN0aW9uIChmbiwgYSwgYiwgYywgZCkge1xuICByZXR1cm4gZm4oYSwgYiwgYywgZCk7XG59O1xuXG52YXIgZmx1c2hEaXNjcmV0ZVVwZGF0ZXNJbXBsID0gZnVuY3Rpb24gKCkge307XG5cbnZhciBiYXRjaGVkRXZlbnRVcGRhdGVzSW1wbCA9IGJhdGNoZWRVcGRhdGVzSW1wbDtcbnZhciBpc0luc2lkZUV2ZW50SGFuZGxlciA9IGZhbHNlO1xudmFyIGlzQmF0Y2hpbmdFdmVudFVwZGF0ZXMgPSBmYWxzZTtcblxuZnVuY3Rpb24gZmluaXNoRXZlbnRIYW5kbGVyKCkge1xuICAvLyBIZXJlIHdlIHdhaXQgdW50aWwgYWxsIHVwZGF0ZXMgaGF2ZSBwcm9wYWdhdGVkLCB3aGljaCBpcyBpbXBvcnRhbnRcbiAgLy8gd2hlbiB1c2luZyBjb250cm9sbGVkIGNvbXBvbmVudHMgd2l0aGluIGxheWVyczpcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xNjk4XG4gIC8vIFRoZW4gd2UgcmVzdG9yZSBzdGF0ZSBvZiBhbnkgY29udHJvbGxlZCBjb21wb25lbnQuXG4gIHZhciBjb250cm9sbGVkQ29tcG9uZW50c0hhdmVQZW5kaW5nVXBkYXRlcyA9IG5lZWRzU3RhdGVSZXN0b3JlKCk7XG5cbiAgaWYgKGNvbnRyb2xsZWRDb21wb25lbnRzSGF2ZVBlbmRpbmdVcGRhdGVzKSB7XG4gICAgLy8gSWYgYSBjb250cm9sbGVkIGV2ZW50IHdhcyBmaXJlZCwgd2UgbWF5IG5lZWQgdG8gcmVzdG9yZSB0aGUgc3RhdGUgb2ZcbiAgICAvLyB0aGUgRE9NIG5vZGUgYmFjayB0byB0aGUgY29udHJvbGxlZCB2YWx1ZS4gVGhpcyBpcyBuZWNlc3Nhcnkgd2hlbiBSZWFjdFxuICAgIC8vIGJhaWxzIG91dCBvZiB0aGUgdXBkYXRlIHdpdGhvdXQgdG91Y2hpbmcgdGhlIERPTS5cbiAgICBmbHVzaERpc2NyZXRlVXBkYXRlc0ltcGwoKTtcbiAgICByZXN0b3JlU3RhdGVJZk5lZWRlZCgpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGJhdGNoZWRVcGRhdGVzKGZuLCBib29ra2VlcGluZykge1xuICBpZiAoaXNJbnNpZGVFdmVudEhhbmRsZXIpIHtcbiAgICAvLyBJZiB3ZSBhcmUgY3VycmVudGx5IGluc2lkZSBhbm90aGVyIGJhdGNoLCB3ZSBuZWVkIHRvIHdhaXQgdW50aWwgaXRcbiAgICAvLyBmdWxseSBjb21wbGV0ZXMgYmVmb3JlIHJlc3RvcmluZyBzdGF0ZS5cbiAgICByZXR1cm4gZm4oYm9va2tlZXBpbmcpO1xuICB9XG5cbiAgaXNJbnNpZGVFdmVudEhhbmRsZXIgPSB0cnVlO1xuXG4gIHRyeSB7XG4gICAgcmV0dXJuIGJhdGNoZWRVcGRhdGVzSW1wbChmbiwgYm9va2tlZXBpbmcpO1xuICB9IGZpbmFsbHkge1xuICAgIGlzSW5zaWRlRXZlbnRIYW5kbGVyID0gZmFsc2U7XG4gICAgZmluaXNoRXZlbnRIYW5kbGVyKCk7XG4gIH1cbn1cbmZ1bmN0aW9uIGJhdGNoZWRFdmVudFVwZGF0ZXMoZm4sIGEsIGIpIHtcbiAgaWYgKGlzQmF0Y2hpbmdFdmVudFVwZGF0ZXMpIHtcbiAgICAvLyBJZiB3ZSBhcmUgY3VycmVudGx5IGluc2lkZSBhbm90aGVyIGJhdGNoLCB3ZSBuZWVkIHRvIHdhaXQgdW50aWwgaXRcbiAgICAvLyBmdWxseSBjb21wbGV0ZXMgYmVmb3JlIHJlc3RvcmluZyBzdGF0ZS5cbiAgICByZXR1cm4gZm4oYSwgYik7XG4gIH1cblxuICBpc0JhdGNoaW5nRXZlbnRVcGRhdGVzID0gdHJ1ZTtcblxuICB0cnkge1xuICAgIHJldHVybiBiYXRjaGVkRXZlbnRVcGRhdGVzSW1wbChmbiwgYSwgYik7XG4gIH0gZmluYWxseSB7XG4gICAgaXNCYXRjaGluZ0V2ZW50VXBkYXRlcyA9IGZhbHNlO1xuICAgIGZpbmlzaEV2ZW50SGFuZGxlcigpO1xuICB9XG59XG5mdW5jdGlvbiBkaXNjcmV0ZVVwZGF0ZXMoZm4sIGEsIGIsIGMsIGQpIHtcbiAgdmFyIHByZXZJc0luc2lkZUV2ZW50SGFuZGxlciA9IGlzSW5zaWRlRXZlbnRIYW5kbGVyO1xuICBpc0luc2lkZUV2ZW50SGFuZGxlciA9IHRydWU7XG5cbiAgdHJ5IHtcbiAgICByZXR1cm4gZGlzY3JldGVVcGRhdGVzSW1wbChmbiwgYSwgYiwgYywgZCk7XG4gIH0gZmluYWxseSB7XG4gICAgaXNJbnNpZGVFdmVudEhhbmRsZXIgPSBwcmV2SXNJbnNpZGVFdmVudEhhbmRsZXI7XG5cbiAgICBpZiAoIWlzSW5zaWRlRXZlbnRIYW5kbGVyKSB7XG4gICAgICBmaW5pc2hFdmVudEhhbmRsZXIoKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGZsdXNoRGlzY3JldGVVcGRhdGVzSWZOZWVkZWQodGltZVN0YW1wKSB7XG4gIHtcbiAgICBpZiAoIWlzSW5zaWRlRXZlbnRIYW5kbGVyKSB7XG4gICAgICBmbHVzaERpc2NyZXRlVXBkYXRlc0ltcGwoKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHNldEJhdGNoaW5nSW1wbGVtZW50YXRpb24oX2JhdGNoZWRVcGRhdGVzSW1wbCwgX2Rpc2NyZXRlVXBkYXRlc0ltcGwsIF9mbHVzaERpc2NyZXRlVXBkYXRlc0ltcGwsIF9iYXRjaGVkRXZlbnRVcGRhdGVzSW1wbCkge1xuICBiYXRjaGVkVXBkYXRlc0ltcGwgPSBfYmF0Y2hlZFVwZGF0ZXNJbXBsO1xuICBkaXNjcmV0ZVVwZGF0ZXNJbXBsID0gX2Rpc2NyZXRlVXBkYXRlc0ltcGw7XG4gIGZsdXNoRGlzY3JldGVVcGRhdGVzSW1wbCA9IF9mbHVzaERpc2NyZXRlVXBkYXRlc0ltcGw7XG4gIGJhdGNoZWRFdmVudFVwZGF0ZXNJbXBsID0gX2JhdGNoZWRFdmVudFVwZGF0ZXNJbXBsO1xufVxuXG5mdW5jdGlvbiBpc0ludGVyYWN0aXZlKHRhZykge1xuICByZXR1cm4gdGFnID09PSAnYnV0dG9uJyB8fCB0YWcgPT09ICdpbnB1dCcgfHwgdGFnID09PSAnc2VsZWN0JyB8fCB0YWcgPT09ICd0ZXh0YXJlYSc7XG59XG5cbmZ1bmN0aW9uIHNob3VsZFByZXZlbnRNb3VzZUV2ZW50KG5hbWUsIHR5cGUsIHByb3BzKSB7XG4gIHN3aXRjaCAobmFtZSkge1xuICAgIGNhc2UgJ29uQ2xpY2snOlxuICAgIGNhc2UgJ29uQ2xpY2tDYXB0dXJlJzpcbiAgICBjYXNlICdvbkRvdWJsZUNsaWNrJzpcbiAgICBjYXNlICdvbkRvdWJsZUNsaWNrQ2FwdHVyZSc6XG4gICAgY2FzZSAnb25Nb3VzZURvd24nOlxuICAgIGNhc2UgJ29uTW91c2VEb3duQ2FwdHVyZSc6XG4gICAgY2FzZSAnb25Nb3VzZU1vdmUnOlxuICAgIGNhc2UgJ29uTW91c2VNb3ZlQ2FwdHVyZSc6XG4gICAgY2FzZSAnb25Nb3VzZVVwJzpcbiAgICBjYXNlICdvbk1vdXNlVXBDYXB0dXJlJzpcbiAgICBjYXNlICdvbk1vdXNlRW50ZXInOlxuICAgICAgcmV0dXJuICEhKHByb3BzLmRpc2FibGVkICYmIGlzSW50ZXJhY3RpdmUodHlwZSkpO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gaW5zdCBUaGUgaW5zdGFuY2UsIHdoaWNoIGlzIHRoZSBzb3VyY2Ugb2YgZXZlbnRzLlxuICogQHBhcmFtIHtzdHJpbmd9IHJlZ2lzdHJhdGlvbk5hbWUgTmFtZSBvZiBsaXN0ZW5lciAoZS5nLiBgb25DbGlja2ApLlxuICogQHJldHVybiB7P2Z1bmN0aW9ufSBUaGUgc3RvcmVkIGNhbGxiYWNrLlxuICovXG5cblxuZnVuY3Rpb24gZ2V0TGlzdGVuZXIoaW5zdCwgcmVnaXN0cmF0aW9uTmFtZSkge1xuICB2YXIgc3RhdGVOb2RlID0gaW5zdC5zdGF0ZU5vZGU7XG5cbiAgaWYgKHN0YXRlTm9kZSA9PT0gbnVsbCkge1xuICAgIC8vIFdvcmsgaW4gcHJvZ3Jlc3MgKGV4OiBvbmxvYWQgZXZlbnRzIGluIGluY3JlbWVudGFsIG1vZGUpLlxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIHByb3BzID0gZ2V0RmliZXJDdXJyZW50UHJvcHNGcm9tTm9kZShzdGF0ZU5vZGUpO1xuXG4gIGlmIChwcm9wcyA9PT0gbnVsbCkge1xuICAgIC8vIFdvcmsgaW4gcHJvZ3Jlc3MuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgbGlzdGVuZXIgPSBwcm9wc1tyZWdpc3RyYXRpb25OYW1lXTtcblxuICBpZiAoc2hvdWxkUHJldmVudE1vdXNlRXZlbnQocmVnaXN0cmF0aW9uTmFtZSwgaW5zdC50eXBlLCBwcm9wcykpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGlmICghKCFsaXN0ZW5lciB8fCB0eXBlb2YgbGlzdGVuZXIgPT09ICdmdW5jdGlvbicpKSB7XG4gICAge1xuICAgICAgdGhyb3cgRXJyb3IoIFwiRXhwZWN0ZWQgYFwiICsgcmVnaXN0cmF0aW9uTmFtZSArIFwiYCBsaXN0ZW5lciB0byBiZSBhIGZ1bmN0aW9uLCBpbnN0ZWFkIGdvdCBhIHZhbHVlIG9mIGBcIiArIHR5cGVvZiBsaXN0ZW5lciArIFwiYCB0eXBlLlwiICk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGxpc3RlbmVyO1xufVxuXG52YXIgcGFzc2l2ZUJyb3dzZXJFdmVudHNTdXBwb3J0ZWQgPSBmYWxzZTsgLy8gQ2hlY2sgaWYgYnJvd3NlciBzdXBwb3J0IGV2ZW50cyB3aXRoIHBhc3NpdmUgbGlzdGVuZXJzXG4vLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvRXZlbnRUYXJnZXQvYWRkRXZlbnRMaXN0ZW5lciNTYWZlbHlfZGV0ZWN0aW5nX29wdGlvbl9zdXBwb3J0XG5cbmlmIChjYW5Vc2VET00pIHtcbiAgdHJ5IHtcbiAgICB2YXIgb3B0aW9ucyA9IHt9OyAvLyAkRmxvd0ZpeE1lOiBJZ25vcmUgRmxvdyBjb21wbGFpbmluZyBhYm91dCBuZWVkaW5nIGEgdmFsdWVcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvcHRpb25zLCAncGFzc2l2ZScsIHtcbiAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICBwYXNzaXZlQnJvd3NlckV2ZW50c1N1cHBvcnRlZCA9IHRydWU7XG4gICAgICB9XG4gICAgfSk7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Rlc3QnLCBvcHRpb25zLCBvcHRpb25zKTtcbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigndGVzdCcsIG9wdGlvbnMsIG9wdGlvbnMpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcGFzc2l2ZUJyb3dzZXJFdmVudHNTdXBwb3J0ZWQgPSBmYWxzZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbnZva2VHdWFyZGVkQ2FsbGJhY2tQcm9kKG5hbWUsIGZ1bmMsIGNvbnRleHQsIGEsIGIsIGMsIGQsIGUsIGYpIHtcbiAgdmFyIGZ1bmNBcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAzKTtcblxuICB0cnkge1xuICAgIGZ1bmMuYXBwbHkoY29udGV4dCwgZnVuY0FyZ3MpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHRoaXMub25FcnJvcihlcnJvcik7XG4gIH1cbn1cblxudmFyIGludm9rZUd1YXJkZWRDYWxsYmFja0ltcGwgPSBpbnZva2VHdWFyZGVkQ2FsbGJhY2tQcm9kO1xuXG57XG4gIC8vIEluIERFViBtb2RlLCB3ZSBzd2FwIG91dCBpbnZva2VHdWFyZGVkQ2FsbGJhY2sgZm9yIGEgc3BlY2lhbCB2ZXJzaW9uXG4gIC8vIHRoYXQgcGxheXMgbW9yZSBuaWNlbHkgd2l0aCB0aGUgYnJvd3NlcidzIERldlRvb2xzLiBUaGUgaWRlYSBpcyB0byBwcmVzZXJ2ZVxuICAvLyBcIlBhdXNlIG9uIGV4Y2VwdGlvbnNcIiBiZWhhdmlvci4gQmVjYXVzZSBSZWFjdCB3cmFwcyBhbGwgdXNlci1wcm92aWRlZFxuICAvLyBmdW5jdGlvbnMgaW4gaW52b2tlR3VhcmRlZENhbGxiYWNrLCBhbmQgdGhlIHByb2R1Y3Rpb24gdmVyc2lvbiBvZlxuICAvLyBpbnZva2VHdWFyZGVkQ2FsbGJhY2sgdXNlcyBhIHRyeS1jYXRjaCwgYWxsIHVzZXIgZXhjZXB0aW9ucyBhcmUgdHJlYXRlZFxuICAvLyBsaWtlIGNhdWdodCBleGNlcHRpb25zLCBhbmQgdGhlIERldlRvb2xzIHdvbid0IHBhdXNlIHVubGVzcyB0aGUgZGV2ZWxvcGVyXG4gIC8vIHRha2VzIHRoZSBleHRyYSBzdGVwIG9mIGVuYWJsaW5nIHBhdXNlIG9uIGNhdWdodCBleGNlcHRpb25zLiBUaGlzIGlzXG4gIC8vIHVuaW50dWl0aXZlLCB0aG91Z2gsIGJlY2F1c2UgZXZlbiB0aG91Z2ggUmVhY3QgaGFzIGNhdWdodCB0aGUgZXJyb3IsIGZyb21cbiAgLy8gdGhlIGRldmVsb3BlcidzIHBlcnNwZWN0aXZlLCB0aGUgZXJyb3IgaXMgdW5jYXVnaHQuXG4gIC8vXG4gIC8vIFRvIHByZXNlcnZlIHRoZSBleHBlY3RlZCBcIlBhdXNlIG9uIGV4Y2VwdGlvbnNcIiBiZWhhdmlvciwgd2UgZG9uJ3QgdXNlIGFcbiAgLy8gdHJ5LWNhdGNoIGluIERFVi4gSW5zdGVhZCwgd2Ugc3luY2hyb25vdXNseSBkaXNwYXRjaCBhIGZha2UgZXZlbnQgdG8gYSBmYWtlXG4gIC8vIERPTSBub2RlLCBhbmQgY2FsbCB0aGUgdXNlci1wcm92aWRlZCBjYWxsYmFjayBmcm9tIGluc2lkZSBhbiBldmVudCBoYW5kbGVyXG4gIC8vIGZvciB0aGF0IGZha2UgZXZlbnQuIElmIHRoZSBjYWxsYmFjayB0aHJvd3MsIHRoZSBlcnJvciBpcyBcImNhcHR1cmVkXCIgdXNpbmdcbiAgLy8gYSBnbG9iYWwgZXZlbnQgaGFuZGxlci4gQnV0IGJlY2F1c2UgdGhlIGVycm9yIGhhcHBlbnMgaW4gYSBkaWZmZXJlbnRcbiAgLy8gZXZlbnQgbG9vcCBjb250ZXh0LCBpdCBkb2VzIG5vdCBpbnRlcnJ1cHQgdGhlIG5vcm1hbCBwcm9ncmFtIGZsb3cuXG4gIC8vIEVmZmVjdGl2ZWx5LCB0aGlzIGdpdmVzIHVzIHRyeS1jYXRjaCBiZWhhdmlvciB3aXRob3V0IGFjdHVhbGx5IHVzaW5nXG4gIC8vIHRyeS1jYXRjaC4gTmVhdCFcbiAgLy8gQ2hlY2sgdGhhdCB0aGUgYnJvd3NlciBzdXBwb3J0cyB0aGUgQVBJcyB3ZSBuZWVkIHRvIGltcGxlbWVudCBvdXIgc3BlY2lhbFxuICAvLyBERVYgdmVyc2lvbiBvZiBpbnZva2VHdWFyZGVkQ2FsbGJhY2tcbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiB3aW5kb3cuZGlzcGF0Y2hFdmVudCA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBkb2N1bWVudC5jcmVhdGVFdmVudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHZhciBmYWtlTm9kZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3JlYWN0Jyk7XG5cbiAgICBpbnZva2VHdWFyZGVkQ2FsbGJhY2tJbXBsID0gZnVuY3Rpb24gaW52b2tlR3VhcmRlZENhbGxiYWNrRGV2KG5hbWUsIGZ1bmMsIGNvbnRleHQsIGEsIGIsIGMsIGQsIGUsIGYpIHtcbiAgICAgIC8vIElmIGRvY3VtZW50IGRvZXNuJ3QgZXhpc3Qgd2Uga25vdyBmb3Igc3VyZSB3ZSB3aWxsIGNyYXNoIGluIHRoaXMgbWV0aG9kXG4gICAgICAvLyB3aGVuIHdlIGNhbGwgZG9jdW1lbnQuY3JlYXRlRXZlbnQoKS4gSG93ZXZlciB0aGlzIGNhbiBjYXVzZSBjb25mdXNpbmdcbiAgICAgIC8vIGVycm9yczogaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29raW5jdWJhdG9yL2NyZWF0ZS1yZWFjdC1hcHAvaXNzdWVzLzM0ODJcbiAgICAgIC8vIFNvIHdlIHByZWVtcHRpdmVseSB0aHJvdyB3aXRoIGEgYmV0dGVyIG1lc3NhZ2UgaW5zdGVhZC5cbiAgICAgIGlmICghKHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcpKSB7XG4gICAgICAgIHtcbiAgICAgICAgICB0aHJvdyBFcnJvciggXCJUaGUgYGRvY3VtZW50YCBnbG9iYWwgd2FzIGRlZmluZWQgd2hlbiBSZWFjdCB3YXMgaW5pdGlhbGl6ZWQsIGJ1dCBpcyBub3QgZGVmaW5lZCBhbnltb3JlLiBUaGlzIGNhbiBoYXBwZW4gaW4gYSB0ZXN0IGVudmlyb25tZW50IGlmIGEgY29tcG9uZW50IHNjaGVkdWxlcyBhbiB1cGRhdGUgZnJvbSBhbiBhc3luY2hyb25vdXMgY2FsbGJhY2ssIGJ1dCB0aGUgdGVzdCBoYXMgYWxyZWFkeSBmaW5pc2hlZCBydW5uaW5nLiBUbyBzb2x2ZSB0aGlzLCB5b3UgY2FuIGVpdGhlciB1bm1vdW50IHRoZSBjb21wb25lbnQgYXQgdGhlIGVuZCBvZiB5b3VyIHRlc3QgKGFuZCBlbnN1cmUgdGhhdCBhbnkgYXN5bmNocm9ub3VzIG9wZXJhdGlvbnMgZ2V0IGNhbmNlbGVkIGluIGBjb21wb25lbnRXaWxsVW5tb3VudGApLCBvciB5b3UgY2FuIGNoYW5nZSB0aGUgdGVzdCBpdHNlbGYgdG8gYmUgYXN5bmNocm9ub3VzLlwiICk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIGV2dCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdFdmVudCcpO1xuICAgICAgdmFyIGRpZENhbGwgPSBmYWxzZTsgLy8gS2VlcHMgdHJhY2sgb2Ygd2hldGhlciB0aGUgdXNlci1wcm92aWRlZCBjYWxsYmFjayB0aHJldyBhbiBlcnJvci4gV2VcbiAgICAgIC8vIHNldCB0aGlzIHRvIHRydWUgYXQgdGhlIGJlZ2lubmluZywgdGhlbiBzZXQgaXQgdG8gZmFsc2UgcmlnaHQgYWZ0ZXJcbiAgICAgIC8vIGNhbGxpbmcgdGhlIGZ1bmN0aW9uLiBJZiB0aGUgZnVuY3Rpb24gZXJyb3JzLCBgZGlkRXJyb3JgIHdpbGwgbmV2ZXIgYmVcbiAgICAgIC8vIHNldCB0byBmYWxzZS4gVGhpcyBzdHJhdGVneSB3b3JrcyBldmVuIGlmIHRoZSBicm93c2VyIGlzIGZsYWt5IGFuZFxuICAgICAgLy8gZmFpbHMgdG8gY2FsbCBvdXIgZ2xvYmFsIGVycm9yIGhhbmRsZXIsIGJlY2F1c2UgaXQgZG9lc24ndCByZWx5IG9uXG4gICAgICAvLyB0aGUgZXJyb3IgZXZlbnQgYXQgYWxsLlxuXG4gICAgICB2YXIgZGlkRXJyb3IgPSB0cnVlOyAvLyBLZWVwcyB0cmFjayBvZiB0aGUgdmFsdWUgb2Ygd2luZG93LmV2ZW50IHNvIHRoYXQgd2UgY2FuIHJlc2V0IGl0XG4gICAgICAvLyBkdXJpbmcgdGhlIGNhbGxiYWNrIHRvIGxldCB1c2VyIGNvZGUgYWNjZXNzIHdpbmRvdy5ldmVudCBpbiB0aGVcbiAgICAgIC8vIGJyb3dzZXJzIHRoYXQgc3VwcG9ydCBpdC5cblxuICAgICAgdmFyIHdpbmRvd0V2ZW50ID0gd2luZG93LmV2ZW50OyAvLyBLZWVwcyB0cmFjayBvZiB0aGUgZGVzY3JpcHRvciBvZiB3aW5kb3cuZXZlbnQgdG8gcmVzdG9yZSBpdCBhZnRlciBldmVudFxuICAgICAgLy8gZGlzcGF0Y2hpbmc6IGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTM2ODhcblxuICAgICAgdmFyIHdpbmRvd0V2ZW50RGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iod2luZG93LCAnZXZlbnQnKTtcblxuICAgICAgZnVuY3Rpb24gcmVzdG9yZUFmdGVyRGlzcGF0Y2goKSB7XG4gICAgICAgIC8vIFdlIGltbWVkaWF0ZWx5IHJlbW92ZSB0aGUgY2FsbGJhY2sgZnJvbSBldmVudCBsaXN0ZW5lcnMgc28gdGhhdFxuICAgICAgICAvLyBuZXN0ZWQgYGludm9rZUd1YXJkZWRDYWxsYmFja2AgY2FsbHMgZG8gbm90IGNsYXNoLiBPdGhlcndpc2UsIGFcbiAgICAgICAgLy8gbmVzdGVkIGNhbGwgd291bGQgdHJpZ2dlciB0aGUgZmFrZSBldmVudCBoYW5kbGVycyBvZiBhbnkgY2FsbCBoaWdoZXJcbiAgICAgICAgLy8gaW4gdGhlIHN0YWNrLlxuICAgICAgICBmYWtlTm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKGV2dFR5cGUsIGNhbGxDYWxsYmFjaywgZmFsc2UpOyAvLyBXZSBjaGVjayBmb3Igd2luZG93Lmhhc093blByb3BlcnR5KCdldmVudCcpIHRvIHByZXZlbnQgdGhlXG4gICAgICAgIC8vIHdpbmRvdy5ldmVudCBhc3NpZ25tZW50IGluIGJvdGggSUUgPD0gMTAgYXMgdGhleSB0aHJvdyBhbiBlcnJvclxuICAgICAgICAvLyBcIk1lbWJlciBub3QgZm91bmRcIiBpbiBzdHJpY3QgbW9kZSwgYW5kIGluIEZpcmVmb3ggd2hpY2ggZG9lcyBub3RcbiAgICAgICAgLy8gc3VwcG9ydCB3aW5kb3cuZXZlbnQuXG5cbiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cuZXZlbnQgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5oYXNPd25Qcm9wZXJ0eSgnZXZlbnQnKSkge1xuICAgICAgICAgIHdpbmRvdy5ldmVudCA9IHdpbmRvd0V2ZW50O1xuICAgICAgICB9XG4gICAgICB9IC8vIENyZWF0ZSBhbiBldmVudCBoYW5kbGVyIGZvciBvdXIgZmFrZSBldmVudC4gV2Ugd2lsbCBzeW5jaHJvbm91c2x5XG4gICAgICAvLyBkaXNwYXRjaCBvdXIgZmFrZSBldmVudCB1c2luZyBgZGlzcGF0Y2hFdmVudGAuIEluc2lkZSB0aGUgaGFuZGxlciwgd2VcbiAgICAgIC8vIGNhbGwgdGhlIHVzZXItcHJvdmlkZWQgY2FsbGJhY2suXG5cblxuICAgICAgdmFyIGZ1bmNBcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAzKTtcblxuICAgICAgZnVuY3Rpb24gY2FsbENhbGxiYWNrKCkge1xuICAgICAgICBkaWRDYWxsID0gdHJ1ZTtcbiAgICAgICAgcmVzdG9yZUFmdGVyRGlzcGF0Y2goKTtcbiAgICAgICAgZnVuYy5hcHBseShjb250ZXh0LCBmdW5jQXJncyk7XG4gICAgICAgIGRpZEVycm9yID0gZmFsc2U7XG4gICAgICB9IC8vIENyZWF0ZSBhIGdsb2JhbCBlcnJvciBldmVudCBoYW5kbGVyLiBXZSB1c2UgdGhpcyB0byBjYXB0dXJlIHRoZSB2YWx1ZVxuICAgICAgLy8gdGhhdCB3YXMgdGhyb3duLiBJdCdzIHBvc3NpYmxlIHRoYXQgdGhpcyBlcnJvciBoYW5kbGVyIHdpbGwgZmlyZSBtb3JlXG4gICAgICAvLyB0aGFuIG9uY2U7IGZvciBleGFtcGxlLCBpZiBub24tUmVhY3QgY29kZSBhbHNvIGNhbGxzIGBkaXNwYXRjaEV2ZW50YFxuICAgICAgLy8gYW5kIGEgaGFuZGxlciBmb3IgdGhhdCBldmVudCB0aHJvd3MuIFdlIHNob3VsZCBiZSByZXNpbGllbnQgdG8gbW9zdCBvZlxuICAgICAgLy8gdGhvc2UgY2FzZXMuIEV2ZW4gaWYgb3VyIGVycm9yIGV2ZW50IGhhbmRsZXIgZmlyZXMgbW9yZSB0aGFuIG9uY2UsIHRoZVxuICAgICAgLy8gbGFzdCBlcnJvciBldmVudCBpcyBhbHdheXMgdXNlZC4gSWYgdGhlIGNhbGxiYWNrIGFjdHVhbGx5IGRvZXMgZXJyb3IsXG4gICAgICAvLyB3ZSBrbm93IHRoYXQgdGhlIGxhc3QgZXJyb3IgZXZlbnQgaXMgdGhlIGNvcnJlY3Qgb25lLCBiZWNhdXNlIGl0J3Mgbm90XG4gICAgICAvLyBwb3NzaWJsZSBmb3IgYW55dGhpbmcgZWxzZSB0byBoYXZlIGhhcHBlbmVkIGluIGJldHdlZW4gb3VyIGNhbGxiYWNrXG4gICAgICAvLyBlcnJvcmluZyBhbmQgdGhlIGNvZGUgdGhhdCBmb2xsb3dzIHRoZSBgZGlzcGF0Y2hFdmVudGAgY2FsbCBiZWxvdy4gSWZcbiAgICAgIC8vIHRoZSBjYWxsYmFjayBkb2Vzbid0IGVycm9yLCBidXQgdGhlIGVycm9yIGV2ZW50IHdhcyBmaXJlZCwgd2Uga25vdyB0b1xuICAgICAgLy8gaWdub3JlIGl0IGJlY2F1c2UgYGRpZEVycm9yYCB3aWxsIGJlIGZhbHNlLCBhcyBkZXNjcmliZWQgYWJvdmUuXG5cblxuICAgICAgdmFyIGVycm9yOyAvLyBVc2UgdGhpcyB0byB0cmFjayB3aGV0aGVyIHRoZSBlcnJvciBldmVudCBpcyBldmVyIGNhbGxlZC5cblxuICAgICAgdmFyIGRpZFNldEVycm9yID0gZmFsc2U7XG4gICAgICB2YXIgaXNDcm9zc09yaWdpbkVycm9yID0gZmFsc2U7XG5cbiAgICAgIGZ1bmN0aW9uIGhhbmRsZVdpbmRvd0Vycm9yKGV2ZW50KSB7XG4gICAgICAgIGVycm9yID0gZXZlbnQuZXJyb3I7XG4gICAgICAgIGRpZFNldEVycm9yID0gdHJ1ZTtcblxuICAgICAgICBpZiAoZXJyb3IgPT09IG51bGwgJiYgZXZlbnQuY29sbm8gPT09IDAgJiYgZXZlbnQubGluZW5vID09PSAwKSB7XG4gICAgICAgICAgaXNDcm9zc09yaWdpbkVycm9yID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChldmVudC5kZWZhdWx0UHJldmVudGVkKSB7XG4gICAgICAgICAgLy8gU29tZSBvdGhlciBlcnJvciBoYW5kbGVyIGhhcyBwcmV2ZW50ZWQgZGVmYXVsdC5cbiAgICAgICAgICAvLyBCcm93c2VycyBzaWxlbmNlIHRoZSBlcnJvciByZXBvcnQgaWYgdGhpcyBoYXBwZW5zLlxuICAgICAgICAgIC8vIFdlJ2xsIHJlbWVtYmVyIHRoaXMgdG8gbGF0ZXIgZGVjaWRlIHdoZXRoZXIgdG8gbG9nIGl0IG9yIG5vdC5cbiAgICAgICAgICBpZiAoZXJyb3IgIT0gbnVsbCAmJiB0eXBlb2YgZXJyb3IgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBlcnJvci5fc3VwcHJlc3NMb2dnaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGlubmVyKSB7Ly8gSWdub3JlLlxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSAvLyBDcmVhdGUgYSBmYWtlIGV2ZW50IHR5cGUuXG5cblxuICAgICAgdmFyIGV2dFR5cGUgPSBcInJlYWN0LVwiICsgKG5hbWUgPyBuYW1lIDogJ2ludm9rZWd1YXJkZWRjYWxsYmFjaycpOyAvLyBBdHRhY2ggb3VyIGV2ZW50IGhhbmRsZXJzXG5cbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsIGhhbmRsZVdpbmRvd0Vycm9yKTtcbiAgICAgIGZha2VOb2RlLmFkZEV2ZW50TGlzdGVuZXIoZXZ0VHlwZSwgY2FsbENhbGxiYWNrLCBmYWxzZSk7IC8vIFN5bmNocm9ub3VzbHkgZGlzcGF0Y2ggb3VyIGZha2UgZXZlbnQuIElmIHRoZSB1c2VyLXByb3ZpZGVkIGZ1bmN0aW9uXG4gICAgICAvLyBlcnJvcnMsIGl0IHdpbGwgdHJpZ2dlciBvdXIgZ2xvYmFsIGVycm9yIGhhbmRsZXIuXG5cbiAgICAgIGV2dC5pbml0RXZlbnQoZXZ0VHlwZSwgZmFsc2UsIGZhbHNlKTtcbiAgICAgIGZha2VOb2RlLmRpc3BhdGNoRXZlbnQoZXZ0KTtcblxuICAgICAgaWYgKHdpbmRvd0V2ZW50RGVzY3JpcHRvcikge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkod2luZG93LCAnZXZlbnQnLCB3aW5kb3dFdmVudERlc2NyaXB0b3IpO1xuICAgICAgfVxuXG4gICAgICBpZiAoZGlkQ2FsbCAmJiBkaWRFcnJvcikge1xuICAgICAgICBpZiAoIWRpZFNldEVycm9yKSB7XG4gICAgICAgICAgLy8gVGhlIGNhbGxiYWNrIGVycm9yZWQsIGJ1dCB0aGUgZXJyb3IgZXZlbnQgbmV2ZXIgZmlyZWQuXG4gICAgICAgICAgZXJyb3IgPSBuZXcgRXJyb3IoJ0FuIGVycm9yIHdhcyB0aHJvd24gaW5zaWRlIG9uZSBvZiB5b3VyIGNvbXBvbmVudHMsIGJ1dCBSZWFjdCAnICsgXCJkb2Vzbid0IGtub3cgd2hhdCBpdCB3YXMuIFRoaXMgaXMgbGlrZWx5IGR1ZSB0byBicm93c2VyIFwiICsgJ2ZsYWtpbmVzcy4gUmVhY3QgZG9lcyBpdHMgYmVzdCB0byBwcmVzZXJ2ZSB0aGUgXCJQYXVzZSBvbiAnICsgJ2V4Y2VwdGlvbnNcIiBiZWhhdmlvciBvZiB0aGUgRGV2VG9vbHMsIHdoaWNoIHJlcXVpcmVzIHNvbWUgJyArIFwiREVWLW1vZGUgb25seSB0cmlja3MuIEl0J3MgcG9zc2libGUgdGhhdCB0aGVzZSBkb24ndCB3b3JrIGluIFwiICsgJ3lvdXIgYnJvd3Nlci4gVHJ5IHRyaWdnZXJpbmcgdGhlIGVycm9yIGluIHByb2R1Y3Rpb24gbW9kZSwgJyArICdvciBzd2l0Y2hpbmcgdG8gYSBtb2Rlcm4gYnJvd3Nlci4gSWYgeW91IHN1c3BlY3QgdGhhdCB0aGlzIGlzICcgKyAnYWN0dWFsbHkgYW4gaXNzdWUgd2l0aCBSZWFjdCwgcGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNDcm9zc09yaWdpbkVycm9yKSB7XG4gICAgICAgICAgZXJyb3IgPSBuZXcgRXJyb3IoXCJBIGNyb3NzLW9yaWdpbiBlcnJvciB3YXMgdGhyb3duLiBSZWFjdCBkb2Vzbid0IGhhdmUgYWNjZXNzIHRvIFwiICsgJ3RoZSBhY3R1YWwgZXJyb3Igb2JqZWN0IGluIGRldmVsb3BtZW50LiAnICsgJ1NlZSBodHRwczovL3JlYWN0anMub3JnL2xpbmsvY3Jvc3NvcmlnaW4tZXJyb3IgZm9yIG1vcmUgaW5mb3JtYXRpb24uJyk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLm9uRXJyb3IoZXJyb3IpO1xuICAgICAgfSAvLyBSZW1vdmUgb3VyIGV2ZW50IGxpc3RlbmVyc1xuXG5cbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdlcnJvcicsIGhhbmRsZVdpbmRvd0Vycm9yKTtcblxuICAgICAgaWYgKCFkaWRDYWxsKSB7XG4gICAgICAgIC8vIFNvbWV0aGluZyB3ZW50IHJlYWxseSB3cm9uZywgYW5kIG91ciBldmVudCB3YXMgbm90IGRpc3BhdGNoZWQuXG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTY3MzRcbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xNjU4NVxuICAgICAgICAvLyBGYWxsIGJhY2sgdG8gdGhlIHByb2R1Y3Rpb24gaW1wbGVtZW50YXRpb24uXG4gICAgICAgIHJlc3RvcmVBZnRlckRpc3BhdGNoKCk7XG4gICAgICAgIHJldHVybiBpbnZva2VHdWFyZGVkQ2FsbGJhY2tQcm9kLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxufVxuXG52YXIgaW52b2tlR3VhcmRlZENhbGxiYWNrSW1wbCQxID0gaW52b2tlR3VhcmRlZENhbGxiYWNrSW1wbDtcblxudmFyIGhhc0Vycm9yID0gZmFsc2U7XG52YXIgY2F1Z2h0RXJyb3IgPSBudWxsOyAvLyBVc2VkIGJ5IGV2ZW50IHN5c3RlbSB0byBjYXB0dXJlL3JldGhyb3cgdGhlIGZpcnN0IGVycm9yLlxuXG52YXIgaGFzUmV0aHJvd0Vycm9yID0gZmFsc2U7XG52YXIgcmV0aHJvd0Vycm9yID0gbnVsbDtcbnZhciByZXBvcnRlciA9IHtcbiAgb25FcnJvcjogZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgaGFzRXJyb3IgPSB0cnVlO1xuICAgIGNhdWdodEVycm9yID0gZXJyb3I7XG4gIH1cbn07XG4vKipcbiAqIENhbGwgYSBmdW5jdGlvbiB3aGlsZSBndWFyZGluZyBhZ2FpbnN0IGVycm9ycyB0aGF0IGhhcHBlbnMgd2l0aGluIGl0LlxuICogUmV0dXJucyBhbiBlcnJvciBpZiBpdCB0aHJvd3MsIG90aGVyd2lzZSBudWxsLlxuICpcbiAqIEluIHByb2R1Y3Rpb24sIHRoaXMgaXMgaW1wbGVtZW50ZWQgdXNpbmcgYSB0cnktY2F0Y2guIFRoZSByZWFzb24gd2UgZG9uJ3RcbiAqIHVzZSBhIHRyeS1jYXRjaCBkaXJlY3RseSBpcyBzbyB0aGF0IHdlIGNhbiBzd2FwIG91dCBhIGRpZmZlcmVudFxuICogaW1wbGVtZW50YXRpb24gaW4gREVWIG1vZGUuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgb2YgdGhlIGd1YXJkIHRvIHVzZSBmb3IgbG9nZ2luZyBvciBkZWJ1Z2dpbmdcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGludm9rZVxuICogQHBhcmFtIHsqfSBjb250ZXh0IFRoZSBjb250ZXh0IHRvIHVzZSB3aGVuIGNhbGxpbmcgdGhlIGZ1bmN0aW9uXG4gKiBAcGFyYW0gey4uLip9IGFyZ3MgQXJndW1lbnRzIGZvciBmdW5jdGlvblxuICovXG5cbmZ1bmN0aW9uIGludm9rZUd1YXJkZWRDYWxsYmFjayhuYW1lLCBmdW5jLCBjb250ZXh0LCBhLCBiLCBjLCBkLCBlLCBmKSB7XG4gIGhhc0Vycm9yID0gZmFsc2U7XG4gIGNhdWdodEVycm9yID0gbnVsbDtcbiAgaW52b2tlR3VhcmRlZENhbGxiYWNrSW1wbCQxLmFwcGx5KHJlcG9ydGVyLCBhcmd1bWVudHMpO1xufVxuLyoqXG4gKiBTYW1lIGFzIGludm9rZUd1YXJkZWRDYWxsYmFjaywgYnV0IGluc3RlYWQgb2YgcmV0dXJuaW5nIGFuIGVycm9yLCBpdCBzdG9yZXNcbiAqIGl0IGluIGEgZ2xvYmFsIHNvIGl0IGNhbiBiZSByZXRocm93biBieSBgcmV0aHJvd0NhdWdodEVycm9yYCBsYXRlci5cbiAqIFRPRE86IFNlZSBpZiBjYXVnaHRFcnJvciBhbmQgcmV0aHJvd0Vycm9yIGNhbiBiZSB1bmlmaWVkLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIG9mIHRoZSBndWFyZCB0byB1c2UgZm9yIGxvZ2dpbmcgb3IgZGVidWdnaW5nXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBpbnZva2VcbiAqIEBwYXJhbSB7Kn0gY29udGV4dCBUaGUgY29udGV4dCB0byB1c2Ugd2hlbiBjYWxsaW5nIHRoZSBmdW5jdGlvblxuICogQHBhcmFtIHsuLi4qfSBhcmdzIEFyZ3VtZW50cyBmb3IgZnVuY3Rpb25cbiAqL1xuXG5mdW5jdGlvbiBpbnZva2VHdWFyZGVkQ2FsbGJhY2tBbmRDYXRjaEZpcnN0RXJyb3IobmFtZSwgZnVuYywgY29udGV4dCwgYSwgYiwgYywgZCwgZSwgZikge1xuICBpbnZva2VHdWFyZGVkQ2FsbGJhY2suYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICBpZiAoaGFzRXJyb3IpIHtcbiAgICB2YXIgZXJyb3IgPSBjbGVhckNhdWdodEVycm9yKCk7XG5cbiAgICBpZiAoIWhhc1JldGhyb3dFcnJvcikge1xuICAgICAgaGFzUmV0aHJvd0Vycm9yID0gdHJ1ZTtcbiAgICAgIHJldGhyb3dFcnJvciA9IGVycm9yO1xuICAgIH1cbiAgfVxufVxuLyoqXG4gKiBEdXJpbmcgZXhlY3V0aW9uIG9mIGd1YXJkZWQgZnVuY3Rpb25zIHdlIHdpbGwgY2FwdHVyZSB0aGUgZmlyc3QgZXJyb3Igd2hpY2hcbiAqIHdlIHdpbGwgcmV0aHJvdyB0byBiZSBoYW5kbGVkIGJ5IHRoZSB0b3AgbGV2ZWwgZXJyb3IgaGFuZGxlci5cbiAqL1xuXG5mdW5jdGlvbiByZXRocm93Q2F1Z2h0RXJyb3IoKSB7XG4gIGlmIChoYXNSZXRocm93RXJyb3IpIHtcbiAgICB2YXIgZXJyb3IgPSByZXRocm93RXJyb3I7XG4gICAgaGFzUmV0aHJvd0Vycm9yID0gZmFsc2U7XG4gICAgcmV0aHJvd0Vycm9yID0gbnVsbDtcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxufVxuZnVuY3Rpb24gaGFzQ2F1Z2h0RXJyb3IoKSB7XG4gIHJldHVybiBoYXNFcnJvcjtcbn1cbmZ1bmN0aW9uIGNsZWFyQ2F1Z2h0RXJyb3IoKSB7XG4gIGlmIChoYXNFcnJvcikge1xuICAgIHZhciBlcnJvciA9IGNhdWdodEVycm9yO1xuICAgIGhhc0Vycm9yID0gZmFsc2U7XG4gICAgY2F1Z2h0RXJyb3IgPSBudWxsO1xuICAgIHJldHVybiBlcnJvcjtcbiAgfSBlbHNlIHtcbiAgICB7XG4gICAgICB7XG4gICAgICAgIHRocm93IEVycm9yKCBcImNsZWFyQ2F1Z2h0RXJyb3Igd2FzIGNhbGxlZCBidXQgbm8gZXJyb3Igd2FzIGNhcHR1cmVkLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiICk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogYFJlYWN0SW5zdGFuY2VNYXBgIG1haW50YWlucyBhIG1hcHBpbmcgZnJvbSBhIHB1YmxpYyBmYWNpbmcgc3RhdGVmdWxcbiAqIGluc3RhbmNlIChrZXkpIGFuZCB0aGUgaW50ZXJuYWwgcmVwcmVzZW50YXRpb24gKHZhbHVlKS4gVGhpcyBhbGxvd3MgcHVibGljXG4gKiBtZXRob2RzIHRvIGFjY2VwdCB0aGUgdXNlciBmYWNpbmcgaW5zdGFuY2UgYXMgYW4gYXJndW1lbnQgYW5kIG1hcCB0aGVtIGJhY2tcbiAqIHRvIGludGVybmFsIG1ldGhvZHMuXG4gKlxuICogTm90ZSB0aGF0IHRoaXMgbW9kdWxlIGlzIGN1cnJlbnRseSBzaGFyZWQgYW5kIGFzc3VtZWQgdG8gYmUgc3RhdGVsZXNzLlxuICogSWYgdGhpcyBiZWNvbWVzIGFuIGFjdHVhbCBNYXAsIHRoYXQgd2lsbCBicmVhay5cbiAqL1xuZnVuY3Rpb24gZ2V0KGtleSkge1xuICByZXR1cm4ga2V5Ll9yZWFjdEludGVybmFscztcbn1cbmZ1bmN0aW9uIGhhcyhrZXkpIHtcbiAgcmV0dXJuIGtleS5fcmVhY3RJbnRlcm5hbHMgIT09IHVuZGVmaW5lZDtcbn1cbmZ1bmN0aW9uIHNldChrZXksIHZhbHVlKSB7XG4gIGtleS5fcmVhY3RJbnRlcm5hbHMgPSB2YWx1ZTtcbn1cblxuLy8gRG9uJ3QgY2hhbmdlIHRoZXNlIHR3byB2YWx1ZXMuIFRoZXkncmUgdXNlZCBieSBSZWFjdCBEZXYgVG9vbHMuXG52YXIgTm9GbGFncyA9XG4vKiAgICAgICAgICAgICAgICAgICAgICAqL1xuMDtcbnZhciBQZXJmb3JtZWRXb3JrID1cbi8qICAgICAgICAgICAgICAgICovXG4xOyAvLyBZb3UgY2FuIGNoYW5nZSB0aGUgcmVzdCAoYW5kIGFkZCBtb3JlKS5cblxudmFyIFBsYWNlbWVudCA9XG4vKiAgICAgICAgICAgICAgICAgICAgKi9cbjI7XG52YXIgVXBkYXRlID1cbi8qICAgICAgICAgICAgICAgICAgICAgICAqL1xuNDtcbnZhciBQbGFjZW1lbnRBbmRVcGRhdGUgPVxuLyogICAgICAgICAgICovXG42O1xudmFyIERlbGV0aW9uID1cbi8qICAgICAgICAgICAgICAgICAgICAgKi9cbjg7XG52YXIgQ29udGVudFJlc2V0ID1cbi8qICAgICAgICAgICAgICAgICAqL1xuMTY7XG52YXIgQ2FsbGJhY2sgPVxuLyogICAgICAgICAgICAgICAgICAgICAqL1xuMzI7XG52YXIgRGlkQ2FwdHVyZSA9XG4vKiAgICAgICAgICAgICAgICAgICAqL1xuNjQ7XG52YXIgUmVmID1cbi8qICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuMTI4O1xudmFyIFNuYXBzaG90ID1cbi8qICAgICAgICAgICAgICAgICAgICAgKi9cbjI1NjtcbnZhciBQYXNzaXZlID1cbi8qICAgICAgICAgICAgICAgICAgICAgICovXG41MTI7IC8vIFRPRE8gKGVmZmVjdHMpIFJlbW92ZSB0aGlzIGJpdCBvbmNlIHRoZSBuZXcgcmVjb25jaWxlciBpcyBzeW5jZWQgdG8gdGhlIG9sZC5cblxudmFyIFBhc3NpdmVVbm1vdW50UGVuZGluZ0RldiA9XG4vKiAgICAgKi9cbjgxOTI7XG52YXIgSHlkcmF0aW5nID1cbi8qICAgICAgICAgICAgICAgICAgICAqL1xuMTAyNDtcbnZhciBIeWRyYXRpbmdBbmRVcGRhdGUgPVxuLyogICAgICAgICAgICovXG4xMDI4OyAvLyBQYXNzaXZlICYgVXBkYXRlICYgQ2FsbGJhY2sgJiBSZWYgJiBTbmFwc2hvdFxuXG52YXIgTGlmZWN5Y2xlRWZmZWN0TWFzayA9XG4vKiAgICAgICAgICAqL1xuOTMyOyAvLyBVbmlvbiBvZiBhbGwgaG9zdCBlZmZlY3RzXG5cbnZhciBIb3N0RWZmZWN0TWFzayA9XG4vKiAgICAgICAgICAgICAgICovXG4yMDQ3OyAvLyBUaGVzZSBhcmUgbm90IHJlYWxseSBzaWRlIGVmZmVjdHMsIGJ1dCB3ZSBzdGlsbCByZXVzZSB0aGlzIGZpZWxkLlxuXG52YXIgSW5jb21wbGV0ZSA9XG4vKiAgICAgICAgICAgICAgICAgICAqL1xuMjA0ODtcbnZhciBTaG91bGRDYXB0dXJlID1cbi8qICAgICAgICAgICAgICAgICovXG40MDk2O1xudmFyIEZvcmNlVXBkYXRlRm9yTGVnYWN5U3VzcGVuc2UgPVxuLyogKi9cbjE2Mzg0OyAvLyBTdGF0aWMgdGFncyBkZXNjcmliZSBhc3BlY3RzIG9mIGEgZmliZXIgdGhhdCBhcmUgbm90IHNwZWNpZmljIHRvIGEgcmVuZGVyLFxuXG52YXIgUmVhY3RDdXJyZW50T3duZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdEN1cnJlbnRPd25lcjtcbmZ1bmN0aW9uIGdldE5lYXJlc3RNb3VudGVkRmliZXIoZmliZXIpIHtcbiAgdmFyIG5vZGUgPSBmaWJlcjtcbiAgdmFyIG5lYXJlc3RNb3VudGVkID0gZmliZXI7XG5cbiAgaWYgKCFmaWJlci5hbHRlcm5hdGUpIHtcbiAgICAvLyBJZiB0aGVyZSBpcyBubyBhbHRlcm5hdGUsIHRoaXMgbWlnaHQgYmUgYSBuZXcgdHJlZSB0aGF0IGlzbid0IGluc2VydGVkXG4gICAgLy8geWV0LiBJZiBpdCBpcywgdGhlbiBpdCB3aWxsIGhhdmUgYSBwZW5kaW5nIGluc2VydGlvbiBlZmZlY3Qgb24gaXQuXG4gICAgdmFyIG5leHROb2RlID0gbm9kZTtcblxuICAgIGRvIHtcbiAgICAgIG5vZGUgPSBuZXh0Tm9kZTtcblxuICAgICAgaWYgKChub2RlLmZsYWdzICYgKFBsYWNlbWVudCB8IEh5ZHJhdGluZykpICE9PSBOb0ZsYWdzKSB7XG4gICAgICAgIC8vIFRoaXMgaXMgYW4gaW5zZXJ0aW9uIG9yIGluLXByb2dyZXNzIGh5ZHJhdGlvbi4gVGhlIG5lYXJlc3QgcG9zc2libGVcbiAgICAgICAgLy8gbW91bnRlZCBmaWJlciBpcyB0aGUgcGFyZW50IGJ1dCB3ZSBuZWVkIHRvIGNvbnRpbnVlIHRvIGZpZ3VyZSBvdXRcbiAgICAgICAgLy8gaWYgdGhhdCBvbmUgaXMgc3RpbGwgbW91bnRlZC5cbiAgICAgICAgbmVhcmVzdE1vdW50ZWQgPSBub2RlLnJldHVybjtcbiAgICAgIH1cblxuICAgICAgbmV4dE5vZGUgPSBub2RlLnJldHVybjtcbiAgICB9IHdoaWxlIChuZXh0Tm9kZSk7XG4gIH0gZWxzZSB7XG4gICAgd2hpbGUgKG5vZGUucmV0dXJuKSB7XG4gICAgICBub2RlID0gbm9kZS5yZXR1cm47XG4gICAgfVxuICB9XG5cbiAgaWYgKG5vZGUudGFnID09PSBIb3N0Um9vdCkge1xuICAgIC8vIFRPRE86IENoZWNrIGlmIHRoaXMgd2FzIGEgbmVzdGVkIEhvc3RSb290IHdoZW4gdXNlZCB3aXRoXG4gICAgLy8gcmVuZGVyQ29udGFpbmVySW50b1N1YnRyZWUuXG4gICAgcmV0dXJuIG5lYXJlc3RNb3VudGVkO1xuICB9IC8vIElmIHdlIGRpZG4ndCBoaXQgdGhlIHJvb3QsIHRoYXQgbWVhbnMgdGhhdCB3ZSdyZSBpbiBhbiBkaXNjb25uZWN0ZWQgdHJlZVxuICAvLyB0aGF0IGhhcyBiZWVuIHVubW91bnRlZC5cblxuXG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gZ2V0U3VzcGVuc2VJbnN0YW5jZUZyb21GaWJlcihmaWJlcikge1xuICBpZiAoZmliZXIudGFnID09PSBTdXNwZW5zZUNvbXBvbmVudCkge1xuICAgIHZhciBzdXNwZW5zZVN0YXRlID0gZmliZXIubWVtb2l6ZWRTdGF0ZTtcblxuICAgIGlmIChzdXNwZW5zZVN0YXRlID09PSBudWxsKSB7XG4gICAgICB2YXIgY3VycmVudCA9IGZpYmVyLmFsdGVybmF0ZTtcblxuICAgICAgaWYgKGN1cnJlbnQgIT09IG51bGwpIHtcbiAgICAgICAgc3VzcGVuc2VTdGF0ZSA9IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoc3VzcGVuc2VTdGF0ZSAhPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHN1c3BlbnNlU3RhdGUuZGVoeWRyYXRlZDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGdldENvbnRhaW5lckZyb21GaWJlcihmaWJlcikge1xuICByZXR1cm4gZmliZXIudGFnID09PSBIb3N0Um9vdCA/IGZpYmVyLnN0YXRlTm9kZS5jb250YWluZXJJbmZvIDogbnVsbDtcbn1cbmZ1bmN0aW9uIGlzRmliZXJNb3VudGVkKGZpYmVyKSB7XG4gIHJldHVybiBnZXROZWFyZXN0TW91bnRlZEZpYmVyKGZpYmVyKSA9PT0gZmliZXI7XG59XG5mdW5jdGlvbiBpc01vdW50ZWQoY29tcG9uZW50KSB7XG4gIHtcbiAgICB2YXIgb3duZXIgPSBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50O1xuXG4gICAgaWYgKG93bmVyICE9PSBudWxsICYmIG93bmVyLnRhZyA9PT0gQ2xhc3NDb21wb25lbnQpIHtcbiAgICAgIHZhciBvd25lckZpYmVyID0gb3duZXI7XG4gICAgICB2YXIgaW5zdGFuY2UgPSBvd25lckZpYmVyLnN0YXRlTm9kZTtcblxuICAgICAgaWYgKCFpbnN0YW5jZS5fd2FybmVkQWJvdXRSZWZzSW5SZW5kZXIpIHtcbiAgICAgICAgZXJyb3IoJyVzIGlzIGFjY2Vzc2luZyBpc01vdW50ZWQgaW5zaWRlIGl0cyByZW5kZXIoKSBmdW5jdGlvbi4gJyArICdyZW5kZXIoKSBzaG91bGQgYmUgYSBwdXJlIGZ1bmN0aW9uIG9mIHByb3BzIGFuZCBzdGF0ZS4gSXQgc2hvdWxkICcgKyAnbmV2ZXIgYWNjZXNzIHNvbWV0aGluZyB0aGF0IHJlcXVpcmVzIHN0YWxlIGRhdGEgZnJvbSB0aGUgcHJldmlvdXMgJyArICdyZW5kZXIsIHN1Y2ggYXMgcmVmcy4gTW92ZSB0aGlzIGxvZ2ljIHRvIGNvbXBvbmVudERpZE1vdW50IGFuZCAnICsgJ2NvbXBvbmVudERpZFVwZGF0ZSBpbnN0ZWFkLicsIGdldENvbXBvbmVudE5hbWUob3duZXJGaWJlci50eXBlKSB8fCAnQSBjb21wb25lbnQnKTtcbiAgICAgIH1cblxuICAgICAgaW5zdGFuY2UuX3dhcm5lZEFib3V0UmVmc0luUmVuZGVyID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICB2YXIgZmliZXIgPSBnZXQoY29tcG9uZW50KTtcblxuICBpZiAoIWZpYmVyKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIGdldE5lYXJlc3RNb3VudGVkRmliZXIoZmliZXIpID09PSBmaWJlcjtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0SXNNb3VudGVkKGZpYmVyKSB7XG4gIGlmICghKGdldE5lYXJlc3RNb3VudGVkRmliZXIoZmliZXIpID09PSBmaWJlcikpIHtcbiAgICB7XG4gICAgICB0aHJvdyBFcnJvciggXCJVbmFibGUgdG8gZmluZCBub2RlIG9uIGFuIHVubW91bnRlZCBjb21wb25lbnQuXCIgKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZmluZEN1cnJlbnRGaWJlclVzaW5nU2xvd1BhdGgoZmliZXIpIHtcbiAgdmFyIGFsdGVybmF0ZSA9IGZpYmVyLmFsdGVybmF0ZTtcblxuICBpZiAoIWFsdGVybmF0ZSkge1xuICAgIC8vIElmIHRoZXJlIGlzIG5vIGFsdGVybmF0ZSwgdGhlbiB3ZSBvbmx5IG5lZWQgdG8gY2hlY2sgaWYgaXQgaXMgbW91bnRlZC5cbiAgICB2YXIgbmVhcmVzdE1vdW50ZWQgPSBnZXROZWFyZXN0TW91bnRlZEZpYmVyKGZpYmVyKTtcblxuICAgIGlmICghKG5lYXJlc3RNb3VudGVkICE9PSBudWxsKSkge1xuICAgICAge1xuICAgICAgICB0aHJvdyBFcnJvciggXCJVbmFibGUgdG8gZmluZCBub2RlIG9uIGFuIHVubW91bnRlZCBjb21wb25lbnQuXCIgKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAobmVhcmVzdE1vdW50ZWQgIT09IGZpYmVyKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gZmliZXI7XG4gIH0gLy8gSWYgd2UgaGF2ZSB0d28gcG9zc2libGUgYnJhbmNoZXMsIHdlJ2xsIHdhbGsgYmFja3dhcmRzIHVwIHRvIHRoZSByb290XG4gIC8vIHRvIHNlZSB3aGF0IHBhdGggdGhlIHJvb3QgcG9pbnRzIHRvLiBPbiB0aGUgd2F5IHdlIG1heSBoaXQgb25lIG9mIHRoZVxuICAvLyBzcGVjaWFsIGNhc2VzIGFuZCB3ZSdsbCBkZWFsIHdpdGggdGhlbS5cblxuXG4gIHZhciBhID0gZmliZXI7XG4gIHZhciBiID0gYWx0ZXJuYXRlO1xuXG4gIHdoaWxlICh0cnVlKSB7XG4gICAgdmFyIHBhcmVudEEgPSBhLnJldHVybjtcblxuICAgIGlmIChwYXJlbnRBID09PSBudWxsKSB7XG4gICAgICAvLyBXZSdyZSBhdCB0aGUgcm9vdC5cbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHZhciBwYXJlbnRCID0gcGFyZW50QS5hbHRlcm5hdGU7XG5cbiAgICBpZiAocGFyZW50QiA9PT0gbnVsbCkge1xuICAgICAgLy8gVGhlcmUgaXMgbm8gYWx0ZXJuYXRlLiBUaGlzIGlzIGFuIHVudXN1YWwgY2FzZS4gQ3VycmVudGx5LCBpdCBvbmx5XG4gICAgICAvLyBoYXBwZW5zIHdoZW4gYSBTdXNwZW5zZSBjb21wb25lbnQgaXMgaGlkZGVuLiBBbiBleHRyYSBmcmFnbWVudCBmaWJlclxuICAgICAgLy8gaXMgaW5zZXJ0ZWQgaW4gYmV0d2VlbiB0aGUgU3VzcGVuc2UgZmliZXIgYW5kIGl0cyBjaGlsZHJlbi4gU2tpcFxuICAgICAgLy8gb3ZlciB0aGlzIGV4dHJhIGZyYWdtZW50IGZpYmVyIGFuZCBwcm9jZWVkIHRvIHRoZSBuZXh0IHBhcmVudC5cbiAgICAgIHZhciBuZXh0UGFyZW50ID0gcGFyZW50QS5yZXR1cm47XG5cbiAgICAgIGlmIChuZXh0UGFyZW50ICE9PSBudWxsKSB7XG4gICAgICAgIGEgPSBiID0gbmV4dFBhcmVudDtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9IC8vIElmIHRoZXJlJ3Mgbm8gcGFyZW50LCB3ZSdyZSBhdCB0aGUgcm9vdC5cblxuXG4gICAgICBicmVhaztcbiAgICB9IC8vIElmIGJvdGggY29waWVzIG9mIHRoZSBwYXJlbnQgZmliZXIgcG9pbnQgdG8gdGhlIHNhbWUgY2hpbGQsIHdlIGNhblxuICAgIC8vIGFzc3VtZSB0aGF0IHRoZSBjaGlsZCBpcyBjdXJyZW50LiBUaGlzIGhhcHBlbnMgd2hlbiB3ZSBiYWlsb3V0IG9uIGxvd1xuICAgIC8vIHByaW9yaXR5OiB0aGUgYmFpbGVkIG91dCBmaWJlcidzIGNoaWxkIHJldXNlcyB0aGUgY3VycmVudCBjaGlsZC5cblxuXG4gICAgaWYgKHBhcmVudEEuY2hpbGQgPT09IHBhcmVudEIuY2hpbGQpIHtcbiAgICAgIHZhciBjaGlsZCA9IHBhcmVudEEuY2hpbGQ7XG5cbiAgICAgIHdoaWxlIChjaGlsZCkge1xuICAgICAgICBpZiAoY2hpbGQgPT09IGEpIHtcbiAgICAgICAgICAvLyBXZSd2ZSBkZXRlcm1pbmVkIHRoYXQgQSBpcyB0aGUgY3VycmVudCBicmFuY2guXG4gICAgICAgICAgYXNzZXJ0SXNNb3VudGVkKHBhcmVudEEpO1xuICAgICAgICAgIHJldHVybiBmaWJlcjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjaGlsZCA9PT0gYikge1xuICAgICAgICAgIC8vIFdlJ3ZlIGRldGVybWluZWQgdGhhdCBCIGlzIHRoZSBjdXJyZW50IGJyYW5jaC5cbiAgICAgICAgICBhc3NlcnRJc01vdW50ZWQocGFyZW50QSk7XG4gICAgICAgICAgcmV0dXJuIGFsdGVybmF0ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNoaWxkID0gY2hpbGQuc2libGluZztcbiAgICAgIH0gLy8gV2Ugc2hvdWxkIG5ldmVyIGhhdmUgYW4gYWx0ZXJuYXRlIGZvciBhbnkgbW91bnRpbmcgbm9kZS4gU28gdGhlIG9ubHlcbiAgICAgIC8vIHdheSB0aGlzIGNvdWxkIHBvc3NpYmx5IGhhcHBlbiBpcyBpZiB0aGlzIHdhcyB1bm1vdW50ZWQsIGlmIGF0IGFsbC5cblxuXG4gICAgICB7XG4gICAgICAgIHtcbiAgICAgICAgICB0aHJvdyBFcnJvciggXCJVbmFibGUgdG8gZmluZCBub2RlIG9uIGFuIHVubW91bnRlZCBjb21wb25lbnQuXCIgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChhLnJldHVybiAhPT0gYi5yZXR1cm4pIHtcbiAgICAgIC8vIFRoZSByZXR1cm4gcG9pbnRlciBvZiBBIGFuZCB0aGUgcmV0dXJuIHBvaW50ZXIgb2YgQiBwb2ludCB0byBkaWZmZXJlbnRcbiAgICAgIC8vIGZpYmVycy4gV2UgYXNzdW1lIHRoYXQgcmV0dXJuIHBvaW50ZXJzIG5ldmVyIGNyaXNzLWNyb3NzLCBzbyBBIG11c3RcbiAgICAgIC8vIGJlbG9uZyB0byB0aGUgY2hpbGQgc2V0IG9mIEEucmV0dXJuLCBhbmQgQiBtdXN0IGJlbG9uZyB0byB0aGUgY2hpbGRcbiAgICAgIC8vIHNldCBvZiBCLnJldHVybi5cbiAgICAgIGEgPSBwYXJlbnRBO1xuICAgICAgYiA9IHBhcmVudEI7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRoZSByZXR1cm4gcG9pbnRlcnMgcG9pbnQgdG8gdGhlIHNhbWUgZmliZXIuIFdlJ2xsIGhhdmUgdG8gdXNlIHRoZVxuICAgICAgLy8gZGVmYXVsdCwgc2xvdyBwYXRoOiBzY2FuIHRoZSBjaGlsZCBzZXRzIG9mIGVhY2ggcGFyZW50IGFsdGVybmF0ZSB0byBzZWVcbiAgICAgIC8vIHdoaWNoIGNoaWxkIGJlbG9uZ3MgdG8gd2hpY2ggc2V0LlxuICAgICAgLy9cbiAgICAgIC8vIFNlYXJjaCBwYXJlbnQgQSdzIGNoaWxkIHNldFxuICAgICAgdmFyIGRpZEZpbmRDaGlsZCA9IGZhbHNlO1xuICAgICAgdmFyIF9jaGlsZCA9IHBhcmVudEEuY2hpbGQ7XG5cbiAgICAgIHdoaWxlIChfY2hpbGQpIHtcbiAgICAgICAgaWYgKF9jaGlsZCA9PT0gYSkge1xuICAgICAgICAgIGRpZEZpbmRDaGlsZCA9IHRydWU7XG4gICAgICAgICAgYSA9IHBhcmVudEE7XG4gICAgICAgICAgYiA9IHBhcmVudEI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoX2NoaWxkID09PSBiKSB7XG4gICAgICAgICAgZGlkRmluZENoaWxkID0gdHJ1ZTtcbiAgICAgICAgICBiID0gcGFyZW50QTtcbiAgICAgICAgICBhID0gcGFyZW50QjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIF9jaGlsZCA9IF9jaGlsZC5zaWJsaW5nO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWRpZEZpbmRDaGlsZCkge1xuICAgICAgICAvLyBTZWFyY2ggcGFyZW50IEIncyBjaGlsZCBzZXRcbiAgICAgICAgX2NoaWxkID0gcGFyZW50Qi5jaGlsZDtcblxuICAgICAgICB3aGlsZSAoX2NoaWxkKSB7XG4gICAgICAgICAgaWYgKF9jaGlsZCA9PT0gYSkge1xuICAgICAgICAgICAgZGlkRmluZENoaWxkID0gdHJ1ZTtcbiAgICAgICAgICAgIGEgPSBwYXJlbnRCO1xuICAgICAgICAgICAgYiA9IHBhcmVudEE7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoX2NoaWxkID09PSBiKSB7XG4gICAgICAgICAgICBkaWRGaW5kQ2hpbGQgPSB0cnVlO1xuICAgICAgICAgICAgYiA9IHBhcmVudEI7XG4gICAgICAgICAgICBhID0gcGFyZW50QTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIF9jaGlsZCA9IF9jaGlsZC5zaWJsaW5nO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFkaWRGaW5kQ2hpbGQpIHtcbiAgICAgICAgICB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvciggXCJDaGlsZCB3YXMgbm90IGZvdW5kIGluIGVpdGhlciBwYXJlbnQgc2V0LiBUaGlzIGluZGljYXRlcyBhIGJ1ZyBpbiBSZWFjdCByZWxhdGVkIHRvIHRoZSByZXR1cm4gcG9pbnRlci4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCIgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIShhLmFsdGVybmF0ZSA9PT0gYikpIHtcbiAgICAgIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoIFwiUmV0dXJuIGZpYmVycyBzaG91bGQgYWx3YXlzIGJlIGVhY2ggb3RoZXJzJyBhbHRlcm5hdGVzLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiICk7XG4gICAgICB9XG4gICAgfVxuICB9IC8vIElmIHRoZSByb290IGlzIG5vdCBhIGhvc3QgY29udGFpbmVyLCB3ZSdyZSBpbiBhIGRpc2Nvbm5lY3RlZCB0cmVlLiBJLmUuXG4gIC8vIHVubW91bnRlZC5cblxuXG4gIGlmICghKGEudGFnID09PSBIb3N0Um9vdCkpIHtcbiAgICB7XG4gICAgICB0aHJvdyBFcnJvciggXCJVbmFibGUgdG8gZmluZCBub2RlIG9uIGFuIHVubW91bnRlZCBjb21wb25lbnQuXCIgKTtcbiAgICB9XG4gIH1cblxuICBpZiAoYS5zdGF0ZU5vZGUuY3VycmVudCA9PT0gYSkge1xuICAgIC8vIFdlJ3ZlIGRldGVybWluZWQgdGhhdCBBIGlzIHRoZSBjdXJyZW50IGJyYW5jaC5cbiAgICByZXR1cm4gZmliZXI7XG4gIH0gLy8gT3RoZXJ3aXNlIEIgaGFzIHRvIGJlIGN1cnJlbnQgYnJhbmNoLlxuXG5cbiAgcmV0dXJuIGFsdGVybmF0ZTtcbn1cbmZ1bmN0aW9uIGZpbmRDdXJyZW50SG9zdEZpYmVyKHBhcmVudCkge1xuICB2YXIgY3VycmVudFBhcmVudCA9IGZpbmRDdXJyZW50RmliZXJVc2luZ1Nsb3dQYXRoKHBhcmVudCk7XG5cbiAgaWYgKCFjdXJyZW50UGFyZW50KSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH0gLy8gTmV4dCB3ZSdsbCBkcmlsbCBkb3duIHRoaXMgY29tcG9uZW50IHRvIGZpbmQgdGhlIGZpcnN0IEhvc3RDb21wb25lbnQvVGV4dC5cblxuXG4gIHZhciBub2RlID0gY3VycmVudFBhcmVudDtcblxuICB3aGlsZSAodHJ1ZSkge1xuICAgIGlmIChub2RlLnRhZyA9PT0gSG9zdENvbXBvbmVudCB8fCBub2RlLnRhZyA9PT0gSG9zdFRleHQpIHtcbiAgICAgIHJldHVybiBub2RlO1xuICAgIH0gZWxzZSBpZiAobm9kZS5jaGlsZCkge1xuICAgICAgbm9kZS5jaGlsZC5yZXR1cm4gPSBub2RlO1xuICAgICAgbm9kZSA9IG5vZGUuY2hpbGQ7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAobm9kZSA9PT0gY3VycmVudFBhcmVudCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgd2hpbGUgKCFub2RlLnNpYmxpbmcpIHtcbiAgICAgIGlmICghbm9kZS5yZXR1cm4gfHwgbm9kZS5yZXR1cm4gPT09IGN1cnJlbnRQYXJlbnQpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIG5vZGUgPSBub2RlLnJldHVybjtcbiAgICB9XG5cbiAgICBub2RlLnNpYmxpbmcucmV0dXJuID0gbm9kZS5yZXR1cm47XG4gICAgbm9kZSA9IG5vZGUuc2libGluZztcbiAgfSAvLyBGbG93IG5lZWRzIHRoZSByZXR1cm4gbnVsbCBoZXJlLCBidXQgRVNMaW50IGNvbXBsYWlucyBhYm91dCBpdC5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVucmVhY2hhYmxlXG5cblxuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGZpbmRDdXJyZW50SG9zdEZpYmVyV2l0aE5vUG9ydGFscyhwYXJlbnQpIHtcbiAgdmFyIGN1cnJlbnRQYXJlbnQgPSBmaW5kQ3VycmVudEZpYmVyVXNpbmdTbG93UGF0aChwYXJlbnQpO1xuXG4gIGlmICghY3VycmVudFBhcmVudCkge1xuICAgIHJldHVybiBudWxsO1xuICB9IC8vIE5leHQgd2UnbGwgZHJpbGwgZG93biB0aGlzIGNvbXBvbmVudCB0byBmaW5kIHRoZSBmaXJzdCBIb3N0Q29tcG9uZW50L1RleHQuXG5cblxuICB2YXIgbm9kZSA9IGN1cnJlbnRQYXJlbnQ7XG5cbiAgd2hpbGUgKHRydWUpIHtcbiAgICBpZiAobm9kZS50YWcgPT09IEhvc3RDb21wb25lbnQgfHwgbm9kZS50YWcgPT09IEhvc3RUZXh0IHx8IGVuYWJsZUZ1bmRhbWVudGFsQVBJICkge1xuICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfSBlbHNlIGlmIChub2RlLmNoaWxkICYmIG5vZGUudGFnICE9PSBIb3N0UG9ydGFsKSB7XG4gICAgICBub2RlLmNoaWxkLnJldHVybiA9IG5vZGU7XG4gICAgICBub2RlID0gbm9kZS5jaGlsZDtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmIChub2RlID09PSBjdXJyZW50UGFyZW50KSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB3aGlsZSAoIW5vZGUuc2libGluZykge1xuICAgICAgaWYgKCFub2RlLnJldHVybiB8fCBub2RlLnJldHVybiA9PT0gY3VycmVudFBhcmVudCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgbm9kZSA9IG5vZGUucmV0dXJuO1xuICAgIH1cblxuICAgIG5vZGUuc2libGluZy5yZXR1cm4gPSBub2RlLnJldHVybjtcbiAgICBub2RlID0gbm9kZS5zaWJsaW5nO1xuICB9IC8vIEZsb3cgbmVlZHMgdGhlIHJldHVybiBudWxsIGhlcmUsIGJ1dCBFU0xpbnQgY29tcGxhaW5zIGFib3V0IGl0LlxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5yZWFjaGFibGVcblxuXG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gZG9lc0ZpYmVyQ29udGFpbihwYXJlbnRGaWJlciwgY2hpbGRGaWJlcikge1xuICB2YXIgbm9kZSA9IGNoaWxkRmliZXI7XG4gIHZhciBwYXJlbnRGaWJlckFsdGVybmF0ZSA9IHBhcmVudEZpYmVyLmFsdGVybmF0ZTtcblxuICB3aGlsZSAobm9kZSAhPT0gbnVsbCkge1xuICAgIGlmIChub2RlID09PSBwYXJlbnRGaWJlciB8fCBub2RlID09PSBwYXJlbnRGaWJlckFsdGVybmF0ZSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgbm9kZSA9IG5vZGUucmV0dXJuO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG52YXIgYXR0ZW1wdFVzZXJCbG9ja2luZ0h5ZHJhdGlvbjtcbmZ1bmN0aW9uIHNldEF0dGVtcHRVc2VyQmxvY2tpbmdIeWRyYXRpb24oZm4pIHtcbiAgYXR0ZW1wdFVzZXJCbG9ja2luZ0h5ZHJhdGlvbiA9IGZuO1xufVxudmFyIGF0dGVtcHRDb250aW51b3VzSHlkcmF0aW9uO1xuZnVuY3Rpb24gc2V0QXR0ZW1wdENvbnRpbnVvdXNIeWRyYXRpb24oZm4pIHtcbiAgYXR0ZW1wdENvbnRpbnVvdXNIeWRyYXRpb24gPSBmbjtcbn1cbnZhciBhdHRlbXB0SHlkcmF0aW9uQXRDdXJyZW50UHJpb3JpdHk7XG5mdW5jdGlvbiBzZXRBdHRlbXB0SHlkcmF0aW9uQXRDdXJyZW50UHJpb3JpdHkoZm4pIHtcbiAgYXR0ZW1wdEh5ZHJhdGlvbkF0Q3VycmVudFByaW9yaXR5ID0gZm47XG59XG52YXIgYXR0ZW1wdEh5ZHJhdGlvbkF0UHJpb3JpdHk7XG5mdW5jdGlvbiBzZXRBdHRlbXB0SHlkcmF0aW9uQXRQcmlvcml0eShmbikge1xuICBhdHRlbXB0SHlkcmF0aW9uQXRQcmlvcml0eSA9IGZuO1xufSAvLyBUT0RPOiBVcGdyYWRlIHRoaXMgZGVmaW5pdGlvbiBvbmNlIHdlJ3JlIG9uIGEgbmV3ZXIgdmVyc2lvbiBvZiBGbG93IHRoYXRcbnZhciBoYXNTY2hlZHVsZWRSZXBsYXlBdHRlbXB0ID0gZmFsc2U7IC8vIFRoZSBxdWV1ZSBvZiBkaXNjcmV0ZSBldmVudHMgdG8gYmUgcmVwbGF5ZWQuXG5cbnZhciBxdWV1ZWREaXNjcmV0ZUV2ZW50cyA9IFtdOyAvLyBJbmRpY2F0ZXMgaWYgYW55IGNvbnRpbnVvdXMgZXZlbnQgdGFyZ2V0cyBhcmUgbm9uLW51bGwgZm9yIGVhcmx5IGJhaWxvdXQuXG4vLyBpZiB0aGUgbGFzdCB0YXJnZXQgd2FzIGRlaHlkcmF0ZWQuXG5cbnZhciBxdWV1ZWRGb2N1cyA9IG51bGw7XG52YXIgcXVldWVkRHJhZyA9IG51bGw7XG52YXIgcXVldWVkTW91c2UgPSBudWxsOyAvLyBGb3IgcG9pbnRlciBldmVudHMgdGhlcmUgY2FuIGJlIG9uZSBsYXRlc3QgZXZlbnQgcGVyIHBvaW50ZXJJZC5cblxudmFyIHF1ZXVlZFBvaW50ZXJzID0gbmV3IE1hcCgpO1xudmFyIHF1ZXVlZFBvaW50ZXJDYXB0dXJlcyA9IG5ldyBNYXAoKTsgLy8gV2UgY291bGQgY29uc2lkZXIgcmVwbGF5aW5nIHNlbGVjdGlvbmNoYW5nZSBhbmQgdG91Y2htb3ZlcyB0b28uXG5cbnZhciBxdWV1ZWRFeHBsaWNpdEh5ZHJhdGlvblRhcmdldHMgPSBbXTtcbmZ1bmN0aW9uIGhhc1F1ZXVlZERpc2NyZXRlRXZlbnRzKCkge1xuICByZXR1cm4gcXVldWVkRGlzY3JldGVFdmVudHMubGVuZ3RoID4gMDtcbn1cbnZhciBkaXNjcmV0ZVJlcGxheWFibGVFdmVudHMgPSBbJ21vdXNlZG93bicsICdtb3VzZXVwJywgJ3RvdWNoY2FuY2VsJywgJ3RvdWNoZW5kJywgJ3RvdWNoc3RhcnQnLCAnYXV4Y2xpY2snLCAnZGJsY2xpY2snLCAncG9pbnRlcmNhbmNlbCcsICdwb2ludGVyZG93bicsICdwb2ludGVydXAnLCAnZHJhZ2VuZCcsICdkcmFnc3RhcnQnLCAnZHJvcCcsICdjb21wb3NpdGlvbmVuZCcsICdjb21wb3NpdGlvbnN0YXJ0JywgJ2tleWRvd24nLCAna2V5cHJlc3MnLCAna2V5dXAnLCAnaW5wdXQnLCAndGV4dElucHV0JywgLy8gSW50ZW50aW9uYWxseSBjYW1lbENhc2Vcbidjb3B5JywgJ2N1dCcsICdwYXN0ZScsICdjbGljaycsICdjaGFuZ2UnLCAnY29udGV4dG1lbnUnLCAncmVzZXQnLCAnc3VibWl0J107XG5mdW5jdGlvbiBpc1JlcGxheWFibGVEaXNjcmV0ZUV2ZW50KGV2ZW50VHlwZSkge1xuICByZXR1cm4gZGlzY3JldGVSZXBsYXlhYmxlRXZlbnRzLmluZGV4T2YoZXZlbnRUeXBlKSA+IC0xO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVRdWV1ZWRSZXBsYXlhYmxlRXZlbnQoYmxvY2tlZE9uLCBkb21FdmVudE5hbWUsIGV2ZW50U3lzdGVtRmxhZ3MsIHRhcmdldENvbnRhaW5lciwgbmF0aXZlRXZlbnQpIHtcbiAgcmV0dXJuIHtcbiAgICBibG9ja2VkT246IGJsb2NrZWRPbixcbiAgICBkb21FdmVudE5hbWU6IGRvbUV2ZW50TmFtZSxcbiAgICBldmVudFN5c3RlbUZsYWdzOiBldmVudFN5c3RlbUZsYWdzIHwgSVNfUkVQTEFZRUQsXG4gICAgbmF0aXZlRXZlbnQ6IG5hdGl2ZUV2ZW50LFxuICAgIHRhcmdldENvbnRhaW5lcnM6IFt0YXJnZXRDb250YWluZXJdXG4gIH07XG59XG5cbmZ1bmN0aW9uIHF1ZXVlRGlzY3JldGVFdmVudChibG9ja2VkT24sIGRvbUV2ZW50TmFtZSwgZXZlbnRTeXN0ZW1GbGFncywgdGFyZ2V0Q29udGFpbmVyLCBuYXRpdmVFdmVudCkge1xuICB2YXIgcXVldWVkRXZlbnQgPSBjcmVhdGVRdWV1ZWRSZXBsYXlhYmxlRXZlbnQoYmxvY2tlZE9uLCBkb21FdmVudE5hbWUsIGV2ZW50U3lzdGVtRmxhZ3MsIHRhcmdldENvbnRhaW5lciwgbmF0aXZlRXZlbnQpO1xuICBxdWV1ZWREaXNjcmV0ZUV2ZW50cy5wdXNoKHF1ZXVlZEV2ZW50KTtcbn0gLy8gUmVzZXRzIHRoZSByZXBsYXlpbmcgZm9yIHRoaXMgdHlwZSBvZiBjb250aW51b3VzIGV2ZW50IHRvIG5vIGV2ZW50LlxuXG5mdW5jdGlvbiBjbGVhcklmQ29udGludW91c0V2ZW50KGRvbUV2ZW50TmFtZSwgbmF0aXZlRXZlbnQpIHtcbiAgc3dpdGNoIChkb21FdmVudE5hbWUpIHtcbiAgICBjYXNlICdmb2N1c2luJzpcbiAgICBjYXNlICdmb2N1c291dCc6XG4gICAgICBxdWV1ZWRGb2N1cyA9IG51bGw7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ2RyYWdlbnRlcic6XG4gICAgY2FzZSAnZHJhZ2xlYXZlJzpcbiAgICAgIHF1ZXVlZERyYWcgPSBudWxsO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdtb3VzZW92ZXInOlxuICAgIGNhc2UgJ21vdXNlb3V0JzpcbiAgICAgIHF1ZXVlZE1vdXNlID0gbnVsbDtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAncG9pbnRlcm92ZXInOlxuICAgIGNhc2UgJ3BvaW50ZXJvdXQnOlxuICAgICAge1xuICAgICAgICB2YXIgcG9pbnRlcklkID0gbmF0aXZlRXZlbnQucG9pbnRlcklkO1xuICAgICAgICBxdWV1ZWRQb2ludGVycy5kZWxldGUocG9pbnRlcklkKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICBjYXNlICdnb3Rwb2ludGVyY2FwdHVyZSc6XG4gICAgY2FzZSAnbG9zdHBvaW50ZXJjYXB0dXJlJzpcbiAgICAgIHtcbiAgICAgICAgdmFyIF9wb2ludGVySWQgPSBuYXRpdmVFdmVudC5wb2ludGVySWQ7XG4gICAgICAgIHF1ZXVlZFBvaW50ZXJDYXB0dXJlcy5kZWxldGUoX3BvaW50ZXJJZCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGFjY3VtdWxhdGVPckNyZWF0ZUNvbnRpbnVvdXNRdWV1ZWRSZXBsYXlhYmxlRXZlbnQoZXhpc3RpbmdRdWV1ZWRFdmVudCwgYmxvY2tlZE9uLCBkb21FdmVudE5hbWUsIGV2ZW50U3lzdGVtRmxhZ3MsIHRhcmdldENvbnRhaW5lciwgbmF0aXZlRXZlbnQpIHtcbiAgaWYgKGV4aXN0aW5nUXVldWVkRXZlbnQgPT09IG51bGwgfHwgZXhpc3RpbmdRdWV1ZWRFdmVudC5uYXRpdmVFdmVudCAhPT0gbmF0aXZlRXZlbnQpIHtcbiAgICB2YXIgcXVldWVkRXZlbnQgPSBjcmVhdGVRdWV1ZWRSZXBsYXlhYmxlRXZlbnQoYmxvY2tlZE9uLCBkb21FdmVudE5hbWUsIGV2ZW50U3lzdGVtRmxhZ3MsIHRhcmdldENvbnRhaW5lciwgbmF0aXZlRXZlbnQpO1xuXG4gICAgaWYgKGJsb2NrZWRPbiAhPT0gbnVsbCkge1xuICAgICAgdmFyIF9maWJlcjIgPSBnZXRJbnN0YW5jZUZyb21Ob2RlKGJsb2NrZWRPbik7XG5cbiAgICAgIGlmIChfZmliZXIyICE9PSBudWxsKSB7XG4gICAgICAgIC8vIEF0dGVtcHQgdG8gaW5jcmVhc2UgdGhlIHByaW9yaXR5IG9mIHRoaXMgdGFyZ2V0LlxuICAgICAgICBhdHRlbXB0Q29udGludW91c0h5ZHJhdGlvbihfZmliZXIyKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcXVldWVkRXZlbnQ7XG4gIH0gLy8gSWYgd2UgaGF2ZSBhbHJlYWR5IHF1ZXVlZCB0aGlzIGV4YWN0IGV2ZW50LCB0aGVuIGl0J3MgYmVjYXVzZVxuICAvLyB0aGUgZGlmZmVyZW50IGV2ZW50IHN5c3RlbXMgaGF2ZSBkaWZmZXJlbnQgRE9NIGV2ZW50IGxpc3RlbmVycy5cbiAgLy8gV2UgY2FuIGFjY3VtdWxhdGUgdGhlIGZsYWdzLCBhbmQgdGhlIHRhcmdldENvbnRhaW5lcnMsIGFuZFxuICAvLyBzdG9yZSBhIHNpbmdsZSBldmVudCB0byBiZSByZXBsYXllZC5cblxuXG4gIGV4aXN0aW5nUXVldWVkRXZlbnQuZXZlbnRTeXN0ZW1GbGFncyB8PSBldmVudFN5c3RlbUZsYWdzO1xuICB2YXIgdGFyZ2V0Q29udGFpbmVycyA9IGV4aXN0aW5nUXVldWVkRXZlbnQudGFyZ2V0Q29udGFpbmVycztcblxuICBpZiAodGFyZ2V0Q29udGFpbmVyICE9PSBudWxsICYmIHRhcmdldENvbnRhaW5lcnMuaW5kZXhPZih0YXJnZXRDb250YWluZXIpID09PSAtMSkge1xuICAgIHRhcmdldENvbnRhaW5lcnMucHVzaCh0YXJnZXRDb250YWluZXIpO1xuICB9XG5cbiAgcmV0dXJuIGV4aXN0aW5nUXVldWVkRXZlbnQ7XG59XG5cbmZ1bmN0aW9uIHF1ZXVlSWZDb250aW51b3VzRXZlbnQoYmxvY2tlZE9uLCBkb21FdmVudE5hbWUsIGV2ZW50U3lzdGVtRmxhZ3MsIHRhcmdldENvbnRhaW5lciwgbmF0aXZlRXZlbnQpIHtcbiAgLy8gVGhlc2Ugc2V0IHJlbGF0ZWRUYXJnZXQgdG8gbnVsbCBiZWNhdXNlIHRoZSByZXBsYXllZCBldmVudCB3aWxsIGJlIHRyZWF0ZWQgYXMgaWYgd2VcbiAgLy8gbW92ZWQgZnJvbSBvdXRzaWRlIHRoZSB3aW5kb3cgKG5vIHRhcmdldCkgb250byB0aGUgdGFyZ2V0IG9uY2UgaXQgaHlkcmF0ZXMuXG4gIC8vIEluc3RlYWQgb2YgbXV0YXRpbmcgd2UgY291bGQgY2xvbmUgdGhlIGV2ZW50LlxuICBzd2l0Y2ggKGRvbUV2ZW50TmFtZSkge1xuICAgIGNhc2UgJ2ZvY3VzaW4nOlxuICAgICAge1xuICAgICAgICB2YXIgZm9jdXNFdmVudCA9IG5hdGl2ZUV2ZW50O1xuICAgICAgICBxdWV1ZWRGb2N1cyA9IGFjY3VtdWxhdGVPckNyZWF0ZUNvbnRpbnVvdXNRdWV1ZWRSZXBsYXlhYmxlRXZlbnQocXVldWVkRm9jdXMsIGJsb2NrZWRPbiwgZG9tRXZlbnROYW1lLCBldmVudFN5c3RlbUZsYWdzLCB0YXJnZXRDb250YWluZXIsIGZvY3VzRXZlbnQpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgIGNhc2UgJ2RyYWdlbnRlcic6XG4gICAgICB7XG4gICAgICAgIHZhciBkcmFnRXZlbnQgPSBuYXRpdmVFdmVudDtcbiAgICAgICAgcXVldWVkRHJhZyA9IGFjY3VtdWxhdGVPckNyZWF0ZUNvbnRpbnVvdXNRdWV1ZWRSZXBsYXlhYmxlRXZlbnQocXVldWVkRHJhZywgYmxvY2tlZE9uLCBkb21FdmVudE5hbWUsIGV2ZW50U3lzdGVtRmxhZ3MsIHRhcmdldENvbnRhaW5lciwgZHJhZ0V2ZW50KTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICBjYXNlICdtb3VzZW92ZXInOlxuICAgICAge1xuICAgICAgICB2YXIgbW91c2VFdmVudCA9IG5hdGl2ZUV2ZW50O1xuICAgICAgICBxdWV1ZWRNb3VzZSA9IGFjY3VtdWxhdGVPckNyZWF0ZUNvbnRpbnVvdXNRdWV1ZWRSZXBsYXlhYmxlRXZlbnQocXVldWVkTW91c2UsIGJsb2NrZWRPbiwgZG9tRXZlbnROYW1lLCBldmVudFN5c3RlbUZsYWdzLCB0YXJnZXRDb250YWluZXIsIG1vdXNlRXZlbnQpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgIGNhc2UgJ3BvaW50ZXJvdmVyJzpcbiAgICAgIHtcbiAgICAgICAgdmFyIHBvaW50ZXJFdmVudCA9IG5hdGl2ZUV2ZW50O1xuICAgICAgICB2YXIgcG9pbnRlcklkID0gcG9pbnRlckV2ZW50LnBvaW50ZXJJZDtcbiAgICAgICAgcXVldWVkUG9pbnRlcnMuc2V0KHBvaW50ZXJJZCwgYWNjdW11bGF0ZU9yQ3JlYXRlQ29udGludW91c1F1ZXVlZFJlcGxheWFibGVFdmVudChxdWV1ZWRQb2ludGVycy5nZXQocG9pbnRlcklkKSB8fCBudWxsLCBibG9ja2VkT24sIGRvbUV2ZW50TmFtZSwgZXZlbnRTeXN0ZW1GbGFncywgdGFyZ2V0Q29udGFpbmVyLCBwb2ludGVyRXZlbnQpKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICBjYXNlICdnb3Rwb2ludGVyY2FwdHVyZSc6XG4gICAgICB7XG4gICAgICAgIHZhciBfcG9pbnRlckV2ZW50ID0gbmF0aXZlRXZlbnQ7XG4gICAgICAgIHZhciBfcG9pbnRlcklkMiA9IF9wb2ludGVyRXZlbnQucG9pbnRlcklkO1xuICAgICAgICBxdWV1ZWRQb2ludGVyQ2FwdHVyZXMuc2V0KF9wb2ludGVySWQyLCBhY2N1bXVsYXRlT3JDcmVhdGVDb250aW51b3VzUXVldWVkUmVwbGF5YWJsZUV2ZW50KHF1ZXVlZFBvaW50ZXJDYXB0dXJlcy5nZXQoX3BvaW50ZXJJZDIpIHx8IG51bGwsIGJsb2NrZWRPbiwgZG9tRXZlbnROYW1lLCBldmVudFN5c3RlbUZsYWdzLCB0YXJnZXRDb250YWluZXIsIF9wb2ludGVyRXZlbnQpKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59IC8vIENoZWNrIGlmIHRoaXMgdGFyZ2V0IGlzIHVuYmxvY2tlZC4gUmV0dXJucyB0cnVlIGlmIGl0J3MgdW5ibG9ja2VkLlxuXG5mdW5jdGlvbiBhdHRlbXB0RXhwbGljaXRIeWRyYXRpb25UYXJnZXQocXVldWVkVGFyZ2V0KSB7XG4gIC8vIFRPRE86IFRoaXMgZnVuY3Rpb24gc2hhcmVzIGEgbG90IG9mIGxvZ2ljIHdpdGggYXR0ZW1wdFRvRGlzcGF0Y2hFdmVudC5cbiAgLy8gVHJ5IHRvIHVuaWZ5IHRoZW0uIEl0J3MgYSBiaXQgdHJpY2t5IHNpbmNlIGl0IHdvdWxkIHJlcXVpcmUgdHdvIHJldHVyblxuICAvLyB2YWx1ZXMuXG4gIHZhciB0YXJnZXRJbnN0ID0gZ2V0Q2xvc2VzdEluc3RhbmNlRnJvbU5vZGUocXVldWVkVGFyZ2V0LnRhcmdldCk7XG5cbiAgaWYgKHRhcmdldEluc3QgIT09IG51bGwpIHtcbiAgICB2YXIgbmVhcmVzdE1vdW50ZWQgPSBnZXROZWFyZXN0TW91bnRlZEZpYmVyKHRhcmdldEluc3QpO1xuXG4gICAgaWYgKG5lYXJlc3RNb3VudGVkICE9PSBudWxsKSB7XG4gICAgICB2YXIgdGFnID0gbmVhcmVzdE1vdW50ZWQudGFnO1xuXG4gICAgICBpZiAodGFnID09PSBTdXNwZW5zZUNvbXBvbmVudCkge1xuICAgICAgICB2YXIgaW5zdGFuY2UgPSBnZXRTdXNwZW5zZUluc3RhbmNlRnJvbUZpYmVyKG5lYXJlc3RNb3VudGVkKTtcblxuICAgICAgICBpZiAoaW5zdGFuY2UgIT09IG51bGwpIHtcbiAgICAgICAgICAvLyBXZSdyZSBibG9ja2VkIG9uIGh5ZHJhdGluZyB0aGlzIGJvdW5kYXJ5LlxuICAgICAgICAgIC8vIEluY3JlYXNlIGl0cyBwcmlvcml0eS5cbiAgICAgICAgICBxdWV1ZWRUYXJnZXQuYmxvY2tlZE9uID0gaW5zdGFuY2U7XG4gICAgICAgICAgYXR0ZW1wdEh5ZHJhdGlvbkF0UHJpb3JpdHkocXVldWVkVGFyZ2V0LmxhbmVQcmlvcml0eSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgU2NoZWR1bGVyLnVuc3RhYmxlX3J1bldpdGhQcmlvcml0eShxdWV1ZWRUYXJnZXQucHJpb3JpdHksIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgYXR0ZW1wdEh5ZHJhdGlvbkF0Q3VycmVudFByaW9yaXR5KG5lYXJlc3RNb3VudGVkKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0YWcgPT09IEhvc3RSb290KSB7XG4gICAgICAgIHZhciByb290ID0gbmVhcmVzdE1vdW50ZWQuc3RhdGVOb2RlO1xuXG4gICAgICAgIGlmIChyb290Lmh5ZHJhdGUpIHtcbiAgICAgICAgICBxdWV1ZWRUYXJnZXQuYmxvY2tlZE9uID0gZ2V0Q29udGFpbmVyRnJvbUZpYmVyKG5lYXJlc3RNb3VudGVkKTsgLy8gV2UgZG9uJ3QgY3VycmVudGx5IGhhdmUgYSB3YXkgdG8gaW5jcmVhc2UgdGhlIHByaW9yaXR5IG9mXG4gICAgICAgICAgLy8gYSByb290IG90aGVyIHRoYW4gc3luYy5cblxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHF1ZXVlZFRhcmdldC5ibG9ja2VkT24gPSBudWxsO1xufVxuXG5mdW5jdGlvbiBhdHRlbXB0UmVwbGF5Q29udGludW91c1F1ZXVlZEV2ZW50KHF1ZXVlZEV2ZW50KSB7XG4gIGlmIChxdWV1ZWRFdmVudC5ibG9ja2VkT24gIT09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgdGFyZ2V0Q29udGFpbmVycyA9IHF1ZXVlZEV2ZW50LnRhcmdldENvbnRhaW5lcnM7XG5cbiAgd2hpbGUgKHRhcmdldENvbnRhaW5lcnMubGVuZ3RoID4gMCkge1xuICAgIHZhciB0YXJnZXRDb250YWluZXIgPSB0YXJnZXRDb250YWluZXJzWzBdO1xuICAgIHZhciBuZXh0QmxvY2tlZE9uID0gYXR0ZW1wdFRvRGlzcGF0Y2hFdmVudChxdWV1ZWRFdmVudC5kb21FdmVudE5hbWUsIHF1ZXVlZEV2ZW50LmV2ZW50U3lzdGVtRmxhZ3MsIHRhcmdldENvbnRhaW5lciwgcXVldWVkRXZlbnQubmF0aXZlRXZlbnQpO1xuXG4gICAgaWYgKG5leHRCbG9ja2VkT24gIT09IG51bGwpIHtcbiAgICAgIC8vIFdlJ3JlIHN0aWxsIGJsb2NrZWQuIFRyeSBhZ2FpbiBsYXRlci5cbiAgICAgIHZhciBfZmliZXIzID0gZ2V0SW5zdGFuY2VGcm9tTm9kZShuZXh0QmxvY2tlZE9uKTtcblxuICAgICAgaWYgKF9maWJlcjMgIT09IG51bGwpIHtcbiAgICAgICAgYXR0ZW1wdENvbnRpbnVvdXNIeWRyYXRpb24oX2ZpYmVyMyk7XG4gICAgICB9XG5cbiAgICAgIHF1ZXVlZEV2ZW50LmJsb2NrZWRPbiA9IG5leHRCbG9ja2VkT247XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSAvLyBUaGlzIHRhcmdldCBjb250YWluZXIgd2FzIHN1Y2Nlc3NmdWxseSBkaXNwYXRjaGVkLiBUcnkgdGhlIG5leHQuXG5cblxuICAgIHRhcmdldENvbnRhaW5lcnMuc2hpZnQoKTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBhdHRlbXB0UmVwbGF5Q29udGludW91c1F1ZXVlZEV2ZW50SW5NYXAocXVldWVkRXZlbnQsIGtleSwgbWFwKSB7XG4gIGlmIChhdHRlbXB0UmVwbGF5Q29udGludW91c1F1ZXVlZEV2ZW50KHF1ZXVlZEV2ZW50KSkge1xuICAgIG1hcC5kZWxldGUoa2V5KTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZXBsYXlVbmJsb2NrZWRFdmVudHMoKSB7XG4gIGhhc1NjaGVkdWxlZFJlcGxheUF0dGVtcHQgPSBmYWxzZTsgLy8gRmlyc3QgcmVwbGF5IGRpc2NyZXRlIGV2ZW50cy5cblxuICB3aGlsZSAocXVldWVkRGlzY3JldGVFdmVudHMubGVuZ3RoID4gMCkge1xuICAgIHZhciBuZXh0RGlzY3JldGVFdmVudCA9IHF1ZXVlZERpc2NyZXRlRXZlbnRzWzBdO1xuXG4gICAgaWYgKG5leHREaXNjcmV0ZUV2ZW50LmJsb2NrZWRPbiAhPT0gbnVsbCkge1xuICAgICAgLy8gV2UncmUgc3RpbGwgYmxvY2tlZC5cbiAgICAgIC8vIEluY3JlYXNlIHRoZSBwcmlvcml0eSBvZiB0aGlzIGJvdW5kYXJ5IHRvIHVuYmxvY2tcbiAgICAgIC8vIHRoZSBuZXh0IGRpc2NyZXRlIGV2ZW50LlxuICAgICAgdmFyIF9maWJlcjQgPSBnZXRJbnN0YW5jZUZyb21Ob2RlKG5leHREaXNjcmV0ZUV2ZW50LmJsb2NrZWRPbik7XG5cbiAgICAgIGlmIChfZmliZXI0ICE9PSBudWxsKSB7XG4gICAgICAgIGF0dGVtcHRVc2VyQmxvY2tpbmdIeWRyYXRpb24oX2ZpYmVyNCk7XG4gICAgICB9XG5cbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHZhciB0YXJnZXRDb250YWluZXJzID0gbmV4dERpc2NyZXRlRXZlbnQudGFyZ2V0Q29udGFpbmVycztcblxuICAgIHdoaWxlICh0YXJnZXRDb250YWluZXJzLmxlbmd0aCA+IDApIHtcbiAgICAgIHZhciB0YXJnZXRDb250YWluZXIgPSB0YXJnZXRDb250YWluZXJzWzBdO1xuICAgICAgdmFyIG5leHRCbG9ja2VkT24gPSBhdHRlbXB0VG9EaXNwYXRjaEV2ZW50KG5leHREaXNjcmV0ZUV2ZW50LmRvbUV2ZW50TmFtZSwgbmV4dERpc2NyZXRlRXZlbnQuZXZlbnRTeXN0ZW1GbGFncywgdGFyZ2V0Q29udGFpbmVyLCBuZXh0RGlzY3JldGVFdmVudC5uYXRpdmVFdmVudCk7XG5cbiAgICAgIGlmIChuZXh0QmxvY2tlZE9uICE9PSBudWxsKSB7XG4gICAgICAgIC8vIFdlJ3JlIHN0aWxsIGJsb2NrZWQuIFRyeSBhZ2FpbiBsYXRlci5cbiAgICAgICAgbmV4dERpc2NyZXRlRXZlbnQuYmxvY2tlZE9uID0gbmV4dEJsb2NrZWRPbjtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9IC8vIFRoaXMgdGFyZ2V0IGNvbnRhaW5lciB3YXMgc3VjY2Vzc2Z1bGx5IGRpc3BhdGNoZWQuIFRyeSB0aGUgbmV4dC5cblxuXG4gICAgICB0YXJnZXRDb250YWluZXJzLnNoaWZ0KCk7XG4gICAgfVxuXG4gICAgaWYgKG5leHREaXNjcmV0ZUV2ZW50LmJsb2NrZWRPbiA9PT0gbnVsbCkge1xuICAgICAgLy8gV2UndmUgc3VjY2Vzc2Z1bGx5IHJlcGxheWVkIHRoZSBmaXJzdCBldmVudC4gTGV0J3MgdHJ5IHRoZSBuZXh0IG9uZS5cbiAgICAgIHF1ZXVlZERpc2NyZXRlRXZlbnRzLnNoaWZ0KCk7XG4gICAgfVxuICB9IC8vIE5leHQgcmVwbGF5IGFueSBjb250aW51b3VzIGV2ZW50cy5cblxuXG4gIGlmIChxdWV1ZWRGb2N1cyAhPT0gbnVsbCAmJiBhdHRlbXB0UmVwbGF5Q29udGludW91c1F1ZXVlZEV2ZW50KHF1ZXVlZEZvY3VzKSkge1xuICAgIHF1ZXVlZEZvY3VzID0gbnVsbDtcbiAgfVxuXG4gIGlmIChxdWV1ZWREcmFnICE9PSBudWxsICYmIGF0dGVtcHRSZXBsYXlDb250aW51b3VzUXVldWVkRXZlbnQocXVldWVkRHJhZykpIHtcbiAgICBxdWV1ZWREcmFnID0gbnVsbDtcbiAgfVxuXG4gIGlmIChxdWV1ZWRNb3VzZSAhPT0gbnVsbCAmJiBhdHRlbXB0UmVwbGF5Q29udGludW91c1F1ZXVlZEV2ZW50KHF1ZXVlZE1vdXNlKSkge1xuICAgIHF1ZXVlZE1vdXNlID0gbnVsbDtcbiAgfVxuXG4gIHF1ZXVlZFBvaW50ZXJzLmZvckVhY2goYXR0ZW1wdFJlcGxheUNvbnRpbnVvdXNRdWV1ZWRFdmVudEluTWFwKTtcbiAgcXVldWVkUG9pbnRlckNhcHR1cmVzLmZvckVhY2goYXR0ZW1wdFJlcGxheUNvbnRpbnVvdXNRdWV1ZWRFdmVudEluTWFwKTtcbn1cblxuZnVuY3Rpb24gc2NoZWR1bGVDYWxsYmFja0lmVW5ibG9ja2VkKHF1ZXVlZEV2ZW50LCB1bmJsb2NrZWQpIHtcbiAgaWYgKHF1ZXVlZEV2ZW50LmJsb2NrZWRPbiA9PT0gdW5ibG9ja2VkKSB7XG4gICAgcXVldWVkRXZlbnQuYmxvY2tlZE9uID0gbnVsbDtcblxuICAgIGlmICghaGFzU2NoZWR1bGVkUmVwbGF5QXR0ZW1wdCkge1xuICAgICAgaGFzU2NoZWR1bGVkUmVwbGF5QXR0ZW1wdCA9IHRydWU7IC8vIFNjaGVkdWxlIGEgY2FsbGJhY2sgdG8gYXR0ZW1wdCByZXBsYXlpbmcgYXMgbWFueSBldmVudHMgYXMgYXJlXG4gICAgICAvLyBub3cgdW5ibG9ja2VkLiBUaGlzIGZpcnN0IG1pZ2h0IG5vdCBhY3R1YWxseSBiZSB1bmJsb2NrZWQgeWV0LlxuICAgICAgLy8gV2UgY291bGQgY2hlY2sgaXQgZWFybHkgdG8gYXZvaWQgc2NoZWR1bGluZyBhbiB1bm5lY2Vzc2FyeSBjYWxsYmFjay5cblxuICAgICAgU2NoZWR1bGVyLnVuc3RhYmxlX3NjaGVkdWxlQ2FsbGJhY2soU2NoZWR1bGVyLnVuc3RhYmxlX05vcm1hbFByaW9yaXR5LCByZXBsYXlVbmJsb2NrZWRFdmVudHMpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiByZXRyeUlmQmxvY2tlZE9uKHVuYmxvY2tlZCkge1xuICAvLyBNYXJrIGFueXRoaW5nIHRoYXQgd2FzIGJsb2NrZWQgb24gdGhpcyBhcyBubyBsb25nZXIgYmxvY2tlZFxuICAvLyBhbmQgZWxpZ2libGUgZm9yIGEgcmVwbGF5LlxuICBpZiAocXVldWVkRGlzY3JldGVFdmVudHMubGVuZ3RoID4gMCkge1xuICAgIHNjaGVkdWxlQ2FsbGJhY2tJZlVuYmxvY2tlZChxdWV1ZWREaXNjcmV0ZUV2ZW50c1swXSwgdW5ibG9ja2VkKTsgLy8gVGhpcyBpcyBhIGV4cG9uZW50aWFsIHNlYXJjaCBmb3IgZWFjaCBib3VuZGFyeSB0aGF0IGNvbW1pdHMuIEkgdGhpbmsgaXQnc1xuICAgIC8vIHdvcnRoIGl0IGJlY2F1c2Ugd2UgZXhwZWN0IHZlcnkgZmV3IGRpc2NyZXRlIGV2ZW50cyB0byBxdWV1ZSB1cCBhbmQgb25jZVxuICAgIC8vIHdlIGFyZSBhY3R1YWxseSBmdWxseSB1bmJsb2NrZWQgaXQgd2lsbCBiZSBmYXN0IHRvIHJlcGxheSB0aGVtLlxuXG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBxdWV1ZWREaXNjcmV0ZUV2ZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHF1ZXVlZEV2ZW50ID0gcXVldWVkRGlzY3JldGVFdmVudHNbaV07XG5cbiAgICAgIGlmIChxdWV1ZWRFdmVudC5ibG9ja2VkT24gPT09IHVuYmxvY2tlZCkge1xuICAgICAgICBxdWV1ZWRFdmVudC5ibG9ja2VkT24gPSBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChxdWV1ZWRGb2N1cyAhPT0gbnVsbCkge1xuICAgIHNjaGVkdWxlQ2FsbGJhY2tJZlVuYmxvY2tlZChxdWV1ZWRGb2N1cywgdW5ibG9ja2VkKTtcbiAgfVxuXG4gIGlmIChxdWV1ZWREcmFnICE9PSBudWxsKSB7XG4gICAgc2NoZWR1bGVDYWxsYmFja0lmVW5ibG9ja2VkKHF1ZXVlZERyYWcsIHVuYmxvY2tlZCk7XG4gIH1cblxuICBpZiAocXVldWVkTW91c2UgIT09IG51bGwpIHtcbiAgICBzY2hlZHVsZUNhbGxiYWNrSWZVbmJsb2NrZWQocXVldWVkTW91c2UsIHVuYmxvY2tlZCk7XG4gIH1cblxuICB2YXIgdW5ibG9jayA9IGZ1bmN0aW9uIChxdWV1ZWRFdmVudCkge1xuICAgIHJldHVybiBzY2hlZHVsZUNhbGxiYWNrSWZVbmJsb2NrZWQocXVldWVkRXZlbnQsIHVuYmxvY2tlZCk7XG4gIH07XG5cbiAgcXVldWVkUG9pbnRlcnMuZm9yRWFjaCh1bmJsb2NrKTtcbiAgcXVldWVkUG9pbnRlckNhcHR1cmVzLmZvckVhY2godW5ibG9jayk7XG5cbiAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IHF1ZXVlZEV4cGxpY2l0SHlkcmF0aW9uVGFyZ2V0cy5sZW5ndGg7IF9pKyspIHtcbiAgICB2YXIgcXVldWVkVGFyZ2V0ID0gcXVldWVkRXhwbGljaXRIeWRyYXRpb25UYXJnZXRzW19pXTtcblxuICAgIGlmIChxdWV1ZWRUYXJnZXQuYmxvY2tlZE9uID09PSB1bmJsb2NrZWQpIHtcbiAgICAgIHF1ZXVlZFRhcmdldC5ibG9ja2VkT24gPSBudWxsO1xuICAgIH1cbiAgfVxuXG4gIHdoaWxlIChxdWV1ZWRFeHBsaWNpdEh5ZHJhdGlvblRhcmdldHMubGVuZ3RoID4gMCkge1xuICAgIHZhciBuZXh0RXhwbGljaXRUYXJnZXQgPSBxdWV1ZWRFeHBsaWNpdEh5ZHJhdGlvblRhcmdldHNbMF07XG5cbiAgICBpZiAobmV4dEV4cGxpY2l0VGFyZ2V0LmJsb2NrZWRPbiAhPT0gbnVsbCkge1xuICAgICAgLy8gV2UncmUgc3RpbGwgYmxvY2tlZC5cbiAgICAgIGJyZWFrO1xuICAgIH0gZWxzZSB7XG4gICAgICBhdHRlbXB0RXhwbGljaXRIeWRyYXRpb25UYXJnZXQobmV4dEV4cGxpY2l0VGFyZ2V0KTtcblxuICAgICAgaWYgKG5leHRFeHBsaWNpdFRhcmdldC5ibG9ja2VkT24gPT09IG51bGwpIHtcbiAgICAgICAgLy8gV2UncmUgdW5ibG9ja2VkLlxuICAgICAgICBxdWV1ZWRFeHBsaWNpdEh5ZHJhdGlvblRhcmdldHMuc2hpZnQoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxudmFyIERpc2NyZXRlRXZlbnQgPSAwO1xudmFyIFVzZXJCbG9ja2luZ0V2ZW50ID0gMTtcbnZhciBDb250aW51b3VzRXZlbnQgPSAyO1xuXG4vKipcbiAqIEdlbmVyYXRlIGEgbWFwcGluZyBvZiBzdGFuZGFyZCB2ZW5kb3IgcHJlZml4ZXMgdXNpbmcgdGhlIGRlZmluZWQgc3R5bGUgcHJvcGVydHkgYW5kIGV2ZW50IG5hbWUuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHN0eWxlUHJvcFxuICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZVxuICogQHJldHVybnMge29iamVjdH1cbiAqL1xuXG5mdW5jdGlvbiBtYWtlUHJlZml4TWFwKHN0eWxlUHJvcCwgZXZlbnROYW1lKSB7XG4gIHZhciBwcmVmaXhlcyA9IHt9O1xuICBwcmVmaXhlc1tzdHlsZVByb3AudG9Mb3dlckNhc2UoKV0gPSBldmVudE5hbWUudG9Mb3dlckNhc2UoKTtcbiAgcHJlZml4ZXNbJ1dlYmtpdCcgKyBzdHlsZVByb3BdID0gJ3dlYmtpdCcgKyBldmVudE5hbWU7XG4gIHByZWZpeGVzWydNb3onICsgc3R5bGVQcm9wXSA9ICdtb3onICsgZXZlbnROYW1lO1xuICByZXR1cm4gcHJlZml4ZXM7XG59XG4vKipcbiAqIEEgbGlzdCBvZiBldmVudCBuYW1lcyB0byBhIGNvbmZpZ3VyYWJsZSBsaXN0IG9mIHZlbmRvciBwcmVmaXhlcy5cbiAqL1xuXG5cbnZhciB2ZW5kb3JQcmVmaXhlcyA9IHtcbiAgYW5pbWF0aW9uZW5kOiBtYWtlUHJlZml4TWFwKCdBbmltYXRpb24nLCAnQW5pbWF0aW9uRW5kJyksXG4gIGFuaW1hdGlvbml0ZXJhdGlvbjogbWFrZVByZWZpeE1hcCgnQW5pbWF0aW9uJywgJ0FuaW1hdGlvbkl0ZXJhdGlvbicpLFxuICBhbmltYXRpb25zdGFydDogbWFrZVByZWZpeE1hcCgnQW5pbWF0aW9uJywgJ0FuaW1hdGlvblN0YXJ0JyksXG4gIHRyYW5zaXRpb25lbmQ6IG1ha2VQcmVmaXhNYXAoJ1RyYW5zaXRpb24nLCAnVHJhbnNpdGlvbkVuZCcpXG59O1xuLyoqXG4gKiBFdmVudCBuYW1lcyB0aGF0IGhhdmUgYWxyZWFkeSBiZWVuIGRldGVjdGVkIGFuZCBwcmVmaXhlZCAoaWYgYXBwbGljYWJsZSkuXG4gKi9cblxudmFyIHByZWZpeGVkRXZlbnROYW1lcyA9IHt9O1xuLyoqXG4gKiBFbGVtZW50IHRvIGNoZWNrIGZvciBwcmVmaXhlcyBvbi5cbiAqL1xuXG52YXIgc3R5bGUgPSB7fTtcbi8qKlxuICogQm9vdHN0cmFwIGlmIGEgRE9NIGV4aXN0cy5cbiAqL1xuXG5pZiAoY2FuVXNlRE9NKSB7XG4gIHN0eWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jykuc3R5bGU7IC8vIE9uIHNvbWUgcGxhdGZvcm1zLCBpbiBwYXJ0aWN1bGFyIHNvbWUgcmVsZWFzZXMgb2YgQW5kcm9pZCA0LngsXG4gIC8vIHRoZSB1bi1wcmVmaXhlZCBcImFuaW1hdGlvblwiIGFuZCBcInRyYW5zaXRpb25cIiBwcm9wZXJ0aWVzIGFyZSBkZWZpbmVkIG9uIHRoZVxuICAvLyBzdHlsZSBvYmplY3QgYnV0IHRoZSBldmVudHMgdGhhdCBmaXJlIHdpbGwgc3RpbGwgYmUgcHJlZml4ZWQsIHNvIHdlIG5lZWRcbiAgLy8gdG8gY2hlY2sgaWYgdGhlIHVuLXByZWZpeGVkIGV2ZW50cyBhcmUgdXNhYmxlLCBhbmQgaWYgbm90IHJlbW92ZSB0aGVtIGZyb20gdGhlIG1hcC5cblxuICBpZiAoISgnQW5pbWF0aW9uRXZlbnQnIGluIHdpbmRvdykpIHtcbiAgICBkZWxldGUgdmVuZG9yUHJlZml4ZXMuYW5pbWF0aW9uZW5kLmFuaW1hdGlvbjtcbiAgICBkZWxldGUgdmVuZG9yUHJlZml4ZXMuYW5pbWF0aW9uaXRlcmF0aW9uLmFuaW1hdGlvbjtcbiAgICBkZWxldGUgdmVuZG9yUHJlZml4ZXMuYW5pbWF0aW9uc3RhcnQuYW5pbWF0aW9uO1xuICB9IC8vIFNhbWUgYXMgYWJvdmVcblxuXG4gIGlmICghKCdUcmFuc2l0aW9uRXZlbnQnIGluIHdpbmRvdykpIHtcbiAgICBkZWxldGUgdmVuZG9yUHJlZml4ZXMudHJhbnNpdGlvbmVuZC50cmFuc2l0aW9uO1xuICB9XG59XG4vKipcbiAqIEF0dGVtcHRzIHRvIGRldGVybWluZSB0aGUgY29ycmVjdCB2ZW5kb3IgcHJlZml4ZWQgZXZlbnQgbmFtZS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5cblxuZnVuY3Rpb24gZ2V0VmVuZG9yUHJlZml4ZWRFdmVudE5hbWUoZXZlbnROYW1lKSB7XG4gIGlmIChwcmVmaXhlZEV2ZW50TmFtZXNbZXZlbnROYW1lXSkge1xuICAgIHJldHVybiBwcmVmaXhlZEV2ZW50TmFtZXNbZXZlbnROYW1lXTtcbiAgfSBlbHNlIGlmICghdmVuZG9yUHJlZml4ZXNbZXZlbnROYW1lXSkge1xuICAgIHJldHVybiBldmVudE5hbWU7XG4gIH1cblxuICB2YXIgcHJlZml4TWFwID0gdmVuZG9yUHJlZml4ZXNbZXZlbnROYW1lXTtcblxuICBmb3IgKHZhciBzdHlsZVByb3AgaW4gcHJlZml4TWFwKSB7XG4gICAgaWYgKHByZWZpeE1hcC5oYXNPd25Qcm9wZXJ0eShzdHlsZVByb3ApICYmIHN0eWxlUHJvcCBpbiBzdHlsZSkge1xuICAgICAgcmV0dXJuIHByZWZpeGVkRXZlbnROYW1lc1tldmVudE5hbWVdID0gcHJlZml4TWFwW3N0eWxlUHJvcF07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGV2ZW50TmFtZTtcbn1cblxudmFyIEFOSU1BVElPTl9FTkQgPSBnZXRWZW5kb3JQcmVmaXhlZEV2ZW50TmFtZSgnYW5pbWF0aW9uZW5kJyk7XG52YXIgQU5JTUFUSU9OX0lURVJBVElPTiA9IGdldFZlbmRvclByZWZpeGVkRXZlbnROYW1lKCdhbmltYXRpb25pdGVyYXRpb24nKTtcbnZhciBBTklNQVRJT05fU1RBUlQgPSBnZXRWZW5kb3JQcmVmaXhlZEV2ZW50TmFtZSgnYW5pbWF0aW9uc3RhcnQnKTtcbnZhciBUUkFOU0lUSU9OX0VORCA9IGdldFZlbmRvclByZWZpeGVkRXZlbnROYW1lKCd0cmFuc2l0aW9uZW5kJyk7XG5cbnZhciB0b3BMZXZlbEV2ZW50c1RvUmVhY3ROYW1lcyA9IG5ldyBNYXAoKTtcbnZhciBldmVudFByaW9yaXRpZXMgPSBuZXcgTWFwKCk7IC8vIFdlIHN0b3JlIG1vc3Qgb2YgdGhlIGV2ZW50cyBpbiB0aGlzIG1vZHVsZSBpbiBwYWlycyBvZiB0d28gc3RyaW5ncyBzbyB3ZSBjYW4gcmUtdXNlXG4vLyB0aGUgY29kZSByZXF1aXJlZCB0byBhcHBseSB0aGUgc2FtZSBsb2dpYyBmb3IgZXZlbnQgcHJpb3JpdGl6YXRpb24gYW5kIHRoYXQgb2YgdGhlXG4vLyBTaW1wbGVFdmVudFBsdWdpbi4gVGhpcyBjb21wbGljYXRlcyB0aGluZ3Mgc2xpZ2h0bHksIGJ1dCB0aGUgYWltIGlzIHRvIHJlZHVjZSBjb2RlXG4vLyBkdXBsaWNhdGlvbiAoZm9yIHdoaWNoIHRoZXJlIHdvdWxkIGJlIHF1aXRlIGEgYml0KS4gRm9yIHRoZSBldmVudHMgdGhhdCBhcmUgbm90IG5lZWRlZFxuLy8gZm9yIHRoZSBTaW1wbGVFdmVudFBsdWdpbiAob3RoZXJEaXNjcmV0ZUV2ZW50cykgd2UgcHJvY2VzcyB0aGVtIHNlcGFyYXRlbHkgYXMgYW5cbi8vIGFycmF5IG9mIHRvcCBsZXZlbCBldmVudHMuXG4vLyBMYXN0bHksIHdlIGlnbm9yZSBwcmV0dGllciBzbyB3ZSBjYW4ga2VlcCB0aGUgZm9ybWF0dGluZyBzYW5lLlxuLy8gcHJldHRpZXItaWdub3JlXG5cbnZhciBkaXNjcmV0ZUV2ZW50UGFpcnNGb3JTaW1wbGVFdmVudFBsdWdpbiA9IFsnY2FuY2VsJywgJ2NhbmNlbCcsICdjbGljaycsICdjbGljaycsICdjbG9zZScsICdjbG9zZScsICdjb250ZXh0bWVudScsICdjb250ZXh0TWVudScsICdjb3B5JywgJ2NvcHknLCAnY3V0JywgJ2N1dCcsICdhdXhjbGljaycsICdhdXhDbGljaycsICdkYmxjbGljaycsICdkb3VibGVDbGljaycsIC8vIENhcmVmdWwhXG4nZHJhZ2VuZCcsICdkcmFnRW5kJywgJ2RyYWdzdGFydCcsICdkcmFnU3RhcnQnLCAnZHJvcCcsICdkcm9wJywgJ2ZvY3VzaW4nLCAnZm9jdXMnLCAvLyBDYXJlZnVsIVxuJ2ZvY3Vzb3V0JywgJ2JsdXInLCAvLyBDYXJlZnVsIVxuJ2lucHV0JywgJ2lucHV0JywgJ2ludmFsaWQnLCAnaW52YWxpZCcsICdrZXlkb3duJywgJ2tleURvd24nLCAna2V5cHJlc3MnLCAna2V5UHJlc3MnLCAna2V5dXAnLCAna2V5VXAnLCAnbW91c2Vkb3duJywgJ21vdXNlRG93bicsICdtb3VzZXVwJywgJ21vdXNlVXAnLCAncGFzdGUnLCAncGFzdGUnLCAncGF1c2UnLCAncGF1c2UnLCAncGxheScsICdwbGF5JywgJ3BvaW50ZXJjYW5jZWwnLCAncG9pbnRlckNhbmNlbCcsICdwb2ludGVyZG93bicsICdwb2ludGVyRG93bicsICdwb2ludGVydXAnLCAncG9pbnRlclVwJywgJ3JhdGVjaGFuZ2UnLCAncmF0ZUNoYW5nZScsICdyZXNldCcsICdyZXNldCcsICdzZWVrZWQnLCAnc2Vla2VkJywgJ3N1Ym1pdCcsICdzdWJtaXQnLCAndG91Y2hjYW5jZWwnLCAndG91Y2hDYW5jZWwnLCAndG91Y2hlbmQnLCAndG91Y2hFbmQnLCAndG91Y2hzdGFydCcsICd0b3VjaFN0YXJ0JywgJ3ZvbHVtZWNoYW5nZScsICd2b2x1bWVDaGFuZ2UnXTtcbnZhciBvdGhlckRpc2NyZXRlRXZlbnRzID0gWydjaGFuZ2UnLCAnc2VsZWN0aW9uY2hhbmdlJywgJ3RleHRJbnB1dCcsICdjb21wb3NpdGlvbnN0YXJ0JywgJ2NvbXBvc2l0aW9uZW5kJywgJ2NvbXBvc2l0aW9udXBkYXRlJ107XG5cblxudmFyIHVzZXJCbG9ja2luZ1BhaXJzRm9yU2ltcGxlRXZlbnRQbHVnaW4gPSBbJ2RyYWcnLCAnZHJhZycsICdkcmFnZW50ZXInLCAnZHJhZ0VudGVyJywgJ2RyYWdleGl0JywgJ2RyYWdFeGl0JywgJ2RyYWdsZWF2ZScsICdkcmFnTGVhdmUnLCAnZHJhZ292ZXInLCAnZHJhZ092ZXInLCAnbW91c2Vtb3ZlJywgJ21vdXNlTW92ZScsICdtb3VzZW91dCcsICdtb3VzZU91dCcsICdtb3VzZW92ZXInLCAnbW91c2VPdmVyJywgJ3BvaW50ZXJtb3ZlJywgJ3BvaW50ZXJNb3ZlJywgJ3BvaW50ZXJvdXQnLCAncG9pbnRlck91dCcsICdwb2ludGVyb3ZlcicsICdwb2ludGVyT3ZlcicsICdzY3JvbGwnLCAnc2Nyb2xsJywgJ3RvZ2dsZScsICd0b2dnbGUnLCAndG91Y2htb3ZlJywgJ3RvdWNoTW92ZScsICd3aGVlbCcsICd3aGVlbCddOyAvLyBwcmV0dGllci1pZ25vcmVcblxudmFyIGNvbnRpbnVvdXNQYWlyc0ZvclNpbXBsZUV2ZW50UGx1Z2luID0gWydhYm9ydCcsICdhYm9ydCcsIEFOSU1BVElPTl9FTkQsICdhbmltYXRpb25FbmQnLCBBTklNQVRJT05fSVRFUkFUSU9OLCAnYW5pbWF0aW9uSXRlcmF0aW9uJywgQU5JTUFUSU9OX1NUQVJULCAnYW5pbWF0aW9uU3RhcnQnLCAnY2FucGxheScsICdjYW5QbGF5JywgJ2NhbnBsYXl0aHJvdWdoJywgJ2NhblBsYXlUaHJvdWdoJywgJ2R1cmF0aW9uY2hhbmdlJywgJ2R1cmF0aW9uQ2hhbmdlJywgJ2VtcHRpZWQnLCAnZW1wdGllZCcsICdlbmNyeXB0ZWQnLCAnZW5jcnlwdGVkJywgJ2VuZGVkJywgJ2VuZGVkJywgJ2Vycm9yJywgJ2Vycm9yJywgJ2dvdHBvaW50ZXJjYXB0dXJlJywgJ2dvdFBvaW50ZXJDYXB0dXJlJywgJ2xvYWQnLCAnbG9hZCcsICdsb2FkZWRkYXRhJywgJ2xvYWRlZERhdGEnLCAnbG9hZGVkbWV0YWRhdGEnLCAnbG9hZGVkTWV0YWRhdGEnLCAnbG9hZHN0YXJ0JywgJ2xvYWRTdGFydCcsICdsb3N0cG9pbnRlcmNhcHR1cmUnLCAnbG9zdFBvaW50ZXJDYXB0dXJlJywgJ3BsYXlpbmcnLCAncGxheWluZycsICdwcm9ncmVzcycsICdwcm9ncmVzcycsICdzZWVraW5nJywgJ3NlZWtpbmcnLCAnc3RhbGxlZCcsICdzdGFsbGVkJywgJ3N1c3BlbmQnLCAnc3VzcGVuZCcsICd0aW1ldXBkYXRlJywgJ3RpbWVVcGRhdGUnLCBUUkFOU0lUSU9OX0VORCwgJ3RyYW5zaXRpb25FbmQnLCAnd2FpdGluZycsICd3YWl0aW5nJ107XG4vKipcbiAqIFR1cm5zXG4gKiBbJ2Fib3J0JywgLi4uXVxuICpcbiAqIGludG9cbiAqXG4gKiB0b3BMZXZlbEV2ZW50c1RvUmVhY3ROYW1lcyA9IG5ldyBNYXAoW1xuICogICBbJ2Fib3J0JywgJ29uQWJvcnQnXSxcbiAqIF0pO1xuICpcbiAqIGFuZCByZWdpc3RlcnMgdGhlbS5cbiAqL1xuXG5mdW5jdGlvbiByZWdpc3RlclNpbXBsZVBsdWdpbkV2ZW50c0FuZFNldFRoZWlyUHJpb3JpdGllcyhldmVudFR5cGVzLCBwcmlvcml0eSkge1xuICAvLyBBcyB0aGUgZXZlbnQgdHlwZXMgYXJlIGluIHBhaXJzIG9mIHR3bywgd2UgbmVlZCB0byBpdGVyYXRlXG4gIC8vIHRocm91Z2ggaW4gdHdvcy4gVGhlIGV2ZW50cyBhcmUgaW4gcGFpcnMgb2YgdHdvIHRvIHNhdmUgY29kZVxuICAvLyBhbmQgaW1wcm92ZSBpbml0IHBlcmYgb2YgcHJvY2Vzc2luZyB0aGlzIGFycmF5LCBhcyBpdCB3aWxsXG4gIC8vIHJlc3VsdCBpbiBmYXIgZmV3ZXIgb2JqZWN0IGFsbG9jYXRpb25zIGFuZCBwcm9wZXJ0eSBhY2Nlc3Nlc1xuICAvLyBpZiB3ZSBvbmx5IHVzZSB0aHJlZSBhcnJheXMgdG8gcHJvY2VzcyBhbGwgdGhlIGNhdGVnb3JpZXMgb2ZcbiAgLy8gaW5zdGVhZCBvZiB0dXBsZXMuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZXZlbnRUeXBlcy5sZW5ndGg7IGkgKz0gMikge1xuICAgIHZhciB0b3BFdmVudCA9IGV2ZW50VHlwZXNbaV07XG4gICAgdmFyIGV2ZW50ID0gZXZlbnRUeXBlc1tpICsgMV07XG4gICAgdmFyIGNhcGl0YWxpemVkRXZlbnQgPSBldmVudFswXS50b1VwcGVyQ2FzZSgpICsgZXZlbnQuc2xpY2UoMSk7XG4gICAgdmFyIHJlYWN0TmFtZSA9ICdvbicgKyBjYXBpdGFsaXplZEV2ZW50O1xuICAgIGV2ZW50UHJpb3JpdGllcy5zZXQodG9wRXZlbnQsIHByaW9yaXR5KTtcbiAgICB0b3BMZXZlbEV2ZW50c1RvUmVhY3ROYW1lcy5zZXQodG9wRXZlbnQsIHJlYWN0TmFtZSk7XG4gICAgcmVnaXN0ZXJUd29QaGFzZUV2ZW50KHJlYWN0TmFtZSwgW3RvcEV2ZW50XSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc2V0RXZlbnRQcmlvcml0aWVzKGV2ZW50VHlwZXMsIHByaW9yaXR5KSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZXZlbnRUeXBlcy5sZW5ndGg7IGkrKykge1xuICAgIGV2ZW50UHJpb3JpdGllcy5zZXQoZXZlbnRUeXBlc1tpXSwgcHJpb3JpdHkpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldEV2ZW50UHJpb3JpdHlGb3JQbHVnaW5TeXN0ZW0oZG9tRXZlbnROYW1lKSB7XG4gIHZhciBwcmlvcml0eSA9IGV2ZW50UHJpb3JpdGllcy5nZXQoZG9tRXZlbnROYW1lKTsgLy8gRGVmYXVsdCB0byBhIENvbnRpbnVvdXNFdmVudC4gTm90ZTogd2UgbWlnaHRcbiAgLy8gd2FudCB0byB3YXJuIGlmIHdlIGNhbid0IGRldGVjdCB0aGUgcHJpb3JpdHlcbiAgLy8gZm9yIHRoZSBldmVudC5cblxuICByZXR1cm4gcHJpb3JpdHkgPT09IHVuZGVmaW5lZCA/IENvbnRpbnVvdXNFdmVudCA6IHByaW9yaXR5O1xufVxuZnVuY3Rpb24gcmVnaXN0ZXJTaW1wbGVFdmVudHMoKSB7XG4gIHJlZ2lzdGVyU2ltcGxlUGx1Z2luRXZlbnRzQW5kU2V0VGhlaXJQcmlvcml0aWVzKGRpc2NyZXRlRXZlbnRQYWlyc0ZvclNpbXBsZUV2ZW50UGx1Z2luLCBEaXNjcmV0ZUV2ZW50KTtcbiAgcmVnaXN0ZXJTaW1wbGVQbHVnaW5FdmVudHNBbmRTZXRUaGVpclByaW9yaXRpZXModXNlckJsb2NraW5nUGFpcnNGb3JTaW1wbGVFdmVudFBsdWdpbiwgVXNlckJsb2NraW5nRXZlbnQpO1xuICByZWdpc3RlclNpbXBsZVBsdWdpbkV2ZW50c0FuZFNldFRoZWlyUHJpb3JpdGllcyhjb250aW51b3VzUGFpcnNGb3JTaW1wbGVFdmVudFBsdWdpbiwgQ29udGludW91c0V2ZW50KTtcbiAgc2V0RXZlbnRQcmlvcml0aWVzKG90aGVyRGlzY3JldGVFdmVudHMsIERpc2NyZXRlRXZlbnQpO1xufVxuXG52YXIgU2NoZWR1bGVyX25vdyA9IFNjaGVkdWxlci51bnN0YWJsZV9ub3c7XG5cbntcbiAgLy8gUHJvdmlkZSBleHBsaWNpdCBlcnJvciBtZXNzYWdlIHdoZW4gcHJvZHVjdGlvbitwcm9maWxpbmcgYnVuZGxlIG9mIGUuZy5cbiAgLy8gcmVhY3QtZG9tIGlzIHVzZWQgd2l0aCBwcm9kdWN0aW9uIChub24tcHJvZmlsaW5nKSBidW5kbGUgb2ZcbiAgLy8gc2NoZWR1bGVyL3RyYWNpbmdcbiAgaWYgKCEodHJhY2luZy5fX2ludGVyYWN0aW9uc1JlZiAhPSBudWxsICYmIHRyYWNpbmcuX19pbnRlcmFjdGlvbnNSZWYuY3VycmVudCAhPSBudWxsKSkge1xuICAgIHtcbiAgICAgIHRocm93IEVycm9yKCBcIkl0IGlzIG5vdCBzdXBwb3J0ZWQgdG8gcnVuIHRoZSBwcm9maWxpbmcgdmVyc2lvbiBvZiBhIHJlbmRlcmVyIChmb3IgZXhhbXBsZSwgYHJlYWN0LWRvbS9wcm9maWxpbmdgKSB3aXRob3V0IGFsc28gcmVwbGFjaW5nIHRoZSBgc2NoZWR1bGVyL3RyYWNpbmdgIG1vZHVsZSB3aXRoIGBzY2hlZHVsZXIvdHJhY2luZy1wcm9maWxpbmdgLiBZb3VyIGJ1bmRsZXIgbWlnaHQgaGF2ZSBhIHNldHRpbmcgZm9yIGFsaWFzaW5nIGJvdGggbW9kdWxlcy4gTGVhcm4gbW9yZSBhdCBodHRwczovL3JlYWN0anMub3JnL2xpbmsvcHJvZmlsaW5nXCIgKTtcbiAgICB9XG4gIH1cbn1cbi8vIGFzY2VuZGluZyBudW1iZXJzIHNvIHdlIGNhbiBjb21wYXJlIHRoZW0gbGlrZSBudW1iZXJzLiBUaGV5IHN0YXJ0IGF0IDkwIHRvXG4vLyBhdm9pZCBjbGFzaGluZyB3aXRoIFNjaGVkdWxlcidzIHByaW9yaXRpZXMuXG5cbnZhciBJbW1lZGlhdGVQcmlvcml0eSA9IDk5O1xudmFyIFVzZXJCbG9ja2luZ1ByaW9yaXR5ID0gOTg7XG52YXIgTm9ybWFsUHJpb3JpdHkgPSA5NztcbnZhciBMb3dQcmlvcml0eSA9IDk2O1xudmFyIElkbGVQcmlvcml0eSA9IDk1OyAvLyBOb1ByaW9yaXR5IGlzIHRoZSBhYnNlbmNlIG9mIHByaW9yaXR5LiBBbHNvIFJlYWN0LW9ubHkuXG5cbnZhciBOb1ByaW9yaXR5ID0gOTA7XG52YXIgaW5pdGlhbFRpbWVNcyA9IFNjaGVkdWxlcl9ub3coKTsgLy8gSWYgdGhlIGluaXRpYWwgdGltZXN0YW1wIGlzIHJlYXNvbmFibHkgc21hbGwsIHVzZSBTY2hlZHVsZXIncyBgbm93YCBkaXJlY3RseS5cblxudmFyIFN5bmNMYW5lUHJpb3JpdHkgPSAxNTtcbnZhciBTeW5jQmF0Y2hlZExhbmVQcmlvcml0eSA9IDE0O1xudmFyIElucHV0RGlzY3JldGVIeWRyYXRpb25MYW5lUHJpb3JpdHkgPSAxMztcbnZhciBJbnB1dERpc2NyZXRlTGFuZVByaW9yaXR5ID0gMTI7XG52YXIgSW5wdXRDb250aW51b3VzSHlkcmF0aW9uTGFuZVByaW9yaXR5ID0gMTE7XG52YXIgSW5wdXRDb250aW51b3VzTGFuZVByaW9yaXR5ID0gMTA7XG52YXIgRGVmYXVsdEh5ZHJhdGlvbkxhbmVQcmlvcml0eSA9IDk7XG52YXIgRGVmYXVsdExhbmVQcmlvcml0eSA9IDg7XG52YXIgVHJhbnNpdGlvbkh5ZHJhdGlvblByaW9yaXR5ID0gNztcbnZhciBUcmFuc2l0aW9uUHJpb3JpdHkgPSA2O1xudmFyIFJldHJ5TGFuZVByaW9yaXR5ID0gNTtcbnZhciBTZWxlY3RpdmVIeWRyYXRpb25MYW5lUHJpb3JpdHkgPSA0O1xudmFyIElkbGVIeWRyYXRpb25MYW5lUHJpb3JpdHkgPSAzO1xudmFyIElkbGVMYW5lUHJpb3JpdHkgPSAyO1xudmFyIE9mZnNjcmVlbkxhbmVQcmlvcml0eSA9IDE7XG52YXIgTm9MYW5lUHJpb3JpdHkgPSAwO1xudmFyIFRvdGFsTGFuZXMgPSAzMTtcbnZhciBOb0xhbmVzID1cbi8qICAgICAgICAgICAgICAgICAgICAgICAgKi9cbjA7XG52YXIgTm9MYW5lID1cbi8qICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuMDtcbnZhciBTeW5jTGFuZSA9XG4vKiAgICAgICAgICAgICAgICAgICAgICAgICovXG4xO1xudmFyIFN5bmNCYXRjaGVkTGFuZSA9XG4vKiAgICAgICAgICAgICAgICAgKi9cbjI7XG52YXIgSW5wdXREaXNjcmV0ZUh5ZHJhdGlvbkxhbmUgPVxuLyogICAgICAqL1xuNDtcbnZhciBJbnB1dERpc2NyZXRlTGFuZXMgPVxuLyogICAgICAgICAgICAgICAgICAgICovXG4yNDtcbnZhciBJbnB1dENvbnRpbnVvdXNIeWRyYXRpb25MYW5lID1cbi8qICAgICAgICAgICAqL1xuMzI7XG52YXIgSW5wdXRDb250aW51b3VzTGFuZXMgPVxuLyogICAgICAgICAgICAgICAgICAqL1xuMTkyO1xudmFyIERlZmF1bHRIeWRyYXRpb25MYW5lID1cbi8qICAgICAgICAgICAgKi9cbjI1NjtcbnZhciBEZWZhdWx0TGFuZXMgPVxuLyogICAgICAgICAgICAgICAgICAgKi9cbjM1ODQ7XG52YXIgVHJhbnNpdGlvbkh5ZHJhdGlvbkxhbmUgPVxuLyogICAgICAgICAgICAgICAgKi9cbjQwOTY7XG52YXIgVHJhbnNpdGlvbkxhbmVzID1cbi8qICAgICAgICAgICAgICAgICAgICAgICAqL1xuNDE4NjExMjtcbnZhciBSZXRyeUxhbmVzID1cbi8qICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG42MjkxNDU2MDtcbnZhciBTb21lUmV0cnlMYW5lID1cbi8qICAgICAgICAgICAgICAgICAgKi9cbjMzNTU0NDMyO1xudmFyIFNlbGVjdGl2ZUh5ZHJhdGlvbkxhbmUgPVxuLyogICAgICAgICAgKi9cbjY3MTA4ODY0O1xudmFyIE5vbklkbGVMYW5lcyA9XG4vKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG4xMzQyMTc3Mjc7XG52YXIgSWRsZUh5ZHJhdGlvbkxhbmUgPVxuLyogICAgICAgICAgICAgICAqL1xuMTM0MjE3NzI4O1xudmFyIElkbGVMYW5lcyA9XG4vKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbjgwNTMwNjM2ODtcbnZhciBPZmZzY3JlZW5MYW5lID1cbi8qICAgICAgICAgICAgICAgICAgICovXG4xMDczNzQxODI0O1xudmFyIE5vVGltZXN0YW1wID0gLTE7XG5mdW5jdGlvbiBzZXRDdXJyZW50VXBkYXRlTGFuZVByaW9yaXR5KG5ld0xhbmVQcmlvcml0eSkge1xufSAvLyBcIlJlZ2lzdGVyc1wiIHVzZWQgdG8gXCJyZXR1cm5cIiBtdWx0aXBsZSB2YWx1ZXNcbi8vIFVzZWQgYnkgZ2V0SGlnaGVzdFByaW9yaXR5TGFuZXMgYW5kIGdldE5leHRMYW5lczpcblxudmFyIHJldHVybl9oaWdoZXN0TGFuZVByaW9yaXR5ID0gRGVmYXVsdExhbmVQcmlvcml0eTtcblxuZnVuY3Rpb24gZ2V0SGlnaGVzdFByaW9yaXR5TGFuZXMobGFuZXMpIHtcbiAgaWYgKChTeW5jTGFuZSAmIGxhbmVzKSAhPT0gTm9MYW5lcykge1xuICAgIHJldHVybl9oaWdoZXN0TGFuZVByaW9yaXR5ID0gU3luY0xhbmVQcmlvcml0eTtcbiAgICByZXR1cm4gU3luY0xhbmU7XG4gIH1cblxuICBpZiAoKFN5bmNCYXRjaGVkTGFuZSAmIGxhbmVzKSAhPT0gTm9MYW5lcykge1xuICAgIHJldHVybl9oaWdoZXN0TGFuZVByaW9yaXR5ID0gU3luY0JhdGNoZWRMYW5lUHJpb3JpdHk7XG4gICAgcmV0dXJuIFN5bmNCYXRjaGVkTGFuZTtcbiAgfVxuXG4gIGlmICgoSW5wdXREaXNjcmV0ZUh5ZHJhdGlvbkxhbmUgJiBsYW5lcykgIT09IE5vTGFuZXMpIHtcbiAgICByZXR1cm5faGlnaGVzdExhbmVQcmlvcml0eSA9IElucHV0RGlzY3JldGVIeWRyYXRpb25MYW5lUHJpb3JpdHk7XG4gICAgcmV0dXJuIElucHV0RGlzY3JldGVIeWRyYXRpb25MYW5lO1xuICB9XG5cbiAgdmFyIGlucHV0RGlzY3JldGVMYW5lcyA9IElucHV0RGlzY3JldGVMYW5lcyAmIGxhbmVzO1xuXG4gIGlmIChpbnB1dERpc2NyZXRlTGFuZXMgIT09IE5vTGFuZXMpIHtcbiAgICByZXR1cm5faGlnaGVzdExhbmVQcmlvcml0eSA9IElucHV0RGlzY3JldGVMYW5lUHJpb3JpdHk7XG4gICAgcmV0dXJuIGlucHV0RGlzY3JldGVMYW5lcztcbiAgfVxuXG4gIGlmICgobGFuZXMgJiBJbnB1dENvbnRpbnVvdXNIeWRyYXRpb25MYW5lKSAhPT0gTm9MYW5lcykge1xuICAgIHJldHVybl9oaWdoZXN0TGFuZVByaW9yaXR5ID0gSW5wdXRDb250aW51b3VzSHlkcmF0aW9uTGFuZVByaW9yaXR5O1xuICAgIHJldHVybiBJbnB1dENvbnRpbnVvdXNIeWRyYXRpb25MYW5lO1xuICB9XG5cbiAgdmFyIGlucHV0Q29udGludW91c0xhbmVzID0gSW5wdXRDb250aW51b3VzTGFuZXMgJiBsYW5lcztcblxuICBpZiAoaW5wdXRDb250aW51b3VzTGFuZXMgIT09IE5vTGFuZXMpIHtcbiAgICByZXR1cm5faGlnaGVzdExhbmVQcmlvcml0eSA9IElucHV0Q29udGludW91c0xhbmVQcmlvcml0eTtcbiAgICByZXR1cm4gaW5wdXRDb250aW51b3VzTGFuZXM7XG4gIH1cblxuICBpZiAoKGxhbmVzICYgRGVmYXVsdEh5ZHJhdGlvbkxhbmUpICE9PSBOb0xhbmVzKSB7XG4gICAgcmV0dXJuX2hpZ2hlc3RMYW5lUHJpb3JpdHkgPSBEZWZhdWx0SHlkcmF0aW9uTGFuZVByaW9yaXR5O1xuICAgIHJldHVybiBEZWZhdWx0SHlkcmF0aW9uTGFuZTtcbiAgfVxuXG4gIHZhciBkZWZhdWx0TGFuZXMgPSBEZWZhdWx0TGFuZXMgJiBsYW5lcztcblxuICBpZiAoZGVmYXVsdExhbmVzICE9PSBOb0xhbmVzKSB7XG4gICAgcmV0dXJuX2hpZ2hlc3RMYW5lUHJpb3JpdHkgPSBEZWZhdWx0TGFuZVByaW9yaXR5O1xuICAgIHJldHVybiBkZWZhdWx0TGFuZXM7XG4gIH1cblxuICBpZiAoKGxhbmVzICYgVHJhbnNpdGlvbkh5ZHJhdGlvbkxhbmUpICE9PSBOb0xhbmVzKSB7XG4gICAgcmV0dXJuX2hpZ2hlc3RMYW5lUHJpb3JpdHkgPSBUcmFuc2l0aW9uSHlkcmF0aW9uUHJpb3JpdHk7XG4gICAgcmV0dXJuIFRyYW5zaXRpb25IeWRyYXRpb25MYW5lO1xuICB9XG5cbiAgdmFyIHRyYW5zaXRpb25MYW5lcyA9IFRyYW5zaXRpb25MYW5lcyAmIGxhbmVzO1xuXG4gIGlmICh0cmFuc2l0aW9uTGFuZXMgIT09IE5vTGFuZXMpIHtcbiAgICByZXR1cm5faGlnaGVzdExhbmVQcmlvcml0eSA9IFRyYW5zaXRpb25Qcmlvcml0eTtcbiAgICByZXR1cm4gdHJhbnNpdGlvbkxhbmVzO1xuICB9XG5cbiAgdmFyIHJldHJ5TGFuZXMgPSBSZXRyeUxhbmVzICYgbGFuZXM7XG5cbiAgaWYgKHJldHJ5TGFuZXMgIT09IE5vTGFuZXMpIHtcbiAgICByZXR1cm5faGlnaGVzdExhbmVQcmlvcml0eSA9IFJldHJ5TGFuZVByaW9yaXR5O1xuICAgIHJldHVybiByZXRyeUxhbmVzO1xuICB9XG5cbiAgaWYgKGxhbmVzICYgU2VsZWN0aXZlSHlkcmF0aW9uTGFuZSkge1xuICAgIHJldHVybl9oaWdoZXN0TGFuZVByaW9yaXR5ID0gU2VsZWN0aXZlSHlkcmF0aW9uTGFuZVByaW9yaXR5O1xuICAgIHJldHVybiBTZWxlY3RpdmVIeWRyYXRpb25MYW5lO1xuICB9XG5cbiAgaWYgKChsYW5lcyAmIElkbGVIeWRyYXRpb25MYW5lKSAhPT0gTm9MYW5lcykge1xuICAgIHJldHVybl9oaWdoZXN0TGFuZVByaW9yaXR5ID0gSWRsZUh5ZHJhdGlvbkxhbmVQcmlvcml0eTtcbiAgICByZXR1cm4gSWRsZUh5ZHJhdGlvbkxhbmU7XG4gIH1cblxuICB2YXIgaWRsZUxhbmVzID0gSWRsZUxhbmVzICYgbGFuZXM7XG5cbiAgaWYgKGlkbGVMYW5lcyAhPT0gTm9MYW5lcykge1xuICAgIHJldHVybl9oaWdoZXN0TGFuZVByaW9yaXR5ID0gSWRsZUxhbmVQcmlvcml0eTtcbiAgICByZXR1cm4gaWRsZUxhbmVzO1xuICB9XG5cbiAgaWYgKChPZmZzY3JlZW5MYW5lICYgbGFuZXMpICE9PSBOb0xhbmVzKSB7XG4gICAgcmV0dXJuX2hpZ2hlc3RMYW5lUHJpb3JpdHkgPSBPZmZzY3JlZW5MYW5lUHJpb3JpdHk7XG4gICAgcmV0dXJuIE9mZnNjcmVlbkxhbmU7XG4gIH1cblxuICB7XG4gICAgZXJyb3IoJ1Nob3VsZCBoYXZlIGZvdW5kIG1hdGNoaW5nIGxhbmVzLiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LicpO1xuICB9IC8vIFRoaXMgc2hvdWxkbid0IGJlIHJlYWNoYWJsZSwgYnV0IGFzIGEgZmFsbGJhY2ssIHJldHVybiB0aGUgZW50aXJlIGJpdG1hc2suXG5cblxuICByZXR1cm5faGlnaGVzdExhbmVQcmlvcml0eSA9IERlZmF1bHRMYW5lUHJpb3JpdHk7XG4gIHJldHVybiBsYW5lcztcbn1cblxuZnVuY3Rpb24gc2NoZWR1bGVyUHJpb3JpdHlUb0xhbmVQcmlvcml0eShzY2hlZHVsZXJQcmlvcml0eUxldmVsKSB7XG4gIHN3aXRjaCAoc2NoZWR1bGVyUHJpb3JpdHlMZXZlbCkge1xuICAgIGNhc2UgSW1tZWRpYXRlUHJpb3JpdHk6XG4gICAgICByZXR1cm4gU3luY0xhbmVQcmlvcml0eTtcblxuICAgIGNhc2UgVXNlckJsb2NraW5nUHJpb3JpdHk6XG4gICAgICByZXR1cm4gSW5wdXRDb250aW51b3VzTGFuZVByaW9yaXR5O1xuXG4gICAgY2FzZSBOb3JtYWxQcmlvcml0eTpcbiAgICBjYXNlIExvd1ByaW9yaXR5OlxuICAgICAgLy8gVE9ETzogSGFuZGxlIExvd1NjaGVkdWxlclByaW9yaXR5LCBzb21laG93LiBNYXliZSB0aGUgc2FtZSBsYW5lIGFzIGh5ZHJhdGlvbi5cbiAgICAgIHJldHVybiBEZWZhdWx0TGFuZVByaW9yaXR5O1xuXG4gICAgY2FzZSBJZGxlUHJpb3JpdHk6XG4gICAgICByZXR1cm4gSWRsZUxhbmVQcmlvcml0eTtcblxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gTm9MYW5lUHJpb3JpdHk7XG4gIH1cbn1cbmZ1bmN0aW9uIGxhbmVQcmlvcml0eVRvU2NoZWR1bGVyUHJpb3JpdHkobGFuZVByaW9yaXR5KSB7XG4gIHN3aXRjaCAobGFuZVByaW9yaXR5KSB7XG4gICAgY2FzZSBTeW5jTGFuZVByaW9yaXR5OlxuICAgIGNhc2UgU3luY0JhdGNoZWRMYW5lUHJpb3JpdHk6XG4gICAgICByZXR1cm4gSW1tZWRpYXRlUHJpb3JpdHk7XG5cbiAgICBjYXNlIElucHV0RGlzY3JldGVIeWRyYXRpb25MYW5lUHJpb3JpdHk6XG4gICAgY2FzZSBJbnB1dERpc2NyZXRlTGFuZVByaW9yaXR5OlxuICAgIGNhc2UgSW5wdXRDb250aW51b3VzSHlkcmF0aW9uTGFuZVByaW9yaXR5OlxuICAgIGNhc2UgSW5wdXRDb250aW51b3VzTGFuZVByaW9yaXR5OlxuICAgICAgcmV0dXJuIFVzZXJCbG9ja2luZ1ByaW9yaXR5O1xuXG4gICAgY2FzZSBEZWZhdWx0SHlkcmF0aW9uTGFuZVByaW9yaXR5OlxuICAgIGNhc2UgRGVmYXVsdExhbmVQcmlvcml0eTpcbiAgICBjYXNlIFRyYW5zaXRpb25IeWRyYXRpb25Qcmlvcml0eTpcbiAgICBjYXNlIFRyYW5zaXRpb25Qcmlvcml0eTpcbiAgICBjYXNlIFNlbGVjdGl2ZUh5ZHJhdGlvbkxhbmVQcmlvcml0eTpcbiAgICBjYXNlIFJldHJ5TGFuZVByaW9yaXR5OlxuICAgICAgcmV0dXJuIE5vcm1hbFByaW9yaXR5O1xuXG4gICAgY2FzZSBJZGxlSHlkcmF0aW9uTGFuZVByaW9yaXR5OlxuICAgIGNhc2UgSWRsZUxhbmVQcmlvcml0eTpcbiAgICBjYXNlIE9mZnNjcmVlbkxhbmVQcmlvcml0eTpcbiAgICAgIHJldHVybiBJZGxlUHJpb3JpdHk7XG5cbiAgICBjYXNlIE5vTGFuZVByaW9yaXR5OlxuICAgICAgcmV0dXJuIE5vUHJpb3JpdHk7XG5cbiAgICBkZWZhdWx0OlxuICAgICAge1xuICAgICAgICB7XG4gICAgICAgICAgdGhyb3cgRXJyb3IoIFwiSW52YWxpZCB1cGRhdGUgcHJpb3JpdHk6IFwiICsgbGFuZVByaW9yaXR5ICsgXCIuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuXCIgKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gIH1cbn1cbmZ1bmN0aW9uIGdldE5leHRMYW5lcyhyb290LCB3aXBMYW5lcykge1xuICAvLyBFYXJseSBiYWlsb3V0IGlmIHRoZXJlJ3Mgbm8gcGVuZGluZyB3b3JrIGxlZnQuXG4gIHZhciBwZW5kaW5nTGFuZXMgPSByb290LnBlbmRpbmdMYW5lcztcblxuICBpZiAocGVuZGluZ0xhbmVzID09PSBOb0xhbmVzKSB7XG4gICAgcmV0dXJuX2hpZ2hlc3RMYW5lUHJpb3JpdHkgPSBOb0xhbmVQcmlvcml0eTtcbiAgICByZXR1cm4gTm9MYW5lcztcbiAgfVxuXG4gIHZhciBuZXh0TGFuZXMgPSBOb0xhbmVzO1xuICB2YXIgbmV4dExhbmVQcmlvcml0eSA9IE5vTGFuZVByaW9yaXR5O1xuICB2YXIgZXhwaXJlZExhbmVzID0gcm9vdC5leHBpcmVkTGFuZXM7XG4gIHZhciBzdXNwZW5kZWRMYW5lcyA9IHJvb3Quc3VzcGVuZGVkTGFuZXM7XG4gIHZhciBwaW5nZWRMYW5lcyA9IHJvb3QucGluZ2VkTGFuZXM7IC8vIENoZWNrIGlmIGFueSB3b3JrIGhhcyBleHBpcmVkLlxuXG4gIGlmIChleHBpcmVkTGFuZXMgIT09IE5vTGFuZXMpIHtcbiAgICBuZXh0TGFuZXMgPSBleHBpcmVkTGFuZXM7XG4gICAgbmV4dExhbmVQcmlvcml0eSA9IHJldHVybl9oaWdoZXN0TGFuZVByaW9yaXR5ID0gU3luY0xhbmVQcmlvcml0eTtcbiAgfSBlbHNlIHtcbiAgICAvLyBEbyBub3Qgd29yayBvbiBhbnkgaWRsZSB3b3JrIHVudGlsIGFsbCB0aGUgbm9uLWlkbGUgd29yayBoYXMgZmluaXNoZWQsXG4gICAgLy8gZXZlbiBpZiB0aGUgd29yayBpcyBzdXNwZW5kZWQuXG4gICAgdmFyIG5vbklkbGVQZW5kaW5nTGFuZXMgPSBwZW5kaW5nTGFuZXMgJiBOb25JZGxlTGFuZXM7XG5cbiAgICBpZiAobm9uSWRsZVBlbmRpbmdMYW5lcyAhPT0gTm9MYW5lcykge1xuICAgICAgdmFyIG5vbklkbGVVbmJsb2NrZWRMYW5lcyA9IG5vbklkbGVQZW5kaW5nTGFuZXMgJiB+c3VzcGVuZGVkTGFuZXM7XG5cbiAgICAgIGlmIChub25JZGxlVW5ibG9ja2VkTGFuZXMgIT09IE5vTGFuZXMpIHtcbiAgICAgICAgbmV4dExhbmVzID0gZ2V0SGlnaGVzdFByaW9yaXR5TGFuZXMobm9uSWRsZVVuYmxvY2tlZExhbmVzKTtcbiAgICAgICAgbmV4dExhbmVQcmlvcml0eSA9IHJldHVybl9oaWdoZXN0TGFuZVByaW9yaXR5O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIG5vbklkbGVQaW5nZWRMYW5lcyA9IG5vbklkbGVQZW5kaW5nTGFuZXMgJiBwaW5nZWRMYW5lcztcblxuICAgICAgICBpZiAobm9uSWRsZVBpbmdlZExhbmVzICE9PSBOb0xhbmVzKSB7XG4gICAgICAgICAgbmV4dExhbmVzID0gZ2V0SGlnaGVzdFByaW9yaXR5TGFuZXMobm9uSWRsZVBpbmdlZExhbmVzKTtcbiAgICAgICAgICBuZXh0TGFuZVByaW9yaXR5ID0gcmV0dXJuX2hpZ2hlc3RMYW5lUHJpb3JpdHk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVGhlIG9ubHkgcmVtYWluaW5nIHdvcmsgaXMgSWRsZS5cbiAgICAgIHZhciB1bmJsb2NrZWRMYW5lcyA9IHBlbmRpbmdMYW5lcyAmIH5zdXNwZW5kZWRMYW5lcztcblxuICAgICAgaWYgKHVuYmxvY2tlZExhbmVzICE9PSBOb0xhbmVzKSB7XG4gICAgICAgIG5leHRMYW5lcyA9IGdldEhpZ2hlc3RQcmlvcml0eUxhbmVzKHVuYmxvY2tlZExhbmVzKTtcbiAgICAgICAgbmV4dExhbmVQcmlvcml0eSA9IHJldHVybl9oaWdoZXN0TGFuZVByaW9yaXR5O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHBpbmdlZExhbmVzICE9PSBOb0xhbmVzKSB7XG4gICAgICAgICAgbmV4dExhbmVzID0gZ2V0SGlnaGVzdFByaW9yaXR5TGFuZXMocGluZ2VkTGFuZXMpO1xuICAgICAgICAgIG5leHRMYW5lUHJpb3JpdHkgPSByZXR1cm5faGlnaGVzdExhbmVQcmlvcml0eTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChuZXh0TGFuZXMgPT09IE5vTGFuZXMpIHtcbiAgICAvLyBUaGlzIHNob3VsZCBvbmx5IGJlIHJlYWNoYWJsZSBpZiB3ZSdyZSBzdXNwZW5kZWRcbiAgICAvLyBUT0RPOiBDb25zaWRlciB3YXJuaW5nIGluIHRoaXMgcGF0aCBpZiBhIGZhbGxiYWNrIHRpbWVyIGlzIG5vdCBzY2hlZHVsZWQuXG4gICAgcmV0dXJuIE5vTGFuZXM7XG4gIH0gLy8gSWYgdGhlcmUgYXJlIGhpZ2hlciBwcmlvcml0eSBsYW5lcywgd2UnbGwgaW5jbHVkZSB0aGVtIGV2ZW4gaWYgdGhleVxuICAvLyBhcmUgc3VzcGVuZGVkLlxuXG5cbiAgbmV4dExhbmVzID0gcGVuZGluZ0xhbmVzICYgZ2V0RXF1YWxPckhpZ2hlclByaW9yaXR5TGFuZXMobmV4dExhbmVzKTsgLy8gSWYgd2UncmUgYWxyZWFkeSBpbiB0aGUgbWlkZGxlIG9mIGEgcmVuZGVyLCBzd2l0Y2hpbmcgbGFuZXMgd2lsbCBpbnRlcnJ1cHRcbiAgLy8gaXQgYW5kIHdlJ2xsIGxvc2Ugb3VyIHByb2dyZXNzLiBXZSBzaG91bGQgb25seSBkbyB0aGlzIGlmIHRoZSBuZXcgbGFuZXMgYXJlXG4gIC8vIGhpZ2hlciBwcmlvcml0eS5cblxuICBpZiAod2lwTGFuZXMgIT09IE5vTGFuZXMgJiYgd2lwTGFuZXMgIT09IG5leHRMYW5lcyAmJiAvLyBJZiB3ZSBhbHJlYWR5IHN1c3BlbmRlZCB3aXRoIGEgZGVsYXksIHRoZW4gaW50ZXJydXB0aW5nIGlzIGZpbmUuIERvbid0XG4gIC8vIGJvdGhlciB3YWl0aW5nIHVudGlsIHRoZSByb290IGlzIGNvbXBsZXRlLlxuICAod2lwTGFuZXMgJiBzdXNwZW5kZWRMYW5lcykgPT09IE5vTGFuZXMpIHtcbiAgICBnZXRIaWdoZXN0UHJpb3JpdHlMYW5lcyh3aXBMYW5lcyk7XG4gICAgdmFyIHdpcExhbmVQcmlvcml0eSA9IHJldHVybl9oaWdoZXN0TGFuZVByaW9yaXR5O1xuXG4gICAgaWYgKG5leHRMYW5lUHJpb3JpdHkgPD0gd2lwTGFuZVByaW9yaXR5KSB7XG4gICAgICByZXR1cm4gd2lwTGFuZXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybl9oaWdoZXN0TGFuZVByaW9yaXR5ID0gbmV4dExhbmVQcmlvcml0eTtcbiAgICB9XG4gIH0gLy8gQ2hlY2sgZm9yIGVudGFuZ2xlZCBsYW5lcyBhbmQgYWRkIHRoZW0gdG8gdGhlIGJhdGNoLlxuICAvL1xuICAvLyBBIGxhbmUgaXMgc2FpZCB0byBiZSBlbnRhbmdsZWQgd2l0aCBhbm90aGVyIHdoZW4gaXQncyBub3QgYWxsb3dlZCB0byByZW5kZXJcbiAgLy8gaW4gYSBiYXRjaCB0aGF0IGRvZXMgbm90IGFsc28gaW5jbHVkZSB0aGUgb3RoZXIgbGFuZS4gVHlwaWNhbGx5IHdlIGRvIHRoaXNcbiAgLy8gd2hlbiBtdWx0aXBsZSB1cGRhdGVzIGhhdmUgdGhlIHNhbWUgc291cmNlLCBhbmQgd2Ugb25seSB3YW50IHRvIHJlc3BvbmQgdG9cbiAgLy8gdGhlIG1vc3QgcmVjZW50IGV2ZW50IGZyb20gdGhhdCBzb3VyY2UuXG4gIC8vXG4gIC8vIE5vdGUgdGhhdCB3ZSBhcHBseSBlbnRhbmdsZW1lbnRzICphZnRlciogY2hlY2tpbmcgZm9yIHBhcnRpYWwgd29yayBhYm92ZS5cbiAgLy8gVGhpcyBtZWFucyB0aGF0IGlmIGEgbGFuZSBpcyBlbnRhbmdsZWQgZHVyaW5nIGFuIGludGVybGVhdmVkIGV2ZW50IHdoaWxlXG4gIC8vIGl0J3MgYWxyZWFkeSByZW5kZXJpbmcsIHdlIHdvbid0IGludGVycnVwdCBpdC4gVGhpcyBpcyBpbnRlbnRpb25hbCwgc2luY2VcbiAgLy8gZW50YW5nbGVtZW50IGlzIHVzdWFsbHkgXCJiZXN0IGVmZm9ydFwiOiB3ZSdsbCB0cnkgb3VyIGJlc3QgdG8gcmVuZGVyIHRoZVxuICAvLyBsYW5lcyBpbiB0aGUgc2FtZSBiYXRjaCwgYnV0IGl0J3Mgbm90IHdvcnRoIHRocm93aW5nIG91dCBwYXJ0aWFsbHlcbiAgLy8gY29tcGxldGVkIHdvcmsgaW4gb3JkZXIgdG8gZG8gaXQuXG4gIC8vXG4gIC8vIEZvciB0aG9zZSBleGNlcHRpb25zIHdoZXJlIGVudGFuZ2xlbWVudCBpcyBzZW1hbnRpY2FsbHkgaW1wb3J0YW50LCBsaWtlXG4gIC8vIHVzZU11dGFibGVTb3VyY2UsIHdlIHNob3VsZCBlbnN1cmUgdGhhdCB0aGVyZSBpcyBubyBwYXJ0aWFsIHdvcmsgYXQgdGhlXG4gIC8vIHRpbWUgd2UgYXBwbHkgdGhlIGVudGFuZ2xlbWVudC5cblxuXG4gIHZhciBlbnRhbmdsZWRMYW5lcyA9IHJvb3QuZW50YW5nbGVkTGFuZXM7XG5cbiAgaWYgKGVudGFuZ2xlZExhbmVzICE9PSBOb0xhbmVzKSB7XG4gICAgdmFyIGVudGFuZ2xlbWVudHMgPSByb290LmVudGFuZ2xlbWVudHM7XG4gICAgdmFyIGxhbmVzID0gbmV4dExhbmVzICYgZW50YW5nbGVkTGFuZXM7XG5cbiAgICB3aGlsZSAobGFuZXMgPiAwKSB7XG4gICAgICB2YXIgaW5kZXggPSBwaWNrQXJiaXRyYXJ5TGFuZUluZGV4KGxhbmVzKTtcbiAgICAgIHZhciBsYW5lID0gMSA8PCBpbmRleDtcbiAgICAgIG5leHRMYW5lcyB8PSBlbnRhbmdsZW1lbnRzW2luZGV4XTtcbiAgICAgIGxhbmVzICY9IH5sYW5lO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuZXh0TGFuZXM7XG59XG5mdW5jdGlvbiBnZXRNb3N0UmVjZW50RXZlbnRUaW1lKHJvb3QsIGxhbmVzKSB7XG4gIHZhciBldmVudFRpbWVzID0gcm9vdC5ldmVudFRpbWVzO1xuICB2YXIgbW9zdFJlY2VudEV2ZW50VGltZSA9IE5vVGltZXN0YW1wO1xuXG4gIHdoaWxlIChsYW5lcyA+IDApIHtcbiAgICB2YXIgaW5kZXggPSBwaWNrQXJiaXRyYXJ5TGFuZUluZGV4KGxhbmVzKTtcbiAgICB2YXIgbGFuZSA9IDEgPDwgaW5kZXg7XG4gICAgdmFyIGV2ZW50VGltZSA9IGV2ZW50VGltZXNbaW5kZXhdO1xuXG4gICAgaWYgKGV2ZW50VGltZSA+IG1vc3RSZWNlbnRFdmVudFRpbWUpIHtcbiAgICAgIG1vc3RSZWNlbnRFdmVudFRpbWUgPSBldmVudFRpbWU7XG4gICAgfVxuXG4gICAgbGFuZXMgJj0gfmxhbmU7XG4gIH1cblxuICByZXR1cm4gbW9zdFJlY2VudEV2ZW50VGltZTtcbn1cblxuZnVuY3Rpb24gY29tcHV0ZUV4cGlyYXRpb25UaW1lKGxhbmUsIGN1cnJlbnRUaW1lKSB7XG4gIC8vIFRPRE86IEV4cGlyYXRpb24gaGV1cmlzdGljIGlzIGNvbnN0YW50IHBlciBsYW5lLCBzbyBjb3VsZCB1c2UgYSBtYXAuXG4gIGdldEhpZ2hlc3RQcmlvcml0eUxhbmVzKGxhbmUpO1xuICB2YXIgcHJpb3JpdHkgPSByZXR1cm5faGlnaGVzdExhbmVQcmlvcml0eTtcblxuICBpZiAocHJpb3JpdHkgPj0gSW5wdXRDb250aW51b3VzTGFuZVByaW9yaXR5KSB7XG4gICAgLy8gVXNlciBpbnRlcmFjdGlvbnMgc2hvdWxkIGV4cGlyZSBzbGlnaHRseSBtb3JlIHF1aWNrbHkuXG4gICAgLy9cbiAgICAvLyBOT1RFOiBUaGlzIGlzIHNldCB0byB0aGUgY29ycmVzcG9uZGluZyBjb25zdGFudCBhcyBpbiBTY2hlZHVsZXIuanMuIFdoZW5cbiAgICAvLyB3ZSBtYWRlIGl0IGxhcmdlciwgYSBwcm9kdWN0IG1ldHJpYyBpbiB3d3cgcmVncmVzc2VkLCBzdWdnZXN0aW5nIHRoZXJlJ3NcbiAgICAvLyBhIHVzZXIgaW50ZXJhY3Rpb24gdGhhdCdzIGJlaW5nIHN0YXJ2ZWQgYnkgYSBzZXJpZXMgb2Ygc3luY2hyb25vdXNcbiAgICAvLyB1cGRhdGVzLiBJZiB0aGF0IHRoZW9yeSBpcyBjb3JyZWN0LCB0aGUgcHJvcGVyIHNvbHV0aW9uIGlzIHRvIGZpeCB0aGVcbiAgICAvLyBzdGFydmF0aW9uLiBIb3dldmVyLCB0aGlzIHNjZW5hcmlvIHN1cHBvcnRzIHRoZSBpZGVhIHRoYXQgZXhwaXJhdGlvblxuICAgIC8vIHRpbWVzIGFyZSBhbiBpbXBvcnRhbnQgc2FmZWd1YXJkIHdoZW4gc3RhcnZhdGlvbiBkb2VzIGhhcHBlbi5cbiAgICAvL1xuICAgIC8vIEFsc28gbm90ZSB0aGF0LCBpbiB0aGUgY2FzZSBvZiB1c2VyIGlucHV0IHNwZWNpZmljYWxseSwgdGhpcyB3aWxsIHNvb24gbm9cbiAgICAvLyBsb25nZXIgYmUgYW4gaXNzdWUgYmVjYXVzZSB3ZSBwbGFuIHRvIG1ha2UgdXNlciBpbnB1dCBzeW5jaHJvbm91cyBieVxuICAgIC8vIGRlZmF1bHQgKHVudGlsIHlvdSBlbnRlciBgc3RhcnRUcmFuc2l0aW9uYCwgb2YgY291cnNlLilcbiAgICAvL1xuICAgIC8vIElmIHdlcmVuJ3QgcGxhbm5pbmcgdG8gbWFrZSB0aGVzZSB1cGRhdGVzIHN5bmNocm9ub3VzIHNvb24gYW55d2F5LCBJXG4gICAgLy8gd291bGQgcHJvYmFibHkgbWFrZSB0aGlzIG51bWJlciBhIGNvbmZpZ3VyYWJsZSBwYXJhbWV0ZXIuXG4gICAgcmV0dXJuIGN1cnJlbnRUaW1lICsgMjUwO1xuICB9IGVsc2UgaWYgKHByaW9yaXR5ID49IFRyYW5zaXRpb25Qcmlvcml0eSkge1xuICAgIHJldHVybiBjdXJyZW50VGltZSArIDUwMDA7XG4gIH0gZWxzZSB7XG4gICAgLy8gQW55dGhpbmcgaWRsZSBwcmlvcml0eSBvciBsb3dlciBzaG91bGQgbmV2ZXIgZXhwaXJlLlxuICAgIHJldHVybiBOb1RpbWVzdGFtcDtcbiAgfVxufVxuXG5mdW5jdGlvbiBtYXJrU3RhcnZlZExhbmVzQXNFeHBpcmVkKHJvb3QsIGN1cnJlbnRUaW1lKSB7XG4gIC8vIFRPRE86IFRoaXMgZ2V0cyBjYWxsZWQgZXZlcnkgdGltZSB3ZSB5aWVsZC4gV2UgY2FuIG9wdGltaXplIGJ5IHN0b3JpbmdcbiAgLy8gdGhlIGVhcmxpZXN0IGV4cGlyYXRpb24gdGltZSBvbiB0aGUgcm9vdC4gVGhlbiB1c2UgdGhhdCB0byBxdWlja2x5IGJhaWwgb3V0XG4gIC8vIG9mIHRoaXMgZnVuY3Rpb24uXG4gIHZhciBwZW5kaW5nTGFuZXMgPSByb290LnBlbmRpbmdMYW5lcztcbiAgdmFyIHN1c3BlbmRlZExhbmVzID0gcm9vdC5zdXNwZW5kZWRMYW5lcztcbiAgdmFyIHBpbmdlZExhbmVzID0gcm9vdC5waW5nZWRMYW5lcztcbiAgdmFyIGV4cGlyYXRpb25UaW1lcyA9IHJvb3QuZXhwaXJhdGlvblRpbWVzOyAvLyBJdGVyYXRlIHRocm91Z2ggdGhlIHBlbmRpbmcgbGFuZXMgYW5kIGNoZWNrIGlmIHdlJ3ZlIHJlYWNoZWQgdGhlaXJcbiAgLy8gZXhwaXJhdGlvbiB0aW1lLiBJZiBzbywgd2UnbGwgYXNzdW1lIHRoZSB1cGRhdGUgaXMgYmVpbmcgc3RhcnZlZCBhbmQgbWFya1xuICAvLyBpdCBhcyBleHBpcmVkIHRvIGZvcmNlIGl0IHRvIGZpbmlzaC5cblxuICB2YXIgbGFuZXMgPSBwZW5kaW5nTGFuZXM7XG5cbiAgd2hpbGUgKGxhbmVzID4gMCkge1xuICAgIHZhciBpbmRleCA9IHBpY2tBcmJpdHJhcnlMYW5lSW5kZXgobGFuZXMpO1xuICAgIHZhciBsYW5lID0gMSA8PCBpbmRleDtcbiAgICB2YXIgZXhwaXJhdGlvblRpbWUgPSBleHBpcmF0aW9uVGltZXNbaW5kZXhdO1xuXG4gICAgaWYgKGV4cGlyYXRpb25UaW1lID09PSBOb1RpbWVzdGFtcCkge1xuICAgICAgLy8gRm91bmQgYSBwZW5kaW5nIGxhbmUgd2l0aCBubyBleHBpcmF0aW9uIHRpbWUuIElmIGl0J3Mgbm90IHN1c3BlbmRlZCwgb3JcbiAgICAgIC8vIGlmIGl0J3MgcGluZ2VkLCBhc3N1bWUgaXQncyBDUFUtYm91bmQuIENvbXB1dGUgYSBuZXcgZXhwaXJhdGlvbiB0aW1lXG4gICAgICAvLyB1c2luZyB0aGUgY3VycmVudCB0aW1lLlxuICAgICAgaWYgKChsYW5lICYgc3VzcGVuZGVkTGFuZXMpID09PSBOb0xhbmVzIHx8IChsYW5lICYgcGluZ2VkTGFuZXMpICE9PSBOb0xhbmVzKSB7XG4gICAgICAgIC8vIEFzc3VtZXMgdGltZXN0YW1wcyBhcmUgbW9ub3RvbmljYWxseSBpbmNyZWFzaW5nLlxuICAgICAgICBleHBpcmF0aW9uVGltZXNbaW5kZXhdID0gY29tcHV0ZUV4cGlyYXRpb25UaW1lKGxhbmUsIGN1cnJlbnRUaW1lKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGV4cGlyYXRpb25UaW1lIDw9IGN1cnJlbnRUaW1lKSB7XG4gICAgICAvLyBUaGlzIGxhbmUgZXhwaXJlZFxuICAgICAgcm9vdC5leHBpcmVkTGFuZXMgfD0gbGFuZTtcbiAgICB9XG5cbiAgICBsYW5lcyAmPSB+bGFuZTtcbiAgfVxufSAvLyBUaGlzIHJldHVybnMgdGhlIGhpZ2hlc3QgcHJpb3JpdHkgcGVuZGluZyBsYW5lcyByZWdhcmRsZXNzIG9mIHdoZXRoZXIgdGhleVxuZnVuY3Rpb24gZ2V0TGFuZXNUb1JldHJ5U3luY2hyb25vdXNseU9uRXJyb3Iocm9vdCkge1xuICB2YXIgZXZlcnl0aGluZ0J1dE9mZnNjcmVlbiA9IHJvb3QucGVuZGluZ0xhbmVzICYgfk9mZnNjcmVlbkxhbmU7XG5cbiAgaWYgKGV2ZXJ5dGhpbmdCdXRPZmZzY3JlZW4gIT09IE5vTGFuZXMpIHtcbiAgICByZXR1cm4gZXZlcnl0aGluZ0J1dE9mZnNjcmVlbjtcbiAgfVxuXG4gIGlmIChldmVyeXRoaW5nQnV0T2Zmc2NyZWVuICYgT2Zmc2NyZWVuTGFuZSkge1xuICAgIHJldHVybiBPZmZzY3JlZW5MYW5lO1xuICB9XG5cbiAgcmV0dXJuIE5vTGFuZXM7XG59XG5mdW5jdGlvbiByZXR1cm5OZXh0TGFuZXNQcmlvcml0eSgpIHtcbiAgcmV0dXJuIHJldHVybl9oaWdoZXN0TGFuZVByaW9yaXR5O1xufVxuZnVuY3Rpb24gaW5jbHVkZXNOb25JZGxlV29yayhsYW5lcykge1xuICByZXR1cm4gKGxhbmVzICYgTm9uSWRsZUxhbmVzKSAhPT0gTm9MYW5lcztcbn1cbmZ1bmN0aW9uIGluY2x1ZGVzT25seVJldHJpZXMobGFuZXMpIHtcbiAgcmV0dXJuIChsYW5lcyAmIFJldHJ5TGFuZXMpID09PSBsYW5lcztcbn1cbmZ1bmN0aW9uIGluY2x1ZGVzT25seVRyYW5zaXRpb25zKGxhbmVzKSB7XG4gIHJldHVybiAobGFuZXMgJiBUcmFuc2l0aW9uTGFuZXMpID09PSBsYW5lcztcbn0gLy8gVG8gZW5zdXJlIGNvbnNpc3RlbmN5IGFjcm9zcyBtdWx0aXBsZSB1cGRhdGVzIGluIHRoZSBzYW1lIGV2ZW50LCB0aGlzIHNob3VsZFxuLy8gYmUgYSBwdXJlIGZ1bmN0aW9uLCBzbyB0aGF0IGl0IGFsd2F5cyByZXR1cm5zIHRoZSBzYW1lIGxhbmUgZm9yIGdpdmVuIGlucHV0cy5cblxuZnVuY3Rpb24gZmluZFVwZGF0ZUxhbmUobGFuZVByaW9yaXR5LCB3aXBMYW5lcykge1xuICBzd2l0Y2ggKGxhbmVQcmlvcml0eSkge1xuICAgIGNhc2UgTm9MYW5lUHJpb3JpdHk6XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgU3luY0xhbmVQcmlvcml0eTpcbiAgICAgIHJldHVybiBTeW5jTGFuZTtcblxuICAgIGNhc2UgU3luY0JhdGNoZWRMYW5lUHJpb3JpdHk6XG4gICAgICByZXR1cm4gU3luY0JhdGNoZWRMYW5lO1xuXG4gICAgY2FzZSBJbnB1dERpc2NyZXRlTGFuZVByaW9yaXR5OlxuICAgICAge1xuICAgICAgICB2YXIgX2xhbmUgPSBwaWNrQXJiaXRyYXJ5TGFuZShJbnB1dERpc2NyZXRlTGFuZXMgJiB+d2lwTGFuZXMpO1xuXG4gICAgICAgIGlmIChfbGFuZSA9PT0gTm9MYW5lKSB7XG4gICAgICAgICAgLy8gU2hpZnQgdG8gdGhlIG5leHQgcHJpb3JpdHkgbGV2ZWxcbiAgICAgICAgICByZXR1cm4gZmluZFVwZGF0ZUxhbmUoSW5wdXRDb250aW51b3VzTGFuZVByaW9yaXR5LCB3aXBMYW5lcyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gX2xhbmU7XG4gICAgICB9XG5cbiAgICBjYXNlIElucHV0Q29udGludW91c0xhbmVQcmlvcml0eTpcbiAgICAgIHtcbiAgICAgICAgdmFyIF9sYW5lMiA9IHBpY2tBcmJpdHJhcnlMYW5lKElucHV0Q29udGludW91c0xhbmVzICYgfndpcExhbmVzKTtcblxuICAgICAgICBpZiAoX2xhbmUyID09PSBOb0xhbmUpIHtcbiAgICAgICAgICAvLyBTaGlmdCB0byB0aGUgbmV4dCBwcmlvcml0eSBsZXZlbFxuICAgICAgICAgIHJldHVybiBmaW5kVXBkYXRlTGFuZShEZWZhdWx0TGFuZVByaW9yaXR5LCB3aXBMYW5lcyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gX2xhbmUyO1xuICAgICAgfVxuXG4gICAgY2FzZSBEZWZhdWx0TGFuZVByaW9yaXR5OlxuICAgICAge1xuICAgICAgICB2YXIgX2xhbmUzID0gcGlja0FyYml0cmFyeUxhbmUoRGVmYXVsdExhbmVzICYgfndpcExhbmVzKTtcblxuICAgICAgICBpZiAoX2xhbmUzID09PSBOb0xhbmUpIHtcbiAgICAgICAgICAvLyBJZiBhbGwgdGhlIGRlZmF1bHQgbGFuZXMgYXJlIGFscmVhZHkgYmVpbmcgd29ya2VkIG9uLCBsb29rIGZvciBhXG4gICAgICAgICAgLy8gbGFuZSBpbiB0aGUgdHJhbnNpdGlvbiByYW5nZS5cbiAgICAgICAgICBfbGFuZTMgPSBwaWNrQXJiaXRyYXJ5TGFuZShUcmFuc2l0aW9uTGFuZXMgJiB+d2lwTGFuZXMpO1xuXG4gICAgICAgICAgaWYgKF9sYW5lMyA9PT0gTm9MYW5lKSB7XG4gICAgICAgICAgICAvLyBBbGwgdGhlIHRyYW5zaXRpb24gbGFuZXMgYXJlIHRha2VuLCB0b28uIFRoaXMgc2hvdWxkIGJlIHZlcnlcbiAgICAgICAgICAgIC8vIHJhcmUsIGJ1dCBhcyBhIGxhc3QgcmVzb3J0LCBwaWNrIGEgZGVmYXVsdCBsYW5lLiBUaGlzIHdpbGwgaGF2ZVxuICAgICAgICAgICAgLy8gdGhlIGVmZmVjdCBvZiBpbnRlcnJ1cHRpbmcgdGhlIGN1cnJlbnQgd29yay1pbi1wcm9ncmVzcyByZW5kZXIuXG4gICAgICAgICAgICBfbGFuZTMgPSBwaWNrQXJiaXRyYXJ5TGFuZShEZWZhdWx0TGFuZXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBfbGFuZTM7XG4gICAgICB9XG5cbiAgICBjYXNlIFRyYW5zaXRpb25Qcmlvcml0eTogLy8gU2hvdWxkIGJlIGhhbmRsZWQgYnkgZmluZFRyYW5zaXRpb25MYW5lIGluc3RlYWRcblxuICAgIGNhc2UgUmV0cnlMYW5lUHJpb3JpdHk6XG4gICAgICAvLyBTaG91bGQgYmUgaGFuZGxlZCBieSBmaW5kUmV0cnlMYW5lIGluc3RlYWRcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBJZGxlTGFuZVByaW9yaXR5OlxuICAgICAgdmFyIGxhbmUgPSBwaWNrQXJiaXRyYXJ5TGFuZShJZGxlTGFuZXMgJiB+d2lwTGFuZXMpO1xuXG4gICAgICBpZiAobGFuZSA9PT0gTm9MYW5lKSB7XG4gICAgICAgIGxhbmUgPSBwaWNrQXJiaXRyYXJ5TGFuZShJZGxlTGFuZXMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbGFuZTtcbiAgfVxuXG4gIHtcbiAgICB7XG4gICAgICB0aHJvdyBFcnJvciggXCJJbnZhbGlkIHVwZGF0ZSBwcmlvcml0eTogXCIgKyBsYW5lUHJpb3JpdHkgKyBcIi4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC5cIiApO1xuICAgIH1cbiAgfVxufSAvLyBUbyBlbnN1cmUgY29uc2lzdGVuY3kgYWNyb3NzIG11bHRpcGxlIHVwZGF0ZXMgaW4gdGhlIHNhbWUgZXZlbnQsIHRoaXMgc2hvdWxkXG4vLyBiZSBwdXJlIGZ1bmN0aW9uLCBzbyB0aGF0IGl0IGFsd2F5cyByZXR1cm5zIHRoZSBzYW1lIGxhbmUgZm9yIGdpdmVuIGlucHV0cy5cblxuZnVuY3Rpb24gZmluZFRyYW5zaXRpb25MYW5lKHdpcExhbmVzLCBwZW5kaW5nTGFuZXMpIHtcbiAgLy8gRmlyc3QgbG9vayBmb3IgbGFuZXMgdGhhdCBhcmUgY29tcGxldGVseSB1bmNsYWltZWQsIGkuZS4gaGF2ZSBub1xuICAvLyBwZW5kaW5nIHdvcmsuXG4gIHZhciBsYW5lID0gcGlja0FyYml0cmFyeUxhbmUoVHJhbnNpdGlvbkxhbmVzICYgfnBlbmRpbmdMYW5lcyk7XG5cbiAgaWYgKGxhbmUgPT09IE5vTGFuZSkge1xuICAgIC8vIElmIGFsbCBsYW5lcyBoYXZlIHBlbmRpbmcgd29yaywgbG9vayBmb3IgYSBsYW5lIHRoYXQgaXNuJ3QgY3VycmVudGx5XG4gICAgLy8gYmVpbmcgd29ya2VkIG9uLlxuICAgIGxhbmUgPSBwaWNrQXJiaXRyYXJ5TGFuZShUcmFuc2l0aW9uTGFuZXMgJiB+d2lwTGFuZXMpO1xuXG4gICAgaWYgKGxhbmUgPT09IE5vTGFuZSkge1xuICAgICAgLy8gSWYgZXZlcnl0aGluZyBpcyBiZWluZyB3b3JrZWQgb24sIHBpY2sgYW55IGxhbmUuIFRoaXMgaGFzIHRoZVxuICAgICAgLy8gZWZmZWN0IG9mIGludGVycnVwdGluZyB0aGUgY3VycmVudCB3b3JrLWluLXByb2dyZXNzLlxuICAgICAgbGFuZSA9IHBpY2tBcmJpdHJhcnlMYW5lKFRyYW5zaXRpb25MYW5lcyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGxhbmU7XG59IC8vIFRvIGVuc3VyZSBjb25zaXN0ZW5jeSBhY3Jvc3MgbXVsdGlwbGUgdXBkYXRlcyBpbiB0aGUgc2FtZSBldmVudCwgdGhpcyBzaG91bGRcbi8vIGJlIHB1cmUgZnVuY3Rpb24sIHNvIHRoYXQgaXQgYWx3YXlzIHJldHVybnMgdGhlIHNhbWUgbGFuZSBmb3IgZ2l2ZW4gaW5wdXRzLlxuXG5mdW5jdGlvbiBmaW5kUmV0cnlMYW5lKHdpcExhbmVzKSB7XG4gIC8vIFRoaXMgaXMgYSBmb3JrIG9mIGBmaW5kVXBkYXRlTGFuZWAgZGVzaWduZWQgc3BlY2lmaWNhbGx5IGZvciBTdXNwZW5zZVxuICAvLyBcInJldHJpZXNcIiDigJQgYSBzcGVjaWFsIHVwZGF0ZSB0aGF0IGF0dGVtcHRzIHRvIGZsaXAgYSBTdXNwZW5zZSBib3VuZGFyeVxuICAvLyBmcm9tIGl0cyBwbGFjZWhvbGRlciBzdGF0ZSB0byBpdHMgcHJpbWFyeS9yZXNvbHZlZCBzdGF0ZS5cbiAgdmFyIGxhbmUgPSBwaWNrQXJiaXRyYXJ5TGFuZShSZXRyeUxhbmVzICYgfndpcExhbmVzKTtcblxuICBpZiAobGFuZSA9PT0gTm9MYW5lKSB7XG4gICAgbGFuZSA9IHBpY2tBcmJpdHJhcnlMYW5lKFJldHJ5TGFuZXMpO1xuICB9XG5cbiAgcmV0dXJuIGxhbmU7XG59XG5cbmZ1bmN0aW9uIGdldEhpZ2hlc3RQcmlvcml0eUxhbmUobGFuZXMpIHtcbiAgcmV0dXJuIGxhbmVzICYgLWxhbmVzO1xufVxuXG5mdW5jdGlvbiBnZXRMb3dlc3RQcmlvcml0eUxhbmUobGFuZXMpIHtcbiAgLy8gVGhpcyBmaW5kcyB0aGUgbW9zdCBzaWduaWZpY2FudCBub24temVybyBiaXQuXG4gIHZhciBpbmRleCA9IDMxIC0gY2x6MzIobGFuZXMpO1xuICByZXR1cm4gaW5kZXggPCAwID8gTm9MYW5lcyA6IDEgPDwgaW5kZXg7XG59XG5cbmZ1bmN0aW9uIGdldEVxdWFsT3JIaWdoZXJQcmlvcml0eUxhbmVzKGxhbmVzKSB7XG4gIHJldHVybiAoZ2V0TG93ZXN0UHJpb3JpdHlMYW5lKGxhbmVzKSA8PCAxKSAtIDE7XG59XG5cbmZ1bmN0aW9uIHBpY2tBcmJpdHJhcnlMYW5lKGxhbmVzKSB7XG4gIC8vIFRoaXMgd3JhcHBlciBmdW5jdGlvbiBnZXRzIGlubGluZWQuIE9ubHkgZXhpc3RzIHNvIHRvIGNvbW11bmljYXRlIHRoYXQgaXRcbiAgLy8gZG9lc24ndCBtYXR0ZXIgd2hpY2ggYml0IGlzIHNlbGVjdGVkOyB5b3UgY2FuIHBpY2sgYW55IGJpdCB3aXRob3V0XG4gIC8vIGFmZmVjdGluZyB0aGUgYWxnb3JpdGhtcyB3aGVyZSBpdHMgdXNlZC4gSGVyZSBJJ20gdXNpbmdcbiAgLy8gZ2V0SGlnaGVzdFByaW9yaXR5TGFuZSBiZWNhdXNlIGl0IHJlcXVpcmVzIHRoZSBmZXdlc3Qgb3BlcmF0aW9ucy5cbiAgcmV0dXJuIGdldEhpZ2hlc3RQcmlvcml0eUxhbmUobGFuZXMpO1xufVxuXG5mdW5jdGlvbiBwaWNrQXJiaXRyYXJ5TGFuZUluZGV4KGxhbmVzKSB7XG4gIHJldHVybiAzMSAtIGNsejMyKGxhbmVzKTtcbn1cblxuZnVuY3Rpb24gbGFuZVRvSW5kZXgobGFuZSkge1xuICByZXR1cm4gcGlja0FyYml0cmFyeUxhbmVJbmRleChsYW5lKTtcbn1cblxuZnVuY3Rpb24gaW5jbHVkZXNTb21lTGFuZShhLCBiKSB7XG4gIHJldHVybiAoYSAmIGIpICE9PSBOb0xhbmVzO1xufVxuZnVuY3Rpb24gaXNTdWJzZXRPZkxhbmVzKHNldCwgc3Vic2V0KSB7XG4gIHJldHVybiAoc2V0ICYgc3Vic2V0KSA9PT0gc3Vic2V0O1xufVxuZnVuY3Rpb24gbWVyZ2VMYW5lcyhhLCBiKSB7XG4gIHJldHVybiBhIHwgYjtcbn1cbmZ1bmN0aW9uIHJlbW92ZUxhbmVzKHNldCwgc3Vic2V0KSB7XG4gIHJldHVybiBzZXQgJiB+c3Vic2V0O1xufSAvLyBTZWVtcyByZWR1bmRhbnQsIGJ1dCBpdCBjaGFuZ2VzIHRoZSB0eXBlIGZyb20gYSBzaW5nbGUgbGFuZSAodXNlZCBmb3Jcbi8vIHVwZGF0ZXMpIHRvIGEgZ3JvdXAgb2YgbGFuZXMgKHVzZWQgZm9yIGZsdXNoaW5nIHdvcmspLlxuXG5mdW5jdGlvbiBsYW5lVG9MYW5lcyhsYW5lKSB7XG4gIHJldHVybiBsYW5lO1xufVxuZnVuY3Rpb24gaGlnaGVyUHJpb3JpdHlMYW5lKGEsIGIpIHtcbiAgLy8gVGhpcyB3b3JrcyBiZWNhdXNlIHRoZSBiaXQgcmFuZ2VzIGRlY3JlYXNlIGluIHByaW9yaXR5IGFzIHlvdSBnbyBsZWZ0LlxuICByZXR1cm4gYSAhPT0gTm9MYW5lICYmIGEgPCBiID8gYSA6IGI7XG59XG5mdW5jdGlvbiBjcmVhdGVMYW5lTWFwKGluaXRpYWwpIHtcbiAgLy8gSW50ZW50aW9uYWxseSBwdXNoaW5nIG9uZSBieSBvbmUuXG4gIC8vIGh0dHBzOi8vdjguZGV2L2Jsb2cvZWxlbWVudHMta2luZHMjYXZvaWQtY3JlYXRpbmctaG9sZXNcbiAgdmFyIGxhbmVNYXAgPSBbXTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IFRvdGFsTGFuZXM7IGkrKykge1xuICAgIGxhbmVNYXAucHVzaChpbml0aWFsKTtcbiAgfVxuXG4gIHJldHVybiBsYW5lTWFwO1xufVxuZnVuY3Rpb24gbWFya1Jvb3RVcGRhdGVkKHJvb3QsIHVwZGF0ZUxhbmUsIGV2ZW50VGltZSkge1xuICByb290LnBlbmRpbmdMYW5lcyB8PSB1cGRhdGVMYW5lOyAvLyBUT0RPOiBUaGVvcmV0aWNhbGx5LCBhbnkgdXBkYXRlIHRvIGFueSBsYW5lIGNhbiB1bmJsb2NrIGFueSBvdGhlciBsYW5lLiBCdXRcbiAgLy8gaXQncyBub3QgcHJhY3RpY2FsIHRvIHRyeSBldmVyeSBzaW5nbGUgcG9zc2libGUgY29tYmluYXRpb24uIFdlIG5lZWQgYVxuICAvLyBoZXVyaXN0aWMgdG8gZGVjaWRlIHdoaWNoIGxhbmVzIHRvIGF0dGVtcHQgdG8gcmVuZGVyLCBhbmQgaW4gd2hpY2ggYmF0Y2hlcy5cbiAgLy8gRm9yIG5vdywgd2UgdXNlIHRoZSBzYW1lIGhldXJpc3RpYyBhcyBpbiB0aGUgb2xkIEV4cGlyYXRpb25UaW1lcyBtb2RlbDpcbiAgLy8gcmV0cnkgYW55IGxhbmUgYXQgZXF1YWwgb3IgbG93ZXIgcHJpb3JpdHksIGJ1dCBkb24ndCB0cnkgdXBkYXRlcyBhdCBoaWdoZXJcbiAgLy8gcHJpb3JpdHkgd2l0aG91dCBhbHNvIGluY2x1ZGluZyB0aGUgbG93ZXIgcHJpb3JpdHkgdXBkYXRlcy4gVGhpcyB3b3JrcyB3ZWxsXG4gIC8vIHdoZW4gY29uc2lkZXJpbmcgdXBkYXRlcyBhY3Jvc3MgZGlmZmVyZW50IHByaW9yaXR5IGxldmVscywgYnV0IGlzbid0XG4gIC8vIHN1ZmZpY2llbnQgZm9yIHVwZGF0ZXMgd2l0aGluIHRoZSBzYW1lIHByaW9yaXR5LCBzaW5jZSB3ZSB3YW50IHRvIHRyZWF0XG4gIC8vIHRob3NlIHVwZGF0ZXMgYXMgcGFyYWxsZWwuXG4gIC8vIFVuc3VzcGVuZCBhbnkgdXBkYXRlIGF0IGVxdWFsIG9yIGxvd2VyIHByaW9yaXR5LlxuXG4gIHZhciBoaWdoZXJQcmlvcml0eUxhbmVzID0gdXBkYXRlTGFuZSAtIDE7IC8vIFR1cm5zIDBiMTAwMCBpbnRvIDBiMDExMVxuXG4gIHJvb3Quc3VzcGVuZGVkTGFuZXMgJj0gaGlnaGVyUHJpb3JpdHlMYW5lcztcbiAgcm9vdC5waW5nZWRMYW5lcyAmPSBoaWdoZXJQcmlvcml0eUxhbmVzO1xuICB2YXIgZXZlbnRUaW1lcyA9IHJvb3QuZXZlbnRUaW1lcztcbiAgdmFyIGluZGV4ID0gbGFuZVRvSW5kZXgodXBkYXRlTGFuZSk7IC8vIFdlIGNhbiBhbHdheXMgb3ZlcndyaXRlIGFuIGV4aXN0aW5nIHRpbWVzdGFtcCBiZWNhdXNlIHdlIHByZWZlciB0aGUgbW9zdFxuICAvLyByZWNlbnQgZXZlbnQsIGFuZCB3ZSBhc3N1bWUgdGltZSBpcyBtb25vdG9uaWNhbGx5IGluY3JlYXNpbmcuXG5cbiAgZXZlbnRUaW1lc1tpbmRleF0gPSBldmVudFRpbWU7XG59XG5mdW5jdGlvbiBtYXJrUm9vdFN1c3BlbmRlZChyb290LCBzdXNwZW5kZWRMYW5lcykge1xuICByb290LnN1c3BlbmRlZExhbmVzIHw9IHN1c3BlbmRlZExhbmVzO1xuICByb290LnBpbmdlZExhbmVzICY9IH5zdXNwZW5kZWRMYW5lczsgLy8gVGhlIHN1c3BlbmRlZCBsYW5lcyBhcmUgbm8gbG9uZ2VyIENQVS1ib3VuZC4gQ2xlYXIgdGhlaXIgZXhwaXJhdGlvbiB0aW1lcy5cblxuICB2YXIgZXhwaXJhdGlvblRpbWVzID0gcm9vdC5leHBpcmF0aW9uVGltZXM7XG4gIHZhciBsYW5lcyA9IHN1c3BlbmRlZExhbmVzO1xuXG4gIHdoaWxlIChsYW5lcyA+IDApIHtcbiAgICB2YXIgaW5kZXggPSBwaWNrQXJiaXRyYXJ5TGFuZUluZGV4KGxhbmVzKTtcbiAgICB2YXIgbGFuZSA9IDEgPDwgaW5kZXg7XG4gICAgZXhwaXJhdGlvblRpbWVzW2luZGV4XSA9IE5vVGltZXN0YW1wO1xuICAgIGxhbmVzICY9IH5sYW5lO1xuICB9XG59XG5mdW5jdGlvbiBtYXJrUm9vdFBpbmdlZChyb290LCBwaW5nZWRMYW5lcywgZXZlbnRUaW1lKSB7XG4gIHJvb3QucGluZ2VkTGFuZXMgfD0gcm9vdC5zdXNwZW5kZWRMYW5lcyAmIHBpbmdlZExhbmVzO1xufVxuZnVuY3Rpb24gbWFya0Rpc2NyZXRlVXBkYXRlc0V4cGlyZWQocm9vdCkge1xuICByb290LmV4cGlyZWRMYW5lcyB8PSBJbnB1dERpc2NyZXRlTGFuZXMgJiByb290LnBlbmRpbmdMYW5lcztcbn1cbmZ1bmN0aW9uIGhhc0Rpc2NyZXRlTGFuZXMobGFuZXMpIHtcbiAgcmV0dXJuIChsYW5lcyAmIElucHV0RGlzY3JldGVMYW5lcykgIT09IE5vTGFuZXM7XG59XG5mdW5jdGlvbiBtYXJrUm9vdE11dGFibGVSZWFkKHJvb3QsIHVwZGF0ZUxhbmUpIHtcbiAgcm9vdC5tdXRhYmxlUmVhZExhbmVzIHw9IHVwZGF0ZUxhbmUgJiByb290LnBlbmRpbmdMYW5lcztcbn1cbmZ1bmN0aW9uIG1hcmtSb290RmluaXNoZWQocm9vdCwgcmVtYWluaW5nTGFuZXMpIHtcbiAgdmFyIG5vTG9uZ2VyUGVuZGluZ0xhbmVzID0gcm9vdC5wZW5kaW5nTGFuZXMgJiB+cmVtYWluaW5nTGFuZXM7XG4gIHJvb3QucGVuZGluZ0xhbmVzID0gcmVtYWluaW5nTGFuZXM7IC8vIExldCdzIHRyeSBldmVyeXRoaW5nIGFnYWluXG5cbiAgcm9vdC5zdXNwZW5kZWRMYW5lcyA9IDA7XG4gIHJvb3QucGluZ2VkTGFuZXMgPSAwO1xuICByb290LmV4cGlyZWRMYW5lcyAmPSByZW1haW5pbmdMYW5lcztcbiAgcm9vdC5tdXRhYmxlUmVhZExhbmVzICY9IHJlbWFpbmluZ0xhbmVzO1xuICByb290LmVudGFuZ2xlZExhbmVzICY9IHJlbWFpbmluZ0xhbmVzO1xuICB2YXIgZW50YW5nbGVtZW50cyA9IHJvb3QuZW50YW5nbGVtZW50cztcbiAgdmFyIGV2ZW50VGltZXMgPSByb290LmV2ZW50VGltZXM7XG4gIHZhciBleHBpcmF0aW9uVGltZXMgPSByb290LmV4cGlyYXRpb25UaW1lczsgLy8gQ2xlYXIgdGhlIGxhbmVzIHRoYXQgbm8gbG9uZ2VyIGhhdmUgcGVuZGluZyB3b3JrXG5cbiAgdmFyIGxhbmVzID0gbm9Mb25nZXJQZW5kaW5nTGFuZXM7XG5cbiAgd2hpbGUgKGxhbmVzID4gMCkge1xuICAgIHZhciBpbmRleCA9IHBpY2tBcmJpdHJhcnlMYW5lSW5kZXgobGFuZXMpO1xuICAgIHZhciBsYW5lID0gMSA8PCBpbmRleDtcbiAgICBlbnRhbmdsZW1lbnRzW2luZGV4XSA9IE5vTGFuZXM7XG4gICAgZXZlbnRUaW1lc1tpbmRleF0gPSBOb1RpbWVzdGFtcDtcbiAgICBleHBpcmF0aW9uVGltZXNbaW5kZXhdID0gTm9UaW1lc3RhbXA7XG4gICAgbGFuZXMgJj0gfmxhbmU7XG4gIH1cbn1cbmZ1bmN0aW9uIG1hcmtSb290RW50YW5nbGVkKHJvb3QsIGVudGFuZ2xlZExhbmVzKSB7XG4gIHJvb3QuZW50YW5nbGVkTGFuZXMgfD0gZW50YW5nbGVkTGFuZXM7XG4gIHZhciBlbnRhbmdsZW1lbnRzID0gcm9vdC5lbnRhbmdsZW1lbnRzO1xuICB2YXIgbGFuZXMgPSBlbnRhbmdsZWRMYW5lcztcblxuICB3aGlsZSAobGFuZXMgPiAwKSB7XG4gICAgdmFyIGluZGV4ID0gcGlja0FyYml0cmFyeUxhbmVJbmRleChsYW5lcyk7XG4gICAgdmFyIGxhbmUgPSAxIDw8IGluZGV4O1xuICAgIGVudGFuZ2xlbWVudHNbaW5kZXhdIHw9IGVudGFuZ2xlZExhbmVzO1xuICAgIGxhbmVzICY9IH5sYW5lO1xuICB9XG59XG52YXIgY2x6MzIgPSBNYXRoLmNsejMyID8gTWF0aC5jbHozMiA6IGNsejMyRmFsbGJhY2s7IC8vIENvdW50IGxlYWRpbmcgemVyb3MuIE9ubHkgdXNlZCBvbiBsYW5lcywgc28gYXNzdW1lIGlucHV0IGlzIGFuIGludGVnZXIuXG4vLyBCYXNlZCBvbjpcbi8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL01hdGgvY2x6MzJcblxudmFyIGxvZyA9IE1hdGgubG9nO1xudmFyIExOMiA9IE1hdGguTE4yO1xuXG5mdW5jdGlvbiBjbHozMkZhbGxiYWNrKGxhbmVzKSB7XG4gIGlmIChsYW5lcyA9PT0gMCkge1xuICAgIHJldHVybiAzMjtcbiAgfVxuXG4gIHJldHVybiAzMSAtIChsb2cobGFuZXMpIC8gTE4yIHwgMCkgfCAwO1xufVxuXG4vLyBJbnRlbnRpb25hbGx5IG5vdCBuYW1lZCBpbXBvcnRzIGJlY2F1c2UgUm9sbHVwIHdvdWxkIHVzZSBkeW5hbWljIGRpc3BhdGNoIGZvclxudmFyIFVzZXJCbG9ja2luZ1ByaW9yaXR5JDEgPSBTY2hlZHVsZXIudW5zdGFibGVfVXNlckJsb2NraW5nUHJpb3JpdHksXG4gICAgcnVuV2l0aFByaW9yaXR5ID0gU2NoZWR1bGVyLnVuc3RhYmxlX3J1bldpdGhQcmlvcml0eTsgLy8gVE9ETzogY2FuIHdlIHN0b3AgZXhwb3J0aW5nIHRoZXNlP1xuXG52YXIgX2VuYWJsZWQgPSB0cnVlOyAvLyBUaGlzIGlzIGV4cG9ydGVkIGluIEZCIGJ1aWxkcyBmb3IgdXNlIGJ5IGxlZ2FjeSBGQiBsYXllciBpbmZyYS5cbi8vIFdlJ2QgbGlrZSB0byByZW1vdmUgdGhpcyBidXQgaXQncyBub3QgY2xlYXIgaWYgdGhpcyBpcyBzYWZlLlxuXG5mdW5jdGlvbiBzZXRFbmFibGVkKGVuYWJsZWQpIHtcbiAgX2VuYWJsZWQgPSAhIWVuYWJsZWQ7XG59XG5mdW5jdGlvbiBpc0VuYWJsZWQoKSB7XG4gIHJldHVybiBfZW5hYmxlZDtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUV2ZW50TGlzdGVuZXJXcmFwcGVyV2l0aFByaW9yaXR5KHRhcmdldENvbnRhaW5lciwgZG9tRXZlbnROYW1lLCBldmVudFN5c3RlbUZsYWdzKSB7XG4gIHZhciBldmVudFByaW9yaXR5ID0gZ2V0RXZlbnRQcmlvcml0eUZvclBsdWdpblN5c3RlbShkb21FdmVudE5hbWUpO1xuICB2YXIgbGlzdGVuZXJXcmFwcGVyO1xuXG4gIHN3aXRjaCAoZXZlbnRQcmlvcml0eSkge1xuICAgIGNhc2UgRGlzY3JldGVFdmVudDpcbiAgICAgIGxpc3RlbmVyV3JhcHBlciA9IGRpc3BhdGNoRGlzY3JldGVFdmVudDtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBVc2VyQmxvY2tpbmdFdmVudDpcbiAgICAgIGxpc3RlbmVyV3JhcHBlciA9IGRpc3BhdGNoVXNlckJsb2NraW5nVXBkYXRlO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIENvbnRpbnVvdXNFdmVudDpcbiAgICBkZWZhdWx0OlxuICAgICAgbGlzdGVuZXJXcmFwcGVyID0gZGlzcGF0Y2hFdmVudDtcbiAgICAgIGJyZWFrO1xuICB9XG5cbiAgcmV0dXJuIGxpc3RlbmVyV3JhcHBlci5iaW5kKG51bGwsIGRvbUV2ZW50TmFtZSwgZXZlbnRTeXN0ZW1GbGFncywgdGFyZ2V0Q29udGFpbmVyKTtcbn1cblxuZnVuY3Rpb24gZGlzcGF0Y2hEaXNjcmV0ZUV2ZW50KGRvbUV2ZW50TmFtZSwgZXZlbnRTeXN0ZW1GbGFncywgY29udGFpbmVyLCBuYXRpdmVFdmVudCkge1xuICB7XG4gICAgZmx1c2hEaXNjcmV0ZVVwZGF0ZXNJZk5lZWRlZChuYXRpdmVFdmVudC50aW1lU3RhbXApO1xuICB9XG5cbiAgZGlzY3JldGVVcGRhdGVzKGRpc3BhdGNoRXZlbnQsIGRvbUV2ZW50TmFtZSwgZXZlbnRTeXN0ZW1GbGFncywgY29udGFpbmVyLCBuYXRpdmVFdmVudCk7XG59XG5cbmZ1bmN0aW9uIGRpc3BhdGNoVXNlckJsb2NraW5nVXBkYXRlKGRvbUV2ZW50TmFtZSwgZXZlbnRTeXN0ZW1GbGFncywgY29udGFpbmVyLCBuYXRpdmVFdmVudCkge1xuICB7XG4gICAgcnVuV2l0aFByaW9yaXR5KFVzZXJCbG9ja2luZ1ByaW9yaXR5JDEsIGRpc3BhdGNoRXZlbnQuYmluZChudWxsLCBkb21FdmVudE5hbWUsIGV2ZW50U3lzdGVtRmxhZ3MsIGNvbnRhaW5lciwgbmF0aXZlRXZlbnQpKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBkaXNwYXRjaEV2ZW50KGRvbUV2ZW50TmFtZSwgZXZlbnRTeXN0ZW1GbGFncywgdGFyZ2V0Q29udGFpbmVyLCBuYXRpdmVFdmVudCkge1xuICBpZiAoIV9lbmFibGVkKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGFsbG93UmVwbGF5ID0gdHJ1ZTtcblxuICB7XG4gICAgLy8gVE9ETzogcmVwbGF5aW5nIGNhcHR1cmUgcGhhc2UgZXZlbnRzIGlzIGN1cnJlbnRseSBicm9rZW5cbiAgICAvLyBiZWNhdXNlIHdlIHVzZWQgdG8gZG8gaXQgZHVyaW5nIHRvcC1sZXZlbCBuYXRpdmUgYnViYmxlIGhhbmRsZXJzXG4gICAgLy8gYnV0IG5vdyB3ZSB1c2UgZGlmZmVyZW50IGJ1YmJsZSBhbmQgY2FwdHVyZSBoYW5kbGVycy5cbiAgICAvLyBJbiBlYWdlciBtb2RlLCB3ZSBhdHRhY2ggY2FwdHVyZSBsaXN0ZW5lcnMgZWFybHksIHNvIHdlIG5lZWRcbiAgICAvLyB0byBmaWx0ZXIgdGhlbSBvdXQgdW50aWwgd2UgZml4IHRoZSBsb2dpYyB0byBoYW5kbGUgdGhlbSBjb3JyZWN0bHkuXG4gICAgLy8gVGhpcyBjb3VsZCd2ZSBiZWVuIG91dHNpZGUgdGhlIGZsYWcgYnV0IEkgcHV0IGl0IGluc2lkZSB0byByZWR1Y2Ugcmlzay5cbiAgICBhbGxvd1JlcGxheSA9IChldmVudFN5c3RlbUZsYWdzICYgSVNfQ0FQVFVSRV9QSEFTRSkgPT09IDA7XG4gIH1cblxuICBpZiAoYWxsb3dSZXBsYXkgJiYgaGFzUXVldWVkRGlzY3JldGVFdmVudHMoKSAmJiBpc1JlcGxheWFibGVEaXNjcmV0ZUV2ZW50KGRvbUV2ZW50TmFtZSkpIHtcbiAgICAvLyBJZiB3ZSBhbHJlYWR5IGhhdmUgYSBxdWV1ZSBvZiBkaXNjcmV0ZSBldmVudHMsIGFuZCB0aGlzIGlzIGFub3RoZXIgZGlzY3JldGVcbiAgICAvLyBldmVudCwgdGhlbiB3ZSBjYW4ndCBkaXNwYXRjaCBpdCByZWdhcmRsZXNzIG9mIGl0cyB0YXJnZXQsIHNpbmNlIHRoZXlcbiAgICAvLyBuZWVkIHRvIGRpc3BhdGNoIGluIG9yZGVyLlxuICAgIHF1ZXVlRGlzY3JldGVFdmVudChudWxsLCAvLyBGbGFncyB0aGF0IHdlJ3JlIG5vdCBhY3R1YWxseSBibG9ja2VkIG9uIGFueXRoaW5nIGFzIGZhciBhcyB3ZSBrbm93LlxuICAgIGRvbUV2ZW50TmFtZSwgZXZlbnRTeXN0ZW1GbGFncywgdGFyZ2V0Q29udGFpbmVyLCBuYXRpdmVFdmVudCk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGJsb2NrZWRPbiA9IGF0dGVtcHRUb0Rpc3BhdGNoRXZlbnQoZG9tRXZlbnROYW1lLCBldmVudFN5c3RlbUZsYWdzLCB0YXJnZXRDb250YWluZXIsIG5hdGl2ZUV2ZW50KTtcblxuICBpZiAoYmxvY2tlZE9uID09PSBudWxsKSB7XG4gICAgLy8gV2Ugc3VjY2Vzc2Z1bGx5IGRpc3BhdGNoZWQgdGhpcyBldmVudC5cbiAgICBpZiAoYWxsb3dSZXBsYXkpIHtcbiAgICAgIGNsZWFySWZDb250aW51b3VzRXZlbnQoZG9tRXZlbnROYW1lLCBuYXRpdmVFdmVudCk7XG4gICAgfVxuXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKGFsbG93UmVwbGF5KSB7XG4gICAgaWYgKGlzUmVwbGF5YWJsZURpc2NyZXRlRXZlbnQoZG9tRXZlbnROYW1lKSkge1xuICAgICAgLy8gVGhpcyB0aGlzIHRvIGJlIHJlcGxheWVkIGxhdGVyIG9uY2UgdGhlIHRhcmdldCBpcyBhdmFpbGFibGUuXG4gICAgICBxdWV1ZURpc2NyZXRlRXZlbnQoYmxvY2tlZE9uLCBkb21FdmVudE5hbWUsIGV2ZW50U3lzdGVtRmxhZ3MsIHRhcmdldENvbnRhaW5lciwgbmF0aXZlRXZlbnQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChxdWV1ZUlmQ29udGludW91c0V2ZW50KGJsb2NrZWRPbiwgZG9tRXZlbnROYW1lLCBldmVudFN5c3RlbUZsYWdzLCB0YXJnZXRDb250YWluZXIsIG5hdGl2ZUV2ZW50KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gV2UgbmVlZCB0byBjbGVhciBvbmx5IGlmIHdlIGRpZG4ndCBxdWV1ZSBiZWNhdXNlXG4gICAgLy8gcXVldWVpbmcgaXMgYWNjdW1tdWxhdGl2ZS5cblxuXG4gICAgY2xlYXJJZkNvbnRpbnVvdXNFdmVudChkb21FdmVudE5hbWUsIG5hdGl2ZUV2ZW50KTtcbiAgfSAvLyBUaGlzIGlzIG5vdCByZXBsYXlhYmxlIHNvIHdlJ2xsIGludm9rZSBpdCBidXQgd2l0aG91dCBhIHRhcmdldCxcbiAgLy8gaW4gY2FzZSB0aGUgZXZlbnQgc3lzdGVtIG5lZWRzIHRvIHRyYWNlIGl0LlxuXG5cbiAgZGlzcGF0Y2hFdmVudEZvclBsdWdpbkV2ZW50U3lzdGVtKGRvbUV2ZW50TmFtZSwgZXZlbnRTeXN0ZW1GbGFncywgbmF0aXZlRXZlbnQsIG51bGwsIHRhcmdldENvbnRhaW5lcik7XG59IC8vIEF0dGVtcHQgZGlzcGF0Y2hpbmcgYW4gZXZlbnQuIFJldHVybnMgYSBTdXNwZW5zZUluc3RhbmNlIG9yIENvbnRhaW5lciBpZiBpdCdzIGJsb2NrZWQuXG5cbmZ1bmN0aW9uIGF0dGVtcHRUb0Rpc3BhdGNoRXZlbnQoZG9tRXZlbnROYW1lLCBldmVudFN5c3RlbUZsYWdzLCB0YXJnZXRDb250YWluZXIsIG5hdGl2ZUV2ZW50KSB7XG4gIC8vIFRPRE86IFdhcm4gaWYgX2VuYWJsZWQgaXMgZmFsc2UuXG4gIHZhciBuYXRpdmVFdmVudFRhcmdldCA9IGdldEV2ZW50VGFyZ2V0KG5hdGl2ZUV2ZW50KTtcbiAgdmFyIHRhcmdldEluc3QgPSBnZXRDbG9zZXN0SW5zdGFuY2VGcm9tTm9kZShuYXRpdmVFdmVudFRhcmdldCk7XG5cbiAgaWYgKHRhcmdldEluc3QgIT09IG51bGwpIHtcbiAgICB2YXIgbmVhcmVzdE1vdW50ZWQgPSBnZXROZWFyZXN0TW91bnRlZEZpYmVyKHRhcmdldEluc3QpO1xuXG4gICAgaWYgKG5lYXJlc3RNb3VudGVkID09PSBudWxsKSB7XG4gICAgICAvLyBUaGlzIHRyZWUgaGFzIGJlZW4gdW5tb3VudGVkIGFscmVhZHkuIERpc3BhdGNoIHdpdGhvdXQgYSB0YXJnZXQuXG4gICAgICB0YXJnZXRJbnN0ID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHRhZyA9IG5lYXJlc3RNb3VudGVkLnRhZztcblxuICAgICAgaWYgKHRhZyA9PT0gU3VzcGVuc2VDb21wb25lbnQpIHtcbiAgICAgICAgdmFyIGluc3RhbmNlID0gZ2V0U3VzcGVuc2VJbnN0YW5jZUZyb21GaWJlcihuZWFyZXN0TW91bnRlZCk7XG5cbiAgICAgICAgaWYgKGluc3RhbmNlICE9PSBudWxsKSB7XG4gICAgICAgICAgLy8gUXVldWUgdGhlIGV2ZW50IHRvIGJlIHJlcGxheWVkIGxhdGVyLiBBYm9ydCBkaXNwYXRjaGluZyBzaW5jZSB3ZVxuICAgICAgICAgIC8vIGRvbid0IHdhbnQgdGhpcyBldmVudCBkaXNwYXRjaGVkIHR3aWNlIHRocm91Z2ggdGhlIGV2ZW50IHN5c3RlbS5cbiAgICAgICAgICAvLyBUT0RPOiBJZiB0aGlzIGlzIHRoZSBmaXJzdCBkaXNjcmV0ZSBldmVudCBpbiB0aGUgcXVldWUuIFNjaGVkdWxlIGFuIGluY3JlYXNlZFxuICAgICAgICAgIC8vIHByaW9yaXR5IGZvciB0aGlzIGJvdW5kYXJ5LlxuICAgICAgICAgIHJldHVybiBpbnN0YW5jZTtcbiAgICAgICAgfSAvLyBUaGlzIHNob3VsZG4ndCBoYXBwZW4sIHNvbWV0aGluZyB3ZW50IHdyb25nIGJ1dCB0byBhdm9pZCBibG9ja2luZ1xuICAgICAgICAvLyB0aGUgd2hvbGUgc3lzdGVtLCBkaXNwYXRjaCB0aGUgZXZlbnQgd2l0aG91dCBhIHRhcmdldC5cbiAgICAgICAgLy8gVE9ETzogV2Fybi5cblxuXG4gICAgICAgIHRhcmdldEluc3QgPSBudWxsO1xuICAgICAgfSBlbHNlIGlmICh0YWcgPT09IEhvc3RSb290KSB7XG4gICAgICAgIHZhciByb290ID0gbmVhcmVzdE1vdW50ZWQuc3RhdGVOb2RlO1xuXG4gICAgICAgIGlmIChyb290Lmh5ZHJhdGUpIHtcbiAgICAgICAgICAvLyBJZiB0aGlzIGhhcHBlbnMgZHVyaW5nIGEgcmVwbGF5IHNvbWV0aGluZyB3ZW50IHdyb25nIGFuZCBpdCBtaWdodCBibG9ja1xuICAgICAgICAgIC8vIHRoZSB3aG9sZSBzeXN0ZW0uXG4gICAgICAgICAgcmV0dXJuIGdldENvbnRhaW5lckZyb21GaWJlcihuZWFyZXN0TW91bnRlZCk7XG4gICAgICAgIH1cblxuICAgICAgICB0YXJnZXRJbnN0ID0gbnVsbDtcbiAgICAgIH0gZWxzZSBpZiAobmVhcmVzdE1vdW50ZWQgIT09IHRhcmdldEluc3QpIHtcbiAgICAgICAgLy8gSWYgd2UgZ2V0IGFuIGV2ZW50IChleDogaW1nIG9ubG9hZCkgYmVmb3JlIGNvbW1pdHRpbmcgdGhhdFxuICAgICAgICAvLyBjb21wb25lbnQncyBtb3VudCwgaWdub3JlIGl0IGZvciBub3cgKHRoYXQgaXMsIHRyZWF0IGl0IGFzIGlmIGl0IHdhcyBhblxuICAgICAgICAvLyBldmVudCBvbiBhIG5vbi1SZWFjdCB0cmVlKS4gV2UgbWlnaHQgYWxzbyBjb25zaWRlciBxdWV1ZWluZyBldmVudHMgYW5kXG4gICAgICAgIC8vIGRpc3BhdGNoaW5nIHRoZW0gYWZ0ZXIgdGhlIG1vdW50LlxuICAgICAgICB0YXJnZXRJbnN0ID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBkaXNwYXRjaEV2ZW50Rm9yUGx1Z2luRXZlbnRTeXN0ZW0oZG9tRXZlbnROYW1lLCBldmVudFN5c3RlbUZsYWdzLCBuYXRpdmVFdmVudCwgdGFyZ2V0SW5zdCwgdGFyZ2V0Q29udGFpbmVyKTsgLy8gV2UncmUgbm90IGJsb2NrZWQgb24gYW55dGhpbmcuXG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIGFkZEV2ZW50QnViYmxlTGlzdGVuZXIodGFyZ2V0LCBldmVudFR5cGUsIGxpc3RlbmVyKSB7XG4gIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKGV2ZW50VHlwZSwgbGlzdGVuZXIsIGZhbHNlKTtcbiAgcmV0dXJuIGxpc3RlbmVyO1xufVxuZnVuY3Rpb24gYWRkRXZlbnRDYXB0dXJlTGlzdGVuZXIodGFyZ2V0LCBldmVudFR5cGUsIGxpc3RlbmVyKSB7XG4gIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKGV2ZW50VHlwZSwgbGlzdGVuZXIsIHRydWUpO1xuICByZXR1cm4gbGlzdGVuZXI7XG59XG5mdW5jdGlvbiBhZGRFdmVudENhcHR1cmVMaXN0ZW5lcldpdGhQYXNzaXZlRmxhZyh0YXJnZXQsIGV2ZW50VHlwZSwgbGlzdGVuZXIsIHBhc3NpdmUpIHtcbiAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnRUeXBlLCBsaXN0ZW5lciwge1xuICAgIGNhcHR1cmU6IHRydWUsXG4gICAgcGFzc2l2ZTogcGFzc2l2ZVxuICB9KTtcbiAgcmV0dXJuIGxpc3RlbmVyO1xufVxuZnVuY3Rpb24gYWRkRXZlbnRCdWJibGVMaXN0ZW5lcldpdGhQYXNzaXZlRmxhZyh0YXJnZXQsIGV2ZW50VHlwZSwgbGlzdGVuZXIsIHBhc3NpdmUpIHtcbiAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnRUeXBlLCBsaXN0ZW5lciwge1xuICAgIHBhc3NpdmU6IHBhc3NpdmVcbiAgfSk7XG4gIHJldHVybiBsaXN0ZW5lcjtcbn1cblxuLyoqXG4gKiBUaGVzZSB2YXJpYWJsZXMgc3RvcmUgaW5mb3JtYXRpb24gYWJvdXQgdGV4dCBjb250ZW50IG9mIGEgdGFyZ2V0IG5vZGUsXG4gKiBhbGxvd2luZyBjb21wYXJpc29uIG9mIGNvbnRlbnQgYmVmb3JlIGFuZCBhZnRlciBhIGdpdmVuIGV2ZW50LlxuICpcbiAqIElkZW50aWZ5IHRoZSBub2RlIHdoZXJlIHNlbGVjdGlvbiBjdXJyZW50bHkgYmVnaW5zLCB0aGVuIG9ic2VydmVcbiAqIGJvdGggaXRzIHRleHQgY29udGVudCBhbmQgaXRzIGN1cnJlbnQgcG9zaXRpb24gaW4gdGhlIERPTS4gU2luY2UgdGhlXG4gKiBicm93c2VyIG1heSBuYXRpdmVseSByZXBsYWNlIHRoZSB0YXJnZXQgbm9kZSBkdXJpbmcgY29tcG9zaXRpb24sIHdlIGNhblxuICogdXNlIGl0cyBwb3NpdGlvbiB0byBmaW5kIGl0cyByZXBsYWNlbWVudC5cbiAqXG4gKlxuICovXG52YXIgcm9vdCA9IG51bGw7XG52YXIgc3RhcnRUZXh0ID0gbnVsbDtcbnZhciBmYWxsYmFja1RleHQgPSBudWxsO1xuZnVuY3Rpb24gaW5pdGlhbGl6ZShuYXRpdmVFdmVudFRhcmdldCkge1xuICByb290ID0gbmF0aXZlRXZlbnRUYXJnZXQ7XG4gIHN0YXJ0VGV4dCA9IGdldFRleHQoKTtcbiAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiByZXNldCgpIHtcbiAgcm9vdCA9IG51bGw7XG4gIHN0YXJ0VGV4dCA9IG51bGw7XG4gIGZhbGxiYWNrVGV4dCA9IG51bGw7XG59XG5mdW5jdGlvbiBnZXREYXRhKCkge1xuICBpZiAoZmFsbGJhY2tUZXh0KSB7XG4gICAgcmV0dXJuIGZhbGxiYWNrVGV4dDtcbiAgfVxuXG4gIHZhciBzdGFydDtcbiAgdmFyIHN0YXJ0VmFsdWUgPSBzdGFydFRleHQ7XG4gIHZhciBzdGFydExlbmd0aCA9IHN0YXJ0VmFsdWUubGVuZ3RoO1xuICB2YXIgZW5kO1xuICB2YXIgZW5kVmFsdWUgPSBnZXRUZXh0KCk7XG4gIHZhciBlbmRMZW5ndGggPSBlbmRWYWx1ZS5sZW5ndGg7XG5cbiAgZm9yIChzdGFydCA9IDA7IHN0YXJ0IDwgc3RhcnRMZW5ndGg7IHN0YXJ0KyspIHtcbiAgICBpZiAoc3RhcnRWYWx1ZVtzdGFydF0gIT09IGVuZFZhbHVlW3N0YXJ0XSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgdmFyIG1pbkVuZCA9IHN0YXJ0TGVuZ3RoIC0gc3RhcnQ7XG5cbiAgZm9yIChlbmQgPSAxOyBlbmQgPD0gbWluRW5kOyBlbmQrKykge1xuICAgIGlmIChzdGFydFZhbHVlW3N0YXJ0TGVuZ3RoIC0gZW5kXSAhPT0gZW5kVmFsdWVbZW5kTGVuZ3RoIC0gZW5kXSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgdmFyIHNsaWNlVGFpbCA9IGVuZCA+IDEgPyAxIC0gZW5kIDogdW5kZWZpbmVkO1xuICBmYWxsYmFja1RleHQgPSBlbmRWYWx1ZS5zbGljZShzdGFydCwgc2xpY2VUYWlsKTtcbiAgcmV0dXJuIGZhbGxiYWNrVGV4dDtcbn1cbmZ1bmN0aW9uIGdldFRleHQoKSB7XG4gIGlmICgndmFsdWUnIGluIHJvb3QpIHtcbiAgICByZXR1cm4gcm9vdC52YWx1ZTtcbiAgfVxuXG4gIHJldHVybiByb290LnRleHRDb250ZW50O1xufVxuXG4vKipcbiAqIGBjaGFyQ29kZWAgcmVwcmVzZW50cyB0aGUgYWN0dWFsIFwiY2hhcmFjdGVyIGNvZGVcIiBhbmQgaXMgc2FmZSB0byB1c2Ugd2l0aFxuICogYFN0cmluZy5mcm9tQ2hhckNvZGVgLiBBcyBzdWNoLCBvbmx5IGtleXMgdGhhdCBjb3JyZXNwb25kIHRvIHByaW50YWJsZVxuICogY2hhcmFjdGVycyBwcm9kdWNlIGEgdmFsaWQgYGNoYXJDb2RlYCwgdGhlIG9ubHkgZXhjZXB0aW9uIHRvIHRoaXMgaXMgRW50ZXIuXG4gKiBUaGUgVGFiLWtleSBpcyBjb25zaWRlcmVkIG5vbi1wcmludGFibGUgYW5kIGRvZXMgbm90IGhhdmUgYSBgY2hhckNvZGVgLFxuICogcHJlc3VtYWJseSBiZWNhdXNlIGl0IGRvZXMgbm90IHByb2R1Y2UgYSB0YWItY2hhcmFjdGVyIGluIGJyb3dzZXJzLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEByZXR1cm4ge251bWJlcn0gTm9ybWFsaXplZCBgY2hhckNvZGVgIHByb3BlcnR5LlxuICovXG5mdW5jdGlvbiBnZXRFdmVudENoYXJDb2RlKG5hdGl2ZUV2ZW50KSB7XG4gIHZhciBjaGFyQ29kZTtcbiAgdmFyIGtleUNvZGUgPSBuYXRpdmVFdmVudC5rZXlDb2RlO1xuXG4gIGlmICgnY2hhckNvZGUnIGluIG5hdGl2ZUV2ZW50KSB7XG4gICAgY2hhckNvZGUgPSBuYXRpdmVFdmVudC5jaGFyQ29kZTsgLy8gRkYgZG9lcyBub3Qgc2V0IGBjaGFyQ29kZWAgZm9yIHRoZSBFbnRlci1rZXksIGNoZWNrIGFnYWluc3QgYGtleUNvZGVgLlxuXG4gICAgaWYgKGNoYXJDb2RlID09PSAwICYmIGtleUNvZGUgPT09IDEzKSB7XG4gICAgICBjaGFyQ29kZSA9IDEzO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBJRTggZG9lcyBub3QgaW1wbGVtZW50IGBjaGFyQ29kZWAsIGJ1dCBga2V5Q29kZWAgaGFzIHRoZSBjb3JyZWN0IHZhbHVlLlxuICAgIGNoYXJDb2RlID0ga2V5Q29kZTtcbiAgfSAvLyBJRSBhbmQgRWRnZSAob24gV2luZG93cykgYW5kIENocm9tZSAvIFNhZmFyaSAob24gV2luZG93cyBhbmQgTGludXgpXG4gIC8vIHJlcG9ydCBFbnRlciBhcyBjaGFyQ29kZSAxMCB3aGVuIGN0cmwgaXMgcHJlc3NlZC5cblxuXG4gIGlmIChjaGFyQ29kZSA9PT0gMTApIHtcbiAgICBjaGFyQ29kZSA9IDEzO1xuICB9IC8vIFNvbWUgbm9uLXByaW50YWJsZSBrZXlzIGFyZSByZXBvcnRlZCBpbiBgY2hhckNvZGVgL2BrZXlDb2RlYCwgZGlzY2FyZCB0aGVtLlxuICAvLyBNdXN0IG5vdCBkaXNjYXJkIHRoZSAobm9uLSlwcmludGFibGUgRW50ZXIta2V5LlxuXG5cbiAgaWYgKGNoYXJDb2RlID49IDMyIHx8IGNoYXJDb2RlID09PSAxMykge1xuICAgIHJldHVybiBjaGFyQ29kZTtcbiAgfVxuXG4gIHJldHVybiAwO1xufVxuXG5mdW5jdGlvbiBmdW5jdGlvblRoYXRSZXR1cm5zVHJ1ZSgpIHtcbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGZ1bmN0aW9uVGhhdFJldHVybnNGYWxzZSgpIHtcbiAgcmV0dXJuIGZhbHNlO1xufSAvLyBUaGlzIGlzIGludGVudGlvbmFsbHkgYSBmYWN0b3J5IHNvIHRoYXQgd2UgaGF2ZSBkaWZmZXJlbnQgcmV0dXJuZWQgY29uc3RydWN0b3JzLlxuLy8gSWYgd2UgaGFkIGEgc2luZ2xlIGNvbnN0cnVjdG9yLCBpdCB3b3VsZCBiZSBtZWdhbW9ycGhpYyBhbmQgZW5naW5lcyB3b3VsZCBkZW9wdC5cblxuXG5mdW5jdGlvbiBjcmVhdGVTeW50aGV0aWNFdmVudChJbnRlcmZhY2UpIHtcbiAgLyoqXG4gICAqIFN5bnRoZXRpYyBldmVudHMgYXJlIGRpc3BhdGNoZWQgYnkgZXZlbnQgcGx1Z2lucywgdHlwaWNhbGx5IGluIHJlc3BvbnNlIHRvIGFcbiAgICogdG9wLWxldmVsIGV2ZW50IGRlbGVnYXRpb24gaGFuZGxlci5cbiAgICpcbiAgICogVGhlc2Ugc3lzdGVtcyBzaG91bGQgZ2VuZXJhbGx5IHVzZSBwb29saW5nIHRvIHJlZHVjZSB0aGUgZnJlcXVlbmN5IG9mIGdhcmJhZ2VcbiAgICogY29sbGVjdGlvbi4gVGhlIHN5c3RlbSBzaG91bGQgY2hlY2sgYGlzUGVyc2lzdGVudGAgdG8gZGV0ZXJtaW5lIHdoZXRoZXIgdGhlXG4gICAqIGV2ZW50IHNob3VsZCBiZSByZWxlYXNlZCBpbnRvIHRoZSBwb29sIGFmdGVyIGJlaW5nIGRpc3BhdGNoZWQuIFVzZXJzIHRoYXRcbiAgICogbmVlZCBhIHBlcnNpc3RlZCBldmVudCBzaG91bGQgaW52b2tlIGBwZXJzaXN0YC5cbiAgICpcbiAgICogU3ludGhldGljIGV2ZW50cyAoYW5kIHN1YmNsYXNzZXMpIGltcGxlbWVudCB0aGUgRE9NIExldmVsIDMgRXZlbnRzIEFQSSBieVxuICAgKiBub3JtYWxpemluZyBicm93c2VyIHF1aXJrcy4gU3ViY2xhc3NlcyBkbyBub3QgbmVjZXNzYXJpbHkgaGF2ZSB0byBpbXBsZW1lbnQgYVxuICAgKiBET00gaW50ZXJmYWNlOyBjdXN0b20gYXBwbGljYXRpb24tc3BlY2lmaWMgZXZlbnRzIGNhbiBhbHNvIHN1YmNsYXNzIHRoaXMuXG4gICAqL1xuICBmdW5jdGlvbiBTeW50aGV0aWNCYXNlRXZlbnQocmVhY3ROYW1lLCByZWFjdEV2ZW50VHlwZSwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gICAgdGhpcy5fcmVhY3ROYW1lID0gcmVhY3ROYW1lO1xuICAgIHRoaXMuX3RhcmdldEluc3QgPSB0YXJnZXRJbnN0O1xuICAgIHRoaXMudHlwZSA9IHJlYWN0RXZlbnRUeXBlO1xuICAgIHRoaXMubmF0aXZlRXZlbnQgPSBuYXRpdmVFdmVudDtcbiAgICB0aGlzLnRhcmdldCA9IG5hdGl2ZUV2ZW50VGFyZ2V0O1xuICAgIHRoaXMuY3VycmVudFRhcmdldCA9IG51bGw7XG5cbiAgICBmb3IgKHZhciBfcHJvcE5hbWUgaW4gSW50ZXJmYWNlKSB7XG4gICAgICBpZiAoIUludGVyZmFjZS5oYXNPd25Qcm9wZXJ0eShfcHJvcE5hbWUpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICB2YXIgbm9ybWFsaXplID0gSW50ZXJmYWNlW19wcm9wTmFtZV07XG5cbiAgICAgIGlmIChub3JtYWxpemUpIHtcbiAgICAgICAgdGhpc1tfcHJvcE5hbWVdID0gbm9ybWFsaXplKG5hdGl2ZUV2ZW50KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXNbX3Byb3BOYW1lXSA9IG5hdGl2ZUV2ZW50W19wcm9wTmFtZV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGRlZmF1bHRQcmV2ZW50ZWQgPSBuYXRpdmVFdmVudC5kZWZhdWx0UHJldmVudGVkICE9IG51bGwgPyBuYXRpdmVFdmVudC5kZWZhdWx0UHJldmVudGVkIDogbmF0aXZlRXZlbnQucmV0dXJuVmFsdWUgPT09IGZhbHNlO1xuXG4gICAgaWYgKGRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICAgIHRoaXMuaXNEZWZhdWx0UHJldmVudGVkID0gZnVuY3Rpb25UaGF0UmV0dXJuc1RydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuaXNEZWZhdWx0UHJldmVudGVkID0gZnVuY3Rpb25UaGF0UmV0dXJuc0ZhbHNlO1xuICAgIH1cblxuICAgIHRoaXMuaXNQcm9wYWdhdGlvblN0b3BwZWQgPSBmdW5jdGlvblRoYXRSZXR1cm5zRmFsc2U7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBfYXNzaWduKFN5bnRoZXRpY0Jhc2VFdmVudC5wcm90b3R5cGUsIHtcbiAgICBwcmV2ZW50RGVmYXVsdDogZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5kZWZhdWx0UHJldmVudGVkID0gdHJ1ZTtcbiAgICAgIHZhciBldmVudCA9IHRoaXMubmF0aXZlRXZlbnQ7XG5cbiAgICAgIGlmICghZXZlbnQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoZXZlbnQucHJldmVudERlZmF1bHQpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTsgLy8gJEZsb3dGaXhNZSAtIGZsb3cgaXMgbm90IGF3YXJlIG9mIGB1bmtub3duYCBpbiBJRVxuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgZXZlbnQucmV0dXJuVmFsdWUgIT09ICd1bmtub3duJykge1xuICAgICAgICBldmVudC5yZXR1cm5WYWx1ZSA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmlzRGVmYXVsdFByZXZlbnRlZCA9IGZ1bmN0aW9uVGhhdFJldHVybnNUcnVlO1xuICAgIH0sXG4gICAgc3RvcFByb3BhZ2F0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgZXZlbnQgPSB0aGlzLm5hdGl2ZUV2ZW50O1xuXG4gICAgICBpZiAoIWV2ZW50KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKGV2ZW50LnN0b3BQcm9wYWdhdGlvbikge1xuICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTsgLy8gJEZsb3dGaXhNZSAtIGZsb3cgaXMgbm90IGF3YXJlIG9mIGB1bmtub3duYCBpbiBJRVxuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgZXZlbnQuY2FuY2VsQnViYmxlICE9PSAndW5rbm93bicpIHtcbiAgICAgICAgLy8gVGhlIENoYW5nZUV2ZW50UGx1Z2luIHJlZ2lzdGVycyBhIFwicHJvcGVydHljaGFuZ2VcIiBldmVudCBmb3JcbiAgICAgICAgLy8gSUUuIFRoaXMgZXZlbnQgZG9lcyBub3Qgc3VwcG9ydCBidWJibGluZyBvciBjYW5jZWxsaW5nLCBhbmRcbiAgICAgICAgLy8gYW55IHJlZmVyZW5jZXMgdG8gY2FuY2VsQnViYmxlIHRocm93IFwiTWVtYmVyIG5vdCBmb3VuZFwiLiAgQVxuICAgICAgICAvLyB0eXBlb2YgY2hlY2sgb2YgXCJ1bmtub3duXCIgY2lyY3VtdmVudHMgdGhpcyBpc3N1ZSAoYW5kIGlzIGFsc29cbiAgICAgICAgLy8gSUUgc3BlY2lmaWMpLlxuICAgICAgICBldmVudC5jYW5jZWxCdWJibGUgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmlzUHJvcGFnYXRpb25TdG9wcGVkID0gZnVuY3Rpb25UaGF0UmV0dXJuc1RydWU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFdlIHJlbGVhc2UgYWxsIGRpc3BhdGNoZWQgYFN5bnRoZXRpY0V2ZW50YHMgYWZ0ZXIgZWFjaCBldmVudCBsb29wLCBhZGRpbmdcbiAgICAgKiB0aGVtIGJhY2sgaW50byB0aGUgcG9vbC4gVGhpcyBhbGxvd3MgYSB3YXkgdG8gaG9sZCBvbnRvIGEgcmVmZXJlbmNlIHRoYXRcbiAgICAgKiB3b24ndCBiZSBhZGRlZCBiYWNrIGludG8gdGhlIHBvb2wuXG4gICAgICovXG4gICAgcGVyc2lzdDogZnVuY3Rpb24gKCkgey8vIE1vZGVybiBldmVudCBzeXN0ZW0gZG9lc24ndCB1c2UgcG9vbGluZy5cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIHRoaXMgZXZlbnQgc2hvdWxkIGJlIHJlbGVhc2VkIGJhY2sgaW50byB0aGUgcG9vbC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhpcyBzaG91bGQgbm90IGJlIHJlbGVhc2VkLCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICovXG4gICAgaXNQZXJzaXN0ZW50OiBmdW5jdGlvblRoYXRSZXR1cm5zVHJ1ZVxuICB9KTtcblxuICByZXR1cm4gU3ludGhldGljQmFzZUV2ZW50O1xufVxuLyoqXG4gKiBAaW50ZXJmYWNlIEV2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy9cbiAqL1xuXG5cbnZhciBFdmVudEludGVyZmFjZSA9IHtcbiAgZXZlbnRQaGFzZTogMCxcbiAgYnViYmxlczogMCxcbiAgY2FuY2VsYWJsZTogMCxcbiAgdGltZVN0YW1wOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICByZXR1cm4gZXZlbnQudGltZVN0YW1wIHx8IERhdGUubm93KCk7XG4gIH0sXG4gIGRlZmF1bHRQcmV2ZW50ZWQ6IDAsXG4gIGlzVHJ1c3RlZDogMFxufTtcbnZhciBTeW50aGV0aWNFdmVudCA9IGNyZWF0ZVN5bnRoZXRpY0V2ZW50KEV2ZW50SW50ZXJmYWNlKTtcblxudmFyIFVJRXZlbnRJbnRlcmZhY2UgPSBfYXNzaWduKHt9LCBFdmVudEludGVyZmFjZSwge1xuICB2aWV3OiAwLFxuICBkZXRhaWw6IDBcbn0pO1xuXG52YXIgU3ludGhldGljVUlFdmVudCA9IGNyZWF0ZVN5bnRoZXRpY0V2ZW50KFVJRXZlbnRJbnRlcmZhY2UpO1xudmFyIGxhc3RNb3ZlbWVudFg7XG52YXIgbGFzdE1vdmVtZW50WTtcbnZhciBsYXN0TW91c2VFdmVudDtcblxuZnVuY3Rpb24gdXBkYXRlTW91c2VNb3ZlbWVudFBvbHlmaWxsU3RhdGUoZXZlbnQpIHtcbiAgaWYgKGV2ZW50ICE9PSBsYXN0TW91c2VFdmVudCkge1xuICAgIGlmIChsYXN0TW91c2VFdmVudCAmJiBldmVudC50eXBlID09PSAnbW91c2Vtb3ZlJykge1xuICAgICAgbGFzdE1vdmVtZW50WCA9IGV2ZW50LnNjcmVlblggLSBsYXN0TW91c2VFdmVudC5zY3JlZW5YO1xuICAgICAgbGFzdE1vdmVtZW50WSA9IGV2ZW50LnNjcmVlblkgLSBsYXN0TW91c2VFdmVudC5zY3JlZW5ZO1xuICAgIH0gZWxzZSB7XG4gICAgICBsYXN0TW92ZW1lbnRYID0gMDtcbiAgICAgIGxhc3RNb3ZlbWVudFkgPSAwO1xuICAgIH1cblxuICAgIGxhc3RNb3VzZUV2ZW50ID0gZXZlbnQ7XG4gIH1cbn1cbi8qKlxuICogQGludGVyZmFjZSBNb3VzZUV2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy9cbiAqL1xuXG5cbnZhciBNb3VzZUV2ZW50SW50ZXJmYWNlID0gX2Fzc2lnbih7fSwgVUlFdmVudEludGVyZmFjZSwge1xuICBzY3JlZW5YOiAwLFxuICBzY3JlZW5ZOiAwLFxuICBjbGllbnRYOiAwLFxuICBjbGllbnRZOiAwLFxuICBwYWdlWDogMCxcbiAgcGFnZVk6IDAsXG4gIGN0cmxLZXk6IDAsXG4gIHNoaWZ0S2V5OiAwLFxuICBhbHRLZXk6IDAsXG4gIG1ldGFLZXk6IDAsXG4gIGdldE1vZGlmaWVyU3RhdGU6IGdldEV2ZW50TW9kaWZpZXJTdGF0ZSxcbiAgYnV0dG9uOiAwLFxuICBidXR0b25zOiAwLFxuICByZWxhdGVkVGFyZ2V0OiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICBpZiAoZXZlbnQucmVsYXRlZFRhcmdldCA9PT0gdW5kZWZpbmVkKSByZXR1cm4gZXZlbnQuZnJvbUVsZW1lbnQgPT09IGV2ZW50LnNyY0VsZW1lbnQgPyBldmVudC50b0VsZW1lbnQgOiBldmVudC5mcm9tRWxlbWVudDtcbiAgICByZXR1cm4gZXZlbnQucmVsYXRlZFRhcmdldDtcbiAgfSxcbiAgbW92ZW1lbnRYOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICBpZiAoJ21vdmVtZW50WCcgaW4gZXZlbnQpIHtcbiAgICAgIHJldHVybiBldmVudC5tb3ZlbWVudFg7XG4gICAgfVxuXG4gICAgdXBkYXRlTW91c2VNb3ZlbWVudFBvbHlmaWxsU3RhdGUoZXZlbnQpO1xuICAgIHJldHVybiBsYXN0TW92ZW1lbnRYO1xuICB9LFxuICBtb3ZlbWVudFk6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIGlmICgnbW92ZW1lbnRZJyBpbiBldmVudCkge1xuICAgICAgcmV0dXJuIGV2ZW50Lm1vdmVtZW50WTtcbiAgICB9IC8vIERvbid0IG5lZWQgdG8gY2FsbCB1cGRhdGVNb3VzZU1vdmVtZW50UG9seWZpbGxTdGF0ZSgpIGhlcmVcbiAgICAvLyBiZWNhdXNlIGl0J3MgZ3VhcmFudGVlZCB0byBoYXZlIGFscmVhZHkgcnVuIHdoZW4gbW92ZW1lbnRYXG4gICAgLy8gd2FzIGNvcGllZC5cblxuXG4gICAgcmV0dXJuIGxhc3RNb3ZlbWVudFk7XG4gIH1cbn0pO1xuXG52YXIgU3ludGhldGljTW91c2VFdmVudCA9IGNyZWF0ZVN5bnRoZXRpY0V2ZW50KE1vdXNlRXZlbnRJbnRlcmZhY2UpO1xuLyoqXG4gKiBAaW50ZXJmYWNlIERyYWdFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvXG4gKi9cblxudmFyIERyYWdFdmVudEludGVyZmFjZSA9IF9hc3NpZ24oe30sIE1vdXNlRXZlbnRJbnRlcmZhY2UsIHtcbiAgZGF0YVRyYW5zZmVyOiAwXG59KTtcblxudmFyIFN5bnRoZXRpY0RyYWdFdmVudCA9IGNyZWF0ZVN5bnRoZXRpY0V2ZW50KERyYWdFdmVudEludGVyZmFjZSk7XG4vKipcbiAqIEBpbnRlcmZhY2UgRm9jdXNFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvXG4gKi9cblxudmFyIEZvY3VzRXZlbnRJbnRlcmZhY2UgPSBfYXNzaWduKHt9LCBVSUV2ZW50SW50ZXJmYWNlLCB7XG4gIHJlbGF0ZWRUYXJnZXQ6IDBcbn0pO1xuXG52YXIgU3ludGhldGljRm9jdXNFdmVudCA9IGNyZWF0ZVN5bnRoZXRpY0V2ZW50KEZvY3VzRXZlbnRJbnRlcmZhY2UpO1xuLyoqXG4gKiBAaW50ZXJmYWNlIEV2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL2NzczMtYW5pbWF0aW9ucy8jQW5pbWF0aW9uRXZlbnQtaW50ZXJmYWNlXG4gKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9BbmltYXRpb25FdmVudFxuICovXG5cbnZhciBBbmltYXRpb25FdmVudEludGVyZmFjZSA9IF9hc3NpZ24oe30sIEV2ZW50SW50ZXJmYWNlLCB7XG4gIGFuaW1hdGlvbk5hbWU6IDAsXG4gIGVsYXBzZWRUaW1lOiAwLFxuICBwc2V1ZG9FbGVtZW50OiAwXG59KTtcblxudmFyIFN5bnRoZXRpY0FuaW1hdGlvbkV2ZW50ID0gY3JlYXRlU3ludGhldGljRXZlbnQoQW5pbWF0aW9uRXZlbnRJbnRlcmZhY2UpO1xuLyoqXG4gKiBAaW50ZXJmYWNlIEV2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL2NsaXBib2FyZC1hcGlzL1xuICovXG5cbnZhciBDbGlwYm9hcmRFdmVudEludGVyZmFjZSA9IF9hc3NpZ24oe30sIEV2ZW50SW50ZXJmYWNlLCB7XG4gIGNsaXBib2FyZERhdGE6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHJldHVybiAnY2xpcGJvYXJkRGF0YScgaW4gZXZlbnQgPyBldmVudC5jbGlwYm9hcmREYXRhIDogd2luZG93LmNsaXBib2FyZERhdGE7XG4gIH1cbn0pO1xuXG52YXIgU3ludGhldGljQ2xpcGJvYXJkRXZlbnQgPSBjcmVhdGVTeW50aGV0aWNFdmVudChDbGlwYm9hcmRFdmVudEludGVyZmFjZSk7XG4vKipcbiAqIEBpbnRlcmZhY2UgRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzLyNldmVudHMtY29tcG9zaXRpb25ldmVudHNcbiAqL1xuXG52YXIgQ29tcG9zaXRpb25FdmVudEludGVyZmFjZSA9IF9hc3NpZ24oe30sIEV2ZW50SW50ZXJmYWNlLCB7XG4gIGRhdGE6IDBcbn0pO1xuXG52YXIgU3ludGhldGljQ29tcG9zaXRpb25FdmVudCA9IGNyZWF0ZVN5bnRoZXRpY0V2ZW50KENvbXBvc2l0aW9uRXZlbnRJbnRlcmZhY2UpO1xuLyoqXG4gKiBAaW50ZXJmYWNlIEV2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSLzIwMTMvV0QtRE9NLUxldmVsLTMtRXZlbnRzLTIwMTMxMTA1XG4gKiAgICAgIC8jZXZlbnRzLWlucHV0ZXZlbnRzXG4gKi9cbi8vIEhhcHBlbnMgdG8gc2hhcmUgdGhlIHNhbWUgbGlzdCBmb3Igbm93LlxuXG52YXIgU3ludGhldGljSW5wdXRFdmVudCA9IFN5bnRoZXRpY0NvbXBvc2l0aW9uRXZlbnQ7XG4vKipcbiAqIE5vcm1hbGl6YXRpb24gb2YgZGVwcmVjYXRlZCBIVE1MNSBga2V5YCB2YWx1ZXNcbiAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0tleWJvYXJkRXZlbnQjS2V5X25hbWVzXG4gKi9cblxudmFyIG5vcm1hbGl6ZUtleSA9IHtcbiAgRXNjOiAnRXNjYXBlJyxcbiAgU3BhY2ViYXI6ICcgJyxcbiAgTGVmdDogJ0Fycm93TGVmdCcsXG4gIFVwOiAnQXJyb3dVcCcsXG4gIFJpZ2h0OiAnQXJyb3dSaWdodCcsXG4gIERvd246ICdBcnJvd0Rvd24nLFxuICBEZWw6ICdEZWxldGUnLFxuICBXaW46ICdPUycsXG4gIE1lbnU6ICdDb250ZXh0TWVudScsXG4gIEFwcHM6ICdDb250ZXh0TWVudScsXG4gIFNjcm9sbDogJ1Njcm9sbExvY2snLFxuICBNb3pQcmludGFibGVLZXk6ICdVbmlkZW50aWZpZWQnXG59O1xuLyoqXG4gKiBUcmFuc2xhdGlvbiBmcm9tIGxlZ2FjeSBga2V5Q29kZWAgdG8gSFRNTDUgYGtleWBcbiAqIE9ubHkgc3BlY2lhbCBrZXlzIHN1cHBvcnRlZCwgYWxsIG90aGVycyBkZXBlbmQgb24ga2V5Ym9hcmQgbGF5b3V0IG9yIGJyb3dzZXJcbiAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0tleWJvYXJkRXZlbnQjS2V5X25hbWVzXG4gKi9cblxudmFyIHRyYW5zbGF0ZVRvS2V5ID0ge1xuICAnOCc6ICdCYWNrc3BhY2UnLFxuICAnOSc6ICdUYWInLFxuICAnMTInOiAnQ2xlYXInLFxuICAnMTMnOiAnRW50ZXInLFxuICAnMTYnOiAnU2hpZnQnLFxuICAnMTcnOiAnQ29udHJvbCcsXG4gICcxOCc6ICdBbHQnLFxuICAnMTknOiAnUGF1c2UnLFxuICAnMjAnOiAnQ2Fwc0xvY2snLFxuICAnMjcnOiAnRXNjYXBlJyxcbiAgJzMyJzogJyAnLFxuICAnMzMnOiAnUGFnZVVwJyxcbiAgJzM0JzogJ1BhZ2VEb3duJyxcbiAgJzM1JzogJ0VuZCcsXG4gICczNic6ICdIb21lJyxcbiAgJzM3JzogJ0Fycm93TGVmdCcsXG4gICczOCc6ICdBcnJvd1VwJyxcbiAgJzM5JzogJ0Fycm93UmlnaHQnLFxuICAnNDAnOiAnQXJyb3dEb3duJyxcbiAgJzQ1JzogJ0luc2VydCcsXG4gICc0Nic6ICdEZWxldGUnLFxuICAnMTEyJzogJ0YxJyxcbiAgJzExMyc6ICdGMicsXG4gICcxMTQnOiAnRjMnLFxuICAnMTE1JzogJ0Y0JyxcbiAgJzExNic6ICdGNScsXG4gICcxMTcnOiAnRjYnLFxuICAnMTE4JzogJ0Y3JyxcbiAgJzExOSc6ICdGOCcsXG4gICcxMjAnOiAnRjknLFxuICAnMTIxJzogJ0YxMCcsXG4gICcxMjInOiAnRjExJyxcbiAgJzEyMyc6ICdGMTInLFxuICAnMTQ0JzogJ051bUxvY2snLFxuICAnMTQ1JzogJ1Njcm9sbExvY2snLFxuICAnMjI0JzogJ01ldGEnXG59O1xuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IE5vcm1hbGl6ZWQgYGtleWAgcHJvcGVydHkuXG4gKi9cblxuZnVuY3Rpb24gZ2V0RXZlbnRLZXkobmF0aXZlRXZlbnQpIHtcbiAgaWYgKG5hdGl2ZUV2ZW50LmtleSkge1xuICAgIC8vIE5vcm1hbGl6ZSBpbmNvbnNpc3RlbnQgdmFsdWVzIHJlcG9ydGVkIGJ5IGJyb3dzZXJzIGR1ZSB0b1xuICAgIC8vIGltcGxlbWVudGF0aW9ucyBvZiBhIHdvcmtpbmcgZHJhZnQgc3BlY2lmaWNhdGlvbi5cbiAgICAvLyBGaXJlRm94IGltcGxlbWVudHMgYGtleWAgYnV0IHJldHVybnMgYE1velByaW50YWJsZUtleWAgZm9yIGFsbFxuICAgIC8vIHByaW50YWJsZSBjaGFyYWN0ZXJzIChub3JtYWxpemVkIHRvIGBVbmlkZW50aWZpZWRgKSwgaWdub3JlIGl0LlxuICAgIHZhciBrZXkgPSBub3JtYWxpemVLZXlbbmF0aXZlRXZlbnQua2V5XSB8fCBuYXRpdmVFdmVudC5rZXk7XG5cbiAgICBpZiAoa2V5ICE9PSAnVW5pZGVudGlmaWVkJykge1xuICAgICAgcmV0dXJuIGtleTtcbiAgICB9XG4gIH0gLy8gQnJvd3NlciBkb2VzIG5vdCBpbXBsZW1lbnQgYGtleWAsIHBvbHlmaWxsIGFzIG11Y2ggb2YgaXQgYXMgd2UgY2FuLlxuXG5cbiAgaWYgKG5hdGl2ZUV2ZW50LnR5cGUgPT09ICdrZXlwcmVzcycpIHtcbiAgICB2YXIgY2hhckNvZGUgPSBnZXRFdmVudENoYXJDb2RlKG5hdGl2ZUV2ZW50KTsgLy8gVGhlIGVudGVyLWtleSBpcyB0ZWNobmljYWxseSBib3RoIHByaW50YWJsZSBhbmQgbm9uLXByaW50YWJsZSBhbmQgY2FuXG4gICAgLy8gdGh1cyBiZSBjYXB0dXJlZCBieSBga2V5cHJlc3NgLCBubyBvdGhlciBub24tcHJpbnRhYmxlIGtleSBzaG91bGQuXG5cbiAgICByZXR1cm4gY2hhckNvZGUgPT09IDEzID8gJ0VudGVyJyA6IFN0cmluZy5mcm9tQ2hhckNvZGUoY2hhckNvZGUpO1xuICB9XG5cbiAgaWYgKG5hdGl2ZUV2ZW50LnR5cGUgPT09ICdrZXlkb3duJyB8fCBuYXRpdmVFdmVudC50eXBlID09PSAna2V5dXAnKSB7XG4gICAgLy8gV2hpbGUgdXNlciBrZXlib2FyZCBsYXlvdXQgZGV0ZXJtaW5lcyB0aGUgYWN0dWFsIG1lYW5pbmcgb2YgZWFjaFxuICAgIC8vIGBrZXlDb2RlYCB2YWx1ZSwgYWxtb3N0IGFsbCBmdW5jdGlvbiBrZXlzIGhhdmUgYSB1bml2ZXJzYWwgdmFsdWUuXG4gICAgcmV0dXJuIHRyYW5zbGF0ZVRvS2V5W25hdGl2ZUV2ZW50LmtleUNvZGVdIHx8ICdVbmlkZW50aWZpZWQnO1xuICB9XG5cbiAgcmV0dXJuICcnO1xufVxuLyoqXG4gKiBUcmFuc2xhdGlvbiBmcm9tIG1vZGlmaWVyIGtleSB0byB0aGUgYXNzb2NpYXRlZCBwcm9wZXJ0eSBpbiB0aGUgZXZlbnQuXG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy8ja2V5cy1Nb2RpZmllcnNcbiAqL1xuXG5cbnZhciBtb2RpZmllcktleVRvUHJvcCA9IHtcbiAgQWx0OiAnYWx0S2V5JyxcbiAgQ29udHJvbDogJ2N0cmxLZXknLFxuICBNZXRhOiAnbWV0YUtleScsXG4gIFNoaWZ0OiAnc2hpZnRLZXknXG59OyAvLyBPbGRlciBicm93c2VycyAoU2FmYXJpIDw9IDEwLCBpT1MgU2FmYXJpIDw9IDEwLjIpIGRvIG5vdCBzdXBwb3J0XG4vLyBnZXRNb2RpZmllclN0YXRlLiBJZiBnZXRNb2RpZmllclN0YXRlIGlzIG5vdCBzdXBwb3J0ZWQsIHdlIG1hcCBpdCB0byBhIHNldCBvZlxuLy8gbW9kaWZpZXIga2V5cyBleHBvc2VkIGJ5IHRoZSBldmVudC4gSW4gdGhpcyBjYXNlLCBMb2NrLWtleXMgYXJlIG5vdCBzdXBwb3J0ZWQuXG5cbmZ1bmN0aW9uIG1vZGlmaWVyU3RhdGVHZXR0ZXIoa2V5QXJnKSB7XG4gIHZhciBzeW50aGV0aWNFdmVudCA9IHRoaXM7XG4gIHZhciBuYXRpdmVFdmVudCA9IHN5bnRoZXRpY0V2ZW50Lm5hdGl2ZUV2ZW50O1xuXG4gIGlmIChuYXRpdmVFdmVudC5nZXRNb2RpZmllclN0YXRlKSB7XG4gICAgcmV0dXJuIG5hdGl2ZUV2ZW50LmdldE1vZGlmaWVyU3RhdGUoa2V5QXJnKTtcbiAgfVxuXG4gIHZhciBrZXlQcm9wID0gbW9kaWZpZXJLZXlUb1Byb3Bba2V5QXJnXTtcbiAgcmV0dXJuIGtleVByb3AgPyAhIW5hdGl2ZUV2ZW50W2tleVByb3BdIDogZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGdldEV2ZW50TW9kaWZpZXJTdGF0ZShuYXRpdmVFdmVudCkge1xuICByZXR1cm4gbW9kaWZpZXJTdGF0ZUdldHRlcjtcbn1cbi8qKlxuICogQGludGVyZmFjZSBLZXlib2FyZEV2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy9cbiAqL1xuXG5cbnZhciBLZXlib2FyZEV2ZW50SW50ZXJmYWNlID0gX2Fzc2lnbih7fSwgVUlFdmVudEludGVyZmFjZSwge1xuICBrZXk6IGdldEV2ZW50S2V5LFxuICBjb2RlOiAwLFxuICBsb2NhdGlvbjogMCxcbiAgY3RybEtleTogMCxcbiAgc2hpZnRLZXk6IDAsXG4gIGFsdEtleTogMCxcbiAgbWV0YUtleTogMCxcbiAgcmVwZWF0OiAwLFxuICBsb2NhbGU6IDAsXG4gIGdldE1vZGlmaWVyU3RhdGU6IGdldEV2ZW50TW9kaWZpZXJTdGF0ZSxcbiAgLy8gTGVnYWN5IEludGVyZmFjZVxuICBjaGFyQ29kZTogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgLy8gYGNoYXJDb2RlYCBpcyB0aGUgcmVzdWx0IG9mIGEgS2V5UHJlc3MgZXZlbnQgYW5kIHJlcHJlc2VudHMgdGhlIHZhbHVlIG9mXG4gICAgLy8gdGhlIGFjdHVhbCBwcmludGFibGUgY2hhcmFjdGVyLlxuICAgIC8vIEtleVByZXNzIGlzIGRlcHJlY2F0ZWQsIGJ1dCBpdHMgcmVwbGFjZW1lbnQgaXMgbm90IHlldCBmaW5hbCBhbmQgbm90XG4gICAgLy8gaW1wbGVtZW50ZWQgaW4gYW55IG1ham9yIGJyb3dzZXIuIE9ubHkgS2V5UHJlc3MgaGFzIGNoYXJDb2RlLlxuICAgIGlmIChldmVudC50eXBlID09PSAna2V5cHJlc3MnKSB7XG4gICAgICByZXR1cm4gZ2V0RXZlbnRDaGFyQ29kZShldmVudCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIDA7XG4gIH0sXG4gIGtleUNvZGU6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIC8vIGBrZXlDb2RlYCBpcyB0aGUgcmVzdWx0IG9mIGEgS2V5RG93bi9VcCBldmVudCBhbmQgcmVwcmVzZW50cyB0aGUgdmFsdWUgb2ZcbiAgICAvLyBwaHlzaWNhbCBrZXlib2FyZCBrZXkuXG4gICAgLy8gVGhlIGFjdHVhbCBtZWFuaW5nIG9mIHRoZSB2YWx1ZSBkZXBlbmRzIG9uIHRoZSB1c2Vycycga2V5Ym9hcmQgbGF5b3V0XG4gICAgLy8gd2hpY2ggY2Fubm90IGJlIGRldGVjdGVkLiBBc3N1bWluZyB0aGF0IGl0IGlzIGEgVVMga2V5Ym9hcmQgbGF5b3V0XG4gICAgLy8gcHJvdmlkZXMgYSBzdXJwcmlzaW5nbHkgYWNjdXJhdGUgbWFwcGluZyBmb3IgVVMgYW5kIEV1cm9wZWFuIHVzZXJzLlxuICAgIC8vIER1ZSB0byB0aGlzLCBpdCBpcyBsZWZ0IHRvIHRoZSB1c2VyIHRvIGltcGxlbWVudCBhdCB0aGlzIHRpbWUuXG4gICAgaWYgKGV2ZW50LnR5cGUgPT09ICdrZXlkb3duJyB8fCBldmVudC50eXBlID09PSAna2V5dXAnKSB7XG4gICAgICByZXR1cm4gZXZlbnQua2V5Q29kZTtcbiAgICB9XG5cbiAgICByZXR1cm4gMDtcbiAgfSxcbiAgd2hpY2g6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIC8vIGB3aGljaGAgaXMgYW4gYWxpYXMgZm9yIGVpdGhlciBga2V5Q29kZWAgb3IgYGNoYXJDb2RlYCBkZXBlbmRpbmcgb24gdGhlXG4gICAgLy8gdHlwZSBvZiB0aGUgZXZlbnQuXG4gICAgaWYgKGV2ZW50LnR5cGUgPT09ICdrZXlwcmVzcycpIHtcbiAgICAgIHJldHVybiBnZXRFdmVudENoYXJDb2RlKGV2ZW50KTtcbiAgICB9XG5cbiAgICBpZiAoZXZlbnQudHlwZSA9PT0gJ2tleWRvd24nIHx8IGV2ZW50LnR5cGUgPT09ICdrZXl1cCcpIHtcbiAgICAgIHJldHVybiBldmVudC5rZXlDb2RlO1xuICAgIH1cblxuICAgIHJldHVybiAwO1xuICB9XG59KTtcblxudmFyIFN5bnRoZXRpY0tleWJvYXJkRXZlbnQgPSBjcmVhdGVTeW50aGV0aWNFdmVudChLZXlib2FyZEV2ZW50SW50ZXJmYWNlKTtcbi8qKlxuICogQGludGVyZmFjZSBQb2ludGVyRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvcG9pbnRlcmV2ZW50cy9cbiAqL1xuXG52YXIgUG9pbnRlckV2ZW50SW50ZXJmYWNlID0gX2Fzc2lnbih7fSwgTW91c2VFdmVudEludGVyZmFjZSwge1xuICBwb2ludGVySWQ6IDAsXG4gIHdpZHRoOiAwLFxuICBoZWlnaHQ6IDAsXG4gIHByZXNzdXJlOiAwLFxuICB0YW5nZW50aWFsUHJlc3N1cmU6IDAsXG4gIHRpbHRYOiAwLFxuICB0aWx0WTogMCxcbiAgdHdpc3Q6IDAsXG4gIHBvaW50ZXJUeXBlOiAwLFxuICBpc1ByaW1hcnk6IDBcbn0pO1xuXG52YXIgU3ludGhldGljUG9pbnRlckV2ZW50ID0gY3JlYXRlU3ludGhldGljRXZlbnQoUG9pbnRlckV2ZW50SW50ZXJmYWNlKTtcbi8qKlxuICogQGludGVyZmFjZSBUb3VjaEV2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL3RvdWNoLWV2ZW50cy9cbiAqL1xuXG52YXIgVG91Y2hFdmVudEludGVyZmFjZSA9IF9hc3NpZ24oe30sIFVJRXZlbnRJbnRlcmZhY2UsIHtcbiAgdG91Y2hlczogMCxcbiAgdGFyZ2V0VG91Y2hlczogMCxcbiAgY2hhbmdlZFRvdWNoZXM6IDAsXG4gIGFsdEtleTogMCxcbiAgbWV0YUtleTogMCxcbiAgY3RybEtleTogMCxcbiAgc2hpZnRLZXk6IDAsXG4gIGdldE1vZGlmaWVyU3RhdGU6IGdldEV2ZW50TW9kaWZpZXJTdGF0ZVxufSk7XG5cbnZhciBTeW50aGV0aWNUb3VjaEV2ZW50ID0gY3JlYXRlU3ludGhldGljRXZlbnQoVG91Y2hFdmVudEludGVyZmFjZSk7XG4vKipcbiAqIEBpbnRlcmZhY2UgRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvMjAwOS9XRC1jc3MzLXRyYW5zaXRpb25zLTIwMDkwMzIwLyN0cmFuc2l0aW9uLWV2ZW50cy1cbiAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1RyYW5zaXRpb25FdmVudFxuICovXG5cbnZhciBUcmFuc2l0aW9uRXZlbnRJbnRlcmZhY2UgPSBfYXNzaWduKHt9LCBFdmVudEludGVyZmFjZSwge1xuICBwcm9wZXJ0eU5hbWU6IDAsXG4gIGVsYXBzZWRUaW1lOiAwLFxuICBwc2V1ZG9FbGVtZW50OiAwXG59KTtcblxudmFyIFN5bnRoZXRpY1RyYW5zaXRpb25FdmVudCA9IGNyZWF0ZVN5bnRoZXRpY0V2ZW50KFRyYW5zaXRpb25FdmVudEludGVyZmFjZSk7XG4vKipcbiAqIEBpbnRlcmZhY2UgV2hlZWxFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvXG4gKi9cblxudmFyIFdoZWVsRXZlbnRJbnRlcmZhY2UgPSBfYXNzaWduKHt9LCBNb3VzZUV2ZW50SW50ZXJmYWNlLCB7XG4gIGRlbHRhWDogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgcmV0dXJuICdkZWx0YVgnIGluIGV2ZW50ID8gZXZlbnQuZGVsdGFYIDogLy8gRmFsbGJhY2sgdG8gYHdoZWVsRGVsdGFYYCBmb3IgV2Via2l0IGFuZCBub3JtYWxpemUgKHJpZ2h0IGlzIHBvc2l0aXZlKS5cbiAgICAnd2hlZWxEZWx0YVgnIGluIGV2ZW50ID8gLWV2ZW50LndoZWVsRGVsdGFYIDogMDtcbiAgfSxcbiAgZGVsdGFZOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICByZXR1cm4gJ2RlbHRhWScgaW4gZXZlbnQgPyBldmVudC5kZWx0YVkgOiAvLyBGYWxsYmFjayB0byBgd2hlZWxEZWx0YVlgIGZvciBXZWJraXQgYW5kIG5vcm1hbGl6ZSAoZG93biBpcyBwb3NpdGl2ZSkuXG4gICAgJ3doZWVsRGVsdGFZJyBpbiBldmVudCA/IC1ldmVudC53aGVlbERlbHRhWSA6IC8vIEZhbGxiYWNrIHRvIGB3aGVlbERlbHRhYCBmb3IgSUU8OSBhbmQgbm9ybWFsaXplIChkb3duIGlzIHBvc2l0aXZlKS5cbiAgICAnd2hlZWxEZWx0YScgaW4gZXZlbnQgPyAtZXZlbnQud2hlZWxEZWx0YSA6IDA7XG4gIH0sXG4gIGRlbHRhWjogMCxcbiAgLy8gQnJvd3NlcnMgd2l0aG91dCBcImRlbHRhTW9kZVwiIGlzIHJlcG9ydGluZyBpbiByYXcgd2hlZWwgZGVsdGEgd2hlcmUgb25lXG4gIC8vIG5vdGNoIG9uIHRoZSBzY3JvbGwgaXMgYWx3YXlzICsvLSAxMjAsIHJvdWdobHkgZXF1aXZhbGVudCB0byBwaXhlbHMuXG4gIC8vIEEgZ29vZCBhcHByb3hpbWF0aW9uIG9mIERPTV9ERUxUQV9MSU5FICgxKSBpcyA1JSBvZiB2aWV3cG9ydCBzaXplIG9yXG4gIC8vIH40MCBwaXhlbHMsIGZvciBET01fREVMVEFfU0NSRUVOICgyKSBpdCBpcyA4Ny41JSBvZiB2aWV3cG9ydCBzaXplLlxuICBkZWx0YU1vZGU6IDBcbn0pO1xuXG52YXIgU3ludGhldGljV2hlZWxFdmVudCA9IGNyZWF0ZVN5bnRoZXRpY0V2ZW50KFdoZWVsRXZlbnRJbnRlcmZhY2UpO1xuXG52YXIgRU5EX0tFWUNPREVTID0gWzksIDEzLCAyNywgMzJdOyAvLyBUYWIsIFJldHVybiwgRXNjLCBTcGFjZVxuXG52YXIgU1RBUlRfS0VZQ09ERSA9IDIyOTtcbnZhciBjYW5Vc2VDb21wb3NpdGlvbkV2ZW50ID0gY2FuVXNlRE9NICYmICdDb21wb3NpdGlvbkV2ZW50JyBpbiB3aW5kb3c7XG52YXIgZG9jdW1lbnRNb2RlID0gbnVsbDtcblxuaWYgKGNhblVzZURPTSAmJiAnZG9jdW1lbnRNb2RlJyBpbiBkb2N1bWVudCkge1xuICBkb2N1bWVudE1vZGUgPSBkb2N1bWVudC5kb2N1bWVudE1vZGU7XG59IC8vIFdlYmtpdCBvZmZlcnMgYSB2ZXJ5IHVzZWZ1bCBgdGV4dElucHV0YCBldmVudCB0aGF0IGNhbiBiZSB1c2VkIHRvXG4vLyBkaXJlY3RseSByZXByZXNlbnQgYGJlZm9yZUlucHV0YC4gVGhlIElFIGB0ZXh0aW5wdXRgIGV2ZW50IGlzIG5vdCBhc1xuLy8gdXNlZnVsLCBzbyB3ZSBkb24ndCB1c2UgaXQuXG5cblxudmFyIGNhblVzZVRleHRJbnB1dEV2ZW50ID0gY2FuVXNlRE9NICYmICdUZXh0RXZlbnQnIGluIHdpbmRvdyAmJiAhZG9jdW1lbnRNb2RlOyAvLyBJbiBJRTkrLCB3ZSBoYXZlIGFjY2VzcyB0byBjb21wb3NpdGlvbiBldmVudHMsIGJ1dCB0aGUgZGF0YSBzdXBwbGllZFxuLy8gYnkgdGhlIG5hdGl2ZSBjb21wb3NpdGlvbmVuZCBldmVudCBtYXkgYmUgaW5jb3JyZWN0LiBKYXBhbmVzZSBpZGVvZ3JhcGhpY1xuLy8gc3BhY2VzLCBmb3IgaW5zdGFuY2UgKFxcdTMwMDApIGFyZSBub3QgcmVjb3JkZWQgY29ycmVjdGx5LlxuXG52YXIgdXNlRmFsbGJhY2tDb21wb3NpdGlvbkRhdGEgPSBjYW5Vc2VET00gJiYgKCFjYW5Vc2VDb21wb3NpdGlvbkV2ZW50IHx8IGRvY3VtZW50TW9kZSAmJiBkb2N1bWVudE1vZGUgPiA4ICYmIGRvY3VtZW50TW9kZSA8PSAxMSk7XG52YXIgU1BBQ0VCQVJfQ09ERSA9IDMyO1xudmFyIFNQQUNFQkFSX0NIQVIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKFNQQUNFQkFSX0NPREUpO1xuXG5mdW5jdGlvbiByZWdpc3RlckV2ZW50cygpIHtcbiAgcmVnaXN0ZXJUd29QaGFzZUV2ZW50KCdvbkJlZm9yZUlucHV0JywgWydjb21wb3NpdGlvbmVuZCcsICdrZXlwcmVzcycsICd0ZXh0SW5wdXQnLCAncGFzdGUnXSk7XG4gIHJlZ2lzdGVyVHdvUGhhc2VFdmVudCgnb25Db21wb3NpdGlvbkVuZCcsIFsnY29tcG9zaXRpb25lbmQnLCAnZm9jdXNvdXQnLCAna2V5ZG93bicsICdrZXlwcmVzcycsICdrZXl1cCcsICdtb3VzZWRvd24nXSk7XG4gIHJlZ2lzdGVyVHdvUGhhc2VFdmVudCgnb25Db21wb3NpdGlvblN0YXJ0JywgWydjb21wb3NpdGlvbnN0YXJ0JywgJ2ZvY3Vzb3V0JywgJ2tleWRvd24nLCAna2V5cHJlc3MnLCAna2V5dXAnLCAnbW91c2Vkb3duJ10pO1xuICByZWdpc3RlclR3b1BoYXNlRXZlbnQoJ29uQ29tcG9zaXRpb25VcGRhdGUnLCBbJ2NvbXBvc2l0aW9udXBkYXRlJywgJ2ZvY3Vzb3V0JywgJ2tleWRvd24nLCAna2V5cHJlc3MnLCAna2V5dXAnLCAnbW91c2Vkb3duJ10pO1xufSAvLyBUcmFjayB3aGV0aGVyIHdlJ3ZlIGV2ZXIgaGFuZGxlZCBhIGtleXByZXNzIG9uIHRoZSBzcGFjZSBrZXkuXG5cblxudmFyIGhhc1NwYWNlS2V5cHJlc3MgPSBmYWxzZTtcbi8qKlxuICogUmV0dXJuIHdoZXRoZXIgYSBuYXRpdmUga2V5cHJlc3MgZXZlbnQgaXMgYXNzdW1lZCB0byBiZSBhIGNvbW1hbmQuXG4gKiBUaGlzIGlzIHJlcXVpcmVkIGJlY2F1c2UgRmlyZWZveCBmaXJlcyBga2V5cHJlc3NgIGV2ZW50cyBmb3Iga2V5IGNvbW1hbmRzXG4gKiAoY3V0LCBjb3B5LCBzZWxlY3QtYWxsLCBldGMuKSBldmVuIHRob3VnaCBubyBjaGFyYWN0ZXIgaXMgaW5zZXJ0ZWQuXG4gKi9cblxuZnVuY3Rpb24gaXNLZXlwcmVzc0NvbW1hbmQobmF0aXZlRXZlbnQpIHtcbiAgcmV0dXJuIChuYXRpdmVFdmVudC5jdHJsS2V5IHx8IG5hdGl2ZUV2ZW50LmFsdEtleSB8fCBuYXRpdmVFdmVudC5tZXRhS2V5KSAmJiAvLyBjdHJsS2V5ICYmIGFsdEtleSBpcyBlcXVpdmFsZW50IHRvIEFsdEdyLCBhbmQgaXMgbm90IGEgY29tbWFuZC5cbiAgIShuYXRpdmVFdmVudC5jdHJsS2V5ICYmIG5hdGl2ZUV2ZW50LmFsdEtleSk7XG59XG4vKipcbiAqIFRyYW5zbGF0ZSBuYXRpdmUgdG9wIGxldmVsIGV2ZW50cyBpbnRvIGV2ZW50IHR5cGVzLlxuICovXG5cblxuZnVuY3Rpb24gZ2V0Q29tcG9zaXRpb25FdmVudFR5cGUoZG9tRXZlbnROYW1lKSB7XG4gIHN3aXRjaCAoZG9tRXZlbnROYW1lKSB7XG4gICAgY2FzZSAnY29tcG9zaXRpb25zdGFydCc6XG4gICAgICByZXR1cm4gJ29uQ29tcG9zaXRpb25TdGFydCc7XG5cbiAgICBjYXNlICdjb21wb3NpdGlvbmVuZCc6XG4gICAgICByZXR1cm4gJ29uQ29tcG9zaXRpb25FbmQnO1xuXG4gICAgY2FzZSAnY29tcG9zaXRpb251cGRhdGUnOlxuICAgICAgcmV0dXJuICdvbkNvbXBvc2l0aW9uVXBkYXRlJztcbiAgfVxufVxuLyoqXG4gKiBEb2VzIG91ciBmYWxsYmFjayBiZXN0LWd1ZXNzIG1vZGVsIHRoaW5rIHRoaXMgZXZlbnQgc2lnbmlmaWVzIHRoYXRcbiAqIGNvbXBvc2l0aW9uIGhhcyBiZWd1bj9cbiAqL1xuXG5cbmZ1bmN0aW9uIGlzRmFsbGJhY2tDb21wb3NpdGlvblN0YXJ0KGRvbUV2ZW50TmFtZSwgbmF0aXZlRXZlbnQpIHtcbiAgcmV0dXJuIGRvbUV2ZW50TmFtZSA9PT0gJ2tleWRvd24nICYmIG5hdGl2ZUV2ZW50LmtleUNvZGUgPT09IFNUQVJUX0tFWUNPREU7XG59XG4vKipcbiAqIERvZXMgb3VyIGZhbGxiYWNrIG1vZGUgdGhpbmsgdGhhdCB0aGlzIGV2ZW50IGlzIHRoZSBlbmQgb2YgY29tcG9zaXRpb24/XG4gKi9cblxuXG5mdW5jdGlvbiBpc0ZhbGxiYWNrQ29tcG9zaXRpb25FbmQoZG9tRXZlbnROYW1lLCBuYXRpdmVFdmVudCkge1xuICBzd2l0Y2ggKGRvbUV2ZW50TmFtZSkge1xuICAgIGNhc2UgJ2tleXVwJzpcbiAgICAgIC8vIENvbW1hbmQga2V5cyBpbnNlcnQgb3IgY2xlYXIgSU1FIGlucHV0LlxuICAgICAgcmV0dXJuIEVORF9LRVlDT0RFUy5pbmRleE9mKG5hdGl2ZUV2ZW50LmtleUNvZGUpICE9PSAtMTtcblxuICAgIGNhc2UgJ2tleWRvd24nOlxuICAgICAgLy8gRXhwZWN0IElNRSBrZXlDb2RlIG9uIGVhY2gga2V5ZG93bi4gSWYgd2UgZ2V0IGFueSBvdGhlclxuICAgICAgLy8gY29kZSB3ZSBtdXN0IGhhdmUgZXhpdGVkIGVhcmxpZXIuXG4gICAgICByZXR1cm4gbmF0aXZlRXZlbnQua2V5Q29kZSAhPT0gU1RBUlRfS0VZQ09ERTtcblxuICAgIGNhc2UgJ2tleXByZXNzJzpcbiAgICBjYXNlICdtb3VzZWRvd24nOlxuICAgIGNhc2UgJ2ZvY3Vzb3V0JzpcbiAgICAgIC8vIEV2ZW50cyBhcmUgbm90IHBvc3NpYmxlIHdpdGhvdXQgY2FuY2VsbGluZyBJTUUuXG4gICAgICByZXR1cm4gdHJ1ZTtcblxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cbi8qKlxuICogR29vZ2xlIElucHV0IFRvb2xzIHByb3ZpZGVzIGNvbXBvc2l0aW9uIGRhdGEgdmlhIGEgQ3VzdG9tRXZlbnQsXG4gKiB3aXRoIHRoZSBgZGF0YWAgcHJvcGVydHkgcG9wdWxhdGVkIGluIHRoZSBgZGV0YWlsYCBvYmplY3QuIElmIHRoaXNcbiAqIGlzIGF2YWlsYWJsZSBvbiB0aGUgZXZlbnQgb2JqZWN0LCB1c2UgaXQuIElmIG5vdCwgdGhpcyBpcyBhIHBsYWluXG4gKiBjb21wb3NpdGlvbiBldmVudCBhbmQgd2UgaGF2ZSBub3RoaW5nIHNwZWNpYWwgdG8gZXh0cmFjdC5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnRcbiAqIEByZXR1cm4gez9zdHJpbmd9XG4gKi9cblxuXG5mdW5jdGlvbiBnZXREYXRhRnJvbUN1c3RvbUV2ZW50KG5hdGl2ZUV2ZW50KSB7XG4gIHZhciBkZXRhaWwgPSBuYXRpdmVFdmVudC5kZXRhaWw7XG5cbiAgaWYgKHR5cGVvZiBkZXRhaWwgPT09ICdvYmplY3QnICYmICdkYXRhJyBpbiBkZXRhaWwpIHtcbiAgICByZXR1cm4gZGV0YWlsLmRhdGE7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cbi8qKlxuICogQ2hlY2sgaWYgYSBjb21wb3NpdGlvbiBldmVudCB3YXMgdHJpZ2dlcmVkIGJ5IEtvcmVhbiBJTUUuXG4gKiBPdXIgZmFsbGJhY2sgbW9kZSBkb2VzIG5vdCB3b3JrIHdlbGwgd2l0aCBJRSdzIEtvcmVhbiBJTUUsXG4gKiBzbyBqdXN0IHVzZSBuYXRpdmUgY29tcG9zaXRpb24gZXZlbnRzIHdoZW4gS29yZWFuIElNRSBpcyB1c2VkLlxuICogQWx0aG91Z2ggQ29tcG9zaXRpb25FdmVudC5sb2NhbGUgcHJvcGVydHkgaXMgZGVwcmVjYXRlZCxcbiAqIGl0IGlzIGF2YWlsYWJsZSBpbiBJRSwgd2hlcmUgb3VyIGZhbGxiYWNrIG1vZGUgaXMgZW5hYmxlZC5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnRcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cblxuXG5mdW5jdGlvbiBpc1VzaW5nS29yZWFuSU1FKG5hdGl2ZUV2ZW50KSB7XG4gIHJldHVybiBuYXRpdmVFdmVudC5sb2NhbGUgPT09ICdrbyc7XG59IC8vIFRyYWNrIHRoZSBjdXJyZW50IElNRSBjb21wb3NpdGlvbiBzdGF0dXMsIGlmIGFueS5cblxuXG52YXIgaXNDb21wb3NpbmcgPSBmYWxzZTtcbi8qKlxuICogQHJldHVybiB7P29iamVjdH0gQSBTeW50aGV0aWNDb21wb3NpdGlvbkV2ZW50LlxuICovXG5cbmZ1bmN0aW9uIGV4dHJhY3RDb21wb3NpdGlvbkV2ZW50KGRpc3BhdGNoUXVldWUsIGRvbUV2ZW50TmFtZSwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIHZhciBldmVudFR5cGU7XG4gIHZhciBmYWxsYmFja0RhdGE7XG5cbiAgaWYgKGNhblVzZUNvbXBvc2l0aW9uRXZlbnQpIHtcbiAgICBldmVudFR5cGUgPSBnZXRDb21wb3NpdGlvbkV2ZW50VHlwZShkb21FdmVudE5hbWUpO1xuICB9IGVsc2UgaWYgKCFpc0NvbXBvc2luZykge1xuICAgIGlmIChpc0ZhbGxiYWNrQ29tcG9zaXRpb25TdGFydChkb21FdmVudE5hbWUsIG5hdGl2ZUV2ZW50KSkge1xuICAgICAgZXZlbnRUeXBlID0gJ29uQ29tcG9zaXRpb25TdGFydCc7XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzRmFsbGJhY2tDb21wb3NpdGlvbkVuZChkb21FdmVudE5hbWUsIG5hdGl2ZUV2ZW50KSkge1xuICAgIGV2ZW50VHlwZSA9ICdvbkNvbXBvc2l0aW9uRW5kJztcbiAgfVxuXG4gIGlmICghZXZlbnRUeXBlKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBpZiAodXNlRmFsbGJhY2tDb21wb3NpdGlvbkRhdGEgJiYgIWlzVXNpbmdLb3JlYW5JTUUobmF0aXZlRXZlbnQpKSB7XG4gICAgLy8gVGhlIGN1cnJlbnQgY29tcG9zaXRpb24gaXMgc3RvcmVkIHN0YXRpY2FsbHkgYW5kIG11c3Qgbm90IGJlXG4gICAgLy8gb3ZlcndyaXR0ZW4gd2hpbGUgY29tcG9zaXRpb24gY29udGludWVzLlxuICAgIGlmICghaXNDb21wb3NpbmcgJiYgZXZlbnRUeXBlID09PSAnb25Db21wb3NpdGlvblN0YXJ0Jykge1xuICAgICAgaXNDb21wb3NpbmcgPSBpbml0aWFsaXplKG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbiAgICB9IGVsc2UgaWYgKGV2ZW50VHlwZSA9PT0gJ29uQ29tcG9zaXRpb25FbmQnKSB7XG4gICAgICBpZiAoaXNDb21wb3NpbmcpIHtcbiAgICAgICAgZmFsbGJhY2tEYXRhID0gZ2V0RGF0YSgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciBsaXN0ZW5lcnMgPSBhY2N1bXVsYXRlVHdvUGhhc2VMaXN0ZW5lcnModGFyZ2V0SW5zdCwgZXZlbnRUeXBlKTtcblxuICBpZiAobGlzdGVuZXJzLmxlbmd0aCA+IDApIHtcbiAgICB2YXIgZXZlbnQgPSBuZXcgU3ludGhldGljQ29tcG9zaXRpb25FdmVudChldmVudFR5cGUsIGRvbUV2ZW50TmFtZSwgbnVsbCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbiAgICBkaXNwYXRjaFF1ZXVlLnB1c2goe1xuICAgICAgZXZlbnQ6IGV2ZW50LFxuICAgICAgbGlzdGVuZXJzOiBsaXN0ZW5lcnNcbiAgICB9KTtcblxuICAgIGlmIChmYWxsYmFja0RhdGEpIHtcbiAgICAgIC8vIEluamVjdCBkYXRhIGdlbmVyYXRlZCBmcm9tIGZhbGxiYWNrIHBhdGggaW50byB0aGUgc3ludGhldGljIGV2ZW50LlxuICAgICAgLy8gVGhpcyBtYXRjaGVzIHRoZSBwcm9wZXJ0eSBvZiBuYXRpdmUgQ29tcG9zaXRpb25FdmVudEludGVyZmFjZS5cbiAgICAgIGV2ZW50LmRhdGEgPSBmYWxsYmFja0RhdGE7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBjdXN0b21EYXRhID0gZ2V0RGF0YUZyb21DdXN0b21FdmVudChuYXRpdmVFdmVudCk7XG5cbiAgICAgIGlmIChjdXN0b21EYXRhICE9PSBudWxsKSB7XG4gICAgICAgIGV2ZW50LmRhdGEgPSBjdXN0b21EYXRhO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBnZXROYXRpdmVCZWZvcmVJbnB1dENoYXJzKGRvbUV2ZW50TmFtZSwgbmF0aXZlRXZlbnQpIHtcbiAgc3dpdGNoIChkb21FdmVudE5hbWUpIHtcbiAgICBjYXNlICdjb21wb3NpdGlvbmVuZCc6XG4gICAgICByZXR1cm4gZ2V0RGF0YUZyb21DdXN0b21FdmVudChuYXRpdmVFdmVudCk7XG5cbiAgICBjYXNlICdrZXlwcmVzcyc6XG4gICAgICAvKipcbiAgICAgICAqIElmIG5hdGl2ZSBgdGV4dElucHV0YCBldmVudHMgYXJlIGF2YWlsYWJsZSwgb3VyIGdvYWwgaXMgdG8gbWFrZVxuICAgICAgICogdXNlIG9mIHRoZW0uIEhvd2V2ZXIsIHRoZXJlIGlzIGEgc3BlY2lhbCBjYXNlOiB0aGUgc3BhY2ViYXIga2V5LlxuICAgICAgICogSW4gV2Via2l0LCBwcmV2ZW50aW5nIGRlZmF1bHQgb24gYSBzcGFjZWJhciBgdGV4dElucHV0YCBldmVudFxuICAgICAgICogY2FuY2VscyBjaGFyYWN0ZXIgaW5zZXJ0aW9uLCBidXQgaXQgKmFsc28qIGNhdXNlcyB0aGUgYnJvd3NlclxuICAgICAgICogdG8gZmFsbCBiYWNrIHRvIGl0cyBkZWZhdWx0IHNwYWNlYmFyIGJlaGF2aW9yIG9mIHNjcm9sbGluZyB0aGVcbiAgICAgICAqIHBhZ2UuXG4gICAgICAgKlxuICAgICAgICogVHJhY2tpbmcgYXQ6XG4gICAgICAgKiBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9MzU1MTAzXG4gICAgICAgKlxuICAgICAgICogVG8gYXZvaWQgdGhpcyBpc3N1ZSwgdXNlIHRoZSBrZXlwcmVzcyBldmVudCBhcyBpZiBubyBgdGV4dElucHV0YFxuICAgICAgICogZXZlbnQgaXMgYXZhaWxhYmxlLlxuICAgICAgICovXG4gICAgICB2YXIgd2hpY2ggPSBuYXRpdmVFdmVudC53aGljaDtcblxuICAgICAgaWYgKHdoaWNoICE9PSBTUEFDRUJBUl9DT0RFKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICBoYXNTcGFjZUtleXByZXNzID0gdHJ1ZTtcbiAgICAgIHJldHVybiBTUEFDRUJBUl9DSEFSO1xuXG4gICAgY2FzZSAndGV4dElucHV0JzpcbiAgICAgIC8vIFJlY29yZCB0aGUgY2hhcmFjdGVycyB0byBiZSBhZGRlZCB0byB0aGUgRE9NLlxuICAgICAgdmFyIGNoYXJzID0gbmF0aXZlRXZlbnQuZGF0YTsgLy8gSWYgaXQncyBhIHNwYWNlYmFyIGNoYXJhY3RlciwgYXNzdW1lIHRoYXQgd2UgaGF2ZSBhbHJlYWR5IGhhbmRsZWRcbiAgICAgIC8vIGl0IGF0IHRoZSBrZXlwcmVzcyBsZXZlbCBhbmQgYmFpbCBpbW1lZGlhdGVseS4gQW5kcm9pZCBDaHJvbWVcbiAgICAgIC8vIGRvZXNuJ3QgZ2l2ZSB1cyBrZXljb2Rlcywgc28gd2UgbmVlZCB0byBpZ25vcmUgaXQuXG5cbiAgICAgIGlmIChjaGFycyA9PT0gU1BBQ0VCQVJfQ0hBUiAmJiBoYXNTcGFjZUtleXByZXNzKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY2hhcnM7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgLy8gRm9yIG90aGVyIG5hdGl2ZSBldmVudCB0eXBlcywgZG8gbm90aGluZy5cbiAgICAgIHJldHVybiBudWxsO1xuICB9XG59XG4vKipcbiAqIEZvciBicm93c2VycyB0aGF0IGRvIG5vdCBwcm92aWRlIHRoZSBgdGV4dElucHV0YCBldmVudCwgZXh0cmFjdCB0aGVcbiAqIGFwcHJvcHJpYXRlIHN0cmluZyB0byB1c2UgZm9yIFN5bnRoZXRpY0lucHV0RXZlbnQuXG4gKi9cblxuXG5mdW5jdGlvbiBnZXRGYWxsYmFja0JlZm9yZUlucHV0Q2hhcnMoZG9tRXZlbnROYW1lLCBuYXRpdmVFdmVudCkge1xuICAvLyBJZiB3ZSBhcmUgY3VycmVudGx5IGNvbXBvc2luZyAoSU1FKSBhbmQgdXNpbmcgYSBmYWxsYmFjayB0byBkbyBzbyxcbiAgLy8gdHJ5IHRvIGV4dHJhY3QgdGhlIGNvbXBvc2VkIGNoYXJhY3RlcnMgZnJvbSB0aGUgZmFsbGJhY2sgb2JqZWN0LlxuICAvLyBJZiBjb21wb3NpdGlvbiBldmVudCBpcyBhdmFpbGFibGUsIHdlIGV4dHJhY3QgYSBzdHJpbmcgb25seSBhdFxuICAvLyBjb21wb3NpdGlvbmV2ZW50LCBvdGhlcndpc2UgZXh0cmFjdCBpdCBhdCBmYWxsYmFjayBldmVudHMuXG4gIGlmIChpc0NvbXBvc2luZykge1xuICAgIGlmIChkb21FdmVudE5hbWUgPT09ICdjb21wb3NpdGlvbmVuZCcgfHwgIWNhblVzZUNvbXBvc2l0aW9uRXZlbnQgJiYgaXNGYWxsYmFja0NvbXBvc2l0aW9uRW5kKGRvbUV2ZW50TmFtZSwgbmF0aXZlRXZlbnQpKSB7XG4gICAgICB2YXIgY2hhcnMgPSBnZXREYXRhKCk7XG4gICAgICByZXNldCgpO1xuICAgICAgaXNDb21wb3NpbmcgPSBmYWxzZTtcbiAgICAgIHJldHVybiBjaGFycztcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHN3aXRjaCAoZG9tRXZlbnROYW1lKSB7XG4gICAgY2FzZSAncGFzdGUnOlxuICAgICAgLy8gSWYgYSBwYXN0ZSBldmVudCBvY2N1cnMgYWZ0ZXIgYSBrZXlwcmVzcywgdGhyb3cgb3V0IHRoZSBpbnB1dFxuICAgICAgLy8gY2hhcnMuIFBhc3RlIGV2ZW50cyBzaG91bGQgbm90IGxlYWQgdG8gQmVmb3JlSW5wdXQgZXZlbnRzLlxuICAgICAgcmV0dXJuIG51bGw7XG5cbiAgICBjYXNlICdrZXlwcmVzcyc6XG4gICAgICAvKipcbiAgICAgICAqIEFzIG9mIHYyNywgRmlyZWZveCBtYXkgZmlyZSBrZXlwcmVzcyBldmVudHMgZXZlbiB3aGVuIG5vIGNoYXJhY3RlclxuICAgICAgICogd2lsbCBiZSBpbnNlcnRlZC4gQSBmZXcgcG9zc2liaWxpdGllczpcbiAgICAgICAqXG4gICAgICAgKiAtIGB3aGljaGAgaXMgYDBgLiBBcnJvdyBrZXlzLCBFc2Mga2V5LCBldGMuXG4gICAgICAgKlxuICAgICAgICogLSBgd2hpY2hgIGlzIHRoZSBwcmVzc2VkIGtleSBjb2RlLCBidXQgbm8gY2hhciBpcyBhdmFpbGFibGUuXG4gICAgICAgKiAgIEV4OiAnQWx0R3IgKyBkYCBpbiBQb2xpc2guIFRoZXJlIGlzIG5vIG1vZGlmaWVkIGNoYXJhY3RlciBmb3JcbiAgICAgICAqICAgdGhpcyBrZXkgY29tYmluYXRpb24gYW5kIG5vIGNoYXJhY3RlciBpcyBpbnNlcnRlZCBpbnRvIHRoZVxuICAgICAgICogICBkb2N1bWVudCwgYnV0IEZGIGZpcmVzIHRoZSBrZXlwcmVzcyBmb3IgY2hhciBjb2RlIGAxMDBgIGFueXdheS5cbiAgICAgICAqICAgTm8gYGlucHV0YCBldmVudCB3aWxsIG9jY3VyLlxuICAgICAgICpcbiAgICAgICAqIC0gYHdoaWNoYCBpcyB0aGUgcHJlc3NlZCBrZXkgY29kZSwgYnV0IGEgY29tbWFuZCBjb21iaW5hdGlvbiBpc1xuICAgICAgICogICBiZWluZyB1c2VkLiBFeDogYENtZCtDYC4gTm8gY2hhcmFjdGVyIGlzIGluc2VydGVkLCBhbmQgbm9cbiAgICAgICAqICAgYGlucHV0YCBldmVudCB3aWxsIG9jY3VyLlxuICAgICAgICovXG4gICAgICBpZiAoIWlzS2V5cHJlc3NDb21tYW5kKG5hdGl2ZUV2ZW50KSkge1xuICAgICAgICAvLyBJRSBmaXJlcyB0aGUgYGtleXByZXNzYCBldmVudCB3aGVuIGEgdXNlciB0eXBlcyBhbiBlbW9qaSB2aWFcbiAgICAgICAgLy8gVG91Y2gga2V5Ym9hcmQgb2YgV2luZG93cy4gIEluIHN1Y2ggYSBjYXNlLCB0aGUgYGNoYXJgIHByb3BlcnR5XG4gICAgICAgIC8vIGhvbGRzIGFuIGVtb2ppIGNoYXJhY3RlciBsaWtlIGBcXHVEODNEXFx1REUwQWAuICBCZWNhdXNlIGl0cyBsZW5ndGhcbiAgICAgICAgLy8gaXMgMiwgdGhlIHByb3BlcnR5IGB3aGljaGAgZG9lcyBub3QgcmVwcmVzZW50IGFuIGVtb2ppIGNvcnJlY3RseS5cbiAgICAgICAgLy8gSW4gc3VjaCBhIGNhc2UsIHdlIGRpcmVjdGx5IHJldHVybiB0aGUgYGNoYXJgIHByb3BlcnR5IGluc3RlYWQgb2ZcbiAgICAgICAgLy8gdXNpbmcgYHdoaWNoYC5cbiAgICAgICAgaWYgKG5hdGl2ZUV2ZW50LmNoYXIgJiYgbmF0aXZlRXZlbnQuY2hhci5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgcmV0dXJuIG5hdGl2ZUV2ZW50LmNoYXI7XG4gICAgICAgIH0gZWxzZSBpZiAobmF0aXZlRXZlbnQud2hpY2gpIHtcbiAgICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShuYXRpdmVFdmVudC53aGljaCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG51bGw7XG5cbiAgICBjYXNlICdjb21wb3NpdGlvbmVuZCc6XG4gICAgICByZXR1cm4gdXNlRmFsbGJhY2tDb21wb3NpdGlvbkRhdGEgJiYgIWlzVXNpbmdLb3JlYW5JTUUobmF0aXZlRXZlbnQpID8gbnVsbCA6IG5hdGl2ZUV2ZW50LmRhdGE7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cbi8qKlxuICogRXh0cmFjdCBhIFN5bnRoZXRpY0lucHV0RXZlbnQgZm9yIGBiZWZvcmVJbnB1dGAsIGJhc2VkIG9uIGVpdGhlciBuYXRpdmVcbiAqIGB0ZXh0SW5wdXRgIG9yIGZhbGxiYWNrIGJlaGF2aW9yLlxuICpcbiAqIEByZXR1cm4gez9vYmplY3R9IEEgU3ludGhldGljSW5wdXRFdmVudC5cbiAqL1xuXG5cbmZ1bmN0aW9uIGV4dHJhY3RCZWZvcmVJbnB1dEV2ZW50KGRpc3BhdGNoUXVldWUsIGRvbUV2ZW50TmFtZSwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIHZhciBjaGFycztcblxuICBpZiAoY2FuVXNlVGV4dElucHV0RXZlbnQpIHtcbiAgICBjaGFycyA9IGdldE5hdGl2ZUJlZm9yZUlucHV0Q2hhcnMoZG9tRXZlbnROYW1lLCBuYXRpdmVFdmVudCk7XG4gIH0gZWxzZSB7XG4gICAgY2hhcnMgPSBnZXRGYWxsYmFja0JlZm9yZUlucHV0Q2hhcnMoZG9tRXZlbnROYW1lLCBuYXRpdmVFdmVudCk7XG4gIH0gLy8gSWYgbm8gY2hhcmFjdGVycyBhcmUgYmVpbmcgaW5zZXJ0ZWQsIG5vIEJlZm9yZUlucHV0IGV2ZW50IHNob3VsZFxuICAvLyBiZSBmaXJlZC5cblxuXG4gIGlmICghY2hhcnMpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBsaXN0ZW5lcnMgPSBhY2N1bXVsYXRlVHdvUGhhc2VMaXN0ZW5lcnModGFyZ2V0SW5zdCwgJ29uQmVmb3JlSW5wdXQnKTtcblxuICBpZiAobGlzdGVuZXJzLmxlbmd0aCA+IDApIHtcbiAgICB2YXIgZXZlbnQgPSBuZXcgU3ludGhldGljSW5wdXRFdmVudCgnb25CZWZvcmVJbnB1dCcsICdiZWZvcmVpbnB1dCcsIG51bGwsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG4gICAgZGlzcGF0Y2hRdWV1ZS5wdXNoKHtcbiAgICAgIGV2ZW50OiBldmVudCxcbiAgICAgIGxpc3RlbmVyczogbGlzdGVuZXJzXG4gICAgfSk7XG4gICAgZXZlbnQuZGF0YSA9IGNoYXJzO1xuICB9XG59XG4vKipcbiAqIENyZWF0ZSBhbiBgb25CZWZvcmVJbnB1dGAgZXZlbnQgdG8gbWF0Y2hcbiAqIGh0dHA6Ly93d3cudzMub3JnL1RSLzIwMTMvV0QtRE9NLUxldmVsLTMtRXZlbnRzLTIwMTMxMTA1LyNldmVudHMtaW5wdXRldmVudHMuXG4gKlxuICogVGhpcyBldmVudCBwbHVnaW4gaXMgYmFzZWQgb24gdGhlIG5hdGl2ZSBgdGV4dElucHV0YCBldmVudFxuICogYXZhaWxhYmxlIGluIENocm9tZSwgU2FmYXJpLCBPcGVyYSwgYW5kIElFLiBUaGlzIGV2ZW50IGZpcmVzIGFmdGVyXG4gKiBgb25LZXlQcmVzc2AgYW5kIGBvbkNvbXBvc2l0aW9uRW5kYCwgYnV0IGJlZm9yZSBgb25JbnB1dGAuXG4gKlxuICogYGJlZm9yZUlucHV0YCBpcyBzcGVjJ2QgYnV0IG5vdCBpbXBsZW1lbnRlZCBpbiBhbnkgYnJvd3NlcnMsIGFuZFxuICogdGhlIGBpbnB1dGAgZXZlbnQgZG9lcyBub3QgcHJvdmlkZSBhbnkgdXNlZnVsIGluZm9ybWF0aW9uIGFib3V0IHdoYXQgaGFzXG4gKiBhY3R1YWxseSBiZWVuIGFkZGVkLCBjb250cmFyeSB0byB0aGUgc3BlYy4gVGh1cywgYHRleHRJbnB1dGAgaXMgdGhlIGJlc3RcbiAqIGF2YWlsYWJsZSBldmVudCB0byBpZGVudGlmeSB0aGUgY2hhcmFjdGVycyB0aGF0IGhhdmUgYWN0dWFsbHkgYmVlbiBpbnNlcnRlZFxuICogaW50byB0aGUgdGFyZ2V0IG5vZGUuXG4gKlxuICogVGhpcyBwbHVnaW4gaXMgYWxzbyByZXNwb25zaWJsZSBmb3IgZW1pdHRpbmcgYGNvbXBvc2l0aW9uYCBldmVudHMsIHRodXNcbiAqIGFsbG93aW5nIHVzIHRvIHNoYXJlIGNvbXBvc2l0aW9uIGZhbGxiYWNrIGNvZGUgZm9yIGJvdGggYGJlZm9yZUlucHV0YCBhbmRcbiAqIGBjb21wb3NpdGlvbmAgZXZlbnQgdHlwZXMuXG4gKi9cblxuXG5mdW5jdGlvbiBleHRyYWN0RXZlbnRzKGRpc3BhdGNoUXVldWUsIGRvbUV2ZW50TmFtZSwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0LCBldmVudFN5c3RlbUZsYWdzLCB0YXJnZXRDb250YWluZXIpIHtcbiAgZXh0cmFjdENvbXBvc2l0aW9uRXZlbnQoZGlzcGF0Y2hRdWV1ZSwgZG9tRXZlbnROYW1lLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xuICBleHRyYWN0QmVmb3JlSW5wdXRFdmVudChkaXNwYXRjaFF1ZXVlLCBkb21FdmVudE5hbWUsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG59XG5cbi8qKlxuICogQHNlZSBodHRwOi8vd3d3LndoYXR3Zy5vcmcvc3BlY3Mvd2ViLWFwcHMvY3VycmVudC13b3JrL211bHRpcGFnZS90aGUtaW5wdXQtZWxlbWVudC5odG1sI2lucHV0LXR5cGUtYXR0ci1zdW1tYXJ5XG4gKi9cbnZhciBzdXBwb3J0ZWRJbnB1dFR5cGVzID0ge1xuICBjb2xvcjogdHJ1ZSxcbiAgZGF0ZTogdHJ1ZSxcbiAgZGF0ZXRpbWU6IHRydWUsXG4gICdkYXRldGltZS1sb2NhbCc6IHRydWUsXG4gIGVtYWlsOiB0cnVlLFxuICBtb250aDogdHJ1ZSxcbiAgbnVtYmVyOiB0cnVlLFxuICBwYXNzd29yZDogdHJ1ZSxcbiAgcmFuZ2U6IHRydWUsXG4gIHNlYXJjaDogdHJ1ZSxcbiAgdGVsOiB0cnVlLFxuICB0ZXh0OiB0cnVlLFxuICB0aW1lOiB0cnVlLFxuICB1cmw6IHRydWUsXG4gIHdlZWs6IHRydWVcbn07XG5cbmZ1bmN0aW9uIGlzVGV4dElucHV0RWxlbWVudChlbGVtKSB7XG4gIHZhciBub2RlTmFtZSA9IGVsZW0gJiYgZWxlbS5ub2RlTmFtZSAmJiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG5cbiAgaWYgKG5vZGVOYW1lID09PSAnaW5wdXQnKSB7XG4gICAgcmV0dXJuICEhc3VwcG9ydGVkSW5wdXRUeXBlc1tlbGVtLnR5cGVdO1xuICB9XG5cbiAgaWYgKG5vZGVOYW1lID09PSAndGV4dGFyZWEnKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGFuIGV2ZW50IGlzIHN1cHBvcnRlZCBpbiB0aGUgY3VycmVudCBleGVjdXRpb24gZW52aXJvbm1lbnQuXG4gKlxuICogTk9URTogVGhpcyB3aWxsIG5vdCB3b3JrIGNvcnJlY3RseSBmb3Igbm9uLWdlbmVyaWMgZXZlbnRzIHN1Y2ggYXMgYGNoYW5nZWAsXG4gKiBgcmVzZXRgLCBgbG9hZGAsIGBlcnJvcmAsIGFuZCBgc2VsZWN0YC5cbiAqXG4gKiBCb3Jyb3dzIGZyb20gTW9kZXJuaXpyLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWVTdWZmaXggRXZlbnQgbmFtZSwgZS5nLiBcImNsaWNrXCIuXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBldmVudCBpcyBzdXBwb3J0ZWQuXG4gKiBAaW50ZXJuYWxcbiAqIEBsaWNlbnNlIE1vZGVybml6ciAzLjAuMHByZSAoQ3VzdG9tIEJ1aWxkKSB8IE1JVFxuICovXG5cbmZ1bmN0aW9uIGlzRXZlbnRTdXBwb3J0ZWQoZXZlbnROYW1lU3VmZml4KSB7XG4gIGlmICghY2FuVXNlRE9NKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIGV2ZW50TmFtZSA9ICdvbicgKyBldmVudE5hbWVTdWZmaXg7XG4gIHZhciBpc1N1cHBvcnRlZCA9IChldmVudE5hbWUgaW4gZG9jdW1lbnQpO1xuXG4gIGlmICghaXNTdXBwb3J0ZWQpIHtcbiAgICB2YXIgZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKGV2ZW50TmFtZSwgJ3JldHVybjsnKTtcbiAgICBpc1N1cHBvcnRlZCA9IHR5cGVvZiBlbGVtZW50W2V2ZW50TmFtZV0gPT09ICdmdW5jdGlvbic7XG4gIH1cblxuICByZXR1cm4gaXNTdXBwb3J0ZWQ7XG59XG5cbmZ1bmN0aW9uIHJlZ2lzdGVyRXZlbnRzJDEoKSB7XG4gIHJlZ2lzdGVyVHdvUGhhc2VFdmVudCgnb25DaGFuZ2UnLCBbJ2NoYW5nZScsICdjbGljaycsICdmb2N1c2luJywgJ2ZvY3Vzb3V0JywgJ2lucHV0JywgJ2tleWRvd24nLCAna2V5dXAnLCAnc2VsZWN0aW9uY2hhbmdlJ10pO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVBbmRBY2N1bXVsYXRlQ2hhbmdlRXZlbnQoZGlzcGF0Y2hRdWV1ZSwgaW5zdCwgbmF0aXZlRXZlbnQsIHRhcmdldCkge1xuICAvLyBGbGFnIHRoaXMgZXZlbnQgbG9vcCBhcyBuZWVkaW5nIHN0YXRlIHJlc3RvcmUuXG4gIGVucXVldWVTdGF0ZVJlc3RvcmUodGFyZ2V0KTtcbiAgdmFyIGxpc3RlbmVycyA9IGFjY3VtdWxhdGVUd29QaGFzZUxpc3RlbmVycyhpbnN0LCAnb25DaGFuZ2UnKTtcblxuICBpZiAobGlzdGVuZXJzLmxlbmd0aCA+IDApIHtcbiAgICB2YXIgZXZlbnQgPSBuZXcgU3ludGhldGljRXZlbnQoJ29uQ2hhbmdlJywgJ2NoYW5nZScsIG51bGwsIG5hdGl2ZUV2ZW50LCB0YXJnZXQpO1xuICAgIGRpc3BhdGNoUXVldWUucHVzaCh7XG4gICAgICBldmVudDogZXZlbnQsXG4gICAgICBsaXN0ZW5lcnM6IGxpc3RlbmVyc1xuICAgIH0pO1xuICB9XG59XG4vKipcbiAqIEZvciBJRSBzaGltc1xuICovXG5cblxudmFyIGFjdGl2ZUVsZW1lbnQgPSBudWxsO1xudmFyIGFjdGl2ZUVsZW1lbnRJbnN0ID0gbnVsbDtcbi8qKlxuICogU0VDVElPTjogaGFuZGxlIGBjaGFuZ2VgIGV2ZW50XG4gKi9cblxuZnVuY3Rpb24gc2hvdWxkVXNlQ2hhbmdlRXZlbnQoZWxlbSkge1xuICB2YXIgbm9kZU5hbWUgPSBlbGVtLm5vZGVOYW1lICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcbiAgcmV0dXJuIG5vZGVOYW1lID09PSAnc2VsZWN0JyB8fCBub2RlTmFtZSA9PT0gJ2lucHV0JyAmJiBlbGVtLnR5cGUgPT09ICdmaWxlJztcbn1cblxuZnVuY3Rpb24gbWFudWFsRGlzcGF0Y2hDaGFuZ2VFdmVudChuYXRpdmVFdmVudCkge1xuICB2YXIgZGlzcGF0Y2hRdWV1ZSA9IFtdO1xuICBjcmVhdGVBbmRBY2N1bXVsYXRlQ2hhbmdlRXZlbnQoZGlzcGF0Y2hRdWV1ZSwgYWN0aXZlRWxlbWVudEluc3QsIG5hdGl2ZUV2ZW50LCBnZXRFdmVudFRhcmdldChuYXRpdmVFdmVudCkpOyAvLyBJZiBjaGFuZ2UgYW5kIHByb3BlcnR5Y2hhbmdlIGJ1YmJsZWQsIHdlJ2QganVzdCBiaW5kIHRvIGl0IGxpa2UgYWxsIHRoZVxuICAvLyBvdGhlciBldmVudHMgYW5kIGhhdmUgaXQgZ28gdGhyb3VnaCBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuIFNpbmNlIGl0XG4gIC8vIGRvZXNuJ3QsIHdlIG1hbnVhbGx5IGxpc3RlbiBmb3IgdGhlIGV2ZW50cyBhbmQgc28gd2UgaGF2ZSB0byBlbnF1ZXVlIGFuZFxuICAvLyBwcm9jZXNzIHRoZSBhYnN0cmFjdCBldmVudCBtYW51YWxseS5cbiAgLy9cbiAgLy8gQmF0Y2hpbmcgaXMgbmVjZXNzYXJ5IGhlcmUgaW4gb3JkZXIgdG8gZW5zdXJlIHRoYXQgYWxsIGV2ZW50IGhhbmRsZXJzIHJ1blxuICAvLyBiZWZvcmUgdGhlIG5leHQgcmVyZW5kZXIgKGluY2x1ZGluZyBldmVudCBoYW5kbGVycyBhdHRhY2hlZCB0byBhbmNlc3RvclxuICAvLyBlbGVtZW50cyBpbnN0ZWFkIG9mIGRpcmVjdGx5IG9uIHRoZSBpbnB1dCkuIFdpdGhvdXQgdGhpcywgY29udHJvbGxlZFxuICAvLyBjb21wb25lbnRzIGRvbid0IHdvcmsgcHJvcGVybHkgaW4gY29uanVuY3Rpb24gd2l0aCBldmVudCBidWJibGluZyBiZWNhdXNlXG4gIC8vIHRoZSBjb21wb25lbnQgaXMgcmVyZW5kZXJlZCBhbmQgdGhlIHZhbHVlIHJldmVydGVkIGJlZm9yZSBhbGwgdGhlIGV2ZW50XG4gIC8vIGhhbmRsZXJzIGNhbiBydW4uIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzcwOC5cblxuICBiYXRjaGVkVXBkYXRlcyhydW5FdmVudEluQmF0Y2gsIGRpc3BhdGNoUXVldWUpO1xufVxuXG5mdW5jdGlvbiBydW5FdmVudEluQmF0Y2goZGlzcGF0Y2hRdWV1ZSkge1xuICBwcm9jZXNzRGlzcGF0Y2hRdWV1ZShkaXNwYXRjaFF1ZXVlLCAwKTtcbn1cblxuZnVuY3Rpb24gZ2V0SW5zdElmVmFsdWVDaGFuZ2VkKHRhcmdldEluc3QpIHtcbiAgdmFyIHRhcmdldE5vZGUgPSBnZXROb2RlRnJvbUluc3RhbmNlKHRhcmdldEluc3QpO1xuXG4gIGlmICh1cGRhdGVWYWx1ZUlmQ2hhbmdlZCh0YXJnZXROb2RlKSkge1xuICAgIHJldHVybiB0YXJnZXRJbnN0O1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldFRhcmdldEluc3RGb3JDaGFuZ2VFdmVudChkb21FdmVudE5hbWUsIHRhcmdldEluc3QpIHtcbiAgaWYgKGRvbUV2ZW50TmFtZSA9PT0gJ2NoYW5nZScpIHtcbiAgICByZXR1cm4gdGFyZ2V0SW5zdDtcbiAgfVxufVxuLyoqXG4gKiBTRUNUSU9OOiBoYW5kbGUgYGlucHV0YCBldmVudFxuICovXG5cblxudmFyIGlzSW5wdXRFdmVudFN1cHBvcnRlZCA9IGZhbHNlO1xuXG5pZiAoY2FuVXNlRE9NKSB7XG4gIC8vIElFOSBjbGFpbXMgdG8gc3VwcG9ydCB0aGUgaW5wdXQgZXZlbnQgYnV0IGZhaWxzIHRvIHRyaWdnZXIgaXQgd2hlblxuICAvLyBkZWxldGluZyB0ZXh0LCBzbyB3ZSBpZ25vcmUgaXRzIGlucHV0IGV2ZW50cy5cbiAgaXNJbnB1dEV2ZW50U3VwcG9ydGVkID0gaXNFdmVudFN1cHBvcnRlZCgnaW5wdXQnKSAmJiAoIWRvY3VtZW50LmRvY3VtZW50TW9kZSB8fCBkb2N1bWVudC5kb2N1bWVudE1vZGUgPiA5KTtcbn1cbi8qKlxuICogKEZvciBJRSA8PTkpIFN0YXJ0cyB0cmFja2luZyBwcm9wZXJ0eWNoYW5nZSBldmVudHMgb24gdGhlIHBhc3NlZC1pbiBlbGVtZW50XG4gKiBhbmQgb3ZlcnJpZGUgdGhlIHZhbHVlIHByb3BlcnR5IHNvIHRoYXQgd2UgY2FuIGRpc3Rpbmd1aXNoIHVzZXIgZXZlbnRzIGZyb21cbiAqIHZhbHVlIGNoYW5nZXMgaW4gSlMuXG4gKi9cblxuXG5mdW5jdGlvbiBzdGFydFdhdGNoaW5nRm9yVmFsdWVDaGFuZ2UodGFyZ2V0LCB0YXJnZXRJbnN0KSB7XG4gIGFjdGl2ZUVsZW1lbnQgPSB0YXJnZXQ7XG4gIGFjdGl2ZUVsZW1lbnRJbnN0ID0gdGFyZ2V0SW5zdDtcbiAgYWN0aXZlRWxlbWVudC5hdHRhY2hFdmVudCgnb25wcm9wZXJ0eWNoYW5nZScsIGhhbmRsZVByb3BlcnR5Q2hhbmdlKTtcbn1cbi8qKlxuICogKEZvciBJRSA8PTkpIFJlbW92ZXMgdGhlIGV2ZW50IGxpc3RlbmVycyBmcm9tIHRoZSBjdXJyZW50bHktdHJhY2tlZCBlbGVtZW50LFxuICogaWYgYW55IGV4aXN0cy5cbiAqL1xuXG5cbmZ1bmN0aW9uIHN0b3BXYXRjaGluZ0ZvclZhbHVlQ2hhbmdlKCkge1xuICBpZiAoIWFjdGl2ZUVsZW1lbnQpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBhY3RpdmVFbGVtZW50LmRldGFjaEV2ZW50KCdvbnByb3BlcnR5Y2hhbmdlJywgaGFuZGxlUHJvcGVydHlDaGFuZ2UpO1xuICBhY3RpdmVFbGVtZW50ID0gbnVsbDtcbiAgYWN0aXZlRWxlbWVudEluc3QgPSBudWxsO1xufVxuLyoqXG4gKiAoRm9yIElFIDw9OSkgSGFuZGxlcyBhIHByb3BlcnR5Y2hhbmdlIGV2ZW50LCBzZW5kaW5nIGEgYGNoYW5nZWAgZXZlbnQgaWZcbiAqIHRoZSB2YWx1ZSBvZiB0aGUgYWN0aXZlIGVsZW1lbnQgaGFzIGNoYW5nZWQuXG4gKi9cblxuXG5mdW5jdGlvbiBoYW5kbGVQcm9wZXJ0eUNoYW5nZShuYXRpdmVFdmVudCkge1xuICBpZiAobmF0aXZlRXZlbnQucHJvcGVydHlOYW1lICE9PSAndmFsdWUnKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKGdldEluc3RJZlZhbHVlQ2hhbmdlZChhY3RpdmVFbGVtZW50SW5zdCkpIHtcbiAgICBtYW51YWxEaXNwYXRjaENoYW5nZUV2ZW50KG5hdGl2ZUV2ZW50KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBoYW5kbGVFdmVudHNGb3JJbnB1dEV2ZW50UG9seWZpbGwoZG9tRXZlbnROYW1lLCB0YXJnZXQsIHRhcmdldEluc3QpIHtcbiAgaWYgKGRvbUV2ZW50TmFtZSA9PT0gJ2ZvY3VzaW4nKSB7XG4gICAgLy8gSW4gSUU5LCBwcm9wZXJ0eWNoYW5nZSBmaXJlcyBmb3IgbW9zdCBpbnB1dCBldmVudHMgYnV0IGlzIGJ1Z2d5IGFuZFxuICAgIC8vIGRvZXNuJ3QgZmlyZSB3aGVuIHRleHQgaXMgZGVsZXRlZCwgYnV0IGNvbnZlbmllbnRseSwgc2VsZWN0aW9uY2hhbmdlXG4gICAgLy8gYXBwZWFycyB0byBmaXJlIGluIGFsbCBvZiB0aGUgcmVtYWluaW5nIGNhc2VzIHNvIHdlIGNhdGNoIHRob3NlIGFuZFxuICAgIC8vIGZvcndhcmQgdGhlIGV2ZW50IGlmIHRoZSB2YWx1ZSBoYXMgY2hhbmdlZFxuICAgIC8vIEluIGVpdGhlciBjYXNlLCB3ZSBkb24ndCB3YW50IHRvIGNhbGwgdGhlIGV2ZW50IGhhbmRsZXIgaWYgdGhlIHZhbHVlXG4gICAgLy8gaXMgY2hhbmdlZCBmcm9tIEpTIHNvIHdlIHJlZGVmaW5lIGEgc2V0dGVyIGZvciBgLnZhbHVlYCB0aGF0IHVwZGF0ZXNcbiAgICAvLyBvdXIgYWN0aXZlRWxlbWVudFZhbHVlIHZhcmlhYmxlLCBhbGxvd2luZyB1cyB0byBpZ25vcmUgdGhvc2UgY2hhbmdlc1xuICAgIC8vXG4gICAgLy8gc3RvcFdhdGNoaW5nKCkgc2hvdWxkIGJlIGEgbm9vcCBoZXJlIGJ1dCB3ZSBjYWxsIGl0IGp1c3QgaW4gY2FzZSB3ZVxuICAgIC8vIG1pc3NlZCBhIGJsdXIgZXZlbnQgc29tZWhvdy5cbiAgICBzdG9wV2F0Y2hpbmdGb3JWYWx1ZUNoYW5nZSgpO1xuICAgIHN0YXJ0V2F0Y2hpbmdGb3JWYWx1ZUNoYW5nZSh0YXJnZXQsIHRhcmdldEluc3QpO1xuICB9IGVsc2UgaWYgKGRvbUV2ZW50TmFtZSA9PT0gJ2ZvY3Vzb3V0Jykge1xuICAgIHN0b3BXYXRjaGluZ0ZvclZhbHVlQ2hhbmdlKCk7XG4gIH1cbn0gLy8gRm9yIElFOCBhbmQgSUU5LlxuXG5cbmZ1bmN0aW9uIGdldFRhcmdldEluc3RGb3JJbnB1dEV2ZW50UG9seWZpbGwoZG9tRXZlbnROYW1lLCB0YXJnZXRJbnN0KSB7XG4gIGlmIChkb21FdmVudE5hbWUgPT09ICdzZWxlY3Rpb25jaGFuZ2UnIHx8IGRvbUV2ZW50TmFtZSA9PT0gJ2tleXVwJyB8fCBkb21FdmVudE5hbWUgPT09ICdrZXlkb3duJykge1xuICAgIC8vIE9uIHRoZSBzZWxlY3Rpb25jaGFuZ2UgZXZlbnQsIHRoZSB0YXJnZXQgaXMganVzdCBkb2N1bWVudCB3aGljaCBpc24ndFxuICAgIC8vIGhlbHBmdWwgZm9yIHVzIHNvIGp1c3QgY2hlY2sgYWN0aXZlRWxlbWVudCBpbnN0ZWFkLlxuICAgIC8vXG4gICAgLy8gOTklIG9mIHRoZSB0aW1lLCBrZXlkb3duIGFuZCBrZXl1cCBhcmVuJ3QgbmVjZXNzYXJ5LiBJRTggZmFpbHMgdG8gZmlyZVxuICAgIC8vIHByb3BlcnR5Y2hhbmdlIG9uIHRoZSBmaXJzdCBpbnB1dCBldmVudCBhZnRlciBzZXR0aW5nIGB2YWx1ZWAgZnJvbSBhXG4gICAgLy8gc2NyaXB0IGFuZCBmaXJlcyBvbmx5IGtleWRvd24sIGtleXByZXNzLCBrZXl1cC4gQ2F0Y2hpbmcga2V5dXAgdXN1YWxseVxuICAgIC8vIGdldHMgaXQgYW5kIGNhdGNoaW5nIGtleWRvd24gbGV0cyB1cyBmaXJlIGFuIGV2ZW50IGZvciB0aGUgZmlyc3RcbiAgICAvLyBrZXlzdHJva2UgaWYgdXNlciBkb2VzIGEga2V5IHJlcGVhdCAoaXQnbGwgYmUgYSBsaXR0bGUgZGVsYXllZDogcmlnaHRcbiAgICAvLyBiZWZvcmUgdGhlIHNlY29uZCBrZXlzdHJva2UpLiBPdGhlciBpbnB1dCBtZXRob2RzIChlLmcuLCBwYXN0ZSkgc2VlbSB0b1xuICAgIC8vIGZpcmUgc2VsZWN0aW9uY2hhbmdlIG5vcm1hbGx5LlxuICAgIHJldHVybiBnZXRJbnN0SWZWYWx1ZUNoYW5nZWQoYWN0aXZlRWxlbWVudEluc3QpO1xuICB9XG59XG4vKipcbiAqIFNFQ1RJT046IGhhbmRsZSBgY2xpY2tgIGV2ZW50XG4gKi9cblxuXG5mdW5jdGlvbiBzaG91bGRVc2VDbGlja0V2ZW50KGVsZW0pIHtcbiAgLy8gVXNlIHRoZSBgY2xpY2tgIGV2ZW50IHRvIGRldGVjdCBjaGFuZ2VzIHRvIGNoZWNrYm94IGFuZCByYWRpbyBpbnB1dHMuXG4gIC8vIFRoaXMgYXBwcm9hY2ggd29ya3MgYWNyb3NzIGFsbCBicm93c2Vycywgd2hlcmVhcyBgY2hhbmdlYCBkb2VzIG5vdCBmaXJlXG4gIC8vIHVudGlsIGBibHVyYCBpbiBJRTguXG4gIHZhciBub2RlTmFtZSA9IGVsZW0ubm9kZU5hbWU7XG4gIHJldHVybiBub2RlTmFtZSAmJiBub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnaW5wdXQnICYmIChlbGVtLnR5cGUgPT09ICdjaGVja2JveCcgfHwgZWxlbS50eXBlID09PSAncmFkaW8nKTtcbn1cblxuZnVuY3Rpb24gZ2V0VGFyZ2V0SW5zdEZvckNsaWNrRXZlbnQoZG9tRXZlbnROYW1lLCB0YXJnZXRJbnN0KSB7XG4gIGlmIChkb21FdmVudE5hbWUgPT09ICdjbGljaycpIHtcbiAgICByZXR1cm4gZ2V0SW5zdElmVmFsdWVDaGFuZ2VkKHRhcmdldEluc3QpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldFRhcmdldEluc3RGb3JJbnB1dE9yQ2hhbmdlRXZlbnQoZG9tRXZlbnROYW1lLCB0YXJnZXRJbnN0KSB7XG4gIGlmIChkb21FdmVudE5hbWUgPT09ICdpbnB1dCcgfHwgZG9tRXZlbnROYW1lID09PSAnY2hhbmdlJykge1xuICAgIHJldHVybiBnZXRJbnN0SWZWYWx1ZUNoYW5nZWQodGFyZ2V0SW5zdCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaGFuZGxlQ29udHJvbGxlZElucHV0Qmx1cihub2RlKSB7XG4gIHZhciBzdGF0ZSA9IG5vZGUuX3dyYXBwZXJTdGF0ZTtcblxuICBpZiAoIXN0YXRlIHx8ICFzdGF0ZS5jb250cm9sbGVkIHx8IG5vZGUudHlwZSAhPT0gJ251bWJlcicpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB7XG4gICAgLy8gSWYgY29udHJvbGxlZCwgYXNzaWduIHRoZSB2YWx1ZSBhdHRyaWJ1dGUgdG8gdGhlIGN1cnJlbnQgdmFsdWUgb24gYmx1clxuICAgIHNldERlZmF1bHRWYWx1ZShub2RlLCAnbnVtYmVyJywgbm9kZS52YWx1ZSk7XG4gIH1cbn1cbi8qKlxuICogVGhpcyBwbHVnaW4gY3JlYXRlcyBhbiBgb25DaGFuZ2VgIGV2ZW50IHRoYXQgbm9ybWFsaXplcyBjaGFuZ2UgZXZlbnRzXG4gKiBhY3Jvc3MgZm9ybSBlbGVtZW50cy4gVGhpcyBldmVudCBmaXJlcyBhdCBhIHRpbWUgd2hlbiBpdCdzIHBvc3NpYmxlIHRvXG4gKiBjaGFuZ2UgdGhlIGVsZW1lbnQncyB2YWx1ZSB3aXRob3V0IHNlZWluZyBhIGZsaWNrZXIuXG4gKlxuICogU3VwcG9ydGVkIGVsZW1lbnRzIGFyZTpcbiAqIC0gaW5wdXQgKHNlZSBgaXNUZXh0SW5wdXRFbGVtZW50YClcbiAqIC0gdGV4dGFyZWFcbiAqIC0gc2VsZWN0XG4gKi9cblxuXG5mdW5jdGlvbiBleHRyYWN0RXZlbnRzJDEoZGlzcGF0Y2hRdWV1ZSwgZG9tRXZlbnROYW1lLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQsIGV2ZW50U3lzdGVtRmxhZ3MsIHRhcmdldENvbnRhaW5lcikge1xuICB2YXIgdGFyZ2V0Tm9kZSA9IHRhcmdldEluc3QgPyBnZXROb2RlRnJvbUluc3RhbmNlKHRhcmdldEluc3QpIDogd2luZG93O1xuICB2YXIgZ2V0VGFyZ2V0SW5zdEZ1bmMsIGhhbmRsZUV2ZW50RnVuYztcblxuICBpZiAoc2hvdWxkVXNlQ2hhbmdlRXZlbnQodGFyZ2V0Tm9kZSkpIHtcbiAgICBnZXRUYXJnZXRJbnN0RnVuYyA9IGdldFRhcmdldEluc3RGb3JDaGFuZ2VFdmVudDtcbiAgfSBlbHNlIGlmIChpc1RleHRJbnB1dEVsZW1lbnQodGFyZ2V0Tm9kZSkpIHtcbiAgICBpZiAoaXNJbnB1dEV2ZW50U3VwcG9ydGVkKSB7XG4gICAgICBnZXRUYXJnZXRJbnN0RnVuYyA9IGdldFRhcmdldEluc3RGb3JJbnB1dE9yQ2hhbmdlRXZlbnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGdldFRhcmdldEluc3RGdW5jID0gZ2V0VGFyZ2V0SW5zdEZvcklucHV0RXZlbnRQb2x5ZmlsbDtcbiAgICAgIGhhbmRsZUV2ZW50RnVuYyA9IGhhbmRsZUV2ZW50c0ZvcklucHV0RXZlbnRQb2x5ZmlsbDtcbiAgICB9XG4gIH0gZWxzZSBpZiAoc2hvdWxkVXNlQ2xpY2tFdmVudCh0YXJnZXROb2RlKSkge1xuICAgIGdldFRhcmdldEluc3RGdW5jID0gZ2V0VGFyZ2V0SW5zdEZvckNsaWNrRXZlbnQ7XG4gIH1cblxuICBpZiAoZ2V0VGFyZ2V0SW5zdEZ1bmMpIHtcbiAgICB2YXIgaW5zdCA9IGdldFRhcmdldEluc3RGdW5jKGRvbUV2ZW50TmFtZSwgdGFyZ2V0SW5zdCk7XG5cbiAgICBpZiAoaW5zdCkge1xuICAgICAgY3JlYXRlQW5kQWNjdW11bGF0ZUNoYW5nZUV2ZW50KGRpc3BhdGNoUXVldWUsIGluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG5cbiAgaWYgKGhhbmRsZUV2ZW50RnVuYykge1xuICAgIGhhbmRsZUV2ZW50RnVuYyhkb21FdmVudE5hbWUsIHRhcmdldE5vZGUsIHRhcmdldEluc3QpO1xuICB9IC8vIFdoZW4gYmx1cnJpbmcsIHNldCB0aGUgdmFsdWUgYXR0cmlidXRlIGZvciBudW1iZXIgaW5wdXRzXG5cblxuICBpZiAoZG9tRXZlbnROYW1lID09PSAnZm9jdXNvdXQnKSB7XG4gICAgaGFuZGxlQ29udHJvbGxlZElucHV0Qmx1cih0YXJnZXROb2RlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZWdpc3RlckV2ZW50cyQyKCkge1xuICByZWdpc3RlckRpcmVjdEV2ZW50KCdvbk1vdXNlRW50ZXInLCBbJ21vdXNlb3V0JywgJ21vdXNlb3ZlciddKTtcbiAgcmVnaXN0ZXJEaXJlY3RFdmVudCgnb25Nb3VzZUxlYXZlJywgWydtb3VzZW91dCcsICdtb3VzZW92ZXInXSk7XG4gIHJlZ2lzdGVyRGlyZWN0RXZlbnQoJ29uUG9pbnRlckVudGVyJywgWydwb2ludGVyb3V0JywgJ3BvaW50ZXJvdmVyJ10pO1xuICByZWdpc3RlckRpcmVjdEV2ZW50KCdvblBvaW50ZXJMZWF2ZScsIFsncG9pbnRlcm91dCcsICdwb2ludGVyb3ZlciddKTtcbn1cbi8qKlxuICogRm9yIGFsbW9zdCBldmVyeSBpbnRlcmFjdGlvbiB3ZSBjYXJlIGFib3V0LCB0aGVyZSB3aWxsIGJlIGJvdGggYSB0b3AtbGV2ZWxcbiAqIGBtb3VzZW92ZXJgIGFuZCBgbW91c2VvdXRgIGV2ZW50IHRoYXQgb2NjdXJzLiBPbmx5IHVzZSBgbW91c2VvdXRgIHNvIHRoYXRcbiAqIHdlIGRvIG5vdCBleHRyYWN0IGR1cGxpY2F0ZSBldmVudHMuIEhvd2V2ZXIsIG1vdmluZyB0aGUgbW91c2UgaW50byB0aGVcbiAqIGJyb3dzZXIgZnJvbSBvdXRzaWRlIHdpbGwgbm90IGZpcmUgYSBgbW91c2VvdXRgIGV2ZW50LiBJbiB0aGlzIGNhc2UsIHdlIHVzZVxuICogdGhlIGBtb3VzZW92ZXJgIHRvcC1sZXZlbCBldmVudC5cbiAqL1xuXG5cbmZ1bmN0aW9uIGV4dHJhY3RFdmVudHMkMihkaXNwYXRjaFF1ZXVlLCBkb21FdmVudE5hbWUsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCwgZXZlbnRTeXN0ZW1GbGFncywgdGFyZ2V0Q29udGFpbmVyKSB7XG4gIHZhciBpc092ZXJFdmVudCA9IGRvbUV2ZW50TmFtZSA9PT0gJ21vdXNlb3ZlcicgfHwgZG9tRXZlbnROYW1lID09PSAncG9pbnRlcm92ZXInO1xuICB2YXIgaXNPdXRFdmVudCA9IGRvbUV2ZW50TmFtZSA9PT0gJ21vdXNlb3V0JyB8fCBkb21FdmVudE5hbWUgPT09ICdwb2ludGVyb3V0JztcblxuICBpZiAoaXNPdmVyRXZlbnQgJiYgKGV2ZW50U3lzdGVtRmxhZ3MgJiBJU19SRVBMQVlFRCkgPT09IDApIHtcbiAgICAvLyBJZiB0aGlzIGlzIGFuIG92ZXIgZXZlbnQgd2l0aCBhIHRhcmdldCwgd2UgbWlnaHQgaGF2ZSBhbHJlYWR5IGRpc3BhdGNoZWRcbiAgICAvLyB0aGUgZXZlbnQgaW4gdGhlIG91dCBldmVudCBvZiB0aGUgb3RoZXIgdGFyZ2V0LiBJZiB0aGlzIGlzIHJlcGxheWVkLFxuICAgIC8vIHRoZW4gaXQncyBiZWNhdXNlIHdlIGNvdWxkbid0IGRpc3BhdGNoIGFnYWluc3QgdGhpcyB0YXJnZXQgcHJldmlvdXNseVxuICAgIC8vIHNvIHdlIGhhdmUgdG8gZG8gaXQgbm93IGluc3RlYWQuXG4gICAgdmFyIHJlbGF0ZWQgPSBuYXRpdmVFdmVudC5yZWxhdGVkVGFyZ2V0IHx8IG5hdGl2ZUV2ZW50LmZyb21FbGVtZW50O1xuXG4gICAgaWYgKHJlbGF0ZWQpIHtcbiAgICAgIC8vIElmIHRoZSByZWxhdGVkIG5vZGUgaXMgbWFuYWdlZCBieSBSZWFjdCwgd2UgY2FuIGFzc3VtZSB0aGF0IHdlIGhhdmVcbiAgICAgIC8vIGFscmVhZHkgZGlzcGF0Y2hlZCB0aGUgY29ycmVzcG9uZGluZyBldmVudHMgZHVyaW5nIGl0cyBtb3VzZW91dC5cbiAgICAgIGlmIChnZXRDbG9zZXN0SW5zdGFuY2VGcm9tTm9kZShyZWxhdGVkKSB8fCBpc0NvbnRhaW5lck1hcmtlZEFzUm9vdChyZWxhdGVkKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKCFpc091dEV2ZW50ICYmICFpc092ZXJFdmVudCkge1xuICAgIC8vIE11c3Qgbm90IGJlIGEgbW91c2Ugb3IgcG9pbnRlciBpbiBvciBvdXQgLSBpZ25vcmluZy5cbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgd2luOyAvLyBUT0RPOiB3aHkgaXMgdGhpcyBudWxsYWJsZSBpbiB0aGUgdHlwZXMgYnV0IHdlIHJlYWQgZnJvbSBpdD9cblxuICBpZiAobmF0aXZlRXZlbnRUYXJnZXQud2luZG93ID09PSBuYXRpdmVFdmVudFRhcmdldCkge1xuICAgIC8vIGBuYXRpdmVFdmVudFRhcmdldGAgaXMgcHJvYmFibHkgYSB3aW5kb3cgb2JqZWN0LlxuICAgIHdpbiA9IG5hdGl2ZUV2ZW50VGFyZ2V0O1xuICB9IGVsc2Uge1xuICAgIC8vIFRPRE86IEZpZ3VyZSBvdXQgd2h5IGBvd25lckRvY3VtZW50YCBpcyBzb21ldGltZXMgdW5kZWZpbmVkIGluIElFOC5cbiAgICB2YXIgZG9jID0gbmF0aXZlRXZlbnRUYXJnZXQub3duZXJEb2N1bWVudDtcblxuICAgIGlmIChkb2MpIHtcbiAgICAgIHdpbiA9IGRvYy5kZWZhdWx0VmlldyB8fCBkb2MucGFyZW50V2luZG93O1xuICAgIH0gZWxzZSB7XG4gICAgICB3aW4gPSB3aW5kb3c7XG4gICAgfVxuICB9XG5cbiAgdmFyIGZyb207XG4gIHZhciB0bztcblxuICBpZiAoaXNPdXRFdmVudCkge1xuICAgIHZhciBfcmVsYXRlZCA9IG5hdGl2ZUV2ZW50LnJlbGF0ZWRUYXJnZXQgfHwgbmF0aXZlRXZlbnQudG9FbGVtZW50O1xuXG4gICAgZnJvbSA9IHRhcmdldEluc3Q7XG4gICAgdG8gPSBfcmVsYXRlZCA/IGdldENsb3Nlc3RJbnN0YW5jZUZyb21Ob2RlKF9yZWxhdGVkKSA6IG51bGw7XG5cbiAgICBpZiAodG8gIT09IG51bGwpIHtcbiAgICAgIHZhciBuZWFyZXN0TW91bnRlZCA9IGdldE5lYXJlc3RNb3VudGVkRmliZXIodG8pO1xuXG4gICAgICBpZiAodG8gIT09IG5lYXJlc3RNb3VudGVkIHx8IHRvLnRhZyAhPT0gSG9zdENvbXBvbmVudCAmJiB0by50YWcgIT09IEhvc3RUZXh0KSB7XG4gICAgICAgIHRvID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gTW92aW5nIHRvIGEgbm9kZSBmcm9tIG91dHNpZGUgdGhlIHdpbmRvdy5cbiAgICBmcm9tID0gbnVsbDtcbiAgICB0byA9IHRhcmdldEluc3Q7XG4gIH1cblxuICBpZiAoZnJvbSA9PT0gdG8pIHtcbiAgICAvLyBOb3RoaW5nIHBlcnRhaW5zIHRvIG91ciBtYW5hZ2VkIGNvbXBvbmVudHMuXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIFN5bnRoZXRpY0V2ZW50Q3RvciA9IFN5bnRoZXRpY01vdXNlRXZlbnQ7XG4gIHZhciBsZWF2ZUV2ZW50VHlwZSA9ICdvbk1vdXNlTGVhdmUnO1xuICB2YXIgZW50ZXJFdmVudFR5cGUgPSAnb25Nb3VzZUVudGVyJztcbiAgdmFyIGV2ZW50VHlwZVByZWZpeCA9ICdtb3VzZSc7XG5cbiAgaWYgKGRvbUV2ZW50TmFtZSA9PT0gJ3BvaW50ZXJvdXQnIHx8IGRvbUV2ZW50TmFtZSA9PT0gJ3BvaW50ZXJvdmVyJykge1xuICAgIFN5bnRoZXRpY0V2ZW50Q3RvciA9IFN5bnRoZXRpY1BvaW50ZXJFdmVudDtcbiAgICBsZWF2ZUV2ZW50VHlwZSA9ICdvblBvaW50ZXJMZWF2ZSc7XG4gICAgZW50ZXJFdmVudFR5cGUgPSAnb25Qb2ludGVyRW50ZXInO1xuICAgIGV2ZW50VHlwZVByZWZpeCA9ICdwb2ludGVyJztcbiAgfVxuXG4gIHZhciBmcm9tTm9kZSA9IGZyb20gPT0gbnVsbCA/IHdpbiA6IGdldE5vZGVGcm9tSW5zdGFuY2UoZnJvbSk7XG4gIHZhciB0b05vZGUgPSB0byA9PSBudWxsID8gd2luIDogZ2V0Tm9kZUZyb21JbnN0YW5jZSh0byk7XG4gIHZhciBsZWF2ZSA9IG5ldyBTeW50aGV0aWNFdmVudEN0b3IobGVhdmVFdmVudFR5cGUsIGV2ZW50VHlwZVByZWZpeCArICdsZWF2ZScsIGZyb20sIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG4gIGxlYXZlLnRhcmdldCA9IGZyb21Ob2RlO1xuICBsZWF2ZS5yZWxhdGVkVGFyZ2V0ID0gdG9Ob2RlO1xuICB2YXIgZW50ZXIgPSBudWxsOyAvLyBXZSBzaG91bGQgb25seSBwcm9jZXNzIHRoaXMgbmF0aXZlRXZlbnQgaWYgd2UgYXJlIHByb2Nlc3NpbmdcbiAgLy8gdGhlIGZpcnN0IGFuY2VzdG9yLiBOZXh0IHRpbWUsIHdlIHdpbGwgaWdub3JlIHRoZSBldmVudC5cblxuICB2YXIgbmF0aXZlVGFyZ2V0SW5zdCA9IGdldENsb3Nlc3RJbnN0YW5jZUZyb21Ob2RlKG5hdGl2ZUV2ZW50VGFyZ2V0KTtcblxuICBpZiAobmF0aXZlVGFyZ2V0SW5zdCA9PT0gdGFyZ2V0SW5zdCkge1xuICAgIHZhciBlbnRlckV2ZW50ID0gbmV3IFN5bnRoZXRpY0V2ZW50Q3RvcihlbnRlckV2ZW50VHlwZSwgZXZlbnRUeXBlUHJlZml4ICsgJ2VudGVyJywgdG8sIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG4gICAgZW50ZXJFdmVudC50YXJnZXQgPSB0b05vZGU7XG4gICAgZW50ZXJFdmVudC5yZWxhdGVkVGFyZ2V0ID0gZnJvbU5vZGU7XG4gICAgZW50ZXIgPSBlbnRlckV2ZW50O1xuICB9XG5cbiAgYWNjdW11bGF0ZUVudGVyTGVhdmVUd29QaGFzZUxpc3RlbmVycyhkaXNwYXRjaFF1ZXVlLCBsZWF2ZSwgZW50ZXIsIGZyb20sIHRvKTtcbn1cblxuLyoqXG4gKiBpbmxpbmVkIE9iamVjdC5pcyBwb2x5ZmlsbCB0byBhdm9pZCByZXF1aXJpbmcgY29uc3VtZXJzIHNoaXAgdGhlaXIgb3duXG4gKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9PYmplY3QvaXNcbiAqL1xuZnVuY3Rpb24gaXMoeCwgeSkge1xuICByZXR1cm4geCA9PT0geSAmJiAoeCAhPT0gMCB8fCAxIC8geCA9PT0gMSAvIHkpIHx8IHggIT09IHggJiYgeSAhPT0geSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXNlbGYtY29tcGFyZVxuICA7XG59XG5cbnZhciBvYmplY3RJcyA9IHR5cGVvZiBPYmplY3QuaXMgPT09ICdmdW5jdGlvbicgPyBPYmplY3QuaXMgOiBpcztcblxudmFyIGhhc093blByb3BlcnR5JDIgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuLyoqXG4gKiBQZXJmb3JtcyBlcXVhbGl0eSBieSBpdGVyYXRpbmcgdGhyb3VnaCBrZXlzIG9uIGFuIG9iamVjdCBhbmQgcmV0dXJuaW5nIGZhbHNlXG4gKiB3aGVuIGFueSBrZXkgaGFzIHZhbHVlcyB3aGljaCBhcmUgbm90IHN0cmljdGx5IGVxdWFsIGJldHdlZW4gdGhlIGFyZ3VtZW50cy5cbiAqIFJldHVybnMgdHJ1ZSB3aGVuIHRoZSB2YWx1ZXMgb2YgYWxsIGtleXMgYXJlIHN0cmljdGx5IGVxdWFsLlxuICovXG5cbmZ1bmN0aW9uIHNoYWxsb3dFcXVhbChvYmpBLCBvYmpCKSB7XG4gIGlmIChvYmplY3RJcyhvYmpBLCBvYmpCKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBvYmpBICE9PSAnb2JqZWN0JyB8fCBvYmpBID09PSBudWxsIHx8IHR5cGVvZiBvYmpCICE9PSAnb2JqZWN0JyB8fCBvYmpCID09PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIGtleXNBID0gT2JqZWN0LmtleXMob2JqQSk7XG4gIHZhciBrZXlzQiA9IE9iamVjdC5rZXlzKG9iakIpO1xuXG4gIGlmIChrZXlzQS5sZW5ndGggIT09IGtleXNCLmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSAvLyBUZXN0IGZvciBBJ3Mga2V5cyBkaWZmZXJlbnQgZnJvbSBCLlxuXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzQS5sZW5ndGg7IGkrKykge1xuICAgIGlmICghaGFzT3duUHJvcGVydHkkMi5jYWxsKG9iakIsIGtleXNBW2ldKSB8fCAhb2JqZWN0SXMob2JqQVtrZXlzQVtpXV0sIG9iakJba2V5c0FbaV1dKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG4vKipcbiAqIEdpdmVuIGFueSBub2RlIHJldHVybiB0aGUgZmlyc3QgbGVhZiBub2RlIHdpdGhvdXQgY2hpbGRyZW4uXG4gKlxuICogQHBhcmFtIHtET01FbGVtZW50fERPTVRleHROb2RlfSBub2RlXG4gKiBAcmV0dXJuIHtET01FbGVtZW50fERPTVRleHROb2RlfVxuICovXG5cbmZ1bmN0aW9uIGdldExlYWZOb2RlKG5vZGUpIHtcbiAgd2hpbGUgKG5vZGUgJiYgbm9kZS5maXJzdENoaWxkKSB7XG4gICAgbm9kZSA9IG5vZGUuZmlyc3RDaGlsZDtcbiAgfVxuXG4gIHJldHVybiBub2RlO1xufVxuLyoqXG4gKiBHZXQgdGhlIG5leHQgc2libGluZyB3aXRoaW4gYSBjb250YWluZXIuIFRoaXMgd2lsbCB3YWxrIHVwIHRoZVxuICogRE9NIGlmIGEgbm9kZSdzIHNpYmxpbmdzIGhhdmUgYmVlbiBleGhhdXN0ZWQuXG4gKlxuICogQHBhcmFtIHtET01FbGVtZW50fERPTVRleHROb2RlfSBub2RlXG4gKiBAcmV0dXJuIHs/RE9NRWxlbWVudHxET01UZXh0Tm9kZX1cbiAqL1xuXG5cbmZ1bmN0aW9uIGdldFNpYmxpbmdOb2RlKG5vZGUpIHtcbiAgd2hpbGUgKG5vZGUpIHtcbiAgICBpZiAobm9kZS5uZXh0U2libGluZykge1xuICAgICAgcmV0dXJuIG5vZGUubmV4dFNpYmxpbmc7XG4gICAgfVxuXG4gICAgbm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgfVxufVxuLyoqXG4gKiBHZXQgb2JqZWN0IGRlc2NyaWJpbmcgdGhlIG5vZGVzIHdoaWNoIGNvbnRhaW4gY2hhcmFjdGVycyBhdCBvZmZzZXQuXG4gKlxuICogQHBhcmFtIHtET01FbGVtZW50fERPTVRleHROb2RlfSByb290XG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0XG4gKiBAcmV0dXJuIHs/b2JqZWN0fVxuICovXG5cblxuZnVuY3Rpb24gZ2V0Tm9kZUZvckNoYXJhY3Rlck9mZnNldChyb290LCBvZmZzZXQpIHtcbiAgdmFyIG5vZGUgPSBnZXRMZWFmTm9kZShyb290KTtcbiAgdmFyIG5vZGVTdGFydCA9IDA7XG4gIHZhciBub2RlRW5kID0gMDtcblxuICB3aGlsZSAobm9kZSkge1xuICAgIGlmIChub2RlLm5vZGVUeXBlID09PSBURVhUX05PREUpIHtcbiAgICAgIG5vZGVFbmQgPSBub2RlU3RhcnQgKyBub2RlLnRleHRDb250ZW50Lmxlbmd0aDtcblxuICAgICAgaWYgKG5vZGVTdGFydCA8PSBvZmZzZXQgJiYgbm9kZUVuZCA+PSBvZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBub2RlOiBub2RlLFxuICAgICAgICAgIG9mZnNldDogb2Zmc2V0IC0gbm9kZVN0YXJ0XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIG5vZGVTdGFydCA9IG5vZGVFbmQ7XG4gICAgfVxuXG4gICAgbm9kZSA9IGdldExlYWZOb2RlKGdldFNpYmxpbmdOb2RlKG5vZGUpKTtcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7RE9NRWxlbWVudH0gb3V0ZXJOb2RlXG4gKiBAcmV0dXJuIHs/b2JqZWN0fVxuICovXG5cbmZ1bmN0aW9uIGdldE9mZnNldHMob3V0ZXJOb2RlKSB7XG4gIHZhciBvd25lckRvY3VtZW50ID0gb3V0ZXJOb2RlLm93bmVyRG9jdW1lbnQ7XG4gIHZhciB3aW4gPSBvd25lckRvY3VtZW50ICYmIG93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXcgfHwgd2luZG93O1xuICB2YXIgc2VsZWN0aW9uID0gd2luLmdldFNlbGVjdGlvbiAmJiB3aW4uZ2V0U2VsZWN0aW9uKCk7XG5cbiAgaWYgKCFzZWxlY3Rpb24gfHwgc2VsZWN0aW9uLnJhbmdlQ291bnQgPT09IDApIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBhbmNob3JOb2RlID0gc2VsZWN0aW9uLmFuY2hvck5vZGUsXG4gICAgICBhbmNob3JPZmZzZXQgPSBzZWxlY3Rpb24uYW5jaG9yT2Zmc2V0LFxuICAgICAgZm9jdXNOb2RlID0gc2VsZWN0aW9uLmZvY3VzTm9kZSxcbiAgICAgIGZvY3VzT2Zmc2V0ID0gc2VsZWN0aW9uLmZvY3VzT2Zmc2V0OyAvLyBJbiBGaXJlZm94LCBhbmNob3JOb2RlIGFuZCBmb2N1c05vZGUgY2FuIGJlIFwiYW5vbnltb3VzIGRpdnNcIiwgZS5nLiB0aGVcbiAgLy8gdXAvZG93biBidXR0b25zIG9uIGFuIDxpbnB1dCB0eXBlPVwibnVtYmVyXCI+LiBBbm9ueW1vdXMgZGl2cyBkbyBub3Qgc2VlbSB0b1xuICAvLyBleHBvc2UgcHJvcGVydGllcywgdHJpZ2dlcmluZyBhIFwiUGVybWlzc2lvbiBkZW5pZWQgZXJyb3JcIiBpZiBhbnkgb2YgaXRzXG4gIC8vIHByb3BlcnRpZXMgYXJlIGFjY2Vzc2VkLiBUaGUgb25seSBzZWVtaW5nbHkgcG9zc2libGUgd2F5IHRvIGF2b2lkIGVycm9yaW5nXG4gIC8vIGlzIHRvIGFjY2VzcyBhIHByb3BlcnR5IHRoYXQgdHlwaWNhbGx5IHdvcmtzIGZvciBub24tYW5vbnltb3VzIGRpdnMgYW5kXG4gIC8vIGNhdGNoIGFueSBlcnJvciB0aGF0IG1heSBvdGhlcndpc2UgYXJpc2UuIFNlZVxuICAvLyBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD0yMDg0MjdcblxuICB0cnkge1xuICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC1leHByZXNzaW9ucyAqL1xuICAgIGFuY2hvck5vZGUubm9kZVR5cGU7XG4gICAgZm9jdXNOb2RlLm5vZGVUeXBlO1xuICAgIC8qIGVzbGludC1lbmFibGUgbm8tdW51c2VkLWV4cHJlc3Npb25zICovXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHJldHVybiBnZXRNb2Rlcm5PZmZzZXRzRnJvbVBvaW50cyhvdXRlck5vZGUsIGFuY2hvck5vZGUsIGFuY2hvck9mZnNldCwgZm9jdXNOb2RlLCBmb2N1c09mZnNldCk7XG59XG4vKipcbiAqIFJldHVybnMge3N0YXJ0LCBlbmR9IHdoZXJlIGBzdGFydGAgaXMgdGhlIGNoYXJhY3Rlci9jb2RlcG9pbnQgaW5kZXggb2ZcbiAqIChhbmNob3JOb2RlLCBhbmNob3JPZmZzZXQpIHdpdGhpbiB0aGUgdGV4dENvbnRlbnQgb2YgYG91dGVyTm9kZWAsIGFuZFxuICogYGVuZGAgaXMgdGhlIGluZGV4IG9mIChmb2N1c05vZGUsIGZvY3VzT2Zmc2V0KS5cbiAqXG4gKiBSZXR1cm5zIG51bGwgaWYgeW91IHBhc3MgaW4gZ2FyYmFnZSBpbnB1dCBidXQgd2Ugc2hvdWxkIHByb2JhYmx5IGp1c3QgY3Jhc2guXG4gKlxuICogRXhwb3J0ZWQgb25seSBmb3IgdGVzdGluZy5cbiAqL1xuXG5mdW5jdGlvbiBnZXRNb2Rlcm5PZmZzZXRzRnJvbVBvaW50cyhvdXRlck5vZGUsIGFuY2hvck5vZGUsIGFuY2hvck9mZnNldCwgZm9jdXNOb2RlLCBmb2N1c09mZnNldCkge1xuICB2YXIgbGVuZ3RoID0gMDtcbiAgdmFyIHN0YXJ0ID0gLTE7XG4gIHZhciBlbmQgPSAtMTtcbiAgdmFyIGluZGV4V2l0aGluQW5jaG9yID0gMDtcbiAgdmFyIGluZGV4V2l0aGluRm9jdXMgPSAwO1xuICB2YXIgbm9kZSA9IG91dGVyTm9kZTtcbiAgdmFyIHBhcmVudE5vZGUgPSBudWxsO1xuXG4gIG91dGVyOiB3aGlsZSAodHJ1ZSkge1xuICAgIHZhciBuZXh0ID0gbnVsbDtcblxuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICBpZiAobm9kZSA9PT0gYW5jaG9yTm9kZSAmJiAoYW5jaG9yT2Zmc2V0ID09PSAwIHx8IG5vZGUubm9kZVR5cGUgPT09IFRFWFRfTk9ERSkpIHtcbiAgICAgICAgc3RhcnQgPSBsZW5ndGggKyBhbmNob3JPZmZzZXQ7XG4gICAgICB9XG5cbiAgICAgIGlmIChub2RlID09PSBmb2N1c05vZGUgJiYgKGZvY3VzT2Zmc2V0ID09PSAwIHx8IG5vZGUubm9kZVR5cGUgPT09IFRFWFRfTk9ERSkpIHtcbiAgICAgICAgZW5kID0gbGVuZ3RoICsgZm9jdXNPZmZzZXQ7XG4gICAgICB9XG5cbiAgICAgIGlmIChub2RlLm5vZGVUeXBlID09PSBURVhUX05PREUpIHtcbiAgICAgICAgbGVuZ3RoICs9IG5vZGUubm9kZVZhbHVlLmxlbmd0aDtcbiAgICAgIH1cblxuICAgICAgaWYgKChuZXh0ID0gbm9kZS5maXJzdENoaWxkKSA9PT0gbnVsbCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH0gLy8gTW92aW5nIGZyb20gYG5vZGVgIHRvIGl0cyBmaXJzdCBjaGlsZCBgbmV4dGAuXG5cblxuICAgICAgcGFyZW50Tm9kZSA9IG5vZGU7XG4gICAgICBub2RlID0gbmV4dDtcbiAgICB9XG5cbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgaWYgKG5vZGUgPT09IG91dGVyTm9kZSkge1xuICAgICAgICAvLyBJZiBgb3V0ZXJOb2RlYCBoYXMgY2hpbGRyZW4sIHRoaXMgaXMgYWx3YXlzIHRoZSBzZWNvbmQgdGltZSB2aXNpdGluZ1xuICAgICAgICAvLyBpdC4gSWYgaXQgaGFzIG5vIGNoaWxkcmVuLCB0aGlzIGlzIHN0aWxsIHRoZSBmaXJzdCBsb29wLCBhbmQgdGhlIG9ubHlcbiAgICAgICAgLy8gdmFsaWQgc2VsZWN0aW9uIGlzIGFuY2hvck5vZGUgYW5kIGZvY3VzTm9kZSBib3RoIGVxdWFsIHRvIHRoaXMgbm9kZVxuICAgICAgICAvLyBhbmQgYm90aCBvZmZzZXRzIDAsIGluIHdoaWNoIGNhc2Ugd2Ugd2lsbCBoYXZlIGhhbmRsZWQgYWJvdmUuXG4gICAgICAgIGJyZWFrIG91dGVyO1xuICAgICAgfVxuXG4gICAgICBpZiAocGFyZW50Tm9kZSA9PT0gYW5jaG9yTm9kZSAmJiArK2luZGV4V2l0aGluQW5jaG9yID09PSBhbmNob3JPZmZzZXQpIHtcbiAgICAgICAgc3RhcnQgPSBsZW5ndGg7XG4gICAgICB9XG5cbiAgICAgIGlmIChwYXJlbnROb2RlID09PSBmb2N1c05vZGUgJiYgKytpbmRleFdpdGhpbkZvY3VzID09PSBmb2N1c09mZnNldCkge1xuICAgICAgICBlbmQgPSBsZW5ndGg7XG4gICAgICB9XG5cbiAgICAgIGlmICgobmV4dCA9IG5vZGUubmV4dFNpYmxpbmcpICE9PSBudWxsKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBub2RlID0gcGFyZW50Tm9kZTtcbiAgICAgIHBhcmVudE5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gICAgfSAvLyBNb3ZpbmcgZnJvbSBgbm9kZWAgdG8gaXRzIG5leHQgc2libGluZyBgbmV4dGAuXG5cblxuICAgIG5vZGUgPSBuZXh0O1xuICB9XG5cbiAgaWYgKHN0YXJ0ID09PSAtMSB8fCBlbmQgPT09IC0xKSB7XG4gICAgLy8gVGhpcyBzaG91bGQgbmV2ZXIgaGFwcGVuLiAoV291bGQgaGFwcGVuIGlmIHRoZSBhbmNob3IvZm9jdXMgbm9kZXMgYXJlbid0XG4gICAgLy8gYWN0dWFsbHkgaW5zaWRlIHRoZSBwYXNzZWQtaW4gbm9kZS4pXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHN0YXJ0OiBzdGFydCxcbiAgICBlbmQ6IGVuZFxuICB9O1xufVxuLyoqXG4gKiBJbiBtb2Rlcm4gbm9uLUlFIGJyb3dzZXJzLCB3ZSBjYW4gc3VwcG9ydCBib3RoIGZvcndhcmQgYW5kIGJhY2t3YXJkXG4gKiBzZWxlY3Rpb25zLlxuICpcbiAqIE5vdGU6IElFMTArIHN1cHBvcnRzIHRoZSBTZWxlY3Rpb24gb2JqZWN0LCBidXQgaXQgZG9lcyBub3Qgc3VwcG9ydFxuICogdGhlIGBleHRlbmRgIG1ldGhvZCwgd2hpY2ggbWVhbnMgdGhhdCBldmVuIGluIG1vZGVybiBJRSwgaXQncyBub3QgcG9zc2libGVcbiAqIHRvIHByb2dyYW1tYXRpY2FsbHkgY3JlYXRlIGEgYmFja3dhcmQgc2VsZWN0aW9uLiBUaHVzLCBmb3IgYWxsIElFXG4gKiB2ZXJzaW9ucywgd2UgdXNlIHRoZSBvbGQgSUUgQVBJIHRvIGNyZWF0ZSBvdXIgc2VsZWN0aW9ucy5cbiAqXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR8RE9NVGV4dE5vZGV9IG5vZGVcbiAqIEBwYXJhbSB7b2JqZWN0fSBvZmZzZXRzXG4gKi9cblxuZnVuY3Rpb24gc2V0T2Zmc2V0cyhub2RlLCBvZmZzZXRzKSB7XG4gIHZhciBkb2MgPSBub2RlLm93bmVyRG9jdW1lbnQgfHwgZG9jdW1lbnQ7XG4gIHZhciB3aW4gPSBkb2MgJiYgZG9jLmRlZmF1bHRWaWV3IHx8IHdpbmRvdzsgLy8gRWRnZSBmYWlscyB3aXRoIFwiT2JqZWN0IGV4cGVjdGVkXCIgaW4gc29tZSBzY2VuYXJpb3MuXG4gIC8vIChGb3IgaW5zdGFuY2U6IFRpbnlNQ0UgZWRpdG9yIHVzZWQgaW4gYSBsaXN0IGNvbXBvbmVudCB0aGF0IHN1cHBvcnRzIHBhc3RpbmcgdG8gYWRkIG1vcmUsXG4gIC8vIGZhaWxzIHdoZW4gcGFzdGluZyAxMDArIGl0ZW1zKVxuXG4gIGlmICghd2luLmdldFNlbGVjdGlvbikge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBzZWxlY3Rpb24gPSB3aW4uZ2V0U2VsZWN0aW9uKCk7XG4gIHZhciBsZW5ndGggPSBub2RlLnRleHRDb250ZW50Lmxlbmd0aDtcbiAgdmFyIHN0YXJ0ID0gTWF0aC5taW4ob2Zmc2V0cy5zdGFydCwgbGVuZ3RoKTtcbiAgdmFyIGVuZCA9IG9mZnNldHMuZW5kID09PSB1bmRlZmluZWQgPyBzdGFydCA6IE1hdGgubWluKG9mZnNldHMuZW5kLCBsZW5ndGgpOyAvLyBJRSAxMSB1c2VzIG1vZGVybiBzZWxlY3Rpb24sIGJ1dCBkb2Vzbid0IHN1cHBvcnQgdGhlIGV4dGVuZCBtZXRob2QuXG4gIC8vIEZsaXAgYmFja3dhcmQgc2VsZWN0aW9ucywgc28gd2UgY2FuIHNldCB3aXRoIGEgc2luZ2xlIHJhbmdlLlxuXG4gIGlmICghc2VsZWN0aW9uLmV4dGVuZCAmJiBzdGFydCA+IGVuZCkge1xuICAgIHZhciB0ZW1wID0gZW5kO1xuICAgIGVuZCA9IHN0YXJ0O1xuICAgIHN0YXJ0ID0gdGVtcDtcbiAgfVxuXG4gIHZhciBzdGFydE1hcmtlciA9IGdldE5vZGVGb3JDaGFyYWN0ZXJPZmZzZXQobm9kZSwgc3RhcnQpO1xuICB2YXIgZW5kTWFya2VyID0gZ2V0Tm9kZUZvckNoYXJhY3Rlck9mZnNldChub2RlLCBlbmQpO1xuXG4gIGlmIChzdGFydE1hcmtlciAmJiBlbmRNYXJrZXIpIHtcbiAgICBpZiAoc2VsZWN0aW9uLnJhbmdlQ291bnQgPT09IDEgJiYgc2VsZWN0aW9uLmFuY2hvck5vZGUgPT09IHN0YXJ0TWFya2VyLm5vZGUgJiYgc2VsZWN0aW9uLmFuY2hvck9mZnNldCA9PT0gc3RhcnRNYXJrZXIub2Zmc2V0ICYmIHNlbGVjdGlvbi5mb2N1c05vZGUgPT09IGVuZE1hcmtlci5ub2RlICYmIHNlbGVjdGlvbi5mb2N1c09mZnNldCA9PT0gZW5kTWFya2VyLm9mZnNldCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciByYW5nZSA9IGRvYy5jcmVhdGVSYW5nZSgpO1xuICAgIHJhbmdlLnNldFN0YXJ0KHN0YXJ0TWFya2VyLm5vZGUsIHN0YXJ0TWFya2VyLm9mZnNldCk7XG4gICAgc2VsZWN0aW9uLnJlbW92ZUFsbFJhbmdlcygpO1xuXG4gICAgaWYgKHN0YXJ0ID4gZW5kKSB7XG4gICAgICBzZWxlY3Rpb24uYWRkUmFuZ2UocmFuZ2UpO1xuICAgICAgc2VsZWN0aW9uLmV4dGVuZChlbmRNYXJrZXIubm9kZSwgZW5kTWFya2VyLm9mZnNldCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJhbmdlLnNldEVuZChlbmRNYXJrZXIubm9kZSwgZW5kTWFya2VyLm9mZnNldCk7XG4gICAgICBzZWxlY3Rpb24uYWRkUmFuZ2UocmFuZ2UpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBpc1RleHROb2RlKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUgJiYgbm9kZS5ub2RlVHlwZSA9PT0gVEVYVF9OT0RFO1xufVxuXG5mdW5jdGlvbiBjb250YWluc05vZGUob3V0ZXJOb2RlLCBpbm5lck5vZGUpIHtcbiAgaWYgKCFvdXRlck5vZGUgfHwgIWlubmVyTm9kZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSBlbHNlIGlmIChvdXRlck5vZGUgPT09IGlubmVyTm9kZSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9IGVsc2UgaWYgKGlzVGV4dE5vZGUob3V0ZXJOb2RlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSBlbHNlIGlmIChpc1RleHROb2RlKGlubmVyTm9kZSkpIHtcbiAgICByZXR1cm4gY29udGFpbnNOb2RlKG91dGVyTm9kZSwgaW5uZXJOb2RlLnBhcmVudE5vZGUpO1xuICB9IGVsc2UgaWYgKCdjb250YWlucycgaW4gb3V0ZXJOb2RlKSB7XG4gICAgcmV0dXJuIG91dGVyTm9kZS5jb250YWlucyhpbm5lck5vZGUpO1xuICB9IGVsc2UgaWYgKG91dGVyTm9kZS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbikge1xuICAgIHJldHVybiAhIShvdXRlck5vZGUuY29tcGFyZURvY3VtZW50UG9zaXRpb24oaW5uZXJOb2RlKSAmIDE2KTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNJbkRvY3VtZW50KG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUgJiYgbm9kZS5vd25lckRvY3VtZW50ICYmIGNvbnRhaW5zTm9kZShub2RlLm93bmVyRG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LCBub2RlKTtcbn1cblxuZnVuY3Rpb24gaXNTYW1lT3JpZ2luRnJhbWUoaWZyYW1lKSB7XG4gIHRyeSB7XG4gICAgLy8gQWNjZXNzaW5nIHRoZSBjb250ZW50RG9jdW1lbnQgb2YgYSBIVE1MSWZyYW1lRWxlbWVudCBjYW4gY2F1c2UgdGhlIGJyb3dzZXJcbiAgICAvLyB0byB0aHJvdywgZS5nLiBpZiBpdCBoYXMgYSBjcm9zcy1vcmlnaW4gc3JjIGF0dHJpYnV0ZS5cbiAgICAvLyBTYWZhcmkgd2lsbCBzaG93IGFuIGVycm9yIGluIHRoZSBjb25zb2xlIHdoZW4gdGhlIGFjY2VzcyByZXN1bHRzIGluIFwiQmxvY2tlZCBhIGZyYW1lIHdpdGggb3JpZ2luXCIuIGUuZzpcbiAgICAvLyBpZnJhbWUuY29udGVudERvY3VtZW50LmRlZmF1bHRWaWV3O1xuICAgIC8vIEEgc2FmZXR5IHdheSBpcyB0byBhY2Nlc3Mgb25lIG9mIHRoZSBjcm9zcyBvcmlnaW4gcHJvcGVydGllczogV2luZG93IG9yIExvY2F0aW9uXG4gICAgLy8gV2hpY2ggbWlnaHQgcmVzdWx0IGluIFwiU2VjdXJpdHlFcnJvclwiIERPTSBFeGNlcHRpb24gYW5kIGl0IGlzIGNvbXBhdGlibGUgdG8gU2FmYXJpLlxuICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2Jyb3dzZXJzLmh0bWwjaW50ZWdyYXRpb24td2l0aC1pZGxcbiAgICByZXR1cm4gdHlwZW9mIGlmcmFtZS5jb250ZW50V2luZG93LmxvY2F0aW9uLmhyZWYgPT09ICdzdHJpbmcnO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0QWN0aXZlRWxlbWVudERlZXAoKSB7XG4gIHZhciB3aW4gPSB3aW5kb3c7XG4gIHZhciBlbGVtZW50ID0gZ2V0QWN0aXZlRWxlbWVudCgpO1xuXG4gIHdoaWxlIChlbGVtZW50IGluc3RhbmNlb2Ygd2luLkhUTUxJRnJhbWVFbGVtZW50KSB7XG4gICAgaWYgKGlzU2FtZU9yaWdpbkZyYW1lKGVsZW1lbnQpKSB7XG4gICAgICB3aW4gPSBlbGVtZW50LmNvbnRlbnRXaW5kb3c7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBlbGVtZW50O1xuICAgIH1cblxuICAgIGVsZW1lbnQgPSBnZXRBY3RpdmVFbGVtZW50KHdpbi5kb2N1bWVudCk7XG4gIH1cblxuICByZXR1cm4gZWxlbWVudDtcbn1cbi8qKlxuICogQFJlYWN0SW5wdXRTZWxlY3Rpb246IFJlYWN0IGlucHV0IHNlbGVjdGlvbiBtb2R1bGUuIEJhc2VkIG9uIFNlbGVjdGlvbi5qcyxcbiAqIGJ1dCBtb2RpZmllZCB0byBiZSBzdWl0YWJsZSBmb3IgcmVhY3QgYW5kIGhhcyBhIGNvdXBsZSBvZiBidWcgZml4ZXMgKGRvZXNuJ3RcbiAqIGFzc3VtZSBidXR0b25zIGhhdmUgcmFuZ2Ugc2VsZWN0aW9ucyBhbGxvd2VkKS5cbiAqIElucHV0IHNlbGVjdGlvbiBtb2R1bGUgZm9yIFJlYWN0LlxuICovXG5cbi8qKlxuICogQGhhc1NlbGVjdGlvbkNhcGFiaWxpdGllczogd2UgZ2V0IHRoZSBlbGVtZW50IHR5cGVzIHRoYXQgc3VwcG9ydCBzZWxlY3Rpb25cbiAqIGZyb20gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy8jZG8tbm90LWFwcGx5LCBsb29raW5nIGF0IGBzZWxlY3Rpb25TdGFydGBcbiAqIGFuZCBgc2VsZWN0aW9uRW5kYCByb3dzLlxuICovXG5cblxuZnVuY3Rpb24gaGFzU2VsZWN0aW9uQ2FwYWJpbGl0aWVzKGVsZW0pIHtcbiAgdmFyIG5vZGVOYW1lID0gZWxlbSAmJiBlbGVtLm5vZGVOYW1lICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcbiAgcmV0dXJuIG5vZGVOYW1lICYmIChub2RlTmFtZSA9PT0gJ2lucHV0JyAmJiAoZWxlbS50eXBlID09PSAndGV4dCcgfHwgZWxlbS50eXBlID09PSAnc2VhcmNoJyB8fCBlbGVtLnR5cGUgPT09ICd0ZWwnIHx8IGVsZW0udHlwZSA9PT0gJ3VybCcgfHwgZWxlbS50eXBlID09PSAncGFzc3dvcmQnKSB8fCBub2RlTmFtZSA9PT0gJ3RleHRhcmVhJyB8fCBlbGVtLmNvbnRlbnRFZGl0YWJsZSA9PT0gJ3RydWUnKTtcbn1cbmZ1bmN0aW9uIGdldFNlbGVjdGlvbkluZm9ybWF0aW9uKCkge1xuICB2YXIgZm9jdXNlZEVsZW0gPSBnZXRBY3RpdmVFbGVtZW50RGVlcCgpO1xuICByZXR1cm4ge1xuICAgIGZvY3VzZWRFbGVtOiBmb2N1c2VkRWxlbSxcbiAgICBzZWxlY3Rpb25SYW5nZTogaGFzU2VsZWN0aW9uQ2FwYWJpbGl0aWVzKGZvY3VzZWRFbGVtKSA/IGdldFNlbGVjdGlvbihmb2N1c2VkRWxlbSkgOiBudWxsXG4gIH07XG59XG4vKipcbiAqIEByZXN0b3JlU2VsZWN0aW9uOiBJZiBhbnkgc2VsZWN0aW9uIGluZm9ybWF0aW9uIHdhcyBwb3RlbnRpYWxseSBsb3N0LFxuICogcmVzdG9yZSBpdC4gVGhpcyBpcyB1c2VmdWwgd2hlbiBwZXJmb3JtaW5nIG9wZXJhdGlvbnMgdGhhdCBjb3VsZCByZW1vdmUgZG9tXG4gKiBub2RlcyBhbmQgcGxhY2UgdGhlbSBiYWNrIGluLCByZXN1bHRpbmcgaW4gZm9jdXMgYmVpbmcgbG9zdC5cbiAqL1xuXG5mdW5jdGlvbiByZXN0b3JlU2VsZWN0aW9uKHByaW9yU2VsZWN0aW9uSW5mb3JtYXRpb24pIHtcbiAgdmFyIGN1ckZvY3VzZWRFbGVtID0gZ2V0QWN0aXZlRWxlbWVudERlZXAoKTtcbiAgdmFyIHByaW9yRm9jdXNlZEVsZW0gPSBwcmlvclNlbGVjdGlvbkluZm9ybWF0aW9uLmZvY3VzZWRFbGVtO1xuICB2YXIgcHJpb3JTZWxlY3Rpb25SYW5nZSA9IHByaW9yU2VsZWN0aW9uSW5mb3JtYXRpb24uc2VsZWN0aW9uUmFuZ2U7XG5cbiAgaWYgKGN1ckZvY3VzZWRFbGVtICE9PSBwcmlvckZvY3VzZWRFbGVtICYmIGlzSW5Eb2N1bWVudChwcmlvckZvY3VzZWRFbGVtKSkge1xuICAgIGlmIChwcmlvclNlbGVjdGlvblJhbmdlICE9PSBudWxsICYmIGhhc1NlbGVjdGlvbkNhcGFiaWxpdGllcyhwcmlvckZvY3VzZWRFbGVtKSkge1xuICAgICAgc2V0U2VsZWN0aW9uKHByaW9yRm9jdXNlZEVsZW0sIHByaW9yU2VsZWN0aW9uUmFuZ2UpO1xuICAgIH0gLy8gRm9jdXNpbmcgYSBub2RlIGNhbiBjaGFuZ2UgdGhlIHNjcm9sbCBwb3NpdGlvbiwgd2hpY2ggaXMgdW5kZXNpcmFibGVcblxuXG4gICAgdmFyIGFuY2VzdG9ycyA9IFtdO1xuICAgIHZhciBhbmNlc3RvciA9IHByaW9yRm9jdXNlZEVsZW07XG5cbiAgICB3aGlsZSAoYW5jZXN0b3IgPSBhbmNlc3Rvci5wYXJlbnROb2RlKSB7XG4gICAgICBpZiAoYW5jZXN0b3Iubm9kZVR5cGUgPT09IEVMRU1FTlRfTk9ERSkge1xuICAgICAgICBhbmNlc3RvcnMucHVzaCh7XG4gICAgICAgICAgZWxlbWVudDogYW5jZXN0b3IsXG4gICAgICAgICAgbGVmdDogYW5jZXN0b3Iuc2Nyb2xsTGVmdCxcbiAgICAgICAgICB0b3A6IGFuY2VzdG9yLnNjcm9sbFRvcFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHByaW9yRm9jdXNlZEVsZW0uZm9jdXMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHByaW9yRm9jdXNlZEVsZW0uZm9jdXMoKTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFuY2VzdG9ycy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGluZm8gPSBhbmNlc3RvcnNbaV07XG4gICAgICBpbmZvLmVsZW1lbnQuc2Nyb2xsTGVmdCA9IGluZm8ubGVmdDtcbiAgICAgIGluZm8uZWxlbWVudC5zY3JvbGxUb3AgPSBpbmZvLnRvcDtcbiAgICB9XG4gIH1cbn1cbi8qKlxuICogQGdldFNlbGVjdGlvbjogR2V0cyB0aGUgc2VsZWN0aW9uIGJvdW5kcyBvZiBhIGZvY3VzZWQgdGV4dGFyZWEsIGlucHV0IG9yXG4gKiBjb250ZW50RWRpdGFibGUgbm9kZS5cbiAqIC1AaW5wdXQ6IExvb2sgdXAgc2VsZWN0aW9uIGJvdW5kcyBvZiB0aGlzIGlucHV0XG4gKiAtQHJldHVybiB7c3RhcnQ6IHNlbGVjdGlvblN0YXJ0LCBlbmQ6IHNlbGVjdGlvbkVuZH1cbiAqL1xuXG5mdW5jdGlvbiBnZXRTZWxlY3Rpb24oaW5wdXQpIHtcbiAgdmFyIHNlbGVjdGlvbjtcblxuICBpZiAoJ3NlbGVjdGlvblN0YXJ0JyBpbiBpbnB1dCkge1xuICAgIC8vIE1vZGVybiBicm93c2VyIHdpdGggaW5wdXQgb3IgdGV4dGFyZWEuXG4gICAgc2VsZWN0aW9uID0ge1xuICAgICAgc3RhcnQ6IGlucHV0LnNlbGVjdGlvblN0YXJ0LFxuICAgICAgZW5kOiBpbnB1dC5zZWxlY3Rpb25FbmRcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIC8vIENvbnRlbnQgZWRpdGFibGUgb3Igb2xkIElFIHRleHRhcmVhLlxuICAgIHNlbGVjdGlvbiA9IGdldE9mZnNldHMoaW5wdXQpO1xuICB9XG5cbiAgcmV0dXJuIHNlbGVjdGlvbiB8fCB7XG4gICAgc3RhcnQ6IDAsXG4gICAgZW5kOiAwXG4gIH07XG59XG4vKipcbiAqIEBzZXRTZWxlY3Rpb246IFNldHMgdGhlIHNlbGVjdGlvbiBib3VuZHMgb2YgYSB0ZXh0YXJlYSBvciBpbnB1dCBhbmQgZm9jdXNlc1xuICogdGhlIGlucHV0LlxuICogLUBpbnB1dCAgICAgU2V0IHNlbGVjdGlvbiBib3VuZHMgb2YgdGhpcyBpbnB1dCBvciB0ZXh0YXJlYVxuICogLUBvZmZzZXRzICAgT2JqZWN0IG9mIHNhbWUgZm9ybSB0aGF0IGlzIHJldHVybmVkIGZyb20gZ2V0KlxuICovXG5cbmZ1bmN0aW9uIHNldFNlbGVjdGlvbihpbnB1dCwgb2Zmc2V0cykge1xuICB2YXIgc3RhcnQgPSBvZmZzZXRzLnN0YXJ0O1xuICB2YXIgZW5kID0gb2Zmc2V0cy5lbmQ7XG5cbiAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZW5kID0gc3RhcnQ7XG4gIH1cblxuICBpZiAoJ3NlbGVjdGlvblN0YXJ0JyBpbiBpbnB1dCkge1xuICAgIGlucHV0LnNlbGVjdGlvblN0YXJ0ID0gc3RhcnQ7XG4gICAgaW5wdXQuc2VsZWN0aW9uRW5kID0gTWF0aC5taW4oZW5kLCBpbnB1dC52YWx1ZS5sZW5ndGgpO1xuICB9IGVsc2Uge1xuICAgIHNldE9mZnNldHMoaW5wdXQsIG9mZnNldHMpO1xuICB9XG59XG5cbnZhciBza2lwU2VsZWN0aW9uQ2hhbmdlRXZlbnQgPSBjYW5Vc2VET00gJiYgJ2RvY3VtZW50TW9kZScgaW4gZG9jdW1lbnQgJiYgZG9jdW1lbnQuZG9jdW1lbnRNb2RlIDw9IDExO1xuXG5mdW5jdGlvbiByZWdpc3RlckV2ZW50cyQzKCkge1xuICByZWdpc3RlclR3b1BoYXNlRXZlbnQoJ29uU2VsZWN0JywgWydmb2N1c291dCcsICdjb250ZXh0bWVudScsICdkcmFnZW5kJywgJ2ZvY3VzaW4nLCAna2V5ZG93bicsICdrZXl1cCcsICdtb3VzZWRvd24nLCAnbW91c2V1cCcsICdzZWxlY3Rpb25jaGFuZ2UnXSk7XG59XG5cbnZhciBhY3RpdmVFbGVtZW50JDEgPSBudWxsO1xudmFyIGFjdGl2ZUVsZW1lbnRJbnN0JDEgPSBudWxsO1xudmFyIGxhc3RTZWxlY3Rpb24gPSBudWxsO1xudmFyIG1vdXNlRG93biA9IGZhbHNlO1xuLyoqXG4gKiBHZXQgYW4gb2JqZWN0IHdoaWNoIGlzIGEgdW5pcXVlIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBjdXJyZW50IHNlbGVjdGlvbi5cbiAqXG4gKiBUaGUgcmV0dXJuIHZhbHVlIHdpbGwgbm90IGJlIGNvbnNpc3RlbnQgYWNyb3NzIG5vZGVzIG9yIGJyb3dzZXJzLCBidXRcbiAqIHR3byBpZGVudGljYWwgc2VsZWN0aW9ucyBvbiB0aGUgc2FtZSBub2RlIHdpbGwgcmV0dXJuIGlkZW50aWNhbCBvYmplY3RzLlxuICovXG5cbmZ1bmN0aW9uIGdldFNlbGVjdGlvbiQxKG5vZGUpIHtcbiAgaWYgKCdzZWxlY3Rpb25TdGFydCcgaW4gbm9kZSAmJiBoYXNTZWxlY3Rpb25DYXBhYmlsaXRpZXMobm9kZSkpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc3RhcnQ6IG5vZGUuc2VsZWN0aW9uU3RhcnQsXG4gICAgICBlbmQ6IG5vZGUuc2VsZWN0aW9uRW5kXG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgd2luID0gbm9kZS5vd25lckRvY3VtZW50ICYmIG5vZGUub3duZXJEb2N1bWVudC5kZWZhdWx0VmlldyB8fCB3aW5kb3c7XG4gICAgdmFyIHNlbGVjdGlvbiA9IHdpbi5nZXRTZWxlY3Rpb24oKTtcbiAgICByZXR1cm4ge1xuICAgICAgYW5jaG9yTm9kZTogc2VsZWN0aW9uLmFuY2hvck5vZGUsXG4gICAgICBhbmNob3JPZmZzZXQ6IHNlbGVjdGlvbi5hbmNob3JPZmZzZXQsXG4gICAgICBmb2N1c05vZGU6IHNlbGVjdGlvbi5mb2N1c05vZGUsXG4gICAgICBmb2N1c09mZnNldDogc2VsZWN0aW9uLmZvY3VzT2Zmc2V0XG4gICAgfTtcbiAgfVxufVxuLyoqXG4gKiBHZXQgZG9jdW1lbnQgYXNzb2NpYXRlZCB3aXRoIHRoZSBldmVudCB0YXJnZXQuXG4gKi9cblxuXG5mdW5jdGlvbiBnZXRFdmVudFRhcmdldERvY3VtZW50KGV2ZW50VGFyZ2V0KSB7XG4gIHJldHVybiBldmVudFRhcmdldC53aW5kb3cgPT09IGV2ZW50VGFyZ2V0ID8gZXZlbnRUYXJnZXQuZG9jdW1lbnQgOiBldmVudFRhcmdldC5ub2RlVHlwZSA9PT0gRE9DVU1FTlRfTk9ERSA/IGV2ZW50VGFyZ2V0IDogZXZlbnRUYXJnZXQub3duZXJEb2N1bWVudDtcbn1cbi8qKlxuICogUG9sbCBzZWxlY3Rpb24gdG8gc2VlIHdoZXRoZXIgaXQncyBjaGFuZ2VkLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudFxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50VGFyZ2V0XG4gKiBAcmV0dXJuIHs/U3ludGhldGljRXZlbnR9XG4gKi9cblxuXG5mdW5jdGlvbiBjb25zdHJ1Y3RTZWxlY3RFdmVudChkaXNwYXRjaFF1ZXVlLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgLy8gRW5zdXJlIHdlIGhhdmUgdGhlIHJpZ2h0IGVsZW1lbnQsIGFuZCB0aGF0IHRoZSB1c2VyIGlzIG5vdCBkcmFnZ2luZyBhXG4gIC8vIHNlbGVjdGlvbiAodGhpcyBtYXRjaGVzIG5hdGl2ZSBgc2VsZWN0YCBldmVudCBiZWhhdmlvcikuIEluIEhUTUw1LCBzZWxlY3RcbiAgLy8gZmlyZXMgb25seSBvbiBpbnB1dCBhbmQgdGV4dGFyZWEgdGh1cyBpZiB0aGVyZSdzIG5vIGZvY3VzZWQgZWxlbWVudCB3ZVxuICAvLyB3b24ndCBkaXNwYXRjaC5cbiAgdmFyIGRvYyA9IGdldEV2ZW50VGFyZ2V0RG9jdW1lbnQobmF0aXZlRXZlbnRUYXJnZXQpO1xuXG4gIGlmIChtb3VzZURvd24gfHwgYWN0aXZlRWxlbWVudCQxID09IG51bGwgfHwgYWN0aXZlRWxlbWVudCQxICE9PSBnZXRBY3RpdmVFbGVtZW50KGRvYykpIHtcbiAgICByZXR1cm47XG4gIH0gLy8gT25seSBmaXJlIHdoZW4gc2VsZWN0aW9uIGhhcyBhY3R1YWxseSBjaGFuZ2VkLlxuXG5cbiAgdmFyIGN1cnJlbnRTZWxlY3Rpb24gPSBnZXRTZWxlY3Rpb24kMShhY3RpdmVFbGVtZW50JDEpO1xuXG4gIGlmICghbGFzdFNlbGVjdGlvbiB8fCAhc2hhbGxvd0VxdWFsKGxhc3RTZWxlY3Rpb24sIGN1cnJlbnRTZWxlY3Rpb24pKSB7XG4gICAgbGFzdFNlbGVjdGlvbiA9IGN1cnJlbnRTZWxlY3Rpb247XG4gICAgdmFyIGxpc3RlbmVycyA9IGFjY3VtdWxhdGVUd29QaGFzZUxpc3RlbmVycyhhY3RpdmVFbGVtZW50SW5zdCQxLCAnb25TZWxlY3QnKTtcblxuICAgIGlmIChsaXN0ZW5lcnMubGVuZ3RoID4gMCkge1xuICAgICAgdmFyIGV2ZW50ID0gbmV3IFN5bnRoZXRpY0V2ZW50KCdvblNlbGVjdCcsICdzZWxlY3QnLCBudWxsLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xuICAgICAgZGlzcGF0Y2hRdWV1ZS5wdXNoKHtcbiAgICAgICAgZXZlbnQ6IGV2ZW50LFxuICAgICAgICBsaXN0ZW5lcnM6IGxpc3RlbmVyc1xuICAgICAgfSk7XG4gICAgICBldmVudC50YXJnZXQgPSBhY3RpdmVFbGVtZW50JDE7XG4gICAgfVxuICB9XG59XG4vKipcbiAqIFRoaXMgcGx1Z2luIGNyZWF0ZXMgYW4gYG9uU2VsZWN0YCBldmVudCB0aGF0IG5vcm1hbGl6ZXMgc2VsZWN0IGV2ZW50c1xuICogYWNyb3NzIGZvcm0gZWxlbWVudHMuXG4gKlxuICogU3VwcG9ydGVkIGVsZW1lbnRzIGFyZTpcbiAqIC0gaW5wdXQgKHNlZSBgaXNUZXh0SW5wdXRFbGVtZW50YClcbiAqIC0gdGV4dGFyZWFcbiAqIC0gY29udGVudEVkaXRhYmxlXG4gKlxuICogVGhpcyBkaWZmZXJzIGZyb20gbmF0aXZlIGJyb3dzZXIgaW1wbGVtZW50YXRpb25zIGluIHRoZSBmb2xsb3dpbmcgd2F5czpcbiAqIC0gRmlyZXMgb24gY29udGVudEVkaXRhYmxlIGZpZWxkcyBhcyB3ZWxsIGFzIGlucHV0cy5cbiAqIC0gRmlyZXMgZm9yIGNvbGxhcHNlZCBzZWxlY3Rpb24uXG4gKiAtIEZpcmVzIGFmdGVyIHVzZXIgaW5wdXQuXG4gKi9cblxuXG5mdW5jdGlvbiBleHRyYWN0RXZlbnRzJDMoZGlzcGF0Y2hRdWV1ZSwgZG9tRXZlbnROYW1lLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQsIGV2ZW50U3lzdGVtRmxhZ3MsIHRhcmdldENvbnRhaW5lcikge1xuXG4gIHZhciB0YXJnZXROb2RlID0gdGFyZ2V0SW5zdCA/IGdldE5vZGVGcm9tSW5zdGFuY2UodGFyZ2V0SW5zdCkgOiB3aW5kb3c7XG5cbiAgc3dpdGNoIChkb21FdmVudE5hbWUpIHtcbiAgICAvLyBUcmFjayB0aGUgaW5wdXQgbm9kZSB0aGF0IGhhcyBmb2N1cy5cbiAgICBjYXNlICdmb2N1c2luJzpcbiAgICAgIGlmIChpc1RleHRJbnB1dEVsZW1lbnQodGFyZ2V0Tm9kZSkgfHwgdGFyZ2V0Tm9kZS5jb250ZW50RWRpdGFibGUgPT09ICd0cnVlJykge1xuICAgICAgICBhY3RpdmVFbGVtZW50JDEgPSB0YXJnZXROb2RlO1xuICAgICAgICBhY3RpdmVFbGVtZW50SW5zdCQxID0gdGFyZ2V0SW5zdDtcbiAgICAgICAgbGFzdFNlbGVjdGlvbiA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnZm9jdXNvdXQnOlxuICAgICAgYWN0aXZlRWxlbWVudCQxID0gbnVsbDtcbiAgICAgIGFjdGl2ZUVsZW1lbnRJbnN0JDEgPSBudWxsO1xuICAgICAgbGFzdFNlbGVjdGlvbiA9IG51bGw7XG4gICAgICBicmVhaztcbiAgICAvLyBEb24ndCBmaXJlIHRoZSBldmVudCB3aGlsZSB0aGUgdXNlciBpcyBkcmFnZ2luZy4gVGhpcyBtYXRjaGVzIHRoZVxuICAgIC8vIHNlbWFudGljcyBvZiB0aGUgbmF0aXZlIHNlbGVjdCBldmVudC5cblxuICAgIGNhc2UgJ21vdXNlZG93bic6XG4gICAgICBtb3VzZURvd24gPSB0cnVlO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdjb250ZXh0bWVudSc6XG4gICAgY2FzZSAnbW91c2V1cCc6XG4gICAgY2FzZSAnZHJhZ2VuZCc6XG4gICAgICBtb3VzZURvd24gPSBmYWxzZTtcbiAgICAgIGNvbnN0cnVjdFNlbGVjdEV2ZW50KGRpc3BhdGNoUXVldWUsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG4gICAgICBicmVhaztcbiAgICAvLyBDaHJvbWUgYW5kIElFIGZpcmUgbm9uLXN0YW5kYXJkIGV2ZW50IHdoZW4gc2VsZWN0aW9uIGlzIGNoYW5nZWQgKGFuZFxuICAgIC8vIHNvbWV0aW1lcyB3aGVuIGl0IGhhc24ndCkuIElFJ3MgZXZlbnQgZmlyZXMgb3V0IG9mIG9yZGVyIHdpdGggcmVzcGVjdFxuICAgIC8vIHRvIGtleSBhbmQgaW5wdXQgZXZlbnRzIG9uIGRlbGV0aW9uLCBzbyB3ZSBkaXNjYXJkIGl0LlxuICAgIC8vXG4gICAgLy8gRmlyZWZveCBkb2Vzbid0IHN1cHBvcnQgc2VsZWN0aW9uY2hhbmdlLCBzbyBjaGVjayBzZWxlY3Rpb24gc3RhdHVzXG4gICAgLy8gYWZ0ZXIgZWFjaCBrZXkgZW50cnkuIFRoZSBzZWxlY3Rpb24gY2hhbmdlcyBhZnRlciBrZXlkb3duIGFuZCBiZWZvcmVcbiAgICAvLyBrZXl1cCwgYnV0IHdlIGNoZWNrIG9uIGtleWRvd24gYXMgd2VsbCBpbiB0aGUgY2FzZSBvZiBob2xkaW5nIGRvd24gYVxuICAgIC8vIGtleSwgd2hlbiBtdWx0aXBsZSBrZXlkb3duIGV2ZW50cyBhcmUgZmlyZWQgYnV0IG9ubHkgb25lIGtleXVwIGlzLlxuICAgIC8vIFRoaXMgaXMgYWxzbyBvdXIgYXBwcm9hY2ggZm9yIElFIGhhbmRsaW5nLCBmb3IgdGhlIHJlYXNvbiBhYm92ZS5cblxuICAgIGNhc2UgJ3NlbGVjdGlvbmNoYW5nZSc6XG4gICAgICBpZiAoc2tpcFNlbGVjdGlvbkNoYW5nZUV2ZW50KSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgLy8gZmFsbHMgdGhyb3VnaFxuXG4gICAgY2FzZSAna2V5ZG93bic6XG4gICAgY2FzZSAna2V5dXAnOlxuICAgICAgY29uc3RydWN0U2VsZWN0RXZlbnQoZGlzcGF0Y2hRdWV1ZSwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBleHRyYWN0RXZlbnRzJDQoZGlzcGF0Y2hRdWV1ZSwgZG9tRXZlbnROYW1lLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQsIGV2ZW50U3lzdGVtRmxhZ3MsIHRhcmdldENvbnRhaW5lcikge1xuICB2YXIgcmVhY3ROYW1lID0gdG9wTGV2ZWxFdmVudHNUb1JlYWN0TmFtZXMuZ2V0KGRvbUV2ZW50TmFtZSk7XG5cbiAgaWYgKHJlYWN0TmFtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIFN5bnRoZXRpY0V2ZW50Q3RvciA9IFN5bnRoZXRpY0V2ZW50O1xuICB2YXIgcmVhY3RFdmVudFR5cGUgPSBkb21FdmVudE5hbWU7XG5cbiAgc3dpdGNoIChkb21FdmVudE5hbWUpIHtcbiAgICBjYXNlICdrZXlwcmVzcyc6XG4gICAgICAvLyBGaXJlZm94IGNyZWF0ZXMgYSBrZXlwcmVzcyBldmVudCBmb3IgZnVuY3Rpb24ga2V5cyB0b28uIFRoaXMgcmVtb3Zlc1xuICAgICAgLy8gdGhlIHVud2FudGVkIGtleXByZXNzIGV2ZW50cy4gRW50ZXIgaXMgaG93ZXZlciBib3RoIHByaW50YWJsZSBhbmRcbiAgICAgIC8vIG5vbi1wcmludGFibGUuIE9uZSB3b3VsZCBleHBlY3QgVGFiIHRvIGJlIGFzIHdlbGwgKGJ1dCBpdCBpc24ndCkuXG4gICAgICBpZiAoZ2V0RXZlbnRDaGFyQ29kZShuYXRpdmVFdmVudCkgPT09IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuXG4gICAgY2FzZSAna2V5ZG93bic6XG4gICAgY2FzZSAna2V5dXAnOlxuICAgICAgU3ludGhldGljRXZlbnRDdG9yID0gU3ludGhldGljS2V5Ym9hcmRFdmVudDtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnZm9jdXNpbic6XG4gICAgICByZWFjdEV2ZW50VHlwZSA9ICdmb2N1cyc7XG4gICAgICBTeW50aGV0aWNFdmVudEN0b3IgPSBTeW50aGV0aWNGb2N1c0V2ZW50O1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdmb2N1c291dCc6XG4gICAgICByZWFjdEV2ZW50VHlwZSA9ICdibHVyJztcbiAgICAgIFN5bnRoZXRpY0V2ZW50Q3RvciA9IFN5bnRoZXRpY0ZvY3VzRXZlbnQ7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ2JlZm9yZWJsdXInOlxuICAgIGNhc2UgJ2FmdGVyYmx1cic6XG4gICAgICBTeW50aGV0aWNFdmVudEN0b3IgPSBTeW50aGV0aWNGb2N1c0V2ZW50O1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdjbGljayc6XG4gICAgICAvLyBGaXJlZm94IGNyZWF0ZXMgYSBjbGljayBldmVudCBvbiByaWdodCBtb3VzZSBjbGlja3MuIFRoaXMgcmVtb3ZlcyB0aGVcbiAgICAgIC8vIHVud2FudGVkIGNsaWNrIGV2ZW50cy5cbiAgICAgIGlmIChuYXRpdmVFdmVudC5idXR0b24gPT09IDIpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuXG4gICAgY2FzZSAnYXV4Y2xpY2snOlxuICAgIGNhc2UgJ2RibGNsaWNrJzpcbiAgICBjYXNlICdtb3VzZWRvd24nOlxuICAgIGNhc2UgJ21vdXNlbW92ZSc6XG4gICAgY2FzZSAnbW91c2V1cCc6IC8vIFRPRE86IERpc2FibGVkIGVsZW1lbnRzIHNob3VsZCBub3QgcmVzcG9uZCB0byBtb3VzZSBldmVudHNcblxuICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cblxuICAgIGNhc2UgJ21vdXNlb3V0JzpcbiAgICBjYXNlICdtb3VzZW92ZXInOlxuICAgIGNhc2UgJ2NvbnRleHRtZW51JzpcbiAgICAgIFN5bnRoZXRpY0V2ZW50Q3RvciA9IFN5bnRoZXRpY01vdXNlRXZlbnQ7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ2RyYWcnOlxuICAgIGNhc2UgJ2RyYWdlbmQnOlxuICAgIGNhc2UgJ2RyYWdlbnRlcic6XG4gICAgY2FzZSAnZHJhZ2V4aXQnOlxuICAgIGNhc2UgJ2RyYWdsZWF2ZSc6XG4gICAgY2FzZSAnZHJhZ292ZXInOlxuICAgIGNhc2UgJ2RyYWdzdGFydCc6XG4gICAgY2FzZSAnZHJvcCc6XG4gICAgICBTeW50aGV0aWNFdmVudEN0b3IgPSBTeW50aGV0aWNEcmFnRXZlbnQ7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ3RvdWNoY2FuY2VsJzpcbiAgICBjYXNlICd0b3VjaGVuZCc6XG4gICAgY2FzZSAndG91Y2htb3ZlJzpcbiAgICBjYXNlICd0b3VjaHN0YXJ0JzpcbiAgICAgIFN5bnRoZXRpY0V2ZW50Q3RvciA9IFN5bnRoZXRpY1RvdWNoRXZlbnQ7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgQU5JTUFUSU9OX0VORDpcbiAgICBjYXNlIEFOSU1BVElPTl9JVEVSQVRJT046XG4gICAgY2FzZSBBTklNQVRJT05fU1RBUlQ6XG4gICAgICBTeW50aGV0aWNFdmVudEN0b3IgPSBTeW50aGV0aWNBbmltYXRpb25FdmVudDtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBUUkFOU0lUSU9OX0VORDpcbiAgICAgIFN5bnRoZXRpY0V2ZW50Q3RvciA9IFN5bnRoZXRpY1RyYW5zaXRpb25FdmVudDtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnc2Nyb2xsJzpcbiAgICAgIFN5bnRoZXRpY0V2ZW50Q3RvciA9IFN5bnRoZXRpY1VJRXZlbnQ7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ3doZWVsJzpcbiAgICAgIFN5bnRoZXRpY0V2ZW50Q3RvciA9IFN5bnRoZXRpY1doZWVsRXZlbnQ7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ2NvcHknOlxuICAgIGNhc2UgJ2N1dCc6XG4gICAgY2FzZSAncGFzdGUnOlxuICAgICAgU3ludGhldGljRXZlbnRDdG9yID0gU3ludGhldGljQ2xpcGJvYXJkRXZlbnQ7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ2dvdHBvaW50ZXJjYXB0dXJlJzpcbiAgICBjYXNlICdsb3N0cG9pbnRlcmNhcHR1cmUnOlxuICAgIGNhc2UgJ3BvaW50ZXJjYW5jZWwnOlxuICAgIGNhc2UgJ3BvaW50ZXJkb3duJzpcbiAgICBjYXNlICdwb2ludGVybW92ZSc6XG4gICAgY2FzZSAncG9pbnRlcm91dCc6XG4gICAgY2FzZSAncG9pbnRlcm92ZXInOlxuICAgIGNhc2UgJ3BvaW50ZXJ1cCc6XG4gICAgICBTeW50aGV0aWNFdmVudEN0b3IgPSBTeW50aGV0aWNQb2ludGVyRXZlbnQ7XG4gICAgICBicmVhaztcbiAgfVxuXG4gIHZhciBpbkNhcHR1cmVQaGFzZSA9IChldmVudFN5c3RlbUZsYWdzICYgSVNfQ0FQVFVSRV9QSEFTRSkgIT09IDA7XG5cbiAge1xuICAgIC8vIFNvbWUgZXZlbnRzIGRvbid0IGJ1YmJsZSBpbiB0aGUgYnJvd3Nlci5cbiAgICAvLyBJbiB0aGUgcGFzdCwgUmVhY3QgaGFzIGFsd2F5cyBidWJibGVkIHRoZW0sIGJ1dCB0aGlzIGNhbiBiZSBzdXJwcmlzaW5nLlxuICAgIC8vIFdlJ3JlIGdvaW5nIHRvIHRyeSBhbGlnbmluZyBjbG9zZXIgdG8gdGhlIGJyb3dzZXIgYmVoYXZpb3IgYnkgbm90IGJ1YmJsaW5nXG4gICAgLy8gdGhlbSBpbiBSZWFjdCBlaXRoZXIuIFdlJ2xsIHN0YXJ0IGJ5IG5vdCBidWJibGluZyBvblNjcm9sbCwgYW5kIHRoZW4gZXhwYW5kLlxuICAgIHZhciBhY2N1bXVsYXRlVGFyZ2V0T25seSA9ICFpbkNhcHR1cmVQaGFzZSAmJiAvLyBUT0RPOiBpZGVhbGx5LCB3ZSdkIGV2ZW50dWFsbHkgYWRkIGFsbCBldmVudHMgZnJvbVxuICAgIC8vIG5vbkRlbGVnYXRlZEV2ZW50cyBsaXN0IGluIERPTVBsdWdpbkV2ZW50U3lzdGVtLlxuICAgIC8vIFRoZW4gd2UgY2FuIHJlbW92ZSB0aGlzIHNwZWNpYWwgbGlzdC5cbiAgICAvLyBUaGlzIGlzIGEgYnJlYWtpbmcgY2hhbmdlIHRoYXQgY2FuIHdhaXQgdW50aWwgUmVhY3QgMTguXG4gICAgZG9tRXZlbnROYW1lID09PSAnc2Nyb2xsJztcblxuICAgIHZhciBfbGlzdGVuZXJzID0gYWNjdW11bGF0ZVNpbmdsZVBoYXNlTGlzdGVuZXJzKHRhcmdldEluc3QsIHJlYWN0TmFtZSwgbmF0aXZlRXZlbnQudHlwZSwgaW5DYXB0dXJlUGhhc2UsIGFjY3VtdWxhdGVUYXJnZXRPbmx5KTtcblxuICAgIGlmIChfbGlzdGVuZXJzLmxlbmd0aCA+IDApIHtcbiAgICAgIC8vIEludGVudGlvbmFsbHkgY3JlYXRlIGV2ZW50IGxhemlseS5cbiAgICAgIHZhciBfZXZlbnQgPSBuZXcgU3ludGhldGljRXZlbnRDdG9yKHJlYWN0TmFtZSwgcmVhY3RFdmVudFR5cGUsIG51bGwsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG5cbiAgICAgIGRpc3BhdGNoUXVldWUucHVzaCh7XG4gICAgICAgIGV2ZW50OiBfZXZlbnQsXG4gICAgICAgIGxpc3RlbmVyczogX2xpc3RlbmVyc1xuICAgICAgfSk7XG4gICAgfVxuICB9XG59XG5cbi8vIFRPRE86IHJlbW92ZSB0b3AtbGV2ZWwgc2lkZSBlZmZlY3QuXG5yZWdpc3RlclNpbXBsZUV2ZW50cygpO1xucmVnaXN0ZXJFdmVudHMkMigpO1xucmVnaXN0ZXJFdmVudHMkMSgpO1xucmVnaXN0ZXJFdmVudHMkMygpO1xucmVnaXN0ZXJFdmVudHMoKTtcblxuZnVuY3Rpb24gZXh0cmFjdEV2ZW50cyQ1KGRpc3BhdGNoUXVldWUsIGRvbUV2ZW50TmFtZSwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0LCBldmVudFN5c3RlbUZsYWdzLCB0YXJnZXRDb250YWluZXIpIHtcbiAgLy8gVE9ETzogd2Ugc2hvdWxkIHJlbW92ZSB0aGUgY29uY2VwdCBvZiBhIFwiU2ltcGxlRXZlbnRQbHVnaW5cIi5cbiAgLy8gVGhpcyBpcyB0aGUgYmFzaWMgZnVuY3Rpb25hbGl0eSBvZiB0aGUgZXZlbnQgc3lzdGVtLiBBbGxcbiAgLy8gdGhlIG90aGVyIHBsdWdpbnMgYXJlIGVzc2VudGlhbGx5IHBvbHlmaWxscy4gU28gdGhlIHBsdWdpblxuICAvLyBzaG91bGQgcHJvYmFibHkgYmUgaW5saW5lZCBzb21ld2hlcmUgYW5kIGhhdmUgaXRzIGxvZ2ljXG4gIC8vIGJlIGNvcmUgdGhlIHRvIGV2ZW50IHN5c3RlbS4gVGhpcyB3b3VsZCBwb3RlbnRpYWxseSBhbGxvd1xuICAvLyB1cyB0byBzaGlwIGJ1aWxkcyBvZiBSZWFjdCB3aXRob3V0IHRoZSBwb2x5ZmlsbGVkIHBsdWdpbnMgYmVsb3cuXG4gIGV4dHJhY3RFdmVudHMkNChkaXNwYXRjaFF1ZXVlLCBkb21FdmVudE5hbWUsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCwgZXZlbnRTeXN0ZW1GbGFncyk7XG4gIHZhciBzaG91bGRQcm9jZXNzUG9seWZpbGxQbHVnaW5zID0gKGV2ZW50U3lzdGVtRmxhZ3MgJiBTSE9VTERfTk9UX1BST0NFU1NfUE9MWUZJTExfRVZFTlRfUExVR0lOUykgPT09IDA7IC8vIFdlIGRvbid0IHByb2Nlc3MgdGhlc2UgZXZlbnRzIHVubGVzcyB3ZSBhcmUgaW4gdGhlXG4gIC8vIGV2ZW50J3MgbmF0aXZlIFwiYnViYmxlXCIgcGhhc2UsIHdoaWNoIG1lYW5zIHRoYXQgd2UncmVcbiAgLy8gbm90IGluIHRoZSBjYXB0dXJlIHBoYXNlLiBUaGF0J3MgYmVjYXVzZSB3ZSBlbXVsYXRlXG4gIC8vIHRoZSBjYXB0dXJlIHBoYXNlIGhlcmUgc3RpbGwuIFRoaXMgaXMgYSB0cmFkZS1vZmYsXG4gIC8vIGJlY2F1c2UgaW4gYW4gaWRlYWwgd29ybGQgd2Ugd291bGQgbm90IGVtdWxhdGUgYW5kIHVzZVxuICAvLyB0aGUgcGhhc2VzIHByb3Blcmx5LCBsaWtlIHdlIGRvIHdpdGggdGhlIFNpbXBsZUV2ZW50XG4gIC8vIHBsdWdpbi4gSG93ZXZlciwgdGhlIHBsdWdpbnMgYmVsb3cgZWl0aGVyIGV4cGVjdFxuICAvLyBlbXVsYXRpb24gKEVudGVyTGVhdmUpIG9yIHVzZSBzdGF0ZSBsb2NhbGl6ZWQgdG8gdGhhdFxuICAvLyBwbHVnaW4gKEJlZm9yZUlucHV0LCBDaGFuZ2UsIFNlbGVjdCkuIFRoZSBzdGF0ZSBpblxuICAvLyB0aGVzZSBtb2R1bGVzIGNvbXBsaWNhdGVzIHRoaW5ncywgYXMgeW91J2xsIGVzc2VudGlhbGx5XG4gIC8vIGdldCB0aGUgY2FzZSB3aGVyZSB0aGUgY2FwdHVyZSBwaGFzZSBldmVudCBtaWdodCBjaGFuZ2VcbiAgLy8gc3RhdGUsIG9ubHkgZm9yIHRoZSBmb2xsb3dpbmcgYnViYmxlIGV2ZW50IHRvIGNvbWUgaW5cbiAgLy8gbGF0ZXIgYW5kIG5vdCB0cmlnZ2VyIGFueXRoaW5nIGFzIHRoZSBzdGF0ZSBub3dcbiAgLy8gaW52YWxpZGF0ZXMgdGhlIGhldXJpc3RpY3Mgb2YgdGhlIGV2ZW50IHBsdWdpbi4gV2VcbiAgLy8gY291bGQgYWx0ZXIgYWxsIHRoZXNlIHBsdWdpbnMgdG8gd29yayBpbiBzdWNoIHdheXMsIGJ1dFxuICAvLyB0aGF0IG1pZ2h0IGNhdXNlIG90aGVyIHVua25vd24gc2lkZS1lZmZlY3RzIHRoYXQgd2VcbiAgLy8gY2FuJ3QgZm9yc2VlIHJpZ2h0IG5vdy5cblxuICBpZiAoc2hvdWxkUHJvY2Vzc1BvbHlmaWxsUGx1Z2lucykge1xuICAgIGV4dHJhY3RFdmVudHMkMihkaXNwYXRjaFF1ZXVlLCBkb21FdmVudE5hbWUsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCwgZXZlbnRTeXN0ZW1GbGFncyk7XG4gICAgZXh0cmFjdEV2ZW50cyQxKGRpc3BhdGNoUXVldWUsIGRvbUV2ZW50TmFtZSwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbiAgICBleHRyYWN0RXZlbnRzJDMoZGlzcGF0Y2hRdWV1ZSwgZG9tRXZlbnROYW1lLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xuICAgIGV4dHJhY3RFdmVudHMoZGlzcGF0Y2hRdWV1ZSwgZG9tRXZlbnROYW1lLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xuICB9XG59IC8vIExpc3Qgb2YgZXZlbnRzIHRoYXQgbmVlZCB0byBiZSBpbmRpdmlkdWFsbHkgYXR0YWNoZWQgdG8gbWVkaWEgZWxlbWVudHMuXG5cblxudmFyIG1lZGlhRXZlbnRUeXBlcyA9IFsnYWJvcnQnLCAnY2FucGxheScsICdjYW5wbGF5dGhyb3VnaCcsICdkdXJhdGlvbmNoYW5nZScsICdlbXB0aWVkJywgJ2VuY3J5cHRlZCcsICdlbmRlZCcsICdlcnJvcicsICdsb2FkZWRkYXRhJywgJ2xvYWRlZG1ldGFkYXRhJywgJ2xvYWRzdGFydCcsICdwYXVzZScsICdwbGF5JywgJ3BsYXlpbmcnLCAncHJvZ3Jlc3MnLCAncmF0ZWNoYW5nZScsICdzZWVrZWQnLCAnc2Vla2luZycsICdzdGFsbGVkJywgJ3N1c3BlbmQnLCAndGltZXVwZGF0ZScsICd2b2x1bWVjaGFuZ2UnLCAnd2FpdGluZyddOyAvLyBXZSBzaG91bGQgbm90IGRlbGVnYXRlIHRoZXNlIGV2ZW50cyB0byB0aGUgY29udGFpbmVyLCBidXQgcmF0aGVyXG4vLyBzZXQgdGhlbSBvbiB0aGUgYWN0dWFsIHRhcmdldCBlbGVtZW50IGl0c2VsZi4gVGhpcyBpcyBwcmltYXJpbHlcbi8vIGJlY2F1c2UgdGhlc2UgZXZlbnRzIGRvIG5vdCBjb25zaXN0ZW50bHkgYnViYmxlIGluIHRoZSBET00uXG5cbnZhciBub25EZWxlZ2F0ZWRFdmVudHMgPSBuZXcgU2V0KFsnY2FuY2VsJywgJ2Nsb3NlJywgJ2ludmFsaWQnLCAnbG9hZCcsICdzY3JvbGwnLCAndG9nZ2xlJ10uY29uY2F0KG1lZGlhRXZlbnRUeXBlcykpO1xuXG5mdW5jdGlvbiBleGVjdXRlRGlzcGF0Y2goZXZlbnQsIGxpc3RlbmVyLCBjdXJyZW50VGFyZ2V0KSB7XG4gIHZhciB0eXBlID0gZXZlbnQudHlwZSB8fCAndW5rbm93bi1ldmVudCc7XG4gIGV2ZW50LmN1cnJlbnRUYXJnZXQgPSBjdXJyZW50VGFyZ2V0O1xuICBpbnZva2VHdWFyZGVkQ2FsbGJhY2tBbmRDYXRjaEZpcnN0RXJyb3IodHlwZSwgbGlzdGVuZXIsIHVuZGVmaW5lZCwgZXZlbnQpO1xuICBldmVudC5jdXJyZW50VGFyZ2V0ID0gbnVsbDtcbn1cblxuZnVuY3Rpb24gcHJvY2Vzc0Rpc3BhdGNoUXVldWVJdGVtc0luT3JkZXIoZXZlbnQsIGRpc3BhdGNoTGlzdGVuZXJzLCBpbkNhcHR1cmVQaGFzZSkge1xuICB2YXIgcHJldmlvdXNJbnN0YW5jZTtcblxuICBpZiAoaW5DYXB0dXJlUGhhc2UpIHtcbiAgICBmb3IgKHZhciBpID0gZGlzcGF0Y2hMaXN0ZW5lcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIHZhciBfZGlzcGF0Y2hMaXN0ZW5lcnMkaSA9IGRpc3BhdGNoTGlzdGVuZXJzW2ldLFxuICAgICAgICAgIGluc3RhbmNlID0gX2Rpc3BhdGNoTGlzdGVuZXJzJGkuaW5zdGFuY2UsXG4gICAgICAgICAgY3VycmVudFRhcmdldCA9IF9kaXNwYXRjaExpc3RlbmVycyRpLmN1cnJlbnRUYXJnZXQsXG4gICAgICAgICAgbGlzdGVuZXIgPSBfZGlzcGF0Y2hMaXN0ZW5lcnMkaS5saXN0ZW5lcjtcblxuICAgICAgaWYgKGluc3RhbmNlICE9PSBwcmV2aW91c0luc3RhbmNlICYmIGV2ZW50LmlzUHJvcGFnYXRpb25TdG9wcGVkKCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBleGVjdXRlRGlzcGF0Y2goZXZlbnQsIGxpc3RlbmVyLCBjdXJyZW50VGFyZ2V0KTtcbiAgICAgIHByZXZpb3VzSW5zdGFuY2UgPSBpbnN0YW5jZTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGRpc3BhdGNoTGlzdGVuZXJzLmxlbmd0aDsgX2krKykge1xuICAgICAgdmFyIF9kaXNwYXRjaExpc3RlbmVycyRfaSA9IGRpc3BhdGNoTGlzdGVuZXJzW19pXSxcbiAgICAgICAgICBfaW5zdGFuY2UgPSBfZGlzcGF0Y2hMaXN0ZW5lcnMkX2kuaW5zdGFuY2UsXG4gICAgICAgICAgX2N1cnJlbnRUYXJnZXQgPSBfZGlzcGF0Y2hMaXN0ZW5lcnMkX2kuY3VycmVudFRhcmdldCxcbiAgICAgICAgICBfbGlzdGVuZXIgPSBfZGlzcGF0Y2hMaXN0ZW5lcnMkX2kubGlzdGVuZXI7XG5cbiAgICAgIGlmIChfaW5zdGFuY2UgIT09IHByZXZpb3VzSW5zdGFuY2UgJiYgZXZlbnQuaXNQcm9wYWdhdGlvblN0b3BwZWQoKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGV4ZWN1dGVEaXNwYXRjaChldmVudCwgX2xpc3RlbmVyLCBfY3VycmVudFRhcmdldCk7XG4gICAgICBwcmV2aW91c0luc3RhbmNlID0gX2luc3RhbmNlO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBwcm9jZXNzRGlzcGF0Y2hRdWV1ZShkaXNwYXRjaFF1ZXVlLCBldmVudFN5c3RlbUZsYWdzKSB7XG4gIHZhciBpbkNhcHR1cmVQaGFzZSA9IChldmVudFN5c3RlbUZsYWdzICYgSVNfQ0FQVFVSRV9QSEFTRSkgIT09IDA7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBkaXNwYXRjaFF1ZXVlLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIF9kaXNwYXRjaFF1ZXVlJGkgPSBkaXNwYXRjaFF1ZXVlW2ldLFxuICAgICAgICBldmVudCA9IF9kaXNwYXRjaFF1ZXVlJGkuZXZlbnQsXG4gICAgICAgIGxpc3RlbmVycyA9IF9kaXNwYXRjaFF1ZXVlJGkubGlzdGVuZXJzO1xuICAgIHByb2Nlc3NEaXNwYXRjaFF1ZXVlSXRlbXNJbk9yZGVyKGV2ZW50LCBsaXN0ZW5lcnMsIGluQ2FwdHVyZVBoYXNlKTsgLy8gIGV2ZW50IHN5c3RlbSBkb2Vzbid0IHVzZSBwb29saW5nLlxuICB9IC8vIFRoaXMgd291bGQgYmUgYSBnb29kIHRpbWUgdG8gcmV0aHJvdyBpZiBhbnkgb2YgdGhlIGV2ZW50IGhhbmRsZXJzIHRocmV3LlxuXG5cbiAgcmV0aHJvd0NhdWdodEVycm9yKCk7XG59XG5cbmZ1bmN0aW9uIGRpc3BhdGNoRXZlbnRzRm9yUGx1Z2lucyhkb21FdmVudE5hbWUsIGV2ZW50U3lzdGVtRmxhZ3MsIG5hdGl2ZUV2ZW50LCB0YXJnZXRJbnN0LCB0YXJnZXRDb250YWluZXIpIHtcbiAgdmFyIG5hdGl2ZUV2ZW50VGFyZ2V0ID0gZ2V0RXZlbnRUYXJnZXQobmF0aXZlRXZlbnQpO1xuICB2YXIgZGlzcGF0Y2hRdWV1ZSA9IFtdO1xuICBleHRyYWN0RXZlbnRzJDUoZGlzcGF0Y2hRdWV1ZSwgZG9tRXZlbnROYW1lLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQsIGV2ZW50U3lzdGVtRmxhZ3MpO1xuICBwcm9jZXNzRGlzcGF0Y2hRdWV1ZShkaXNwYXRjaFF1ZXVlLCBldmVudFN5c3RlbUZsYWdzKTtcbn1cblxuZnVuY3Rpb24gbGlzdGVuVG9Ob25EZWxlZ2F0ZWRFdmVudChkb21FdmVudE5hbWUsIHRhcmdldEVsZW1lbnQpIHtcbiAgdmFyIGlzQ2FwdHVyZVBoYXNlTGlzdGVuZXIgPSBmYWxzZTtcbiAgdmFyIGxpc3RlbmVyU2V0ID0gZ2V0RXZlbnRMaXN0ZW5lclNldCh0YXJnZXRFbGVtZW50KTtcbiAgdmFyIGxpc3RlbmVyU2V0S2V5ID0gZ2V0TGlzdGVuZXJTZXRLZXkoZG9tRXZlbnROYW1lLCBpc0NhcHR1cmVQaGFzZUxpc3RlbmVyKTtcblxuICBpZiAoIWxpc3RlbmVyU2V0LmhhcyhsaXN0ZW5lclNldEtleSkpIHtcbiAgICBhZGRUcmFwcGVkRXZlbnRMaXN0ZW5lcih0YXJnZXRFbGVtZW50LCBkb21FdmVudE5hbWUsIElTX05PTl9ERUxFR0FURUQsIGlzQ2FwdHVyZVBoYXNlTGlzdGVuZXIpO1xuICAgIGxpc3RlbmVyU2V0LmFkZChsaXN0ZW5lclNldEtleSk7XG4gIH1cbn1cbnZhciBsaXN0ZW5pbmdNYXJrZXIgPSAnX3JlYWN0TGlzdGVuaW5nJyArIE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnNsaWNlKDIpO1xuZnVuY3Rpb24gbGlzdGVuVG9BbGxTdXBwb3J0ZWRFdmVudHMocm9vdENvbnRhaW5lckVsZW1lbnQpIHtcbiAge1xuICAgIGlmIChyb290Q29udGFpbmVyRWxlbWVudFtsaXN0ZW5pbmdNYXJrZXJdKSB7XG4gICAgICAvLyBQZXJmb3JtYW5jZSBvcHRpbWl6YXRpb246IGRvbid0IGl0ZXJhdGUgdGhyb3VnaCBldmVudHNcbiAgICAgIC8vIGZvciB0aGUgc2FtZSBwb3J0YWwgY29udGFpbmVyIG9yIHJvb3Qgbm9kZSBtb3JlIHRoYW4gb25jZS5cbiAgICAgIC8vIFRPRE86IG9uY2Ugd2UgcmVtb3ZlIHRoZSBmbGFnLCB3ZSBtYXkgYmUgYWJsZSB0byBhbHNvXG4gICAgICAvLyByZW1vdmUgc29tZSBvZiB0aGUgYm9va2tlZXBpbmcgbWFwcyB1c2VkIGZvciBsYXppbmVzcy5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICByb290Q29udGFpbmVyRWxlbWVudFtsaXN0ZW5pbmdNYXJrZXJdID0gdHJ1ZTtcbiAgICBhbGxOYXRpdmVFdmVudHMuZm9yRWFjaChmdW5jdGlvbiAoZG9tRXZlbnROYW1lKSB7XG4gICAgICBpZiAoIW5vbkRlbGVnYXRlZEV2ZW50cy5oYXMoZG9tRXZlbnROYW1lKSkge1xuICAgICAgICBsaXN0ZW5Ub05hdGl2ZUV2ZW50KGRvbUV2ZW50TmFtZSwgZmFsc2UsIHJvb3RDb250YWluZXJFbGVtZW50LCBudWxsKTtcbiAgICAgIH1cblxuICAgICAgbGlzdGVuVG9OYXRpdmVFdmVudChkb21FdmVudE5hbWUsIHRydWUsIHJvb3RDb250YWluZXJFbGVtZW50LCBudWxsKTtcbiAgICB9KTtcbiAgfVxufVxuZnVuY3Rpb24gbGlzdGVuVG9OYXRpdmVFdmVudChkb21FdmVudE5hbWUsIGlzQ2FwdHVyZVBoYXNlTGlzdGVuZXIsIHJvb3RDb250YWluZXJFbGVtZW50LCB0YXJnZXRFbGVtZW50KSB7XG4gIHZhciBldmVudFN5c3RlbUZsYWdzID0gYXJndW1lbnRzLmxlbmd0aCA+IDQgJiYgYXJndW1lbnRzWzRdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNF0gOiAwO1xuICB2YXIgdGFyZ2V0ID0gcm9vdENvbnRhaW5lckVsZW1lbnQ7IC8vIHNlbGVjdGlvbmNoYW5nZSBuZWVkcyB0byBiZSBhdHRhY2hlZCB0byB0aGUgZG9jdW1lbnRcbiAgLy8gb3RoZXJ3aXNlIGl0IHdvbid0IGNhcHR1cmUgaW5jb21pbmcgZXZlbnRzIHRoYXQgYXJlIG9ubHlcbiAgLy8gdHJpZ2dlcmVkIG9uIHRoZSBkb2N1bWVudCBkaXJlY3RseS5cblxuICBpZiAoZG9tRXZlbnROYW1lID09PSAnc2VsZWN0aW9uY2hhbmdlJyAmJiByb290Q29udGFpbmVyRWxlbWVudC5ub2RlVHlwZSAhPT0gRE9DVU1FTlRfTk9ERSkge1xuICAgIHRhcmdldCA9IHJvb3RDb250YWluZXJFbGVtZW50Lm93bmVyRG9jdW1lbnQ7XG4gIH0gLy8gSWYgdGhlIGV2ZW50IGNhbiBiZSBkZWxlZ2F0ZWQgKG9yIGlzIGNhcHR1cmUgcGhhc2UpLCB3ZSBjYW5cbiAgLy8gcmVnaXN0ZXIgaXQgdG8gdGhlIHJvb3QgY29udGFpbmVyLiBPdGhlcndpc2UsIHdlIHNob3VsZFxuICAvLyByZWdpc3RlciB0aGUgZXZlbnQgdG8gdGhlIHRhcmdldCBlbGVtZW50IGFuZCBtYXJrIGl0IGFzXG4gIC8vIGEgbm9uLWRlbGVnYXRlZCBldmVudC5cblxuXG4gIGlmICh0YXJnZXRFbGVtZW50ICE9PSBudWxsICYmICFpc0NhcHR1cmVQaGFzZUxpc3RlbmVyICYmIG5vbkRlbGVnYXRlZEV2ZW50cy5oYXMoZG9tRXZlbnROYW1lKSkge1xuICAgIC8vIEZvciBhbGwgbm9uLWRlbGVnYXRlZCBldmVudHMsIGFwYXJ0IGZyb20gc2Nyb2xsLCB3ZSBhdHRhY2hcbiAgICAvLyB0aGVpciBldmVudCBsaXN0ZW5lcnMgdG8gdGhlIHJlc3BlY3RpdmUgZWxlbWVudHMgdGhhdCB0aGVpclxuICAgIC8vIGV2ZW50cyBmaXJlIG9uLiBUaGF0IG1lYW5zIHdlIGNhbiBza2lwIHRoaXMgc3RlcCwgYXMgZXZlbnRcbiAgICAvLyBsaXN0ZW5lciBoYXMgYWxyZWFkeSBiZWVuIGFkZGVkIHByZXZpb3VzbHkuIEhvd2V2ZXIsIHdlXG4gICAgLy8gc3BlY2lhbCBjYXNlIHRoZSBzY3JvbGwgZXZlbnQgYmVjYXVzZSB0aGUgcmVhbGl0eSBpcyB0aGF0IGFueVxuICAgIC8vIGVsZW1lbnQgY2FuIHNjcm9sbC5cbiAgICAvLyBUT0RPOiBpZGVhbGx5LCB3ZSdkIGV2ZW50dWFsbHkgYXBwbHkgdGhlIHNhbWUgbG9naWMgdG8gYWxsXG4gICAgLy8gZXZlbnRzIGZyb20gdGhlIG5vbkRlbGVnYXRlZEV2ZW50cyBsaXN0LiBUaGVuIHdlIGNhbiByZW1vdmVcbiAgICAvLyB0aGlzIHNwZWNpYWwgY2FzZSBhbmQgdXNlIHRoZSBzYW1lIGxvZ2ljIGZvciBhbGwgZXZlbnRzLlxuICAgIGlmIChkb21FdmVudE5hbWUgIT09ICdzY3JvbGwnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZXZlbnRTeXN0ZW1GbGFncyB8PSBJU19OT05fREVMRUdBVEVEO1xuICAgIHRhcmdldCA9IHRhcmdldEVsZW1lbnQ7XG4gIH1cblxuICB2YXIgbGlzdGVuZXJTZXQgPSBnZXRFdmVudExpc3RlbmVyU2V0KHRhcmdldCk7XG4gIHZhciBsaXN0ZW5lclNldEtleSA9IGdldExpc3RlbmVyU2V0S2V5KGRvbUV2ZW50TmFtZSwgaXNDYXB0dXJlUGhhc2VMaXN0ZW5lcik7IC8vIElmIHRoZSBsaXN0ZW5lciBlbnRyeSBpcyBlbXB0eSBvciB3ZSBzaG91bGQgdXBncmFkZSwgdGhlblxuICAvLyB3ZSBuZWVkIHRvIHRyYXAgYW4gZXZlbnQgbGlzdGVuZXIgb250byB0aGUgdGFyZ2V0LlxuXG4gIGlmICghbGlzdGVuZXJTZXQuaGFzKGxpc3RlbmVyU2V0S2V5KSkge1xuICAgIGlmIChpc0NhcHR1cmVQaGFzZUxpc3RlbmVyKSB7XG4gICAgICBldmVudFN5c3RlbUZsYWdzIHw9IElTX0NBUFRVUkVfUEhBU0U7XG4gICAgfVxuXG4gICAgYWRkVHJhcHBlZEV2ZW50TGlzdGVuZXIodGFyZ2V0LCBkb21FdmVudE5hbWUsIGV2ZW50U3lzdGVtRmxhZ3MsIGlzQ2FwdHVyZVBoYXNlTGlzdGVuZXIpO1xuICAgIGxpc3RlbmVyU2V0LmFkZChsaXN0ZW5lclNldEtleSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gYWRkVHJhcHBlZEV2ZW50TGlzdGVuZXIodGFyZ2V0Q29udGFpbmVyLCBkb21FdmVudE5hbWUsIGV2ZW50U3lzdGVtRmxhZ3MsIGlzQ2FwdHVyZVBoYXNlTGlzdGVuZXIsIGlzRGVmZXJyZWRMaXN0ZW5lckZvckxlZ2FjeUZCU3VwcG9ydCkge1xuICB2YXIgbGlzdGVuZXIgPSBjcmVhdGVFdmVudExpc3RlbmVyV3JhcHBlcldpdGhQcmlvcml0eSh0YXJnZXRDb250YWluZXIsIGRvbUV2ZW50TmFtZSwgZXZlbnRTeXN0ZW1GbGFncyk7IC8vIElmIHBhc3NpdmUgb3B0aW9uIGlzIG5vdCBzdXBwb3J0ZWQsIHRoZW4gdGhlIGV2ZW50IHdpbGwgYmVcbiAgLy8gYWN0aXZlIGFuZCBub3QgcGFzc2l2ZS5cblxuICB2YXIgaXNQYXNzaXZlTGlzdGVuZXIgPSB1bmRlZmluZWQ7XG5cbiAgaWYgKHBhc3NpdmVCcm93c2VyRXZlbnRzU3VwcG9ydGVkKSB7XG4gICAgLy8gQnJvd3NlcnMgaW50cm9kdWNlZCBhbiBpbnRlcnZlbnRpb24sIG1ha2luZyB0aGVzZSBldmVudHNcbiAgICAvLyBwYXNzaXZlIGJ5IGRlZmF1bHQgb24gZG9jdW1lbnQuIFJlYWN0IGRvZXNuJ3QgYmluZCB0aGVtXG4gICAgLy8gdG8gZG9jdW1lbnQgYW55bW9yZSwgYnV0IGNoYW5naW5nIHRoaXMgbm93IHdvdWxkIHVuZG9cbiAgICAvLyB0aGUgcGVyZm9ybWFuY2Ugd2lucyBmcm9tIHRoZSBjaGFuZ2UuIFNvIHdlIGVtdWxhdGVcbiAgICAvLyB0aGUgZXhpc3RpbmcgYmVoYXZpb3IgbWFudWFsbHkgb24gdGhlIHJvb3RzIG5vdy5cbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzE5NjUxXG4gICAgaWYgKGRvbUV2ZW50TmFtZSA9PT0gJ3RvdWNoc3RhcnQnIHx8IGRvbUV2ZW50TmFtZSA9PT0gJ3RvdWNobW92ZScgfHwgZG9tRXZlbnROYW1lID09PSAnd2hlZWwnKSB7XG4gICAgICBpc1Bhc3NpdmVMaXN0ZW5lciA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgdGFyZ2V0Q29udGFpbmVyID0gIHRhcmdldENvbnRhaW5lcjtcbiAgdmFyIHVuc3Vic2NyaWJlTGlzdGVuZXI7IC8vIFdoZW4gbGVnYWN5RkJTdXBwb3J0IGlzIGVuYWJsZWQsIGl0J3MgZm9yIHdoZW4gd2VcblxuXG4gIGlmIChpc0NhcHR1cmVQaGFzZUxpc3RlbmVyKSB7XG4gICAgaWYgKGlzUGFzc2l2ZUxpc3RlbmVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHVuc3Vic2NyaWJlTGlzdGVuZXIgPSBhZGRFdmVudENhcHR1cmVMaXN0ZW5lcldpdGhQYXNzaXZlRmxhZyh0YXJnZXRDb250YWluZXIsIGRvbUV2ZW50TmFtZSwgbGlzdGVuZXIsIGlzUGFzc2l2ZUxpc3RlbmVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdW5zdWJzY3JpYmVMaXN0ZW5lciA9IGFkZEV2ZW50Q2FwdHVyZUxpc3RlbmVyKHRhcmdldENvbnRhaW5lciwgZG9tRXZlbnROYW1lLCBsaXN0ZW5lcik7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChpc1Bhc3NpdmVMaXN0ZW5lciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB1bnN1YnNjcmliZUxpc3RlbmVyID0gYWRkRXZlbnRCdWJibGVMaXN0ZW5lcldpdGhQYXNzaXZlRmxhZyh0YXJnZXRDb250YWluZXIsIGRvbUV2ZW50TmFtZSwgbGlzdGVuZXIsIGlzUGFzc2l2ZUxpc3RlbmVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdW5zdWJzY3JpYmVMaXN0ZW5lciA9IGFkZEV2ZW50QnViYmxlTGlzdGVuZXIodGFyZ2V0Q29udGFpbmVyLCBkb21FdmVudE5hbWUsIGxpc3RlbmVyKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNNYXRjaGluZ1Jvb3RDb250YWluZXIoZ3JhbmRDb250YWluZXIsIHRhcmdldENvbnRhaW5lcikge1xuICByZXR1cm4gZ3JhbmRDb250YWluZXIgPT09IHRhcmdldENvbnRhaW5lciB8fCBncmFuZENvbnRhaW5lci5ub2RlVHlwZSA9PT0gQ09NTUVOVF9OT0RFICYmIGdyYW5kQ29udGFpbmVyLnBhcmVudE5vZGUgPT09IHRhcmdldENvbnRhaW5lcjtcbn1cblxuZnVuY3Rpb24gZGlzcGF0Y2hFdmVudEZvclBsdWdpbkV2ZW50U3lzdGVtKGRvbUV2ZW50TmFtZSwgZXZlbnRTeXN0ZW1GbGFncywgbmF0aXZlRXZlbnQsIHRhcmdldEluc3QsIHRhcmdldENvbnRhaW5lcikge1xuICB2YXIgYW5jZXN0b3JJbnN0ID0gdGFyZ2V0SW5zdDtcblxuICBpZiAoKGV2ZW50U3lzdGVtRmxhZ3MgJiBJU19FVkVOVF9IQU5ETEVfTk9OX01BTkFHRURfTk9ERSkgPT09IDAgJiYgKGV2ZW50U3lzdGVtRmxhZ3MgJiBJU19OT05fREVMRUdBVEVEKSA9PT0gMCkge1xuICAgIHZhciB0YXJnZXRDb250YWluZXJOb2RlID0gdGFyZ2V0Q29udGFpbmVyOyAvLyBJZiB3ZSBhcmUgdXNpbmcgdGhlIGxlZ2FjeSBGQiBzdXBwb3J0IGZsYWcsIHdlXG5cbiAgICBpZiAodGFyZ2V0SW5zdCAhPT0gbnVsbCkge1xuICAgICAgLy8gVGhlIGJlbG93IGxvZ2ljIGF0dGVtcHRzIHRvIHdvcmsgb3V0IGlmIHdlIG5lZWQgdG8gY2hhbmdlXG4gICAgICAvLyB0aGUgdGFyZ2V0IGZpYmVyIHRvIGEgZGlmZmVyZW50IGFuY2VzdG9yLiBXZSBoYWQgc2ltaWxhciBsb2dpY1xuICAgICAgLy8gaW4gdGhlIGxlZ2FjeSBldmVudCBzeXN0ZW0sIGV4Y2VwdCB0aGUgYmlnIGRpZmZlcmVuY2UgYmV0d2VlblxuICAgICAgLy8gc3lzdGVtcyBpcyB0aGF0IHRoZSBtb2Rlcm4gZXZlbnQgc3lzdGVtIG5vdyBoYXMgYW4gZXZlbnQgbGlzdGVuZXJcbiAgICAgIC8vIGF0dGFjaGVkIHRvIGVhY2ggUmVhY3QgUm9vdCBhbmQgUmVhY3QgUG9ydGFsIFJvb3QuIFRvZ2V0aGVyLFxuICAgICAgLy8gdGhlIERPTSBub2RlcyByZXByZXNlbnRpbmcgdGhlc2Ugcm9vdHMgYXJlIHRoZSBcInJvb3RDb250YWluZXJcIi5cbiAgICAgIC8vIFRvIGZpZ3VyZSBvdXQgd2hpY2ggYW5jZXN0b3IgaW5zdGFuY2Ugd2Ugc2hvdWxkIHVzZSwgd2UgdHJhdmVyc2VcbiAgICAgIC8vIHVwIHRoZSBmaWJlciB0cmVlIGZyb20gdGhlIHRhcmdldCBpbnN0YW5jZSBhbmQgYXR0ZW1wdCB0byBmaW5kXG4gICAgICAvLyByb290IGJvdW5kYXJpZXMgdGhhdCBtYXRjaCB0aGF0IG9mIG91ciBjdXJyZW50IFwicm9vdENvbnRhaW5lclwiLlxuICAgICAgLy8gSWYgd2UgZmluZCB0aGF0IFwicm9vdENvbnRhaW5lclwiLCB3ZSBmaW5kIHRoZSBwYXJlbnQgZmliZXJcbiAgICAgIC8vIHN1Yi10cmVlIGZvciB0aGF0IHJvb3QgYW5kIG1ha2UgdGhhdCBvdXIgYW5jZXN0b3IgaW5zdGFuY2UuXG4gICAgICB2YXIgbm9kZSA9IHRhcmdldEluc3Q7XG5cbiAgICAgIG1haW5Mb29wOiB3aGlsZSAodHJ1ZSkge1xuICAgICAgICBpZiAobm9kZSA9PT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBub2RlVGFnID0gbm9kZS50YWc7XG5cbiAgICAgICAgaWYgKG5vZGVUYWcgPT09IEhvc3RSb290IHx8IG5vZGVUYWcgPT09IEhvc3RQb3J0YWwpIHtcbiAgICAgICAgICB2YXIgY29udGFpbmVyID0gbm9kZS5zdGF0ZU5vZGUuY29udGFpbmVySW5mbztcblxuICAgICAgICAgIGlmIChpc01hdGNoaW5nUm9vdENvbnRhaW5lcihjb250YWluZXIsIHRhcmdldENvbnRhaW5lck5vZGUpKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAobm9kZVRhZyA9PT0gSG9zdFBvcnRhbCkge1xuICAgICAgICAgICAgLy8gVGhlIHRhcmdldCBpcyBhIHBvcnRhbCwgYnV0IGl0J3Mgbm90IHRoZSByb290Q29udGFpbmVyIHdlJ3JlIGxvb2tpbmcgZm9yLlxuICAgICAgICAgICAgLy8gTm9ybWFsbHkgcG9ydGFscyBoYW5kbGUgdGhlaXIgb3duIGV2ZW50cyBhbGwgdGhlIHdheSBkb3duIHRvIHRoZSByb290LlxuICAgICAgICAgICAgLy8gU28gd2Ugc2hvdWxkIGJlIGFibGUgdG8gc3RvcCBub3cuIEhvd2V2ZXIsIHdlIGRvbid0IGtub3cgaWYgdGhpcyBwb3J0YWxcbiAgICAgICAgICAgIC8vIHdhcyBwYXJ0IG9mICpvdXIqIHJvb3QuXG4gICAgICAgICAgICB2YXIgZ3JhbmROb2RlID0gbm9kZS5yZXR1cm47XG5cbiAgICAgICAgICAgIHdoaWxlIChncmFuZE5vZGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgdmFyIGdyYW5kVGFnID0gZ3JhbmROb2RlLnRhZztcblxuICAgICAgICAgICAgICBpZiAoZ3JhbmRUYWcgPT09IEhvc3RSb290IHx8IGdyYW5kVGFnID09PSBIb3N0UG9ydGFsKSB7XG4gICAgICAgICAgICAgICAgdmFyIGdyYW5kQ29udGFpbmVyID0gZ3JhbmROb2RlLnN0YXRlTm9kZS5jb250YWluZXJJbmZvO1xuXG4gICAgICAgICAgICAgICAgaWYgKGlzTWF0Y2hpbmdSb290Q29udGFpbmVyKGdyYW5kQ29udGFpbmVyLCB0YXJnZXRDb250YWluZXJOb2RlKSkge1xuICAgICAgICAgICAgICAgICAgLy8gVGhpcyBpcyB0aGUgcm9vdENvbnRhaW5lciB3ZSdyZSBsb29raW5nIGZvciBhbmQgd2UgZm91bmQgaXQgYXNcbiAgICAgICAgICAgICAgICAgIC8vIGEgcGFyZW50IG9mIHRoZSBQb3J0YWwuIFRoYXQgbWVhbnMgd2UgY2FuIGlnbm9yZSBpdCBiZWNhdXNlIHRoZVxuICAgICAgICAgICAgICAgICAgLy8gUG9ydGFsIHdpbGwgYnViYmxlIHRocm91Z2ggdG8gdXMuXG4gICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgZ3JhbmROb2RlID0gZ3JhbmROb2RlLnJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IC8vIE5vdyB3ZSBuZWVkIHRvIGZpbmQgaXQncyBjb3JyZXNwb25kaW5nIGhvc3QgZmliZXIgaW4gdGhlIG90aGVyXG4gICAgICAgICAgLy8gdHJlZS4gVG8gZG8gdGhpcyB3ZSBjYW4gdXNlIGdldENsb3Nlc3RJbnN0YW5jZUZyb21Ob2RlLCBidXQgd2VcbiAgICAgICAgICAvLyBuZWVkIHRvIHZhbGlkYXRlIHRoYXQgdGhlIGZpYmVyIGlzIGEgaG9zdCBpbnN0YW5jZSwgb3RoZXJ3aXNlXG4gICAgICAgICAgLy8gd2UgbmVlZCB0byB0cmF2ZXJzZSB1cCB0aHJvdWdoIHRoZSBET00gdGlsbCB3ZSBmaW5kIHRoZSBjb3JyZWN0XG4gICAgICAgICAgLy8gbm9kZSB0aGF0IGlzIGZyb20gdGhlIG90aGVyIHRyZWUuXG5cblxuICAgICAgICAgIHdoaWxlIChjb250YWluZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHZhciBwYXJlbnROb2RlID0gZ2V0Q2xvc2VzdEluc3RhbmNlRnJvbU5vZGUoY29udGFpbmVyKTtcblxuICAgICAgICAgICAgaWYgKHBhcmVudE5vZGUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgcGFyZW50VGFnID0gcGFyZW50Tm9kZS50YWc7XG5cbiAgICAgICAgICAgIGlmIChwYXJlbnRUYWcgPT09IEhvc3RDb21wb25lbnQgfHwgcGFyZW50VGFnID09PSBIb3N0VGV4dCkge1xuICAgICAgICAgICAgICBub2RlID0gYW5jZXN0b3JJbnN0ID0gcGFyZW50Tm9kZTtcbiAgICAgICAgICAgICAgY29udGludWUgbWFpbkxvb3A7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnRhaW5lciA9IGNvbnRhaW5lci5wYXJlbnROb2RlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIG5vZGUgPSBub2RlLnJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBiYXRjaGVkRXZlbnRVcGRhdGVzKGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZGlzcGF0Y2hFdmVudHNGb3JQbHVnaW5zKGRvbUV2ZW50TmFtZSwgZXZlbnRTeXN0ZW1GbGFncywgbmF0aXZlRXZlbnQsIGFuY2VzdG9ySW5zdCk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVEaXNwYXRjaExpc3RlbmVyKGluc3RhbmNlLCBsaXN0ZW5lciwgY3VycmVudFRhcmdldCkge1xuICByZXR1cm4ge1xuICAgIGluc3RhbmNlOiBpbnN0YW5jZSxcbiAgICBsaXN0ZW5lcjogbGlzdGVuZXIsXG4gICAgY3VycmVudFRhcmdldDogY3VycmVudFRhcmdldFxuICB9O1xufVxuXG5mdW5jdGlvbiBhY2N1bXVsYXRlU2luZ2xlUGhhc2VMaXN0ZW5lcnModGFyZ2V0RmliZXIsIHJlYWN0TmFtZSwgbmF0aXZlRXZlbnRUeXBlLCBpbkNhcHR1cmVQaGFzZSwgYWNjdW11bGF0ZVRhcmdldE9ubHkpIHtcbiAgdmFyIGNhcHR1cmVOYW1lID0gcmVhY3ROYW1lICE9PSBudWxsID8gcmVhY3ROYW1lICsgJ0NhcHR1cmUnIDogbnVsbDtcbiAgdmFyIHJlYWN0RXZlbnROYW1lID0gaW5DYXB0dXJlUGhhc2UgPyBjYXB0dXJlTmFtZSA6IHJlYWN0TmFtZTtcbiAgdmFyIGxpc3RlbmVycyA9IFtdO1xuICB2YXIgaW5zdGFuY2UgPSB0YXJnZXRGaWJlcjtcbiAgdmFyIGxhc3RIb3N0Q29tcG9uZW50ID0gbnVsbDsgLy8gQWNjdW11bGF0ZSBhbGwgaW5zdGFuY2VzIGFuZCBsaXN0ZW5lcnMgdmlhIHRoZSB0YXJnZXQgLT4gcm9vdCBwYXRoLlxuXG4gIHdoaWxlIChpbnN0YW5jZSAhPT0gbnVsbCkge1xuICAgIHZhciBfaW5zdGFuY2UyID0gaW5zdGFuY2UsXG4gICAgICAgIHN0YXRlTm9kZSA9IF9pbnN0YW5jZTIuc3RhdGVOb2RlLFxuICAgICAgICB0YWcgPSBfaW5zdGFuY2UyLnRhZzsgLy8gSGFuZGxlIGxpc3RlbmVycyB0aGF0IGFyZSBvbiBIb3N0Q29tcG9uZW50cyAoaS5lLiA8ZGl2PilcblxuICAgIGlmICh0YWcgPT09IEhvc3RDb21wb25lbnQgJiYgc3RhdGVOb2RlICE9PSBudWxsKSB7XG4gICAgICBsYXN0SG9zdENvbXBvbmVudCA9IHN0YXRlTm9kZTsgLy8gY3JlYXRlRXZlbnRIYW5kbGUgbGlzdGVuZXJzXG5cblxuICAgICAgaWYgKHJlYWN0RXZlbnROYW1lICE9PSBudWxsKSB7XG4gICAgICAgIHZhciBsaXN0ZW5lciA9IGdldExpc3RlbmVyKGluc3RhbmNlLCByZWFjdEV2ZW50TmFtZSk7XG5cbiAgICAgICAgaWYgKGxpc3RlbmVyICE9IG51bGwpIHtcbiAgICAgICAgICBsaXN0ZW5lcnMucHVzaChjcmVhdGVEaXNwYXRjaExpc3RlbmVyKGluc3RhbmNlLCBsaXN0ZW5lciwgbGFzdEhvc3RDb21wb25lbnQpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gLy8gSWYgd2UgYXJlIG9ubHkgYWNjdW11bGF0aW5nIGV2ZW50cyBmb3IgdGhlIHRhcmdldCwgdGhlbiB3ZSBkb24ndFxuICAgIC8vIGNvbnRpbnVlIHRvIHByb3BhZ2F0ZSB0aHJvdWdoIHRoZSBSZWFjdCBmaWJlciB0cmVlIHRvIGZpbmQgb3RoZXJcbiAgICAvLyBsaXN0ZW5lcnMuXG5cblxuICAgIGlmIChhY2N1bXVsYXRlVGFyZ2V0T25seSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgaW5zdGFuY2UgPSBpbnN0YW5jZS5yZXR1cm47XG4gIH1cblxuICByZXR1cm4gbGlzdGVuZXJzO1xufSAvLyBXZSBzaG91bGQgb25seSB1c2UgdGhpcyBmdW5jdGlvbiBmb3I6XG4vLyAtIEJlZm9yZUlucHV0RXZlbnRQbHVnaW5cbi8vIC0gQ2hhbmdlRXZlbnRQbHVnaW5cbi8vIC0gU2VsZWN0RXZlbnRQbHVnaW5cbi8vIFRoaXMgaXMgYmVjYXVzZSB3ZSBvbmx5IHByb2Nlc3MgdGhlc2UgcGx1Z2luc1xuLy8gaW4gdGhlIGJ1YmJsZSBwaGFzZSwgc28gd2UgbmVlZCB0byBhY2N1bXVsYXRlIHR3b1xuLy8gcGhhc2UgZXZlbnQgbGlzdGVuZXJzICh2aWEgZW11bGF0aW9uKS5cblxuZnVuY3Rpb24gYWNjdW11bGF0ZVR3b1BoYXNlTGlzdGVuZXJzKHRhcmdldEZpYmVyLCByZWFjdE5hbWUpIHtcbiAgdmFyIGNhcHR1cmVOYW1lID0gcmVhY3ROYW1lICsgJ0NhcHR1cmUnO1xuICB2YXIgbGlzdGVuZXJzID0gW107XG4gIHZhciBpbnN0YW5jZSA9IHRhcmdldEZpYmVyOyAvLyBBY2N1bXVsYXRlIGFsbCBpbnN0YW5jZXMgYW5kIGxpc3RlbmVycyB2aWEgdGhlIHRhcmdldCAtPiByb290IHBhdGguXG5cbiAgd2hpbGUgKGluc3RhbmNlICE9PSBudWxsKSB7XG4gICAgdmFyIF9pbnN0YW5jZTMgPSBpbnN0YW5jZSxcbiAgICAgICAgc3RhdGVOb2RlID0gX2luc3RhbmNlMy5zdGF0ZU5vZGUsXG4gICAgICAgIHRhZyA9IF9pbnN0YW5jZTMudGFnOyAvLyBIYW5kbGUgbGlzdGVuZXJzIHRoYXQgYXJlIG9uIEhvc3RDb21wb25lbnRzIChpLmUuIDxkaXY+KVxuXG4gICAgaWYgKHRhZyA9PT0gSG9zdENvbXBvbmVudCAmJiBzdGF0ZU5vZGUgIT09IG51bGwpIHtcbiAgICAgIHZhciBjdXJyZW50VGFyZ2V0ID0gc3RhdGVOb2RlO1xuICAgICAgdmFyIGNhcHR1cmVMaXN0ZW5lciA9IGdldExpc3RlbmVyKGluc3RhbmNlLCBjYXB0dXJlTmFtZSk7XG5cbiAgICAgIGlmIChjYXB0dXJlTGlzdGVuZXIgIT0gbnVsbCkge1xuICAgICAgICBsaXN0ZW5lcnMudW5zaGlmdChjcmVhdGVEaXNwYXRjaExpc3RlbmVyKGluc3RhbmNlLCBjYXB0dXJlTGlzdGVuZXIsIGN1cnJlbnRUYXJnZXQpKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGJ1YmJsZUxpc3RlbmVyID0gZ2V0TGlzdGVuZXIoaW5zdGFuY2UsIHJlYWN0TmFtZSk7XG5cbiAgICAgIGlmIChidWJibGVMaXN0ZW5lciAhPSBudWxsKSB7XG4gICAgICAgIGxpc3RlbmVycy5wdXNoKGNyZWF0ZURpc3BhdGNoTGlzdGVuZXIoaW5zdGFuY2UsIGJ1YmJsZUxpc3RlbmVyLCBjdXJyZW50VGFyZ2V0KSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaW5zdGFuY2UgPSBpbnN0YW5jZS5yZXR1cm47XG4gIH1cblxuICByZXR1cm4gbGlzdGVuZXJzO1xufVxuXG5mdW5jdGlvbiBnZXRQYXJlbnQoaW5zdCkge1xuICBpZiAoaW5zdCA9PT0gbnVsbCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgZG8ge1xuICAgIGluc3QgPSBpbnN0LnJldHVybjsgLy8gVE9ETzogSWYgdGhpcyBpcyBhIEhvc3RSb290IHdlIG1pZ2h0IHdhbnQgdG8gYmFpbCBvdXQuXG4gICAgLy8gVGhhdCBpcyBkZXBlbmRpbmcgb24gaWYgd2Ugd2FudCBuZXN0ZWQgc3VidHJlZXMgKGxheWVycykgdG8gYnViYmxlXG4gICAgLy8gZXZlbnRzIHRvIHRoZWlyIHBhcmVudC4gV2UgY291bGQgYWxzbyBnbyB0aHJvdWdoIHBhcmVudE5vZGUgb24gdGhlXG4gICAgLy8gaG9zdCBub2RlIGJ1dCB0aGF0IHdvdWxkbid0IHdvcmsgZm9yIFJlYWN0IE5hdGl2ZSBhbmQgZG9lc24ndCBsZXQgdXNcbiAgICAvLyBkbyB0aGUgcG9ydGFsIGZlYXR1cmUuXG4gIH0gd2hpbGUgKGluc3QgJiYgaW5zdC50YWcgIT09IEhvc3RDb21wb25lbnQpO1xuXG4gIGlmIChpbnN0KSB7XG4gICAgcmV0dXJuIGluc3Q7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cbi8qKlxuICogUmV0dXJuIHRoZSBsb3dlc3QgY29tbW9uIGFuY2VzdG9yIG9mIEEgYW5kIEIsIG9yIG51bGwgaWYgdGhleSBhcmUgaW5cbiAqIGRpZmZlcmVudCB0cmVlcy5cbiAqL1xuXG5cbmZ1bmN0aW9uIGdldExvd2VzdENvbW1vbkFuY2VzdG9yKGluc3RBLCBpbnN0Qikge1xuICB2YXIgbm9kZUEgPSBpbnN0QTtcbiAgdmFyIG5vZGVCID0gaW5zdEI7XG4gIHZhciBkZXB0aEEgPSAwO1xuXG4gIGZvciAodmFyIHRlbXBBID0gbm9kZUE7IHRlbXBBOyB0ZW1wQSA9IGdldFBhcmVudCh0ZW1wQSkpIHtcbiAgICBkZXB0aEErKztcbiAgfVxuXG4gIHZhciBkZXB0aEIgPSAwO1xuXG4gIGZvciAodmFyIHRlbXBCID0gbm9kZUI7IHRlbXBCOyB0ZW1wQiA9IGdldFBhcmVudCh0ZW1wQikpIHtcbiAgICBkZXB0aEIrKztcbiAgfSAvLyBJZiBBIGlzIGRlZXBlciwgY3Jhd2wgdXAuXG5cblxuICB3aGlsZSAoZGVwdGhBIC0gZGVwdGhCID4gMCkge1xuICAgIG5vZGVBID0gZ2V0UGFyZW50KG5vZGVBKTtcbiAgICBkZXB0aEEtLTtcbiAgfSAvLyBJZiBCIGlzIGRlZXBlciwgY3Jhd2wgdXAuXG5cblxuICB3aGlsZSAoZGVwdGhCIC0gZGVwdGhBID4gMCkge1xuICAgIG5vZGVCID0gZ2V0UGFyZW50KG5vZGVCKTtcbiAgICBkZXB0aEItLTtcbiAgfSAvLyBXYWxrIGluIGxvY2tzdGVwIHVudGlsIHdlIGZpbmQgYSBtYXRjaC5cblxuXG4gIHZhciBkZXB0aCA9IGRlcHRoQTtcblxuICB3aGlsZSAoZGVwdGgtLSkge1xuICAgIGlmIChub2RlQSA9PT0gbm9kZUIgfHwgbm9kZUIgIT09IG51bGwgJiYgbm9kZUEgPT09IG5vZGVCLmFsdGVybmF0ZSkge1xuICAgICAgcmV0dXJuIG5vZGVBO1xuICAgIH1cblxuICAgIG5vZGVBID0gZ2V0UGFyZW50KG5vZGVBKTtcbiAgICBub2RlQiA9IGdldFBhcmVudChub2RlQik7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gYWNjdW11bGF0ZUVudGVyTGVhdmVMaXN0ZW5lcnNGb3JFdmVudChkaXNwYXRjaFF1ZXVlLCBldmVudCwgdGFyZ2V0LCBjb21tb24sIGluQ2FwdHVyZVBoYXNlKSB7XG4gIHZhciByZWdpc3RyYXRpb25OYW1lID0gZXZlbnQuX3JlYWN0TmFtZTtcbiAgdmFyIGxpc3RlbmVycyA9IFtdO1xuICB2YXIgaW5zdGFuY2UgPSB0YXJnZXQ7XG5cbiAgd2hpbGUgKGluc3RhbmNlICE9PSBudWxsKSB7XG4gICAgaWYgKGluc3RhbmNlID09PSBjb21tb24pIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHZhciBfaW5zdGFuY2U0ID0gaW5zdGFuY2UsXG4gICAgICAgIGFsdGVybmF0ZSA9IF9pbnN0YW5jZTQuYWx0ZXJuYXRlLFxuICAgICAgICBzdGF0ZU5vZGUgPSBfaW5zdGFuY2U0LnN0YXRlTm9kZSxcbiAgICAgICAgdGFnID0gX2luc3RhbmNlNC50YWc7XG5cbiAgICBpZiAoYWx0ZXJuYXRlICE9PSBudWxsICYmIGFsdGVybmF0ZSA9PT0gY29tbW9uKSB7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBpZiAodGFnID09PSBIb3N0Q29tcG9uZW50ICYmIHN0YXRlTm9kZSAhPT0gbnVsbCkge1xuICAgICAgdmFyIGN1cnJlbnRUYXJnZXQgPSBzdGF0ZU5vZGU7XG5cbiAgICAgIGlmIChpbkNhcHR1cmVQaGFzZSkge1xuICAgICAgICB2YXIgY2FwdHVyZUxpc3RlbmVyID0gZ2V0TGlzdGVuZXIoaW5zdGFuY2UsIHJlZ2lzdHJhdGlvbk5hbWUpO1xuXG4gICAgICAgIGlmIChjYXB0dXJlTGlzdGVuZXIgIT0gbnVsbCkge1xuICAgICAgICAgIGxpc3RlbmVycy51bnNoaWZ0KGNyZWF0ZURpc3BhdGNoTGlzdGVuZXIoaW5zdGFuY2UsIGNhcHR1cmVMaXN0ZW5lciwgY3VycmVudFRhcmdldCkpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKCFpbkNhcHR1cmVQaGFzZSkge1xuICAgICAgICB2YXIgYnViYmxlTGlzdGVuZXIgPSBnZXRMaXN0ZW5lcihpbnN0YW5jZSwgcmVnaXN0cmF0aW9uTmFtZSk7XG5cbiAgICAgICAgaWYgKGJ1YmJsZUxpc3RlbmVyICE9IG51bGwpIHtcbiAgICAgICAgICBsaXN0ZW5lcnMucHVzaChjcmVhdGVEaXNwYXRjaExpc3RlbmVyKGluc3RhbmNlLCBidWJibGVMaXN0ZW5lciwgY3VycmVudFRhcmdldCkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaW5zdGFuY2UgPSBpbnN0YW5jZS5yZXR1cm47XG4gIH1cblxuICBpZiAobGlzdGVuZXJzLmxlbmd0aCAhPT0gMCkge1xuICAgIGRpc3BhdGNoUXVldWUucHVzaCh7XG4gICAgICBldmVudDogZXZlbnQsXG4gICAgICBsaXN0ZW5lcnM6IGxpc3RlbmVyc1xuICAgIH0pO1xuICB9XG59IC8vIFdlIHNob3VsZCBvbmx5IHVzZSB0aGlzIGZ1bmN0aW9uIGZvcjpcbi8vIC0gRW50ZXJMZWF2ZUV2ZW50UGx1Z2luXG4vLyBUaGlzIGlzIGJlY2F1c2Ugd2Ugb25seSBwcm9jZXNzIHRoaXMgcGx1Z2luXG4vLyBpbiB0aGUgYnViYmxlIHBoYXNlLCBzbyB3ZSBuZWVkIHRvIGFjY3VtdWxhdGUgdHdvXG4vLyBwaGFzZSBldmVudCBsaXN0ZW5lcnMuXG5cblxuZnVuY3Rpb24gYWNjdW11bGF0ZUVudGVyTGVhdmVUd29QaGFzZUxpc3RlbmVycyhkaXNwYXRjaFF1ZXVlLCBsZWF2ZUV2ZW50LCBlbnRlckV2ZW50LCBmcm9tLCB0bykge1xuICB2YXIgY29tbW9uID0gZnJvbSAmJiB0byA/IGdldExvd2VzdENvbW1vbkFuY2VzdG9yKGZyb20sIHRvKSA6IG51bGw7XG5cbiAgaWYgKGZyb20gIT09IG51bGwpIHtcbiAgICBhY2N1bXVsYXRlRW50ZXJMZWF2ZUxpc3RlbmVyc0ZvckV2ZW50KGRpc3BhdGNoUXVldWUsIGxlYXZlRXZlbnQsIGZyb20sIGNvbW1vbiwgZmFsc2UpO1xuICB9XG5cbiAgaWYgKHRvICE9PSBudWxsICYmIGVudGVyRXZlbnQgIT09IG51bGwpIHtcbiAgICBhY2N1bXVsYXRlRW50ZXJMZWF2ZUxpc3RlbmVyc0ZvckV2ZW50KGRpc3BhdGNoUXVldWUsIGVudGVyRXZlbnQsIHRvLCBjb21tb24sIHRydWUpO1xuICB9XG59XG5mdW5jdGlvbiBnZXRMaXN0ZW5lclNldEtleShkb21FdmVudE5hbWUsIGNhcHR1cmUpIHtcbiAgcmV0dXJuIGRvbUV2ZW50TmFtZSArIFwiX19cIiArIChjYXB0dXJlID8gJ2NhcHR1cmUnIDogJ2J1YmJsZScpO1xufVxuXG52YXIgZGlkV2FybkludmFsaWRIeWRyYXRpb24gPSBmYWxzZTtcbnZhciBEQU5HRVJPVVNMWV9TRVRfSU5ORVJfSFRNTCA9ICdkYW5nZXJvdXNseVNldElubmVySFRNTCc7XG52YXIgU1VQUFJFU1NfQ09OVEVOVF9FRElUQUJMRV9XQVJOSU5HID0gJ3N1cHByZXNzQ29udGVudEVkaXRhYmxlV2FybmluZyc7XG52YXIgU1VQUFJFU1NfSFlEUkFUSU9OX1dBUk5JTkcgPSAnc3VwcHJlc3NIeWRyYXRpb25XYXJuaW5nJztcbnZhciBBVVRPRk9DVVMgPSAnYXV0b0ZvY3VzJztcbnZhciBDSElMRFJFTiA9ICdjaGlsZHJlbic7XG52YXIgU1RZTEUgPSAnc3R5bGUnO1xudmFyIEhUTUwkMSA9ICdfX2h0bWwnO1xudmFyIEhUTUxfTkFNRVNQQUNFJDEgPSBOYW1lc3BhY2VzLmh0bWw7XG52YXIgd2FybmVkVW5rbm93blRhZ3M7XG52YXIgc3VwcHJlc3NIeWRyYXRpb25XYXJuaW5nO1xudmFyIHZhbGlkYXRlUHJvcGVydGllc0luRGV2ZWxvcG1lbnQ7XG52YXIgd2FybkZvclRleHREaWZmZXJlbmNlO1xudmFyIHdhcm5Gb3JQcm9wRGlmZmVyZW5jZTtcbnZhciB3YXJuRm9yRXh0cmFBdHRyaWJ1dGVzO1xudmFyIHdhcm5Gb3JJbnZhbGlkRXZlbnRMaXN0ZW5lcjtcbnZhciBjYW5EaWZmU3R5bGVGb3JIeWRyYXRpb25XYXJuaW5nO1xudmFyIG5vcm1hbGl6ZU1hcmt1cEZvclRleHRPckF0dHJpYnV0ZTtcbnZhciBub3JtYWxpemVIVE1MO1xuXG57XG4gIHdhcm5lZFVua25vd25UYWdzID0ge1xuICAgIC8vIFRoZXJlIGFyZSB3b3JraW5nIHBvbHlmaWxscyBmb3IgPGRpYWxvZz4uIExldCBwZW9wbGUgdXNlIGl0LlxuICAgIGRpYWxvZzogdHJ1ZSxcbiAgICAvLyBFbGVjdHJvbiBzaGlwcyBhIGN1c3RvbSA8d2Vidmlldz4gdGFnIHRvIGRpc3BsYXkgZXh0ZXJuYWwgd2ViIGNvbnRlbnQgaW5cbiAgICAvLyBhbiBpc29sYXRlZCBmcmFtZSBhbmQgcHJvY2Vzcy5cbiAgICAvLyBUaGlzIHRhZyBpcyBub3QgcHJlc2VudCBpbiBub24gRWxlY3Ryb24gZW52aXJvbm1lbnRzIHN1Y2ggYXMgSlNEb20gd2hpY2hcbiAgICAvLyBpcyBvZnRlbiB1c2VkIGZvciB0ZXN0aW5nIHB1cnBvc2VzLlxuICAgIC8vIEBzZWUgaHR0cHM6Ly9lbGVjdHJvbmpzLm9yZy9kb2NzL2FwaS93ZWJ2aWV3LXRhZ1xuICAgIHdlYnZpZXc6IHRydWVcbiAgfTtcblxuICB2YWxpZGF0ZVByb3BlcnRpZXNJbkRldmVsb3BtZW50ID0gZnVuY3Rpb24gKHR5cGUsIHByb3BzKSB7XG4gICAgdmFsaWRhdGVQcm9wZXJ0aWVzKHR5cGUsIHByb3BzKTtcbiAgICB2YWxpZGF0ZVByb3BlcnRpZXMkMSh0eXBlLCBwcm9wcyk7XG4gICAgdmFsaWRhdGVQcm9wZXJ0aWVzJDIodHlwZSwgcHJvcHMsIHtcbiAgICAgIHJlZ2lzdHJhdGlvbk5hbWVEZXBlbmRlbmNpZXM6IHJlZ2lzdHJhdGlvbk5hbWVEZXBlbmRlbmNpZXMsXG4gICAgICBwb3NzaWJsZVJlZ2lzdHJhdGlvbk5hbWVzOiBwb3NzaWJsZVJlZ2lzdHJhdGlvbk5hbWVzXG4gICAgfSk7XG4gIH07IC8vIElFIDExIHBhcnNlcyAmIG5vcm1hbGl6ZXMgdGhlIHN0eWxlIGF0dHJpYnV0ZSBhcyBvcHBvc2VkIHRvIG90aGVyXG4gIC8vIGJyb3dzZXJzLiBJdCBhZGRzIHNwYWNlcyBhbmQgc29ydHMgdGhlIHByb3BlcnRpZXMgaW4gc29tZVxuICAvLyBub24tYWxwaGFiZXRpY2FsIG9yZGVyLiBIYW5kbGluZyB0aGF0IHdvdWxkIHJlcXVpcmUgc29ydGluZyBDU1NcbiAgLy8gcHJvcGVydGllcyBpbiB0aGUgY2xpZW50ICYgc2VydmVyIHZlcnNpb25zIG9yIGFwcGx5aW5nXG4gIC8vIGBleHBlY3RlZFN0eWxlYCB0byBhIHRlbXBvcmFyeSBET00gbm9kZSB0byByZWFkIGl0cyBgc3R5bGVgIGF0dHJpYnV0ZVxuICAvLyBub3JtYWxpemVkLiBTaW5jZSBpdCBvbmx5IGFmZmVjdHMgSUUsIHdlJ3JlIHNraXBwaW5nIHN0eWxlIHdhcm5pbmdzXG4gIC8vIGluIHRoYXQgYnJvd3NlciBjb21wbGV0ZWx5IGluIGZhdm9yIG9mIGRvaW5nIGFsbCB0aGF0IHdvcmsuXG4gIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzExODA3XG5cblxuICBjYW5EaWZmU3R5bGVGb3JIeWRyYXRpb25XYXJuaW5nID0gY2FuVXNlRE9NICYmICFkb2N1bWVudC5kb2N1bWVudE1vZGU7IC8vIEhUTUwgcGFyc2luZyBub3JtYWxpemVzIENSIGFuZCBDUkxGIHRvIExGLlxuICAvLyBJdCBhbHNvIGNhbiB0dXJuIFxcdTAwMDAgaW50byBcXHVGRkZEIGluc2lkZSBhdHRyaWJ1dGVzLlxuICAvLyBodHRwczovL3d3dy53My5vcmcvVFIvaHRtbDUvc2luZ2xlLXBhZ2UuaHRtbCNwcmVwcm9jZXNzaW5nLXRoZS1pbnB1dC1zdHJlYW1cbiAgLy8gSWYgd2UgaGF2ZSBhIG1pc21hdGNoLCBpdCBtaWdodCBiZSBjYXVzZWQgYnkgdGhhdC5cbiAgLy8gV2Ugd2lsbCBzdGlsbCBwYXRjaCB1cCBpbiB0aGlzIGNhc2UgYnV0IG5vdCBmaXJlIHRoZSB3YXJuaW5nLlxuXG4gIHZhciBOT1JNQUxJWkVfTkVXTElORVNfUkVHRVggPSAvXFxyXFxuPy9nO1xuICB2YXIgTk9STUFMSVpFX05VTExfQU5EX1JFUExBQ0VNRU5UX1JFR0VYID0gL1xcdTAwMDB8XFx1RkZGRC9nO1xuXG4gIG5vcm1hbGl6ZU1hcmt1cEZvclRleHRPckF0dHJpYnV0ZSA9IGZ1bmN0aW9uIChtYXJrdXApIHtcbiAgICB2YXIgbWFya3VwU3RyaW5nID0gdHlwZW9mIG1hcmt1cCA9PT0gJ3N0cmluZycgPyBtYXJrdXAgOiAnJyArIG1hcmt1cDtcbiAgICByZXR1cm4gbWFya3VwU3RyaW5nLnJlcGxhY2UoTk9STUFMSVpFX05FV0xJTkVTX1JFR0VYLCAnXFxuJykucmVwbGFjZShOT1JNQUxJWkVfTlVMTF9BTkRfUkVQTEFDRU1FTlRfUkVHRVgsICcnKTtcbiAgfTtcblxuICB3YXJuRm9yVGV4dERpZmZlcmVuY2UgPSBmdW5jdGlvbiAoc2VydmVyVGV4dCwgY2xpZW50VGV4dCkge1xuICAgIGlmIChkaWRXYXJuSW52YWxpZEh5ZHJhdGlvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBub3JtYWxpemVkQ2xpZW50VGV4dCA9IG5vcm1hbGl6ZU1hcmt1cEZvclRleHRPckF0dHJpYnV0ZShjbGllbnRUZXh0KTtcbiAgICB2YXIgbm9ybWFsaXplZFNlcnZlclRleHQgPSBub3JtYWxpemVNYXJrdXBGb3JUZXh0T3JBdHRyaWJ1dGUoc2VydmVyVGV4dCk7XG5cbiAgICBpZiAobm9ybWFsaXplZFNlcnZlclRleHQgPT09IG5vcm1hbGl6ZWRDbGllbnRUZXh0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZGlkV2FybkludmFsaWRIeWRyYXRpb24gPSB0cnVlO1xuXG4gICAgZXJyb3IoJ1RleHQgY29udGVudCBkaWQgbm90IG1hdGNoLiBTZXJ2ZXI6IFwiJXNcIiBDbGllbnQ6IFwiJXNcIicsIG5vcm1hbGl6ZWRTZXJ2ZXJUZXh0LCBub3JtYWxpemVkQ2xpZW50VGV4dCk7XG4gIH07XG5cbiAgd2FybkZvclByb3BEaWZmZXJlbmNlID0gZnVuY3Rpb24gKHByb3BOYW1lLCBzZXJ2ZXJWYWx1ZSwgY2xpZW50VmFsdWUpIHtcbiAgICBpZiAoZGlkV2FybkludmFsaWRIeWRyYXRpb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgbm9ybWFsaXplZENsaWVudFZhbHVlID0gbm9ybWFsaXplTWFya3VwRm9yVGV4dE9yQXR0cmlidXRlKGNsaWVudFZhbHVlKTtcbiAgICB2YXIgbm9ybWFsaXplZFNlcnZlclZhbHVlID0gbm9ybWFsaXplTWFya3VwRm9yVGV4dE9yQXR0cmlidXRlKHNlcnZlclZhbHVlKTtcblxuICAgIGlmIChub3JtYWxpemVkU2VydmVyVmFsdWUgPT09IG5vcm1hbGl6ZWRDbGllbnRWYWx1ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGRpZFdhcm5JbnZhbGlkSHlkcmF0aW9uID0gdHJ1ZTtcblxuICAgIGVycm9yKCdQcm9wIGAlc2AgZGlkIG5vdCBtYXRjaC4gU2VydmVyOiAlcyBDbGllbnQ6ICVzJywgcHJvcE5hbWUsIEpTT04uc3RyaW5naWZ5KG5vcm1hbGl6ZWRTZXJ2ZXJWYWx1ZSksIEpTT04uc3RyaW5naWZ5KG5vcm1hbGl6ZWRDbGllbnRWYWx1ZSkpO1xuICB9O1xuXG4gIHdhcm5Gb3JFeHRyYUF0dHJpYnV0ZXMgPSBmdW5jdGlvbiAoYXR0cmlidXRlTmFtZXMpIHtcbiAgICBpZiAoZGlkV2FybkludmFsaWRIeWRyYXRpb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBkaWRXYXJuSW52YWxpZEh5ZHJhdGlvbiA9IHRydWU7XG4gICAgdmFyIG5hbWVzID0gW107XG4gICAgYXR0cmlidXRlTmFtZXMuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgbmFtZXMucHVzaChuYW1lKTtcbiAgICB9KTtcblxuICAgIGVycm9yKCdFeHRyYSBhdHRyaWJ1dGVzIGZyb20gdGhlIHNlcnZlcjogJXMnLCBuYW1lcyk7XG4gIH07XG5cbiAgd2FybkZvckludmFsaWRFdmVudExpc3RlbmVyID0gZnVuY3Rpb24gKHJlZ2lzdHJhdGlvbk5hbWUsIGxpc3RlbmVyKSB7XG4gICAgaWYgKGxpc3RlbmVyID09PSBmYWxzZSkge1xuICAgICAgZXJyb3IoJ0V4cGVjdGVkIGAlc2AgbGlzdGVuZXIgdG8gYmUgYSBmdW5jdGlvbiwgaW5zdGVhZCBnb3QgYGZhbHNlYC5cXG5cXG4nICsgJ0lmIHlvdSB1c2VkIHRvIGNvbmRpdGlvbmFsbHkgb21pdCBpdCB3aXRoICVzPXtjb25kaXRpb24gJiYgdmFsdWV9LCAnICsgJ3Bhc3MgJXM9e2NvbmRpdGlvbiA/IHZhbHVlIDogdW5kZWZpbmVkfSBpbnN0ZWFkLicsIHJlZ2lzdHJhdGlvbk5hbWUsIHJlZ2lzdHJhdGlvbk5hbWUsIHJlZ2lzdHJhdGlvbk5hbWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlcnJvcignRXhwZWN0ZWQgYCVzYCBsaXN0ZW5lciB0byBiZSBhIGZ1bmN0aW9uLCBpbnN0ZWFkIGdvdCBhIHZhbHVlIG9mIGAlc2AgdHlwZS4nLCByZWdpc3RyYXRpb25OYW1lLCB0eXBlb2YgbGlzdGVuZXIpO1xuICAgIH1cbiAgfTsgLy8gUGFyc2UgdGhlIEhUTUwgYW5kIHJlYWQgaXQgYmFjayB0byBub3JtYWxpemUgdGhlIEhUTUwgc3RyaW5nIHNvIHRoYXQgaXRcbiAgLy8gY2FuIGJlIHVzZWQgZm9yIGNvbXBhcmlzb24uXG5cblxuICBub3JtYWxpemVIVE1MID0gZnVuY3Rpb24gKHBhcmVudCwgaHRtbCkge1xuICAgIC8vIFdlIGNvdWxkIGhhdmUgY3JlYXRlZCBhIHNlcGFyYXRlIGRvY3VtZW50IGhlcmUgdG8gYXZvaWRcbiAgICAvLyByZS1pbml0aWFsaXppbmcgY3VzdG9tIGVsZW1lbnRzIGlmIHRoZXkgZXhpc3QuIEJ1dCB0aGlzIGJyZWFrc1xuICAgIC8vIGhvdyA8bm9zY3JpcHQ+IGlzIGJlaW5nIGhhbmRsZWQuIFNvIHdlIHVzZSB0aGUgc2FtZSBkb2N1bWVudC5cbiAgICAvLyBTZWUgdGhlIGRpc2N1c3Npb24gaW4gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L3B1bGwvMTExNTcuXG4gICAgdmFyIHRlc3RFbGVtZW50ID0gcGFyZW50Lm5hbWVzcGFjZVVSSSA9PT0gSFRNTF9OQU1FU1BBQ0UkMSA/IHBhcmVudC5vd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnQocGFyZW50LnRhZ05hbWUpIDogcGFyZW50Lm93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKHBhcmVudC5uYW1lc3BhY2VVUkksIHBhcmVudC50YWdOYW1lKTtcbiAgICB0ZXN0RWxlbWVudC5pbm5lckhUTUwgPSBodG1sO1xuICAgIHJldHVybiB0ZXN0RWxlbWVudC5pbm5lckhUTUw7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGdldE93bmVyRG9jdW1lbnRGcm9tUm9vdENvbnRhaW5lcihyb290Q29udGFpbmVyRWxlbWVudCkge1xuICByZXR1cm4gcm9vdENvbnRhaW5lckVsZW1lbnQubm9kZVR5cGUgPT09IERPQ1VNRU5UX05PREUgPyByb290Q29udGFpbmVyRWxlbWVudCA6IHJvb3RDb250YWluZXJFbGVtZW50Lm93bmVyRG9jdW1lbnQ7XG59XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5mdW5jdGlvbiB0cmFwQ2xpY2tPbk5vbkludGVyYWN0aXZlRWxlbWVudChub2RlKSB7XG4gIC8vIE1vYmlsZSBTYWZhcmkgZG9lcyBub3QgZmlyZSBwcm9wZXJseSBidWJibGUgY2xpY2sgZXZlbnRzIG9uXG4gIC8vIG5vbi1pbnRlcmFjdGl2ZSBlbGVtZW50cywgd2hpY2ggbWVhbnMgZGVsZWdhdGVkIGNsaWNrIGxpc3RlbmVycyBkbyBub3RcbiAgLy8gZmlyZS4gVGhlIHdvcmthcm91bmQgZm9yIHRoaXMgYnVnIGludm9sdmVzIGF0dGFjaGluZyBhbiBlbXB0eSBjbGlja1xuICAvLyBsaXN0ZW5lciBvbiB0aGUgdGFyZ2V0IG5vZGUuXG4gIC8vIGh0dHBzOi8vd3d3LnF1aXJrc21vZGUub3JnL2Jsb2cvYXJjaGl2ZXMvMjAxMC8wOS9jbGlja19ldmVudF9kZWwuaHRtbFxuICAvLyBKdXN0IHNldCBpdCB1c2luZyB0aGUgb25jbGljayBwcm9wZXJ0eSBzbyB0aGF0IHdlIGRvbid0IGhhdmUgdG8gbWFuYWdlIGFueVxuICAvLyBib29ra2VlcGluZyBmb3IgaXQuIE5vdCBzdXJlIGlmIHdlIG5lZWQgdG8gY2xlYXIgaXQgd2hlbiB0aGUgbGlzdGVuZXIgaXNcbiAgLy8gcmVtb3ZlZC5cbiAgLy8gVE9ETzogT25seSBkbyB0aGlzIGZvciB0aGUgcmVsZXZhbnQgU2FmYXJpcyBtYXliZT9cbiAgbm9kZS5vbmNsaWNrID0gbm9vcDtcbn1cblxuZnVuY3Rpb24gc2V0SW5pdGlhbERPTVByb3BlcnRpZXModGFnLCBkb21FbGVtZW50LCByb290Q29udGFpbmVyRWxlbWVudCwgbmV4dFByb3BzLCBpc0N1c3RvbUNvbXBvbmVudFRhZykge1xuICBmb3IgKHZhciBwcm9wS2V5IGluIG5leHRQcm9wcykge1xuICAgIGlmICghbmV4dFByb3BzLmhhc093blByb3BlcnR5KHByb3BLZXkpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICB2YXIgbmV4dFByb3AgPSBuZXh0UHJvcHNbcHJvcEtleV07XG5cbiAgICBpZiAocHJvcEtleSA9PT0gU1RZTEUpIHtcbiAgICAgIHtcbiAgICAgICAgaWYgKG5leHRQcm9wKSB7XG4gICAgICAgICAgLy8gRnJlZXplIHRoZSBuZXh0IHN0eWxlIG9iamVjdCBzbyB0aGF0IHdlIGNhbiBhc3N1bWUgaXQgd29uJ3QgYmVcbiAgICAgICAgICAvLyBtdXRhdGVkLiBXZSBoYXZlIGFscmVhZHkgd2FybmVkIGZvciB0aGlzIGluIHRoZSBwYXN0LlxuICAgICAgICAgIE9iamVjdC5mcmVlemUobmV4dFByb3ApO1xuICAgICAgICB9XG4gICAgICB9IC8vIFJlbGllcyBvbiBgdXBkYXRlU3R5bGVzQnlJRGAgbm90IG11dGF0aW5nIGBzdHlsZVVwZGF0ZXNgLlxuXG5cbiAgICAgIHNldFZhbHVlRm9yU3R5bGVzKGRvbUVsZW1lbnQsIG5leHRQcm9wKTtcbiAgICB9IGVsc2UgaWYgKHByb3BLZXkgPT09IERBTkdFUk9VU0xZX1NFVF9JTk5FUl9IVE1MKSB7XG4gICAgICB2YXIgbmV4dEh0bWwgPSBuZXh0UHJvcCA/IG5leHRQcm9wW0hUTUwkMV0gOiB1bmRlZmluZWQ7XG5cbiAgICAgIGlmIChuZXh0SHRtbCAhPSBudWxsKSB7XG4gICAgICAgIHNldElubmVySFRNTChkb21FbGVtZW50LCBuZXh0SHRtbCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChwcm9wS2V5ID09PSBDSElMRFJFTikge1xuICAgICAgaWYgKHR5cGVvZiBuZXh0UHJvcCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgLy8gQXZvaWQgc2V0dGluZyBpbml0aWFsIHRleHRDb250ZW50IHdoZW4gdGhlIHRleHQgaXMgZW1wdHkuIEluIElFMTEgc2V0dGluZ1xuICAgICAgICAvLyB0ZXh0Q29udGVudCBvbiBhIDx0ZXh0YXJlYT4gd2lsbCBjYXVzZSB0aGUgcGxhY2Vob2xkZXIgdG8gbm90XG4gICAgICAgIC8vIHNob3cgd2l0aGluIHRoZSA8dGV4dGFyZWE+IHVudGlsIGl0IGhhcyBiZWVuIGZvY3VzZWQgYW5kIGJsdXJyZWQgYWdhaW4uXG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvNjczMSNpc3N1ZWNvbW1lbnQtMjU0ODc0NTUzXG4gICAgICAgIHZhciBjYW5TZXRUZXh0Q29udGVudCA9IHRhZyAhPT0gJ3RleHRhcmVhJyB8fCBuZXh0UHJvcCAhPT0gJyc7XG5cbiAgICAgICAgaWYgKGNhblNldFRleHRDb250ZW50KSB7XG4gICAgICAgICAgc2V0VGV4dENvbnRlbnQoZG9tRWxlbWVudCwgbmV4dFByb3ApO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBuZXh0UHJvcCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgc2V0VGV4dENvbnRlbnQoZG9tRWxlbWVudCwgJycgKyBuZXh0UHJvcCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChwcm9wS2V5ID09PSBTVVBQUkVTU19DT05URU5UX0VESVRBQkxFX1dBUk5JTkcgfHwgcHJvcEtleSA9PT0gU1VQUFJFU1NfSFlEUkFUSU9OX1dBUk5JTkcpIDsgZWxzZSBpZiAocHJvcEtleSA9PT0gQVVUT0ZPQ1VTKSA7IGVsc2UgaWYgKHJlZ2lzdHJhdGlvbk5hbWVEZXBlbmRlbmNpZXMuaGFzT3duUHJvcGVydHkocHJvcEtleSkpIHtcbiAgICAgIGlmIChuZXh0UHJvcCAhPSBudWxsKSB7XG4gICAgICAgIGlmICggdHlwZW9mIG5leHRQcm9wICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgd2FybkZvckludmFsaWRFdmVudExpc3RlbmVyKHByb3BLZXksIG5leHRQcm9wKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwcm9wS2V5ID09PSAnb25TY3JvbGwnKSB7XG4gICAgICAgICAgbGlzdGVuVG9Ob25EZWxlZ2F0ZWRFdmVudCgnc2Nyb2xsJywgZG9tRWxlbWVudCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG5leHRQcm9wICE9IG51bGwpIHtcbiAgICAgIHNldFZhbHVlRm9yUHJvcGVydHkoZG9tRWxlbWVudCwgcHJvcEtleSwgbmV4dFByb3AsIGlzQ3VzdG9tQ29tcG9uZW50VGFnKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gdXBkYXRlRE9NUHJvcGVydGllcyhkb21FbGVtZW50LCB1cGRhdGVQYXlsb2FkLCB3YXNDdXN0b21Db21wb25lbnRUYWcsIGlzQ3VzdG9tQ29tcG9uZW50VGFnKSB7XG4gIC8vIFRPRE86IEhhbmRsZSB3YXNDdXN0b21Db21wb25lbnRUYWdcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB1cGRhdGVQYXlsb2FkLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgdmFyIHByb3BLZXkgPSB1cGRhdGVQYXlsb2FkW2ldO1xuICAgIHZhciBwcm9wVmFsdWUgPSB1cGRhdGVQYXlsb2FkW2kgKyAxXTtcblxuICAgIGlmIChwcm9wS2V5ID09PSBTVFlMRSkge1xuICAgICAgc2V0VmFsdWVGb3JTdHlsZXMoZG9tRWxlbWVudCwgcHJvcFZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKHByb3BLZXkgPT09IERBTkdFUk9VU0xZX1NFVF9JTk5FUl9IVE1MKSB7XG4gICAgICBzZXRJbm5lckhUTUwoZG9tRWxlbWVudCwgcHJvcFZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKHByb3BLZXkgPT09IENISUxEUkVOKSB7XG4gICAgICBzZXRUZXh0Q29udGVudChkb21FbGVtZW50LCBwcm9wVmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZXRWYWx1ZUZvclByb3BlcnR5KGRvbUVsZW1lbnQsIHByb3BLZXksIHByb3BWYWx1ZSwgaXNDdXN0b21Db21wb25lbnRUYWcpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVFbGVtZW50KHR5cGUsIHByb3BzLCByb290Q29udGFpbmVyRWxlbWVudCwgcGFyZW50TmFtZXNwYWNlKSB7XG4gIHZhciBpc0N1c3RvbUNvbXBvbmVudFRhZzsgLy8gV2UgY3JlYXRlIHRhZ3MgaW4gdGhlIG5hbWVzcGFjZSBvZiB0aGVpciBwYXJlbnQgY29udGFpbmVyLCBleGNlcHQgSFRNTFxuICAvLyB0YWdzIGdldCBubyBuYW1lc3BhY2UuXG5cbiAgdmFyIG93bmVyRG9jdW1lbnQgPSBnZXRPd25lckRvY3VtZW50RnJvbVJvb3RDb250YWluZXIocm9vdENvbnRhaW5lckVsZW1lbnQpO1xuICB2YXIgZG9tRWxlbWVudDtcbiAgdmFyIG5hbWVzcGFjZVVSSSA9IHBhcmVudE5hbWVzcGFjZTtcblxuICBpZiAobmFtZXNwYWNlVVJJID09PSBIVE1MX05BTUVTUEFDRSQxKSB7XG4gICAgbmFtZXNwYWNlVVJJID0gZ2V0SW50cmluc2ljTmFtZXNwYWNlKHR5cGUpO1xuICB9XG5cbiAgaWYgKG5hbWVzcGFjZVVSSSA9PT0gSFRNTF9OQU1FU1BBQ0UkMSkge1xuICAgIHtcbiAgICAgIGlzQ3VzdG9tQ29tcG9uZW50VGFnID0gaXNDdXN0b21Db21wb25lbnQodHlwZSwgcHJvcHMpOyAvLyBTaG91bGQgdGhpcyBjaGVjayBiZSBnYXRlZCBieSBwYXJlbnQgbmFtZXNwYWNlPyBOb3Qgc3VyZSB3ZSB3YW50IHRvXG4gICAgICAvLyBhbGxvdyA8U1ZHPiBvciA8bUFUSD4uXG5cbiAgICAgIGlmICghaXNDdXN0b21Db21wb25lbnRUYWcgJiYgdHlwZSAhPT0gdHlwZS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICAgIGVycm9yKCc8JXMgLz4gaXMgdXNpbmcgaW5jb3JyZWN0IGNhc2luZy4gJyArICdVc2UgUGFzY2FsQ2FzZSBmb3IgUmVhY3QgY29tcG9uZW50cywgJyArICdvciBsb3dlcmNhc2UgZm9yIEhUTUwgZWxlbWVudHMuJywgdHlwZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHR5cGUgPT09ICdzY3JpcHQnKSB7XG4gICAgICAvLyBDcmVhdGUgdGhlIHNjcmlwdCB2aWEgLmlubmVySFRNTCBzbyBpdHMgXCJwYXJzZXItaW5zZXJ0ZWRcIiBmbGFnIGlzXG4gICAgICAvLyBzZXQgdG8gdHJ1ZSBhbmQgaXQgZG9lcyBub3QgZXhlY3V0ZVxuICAgICAgdmFyIGRpdiA9IG93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cbiAgICAgIGRpdi5pbm5lckhUTUwgPSAnPHNjcmlwdD48JyArICcvc2NyaXB0Pic7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICAgIC8vIFRoaXMgaXMgZ3VhcmFudGVlZCB0byB5aWVsZCBhIHNjcmlwdCBlbGVtZW50LlxuXG4gICAgICB2YXIgZmlyc3RDaGlsZCA9IGRpdi5maXJzdENoaWxkO1xuICAgICAgZG9tRWxlbWVudCA9IGRpdi5yZW1vdmVDaGlsZChmaXJzdENoaWxkKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBwcm9wcy5pcyA9PT0gJ3N0cmluZycpIHtcbiAgICAgIC8vICRGbG93SXNzdWUgYGNyZWF0ZUVsZW1lbnRgIHNob3VsZCBiZSB1cGRhdGVkIGZvciBXZWIgQ29tcG9uZW50c1xuICAgICAgZG9tRWxlbWVudCA9IG93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0eXBlLCB7XG4gICAgICAgIGlzOiBwcm9wcy5pc1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFNlcGFyYXRlIGVsc2UgYnJhbmNoIGluc3RlYWQgb2YgdXNpbmcgYHByb3BzLmlzIHx8IHVuZGVmaW5lZGAgYWJvdmUgYmVjYXVzZSBvZiBhIEZpcmVmb3ggYnVnLlxuICAgICAgLy8gU2VlIGRpc2N1c3Npb24gaW4gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L3B1bGwvNjg5NlxuICAgICAgLy8gYW5kIGRpc2N1c3Npb24gaW4gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTI3NjI0MFxuICAgICAgZG9tRWxlbWVudCA9IG93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0eXBlKTsgLy8gTm9ybWFsbHkgYXR0cmlidXRlcyBhcmUgYXNzaWduZWQgaW4gYHNldEluaXRpYWxET01Qcm9wZXJ0aWVzYCwgaG93ZXZlciB0aGUgYG11bHRpcGxlYCBhbmQgYHNpemVgXG4gICAgICAvLyBhdHRyaWJ1dGVzIG9uIGBzZWxlY3RgcyBuZWVkcyB0byBiZSBhZGRlZCBiZWZvcmUgYG9wdGlvbmBzIGFyZSBpbnNlcnRlZC5cbiAgICAgIC8vIFRoaXMgcHJldmVudHM6XG4gICAgICAvLyAtIGEgYnVnIHdoZXJlIHRoZSBgc2VsZWN0YCBkb2VzIG5vdCBzY3JvbGwgdG8gdGhlIGNvcnJlY3Qgb3B0aW9uIGJlY2F1c2Ugc2luZ3VsYXJcbiAgICAgIC8vICBgc2VsZWN0YCBlbGVtZW50cyBhdXRvbWF0aWNhbGx5IHBpY2sgdGhlIGZpcnN0IGl0ZW0gIzEzMjIyXG4gICAgICAvLyAtIGEgYnVnIHdoZXJlIHRoZSBgc2VsZWN0YCBzZXQgdGhlIGZpcnN0IGl0ZW0gYXMgc2VsZWN0ZWQgZGVzcGl0ZSB0aGUgYHNpemVgIGF0dHJpYnV0ZSAjMTQyMzlcbiAgICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzEzMjIyXG4gICAgICAvLyBhbmQgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xNDIzOVxuXG4gICAgICBpZiAodHlwZSA9PT0gJ3NlbGVjdCcpIHtcbiAgICAgICAgdmFyIG5vZGUgPSBkb21FbGVtZW50O1xuXG4gICAgICAgIGlmIChwcm9wcy5tdWx0aXBsZSkge1xuICAgICAgICAgIG5vZGUubXVsdGlwbGUgPSB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYgKHByb3BzLnNpemUpIHtcbiAgICAgICAgICAvLyBTZXR0aW5nIGEgc2l6ZSBncmVhdGVyIHRoYW4gMSBjYXVzZXMgYSBzZWxlY3QgdG8gYmVoYXZlIGxpa2UgYG11bHRpcGxlPXRydWVgLCB3aGVyZVxuICAgICAgICAgIC8vIGl0IGlzIHBvc3NpYmxlIHRoYXQgbm8gb3B0aW9uIGlzIHNlbGVjdGVkLlxuICAgICAgICAgIC8vXG4gICAgICAgICAgLy8gVGhpcyBpcyBvbmx5IG5lY2Vzc2FyeSB3aGVuIGEgc2VsZWN0IGluIFwic2luZ2xlIHNlbGVjdGlvbiBtb2RlXCIuXG4gICAgICAgICAgbm9kZS5zaXplID0gcHJvcHMuc2l6ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBkb21FbGVtZW50ID0gb3duZXJEb2N1bWVudC5jcmVhdGVFbGVtZW50TlMobmFtZXNwYWNlVVJJLCB0eXBlKTtcbiAgfVxuXG4gIHtcbiAgICBpZiAobmFtZXNwYWNlVVJJID09PSBIVE1MX05BTUVTUEFDRSQxKSB7XG4gICAgICBpZiAoIWlzQ3VzdG9tQ29tcG9uZW50VGFnICYmIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChkb21FbGVtZW50KSA9PT0gJ1tvYmplY3QgSFRNTFVua25vd25FbGVtZW50XScgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh3YXJuZWRVbmtub3duVGFncywgdHlwZSkpIHtcbiAgICAgICAgd2FybmVkVW5rbm93blRhZ3NbdHlwZV0gPSB0cnVlO1xuXG4gICAgICAgIGVycm9yKCdUaGUgdGFnIDwlcz4gaXMgdW5yZWNvZ25pemVkIGluIHRoaXMgYnJvd3Nlci4gJyArICdJZiB5b3UgbWVhbnQgdG8gcmVuZGVyIGEgUmVhY3QgY29tcG9uZW50LCBzdGFydCBpdHMgbmFtZSB3aXRoICcgKyAnYW4gdXBwZXJjYXNlIGxldHRlci4nLCB0eXBlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gZG9tRWxlbWVudDtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVRleHROb2RlKHRleHQsIHJvb3RDb250YWluZXJFbGVtZW50KSB7XG4gIHJldHVybiBnZXRPd25lckRvY3VtZW50RnJvbVJvb3RDb250YWluZXIocm9vdENvbnRhaW5lckVsZW1lbnQpLmNyZWF0ZVRleHROb2RlKHRleHQpO1xufVxuZnVuY3Rpb24gc2V0SW5pdGlhbFByb3BlcnRpZXMoZG9tRWxlbWVudCwgdGFnLCByYXdQcm9wcywgcm9vdENvbnRhaW5lckVsZW1lbnQpIHtcbiAgdmFyIGlzQ3VzdG9tQ29tcG9uZW50VGFnID0gaXNDdXN0b21Db21wb25lbnQodGFnLCByYXdQcm9wcyk7XG5cbiAge1xuICAgIHZhbGlkYXRlUHJvcGVydGllc0luRGV2ZWxvcG1lbnQodGFnLCByYXdQcm9wcyk7XG4gIH0gLy8gVE9ETzogTWFrZSBzdXJlIHRoYXQgd2UgY2hlY2sgaXNNb3VudGVkIGJlZm9yZSBmaXJpbmcgYW55IG9mIHRoZXNlIGV2ZW50cy5cblxuXG4gIHZhciBwcm9wcztcblxuICBzd2l0Y2ggKHRhZykge1xuICAgIGNhc2UgJ2RpYWxvZyc6XG4gICAgICBsaXN0ZW5Ub05vbkRlbGVnYXRlZEV2ZW50KCdjYW5jZWwnLCBkb21FbGVtZW50KTtcbiAgICAgIGxpc3RlblRvTm9uRGVsZWdhdGVkRXZlbnQoJ2Nsb3NlJywgZG9tRWxlbWVudCk7XG4gICAgICBwcm9wcyA9IHJhd1Byb3BzO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdpZnJhbWUnOlxuICAgIGNhc2UgJ29iamVjdCc6XG4gICAgY2FzZSAnZW1iZWQnOlxuICAgICAgLy8gV2UgbGlzdGVuIHRvIHRoaXMgZXZlbnQgaW4gY2FzZSB0byBlbnN1cmUgZW11bGF0ZWQgYnViYmxlXG4gICAgICAvLyBsaXN0ZW5lcnMgc3RpbGwgZmlyZSBmb3IgdGhlIGxvYWQgZXZlbnQuXG4gICAgICBsaXN0ZW5Ub05vbkRlbGVnYXRlZEV2ZW50KCdsb2FkJywgZG9tRWxlbWVudCk7XG4gICAgICBwcm9wcyA9IHJhd1Byb3BzO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICd2aWRlbyc6XG4gICAgY2FzZSAnYXVkaW8nOlxuICAgICAgLy8gV2UgbGlzdGVuIHRvIHRoZXNlIGV2ZW50cyBpbiBjYXNlIHRvIGVuc3VyZSBlbXVsYXRlZCBidWJibGVcbiAgICAgIC8vIGxpc3RlbmVycyBzdGlsbCBmaXJlIGZvciBhbGwgdGhlIG1lZGlhIGV2ZW50cy5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWVkaWFFdmVudFR5cGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxpc3RlblRvTm9uRGVsZWdhdGVkRXZlbnQobWVkaWFFdmVudFR5cGVzW2ldLCBkb21FbGVtZW50KTtcbiAgICAgIH1cblxuICAgICAgcHJvcHMgPSByYXdQcm9wcztcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnc291cmNlJzpcbiAgICAgIC8vIFdlIGxpc3RlbiB0byB0aGlzIGV2ZW50IGluIGNhc2UgdG8gZW5zdXJlIGVtdWxhdGVkIGJ1YmJsZVxuICAgICAgLy8gbGlzdGVuZXJzIHN0aWxsIGZpcmUgZm9yIHRoZSBlcnJvciBldmVudC5cbiAgICAgIGxpc3RlblRvTm9uRGVsZWdhdGVkRXZlbnQoJ2Vycm9yJywgZG9tRWxlbWVudCk7XG4gICAgICBwcm9wcyA9IHJhd1Byb3BzO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdpbWcnOlxuICAgIGNhc2UgJ2ltYWdlJzpcbiAgICBjYXNlICdsaW5rJzpcbiAgICAgIC8vIFdlIGxpc3RlbiB0byB0aGVzZSBldmVudHMgaW4gY2FzZSB0byBlbnN1cmUgZW11bGF0ZWQgYnViYmxlXG4gICAgICAvLyBsaXN0ZW5lcnMgc3RpbGwgZmlyZSBmb3IgZXJyb3IgYW5kIGxvYWQgZXZlbnRzLlxuICAgICAgbGlzdGVuVG9Ob25EZWxlZ2F0ZWRFdmVudCgnZXJyb3InLCBkb21FbGVtZW50KTtcbiAgICAgIGxpc3RlblRvTm9uRGVsZWdhdGVkRXZlbnQoJ2xvYWQnLCBkb21FbGVtZW50KTtcbiAgICAgIHByb3BzID0gcmF3UHJvcHM7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ2RldGFpbHMnOlxuICAgICAgLy8gV2UgbGlzdGVuIHRvIHRoaXMgZXZlbnQgaW4gY2FzZSB0byBlbnN1cmUgZW11bGF0ZWQgYnViYmxlXG4gICAgICAvLyBsaXN0ZW5lcnMgc3RpbGwgZmlyZSBmb3IgdGhlIHRvZ2dsZSBldmVudC5cbiAgICAgIGxpc3RlblRvTm9uRGVsZWdhdGVkRXZlbnQoJ3RvZ2dsZScsIGRvbUVsZW1lbnQpO1xuICAgICAgcHJvcHMgPSByYXdQcm9wcztcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnaW5wdXQnOlxuICAgICAgaW5pdFdyYXBwZXJTdGF0ZShkb21FbGVtZW50LCByYXdQcm9wcyk7XG4gICAgICBwcm9wcyA9IGdldEhvc3RQcm9wcyhkb21FbGVtZW50LCByYXdQcm9wcyk7IC8vIFdlIGxpc3RlbiB0byB0aGlzIGV2ZW50IGluIGNhc2UgdG8gZW5zdXJlIGVtdWxhdGVkIGJ1YmJsZVxuICAgICAgLy8gbGlzdGVuZXJzIHN0aWxsIGZpcmUgZm9yIHRoZSBpbnZhbGlkIGV2ZW50LlxuXG4gICAgICBsaXN0ZW5Ub05vbkRlbGVnYXRlZEV2ZW50KCdpbnZhbGlkJywgZG9tRWxlbWVudCk7XG5cbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnb3B0aW9uJzpcbiAgICAgIHZhbGlkYXRlUHJvcHMoZG9tRWxlbWVudCwgcmF3UHJvcHMpO1xuICAgICAgcHJvcHMgPSBnZXRIb3N0UHJvcHMkMShkb21FbGVtZW50LCByYXdQcm9wcyk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ3NlbGVjdCc6XG4gICAgICBpbml0V3JhcHBlclN0YXRlJDEoZG9tRWxlbWVudCwgcmF3UHJvcHMpO1xuICAgICAgcHJvcHMgPSBnZXRIb3N0UHJvcHMkMihkb21FbGVtZW50LCByYXdQcm9wcyk7IC8vIFdlIGxpc3RlbiB0byB0aGlzIGV2ZW50IGluIGNhc2UgdG8gZW5zdXJlIGVtdWxhdGVkIGJ1YmJsZVxuICAgICAgLy8gbGlzdGVuZXJzIHN0aWxsIGZpcmUgZm9yIHRoZSBpbnZhbGlkIGV2ZW50LlxuXG4gICAgICBsaXN0ZW5Ub05vbkRlbGVnYXRlZEV2ZW50KCdpbnZhbGlkJywgZG9tRWxlbWVudCk7XG5cbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAndGV4dGFyZWEnOlxuICAgICAgaW5pdFdyYXBwZXJTdGF0ZSQyKGRvbUVsZW1lbnQsIHJhd1Byb3BzKTtcbiAgICAgIHByb3BzID0gZ2V0SG9zdFByb3BzJDMoZG9tRWxlbWVudCwgcmF3UHJvcHMpOyAvLyBXZSBsaXN0ZW4gdG8gdGhpcyBldmVudCBpbiBjYXNlIHRvIGVuc3VyZSBlbXVsYXRlZCBidWJibGVcbiAgICAgIC8vIGxpc3RlbmVycyBzdGlsbCBmaXJlIGZvciB0aGUgaW52YWxpZCBldmVudC5cblxuICAgICAgbGlzdGVuVG9Ob25EZWxlZ2F0ZWRFdmVudCgnaW52YWxpZCcsIGRvbUVsZW1lbnQpO1xuXG4gICAgICBicmVhaztcblxuICAgIGRlZmF1bHQ6XG4gICAgICBwcm9wcyA9IHJhd1Byb3BzO1xuICB9XG5cbiAgYXNzZXJ0VmFsaWRQcm9wcyh0YWcsIHByb3BzKTtcbiAgc2V0SW5pdGlhbERPTVByb3BlcnRpZXModGFnLCBkb21FbGVtZW50LCByb290Q29udGFpbmVyRWxlbWVudCwgcHJvcHMsIGlzQ3VzdG9tQ29tcG9uZW50VGFnKTtcblxuICBzd2l0Y2ggKHRhZykge1xuICAgIGNhc2UgJ2lucHV0JzpcbiAgICAgIC8vIFRPRE86IE1ha2Ugc3VyZSB3ZSBjaGVjayBpZiB0aGlzIGlzIHN0aWxsIHVubW91bnRlZCBvciBkbyBhbnkgY2xlYW5cbiAgICAgIC8vIHVwIG5lY2Vzc2FyeSBzaW5jZSB3ZSBuZXZlciBzdG9wIHRyYWNraW5nIGFueW1vcmUuXG4gICAgICB0cmFjayhkb21FbGVtZW50KTtcbiAgICAgIHBvc3RNb3VudFdyYXBwZXIoZG9tRWxlbWVudCwgcmF3UHJvcHMsIGZhbHNlKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAndGV4dGFyZWEnOlxuICAgICAgLy8gVE9ETzogTWFrZSBzdXJlIHdlIGNoZWNrIGlmIHRoaXMgaXMgc3RpbGwgdW5tb3VudGVkIG9yIGRvIGFueSBjbGVhblxuICAgICAgLy8gdXAgbmVjZXNzYXJ5IHNpbmNlIHdlIG5ldmVyIHN0b3AgdHJhY2tpbmcgYW55bW9yZS5cbiAgICAgIHRyYWNrKGRvbUVsZW1lbnQpO1xuICAgICAgcG9zdE1vdW50V3JhcHBlciQzKGRvbUVsZW1lbnQpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdvcHRpb24nOlxuICAgICAgcG9zdE1vdW50V3JhcHBlciQxKGRvbUVsZW1lbnQsIHJhd1Byb3BzKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnc2VsZWN0JzpcbiAgICAgIHBvc3RNb3VudFdyYXBwZXIkMihkb21FbGVtZW50LCByYXdQcm9wcyk7XG4gICAgICBicmVhaztcblxuICAgIGRlZmF1bHQ6XG4gICAgICBpZiAodHlwZW9mIHByb3BzLm9uQ2xpY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gVE9ETzogVGhpcyBjYXN0IG1heSBub3QgYmUgc291bmQgZm9yIFNWRywgTWF0aE1MIG9yIGN1c3RvbSBlbGVtZW50cy5cbiAgICAgICAgdHJhcENsaWNrT25Ob25JbnRlcmFjdGl2ZUVsZW1lbnQoZG9tRWxlbWVudCk7XG4gICAgICB9XG5cbiAgICAgIGJyZWFrO1xuICB9XG59IC8vIENhbGN1bGF0ZSB0aGUgZGlmZiBiZXR3ZWVuIHRoZSB0d28gb2JqZWN0cy5cblxuZnVuY3Rpb24gZGlmZlByb3BlcnRpZXMoZG9tRWxlbWVudCwgdGFnLCBsYXN0UmF3UHJvcHMsIG5leHRSYXdQcm9wcywgcm9vdENvbnRhaW5lckVsZW1lbnQpIHtcbiAge1xuICAgIHZhbGlkYXRlUHJvcGVydGllc0luRGV2ZWxvcG1lbnQodGFnLCBuZXh0UmF3UHJvcHMpO1xuICB9XG5cbiAgdmFyIHVwZGF0ZVBheWxvYWQgPSBudWxsO1xuICB2YXIgbGFzdFByb3BzO1xuICB2YXIgbmV4dFByb3BzO1xuXG4gIHN3aXRjaCAodGFnKSB7XG4gICAgY2FzZSAnaW5wdXQnOlxuICAgICAgbGFzdFByb3BzID0gZ2V0SG9zdFByb3BzKGRvbUVsZW1lbnQsIGxhc3RSYXdQcm9wcyk7XG4gICAgICBuZXh0UHJvcHMgPSBnZXRIb3N0UHJvcHMoZG9tRWxlbWVudCwgbmV4dFJhd1Byb3BzKTtcbiAgICAgIHVwZGF0ZVBheWxvYWQgPSBbXTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnb3B0aW9uJzpcbiAgICAgIGxhc3RQcm9wcyA9IGdldEhvc3RQcm9wcyQxKGRvbUVsZW1lbnQsIGxhc3RSYXdQcm9wcyk7XG4gICAgICBuZXh0UHJvcHMgPSBnZXRIb3N0UHJvcHMkMShkb21FbGVtZW50LCBuZXh0UmF3UHJvcHMpO1xuICAgICAgdXBkYXRlUGF5bG9hZCA9IFtdO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdzZWxlY3QnOlxuICAgICAgbGFzdFByb3BzID0gZ2V0SG9zdFByb3BzJDIoZG9tRWxlbWVudCwgbGFzdFJhd1Byb3BzKTtcbiAgICAgIG5leHRQcm9wcyA9IGdldEhvc3RQcm9wcyQyKGRvbUVsZW1lbnQsIG5leHRSYXdQcm9wcyk7XG4gICAgICB1cGRhdGVQYXlsb2FkID0gW107XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ3RleHRhcmVhJzpcbiAgICAgIGxhc3RQcm9wcyA9IGdldEhvc3RQcm9wcyQzKGRvbUVsZW1lbnQsIGxhc3RSYXdQcm9wcyk7XG4gICAgICBuZXh0UHJvcHMgPSBnZXRIb3N0UHJvcHMkMyhkb21FbGVtZW50LCBuZXh0UmF3UHJvcHMpO1xuICAgICAgdXBkYXRlUGF5bG9hZCA9IFtdO1xuICAgICAgYnJlYWs7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgbGFzdFByb3BzID0gbGFzdFJhd1Byb3BzO1xuICAgICAgbmV4dFByb3BzID0gbmV4dFJhd1Byb3BzO1xuXG4gICAgICBpZiAodHlwZW9mIGxhc3RQcm9wcy5vbkNsaWNrICE9PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBuZXh0UHJvcHMub25DbGljayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyBUT0RPOiBUaGlzIGNhc3QgbWF5IG5vdCBiZSBzb3VuZCBmb3IgU1ZHLCBNYXRoTUwgb3IgY3VzdG9tIGVsZW1lbnRzLlxuICAgICAgICB0cmFwQ2xpY2tPbk5vbkludGVyYWN0aXZlRWxlbWVudChkb21FbGVtZW50KTtcbiAgICAgIH1cblxuICAgICAgYnJlYWs7XG4gIH1cblxuICBhc3NlcnRWYWxpZFByb3BzKHRhZywgbmV4dFByb3BzKTtcbiAgdmFyIHByb3BLZXk7XG4gIHZhciBzdHlsZU5hbWU7XG4gIHZhciBzdHlsZVVwZGF0ZXMgPSBudWxsO1xuXG4gIGZvciAocHJvcEtleSBpbiBsYXN0UHJvcHMpIHtcbiAgICBpZiAobmV4dFByb3BzLmhhc093blByb3BlcnR5KHByb3BLZXkpIHx8ICFsYXN0UHJvcHMuaGFzT3duUHJvcGVydHkocHJvcEtleSkgfHwgbGFzdFByb3BzW3Byb3BLZXldID09IG51bGwpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmIChwcm9wS2V5ID09PSBTVFlMRSkge1xuICAgICAgdmFyIGxhc3RTdHlsZSA9IGxhc3RQcm9wc1twcm9wS2V5XTtcblxuICAgICAgZm9yIChzdHlsZU5hbWUgaW4gbGFzdFN0eWxlKSB7XG4gICAgICAgIGlmIChsYXN0U3R5bGUuaGFzT3duUHJvcGVydHkoc3R5bGVOYW1lKSkge1xuICAgICAgICAgIGlmICghc3R5bGVVcGRhdGVzKSB7XG4gICAgICAgICAgICBzdHlsZVVwZGF0ZXMgPSB7fTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBzdHlsZVVwZGF0ZXNbc3R5bGVOYW1lXSA9ICcnO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChwcm9wS2V5ID09PSBEQU5HRVJPVVNMWV9TRVRfSU5ORVJfSFRNTCB8fCBwcm9wS2V5ID09PSBDSElMRFJFTikgOyBlbHNlIGlmIChwcm9wS2V5ID09PSBTVVBQUkVTU19DT05URU5UX0VESVRBQkxFX1dBUk5JTkcgfHwgcHJvcEtleSA9PT0gU1VQUFJFU1NfSFlEUkFUSU9OX1dBUk5JTkcpIDsgZWxzZSBpZiAocHJvcEtleSA9PT0gQVVUT0ZPQ1VTKSA7IGVsc2UgaWYgKHJlZ2lzdHJhdGlvbk5hbWVEZXBlbmRlbmNpZXMuaGFzT3duUHJvcGVydHkocHJvcEtleSkpIHtcbiAgICAgIC8vIFRoaXMgaXMgYSBzcGVjaWFsIGNhc2UuIElmIGFueSBsaXN0ZW5lciB1cGRhdGVzIHdlIG5lZWQgdG8gZW5zdXJlXG4gICAgICAvLyB0aGF0IHRoZSBcImN1cnJlbnRcIiBmaWJlciBwb2ludGVyIGdldHMgdXBkYXRlZCBzbyB3ZSBuZWVkIGEgY29tbWl0XG4gICAgICAvLyB0byB1cGRhdGUgdGhpcyBlbGVtZW50LlxuICAgICAgaWYgKCF1cGRhdGVQYXlsb2FkKSB7XG4gICAgICAgIHVwZGF0ZVBheWxvYWQgPSBbXTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRm9yIGFsbCBvdGhlciBkZWxldGVkIHByb3BlcnRpZXMgd2UgYWRkIGl0IHRvIHRoZSBxdWV1ZS4gV2UgdXNlXG4gICAgICAvLyB0aGUgYWxsb3dlZCBwcm9wZXJ0eSBsaXN0IGluIHRoZSBjb21taXQgcGhhc2UgaW5zdGVhZC5cbiAgICAgICh1cGRhdGVQYXlsb2FkID0gdXBkYXRlUGF5bG9hZCB8fCBbXSkucHVzaChwcm9wS2V5LCBudWxsKTtcbiAgICB9XG4gIH1cblxuICBmb3IgKHByb3BLZXkgaW4gbmV4dFByb3BzKSB7XG4gICAgdmFyIG5leHRQcm9wID0gbmV4dFByb3BzW3Byb3BLZXldO1xuICAgIHZhciBsYXN0UHJvcCA9IGxhc3RQcm9wcyAhPSBudWxsID8gbGFzdFByb3BzW3Byb3BLZXldIDogdW5kZWZpbmVkO1xuXG4gICAgaWYgKCFuZXh0UHJvcHMuaGFzT3duUHJvcGVydHkocHJvcEtleSkgfHwgbmV4dFByb3AgPT09IGxhc3RQcm9wIHx8IG5leHRQcm9wID09IG51bGwgJiYgbGFzdFByb3AgPT0gbnVsbCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKHByb3BLZXkgPT09IFNUWUxFKSB7XG4gICAgICB7XG4gICAgICAgIGlmIChuZXh0UHJvcCkge1xuICAgICAgICAgIC8vIEZyZWV6ZSB0aGUgbmV4dCBzdHlsZSBvYmplY3Qgc28gdGhhdCB3ZSBjYW4gYXNzdW1lIGl0IHdvbid0IGJlXG4gICAgICAgICAgLy8gbXV0YXRlZC4gV2UgaGF2ZSBhbHJlYWR5IHdhcm5lZCBmb3IgdGhpcyBpbiB0aGUgcGFzdC5cbiAgICAgICAgICBPYmplY3QuZnJlZXplKG5leHRQcm9wKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAobGFzdFByb3ApIHtcbiAgICAgICAgLy8gVW5zZXQgc3R5bGVzIG9uIGBsYXN0UHJvcGAgYnV0IG5vdCBvbiBgbmV4dFByb3BgLlxuICAgICAgICBmb3IgKHN0eWxlTmFtZSBpbiBsYXN0UHJvcCkge1xuICAgICAgICAgIGlmIChsYXN0UHJvcC5oYXNPd25Qcm9wZXJ0eShzdHlsZU5hbWUpICYmICghbmV4dFByb3AgfHwgIW5leHRQcm9wLmhhc093blByb3BlcnR5KHN0eWxlTmFtZSkpKSB7XG4gICAgICAgICAgICBpZiAoIXN0eWxlVXBkYXRlcykge1xuICAgICAgICAgICAgICBzdHlsZVVwZGF0ZXMgPSB7fTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc3R5bGVVcGRhdGVzW3N0eWxlTmFtZV0gPSAnJztcbiAgICAgICAgICB9XG4gICAgICAgIH0gLy8gVXBkYXRlIHN0eWxlcyB0aGF0IGNoYW5nZWQgc2luY2UgYGxhc3RQcm9wYC5cblxuXG4gICAgICAgIGZvciAoc3R5bGVOYW1lIGluIG5leHRQcm9wKSB7XG4gICAgICAgICAgaWYgKG5leHRQcm9wLmhhc093blByb3BlcnR5KHN0eWxlTmFtZSkgJiYgbGFzdFByb3Bbc3R5bGVOYW1lXSAhPT0gbmV4dFByb3Bbc3R5bGVOYW1lXSkge1xuICAgICAgICAgICAgaWYgKCFzdHlsZVVwZGF0ZXMpIHtcbiAgICAgICAgICAgICAgc3R5bGVVcGRhdGVzID0ge307XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHN0eWxlVXBkYXRlc1tzdHlsZU5hbWVdID0gbmV4dFByb3Bbc3R5bGVOYW1lXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFJlbGllcyBvbiBgdXBkYXRlU3R5bGVzQnlJRGAgbm90IG11dGF0aW5nIGBzdHlsZVVwZGF0ZXNgLlxuICAgICAgICBpZiAoIXN0eWxlVXBkYXRlcykge1xuICAgICAgICAgIGlmICghdXBkYXRlUGF5bG9hZCkge1xuICAgICAgICAgICAgdXBkYXRlUGF5bG9hZCA9IFtdO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHVwZGF0ZVBheWxvYWQucHVzaChwcm9wS2V5LCBzdHlsZVVwZGF0ZXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgc3R5bGVVcGRhdGVzID0gbmV4dFByb3A7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChwcm9wS2V5ID09PSBEQU5HRVJPVVNMWV9TRVRfSU5ORVJfSFRNTCkge1xuICAgICAgdmFyIG5leHRIdG1sID0gbmV4dFByb3AgPyBuZXh0UHJvcFtIVE1MJDFdIDogdW5kZWZpbmVkO1xuICAgICAgdmFyIGxhc3RIdG1sID0gbGFzdFByb3AgPyBsYXN0UHJvcFtIVE1MJDFdIDogdW5kZWZpbmVkO1xuXG4gICAgICBpZiAobmV4dEh0bWwgIT0gbnVsbCkge1xuICAgICAgICBpZiAobGFzdEh0bWwgIT09IG5leHRIdG1sKSB7XG4gICAgICAgICAgKHVwZGF0ZVBheWxvYWQgPSB1cGRhdGVQYXlsb2FkIHx8IFtdKS5wdXNoKHByb3BLZXksIG5leHRIdG1sKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocHJvcEtleSA9PT0gQ0hJTERSRU4pIHtcbiAgICAgIGlmICh0eXBlb2YgbmV4dFByb3AgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBuZXh0UHJvcCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgKHVwZGF0ZVBheWxvYWQgPSB1cGRhdGVQYXlsb2FkIHx8IFtdKS5wdXNoKHByb3BLZXksICcnICsgbmV4dFByb3ApO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocHJvcEtleSA9PT0gU1VQUFJFU1NfQ09OVEVOVF9FRElUQUJMRV9XQVJOSU5HIHx8IHByb3BLZXkgPT09IFNVUFBSRVNTX0hZRFJBVElPTl9XQVJOSU5HKSA7IGVsc2UgaWYgKHJlZ2lzdHJhdGlvbk5hbWVEZXBlbmRlbmNpZXMuaGFzT3duUHJvcGVydHkocHJvcEtleSkpIHtcbiAgICAgIGlmIChuZXh0UHJvcCAhPSBudWxsKSB7XG4gICAgICAgIC8vIFdlIGVhZ2VybHkgbGlzdGVuIHRvIHRoaXMgZXZlbiB0aG91Z2ggd2UgaGF2ZW4ndCBjb21taXR0ZWQgeWV0LlxuICAgICAgICBpZiAoIHR5cGVvZiBuZXh0UHJvcCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHdhcm5Gb3JJbnZhbGlkRXZlbnRMaXN0ZW5lcihwcm9wS2V5LCBuZXh0UHJvcCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocHJvcEtleSA9PT0gJ29uU2Nyb2xsJykge1xuICAgICAgICAgIGxpc3RlblRvTm9uRGVsZWdhdGVkRXZlbnQoJ3Njcm9sbCcsIGRvbUVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICghdXBkYXRlUGF5bG9hZCAmJiBsYXN0UHJvcCAhPT0gbmV4dFByb3ApIHtcbiAgICAgICAgLy8gVGhpcyBpcyBhIHNwZWNpYWwgY2FzZS4gSWYgYW55IGxpc3RlbmVyIHVwZGF0ZXMgd2UgbmVlZCB0byBlbnN1cmVcbiAgICAgICAgLy8gdGhhdCB0aGUgXCJjdXJyZW50XCIgcHJvcHMgcG9pbnRlciBnZXRzIHVwZGF0ZWQgc28gd2UgbmVlZCBhIGNvbW1pdFxuICAgICAgICAvLyB0byB1cGRhdGUgdGhpcyBlbGVtZW50LlxuICAgICAgICB1cGRhdGVQYXlsb2FkID0gW107XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgbmV4dFByb3AgPT09ICdvYmplY3QnICYmIG5leHRQcm9wICE9PSBudWxsICYmIG5leHRQcm9wLiQkdHlwZW9mID09PSBSRUFDVF9PUEFRVUVfSURfVFlQRSkge1xuICAgICAgLy8gSWYgd2UgZW5jb3VudGVyIHVzZU9wYXF1ZVJlZmVyZW5jZSdzIG9wYXF1ZSBvYmplY3QsIHRoaXMgbWVhbnMgd2UgYXJlIGh5ZHJhdGluZy5cbiAgICAgIC8vIEluIHRoaXMgY2FzZSwgY2FsbCB0aGUgb3BhcXVlIG9iamVjdCdzIHRvU3RyaW5nIGZ1bmN0aW9uIHdoaWNoIGdlbmVyYXRlcyBhIG5ldyBjbGllbnRcbiAgICAgIC8vIElEIHNvIGNsaWVudCBhbmQgc2VydmVyIElEcyBtYXRjaCBhbmQgdGhyb3dzIHRvIHJlcmVuZGVyLlxuICAgICAgbmV4dFByb3AudG9TdHJpbmcoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRm9yIGFueSBvdGhlciBwcm9wZXJ0eSB3ZSBhbHdheXMgYWRkIGl0IHRvIHRoZSBxdWV1ZSBhbmQgdGhlbiB3ZVxuICAgICAgLy8gZmlsdGVyIGl0IG91dCB1c2luZyB0aGUgYWxsb3dlZCBwcm9wZXJ0eSBsaXN0IGR1cmluZyB0aGUgY29tbWl0LlxuICAgICAgKHVwZGF0ZVBheWxvYWQgPSB1cGRhdGVQYXlsb2FkIHx8IFtdKS5wdXNoKHByb3BLZXksIG5leHRQcm9wKTtcbiAgICB9XG4gIH1cblxuICBpZiAoc3R5bGVVcGRhdGVzKSB7XG4gICAge1xuICAgICAgdmFsaWRhdGVTaG9ydGhhbmRQcm9wZXJ0eUNvbGxpc2lvbkluRGV2KHN0eWxlVXBkYXRlcywgbmV4dFByb3BzW1NUWUxFXSk7XG4gICAgfVxuXG4gICAgKHVwZGF0ZVBheWxvYWQgPSB1cGRhdGVQYXlsb2FkIHx8IFtdKS5wdXNoKFNUWUxFLCBzdHlsZVVwZGF0ZXMpO1xuICB9XG5cbiAgcmV0dXJuIHVwZGF0ZVBheWxvYWQ7XG59IC8vIEFwcGx5IHRoZSBkaWZmLlxuXG5mdW5jdGlvbiB1cGRhdGVQcm9wZXJ0aWVzKGRvbUVsZW1lbnQsIHVwZGF0ZVBheWxvYWQsIHRhZywgbGFzdFJhd1Byb3BzLCBuZXh0UmF3UHJvcHMpIHtcbiAgLy8gVXBkYXRlIGNoZWNrZWQgKmJlZm9yZSogbmFtZS5cbiAgLy8gSW4gdGhlIG1pZGRsZSBvZiBhbiB1cGRhdGUsIGl0IGlzIHBvc3NpYmxlIHRvIGhhdmUgbXVsdGlwbGUgY2hlY2tlZC5cbiAgLy8gV2hlbiBhIGNoZWNrZWQgcmFkaW8gdHJpZXMgdG8gY2hhbmdlIG5hbWUsIGJyb3dzZXIgbWFrZXMgYW5vdGhlciByYWRpbydzIGNoZWNrZWQgZmFsc2UuXG4gIGlmICh0YWcgPT09ICdpbnB1dCcgJiYgbmV4dFJhd1Byb3BzLnR5cGUgPT09ICdyYWRpbycgJiYgbmV4dFJhd1Byb3BzLm5hbWUgIT0gbnVsbCkge1xuICAgIHVwZGF0ZUNoZWNrZWQoZG9tRWxlbWVudCwgbmV4dFJhd1Byb3BzKTtcbiAgfVxuXG4gIHZhciB3YXNDdXN0b21Db21wb25lbnRUYWcgPSBpc0N1c3RvbUNvbXBvbmVudCh0YWcsIGxhc3RSYXdQcm9wcyk7XG4gIHZhciBpc0N1c3RvbUNvbXBvbmVudFRhZyA9IGlzQ3VzdG9tQ29tcG9uZW50KHRhZywgbmV4dFJhd1Byb3BzKTsgLy8gQXBwbHkgdGhlIGRpZmYuXG5cbiAgdXBkYXRlRE9NUHJvcGVydGllcyhkb21FbGVtZW50LCB1cGRhdGVQYXlsb2FkLCB3YXNDdXN0b21Db21wb25lbnRUYWcsIGlzQ3VzdG9tQ29tcG9uZW50VGFnKTsgLy8gVE9ETzogRW5zdXJlIHRoYXQgYW4gdXBkYXRlIGdldHMgc2NoZWR1bGVkIGlmIGFueSBvZiB0aGUgc3BlY2lhbCBwcm9wc1xuICAvLyBjaGFuZ2VkLlxuXG4gIHN3aXRjaCAodGFnKSB7XG4gICAgY2FzZSAnaW5wdXQnOlxuICAgICAgLy8gVXBkYXRlIHRoZSB3cmFwcGVyIGFyb3VuZCBpbnB1dHMgKmFmdGVyKiB1cGRhdGluZyBwcm9wcy4gVGhpcyBoYXMgdG9cbiAgICAgIC8vIGhhcHBlbiBhZnRlciBgdXBkYXRlRE9NUHJvcGVydGllc2AuIE90aGVyd2lzZSBIVE1MNSBpbnB1dCB2YWxpZGF0aW9uc1xuICAgICAgLy8gcmFpc2Ugd2FybmluZ3MgYW5kIHByZXZlbnQgdGhlIG5ldyB2YWx1ZSBmcm9tIGJlaW5nIGFzc2lnbmVkLlxuICAgICAgdXBkYXRlV3JhcHBlcihkb21FbGVtZW50LCBuZXh0UmF3UHJvcHMpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICd0ZXh0YXJlYSc6XG4gICAgICB1cGRhdGVXcmFwcGVyJDEoZG9tRWxlbWVudCwgbmV4dFJhd1Byb3BzKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnc2VsZWN0JzpcbiAgICAgIC8vIDxzZWxlY3Q+IHZhbHVlIHVwZGF0ZSBuZWVkcyB0byBvY2N1ciBhZnRlciA8b3B0aW9uPiBjaGlsZHJlblxuICAgICAgLy8gcmVjb25jaWxpYXRpb25cbiAgICAgIHBvc3RVcGRhdGVXcmFwcGVyKGRvbUVsZW1lbnQsIG5leHRSYXdQcm9wcyk7XG4gICAgICBicmVhaztcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRQb3NzaWJsZVN0YW5kYXJkTmFtZShwcm9wTmFtZSkge1xuICB7XG4gICAgdmFyIGxvd2VyQ2FzZWROYW1lID0gcHJvcE5hbWUudG9Mb3dlckNhc2UoKTtcblxuICAgIGlmICghcG9zc2libGVTdGFuZGFyZE5hbWVzLmhhc093blByb3BlcnR5KGxvd2VyQ2FzZWROYW1lKSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBvc3NpYmxlU3RhbmRhcmROYW1lc1tsb3dlckNhc2VkTmFtZV0gfHwgbnVsbDtcbiAgfVxufVxuXG5mdW5jdGlvbiBkaWZmSHlkcmF0ZWRQcm9wZXJ0aWVzKGRvbUVsZW1lbnQsIHRhZywgcmF3UHJvcHMsIHBhcmVudE5hbWVzcGFjZSwgcm9vdENvbnRhaW5lckVsZW1lbnQpIHtcbiAgdmFyIGlzQ3VzdG9tQ29tcG9uZW50VGFnO1xuICB2YXIgZXh0cmFBdHRyaWJ1dGVOYW1lcztcblxuICB7XG4gICAgc3VwcHJlc3NIeWRyYXRpb25XYXJuaW5nID0gcmF3UHJvcHNbU1VQUFJFU1NfSFlEUkFUSU9OX1dBUk5JTkddID09PSB0cnVlO1xuICAgIGlzQ3VzdG9tQ29tcG9uZW50VGFnID0gaXNDdXN0b21Db21wb25lbnQodGFnLCByYXdQcm9wcyk7XG4gICAgdmFsaWRhdGVQcm9wZXJ0aWVzSW5EZXZlbG9wbWVudCh0YWcsIHJhd1Byb3BzKTtcbiAgfSAvLyBUT0RPOiBNYWtlIHN1cmUgdGhhdCB3ZSBjaGVjayBpc01vdW50ZWQgYmVmb3JlIGZpcmluZyBhbnkgb2YgdGhlc2UgZXZlbnRzLlxuXG5cbiAgc3dpdGNoICh0YWcpIHtcbiAgICBjYXNlICdkaWFsb2cnOlxuICAgICAgbGlzdGVuVG9Ob25EZWxlZ2F0ZWRFdmVudCgnY2FuY2VsJywgZG9tRWxlbWVudCk7XG4gICAgICBsaXN0ZW5Ub05vbkRlbGVnYXRlZEV2ZW50KCdjbG9zZScsIGRvbUVsZW1lbnQpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdpZnJhbWUnOlxuICAgIGNhc2UgJ29iamVjdCc6XG4gICAgY2FzZSAnZW1iZWQnOlxuICAgICAgLy8gV2UgbGlzdGVuIHRvIHRoaXMgZXZlbnQgaW4gY2FzZSB0byBlbnN1cmUgZW11bGF0ZWQgYnViYmxlXG4gICAgICAvLyBsaXN0ZW5lcnMgc3RpbGwgZmlyZSBmb3IgdGhlIGxvYWQgZXZlbnQuXG4gICAgICBsaXN0ZW5Ub05vbkRlbGVnYXRlZEV2ZW50KCdsb2FkJywgZG9tRWxlbWVudCk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ3ZpZGVvJzpcbiAgICBjYXNlICdhdWRpbyc6XG4gICAgICAvLyBXZSBsaXN0ZW4gdG8gdGhlc2UgZXZlbnRzIGluIGNhc2UgdG8gZW5zdXJlIGVtdWxhdGVkIGJ1YmJsZVxuICAgICAgLy8gbGlzdGVuZXJzIHN0aWxsIGZpcmUgZm9yIGFsbCB0aGUgbWVkaWEgZXZlbnRzLlxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZWRpYUV2ZW50VHlwZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGlzdGVuVG9Ob25EZWxlZ2F0ZWRFdmVudChtZWRpYUV2ZW50VHlwZXNbaV0sIGRvbUVsZW1lbnQpO1xuICAgICAgfVxuXG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ3NvdXJjZSc6XG4gICAgICAvLyBXZSBsaXN0ZW4gdG8gdGhpcyBldmVudCBpbiBjYXNlIHRvIGVuc3VyZSBlbXVsYXRlZCBidWJibGVcbiAgICAgIC8vIGxpc3RlbmVycyBzdGlsbCBmaXJlIGZvciB0aGUgZXJyb3IgZXZlbnQuXG4gICAgICBsaXN0ZW5Ub05vbkRlbGVnYXRlZEV2ZW50KCdlcnJvcicsIGRvbUVsZW1lbnQpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdpbWcnOlxuICAgIGNhc2UgJ2ltYWdlJzpcbiAgICBjYXNlICdsaW5rJzpcbiAgICAgIC8vIFdlIGxpc3RlbiB0byB0aGVzZSBldmVudHMgaW4gY2FzZSB0byBlbnN1cmUgZW11bGF0ZWQgYnViYmxlXG4gICAgICAvLyBsaXN0ZW5lcnMgc3RpbGwgZmlyZSBmb3IgZXJyb3IgYW5kIGxvYWQgZXZlbnRzLlxuICAgICAgbGlzdGVuVG9Ob25EZWxlZ2F0ZWRFdmVudCgnZXJyb3InLCBkb21FbGVtZW50KTtcbiAgICAgIGxpc3RlblRvTm9uRGVsZWdhdGVkRXZlbnQoJ2xvYWQnLCBkb21FbGVtZW50KTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnZGV0YWlscyc6XG4gICAgICAvLyBXZSBsaXN0ZW4gdG8gdGhpcyBldmVudCBpbiBjYXNlIHRvIGVuc3VyZSBlbXVsYXRlZCBidWJibGVcbiAgICAgIC8vIGxpc3RlbmVycyBzdGlsbCBmaXJlIGZvciB0aGUgdG9nZ2xlIGV2ZW50LlxuICAgICAgbGlzdGVuVG9Ob25EZWxlZ2F0ZWRFdmVudCgndG9nZ2xlJywgZG9tRWxlbWVudCk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ2lucHV0JzpcbiAgICAgIGluaXRXcmFwcGVyU3RhdGUoZG9tRWxlbWVudCwgcmF3UHJvcHMpOyAvLyBXZSBsaXN0ZW4gdG8gdGhpcyBldmVudCBpbiBjYXNlIHRvIGVuc3VyZSBlbXVsYXRlZCBidWJibGVcbiAgICAgIC8vIGxpc3RlbmVycyBzdGlsbCBmaXJlIGZvciB0aGUgaW52YWxpZCBldmVudC5cblxuICAgICAgbGlzdGVuVG9Ob25EZWxlZ2F0ZWRFdmVudCgnaW52YWxpZCcsIGRvbUVsZW1lbnQpO1xuXG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ29wdGlvbic6XG4gICAgICB2YWxpZGF0ZVByb3BzKGRvbUVsZW1lbnQsIHJhd1Byb3BzKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnc2VsZWN0JzpcbiAgICAgIGluaXRXcmFwcGVyU3RhdGUkMShkb21FbGVtZW50LCByYXdQcm9wcyk7IC8vIFdlIGxpc3RlbiB0byB0aGlzIGV2ZW50IGluIGNhc2UgdG8gZW5zdXJlIGVtdWxhdGVkIGJ1YmJsZVxuICAgICAgLy8gbGlzdGVuZXJzIHN0aWxsIGZpcmUgZm9yIHRoZSBpbnZhbGlkIGV2ZW50LlxuXG4gICAgICBsaXN0ZW5Ub05vbkRlbGVnYXRlZEV2ZW50KCdpbnZhbGlkJywgZG9tRWxlbWVudCk7XG5cbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAndGV4dGFyZWEnOlxuICAgICAgaW5pdFdyYXBwZXJTdGF0ZSQyKGRvbUVsZW1lbnQsIHJhd1Byb3BzKTsgLy8gV2UgbGlzdGVuIHRvIHRoaXMgZXZlbnQgaW4gY2FzZSB0byBlbnN1cmUgZW11bGF0ZWQgYnViYmxlXG4gICAgICAvLyBsaXN0ZW5lcnMgc3RpbGwgZmlyZSBmb3IgdGhlIGludmFsaWQgZXZlbnQuXG5cbiAgICAgIGxpc3RlblRvTm9uRGVsZWdhdGVkRXZlbnQoJ2ludmFsaWQnLCBkb21FbGVtZW50KTtcblxuICAgICAgYnJlYWs7XG4gIH1cblxuICBhc3NlcnRWYWxpZFByb3BzKHRhZywgcmF3UHJvcHMpO1xuXG4gIHtcbiAgICBleHRyYUF0dHJpYnV0ZU5hbWVzID0gbmV3IFNldCgpO1xuICAgIHZhciBhdHRyaWJ1dGVzID0gZG9tRWxlbWVudC5hdHRyaWJ1dGVzO1xuXG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGF0dHJpYnV0ZXMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICB2YXIgbmFtZSA9IGF0dHJpYnV0ZXNbX2ldLm5hbWUudG9Mb3dlckNhc2UoKTtcblxuICAgICAgc3dpdGNoIChuYW1lKSB7XG4gICAgICAgIC8vIEJ1aWx0LWluIFNTUiBhdHRyaWJ1dGUgaXMgYWxsb3dlZFxuICAgICAgICBjYXNlICdkYXRhLXJlYWN0cm9vdCc6XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIC8vIENvbnRyb2xsZWQgYXR0cmlidXRlcyBhcmUgbm90IHZhbGlkYXRlZFxuICAgICAgICAvLyBUT0RPOiBPbmx5IGlnbm9yZSB0aGVtIG9uIGNvbnRyb2xsZWQgdGFncy5cblxuICAgICAgICBjYXNlICd2YWx1ZSc6XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnY2hlY2tlZCc6XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnc2VsZWN0ZWQnOlxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgLy8gSW50ZW50aW9uYWxseSB1c2UgdGhlIG9yaWdpbmFsIG5hbWUuXG4gICAgICAgICAgLy8gU2VlIGRpc2N1c3Npb24gaW4gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L3B1bGwvMTA2NzYuXG4gICAgICAgICAgZXh0cmFBdHRyaWJ1dGVOYW1lcy5hZGQoYXR0cmlidXRlc1tfaV0ubmFtZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIHVwZGF0ZVBheWxvYWQgPSBudWxsO1xuXG4gIGZvciAodmFyIHByb3BLZXkgaW4gcmF3UHJvcHMpIHtcbiAgICBpZiAoIXJhd1Byb3BzLmhhc093blByb3BlcnR5KHByb3BLZXkpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICB2YXIgbmV4dFByb3AgPSByYXdQcm9wc1twcm9wS2V5XTtcblxuICAgIGlmIChwcm9wS2V5ID09PSBDSElMRFJFTikge1xuICAgICAgLy8gRm9yIHRleHQgY29udGVudCBjaGlsZHJlbiB3ZSBjb21wYXJlIGFnYWluc3QgdGV4dENvbnRlbnQuIFRoaXNcbiAgICAgIC8vIG1pZ2h0IG1hdGNoIGFkZGl0aW9uYWwgSFRNTCB0aGF0IGlzIGhpZGRlbiB3aGVuIHdlIHJlYWQgaXQgdXNpbmdcbiAgICAgIC8vIHRleHRDb250ZW50LiBFLmcuIFwiZm9vXCIgd2lsbCBtYXRjaCBcImY8c3Bhbj5vbzwvc3Bhbj5cIiBidXQgdGhhdCBzdGlsbFxuICAgICAgLy8gc2F0aXNmaWVzIG91ciByZXF1aXJlbWVudC4gT3VyIHJlcXVpcmVtZW50IGlzIG5vdCB0byBwcm9kdWNlIHBlcmZlY3RcbiAgICAgIC8vIEhUTUwgYW5kIGF0dHJpYnV0ZXMuIElkZWFsbHkgd2Ugc2hvdWxkIHByZXNlcnZlIHN0cnVjdHVyZSBidXQgaXQnc1xuICAgICAgLy8gb2sgbm90IHRvIGlmIHRoZSB2aXNpYmxlIGNvbnRlbnQgaXMgc3RpbGwgZW5vdWdoIHRvIGluZGljYXRlIHdoYXRcbiAgICAgIC8vIGV2ZW4gbGlzdGVuZXJzIHRoZXNlIG5vZGVzIG1pZ2h0IGJlIHdpcmVkIHVwIHRvLlxuICAgICAgLy8gVE9ETzogV2FybiBpZiB0aGVyZSBpcyBtb3JlIHRoYW4gYSBzaW5nbGUgdGV4dE5vZGUgYXMgYSBjaGlsZC5cbiAgICAgIC8vIFRPRE86IFNob3VsZCB3ZSB1c2UgZG9tRWxlbWVudC5maXJzdENoaWxkLm5vZGVWYWx1ZSB0byBjb21wYXJlP1xuICAgICAgaWYgKHR5cGVvZiBuZXh0UHJvcCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgaWYgKGRvbUVsZW1lbnQudGV4dENvbnRlbnQgIT09IG5leHRQcm9wKSB7XG4gICAgICAgICAgaWYgKCAhc3VwcHJlc3NIeWRyYXRpb25XYXJuaW5nKSB7XG4gICAgICAgICAgICB3YXJuRm9yVGV4dERpZmZlcmVuY2UoZG9tRWxlbWVudC50ZXh0Q29udGVudCwgbmV4dFByb3ApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHVwZGF0ZVBheWxvYWQgPSBbQ0hJTERSRU4sIG5leHRQcm9wXTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgbmV4dFByb3AgPT09ICdudW1iZXInKSB7XG4gICAgICAgIGlmIChkb21FbGVtZW50LnRleHRDb250ZW50ICE9PSAnJyArIG5leHRQcm9wKSB7XG4gICAgICAgICAgaWYgKCAhc3VwcHJlc3NIeWRyYXRpb25XYXJuaW5nKSB7XG4gICAgICAgICAgICB3YXJuRm9yVGV4dERpZmZlcmVuY2UoZG9tRWxlbWVudC50ZXh0Q29udGVudCwgbmV4dFByb3ApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHVwZGF0ZVBheWxvYWQgPSBbQ0hJTERSRU4sICcnICsgbmV4dFByb3BdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChyZWdpc3RyYXRpb25OYW1lRGVwZW5kZW5jaWVzLmhhc093blByb3BlcnR5KHByb3BLZXkpKSB7XG4gICAgICBpZiAobmV4dFByb3AgIT0gbnVsbCkge1xuICAgICAgICBpZiAoIHR5cGVvZiBuZXh0UHJvcCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHdhcm5Gb3JJbnZhbGlkRXZlbnRMaXN0ZW5lcihwcm9wS2V5LCBuZXh0UHJvcCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocHJvcEtleSA9PT0gJ29uU2Nyb2xsJykge1xuICAgICAgICAgIGxpc3RlblRvTm9uRGVsZWdhdGVkRXZlbnQoJ3Njcm9sbCcsIGRvbUVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICggLy8gQ29udmluY2UgRmxvdyB3ZSd2ZSBjYWxjdWxhdGVkIGl0IChpdCdzIERFVi1vbmx5IGluIHRoaXMgbWV0aG9kLilcbiAgICB0eXBlb2YgaXNDdXN0b21Db21wb25lbnRUYWcgPT09ICdib29sZWFuJykge1xuICAgICAgLy8gVmFsaWRhdGUgdGhhdCB0aGUgcHJvcGVydGllcyBjb3JyZXNwb25kIHRvIHRoZWlyIGV4cGVjdGVkIHZhbHVlcy5cbiAgICAgIHZhciBzZXJ2ZXJWYWx1ZSA9IHZvaWQgMDtcbiAgICAgIHZhciBwcm9wZXJ0eUluZm8gPSBnZXRQcm9wZXJ0eUluZm8ocHJvcEtleSk7XG5cbiAgICAgIGlmIChzdXBwcmVzc0h5ZHJhdGlvbldhcm5pbmcpIDsgZWxzZSBpZiAocHJvcEtleSA9PT0gU1VQUFJFU1NfQ09OVEVOVF9FRElUQUJMRV9XQVJOSU5HIHx8IHByb3BLZXkgPT09IFNVUFBSRVNTX0hZRFJBVElPTl9XQVJOSU5HIHx8IC8vIENvbnRyb2xsZWQgYXR0cmlidXRlcyBhcmUgbm90IHZhbGlkYXRlZFxuICAgICAgLy8gVE9ETzogT25seSBpZ25vcmUgdGhlbSBvbiBjb250cm9sbGVkIHRhZ3MuXG4gICAgICBwcm9wS2V5ID09PSAndmFsdWUnIHx8IHByb3BLZXkgPT09ICdjaGVja2VkJyB8fCBwcm9wS2V5ID09PSAnc2VsZWN0ZWQnKSA7IGVsc2UgaWYgKHByb3BLZXkgPT09IERBTkdFUk9VU0xZX1NFVF9JTk5FUl9IVE1MKSB7XG4gICAgICAgIHZhciBzZXJ2ZXJIVE1MID0gZG9tRWxlbWVudC5pbm5lckhUTUw7XG4gICAgICAgIHZhciBuZXh0SHRtbCA9IG5leHRQcm9wID8gbmV4dFByb3BbSFRNTCQxXSA6IHVuZGVmaW5lZDtcblxuICAgICAgICBpZiAobmV4dEh0bWwgIT0gbnVsbCkge1xuICAgICAgICAgIHZhciBleHBlY3RlZEhUTUwgPSBub3JtYWxpemVIVE1MKGRvbUVsZW1lbnQsIG5leHRIdG1sKTtcblxuICAgICAgICAgIGlmIChleHBlY3RlZEhUTUwgIT09IHNlcnZlckhUTUwpIHtcbiAgICAgICAgICAgIHdhcm5Gb3JQcm9wRGlmZmVyZW5jZShwcm9wS2V5LCBzZXJ2ZXJIVE1MLCBleHBlY3RlZEhUTUwpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChwcm9wS2V5ID09PSBTVFlMRSkge1xuICAgICAgICAvLyAkRmxvd0ZpeE1lIC0gU2hvdWxkIGJlIGluZmVycmVkIGFzIG5vdCB1bmRlZmluZWQuXG4gICAgICAgIGV4dHJhQXR0cmlidXRlTmFtZXMuZGVsZXRlKHByb3BLZXkpO1xuXG4gICAgICAgIGlmIChjYW5EaWZmU3R5bGVGb3JIeWRyYXRpb25XYXJuaW5nKSB7XG4gICAgICAgICAgdmFyIGV4cGVjdGVkU3R5bGUgPSBjcmVhdGVEYW5nZXJvdXNTdHJpbmdGb3JTdHlsZXMobmV4dFByb3ApO1xuICAgICAgICAgIHNlcnZlclZhbHVlID0gZG9tRWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3N0eWxlJyk7XG5cbiAgICAgICAgICBpZiAoZXhwZWN0ZWRTdHlsZSAhPT0gc2VydmVyVmFsdWUpIHtcbiAgICAgICAgICAgIHdhcm5Gb3JQcm9wRGlmZmVyZW5jZShwcm9wS2V5LCBzZXJ2ZXJWYWx1ZSwgZXhwZWN0ZWRTdHlsZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGlzQ3VzdG9tQ29tcG9uZW50VGFnKSB7XG4gICAgICAgIC8vICRGbG93Rml4TWUgLSBTaG91bGQgYmUgaW5mZXJyZWQgYXMgbm90IHVuZGVmaW5lZC5cbiAgICAgICAgZXh0cmFBdHRyaWJ1dGVOYW1lcy5kZWxldGUocHJvcEtleS50b0xvd2VyQ2FzZSgpKTtcbiAgICAgICAgc2VydmVyVmFsdWUgPSBnZXRWYWx1ZUZvckF0dHJpYnV0ZShkb21FbGVtZW50LCBwcm9wS2V5LCBuZXh0UHJvcCk7XG5cbiAgICAgICAgaWYgKG5leHRQcm9wICE9PSBzZXJ2ZXJWYWx1ZSkge1xuICAgICAgICAgIHdhcm5Gb3JQcm9wRGlmZmVyZW5jZShwcm9wS2V5LCBzZXJ2ZXJWYWx1ZSwgbmV4dFByb3ApO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKCFzaG91bGRJZ25vcmVBdHRyaWJ1dGUocHJvcEtleSwgcHJvcGVydHlJbmZvLCBpc0N1c3RvbUNvbXBvbmVudFRhZykgJiYgIXNob3VsZFJlbW92ZUF0dHJpYnV0ZShwcm9wS2V5LCBuZXh0UHJvcCwgcHJvcGVydHlJbmZvLCBpc0N1c3RvbUNvbXBvbmVudFRhZykpIHtcbiAgICAgICAgdmFyIGlzTWlzbWF0Y2hEdWVUb0JhZENhc2luZyA9IGZhbHNlO1xuXG4gICAgICAgIGlmIChwcm9wZXJ0eUluZm8gIT09IG51bGwpIHtcbiAgICAgICAgICAvLyAkRmxvd0ZpeE1lIC0gU2hvdWxkIGJlIGluZmVycmVkIGFzIG5vdCB1bmRlZmluZWQuXG4gICAgICAgICAgZXh0cmFBdHRyaWJ1dGVOYW1lcy5kZWxldGUocHJvcGVydHlJbmZvLmF0dHJpYnV0ZU5hbWUpO1xuICAgICAgICAgIHNlcnZlclZhbHVlID0gZ2V0VmFsdWVGb3JQcm9wZXJ0eShkb21FbGVtZW50LCBwcm9wS2V5LCBuZXh0UHJvcCwgcHJvcGVydHlJbmZvKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgb3duTmFtZXNwYWNlID0gcGFyZW50TmFtZXNwYWNlO1xuXG4gICAgICAgICAgaWYgKG93bk5hbWVzcGFjZSA9PT0gSFRNTF9OQU1FU1BBQ0UkMSkge1xuICAgICAgICAgICAgb3duTmFtZXNwYWNlID0gZ2V0SW50cmluc2ljTmFtZXNwYWNlKHRhZyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKG93bk5hbWVzcGFjZSA9PT0gSFRNTF9OQU1FU1BBQ0UkMSkge1xuICAgICAgICAgICAgLy8gJEZsb3dGaXhNZSAtIFNob3VsZCBiZSBpbmZlcnJlZCBhcyBub3QgdW5kZWZpbmVkLlxuICAgICAgICAgICAgZXh0cmFBdHRyaWJ1dGVOYW1lcy5kZWxldGUocHJvcEtleS50b0xvd2VyQ2FzZSgpKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHN0YW5kYXJkTmFtZSA9IGdldFBvc3NpYmxlU3RhbmRhcmROYW1lKHByb3BLZXkpO1xuXG4gICAgICAgICAgICBpZiAoc3RhbmRhcmROYW1lICE9PSBudWxsICYmIHN0YW5kYXJkTmFtZSAhPT0gcHJvcEtleSkge1xuICAgICAgICAgICAgICAvLyBJZiBhbiBTVkcgcHJvcCBpcyBzdXBwbGllZCB3aXRoIGJhZCBjYXNpbmcsIGl0IHdpbGxcbiAgICAgICAgICAgICAgLy8gYmUgc3VjY2Vzc2Z1bGx5IHBhcnNlZCBmcm9tIEhUTUwsIGJ1dCB3aWxsIHByb2R1Y2UgYSBtaXNtYXRjaFxuICAgICAgICAgICAgICAvLyAoYW5kIHdvdWxkIGJlIGluY29ycmVjdGx5IHJlbmRlcmVkIG9uIHRoZSBjbGllbnQpLlxuICAgICAgICAgICAgICAvLyBIb3dldmVyLCB3ZSBhbHJlYWR5IHdhcm4gYWJvdXQgYmFkIGNhc2luZyBlbHNld2hlcmUuXG4gICAgICAgICAgICAgIC8vIFNvIHdlJ2xsIHNraXAgdGhlIG1pc2xlYWRpbmcgZXh0cmEgbWlzbWF0Y2ggd2FybmluZyBpbiB0aGlzIGNhc2UuXG4gICAgICAgICAgICAgIGlzTWlzbWF0Y2hEdWVUb0JhZENhc2luZyA9IHRydWU7IC8vICRGbG93Rml4TWUgLSBTaG91bGQgYmUgaW5mZXJyZWQgYXMgbm90IHVuZGVmaW5lZC5cblxuICAgICAgICAgICAgICBleHRyYUF0dHJpYnV0ZU5hbWVzLmRlbGV0ZShzdGFuZGFyZE5hbWUpO1xuICAgICAgICAgICAgfSAvLyAkRmxvd0ZpeE1lIC0gU2hvdWxkIGJlIGluZmVycmVkIGFzIG5vdCB1bmRlZmluZWQuXG5cblxuICAgICAgICAgICAgZXh0cmFBdHRyaWJ1dGVOYW1lcy5kZWxldGUocHJvcEtleSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgc2VydmVyVmFsdWUgPSBnZXRWYWx1ZUZvckF0dHJpYnV0ZShkb21FbGVtZW50LCBwcm9wS2V5LCBuZXh0UHJvcCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobmV4dFByb3AgIT09IHNlcnZlclZhbHVlICYmICFpc01pc21hdGNoRHVlVG9CYWRDYXNpbmcpIHtcbiAgICAgICAgICB3YXJuRm9yUHJvcERpZmZlcmVuY2UocHJvcEtleSwgc2VydmVyVmFsdWUsIG5leHRQcm9wKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHtcbiAgICAvLyAkRmxvd0ZpeE1lIC0gU2hvdWxkIGJlIGluZmVycmVkIGFzIG5vdCB1bmRlZmluZWQuXG4gICAgaWYgKGV4dHJhQXR0cmlidXRlTmFtZXMuc2l6ZSA+IDAgJiYgIXN1cHByZXNzSHlkcmF0aW9uV2FybmluZykge1xuICAgICAgLy8gJEZsb3dGaXhNZSAtIFNob3VsZCBiZSBpbmZlcnJlZCBhcyBub3QgdW5kZWZpbmVkLlxuICAgICAgd2FybkZvckV4dHJhQXR0cmlidXRlcyhleHRyYUF0dHJpYnV0ZU5hbWVzKTtcbiAgICB9XG4gIH1cblxuICBzd2l0Y2ggKHRhZykge1xuICAgIGNhc2UgJ2lucHV0JzpcbiAgICAgIC8vIFRPRE86IE1ha2Ugc3VyZSB3ZSBjaGVjayBpZiB0aGlzIGlzIHN0aWxsIHVubW91bnRlZCBvciBkbyBhbnkgY2xlYW5cbiAgICAgIC8vIHVwIG5lY2Vzc2FyeSBzaW5jZSB3ZSBuZXZlciBzdG9wIHRyYWNraW5nIGFueW1vcmUuXG4gICAgICB0cmFjayhkb21FbGVtZW50KTtcbiAgICAgIHBvc3RNb3VudFdyYXBwZXIoZG9tRWxlbWVudCwgcmF3UHJvcHMsIHRydWUpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICd0ZXh0YXJlYSc6XG4gICAgICAvLyBUT0RPOiBNYWtlIHN1cmUgd2UgY2hlY2sgaWYgdGhpcyBpcyBzdGlsbCB1bm1vdW50ZWQgb3IgZG8gYW55IGNsZWFuXG4gICAgICAvLyB1cCBuZWNlc3Nhcnkgc2luY2Ugd2UgbmV2ZXIgc3RvcCB0cmFja2luZyBhbnltb3JlLlxuICAgICAgdHJhY2soZG9tRWxlbWVudCk7XG4gICAgICBwb3N0TW91bnRXcmFwcGVyJDMoZG9tRWxlbWVudCk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ3NlbGVjdCc6XG4gICAgY2FzZSAnb3B0aW9uJzpcbiAgICAgIC8vIEZvciBpbnB1dCBhbmQgdGV4dGFyZWEgd2UgY3VycmVudCBhbHdheXMgc2V0IHRoZSB2YWx1ZSBwcm9wZXJ0eSBhdFxuICAgICAgLy8gcG9zdCBtb3VudCB0byBmb3JjZSBpdCB0byBkaXZlcmdlIGZyb20gYXR0cmlidXRlcy4gSG93ZXZlciwgZm9yXG4gICAgICAvLyBvcHRpb24gYW5kIHNlbGVjdCB3ZSBkb24ndCBxdWl0ZSBkbyB0aGUgc2FtZSB0aGluZyBhbmQgc2VsZWN0XG4gICAgICAvLyBpcyBub3QgcmVzaWxpZW50IHRvIHRoZSBET00gc3RhdGUgY2hhbmdpbmcgc28gd2UgZG9uJ3QgZG8gdGhhdCBoZXJlLlxuICAgICAgLy8gVE9ETzogQ29uc2lkZXIgbm90IGRvaW5nIHRoaXMgZm9yIGlucHV0IGFuZCB0ZXh0YXJlYS5cbiAgICAgIGJyZWFrO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIGlmICh0eXBlb2YgcmF3UHJvcHMub25DbGljayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyBUT0RPOiBUaGlzIGNhc3QgbWF5IG5vdCBiZSBzb3VuZCBmb3IgU1ZHLCBNYXRoTUwgb3IgY3VzdG9tIGVsZW1lbnRzLlxuICAgICAgICB0cmFwQ2xpY2tPbk5vbkludGVyYWN0aXZlRWxlbWVudChkb21FbGVtZW50KTtcbiAgICAgIH1cblxuICAgICAgYnJlYWs7XG4gIH1cblxuICByZXR1cm4gdXBkYXRlUGF5bG9hZDtcbn1cbmZ1bmN0aW9uIGRpZmZIeWRyYXRlZFRleHQodGV4dE5vZGUsIHRleHQpIHtcbiAgdmFyIGlzRGlmZmVyZW50ID0gdGV4dE5vZGUubm9kZVZhbHVlICE9PSB0ZXh0O1xuICByZXR1cm4gaXNEaWZmZXJlbnQ7XG59XG5mdW5jdGlvbiB3YXJuRm9yVW5tYXRjaGVkVGV4dCh0ZXh0Tm9kZSwgdGV4dCkge1xuICB7XG4gICAgd2FybkZvclRleHREaWZmZXJlbmNlKHRleHROb2RlLm5vZGVWYWx1ZSwgdGV4dCk7XG4gIH1cbn1cbmZ1bmN0aW9uIHdhcm5Gb3JEZWxldGVkSHlkcmF0YWJsZUVsZW1lbnQocGFyZW50Tm9kZSwgY2hpbGQpIHtcbiAge1xuICAgIGlmIChkaWRXYXJuSW52YWxpZEh5ZHJhdGlvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGRpZFdhcm5JbnZhbGlkSHlkcmF0aW9uID0gdHJ1ZTtcblxuICAgIGVycm9yKCdEaWQgbm90IGV4cGVjdCBzZXJ2ZXIgSFRNTCB0byBjb250YWluIGEgPCVzPiBpbiA8JXM+LicsIGNoaWxkLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCksIHBhcmVudE5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSk7XG4gIH1cbn1cbmZ1bmN0aW9uIHdhcm5Gb3JEZWxldGVkSHlkcmF0YWJsZVRleHQocGFyZW50Tm9kZSwgY2hpbGQpIHtcbiAge1xuICAgIGlmIChkaWRXYXJuSW52YWxpZEh5ZHJhdGlvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGRpZFdhcm5JbnZhbGlkSHlkcmF0aW9uID0gdHJ1ZTtcblxuICAgIGVycm9yKCdEaWQgbm90IGV4cGVjdCBzZXJ2ZXIgSFRNTCB0byBjb250YWluIHRoZSB0ZXh0IG5vZGUgXCIlc1wiIGluIDwlcz4uJywgY2hpbGQubm9kZVZhbHVlLCBwYXJlbnROb2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkpO1xuICB9XG59XG5mdW5jdGlvbiB3YXJuRm9ySW5zZXJ0ZWRIeWRyYXRlZEVsZW1lbnQocGFyZW50Tm9kZSwgdGFnLCBwcm9wcykge1xuICB7XG4gICAgaWYgKGRpZFdhcm5JbnZhbGlkSHlkcmF0aW9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZGlkV2FybkludmFsaWRIeWRyYXRpb24gPSB0cnVlO1xuXG4gICAgZXJyb3IoJ0V4cGVjdGVkIHNlcnZlciBIVE1MIHRvIGNvbnRhaW4gYSBtYXRjaGluZyA8JXM+IGluIDwlcz4uJywgdGFnLCBwYXJlbnROb2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkpO1xuICB9XG59XG5mdW5jdGlvbiB3YXJuRm9ySW5zZXJ0ZWRIeWRyYXRlZFRleHQocGFyZW50Tm9kZSwgdGV4dCkge1xuICB7XG4gICAgaWYgKHRleHQgPT09ICcnKSB7XG4gICAgICAvLyBXZSBleHBlY3QgdG8gaW5zZXJ0IGVtcHR5IHRleHQgbm9kZXMgc2luY2UgdGhleSdyZSBub3QgcmVwcmVzZW50ZWQgaW5cbiAgICAgIC8vIHRoZSBIVE1MLlxuICAgICAgLy8gVE9ETzogUmVtb3ZlIHRoaXMgc3BlY2lhbCBjYXNlIGlmIHdlIGNhbiBqdXN0IGF2b2lkIGluc2VydGluZyBlbXB0eVxuICAgICAgLy8gdGV4dCBub2Rlcy5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoZGlkV2FybkludmFsaWRIeWRyYXRpb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBkaWRXYXJuSW52YWxpZEh5ZHJhdGlvbiA9IHRydWU7XG5cbiAgICBlcnJvcignRXhwZWN0ZWQgc2VydmVyIEhUTUwgdG8gY29udGFpbiBhIG1hdGNoaW5nIHRleHQgbm9kZSBmb3IgXCIlc1wiIGluIDwlcz4uJywgdGV4dCwgcGFyZW50Tm9kZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpKTtcbiAgfVxufVxuZnVuY3Rpb24gcmVzdG9yZUNvbnRyb2xsZWRTdGF0ZSQzKGRvbUVsZW1lbnQsIHRhZywgcHJvcHMpIHtcbiAgc3dpdGNoICh0YWcpIHtcbiAgICBjYXNlICdpbnB1dCc6XG4gICAgICByZXN0b3JlQ29udHJvbGxlZFN0YXRlKGRvbUVsZW1lbnQsIHByb3BzKTtcbiAgICAgIHJldHVybjtcblxuICAgIGNhc2UgJ3RleHRhcmVhJzpcbiAgICAgIHJlc3RvcmVDb250cm9sbGVkU3RhdGUkMihkb21FbGVtZW50LCBwcm9wcyk7XG4gICAgICByZXR1cm47XG5cbiAgICBjYXNlICdzZWxlY3QnOlxuICAgICAgcmVzdG9yZUNvbnRyb2xsZWRTdGF0ZSQxKGRvbUVsZW1lbnQsIHByb3BzKTtcbiAgICAgIHJldHVybjtcbiAgfVxufVxuXG52YXIgdmFsaWRhdGVET01OZXN0aW5nID0gZnVuY3Rpb24gKCkge307XG5cbnZhciB1cGRhdGVkQW5jZXN0b3JJbmZvID0gZnVuY3Rpb24gKCkge307XG5cbntcbiAgLy8gVGhpcyB2YWxpZGF0aW9uIGNvZGUgd2FzIHdyaXR0ZW4gYmFzZWQgb24gdGhlIEhUTUw1IHBhcnNpbmcgc3BlYzpcbiAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjaGFzLWFuLWVsZW1lbnQtaW4tc2NvcGVcbiAgLy9cbiAgLy8gTm90ZTogdGhpcyBkb2VzIG5vdCBjYXRjaCBhbGwgaW52YWxpZCBuZXN0aW5nLCBub3IgZG9lcyBpdCB0cnkgdG8gKGFzIGl0J3NcbiAgLy8gbm90IGNsZWFyIHdoYXQgcHJhY3RpY2FsIGJlbmVmaXQgZG9pbmcgc28gcHJvdmlkZXMpOyBpbnN0ZWFkLCB3ZSB3YXJuIG9ubHlcbiAgLy8gZm9yIGNhc2VzIHdoZXJlIHRoZSBwYXJzZXIgd2lsbCBnaXZlIGEgcGFyc2UgdHJlZSBkaWZmZXJpbmcgZnJvbSB3aGF0IFJlYWN0XG4gIC8vIGludGVuZGVkLiBGb3IgZXhhbXBsZSwgPGI+PGRpdj48L2Rpdj48L2I+IGlzIGludmFsaWQgYnV0IHdlIGRvbid0IHdhcm5cbiAgLy8gYmVjYXVzZSBpdCBzdGlsbCBwYXJzZXMgY29ycmVjdGx5OyB3ZSBkbyB3YXJuIGZvciBvdGhlciBjYXNlcyBsaWtlIG5lc3RlZFxuICAvLyA8cD4gdGFncyB3aGVyZSB0aGUgYmVnaW5uaW5nIG9mIHRoZSBzZWNvbmQgZWxlbWVudCBpbXBsaWNpdGx5IGNsb3NlcyB0aGVcbiAgLy8gZmlyc3QsIGNhdXNpbmcgYSBjb25mdXNpbmcgbWVzcy5cbiAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjc3BlY2lhbFxuICB2YXIgc3BlY2lhbFRhZ3MgPSBbJ2FkZHJlc3MnLCAnYXBwbGV0JywgJ2FyZWEnLCAnYXJ0aWNsZScsICdhc2lkZScsICdiYXNlJywgJ2Jhc2Vmb250JywgJ2Jnc291bmQnLCAnYmxvY2txdW90ZScsICdib2R5JywgJ2JyJywgJ2J1dHRvbicsICdjYXB0aW9uJywgJ2NlbnRlcicsICdjb2wnLCAnY29sZ3JvdXAnLCAnZGQnLCAnZGV0YWlscycsICdkaXInLCAnZGl2JywgJ2RsJywgJ2R0JywgJ2VtYmVkJywgJ2ZpZWxkc2V0JywgJ2ZpZ2NhcHRpb24nLCAnZmlndXJlJywgJ2Zvb3RlcicsICdmb3JtJywgJ2ZyYW1lJywgJ2ZyYW1lc2V0JywgJ2gxJywgJ2gyJywgJ2gzJywgJ2g0JywgJ2g1JywgJ2g2JywgJ2hlYWQnLCAnaGVhZGVyJywgJ2hncm91cCcsICdocicsICdodG1sJywgJ2lmcmFtZScsICdpbWcnLCAnaW5wdXQnLCAnaXNpbmRleCcsICdsaScsICdsaW5rJywgJ2xpc3RpbmcnLCAnbWFpbicsICdtYXJxdWVlJywgJ21lbnUnLCAnbWVudWl0ZW0nLCAnbWV0YScsICduYXYnLCAnbm9lbWJlZCcsICdub2ZyYW1lcycsICdub3NjcmlwdCcsICdvYmplY3QnLCAnb2wnLCAncCcsICdwYXJhbScsICdwbGFpbnRleHQnLCAncHJlJywgJ3NjcmlwdCcsICdzZWN0aW9uJywgJ3NlbGVjdCcsICdzb3VyY2UnLCAnc3R5bGUnLCAnc3VtbWFyeScsICd0YWJsZScsICd0Ym9keScsICd0ZCcsICd0ZW1wbGF0ZScsICd0ZXh0YXJlYScsICd0Zm9vdCcsICd0aCcsICd0aGVhZCcsICd0aXRsZScsICd0cicsICd0cmFjaycsICd1bCcsICd3YnInLCAneG1wJ107IC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI2hhcy1hbi1lbGVtZW50LWluLXNjb3BlXG5cbiAgdmFyIGluU2NvcGVUYWdzID0gWydhcHBsZXQnLCAnY2FwdGlvbicsICdodG1sJywgJ3RhYmxlJywgJ3RkJywgJ3RoJywgJ21hcnF1ZWUnLCAnb2JqZWN0JywgJ3RlbXBsYXRlJywgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjaHRtbC1pbnRlZ3JhdGlvbi1wb2ludFxuICAvLyBUT0RPOiBEaXN0aW5ndWlzaCBieSBuYW1lc3BhY2UgaGVyZSAtLSBmb3IgPHRpdGxlPiwgaW5jbHVkaW5nIGl0IGhlcmVcbiAgLy8gZXJycyBvbiB0aGUgc2lkZSBvZiBmZXdlciB3YXJuaW5nc1xuICAnZm9yZWlnbk9iamVjdCcsICdkZXNjJywgJ3RpdGxlJ107IC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI2hhcy1hbi1lbGVtZW50LWluLWJ1dHRvbi1zY29wZVxuXG4gIHZhciBidXR0b25TY29wZVRhZ3MgPSBpblNjb3BlVGFncy5jb25jYXQoWydidXR0b24nXSk7IC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI2dlbmVyYXRlLWltcGxpZWQtZW5kLXRhZ3NcblxuICB2YXIgaW1wbGllZEVuZFRhZ3MgPSBbJ2RkJywgJ2R0JywgJ2xpJywgJ29wdGlvbicsICdvcHRncm91cCcsICdwJywgJ3JwJywgJ3J0J107XG4gIHZhciBlbXB0eUFuY2VzdG9ySW5mbyA9IHtcbiAgICBjdXJyZW50OiBudWxsLFxuICAgIGZvcm1UYWc6IG51bGwsXG4gICAgYVRhZ0luU2NvcGU6IG51bGwsXG4gICAgYnV0dG9uVGFnSW5TY29wZTogbnVsbCxcbiAgICBub2JyVGFnSW5TY29wZTogbnVsbCxcbiAgICBwVGFnSW5CdXR0b25TY29wZTogbnVsbCxcbiAgICBsaXN0SXRlbVRhZ0F1dG9jbG9zaW5nOiBudWxsLFxuICAgIGRsSXRlbVRhZ0F1dG9jbG9zaW5nOiBudWxsXG4gIH07XG5cbiAgdXBkYXRlZEFuY2VzdG9ySW5mbyA9IGZ1bmN0aW9uIChvbGRJbmZvLCB0YWcpIHtcbiAgICB2YXIgYW5jZXN0b3JJbmZvID0gX2Fzc2lnbih7fSwgb2xkSW5mbyB8fCBlbXB0eUFuY2VzdG9ySW5mbyk7XG5cbiAgICB2YXIgaW5mbyA9IHtcbiAgICAgIHRhZzogdGFnXG4gICAgfTtcblxuICAgIGlmIChpblNjb3BlVGFncy5pbmRleE9mKHRhZykgIT09IC0xKSB7XG4gICAgICBhbmNlc3RvckluZm8uYVRhZ0luU2NvcGUgPSBudWxsO1xuICAgICAgYW5jZXN0b3JJbmZvLmJ1dHRvblRhZ0luU2NvcGUgPSBudWxsO1xuICAgICAgYW5jZXN0b3JJbmZvLm5vYnJUYWdJblNjb3BlID0gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAoYnV0dG9uU2NvcGVUYWdzLmluZGV4T2YodGFnKSAhPT0gLTEpIHtcbiAgICAgIGFuY2VzdG9ySW5mby5wVGFnSW5CdXR0b25TY29wZSA9IG51bGw7XG4gICAgfSAvLyBTZWUgcnVsZXMgZm9yICdsaScsICdkZCcsICdkdCcgc3RhcnQgdGFncyBpblxuICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI3BhcnNpbmctbWFpbi1pbmJvZHlcblxuXG4gICAgaWYgKHNwZWNpYWxUYWdzLmluZGV4T2YodGFnKSAhPT0gLTEgJiYgdGFnICE9PSAnYWRkcmVzcycgJiYgdGFnICE9PSAnZGl2JyAmJiB0YWcgIT09ICdwJykge1xuICAgICAgYW5jZXN0b3JJbmZvLmxpc3RJdGVtVGFnQXV0b2Nsb3NpbmcgPSBudWxsO1xuICAgICAgYW5jZXN0b3JJbmZvLmRsSXRlbVRhZ0F1dG9jbG9zaW5nID0gbnVsbDtcbiAgICB9XG5cbiAgICBhbmNlc3RvckluZm8uY3VycmVudCA9IGluZm87XG5cbiAgICBpZiAodGFnID09PSAnZm9ybScpIHtcbiAgICAgIGFuY2VzdG9ySW5mby5mb3JtVGFnID0gaW5mbztcbiAgICB9XG5cbiAgICBpZiAodGFnID09PSAnYScpIHtcbiAgICAgIGFuY2VzdG9ySW5mby5hVGFnSW5TY29wZSA9IGluZm87XG4gICAgfVxuXG4gICAgaWYgKHRhZyA9PT0gJ2J1dHRvbicpIHtcbiAgICAgIGFuY2VzdG9ySW5mby5idXR0b25UYWdJblNjb3BlID0gaW5mbztcbiAgICB9XG5cbiAgICBpZiAodGFnID09PSAnbm9icicpIHtcbiAgICAgIGFuY2VzdG9ySW5mby5ub2JyVGFnSW5TY29wZSA9IGluZm87XG4gICAgfVxuXG4gICAgaWYgKHRhZyA9PT0gJ3AnKSB7XG4gICAgICBhbmNlc3RvckluZm8ucFRhZ0luQnV0dG9uU2NvcGUgPSBpbmZvO1xuICAgIH1cblxuICAgIGlmICh0YWcgPT09ICdsaScpIHtcbiAgICAgIGFuY2VzdG9ySW5mby5saXN0SXRlbVRhZ0F1dG9jbG9zaW5nID0gaW5mbztcbiAgICB9XG5cbiAgICBpZiAodGFnID09PSAnZGQnIHx8IHRhZyA9PT0gJ2R0Jykge1xuICAgICAgYW5jZXN0b3JJbmZvLmRsSXRlbVRhZ0F1dG9jbG9zaW5nID0gaW5mbztcbiAgICB9XG5cbiAgICByZXR1cm4gYW5jZXN0b3JJbmZvO1xuICB9O1xuICAvKipcbiAgICogUmV0dXJucyB3aGV0aGVyXG4gICAqL1xuXG5cbiAgdmFyIGlzVGFnVmFsaWRXaXRoUGFyZW50ID0gZnVuY3Rpb24gKHRhZywgcGFyZW50VGFnKSB7XG4gICAgLy8gRmlyc3QsIGxldCdzIGNoZWNrIGlmIHdlJ3JlIGluIGFuIHVudXN1YWwgcGFyc2luZyBtb2RlLi4uXG4gICAgc3dpdGNoIChwYXJlbnRUYWcpIHtcbiAgICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI3BhcnNpbmctbWFpbi1pbnNlbGVjdFxuICAgICAgY2FzZSAnc2VsZWN0JzpcbiAgICAgICAgcmV0dXJuIHRhZyA9PT0gJ29wdGlvbicgfHwgdGFnID09PSAnb3B0Z3JvdXAnIHx8IHRhZyA9PT0gJyN0ZXh0JztcblxuICAgICAgY2FzZSAnb3B0Z3JvdXAnOlxuICAgICAgICByZXR1cm4gdGFnID09PSAnb3B0aW9uJyB8fCB0YWcgPT09ICcjdGV4dCc7XG4gICAgICAvLyBTdHJpY3RseSBzcGVha2luZywgc2VlaW5nIGFuIDxvcHRpb24+IGRvZXNuJ3QgbWVhbiB3ZSdyZSBpbiBhIDxzZWxlY3Q+XG4gICAgICAvLyBidXRcblxuICAgICAgY2FzZSAnb3B0aW9uJzpcbiAgICAgICAgcmV0dXJuIHRhZyA9PT0gJyN0ZXh0JztcbiAgICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI3BhcnNpbmctbWFpbi1pbnRkXG4gICAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNwYXJzaW5nLW1haW4taW5jYXB0aW9uXG4gICAgICAvLyBObyBzcGVjaWFsIGJlaGF2aW9yIHNpbmNlIHRoZXNlIHJ1bGVzIGZhbGwgYmFjayB0byBcImluIGJvZHlcIiBtb2RlIGZvclxuICAgICAgLy8gYWxsIGV4Y2VwdCBzcGVjaWFsIHRhYmxlIG5vZGVzIHdoaWNoIGNhdXNlIGJhZCBwYXJzaW5nIGJlaGF2aW9yIGFueXdheS5cbiAgICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI3BhcnNpbmctbWFpbi1pbnRyXG5cbiAgICAgIGNhc2UgJ3RyJzpcbiAgICAgICAgcmV0dXJuIHRhZyA9PT0gJ3RoJyB8fCB0YWcgPT09ICd0ZCcgfHwgdGFnID09PSAnc3R5bGUnIHx8IHRhZyA9PT0gJ3NjcmlwdCcgfHwgdGFnID09PSAndGVtcGxhdGUnO1xuICAgICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjcGFyc2luZy1tYWluLWludGJvZHlcblxuICAgICAgY2FzZSAndGJvZHknOlxuICAgICAgY2FzZSAndGhlYWQnOlxuICAgICAgY2FzZSAndGZvb3QnOlxuICAgICAgICByZXR1cm4gdGFnID09PSAndHInIHx8IHRhZyA9PT0gJ3N0eWxlJyB8fCB0YWcgPT09ICdzY3JpcHQnIHx8IHRhZyA9PT0gJ3RlbXBsYXRlJztcbiAgICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI3BhcnNpbmctbWFpbi1pbmNvbGdyb3VwXG5cbiAgICAgIGNhc2UgJ2NvbGdyb3VwJzpcbiAgICAgICAgcmV0dXJuIHRhZyA9PT0gJ2NvbCcgfHwgdGFnID09PSAndGVtcGxhdGUnO1xuICAgICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjcGFyc2luZy1tYWluLWludGFibGVcblxuICAgICAgY2FzZSAndGFibGUnOlxuICAgICAgICByZXR1cm4gdGFnID09PSAnY2FwdGlvbicgfHwgdGFnID09PSAnY29sZ3JvdXAnIHx8IHRhZyA9PT0gJ3Rib2R5JyB8fCB0YWcgPT09ICd0Zm9vdCcgfHwgdGFnID09PSAndGhlYWQnIHx8IHRhZyA9PT0gJ3N0eWxlJyB8fCB0YWcgPT09ICdzY3JpcHQnIHx8IHRhZyA9PT0gJ3RlbXBsYXRlJztcbiAgICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI3BhcnNpbmctbWFpbi1pbmhlYWRcblxuICAgICAgY2FzZSAnaGVhZCc6XG4gICAgICAgIHJldHVybiB0YWcgPT09ICdiYXNlJyB8fCB0YWcgPT09ICdiYXNlZm9udCcgfHwgdGFnID09PSAnYmdzb3VuZCcgfHwgdGFnID09PSAnbGluaycgfHwgdGFnID09PSAnbWV0YScgfHwgdGFnID09PSAndGl0bGUnIHx8IHRhZyA9PT0gJ25vc2NyaXB0JyB8fCB0YWcgPT09ICdub2ZyYW1lcycgfHwgdGFnID09PSAnc3R5bGUnIHx8IHRhZyA9PT0gJ3NjcmlwdCcgfHwgdGFnID09PSAndGVtcGxhdGUnO1xuICAgICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc2VtYW50aWNzLmh0bWwjdGhlLWh0bWwtZWxlbWVudFxuXG4gICAgICBjYXNlICdodG1sJzpcbiAgICAgICAgcmV0dXJuIHRhZyA9PT0gJ2hlYWQnIHx8IHRhZyA9PT0gJ2JvZHknIHx8IHRhZyA9PT0gJ2ZyYW1lc2V0JztcblxuICAgICAgY2FzZSAnZnJhbWVzZXQnOlxuICAgICAgICByZXR1cm4gdGFnID09PSAnZnJhbWUnO1xuXG4gICAgICBjYXNlICcjZG9jdW1lbnQnOlxuICAgICAgICByZXR1cm4gdGFnID09PSAnaHRtbCc7XG4gICAgfSAvLyBQcm9iYWJseSBpbiB0aGUgXCJpbiBib2R5XCIgcGFyc2luZyBtb2RlLCBzbyB3ZSBvdXRsYXcgb25seSB0YWcgY29tYm9zXG4gICAgLy8gd2hlcmUgdGhlIHBhcnNpbmcgcnVsZXMgY2F1c2UgaW1wbGljaXQgb3BlbnMgb3IgY2xvc2VzIHRvIGJlIGFkZGVkLlxuICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI3BhcnNpbmctbWFpbi1pbmJvZHlcblxuXG4gICAgc3dpdGNoICh0YWcpIHtcbiAgICAgIGNhc2UgJ2gxJzpcbiAgICAgIGNhc2UgJ2gyJzpcbiAgICAgIGNhc2UgJ2gzJzpcbiAgICAgIGNhc2UgJ2g0JzpcbiAgICAgIGNhc2UgJ2g1JzpcbiAgICAgIGNhc2UgJ2g2JzpcbiAgICAgICAgcmV0dXJuIHBhcmVudFRhZyAhPT0gJ2gxJyAmJiBwYXJlbnRUYWcgIT09ICdoMicgJiYgcGFyZW50VGFnICE9PSAnaDMnICYmIHBhcmVudFRhZyAhPT0gJ2g0JyAmJiBwYXJlbnRUYWcgIT09ICdoNScgJiYgcGFyZW50VGFnICE9PSAnaDYnO1xuXG4gICAgICBjYXNlICdycCc6XG4gICAgICBjYXNlICdydCc6XG4gICAgICAgIHJldHVybiBpbXBsaWVkRW5kVGFncy5pbmRleE9mKHBhcmVudFRhZykgPT09IC0xO1xuXG4gICAgICBjYXNlICdib2R5JzpcbiAgICAgIGNhc2UgJ2NhcHRpb24nOlxuICAgICAgY2FzZSAnY29sJzpcbiAgICAgIGNhc2UgJ2NvbGdyb3VwJzpcbiAgICAgIGNhc2UgJ2ZyYW1lc2V0JzpcbiAgICAgIGNhc2UgJ2ZyYW1lJzpcbiAgICAgIGNhc2UgJ2hlYWQnOlxuICAgICAgY2FzZSAnaHRtbCc6XG4gICAgICBjYXNlICd0Ym9keSc6XG4gICAgICBjYXNlICd0ZCc6XG4gICAgICBjYXNlICd0Zm9vdCc6XG4gICAgICBjYXNlICd0aCc6XG4gICAgICBjYXNlICd0aGVhZCc6XG4gICAgICBjYXNlICd0cic6XG4gICAgICAgIC8vIFRoZXNlIHRhZ3MgYXJlIG9ubHkgdmFsaWQgd2l0aCBhIGZldyBwYXJlbnRzIHRoYXQgaGF2ZSBzcGVjaWFsIGNoaWxkXG4gICAgICAgIC8vIHBhcnNpbmcgcnVsZXMgLS0gaWYgd2UncmUgZG93biBoZXJlLCB0aGVuIG5vbmUgb2YgdGhvc2UgbWF0Y2hlZCBhbmRcbiAgICAgICAgLy8gc28gd2UgYWxsb3cgaXQgb25seSBpZiB3ZSBkb24ndCBrbm93IHdoYXQgdGhlIHBhcmVudCBpcywgYXMgYWxsIG90aGVyXG4gICAgICAgIC8vIGNhc2VzIGFyZSBpbnZhbGlkLlxuICAgICAgICByZXR1cm4gcGFyZW50VGFnID09IG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG4gIC8qKlxuICAgKiBSZXR1cm5zIHdoZXRoZXJcbiAgICovXG5cblxuICB2YXIgZmluZEludmFsaWRBbmNlc3RvckZvclRhZyA9IGZ1bmN0aW9uICh0YWcsIGFuY2VzdG9ySW5mbykge1xuICAgIHN3aXRjaCAodGFnKSB7XG4gICAgICBjYXNlICdhZGRyZXNzJzpcbiAgICAgIGNhc2UgJ2FydGljbGUnOlxuICAgICAgY2FzZSAnYXNpZGUnOlxuICAgICAgY2FzZSAnYmxvY2txdW90ZSc6XG4gICAgICBjYXNlICdjZW50ZXInOlxuICAgICAgY2FzZSAnZGV0YWlscyc6XG4gICAgICBjYXNlICdkaWFsb2cnOlxuICAgICAgY2FzZSAnZGlyJzpcbiAgICAgIGNhc2UgJ2Rpdic6XG4gICAgICBjYXNlICdkbCc6XG4gICAgICBjYXNlICdmaWVsZHNldCc6XG4gICAgICBjYXNlICdmaWdjYXB0aW9uJzpcbiAgICAgIGNhc2UgJ2ZpZ3VyZSc6XG4gICAgICBjYXNlICdmb290ZXInOlxuICAgICAgY2FzZSAnaGVhZGVyJzpcbiAgICAgIGNhc2UgJ2hncm91cCc6XG4gICAgICBjYXNlICdtYWluJzpcbiAgICAgIGNhc2UgJ21lbnUnOlxuICAgICAgY2FzZSAnbmF2JzpcbiAgICAgIGNhc2UgJ29sJzpcbiAgICAgIGNhc2UgJ3AnOlxuICAgICAgY2FzZSAnc2VjdGlvbic6XG4gICAgICBjYXNlICdzdW1tYXJ5JzpcbiAgICAgIGNhc2UgJ3VsJzpcbiAgICAgIGNhc2UgJ3ByZSc6XG4gICAgICBjYXNlICdsaXN0aW5nJzpcbiAgICAgIGNhc2UgJ3RhYmxlJzpcbiAgICAgIGNhc2UgJ2hyJzpcbiAgICAgIGNhc2UgJ3htcCc6XG4gICAgICBjYXNlICdoMSc6XG4gICAgICBjYXNlICdoMic6XG4gICAgICBjYXNlICdoMyc6XG4gICAgICBjYXNlICdoNCc6XG4gICAgICBjYXNlICdoNSc6XG4gICAgICBjYXNlICdoNic6XG4gICAgICAgIHJldHVybiBhbmNlc3RvckluZm8ucFRhZ0luQnV0dG9uU2NvcGU7XG5cbiAgICAgIGNhc2UgJ2Zvcm0nOlxuICAgICAgICByZXR1cm4gYW5jZXN0b3JJbmZvLmZvcm1UYWcgfHwgYW5jZXN0b3JJbmZvLnBUYWdJbkJ1dHRvblNjb3BlO1xuXG4gICAgICBjYXNlICdsaSc6XG4gICAgICAgIHJldHVybiBhbmNlc3RvckluZm8ubGlzdEl0ZW1UYWdBdXRvY2xvc2luZztcblxuICAgICAgY2FzZSAnZGQnOlxuICAgICAgY2FzZSAnZHQnOlxuICAgICAgICByZXR1cm4gYW5jZXN0b3JJbmZvLmRsSXRlbVRhZ0F1dG9jbG9zaW5nO1xuXG4gICAgICBjYXNlICdidXR0b24nOlxuICAgICAgICByZXR1cm4gYW5jZXN0b3JJbmZvLmJ1dHRvblRhZ0luU2NvcGU7XG5cbiAgICAgIGNhc2UgJ2EnOlxuICAgICAgICAvLyBTcGVjIHNheXMgc29tZXRoaW5nIGFib3V0IHN0b3JpbmcgYSBsaXN0IG9mIG1hcmtlcnMsIGJ1dCBpdCBzb3VuZHNcbiAgICAgICAgLy8gZXF1aXZhbGVudCB0byB0aGlzIGNoZWNrLlxuICAgICAgICByZXR1cm4gYW5jZXN0b3JJbmZvLmFUYWdJblNjb3BlO1xuXG4gICAgICBjYXNlICdub2JyJzpcbiAgICAgICAgcmV0dXJuIGFuY2VzdG9ySW5mby5ub2JyVGFnSW5TY29wZTtcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfTtcblxuICB2YXIgZGlkV2FybiQxID0ge307XG5cbiAgdmFsaWRhdGVET01OZXN0aW5nID0gZnVuY3Rpb24gKGNoaWxkVGFnLCBjaGlsZFRleHQsIGFuY2VzdG9ySW5mbykge1xuICAgIGFuY2VzdG9ySW5mbyA9IGFuY2VzdG9ySW5mbyB8fCBlbXB0eUFuY2VzdG9ySW5mbztcbiAgICB2YXIgcGFyZW50SW5mbyA9IGFuY2VzdG9ySW5mby5jdXJyZW50O1xuICAgIHZhciBwYXJlbnRUYWcgPSBwYXJlbnRJbmZvICYmIHBhcmVudEluZm8udGFnO1xuXG4gICAgaWYgKGNoaWxkVGV4dCAhPSBudWxsKSB7XG4gICAgICBpZiAoY2hpbGRUYWcgIT0gbnVsbCkge1xuICAgICAgICBlcnJvcigndmFsaWRhdGVET01OZXN0aW5nOiB3aGVuIGNoaWxkVGV4dCBpcyBwYXNzZWQsIGNoaWxkVGFnIHNob3VsZCBiZSBudWxsJyk7XG4gICAgICB9XG5cbiAgICAgIGNoaWxkVGFnID0gJyN0ZXh0JztcbiAgICB9XG5cbiAgICB2YXIgaW52YWxpZFBhcmVudCA9IGlzVGFnVmFsaWRXaXRoUGFyZW50KGNoaWxkVGFnLCBwYXJlbnRUYWcpID8gbnVsbCA6IHBhcmVudEluZm87XG4gICAgdmFyIGludmFsaWRBbmNlc3RvciA9IGludmFsaWRQYXJlbnQgPyBudWxsIDogZmluZEludmFsaWRBbmNlc3RvckZvclRhZyhjaGlsZFRhZywgYW5jZXN0b3JJbmZvKTtcbiAgICB2YXIgaW52YWxpZFBhcmVudE9yQW5jZXN0b3IgPSBpbnZhbGlkUGFyZW50IHx8IGludmFsaWRBbmNlc3RvcjtcblxuICAgIGlmICghaW52YWxpZFBhcmVudE9yQW5jZXN0b3IpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgYW5jZXN0b3JUYWcgPSBpbnZhbGlkUGFyZW50T3JBbmNlc3Rvci50YWc7XG4gICAgdmFyIHdhcm5LZXkgPSAhIWludmFsaWRQYXJlbnQgKyAnfCcgKyBjaGlsZFRhZyArICd8JyArIGFuY2VzdG9yVGFnO1xuXG4gICAgaWYgKGRpZFdhcm4kMVt3YXJuS2V5XSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGRpZFdhcm4kMVt3YXJuS2V5XSA9IHRydWU7XG4gICAgdmFyIHRhZ0Rpc3BsYXlOYW1lID0gY2hpbGRUYWc7XG4gICAgdmFyIHdoaXRlc3BhY2VJbmZvID0gJyc7XG5cbiAgICBpZiAoY2hpbGRUYWcgPT09ICcjdGV4dCcpIHtcbiAgICAgIGlmICgvXFxTLy50ZXN0KGNoaWxkVGV4dCkpIHtcbiAgICAgICAgdGFnRGlzcGxheU5hbWUgPSAnVGV4dCBub2Rlcyc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0YWdEaXNwbGF5TmFtZSA9ICdXaGl0ZXNwYWNlIHRleHQgbm9kZXMnO1xuICAgICAgICB3aGl0ZXNwYWNlSW5mbyA9IFwiIE1ha2Ugc3VyZSB5b3UgZG9uJ3QgaGF2ZSBhbnkgZXh0cmEgd2hpdGVzcGFjZSBiZXR3ZWVuIHRhZ3Mgb24gXCIgKyAnZWFjaCBsaW5lIG9mIHlvdXIgc291cmNlIGNvZGUuJztcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGFnRGlzcGxheU5hbWUgPSAnPCcgKyBjaGlsZFRhZyArICc+JztcbiAgICB9XG5cbiAgICBpZiAoaW52YWxpZFBhcmVudCkge1xuICAgICAgdmFyIGluZm8gPSAnJztcblxuICAgICAgaWYgKGFuY2VzdG9yVGFnID09PSAndGFibGUnICYmIGNoaWxkVGFnID09PSAndHInKSB7XG4gICAgICAgIGluZm8gKz0gJyBBZGQgYSA8dGJvZHk+LCA8dGhlYWQ+IG9yIDx0Zm9vdD4gdG8geW91ciBjb2RlIHRvIG1hdGNoIHRoZSBET00gdHJlZSBnZW5lcmF0ZWQgYnkgJyArICd0aGUgYnJvd3Nlci4nO1xuICAgICAgfVxuXG4gICAgICBlcnJvcigndmFsaWRhdGVET01OZXN0aW5nKC4uLik6ICVzIGNhbm5vdCBhcHBlYXIgYXMgYSBjaGlsZCBvZiA8JXM+LiVzJXMnLCB0YWdEaXNwbGF5TmFtZSwgYW5jZXN0b3JUYWcsIHdoaXRlc3BhY2VJbmZvLCBpbmZvKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXJyb3IoJ3ZhbGlkYXRlRE9NTmVzdGluZyguLi4pOiAlcyBjYW5ub3QgYXBwZWFyIGFzIGEgZGVzY2VuZGFudCBvZiAnICsgJzwlcz4uJywgdGFnRGlzcGxheU5hbWUsIGFuY2VzdG9yVGFnKTtcbiAgICB9XG4gIH07XG59XG5cbnZhciBTVVBQUkVTU19IWURSQVRJT05fV0FSTklORyQxO1xuXG57XG4gIFNVUFBSRVNTX0hZRFJBVElPTl9XQVJOSU5HJDEgPSAnc3VwcHJlc3NIeWRyYXRpb25XYXJuaW5nJztcbn1cblxudmFyIFNVU1BFTlNFX1NUQVJUX0RBVEEgPSAnJCc7XG52YXIgU1VTUEVOU0VfRU5EX0RBVEEgPSAnLyQnO1xudmFyIFNVU1BFTlNFX1BFTkRJTkdfU1RBUlRfREFUQSA9ICckPyc7XG52YXIgU1VTUEVOU0VfRkFMTEJBQ0tfU1RBUlRfREFUQSA9ICckISc7XG52YXIgU1RZTEUkMSA9ICdzdHlsZSc7XG52YXIgZXZlbnRzRW5hYmxlZCA9IG51bGw7XG52YXIgc2VsZWN0aW9uSW5mb3JtYXRpb24gPSBudWxsO1xuXG5mdW5jdGlvbiBzaG91bGRBdXRvRm9jdXNIb3N0Q29tcG9uZW50KHR5cGUsIHByb3BzKSB7XG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgJ2J1dHRvbic6XG4gICAgY2FzZSAnaW5wdXQnOlxuICAgIGNhc2UgJ3NlbGVjdCc6XG4gICAgY2FzZSAndGV4dGFyZWEnOlxuICAgICAgcmV0dXJuICEhcHJvcHMuYXV0b0ZvY3VzO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gZ2V0Um9vdEhvc3RDb250ZXh0KHJvb3RDb250YWluZXJJbnN0YW5jZSkge1xuICB2YXIgdHlwZTtcbiAgdmFyIG5hbWVzcGFjZTtcbiAgdmFyIG5vZGVUeXBlID0gcm9vdENvbnRhaW5lckluc3RhbmNlLm5vZGVUeXBlO1xuXG4gIHN3aXRjaCAobm9kZVR5cGUpIHtcbiAgICBjYXNlIERPQ1VNRU5UX05PREU6XG4gICAgY2FzZSBET0NVTUVOVF9GUkFHTUVOVF9OT0RFOlxuICAgICAge1xuICAgICAgICB0eXBlID0gbm9kZVR5cGUgPT09IERPQ1VNRU5UX05PREUgPyAnI2RvY3VtZW50JyA6ICcjZnJhZ21lbnQnO1xuICAgICAgICB2YXIgcm9vdCA9IHJvb3RDb250YWluZXJJbnN0YW5jZS5kb2N1bWVudEVsZW1lbnQ7XG4gICAgICAgIG5hbWVzcGFjZSA9IHJvb3QgPyByb290Lm5hbWVzcGFjZVVSSSA6IGdldENoaWxkTmFtZXNwYWNlKG51bGwsICcnKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICBkZWZhdWx0OlxuICAgICAge1xuICAgICAgICB2YXIgY29udGFpbmVyID0gbm9kZVR5cGUgPT09IENPTU1FTlRfTk9ERSA/IHJvb3RDb250YWluZXJJbnN0YW5jZS5wYXJlbnROb2RlIDogcm9vdENvbnRhaW5lckluc3RhbmNlO1xuICAgICAgICB2YXIgb3duTmFtZXNwYWNlID0gY29udGFpbmVyLm5hbWVzcGFjZVVSSSB8fCBudWxsO1xuICAgICAgICB0eXBlID0gY29udGFpbmVyLnRhZ05hbWU7XG4gICAgICAgIG5hbWVzcGFjZSA9IGdldENoaWxkTmFtZXNwYWNlKG93bk5hbWVzcGFjZSwgdHlwZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICB9XG5cbiAge1xuICAgIHZhciB2YWxpZGF0ZWRUYWcgPSB0eXBlLnRvTG93ZXJDYXNlKCk7XG4gICAgdmFyIGFuY2VzdG9ySW5mbyA9IHVwZGF0ZWRBbmNlc3RvckluZm8obnVsbCwgdmFsaWRhdGVkVGFnKTtcbiAgICByZXR1cm4ge1xuICAgICAgbmFtZXNwYWNlOiBuYW1lc3BhY2UsXG4gICAgICBhbmNlc3RvckluZm86IGFuY2VzdG9ySW5mb1xuICAgIH07XG4gIH1cbn1cbmZ1bmN0aW9uIGdldENoaWxkSG9zdENvbnRleHQocGFyZW50SG9zdENvbnRleHQsIHR5cGUsIHJvb3RDb250YWluZXJJbnN0YW5jZSkge1xuICB7XG4gICAgdmFyIHBhcmVudEhvc3RDb250ZXh0RGV2ID0gcGFyZW50SG9zdENvbnRleHQ7XG4gICAgdmFyIG5hbWVzcGFjZSA9IGdldENoaWxkTmFtZXNwYWNlKHBhcmVudEhvc3RDb250ZXh0RGV2Lm5hbWVzcGFjZSwgdHlwZSk7XG4gICAgdmFyIGFuY2VzdG9ySW5mbyA9IHVwZGF0ZWRBbmNlc3RvckluZm8ocGFyZW50SG9zdENvbnRleHREZXYuYW5jZXN0b3JJbmZvLCB0eXBlKTtcbiAgICByZXR1cm4ge1xuICAgICAgbmFtZXNwYWNlOiBuYW1lc3BhY2UsXG4gICAgICBhbmNlc3RvckluZm86IGFuY2VzdG9ySW5mb1xuICAgIH07XG4gIH1cbn1cbmZ1bmN0aW9uIGdldFB1YmxpY0luc3RhbmNlKGluc3RhbmNlKSB7XG4gIHJldHVybiBpbnN0YW5jZTtcbn1cbmZ1bmN0aW9uIHByZXBhcmVGb3JDb21taXQoY29udGFpbmVySW5mbykge1xuICBldmVudHNFbmFibGVkID0gaXNFbmFibGVkKCk7XG4gIHNlbGVjdGlvbkluZm9ybWF0aW9uID0gZ2V0U2VsZWN0aW9uSW5mb3JtYXRpb24oKTtcbiAgdmFyIGFjdGl2ZUluc3RhbmNlID0gbnVsbDtcblxuICBzZXRFbmFibGVkKGZhbHNlKTtcbiAgcmV0dXJuIGFjdGl2ZUluc3RhbmNlO1xufVxuZnVuY3Rpb24gcmVzZXRBZnRlckNvbW1pdChjb250YWluZXJJbmZvKSB7XG4gIHJlc3RvcmVTZWxlY3Rpb24oc2VsZWN0aW9uSW5mb3JtYXRpb24pO1xuICBzZXRFbmFibGVkKGV2ZW50c0VuYWJsZWQpO1xuICBldmVudHNFbmFibGVkID0gbnVsbDtcbiAgc2VsZWN0aW9uSW5mb3JtYXRpb24gPSBudWxsO1xufVxuZnVuY3Rpb24gY3JlYXRlSW5zdGFuY2UodHlwZSwgcHJvcHMsIHJvb3RDb250YWluZXJJbnN0YW5jZSwgaG9zdENvbnRleHQsIGludGVybmFsSW5zdGFuY2VIYW5kbGUpIHtcbiAgdmFyIHBhcmVudE5hbWVzcGFjZTtcblxuICB7XG4gICAgLy8gVE9ETzogdGFrZSBuYW1lc3BhY2UgaW50byBhY2NvdW50IHdoZW4gdmFsaWRhdGluZy5cbiAgICB2YXIgaG9zdENvbnRleHREZXYgPSBob3N0Q29udGV4dDtcbiAgICB2YWxpZGF0ZURPTU5lc3RpbmcodHlwZSwgbnVsbCwgaG9zdENvbnRleHREZXYuYW5jZXN0b3JJbmZvKTtcblxuICAgIGlmICh0eXBlb2YgcHJvcHMuY2hpbGRyZW4gPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBwcm9wcy5jaGlsZHJlbiA9PT0gJ251bWJlcicpIHtcbiAgICAgIHZhciBzdHJpbmcgPSAnJyArIHByb3BzLmNoaWxkcmVuO1xuICAgICAgdmFyIG93bkFuY2VzdG9ySW5mbyA9IHVwZGF0ZWRBbmNlc3RvckluZm8oaG9zdENvbnRleHREZXYuYW5jZXN0b3JJbmZvLCB0eXBlKTtcbiAgICAgIHZhbGlkYXRlRE9NTmVzdGluZyhudWxsLCBzdHJpbmcsIG93bkFuY2VzdG9ySW5mbyk7XG4gICAgfVxuXG4gICAgcGFyZW50TmFtZXNwYWNlID0gaG9zdENvbnRleHREZXYubmFtZXNwYWNlO1xuICB9XG5cbiAgdmFyIGRvbUVsZW1lbnQgPSBjcmVhdGVFbGVtZW50KHR5cGUsIHByb3BzLCByb290Q29udGFpbmVySW5zdGFuY2UsIHBhcmVudE5hbWVzcGFjZSk7XG4gIHByZWNhY2hlRmliZXJOb2RlKGludGVybmFsSW5zdGFuY2VIYW5kbGUsIGRvbUVsZW1lbnQpO1xuICB1cGRhdGVGaWJlclByb3BzKGRvbUVsZW1lbnQsIHByb3BzKTtcbiAgcmV0dXJuIGRvbUVsZW1lbnQ7XG59XG5mdW5jdGlvbiBhcHBlbmRJbml0aWFsQ2hpbGQocGFyZW50SW5zdGFuY2UsIGNoaWxkKSB7XG4gIHBhcmVudEluc3RhbmNlLmFwcGVuZENoaWxkKGNoaWxkKTtcbn1cbmZ1bmN0aW9uIGZpbmFsaXplSW5pdGlhbENoaWxkcmVuKGRvbUVsZW1lbnQsIHR5cGUsIHByb3BzLCByb290Q29udGFpbmVySW5zdGFuY2UsIGhvc3RDb250ZXh0KSB7XG4gIHNldEluaXRpYWxQcm9wZXJ0aWVzKGRvbUVsZW1lbnQsIHR5cGUsIHByb3BzLCByb290Q29udGFpbmVySW5zdGFuY2UpO1xuICByZXR1cm4gc2hvdWxkQXV0b0ZvY3VzSG9zdENvbXBvbmVudCh0eXBlLCBwcm9wcyk7XG59XG5mdW5jdGlvbiBwcmVwYXJlVXBkYXRlKGRvbUVsZW1lbnQsIHR5cGUsIG9sZFByb3BzLCBuZXdQcm9wcywgcm9vdENvbnRhaW5lckluc3RhbmNlLCBob3N0Q29udGV4dCkge1xuICB7XG4gICAgdmFyIGhvc3RDb250ZXh0RGV2ID0gaG9zdENvbnRleHQ7XG5cbiAgICBpZiAodHlwZW9mIG5ld1Byb3BzLmNoaWxkcmVuICE9PSB0eXBlb2Ygb2xkUHJvcHMuY2hpbGRyZW4gJiYgKHR5cGVvZiBuZXdQcm9wcy5jaGlsZHJlbiA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIG5ld1Byb3BzLmNoaWxkcmVuID09PSAnbnVtYmVyJykpIHtcbiAgICAgIHZhciBzdHJpbmcgPSAnJyArIG5ld1Byb3BzLmNoaWxkcmVuO1xuICAgICAgdmFyIG93bkFuY2VzdG9ySW5mbyA9IHVwZGF0ZWRBbmNlc3RvckluZm8oaG9zdENvbnRleHREZXYuYW5jZXN0b3JJbmZvLCB0eXBlKTtcbiAgICAgIHZhbGlkYXRlRE9NTmVzdGluZyhudWxsLCBzdHJpbmcsIG93bkFuY2VzdG9ySW5mbyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGRpZmZQcm9wZXJ0aWVzKGRvbUVsZW1lbnQsIHR5cGUsIG9sZFByb3BzLCBuZXdQcm9wcyk7XG59XG5mdW5jdGlvbiBzaG91bGRTZXRUZXh0Q29udGVudCh0eXBlLCBwcm9wcykge1xuICByZXR1cm4gdHlwZSA9PT0gJ3RleHRhcmVhJyB8fCB0eXBlID09PSAnb3B0aW9uJyB8fCB0eXBlID09PSAnbm9zY3JpcHQnIHx8IHR5cGVvZiBwcm9wcy5jaGlsZHJlbiA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHByb3BzLmNoaWxkcmVuID09PSAnbnVtYmVyJyB8fCB0eXBlb2YgcHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwgPT09ICdvYmplY3QnICYmIHByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MICE9PSBudWxsICYmIHByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MLl9faHRtbCAhPSBudWxsO1xufVxuZnVuY3Rpb24gY3JlYXRlVGV4dEluc3RhbmNlKHRleHQsIHJvb3RDb250YWluZXJJbnN0YW5jZSwgaG9zdENvbnRleHQsIGludGVybmFsSW5zdGFuY2VIYW5kbGUpIHtcbiAge1xuICAgIHZhciBob3N0Q29udGV4dERldiA9IGhvc3RDb250ZXh0O1xuICAgIHZhbGlkYXRlRE9NTmVzdGluZyhudWxsLCB0ZXh0LCBob3N0Q29udGV4dERldi5hbmNlc3RvckluZm8pO1xuICB9XG5cbiAgdmFyIHRleHROb2RlID0gY3JlYXRlVGV4dE5vZGUodGV4dCwgcm9vdENvbnRhaW5lckluc3RhbmNlKTtcbiAgcHJlY2FjaGVGaWJlck5vZGUoaW50ZXJuYWxJbnN0YW5jZUhhbmRsZSwgdGV4dE5vZGUpO1xuICByZXR1cm4gdGV4dE5vZGU7XG59XG4vLyBpZiBhIGNvbXBvbmVudCBqdXN0IGltcG9ydHMgUmVhY3RET00gKGUuZy4gZm9yIGZpbmRET01Ob2RlKS5cbi8vIFNvbWUgZW52aXJvbm1lbnRzIG1pZ2h0IG5vdCBoYXZlIHNldFRpbWVvdXQgb3IgY2xlYXJUaW1lb3V0LlxuXG52YXIgc2NoZWR1bGVUaW1lb3V0ID0gdHlwZW9mIHNldFRpbWVvdXQgPT09ICdmdW5jdGlvbicgPyBzZXRUaW1lb3V0IDogdW5kZWZpbmVkO1xudmFyIGNhbmNlbFRpbWVvdXQgPSB0eXBlb2YgY2xlYXJUaW1lb3V0ID09PSAnZnVuY3Rpb24nID8gY2xlYXJUaW1lb3V0IDogdW5kZWZpbmVkO1xudmFyIG5vVGltZW91dCA9IC0xOyAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tXG5mdW5jdGlvbiBjb21taXRNb3VudChkb21FbGVtZW50LCB0eXBlLCBuZXdQcm9wcywgaW50ZXJuYWxJbnN0YW5jZUhhbmRsZSkge1xuICAvLyBEZXNwaXRlIHRoZSBuYW1pbmcgdGhhdCBtaWdodCBpbXBseSBvdGhlcndpc2UsIHRoaXMgbWV0aG9kIG9ubHlcbiAgLy8gZmlyZXMgaWYgdGhlcmUgaXMgYW4gYFVwZGF0ZWAgZWZmZWN0IHNjaGVkdWxlZCBkdXJpbmcgbW91bnRpbmcuXG4gIC8vIFRoaXMgaGFwcGVucyBpZiBgZmluYWxpemVJbml0aWFsQ2hpbGRyZW5gIHJldHVybnMgYHRydWVgICh3aGljaCBpdFxuICAvLyBkb2VzIHRvIGltcGxlbWVudCB0aGUgYGF1dG9Gb2N1c2AgYXR0cmlidXRlIG9uIHRoZSBjbGllbnQpLiBCdXRcbiAgLy8gdGhlcmUgYXJlIGFsc28gb3RoZXIgY2FzZXMgd2hlbiB0aGlzIG1pZ2h0IGhhcHBlbiAoc3VjaCBhcyBwYXRjaGluZ1xuICAvLyB1cCB0ZXh0IGNvbnRlbnQgZHVyaW5nIGh5ZHJhdGlvbiBtaXNtYXRjaCkuIFNvIHdlJ2xsIGNoZWNrIHRoaXMgYWdhaW4uXG4gIGlmIChzaG91bGRBdXRvRm9jdXNIb3N0Q29tcG9uZW50KHR5cGUsIG5ld1Byb3BzKSkge1xuICAgIGRvbUVsZW1lbnQuZm9jdXMoKTtcbiAgfVxufVxuZnVuY3Rpb24gY29tbWl0VXBkYXRlKGRvbUVsZW1lbnQsIHVwZGF0ZVBheWxvYWQsIHR5cGUsIG9sZFByb3BzLCBuZXdQcm9wcywgaW50ZXJuYWxJbnN0YW5jZUhhbmRsZSkge1xuICAvLyBVcGRhdGUgdGhlIHByb3BzIGhhbmRsZSBzbyB0aGF0IHdlIGtub3cgd2hpY2ggcHJvcHMgYXJlIHRoZSBvbmVzIHdpdGhcbiAgLy8gd2l0aCBjdXJyZW50IGV2ZW50IGhhbmRsZXJzLlxuICB1cGRhdGVGaWJlclByb3BzKGRvbUVsZW1lbnQsIG5ld1Byb3BzKTsgLy8gQXBwbHkgdGhlIGRpZmYgdG8gdGhlIERPTSBub2RlLlxuXG4gIHVwZGF0ZVByb3BlcnRpZXMoZG9tRWxlbWVudCwgdXBkYXRlUGF5bG9hZCwgdHlwZSwgb2xkUHJvcHMsIG5ld1Byb3BzKTtcbn1cbmZ1bmN0aW9uIHJlc2V0VGV4dENvbnRlbnQoZG9tRWxlbWVudCkge1xuICBzZXRUZXh0Q29udGVudChkb21FbGVtZW50LCAnJyk7XG59XG5mdW5jdGlvbiBjb21taXRUZXh0VXBkYXRlKHRleHRJbnN0YW5jZSwgb2xkVGV4dCwgbmV3VGV4dCkge1xuICB0ZXh0SW5zdGFuY2Uubm9kZVZhbHVlID0gbmV3VGV4dDtcbn1cbmZ1bmN0aW9uIGFwcGVuZENoaWxkKHBhcmVudEluc3RhbmNlLCBjaGlsZCkge1xuICBwYXJlbnRJbnN0YW5jZS5hcHBlbmRDaGlsZChjaGlsZCk7XG59XG5mdW5jdGlvbiBhcHBlbmRDaGlsZFRvQ29udGFpbmVyKGNvbnRhaW5lciwgY2hpbGQpIHtcbiAgdmFyIHBhcmVudE5vZGU7XG5cbiAgaWYgKGNvbnRhaW5lci5ub2RlVHlwZSA9PT0gQ09NTUVOVF9OT0RFKSB7XG4gICAgcGFyZW50Tm9kZSA9IGNvbnRhaW5lci5wYXJlbnROb2RlO1xuICAgIHBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGNoaWxkLCBjb250YWluZXIpO1xuICB9IGVsc2Uge1xuICAgIHBhcmVudE5vZGUgPSBjb250YWluZXI7XG4gICAgcGFyZW50Tm9kZS5hcHBlbmRDaGlsZChjaGlsZCk7XG4gIH0gLy8gVGhpcyBjb250YWluZXIgbWlnaHQgYmUgdXNlZCBmb3IgYSBwb3J0YWwuXG4gIC8vIElmIHNvbWV0aGluZyBpbnNpZGUgYSBwb3J0YWwgaXMgY2xpY2tlZCwgdGhhdCBjbGljayBzaG91bGQgYnViYmxlXG4gIC8vIHRocm91Z2ggdGhlIFJlYWN0IHRyZWUuIEhvd2V2ZXIsIG9uIE1vYmlsZSBTYWZhcmkgdGhlIGNsaWNrIHdvdWxkXG4gIC8vIG5ldmVyIGJ1YmJsZSB0aHJvdWdoIHRoZSAqRE9NKiB0cmVlIHVubGVzcyBhbiBhbmNlc3RvciB3aXRoIG9uY2xpY2tcbiAgLy8gZXZlbnQgZXhpc3RzLiBTbyB3ZSB3b3VsZG4ndCBzZWUgaXQgYW5kIGRpc3BhdGNoIGl0LlxuICAvLyBUaGlzIGlzIHdoeSB3ZSBlbnN1cmUgdGhhdCBub24gUmVhY3Qgcm9vdCBjb250YWluZXJzIGhhdmUgaW5saW5lIG9uY2xpY2tcbiAgLy8gZGVmaW5lZC5cbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xMTkxOFxuXG5cbiAgdmFyIHJlYWN0Um9vdENvbnRhaW5lciA9IGNvbnRhaW5lci5fcmVhY3RSb290Q29udGFpbmVyO1xuXG4gIGlmICgocmVhY3RSb290Q29udGFpbmVyID09PSBudWxsIHx8IHJlYWN0Um9vdENvbnRhaW5lciA9PT0gdW5kZWZpbmVkKSAmJiBwYXJlbnROb2RlLm9uY2xpY2sgPT09IG51bGwpIHtcbiAgICAvLyBUT0RPOiBUaGlzIGNhc3QgbWF5IG5vdCBiZSBzb3VuZCBmb3IgU1ZHLCBNYXRoTUwgb3IgY3VzdG9tIGVsZW1lbnRzLlxuICAgIHRyYXBDbGlja09uTm9uSW50ZXJhY3RpdmVFbGVtZW50KHBhcmVudE5vZGUpO1xuICB9XG59XG5mdW5jdGlvbiBpbnNlcnRCZWZvcmUocGFyZW50SW5zdGFuY2UsIGNoaWxkLCBiZWZvcmVDaGlsZCkge1xuICBwYXJlbnRJbnN0YW5jZS5pbnNlcnRCZWZvcmUoY2hpbGQsIGJlZm9yZUNoaWxkKTtcbn1cbmZ1bmN0aW9uIGluc2VydEluQ29udGFpbmVyQmVmb3JlKGNvbnRhaW5lciwgY2hpbGQsIGJlZm9yZUNoaWxkKSB7XG4gIGlmIChjb250YWluZXIubm9kZVR5cGUgPT09IENPTU1FTlRfTk9ERSkge1xuICAgIGNvbnRhaW5lci5wYXJlbnROb2RlLmluc2VydEJlZm9yZShjaGlsZCwgYmVmb3JlQ2hpbGQpO1xuICB9IGVsc2Uge1xuICAgIGNvbnRhaW5lci5pbnNlcnRCZWZvcmUoY2hpbGQsIGJlZm9yZUNoaWxkKTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZW1vdmVDaGlsZChwYXJlbnRJbnN0YW5jZSwgY2hpbGQpIHtcbiAgcGFyZW50SW5zdGFuY2UucmVtb3ZlQ2hpbGQoY2hpbGQpO1xufVxuZnVuY3Rpb24gcmVtb3ZlQ2hpbGRGcm9tQ29udGFpbmVyKGNvbnRhaW5lciwgY2hpbGQpIHtcbiAgaWYgKGNvbnRhaW5lci5ub2RlVHlwZSA9PT0gQ09NTUVOVF9OT0RFKSB7XG4gICAgY29udGFpbmVyLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoY2hpbGQpO1xuICB9IGVsc2Uge1xuICAgIGNvbnRhaW5lci5yZW1vdmVDaGlsZChjaGlsZCk7XG4gIH1cbn1cbmZ1bmN0aW9uIGhpZGVJbnN0YW5jZShpbnN0YW5jZSkge1xuICAvLyBUT0RPOiBEb2VzIHRoaXMgd29yayBmb3IgYWxsIGVsZW1lbnQgdHlwZXM/IFdoYXQgYWJvdXQgTWF0aE1MPyBTaG91bGQgd2VcbiAgLy8gcGFzcyBob3N0IGNvbnRleHQgdG8gdGhpcyBtZXRob2Q/XG4gIGluc3RhbmNlID0gaW5zdGFuY2U7XG4gIHZhciBzdHlsZSA9IGluc3RhbmNlLnN0eWxlO1xuXG4gIGlmICh0eXBlb2Ygc3R5bGUuc2V0UHJvcGVydHkgPT09ICdmdW5jdGlvbicpIHtcbiAgICBzdHlsZS5zZXRQcm9wZXJ0eSgnZGlzcGxheScsICdub25lJywgJ2ltcG9ydGFudCcpO1xuICB9IGVsc2Uge1xuICAgIHN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gIH1cbn1cbmZ1bmN0aW9uIGhpZGVUZXh0SW5zdGFuY2UodGV4dEluc3RhbmNlKSB7XG4gIHRleHRJbnN0YW5jZS5ub2RlVmFsdWUgPSAnJztcbn1cbmZ1bmN0aW9uIHVuaGlkZUluc3RhbmNlKGluc3RhbmNlLCBwcm9wcykge1xuICBpbnN0YW5jZSA9IGluc3RhbmNlO1xuICB2YXIgc3R5bGVQcm9wID0gcHJvcHNbU1RZTEUkMV07XG4gIHZhciBkaXNwbGF5ID0gc3R5bGVQcm9wICE9PSB1bmRlZmluZWQgJiYgc3R5bGVQcm9wICE9PSBudWxsICYmIHN0eWxlUHJvcC5oYXNPd25Qcm9wZXJ0eSgnZGlzcGxheScpID8gc3R5bGVQcm9wLmRpc3BsYXkgOiBudWxsO1xuICBpbnN0YW5jZS5zdHlsZS5kaXNwbGF5ID0gZGFuZ2Vyb3VzU3R5bGVWYWx1ZSgnZGlzcGxheScsIGRpc3BsYXkpO1xufVxuZnVuY3Rpb24gdW5oaWRlVGV4dEluc3RhbmNlKHRleHRJbnN0YW5jZSwgdGV4dCkge1xuICB0ZXh0SW5zdGFuY2Uubm9kZVZhbHVlID0gdGV4dDtcbn1cbmZ1bmN0aW9uIGNsZWFyQ29udGFpbmVyKGNvbnRhaW5lcikge1xuICBpZiAoY29udGFpbmVyLm5vZGVUeXBlID09PSBFTEVNRU5UX05PREUpIHtcbiAgICBjb250YWluZXIudGV4dENvbnRlbnQgPSAnJztcbiAgfSBlbHNlIGlmIChjb250YWluZXIubm9kZVR5cGUgPT09IERPQ1VNRU5UX05PREUpIHtcbiAgICB2YXIgYm9keSA9IGNvbnRhaW5lci5ib2R5O1xuXG4gICAgaWYgKGJvZHkgIT0gbnVsbCkge1xuICAgICAgYm9keS50ZXh0Q29udGVudCA9ICcnO1xuICAgIH1cbiAgfVxufSAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tXG5mdW5jdGlvbiBjYW5IeWRyYXRlSW5zdGFuY2UoaW5zdGFuY2UsIHR5cGUsIHByb3BzKSB7XG4gIGlmIChpbnN0YW5jZS5ub2RlVHlwZSAhPT0gRUxFTUVOVF9OT0RFIHx8IHR5cGUudG9Mb3dlckNhc2UoKSAhPT0gaW5zdGFuY2Uubm9kZU5hbWUudG9Mb3dlckNhc2UoKSkge1xuICAgIHJldHVybiBudWxsO1xuICB9IC8vIFRoaXMgaGFzIG5vdyBiZWVuIHJlZmluZWQgdG8gYW4gZWxlbWVudCBub2RlLlxuXG5cbiAgcmV0dXJuIGluc3RhbmNlO1xufVxuZnVuY3Rpb24gY2FuSHlkcmF0ZVRleHRJbnN0YW5jZShpbnN0YW5jZSwgdGV4dCkge1xuICBpZiAodGV4dCA9PT0gJycgfHwgaW5zdGFuY2Uubm9kZVR5cGUgIT09IFRFWFRfTk9ERSkge1xuICAgIC8vIEVtcHR5IHN0cmluZ3MgYXJlIG5vdCBwYXJzZWQgYnkgSFRNTCBzbyB0aGVyZSB3b24ndCBiZSBhIGNvcnJlY3QgbWF0Y2ggaGVyZS5cbiAgICByZXR1cm4gbnVsbDtcbiAgfSAvLyBUaGlzIGhhcyBub3cgYmVlbiByZWZpbmVkIHRvIGEgdGV4dCBub2RlLlxuXG5cbiAgcmV0dXJuIGluc3RhbmNlO1xufVxuZnVuY3Rpb24gaXNTdXNwZW5zZUluc3RhbmNlUGVuZGluZyhpbnN0YW5jZSkge1xuICByZXR1cm4gaW5zdGFuY2UuZGF0YSA9PT0gU1VTUEVOU0VfUEVORElOR19TVEFSVF9EQVRBO1xufVxuZnVuY3Rpb24gaXNTdXNwZW5zZUluc3RhbmNlRmFsbGJhY2soaW5zdGFuY2UpIHtcbiAgcmV0dXJuIGluc3RhbmNlLmRhdGEgPT09IFNVU1BFTlNFX0ZBTExCQUNLX1NUQVJUX0RBVEE7XG59XG5cbmZ1bmN0aW9uIGdldE5leHRIeWRyYXRhYmxlKG5vZGUpIHtcbiAgLy8gU2tpcCBub24taHlkcmF0YWJsZSBub2Rlcy5cbiAgZm9yICg7IG5vZGUgIT0gbnVsbDsgbm9kZSA9IG5vZGUubmV4dFNpYmxpbmcpIHtcbiAgICB2YXIgbm9kZVR5cGUgPSBub2RlLm5vZGVUeXBlO1xuXG4gICAgaWYgKG5vZGVUeXBlID09PSBFTEVNRU5UX05PREUgfHwgbm9kZVR5cGUgPT09IFRFWFRfTk9ERSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5vZGU7XG59XG5cbmZ1bmN0aW9uIGdldE5leHRIeWRyYXRhYmxlU2libGluZyhpbnN0YW5jZSkge1xuICByZXR1cm4gZ2V0TmV4dEh5ZHJhdGFibGUoaW5zdGFuY2UubmV4dFNpYmxpbmcpO1xufVxuZnVuY3Rpb24gZ2V0Rmlyc3RIeWRyYXRhYmxlQ2hpbGQocGFyZW50SW5zdGFuY2UpIHtcbiAgcmV0dXJuIGdldE5leHRIeWRyYXRhYmxlKHBhcmVudEluc3RhbmNlLmZpcnN0Q2hpbGQpO1xufVxuZnVuY3Rpb24gaHlkcmF0ZUluc3RhbmNlKGluc3RhbmNlLCB0eXBlLCBwcm9wcywgcm9vdENvbnRhaW5lckluc3RhbmNlLCBob3N0Q29udGV4dCwgaW50ZXJuYWxJbnN0YW5jZUhhbmRsZSkge1xuICBwcmVjYWNoZUZpYmVyTm9kZShpbnRlcm5hbEluc3RhbmNlSGFuZGxlLCBpbnN0YW5jZSk7IC8vIFRPRE86IFBvc3NpYmx5IGRlZmVyIHRoaXMgdW50aWwgdGhlIGNvbW1pdCBwaGFzZSB3aGVyZSBhbGwgdGhlIGV2ZW50c1xuICAvLyBnZXQgYXR0YWNoZWQuXG5cbiAgdXBkYXRlRmliZXJQcm9wcyhpbnN0YW5jZSwgcHJvcHMpO1xuICB2YXIgcGFyZW50TmFtZXNwYWNlO1xuXG4gIHtcbiAgICB2YXIgaG9zdENvbnRleHREZXYgPSBob3N0Q29udGV4dDtcbiAgICBwYXJlbnROYW1lc3BhY2UgPSBob3N0Q29udGV4dERldi5uYW1lc3BhY2U7XG4gIH1cblxuICByZXR1cm4gZGlmZkh5ZHJhdGVkUHJvcGVydGllcyhpbnN0YW5jZSwgdHlwZSwgcHJvcHMsIHBhcmVudE5hbWVzcGFjZSk7XG59XG5mdW5jdGlvbiBoeWRyYXRlVGV4dEluc3RhbmNlKHRleHRJbnN0YW5jZSwgdGV4dCwgaW50ZXJuYWxJbnN0YW5jZUhhbmRsZSkge1xuICBwcmVjYWNoZUZpYmVyTm9kZShpbnRlcm5hbEluc3RhbmNlSGFuZGxlLCB0ZXh0SW5zdGFuY2UpO1xuICByZXR1cm4gZGlmZkh5ZHJhdGVkVGV4dCh0ZXh0SW5zdGFuY2UsIHRleHQpO1xufVxuZnVuY3Rpb24gZ2V0TmV4dEh5ZHJhdGFibGVJbnN0YW5jZUFmdGVyU3VzcGVuc2VJbnN0YW5jZShzdXNwZW5zZUluc3RhbmNlKSB7XG4gIHZhciBub2RlID0gc3VzcGVuc2VJbnN0YW5jZS5uZXh0U2libGluZzsgLy8gU2tpcCBwYXN0IGFsbCBub2RlcyB3aXRoaW4gdGhpcyBzdXNwZW5zZSBib3VuZGFyeS5cbiAgLy8gVGhlcmUgbWlnaHQgYmUgbmVzdGVkIG5vZGVzIHNvIHdlIG5lZWQgdG8ga2VlcCB0cmFjayBvZiBob3dcbiAgLy8gZGVlcCB3ZSBhcmUgYW5kIG9ubHkgYnJlYWsgb3V0IHdoZW4gd2UncmUgYmFjayBvbiB0b3AuXG5cbiAgdmFyIGRlcHRoID0gMDtcblxuICB3aGlsZSAobm9kZSkge1xuICAgIGlmIChub2RlLm5vZGVUeXBlID09PSBDT01NRU5UX05PREUpIHtcbiAgICAgIHZhciBkYXRhID0gbm9kZS5kYXRhO1xuXG4gICAgICBpZiAoZGF0YSA9PT0gU1VTUEVOU0VfRU5EX0RBVEEpIHtcbiAgICAgICAgaWYgKGRlcHRoID09PSAwKSB7XG4gICAgICAgICAgcmV0dXJuIGdldE5leHRIeWRyYXRhYmxlU2libGluZyhub2RlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkZXB0aC0tO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGRhdGEgPT09IFNVU1BFTlNFX1NUQVJUX0RBVEEgfHwgZGF0YSA9PT0gU1VTUEVOU0VfRkFMTEJBQ0tfU1RBUlRfREFUQSB8fCBkYXRhID09PSBTVVNQRU5TRV9QRU5ESU5HX1NUQVJUX0RBVEEpIHtcbiAgICAgICAgZGVwdGgrKztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBub2RlID0gbm9kZS5uZXh0U2libGluZztcbiAgfSAvLyBUT0RPOiBXYXJuLCB3ZSBkaWRuJ3QgZmluZCB0aGUgZW5kIGNvbW1lbnQgYm91bmRhcnkuXG5cblxuICByZXR1cm4gbnVsbDtcbn0gLy8gUmV0dXJucyB0aGUgU3VzcGVuc2VJbnN0YW5jZSBpZiB0aGlzIG5vZGUgaXMgYSBkaXJlY3QgY2hpbGQgb2YgYVxuLy8gU3VzcGVuc2VJbnN0YW5jZS4gSS5lLiBpZiBpdHMgcHJldmlvdXMgc2libGluZyBpcyBhIENvbW1lbnQgd2l0aFxuLy8gU1VTUEVOU0VfeF9TVEFSVF9EQVRBLiBPdGhlcndpc2UsIG51bGwuXG5cbmZ1bmN0aW9uIGdldFBhcmVudFN1c3BlbnNlSW5zdGFuY2UodGFyZ2V0SW5zdGFuY2UpIHtcbiAgdmFyIG5vZGUgPSB0YXJnZXRJbnN0YW5jZS5wcmV2aW91c1NpYmxpbmc7IC8vIFNraXAgcGFzdCBhbGwgbm9kZXMgd2l0aGluIHRoaXMgc3VzcGVuc2UgYm91bmRhcnkuXG4gIC8vIFRoZXJlIG1pZ2h0IGJlIG5lc3RlZCBub2RlcyBzbyB3ZSBuZWVkIHRvIGtlZXAgdHJhY2sgb2YgaG93XG4gIC8vIGRlZXAgd2UgYXJlIGFuZCBvbmx5IGJyZWFrIG91dCB3aGVuIHdlJ3JlIGJhY2sgb24gdG9wLlxuXG4gIHZhciBkZXB0aCA9IDA7XG5cbiAgd2hpbGUgKG5vZGUpIHtcbiAgICBpZiAobm9kZS5ub2RlVHlwZSA9PT0gQ09NTUVOVF9OT0RFKSB7XG4gICAgICB2YXIgZGF0YSA9IG5vZGUuZGF0YTtcblxuICAgICAgaWYgKGRhdGEgPT09IFNVU1BFTlNFX1NUQVJUX0RBVEEgfHwgZGF0YSA9PT0gU1VTUEVOU0VfRkFMTEJBQ0tfU1RBUlRfREFUQSB8fCBkYXRhID09PSBTVVNQRU5TRV9QRU5ESU5HX1NUQVJUX0RBVEEpIHtcbiAgICAgICAgaWYgKGRlcHRoID09PSAwKSB7XG4gICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGVwdGgtLTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChkYXRhID09PSBTVVNQRU5TRV9FTkRfREFUQSkge1xuICAgICAgICBkZXB0aCsrO1xuICAgICAgfVxuICAgIH1cblxuICAgIG5vZGUgPSBub2RlLnByZXZpb3VzU2libGluZztcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gY29tbWl0SHlkcmF0ZWRDb250YWluZXIoY29udGFpbmVyKSB7XG4gIC8vIFJldHJ5IGlmIGFueSBldmVudCByZXBsYXlpbmcgd2FzIGJsb2NrZWQgb24gdGhpcy5cbiAgcmV0cnlJZkJsb2NrZWRPbihjb250YWluZXIpO1xufVxuZnVuY3Rpb24gY29tbWl0SHlkcmF0ZWRTdXNwZW5zZUluc3RhbmNlKHN1c3BlbnNlSW5zdGFuY2UpIHtcbiAgLy8gUmV0cnkgaWYgYW55IGV2ZW50IHJlcGxheWluZyB3YXMgYmxvY2tlZCBvbiB0aGlzLlxuICByZXRyeUlmQmxvY2tlZE9uKHN1c3BlbnNlSW5zdGFuY2UpO1xufVxuZnVuY3Rpb24gZGlkTm90TWF0Y2hIeWRyYXRlZENvbnRhaW5lclRleHRJbnN0YW5jZShwYXJlbnRDb250YWluZXIsIHRleHRJbnN0YW5jZSwgdGV4dCkge1xuICB7XG4gICAgd2FybkZvclVubWF0Y2hlZFRleHQodGV4dEluc3RhbmNlLCB0ZXh0KTtcbiAgfVxufVxuZnVuY3Rpb24gZGlkTm90TWF0Y2hIeWRyYXRlZFRleHRJbnN0YW5jZShwYXJlbnRUeXBlLCBwYXJlbnRQcm9wcywgcGFyZW50SW5zdGFuY2UsIHRleHRJbnN0YW5jZSwgdGV4dCkge1xuICBpZiAoIHBhcmVudFByb3BzW1NVUFBSRVNTX0hZRFJBVElPTl9XQVJOSU5HJDFdICE9PSB0cnVlKSB7XG4gICAgd2FybkZvclVubWF0Y2hlZFRleHQodGV4dEluc3RhbmNlLCB0ZXh0KTtcbiAgfVxufVxuZnVuY3Rpb24gZGlkTm90SHlkcmF0ZUNvbnRhaW5lckluc3RhbmNlKHBhcmVudENvbnRhaW5lciwgaW5zdGFuY2UpIHtcbiAge1xuICAgIGlmIChpbnN0YW5jZS5ub2RlVHlwZSA9PT0gRUxFTUVOVF9OT0RFKSB7XG4gICAgICB3YXJuRm9yRGVsZXRlZEh5ZHJhdGFibGVFbGVtZW50KHBhcmVudENvbnRhaW5lciwgaW5zdGFuY2UpO1xuICAgIH0gZWxzZSBpZiAoaW5zdGFuY2Uubm9kZVR5cGUgPT09IENPTU1FTlRfTk9ERSkgOyBlbHNlIHtcbiAgICAgIHdhcm5Gb3JEZWxldGVkSHlkcmF0YWJsZVRleHQocGFyZW50Q29udGFpbmVyLCBpbnN0YW5jZSk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBkaWROb3RIeWRyYXRlSW5zdGFuY2UocGFyZW50VHlwZSwgcGFyZW50UHJvcHMsIHBhcmVudEluc3RhbmNlLCBpbnN0YW5jZSkge1xuICBpZiAoIHBhcmVudFByb3BzW1NVUFBSRVNTX0hZRFJBVElPTl9XQVJOSU5HJDFdICE9PSB0cnVlKSB7XG4gICAgaWYgKGluc3RhbmNlLm5vZGVUeXBlID09PSBFTEVNRU5UX05PREUpIHtcbiAgICAgIHdhcm5Gb3JEZWxldGVkSHlkcmF0YWJsZUVsZW1lbnQocGFyZW50SW5zdGFuY2UsIGluc3RhbmNlKTtcbiAgICB9IGVsc2UgaWYgKGluc3RhbmNlLm5vZGVUeXBlID09PSBDT01NRU5UX05PREUpIDsgZWxzZSB7XG4gICAgICB3YXJuRm9yRGVsZXRlZEh5ZHJhdGFibGVUZXh0KHBhcmVudEluc3RhbmNlLCBpbnN0YW5jZSk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBkaWROb3RGaW5kSHlkcmF0YWJsZUNvbnRhaW5lckluc3RhbmNlKHBhcmVudENvbnRhaW5lciwgdHlwZSwgcHJvcHMpIHtcbiAge1xuICAgIHdhcm5Gb3JJbnNlcnRlZEh5ZHJhdGVkRWxlbWVudChwYXJlbnRDb250YWluZXIsIHR5cGUpO1xuICB9XG59XG5mdW5jdGlvbiBkaWROb3RGaW5kSHlkcmF0YWJsZUNvbnRhaW5lclRleHRJbnN0YW5jZShwYXJlbnRDb250YWluZXIsIHRleHQpIHtcbiAge1xuICAgIHdhcm5Gb3JJbnNlcnRlZEh5ZHJhdGVkVGV4dChwYXJlbnRDb250YWluZXIsIHRleHQpO1xuICB9XG59XG5mdW5jdGlvbiBkaWROb3RGaW5kSHlkcmF0YWJsZUluc3RhbmNlKHBhcmVudFR5cGUsIHBhcmVudFByb3BzLCBwYXJlbnRJbnN0YW5jZSwgdHlwZSwgcHJvcHMpIHtcbiAgaWYgKCBwYXJlbnRQcm9wc1tTVVBQUkVTU19IWURSQVRJT05fV0FSTklORyQxXSAhPT0gdHJ1ZSkge1xuICAgIHdhcm5Gb3JJbnNlcnRlZEh5ZHJhdGVkRWxlbWVudChwYXJlbnRJbnN0YW5jZSwgdHlwZSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGRpZE5vdEZpbmRIeWRyYXRhYmxlVGV4dEluc3RhbmNlKHBhcmVudFR5cGUsIHBhcmVudFByb3BzLCBwYXJlbnRJbnN0YW5jZSwgdGV4dCkge1xuICBpZiAoIHBhcmVudFByb3BzW1NVUFBSRVNTX0hZRFJBVElPTl9XQVJOSU5HJDFdICE9PSB0cnVlKSB7XG4gICAgd2FybkZvckluc2VydGVkSHlkcmF0ZWRUZXh0KHBhcmVudEluc3RhbmNlLCB0ZXh0KTtcbiAgfVxufVxuZnVuY3Rpb24gZGlkTm90RmluZEh5ZHJhdGFibGVTdXNwZW5zZUluc3RhbmNlKHBhcmVudFR5cGUsIHBhcmVudFByb3BzLCBwYXJlbnRJbnN0YW5jZSkge1xuICBpZiAoIHBhcmVudFByb3BzW1NVUFBSRVNTX0hZRFJBVElPTl9XQVJOSU5HJDFdICE9PSB0cnVlKSA7XG59XG52YXIgY2xpZW50SWQgPSAwO1xuZnVuY3Rpb24gbWFrZUNsaWVudElkSW5ERVYod2Fybk9uQWNjZXNzSW5ERVYpIHtcbiAgdmFyIGlkID0gJ3I6JyArIChjbGllbnRJZCsrKS50b1N0cmluZygzNik7XG4gIHJldHVybiB7XG4gICAgdG9TdHJpbmc6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHdhcm5PbkFjY2Vzc0luREVWKCk7XG4gICAgICByZXR1cm4gaWQ7XG4gICAgfSxcbiAgICB2YWx1ZU9mOiBmdW5jdGlvbiAoKSB7XG4gICAgICB3YXJuT25BY2Nlc3NJbkRFVigpO1xuICAgICAgcmV0dXJuIGlkO1xuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIGlzT3BhcXVlSHlkcmF0aW5nT2JqZWN0KHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlLiQkdHlwZW9mID09PSBSRUFDVF9PUEFRVUVfSURfVFlQRTtcbn1cbmZ1bmN0aW9uIG1ha2VPcGFxdWVIeWRyYXRpbmdPYmplY3QoYXR0ZW1wdFRvUmVhZFZhbHVlKSB7XG4gIHJldHVybiB7XG4gICAgJCR0eXBlb2Y6IFJFQUNUX09QQVFVRV9JRF9UWVBFLFxuICAgIHRvU3RyaW5nOiBhdHRlbXB0VG9SZWFkVmFsdWUsXG4gICAgdmFsdWVPZjogYXR0ZW1wdFRvUmVhZFZhbHVlXG4gIH07XG59XG5mdW5jdGlvbiBwcmVwYXJlUG9ydGFsTW91bnQocG9ydGFsSW5zdGFuY2UpIHtcbiAge1xuICAgIGxpc3RlblRvQWxsU3VwcG9ydGVkRXZlbnRzKHBvcnRhbEluc3RhbmNlKTtcbiAgfVxufVxuXG52YXIgcmFuZG9tS2V5ID0gTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc2xpY2UoMik7XG52YXIgaW50ZXJuYWxJbnN0YW5jZUtleSA9ICdfX3JlYWN0RmliZXIkJyArIHJhbmRvbUtleTtcbnZhciBpbnRlcm5hbFByb3BzS2V5ID0gJ19fcmVhY3RQcm9wcyQnICsgcmFuZG9tS2V5O1xudmFyIGludGVybmFsQ29udGFpbmVySW5zdGFuY2VLZXkgPSAnX19yZWFjdENvbnRhaW5lciQnICsgcmFuZG9tS2V5O1xudmFyIGludGVybmFsRXZlbnRIYW5kbGVyc0tleSA9ICdfX3JlYWN0RXZlbnRzJCcgKyByYW5kb21LZXk7XG5mdW5jdGlvbiBwcmVjYWNoZUZpYmVyTm9kZShob3N0SW5zdCwgbm9kZSkge1xuICBub2RlW2ludGVybmFsSW5zdGFuY2VLZXldID0gaG9zdEluc3Q7XG59XG5mdW5jdGlvbiBtYXJrQ29udGFpbmVyQXNSb290KGhvc3RSb290LCBub2RlKSB7XG4gIG5vZGVbaW50ZXJuYWxDb250YWluZXJJbnN0YW5jZUtleV0gPSBob3N0Um9vdDtcbn1cbmZ1bmN0aW9uIHVubWFya0NvbnRhaW5lckFzUm9vdChub2RlKSB7XG4gIG5vZGVbaW50ZXJuYWxDb250YWluZXJJbnN0YW5jZUtleV0gPSBudWxsO1xufVxuZnVuY3Rpb24gaXNDb250YWluZXJNYXJrZWRBc1Jvb3Qobm9kZSkge1xuICByZXR1cm4gISFub2RlW2ludGVybmFsQ29udGFpbmVySW5zdGFuY2VLZXldO1xufSAvLyBHaXZlbiBhIERPTSBub2RlLCByZXR1cm4gdGhlIGNsb3Nlc3QgSG9zdENvbXBvbmVudCBvciBIb3N0VGV4dCBmaWJlciBhbmNlc3Rvci5cbi8vIElmIHRoZSB0YXJnZXQgbm9kZSBpcyBwYXJ0IG9mIGEgaHlkcmF0ZWQgb3Igbm90IHlldCByZW5kZXJlZCBzdWJ0cmVlLCB0aGVuXG4vLyB0aGlzIG1heSBhbHNvIHJldHVybiBhIFN1c3BlbnNlQ29tcG9uZW50IG9yIEhvc3RSb290IHRvIGluZGljYXRlIHRoYXQuXG4vLyBDb25jZXB0dWFsbHkgdGhlIEhvc3RSb290IGZpYmVyIGlzIGEgY2hpbGQgb2YgdGhlIENvbnRhaW5lciBub2RlLiBTbyBpZiB5b3Vcbi8vIHBhc3MgdGhlIENvbnRhaW5lciBub2RlIGFzIHRoZSB0YXJnZXROb2RlLCB5b3Ugd2lsbCBub3QgYWN0dWFsbHkgZ2V0IHRoZVxuLy8gSG9zdFJvb3QgYmFjay4gVG8gZ2V0IHRvIHRoZSBIb3N0Um9vdCwgeW91IG5lZWQgdG8gcGFzcyBhIGNoaWxkIG9mIGl0LlxuLy8gVGhlIHNhbWUgdGhpbmcgYXBwbGllcyB0byBTdXNwZW5zZSBib3VuZGFyaWVzLlxuXG5mdW5jdGlvbiBnZXRDbG9zZXN0SW5zdGFuY2VGcm9tTm9kZSh0YXJnZXROb2RlKSB7XG4gIHZhciB0YXJnZXRJbnN0ID0gdGFyZ2V0Tm9kZVtpbnRlcm5hbEluc3RhbmNlS2V5XTtcblxuICBpZiAodGFyZ2V0SW5zdCkge1xuICAgIC8vIERvbid0IHJldHVybiBIb3N0Um9vdCBvciBTdXNwZW5zZUNvbXBvbmVudCBoZXJlLlxuICAgIHJldHVybiB0YXJnZXRJbnN0O1xuICB9IC8vIElmIHRoZSBkaXJlY3QgZXZlbnQgdGFyZ2V0IGlzbid0IGEgUmVhY3Qgb3duZWQgRE9NIG5vZGUsIHdlIG5lZWQgdG8gbG9va1xuICAvLyB0byBzZWUgaWYgb25lIG9mIGl0cyBwYXJlbnRzIGlzIGEgUmVhY3Qgb3duZWQgRE9NIG5vZGUuXG5cblxuICB2YXIgcGFyZW50Tm9kZSA9IHRhcmdldE5vZGUucGFyZW50Tm9kZTtcblxuICB3aGlsZSAocGFyZW50Tm9kZSkge1xuICAgIC8vIFdlJ2xsIGNoZWNrIGlmIHRoaXMgaXMgYSBjb250YWluZXIgcm9vdCB0aGF0IGNvdWxkIGluY2x1ZGVcbiAgICAvLyBSZWFjdCBub2RlcyBpbiB0aGUgZnV0dXJlLiBXZSBuZWVkIHRvIGNoZWNrIHRoaXMgZmlyc3QgYmVjYXVzZVxuICAgIC8vIGlmIHdlJ3JlIGEgY2hpbGQgb2YgYSBkZWh5ZHJhdGVkIGNvbnRhaW5lciwgd2UgbmVlZCB0byBmaXJzdFxuICAgIC8vIGZpbmQgdGhhdCBpbm5lciBjb250YWluZXIgYmVmb3JlIG1vdmluZyBvbiB0byBmaW5kaW5nIHRoZSBwYXJlbnRcbiAgICAvLyBpbnN0YW5jZS4gTm90ZSB0aGF0IHdlIGRvbid0IGNoZWNrIHRoaXMgZmllbGQgb24gIHRoZSB0YXJnZXROb2RlXG4gICAgLy8gaXRzZWxmIGJlY2F1c2UgdGhlIGZpYmVycyBhcmUgY29uY2VwdHVhbGx5IGJldHdlZW4gdGhlIGNvbnRhaW5lclxuICAgIC8vIG5vZGUgYW5kIHRoZSBmaXJzdCBjaGlsZC4gSXQgaXNuJ3Qgc3Vycm91bmRpbmcgdGhlIGNvbnRhaW5lciBub2RlLlxuICAgIC8vIElmIGl0J3Mgbm90IGEgY29udGFpbmVyLCB3ZSBjaGVjayBpZiBpdCdzIGFuIGluc3RhbmNlLlxuICAgIHRhcmdldEluc3QgPSBwYXJlbnROb2RlW2ludGVybmFsQ29udGFpbmVySW5zdGFuY2VLZXldIHx8IHBhcmVudE5vZGVbaW50ZXJuYWxJbnN0YW5jZUtleV07XG5cbiAgICBpZiAodGFyZ2V0SW5zdCkge1xuICAgICAgLy8gU2luY2UgdGhpcyB3YXNuJ3QgdGhlIGRpcmVjdCB0YXJnZXQgb2YgdGhlIGV2ZW50LCB3ZSBtaWdodCBoYXZlXG4gICAgICAvLyBzdGVwcGVkIHBhc3QgZGVoeWRyYXRlZCBET00gbm9kZXMgdG8gZ2V0IGhlcmUuIEhvd2V2ZXIgdGhleSBjb3VsZFxuICAgICAgLy8gYWxzbyBoYXZlIGJlZW4gbm9uLVJlYWN0IG5vZGVzLiBXZSBuZWVkIHRvIGFuc3dlciB3aGljaCBvbmUuXG4gICAgICAvLyBJZiB3ZSB0aGUgaW5zdGFuY2UgZG9lc24ndCBoYXZlIGFueSBjaGlsZHJlbiwgdGhlbiB0aGVyZSBjYW4ndCBiZVxuICAgICAgLy8gYSBuZXN0ZWQgc3VzcGVuc2UgYm91bmRhcnkgd2l0aGluIGl0LiBTbyB3ZSBjYW4gdXNlIHRoaXMgYXMgYSBmYXN0XG4gICAgICAvLyBiYWlsb3V0LiBNb3N0IG9mIHRoZSB0aW1lLCB3aGVuIHBlb3BsZSBhZGQgbm9uLVJlYWN0IGNoaWxkcmVuIHRvXG4gICAgICAvLyB0aGUgdHJlZSwgaXQgaXMgdXNpbmcgYSByZWYgdG8gYSBjaGlsZC1sZXNzIERPTSBub2RlLlxuICAgICAgLy8gTm9ybWFsbHkgd2UnZCBvbmx5IG5lZWQgdG8gY2hlY2sgb25lIG9mIHRoZSBmaWJlcnMgYmVjYXVzZSBpZiBpdFxuICAgICAgLy8gaGFzIGV2ZXIgZ29uZSBmcm9tIGhhdmluZyBjaGlsZHJlbiB0byBkZWxldGluZyB0aGVtIG9yIHZpY2UgdmVyc2FcbiAgICAgIC8vIGl0IHdvdWxkIGhhdmUgZGVsZXRlZCB0aGUgZGVoeWRyYXRlZCBib3VuZGFyeSBuZXN0ZWQgaW5zaWRlIGFscmVhZHkuXG4gICAgICAvLyBIb3dldmVyLCBzaW5jZSB0aGUgSG9zdFJvb3Qgc3RhcnRzIG91dCB3aXRoIGFuIGFsdGVybmF0ZSBpdCBtaWdodFxuICAgICAgLy8gaGF2ZSBvbmUgb24gdGhlIGFsdGVybmF0ZSBzbyB3ZSBuZWVkIHRvIGNoZWNrIGluIGNhc2UgdGhpcyB3YXMgYVxuICAgICAgLy8gcm9vdC5cbiAgICAgIHZhciBhbHRlcm5hdGUgPSB0YXJnZXRJbnN0LmFsdGVybmF0ZTtcblxuICAgICAgaWYgKHRhcmdldEluc3QuY2hpbGQgIT09IG51bGwgfHwgYWx0ZXJuYXRlICE9PSBudWxsICYmIGFsdGVybmF0ZS5jaGlsZCAhPT0gbnVsbCkge1xuICAgICAgICAvLyBOZXh0IHdlIG5lZWQgdG8gZmlndXJlIG91dCBpZiB0aGUgbm9kZSB0aGF0IHNraXBwZWQgcGFzdCBpc1xuICAgICAgICAvLyBuZXN0ZWQgd2l0aGluIGEgZGVoeWRyYXRlZCBib3VuZGFyeSBhbmQgaWYgc28sIHdoaWNoIG9uZS5cbiAgICAgICAgdmFyIHN1c3BlbnNlSW5zdGFuY2UgPSBnZXRQYXJlbnRTdXNwZW5zZUluc3RhbmNlKHRhcmdldE5vZGUpO1xuXG4gICAgICAgIHdoaWxlIChzdXNwZW5zZUluc3RhbmNlICE9PSBudWxsKSB7XG4gICAgICAgICAgLy8gV2UgZm91bmQgYSBzdXNwZW5zZSBpbnN0YW5jZS4gVGhhdCBtZWFucyB0aGF0IHdlIGhhdmVuJ3RcbiAgICAgICAgICAvLyBoeWRyYXRlZCBpdCB5ZXQuIEV2ZW4gdGhvdWdoIHdlIGxlYXZlIHRoZSBjb21tZW50cyBpbiB0aGVcbiAgICAgICAgICAvLyBET00gYWZ0ZXIgaHlkcmF0aW5nLCBhbmQgdGhlcmUgYXJlIGJvdW5kYXJpZXMgaW4gdGhlIERPTVxuICAgICAgICAgIC8vIHRoYXQgY291bGQgYWxyZWFkeSBiZSBoeWRyYXRlZCwgd2Ugd291bGRuJ3QgaGF2ZSBmb3VuZCB0aGVtXG4gICAgICAgICAgLy8gdGhyb3VnaCB0aGlzIHBhc3Mgc2luY2UgaWYgdGhlIHRhcmdldCBpcyBoeWRyYXRlZCBpdCB3b3VsZFxuICAgICAgICAgIC8vIGhhdmUgaGFkIGFuIGludGVybmFsSW5zdGFuY2VLZXkgb24gaXQuXG4gICAgICAgICAgLy8gTGV0J3MgZ2V0IHRoZSBmaWJlciBhc3NvY2lhdGVkIHdpdGggdGhlIFN1c3BlbnNlQ29tcG9uZW50XG4gICAgICAgICAgLy8gYXMgdGhlIGRlZXBlc3QgaW5zdGFuY2UuXG4gICAgICAgICAgdmFyIHRhcmdldFN1c3BlbnNlSW5zdCA9IHN1c3BlbnNlSW5zdGFuY2VbaW50ZXJuYWxJbnN0YW5jZUtleV07XG5cbiAgICAgICAgICBpZiAodGFyZ2V0U3VzcGVuc2VJbnN0KSB7XG4gICAgICAgICAgICByZXR1cm4gdGFyZ2V0U3VzcGVuc2VJbnN0O1xuICAgICAgICAgIH0gLy8gSWYgd2UgZG9uJ3QgZmluZCBhIEZpYmVyIG9uIHRoZSBjb21tZW50LCBpdCBtaWdodCBiZSBiZWNhdXNlXG4gICAgICAgICAgLy8gd2UgaGF2ZW4ndCBnb3R0ZW4gdG8gaHlkcmF0ZSBpdCB5ZXQuIFRoZXJlIG1pZ2h0IHN0aWxsIGJlIGFcbiAgICAgICAgICAvLyBwYXJlbnQgYm91bmRhcnkgdGhhdCBoYXNuJ3QgYWJvdmUgdGhpcyBvbmUgc28gd2UgbmVlZCB0byBmaW5kXG4gICAgICAgICAgLy8gdGhlIG91dGVyIG1vc3QgdGhhdCBpcyBrbm93bi5cblxuXG4gICAgICAgICAgc3VzcGVuc2VJbnN0YW5jZSA9IGdldFBhcmVudFN1c3BlbnNlSW5zdGFuY2Uoc3VzcGVuc2VJbnN0YW5jZSk7IC8vIElmIHdlIGRvbid0IGZpbmQgb25lLCB0aGVuIHRoYXQgc2hvdWxkIG1lYW4gdGhhdCB0aGUgcGFyZW50XG4gICAgICAgICAgLy8gaG9zdCBjb21wb25lbnQgYWxzbyBoYXNuJ3QgaHlkcmF0ZWQgeWV0LiBXZSBjYW4gcmV0dXJuIGl0XG4gICAgICAgICAgLy8gYmVsb3cgc2luY2UgaXQgd2lsbCBiYWlsIG91dCBvbiB0aGUgaXNNb3VudGVkIGNoZWNrIGxhdGVyLlxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0YXJnZXRJbnN0O1xuICAgIH1cblxuICAgIHRhcmdldE5vZGUgPSBwYXJlbnROb2RlO1xuICAgIHBhcmVudE5vZGUgPSB0YXJnZXROb2RlLnBhcmVudE5vZGU7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cbi8qKlxuICogR2l2ZW4gYSBET00gbm9kZSwgcmV0dXJuIHRoZSBSZWFjdERPTUNvbXBvbmVudCBvciBSZWFjdERPTVRleHRDb21wb25lbnRcbiAqIGluc3RhbmNlLCBvciBudWxsIGlmIHRoZSBub2RlIHdhcyBub3QgcmVuZGVyZWQgYnkgdGhpcyBSZWFjdC5cbiAqL1xuXG5mdW5jdGlvbiBnZXRJbnN0YW5jZUZyb21Ob2RlKG5vZGUpIHtcbiAgdmFyIGluc3QgPSBub2RlW2ludGVybmFsSW5zdGFuY2VLZXldIHx8IG5vZGVbaW50ZXJuYWxDb250YWluZXJJbnN0YW5jZUtleV07XG5cbiAgaWYgKGluc3QpIHtcbiAgICBpZiAoaW5zdC50YWcgPT09IEhvc3RDb21wb25lbnQgfHwgaW5zdC50YWcgPT09IEhvc3RUZXh0IHx8IGluc3QudGFnID09PSBTdXNwZW5zZUNvbXBvbmVudCB8fCBpbnN0LnRhZyA9PT0gSG9zdFJvb3QpIHtcbiAgICAgIHJldHVybiBpbnN0O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cbi8qKlxuICogR2l2ZW4gYSBSZWFjdERPTUNvbXBvbmVudCBvciBSZWFjdERPTVRleHRDb21wb25lbnQsIHJldHVybiB0aGUgY29ycmVzcG9uZGluZ1xuICogRE9NIG5vZGUuXG4gKi9cblxuZnVuY3Rpb24gZ2V0Tm9kZUZyb21JbnN0YW5jZShpbnN0KSB7XG4gIGlmIChpbnN0LnRhZyA9PT0gSG9zdENvbXBvbmVudCB8fCBpbnN0LnRhZyA9PT0gSG9zdFRleHQpIHtcbiAgICAvLyBJbiBGaWJlciB0aGlzLCBpcyBqdXN0IHRoZSBzdGF0ZSBub2RlIHJpZ2h0IG5vdy4gV2UgYXNzdW1lIGl0IHdpbGwgYmVcbiAgICAvLyBhIGhvc3QgY29tcG9uZW50IG9yIGhvc3QgdGV4dC5cbiAgICByZXR1cm4gaW5zdC5zdGF0ZU5vZGU7XG4gIH0gLy8gV2l0aG91dCB0aGlzIGZpcnN0IGludmFyaWFudCwgcGFzc2luZyBhIG5vbi1ET00tY29tcG9uZW50IHRyaWdnZXJzIHRoZSBuZXh0XG4gIC8vIGludmFyaWFudCBmb3IgYSBtaXNzaW5nIHBhcmVudCwgd2hpY2ggaXMgc3VwZXIgY29uZnVzaW5nLlxuXG5cbiAge1xuICAgIHtcbiAgICAgIHRocm93IEVycm9yKCBcImdldE5vZGVGcm9tSW5zdGFuY2U6IEludmFsaWQgYXJndW1lbnQuXCIgKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGdldEZpYmVyQ3VycmVudFByb3BzRnJvbU5vZGUobm9kZSkge1xuICByZXR1cm4gbm9kZVtpbnRlcm5hbFByb3BzS2V5XSB8fCBudWxsO1xufVxuZnVuY3Rpb24gdXBkYXRlRmliZXJQcm9wcyhub2RlLCBwcm9wcykge1xuICBub2RlW2ludGVybmFsUHJvcHNLZXldID0gcHJvcHM7XG59XG5mdW5jdGlvbiBnZXRFdmVudExpc3RlbmVyU2V0KG5vZGUpIHtcbiAgdmFyIGVsZW1lbnRMaXN0ZW5lclNldCA9IG5vZGVbaW50ZXJuYWxFdmVudEhhbmRsZXJzS2V5XTtcblxuICBpZiAoZWxlbWVudExpc3RlbmVyU2V0ID09PSB1bmRlZmluZWQpIHtcbiAgICBlbGVtZW50TGlzdGVuZXJTZXQgPSBub2RlW2ludGVybmFsRXZlbnRIYW5kbGVyc0tleV0gPSBuZXcgU2V0KCk7XG4gIH1cblxuICByZXR1cm4gZWxlbWVudExpc3RlbmVyU2V0O1xufVxuXG52YXIgbG9nZ2VkVHlwZUZhaWx1cmVzID0ge307XG52YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSQxID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZTtcblxuZnVuY3Rpb24gc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZWxlbWVudCkge1xuICB7XG4gICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgIHZhciBvd25lciA9IGVsZW1lbnQuX293bmVyO1xuICAgICAgdmFyIHN0YWNrID0gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKGVsZW1lbnQudHlwZSwgZWxlbWVudC5fc291cmNlLCBvd25lciA/IG93bmVyLnR5cGUgOiBudWxsKTtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWUkMS5zZXRFeHRyYVN0YWNrRnJhbWUoc3RhY2spO1xuICAgIH0gZWxzZSB7XG4gICAgICBSZWFjdERlYnVnQ3VycmVudEZyYW1lJDEuc2V0RXh0cmFTdGFja0ZyYW1lKG51bGwpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjaGVja1Byb3BUeXBlcyh0eXBlU3BlY3MsIHZhbHVlcywgbG9jYXRpb24sIGNvbXBvbmVudE5hbWUsIGVsZW1lbnQpIHtcbiAge1xuICAgIC8vICRGbG93Rml4TWUgVGhpcyBpcyBva2F5IGJ1dCBGbG93IGRvZXNuJ3Qga25vdyBpdC5cbiAgICB2YXIgaGFzID0gRnVuY3Rpb24uY2FsbC5iaW5kKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkpO1xuXG4gICAgZm9yICh2YXIgdHlwZVNwZWNOYW1lIGluIHR5cGVTcGVjcykge1xuICAgICAgaWYgKGhhcyh0eXBlU3BlY3MsIHR5cGVTcGVjTmFtZSkpIHtcbiAgICAgICAgdmFyIGVycm9yJDEgPSB2b2lkIDA7IC8vIFByb3AgdHlwZSB2YWxpZGF0aW9uIG1heSB0aHJvdy4gSW4gY2FzZSB0aGV5IGRvLCB3ZSBkb24ndCB3YW50IHRvXG4gICAgICAgIC8vIGZhaWwgdGhlIHJlbmRlciBwaGFzZSB3aGVyZSBpdCBkaWRuJ3QgZmFpbCBiZWZvcmUuIFNvIHdlIGxvZyBpdC5cbiAgICAgICAgLy8gQWZ0ZXIgdGhlc2UgaGF2ZSBiZWVuIGNsZWFuZWQgdXAsIHdlJ2xsIGxldCB0aGVtIHRocm93LlxuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgLy8gVGhpcyBpcyBpbnRlbnRpb25hbGx5IGFuIGludmFyaWFudCB0aGF0IGdldHMgY2F1Z2h0LiBJdCdzIHRoZSBzYW1lXG4gICAgICAgICAgLy8gYmVoYXZpb3IgYXMgd2l0aG91dCB0aGlzIHN0YXRlbWVudCBleGNlcHQgd2l0aCBhIGJldHRlciBtZXNzYWdlLlxuICAgICAgICAgIGlmICh0eXBlb2YgdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHZhciBlcnIgPSBFcnJvcigoY29tcG9uZW50TmFtZSB8fCAnUmVhY3QgY2xhc3MnKSArICc6ICcgKyBsb2NhdGlvbiArICcgdHlwZSBgJyArIHR5cGVTcGVjTmFtZSArICdgIGlzIGludmFsaWQ7ICcgKyAnaXQgbXVzdCBiZSBhIGZ1bmN0aW9uLCB1c3VhbGx5IGZyb20gdGhlIGBwcm9wLXR5cGVzYCBwYWNrYWdlLCBidXQgcmVjZWl2ZWQgYCcgKyB0eXBlb2YgdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0gKyAnYC4nICsgJ1RoaXMgb2Z0ZW4gaGFwcGVucyBiZWNhdXNlIG9mIHR5cG9zIHN1Y2ggYXMgYFByb3BUeXBlcy5mdW5jdGlvbmAgaW5zdGVhZCBvZiBgUHJvcFR5cGVzLmZ1bmNgLicpO1xuICAgICAgICAgICAgZXJyLm5hbWUgPSAnSW52YXJpYW50IFZpb2xhdGlvbic7XG4gICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZXJyb3IkMSA9IHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdKHZhbHVlcywgdHlwZVNwZWNOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgbnVsbCwgJ1NFQ1JFVF9ET19OT1RfUEFTU19USElTX09SX1lPVV9XSUxMX0JFX0ZJUkVEJyk7XG4gICAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgZXJyb3IkMSA9IGV4O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVycm9yJDEgJiYgIShlcnJvciQxIGluc3RhbmNlb2YgRXJyb3IpKSB7XG4gICAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZWxlbWVudCk7XG5cbiAgICAgICAgICBlcnJvcignJXM6IHR5cGUgc3BlY2lmaWNhdGlvbiBvZiAlcycgKyAnIGAlc2AgaXMgaW52YWxpZDsgdGhlIHR5cGUgY2hlY2tlciAnICsgJ2Z1bmN0aW9uIG11c3QgcmV0dXJuIGBudWxsYCBvciBhbiBgRXJyb3JgIGJ1dCByZXR1cm5lZCBhICVzLiAnICsgJ1lvdSBtYXkgaGF2ZSBmb3Jnb3R0ZW4gdG8gcGFzcyBhbiBhcmd1bWVudCB0byB0aGUgdHlwZSBjaGVja2VyICcgKyAnY3JlYXRvciAoYXJyYXlPZiwgaW5zdGFuY2VPZiwgb2JqZWN0T2YsIG9uZU9mLCBvbmVPZlR5cGUsIGFuZCAnICsgJ3NoYXBlIGFsbCByZXF1aXJlIGFuIGFyZ3VtZW50KS4nLCBjb21wb25lbnROYW1lIHx8ICdSZWFjdCBjbGFzcycsIGxvY2F0aW9uLCB0eXBlU3BlY05hbWUsIHR5cGVvZiBlcnJvciQxKTtcblxuICAgICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KG51bGwpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVycm9yJDEgaW5zdGFuY2VvZiBFcnJvciAmJiAhKGVycm9yJDEubWVzc2FnZSBpbiBsb2dnZWRUeXBlRmFpbHVyZXMpKSB7XG4gICAgICAgICAgLy8gT25seSBtb25pdG9yIHRoaXMgZmFpbHVyZSBvbmNlIGJlY2F1c2UgdGhlcmUgdGVuZHMgdG8gYmUgYSBsb3Qgb2YgdGhlXG4gICAgICAgICAgLy8gc2FtZSBlcnJvci5cbiAgICAgICAgICBsb2dnZWRUeXBlRmFpbHVyZXNbZXJyb3IkMS5tZXNzYWdlXSA9IHRydWU7XG4gICAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZWxlbWVudCk7XG5cbiAgICAgICAgICBlcnJvcignRmFpbGVkICVzIHR5cGU6ICVzJywgbG9jYXRpb24sIGVycm9yJDEubWVzc2FnZSk7XG5cbiAgICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChudWxsKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG52YXIgdmFsdWVTdGFjayA9IFtdO1xudmFyIGZpYmVyU3RhY2s7XG5cbntcbiAgZmliZXJTdGFjayA9IFtdO1xufVxuXG52YXIgaW5kZXggPSAtMTtcblxuZnVuY3Rpb24gY3JlYXRlQ3Vyc29yKGRlZmF1bHRWYWx1ZSkge1xuICByZXR1cm4ge1xuICAgIGN1cnJlbnQ6IGRlZmF1bHRWYWx1ZVxuICB9O1xufVxuXG5mdW5jdGlvbiBwb3AoY3Vyc29yLCBmaWJlcikge1xuICBpZiAoaW5kZXggPCAwKSB7XG4gICAge1xuICAgICAgZXJyb3IoJ1VuZXhwZWN0ZWQgcG9wLicpO1xuICAgIH1cblxuICAgIHJldHVybjtcbiAgfVxuXG4gIHtcbiAgICBpZiAoZmliZXIgIT09IGZpYmVyU3RhY2tbaW5kZXhdKSB7XG4gICAgICBlcnJvcignVW5leHBlY3RlZCBGaWJlciBwb3BwZWQuJyk7XG4gICAgfVxuICB9XG5cbiAgY3Vyc29yLmN1cnJlbnQgPSB2YWx1ZVN0YWNrW2luZGV4XTtcbiAgdmFsdWVTdGFja1tpbmRleF0gPSBudWxsO1xuXG4gIHtcbiAgICBmaWJlclN0YWNrW2luZGV4XSA9IG51bGw7XG4gIH1cblxuICBpbmRleC0tO1xufVxuXG5mdW5jdGlvbiBwdXNoKGN1cnNvciwgdmFsdWUsIGZpYmVyKSB7XG4gIGluZGV4Kys7XG4gIHZhbHVlU3RhY2tbaW5kZXhdID0gY3Vyc29yLmN1cnJlbnQ7XG5cbiAge1xuICAgIGZpYmVyU3RhY2tbaW5kZXhdID0gZmliZXI7XG4gIH1cblxuICBjdXJzb3IuY3VycmVudCA9IHZhbHVlO1xufVxuXG52YXIgd2FybmVkQWJvdXRNaXNzaW5nR2V0Q2hpbGRDb250ZXh0O1xuXG57XG4gIHdhcm5lZEFib3V0TWlzc2luZ0dldENoaWxkQ29udGV4dCA9IHt9O1xufVxuXG52YXIgZW1wdHlDb250ZXh0T2JqZWN0ID0ge307XG5cbntcbiAgT2JqZWN0LmZyZWV6ZShlbXB0eUNvbnRleHRPYmplY3QpO1xufSAvLyBBIGN1cnNvciB0byB0aGUgY3VycmVudCBtZXJnZWQgY29udGV4dCBvYmplY3Qgb24gdGhlIHN0YWNrLlxuXG5cbnZhciBjb250ZXh0U3RhY2tDdXJzb3IgPSBjcmVhdGVDdXJzb3IoZW1wdHlDb250ZXh0T2JqZWN0KTsgLy8gQSBjdXJzb3IgdG8gYSBib29sZWFuIGluZGljYXRpbmcgd2hldGhlciB0aGUgY29udGV4dCBoYXMgY2hhbmdlZC5cblxudmFyIGRpZFBlcmZvcm1Xb3JrU3RhY2tDdXJzb3IgPSBjcmVhdGVDdXJzb3IoZmFsc2UpOyAvLyBLZWVwIHRyYWNrIG9mIHRoZSBwcmV2aW91cyBjb250ZXh0IG9iamVjdCB0aGF0IHdhcyBvbiB0aGUgc3RhY2suXG4vLyBXZSB1c2UgdGhpcyB0byBnZXQgYWNjZXNzIHRvIHRoZSBwYXJlbnQgY29udGV4dCBhZnRlciB3ZSBoYXZlIGFscmVhZHlcbi8vIHB1c2hlZCB0aGUgbmV4dCBjb250ZXh0IHByb3ZpZGVyLCBhbmQgbm93IG5lZWQgdG8gbWVyZ2UgdGhlaXIgY29udGV4dHMuXG5cbnZhciBwcmV2aW91c0NvbnRleHQgPSBlbXB0eUNvbnRleHRPYmplY3Q7XG5cbmZ1bmN0aW9uIGdldFVubWFza2VkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgQ29tcG9uZW50LCBkaWRQdXNoT3duQ29udGV4dElmUHJvdmlkZXIpIHtcbiAge1xuICAgIGlmIChkaWRQdXNoT3duQ29udGV4dElmUHJvdmlkZXIgJiYgaXNDb250ZXh0UHJvdmlkZXIoQ29tcG9uZW50KSkge1xuICAgICAgLy8gSWYgdGhlIGZpYmVyIGlzIGEgY29udGV4dCBwcm92aWRlciBpdHNlbGYsIHdoZW4gd2UgcmVhZCBpdHMgY29udGV4dFxuICAgICAgLy8gd2UgbWF5IGhhdmUgYWxyZWFkeSBwdXNoZWQgaXRzIG93biBjaGlsZCBjb250ZXh0IG9uIHRoZSBzdGFjay4gQSBjb250ZXh0XG4gICAgICAvLyBwcm92aWRlciBzaG91bGQgbm90IFwic2VlXCIgaXRzIG93biBjaGlsZCBjb250ZXh0LiBUaGVyZWZvcmUgd2UgcmVhZCB0aGVcbiAgICAgIC8vIHByZXZpb3VzIChwYXJlbnQpIGNvbnRleHQgaW5zdGVhZCBmb3IgYSBjb250ZXh0IHByb3ZpZGVyLlxuICAgICAgcmV0dXJuIHByZXZpb3VzQ29udGV4dDtcbiAgICB9XG5cbiAgICByZXR1cm4gY29udGV4dFN0YWNrQ3Vyc29yLmN1cnJlbnQ7XG4gIH1cbn1cblxuZnVuY3Rpb24gY2FjaGVDb250ZXh0KHdvcmtJblByb2dyZXNzLCB1bm1hc2tlZENvbnRleHQsIG1hc2tlZENvbnRleHQpIHtcbiAge1xuICAgIHZhciBpbnN0YW5jZSA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcbiAgICBpbnN0YW5jZS5fX3JlYWN0SW50ZXJuYWxNZW1vaXplZFVubWFza2VkQ2hpbGRDb250ZXh0ID0gdW5tYXNrZWRDb250ZXh0O1xuICAgIGluc3RhbmNlLl9fcmVhY3RJbnRlcm5hbE1lbW9pemVkTWFza2VkQ2hpbGRDb250ZXh0ID0gbWFza2VkQ29udGV4dDtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRNYXNrZWRDb250ZXh0KHdvcmtJblByb2dyZXNzLCB1bm1hc2tlZENvbnRleHQpIHtcbiAge1xuICAgIHZhciB0eXBlID0gd29ya0luUHJvZ3Jlc3MudHlwZTtcbiAgICB2YXIgY29udGV4dFR5cGVzID0gdHlwZS5jb250ZXh0VHlwZXM7XG5cbiAgICBpZiAoIWNvbnRleHRUeXBlcykge1xuICAgICAgcmV0dXJuIGVtcHR5Q29udGV4dE9iamVjdDtcbiAgICB9IC8vIEF2b2lkIHJlY3JlYXRpbmcgbWFza2VkIGNvbnRleHQgdW5sZXNzIHVubWFza2VkIGNvbnRleHQgaGFzIGNoYW5nZWQuXG4gICAgLy8gRmFpbGluZyB0byBkbyB0aGlzIHdpbGwgcmVzdWx0IGluIHVubmVjZXNzYXJ5IGNhbGxzIHRvIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMuXG4gICAgLy8gVGhpcyBtYXkgdHJpZ2dlciBpbmZpbml0ZSBsb29wcyBpZiBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzIGNhbGxzIHNldFN0YXRlLlxuXG5cbiAgICB2YXIgaW5zdGFuY2UgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG5cbiAgICBpZiAoaW5zdGFuY2UgJiYgaW5zdGFuY2UuX19yZWFjdEludGVybmFsTWVtb2l6ZWRVbm1hc2tlZENoaWxkQ29udGV4dCA9PT0gdW5tYXNrZWRDb250ZXh0KSB7XG4gICAgICByZXR1cm4gaW5zdGFuY2UuX19yZWFjdEludGVybmFsTWVtb2l6ZWRNYXNrZWRDaGlsZENvbnRleHQ7XG4gICAgfVxuXG4gICAgdmFyIGNvbnRleHQgPSB7fTtcblxuICAgIGZvciAodmFyIGtleSBpbiBjb250ZXh0VHlwZXMpIHtcbiAgICAgIGNvbnRleHRba2V5XSA9IHVubWFza2VkQ29udGV4dFtrZXldO1xuICAgIH1cblxuICAgIHtcbiAgICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZSh0eXBlKSB8fCAnVW5rbm93bic7XG4gICAgICBjaGVja1Byb3BUeXBlcyhjb250ZXh0VHlwZXMsIGNvbnRleHQsICdjb250ZXh0JywgbmFtZSk7XG4gICAgfSAvLyBDYWNoZSB1bm1hc2tlZCBjb250ZXh0IHNvIHdlIGNhbiBhdm9pZCByZWNyZWF0aW5nIG1hc2tlZCBjb250ZXh0IHVubGVzcyBuZWNlc3NhcnkuXG4gICAgLy8gQ29udGV4dCBpcyBjcmVhdGVkIGJlZm9yZSB0aGUgY2xhc3MgY29tcG9uZW50IGlzIGluc3RhbnRpYXRlZCBzbyBjaGVjayBmb3IgaW5zdGFuY2UuXG5cblxuICAgIGlmIChpbnN0YW5jZSkge1xuICAgICAgY2FjaGVDb250ZXh0KHdvcmtJblByb2dyZXNzLCB1bm1hc2tlZENvbnRleHQsIGNvbnRleHQpO1xuICAgIH1cblxuICAgIHJldHVybiBjb250ZXh0O1xuICB9XG59XG5cbmZ1bmN0aW9uIGhhc0NvbnRleHRDaGFuZ2VkKCkge1xuICB7XG4gICAgcmV0dXJuIGRpZFBlcmZvcm1Xb3JrU3RhY2tDdXJzb3IuY3VycmVudDtcbiAgfVxufVxuXG5mdW5jdGlvbiBpc0NvbnRleHRQcm92aWRlcih0eXBlKSB7XG4gIHtcbiAgICB2YXIgY2hpbGRDb250ZXh0VHlwZXMgPSB0eXBlLmNoaWxkQ29udGV4dFR5cGVzO1xuICAgIHJldHVybiBjaGlsZENvbnRleHRUeXBlcyAhPT0gbnVsbCAmJiBjaGlsZENvbnRleHRUeXBlcyAhPT0gdW5kZWZpbmVkO1xuICB9XG59XG5cbmZ1bmN0aW9uIHBvcENvbnRleHQoZmliZXIpIHtcbiAge1xuICAgIHBvcChkaWRQZXJmb3JtV29ya1N0YWNrQ3Vyc29yLCBmaWJlcik7XG4gICAgcG9wKGNvbnRleHRTdGFja0N1cnNvciwgZmliZXIpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHBvcFRvcExldmVsQ29udGV4dE9iamVjdChmaWJlcikge1xuICB7XG4gICAgcG9wKGRpZFBlcmZvcm1Xb3JrU3RhY2tDdXJzb3IsIGZpYmVyKTtcbiAgICBwb3AoY29udGV4dFN0YWNrQ3Vyc29yLCBmaWJlcik7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHVzaFRvcExldmVsQ29udGV4dE9iamVjdChmaWJlciwgY29udGV4dCwgZGlkQ2hhbmdlKSB7XG4gIHtcbiAgICBpZiAoIShjb250ZXh0U3RhY2tDdXJzb3IuY3VycmVudCA9PT0gZW1wdHlDb250ZXh0T2JqZWN0KSkge1xuICAgICAge1xuICAgICAgICB0aHJvdyBFcnJvciggXCJVbmV4cGVjdGVkIGNvbnRleHQgZm91bmQgb24gc3RhY2suIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCIgKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBwdXNoKGNvbnRleHRTdGFja0N1cnNvciwgY29udGV4dCwgZmliZXIpO1xuICAgIHB1c2goZGlkUGVyZm9ybVdvcmtTdGFja0N1cnNvciwgZGlkQ2hhbmdlLCBmaWJlcik7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJvY2Vzc0NoaWxkQ29udGV4dChmaWJlciwgdHlwZSwgcGFyZW50Q29udGV4dCkge1xuICB7XG4gICAgdmFyIGluc3RhbmNlID0gZmliZXIuc3RhdGVOb2RlO1xuICAgIHZhciBjaGlsZENvbnRleHRUeXBlcyA9IHR5cGUuY2hpbGRDb250ZXh0VHlwZXM7IC8vIFRPRE8gKGJ2YXVnaG4pIFJlcGxhY2UgdGhpcyBiZWhhdmlvciB3aXRoIGFuIGludmFyaWFudCgpIGluIHRoZSBmdXR1cmUuXG4gICAgLy8gSXQgaGFzIG9ubHkgYmVlbiBhZGRlZCBpbiBGaWJlciB0byBtYXRjaCB0aGUgKHVuaW50ZW50aW9uYWwpIGJlaGF2aW9yIGluIFN0YWNrLlxuXG4gICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5nZXRDaGlsZENvbnRleHQgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHtcbiAgICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lKHR5cGUpIHx8ICdVbmtub3duJztcblxuICAgICAgICBpZiAoIXdhcm5lZEFib3V0TWlzc2luZ0dldENoaWxkQ29udGV4dFtjb21wb25lbnROYW1lXSkge1xuICAgICAgICAgIHdhcm5lZEFib3V0TWlzc2luZ0dldENoaWxkQ29udGV4dFtjb21wb25lbnROYW1lXSA9IHRydWU7XG5cbiAgICAgICAgICBlcnJvcignJXMuY2hpbGRDb250ZXh0VHlwZXMgaXMgc3BlY2lmaWVkIGJ1dCB0aGVyZSBpcyBubyBnZXRDaGlsZENvbnRleHQoKSBtZXRob2QgJyArICdvbiB0aGUgaW5zdGFuY2UuIFlvdSBjYW4gZWl0aGVyIGRlZmluZSBnZXRDaGlsZENvbnRleHQoKSBvbiAlcyBvciByZW1vdmUgJyArICdjaGlsZENvbnRleHRUeXBlcyBmcm9tIGl0LicsIGNvbXBvbmVudE5hbWUsIGNvbXBvbmVudE5hbWUpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwYXJlbnRDb250ZXh0O1xuICAgIH1cblxuICAgIHZhciBjaGlsZENvbnRleHQgPSBpbnN0YW5jZS5nZXRDaGlsZENvbnRleHQoKTtcblxuICAgIGZvciAodmFyIGNvbnRleHRLZXkgaW4gY2hpbGRDb250ZXh0KSB7XG4gICAgICBpZiAoIShjb250ZXh0S2V5IGluIGNoaWxkQ29udGV4dFR5cGVzKSkge1xuICAgICAgICB7XG4gICAgICAgICAgdGhyb3cgRXJyb3IoIChnZXRDb21wb25lbnROYW1lKHR5cGUpIHx8ICdVbmtub3duJykgKyBcIi5nZXRDaGlsZENvbnRleHQoKToga2V5IFxcXCJcIiArIGNvbnRleHRLZXkgKyBcIlxcXCIgaXMgbm90IGRlZmluZWQgaW4gY2hpbGRDb250ZXh0VHlwZXMuXCIgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHtcbiAgICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZSh0eXBlKSB8fCAnVW5rbm93bic7XG4gICAgICBjaGVja1Byb3BUeXBlcyhjaGlsZENvbnRleHRUeXBlcywgY2hpbGRDb250ZXh0LCAnY2hpbGQgY29udGV4dCcsIG5hbWUpO1xuICAgIH1cblxuICAgIHJldHVybiBfYXNzaWduKHt9LCBwYXJlbnRDb250ZXh0LCBjaGlsZENvbnRleHQpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHB1c2hDb250ZXh0UHJvdmlkZXIod29ya0luUHJvZ3Jlc3MpIHtcbiAge1xuICAgIHZhciBpbnN0YW5jZSA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTsgLy8gV2UgcHVzaCB0aGUgY29udGV4dCBhcyBlYXJseSBhcyBwb3NzaWJsZSB0byBlbnN1cmUgc3RhY2sgaW50ZWdyaXR5LlxuICAgIC8vIElmIHRoZSBpbnN0YW5jZSBkb2VzIG5vdCBleGlzdCB5ZXQsIHdlIHdpbGwgcHVzaCBudWxsIGF0IGZpcnN0LFxuICAgIC8vIGFuZCByZXBsYWNlIGl0IG9uIHRoZSBzdGFjayBsYXRlciB3aGVuIGludmFsaWRhdGluZyB0aGUgY29udGV4dC5cblxuICAgIHZhciBtZW1vaXplZE1lcmdlZENoaWxkQ29udGV4dCA9IGluc3RhbmNlICYmIGluc3RhbmNlLl9fcmVhY3RJbnRlcm5hbE1lbW9pemVkTWVyZ2VkQ2hpbGRDb250ZXh0IHx8IGVtcHR5Q29udGV4dE9iamVjdDsgLy8gUmVtZW1iZXIgdGhlIHBhcmVudCBjb250ZXh0IHNvIHdlIGNhbiBtZXJnZSB3aXRoIGl0IGxhdGVyLlxuICAgIC8vIEluaGVyaXQgdGhlIHBhcmVudCdzIGRpZC1wZXJmb3JtLXdvcmsgdmFsdWUgdG8gYXZvaWQgaW5hZHZlcnRlbnRseSBibG9ja2luZyB1cGRhdGVzLlxuXG4gICAgcHJldmlvdXNDb250ZXh0ID0gY29udGV4dFN0YWNrQ3Vyc29yLmN1cnJlbnQ7XG4gICAgcHVzaChjb250ZXh0U3RhY2tDdXJzb3IsIG1lbW9pemVkTWVyZ2VkQ2hpbGRDb250ZXh0LCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgcHVzaChkaWRQZXJmb3JtV29ya1N0YWNrQ3Vyc29yLCBkaWRQZXJmb3JtV29ya1N0YWNrQ3Vyc29yLmN1cnJlbnQsIHdvcmtJblByb2dyZXNzKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbnZhbGlkYXRlQ29udGV4dFByb3ZpZGVyKHdvcmtJblByb2dyZXNzLCB0eXBlLCBkaWRDaGFuZ2UpIHtcbiAge1xuICAgIHZhciBpbnN0YW5jZSA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcblxuICAgIGlmICghaW5zdGFuY2UpIHtcbiAgICAgIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoIFwiRXhwZWN0ZWQgdG8gaGF2ZSBhbiBpbnN0YW5jZSBieSB0aGlzIHBvaW50LiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGRpZENoYW5nZSkge1xuICAgICAgLy8gTWVyZ2UgcGFyZW50IGFuZCBvd24gY29udGV4dC5cbiAgICAgIC8vIFNraXAgdGhpcyBpZiB3ZSdyZSBub3QgdXBkYXRpbmcgZHVlIHRvIHNDVS5cbiAgICAgIC8vIFRoaXMgYXZvaWRzIHVubmVjZXNzYXJpbHkgcmVjb21wdXRpbmcgbWVtb2l6ZWQgdmFsdWVzLlxuICAgICAgdmFyIG1lcmdlZENvbnRleHQgPSBwcm9jZXNzQ2hpbGRDb250ZXh0KHdvcmtJblByb2dyZXNzLCB0eXBlLCBwcmV2aW91c0NvbnRleHQpO1xuICAgICAgaW5zdGFuY2UuX19yZWFjdEludGVybmFsTWVtb2l6ZWRNZXJnZWRDaGlsZENvbnRleHQgPSBtZXJnZWRDb250ZXh0OyAvLyBSZXBsYWNlIHRoZSBvbGQgKG9yIGVtcHR5KSBjb250ZXh0IHdpdGggdGhlIG5ldyBvbmUuXG4gICAgICAvLyBJdCBpcyBpbXBvcnRhbnQgdG8gdW53aW5kIHRoZSBjb250ZXh0IGluIHRoZSByZXZlcnNlIG9yZGVyLlxuXG4gICAgICBwb3AoZGlkUGVyZm9ybVdvcmtTdGFja0N1cnNvciwgd29ya0luUHJvZ3Jlc3MpO1xuICAgICAgcG9wKGNvbnRleHRTdGFja0N1cnNvciwgd29ya0luUHJvZ3Jlc3MpOyAvLyBOb3cgcHVzaCB0aGUgbmV3IGNvbnRleHQgYW5kIG1hcmsgdGhhdCBpdCBoYXMgY2hhbmdlZC5cblxuICAgICAgcHVzaChjb250ZXh0U3RhY2tDdXJzb3IsIG1lcmdlZENvbnRleHQsIHdvcmtJblByb2dyZXNzKTtcbiAgICAgIHB1c2goZGlkUGVyZm9ybVdvcmtTdGFja0N1cnNvciwgZGlkQ2hhbmdlLCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBvcChkaWRQZXJmb3JtV29ya1N0YWNrQ3Vyc29yLCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICBwdXNoKGRpZFBlcmZvcm1Xb3JrU3RhY2tDdXJzb3IsIGRpZENoYW5nZSwgd29ya0luUHJvZ3Jlc3MpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBmaW5kQ3VycmVudFVubWFza2VkQ29udGV4dChmaWJlcikge1xuICB7XG4gICAgLy8gQ3VycmVudGx5IHRoaXMgaXMgb25seSB1c2VkIHdpdGggcmVuZGVyU3VidHJlZUludG9Db250YWluZXI7IG5vdCBzdXJlIGlmIGl0XG4gICAgLy8gbWFrZXMgc2Vuc2UgZWxzZXdoZXJlXG4gICAgaWYgKCEoaXNGaWJlck1vdW50ZWQoZmliZXIpICYmIGZpYmVyLnRhZyA9PT0gQ2xhc3NDb21wb25lbnQpKSB7XG4gICAgICB7XG4gICAgICAgIHRocm93IEVycm9yKCBcIkV4cGVjdGVkIHN1YnRyZWUgcGFyZW50IHRvIGJlIGEgbW91bnRlZCBjbGFzcyBjb21wb25lbnQuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCIgKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgbm9kZSA9IGZpYmVyO1xuXG4gICAgZG8ge1xuICAgICAgc3dpdGNoIChub2RlLnRhZykge1xuICAgICAgICBjYXNlIEhvc3RSb290OlxuICAgICAgICAgIHJldHVybiBub2RlLnN0YXRlTm9kZS5jb250ZXh0O1xuXG4gICAgICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG4gICAgICAgICAge1xuICAgICAgICAgICAgdmFyIENvbXBvbmVudCA9IG5vZGUudHlwZTtcblxuICAgICAgICAgICAgaWYgKGlzQ29udGV4dFByb3ZpZGVyKENvbXBvbmVudCkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG5vZGUuc3RhdGVOb2RlLl9fcmVhY3RJbnRlcm5hbE1lbW9pemVkTWVyZ2VkQ2hpbGRDb250ZXh0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIG5vZGUgPSBub2RlLnJldHVybjtcbiAgICB9IHdoaWxlIChub2RlICE9PSBudWxsKTtcblxuICAgIHtcbiAgICAgIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoIFwiRm91bmQgdW5leHBlY3RlZCBkZXRhY2hlZCBzdWJ0cmVlIHBhcmVudC4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS5cIiApO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG52YXIgTGVnYWN5Um9vdCA9IDA7XG52YXIgQmxvY2tpbmdSb290ID0gMTtcbnZhciBDb25jdXJyZW50Um9vdCA9IDI7XG5cbnZhciByZW5kZXJlcklEID0gbnVsbDtcbnZhciBpbmplY3RlZEhvb2sgPSBudWxsO1xudmFyIGhhc0xvZ2dlZEVycm9yID0gZmFsc2U7XG52YXIgaXNEZXZUb29sc1ByZXNlbnQgPSB0eXBlb2YgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fICE9PSAndW5kZWZpbmVkJztcbmZ1bmN0aW9uIGluamVjdEludGVybmFscyhpbnRlcm5hbHMpIHtcbiAgaWYgKHR5cGVvZiBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgLy8gTm8gRGV2VG9vbHNcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgaG9vayA9IF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXztcblxuICBpZiAoaG9vay5pc0Rpc2FibGVkKSB7XG4gICAgLy8gVGhpcyBpc24ndCBhIHJlYWwgcHJvcGVydHkgb24gdGhlIGhvb2ssIGJ1dCBpdCBjYW4gYmUgc2V0IHRvIG9wdCBvdXRcbiAgICAvLyBvZiBEZXZUb29scyBpbnRlZ3JhdGlvbiBhbmQgYXNzb2NpYXRlZCB3YXJuaW5ncyBhbmQgbG9ncy5cbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzM4NzdcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmICghaG9vay5zdXBwb3J0c0ZpYmVyKSB7XG4gICAge1xuICAgICAgZXJyb3IoJ1RoZSBpbnN0YWxsZWQgdmVyc2lvbiBvZiBSZWFjdCBEZXZUb29scyBpcyB0b28gb2xkIGFuZCB3aWxsIG5vdCB3b3JrICcgKyAnd2l0aCB0aGUgY3VycmVudCB2ZXJzaW9uIG9mIFJlYWN0LiBQbGVhc2UgdXBkYXRlIFJlYWN0IERldlRvb2xzLiAnICsgJ2h0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9yZWFjdC1kZXZ0b29scycpO1xuICAgIH0gLy8gRGV2VG9vbHMgZXhpc3RzLCBldmVuIHRob3VnaCBpdCBkb2Vzbid0IHN1cHBvcnQgRmliZXIuXG5cblxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgdHJ5IHtcbiAgICByZW5kZXJlcklEID0gaG9vay5pbmplY3QoaW50ZXJuYWxzKTsgLy8gV2UgaGF2ZSBzdWNjZXNzZnVsbHkgaW5qZWN0ZWQsIHNvIG5vdyBpdCBpcyBzYWZlIHRvIHNldCB1cCBob29rcy5cblxuICAgIGluamVjdGVkSG9vayA9IGhvb2s7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIC8vIENhdGNoIGFsbCBlcnJvcnMgYmVjYXVzZSBpdCBpcyB1bnNhZmUgdG8gdGhyb3cgZHVyaW5nIGluaXRpYWxpemF0aW9uLlxuICAgIHtcbiAgICAgIGVycm9yKCdSZWFjdCBpbnN0cnVtZW50YXRpb24gZW5jb3VudGVyZWQgYW4gZXJyb3I6ICVzLicsIGVycik7XG4gICAgfVxuICB9IC8vIERldlRvb2xzIGV4aXN0c1xuXG5cbiAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBvblNjaGVkdWxlUm9vdChyb290LCBjaGlsZHJlbikge1xuICB7XG4gICAgaWYgKGluamVjdGVkSG9vayAmJiB0eXBlb2YgaW5qZWN0ZWRIb29rLm9uU2NoZWR1bGVGaWJlclJvb3QgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGluamVjdGVkSG9vay5vblNjaGVkdWxlRmliZXJSb290KHJlbmRlcmVySUQsIHJvb3QsIGNoaWxkcmVuKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBpZiAoICFoYXNMb2dnZWRFcnJvcikge1xuICAgICAgICAgIGhhc0xvZ2dlZEVycm9yID0gdHJ1ZTtcblxuICAgICAgICAgIGVycm9yKCdSZWFjdCBpbnN0cnVtZW50YXRpb24gZW5jb3VudGVyZWQgYW4gZXJyb3I6ICVzJywgZXJyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gb25Db21taXRSb290KHJvb3QsIHByaW9yaXR5TGV2ZWwpIHtcbiAgaWYgKGluamVjdGVkSG9vayAmJiB0eXBlb2YgaW5qZWN0ZWRIb29rLm9uQ29tbWl0RmliZXJSb290ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdHJ5IHtcbiAgICAgIHZhciBkaWRFcnJvciA9IChyb290LmN1cnJlbnQuZmxhZ3MgJiBEaWRDYXB0dXJlKSA9PT0gRGlkQ2FwdHVyZTtcblxuICAgICAgaWYgKGVuYWJsZVByb2ZpbGVyVGltZXIpIHtcbiAgICAgICAgaW5qZWN0ZWRIb29rLm9uQ29tbWl0RmliZXJSb290KHJlbmRlcmVySUQsIHJvb3QsIHByaW9yaXR5TGV2ZWwsIGRpZEVycm9yKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGluamVjdGVkSG9vay5vbkNvbW1pdEZpYmVyUm9vdChyZW5kZXJlcklELCByb290LCB1bmRlZmluZWQsIGRpZEVycm9yKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHtcbiAgICAgICAgaWYgKCFoYXNMb2dnZWRFcnJvcikge1xuICAgICAgICAgIGhhc0xvZ2dlZEVycm9yID0gdHJ1ZTtcblxuICAgICAgICAgIGVycm9yKCdSZWFjdCBpbnN0cnVtZW50YXRpb24gZW5jb3VudGVyZWQgYW4gZXJyb3I6ICVzJywgZXJyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gb25Db21taXRVbm1vdW50KGZpYmVyKSB7XG4gIGlmIChpbmplY3RlZEhvb2sgJiYgdHlwZW9mIGluamVjdGVkSG9vay5vbkNvbW1pdEZpYmVyVW5tb3VudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHRyeSB7XG4gICAgICBpbmplY3RlZEhvb2sub25Db21taXRGaWJlclVubW91bnQocmVuZGVyZXJJRCwgZmliZXIpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAge1xuICAgICAgICBpZiAoIWhhc0xvZ2dlZEVycm9yKSB7XG4gICAgICAgICAgaGFzTG9nZ2VkRXJyb3IgPSB0cnVlO1xuXG4gICAgICAgICAgZXJyb3IoJ1JlYWN0IGluc3RydW1lbnRhdGlvbiBlbmNvdW50ZXJlZCBhbiBlcnJvcjogJXMnLCBlcnIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbnZhciBTY2hlZHVsZXJfcnVuV2l0aFByaW9yaXR5ID0gU2NoZWR1bGVyLnVuc3RhYmxlX3J1bldpdGhQcmlvcml0eSxcbiAgICBTY2hlZHVsZXJfc2NoZWR1bGVDYWxsYmFjayA9IFNjaGVkdWxlci51bnN0YWJsZV9zY2hlZHVsZUNhbGxiYWNrLFxuICAgIFNjaGVkdWxlcl9jYW5jZWxDYWxsYmFjayA9IFNjaGVkdWxlci51bnN0YWJsZV9jYW5jZWxDYWxsYmFjayxcbiAgICBTY2hlZHVsZXJfc2hvdWxkWWllbGQgPSBTY2hlZHVsZXIudW5zdGFibGVfc2hvdWxkWWllbGQsXG4gICAgU2NoZWR1bGVyX3JlcXVlc3RQYWludCA9IFNjaGVkdWxlci51bnN0YWJsZV9yZXF1ZXN0UGFpbnQsXG4gICAgU2NoZWR1bGVyX25vdyQxID0gU2NoZWR1bGVyLnVuc3RhYmxlX25vdyxcbiAgICBTY2hlZHVsZXJfZ2V0Q3VycmVudFByaW9yaXR5TGV2ZWwgPSBTY2hlZHVsZXIudW5zdGFibGVfZ2V0Q3VycmVudFByaW9yaXR5TGV2ZWwsXG4gICAgU2NoZWR1bGVyX0ltbWVkaWF0ZVByaW9yaXR5ID0gU2NoZWR1bGVyLnVuc3RhYmxlX0ltbWVkaWF0ZVByaW9yaXR5LFxuICAgIFNjaGVkdWxlcl9Vc2VyQmxvY2tpbmdQcmlvcml0eSA9IFNjaGVkdWxlci51bnN0YWJsZV9Vc2VyQmxvY2tpbmdQcmlvcml0eSxcbiAgICBTY2hlZHVsZXJfTm9ybWFsUHJpb3JpdHkgPSBTY2hlZHVsZXIudW5zdGFibGVfTm9ybWFsUHJpb3JpdHksXG4gICAgU2NoZWR1bGVyX0xvd1ByaW9yaXR5ID0gU2NoZWR1bGVyLnVuc3RhYmxlX0xvd1ByaW9yaXR5LFxuICAgIFNjaGVkdWxlcl9JZGxlUHJpb3JpdHkgPSBTY2hlZHVsZXIudW5zdGFibGVfSWRsZVByaW9yaXR5O1xuXG57XG4gIC8vIFByb3ZpZGUgZXhwbGljaXQgZXJyb3IgbWVzc2FnZSB3aGVuIHByb2R1Y3Rpb24rcHJvZmlsaW5nIGJ1bmRsZSBvZiBlLmcuXG4gIC8vIHJlYWN0LWRvbSBpcyB1c2VkIHdpdGggcHJvZHVjdGlvbiAobm9uLXByb2ZpbGluZykgYnVuZGxlIG9mXG4gIC8vIHNjaGVkdWxlci90cmFjaW5nXG4gIGlmICghKHRyYWNpbmcuX19pbnRlcmFjdGlvbnNSZWYgIT0gbnVsbCAmJiB0cmFjaW5nLl9faW50ZXJhY3Rpb25zUmVmLmN1cnJlbnQgIT0gbnVsbCkpIHtcbiAgICB7XG4gICAgICB0aHJvdyBFcnJvciggXCJJdCBpcyBub3Qgc3VwcG9ydGVkIHRvIHJ1biB0aGUgcHJvZmlsaW5nIHZlcnNpb24gb2YgYSByZW5kZXJlciAoZm9yIGV4YW1wbGUsIGByZWFjdC1kb20vcHJvZmlsaW5nYCkgd2l0aG91dCBhbHNvIHJlcGxhY2luZyB0aGUgYHNjaGVkdWxlci90cmFjaW5nYCBtb2R1bGUgd2l0aCBgc2NoZWR1bGVyL3RyYWNpbmctcHJvZmlsaW5nYC4gWW91ciBidW5kbGVyIG1pZ2h0IGhhdmUgYSBzZXR0aW5nIGZvciBhbGlhc2luZyBib3RoIG1vZHVsZXMuIExlYXJuIG1vcmUgYXQgaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3Byb2ZpbGluZ1wiICk7XG4gICAgfVxuICB9XG59XG5cbnZhciBmYWtlQ2FsbGJhY2tOb2RlID0ge307IC8vIEV4Y2VwdCBmb3IgTm9Qcmlvcml0eSwgdGhlc2UgY29ycmVzcG9uZCB0byBTY2hlZHVsZXIgcHJpb3JpdGllcy4gV2UgdXNlXG4vLyBhc2NlbmRpbmcgbnVtYmVycyBzbyB3ZSBjYW4gY29tcGFyZSB0aGVtIGxpa2UgbnVtYmVycy4gVGhleSBzdGFydCBhdCA5MCB0b1xuLy8gYXZvaWQgY2xhc2hpbmcgd2l0aCBTY2hlZHVsZXIncyBwcmlvcml0aWVzLlxuXG52YXIgSW1tZWRpYXRlUHJpb3JpdHkkMSA9IDk5O1xudmFyIFVzZXJCbG9ja2luZ1ByaW9yaXR5JDIgPSA5ODtcbnZhciBOb3JtYWxQcmlvcml0eSQxID0gOTc7XG52YXIgTG93UHJpb3JpdHkkMSA9IDk2O1xudmFyIElkbGVQcmlvcml0eSQxID0gOTU7IC8vIE5vUHJpb3JpdHkgaXMgdGhlIGFic2VuY2Ugb2YgcHJpb3JpdHkuIEFsc28gUmVhY3Qtb25seS5cblxudmFyIE5vUHJpb3JpdHkkMSA9IDkwO1xudmFyIHNob3VsZFlpZWxkID0gU2NoZWR1bGVyX3Nob3VsZFlpZWxkO1xudmFyIHJlcXVlc3RQYWludCA9IC8vIEZhbGwgYmFjayBncmFjZWZ1bGx5IGlmIHdlJ3JlIHJ1bm5pbmcgYW4gb2xkZXIgdmVyc2lvbiBvZiBTY2hlZHVsZXIuXG5TY2hlZHVsZXJfcmVxdWVzdFBhaW50ICE9PSB1bmRlZmluZWQgPyBTY2hlZHVsZXJfcmVxdWVzdFBhaW50IDogZnVuY3Rpb24gKCkge307XG52YXIgc3luY1F1ZXVlID0gbnVsbDtcbnZhciBpbW1lZGlhdGVRdWV1ZUNhbGxiYWNrTm9kZSA9IG51bGw7XG52YXIgaXNGbHVzaGluZ1N5bmNRdWV1ZSA9IGZhbHNlO1xudmFyIGluaXRpYWxUaW1lTXMkMSA9IFNjaGVkdWxlcl9ub3ckMSgpOyAvLyBJZiB0aGUgaW5pdGlhbCB0aW1lc3RhbXAgaXMgcmVhc29uYWJseSBzbWFsbCwgdXNlIFNjaGVkdWxlcidzIGBub3dgIGRpcmVjdGx5LlxuLy8gVGhpcyB3aWxsIGJlIHRoZSBjYXNlIGZvciBtb2Rlcm4gYnJvd3NlcnMgdGhhdCBzdXBwb3J0IGBwZXJmb3JtYW5jZS5ub3dgLiBJblxuLy8gb2xkZXIgYnJvd3NlcnMsIFNjaGVkdWxlciBmYWxscyBiYWNrIHRvIGBEYXRlLm5vd2AsIHdoaWNoIHJldHVybnMgYSBVbml4XG4vLyB0aW1lc3RhbXAuIEluIHRoYXQgY2FzZSwgc3VidHJhY3QgdGhlIG1vZHVsZSBpbml0aWFsaXphdGlvbiB0aW1lIHRvIHNpbXVsYXRlXG4vLyB0aGUgYmVoYXZpb3Igb2YgcGVyZm9ybWFuY2Uubm93IGFuZCBrZWVwIG91ciB0aW1lcyBzbWFsbCBlbm91Z2ggdG8gZml0XG4vLyB3aXRoaW4gMzIgYml0cy5cbi8vIFRPRE86IENvbnNpZGVyIGxpZnRpbmcgdGhpcyBpbnRvIFNjaGVkdWxlci5cblxudmFyIG5vdyA9IGluaXRpYWxUaW1lTXMkMSA8IDEwMDAwID8gU2NoZWR1bGVyX25vdyQxIDogZnVuY3Rpb24gKCkge1xuICByZXR1cm4gU2NoZWR1bGVyX25vdyQxKCkgLSBpbml0aWFsVGltZU1zJDE7XG59O1xuZnVuY3Rpb24gZ2V0Q3VycmVudFByaW9yaXR5TGV2ZWwoKSB7XG4gIHN3aXRjaCAoU2NoZWR1bGVyX2dldEN1cnJlbnRQcmlvcml0eUxldmVsKCkpIHtcbiAgICBjYXNlIFNjaGVkdWxlcl9JbW1lZGlhdGVQcmlvcml0eTpcbiAgICAgIHJldHVybiBJbW1lZGlhdGVQcmlvcml0eSQxO1xuXG4gICAgY2FzZSBTY2hlZHVsZXJfVXNlckJsb2NraW5nUHJpb3JpdHk6XG4gICAgICByZXR1cm4gVXNlckJsb2NraW5nUHJpb3JpdHkkMjtcblxuICAgIGNhc2UgU2NoZWR1bGVyX05vcm1hbFByaW9yaXR5OlxuICAgICAgcmV0dXJuIE5vcm1hbFByaW9yaXR5JDE7XG5cbiAgICBjYXNlIFNjaGVkdWxlcl9Mb3dQcmlvcml0eTpcbiAgICAgIHJldHVybiBMb3dQcmlvcml0eSQxO1xuXG4gICAgY2FzZSBTY2hlZHVsZXJfSWRsZVByaW9yaXR5OlxuICAgICAgcmV0dXJuIElkbGVQcmlvcml0eSQxO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHtcbiAgICAgICAge1xuICAgICAgICAgIHRocm93IEVycm9yKCBcIlVua25vd24gcHJpb3JpdHkgbGV2ZWwuXCIgKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gIH1cbn1cblxuZnVuY3Rpb24gcmVhY3RQcmlvcml0eVRvU2NoZWR1bGVyUHJpb3JpdHkocmVhY3RQcmlvcml0eUxldmVsKSB7XG4gIHN3aXRjaCAocmVhY3RQcmlvcml0eUxldmVsKSB7XG4gICAgY2FzZSBJbW1lZGlhdGVQcmlvcml0eSQxOlxuICAgICAgcmV0dXJuIFNjaGVkdWxlcl9JbW1lZGlhdGVQcmlvcml0eTtcblxuICAgIGNhc2UgVXNlckJsb2NraW5nUHJpb3JpdHkkMjpcbiAgICAgIHJldHVybiBTY2hlZHVsZXJfVXNlckJsb2NraW5nUHJpb3JpdHk7XG5cbiAgICBjYXNlIE5vcm1hbFByaW9yaXR5JDE6XG4gICAgICByZXR1cm4gU2NoZWR1bGVyX05vcm1hbFByaW9yaXR5O1xuXG4gICAgY2FzZSBMb3dQcmlvcml0eSQxOlxuICAgICAgcmV0dXJuIFNjaGVkdWxlcl9Mb3dQcmlvcml0eTtcblxuICAgIGNhc2UgSWRsZVByaW9yaXR5JDE6XG4gICAgICByZXR1cm4gU2NoZWR1bGVyX0lkbGVQcmlvcml0eTtcblxuICAgIGRlZmF1bHQ6XG4gICAgICB7XG4gICAgICAgIHtcbiAgICAgICAgICB0aHJvdyBFcnJvciggXCJVbmtub3duIHByaW9yaXR5IGxldmVsLlwiICk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICB9XG59XG5cbmZ1bmN0aW9uIHJ1bldpdGhQcmlvcml0eSQxKHJlYWN0UHJpb3JpdHlMZXZlbCwgZm4pIHtcbiAgdmFyIHByaW9yaXR5TGV2ZWwgPSByZWFjdFByaW9yaXR5VG9TY2hlZHVsZXJQcmlvcml0eShyZWFjdFByaW9yaXR5TGV2ZWwpO1xuICByZXR1cm4gU2NoZWR1bGVyX3J1bldpdGhQcmlvcml0eShwcmlvcml0eUxldmVsLCBmbik7XG59XG5mdW5jdGlvbiBzY2hlZHVsZUNhbGxiYWNrKHJlYWN0UHJpb3JpdHlMZXZlbCwgY2FsbGJhY2ssIG9wdGlvbnMpIHtcbiAgdmFyIHByaW9yaXR5TGV2ZWwgPSByZWFjdFByaW9yaXR5VG9TY2hlZHVsZXJQcmlvcml0eShyZWFjdFByaW9yaXR5TGV2ZWwpO1xuICByZXR1cm4gU2NoZWR1bGVyX3NjaGVkdWxlQ2FsbGJhY2socHJpb3JpdHlMZXZlbCwgY2FsbGJhY2ssIG9wdGlvbnMpO1xufVxuZnVuY3Rpb24gc2NoZWR1bGVTeW5jQ2FsbGJhY2soY2FsbGJhY2spIHtcbiAgLy8gUHVzaCB0aGlzIGNhbGxiYWNrIGludG8gYW4gaW50ZXJuYWwgcXVldWUuIFdlJ2xsIGZsdXNoIHRoZXNlIGVpdGhlciBpblxuICAvLyB0aGUgbmV4dCB0aWNrLCBvciBlYXJsaWVyIGlmIHNvbWV0aGluZyBjYWxscyBgZmx1c2hTeW5jQ2FsbGJhY2tRdWV1ZWAuXG4gIGlmIChzeW5jUXVldWUgPT09IG51bGwpIHtcbiAgICBzeW5jUXVldWUgPSBbY2FsbGJhY2tdOyAvLyBGbHVzaCB0aGUgcXVldWUgaW4gdGhlIG5leHQgdGljaywgYXQgdGhlIGVhcmxpZXN0LlxuXG4gICAgaW1tZWRpYXRlUXVldWVDYWxsYmFja05vZGUgPSBTY2hlZHVsZXJfc2NoZWR1bGVDYWxsYmFjayhTY2hlZHVsZXJfSW1tZWRpYXRlUHJpb3JpdHksIGZsdXNoU3luY0NhbGxiYWNrUXVldWVJbXBsKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBQdXNoIG9udG8gZXhpc3RpbmcgcXVldWUuIERvbid0IG5lZWQgdG8gc2NoZWR1bGUgYSBjYWxsYmFjayBiZWNhdXNlXG4gICAgLy8gd2UgYWxyZWFkeSBzY2hlZHVsZWQgb25lIHdoZW4gd2UgY3JlYXRlZCB0aGUgcXVldWUuXG4gICAgc3luY1F1ZXVlLnB1c2goY2FsbGJhY2spO1xuICB9XG5cbiAgcmV0dXJuIGZha2VDYWxsYmFja05vZGU7XG59XG5mdW5jdGlvbiBjYW5jZWxDYWxsYmFjayhjYWxsYmFja05vZGUpIHtcbiAgaWYgKGNhbGxiYWNrTm9kZSAhPT0gZmFrZUNhbGxiYWNrTm9kZSkge1xuICAgIFNjaGVkdWxlcl9jYW5jZWxDYWxsYmFjayhjYWxsYmFja05vZGUpO1xuICB9XG59XG5mdW5jdGlvbiBmbHVzaFN5bmNDYWxsYmFja1F1ZXVlKCkge1xuICBpZiAoaW1tZWRpYXRlUXVldWVDYWxsYmFja05vZGUgIT09IG51bGwpIHtcbiAgICB2YXIgbm9kZSA9IGltbWVkaWF0ZVF1ZXVlQ2FsbGJhY2tOb2RlO1xuICAgIGltbWVkaWF0ZVF1ZXVlQ2FsbGJhY2tOb2RlID0gbnVsbDtcbiAgICBTY2hlZHVsZXJfY2FuY2VsQ2FsbGJhY2sobm9kZSk7XG4gIH1cblxuICBmbHVzaFN5bmNDYWxsYmFja1F1ZXVlSW1wbCgpO1xufVxuXG5mdW5jdGlvbiBmbHVzaFN5bmNDYWxsYmFja1F1ZXVlSW1wbCgpIHtcbiAgaWYgKCFpc0ZsdXNoaW5nU3luY1F1ZXVlICYmIHN5bmNRdWV1ZSAhPT0gbnVsbCkge1xuICAgIC8vIFByZXZlbnQgcmUtZW50cmFuY3kuXG4gICAgaXNGbHVzaGluZ1N5bmNRdWV1ZSA9IHRydWU7XG4gICAgdmFyIGkgPSAwO1xuXG4gICAge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIF9pc1N5bmMyID0gdHJ1ZTtcbiAgICAgICAgdmFyIF9xdWV1ZSA9IHN5bmNRdWV1ZTtcbiAgICAgICAgcnVuV2l0aFByaW9yaXR5JDEoSW1tZWRpYXRlUHJpb3JpdHkkMSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGZvciAoOyBpIDwgX3F1ZXVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgY2FsbGJhY2sgPSBfcXVldWVbaV07XG5cbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgY2FsbGJhY2sgPSBjYWxsYmFjayhfaXNTeW5jMik7XG4gICAgICAgICAgICB9IHdoaWxlIChjYWxsYmFjayAhPT0gbnVsbCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgc3luY1F1ZXVlID0gbnVsbDtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIC8vIElmIHNvbWV0aGluZyB0aHJvd3MsIGxlYXZlIHRoZSByZW1haW5pbmcgY2FsbGJhY2tzIG9uIHRoZSBxdWV1ZS5cbiAgICAgICAgaWYgKHN5bmNRdWV1ZSAhPT0gbnVsbCkge1xuICAgICAgICAgIHN5bmNRdWV1ZSA9IHN5bmNRdWV1ZS5zbGljZShpICsgMSk7XG4gICAgICAgIH0gLy8gUmVzdW1lIGZsdXNoaW5nIGluIHRoZSBuZXh0IHRpY2tcblxuXG4gICAgICAgIFNjaGVkdWxlcl9zY2hlZHVsZUNhbGxiYWNrKFNjaGVkdWxlcl9JbW1lZGlhdGVQcmlvcml0eSwgZmx1c2hTeW5jQ2FsbGJhY2tRdWV1ZSk7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgaXNGbHVzaGluZ1N5bmNRdWV1ZSA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vLyBUT0RPOiB0aGlzIGlzIHNwZWNpYWwgYmVjYXVzZSBpdCBnZXRzIGltcG9ydGVkIGR1cmluZyBidWlsZC5cbnZhciBSZWFjdFZlcnNpb24gPSAnMTcuMC4yJztcblxudmFyIE5vTW9kZSA9IDA7XG52YXIgU3RyaWN0TW9kZSA9IDE7IC8vIFRPRE86IFJlbW92ZSBCbG9ja2luZ01vZGUgYW5kIENvbmN1cnJlbnRNb2RlIGJ5IHJlYWRpbmcgZnJvbSB0aGUgcm9vdFxuLy8gdGFnIGluc3RlYWRcblxudmFyIEJsb2NraW5nTW9kZSA9IDI7XG52YXIgQ29uY3VycmVudE1vZGUgPSA0O1xudmFyIFByb2ZpbGVNb2RlID0gODtcbnZhciBEZWJ1Z1RyYWNpbmdNb2RlID0gMTY7XG5cbnZhciBSZWFjdEN1cnJlbnRCYXRjaENvbmZpZyA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0Q3VycmVudEJhdGNoQ29uZmlnO1xudmFyIE5vVHJhbnNpdGlvbiA9IDA7XG5mdW5jdGlvbiByZXF1ZXN0Q3VycmVudFRyYW5zaXRpb24oKSB7XG4gIHJldHVybiBSZWFjdEN1cnJlbnRCYXRjaENvbmZpZy50cmFuc2l0aW9uO1xufVxuXG52YXIgUmVhY3RTdHJpY3RNb2RlV2FybmluZ3MgPSB7XG4gIHJlY29yZFVuc2FmZUxpZmVjeWNsZVdhcm5pbmdzOiBmdW5jdGlvbiAoZmliZXIsIGluc3RhbmNlKSB7fSxcbiAgZmx1c2hQZW5kaW5nVW5zYWZlTGlmZWN5Y2xlV2FybmluZ3M6IGZ1bmN0aW9uICgpIHt9LFxuICByZWNvcmRMZWdhY3lDb250ZXh0V2FybmluZzogZnVuY3Rpb24gKGZpYmVyLCBpbnN0YW5jZSkge30sXG4gIGZsdXNoTGVnYWN5Q29udGV4dFdhcm5pbmc6IGZ1bmN0aW9uICgpIHt9LFxuICBkaXNjYXJkUGVuZGluZ1dhcm5pbmdzOiBmdW5jdGlvbiAoKSB7fVxufTtcblxue1xuICB2YXIgZmluZFN0cmljdFJvb3QgPSBmdW5jdGlvbiAoZmliZXIpIHtcbiAgICB2YXIgbWF5YmVTdHJpY3RSb290ID0gbnVsbDtcbiAgICB2YXIgbm9kZSA9IGZpYmVyO1xuXG4gICAgd2hpbGUgKG5vZGUgIT09IG51bGwpIHtcbiAgICAgIGlmIChub2RlLm1vZGUgJiBTdHJpY3RNb2RlKSB7XG4gICAgICAgIG1heWJlU3RyaWN0Um9vdCA9IG5vZGU7XG4gICAgICB9XG5cbiAgICAgIG5vZGUgPSBub2RlLnJldHVybjtcbiAgICB9XG5cbiAgICByZXR1cm4gbWF5YmVTdHJpY3RSb290O1xuICB9O1xuXG4gIHZhciBzZXRUb1NvcnRlZFN0cmluZyA9IGZ1bmN0aW9uIChzZXQpIHtcbiAgICB2YXIgYXJyYXkgPSBbXTtcbiAgICBzZXQuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIGFycmF5LnB1c2godmFsdWUpO1xuICAgIH0pO1xuICAgIHJldHVybiBhcnJheS5zb3J0KCkuam9pbignLCAnKTtcbiAgfTtcblxuICB2YXIgcGVuZGluZ0NvbXBvbmVudFdpbGxNb3VudFdhcm5pbmdzID0gW107XG4gIHZhciBwZW5kaW5nVU5TQUZFX0NvbXBvbmVudFdpbGxNb3VudFdhcm5pbmdzID0gW107XG4gIHZhciBwZW5kaW5nQ29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1dhcm5pbmdzID0gW107XG4gIHZhciBwZW5kaW5nVU5TQUZFX0NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNXYXJuaW5ncyA9IFtdO1xuICB2YXIgcGVuZGluZ0NvbXBvbmVudFdpbGxVcGRhdGVXYXJuaW5ncyA9IFtdO1xuICB2YXIgcGVuZGluZ1VOU0FGRV9Db21wb25lbnRXaWxsVXBkYXRlV2FybmluZ3MgPSBbXTsgLy8gVHJhY2tzIGNvbXBvbmVudHMgd2UgaGF2ZSBhbHJlYWR5IHdhcm5lZCBhYm91dC5cblxuICB2YXIgZGlkV2FybkFib3V0VW5zYWZlTGlmZWN5Y2xlcyA9IG5ldyBTZXQoKTtcblxuICBSZWFjdFN0cmljdE1vZGVXYXJuaW5ncy5yZWNvcmRVbnNhZmVMaWZlY3ljbGVXYXJuaW5ncyA9IGZ1bmN0aW9uIChmaWJlciwgaW5zdGFuY2UpIHtcbiAgICAvLyBEZWR1cCBzdHJhdGVneTogV2FybiBvbmNlIHBlciBjb21wb25lbnQuXG4gICAgaWYgKGRpZFdhcm5BYm91dFVuc2FmZUxpZmVjeWNsZXMuaGFzKGZpYmVyLnR5cGUpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsTW91bnQgPT09ICdmdW5jdGlvbicgJiYgLy8gRG9uJ3Qgd2FybiBhYm91dCByZWFjdC1saWZlY3ljbGVzLWNvbXBhdCBwb2x5ZmlsbGVkIGNvbXBvbmVudHMuXG4gICAgaW5zdGFuY2UuY29tcG9uZW50V2lsbE1vdW50Ll9fc3VwcHJlc3NEZXByZWNhdGlvbldhcm5pbmcgIT09IHRydWUpIHtcbiAgICAgIHBlbmRpbmdDb21wb25lbnRXaWxsTW91bnRXYXJuaW5ncy5wdXNoKGZpYmVyKTtcbiAgICB9XG5cbiAgICBpZiAoZmliZXIubW9kZSAmIFN0cmljdE1vZGUgJiYgdHlwZW9mIGluc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsTW91bnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHBlbmRpbmdVTlNBRkVfQ29tcG9uZW50V2lsbE1vdW50V2FybmluZ3MucHVzaChmaWJlcik7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzID09PSAnZnVuY3Rpb24nICYmIGluc3RhbmNlLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMuX19zdXBwcmVzc0RlcHJlY2F0aW9uV2FybmluZyAhPT0gdHJ1ZSkge1xuICAgICAgcGVuZGluZ0NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNXYXJuaW5ncy5wdXNoKGZpYmVyKTtcbiAgICB9XG5cbiAgICBpZiAoZmliZXIubW9kZSAmIFN0cmljdE1vZGUgJiYgdHlwZW9mIGluc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBwZW5kaW5nVU5TQUZFX0NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNXYXJuaW5ncy5wdXNoKGZpYmVyKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxVcGRhdGUgPT09ICdmdW5jdGlvbicgJiYgaW5zdGFuY2UuY29tcG9uZW50V2lsbFVwZGF0ZS5fX3N1cHByZXNzRGVwcmVjYXRpb25XYXJuaW5nICE9PSB0cnVlKSB7XG4gICAgICBwZW5kaW5nQ29tcG9uZW50V2lsbFVwZGF0ZVdhcm5pbmdzLnB1c2goZmliZXIpO1xuICAgIH1cblxuICAgIGlmIChmaWJlci5tb2RlICYgU3RyaWN0TW9kZSAmJiB0eXBlb2YgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxVcGRhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHBlbmRpbmdVTlNBRkVfQ29tcG9uZW50V2lsbFVwZGF0ZVdhcm5pbmdzLnB1c2goZmliZXIpO1xuICAgIH1cbiAgfTtcblxuICBSZWFjdFN0cmljdE1vZGVXYXJuaW5ncy5mbHVzaFBlbmRpbmdVbnNhZmVMaWZlY3ljbGVXYXJuaW5ncyA9IGZ1bmN0aW9uICgpIHtcbiAgICAvLyBXZSBkbyBhbiBpbml0aWFsIHBhc3MgdG8gZ2F0aGVyIGNvbXBvbmVudCBuYW1lc1xuICAgIHZhciBjb21wb25lbnRXaWxsTW91bnRVbmlxdWVOYW1lcyA9IG5ldyBTZXQoKTtcblxuICAgIGlmIChwZW5kaW5nQ29tcG9uZW50V2lsbE1vdW50V2FybmluZ3MubGVuZ3RoID4gMCkge1xuICAgICAgcGVuZGluZ0NvbXBvbmVudFdpbGxNb3VudFdhcm5pbmdzLmZvckVhY2goZnVuY3Rpb24gKGZpYmVyKSB7XG4gICAgICAgIGNvbXBvbmVudFdpbGxNb3VudFVuaXF1ZU5hbWVzLmFkZChnZXRDb21wb25lbnROYW1lKGZpYmVyLnR5cGUpIHx8ICdDb21wb25lbnQnKTtcbiAgICAgICAgZGlkV2FybkFib3V0VW5zYWZlTGlmZWN5Y2xlcy5hZGQoZmliZXIudHlwZSk7XG4gICAgICB9KTtcbiAgICAgIHBlbmRpbmdDb21wb25lbnRXaWxsTW91bnRXYXJuaW5ncyA9IFtdO1xuICAgIH1cblxuICAgIHZhciBVTlNBRkVfY29tcG9uZW50V2lsbE1vdW50VW5pcXVlTmFtZXMgPSBuZXcgU2V0KCk7XG5cbiAgICBpZiAocGVuZGluZ1VOU0FGRV9Db21wb25lbnRXaWxsTW91bnRXYXJuaW5ncy5sZW5ndGggPiAwKSB7XG4gICAgICBwZW5kaW5nVU5TQUZFX0NvbXBvbmVudFdpbGxNb3VudFdhcm5pbmdzLmZvckVhY2goZnVuY3Rpb24gKGZpYmVyKSB7XG4gICAgICAgIFVOU0FGRV9jb21wb25lbnRXaWxsTW91bnRVbmlxdWVOYW1lcy5hZGQoZ2V0Q29tcG9uZW50TmFtZShmaWJlci50eXBlKSB8fCAnQ29tcG9uZW50Jyk7XG4gICAgICAgIGRpZFdhcm5BYm91dFVuc2FmZUxpZmVjeWNsZXMuYWRkKGZpYmVyLnR5cGUpO1xuICAgICAgfSk7XG4gICAgICBwZW5kaW5nVU5TQUZFX0NvbXBvbmVudFdpbGxNb3VudFdhcm5pbmdzID0gW107XG4gICAgfVxuXG4gICAgdmFyIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNVbmlxdWVOYW1lcyA9IG5ldyBTZXQoKTtcblxuICAgIGlmIChwZW5kaW5nQ29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1dhcm5pbmdzLmxlbmd0aCA+IDApIHtcbiAgICAgIHBlbmRpbmdDb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzV2FybmluZ3MuZm9yRWFjaChmdW5jdGlvbiAoZmliZXIpIHtcbiAgICAgICAgY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1VuaXF1ZU5hbWVzLmFkZChnZXRDb21wb25lbnROYW1lKGZpYmVyLnR5cGUpIHx8ICdDb21wb25lbnQnKTtcbiAgICAgICAgZGlkV2FybkFib3V0VW5zYWZlTGlmZWN5Y2xlcy5hZGQoZmliZXIudHlwZSk7XG4gICAgICB9KTtcbiAgICAgIHBlbmRpbmdDb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzV2FybmluZ3MgPSBbXTtcbiAgICB9XG5cbiAgICB2YXIgVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNVbmlxdWVOYW1lcyA9IG5ldyBTZXQoKTtcblxuICAgIGlmIChwZW5kaW5nVU5TQUZFX0NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNXYXJuaW5ncy5sZW5ndGggPiAwKSB7XG4gICAgICBwZW5kaW5nVU5TQUZFX0NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNXYXJuaW5ncy5mb3JFYWNoKGZ1bmN0aW9uIChmaWJlcikge1xuICAgICAgICBVTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1VuaXF1ZU5hbWVzLmFkZChnZXRDb21wb25lbnROYW1lKGZpYmVyLnR5cGUpIHx8ICdDb21wb25lbnQnKTtcbiAgICAgICAgZGlkV2FybkFib3V0VW5zYWZlTGlmZWN5Y2xlcy5hZGQoZmliZXIudHlwZSk7XG4gICAgICB9KTtcbiAgICAgIHBlbmRpbmdVTlNBRkVfQ29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1dhcm5pbmdzID0gW107XG4gICAgfVxuXG4gICAgdmFyIGNvbXBvbmVudFdpbGxVcGRhdGVVbmlxdWVOYW1lcyA9IG5ldyBTZXQoKTtcblxuICAgIGlmIChwZW5kaW5nQ29tcG9uZW50V2lsbFVwZGF0ZVdhcm5pbmdzLmxlbmd0aCA+IDApIHtcbiAgICAgIHBlbmRpbmdDb21wb25lbnRXaWxsVXBkYXRlV2FybmluZ3MuZm9yRWFjaChmdW5jdGlvbiAoZmliZXIpIHtcbiAgICAgICAgY29tcG9uZW50V2lsbFVwZGF0ZVVuaXF1ZU5hbWVzLmFkZChnZXRDb21wb25lbnROYW1lKGZpYmVyLnR5cGUpIHx8ICdDb21wb25lbnQnKTtcbiAgICAgICAgZGlkV2FybkFib3V0VW5zYWZlTGlmZWN5Y2xlcy5hZGQoZmliZXIudHlwZSk7XG4gICAgICB9KTtcbiAgICAgIHBlbmRpbmdDb21wb25lbnRXaWxsVXBkYXRlV2FybmluZ3MgPSBbXTtcbiAgICB9XG5cbiAgICB2YXIgVU5TQUZFX2NvbXBvbmVudFdpbGxVcGRhdGVVbmlxdWVOYW1lcyA9IG5ldyBTZXQoKTtcblxuICAgIGlmIChwZW5kaW5nVU5TQUZFX0NvbXBvbmVudFdpbGxVcGRhdGVXYXJuaW5ncy5sZW5ndGggPiAwKSB7XG4gICAgICBwZW5kaW5nVU5TQUZFX0NvbXBvbmVudFdpbGxVcGRhdGVXYXJuaW5ncy5mb3JFYWNoKGZ1bmN0aW9uIChmaWJlcikge1xuICAgICAgICBVTlNBRkVfY29tcG9uZW50V2lsbFVwZGF0ZVVuaXF1ZU5hbWVzLmFkZChnZXRDb21wb25lbnROYW1lKGZpYmVyLnR5cGUpIHx8ICdDb21wb25lbnQnKTtcbiAgICAgICAgZGlkV2FybkFib3V0VW5zYWZlTGlmZWN5Y2xlcy5hZGQoZmliZXIudHlwZSk7XG4gICAgICB9KTtcbiAgICAgIHBlbmRpbmdVTlNBRkVfQ29tcG9uZW50V2lsbFVwZGF0ZVdhcm5pbmdzID0gW107XG4gICAgfSAvLyBGaW5hbGx5LCB3ZSBmbHVzaCBhbGwgdGhlIHdhcm5pbmdzXG4gICAgLy8gVU5TQUZFXyBvbmVzIGJlZm9yZSB0aGUgZGVwcmVjYXRlZCBvbmVzLCBzaW5jZSB0aGV5J2xsIGJlICdsb3VkZXInXG5cblxuICAgIGlmIChVTlNBRkVfY29tcG9uZW50V2lsbE1vdW50VW5pcXVlTmFtZXMuc2l6ZSA+IDApIHtcbiAgICAgIHZhciBzb3J0ZWROYW1lcyA9IHNldFRvU29ydGVkU3RyaW5nKFVOU0FGRV9jb21wb25lbnRXaWxsTW91bnRVbmlxdWVOYW1lcyk7XG5cbiAgICAgIGVycm9yKCdVc2luZyBVTlNBRkVfY29tcG9uZW50V2lsbE1vdW50IGluIHN0cmljdCBtb2RlIGlzIG5vdCByZWNvbW1lbmRlZCBhbmQgbWF5IGluZGljYXRlIGJ1Z3MgaW4geW91ciBjb2RlLiAnICsgJ1NlZSBodHRwczovL3JlYWN0anMub3JnL2xpbmsvdW5zYWZlLWNvbXBvbmVudC1saWZlY3ljbGVzIGZvciBkZXRhaWxzLlxcblxcbicgKyAnKiBNb3ZlIGNvZGUgd2l0aCBzaWRlIGVmZmVjdHMgdG8gY29tcG9uZW50RGlkTW91bnQsIGFuZCBzZXQgaW5pdGlhbCBzdGF0ZSBpbiB0aGUgY29uc3RydWN0b3IuXFxuJyArICdcXG5QbGVhc2UgdXBkYXRlIHRoZSBmb2xsb3dpbmcgY29tcG9uZW50czogJXMnLCBzb3J0ZWROYW1lcyk7XG4gICAgfVxuXG4gICAgaWYgKFVOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzVW5pcXVlTmFtZXMuc2l6ZSA+IDApIHtcbiAgICAgIHZhciBfc29ydGVkTmFtZXMgPSBzZXRUb1NvcnRlZFN0cmluZyhVTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1VuaXF1ZU5hbWVzKTtcblxuICAgICAgZXJyb3IoJ1VzaW5nIFVOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzIGluIHN0cmljdCBtb2RlIGlzIG5vdCByZWNvbW1lbmRlZCAnICsgJ2FuZCBtYXkgaW5kaWNhdGUgYnVncyBpbiB5b3VyIGNvZGUuICcgKyAnU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay91bnNhZmUtY29tcG9uZW50LWxpZmVjeWNsZXMgZm9yIGRldGFpbHMuXFxuXFxuJyArICcqIE1vdmUgZGF0YSBmZXRjaGluZyBjb2RlIG9yIHNpZGUgZWZmZWN0cyB0byBjb21wb25lbnREaWRVcGRhdGUuXFxuJyArIFwiKiBJZiB5b3UncmUgdXBkYXRpbmcgc3RhdGUgd2hlbmV2ZXIgcHJvcHMgY2hhbmdlLCBcIiArICdyZWZhY3RvciB5b3VyIGNvZGUgdG8gdXNlIG1lbW9pemF0aW9uIHRlY2huaXF1ZXMgb3IgbW92ZSBpdCB0byAnICsgJ3N0YXRpYyBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMuIExlYXJuIG1vcmUgYXQ6IGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9kZXJpdmVkLXN0YXRlXFxuJyArICdcXG5QbGVhc2UgdXBkYXRlIHRoZSBmb2xsb3dpbmcgY29tcG9uZW50czogJXMnLCBfc29ydGVkTmFtZXMpO1xuICAgIH1cblxuICAgIGlmIChVTlNBRkVfY29tcG9uZW50V2lsbFVwZGF0ZVVuaXF1ZU5hbWVzLnNpemUgPiAwKSB7XG4gICAgICB2YXIgX3NvcnRlZE5hbWVzMiA9IHNldFRvU29ydGVkU3RyaW5nKFVOU0FGRV9jb21wb25lbnRXaWxsVXBkYXRlVW5pcXVlTmFtZXMpO1xuXG4gICAgICBlcnJvcignVXNpbmcgVU5TQUZFX2NvbXBvbmVudFdpbGxVcGRhdGUgaW4gc3RyaWN0IG1vZGUgaXMgbm90IHJlY29tbWVuZGVkICcgKyAnYW5kIG1heSBpbmRpY2F0ZSBidWdzIGluIHlvdXIgY29kZS4gJyArICdTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3Vuc2FmZS1jb21wb25lbnQtbGlmZWN5Y2xlcyBmb3IgZGV0YWlscy5cXG5cXG4nICsgJyogTW92ZSBkYXRhIGZldGNoaW5nIGNvZGUgb3Igc2lkZSBlZmZlY3RzIHRvIGNvbXBvbmVudERpZFVwZGF0ZS5cXG4nICsgJ1xcblBsZWFzZSB1cGRhdGUgdGhlIGZvbGxvd2luZyBjb21wb25lbnRzOiAlcycsIF9zb3J0ZWROYW1lczIpO1xuICAgIH1cblxuICAgIGlmIChjb21wb25lbnRXaWxsTW91bnRVbmlxdWVOYW1lcy5zaXplID4gMCkge1xuICAgICAgdmFyIF9zb3J0ZWROYW1lczMgPSBzZXRUb1NvcnRlZFN0cmluZyhjb21wb25lbnRXaWxsTW91bnRVbmlxdWVOYW1lcyk7XG5cbiAgICAgIHdhcm4oJ2NvbXBvbmVudFdpbGxNb3VudCBoYXMgYmVlbiByZW5hbWVkLCBhbmQgaXMgbm90IHJlY29tbWVuZGVkIGZvciB1c2UuICcgKyAnU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay91bnNhZmUtY29tcG9uZW50LWxpZmVjeWNsZXMgZm9yIGRldGFpbHMuXFxuXFxuJyArICcqIE1vdmUgY29kZSB3aXRoIHNpZGUgZWZmZWN0cyB0byBjb21wb25lbnREaWRNb3VudCwgYW5kIHNldCBpbml0aWFsIHN0YXRlIGluIHRoZSBjb25zdHJ1Y3Rvci5cXG4nICsgJyogUmVuYW1lIGNvbXBvbmVudFdpbGxNb3VudCB0byBVTlNBRkVfY29tcG9uZW50V2lsbE1vdW50IHRvIHN1cHByZXNzICcgKyAndGhpcyB3YXJuaW5nIGluIG5vbi1zdHJpY3QgbW9kZS4gSW4gUmVhY3QgMTgueCwgb25seSB0aGUgVU5TQUZFXyBuYW1lIHdpbGwgd29yay4gJyArICdUbyByZW5hbWUgYWxsIGRlcHJlY2F0ZWQgbGlmZWN5Y2xlcyB0byB0aGVpciBuZXcgbmFtZXMsIHlvdSBjYW4gcnVuICcgKyAnYG5weCByZWFjdC1jb2RlbW9kIHJlbmFtZS11bnNhZmUtbGlmZWN5Y2xlc2AgaW4geW91ciBwcm9qZWN0IHNvdXJjZSBmb2xkZXIuXFxuJyArICdcXG5QbGVhc2UgdXBkYXRlIHRoZSBmb2xsb3dpbmcgY29tcG9uZW50czogJXMnLCBfc29ydGVkTmFtZXMzKTtcbiAgICB9XG5cbiAgICBpZiAoY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1VuaXF1ZU5hbWVzLnNpemUgPiAwKSB7XG4gICAgICB2YXIgX3NvcnRlZE5hbWVzNCA9IHNldFRvU29ydGVkU3RyaW5nKGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNVbmlxdWVOYW1lcyk7XG5cbiAgICAgIHdhcm4oJ2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgaGFzIGJlZW4gcmVuYW1lZCwgYW5kIGlzIG5vdCByZWNvbW1lbmRlZCBmb3IgdXNlLiAnICsgJ1NlZSBodHRwczovL3JlYWN0anMub3JnL2xpbmsvdW5zYWZlLWNvbXBvbmVudC1saWZlY3ljbGVzIGZvciBkZXRhaWxzLlxcblxcbicgKyAnKiBNb3ZlIGRhdGEgZmV0Y2hpbmcgY29kZSBvciBzaWRlIGVmZmVjdHMgdG8gY29tcG9uZW50RGlkVXBkYXRlLlxcbicgKyBcIiogSWYgeW91J3JlIHVwZGF0aW5nIHN0YXRlIHdoZW5ldmVyIHByb3BzIGNoYW5nZSwgcmVmYWN0b3IgeW91ciBcIiArICdjb2RlIHRvIHVzZSBtZW1vaXphdGlvbiB0ZWNobmlxdWVzIG9yIG1vdmUgaXQgdG8gJyArICdzdGF0aWMgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzLiBMZWFybiBtb3JlIGF0OiBodHRwczovL3JlYWN0anMub3JnL2xpbmsvZGVyaXZlZC1zdGF0ZVxcbicgKyAnKiBSZW5hbWUgY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyB0byBVTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyB0byBzdXBwcmVzcyAnICsgJ3RoaXMgd2FybmluZyBpbiBub24tc3RyaWN0IG1vZGUuIEluIFJlYWN0IDE4LngsIG9ubHkgdGhlIFVOU0FGRV8gbmFtZSB3aWxsIHdvcmsuICcgKyAnVG8gcmVuYW1lIGFsbCBkZXByZWNhdGVkIGxpZmVjeWNsZXMgdG8gdGhlaXIgbmV3IG5hbWVzLCB5b3UgY2FuIHJ1biAnICsgJ2BucHggcmVhY3QtY29kZW1vZCByZW5hbWUtdW5zYWZlLWxpZmVjeWNsZXNgIGluIHlvdXIgcHJvamVjdCBzb3VyY2UgZm9sZGVyLlxcbicgKyAnXFxuUGxlYXNlIHVwZGF0ZSB0aGUgZm9sbG93aW5nIGNvbXBvbmVudHM6ICVzJywgX3NvcnRlZE5hbWVzNCk7XG4gICAgfVxuXG4gICAgaWYgKGNvbXBvbmVudFdpbGxVcGRhdGVVbmlxdWVOYW1lcy5zaXplID4gMCkge1xuICAgICAgdmFyIF9zb3J0ZWROYW1lczUgPSBzZXRUb1NvcnRlZFN0cmluZyhjb21wb25lbnRXaWxsVXBkYXRlVW5pcXVlTmFtZXMpO1xuXG4gICAgICB3YXJuKCdjb21wb25lbnRXaWxsVXBkYXRlIGhhcyBiZWVuIHJlbmFtZWQsIGFuZCBpcyBub3QgcmVjb21tZW5kZWQgZm9yIHVzZS4gJyArICdTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3Vuc2FmZS1jb21wb25lbnQtbGlmZWN5Y2xlcyBmb3IgZGV0YWlscy5cXG5cXG4nICsgJyogTW92ZSBkYXRhIGZldGNoaW5nIGNvZGUgb3Igc2lkZSBlZmZlY3RzIHRvIGNvbXBvbmVudERpZFVwZGF0ZS5cXG4nICsgJyogUmVuYW1lIGNvbXBvbmVudFdpbGxVcGRhdGUgdG8gVU5TQUZFX2NvbXBvbmVudFdpbGxVcGRhdGUgdG8gc3VwcHJlc3MgJyArICd0aGlzIHdhcm5pbmcgaW4gbm9uLXN0cmljdCBtb2RlLiBJbiBSZWFjdCAxOC54LCBvbmx5IHRoZSBVTlNBRkVfIG5hbWUgd2lsbCB3b3JrLiAnICsgJ1RvIHJlbmFtZSBhbGwgZGVwcmVjYXRlZCBsaWZlY3ljbGVzIHRvIHRoZWlyIG5ldyBuYW1lcywgeW91IGNhbiBydW4gJyArICdgbnB4IHJlYWN0LWNvZGVtb2QgcmVuYW1lLXVuc2FmZS1saWZlY3ljbGVzYCBpbiB5b3VyIHByb2plY3Qgc291cmNlIGZvbGRlci5cXG4nICsgJ1xcblBsZWFzZSB1cGRhdGUgdGhlIGZvbGxvd2luZyBjb21wb25lbnRzOiAlcycsIF9zb3J0ZWROYW1lczUpO1xuICAgIH1cbiAgfTtcblxuICB2YXIgcGVuZGluZ0xlZ2FjeUNvbnRleHRXYXJuaW5nID0gbmV3IE1hcCgpOyAvLyBUcmFja3MgY29tcG9uZW50cyB3ZSBoYXZlIGFscmVhZHkgd2FybmVkIGFib3V0LlxuXG4gIHZhciBkaWRXYXJuQWJvdXRMZWdhY3lDb250ZXh0ID0gbmV3IFNldCgpO1xuXG4gIFJlYWN0U3RyaWN0TW9kZVdhcm5pbmdzLnJlY29yZExlZ2FjeUNvbnRleHRXYXJuaW5nID0gZnVuY3Rpb24gKGZpYmVyLCBpbnN0YW5jZSkge1xuICAgIHZhciBzdHJpY3RSb290ID0gZmluZFN0cmljdFJvb3QoZmliZXIpO1xuXG4gICAgaWYgKHN0cmljdFJvb3QgPT09IG51bGwpIHtcbiAgICAgIGVycm9yKCdFeHBlY3RlZCB0byBmaW5kIGEgU3RyaWN0TW9kZSBjb21wb25lbnQgaW4gYSBzdHJpY3QgbW9kZSB0cmVlLiAnICsgJ1RoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG5cbiAgICAgIHJldHVybjtcbiAgICB9IC8vIERlZHVwIHN0cmF0ZWd5OiBXYXJuIG9uY2UgcGVyIGNvbXBvbmVudC5cblxuXG4gICAgaWYgKGRpZFdhcm5BYm91dExlZ2FjeUNvbnRleHQuaGFzKGZpYmVyLnR5cGUpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHdhcm5pbmdzRm9yUm9vdCA9IHBlbmRpbmdMZWdhY3lDb250ZXh0V2FybmluZy5nZXQoc3RyaWN0Um9vdCk7XG5cbiAgICBpZiAoZmliZXIudHlwZS5jb250ZXh0VHlwZXMgIT0gbnVsbCB8fCBmaWJlci50eXBlLmNoaWxkQ29udGV4dFR5cGVzICE9IG51bGwgfHwgaW5zdGFuY2UgIT09IG51bGwgJiYgdHlwZW9mIGluc3RhbmNlLmdldENoaWxkQ29udGV4dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaWYgKHdhcm5pbmdzRm9yUm9vdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHdhcm5pbmdzRm9yUm9vdCA9IFtdO1xuICAgICAgICBwZW5kaW5nTGVnYWN5Q29udGV4dFdhcm5pbmcuc2V0KHN0cmljdFJvb3QsIHdhcm5pbmdzRm9yUm9vdCk7XG4gICAgICB9XG5cbiAgICAgIHdhcm5pbmdzRm9yUm9vdC5wdXNoKGZpYmVyKTtcbiAgICB9XG4gIH07XG5cbiAgUmVhY3RTdHJpY3RNb2RlV2FybmluZ3MuZmx1c2hMZWdhY3lDb250ZXh0V2FybmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICBwZW5kaW5nTGVnYWN5Q29udGV4dFdhcm5pbmcuZm9yRWFjaChmdW5jdGlvbiAoZmliZXJBcnJheSwgc3RyaWN0Um9vdCkge1xuICAgICAgaWYgKGZpYmVyQXJyYXkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIGZpcnN0RmliZXIgPSBmaWJlckFycmF5WzBdO1xuICAgICAgdmFyIHVuaXF1ZU5hbWVzID0gbmV3IFNldCgpO1xuICAgICAgZmliZXJBcnJheS5mb3JFYWNoKGZ1bmN0aW9uIChmaWJlcikge1xuICAgICAgICB1bmlxdWVOYW1lcy5hZGQoZ2V0Q29tcG9uZW50TmFtZShmaWJlci50eXBlKSB8fCAnQ29tcG9uZW50Jyk7XG4gICAgICAgIGRpZFdhcm5BYm91dExlZ2FjeUNvbnRleHQuYWRkKGZpYmVyLnR5cGUpO1xuICAgICAgfSk7XG4gICAgICB2YXIgc29ydGVkTmFtZXMgPSBzZXRUb1NvcnRlZFN0cmluZyh1bmlxdWVOYW1lcyk7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHNldEN1cnJlbnRGaWJlcihmaXJzdEZpYmVyKTtcblxuICAgICAgICBlcnJvcignTGVnYWN5IGNvbnRleHQgQVBJIGhhcyBiZWVuIGRldGVjdGVkIHdpdGhpbiBhIHN0cmljdC1tb2RlIHRyZWUuJyArICdcXG5cXG5UaGUgb2xkIEFQSSB3aWxsIGJlIHN1cHBvcnRlZCBpbiBhbGwgMTYueCByZWxlYXNlcywgYnV0IGFwcGxpY2F0aW9ucyAnICsgJ3VzaW5nIGl0IHNob3VsZCBtaWdyYXRlIHRvIHRoZSBuZXcgdmVyc2lvbi4nICsgJ1xcblxcblBsZWFzZSB1cGRhdGUgdGhlIGZvbGxvd2luZyBjb21wb25lbnRzOiAlcycgKyAnXFxuXFxuTGVhcm4gbW9yZSBhYm91dCB0aGlzIHdhcm5pbmcgaGVyZTogaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL2xlZ2FjeS1jb250ZXh0Jywgc29ydGVkTmFtZXMpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgcmVzZXRDdXJyZW50RmliZXIoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICBSZWFjdFN0cmljdE1vZGVXYXJuaW5ncy5kaXNjYXJkUGVuZGluZ1dhcm5pbmdzID0gZnVuY3Rpb24gKCkge1xuICAgIHBlbmRpbmdDb21wb25lbnRXaWxsTW91bnRXYXJuaW5ncyA9IFtdO1xuICAgIHBlbmRpbmdVTlNBRkVfQ29tcG9uZW50V2lsbE1vdW50V2FybmluZ3MgPSBbXTtcbiAgICBwZW5kaW5nQ29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1dhcm5pbmdzID0gW107XG4gICAgcGVuZGluZ1VOU0FGRV9Db21wb25lbnRXaWxsUmVjZWl2ZVByb3BzV2FybmluZ3MgPSBbXTtcbiAgICBwZW5kaW5nQ29tcG9uZW50V2lsbFVwZGF0ZVdhcm5pbmdzID0gW107XG4gICAgcGVuZGluZ1VOU0FGRV9Db21wb25lbnRXaWxsVXBkYXRlV2FybmluZ3MgPSBbXTtcbiAgICBwZW5kaW5nTGVnYWN5Q29udGV4dFdhcm5pbmcgPSBuZXcgTWFwKCk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHJlc29sdmVEZWZhdWx0UHJvcHMoQ29tcG9uZW50LCBiYXNlUHJvcHMpIHtcbiAgaWYgKENvbXBvbmVudCAmJiBDb21wb25lbnQuZGVmYXVsdFByb3BzKSB7XG4gICAgLy8gUmVzb2x2ZSBkZWZhdWx0IHByb3BzLiBUYWtlbiBmcm9tIFJlYWN0RWxlbWVudFxuICAgIHZhciBwcm9wcyA9IF9hc3NpZ24oe30sIGJhc2VQcm9wcyk7XG5cbiAgICB2YXIgZGVmYXVsdFByb3BzID0gQ29tcG9uZW50LmRlZmF1bHRQcm9wcztcblxuICAgIGZvciAodmFyIHByb3BOYW1lIGluIGRlZmF1bHRQcm9wcykge1xuICAgICAgaWYgKHByb3BzW3Byb3BOYW1lXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHByb3BzW3Byb3BOYW1lXSA9IGRlZmF1bHRQcm9wc1twcm9wTmFtZV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHByb3BzO1xuICB9XG5cbiAgcmV0dXJuIGJhc2VQcm9wcztcbn1cblxuLy8gTWF4IDMxIGJpdCBpbnRlZ2VyLiBUaGUgbWF4IGludGVnZXIgc2l6ZSBpbiBWOCBmb3IgMzItYml0IHN5c3RlbXMuXG4vLyBNYXRoLnBvdygyLCAzMCkgLSAxXG4vLyAwYjExMTExMTExMTExMTExMTExMTExMTExMTExMTExMVxudmFyIE1BWF9TSUdORURfMzFfQklUX0lOVCA9IDEwNzM3NDE4MjM7XG5cbnZhciB2YWx1ZUN1cnNvciA9IGNyZWF0ZUN1cnNvcihudWxsKTtcbnZhciByZW5kZXJlclNpZ2lsO1xuXG57XG4gIC8vIFVzZSB0aGlzIHRvIGRldGVjdCBtdWx0aXBsZSByZW5kZXJlcnMgdXNpbmcgdGhlIHNhbWUgY29udGV4dFxuICByZW5kZXJlclNpZ2lsID0ge307XG59XG5cbnZhciBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciA9IG51bGw7XG52YXIgbGFzdENvbnRleHREZXBlbmRlbmN5ID0gbnVsbDtcbnZhciBsYXN0Q29udGV4dFdpdGhBbGxCaXRzT2JzZXJ2ZWQgPSBudWxsO1xudmFyIGlzRGlzYWxsb3dlZENvbnRleHRSZWFkSW5ERVYgPSBmYWxzZTtcbmZ1bmN0aW9uIHJlc2V0Q29udGV4dERlcGVuZGVuY2llcygpIHtcbiAgLy8gVGhpcyBpcyBjYWxsZWQgcmlnaHQgYmVmb3JlIFJlYWN0IHlpZWxkcyBleGVjdXRpb24sIHRvIGVuc3VyZSBgcmVhZENvbnRleHRgXG4gIC8vIGNhbm5vdCBiZSBjYWxsZWQgb3V0c2lkZSB0aGUgcmVuZGVyIHBoYXNlLlxuICBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciA9IG51bGw7XG4gIGxhc3RDb250ZXh0RGVwZW5kZW5jeSA9IG51bGw7XG4gIGxhc3RDb250ZXh0V2l0aEFsbEJpdHNPYnNlcnZlZCA9IG51bGw7XG5cbiAge1xuICAgIGlzRGlzYWxsb3dlZENvbnRleHRSZWFkSW5ERVYgPSBmYWxzZTtcbiAgfVxufVxuZnVuY3Rpb24gZW50ZXJEaXNhbGxvd2VkQ29udGV4dFJlYWRJbkRFVigpIHtcbiAge1xuICAgIGlzRGlzYWxsb3dlZENvbnRleHRSZWFkSW5ERVYgPSB0cnVlO1xuICB9XG59XG5mdW5jdGlvbiBleGl0RGlzYWxsb3dlZENvbnRleHRSZWFkSW5ERVYoKSB7XG4gIHtcbiAgICBpc0Rpc2FsbG93ZWRDb250ZXh0UmVhZEluREVWID0gZmFsc2U7XG4gIH1cbn1cbmZ1bmN0aW9uIHB1c2hQcm92aWRlcihwcm92aWRlckZpYmVyLCBuZXh0VmFsdWUpIHtcbiAgdmFyIGNvbnRleHQgPSBwcm92aWRlckZpYmVyLnR5cGUuX2NvbnRleHQ7XG5cbiAge1xuICAgIHB1c2godmFsdWVDdXJzb3IsIGNvbnRleHQuX2N1cnJlbnRWYWx1ZSwgcHJvdmlkZXJGaWJlcik7XG4gICAgY29udGV4dC5fY3VycmVudFZhbHVlID0gbmV4dFZhbHVlO1xuXG4gICAge1xuICAgICAgaWYgKGNvbnRleHQuX2N1cnJlbnRSZW5kZXJlciAhPT0gdW5kZWZpbmVkICYmIGNvbnRleHQuX2N1cnJlbnRSZW5kZXJlciAhPT0gbnVsbCAmJiBjb250ZXh0Ll9jdXJyZW50UmVuZGVyZXIgIT09IHJlbmRlcmVyU2lnaWwpIHtcbiAgICAgICAgZXJyb3IoJ0RldGVjdGVkIG11bHRpcGxlIHJlbmRlcmVycyBjb25jdXJyZW50bHkgcmVuZGVyaW5nIHRoZSAnICsgJ3NhbWUgY29udGV4dCBwcm92aWRlci4gVGhpcyBpcyBjdXJyZW50bHkgdW5zdXBwb3J0ZWQuJyk7XG4gICAgICB9XG5cbiAgICAgIGNvbnRleHQuX2N1cnJlbnRSZW5kZXJlciA9IHJlbmRlcmVyU2lnaWw7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBwb3BQcm92aWRlcihwcm92aWRlckZpYmVyKSB7XG4gIHZhciBjdXJyZW50VmFsdWUgPSB2YWx1ZUN1cnNvci5jdXJyZW50O1xuICBwb3AodmFsdWVDdXJzb3IsIHByb3ZpZGVyRmliZXIpO1xuICB2YXIgY29udGV4dCA9IHByb3ZpZGVyRmliZXIudHlwZS5fY29udGV4dDtcblxuICB7XG4gICAgY29udGV4dC5fY3VycmVudFZhbHVlID0gY3VycmVudFZhbHVlO1xuICB9XG59XG5mdW5jdGlvbiBjYWxjdWxhdGVDaGFuZ2VkQml0cyhjb250ZXh0LCBuZXdWYWx1ZSwgb2xkVmFsdWUpIHtcbiAgaWYgKG9iamVjdElzKG9sZFZhbHVlLCBuZXdWYWx1ZSkpIHtcbiAgICAvLyBObyBjaGFuZ2VcbiAgICByZXR1cm4gMDtcbiAgfSBlbHNlIHtcbiAgICB2YXIgY2hhbmdlZEJpdHMgPSB0eXBlb2YgY29udGV4dC5fY2FsY3VsYXRlQ2hhbmdlZEJpdHMgPT09ICdmdW5jdGlvbicgPyBjb250ZXh0Ll9jYWxjdWxhdGVDaGFuZ2VkQml0cyhvbGRWYWx1ZSwgbmV3VmFsdWUpIDogTUFYX1NJR05FRF8zMV9CSVRfSU5UO1xuXG4gICAge1xuICAgICAgaWYgKChjaGFuZ2VkQml0cyAmIE1BWF9TSUdORURfMzFfQklUX0lOVCkgIT09IGNoYW5nZWRCaXRzKSB7XG4gICAgICAgIGVycm9yKCdjYWxjdWxhdGVDaGFuZ2VkQml0czogRXhwZWN0ZWQgdGhlIHJldHVybiB2YWx1ZSB0byBiZSBhICcgKyAnMzEtYml0IGludGVnZXIuIEluc3RlYWQgcmVjZWl2ZWQ6ICVzJywgY2hhbmdlZEJpdHMpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBjaGFuZ2VkQml0cyB8IDA7XG4gIH1cbn1cbmZ1bmN0aW9uIHNjaGVkdWxlV29ya09uUGFyZW50UGF0aChwYXJlbnQsIHJlbmRlckxhbmVzKSB7XG4gIC8vIFVwZGF0ZSB0aGUgY2hpbGQgbGFuZXMgb2YgYWxsIHRoZSBhbmNlc3RvcnMsIGluY2x1ZGluZyB0aGUgYWx0ZXJuYXRlcy5cbiAgdmFyIG5vZGUgPSBwYXJlbnQ7XG5cbiAgd2hpbGUgKG5vZGUgIT09IG51bGwpIHtcbiAgICB2YXIgYWx0ZXJuYXRlID0gbm9kZS5hbHRlcm5hdGU7XG5cbiAgICBpZiAoIWlzU3Vic2V0T2ZMYW5lcyhub2RlLmNoaWxkTGFuZXMsIHJlbmRlckxhbmVzKSkge1xuICAgICAgbm9kZS5jaGlsZExhbmVzID0gbWVyZ2VMYW5lcyhub2RlLmNoaWxkTGFuZXMsIHJlbmRlckxhbmVzKTtcblxuICAgICAgaWYgKGFsdGVybmF0ZSAhPT0gbnVsbCkge1xuICAgICAgICBhbHRlcm5hdGUuY2hpbGRMYW5lcyA9IG1lcmdlTGFuZXMoYWx0ZXJuYXRlLmNoaWxkTGFuZXMsIHJlbmRlckxhbmVzKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGFsdGVybmF0ZSAhPT0gbnVsbCAmJiAhaXNTdWJzZXRPZkxhbmVzKGFsdGVybmF0ZS5jaGlsZExhbmVzLCByZW5kZXJMYW5lcykpIHtcbiAgICAgIGFsdGVybmF0ZS5jaGlsZExhbmVzID0gbWVyZ2VMYW5lcyhhbHRlcm5hdGUuY2hpbGRMYW5lcywgcmVuZGVyTGFuZXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBOZWl0aGVyIGFsdGVybmF0ZSB3YXMgdXBkYXRlZCwgd2hpY2ggbWVhbnMgdGhlIHJlc3Qgb2YgdGhlXG4gICAgICAvLyBhbmNlc3RvciBwYXRoIGFscmVhZHkgaGFzIHN1ZmZpY2llbnQgcHJpb3JpdHkuXG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBub2RlID0gbm9kZS5yZXR1cm47XG4gIH1cbn1cbmZ1bmN0aW9uIHByb3BhZ2F0ZUNvbnRleHRDaGFuZ2Uod29ya0luUHJvZ3Jlc3MsIGNvbnRleHQsIGNoYW5nZWRCaXRzLCByZW5kZXJMYW5lcykge1xuICB2YXIgZmliZXIgPSB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcblxuICBpZiAoZmliZXIgIT09IG51bGwpIHtcbiAgICAvLyBTZXQgdGhlIHJldHVybiBwb2ludGVyIG9mIHRoZSBjaGlsZCB0byB0aGUgd29yay1pbi1wcm9ncmVzcyBmaWJlci5cbiAgICBmaWJlci5yZXR1cm4gPSB3b3JrSW5Qcm9ncmVzcztcbiAgfVxuXG4gIHdoaWxlIChmaWJlciAhPT0gbnVsbCkge1xuICAgIHZhciBuZXh0RmliZXIgPSB2b2lkIDA7IC8vIFZpc2l0IHRoaXMgZmliZXIuXG5cbiAgICB2YXIgbGlzdCA9IGZpYmVyLmRlcGVuZGVuY2llcztcblxuICAgIGlmIChsaXN0ICE9PSBudWxsKSB7XG4gICAgICBuZXh0RmliZXIgPSBmaWJlci5jaGlsZDtcbiAgICAgIHZhciBkZXBlbmRlbmN5ID0gbGlzdC5maXJzdENvbnRleHQ7XG5cbiAgICAgIHdoaWxlIChkZXBlbmRlbmN5ICE9PSBudWxsKSB7XG4gICAgICAgIC8vIENoZWNrIGlmIHRoZSBjb250ZXh0IG1hdGNoZXMuXG4gICAgICAgIGlmIChkZXBlbmRlbmN5LmNvbnRleHQgPT09IGNvbnRleHQgJiYgKGRlcGVuZGVuY3kub2JzZXJ2ZWRCaXRzICYgY2hhbmdlZEJpdHMpICE9PSAwKSB7XG4gICAgICAgICAgLy8gTWF0Y2ghIFNjaGVkdWxlIGFuIHVwZGF0ZSBvbiB0aGlzIGZpYmVyLlxuICAgICAgICAgIGlmIChmaWJlci50YWcgPT09IENsYXNzQ29tcG9uZW50KSB7XG4gICAgICAgICAgICAvLyBTY2hlZHVsZSBhIGZvcmNlIHVwZGF0ZSBvbiB0aGUgd29yay1pbi1wcm9ncmVzcy5cbiAgICAgICAgICAgIHZhciB1cGRhdGUgPSBjcmVhdGVVcGRhdGUoTm9UaW1lc3RhbXAsIHBpY2tBcmJpdHJhcnlMYW5lKHJlbmRlckxhbmVzKSk7XG4gICAgICAgICAgICB1cGRhdGUudGFnID0gRm9yY2VVcGRhdGU7IC8vIFRPRE86IEJlY2F1c2Ugd2UgZG9uJ3QgaGF2ZSBhIHdvcmstaW4tcHJvZ3Jlc3MsIHRoaXMgd2lsbCBhZGQgdGhlXG4gICAgICAgICAgICAvLyB1cGRhdGUgdG8gdGhlIGN1cnJlbnQgZmliZXIsIHRvbywgd2hpY2ggbWVhbnMgaXQgd2lsbCBwZXJzaXN0IGV2ZW4gaWZcbiAgICAgICAgICAgIC8vIHRoaXMgcmVuZGVyIGlzIHRocm93biBhd2F5LiBTaW5jZSBpdCdzIGEgcmFjZSBjb25kaXRpb24sIG5vdCBzdXJlIGl0J3NcbiAgICAgICAgICAgIC8vIHdvcnRoIGZpeGluZy5cblxuICAgICAgICAgICAgZW5xdWV1ZVVwZGF0ZShmaWJlciwgdXBkYXRlKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmaWJlci5sYW5lcyA9IG1lcmdlTGFuZXMoZmliZXIubGFuZXMsIHJlbmRlckxhbmVzKTtcbiAgICAgICAgICB2YXIgYWx0ZXJuYXRlID0gZmliZXIuYWx0ZXJuYXRlO1xuXG4gICAgICAgICAgaWYgKGFsdGVybmF0ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgYWx0ZXJuYXRlLmxhbmVzID0gbWVyZ2VMYW5lcyhhbHRlcm5hdGUubGFuZXMsIHJlbmRlckxhbmVzKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBzY2hlZHVsZVdvcmtPblBhcmVudFBhdGgoZmliZXIucmV0dXJuLCByZW5kZXJMYW5lcyk7IC8vIE1hcmsgdGhlIHVwZGF0ZWQgbGFuZXMgb24gdGhlIGxpc3QsIHRvby5cblxuICAgICAgICAgIGxpc3QubGFuZXMgPSBtZXJnZUxhbmVzKGxpc3QubGFuZXMsIHJlbmRlckxhbmVzKTsgLy8gU2luY2Ugd2UgYWxyZWFkeSBmb3VuZCBhIG1hdGNoLCB3ZSBjYW4gc3RvcCB0cmF2ZXJzaW5nIHRoZVxuICAgICAgICAgIC8vIGRlcGVuZGVuY3kgbGlzdC5cblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgZGVwZW5kZW5jeSA9IGRlcGVuZGVuY3kubmV4dDtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGZpYmVyLnRhZyA9PT0gQ29udGV4dFByb3ZpZGVyKSB7XG4gICAgICAvLyBEb24ndCBzY2FuIGRlZXBlciBpZiB0aGlzIGlzIGEgbWF0Y2hpbmcgcHJvdmlkZXJcbiAgICAgIG5leHRGaWJlciA9IGZpYmVyLnR5cGUgPT09IHdvcmtJblByb2dyZXNzLnR5cGUgPyBudWxsIDogZmliZXIuY2hpbGQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRyYXZlcnNlIGRvd24uXG4gICAgICBuZXh0RmliZXIgPSBmaWJlci5jaGlsZDtcbiAgICB9XG5cbiAgICBpZiAobmV4dEZpYmVyICE9PSBudWxsKSB7XG4gICAgICAvLyBTZXQgdGhlIHJldHVybiBwb2ludGVyIG9mIHRoZSBjaGlsZCB0byB0aGUgd29yay1pbi1wcm9ncmVzcyBmaWJlci5cbiAgICAgIG5leHRGaWJlci5yZXR1cm4gPSBmaWJlcjtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gTm8gY2hpbGQuIFRyYXZlcnNlIHRvIG5leHQgc2libGluZy5cbiAgICAgIG5leHRGaWJlciA9IGZpYmVyO1xuXG4gICAgICB3aGlsZSAobmV4dEZpYmVyICE9PSBudWxsKSB7XG4gICAgICAgIGlmIChuZXh0RmliZXIgPT09IHdvcmtJblByb2dyZXNzKSB7XG4gICAgICAgICAgLy8gV2UncmUgYmFjayB0byB0aGUgcm9vdCBvZiB0aGlzIHN1YnRyZWUuIEV4aXQuXG4gICAgICAgICAgbmV4dEZpYmVyID0gbnVsbDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzaWJsaW5nID0gbmV4dEZpYmVyLnNpYmxpbmc7XG5cbiAgICAgICAgaWYgKHNpYmxpbmcgIT09IG51bGwpIHtcbiAgICAgICAgICAvLyBTZXQgdGhlIHJldHVybiBwb2ludGVyIG9mIHRoZSBzaWJsaW5nIHRvIHRoZSB3b3JrLWluLXByb2dyZXNzIGZpYmVyLlxuICAgICAgICAgIHNpYmxpbmcucmV0dXJuID0gbmV4dEZpYmVyLnJldHVybjtcbiAgICAgICAgICBuZXh0RmliZXIgPSBzaWJsaW5nO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9IC8vIE5vIG1vcmUgc2libGluZ3MuIFRyYXZlcnNlIHVwLlxuXG5cbiAgICAgICAgbmV4dEZpYmVyID0gbmV4dEZpYmVyLnJldHVybjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmaWJlciA9IG5leHRGaWJlcjtcbiAgfVxufVxuZnVuY3Rpb24gcHJlcGFyZVRvUmVhZENvbnRleHQod29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKSB7XG4gIGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyID0gd29ya0luUHJvZ3Jlc3M7XG4gIGxhc3RDb250ZXh0RGVwZW5kZW5jeSA9IG51bGw7XG4gIGxhc3RDb250ZXh0V2l0aEFsbEJpdHNPYnNlcnZlZCA9IG51bGw7XG4gIHZhciBkZXBlbmRlbmNpZXMgPSB3b3JrSW5Qcm9ncmVzcy5kZXBlbmRlbmNpZXM7XG5cbiAgaWYgKGRlcGVuZGVuY2llcyAhPT0gbnVsbCkge1xuICAgIHZhciBmaXJzdENvbnRleHQgPSBkZXBlbmRlbmNpZXMuZmlyc3RDb250ZXh0O1xuXG4gICAgaWYgKGZpcnN0Q29udGV4dCAhPT0gbnVsbCkge1xuICAgICAgaWYgKGluY2x1ZGVzU29tZUxhbmUoZGVwZW5kZW5jaWVzLmxhbmVzLCByZW5kZXJMYW5lcykpIHtcbiAgICAgICAgLy8gQ29udGV4dCBsaXN0IGhhcyBhIHBlbmRpbmcgdXBkYXRlLiBNYXJrIHRoYXQgdGhpcyBmaWJlciBwZXJmb3JtZWQgd29yay5cbiAgICAgICAgbWFya1dvcmtJblByb2dyZXNzUmVjZWl2ZWRVcGRhdGUoKTtcbiAgICAgIH0gLy8gUmVzZXQgdGhlIHdvcmstaW4tcHJvZ3Jlc3MgbGlzdFxuXG5cbiAgICAgIGRlcGVuZGVuY2llcy5maXJzdENvbnRleHQgPSBudWxsO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gcmVhZENvbnRleHQoY29udGV4dCwgb2JzZXJ2ZWRCaXRzKSB7XG4gIHtcbiAgICAvLyBUaGlzIHdhcm5pbmcgd291bGQgZmlyZSBpZiB5b3UgcmVhZCBjb250ZXh0IGluc2lkZSBhIEhvb2sgbGlrZSB1c2VNZW1vLlxuICAgIC8vIFVubGlrZSB0aGUgY2xhc3MgY2hlY2sgYmVsb3csIGl0J3Mgbm90IGVuZm9yY2VkIGluIHByb2R1Y3Rpb24gZm9yIHBlcmYuXG4gICAgaWYgKGlzRGlzYWxsb3dlZENvbnRleHRSZWFkSW5ERVYpIHtcbiAgICAgIGVycm9yKCdDb250ZXh0IGNhbiBvbmx5IGJlIHJlYWQgd2hpbGUgUmVhY3QgaXMgcmVuZGVyaW5nLiAnICsgJ0luIGNsYXNzZXMsIHlvdSBjYW4gcmVhZCBpdCBpbiB0aGUgcmVuZGVyIG1ldGhvZCBvciBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMuICcgKyAnSW4gZnVuY3Rpb24gY29tcG9uZW50cywgeW91IGNhbiByZWFkIGl0IGRpcmVjdGx5IGluIHRoZSBmdW5jdGlvbiBib2R5LCBidXQgbm90ICcgKyAnaW5zaWRlIEhvb2tzIGxpa2UgdXNlUmVkdWNlcigpIG9yIHVzZU1lbW8oKS4nKTtcbiAgICB9XG4gIH1cblxuICBpZiAobGFzdENvbnRleHRXaXRoQWxsQml0c09ic2VydmVkID09PSBjb250ZXh0KSA7IGVsc2UgaWYgKG9ic2VydmVkQml0cyA9PT0gZmFsc2UgfHwgb2JzZXJ2ZWRCaXRzID09PSAwKSA7IGVsc2Uge1xuICAgIHZhciByZXNvbHZlZE9ic2VydmVkQml0czsgLy8gQXZvaWQgZGVvcHRpbmcgb24gb2JzZXJ2YWJsZSBhcmd1bWVudHMgb3IgaGV0ZXJvZ2VuZW91cyB0eXBlcy5cblxuICAgIGlmICh0eXBlb2Ygb2JzZXJ2ZWRCaXRzICE9PSAnbnVtYmVyJyB8fCBvYnNlcnZlZEJpdHMgPT09IE1BWF9TSUdORURfMzFfQklUX0lOVCkge1xuICAgICAgLy8gT2JzZXJ2ZSBhbGwgdXBkYXRlcy5cbiAgICAgIGxhc3RDb250ZXh0V2l0aEFsbEJpdHNPYnNlcnZlZCA9IGNvbnRleHQ7XG4gICAgICByZXNvbHZlZE9ic2VydmVkQml0cyA9IE1BWF9TSUdORURfMzFfQklUX0lOVDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzb2x2ZWRPYnNlcnZlZEJpdHMgPSBvYnNlcnZlZEJpdHM7XG4gICAgfVxuXG4gICAgdmFyIGNvbnRleHRJdGVtID0ge1xuICAgICAgY29udGV4dDogY29udGV4dCxcbiAgICAgIG9ic2VydmVkQml0czogcmVzb2x2ZWRPYnNlcnZlZEJpdHMsXG4gICAgICBuZXh0OiBudWxsXG4gICAgfTtcblxuICAgIGlmIChsYXN0Q29udGV4dERlcGVuZGVuY3kgPT09IG51bGwpIHtcbiAgICAgIGlmICghKGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyICE9PSBudWxsKSkge1xuICAgICAgICB7XG4gICAgICAgICAgdGhyb3cgRXJyb3IoIFwiQ29udGV4dCBjYW4gb25seSBiZSByZWFkIHdoaWxlIFJlYWN0IGlzIHJlbmRlcmluZy4gSW4gY2xhc3NlcywgeW91IGNhbiByZWFkIGl0IGluIHRoZSByZW5kZXIgbWV0aG9kIG9yIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcy4gSW4gZnVuY3Rpb24gY29tcG9uZW50cywgeW91IGNhbiByZWFkIGl0IGRpcmVjdGx5IGluIHRoZSBmdW5jdGlvbiBib2R5LCBidXQgbm90IGluc2lkZSBIb29rcyBsaWtlIHVzZVJlZHVjZXIoKSBvciB1c2VNZW1vKCkuXCIgKTtcbiAgICAgICAgfVxuICAgICAgfSAvLyBUaGlzIGlzIHRoZSBmaXJzdCBkZXBlbmRlbmN5IGZvciB0aGlzIGNvbXBvbmVudC4gQ3JlYXRlIGEgbmV3IGxpc3QuXG5cblxuICAgICAgbGFzdENvbnRleHREZXBlbmRlbmN5ID0gY29udGV4dEl0ZW07XG4gICAgICBjdXJyZW50bHlSZW5kZXJpbmdGaWJlci5kZXBlbmRlbmNpZXMgPSB7XG4gICAgICAgIGxhbmVzOiBOb0xhbmVzLFxuICAgICAgICBmaXJzdENvbnRleHQ6IGNvbnRleHRJdGVtLFxuICAgICAgICByZXNwb25kZXJzOiBudWxsXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBBcHBlbmQgYSBuZXcgY29udGV4dCBpdGVtLlxuICAgICAgbGFzdENvbnRleHREZXBlbmRlbmN5ID0gbGFzdENvbnRleHREZXBlbmRlbmN5Lm5leHQgPSBjb250ZXh0SXRlbTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gIGNvbnRleHQuX2N1cnJlbnRWYWx1ZSA7XG59XG5cbnZhciBVcGRhdGVTdGF0ZSA9IDA7XG52YXIgUmVwbGFjZVN0YXRlID0gMTtcbnZhciBGb3JjZVVwZGF0ZSA9IDI7XG52YXIgQ2FwdHVyZVVwZGF0ZSA9IDM7IC8vIEdsb2JhbCBzdGF0ZSB0aGF0IGlzIHJlc2V0IGF0IHRoZSBiZWdpbm5pbmcgb2YgY2FsbGluZyBgcHJvY2Vzc1VwZGF0ZVF1ZXVlYC5cbi8vIEl0IHNob3VsZCBvbmx5IGJlIHJlYWQgcmlnaHQgYWZ0ZXIgY2FsbGluZyBgcHJvY2Vzc1VwZGF0ZVF1ZXVlYCwgdmlhXG4vLyBgY2hlY2tIYXNGb3JjZVVwZGF0ZUFmdGVyUHJvY2Vzc2luZ2AuXG5cbnZhciBoYXNGb3JjZVVwZGF0ZSA9IGZhbHNlO1xudmFyIGRpZFdhcm5VcGRhdGVJbnNpZGVVcGRhdGU7XG52YXIgY3VycmVudGx5UHJvY2Vzc2luZ1F1ZXVlO1xuXG57XG4gIGRpZFdhcm5VcGRhdGVJbnNpZGVVcGRhdGUgPSBmYWxzZTtcbiAgY3VycmVudGx5UHJvY2Vzc2luZ1F1ZXVlID0gbnVsbDtcbn1cblxuZnVuY3Rpb24gaW5pdGlhbGl6ZVVwZGF0ZVF1ZXVlKGZpYmVyKSB7XG4gIHZhciBxdWV1ZSA9IHtcbiAgICBiYXNlU3RhdGU6IGZpYmVyLm1lbW9pemVkU3RhdGUsXG4gICAgZmlyc3RCYXNlVXBkYXRlOiBudWxsLFxuICAgIGxhc3RCYXNlVXBkYXRlOiBudWxsLFxuICAgIHNoYXJlZDoge1xuICAgICAgcGVuZGluZzogbnVsbFxuICAgIH0sXG4gICAgZWZmZWN0czogbnVsbFxuICB9O1xuICBmaWJlci51cGRhdGVRdWV1ZSA9IHF1ZXVlO1xufVxuZnVuY3Rpb24gY2xvbmVVcGRhdGVRdWV1ZShjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcykge1xuICAvLyBDbG9uZSB0aGUgdXBkYXRlIHF1ZXVlIGZyb20gY3VycmVudC4gVW5sZXNzIGl0J3MgYWxyZWFkeSBhIGNsb25lLlxuICB2YXIgcXVldWUgPSB3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZTtcbiAgdmFyIGN1cnJlbnRRdWV1ZSA9IGN1cnJlbnQudXBkYXRlUXVldWU7XG5cbiAgaWYgKHF1ZXVlID09PSBjdXJyZW50UXVldWUpIHtcbiAgICB2YXIgY2xvbmUgPSB7XG4gICAgICBiYXNlU3RhdGU6IGN1cnJlbnRRdWV1ZS5iYXNlU3RhdGUsXG4gICAgICBmaXJzdEJhc2VVcGRhdGU6IGN1cnJlbnRRdWV1ZS5maXJzdEJhc2VVcGRhdGUsXG4gICAgICBsYXN0QmFzZVVwZGF0ZTogY3VycmVudFF1ZXVlLmxhc3RCYXNlVXBkYXRlLFxuICAgICAgc2hhcmVkOiBjdXJyZW50UXVldWUuc2hhcmVkLFxuICAgICAgZWZmZWN0czogY3VycmVudFF1ZXVlLmVmZmVjdHNcbiAgICB9O1xuICAgIHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlID0gY2xvbmU7XG4gIH1cbn1cbmZ1bmN0aW9uIGNyZWF0ZVVwZGF0ZShldmVudFRpbWUsIGxhbmUpIHtcbiAgdmFyIHVwZGF0ZSA9IHtcbiAgICBldmVudFRpbWU6IGV2ZW50VGltZSxcbiAgICBsYW5lOiBsYW5lLFxuICAgIHRhZzogVXBkYXRlU3RhdGUsXG4gICAgcGF5bG9hZDogbnVsbCxcbiAgICBjYWxsYmFjazogbnVsbCxcbiAgICBuZXh0OiBudWxsXG4gIH07XG4gIHJldHVybiB1cGRhdGU7XG59XG5mdW5jdGlvbiBlbnF1ZXVlVXBkYXRlKGZpYmVyLCB1cGRhdGUpIHtcbiAgdmFyIHVwZGF0ZVF1ZXVlID0gZmliZXIudXBkYXRlUXVldWU7XG5cbiAgaWYgKHVwZGF0ZVF1ZXVlID09PSBudWxsKSB7XG4gICAgLy8gT25seSBvY2N1cnMgaWYgdGhlIGZpYmVyIGhhcyBiZWVuIHVubW91bnRlZC5cbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgc2hhcmVkUXVldWUgPSB1cGRhdGVRdWV1ZS5zaGFyZWQ7XG4gIHZhciBwZW5kaW5nID0gc2hhcmVkUXVldWUucGVuZGluZztcblxuICBpZiAocGVuZGluZyA9PT0gbnVsbCkge1xuICAgIC8vIFRoaXMgaXMgdGhlIGZpcnN0IHVwZGF0ZS4gQ3JlYXRlIGEgY2lyY3VsYXIgbGlzdC5cbiAgICB1cGRhdGUubmV4dCA9IHVwZGF0ZTtcbiAgfSBlbHNlIHtcbiAgICB1cGRhdGUubmV4dCA9IHBlbmRpbmcubmV4dDtcbiAgICBwZW5kaW5nLm5leHQgPSB1cGRhdGU7XG4gIH1cblxuICBzaGFyZWRRdWV1ZS5wZW5kaW5nID0gdXBkYXRlO1xuXG4gIHtcbiAgICBpZiAoY3VycmVudGx5UHJvY2Vzc2luZ1F1ZXVlID09PSBzaGFyZWRRdWV1ZSAmJiAhZGlkV2FyblVwZGF0ZUluc2lkZVVwZGF0ZSkge1xuICAgICAgZXJyb3IoJ0FuIHVwZGF0ZSAoc2V0U3RhdGUsIHJlcGxhY2VTdGF0ZSwgb3IgZm9yY2VVcGRhdGUpIHdhcyBzY2hlZHVsZWQgJyArICdmcm9tIGluc2lkZSBhbiB1cGRhdGUgZnVuY3Rpb24uIFVwZGF0ZSBmdW5jdGlvbnMgc2hvdWxkIGJlIHB1cmUsICcgKyAnd2l0aCB6ZXJvIHNpZGUtZWZmZWN0cy4gQ29uc2lkZXIgdXNpbmcgY29tcG9uZW50RGlkVXBkYXRlIG9yIGEgJyArICdjYWxsYmFjay4nKTtcblxuICAgICAgZGlkV2FyblVwZGF0ZUluc2lkZVVwZGF0ZSA9IHRydWU7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBlbnF1ZXVlQ2FwdHVyZWRVcGRhdGUod29ya0luUHJvZ3Jlc3MsIGNhcHR1cmVkVXBkYXRlKSB7XG4gIC8vIENhcHR1cmVkIHVwZGF0ZXMgYXJlIHVwZGF0ZXMgdGhhdCBhcmUgdGhyb3duIGJ5IGEgY2hpbGQgZHVyaW5nIHRoZSByZW5kZXJcbiAgLy8gcGhhc2UuIFRoZXkgc2hvdWxkIGJlIGRpc2NhcmRlZCBpZiB0aGUgcmVuZGVyIGlzIGFib3J0ZWQuIFRoZXJlZm9yZSxcbiAgLy8gd2Ugc2hvdWxkIG9ubHkgcHV0IHRoZW0gb24gdGhlIHdvcmstaW4tcHJvZ3Jlc3MgcXVldWUsIG5vdCB0aGUgY3VycmVudCBvbmUuXG4gIHZhciBxdWV1ZSA9IHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlOyAvLyBDaGVjayBpZiB0aGUgd29yay1pbi1wcm9ncmVzcyBxdWV1ZSBpcyBhIGNsb25lLlxuXG4gIHZhciBjdXJyZW50ID0gd29ya0luUHJvZ3Jlc3MuYWx0ZXJuYXRlO1xuXG4gIGlmIChjdXJyZW50ICE9PSBudWxsKSB7XG4gICAgdmFyIGN1cnJlbnRRdWV1ZSA9IGN1cnJlbnQudXBkYXRlUXVldWU7XG5cbiAgICBpZiAocXVldWUgPT09IGN1cnJlbnRRdWV1ZSkge1xuICAgICAgLy8gVGhlIHdvcmstaW4tcHJvZ3Jlc3MgcXVldWUgaXMgdGhlIHNhbWUgYXMgY3VycmVudC4gVGhpcyBoYXBwZW5zIHdoZW5cbiAgICAgIC8vIHdlIGJhaWwgb3V0IG9uIGEgcGFyZW50IGZpYmVyIHRoYXQgdGhlbiBjYXB0dXJlcyBhbiBlcnJvciB0aHJvd24gYnlcbiAgICAgIC8vIGEgY2hpbGQuIFNpbmNlIHdlIHdhbnQgdG8gYXBwZW5kIHRoZSB1cGRhdGUgb25seSB0byB0aGUgd29yay1pblxuICAgICAgLy8gLXByb2dyZXNzIHF1ZXVlLCB3ZSBuZWVkIHRvIGNsb25lIHRoZSB1cGRhdGVzLiBXZSB1c3VhbGx5IGNsb25lIGR1cmluZ1xuICAgICAgLy8gcHJvY2Vzc1VwZGF0ZVF1ZXVlLCBidXQgdGhhdCBkaWRuJ3QgaGFwcGVuIGluIHRoaXMgY2FzZSBiZWNhdXNlIHdlXG4gICAgICAvLyBza2lwcGVkIG92ZXIgdGhlIHBhcmVudCB3aGVuIHdlIGJhaWxlZCBvdXQuXG4gICAgICB2YXIgbmV3Rmlyc3QgPSBudWxsO1xuICAgICAgdmFyIG5ld0xhc3QgPSBudWxsO1xuICAgICAgdmFyIGZpcnN0QmFzZVVwZGF0ZSA9IHF1ZXVlLmZpcnN0QmFzZVVwZGF0ZTtcblxuICAgICAgaWYgKGZpcnN0QmFzZVVwZGF0ZSAhPT0gbnVsbCkge1xuICAgICAgICAvLyBMb29wIHRocm91Z2ggdGhlIHVwZGF0ZXMgYW5kIGNsb25lIHRoZW0uXG4gICAgICAgIHZhciB1cGRhdGUgPSBmaXJzdEJhc2VVcGRhdGU7XG5cbiAgICAgICAgZG8ge1xuICAgICAgICAgIHZhciBjbG9uZSA9IHtcbiAgICAgICAgICAgIGV2ZW50VGltZTogdXBkYXRlLmV2ZW50VGltZSxcbiAgICAgICAgICAgIGxhbmU6IHVwZGF0ZS5sYW5lLFxuICAgICAgICAgICAgdGFnOiB1cGRhdGUudGFnLFxuICAgICAgICAgICAgcGF5bG9hZDogdXBkYXRlLnBheWxvYWQsXG4gICAgICAgICAgICBjYWxsYmFjazogdXBkYXRlLmNhbGxiYWNrLFxuICAgICAgICAgICAgbmV4dDogbnVsbFxuICAgICAgICAgIH07XG5cbiAgICAgICAgICBpZiAobmV3TGFzdCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgbmV3Rmlyc3QgPSBuZXdMYXN0ID0gY2xvbmU7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5ld0xhc3QubmV4dCA9IGNsb25lO1xuICAgICAgICAgICAgbmV3TGFzdCA9IGNsb25lO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHVwZGF0ZSA9IHVwZGF0ZS5uZXh0O1xuICAgICAgICB9IHdoaWxlICh1cGRhdGUgIT09IG51bGwpOyAvLyBBcHBlbmQgdGhlIGNhcHR1cmVkIHVwZGF0ZSB0aGUgZW5kIG9mIHRoZSBjbG9uZWQgbGlzdC5cblxuXG4gICAgICAgIGlmIChuZXdMYXN0ID09PSBudWxsKSB7XG4gICAgICAgICAgbmV3Rmlyc3QgPSBuZXdMYXN0ID0gY2FwdHVyZWRVcGRhdGU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbmV3TGFzdC5uZXh0ID0gY2FwdHVyZWRVcGRhdGU7XG4gICAgICAgICAgbmV3TGFzdCA9IGNhcHR1cmVkVXBkYXRlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBUaGVyZSBhcmUgbm8gYmFzZSB1cGRhdGVzLlxuICAgICAgICBuZXdGaXJzdCA9IG5ld0xhc3QgPSBjYXB0dXJlZFVwZGF0ZTtcbiAgICAgIH1cblxuICAgICAgcXVldWUgPSB7XG4gICAgICAgIGJhc2VTdGF0ZTogY3VycmVudFF1ZXVlLmJhc2VTdGF0ZSxcbiAgICAgICAgZmlyc3RCYXNlVXBkYXRlOiBuZXdGaXJzdCxcbiAgICAgICAgbGFzdEJhc2VVcGRhdGU6IG5ld0xhc3QsXG4gICAgICAgIHNoYXJlZDogY3VycmVudFF1ZXVlLnNoYXJlZCxcbiAgICAgICAgZWZmZWN0czogY3VycmVudFF1ZXVlLmVmZmVjdHNcbiAgICAgIH07XG4gICAgICB3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZSA9IHF1ZXVlO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfSAvLyBBcHBlbmQgdGhlIHVwZGF0ZSB0byB0aGUgZW5kIG9mIHRoZSBsaXN0LlxuXG5cbiAgdmFyIGxhc3RCYXNlVXBkYXRlID0gcXVldWUubGFzdEJhc2VVcGRhdGU7XG5cbiAgaWYgKGxhc3RCYXNlVXBkYXRlID09PSBudWxsKSB7XG4gICAgcXVldWUuZmlyc3RCYXNlVXBkYXRlID0gY2FwdHVyZWRVcGRhdGU7XG4gIH0gZWxzZSB7XG4gICAgbGFzdEJhc2VVcGRhdGUubmV4dCA9IGNhcHR1cmVkVXBkYXRlO1xuICB9XG5cbiAgcXVldWUubGFzdEJhc2VVcGRhdGUgPSBjYXB0dXJlZFVwZGF0ZTtcbn1cblxuZnVuY3Rpb24gZ2V0U3RhdGVGcm9tVXBkYXRlKHdvcmtJblByb2dyZXNzLCBxdWV1ZSwgdXBkYXRlLCBwcmV2U3RhdGUsIG5leHRQcm9wcywgaW5zdGFuY2UpIHtcbiAgc3dpdGNoICh1cGRhdGUudGFnKSB7XG4gICAgY2FzZSBSZXBsYWNlU3RhdGU6XG4gICAgICB7XG4gICAgICAgIHZhciBwYXlsb2FkID0gdXBkYXRlLnBheWxvYWQ7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBwYXlsb2FkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgLy8gVXBkYXRlciBmdW5jdGlvblxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGVudGVyRGlzYWxsb3dlZENvbnRleHRSZWFkSW5ERVYoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgbmV4dFN0YXRlID0gcGF5bG9hZC5jYWxsKGluc3RhbmNlLCBwcmV2U3RhdGUsIG5leHRQcm9wcyk7XG5cbiAgICAgICAgICB7XG4gICAgICAgICAgICBpZiAoIHdvcmtJblByb2dyZXNzLm1vZGUgJiBTdHJpY3RNb2RlKSB7XG4gICAgICAgICAgICAgIGRpc2FibGVMb2dzKCk7XG5cbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBwYXlsb2FkLmNhbGwoaW5zdGFuY2UsIHByZXZTdGF0ZSwgbmV4dFByb3BzKTtcbiAgICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICByZWVuYWJsZUxvZ3MoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBleGl0RGlzYWxsb3dlZENvbnRleHRSZWFkSW5ERVYoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gbmV4dFN0YXRlO1xuICAgICAgICB9IC8vIFN0YXRlIG9iamVjdFxuXG5cbiAgICAgICAgcmV0dXJuIHBheWxvYWQ7XG4gICAgICB9XG5cbiAgICBjYXNlIENhcHR1cmVVcGRhdGU6XG4gICAgICB7XG4gICAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzID0gd29ya0luUHJvZ3Jlc3MuZmxhZ3MgJiB+U2hvdWxkQ2FwdHVyZSB8IERpZENhcHR1cmU7XG4gICAgICB9XG4gICAgLy8gSW50ZW50aW9uYWwgZmFsbHRocm91Z2hcblxuICAgIGNhc2UgVXBkYXRlU3RhdGU6XG4gICAgICB7XG4gICAgICAgIHZhciBfcGF5bG9hZCA9IHVwZGF0ZS5wYXlsb2FkO1xuICAgICAgICB2YXIgcGFydGlhbFN0YXRlO1xuXG4gICAgICAgIGlmICh0eXBlb2YgX3BheWxvYWQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAvLyBVcGRhdGVyIGZ1bmN0aW9uXG4gICAgICAgICAge1xuICAgICAgICAgICAgZW50ZXJEaXNhbGxvd2VkQ29udGV4dFJlYWRJbkRFVigpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHBhcnRpYWxTdGF0ZSA9IF9wYXlsb2FkLmNhbGwoaW5zdGFuY2UsIHByZXZTdGF0ZSwgbmV4dFByb3BzKTtcblxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlmICggd29ya0luUHJvZ3Jlc3MubW9kZSAmIFN0cmljdE1vZGUpIHtcbiAgICAgICAgICAgICAgZGlzYWJsZUxvZ3MoKTtcblxuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIF9wYXlsb2FkLmNhbGwoaW5zdGFuY2UsIHByZXZTdGF0ZSwgbmV4dFByb3BzKTtcbiAgICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICByZWVuYWJsZUxvZ3MoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBleGl0RGlzYWxsb3dlZENvbnRleHRSZWFkSW5ERVYoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gUGFydGlhbCBzdGF0ZSBvYmplY3RcbiAgICAgICAgICBwYXJ0aWFsU3RhdGUgPSBfcGF5bG9hZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwYXJ0aWFsU3RhdGUgPT09IG51bGwgfHwgcGFydGlhbFN0YXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAvLyBOdWxsIGFuZCB1bmRlZmluZWQgYXJlIHRyZWF0ZWQgYXMgbm8tb3BzLlxuICAgICAgICAgIHJldHVybiBwcmV2U3RhdGU7XG4gICAgICAgIH0gLy8gTWVyZ2UgdGhlIHBhcnRpYWwgc3RhdGUgYW5kIHRoZSBwcmV2aW91cyBzdGF0ZS5cblxuXG4gICAgICAgIHJldHVybiBfYXNzaWduKHt9LCBwcmV2U3RhdGUsIHBhcnRpYWxTdGF0ZSk7XG4gICAgICB9XG5cbiAgICBjYXNlIEZvcmNlVXBkYXRlOlxuICAgICAge1xuICAgICAgICBoYXNGb3JjZVVwZGF0ZSA9IHRydWU7XG4gICAgICAgIHJldHVybiBwcmV2U3RhdGU7XG4gICAgICB9XG4gIH1cblxuICByZXR1cm4gcHJldlN0YXRlO1xufVxuXG5mdW5jdGlvbiBwcm9jZXNzVXBkYXRlUXVldWUod29ya0luUHJvZ3Jlc3MsIHByb3BzLCBpbnN0YW5jZSwgcmVuZGVyTGFuZXMpIHtcbiAgLy8gVGhpcyBpcyBhbHdheXMgbm9uLW51bGwgb24gYSBDbGFzc0NvbXBvbmVudCBvciBIb3N0Um9vdFxuICB2YXIgcXVldWUgPSB3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZTtcbiAgaGFzRm9yY2VVcGRhdGUgPSBmYWxzZTtcblxuICB7XG4gICAgY3VycmVudGx5UHJvY2Vzc2luZ1F1ZXVlID0gcXVldWUuc2hhcmVkO1xuICB9XG5cbiAgdmFyIGZpcnN0QmFzZVVwZGF0ZSA9IHF1ZXVlLmZpcnN0QmFzZVVwZGF0ZTtcbiAgdmFyIGxhc3RCYXNlVXBkYXRlID0gcXVldWUubGFzdEJhc2VVcGRhdGU7IC8vIENoZWNrIGlmIHRoZXJlIGFyZSBwZW5kaW5nIHVwZGF0ZXMuIElmIHNvLCB0cmFuc2ZlciB0aGVtIHRvIHRoZSBiYXNlIHF1ZXVlLlxuXG4gIHZhciBwZW5kaW5nUXVldWUgPSBxdWV1ZS5zaGFyZWQucGVuZGluZztcblxuICBpZiAocGVuZGluZ1F1ZXVlICE9PSBudWxsKSB7XG4gICAgcXVldWUuc2hhcmVkLnBlbmRpbmcgPSBudWxsOyAvLyBUaGUgcGVuZGluZyBxdWV1ZSBpcyBjaXJjdWxhci4gRGlzY29ubmVjdCB0aGUgcG9pbnRlciBiZXR3ZWVuIGZpcnN0XG4gICAgLy8gYW5kIGxhc3Qgc28gdGhhdCBpdCdzIG5vbi1jaXJjdWxhci5cblxuICAgIHZhciBsYXN0UGVuZGluZ1VwZGF0ZSA9IHBlbmRpbmdRdWV1ZTtcbiAgICB2YXIgZmlyc3RQZW5kaW5nVXBkYXRlID0gbGFzdFBlbmRpbmdVcGRhdGUubmV4dDtcbiAgICBsYXN0UGVuZGluZ1VwZGF0ZS5uZXh0ID0gbnVsbDsgLy8gQXBwZW5kIHBlbmRpbmcgdXBkYXRlcyB0byBiYXNlIHF1ZXVlXG5cbiAgICBpZiAobGFzdEJhc2VVcGRhdGUgPT09IG51bGwpIHtcbiAgICAgIGZpcnN0QmFzZVVwZGF0ZSA9IGZpcnN0UGVuZGluZ1VwZGF0ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGFzdEJhc2VVcGRhdGUubmV4dCA9IGZpcnN0UGVuZGluZ1VwZGF0ZTtcbiAgICB9XG5cbiAgICBsYXN0QmFzZVVwZGF0ZSA9IGxhc3RQZW5kaW5nVXBkYXRlOyAvLyBJZiB0aGVyZSdzIGEgY3VycmVudCBxdWV1ZSwgYW5kIGl0J3MgZGlmZmVyZW50IGZyb20gdGhlIGJhc2UgcXVldWUsIHRoZW5cbiAgICAvLyB3ZSBuZWVkIHRvIHRyYW5zZmVyIHRoZSB1cGRhdGVzIHRvIHRoYXQgcXVldWUsIHRvby4gQmVjYXVzZSB0aGUgYmFzZVxuICAgIC8vIHF1ZXVlIGlzIGEgc2luZ2x5LWxpbmtlZCBsaXN0IHdpdGggbm8gY3ljbGVzLCB3ZSBjYW4gYXBwZW5kIHRvIGJvdGhcbiAgICAvLyBsaXN0cyBhbmQgdGFrZSBhZHZhbnRhZ2Ugb2Ygc3RydWN0dXJhbCBzaGFyaW5nLlxuICAgIC8vIFRPRE86IFBhc3MgYGN1cnJlbnRgIGFzIGFyZ3VtZW50XG5cbiAgICB2YXIgY3VycmVudCA9IHdvcmtJblByb2dyZXNzLmFsdGVybmF0ZTtcblxuICAgIGlmIChjdXJyZW50ICE9PSBudWxsKSB7XG4gICAgICAvLyBUaGlzIGlzIGFsd2F5cyBub24tbnVsbCBvbiBhIENsYXNzQ29tcG9uZW50IG9yIEhvc3RSb290XG4gICAgICB2YXIgY3VycmVudFF1ZXVlID0gY3VycmVudC51cGRhdGVRdWV1ZTtcbiAgICAgIHZhciBjdXJyZW50TGFzdEJhc2VVcGRhdGUgPSBjdXJyZW50UXVldWUubGFzdEJhc2VVcGRhdGU7XG5cbiAgICAgIGlmIChjdXJyZW50TGFzdEJhc2VVcGRhdGUgIT09IGxhc3RCYXNlVXBkYXRlKSB7XG4gICAgICAgIGlmIChjdXJyZW50TGFzdEJhc2VVcGRhdGUgPT09IG51bGwpIHtcbiAgICAgICAgICBjdXJyZW50UXVldWUuZmlyc3RCYXNlVXBkYXRlID0gZmlyc3RQZW5kaW5nVXBkYXRlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGN1cnJlbnRMYXN0QmFzZVVwZGF0ZS5uZXh0ID0gZmlyc3RQZW5kaW5nVXBkYXRlO1xuICAgICAgICB9XG5cbiAgICAgICAgY3VycmVudFF1ZXVlLmxhc3RCYXNlVXBkYXRlID0gbGFzdFBlbmRpbmdVcGRhdGU7XG4gICAgICB9XG4gICAgfVxuICB9IC8vIFRoZXNlIHZhbHVlcyBtYXkgY2hhbmdlIGFzIHdlIHByb2Nlc3MgdGhlIHF1ZXVlLlxuXG5cbiAgaWYgKGZpcnN0QmFzZVVwZGF0ZSAhPT0gbnVsbCkge1xuICAgIC8vIEl0ZXJhdGUgdGhyb3VnaCB0aGUgbGlzdCBvZiB1cGRhdGVzIHRvIGNvbXB1dGUgdGhlIHJlc3VsdC5cbiAgICB2YXIgbmV3U3RhdGUgPSBxdWV1ZS5iYXNlU3RhdGU7IC8vIFRPRE86IERvbid0IG5lZWQgdG8gYWNjdW11bGF0ZSB0aGlzLiBJbnN0ZWFkLCB3ZSBjYW4gcmVtb3ZlIHJlbmRlckxhbmVzXG4gICAgLy8gZnJvbSB0aGUgb3JpZ2luYWwgbGFuZXMuXG5cbiAgICB2YXIgbmV3TGFuZXMgPSBOb0xhbmVzO1xuICAgIHZhciBuZXdCYXNlU3RhdGUgPSBudWxsO1xuICAgIHZhciBuZXdGaXJzdEJhc2VVcGRhdGUgPSBudWxsO1xuICAgIHZhciBuZXdMYXN0QmFzZVVwZGF0ZSA9IG51bGw7XG4gICAgdmFyIHVwZGF0ZSA9IGZpcnN0QmFzZVVwZGF0ZTtcblxuICAgIGRvIHtcbiAgICAgIHZhciB1cGRhdGVMYW5lID0gdXBkYXRlLmxhbmU7XG4gICAgICB2YXIgdXBkYXRlRXZlbnRUaW1lID0gdXBkYXRlLmV2ZW50VGltZTtcblxuICAgICAgaWYgKCFpc1N1YnNldE9mTGFuZXMocmVuZGVyTGFuZXMsIHVwZGF0ZUxhbmUpKSB7XG4gICAgICAgIC8vIFByaW9yaXR5IGlzIGluc3VmZmljaWVudC4gU2tpcCB0aGlzIHVwZGF0ZS4gSWYgdGhpcyBpcyB0aGUgZmlyc3RcbiAgICAgICAgLy8gc2tpcHBlZCB1cGRhdGUsIHRoZSBwcmV2aW91cyB1cGRhdGUvc3RhdGUgaXMgdGhlIG5ldyBiYXNlXG4gICAgICAgIC8vIHVwZGF0ZS9zdGF0ZS5cbiAgICAgICAgdmFyIGNsb25lID0ge1xuICAgICAgICAgIGV2ZW50VGltZTogdXBkYXRlRXZlbnRUaW1lLFxuICAgICAgICAgIGxhbmU6IHVwZGF0ZUxhbmUsXG4gICAgICAgICAgdGFnOiB1cGRhdGUudGFnLFxuICAgICAgICAgIHBheWxvYWQ6IHVwZGF0ZS5wYXlsb2FkLFxuICAgICAgICAgIGNhbGxiYWNrOiB1cGRhdGUuY2FsbGJhY2ssXG4gICAgICAgICAgbmV4dDogbnVsbFxuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChuZXdMYXN0QmFzZVVwZGF0ZSA9PT0gbnVsbCkge1xuICAgICAgICAgIG5ld0ZpcnN0QmFzZVVwZGF0ZSA9IG5ld0xhc3RCYXNlVXBkYXRlID0gY2xvbmU7XG4gICAgICAgICAgbmV3QmFzZVN0YXRlID0gbmV3U3RhdGU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbmV3TGFzdEJhc2VVcGRhdGUgPSBuZXdMYXN0QmFzZVVwZGF0ZS5uZXh0ID0gY2xvbmU7XG4gICAgICAgIH0gLy8gVXBkYXRlIHRoZSByZW1haW5pbmcgcHJpb3JpdHkgaW4gdGhlIHF1ZXVlLlxuXG5cbiAgICAgICAgbmV3TGFuZXMgPSBtZXJnZUxhbmVzKG5ld0xhbmVzLCB1cGRhdGVMYW5lKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFRoaXMgdXBkYXRlIGRvZXMgaGF2ZSBzdWZmaWNpZW50IHByaW9yaXR5LlxuICAgICAgICBpZiAobmV3TGFzdEJhc2VVcGRhdGUgIT09IG51bGwpIHtcbiAgICAgICAgICB2YXIgX2Nsb25lID0ge1xuICAgICAgICAgICAgZXZlbnRUaW1lOiB1cGRhdGVFdmVudFRpbWUsXG4gICAgICAgICAgICAvLyBUaGlzIHVwZGF0ZSBpcyBnb2luZyB0byBiZSBjb21taXR0ZWQgc28gd2UgbmV2ZXIgd2FudCB1bmNvbW1pdFxuICAgICAgICAgICAgLy8gaXQuIFVzaW5nIE5vTGFuZSB3b3JrcyBiZWNhdXNlIDAgaXMgYSBzdWJzZXQgb2YgYWxsIGJpdG1hc2tzLCBzb1xuICAgICAgICAgICAgLy8gdGhpcyB3aWxsIG5ldmVyIGJlIHNraXBwZWQgYnkgdGhlIGNoZWNrIGFib3ZlLlxuICAgICAgICAgICAgbGFuZTogTm9MYW5lLFxuICAgICAgICAgICAgdGFnOiB1cGRhdGUudGFnLFxuICAgICAgICAgICAgcGF5bG9hZDogdXBkYXRlLnBheWxvYWQsXG4gICAgICAgICAgICBjYWxsYmFjazogdXBkYXRlLmNhbGxiYWNrLFxuICAgICAgICAgICAgbmV4dDogbnVsbFxuICAgICAgICAgIH07XG4gICAgICAgICAgbmV3TGFzdEJhc2VVcGRhdGUgPSBuZXdMYXN0QmFzZVVwZGF0ZS5uZXh0ID0gX2Nsb25lO1xuICAgICAgICB9IC8vIFByb2Nlc3MgdGhpcyB1cGRhdGUuXG5cblxuICAgICAgICBuZXdTdGF0ZSA9IGdldFN0YXRlRnJvbVVwZGF0ZSh3b3JrSW5Qcm9ncmVzcywgcXVldWUsIHVwZGF0ZSwgbmV3U3RhdGUsIHByb3BzLCBpbnN0YW5jZSk7XG4gICAgICAgIHZhciBjYWxsYmFjayA9IHVwZGF0ZS5jYWxsYmFjaztcblxuICAgICAgICBpZiAoY2FsbGJhY2sgIT09IG51bGwpIHtcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBDYWxsYmFjaztcbiAgICAgICAgICB2YXIgZWZmZWN0cyA9IHF1ZXVlLmVmZmVjdHM7XG5cbiAgICAgICAgICBpZiAoZWZmZWN0cyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcXVldWUuZWZmZWN0cyA9IFt1cGRhdGVdO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlZmZlY3RzLnB1c2godXBkYXRlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdXBkYXRlID0gdXBkYXRlLm5leHQ7XG5cbiAgICAgIGlmICh1cGRhdGUgPT09IG51bGwpIHtcbiAgICAgICAgcGVuZGluZ1F1ZXVlID0gcXVldWUuc2hhcmVkLnBlbmRpbmc7XG5cbiAgICAgICAgaWYgKHBlbmRpbmdRdWV1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIEFuIHVwZGF0ZSB3YXMgc2NoZWR1bGVkIGZyb20gaW5zaWRlIGEgcmVkdWNlci4gQWRkIHRoZSBuZXdcbiAgICAgICAgICAvLyBwZW5kaW5nIHVwZGF0ZXMgdG8gdGhlIGVuZCBvZiB0aGUgbGlzdCBhbmQga2VlcCBwcm9jZXNzaW5nLlxuICAgICAgICAgIHZhciBfbGFzdFBlbmRpbmdVcGRhdGUgPSBwZW5kaW5nUXVldWU7IC8vIEludGVudGlvbmFsbHkgdW5zb3VuZC4gUGVuZGluZyB1cGRhdGVzIGZvcm0gYSBjaXJjdWxhciBsaXN0LCBidXQgd2VcbiAgICAgICAgICAvLyB1bnJhdmVsIHRoZW0gd2hlbiB0cmFuc2ZlcnJpbmcgdGhlbSB0byB0aGUgYmFzZSBxdWV1ZS5cblxuICAgICAgICAgIHZhciBfZmlyc3RQZW5kaW5nVXBkYXRlID0gX2xhc3RQZW5kaW5nVXBkYXRlLm5leHQ7XG4gICAgICAgICAgX2xhc3RQZW5kaW5nVXBkYXRlLm5leHQgPSBudWxsO1xuICAgICAgICAgIHVwZGF0ZSA9IF9maXJzdFBlbmRpbmdVcGRhdGU7XG4gICAgICAgICAgcXVldWUubGFzdEJhc2VVcGRhdGUgPSBfbGFzdFBlbmRpbmdVcGRhdGU7XG4gICAgICAgICAgcXVldWUuc2hhcmVkLnBlbmRpbmcgPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSB3aGlsZSAodHJ1ZSk7XG5cbiAgICBpZiAobmV3TGFzdEJhc2VVcGRhdGUgPT09IG51bGwpIHtcbiAgICAgIG5ld0Jhc2VTdGF0ZSA9IG5ld1N0YXRlO1xuICAgIH1cblxuICAgIHF1ZXVlLmJhc2VTdGF0ZSA9IG5ld0Jhc2VTdGF0ZTtcbiAgICBxdWV1ZS5maXJzdEJhc2VVcGRhdGUgPSBuZXdGaXJzdEJhc2VVcGRhdGU7XG4gICAgcXVldWUubGFzdEJhc2VVcGRhdGUgPSBuZXdMYXN0QmFzZVVwZGF0ZTsgLy8gU2V0IHRoZSByZW1haW5pbmcgZXhwaXJhdGlvbiB0aW1lIHRvIGJlIHdoYXRldmVyIGlzIHJlbWFpbmluZyBpbiB0aGUgcXVldWUuXG4gICAgLy8gVGhpcyBzaG91bGQgYmUgZmluZSBiZWNhdXNlIHRoZSBvbmx5IHR3byBvdGhlciB0aGluZ3MgdGhhdCBjb250cmlidXRlIHRvXG4gICAgLy8gZXhwaXJhdGlvbiB0aW1lIGFyZSBwcm9wcyBhbmQgY29udGV4dC4gV2UncmUgYWxyZWFkeSBpbiB0aGUgbWlkZGxlIG9mIHRoZVxuICAgIC8vIGJlZ2luIHBoYXNlIGJ5IHRoZSB0aW1lIHdlIHN0YXJ0IHByb2Nlc3NpbmcgdGhlIHF1ZXVlLCBzbyB3ZSd2ZSBhbHJlYWR5XG4gICAgLy8gZGVhbHQgd2l0aCB0aGUgcHJvcHMuIENvbnRleHQgaW4gY29tcG9uZW50cyB0aGF0IHNwZWNpZnlcbiAgICAvLyBzaG91bGRDb21wb25lbnRVcGRhdGUgaXMgdHJpY2t5OyBidXQgd2UnbGwgaGF2ZSB0byBhY2NvdW50IGZvclxuICAgIC8vIHRoYXQgcmVnYXJkbGVzcy5cblxuICAgIG1hcmtTa2lwcGVkVXBkYXRlTGFuZXMobmV3TGFuZXMpO1xuICAgIHdvcmtJblByb2dyZXNzLmxhbmVzID0gbmV3TGFuZXM7XG4gICAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IG5ld1N0YXRlO1xuICB9XG5cbiAge1xuICAgIGN1cnJlbnRseVByb2Nlc3NpbmdRdWV1ZSA9IG51bGw7XG4gIH1cbn1cblxuZnVuY3Rpb24gY2FsbENhbGxiYWNrKGNhbGxiYWNrLCBjb250ZXh0KSB7XG4gIGlmICghKHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykpIHtcbiAgICB7XG4gICAgICB0aHJvdyBFcnJvciggXCJJbnZhbGlkIGFyZ3VtZW50IHBhc3NlZCBhcyBjYWxsYmFjay4gRXhwZWN0ZWQgYSBmdW5jdGlvbi4gSW5zdGVhZCByZWNlaXZlZDogXCIgKyBjYWxsYmFjayApO1xuICAgIH1cbiAgfVxuXG4gIGNhbGxiYWNrLmNhbGwoY29udGV4dCk7XG59XG5cbmZ1bmN0aW9uIHJlc2V0SGFzRm9yY2VVcGRhdGVCZWZvcmVQcm9jZXNzaW5nKCkge1xuICBoYXNGb3JjZVVwZGF0ZSA9IGZhbHNlO1xufVxuZnVuY3Rpb24gY2hlY2tIYXNGb3JjZVVwZGF0ZUFmdGVyUHJvY2Vzc2luZygpIHtcbiAgcmV0dXJuIGhhc0ZvcmNlVXBkYXRlO1xufVxuZnVuY3Rpb24gY29tbWl0VXBkYXRlUXVldWUoZmluaXNoZWRXb3JrLCBmaW5pc2hlZFF1ZXVlLCBpbnN0YW5jZSkge1xuICAvLyBDb21taXQgdGhlIGVmZmVjdHNcbiAgdmFyIGVmZmVjdHMgPSBmaW5pc2hlZFF1ZXVlLmVmZmVjdHM7XG4gIGZpbmlzaGVkUXVldWUuZWZmZWN0cyA9IG51bGw7XG5cbiAgaWYgKGVmZmVjdHMgIT09IG51bGwpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVmZmVjdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBlZmZlY3QgPSBlZmZlY3RzW2ldO1xuICAgICAgdmFyIGNhbGxiYWNrID0gZWZmZWN0LmNhbGxiYWNrO1xuXG4gICAgICBpZiAoY2FsbGJhY2sgIT09IG51bGwpIHtcbiAgICAgICAgZWZmZWN0LmNhbGxiYWNrID0gbnVsbDtcbiAgICAgICAgY2FsbENhbGxiYWNrKGNhbGxiYWNrLCBpbnN0YW5jZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbnZhciBmYWtlSW50ZXJuYWxJbnN0YW5jZSA9IHt9O1xudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5OyAvLyBSZWFjdC5Db21wb25lbnQgdXNlcyBhIHNoYXJlZCBmcm96ZW4gb2JqZWN0IGJ5IGRlZmF1bHQuXG4vLyBXZSdsbCB1c2UgaXQgdG8gZGV0ZXJtaW5lIHdoZXRoZXIgd2UgbmVlZCB0byBpbml0aWFsaXplIGxlZ2FjeSByZWZzLlxuXG52YXIgZW1wdHlSZWZzT2JqZWN0ID0gbmV3IFJlYWN0LkNvbXBvbmVudCgpLnJlZnM7XG52YXIgZGlkV2FybkFib3V0U3RhdGVBc3NpZ25tZW50Rm9yQ29tcG9uZW50O1xudmFyIGRpZFdhcm5BYm91dFVuaW5pdGlhbGl6ZWRTdGF0ZTtcbnZhciBkaWRXYXJuQWJvdXRHZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZVdpdGhvdXREaWRVcGRhdGU7XG52YXIgZGlkV2FybkFib3V0TGVnYWN5TGlmZWN5Y2xlc0FuZERlcml2ZWRTdGF0ZTtcbnZhciBkaWRXYXJuQWJvdXRVbmRlZmluZWREZXJpdmVkU3RhdGU7XG52YXIgd2Fybk9uVW5kZWZpbmVkRGVyaXZlZFN0YXRlO1xudmFyIHdhcm5PbkludmFsaWRDYWxsYmFjaztcbnZhciBkaWRXYXJuQWJvdXREaXJlY3RseUFzc2lnbmluZ1Byb3BzVG9TdGF0ZTtcbnZhciBkaWRXYXJuQWJvdXRDb250ZXh0VHlwZUFuZENvbnRleHRUeXBlcztcbnZhciBkaWRXYXJuQWJvdXRJbnZhbGlkYXRlQ29udGV4dFR5cGU7XG5cbntcbiAgZGlkV2FybkFib3V0U3RhdGVBc3NpZ25tZW50Rm9yQ29tcG9uZW50ID0gbmV3IFNldCgpO1xuICBkaWRXYXJuQWJvdXRVbmluaXRpYWxpemVkU3RhdGUgPSBuZXcgU2V0KCk7XG4gIGRpZFdhcm5BYm91dEdldFNuYXBzaG90QmVmb3JlVXBkYXRlV2l0aG91dERpZFVwZGF0ZSA9IG5ldyBTZXQoKTtcbiAgZGlkV2FybkFib3V0TGVnYWN5TGlmZWN5Y2xlc0FuZERlcml2ZWRTdGF0ZSA9IG5ldyBTZXQoKTtcbiAgZGlkV2FybkFib3V0RGlyZWN0bHlBc3NpZ25pbmdQcm9wc1RvU3RhdGUgPSBuZXcgU2V0KCk7XG4gIGRpZFdhcm5BYm91dFVuZGVmaW5lZERlcml2ZWRTdGF0ZSA9IG5ldyBTZXQoKTtcbiAgZGlkV2FybkFib3V0Q29udGV4dFR5cGVBbmRDb250ZXh0VHlwZXMgPSBuZXcgU2V0KCk7XG4gIGRpZFdhcm5BYm91dEludmFsaWRhdGVDb250ZXh0VHlwZSA9IG5ldyBTZXQoKTtcbiAgdmFyIGRpZFdhcm5PbkludmFsaWRDYWxsYmFjayA9IG5ldyBTZXQoKTtcblxuICB3YXJuT25JbnZhbGlkQ2FsbGJhY2sgPSBmdW5jdGlvbiAoY2FsbGJhY2ssIGNhbGxlck5hbWUpIHtcbiAgICBpZiAoY2FsbGJhY2sgPT09IG51bGwgfHwgdHlwZW9mIGNhbGxiYWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGtleSA9IGNhbGxlck5hbWUgKyAnXycgKyBjYWxsYmFjaztcblxuICAgIGlmICghZGlkV2Fybk9uSW52YWxpZENhbGxiYWNrLmhhcyhrZXkpKSB7XG4gICAgICBkaWRXYXJuT25JbnZhbGlkQ2FsbGJhY2suYWRkKGtleSk7XG5cbiAgICAgIGVycm9yKCclcyguLi4pOiBFeHBlY3RlZCB0aGUgbGFzdCBvcHRpb25hbCBgY2FsbGJhY2tgIGFyZ3VtZW50IHRvIGJlIGEgJyArICdmdW5jdGlvbi4gSW5zdGVhZCByZWNlaXZlZDogJXMuJywgY2FsbGVyTmFtZSwgY2FsbGJhY2spO1xuICAgIH1cbiAgfTtcblxuICB3YXJuT25VbmRlZmluZWREZXJpdmVkU3RhdGUgPSBmdW5jdGlvbiAodHlwZSwgcGFydGlhbFN0YXRlKSB7XG4gICAgaWYgKHBhcnRpYWxTdGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWUodHlwZSkgfHwgJ0NvbXBvbmVudCc7XG5cbiAgICAgIGlmICghZGlkV2FybkFib3V0VW5kZWZpbmVkRGVyaXZlZFN0YXRlLmhhcyhjb21wb25lbnROYW1lKSkge1xuICAgICAgICBkaWRXYXJuQWJvdXRVbmRlZmluZWREZXJpdmVkU3RhdGUuYWRkKGNvbXBvbmVudE5hbWUpO1xuXG4gICAgICAgIGVycm9yKCclcy5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMoKTogQSB2YWxpZCBzdGF0ZSBvYmplY3QgKG9yIG51bGwpIG11c3QgYmUgcmV0dXJuZWQuICcgKyAnWW91IGhhdmUgcmV0dXJuZWQgdW5kZWZpbmVkLicsIGNvbXBvbmVudE5hbWUpO1xuICAgICAgfVxuICAgIH1cbiAgfTsgLy8gVGhpcyBpcyBzbyBncm9zcyBidXQgaXQncyBhdCBsZWFzdCBub24tY3JpdGljYWwgYW5kIGNhbiBiZSByZW1vdmVkIGlmXG4gIC8vIGl0IGNhdXNlcyBwcm9ibGVtcy4gVGhpcyBpcyBtZWFudCB0byBnaXZlIGEgbmljZXIgZXJyb3IgbWVzc2FnZSBmb3JcbiAgLy8gUmVhY3RET00xNS51bnN0YWJsZV9yZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lcihyZWFjdERPTTE2Q29tcG9uZW50LFxuICAvLyAuLi4pKSB3aGljaCBvdGhlcndpc2UgdGhyb3dzIGEgXCJfcHJvY2Vzc0NoaWxkQ29udGV4dCBpcyBub3QgYSBmdW5jdGlvblwiXG4gIC8vIGV4Y2VwdGlvbi5cblxuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShmYWtlSW50ZXJuYWxJbnN0YW5jZSwgJ19wcm9jZXNzQ2hpbGRDb250ZXh0Jywge1xuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB7XG4gICAgICAgIHtcbiAgICAgICAgICB0aHJvdyBFcnJvciggXCJfcHJvY2Vzc0NoaWxkQ29udGV4dCBpcyBub3QgYXZhaWxhYmxlIGluIFJlYWN0IDE2Ky4gVGhpcyBsaWtlbHkgbWVhbnMgeW91IGhhdmUgbXVsdGlwbGUgY29waWVzIG9mIFJlYWN0IGFuZCBhcmUgYXR0ZW1wdGluZyB0byBuZXN0IGEgUmVhY3QgMTUgdHJlZSBpbnNpZGUgYSBSZWFjdCAxNiB0cmVlIHVzaW5nIHVuc3RhYmxlX3JlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyLCB3aGljaCBpc24ndCBzdXBwb3J0ZWQuIFRyeSB0byBtYWtlIHN1cmUgeW91IGhhdmUgb25seSBvbmUgY29weSBvZiBSZWFjdCAoYW5kIGlkZWFsbHksIHN3aXRjaCB0byBSZWFjdERPTS5jcmVhdGVQb3J0YWwpLlwiICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICBPYmplY3QuZnJlZXplKGZha2VJbnRlcm5hbEluc3RhbmNlKTtcbn1cblxuZnVuY3Rpb24gYXBwbHlEZXJpdmVkU3RhdGVGcm9tUHJvcHMod29ya0luUHJvZ3Jlc3MsIGN0b3IsIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcywgbmV4dFByb3BzKSB7XG4gIHZhciBwcmV2U3RhdGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuXG4gIHtcbiAgICBpZiAoIHdvcmtJblByb2dyZXNzLm1vZGUgJiBTdHJpY3RNb2RlKSB7XG4gICAgICBkaXNhYmxlTG9ncygpO1xuXG4gICAgICB0cnkge1xuICAgICAgICAvLyBJbnZva2UgdGhlIGZ1bmN0aW9uIGFuIGV4dHJhIHRpbWUgdG8gaGVscCBkZXRlY3Qgc2lkZS1lZmZlY3RzLlxuICAgICAgICBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMobmV4dFByb3BzLCBwcmV2U3RhdGUpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgcmVlbmFibGVMb2dzKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIHBhcnRpYWxTdGF0ZSA9IGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyhuZXh0UHJvcHMsIHByZXZTdGF0ZSk7XG5cbiAge1xuICAgIHdhcm5PblVuZGVmaW5lZERlcml2ZWRTdGF0ZShjdG9yLCBwYXJ0aWFsU3RhdGUpO1xuICB9IC8vIE1lcmdlIHRoZSBwYXJ0aWFsIHN0YXRlIGFuZCB0aGUgcHJldmlvdXMgc3RhdGUuXG5cblxuICB2YXIgbWVtb2l6ZWRTdGF0ZSA9IHBhcnRpYWxTdGF0ZSA9PT0gbnVsbCB8fCBwYXJ0aWFsU3RhdGUgPT09IHVuZGVmaW5lZCA/IHByZXZTdGF0ZSA6IF9hc3NpZ24oe30sIHByZXZTdGF0ZSwgcGFydGlhbFN0YXRlKTtcbiAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IG1lbW9pemVkU3RhdGU7IC8vIE9uY2UgdGhlIHVwZGF0ZSBxdWV1ZSBpcyBlbXB0eSwgcGVyc2lzdCB0aGUgZGVyaXZlZCBzdGF0ZSBvbnRvIHRoZVxuICAvLyBiYXNlIHN0YXRlLlxuXG4gIGlmICh3b3JrSW5Qcm9ncmVzcy5sYW5lcyA9PT0gTm9MYW5lcykge1xuICAgIC8vIFF1ZXVlIGlzIGFsd2F5cyBub24tbnVsbCBmb3IgY2xhc3Nlc1xuICAgIHZhciB1cGRhdGVRdWV1ZSA9IHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlO1xuICAgIHVwZGF0ZVF1ZXVlLmJhc2VTdGF0ZSA9IG1lbW9pemVkU3RhdGU7XG4gIH1cbn1cbnZhciBjbGFzc0NvbXBvbmVudFVwZGF0ZXIgPSB7XG4gIGlzTW91bnRlZDogaXNNb3VudGVkLFxuICBlbnF1ZXVlU2V0U3RhdGU6IGZ1bmN0aW9uIChpbnN0LCBwYXlsb2FkLCBjYWxsYmFjaykge1xuICAgIHZhciBmaWJlciA9IGdldChpbnN0KTtcbiAgICB2YXIgZXZlbnRUaW1lID0gcmVxdWVzdEV2ZW50VGltZSgpO1xuICAgIHZhciBsYW5lID0gcmVxdWVzdFVwZGF0ZUxhbmUoZmliZXIpO1xuICAgIHZhciB1cGRhdGUgPSBjcmVhdGVVcGRhdGUoZXZlbnRUaW1lLCBsYW5lKTtcbiAgICB1cGRhdGUucGF5bG9hZCA9IHBheWxvYWQ7XG5cbiAgICBpZiAoY2FsbGJhY2sgIT09IHVuZGVmaW5lZCAmJiBjYWxsYmFjayAhPT0gbnVsbCkge1xuICAgICAge1xuICAgICAgICB3YXJuT25JbnZhbGlkQ2FsbGJhY2soY2FsbGJhY2ssICdzZXRTdGF0ZScpO1xuICAgICAgfVxuXG4gICAgICB1cGRhdGUuY2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICB9XG5cbiAgICBlbnF1ZXVlVXBkYXRlKGZpYmVyLCB1cGRhdGUpO1xuICAgIHNjaGVkdWxlVXBkYXRlT25GaWJlcihmaWJlciwgbGFuZSwgZXZlbnRUaW1lKTtcbiAgfSxcbiAgZW5xdWV1ZVJlcGxhY2VTdGF0ZTogZnVuY3Rpb24gKGluc3QsIHBheWxvYWQsIGNhbGxiYWNrKSB7XG4gICAgdmFyIGZpYmVyID0gZ2V0KGluc3QpO1xuICAgIHZhciBldmVudFRpbWUgPSByZXF1ZXN0RXZlbnRUaW1lKCk7XG4gICAgdmFyIGxhbmUgPSByZXF1ZXN0VXBkYXRlTGFuZShmaWJlcik7XG4gICAgdmFyIHVwZGF0ZSA9IGNyZWF0ZVVwZGF0ZShldmVudFRpbWUsIGxhbmUpO1xuICAgIHVwZGF0ZS50YWcgPSBSZXBsYWNlU3RhdGU7XG4gICAgdXBkYXRlLnBheWxvYWQgPSBwYXlsb2FkO1xuXG4gICAgaWYgKGNhbGxiYWNrICE9PSB1bmRlZmluZWQgJiYgY2FsbGJhY2sgIT09IG51bGwpIHtcbiAgICAgIHtcbiAgICAgICAgd2Fybk9uSW52YWxpZENhbGxiYWNrKGNhbGxiYWNrLCAncmVwbGFjZVN0YXRlJyk7XG4gICAgICB9XG5cbiAgICAgIHVwZGF0ZS5jYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgIH1cblxuICAgIGVucXVldWVVcGRhdGUoZmliZXIsIHVwZGF0ZSk7XG4gICAgc2NoZWR1bGVVcGRhdGVPbkZpYmVyKGZpYmVyLCBsYW5lLCBldmVudFRpbWUpO1xuICB9LFxuICBlbnF1ZXVlRm9yY2VVcGRhdGU6IGZ1bmN0aW9uIChpbnN0LCBjYWxsYmFjaykge1xuICAgIHZhciBmaWJlciA9IGdldChpbnN0KTtcbiAgICB2YXIgZXZlbnRUaW1lID0gcmVxdWVzdEV2ZW50VGltZSgpO1xuICAgIHZhciBsYW5lID0gcmVxdWVzdFVwZGF0ZUxhbmUoZmliZXIpO1xuICAgIHZhciB1cGRhdGUgPSBjcmVhdGVVcGRhdGUoZXZlbnRUaW1lLCBsYW5lKTtcbiAgICB1cGRhdGUudGFnID0gRm9yY2VVcGRhdGU7XG5cbiAgICBpZiAoY2FsbGJhY2sgIT09IHVuZGVmaW5lZCAmJiBjYWxsYmFjayAhPT0gbnVsbCkge1xuICAgICAge1xuICAgICAgICB3YXJuT25JbnZhbGlkQ2FsbGJhY2soY2FsbGJhY2ssICdmb3JjZVVwZGF0ZScpO1xuICAgICAgfVxuXG4gICAgICB1cGRhdGUuY2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICB9XG5cbiAgICBlbnF1ZXVlVXBkYXRlKGZpYmVyLCB1cGRhdGUpO1xuICAgIHNjaGVkdWxlVXBkYXRlT25GaWJlcihmaWJlciwgbGFuZSwgZXZlbnRUaW1lKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gY2hlY2tTaG91bGRDb21wb25lbnRVcGRhdGUod29ya0luUHJvZ3Jlc3MsIGN0b3IsIG9sZFByb3BzLCBuZXdQcm9wcywgb2xkU3RhdGUsIG5ld1N0YXRlLCBuZXh0Q29udGV4dCkge1xuICB2YXIgaW5zdGFuY2UgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG5cbiAgaWYgKHR5cGVvZiBpbnN0YW5jZS5zaG91bGRDb21wb25lbnRVcGRhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICB7XG4gICAgICBpZiAoIHdvcmtJblByb2dyZXNzLm1vZGUgJiBTdHJpY3RNb2RlKSB7XG4gICAgICAgIGRpc2FibGVMb2dzKCk7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyBJbnZva2UgdGhlIGZ1bmN0aW9uIGFuIGV4dHJhIHRpbWUgdG8gaGVscCBkZXRlY3Qgc2lkZS1lZmZlY3RzLlxuICAgICAgICAgIGluc3RhbmNlLnNob3VsZENvbXBvbmVudFVwZGF0ZShuZXdQcm9wcywgbmV3U3RhdGUsIG5leHRDb250ZXh0KTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICByZWVuYWJsZUxvZ3MoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBzaG91bGRVcGRhdGUgPSBpbnN0YW5jZS5zaG91bGRDb21wb25lbnRVcGRhdGUobmV3UHJvcHMsIG5ld1N0YXRlLCBuZXh0Q29udGV4dCk7XG5cbiAgICB7XG4gICAgICBpZiAoc2hvdWxkVXBkYXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZXJyb3IoJyVzLnNob3VsZENvbXBvbmVudFVwZGF0ZSgpOiBSZXR1cm5lZCB1bmRlZmluZWQgaW5zdGVhZCBvZiBhICcgKyAnYm9vbGVhbiB2YWx1ZS4gTWFrZSBzdXJlIHRvIHJldHVybiB0cnVlIG9yIGZhbHNlLicsIGdldENvbXBvbmVudE5hbWUoY3RvcikgfHwgJ0NvbXBvbmVudCcpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBzaG91bGRVcGRhdGU7XG4gIH1cblxuICBpZiAoY3Rvci5wcm90b3R5cGUgJiYgY3Rvci5wcm90b3R5cGUuaXNQdXJlUmVhY3RDb21wb25lbnQpIHtcbiAgICByZXR1cm4gIXNoYWxsb3dFcXVhbChvbGRQcm9wcywgbmV3UHJvcHMpIHx8ICFzaGFsbG93RXF1YWwob2xkU3RhdGUsIG5ld1N0YXRlKTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBjaGVja0NsYXNzSW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MsIGN0b3IsIG5ld1Byb3BzKSB7XG4gIHZhciBpbnN0YW5jZSA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcblxuICB7XG4gICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lKGN0b3IpIHx8ICdDb21wb25lbnQnO1xuICAgIHZhciByZW5kZXJQcmVzZW50ID0gaW5zdGFuY2UucmVuZGVyO1xuXG4gICAgaWYgKCFyZW5kZXJQcmVzZW50KSB7XG4gICAgICBpZiAoY3Rvci5wcm90b3R5cGUgJiYgdHlwZW9mIGN0b3IucHJvdG90eXBlLnJlbmRlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBlcnJvcignJXMoLi4uKTogTm8gYHJlbmRlcmAgbWV0aG9kIGZvdW5kIG9uIHRoZSByZXR1cm5lZCBjb21wb25lbnQgJyArICdpbnN0YW5jZTogZGlkIHlvdSBhY2NpZGVudGFsbHkgcmV0dXJuIGFuIG9iamVjdCBmcm9tIHRoZSBjb25zdHJ1Y3Rvcj8nLCBuYW1lKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVycm9yKCclcyguLi4pOiBObyBgcmVuZGVyYCBtZXRob2QgZm91bmQgb24gdGhlIHJldHVybmVkIGNvbXBvbmVudCAnICsgJ2luc3RhbmNlOiB5b3UgbWF5IGhhdmUgZm9yZ290dGVuIHRvIGRlZmluZSBgcmVuZGVyYC4nLCBuYW1lKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaW5zdGFuY2UuZ2V0SW5pdGlhbFN0YXRlICYmICFpbnN0YW5jZS5nZXRJbml0aWFsU3RhdGUuaXNSZWFjdENsYXNzQXBwcm92ZWQgJiYgIWluc3RhbmNlLnN0YXRlKSB7XG4gICAgICBlcnJvcignZ2V0SW5pdGlhbFN0YXRlIHdhcyBkZWZpbmVkIG9uICVzLCBhIHBsYWluIEphdmFTY3JpcHQgY2xhc3MuICcgKyAnVGhpcyBpcyBvbmx5IHN1cHBvcnRlZCBmb3IgY2xhc3NlcyBjcmVhdGVkIHVzaW5nIFJlYWN0LmNyZWF0ZUNsYXNzLiAnICsgJ0RpZCB5b3UgbWVhbiB0byBkZWZpbmUgYSBzdGF0ZSBwcm9wZXJ0eSBpbnN0ZWFkPycsIG5hbWUpO1xuICAgIH1cblxuICAgIGlmIChpbnN0YW5jZS5nZXREZWZhdWx0UHJvcHMgJiYgIWluc3RhbmNlLmdldERlZmF1bHRQcm9wcy5pc1JlYWN0Q2xhc3NBcHByb3ZlZCkge1xuICAgICAgZXJyb3IoJ2dldERlZmF1bHRQcm9wcyB3YXMgZGVmaW5lZCBvbiAlcywgYSBwbGFpbiBKYXZhU2NyaXB0IGNsYXNzLiAnICsgJ1RoaXMgaXMgb25seSBzdXBwb3J0ZWQgZm9yIGNsYXNzZXMgY3JlYXRlZCB1c2luZyBSZWFjdC5jcmVhdGVDbGFzcy4gJyArICdVc2UgYSBzdGF0aWMgcHJvcGVydHkgdG8gZGVmaW5lIGRlZmF1bHRQcm9wcyBpbnN0ZWFkLicsIG5hbWUpO1xuICAgIH1cblxuICAgIGlmIChpbnN0YW5jZS5wcm9wVHlwZXMpIHtcbiAgICAgIGVycm9yKCdwcm9wVHlwZXMgd2FzIGRlZmluZWQgYXMgYW4gaW5zdGFuY2UgcHJvcGVydHkgb24gJXMuIFVzZSBhIHN0YXRpYyAnICsgJ3Byb3BlcnR5IHRvIGRlZmluZSBwcm9wVHlwZXMgaW5zdGVhZC4nLCBuYW1lKTtcbiAgICB9XG5cbiAgICBpZiAoaW5zdGFuY2UuY29udGV4dFR5cGUpIHtcbiAgICAgIGVycm9yKCdjb250ZXh0VHlwZSB3YXMgZGVmaW5lZCBhcyBhbiBpbnN0YW5jZSBwcm9wZXJ0eSBvbiAlcy4gVXNlIGEgc3RhdGljICcgKyAncHJvcGVydHkgdG8gZGVmaW5lIGNvbnRleHRUeXBlIGluc3RlYWQuJywgbmFtZSk7XG4gICAgfVxuXG4gICAge1xuICAgICAgaWYgKGluc3RhbmNlLmNvbnRleHRUeXBlcykge1xuICAgICAgICBlcnJvcignY29udGV4dFR5cGVzIHdhcyBkZWZpbmVkIGFzIGFuIGluc3RhbmNlIHByb3BlcnR5IG9uICVzLiBVc2UgYSBzdGF0aWMgJyArICdwcm9wZXJ0eSB0byBkZWZpbmUgY29udGV4dFR5cGVzIGluc3RlYWQuJywgbmFtZSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChjdG9yLmNvbnRleHRUeXBlICYmIGN0b3IuY29udGV4dFR5cGVzICYmICFkaWRXYXJuQWJvdXRDb250ZXh0VHlwZUFuZENvbnRleHRUeXBlcy5oYXMoY3RvcikpIHtcbiAgICAgICAgZGlkV2FybkFib3V0Q29udGV4dFR5cGVBbmRDb250ZXh0VHlwZXMuYWRkKGN0b3IpO1xuXG4gICAgICAgIGVycm9yKCclcyBkZWNsYXJlcyBib3RoIGNvbnRleHRUeXBlcyBhbmQgY29udGV4dFR5cGUgc3RhdGljIHByb3BlcnRpZXMuICcgKyAnVGhlIGxlZ2FjeSBjb250ZXh0VHlwZXMgcHJvcGVydHkgd2lsbCBiZSBpZ25vcmVkLicsIG5hbWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50U2hvdWxkVXBkYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBlcnJvcignJXMgaGFzIGEgbWV0aG9kIGNhbGxlZCAnICsgJ2NvbXBvbmVudFNob3VsZFVwZGF0ZSgpLiBEaWQgeW91IG1lYW4gc2hvdWxkQ29tcG9uZW50VXBkYXRlKCk/ICcgKyAnVGhlIG5hbWUgaXMgcGhyYXNlZCBhcyBhIHF1ZXN0aW9uIGJlY2F1c2UgdGhlIGZ1bmN0aW9uIGlzICcgKyAnZXhwZWN0ZWQgdG8gcmV0dXJuIGEgdmFsdWUuJywgbmFtZSk7XG4gICAgfVxuXG4gICAgaWYgKGN0b3IucHJvdG90eXBlICYmIGN0b3IucHJvdG90eXBlLmlzUHVyZVJlYWN0Q29tcG9uZW50ICYmIHR5cGVvZiBpbnN0YW5jZS5zaG91bGRDb21wb25lbnRVcGRhdGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBlcnJvcignJXMgaGFzIGEgbWV0aG9kIGNhbGxlZCBzaG91bGRDb21wb25lbnRVcGRhdGUoKS4gJyArICdzaG91bGRDb21wb25lbnRVcGRhdGUgc2hvdWxkIG5vdCBiZSB1c2VkIHdoZW4gZXh0ZW5kaW5nIFJlYWN0LlB1cmVDb21wb25lbnQuICcgKyAnUGxlYXNlIGV4dGVuZCBSZWFjdC5Db21wb25lbnQgaWYgc2hvdWxkQ29tcG9uZW50VXBkYXRlIGlzIHVzZWQuJywgZ2V0Q29tcG9uZW50TmFtZShjdG9yKSB8fCAnQSBwdXJlIGNvbXBvbmVudCcpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50RGlkVW5tb3VudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgZXJyb3IoJyVzIGhhcyBhIG1ldGhvZCBjYWxsZWQgJyArICdjb21wb25lbnREaWRVbm1vdW50KCkuIEJ1dCB0aGVyZSBpcyBubyBzdWNoIGxpZmVjeWNsZSBtZXRob2QuICcgKyAnRGlkIHlvdSBtZWFuIGNvbXBvbmVudFdpbGxVbm1vdW50KCk/JywgbmFtZSk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnREaWRSZWNlaXZlUHJvcHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGVycm9yKCclcyBoYXMgYSBtZXRob2QgY2FsbGVkICcgKyAnY29tcG9uZW50RGlkUmVjZWl2ZVByb3BzKCkuIEJ1dCB0aGVyZSBpcyBubyBzdWNoIGxpZmVjeWNsZSBtZXRob2QuICcgKyAnSWYgeW91IG1lYW50IHRvIHVwZGF0ZSB0aGUgc3RhdGUgaW4gcmVzcG9uc2UgdG8gY2hhbmdpbmcgcHJvcHMsICcgKyAndXNlIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMoKS4gSWYgeW91IG1lYW50IHRvIGZldGNoIGRhdGEgb3IgJyArICdydW4gc2lkZS1lZmZlY3RzIG9yIG11dGF0aW9ucyBhZnRlciBSZWFjdCBoYXMgdXBkYXRlZCB0aGUgVUksIHVzZSBjb21wb25lbnREaWRVcGRhdGUoKS4nLCBuYW1lKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxSZWNpZXZlUHJvcHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGVycm9yKCclcyBoYXMgYSBtZXRob2QgY2FsbGVkICcgKyAnY29tcG9uZW50V2lsbFJlY2lldmVQcm9wcygpLiBEaWQgeW91IG1lYW4gY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcygpPycsIG5hbWUpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNpZXZlUHJvcHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGVycm9yKCclcyBoYXMgYSBtZXRob2QgY2FsbGVkICcgKyAnVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNpZXZlUHJvcHMoKS4gRGlkIHlvdSBtZWFuIFVOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKCk/JywgbmFtZSk7XG4gICAgfVxuXG4gICAgdmFyIGhhc011dGF0ZWRQcm9wcyA9IGluc3RhbmNlLnByb3BzICE9PSBuZXdQcm9wcztcblxuICAgIGlmIChpbnN0YW5jZS5wcm9wcyAhPT0gdW5kZWZpbmVkICYmIGhhc011dGF0ZWRQcm9wcykge1xuICAgICAgZXJyb3IoJyVzKC4uLik6IFdoZW4gY2FsbGluZyBzdXBlcigpIGluIGAlc2AsIG1ha2Ugc3VyZSB0byBwYXNzICcgKyBcInVwIHRoZSBzYW1lIHByb3BzIHRoYXQgeW91ciBjb21wb25lbnQncyBjb25zdHJ1Y3RvciB3YXMgcGFzc2VkLlwiLCBuYW1lLCBuYW1lKTtcbiAgICB9XG5cbiAgICBpZiAoaW5zdGFuY2UuZGVmYXVsdFByb3BzKSB7XG4gICAgICBlcnJvcignU2V0dGluZyBkZWZhdWx0UHJvcHMgYXMgYW4gaW5zdGFuY2UgcHJvcGVydHkgb24gJXMgaXMgbm90IHN1cHBvcnRlZCBhbmQgd2lsbCBiZSBpZ25vcmVkLicgKyAnIEluc3RlYWQsIGRlZmluZSBkZWZhdWx0UHJvcHMgYXMgYSBzdGF0aWMgcHJvcGVydHkgb24gJXMuJywgbmFtZSwgbmFtZSk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5nZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50RGlkVXBkYXRlICE9PSAnZnVuY3Rpb24nICYmICFkaWRXYXJuQWJvdXRHZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZVdpdGhvdXREaWRVcGRhdGUuaGFzKGN0b3IpKSB7XG4gICAgICBkaWRXYXJuQWJvdXRHZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZVdpdGhvdXREaWRVcGRhdGUuYWRkKGN0b3IpO1xuXG4gICAgICBlcnJvcignJXM6IGdldFNuYXBzaG90QmVmb3JlVXBkYXRlKCkgc2hvdWxkIGJlIHVzZWQgd2l0aCBjb21wb25lbnREaWRVcGRhdGUoKS4gJyArICdUaGlzIGNvbXBvbmVudCBkZWZpbmVzIGdldFNuYXBzaG90QmVmb3JlVXBkYXRlKCkgb25seS4nLCBnZXRDb21wb25lbnROYW1lKGN0b3IpKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGluc3RhbmNlLmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgZXJyb3IoJyVzOiBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMoKSBpcyBkZWZpbmVkIGFzIGFuIGluc3RhbmNlIG1ldGhvZCAnICsgJ2FuZCB3aWxsIGJlIGlnbm9yZWQuIEluc3RlYWQsIGRlY2xhcmUgaXQgYXMgYSBzdGF0aWMgbWV0aG9kLicsIG5hbWUpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBlcnJvcignJXM6IGdldERlcml2ZWRTdGF0ZUZyb21FcnJvcigpIGlzIGRlZmluZWQgYXMgYW4gaW5zdGFuY2UgbWV0aG9kICcgKyAnYW5kIHdpbGwgYmUgaWdub3JlZC4gSW5zdGVhZCwgZGVjbGFyZSBpdCBhcyBhIHN0YXRpYyBtZXRob2QuJywgbmFtZSk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBjdG9yLmdldFNuYXBzaG90QmVmb3JlVXBkYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBlcnJvcignJXM6IGdldFNuYXBzaG90QmVmb3JlVXBkYXRlKCkgaXMgZGVmaW5lZCBhcyBhIHN0YXRpYyBtZXRob2QgJyArICdhbmQgd2lsbCBiZSBpZ25vcmVkLiBJbnN0ZWFkLCBkZWNsYXJlIGl0IGFzIGFuIGluc3RhbmNlIG1ldGhvZC4nLCBuYW1lKTtcbiAgICB9XG5cbiAgICB2YXIgX3N0YXRlID0gaW5zdGFuY2Uuc3RhdGU7XG5cbiAgICBpZiAoX3N0YXRlICYmICh0eXBlb2YgX3N0YXRlICE9PSAnb2JqZWN0JyB8fCBpc0FycmF5KF9zdGF0ZSkpKSB7XG4gICAgICBlcnJvcignJXMuc3RhdGU6IG11c3QgYmUgc2V0IHRvIGFuIG9iamVjdCBvciBudWxsJywgbmFtZSk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5nZXRDaGlsZENvbnRleHQgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGN0b3IuY2hpbGRDb250ZXh0VHlwZXMgIT09ICdvYmplY3QnKSB7XG4gICAgICBlcnJvcignJXMuZ2V0Q2hpbGRDb250ZXh0KCk6IGNoaWxkQ29udGV4dFR5cGVzIG11c3QgYmUgZGVmaW5lZCBpbiBvcmRlciB0byAnICsgJ3VzZSBnZXRDaGlsZENvbnRleHQoKS4nLCBuYW1lKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gYWRvcHRDbGFzc0luc3RhbmNlKHdvcmtJblByb2dyZXNzLCBpbnN0YW5jZSkge1xuICBpbnN0YW5jZS51cGRhdGVyID0gY2xhc3NDb21wb25lbnRVcGRhdGVyO1xuICB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUgPSBpbnN0YW5jZTsgLy8gVGhlIGluc3RhbmNlIG5lZWRzIGFjY2VzcyB0byB0aGUgZmliZXIgc28gdGhhdCBpdCBjYW4gc2NoZWR1bGUgdXBkYXRlc1xuXG4gIHNldChpbnN0YW5jZSwgd29ya0luUHJvZ3Jlc3MpO1xuXG4gIHtcbiAgICBpbnN0YW5jZS5fcmVhY3RJbnRlcm5hbEluc3RhbmNlID0gZmFrZUludGVybmFsSW5zdGFuY2U7XG4gIH1cbn1cblxuZnVuY3Rpb24gY29uc3RydWN0Q2xhc3NJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcywgY3RvciwgcHJvcHMpIHtcbiAgdmFyIGlzTGVnYWN5Q29udGV4dENvbnN1bWVyID0gZmFsc2U7XG4gIHZhciB1bm1hc2tlZENvbnRleHQgPSBlbXB0eUNvbnRleHRPYmplY3Q7XG4gIHZhciBjb250ZXh0ID0gZW1wdHlDb250ZXh0T2JqZWN0O1xuICB2YXIgY29udGV4dFR5cGUgPSBjdG9yLmNvbnRleHRUeXBlO1xuXG4gIHtcbiAgICBpZiAoJ2NvbnRleHRUeXBlJyBpbiBjdG9yKSB7XG4gICAgICB2YXIgaXNWYWxpZCA9IC8vIEFsbG93IG51bGwgZm9yIGNvbmRpdGlvbmFsIGRlY2xhcmF0aW9uXG4gICAgICBjb250ZXh0VHlwZSA9PT0gbnVsbCB8fCBjb250ZXh0VHlwZSAhPT0gdW5kZWZpbmVkICYmIGNvbnRleHRUeXBlLiQkdHlwZW9mID09PSBSRUFDVF9DT05URVhUX1RZUEUgJiYgY29udGV4dFR5cGUuX2NvbnRleHQgPT09IHVuZGVmaW5lZDsgLy8gTm90IGEgPENvbnRleHQuQ29uc3VtZXI+XG5cbiAgICAgIGlmICghaXNWYWxpZCAmJiAhZGlkV2FybkFib3V0SW52YWxpZGF0ZUNvbnRleHRUeXBlLmhhcyhjdG9yKSkge1xuICAgICAgICBkaWRXYXJuQWJvdXRJbnZhbGlkYXRlQ29udGV4dFR5cGUuYWRkKGN0b3IpO1xuICAgICAgICB2YXIgYWRkZW5kdW0gPSAnJztcblxuICAgICAgICBpZiAoY29udGV4dFR5cGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGFkZGVuZHVtID0gJyBIb3dldmVyLCBpdCBpcyBzZXQgdG8gdW5kZWZpbmVkLiAnICsgJ1RoaXMgY2FuIGJlIGNhdXNlZCBieSBhIHR5cG8gb3IgYnkgbWl4aW5nIHVwIG5hbWVkIGFuZCBkZWZhdWx0IGltcG9ydHMuICcgKyAnVGhpcyBjYW4gYWxzbyBoYXBwZW4gZHVlIHRvIGEgY2lyY3VsYXIgZGVwZW5kZW5jeSwgc28gJyArICd0cnkgbW92aW5nIHRoZSBjcmVhdGVDb250ZXh0KCkgY2FsbCB0byBhIHNlcGFyYXRlIGZpbGUuJztcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgY29udGV4dFR5cGUgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgYWRkZW5kdW0gPSAnIEhvd2V2ZXIsIGl0IGlzIHNldCB0byBhICcgKyB0eXBlb2YgY29udGV4dFR5cGUgKyAnLic7XG4gICAgICAgIH0gZWxzZSBpZiAoY29udGV4dFR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX1BST1ZJREVSX1RZUEUpIHtcbiAgICAgICAgICBhZGRlbmR1bSA9ICcgRGlkIHlvdSBhY2NpZGVudGFsbHkgcGFzcyB0aGUgQ29udGV4dC5Qcm92aWRlciBpbnN0ZWFkPyc7XG4gICAgICAgIH0gZWxzZSBpZiAoY29udGV4dFR5cGUuX2NvbnRleHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIC8vIDxDb250ZXh0LkNvbnN1bWVyPlxuICAgICAgICAgIGFkZGVuZHVtID0gJyBEaWQgeW91IGFjY2lkZW50YWxseSBwYXNzIHRoZSBDb250ZXh0LkNvbnN1bWVyIGluc3RlYWQ/JztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhZGRlbmR1bSA9ICcgSG93ZXZlciwgaXQgaXMgc2V0IHRvIGFuIG9iamVjdCB3aXRoIGtleXMgeycgKyBPYmplY3Qua2V5cyhjb250ZXh0VHlwZSkuam9pbignLCAnKSArICd9Lic7XG4gICAgICAgIH1cblxuICAgICAgICBlcnJvcignJXMgZGVmaW5lcyBhbiBpbnZhbGlkIGNvbnRleHRUeXBlLiAnICsgJ2NvbnRleHRUeXBlIHNob3VsZCBwb2ludCB0byB0aGUgQ29udGV4dCBvYmplY3QgcmV0dXJuZWQgYnkgUmVhY3QuY3JlYXRlQ29udGV4dCgpLiVzJywgZ2V0Q29tcG9uZW50TmFtZShjdG9yKSB8fCAnQ29tcG9uZW50JywgYWRkZW5kdW0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmICh0eXBlb2YgY29udGV4dFR5cGUgPT09ICdvYmplY3QnICYmIGNvbnRleHRUeXBlICE9PSBudWxsKSB7XG4gICAgY29udGV4dCA9IHJlYWRDb250ZXh0KGNvbnRleHRUeXBlKTtcbiAgfSBlbHNlIHtcbiAgICB1bm1hc2tlZENvbnRleHQgPSBnZXRVbm1hc2tlZENvbnRleHQod29ya0luUHJvZ3Jlc3MsIGN0b3IsIHRydWUpO1xuICAgIHZhciBjb250ZXh0VHlwZXMgPSBjdG9yLmNvbnRleHRUeXBlcztcbiAgICBpc0xlZ2FjeUNvbnRleHRDb25zdW1lciA9IGNvbnRleHRUeXBlcyAhPT0gbnVsbCAmJiBjb250ZXh0VHlwZXMgIT09IHVuZGVmaW5lZDtcbiAgICBjb250ZXh0ID0gaXNMZWdhY3lDb250ZXh0Q29uc3VtZXIgPyBnZXRNYXNrZWRDb250ZXh0KHdvcmtJblByb2dyZXNzLCB1bm1hc2tlZENvbnRleHQpIDogZW1wdHlDb250ZXh0T2JqZWN0O1xuICB9IC8vIEluc3RhbnRpYXRlIHR3aWNlIHRvIGhlbHAgZGV0ZWN0IHNpZGUtZWZmZWN0cy5cblxuXG4gIHtcbiAgICBpZiAoIHdvcmtJblByb2dyZXNzLm1vZGUgJiBTdHJpY3RNb2RlKSB7XG4gICAgICBkaXNhYmxlTG9ncygpO1xuXG4gICAgICB0cnkge1xuICAgICAgICBuZXcgY3Rvcihwcm9wcywgY29udGV4dCk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICByZWVuYWJsZUxvZ3MoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2YXIgaW5zdGFuY2UgPSBuZXcgY3Rvcihwcm9wcywgY29udGV4dCk7XG4gIHZhciBzdGF0ZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBpbnN0YW5jZS5zdGF0ZSAhPT0gbnVsbCAmJiBpbnN0YW5jZS5zdGF0ZSAhPT0gdW5kZWZpbmVkID8gaW5zdGFuY2Uuc3RhdGUgOiBudWxsO1xuICBhZG9wdENsYXNzSW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MsIGluc3RhbmNlKTtcblxuICB7XG4gICAgaWYgKHR5cGVvZiBjdG9yLmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyA9PT0gJ2Z1bmN0aW9uJyAmJiBzdGF0ZSA9PT0gbnVsbCkge1xuICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lKGN0b3IpIHx8ICdDb21wb25lbnQnO1xuXG4gICAgICBpZiAoIWRpZFdhcm5BYm91dFVuaW5pdGlhbGl6ZWRTdGF0ZS5oYXMoY29tcG9uZW50TmFtZSkpIHtcbiAgICAgICAgZGlkV2FybkFib3V0VW5pbml0aWFsaXplZFN0YXRlLmFkZChjb21wb25lbnROYW1lKTtcblxuICAgICAgICBlcnJvcignYCVzYCB1c2VzIGBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHNgIGJ1dCBpdHMgaW5pdGlhbCBzdGF0ZSBpcyAnICsgJyVzLiBUaGlzIGlzIG5vdCByZWNvbW1lbmRlZC4gSW5zdGVhZCwgZGVmaW5lIHRoZSBpbml0aWFsIHN0YXRlIGJ5ICcgKyAnYXNzaWduaW5nIGFuIG9iamVjdCB0byBgdGhpcy5zdGF0ZWAgaW4gdGhlIGNvbnN0cnVjdG9yIG9mIGAlc2AuICcgKyAnVGhpcyBlbnN1cmVzIHRoYXQgYGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wc2AgYXJndW1lbnRzIGhhdmUgYSBjb25zaXN0ZW50IHNoYXBlLicsIGNvbXBvbmVudE5hbWUsIGluc3RhbmNlLnN0YXRlID09PSBudWxsID8gJ251bGwnIDogJ3VuZGVmaW5lZCcsIGNvbXBvbmVudE5hbWUpO1xuICAgICAgfVxuICAgIH0gLy8gSWYgbmV3IGNvbXBvbmVudCBBUElzIGFyZSBkZWZpbmVkLCBcInVuc2FmZVwiIGxpZmVjeWNsZXMgd29uJ3QgYmUgY2FsbGVkLlxuICAgIC8vIFdhcm4gYWJvdXQgdGhlc2UgbGlmZWN5Y2xlcyBpZiB0aGV5IGFyZSBwcmVzZW50LlxuICAgIC8vIERvbid0IHdhcm4gYWJvdXQgcmVhY3QtbGlmZWN5Y2xlcy1jb21wYXQgcG9seWZpbGxlZCBtZXRob2RzIHRob3VnaC5cblxuXG4gICAgaWYgKHR5cGVvZiBjdG9yLmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgaW5zdGFuY2UuZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHZhciBmb3VuZFdpbGxNb3VudE5hbWUgPSBudWxsO1xuICAgICAgdmFyIGZvdW5kV2lsbFJlY2VpdmVQcm9wc05hbWUgPSBudWxsO1xuICAgICAgdmFyIGZvdW5kV2lsbFVwZGF0ZU5hbWUgPSBudWxsO1xuXG4gICAgICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxNb3VudCA9PT0gJ2Z1bmN0aW9uJyAmJiBpbnN0YW5jZS5jb21wb25lbnRXaWxsTW91bnQuX19zdXBwcmVzc0RlcHJlY2F0aW9uV2FybmluZyAhPT0gdHJ1ZSkge1xuICAgICAgICBmb3VuZFdpbGxNb3VudE5hbWUgPSAnY29tcG9uZW50V2lsbE1vdW50JztcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGluc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsTW91bnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgZm91bmRXaWxsTW91bnROYW1lID0gJ1VOU0FGRV9jb21wb25lbnRXaWxsTW91bnQnO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgPT09ICdmdW5jdGlvbicgJiYgaW5zdGFuY2UuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcy5fX3N1cHByZXNzRGVwcmVjYXRpb25XYXJuaW5nICE9PSB0cnVlKSB7XG4gICAgICAgIGZvdW5kV2lsbFJlY2VpdmVQcm9wc05hbWUgPSAnY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyc7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBpbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBmb3VuZFdpbGxSZWNlaXZlUHJvcHNOYW1lID0gJ1VOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzJztcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsVXBkYXRlID09PSAnZnVuY3Rpb24nICYmIGluc3RhbmNlLmNvbXBvbmVudFdpbGxVcGRhdGUuX19zdXBwcmVzc0RlcHJlY2F0aW9uV2FybmluZyAhPT0gdHJ1ZSkge1xuICAgICAgICBmb3VuZFdpbGxVcGRhdGVOYW1lID0gJ2NvbXBvbmVudFdpbGxVcGRhdGUnO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxVcGRhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgZm91bmRXaWxsVXBkYXRlTmFtZSA9ICdVTlNBRkVfY29tcG9uZW50V2lsbFVwZGF0ZSc7XG4gICAgICB9XG5cbiAgICAgIGlmIChmb3VuZFdpbGxNb3VudE5hbWUgIT09IG51bGwgfHwgZm91bmRXaWxsUmVjZWl2ZVByb3BzTmFtZSAhPT0gbnVsbCB8fCBmb3VuZFdpbGxVcGRhdGVOYW1lICE9PSBudWxsKSB7XG4gICAgICAgIHZhciBfY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWUoY3RvcikgfHwgJ0NvbXBvbmVudCc7XG5cbiAgICAgICAgdmFyIG5ld0FwaU5hbWUgPSB0eXBlb2YgY3Rvci5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgPT09ICdmdW5jdGlvbicgPyAnZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzKCknIDogJ2dldFNuYXBzaG90QmVmb3JlVXBkYXRlKCknO1xuXG4gICAgICAgIGlmICghZGlkV2FybkFib3V0TGVnYWN5TGlmZWN5Y2xlc0FuZERlcml2ZWRTdGF0ZS5oYXMoX2NvbXBvbmVudE5hbWUpKSB7XG4gICAgICAgICAgZGlkV2FybkFib3V0TGVnYWN5TGlmZWN5Y2xlc0FuZERlcml2ZWRTdGF0ZS5hZGQoX2NvbXBvbmVudE5hbWUpO1xuXG4gICAgICAgICAgZXJyb3IoJ1Vuc2FmZSBsZWdhY3kgbGlmZWN5Y2xlcyB3aWxsIG5vdCBiZSBjYWxsZWQgZm9yIGNvbXBvbmVudHMgdXNpbmcgbmV3IGNvbXBvbmVudCBBUElzLlxcblxcbicgKyAnJXMgdXNlcyAlcyBidXQgYWxzbyBjb250YWlucyB0aGUgZm9sbG93aW5nIGxlZ2FjeSBsaWZlY3ljbGVzOiVzJXMlc1xcblxcbicgKyAnVGhlIGFib3ZlIGxpZmVjeWNsZXMgc2hvdWxkIGJlIHJlbW92ZWQuIExlYXJuIG1vcmUgYWJvdXQgdGhpcyB3YXJuaW5nIGhlcmU6XFxuJyArICdodHRwczovL3JlYWN0anMub3JnL2xpbmsvdW5zYWZlLWNvbXBvbmVudC1saWZlY3ljbGVzJywgX2NvbXBvbmVudE5hbWUsIG5ld0FwaU5hbWUsIGZvdW5kV2lsbE1vdW50TmFtZSAhPT0gbnVsbCA/IFwiXFxuICBcIiArIGZvdW5kV2lsbE1vdW50TmFtZSA6ICcnLCBmb3VuZFdpbGxSZWNlaXZlUHJvcHNOYW1lICE9PSBudWxsID8gXCJcXG4gIFwiICsgZm91bmRXaWxsUmVjZWl2ZVByb3BzTmFtZSA6ICcnLCBmb3VuZFdpbGxVcGRhdGVOYW1lICE9PSBudWxsID8gXCJcXG4gIFwiICsgZm91bmRXaWxsVXBkYXRlTmFtZSA6ICcnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSAvLyBDYWNoZSB1bm1hc2tlZCBjb250ZXh0IHNvIHdlIGNhbiBhdm9pZCByZWNyZWF0aW5nIG1hc2tlZCBjb250ZXh0IHVubGVzcyBuZWNlc3NhcnkuXG4gIC8vIFJlYWN0RmliZXJDb250ZXh0IHVzdWFsbHkgdXBkYXRlcyB0aGlzIGNhY2hlIGJ1dCBjYW4ndCBmb3IgbmV3bHktY3JlYXRlZCBpbnN0YW5jZXMuXG5cblxuICBpZiAoaXNMZWdhY3lDb250ZXh0Q29uc3VtZXIpIHtcbiAgICBjYWNoZUNvbnRleHQod29ya0luUHJvZ3Jlc3MsIHVubWFza2VkQ29udGV4dCwgY29udGV4dCk7XG4gIH1cblxuICByZXR1cm4gaW5zdGFuY2U7XG59XG5cbmZ1bmN0aW9uIGNhbGxDb21wb25lbnRXaWxsTW91bnQod29ya0luUHJvZ3Jlc3MsIGluc3RhbmNlKSB7XG4gIHZhciBvbGRTdGF0ZSA9IGluc3RhbmNlLnN0YXRlO1xuXG4gIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbE1vdW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgaW5zdGFuY2UuY29tcG9uZW50V2lsbE1vdW50KCk7XG4gIH1cblxuICBpZiAodHlwZW9mIGluc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsTW91bnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICBpbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbE1vdW50KCk7XG4gIH1cblxuICBpZiAob2xkU3RhdGUgIT09IGluc3RhbmNlLnN0YXRlKSB7XG4gICAge1xuICAgICAgZXJyb3IoJyVzLmNvbXBvbmVudFdpbGxNb3VudCgpOiBBc3NpZ25pbmcgZGlyZWN0bHkgdG8gdGhpcy5zdGF0ZSBpcyAnICsgXCJkZXByZWNhdGVkIChleGNlcHQgaW5zaWRlIGEgY29tcG9uZW50J3MgXCIgKyAnY29uc3RydWN0b3IpLiBVc2Ugc2V0U3RhdGUgaW5zdGVhZC4nLCBnZXRDb21wb25lbnROYW1lKHdvcmtJblByb2dyZXNzLnR5cGUpIHx8ICdDb21wb25lbnQnKTtcbiAgICB9XG5cbiAgICBjbGFzc0NvbXBvbmVudFVwZGF0ZXIuZW5xdWV1ZVJlcGxhY2VTdGF0ZShpbnN0YW5jZSwgaW5zdGFuY2Uuc3RhdGUsIG51bGwpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNhbGxDb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKHdvcmtJblByb2dyZXNzLCBpbnN0YW5jZSwgbmV3UHJvcHMsIG5leHRDb250ZXh0KSB7XG4gIHZhciBvbGRTdGF0ZSA9IGluc3RhbmNlLnN0YXRlO1xuXG4gIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGluc3RhbmNlLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMobmV3UHJvcHMsIG5leHRDb250ZXh0KTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBpbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuZXdQcm9wcywgbmV4dENvbnRleHQpO1xuICB9XG5cbiAgaWYgKGluc3RhbmNlLnN0YXRlICE9PSBvbGRTdGF0ZSkge1xuICAgIHtcbiAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZSh3b3JrSW5Qcm9ncmVzcy50eXBlKSB8fCAnQ29tcG9uZW50JztcblxuICAgICAgaWYgKCFkaWRXYXJuQWJvdXRTdGF0ZUFzc2lnbm1lbnRGb3JDb21wb25lbnQuaGFzKGNvbXBvbmVudE5hbWUpKSB7XG4gICAgICAgIGRpZFdhcm5BYm91dFN0YXRlQXNzaWdubWVudEZvckNvbXBvbmVudC5hZGQoY29tcG9uZW50TmFtZSk7XG5cbiAgICAgICAgZXJyb3IoJyVzLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMoKTogQXNzaWduaW5nIGRpcmVjdGx5IHRvICcgKyBcInRoaXMuc3RhdGUgaXMgZGVwcmVjYXRlZCAoZXhjZXB0IGluc2lkZSBhIGNvbXBvbmVudCdzIFwiICsgJ2NvbnN0cnVjdG9yKS4gVXNlIHNldFN0YXRlIGluc3RlYWQuJywgY29tcG9uZW50TmFtZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY2xhc3NDb21wb25lbnRVcGRhdGVyLmVucXVldWVSZXBsYWNlU3RhdGUoaW5zdGFuY2UsIGluc3RhbmNlLnN0YXRlLCBudWxsKTtcbiAgfVxufSAvLyBJbnZva2VzIHRoZSBtb3VudCBsaWZlLWN5Y2xlcyBvbiBhIHByZXZpb3VzbHkgbmV2ZXIgcmVuZGVyZWQgaW5zdGFuY2UuXG5cblxuZnVuY3Rpb24gbW91bnRDbGFzc0luc3RhbmNlKHdvcmtJblByb2dyZXNzLCBjdG9yLCBuZXdQcm9wcywgcmVuZGVyTGFuZXMpIHtcbiAge1xuICAgIGNoZWNrQ2xhc3NJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcywgY3RvciwgbmV3UHJvcHMpO1xuICB9XG5cbiAgdmFyIGluc3RhbmNlID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuICBpbnN0YW5jZS5wcm9wcyA9IG5ld1Byb3BzO1xuICBpbnN0YW5jZS5zdGF0ZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG4gIGluc3RhbmNlLnJlZnMgPSBlbXB0eVJlZnNPYmplY3Q7XG4gIGluaXRpYWxpemVVcGRhdGVRdWV1ZSh3b3JrSW5Qcm9ncmVzcyk7XG4gIHZhciBjb250ZXh0VHlwZSA9IGN0b3IuY29udGV4dFR5cGU7XG5cbiAgaWYgKHR5cGVvZiBjb250ZXh0VHlwZSA9PT0gJ29iamVjdCcgJiYgY29udGV4dFR5cGUgIT09IG51bGwpIHtcbiAgICBpbnN0YW5jZS5jb250ZXh0ID0gcmVhZENvbnRleHQoY29udGV4dFR5cGUpO1xuICB9IGVsc2Uge1xuICAgIHZhciB1bm1hc2tlZENvbnRleHQgPSBnZXRVbm1hc2tlZENvbnRleHQod29ya0luUHJvZ3Jlc3MsIGN0b3IsIHRydWUpO1xuICAgIGluc3RhbmNlLmNvbnRleHQgPSBnZXRNYXNrZWRDb250ZXh0KHdvcmtJblByb2dyZXNzLCB1bm1hc2tlZENvbnRleHQpO1xuICB9XG5cbiAge1xuICAgIGlmIChpbnN0YW5jZS5zdGF0ZSA9PT0gbmV3UHJvcHMpIHtcbiAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZShjdG9yKSB8fCAnQ29tcG9uZW50JztcblxuICAgICAgaWYgKCFkaWRXYXJuQWJvdXREaXJlY3RseUFzc2lnbmluZ1Byb3BzVG9TdGF0ZS5oYXMoY29tcG9uZW50TmFtZSkpIHtcbiAgICAgICAgZGlkV2FybkFib3V0RGlyZWN0bHlBc3NpZ25pbmdQcm9wc1RvU3RhdGUuYWRkKGNvbXBvbmVudE5hbWUpO1xuXG4gICAgICAgIGVycm9yKCclczogSXQgaXMgbm90IHJlY29tbWVuZGVkIHRvIGFzc2lnbiBwcm9wcyBkaXJlY3RseSB0byBzdGF0ZSAnICsgXCJiZWNhdXNlIHVwZGF0ZXMgdG8gcHJvcHMgd29uJ3QgYmUgcmVmbGVjdGVkIGluIHN0YXRlLiBcIiArICdJbiBtb3N0IGNhc2VzLCBpdCBpcyBiZXR0ZXIgdG8gdXNlIHByb3BzIGRpcmVjdGx5LicsIGNvbXBvbmVudE5hbWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh3b3JrSW5Qcm9ncmVzcy5tb2RlICYgU3RyaWN0TW9kZSkge1xuICAgICAgUmVhY3RTdHJpY3RNb2RlV2FybmluZ3MucmVjb3JkTGVnYWN5Q29udGV4dFdhcm5pbmcod29ya0luUHJvZ3Jlc3MsIGluc3RhbmNlKTtcbiAgICB9XG5cbiAgICB7XG4gICAgICBSZWFjdFN0cmljdE1vZGVXYXJuaW5ncy5yZWNvcmRVbnNhZmVMaWZlY3ljbGVXYXJuaW5ncyh3b3JrSW5Qcm9ncmVzcywgaW5zdGFuY2UpO1xuICAgIH1cbiAgfVxuXG4gIHByb2Nlc3NVcGRhdGVRdWV1ZSh3b3JrSW5Qcm9ncmVzcywgbmV3UHJvcHMsIGluc3RhbmNlLCByZW5kZXJMYW5lcyk7XG4gIGluc3RhbmNlLnN0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcbiAgdmFyIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyA9IGN0b3IuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzO1xuXG4gIGlmICh0eXBlb2YgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgYXBwbHlEZXJpdmVkU3RhdGVGcm9tUHJvcHMod29ya0luUHJvZ3Jlc3MsIGN0b3IsIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcywgbmV3UHJvcHMpO1xuICAgIGluc3RhbmNlLnN0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcbiAgfSAvLyBJbiBvcmRlciB0byBzdXBwb3J0IHJlYWN0LWxpZmVjeWNsZXMtY29tcGF0IHBvbHlmaWxsZWQgY29tcG9uZW50cyxcbiAgLy8gVW5zYWZlIGxpZmVjeWNsZXMgc2hvdWxkIG5vdCBiZSBpbnZva2VkIGZvciBjb21wb25lbnRzIHVzaW5nIHRoZSBuZXcgQVBJcy5cblxuXG4gIGlmICh0eXBlb2YgY3Rvci5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgIT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGluc3RhbmNlLmdldFNuYXBzaG90QmVmb3JlVXBkYXRlICE9PSAnZnVuY3Rpb24nICYmICh0eXBlb2YgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudCA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbE1vdW50ID09PSAnZnVuY3Rpb24nKSkge1xuICAgIGNhbGxDb21wb25lbnRXaWxsTW91bnQod29ya0luUHJvZ3Jlc3MsIGluc3RhbmNlKTsgLy8gSWYgd2UgaGFkIGFkZGl0aW9uYWwgc3RhdGUgdXBkYXRlcyBkdXJpbmcgdGhpcyBsaWZlLWN5Y2xlLCBsZXQnc1xuICAgIC8vIHByb2Nlc3MgdGhlbSBub3cuXG5cbiAgICBwcm9jZXNzVXBkYXRlUXVldWUod29ya0luUHJvZ3Jlc3MsIG5ld1Byb3BzLCBpbnN0YW5jZSwgcmVuZGVyTGFuZXMpO1xuICAgIGluc3RhbmNlLnN0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50RGlkTW91bnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBVcGRhdGU7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVzdW1lTW91bnRDbGFzc0luc3RhbmNlKHdvcmtJblByb2dyZXNzLCBjdG9yLCBuZXdQcm9wcywgcmVuZGVyTGFuZXMpIHtcbiAgdmFyIGluc3RhbmNlID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuICB2YXIgb2xkUHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFByb3BzO1xuICBpbnN0YW5jZS5wcm9wcyA9IG9sZFByb3BzO1xuICB2YXIgb2xkQ29udGV4dCA9IGluc3RhbmNlLmNvbnRleHQ7XG4gIHZhciBjb250ZXh0VHlwZSA9IGN0b3IuY29udGV4dFR5cGU7XG4gIHZhciBuZXh0Q29udGV4dCA9IGVtcHR5Q29udGV4dE9iamVjdDtcblxuICBpZiAodHlwZW9mIGNvbnRleHRUeXBlID09PSAnb2JqZWN0JyAmJiBjb250ZXh0VHlwZSAhPT0gbnVsbCkge1xuICAgIG5leHRDb250ZXh0ID0gcmVhZENvbnRleHQoY29udGV4dFR5cGUpO1xuICB9IGVsc2Uge1xuICAgIHZhciBuZXh0TGVnYWN5VW5tYXNrZWRDb250ZXh0ID0gZ2V0VW5tYXNrZWRDb250ZXh0KHdvcmtJblByb2dyZXNzLCBjdG9yLCB0cnVlKTtcbiAgICBuZXh0Q29udGV4dCA9IGdldE1hc2tlZENvbnRleHQod29ya0luUHJvZ3Jlc3MsIG5leHRMZWdhY3lVbm1hc2tlZENvbnRleHQpO1xuICB9XG5cbiAgdmFyIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyA9IGN0b3IuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzO1xuICB2YXIgaGFzTmV3TGlmZWN5Y2xlcyA9IHR5cGVvZiBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgPT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGluc3RhbmNlLmdldFNuYXBzaG90QmVmb3JlVXBkYXRlID09PSAnZnVuY3Rpb24nOyAvLyBOb3RlOiBEdXJpbmcgdGhlc2UgbGlmZS1jeWNsZXMsIGluc3RhbmNlLnByb3BzL2luc3RhbmNlLnN0YXRlIGFyZSB3aGF0XG4gIC8vIGV2ZXIgdGhlIHByZXZpb3VzbHkgYXR0ZW1wdGVkIHRvIHJlbmRlciAtIG5vdCB0aGUgXCJjdXJyZW50XCIuIEhvd2V2ZXIsXG4gIC8vIGR1cmluZyBjb21wb25lbnREaWRVcGRhdGUgd2UgcGFzcyB0aGUgXCJjdXJyZW50XCIgcHJvcHMuXG4gIC8vIEluIG9yZGVyIHRvIHN1cHBvcnQgcmVhY3QtbGlmZWN5Y2xlcy1jb21wYXQgcG9seWZpbGxlZCBjb21wb25lbnRzLFxuICAvLyBVbnNhZmUgbGlmZWN5Y2xlcyBzaG91bGQgbm90IGJlIGludm9rZWQgZm9yIGNvbXBvbmVudHMgdXNpbmcgdGhlIG5ldyBBUElzLlxuXG4gIGlmICghaGFzTmV3TGlmZWN5Y2xlcyAmJiAodHlwZW9mIGluc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzID09PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzID09PSAnZnVuY3Rpb24nKSkge1xuICAgIGlmIChvbGRQcm9wcyAhPT0gbmV3UHJvcHMgfHwgb2xkQ29udGV4dCAhPT0gbmV4dENvbnRleHQpIHtcbiAgICAgIGNhbGxDb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKHdvcmtJblByb2dyZXNzLCBpbnN0YW5jZSwgbmV3UHJvcHMsIG5leHRDb250ZXh0KTtcbiAgICB9XG4gIH1cblxuICByZXNldEhhc0ZvcmNlVXBkYXRlQmVmb3JlUHJvY2Vzc2luZygpO1xuICB2YXIgb2xkU3RhdGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuICB2YXIgbmV3U3RhdGUgPSBpbnN0YW5jZS5zdGF0ZSA9IG9sZFN0YXRlO1xuICBwcm9jZXNzVXBkYXRlUXVldWUod29ya0luUHJvZ3Jlc3MsIG5ld1Byb3BzLCBpbnN0YW5jZSwgcmVuZGVyTGFuZXMpO1xuICBuZXdTdGF0ZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG5cbiAgaWYgKG9sZFByb3BzID09PSBuZXdQcm9wcyAmJiBvbGRTdGF0ZSA9PT0gbmV3U3RhdGUgJiYgIWhhc0NvbnRleHRDaGFuZ2VkKCkgJiYgIWNoZWNrSGFzRm9yY2VVcGRhdGVBZnRlclByb2Nlc3NpbmcoKSkge1xuICAgIC8vIElmIGFuIHVwZGF0ZSB3YXMgYWxyZWFkeSBpbiBwcm9ncmVzcywgd2Ugc2hvdWxkIHNjaGVkdWxlIGFuIFVwZGF0ZVxuICAgIC8vIGVmZmVjdCBldmVuIHRob3VnaCB3ZSdyZSBiYWlsaW5nIG91dCwgc28gdGhhdCBjV1UvY0RVIGFyZSBjYWxsZWQuXG4gICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnREaWRNb3VudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gVXBkYXRlO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgYXBwbHlEZXJpdmVkU3RhdGVGcm9tUHJvcHMod29ya0luUHJvZ3Jlc3MsIGN0b3IsIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcywgbmV3UHJvcHMpO1xuICAgIG5ld1N0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcbiAgfVxuXG4gIHZhciBzaG91bGRVcGRhdGUgPSBjaGVja0hhc0ZvcmNlVXBkYXRlQWZ0ZXJQcm9jZXNzaW5nKCkgfHwgY2hlY2tTaG91bGRDb21wb25lbnRVcGRhdGUod29ya0luUHJvZ3Jlc3MsIGN0b3IsIG9sZFByb3BzLCBuZXdQcm9wcywgb2xkU3RhdGUsIG5ld1N0YXRlLCBuZXh0Q29udGV4dCk7XG5cbiAgaWYgKHNob3VsZFVwZGF0ZSkge1xuICAgIC8vIEluIG9yZGVyIHRvIHN1cHBvcnQgcmVhY3QtbGlmZWN5Y2xlcy1jb21wYXQgcG9seWZpbGxlZCBjb21wb25lbnRzLFxuICAgIC8vIFVuc2FmZSBsaWZlY3ljbGVzIHNob3VsZCBub3QgYmUgaW52b2tlZCBmb3IgY29tcG9uZW50cyB1c2luZyB0aGUgbmV3IEFQSXMuXG4gICAgaWYgKCFoYXNOZXdMaWZlY3ljbGVzICYmICh0eXBlb2YgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudCA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbE1vdW50ID09PSAnZnVuY3Rpb24nKSkge1xuICAgICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsTW91bnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgaW5zdGFuY2UuY29tcG9uZW50V2lsbE1vdW50KCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBpbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbE1vdW50KCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnREaWRNb3VudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gVXBkYXRlO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBJZiBhbiB1cGRhdGUgd2FzIGFscmVhZHkgaW4gcHJvZ3Jlc3MsIHdlIHNob3VsZCBzY2hlZHVsZSBhbiBVcGRhdGVcbiAgICAvLyBlZmZlY3QgZXZlbiB0aG91Z2ggd2UncmUgYmFpbGluZyBvdXQsIHNvIHRoYXQgY1dVL2NEVSBhcmUgY2FsbGVkLlxuICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50RGlkTW91bnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IFVwZGF0ZTtcbiAgICB9IC8vIElmIHNob3VsZENvbXBvbmVudFVwZGF0ZSByZXR1cm5lZCBmYWxzZSwgd2Ugc2hvdWxkIHN0aWxsIHVwZGF0ZSB0aGVcbiAgICAvLyBtZW1vaXplZCBzdGF0ZSB0byBpbmRpY2F0ZSB0aGF0IHRoaXMgd29yayBjYW4gYmUgcmV1c2VkLlxuXG5cbiAgICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFByb3BzID0gbmV3UHJvcHM7XG4gICAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IG5ld1N0YXRlO1xuICB9IC8vIFVwZGF0ZSB0aGUgZXhpc3RpbmcgaW5zdGFuY2UncyBzdGF0ZSwgcHJvcHMsIGFuZCBjb250ZXh0IHBvaW50ZXJzIGV2ZW5cbiAgLy8gaWYgc2hvdWxkQ29tcG9uZW50VXBkYXRlIHJldHVybnMgZmFsc2UuXG5cblxuICBpbnN0YW5jZS5wcm9wcyA9IG5ld1Byb3BzO1xuICBpbnN0YW5jZS5zdGF0ZSA9IG5ld1N0YXRlO1xuICBpbnN0YW5jZS5jb250ZXh0ID0gbmV4dENvbnRleHQ7XG4gIHJldHVybiBzaG91bGRVcGRhdGU7XG59IC8vIEludm9rZXMgdGhlIHVwZGF0ZSBsaWZlLWN5Y2xlcyBhbmQgcmV0dXJucyBmYWxzZSBpZiBpdCBzaG91bGRuJ3QgcmVyZW5kZXIuXG5cblxuZnVuY3Rpb24gdXBkYXRlQ2xhc3NJbnN0YW5jZShjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgY3RvciwgbmV3UHJvcHMsIHJlbmRlckxhbmVzKSB7XG4gIHZhciBpbnN0YW5jZSA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcbiAgY2xvbmVVcGRhdGVRdWV1ZShjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcyk7XG4gIHZhciB1bnJlc29sdmVkT2xkUHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFByb3BzO1xuICB2YXIgb2xkUHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy50eXBlID09PSB3b3JrSW5Qcm9ncmVzcy5lbGVtZW50VHlwZSA/IHVucmVzb2x2ZWRPbGRQcm9wcyA6IHJlc29sdmVEZWZhdWx0UHJvcHMod29ya0luUHJvZ3Jlc3MudHlwZSwgdW5yZXNvbHZlZE9sZFByb3BzKTtcbiAgaW5zdGFuY2UucHJvcHMgPSBvbGRQcm9wcztcbiAgdmFyIHVucmVzb2x2ZWROZXdQcm9wcyA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcztcbiAgdmFyIG9sZENvbnRleHQgPSBpbnN0YW5jZS5jb250ZXh0O1xuICB2YXIgY29udGV4dFR5cGUgPSBjdG9yLmNvbnRleHRUeXBlO1xuICB2YXIgbmV4dENvbnRleHQgPSBlbXB0eUNvbnRleHRPYmplY3Q7XG5cbiAgaWYgKHR5cGVvZiBjb250ZXh0VHlwZSA9PT0gJ29iamVjdCcgJiYgY29udGV4dFR5cGUgIT09IG51bGwpIHtcbiAgICBuZXh0Q29udGV4dCA9IHJlYWRDb250ZXh0KGNvbnRleHRUeXBlKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgbmV4dFVubWFza2VkQ29udGV4dCA9IGdldFVubWFza2VkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgY3RvciwgdHJ1ZSk7XG4gICAgbmV4dENvbnRleHQgPSBnZXRNYXNrZWRDb250ZXh0KHdvcmtJblByb2dyZXNzLCBuZXh0VW5tYXNrZWRDb250ZXh0KTtcbiAgfVxuXG4gIHZhciBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgPSBjdG9yLmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcztcbiAgdmFyIGhhc05ld0xpZmVjeWNsZXMgPSB0eXBlb2YgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzID09PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBpbnN0YW5jZS5nZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJzsgLy8gTm90ZTogRHVyaW5nIHRoZXNlIGxpZmUtY3ljbGVzLCBpbnN0YW5jZS5wcm9wcy9pbnN0YW5jZS5zdGF0ZSBhcmUgd2hhdFxuICAvLyBldmVyIHRoZSBwcmV2aW91c2x5IGF0dGVtcHRlZCB0byByZW5kZXIgLSBub3QgdGhlIFwiY3VycmVudFwiLiBIb3dldmVyLFxuICAvLyBkdXJpbmcgY29tcG9uZW50RGlkVXBkYXRlIHdlIHBhc3MgdGhlIFwiY3VycmVudFwiIHByb3BzLlxuICAvLyBJbiBvcmRlciB0byBzdXBwb3J0IHJlYWN0LWxpZmVjeWNsZXMtY29tcGF0IHBvbHlmaWxsZWQgY29tcG9uZW50cyxcbiAgLy8gVW5zYWZlIGxpZmVjeWNsZXMgc2hvdWxkIG5vdCBiZSBpbnZva2VkIGZvciBjb21wb25lbnRzIHVzaW5nIHRoZSBuZXcgQVBJcy5cblxuICBpZiAoIWhhc05ld0xpZmVjeWNsZXMgJiYgKHR5cGVvZiBpbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyA9PT0gJ2Z1bmN0aW9uJykpIHtcbiAgICBpZiAodW5yZXNvbHZlZE9sZFByb3BzICE9PSB1bnJlc29sdmVkTmV3UHJvcHMgfHwgb2xkQ29udGV4dCAhPT0gbmV4dENvbnRleHQpIHtcbiAgICAgIGNhbGxDb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKHdvcmtJblByb2dyZXNzLCBpbnN0YW5jZSwgbmV3UHJvcHMsIG5leHRDb250ZXh0KTtcbiAgICB9XG4gIH1cblxuICByZXNldEhhc0ZvcmNlVXBkYXRlQmVmb3JlUHJvY2Vzc2luZygpO1xuICB2YXIgb2xkU3RhdGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuICB2YXIgbmV3U3RhdGUgPSBpbnN0YW5jZS5zdGF0ZSA9IG9sZFN0YXRlO1xuICBwcm9jZXNzVXBkYXRlUXVldWUod29ya0luUHJvZ3Jlc3MsIG5ld1Byb3BzLCBpbnN0YW5jZSwgcmVuZGVyTGFuZXMpO1xuICBuZXdTdGF0ZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG5cbiAgaWYgKHVucmVzb2x2ZWRPbGRQcm9wcyA9PT0gdW5yZXNvbHZlZE5ld1Byb3BzICYmIG9sZFN0YXRlID09PSBuZXdTdGF0ZSAmJiAhaGFzQ29udGV4dENoYW5nZWQoKSAmJiAhY2hlY2tIYXNGb3JjZVVwZGF0ZUFmdGVyUHJvY2Vzc2luZygpKSB7XG4gICAgLy8gSWYgYW4gdXBkYXRlIHdhcyBhbHJlYWR5IGluIHByb2dyZXNzLCB3ZSBzaG91bGQgc2NoZWR1bGUgYW4gVXBkYXRlXG4gICAgLy8gZWZmZWN0IGV2ZW4gdGhvdWdoIHdlJ3JlIGJhaWxpbmcgb3V0LCBzbyB0aGF0IGNXVS9jRFUgYXJlIGNhbGxlZC5cbiAgICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudERpZFVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaWYgKHVucmVzb2x2ZWRPbGRQcm9wcyAhPT0gY3VycmVudC5tZW1vaXplZFByb3BzIHx8IG9sZFN0YXRlICE9PSBjdXJyZW50Lm1lbW9pemVkU3RhdGUpIHtcbiAgICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gVXBkYXRlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGlmICh1bnJlc29sdmVkT2xkUHJvcHMgIT09IGN1cnJlbnQubWVtb2l6ZWRQcm9wcyB8fCBvbGRTdGF0ZSAhPT0gY3VycmVudC5tZW1vaXplZFN0YXRlKSB7XG4gICAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IFNuYXBzaG90O1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgYXBwbHlEZXJpdmVkU3RhdGVGcm9tUHJvcHMod29ya0luUHJvZ3Jlc3MsIGN0b3IsIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcywgbmV3UHJvcHMpO1xuICAgIG5ld1N0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcbiAgfVxuXG4gIHZhciBzaG91bGRVcGRhdGUgPSBjaGVja0hhc0ZvcmNlVXBkYXRlQWZ0ZXJQcm9jZXNzaW5nKCkgfHwgY2hlY2tTaG91bGRDb21wb25lbnRVcGRhdGUod29ya0luUHJvZ3Jlc3MsIGN0b3IsIG9sZFByb3BzLCBuZXdQcm9wcywgb2xkU3RhdGUsIG5ld1N0YXRlLCBuZXh0Q29udGV4dCk7XG5cbiAgaWYgKHNob3VsZFVwZGF0ZSkge1xuICAgIC8vIEluIG9yZGVyIHRvIHN1cHBvcnQgcmVhY3QtbGlmZWN5Y2xlcy1jb21wYXQgcG9seWZpbGxlZCBjb21wb25lbnRzLFxuICAgIC8vIFVuc2FmZSBsaWZlY3ljbGVzIHNob3VsZCBub3QgYmUgaW52b2tlZCBmb3IgY29tcG9uZW50cyB1c2luZyB0aGUgbmV3IEFQSXMuXG4gICAgaWYgKCFoYXNOZXdMaWZlY3ljbGVzICYmICh0eXBlb2YgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxVcGRhdGUgPT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxVcGRhdGUgPT09ICdmdW5jdGlvbicpKSB7XG4gICAgICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxVcGRhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgaW5zdGFuY2UuY29tcG9uZW50V2lsbFVwZGF0ZShuZXdQcm9wcywgbmV3U3RhdGUsIG5leHRDb250ZXh0KTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbFVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBpbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbFVwZGF0ZShuZXdQcm9wcywgbmV3U3RhdGUsIG5leHRDb250ZXh0KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudERpZFVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gVXBkYXRlO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IFNuYXBzaG90O1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBJZiBhbiB1cGRhdGUgd2FzIGFscmVhZHkgaW4gcHJvZ3Jlc3MsIHdlIHNob3VsZCBzY2hlZHVsZSBhbiBVcGRhdGVcbiAgICAvLyBlZmZlY3QgZXZlbiB0aG91Z2ggd2UncmUgYmFpbGluZyBvdXQsIHNvIHRoYXQgY1dVL2NEVSBhcmUgY2FsbGVkLlxuICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50RGlkVXBkYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpZiAodW5yZXNvbHZlZE9sZFByb3BzICE9PSBjdXJyZW50Lm1lbW9pemVkUHJvcHMgfHwgb2xkU3RhdGUgIT09IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZSkge1xuICAgICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBVcGRhdGU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5nZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaWYgKHVucmVzb2x2ZWRPbGRQcm9wcyAhPT0gY3VycmVudC5tZW1vaXplZFByb3BzIHx8IG9sZFN0YXRlICE9PSBjdXJyZW50Lm1lbW9pemVkU3RhdGUpIHtcbiAgICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gU25hcHNob3Q7XG4gICAgICB9XG4gICAgfSAvLyBJZiBzaG91bGRDb21wb25lbnRVcGRhdGUgcmV0dXJuZWQgZmFsc2UsIHdlIHNob3VsZCBzdGlsbCB1cGRhdGUgdGhlXG4gICAgLy8gbWVtb2l6ZWQgcHJvcHMvc3RhdGUgdG8gaW5kaWNhdGUgdGhhdCB0aGlzIHdvcmsgY2FuIGJlIHJldXNlZC5cblxuXG4gICAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcyA9IG5ld1Byb3BzO1xuICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBuZXdTdGF0ZTtcbiAgfSAvLyBVcGRhdGUgdGhlIGV4aXN0aW5nIGluc3RhbmNlJ3Mgc3RhdGUsIHByb3BzLCBhbmQgY29udGV4dCBwb2ludGVycyBldmVuXG4gIC8vIGlmIHNob3VsZENvbXBvbmVudFVwZGF0ZSByZXR1cm5zIGZhbHNlLlxuXG5cbiAgaW5zdGFuY2UucHJvcHMgPSBuZXdQcm9wcztcbiAgaW5zdGFuY2Uuc3RhdGUgPSBuZXdTdGF0ZTtcbiAgaW5zdGFuY2UuY29udGV4dCA9IG5leHRDb250ZXh0O1xuICByZXR1cm4gc2hvdWxkVXBkYXRlO1xufVxuXG52YXIgZGlkV2FybkFib3V0TWFwcztcbnZhciBkaWRXYXJuQWJvdXRHZW5lcmF0b3JzO1xudmFyIGRpZFdhcm5BYm91dFN0cmluZ1JlZnM7XG52YXIgb3duZXJIYXNLZXlVc2VXYXJuaW5nO1xudmFyIG93bmVySGFzRnVuY3Rpb25UeXBlV2FybmluZztcblxudmFyIHdhcm5Gb3JNaXNzaW5nS2V5ID0gZnVuY3Rpb24gKGNoaWxkLCByZXR1cm5GaWJlcikge307XG5cbntcbiAgZGlkV2FybkFib3V0TWFwcyA9IGZhbHNlO1xuICBkaWRXYXJuQWJvdXRHZW5lcmF0b3JzID0gZmFsc2U7XG4gIGRpZFdhcm5BYm91dFN0cmluZ1JlZnMgPSB7fTtcbiAgLyoqXG4gICAqIFdhcm4gaWYgdGhlcmUncyBubyBrZXkgZXhwbGljaXRseSBzZXQgb24gZHluYW1pYyBhcnJheXMgb2YgY2hpbGRyZW4gb3JcbiAgICogb2JqZWN0IGtleXMgYXJlIG5vdCB2YWxpZC4gVGhpcyBhbGxvd3MgdXMgdG8ga2VlcCB0cmFjayBvZiBjaGlsZHJlbiBiZXR3ZWVuXG4gICAqIHVwZGF0ZXMuXG4gICAqL1xuXG4gIG93bmVySGFzS2V5VXNlV2FybmluZyA9IHt9O1xuICBvd25lckhhc0Z1bmN0aW9uVHlwZVdhcm5pbmcgPSB7fTtcblxuICB3YXJuRm9yTWlzc2luZ0tleSA9IGZ1bmN0aW9uIChjaGlsZCwgcmV0dXJuRmliZXIpIHtcbiAgICBpZiAoY2hpbGQgPT09IG51bGwgfHwgdHlwZW9mIGNoaWxkICE9PSAnb2JqZWN0Jykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICghY2hpbGQuX3N0b3JlIHx8IGNoaWxkLl9zdG9yZS52YWxpZGF0ZWQgfHwgY2hpbGQua2V5ICE9IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoISh0eXBlb2YgY2hpbGQuX3N0b3JlID09PSAnb2JqZWN0JykpIHtcbiAgICAgIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoIFwiUmVhY3QgQ29tcG9uZW50IGluIHdhcm5Gb3JNaXNzaW5nS2V5IHNob3VsZCBoYXZlIGEgX3N0b3JlLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY2hpbGQuX3N0b3JlLnZhbGlkYXRlZCA9IHRydWU7XG4gICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lKHJldHVybkZpYmVyLnR5cGUpIHx8ICdDb21wb25lbnQnO1xuXG4gICAgaWYgKG93bmVySGFzS2V5VXNlV2FybmluZ1tjb21wb25lbnROYW1lXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIG93bmVySGFzS2V5VXNlV2FybmluZ1tjb21wb25lbnROYW1lXSA9IHRydWU7XG5cbiAgICBlcnJvcignRWFjaCBjaGlsZCBpbiBhIGxpc3Qgc2hvdWxkIGhhdmUgYSB1bmlxdWUgJyArICdcImtleVwiIHByb3AuIFNlZSBodHRwczovL3JlYWN0anMub3JnL2xpbmsvd2FybmluZy1rZXlzIGZvciAnICsgJ21vcmUgaW5mb3JtYXRpb24uJyk7XG4gIH07XG59XG5cbnZhciBpc0FycmF5JDEgPSBBcnJheS5pc0FycmF5O1xuXG5mdW5jdGlvbiBjb2VyY2VSZWYocmV0dXJuRmliZXIsIGN1cnJlbnQsIGVsZW1lbnQpIHtcbiAgdmFyIG1peGVkUmVmID0gZWxlbWVudC5yZWY7XG5cbiAgaWYgKG1peGVkUmVmICE9PSBudWxsICYmIHR5cGVvZiBtaXhlZFJlZiAhPT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgbWl4ZWRSZWYgIT09ICdvYmplY3QnKSB7XG4gICAge1xuICAgICAgLy8gVE9ETzogQ2xlYW4gdGhpcyB1cCBvbmNlIHdlIHR1cm4gb24gdGhlIHN0cmluZyByZWYgd2FybmluZyBmb3JcbiAgICAgIC8vIGV2ZXJ5b25lLCBiZWNhdXNlIHRoZSBzdHJpY3QgbW9kZSBjYXNlIHdpbGwgbm8gbG9uZ2VyIGJlIHJlbGV2YW50XG4gICAgICBpZiAoKHJldHVybkZpYmVyLm1vZGUgJiBTdHJpY3RNb2RlIHx8IHdhcm5BYm91dFN0cmluZ1JlZnMpICYmIC8vIFdlIHdhcm4gaW4gUmVhY3RFbGVtZW50LmpzIGlmIG93bmVyIGFuZCBzZWxmIGFyZSBlcXVhbCBmb3Igc3RyaW5nIHJlZnNcbiAgICAgIC8vIGJlY2F1c2UgdGhlc2UgY2Fubm90IGJlIGF1dG9tYXRpY2FsbHkgY29udmVydGVkIHRvIGFuIGFycm93IGZ1bmN0aW9uXG4gICAgICAvLyB1c2luZyBhIGNvZGVtb2QuIFRoZXJlZm9yZSwgd2UgZG9uJ3QgaGF2ZSB0byB3YXJuIGFib3V0IHN0cmluZyByZWZzIGFnYWluLlxuICAgICAgIShlbGVtZW50Ll9vd25lciAmJiBlbGVtZW50Ll9zZWxmICYmIGVsZW1lbnQuX293bmVyLnN0YXRlTm9kZSAhPT0gZWxlbWVudC5fc2VsZikpIHtcbiAgICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lKHJldHVybkZpYmVyLnR5cGUpIHx8ICdDb21wb25lbnQnO1xuXG4gICAgICAgIGlmICghZGlkV2FybkFib3V0U3RyaW5nUmVmc1tjb21wb25lbnROYW1lXSkge1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIGVycm9yKCdBIHN0cmluZyByZWYsIFwiJXNcIiwgaGFzIGJlZW4gZm91bmQgd2l0aGluIGEgc3RyaWN0IG1vZGUgdHJlZS4gJyArICdTdHJpbmcgcmVmcyBhcmUgYSBzb3VyY2Ugb2YgcG90ZW50aWFsIGJ1Z3MgYW5kIHNob3VsZCBiZSBhdm9pZGVkLiAnICsgJ1dlIHJlY29tbWVuZCB1c2luZyB1c2VSZWYoKSBvciBjcmVhdGVSZWYoKSBpbnN0ZWFkLiAnICsgJ0xlYXJuIG1vcmUgYWJvdXQgdXNpbmcgcmVmcyBzYWZlbHkgaGVyZTogJyArICdodHRwczovL3JlYWN0anMub3JnL2xpbmsvc3RyaWN0LW1vZGUtc3RyaW5nLXJlZicsIG1peGVkUmVmKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBkaWRXYXJuQWJvdXRTdHJpbmdSZWZzW2NvbXBvbmVudE5hbWVdID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChlbGVtZW50Ll9vd25lcikge1xuICAgICAgdmFyIG93bmVyID0gZWxlbWVudC5fb3duZXI7XG4gICAgICB2YXIgaW5zdDtcblxuICAgICAgaWYgKG93bmVyKSB7XG4gICAgICAgIHZhciBvd25lckZpYmVyID0gb3duZXI7XG5cbiAgICAgICAgaWYgKCEob3duZXJGaWJlci50YWcgPT09IENsYXNzQ29tcG9uZW50KSkge1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKCBcIkZ1bmN0aW9uIGNvbXBvbmVudHMgY2Fubm90IGhhdmUgc3RyaW5nIHJlZnMuIFdlIHJlY29tbWVuZCB1c2luZyB1c2VSZWYoKSBpbnN0ZWFkLiBMZWFybiBtb3JlIGFib3V0IHVzaW5nIHJlZnMgc2FmZWx5IGhlcmU6IGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zdHJpY3QtbW9kZS1zdHJpbmctcmVmXCIgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpbnN0ID0gb3duZXJGaWJlci5zdGF0ZU5vZGU7XG4gICAgICB9XG5cbiAgICAgIGlmICghaW5zdCkge1xuICAgICAgICB7XG4gICAgICAgICAgdGhyb3cgRXJyb3IoIFwiTWlzc2luZyBvd25lciBmb3Igc3RyaW5nIHJlZiBcIiArIG1peGVkUmVmICsgXCIuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCIgKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgc3RyaW5nUmVmID0gJycgKyBtaXhlZFJlZjsgLy8gQ2hlY2sgaWYgcHJldmlvdXMgc3RyaW5nIHJlZiBtYXRjaGVzIG5ldyBzdHJpbmcgcmVmXG5cbiAgICAgIGlmIChjdXJyZW50ICE9PSBudWxsICYmIGN1cnJlbnQucmVmICE9PSBudWxsICYmIHR5cGVvZiBjdXJyZW50LnJlZiA9PT0gJ2Z1bmN0aW9uJyAmJiBjdXJyZW50LnJlZi5fc3RyaW5nUmVmID09PSBzdHJpbmdSZWYpIHtcbiAgICAgICAgcmV0dXJuIGN1cnJlbnQucmVmO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVmID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHZhciByZWZzID0gaW5zdC5yZWZzO1xuXG4gICAgICAgIGlmIChyZWZzID09PSBlbXB0eVJlZnNPYmplY3QpIHtcbiAgICAgICAgICAvLyBUaGlzIGlzIGEgbGF6eSBwb29sZWQgZnJvemVuIG9iamVjdCwgc28gd2UgbmVlZCB0byBpbml0aWFsaXplLlxuICAgICAgICAgIHJlZnMgPSBpbnN0LnJlZnMgPSB7fTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgIGRlbGV0ZSByZWZzW3N0cmluZ1JlZl07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVmc1tzdHJpbmdSZWZdID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHJlZi5fc3RyaW5nUmVmID0gc3RyaW5nUmVmO1xuICAgICAgcmV0dXJuIHJlZjtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKCEodHlwZW9mIG1peGVkUmVmID09PSAnc3RyaW5nJykpIHtcbiAgICAgICAge1xuICAgICAgICAgIHRocm93IEVycm9yKCBcIkV4cGVjdGVkIHJlZiB0byBiZSBhIGZ1bmN0aW9uLCBhIHN0cmluZywgYW4gb2JqZWN0IHJldHVybmVkIGJ5IFJlYWN0LmNyZWF0ZVJlZigpLCBvciBudWxsLlwiICk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKCFlbGVtZW50Ll9vd25lcikge1xuICAgICAgICB7XG4gICAgICAgICAgdGhyb3cgRXJyb3IoIFwiRWxlbWVudCByZWYgd2FzIHNwZWNpZmllZCBhcyBhIHN0cmluZyAoXCIgKyBtaXhlZFJlZiArIFwiKSBidXQgbm8gb3duZXIgd2FzIHNldC4gVGhpcyBjb3VsZCBoYXBwZW4gZm9yIG9uZSBvZiB0aGUgZm9sbG93aW5nIHJlYXNvbnM6XFxuMS4gWW91IG1heSBiZSBhZGRpbmcgYSByZWYgdG8gYSBmdW5jdGlvbiBjb21wb25lbnRcXG4yLiBZb3UgbWF5IGJlIGFkZGluZyBhIHJlZiB0byBhIGNvbXBvbmVudCB0aGF0IHdhcyBub3QgY3JlYXRlZCBpbnNpZGUgYSBjb21wb25lbnQncyByZW5kZXIgbWV0aG9kXFxuMy4gWW91IGhhdmUgbXVsdGlwbGUgY29waWVzIG9mIFJlYWN0IGxvYWRlZFxcblNlZSBodHRwczovL3JlYWN0anMub3JnL2xpbmsvcmVmcy1tdXN0LWhhdmUtb3duZXIgZm9yIG1vcmUgaW5mb3JtYXRpb24uXCIgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBtaXhlZFJlZjtcbn1cblxuZnVuY3Rpb24gdGhyb3dPbkludmFsaWRPYmplY3RUeXBlKHJldHVybkZpYmVyLCBuZXdDaGlsZCkge1xuICBpZiAocmV0dXJuRmliZXIudHlwZSAhPT0gJ3RleHRhcmVhJykge1xuICAgIHtcbiAgICAgIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoIFwiT2JqZWN0cyBhcmUgbm90IHZhbGlkIGFzIGEgUmVhY3QgY2hpbGQgKGZvdW5kOiBcIiArIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobmV3Q2hpbGQpID09PSAnW29iamVjdCBPYmplY3RdJyA/ICdvYmplY3Qgd2l0aCBrZXlzIHsnICsgT2JqZWN0LmtleXMobmV3Q2hpbGQpLmpvaW4oJywgJykgKyAnfScgOiBuZXdDaGlsZCkgKyBcIikuIElmIHlvdSBtZWFudCB0byByZW5kZXIgYSBjb2xsZWN0aW9uIG9mIGNoaWxkcmVuLCB1c2UgYW4gYXJyYXkgaW5zdGVhZC5cIiApO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiB3YXJuT25GdW5jdGlvblR5cGUocmV0dXJuRmliZXIpIHtcbiAge1xuICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZShyZXR1cm5GaWJlci50eXBlKSB8fCAnQ29tcG9uZW50JztcblxuICAgIGlmIChvd25lckhhc0Z1bmN0aW9uVHlwZVdhcm5pbmdbY29tcG9uZW50TmFtZV0pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBvd25lckhhc0Z1bmN0aW9uVHlwZVdhcm5pbmdbY29tcG9uZW50TmFtZV0gPSB0cnVlO1xuXG4gICAgZXJyb3IoJ0Z1bmN0aW9ucyBhcmUgbm90IHZhbGlkIGFzIGEgUmVhY3QgY2hpbGQuIFRoaXMgbWF5IGhhcHBlbiBpZiAnICsgJ3lvdSByZXR1cm4gYSBDb21wb25lbnQgaW5zdGVhZCBvZiA8Q29tcG9uZW50IC8+IGZyb20gcmVuZGVyLiAnICsgJ09yIG1heWJlIHlvdSBtZWFudCB0byBjYWxsIHRoaXMgZnVuY3Rpb24gcmF0aGVyIHRoYW4gcmV0dXJuIGl0LicpO1xuICB9XG59IC8vIFdlIGF2b2lkIGlubGluaW5nIHRoaXMgdG8gYXZvaWQgcG90ZW50aWFsIGRlb3B0cyBmcm9tIHVzaW5nIHRyeS9jYXRjaC5cbi8vIHRvIGJlIGFibGUgdG8gb3B0aW1pemUgZWFjaCBwYXRoIGluZGl2aWR1YWxseSBieSBicmFuY2hpbmcgZWFybHkuIFRoaXMgbmVlZHNcbi8vIGEgY29tcGlsZXIgb3Igd2UgY2FuIGRvIGl0IG1hbnVhbGx5LiBIZWxwZXJzIHRoYXQgZG9uJ3QgbmVlZCB0aGlzIGJyYW5jaGluZ1xuLy8gbGl2ZSBvdXRzaWRlIG9mIHRoaXMgZnVuY3Rpb24uXG5cblxuZnVuY3Rpb24gQ2hpbGRSZWNvbmNpbGVyKHNob3VsZFRyYWNrU2lkZUVmZmVjdHMpIHtcbiAgZnVuY3Rpb24gZGVsZXRlQ2hpbGQocmV0dXJuRmliZXIsIGNoaWxkVG9EZWxldGUpIHtcbiAgICBpZiAoIXNob3VsZFRyYWNrU2lkZUVmZmVjdHMpIHtcbiAgICAgIC8vIE5vb3AuXG4gICAgICByZXR1cm47XG4gICAgfSAvLyBEZWxldGlvbnMgYXJlIGFkZGVkIGluIHJldmVyc2VkIG9yZGVyIHNvIHdlIGFkZCBpdCB0byB0aGUgZnJvbnQuXG4gICAgLy8gQXQgdGhpcyBwb2ludCwgdGhlIHJldHVybiBmaWJlcidzIGVmZmVjdCBsaXN0IGlzIGVtcHR5IGV4Y2VwdCBmb3JcbiAgICAvLyBkZWxldGlvbnMsIHNvIHdlIGNhbiBqdXN0IGFwcGVuZCB0aGUgZGVsZXRpb24gdG8gdGhlIGxpc3QuIFRoZSByZW1haW5pbmdcbiAgICAvLyBlZmZlY3RzIGFyZW4ndCBhZGRlZCB1bnRpbCB0aGUgY29tcGxldGUgcGhhc2UuIE9uY2Ugd2UgaW1wbGVtZW50XG4gICAgLy8gcmVzdW1pbmcsIHRoaXMgbWF5IG5vdCBiZSB0cnVlLlxuXG5cbiAgICB2YXIgbGFzdCA9IHJldHVybkZpYmVyLmxhc3RFZmZlY3Q7XG5cbiAgICBpZiAobGFzdCAhPT0gbnVsbCkge1xuICAgICAgbGFzdC5uZXh0RWZmZWN0ID0gY2hpbGRUb0RlbGV0ZTtcbiAgICAgIHJldHVybkZpYmVyLmxhc3RFZmZlY3QgPSBjaGlsZFRvRGVsZXRlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm5GaWJlci5maXJzdEVmZmVjdCA9IHJldHVybkZpYmVyLmxhc3RFZmZlY3QgPSBjaGlsZFRvRGVsZXRlO1xuICAgIH1cblxuICAgIGNoaWxkVG9EZWxldGUubmV4dEVmZmVjdCA9IG51bGw7XG4gICAgY2hpbGRUb0RlbGV0ZS5mbGFncyA9IERlbGV0aW9uO1xuICB9XG5cbiAgZnVuY3Rpb24gZGVsZXRlUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkKSB7XG4gICAgaWYgKCFzaG91bGRUcmFja1NpZGVFZmZlY3RzKSB7XG4gICAgICAvLyBOb29wLlxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSAvLyBUT0RPOiBGb3IgdGhlIHNob3VsZENsb25lIGNhc2UsIHRoaXMgY291bGQgYmUgbWljcm8tb3B0aW1pemVkIGEgYml0IGJ5XG4gICAgLy8gYXNzdW1pbmcgdGhhdCBhZnRlciB0aGUgZmlyc3QgY2hpbGQgd2UndmUgYWxyZWFkeSBhZGRlZCBldmVyeXRoaW5nLlxuXG5cbiAgICB2YXIgY2hpbGRUb0RlbGV0ZSA9IGN1cnJlbnRGaXJzdENoaWxkO1xuXG4gICAgd2hpbGUgKGNoaWxkVG9EZWxldGUgIT09IG51bGwpIHtcbiAgICAgIGRlbGV0ZUNoaWxkKHJldHVybkZpYmVyLCBjaGlsZFRvRGVsZXRlKTtcbiAgICAgIGNoaWxkVG9EZWxldGUgPSBjaGlsZFRvRGVsZXRlLnNpYmxpbmc7XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBmdW5jdGlvbiBtYXBSZW1haW5pbmdDaGlsZHJlbihyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQpIHtcbiAgICAvLyBBZGQgdGhlIHJlbWFpbmluZyBjaGlsZHJlbiB0byBhIHRlbXBvcmFyeSBtYXAgc28gdGhhdCB3ZSBjYW4gZmluZCB0aGVtIGJ5XG4gICAgLy8ga2V5cyBxdWlja2x5LiBJbXBsaWNpdCAobnVsbCkga2V5cyBnZXQgYWRkZWQgdG8gdGhpcyBzZXQgd2l0aCB0aGVpciBpbmRleFxuICAgIC8vIGluc3RlYWQuXG4gICAgdmFyIGV4aXN0aW5nQ2hpbGRyZW4gPSBuZXcgTWFwKCk7XG4gICAgdmFyIGV4aXN0aW5nQ2hpbGQgPSBjdXJyZW50Rmlyc3RDaGlsZDtcblxuICAgIHdoaWxlIChleGlzdGluZ0NoaWxkICE9PSBudWxsKSB7XG4gICAgICBpZiAoZXhpc3RpbmdDaGlsZC5rZXkgIT09IG51bGwpIHtcbiAgICAgICAgZXhpc3RpbmdDaGlsZHJlbi5zZXQoZXhpc3RpbmdDaGlsZC5rZXksIGV4aXN0aW5nQ2hpbGQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZXhpc3RpbmdDaGlsZHJlbi5zZXQoZXhpc3RpbmdDaGlsZC5pbmRleCwgZXhpc3RpbmdDaGlsZCk7XG4gICAgICB9XG5cbiAgICAgIGV4aXN0aW5nQ2hpbGQgPSBleGlzdGluZ0NoaWxkLnNpYmxpbmc7XG4gICAgfVxuXG4gICAgcmV0dXJuIGV4aXN0aW5nQ2hpbGRyZW47XG4gIH1cblxuICBmdW5jdGlvbiB1c2VGaWJlcihmaWJlciwgcGVuZGluZ1Byb3BzKSB7XG4gICAgLy8gV2UgY3VycmVudGx5IHNldCBzaWJsaW5nIHRvIG51bGwgYW5kIGluZGV4IHRvIDAgaGVyZSBiZWNhdXNlIGl0IGlzIGVhc3lcbiAgICAvLyB0byBmb3JnZXQgdG8gZG8gYmVmb3JlIHJldHVybmluZyBpdC4gRS5nLiBmb3IgdGhlIHNpbmdsZSBjaGlsZCBjYXNlLlxuICAgIHZhciBjbG9uZSA9IGNyZWF0ZVdvcmtJblByb2dyZXNzKGZpYmVyLCBwZW5kaW5nUHJvcHMpO1xuICAgIGNsb25lLmluZGV4ID0gMDtcbiAgICBjbG9uZS5zaWJsaW5nID0gbnVsbDtcbiAgICByZXR1cm4gY2xvbmU7XG4gIH1cblxuICBmdW5jdGlvbiBwbGFjZUNoaWxkKG5ld0ZpYmVyLCBsYXN0UGxhY2VkSW5kZXgsIG5ld0luZGV4KSB7XG4gICAgbmV3RmliZXIuaW5kZXggPSBuZXdJbmRleDtcblxuICAgIGlmICghc2hvdWxkVHJhY2tTaWRlRWZmZWN0cykge1xuICAgICAgLy8gTm9vcC5cbiAgICAgIHJldHVybiBsYXN0UGxhY2VkSW5kZXg7XG4gICAgfVxuXG4gICAgdmFyIGN1cnJlbnQgPSBuZXdGaWJlci5hbHRlcm5hdGU7XG5cbiAgICBpZiAoY3VycmVudCAhPT0gbnVsbCkge1xuICAgICAgdmFyIG9sZEluZGV4ID0gY3VycmVudC5pbmRleDtcblxuICAgICAgaWYgKG9sZEluZGV4IDwgbGFzdFBsYWNlZEluZGV4KSB7XG4gICAgICAgIC8vIFRoaXMgaXMgYSBtb3ZlLlxuICAgICAgICBuZXdGaWJlci5mbGFncyA9IFBsYWNlbWVudDtcbiAgICAgICAgcmV0dXJuIGxhc3RQbGFjZWRJbmRleDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFRoaXMgaXRlbSBjYW4gc3RheSBpbiBwbGFjZS5cbiAgICAgICAgcmV0dXJuIG9sZEluZGV4O1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUaGlzIGlzIGFuIGluc2VydGlvbi5cbiAgICAgIG5ld0ZpYmVyLmZsYWdzID0gUGxhY2VtZW50O1xuICAgICAgcmV0dXJuIGxhc3RQbGFjZWRJbmRleDtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBwbGFjZVNpbmdsZUNoaWxkKG5ld0ZpYmVyKSB7XG4gICAgLy8gVGhpcyBpcyBzaW1wbGVyIGZvciB0aGUgc2luZ2xlIGNoaWxkIGNhc2UuIFdlIG9ubHkgbmVlZCB0byBkbyBhXG4gICAgLy8gcGxhY2VtZW50IGZvciBpbnNlcnRpbmcgbmV3IGNoaWxkcmVuLlxuICAgIGlmIChzaG91bGRUcmFja1NpZGVFZmZlY3RzICYmIG5ld0ZpYmVyLmFsdGVybmF0ZSA9PT0gbnVsbCkge1xuICAgICAgbmV3RmliZXIuZmxhZ3MgPSBQbGFjZW1lbnQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ld0ZpYmVyO1xuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlVGV4dE5vZGUocmV0dXJuRmliZXIsIGN1cnJlbnQsIHRleHRDb250ZW50LCBsYW5lcykge1xuICAgIGlmIChjdXJyZW50ID09PSBudWxsIHx8IGN1cnJlbnQudGFnICE9PSBIb3N0VGV4dCkge1xuICAgICAgLy8gSW5zZXJ0XG4gICAgICB2YXIgY3JlYXRlZCA9IGNyZWF0ZUZpYmVyRnJvbVRleHQodGV4dENvbnRlbnQsIHJldHVybkZpYmVyLm1vZGUsIGxhbmVzKTtcbiAgICAgIGNyZWF0ZWQucmV0dXJuID0gcmV0dXJuRmliZXI7XG4gICAgICByZXR1cm4gY3JlYXRlZDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVXBkYXRlXG4gICAgICB2YXIgZXhpc3RpbmcgPSB1c2VGaWJlcihjdXJyZW50LCB0ZXh0Q29udGVudCk7XG4gICAgICBleGlzdGluZy5yZXR1cm4gPSByZXR1cm5GaWJlcjtcbiAgICAgIHJldHVybiBleGlzdGluZztcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVFbGVtZW50KHJldHVybkZpYmVyLCBjdXJyZW50LCBlbGVtZW50LCBsYW5lcykge1xuICAgIGlmIChjdXJyZW50ICE9PSBudWxsKSB7XG4gICAgICBpZiAoY3VycmVudC5lbGVtZW50VHlwZSA9PT0gZWxlbWVudC50eXBlIHx8ICggLy8gS2VlcCB0aGlzIGNoZWNrIGlubGluZSBzbyBpdCBvbmx5IHJ1bnMgb24gdGhlIGZhbHNlIHBhdGg6XG4gICAgICAgaXNDb21wYXRpYmxlRmFtaWx5Rm9ySG90UmVsb2FkaW5nKGN1cnJlbnQsIGVsZW1lbnQpICkpIHtcbiAgICAgICAgLy8gTW92ZSBiYXNlZCBvbiBpbmRleFxuICAgICAgICB2YXIgZXhpc3RpbmcgPSB1c2VGaWJlcihjdXJyZW50LCBlbGVtZW50LnByb3BzKTtcbiAgICAgICAgZXhpc3RpbmcucmVmID0gY29lcmNlUmVmKHJldHVybkZpYmVyLCBjdXJyZW50LCBlbGVtZW50KTtcbiAgICAgICAgZXhpc3RpbmcucmV0dXJuID0gcmV0dXJuRmliZXI7XG5cbiAgICAgICAge1xuICAgICAgICAgIGV4aXN0aW5nLl9kZWJ1Z1NvdXJjZSA9IGVsZW1lbnQuX3NvdXJjZTtcbiAgICAgICAgICBleGlzdGluZy5fZGVidWdPd25lciA9IGVsZW1lbnQuX293bmVyO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGV4aXN0aW5nO1xuICAgICAgfVxuICAgIH0gLy8gSW5zZXJ0XG5cblxuICAgIHZhciBjcmVhdGVkID0gY3JlYXRlRmliZXJGcm9tRWxlbWVudChlbGVtZW50LCByZXR1cm5GaWJlci5tb2RlLCBsYW5lcyk7XG4gICAgY3JlYXRlZC5yZWYgPSBjb2VyY2VSZWYocmV0dXJuRmliZXIsIGN1cnJlbnQsIGVsZW1lbnQpO1xuICAgIGNyZWF0ZWQucmV0dXJuID0gcmV0dXJuRmliZXI7XG4gICAgcmV0dXJuIGNyZWF0ZWQ7XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVQb3J0YWwocmV0dXJuRmliZXIsIGN1cnJlbnQsIHBvcnRhbCwgbGFuZXMpIHtcbiAgICBpZiAoY3VycmVudCA9PT0gbnVsbCB8fCBjdXJyZW50LnRhZyAhPT0gSG9zdFBvcnRhbCB8fCBjdXJyZW50LnN0YXRlTm9kZS5jb250YWluZXJJbmZvICE9PSBwb3J0YWwuY29udGFpbmVySW5mbyB8fCBjdXJyZW50LnN0YXRlTm9kZS5pbXBsZW1lbnRhdGlvbiAhPT0gcG9ydGFsLmltcGxlbWVudGF0aW9uKSB7XG4gICAgICAvLyBJbnNlcnRcbiAgICAgIHZhciBjcmVhdGVkID0gY3JlYXRlRmliZXJGcm9tUG9ydGFsKHBvcnRhbCwgcmV0dXJuRmliZXIubW9kZSwgbGFuZXMpO1xuICAgICAgY3JlYXRlZC5yZXR1cm4gPSByZXR1cm5GaWJlcjtcbiAgICAgIHJldHVybiBjcmVhdGVkO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBVcGRhdGVcbiAgICAgIHZhciBleGlzdGluZyA9IHVzZUZpYmVyKGN1cnJlbnQsIHBvcnRhbC5jaGlsZHJlbiB8fCBbXSk7XG4gICAgICBleGlzdGluZy5yZXR1cm4gPSByZXR1cm5GaWJlcjtcbiAgICAgIHJldHVybiBleGlzdGluZztcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVGcmFnbWVudChyZXR1cm5GaWJlciwgY3VycmVudCwgZnJhZ21lbnQsIGxhbmVzLCBrZXkpIHtcbiAgICBpZiAoY3VycmVudCA9PT0gbnVsbCB8fCBjdXJyZW50LnRhZyAhPT0gRnJhZ21lbnQpIHtcbiAgICAgIC8vIEluc2VydFxuICAgICAgdmFyIGNyZWF0ZWQgPSBjcmVhdGVGaWJlckZyb21GcmFnbWVudChmcmFnbWVudCwgcmV0dXJuRmliZXIubW9kZSwgbGFuZXMsIGtleSk7XG4gICAgICBjcmVhdGVkLnJldHVybiA9IHJldHVybkZpYmVyO1xuICAgICAgcmV0dXJuIGNyZWF0ZWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFVwZGF0ZVxuICAgICAgdmFyIGV4aXN0aW5nID0gdXNlRmliZXIoY3VycmVudCwgZnJhZ21lbnQpO1xuICAgICAgZXhpc3RpbmcucmV0dXJuID0gcmV0dXJuRmliZXI7XG4gICAgICByZXR1cm4gZXhpc3Rpbmc7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlQ2hpbGQocmV0dXJuRmliZXIsIG5ld0NoaWxkLCBsYW5lcykge1xuICAgIGlmICh0eXBlb2YgbmV3Q2hpbGQgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBuZXdDaGlsZCA9PT0gJ251bWJlcicpIHtcbiAgICAgIC8vIFRleHQgbm9kZXMgZG9uJ3QgaGF2ZSBrZXlzLiBJZiB0aGUgcHJldmlvdXMgbm9kZSBpcyBpbXBsaWNpdGx5IGtleWVkXG4gICAgICAvLyB3ZSBjYW4gY29udGludWUgdG8gcmVwbGFjZSBpdCB3aXRob3V0IGFib3J0aW5nIGV2ZW4gaWYgaXQgaXMgbm90IGEgdGV4dFxuICAgICAgLy8gbm9kZS5cbiAgICAgIHZhciBjcmVhdGVkID0gY3JlYXRlRmliZXJGcm9tVGV4dCgnJyArIG5ld0NoaWxkLCByZXR1cm5GaWJlci5tb2RlLCBsYW5lcyk7XG4gICAgICBjcmVhdGVkLnJldHVybiA9IHJldHVybkZpYmVyO1xuICAgICAgcmV0dXJuIGNyZWF0ZWQ7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBuZXdDaGlsZCA9PT0gJ29iamVjdCcgJiYgbmV3Q2hpbGQgIT09IG51bGwpIHtcbiAgICAgIHN3aXRjaCAobmV3Q2hpbGQuJCR0eXBlb2YpIHtcbiAgICAgICAgY2FzZSBSRUFDVF9FTEVNRU5UX1RZUEU6XG4gICAgICAgICAge1xuICAgICAgICAgICAgdmFyIF9jcmVhdGVkID0gY3JlYXRlRmliZXJGcm9tRWxlbWVudChuZXdDaGlsZCwgcmV0dXJuRmliZXIubW9kZSwgbGFuZXMpO1xuXG4gICAgICAgICAgICBfY3JlYXRlZC5yZWYgPSBjb2VyY2VSZWYocmV0dXJuRmliZXIsIG51bGwsIG5ld0NoaWxkKTtcbiAgICAgICAgICAgIF9jcmVhdGVkLnJldHVybiA9IHJldHVybkZpYmVyO1xuICAgICAgICAgICAgcmV0dXJuIF9jcmVhdGVkO1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHZhciBfY3JlYXRlZDIgPSBjcmVhdGVGaWJlckZyb21Qb3J0YWwobmV3Q2hpbGQsIHJldHVybkZpYmVyLm1vZGUsIGxhbmVzKTtcblxuICAgICAgICAgICAgX2NyZWF0ZWQyLnJldHVybiA9IHJldHVybkZpYmVyO1xuICAgICAgICAgICAgcmV0dXJuIF9jcmVhdGVkMjtcbiAgICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChpc0FycmF5JDEobmV3Q2hpbGQpIHx8IGdldEl0ZXJhdG9yRm4obmV3Q2hpbGQpKSB7XG4gICAgICAgIHZhciBfY3JlYXRlZDMgPSBjcmVhdGVGaWJlckZyb21GcmFnbWVudChuZXdDaGlsZCwgcmV0dXJuRmliZXIubW9kZSwgbGFuZXMsIG51bGwpO1xuXG4gICAgICAgIF9jcmVhdGVkMy5yZXR1cm4gPSByZXR1cm5GaWJlcjtcbiAgICAgICAgcmV0dXJuIF9jcmVhdGVkMztcbiAgICAgIH1cblxuICAgICAgdGhyb3dPbkludmFsaWRPYmplY3RUeXBlKHJldHVybkZpYmVyLCBuZXdDaGlsZCk7XG4gICAgfVxuXG4gICAge1xuICAgICAgaWYgKHR5cGVvZiBuZXdDaGlsZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB3YXJuT25GdW5jdGlvblR5cGUocmV0dXJuRmliZXIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlU2xvdChyZXR1cm5GaWJlciwgb2xkRmliZXIsIG5ld0NoaWxkLCBsYW5lcykge1xuICAgIC8vIFVwZGF0ZSB0aGUgZmliZXIgaWYgdGhlIGtleXMgbWF0Y2gsIG90aGVyd2lzZSByZXR1cm4gbnVsbC5cbiAgICB2YXIga2V5ID0gb2xkRmliZXIgIT09IG51bGwgPyBvbGRGaWJlci5rZXkgOiBudWxsO1xuXG4gICAgaWYgKHR5cGVvZiBuZXdDaGlsZCA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIG5ld0NoaWxkID09PSAnbnVtYmVyJykge1xuICAgICAgLy8gVGV4dCBub2RlcyBkb24ndCBoYXZlIGtleXMuIElmIHRoZSBwcmV2aW91cyBub2RlIGlzIGltcGxpY2l0bHkga2V5ZWRcbiAgICAgIC8vIHdlIGNhbiBjb250aW51ZSB0byByZXBsYWNlIGl0IHdpdGhvdXQgYWJvcnRpbmcgZXZlbiBpZiBpdCBpcyBub3QgYSB0ZXh0XG4gICAgICAvLyBub2RlLlxuICAgICAgaWYgKGtleSAhPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHVwZGF0ZVRleHROb2RlKHJldHVybkZpYmVyLCBvbGRGaWJlciwgJycgKyBuZXdDaGlsZCwgbGFuZXMpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgbmV3Q2hpbGQgPT09ICdvYmplY3QnICYmIG5ld0NoaWxkICE9PSBudWxsKSB7XG4gICAgICBzd2l0Y2ggKG5ld0NoaWxkLiQkdHlwZW9mKSB7XG4gICAgICAgIGNhc2UgUkVBQ1RfRUxFTUVOVF9UWVBFOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlmIChuZXdDaGlsZC5rZXkgPT09IGtleSkge1xuICAgICAgICAgICAgICBpZiAobmV3Q2hpbGQudHlwZSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB1cGRhdGVGcmFnbWVudChyZXR1cm5GaWJlciwgb2xkRmliZXIsIG5ld0NoaWxkLnByb3BzLmNoaWxkcmVuLCBsYW5lcywga2V5KTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHJldHVybiB1cGRhdGVFbGVtZW50KHJldHVybkZpYmVyLCBvbGRGaWJlciwgbmV3Q2hpbGQsIGxhbmVzKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlmIChuZXdDaGlsZC5rZXkgPT09IGtleSkge1xuICAgICAgICAgICAgICByZXR1cm4gdXBkYXRlUG9ydGFsKHJldHVybkZpYmVyLCBvbGRGaWJlciwgbmV3Q2hpbGQsIGxhbmVzKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGlzQXJyYXkkMShuZXdDaGlsZCkgfHwgZ2V0SXRlcmF0b3JGbihuZXdDaGlsZCkpIHtcbiAgICAgICAgaWYgKGtleSAhPT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHVwZGF0ZUZyYWdtZW50KHJldHVybkZpYmVyLCBvbGRGaWJlciwgbmV3Q2hpbGQsIGxhbmVzLCBudWxsKTtcbiAgICAgIH1cblxuICAgICAgdGhyb3dPbkludmFsaWRPYmplY3RUeXBlKHJldHVybkZpYmVyLCBuZXdDaGlsZCk7XG4gICAgfVxuXG4gICAge1xuICAgICAgaWYgKHR5cGVvZiBuZXdDaGlsZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB3YXJuT25GdW5jdGlvblR5cGUocmV0dXJuRmliZXIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlRnJvbU1hcChleGlzdGluZ0NoaWxkcmVuLCByZXR1cm5GaWJlciwgbmV3SWR4LCBuZXdDaGlsZCwgbGFuZXMpIHtcbiAgICBpZiAodHlwZW9mIG5ld0NoaWxkID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgbmV3Q2hpbGQgPT09ICdudW1iZXInKSB7XG4gICAgICAvLyBUZXh0IG5vZGVzIGRvbid0IGhhdmUga2V5cywgc28gd2UgbmVpdGhlciBoYXZlIHRvIGNoZWNrIHRoZSBvbGQgbm9yXG4gICAgICAvLyBuZXcgbm9kZSBmb3IgdGhlIGtleS4gSWYgYm90aCBhcmUgdGV4dCBub2RlcywgdGhleSBtYXRjaC5cbiAgICAgIHZhciBtYXRjaGVkRmliZXIgPSBleGlzdGluZ0NoaWxkcmVuLmdldChuZXdJZHgpIHx8IG51bGw7XG4gICAgICByZXR1cm4gdXBkYXRlVGV4dE5vZGUocmV0dXJuRmliZXIsIG1hdGNoZWRGaWJlciwgJycgKyBuZXdDaGlsZCwgbGFuZXMpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgbmV3Q2hpbGQgPT09ICdvYmplY3QnICYmIG5ld0NoaWxkICE9PSBudWxsKSB7XG4gICAgICBzd2l0Y2ggKG5ld0NoaWxkLiQkdHlwZW9mKSB7XG4gICAgICAgIGNhc2UgUkVBQ1RfRUxFTUVOVF9UWVBFOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHZhciBfbWF0Y2hlZEZpYmVyID0gZXhpc3RpbmdDaGlsZHJlbi5nZXQobmV3Q2hpbGQua2V5ID09PSBudWxsID8gbmV3SWR4IDogbmV3Q2hpbGQua2V5KSB8fCBudWxsO1xuXG4gICAgICAgICAgICBpZiAobmV3Q2hpbGQudHlwZSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRSkge1xuICAgICAgICAgICAgICByZXR1cm4gdXBkYXRlRnJhZ21lbnQocmV0dXJuRmliZXIsIF9tYXRjaGVkRmliZXIsIG5ld0NoaWxkLnByb3BzLmNoaWxkcmVuLCBsYW5lcywgbmV3Q2hpbGQua2V5KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHVwZGF0ZUVsZW1lbnQocmV0dXJuRmliZXIsIF9tYXRjaGVkRmliZXIsIG5ld0NoaWxkLCBsYW5lcyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgUkVBQ1RfUE9SVEFMX1RZUEU6XG4gICAgICAgICAge1xuICAgICAgICAgICAgdmFyIF9tYXRjaGVkRmliZXIyID0gZXhpc3RpbmdDaGlsZHJlbi5nZXQobmV3Q2hpbGQua2V5ID09PSBudWxsID8gbmV3SWR4IDogbmV3Q2hpbGQua2V5KSB8fCBudWxsO1xuXG4gICAgICAgICAgICByZXR1cm4gdXBkYXRlUG9ydGFsKHJldHVybkZpYmVyLCBfbWF0Y2hlZEZpYmVyMiwgbmV3Q2hpbGQsIGxhbmVzKTtcbiAgICAgICAgICB9XG5cbiAgICAgIH1cblxuICAgICAgaWYgKGlzQXJyYXkkMShuZXdDaGlsZCkgfHwgZ2V0SXRlcmF0b3JGbihuZXdDaGlsZCkpIHtcbiAgICAgICAgdmFyIF9tYXRjaGVkRmliZXIzID0gZXhpc3RpbmdDaGlsZHJlbi5nZXQobmV3SWR4KSB8fCBudWxsO1xuXG4gICAgICAgIHJldHVybiB1cGRhdGVGcmFnbWVudChyZXR1cm5GaWJlciwgX21hdGNoZWRGaWJlcjMsIG5ld0NoaWxkLCBsYW5lcywgbnVsbCk7XG4gICAgICB9XG5cbiAgICAgIHRocm93T25JbnZhbGlkT2JqZWN0VHlwZShyZXR1cm5GaWJlciwgbmV3Q2hpbGQpO1xuICAgIH1cblxuICAgIHtcbiAgICAgIGlmICh0eXBlb2YgbmV3Q2hpbGQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgd2Fybk9uRnVuY3Rpb25UeXBlKHJldHVybkZpYmVyKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICAvKipcbiAgICogV2FybnMgaWYgdGhlcmUgaXMgYSBkdXBsaWNhdGUgb3IgbWlzc2luZyBrZXlcbiAgICovXG5cblxuICBmdW5jdGlvbiB3YXJuT25JbnZhbGlkS2V5KGNoaWxkLCBrbm93bktleXMsIHJldHVybkZpYmVyKSB7XG4gICAge1xuICAgICAgaWYgKHR5cGVvZiBjaGlsZCAhPT0gJ29iamVjdCcgfHwgY2hpbGQgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGtub3duS2V5cztcbiAgICAgIH1cblxuICAgICAgc3dpdGNoIChjaGlsZC4kJHR5cGVvZikge1xuICAgICAgICBjYXNlIFJFQUNUX0VMRU1FTlRfVFlQRTpcbiAgICAgICAgY2FzZSBSRUFDVF9QT1JUQUxfVFlQRTpcbiAgICAgICAgICB3YXJuRm9yTWlzc2luZ0tleShjaGlsZCwgcmV0dXJuRmliZXIpO1xuICAgICAgICAgIHZhciBrZXkgPSBjaGlsZC5rZXk7XG5cbiAgICAgICAgICBpZiAodHlwZW9mIGtleSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChrbm93bktleXMgPT09IG51bGwpIHtcbiAgICAgICAgICAgIGtub3duS2V5cyA9IG5ldyBTZXQoKTtcbiAgICAgICAgICAgIGtub3duS2V5cy5hZGQoa2V5KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICgha25vd25LZXlzLmhhcyhrZXkpKSB7XG4gICAgICAgICAgICBrbm93bktleXMuYWRkKGtleSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBlcnJvcignRW5jb3VudGVyZWQgdHdvIGNoaWxkcmVuIHdpdGggdGhlIHNhbWUga2V5LCBgJXNgLiAnICsgJ0tleXMgc2hvdWxkIGJlIHVuaXF1ZSBzbyB0aGF0IGNvbXBvbmVudHMgbWFpbnRhaW4gdGhlaXIgaWRlbnRpdHkgJyArICdhY3Jvc3MgdXBkYXRlcy4gTm9uLXVuaXF1ZSBrZXlzIG1heSBjYXVzZSBjaGlsZHJlbiB0byBiZSAnICsgJ2R1cGxpY2F0ZWQgYW5kL29yIG9taXR0ZWQg4oCUIHRoZSBiZWhhdmlvciBpcyB1bnN1cHBvcnRlZCBhbmQgJyArICdjb3VsZCBjaGFuZ2UgaW4gYSBmdXR1cmUgdmVyc2lvbi4nLCBrZXkpO1xuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGtub3duS2V5cztcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlY29uY2lsZUNoaWxkcmVuQXJyYXkocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkLCBuZXdDaGlsZHJlbiwgbGFuZXMpIHtcbiAgICAvLyBUaGlzIGFsZ29yaXRobSBjYW4ndCBvcHRpbWl6ZSBieSBzZWFyY2hpbmcgZnJvbSBib3RoIGVuZHMgc2luY2Ugd2VcbiAgICAvLyBkb24ndCBoYXZlIGJhY2twb2ludGVycyBvbiBmaWJlcnMuIEknbSB0cnlpbmcgdG8gc2VlIGhvdyBmYXIgd2UgY2FuIGdldFxuICAgIC8vIHdpdGggdGhhdCBtb2RlbC4gSWYgaXQgZW5kcyB1cCBub3QgYmVpbmcgd29ydGggdGhlIHRyYWRlb2Zmcywgd2UgY2FuXG4gICAgLy8gYWRkIGl0IGxhdGVyLlxuICAgIC8vIEV2ZW4gd2l0aCBhIHR3byBlbmRlZCBvcHRpbWl6YXRpb24sIHdlJ2Qgd2FudCB0byBvcHRpbWl6ZSBmb3IgdGhlIGNhc2VcbiAgICAvLyB3aGVyZSB0aGVyZSBhcmUgZmV3IGNoYW5nZXMgYW5kIGJydXRlIGZvcmNlIHRoZSBjb21wYXJpc29uIGluc3RlYWQgb2ZcbiAgICAvLyBnb2luZyBmb3IgdGhlIE1hcC4gSXQnZCBsaWtlIHRvIGV4cGxvcmUgaGl0dGluZyB0aGF0IHBhdGggZmlyc3QgaW5cbiAgICAvLyBmb3J3YXJkLW9ubHkgbW9kZSBhbmQgb25seSBnbyBmb3IgdGhlIE1hcCBvbmNlIHdlIG5vdGljZSB0aGF0IHdlIG5lZWRcbiAgICAvLyBsb3RzIG9mIGxvb2sgYWhlYWQuIFRoaXMgZG9lc24ndCBoYW5kbGUgcmV2ZXJzYWwgYXMgd2VsbCBhcyB0d28gZW5kZWRcbiAgICAvLyBzZWFyY2ggYnV0IHRoYXQncyB1bnVzdWFsLiBCZXNpZGVzLCBmb3IgdGhlIHR3byBlbmRlZCBvcHRpbWl6YXRpb24gdG9cbiAgICAvLyB3b3JrIG9uIEl0ZXJhYmxlcywgd2UnZCBuZWVkIHRvIGNvcHkgdGhlIHdob2xlIHNldC5cbiAgICAvLyBJbiB0aGlzIGZpcnN0IGl0ZXJhdGlvbiwgd2UnbGwganVzdCBsaXZlIHdpdGggaGl0dGluZyB0aGUgYmFkIGNhc2VcbiAgICAvLyAoYWRkaW5nIGV2ZXJ5dGhpbmcgdG8gYSBNYXApIGluIGZvciBldmVyeSBpbnNlcnQvbW92ZS5cbiAgICAvLyBJZiB5b3UgY2hhbmdlIHRoaXMgY29kZSwgYWxzbyB1cGRhdGUgcmVjb25jaWxlQ2hpbGRyZW5JdGVyYXRvcigpIHdoaWNoXG4gICAgLy8gdXNlcyB0aGUgc2FtZSBhbGdvcml0aG0uXG4gICAge1xuICAgICAgLy8gRmlyc3QsIHZhbGlkYXRlIGtleXMuXG4gICAgICB2YXIga25vd25LZXlzID0gbnVsbDtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuZXdDaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY2hpbGQgPSBuZXdDaGlsZHJlbltpXTtcbiAgICAgICAga25vd25LZXlzID0gd2Fybk9uSW52YWxpZEtleShjaGlsZCwga25vd25LZXlzLCByZXR1cm5GaWJlcik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHJlc3VsdGluZ0ZpcnN0Q2hpbGQgPSBudWxsO1xuICAgIHZhciBwcmV2aW91c05ld0ZpYmVyID0gbnVsbDtcbiAgICB2YXIgb2xkRmliZXIgPSBjdXJyZW50Rmlyc3RDaGlsZDtcbiAgICB2YXIgbGFzdFBsYWNlZEluZGV4ID0gMDtcbiAgICB2YXIgbmV3SWR4ID0gMDtcbiAgICB2YXIgbmV4dE9sZEZpYmVyID0gbnVsbDtcblxuICAgIGZvciAoOyBvbGRGaWJlciAhPT0gbnVsbCAmJiBuZXdJZHggPCBuZXdDaGlsZHJlbi5sZW5ndGg7IG5ld0lkeCsrKSB7XG4gICAgICBpZiAob2xkRmliZXIuaW5kZXggPiBuZXdJZHgpIHtcbiAgICAgICAgbmV4dE9sZEZpYmVyID0gb2xkRmliZXI7XG4gICAgICAgIG9sZEZpYmVyID0gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5leHRPbGRGaWJlciA9IG9sZEZpYmVyLnNpYmxpbmc7XG4gICAgICB9XG5cbiAgICAgIHZhciBuZXdGaWJlciA9IHVwZGF0ZVNsb3QocmV0dXJuRmliZXIsIG9sZEZpYmVyLCBuZXdDaGlsZHJlbltuZXdJZHhdLCBsYW5lcyk7XG5cbiAgICAgIGlmIChuZXdGaWJlciA9PT0gbnVsbCkge1xuICAgICAgICAvLyBUT0RPOiBUaGlzIGJyZWFrcyBvbiBlbXB0eSBzbG90cyBsaWtlIG51bGwgY2hpbGRyZW4uIFRoYXQnc1xuICAgICAgICAvLyB1bmZvcnR1bmF0ZSBiZWNhdXNlIGl0IHRyaWdnZXJzIHRoZSBzbG93IHBhdGggYWxsIHRoZSB0aW1lLiBXZSBuZWVkXG4gICAgICAgIC8vIGEgYmV0dGVyIHdheSB0byBjb21tdW5pY2F0ZSB3aGV0aGVyIHRoaXMgd2FzIGEgbWlzcyBvciBudWxsLFxuICAgICAgICAvLyBib29sZWFuLCB1bmRlZmluZWQsIGV0Yy5cbiAgICAgICAgaWYgKG9sZEZpYmVyID09PSBudWxsKSB7XG4gICAgICAgICAgb2xkRmliZXIgPSBuZXh0T2xkRmliZXI7XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgaWYgKHNob3VsZFRyYWNrU2lkZUVmZmVjdHMpIHtcbiAgICAgICAgaWYgKG9sZEZpYmVyICYmIG5ld0ZpYmVyLmFsdGVybmF0ZSA9PT0gbnVsbCkge1xuICAgICAgICAgIC8vIFdlIG1hdGNoZWQgdGhlIHNsb3QsIGJ1dCB3ZSBkaWRuJ3QgcmV1c2UgdGhlIGV4aXN0aW5nIGZpYmVyLCBzbyB3ZVxuICAgICAgICAgIC8vIG5lZWQgdG8gZGVsZXRlIHRoZSBleGlzdGluZyBjaGlsZC5cbiAgICAgICAgICBkZWxldGVDaGlsZChyZXR1cm5GaWJlciwgb2xkRmliZXIpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGxhc3RQbGFjZWRJbmRleCA9IHBsYWNlQ2hpbGQobmV3RmliZXIsIGxhc3RQbGFjZWRJbmRleCwgbmV3SWR4KTtcblxuICAgICAgaWYgKHByZXZpb3VzTmV3RmliZXIgPT09IG51bGwpIHtcbiAgICAgICAgLy8gVE9ETzogTW92ZSBvdXQgb2YgdGhlIGxvb3AuIFRoaXMgb25seSBoYXBwZW5zIGZvciB0aGUgZmlyc3QgcnVuLlxuICAgICAgICByZXN1bHRpbmdGaXJzdENoaWxkID0gbmV3RmliZXI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBUT0RPOiBEZWZlciBzaWJsaW5ncyBpZiB3ZSdyZSBub3QgYXQgdGhlIHJpZ2h0IGluZGV4IGZvciB0aGlzIHNsb3QuXG4gICAgICAgIC8vIEkuZS4gaWYgd2UgaGFkIG51bGwgdmFsdWVzIGJlZm9yZSwgdGhlbiB3ZSB3YW50IHRvIGRlZmVyIHRoaXNcbiAgICAgICAgLy8gZm9yIGVhY2ggbnVsbCB2YWx1ZS4gSG93ZXZlciwgd2UgYWxzbyBkb24ndCB3YW50IHRvIGNhbGwgdXBkYXRlU2xvdFxuICAgICAgICAvLyB3aXRoIHRoZSBwcmV2aW91cyBvbmUuXG4gICAgICAgIHByZXZpb3VzTmV3RmliZXIuc2libGluZyA9IG5ld0ZpYmVyO1xuICAgICAgfVxuXG4gICAgICBwcmV2aW91c05ld0ZpYmVyID0gbmV3RmliZXI7XG4gICAgICBvbGRGaWJlciA9IG5leHRPbGRGaWJlcjtcbiAgICB9XG5cbiAgICBpZiAobmV3SWR4ID09PSBuZXdDaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgIC8vIFdlJ3ZlIHJlYWNoZWQgdGhlIGVuZCBvZiB0aGUgbmV3IGNoaWxkcmVuLiBXZSBjYW4gZGVsZXRlIHRoZSByZXN0LlxuICAgICAgZGVsZXRlUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsIG9sZEZpYmVyKTtcbiAgICAgIHJldHVybiByZXN1bHRpbmdGaXJzdENoaWxkO1xuICAgIH1cblxuICAgIGlmIChvbGRGaWJlciA9PT0gbnVsbCkge1xuICAgICAgLy8gSWYgd2UgZG9uJ3QgaGF2ZSBhbnkgbW9yZSBleGlzdGluZyBjaGlsZHJlbiB3ZSBjYW4gY2hvb3NlIGEgZmFzdCBwYXRoXG4gICAgICAvLyBzaW5jZSB0aGUgcmVzdCB3aWxsIGFsbCBiZSBpbnNlcnRpb25zLlxuICAgICAgZm9yICg7IG5ld0lkeCA8IG5ld0NoaWxkcmVuLmxlbmd0aDsgbmV3SWR4KyspIHtcbiAgICAgICAgdmFyIF9uZXdGaWJlciA9IGNyZWF0ZUNoaWxkKHJldHVybkZpYmVyLCBuZXdDaGlsZHJlbltuZXdJZHhdLCBsYW5lcyk7XG5cbiAgICAgICAgaWYgKF9uZXdGaWJlciA9PT0gbnVsbCkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgbGFzdFBsYWNlZEluZGV4ID0gcGxhY2VDaGlsZChfbmV3RmliZXIsIGxhc3RQbGFjZWRJbmRleCwgbmV3SWR4KTtcblxuICAgICAgICBpZiAocHJldmlvdXNOZXdGaWJlciA9PT0gbnVsbCkge1xuICAgICAgICAgIC8vIFRPRE86IE1vdmUgb3V0IG9mIHRoZSBsb29wLiBUaGlzIG9ubHkgaGFwcGVucyBmb3IgdGhlIGZpcnN0IHJ1bi5cbiAgICAgICAgICByZXN1bHRpbmdGaXJzdENoaWxkID0gX25ld0ZpYmVyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHByZXZpb3VzTmV3RmliZXIuc2libGluZyA9IF9uZXdGaWJlcjtcbiAgICAgICAgfVxuXG4gICAgICAgIHByZXZpb3VzTmV3RmliZXIgPSBfbmV3RmliZXI7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHRpbmdGaXJzdENoaWxkO1xuICAgIH0gLy8gQWRkIGFsbCBjaGlsZHJlbiB0byBhIGtleSBtYXAgZm9yIHF1aWNrIGxvb2t1cHMuXG5cblxuICAgIHZhciBleGlzdGluZ0NoaWxkcmVuID0gbWFwUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsIG9sZEZpYmVyKTsgLy8gS2VlcCBzY2FubmluZyBhbmQgdXNlIHRoZSBtYXAgdG8gcmVzdG9yZSBkZWxldGVkIGl0ZW1zIGFzIG1vdmVzLlxuXG4gICAgZm9yICg7IG5ld0lkeCA8IG5ld0NoaWxkcmVuLmxlbmd0aDsgbmV3SWR4KyspIHtcbiAgICAgIHZhciBfbmV3RmliZXIyID0gdXBkYXRlRnJvbU1hcChleGlzdGluZ0NoaWxkcmVuLCByZXR1cm5GaWJlciwgbmV3SWR4LCBuZXdDaGlsZHJlbltuZXdJZHhdLCBsYW5lcyk7XG5cbiAgICAgIGlmIChfbmV3RmliZXIyICE9PSBudWxsKSB7XG4gICAgICAgIGlmIChzaG91bGRUcmFja1NpZGVFZmZlY3RzKSB7XG4gICAgICAgICAgaWYgKF9uZXdGaWJlcjIuYWx0ZXJuYXRlICE9PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBUaGUgbmV3IGZpYmVyIGlzIGEgd29yayBpbiBwcm9ncmVzcywgYnV0IGlmIHRoZXJlIGV4aXN0cyBhXG4gICAgICAgICAgICAvLyBjdXJyZW50LCB0aGF0IG1lYW5zIHRoYXQgd2UgcmV1c2VkIHRoZSBmaWJlci4gV2UgbmVlZCB0byBkZWxldGVcbiAgICAgICAgICAgIC8vIGl0IGZyb20gdGhlIGNoaWxkIGxpc3Qgc28gdGhhdCB3ZSBkb24ndCBhZGQgaXQgdG8gdGhlIGRlbGV0aW9uXG4gICAgICAgICAgICAvLyBsaXN0LlxuICAgICAgICAgICAgZXhpc3RpbmdDaGlsZHJlbi5kZWxldGUoX25ld0ZpYmVyMi5rZXkgPT09IG51bGwgPyBuZXdJZHggOiBfbmV3RmliZXIyLmtleSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgbGFzdFBsYWNlZEluZGV4ID0gcGxhY2VDaGlsZChfbmV3RmliZXIyLCBsYXN0UGxhY2VkSW5kZXgsIG5ld0lkeCk7XG5cbiAgICAgICAgaWYgKHByZXZpb3VzTmV3RmliZXIgPT09IG51bGwpIHtcbiAgICAgICAgICByZXN1bHRpbmdGaXJzdENoaWxkID0gX25ld0ZpYmVyMjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwcmV2aW91c05ld0ZpYmVyLnNpYmxpbmcgPSBfbmV3RmliZXIyO1xuICAgICAgICB9XG5cbiAgICAgICAgcHJldmlvdXNOZXdGaWJlciA9IF9uZXdGaWJlcjI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHNob3VsZFRyYWNrU2lkZUVmZmVjdHMpIHtcbiAgICAgIC8vIEFueSBleGlzdGluZyBjaGlsZHJlbiB0aGF0IHdlcmVuJ3QgY29uc3VtZWQgYWJvdmUgd2VyZSBkZWxldGVkLiBXZSBuZWVkXG4gICAgICAvLyB0byBhZGQgdGhlbSB0byB0aGUgZGVsZXRpb24gbGlzdC5cbiAgICAgIGV4aXN0aW5nQ2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgcmV0dXJuIGRlbGV0ZUNoaWxkKHJldHVybkZpYmVyLCBjaGlsZCk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0aW5nRmlyc3RDaGlsZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlY29uY2lsZUNoaWxkcmVuSXRlcmF0b3IocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkLCBuZXdDaGlsZHJlbkl0ZXJhYmxlLCBsYW5lcykge1xuICAgIC8vIFRoaXMgaXMgdGhlIHNhbWUgaW1wbGVtZW50YXRpb24gYXMgcmVjb25jaWxlQ2hpbGRyZW5BcnJheSgpLFxuICAgIC8vIGJ1dCB1c2luZyB0aGUgaXRlcmF0b3IgaW5zdGVhZC5cbiAgICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4obmV3Q2hpbGRyZW5JdGVyYWJsZSk7XG5cbiAgICBpZiAoISh0eXBlb2YgaXRlcmF0b3JGbiA9PT0gJ2Z1bmN0aW9uJykpIHtcbiAgICAgIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoIFwiQW4gb2JqZWN0IGlzIG5vdCBhbiBpdGVyYWJsZS4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS5cIiApO1xuICAgICAgfVxuICAgIH1cblxuICAgIHtcbiAgICAgIC8vIFdlIGRvbid0IHN1cHBvcnQgcmVuZGVyaW5nIEdlbmVyYXRvcnMgYmVjYXVzZSBpdCdzIGEgbXV0YXRpb24uXG4gICAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xMjk5NVxuICAgICAgaWYgKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgLy8gJEZsb3dGaXhNZSBGbG93IGRvZXNuJ3Qga25vdyBhYm91dCB0b1N0cmluZ1RhZ1xuICAgICAgbmV3Q2hpbGRyZW5JdGVyYWJsZVtTeW1ib2wudG9TdHJpbmdUYWddID09PSAnR2VuZXJhdG9yJykge1xuICAgICAgICBpZiAoIWRpZFdhcm5BYm91dEdlbmVyYXRvcnMpIHtcbiAgICAgICAgICBlcnJvcignVXNpbmcgR2VuZXJhdG9ycyBhcyBjaGlsZHJlbiBpcyB1bnN1cHBvcnRlZCBhbmQgd2lsbCBsaWtlbHkgeWllbGQgJyArICd1bmV4cGVjdGVkIHJlc3VsdHMgYmVjYXVzZSBlbnVtZXJhdGluZyBhIGdlbmVyYXRvciBtdXRhdGVzIGl0LiAnICsgJ1lvdSBtYXkgY29udmVydCBpdCB0byBhbiBhcnJheSB3aXRoIGBBcnJheS5mcm9tKClgIG9yIHRoZSAnICsgJ2BbLi4uc3ByZWFkXWAgb3BlcmF0b3IgYmVmb3JlIHJlbmRlcmluZy4gS2VlcCBpbiBtaW5kICcgKyAneW91IG1pZ2h0IG5lZWQgdG8gcG9seWZpbGwgdGhlc2UgZmVhdHVyZXMgZm9yIG9sZGVyIGJyb3dzZXJzLicpO1xuICAgICAgICB9XG5cbiAgICAgICAgZGlkV2FybkFib3V0R2VuZXJhdG9ycyA9IHRydWU7XG4gICAgICB9IC8vIFdhcm4gYWJvdXQgdXNpbmcgTWFwcyBhcyBjaGlsZHJlblxuXG5cbiAgICAgIGlmIChuZXdDaGlsZHJlbkl0ZXJhYmxlLmVudHJpZXMgPT09IGl0ZXJhdG9yRm4pIHtcbiAgICAgICAgaWYgKCFkaWRXYXJuQWJvdXRNYXBzKSB7XG4gICAgICAgICAgZXJyb3IoJ1VzaW5nIE1hcHMgYXMgY2hpbGRyZW4gaXMgbm90IHN1cHBvcnRlZC4gJyArICdVc2UgYW4gYXJyYXkgb2Yga2V5ZWQgUmVhY3RFbGVtZW50cyBpbnN0ZWFkLicpO1xuICAgICAgICB9XG5cbiAgICAgICAgZGlkV2FybkFib3V0TWFwcyA9IHRydWU7XG4gICAgICB9IC8vIEZpcnN0LCB2YWxpZGF0ZSBrZXlzLlxuICAgICAgLy8gV2UnbGwgZ2V0IGEgZGlmZmVyZW50IGl0ZXJhdG9yIGxhdGVyIGZvciB0aGUgbWFpbiBwYXNzLlxuXG5cbiAgICAgIHZhciBfbmV3Q2hpbGRyZW4gPSBpdGVyYXRvckZuLmNhbGwobmV3Q2hpbGRyZW5JdGVyYWJsZSk7XG5cbiAgICAgIGlmIChfbmV3Q2hpbGRyZW4pIHtcbiAgICAgICAgdmFyIGtub3duS2V5cyA9IG51bGw7XG5cbiAgICAgICAgdmFyIF9zdGVwID0gX25ld0NoaWxkcmVuLm5leHQoKTtcblxuICAgICAgICBmb3IgKDsgIV9zdGVwLmRvbmU7IF9zdGVwID0gX25ld0NoaWxkcmVuLm5leHQoKSkge1xuICAgICAgICAgIHZhciBjaGlsZCA9IF9zdGVwLnZhbHVlO1xuICAgICAgICAgIGtub3duS2V5cyA9IHdhcm5PbkludmFsaWRLZXkoY2hpbGQsIGtub3duS2V5cywgcmV0dXJuRmliZXIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIG5ld0NoaWxkcmVuID0gaXRlcmF0b3JGbi5jYWxsKG5ld0NoaWxkcmVuSXRlcmFibGUpO1xuXG4gICAgaWYgKCEobmV3Q2hpbGRyZW4gIT0gbnVsbCkpIHtcbiAgICAgIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoIFwiQW4gaXRlcmFibGUgb2JqZWN0IHByb3ZpZGVkIG5vIGl0ZXJhdG9yLlwiICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHJlc3VsdGluZ0ZpcnN0Q2hpbGQgPSBudWxsO1xuICAgIHZhciBwcmV2aW91c05ld0ZpYmVyID0gbnVsbDtcbiAgICB2YXIgb2xkRmliZXIgPSBjdXJyZW50Rmlyc3RDaGlsZDtcbiAgICB2YXIgbGFzdFBsYWNlZEluZGV4ID0gMDtcbiAgICB2YXIgbmV3SWR4ID0gMDtcbiAgICB2YXIgbmV4dE9sZEZpYmVyID0gbnVsbDtcbiAgICB2YXIgc3RlcCA9IG5ld0NoaWxkcmVuLm5leHQoKTtcblxuICAgIGZvciAoOyBvbGRGaWJlciAhPT0gbnVsbCAmJiAhc3RlcC5kb25lOyBuZXdJZHgrKywgc3RlcCA9IG5ld0NoaWxkcmVuLm5leHQoKSkge1xuICAgICAgaWYgKG9sZEZpYmVyLmluZGV4ID4gbmV3SWR4KSB7XG4gICAgICAgIG5leHRPbGRGaWJlciA9IG9sZEZpYmVyO1xuICAgICAgICBvbGRGaWJlciA9IG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZXh0T2xkRmliZXIgPSBvbGRGaWJlci5zaWJsaW5nO1xuICAgICAgfVxuXG4gICAgICB2YXIgbmV3RmliZXIgPSB1cGRhdGVTbG90KHJldHVybkZpYmVyLCBvbGRGaWJlciwgc3RlcC52YWx1ZSwgbGFuZXMpO1xuXG4gICAgICBpZiAobmV3RmliZXIgPT09IG51bGwpIHtcbiAgICAgICAgLy8gVE9ETzogVGhpcyBicmVha3Mgb24gZW1wdHkgc2xvdHMgbGlrZSBudWxsIGNoaWxkcmVuLiBUaGF0J3NcbiAgICAgICAgLy8gdW5mb3J0dW5hdGUgYmVjYXVzZSBpdCB0cmlnZ2VycyB0aGUgc2xvdyBwYXRoIGFsbCB0aGUgdGltZS4gV2UgbmVlZFxuICAgICAgICAvLyBhIGJldHRlciB3YXkgdG8gY29tbXVuaWNhdGUgd2hldGhlciB0aGlzIHdhcyBhIG1pc3Mgb3IgbnVsbCxcbiAgICAgICAgLy8gYm9vbGVhbiwgdW5kZWZpbmVkLCBldGMuXG4gICAgICAgIGlmIChvbGRGaWJlciA9PT0gbnVsbCkge1xuICAgICAgICAgIG9sZEZpYmVyID0gbmV4dE9sZEZpYmVyO1xuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGlmIChzaG91bGRUcmFja1NpZGVFZmZlY3RzKSB7XG4gICAgICAgIGlmIChvbGRGaWJlciAmJiBuZXdGaWJlci5hbHRlcm5hdGUgPT09IG51bGwpIHtcbiAgICAgICAgICAvLyBXZSBtYXRjaGVkIHRoZSBzbG90LCBidXQgd2UgZGlkbid0IHJldXNlIHRoZSBleGlzdGluZyBmaWJlciwgc28gd2VcbiAgICAgICAgICAvLyBuZWVkIHRvIGRlbGV0ZSB0aGUgZXhpc3RpbmcgY2hpbGQuXG4gICAgICAgICAgZGVsZXRlQ2hpbGQocmV0dXJuRmliZXIsIG9sZEZpYmVyKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBsYXN0UGxhY2VkSW5kZXggPSBwbGFjZUNoaWxkKG5ld0ZpYmVyLCBsYXN0UGxhY2VkSW5kZXgsIG5ld0lkeCk7XG5cbiAgICAgIGlmIChwcmV2aW91c05ld0ZpYmVyID09PSBudWxsKSB7XG4gICAgICAgIC8vIFRPRE86IE1vdmUgb3V0IG9mIHRoZSBsb29wLiBUaGlzIG9ubHkgaGFwcGVucyBmb3IgdGhlIGZpcnN0IHJ1bi5cbiAgICAgICAgcmVzdWx0aW5nRmlyc3RDaGlsZCA9IG5ld0ZpYmVyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gVE9ETzogRGVmZXIgc2libGluZ3MgaWYgd2UncmUgbm90IGF0IHRoZSByaWdodCBpbmRleCBmb3IgdGhpcyBzbG90LlxuICAgICAgICAvLyBJLmUuIGlmIHdlIGhhZCBudWxsIHZhbHVlcyBiZWZvcmUsIHRoZW4gd2Ugd2FudCB0byBkZWZlciB0aGlzXG4gICAgICAgIC8vIGZvciBlYWNoIG51bGwgdmFsdWUuIEhvd2V2ZXIsIHdlIGFsc28gZG9uJ3Qgd2FudCB0byBjYWxsIHVwZGF0ZVNsb3RcbiAgICAgICAgLy8gd2l0aCB0aGUgcHJldmlvdXMgb25lLlxuICAgICAgICBwcmV2aW91c05ld0ZpYmVyLnNpYmxpbmcgPSBuZXdGaWJlcjtcbiAgICAgIH1cblxuICAgICAgcHJldmlvdXNOZXdGaWJlciA9IG5ld0ZpYmVyO1xuICAgICAgb2xkRmliZXIgPSBuZXh0T2xkRmliZXI7XG4gICAgfVxuXG4gICAgaWYgKHN0ZXAuZG9uZSkge1xuICAgICAgLy8gV2UndmUgcmVhY2hlZCB0aGUgZW5kIG9mIHRoZSBuZXcgY2hpbGRyZW4uIFdlIGNhbiBkZWxldGUgdGhlIHJlc3QuXG4gICAgICBkZWxldGVSZW1haW5pbmdDaGlsZHJlbihyZXR1cm5GaWJlciwgb2xkRmliZXIpO1xuICAgICAgcmV0dXJuIHJlc3VsdGluZ0ZpcnN0Q2hpbGQ7XG4gICAgfVxuXG4gICAgaWYgKG9sZEZpYmVyID09PSBudWxsKSB7XG4gICAgICAvLyBJZiB3ZSBkb24ndCBoYXZlIGFueSBtb3JlIGV4aXN0aW5nIGNoaWxkcmVuIHdlIGNhbiBjaG9vc2UgYSBmYXN0IHBhdGhcbiAgICAgIC8vIHNpbmNlIHRoZSByZXN0IHdpbGwgYWxsIGJlIGluc2VydGlvbnMuXG4gICAgICBmb3IgKDsgIXN0ZXAuZG9uZTsgbmV3SWR4KyssIHN0ZXAgPSBuZXdDaGlsZHJlbi5uZXh0KCkpIHtcbiAgICAgICAgdmFyIF9uZXdGaWJlcjMgPSBjcmVhdGVDaGlsZChyZXR1cm5GaWJlciwgc3RlcC52YWx1ZSwgbGFuZXMpO1xuXG4gICAgICAgIGlmIChfbmV3RmliZXIzID09PSBudWxsKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBsYXN0UGxhY2VkSW5kZXggPSBwbGFjZUNoaWxkKF9uZXdGaWJlcjMsIGxhc3RQbGFjZWRJbmRleCwgbmV3SWR4KTtcblxuICAgICAgICBpZiAocHJldmlvdXNOZXdGaWJlciA9PT0gbnVsbCkge1xuICAgICAgICAgIC8vIFRPRE86IE1vdmUgb3V0IG9mIHRoZSBsb29wLiBUaGlzIG9ubHkgaGFwcGVucyBmb3IgdGhlIGZpcnN0IHJ1bi5cbiAgICAgICAgICByZXN1bHRpbmdGaXJzdENoaWxkID0gX25ld0ZpYmVyMztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwcmV2aW91c05ld0ZpYmVyLnNpYmxpbmcgPSBfbmV3RmliZXIzO1xuICAgICAgICB9XG5cbiAgICAgICAgcHJldmlvdXNOZXdGaWJlciA9IF9uZXdGaWJlcjM7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHRpbmdGaXJzdENoaWxkO1xuICAgIH0gLy8gQWRkIGFsbCBjaGlsZHJlbiB0byBhIGtleSBtYXAgZm9yIHF1aWNrIGxvb2t1cHMuXG5cblxuICAgIHZhciBleGlzdGluZ0NoaWxkcmVuID0gbWFwUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsIG9sZEZpYmVyKTsgLy8gS2VlcCBzY2FubmluZyBhbmQgdXNlIHRoZSBtYXAgdG8gcmVzdG9yZSBkZWxldGVkIGl0ZW1zIGFzIG1vdmVzLlxuXG4gICAgZm9yICg7ICFzdGVwLmRvbmU7IG5ld0lkeCsrLCBzdGVwID0gbmV3Q2hpbGRyZW4ubmV4dCgpKSB7XG4gICAgICB2YXIgX25ld0ZpYmVyNCA9IHVwZGF0ZUZyb21NYXAoZXhpc3RpbmdDaGlsZHJlbiwgcmV0dXJuRmliZXIsIG5ld0lkeCwgc3RlcC52YWx1ZSwgbGFuZXMpO1xuXG4gICAgICBpZiAoX25ld0ZpYmVyNCAhPT0gbnVsbCkge1xuICAgICAgICBpZiAoc2hvdWxkVHJhY2tTaWRlRWZmZWN0cykge1xuICAgICAgICAgIGlmIChfbmV3RmliZXI0LmFsdGVybmF0ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gVGhlIG5ldyBmaWJlciBpcyBhIHdvcmsgaW4gcHJvZ3Jlc3MsIGJ1dCBpZiB0aGVyZSBleGlzdHMgYVxuICAgICAgICAgICAgLy8gY3VycmVudCwgdGhhdCBtZWFucyB0aGF0IHdlIHJldXNlZCB0aGUgZmliZXIuIFdlIG5lZWQgdG8gZGVsZXRlXG4gICAgICAgICAgICAvLyBpdCBmcm9tIHRoZSBjaGlsZCBsaXN0IHNvIHRoYXQgd2UgZG9uJ3QgYWRkIGl0IHRvIHRoZSBkZWxldGlvblxuICAgICAgICAgICAgLy8gbGlzdC5cbiAgICAgICAgICAgIGV4aXN0aW5nQ2hpbGRyZW4uZGVsZXRlKF9uZXdGaWJlcjQua2V5ID09PSBudWxsID8gbmV3SWR4IDogX25ld0ZpYmVyNC5rZXkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGxhc3RQbGFjZWRJbmRleCA9IHBsYWNlQ2hpbGQoX25ld0ZpYmVyNCwgbGFzdFBsYWNlZEluZGV4LCBuZXdJZHgpO1xuXG4gICAgICAgIGlmIChwcmV2aW91c05ld0ZpYmVyID09PSBudWxsKSB7XG4gICAgICAgICAgcmVzdWx0aW5nRmlyc3RDaGlsZCA9IF9uZXdGaWJlcjQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcHJldmlvdXNOZXdGaWJlci5zaWJsaW5nID0gX25ld0ZpYmVyNDtcbiAgICAgICAgfVxuXG4gICAgICAgIHByZXZpb3VzTmV3RmliZXIgPSBfbmV3RmliZXI0O1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzaG91bGRUcmFja1NpZGVFZmZlY3RzKSB7XG4gICAgICAvLyBBbnkgZXhpc3RpbmcgY2hpbGRyZW4gdGhhdCB3ZXJlbid0IGNvbnN1bWVkIGFib3ZlIHdlcmUgZGVsZXRlZC4gV2UgbmVlZFxuICAgICAgLy8gdG8gYWRkIHRoZW0gdG8gdGhlIGRlbGV0aW9uIGxpc3QuXG4gICAgICBleGlzdGluZ0NoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgIHJldHVybiBkZWxldGVDaGlsZChyZXR1cm5GaWJlciwgY2hpbGQpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdGluZ0ZpcnN0Q2hpbGQ7XG4gIH1cblxuICBmdW5jdGlvbiByZWNvbmNpbGVTaW5nbGVUZXh0Tm9kZShyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQsIHRleHRDb250ZW50LCBsYW5lcykge1xuICAgIC8vIFRoZXJlJ3Mgbm8gbmVlZCB0byBjaGVjayBmb3Iga2V5cyBvbiB0ZXh0IG5vZGVzIHNpbmNlIHdlIGRvbid0IGhhdmUgYVxuICAgIC8vIHdheSB0byBkZWZpbmUgdGhlbS5cbiAgICBpZiAoY3VycmVudEZpcnN0Q2hpbGQgIT09IG51bGwgJiYgY3VycmVudEZpcnN0Q2hpbGQudGFnID09PSBIb3N0VGV4dCkge1xuICAgICAgLy8gV2UgYWxyZWFkeSBoYXZlIGFuIGV4aXN0aW5nIG5vZGUgc28gbGV0J3MganVzdCB1cGRhdGUgaXQgYW5kIGRlbGV0ZVxuICAgICAgLy8gdGhlIHJlc3QuXG4gICAgICBkZWxldGVSZW1haW5pbmdDaGlsZHJlbihyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQuc2libGluZyk7XG4gICAgICB2YXIgZXhpc3RpbmcgPSB1c2VGaWJlcihjdXJyZW50Rmlyc3RDaGlsZCwgdGV4dENvbnRlbnQpO1xuICAgICAgZXhpc3RpbmcucmV0dXJuID0gcmV0dXJuRmliZXI7XG4gICAgICByZXR1cm4gZXhpc3Rpbmc7XG4gICAgfSAvLyBUaGUgZXhpc3RpbmcgZmlyc3QgY2hpbGQgaXMgbm90IGEgdGV4dCBub2RlIHNvIHdlIG5lZWQgdG8gY3JlYXRlIG9uZVxuICAgIC8vIGFuZCBkZWxldGUgdGhlIGV4aXN0aW5nIG9uZXMuXG5cblxuICAgIGRlbGV0ZVJlbWFpbmluZ0NoaWxkcmVuKHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCk7XG4gICAgdmFyIGNyZWF0ZWQgPSBjcmVhdGVGaWJlckZyb21UZXh0KHRleHRDb250ZW50LCByZXR1cm5GaWJlci5tb2RlLCBsYW5lcyk7XG4gICAgY3JlYXRlZC5yZXR1cm4gPSByZXR1cm5GaWJlcjtcbiAgICByZXR1cm4gY3JlYXRlZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlY29uY2lsZVNpbmdsZUVsZW1lbnQocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkLCBlbGVtZW50LCBsYW5lcykge1xuICAgIHZhciBrZXkgPSBlbGVtZW50LmtleTtcbiAgICB2YXIgY2hpbGQgPSBjdXJyZW50Rmlyc3RDaGlsZDtcblxuICAgIHdoaWxlIChjaGlsZCAhPT0gbnVsbCkge1xuICAgICAgLy8gVE9ETzogSWYga2V5ID09PSBudWxsIGFuZCBjaGlsZC5rZXkgPT09IG51bGwsIHRoZW4gdGhpcyBvbmx5IGFwcGxpZXMgdG9cbiAgICAgIC8vIHRoZSBmaXJzdCBpdGVtIGluIHRoZSBsaXN0LlxuICAgICAgaWYgKGNoaWxkLmtleSA9PT0ga2V5KSB7XG4gICAgICAgIHN3aXRjaCAoY2hpbGQudGFnKSB7XG4gICAgICAgICAgY2FzZSBGcmFnbWVudDpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgaWYgKGVsZW1lbnQudHlwZSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRSkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZVJlbWFpbmluZ0NoaWxkcmVuKHJldHVybkZpYmVyLCBjaGlsZC5zaWJsaW5nKTtcbiAgICAgICAgICAgICAgICB2YXIgZXhpc3RpbmcgPSB1c2VGaWJlcihjaGlsZCwgZWxlbWVudC5wcm9wcy5jaGlsZHJlbik7XG4gICAgICAgICAgICAgICAgZXhpc3RpbmcucmV0dXJuID0gcmV0dXJuRmliZXI7XG5cbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICBleGlzdGluZy5fZGVidWdTb3VyY2UgPSBlbGVtZW50Ll9zb3VyY2U7XG4gICAgICAgICAgICAgICAgICBleGlzdGluZy5fZGVidWdPd25lciA9IGVsZW1lbnQuX293bmVyO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBleGlzdGluZztcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgY2FzZSBCbG9jazpcblxuICAgICAgICAgIC8vIFdlIGludGVudGlvbmFsbHkgZmFsbHRocm91Z2ggaGVyZSBpZiBlbmFibGVCbG9ja3NBUEkgaXMgbm90IG9uLlxuICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZWQgbm8tZmFsbHRocm91Z2hcblxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGlmIChjaGlsZC5lbGVtZW50VHlwZSA9PT0gZWxlbWVudC50eXBlIHx8ICggLy8gS2VlcCB0aGlzIGNoZWNrIGlubGluZSBzbyBpdCBvbmx5IHJ1bnMgb24gdGhlIGZhbHNlIHBhdGg6XG4gICAgICAgICAgICAgICBpc0NvbXBhdGlibGVGYW1pbHlGb3JIb3RSZWxvYWRpbmcoY2hpbGQsIGVsZW1lbnQpICkpIHtcbiAgICAgICAgICAgICAgICBkZWxldGVSZW1haW5pbmdDaGlsZHJlbihyZXR1cm5GaWJlciwgY2hpbGQuc2libGluZyk7XG5cbiAgICAgICAgICAgICAgICB2YXIgX2V4aXN0aW5nMyA9IHVzZUZpYmVyKGNoaWxkLCBlbGVtZW50LnByb3BzKTtcblxuICAgICAgICAgICAgICAgIF9leGlzdGluZzMucmVmID0gY29lcmNlUmVmKHJldHVybkZpYmVyLCBjaGlsZCwgZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgX2V4aXN0aW5nMy5yZXR1cm4gPSByZXR1cm5GaWJlcjtcblxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIF9leGlzdGluZzMuX2RlYnVnU291cmNlID0gZWxlbWVudC5fc291cmNlO1xuICAgICAgICAgICAgICAgICAgX2V4aXN0aW5nMy5fZGVidWdPd25lciA9IGVsZW1lbnQuX293bmVyO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBfZXhpc3RpbmczO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gLy8gRGlkbid0IG1hdGNoLlxuXG5cbiAgICAgICAgZGVsZXRlUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsIGNoaWxkKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWxldGVDaGlsZChyZXR1cm5GaWJlciwgY2hpbGQpO1xuICAgICAgfVxuXG4gICAgICBjaGlsZCA9IGNoaWxkLnNpYmxpbmc7XG4gICAgfVxuXG4gICAgaWYgKGVsZW1lbnQudHlwZSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRSkge1xuICAgICAgdmFyIGNyZWF0ZWQgPSBjcmVhdGVGaWJlckZyb21GcmFnbWVudChlbGVtZW50LnByb3BzLmNoaWxkcmVuLCByZXR1cm5GaWJlci5tb2RlLCBsYW5lcywgZWxlbWVudC5rZXkpO1xuICAgICAgY3JlYXRlZC5yZXR1cm4gPSByZXR1cm5GaWJlcjtcbiAgICAgIHJldHVybiBjcmVhdGVkO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgX2NyZWF0ZWQ0ID0gY3JlYXRlRmliZXJGcm9tRWxlbWVudChlbGVtZW50LCByZXR1cm5GaWJlci5tb2RlLCBsYW5lcyk7XG5cbiAgICAgIF9jcmVhdGVkNC5yZWYgPSBjb2VyY2VSZWYocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkLCBlbGVtZW50KTtcbiAgICAgIF9jcmVhdGVkNC5yZXR1cm4gPSByZXR1cm5GaWJlcjtcbiAgICAgIHJldHVybiBfY3JlYXRlZDQ7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVjb25jaWxlU2luZ2xlUG9ydGFsKHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCwgcG9ydGFsLCBsYW5lcykge1xuICAgIHZhciBrZXkgPSBwb3J0YWwua2V5O1xuICAgIHZhciBjaGlsZCA9IGN1cnJlbnRGaXJzdENoaWxkO1xuXG4gICAgd2hpbGUgKGNoaWxkICE9PSBudWxsKSB7XG4gICAgICAvLyBUT0RPOiBJZiBrZXkgPT09IG51bGwgYW5kIGNoaWxkLmtleSA9PT0gbnVsbCwgdGhlbiB0aGlzIG9ubHkgYXBwbGllcyB0b1xuICAgICAgLy8gdGhlIGZpcnN0IGl0ZW0gaW4gdGhlIGxpc3QuXG4gICAgICBpZiAoY2hpbGQua2V5ID09PSBrZXkpIHtcbiAgICAgICAgaWYgKGNoaWxkLnRhZyA9PT0gSG9zdFBvcnRhbCAmJiBjaGlsZC5zdGF0ZU5vZGUuY29udGFpbmVySW5mbyA9PT0gcG9ydGFsLmNvbnRhaW5lckluZm8gJiYgY2hpbGQuc3RhdGVOb2RlLmltcGxlbWVudGF0aW9uID09PSBwb3J0YWwuaW1wbGVtZW50YXRpb24pIHtcbiAgICAgICAgICBkZWxldGVSZW1haW5pbmdDaGlsZHJlbihyZXR1cm5GaWJlciwgY2hpbGQuc2libGluZyk7XG4gICAgICAgICAgdmFyIGV4aXN0aW5nID0gdXNlRmliZXIoY2hpbGQsIHBvcnRhbC5jaGlsZHJlbiB8fCBbXSk7XG4gICAgICAgICAgZXhpc3RpbmcucmV0dXJuID0gcmV0dXJuRmliZXI7XG4gICAgICAgICAgcmV0dXJuIGV4aXN0aW5nO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRlbGV0ZVJlbWFpbmluZ0NoaWxkcmVuKHJldHVybkZpYmVyLCBjaGlsZCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlbGV0ZUNoaWxkKHJldHVybkZpYmVyLCBjaGlsZCk7XG4gICAgICB9XG5cbiAgICAgIGNoaWxkID0gY2hpbGQuc2libGluZztcbiAgICB9XG5cbiAgICB2YXIgY3JlYXRlZCA9IGNyZWF0ZUZpYmVyRnJvbVBvcnRhbChwb3J0YWwsIHJldHVybkZpYmVyLm1vZGUsIGxhbmVzKTtcbiAgICBjcmVhdGVkLnJldHVybiA9IHJldHVybkZpYmVyO1xuICAgIHJldHVybiBjcmVhdGVkO1xuICB9IC8vIFRoaXMgQVBJIHdpbGwgdGFnIHRoZSBjaGlsZHJlbiB3aXRoIHRoZSBzaWRlLWVmZmVjdCBvZiB0aGUgcmVjb25jaWxpYXRpb25cbiAgLy8gaXRzZWxmLiBUaGV5IHdpbGwgYmUgYWRkZWQgdG8gdGhlIHNpZGUtZWZmZWN0IGxpc3QgYXMgd2UgcGFzcyB0aHJvdWdoIHRoZVxuICAvLyBjaGlsZHJlbiBhbmQgdGhlIHBhcmVudC5cblxuXG4gIGZ1bmN0aW9uIHJlY29uY2lsZUNoaWxkRmliZXJzKHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCwgbmV3Q2hpbGQsIGxhbmVzKSB7XG4gICAgLy8gVGhpcyBmdW5jdGlvbiBpcyBub3QgcmVjdXJzaXZlLlxuICAgIC8vIElmIHRoZSB0b3AgbGV2ZWwgaXRlbSBpcyBhbiBhcnJheSwgd2UgdHJlYXQgaXQgYXMgYSBzZXQgb2YgY2hpbGRyZW4sXG4gICAgLy8gbm90IGFzIGEgZnJhZ21lbnQuIE5lc3RlZCBhcnJheXMgb24gdGhlIG90aGVyIGhhbmQgd2lsbCBiZSB0cmVhdGVkIGFzXG4gICAgLy8gZnJhZ21lbnQgbm9kZXMuIFJlY3Vyc2lvbiBoYXBwZW5zIGF0IHRoZSBub3JtYWwgZmxvdy5cbiAgICAvLyBIYW5kbGUgdG9wIGxldmVsIHVua2V5ZWQgZnJhZ21lbnRzIGFzIGlmIHRoZXkgd2VyZSBhcnJheXMuXG4gICAgLy8gVGhpcyBsZWFkcyB0byBhbiBhbWJpZ3VpdHkgYmV0d2VlbiA8PntbLi4uXX08Lz4gYW5kIDw+Li4uPC8+LlxuICAgIC8vIFdlIHRyZWF0IHRoZSBhbWJpZ3VvdXMgY2FzZXMgYWJvdmUgdGhlIHNhbWUuXG4gICAgdmFyIGlzVW5rZXllZFRvcExldmVsRnJhZ21lbnQgPSB0eXBlb2YgbmV3Q2hpbGQgPT09ICdvYmplY3QnICYmIG5ld0NoaWxkICE9PSBudWxsICYmIG5ld0NoaWxkLnR5cGUgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEUgJiYgbmV3Q2hpbGQua2V5ID09PSBudWxsO1xuXG4gICAgaWYgKGlzVW5rZXllZFRvcExldmVsRnJhZ21lbnQpIHtcbiAgICAgIG5ld0NoaWxkID0gbmV3Q2hpbGQucHJvcHMuY2hpbGRyZW47XG4gICAgfSAvLyBIYW5kbGUgb2JqZWN0IHR5cGVzXG5cblxuICAgIHZhciBpc09iamVjdCA9IHR5cGVvZiBuZXdDaGlsZCA9PT0gJ29iamVjdCcgJiYgbmV3Q2hpbGQgIT09IG51bGw7XG5cbiAgICBpZiAoaXNPYmplY3QpIHtcbiAgICAgIHN3aXRjaCAobmV3Q2hpbGQuJCR0eXBlb2YpIHtcbiAgICAgICAgY2FzZSBSRUFDVF9FTEVNRU5UX1RZUEU6XG4gICAgICAgICAgcmV0dXJuIHBsYWNlU2luZ2xlQ2hpbGQocmVjb25jaWxlU2luZ2xlRWxlbWVudChyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQsIG5ld0NoaWxkLCBsYW5lcykpO1xuXG4gICAgICAgIGNhc2UgUkVBQ1RfUE9SVEFMX1RZUEU6XG4gICAgICAgICAgcmV0dXJuIHBsYWNlU2luZ2xlQ2hpbGQocmVjb25jaWxlU2luZ2xlUG9ydGFsKHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCwgbmV3Q2hpbGQsIGxhbmVzKSk7XG5cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIG5ld0NoaWxkID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgbmV3Q2hpbGQgPT09ICdudW1iZXInKSB7XG4gICAgICByZXR1cm4gcGxhY2VTaW5nbGVDaGlsZChyZWNvbmNpbGVTaW5nbGVUZXh0Tm9kZShyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQsICcnICsgbmV3Q2hpbGQsIGxhbmVzKSk7XG4gICAgfVxuXG4gICAgaWYgKGlzQXJyYXkkMShuZXdDaGlsZCkpIHtcbiAgICAgIHJldHVybiByZWNvbmNpbGVDaGlsZHJlbkFycmF5KHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCwgbmV3Q2hpbGQsIGxhbmVzKTtcbiAgICB9XG5cbiAgICBpZiAoZ2V0SXRlcmF0b3JGbihuZXdDaGlsZCkpIHtcbiAgICAgIHJldHVybiByZWNvbmNpbGVDaGlsZHJlbkl0ZXJhdG9yKHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCwgbmV3Q2hpbGQsIGxhbmVzKTtcbiAgICB9XG5cbiAgICBpZiAoaXNPYmplY3QpIHtcbiAgICAgIHRocm93T25JbnZhbGlkT2JqZWN0VHlwZShyZXR1cm5GaWJlciwgbmV3Q2hpbGQpO1xuICAgIH1cblxuICAgIHtcbiAgICAgIGlmICh0eXBlb2YgbmV3Q2hpbGQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgd2Fybk9uRnVuY3Rpb25UeXBlKHJldHVybkZpYmVyKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIG5ld0NoaWxkID09PSAndW5kZWZpbmVkJyAmJiAhaXNVbmtleWVkVG9wTGV2ZWxGcmFnbWVudCkge1xuICAgICAgLy8gSWYgdGhlIG5ldyBjaGlsZCBpcyB1bmRlZmluZWQsIGFuZCB0aGUgcmV0dXJuIGZpYmVyIGlzIGEgY29tcG9zaXRlXG4gICAgICAvLyBjb21wb25lbnQsIHRocm93IGFuIGVycm9yLiBJZiBGaWJlciByZXR1cm4gdHlwZXMgYXJlIGRpc2FibGVkLFxuICAgICAgLy8gd2UgYWxyZWFkeSB0aHJldyBhYm92ZS5cbiAgICAgIHN3aXRjaCAocmV0dXJuRmliZXIudGFnKSB7XG4gICAgICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG4gICAgICAgICAge1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICB2YXIgaW5zdGFuY2UgPSByZXR1cm5GaWJlci5zdGF0ZU5vZGU7XG5cbiAgICAgICAgICAgICAgaWYgKGluc3RhbmNlLnJlbmRlci5faXNNb2NrRnVuY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAvLyBXZSBhbGxvdyBhdXRvLW1vY2tzIHRvIHByb2NlZWQgYXMgaWYgdGhleSdyZSByZXR1cm5pbmcgbnVsbC5cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgLy8gSW50ZW50aW9uYWxseSBmYWxsIHRocm91Z2ggdG8gdGhlIG5leHQgY2FzZSwgd2hpY2ggaGFuZGxlcyBib3RoXG4gICAgICAgIC8vIGZ1bmN0aW9ucyBhbmQgY2xhc3Nlc1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVkIG5vLWZhbGx0aHJvdWdoXG5cbiAgICAgICAgY2FzZSBCbG9jazpcbiAgICAgICAgY2FzZSBGdW5jdGlvbkNvbXBvbmVudDpcbiAgICAgICAgY2FzZSBGb3J3YXJkUmVmOlxuICAgICAgICBjYXNlIFNpbXBsZU1lbW9Db21wb25lbnQ6XG4gICAgICAgICAge1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoIChnZXRDb21wb25lbnROYW1lKHJldHVybkZpYmVyLnR5cGUpIHx8ICdDb21wb25lbnQnKSArIFwiKC4uLik6IE5vdGhpbmcgd2FzIHJldHVybmVkIGZyb20gcmVuZGVyLiBUaGlzIHVzdWFsbHkgbWVhbnMgYSByZXR1cm4gc3RhdGVtZW50IGlzIG1pc3NpbmcuIE9yLCB0byByZW5kZXIgbm90aGluZywgcmV0dXJuIG51bGwuXCIgKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9IC8vIFJlbWFpbmluZyBjYXNlcyBhcmUgYWxsIHRyZWF0ZWQgYXMgZW1wdHkuXG5cblxuICAgIHJldHVybiBkZWxldGVSZW1haW5pbmdDaGlsZHJlbihyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQpO1xuICB9XG5cbiAgcmV0dXJuIHJlY29uY2lsZUNoaWxkRmliZXJzO1xufVxuXG52YXIgcmVjb25jaWxlQ2hpbGRGaWJlcnMgPSBDaGlsZFJlY29uY2lsZXIodHJ1ZSk7XG52YXIgbW91bnRDaGlsZEZpYmVycyA9IENoaWxkUmVjb25jaWxlcihmYWxzZSk7XG5mdW5jdGlvbiBjbG9uZUNoaWxkRmliZXJzKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKSB7XG4gIGlmICghKGN1cnJlbnQgPT09IG51bGwgfHwgd29ya0luUHJvZ3Jlc3MuY2hpbGQgPT09IGN1cnJlbnQuY2hpbGQpKSB7XG4gICAge1xuICAgICAgdGhyb3cgRXJyb3IoIFwiUmVzdW1pbmcgd29yayBub3QgeWV0IGltcGxlbWVudGVkLlwiICk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHdvcmtJblByb2dyZXNzLmNoaWxkID09PSBudWxsKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGN1cnJlbnRDaGlsZCA9IHdvcmtJblByb2dyZXNzLmNoaWxkO1xuICB2YXIgbmV3Q2hpbGQgPSBjcmVhdGVXb3JrSW5Qcm9ncmVzcyhjdXJyZW50Q2hpbGQsIGN1cnJlbnRDaGlsZC5wZW5kaW5nUHJvcHMpO1xuICB3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IG5ld0NoaWxkO1xuICBuZXdDaGlsZC5yZXR1cm4gPSB3b3JrSW5Qcm9ncmVzcztcblxuICB3aGlsZSAoY3VycmVudENoaWxkLnNpYmxpbmcgIT09IG51bGwpIHtcbiAgICBjdXJyZW50Q2hpbGQgPSBjdXJyZW50Q2hpbGQuc2libGluZztcbiAgICBuZXdDaGlsZCA9IG5ld0NoaWxkLnNpYmxpbmcgPSBjcmVhdGVXb3JrSW5Qcm9ncmVzcyhjdXJyZW50Q2hpbGQsIGN1cnJlbnRDaGlsZC5wZW5kaW5nUHJvcHMpO1xuICAgIG5ld0NoaWxkLnJldHVybiA9IHdvcmtJblByb2dyZXNzO1xuICB9XG5cbiAgbmV3Q2hpbGQuc2libGluZyA9IG51bGw7XG59IC8vIFJlc2V0IGEgd29ya0luUHJvZ3Jlc3MgY2hpbGQgc2V0IHRvIHByZXBhcmUgaXQgZm9yIGEgc2Vjb25kIHBhc3MuXG5cbmZ1bmN0aW9uIHJlc2V0Q2hpbGRGaWJlcnMod29ya0luUHJvZ3Jlc3MsIGxhbmVzKSB7XG4gIHZhciBjaGlsZCA9IHdvcmtJblByb2dyZXNzLmNoaWxkO1xuXG4gIHdoaWxlIChjaGlsZCAhPT0gbnVsbCkge1xuICAgIHJlc2V0V29ya0luUHJvZ3Jlc3MoY2hpbGQsIGxhbmVzKTtcbiAgICBjaGlsZCA9IGNoaWxkLnNpYmxpbmc7XG4gIH1cbn1cblxudmFyIE5PX0NPTlRFWFQgPSB7fTtcbnZhciBjb250ZXh0U3RhY2tDdXJzb3IkMSA9IGNyZWF0ZUN1cnNvcihOT19DT05URVhUKTtcbnZhciBjb250ZXh0RmliZXJTdGFja0N1cnNvciA9IGNyZWF0ZUN1cnNvcihOT19DT05URVhUKTtcbnZhciByb290SW5zdGFuY2VTdGFja0N1cnNvciA9IGNyZWF0ZUN1cnNvcihOT19DT05URVhUKTtcblxuZnVuY3Rpb24gcmVxdWlyZWRDb250ZXh0KGMpIHtcbiAgaWYgKCEoYyAhPT0gTk9fQ09OVEVYVCkpIHtcbiAgICB7XG4gICAgICB0aHJvdyBFcnJvciggXCJFeHBlY3RlZCBob3N0IGNvbnRleHQgdG8gZXhpc3QuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCIgKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYztcbn1cblxuZnVuY3Rpb24gZ2V0Um9vdEhvc3RDb250YWluZXIoKSB7XG4gIHZhciByb290SW5zdGFuY2UgPSByZXF1aXJlZENvbnRleHQocm9vdEluc3RhbmNlU3RhY2tDdXJzb3IuY3VycmVudCk7XG4gIHJldHVybiByb290SW5zdGFuY2U7XG59XG5cbmZ1bmN0aW9uIHB1c2hIb3N0Q29udGFpbmVyKGZpYmVyLCBuZXh0Um9vdEluc3RhbmNlKSB7XG4gIC8vIFB1c2ggY3VycmVudCByb290IGluc3RhbmNlIG9udG8gdGhlIHN0YWNrO1xuICAvLyBUaGlzIGFsbG93cyB1cyB0byByZXNldCByb290IHdoZW4gcG9ydGFscyBhcmUgcG9wcGVkLlxuICBwdXNoKHJvb3RJbnN0YW5jZVN0YWNrQ3Vyc29yLCBuZXh0Um9vdEluc3RhbmNlLCBmaWJlcik7IC8vIFRyYWNrIHRoZSBjb250ZXh0IGFuZCB0aGUgRmliZXIgdGhhdCBwcm92aWRlZCBpdC5cbiAgLy8gVGhpcyBlbmFibGVzIHVzIHRvIHBvcCBvbmx5IEZpYmVycyB0aGF0IHByb3ZpZGUgdW5pcXVlIGNvbnRleHRzLlxuXG4gIHB1c2goY29udGV4dEZpYmVyU3RhY2tDdXJzb3IsIGZpYmVyLCBmaWJlcik7IC8vIEZpbmFsbHksIHdlIG5lZWQgdG8gcHVzaCB0aGUgaG9zdCBjb250ZXh0IHRvIHRoZSBzdGFjay5cbiAgLy8gSG93ZXZlciwgd2UgY2FuJ3QganVzdCBjYWxsIGdldFJvb3RIb3N0Q29udGV4dCgpIGFuZCBwdXNoIGl0IGJlY2F1c2VcbiAgLy8gd2UnZCBoYXZlIGEgZGlmZmVyZW50IG51bWJlciBvZiBlbnRyaWVzIG9uIHRoZSBzdGFjayBkZXBlbmRpbmcgb25cbiAgLy8gd2hldGhlciBnZXRSb290SG9zdENvbnRleHQoKSB0aHJvd3Mgc29tZXdoZXJlIGluIHJlbmRlcmVyIGNvZGUgb3Igbm90LlxuICAvLyBTbyB3ZSBwdXNoIGFuIGVtcHR5IHZhbHVlIGZpcnN0LiBUaGlzIGxldHMgdXMgc2FmZWx5IHVud2luZCBvbiBlcnJvcnMuXG5cbiAgcHVzaChjb250ZXh0U3RhY2tDdXJzb3IkMSwgTk9fQ09OVEVYVCwgZmliZXIpO1xuICB2YXIgbmV4dFJvb3RDb250ZXh0ID0gZ2V0Um9vdEhvc3RDb250ZXh0KG5leHRSb290SW5zdGFuY2UpOyAvLyBOb3cgdGhhdCB3ZSBrbm93IHRoaXMgZnVuY3Rpb24gZG9lc24ndCB0aHJvdywgcmVwbGFjZSBpdC5cblxuICBwb3AoY29udGV4dFN0YWNrQ3Vyc29yJDEsIGZpYmVyKTtcbiAgcHVzaChjb250ZXh0U3RhY2tDdXJzb3IkMSwgbmV4dFJvb3RDb250ZXh0LCBmaWJlcik7XG59XG5cbmZ1bmN0aW9uIHBvcEhvc3RDb250YWluZXIoZmliZXIpIHtcbiAgcG9wKGNvbnRleHRTdGFja0N1cnNvciQxLCBmaWJlcik7XG4gIHBvcChjb250ZXh0RmliZXJTdGFja0N1cnNvciwgZmliZXIpO1xuICBwb3Aocm9vdEluc3RhbmNlU3RhY2tDdXJzb3IsIGZpYmVyKTtcbn1cblxuZnVuY3Rpb24gZ2V0SG9zdENvbnRleHQoKSB7XG4gIHZhciBjb250ZXh0ID0gcmVxdWlyZWRDb250ZXh0KGNvbnRleHRTdGFja0N1cnNvciQxLmN1cnJlbnQpO1xuICByZXR1cm4gY29udGV4dDtcbn1cblxuZnVuY3Rpb24gcHVzaEhvc3RDb250ZXh0KGZpYmVyKSB7XG4gIHZhciByb290SW5zdGFuY2UgPSByZXF1aXJlZENvbnRleHQocm9vdEluc3RhbmNlU3RhY2tDdXJzb3IuY3VycmVudCk7XG4gIHZhciBjb250ZXh0ID0gcmVxdWlyZWRDb250ZXh0KGNvbnRleHRTdGFja0N1cnNvciQxLmN1cnJlbnQpO1xuICB2YXIgbmV4dENvbnRleHQgPSBnZXRDaGlsZEhvc3RDb250ZXh0KGNvbnRleHQsIGZpYmVyLnR5cGUpOyAvLyBEb24ndCBwdXNoIHRoaXMgRmliZXIncyBjb250ZXh0IHVubGVzcyBpdCdzIHVuaXF1ZS5cblxuICBpZiAoY29udGV4dCA9PT0gbmV4dENvbnRleHQpIHtcbiAgICByZXR1cm47XG4gIH0gLy8gVHJhY2sgdGhlIGNvbnRleHQgYW5kIHRoZSBGaWJlciB0aGF0IHByb3ZpZGVkIGl0LlxuICAvLyBUaGlzIGVuYWJsZXMgdXMgdG8gcG9wIG9ubHkgRmliZXJzIHRoYXQgcHJvdmlkZSB1bmlxdWUgY29udGV4dHMuXG5cblxuICBwdXNoKGNvbnRleHRGaWJlclN0YWNrQ3Vyc29yLCBmaWJlciwgZmliZXIpO1xuICBwdXNoKGNvbnRleHRTdGFja0N1cnNvciQxLCBuZXh0Q29udGV4dCwgZmliZXIpO1xufVxuXG5mdW5jdGlvbiBwb3BIb3N0Q29udGV4dChmaWJlcikge1xuICAvLyBEbyBub3QgcG9wIHVubGVzcyB0aGlzIEZpYmVyIHByb3ZpZGVkIHRoZSBjdXJyZW50IGNvbnRleHQuXG4gIC8vIHB1c2hIb3N0Q29udGV4dCgpIG9ubHkgcHVzaGVzIEZpYmVycyB0aGF0IHByb3ZpZGUgdW5pcXVlIGNvbnRleHRzLlxuICBpZiAoY29udGV4dEZpYmVyU3RhY2tDdXJzb3IuY3VycmVudCAhPT0gZmliZXIpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBwb3AoY29udGV4dFN0YWNrQ3Vyc29yJDEsIGZpYmVyKTtcbiAgcG9wKGNvbnRleHRGaWJlclN0YWNrQ3Vyc29yLCBmaWJlcik7XG59XG5cbnZhciBEZWZhdWx0U3VzcGVuc2VDb250ZXh0ID0gMDsgLy8gVGhlIFN1c3BlbnNlIENvbnRleHQgaXMgc3BsaXQgaW50byB0d28gcGFydHMuIFRoZSBsb3dlciBiaXRzIGlzXG4vLyBpbmhlcml0ZWQgZGVlcGx5IGRvd24gdGhlIHN1YnRyZWUuIFRoZSB1cHBlciBiaXRzIG9ubHkgYWZmZWN0XG4vLyB0aGlzIGltbWVkaWF0ZSBzdXNwZW5zZSBib3VuZGFyeSBhbmQgZ2V0cyByZXNldCBlYWNoIG5ld1xuLy8gYm91bmRhcnkgb3Igc3VzcGVuc2UgbGlzdC5cblxudmFyIFN1YnRyZWVTdXNwZW5zZUNvbnRleHRNYXNrID0gMTsgLy8gU3VidHJlZSBGbGFnczpcbi8vIEludmlzaWJsZVBhcmVudFN1c3BlbnNlQ29udGV4dCBpbmRpY2F0ZXMgdGhhdCBvbmUgb2Ygb3VyIHBhcmVudCBTdXNwZW5zZVxuLy8gYm91bmRhcmllcyBpcyBub3QgY3VycmVudGx5IHNob3dpbmcgdmlzaWJsZSBtYWluIGNvbnRlbnQuXG4vLyBFaXRoZXIgYmVjYXVzZSBpdCBpcyBhbHJlYWR5IHNob3dpbmcgYSBmYWxsYmFjayBvciBpcyBub3QgbW91bnRlZCBhdCBhbGwuXG4vLyBXZSBjYW4gdXNlIHRoaXMgdG8gZGV0ZXJtaW5lIGlmIGl0IGlzIGRlc2lyYWJsZSB0byB0cmlnZ2VyIGEgZmFsbGJhY2sgYXRcbi8vIHRoZSBwYXJlbnQuIElmIG5vdCwgdGhlbiB3ZSBtaWdodCBuZWVkIHRvIHRyaWdnZXIgdW5kZXNpcmFibGUgYm91bmRhcmllc1xuLy8gYW5kL29yIHN1c3BlbmQgdGhlIGNvbW1pdCB0byBhdm9pZCBoaWRpbmcgdGhlIHBhcmVudCBjb250ZW50LlxuXG52YXIgSW52aXNpYmxlUGFyZW50U3VzcGVuc2VDb250ZXh0ID0gMTsgLy8gU2hhbGxvdyBGbGFnczpcbi8vIEZvcmNlU3VzcGVuc2VGYWxsYmFjayBjYW4gYmUgdXNlZCBieSBTdXNwZW5zZUxpc3QgdG8gZm9yY2UgbmV3bHkgYWRkZWRcbi8vIGl0ZW1zIGludG8gdGhlaXIgZmFsbGJhY2sgc3RhdGUgZHVyaW5nIG9uZSBvZiB0aGUgcmVuZGVyIHBhc3Nlcy5cblxudmFyIEZvcmNlU3VzcGVuc2VGYWxsYmFjayA9IDI7XG52YXIgc3VzcGVuc2VTdGFja0N1cnNvciA9IGNyZWF0ZUN1cnNvcihEZWZhdWx0U3VzcGVuc2VDb250ZXh0KTtcbmZ1bmN0aW9uIGhhc1N1c3BlbnNlQ29udGV4dChwYXJlbnRDb250ZXh0LCBmbGFnKSB7XG4gIHJldHVybiAocGFyZW50Q29udGV4dCAmIGZsYWcpICE9PSAwO1xufVxuZnVuY3Rpb24gc2V0RGVmYXVsdFNoYWxsb3dTdXNwZW5zZUNvbnRleHQocGFyZW50Q29udGV4dCkge1xuICByZXR1cm4gcGFyZW50Q29udGV4dCAmIFN1YnRyZWVTdXNwZW5zZUNvbnRleHRNYXNrO1xufVxuZnVuY3Rpb24gc2V0U2hhbGxvd1N1c3BlbnNlQ29udGV4dChwYXJlbnRDb250ZXh0LCBzaGFsbG93Q29udGV4dCkge1xuICByZXR1cm4gcGFyZW50Q29udGV4dCAmIFN1YnRyZWVTdXNwZW5zZUNvbnRleHRNYXNrIHwgc2hhbGxvd0NvbnRleHQ7XG59XG5mdW5jdGlvbiBhZGRTdWJ0cmVlU3VzcGVuc2VDb250ZXh0KHBhcmVudENvbnRleHQsIHN1YnRyZWVDb250ZXh0KSB7XG4gIHJldHVybiBwYXJlbnRDb250ZXh0IHwgc3VidHJlZUNvbnRleHQ7XG59XG5mdW5jdGlvbiBwdXNoU3VzcGVuc2VDb250ZXh0KGZpYmVyLCBuZXdDb250ZXh0KSB7XG4gIHB1c2goc3VzcGVuc2VTdGFja0N1cnNvciwgbmV3Q29udGV4dCwgZmliZXIpO1xufVxuZnVuY3Rpb24gcG9wU3VzcGVuc2VDb250ZXh0KGZpYmVyKSB7XG4gIHBvcChzdXNwZW5zZVN0YWNrQ3Vyc29yLCBmaWJlcik7XG59XG5cbmZ1bmN0aW9uIHNob3VsZENhcHR1cmVTdXNwZW5zZSh3b3JrSW5Qcm9ncmVzcywgaGFzSW52aXNpYmxlUGFyZW50KSB7XG4gIC8vIElmIGl0IHdhcyB0aGUgcHJpbWFyeSBjaGlsZHJlbiB0aGF0IGp1c3Qgc3VzcGVuZGVkLCBjYXB0dXJlIGFuZCByZW5kZXIgdGhlXG4gIC8vIGZhbGxiYWNrLiBPdGhlcndpc2UsIGRvbid0IGNhcHR1cmUgYW5kIGJ1YmJsZSB0byB0aGUgbmV4dCBib3VuZGFyeS5cbiAgdmFyIG5leHRTdGF0ZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG5cbiAgaWYgKG5leHRTdGF0ZSAhPT0gbnVsbCkge1xuICAgIGlmIChuZXh0U3RhdGUuZGVoeWRyYXRlZCAhPT0gbnVsbCkge1xuICAgICAgLy8gQSBkZWh5ZHJhdGVkIGJvdW5kYXJ5IGFsd2F5cyBjYXB0dXJlcy5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBwcm9wcyA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkUHJvcHM7IC8vIEluIG9yZGVyIHRvIGNhcHR1cmUsIHRoZSBTdXNwZW5zZSBjb21wb25lbnQgbXVzdCBoYXZlIGEgZmFsbGJhY2sgcHJvcC5cblxuICBpZiAocHJvcHMuZmFsbGJhY2sgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSAvLyBSZWd1bGFyIGJvdW5kYXJpZXMgYWx3YXlzIGNhcHR1cmUuXG5cblxuICBpZiAocHJvcHMudW5zdGFibGVfYXZvaWRUaGlzRmFsbGJhY2sgIT09IHRydWUpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSAvLyBJZiBpdCdzIGEgYm91bmRhcnkgd2Ugc2hvdWxkIGF2b2lkLCB0aGVuIHdlIHByZWZlciB0byBidWJibGUgdXAgdG8gdGhlXG4gIC8vIHBhcmVudCBib3VuZGFyeSBpZiBpdCBpcyBjdXJyZW50bHkgaW52aXNpYmxlLlxuXG5cbiAgaWYgKGhhc0ludmlzaWJsZVBhcmVudCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSAvLyBJZiB0aGUgcGFyZW50IGlzIG5vdCBhYmxlIHRvIGhhbmRsZSBpdCwgd2UgbXVzdCBoYW5kbGUgaXQuXG5cblxuICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGZpbmRGaXJzdFN1c3BlbmRlZChyb3cpIHtcbiAgdmFyIG5vZGUgPSByb3c7XG5cbiAgd2hpbGUgKG5vZGUgIT09IG51bGwpIHtcbiAgICBpZiAobm9kZS50YWcgPT09IFN1c3BlbnNlQ29tcG9uZW50KSB7XG4gICAgICB2YXIgc3RhdGUgPSBub2RlLm1lbW9pemVkU3RhdGU7XG5cbiAgICAgIGlmIChzdGF0ZSAhPT0gbnVsbCkge1xuICAgICAgICB2YXIgZGVoeWRyYXRlZCA9IHN0YXRlLmRlaHlkcmF0ZWQ7XG5cbiAgICAgICAgaWYgKGRlaHlkcmF0ZWQgPT09IG51bGwgfHwgaXNTdXNwZW5zZUluc3RhbmNlUGVuZGluZyhkZWh5ZHJhdGVkKSB8fCBpc1N1c3BlbnNlSW5zdGFuY2VGYWxsYmFjayhkZWh5ZHJhdGVkKSkge1xuICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChub2RlLnRhZyA9PT0gU3VzcGVuc2VMaXN0Q29tcG9uZW50ICYmIC8vIHJldmVhbE9yZGVyIHVuZGVmaW5lZCBjYW4ndCBiZSB0cnVzdGVkIGJlY2F1c2UgaXQgZG9uJ3RcbiAgICAvLyBrZWVwIHRyYWNrIG9mIHdoZXRoZXIgaXQgc3VzcGVuZGVkIG9yIG5vdC5cbiAgICBub2RlLm1lbW9pemVkUHJvcHMucmV2ZWFsT3JkZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdmFyIGRpZFN1c3BlbmQgPSAobm9kZS5mbGFncyAmIERpZENhcHR1cmUpICE9PSBOb0ZsYWdzO1xuXG4gICAgICBpZiAoZGlkU3VzcGVuZCkge1xuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG5vZGUuY2hpbGQgIT09IG51bGwpIHtcbiAgICAgIG5vZGUuY2hpbGQucmV0dXJuID0gbm9kZTtcbiAgICAgIG5vZGUgPSBub2RlLmNoaWxkO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKG5vZGUgPT09IHJvdykge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgd2hpbGUgKG5vZGUuc2libGluZyA9PT0gbnVsbCkge1xuICAgICAgaWYgKG5vZGUucmV0dXJuID09PSBudWxsIHx8IG5vZGUucmV0dXJuID09PSByb3cpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIG5vZGUgPSBub2RlLnJldHVybjtcbiAgICB9XG5cbiAgICBub2RlLnNpYmxpbmcucmV0dXJuID0gbm9kZS5yZXR1cm47XG4gICAgbm9kZSA9IG5vZGUuc2libGluZztcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG52YXIgTm9GbGFncyQxID1cbi8qICAqL1xuMDsgLy8gUmVwcmVzZW50cyB3aGV0aGVyIGVmZmVjdCBzaG91bGQgZmlyZS5cblxudmFyIEhhc0VmZmVjdCA9XG4vKiAqL1xuMTsgLy8gUmVwcmVzZW50cyB0aGUgcGhhc2UgaW4gd2hpY2ggdGhlIGVmZmVjdCAobm90IHRoZSBjbGVhbi11cCkgZmlyZXMuXG5cbnZhciBMYXlvdXQgPVxuLyogICAgKi9cbjI7XG52YXIgUGFzc2l2ZSQxID1cbi8qICAgKi9cbjQ7XG5cbi8vIFRoaXMgbWF5IGhhdmUgYmVlbiBhbiBpbnNlcnRpb24gb3IgYSBoeWRyYXRpb24uXG5cbnZhciBoeWRyYXRpb25QYXJlbnRGaWJlciA9IG51bGw7XG52YXIgbmV4dEh5ZHJhdGFibGVJbnN0YW5jZSA9IG51bGw7XG52YXIgaXNIeWRyYXRpbmcgPSBmYWxzZTtcblxuZnVuY3Rpb24gZW50ZXJIeWRyYXRpb25TdGF0ZShmaWJlcikge1xuXG4gIHZhciBwYXJlbnRJbnN0YW5jZSA9IGZpYmVyLnN0YXRlTm9kZS5jb250YWluZXJJbmZvO1xuICBuZXh0SHlkcmF0YWJsZUluc3RhbmNlID0gZ2V0Rmlyc3RIeWRyYXRhYmxlQ2hpbGQocGFyZW50SW5zdGFuY2UpO1xuICBoeWRyYXRpb25QYXJlbnRGaWJlciA9IGZpYmVyO1xuICBpc0h5ZHJhdGluZyA9IHRydWU7XG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBkZWxldGVIeWRyYXRhYmxlSW5zdGFuY2UocmV0dXJuRmliZXIsIGluc3RhbmNlKSB7XG4gIHtcbiAgICBzd2l0Y2ggKHJldHVybkZpYmVyLnRhZykge1xuICAgICAgY2FzZSBIb3N0Um9vdDpcbiAgICAgICAgZGlkTm90SHlkcmF0ZUNvbnRhaW5lckluc3RhbmNlKHJldHVybkZpYmVyLnN0YXRlTm9kZS5jb250YWluZXJJbmZvLCBpbnN0YW5jZSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICAgIGRpZE5vdEh5ZHJhdGVJbnN0YW5jZShyZXR1cm5GaWJlci50eXBlLCByZXR1cm5GaWJlci5tZW1vaXplZFByb3BzLCByZXR1cm5GaWJlci5zdGF0ZU5vZGUsIGluc3RhbmNlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgdmFyIGNoaWxkVG9EZWxldGUgPSBjcmVhdGVGaWJlckZyb21Ib3N0SW5zdGFuY2VGb3JEZWxldGlvbigpO1xuICBjaGlsZFRvRGVsZXRlLnN0YXRlTm9kZSA9IGluc3RhbmNlO1xuICBjaGlsZFRvRGVsZXRlLnJldHVybiA9IHJldHVybkZpYmVyO1xuICBjaGlsZFRvRGVsZXRlLmZsYWdzID0gRGVsZXRpb247IC8vIFRoaXMgbWlnaHQgc2VlbSBsaWtlIGl0IGJlbG9uZ3Mgb24gcHJvZ3Jlc3NlZEZpcnN0RGVsZXRpb24uIEhvd2V2ZXIsXG4gIC8vIHRoZXNlIGNoaWxkcmVuIGFyZSBub3QgcGFydCBvZiB0aGUgcmVjb25jaWxpYXRpb24gbGlzdCBvZiBjaGlsZHJlbi5cbiAgLy8gRXZlbiBpZiB3ZSBhYm9ydCBhbmQgcmVyZWNvbmNpbGUgdGhlIGNoaWxkcmVuLCB0aGF0IHdpbGwgdHJ5IHRvIGh5ZHJhdGVcbiAgLy8gYWdhaW4gYW5kIHRoZSBub2RlcyBhcmUgc3RpbGwgaW4gdGhlIGhvc3QgdHJlZSBzbyB0aGVzZSB3aWxsIGJlXG4gIC8vIHJlY3JlYXRlZC5cblxuICBpZiAocmV0dXJuRmliZXIubGFzdEVmZmVjdCAhPT0gbnVsbCkge1xuICAgIHJldHVybkZpYmVyLmxhc3RFZmZlY3QubmV4dEVmZmVjdCA9IGNoaWxkVG9EZWxldGU7XG4gICAgcmV0dXJuRmliZXIubGFzdEVmZmVjdCA9IGNoaWxkVG9EZWxldGU7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuRmliZXIuZmlyc3RFZmZlY3QgPSByZXR1cm5GaWJlci5sYXN0RWZmZWN0ID0gY2hpbGRUb0RlbGV0ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbnNlcnROb25IeWRyYXRlZEluc3RhbmNlKHJldHVybkZpYmVyLCBmaWJlcikge1xuICBmaWJlci5mbGFncyA9IGZpYmVyLmZsYWdzICYgfkh5ZHJhdGluZyB8IFBsYWNlbWVudDtcblxuICB7XG4gICAgc3dpdGNoIChyZXR1cm5GaWJlci50YWcpIHtcbiAgICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgcGFyZW50Q29udGFpbmVyID0gcmV0dXJuRmliZXIuc3RhdGVOb2RlLmNvbnRhaW5lckluZm87XG5cbiAgICAgICAgICBzd2l0Y2ggKGZpYmVyLnRhZykge1xuICAgICAgICAgICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAgICAgICAgICB2YXIgdHlwZSA9IGZpYmVyLnR5cGU7XG4gICAgICAgICAgICAgIHZhciBwcm9wcyA9IGZpYmVyLnBlbmRpbmdQcm9wcztcbiAgICAgICAgICAgICAgZGlkTm90RmluZEh5ZHJhdGFibGVDb250YWluZXJJbnN0YW5jZShwYXJlbnRDb250YWluZXIsIHR5cGUpO1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSBIb3N0VGV4dDpcbiAgICAgICAgICAgICAgdmFyIHRleHQgPSBmaWJlci5wZW5kaW5nUHJvcHM7XG4gICAgICAgICAgICAgIGRpZE5vdEZpbmRIeWRyYXRhYmxlQ29udGFpbmVyVGV4dEluc3RhbmNlKHBhcmVudENvbnRhaW5lciwgdGV4dCk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBwYXJlbnRUeXBlID0gcmV0dXJuRmliZXIudHlwZTtcbiAgICAgICAgICB2YXIgcGFyZW50UHJvcHMgPSByZXR1cm5GaWJlci5tZW1vaXplZFByb3BzO1xuICAgICAgICAgIHZhciBwYXJlbnRJbnN0YW5jZSA9IHJldHVybkZpYmVyLnN0YXRlTm9kZTtcblxuICAgICAgICAgIHN3aXRjaCAoZmliZXIudGFnKSB7XG4gICAgICAgICAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICAgICAgICAgIHZhciBfdHlwZSA9IGZpYmVyLnR5cGU7XG4gICAgICAgICAgICAgIHZhciBfcHJvcHMgPSBmaWJlci5wZW5kaW5nUHJvcHM7XG4gICAgICAgICAgICAgIGRpZE5vdEZpbmRIeWRyYXRhYmxlSW5zdGFuY2UocGFyZW50VHlwZSwgcGFyZW50UHJvcHMsIHBhcmVudEluc3RhbmNlLCBfdHlwZSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIEhvc3RUZXh0OlxuICAgICAgICAgICAgICB2YXIgX3RleHQgPSBmaWJlci5wZW5kaW5nUHJvcHM7XG4gICAgICAgICAgICAgIGRpZE5vdEZpbmRIeWRyYXRhYmxlVGV4dEluc3RhbmNlKHBhcmVudFR5cGUsIHBhcmVudFByb3BzLCBwYXJlbnRJbnN0YW5jZSwgX3RleHQpO1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSBTdXNwZW5zZUNvbXBvbmVudDpcbiAgICAgICAgICAgICAgZGlkTm90RmluZEh5ZHJhdGFibGVTdXNwZW5zZUluc3RhbmNlKHBhcmVudFR5cGUsIHBhcmVudFByb3BzKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiB0cnlIeWRyYXRlKGZpYmVyLCBuZXh0SW5zdGFuY2UpIHtcbiAgc3dpdGNoIChmaWJlci50YWcpIHtcbiAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIHZhciB0eXBlID0gZmliZXIudHlwZTtcbiAgICAgICAgdmFyIHByb3BzID0gZmliZXIucGVuZGluZ1Byb3BzO1xuICAgICAgICB2YXIgaW5zdGFuY2UgPSBjYW5IeWRyYXRlSW5zdGFuY2UobmV4dEluc3RhbmNlLCB0eXBlKTtcblxuICAgICAgICBpZiAoaW5zdGFuY2UgIT09IG51bGwpIHtcbiAgICAgICAgICBmaWJlci5zdGF0ZU5vZGUgPSBpbnN0YW5jZTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgIGNhc2UgSG9zdFRleHQ6XG4gICAgICB7XG4gICAgICAgIHZhciB0ZXh0ID0gZmliZXIucGVuZGluZ1Byb3BzO1xuICAgICAgICB2YXIgdGV4dEluc3RhbmNlID0gY2FuSHlkcmF0ZVRleHRJbnN0YW5jZShuZXh0SW5zdGFuY2UsIHRleHQpO1xuXG4gICAgICAgIGlmICh0ZXh0SW5zdGFuY2UgIT09IG51bGwpIHtcbiAgICAgICAgICBmaWJlci5zdGF0ZU5vZGUgPSB0ZXh0SW5zdGFuY2U7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICBjYXNlIFN1c3BlbnNlQ29tcG9uZW50OlxuICAgICAge1xuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuZnVuY3Rpb24gdHJ5VG9DbGFpbU5leHRIeWRyYXRhYmxlSW5zdGFuY2UoZmliZXIpIHtcbiAgaWYgKCFpc0h5ZHJhdGluZykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBuZXh0SW5zdGFuY2UgPSBuZXh0SHlkcmF0YWJsZUluc3RhbmNlO1xuXG4gIGlmICghbmV4dEluc3RhbmNlKSB7XG4gICAgLy8gTm90aGluZyB0byBoeWRyYXRlLiBNYWtlIGl0IGFuIGluc2VydGlvbi5cbiAgICBpbnNlcnROb25IeWRyYXRlZEluc3RhbmNlKGh5ZHJhdGlvblBhcmVudEZpYmVyLCBmaWJlcik7XG4gICAgaXNIeWRyYXRpbmcgPSBmYWxzZTtcbiAgICBoeWRyYXRpb25QYXJlbnRGaWJlciA9IGZpYmVyO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBmaXJzdEF0dGVtcHRlZEluc3RhbmNlID0gbmV4dEluc3RhbmNlO1xuXG4gIGlmICghdHJ5SHlkcmF0ZShmaWJlciwgbmV4dEluc3RhbmNlKSkge1xuICAgIC8vIElmIHdlIGNhbid0IGh5ZHJhdGUgdGhpcyBpbnN0YW5jZSBsZXQncyB0cnkgdGhlIG5leHQgb25lLlxuICAgIC8vIFdlIHVzZSB0aGlzIGFzIGEgaGV1cmlzdGljLiBJdCdzIGJhc2VkIG9uIGludHVpdGlvbiBhbmQgbm90IGRhdGEgc28gaXRcbiAgICAvLyBtaWdodCBiZSBmbGF3ZWQgb3IgdW5uZWNlc3NhcnkuXG4gICAgbmV4dEluc3RhbmNlID0gZ2V0TmV4dEh5ZHJhdGFibGVTaWJsaW5nKGZpcnN0QXR0ZW1wdGVkSW5zdGFuY2UpO1xuXG4gICAgaWYgKCFuZXh0SW5zdGFuY2UgfHwgIXRyeUh5ZHJhdGUoZmliZXIsIG5leHRJbnN0YW5jZSkpIHtcbiAgICAgIC8vIE5vdGhpbmcgdG8gaHlkcmF0ZS4gTWFrZSBpdCBhbiBpbnNlcnRpb24uXG4gICAgICBpbnNlcnROb25IeWRyYXRlZEluc3RhbmNlKGh5ZHJhdGlvblBhcmVudEZpYmVyLCBmaWJlcik7XG4gICAgICBpc0h5ZHJhdGluZyA9IGZhbHNlO1xuICAgICAgaHlkcmF0aW9uUGFyZW50RmliZXIgPSBmaWJlcjtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIFdlIG1hdGNoZWQgdGhlIG5leHQgb25lLCB3ZSdsbCBub3cgYXNzdW1lIHRoYXQgdGhlIGZpcnN0IG9uZSB3YXNcbiAgICAvLyBzdXBlcmZsdW91cyBhbmQgd2UnbGwgZGVsZXRlIGl0LiBTaW5jZSB3ZSBjYW4ndCBlYWdlcmx5IGRlbGV0ZSBpdFxuICAgIC8vIHdlJ2xsIGhhdmUgdG8gc2NoZWR1bGUgYSBkZWxldGlvbi4gVG8gZG8gdGhhdCwgdGhpcyBub2RlIG5lZWRzIGEgZHVtbXlcbiAgICAvLyBmaWJlciBhc3NvY2lhdGVkIHdpdGggaXQuXG5cblxuICAgIGRlbGV0ZUh5ZHJhdGFibGVJbnN0YW5jZShoeWRyYXRpb25QYXJlbnRGaWJlciwgZmlyc3RBdHRlbXB0ZWRJbnN0YW5jZSk7XG4gIH1cblxuICBoeWRyYXRpb25QYXJlbnRGaWJlciA9IGZpYmVyO1xuICBuZXh0SHlkcmF0YWJsZUluc3RhbmNlID0gZ2V0Rmlyc3RIeWRyYXRhYmxlQ2hpbGQobmV4dEluc3RhbmNlKTtcbn1cblxuZnVuY3Rpb24gcHJlcGFyZVRvSHlkcmF0ZUhvc3RJbnN0YW5jZShmaWJlciwgcm9vdENvbnRhaW5lckluc3RhbmNlLCBob3N0Q29udGV4dCkge1xuXG4gIHZhciBpbnN0YW5jZSA9IGZpYmVyLnN0YXRlTm9kZTtcbiAgdmFyIHVwZGF0ZVBheWxvYWQgPSBoeWRyYXRlSW5zdGFuY2UoaW5zdGFuY2UsIGZpYmVyLnR5cGUsIGZpYmVyLm1lbW9pemVkUHJvcHMsIHJvb3RDb250YWluZXJJbnN0YW5jZSwgaG9zdENvbnRleHQsIGZpYmVyKTsgLy8gVE9ETzogVHlwZSB0aGlzIHNwZWNpZmljIHRvIHRoaXMgdHlwZSBvZiBjb21wb25lbnQuXG5cbiAgZmliZXIudXBkYXRlUXVldWUgPSB1cGRhdGVQYXlsb2FkOyAvLyBJZiB0aGUgdXBkYXRlIHBheWxvYWQgaW5kaWNhdGVzIHRoYXQgdGhlcmUgaXMgYSBjaGFuZ2Ugb3IgaWYgdGhlcmVcbiAgLy8gaXMgYSBuZXcgcmVmIHdlIG1hcmsgdGhpcyBhcyBhbiB1cGRhdGUuXG5cbiAgaWYgKHVwZGF0ZVBheWxvYWQgIT09IG51bGwpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gcHJlcGFyZVRvSHlkcmF0ZUhvc3RUZXh0SW5zdGFuY2UoZmliZXIpIHtcblxuICB2YXIgdGV4dEluc3RhbmNlID0gZmliZXIuc3RhdGVOb2RlO1xuICB2YXIgdGV4dENvbnRlbnQgPSBmaWJlci5tZW1vaXplZFByb3BzO1xuICB2YXIgc2hvdWxkVXBkYXRlID0gaHlkcmF0ZVRleHRJbnN0YW5jZSh0ZXh0SW5zdGFuY2UsIHRleHRDb250ZW50LCBmaWJlcik7XG5cbiAge1xuICAgIGlmIChzaG91bGRVcGRhdGUpIHtcbiAgICAgIC8vIFdlIGFzc3VtZSB0aGF0IHByZXBhcmVUb0h5ZHJhdGVIb3N0VGV4dEluc3RhbmNlIGlzIGNhbGxlZCBpbiBhIGNvbnRleHQgd2hlcmUgdGhlXG4gICAgICAvLyBoeWRyYXRpb24gcGFyZW50IGlzIHRoZSBwYXJlbnQgaG9zdCBjb21wb25lbnQgb2YgdGhpcyBob3N0IHRleHQuXG4gICAgICB2YXIgcmV0dXJuRmliZXIgPSBoeWRyYXRpb25QYXJlbnRGaWJlcjtcblxuICAgICAgaWYgKHJldHVybkZpYmVyICE9PSBudWxsKSB7XG4gICAgICAgIHN3aXRjaCAocmV0dXJuRmliZXIudGFnKSB7XG4gICAgICAgICAgY2FzZSBIb3N0Um9vdDpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgdmFyIHBhcmVudENvbnRhaW5lciA9IHJldHVybkZpYmVyLnN0YXRlTm9kZS5jb250YWluZXJJbmZvO1xuICAgICAgICAgICAgICBkaWROb3RNYXRjaEh5ZHJhdGVkQ29udGFpbmVyVGV4dEluc3RhbmNlKHBhcmVudENvbnRhaW5lciwgdGV4dEluc3RhbmNlLCB0ZXh0Q29udGVudCk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICB2YXIgcGFyZW50VHlwZSA9IHJldHVybkZpYmVyLnR5cGU7XG4gICAgICAgICAgICAgIHZhciBwYXJlbnRQcm9wcyA9IHJldHVybkZpYmVyLm1lbW9pemVkUHJvcHM7XG4gICAgICAgICAgICAgIHZhciBwYXJlbnRJbnN0YW5jZSA9IHJldHVybkZpYmVyLnN0YXRlTm9kZTtcbiAgICAgICAgICAgICAgZGlkTm90TWF0Y2hIeWRyYXRlZFRleHRJbnN0YW5jZShwYXJlbnRUeXBlLCBwYXJlbnRQcm9wcywgcGFyZW50SW5zdGFuY2UsIHRleHRJbnN0YW5jZSwgdGV4dENvbnRlbnQpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzaG91bGRVcGRhdGU7XG59XG5cbmZ1bmN0aW9uIHNraXBQYXN0RGVoeWRyYXRlZFN1c3BlbnNlSW5zdGFuY2UoZmliZXIpIHtcblxuICB2YXIgc3VzcGVuc2VTdGF0ZSA9IGZpYmVyLm1lbW9pemVkU3RhdGU7XG4gIHZhciBzdXNwZW5zZUluc3RhbmNlID0gc3VzcGVuc2VTdGF0ZSAhPT0gbnVsbCA/IHN1c3BlbnNlU3RhdGUuZGVoeWRyYXRlZCA6IG51bGw7XG5cbiAgaWYgKCFzdXNwZW5zZUluc3RhbmNlKSB7XG4gICAge1xuICAgICAgdGhyb3cgRXJyb3IoIFwiRXhwZWN0ZWQgdG8gaGF2ZSBhIGh5ZHJhdGVkIHN1c3BlbnNlIGluc3RhbmNlLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiICk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGdldE5leHRIeWRyYXRhYmxlSW5zdGFuY2VBZnRlclN1c3BlbnNlSW5zdGFuY2Uoc3VzcGVuc2VJbnN0YW5jZSk7XG59XG5cbmZ1bmN0aW9uIHBvcFRvTmV4dEhvc3RQYXJlbnQoZmliZXIpIHtcbiAgdmFyIHBhcmVudCA9IGZpYmVyLnJldHVybjtcblxuICB3aGlsZSAocGFyZW50ICE9PSBudWxsICYmIHBhcmVudC50YWcgIT09IEhvc3RDb21wb25lbnQgJiYgcGFyZW50LnRhZyAhPT0gSG9zdFJvb3QgJiYgcGFyZW50LnRhZyAhPT0gU3VzcGVuc2VDb21wb25lbnQpIHtcbiAgICBwYXJlbnQgPSBwYXJlbnQucmV0dXJuO1xuICB9XG5cbiAgaHlkcmF0aW9uUGFyZW50RmliZXIgPSBwYXJlbnQ7XG59XG5cbmZ1bmN0aW9uIHBvcEh5ZHJhdGlvblN0YXRlKGZpYmVyKSB7XG5cbiAgaWYgKGZpYmVyICE9PSBoeWRyYXRpb25QYXJlbnRGaWJlcikge1xuICAgIC8vIFdlJ3JlIGRlZXBlciB0aGFuIHRoZSBjdXJyZW50IGh5ZHJhdGlvbiBjb250ZXh0LCBpbnNpZGUgYW4gaW5zZXJ0ZWRcbiAgICAvLyB0cmVlLlxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmICghaXNIeWRyYXRpbmcpIHtcbiAgICAvLyBJZiB3ZSdyZSBub3QgY3VycmVudGx5IGh5ZHJhdGluZyBidXQgd2UncmUgaW4gYSBoeWRyYXRpb24gY29udGV4dCwgdGhlblxuICAgIC8vIHdlIHdlcmUgYW4gaW5zZXJ0aW9uIGFuZCBub3cgbmVlZCB0byBwb3AgdXAgcmVlbnRlciBoeWRyYXRpb24gb2Ygb3VyXG4gICAgLy8gc2libGluZ3MuXG4gICAgcG9wVG9OZXh0SG9zdFBhcmVudChmaWJlcik7XG4gICAgaXNIeWRyYXRpbmcgPSB0cnVlO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciB0eXBlID0gZmliZXIudHlwZTsgLy8gSWYgd2UgaGF2ZSBhbnkgcmVtYWluaW5nIGh5ZHJhdGFibGUgbm9kZXMsIHdlIG5lZWQgdG8gZGVsZXRlIHRoZW0gbm93LlxuICAvLyBXZSBvbmx5IGRvIHRoaXMgZGVlcGVyIHRoYW4gaGVhZCBhbmQgYm9keSBzaW5jZSB0aGV5IHRlbmQgdG8gaGF2ZSByYW5kb21cbiAgLy8gb3RoZXIgbm9kZXMgaW4gdGhlbS4gV2UgYWxzbyBpZ25vcmUgY29tcG9uZW50cyB3aXRoIHB1cmUgdGV4dCBjb250ZW50IGluXG4gIC8vIHNpZGUgb2YgdGhlbS5cbiAgLy8gVE9ETzogQmV0dGVyIGhldXJpc3RpYy5cblxuICBpZiAoZmliZXIudGFnICE9PSBIb3N0Q29tcG9uZW50IHx8IHR5cGUgIT09ICdoZWFkJyAmJiB0eXBlICE9PSAnYm9keScgJiYgIXNob3VsZFNldFRleHRDb250ZW50KHR5cGUsIGZpYmVyLm1lbW9pemVkUHJvcHMpKSB7XG4gICAgdmFyIG5leHRJbnN0YW5jZSA9IG5leHRIeWRyYXRhYmxlSW5zdGFuY2U7XG5cbiAgICB3aGlsZSAobmV4dEluc3RhbmNlKSB7XG4gICAgICBkZWxldGVIeWRyYXRhYmxlSW5zdGFuY2UoZmliZXIsIG5leHRJbnN0YW5jZSk7XG4gICAgICBuZXh0SW5zdGFuY2UgPSBnZXROZXh0SHlkcmF0YWJsZVNpYmxpbmcobmV4dEluc3RhbmNlKTtcbiAgICB9XG4gIH1cblxuICBwb3BUb05leHRIb3N0UGFyZW50KGZpYmVyKTtcblxuICBpZiAoZmliZXIudGFnID09PSBTdXNwZW5zZUNvbXBvbmVudCkge1xuICAgIG5leHRIeWRyYXRhYmxlSW5zdGFuY2UgPSBza2lwUGFzdERlaHlkcmF0ZWRTdXNwZW5zZUluc3RhbmNlKGZpYmVyKTtcbiAgfSBlbHNlIHtcbiAgICBuZXh0SHlkcmF0YWJsZUluc3RhbmNlID0gaHlkcmF0aW9uUGFyZW50RmliZXIgPyBnZXROZXh0SHlkcmF0YWJsZVNpYmxpbmcoZmliZXIuc3RhdGVOb2RlKSA6IG51bGw7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gcmVzZXRIeWRyYXRpb25TdGF0ZSgpIHtcblxuICBoeWRyYXRpb25QYXJlbnRGaWJlciA9IG51bGw7XG4gIG5leHRIeWRyYXRhYmxlSW5zdGFuY2UgPSBudWxsO1xuICBpc0h5ZHJhdGluZyA9IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBnZXRJc0h5ZHJhdGluZygpIHtcbiAgcmV0dXJuIGlzSHlkcmF0aW5nO1xufVxuXG4vLyBhbmQgc2hvdWxkIGJlIHJlc2V0IGJlZm9yZSBzdGFydGluZyBhIG5ldyByZW5kZXIuXG4vLyBUaGlzIHRyYWNrcyB3aGljaCBtdXRhYmxlIHNvdXJjZXMgbmVlZCB0byBiZSByZXNldCBhZnRlciBhIHJlbmRlci5cblxudmFyIHdvcmtJblByb2dyZXNzU291cmNlcyA9IFtdO1xudmFyIHJlbmRlcmVyU2lnaWwkMTtcblxue1xuICAvLyBVc2VkIHRvIGRldGVjdCBtdWx0aXBsZSByZW5kZXJlcnMgdXNpbmcgdGhlIHNhbWUgbXV0YWJsZSBzb3VyY2UuXG4gIHJlbmRlcmVyU2lnaWwkMSA9IHt9O1xufVxuXG5mdW5jdGlvbiBtYXJrU291cmNlQXNEaXJ0eShtdXRhYmxlU291cmNlKSB7XG4gIHdvcmtJblByb2dyZXNzU291cmNlcy5wdXNoKG11dGFibGVTb3VyY2UpO1xufVxuZnVuY3Rpb24gcmVzZXRXb3JrSW5Qcm9ncmVzc1ZlcnNpb25zKCkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHdvcmtJblByb2dyZXNzU291cmNlcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBtdXRhYmxlU291cmNlID0gd29ya0luUHJvZ3Jlc3NTb3VyY2VzW2ldO1xuXG4gICAge1xuICAgICAgbXV0YWJsZVNvdXJjZS5fd29ya0luUHJvZ3Jlc3NWZXJzaW9uUHJpbWFyeSA9IG51bGw7XG4gICAgfVxuICB9XG5cbiAgd29ya0luUHJvZ3Jlc3NTb3VyY2VzLmxlbmd0aCA9IDA7XG59XG5mdW5jdGlvbiBnZXRXb3JrSW5Qcm9ncmVzc1ZlcnNpb24obXV0YWJsZVNvdXJjZSkge1xuICB7XG4gICAgcmV0dXJuIG11dGFibGVTb3VyY2UuX3dvcmtJblByb2dyZXNzVmVyc2lvblByaW1hcnk7XG4gIH1cbn1cbmZ1bmN0aW9uIHNldFdvcmtJblByb2dyZXNzVmVyc2lvbihtdXRhYmxlU291cmNlLCB2ZXJzaW9uKSB7XG4gIHtcbiAgICBtdXRhYmxlU291cmNlLl93b3JrSW5Qcm9ncmVzc1ZlcnNpb25QcmltYXJ5ID0gdmVyc2lvbjtcbiAgfVxuXG4gIHdvcmtJblByb2dyZXNzU291cmNlcy5wdXNoKG11dGFibGVTb3VyY2UpO1xufVxuZnVuY3Rpb24gd2FybkFib3V0TXVsdGlwbGVSZW5kZXJlcnNERVYobXV0YWJsZVNvdXJjZSkge1xuICB7XG4gICAge1xuICAgICAgaWYgKG11dGFibGVTb3VyY2UuX2N1cnJlbnRQcmltYXJ5UmVuZGVyZXIgPT0gbnVsbCkge1xuICAgICAgICBtdXRhYmxlU291cmNlLl9jdXJyZW50UHJpbWFyeVJlbmRlcmVyID0gcmVuZGVyZXJTaWdpbCQxO1xuICAgICAgfSBlbHNlIGlmIChtdXRhYmxlU291cmNlLl9jdXJyZW50UHJpbWFyeVJlbmRlcmVyICE9PSByZW5kZXJlclNpZ2lsJDEpIHtcbiAgICAgICAgZXJyb3IoJ0RldGVjdGVkIG11bHRpcGxlIHJlbmRlcmVycyBjb25jdXJyZW50bHkgcmVuZGVyaW5nIHRoZSAnICsgJ3NhbWUgbXV0YWJsZSBzb3VyY2UuIFRoaXMgaXMgY3VycmVudGx5IHVuc3VwcG9ydGVkLicpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufSAvLyBFYWdlciByZWFkcyB0aGUgdmVyc2lvbiBvZiBhIG11dGFibGUgc291cmNlIGFuZCBzdG9yZXMgaXQgb24gdGhlIHJvb3QuXG5cbnZhciBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdEN1cnJlbnREaXNwYXRjaGVyLFxuICAgIFJlYWN0Q3VycmVudEJhdGNoQ29uZmlnJDEgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdEN1cnJlbnRCYXRjaENvbmZpZztcbnZhciBkaWRXYXJuQWJvdXRNaXNtYXRjaGVkSG9va3NGb3JDb21wb25lbnQ7XG52YXIgZGlkV2FybkFib3V0VXNlT3BhcXVlSWRlbnRpZmllcjtcblxue1xuICBkaWRXYXJuQWJvdXRVc2VPcGFxdWVJZGVudGlmaWVyID0ge307XG4gIGRpZFdhcm5BYm91dE1pc21hdGNoZWRIb29rc0ZvckNvbXBvbmVudCA9IG5ldyBTZXQoKTtcbn1cblxuLy8gVGhlc2UgYXJlIHNldCByaWdodCBiZWZvcmUgY2FsbGluZyB0aGUgY29tcG9uZW50LlxudmFyIHJlbmRlckxhbmVzID0gTm9MYW5lczsgLy8gVGhlIHdvcmstaW4tcHJvZ3Jlc3MgZmliZXIuIEkndmUgbmFtZWQgaXQgZGlmZmVyZW50bHkgdG8gZGlzdGluZ3Vpc2ggaXQgZnJvbVxuLy8gdGhlIHdvcmstaW4tcHJvZ3Jlc3MgaG9vay5cblxudmFyIGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEgPSBudWxsOyAvLyBIb29rcyBhcmUgc3RvcmVkIGFzIGEgbGlua2VkIGxpc3Qgb24gdGhlIGZpYmVyJ3MgbWVtb2l6ZWRTdGF0ZSBmaWVsZC4gVGhlXG4vLyBjdXJyZW50IGhvb2sgbGlzdCBpcyB0aGUgbGlzdCB0aGF0IGJlbG9uZ3MgdG8gdGhlIGN1cnJlbnQgZmliZXIuIFRoZVxuLy8gd29yay1pbi1wcm9ncmVzcyBob29rIGxpc3QgaXMgYSBuZXcgbGlzdCB0aGF0IHdpbGwgYmUgYWRkZWQgdG8gdGhlXG4vLyB3b3JrLWluLXByb2dyZXNzIGZpYmVyLlxuXG52YXIgY3VycmVudEhvb2sgPSBudWxsO1xudmFyIHdvcmtJblByb2dyZXNzSG9vayA9IG51bGw7IC8vIFdoZXRoZXIgYW4gdXBkYXRlIHdhcyBzY2hlZHVsZWQgYXQgYW55IHBvaW50IGR1cmluZyB0aGUgcmVuZGVyIHBoYXNlLiBUaGlzXG4vLyBkb2VzIG5vdCBnZXQgcmVzZXQgaWYgd2UgZG8gYW5vdGhlciByZW5kZXIgcGFzczsgb25seSB3aGVuIHdlJ3JlIGNvbXBsZXRlbHlcbi8vIGZpbmlzaGVkIGV2YWx1YXRpbmcgdGhpcyBjb21wb25lbnQuIFRoaXMgaXMgYW4gb3B0aW1pemF0aW9uIHNvIHdlIGtub3dcbi8vIHdoZXRoZXIgd2UgbmVlZCB0byBjbGVhciByZW5kZXIgcGhhc2UgdXBkYXRlcyBhZnRlciBhIHRocm93LlxuXG52YXIgZGlkU2NoZWR1bGVSZW5kZXJQaGFzZVVwZGF0ZSA9IGZhbHNlOyAvLyBXaGVyZSBhbiB1cGRhdGUgd2FzIHNjaGVkdWxlZCBvbmx5IGR1cmluZyB0aGUgY3VycmVudCByZW5kZXIgcGFzcy4gVGhpc1xuLy8gZ2V0cyByZXNldCBhZnRlciBlYWNoIGF0dGVtcHQuXG4vLyBUT0RPOiBNYXliZSB0aGVyZSdzIHNvbWUgd2F5IHRvIGNvbnNvbGlkYXRlIHRoaXMgd2l0aFxuLy8gYGRpZFNjaGVkdWxlUmVuZGVyUGhhc2VVcGRhdGVgLiBPciB3aXRoIGBudW1iZXJPZlJlUmVuZGVyc2AuXG5cbnZhciBkaWRTY2hlZHVsZVJlbmRlclBoYXNlVXBkYXRlRHVyaW5nVGhpc1Bhc3MgPSBmYWxzZTtcbnZhciBSRV9SRU5ERVJfTElNSVQgPSAyNTsgLy8gSW4gREVWLCB0aGlzIGlzIHRoZSBuYW1lIG9mIHRoZSBjdXJyZW50bHkgZXhlY3V0aW5nIHByaW1pdGl2ZSBob29rXG5cbnZhciBjdXJyZW50SG9va05hbWVJbkRldiA9IG51bGw7IC8vIEluIERFViwgdGhpcyBsaXN0IGVuc3VyZXMgdGhhdCBob29rcyBhcmUgY2FsbGVkIGluIHRoZSBzYW1lIG9yZGVyIGJldHdlZW4gcmVuZGVycy5cbi8vIFRoZSBsaXN0IHN0b3JlcyB0aGUgb3JkZXIgb2YgaG9va3MgdXNlZCBkdXJpbmcgdGhlIGluaXRpYWwgcmVuZGVyIChtb3VudCkuXG4vLyBTdWJzZXF1ZW50IHJlbmRlcnMgKHVwZGF0ZXMpIHJlZmVyZW5jZSB0aGlzIGxpc3QuXG5cbnZhciBob29rVHlwZXNEZXYgPSBudWxsO1xudmFyIGhvb2tUeXBlc1VwZGF0ZUluZGV4RGV2ID0gLTE7IC8vIEluIERFViwgdGhpcyB0cmFja3Mgd2hldGhlciBjdXJyZW50bHkgcmVuZGVyaW5nIGNvbXBvbmVudCBuZWVkcyB0byBpZ25vcmVcbi8vIHRoZSBkZXBlbmRlbmNpZXMgZm9yIEhvb2tzIHRoYXQgbmVlZCB0aGVtIChlLmcuIHVzZUVmZmVjdCBvciB1c2VNZW1vKS5cbi8vIFdoZW4gdHJ1ZSwgc3VjaCBIb29rcyB3aWxsIGFsd2F5cyBiZSBcInJlbW91bnRlZFwiLiBPbmx5IHVzZWQgZHVyaW5nIGhvdCByZWxvYWQuXG5cbnZhciBpZ25vcmVQcmV2aW91c0RlcGVuZGVuY2llcyA9IGZhbHNlO1xuXG5mdW5jdGlvbiBtb3VudEhvb2tUeXBlc0RldigpIHtcbiAge1xuICAgIHZhciBob29rTmFtZSA9IGN1cnJlbnRIb29rTmFtZUluRGV2O1xuXG4gICAgaWYgKGhvb2tUeXBlc0RldiA9PT0gbnVsbCkge1xuICAgICAgaG9va1R5cGVzRGV2ID0gW2hvb2tOYW1lXTtcbiAgICB9IGVsc2Uge1xuICAgICAgaG9va1R5cGVzRGV2LnB1c2goaG9va05hbWUpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiB1cGRhdGVIb29rVHlwZXNEZXYoKSB7XG4gIHtcbiAgICB2YXIgaG9va05hbWUgPSBjdXJyZW50SG9va05hbWVJbkRldjtcblxuICAgIGlmIChob29rVHlwZXNEZXYgIT09IG51bGwpIHtcbiAgICAgIGhvb2tUeXBlc1VwZGF0ZUluZGV4RGV2Kys7XG5cbiAgICAgIGlmIChob29rVHlwZXNEZXZbaG9va1R5cGVzVXBkYXRlSW5kZXhEZXZdICE9PSBob29rTmFtZSkge1xuICAgICAgICB3YXJuT25Ib29rTWlzbWF0Y2hJbkRldihob29rTmFtZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNoZWNrRGVwc0FyZUFycmF5RGV2KGRlcHMpIHtcbiAge1xuICAgIGlmIChkZXBzICE9PSB1bmRlZmluZWQgJiYgZGVwcyAhPT0gbnVsbCAmJiAhQXJyYXkuaXNBcnJheShkZXBzKSkge1xuICAgICAgLy8gVmVyaWZ5IGRlcHMsIGJ1dCBvbmx5IG9uIG1vdW50IHRvIGF2b2lkIGV4dHJhIGNoZWNrcy5cbiAgICAgIC8vIEl0J3MgdW5saWtlbHkgdGhlaXIgdHlwZSB3b3VsZCBjaGFuZ2UgYXMgdXN1YWxseSB5b3UgZGVmaW5lIHRoZW0gaW5saW5lLlxuICAgICAgZXJyb3IoJyVzIHJlY2VpdmVkIGEgZmluYWwgYXJndW1lbnQgdGhhdCBpcyBub3QgYW4gYXJyYXkgKGluc3RlYWQsIHJlY2VpdmVkIGAlc2ApLiBXaGVuICcgKyAnc3BlY2lmaWVkLCB0aGUgZmluYWwgYXJndW1lbnQgbXVzdCBiZSBhbiBhcnJheS4nLCBjdXJyZW50SG9va05hbWVJbkRldiwgdHlwZW9mIGRlcHMpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiB3YXJuT25Ib29rTWlzbWF0Y2hJbkRldihjdXJyZW50SG9va05hbWUpIHtcbiAge1xuICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZShjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLnR5cGUpO1xuXG4gICAgaWYgKCFkaWRXYXJuQWJvdXRNaXNtYXRjaGVkSG9va3NGb3JDb21wb25lbnQuaGFzKGNvbXBvbmVudE5hbWUpKSB7XG4gICAgICBkaWRXYXJuQWJvdXRNaXNtYXRjaGVkSG9va3NGb3JDb21wb25lbnQuYWRkKGNvbXBvbmVudE5hbWUpO1xuXG4gICAgICBpZiAoaG9va1R5cGVzRGV2ICE9PSBudWxsKSB7XG4gICAgICAgIHZhciB0YWJsZSA9ICcnO1xuICAgICAgICB2YXIgc2Vjb25kQ29sdW1uU3RhcnQgPSAzMDtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8PSBob29rVHlwZXNVcGRhdGVJbmRleERldjsgaSsrKSB7XG4gICAgICAgICAgdmFyIG9sZEhvb2tOYW1lID0gaG9va1R5cGVzRGV2W2ldO1xuICAgICAgICAgIHZhciBuZXdIb29rTmFtZSA9IGkgPT09IGhvb2tUeXBlc1VwZGF0ZUluZGV4RGV2ID8gY3VycmVudEhvb2tOYW1lIDogb2xkSG9va05hbWU7XG4gICAgICAgICAgdmFyIHJvdyA9IGkgKyAxICsgXCIuIFwiICsgb2xkSG9va05hbWU7IC8vIEV4dHJhIHNwYWNlIHNvIHNlY29uZCBjb2x1bW4gbGluZXMgdXBcbiAgICAgICAgICAvLyBsb2wgQCBJRSBub3Qgc3VwcG9ydGluZyBTdHJpbmcjcmVwZWF0XG5cbiAgICAgICAgICB3aGlsZSAocm93Lmxlbmd0aCA8IHNlY29uZENvbHVtblN0YXJ0KSB7XG4gICAgICAgICAgICByb3cgKz0gJyAnO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJvdyArPSBuZXdIb29rTmFtZSArICdcXG4nO1xuICAgICAgICAgIHRhYmxlICs9IHJvdztcbiAgICAgICAgfVxuXG4gICAgICAgIGVycm9yKCdSZWFjdCBoYXMgZGV0ZWN0ZWQgYSBjaGFuZ2UgaW4gdGhlIG9yZGVyIG9mIEhvb2tzIGNhbGxlZCBieSAlcy4gJyArICdUaGlzIHdpbGwgbGVhZCB0byBidWdzIGFuZCBlcnJvcnMgaWYgbm90IGZpeGVkLiAnICsgJ0ZvciBtb3JlIGluZm9ybWF0aW9uLCByZWFkIHRoZSBSdWxlcyBvZiBIb29rczogaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3J1bGVzLW9mLWhvb2tzXFxuXFxuJyArICcgICBQcmV2aW91cyByZW5kZXIgICAgICAgICAgICBOZXh0IHJlbmRlclxcbicgKyAnICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuJyArICclcycgKyAnICAgXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXFxuJywgY29tcG9uZW50TmFtZSwgdGFibGUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiB0aHJvd0ludmFsaWRIb29rRXJyb3IoKSB7XG4gIHtcbiAgICB7XG4gICAgICB0aHJvdyBFcnJvciggXCJJbnZhbGlkIGhvb2sgY2FsbC4gSG9va3MgY2FuIG9ubHkgYmUgY2FsbGVkIGluc2lkZSBvZiB0aGUgYm9keSBvZiBhIGZ1bmN0aW9uIGNvbXBvbmVudC4gVGhpcyBjb3VsZCBoYXBwZW4gZm9yIG9uZSBvZiB0aGUgZm9sbG93aW5nIHJlYXNvbnM6XFxuMS4gWW91IG1pZ2h0IGhhdmUgbWlzbWF0Y2hpbmcgdmVyc2lvbnMgb2YgUmVhY3QgYW5kIHRoZSByZW5kZXJlciAoc3VjaCBhcyBSZWFjdCBET00pXFxuMi4gWW91IG1pZ2h0IGJlIGJyZWFraW5nIHRoZSBSdWxlcyBvZiBIb29rc1xcbjMuIFlvdSBtaWdodCBoYXZlIG1vcmUgdGhhbiBvbmUgY29weSBvZiBSZWFjdCBpbiB0aGUgc2FtZSBhcHBcXG5TZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL2ludmFsaWQtaG9vay1jYWxsIGZvciB0aXBzIGFib3V0IGhvdyB0byBkZWJ1ZyBhbmQgZml4IHRoaXMgcHJvYmxlbS5cIiApO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBhcmVIb29rSW5wdXRzRXF1YWwobmV4dERlcHMsIHByZXZEZXBzKSB7XG4gIHtcbiAgICBpZiAoaWdub3JlUHJldmlvdXNEZXBlbmRlbmNpZXMpIHtcbiAgICAgIC8vIE9ubHkgdHJ1ZSB3aGVuIHRoaXMgY29tcG9uZW50IGlzIGJlaW5nIGhvdCByZWxvYWRlZC5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBpZiAocHJldkRlcHMgPT09IG51bGwpIHtcbiAgICB7XG4gICAgICBlcnJvcignJXMgcmVjZWl2ZWQgYSBmaW5hbCBhcmd1bWVudCBkdXJpbmcgdGhpcyByZW5kZXIsIGJ1dCBub3QgZHVyaW5nICcgKyAndGhlIHByZXZpb3VzIHJlbmRlci4gRXZlbiB0aG91Z2ggdGhlIGZpbmFsIGFyZ3VtZW50IGlzIG9wdGlvbmFsLCAnICsgJ2l0cyB0eXBlIGNhbm5vdCBjaGFuZ2UgYmV0d2VlbiByZW5kZXJzLicsIGN1cnJlbnRIb29rTmFtZUluRGV2KTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB7XG4gICAgLy8gRG9uJ3QgYm90aGVyIGNvbXBhcmluZyBsZW5ndGhzIGluIHByb2QgYmVjYXVzZSB0aGVzZSBhcnJheXMgc2hvdWxkIGJlXG4gICAgLy8gcGFzc2VkIGlubGluZS5cbiAgICBpZiAobmV4dERlcHMubGVuZ3RoICE9PSBwcmV2RGVwcy5sZW5ndGgpIHtcbiAgICAgIGVycm9yKCdUaGUgZmluYWwgYXJndW1lbnQgcGFzc2VkIHRvICVzIGNoYW5nZWQgc2l6ZSBiZXR3ZWVuIHJlbmRlcnMuIFRoZSAnICsgJ29yZGVyIGFuZCBzaXplIG9mIHRoaXMgYXJyYXkgbXVzdCByZW1haW4gY29uc3RhbnQuXFxuXFxuJyArICdQcmV2aW91czogJXNcXG4nICsgJ0luY29taW5nOiAlcycsIGN1cnJlbnRIb29rTmFtZUluRGV2LCBcIltcIiArIHByZXZEZXBzLmpvaW4oJywgJykgKyBcIl1cIiwgXCJbXCIgKyBuZXh0RGVwcy5qb2luKCcsICcpICsgXCJdXCIpO1xuICAgIH1cbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcHJldkRlcHMubGVuZ3RoICYmIGkgPCBuZXh0RGVwcy5sZW5ndGg7IGkrKykge1xuICAgIGlmIChvYmplY3RJcyhuZXh0RGVwc1tpXSwgcHJldkRlcHNbaV0pKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gcmVuZGVyV2l0aEhvb2tzKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQsIHByb3BzLCBzZWNvbmRBcmcsIG5leHRSZW5kZXJMYW5lcykge1xuICByZW5kZXJMYW5lcyA9IG5leHRSZW5kZXJMYW5lcztcbiAgY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMSA9IHdvcmtJblByb2dyZXNzO1xuXG4gIHtcbiAgICBob29rVHlwZXNEZXYgPSBjdXJyZW50ICE9PSBudWxsID8gY3VycmVudC5fZGVidWdIb29rVHlwZXMgOiBudWxsO1xuICAgIGhvb2tUeXBlc1VwZGF0ZUluZGV4RGV2ID0gLTE7IC8vIFVzZWQgZm9yIGhvdCByZWxvYWRpbmc6XG5cbiAgICBpZ25vcmVQcmV2aW91c0RlcGVuZGVuY2llcyA9IGN1cnJlbnQgIT09IG51bGwgJiYgY3VycmVudC50eXBlICE9PSB3b3JrSW5Qcm9ncmVzcy50eXBlO1xuICB9XG5cbiAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IG51bGw7XG4gIHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlID0gbnVsbDtcbiAgd29ya0luUHJvZ3Jlc3MubGFuZXMgPSBOb0xhbmVzOyAvLyBUaGUgZm9sbG93aW5nIHNob3VsZCBoYXZlIGFscmVhZHkgYmVlbiByZXNldFxuICAvLyBjdXJyZW50SG9vayA9IG51bGw7XG4gIC8vIHdvcmtJblByb2dyZXNzSG9vayA9IG51bGw7XG4gIC8vIGRpZFNjaGVkdWxlUmVuZGVyUGhhc2VVcGRhdGUgPSBmYWxzZTtcbiAgLy8gVE9ETyBXYXJuIGlmIG5vIGhvb2tzIGFyZSB1c2VkIGF0IGFsbCBkdXJpbmcgbW91bnQsIHRoZW4gc29tZSBhcmUgdXNlZCBkdXJpbmcgdXBkYXRlLlxuICAvLyBDdXJyZW50bHkgd2Ugd2lsbCBpZGVudGlmeSB0aGUgdXBkYXRlIHJlbmRlciBhcyBhIG1vdW50IGJlY2F1c2UgbWVtb2l6ZWRTdGF0ZSA9PT0gbnVsbC5cbiAgLy8gVGhpcyBpcyB0cmlja3kgYmVjYXVzZSBpdCdzIHZhbGlkIGZvciBjZXJ0YWluIHR5cGVzIG9mIGNvbXBvbmVudHMgKGUuZy4gUmVhY3QubGF6eSlcbiAgLy8gVXNpbmcgbWVtb2l6ZWRTdGF0ZSB0byBkaWZmZXJlbnRpYXRlIGJldHdlZW4gbW91bnQvdXBkYXRlIG9ubHkgd29ya3MgaWYgYXQgbGVhc3Qgb25lIHN0YXRlZnVsIGhvb2sgaXMgdXNlZC5cbiAgLy8gTm9uLXN0YXRlZnVsIGhvb2tzIChlLmcuIGNvbnRleHQpIGRvbid0IGdldCBhZGRlZCB0byBtZW1vaXplZFN0YXRlLFxuICAvLyBzbyBtZW1vaXplZFN0YXRlIHdvdWxkIGJlIG51bGwgZHVyaW5nIHVwZGF0ZXMgYW5kIG1vdW50cy5cblxuICB7XG4gICAgaWYgKGN1cnJlbnQgIT09IG51bGwgJiYgY3VycmVudC5tZW1vaXplZFN0YXRlICE9PSBudWxsKSB7XG4gICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudCA9IEhvb2tzRGlzcGF0Y2hlck9uVXBkYXRlSW5ERVY7XG4gICAgfSBlbHNlIGlmIChob29rVHlwZXNEZXYgIT09IG51bGwpIHtcbiAgICAgIC8vIFRoaXMgZGlzcGF0Y2hlciBoYW5kbGVzIGFuIGVkZ2UgY2FzZSB3aGVyZSBhIGNvbXBvbmVudCBpcyB1cGRhdGluZyxcbiAgICAgIC8vIGJ1dCBubyBzdGF0ZWZ1bCBob29rcyBoYXZlIGJlZW4gdXNlZC5cbiAgICAgIC8vIFdlIHdhbnQgdG8gbWF0Y2ggdGhlIHByb2R1Y3Rpb24gY29kZSBiZWhhdmlvciAod2hpY2ggd2lsbCB1c2UgSG9va3NEaXNwYXRjaGVyT25Nb3VudCksXG4gICAgICAvLyBidXQgd2l0aCB0aGUgZXh0cmEgREVWIHZhbGlkYXRpb24gdG8gZW5zdXJlIGhvb2tzIG9yZGVyaW5nIGhhc24ndCBjaGFuZ2VkLlxuICAgICAgLy8gVGhpcyBkaXNwYXRjaGVyIGRvZXMgdGhhdC5cbiAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gSG9va3NEaXNwYXRjaGVyT25Nb3VudFdpdGhIb29rVHlwZXNJbkRFVjtcbiAgICB9IGVsc2Uge1xuICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSBIb29rc0Rpc3BhdGNoZXJPbk1vdW50SW5ERVY7XG4gICAgfVxuICB9XG5cbiAgdmFyIGNoaWxkcmVuID0gQ29tcG9uZW50KHByb3BzLCBzZWNvbmRBcmcpOyAvLyBDaGVjayBpZiB0aGVyZSB3YXMgYSByZW5kZXIgcGhhc2UgdXBkYXRlXG5cbiAgaWYgKGRpZFNjaGVkdWxlUmVuZGVyUGhhc2VVcGRhdGVEdXJpbmdUaGlzUGFzcykge1xuICAgIC8vIEtlZXAgcmVuZGVyaW5nIGluIGEgbG9vcCBmb3IgYXMgbG9uZyBhcyByZW5kZXIgcGhhc2UgdXBkYXRlcyBjb250aW51ZSB0b1xuICAgIC8vIGJlIHNjaGVkdWxlZC4gVXNlIGEgY291bnRlciB0byBwcmV2ZW50IGluZmluaXRlIGxvb3BzLlxuICAgIHZhciBudW1iZXJPZlJlUmVuZGVycyA9IDA7XG5cbiAgICBkbyB7XG4gICAgICBkaWRTY2hlZHVsZVJlbmRlclBoYXNlVXBkYXRlRHVyaW5nVGhpc1Bhc3MgPSBmYWxzZTtcblxuICAgICAgaWYgKCEobnVtYmVyT2ZSZVJlbmRlcnMgPCBSRV9SRU5ERVJfTElNSVQpKSB7XG4gICAgICAgIHtcbiAgICAgICAgICB0aHJvdyBFcnJvciggXCJUb28gbWFueSByZS1yZW5kZXJzLiBSZWFjdCBsaW1pdHMgdGhlIG51bWJlciBvZiByZW5kZXJzIHRvIHByZXZlbnQgYW4gaW5maW5pdGUgbG9vcC5cIiApO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIG51bWJlck9mUmVSZW5kZXJzICs9IDE7XG5cbiAgICAgIHtcbiAgICAgICAgLy8gRXZlbiB3aGVuIGhvdCByZWxvYWRpbmcsIGFsbG93IGRlcGVuZGVuY2llcyB0byBzdGFiaWxpemVcbiAgICAgICAgLy8gYWZ0ZXIgZmlyc3QgcmVuZGVyIHRvIHByZXZlbnQgaW5maW5pdGUgcmVuZGVyIHBoYXNlIHVwZGF0ZXMuXG4gICAgICAgIGlnbm9yZVByZXZpb3VzRGVwZW5kZW5jaWVzID0gZmFsc2U7XG4gICAgICB9IC8vIFN0YXJ0IG92ZXIgZnJvbSB0aGUgYmVnaW5uaW5nIG9mIHRoZSBsaXN0XG5cblxuICAgICAgY3VycmVudEhvb2sgPSBudWxsO1xuICAgICAgd29ya0luUHJvZ3Jlc3NIb29rID0gbnVsbDtcbiAgICAgIHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlID0gbnVsbDtcblxuICAgICAge1xuICAgICAgICAvLyBBbHNvIHZhbGlkYXRlIGhvb2sgb3JkZXIgZm9yIGNhc2NhZGluZyB1cGRhdGVzLlxuICAgICAgICBob29rVHlwZXNVcGRhdGVJbmRleERldiA9IC0xO1xuICAgICAgfVxuXG4gICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudCA9ICBIb29rc0Rpc3BhdGNoZXJPblJlcmVuZGVySW5ERVYgO1xuICAgICAgY2hpbGRyZW4gPSBDb21wb25lbnQocHJvcHMsIHNlY29uZEFyZyk7XG4gICAgfSB3aGlsZSAoZGlkU2NoZWR1bGVSZW5kZXJQaGFzZVVwZGF0ZUR1cmluZ1RoaXNQYXNzKTtcbiAgfSAvLyBXZSBjYW4gYXNzdW1lIHRoZSBwcmV2aW91cyBkaXNwYXRjaGVyIGlzIGFsd2F5cyB0aGlzIG9uZSwgc2luY2Ugd2Ugc2V0IGl0XG4gIC8vIGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlIHJlbmRlciBwaGFzZSBhbmQgdGhlcmUncyBubyByZS1lbnRyYW5jeS5cblxuXG4gIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gQ29udGV4dE9ubHlEaXNwYXRjaGVyO1xuXG4gIHtcbiAgICB3b3JrSW5Qcm9ncmVzcy5fZGVidWdIb29rVHlwZXMgPSBob29rVHlwZXNEZXY7XG4gIH0gLy8gVGhpcyBjaGVjayB1c2VzIGN1cnJlbnRIb29rIHNvIHRoYXQgaXQgd29ya3MgdGhlIHNhbWUgaW4gREVWIGFuZCBwcm9kIGJ1bmRsZXMuXG4gIC8vIGhvb2tUeXBlc0RldiBjb3VsZCBjYXRjaCBtb3JlIGNhc2VzIChlLmcuIGNvbnRleHQpIGJ1dCBvbmx5IGluIERFViBidW5kbGVzLlxuXG5cbiAgdmFyIGRpZFJlbmRlclRvb0Zld0hvb2tzID0gY3VycmVudEhvb2sgIT09IG51bGwgJiYgY3VycmVudEhvb2submV4dCAhPT0gbnVsbDtcbiAgcmVuZGVyTGFuZXMgPSBOb0xhbmVzO1xuICBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxID0gbnVsbDtcbiAgY3VycmVudEhvb2sgPSBudWxsO1xuICB3b3JrSW5Qcm9ncmVzc0hvb2sgPSBudWxsO1xuXG4gIHtcbiAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IG51bGw7XG4gICAgaG9va1R5cGVzRGV2ID0gbnVsbDtcbiAgICBob29rVHlwZXNVcGRhdGVJbmRleERldiA9IC0xO1xuICB9XG5cbiAgZGlkU2NoZWR1bGVSZW5kZXJQaGFzZVVwZGF0ZSA9IGZhbHNlO1xuXG4gIGlmICghIWRpZFJlbmRlclRvb0Zld0hvb2tzKSB7XG4gICAge1xuICAgICAgdGhyb3cgRXJyb3IoIFwiUmVuZGVyZWQgZmV3ZXIgaG9va3MgdGhhbiBleHBlY3RlZC4gVGhpcyBtYXkgYmUgY2F1c2VkIGJ5IGFuIGFjY2lkZW50YWwgZWFybHkgcmV0dXJuIHN0YXRlbWVudC5cIiApO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjaGlsZHJlbjtcbn1cbmZ1bmN0aW9uIGJhaWxvdXRIb29rcyhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbGFuZXMpIHtcbiAgd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWUgPSBjdXJyZW50LnVwZGF0ZVF1ZXVlO1xuICB3b3JrSW5Qcm9ncmVzcy5mbGFncyAmPSB+KFBhc3NpdmUgfCBVcGRhdGUpO1xuICBjdXJyZW50LmxhbmVzID0gcmVtb3ZlTGFuZXMoY3VycmVudC5sYW5lcywgbGFuZXMpO1xufVxuZnVuY3Rpb24gcmVzZXRIb29rc0FmdGVyVGhyb3coKSB7XG4gIC8vIFdlIGNhbiBhc3N1bWUgdGhlIHByZXZpb3VzIGRpc3BhdGNoZXIgaXMgYWx3YXlzIHRoaXMgb25lLCBzaW5jZSB3ZSBzZXQgaXRcbiAgLy8gYXQgdGhlIGJlZ2lubmluZyBvZiB0aGUgcmVuZGVyIHBoYXNlIGFuZCB0aGVyZSdzIG5vIHJlLWVudHJhbmN5LlxuICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudCA9IENvbnRleHRPbmx5RGlzcGF0Y2hlcjtcblxuICBpZiAoZGlkU2NoZWR1bGVSZW5kZXJQaGFzZVVwZGF0ZSkge1xuICAgIC8vIFRoZXJlIHdlcmUgcmVuZGVyIHBoYXNlIHVwZGF0ZXMuIFRoZXNlIGFyZSBvbmx5IHZhbGlkIGZvciB0aGlzIHJlbmRlclxuICAgIC8vIHBoYXNlLCB3aGljaCB3ZSBhcmUgbm93IGFib3J0aW5nLiBSZW1vdmUgdGhlIHVwZGF0ZXMgZnJvbSB0aGUgcXVldWVzIHNvXG4gICAgLy8gdGhleSBkbyBub3QgcGVyc2lzdCB0byB0aGUgbmV4dCByZW5kZXIuIERvIG5vdCByZW1vdmUgdXBkYXRlcyBmcm9tIGhvb2tzXG4gICAgLy8gdGhhdCB3ZXJlbid0IHByb2Nlc3NlZC5cbiAgICAvL1xuICAgIC8vIE9ubHkgcmVzZXQgdGhlIHVwZGF0ZXMgZnJvbSB0aGUgcXVldWUgaWYgaXQgaGFzIGEgY2xvbmUuIElmIGl0IGRvZXNcbiAgICAvLyBub3QgaGF2ZSBhIGNsb25lLCB0aGF0IG1lYW5zIGl0IHdhc24ndCBwcm9jZXNzZWQsIGFuZCB0aGUgdXBkYXRlcyB3ZXJlXG4gICAgLy8gc2NoZWR1bGVkIGJlZm9yZSB3ZSBlbnRlcmVkIHRoZSByZW5kZXIgcGhhc2UuXG4gICAgdmFyIGhvb2sgPSBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLm1lbW9pemVkU3RhdGU7XG5cbiAgICB3aGlsZSAoaG9vayAhPT0gbnVsbCkge1xuICAgICAgdmFyIHF1ZXVlID0gaG9vay5xdWV1ZTtcblxuICAgICAgaWYgKHF1ZXVlICE9PSBudWxsKSB7XG4gICAgICAgIHF1ZXVlLnBlbmRpbmcgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICBob29rID0gaG9vay5uZXh0O1xuICAgIH1cblxuICAgIGRpZFNjaGVkdWxlUmVuZGVyUGhhc2VVcGRhdGUgPSBmYWxzZTtcbiAgfVxuXG4gIHJlbmRlckxhbmVzID0gTm9MYW5lcztcbiAgY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMSA9IG51bGw7XG4gIGN1cnJlbnRIb29rID0gbnVsbDtcbiAgd29ya0luUHJvZ3Jlc3NIb29rID0gbnVsbDtcblxuICB7XG4gICAgaG9va1R5cGVzRGV2ID0gbnVsbDtcbiAgICBob29rVHlwZXNVcGRhdGVJbmRleERldiA9IC0xO1xuICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gbnVsbDtcbiAgICBpc1VwZGF0aW5nT3BhcXVlVmFsdWVJblJlbmRlclBoYXNlID0gZmFsc2U7XG4gIH1cblxuICBkaWRTY2hlZHVsZVJlbmRlclBoYXNlVXBkYXRlRHVyaW5nVGhpc1Bhc3MgPSBmYWxzZTtcbn1cblxuZnVuY3Rpb24gbW91bnRXb3JrSW5Qcm9ncmVzc0hvb2soKSB7XG4gIHZhciBob29rID0ge1xuICAgIG1lbW9pemVkU3RhdGU6IG51bGwsXG4gICAgYmFzZVN0YXRlOiBudWxsLFxuICAgIGJhc2VRdWV1ZTogbnVsbCxcbiAgICBxdWV1ZTogbnVsbCxcbiAgICBuZXh0OiBudWxsXG4gIH07XG5cbiAgaWYgKHdvcmtJblByb2dyZXNzSG9vayA9PT0gbnVsbCkge1xuICAgIC8vIFRoaXMgaXMgdGhlIGZpcnN0IGhvb2sgaW4gdGhlIGxpc3RcbiAgICBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLm1lbW9pemVkU3RhdGUgPSB3b3JrSW5Qcm9ncmVzc0hvb2sgPSBob29rO1xuICB9IGVsc2Uge1xuICAgIC8vIEFwcGVuZCB0byB0aGUgZW5kIG9mIHRoZSBsaXN0XG4gICAgd29ya0luUHJvZ3Jlc3NIb29rID0gd29ya0luUHJvZ3Jlc3NIb29rLm5leHQgPSBob29rO1xuICB9XG5cbiAgcmV0dXJuIHdvcmtJblByb2dyZXNzSG9vaztcbn1cblxuZnVuY3Rpb24gdXBkYXRlV29ya0luUHJvZ3Jlc3NIb29rKCkge1xuICAvLyBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgYm90aCBmb3IgdXBkYXRlcyBhbmQgZm9yIHJlLXJlbmRlcnMgdHJpZ2dlcmVkIGJ5IGFcbiAgLy8gcmVuZGVyIHBoYXNlIHVwZGF0ZS4gSXQgYXNzdW1lcyB0aGVyZSBpcyBlaXRoZXIgYSBjdXJyZW50IGhvb2sgd2UgY2FuXG4gIC8vIGNsb25lLCBvciBhIHdvcmstaW4tcHJvZ3Jlc3MgaG9vayBmcm9tIGEgcHJldmlvdXMgcmVuZGVyIHBhc3MgdGhhdCB3ZSBjYW5cbiAgLy8gdXNlIGFzIGEgYmFzZS4gV2hlbiB3ZSByZWFjaCB0aGUgZW5kIG9mIHRoZSBiYXNlIGxpc3QsIHdlIG11c3Qgc3dpdGNoIHRvXG4gIC8vIHRoZSBkaXNwYXRjaGVyIHVzZWQgZm9yIG1vdW50cy5cbiAgdmFyIG5leHRDdXJyZW50SG9vaztcblxuICBpZiAoY3VycmVudEhvb2sgPT09IG51bGwpIHtcbiAgICB2YXIgY3VycmVudCA9IGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEuYWx0ZXJuYXRlO1xuXG4gICAgaWYgKGN1cnJlbnQgIT09IG51bGwpIHtcbiAgICAgIG5leHRDdXJyZW50SG9vayA9IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgbmV4dEN1cnJlbnRIb29rID0gbnVsbDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgbmV4dEN1cnJlbnRIb29rID0gY3VycmVudEhvb2submV4dDtcbiAgfVxuXG4gIHZhciBuZXh0V29ya0luUHJvZ3Jlc3NIb29rO1xuXG4gIGlmICh3b3JrSW5Qcm9ncmVzc0hvb2sgPT09IG51bGwpIHtcbiAgICBuZXh0V29ya0luUHJvZ3Jlc3NIb29rID0gY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMS5tZW1vaXplZFN0YXRlO1xuICB9IGVsc2Uge1xuICAgIG5leHRXb3JrSW5Qcm9ncmVzc0hvb2sgPSB3b3JrSW5Qcm9ncmVzc0hvb2submV4dDtcbiAgfVxuXG4gIGlmIChuZXh0V29ya0luUHJvZ3Jlc3NIb29rICE9PSBudWxsKSB7XG4gICAgLy8gVGhlcmUncyBhbHJlYWR5IGEgd29yay1pbi1wcm9ncmVzcy4gUmV1c2UgaXQuXG4gICAgd29ya0luUHJvZ3Jlc3NIb29rID0gbmV4dFdvcmtJblByb2dyZXNzSG9vaztcbiAgICBuZXh0V29ya0luUHJvZ3Jlc3NIb29rID0gd29ya0luUHJvZ3Jlc3NIb29rLm5leHQ7XG4gICAgY3VycmVudEhvb2sgPSBuZXh0Q3VycmVudEhvb2s7XG4gIH0gZWxzZSB7XG4gICAgLy8gQ2xvbmUgZnJvbSB0aGUgY3VycmVudCBob29rLlxuICAgIGlmICghKG5leHRDdXJyZW50SG9vayAhPT0gbnVsbCkpIHtcbiAgICAgIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoIFwiUmVuZGVyZWQgbW9yZSBob29rcyB0aGFuIGR1cmluZyB0aGUgcHJldmlvdXMgcmVuZGVyLlwiICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY3VycmVudEhvb2sgPSBuZXh0Q3VycmVudEhvb2s7XG4gICAgdmFyIG5ld0hvb2sgPSB7XG4gICAgICBtZW1vaXplZFN0YXRlOiBjdXJyZW50SG9vay5tZW1vaXplZFN0YXRlLFxuICAgICAgYmFzZVN0YXRlOiBjdXJyZW50SG9vay5iYXNlU3RhdGUsXG4gICAgICBiYXNlUXVldWU6IGN1cnJlbnRIb29rLmJhc2VRdWV1ZSxcbiAgICAgIHF1ZXVlOiBjdXJyZW50SG9vay5xdWV1ZSxcbiAgICAgIG5leHQ6IG51bGxcbiAgICB9O1xuXG4gICAgaWYgKHdvcmtJblByb2dyZXNzSG9vayA9PT0gbnVsbCkge1xuICAgICAgLy8gVGhpcyBpcyB0aGUgZmlyc3QgaG9vayBpbiB0aGUgbGlzdC5cbiAgICAgIGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEubWVtb2l6ZWRTdGF0ZSA9IHdvcmtJblByb2dyZXNzSG9vayA9IG5ld0hvb2s7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEFwcGVuZCB0byB0aGUgZW5kIG9mIHRoZSBsaXN0LlxuICAgICAgd29ya0luUHJvZ3Jlc3NIb29rID0gd29ya0luUHJvZ3Jlc3NIb29rLm5leHQgPSBuZXdIb29rO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB3b3JrSW5Qcm9ncmVzc0hvb2s7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUZ1bmN0aW9uQ29tcG9uZW50VXBkYXRlUXVldWUoKSB7XG4gIHJldHVybiB7XG4gICAgbGFzdEVmZmVjdDogbnVsbFxuICB9O1xufVxuXG5mdW5jdGlvbiBiYXNpY1N0YXRlUmVkdWNlcihzdGF0ZSwgYWN0aW9uKSB7XG4gIC8vICRGbG93Rml4TWU6IEZsb3cgZG9lc24ndCBsaWtlIG1peGVkIHR5cGVzXG4gIHJldHVybiB0eXBlb2YgYWN0aW9uID09PSAnZnVuY3Rpb24nID8gYWN0aW9uKHN0YXRlKSA6IGFjdGlvbjtcbn1cblxuZnVuY3Rpb24gbW91bnRSZWR1Y2VyKHJlZHVjZXIsIGluaXRpYWxBcmcsIGluaXQpIHtcbiAgdmFyIGhvb2sgPSBtb3VudFdvcmtJblByb2dyZXNzSG9vaygpO1xuICB2YXIgaW5pdGlhbFN0YXRlO1xuXG4gIGlmIChpbml0ICE9PSB1bmRlZmluZWQpIHtcbiAgICBpbml0aWFsU3RhdGUgPSBpbml0KGluaXRpYWxBcmcpO1xuICB9IGVsc2Uge1xuICAgIGluaXRpYWxTdGF0ZSA9IGluaXRpYWxBcmc7XG4gIH1cblxuICBob29rLm1lbW9pemVkU3RhdGUgPSBob29rLmJhc2VTdGF0ZSA9IGluaXRpYWxTdGF0ZTtcbiAgdmFyIHF1ZXVlID0gaG9vay5xdWV1ZSA9IHtcbiAgICBwZW5kaW5nOiBudWxsLFxuICAgIGRpc3BhdGNoOiBudWxsLFxuICAgIGxhc3RSZW5kZXJlZFJlZHVjZXI6IHJlZHVjZXIsXG4gICAgbGFzdFJlbmRlcmVkU3RhdGU6IGluaXRpYWxTdGF0ZVxuICB9O1xuICB2YXIgZGlzcGF0Y2ggPSBxdWV1ZS5kaXNwYXRjaCA9IGRpc3BhdGNoQWN0aW9uLmJpbmQobnVsbCwgY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMSwgcXVldWUpO1xuICByZXR1cm4gW2hvb2subWVtb2l6ZWRTdGF0ZSwgZGlzcGF0Y2hdO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVSZWR1Y2VyKHJlZHVjZXIsIGluaXRpYWxBcmcsIGluaXQpIHtcbiAgdmFyIGhvb2sgPSB1cGRhdGVXb3JrSW5Qcm9ncmVzc0hvb2soKTtcbiAgdmFyIHF1ZXVlID0gaG9vay5xdWV1ZTtcblxuICBpZiAoIShxdWV1ZSAhPT0gbnVsbCkpIHtcbiAgICB7XG4gICAgICB0aHJvdyBFcnJvciggXCJTaG91bGQgaGF2ZSBhIHF1ZXVlLiBUaGlzIGlzIGxpa2VseSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCIgKTtcbiAgICB9XG4gIH1cblxuICBxdWV1ZS5sYXN0UmVuZGVyZWRSZWR1Y2VyID0gcmVkdWNlcjtcbiAgdmFyIGN1cnJlbnQgPSBjdXJyZW50SG9vazsgLy8gVGhlIGxhc3QgcmViYXNlIHVwZGF0ZSB0aGF0IGlzIE5PVCBwYXJ0IG9mIHRoZSBiYXNlIHN0YXRlLlxuXG4gIHZhciBiYXNlUXVldWUgPSBjdXJyZW50LmJhc2VRdWV1ZTsgLy8gVGhlIGxhc3QgcGVuZGluZyB1cGRhdGUgdGhhdCBoYXNuJ3QgYmVlbiBwcm9jZXNzZWQgeWV0LlxuXG4gIHZhciBwZW5kaW5nUXVldWUgPSBxdWV1ZS5wZW5kaW5nO1xuXG4gIGlmIChwZW5kaW5nUXVldWUgIT09IG51bGwpIHtcbiAgICAvLyBXZSBoYXZlIG5ldyB1cGRhdGVzIHRoYXQgaGF2ZW4ndCBiZWVuIHByb2Nlc3NlZCB5ZXQuXG4gICAgLy8gV2UnbGwgYWRkIHRoZW0gdG8gdGhlIGJhc2UgcXVldWUuXG4gICAgaWYgKGJhc2VRdWV1ZSAhPT0gbnVsbCkge1xuICAgICAgLy8gTWVyZ2UgdGhlIHBlbmRpbmcgcXVldWUgYW5kIHRoZSBiYXNlIHF1ZXVlLlxuICAgICAgdmFyIGJhc2VGaXJzdCA9IGJhc2VRdWV1ZS5uZXh0O1xuICAgICAgdmFyIHBlbmRpbmdGaXJzdCA9IHBlbmRpbmdRdWV1ZS5uZXh0O1xuICAgICAgYmFzZVF1ZXVlLm5leHQgPSBwZW5kaW5nRmlyc3Q7XG4gICAgICBwZW5kaW5nUXVldWUubmV4dCA9IGJhc2VGaXJzdDtcbiAgICB9XG5cbiAgICB7XG4gICAgICBpZiAoY3VycmVudC5iYXNlUXVldWUgIT09IGJhc2VRdWV1ZSkge1xuICAgICAgICAvLyBJbnRlcm5hbCBpbnZhcmlhbnQgdGhhdCBzaG91bGQgbmV2ZXIgaGFwcGVuLCBidXQgZmVhc2libHkgY291bGQgaW5cbiAgICAgICAgLy8gdGhlIGZ1dHVyZSBpZiB3ZSBpbXBsZW1lbnQgcmVzdW1pbmcsIG9yIHNvbWUgZm9ybSBvZiB0aGF0LlxuICAgICAgICBlcnJvcignSW50ZXJuYWwgZXJyb3I6IEV4cGVjdGVkIHdvcmstaW4tcHJvZ3Jlc3MgcXVldWUgdG8gYmUgYSBjbG9uZS4gJyArICdUaGlzIGlzIGEgYnVnIGluIFJlYWN0LicpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGN1cnJlbnQuYmFzZVF1ZXVlID0gYmFzZVF1ZXVlID0gcGVuZGluZ1F1ZXVlO1xuICAgIHF1ZXVlLnBlbmRpbmcgPSBudWxsO1xuICB9XG5cbiAgaWYgKGJhc2VRdWV1ZSAhPT0gbnVsbCkge1xuICAgIC8vIFdlIGhhdmUgYSBxdWV1ZSB0byBwcm9jZXNzLlxuICAgIHZhciBmaXJzdCA9IGJhc2VRdWV1ZS5uZXh0O1xuICAgIHZhciBuZXdTdGF0ZSA9IGN1cnJlbnQuYmFzZVN0YXRlO1xuICAgIHZhciBuZXdCYXNlU3RhdGUgPSBudWxsO1xuICAgIHZhciBuZXdCYXNlUXVldWVGaXJzdCA9IG51bGw7XG4gICAgdmFyIG5ld0Jhc2VRdWV1ZUxhc3QgPSBudWxsO1xuICAgIHZhciB1cGRhdGUgPSBmaXJzdDtcblxuICAgIGRvIHtcbiAgICAgIHZhciB1cGRhdGVMYW5lID0gdXBkYXRlLmxhbmU7XG5cbiAgICAgIGlmICghaXNTdWJzZXRPZkxhbmVzKHJlbmRlckxhbmVzLCB1cGRhdGVMYW5lKSkge1xuICAgICAgICAvLyBQcmlvcml0eSBpcyBpbnN1ZmZpY2llbnQuIFNraXAgdGhpcyB1cGRhdGUuIElmIHRoaXMgaXMgdGhlIGZpcnN0XG4gICAgICAgIC8vIHNraXBwZWQgdXBkYXRlLCB0aGUgcHJldmlvdXMgdXBkYXRlL3N0YXRlIGlzIHRoZSBuZXcgYmFzZVxuICAgICAgICAvLyB1cGRhdGUvc3RhdGUuXG4gICAgICAgIHZhciBjbG9uZSA9IHtcbiAgICAgICAgICBsYW5lOiB1cGRhdGVMYW5lLFxuICAgICAgICAgIGFjdGlvbjogdXBkYXRlLmFjdGlvbixcbiAgICAgICAgICBlYWdlclJlZHVjZXI6IHVwZGF0ZS5lYWdlclJlZHVjZXIsXG4gICAgICAgICAgZWFnZXJTdGF0ZTogdXBkYXRlLmVhZ2VyU3RhdGUsXG4gICAgICAgICAgbmV4dDogbnVsbFxuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChuZXdCYXNlUXVldWVMYXN0ID09PSBudWxsKSB7XG4gICAgICAgICAgbmV3QmFzZVF1ZXVlRmlyc3QgPSBuZXdCYXNlUXVldWVMYXN0ID0gY2xvbmU7XG4gICAgICAgICAgbmV3QmFzZVN0YXRlID0gbmV3U3RhdGU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbmV3QmFzZVF1ZXVlTGFzdCA9IG5ld0Jhc2VRdWV1ZUxhc3QubmV4dCA9IGNsb25lO1xuICAgICAgICB9IC8vIFVwZGF0ZSB0aGUgcmVtYWluaW5nIHByaW9yaXR5IGluIHRoZSBxdWV1ZS5cbiAgICAgICAgLy8gVE9ETzogRG9uJ3QgbmVlZCB0byBhY2N1bXVsYXRlIHRoaXMuIEluc3RlYWQsIHdlIGNhbiByZW1vdmVcbiAgICAgICAgLy8gcmVuZGVyTGFuZXMgZnJvbSB0aGUgb3JpZ2luYWwgbGFuZXMuXG5cblxuICAgICAgICBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLmxhbmVzID0gbWVyZ2VMYW5lcyhjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLmxhbmVzLCB1cGRhdGVMYW5lKTtcbiAgICAgICAgbWFya1NraXBwZWRVcGRhdGVMYW5lcyh1cGRhdGVMYW5lKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFRoaXMgdXBkYXRlIGRvZXMgaGF2ZSBzdWZmaWNpZW50IHByaW9yaXR5LlxuICAgICAgICBpZiAobmV3QmFzZVF1ZXVlTGFzdCAhPT0gbnVsbCkge1xuICAgICAgICAgIHZhciBfY2xvbmUgPSB7XG4gICAgICAgICAgICAvLyBUaGlzIHVwZGF0ZSBpcyBnb2luZyB0byBiZSBjb21taXR0ZWQgc28gd2UgbmV2ZXIgd2FudCB1bmNvbW1pdFxuICAgICAgICAgICAgLy8gaXQuIFVzaW5nIE5vTGFuZSB3b3JrcyBiZWNhdXNlIDAgaXMgYSBzdWJzZXQgb2YgYWxsIGJpdG1hc2tzLCBzb1xuICAgICAgICAgICAgLy8gdGhpcyB3aWxsIG5ldmVyIGJlIHNraXBwZWQgYnkgdGhlIGNoZWNrIGFib3ZlLlxuICAgICAgICAgICAgbGFuZTogTm9MYW5lLFxuICAgICAgICAgICAgYWN0aW9uOiB1cGRhdGUuYWN0aW9uLFxuICAgICAgICAgICAgZWFnZXJSZWR1Y2VyOiB1cGRhdGUuZWFnZXJSZWR1Y2VyLFxuICAgICAgICAgICAgZWFnZXJTdGF0ZTogdXBkYXRlLmVhZ2VyU3RhdGUsXG4gICAgICAgICAgICBuZXh0OiBudWxsXG4gICAgICAgICAgfTtcbiAgICAgICAgICBuZXdCYXNlUXVldWVMYXN0ID0gbmV3QmFzZVF1ZXVlTGFzdC5uZXh0ID0gX2Nsb25lO1xuICAgICAgICB9IC8vIFByb2Nlc3MgdGhpcyB1cGRhdGUuXG5cblxuICAgICAgICBpZiAodXBkYXRlLmVhZ2VyUmVkdWNlciA9PT0gcmVkdWNlcikge1xuICAgICAgICAgIC8vIElmIHRoaXMgdXBkYXRlIHdhcyBwcm9jZXNzZWQgZWFnZXJseSwgYW5kIGl0cyByZWR1Y2VyIG1hdGNoZXMgdGhlXG4gICAgICAgICAgLy8gY3VycmVudCByZWR1Y2VyLCB3ZSBjYW4gdXNlIHRoZSBlYWdlcmx5IGNvbXB1dGVkIHN0YXRlLlxuICAgICAgICAgIG5ld1N0YXRlID0gdXBkYXRlLmVhZ2VyU3RhdGU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIGFjdGlvbiA9IHVwZGF0ZS5hY3Rpb247XG4gICAgICAgICAgbmV3U3RhdGUgPSByZWR1Y2VyKG5ld1N0YXRlLCBhY3Rpb24pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHVwZGF0ZSA9IHVwZGF0ZS5uZXh0O1xuICAgIH0gd2hpbGUgKHVwZGF0ZSAhPT0gbnVsbCAmJiB1cGRhdGUgIT09IGZpcnN0KTtcblxuICAgIGlmIChuZXdCYXNlUXVldWVMYXN0ID09PSBudWxsKSB7XG4gICAgICBuZXdCYXNlU3RhdGUgPSBuZXdTdGF0ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgbmV3QmFzZVF1ZXVlTGFzdC5uZXh0ID0gbmV3QmFzZVF1ZXVlRmlyc3Q7XG4gICAgfSAvLyBNYXJrIHRoYXQgdGhlIGZpYmVyIHBlcmZvcm1lZCB3b3JrLCBidXQgb25seSBpZiB0aGUgbmV3IHN0YXRlIGlzXG4gICAgLy8gZGlmZmVyZW50IGZyb20gdGhlIGN1cnJlbnQgc3RhdGUuXG5cblxuICAgIGlmICghb2JqZWN0SXMobmV3U3RhdGUsIGhvb2subWVtb2l6ZWRTdGF0ZSkpIHtcbiAgICAgIG1hcmtXb3JrSW5Qcm9ncmVzc1JlY2VpdmVkVXBkYXRlKCk7XG4gICAgfVxuXG4gICAgaG9vay5tZW1vaXplZFN0YXRlID0gbmV3U3RhdGU7XG4gICAgaG9vay5iYXNlU3RhdGUgPSBuZXdCYXNlU3RhdGU7XG4gICAgaG9vay5iYXNlUXVldWUgPSBuZXdCYXNlUXVldWVMYXN0O1xuICAgIHF1ZXVlLmxhc3RSZW5kZXJlZFN0YXRlID0gbmV3U3RhdGU7XG4gIH1cblxuICB2YXIgZGlzcGF0Y2ggPSBxdWV1ZS5kaXNwYXRjaDtcbiAgcmV0dXJuIFtob29rLm1lbW9pemVkU3RhdGUsIGRpc3BhdGNoXTtcbn1cblxuZnVuY3Rpb24gcmVyZW5kZXJSZWR1Y2VyKHJlZHVjZXIsIGluaXRpYWxBcmcsIGluaXQpIHtcbiAgdmFyIGhvb2sgPSB1cGRhdGVXb3JrSW5Qcm9ncmVzc0hvb2soKTtcbiAgdmFyIHF1ZXVlID0gaG9vay5xdWV1ZTtcblxuICBpZiAoIShxdWV1ZSAhPT0gbnVsbCkpIHtcbiAgICB7XG4gICAgICB0aHJvdyBFcnJvciggXCJTaG91bGQgaGF2ZSBhIHF1ZXVlLiBUaGlzIGlzIGxpa2VseSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCIgKTtcbiAgICB9XG4gIH1cblxuICBxdWV1ZS5sYXN0UmVuZGVyZWRSZWR1Y2VyID0gcmVkdWNlcjsgLy8gVGhpcyBpcyBhIHJlLXJlbmRlci4gQXBwbHkgdGhlIG5ldyByZW5kZXIgcGhhc2UgdXBkYXRlcyB0byB0aGUgcHJldmlvdXNcbiAgLy8gd29yay1pbi1wcm9ncmVzcyBob29rLlxuXG4gIHZhciBkaXNwYXRjaCA9IHF1ZXVlLmRpc3BhdGNoO1xuICB2YXIgbGFzdFJlbmRlclBoYXNlVXBkYXRlID0gcXVldWUucGVuZGluZztcbiAgdmFyIG5ld1N0YXRlID0gaG9vay5tZW1vaXplZFN0YXRlO1xuXG4gIGlmIChsYXN0UmVuZGVyUGhhc2VVcGRhdGUgIT09IG51bGwpIHtcbiAgICAvLyBUaGUgcXVldWUgZG9lc24ndCBwZXJzaXN0IHBhc3QgdGhpcyByZW5kZXIgcGFzcy5cbiAgICBxdWV1ZS5wZW5kaW5nID0gbnVsbDtcbiAgICB2YXIgZmlyc3RSZW5kZXJQaGFzZVVwZGF0ZSA9IGxhc3RSZW5kZXJQaGFzZVVwZGF0ZS5uZXh0O1xuICAgIHZhciB1cGRhdGUgPSBmaXJzdFJlbmRlclBoYXNlVXBkYXRlO1xuXG4gICAgZG8ge1xuICAgICAgLy8gUHJvY2VzcyB0aGlzIHJlbmRlciBwaGFzZSB1cGRhdGUuIFdlIGRvbid0IGhhdmUgdG8gY2hlY2sgdGhlXG4gICAgICAvLyBwcmlvcml0eSBiZWNhdXNlIGl0IHdpbGwgYWx3YXlzIGJlIHRoZSBzYW1lIGFzIHRoZSBjdXJyZW50XG4gICAgICAvLyByZW5kZXIncy5cbiAgICAgIHZhciBhY3Rpb24gPSB1cGRhdGUuYWN0aW9uO1xuICAgICAgbmV3U3RhdGUgPSByZWR1Y2VyKG5ld1N0YXRlLCBhY3Rpb24pO1xuICAgICAgdXBkYXRlID0gdXBkYXRlLm5leHQ7XG4gICAgfSB3aGlsZSAodXBkYXRlICE9PSBmaXJzdFJlbmRlclBoYXNlVXBkYXRlKTsgLy8gTWFyayB0aGF0IHRoZSBmaWJlciBwZXJmb3JtZWQgd29yaywgYnV0IG9ubHkgaWYgdGhlIG5ldyBzdGF0ZSBpc1xuICAgIC8vIGRpZmZlcmVudCBmcm9tIHRoZSBjdXJyZW50IHN0YXRlLlxuXG5cbiAgICBpZiAoIW9iamVjdElzKG5ld1N0YXRlLCBob29rLm1lbW9pemVkU3RhdGUpKSB7XG4gICAgICBtYXJrV29ya0luUHJvZ3Jlc3NSZWNlaXZlZFVwZGF0ZSgpO1xuICAgIH1cblxuICAgIGhvb2subWVtb2l6ZWRTdGF0ZSA9IG5ld1N0YXRlOyAvLyBEb24ndCBwZXJzaXN0IHRoZSBzdGF0ZSBhY2N1bXVsYXRlZCBmcm9tIHRoZSByZW5kZXIgcGhhc2UgdXBkYXRlcyB0b1xuICAgIC8vIHRoZSBiYXNlIHN0YXRlIHVubGVzcyB0aGUgcXVldWUgaXMgZW1wdHkuXG4gICAgLy8gVE9ETzogTm90IHN1cmUgaWYgdGhpcyBpcyB0aGUgZGVzaXJlZCBzZW1hbnRpY3MsIGJ1dCBpdCdzIHdoYXQgd2VcbiAgICAvLyBkbyBmb3IgZ0RTRlAuIEkgY2FuJ3QgcmVtZW1iZXIgd2h5LlxuXG4gICAgaWYgKGhvb2suYmFzZVF1ZXVlID09PSBudWxsKSB7XG4gICAgICBob29rLmJhc2VTdGF0ZSA9IG5ld1N0YXRlO1xuICAgIH1cblxuICAgIHF1ZXVlLmxhc3RSZW5kZXJlZFN0YXRlID0gbmV3U3RhdGU7XG4gIH1cblxuICByZXR1cm4gW25ld1N0YXRlLCBkaXNwYXRjaF07XG59XG5cbmZ1bmN0aW9uIHJlYWRGcm9tVW5zdWJjcmliZWRNdXRhYmxlU291cmNlKHJvb3QsIHNvdXJjZSwgZ2V0U25hcHNob3QpIHtcbiAge1xuICAgIHdhcm5BYm91dE11bHRpcGxlUmVuZGVyZXJzREVWKHNvdXJjZSk7XG4gIH1cblxuICB2YXIgZ2V0VmVyc2lvbiA9IHNvdXJjZS5fZ2V0VmVyc2lvbjtcbiAgdmFyIHZlcnNpb24gPSBnZXRWZXJzaW9uKHNvdXJjZS5fc291cmNlKTsgLy8gSXMgaXQgc2FmZSBmb3IgdGhpcyBjb21wb25lbnQgdG8gcmVhZCBmcm9tIHRoaXMgc291cmNlIGR1cmluZyB0aGUgY3VycmVudCByZW5kZXI/XG5cbiAgdmFyIGlzU2FmZVRvUmVhZEZyb21Tb3VyY2UgPSBmYWxzZTsgLy8gQ2hlY2sgdGhlIHZlcnNpb24gZmlyc3QuXG4gIC8vIElmIHRoaXMgcmVuZGVyIGhhcyBhbHJlYWR5IGJlZW4gc3RhcnRlZCB3aXRoIGEgc3BlY2lmaWMgdmVyc2lvbixcbiAgLy8gd2UgY2FuIHVzZSBpdCBhbG9uZSB0byBkZXRlcm1pbmUgaWYgd2UgY2FuIHNhZmVseSByZWFkIGZyb20gdGhlIHNvdXJjZS5cblxuICB2YXIgY3VycmVudFJlbmRlclZlcnNpb24gPSBnZXRXb3JrSW5Qcm9ncmVzc1ZlcnNpb24oc291cmNlKTtcblxuICBpZiAoY3VycmVudFJlbmRlclZlcnNpb24gIT09IG51bGwpIHtcbiAgICAvLyBJdCdzIHNhZmUgdG8gcmVhZCBpZiB0aGUgc3RvcmUgaGFzbid0IGJlZW4gbXV0YXRlZCBzaW5jZSB0aGUgbGFzdCB0aW1lXG4gICAgLy8gd2UgcmVhZCBzb21ldGhpbmcuXG4gICAgaXNTYWZlVG9SZWFkRnJvbVNvdXJjZSA9IGN1cnJlbnRSZW5kZXJWZXJzaW9uID09PSB2ZXJzaW9uO1xuICB9IGVsc2Uge1xuICAgIC8vIElmIHRoZXJlJ3Mgbm8gdmVyc2lvbiwgdGhlbiB0aGlzIGlzIHRoZSBmaXJzdCB0aW1lIHdlJ3ZlIHJlYWQgZnJvbSB0aGVcbiAgICAvLyBzb3VyY2UgZHVyaW5nIHRoZSBjdXJyZW50IHJlbmRlciBwYXNzLCBzbyB3ZSBuZWVkIHRvIGRvIGEgYml0IG1vcmUgd29yay5cbiAgICAvLyBXaGF0IHdlIG5lZWQgdG8gZGV0ZXJtaW5lIGlzIGlmIHRoZXJlIGFyZSBhbnkgaG9va3MgdGhhdCBhbHJlYWR5XG4gICAgLy8gc3Vic2NyaWJlZCB0byB0aGUgc291cmNlLCBhbmQgaWYgc28sIHdoZXRoZXIgdGhlcmUgYXJlIGFueSBwZW5kaW5nXG4gICAgLy8gbXV0YXRpb25zIHRoYXQgaGF2ZW4ndCBiZWVuIHN5bmNocm9uaXplZCB5ZXQuXG4gICAgLy9cbiAgICAvLyBJZiB0aGVyZSBhcmUgbm8gcGVuZGluZyBtdXRhdGlvbnMsIHRoZW4gYHJvb3QubXV0YWJsZVJlYWRMYW5lc2Agd2lsbCBiZVxuICAgIC8vIGVtcHR5LCBhbmQgd2Uga25vdyB3ZSBjYW4gc2FmZWx5IHJlYWQuXG4gICAgLy9cbiAgICAvLyBJZiB0aGVyZSAqYXJlKiBwZW5kaW5nIG11dGF0aW9ucywgd2UgbWF5IHN0aWxsIGJlIGFibGUgdG8gc2FmZWx5IHJlYWRcbiAgICAvLyBpZiB0aGUgY3VycmVudGx5IHJlbmRlcmluZyBsYW5lcyBhcmUgaW5jbHVzaXZlIG9mIHRoZSBwZW5kaW5nIG11dGF0aW9uXG4gICAgLy8gbGFuZXMsIHNpbmNlIHRoYXQgZ3VhcmFudGVlcyB0aGF0IHRoZSB2YWx1ZSB3ZSdyZSBhYm91dCB0byByZWFkIGZyb21cbiAgICAvLyB0aGUgc291cmNlIGlzIGNvbnNpc3RlbnQgd2l0aCB0aGUgdmFsdWVzIHRoYXQgd2UgcmVhZCBkdXJpbmcgdGhlIG1vc3RcbiAgICAvLyByZWNlbnQgbXV0YXRpb24uXG4gICAgaXNTYWZlVG9SZWFkRnJvbVNvdXJjZSA9IGlzU3Vic2V0T2ZMYW5lcyhyZW5kZXJMYW5lcywgcm9vdC5tdXRhYmxlUmVhZExhbmVzKTtcblxuICAgIGlmIChpc1NhZmVUb1JlYWRGcm9tU291cmNlKSB7XG4gICAgICAvLyBJZiBpdCdzIHNhZmUgdG8gcmVhZCBmcm9tIHRoaXMgc291cmNlIGR1cmluZyB0aGUgY3VycmVudCByZW5kZXIsXG4gICAgICAvLyBzdG9yZSB0aGUgdmVyc2lvbiBpbiBjYXNlIG90aGVyIGNvbXBvbmVudHMgcmVhZCBmcm9tIGl0LlxuICAgICAgLy8gQSBjaGFuZ2VkIHZlcnNpb24gbnVtYmVyIHdpbGwgbGV0IHRob3NlIGNvbXBvbmVudHMga25vdyB0byB0aHJvdyBhbmQgcmVzdGFydCB0aGUgcmVuZGVyLlxuICAgICAgc2V0V29ya0luUHJvZ3Jlc3NWZXJzaW9uKHNvdXJjZSwgdmVyc2lvbik7XG4gICAgfVxuICB9XG5cbiAgaWYgKGlzU2FmZVRvUmVhZEZyb21Tb3VyY2UpIHtcbiAgICB2YXIgc25hcHNob3QgPSBnZXRTbmFwc2hvdChzb3VyY2UuX3NvdXJjZSk7XG5cbiAgICB7XG4gICAgICBpZiAodHlwZW9mIHNuYXBzaG90ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGVycm9yKCdNdXRhYmxlIHNvdXJjZSBzaG91bGQgbm90IHJldHVybiBhIGZ1bmN0aW9uIGFzIHRoZSBzbmFwc2hvdCB2YWx1ZS4gJyArICdGdW5jdGlvbnMgbWF5IGNsb3NlIG92ZXIgbXV0YWJsZSB2YWx1ZXMgYW5kIGNhdXNlIHRlYXJpbmcuJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHNuYXBzaG90O1xuICB9IGVsc2Uge1xuICAgIC8vIFRoaXMgaGFuZGxlcyB0aGUgc3BlY2lhbCBjYXNlIG9mIGEgbXV0YWJsZSBzb3VyY2UgYmVpbmcgc2hhcmVkIGJldHdlZW4gcmVuZGVyZXJzLlxuICAgIC8vIEluIHRoYXQgY2FzZSwgaWYgdGhlIHNvdXJjZSBpcyBtdXRhdGVkIGJldHdlZW4gdGhlIGZpcnN0IGFuZCBzZWNvbmQgcmVuZGVyZXIsXG4gICAgLy8gVGhlIHNlY29uZCByZW5kZXJlciBkb24ndCBrbm93IHRoYXQgaXQgbmVlZHMgdG8gcmVzZXQgdGhlIFdJUCB2ZXJzaW9uIGR1cmluZyB1bndpbmQsXG4gICAgLy8gKGJlY2F1c2UgdGhlIGhvb2sgb25seSBtYXJrcyBzb3VyY2VzIGFzIGRpcnR5IGlmIGl0J3Mgd3JpdHRlbiB0byB0aGVpciBXSVAgdmVyc2lvbikuXG4gICAgLy8gVGhhdCB3b3VsZCBjYXVzZSB0aGlzIHRlYXIgY2hlY2sgdG8gdGhyb3cgYWdhaW4gYW5kIGV2ZW50dWFsbHkgYmUgdmlzaWJsZSB0byB0aGUgdXNlci5cbiAgICAvLyBXZSBjYW4gYXZvaWQgdGhpcyBpbmZpbml0ZSBsb29wIGJ5IGV4cGxpY2l0bHkgbWFya2luZyB0aGUgc291cmNlIGFzIGRpcnR5LlxuICAgIC8vXG4gICAgLy8gVGhpcyBjYW4gbGVhZCB0byB0ZWFyaW5nIGluIHRoZSBmaXJzdCByZW5kZXJlciB3aGVuIGl0IHJlc3VtZXMsXG4gICAgLy8gYnV0IHRoZXJlJ3Mgbm90aGluZyB3ZSBjYW4gZG8gYWJvdXQgdGhhdCAoc2hvcnQgb2YgdGhyb3dpbmcgaGVyZSBhbmQgcmVmdXNpbmcgdG8gY29udGludWUgdGhlIHJlbmRlcikuXG4gICAgbWFya1NvdXJjZUFzRGlydHkoc291cmNlKTtcblxuICAgIHtcbiAgICAgIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoIFwiQ2Fubm90IHJlYWQgZnJvbSBtdXRhYmxlIHNvdXJjZSBkdXJpbmcgdGhlIGN1cnJlbnQgcmVuZGVyIHdpdGhvdXQgdGVhcmluZy4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCIgKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gdXNlTXV0YWJsZVNvdXJjZShob29rLCBzb3VyY2UsIGdldFNuYXBzaG90LCBzdWJzY3JpYmUpIHtcbiAgdmFyIHJvb3QgPSBnZXRXb3JrSW5Qcm9ncmVzc1Jvb3QoKTtcblxuICBpZiAoIShyb290ICE9PSBudWxsKSkge1xuICAgIHtcbiAgICAgIHRocm93IEVycm9yKCBcIkV4cGVjdGVkIGEgd29yay1pbi1wcm9ncmVzcyByb290LiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS5cIiApO1xuICAgIH1cbiAgfVxuXG4gIHZhciBnZXRWZXJzaW9uID0gc291cmNlLl9nZXRWZXJzaW9uO1xuICB2YXIgdmVyc2lvbiA9IGdldFZlcnNpb24oc291cmNlLl9zb3VyY2UpO1xuICB2YXIgZGlzcGF0Y2hlciA9IFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50OyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcHJlZmVyLWNvbnN0XG5cbiAgdmFyIF9kaXNwYXRjaGVyJHVzZVN0YXRlID0gZGlzcGF0Y2hlci51c2VTdGF0ZShmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHJlYWRGcm9tVW5zdWJjcmliZWRNdXRhYmxlU291cmNlKHJvb3QsIHNvdXJjZSwgZ2V0U25hcHNob3QpO1xuICB9KSxcbiAgICAgIGN1cnJlbnRTbmFwc2hvdCA9IF9kaXNwYXRjaGVyJHVzZVN0YXRlWzBdLFxuICAgICAgc2V0U25hcHNob3QgPSBfZGlzcGF0Y2hlciR1c2VTdGF0ZVsxXTtcblxuICB2YXIgc25hcHNob3QgPSBjdXJyZW50U25hcHNob3Q7IC8vIEdyYWIgYSBoYW5kbGUgdG8gdGhlIHN0YXRlIGhvb2sgYXMgd2VsbC5cbiAgLy8gV2UgdXNlIGl0IHRvIGNsZWFyIHRoZSBwZW5kaW5nIHVwZGF0ZSBxdWV1ZSBpZiB3ZSBoYXZlIGEgbmV3IHNvdXJjZS5cblxuICB2YXIgc3RhdGVIb29rID0gd29ya0luUHJvZ3Jlc3NIb29rO1xuICB2YXIgbWVtb2l6ZWRTdGF0ZSA9IGhvb2subWVtb2l6ZWRTdGF0ZTtcbiAgdmFyIHJlZnMgPSBtZW1vaXplZFN0YXRlLnJlZnM7XG4gIHZhciBwcmV2R2V0U25hcHNob3QgPSByZWZzLmdldFNuYXBzaG90O1xuICB2YXIgcHJldlNvdXJjZSA9IG1lbW9pemVkU3RhdGUuc291cmNlO1xuICB2YXIgcHJldlN1YnNjcmliZSA9IG1lbW9pemVkU3RhdGUuc3Vic2NyaWJlO1xuICB2YXIgZmliZXIgPSBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxO1xuICBob29rLm1lbW9pemVkU3RhdGUgPSB7XG4gICAgcmVmczogcmVmcyxcbiAgICBzb3VyY2U6IHNvdXJjZSxcbiAgICBzdWJzY3JpYmU6IHN1YnNjcmliZVxuICB9OyAvLyBTeW5jIHRoZSB2YWx1ZXMgbmVlZGVkIGJ5IG91ciBzdWJzY3JpcHRpb24gaGFuZGxlciBhZnRlciBlYWNoIGNvbW1pdC5cblxuICBkaXNwYXRjaGVyLnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgcmVmcy5nZXRTbmFwc2hvdCA9IGdldFNuYXBzaG90OyAvLyBOb3JtYWxseSB0aGUgZGlzcGF0Y2ggZnVuY3Rpb24gZm9yIGEgc3RhdGUgaG9vayBuZXZlciBjaGFuZ2VzLFxuICAgIC8vIGJ1dCB0aGlzIGhvb2sgcmVjcmVhdGVzIHRoZSBxdWV1ZSBpbiBjZXJ0YWluIGNhc2VzICB0byBhdm9pZCB1cGRhdGVzIGZyb20gc3RhbGUgc291cmNlcy5cbiAgICAvLyBoYW5kbGVDaGFuZ2UoKSBiZWxvdyBuZWVkcyB0byByZWZlcmVuY2UgdGhlIGRpc3BhdGNoIGZ1bmN0aW9uIHdpdGhvdXQgcmUtc3Vic2NyaWJpbmcsXG4gICAgLy8gc28gd2UgdXNlIGEgcmVmIHRvIGVuc3VyZSB0aGF0IGl0IGFsd2F5cyBoYXMgdGhlIGxhdGVzdCB2ZXJzaW9uLlxuXG4gICAgcmVmcy5zZXRTbmFwc2hvdCA9IHNldFNuYXBzaG90OyAvLyBDaGVjayBmb3IgYSBwb3NzaWJsZSBjaGFuZ2UgYmV0d2VlbiB3aGVuIHdlIGxhc3QgcmVuZGVyZWQgbm93LlxuXG4gICAgdmFyIG1heWJlTmV3VmVyc2lvbiA9IGdldFZlcnNpb24oc291cmNlLl9zb3VyY2UpO1xuXG4gICAgaWYgKCFvYmplY3RJcyh2ZXJzaW9uLCBtYXliZU5ld1ZlcnNpb24pKSB7XG4gICAgICB2YXIgbWF5YmVOZXdTbmFwc2hvdCA9IGdldFNuYXBzaG90KHNvdXJjZS5fc291cmNlKTtcblxuICAgICAge1xuICAgICAgICBpZiAodHlwZW9mIG1heWJlTmV3U25hcHNob3QgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBlcnJvcignTXV0YWJsZSBzb3VyY2Ugc2hvdWxkIG5vdCByZXR1cm4gYSBmdW5jdGlvbiBhcyB0aGUgc25hcHNob3QgdmFsdWUuICcgKyAnRnVuY3Rpb25zIG1heSBjbG9zZSBvdmVyIG11dGFibGUgdmFsdWVzIGFuZCBjYXVzZSB0ZWFyaW5nLicpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICghb2JqZWN0SXMoc25hcHNob3QsIG1heWJlTmV3U25hcHNob3QpKSB7XG4gICAgICAgIHNldFNuYXBzaG90KG1heWJlTmV3U25hcHNob3QpO1xuICAgICAgICB2YXIgbGFuZSA9IHJlcXVlc3RVcGRhdGVMYW5lKGZpYmVyKTtcbiAgICAgICAgbWFya1Jvb3RNdXRhYmxlUmVhZChyb290LCBsYW5lKTtcbiAgICAgIH0gLy8gSWYgdGhlIHNvdXJjZSBtdXRhdGVkIGJldHdlZW4gcmVuZGVyIGFuZCBub3csXG4gICAgICAvLyB0aGVyZSBtYXkgYmUgc3RhdGUgdXBkYXRlcyBhbHJlYWR5IHNjaGVkdWxlZCBmcm9tIHRoZSBvbGQgc291cmNlLlxuICAgICAgLy8gRW50YW5nbGUgdGhlIHVwZGF0ZXMgc28gdGhhdCB0aGV5IHJlbmRlciBpbiB0aGUgc2FtZSBiYXRjaC5cblxuXG4gICAgICBtYXJrUm9vdEVudGFuZ2xlZChyb290LCByb290Lm11dGFibGVSZWFkTGFuZXMpO1xuICAgIH1cbiAgfSwgW2dldFNuYXBzaG90LCBzb3VyY2UsIHN1YnNjcmliZV0pOyAvLyBJZiB3ZSBnb3QgYSBuZXcgc291cmNlIG9yIHN1YnNjcmliZSBmdW5jdGlvbiwgcmUtc3Vic2NyaWJlIGluIGEgcGFzc2l2ZSBlZmZlY3QuXG5cbiAgZGlzcGF0Y2hlci51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIHZhciBoYW5kbGVDaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgbGF0ZXN0R2V0U25hcHNob3QgPSByZWZzLmdldFNuYXBzaG90O1xuICAgICAgdmFyIGxhdGVzdFNldFNuYXBzaG90ID0gcmVmcy5zZXRTbmFwc2hvdDtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgbGF0ZXN0U2V0U25hcHNob3QobGF0ZXN0R2V0U25hcHNob3Qoc291cmNlLl9zb3VyY2UpKTsgLy8gUmVjb3JkIGEgcGVuZGluZyBtdXRhYmxlIHNvdXJjZSB1cGRhdGUgd2l0aCB0aGUgc2FtZSBleHBpcmF0aW9uIHRpbWUuXG5cbiAgICAgICAgdmFyIGxhbmUgPSByZXF1ZXN0VXBkYXRlTGFuZShmaWJlcik7XG4gICAgICAgIG1hcmtSb290TXV0YWJsZVJlYWQocm9vdCwgbGFuZSk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAvLyBBIHNlbGVjdG9yIG1pZ2h0IHRocm93IGFmdGVyIGEgc291cmNlIG11dGF0aW9uLlxuICAgICAgICAvLyBlLmcuIGl0IG1pZ2h0IHRyeSB0byByZWFkIGZyb20gYSBwYXJ0IG9mIHRoZSBzdG9yZSB0aGF0IG5vIGxvbmdlciBleGlzdHMuXG4gICAgICAgIC8vIEluIHRoaXMgY2FzZSB3ZSBzaG91bGQgc3RpbGwgc2NoZWR1bGUgYW4gdXBkYXRlIHdpdGggUmVhY3QuXG4gICAgICAgIC8vIFdvcnN0IGNhc2UgdGhlIHNlbGVjdG9yIHdpbGwgdGhyb3cgYWdhaW4gYW5kIHRoZW4gYW4gZXJyb3IgYm91bmRhcnkgd2lsbCBoYW5kbGUgaXQuXG4gICAgICAgIGxhdGVzdFNldFNuYXBzaG90KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHZhciB1bnN1YnNjcmliZSA9IHN1YnNjcmliZShzb3VyY2UuX3NvdXJjZSwgaGFuZGxlQ2hhbmdlKTtcblxuICAgIHtcbiAgICAgIGlmICh0eXBlb2YgdW5zdWJzY3JpYmUgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgZXJyb3IoJ011dGFibGUgc291cmNlIHN1YnNjcmliZSBmdW5jdGlvbiBtdXN0IHJldHVybiBhbiB1bnN1YnNjcmliZSBmdW5jdGlvbi4nKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdW5zdWJzY3JpYmU7XG4gIH0sIFtzb3VyY2UsIHN1YnNjcmliZV0pOyAvLyBJZiBhbnkgb2YgdGhlIGlucHV0cyB0byB1c2VNdXRhYmxlU291cmNlIGNoYW5nZSwgcmVhZGluZyBpcyBwb3RlbnRpYWxseSB1bnNhZmUuXG4gIC8vXG4gIC8vIElmIGVpdGhlciB0aGUgc291cmNlIG9yIHRoZSBzdWJzY3JpcHRpb24gaGF2ZSBjaGFuZ2VkIHdlIGNhbid0IGNhbid0IHRydXN0IHRoZSB1cGRhdGUgcXVldWUuXG4gIC8vIE1heWJlIHRoZSBzb3VyY2UgY2hhbmdlZCBpbiBhIHdheSB0aGF0IHRoZSBvbGQgc3Vic2NyaXB0aW9uIGlnbm9yZWQgYnV0IHRoZSBuZXcgb25lIGRlcGVuZHMgb24uXG4gIC8vXG4gIC8vIElmIHRoZSBnZXRTbmFwc2hvdCBmdW5jdGlvbiBjaGFuZ2VkLCB3ZSBhbHNvIHNob3VsZG4ndCByZWx5IG9uIHRoZSB1cGRhdGUgcXVldWUuXG4gIC8vIEl0J3MgcG9zc2libGUgdGhhdCB0aGUgdW5kZXJseWluZyBzb3VyY2Ugd2FzIG11dGF0ZWQgYmV0d2VlbiB0aGUgd2hlbiB0aGUgbGFzdCBcImNoYW5nZVwiIGV2ZW50IGZpcmVkLFxuICAvLyBhbmQgd2hlbiB0aGUgY3VycmVudCByZW5kZXIgKHdpdGggdGhlIG5ldyBnZXRTbmFwc2hvdCBmdW5jdGlvbikgaXMgcHJvY2Vzc2VkLlxuICAvL1xuICAvLyBJbiBib3RoIGNhc2VzLCB3ZSBuZWVkIHRvIHRocm93IGF3YXkgcGVuZGluZyB1cGRhdGVzIChzaW5jZSB0aGV5IGFyZSBubyBsb25nZXIgcmVsZXZhbnQpXG4gIC8vIGFuZCB0cmVhdCByZWFkaW5nIGZyb20gdGhlIHNvdXJjZSBhcyB3ZSBkbyBpbiB0aGUgbW91bnQgY2FzZS5cblxuICBpZiAoIW9iamVjdElzKHByZXZHZXRTbmFwc2hvdCwgZ2V0U25hcHNob3QpIHx8ICFvYmplY3RJcyhwcmV2U291cmNlLCBzb3VyY2UpIHx8ICFvYmplY3RJcyhwcmV2U3Vic2NyaWJlLCBzdWJzY3JpYmUpKSB7XG4gICAgLy8gQ3JlYXRlIGEgbmV3IHF1ZXVlIGFuZCBzZXRTdGF0ZSBtZXRob2QsXG4gICAgLy8gU28gaWYgdGhlcmUgYXJlIGludGVybGVhdmVkIHVwZGF0ZXMsIHRoZXkgZ2V0IHB1c2hlZCB0byB0aGUgb2xkZXIgcXVldWUuXG4gICAgLy8gV2hlbiB0aGlzIGJlY29tZXMgY3VycmVudCwgdGhlIHByZXZpb3VzIHF1ZXVlIGFuZCBkaXNwYXRjaCBtZXRob2Qgd2lsbCBiZSBkaXNjYXJkZWQsXG4gICAgLy8gaW5jbHVkaW5nIGFueSBpbnRlcmxlYXZpbmcgdXBkYXRlcyB0aGF0IG9jY3VyLlxuICAgIHZhciBuZXdRdWV1ZSA9IHtcbiAgICAgIHBlbmRpbmc6IG51bGwsXG4gICAgICBkaXNwYXRjaDogbnVsbCxcbiAgICAgIGxhc3RSZW5kZXJlZFJlZHVjZXI6IGJhc2ljU3RhdGVSZWR1Y2VyLFxuICAgICAgbGFzdFJlbmRlcmVkU3RhdGU6IHNuYXBzaG90XG4gICAgfTtcbiAgICBuZXdRdWV1ZS5kaXNwYXRjaCA9IHNldFNuYXBzaG90ID0gZGlzcGF0Y2hBY3Rpb24uYmluZChudWxsLCBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLCBuZXdRdWV1ZSk7XG4gICAgc3RhdGVIb29rLnF1ZXVlID0gbmV3UXVldWU7XG4gICAgc3RhdGVIb29rLmJhc2VRdWV1ZSA9IG51bGw7XG4gICAgc25hcHNob3QgPSByZWFkRnJvbVVuc3ViY3JpYmVkTXV0YWJsZVNvdXJjZShyb290LCBzb3VyY2UsIGdldFNuYXBzaG90KTtcbiAgICBzdGF0ZUhvb2subWVtb2l6ZWRTdGF0ZSA9IHN0YXRlSG9vay5iYXNlU3RhdGUgPSBzbmFwc2hvdDtcbiAgfVxuXG4gIHJldHVybiBzbmFwc2hvdDtcbn1cblxuZnVuY3Rpb24gbW91bnRNdXRhYmxlU291cmNlKHNvdXJjZSwgZ2V0U25hcHNob3QsIHN1YnNjcmliZSkge1xuICB2YXIgaG9vayA9IG1vdW50V29ya0luUHJvZ3Jlc3NIb29rKCk7XG4gIGhvb2subWVtb2l6ZWRTdGF0ZSA9IHtcbiAgICByZWZzOiB7XG4gICAgICBnZXRTbmFwc2hvdDogZ2V0U25hcHNob3QsXG4gICAgICBzZXRTbmFwc2hvdDogbnVsbFxuICAgIH0sXG4gICAgc291cmNlOiBzb3VyY2UsXG4gICAgc3Vic2NyaWJlOiBzdWJzY3JpYmVcbiAgfTtcbiAgcmV0dXJuIHVzZU11dGFibGVTb3VyY2UoaG9vaywgc291cmNlLCBnZXRTbmFwc2hvdCwgc3Vic2NyaWJlKTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlTXV0YWJsZVNvdXJjZShzb3VyY2UsIGdldFNuYXBzaG90LCBzdWJzY3JpYmUpIHtcbiAgdmFyIGhvb2sgPSB1cGRhdGVXb3JrSW5Qcm9ncmVzc0hvb2soKTtcbiAgcmV0dXJuIHVzZU11dGFibGVTb3VyY2UoaG9vaywgc291cmNlLCBnZXRTbmFwc2hvdCwgc3Vic2NyaWJlKTtcbn1cblxuZnVuY3Rpb24gbW91bnRTdGF0ZShpbml0aWFsU3RhdGUpIHtcbiAgdmFyIGhvb2sgPSBtb3VudFdvcmtJblByb2dyZXNzSG9vaygpO1xuXG4gIGlmICh0eXBlb2YgaW5pdGlhbFN0YXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgLy8gJEZsb3dGaXhNZTogRmxvdyBkb2Vzbid0IGxpa2UgbWl4ZWQgdHlwZXNcbiAgICBpbml0aWFsU3RhdGUgPSBpbml0aWFsU3RhdGUoKTtcbiAgfVxuXG4gIGhvb2subWVtb2l6ZWRTdGF0ZSA9IGhvb2suYmFzZVN0YXRlID0gaW5pdGlhbFN0YXRlO1xuICB2YXIgcXVldWUgPSBob29rLnF1ZXVlID0ge1xuICAgIHBlbmRpbmc6IG51bGwsXG4gICAgZGlzcGF0Y2g6IG51bGwsXG4gICAgbGFzdFJlbmRlcmVkUmVkdWNlcjogYmFzaWNTdGF0ZVJlZHVjZXIsXG4gICAgbGFzdFJlbmRlcmVkU3RhdGU6IGluaXRpYWxTdGF0ZVxuICB9O1xuICB2YXIgZGlzcGF0Y2ggPSBxdWV1ZS5kaXNwYXRjaCA9IGRpc3BhdGNoQWN0aW9uLmJpbmQobnVsbCwgY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMSwgcXVldWUpO1xuICByZXR1cm4gW2hvb2subWVtb2l6ZWRTdGF0ZSwgZGlzcGF0Y2hdO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVTdGF0ZShpbml0aWFsU3RhdGUpIHtcbiAgcmV0dXJuIHVwZGF0ZVJlZHVjZXIoYmFzaWNTdGF0ZVJlZHVjZXIpO1xufVxuXG5mdW5jdGlvbiByZXJlbmRlclN0YXRlKGluaXRpYWxTdGF0ZSkge1xuICByZXR1cm4gcmVyZW5kZXJSZWR1Y2VyKGJhc2ljU3RhdGVSZWR1Y2VyKTtcbn1cblxuZnVuY3Rpb24gcHVzaEVmZmVjdCh0YWcsIGNyZWF0ZSwgZGVzdHJveSwgZGVwcykge1xuICB2YXIgZWZmZWN0ID0ge1xuICAgIHRhZzogdGFnLFxuICAgIGNyZWF0ZTogY3JlYXRlLFxuICAgIGRlc3Ryb3k6IGRlc3Ryb3ksXG4gICAgZGVwczogZGVwcyxcbiAgICAvLyBDaXJjdWxhclxuICAgIG5leHQ6IG51bGxcbiAgfTtcbiAgdmFyIGNvbXBvbmVudFVwZGF0ZVF1ZXVlID0gY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMS51cGRhdGVRdWV1ZTtcblxuICBpZiAoY29tcG9uZW50VXBkYXRlUXVldWUgPT09IG51bGwpIHtcbiAgICBjb21wb25lbnRVcGRhdGVRdWV1ZSA9IGNyZWF0ZUZ1bmN0aW9uQ29tcG9uZW50VXBkYXRlUXVldWUoKTtcbiAgICBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLnVwZGF0ZVF1ZXVlID0gY29tcG9uZW50VXBkYXRlUXVldWU7XG4gICAgY29tcG9uZW50VXBkYXRlUXVldWUubGFzdEVmZmVjdCA9IGVmZmVjdC5uZXh0ID0gZWZmZWN0O1xuICB9IGVsc2Uge1xuICAgIHZhciBsYXN0RWZmZWN0ID0gY29tcG9uZW50VXBkYXRlUXVldWUubGFzdEVmZmVjdDtcblxuICAgIGlmIChsYXN0RWZmZWN0ID09PSBudWxsKSB7XG4gICAgICBjb21wb25lbnRVcGRhdGVRdWV1ZS5sYXN0RWZmZWN0ID0gZWZmZWN0Lm5leHQgPSBlZmZlY3Q7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBmaXJzdEVmZmVjdCA9IGxhc3RFZmZlY3QubmV4dDtcbiAgICAgIGxhc3RFZmZlY3QubmV4dCA9IGVmZmVjdDtcbiAgICAgIGVmZmVjdC5uZXh0ID0gZmlyc3RFZmZlY3Q7XG4gICAgICBjb21wb25lbnRVcGRhdGVRdWV1ZS5sYXN0RWZmZWN0ID0gZWZmZWN0O1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBlZmZlY3Q7XG59XG5cbmZ1bmN0aW9uIG1vdW50UmVmKGluaXRpYWxWYWx1ZSkge1xuICB2YXIgaG9vayA9IG1vdW50V29ya0luUHJvZ3Jlc3NIb29rKCk7XG4gIHZhciByZWYgPSB7XG4gICAgY3VycmVudDogaW5pdGlhbFZhbHVlXG4gIH07XG5cbiAge1xuICAgIE9iamVjdC5zZWFsKHJlZik7XG4gIH1cblxuICBob29rLm1lbW9pemVkU3RhdGUgPSByZWY7XG4gIHJldHVybiByZWY7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZVJlZihpbml0aWFsVmFsdWUpIHtcbiAgdmFyIGhvb2sgPSB1cGRhdGVXb3JrSW5Qcm9ncmVzc0hvb2soKTtcbiAgcmV0dXJuIGhvb2subWVtb2l6ZWRTdGF0ZTtcbn1cblxuZnVuY3Rpb24gbW91bnRFZmZlY3RJbXBsKGZpYmVyRmxhZ3MsIGhvb2tGbGFncywgY3JlYXRlLCBkZXBzKSB7XG4gIHZhciBob29rID0gbW91bnRXb3JrSW5Qcm9ncmVzc0hvb2soKTtcbiAgdmFyIG5leHREZXBzID0gZGVwcyA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGRlcHM7XG4gIGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEuZmxhZ3MgfD0gZmliZXJGbGFncztcbiAgaG9vay5tZW1vaXplZFN0YXRlID0gcHVzaEVmZmVjdChIYXNFZmZlY3QgfCBob29rRmxhZ3MsIGNyZWF0ZSwgdW5kZWZpbmVkLCBuZXh0RGVwcyk7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUVmZmVjdEltcGwoZmliZXJGbGFncywgaG9va0ZsYWdzLCBjcmVhdGUsIGRlcHMpIHtcbiAgdmFyIGhvb2sgPSB1cGRhdGVXb3JrSW5Qcm9ncmVzc0hvb2soKTtcbiAgdmFyIG5leHREZXBzID0gZGVwcyA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGRlcHM7XG4gIHZhciBkZXN0cm95ID0gdW5kZWZpbmVkO1xuXG4gIGlmIChjdXJyZW50SG9vayAhPT0gbnVsbCkge1xuICAgIHZhciBwcmV2RWZmZWN0ID0gY3VycmVudEhvb2subWVtb2l6ZWRTdGF0ZTtcbiAgICBkZXN0cm95ID0gcHJldkVmZmVjdC5kZXN0cm95O1xuXG4gICAgaWYgKG5leHREZXBzICE9PSBudWxsKSB7XG4gICAgICB2YXIgcHJldkRlcHMgPSBwcmV2RWZmZWN0LmRlcHM7XG5cbiAgICAgIGlmIChhcmVIb29rSW5wdXRzRXF1YWwobmV4dERlcHMsIHByZXZEZXBzKSkge1xuICAgICAgICBwdXNoRWZmZWN0KGhvb2tGbGFncywgY3JlYXRlLCBkZXN0cm95LCBuZXh0RGVwcyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLmZsYWdzIHw9IGZpYmVyRmxhZ3M7XG4gIGhvb2subWVtb2l6ZWRTdGF0ZSA9IHB1c2hFZmZlY3QoSGFzRWZmZWN0IHwgaG9va0ZsYWdzLCBjcmVhdGUsIGRlc3Ryb3ksIG5leHREZXBzKTtcbn1cblxuZnVuY3Rpb24gbW91bnRFZmZlY3QoY3JlYXRlLCBkZXBzKSB7XG4gIHtcbiAgICAvLyAkRmxvd0V4cGVjdGVkRXJyb3IgLSBqZXN0IGlzbid0IGEgZ2xvYmFsLCBhbmQgaXNuJ3QgcmVjb2duaXplZCBvdXRzaWRlIG9mIHRlc3RzXG4gICAgaWYgKCd1bmRlZmluZWQnICE9PSB0eXBlb2YgamVzdCkge1xuICAgICAgd2FybklmTm90Q3VycmVudGx5QWN0aW5nRWZmZWN0c0luREVWKGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBtb3VudEVmZmVjdEltcGwoVXBkYXRlIHwgUGFzc2l2ZSwgUGFzc2l2ZSQxLCBjcmVhdGUsIGRlcHMpO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVFZmZlY3QoY3JlYXRlLCBkZXBzKSB7XG4gIHtcbiAgICAvLyAkRmxvd0V4cGVjdGVkRXJyb3IgLSBqZXN0IGlzbid0IGEgZ2xvYmFsLCBhbmQgaXNuJ3QgcmVjb2duaXplZCBvdXRzaWRlIG9mIHRlc3RzXG4gICAgaWYgKCd1bmRlZmluZWQnICE9PSB0eXBlb2YgamVzdCkge1xuICAgICAgd2FybklmTm90Q3VycmVudGx5QWN0aW5nRWZmZWN0c0luREVWKGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB1cGRhdGVFZmZlY3RJbXBsKFVwZGF0ZSB8IFBhc3NpdmUsIFBhc3NpdmUkMSwgY3JlYXRlLCBkZXBzKTtcbn1cblxuZnVuY3Rpb24gbW91bnRMYXlvdXRFZmZlY3QoY3JlYXRlLCBkZXBzKSB7XG4gIHJldHVybiBtb3VudEVmZmVjdEltcGwoVXBkYXRlLCBMYXlvdXQsIGNyZWF0ZSwgZGVwcyk7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUxheW91dEVmZmVjdChjcmVhdGUsIGRlcHMpIHtcbiAgcmV0dXJuIHVwZGF0ZUVmZmVjdEltcGwoVXBkYXRlLCBMYXlvdXQsIGNyZWF0ZSwgZGVwcyk7XG59XG5cbmZ1bmN0aW9uIGltcGVyYXRpdmVIYW5kbGVFZmZlY3QoY3JlYXRlLCByZWYpIHtcbiAgaWYgKHR5cGVvZiByZWYgPT09ICdmdW5jdGlvbicpIHtcbiAgICB2YXIgcmVmQ2FsbGJhY2sgPSByZWY7XG5cbiAgICB2YXIgX2luc3QgPSBjcmVhdGUoKTtcblxuICAgIHJlZkNhbGxiYWNrKF9pbnN0KTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgcmVmQ2FsbGJhY2sobnVsbCk7XG4gICAgfTtcbiAgfSBlbHNlIGlmIChyZWYgIT09IG51bGwgJiYgcmVmICE9PSB1bmRlZmluZWQpIHtcbiAgICB2YXIgcmVmT2JqZWN0ID0gcmVmO1xuXG4gICAge1xuICAgICAgaWYgKCFyZWZPYmplY3QuaGFzT3duUHJvcGVydHkoJ2N1cnJlbnQnKSkge1xuICAgICAgICBlcnJvcignRXhwZWN0ZWQgdXNlSW1wZXJhdGl2ZUhhbmRsZSgpIGZpcnN0IGFyZ3VtZW50IHRvIGVpdGhlciBiZSBhICcgKyAncmVmIGNhbGxiYWNrIG9yIFJlYWN0LmNyZWF0ZVJlZigpIG9iamVjdC4gSW5zdGVhZCByZWNlaXZlZDogJXMuJywgJ2FuIG9iamVjdCB3aXRoIGtleXMgeycgKyBPYmplY3Qua2V5cyhyZWZPYmplY3QpLmpvaW4oJywgJykgKyAnfScpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBfaW5zdDIgPSBjcmVhdGUoKTtcblxuICAgIHJlZk9iamVjdC5jdXJyZW50ID0gX2luc3QyO1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICByZWZPYmplY3QuY3VycmVudCA9IG51bGw7XG4gICAgfTtcbiAgfVxufVxuXG5mdW5jdGlvbiBtb3VudEltcGVyYXRpdmVIYW5kbGUocmVmLCBjcmVhdGUsIGRlcHMpIHtcbiAge1xuICAgIGlmICh0eXBlb2YgY3JlYXRlICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICBlcnJvcignRXhwZWN0ZWQgdXNlSW1wZXJhdGl2ZUhhbmRsZSgpIHNlY29uZCBhcmd1bWVudCB0byBiZSBhIGZ1bmN0aW9uICcgKyAndGhhdCBjcmVhdGVzIGEgaGFuZGxlLiBJbnN0ZWFkIHJlY2VpdmVkOiAlcy4nLCBjcmVhdGUgIT09IG51bGwgPyB0eXBlb2YgY3JlYXRlIDogJ251bGwnKTtcbiAgICB9XG4gIH0gLy8gVE9ETzogSWYgZGVwcyBhcmUgcHJvdmlkZWQsIHNob3VsZCB3ZSBza2lwIGNvbXBhcmluZyB0aGUgcmVmIGl0c2VsZj9cblxuXG4gIHZhciBlZmZlY3REZXBzID0gZGVwcyAhPT0gbnVsbCAmJiBkZXBzICE9PSB1bmRlZmluZWQgPyBkZXBzLmNvbmNhdChbcmVmXSkgOiBudWxsO1xuICByZXR1cm4gbW91bnRFZmZlY3RJbXBsKFVwZGF0ZSwgTGF5b3V0LCBpbXBlcmF0aXZlSGFuZGxlRWZmZWN0LmJpbmQobnVsbCwgY3JlYXRlLCByZWYpLCBlZmZlY3REZXBzKTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlSW1wZXJhdGl2ZUhhbmRsZShyZWYsIGNyZWF0ZSwgZGVwcykge1xuICB7XG4gICAgaWYgKHR5cGVvZiBjcmVhdGUgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGVycm9yKCdFeHBlY3RlZCB1c2VJbXBlcmF0aXZlSGFuZGxlKCkgc2Vjb25kIGFyZ3VtZW50IHRvIGJlIGEgZnVuY3Rpb24gJyArICd0aGF0IGNyZWF0ZXMgYSBoYW5kbGUuIEluc3RlYWQgcmVjZWl2ZWQ6ICVzLicsIGNyZWF0ZSAhPT0gbnVsbCA/IHR5cGVvZiBjcmVhdGUgOiAnbnVsbCcpO1xuICAgIH1cbiAgfSAvLyBUT0RPOiBJZiBkZXBzIGFyZSBwcm92aWRlZCwgc2hvdWxkIHdlIHNraXAgY29tcGFyaW5nIHRoZSByZWYgaXRzZWxmP1xuXG5cbiAgdmFyIGVmZmVjdERlcHMgPSBkZXBzICE9PSBudWxsICYmIGRlcHMgIT09IHVuZGVmaW5lZCA/IGRlcHMuY29uY2F0KFtyZWZdKSA6IG51bGw7XG4gIHJldHVybiB1cGRhdGVFZmZlY3RJbXBsKFVwZGF0ZSwgTGF5b3V0LCBpbXBlcmF0aXZlSGFuZGxlRWZmZWN0LmJpbmQobnVsbCwgY3JlYXRlLCByZWYpLCBlZmZlY3REZXBzKTtcbn1cblxuZnVuY3Rpb24gbW91bnREZWJ1Z1ZhbHVlKHZhbHVlLCBmb3JtYXR0ZXJGbikgey8vIFRoaXMgaG9vayBpcyBub3JtYWxseSBhIG5vLW9wLlxuICAvLyBUaGUgcmVhY3QtZGVidWctaG9va3MgcGFja2FnZSBpbmplY3RzIGl0cyBvd24gaW1wbGVtZW50YXRpb25cbiAgLy8gc28gdGhhdCBlLmcuIERldlRvb2xzIGNhbiBkaXNwbGF5IGN1c3RvbSBob29rIHZhbHVlcy5cbn1cblxudmFyIHVwZGF0ZURlYnVnVmFsdWUgPSBtb3VudERlYnVnVmFsdWU7XG5cbmZ1bmN0aW9uIG1vdW50Q2FsbGJhY2soY2FsbGJhY2ssIGRlcHMpIHtcbiAgdmFyIGhvb2sgPSBtb3VudFdvcmtJblByb2dyZXNzSG9vaygpO1xuICB2YXIgbmV4dERlcHMgPSBkZXBzID09PSB1bmRlZmluZWQgPyBudWxsIDogZGVwcztcbiAgaG9vay5tZW1vaXplZFN0YXRlID0gW2NhbGxiYWNrLCBuZXh0RGVwc107XG4gIHJldHVybiBjYWxsYmFjaztcbn1cblxuZnVuY3Rpb24gdXBkYXRlQ2FsbGJhY2soY2FsbGJhY2ssIGRlcHMpIHtcbiAgdmFyIGhvb2sgPSB1cGRhdGVXb3JrSW5Qcm9ncmVzc0hvb2soKTtcbiAgdmFyIG5leHREZXBzID0gZGVwcyA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGRlcHM7XG4gIHZhciBwcmV2U3RhdGUgPSBob29rLm1lbW9pemVkU3RhdGU7XG5cbiAgaWYgKHByZXZTdGF0ZSAhPT0gbnVsbCkge1xuICAgIGlmIChuZXh0RGVwcyAhPT0gbnVsbCkge1xuICAgICAgdmFyIHByZXZEZXBzID0gcHJldlN0YXRlWzFdO1xuXG4gICAgICBpZiAoYXJlSG9va0lucHV0c0VxdWFsKG5leHREZXBzLCBwcmV2RGVwcykpIHtcbiAgICAgICAgcmV0dXJuIHByZXZTdGF0ZVswXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBob29rLm1lbW9pemVkU3RhdGUgPSBbY2FsbGJhY2ssIG5leHREZXBzXTtcbiAgcmV0dXJuIGNhbGxiYWNrO1xufVxuXG5mdW5jdGlvbiBtb3VudE1lbW8obmV4dENyZWF0ZSwgZGVwcykge1xuICB2YXIgaG9vayA9IG1vdW50V29ya0luUHJvZ3Jlc3NIb29rKCk7XG4gIHZhciBuZXh0RGVwcyA9IGRlcHMgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBkZXBzO1xuICB2YXIgbmV4dFZhbHVlID0gbmV4dENyZWF0ZSgpO1xuICBob29rLm1lbW9pemVkU3RhdGUgPSBbbmV4dFZhbHVlLCBuZXh0RGVwc107XG4gIHJldHVybiBuZXh0VmFsdWU7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZU1lbW8obmV4dENyZWF0ZSwgZGVwcykge1xuICB2YXIgaG9vayA9IHVwZGF0ZVdvcmtJblByb2dyZXNzSG9vaygpO1xuICB2YXIgbmV4dERlcHMgPSBkZXBzID09PSB1bmRlZmluZWQgPyBudWxsIDogZGVwcztcbiAgdmFyIHByZXZTdGF0ZSA9IGhvb2subWVtb2l6ZWRTdGF0ZTtcblxuICBpZiAocHJldlN0YXRlICE9PSBudWxsKSB7XG4gICAgLy8gQXNzdW1lIHRoZXNlIGFyZSBkZWZpbmVkLiBJZiB0aGV5J3JlIG5vdCwgYXJlSG9va0lucHV0c0VxdWFsIHdpbGwgd2Fybi5cbiAgICBpZiAobmV4dERlcHMgIT09IG51bGwpIHtcbiAgICAgIHZhciBwcmV2RGVwcyA9IHByZXZTdGF0ZVsxXTtcblxuICAgICAgaWYgKGFyZUhvb2tJbnB1dHNFcXVhbChuZXh0RGVwcywgcHJldkRlcHMpKSB7XG4gICAgICAgIHJldHVybiBwcmV2U3RhdGVbMF07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIG5leHRWYWx1ZSA9IG5leHRDcmVhdGUoKTtcbiAgaG9vay5tZW1vaXplZFN0YXRlID0gW25leHRWYWx1ZSwgbmV4dERlcHNdO1xuICByZXR1cm4gbmV4dFZhbHVlO1xufVxuXG5mdW5jdGlvbiBtb3VudERlZmVycmVkVmFsdWUodmFsdWUpIHtcbiAgdmFyIF9tb3VudFN0YXRlID0gbW91bnRTdGF0ZSh2YWx1ZSksXG4gICAgICBwcmV2VmFsdWUgPSBfbW91bnRTdGF0ZVswXSxcbiAgICAgIHNldFZhbHVlID0gX21vdW50U3RhdGVbMV07XG5cbiAgbW91bnRFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIHZhciBwcmV2VHJhbnNpdGlvbiA9IFJlYWN0Q3VycmVudEJhdGNoQ29uZmlnJDEudHJhbnNpdGlvbjtcbiAgICBSZWFjdEN1cnJlbnRCYXRjaENvbmZpZyQxLnRyYW5zaXRpb24gPSAxO1xuXG4gICAgdHJ5IHtcbiAgICAgIHNldFZhbHVlKHZhbHVlKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgUmVhY3RDdXJyZW50QmF0Y2hDb25maWckMS50cmFuc2l0aW9uID0gcHJldlRyYW5zaXRpb247XG4gICAgfVxuICB9LCBbdmFsdWVdKTtcbiAgcmV0dXJuIHByZXZWYWx1ZTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlRGVmZXJyZWRWYWx1ZSh2YWx1ZSkge1xuICB2YXIgX3VwZGF0ZVN0YXRlID0gdXBkYXRlU3RhdGUoKSxcbiAgICAgIHByZXZWYWx1ZSA9IF91cGRhdGVTdGF0ZVswXSxcbiAgICAgIHNldFZhbHVlID0gX3VwZGF0ZVN0YXRlWzFdO1xuXG4gIHVwZGF0ZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHByZXZUcmFuc2l0aW9uID0gUmVhY3RDdXJyZW50QmF0Y2hDb25maWckMS50cmFuc2l0aW9uO1xuICAgIFJlYWN0Q3VycmVudEJhdGNoQ29uZmlnJDEudHJhbnNpdGlvbiA9IDE7XG5cbiAgICB0cnkge1xuICAgICAgc2V0VmFsdWUodmFsdWUpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBSZWFjdEN1cnJlbnRCYXRjaENvbmZpZyQxLnRyYW5zaXRpb24gPSBwcmV2VHJhbnNpdGlvbjtcbiAgICB9XG4gIH0sIFt2YWx1ZV0pO1xuICByZXR1cm4gcHJldlZhbHVlO1xufVxuXG5mdW5jdGlvbiByZXJlbmRlckRlZmVycmVkVmFsdWUodmFsdWUpIHtcbiAgdmFyIF9yZXJlbmRlclN0YXRlID0gcmVyZW5kZXJTdGF0ZSgpLFxuICAgICAgcHJldlZhbHVlID0gX3JlcmVuZGVyU3RhdGVbMF0sXG4gICAgICBzZXRWYWx1ZSA9IF9yZXJlbmRlclN0YXRlWzFdO1xuXG4gIHVwZGF0ZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHByZXZUcmFuc2l0aW9uID0gUmVhY3RDdXJyZW50QmF0Y2hDb25maWckMS50cmFuc2l0aW9uO1xuICAgIFJlYWN0Q3VycmVudEJhdGNoQ29uZmlnJDEudHJhbnNpdGlvbiA9IDE7XG5cbiAgICB0cnkge1xuICAgICAgc2V0VmFsdWUodmFsdWUpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBSZWFjdEN1cnJlbnRCYXRjaENvbmZpZyQxLnRyYW5zaXRpb24gPSBwcmV2VHJhbnNpdGlvbjtcbiAgICB9XG4gIH0sIFt2YWx1ZV0pO1xuICByZXR1cm4gcHJldlZhbHVlO1xufVxuXG5mdW5jdGlvbiBzdGFydFRyYW5zaXRpb24oc2V0UGVuZGluZywgY2FsbGJhY2spIHtcbiAgdmFyIHByaW9yaXR5TGV2ZWwgPSBnZXRDdXJyZW50UHJpb3JpdHlMZXZlbCgpO1xuXG4gIHtcbiAgICBydW5XaXRoUHJpb3JpdHkkMShwcmlvcml0eUxldmVsIDwgVXNlckJsb2NraW5nUHJpb3JpdHkkMiA/IFVzZXJCbG9ja2luZ1ByaW9yaXR5JDIgOiBwcmlvcml0eUxldmVsLCBmdW5jdGlvbiAoKSB7XG4gICAgICBzZXRQZW5kaW5nKHRydWUpO1xuICAgIH0pO1xuICAgIHJ1bldpdGhQcmlvcml0eSQxKHByaW9yaXR5TGV2ZWwgPiBOb3JtYWxQcmlvcml0eSQxID8gTm9ybWFsUHJpb3JpdHkkMSA6IHByaW9yaXR5TGV2ZWwsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBwcmV2VHJhbnNpdGlvbiA9IFJlYWN0Q3VycmVudEJhdGNoQ29uZmlnJDEudHJhbnNpdGlvbjtcbiAgICAgIFJlYWN0Q3VycmVudEJhdGNoQ29uZmlnJDEudHJhbnNpdGlvbiA9IDE7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHNldFBlbmRpbmcoZmFsc2UpO1xuICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgUmVhY3RDdXJyZW50QmF0Y2hDb25maWckMS50cmFuc2l0aW9uID0gcHJldlRyYW5zaXRpb247XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gbW91bnRUcmFuc2l0aW9uKCkge1xuICB2YXIgX21vdW50U3RhdGUyID0gbW91bnRTdGF0ZShmYWxzZSksXG4gICAgICBpc1BlbmRpbmcgPSBfbW91bnRTdGF0ZTJbMF0sXG4gICAgICBzZXRQZW5kaW5nID0gX21vdW50U3RhdGUyWzFdOyAvLyBUaGUgYHN0YXJ0YCBtZXRob2QgY2FuIGJlIHN0b3JlZCBvbiBhIHJlZiwgc2luY2UgYHNldFBlbmRpbmdgXG4gIC8vIG5ldmVyIGNoYW5nZXMuXG5cblxuICB2YXIgc3RhcnQgPSBzdGFydFRyYW5zaXRpb24uYmluZChudWxsLCBzZXRQZW5kaW5nKTtcbiAgbW91bnRSZWYoc3RhcnQpO1xuICByZXR1cm4gW3N0YXJ0LCBpc1BlbmRpbmddO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVUcmFuc2l0aW9uKCkge1xuICB2YXIgX3VwZGF0ZVN0YXRlMiA9IHVwZGF0ZVN0YXRlKCksXG4gICAgICBpc1BlbmRpbmcgPSBfdXBkYXRlU3RhdGUyWzBdO1xuXG4gIHZhciBzdGFydFJlZiA9IHVwZGF0ZVJlZigpO1xuICB2YXIgc3RhcnQgPSBzdGFydFJlZi5jdXJyZW50O1xuICByZXR1cm4gW3N0YXJ0LCBpc1BlbmRpbmddO1xufVxuXG5mdW5jdGlvbiByZXJlbmRlclRyYW5zaXRpb24oKSB7XG4gIHZhciBfcmVyZW5kZXJTdGF0ZTIgPSByZXJlbmRlclN0YXRlKCksXG4gICAgICBpc1BlbmRpbmcgPSBfcmVyZW5kZXJTdGF0ZTJbMF07XG5cbiAgdmFyIHN0YXJ0UmVmID0gdXBkYXRlUmVmKCk7XG4gIHZhciBzdGFydCA9IHN0YXJ0UmVmLmN1cnJlbnQ7XG4gIHJldHVybiBbc3RhcnQsIGlzUGVuZGluZ107XG59XG5cbnZhciBpc1VwZGF0aW5nT3BhcXVlVmFsdWVJblJlbmRlclBoYXNlID0gZmFsc2U7XG5mdW5jdGlvbiBnZXRJc1VwZGF0aW5nT3BhcXVlVmFsdWVJblJlbmRlclBoYXNlSW5ERVYoKSB7XG4gIHtcbiAgICByZXR1cm4gaXNVcGRhdGluZ09wYXF1ZVZhbHVlSW5SZW5kZXJQaGFzZTtcbiAgfVxufVxuXG5mdW5jdGlvbiB3YXJuT25PcGFxdWVJZGVudGlmaWVyQWNjZXNzSW5ERVYoZmliZXIpIHtcbiAge1xuICAgIC8vIFRPRE86IFNob3VsZCB3YXJuIGluIGVmZmVjdHMgYW5kIGNhbGxiYWNrcywgdG9vXG4gICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lKGZpYmVyLnR5cGUpIHx8ICdVbmtub3duJztcblxuICAgIGlmIChnZXRJc1JlbmRlcmluZygpICYmICFkaWRXYXJuQWJvdXRVc2VPcGFxdWVJZGVudGlmaWVyW25hbWVdKSB7XG4gICAgICBlcnJvcignVGhlIG9iamVjdCBwYXNzZWQgYmFjayBmcm9tIHVzZU9wYXF1ZUlkZW50aWZpZXIgaXMgbWVhbnQgdG8gYmUgJyArICdwYXNzZWQgdGhyb3VnaCB0byBhdHRyaWJ1dGVzIG9ubHkuIERvIG5vdCByZWFkIHRoZSAnICsgJ3ZhbHVlIGRpcmVjdGx5LicpO1xuXG4gICAgICBkaWRXYXJuQWJvdXRVc2VPcGFxdWVJZGVudGlmaWVyW25hbWVdID0gdHJ1ZTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gbW91bnRPcGFxdWVJZGVudGlmaWVyKCkge1xuICB2YXIgbWFrZUlkID0gIG1ha2VDbGllbnRJZEluREVWLmJpbmQobnVsbCwgd2Fybk9uT3BhcXVlSWRlbnRpZmllckFjY2Vzc0luREVWLmJpbmQobnVsbCwgY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMSkpIDtcblxuICBpZiAoZ2V0SXNIeWRyYXRpbmcoKSkge1xuICAgIHZhciBkaWRVcGdyYWRlID0gZmFsc2U7XG4gICAgdmFyIGZpYmVyID0gY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMTtcblxuICAgIHZhciByZWFkVmFsdWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoIWRpZFVwZ3JhZGUpIHtcbiAgICAgICAgLy8gT25seSB1cGdyYWRlIG9uY2UuIFRoaXMgd29ya3MgZXZlbiBpbnNpZGUgdGhlIHJlbmRlciBwaGFzZSBiZWNhdXNlXG4gICAgICAgIC8vIHRoZSB1cGRhdGUgaXMgYWRkZWQgdG8gYSBzaGFyZWQgcXVldWUsIHdoaWNoIG91dGxhc3RzIHRoZVxuICAgICAgICAvLyBpbi1wcm9ncmVzcyByZW5kZXIuXG4gICAgICAgIGRpZFVwZ3JhZGUgPSB0cnVlO1xuXG4gICAgICAgIHtcbiAgICAgICAgICBpc1VwZGF0aW5nT3BhcXVlVmFsdWVJblJlbmRlclBoYXNlID0gdHJ1ZTtcbiAgICAgICAgICBzZXRJZChtYWtlSWQoKSk7XG4gICAgICAgICAgaXNVcGRhdGluZ09wYXF1ZVZhbHVlSW5SZW5kZXJQaGFzZSA9IGZhbHNlO1xuICAgICAgICAgIHdhcm5Pbk9wYXF1ZUlkZW50aWZpZXJBY2Nlc3NJbkRFVihmaWJlcik7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAge1xuICAgICAgICB7XG4gICAgICAgICAgdGhyb3cgRXJyb3IoIFwiVGhlIG9iamVjdCBwYXNzZWQgYmFjayBmcm9tIHVzZU9wYXF1ZUlkZW50aWZpZXIgaXMgbWVhbnQgdG8gYmUgcGFzc2VkIHRocm91Z2ggdG8gYXR0cmlidXRlcyBvbmx5LiBEbyBub3QgcmVhZCB0aGUgdmFsdWUgZGlyZWN0bHkuXCIgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgaWQgPSBtYWtlT3BhcXVlSHlkcmF0aW5nT2JqZWN0KHJlYWRWYWx1ZSk7XG4gICAgdmFyIHNldElkID0gbW91bnRTdGF0ZShpZClbMV07XG5cbiAgICBpZiAoKGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEubW9kZSAmIEJsb2NraW5nTW9kZSkgPT09IE5vTW9kZSkge1xuICAgICAgY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMS5mbGFncyB8PSBVcGRhdGUgfCBQYXNzaXZlO1xuICAgICAgcHVzaEVmZmVjdChIYXNFZmZlY3QgfCBQYXNzaXZlJDEsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc2V0SWQobWFrZUlkKCkpO1xuICAgICAgfSwgdW5kZWZpbmVkLCBudWxsKTtcbiAgICB9XG5cbiAgICByZXR1cm4gaWQ7XG4gIH0gZWxzZSB7XG4gICAgdmFyIF9pZCA9IG1ha2VJZCgpO1xuXG4gICAgbW91bnRTdGF0ZShfaWQpO1xuICAgIHJldHVybiBfaWQ7XG4gIH1cbn1cblxuZnVuY3Rpb24gdXBkYXRlT3BhcXVlSWRlbnRpZmllcigpIHtcbiAgdmFyIGlkID0gdXBkYXRlU3RhdGUoKVswXTtcbiAgcmV0dXJuIGlkO1xufVxuXG5mdW5jdGlvbiByZXJlbmRlck9wYXF1ZUlkZW50aWZpZXIoKSB7XG4gIHZhciBpZCA9IHJlcmVuZGVyU3RhdGUoKVswXTtcbiAgcmV0dXJuIGlkO1xufVxuXG5mdW5jdGlvbiBkaXNwYXRjaEFjdGlvbihmaWJlciwgcXVldWUsIGFjdGlvbikge1xuICB7XG4gICAgaWYgKHR5cGVvZiBhcmd1bWVudHNbM10gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGVycm9yKFwiU3RhdGUgdXBkYXRlcyBmcm9tIHRoZSB1c2VTdGF0ZSgpIGFuZCB1c2VSZWR1Y2VyKCkgSG9va3MgZG9uJ3Qgc3VwcG9ydCB0aGUgXCIgKyAnc2Vjb25kIGNhbGxiYWNrIGFyZ3VtZW50LiBUbyBleGVjdXRlIGEgc2lkZSBlZmZlY3QgYWZ0ZXIgJyArICdyZW5kZXJpbmcsIGRlY2xhcmUgaXQgaW4gdGhlIGNvbXBvbmVudCBib2R5IHdpdGggdXNlRWZmZWN0KCkuJyk7XG4gICAgfVxuICB9XG5cbiAgdmFyIGV2ZW50VGltZSA9IHJlcXVlc3RFdmVudFRpbWUoKTtcbiAgdmFyIGxhbmUgPSByZXF1ZXN0VXBkYXRlTGFuZShmaWJlcik7XG4gIHZhciB1cGRhdGUgPSB7XG4gICAgbGFuZTogbGFuZSxcbiAgICBhY3Rpb246IGFjdGlvbixcbiAgICBlYWdlclJlZHVjZXI6IG51bGwsXG4gICAgZWFnZXJTdGF0ZTogbnVsbCxcbiAgICBuZXh0OiBudWxsXG4gIH07IC8vIEFwcGVuZCB0aGUgdXBkYXRlIHRvIHRoZSBlbmQgb2YgdGhlIGxpc3QuXG5cbiAgdmFyIHBlbmRpbmcgPSBxdWV1ZS5wZW5kaW5nO1xuXG4gIGlmIChwZW5kaW5nID09PSBudWxsKSB7XG4gICAgLy8gVGhpcyBpcyB0aGUgZmlyc3QgdXBkYXRlLiBDcmVhdGUgYSBjaXJjdWxhciBsaXN0LlxuICAgIHVwZGF0ZS5uZXh0ID0gdXBkYXRlO1xuICB9IGVsc2Uge1xuICAgIHVwZGF0ZS5uZXh0ID0gcGVuZGluZy5uZXh0O1xuICAgIHBlbmRpbmcubmV4dCA9IHVwZGF0ZTtcbiAgfVxuXG4gIHF1ZXVlLnBlbmRpbmcgPSB1cGRhdGU7XG4gIHZhciBhbHRlcm5hdGUgPSBmaWJlci5hbHRlcm5hdGU7XG5cbiAgaWYgKGZpYmVyID09PSBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxIHx8IGFsdGVybmF0ZSAhPT0gbnVsbCAmJiBhbHRlcm5hdGUgPT09IGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEpIHtcbiAgICAvLyBUaGlzIGlzIGEgcmVuZGVyIHBoYXNlIHVwZGF0ZS4gU3Rhc2ggaXQgaW4gYSBsYXppbHktY3JlYXRlZCBtYXAgb2ZcbiAgICAvLyBxdWV1ZSAtPiBsaW5rZWQgbGlzdCBvZiB1cGRhdGVzLiBBZnRlciB0aGlzIHJlbmRlciBwYXNzLCB3ZSdsbCByZXN0YXJ0XG4gICAgLy8gYW5kIGFwcGx5IHRoZSBzdGFzaGVkIHVwZGF0ZXMgb24gdG9wIG9mIHRoZSB3b3JrLWluLXByb2dyZXNzIGhvb2suXG4gICAgZGlkU2NoZWR1bGVSZW5kZXJQaGFzZVVwZGF0ZUR1cmluZ1RoaXNQYXNzID0gZGlkU2NoZWR1bGVSZW5kZXJQaGFzZVVwZGF0ZSA9IHRydWU7XG4gIH0gZWxzZSB7XG4gICAgaWYgKGZpYmVyLmxhbmVzID09PSBOb0xhbmVzICYmIChhbHRlcm5hdGUgPT09IG51bGwgfHwgYWx0ZXJuYXRlLmxhbmVzID09PSBOb0xhbmVzKSkge1xuICAgICAgLy8gVGhlIHF1ZXVlIGlzIGN1cnJlbnRseSBlbXB0eSwgd2hpY2ggbWVhbnMgd2UgY2FuIGVhZ2VybHkgY29tcHV0ZSB0aGVcbiAgICAgIC8vIG5leHQgc3RhdGUgYmVmb3JlIGVudGVyaW5nIHRoZSByZW5kZXIgcGhhc2UuIElmIHRoZSBuZXcgc3RhdGUgaXMgdGhlXG4gICAgICAvLyBzYW1lIGFzIHRoZSBjdXJyZW50IHN0YXRlLCB3ZSBtYXkgYmUgYWJsZSB0byBiYWlsIG91dCBlbnRpcmVseS5cbiAgICAgIHZhciBsYXN0UmVuZGVyZWRSZWR1Y2VyID0gcXVldWUubGFzdFJlbmRlcmVkUmVkdWNlcjtcblxuICAgICAgaWYgKGxhc3RSZW5kZXJlZFJlZHVjZXIgIT09IG51bGwpIHtcbiAgICAgICAgdmFyIHByZXZEaXNwYXRjaGVyO1xuXG4gICAgICAgIHtcbiAgICAgICAgICBwcmV2RGlzcGF0Y2hlciA9IFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50O1xuICAgICAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uVXBkYXRlSW5ERVY7XG4gICAgICAgIH1cblxuICAgICAgICB0cnkge1xuICAgICAgICAgIHZhciBjdXJyZW50U3RhdGUgPSBxdWV1ZS5sYXN0UmVuZGVyZWRTdGF0ZTtcbiAgICAgICAgICB2YXIgZWFnZXJTdGF0ZSA9IGxhc3RSZW5kZXJlZFJlZHVjZXIoY3VycmVudFN0YXRlLCBhY3Rpb24pOyAvLyBTdGFzaCB0aGUgZWFnZXJseSBjb21wdXRlZCBzdGF0ZSwgYW5kIHRoZSByZWR1Y2VyIHVzZWQgdG8gY29tcHV0ZVxuICAgICAgICAgIC8vIGl0LCBvbiB0aGUgdXBkYXRlIG9iamVjdC4gSWYgdGhlIHJlZHVjZXIgaGFzbid0IGNoYW5nZWQgYnkgdGhlXG4gICAgICAgICAgLy8gdGltZSB3ZSBlbnRlciB0aGUgcmVuZGVyIHBoYXNlLCB0aGVuIHRoZSBlYWdlciBzdGF0ZSBjYW4gYmUgdXNlZFxuICAgICAgICAgIC8vIHdpdGhvdXQgY2FsbGluZyB0aGUgcmVkdWNlciBhZ2Fpbi5cblxuICAgICAgICAgIHVwZGF0ZS5lYWdlclJlZHVjZXIgPSBsYXN0UmVuZGVyZWRSZWR1Y2VyO1xuICAgICAgICAgIHVwZGF0ZS5lYWdlclN0YXRlID0gZWFnZXJTdGF0ZTtcblxuICAgICAgICAgIGlmIChvYmplY3RJcyhlYWdlclN0YXRlLCBjdXJyZW50U3RhdGUpKSB7XG4gICAgICAgICAgICAvLyBGYXN0IHBhdGguIFdlIGNhbiBiYWlsIG91dCB3aXRob3V0IHNjaGVkdWxpbmcgUmVhY3QgdG8gcmUtcmVuZGVyLlxuICAgICAgICAgICAgLy8gSXQncyBzdGlsbCBwb3NzaWJsZSB0aGF0IHdlJ2xsIG5lZWQgdG8gcmViYXNlIHRoaXMgdXBkYXRlIGxhdGVyLFxuICAgICAgICAgICAgLy8gaWYgdGhlIGNvbXBvbmVudCByZS1yZW5kZXJzIGZvciBhIGRpZmZlcmVudCByZWFzb24gYW5kIGJ5IHRoYXRcbiAgICAgICAgICAgIC8vIHRpbWUgdGhlIHJlZHVjZXIgaGFzIGNoYW5nZWQuXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnJvcikgey8vIFN1cHByZXNzIHRoZSBlcnJvci4gSXQgd2lsbCB0aHJvdyBhZ2FpbiBpbiB0aGUgcmVuZGVyIHBoYXNlLlxuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gcHJldkRpc3BhdGNoZXI7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAge1xuICAgICAgLy8gJEZsb3dFeHBlY3RlZEVycm9yIC0gamVzdCBpc24ndCBhIGdsb2JhbCwgYW5kIGlzbid0IHJlY29nbml6ZWQgb3V0c2lkZSBvZiB0ZXN0c1xuICAgICAgaWYgKCd1bmRlZmluZWQnICE9PSB0eXBlb2YgamVzdCkge1xuICAgICAgICB3YXJuSWZOb3RTY29wZWRXaXRoTWF0Y2hpbmdBY3QoZmliZXIpO1xuICAgICAgICB3YXJuSWZOb3RDdXJyZW50bHlBY3RpbmdVcGRhdGVzSW5EZXYoZmliZXIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHNjaGVkdWxlVXBkYXRlT25GaWJlcihmaWJlciwgbGFuZSwgZXZlbnRUaW1lKTtcbiAgfVxufVxuXG52YXIgQ29udGV4dE9ubHlEaXNwYXRjaGVyID0ge1xuICByZWFkQ29udGV4dDogcmVhZENvbnRleHQsXG4gIHVzZUNhbGxiYWNrOiB0aHJvd0ludmFsaWRIb29rRXJyb3IsXG4gIHVzZUNvbnRleHQ6IHRocm93SW52YWxpZEhvb2tFcnJvcixcbiAgdXNlRWZmZWN0OiB0aHJvd0ludmFsaWRIb29rRXJyb3IsXG4gIHVzZUltcGVyYXRpdmVIYW5kbGU6IHRocm93SW52YWxpZEhvb2tFcnJvcixcbiAgdXNlTGF5b3V0RWZmZWN0OiB0aHJvd0ludmFsaWRIb29rRXJyb3IsXG4gIHVzZU1lbW86IHRocm93SW52YWxpZEhvb2tFcnJvcixcbiAgdXNlUmVkdWNlcjogdGhyb3dJbnZhbGlkSG9va0Vycm9yLFxuICB1c2VSZWY6IHRocm93SW52YWxpZEhvb2tFcnJvcixcbiAgdXNlU3RhdGU6IHRocm93SW52YWxpZEhvb2tFcnJvcixcbiAgdXNlRGVidWdWYWx1ZTogdGhyb3dJbnZhbGlkSG9va0Vycm9yLFxuICB1c2VEZWZlcnJlZFZhbHVlOiB0aHJvd0ludmFsaWRIb29rRXJyb3IsXG4gIHVzZVRyYW5zaXRpb246IHRocm93SW52YWxpZEhvb2tFcnJvcixcbiAgdXNlTXV0YWJsZVNvdXJjZTogdGhyb3dJbnZhbGlkSG9va0Vycm9yLFxuICB1c2VPcGFxdWVJZGVudGlmaWVyOiB0aHJvd0ludmFsaWRIb29rRXJyb3IsXG4gIHVuc3RhYmxlX2lzTmV3UmVjb25jaWxlcjogZW5hYmxlTmV3UmVjb25jaWxlclxufTtcbnZhciBIb29rc0Rpc3BhdGNoZXJPbk1vdW50SW5ERVYgPSBudWxsO1xudmFyIEhvb2tzRGlzcGF0Y2hlck9uTW91bnRXaXRoSG9va1R5cGVzSW5ERVYgPSBudWxsO1xudmFyIEhvb2tzRGlzcGF0Y2hlck9uVXBkYXRlSW5ERVYgPSBudWxsO1xudmFyIEhvb2tzRGlzcGF0Y2hlck9uUmVyZW5kZXJJbkRFViA9IG51bGw7XG52YXIgSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uTW91bnRJbkRFViA9IG51bGw7XG52YXIgSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uVXBkYXRlSW5ERVYgPSBudWxsO1xudmFyIEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPblJlcmVuZGVySW5ERVYgPSBudWxsO1xuXG57XG4gIHZhciB3YXJuSW52YWxpZENvbnRleHRBY2Nlc3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgZXJyb3IoJ0NvbnRleHQgY2FuIG9ubHkgYmUgcmVhZCB3aGlsZSBSZWFjdCBpcyByZW5kZXJpbmcuICcgKyAnSW4gY2xhc3NlcywgeW91IGNhbiByZWFkIGl0IGluIHRoZSByZW5kZXIgbWV0aG9kIG9yIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcy4gJyArICdJbiBmdW5jdGlvbiBjb21wb25lbnRzLCB5b3UgY2FuIHJlYWQgaXQgZGlyZWN0bHkgaW4gdGhlIGZ1bmN0aW9uIGJvZHksIGJ1dCBub3QgJyArICdpbnNpZGUgSG9va3MgbGlrZSB1c2VSZWR1Y2VyKCkgb3IgdXNlTWVtbygpLicpO1xuICB9O1xuXG4gIHZhciB3YXJuSW52YWxpZEhvb2tBY2Nlc3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgZXJyb3IoJ0RvIG5vdCBjYWxsIEhvb2tzIGluc2lkZSB1c2VFZmZlY3QoLi4uKSwgdXNlTWVtbyguLi4pLCBvciBvdGhlciBidWlsdC1pbiBIb29rcy4gJyArICdZb3UgY2FuIG9ubHkgY2FsbCBIb29rcyBhdCB0aGUgdG9wIGxldmVsIG9mIHlvdXIgUmVhY3QgZnVuY3Rpb24uICcgKyAnRm9yIG1vcmUgaW5mb3JtYXRpb24sIHNlZSAnICsgJ2h0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9ydWxlcy1vZi1ob29rcycpO1xuICB9O1xuXG4gIEhvb2tzRGlzcGF0Y2hlck9uTW91bnRJbkRFViA9IHtcbiAgICByZWFkQ29udGV4dDogZnVuY3Rpb24gKGNvbnRleHQsIG9ic2VydmVkQml0cykge1xuICAgICAgcmV0dXJuIHJlYWRDb250ZXh0KGNvbnRleHQsIG9ic2VydmVkQml0cyk7XG4gICAgfSxcbiAgICB1c2VDYWxsYmFjazogZnVuY3Rpb24gKGNhbGxiYWNrLCBkZXBzKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VDYWxsYmFjayc7XG4gICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgY2hlY2tEZXBzQXJlQXJyYXlEZXYoZGVwcyk7XG4gICAgICByZXR1cm4gbW91bnRDYWxsYmFjayhjYWxsYmFjaywgZGVwcyk7XG4gICAgfSxcbiAgICB1c2VDb250ZXh0OiBmdW5jdGlvbiAoY29udGV4dCwgb2JzZXJ2ZWRCaXRzKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VDb250ZXh0JztcbiAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gcmVhZENvbnRleHQoY29udGV4dCwgb2JzZXJ2ZWRCaXRzKTtcbiAgICB9LFxuICAgIHVzZUVmZmVjdDogZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlRWZmZWN0JztcbiAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICBjaGVja0RlcHNBcmVBcnJheURldihkZXBzKTtcbiAgICAgIHJldHVybiBtb3VudEVmZmVjdChjcmVhdGUsIGRlcHMpO1xuICAgIH0sXG4gICAgdXNlSW1wZXJhdGl2ZUhhbmRsZTogZnVuY3Rpb24gKHJlZiwgY3JlYXRlLCBkZXBzKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VJbXBlcmF0aXZlSGFuZGxlJztcbiAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICBjaGVja0RlcHNBcmVBcnJheURldihkZXBzKTtcbiAgICAgIHJldHVybiBtb3VudEltcGVyYXRpdmVIYW5kbGUocmVmLCBjcmVhdGUsIGRlcHMpO1xuICAgIH0sXG4gICAgdXNlTGF5b3V0RWZmZWN0OiBmdW5jdGlvbiAoY3JlYXRlLCBkZXBzKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VMYXlvdXRFZmZlY3QnO1xuICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgIGNoZWNrRGVwc0FyZUFycmF5RGV2KGRlcHMpO1xuICAgICAgcmV0dXJuIG1vdW50TGF5b3V0RWZmZWN0KGNyZWF0ZSwgZGVwcyk7XG4gICAgfSxcbiAgICB1c2VNZW1vOiBmdW5jdGlvbiAoY3JlYXRlLCBkZXBzKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VNZW1vJztcbiAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICBjaGVja0RlcHNBcmVBcnJheURldihkZXBzKTtcbiAgICAgIHZhciBwcmV2RGlzcGF0Y2hlciA9IFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50O1xuICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25Nb3VudEluREVWO1xuXG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gbW91bnRNZW1vKGNyZWF0ZSwgZGVwcyk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudCA9IHByZXZEaXNwYXRjaGVyO1xuICAgICAgfVxuICAgIH0sXG4gICAgdXNlUmVkdWNlcjogZnVuY3Rpb24gKHJlZHVjZXIsIGluaXRpYWxBcmcsIGluaXQpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZVJlZHVjZXInO1xuICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgIHZhciBwcmV2RGlzcGF0Y2hlciA9IFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50O1xuICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25Nb3VudEluREVWO1xuXG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gbW91bnRSZWR1Y2VyKHJlZHVjZXIsIGluaXRpYWxBcmcsIGluaXQpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSBwcmV2RGlzcGF0Y2hlcjtcbiAgICAgIH1cbiAgICB9LFxuICAgIHVzZVJlZjogZnVuY3Rpb24gKGluaXRpYWxWYWx1ZSkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlUmVmJztcbiAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gbW91bnRSZWYoaW5pdGlhbFZhbHVlKTtcbiAgICB9LFxuICAgIHVzZVN0YXRlOiBmdW5jdGlvbiAoaW5pdGlhbFN0YXRlKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VTdGF0ZSc7XG4gICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgdmFyIHByZXZEaXNwYXRjaGVyID0gUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQ7XG4gICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudCA9IEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPbk1vdW50SW5ERVY7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBtb3VudFN0YXRlKGluaXRpYWxTdGF0ZSk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudCA9IHByZXZEaXNwYXRjaGVyO1xuICAgICAgfVxuICAgIH0sXG4gICAgdXNlRGVidWdWYWx1ZTogZnVuY3Rpb24gKHZhbHVlLCBmb3JtYXR0ZXJGbikge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlRGVidWdWYWx1ZSc7XG4gICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIG1vdW50RGVidWdWYWx1ZSgpO1xuICAgIH0sXG4gICAgdXNlRGVmZXJyZWRWYWx1ZTogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VEZWZlcnJlZFZhbHVlJztcbiAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gbW91bnREZWZlcnJlZFZhbHVlKHZhbHVlKTtcbiAgICB9LFxuICAgIHVzZVRyYW5zaXRpb246IGZ1bmN0aW9uICgpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZVRyYW5zaXRpb24nO1xuICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiBtb3VudFRyYW5zaXRpb24oKTtcbiAgICB9LFxuICAgIHVzZU11dGFibGVTb3VyY2U6IGZ1bmN0aW9uIChzb3VyY2UsIGdldFNuYXBzaG90LCBzdWJzY3JpYmUpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZU11dGFibGVTb3VyY2UnO1xuICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiBtb3VudE11dGFibGVTb3VyY2Uoc291cmNlLCBnZXRTbmFwc2hvdCwgc3Vic2NyaWJlKTtcbiAgICB9LFxuICAgIHVzZU9wYXF1ZUlkZW50aWZpZXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZU9wYXF1ZUlkZW50aWZpZXInO1xuICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiBtb3VudE9wYXF1ZUlkZW50aWZpZXIoKTtcbiAgICB9LFxuICAgIHVuc3RhYmxlX2lzTmV3UmVjb25jaWxlcjogZW5hYmxlTmV3UmVjb25jaWxlclxuICB9O1xuICBIb29rc0Rpc3BhdGNoZXJPbk1vdW50V2l0aEhvb2tUeXBlc0luREVWID0ge1xuICAgIHJlYWRDb250ZXh0OiBmdW5jdGlvbiAoY29udGV4dCwgb2JzZXJ2ZWRCaXRzKSB7XG4gICAgICByZXR1cm4gcmVhZENvbnRleHQoY29udGV4dCwgb2JzZXJ2ZWRCaXRzKTtcbiAgICB9LFxuICAgIHVzZUNhbGxiYWNrOiBmdW5jdGlvbiAoY2FsbGJhY2ssIGRlcHMpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUNhbGxiYWNrJztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIG1vdW50Q2FsbGJhY2soY2FsbGJhY2ssIGRlcHMpO1xuICAgIH0sXG4gICAgdXNlQ29udGV4dDogZnVuY3Rpb24gKGNvbnRleHQsIG9ic2VydmVkQml0cykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlQ29udGV4dCc7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiByZWFkQ29udGV4dChjb250ZXh0LCBvYnNlcnZlZEJpdHMpO1xuICAgIH0sXG4gICAgdXNlRWZmZWN0OiBmdW5jdGlvbiAoY3JlYXRlLCBkZXBzKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VFZmZlY3QnO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gbW91bnRFZmZlY3QoY3JlYXRlLCBkZXBzKTtcbiAgICB9LFxuICAgIHVzZUltcGVyYXRpdmVIYW5kbGU6IGZ1bmN0aW9uIChyZWYsIGNyZWF0ZSwgZGVwcykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlSW1wZXJhdGl2ZUhhbmRsZSc7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiBtb3VudEltcGVyYXRpdmVIYW5kbGUocmVmLCBjcmVhdGUsIGRlcHMpO1xuICAgIH0sXG4gICAgdXNlTGF5b3V0RWZmZWN0OiBmdW5jdGlvbiAoY3JlYXRlLCBkZXBzKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VMYXlvdXRFZmZlY3QnO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gbW91bnRMYXlvdXRFZmZlY3QoY3JlYXRlLCBkZXBzKTtcbiAgICB9LFxuICAgIHVzZU1lbW86IGZ1bmN0aW9uIChjcmVhdGUsIGRlcHMpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZU1lbW8nO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICB2YXIgcHJldkRpc3BhdGNoZXIgPSBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudDtcbiAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uTW91bnRJbkRFVjtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIG1vdW50TWVtbyhjcmVhdGUsIGRlcHMpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSBwcmV2RGlzcGF0Y2hlcjtcbiAgICAgIH1cbiAgICB9LFxuICAgIHVzZVJlZHVjZXI6IGZ1bmN0aW9uIChyZWR1Y2VyLCBpbml0aWFsQXJnLCBpbml0KSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VSZWR1Y2VyJztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgdmFyIHByZXZEaXNwYXRjaGVyID0gUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQ7XG4gICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudCA9IEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPbk1vdW50SW5ERVY7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBtb3VudFJlZHVjZXIocmVkdWNlciwgaW5pdGlhbEFyZywgaW5pdCk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudCA9IHByZXZEaXNwYXRjaGVyO1xuICAgICAgfVxuICAgIH0sXG4gICAgdXNlUmVmOiBmdW5jdGlvbiAoaW5pdGlhbFZhbHVlKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VSZWYnO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gbW91bnRSZWYoaW5pdGlhbFZhbHVlKTtcbiAgICB9LFxuICAgIHVzZVN0YXRlOiBmdW5jdGlvbiAoaW5pdGlhbFN0YXRlKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VTdGF0ZSc7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHZhciBwcmV2RGlzcGF0Y2hlciA9IFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50O1xuICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25Nb3VudEluREVWO1xuXG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gbW91bnRTdGF0ZShpbml0aWFsU3RhdGUpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSBwcmV2RGlzcGF0Y2hlcjtcbiAgICAgIH1cbiAgICB9LFxuICAgIHVzZURlYnVnVmFsdWU6IGZ1bmN0aW9uICh2YWx1ZSwgZm9ybWF0dGVyRm4pIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZURlYnVnVmFsdWUnO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gbW91bnREZWJ1Z1ZhbHVlKCk7XG4gICAgfSxcbiAgICB1c2VEZWZlcnJlZFZhbHVlOiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZURlZmVycmVkVmFsdWUnO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gbW91bnREZWZlcnJlZFZhbHVlKHZhbHVlKTtcbiAgICB9LFxuICAgIHVzZVRyYW5zaXRpb246IGZ1bmN0aW9uICgpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZVRyYW5zaXRpb24nO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gbW91bnRUcmFuc2l0aW9uKCk7XG4gICAgfSxcbiAgICB1c2VNdXRhYmxlU291cmNlOiBmdW5jdGlvbiAoc291cmNlLCBnZXRTbmFwc2hvdCwgc3Vic2NyaWJlKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VNdXRhYmxlU291cmNlJztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIG1vdW50TXV0YWJsZVNvdXJjZShzb3VyY2UsIGdldFNuYXBzaG90LCBzdWJzY3JpYmUpO1xuICAgIH0sXG4gICAgdXNlT3BhcXVlSWRlbnRpZmllcjogZnVuY3Rpb24gKCkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlT3BhcXVlSWRlbnRpZmllcic7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiBtb3VudE9wYXF1ZUlkZW50aWZpZXIoKTtcbiAgICB9LFxuICAgIHVuc3RhYmxlX2lzTmV3UmVjb25jaWxlcjogZW5hYmxlTmV3UmVjb25jaWxlclxuICB9O1xuICBIb29rc0Rpc3BhdGNoZXJPblVwZGF0ZUluREVWID0ge1xuICAgIHJlYWRDb250ZXh0OiBmdW5jdGlvbiAoY29udGV4dCwgb2JzZXJ2ZWRCaXRzKSB7XG4gICAgICByZXR1cm4gcmVhZENvbnRleHQoY29udGV4dCwgb2JzZXJ2ZWRCaXRzKTtcbiAgICB9LFxuICAgIHVzZUNhbGxiYWNrOiBmdW5jdGlvbiAoY2FsbGJhY2ssIGRlcHMpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUNhbGxiYWNrJztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHVwZGF0ZUNhbGxiYWNrKGNhbGxiYWNrLCBkZXBzKTtcbiAgICB9LFxuICAgIHVzZUNvbnRleHQ6IGZ1bmN0aW9uIChjb250ZXh0LCBvYnNlcnZlZEJpdHMpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUNvbnRleHQnO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gcmVhZENvbnRleHQoY29udGV4dCwgb2JzZXJ2ZWRCaXRzKTtcbiAgICB9LFxuICAgIHVzZUVmZmVjdDogZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlRWZmZWN0JztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHVwZGF0ZUVmZmVjdChjcmVhdGUsIGRlcHMpO1xuICAgIH0sXG4gICAgdXNlSW1wZXJhdGl2ZUhhbmRsZTogZnVuY3Rpb24gKHJlZiwgY3JlYXRlLCBkZXBzKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VJbXBlcmF0aXZlSGFuZGxlJztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHVwZGF0ZUltcGVyYXRpdmVIYW5kbGUocmVmLCBjcmVhdGUsIGRlcHMpO1xuICAgIH0sXG4gICAgdXNlTGF5b3V0RWZmZWN0OiBmdW5jdGlvbiAoY3JlYXRlLCBkZXBzKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VMYXlvdXRFZmZlY3QnO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gdXBkYXRlTGF5b3V0RWZmZWN0KGNyZWF0ZSwgZGVwcyk7XG4gICAgfSxcbiAgICB1c2VNZW1vOiBmdW5jdGlvbiAoY3JlYXRlLCBkZXBzKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VNZW1vJztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgdmFyIHByZXZEaXNwYXRjaGVyID0gUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQ7XG4gICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudCA9IEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPblVwZGF0ZUluREVWO1xuXG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gdXBkYXRlTWVtbyhjcmVhdGUsIGRlcHMpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSBwcmV2RGlzcGF0Y2hlcjtcbiAgICAgIH1cbiAgICB9LFxuICAgIHVzZVJlZHVjZXI6IGZ1bmN0aW9uIChyZWR1Y2VyLCBpbml0aWFsQXJnLCBpbml0KSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VSZWR1Y2VyJztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgdmFyIHByZXZEaXNwYXRjaGVyID0gUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQ7XG4gICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudCA9IEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPblVwZGF0ZUluREVWO1xuXG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gdXBkYXRlUmVkdWNlcihyZWR1Y2VyLCBpbml0aWFsQXJnLCBpbml0KTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gcHJldkRpc3BhdGNoZXI7XG4gICAgICB9XG4gICAgfSxcbiAgICB1c2VSZWY6IGZ1bmN0aW9uIChpbml0aWFsVmFsdWUpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZVJlZic7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiB1cGRhdGVSZWYoKTtcbiAgICB9LFxuICAgIHVzZVN0YXRlOiBmdW5jdGlvbiAoaW5pdGlhbFN0YXRlKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VTdGF0ZSc7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHZhciBwcmV2RGlzcGF0Y2hlciA9IFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50O1xuICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25VcGRhdGVJbkRFVjtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIHVwZGF0ZVN0YXRlKGluaXRpYWxTdGF0ZSk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudCA9IHByZXZEaXNwYXRjaGVyO1xuICAgICAgfVxuICAgIH0sXG4gICAgdXNlRGVidWdWYWx1ZTogZnVuY3Rpb24gKHZhbHVlLCBmb3JtYXR0ZXJGbikge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlRGVidWdWYWx1ZSc7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiB1cGRhdGVEZWJ1Z1ZhbHVlKCk7XG4gICAgfSxcbiAgICB1c2VEZWZlcnJlZFZhbHVlOiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZURlZmVycmVkVmFsdWUnO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gdXBkYXRlRGVmZXJyZWRWYWx1ZSh2YWx1ZSk7XG4gICAgfSxcbiAgICB1c2VUcmFuc2l0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VUcmFuc2l0aW9uJztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHVwZGF0ZVRyYW5zaXRpb24oKTtcbiAgICB9LFxuICAgIHVzZU11dGFibGVTb3VyY2U6IGZ1bmN0aW9uIChzb3VyY2UsIGdldFNuYXBzaG90LCBzdWJzY3JpYmUpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZU11dGFibGVTb3VyY2UnO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gdXBkYXRlTXV0YWJsZVNvdXJjZShzb3VyY2UsIGdldFNuYXBzaG90LCBzdWJzY3JpYmUpO1xuICAgIH0sXG4gICAgdXNlT3BhcXVlSWRlbnRpZmllcjogZnVuY3Rpb24gKCkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlT3BhcXVlSWRlbnRpZmllcic7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiB1cGRhdGVPcGFxdWVJZGVudGlmaWVyKCk7XG4gICAgfSxcbiAgICB1bnN0YWJsZV9pc05ld1JlY29uY2lsZXI6IGVuYWJsZU5ld1JlY29uY2lsZXJcbiAgfTtcbiAgSG9va3NEaXNwYXRjaGVyT25SZXJlbmRlckluREVWID0ge1xuICAgIHJlYWRDb250ZXh0OiBmdW5jdGlvbiAoY29udGV4dCwgb2JzZXJ2ZWRCaXRzKSB7XG4gICAgICByZXR1cm4gcmVhZENvbnRleHQoY29udGV4dCwgb2JzZXJ2ZWRCaXRzKTtcbiAgICB9LFxuICAgIHVzZUNhbGxiYWNrOiBmdW5jdGlvbiAoY2FsbGJhY2ssIGRlcHMpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUNhbGxiYWNrJztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHVwZGF0ZUNhbGxiYWNrKGNhbGxiYWNrLCBkZXBzKTtcbiAgICB9LFxuICAgIHVzZUNvbnRleHQ6IGZ1bmN0aW9uIChjb250ZXh0LCBvYnNlcnZlZEJpdHMpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUNvbnRleHQnO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gcmVhZENvbnRleHQoY29udGV4dCwgb2JzZXJ2ZWRCaXRzKTtcbiAgICB9LFxuICAgIHVzZUVmZmVjdDogZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlRWZmZWN0JztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHVwZGF0ZUVmZmVjdChjcmVhdGUsIGRlcHMpO1xuICAgIH0sXG4gICAgdXNlSW1wZXJhdGl2ZUhhbmRsZTogZnVuY3Rpb24gKHJlZiwgY3JlYXRlLCBkZXBzKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VJbXBlcmF0aXZlSGFuZGxlJztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHVwZGF0ZUltcGVyYXRpdmVIYW5kbGUocmVmLCBjcmVhdGUsIGRlcHMpO1xuICAgIH0sXG4gICAgdXNlTGF5b3V0RWZmZWN0OiBmdW5jdGlvbiAoY3JlYXRlLCBkZXBzKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VMYXlvdXRFZmZlY3QnO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gdXBkYXRlTGF5b3V0RWZmZWN0KGNyZWF0ZSwgZGVwcyk7XG4gICAgfSxcbiAgICB1c2VNZW1vOiBmdW5jdGlvbiAoY3JlYXRlLCBkZXBzKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VNZW1vJztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgdmFyIHByZXZEaXNwYXRjaGVyID0gUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQ7XG4gICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudCA9IEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPblJlcmVuZGVySW5ERVY7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiB1cGRhdGVNZW1vKGNyZWF0ZSwgZGVwcyk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudCA9IHByZXZEaXNwYXRjaGVyO1xuICAgICAgfVxuICAgIH0sXG4gICAgdXNlUmVkdWNlcjogZnVuY3Rpb24gKHJlZHVjZXIsIGluaXRpYWxBcmcsIGluaXQpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZVJlZHVjZXInO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICB2YXIgcHJldkRpc3BhdGNoZXIgPSBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudDtcbiAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uUmVyZW5kZXJJbkRFVjtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIHJlcmVuZGVyUmVkdWNlcihyZWR1Y2VyLCBpbml0aWFsQXJnLCBpbml0KTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gcHJldkRpc3BhdGNoZXI7XG4gICAgICB9XG4gICAgfSxcbiAgICB1c2VSZWY6IGZ1bmN0aW9uIChpbml0aWFsVmFsdWUpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZVJlZic7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiB1cGRhdGVSZWYoKTtcbiAgICB9LFxuICAgIHVzZVN0YXRlOiBmdW5jdGlvbiAoaW5pdGlhbFN0YXRlKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VTdGF0ZSc7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHZhciBwcmV2RGlzcGF0Y2hlciA9IFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50O1xuICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25SZXJlbmRlckluREVWO1xuXG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gcmVyZW5kZXJTdGF0ZShpbml0aWFsU3RhdGUpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSBwcmV2RGlzcGF0Y2hlcjtcbiAgICAgIH1cbiAgICB9LFxuICAgIHVzZURlYnVnVmFsdWU6IGZ1bmN0aW9uICh2YWx1ZSwgZm9ybWF0dGVyRm4pIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZURlYnVnVmFsdWUnO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gdXBkYXRlRGVidWdWYWx1ZSgpO1xuICAgIH0sXG4gICAgdXNlRGVmZXJyZWRWYWx1ZTogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VEZWZlcnJlZFZhbHVlJztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHJlcmVuZGVyRGVmZXJyZWRWYWx1ZSh2YWx1ZSk7XG4gICAgfSxcbiAgICB1c2VUcmFuc2l0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VUcmFuc2l0aW9uJztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHJlcmVuZGVyVHJhbnNpdGlvbigpO1xuICAgIH0sXG4gICAgdXNlTXV0YWJsZVNvdXJjZTogZnVuY3Rpb24gKHNvdXJjZSwgZ2V0U25hcHNob3QsIHN1YnNjcmliZSkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlTXV0YWJsZVNvdXJjZSc7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiB1cGRhdGVNdXRhYmxlU291cmNlKHNvdXJjZSwgZ2V0U25hcHNob3QsIHN1YnNjcmliZSk7XG4gICAgfSxcbiAgICB1c2VPcGFxdWVJZGVudGlmaWVyOiBmdW5jdGlvbiAoKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VPcGFxdWVJZGVudGlmaWVyJztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHJlcmVuZGVyT3BhcXVlSWRlbnRpZmllcigpO1xuICAgIH0sXG4gICAgdW5zdGFibGVfaXNOZXdSZWNvbmNpbGVyOiBlbmFibGVOZXdSZWNvbmNpbGVyXG4gIH07XG4gIEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPbk1vdW50SW5ERVYgPSB7XG4gICAgcmVhZENvbnRleHQ6IGZ1bmN0aW9uIChjb250ZXh0LCBvYnNlcnZlZEJpdHMpIHtcbiAgICAgIHdhcm5JbnZhbGlkQ29udGV4dEFjY2VzcygpO1xuICAgICAgcmV0dXJuIHJlYWRDb250ZXh0KGNvbnRleHQsIG9ic2VydmVkQml0cyk7XG4gICAgfSxcbiAgICB1c2VDYWxsYmFjazogZnVuY3Rpb24gKGNhbGxiYWNrLCBkZXBzKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VDYWxsYmFjayc7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gbW91bnRDYWxsYmFjayhjYWxsYmFjaywgZGVwcyk7XG4gICAgfSxcbiAgICB1c2VDb250ZXh0OiBmdW5jdGlvbiAoY29udGV4dCwgb2JzZXJ2ZWRCaXRzKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VDb250ZXh0JztcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiByZWFkQ29udGV4dChjb250ZXh0LCBvYnNlcnZlZEJpdHMpO1xuICAgIH0sXG4gICAgdXNlRWZmZWN0OiBmdW5jdGlvbiAoY3JlYXRlLCBkZXBzKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VFZmZlY3QnO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIG1vdW50RWZmZWN0KGNyZWF0ZSwgZGVwcyk7XG4gICAgfSxcbiAgICB1c2VJbXBlcmF0aXZlSGFuZGxlOiBmdW5jdGlvbiAocmVmLCBjcmVhdGUsIGRlcHMpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUltcGVyYXRpdmVIYW5kbGUnO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIG1vdW50SW1wZXJhdGl2ZUhhbmRsZShyZWYsIGNyZWF0ZSwgZGVwcyk7XG4gICAgfSxcbiAgICB1c2VMYXlvdXRFZmZlY3Q6IGZ1bmN0aW9uIChjcmVhdGUsIGRlcHMpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUxheW91dEVmZmVjdCc7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gbW91bnRMYXlvdXRFZmZlY3QoY3JlYXRlLCBkZXBzKTtcbiAgICB9LFxuICAgIHVzZU1lbW86IGZ1bmN0aW9uIChjcmVhdGUsIGRlcHMpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZU1lbW8nO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgdmFyIHByZXZEaXNwYXRjaGVyID0gUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQ7XG4gICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudCA9IEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPbk1vdW50SW5ERVY7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBtb3VudE1lbW8oY3JlYXRlLCBkZXBzKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gcHJldkRpc3BhdGNoZXI7XG4gICAgICB9XG4gICAgfSxcbiAgICB1c2VSZWR1Y2VyOiBmdW5jdGlvbiAocmVkdWNlciwgaW5pdGlhbEFyZywgaW5pdCkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlUmVkdWNlcic7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICB2YXIgcHJldkRpc3BhdGNoZXIgPSBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudDtcbiAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uTW91bnRJbkRFVjtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIG1vdW50UmVkdWNlcihyZWR1Y2VyLCBpbml0aWFsQXJnLCBpbml0KTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gcHJldkRpc3BhdGNoZXI7XG4gICAgICB9XG4gICAgfSxcbiAgICB1c2VSZWY6IGZ1bmN0aW9uIChpbml0aWFsVmFsdWUpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZVJlZic7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gbW91bnRSZWYoaW5pdGlhbFZhbHVlKTtcbiAgICB9LFxuICAgIHVzZVN0YXRlOiBmdW5jdGlvbiAoaW5pdGlhbFN0YXRlKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VTdGF0ZSc7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICB2YXIgcHJldkRpc3BhdGNoZXIgPSBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudDtcbiAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uTW91bnRJbkRFVjtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIG1vdW50U3RhdGUoaW5pdGlhbFN0YXRlKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gcHJldkRpc3BhdGNoZXI7XG4gICAgICB9XG4gICAgfSxcbiAgICB1c2VEZWJ1Z1ZhbHVlOiBmdW5jdGlvbiAodmFsdWUsIGZvcm1hdHRlckZuKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VEZWJ1Z1ZhbHVlJztcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiBtb3VudERlYnVnVmFsdWUoKTtcbiAgICB9LFxuICAgIHVzZURlZmVycmVkVmFsdWU6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlRGVmZXJyZWRWYWx1ZSc7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gbW91bnREZWZlcnJlZFZhbHVlKHZhbHVlKTtcbiAgICB9LFxuICAgIHVzZVRyYW5zaXRpb246IGZ1bmN0aW9uICgpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZVRyYW5zaXRpb24nO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIG1vdW50VHJhbnNpdGlvbigpO1xuICAgIH0sXG4gICAgdXNlTXV0YWJsZVNvdXJjZTogZnVuY3Rpb24gKHNvdXJjZSwgZ2V0U25hcHNob3QsIHN1YnNjcmliZSkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlTXV0YWJsZVNvdXJjZSc7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gbW91bnRNdXRhYmxlU291cmNlKHNvdXJjZSwgZ2V0U25hcHNob3QsIHN1YnNjcmliZSk7XG4gICAgfSxcbiAgICB1c2VPcGFxdWVJZGVudGlmaWVyOiBmdW5jdGlvbiAoKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VPcGFxdWVJZGVudGlmaWVyJztcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiBtb3VudE9wYXF1ZUlkZW50aWZpZXIoKTtcbiAgICB9LFxuICAgIHVuc3RhYmxlX2lzTmV3UmVjb25jaWxlcjogZW5hYmxlTmV3UmVjb25jaWxlclxuICB9O1xuICBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25VcGRhdGVJbkRFViA9IHtcbiAgICByZWFkQ29udGV4dDogZnVuY3Rpb24gKGNvbnRleHQsIG9ic2VydmVkQml0cykge1xuICAgICAgd2FybkludmFsaWRDb250ZXh0QWNjZXNzKCk7XG4gICAgICByZXR1cm4gcmVhZENvbnRleHQoY29udGV4dCwgb2JzZXJ2ZWRCaXRzKTtcbiAgICB9LFxuICAgIHVzZUNhbGxiYWNrOiBmdW5jdGlvbiAoY2FsbGJhY2ssIGRlcHMpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUNhbGxiYWNrJztcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gdXBkYXRlQ2FsbGJhY2soY2FsbGJhY2ssIGRlcHMpO1xuICAgIH0sXG4gICAgdXNlQ29udGV4dDogZnVuY3Rpb24gKGNvbnRleHQsIG9ic2VydmVkQml0cykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlQ29udGV4dCc7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHJlYWRDb250ZXh0KGNvbnRleHQsIG9ic2VydmVkQml0cyk7XG4gICAgfSxcbiAgICB1c2VFZmZlY3Q6IGZ1bmN0aW9uIChjcmVhdGUsIGRlcHMpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUVmZmVjdCc7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHVwZGF0ZUVmZmVjdChjcmVhdGUsIGRlcHMpO1xuICAgIH0sXG4gICAgdXNlSW1wZXJhdGl2ZUhhbmRsZTogZnVuY3Rpb24gKHJlZiwgY3JlYXRlLCBkZXBzKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VJbXBlcmF0aXZlSGFuZGxlJztcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gdXBkYXRlSW1wZXJhdGl2ZUhhbmRsZShyZWYsIGNyZWF0ZSwgZGVwcyk7XG4gICAgfSxcbiAgICB1c2VMYXlvdXRFZmZlY3Q6IGZ1bmN0aW9uIChjcmVhdGUsIGRlcHMpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUxheW91dEVmZmVjdCc7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHVwZGF0ZUxheW91dEVmZmVjdChjcmVhdGUsIGRlcHMpO1xuICAgIH0sXG4gICAgdXNlTWVtbzogZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlTWVtbyc7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgdmFyIHByZXZEaXNwYXRjaGVyID0gUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQ7XG4gICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudCA9IEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPblVwZGF0ZUluREVWO1xuXG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gdXBkYXRlTWVtbyhjcmVhdGUsIGRlcHMpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSBwcmV2RGlzcGF0Y2hlcjtcbiAgICAgIH1cbiAgICB9LFxuICAgIHVzZVJlZHVjZXI6IGZ1bmN0aW9uIChyZWR1Y2VyLCBpbml0aWFsQXJnLCBpbml0KSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VSZWR1Y2VyJztcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICB2YXIgcHJldkRpc3BhdGNoZXIgPSBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudDtcbiAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uVXBkYXRlSW5ERVY7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiB1cGRhdGVSZWR1Y2VyKHJlZHVjZXIsIGluaXRpYWxBcmcsIGluaXQpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSBwcmV2RGlzcGF0Y2hlcjtcbiAgICAgIH1cbiAgICB9LFxuICAgIHVzZVJlZjogZnVuY3Rpb24gKGluaXRpYWxWYWx1ZSkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlUmVmJztcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gdXBkYXRlUmVmKCk7XG4gICAgfSxcbiAgICB1c2VTdGF0ZTogZnVuY3Rpb24gKGluaXRpYWxTdGF0ZSkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlU3RhdGUnO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHZhciBwcmV2RGlzcGF0Y2hlciA9IFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50O1xuICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25VcGRhdGVJbkRFVjtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIHVwZGF0ZVN0YXRlKGluaXRpYWxTdGF0ZSk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudCA9IHByZXZEaXNwYXRjaGVyO1xuICAgICAgfVxuICAgIH0sXG4gICAgdXNlRGVidWdWYWx1ZTogZnVuY3Rpb24gKHZhbHVlLCBmb3JtYXR0ZXJGbikge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlRGVidWdWYWx1ZSc7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHVwZGF0ZURlYnVnVmFsdWUoKTtcbiAgICB9LFxuICAgIHVzZURlZmVycmVkVmFsdWU6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlRGVmZXJyZWRWYWx1ZSc7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHVwZGF0ZURlZmVycmVkVmFsdWUodmFsdWUpO1xuICAgIH0sXG4gICAgdXNlVHJhbnNpdGlvbjogZnVuY3Rpb24gKCkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlVHJhbnNpdGlvbic7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHVwZGF0ZVRyYW5zaXRpb24oKTtcbiAgICB9LFxuICAgIHVzZU11dGFibGVTb3VyY2U6IGZ1bmN0aW9uIChzb3VyY2UsIGdldFNuYXBzaG90LCBzdWJzY3JpYmUpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZU11dGFibGVTb3VyY2UnO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiB1cGRhdGVNdXRhYmxlU291cmNlKHNvdXJjZSwgZ2V0U25hcHNob3QsIHN1YnNjcmliZSk7XG4gICAgfSxcbiAgICB1c2VPcGFxdWVJZGVudGlmaWVyOiBmdW5jdGlvbiAoKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VPcGFxdWVJZGVudGlmaWVyJztcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gdXBkYXRlT3BhcXVlSWRlbnRpZmllcigpO1xuICAgIH0sXG4gICAgdW5zdGFibGVfaXNOZXdSZWNvbmNpbGVyOiBlbmFibGVOZXdSZWNvbmNpbGVyXG4gIH07XG4gIEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPblJlcmVuZGVySW5ERVYgPSB7XG4gICAgcmVhZENvbnRleHQ6IGZ1bmN0aW9uIChjb250ZXh0LCBvYnNlcnZlZEJpdHMpIHtcbiAgICAgIHdhcm5JbnZhbGlkQ29udGV4dEFjY2VzcygpO1xuICAgICAgcmV0dXJuIHJlYWRDb250ZXh0KGNvbnRleHQsIG9ic2VydmVkQml0cyk7XG4gICAgfSxcbiAgICB1c2VDYWxsYmFjazogZnVuY3Rpb24gKGNhbGxiYWNrLCBkZXBzKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VDYWxsYmFjayc7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHVwZGF0ZUNhbGxiYWNrKGNhbGxiYWNrLCBkZXBzKTtcbiAgICB9LFxuICAgIHVzZUNvbnRleHQ6IGZ1bmN0aW9uIChjb250ZXh0LCBvYnNlcnZlZEJpdHMpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUNvbnRleHQnO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiByZWFkQ29udGV4dChjb250ZXh0LCBvYnNlcnZlZEJpdHMpO1xuICAgIH0sXG4gICAgdXNlRWZmZWN0OiBmdW5jdGlvbiAoY3JlYXRlLCBkZXBzKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VFZmZlY3QnO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiB1cGRhdGVFZmZlY3QoY3JlYXRlLCBkZXBzKTtcbiAgICB9LFxuICAgIHVzZUltcGVyYXRpdmVIYW5kbGU6IGZ1bmN0aW9uIChyZWYsIGNyZWF0ZSwgZGVwcykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlSW1wZXJhdGl2ZUhhbmRsZSc7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHVwZGF0ZUltcGVyYXRpdmVIYW5kbGUocmVmLCBjcmVhdGUsIGRlcHMpO1xuICAgIH0sXG4gICAgdXNlTGF5b3V0RWZmZWN0OiBmdW5jdGlvbiAoY3JlYXRlLCBkZXBzKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VMYXlvdXRFZmZlY3QnO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiB1cGRhdGVMYXlvdXRFZmZlY3QoY3JlYXRlLCBkZXBzKTtcbiAgICB9LFxuICAgIHVzZU1lbW86IGZ1bmN0aW9uIChjcmVhdGUsIGRlcHMpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZU1lbW8nO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHZhciBwcmV2RGlzcGF0Y2hlciA9IFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50O1xuICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25VcGRhdGVJbkRFVjtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIHVwZGF0ZU1lbW8oY3JlYXRlLCBkZXBzKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gcHJldkRpc3BhdGNoZXI7XG4gICAgICB9XG4gICAgfSxcbiAgICB1c2VSZWR1Y2VyOiBmdW5jdGlvbiAocmVkdWNlciwgaW5pdGlhbEFyZywgaW5pdCkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlUmVkdWNlcic7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgdmFyIHByZXZEaXNwYXRjaGVyID0gUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQ7XG4gICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudCA9IEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPblVwZGF0ZUluREVWO1xuXG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gcmVyZW5kZXJSZWR1Y2VyKHJlZHVjZXIsIGluaXRpYWxBcmcsIGluaXQpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSBwcmV2RGlzcGF0Y2hlcjtcbiAgICAgIH1cbiAgICB9LFxuICAgIHVzZVJlZjogZnVuY3Rpb24gKGluaXRpYWxWYWx1ZSkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlUmVmJztcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gdXBkYXRlUmVmKCk7XG4gICAgfSxcbiAgICB1c2VTdGF0ZTogZnVuY3Rpb24gKGluaXRpYWxTdGF0ZSkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlU3RhdGUnO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHZhciBwcmV2RGlzcGF0Y2hlciA9IFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50O1xuICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25VcGRhdGVJbkRFVjtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIHJlcmVuZGVyU3RhdGUoaW5pdGlhbFN0YXRlKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gcHJldkRpc3BhdGNoZXI7XG4gICAgICB9XG4gICAgfSxcbiAgICB1c2VEZWJ1Z1ZhbHVlOiBmdW5jdGlvbiAodmFsdWUsIGZvcm1hdHRlckZuKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VEZWJ1Z1ZhbHVlJztcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gdXBkYXRlRGVidWdWYWx1ZSgpO1xuICAgIH0sXG4gICAgdXNlRGVmZXJyZWRWYWx1ZTogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VEZWZlcnJlZFZhbHVlJztcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gcmVyZW5kZXJEZWZlcnJlZFZhbHVlKHZhbHVlKTtcbiAgICB9LFxuICAgIHVzZVRyYW5zaXRpb246IGZ1bmN0aW9uICgpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZVRyYW5zaXRpb24nO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiByZXJlbmRlclRyYW5zaXRpb24oKTtcbiAgICB9LFxuICAgIHVzZU11dGFibGVTb3VyY2U6IGZ1bmN0aW9uIChzb3VyY2UsIGdldFNuYXBzaG90LCBzdWJzY3JpYmUpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZU11dGFibGVTb3VyY2UnO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiB1cGRhdGVNdXRhYmxlU291cmNlKHNvdXJjZSwgZ2V0U25hcHNob3QsIHN1YnNjcmliZSk7XG4gICAgfSxcbiAgICB1c2VPcGFxdWVJZGVudGlmaWVyOiBmdW5jdGlvbiAoKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VPcGFxdWVJZGVudGlmaWVyJztcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gcmVyZW5kZXJPcGFxdWVJZGVudGlmaWVyKCk7XG4gICAgfSxcbiAgICB1bnN0YWJsZV9pc05ld1JlY29uY2lsZXI6IGVuYWJsZU5ld1JlY29uY2lsZXJcbiAgfTtcbn1cblxudmFyIG5vdyQxID0gU2NoZWR1bGVyLnVuc3RhYmxlX25vdztcbnZhciBjb21taXRUaW1lID0gMDtcbnZhciBwcm9maWxlclN0YXJ0VGltZSA9IC0xO1xuXG5mdW5jdGlvbiBnZXRDb21taXRUaW1lKCkge1xuICByZXR1cm4gY29tbWl0VGltZTtcbn1cblxuZnVuY3Rpb24gcmVjb3JkQ29tbWl0VGltZSgpIHtcblxuICBjb21taXRUaW1lID0gbm93JDEoKTtcbn1cblxuZnVuY3Rpb24gc3RhcnRQcm9maWxlclRpbWVyKGZpYmVyKSB7XG5cbiAgcHJvZmlsZXJTdGFydFRpbWUgPSBub3ckMSgpO1xuXG4gIGlmIChmaWJlci5hY3R1YWxTdGFydFRpbWUgPCAwKSB7XG4gICAgZmliZXIuYWN0dWFsU3RhcnRUaW1lID0gbm93JDEoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzdG9wUHJvZmlsZXJUaW1lcklmUnVubmluZyhmaWJlcikge1xuXG4gIHByb2ZpbGVyU3RhcnRUaW1lID0gLTE7XG59XG5cbmZ1bmN0aW9uIHN0b3BQcm9maWxlclRpbWVySWZSdW5uaW5nQW5kUmVjb3JkRGVsdGEoZmliZXIsIG92ZXJyaWRlQmFzZVRpbWUpIHtcblxuICBpZiAocHJvZmlsZXJTdGFydFRpbWUgPj0gMCkge1xuICAgIHZhciBlbGFwc2VkVGltZSA9IG5vdyQxKCkgLSBwcm9maWxlclN0YXJ0VGltZTtcbiAgICBmaWJlci5hY3R1YWxEdXJhdGlvbiArPSBlbGFwc2VkVGltZTtcblxuICAgIGlmIChvdmVycmlkZUJhc2VUaW1lKSB7XG4gICAgICBmaWJlci5zZWxmQmFzZUR1cmF0aW9uID0gZWxhcHNlZFRpbWU7XG4gICAgfVxuXG4gICAgcHJvZmlsZXJTdGFydFRpbWUgPSAtMTtcbiAgfVxufVxuXG5mdW5jdGlvbiB0cmFuc2ZlckFjdHVhbER1cmF0aW9uKGZpYmVyKSB7XG4gIC8vIFRyYW5zZmVyIHRpbWUgc3BlbnQgcmVuZGVyaW5nIHRoZXNlIGNoaWxkcmVuIHNvIHdlIGRvbid0IGxvc2UgaXRcbiAgLy8gYWZ0ZXIgd2UgcmVyZW5kZXIuIFRoaXMgaXMgdXNlZCBhcyBhIGhlbHBlciBpbiBzcGVjaWFsIGNhc2VzXG4gIC8vIHdoZXJlIHdlIHNob3VsZCBjb3VudCB0aGUgd29yayBvZiBtdWx0aXBsZSBwYXNzZXMuXG4gIHZhciBjaGlsZCA9IGZpYmVyLmNoaWxkO1xuXG4gIHdoaWxlIChjaGlsZCkge1xuICAgIGZpYmVyLmFjdHVhbER1cmF0aW9uICs9IGNoaWxkLmFjdHVhbER1cmF0aW9uO1xuICAgIGNoaWxkID0gY2hpbGQuc2libGluZztcbiAgfVxufVxuXG52YXIgUmVhY3RDdXJyZW50T3duZXIkMSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0Q3VycmVudE93bmVyO1xudmFyIGRpZFJlY2VpdmVVcGRhdGUgPSBmYWxzZTtcbnZhciBkaWRXYXJuQWJvdXRCYWRDbGFzcztcbnZhciBkaWRXYXJuQWJvdXRNb2R1bGVQYXR0ZXJuQ29tcG9uZW50O1xudmFyIGRpZFdhcm5BYm91dENvbnRleHRUeXBlT25GdW5jdGlvbkNvbXBvbmVudDtcbnZhciBkaWRXYXJuQWJvdXRHZXREZXJpdmVkU3RhdGVPbkZ1bmN0aW9uQ29tcG9uZW50O1xudmFyIGRpZFdhcm5BYm91dEZ1bmN0aW9uUmVmcztcbnZhciBkaWRXYXJuQWJvdXRSZWFzc2lnbmluZ1Byb3BzO1xudmFyIGRpZFdhcm5BYm91dFJldmVhbE9yZGVyO1xudmFyIGRpZFdhcm5BYm91dFRhaWxPcHRpb25zO1xuXG57XG4gIGRpZFdhcm5BYm91dEJhZENsYXNzID0ge307XG4gIGRpZFdhcm5BYm91dE1vZHVsZVBhdHRlcm5Db21wb25lbnQgPSB7fTtcbiAgZGlkV2FybkFib3V0Q29udGV4dFR5cGVPbkZ1bmN0aW9uQ29tcG9uZW50ID0ge307XG4gIGRpZFdhcm5BYm91dEdldERlcml2ZWRTdGF0ZU9uRnVuY3Rpb25Db21wb25lbnQgPSB7fTtcbiAgZGlkV2FybkFib3V0RnVuY3Rpb25SZWZzID0ge307XG4gIGRpZFdhcm5BYm91dFJlYXNzaWduaW5nUHJvcHMgPSBmYWxzZTtcbiAgZGlkV2FybkFib3V0UmV2ZWFsT3JkZXIgPSB7fTtcbiAgZGlkV2FybkFib3V0VGFpbE9wdGlvbnMgPSB7fTtcbn1cblxuZnVuY3Rpb24gcmVjb25jaWxlQ2hpbGRyZW4oY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG5leHRDaGlsZHJlbiwgcmVuZGVyTGFuZXMpIHtcbiAgaWYgKGN1cnJlbnQgPT09IG51bGwpIHtcbiAgICAvLyBJZiB0aGlzIGlzIGEgZnJlc2ggbmV3IGNvbXBvbmVudCB0aGF0IGhhc24ndCBiZWVuIHJlbmRlcmVkIHlldCwgd2VcbiAgICAvLyB3b24ndCB1cGRhdGUgaXRzIGNoaWxkIHNldCBieSBhcHBseWluZyBtaW5pbWFsIHNpZGUtZWZmZWN0cy4gSW5zdGVhZCxcbiAgICAvLyB3ZSB3aWxsIGFkZCB0aGVtIGFsbCB0byB0aGUgY2hpbGQgYmVmb3JlIGl0IGdldHMgcmVuZGVyZWQuIFRoYXQgbWVhbnNcbiAgICAvLyB3ZSBjYW4gb3B0aW1pemUgdGhpcyByZWNvbmNpbGlhdGlvbiBwYXNzIGJ5IG5vdCB0cmFja2luZyBzaWRlLWVmZmVjdHMuXG4gICAgd29ya0luUHJvZ3Jlc3MuY2hpbGQgPSBtb3VudENoaWxkRmliZXJzKHdvcmtJblByb2dyZXNzLCBudWxsLCBuZXh0Q2hpbGRyZW4sIHJlbmRlckxhbmVzKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBJZiB0aGUgY3VycmVudCBjaGlsZCBpcyB0aGUgc2FtZSBhcyB0aGUgd29yayBpbiBwcm9ncmVzcywgaXQgbWVhbnMgdGhhdFxuICAgIC8vIHdlIGhhdmVuJ3QgeWV0IHN0YXJ0ZWQgYW55IHdvcmsgb24gdGhlc2UgY2hpbGRyZW4uIFRoZXJlZm9yZSwgd2UgdXNlXG4gICAgLy8gdGhlIGNsb25lIGFsZ29yaXRobSB0byBjcmVhdGUgYSBjb3B5IG9mIGFsbCB0aGUgY3VycmVudCBjaGlsZHJlbi5cbiAgICAvLyBJZiB3ZSBoYWQgYW55IHByb2dyZXNzZWQgd29yayBhbHJlYWR5LCB0aGF0IGlzIGludmFsaWQgYXQgdGhpcyBwb2ludCBzb1xuICAgIC8vIGxldCdzIHRocm93IGl0IG91dC5cbiAgICB3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IHJlY29uY2lsZUNoaWxkRmliZXJzKHdvcmtJblByb2dyZXNzLCBjdXJyZW50LmNoaWxkLCBuZXh0Q2hpbGRyZW4sIHJlbmRlckxhbmVzKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBmb3JjZVVubW91bnRDdXJyZW50QW5kUmVjb25jaWxlKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBuZXh0Q2hpbGRyZW4sIHJlbmRlckxhbmVzKSB7XG4gIC8vIFRoaXMgZnVuY3Rpb24gaXMgZm9yayBvZiByZWNvbmNpbGVDaGlsZHJlbi4gSXQncyB1c2VkIGluIGNhc2VzIHdoZXJlIHdlXG4gIC8vIHdhbnQgdG8gcmVjb25jaWxlIHdpdGhvdXQgbWF0Y2hpbmcgYWdhaW5zdCB0aGUgZXhpc3Rpbmcgc2V0LiBUaGlzIGhhcyB0aGVcbiAgLy8gZWZmZWN0IG9mIGFsbCBjdXJyZW50IGNoaWxkcmVuIGJlaW5nIHVubW91bnRlZDsgZXZlbiBpZiB0aGUgdHlwZSBhbmQga2V5XG4gIC8vIGFyZSB0aGUgc2FtZSwgdGhlIG9sZCBjaGlsZCBpcyB1bm1vdW50ZWQgYW5kIGEgbmV3IGNoaWxkIGlzIGNyZWF0ZWQuXG4gIC8vXG4gIC8vIFRvIGRvIHRoaXMsIHdlJ3JlIGdvaW5nIHRvIGdvIHRocm91Z2ggdGhlIHJlY29uY2lsZSBhbGdvcml0aG0gdHdpY2UuIEluXG4gIC8vIHRoZSBmaXJzdCBwYXNzLCB3ZSBzY2hlZHVsZSBhIGRlbGV0aW9uIGZvciBhbGwgdGhlIGN1cnJlbnQgY2hpbGRyZW4gYnlcbiAgLy8gcGFzc2luZyBudWxsLlxuICB3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IHJlY29uY2lsZUNoaWxkRmliZXJzKHdvcmtJblByb2dyZXNzLCBjdXJyZW50LmNoaWxkLCBudWxsLCByZW5kZXJMYW5lcyk7IC8vIEluIHRoZSBzZWNvbmQgcGFzcywgd2UgbW91bnQgdGhlIG5ldyBjaGlsZHJlbi4gVGhlIHRyaWNrIGhlcmUgaXMgdGhhdCB3ZVxuICAvLyBwYXNzIG51bGwgaW4gcGxhY2Ugb2Ygd2hlcmUgd2UgdXN1YWxseSBwYXNzIHRoZSBjdXJyZW50IGNoaWxkIHNldC4gVGhpcyBoYXNcbiAgLy8gdGhlIGVmZmVjdCBvZiByZW1vdW50aW5nIGFsbCBjaGlsZHJlbiByZWdhcmRsZXNzIG9mIHdoZXRoZXIgdGhlaXJcbiAgLy8gaWRlbnRpdGllcyBtYXRjaC5cblxuICB3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IHJlY29uY2lsZUNoaWxkRmliZXJzKHdvcmtJblByb2dyZXNzLCBudWxsLCBuZXh0Q2hpbGRyZW4sIHJlbmRlckxhbmVzKTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlRm9yd2FyZFJlZihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgQ29tcG9uZW50LCBuZXh0UHJvcHMsIHJlbmRlckxhbmVzKSB7XG4gIC8vIFRPRE86IGN1cnJlbnQgY2FuIGJlIG5vbi1udWxsIGhlcmUgZXZlbiBpZiB0aGUgY29tcG9uZW50XG4gIC8vIGhhc24ndCB5ZXQgbW91bnRlZC4gVGhpcyBoYXBwZW5zIGFmdGVyIHRoZSBmaXJzdCByZW5kZXIgc3VzcGVuZHMuXG4gIC8vIFdlJ2xsIG5lZWQgdG8gZmlndXJlIG91dCBpZiB0aGlzIGlzIGZpbmUgb3IgY2FuIGNhdXNlIGlzc3Vlcy5cbiAge1xuICAgIGlmICh3b3JrSW5Qcm9ncmVzcy50eXBlICE9PSB3b3JrSW5Qcm9ncmVzcy5lbGVtZW50VHlwZSkge1xuICAgICAgLy8gTGF6eSBjb21wb25lbnQgcHJvcHMgY2FuJ3QgYmUgdmFsaWRhdGVkIGluIGNyZWF0ZUVsZW1lbnRcbiAgICAgIC8vIGJlY2F1c2UgdGhleSdyZSBvbmx5IGd1YXJhbnRlZWQgdG8gYmUgcmVzb2x2ZWQgaGVyZS5cbiAgICAgIHZhciBpbm5lclByb3BUeXBlcyA9IENvbXBvbmVudC5wcm9wVHlwZXM7XG5cbiAgICAgIGlmIChpbm5lclByb3BUeXBlcykge1xuICAgICAgICBjaGVja1Byb3BUeXBlcyhpbm5lclByb3BUeXBlcywgbmV4dFByb3BzLCAvLyBSZXNvbHZlZCBwcm9wc1xuICAgICAgICAncHJvcCcsIGdldENvbXBvbmVudE5hbWUoQ29tcG9uZW50KSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIHJlbmRlciA9IENvbXBvbmVudC5yZW5kZXI7XG4gIHZhciByZWYgPSB3b3JrSW5Qcm9ncmVzcy5yZWY7IC8vIFRoZSByZXN0IGlzIGEgZm9yayBvZiB1cGRhdGVGdW5jdGlvbkNvbXBvbmVudFxuXG4gIHZhciBuZXh0Q2hpbGRyZW47XG4gIHByZXBhcmVUb1JlYWRDb250ZXh0KHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcyk7XG5cbiAge1xuICAgIFJlYWN0Q3VycmVudE93bmVyJDEuY3VycmVudCA9IHdvcmtJblByb2dyZXNzO1xuICAgIHNldElzUmVuZGVyaW5nKHRydWUpO1xuICAgIG5leHRDaGlsZHJlbiA9IHJlbmRlcldpdGhIb29rcyhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyLCBuZXh0UHJvcHMsIHJlZiwgcmVuZGVyTGFuZXMpO1xuXG4gICAgaWYgKCB3b3JrSW5Qcm9ncmVzcy5tb2RlICYgU3RyaWN0TW9kZSkge1xuICAgICAgZGlzYWJsZUxvZ3MoKTtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgbmV4dENoaWxkcmVuID0gcmVuZGVyV2l0aEhvb2tzKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXIsIG5leHRQcm9wcywgcmVmLCByZW5kZXJMYW5lcyk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICByZWVuYWJsZUxvZ3MoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzZXRJc1JlbmRlcmluZyhmYWxzZSk7XG4gIH1cblxuICBpZiAoY3VycmVudCAhPT0gbnVsbCAmJiAhZGlkUmVjZWl2ZVVwZGF0ZSkge1xuICAgIGJhaWxvdXRIb29rcyhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpO1xuICAgIHJldHVybiBiYWlsb3V0T25BbHJlYWR5RmluaXNoZWRXb3JrKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcyk7XG4gIH0gLy8gUmVhY3QgRGV2VG9vbHMgcmVhZHMgdGhpcyBmbGFnLlxuXG5cbiAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gUGVyZm9ybWVkV29yaztcbiAgcmVjb25jaWxlQ2hpbGRyZW4oY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG5leHRDaGlsZHJlbiwgcmVuZGVyTGFuZXMpO1xuICByZXR1cm4gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZU1lbW9Db21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIENvbXBvbmVudCwgbmV4dFByb3BzLCB1cGRhdGVMYW5lcywgcmVuZGVyTGFuZXMpIHtcbiAgaWYgKGN1cnJlbnQgPT09IG51bGwpIHtcbiAgICB2YXIgdHlwZSA9IENvbXBvbmVudC50eXBlO1xuXG4gICAgaWYgKGlzU2ltcGxlRnVuY3Rpb25Db21wb25lbnQodHlwZSkgJiYgQ29tcG9uZW50LmNvbXBhcmUgPT09IG51bGwgJiYgLy8gU2ltcGxlTWVtb0NvbXBvbmVudCBjb2RlcGF0aCBkb2Vzbid0IHJlc29sdmUgb3V0ZXIgcHJvcHMgZWl0aGVyLlxuICAgIENvbXBvbmVudC5kZWZhdWx0UHJvcHMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdmFyIHJlc29sdmVkVHlwZSA9IHR5cGU7XG5cbiAgICAgIHtcbiAgICAgICAgcmVzb2x2ZWRUeXBlID0gcmVzb2x2ZUZ1bmN0aW9uRm9ySG90UmVsb2FkaW5nKHR5cGUpO1xuICAgICAgfSAvLyBJZiB0aGlzIGlzIGEgcGxhaW4gZnVuY3Rpb24gY29tcG9uZW50IHdpdGhvdXQgZGVmYXVsdCBwcm9wcyxcbiAgICAgIC8vIGFuZCB3aXRoIG9ubHkgdGhlIGRlZmF1bHQgc2hhbGxvdyBjb21wYXJpc29uLCB3ZSB1cGdyYWRlIGl0XG4gICAgICAvLyB0byBhIFNpbXBsZU1lbW9Db21wb25lbnQgdG8gYWxsb3cgZmFzdCBwYXRoIHVwZGF0ZXMuXG5cblxuICAgICAgd29ya0luUHJvZ3Jlc3MudGFnID0gU2ltcGxlTWVtb0NvbXBvbmVudDtcbiAgICAgIHdvcmtJblByb2dyZXNzLnR5cGUgPSByZXNvbHZlZFR5cGU7XG5cbiAgICAgIHtcbiAgICAgICAgdmFsaWRhdGVGdW5jdGlvbkNvbXBvbmVudEluRGV2KHdvcmtJblByb2dyZXNzLCB0eXBlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHVwZGF0ZVNpbXBsZU1lbW9Db21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlc29sdmVkVHlwZSwgbmV4dFByb3BzLCB1cGRhdGVMYW5lcywgcmVuZGVyTGFuZXMpO1xuICAgIH1cblxuICAgIHtcbiAgICAgIHZhciBpbm5lclByb3BUeXBlcyA9IHR5cGUucHJvcFR5cGVzO1xuXG4gICAgICBpZiAoaW5uZXJQcm9wVHlwZXMpIHtcbiAgICAgICAgLy8gSW5uZXIgbWVtbyBjb21wb25lbnQgcHJvcHMgYXJlbid0IGN1cnJlbnRseSB2YWxpZGF0ZWQgaW4gY3JlYXRlRWxlbWVudC5cbiAgICAgICAgLy8gV2UgY291bGQgbW92ZSBpdCB0aGVyZSwgYnV0IHdlJ2Qgc3RpbGwgbmVlZCB0aGlzIGZvciBsYXp5IGNvZGUgcGF0aC5cbiAgICAgICAgY2hlY2tQcm9wVHlwZXMoaW5uZXJQcm9wVHlwZXMsIG5leHRQcm9wcywgLy8gUmVzb2x2ZWQgcHJvcHNcbiAgICAgICAgJ3Byb3AnLCBnZXRDb21wb25lbnROYW1lKHR5cGUpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgY2hpbGQgPSBjcmVhdGVGaWJlckZyb21UeXBlQW5kUHJvcHMoQ29tcG9uZW50LnR5cGUsIG51bGwsIG5leHRQcm9wcywgd29ya0luUHJvZ3Jlc3MsIHdvcmtJblByb2dyZXNzLm1vZGUsIHJlbmRlckxhbmVzKTtcbiAgICBjaGlsZC5yZWYgPSB3b3JrSW5Qcm9ncmVzcy5yZWY7XG4gICAgY2hpbGQucmV0dXJuID0gd29ya0luUHJvZ3Jlc3M7XG4gICAgd29ya0luUHJvZ3Jlc3MuY2hpbGQgPSBjaGlsZDtcbiAgICByZXR1cm4gY2hpbGQ7XG4gIH1cblxuICB7XG4gICAgdmFyIF90eXBlID0gQ29tcG9uZW50LnR5cGU7XG4gICAgdmFyIF9pbm5lclByb3BUeXBlcyA9IF90eXBlLnByb3BUeXBlcztcblxuICAgIGlmIChfaW5uZXJQcm9wVHlwZXMpIHtcbiAgICAgIC8vIElubmVyIG1lbW8gY29tcG9uZW50IHByb3BzIGFyZW4ndCBjdXJyZW50bHkgdmFsaWRhdGVkIGluIGNyZWF0ZUVsZW1lbnQuXG4gICAgICAvLyBXZSBjb3VsZCBtb3ZlIGl0IHRoZXJlLCBidXQgd2UnZCBzdGlsbCBuZWVkIHRoaXMgZm9yIGxhenkgY29kZSBwYXRoLlxuICAgICAgY2hlY2tQcm9wVHlwZXMoX2lubmVyUHJvcFR5cGVzLCBuZXh0UHJvcHMsIC8vIFJlc29sdmVkIHByb3BzXG4gICAgICAncHJvcCcsIGdldENvbXBvbmVudE5hbWUoX3R5cGUpKTtcbiAgICB9XG4gIH1cblxuICB2YXIgY3VycmVudENoaWxkID0gY3VycmVudC5jaGlsZDsgLy8gVGhpcyBpcyBhbHdheXMgZXhhY3RseSBvbmUgY2hpbGRcblxuICBpZiAoIWluY2x1ZGVzU29tZUxhbmUodXBkYXRlTGFuZXMsIHJlbmRlckxhbmVzKSkge1xuICAgIC8vIFRoaXMgd2lsbCBiZSB0aGUgcHJvcHMgd2l0aCByZXNvbHZlZCBkZWZhdWx0UHJvcHMsXG4gICAgLy8gdW5saWtlIGN1cnJlbnQubWVtb2l6ZWRQcm9wcyB3aGljaCB3aWxsIGJlIHRoZSB1bnJlc29sdmVkIG9uZXMuXG4gICAgdmFyIHByZXZQcm9wcyA9IGN1cnJlbnRDaGlsZC5tZW1vaXplZFByb3BzOyAvLyBEZWZhdWx0IHRvIHNoYWxsb3cgY29tcGFyaXNvblxuXG4gICAgdmFyIGNvbXBhcmUgPSBDb21wb25lbnQuY29tcGFyZTtcbiAgICBjb21wYXJlID0gY29tcGFyZSAhPT0gbnVsbCA/IGNvbXBhcmUgOiBzaGFsbG93RXF1YWw7XG5cbiAgICBpZiAoY29tcGFyZShwcmV2UHJvcHMsIG5leHRQcm9wcykgJiYgY3VycmVudC5yZWYgPT09IHdvcmtJblByb2dyZXNzLnJlZikge1xuICAgICAgcmV0dXJuIGJhaWxvdXRPbkFscmVhZHlGaW5pc2hlZFdvcmsoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKTtcbiAgICB9XG4gIH0gLy8gUmVhY3QgRGV2VG9vbHMgcmVhZHMgdGhpcyBmbGFnLlxuXG5cbiAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gUGVyZm9ybWVkV29yaztcbiAgdmFyIG5ld0NoaWxkID0gY3JlYXRlV29ya0luUHJvZ3Jlc3MoY3VycmVudENoaWxkLCBuZXh0UHJvcHMpO1xuICBuZXdDaGlsZC5yZWYgPSB3b3JrSW5Qcm9ncmVzcy5yZWY7XG4gIG5ld0NoaWxkLnJldHVybiA9IHdvcmtJblByb2dyZXNzO1xuICB3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IG5ld0NoaWxkO1xuICByZXR1cm4gbmV3Q2hpbGQ7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZVNpbXBsZU1lbW9Db21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIENvbXBvbmVudCwgbmV4dFByb3BzLCB1cGRhdGVMYW5lcywgcmVuZGVyTGFuZXMpIHtcbiAgLy8gVE9ETzogY3VycmVudCBjYW4gYmUgbm9uLW51bGwgaGVyZSBldmVuIGlmIHRoZSBjb21wb25lbnRcbiAgLy8gaGFzbid0IHlldCBtb3VudGVkLiBUaGlzIGhhcHBlbnMgd2hlbiB0aGUgaW5uZXIgcmVuZGVyIHN1c3BlbmRzLlxuICAvLyBXZSdsbCBuZWVkIHRvIGZpZ3VyZSBvdXQgaWYgdGhpcyBpcyBmaW5lIG9yIGNhbiBjYXVzZSBpc3N1ZXMuXG4gIHtcbiAgICBpZiAod29ya0luUHJvZ3Jlc3MudHlwZSAhPT0gd29ya0luUHJvZ3Jlc3MuZWxlbWVudFR5cGUpIHtcbiAgICAgIC8vIExhenkgY29tcG9uZW50IHByb3BzIGNhbid0IGJlIHZhbGlkYXRlZCBpbiBjcmVhdGVFbGVtZW50XG4gICAgICAvLyBiZWNhdXNlIHRoZXkncmUgb25seSBndWFyYW50ZWVkIHRvIGJlIHJlc29sdmVkIGhlcmUuXG4gICAgICB2YXIgb3V0ZXJNZW1vVHlwZSA9IHdvcmtJblByb2dyZXNzLmVsZW1lbnRUeXBlO1xuXG4gICAgICBpZiAob3V0ZXJNZW1vVHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTEFaWV9UWVBFKSB7XG4gICAgICAgIC8vIFdlIHdhcm4gd2hlbiB5b3UgZGVmaW5lIHByb3BUeXBlcyBvbiBsYXp5KClcbiAgICAgICAgLy8gc28gbGV0J3MganVzdCBza2lwIG92ZXIgaXQgdG8gZmluZCBtZW1vKCkgb3V0ZXIgd3JhcHBlci5cbiAgICAgICAgLy8gSW5uZXIgcHJvcHMgZm9yIG1lbW8gYXJlIHZhbGlkYXRlZCBsYXRlci5cbiAgICAgICAgdmFyIGxhenlDb21wb25lbnQgPSBvdXRlck1lbW9UeXBlO1xuICAgICAgICB2YXIgcGF5bG9hZCA9IGxhenlDb21wb25lbnQuX3BheWxvYWQ7XG4gICAgICAgIHZhciBpbml0ID0gbGF6eUNvbXBvbmVudC5faW5pdDtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgIG91dGVyTWVtb1R5cGUgPSBpbml0KHBheWxvYWQpO1xuICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgb3V0ZXJNZW1vVHlwZSA9IG51bGw7XG4gICAgICAgIH0gLy8gSW5uZXIgcHJvcFR5cGVzIHdpbGwgYmUgdmFsaWRhdGVkIGluIHRoZSBmdW5jdGlvbiBjb21wb25lbnQgcGF0aC5cblxuXG4gICAgICAgIHZhciBvdXRlclByb3BUeXBlcyA9IG91dGVyTWVtb1R5cGUgJiYgb3V0ZXJNZW1vVHlwZS5wcm9wVHlwZXM7XG5cbiAgICAgICAgaWYgKG91dGVyUHJvcFR5cGVzKSB7XG4gICAgICAgICAgY2hlY2tQcm9wVHlwZXMob3V0ZXJQcm9wVHlwZXMsIG5leHRQcm9wcywgLy8gUmVzb2x2ZWQgKFNpbXBsZU1lbW9Db21wb25lbnQgaGFzIG5vIGRlZmF1bHRQcm9wcylcbiAgICAgICAgICAncHJvcCcsIGdldENvbXBvbmVudE5hbWUob3V0ZXJNZW1vVHlwZSkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKGN1cnJlbnQgIT09IG51bGwpIHtcbiAgICB2YXIgcHJldlByb3BzID0gY3VycmVudC5tZW1vaXplZFByb3BzO1xuXG4gICAgaWYgKHNoYWxsb3dFcXVhbChwcmV2UHJvcHMsIG5leHRQcm9wcykgJiYgY3VycmVudC5yZWYgPT09IHdvcmtJblByb2dyZXNzLnJlZiAmJiAoIC8vIFByZXZlbnQgYmFpbG91dCBpZiB0aGUgaW1wbGVtZW50YXRpb24gY2hhbmdlZCBkdWUgdG8gaG90IHJlbG9hZC5cbiAgICAgd29ya0luUHJvZ3Jlc3MudHlwZSA9PT0gY3VycmVudC50eXBlICkpIHtcbiAgICAgIGRpZFJlY2VpdmVVcGRhdGUgPSBmYWxzZTtcblxuICAgICAgaWYgKCFpbmNsdWRlc1NvbWVMYW5lKHJlbmRlckxhbmVzLCB1cGRhdGVMYW5lcykpIHtcbiAgICAgICAgLy8gVGhlIHBlbmRpbmcgbGFuZXMgd2VyZSBjbGVhcmVkIGF0IHRoZSBiZWdpbm5pbmcgb2YgYmVnaW5Xb3JrLiBXZSdyZVxuICAgICAgICAvLyBhYm91dCB0byBiYWlsIG91dCwgYnV0IHRoZXJlIG1pZ2h0IGJlIG90aGVyIGxhbmVzIHRoYXQgd2VyZW4ndFxuICAgICAgICAvLyBpbmNsdWRlZCBpbiB0aGUgY3VycmVudCByZW5kZXIuIFVzdWFsbHksIHRoZSBwcmlvcml0eSBsZXZlbCBvZiB0aGVcbiAgICAgICAgLy8gcmVtYWluaW5nIHVwZGF0ZXMgaXMgYWNjdW1sYXRlZCBkdXJpbmcgdGhlIGV2YWx1YXRpb24gb2YgdGhlXG4gICAgICAgIC8vIGNvbXBvbmVudCAoaS5lLiB3aGVuIHByb2Nlc3NpbmcgdGhlIHVwZGF0ZSBxdWV1ZSkuIEJ1dCBzaW5jZSBzaW5jZVxuICAgICAgICAvLyB3ZSdyZSBiYWlsaW5nIG91dCBlYXJseSAqd2l0aG91dCogZXZhbHVhdGluZyB0aGUgY29tcG9uZW50LCB3ZSBuZWVkXG4gICAgICAgIC8vIHRvIGFjY291bnQgZm9yIGl0IGhlcmUsIHRvby4gUmVzZXQgdG8gdGhlIHZhbHVlIG9mIHRoZSBjdXJyZW50IGZpYmVyLlxuICAgICAgICAvLyBOT1RFOiBUaGlzIG9ubHkgYXBwbGllcyB0byBTaW1wbGVNZW1vQ29tcG9uZW50LCBub3QgTWVtb0NvbXBvbmVudCxcbiAgICAgICAgLy8gYmVjYXVzZSBhIE1lbW9Db21wb25lbnQgZmliZXIgZG9lcyBub3QgaGF2ZSBob29rcyBvciBhbiB1cGRhdGUgcXVldWU7XG4gICAgICAgIC8vIHJhdGhlciwgaXQgd3JhcHMgYXJvdW5kIGFuIGlubmVyIGNvbXBvbmVudCwgd2hpY2ggbWF5IG9yIG1heSBub3RcbiAgICAgICAgLy8gY29udGFpbnMgaG9va3MuXG4gICAgICAgIC8vIFRPRE86IE1vdmUgdGhlIHJlc2V0IGF0IGluIGJlZ2luV29yayBvdXQgb2YgdGhlIGNvbW1vbiBwYXRoIHNvIHRoYXRcbiAgICAgICAgLy8gdGhpcyBpcyBubyBsb25nZXIgbmVjZXNzYXJ5LlxuICAgICAgICB3b3JrSW5Qcm9ncmVzcy5sYW5lcyA9IGN1cnJlbnQubGFuZXM7XG4gICAgICAgIHJldHVybiBiYWlsb3V0T25BbHJlYWR5RmluaXNoZWRXb3JrKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcyk7XG4gICAgICB9IGVsc2UgaWYgKChjdXJyZW50LmZsYWdzICYgRm9yY2VVcGRhdGVGb3JMZWdhY3lTdXNwZW5zZSkgIT09IE5vRmxhZ3MpIHtcbiAgICAgICAgLy8gVGhpcyBpcyBhIHNwZWNpYWwgY2FzZSB0aGF0IG9ubHkgZXhpc3RzIGZvciBsZWdhY3kgbW9kZS5cbiAgICAgICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9wdWxsLzE5MjE2LlxuICAgICAgICBkaWRSZWNlaXZlVXBkYXRlID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdXBkYXRlRnVuY3Rpb25Db21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIENvbXBvbmVudCwgbmV4dFByb3BzLCByZW5kZXJMYW5lcyk7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZU9mZnNjcmVlbkNvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpIHtcbiAgdmFyIG5leHRQcm9wcyA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcztcbiAgdmFyIG5leHRDaGlsZHJlbiA9IG5leHRQcm9wcy5jaGlsZHJlbjtcbiAgdmFyIHByZXZTdGF0ZSA9IGN1cnJlbnQgIT09IG51bGwgPyBjdXJyZW50Lm1lbW9pemVkU3RhdGUgOiBudWxsO1xuXG4gIGlmIChuZXh0UHJvcHMubW9kZSA9PT0gJ2hpZGRlbicgfHwgbmV4dFByb3BzLm1vZGUgPT09ICd1bnN0YWJsZS1kZWZlci13aXRob3V0LWhpZGluZycpIHtcbiAgICBpZiAoKHdvcmtJblByb2dyZXNzLm1vZGUgJiBDb25jdXJyZW50TW9kZSkgPT09IE5vTW9kZSkge1xuICAgICAgLy8gSW4gbGVnYWN5IHN5bmMgbW9kZSwgZG9uJ3QgZGVmZXIgdGhlIHN1YnRyZWUuIFJlbmRlciBpdCBub3cuXG4gICAgICAvLyBUT0RPOiBGaWd1cmUgb3V0IHdoYXQgd2Ugc2hvdWxkIGRvIGluIEJsb2NraW5nIG1vZGUuXG4gICAgICB2YXIgbmV4dFN0YXRlID0ge1xuICAgICAgICBiYXNlTGFuZXM6IE5vTGFuZXNcbiAgICAgIH07XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0gbmV4dFN0YXRlO1xuICAgICAgcHVzaFJlbmRlckxhbmVzKHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcyk7XG4gICAgfSBlbHNlIGlmICghaW5jbHVkZXNTb21lTGFuZShyZW5kZXJMYW5lcywgT2Zmc2NyZWVuTGFuZSkpIHtcbiAgICAgIHZhciBuZXh0QmFzZUxhbmVzO1xuXG4gICAgICBpZiAocHJldlN0YXRlICE9PSBudWxsKSB7XG4gICAgICAgIHZhciBwcmV2QmFzZUxhbmVzID0gcHJldlN0YXRlLmJhc2VMYW5lcztcbiAgICAgICAgbmV4dEJhc2VMYW5lcyA9IG1lcmdlTGFuZXMocHJldkJhc2VMYW5lcywgcmVuZGVyTGFuZXMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmV4dEJhc2VMYW5lcyA9IHJlbmRlckxhbmVzO1xuICAgICAgfSAvLyBTY2hlZHVsZSB0aGlzIGZpYmVyIHRvIHJlLXJlbmRlciBhdCBvZmZzY3JlZW4gcHJpb3JpdHkuIFRoZW4gYmFpbG91dC5cblxuXG4gICAgICB7XG4gICAgICAgIG1hcmtTcGF3bmVkV29yayhPZmZzY3JlZW5MYW5lKTtcbiAgICAgIH1cblxuICAgICAgd29ya0luUHJvZ3Jlc3MubGFuZXMgPSB3b3JrSW5Qcm9ncmVzcy5jaGlsZExhbmVzID0gbGFuZVRvTGFuZXMoT2Zmc2NyZWVuTGFuZSk7XG4gICAgICB2YXIgX25leHRTdGF0ZSA9IHtcbiAgICAgICAgYmFzZUxhbmVzOiBuZXh0QmFzZUxhbmVzXG4gICAgICB9O1xuICAgICAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IF9uZXh0U3RhdGU7IC8vIFdlJ3JlIGFib3V0IHRvIGJhaWwgb3V0LCBidXQgd2UgbmVlZCB0byBwdXNoIHRoaXMgdG8gdGhlIHN0YWNrIGFueXdheVxuICAgICAgLy8gdG8gYXZvaWQgYSBwdXNoL3BvcCBtaXNhbGlnbm1lbnQuXG5cbiAgICAgIHB1c2hSZW5kZXJMYW5lcyh3b3JrSW5Qcm9ncmVzcywgbmV4dEJhc2VMYW5lcyk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gUmVuZGVyaW5nIGF0IG9mZnNjcmVlbiwgc28gd2UgY2FuIGNsZWFyIHRoZSBiYXNlIGxhbmVzLlxuICAgICAgdmFyIF9uZXh0U3RhdGUyID0ge1xuICAgICAgICBiYXNlTGFuZXM6IE5vTGFuZXNcbiAgICAgIH07XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0gX25leHRTdGF0ZTI7IC8vIFB1c2ggdGhlIGxhbmVzIHRoYXQgd2VyZSBza2lwcGVkIHdoZW4gd2UgYmFpbGVkIG91dC5cblxuICAgICAgdmFyIHN1YnRyZWVSZW5kZXJMYW5lcyA9IHByZXZTdGF0ZSAhPT0gbnVsbCA/IHByZXZTdGF0ZS5iYXNlTGFuZXMgOiByZW5kZXJMYW5lcztcbiAgICAgIHB1c2hSZW5kZXJMYW5lcyh3b3JrSW5Qcm9ncmVzcywgc3VidHJlZVJlbmRlckxhbmVzKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIF9zdWJ0cmVlUmVuZGVyTGFuZXM7XG5cbiAgICBpZiAocHJldlN0YXRlICE9PSBudWxsKSB7XG4gICAgICBfc3VidHJlZVJlbmRlckxhbmVzID0gbWVyZ2VMYW5lcyhwcmV2U3RhdGUuYmFzZUxhbmVzLCByZW5kZXJMYW5lcyk7IC8vIFNpbmNlIHdlJ3JlIG5vdCBoaWRkZW4gYW55bW9yZSwgcmVzZXQgdGhlIHN0YXRlXG5cbiAgICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBXZSB3ZXJlbid0IHByZXZpb3VzbHkgaGlkZGVuLCBhbmQgd2Ugc3RpbGwgYXJlbid0LCBzbyB0aGVyZSdzIG5vdGhpbmdcbiAgICAgIC8vIHNwZWNpYWwgdG8gZG8uIE5lZWQgdG8gcHVzaCB0byB0aGUgc3RhY2sgcmVnYXJkbGVzcywgdGhvdWdoLCB0byBhdm9pZFxuICAgICAgLy8gYSBwdXNoL3BvcCBtaXNhbGlnbm1lbnQuXG4gICAgICBfc3VidHJlZVJlbmRlckxhbmVzID0gcmVuZGVyTGFuZXM7XG4gICAgfVxuXG4gICAgcHVzaFJlbmRlckxhbmVzKHdvcmtJblByb2dyZXNzLCBfc3VidHJlZVJlbmRlckxhbmVzKTtcbiAgfVxuXG4gIHJlY29uY2lsZUNoaWxkcmVuKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBuZXh0Q2hpbGRyZW4sIHJlbmRlckxhbmVzKTtcbiAgcmV0dXJuIHdvcmtJblByb2dyZXNzLmNoaWxkO1xufSAvLyBOb3RlOiBUaGVzZSBoYXBwZW4gdG8gaGF2ZSBpZGVudGljYWwgYmVnaW4gcGhhc2VzLCBmb3Igbm93LiBXZSBzaG91bGRuJ3QgaG9sZFxuLy8gb3Vyc2VsdmVzIHRvIHRoaXMgY29uc3RyYWludCwgdGhvdWdoLiBJZiB0aGUgYmVoYXZpb3IgZGl2ZXJnZXMsIHdlIHNob3VsZFxuLy8gZm9yayB0aGUgZnVuY3Rpb24uXG5cblxudmFyIHVwZGF0ZUxlZ2FjeUhpZGRlbkNvbXBvbmVudCA9IHVwZGF0ZU9mZnNjcmVlbkNvbXBvbmVudDtcblxuZnVuY3Rpb24gdXBkYXRlRnJhZ21lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKSB7XG4gIHZhciBuZXh0Q2hpbGRyZW4gPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7XG4gIHJlY29uY2lsZUNoaWxkcmVuKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBuZXh0Q2hpbGRyZW4sIHJlbmRlckxhbmVzKTtcbiAgcmV0dXJuIHdvcmtJblByb2dyZXNzLmNoaWxkO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVNb2RlKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcykge1xuICB2YXIgbmV4dENoaWxkcmVuID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzLmNoaWxkcmVuO1xuICByZWNvbmNpbGVDaGlsZHJlbihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbmV4dENoaWxkcmVuLCByZW5kZXJMYW5lcyk7XG4gIHJldHVybiB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbn1cblxuZnVuY3Rpb24gdXBkYXRlUHJvZmlsZXIoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKSB7XG4gIHtcbiAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBVcGRhdGU7IC8vIFJlc2V0IGVmZmVjdCBkdXJhdGlvbnMgZm9yIHRoZSBuZXh0IGV2ZW50dWFsIGVmZmVjdCBwaGFzZS5cbiAgICAvLyBUaGVzZSBhcmUgcmVzZXQgZHVyaW5nIHJlbmRlciB0byBhbGxvdyB0aGUgRGV2VG9vbHMgY29tbWl0IGhvb2sgYSBjaGFuY2UgdG8gcmVhZCB0aGVtLFxuXG4gICAgdmFyIHN0YXRlTm9kZSA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcbiAgICBzdGF0ZU5vZGUuZWZmZWN0RHVyYXRpb24gPSAwO1xuICAgIHN0YXRlTm9kZS5wYXNzaXZlRWZmZWN0RHVyYXRpb24gPSAwO1xuICB9XG5cbiAgdmFyIG5leHRQcm9wcyA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcztcbiAgdmFyIG5leHRDaGlsZHJlbiA9IG5leHRQcm9wcy5jaGlsZHJlbjtcbiAgcmVjb25jaWxlQ2hpbGRyZW4oY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG5leHRDaGlsZHJlbiwgcmVuZGVyTGFuZXMpO1xuICByZXR1cm4gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG59XG5cbmZ1bmN0aW9uIG1hcmtSZWYoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpIHtcbiAgdmFyIHJlZiA9IHdvcmtJblByb2dyZXNzLnJlZjtcblxuICBpZiAoY3VycmVudCA9PT0gbnVsbCAmJiByZWYgIT09IG51bGwgfHwgY3VycmVudCAhPT0gbnVsbCAmJiBjdXJyZW50LnJlZiAhPT0gcmVmKSB7XG4gICAgLy8gU2NoZWR1bGUgYSBSZWYgZWZmZWN0XG4gICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gUmVmO1xuICB9XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUZ1bmN0aW9uQ29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQsIG5leHRQcm9wcywgcmVuZGVyTGFuZXMpIHtcbiAge1xuICAgIGlmICh3b3JrSW5Qcm9ncmVzcy50eXBlICE9PSB3b3JrSW5Qcm9ncmVzcy5lbGVtZW50VHlwZSkge1xuICAgICAgLy8gTGF6eSBjb21wb25lbnQgcHJvcHMgY2FuJ3QgYmUgdmFsaWRhdGVkIGluIGNyZWF0ZUVsZW1lbnRcbiAgICAgIC8vIGJlY2F1c2UgdGhleSdyZSBvbmx5IGd1YXJhbnRlZWQgdG8gYmUgcmVzb2x2ZWQgaGVyZS5cbiAgICAgIHZhciBpbm5lclByb3BUeXBlcyA9IENvbXBvbmVudC5wcm9wVHlwZXM7XG5cbiAgICAgIGlmIChpbm5lclByb3BUeXBlcykge1xuICAgICAgICBjaGVja1Byb3BUeXBlcyhpbm5lclByb3BUeXBlcywgbmV4dFByb3BzLCAvLyBSZXNvbHZlZCBwcm9wc1xuICAgICAgICAncHJvcCcsIGdldENvbXBvbmVudE5hbWUoQ29tcG9uZW50KSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIGNvbnRleHQ7XG5cbiAge1xuICAgIHZhciB1bm1hc2tlZENvbnRleHQgPSBnZXRVbm1hc2tlZENvbnRleHQod29ya0luUHJvZ3Jlc3MsIENvbXBvbmVudCwgdHJ1ZSk7XG4gICAgY29udGV4dCA9IGdldE1hc2tlZENvbnRleHQod29ya0luUHJvZ3Jlc3MsIHVubWFza2VkQ29udGV4dCk7XG4gIH1cblxuICB2YXIgbmV4dENoaWxkcmVuO1xuICBwcmVwYXJlVG9SZWFkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpO1xuXG4gIHtcbiAgICBSZWFjdEN1cnJlbnRPd25lciQxLmN1cnJlbnQgPSB3b3JrSW5Qcm9ncmVzcztcbiAgICBzZXRJc1JlbmRlcmluZyh0cnVlKTtcbiAgICBuZXh0Q2hpbGRyZW4gPSByZW5kZXJXaXRoSG9va3MoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIENvbXBvbmVudCwgbmV4dFByb3BzLCBjb250ZXh0LCByZW5kZXJMYW5lcyk7XG5cbiAgICBpZiAoIHdvcmtJblByb2dyZXNzLm1vZGUgJiBTdHJpY3RNb2RlKSB7XG4gICAgICBkaXNhYmxlTG9ncygpO1xuXG4gICAgICB0cnkge1xuICAgICAgICBuZXh0Q2hpbGRyZW4gPSByZW5kZXJXaXRoSG9va3MoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIENvbXBvbmVudCwgbmV4dFByb3BzLCBjb250ZXh0LCByZW5kZXJMYW5lcyk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICByZWVuYWJsZUxvZ3MoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzZXRJc1JlbmRlcmluZyhmYWxzZSk7XG4gIH1cblxuICBpZiAoY3VycmVudCAhPT0gbnVsbCAmJiAhZGlkUmVjZWl2ZVVwZGF0ZSkge1xuICAgIGJhaWxvdXRIb29rcyhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpO1xuICAgIHJldHVybiBiYWlsb3V0T25BbHJlYWR5RmluaXNoZWRXb3JrKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcyk7XG4gIH0gLy8gUmVhY3QgRGV2VG9vbHMgcmVhZHMgdGhpcyBmbGFnLlxuXG5cbiAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gUGVyZm9ybWVkV29yaztcbiAgcmVjb25jaWxlQ2hpbGRyZW4oY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG5leHRDaGlsZHJlbiwgcmVuZGVyTGFuZXMpO1xuICByZXR1cm4gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUNsYXNzQ29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQsIG5leHRQcm9wcywgcmVuZGVyTGFuZXMpIHtcbiAge1xuICAgIGlmICh3b3JrSW5Qcm9ncmVzcy50eXBlICE9PSB3b3JrSW5Qcm9ncmVzcy5lbGVtZW50VHlwZSkge1xuICAgICAgLy8gTGF6eSBjb21wb25lbnQgcHJvcHMgY2FuJ3QgYmUgdmFsaWRhdGVkIGluIGNyZWF0ZUVsZW1lbnRcbiAgICAgIC8vIGJlY2F1c2UgdGhleSdyZSBvbmx5IGd1YXJhbnRlZWQgdG8gYmUgcmVzb2x2ZWQgaGVyZS5cbiAgICAgIHZhciBpbm5lclByb3BUeXBlcyA9IENvbXBvbmVudC5wcm9wVHlwZXM7XG5cbiAgICAgIGlmIChpbm5lclByb3BUeXBlcykge1xuICAgICAgICBjaGVja1Byb3BUeXBlcyhpbm5lclByb3BUeXBlcywgbmV4dFByb3BzLCAvLyBSZXNvbHZlZCBwcm9wc1xuICAgICAgICAncHJvcCcsIGdldENvbXBvbmVudE5hbWUoQ29tcG9uZW50KSk7XG4gICAgICB9XG4gICAgfVxuICB9IC8vIFB1c2ggY29udGV4dCBwcm92aWRlcnMgZWFybHkgdG8gcHJldmVudCBjb250ZXh0IHN0YWNrIG1pc21hdGNoZXMuXG4gIC8vIER1cmluZyBtb3VudGluZyB3ZSBkb24ndCBrbm93IHRoZSBjaGlsZCBjb250ZXh0IHlldCBhcyB0aGUgaW5zdGFuY2UgZG9lc24ndCBleGlzdC5cbiAgLy8gV2Ugd2lsbCBpbnZhbGlkYXRlIHRoZSBjaGlsZCBjb250ZXh0IGluIGZpbmlzaENsYXNzQ29tcG9uZW50KCkgcmlnaHQgYWZ0ZXIgcmVuZGVyaW5nLlxuXG5cbiAgdmFyIGhhc0NvbnRleHQ7XG5cbiAgaWYgKGlzQ29udGV4dFByb3ZpZGVyKENvbXBvbmVudCkpIHtcbiAgICBoYXNDb250ZXh0ID0gdHJ1ZTtcbiAgICBwdXNoQ29udGV4dFByb3ZpZGVyKHdvcmtJblByb2dyZXNzKTtcbiAgfSBlbHNlIHtcbiAgICBoYXNDb250ZXh0ID0gZmFsc2U7XG4gIH1cblxuICBwcmVwYXJlVG9SZWFkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpO1xuICB2YXIgaW5zdGFuY2UgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG4gIHZhciBzaG91bGRVcGRhdGU7XG5cbiAgaWYgKGluc3RhbmNlID09PSBudWxsKSB7XG4gICAgaWYgKGN1cnJlbnQgIT09IG51bGwpIHtcbiAgICAgIC8vIEEgY2xhc3MgY29tcG9uZW50IHdpdGhvdXQgYW4gaW5zdGFuY2Ugb25seSBtb3VudHMgaWYgaXQgc3VzcGVuZGVkXG4gICAgICAvLyBpbnNpZGUgYSBub24tY29uY3VycmVudCB0cmVlLCBpbiBhbiBpbmNvbnNpc3RlbnQgc3RhdGUuIFdlIHdhbnQgdG9cbiAgICAgIC8vIHRyZWF0IGl0IGxpa2UgYSBuZXcgbW91bnQsIGV2ZW4gdGhvdWdoIGFuIGVtcHR5IHZlcnNpb24gb2YgaXQgYWxyZWFkeVxuICAgICAgLy8gY29tbWl0dGVkLiBEaXNjb25uZWN0IHRoZSBhbHRlcm5hdGUgcG9pbnRlcnMuXG4gICAgICBjdXJyZW50LmFsdGVybmF0ZSA9IG51bGw7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5hbHRlcm5hdGUgPSBudWxsOyAvLyBTaW5jZSB0aGlzIGlzIGNvbmNlcHR1YWxseSBhIG5ldyBmaWJlciwgc2NoZWR1bGUgYSBQbGFjZW1lbnQgZWZmZWN0XG5cbiAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IFBsYWNlbWVudDtcbiAgICB9IC8vIEluIHRoZSBpbml0aWFsIHBhc3Mgd2UgbWlnaHQgbmVlZCB0byBjb25zdHJ1Y3QgdGhlIGluc3RhbmNlLlxuXG5cbiAgICBjb25zdHJ1Y3RDbGFzc0luc3RhbmNlKHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQsIG5leHRQcm9wcyk7XG4gICAgbW91bnRDbGFzc0luc3RhbmNlKHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQsIG5leHRQcm9wcywgcmVuZGVyTGFuZXMpO1xuICAgIHNob3VsZFVwZGF0ZSA9IHRydWU7XG4gIH0gZWxzZSBpZiAoY3VycmVudCA9PT0gbnVsbCkge1xuICAgIC8vIEluIGEgcmVzdW1lLCB3ZSdsbCBhbHJlYWR5IGhhdmUgYW4gaW5zdGFuY2Ugd2UgY2FuIHJldXNlLlxuICAgIHNob3VsZFVwZGF0ZSA9IHJlc3VtZU1vdW50Q2xhc3NJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcywgQ29tcG9uZW50LCBuZXh0UHJvcHMsIHJlbmRlckxhbmVzKTtcbiAgfSBlbHNlIHtcbiAgICBzaG91bGRVcGRhdGUgPSB1cGRhdGVDbGFzc0luc3RhbmNlKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQsIG5leHRQcm9wcywgcmVuZGVyTGFuZXMpO1xuICB9XG5cbiAgdmFyIG5leHRVbml0T2ZXb3JrID0gZmluaXNoQ2xhc3NDb21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIENvbXBvbmVudCwgc2hvdWxkVXBkYXRlLCBoYXNDb250ZXh0LCByZW5kZXJMYW5lcyk7XG5cbiAge1xuICAgIHZhciBpbnN0ID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuXG4gICAgaWYgKHNob3VsZFVwZGF0ZSAmJiBpbnN0LnByb3BzICE9PSBuZXh0UHJvcHMpIHtcbiAgICAgIGlmICghZGlkV2FybkFib3V0UmVhc3NpZ25pbmdQcm9wcykge1xuICAgICAgICBlcnJvcignSXQgbG9va3MgbGlrZSAlcyBpcyByZWFzc2lnbmluZyBpdHMgb3duIGB0aGlzLnByb3BzYCB3aGlsZSByZW5kZXJpbmcuICcgKyAnVGhpcyBpcyBub3Qgc3VwcG9ydGVkIGFuZCBjYW4gbGVhZCB0byBjb25mdXNpbmcgYnVncy4nLCBnZXRDb21wb25lbnROYW1lKHdvcmtJblByb2dyZXNzLnR5cGUpIHx8ICdhIGNvbXBvbmVudCcpO1xuICAgICAgfVxuXG4gICAgICBkaWRXYXJuQWJvdXRSZWFzc2lnbmluZ1Byb3BzID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmV4dFVuaXRPZldvcms7XG59XG5cbmZ1bmN0aW9uIGZpbmlzaENsYXNzQ29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQsIHNob3VsZFVwZGF0ZSwgaGFzQ29udGV4dCwgcmVuZGVyTGFuZXMpIHtcbiAgLy8gUmVmcyBzaG91bGQgdXBkYXRlIGV2ZW4gaWYgc2hvdWxkQ29tcG9uZW50VXBkYXRlIHJldHVybnMgZmFsc2VcbiAgbWFya1JlZihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcyk7XG4gIHZhciBkaWRDYXB0dXJlRXJyb3IgPSAod29ya0luUHJvZ3Jlc3MuZmxhZ3MgJiBEaWRDYXB0dXJlKSAhPT0gTm9GbGFncztcblxuICBpZiAoIXNob3VsZFVwZGF0ZSAmJiAhZGlkQ2FwdHVyZUVycm9yKSB7XG4gICAgLy8gQ29udGV4dCBwcm92aWRlcnMgc2hvdWxkIGRlZmVyIHRvIHNDVSBmb3IgcmVuZGVyaW5nXG4gICAgaWYgKGhhc0NvbnRleHQpIHtcbiAgICAgIGludmFsaWRhdGVDb250ZXh0UHJvdmlkZXIod29ya0luUHJvZ3Jlc3MsIENvbXBvbmVudCwgZmFsc2UpO1xuICAgIH1cblxuICAgIHJldHVybiBiYWlsb3V0T25BbHJlYWR5RmluaXNoZWRXb3JrKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcyk7XG4gIH1cblxuICB2YXIgaW5zdGFuY2UgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7IC8vIFJlcmVuZGVyXG5cbiAgUmVhY3RDdXJyZW50T3duZXIkMS5jdXJyZW50ID0gd29ya0luUHJvZ3Jlc3M7XG4gIHZhciBuZXh0Q2hpbGRyZW47XG5cbiAgaWYgKGRpZENhcHR1cmVFcnJvciAmJiB0eXBlb2YgQ29tcG9uZW50LmdldERlcml2ZWRTdGF0ZUZyb21FcnJvciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIC8vIElmIHdlIGNhcHR1cmVkIGFuIGVycm9yLCBidXQgZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yIGlzIG5vdCBkZWZpbmVkLFxuICAgIC8vIHVubW91bnQgYWxsIHRoZSBjaGlsZHJlbi4gY29tcG9uZW50RGlkQ2F0Y2ggd2lsbCBzY2hlZHVsZSBhbiB1cGRhdGUgdG9cbiAgICAvLyByZS1yZW5kZXIgYSBmYWxsYmFjay4gVGhpcyBpcyB0ZW1wb3JhcnkgdW50aWwgd2UgbWlncmF0ZSBldmVyeW9uZSB0b1xuICAgIC8vIHRoZSBuZXcgQVBJLlxuICAgIC8vIFRPRE86IFdhcm4gaW4gYSBmdXR1cmUgcmVsZWFzZS5cbiAgICBuZXh0Q2hpbGRyZW4gPSBudWxsO1xuXG4gICAge1xuICAgICAgc3RvcFByb2ZpbGVyVGltZXJJZlJ1bm5pbmcoKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAge1xuICAgICAgc2V0SXNSZW5kZXJpbmcodHJ1ZSk7XG4gICAgICBuZXh0Q2hpbGRyZW4gPSBpbnN0YW5jZS5yZW5kZXIoKTtcblxuICAgICAgaWYgKCB3b3JrSW5Qcm9ncmVzcy5tb2RlICYgU3RyaWN0TW9kZSkge1xuICAgICAgICBkaXNhYmxlTG9ncygpO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaW5zdGFuY2UucmVuZGVyKCk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgcmVlbmFibGVMb2dzKCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgc2V0SXNSZW5kZXJpbmcoZmFsc2UpO1xuICAgIH1cbiAgfSAvLyBSZWFjdCBEZXZUb29scyByZWFkcyB0aGlzIGZsYWcuXG5cblxuICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBQZXJmb3JtZWRXb3JrO1xuXG4gIGlmIChjdXJyZW50ICE9PSBudWxsICYmIGRpZENhcHR1cmVFcnJvcikge1xuICAgIC8vIElmIHdlJ3JlIHJlY292ZXJpbmcgZnJvbSBhbiBlcnJvciwgcmVjb25jaWxlIHdpdGhvdXQgcmV1c2luZyBhbnkgb2ZcbiAgICAvLyB0aGUgZXhpc3RpbmcgY2hpbGRyZW4uIENvbmNlcHR1YWxseSwgdGhlIG5vcm1hbCBjaGlsZHJlbiBhbmQgdGhlIGNoaWxkcmVuXG4gICAgLy8gdGhhdCBhcmUgc2hvd24gb24gZXJyb3IgYXJlIHR3byBkaWZmZXJlbnQgc2V0cywgc28gd2Ugc2hvdWxkbid0IHJldXNlXG4gICAgLy8gbm9ybWFsIGNoaWxkcmVuIGV2ZW4gaWYgdGhlaXIgaWRlbnRpdGllcyBtYXRjaC5cbiAgICBmb3JjZVVubW91bnRDdXJyZW50QW5kUmVjb25jaWxlKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBuZXh0Q2hpbGRyZW4sIHJlbmRlckxhbmVzKTtcbiAgfSBlbHNlIHtcbiAgICByZWNvbmNpbGVDaGlsZHJlbihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbmV4dENoaWxkcmVuLCByZW5kZXJMYW5lcyk7XG4gIH0gLy8gTWVtb2l6ZSBzdGF0ZSB1c2luZyB0aGUgdmFsdWVzIHdlIGp1c3QgdXNlZCB0byByZW5kZXIuXG4gIC8vIFRPRE86IFJlc3RydWN0dXJlIHNvIHdlIG5ldmVyIHJlYWQgdmFsdWVzIGZyb20gdGhlIGluc3RhbmNlLlxuXG5cbiAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IGluc3RhbmNlLnN0YXRlOyAvLyBUaGUgY29udGV4dCBtaWdodCBoYXZlIGNoYW5nZWQgc28gd2UgbmVlZCB0byByZWNhbGN1bGF0ZSBpdC5cblxuICBpZiAoaGFzQ29udGV4dCkge1xuICAgIGludmFsaWRhdGVDb250ZXh0UHJvdmlkZXIod29ya0luUHJvZ3Jlc3MsIENvbXBvbmVudCwgdHJ1ZSk7XG4gIH1cblxuICByZXR1cm4gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG59XG5cbmZ1bmN0aW9uIHB1c2hIb3N0Um9vdENvbnRleHQod29ya0luUHJvZ3Jlc3MpIHtcbiAgdmFyIHJvb3QgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG5cbiAgaWYgKHJvb3QucGVuZGluZ0NvbnRleHQpIHtcbiAgICBwdXNoVG9wTGV2ZWxDb250ZXh0T2JqZWN0KHdvcmtJblByb2dyZXNzLCByb290LnBlbmRpbmdDb250ZXh0LCByb290LnBlbmRpbmdDb250ZXh0ICE9PSByb290LmNvbnRleHQpO1xuICB9IGVsc2UgaWYgKHJvb3QuY29udGV4dCkge1xuICAgIC8vIFNob3VsZCBhbHdheXMgYmUgc2V0XG4gICAgcHVzaFRvcExldmVsQ29udGV4dE9iamVjdCh3b3JrSW5Qcm9ncmVzcywgcm9vdC5jb250ZXh0LCBmYWxzZSk7XG4gIH1cblxuICBwdXNoSG9zdENvbnRhaW5lcih3b3JrSW5Qcm9ncmVzcywgcm9vdC5jb250YWluZXJJbmZvKTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlSG9zdFJvb3QoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKSB7XG4gIHB1c2hIb3N0Um9vdENvbnRleHQod29ya0luUHJvZ3Jlc3MpO1xuICB2YXIgdXBkYXRlUXVldWUgPSB3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZTtcblxuICBpZiAoIShjdXJyZW50ICE9PSBudWxsICYmIHVwZGF0ZVF1ZXVlICE9PSBudWxsKSkge1xuICAgIHtcbiAgICAgIHRocm93IEVycm9yKCBcIklmIHRoZSByb290IGRvZXMgbm90IGhhdmUgYW4gdXBkYXRlUXVldWUsIHdlIHNob3VsZCBoYXZlIGFscmVhZHkgYmFpbGVkIG91dC4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS5cIiApO1xuICAgIH1cbiAgfVxuXG4gIHZhciBuZXh0UHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7XG4gIHZhciBwcmV2U3RhdGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuICB2YXIgcHJldkNoaWxkcmVuID0gcHJldlN0YXRlICE9PSBudWxsID8gcHJldlN0YXRlLmVsZW1lbnQgOiBudWxsO1xuICBjbG9uZVVwZGF0ZVF1ZXVlKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKTtcbiAgcHJvY2Vzc1VwZGF0ZVF1ZXVlKHdvcmtJblByb2dyZXNzLCBuZXh0UHJvcHMsIG51bGwsIHJlbmRlckxhbmVzKTtcbiAgdmFyIG5leHRTdGF0ZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7IC8vIENhdXRpb246IFJlYWN0IERldlRvb2xzIGN1cnJlbnRseSBkZXBlbmRzIG9uIHRoaXMgcHJvcGVydHlcbiAgLy8gYmVpbmcgY2FsbGVkIFwiZWxlbWVudFwiLlxuXG4gIHZhciBuZXh0Q2hpbGRyZW4gPSBuZXh0U3RhdGUuZWxlbWVudDtcblxuICBpZiAobmV4dENoaWxkcmVuID09PSBwcmV2Q2hpbGRyZW4pIHtcbiAgICByZXNldEh5ZHJhdGlvblN0YXRlKCk7XG4gICAgcmV0dXJuIGJhaWxvdXRPbkFscmVhZHlGaW5pc2hlZFdvcmsoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKTtcbiAgfVxuXG4gIHZhciByb290ID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuXG4gIGlmIChyb290Lmh5ZHJhdGUgJiYgZW50ZXJIeWRyYXRpb25TdGF0ZSh3b3JrSW5Qcm9ncmVzcykpIHtcbiAgICAvLyBJZiB3ZSBkb24ndCBoYXZlIGFueSBjdXJyZW50IGNoaWxkcmVuIHRoaXMgbWlnaHQgYmUgdGhlIGZpcnN0IHBhc3MuXG4gICAgLy8gV2UgYWx3YXlzIHRyeSB0byBoeWRyYXRlLiBJZiB0aGlzIGlzbid0IGEgaHlkcmF0aW9uIHBhc3MgdGhlcmUgd29uJ3RcbiAgICAvLyBiZSBhbnkgY2hpbGRyZW4gdG8gaHlkcmF0ZSB3aGljaCBpcyBlZmZlY3RpdmVseSB0aGUgc2FtZSB0aGluZyBhc1xuICAgIC8vIG5vdCBoeWRyYXRpbmcuXG4gICAge1xuICAgICAgdmFyIG11dGFibGVTb3VyY2VFYWdlckh5ZHJhdGlvbkRhdGEgPSByb290Lm11dGFibGVTb3VyY2VFYWdlckh5ZHJhdGlvbkRhdGE7XG5cbiAgICAgIGlmIChtdXRhYmxlU291cmNlRWFnZXJIeWRyYXRpb25EYXRhICE9IG51bGwpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtdXRhYmxlU291cmNlRWFnZXJIeWRyYXRpb25EYXRhLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgICAgdmFyIG11dGFibGVTb3VyY2UgPSBtdXRhYmxlU291cmNlRWFnZXJIeWRyYXRpb25EYXRhW2ldO1xuICAgICAgICAgIHZhciB2ZXJzaW9uID0gbXV0YWJsZVNvdXJjZUVhZ2VySHlkcmF0aW9uRGF0YVtpICsgMV07XG4gICAgICAgICAgc2V0V29ya0luUHJvZ3Jlc3NWZXJzaW9uKG11dGFibGVTb3VyY2UsIHZlcnNpb24pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGNoaWxkID0gbW91bnRDaGlsZEZpYmVycyh3b3JrSW5Qcm9ncmVzcywgbnVsbCwgbmV4dENoaWxkcmVuLCByZW5kZXJMYW5lcyk7XG4gICAgd29ya0luUHJvZ3Jlc3MuY2hpbGQgPSBjaGlsZDtcbiAgICB2YXIgbm9kZSA9IGNoaWxkO1xuXG4gICAgd2hpbGUgKG5vZGUpIHtcbiAgICAgIC8vIE1hcmsgZWFjaCBjaGlsZCBhcyBoeWRyYXRpbmcuIFRoaXMgaXMgYSBmYXN0IHBhdGggdG8ga25vdyB3aGV0aGVyIHRoaXNcbiAgICAgIC8vIHRyZWUgaXMgcGFydCBvZiBhIGh5ZHJhdGluZyB0cmVlLiBUaGlzIGlzIHVzZWQgdG8gZGV0ZXJtaW5lIGlmIGEgY2hpbGRcbiAgICAgIC8vIG5vZGUgaGFzIGZ1bGx5IG1vdW50ZWQgeWV0LCBhbmQgZm9yIHNjaGVkdWxpbmcgZXZlbnQgcmVwbGF5aW5nLlxuICAgICAgLy8gQ29uY2VwdHVhbGx5IHRoaXMgaXMgc2ltaWxhciB0byBQbGFjZW1lbnQgaW4gdGhhdCBhIG5ldyBzdWJ0cmVlIGlzXG4gICAgICAvLyBpbnNlcnRlZCBpbnRvIHRoZSBSZWFjdCB0cmVlIGhlcmUuIEl0IGp1c3QgaGFwcGVucyB0byBub3QgbmVlZCBET01cbiAgICAgIC8vIG11dGF0aW9ucyBiZWNhdXNlIGl0IGFscmVhZHkgZXhpc3RzLlxuICAgICAgbm9kZS5mbGFncyA9IG5vZGUuZmxhZ3MgJiB+UGxhY2VtZW50IHwgSHlkcmF0aW5nO1xuICAgICAgbm9kZSA9IG5vZGUuc2libGluZztcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gT3RoZXJ3aXNlIHJlc2V0IGh5ZHJhdGlvbiBzdGF0ZSBpbiBjYXNlIHdlIGFib3J0ZWQgYW5kIHJlc3VtZWQgYW5vdGhlclxuICAgIC8vIHJvb3QuXG4gICAgcmVjb25jaWxlQ2hpbGRyZW4oY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG5leHRDaGlsZHJlbiwgcmVuZGVyTGFuZXMpO1xuICAgIHJlc2V0SHlkcmF0aW9uU3RhdGUoKTtcbiAgfVxuXG4gIHJldHVybiB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbn1cblxuZnVuY3Rpb24gdXBkYXRlSG9zdENvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpIHtcbiAgcHVzaEhvc3RDb250ZXh0KHdvcmtJblByb2dyZXNzKTtcblxuICBpZiAoY3VycmVudCA9PT0gbnVsbCkge1xuICAgIHRyeVRvQ2xhaW1OZXh0SHlkcmF0YWJsZUluc3RhbmNlKHdvcmtJblByb2dyZXNzKTtcbiAgfVxuXG4gIHZhciB0eXBlID0gd29ya0luUHJvZ3Jlc3MudHlwZTtcbiAgdmFyIG5leHRQcm9wcyA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcztcbiAgdmFyIHByZXZQcm9wcyA9IGN1cnJlbnQgIT09IG51bGwgPyBjdXJyZW50Lm1lbW9pemVkUHJvcHMgOiBudWxsO1xuICB2YXIgbmV4dENoaWxkcmVuID0gbmV4dFByb3BzLmNoaWxkcmVuO1xuICB2YXIgaXNEaXJlY3RUZXh0Q2hpbGQgPSBzaG91bGRTZXRUZXh0Q29udGVudCh0eXBlLCBuZXh0UHJvcHMpO1xuXG4gIGlmIChpc0RpcmVjdFRleHRDaGlsZCkge1xuICAgIC8vIFdlIHNwZWNpYWwgY2FzZSBhIGRpcmVjdCB0ZXh0IGNoaWxkIG9mIGEgaG9zdCBub2RlLiBUaGlzIGlzIGEgY29tbW9uXG4gICAgLy8gY2FzZS4gV2Ugd29uJ3QgaGFuZGxlIGl0IGFzIGEgcmVpZmllZCBjaGlsZC4gV2Ugd2lsbCBpbnN0ZWFkIGhhbmRsZVxuICAgIC8vIHRoaXMgaW4gdGhlIGhvc3QgZW52aXJvbm1lbnQgdGhhdCBhbHNvIGhhcyBhY2Nlc3MgdG8gdGhpcyBwcm9wLiBUaGF0XG4gICAgLy8gYXZvaWRzIGFsbG9jYXRpbmcgYW5vdGhlciBIb3N0VGV4dCBmaWJlciBhbmQgdHJhdmVyc2luZyBpdC5cbiAgICBuZXh0Q2hpbGRyZW4gPSBudWxsO1xuICB9IGVsc2UgaWYgKHByZXZQcm9wcyAhPT0gbnVsbCAmJiBzaG91bGRTZXRUZXh0Q29udGVudCh0eXBlLCBwcmV2UHJvcHMpKSB7XG4gICAgLy8gSWYgd2UncmUgc3dpdGNoaW5nIGZyb20gYSBkaXJlY3QgdGV4dCBjaGlsZCB0byBhIG5vcm1hbCBjaGlsZCwgb3IgdG9cbiAgICAvLyBlbXB0eSwgd2UgbmVlZCB0byBzY2hlZHVsZSB0aGUgdGV4dCBjb250ZW50IHRvIGJlIHJlc2V0LlxuICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IENvbnRlbnRSZXNldDtcbiAgfVxuXG4gIG1hcmtSZWYoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpO1xuICByZWNvbmNpbGVDaGlsZHJlbihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbmV4dENoaWxkcmVuLCByZW5kZXJMYW5lcyk7XG4gIHJldHVybiB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbn1cblxuZnVuY3Rpb24gdXBkYXRlSG9zdFRleHQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpIHtcbiAgaWYgKGN1cnJlbnQgPT09IG51bGwpIHtcbiAgICB0cnlUb0NsYWltTmV4dEh5ZHJhdGFibGVJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcyk7XG4gIH0gLy8gTm90aGluZyB0byBkbyBoZXJlLiBUaGlzIGlzIHRlcm1pbmFsLiBXZSdsbCBkbyB0aGUgY29tcGxldGlvbiBzdGVwXG4gIC8vIGltbWVkaWF0ZWx5IGFmdGVyLlxuXG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIG1vdW50TGF6eUNvbXBvbmVudChfY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIGVsZW1lbnRUeXBlLCB1cGRhdGVMYW5lcywgcmVuZGVyTGFuZXMpIHtcbiAgaWYgKF9jdXJyZW50ICE9PSBudWxsKSB7XG4gICAgLy8gQSBsYXp5IGNvbXBvbmVudCBvbmx5IG1vdW50cyBpZiBpdCBzdXNwZW5kZWQgaW5zaWRlIGEgbm9uLVxuICAgIC8vIGNvbmN1cnJlbnQgdHJlZSwgaW4gYW4gaW5jb25zaXN0ZW50IHN0YXRlLiBXZSB3YW50IHRvIHRyZWF0IGl0IGxpa2VcbiAgICAvLyBhIG5ldyBtb3VudCwgZXZlbiB0aG91Z2ggYW4gZW1wdHkgdmVyc2lvbiBvZiBpdCBhbHJlYWR5IGNvbW1pdHRlZC5cbiAgICAvLyBEaXNjb25uZWN0IHRoZSBhbHRlcm5hdGUgcG9pbnRlcnMuXG4gICAgX2N1cnJlbnQuYWx0ZXJuYXRlID0gbnVsbDtcbiAgICB3b3JrSW5Qcm9ncmVzcy5hbHRlcm5hdGUgPSBudWxsOyAvLyBTaW5jZSB0aGlzIGlzIGNvbmNlcHR1YWxseSBhIG5ldyBmaWJlciwgc2NoZWR1bGUgYSBQbGFjZW1lbnQgZWZmZWN0XG5cbiAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBQbGFjZW1lbnQ7XG4gIH1cblxuICB2YXIgcHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7XG4gIHZhciBsYXp5Q29tcG9uZW50ID0gZWxlbWVudFR5cGU7XG4gIHZhciBwYXlsb2FkID0gbGF6eUNvbXBvbmVudC5fcGF5bG9hZDtcbiAgdmFyIGluaXQgPSBsYXp5Q29tcG9uZW50Ll9pbml0O1xuICB2YXIgQ29tcG9uZW50ID0gaW5pdChwYXlsb2FkKTsgLy8gU3RvcmUgdGhlIHVud3JhcHBlZCBjb21wb25lbnQgaW4gdGhlIHR5cGUuXG5cbiAgd29ya0luUHJvZ3Jlc3MudHlwZSA9IENvbXBvbmVudDtcbiAgdmFyIHJlc29sdmVkVGFnID0gd29ya0luUHJvZ3Jlc3MudGFnID0gcmVzb2x2ZUxhenlDb21wb25lbnRUYWcoQ29tcG9uZW50KTtcbiAgdmFyIHJlc29sdmVkUHJvcHMgPSByZXNvbHZlRGVmYXVsdFByb3BzKENvbXBvbmVudCwgcHJvcHMpO1xuICB2YXIgY2hpbGQ7XG5cbiAgc3dpdGNoIChyZXNvbHZlZFRhZykge1xuICAgIGNhc2UgRnVuY3Rpb25Db21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIHtcbiAgICAgICAgICB2YWxpZGF0ZUZ1bmN0aW9uQ29tcG9uZW50SW5EZXYod29ya0luUHJvZ3Jlc3MsIENvbXBvbmVudCk7XG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MudHlwZSA9IENvbXBvbmVudCA9IHJlc29sdmVGdW5jdGlvbkZvckhvdFJlbG9hZGluZyhDb21wb25lbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgY2hpbGQgPSB1cGRhdGVGdW5jdGlvbkNvbXBvbmVudChudWxsLCB3b3JrSW5Qcm9ncmVzcywgQ29tcG9uZW50LCByZXNvbHZlZFByb3BzLCByZW5kZXJMYW5lcyk7XG4gICAgICAgIHJldHVybiBjaGlsZDtcbiAgICAgIH1cblxuICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIHtcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy50eXBlID0gQ29tcG9uZW50ID0gcmVzb2x2ZUNsYXNzRm9ySG90UmVsb2FkaW5nKENvbXBvbmVudCk7XG4gICAgICAgIH1cblxuICAgICAgICBjaGlsZCA9IHVwZGF0ZUNsYXNzQ29tcG9uZW50KG51bGwsIHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQsIHJlc29sdmVkUHJvcHMsIHJlbmRlckxhbmVzKTtcbiAgICAgICAgcmV0dXJuIGNoaWxkO1xuICAgICAgfVxuXG4gICAgY2FzZSBGb3J3YXJkUmVmOlxuICAgICAge1xuICAgICAgICB7XG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MudHlwZSA9IENvbXBvbmVudCA9IHJlc29sdmVGb3J3YXJkUmVmRm9ySG90UmVsb2FkaW5nKENvbXBvbmVudCk7XG4gICAgICAgIH1cblxuICAgICAgICBjaGlsZCA9IHVwZGF0ZUZvcndhcmRSZWYobnVsbCwgd29ya0luUHJvZ3Jlc3MsIENvbXBvbmVudCwgcmVzb2x2ZWRQcm9wcywgcmVuZGVyTGFuZXMpO1xuICAgICAgICByZXR1cm4gY2hpbGQ7XG4gICAgICB9XG5cbiAgICBjYXNlIE1lbW9Db21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIHtcbiAgICAgICAgICBpZiAod29ya0luUHJvZ3Jlc3MudHlwZSAhPT0gd29ya0luUHJvZ3Jlc3MuZWxlbWVudFR5cGUpIHtcbiAgICAgICAgICAgIHZhciBvdXRlclByb3BUeXBlcyA9IENvbXBvbmVudC5wcm9wVHlwZXM7XG5cbiAgICAgICAgICAgIGlmIChvdXRlclByb3BUeXBlcykge1xuICAgICAgICAgICAgICBjaGVja1Byb3BUeXBlcyhvdXRlclByb3BUeXBlcywgcmVzb2x2ZWRQcm9wcywgLy8gUmVzb2x2ZWQgZm9yIG91dGVyIG9ubHlcbiAgICAgICAgICAgICAgJ3Byb3AnLCBnZXRDb21wb25lbnROYW1lKENvbXBvbmVudCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNoaWxkID0gdXBkYXRlTWVtb0NvbXBvbmVudChudWxsLCB3b3JrSW5Qcm9ncmVzcywgQ29tcG9uZW50LCByZXNvbHZlRGVmYXVsdFByb3BzKENvbXBvbmVudC50eXBlLCByZXNvbHZlZFByb3BzKSwgLy8gVGhlIGlubmVyIHR5cGUgY2FuIGhhdmUgZGVmYXVsdHMgdG9vXG4gICAgICAgIHVwZGF0ZUxhbmVzLCByZW5kZXJMYW5lcyk7XG4gICAgICAgIHJldHVybiBjaGlsZDtcbiAgICAgIH1cbiAgfVxuXG4gIHZhciBoaW50ID0gJyc7XG5cbiAge1xuICAgIGlmIChDb21wb25lbnQgIT09IG51bGwgJiYgdHlwZW9mIENvbXBvbmVudCA9PT0gJ29iamVjdCcgJiYgQ29tcG9uZW50LiQkdHlwZW9mID09PSBSRUFDVF9MQVpZX1RZUEUpIHtcbiAgICAgIGhpbnQgPSAnIERpZCB5b3Ugd3JhcCBhIGNvbXBvbmVudCBpbiBSZWFjdC5sYXp5KCkgbW9yZSB0aGFuIG9uY2U/JztcbiAgICB9XG4gIH0gLy8gVGhpcyBtZXNzYWdlIGludGVudGlvbmFsbHkgZG9lc24ndCBtZW50aW9uIEZvcndhcmRSZWYgb3IgTWVtb0NvbXBvbmVudFxuICAvLyBiZWNhdXNlIHRoZSBmYWN0IHRoYXQgaXQncyBhIHNlcGFyYXRlIHR5cGUgb2Ygd29yayBpcyBhblxuICAvLyBpbXBsZW1lbnRhdGlvbiBkZXRhaWwuXG5cblxuICB7XG4gICAge1xuICAgICAgdGhyb3cgRXJyb3IoIFwiRWxlbWVudCB0eXBlIGlzIGludmFsaWQuIFJlY2VpdmVkIGEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvOiBcIiArIENvbXBvbmVudCArIFwiLiBMYXp5IGVsZW1lbnQgdHlwZSBtdXN0IHJlc29sdmUgdG8gYSBjbGFzcyBvciBmdW5jdGlvbi5cIiArIGhpbnQgKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gbW91bnRJbmNvbXBsZXRlQ2xhc3NDb21wb25lbnQoX2N1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQsIG5leHRQcm9wcywgcmVuZGVyTGFuZXMpIHtcbiAgaWYgKF9jdXJyZW50ICE9PSBudWxsKSB7XG4gICAgLy8gQW4gaW5jb21wbGV0ZSBjb21wb25lbnQgb25seSBtb3VudHMgaWYgaXQgc3VzcGVuZGVkIGluc2lkZSBhIG5vbi1cbiAgICAvLyBjb25jdXJyZW50IHRyZWUsIGluIGFuIGluY29uc2lzdGVudCBzdGF0ZS4gV2Ugd2FudCB0byB0cmVhdCBpdCBsaWtlXG4gICAgLy8gYSBuZXcgbW91bnQsIGV2ZW4gdGhvdWdoIGFuIGVtcHR5IHZlcnNpb24gb2YgaXQgYWxyZWFkeSBjb21taXR0ZWQuXG4gICAgLy8gRGlzY29ubmVjdCB0aGUgYWx0ZXJuYXRlIHBvaW50ZXJzLlxuICAgIF9jdXJyZW50LmFsdGVybmF0ZSA9IG51bGw7XG4gICAgd29ya0luUHJvZ3Jlc3MuYWx0ZXJuYXRlID0gbnVsbDsgLy8gU2luY2UgdGhpcyBpcyBjb25jZXB0dWFsbHkgYSBuZXcgZmliZXIsIHNjaGVkdWxlIGEgUGxhY2VtZW50IGVmZmVjdFxuXG4gICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gUGxhY2VtZW50O1xuICB9IC8vIFByb21vdGUgdGhlIGZpYmVyIHRvIGEgY2xhc3MgYW5kIHRyeSByZW5kZXJpbmcgYWdhaW4uXG5cblxuICB3b3JrSW5Qcm9ncmVzcy50YWcgPSBDbGFzc0NvbXBvbmVudDsgLy8gVGhlIHJlc3Qgb2YgdGhpcyBmdW5jdGlvbiBpcyBhIGZvcmsgb2YgYHVwZGF0ZUNsYXNzQ29tcG9uZW50YFxuICAvLyBQdXNoIGNvbnRleHQgcHJvdmlkZXJzIGVhcmx5IHRvIHByZXZlbnQgY29udGV4dCBzdGFjayBtaXNtYXRjaGVzLlxuICAvLyBEdXJpbmcgbW91bnRpbmcgd2UgZG9uJ3Qga25vdyB0aGUgY2hpbGQgY29udGV4dCB5ZXQgYXMgdGhlIGluc3RhbmNlIGRvZXNuJ3QgZXhpc3QuXG4gIC8vIFdlIHdpbGwgaW52YWxpZGF0ZSB0aGUgY2hpbGQgY29udGV4dCBpbiBmaW5pc2hDbGFzc0NvbXBvbmVudCgpIHJpZ2h0IGFmdGVyIHJlbmRlcmluZy5cblxuICB2YXIgaGFzQ29udGV4dDtcblxuICBpZiAoaXNDb250ZXh0UHJvdmlkZXIoQ29tcG9uZW50KSkge1xuICAgIGhhc0NvbnRleHQgPSB0cnVlO1xuICAgIHB1c2hDb250ZXh0UHJvdmlkZXIod29ya0luUHJvZ3Jlc3MpO1xuICB9IGVsc2Uge1xuICAgIGhhc0NvbnRleHQgPSBmYWxzZTtcbiAgfVxuXG4gIHByZXBhcmVUb1JlYWRDb250ZXh0KHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcyk7XG4gIGNvbnN0cnVjdENsYXNzSW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MsIENvbXBvbmVudCwgbmV4dFByb3BzKTtcbiAgbW91bnRDbGFzc0luc3RhbmNlKHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQsIG5leHRQcm9wcywgcmVuZGVyTGFuZXMpO1xuICByZXR1cm4gZmluaXNoQ2xhc3NDb21wb25lbnQobnVsbCwgd29ya0luUHJvZ3Jlc3MsIENvbXBvbmVudCwgdHJ1ZSwgaGFzQ29udGV4dCwgcmVuZGVyTGFuZXMpO1xufVxuXG5mdW5jdGlvbiBtb3VudEluZGV0ZXJtaW5hdGVDb21wb25lbnQoX2N1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQsIHJlbmRlckxhbmVzKSB7XG4gIGlmIChfY3VycmVudCAhPT0gbnVsbCkge1xuICAgIC8vIEFuIGluZGV0ZXJtaW5hdGUgY29tcG9uZW50IG9ubHkgbW91bnRzIGlmIGl0IHN1c3BlbmRlZCBpbnNpZGUgYSBub24tXG4gICAgLy8gY29uY3VycmVudCB0cmVlLCBpbiBhbiBpbmNvbnNpc3RlbnQgc3RhdGUuIFdlIHdhbnQgdG8gdHJlYXQgaXQgbGlrZVxuICAgIC8vIGEgbmV3IG1vdW50LCBldmVuIHRob3VnaCBhbiBlbXB0eSB2ZXJzaW9uIG9mIGl0IGFscmVhZHkgY29tbWl0dGVkLlxuICAgIC8vIERpc2Nvbm5lY3QgdGhlIGFsdGVybmF0ZSBwb2ludGVycy5cbiAgICBfY3VycmVudC5hbHRlcm5hdGUgPSBudWxsO1xuICAgIHdvcmtJblByb2dyZXNzLmFsdGVybmF0ZSA9IG51bGw7IC8vIFNpbmNlIHRoaXMgaXMgY29uY2VwdHVhbGx5IGEgbmV3IGZpYmVyLCBzY2hlZHVsZSBhIFBsYWNlbWVudCBlZmZlY3RcblxuICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IFBsYWNlbWVudDtcbiAgfVxuXG4gIHZhciBwcm9wcyA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcztcbiAgdmFyIGNvbnRleHQ7XG5cbiAge1xuICAgIHZhciB1bm1hc2tlZENvbnRleHQgPSBnZXRVbm1hc2tlZENvbnRleHQod29ya0luUHJvZ3Jlc3MsIENvbXBvbmVudCwgZmFsc2UpO1xuICAgIGNvbnRleHQgPSBnZXRNYXNrZWRDb250ZXh0KHdvcmtJblByb2dyZXNzLCB1bm1hc2tlZENvbnRleHQpO1xuICB9XG5cbiAgcHJlcGFyZVRvUmVhZENvbnRleHQod29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKTtcbiAgdmFyIHZhbHVlO1xuXG4gIHtcbiAgICBpZiAoQ29tcG9uZW50LnByb3RvdHlwZSAmJiB0eXBlb2YgQ29tcG9uZW50LnByb3RvdHlwZS5yZW5kZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZShDb21wb25lbnQpIHx8ICdVbmtub3duJztcblxuICAgICAgaWYgKCFkaWRXYXJuQWJvdXRCYWRDbGFzc1tjb21wb25lbnROYW1lXSkge1xuICAgICAgICBlcnJvcihcIlRoZSA8JXMgLz4gY29tcG9uZW50IGFwcGVhcnMgdG8gaGF2ZSBhIHJlbmRlciBtZXRob2QsIGJ1dCBkb2Vzbid0IGV4dGVuZCBSZWFjdC5Db21wb25lbnQuIFwiICsgJ1RoaXMgaXMgbGlrZWx5IHRvIGNhdXNlIGVycm9ycy4gQ2hhbmdlICVzIHRvIGV4dGVuZCBSZWFjdC5Db21wb25lbnQgaW5zdGVhZC4nLCBjb21wb25lbnROYW1lLCBjb21wb25lbnROYW1lKTtcblxuICAgICAgICBkaWRXYXJuQWJvdXRCYWRDbGFzc1tjb21wb25lbnROYW1lXSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHdvcmtJblByb2dyZXNzLm1vZGUgJiBTdHJpY3RNb2RlKSB7XG4gICAgICBSZWFjdFN0cmljdE1vZGVXYXJuaW5ncy5yZWNvcmRMZWdhY3lDb250ZXh0V2FybmluZyh3b3JrSW5Qcm9ncmVzcywgbnVsbCk7XG4gICAgfVxuXG4gICAgc2V0SXNSZW5kZXJpbmcodHJ1ZSk7XG4gICAgUmVhY3RDdXJyZW50T3duZXIkMS5jdXJyZW50ID0gd29ya0luUHJvZ3Jlc3M7XG4gICAgdmFsdWUgPSByZW5kZXJXaXRoSG9va3MobnVsbCwgd29ya0luUHJvZ3Jlc3MsIENvbXBvbmVudCwgcHJvcHMsIGNvbnRleHQsIHJlbmRlckxhbmVzKTtcbiAgICBzZXRJc1JlbmRlcmluZyhmYWxzZSk7XG4gIH0gLy8gUmVhY3QgRGV2VG9vbHMgcmVhZHMgdGhpcyBmbGFnLlxuXG5cbiAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gUGVyZm9ybWVkV29yaztcblxuICB7XG4gICAgLy8gU3VwcG9ydCBmb3IgbW9kdWxlIGNvbXBvbmVudHMgaXMgZGVwcmVjYXRlZCBhbmQgaXMgcmVtb3ZlZCBiZWhpbmQgYSBmbGFnLlxuICAgIC8vIFdoZXRoZXIgb3Igbm90IGl0IHdvdWxkIGNyYXNoIGxhdGVyLCB3ZSB3YW50IHRvIHNob3cgYSBnb29kIG1lc3NhZ2UgaW4gREVWIGZpcnN0LlxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlICE9PSBudWxsICYmIHR5cGVvZiB2YWx1ZS5yZW5kZXIgPT09ICdmdW5jdGlvbicgJiYgdmFsdWUuJCR0eXBlb2YgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdmFyIF9jb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZShDb21wb25lbnQpIHx8ICdVbmtub3duJztcblxuICAgICAgaWYgKCFkaWRXYXJuQWJvdXRNb2R1bGVQYXR0ZXJuQ29tcG9uZW50W19jb21wb25lbnROYW1lXSkge1xuICAgICAgICBlcnJvcignVGhlIDwlcyAvPiBjb21wb25lbnQgYXBwZWFycyB0byBiZSBhIGZ1bmN0aW9uIGNvbXBvbmVudCB0aGF0IHJldHVybnMgYSBjbGFzcyBpbnN0YW5jZS4gJyArICdDaGFuZ2UgJXMgdG8gYSBjbGFzcyB0aGF0IGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IGluc3RlYWQuICcgKyBcIklmIHlvdSBjYW4ndCB1c2UgYSBjbGFzcyB0cnkgYXNzaWduaW5nIHRoZSBwcm90b3R5cGUgb24gdGhlIGZ1bmN0aW9uIGFzIGEgd29ya2Fyb3VuZC4gXCIgKyBcImAlcy5wcm90b3R5cGUgPSBSZWFjdC5Db21wb25lbnQucHJvdG90eXBlYC4gRG9uJ3QgdXNlIGFuIGFycm93IGZ1bmN0aW9uIHNpbmNlIGl0IFwiICsgJ2Nhbm5vdCBiZSBjYWxsZWQgd2l0aCBgbmV3YCBieSBSZWFjdC4nLCBfY29tcG9uZW50TmFtZSwgX2NvbXBvbmVudE5hbWUsIF9jb21wb25lbnROYW1lKTtcblxuICAgICAgICBkaWRXYXJuQWJvdXRNb2R1bGVQYXR0ZXJuQ29tcG9uZW50W19jb21wb25lbnROYW1lXSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKCAvLyBSdW4gdGhlc2UgY2hlY2tzIGluIHByb2R1Y3Rpb24gb25seSBpZiB0aGUgZmxhZyBpcyBvZmYuXG4gIC8vIEV2ZW50dWFsbHkgd2UnbGwgZGVsZXRlIHRoaXMgYnJhbmNoIGFsdG9nZXRoZXIuXG4gICB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlICE9PSBudWxsICYmIHR5cGVvZiB2YWx1ZS5yZW5kZXIgPT09ICdmdW5jdGlvbicgJiYgdmFsdWUuJCR0eXBlb2YgPT09IHVuZGVmaW5lZCkge1xuICAgIHtcbiAgICAgIHZhciBfY29tcG9uZW50TmFtZTIgPSBnZXRDb21wb25lbnROYW1lKENvbXBvbmVudCkgfHwgJ1Vua25vd24nO1xuXG4gICAgICBpZiAoIWRpZFdhcm5BYm91dE1vZHVsZVBhdHRlcm5Db21wb25lbnRbX2NvbXBvbmVudE5hbWUyXSkge1xuICAgICAgICBlcnJvcignVGhlIDwlcyAvPiBjb21wb25lbnQgYXBwZWFycyB0byBiZSBhIGZ1bmN0aW9uIGNvbXBvbmVudCB0aGF0IHJldHVybnMgYSBjbGFzcyBpbnN0YW5jZS4gJyArICdDaGFuZ2UgJXMgdG8gYSBjbGFzcyB0aGF0IGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IGluc3RlYWQuICcgKyBcIklmIHlvdSBjYW4ndCB1c2UgYSBjbGFzcyB0cnkgYXNzaWduaW5nIHRoZSBwcm90b3R5cGUgb24gdGhlIGZ1bmN0aW9uIGFzIGEgd29ya2Fyb3VuZC4gXCIgKyBcImAlcy5wcm90b3R5cGUgPSBSZWFjdC5Db21wb25lbnQucHJvdG90eXBlYC4gRG9uJ3QgdXNlIGFuIGFycm93IGZ1bmN0aW9uIHNpbmNlIGl0IFwiICsgJ2Nhbm5vdCBiZSBjYWxsZWQgd2l0aCBgbmV3YCBieSBSZWFjdC4nLCBfY29tcG9uZW50TmFtZTIsIF9jb21wb25lbnROYW1lMiwgX2NvbXBvbmVudE5hbWUyKTtcblxuICAgICAgICBkaWRXYXJuQWJvdXRNb2R1bGVQYXR0ZXJuQ29tcG9uZW50W19jb21wb25lbnROYW1lMl0gPSB0cnVlO1xuICAgICAgfVxuICAgIH0gLy8gUHJvY2VlZCB1bmRlciB0aGUgYXNzdW1wdGlvbiB0aGF0IHRoaXMgaXMgYSBjbGFzcyBpbnN0YW5jZVxuXG5cbiAgICB3b3JrSW5Qcm9ncmVzcy50YWcgPSBDbGFzc0NvbXBvbmVudDsgLy8gVGhyb3cgb3V0IGFueSBob29rcyB0aGF0IHdlcmUgdXNlZC5cblxuICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBudWxsO1xuICAgIHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlID0gbnVsbDsgLy8gUHVzaCBjb250ZXh0IHByb3ZpZGVycyBlYXJseSB0byBwcmV2ZW50IGNvbnRleHQgc3RhY2sgbWlzbWF0Y2hlcy5cbiAgICAvLyBEdXJpbmcgbW91bnRpbmcgd2UgZG9uJ3Qga25vdyB0aGUgY2hpbGQgY29udGV4dCB5ZXQgYXMgdGhlIGluc3RhbmNlIGRvZXNuJ3QgZXhpc3QuXG4gICAgLy8gV2Ugd2lsbCBpbnZhbGlkYXRlIHRoZSBjaGlsZCBjb250ZXh0IGluIGZpbmlzaENsYXNzQ29tcG9uZW50KCkgcmlnaHQgYWZ0ZXIgcmVuZGVyaW5nLlxuXG4gICAgdmFyIGhhc0NvbnRleHQgPSBmYWxzZTtcblxuICAgIGlmIChpc0NvbnRleHRQcm92aWRlcihDb21wb25lbnQpKSB7XG4gICAgICBoYXNDb250ZXh0ID0gdHJ1ZTtcbiAgICAgIHB1c2hDb250ZXh0UHJvdmlkZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgIH0gZWxzZSB7XG4gICAgICBoYXNDb250ZXh0ID0gZmFsc2U7XG4gICAgfVxuXG4gICAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IHZhbHVlLnN0YXRlICE9PSBudWxsICYmIHZhbHVlLnN0YXRlICE9PSB1bmRlZmluZWQgPyB2YWx1ZS5zdGF0ZSA6IG51bGw7XG4gICAgaW5pdGlhbGl6ZVVwZGF0ZVF1ZXVlKHdvcmtJblByb2dyZXNzKTtcbiAgICB2YXIgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzID0gQ29tcG9uZW50LmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcztcblxuICAgIGlmICh0eXBlb2YgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBhcHBseURlcml2ZWRTdGF0ZUZyb21Qcm9wcyh3b3JrSW5Qcm9ncmVzcywgQ29tcG9uZW50LCBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMsIHByb3BzKTtcbiAgICB9XG5cbiAgICBhZG9wdENsYXNzSW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MsIHZhbHVlKTtcbiAgICBtb3VudENsYXNzSW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MsIENvbXBvbmVudCwgcHJvcHMsIHJlbmRlckxhbmVzKTtcbiAgICByZXR1cm4gZmluaXNoQ2xhc3NDb21wb25lbnQobnVsbCwgd29ya0luUHJvZ3Jlc3MsIENvbXBvbmVudCwgdHJ1ZSwgaGFzQ29udGV4dCwgcmVuZGVyTGFuZXMpO1xuICB9IGVsc2Uge1xuICAgIC8vIFByb2NlZWQgdW5kZXIgdGhlIGFzc3VtcHRpb24gdGhhdCB0aGlzIGlzIGEgZnVuY3Rpb24gY29tcG9uZW50XG4gICAgd29ya0luUHJvZ3Jlc3MudGFnID0gRnVuY3Rpb25Db21wb25lbnQ7XG5cbiAgICB7XG5cbiAgICAgIGlmICggd29ya0luUHJvZ3Jlc3MubW9kZSAmIFN0cmljdE1vZGUpIHtcbiAgICAgICAgZGlzYWJsZUxvZ3MoKTtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgIHZhbHVlID0gcmVuZGVyV2l0aEhvb2tzKG51bGwsIHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQsIHByb3BzLCBjb250ZXh0LCByZW5kZXJMYW5lcyk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgcmVlbmFibGVMb2dzKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZWNvbmNpbGVDaGlsZHJlbihudWxsLCB3b3JrSW5Qcm9ncmVzcywgdmFsdWUsIHJlbmRlckxhbmVzKTtcblxuICAgIHtcbiAgICAgIHZhbGlkYXRlRnVuY3Rpb25Db21wb25lbnRJbkRldih3b3JrSW5Qcm9ncmVzcywgQ29tcG9uZW50KTtcbiAgICB9XG5cbiAgICByZXR1cm4gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG4gIH1cbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVGdW5jdGlvbkNvbXBvbmVudEluRGV2KHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQpIHtcbiAge1xuICAgIGlmIChDb21wb25lbnQpIHtcbiAgICAgIGlmIChDb21wb25lbnQuY2hpbGRDb250ZXh0VHlwZXMpIHtcbiAgICAgICAgZXJyb3IoJyVzKC4uLik6IGNoaWxkQ29udGV4dFR5cGVzIGNhbm5vdCBiZSBkZWZpbmVkIG9uIGEgZnVuY3Rpb24gY29tcG9uZW50LicsIENvbXBvbmVudC5kaXNwbGF5TmFtZSB8fCBDb21wb25lbnQubmFtZSB8fCAnQ29tcG9uZW50Jyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHdvcmtJblByb2dyZXNzLnJlZiAhPT0gbnVsbCkge1xuICAgICAgdmFyIGluZm8gPSAnJztcbiAgICAgIHZhciBvd25lck5hbWUgPSBnZXRDdXJyZW50RmliZXJPd25lck5hbWVJbkRldk9yTnVsbCgpO1xuXG4gICAgICBpZiAob3duZXJOYW1lKSB7XG4gICAgICAgIGluZm8gKz0gJ1xcblxcbkNoZWNrIHRoZSByZW5kZXIgbWV0aG9kIG9mIGAnICsgb3duZXJOYW1lICsgJ2AuJztcbiAgICAgIH1cblxuICAgICAgdmFyIHdhcm5pbmdLZXkgPSBvd25lck5hbWUgfHwgd29ya0luUHJvZ3Jlc3MuX2RlYnVnSUQgfHwgJyc7XG4gICAgICB2YXIgZGVidWdTb3VyY2UgPSB3b3JrSW5Qcm9ncmVzcy5fZGVidWdTb3VyY2U7XG5cbiAgICAgIGlmIChkZWJ1Z1NvdXJjZSkge1xuICAgICAgICB3YXJuaW5nS2V5ID0gZGVidWdTb3VyY2UuZmlsZU5hbWUgKyAnOicgKyBkZWJ1Z1NvdXJjZS5saW5lTnVtYmVyO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWRpZFdhcm5BYm91dEZ1bmN0aW9uUmVmc1t3YXJuaW5nS2V5XSkge1xuICAgICAgICBkaWRXYXJuQWJvdXRGdW5jdGlvblJlZnNbd2FybmluZ0tleV0gPSB0cnVlO1xuXG4gICAgICAgIGVycm9yKCdGdW5jdGlvbiBjb21wb25lbnRzIGNhbm5vdCBiZSBnaXZlbiByZWZzLiAnICsgJ0F0dGVtcHRzIHRvIGFjY2VzcyB0aGlzIHJlZiB3aWxsIGZhaWwuICcgKyAnRGlkIHlvdSBtZWFuIHRvIHVzZSBSZWFjdC5mb3J3YXJkUmVmKCk/JXMnLCBpbmZvKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIENvbXBvbmVudC5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHZhciBfY29tcG9uZW50TmFtZTMgPSBnZXRDb21wb25lbnROYW1lKENvbXBvbmVudCkgfHwgJ1Vua25vd24nO1xuXG4gICAgICBpZiAoIWRpZFdhcm5BYm91dEdldERlcml2ZWRTdGF0ZU9uRnVuY3Rpb25Db21wb25lbnRbX2NvbXBvbmVudE5hbWUzXSkge1xuICAgICAgICBlcnJvcignJXM6IEZ1bmN0aW9uIGNvbXBvbmVudHMgZG8gbm90IHN1cHBvcnQgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzLicsIF9jb21wb25lbnROYW1lMyk7XG5cbiAgICAgICAgZGlkV2FybkFib3V0R2V0RGVyaXZlZFN0YXRlT25GdW5jdGlvbkNvbXBvbmVudFtfY29tcG9uZW50TmFtZTNdID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIENvbXBvbmVudC5jb250ZXh0VHlwZSA9PT0gJ29iamVjdCcgJiYgQ29tcG9uZW50LmNvbnRleHRUeXBlICE9PSBudWxsKSB7XG4gICAgICB2YXIgX2NvbXBvbmVudE5hbWU0ID0gZ2V0Q29tcG9uZW50TmFtZShDb21wb25lbnQpIHx8ICdVbmtub3duJztcblxuICAgICAgaWYgKCFkaWRXYXJuQWJvdXRDb250ZXh0VHlwZU9uRnVuY3Rpb25Db21wb25lbnRbX2NvbXBvbmVudE5hbWU0XSkge1xuICAgICAgICBlcnJvcignJXM6IEZ1bmN0aW9uIGNvbXBvbmVudHMgZG8gbm90IHN1cHBvcnQgY29udGV4dFR5cGUuJywgX2NvbXBvbmVudE5hbWU0KTtcblxuICAgICAgICBkaWRXYXJuQWJvdXRDb250ZXh0VHlwZU9uRnVuY3Rpb25Db21wb25lbnRbX2NvbXBvbmVudE5hbWU0XSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbnZhciBTVVNQRU5ERURfTUFSS0VSID0ge1xuICBkZWh5ZHJhdGVkOiBudWxsLFxuICByZXRyeUxhbmU6IE5vTGFuZVxufTtcblxuZnVuY3Rpb24gbW91bnRTdXNwZW5zZU9mZnNjcmVlblN0YXRlKHJlbmRlckxhbmVzKSB7XG4gIHJldHVybiB7XG4gICAgYmFzZUxhbmVzOiByZW5kZXJMYW5lc1xuICB9O1xufVxuXG5mdW5jdGlvbiB1cGRhdGVTdXNwZW5zZU9mZnNjcmVlblN0YXRlKHByZXZPZmZzY3JlZW5TdGF0ZSwgcmVuZGVyTGFuZXMpIHtcbiAgcmV0dXJuIHtcbiAgICBiYXNlTGFuZXM6IG1lcmdlTGFuZXMocHJldk9mZnNjcmVlblN0YXRlLmJhc2VMYW5lcywgcmVuZGVyTGFuZXMpXG4gIH07XG59IC8vIFRPRE86IFByb2JhYmx5IHNob3VsZCBpbmxpbmUgdGhpcyBiYWNrXG5cblxuZnVuY3Rpb24gc2hvdWxkUmVtYWluT25GYWxsYmFjayhzdXNwZW5zZUNvbnRleHQsIGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcykge1xuICAvLyBJZiB3ZSdyZSBhbHJlYWR5IHNob3dpbmcgYSBmYWxsYmFjaywgdGhlcmUgYXJlIGNhc2VzIHdoZXJlIHdlIG5lZWQgdG9cbiAgLy8gcmVtYWluIG9uIHRoYXQgZmFsbGJhY2sgcmVnYXJkbGVzcyBvZiB3aGV0aGVyIHRoZSBjb250ZW50IGhhcyByZXNvbHZlZC5cbiAgLy8gRm9yIGV4YW1wbGUsIFN1c3BlbnNlTGlzdCBjb29yZGluYXRlcyB3aGVuIG5lc3RlZCBjb250ZW50IGFwcGVhcnMuXG4gIGlmIChjdXJyZW50ICE9PSBudWxsKSB7XG4gICAgdmFyIHN1c3BlbnNlU3RhdGUgPSBjdXJyZW50Lm1lbW9pemVkU3RhdGU7XG5cbiAgICBpZiAoc3VzcGVuc2VTdGF0ZSA9PT0gbnVsbCkge1xuICAgICAgLy8gQ3VycmVudGx5IHNob3dpbmcgY29udGVudC4gRG9uJ3QgaGlkZSBpdCwgZXZlbiBpZiBGb3JjZVN1c3BlbnNlRmFsbGFja1xuICAgICAgLy8gaXMgdHJ1ZS4gTW9yZSBwcmVjaXNlIG5hbWUgbWlnaHQgYmUgXCJGb3JjZVJlbWFpblN1c3BlbnNlRmFsbGJhY2tcIi5cbiAgICAgIC8vIE5vdGU6IFRoaXMgaXMgYSBmYWN0b3Jpbmcgc21lbGwuIENhbid0IHJlbWFpbiBvbiBhIGZhbGxiYWNrIGlmIHRoZXJlJ3NcbiAgICAgIC8vIG5vIGZhbGxiYWNrIHRvIHJlbWFpbiBvbi5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0gLy8gTm90IGN1cnJlbnRseSBzaG93aW5nIGNvbnRlbnQuIENvbnN1bHQgdGhlIFN1c3BlbnNlIGNvbnRleHQuXG5cblxuICByZXR1cm4gaGFzU3VzcGVuc2VDb250ZXh0KHN1c3BlbnNlQ29udGV4dCwgRm9yY2VTdXNwZW5zZUZhbGxiYWNrKTtcbn1cblxuZnVuY3Rpb24gZ2V0UmVtYWluaW5nV29ya0luUHJpbWFyeVRyZWUoY3VycmVudCwgcmVuZGVyTGFuZXMpIHtcbiAgLy8gVE9ETzogU2hvdWxkIG5vdCByZW1vdmUgcmVuZGVyIGxhbmVzIHRoYXQgd2VyZSBwaW5nZWQgZHVyaW5nIHRoaXMgcmVuZGVyXG4gIHJldHVybiByZW1vdmVMYW5lcyhjdXJyZW50LmNoaWxkTGFuZXMsIHJlbmRlckxhbmVzKTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlU3VzcGVuc2VDb21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKSB7XG4gIHZhciBuZXh0UHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7IC8vIFRoaXMgaXMgdXNlZCBieSBEZXZUb29scyB0byBmb3JjZSBhIGJvdW5kYXJ5IHRvIHN1c3BlbmQuXG5cbiAge1xuICAgIGlmIChzaG91bGRTdXNwZW5kKHdvcmtJblByb2dyZXNzKSkge1xuICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gRGlkQ2FwdHVyZTtcbiAgICB9XG4gIH1cblxuICB2YXIgc3VzcGVuc2VDb250ZXh0ID0gc3VzcGVuc2VTdGFja0N1cnNvci5jdXJyZW50O1xuICB2YXIgc2hvd0ZhbGxiYWNrID0gZmFsc2U7XG4gIHZhciBkaWRTdXNwZW5kID0gKHdvcmtJblByb2dyZXNzLmZsYWdzICYgRGlkQ2FwdHVyZSkgIT09IE5vRmxhZ3M7XG5cbiAgaWYgKGRpZFN1c3BlbmQgfHwgc2hvdWxkUmVtYWluT25GYWxsYmFjayhzdXNwZW5zZUNvbnRleHQsIGN1cnJlbnQpKSB7XG4gICAgLy8gU29tZXRoaW5nIGluIHRoaXMgYm91bmRhcnkncyBzdWJ0cmVlIGFscmVhZHkgc3VzcGVuZGVkLiBTd2l0Y2ggdG9cbiAgICAvLyByZW5kZXJpbmcgdGhlIGZhbGxiYWNrIGNoaWxkcmVuLlxuICAgIHNob3dGYWxsYmFjayA9IHRydWU7XG4gICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgJj0gfkRpZENhcHR1cmU7XG4gIH0gZWxzZSB7XG4gICAgLy8gQXR0ZW1wdGluZyB0aGUgbWFpbiBjb250ZW50XG4gICAgaWYgKGN1cnJlbnQgPT09IG51bGwgfHwgY3VycmVudC5tZW1vaXplZFN0YXRlICE9PSBudWxsKSB7XG4gICAgICAvLyBUaGlzIGlzIGEgbmV3IG1vdW50IG9yIHRoaXMgYm91bmRhcnkgaXMgYWxyZWFkeSBzaG93aW5nIGEgZmFsbGJhY2sgc3RhdGUuXG4gICAgICAvLyBNYXJrIHRoaXMgc3VidHJlZSBjb250ZXh0IGFzIGhhdmluZyBhdCBsZWFzdCBvbmUgaW52aXNpYmxlIHBhcmVudCB0aGF0IGNvdWxkXG4gICAgICAvLyBoYW5kbGUgdGhlIGZhbGxiYWNrIHN0YXRlLlxuICAgICAgLy8gQm91bmRhcmllcyB3aXRob3V0IGZhbGxiYWNrcyBvciBzaG91bGQgYmUgYXZvaWRlZCBhcmUgbm90IGNvbnNpZGVyZWQgc2luY2VcbiAgICAgIC8vIHRoZXkgY2Fubm90IGhhbmRsZSBwcmVmZXJyZWQgZmFsbGJhY2sgc3RhdGVzLlxuICAgICAgaWYgKG5leHRQcm9wcy5mYWxsYmFjayAhPT0gdW5kZWZpbmVkICYmIG5leHRQcm9wcy51bnN0YWJsZV9hdm9pZFRoaXNGYWxsYmFjayAhPT0gdHJ1ZSkge1xuICAgICAgICBzdXNwZW5zZUNvbnRleHQgPSBhZGRTdWJ0cmVlU3VzcGVuc2VDb250ZXh0KHN1c3BlbnNlQ29udGV4dCwgSW52aXNpYmxlUGFyZW50U3VzcGVuc2VDb250ZXh0KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBzdXNwZW5zZUNvbnRleHQgPSBzZXREZWZhdWx0U2hhbGxvd1N1c3BlbnNlQ29udGV4dChzdXNwZW5zZUNvbnRleHQpO1xuICBwdXNoU3VzcGVuc2VDb250ZXh0KHdvcmtJblByb2dyZXNzLCBzdXNwZW5zZUNvbnRleHQpOyAvLyBPSywgdGhlIG5leHQgcGFydCBpcyBjb25mdXNpbmcuIFdlJ3JlIGFib3V0IHRvIHJlY29uY2lsZSB0aGUgU3VzcGVuc2VcbiAgLy8gYm91bmRhcnkncyBjaGlsZHJlbi4gVGhpcyBpbnZvbHZlcyBzb21lIGN1c3RvbSByZWNvbmNpbGF0aW9uIGxvZ2ljLiBUd29cbiAgLy8gbWFpbiByZWFzb25zIHRoaXMgaXMgc28gY29tcGxpY2F0ZWQuXG4gIC8vXG4gIC8vIEZpcnN0LCBMZWdhY3kgTW9kZSBoYXMgZGlmZmVyZW50IHNlbWFudGljcyBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkuIFRoZVxuICAvLyBwcmltYXJ5IHRyZWUgd2lsbCBjb21taXQgaW4gYW4gaW5jb25zaXN0ZW50IHN0YXRlLCBzbyB3aGVuIHdlIGRvIHRoZVxuICAvLyBzZWNvbmQgcGFzcyB0byByZW5kZXIgdGhlIGZhbGxiYWNrLCB3ZSBkbyBzb21lIGV4Y2VlZGluZ2x5LCB1aCwgY2xldmVyXG4gIC8vIGhhY2tzIHRvIG1ha2UgdGhhdCBub3QgdG90YWxseSBicmVhay4gTGlrZSB0cmFuc2ZlcnJpbmcgZWZmZWN0cyBhbmRcbiAgLy8gZGVsZXRpb25zIGZyb20gaGlkZGVuIHRyZWUuIEluIENvbmN1cnJlbnQgTW9kZSwgaXQncyBtdWNoIHNpbXBsZXIsXG4gIC8vIGJlY2F1c2Ugd2UgYmFpbG91dCBvbiB0aGUgcHJpbWFyeSB0cmVlIGNvbXBsZXRlbHkgYW5kIGxlYXZlIGl0IGluIGl0cyBvbGRcbiAgLy8gc3RhdGUsIG5vIGVmZmVjdHMuIFNhbWUgYXMgd2hhdCB3ZSBkbyBmb3IgT2Zmc2NyZWVuIChleGNlcHQgdGhhdFxuICAvLyBPZmZzY3JlZW4gZG9lc24ndCBoYXZlIHRoZSBmaXJzdCByZW5kZXIgcGFzcykuXG4gIC8vXG4gIC8vIFNlY29uZCBpcyBoeWRyYXRpb24uIER1cmluZyBoeWRyYXRpb24sIHRoZSBTdXNwZW5zZSBmaWJlciBoYXMgYSBzbGlnaHRseVxuICAvLyBkaWZmZXJlbnQgbGF5b3V0LCB3aGVyZSB0aGUgY2hpbGQgcG9pbnRzIHRvIGEgZGVoeWRyYXRlZCBmcmFnbWVudCwgd2hpY2hcbiAgLy8gY29udGFpbnMgdGhlIERPTSByZW5kZXJlZCBieSB0aGUgc2VydmVyLlxuICAvL1xuICAvLyBUaGlyZCwgZXZlbiBpZiB5b3Ugc2V0IGFsbCB0aGF0IGFzaWRlLCBTdXNwZW5zZSBpcyBsaWtlIGVycm9yIGJvdW5kYXJpZXMgaW5cbiAgLy8gdGhhdCB3ZSBmaXJzdCB3ZSB0cnkgdG8gcmVuZGVyIG9uZSB0cmVlLCBhbmQgaWYgdGhhdCBmYWlscywgd2UgcmVuZGVyIGFnYWluXG4gIC8vIGFuZCBzd2l0Y2ggdG8gYSBkaWZmZXJlbnQgdHJlZS4gTGlrZSBhIHRyeS9jYXRjaCBibG9jay4gU28gd2UgaGF2ZSB0byB0cmFja1xuICAvLyB3aGljaCBicmFuY2ggd2UncmUgY3VycmVudGx5IHJlbmRlcmluZy4gSWRlYWxseSB3ZSB3b3VsZCBtb2RlbCB0aGlzIHVzaW5nXG4gIC8vIGEgc3RhY2suXG5cbiAgaWYgKGN1cnJlbnQgPT09IG51bGwpIHtcbiAgICAvLyBJbml0aWFsIG1vdW50XG4gICAgLy8gSWYgd2UncmUgY3VycmVudGx5IGh5ZHJhdGluZywgdHJ5IHRvIGh5ZHJhdGUgdGhpcyBib3VuZGFyeS5cbiAgICAvLyBCdXQgb25seSBpZiB0aGlzIGhhcyBhIGZhbGxiYWNrLlxuICAgIGlmIChuZXh0UHJvcHMuZmFsbGJhY2sgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdHJ5VG9DbGFpbU5leHRIeWRyYXRhYmxlSW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MpOyAvLyBUaGlzIGNvdWxkJ3ZlIGJlZW4gYSBkZWh5ZHJhdGVkIHN1c3BlbnNlIGNvbXBvbmVudC5cbiAgICB9XG5cbiAgICB2YXIgbmV4dFByaW1hcnlDaGlsZHJlbiA9IG5leHRQcm9wcy5jaGlsZHJlbjtcbiAgICB2YXIgbmV4dEZhbGxiYWNrQ2hpbGRyZW4gPSBuZXh0UHJvcHMuZmFsbGJhY2s7XG5cbiAgICBpZiAoc2hvd0ZhbGxiYWNrKSB7XG4gICAgICB2YXIgZmFsbGJhY2tGcmFnbWVudCA9IG1vdW50U3VzcGVuc2VGYWxsYmFja0NoaWxkcmVuKHdvcmtJblByb2dyZXNzLCBuZXh0UHJpbWFyeUNoaWxkcmVuLCBuZXh0RmFsbGJhY2tDaGlsZHJlbiwgcmVuZGVyTGFuZXMpO1xuICAgICAgdmFyIHByaW1hcnlDaGlsZEZyYWdtZW50ID0gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG4gICAgICBwcmltYXJ5Q2hpbGRGcmFnbWVudC5tZW1vaXplZFN0YXRlID0gbW91bnRTdXNwZW5zZU9mZnNjcmVlblN0YXRlKHJlbmRlckxhbmVzKTtcbiAgICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBTVVNQRU5ERURfTUFSS0VSO1xuICAgICAgcmV0dXJuIGZhbGxiYWNrRnJhZ21lbnQ7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgbmV4dFByb3BzLnVuc3RhYmxlX2V4cGVjdGVkTG9hZFRpbWUgPT09ICdudW1iZXInKSB7XG4gICAgICAvLyBUaGlzIGlzIGEgQ1BVLWJvdW5kIHRyZWUuIFNraXAgdGhpcyB0cmVlIGFuZCBzaG93IGEgcGxhY2Vob2xkZXIgdG9cbiAgICAgIC8vIHVuYmxvY2sgdGhlIHN1cnJvdW5kaW5nIGNvbnRlbnQuIFRoZW4gaW1tZWRpYXRlbHkgcmV0cnkgYWZ0ZXIgdGhlXG4gICAgICAvLyBpbml0aWFsIGNvbW1pdC5cbiAgICAgIHZhciBfZmFsbGJhY2tGcmFnbWVudCA9IG1vdW50U3VzcGVuc2VGYWxsYmFja0NoaWxkcmVuKHdvcmtJblByb2dyZXNzLCBuZXh0UHJpbWFyeUNoaWxkcmVuLCBuZXh0RmFsbGJhY2tDaGlsZHJlbiwgcmVuZGVyTGFuZXMpO1xuXG4gICAgICB2YXIgX3ByaW1hcnlDaGlsZEZyYWdtZW50ID0gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG4gICAgICBfcHJpbWFyeUNoaWxkRnJhZ21lbnQubWVtb2l6ZWRTdGF0ZSA9IG1vdW50U3VzcGVuc2VPZmZzY3JlZW5TdGF0ZShyZW5kZXJMYW5lcyk7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0gU1VTUEVOREVEX01BUktFUjsgLy8gU2luY2Ugbm90aGluZyBhY3R1YWxseSBzdXNwZW5kZWQsIHRoZXJlIHdpbGwgbm90aGluZyB0byBwaW5nIHRoaXMgdG9cbiAgICAgIC8vIGdldCBpdCBzdGFydGVkIGJhY2sgdXAgdG8gYXR0ZW1wdCB0aGUgbmV4dCBpdGVtLiBXaGlsZSBpbiB0ZXJtcyBvZlxuICAgICAgLy8gcHJpb3JpdHkgdGhpcyB3b3JrIGhhcyB0aGUgc2FtZSBwcmlvcml0eSBhcyB0aGlzIGN1cnJlbnQgcmVuZGVyLCBpdCdzXG4gICAgICAvLyBub3QgcGFydCBvZiB0aGUgc2FtZSB0cmFuc2l0aW9uIG9uY2UgdGhlIHRyYW5zaXRpb24gaGFzIGNvbW1pdHRlZC4gSWZcbiAgICAgIC8vIGl0J3Mgc3luYywgd2Ugc3RpbGwgd2FudCB0byB5aWVsZCBzbyB0aGF0IGl0IGNhbiBiZSBwYWludGVkLlxuICAgICAgLy8gQ29uY2VwdHVhbGx5LCB0aGlzIGlzIHJlYWxseSB0aGUgc2FtZSBhcyBwaW5naW5nLiBXZSBjYW4gdXNlIGFueVxuICAgICAgLy8gUmV0cnlMYW5lIGV2ZW4gaWYgaXQncyB0aGUgb25lIGN1cnJlbnRseSByZW5kZXJpbmcgc2luY2Ugd2UncmUgbGVhdmluZ1xuICAgICAgLy8gaXQgYmVoaW5kIG9uIHRoaXMgbm9kZS5cblxuICAgICAgd29ya0luUHJvZ3Jlc3MubGFuZXMgPSBTb21lUmV0cnlMYW5lO1xuXG4gICAgICB7XG4gICAgICAgIG1hcmtTcGF3bmVkV29yayhTb21lUmV0cnlMYW5lKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIF9mYWxsYmFja0ZyYWdtZW50O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbW91bnRTdXNwZW5zZVByaW1hcnlDaGlsZHJlbih3b3JrSW5Qcm9ncmVzcywgbmV4dFByaW1hcnlDaGlsZHJlbiwgcmVuZGVyTGFuZXMpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBUaGlzIGlzIGFuIHVwZGF0ZS5cbiAgICAvLyBJZiB0aGUgY3VycmVudCBmaWJlciBoYXMgYSBTdXNwZW5zZVN0YXRlLCB0aGF0IG1lYW5zIGl0J3MgYWxyZWFkeSBzaG93aW5nXG4gICAgLy8gYSBmYWxsYmFjay5cbiAgICB2YXIgcHJldlN0YXRlID0gY3VycmVudC5tZW1vaXplZFN0YXRlO1xuXG4gICAgaWYgKHByZXZTdGF0ZSAhPT0gbnVsbCkge1xuXG4gICAgICBpZiAoc2hvd0ZhbGxiYWNrKSB7XG4gICAgICAgIHZhciBfbmV4dEZhbGxiYWNrQ2hpbGRyZW4yID0gbmV4dFByb3BzLmZhbGxiYWNrO1xuICAgICAgICB2YXIgX25leHRQcmltYXJ5Q2hpbGRyZW4yID0gbmV4dFByb3BzLmNoaWxkcmVuO1xuXG4gICAgICAgIHZhciBfZmFsbGJhY2tDaGlsZEZyYWdtZW50ID0gdXBkYXRlU3VzcGVuc2VGYWxsYmFja0NoaWxkcmVuKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBfbmV4dFByaW1hcnlDaGlsZHJlbjIsIF9uZXh0RmFsbGJhY2tDaGlsZHJlbjIsIHJlbmRlckxhbmVzKTtcblxuICAgICAgICB2YXIgX3ByaW1hcnlDaGlsZEZyYWdtZW50MyA9IHdvcmtJblByb2dyZXNzLmNoaWxkO1xuICAgICAgICB2YXIgcHJldk9mZnNjcmVlblN0YXRlID0gY3VycmVudC5jaGlsZC5tZW1vaXplZFN0YXRlO1xuICAgICAgICBfcHJpbWFyeUNoaWxkRnJhZ21lbnQzLm1lbW9pemVkU3RhdGUgPSBwcmV2T2Zmc2NyZWVuU3RhdGUgPT09IG51bGwgPyBtb3VudFN1c3BlbnNlT2Zmc2NyZWVuU3RhdGUocmVuZGVyTGFuZXMpIDogdXBkYXRlU3VzcGVuc2VPZmZzY3JlZW5TdGF0ZShwcmV2T2Zmc2NyZWVuU3RhdGUsIHJlbmRlckxhbmVzKTtcbiAgICAgICAgX3ByaW1hcnlDaGlsZEZyYWdtZW50My5jaGlsZExhbmVzID0gZ2V0UmVtYWluaW5nV29ya0luUHJpbWFyeVRyZWUoY3VycmVudCwgcmVuZGVyTGFuZXMpO1xuICAgICAgICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0gU1VTUEVOREVEX01BUktFUjtcbiAgICAgICAgcmV0dXJuIF9mYWxsYmFja0NoaWxkRnJhZ21lbnQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgX25leHRQcmltYXJ5Q2hpbGRyZW4zID0gbmV4dFByb3BzLmNoaWxkcmVuO1xuXG4gICAgICAgIHZhciBfcHJpbWFyeUNoaWxkRnJhZ21lbnQ0ID0gdXBkYXRlU3VzcGVuc2VQcmltYXJ5Q2hpbGRyZW4oY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIF9uZXh0UHJpbWFyeUNoaWxkcmVuMywgcmVuZGVyTGFuZXMpO1xuXG4gICAgICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBudWxsO1xuICAgICAgICByZXR1cm4gX3ByaW1hcnlDaGlsZEZyYWdtZW50NDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVGhlIGN1cnJlbnQgdHJlZSBpcyBub3QgYWxyZWFkeSBzaG93aW5nIGEgZmFsbGJhY2suXG4gICAgICBpZiAoc2hvd0ZhbGxiYWNrKSB7XG4gICAgICAgIC8vIFRpbWVkIG91dC5cbiAgICAgICAgdmFyIF9uZXh0RmFsbGJhY2tDaGlsZHJlbjMgPSBuZXh0UHJvcHMuZmFsbGJhY2s7XG4gICAgICAgIHZhciBfbmV4dFByaW1hcnlDaGlsZHJlbjQgPSBuZXh0UHJvcHMuY2hpbGRyZW47XG5cbiAgICAgICAgdmFyIF9mYWxsYmFja0NoaWxkRnJhZ21lbnQyID0gdXBkYXRlU3VzcGVuc2VGYWxsYmFja0NoaWxkcmVuKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBfbmV4dFByaW1hcnlDaGlsZHJlbjQsIF9uZXh0RmFsbGJhY2tDaGlsZHJlbjMsIHJlbmRlckxhbmVzKTtcblxuICAgICAgICB2YXIgX3ByaW1hcnlDaGlsZEZyYWdtZW50NSA9IHdvcmtJblByb2dyZXNzLmNoaWxkO1xuICAgICAgICB2YXIgX3ByZXZPZmZzY3JlZW5TdGF0ZSA9IGN1cnJlbnQuY2hpbGQubWVtb2l6ZWRTdGF0ZTtcbiAgICAgICAgX3ByaW1hcnlDaGlsZEZyYWdtZW50NS5tZW1vaXplZFN0YXRlID0gX3ByZXZPZmZzY3JlZW5TdGF0ZSA9PT0gbnVsbCA/IG1vdW50U3VzcGVuc2VPZmZzY3JlZW5TdGF0ZShyZW5kZXJMYW5lcykgOiB1cGRhdGVTdXNwZW5zZU9mZnNjcmVlblN0YXRlKF9wcmV2T2Zmc2NyZWVuU3RhdGUsIHJlbmRlckxhbmVzKTtcbiAgICAgICAgX3ByaW1hcnlDaGlsZEZyYWdtZW50NS5jaGlsZExhbmVzID0gZ2V0UmVtYWluaW5nV29ya0luUHJpbWFyeVRyZWUoY3VycmVudCwgcmVuZGVyTGFuZXMpOyAvLyBTa2lwIHRoZSBwcmltYXJ5IGNoaWxkcmVuLCBhbmQgY29udGludWUgd29ya2luZyBvbiB0aGVcbiAgICAgICAgLy8gZmFsbGJhY2sgY2hpbGRyZW4uXG5cbiAgICAgICAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IFNVU1BFTkRFRF9NQVJLRVI7XG4gICAgICAgIHJldHVybiBfZmFsbGJhY2tDaGlsZEZyYWdtZW50MjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFN0aWxsIGhhdmVuJ3QgdGltZWQgb3V0LiBDb250aW51ZSByZW5kZXJpbmcgdGhlIGNoaWxkcmVuLCBsaWtlIHdlXG4gICAgICAgIC8vIG5vcm1hbGx5IGRvLlxuICAgICAgICB2YXIgX25leHRQcmltYXJ5Q2hpbGRyZW41ID0gbmV4dFByb3BzLmNoaWxkcmVuO1xuXG4gICAgICAgIHZhciBfcHJpbWFyeUNoaWxkRnJhZ21lbnQ2ID0gdXBkYXRlU3VzcGVuc2VQcmltYXJ5Q2hpbGRyZW4oY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIF9uZXh0UHJpbWFyeUNoaWxkcmVuNSwgcmVuZGVyTGFuZXMpO1xuXG4gICAgICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBudWxsO1xuICAgICAgICByZXR1cm4gX3ByaW1hcnlDaGlsZEZyYWdtZW50NjtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gbW91bnRTdXNwZW5zZVByaW1hcnlDaGlsZHJlbih3b3JrSW5Qcm9ncmVzcywgcHJpbWFyeUNoaWxkcmVuLCByZW5kZXJMYW5lcykge1xuICB2YXIgbW9kZSA9IHdvcmtJblByb2dyZXNzLm1vZGU7XG4gIHZhciBwcmltYXJ5Q2hpbGRQcm9wcyA9IHtcbiAgICBtb2RlOiAndmlzaWJsZScsXG4gICAgY2hpbGRyZW46IHByaW1hcnlDaGlsZHJlblxuICB9O1xuICB2YXIgcHJpbWFyeUNoaWxkRnJhZ21lbnQgPSBjcmVhdGVGaWJlckZyb21PZmZzY3JlZW4ocHJpbWFyeUNoaWxkUHJvcHMsIG1vZGUsIHJlbmRlckxhbmVzLCBudWxsKTtcbiAgcHJpbWFyeUNoaWxkRnJhZ21lbnQucmV0dXJuID0gd29ya0luUHJvZ3Jlc3M7XG4gIHdvcmtJblByb2dyZXNzLmNoaWxkID0gcHJpbWFyeUNoaWxkRnJhZ21lbnQ7XG4gIHJldHVybiBwcmltYXJ5Q2hpbGRGcmFnbWVudDtcbn1cblxuZnVuY3Rpb24gbW91bnRTdXNwZW5zZUZhbGxiYWNrQ2hpbGRyZW4od29ya0luUHJvZ3Jlc3MsIHByaW1hcnlDaGlsZHJlbiwgZmFsbGJhY2tDaGlsZHJlbiwgcmVuZGVyTGFuZXMpIHtcbiAgdmFyIG1vZGUgPSB3b3JrSW5Qcm9ncmVzcy5tb2RlO1xuICB2YXIgcHJvZ3Jlc3NlZFByaW1hcnlGcmFnbWVudCA9IHdvcmtJblByb2dyZXNzLmNoaWxkO1xuICB2YXIgcHJpbWFyeUNoaWxkUHJvcHMgPSB7XG4gICAgbW9kZTogJ2hpZGRlbicsXG4gICAgY2hpbGRyZW46IHByaW1hcnlDaGlsZHJlblxuICB9O1xuICB2YXIgcHJpbWFyeUNoaWxkRnJhZ21lbnQ7XG4gIHZhciBmYWxsYmFja0NoaWxkRnJhZ21lbnQ7XG5cbiAgaWYgKChtb2RlICYgQmxvY2tpbmdNb2RlKSA9PT0gTm9Nb2RlICYmIHByb2dyZXNzZWRQcmltYXJ5RnJhZ21lbnQgIT09IG51bGwpIHtcbiAgICAvLyBJbiBsZWdhY3kgbW9kZSwgd2UgY29tbWl0IHRoZSBwcmltYXJ5IHRyZWUgYXMgaWYgaXQgc3VjY2Vzc2Z1bGx5XG4gICAgLy8gY29tcGxldGVkLCBldmVuIHRob3VnaCBpdCdzIGluIGFuIGluY29uc2lzdGVudCBzdGF0ZS5cbiAgICBwcmltYXJ5Q2hpbGRGcmFnbWVudCA9IHByb2dyZXNzZWRQcmltYXJ5RnJhZ21lbnQ7XG4gICAgcHJpbWFyeUNoaWxkRnJhZ21lbnQuY2hpbGRMYW5lcyA9IE5vTGFuZXM7XG4gICAgcHJpbWFyeUNoaWxkRnJhZ21lbnQucGVuZGluZ1Byb3BzID0gcHJpbWFyeUNoaWxkUHJvcHM7XG5cbiAgICBpZiAoIHdvcmtJblByb2dyZXNzLm1vZGUgJiBQcm9maWxlTW9kZSkge1xuICAgICAgLy8gUmVzZXQgdGhlIGR1cmF0aW9ucyBmcm9tIHRoZSBmaXJzdCBwYXNzIHNvIHRoZXkgYXJlbid0IGluY2x1ZGVkIGluIHRoZVxuICAgICAgLy8gZmluYWwgYW1vdW50cy4gVGhpcyBzZWVtcyBjb3VudGVyaW50dWl0aXZlLCBzaW5jZSB3ZSdyZSBpbnRlbnRpb25hbGx5XG4gICAgICAvLyBub3QgbWVhc3VyaW5nIHBhcnQgb2YgdGhlIHJlbmRlciBwaGFzZSwgYnV0IHRoaXMgbWFrZXMgaXQgbWF0Y2ggd2hhdCB3ZVxuICAgICAgLy8gZG8gaW4gQ29uY3VycmVudCBNb2RlLlxuICAgICAgcHJpbWFyeUNoaWxkRnJhZ21lbnQuYWN0dWFsRHVyYXRpb24gPSAwO1xuICAgICAgcHJpbWFyeUNoaWxkRnJhZ21lbnQuYWN0dWFsU3RhcnRUaW1lID0gLTE7XG4gICAgICBwcmltYXJ5Q2hpbGRGcmFnbWVudC5zZWxmQmFzZUR1cmF0aW9uID0gMDtcbiAgICAgIHByaW1hcnlDaGlsZEZyYWdtZW50LnRyZWVCYXNlRHVyYXRpb24gPSAwO1xuICAgIH1cblxuICAgIGZhbGxiYWNrQ2hpbGRGcmFnbWVudCA9IGNyZWF0ZUZpYmVyRnJvbUZyYWdtZW50KGZhbGxiYWNrQ2hpbGRyZW4sIG1vZGUsIHJlbmRlckxhbmVzLCBudWxsKTtcbiAgfSBlbHNlIHtcbiAgICBwcmltYXJ5Q2hpbGRGcmFnbWVudCA9IGNyZWF0ZUZpYmVyRnJvbU9mZnNjcmVlbihwcmltYXJ5Q2hpbGRQcm9wcywgbW9kZSwgTm9MYW5lcywgbnVsbCk7XG4gICAgZmFsbGJhY2tDaGlsZEZyYWdtZW50ID0gY3JlYXRlRmliZXJGcm9tRnJhZ21lbnQoZmFsbGJhY2tDaGlsZHJlbiwgbW9kZSwgcmVuZGVyTGFuZXMsIG51bGwpO1xuICB9XG5cbiAgcHJpbWFyeUNoaWxkRnJhZ21lbnQucmV0dXJuID0gd29ya0luUHJvZ3Jlc3M7XG4gIGZhbGxiYWNrQ2hpbGRGcmFnbWVudC5yZXR1cm4gPSB3b3JrSW5Qcm9ncmVzcztcbiAgcHJpbWFyeUNoaWxkRnJhZ21lbnQuc2libGluZyA9IGZhbGxiYWNrQ2hpbGRGcmFnbWVudDtcbiAgd29ya0luUHJvZ3Jlc3MuY2hpbGQgPSBwcmltYXJ5Q2hpbGRGcmFnbWVudDtcbiAgcmV0dXJuIGZhbGxiYWNrQ2hpbGRGcmFnbWVudDtcbn1cblxuZnVuY3Rpb24gY3JlYXRlV29ya0luUHJvZ3Jlc3NPZmZzY3JlZW5GaWJlcihjdXJyZW50LCBvZmZzY3JlZW5Qcm9wcykge1xuICAvLyBUaGUgcHJvcHMgYXJndW1lbnQgdG8gYGNyZWF0ZVdvcmtJblByb2dyZXNzYCBpcyBgYW55YCB0eXBlZCwgc28gd2UgdXNlIHRoaXNcbiAgLy8gd3JhcHBlciBmdW5jdGlvbiB0byBjb25zdHJhaW4gaXQuXG4gIHJldHVybiBjcmVhdGVXb3JrSW5Qcm9ncmVzcyhjdXJyZW50LCBvZmZzY3JlZW5Qcm9wcyk7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZVN1c3BlbnNlUHJpbWFyeUNoaWxkcmVuKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBwcmltYXJ5Q2hpbGRyZW4sIHJlbmRlckxhbmVzKSB7XG4gIHZhciBjdXJyZW50UHJpbWFyeUNoaWxkRnJhZ21lbnQgPSBjdXJyZW50LmNoaWxkO1xuICB2YXIgY3VycmVudEZhbGxiYWNrQ2hpbGRGcmFnbWVudCA9IGN1cnJlbnRQcmltYXJ5Q2hpbGRGcmFnbWVudC5zaWJsaW5nO1xuICB2YXIgcHJpbWFyeUNoaWxkRnJhZ21lbnQgPSBjcmVhdGVXb3JrSW5Qcm9ncmVzc09mZnNjcmVlbkZpYmVyKGN1cnJlbnRQcmltYXJ5Q2hpbGRGcmFnbWVudCwge1xuICAgIG1vZGU6ICd2aXNpYmxlJyxcbiAgICBjaGlsZHJlbjogcHJpbWFyeUNoaWxkcmVuXG4gIH0pO1xuXG4gIGlmICgod29ya0luUHJvZ3Jlc3MubW9kZSAmIEJsb2NraW5nTW9kZSkgPT09IE5vTW9kZSkge1xuICAgIHByaW1hcnlDaGlsZEZyYWdtZW50LmxhbmVzID0gcmVuZGVyTGFuZXM7XG4gIH1cblxuICBwcmltYXJ5Q2hpbGRGcmFnbWVudC5yZXR1cm4gPSB3b3JrSW5Qcm9ncmVzcztcbiAgcHJpbWFyeUNoaWxkRnJhZ21lbnQuc2libGluZyA9IG51bGw7XG5cbiAgaWYgKGN1cnJlbnRGYWxsYmFja0NoaWxkRnJhZ21lbnQgIT09IG51bGwpIHtcbiAgICAvLyBEZWxldGUgdGhlIGZhbGxiYWNrIGNoaWxkIGZyYWdtZW50XG4gICAgY3VycmVudEZhbGxiYWNrQ2hpbGRGcmFnbWVudC5uZXh0RWZmZWN0ID0gbnVsbDtcbiAgICBjdXJyZW50RmFsbGJhY2tDaGlsZEZyYWdtZW50LmZsYWdzID0gRGVsZXRpb247XG4gICAgd29ya0luUHJvZ3Jlc3MuZmlyc3RFZmZlY3QgPSB3b3JrSW5Qcm9ncmVzcy5sYXN0RWZmZWN0ID0gY3VycmVudEZhbGxiYWNrQ2hpbGRGcmFnbWVudDtcbiAgfVxuXG4gIHdvcmtJblByb2dyZXNzLmNoaWxkID0gcHJpbWFyeUNoaWxkRnJhZ21lbnQ7XG4gIHJldHVybiBwcmltYXJ5Q2hpbGRGcmFnbWVudDtcbn1cblxuZnVuY3Rpb24gdXBkYXRlU3VzcGVuc2VGYWxsYmFja0NoaWxkcmVuKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBwcmltYXJ5Q2hpbGRyZW4sIGZhbGxiYWNrQ2hpbGRyZW4sIHJlbmRlckxhbmVzKSB7XG4gIHZhciBtb2RlID0gd29ya0luUHJvZ3Jlc3MubW9kZTtcbiAgdmFyIGN1cnJlbnRQcmltYXJ5Q2hpbGRGcmFnbWVudCA9IGN1cnJlbnQuY2hpbGQ7XG4gIHZhciBjdXJyZW50RmFsbGJhY2tDaGlsZEZyYWdtZW50ID0gY3VycmVudFByaW1hcnlDaGlsZEZyYWdtZW50LnNpYmxpbmc7XG4gIHZhciBwcmltYXJ5Q2hpbGRQcm9wcyA9IHtcbiAgICBtb2RlOiAnaGlkZGVuJyxcbiAgICBjaGlsZHJlbjogcHJpbWFyeUNoaWxkcmVuXG4gIH07XG4gIHZhciBwcmltYXJ5Q2hpbGRGcmFnbWVudDtcblxuICBpZiAoIC8vIEluIGxlZ2FjeSBtb2RlLCB3ZSBjb21taXQgdGhlIHByaW1hcnkgdHJlZSBhcyBpZiBpdCBzdWNjZXNzZnVsbHlcbiAgLy8gY29tcGxldGVkLCBldmVuIHRob3VnaCBpdCdzIGluIGFuIGluY29uc2lzdGVudCBzdGF0ZS5cbiAgKG1vZGUgJiBCbG9ja2luZ01vZGUpID09PSBOb01vZGUgJiYgLy8gTWFrZSBzdXJlIHdlJ3JlIG9uIHRoZSBzZWNvbmQgcGFzcywgaS5lLiB0aGUgcHJpbWFyeSBjaGlsZCBmcmFnbWVudCB3YXNcbiAgLy8gYWxyZWFkeSBjbG9uZWQuIEluIGxlZ2FjeSBtb2RlLCB0aGUgb25seSBjYXNlIHdoZXJlIHRoaXMgaXNuJ3QgdHJ1ZSBpc1xuICAvLyB3aGVuIERldlRvb2xzIGZvcmNlcyB1cyB0byBkaXNwbGF5IGEgZmFsbGJhY2s7IHdlIHNraXAgdGhlIGZpcnN0IHJlbmRlclxuICAvLyBwYXNzIGVudGlyZWx5IGFuZCBnbyBzdHJhaWdodCB0byByZW5kZXJpbmcgdGhlIGZhbGxiYWNrLiAoSW4gQ29uY3VycmVudFxuICAvLyBNb2RlLCBTdXNwZW5zZUxpc3QgY2FuIGFsc28gdHJpZ2dlciB0aGlzIHNjZW5hcmlvLCBidXQgdGhpcyBpcyBhIGxlZ2FjeS1cbiAgLy8gb25seSBjb2RlcGF0aC4pXG4gIHdvcmtJblByb2dyZXNzLmNoaWxkICE9PSBjdXJyZW50UHJpbWFyeUNoaWxkRnJhZ21lbnQpIHtcbiAgICB2YXIgcHJvZ3Jlc3NlZFByaW1hcnlGcmFnbWVudCA9IHdvcmtJblByb2dyZXNzLmNoaWxkO1xuICAgIHByaW1hcnlDaGlsZEZyYWdtZW50ID0gcHJvZ3Jlc3NlZFByaW1hcnlGcmFnbWVudDtcbiAgICBwcmltYXJ5Q2hpbGRGcmFnbWVudC5jaGlsZExhbmVzID0gTm9MYW5lcztcbiAgICBwcmltYXJ5Q2hpbGRGcmFnbWVudC5wZW5kaW5nUHJvcHMgPSBwcmltYXJ5Q2hpbGRQcm9wcztcblxuICAgIGlmICggd29ya0luUHJvZ3Jlc3MubW9kZSAmIFByb2ZpbGVNb2RlKSB7XG4gICAgICAvLyBSZXNldCB0aGUgZHVyYXRpb25zIGZyb20gdGhlIGZpcnN0IHBhc3Mgc28gdGhleSBhcmVuJ3QgaW5jbHVkZWQgaW4gdGhlXG4gICAgICAvLyBmaW5hbCBhbW91bnRzLiBUaGlzIHNlZW1zIGNvdW50ZXJpbnR1aXRpdmUsIHNpbmNlIHdlJ3JlIGludGVudGlvbmFsbHlcbiAgICAgIC8vIG5vdCBtZWFzdXJpbmcgcGFydCBvZiB0aGUgcmVuZGVyIHBoYXNlLCBidXQgdGhpcyBtYWtlcyBpdCBtYXRjaCB3aGF0IHdlXG4gICAgICAvLyBkbyBpbiBDb25jdXJyZW50IE1vZGUuXG4gICAgICBwcmltYXJ5Q2hpbGRGcmFnbWVudC5hY3R1YWxEdXJhdGlvbiA9IDA7XG4gICAgICBwcmltYXJ5Q2hpbGRGcmFnbWVudC5hY3R1YWxTdGFydFRpbWUgPSAtMTtcbiAgICAgIHByaW1hcnlDaGlsZEZyYWdtZW50LnNlbGZCYXNlRHVyYXRpb24gPSBjdXJyZW50UHJpbWFyeUNoaWxkRnJhZ21lbnQuc2VsZkJhc2VEdXJhdGlvbjtcbiAgICAgIHByaW1hcnlDaGlsZEZyYWdtZW50LnRyZWVCYXNlRHVyYXRpb24gPSBjdXJyZW50UHJpbWFyeUNoaWxkRnJhZ21lbnQudHJlZUJhc2VEdXJhdGlvbjtcbiAgICB9IC8vIFRoZSBmYWxsYmFjayBmaWJlciB3YXMgYWRkZWQgYXMgYSBkZWxldGlvbiBlZmZlY3QgZHVyaW5nIHRoZSBmaXJzdCBwYXNzLlxuICAgIC8vIEhvd2V2ZXIsIHNpbmNlIHdlJ3JlIGdvaW5nIHRvIHJlbWFpbiBvbiB0aGUgZmFsbGJhY2ssIHdlIG5vIGxvbmdlciB3YW50XG4gICAgLy8gdG8gZGVsZXRlIGl0LiBTbyB3ZSBuZWVkIHRvIHJlbW92ZSBpdCBmcm9tIHRoZSBsaXN0LiBEZWxldGlvbnMgYXJlIHN0b3JlZFxuICAgIC8vIG9uIHRoZSBzYW1lIGxpc3QgYXMgZWZmZWN0cy4gV2Ugd2FudCB0byBrZWVwIHRoZSBlZmZlY3RzIGZyb20gdGhlIHByaW1hcnlcbiAgICAvLyB0cmVlLiBTbyB3ZSBjb3B5IHRoZSBwcmltYXJ5IGNoaWxkIGZyYWdtZW50J3MgZWZmZWN0IGxpc3QsIHdoaWNoIGRvZXMgbm90XG4gICAgLy8gaW5jbHVkZSB0aGUgZmFsbGJhY2sgZGVsZXRpb24gZWZmZWN0LlxuXG5cbiAgICB2YXIgcHJvZ3Jlc3NlZExhc3RFZmZlY3QgPSBwcmltYXJ5Q2hpbGRGcmFnbWVudC5sYXN0RWZmZWN0O1xuXG4gICAgaWYgKHByb2dyZXNzZWRMYXN0RWZmZWN0ICE9PSBudWxsKSB7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5maXJzdEVmZmVjdCA9IHByaW1hcnlDaGlsZEZyYWdtZW50LmZpcnN0RWZmZWN0O1xuICAgICAgd29ya0luUHJvZ3Jlc3MubGFzdEVmZmVjdCA9IHByb2dyZXNzZWRMYXN0RWZmZWN0O1xuICAgICAgcHJvZ3Jlc3NlZExhc3RFZmZlY3QubmV4dEVmZmVjdCA9IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRPRE86IFJlc2V0IHRoaXMgc29tZXdoZXJlIGVsc2U/IExvbCBsZWdhY3kgbW9kZSBpcyBzbyB3ZWlyZC5cbiAgICAgIHdvcmtJblByb2dyZXNzLmZpcnN0RWZmZWN0ID0gd29ya0luUHJvZ3Jlc3MubGFzdEVmZmVjdCA9IG51bGw7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHByaW1hcnlDaGlsZEZyYWdtZW50ID0gY3JlYXRlV29ya0luUHJvZ3Jlc3NPZmZzY3JlZW5GaWJlcihjdXJyZW50UHJpbWFyeUNoaWxkRnJhZ21lbnQsIHByaW1hcnlDaGlsZFByb3BzKTtcbiAgfVxuXG4gIHZhciBmYWxsYmFja0NoaWxkRnJhZ21lbnQ7XG5cbiAgaWYgKGN1cnJlbnRGYWxsYmFja0NoaWxkRnJhZ21lbnQgIT09IG51bGwpIHtcbiAgICBmYWxsYmFja0NoaWxkRnJhZ21lbnQgPSBjcmVhdGVXb3JrSW5Qcm9ncmVzcyhjdXJyZW50RmFsbGJhY2tDaGlsZEZyYWdtZW50LCBmYWxsYmFja0NoaWxkcmVuKTtcbiAgfSBlbHNlIHtcbiAgICBmYWxsYmFja0NoaWxkRnJhZ21lbnQgPSBjcmVhdGVGaWJlckZyb21GcmFnbWVudChmYWxsYmFja0NoaWxkcmVuLCBtb2RlLCByZW5kZXJMYW5lcywgbnVsbCk7IC8vIE5lZWRzIGEgcGxhY2VtZW50IGVmZmVjdCBiZWNhdXNlIHRoZSBwYXJlbnQgKHRoZSBTdXNwZW5zZSBib3VuZGFyeSkgYWxyZWFkeVxuICAgIC8vIG1vdW50ZWQgYnV0IHRoaXMgaXMgYSBuZXcgZmliZXIuXG5cbiAgICBmYWxsYmFja0NoaWxkRnJhZ21lbnQuZmxhZ3MgfD0gUGxhY2VtZW50O1xuICB9XG5cbiAgZmFsbGJhY2tDaGlsZEZyYWdtZW50LnJldHVybiA9IHdvcmtJblByb2dyZXNzO1xuICBwcmltYXJ5Q2hpbGRGcmFnbWVudC5yZXR1cm4gPSB3b3JrSW5Qcm9ncmVzcztcbiAgcHJpbWFyeUNoaWxkRnJhZ21lbnQuc2libGluZyA9IGZhbGxiYWNrQ2hpbGRGcmFnbWVudDtcbiAgd29ya0luUHJvZ3Jlc3MuY2hpbGQgPSBwcmltYXJ5Q2hpbGRGcmFnbWVudDtcbiAgcmV0dXJuIGZhbGxiYWNrQ2hpbGRGcmFnbWVudDtcbn1cblxuZnVuY3Rpb24gc2NoZWR1bGVXb3JrT25GaWJlcihmaWJlciwgcmVuZGVyTGFuZXMpIHtcbiAgZmliZXIubGFuZXMgPSBtZXJnZUxhbmVzKGZpYmVyLmxhbmVzLCByZW5kZXJMYW5lcyk7XG4gIHZhciBhbHRlcm5hdGUgPSBmaWJlci5hbHRlcm5hdGU7XG5cbiAgaWYgKGFsdGVybmF0ZSAhPT0gbnVsbCkge1xuICAgIGFsdGVybmF0ZS5sYW5lcyA9IG1lcmdlTGFuZXMoYWx0ZXJuYXRlLmxhbmVzLCByZW5kZXJMYW5lcyk7XG4gIH1cblxuICBzY2hlZHVsZVdvcmtPblBhcmVudFBhdGgoZmliZXIucmV0dXJuLCByZW5kZXJMYW5lcyk7XG59XG5cbmZ1bmN0aW9uIHByb3BhZ2F0ZVN1c3BlbnNlQ29udGV4dENoYW5nZSh3b3JrSW5Qcm9ncmVzcywgZmlyc3RDaGlsZCwgcmVuZGVyTGFuZXMpIHtcbiAgLy8gTWFyayBhbnkgU3VzcGVuc2UgYm91bmRhcmllcyB3aXRoIGZhbGxiYWNrcyBhcyBoYXZpbmcgd29yayB0byBkby5cbiAgLy8gSWYgdGhleSB3ZXJlIHByZXZpb3VzbHkgZm9yY2VkIGludG8gZmFsbGJhY2tzLCB0aGV5IG1heSBub3cgYmUgYWJsZVxuICAvLyB0byB1bmJsb2NrLlxuICB2YXIgbm9kZSA9IGZpcnN0Q2hpbGQ7XG5cbiAgd2hpbGUgKG5vZGUgIT09IG51bGwpIHtcbiAgICBpZiAobm9kZS50YWcgPT09IFN1c3BlbnNlQ29tcG9uZW50KSB7XG4gICAgICB2YXIgc3RhdGUgPSBub2RlLm1lbW9pemVkU3RhdGU7XG5cbiAgICAgIGlmIChzdGF0ZSAhPT0gbnVsbCkge1xuICAgICAgICBzY2hlZHVsZVdvcmtPbkZpYmVyKG5vZGUsIHJlbmRlckxhbmVzKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG5vZGUudGFnID09PSBTdXNwZW5zZUxpc3RDb21wb25lbnQpIHtcbiAgICAgIC8vIElmIHRoZSB0YWlsIGlzIGhpZGRlbiB0aGVyZSBtaWdodCBub3QgYmUgYW4gU3VzcGVuc2UgYm91bmRhcmllc1xuICAgICAgLy8gdG8gc2NoZWR1bGUgd29yayBvbi4gSW4gdGhpcyBjYXNlIHdlIGhhdmUgdG8gc2NoZWR1bGUgaXQgb24gdGhlXG4gICAgICAvLyBsaXN0IGl0c2VsZi5cbiAgICAgIC8vIFdlIGRvbid0IGhhdmUgdG8gdHJhdmVyc2UgdG8gdGhlIGNoaWxkcmVuIG9mIHRoZSBsaXN0IHNpbmNlXG4gICAgICAvLyB0aGUgbGlzdCB3aWxsIHByb3BhZ2F0ZSB0aGUgY2hhbmdlIHdoZW4gaXQgcmVyZW5kZXJzLlxuICAgICAgc2NoZWR1bGVXb3JrT25GaWJlcihub2RlLCByZW5kZXJMYW5lcyk7XG4gICAgfSBlbHNlIGlmIChub2RlLmNoaWxkICE9PSBudWxsKSB7XG4gICAgICBub2RlLmNoaWxkLnJldHVybiA9IG5vZGU7XG4gICAgICBub2RlID0gbm9kZS5jaGlsZDtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmIChub2RlID09PSB3b3JrSW5Qcm9ncmVzcykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHdoaWxlIChub2RlLnNpYmxpbmcgPT09IG51bGwpIHtcbiAgICAgIGlmIChub2RlLnJldHVybiA9PT0gbnVsbCB8fCBub2RlLnJldHVybiA9PT0gd29ya0luUHJvZ3Jlc3MpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBub2RlID0gbm9kZS5yZXR1cm47XG4gICAgfVxuXG4gICAgbm9kZS5zaWJsaW5nLnJldHVybiA9IG5vZGUucmV0dXJuO1xuICAgIG5vZGUgPSBub2RlLnNpYmxpbmc7XG4gIH1cbn1cblxuZnVuY3Rpb24gZmluZExhc3RDb250ZW50Um93KGZpcnN0Q2hpbGQpIHtcbiAgLy8gVGhpcyBpcyBnb2luZyB0byBmaW5kIHRoZSBsYXN0IHJvdyBhbW9uZyB0aGVzZSBjaGlsZHJlbiB0aGF0IGlzIGFscmVhZHlcbiAgLy8gc2hvd2luZyBjb250ZW50IG9uIHRoZSBzY3JlZW4sIGFzIG9wcG9zZWQgdG8gYmVpbmcgaW4gZmFsbGJhY2sgc3RhdGUgb3JcbiAgLy8gbmV3LiBJZiBhIHJvdyBoYXMgbXVsdGlwbGUgU3VzcGVuc2UgYm91bmRhcmllcywgYW55IG9mIHRoZW0gYmVpbmcgaW4gdGhlXG4gIC8vIGZhbGxiYWNrIHN0YXRlLCBjb3VudHMgYXMgdGhlIHdob2xlIHJvdyBiZWluZyBpbiBhIGZhbGxiYWNrIHN0YXRlLlxuICAvLyBOb3RlIHRoYXQgdGhlIFwicm93c1wiIHdpbGwgYmUgd29ya0luUHJvZ3Jlc3MsIGJ1dCBhbnkgbmVzdGVkIGNoaWxkcmVuXG4gIC8vIHdpbGwgc3RpbGwgYmUgY3VycmVudCBzaW5jZSB3ZSBoYXZlbid0IHJlbmRlcmVkIHRoZW0geWV0LiBUaGUgbW91bnRlZFxuICAvLyBvcmRlciBtYXkgbm90IGJlIHRoZSBzYW1lIGFzIHRoZSBuZXcgb3JkZXIuIFdlIHVzZSB0aGUgbmV3IG9yZGVyLlxuICB2YXIgcm93ID0gZmlyc3RDaGlsZDtcbiAgdmFyIGxhc3RDb250ZW50Um93ID0gbnVsbDtcblxuICB3aGlsZSAocm93ICE9PSBudWxsKSB7XG4gICAgdmFyIGN1cnJlbnRSb3cgPSByb3cuYWx0ZXJuYXRlOyAvLyBOZXcgcm93cyBjYW4ndCBiZSBjb250ZW50IHJvd3MuXG5cbiAgICBpZiAoY3VycmVudFJvdyAhPT0gbnVsbCAmJiBmaW5kRmlyc3RTdXNwZW5kZWQoY3VycmVudFJvdykgPT09IG51bGwpIHtcbiAgICAgIGxhc3RDb250ZW50Um93ID0gcm93O1xuICAgIH1cblxuICAgIHJvdyA9IHJvdy5zaWJsaW5nO1xuICB9XG5cbiAgcmV0dXJuIGxhc3RDb250ZW50Um93O1xufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZVJldmVhbE9yZGVyKHJldmVhbE9yZGVyKSB7XG4gIHtcbiAgICBpZiAocmV2ZWFsT3JkZXIgIT09IHVuZGVmaW5lZCAmJiByZXZlYWxPcmRlciAhPT0gJ2ZvcndhcmRzJyAmJiByZXZlYWxPcmRlciAhPT0gJ2JhY2t3YXJkcycgJiYgcmV2ZWFsT3JkZXIgIT09ICd0b2dldGhlcicgJiYgIWRpZFdhcm5BYm91dFJldmVhbE9yZGVyW3JldmVhbE9yZGVyXSkge1xuICAgICAgZGlkV2FybkFib3V0UmV2ZWFsT3JkZXJbcmV2ZWFsT3JkZXJdID0gdHJ1ZTtcblxuICAgICAgaWYgKHR5cGVvZiByZXZlYWxPcmRlciA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgc3dpdGNoIChyZXZlYWxPcmRlci50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICAgICAgY2FzZSAndG9nZXRoZXInOlxuICAgICAgICAgIGNhc2UgJ2ZvcndhcmRzJzpcbiAgICAgICAgICBjYXNlICdiYWNrd2FyZHMnOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBlcnJvcignXCIlc1wiIGlzIG5vdCBhIHZhbGlkIHZhbHVlIGZvciByZXZlYWxPcmRlciBvbiA8U3VzcGVuc2VMaXN0IC8+LiAnICsgJ1VzZSBsb3dlcmNhc2UgXCIlc1wiIGluc3RlYWQuJywgcmV2ZWFsT3JkZXIsIHJldmVhbE9yZGVyLnRvTG93ZXJDYXNlKCkpO1xuXG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgY2FzZSAnZm9yd2FyZCc6XG4gICAgICAgICAgY2FzZSAnYmFja3dhcmQnOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBlcnJvcignXCIlc1wiIGlzIG5vdCBhIHZhbGlkIHZhbHVlIGZvciByZXZlYWxPcmRlciBvbiA8U3VzcGVuc2VMaXN0IC8+LiAnICsgJ1JlYWN0IHVzZXMgdGhlIC1zIHN1ZmZpeCBpbiB0aGUgc3BlbGxpbmcuIFVzZSBcIiVzc1wiIGluc3RlYWQuJywgcmV2ZWFsT3JkZXIsIHJldmVhbE9yZGVyLnRvTG93ZXJDYXNlKCkpO1xuXG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGVycm9yKCdcIiVzXCIgaXMgbm90IGEgc3VwcG9ydGVkIHJldmVhbE9yZGVyIG9uIDxTdXNwZW5zZUxpc3QgLz4uICcgKyAnRGlkIHlvdSBtZWFuIFwidG9nZXRoZXJcIiwgXCJmb3J3YXJkc1wiIG9yIFwiYmFja3dhcmRzXCI/JywgcmV2ZWFsT3JkZXIpO1xuXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZXJyb3IoJyVzIGlzIG5vdCBhIHN1cHBvcnRlZCB2YWx1ZSBmb3IgcmV2ZWFsT3JkZXIgb24gPFN1c3BlbnNlTGlzdCAvPi4gJyArICdEaWQgeW91IG1lYW4gXCJ0b2dldGhlclwiLCBcImZvcndhcmRzXCIgb3IgXCJiYWNrd2FyZHNcIj8nLCByZXZlYWxPcmRlcik7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlVGFpbE9wdGlvbnModGFpbE1vZGUsIHJldmVhbE9yZGVyKSB7XG4gIHtcbiAgICBpZiAodGFpbE1vZGUgIT09IHVuZGVmaW5lZCAmJiAhZGlkV2FybkFib3V0VGFpbE9wdGlvbnNbdGFpbE1vZGVdKSB7XG4gICAgICBpZiAodGFpbE1vZGUgIT09ICdjb2xsYXBzZWQnICYmIHRhaWxNb2RlICE9PSAnaGlkZGVuJykge1xuICAgICAgICBkaWRXYXJuQWJvdXRUYWlsT3B0aW9uc1t0YWlsTW9kZV0gPSB0cnVlO1xuXG4gICAgICAgIGVycm9yKCdcIiVzXCIgaXMgbm90IGEgc3VwcG9ydGVkIHZhbHVlIGZvciB0YWlsIG9uIDxTdXNwZW5zZUxpc3QgLz4uICcgKyAnRGlkIHlvdSBtZWFuIFwiY29sbGFwc2VkXCIgb3IgXCJoaWRkZW5cIj8nLCB0YWlsTW9kZSk7XG4gICAgICB9IGVsc2UgaWYgKHJldmVhbE9yZGVyICE9PSAnZm9yd2FyZHMnICYmIHJldmVhbE9yZGVyICE9PSAnYmFja3dhcmRzJykge1xuICAgICAgICBkaWRXYXJuQWJvdXRUYWlsT3B0aW9uc1t0YWlsTW9kZV0gPSB0cnVlO1xuXG4gICAgICAgIGVycm9yKCc8U3VzcGVuc2VMaXN0IHRhaWw9XCIlc1wiIC8+IGlzIG9ubHkgdmFsaWQgaWYgcmV2ZWFsT3JkZXIgaXMgJyArICdcImZvcndhcmRzXCIgb3IgXCJiYWNrd2FyZHNcIi4gJyArICdEaWQgeW91IG1lYW4gdG8gc3BlY2lmeSByZXZlYWxPcmRlcj1cImZvcndhcmRzXCI/JywgdGFpbE1vZGUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZVN1c3BlbnNlTGlzdE5lc3RlZENoaWxkKGNoaWxkU2xvdCwgaW5kZXgpIHtcbiAge1xuICAgIHZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheShjaGlsZFNsb3QpO1xuICAgIHZhciBpc0l0ZXJhYmxlID0gIWlzQXJyYXkgJiYgdHlwZW9mIGdldEl0ZXJhdG9yRm4oY2hpbGRTbG90KSA9PT0gJ2Z1bmN0aW9uJztcblxuICAgIGlmIChpc0FycmF5IHx8IGlzSXRlcmFibGUpIHtcbiAgICAgIHZhciB0eXBlID0gaXNBcnJheSA/ICdhcnJheScgOiAnaXRlcmFibGUnO1xuXG4gICAgICBlcnJvcignQSBuZXN0ZWQgJXMgd2FzIHBhc3NlZCB0byByb3cgIyVzIGluIDxTdXNwZW5zZUxpc3QgLz4uIFdyYXAgaXQgaW4gJyArICdhbiBhZGRpdGlvbmFsIFN1c3BlbnNlTGlzdCB0byBjb25maWd1cmUgaXRzIHJldmVhbE9yZGVyOiAnICsgJzxTdXNwZW5zZUxpc3QgcmV2ZWFsT3JkZXI9Li4uPiAuLi4gJyArICc8U3VzcGVuc2VMaXN0IHJldmVhbE9yZGVyPS4uLj57JXN9PC9TdXNwZW5zZUxpc3Q+IC4uLiAnICsgJzwvU3VzcGVuc2VMaXN0PicsIHR5cGUsIGluZGV4LCB0eXBlKTtcblxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZVN1c3BlbnNlTGlzdENoaWxkcmVuKGNoaWxkcmVuLCByZXZlYWxPcmRlcikge1xuICB7XG4gICAgaWYgKChyZXZlYWxPcmRlciA9PT0gJ2ZvcndhcmRzJyB8fCByZXZlYWxPcmRlciA9PT0gJ2JhY2t3YXJkcycpICYmIGNoaWxkcmVuICE9PSB1bmRlZmluZWQgJiYgY2hpbGRyZW4gIT09IG51bGwgJiYgY2hpbGRyZW4gIT09IGZhbHNlKSB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShjaGlsZHJlbikpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmICghdmFsaWRhdGVTdXNwZW5zZUxpc3ROZXN0ZWRDaGlsZChjaGlsZHJlbltpXSwgaSkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBpdGVyYXRvckZuID0gZ2V0SXRlcmF0b3JGbihjaGlsZHJlbik7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBpdGVyYXRvckZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgdmFyIGNoaWxkcmVuSXRlcmF0b3IgPSBpdGVyYXRvckZuLmNhbGwoY2hpbGRyZW4pO1xuXG4gICAgICAgICAgaWYgKGNoaWxkcmVuSXRlcmF0b3IpIHtcbiAgICAgICAgICAgIHZhciBzdGVwID0gY2hpbGRyZW5JdGVyYXRvci5uZXh0KCk7XG4gICAgICAgICAgICB2YXIgX2kgPSAwO1xuXG4gICAgICAgICAgICBmb3IgKDsgIXN0ZXAuZG9uZTsgc3RlcCA9IGNoaWxkcmVuSXRlcmF0b3IubmV4dCgpKSB7XG4gICAgICAgICAgICAgIGlmICghdmFsaWRhdGVTdXNwZW5zZUxpc3ROZXN0ZWRDaGlsZChzdGVwLnZhbHVlLCBfaSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBfaSsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBlcnJvcignQSBzaW5nbGUgcm93IHdhcyBwYXNzZWQgdG8gYSA8U3VzcGVuc2VMaXN0IHJldmVhbE9yZGVyPVwiJXNcIiAvPi4gJyArICdUaGlzIGlzIG5vdCB1c2VmdWwgc2luY2UgaXQgbmVlZHMgbXVsdGlwbGUgcm93cy4gJyArICdEaWQgeW91IG1lYW4gdG8gcGFzcyBtdWx0aXBsZSBjaGlsZHJlbiBvciBhbiBhcnJheT8nLCByZXZlYWxPcmRlcik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5pdFN1c3BlbnNlTGlzdFJlbmRlclN0YXRlKHdvcmtJblByb2dyZXNzLCBpc0JhY2t3YXJkcywgdGFpbCwgbGFzdENvbnRlbnRSb3csIHRhaWxNb2RlLCBsYXN0RWZmZWN0QmVmb3JlUmVuZGVyaW5nKSB7XG4gIHZhciByZW5kZXJTdGF0ZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG5cbiAgaWYgKHJlbmRlclN0YXRlID09PSBudWxsKSB7XG4gICAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IHtcbiAgICAgIGlzQmFja3dhcmRzOiBpc0JhY2t3YXJkcyxcbiAgICAgIHJlbmRlcmluZzogbnVsbCxcbiAgICAgIHJlbmRlcmluZ1N0YXJ0VGltZTogMCxcbiAgICAgIGxhc3Q6IGxhc3RDb250ZW50Um93LFxuICAgICAgdGFpbDogdGFpbCxcbiAgICAgIHRhaWxNb2RlOiB0YWlsTW9kZSxcbiAgICAgIGxhc3RFZmZlY3Q6IGxhc3RFZmZlY3RCZWZvcmVSZW5kZXJpbmdcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIC8vIFdlIGNhbiByZXVzZSB0aGUgZXhpc3Rpbmcgb2JqZWN0IGZyb20gcHJldmlvdXMgcmVuZGVycy5cbiAgICByZW5kZXJTdGF0ZS5pc0JhY2t3YXJkcyA9IGlzQmFja3dhcmRzO1xuICAgIHJlbmRlclN0YXRlLnJlbmRlcmluZyA9IG51bGw7XG4gICAgcmVuZGVyU3RhdGUucmVuZGVyaW5nU3RhcnRUaW1lID0gMDtcbiAgICByZW5kZXJTdGF0ZS5sYXN0ID0gbGFzdENvbnRlbnRSb3c7XG4gICAgcmVuZGVyU3RhdGUudGFpbCA9IHRhaWw7XG4gICAgcmVuZGVyU3RhdGUudGFpbE1vZGUgPSB0YWlsTW9kZTtcbiAgICByZW5kZXJTdGF0ZS5sYXN0RWZmZWN0ID0gbGFzdEVmZmVjdEJlZm9yZVJlbmRlcmluZztcbiAgfVxufSAvLyBUaGlzIGNhbiBlbmQgdXAgcmVuZGVyaW5nIHRoaXMgY29tcG9uZW50IG11bHRpcGxlIHBhc3Nlcy5cbi8vIFRoZSBmaXJzdCBwYXNzIHNwbGl0cyB0aGUgY2hpbGRyZW4gZmliZXJzIGludG8gdHdvIHNldHMuIEEgaGVhZCBhbmQgdGFpbC5cbi8vIFdlIGZpcnN0IHJlbmRlciB0aGUgaGVhZC4gSWYgYW55dGhpbmcgaXMgaW4gZmFsbGJhY2sgc3RhdGUsIHdlIGRvIGFub3RoZXJcbi8vIHBhc3MgdGhyb3VnaCBiZWdpbldvcmsgdG8gcmVyZW5kZXIgYWxsIGNoaWxkcmVuIChpbmNsdWRpbmcgdGhlIHRhaWwpIHdpdGhcbi8vIHRoZSBmb3JjZSBzdXNwZW5kIGNvbnRleHQuIElmIHRoZSBmaXJzdCByZW5kZXIgZGlkbid0IGhhdmUgYW55dGhpbmcgaW5cbi8vIGluIGZhbGxiYWNrIHN0YXRlLiBUaGVuIHdlIHJlbmRlciBlYWNoIHJvdyBpbiB0aGUgdGFpbCBvbmUtYnktb25lLlxuLy8gVGhhdCBoYXBwZW5zIGluIHRoZSBjb21wbGV0ZVdvcmsgcGhhc2Ugd2l0aG91dCBnb2luZyBiYWNrIHRvIGJlZ2luV29yay5cblxuXG5mdW5jdGlvbiB1cGRhdGVTdXNwZW5zZUxpc3RDb21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKSB7XG4gIHZhciBuZXh0UHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7XG4gIHZhciByZXZlYWxPcmRlciA9IG5leHRQcm9wcy5yZXZlYWxPcmRlcjtcbiAgdmFyIHRhaWxNb2RlID0gbmV4dFByb3BzLnRhaWw7XG4gIHZhciBuZXdDaGlsZHJlbiA9IG5leHRQcm9wcy5jaGlsZHJlbjtcbiAgdmFsaWRhdGVSZXZlYWxPcmRlcihyZXZlYWxPcmRlcik7XG4gIHZhbGlkYXRlVGFpbE9wdGlvbnModGFpbE1vZGUsIHJldmVhbE9yZGVyKTtcbiAgdmFsaWRhdGVTdXNwZW5zZUxpc3RDaGlsZHJlbihuZXdDaGlsZHJlbiwgcmV2ZWFsT3JkZXIpO1xuICByZWNvbmNpbGVDaGlsZHJlbihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbmV3Q2hpbGRyZW4sIHJlbmRlckxhbmVzKTtcbiAgdmFyIHN1c3BlbnNlQ29udGV4dCA9IHN1c3BlbnNlU3RhY2tDdXJzb3IuY3VycmVudDtcbiAgdmFyIHNob3VsZEZvcmNlRmFsbGJhY2sgPSBoYXNTdXNwZW5zZUNvbnRleHQoc3VzcGVuc2VDb250ZXh0LCBGb3JjZVN1c3BlbnNlRmFsbGJhY2spO1xuXG4gIGlmIChzaG91bGRGb3JjZUZhbGxiYWNrKSB7XG4gICAgc3VzcGVuc2VDb250ZXh0ID0gc2V0U2hhbGxvd1N1c3BlbnNlQ29udGV4dChzdXNwZW5zZUNvbnRleHQsIEZvcmNlU3VzcGVuc2VGYWxsYmFjayk7XG4gICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gRGlkQ2FwdHVyZTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgZGlkU3VzcGVuZEJlZm9yZSA9IGN1cnJlbnQgIT09IG51bGwgJiYgKGN1cnJlbnQuZmxhZ3MgJiBEaWRDYXB0dXJlKSAhPT0gTm9GbGFncztcblxuICAgIGlmIChkaWRTdXNwZW5kQmVmb3JlKSB7XG4gICAgICAvLyBJZiB3ZSBwcmV2aW91c2x5IGZvcmNlZCBhIGZhbGxiYWNrLCB3ZSBuZWVkIHRvIHNjaGVkdWxlIHdvcmtcbiAgICAgIC8vIG9uIGFueSBuZXN0ZWQgYm91bmRhcmllcyB0byBsZXQgdGhlbSBrbm93IHRvIHRyeSB0byByZW5kZXJcbiAgICAgIC8vIGFnYWluLiBUaGlzIGlzIHRoZSBzYW1lIGFzIGNvbnRleHQgdXBkYXRpbmcuXG4gICAgICBwcm9wYWdhdGVTdXNwZW5zZUNvbnRleHRDaGFuZ2Uod29ya0luUHJvZ3Jlc3MsIHdvcmtJblByb2dyZXNzLmNoaWxkLCByZW5kZXJMYW5lcyk7XG4gICAgfVxuXG4gICAgc3VzcGVuc2VDb250ZXh0ID0gc2V0RGVmYXVsdFNoYWxsb3dTdXNwZW5zZUNvbnRleHQoc3VzcGVuc2VDb250ZXh0KTtcbiAgfVxuXG4gIHB1c2hTdXNwZW5zZUNvbnRleHQod29ya0luUHJvZ3Jlc3MsIHN1c3BlbnNlQ29udGV4dCk7XG5cbiAgaWYgKCh3b3JrSW5Qcm9ncmVzcy5tb2RlICYgQmxvY2tpbmdNb2RlKSA9PT0gTm9Nb2RlKSB7XG4gICAgLy8gSW4gbGVnYWN5IG1vZGUsIFN1c3BlbnNlTGlzdCBkb2Vzbid0IHdvcmsgc28gd2UganVzdFxuICAgIC8vIHVzZSBtYWtlIGl0IGEgbm9vcCBieSB0cmVhdGluZyBpdCBhcyB0aGUgZGVmYXVsdCByZXZlYWxPcmRlci5cbiAgICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0gbnVsbDtcbiAgfSBlbHNlIHtcbiAgICBzd2l0Y2ggKHJldmVhbE9yZGVyKSB7XG4gICAgICBjYXNlICdmb3J3YXJkcyc6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgbGFzdENvbnRlbnRSb3cgPSBmaW5kTGFzdENvbnRlbnRSb3cod29ya0luUHJvZ3Jlc3MuY2hpbGQpO1xuICAgICAgICAgIHZhciB0YWlsO1xuXG4gICAgICAgICAgaWYgKGxhc3RDb250ZW50Um93ID09PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBUaGUgd2hvbGUgbGlzdCBpcyBwYXJ0IG9mIHRoZSB0YWlsLlxuICAgICAgICAgICAgLy8gVE9ETzogV2UgY291bGQgZmFzdCBwYXRoIGJ5IGp1c3QgcmVuZGVyaW5nIHRoZSB0YWlsIG5vdy5cbiAgICAgICAgICAgIHRhaWwgPSB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLmNoaWxkID0gbnVsbDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gRGlzY29ubmVjdCB0aGUgdGFpbCByb3dzIGFmdGVyIHRoZSBjb250ZW50IHJvdy5cbiAgICAgICAgICAgIC8vIFdlJ3JlIGdvaW5nIHRvIHJlbmRlciB0aGVtIHNlcGFyYXRlbHkgbGF0ZXIuXG4gICAgICAgICAgICB0YWlsID0gbGFzdENvbnRlbnRSb3cuc2libGluZztcbiAgICAgICAgICAgIGxhc3RDb250ZW50Um93LnNpYmxpbmcgPSBudWxsO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGluaXRTdXNwZW5zZUxpc3RSZW5kZXJTdGF0ZSh3b3JrSW5Qcm9ncmVzcywgZmFsc2UsIC8vIGlzQmFja3dhcmRzXG4gICAgICAgICAgdGFpbCwgbGFzdENvbnRlbnRSb3csIHRhaWxNb2RlLCB3b3JrSW5Qcm9ncmVzcy5sYXN0RWZmZWN0KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICBjYXNlICdiYWNrd2FyZHMnOlxuICAgICAgICB7XG4gICAgICAgICAgLy8gV2UncmUgZ29pbmcgdG8gZmluZCB0aGUgZmlyc3Qgcm93IHRoYXQgaGFzIGV4aXN0aW5nIGNvbnRlbnQuXG4gICAgICAgICAgLy8gQXQgdGhlIHNhbWUgdGltZSB3ZSdyZSBnb2luZyB0byByZXZlcnNlIHRoZSBsaXN0IG9mIGV2ZXJ5dGhpbmdcbiAgICAgICAgICAvLyB3ZSBwYXNzIGluIHRoZSBtZWFudGltZS4gVGhhdCdzIGdvaW5nIHRvIGJlIG91ciB0YWlsIGluIHJldmVyc2VcbiAgICAgICAgICAvLyBvcmRlci5cbiAgICAgICAgICB2YXIgX3RhaWwgPSBudWxsO1xuICAgICAgICAgIHZhciByb3cgPSB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IG51bGw7XG5cbiAgICAgICAgICB3aGlsZSAocm93ICE9PSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgY3VycmVudFJvdyA9IHJvdy5hbHRlcm5hdGU7IC8vIE5ldyByb3dzIGNhbid0IGJlIGNvbnRlbnQgcm93cy5cblxuICAgICAgICAgICAgaWYgKGN1cnJlbnRSb3cgIT09IG51bGwgJiYgZmluZEZpcnN0U3VzcGVuZGVkKGN1cnJlbnRSb3cpID09PSBudWxsKSB7XG4gICAgICAgICAgICAgIC8vIFRoaXMgaXMgdGhlIGJlZ2lubmluZyBvZiB0aGUgbWFpbiBjb250ZW50LlxuICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IHJvdztcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBuZXh0Um93ID0gcm93LnNpYmxpbmc7XG4gICAgICAgICAgICByb3cuc2libGluZyA9IF90YWlsO1xuICAgICAgICAgICAgX3RhaWwgPSByb3c7XG4gICAgICAgICAgICByb3cgPSBuZXh0Um93O1xuICAgICAgICAgIH0gLy8gVE9ETzogSWYgd29ya0luUHJvZ3Jlc3MuY2hpbGQgaXMgbnVsbCwgd2UgY2FuIGNvbnRpbnVlIG9uIHRoZSB0YWlsIGltbWVkaWF0ZWx5LlxuXG5cbiAgICAgICAgICBpbml0U3VzcGVuc2VMaXN0UmVuZGVyU3RhdGUod29ya0luUHJvZ3Jlc3MsIHRydWUsIC8vIGlzQmFja3dhcmRzXG4gICAgICAgICAgX3RhaWwsIG51bGwsIC8vIGxhc3RcbiAgICAgICAgICB0YWlsTW9kZSwgd29ya0luUHJvZ3Jlc3MubGFzdEVmZmVjdCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSAndG9nZXRoZXInOlxuICAgICAgICB7XG4gICAgICAgICAgaW5pdFN1c3BlbnNlTGlzdFJlbmRlclN0YXRlKHdvcmtJblByb2dyZXNzLCBmYWxzZSwgLy8gaXNCYWNrd2FyZHNcbiAgICAgICAgICBudWxsLCAvLyB0YWlsXG4gICAgICAgICAgbnVsbCwgLy8gbGFzdFxuICAgICAgICAgIHVuZGVmaW5lZCwgd29ya0luUHJvZ3Jlc3MubGFzdEVmZmVjdCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAge1xuICAgICAgICAgIC8vIFRoZSBkZWZhdWx0IHJldmVhbCBvcmRlciBpcyB0aGUgc2FtZSBhcyBub3QgaGF2aW5nXG4gICAgICAgICAgLy8gYSBib3VuZGFyeS5cbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbn1cblxuZnVuY3Rpb24gdXBkYXRlUG9ydGFsQ29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcykge1xuICBwdXNoSG9zdENvbnRhaW5lcih3b3JrSW5Qcm9ncmVzcywgd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlLmNvbnRhaW5lckluZm8pO1xuICB2YXIgbmV4dENoaWxkcmVuID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO1xuXG4gIGlmIChjdXJyZW50ID09PSBudWxsKSB7XG4gICAgLy8gUG9ydGFscyBhcmUgc3BlY2lhbCBiZWNhdXNlIHdlIGRvbid0IGFwcGVuZCB0aGUgY2hpbGRyZW4gZHVyaW5nIG1vdW50XG4gICAgLy8gYnV0IGF0IGNvbW1pdC4gVGhlcmVmb3JlIHdlIG5lZWQgdG8gdHJhY2sgaW5zZXJ0aW9ucyB3aGljaCB0aGUgbm9ybWFsXG4gICAgLy8gZmxvdyBkb2Vzbid0IGRvIGR1cmluZyBtb3VudC4gVGhpcyBkb2Vzbid0IGhhcHBlbiBhdCB0aGUgcm9vdCBiZWNhdXNlXG4gICAgLy8gdGhlIHJvb3QgYWx3YXlzIHN0YXJ0cyB3aXRoIGEgXCJjdXJyZW50XCIgd2l0aCBhIG51bGwgY2hpbGQuXG4gICAgLy8gVE9ETzogQ29uc2lkZXIgdW5pZnlpbmcgdGhpcyB3aXRoIGhvdyB0aGUgcm9vdCB3b3Jrcy5cbiAgICB3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IHJlY29uY2lsZUNoaWxkRmliZXJzKHdvcmtJblByb2dyZXNzLCBudWxsLCBuZXh0Q2hpbGRyZW4sIHJlbmRlckxhbmVzKTtcbiAgfSBlbHNlIHtcbiAgICByZWNvbmNpbGVDaGlsZHJlbihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbmV4dENoaWxkcmVuLCByZW5kZXJMYW5lcyk7XG4gIH1cblxuICByZXR1cm4gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG59XG5cbnZhciBoYXNXYXJuZWRBYm91dFVzaW5nTm9WYWx1ZVByb3BPbkNvbnRleHRQcm92aWRlciA9IGZhbHNlO1xuXG5mdW5jdGlvbiB1cGRhdGVDb250ZXh0UHJvdmlkZXIoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKSB7XG4gIHZhciBwcm92aWRlclR5cGUgPSB3b3JrSW5Qcm9ncmVzcy50eXBlO1xuICB2YXIgY29udGV4dCA9IHByb3ZpZGVyVHlwZS5fY29udGV4dDtcbiAgdmFyIG5ld1Byb3BzID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO1xuICB2YXIgb2xkUHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFByb3BzO1xuICB2YXIgbmV3VmFsdWUgPSBuZXdQcm9wcy52YWx1ZTtcblxuICB7XG4gICAgaWYgKCEoJ3ZhbHVlJyBpbiBuZXdQcm9wcykpIHtcbiAgICAgIGlmICghaGFzV2FybmVkQWJvdXRVc2luZ05vVmFsdWVQcm9wT25Db250ZXh0UHJvdmlkZXIpIHtcbiAgICAgICAgaGFzV2FybmVkQWJvdXRVc2luZ05vVmFsdWVQcm9wT25Db250ZXh0UHJvdmlkZXIgPSB0cnVlO1xuXG4gICAgICAgIGVycm9yKCdUaGUgYHZhbHVlYCBwcm9wIGlzIHJlcXVpcmVkIGZvciB0aGUgYDxDb250ZXh0LlByb3ZpZGVyPmAuIERpZCB5b3UgbWlzc3BlbGwgaXQgb3IgZm9yZ2V0IHRvIHBhc3MgaXQ/Jyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHByb3ZpZGVyUHJvcFR5cGVzID0gd29ya0luUHJvZ3Jlc3MudHlwZS5wcm9wVHlwZXM7XG5cbiAgICBpZiAocHJvdmlkZXJQcm9wVHlwZXMpIHtcbiAgICAgIGNoZWNrUHJvcFR5cGVzKHByb3ZpZGVyUHJvcFR5cGVzLCBuZXdQcm9wcywgJ3Byb3AnLCAnQ29udGV4dC5Qcm92aWRlcicpO1xuICAgIH1cbiAgfVxuXG4gIHB1c2hQcm92aWRlcih3b3JrSW5Qcm9ncmVzcywgbmV3VmFsdWUpO1xuXG4gIGlmIChvbGRQcm9wcyAhPT0gbnVsbCkge1xuICAgIHZhciBvbGRWYWx1ZSA9IG9sZFByb3BzLnZhbHVlO1xuICAgIHZhciBjaGFuZ2VkQml0cyA9IGNhbGN1bGF0ZUNoYW5nZWRCaXRzKGNvbnRleHQsIG5ld1ZhbHVlLCBvbGRWYWx1ZSk7XG5cbiAgICBpZiAoY2hhbmdlZEJpdHMgPT09IDApIHtcbiAgICAgIC8vIE5vIGNoYW5nZS4gQmFpbG91dCBlYXJseSBpZiBjaGlsZHJlbiBhcmUgdGhlIHNhbWUuXG4gICAgICBpZiAob2xkUHJvcHMuY2hpbGRyZW4gPT09IG5ld1Byb3BzLmNoaWxkcmVuICYmICFoYXNDb250ZXh0Q2hhbmdlZCgpKSB7XG4gICAgICAgIHJldHVybiBiYWlsb3V0T25BbHJlYWR5RmluaXNoZWRXb3JrKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcyk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRoZSBjb250ZXh0IHZhbHVlIGNoYW5nZWQuIFNlYXJjaCBmb3IgbWF0Y2hpbmcgY29uc3VtZXJzIGFuZCBzY2hlZHVsZVxuICAgICAgLy8gdGhlbSB0byB1cGRhdGUuXG4gICAgICBwcm9wYWdhdGVDb250ZXh0Q2hhbmdlKHdvcmtJblByb2dyZXNzLCBjb250ZXh0LCBjaGFuZ2VkQml0cywgcmVuZGVyTGFuZXMpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBuZXdDaGlsZHJlbiA9IG5ld1Byb3BzLmNoaWxkcmVuO1xuICByZWNvbmNpbGVDaGlsZHJlbihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbmV3Q2hpbGRyZW4sIHJlbmRlckxhbmVzKTtcbiAgcmV0dXJuIHdvcmtJblByb2dyZXNzLmNoaWxkO1xufVxuXG52YXIgaGFzV2FybmVkQWJvdXRVc2luZ0NvbnRleHRBc0NvbnN1bWVyID0gZmFsc2U7XG5cbmZ1bmN0aW9uIHVwZGF0ZUNvbnRleHRDb25zdW1lcihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpIHtcbiAgdmFyIGNvbnRleHQgPSB3b3JrSW5Qcm9ncmVzcy50eXBlOyAvLyBUaGUgbG9naWMgYmVsb3cgZm9yIENvbnRleHQgZGlmZmVycyBkZXBlbmRpbmcgb24gUFJPRCBvciBERVYgbW9kZS4gSW5cbiAgLy8gREVWIG1vZGUsIHdlIGNyZWF0ZSBhIHNlcGFyYXRlIG9iamVjdCBmb3IgQ29udGV4dC5Db25zdW1lciB0aGF0IGFjdHNcbiAgLy8gbGlrZSBhIHByb3h5IHRvIENvbnRleHQuIFRoaXMgcHJveHkgb2JqZWN0IGFkZHMgdW5uZWNlc3NhcnkgY29kZSBpbiBQUk9EXG4gIC8vIHNvIHdlIHVzZSB0aGUgb2xkIGJlaGF2aW91ciAoQ29udGV4dC5Db25zdW1lciByZWZlcmVuY2VzIENvbnRleHQpIHRvXG4gIC8vIHJlZHVjZSBzaXplIGFuZCBvdmVyaGVhZC4gVGhlIHNlcGFyYXRlIG9iamVjdCByZWZlcmVuY2VzIGNvbnRleHQgdmlhXG4gIC8vIGEgcHJvcGVydHkgY2FsbGVkIFwiX2NvbnRleHRcIiwgd2hpY2ggYWxzbyBnaXZlcyB1cyB0aGUgYWJpbGl0eSB0byBjaGVja1xuICAvLyBpbiBERVYgbW9kZSBpZiB0aGlzIHByb3BlcnR5IGV4aXN0cyBvciBub3QgYW5kIHdhcm4gaWYgaXQgZG9lcyBub3QuXG5cbiAge1xuICAgIGlmIChjb250ZXh0Ll9jb250ZXh0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIFRoaXMgbWF5IGJlIGJlY2F1c2UgaXQncyBhIENvbnRleHQgKHJhdGhlciB0aGFuIGEgQ29uc3VtZXIpLlxuICAgICAgLy8gT3IgaXQgbWF5IGJlIGJlY2F1c2UgaXQncyBvbGRlciBSZWFjdCB3aGVyZSB0aGV5J3JlIHRoZSBzYW1lIHRoaW5nLlxuICAgICAgLy8gV2Ugb25seSB3YW50IHRvIHdhcm4gaWYgd2UncmUgc3VyZSBpdCdzIGEgbmV3IFJlYWN0LlxuICAgICAgaWYgKGNvbnRleHQgIT09IGNvbnRleHQuQ29uc3VtZXIpIHtcbiAgICAgICAgaWYgKCFoYXNXYXJuZWRBYm91dFVzaW5nQ29udGV4dEFzQ29uc3VtZXIpIHtcbiAgICAgICAgICBoYXNXYXJuZWRBYm91dFVzaW5nQ29udGV4dEFzQ29uc3VtZXIgPSB0cnVlO1xuXG4gICAgICAgICAgZXJyb3IoJ1JlbmRlcmluZyA8Q29udGV4dD4gZGlyZWN0bHkgaXMgbm90IHN1cHBvcnRlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluICcgKyAnYSBmdXR1cmUgbWFqb3IgcmVsZWFzZS4gRGlkIHlvdSBtZWFuIHRvIHJlbmRlciA8Q29udGV4dC5Db25zdW1lcj4gaW5zdGVhZD8nKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb250ZXh0ID0gY29udGV4dC5fY29udGV4dDtcbiAgICB9XG4gIH1cblxuICB2YXIgbmV3UHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7XG4gIHZhciByZW5kZXIgPSBuZXdQcm9wcy5jaGlsZHJlbjtcblxuICB7XG4gICAgaWYgKHR5cGVvZiByZW5kZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGVycm9yKCdBIGNvbnRleHQgY29uc3VtZXIgd2FzIHJlbmRlcmVkIHdpdGggbXVsdGlwbGUgY2hpbGRyZW4sIG9yIGEgY2hpbGQgJyArIFwidGhhdCBpc24ndCBhIGZ1bmN0aW9uLiBBIGNvbnRleHQgY29uc3VtZXIgZXhwZWN0cyBhIHNpbmdsZSBjaGlsZCBcIiArICd0aGF0IGlzIGEgZnVuY3Rpb24uIElmIHlvdSBkaWQgcGFzcyBhIGZ1bmN0aW9uLCBtYWtlIHN1cmUgdGhlcmUgJyArICdpcyBubyB0cmFpbGluZyBvciBsZWFkaW5nIHdoaXRlc3BhY2UgYXJvdW5kIGl0LicpO1xuICAgIH1cbiAgfVxuXG4gIHByZXBhcmVUb1JlYWRDb250ZXh0KHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcyk7XG4gIHZhciBuZXdWYWx1ZSA9IHJlYWRDb250ZXh0KGNvbnRleHQsIG5ld1Byb3BzLnVuc3RhYmxlX29ic2VydmVkQml0cyk7XG4gIHZhciBuZXdDaGlsZHJlbjtcblxuICB7XG4gICAgUmVhY3RDdXJyZW50T3duZXIkMS5jdXJyZW50ID0gd29ya0luUHJvZ3Jlc3M7XG4gICAgc2V0SXNSZW5kZXJpbmcodHJ1ZSk7XG4gICAgbmV3Q2hpbGRyZW4gPSByZW5kZXIobmV3VmFsdWUpO1xuICAgIHNldElzUmVuZGVyaW5nKGZhbHNlKTtcbiAgfSAvLyBSZWFjdCBEZXZUb29scyByZWFkcyB0aGlzIGZsYWcuXG5cblxuICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBQZXJmb3JtZWRXb3JrO1xuICByZWNvbmNpbGVDaGlsZHJlbihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbmV3Q2hpbGRyZW4sIHJlbmRlckxhbmVzKTtcbiAgcmV0dXJuIHdvcmtJblByb2dyZXNzLmNoaWxkO1xufVxuXG5mdW5jdGlvbiBtYXJrV29ya0luUHJvZ3Jlc3NSZWNlaXZlZFVwZGF0ZSgpIHtcbiAgZGlkUmVjZWl2ZVVwZGF0ZSA9IHRydWU7XG59XG5cbmZ1bmN0aW9uIGJhaWxvdXRPbkFscmVhZHlGaW5pc2hlZFdvcmsoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKSB7XG4gIGlmIChjdXJyZW50ICE9PSBudWxsKSB7XG4gICAgLy8gUmV1c2UgcHJldmlvdXMgZGVwZW5kZW5jaWVzXG4gICAgd29ya0luUHJvZ3Jlc3MuZGVwZW5kZW5jaWVzID0gY3VycmVudC5kZXBlbmRlbmNpZXM7XG4gIH1cblxuICB7XG4gICAgLy8gRG9uJ3QgdXBkYXRlIFwiYmFzZVwiIHJlbmRlciB0aW1lcyBmb3IgYmFpbG91dHMuXG4gICAgc3RvcFByb2ZpbGVyVGltZXJJZlJ1bm5pbmcoKTtcbiAgfVxuXG4gIG1hcmtTa2lwcGVkVXBkYXRlTGFuZXMod29ya0luUHJvZ3Jlc3MubGFuZXMpOyAvLyBDaGVjayBpZiB0aGUgY2hpbGRyZW4gaGF2ZSBhbnkgcGVuZGluZyB3b3JrLlxuXG4gIGlmICghaW5jbHVkZXNTb21lTGFuZShyZW5kZXJMYW5lcywgd29ya0luUHJvZ3Jlc3MuY2hpbGRMYW5lcykpIHtcbiAgICAvLyBUaGUgY2hpbGRyZW4gZG9uJ3QgaGF2ZSBhbnkgd29yayBlaXRoZXIuIFdlIGNhbiBza2lwIHRoZW0uXG4gICAgLy8gVE9ETzogT25jZSB3ZSBhZGQgYmFjayByZXN1bWluZywgd2Ugc2hvdWxkIGNoZWNrIGlmIHRoZSBjaGlsZHJlbiBhcmVcbiAgICAvLyBhIHdvcmstaW4tcHJvZ3Jlc3Mgc2V0LiBJZiBzbywgd2UgbmVlZCB0byB0cmFuc2ZlciB0aGVpciBlZmZlY3RzLlxuICAgIHJldHVybiBudWxsO1xuICB9IGVsc2Uge1xuICAgIC8vIFRoaXMgZmliZXIgZG9lc24ndCBoYXZlIHdvcmssIGJ1dCBpdHMgc3VidHJlZSBkb2VzLiBDbG9uZSB0aGUgY2hpbGRcbiAgICAvLyBmaWJlcnMgYW5kIGNvbnRpbnVlLlxuICAgIGNsb25lQ2hpbGRGaWJlcnMoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpO1xuICAgIHJldHVybiB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbiAgfVxufVxuXG5mdW5jdGlvbiByZW1vdW50RmliZXIoY3VycmVudCwgb2xkV29ya0luUHJvZ3Jlc3MsIG5ld1dvcmtJblByb2dyZXNzKSB7XG4gIHtcbiAgICB2YXIgcmV0dXJuRmliZXIgPSBvbGRXb3JrSW5Qcm9ncmVzcy5yZXR1cm47XG5cbiAgICBpZiAocmV0dXJuRmliZXIgPT09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IHN3YXAgdGhlIHJvb3QgZmliZXIuJyk7XG4gICAgfSAvLyBEaXNjb25uZWN0IGZyb20gdGhlIG9sZCBjdXJyZW50LlxuICAgIC8vIEl0IHdpbGwgZ2V0IGRlbGV0ZWQuXG5cblxuICAgIGN1cnJlbnQuYWx0ZXJuYXRlID0gbnVsbDtcbiAgICBvbGRXb3JrSW5Qcm9ncmVzcy5hbHRlcm5hdGUgPSBudWxsOyAvLyBDb25uZWN0IHRvIHRoZSBuZXcgdHJlZS5cblxuICAgIG5ld1dvcmtJblByb2dyZXNzLmluZGV4ID0gb2xkV29ya0luUHJvZ3Jlc3MuaW5kZXg7XG4gICAgbmV3V29ya0luUHJvZ3Jlc3Muc2libGluZyA9IG9sZFdvcmtJblByb2dyZXNzLnNpYmxpbmc7XG4gICAgbmV3V29ya0luUHJvZ3Jlc3MucmV0dXJuID0gb2xkV29ya0luUHJvZ3Jlc3MucmV0dXJuO1xuICAgIG5ld1dvcmtJblByb2dyZXNzLnJlZiA9IG9sZFdvcmtJblByb2dyZXNzLnJlZjsgLy8gUmVwbGFjZSB0aGUgY2hpbGQvc2libGluZyBwb2ludGVycyBhYm92ZSBpdC5cblxuICAgIGlmIChvbGRXb3JrSW5Qcm9ncmVzcyA9PT0gcmV0dXJuRmliZXIuY2hpbGQpIHtcbiAgICAgIHJldHVybkZpYmVyLmNoaWxkID0gbmV3V29ya0luUHJvZ3Jlc3M7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBwcmV2U2libGluZyA9IHJldHVybkZpYmVyLmNoaWxkO1xuXG4gICAgICBpZiAocHJldlNpYmxpbmcgPT09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBwYXJlbnQgdG8gaGF2ZSBhIGNoaWxkLicpO1xuICAgICAgfVxuXG4gICAgICB3aGlsZSAocHJldlNpYmxpbmcuc2libGluZyAhPT0gb2xkV29ya0luUHJvZ3Jlc3MpIHtcbiAgICAgICAgcHJldlNpYmxpbmcgPSBwcmV2U2libGluZy5zaWJsaW5nO1xuXG4gICAgICAgIGlmIChwcmV2U2libGluZyA9PT0gbnVsbCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgdG8gZmluZCB0aGUgcHJldmlvdXMgc2libGluZy4nKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBwcmV2U2libGluZy5zaWJsaW5nID0gbmV3V29ya0luUHJvZ3Jlc3M7XG4gICAgfSAvLyBEZWxldGUgdGhlIG9sZCBmaWJlciBhbmQgcGxhY2UgdGhlIG5ldyBvbmUuXG4gICAgLy8gU2luY2UgdGhlIG9sZCBmaWJlciBpcyBkaXNjb25uZWN0ZWQsIHdlIGhhdmUgdG8gc2NoZWR1bGUgaXQgbWFudWFsbHkuXG5cblxuICAgIHZhciBsYXN0ID0gcmV0dXJuRmliZXIubGFzdEVmZmVjdDtcblxuICAgIGlmIChsYXN0ICE9PSBudWxsKSB7XG4gICAgICBsYXN0Lm5leHRFZmZlY3QgPSBjdXJyZW50O1xuICAgICAgcmV0dXJuRmliZXIubGFzdEVmZmVjdCA9IGN1cnJlbnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybkZpYmVyLmZpcnN0RWZmZWN0ID0gcmV0dXJuRmliZXIubGFzdEVmZmVjdCA9IGN1cnJlbnQ7XG4gICAgfVxuXG4gICAgY3VycmVudC5uZXh0RWZmZWN0ID0gbnVsbDtcbiAgICBjdXJyZW50LmZsYWdzID0gRGVsZXRpb247XG4gICAgbmV3V29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gUGxhY2VtZW50OyAvLyBSZXN0YXJ0IHdvcmsgZnJvbSB0aGUgbmV3IGZpYmVyLlxuXG4gICAgcmV0dXJuIG5ld1dvcmtJblByb2dyZXNzO1xuICB9XG59XG5cbmZ1bmN0aW9uIGJlZ2luV29yayhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpIHtcbiAgdmFyIHVwZGF0ZUxhbmVzID0gd29ya0luUHJvZ3Jlc3MubGFuZXM7XG5cbiAge1xuICAgIGlmICh3b3JrSW5Qcm9ncmVzcy5fZGVidWdOZWVkc1JlbW91bnQgJiYgY3VycmVudCAhPT0gbnVsbCkge1xuICAgICAgLy8gVGhpcyB3aWxsIHJlc3RhcnQgdGhlIGJlZ2luIHBoYXNlIHdpdGggYSBuZXcgZmliZXIuXG4gICAgICByZXR1cm4gcmVtb3VudEZpYmVyKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBjcmVhdGVGaWJlckZyb21UeXBlQW5kUHJvcHMod29ya0luUHJvZ3Jlc3MudHlwZSwgd29ya0luUHJvZ3Jlc3Mua2V5LCB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHMsIHdvcmtJblByb2dyZXNzLl9kZWJ1Z093bmVyIHx8IG51bGwsIHdvcmtJblByb2dyZXNzLm1vZGUsIHdvcmtJblByb2dyZXNzLmxhbmVzKSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKGN1cnJlbnQgIT09IG51bGwpIHtcbiAgICB2YXIgb2xkUHJvcHMgPSBjdXJyZW50Lm1lbW9pemVkUHJvcHM7XG4gICAgdmFyIG5ld1Byb3BzID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO1xuXG4gICAgaWYgKG9sZFByb3BzICE9PSBuZXdQcm9wcyB8fCBoYXNDb250ZXh0Q2hhbmdlZCgpIHx8ICggLy8gRm9yY2UgYSByZS1yZW5kZXIgaWYgdGhlIGltcGxlbWVudGF0aW9uIGNoYW5nZWQgZHVlIHRvIGhvdCByZWxvYWQ6XG4gICAgIHdvcmtJblByb2dyZXNzLnR5cGUgIT09IGN1cnJlbnQudHlwZSApKSB7XG4gICAgICAvLyBJZiBwcm9wcyBvciBjb250ZXh0IGNoYW5nZWQsIG1hcmsgdGhlIGZpYmVyIGFzIGhhdmluZyBwZXJmb3JtZWQgd29yay5cbiAgICAgIC8vIFRoaXMgbWF5IGJlIHVuc2V0IGlmIHRoZSBwcm9wcyBhcmUgZGV0ZXJtaW5lZCB0byBiZSBlcXVhbCBsYXRlciAobWVtbykuXG4gICAgICBkaWRSZWNlaXZlVXBkYXRlID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKCFpbmNsdWRlc1NvbWVMYW5lKHJlbmRlckxhbmVzLCB1cGRhdGVMYW5lcykpIHtcbiAgICAgIGRpZFJlY2VpdmVVcGRhdGUgPSBmYWxzZTsgLy8gVGhpcyBmaWJlciBkb2VzIG5vdCBoYXZlIGFueSBwZW5kaW5nIHdvcmsuIEJhaWxvdXQgd2l0aG91dCBlbnRlcmluZ1xuICAgICAgLy8gdGhlIGJlZ2luIHBoYXNlLiBUaGVyZSdzIHN0aWxsIHNvbWUgYm9va2tlZXBpbmcgd2UgdGhhdCBuZWVkcyB0byBiZSBkb25lXG4gICAgICAvLyBpbiB0aGlzIG9wdGltaXplZCBwYXRoLCBtb3N0bHkgcHVzaGluZyBzdHVmZiBvbnRvIHRoZSBzdGFjay5cblxuICAgICAgc3dpdGNoICh3b3JrSW5Qcm9ncmVzcy50YWcpIHtcbiAgICAgICAgY2FzZSBIb3N0Um9vdDpcbiAgICAgICAgICBwdXNoSG9zdFJvb3RDb250ZXh0KHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICByZXNldEh5ZHJhdGlvblN0YXRlKCk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAgICAgIHB1c2hIb3N0Q29udGV4dCh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBDbGFzc0NvbXBvbmVudDpcbiAgICAgICAgICB7XG4gICAgICAgICAgICB2YXIgQ29tcG9uZW50ID0gd29ya0luUHJvZ3Jlc3MudHlwZTtcblxuICAgICAgICAgICAgaWYgKGlzQ29udGV4dFByb3ZpZGVyKENvbXBvbmVudCkpIHtcbiAgICAgICAgICAgICAgcHVzaENvbnRleHRQcm92aWRlcih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlIEhvc3RQb3J0YWw6XG4gICAgICAgICAgcHVzaEhvc3RDb250YWluZXIod29ya0luUHJvZ3Jlc3MsIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZS5jb250YWluZXJJbmZvKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIENvbnRleHRQcm92aWRlcjpcbiAgICAgICAgICB7XG4gICAgICAgICAgICB2YXIgbmV3VmFsdWUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFByb3BzLnZhbHVlO1xuICAgICAgICAgICAgcHVzaFByb3ZpZGVyKHdvcmtJblByb2dyZXNzLCBuZXdWYWx1ZSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSBQcm9maWxlcjpcbiAgICAgICAgICB7XG4gICAgICAgICAgICAvLyBQcm9maWxlciBzaG91bGQgb25seSBjYWxsIG9uUmVuZGVyIHdoZW4gb25lIG9mIGl0cyBkZXNjZW5kYW50cyBhY3R1YWxseSByZW5kZXJlZC5cbiAgICAgICAgICAgIHZhciBoYXNDaGlsZFdvcmsgPSBpbmNsdWRlc1NvbWVMYW5lKHJlbmRlckxhbmVzLCB3b3JrSW5Qcm9ncmVzcy5jaGlsZExhbmVzKTtcblxuICAgICAgICAgICAgaWYgKGhhc0NoaWxkV29yaykge1xuICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBVcGRhdGU7XG4gICAgICAgICAgICB9IC8vIFJlc2V0IGVmZmVjdCBkdXJhdGlvbnMgZm9yIHRoZSBuZXh0IGV2ZW50dWFsIGVmZmVjdCBwaGFzZS5cbiAgICAgICAgICAgIC8vIFRoZXNlIGFyZSByZXNldCBkdXJpbmcgcmVuZGVyIHRvIGFsbG93IHRoZSBEZXZUb29scyBjb21taXQgaG9vayBhIGNoYW5jZSB0byByZWFkIHRoZW0sXG5cblxuICAgICAgICAgICAgdmFyIHN0YXRlTm9kZSA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcbiAgICAgICAgICAgIHN0YXRlTm9kZS5lZmZlY3REdXJhdGlvbiA9IDA7XG4gICAgICAgICAgICBzdGF0ZU5vZGUucGFzc2l2ZUVmZmVjdER1cmF0aW9uID0gMDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIFN1c3BlbnNlQ29tcG9uZW50OlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHZhciBzdGF0ZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG5cbiAgICAgICAgICAgIGlmIChzdGF0ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAvLyB3aGV0aGVyIHRvIHJldHJ5IHRoZSBwcmltYXJ5IGNoaWxkcmVuLCBvciB0byBza2lwIG92ZXIgaXQgYW5kXG4gICAgICAgICAgICAgIC8vIGdvIHN0cmFpZ2h0IHRvIHRoZSBmYWxsYmFjay4gQ2hlY2sgdGhlIHByaW9yaXR5IG9mIHRoZSBwcmltYXJ5XG4gICAgICAgICAgICAgIC8vIGNoaWxkIGZyYWdtZW50LlxuXG5cbiAgICAgICAgICAgICAgdmFyIHByaW1hcnlDaGlsZEZyYWdtZW50ID0gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG4gICAgICAgICAgICAgIHZhciBwcmltYXJ5Q2hpbGRMYW5lcyA9IHByaW1hcnlDaGlsZEZyYWdtZW50LmNoaWxkTGFuZXM7XG5cbiAgICAgICAgICAgICAgaWYgKGluY2x1ZGVzU29tZUxhbmUocmVuZGVyTGFuZXMsIHByaW1hcnlDaGlsZExhbmVzKSkge1xuICAgICAgICAgICAgICAgIC8vIFRoZSBwcmltYXJ5IGNoaWxkcmVuIGhhdmUgcGVuZGluZyB3b3JrLiBVc2UgdGhlIG5vcm1hbCBwYXRoXG4gICAgICAgICAgICAgICAgLy8gdG8gYXR0ZW1wdCB0byByZW5kZXIgdGhlIHByaW1hcnkgY2hpbGRyZW4gYWdhaW4uXG4gICAgICAgICAgICAgICAgcmV0dXJuIHVwZGF0ZVN1c3BlbnNlQ29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcyk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gVGhlIHByaW1hcnkgY2hpbGQgZnJhZ21lbnQgZG9lcyBub3QgaGF2ZSBwZW5kaW5nIHdvcmsgbWFya2VkXG4gICAgICAgICAgICAgICAgLy8gb24gaXRcbiAgICAgICAgICAgICAgICBwdXNoU3VzcGVuc2VDb250ZXh0KHdvcmtJblByb2dyZXNzLCBzZXREZWZhdWx0U2hhbGxvd1N1c3BlbnNlQ29udGV4dChzdXNwZW5zZVN0YWNrQ3Vyc29yLmN1cnJlbnQpKTsgLy8gVGhlIHByaW1hcnkgY2hpbGRyZW4gZG8gbm90IGhhdmUgcGVuZGluZyB3b3JrIHdpdGggc3VmZmljaWVudFxuICAgICAgICAgICAgICAgIC8vIHByaW9yaXR5LiBCYWlsb3V0LlxuXG4gICAgICAgICAgICAgICAgdmFyIGNoaWxkID0gYmFpbG91dE9uQWxyZWFkeUZpbmlzaGVkV29yayhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAvLyBUaGUgZmFsbGJhY2sgY2hpbGRyZW4gaGF2ZSBwZW5kaW5nIHdvcmsuIFNraXAgb3ZlciB0aGVcbiAgICAgICAgICAgICAgICAgIC8vIHByaW1hcnkgY2hpbGRyZW4gYW5kIHdvcmsgb24gdGhlIGZhbGxiYWNrLlxuICAgICAgICAgICAgICAgICAgcmV0dXJuIGNoaWxkLnNpYmxpbmc7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcHVzaFN1c3BlbnNlQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgc2V0RGVmYXVsdFNoYWxsb3dTdXNwZW5zZUNvbnRleHQoc3VzcGVuc2VTdGFja0N1cnNvci5jdXJyZW50KSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlIFN1c3BlbnNlTGlzdENvbXBvbmVudDpcbiAgICAgICAgICB7XG4gICAgICAgICAgICB2YXIgZGlkU3VzcGVuZEJlZm9yZSA9IChjdXJyZW50LmZsYWdzICYgRGlkQ2FwdHVyZSkgIT09IE5vRmxhZ3M7XG5cbiAgICAgICAgICAgIHZhciBfaGFzQ2hpbGRXb3JrID0gaW5jbHVkZXNTb21lTGFuZShyZW5kZXJMYW5lcywgd29ya0luUHJvZ3Jlc3MuY2hpbGRMYW5lcyk7XG5cbiAgICAgICAgICAgIGlmIChkaWRTdXNwZW5kQmVmb3JlKSB7XG4gICAgICAgICAgICAgIGlmIChfaGFzQ2hpbGRXb3JrKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgc29tZXRoaW5nIHdhcyBpbiBmYWxsYmFjayBzdGF0ZSBsYXN0IHRpbWUsIGFuZCB3ZSBoYXZlIGFsbCB0aGVcbiAgICAgICAgICAgICAgICAvLyBzYW1lIGNoaWxkcmVuIHRoZW4gd2UncmUgc3RpbGwgaW4gcHJvZ3Jlc3NpdmUgbG9hZGluZyBzdGF0ZS5cbiAgICAgICAgICAgICAgICAvLyBTb21ldGhpbmcgbWlnaHQgZ2V0IHVuYmxvY2tlZCBieSBzdGF0ZSB1cGRhdGVzIG9yIHJldHJpZXMgaW4gdGhlXG4gICAgICAgICAgICAgICAgLy8gdHJlZSB3aGljaCB3aWxsIGFmZmVjdCB0aGUgdGFpbC4gU28gd2UgbmVlZCB0byB1c2UgdGhlIG5vcm1hbFxuICAgICAgICAgICAgICAgIC8vIHBhdGggdG8gY29tcHV0ZSB0aGUgY29ycmVjdCB0YWlsLlxuICAgICAgICAgICAgICAgIHJldHVybiB1cGRhdGVTdXNwZW5zZUxpc3RDb21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKTtcbiAgICAgICAgICAgICAgfSAvLyBJZiBub25lIG9mIHRoZSBjaGlsZHJlbiBoYWQgYW55IHdvcmssIHRoYXQgbWVhbnMgdGhhdCBub25lIG9mXG4gICAgICAgICAgICAgIC8vIHRoZW0gZ290IHJldHJpZWQgc28gdGhleSdsbCBzdGlsbCBiZSBibG9ja2VkIGluIHRoZSBzYW1lIHdheVxuICAgICAgICAgICAgICAvLyBhcyBiZWZvcmUuIFdlIGNhbiBmYXN0IGJhaWwgb3V0LlxuXG5cbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gRGlkQ2FwdHVyZTtcbiAgICAgICAgICAgIH0gLy8gSWYgbm90aGluZyBzdXNwZW5kZWQgYmVmb3JlIGFuZCB3ZSdyZSByZW5kZXJpbmcgdGhlIHNhbWUgY2hpbGRyZW4sXG4gICAgICAgICAgICAvLyB0aGVuIHRoZSB0YWlsIGRvZXNuJ3QgbWF0dGVyLiBBbnl0aGluZyBuZXcgdGhhdCBzdXNwZW5kcyB3aWxsIHdvcmtcbiAgICAgICAgICAgIC8vIGluIHRoZSBcInRvZ2V0aGVyXCIgbW9kZSwgc28gd2UgY2FuIGNvbnRpbnVlIGZyb20gdGhlIHN0YXRlIHdlIGhhZC5cblxuXG4gICAgICAgICAgICB2YXIgcmVuZGVyU3RhdGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuXG4gICAgICAgICAgICBpZiAocmVuZGVyU3RhdGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgLy8gUmVzZXQgdG8gdGhlIFwidG9nZXRoZXJcIiBtb2RlIGluIGNhc2Ugd2UndmUgc3RhcnRlZCBhIGRpZmZlcmVudFxuICAgICAgICAgICAgICAvLyB1cGRhdGUgaW4gdGhlIHBhc3QgYnV0IGRpZG4ndCBjb21wbGV0ZSBpdC5cbiAgICAgICAgICAgICAgcmVuZGVyU3RhdGUucmVuZGVyaW5nID0gbnVsbDtcbiAgICAgICAgICAgICAgcmVuZGVyU3RhdGUudGFpbCA9IG51bGw7XG4gICAgICAgICAgICAgIHJlbmRlclN0YXRlLmxhc3RFZmZlY3QgPSBudWxsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBwdXNoU3VzcGVuc2VDb250ZXh0KHdvcmtJblByb2dyZXNzLCBzdXNwZW5zZVN0YWNrQ3Vyc29yLmN1cnJlbnQpO1xuXG4gICAgICAgICAgICBpZiAoX2hhc0NoaWxkV29yaykge1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIElmIG5vbmUgb2YgdGhlIGNoaWxkcmVuIGhhZCBhbnkgd29yaywgdGhhdCBtZWFucyB0aGF0IG5vbmUgb2ZcbiAgICAgICAgICAgICAgLy8gdGhlbSBnb3QgcmV0cmllZCBzbyB0aGV5J2xsIHN0aWxsIGJlIGJsb2NrZWQgaW4gdGhlIHNhbWUgd2F5XG4gICAgICAgICAgICAgIC8vIGFzIGJlZm9yZS4gV2UgY2FuIGZhc3QgYmFpbCBvdXQuXG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlIE9mZnNjcmVlbkNvbXBvbmVudDpcbiAgICAgICAgY2FzZSBMZWdhY3lIaWRkZW5Db21wb25lbnQ6XG4gICAgICAgICAge1xuICAgICAgICAgICAgLy8gTmVlZCB0byBjaGVjayBpZiB0aGUgdHJlZSBzdGlsbCBuZWVkcyB0byBiZSBkZWZlcnJlZC4gVGhpcyBpc1xuICAgICAgICAgICAgLy8gYWxtb3N0IGlkZW50aWNhbCB0byB0aGUgbG9naWMgdXNlZCBpbiB0aGUgbm9ybWFsIHVwZGF0ZSBwYXRoLFxuICAgICAgICAgICAgLy8gc28gd2UnbGwganVzdCBlbnRlciB0aGF0LiBUaGUgb25seSBkaWZmZXJlbmNlIGlzIHdlJ2xsIGJhaWwgb3V0XG4gICAgICAgICAgICAvLyBhdCB0aGUgbmV4dCBsZXZlbCBpbnN0ZWFkIG9mIHRoaXMgb25lLCBiZWNhdXNlIHRoZSBjaGlsZCBwcm9wc1xuICAgICAgICAgICAgLy8gaGF2ZSBub3QgY2hhbmdlZC4gV2hpY2ggaXMgZmluZS5cbiAgICAgICAgICAgIC8vIFRPRE86IFByb2JhYmx5IHNob3VsZCByZWZhY3RvciBgYmVnaW5Xb3JrYCB0byBzcGxpdCB0aGUgYmFpbG91dFxuICAgICAgICAgICAgLy8gcGF0aCBmcm9tIHRoZSBub3JtYWwgcGF0aC4gSSdtIHRlbXB0ZWQgdG8gZG8gYSBsYWJlbGVkIGJyZWFrIGhlcmVcbiAgICAgICAgICAgIC8vIGJ1dCBJIHdvbid0IDopXG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5sYW5lcyA9IE5vTGFuZXM7XG4gICAgICAgICAgICByZXR1cm4gdXBkYXRlT2Zmc2NyZWVuQ29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcyk7XG4gICAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gYmFpbG91dE9uQWxyZWFkeUZpbmlzaGVkV29yayhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoKGN1cnJlbnQuZmxhZ3MgJiBGb3JjZVVwZGF0ZUZvckxlZ2FjeVN1c3BlbnNlKSAhPT0gTm9GbGFncykge1xuICAgICAgICAvLyBUaGlzIGlzIGEgc3BlY2lhbCBjYXNlIHRoYXQgb25seSBleGlzdHMgZm9yIGxlZ2FjeSBtb2RlLlxuICAgICAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L3B1bGwvMTkyMTYuXG4gICAgICAgIGRpZFJlY2VpdmVVcGRhdGUgPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gQW4gdXBkYXRlIHdhcyBzY2hlZHVsZWQgb24gdGhpcyBmaWJlciwgYnV0IHRoZXJlIGFyZSBubyBuZXcgcHJvcHNcbiAgICAgICAgLy8gbm9yIGxlZ2FjeSBjb250ZXh0LiBTZXQgdGhpcyB0byBmYWxzZS4gSWYgYW4gdXBkYXRlIHF1ZXVlIG9yIGNvbnRleHRcbiAgICAgICAgLy8gY29uc3VtZXIgcHJvZHVjZXMgYSBjaGFuZ2VkIHZhbHVlLCBpdCB3aWxsIHNldCB0aGlzIHRvIHRydWUuIE90aGVyd2lzZSxcbiAgICAgICAgLy8gdGhlIGNvbXBvbmVudCB3aWxsIGFzc3VtZSB0aGUgY2hpbGRyZW4gaGF2ZSBub3QgY2hhbmdlZCBhbmQgYmFpbCBvdXQuXG4gICAgICAgIGRpZFJlY2VpdmVVcGRhdGUgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZGlkUmVjZWl2ZVVwZGF0ZSA9IGZhbHNlO1xuICB9IC8vIEJlZm9yZSBlbnRlcmluZyB0aGUgYmVnaW4gcGhhc2UsIGNsZWFyIHBlbmRpbmcgdXBkYXRlIHByaW9yaXR5LlxuICAvLyBUT0RPOiBUaGlzIGFzc3VtZXMgdGhhdCB3ZSdyZSBhYm91dCB0byBldmFsdWF0ZSB0aGUgY29tcG9uZW50IGFuZCBwcm9jZXNzXG4gIC8vIHRoZSB1cGRhdGUgcXVldWUuIEhvd2V2ZXIsIHRoZXJlJ3MgYW4gZXhjZXB0aW9uOiBTaW1wbGVNZW1vQ29tcG9uZW50XG4gIC8vIHNvbWV0aW1lcyBiYWlscyBvdXQgbGF0ZXIgaW4gdGhlIGJlZ2luIHBoYXNlLiBUaGlzIGluZGljYXRlcyB0aGF0IHdlIHNob3VsZFxuICAvLyBtb3ZlIHRoaXMgYXNzaWdubWVudCBvdXQgb2YgdGhlIGNvbW1vbiBwYXRoIGFuZCBpbnRvIGVhY2ggYnJhbmNoLlxuXG5cbiAgd29ya0luUHJvZ3Jlc3MubGFuZXMgPSBOb0xhbmVzO1xuXG4gIHN3aXRjaCAod29ya0luUHJvZ3Jlc3MudGFnKSB7XG4gICAgY2FzZSBJbmRldGVybWluYXRlQ29tcG9uZW50OlxuICAgICAge1xuICAgICAgICByZXR1cm4gbW91bnRJbmRldGVybWluYXRlQ29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCB3b3JrSW5Qcm9ncmVzcy50eXBlLCByZW5kZXJMYW5lcyk7XG4gICAgICB9XG5cbiAgICBjYXNlIExhenlDb21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIHZhciBlbGVtZW50VHlwZSA9IHdvcmtJblByb2dyZXNzLmVsZW1lbnRUeXBlO1xuICAgICAgICByZXR1cm4gbW91bnRMYXp5Q29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBlbGVtZW50VHlwZSwgdXBkYXRlTGFuZXMsIHJlbmRlckxhbmVzKTtcbiAgICAgIH1cblxuICAgIGNhc2UgRnVuY3Rpb25Db21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIHZhciBfQ29tcG9uZW50ID0gd29ya0luUHJvZ3Jlc3MudHlwZTtcbiAgICAgICAgdmFyIHVucmVzb2x2ZWRQcm9wcyA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcztcbiAgICAgICAgdmFyIHJlc29sdmVkUHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5lbGVtZW50VHlwZSA9PT0gX0NvbXBvbmVudCA/IHVucmVzb2x2ZWRQcm9wcyA6IHJlc29sdmVEZWZhdWx0UHJvcHMoX0NvbXBvbmVudCwgdW5yZXNvbHZlZFByb3BzKTtcbiAgICAgICAgcmV0dXJuIHVwZGF0ZUZ1bmN0aW9uQ29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBfQ29tcG9uZW50LCByZXNvbHZlZFByb3BzLCByZW5kZXJMYW5lcyk7XG4gICAgICB9XG5cbiAgICBjYXNlIENsYXNzQ29tcG9uZW50OlxuICAgICAge1xuICAgICAgICB2YXIgX0NvbXBvbmVudDIgPSB3b3JrSW5Qcm9ncmVzcy50eXBlO1xuICAgICAgICB2YXIgX3VucmVzb2x2ZWRQcm9wcyA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcztcblxuICAgICAgICB2YXIgX3Jlc29sdmVkUHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5lbGVtZW50VHlwZSA9PT0gX0NvbXBvbmVudDIgPyBfdW5yZXNvbHZlZFByb3BzIDogcmVzb2x2ZURlZmF1bHRQcm9wcyhfQ29tcG9uZW50MiwgX3VucmVzb2x2ZWRQcm9wcyk7XG5cbiAgICAgICAgcmV0dXJuIHVwZGF0ZUNsYXNzQ29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBfQ29tcG9uZW50MiwgX3Jlc29sdmVkUHJvcHMsIHJlbmRlckxhbmVzKTtcbiAgICAgIH1cblxuICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgICByZXR1cm4gdXBkYXRlSG9zdFJvb3QoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKTtcblxuICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgIHJldHVybiB1cGRhdGVIb3N0Q29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcyk7XG5cbiAgICBjYXNlIEhvc3RUZXh0OlxuICAgICAgcmV0dXJuIHVwZGF0ZUhvc3RUZXh0KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKTtcblxuICAgIGNhc2UgU3VzcGVuc2VDb21wb25lbnQ6XG4gICAgICByZXR1cm4gdXBkYXRlU3VzcGVuc2VDb21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKTtcblxuICAgIGNhc2UgSG9zdFBvcnRhbDpcbiAgICAgIHJldHVybiB1cGRhdGVQb3J0YWxDb21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKTtcblxuICAgIGNhc2UgRm9yd2FyZFJlZjpcbiAgICAgIHtcbiAgICAgICAgdmFyIHR5cGUgPSB3b3JrSW5Qcm9ncmVzcy50eXBlO1xuICAgICAgICB2YXIgX3VucmVzb2x2ZWRQcm9wczIgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7XG5cbiAgICAgICAgdmFyIF9yZXNvbHZlZFByb3BzMiA9IHdvcmtJblByb2dyZXNzLmVsZW1lbnRUeXBlID09PSB0eXBlID8gX3VucmVzb2x2ZWRQcm9wczIgOiByZXNvbHZlRGVmYXVsdFByb3BzKHR5cGUsIF91bnJlc29sdmVkUHJvcHMyKTtcblxuICAgICAgICByZXR1cm4gdXBkYXRlRm9yd2FyZFJlZihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgdHlwZSwgX3Jlc29sdmVkUHJvcHMyLCByZW5kZXJMYW5lcyk7XG4gICAgICB9XG5cbiAgICBjYXNlIEZyYWdtZW50OlxuICAgICAgcmV0dXJuIHVwZGF0ZUZyYWdtZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcyk7XG5cbiAgICBjYXNlIE1vZGU6XG4gICAgICByZXR1cm4gdXBkYXRlTW9kZShjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpO1xuXG4gICAgY2FzZSBQcm9maWxlcjpcbiAgICAgIHJldHVybiB1cGRhdGVQcm9maWxlcihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpO1xuXG4gICAgY2FzZSBDb250ZXh0UHJvdmlkZXI6XG4gICAgICByZXR1cm4gdXBkYXRlQ29udGV4dFByb3ZpZGVyKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcyk7XG5cbiAgICBjYXNlIENvbnRleHRDb25zdW1lcjpcbiAgICAgIHJldHVybiB1cGRhdGVDb250ZXh0Q29uc3VtZXIoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKTtcblxuICAgIGNhc2UgTWVtb0NvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgdmFyIF90eXBlMiA9IHdvcmtJblByb2dyZXNzLnR5cGU7XG4gICAgICAgIHZhciBfdW5yZXNvbHZlZFByb3BzMyA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wczsgLy8gUmVzb2x2ZSBvdXRlciBwcm9wcyBmaXJzdCwgdGhlbiByZXNvbHZlIGlubmVyIHByb3BzLlxuXG4gICAgICAgIHZhciBfcmVzb2x2ZWRQcm9wczMgPSByZXNvbHZlRGVmYXVsdFByb3BzKF90eXBlMiwgX3VucmVzb2x2ZWRQcm9wczMpO1xuXG4gICAgICAgIHtcbiAgICAgICAgICBpZiAod29ya0luUHJvZ3Jlc3MudHlwZSAhPT0gd29ya0luUHJvZ3Jlc3MuZWxlbWVudFR5cGUpIHtcbiAgICAgICAgICAgIHZhciBvdXRlclByb3BUeXBlcyA9IF90eXBlMi5wcm9wVHlwZXM7XG5cbiAgICAgICAgICAgIGlmIChvdXRlclByb3BUeXBlcykge1xuICAgICAgICAgICAgICBjaGVja1Byb3BUeXBlcyhvdXRlclByb3BUeXBlcywgX3Jlc29sdmVkUHJvcHMzLCAvLyBSZXNvbHZlZCBmb3Igb3V0ZXIgb25seVxuICAgICAgICAgICAgICAncHJvcCcsIGdldENvbXBvbmVudE5hbWUoX3R5cGUyKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgX3Jlc29sdmVkUHJvcHMzID0gcmVzb2x2ZURlZmF1bHRQcm9wcyhfdHlwZTIudHlwZSwgX3Jlc29sdmVkUHJvcHMzKTtcbiAgICAgICAgcmV0dXJuIHVwZGF0ZU1lbW9Db21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIF90eXBlMiwgX3Jlc29sdmVkUHJvcHMzLCB1cGRhdGVMYW5lcywgcmVuZGVyTGFuZXMpO1xuICAgICAgfVxuXG4gICAgY2FzZSBTaW1wbGVNZW1vQ29tcG9uZW50OlxuICAgICAge1xuICAgICAgICByZXR1cm4gdXBkYXRlU2ltcGxlTWVtb0NvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgd29ya0luUHJvZ3Jlc3MudHlwZSwgd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzLCB1cGRhdGVMYW5lcywgcmVuZGVyTGFuZXMpO1xuICAgICAgfVxuXG4gICAgY2FzZSBJbmNvbXBsZXRlQ2xhc3NDb21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIHZhciBfQ29tcG9uZW50MyA9IHdvcmtJblByb2dyZXNzLnR5cGU7XG4gICAgICAgIHZhciBfdW5yZXNvbHZlZFByb3BzNCA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcztcblxuICAgICAgICB2YXIgX3Jlc29sdmVkUHJvcHM0ID0gd29ya0luUHJvZ3Jlc3MuZWxlbWVudFR5cGUgPT09IF9Db21wb25lbnQzID8gX3VucmVzb2x2ZWRQcm9wczQgOiByZXNvbHZlRGVmYXVsdFByb3BzKF9Db21wb25lbnQzLCBfdW5yZXNvbHZlZFByb3BzNCk7XG5cbiAgICAgICAgcmV0dXJuIG1vdW50SW5jb21wbGV0ZUNsYXNzQ29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBfQ29tcG9uZW50MywgX3Jlc29sdmVkUHJvcHM0LCByZW5kZXJMYW5lcyk7XG4gICAgICB9XG5cbiAgICBjYXNlIFN1c3BlbnNlTGlzdENvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgcmV0dXJuIHVwZGF0ZVN1c3BlbnNlTGlzdENvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpO1xuICAgICAgfVxuXG4gICAgY2FzZSBGdW5kYW1lbnRhbENvbXBvbmVudDpcbiAgICAgIHtcblxuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgIGNhc2UgU2NvcGVDb21wb25lbnQ6XG4gICAgICB7XG5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICBjYXNlIEJsb2NrOlxuICAgICAge1xuXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgY2FzZSBPZmZzY3JlZW5Db21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIHJldHVybiB1cGRhdGVPZmZzY3JlZW5Db21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKTtcbiAgICAgIH1cblxuICAgIGNhc2UgTGVnYWN5SGlkZGVuQ29tcG9uZW50OlxuICAgICAge1xuICAgICAgICByZXR1cm4gdXBkYXRlTGVnYWN5SGlkZGVuQ29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcyk7XG4gICAgICB9XG4gIH1cblxuICB7XG4gICAge1xuICAgICAgdGhyb3cgRXJyb3IoIFwiVW5rbm93biB1bml0IG9mIHdvcmsgdGFnIChcIiArIHdvcmtJblByb2dyZXNzLnRhZyArIFwiKS4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS5cIiApO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBtYXJrVXBkYXRlKHdvcmtJblByb2dyZXNzKSB7XG4gIC8vIFRhZyB0aGUgZmliZXIgd2l0aCBhbiB1cGRhdGUgZWZmZWN0LiBUaGlzIHR1cm5zIGEgUGxhY2VtZW50IGludG9cbiAgLy8gYSBQbGFjZW1lbnRBbmRVcGRhdGUuXG4gIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IFVwZGF0ZTtcbn1cblxuZnVuY3Rpb24gbWFya1JlZiQxKHdvcmtJblByb2dyZXNzKSB7XG4gIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IFJlZjtcbn1cblxudmFyIGFwcGVuZEFsbENoaWxkcmVuO1xudmFyIHVwZGF0ZUhvc3RDb250YWluZXI7XG52YXIgdXBkYXRlSG9zdENvbXBvbmVudCQxO1xudmFyIHVwZGF0ZUhvc3RUZXh0JDE7XG5cbntcbiAgLy8gTXV0YXRpb24gbW9kZVxuICBhcHBlbmRBbGxDaGlsZHJlbiA9IGZ1bmN0aW9uIChwYXJlbnQsIHdvcmtJblByb2dyZXNzLCBuZWVkc1Zpc2liaWxpdHlUb2dnbGUsIGlzSGlkZGVuKSB7XG4gICAgLy8gV2Ugb25seSBoYXZlIHRoZSB0b3AgRmliZXIgdGhhdCB3YXMgY3JlYXRlZCBidXQgd2UgbmVlZCByZWN1cnNlIGRvd24gaXRzXG4gICAgLy8gY2hpbGRyZW4gdG8gZmluZCBhbGwgdGhlIHRlcm1pbmFsIG5vZGVzLlxuICAgIHZhciBub2RlID0gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG5cbiAgICB3aGlsZSAobm9kZSAhPT0gbnVsbCkge1xuICAgICAgaWYgKG5vZGUudGFnID09PSBIb3N0Q29tcG9uZW50IHx8IG5vZGUudGFnID09PSBIb3N0VGV4dCkge1xuICAgICAgICBhcHBlbmRJbml0aWFsQ2hpbGQocGFyZW50LCBub2RlLnN0YXRlTm9kZSk7XG4gICAgICB9IGVsc2UgaWYgKG5vZGUudGFnID09PSBIb3N0UG9ydGFsKSA7IGVsc2UgaWYgKG5vZGUuY2hpbGQgIT09IG51bGwpIHtcbiAgICAgICAgbm9kZS5jaGlsZC5yZXR1cm4gPSBub2RlO1xuICAgICAgICBub2RlID0gbm9kZS5jaGlsZDtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChub2RlID09PSB3b3JrSW5Qcm9ncmVzcykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHdoaWxlIChub2RlLnNpYmxpbmcgPT09IG51bGwpIHtcbiAgICAgICAgaWYgKG5vZGUucmV0dXJuID09PSBudWxsIHx8IG5vZGUucmV0dXJuID09PSB3b3JrSW5Qcm9ncmVzcykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIG5vZGUgPSBub2RlLnJldHVybjtcbiAgICAgIH1cblxuICAgICAgbm9kZS5zaWJsaW5nLnJldHVybiA9IG5vZGUucmV0dXJuO1xuICAgICAgbm9kZSA9IG5vZGUuc2libGluZztcbiAgICB9XG4gIH07XG5cbiAgdXBkYXRlSG9zdENvbnRhaW5lciA9IGZ1bmN0aW9uICh3b3JrSW5Qcm9ncmVzcykgey8vIE5vb3BcbiAgfTtcblxuICB1cGRhdGVIb3N0Q29tcG9uZW50JDEgPSBmdW5jdGlvbiAoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHR5cGUsIG5ld1Byb3BzLCByb290Q29udGFpbmVySW5zdGFuY2UpIHtcbiAgICAvLyBJZiB3ZSBoYXZlIGFuIGFsdGVybmF0ZSwgdGhhdCBtZWFucyB0aGlzIGlzIGFuIHVwZGF0ZSBhbmQgd2UgbmVlZCB0b1xuICAgIC8vIHNjaGVkdWxlIGEgc2lkZS1lZmZlY3QgdG8gZG8gdGhlIHVwZGF0ZXMuXG4gICAgdmFyIG9sZFByb3BzID0gY3VycmVudC5tZW1vaXplZFByb3BzO1xuXG4gICAgaWYgKG9sZFByb3BzID09PSBuZXdQcm9wcykge1xuICAgICAgLy8gSW4gbXV0YXRpb24gbW9kZSwgdGhpcyBpcyBzdWZmaWNpZW50IGZvciBhIGJhaWxvdXQgYmVjYXVzZVxuICAgICAgLy8gd2Ugd29uJ3QgdG91Y2ggdGhpcyBub2RlIGV2ZW4gaWYgY2hpbGRyZW4gY2hhbmdlZC5cbiAgICAgIHJldHVybjtcbiAgICB9IC8vIElmIHdlIGdldCB1cGRhdGVkIGJlY2F1c2Ugb25lIG9mIG91ciBjaGlsZHJlbiB1cGRhdGVkLCB3ZSBkb24ndFxuICAgIC8vIGhhdmUgbmV3UHJvcHMgc28gd2UnbGwgaGF2ZSB0byByZXVzZSB0aGVtLlxuICAgIC8vIFRPRE86IFNwbGl0IHRoZSB1cGRhdGUgQVBJIGFzIHNlcGFyYXRlIGZvciB0aGUgcHJvcHMgdnMuIGNoaWxkcmVuLlxuICAgIC8vIEV2ZW4gYmV0dGVyIHdvdWxkIGJlIGlmIGNoaWxkcmVuIHdlcmVuJ3Qgc3BlY2lhbCBjYXNlZCBhdCBhbGwgdGhvLlxuXG5cbiAgICB2YXIgaW5zdGFuY2UgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG4gICAgdmFyIGN1cnJlbnRIb3N0Q29udGV4dCA9IGdldEhvc3RDb250ZXh0KCk7IC8vIFRPRE86IEV4cGVyaWVuY2luZyBhbiBlcnJvciB3aGVyZSBvbGRQcm9wcyBpcyBudWxsLiBTdWdnZXN0cyBhIGhvc3RcbiAgICAvLyBjb21wb25lbnQgaXMgaGl0dGluZyB0aGUgcmVzdW1lIHBhdGguIEZpZ3VyZSBvdXQgd2h5LiBQb3NzaWJseVxuICAgIC8vIHJlbGF0ZWQgdG8gYGhpZGRlbmAuXG5cbiAgICB2YXIgdXBkYXRlUGF5bG9hZCA9IHByZXBhcmVVcGRhdGUoaW5zdGFuY2UsIHR5cGUsIG9sZFByb3BzLCBuZXdQcm9wcywgcm9vdENvbnRhaW5lckluc3RhbmNlLCBjdXJyZW50SG9zdENvbnRleHQpOyAvLyBUT0RPOiBUeXBlIHRoaXMgc3BlY2lmaWMgdG8gdGhpcyB0eXBlIG9mIGNvbXBvbmVudC5cblxuICAgIHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlID0gdXBkYXRlUGF5bG9hZDsgLy8gSWYgdGhlIHVwZGF0ZSBwYXlsb2FkIGluZGljYXRlcyB0aGF0IHRoZXJlIGlzIGEgY2hhbmdlIG9yIGlmIHRoZXJlXG4gICAgLy8gaXMgYSBuZXcgcmVmIHdlIG1hcmsgdGhpcyBhcyBhbiB1cGRhdGUuIEFsbCB0aGUgd29yayBpcyBkb25lIGluIGNvbW1pdFdvcmsuXG5cbiAgICBpZiAodXBkYXRlUGF5bG9hZCkge1xuICAgICAgbWFya1VwZGF0ZSh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgfVxuICB9O1xuXG4gIHVwZGF0ZUhvc3RUZXh0JDEgPSBmdW5jdGlvbiAoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG9sZFRleHQsIG5ld1RleHQpIHtcbiAgICAvLyBJZiB0aGUgdGV4dCBkaWZmZXJzLCBtYXJrIGl0IGFzIGFuIHVwZGF0ZS4gQWxsIHRoZSB3b3JrIGluIGRvbmUgaW4gY29tbWl0V29yay5cbiAgICBpZiAob2xkVGV4dCAhPT0gbmV3VGV4dCkge1xuICAgICAgbWFya1VwZGF0ZSh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBjdXRPZmZUYWlsSWZOZWVkZWQocmVuZGVyU3RhdGUsIGhhc1JlbmRlcmVkQVRhaWxGYWxsYmFjaykge1xuICBpZiAoZ2V0SXNIeWRyYXRpbmcoKSkge1xuICAgIC8vIElmIHdlJ3JlIGh5ZHJhdGluZywgd2Ugc2hvdWxkIGNvbnN1bWUgYXMgbWFueSBpdGVtcyBhcyB3ZSBjYW5cbiAgICAvLyBzbyB3ZSBkb24ndCBsZWF2ZSBhbnkgYmVoaW5kLlxuICAgIHJldHVybjtcbiAgfVxuXG4gIHN3aXRjaCAocmVuZGVyU3RhdGUudGFpbE1vZGUpIHtcbiAgICBjYXNlICdoaWRkZW4nOlxuICAgICAge1xuICAgICAgICAvLyBBbnkgaW5zZXJ0aW9ucyBhdCB0aGUgZW5kIG9mIHRoZSB0YWlsIGxpc3QgYWZ0ZXIgdGhpcyBwb2ludFxuICAgICAgICAvLyBzaG91bGQgYmUgaW52aXNpYmxlLiBJZiB0aGVyZSBhcmUgYWxyZWFkeSBtb3VudGVkIGJvdW5kYXJpZXNcbiAgICAgICAgLy8gYW55dGhpbmcgYmVmb3JlIHRoZW0gYXJlIG5vdCBjb25zaWRlcmVkIGZvciBjb2xsYXBzaW5nLlxuICAgICAgICAvLyBUaGVyZWZvcmUgd2UgbmVlZCB0byBnbyB0aHJvdWdoIHRoZSB3aG9sZSB0YWlsIHRvIGZpbmQgaWZcbiAgICAgICAgLy8gdGhlcmUgYXJlIGFueS5cbiAgICAgICAgdmFyIHRhaWxOb2RlID0gcmVuZGVyU3RhdGUudGFpbDtcbiAgICAgICAgdmFyIGxhc3RUYWlsTm9kZSA9IG51bGw7XG5cbiAgICAgICAgd2hpbGUgKHRhaWxOb2RlICE9PSBudWxsKSB7XG4gICAgICAgICAgaWYgKHRhaWxOb2RlLmFsdGVybmF0ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgbGFzdFRhaWxOb2RlID0gdGFpbE5vZGU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGFpbE5vZGUgPSB0YWlsTm9kZS5zaWJsaW5nO1xuICAgICAgICB9IC8vIE5leHQgd2UncmUgc2ltcGx5IGdvaW5nIHRvIGRlbGV0ZSBhbGwgaW5zZXJ0aW9ucyBhZnRlciB0aGVcbiAgICAgICAgLy8gbGFzdCByZW5kZXJlZCBpdGVtLlxuXG5cbiAgICAgICAgaWYgKGxhc3RUYWlsTm9kZSA9PT0gbnVsbCkge1xuICAgICAgICAgIC8vIEFsbCByZW1haW5pbmcgaXRlbXMgaW4gdGhlIHRhaWwgYXJlIGluc2VydGlvbnMuXG4gICAgICAgICAgcmVuZGVyU3RhdGUudGFpbCA9IG51bGw7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gRGV0YWNoIHRoZSBpbnNlcnRpb24gYWZ0ZXIgdGhlIGxhc3Qgbm9kZSB0aGF0IHdhcyBhbHJlYWR5XG4gICAgICAgICAgLy8gaW5zZXJ0ZWQuXG4gICAgICAgICAgbGFzdFRhaWxOb2RlLnNpYmxpbmcgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICBjYXNlICdjb2xsYXBzZWQnOlxuICAgICAge1xuICAgICAgICAvLyBBbnkgaW5zZXJ0aW9ucyBhdCB0aGUgZW5kIG9mIHRoZSB0YWlsIGxpc3QgYWZ0ZXIgdGhpcyBwb2ludFxuICAgICAgICAvLyBzaG91bGQgYmUgaW52aXNpYmxlLiBJZiB0aGVyZSBhcmUgYWxyZWFkeSBtb3VudGVkIGJvdW5kYXJpZXNcbiAgICAgICAgLy8gYW55dGhpbmcgYmVmb3JlIHRoZW0gYXJlIG5vdCBjb25zaWRlcmVkIGZvciBjb2xsYXBzaW5nLlxuICAgICAgICAvLyBUaGVyZWZvcmUgd2UgbmVlZCB0byBnbyB0aHJvdWdoIHRoZSB3aG9sZSB0YWlsIHRvIGZpbmQgaWZcbiAgICAgICAgLy8gdGhlcmUgYXJlIGFueS5cbiAgICAgICAgdmFyIF90YWlsTm9kZSA9IHJlbmRlclN0YXRlLnRhaWw7XG4gICAgICAgIHZhciBfbGFzdFRhaWxOb2RlID0gbnVsbDtcblxuICAgICAgICB3aGlsZSAoX3RhaWxOb2RlICE9PSBudWxsKSB7XG4gICAgICAgICAgaWYgKF90YWlsTm9kZS5hbHRlcm5hdGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIF9sYXN0VGFpbE5vZGUgPSBfdGFpbE5vZGU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgX3RhaWxOb2RlID0gX3RhaWxOb2RlLnNpYmxpbmc7XG4gICAgICAgIH0gLy8gTmV4dCB3ZSdyZSBzaW1wbHkgZ29pbmcgdG8gZGVsZXRlIGFsbCBpbnNlcnRpb25zIGFmdGVyIHRoZVxuICAgICAgICAvLyBsYXN0IHJlbmRlcmVkIGl0ZW0uXG5cblxuICAgICAgICBpZiAoX2xhc3RUYWlsTm9kZSA9PT0gbnVsbCkge1xuICAgICAgICAgIC8vIEFsbCByZW1haW5pbmcgaXRlbXMgaW4gdGhlIHRhaWwgYXJlIGluc2VydGlvbnMuXG4gICAgICAgICAgaWYgKCFoYXNSZW5kZXJlZEFUYWlsRmFsbGJhY2sgJiYgcmVuZGVyU3RhdGUudGFpbCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gV2Ugc3VzcGVuZGVkIGR1cmluZyB0aGUgaGVhZC4gV2Ugd2FudCB0byBzaG93IGF0IGxlYXN0IG9uZVxuICAgICAgICAgICAgLy8gcm93IGF0IHRoZSB0YWlsLiBTbyB3ZSdsbCBrZWVwIG9uIGFuZCBjdXQgb2ZmIHRoZSByZXN0LlxuICAgICAgICAgICAgcmVuZGVyU3RhdGUudGFpbC5zaWJsaW5nID0gbnVsbDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVuZGVyU3RhdGUudGFpbCA9IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIERldGFjaCB0aGUgaW5zZXJ0aW9uIGFmdGVyIHRoZSBsYXN0IG5vZGUgdGhhdCB3YXMgYWxyZWFkeVxuICAgICAgICAgIC8vIGluc2VydGVkLlxuICAgICAgICAgIF9sYXN0VGFpbE5vZGUuc2libGluZyA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjb21wbGV0ZVdvcmsoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKSB7XG4gIHZhciBuZXdQcm9wcyA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcztcblxuICBzd2l0Y2ggKHdvcmtJblByb2dyZXNzLnRhZykge1xuICAgIGNhc2UgSW5kZXRlcm1pbmF0ZUNvbXBvbmVudDpcbiAgICBjYXNlIExhenlDb21wb25lbnQ6XG4gICAgY2FzZSBTaW1wbGVNZW1vQ29tcG9uZW50OlxuICAgIGNhc2UgRnVuY3Rpb25Db21wb25lbnQ6XG4gICAgY2FzZSBGb3J3YXJkUmVmOlxuICAgIGNhc2UgRnJhZ21lbnQ6XG4gICAgY2FzZSBNb2RlOlxuICAgIGNhc2UgUHJvZmlsZXI6XG4gICAgY2FzZSBDb250ZXh0Q29uc3VtZXI6XG4gICAgY2FzZSBNZW1vQ29tcG9uZW50OlxuICAgICAgcmV0dXJuIG51bGw7XG5cbiAgICBjYXNlIENsYXNzQ29tcG9uZW50OlxuICAgICAge1xuICAgICAgICB2YXIgQ29tcG9uZW50ID0gd29ya0luUHJvZ3Jlc3MudHlwZTtcblxuICAgICAgICBpZiAoaXNDb250ZXh0UHJvdmlkZXIoQ29tcG9uZW50KSkge1xuICAgICAgICAgIHBvcENvbnRleHQod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICBjYXNlIEhvc3RSb290OlxuICAgICAge1xuICAgICAgICBwb3BIb3N0Q29udGFpbmVyKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgcG9wVG9wTGV2ZWxDb250ZXh0T2JqZWN0KHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgcmVzZXRXb3JrSW5Qcm9ncmVzc1ZlcnNpb25zKCk7XG4gICAgICAgIHZhciBmaWJlclJvb3QgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG5cbiAgICAgICAgaWYgKGZpYmVyUm9vdC5wZW5kaW5nQ29udGV4dCkge1xuICAgICAgICAgIGZpYmVyUm9vdC5jb250ZXh0ID0gZmliZXJSb290LnBlbmRpbmdDb250ZXh0O1xuICAgICAgICAgIGZpYmVyUm9vdC5wZW5kaW5nQ29udGV4dCA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY3VycmVudCA9PT0gbnVsbCB8fCBjdXJyZW50LmNoaWxkID09PSBudWxsKSB7XG4gICAgICAgICAgLy8gSWYgd2UgaHlkcmF0ZWQsIHBvcCBzbyB0aGF0IHdlIGNhbiBkZWxldGUgYW55IHJlbWFpbmluZyBjaGlsZHJlblxuICAgICAgICAgIC8vIHRoYXQgd2VyZW4ndCBoeWRyYXRlZC5cbiAgICAgICAgICB2YXIgd2FzSHlkcmF0ZWQgPSBwb3BIeWRyYXRpb25TdGF0ZSh3b3JrSW5Qcm9ncmVzcyk7XG5cbiAgICAgICAgICBpZiAod2FzSHlkcmF0ZWQpIHtcbiAgICAgICAgICAgIC8vIElmIHdlIGh5ZHJhdGVkLCB0aGVuIHdlJ2xsIG5lZWQgdG8gc2NoZWR1bGUgYW4gdXBkYXRlIGZvclxuICAgICAgICAgICAgLy8gdGhlIGNvbW1pdCBzaWRlLWVmZmVjdHMgb24gdGhlIHJvb3QuXG4gICAgICAgICAgICBtYXJrVXBkYXRlKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKCFmaWJlclJvb3QuaHlkcmF0ZSkge1xuICAgICAgICAgICAgLy8gU2NoZWR1bGUgYW4gZWZmZWN0IHRvIGNsZWFyIHRoaXMgY29udGFpbmVyIGF0IHRoZSBzdGFydCBvZiB0aGUgbmV4dCBjb21taXQuXG4gICAgICAgICAgICAvLyBUaGlzIGhhbmRsZXMgdGhlIGNhc2Ugb2YgUmVhY3QgcmVuZGVyaW5nIGludG8gYSBjb250YWluZXIgd2l0aCBwcmV2aW91cyBjaGlsZHJlbi5cbiAgICAgICAgICAgIC8vIEl0J3MgYWxzbyBzYWZlIHRvIGRvIGZvciB1cGRhdGVzIHRvbywgYmVjYXVzZSBjdXJyZW50LmNoaWxkIHdvdWxkIG9ubHkgYmUgbnVsbFxuICAgICAgICAgICAgLy8gaWYgdGhlIHByZXZpb3VzIHJlbmRlciB3YXMgbnVsbCAoc28gdGhlIHRoZSBjb250YWluZXIgd291bGQgYWxyZWFkeSBiZSBlbXB0eSkuXG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBTbmFwc2hvdDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB1cGRhdGVIb3N0Q29udGFpbmVyKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIHBvcEhvc3RDb250ZXh0KHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgdmFyIHJvb3RDb250YWluZXJJbnN0YW5jZSA9IGdldFJvb3RIb3N0Q29udGFpbmVyKCk7XG4gICAgICAgIHZhciB0eXBlID0gd29ya0luUHJvZ3Jlc3MudHlwZTtcblxuICAgICAgICBpZiAoY3VycmVudCAhPT0gbnVsbCAmJiB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUgIT0gbnVsbCkge1xuICAgICAgICAgIHVwZGF0ZUhvc3RDb21wb25lbnQkMShjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgdHlwZSwgbmV3UHJvcHMsIHJvb3RDb250YWluZXJJbnN0YW5jZSk7XG5cbiAgICAgICAgICBpZiAoY3VycmVudC5yZWYgIT09IHdvcmtJblByb2dyZXNzLnJlZikge1xuICAgICAgICAgICAgbWFya1JlZiQxKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKCFuZXdQcm9wcykge1xuICAgICAgICAgICAgaWYgKCEod29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlICE9PSBudWxsKSkge1xuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoIFwiV2UgbXVzdCBoYXZlIG5ldyBwcm9wcyBmb3IgbmV3IG1vdW50cy4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS5cIiApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IC8vIFRoaXMgY2FuIGhhcHBlbiB3aGVuIHdlIGFib3J0IHdvcmsuXG5cblxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIGN1cnJlbnRIb3N0Q29udGV4dCA9IGdldEhvc3RDb250ZXh0KCk7IC8vIFRPRE86IE1vdmUgY3JlYXRlSW5zdGFuY2UgdG8gYmVnaW5Xb3JrIGFuZCBrZWVwIGl0IG9uIGEgY29udGV4dFxuICAgICAgICAgIC8vIFwic3RhY2tcIiBhcyB0aGUgcGFyZW50LiBUaGVuIGFwcGVuZCBjaGlsZHJlbiBhcyB3ZSBnbyBpbiBiZWdpbldvcmtcbiAgICAgICAgICAvLyBvciBjb21wbGV0ZVdvcmsgZGVwZW5kaW5nIG9uIHdoZXRoZXIgd2Ugd2FudCB0byBhZGQgdGhlbSB0b3AtPmRvd24gb3JcbiAgICAgICAgICAvLyBib3R0b20tPnVwLiBUb3AtPmRvd24gaXMgZmFzdGVyIGluIElFMTEuXG5cbiAgICAgICAgICB2YXIgX3dhc0h5ZHJhdGVkID0gcG9wSHlkcmF0aW9uU3RhdGUod29ya0luUHJvZ3Jlc3MpO1xuXG4gICAgICAgICAgaWYgKF93YXNIeWRyYXRlZCkge1xuICAgICAgICAgICAgLy8gVE9ETzogTW92ZSB0aGlzIGFuZCBjcmVhdGVJbnN0YW5jZSBzdGVwIGludG8gdGhlIGJlZ2luUGhhc2VcbiAgICAgICAgICAgIC8vIHRvIGNvbnNvbGlkYXRlLlxuICAgICAgICAgICAgaWYgKHByZXBhcmVUb0h5ZHJhdGVIb3N0SW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MsIHJvb3RDb250YWluZXJJbnN0YW5jZSwgY3VycmVudEhvc3RDb250ZXh0KSkge1xuICAgICAgICAgICAgICAvLyBJZiBjaGFuZ2VzIHRvIHRoZSBoeWRyYXRlZCBub2RlIG5lZWQgdG8gYmUgYXBwbGllZCBhdCB0aGVcbiAgICAgICAgICAgICAgLy8gY29tbWl0LXBoYXNlIHdlIG1hcmsgdGhpcyBhcyBzdWNoLlxuICAgICAgICAgICAgICBtYXJrVXBkYXRlKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIGluc3RhbmNlID0gY3JlYXRlSW5zdGFuY2UodHlwZSwgbmV3UHJvcHMsIHJvb3RDb250YWluZXJJbnN0YW5jZSwgY3VycmVudEhvc3RDb250ZXh0LCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgICBhcHBlbmRBbGxDaGlsZHJlbihpbnN0YW5jZSwgd29ya0luUHJvZ3Jlc3MsIGZhbHNlLCBmYWxzZSk7XG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUgPSBpbnN0YW5jZTsgLy8gQ2VydGFpbiByZW5kZXJlcnMgcmVxdWlyZSBjb21taXQtdGltZSBlZmZlY3RzIGZvciBpbml0aWFsIG1vdW50LlxuICAgICAgICAgICAgLy8gKGVnIERPTSByZW5kZXJlciBzdXBwb3J0cyBhdXRvLWZvY3VzIGZvciBjZXJ0YWluIGVsZW1lbnRzKS5cbiAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSBzdWNoIHJlbmRlcmVycyBnZXQgc2NoZWR1bGVkIGZvciBsYXRlciB3b3JrLlxuXG4gICAgICAgICAgICBpZiAoZmluYWxpemVJbml0aWFsQ2hpbGRyZW4oaW5zdGFuY2UsIHR5cGUsIG5ld1Byb3BzLCByb290Q29udGFpbmVySW5zdGFuY2UpKSB7XG4gICAgICAgICAgICAgIG1hcmtVcGRhdGUod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh3b3JrSW5Qcm9ncmVzcy5yZWYgIT09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIElmIHRoZXJlIGlzIGEgcmVmIG9uIGEgaG9zdCBub2RlIHdlIG5lZWQgdG8gc2NoZWR1bGUgYSBjYWxsYmFja1xuICAgICAgICAgICAgbWFya1JlZiQxKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgIGNhc2UgSG9zdFRleHQ6XG4gICAgICB7XG4gICAgICAgIHZhciBuZXdUZXh0ID0gbmV3UHJvcHM7XG5cbiAgICAgICAgaWYgKGN1cnJlbnQgJiYgd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlICE9IG51bGwpIHtcbiAgICAgICAgICB2YXIgb2xkVGV4dCA9IGN1cnJlbnQubWVtb2l6ZWRQcm9wczsgLy8gSWYgd2UgaGF2ZSBhbiBhbHRlcm5hdGUsIHRoYXQgbWVhbnMgdGhpcyBpcyBhbiB1cGRhdGUgYW5kIHdlIG5lZWRcbiAgICAgICAgICAvLyB0byBzY2hlZHVsZSBhIHNpZGUtZWZmZWN0IHRvIGRvIHRoZSB1cGRhdGVzLlxuXG4gICAgICAgICAgdXBkYXRlSG9zdFRleHQkMShjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgb2xkVGV4dCwgbmV3VGV4dCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBuZXdUZXh0ICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgaWYgKCEod29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlICE9PSBudWxsKSkge1xuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoIFwiV2UgbXVzdCBoYXZlIG5ldyBwcm9wcyBmb3IgbmV3IG1vdW50cy4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS5cIiApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IC8vIFRoaXMgY2FuIGhhcHBlbiB3aGVuIHdlIGFib3J0IHdvcmsuXG5cbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgX3Jvb3RDb250YWluZXJJbnN0YW5jZSA9IGdldFJvb3RIb3N0Q29udGFpbmVyKCk7XG5cbiAgICAgICAgICB2YXIgX2N1cnJlbnRIb3N0Q29udGV4dCA9IGdldEhvc3RDb250ZXh0KCk7XG5cbiAgICAgICAgICB2YXIgX3dhc0h5ZHJhdGVkMiA9IHBvcEh5ZHJhdGlvblN0YXRlKHdvcmtJblByb2dyZXNzKTtcblxuICAgICAgICAgIGlmIChfd2FzSHlkcmF0ZWQyKSB7XG4gICAgICAgICAgICBpZiAocHJlcGFyZVRvSHlkcmF0ZUhvc3RUZXh0SW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MpKSB7XG4gICAgICAgICAgICAgIG1hcmtVcGRhdGUod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUgPSBjcmVhdGVUZXh0SW5zdGFuY2UobmV3VGV4dCwgX3Jvb3RDb250YWluZXJJbnN0YW5jZSwgX2N1cnJlbnRIb3N0Q29udGV4dCwgd29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgY2FzZSBTdXNwZW5zZUNvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgcG9wU3VzcGVuc2VDb250ZXh0KHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgdmFyIG5leHRTdGF0ZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG5cbiAgICAgICAgaWYgKCh3b3JrSW5Qcm9ncmVzcy5mbGFncyAmIERpZENhcHR1cmUpICE9PSBOb0ZsYWdzKSB7XG4gICAgICAgICAgLy8gU29tZXRoaW5nIHN1c3BlbmRlZC4gUmUtcmVuZGVyIHdpdGggdGhlIGZhbGxiYWNrIGNoaWxkcmVuLlxuICAgICAgICAgIHdvcmtJblByb2dyZXNzLmxhbmVzID0gcmVuZGVyTGFuZXM7IC8vIERvIG5vdCByZXNldCB0aGUgZWZmZWN0IGxpc3QuXG5cbiAgICAgICAgICBpZiAoICh3b3JrSW5Qcm9ncmVzcy5tb2RlICYgUHJvZmlsZU1vZGUpICE9PSBOb01vZGUpIHtcbiAgICAgICAgICAgIHRyYW5zZmVyQWN0dWFsRHVyYXRpb24od29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB3b3JrSW5Qcm9ncmVzcztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBuZXh0RGlkVGltZW91dCA9IG5leHRTdGF0ZSAhPT0gbnVsbDtcbiAgICAgICAgdmFyIHByZXZEaWRUaW1lb3V0ID0gZmFsc2U7XG5cbiAgICAgICAgaWYgKGN1cnJlbnQgPT09IG51bGwpIHtcbiAgICAgICAgICBpZiAod29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcy5mYWxsYmFjayAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBwb3BIeWRyYXRpb25TdGF0ZSh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBwcmV2U3RhdGUgPSBjdXJyZW50Lm1lbW9pemVkU3RhdGU7XG4gICAgICAgICAgcHJldkRpZFRpbWVvdXQgPSBwcmV2U3RhdGUgIT09IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobmV4dERpZFRpbWVvdXQgJiYgIXByZXZEaWRUaW1lb3V0KSB7XG4gICAgICAgICAgLy8gSWYgdGhpcyBzdWJ0cmVlZSBpcyBydW5uaW5nIGluIGJsb2NraW5nIG1vZGUgd2UgY2FuIHN1c3BlbmQsXG4gICAgICAgICAgLy8gb3RoZXJ3aXNlIHdlIHdvbid0IHN1c3BlbmQuXG4gICAgICAgICAgLy8gVE9ETzogVGhpcyB3aWxsIHN0aWxsIHN1c3BlbmQgYSBzeW5jaHJvbm91cyB0cmVlIGlmIGFueXRoaW5nXG4gICAgICAgICAgLy8gaW4gdGhlIGNvbmN1cnJlbnQgdHJlZSBhbHJlYWR5IHN1c3BlbmRlZCBkdXJpbmcgdGhpcyByZW5kZXIuXG4gICAgICAgICAgLy8gVGhpcyBpcyBhIGtub3duIGJ1Zy5cbiAgICAgICAgICBpZiAoKHdvcmtJblByb2dyZXNzLm1vZGUgJiBCbG9ja2luZ01vZGUpICE9PSBOb01vZGUpIHtcbiAgICAgICAgICAgIC8vIFRPRE86IE1vdmUgdGhpcyBiYWNrIHRvIHRocm93RXhjZXB0aW9uIGJlY2F1c2UgdGhpcyBpcyB0b28gbGF0ZVxuICAgICAgICAgICAgLy8gaWYgdGhpcyBpcyBhIGxhcmdlIHRyZWUgd2hpY2ggaXMgY29tbW9uIGZvciBpbml0aWFsIGxvYWRzLiBXZVxuICAgICAgICAgICAgLy8gZG9uJ3Qga25vdyBpZiB3ZSBzaG91bGQgcmVzdGFydCBhIHJlbmRlciBvciBub3QgdW50aWwgd2UgZ2V0XG4gICAgICAgICAgICAvLyB0aGlzIG1hcmtlciwgYW5kIHRoaXMgaXMgdG9vIGxhdGUuXG4gICAgICAgICAgICAvLyBJZiB0aGlzIHJlbmRlciBhbHJlYWR5IGhhZCBhIHBpbmcgb3IgbG93ZXIgcHJpIHVwZGF0ZXMsXG4gICAgICAgICAgICAvLyBhbmQgdGhpcyBpcyB0aGUgZmlyc3QgdGltZSB3ZSBrbm93IHdlJ3JlIGdvaW5nIHRvIHN1c3BlbmQgd2VcbiAgICAgICAgICAgIC8vIHNob3VsZCBiZSBhYmxlIHRvIGltbWVkaWF0ZWx5IHJlc3RhcnQgZnJvbSB3aXRoaW4gdGhyb3dFeGNlcHRpb24uXG4gICAgICAgICAgICB2YXIgaGFzSW52aXNpYmxlQ2hpbGRDb250ZXh0ID0gY3VycmVudCA9PT0gbnVsbCAmJiB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFByb3BzLnVuc3RhYmxlX2F2b2lkVGhpc0ZhbGxiYWNrICE9PSB0cnVlO1xuXG4gICAgICAgICAgICBpZiAoaGFzSW52aXNpYmxlQ2hpbGRDb250ZXh0IHx8IGhhc1N1c3BlbnNlQ29udGV4dChzdXNwZW5zZVN0YWNrQ3Vyc29yLmN1cnJlbnQsIEludmlzaWJsZVBhcmVudFN1c3BlbnNlQ29udGV4dCkpIHtcbiAgICAgICAgICAgICAgLy8gSWYgdGhpcyB3YXMgaW4gYW4gaW52aXNpYmxlIHRyZWUgb3IgYSBuZXcgcmVuZGVyLCB0aGVuIHNob3dpbmdcbiAgICAgICAgICAgICAgLy8gdGhpcyBib3VuZGFyeSBpcyBvay5cbiAgICAgICAgICAgICAgcmVuZGVyRGlkU3VzcGVuZCgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gT3RoZXJ3aXNlLCB3ZSdyZSBnb2luZyB0byBoYXZlIHRvIGhpZGUgY29udGVudCBzbyB3ZSBzaG91bGRcbiAgICAgICAgICAgICAgLy8gc3VzcGVuZCBmb3IgbG9uZ2VyIGlmIHBvc3NpYmxlLlxuICAgICAgICAgICAgICByZW5kZXJEaWRTdXNwZW5kRGVsYXlJZlBvc3NpYmxlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAge1xuICAgICAgICAgIC8vIFRPRE86IE9ubHkgc2NoZWR1bGUgdXBkYXRlcyBpZiB0aGVzZSB2YWx1ZXMgYXJlIG5vbiBlcXVhbCwgaS5lLiBpdCBjaGFuZ2VkLlxuICAgICAgICAgIGlmIChuZXh0RGlkVGltZW91dCB8fCBwcmV2RGlkVGltZW91dCkge1xuICAgICAgICAgICAgLy8gSWYgdGhpcyBib3VuZGFyeSBqdXN0IHRpbWVkIG91dCwgc2NoZWR1bGUgYW4gZWZmZWN0IHRvIGF0dGFjaCBhXG4gICAgICAgICAgICAvLyByZXRyeSBsaXN0ZW5lciB0byB0aGUgcHJvbWlzZS4gVGhpcyBmbGFnIGlzIGFsc28gdXNlZCB0byBoaWRlIHRoZVxuICAgICAgICAgICAgLy8gcHJpbWFyeSBjaGlsZHJlbi4gSW4gbXV0YXRpb24gbW9kZSwgd2UgYWxzbyBuZWVkIHRoZSBmbGFnIHRvXG4gICAgICAgICAgICAvLyAqdW5oaWRlKiBjaGlsZHJlbiB0aGF0IHdlcmUgcHJldmlvdXNseSBoaWRkZW4sIHNvIGNoZWNrIGlmIHRoaXNcbiAgICAgICAgICAgIC8vIGlzIGN1cnJlbnRseSB0aW1lZCBvdXQsIHRvby5cbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IFVwZGF0ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgIGNhc2UgSG9zdFBvcnRhbDpcbiAgICAgIHBvcEhvc3RDb250YWluZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgdXBkYXRlSG9zdENvbnRhaW5lcih3b3JrSW5Qcm9ncmVzcyk7XG5cbiAgICAgIGlmIChjdXJyZW50ID09PSBudWxsKSB7XG4gICAgICAgIHByZXBhcmVQb3J0YWxNb3VudCh3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUuY29udGFpbmVySW5mbyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBudWxsO1xuXG4gICAgY2FzZSBDb250ZXh0UHJvdmlkZXI6XG4gICAgICAvLyBQb3AgcHJvdmlkZXIgZmliZXJcbiAgICAgIHBvcFByb3ZpZGVyKHdvcmtJblByb2dyZXNzKTtcbiAgICAgIHJldHVybiBudWxsO1xuXG4gICAgY2FzZSBJbmNvbXBsZXRlQ2xhc3NDb21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIC8vIFNhbWUgYXMgY2xhc3MgY29tcG9uZW50IGNhc2UuIEkgcHV0IGl0IGRvd24gaGVyZSBzbyB0aGF0IHRoZSB0YWdzIGFyZVxuICAgICAgICAvLyBzZXF1ZW50aWFsIHRvIGVuc3VyZSB0aGlzIHN3aXRjaCBpcyBjb21waWxlZCB0byBhIGp1bXAgdGFibGUuXG4gICAgICAgIHZhciBfQ29tcG9uZW50ID0gd29ya0luUHJvZ3Jlc3MudHlwZTtcblxuICAgICAgICBpZiAoaXNDb250ZXh0UHJvdmlkZXIoX0NvbXBvbmVudCkpIHtcbiAgICAgICAgICBwb3BDb250ZXh0KHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgY2FzZSBTdXNwZW5zZUxpc3RDb21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIHBvcFN1c3BlbnNlQ29udGV4dCh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgIHZhciByZW5kZXJTdGF0ZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG5cbiAgICAgICAgaWYgKHJlbmRlclN0YXRlID09PSBudWxsKSB7XG4gICAgICAgICAgLy8gV2UncmUgcnVubmluZyBpbiB0aGUgZGVmYXVsdCwgXCJpbmRlcGVuZGVudFwiIG1vZGUuXG4gICAgICAgICAgLy8gV2UgZG9uJ3QgZG8gYW55dGhpbmcgaW4gdGhpcyBtb2RlLlxuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGRpZFN1c3BlbmRBbHJlYWR5ID0gKHdvcmtJblByb2dyZXNzLmZsYWdzICYgRGlkQ2FwdHVyZSkgIT09IE5vRmxhZ3M7XG4gICAgICAgIHZhciByZW5kZXJlZFRhaWwgPSByZW5kZXJTdGF0ZS5yZW5kZXJpbmc7XG5cbiAgICAgICAgaWYgKHJlbmRlcmVkVGFpbCA9PT0gbnVsbCkge1xuICAgICAgICAgIC8vIFdlIGp1c3QgcmVuZGVyZWQgdGhlIGhlYWQuXG4gICAgICAgICAgaWYgKCFkaWRTdXNwZW5kQWxyZWFkeSkge1xuICAgICAgICAgICAgLy8gVGhpcyBpcyB0aGUgZmlyc3QgcGFzcy4gV2UgbmVlZCB0byBmaWd1cmUgb3V0IGlmIGFueXRoaW5nIGlzIHN0aWxsXG4gICAgICAgICAgICAvLyBzdXNwZW5kZWQgaW4gdGhlIHJlbmRlcmVkIHNldC5cbiAgICAgICAgICAgIC8vIElmIG5ldyBjb250ZW50IHVuc3VzcGVuZGVkLCBidXQgdGhlcmUncyBzdGlsbCBzb21lIGNvbnRlbnQgdGhhdFxuICAgICAgICAgICAgLy8gZGlkbid0LiBUaGVuIHdlIG5lZWQgdG8gZG8gYSBzZWNvbmQgcGFzcyB0aGF0IGZvcmNlcyBldmVyeXRoaW5nXG4gICAgICAgICAgICAvLyB0byBrZWVwIHNob3dpbmcgdGhlaXIgZmFsbGJhY2tzLlxuICAgICAgICAgICAgLy8gV2UgbWlnaHQgYmUgc3VzcGVuZGVkIGlmIHNvbWV0aGluZyBpbiB0aGlzIHJlbmRlciBwYXNzIHN1c3BlbmRlZCwgb3JcbiAgICAgICAgICAgIC8vIHNvbWV0aGluZyBpbiB0aGUgcHJldmlvdXMgY29tbWl0dGVkIHBhc3Mgc3VzcGVuZGVkLiBPdGhlcndpc2UsXG4gICAgICAgICAgICAvLyB0aGVyZSdzIG5vIGNoYW5jZSBzbyB3ZSBjYW4gc2tpcCB0aGUgZXhwZW5zaXZlIGNhbGwgdG9cbiAgICAgICAgICAgIC8vIGZpbmRGaXJzdFN1c3BlbmRlZC5cbiAgICAgICAgICAgIHZhciBjYW5ub3RCZVN1c3BlbmRlZCA9IHJlbmRlckhhc05vdFN1c3BlbmRlZFlldCgpICYmIChjdXJyZW50ID09PSBudWxsIHx8IChjdXJyZW50LmZsYWdzICYgRGlkQ2FwdHVyZSkgPT09IE5vRmxhZ3MpO1xuXG4gICAgICAgICAgICBpZiAoIWNhbm5vdEJlU3VzcGVuZGVkKSB7XG4gICAgICAgICAgICAgIHZhciByb3cgPSB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcblxuICAgICAgICAgICAgICB3aGlsZSAocm93ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdmFyIHN1c3BlbmRlZCA9IGZpbmRGaXJzdFN1c3BlbmRlZChyb3cpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHN1c3BlbmRlZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgZGlkU3VzcGVuZEFscmVhZHkgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gRGlkQ2FwdHVyZTtcbiAgICAgICAgICAgICAgICAgIGN1dE9mZlRhaWxJZk5lZWRlZChyZW5kZXJTdGF0ZSwgZmFsc2UpOyAvLyBJZiB0aGlzIGlzIGEgbmV3bHkgc3VzcGVuZGVkIHRyZWUsIGl0IG1pZ2h0IG5vdCBnZXQgY29tbWl0dGVkIGFzXG4gICAgICAgICAgICAgICAgICAvLyBwYXJ0IG9mIHRoZSBzZWNvbmQgcGFzcy4gSW4gdGhhdCBjYXNlIG5vdGhpbmcgd2lsbCBzdWJzY3JpYmUgdG9cbiAgICAgICAgICAgICAgICAgIC8vIGl0cyB0aGVubmFibGVzLiBJbnN0ZWFkLCB3ZSdsbCB0cmFuc2ZlciBpdHMgdGhlbm5hYmxlcyB0byB0aGVcbiAgICAgICAgICAgICAgICAgIC8vIFN1c3BlbnNlTGlzdCBzbyB0aGF0IGl0IGNhbiByZXRyeSBpZiB0aGV5IHJlc29sdmUuXG4gICAgICAgICAgICAgICAgICAvLyBUaGVyZSBtaWdodCBiZSBtdWx0aXBsZSBvZiB0aGVzZSBpbiB0aGUgbGlzdCBidXQgc2luY2Ugd2UncmVcbiAgICAgICAgICAgICAgICAgIC8vIGdvaW5nIHRvIHdhaXQgZm9yIGFsbCBvZiB0aGVtIGFueXdheSwgaXQgZG9lc24ndCByZWFsbHkgbWF0dGVyXG4gICAgICAgICAgICAgICAgICAvLyB3aGljaCBvbmVzIGdldHMgdG8gcGluZy4gSW4gdGhlb3J5IHdlIGNvdWxkIGdldCBjbGV2ZXIgYW5kIGtlZXBcbiAgICAgICAgICAgICAgICAgIC8vIHRyYWNrIG9mIGhvdyBtYW55IGRlcGVuZGVuY2llcyByZW1haW4gYnV0IGl0IGdldHMgdHJpY2t5IGJlY2F1c2VcbiAgICAgICAgICAgICAgICAgIC8vIGluIHRoZSBtZWFudGltZSwgd2UgY2FuIGFkZC9yZW1vdmUvY2hhbmdlIGl0ZW1zIGFuZCBkZXBlbmRlbmNpZXMuXG4gICAgICAgICAgICAgICAgICAvLyBXZSBtaWdodCBiYWlsIG91dCBvZiB0aGUgbG9vcCBiZWZvcmUgZmluZGluZyBhbnkgYnV0IHRoYXRcbiAgICAgICAgICAgICAgICAgIC8vIGRvZXNuJ3QgbWF0dGVyIHNpbmNlIHRoYXQgbWVhbnMgdGhhdCB0aGUgb3RoZXIgYm91bmRhcmllcyB0aGF0XG4gICAgICAgICAgICAgICAgICAvLyB3ZSBkaWQgZmluZCBhbHJlYWR5IGhhcyB0aGVpciBsaXN0ZW5lcnMgYXR0YWNoZWQuXG5cbiAgICAgICAgICAgICAgICAgIHZhciBuZXdUaGVubmFibGVzID0gc3VzcGVuZGVkLnVwZGF0ZVF1ZXVlO1xuXG4gICAgICAgICAgICAgICAgICBpZiAobmV3VGhlbm5hYmxlcyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZSA9IG5ld1RoZW5uYWJsZXM7XG4gICAgICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IFVwZGF0ZTtcbiAgICAgICAgICAgICAgICAgIH0gLy8gUmVyZW5kZXIgdGhlIHdob2xlIGxpc3QsIGJ1dCB0aGlzIHRpbWUsIHdlJ2xsIGZvcmNlIGZhbGxiYWNrc1xuICAgICAgICAgICAgICAgICAgLy8gdG8gc3RheSBpbiBwbGFjZS5cbiAgICAgICAgICAgICAgICAgIC8vIFJlc2V0IHRoZSBlZmZlY3QgbGlzdCBiZWZvcmUgZG9pbmcgdGhlIHNlY29uZCBwYXNzIHNpbmNlIHRoYXQncyBub3cgaW52YWxpZC5cblxuXG4gICAgICAgICAgICAgICAgICBpZiAocmVuZGVyU3RhdGUubGFzdEVmZmVjdCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5maXJzdEVmZmVjdCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLmxhc3RFZmZlY3QgPSByZW5kZXJTdGF0ZS5sYXN0RWZmZWN0OyAvLyBSZXNldCB0aGUgY2hpbGQgZmliZXJzIHRvIHRoZWlyIG9yaWdpbmFsIHN0YXRlLlxuXG4gICAgICAgICAgICAgICAgICByZXNldENoaWxkRmliZXJzKHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcyk7IC8vIFNldCB1cCB0aGUgU3VzcGVuc2UgQ29udGV4dCB0byBmb3JjZSBzdXNwZW5zZSBhbmQgaW1tZWRpYXRlbHlcbiAgICAgICAgICAgICAgICAgIC8vIHJlcmVuZGVyIHRoZSBjaGlsZHJlbi5cblxuICAgICAgICAgICAgICAgICAgcHVzaFN1c3BlbnNlQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgc2V0U2hhbGxvd1N1c3BlbnNlQ29udGV4dChzdXNwZW5zZVN0YWNrQ3Vyc29yLmN1cnJlbnQsIEZvcmNlU3VzcGVuc2VGYWxsYmFjaykpO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHdvcmtJblByb2dyZXNzLmNoaWxkO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJvdyA9IHJvdy5zaWJsaW5nO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChyZW5kZXJTdGF0ZS50YWlsICE9PSBudWxsICYmIG5vdygpID4gZ2V0UmVuZGVyVGFyZ2V0VGltZSgpKSB7XG4gICAgICAgICAgICAgIC8vIFdlIGhhdmUgYWxyZWFkeSBwYXNzZWQgb3VyIENQVSBkZWFkbGluZSBidXQgd2Ugc3RpbGwgaGF2ZSByb3dzXG4gICAgICAgICAgICAgIC8vIGxlZnQgaW4gdGhlIHRhaWwuIFdlJ2xsIGp1c3QgZ2l2ZSB1cCBmdXJ0aGVyIGF0dGVtcHRzIHRvIHJlbmRlclxuICAgICAgICAgICAgICAvLyB0aGUgbWFpbiBjb250ZW50IGFuZCBvbmx5IHJlbmRlciBmYWxsYmFja3MuXG4gICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IERpZENhcHR1cmU7XG4gICAgICAgICAgICAgIGRpZFN1c3BlbmRBbHJlYWR5ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgY3V0T2ZmVGFpbElmTmVlZGVkKHJlbmRlclN0YXRlLCBmYWxzZSk7IC8vIFNpbmNlIG5vdGhpbmcgYWN0dWFsbHkgc3VzcGVuZGVkLCB0aGVyZSB3aWxsIG5vdGhpbmcgdG8gcGluZyB0aGlzXG4gICAgICAgICAgICAgIC8vIHRvIGdldCBpdCBzdGFydGVkIGJhY2sgdXAgdG8gYXR0ZW1wdCB0aGUgbmV4dCBpdGVtLiBXaGlsZSBpbiB0ZXJtc1xuICAgICAgICAgICAgICAvLyBvZiBwcmlvcml0eSB0aGlzIHdvcmsgaGFzIHRoZSBzYW1lIHByaW9yaXR5IGFzIHRoaXMgY3VycmVudCByZW5kZXIsXG4gICAgICAgICAgICAgIC8vIGl0J3Mgbm90IHBhcnQgb2YgdGhlIHNhbWUgdHJhbnNpdGlvbiBvbmNlIHRoZSB0cmFuc2l0aW9uIGhhc1xuICAgICAgICAgICAgICAvLyBjb21taXR0ZWQuIElmIGl0J3Mgc3luYywgd2Ugc3RpbGwgd2FudCB0byB5aWVsZCBzbyB0aGF0IGl0IGNhbiBiZVxuICAgICAgICAgICAgICAvLyBwYWludGVkLiBDb25jZXB0dWFsbHksIHRoaXMgaXMgcmVhbGx5IHRoZSBzYW1lIGFzIHBpbmdpbmcuXG4gICAgICAgICAgICAgIC8vIFdlIGNhbiB1c2UgYW55IFJldHJ5TGFuZSBldmVuIGlmIGl0J3MgdGhlIG9uZSBjdXJyZW50bHkgcmVuZGVyaW5nXG4gICAgICAgICAgICAgIC8vIHNpbmNlIHdlJ3JlIGxlYXZpbmcgaXQgYmVoaW5kIG9uIHRoaXMgbm9kZS5cblxuICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5sYW5lcyA9IFNvbWVSZXRyeUxhbmU7XG5cbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG1hcmtTcGF3bmVkV29yayhTb21lUmV0cnlMYW5lKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjdXRPZmZUYWlsSWZOZWVkZWQocmVuZGVyU3RhdGUsIGZhbHNlKTtcbiAgICAgICAgICB9IC8vIE5leHQgd2UncmUgZ29pbmcgdG8gcmVuZGVyIHRoZSB0YWlsLlxuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gQXBwZW5kIHRoZSByZW5kZXJlZCByb3cgdG8gdGhlIGNoaWxkIGxpc3QuXG4gICAgICAgICAgaWYgKCFkaWRTdXNwZW5kQWxyZWFkeSkge1xuICAgICAgICAgICAgdmFyIF9zdXNwZW5kZWQgPSBmaW5kRmlyc3RTdXNwZW5kZWQocmVuZGVyZWRUYWlsKTtcblxuICAgICAgICAgICAgaWYgKF9zdXNwZW5kZWQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gRGlkQ2FwdHVyZTtcbiAgICAgICAgICAgICAgZGlkU3VzcGVuZEFscmVhZHkgPSB0cnVlOyAvLyBFbnN1cmUgd2UgdHJhbnNmZXIgdGhlIHVwZGF0ZSBxdWV1ZSB0byB0aGUgcGFyZW50IHNvIHRoYXQgaXQgZG9lc24ndFxuICAgICAgICAgICAgICAvLyBnZXQgbG9zdCBpZiB0aGlzIHJvdyBlbmRzIHVwIGRyb3BwZWQgZHVyaW5nIGEgc2Vjb25kIHBhc3MuXG5cbiAgICAgICAgICAgICAgdmFyIF9uZXdUaGVubmFibGVzID0gX3N1c3BlbmRlZC51cGRhdGVRdWV1ZTtcblxuICAgICAgICAgICAgICBpZiAoX25ld1RoZW5uYWJsZXMgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZSA9IF9uZXdUaGVubmFibGVzO1xuICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IFVwZGF0ZTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGN1dE9mZlRhaWxJZk5lZWRlZChyZW5kZXJTdGF0ZSwgdHJ1ZSk7IC8vIFRoaXMgbWlnaHQgaGF2ZSBiZWVuIG1vZGlmaWVkLlxuXG4gICAgICAgICAgICAgIGlmIChyZW5kZXJTdGF0ZS50YWlsID09PSBudWxsICYmIHJlbmRlclN0YXRlLnRhaWxNb2RlID09PSAnaGlkZGVuJyAmJiAhcmVuZGVyZWRUYWlsLmFsdGVybmF0ZSAmJiAhZ2V0SXNIeWRyYXRpbmcoKSAvLyBXZSBkb24ndCBjdXQgaXQgaWYgd2UncmUgaHlkcmF0aW5nLlxuICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgIC8vIFdlIG5lZWQgdG8gZGVsZXRlIHRoZSByb3cgd2UganVzdCByZW5kZXJlZC5cbiAgICAgICAgICAgICAgICAgIC8vIFJlc2V0IHRoZSBlZmZlY3QgbGlzdCB0byB3aGF0IGl0IHdhcyBiZWZvcmUgd2UgcmVuZGVyZWQgdGhpc1xuICAgICAgICAgICAgICAgICAgLy8gY2hpbGQuIFRoZSBuZXN0ZWQgY2hpbGRyZW4gaGF2ZSBhbHJlYWR5IGFwcGVuZGVkIHRoZW1zZWx2ZXMuXG4gICAgICAgICAgICAgICAgICB2YXIgbGFzdEVmZmVjdCA9IHdvcmtJblByb2dyZXNzLmxhc3RFZmZlY3QgPSByZW5kZXJTdGF0ZS5sYXN0RWZmZWN0OyAvLyBSZW1vdmUgYW55IGVmZmVjdHMgdGhhdCB3ZXJlIGFwcGVuZGVkIGFmdGVyIHRoaXMgcG9pbnQuXG5cbiAgICAgICAgICAgICAgICAgIGlmIChsYXN0RWZmZWN0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGxhc3RFZmZlY3QubmV4dEVmZmVjdCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICB9IC8vIFdlJ3JlIGRvbmUuXG5cblxuICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmICggLy8gVGhlIHRpbWUgaXQgdG9vayB0byByZW5kZXIgbGFzdCByb3cgaXMgZ3JlYXRlciB0aGFuIHRoZSByZW1haW5pbmdcbiAgICAgICAgICAgIC8vIHRpbWUgd2UgaGF2ZSB0byByZW5kZXIuIFNvIHJlbmRlcmluZyBvbmUgbW9yZSByb3cgd291bGQgbGlrZWx5XG4gICAgICAgICAgICAvLyBleGNlZWQgaXQuXG4gICAgICAgICAgICBub3coKSAqIDIgLSByZW5kZXJTdGF0ZS5yZW5kZXJpbmdTdGFydFRpbWUgPiBnZXRSZW5kZXJUYXJnZXRUaW1lKCkgJiYgcmVuZGVyTGFuZXMgIT09IE9mZnNjcmVlbkxhbmUpIHtcbiAgICAgICAgICAgICAgLy8gV2UgaGF2ZSBub3cgcGFzc2VkIG91ciBDUFUgZGVhZGxpbmUgYW5kIHdlJ2xsIGp1c3QgZ2l2ZSB1cCBmdXJ0aGVyXG4gICAgICAgICAgICAgIC8vIGF0dGVtcHRzIHRvIHJlbmRlciB0aGUgbWFpbiBjb250ZW50IGFuZCBvbmx5IHJlbmRlciBmYWxsYmFja3MuXG4gICAgICAgICAgICAgIC8vIFRoZSBhc3N1bXB0aW9uIGlzIHRoYXQgdGhpcyBpcyB1c3VhbGx5IGZhc3Rlci5cbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gRGlkQ2FwdHVyZTtcbiAgICAgICAgICAgICAgZGlkU3VzcGVuZEFscmVhZHkgPSB0cnVlO1xuICAgICAgICAgICAgICBjdXRPZmZUYWlsSWZOZWVkZWQocmVuZGVyU3RhdGUsIGZhbHNlKTsgLy8gU2luY2Ugbm90aGluZyBhY3R1YWxseSBzdXNwZW5kZWQsIHRoZXJlIHdpbGwgbm90aGluZyB0byBwaW5nIHRoaXNcbiAgICAgICAgICAgICAgLy8gdG8gZ2V0IGl0IHN0YXJ0ZWQgYmFjayB1cCB0byBhdHRlbXB0IHRoZSBuZXh0IGl0ZW0uIFdoaWxlIGluIHRlcm1zXG4gICAgICAgICAgICAgIC8vIG9mIHByaW9yaXR5IHRoaXMgd29yayBoYXMgdGhlIHNhbWUgcHJpb3JpdHkgYXMgdGhpcyBjdXJyZW50IHJlbmRlcixcbiAgICAgICAgICAgICAgLy8gaXQncyBub3QgcGFydCBvZiB0aGUgc2FtZSB0cmFuc2l0aW9uIG9uY2UgdGhlIHRyYW5zaXRpb24gaGFzXG4gICAgICAgICAgICAgIC8vIGNvbW1pdHRlZC4gSWYgaXQncyBzeW5jLCB3ZSBzdGlsbCB3YW50IHRvIHlpZWxkIHNvIHRoYXQgaXQgY2FuIGJlXG4gICAgICAgICAgICAgIC8vIHBhaW50ZWQuIENvbmNlcHR1YWxseSwgdGhpcyBpcyByZWFsbHkgdGhlIHNhbWUgYXMgcGluZ2luZy5cbiAgICAgICAgICAgICAgLy8gV2UgY2FuIHVzZSBhbnkgUmV0cnlMYW5lIGV2ZW4gaWYgaXQncyB0aGUgb25lIGN1cnJlbnRseSByZW5kZXJpbmdcbiAgICAgICAgICAgICAgLy8gc2luY2Ugd2UncmUgbGVhdmluZyBpdCBiZWhpbmQgb24gdGhpcyBub2RlLlxuXG4gICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLmxhbmVzID0gU29tZVJldHJ5TGFuZTtcblxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbWFya1NwYXduZWRXb3JrKFNvbWVSZXRyeUxhbmUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHJlbmRlclN0YXRlLmlzQmFja3dhcmRzKSB7XG4gICAgICAgICAgICAvLyBUaGUgZWZmZWN0IGxpc3Qgb2YgdGhlIGJhY2t3YXJkcyB0YWlsIHdpbGwgaGF2ZSBiZWVuIGFkZGVkXG4gICAgICAgICAgICAvLyB0byB0aGUgZW5kLiBUaGlzIGJyZWFrcyB0aGUgZ3VhcmFudGVlIHRoYXQgbGlmZS1jeWNsZXMgZmlyZSBpblxuICAgICAgICAgICAgLy8gc2libGluZyBvcmRlciBidXQgdGhhdCBpc24ndCBhIHN0cm9uZyBndWFyYW50ZWUgcHJvbWlzZWQgYnkgUmVhY3QuXG4gICAgICAgICAgICAvLyBFc3BlY2lhbGx5IHNpbmNlIHRoZXNlIG1pZ2h0IGFsc28ganVzdCBwb3AgaW4gZHVyaW5nIGZ1dHVyZSBjb21taXRzLlxuICAgICAgICAgICAgLy8gQXBwZW5kIHRvIHRoZSBiZWdpbm5pbmcgb2YgdGhlIGxpc3QuXG4gICAgICAgICAgICByZW5kZXJlZFRhaWwuc2libGluZyA9IHdvcmtJblByb2dyZXNzLmNoaWxkO1xuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MuY2hpbGQgPSByZW5kZXJlZFRhaWw7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBwcmV2aW91c1NpYmxpbmcgPSByZW5kZXJTdGF0ZS5sYXN0O1xuXG4gICAgICAgICAgICBpZiAocHJldmlvdXNTaWJsaW5nICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIHByZXZpb3VzU2libGluZy5zaWJsaW5nID0gcmVuZGVyZWRUYWlsO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MuY2hpbGQgPSByZW5kZXJlZFRhaWw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJlbmRlclN0YXRlLmxhc3QgPSByZW5kZXJlZFRhaWw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJlbmRlclN0YXRlLnRhaWwgIT09IG51bGwpIHtcbiAgICAgICAgICAvLyBXZSBzdGlsbCBoYXZlIHRhaWwgcm93cyB0byByZW5kZXIuXG4gICAgICAgICAgLy8gUG9wIGEgcm93LlxuICAgICAgICAgIHZhciBuZXh0ID0gcmVuZGVyU3RhdGUudGFpbDtcbiAgICAgICAgICByZW5kZXJTdGF0ZS5yZW5kZXJpbmcgPSBuZXh0O1xuICAgICAgICAgIHJlbmRlclN0YXRlLnRhaWwgPSBuZXh0LnNpYmxpbmc7XG4gICAgICAgICAgcmVuZGVyU3RhdGUubGFzdEVmZmVjdCA9IHdvcmtJblByb2dyZXNzLmxhc3RFZmZlY3Q7XG4gICAgICAgICAgcmVuZGVyU3RhdGUucmVuZGVyaW5nU3RhcnRUaW1lID0gbm93KCk7XG4gICAgICAgICAgbmV4dC5zaWJsaW5nID0gbnVsbDsgLy8gUmVzdG9yZSB0aGUgY29udGV4dC5cbiAgICAgICAgICAvLyBUT0RPOiBXZSBjYW4gcHJvYmFibHkganVzdCBhdm9pZCBwb3BwaW5nIGl0IGluc3RlYWQgYW5kIG9ubHlcbiAgICAgICAgICAvLyBzZXR0aW5nIGl0IHRoZSBmaXJzdCB0aW1lIHdlIGdvIGZyb20gbm90IHN1c3BlbmRlZCB0byBzdXNwZW5kZWQuXG5cbiAgICAgICAgICB2YXIgc3VzcGVuc2VDb250ZXh0ID0gc3VzcGVuc2VTdGFja0N1cnNvci5jdXJyZW50O1xuXG4gICAgICAgICAgaWYgKGRpZFN1c3BlbmRBbHJlYWR5KSB7XG4gICAgICAgICAgICBzdXNwZW5zZUNvbnRleHQgPSBzZXRTaGFsbG93U3VzcGVuc2VDb250ZXh0KHN1c3BlbnNlQ29udGV4dCwgRm9yY2VTdXNwZW5zZUZhbGxiYWNrKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3VzcGVuc2VDb250ZXh0ID0gc2V0RGVmYXVsdFNoYWxsb3dTdXNwZW5zZUNvbnRleHQoc3VzcGVuc2VDb250ZXh0KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBwdXNoU3VzcGVuc2VDb250ZXh0KHdvcmtJblByb2dyZXNzLCBzdXNwZW5zZUNvbnRleHQpOyAvLyBEbyBhIHBhc3Mgb3ZlciB0aGUgbmV4dCByb3cuXG5cbiAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgY2FzZSBGdW5kYW1lbnRhbENvbXBvbmVudDpcbiAgICAgIHtcblxuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgIGNhc2UgU2NvcGVDb21wb25lbnQ6XG4gICAgICB7XG5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICBjYXNlIEJsb2NrOlxuXG4gICAgICBicmVhaztcblxuICAgIGNhc2UgT2Zmc2NyZWVuQ29tcG9uZW50OlxuICAgIGNhc2UgTGVnYWN5SGlkZGVuQ29tcG9uZW50OlxuICAgICAge1xuICAgICAgICBwb3BSZW5kZXJMYW5lcyh3b3JrSW5Qcm9ncmVzcyk7XG5cbiAgICAgICAgaWYgKGN1cnJlbnQgIT09IG51bGwpIHtcbiAgICAgICAgICB2YXIgX25leHRTdGF0ZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG4gICAgICAgICAgdmFyIF9wcmV2U3RhdGUgPSBjdXJyZW50Lm1lbW9pemVkU3RhdGU7XG4gICAgICAgICAgdmFyIHByZXZJc0hpZGRlbiA9IF9wcmV2U3RhdGUgIT09IG51bGw7XG4gICAgICAgICAgdmFyIG5leHRJc0hpZGRlbiA9IF9uZXh0U3RhdGUgIT09IG51bGw7XG5cbiAgICAgICAgICBpZiAocHJldklzSGlkZGVuICE9PSBuZXh0SXNIaWRkZW4gJiYgbmV3UHJvcHMubW9kZSAhPT0gJ3Vuc3RhYmxlLWRlZmVyLXdpdGhvdXQtaGlkaW5nJykge1xuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gVXBkYXRlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICB9XG5cbiAge1xuICAgIHtcbiAgICAgIHRocm93IEVycm9yKCBcIlVua25vd24gdW5pdCBvZiB3b3JrIHRhZyAoXCIgKyB3b3JrSW5Qcm9ncmVzcy50YWcgKyBcIikuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCIgKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gdW53aW5kV29yayh3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpIHtcbiAgc3dpdGNoICh3b3JrSW5Qcm9ncmVzcy50YWcpIHtcbiAgICBjYXNlIENsYXNzQ29tcG9uZW50OlxuICAgICAge1xuICAgICAgICB2YXIgQ29tcG9uZW50ID0gd29ya0luUHJvZ3Jlc3MudHlwZTtcblxuICAgICAgICBpZiAoaXNDb250ZXh0UHJvdmlkZXIoQ29tcG9uZW50KSkge1xuICAgICAgICAgIHBvcENvbnRleHQod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGZsYWdzID0gd29ya0luUHJvZ3Jlc3MuZmxhZ3M7XG5cbiAgICAgICAgaWYgKGZsYWdzICYgU2hvdWxkQ2FwdHVyZSkge1xuICAgICAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzID0gZmxhZ3MgJiB+U2hvdWxkQ2FwdHVyZSB8IERpZENhcHR1cmU7XG5cbiAgICAgICAgICBpZiAoICh3b3JrSW5Qcm9ncmVzcy5tb2RlICYgUHJvZmlsZU1vZGUpICE9PSBOb01vZGUpIHtcbiAgICAgICAgICAgIHRyYW5zZmVyQWN0dWFsRHVyYXRpb24od29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB3b3JrSW5Qcm9ncmVzcztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgY2FzZSBIb3N0Um9vdDpcbiAgICAgIHtcbiAgICAgICAgcG9wSG9zdENvbnRhaW5lcih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgIHBvcFRvcExldmVsQ29udGV4dE9iamVjdCh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgIHJlc2V0V29ya0luUHJvZ3Jlc3NWZXJzaW9ucygpO1xuICAgICAgICB2YXIgX2ZsYWdzID0gd29ya0luUHJvZ3Jlc3MuZmxhZ3M7XG5cbiAgICAgICAgaWYgKCEoKF9mbGFncyAmIERpZENhcHR1cmUpID09PSBOb0ZsYWdzKSkge1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKCBcIlRoZSByb290IGZhaWxlZCB0byB1bm1vdW50IGFmdGVyIGFuIGVycm9yLiBUaGlzIGlzIGxpa2VseSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCIgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyA9IF9mbGFncyAmIH5TaG91bGRDYXB0dXJlIHwgRGlkQ2FwdHVyZTtcbiAgICAgICAgcmV0dXJuIHdvcmtJblByb2dyZXNzO1xuICAgICAgfVxuXG4gICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAge1xuICAgICAgICAvLyBUT0RPOiBwb3BIeWRyYXRpb25TdGF0ZVxuICAgICAgICBwb3BIb3N0Q29udGV4dCh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgY2FzZSBTdXNwZW5zZUNvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgcG9wU3VzcGVuc2VDb250ZXh0KHdvcmtJblByb2dyZXNzKTtcblxuICAgICAgICB2YXIgX2ZsYWdzMiA9IHdvcmtJblByb2dyZXNzLmZsYWdzO1xuXG4gICAgICAgIGlmIChfZmxhZ3MyICYgU2hvdWxkQ2FwdHVyZSkge1xuICAgICAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzID0gX2ZsYWdzMiAmIH5TaG91bGRDYXB0dXJlIHwgRGlkQ2FwdHVyZTsgLy8gQ2FwdHVyZWQgYSBzdXNwZW5zZSBlZmZlY3QuIFJlLXJlbmRlciB0aGUgYm91bmRhcnkuXG5cbiAgICAgICAgICBpZiAoICh3b3JrSW5Qcm9ncmVzcy5tb2RlICYgUHJvZmlsZU1vZGUpICE9PSBOb01vZGUpIHtcbiAgICAgICAgICAgIHRyYW5zZmVyQWN0dWFsRHVyYXRpb24od29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB3b3JrSW5Qcm9ncmVzcztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgY2FzZSBTdXNwZW5zZUxpc3RDb21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIHBvcFN1c3BlbnNlQ29udGV4dCh3b3JrSW5Qcm9ncmVzcyk7IC8vIFN1c3BlbnNlTGlzdCBkb2Vzbid0IGFjdHVhbGx5IGNhdGNoIGFueXRoaW5nLiBJdCBzaG91bGQndmUgYmVlblxuICAgICAgICAvLyBjYXVnaHQgYnkgYSBuZXN0ZWQgYm91bmRhcnkuIElmIG5vdCwgaXQgc2hvdWxkIGJ1YmJsZSB0aHJvdWdoLlxuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgY2FzZSBIb3N0UG9ydGFsOlxuICAgICAgcG9wSG9zdENvbnRhaW5lcih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICByZXR1cm4gbnVsbDtcblxuICAgIGNhc2UgQ29udGV4dFByb3ZpZGVyOlxuICAgICAgcG9wUHJvdmlkZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgcmV0dXJuIG51bGw7XG5cbiAgICBjYXNlIE9mZnNjcmVlbkNvbXBvbmVudDpcbiAgICBjYXNlIExlZ2FjeUhpZGRlbkNvbXBvbmVudDpcbiAgICAgIHBvcFJlbmRlckxhbmVzKHdvcmtJblByb2dyZXNzKTtcbiAgICAgIHJldHVybiBudWxsO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbmZ1bmN0aW9uIHVud2luZEludGVycnVwdGVkV29yayhpbnRlcnJ1cHRlZFdvcmspIHtcbiAgc3dpdGNoIChpbnRlcnJ1cHRlZFdvcmsudGFnKSB7XG4gICAgY2FzZSBDbGFzc0NvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgdmFyIGNoaWxkQ29udGV4dFR5cGVzID0gaW50ZXJydXB0ZWRXb3JrLnR5cGUuY2hpbGRDb250ZXh0VHlwZXM7XG5cbiAgICAgICAgaWYgKGNoaWxkQ29udGV4dFR5cGVzICE9PSBudWxsICYmIGNoaWxkQ29udGV4dFR5cGVzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBwb3BDb250ZXh0KGludGVycnVwdGVkV29yayk7XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgICB7XG4gICAgICAgIHBvcEhvc3RDb250YWluZXIoaW50ZXJydXB0ZWRXb3JrKTtcbiAgICAgICAgcG9wVG9wTGV2ZWxDb250ZXh0T2JqZWN0KGludGVycnVwdGVkV29yayk7XG4gICAgICAgIHJlc2V0V29ya0luUHJvZ3Jlc3NWZXJzaW9ucygpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgcG9wSG9zdENvbnRleHQoaW50ZXJydXB0ZWRXb3JrKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICBjYXNlIEhvc3RQb3J0YWw6XG4gICAgICBwb3BIb3N0Q29udGFpbmVyKGludGVycnVwdGVkV29yayk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgU3VzcGVuc2VDb21wb25lbnQ6XG4gICAgICBwb3BTdXNwZW5zZUNvbnRleHQoaW50ZXJydXB0ZWRXb3JrKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBTdXNwZW5zZUxpc3RDb21wb25lbnQ6XG4gICAgICBwb3BTdXNwZW5zZUNvbnRleHQoaW50ZXJydXB0ZWRXb3JrKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBDb250ZXh0UHJvdmlkZXI6XG4gICAgICBwb3BQcm92aWRlcihpbnRlcnJ1cHRlZFdvcmspO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIE9mZnNjcmVlbkNvbXBvbmVudDpcbiAgICBjYXNlIExlZ2FjeUhpZGRlbkNvbXBvbmVudDpcbiAgICAgIHBvcFJlbmRlckxhbmVzKGludGVycnVwdGVkV29yayk7XG4gICAgICBicmVhaztcbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVDYXB0dXJlZFZhbHVlKHZhbHVlLCBzb3VyY2UpIHtcbiAgLy8gSWYgdGhlIHZhbHVlIGlzIGFuIGVycm9yLCBjYWxsIHRoaXMgZnVuY3Rpb24gaW1tZWRpYXRlbHkgYWZ0ZXIgaXQgaXMgdGhyb3duXG4gIC8vIHNvIHRoZSBzdGFjayBpcyBhY2N1cmF0ZS5cbiAgcmV0dXJuIHtcbiAgICB2YWx1ZTogdmFsdWUsXG4gICAgc291cmNlOiBzb3VyY2UsXG4gICAgc3RhY2s6IGdldFN0YWNrQnlGaWJlckluRGV2QW5kUHJvZChzb3VyY2UpXG4gIH07XG59XG5cbi8vIFRoaXMgbW9kdWxlIGlzIGZvcmtlZCBpbiBkaWZmZXJlbnQgZW52aXJvbm1lbnRzLlxuLy8gQnkgZGVmYXVsdCwgcmV0dXJuIGB0cnVlYCB0byBsb2cgZXJyb3JzIHRvIHRoZSBjb25zb2xlLlxuLy8gRm9ya3MgY2FuIHJldHVybiBgZmFsc2VgIGlmIHRoaXMgaXNuJ3QgZGVzaXJhYmxlLlxuZnVuY3Rpb24gc2hvd0Vycm9yRGlhbG9nKGJvdW5kYXJ5LCBlcnJvckluZm8pIHtcbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGxvZ0NhcHR1cmVkRXJyb3IoYm91bmRhcnksIGVycm9ySW5mbykge1xuICB0cnkge1xuICAgIHZhciBsb2dFcnJvciA9IHNob3dFcnJvckRpYWxvZyhib3VuZGFyeSwgZXJyb3JJbmZvKTsgLy8gQWxsb3cgaW5qZWN0ZWQgc2hvd0Vycm9yRGlhbG9nKCkgdG8gcHJldmVudCBkZWZhdWx0IGNvbnNvbGUuZXJyb3IgbG9nZ2luZy5cbiAgICAvLyBUaGlzIGVuYWJsZXMgcmVuZGVyZXJzIGxpa2UgUmVhY3ROYXRpdmUgdG8gYmV0dGVyIG1hbmFnZSByZWRib3ggYmVoYXZpb3IuXG5cbiAgICBpZiAobG9nRXJyb3IgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGVycm9yID0gZXJyb3JJbmZvLnZhbHVlO1xuXG4gICAgaWYgKHRydWUpIHtcbiAgICAgIHZhciBzb3VyY2UgPSBlcnJvckluZm8uc291cmNlO1xuICAgICAgdmFyIHN0YWNrID0gZXJyb3JJbmZvLnN0YWNrO1xuICAgICAgdmFyIGNvbXBvbmVudFN0YWNrID0gc3RhY2sgIT09IG51bGwgPyBzdGFjayA6ICcnOyAvLyBCcm93c2VycyBzdXBwb3J0IHNpbGVuY2luZyB1bmNhdWdodCBlcnJvcnMgYnkgY2FsbGluZ1xuICAgICAgLy8gYHByZXZlbnREZWZhdWx0KClgIGluIHdpbmRvdyBgZXJyb3JgIGhhbmRsZXIuXG4gICAgICAvLyBXZSByZWNvcmQgdGhpcyBpbmZvcm1hdGlvbiBhcyBhbiBleHBhbmRvIG9uIHRoZSBlcnJvci5cblxuICAgICAgaWYgKGVycm9yICE9IG51bGwgJiYgZXJyb3IuX3N1cHByZXNzTG9nZ2luZykge1xuICAgICAgICBpZiAoYm91bmRhcnkudGFnID09PSBDbGFzc0NvbXBvbmVudCkge1xuICAgICAgICAgIC8vIFRoZSBlcnJvciBpcyByZWNvdmVyYWJsZSBhbmQgd2FzIHNpbGVuY2VkLlxuICAgICAgICAgIC8vIElnbm9yZSBpdCBhbmQgZG9uJ3QgcHJpbnQgdGhlIHN0YWNrIGFkZGVuZHVtLlxuICAgICAgICAgIC8vIFRoaXMgaXMgaGFuZHkgZm9yIHRlc3RpbmcgZXJyb3IgYm91bmRhcmllcyB3aXRob3V0IG5vaXNlLlxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSAvLyBUaGUgZXJyb3IgaXMgZmF0YWwuIFNpbmNlIHRoZSBzaWxlbmNpbmcgbWlnaHQgaGF2ZVxuICAgICAgICAvLyBiZWVuIGFjY2lkZW50YWwsIHdlJ2xsIHN1cmZhY2UgaXQgYW55d2F5LlxuICAgICAgICAvLyBIb3dldmVyLCB0aGUgYnJvd3NlciB3b3VsZCBoYXZlIHNpbGVuY2VkIHRoZSBvcmlnaW5hbCBlcnJvclxuICAgICAgICAvLyBzbyB3ZSdsbCBwcmludCBpdCBmaXJzdCwgYW5kIHRoZW4gcHJpbnQgdGhlIHN0YWNrIGFkZGVuZHVtLlxuXG5cbiAgICAgICAgY29uc29sZVsnZXJyb3InXShlcnJvcik7IC8vIERvbid0IHRyYW5zZm9ybSB0byBvdXIgd3JhcHBlclxuICAgICAgICAvLyBGb3IgYSBtb3JlIGRldGFpbGVkIGRlc2NyaXB0aW9uIG9mIHRoaXMgYmxvY2ssIHNlZTpcbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L3B1bGwvMTMzODRcbiAgICAgIH1cblxuICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBzb3VyY2UgPyBnZXRDb21wb25lbnROYW1lKHNvdXJjZS50eXBlKSA6IG51bGw7XG4gICAgICB2YXIgY29tcG9uZW50TmFtZU1lc3NhZ2UgPSBjb21wb25lbnROYW1lID8gXCJUaGUgYWJvdmUgZXJyb3Igb2NjdXJyZWQgaW4gdGhlIDxcIiArIGNvbXBvbmVudE5hbWUgKyBcIj4gY29tcG9uZW50OlwiIDogJ1RoZSBhYm92ZSBlcnJvciBvY2N1cnJlZCBpbiBvbmUgb2YgeW91ciBSZWFjdCBjb21wb25lbnRzOic7XG4gICAgICB2YXIgZXJyb3JCb3VuZGFyeU1lc3NhZ2U7XG4gICAgICB2YXIgZXJyb3JCb3VuZGFyeU5hbWUgPSBnZXRDb21wb25lbnROYW1lKGJvdW5kYXJ5LnR5cGUpO1xuXG4gICAgICBpZiAoZXJyb3JCb3VuZGFyeU5hbWUpIHtcbiAgICAgICAgZXJyb3JCb3VuZGFyeU1lc3NhZ2UgPSBcIlJlYWN0IHdpbGwgdHJ5IHRvIHJlY3JlYXRlIHRoaXMgY29tcG9uZW50IHRyZWUgZnJvbSBzY3JhdGNoIFwiICsgKFwidXNpbmcgdGhlIGVycm9yIGJvdW5kYXJ5IHlvdSBwcm92aWRlZCwgXCIgKyBlcnJvckJvdW5kYXJ5TmFtZSArIFwiLlwiKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVycm9yQm91bmRhcnlNZXNzYWdlID0gJ0NvbnNpZGVyIGFkZGluZyBhbiBlcnJvciBib3VuZGFyeSB0byB5b3VyIHRyZWUgdG8gY3VzdG9taXplIGVycm9yIGhhbmRsaW5nIGJlaGF2aW9yLlxcbicgKyAnVmlzaXQgaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL2Vycm9yLWJvdW5kYXJpZXMgdG8gbGVhcm4gbW9yZSBhYm91dCBlcnJvciBib3VuZGFyaWVzLic7XG4gICAgICB9XG5cbiAgICAgIHZhciBjb21iaW5lZE1lc3NhZ2UgPSBjb21wb25lbnROYW1lTWVzc2FnZSArIFwiXFxuXCIgKyBjb21wb25lbnRTdGFjayArIFwiXFxuXFxuXCIgKyAoXCJcIiArIGVycm9yQm91bmRhcnlNZXNzYWdlKTsgLy8gSW4gZGV2ZWxvcG1lbnQsIHdlIHByb3ZpZGUgb3VyIG93biBtZXNzYWdlIHdpdGgganVzdCB0aGUgY29tcG9uZW50IHN0YWNrLlxuICAgICAgLy8gV2UgZG9uJ3QgaW5jbHVkZSB0aGUgb3JpZ2luYWwgZXJyb3IgbWVzc2FnZSBhbmQgSlMgc3RhY2sgYmVjYXVzZSB0aGUgYnJvd3NlclxuICAgICAgLy8gaGFzIGFscmVhZHkgcHJpbnRlZCBpdC4gRXZlbiBpZiB0aGUgYXBwbGljYXRpb24gc3dhbGxvd3MgdGhlIGVycm9yLCBpdCBpcyBzdGlsbFxuICAgICAgLy8gZGlzcGxheWVkIGJ5IHRoZSBicm93c2VyIHRoYW5rcyB0byB0aGUgREVWLW9ubHkgZmFrZSBldmVudCB0cmljayBpbiBSZWFjdEVycm9yVXRpbHMuXG5cbiAgICAgIGNvbnNvbGVbJ2Vycm9yJ10oY29tYmluZWRNZXNzYWdlKTsgLy8gRG9uJ3QgdHJhbnNmb3JtIHRvIG91ciB3cmFwcGVyXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEluIHByb2R1Y3Rpb24sIHdlIHByaW50IHRoZSBlcnJvciBkaXJlY3RseS5cbiAgICAgIC8vIFRoaXMgd2lsbCBpbmNsdWRlIHRoZSBtZXNzYWdlLCB0aGUgSlMgc3RhY2ssIGFuZCBhbnl0aGluZyB0aGUgYnJvd3NlciB3YW50cyB0byBzaG93LlxuICAgICAgLy8gV2UgcGFzcyB0aGUgZXJyb3Igb2JqZWN0IGluc3RlYWQgb2YgY3VzdG9tIG1lc3NhZ2Ugc28gdGhhdCB0aGUgYnJvd3NlciBkaXNwbGF5cyB0aGUgZXJyb3IgbmF0aXZlbHkuXG4gICAgICBjb25zb2xlWydlcnJvciddKGVycm9yKTsgLy8gRG9uJ3QgdHJhbnNmb3JtIHRvIG91ciB3cmFwcGVyXG4gICAgfVxuICB9IGNhdGNoIChlKSB7XG4gICAgLy8gVGhpcyBtZXRob2QgbXVzdCBub3QgdGhyb3csIG9yIFJlYWN0IGludGVybmFsIHN0YXRlIHdpbGwgZ2V0IG1lc3NlZCB1cC5cbiAgICAvLyBJZiBjb25zb2xlLmVycm9yIGlzIG92ZXJyaWRkZW4sIG9yIGxvZ0NhcHR1cmVkRXJyb3IoKSBzaG93cyBhIGRpYWxvZyB0aGF0IHRocm93cyxcbiAgICAvLyB3ZSB3YW50IHRvIHJlcG9ydCB0aGlzIGVycm9yIG91dHNpZGUgb2YgdGhlIG5vcm1hbCBzdGFjayBhcyBhIGxhc3QgcmVzb3J0LlxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTMxODhcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIHRocm93IGU7XG4gICAgfSk7XG4gIH1cbn1cblxudmFyIFBvc3NpYmx5V2Vha01hcCQxID0gdHlwZW9mIFdlYWtNYXAgPT09ICdmdW5jdGlvbicgPyBXZWFrTWFwIDogTWFwO1xuXG5mdW5jdGlvbiBjcmVhdGVSb290RXJyb3JVcGRhdGUoZmliZXIsIGVycm9ySW5mbywgbGFuZSkge1xuICB2YXIgdXBkYXRlID0gY3JlYXRlVXBkYXRlKE5vVGltZXN0YW1wLCBsYW5lKTsgLy8gVW5tb3VudCB0aGUgcm9vdCBieSByZW5kZXJpbmcgbnVsbC5cblxuICB1cGRhdGUudGFnID0gQ2FwdHVyZVVwZGF0ZTsgLy8gQ2F1dGlvbjogUmVhY3QgRGV2VG9vbHMgY3VycmVudGx5IGRlcGVuZHMgb24gdGhpcyBwcm9wZXJ0eVxuICAvLyBiZWluZyBjYWxsZWQgXCJlbGVtZW50XCIuXG5cbiAgdXBkYXRlLnBheWxvYWQgPSB7XG4gICAgZWxlbWVudDogbnVsbFxuICB9O1xuICB2YXIgZXJyb3IgPSBlcnJvckluZm8udmFsdWU7XG5cbiAgdXBkYXRlLmNhbGxiYWNrID0gZnVuY3Rpb24gKCkge1xuICAgIG9uVW5jYXVnaHRFcnJvcihlcnJvcik7XG4gICAgbG9nQ2FwdHVyZWRFcnJvcihmaWJlciwgZXJyb3JJbmZvKTtcbiAgfTtcblxuICByZXR1cm4gdXBkYXRlO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVDbGFzc0Vycm9yVXBkYXRlKGZpYmVyLCBlcnJvckluZm8sIGxhbmUpIHtcbiAgdmFyIHVwZGF0ZSA9IGNyZWF0ZVVwZGF0ZShOb1RpbWVzdGFtcCwgbGFuZSk7XG4gIHVwZGF0ZS50YWcgPSBDYXB0dXJlVXBkYXRlO1xuICB2YXIgZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yID0gZmliZXIudHlwZS5nZXREZXJpdmVkU3RhdGVGcm9tRXJyb3I7XG5cbiAgaWYgKHR5cGVvZiBnZXREZXJpdmVkU3RhdGVGcm9tRXJyb3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICB2YXIgZXJyb3IkMSA9IGVycm9ySW5mby52YWx1ZTtcblxuICAgIHVwZGF0ZS5wYXlsb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgbG9nQ2FwdHVyZWRFcnJvcihmaWJlciwgZXJyb3JJbmZvKTtcbiAgICAgIHJldHVybiBnZXREZXJpdmVkU3RhdGVGcm9tRXJyb3IoZXJyb3IkMSk7XG4gICAgfTtcbiAgfVxuXG4gIHZhciBpbnN0ID0gZmliZXIuc3RhdGVOb2RlO1xuXG4gIGlmIChpbnN0ICE9PSBudWxsICYmIHR5cGVvZiBpbnN0LmNvbXBvbmVudERpZENhdGNoID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdXBkYXRlLmNhbGxiYWNrID0gZnVuY3Rpb24gY2FsbGJhY2soKSB7XG4gICAgICB7XG4gICAgICAgIG1hcmtGYWlsZWRFcnJvckJvdW5kYXJ5Rm9ySG90UmVsb2FkaW5nKGZpYmVyKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBnZXREZXJpdmVkU3RhdGVGcm9tRXJyb3IgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gVG8gcHJlc2VydmUgdGhlIHByZWV4aXN0aW5nIHJldHJ5IGJlaGF2aW9yIG9mIGVycm9yIGJvdW5kYXJpZXMsXG4gICAgICAgIC8vIHdlIGtlZXAgdHJhY2sgb2Ygd2hpY2ggb25lcyBhbHJlYWR5IGZhaWxlZCBkdXJpbmcgdGhpcyBiYXRjaC5cbiAgICAgICAgLy8gVGhpcyBnZXRzIHJlc2V0IGJlZm9yZSB3ZSB5aWVsZCBiYWNrIHRvIHRoZSBicm93c2VyLlxuICAgICAgICAvLyBUT0RPOiBXYXJuIGluIHN0cmljdCBtb2RlIGlmIGdldERlcml2ZWRTdGF0ZUZyb21FcnJvciBpc1xuICAgICAgICAvLyBub3QgZGVmaW5lZC5cbiAgICAgICAgbWFya0xlZ2FjeUVycm9yQm91bmRhcnlBc0ZhaWxlZCh0aGlzKTsgLy8gT25seSBsb2cgaGVyZSBpZiBjb21wb25lbnREaWRDYXRjaCBpcyB0aGUgb25seSBlcnJvciBib3VuZGFyeSBtZXRob2QgZGVmaW5lZFxuXG4gICAgICAgIGxvZ0NhcHR1cmVkRXJyb3IoZmliZXIsIGVycm9ySW5mbyk7XG4gICAgICB9XG5cbiAgICAgIHZhciBlcnJvciQxID0gZXJyb3JJbmZvLnZhbHVlO1xuICAgICAgdmFyIHN0YWNrID0gZXJyb3JJbmZvLnN0YWNrO1xuICAgICAgdGhpcy5jb21wb25lbnREaWRDYXRjaChlcnJvciQxLCB7XG4gICAgICAgIGNvbXBvbmVudFN0YWNrOiBzdGFjayAhPT0gbnVsbCA/IHN0YWNrIDogJydcbiAgICAgIH0pO1xuXG4gICAgICB7XG4gICAgICAgIGlmICh0eXBlb2YgZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgLy8gSWYgY29tcG9uZW50RGlkQ2F0Y2ggaXMgdGhlIG9ubHkgZXJyb3IgYm91bmRhcnkgbWV0aG9kIGRlZmluZWQsXG4gICAgICAgICAgLy8gdGhlbiBpdCBuZWVkcyB0byBjYWxsIHNldFN0YXRlIHRvIHJlY292ZXIgZnJvbSBlcnJvcnMuXG4gICAgICAgICAgLy8gSWYgbm8gc3RhdGUgdXBkYXRlIGlzIHNjaGVkdWxlZCB0aGVuIHRoZSBib3VuZGFyeSB3aWxsIHN3YWxsb3cgdGhlIGVycm9yLlxuICAgICAgICAgIGlmICghaW5jbHVkZXNTb21lTGFuZShmaWJlci5sYW5lcywgU3luY0xhbmUpKSB7XG4gICAgICAgICAgICBlcnJvcignJXM6IEVycm9yIGJvdW5kYXJpZXMgc2hvdWxkIGltcGxlbWVudCBnZXREZXJpdmVkU3RhdGVGcm9tRXJyb3IoKS4gJyArICdJbiB0aGF0IG1ldGhvZCwgcmV0dXJuIGEgc3RhdGUgdXBkYXRlIHRvIGRpc3BsYXkgYW4gZXJyb3IgbWVzc2FnZSBvciBmYWxsYmFjayBVSS4nLCBnZXRDb21wb25lbnROYW1lKGZpYmVyLnR5cGUpIHx8ICdVbmtub3duJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICB1cGRhdGUuY2FsbGJhY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBtYXJrRmFpbGVkRXJyb3JCb3VuZGFyeUZvckhvdFJlbG9hZGluZyhmaWJlcik7XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiB1cGRhdGU7XG59XG5cbmZ1bmN0aW9uIGF0dGFjaFBpbmdMaXN0ZW5lcihyb290LCB3YWtlYWJsZSwgbGFuZXMpIHtcbiAgLy8gQXR0YWNoIGEgbGlzdGVuZXIgdG8gdGhlIHByb21pc2UgdG8gXCJwaW5nXCIgdGhlIHJvb3QgYW5kIHJldHJ5LiBCdXQgb25seSBpZlxuICAvLyBvbmUgZG9lcyBub3QgYWxyZWFkeSBleGlzdCBmb3IgdGhlIGxhbmVzIHdlJ3JlIGN1cnJlbnRseSByZW5kZXJpbmcgKHdoaWNoXG4gIC8vIGFjdHMgbGlrZSBhIFwidGhyZWFkIElEXCIgaGVyZSkuXG4gIHZhciBwaW5nQ2FjaGUgPSByb290LnBpbmdDYWNoZTtcbiAgdmFyIHRocmVhZElEcztcblxuICBpZiAocGluZ0NhY2hlID09PSBudWxsKSB7XG4gICAgcGluZ0NhY2hlID0gcm9vdC5waW5nQ2FjaGUgPSBuZXcgUG9zc2libHlXZWFrTWFwJDEoKTtcbiAgICB0aHJlYWRJRHMgPSBuZXcgU2V0KCk7XG4gICAgcGluZ0NhY2hlLnNldCh3YWtlYWJsZSwgdGhyZWFkSURzKTtcbiAgfSBlbHNlIHtcbiAgICB0aHJlYWRJRHMgPSBwaW5nQ2FjaGUuZ2V0KHdha2VhYmxlKTtcblxuICAgIGlmICh0aHJlYWRJRHMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyZWFkSURzID0gbmV3IFNldCgpO1xuICAgICAgcGluZ0NhY2hlLnNldCh3YWtlYWJsZSwgdGhyZWFkSURzKTtcbiAgICB9XG4gIH1cblxuICBpZiAoIXRocmVhZElEcy5oYXMobGFuZXMpKSB7XG4gICAgLy8gTWVtb2l6ZSB1c2luZyB0aGUgdGhyZWFkIElEIHRvIHByZXZlbnQgcmVkdW5kYW50IGxpc3RlbmVycy5cbiAgICB0aHJlYWRJRHMuYWRkKGxhbmVzKTtcbiAgICB2YXIgcGluZyA9IHBpbmdTdXNwZW5kZWRSb290LmJpbmQobnVsbCwgcm9vdCwgd2FrZWFibGUsIGxhbmVzKTtcbiAgICB3YWtlYWJsZS50aGVuKHBpbmcsIHBpbmcpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHRocm93RXhjZXB0aW9uKHJvb3QsIHJldHVybkZpYmVyLCBzb3VyY2VGaWJlciwgdmFsdWUsIHJvb3RSZW5kZXJMYW5lcykge1xuICAvLyBUaGUgc291cmNlIGZpYmVyIGRpZCBub3QgY29tcGxldGUuXG4gIHNvdXJjZUZpYmVyLmZsYWdzIHw9IEluY29tcGxldGU7IC8vIEl0cyBlZmZlY3QgbGlzdCBpcyBubyBsb25nZXIgdmFsaWQuXG5cbiAgc291cmNlRmliZXIuZmlyc3RFZmZlY3QgPSBzb3VyY2VGaWJlci5sYXN0RWZmZWN0ID0gbnVsbDtcblxuICBpZiAodmFsdWUgIT09IG51bGwgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgdmFsdWUudGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIC8vIFRoaXMgaXMgYSB3YWtlYWJsZS5cbiAgICB2YXIgd2FrZWFibGUgPSB2YWx1ZTtcblxuICAgIGlmICgoc291cmNlRmliZXIubW9kZSAmIEJsb2NraW5nTW9kZSkgPT09IE5vTW9kZSkge1xuICAgICAgLy8gUmVzZXQgdGhlIG1lbW9pemVkU3RhdGUgdG8gd2hhdCBpdCB3YXMgYmVmb3JlIHdlIGF0dGVtcHRlZFxuICAgICAgLy8gdG8gcmVuZGVyIGl0LlxuICAgICAgdmFyIGN1cnJlbnRTb3VyY2UgPSBzb3VyY2VGaWJlci5hbHRlcm5hdGU7XG5cbiAgICAgIGlmIChjdXJyZW50U291cmNlKSB7XG4gICAgICAgIHNvdXJjZUZpYmVyLnVwZGF0ZVF1ZXVlID0gY3VycmVudFNvdXJjZS51cGRhdGVRdWV1ZTtcbiAgICAgICAgc291cmNlRmliZXIubWVtb2l6ZWRTdGF0ZSA9IGN1cnJlbnRTb3VyY2UubWVtb2l6ZWRTdGF0ZTtcbiAgICAgICAgc291cmNlRmliZXIubGFuZXMgPSBjdXJyZW50U291cmNlLmxhbmVzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc291cmNlRmliZXIudXBkYXRlUXVldWUgPSBudWxsO1xuICAgICAgICBzb3VyY2VGaWJlci5tZW1vaXplZFN0YXRlID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgaGFzSW52aXNpYmxlUGFyZW50Qm91bmRhcnkgPSBoYXNTdXNwZW5zZUNvbnRleHQoc3VzcGVuc2VTdGFja0N1cnNvci5jdXJyZW50LCBJbnZpc2libGVQYXJlbnRTdXNwZW5zZUNvbnRleHQpOyAvLyBTY2hlZHVsZSB0aGUgbmVhcmVzdCBTdXNwZW5zZSB0byByZS1yZW5kZXIgdGhlIHRpbWVkIG91dCB2aWV3LlxuXG4gICAgdmFyIF93b3JrSW5Qcm9ncmVzcyA9IHJldHVybkZpYmVyO1xuXG4gICAgZG8ge1xuICAgICAgaWYgKF93b3JrSW5Qcm9ncmVzcy50YWcgPT09IFN1c3BlbnNlQ29tcG9uZW50ICYmIHNob3VsZENhcHR1cmVTdXNwZW5zZShfd29ya0luUHJvZ3Jlc3MsIGhhc0ludmlzaWJsZVBhcmVudEJvdW5kYXJ5KSkge1xuICAgICAgICAvLyBGb3VuZCB0aGUgbmVhcmVzdCBib3VuZGFyeS5cbiAgICAgICAgLy8gU3Rhc2ggdGhlIHByb21pc2Ugb24gdGhlIGJvdW5kYXJ5IGZpYmVyLiBJZiB0aGUgYm91bmRhcnkgdGltZXMgb3V0LCB3ZSdsbFxuICAgICAgICAvLyBhdHRhY2ggYW5vdGhlciBsaXN0ZW5lciB0byBmbGlwIHRoZSBib3VuZGFyeSBiYWNrIHRvIGl0cyBub3JtYWwgc3RhdGUuXG4gICAgICAgIHZhciB3YWtlYWJsZXMgPSBfd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWU7XG5cbiAgICAgICAgaWYgKHdha2VhYmxlcyA9PT0gbnVsbCkge1xuICAgICAgICAgIHZhciB1cGRhdGVRdWV1ZSA9IG5ldyBTZXQoKTtcbiAgICAgICAgICB1cGRhdGVRdWV1ZS5hZGQod2FrZWFibGUpO1xuICAgICAgICAgIF93b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZSA9IHVwZGF0ZVF1ZXVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHdha2VhYmxlcy5hZGQod2FrZWFibGUpO1xuICAgICAgICB9IC8vIElmIHRoZSBib3VuZGFyeSBpcyBvdXRzaWRlIG9mIGJsb2NraW5nIG1vZGUsIHdlIHNob3VsZCAqbm90KlxuICAgICAgICAvLyBzdXNwZW5kIHRoZSBjb21taXQuIFByZXRlbmQgYXMgaWYgdGhlIHN1c3BlbmRlZCBjb21wb25lbnQgcmVuZGVyZWRcbiAgICAgICAgLy8gbnVsbCBhbmQga2VlcCByZW5kZXJpbmcuIEluIHRoZSBjb21taXQgcGhhc2UsIHdlJ2xsIHNjaGVkdWxlIGFcbiAgICAgICAgLy8gc3Vic2VxdWVudCBzeW5jaHJvbm91cyB1cGRhdGUgdG8gcmUtcmVuZGVyIHRoZSBTdXNwZW5zZS5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gTm90ZTogSXQgZG9lc24ndCBtYXR0ZXIgd2hldGhlciB0aGUgY29tcG9uZW50IHRoYXQgc3VzcGVuZGVkIHdhc1xuICAgICAgICAvLyBpbnNpZGUgYSBibG9ja2luZyBtb2RlIHRyZWUuIElmIHRoZSBTdXNwZW5zZSBpcyBvdXRzaWRlIG9mIGl0LCB3ZVxuICAgICAgICAvLyBzaG91bGQgKm5vdCogc3VzcGVuZCB0aGUgY29tbWl0LlxuXG5cbiAgICAgICAgaWYgKChfd29ya0luUHJvZ3Jlc3MubW9kZSAmIEJsb2NraW5nTW9kZSkgPT09IE5vTW9kZSkge1xuICAgICAgICAgIF93b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBEaWRDYXB0dXJlO1xuICAgICAgICAgIHNvdXJjZUZpYmVyLmZsYWdzIHw9IEZvcmNlVXBkYXRlRm9yTGVnYWN5U3VzcGVuc2U7IC8vIFdlJ3JlIGdvaW5nIHRvIGNvbW1pdCB0aGlzIGZpYmVyIGV2ZW4gdGhvdWdoIGl0IGRpZG4ndCBjb21wbGV0ZS5cbiAgICAgICAgICAvLyBCdXQgd2Ugc2hvdWxkbid0IGNhbGwgYW55IGxpZmVjeWNsZSBtZXRob2RzIG9yIGNhbGxiYWNrcy4gUmVtb3ZlXG4gICAgICAgICAgLy8gYWxsIGxpZmVjeWNsZSBlZmZlY3QgdGFncy5cblxuICAgICAgICAgIHNvdXJjZUZpYmVyLmZsYWdzICY9IH4oTGlmZWN5Y2xlRWZmZWN0TWFzayB8IEluY29tcGxldGUpO1xuXG4gICAgICAgICAgaWYgKHNvdXJjZUZpYmVyLnRhZyA9PT0gQ2xhc3NDb21wb25lbnQpIHtcbiAgICAgICAgICAgIHZhciBjdXJyZW50U291cmNlRmliZXIgPSBzb3VyY2VGaWJlci5hbHRlcm5hdGU7XG5cbiAgICAgICAgICAgIGlmIChjdXJyZW50U291cmNlRmliZXIgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgLy8gVGhpcyBpcyBhIG5ldyBtb3VudC4gQ2hhbmdlIHRoZSB0YWcgc28gaXQncyBub3QgbWlzdGFrZW4gZm9yIGFcbiAgICAgICAgICAgICAgLy8gY29tcGxldGVkIGNsYXNzIGNvbXBvbmVudC4gRm9yIGV4YW1wbGUsIHdlIHNob3VsZCBub3QgY2FsbFxuICAgICAgICAgICAgICAvLyBjb21wb25lbnRXaWxsVW5tb3VudCBpZiBpdCBpcyBkZWxldGVkLlxuICAgICAgICAgICAgICBzb3VyY2VGaWJlci50YWcgPSBJbmNvbXBsZXRlQ2xhc3NDb21wb25lbnQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBXaGVuIHdlIHRyeSByZW5kZXJpbmcgYWdhaW4sIHdlIHNob3VsZCBub3QgcmV1c2UgdGhlIGN1cnJlbnQgZmliZXIsXG4gICAgICAgICAgICAgIC8vIHNpbmNlIGl0J3Mga25vd24gdG8gYmUgaW4gYW4gaW5jb25zaXN0ZW50IHN0YXRlLiBVc2UgYSBmb3JjZSB1cGRhdGUgdG9cbiAgICAgICAgICAgICAgLy8gcHJldmVudCBhIGJhaWwgb3V0LlxuICAgICAgICAgICAgICB2YXIgdXBkYXRlID0gY3JlYXRlVXBkYXRlKE5vVGltZXN0YW1wLCBTeW5jTGFuZSk7XG4gICAgICAgICAgICAgIHVwZGF0ZS50YWcgPSBGb3JjZVVwZGF0ZTtcbiAgICAgICAgICAgICAgZW5xdWV1ZVVwZGF0ZShzb3VyY2VGaWJlciwgdXBkYXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IC8vIFRoZSBzb3VyY2UgZmliZXIgZGlkIG5vdCBjb21wbGV0ZS4gTWFyayBpdCB3aXRoIFN5bmMgcHJpb3JpdHkgdG9cbiAgICAgICAgICAvLyBpbmRpY2F0ZSB0aGF0IGl0IHN0aWxsIGhhcyBwZW5kaW5nIHdvcmsuXG5cblxuICAgICAgICAgIHNvdXJjZUZpYmVyLmxhbmVzID0gbWVyZ2VMYW5lcyhzb3VyY2VGaWJlci5sYW5lcywgU3luY0xhbmUpOyAvLyBFeGl0IHdpdGhvdXQgc3VzcGVuZGluZy5cblxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSAvLyBDb25maXJtZWQgdGhhdCB0aGUgYm91bmRhcnkgaXMgaW4gYSBjb25jdXJyZW50IG1vZGUgdHJlZS4gQ29udGludWVcbiAgICAgICAgLy8gd2l0aCB0aGUgbm9ybWFsIHN1c3BlbmQgcGF0aC5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gQWZ0ZXIgdGhpcyB3ZSdsbCB1c2UgYSBzZXQgb2YgaGV1cmlzdGljcyB0byBkZXRlcm1pbmUgd2hldGhlciB0aGlzXG4gICAgICAgIC8vIHJlbmRlciBwYXNzIHdpbGwgcnVuIHRvIGNvbXBsZXRpb24gb3IgcmVzdGFydCBvciBcInN1c3BlbmRcIiB0aGUgY29tbWl0LlxuICAgICAgICAvLyBUaGUgYWN0dWFsIGxvZ2ljIGZvciB0aGlzIGlzIHNwcmVhZCBvdXQgaW4gZGlmZmVyZW50IHBsYWNlcy5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gVGhpcyBmaXJzdCBwcmluY2lwbGUgaXMgdGhhdCBpZiB3ZSdyZSBnb2luZyB0byBzdXNwZW5kIHdoZW4gd2UgY29tcGxldGVcbiAgICAgICAgLy8gYSByb290LCB0aGVuIHdlIHNob3VsZCBhbHNvIHJlc3RhcnQgaWYgd2UgZ2V0IGFuIHVwZGF0ZSBvciBwaW5nIHRoYXRcbiAgICAgICAgLy8gbWlnaHQgdW5zdXNwZW5kIGl0LCBhbmQgdmljZSB2ZXJzYS4gVGhlIG9ubHkgcmVhc29uIHRvIHN1c3BlbmQgaXNcbiAgICAgICAgLy8gYmVjYXVzZSB5b3UgdGhpbmsgeW91IG1pZ2h0IHdhbnQgdG8gcmVzdGFydCBiZWZvcmUgY29tbWl0dGluZy4gSG93ZXZlcixcbiAgICAgICAgLy8gaXQgZG9lc24ndCBtYWtlIHNlbnNlIHRvIHJlc3RhcnQgb25seSB3aGlsZSBpbiB0aGUgcGVyaW9kIHdlJ3JlIHN1c3BlbmRlZC5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gUmVzdGFydGluZyB0b28gYWdncmVzc2l2ZWx5IGlzIGFsc28gbm90IGdvb2QgYmVjYXVzZSBpdCBzdGFydmVzIG91dCBhbnlcbiAgICAgICAgLy8gaW50ZXJtZWRpYXRlIGxvYWRpbmcgc3RhdGUuIFNvIHdlIHVzZSBoZXVyaXN0aWNzIHRvIGRldGVybWluZSB3aGVuLlxuICAgICAgICAvLyBTdXNwZW5zZSBIZXVyaXN0aWNzXG4gICAgICAgIC8vXG4gICAgICAgIC8vIElmIG5vdGhpbmcgdGhyZXcgYSBQcm9taXNlIG9yIGFsbCB0aGUgc2FtZSBmYWxsYmFja3MgYXJlIGFscmVhZHkgc2hvd2luZyxcbiAgICAgICAgLy8gdGhlbiBkb24ndCBzdXNwZW5kL3Jlc3RhcnQuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIElmIHRoaXMgaXMgYW4gaW5pdGlhbCByZW5kZXIgb2YgYSBuZXcgdHJlZSBvZiBTdXNwZW5zZSBib3VuZGFyaWVzIGFuZFxuICAgICAgICAvLyB0aG9zZSB0cmlnZ2VyIGEgZmFsbGJhY2ssIHRoZW4gZG9uJ3Qgc3VzcGVuZC9yZXN0YXJ0LiBXZSB3YW50IHRvIGVuc3VyZVxuICAgICAgICAvLyB0aGF0IHdlIGNhbiBzaG93IHRoZSBpbml0aWFsIGxvYWRpbmcgc3RhdGUgYXMgcXVpY2tseSBhcyBwb3NzaWJsZS5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gSWYgd2UgaGl0IGEgXCJEZWxheWVkXCIgY2FzZSwgc3VjaCBhcyB3aGVuIHdlJ2Qgc3dpdGNoIGZyb20gY29udGVudCBiYWNrIGludG9cbiAgICAgICAgLy8gYSBmYWxsYmFjaywgdGhlbiB3ZSBzaG91bGQgYWx3YXlzIHN1c3BlbmQvcmVzdGFydC4gVHJhbnNpdGlvbnMgYXBwbHlcbiAgICAgICAgLy8gdG8gdGhpcyBjYXNlLiBJZiBub25lIGlzIGRlZmluZWQsIEpORCBpcyB1c2VkIGluc3RlYWQuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIElmIHdlJ3JlIGFscmVhZHkgc2hvd2luZyBhIGZhbGxiYWNrIGFuZCBpdCBnZXRzIFwicmV0cmllZFwiLCBhbGxvd2luZyB1cyB0byBzaG93XG4gICAgICAgIC8vIGFub3RoZXIgbGV2ZWwsIGJ1dCB0aGVyZSdzIHN0aWxsIGFuIGlubmVyIGJvdW5kYXJ5IHRoYXQgd291bGQgc2hvdyBhIGZhbGxiYWNrLFxuICAgICAgICAvLyB0aGVuIHdlIHN1c3BlbmQvcmVzdGFydCBmb3IgNTAwbXMgc2luY2UgdGhlIGxhc3QgdGltZSB3ZSBzaG93ZWQgYSBmYWxsYmFja1xuICAgICAgICAvLyBhbnl3aGVyZSBpbiB0aGUgdHJlZS4gVGhpcyBlZmZlY3RpdmVseSB0aHJvdHRsZXMgcHJvZ3Jlc3NpdmUgbG9hZGluZyBpbnRvIGFcbiAgICAgICAgLy8gY29uc2lzdGVudCB0cmFpbiBvZiBjb21taXRzLiBUaGlzIGFsc28gZ2l2ZXMgdXMgYW4gb3Bwb3J0dW5pdHkgdG8gcmVzdGFydCB0b1xuICAgICAgICAvLyBnZXQgdG8gdGhlIGNvbXBsZXRlZCBzdGF0ZSBzbGlnaHRseSBlYXJsaWVyLlxuICAgICAgICAvL1xuICAgICAgICAvLyBJZiB0aGVyZSdzIGFtYmlndWl0eSBkdWUgdG8gYmF0Y2hpbmcgaXQncyByZXNvbHZlZCBpbiBwcmVmZXJlbmNlIG9mOlxuICAgICAgICAvLyAxKSBcImRlbGF5ZWRcIiwgMikgXCJpbml0aWFsIHJlbmRlclwiLCAzKSBcInJldHJ5XCIuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIFdlIHdhbnQgdG8gZW5zdXJlIHRoYXQgYSBcImJ1c3lcIiBzdGF0ZSBkb2Vzbid0IGdldCBmb3JjZSBjb21taXR0ZWQuIFdlIHdhbnQgdG9cbiAgICAgICAgLy8gZW5zdXJlIHRoYXQgbmV3IGluaXRpYWwgbG9hZGluZyBzdGF0ZXMgY2FuIGNvbW1pdCBhcyBzb29uIGFzIHBvc3NpYmxlLlxuXG5cbiAgICAgICAgYXR0YWNoUGluZ0xpc3RlbmVyKHJvb3QsIHdha2VhYmxlLCByb290UmVuZGVyTGFuZXMpO1xuICAgICAgICBfd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gU2hvdWxkQ2FwdHVyZTtcbiAgICAgICAgX3dvcmtJblByb2dyZXNzLmxhbmVzID0gcm9vdFJlbmRlckxhbmVzO1xuICAgICAgICByZXR1cm47XG4gICAgICB9IC8vIFRoaXMgYm91bmRhcnkgYWxyZWFkeSBjYXB0dXJlZCBkdXJpbmcgdGhpcyByZW5kZXIuIENvbnRpbnVlIHRvIHRoZSBuZXh0XG4gICAgICAvLyBib3VuZGFyeS5cblxuXG4gICAgICBfd29ya0luUHJvZ3Jlc3MgPSBfd29ya0luUHJvZ3Jlc3MucmV0dXJuO1xuICAgIH0gd2hpbGUgKF93b3JrSW5Qcm9ncmVzcyAhPT0gbnVsbCk7IC8vIE5vIGJvdW5kYXJ5IHdhcyBmb3VuZC4gRmFsbHRocm91Z2ggdG8gZXJyb3IgbW9kZS5cbiAgICAvLyBUT0RPOiBVc2UgaW52YXJpYW50IHNvIHRoZSBtZXNzYWdlIGlzIHN0cmlwcGVkIGluIHByb2Q/XG5cblxuICAgIHZhbHVlID0gbmV3IEVycm9yKChnZXRDb21wb25lbnROYW1lKHNvdXJjZUZpYmVyLnR5cGUpIHx8ICdBIFJlYWN0IGNvbXBvbmVudCcpICsgJyBzdXNwZW5kZWQgd2hpbGUgcmVuZGVyaW5nLCBidXQgbm8gZmFsbGJhY2sgVUkgd2FzIHNwZWNpZmllZC5cXG4nICsgJ1xcbicgKyAnQWRkIGEgPFN1c3BlbnNlIGZhbGxiYWNrPS4uLj4gY29tcG9uZW50IGhpZ2hlciBpbiB0aGUgdHJlZSB0byAnICsgJ3Byb3ZpZGUgYSBsb2FkaW5nIGluZGljYXRvciBvciBwbGFjZWhvbGRlciB0byBkaXNwbGF5LicpO1xuICB9IC8vIFdlIGRpZG4ndCBmaW5kIGEgYm91bmRhcnkgdGhhdCBjb3VsZCBoYW5kbGUgdGhpcyB0eXBlIG9mIGV4Y2VwdGlvbi4gU3RhcnRcbiAgLy8gb3ZlciBhbmQgdHJhdmVyc2UgcGFyZW50IHBhdGggYWdhaW4sIHRoaXMgdGltZSB0cmVhdGluZyB0aGUgZXhjZXB0aW9uXG4gIC8vIGFzIGFuIGVycm9yLlxuXG5cbiAgcmVuZGVyRGlkRXJyb3IoKTtcbiAgdmFsdWUgPSBjcmVhdGVDYXB0dXJlZFZhbHVlKHZhbHVlLCBzb3VyY2VGaWJlcik7XG4gIHZhciB3b3JrSW5Qcm9ncmVzcyA9IHJldHVybkZpYmVyO1xuXG4gIGRvIHtcbiAgICBzd2l0Y2ggKHdvcmtJblByb2dyZXNzLnRhZykge1xuICAgICAgY2FzZSBIb3N0Um9vdDpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBfZXJyb3JJbmZvID0gdmFsdWU7XG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gU2hvdWxkQ2FwdHVyZTtcbiAgICAgICAgICB2YXIgbGFuZSA9IHBpY2tBcmJpdHJhcnlMYW5lKHJvb3RSZW5kZXJMYW5lcyk7XG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MubGFuZXMgPSBtZXJnZUxhbmVzKHdvcmtJblByb2dyZXNzLmxhbmVzLCBsYW5lKTtcblxuICAgICAgICAgIHZhciBfdXBkYXRlID0gY3JlYXRlUm9vdEVycm9yVXBkYXRlKHdvcmtJblByb2dyZXNzLCBfZXJyb3JJbmZvLCBsYW5lKTtcblxuICAgICAgICAgIGVucXVldWVDYXB0dXJlZFVwZGF0ZSh3b3JrSW5Qcm9ncmVzcywgX3VwZGF0ZSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG4gICAgICAgIC8vIENhcHR1cmUgYW5kIHJldHJ5XG4gICAgICAgIHZhciBlcnJvckluZm8gPSB2YWx1ZTtcbiAgICAgICAgdmFyIGN0b3IgPSB3b3JrSW5Qcm9ncmVzcy50eXBlO1xuICAgICAgICB2YXIgaW5zdGFuY2UgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG5cbiAgICAgICAgaWYgKCh3b3JrSW5Qcm9ncmVzcy5mbGFncyAmIERpZENhcHR1cmUpID09PSBOb0ZsYWdzICYmICh0eXBlb2YgY3Rvci5nZXREZXJpdmVkU3RhdGVGcm9tRXJyb3IgPT09ICdmdW5jdGlvbicgfHwgaW5zdGFuY2UgIT09IG51bGwgJiYgdHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudERpZENhdGNoID09PSAnZnVuY3Rpb24nICYmICFpc0FscmVhZHlGYWlsZWRMZWdhY3lFcnJvckJvdW5kYXJ5KGluc3RhbmNlKSkpIHtcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBTaG91bGRDYXB0dXJlO1xuXG4gICAgICAgICAgdmFyIF9sYW5lID0gcGlja0FyYml0cmFyeUxhbmUocm9vdFJlbmRlckxhbmVzKTtcblxuICAgICAgICAgIHdvcmtJblByb2dyZXNzLmxhbmVzID0gbWVyZ2VMYW5lcyh3b3JrSW5Qcm9ncmVzcy5sYW5lcywgX2xhbmUpOyAvLyBTY2hlZHVsZSB0aGUgZXJyb3IgYm91bmRhcnkgdG8gcmUtcmVuZGVyIHVzaW5nIHVwZGF0ZWQgc3RhdGVcblxuICAgICAgICAgIHZhciBfdXBkYXRlMiA9IGNyZWF0ZUNsYXNzRXJyb3JVcGRhdGUod29ya0luUHJvZ3Jlc3MsIGVycm9ySW5mbywgX2xhbmUpO1xuXG4gICAgICAgICAgZW5xdWV1ZUNhcHR1cmVkVXBkYXRlKHdvcmtJblByb2dyZXNzLCBfdXBkYXRlMik7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgd29ya0luUHJvZ3Jlc3MgPSB3b3JrSW5Qcm9ncmVzcy5yZXR1cm47XG4gIH0gd2hpbGUgKHdvcmtJblByb2dyZXNzICE9PSBudWxsKTtcbn1cblxudmFyIGRpZFdhcm5BYm91dFVuZGVmaW5lZFNuYXBzaG90QmVmb3JlVXBkYXRlID0gbnVsbDtcblxue1xuICBkaWRXYXJuQWJvdXRVbmRlZmluZWRTbmFwc2hvdEJlZm9yZVVwZGF0ZSA9IG5ldyBTZXQoKTtcbn1cblxudmFyIFBvc3NpYmx5V2Vha1NldCA9IHR5cGVvZiBXZWFrU2V0ID09PSAnZnVuY3Rpb24nID8gV2Vha1NldCA6IFNldDtcblxudmFyIGNhbGxDb21wb25lbnRXaWxsVW5tb3VudFdpdGhUaW1lciA9IGZ1bmN0aW9uIChjdXJyZW50LCBpbnN0YW5jZSkge1xuICBpbnN0YW5jZS5wcm9wcyA9IGN1cnJlbnQubWVtb2l6ZWRQcm9wcztcbiAgaW5zdGFuY2Uuc3RhdGUgPSBjdXJyZW50Lm1lbW9pemVkU3RhdGU7XG5cbiAge1xuICAgIGluc3RhbmNlLmNvbXBvbmVudFdpbGxVbm1vdW50KCk7XG4gIH1cbn07IC8vIENhcHR1cmUgZXJyb3JzIHNvIHRoZXkgZG9uJ3QgaW50ZXJydXB0IHVubW91bnRpbmcuXG5cblxuZnVuY3Rpb24gc2FmZWx5Q2FsbENvbXBvbmVudFdpbGxVbm1vdW50KGN1cnJlbnQsIGluc3RhbmNlKSB7XG4gIHtcbiAgICBpbnZva2VHdWFyZGVkQ2FsbGJhY2sobnVsbCwgY2FsbENvbXBvbmVudFdpbGxVbm1vdW50V2l0aFRpbWVyLCBudWxsLCBjdXJyZW50LCBpbnN0YW5jZSk7XG5cbiAgICBpZiAoaGFzQ2F1Z2h0RXJyb3IoKSkge1xuICAgICAgdmFyIHVubW91bnRFcnJvciA9IGNsZWFyQ2F1Z2h0RXJyb3IoKTtcbiAgICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKGN1cnJlbnQsIHVubW91bnRFcnJvcik7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHNhZmVseURldGFjaFJlZihjdXJyZW50KSB7XG4gIHZhciByZWYgPSBjdXJyZW50LnJlZjtcblxuICBpZiAocmVmICE9PSBudWxsKSB7XG4gICAgaWYgKHR5cGVvZiByZWYgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHtcbiAgICAgICAgaW52b2tlR3VhcmRlZENhbGxiYWNrKG51bGwsIHJlZiwgbnVsbCwgbnVsbCk7XG5cbiAgICAgICAgaWYgKGhhc0NhdWdodEVycm9yKCkpIHtcbiAgICAgICAgICB2YXIgcmVmRXJyb3IgPSBjbGVhckNhdWdodEVycm9yKCk7XG4gICAgICAgICAgY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IoY3VycmVudCwgcmVmRXJyb3IpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlZi5jdXJyZW50ID0gbnVsbDtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gc2FmZWx5Q2FsbERlc3Ryb3koY3VycmVudCwgZGVzdHJveSkge1xuICB7XG4gICAgaW52b2tlR3VhcmRlZENhbGxiYWNrKG51bGwsIGRlc3Ryb3ksIG51bGwpO1xuXG4gICAgaWYgKGhhc0NhdWdodEVycm9yKCkpIHtcbiAgICAgIHZhciBlcnJvciA9IGNsZWFyQ2F1Z2h0RXJyb3IoKTtcbiAgICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKGN1cnJlbnQsIGVycm9yKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY29tbWl0QmVmb3JlTXV0YXRpb25MaWZlQ3ljbGVzKGN1cnJlbnQsIGZpbmlzaGVkV29yaykge1xuICBzd2l0Y2ggKGZpbmlzaGVkV29yay50YWcpIHtcbiAgICBjYXNlIEZ1bmN0aW9uQ29tcG9uZW50OlxuICAgIGNhc2UgRm9yd2FyZFJlZjpcbiAgICBjYXNlIFNpbXBsZU1lbW9Db21wb25lbnQ6XG4gICAgY2FzZSBCbG9jazpcbiAgICAgIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgY2FzZSBDbGFzc0NvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgaWYgKGZpbmlzaGVkV29yay5mbGFncyAmIFNuYXBzaG90KSB7XG4gICAgICAgICAgaWYgKGN1cnJlbnQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHZhciBwcmV2UHJvcHMgPSBjdXJyZW50Lm1lbW9pemVkUHJvcHM7XG4gICAgICAgICAgICB2YXIgcHJldlN0YXRlID0gY3VycmVudC5tZW1vaXplZFN0YXRlO1xuICAgICAgICAgICAgdmFyIGluc3RhbmNlID0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZTsgLy8gV2UgY291bGQgdXBkYXRlIGluc3RhbmNlIHByb3BzIGFuZCBzdGF0ZSBoZXJlLFxuICAgICAgICAgICAgLy8gYnV0IGluc3RlYWQgd2UgcmVseSBvbiB0aGVtIGJlaW5nIHNldCBkdXJpbmcgbGFzdCByZW5kZXIuXG4gICAgICAgICAgICAvLyBUT0RPOiByZXZpc2l0IHRoaXMgd2hlbiB3ZSBpbXBsZW1lbnQgcmVzdW1pbmcuXG5cbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgaWYgKGZpbmlzaGVkV29yay50eXBlID09PSBmaW5pc2hlZFdvcmsuZWxlbWVudFR5cGUgJiYgIWRpZFdhcm5BYm91dFJlYXNzaWduaW5nUHJvcHMpIHtcbiAgICAgICAgICAgICAgICBpZiAoaW5zdGFuY2UucHJvcHMgIT09IGZpbmlzaGVkV29yay5tZW1vaXplZFByb3BzKSB7XG4gICAgICAgICAgICAgICAgICBlcnJvcignRXhwZWN0ZWQgJXMgcHJvcHMgdG8gbWF0Y2ggbWVtb2l6ZWQgcHJvcHMgYmVmb3JlICcgKyAnZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUuICcgKyAnVGhpcyBtaWdodCBlaXRoZXIgYmUgYmVjYXVzZSBvZiBhIGJ1ZyBpbiBSZWFjdCwgb3IgYmVjYXVzZSAnICsgJ2EgY29tcG9uZW50IHJlYXNzaWducyBpdHMgb3duIGB0aGlzLnByb3BzYC4gJyArICdQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nLCBnZXRDb21wb25lbnROYW1lKGZpbmlzaGVkV29yay50eXBlKSB8fCAnaW5zdGFuY2UnKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoaW5zdGFuY2Uuc3RhdGUgIT09IGZpbmlzaGVkV29yay5tZW1vaXplZFN0YXRlKSB7XG4gICAgICAgICAgICAgICAgICBlcnJvcignRXhwZWN0ZWQgJXMgc3RhdGUgdG8gbWF0Y2ggbWVtb2l6ZWQgc3RhdGUgYmVmb3JlICcgKyAnZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUuICcgKyAnVGhpcyBtaWdodCBlaXRoZXIgYmUgYmVjYXVzZSBvZiBhIGJ1ZyBpbiBSZWFjdCwgb3IgYmVjYXVzZSAnICsgJ2EgY29tcG9uZW50IHJlYXNzaWducyBpdHMgb3duIGB0aGlzLnN0YXRlYC4gJyArICdQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nLCBnZXRDb21wb25lbnROYW1lKGZpbmlzaGVkV29yay50eXBlKSB8fCAnaW5zdGFuY2UnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHNuYXBzaG90ID0gaW5zdGFuY2UuZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUoZmluaXNoZWRXb3JrLmVsZW1lbnRUeXBlID09PSBmaW5pc2hlZFdvcmsudHlwZSA/IHByZXZQcm9wcyA6IHJlc29sdmVEZWZhdWx0UHJvcHMoZmluaXNoZWRXb3JrLnR5cGUsIHByZXZQcm9wcyksIHByZXZTdGF0ZSk7XG5cbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgdmFyIGRpZFdhcm5TZXQgPSBkaWRXYXJuQWJvdXRVbmRlZmluZWRTbmFwc2hvdEJlZm9yZVVwZGF0ZTtcblxuICAgICAgICAgICAgICBpZiAoc25hcHNob3QgPT09IHVuZGVmaW5lZCAmJiAhZGlkV2FyblNldC5oYXMoZmluaXNoZWRXb3JrLnR5cGUpKSB7XG4gICAgICAgICAgICAgICAgZGlkV2FyblNldC5hZGQoZmluaXNoZWRXb3JrLnR5cGUpO1xuXG4gICAgICAgICAgICAgICAgZXJyb3IoJyVzLmdldFNuYXBzaG90QmVmb3JlVXBkYXRlKCk6IEEgc25hcHNob3QgdmFsdWUgKG9yIG51bGwpICcgKyAnbXVzdCBiZSByZXR1cm5lZC4gWW91IGhhdmUgcmV0dXJuZWQgdW5kZWZpbmVkLicsIGdldENvbXBvbmVudE5hbWUoZmluaXNoZWRXb3JrLnR5cGUpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpbnN0YW5jZS5fX3JlYWN0SW50ZXJuYWxTbmFwc2hvdEJlZm9yZVVwZGF0ZSA9IHNuYXBzaG90O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgICB7XG4gICAgICAgIHtcbiAgICAgICAgICBpZiAoZmluaXNoZWRXb3JrLmZsYWdzICYgU25hcHNob3QpIHtcbiAgICAgICAgICAgIHZhciByb290ID0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZTtcbiAgICAgICAgICAgIGNsZWFyQ29udGFpbmVyKHJvb3QuY29udGFpbmVySW5mbyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgIGNhc2UgSG9zdFRleHQ6XG4gICAgY2FzZSBIb3N0UG9ydGFsOlxuICAgIGNhc2UgSW5jb21wbGV0ZUNsYXNzQ29tcG9uZW50OlxuICAgICAgLy8gTm90aGluZyB0byBkbyBmb3IgdGhlc2UgY29tcG9uZW50IHR5cGVzXG4gICAgICByZXR1cm47XG4gIH1cblxuICB7XG4gICAge1xuICAgICAgdGhyb3cgRXJyb3IoIFwiVGhpcyB1bml0IG9mIHdvcmsgdGFnIHNob3VsZCBub3QgaGF2ZSBzaWRlLWVmZmVjdHMuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCIgKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY29tbWl0SG9va0VmZmVjdExpc3RVbm1vdW50KHRhZywgZmluaXNoZWRXb3JrKSB7XG4gIHZhciB1cGRhdGVRdWV1ZSA9IGZpbmlzaGVkV29yay51cGRhdGVRdWV1ZTtcbiAgdmFyIGxhc3RFZmZlY3QgPSB1cGRhdGVRdWV1ZSAhPT0gbnVsbCA/IHVwZGF0ZVF1ZXVlLmxhc3RFZmZlY3QgOiBudWxsO1xuXG4gIGlmIChsYXN0RWZmZWN0ICE9PSBudWxsKSB7XG4gICAgdmFyIGZpcnN0RWZmZWN0ID0gbGFzdEVmZmVjdC5uZXh0O1xuICAgIHZhciBlZmZlY3QgPSBmaXJzdEVmZmVjdDtcblxuICAgIGRvIHtcbiAgICAgIGlmICgoZWZmZWN0LnRhZyAmIHRhZykgPT09IHRhZykge1xuICAgICAgICAvLyBVbm1vdW50XG4gICAgICAgIHZhciBkZXN0cm95ID0gZWZmZWN0LmRlc3Ryb3k7XG4gICAgICAgIGVmZmVjdC5kZXN0cm95ID0gdW5kZWZpbmVkO1xuXG4gICAgICAgIGlmIChkZXN0cm95ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBkZXN0cm95KCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZWZmZWN0ID0gZWZmZWN0Lm5leHQ7XG4gICAgfSB3aGlsZSAoZWZmZWN0ICE9PSBmaXJzdEVmZmVjdCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY29tbWl0SG9va0VmZmVjdExpc3RNb3VudCh0YWcsIGZpbmlzaGVkV29yaykge1xuICB2YXIgdXBkYXRlUXVldWUgPSBmaW5pc2hlZFdvcmsudXBkYXRlUXVldWU7XG4gIHZhciBsYXN0RWZmZWN0ID0gdXBkYXRlUXVldWUgIT09IG51bGwgPyB1cGRhdGVRdWV1ZS5sYXN0RWZmZWN0IDogbnVsbDtcblxuICBpZiAobGFzdEVmZmVjdCAhPT0gbnVsbCkge1xuICAgIHZhciBmaXJzdEVmZmVjdCA9IGxhc3RFZmZlY3QubmV4dDtcbiAgICB2YXIgZWZmZWN0ID0gZmlyc3RFZmZlY3Q7XG5cbiAgICBkbyB7XG4gICAgICBpZiAoKGVmZmVjdC50YWcgJiB0YWcpID09PSB0YWcpIHtcbiAgICAgICAgLy8gTW91bnRcbiAgICAgICAgdmFyIGNyZWF0ZSA9IGVmZmVjdC5jcmVhdGU7XG4gICAgICAgIGVmZmVjdC5kZXN0cm95ID0gY3JlYXRlKCk7XG5cbiAgICAgICAge1xuICAgICAgICAgIHZhciBkZXN0cm95ID0gZWZmZWN0LmRlc3Ryb3k7XG5cbiAgICAgICAgICBpZiAoZGVzdHJveSAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiBkZXN0cm95ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB2YXIgYWRkZW5kdW0gPSB2b2lkIDA7XG5cbiAgICAgICAgICAgIGlmIChkZXN0cm95ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgIGFkZGVuZHVtID0gJyBZb3UgcmV0dXJuZWQgbnVsbC4gSWYgeW91ciBlZmZlY3QgZG9lcyBub3QgcmVxdWlyZSBjbGVhbiAnICsgJ3VwLCByZXR1cm4gdW5kZWZpbmVkIChvciBub3RoaW5nKS4nO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgZGVzdHJveS50aGVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgIGFkZGVuZHVtID0gJ1xcblxcbkl0IGxvb2tzIGxpa2UgeW91IHdyb3RlIHVzZUVmZmVjdChhc3luYyAoKSA9PiAuLi4pIG9yIHJldHVybmVkIGEgUHJvbWlzZS4gJyArICdJbnN0ZWFkLCB3cml0ZSB0aGUgYXN5bmMgZnVuY3Rpb24gaW5zaWRlIHlvdXIgZWZmZWN0ICcgKyAnYW5kIGNhbGwgaXQgaW1tZWRpYXRlbHk6XFxuXFxuJyArICd1c2VFZmZlY3QoKCkgPT4ge1xcbicgKyAnICBhc3luYyBmdW5jdGlvbiBmZXRjaERhdGEoKSB7XFxuJyArICcgICAgLy8gWW91IGNhbiBhd2FpdCBoZXJlXFxuJyArICcgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBNeUFQSS5nZXREYXRhKHNvbWVJZCk7XFxuJyArICcgICAgLy8gLi4uXFxuJyArICcgIH1cXG4nICsgJyAgZmV0Y2hEYXRhKCk7XFxuJyArIFwifSwgW3NvbWVJZF0pOyAvLyBPciBbXSBpZiBlZmZlY3QgZG9lc24ndCBuZWVkIHByb3BzIG9yIHN0YXRlXFxuXFxuXCIgKyAnTGVhcm4gbW9yZSBhYm91dCBkYXRhIGZldGNoaW5nIHdpdGggSG9va3M6IGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9ob29rcy1kYXRhLWZldGNoaW5nJztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGFkZGVuZHVtID0gJyBZb3UgcmV0dXJuZWQ6ICcgKyBkZXN0cm95O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBlcnJvcignQW4gZWZmZWN0IGZ1bmN0aW9uIG11c3Qgbm90IHJldHVybiBhbnl0aGluZyBiZXNpZGVzIGEgZnVuY3Rpb24sICcgKyAnd2hpY2ggaXMgdXNlZCBmb3IgY2xlYW4tdXAuJXMnLCBhZGRlbmR1bSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGVmZmVjdCA9IGVmZmVjdC5uZXh0O1xuICAgIH0gd2hpbGUgKGVmZmVjdCAhPT0gZmlyc3RFZmZlY3QpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHNjaGVkdWxlUGFzc2l2ZUVmZmVjdHMoZmluaXNoZWRXb3JrKSB7XG4gIHZhciB1cGRhdGVRdWV1ZSA9IGZpbmlzaGVkV29yay51cGRhdGVRdWV1ZTtcbiAgdmFyIGxhc3RFZmZlY3QgPSB1cGRhdGVRdWV1ZSAhPT0gbnVsbCA/IHVwZGF0ZVF1ZXVlLmxhc3RFZmZlY3QgOiBudWxsO1xuXG4gIGlmIChsYXN0RWZmZWN0ICE9PSBudWxsKSB7XG4gICAgdmFyIGZpcnN0RWZmZWN0ID0gbGFzdEVmZmVjdC5uZXh0O1xuICAgIHZhciBlZmZlY3QgPSBmaXJzdEVmZmVjdDtcblxuICAgIGRvIHtcbiAgICAgIHZhciBfZWZmZWN0ID0gZWZmZWN0LFxuICAgICAgICAgIG5leHQgPSBfZWZmZWN0Lm5leHQsXG4gICAgICAgICAgdGFnID0gX2VmZmVjdC50YWc7XG5cbiAgICAgIGlmICgodGFnICYgUGFzc2l2ZSQxKSAhPT0gTm9GbGFncyQxICYmICh0YWcgJiBIYXNFZmZlY3QpICE9PSBOb0ZsYWdzJDEpIHtcbiAgICAgICAgZW5xdWV1ZVBlbmRpbmdQYXNzaXZlSG9va0VmZmVjdFVubW91bnQoZmluaXNoZWRXb3JrLCBlZmZlY3QpO1xuICAgICAgICBlbnF1ZXVlUGVuZGluZ1Bhc3NpdmVIb29rRWZmZWN0TW91bnQoZmluaXNoZWRXb3JrLCBlZmZlY3QpO1xuICAgICAgfVxuXG4gICAgICBlZmZlY3QgPSBuZXh0O1xuICAgIH0gd2hpbGUgKGVmZmVjdCAhPT0gZmlyc3RFZmZlY3QpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNvbW1pdExpZmVDeWNsZXMoZmluaXNoZWRSb290LCBjdXJyZW50LCBmaW5pc2hlZFdvcmssIGNvbW1pdHRlZExhbmVzKSB7XG4gIHN3aXRjaCAoZmluaXNoZWRXb3JrLnRhZykge1xuICAgIGNhc2UgRnVuY3Rpb25Db21wb25lbnQ6XG4gICAgY2FzZSBGb3J3YXJkUmVmOlxuICAgIGNhc2UgU2ltcGxlTWVtb0NvbXBvbmVudDpcbiAgICBjYXNlIEJsb2NrOlxuICAgICAge1xuICAgICAgICAvLyBBdCB0aGlzIHBvaW50IGxheW91dCBlZmZlY3RzIGhhdmUgYWxyZWFkeSBiZWVuIGRlc3Ryb3llZCAoZHVyaW5nIG11dGF0aW9uIHBoYXNlKS5cbiAgICAgICAgLy8gVGhpcyBpcyBkb25lIHRvIHByZXZlbnQgc2libGluZyBjb21wb25lbnQgZWZmZWN0cyBmcm9tIGludGVyZmVyaW5nIHdpdGggZWFjaCBvdGhlcixcbiAgICAgICAgLy8gZS5nLiBhIGRlc3Ryb3kgZnVuY3Rpb24gaW4gb25lIGNvbXBvbmVudCBzaG91bGQgbmV2ZXIgb3ZlcnJpZGUgYSByZWYgc2V0XG4gICAgICAgIC8vIGJ5IGEgY3JlYXRlIGZ1bmN0aW9uIGluIGFub3RoZXIgY29tcG9uZW50IGR1cmluZyB0aGUgc2FtZSBjb21taXQuXG4gICAgICAgIHtcbiAgICAgICAgICBjb21taXRIb29rRWZmZWN0TGlzdE1vdW50KExheW91dCB8IEhhc0VmZmVjdCwgZmluaXNoZWRXb3JrKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNjaGVkdWxlUGFzc2l2ZUVmZmVjdHMoZmluaXNoZWRXb3JrKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgY2FzZSBDbGFzc0NvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgdmFyIGluc3RhbmNlID0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZTtcblxuICAgICAgICBpZiAoZmluaXNoZWRXb3JrLmZsYWdzICYgVXBkYXRlKSB7XG4gICAgICAgICAgaWYgKGN1cnJlbnQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIFdlIGNvdWxkIHVwZGF0ZSBpbnN0YW5jZSBwcm9wcyBhbmQgc3RhdGUgaGVyZSxcbiAgICAgICAgICAgIC8vIGJ1dCBpbnN0ZWFkIHdlIHJlbHkgb24gdGhlbSBiZWluZyBzZXQgZHVyaW5nIGxhc3QgcmVuZGVyLlxuICAgICAgICAgICAgLy8gVE9ETzogcmV2aXNpdCB0aGlzIHdoZW4gd2UgaW1wbGVtZW50IHJlc3VtaW5nLlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBpZiAoZmluaXNoZWRXb3JrLnR5cGUgPT09IGZpbmlzaGVkV29yay5lbGVtZW50VHlwZSAmJiAhZGlkV2FybkFib3V0UmVhc3NpZ25pbmdQcm9wcykge1xuICAgICAgICAgICAgICAgIGlmIChpbnN0YW5jZS5wcm9wcyAhPT0gZmluaXNoZWRXb3JrLm1lbW9pemVkUHJvcHMpIHtcbiAgICAgICAgICAgICAgICAgIGVycm9yKCdFeHBlY3RlZCAlcyBwcm9wcyB0byBtYXRjaCBtZW1vaXplZCBwcm9wcyBiZWZvcmUgJyArICdjb21wb25lbnREaWRNb3VudC4gJyArICdUaGlzIG1pZ2h0IGVpdGhlciBiZSBiZWNhdXNlIG9mIGEgYnVnIGluIFJlYWN0LCBvciBiZWNhdXNlICcgKyAnYSBjb21wb25lbnQgcmVhc3NpZ25zIGl0cyBvd24gYHRoaXMucHJvcHNgLiAnICsgJ1BsZWFzZSBmaWxlIGFuIGlzc3VlLicsIGdldENvbXBvbmVudE5hbWUoZmluaXNoZWRXb3JrLnR5cGUpIHx8ICdpbnN0YW5jZScpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChpbnN0YW5jZS5zdGF0ZSAhPT0gZmluaXNoZWRXb3JrLm1lbW9pemVkU3RhdGUpIHtcbiAgICAgICAgICAgICAgICAgIGVycm9yKCdFeHBlY3RlZCAlcyBzdGF0ZSB0byBtYXRjaCBtZW1vaXplZCBzdGF0ZSBiZWZvcmUgJyArICdjb21wb25lbnREaWRNb3VudC4gJyArICdUaGlzIG1pZ2h0IGVpdGhlciBiZSBiZWNhdXNlIG9mIGEgYnVnIGluIFJlYWN0LCBvciBiZWNhdXNlICcgKyAnYSBjb21wb25lbnQgcmVhc3NpZ25zIGl0cyBvd24gYHRoaXMuc3RhdGVgLiAnICsgJ1BsZWFzZSBmaWxlIGFuIGlzc3VlLicsIGdldENvbXBvbmVudE5hbWUoZmluaXNoZWRXb3JrLnR5cGUpIHx8ICdpbnN0YW5jZScpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGluc3RhbmNlLmNvbXBvbmVudERpZE1vdW50KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBwcmV2UHJvcHMgPSBmaW5pc2hlZFdvcmsuZWxlbWVudFR5cGUgPT09IGZpbmlzaGVkV29yay50eXBlID8gY3VycmVudC5tZW1vaXplZFByb3BzIDogcmVzb2x2ZURlZmF1bHRQcm9wcyhmaW5pc2hlZFdvcmsudHlwZSwgY3VycmVudC5tZW1vaXplZFByb3BzKTtcbiAgICAgICAgICAgIHZhciBwcmV2U3RhdGUgPSBjdXJyZW50Lm1lbW9pemVkU3RhdGU7IC8vIFdlIGNvdWxkIHVwZGF0ZSBpbnN0YW5jZSBwcm9wcyBhbmQgc3RhdGUgaGVyZSxcbiAgICAgICAgICAgIC8vIGJ1dCBpbnN0ZWFkIHdlIHJlbHkgb24gdGhlbSBiZWluZyBzZXQgZHVyaW5nIGxhc3QgcmVuZGVyLlxuICAgICAgICAgICAgLy8gVE9ETzogcmV2aXNpdCB0aGlzIHdoZW4gd2UgaW1wbGVtZW50IHJlc3VtaW5nLlxuXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGlmIChmaW5pc2hlZFdvcmsudHlwZSA9PT0gZmluaXNoZWRXb3JrLmVsZW1lbnRUeXBlICYmICFkaWRXYXJuQWJvdXRSZWFzc2lnbmluZ1Byb3BzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGluc3RhbmNlLnByb3BzICE9PSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRQcm9wcykge1xuICAgICAgICAgICAgICAgICAgZXJyb3IoJ0V4cGVjdGVkICVzIHByb3BzIHRvIG1hdGNoIG1lbW9pemVkIHByb3BzIGJlZm9yZSAnICsgJ2NvbXBvbmVudERpZFVwZGF0ZS4gJyArICdUaGlzIG1pZ2h0IGVpdGhlciBiZSBiZWNhdXNlIG9mIGEgYnVnIGluIFJlYWN0LCBvciBiZWNhdXNlICcgKyAnYSBjb21wb25lbnQgcmVhc3NpZ25zIGl0cyBvd24gYHRoaXMucHJvcHNgLiAnICsgJ1BsZWFzZSBmaWxlIGFuIGlzc3VlLicsIGdldENvbXBvbmVudE5hbWUoZmluaXNoZWRXb3JrLnR5cGUpIHx8ICdpbnN0YW5jZScpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChpbnN0YW5jZS5zdGF0ZSAhPT0gZmluaXNoZWRXb3JrLm1lbW9pemVkU3RhdGUpIHtcbiAgICAgICAgICAgICAgICAgIGVycm9yKCdFeHBlY3RlZCAlcyBzdGF0ZSB0byBtYXRjaCBtZW1vaXplZCBzdGF0ZSBiZWZvcmUgJyArICdjb21wb25lbnREaWRVcGRhdGUuICcgKyAnVGhpcyBtaWdodCBlaXRoZXIgYmUgYmVjYXVzZSBvZiBhIGJ1ZyBpbiBSZWFjdCwgb3IgYmVjYXVzZSAnICsgJ2EgY29tcG9uZW50IHJlYXNzaWducyBpdHMgb3duIGB0aGlzLnN0YXRlYC4gJyArICdQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nLCBnZXRDb21wb25lbnROYW1lKGZpbmlzaGVkV29yay50eXBlKSB8fCAnaW5zdGFuY2UnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBpbnN0YW5jZS5jb21wb25lbnREaWRVcGRhdGUocHJldlByb3BzLCBwcmV2U3RhdGUsIGluc3RhbmNlLl9fcmVhY3RJbnRlcm5hbFNuYXBzaG90QmVmb3JlVXBkYXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gLy8gVE9ETzogSSB0aGluayB0aGlzIGlzIG5vdyBhbHdheXMgbm9uLW51bGwgYnkgdGhlIHRpbWUgaXQgcmVhY2hlcyB0aGVcbiAgICAgICAgLy8gY29tbWl0IHBoYXNlLiBDb25zaWRlciByZW1vdmluZyB0aGUgdHlwZSBjaGVjay5cblxuXG4gICAgICAgIHZhciB1cGRhdGVRdWV1ZSA9IGZpbmlzaGVkV29yay51cGRhdGVRdWV1ZTtcblxuICAgICAgICBpZiAodXBkYXRlUXVldWUgIT09IG51bGwpIHtcbiAgICAgICAgICB7XG4gICAgICAgICAgICBpZiAoZmluaXNoZWRXb3JrLnR5cGUgPT09IGZpbmlzaGVkV29yay5lbGVtZW50VHlwZSAmJiAhZGlkV2FybkFib3V0UmVhc3NpZ25pbmdQcm9wcykge1xuICAgICAgICAgICAgICBpZiAoaW5zdGFuY2UucHJvcHMgIT09IGZpbmlzaGVkV29yay5tZW1vaXplZFByb3BzKSB7XG4gICAgICAgICAgICAgICAgZXJyb3IoJ0V4cGVjdGVkICVzIHByb3BzIHRvIG1hdGNoIG1lbW9pemVkIHByb3BzIGJlZm9yZSAnICsgJ3Byb2Nlc3NpbmcgdGhlIHVwZGF0ZSBxdWV1ZS4gJyArICdUaGlzIG1pZ2h0IGVpdGhlciBiZSBiZWNhdXNlIG9mIGEgYnVnIGluIFJlYWN0LCBvciBiZWNhdXNlICcgKyAnYSBjb21wb25lbnQgcmVhc3NpZ25zIGl0cyBvd24gYHRoaXMucHJvcHNgLiAnICsgJ1BsZWFzZSBmaWxlIGFuIGlzc3VlLicsIGdldENvbXBvbmVudE5hbWUoZmluaXNoZWRXb3JrLnR5cGUpIHx8ICdpbnN0YW5jZScpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKGluc3RhbmNlLnN0YXRlICE9PSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRTdGF0ZSkge1xuICAgICAgICAgICAgICAgIGVycm9yKCdFeHBlY3RlZCAlcyBzdGF0ZSB0byBtYXRjaCBtZW1vaXplZCBzdGF0ZSBiZWZvcmUgJyArICdwcm9jZXNzaW5nIHRoZSB1cGRhdGUgcXVldWUuICcgKyAnVGhpcyBtaWdodCBlaXRoZXIgYmUgYmVjYXVzZSBvZiBhIGJ1ZyBpbiBSZWFjdCwgb3IgYmVjYXVzZSAnICsgJ2EgY29tcG9uZW50IHJlYXNzaWducyBpdHMgb3duIGB0aGlzLnN0YXRlYC4gJyArICdQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nLCBnZXRDb21wb25lbnROYW1lKGZpbmlzaGVkV29yay50eXBlKSB8fCAnaW5zdGFuY2UnKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gLy8gV2UgY291bGQgdXBkYXRlIGluc3RhbmNlIHByb3BzIGFuZCBzdGF0ZSBoZXJlLFxuICAgICAgICAgIC8vIGJ1dCBpbnN0ZWFkIHdlIHJlbHkgb24gdGhlbSBiZWluZyBzZXQgZHVyaW5nIGxhc3QgcmVuZGVyLlxuICAgICAgICAgIC8vIFRPRE86IHJldmlzaXQgdGhpcyB3aGVuIHdlIGltcGxlbWVudCByZXN1bWluZy5cblxuXG4gICAgICAgICAgY29tbWl0VXBkYXRlUXVldWUoZmluaXNoZWRXb3JrLCB1cGRhdGVRdWV1ZSwgaW5zdGFuY2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgY2FzZSBIb3N0Um9vdDpcbiAgICAgIHtcbiAgICAgICAgLy8gVE9ETzogSSB0aGluayB0aGlzIGlzIG5vdyBhbHdheXMgbm9uLW51bGwgYnkgdGhlIHRpbWUgaXQgcmVhY2hlcyB0aGVcbiAgICAgICAgLy8gY29tbWl0IHBoYXNlLiBDb25zaWRlciByZW1vdmluZyB0aGUgdHlwZSBjaGVjay5cbiAgICAgICAgdmFyIF91cGRhdGVRdWV1ZSA9IGZpbmlzaGVkV29yay51cGRhdGVRdWV1ZTtcblxuICAgICAgICBpZiAoX3VwZGF0ZVF1ZXVlICE9PSBudWxsKSB7XG4gICAgICAgICAgdmFyIF9pbnN0YW5jZSA9IG51bGw7XG5cbiAgICAgICAgICBpZiAoZmluaXNoZWRXb3JrLmNoaWxkICE9PSBudWxsKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKGZpbmlzaGVkV29yay5jaGlsZC50YWcpIHtcbiAgICAgICAgICAgICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAgICAgICAgICAgIF9pbnN0YW5jZSA9IGdldFB1YmxpY0luc3RhbmNlKGZpbmlzaGVkV29yay5jaGlsZC5zdGF0ZU5vZGUpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG4gICAgICAgICAgICAgICAgX2luc3RhbmNlID0gZmluaXNoZWRXb3JrLmNoaWxkLnN0YXRlTm9kZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb21taXRVcGRhdGVRdWV1ZShmaW5pc2hlZFdvcmssIF91cGRhdGVRdWV1ZSwgX2luc3RhbmNlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgdmFyIF9pbnN0YW5jZTIgPSBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlOyAvLyBSZW5kZXJlcnMgbWF5IHNjaGVkdWxlIHdvcmsgdG8gYmUgZG9uZSBhZnRlciBob3N0IGNvbXBvbmVudHMgYXJlIG1vdW50ZWRcbiAgICAgICAgLy8gKGVnIERPTSByZW5kZXJlciBtYXkgc2NoZWR1bGUgYXV0by1mb2N1cyBmb3IgaW5wdXRzIGFuZCBmb3JtIGNvbnRyb2xzKS5cbiAgICAgICAgLy8gVGhlc2UgZWZmZWN0cyBzaG91bGQgb25seSBiZSBjb21taXR0ZWQgd2hlbiBjb21wb25lbnRzIGFyZSBmaXJzdCBtb3VudGVkLFxuICAgICAgICAvLyBha2Egd2hlbiB0aGVyZSBpcyBubyBjdXJyZW50L2FsdGVybmF0ZS5cblxuICAgICAgICBpZiAoY3VycmVudCA9PT0gbnVsbCAmJiBmaW5pc2hlZFdvcmsuZmxhZ3MgJiBVcGRhdGUpIHtcbiAgICAgICAgICB2YXIgdHlwZSA9IGZpbmlzaGVkV29yay50eXBlO1xuICAgICAgICAgIHZhciBwcm9wcyA9IGZpbmlzaGVkV29yay5tZW1vaXplZFByb3BzO1xuICAgICAgICAgIGNvbW1pdE1vdW50KF9pbnN0YW5jZTIsIHR5cGUsIHByb3BzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgIGNhc2UgSG9zdFRleHQ6XG4gICAgICB7XG4gICAgICAgIC8vIFdlIGhhdmUgbm8gbGlmZS1jeWNsZXMgYXNzb2NpYXRlZCB3aXRoIHRleHQuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgIGNhc2UgSG9zdFBvcnRhbDpcbiAgICAgIHtcbiAgICAgICAgLy8gV2UgaGF2ZSBubyBsaWZlLWN5Y2xlcyBhc3NvY2lhdGVkIHdpdGggcG9ydGFscy5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgY2FzZSBQcm9maWxlcjpcbiAgICAgIHtcbiAgICAgICAge1xuICAgICAgICAgIHZhciBfZmluaXNoZWRXb3JrJG1lbW9pemUyID0gZmluaXNoZWRXb3JrLm1lbW9pemVkUHJvcHMsXG4gICAgICAgICAgICAgIG9uQ29tbWl0ID0gX2ZpbmlzaGVkV29yayRtZW1vaXplMi5vbkNvbW1pdCxcbiAgICAgICAgICAgICAgb25SZW5kZXIgPSBfZmluaXNoZWRXb3JrJG1lbW9pemUyLm9uUmVuZGVyO1xuICAgICAgICAgIHZhciBlZmZlY3REdXJhdGlvbiA9IGZpbmlzaGVkV29yay5zdGF0ZU5vZGUuZWZmZWN0RHVyYXRpb247XG4gICAgICAgICAgdmFyIGNvbW1pdFRpbWUgPSBnZXRDb21taXRUaW1lKCk7XG5cbiAgICAgICAgICBpZiAodHlwZW9mIG9uUmVuZGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIG9uUmVuZGVyKGZpbmlzaGVkV29yay5tZW1vaXplZFByb3BzLmlkLCBjdXJyZW50ID09PSBudWxsID8gJ21vdW50JyA6ICd1cGRhdGUnLCBmaW5pc2hlZFdvcmsuYWN0dWFsRHVyYXRpb24sIGZpbmlzaGVkV29yay50cmVlQmFzZUR1cmF0aW9uLCBmaW5pc2hlZFdvcmsuYWN0dWFsU3RhcnRUaW1lLCBjb21taXRUaW1lLCBmaW5pc2hlZFJvb3QubWVtb2l6ZWRJbnRlcmFjdGlvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgIGNhc2UgU3VzcGVuc2VDb21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIGNvbW1pdFN1c3BlbnNlSHlkcmF0aW9uQ2FsbGJhY2tzKGZpbmlzaGVkUm9vdCwgZmluaXNoZWRXb3JrKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgY2FzZSBTdXNwZW5zZUxpc3RDb21wb25lbnQ6XG4gICAgY2FzZSBJbmNvbXBsZXRlQ2xhc3NDb21wb25lbnQ6XG4gICAgY2FzZSBGdW5kYW1lbnRhbENvbXBvbmVudDpcbiAgICBjYXNlIFNjb3BlQ29tcG9uZW50OlxuICAgIGNhc2UgT2Zmc2NyZWVuQ29tcG9uZW50OlxuICAgIGNhc2UgTGVnYWN5SGlkZGVuQ29tcG9uZW50OlxuICAgICAgcmV0dXJuO1xuICB9XG5cbiAge1xuICAgIHtcbiAgICAgIHRocm93IEVycm9yKCBcIlRoaXMgdW5pdCBvZiB3b3JrIHRhZyBzaG91bGQgbm90IGhhdmUgc2lkZS1lZmZlY3RzLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiICk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGhpZGVPclVuaGlkZUFsbENoaWxkcmVuKGZpbmlzaGVkV29yaywgaXNIaWRkZW4pIHtcbiAge1xuICAgIC8vIFdlIG9ubHkgaGF2ZSB0aGUgdG9wIEZpYmVyIHRoYXQgd2FzIGluc2VydGVkIGJ1dCB3ZSBuZWVkIHRvIHJlY3Vyc2UgZG93biBpdHNcbiAgICAvLyBjaGlsZHJlbiB0byBmaW5kIGFsbCB0aGUgdGVybWluYWwgbm9kZXMuXG4gICAgdmFyIG5vZGUgPSBmaW5pc2hlZFdvcms7XG5cbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgaWYgKG5vZGUudGFnID09PSBIb3N0Q29tcG9uZW50KSB7XG4gICAgICAgIHZhciBpbnN0YW5jZSA9IG5vZGUuc3RhdGVOb2RlO1xuXG4gICAgICAgIGlmIChpc0hpZGRlbikge1xuICAgICAgICAgIGhpZGVJbnN0YW5jZShpbnN0YW5jZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdW5oaWRlSW5zdGFuY2Uobm9kZS5zdGF0ZU5vZGUsIG5vZGUubWVtb2l6ZWRQcm9wcyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAobm9kZS50YWcgPT09IEhvc3RUZXh0KSB7XG4gICAgICAgIHZhciBfaW5zdGFuY2UzID0gbm9kZS5zdGF0ZU5vZGU7XG5cbiAgICAgICAgaWYgKGlzSGlkZGVuKSB7XG4gICAgICAgICAgaGlkZVRleHRJbnN0YW5jZShfaW5zdGFuY2UzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB1bmhpZGVUZXh0SW5zdGFuY2UoX2luc3RhbmNlMywgbm9kZS5tZW1vaXplZFByb3BzKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICgobm9kZS50YWcgPT09IE9mZnNjcmVlbkNvbXBvbmVudCB8fCBub2RlLnRhZyA9PT0gTGVnYWN5SGlkZGVuQ29tcG9uZW50KSAmJiBub2RlLm1lbW9pemVkU3RhdGUgIT09IG51bGwgJiYgbm9kZSAhPT0gZmluaXNoZWRXb3JrKSA7IGVsc2UgaWYgKG5vZGUuY2hpbGQgIT09IG51bGwpIHtcbiAgICAgICAgbm9kZS5jaGlsZC5yZXR1cm4gPSBub2RlO1xuICAgICAgICBub2RlID0gbm9kZS5jaGlsZDtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChub2RlID09PSBmaW5pc2hlZFdvcmspIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB3aGlsZSAobm9kZS5zaWJsaW5nID09PSBudWxsKSB7XG4gICAgICAgIGlmIChub2RlLnJldHVybiA9PT0gbnVsbCB8fCBub2RlLnJldHVybiA9PT0gZmluaXNoZWRXb3JrKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgbm9kZSA9IG5vZGUucmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBub2RlLnNpYmxpbmcucmV0dXJuID0gbm9kZS5yZXR1cm47XG4gICAgICBub2RlID0gbm9kZS5zaWJsaW5nO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjb21taXRBdHRhY2hSZWYoZmluaXNoZWRXb3JrKSB7XG4gIHZhciByZWYgPSBmaW5pc2hlZFdvcmsucmVmO1xuXG4gIGlmIChyZWYgIT09IG51bGwpIHtcbiAgICB2YXIgaW5zdGFuY2UgPSBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlO1xuICAgIHZhciBpbnN0YW5jZVRvVXNlO1xuXG4gICAgc3dpdGNoIChmaW5pc2hlZFdvcmsudGFnKSB7XG4gICAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICAgIGluc3RhbmNlVG9Vc2UgPSBnZXRQdWJsaWNJbnN0YW5jZShpbnN0YW5jZSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpbnN0YW5jZVRvVXNlID0gaW5zdGFuY2U7XG4gICAgfSAvLyBNb3ZlZCBvdXRzaWRlIHRvIGVuc3VyZSBEQ0Ugd29ya3Mgd2l0aCB0aGlzIGZsYWdcblxuICAgIGlmICh0eXBlb2YgcmVmID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZWYoaW5zdGFuY2VUb1VzZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHtcbiAgICAgICAgaWYgKCFyZWYuaGFzT3duUHJvcGVydHkoJ2N1cnJlbnQnKSkge1xuICAgICAgICAgIGVycm9yKCdVbmV4cGVjdGVkIHJlZiBvYmplY3QgcHJvdmlkZWQgZm9yICVzLiAnICsgJ1VzZSBlaXRoZXIgYSByZWYtc2V0dGVyIGZ1bmN0aW9uIG9yIFJlYWN0LmNyZWF0ZVJlZigpLicsIGdldENvbXBvbmVudE5hbWUoZmluaXNoZWRXb3JrLnR5cGUpKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZWYuY3VycmVudCA9IGluc3RhbmNlVG9Vc2U7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNvbW1pdERldGFjaFJlZihjdXJyZW50KSB7XG4gIHZhciBjdXJyZW50UmVmID0gY3VycmVudC5yZWY7XG5cbiAgaWYgKGN1cnJlbnRSZWYgIT09IG51bGwpIHtcbiAgICBpZiAodHlwZW9mIGN1cnJlbnRSZWYgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGN1cnJlbnRSZWYobnVsbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGN1cnJlbnRSZWYuY3VycmVudCA9IG51bGw7XG4gICAgfVxuICB9XG59IC8vIFVzZXItb3JpZ2luYXRpbmcgZXJyb3JzIChsaWZlY3ljbGVzIGFuZCByZWZzKSBzaG91bGQgbm90IGludGVycnVwdFxuLy8gZGVsZXRpb24sIHNvIGRvbid0IGxldCB0aGVtIHRocm93LiBIb3N0LW9yaWdpbmF0aW5nIGVycm9ycyBzaG91bGRcbi8vIGludGVycnVwdCBkZWxldGlvbiwgc28gaXQncyBva2F5XG5cblxuZnVuY3Rpb24gY29tbWl0VW5tb3VudChmaW5pc2hlZFJvb3QsIGN1cnJlbnQsIHJlbmRlclByaW9yaXR5TGV2ZWwpIHtcbiAgb25Db21taXRVbm1vdW50KGN1cnJlbnQpO1xuXG4gIHN3aXRjaCAoY3VycmVudC50YWcpIHtcbiAgICBjYXNlIEZ1bmN0aW9uQ29tcG9uZW50OlxuICAgIGNhc2UgRm9yd2FyZFJlZjpcbiAgICBjYXNlIE1lbW9Db21wb25lbnQ6XG4gICAgY2FzZSBTaW1wbGVNZW1vQ29tcG9uZW50OlxuICAgIGNhc2UgQmxvY2s6XG4gICAgICB7XG4gICAgICAgIHZhciB1cGRhdGVRdWV1ZSA9IGN1cnJlbnQudXBkYXRlUXVldWU7XG5cbiAgICAgICAgaWYgKHVwZGF0ZVF1ZXVlICE9PSBudWxsKSB7XG4gICAgICAgICAgdmFyIGxhc3RFZmZlY3QgPSB1cGRhdGVRdWV1ZS5sYXN0RWZmZWN0O1xuXG4gICAgICAgICAgaWYgKGxhc3RFZmZlY3QgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHZhciBmaXJzdEVmZmVjdCA9IGxhc3RFZmZlY3QubmV4dDtcbiAgICAgICAgICAgIHZhciBlZmZlY3QgPSBmaXJzdEVmZmVjdDtcblxuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICB2YXIgX2VmZmVjdDIgPSBlZmZlY3QsXG4gICAgICAgICAgICAgICAgICBkZXN0cm95ID0gX2VmZmVjdDIuZGVzdHJveSxcbiAgICAgICAgICAgICAgICAgIHRhZyA9IF9lZmZlY3QyLnRhZztcblxuICAgICAgICAgICAgICBpZiAoZGVzdHJveSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKCh0YWcgJiBQYXNzaXZlJDEpICE9PSBOb0ZsYWdzJDEpIHtcbiAgICAgICAgICAgICAgICAgIGVucXVldWVQZW5kaW5nUGFzc2l2ZUhvb2tFZmZlY3RVbm1vdW50KGN1cnJlbnQsIGVmZmVjdCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgc2FmZWx5Q2FsbERlc3Ryb3koY3VycmVudCwgZGVzdHJveSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgZWZmZWN0ID0gZWZmZWN0Lm5leHQ7XG4gICAgICAgICAgICB9IHdoaWxlIChlZmZlY3QgIT09IGZpcnN0RWZmZWN0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICBjYXNlIENsYXNzQ29tcG9uZW50OlxuICAgICAge1xuICAgICAgICBzYWZlbHlEZXRhY2hSZWYoY3VycmVudCk7XG4gICAgICAgIHZhciBpbnN0YW5jZSA9IGN1cnJlbnQuc3RhdGVOb2RlO1xuXG4gICAgICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbFVubW91bnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBzYWZlbHlDYWxsQ29tcG9uZW50V2lsbFVubW91bnQoY3VycmVudCwgaW5zdGFuY2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAge1xuICAgICAgICBzYWZlbHlEZXRhY2hSZWYoY3VycmVudCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgIGNhc2UgSG9zdFBvcnRhbDpcbiAgICAgIHtcbiAgICAgICAgLy8gVE9ETzogdGhpcyBpcyByZWN1cnNpdmUuXG4gICAgICAgIC8vIFdlIGFyZSBhbHNvIG5vdCB1c2luZyB0aGlzIHBhcmVudCBiZWNhdXNlXG4gICAgICAgIC8vIHRoZSBwb3J0YWwgd2lsbCBnZXQgcHVzaGVkIGltbWVkaWF0ZWx5LlxuICAgICAgICB7XG4gICAgICAgICAgdW5tb3VudEhvc3RDb21wb25lbnRzKGZpbmlzaGVkUm9vdCwgY3VycmVudCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICBjYXNlIEZ1bmRhbWVudGFsQ29tcG9uZW50OlxuICAgICAge1xuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgIGNhc2UgRGVoeWRyYXRlZEZyYWdtZW50OlxuICAgICAge1xuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgIGNhc2UgU2NvcGVDb21wb25lbnQ6XG4gICAgICB7XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNvbW1pdE5lc3RlZFVubW91bnRzKGZpbmlzaGVkUm9vdCwgcm9vdCwgcmVuZGVyUHJpb3JpdHlMZXZlbCkge1xuICAvLyBXaGlsZSB3ZSdyZSBpbnNpZGUgYSByZW1vdmVkIGhvc3Qgbm9kZSB3ZSBkb24ndCB3YW50IHRvIGNhbGxcbiAgLy8gcmVtb3ZlQ2hpbGQgb24gdGhlIGlubmVyIG5vZGVzIGJlY2F1c2UgdGhleSdyZSByZW1vdmVkIGJ5IHRoZSB0b3BcbiAgLy8gY2FsbCBhbnl3YXkuIFdlIGFsc28gd2FudCB0byBjYWxsIGNvbXBvbmVudFdpbGxVbm1vdW50IG9uIGFsbFxuICAvLyBjb21wb3NpdGVzIGJlZm9yZSB0aGlzIGhvc3Qgbm9kZSBpcyByZW1vdmVkIGZyb20gdGhlIHRyZWUuIFRoZXJlZm9yZVxuICAvLyB3ZSBkbyBhbiBpbm5lciBsb29wIHdoaWxlIHdlJ3JlIHN0aWxsIGluc2lkZSB0aGUgaG9zdCBub2RlLlxuICB2YXIgbm9kZSA9IHJvb3Q7XG5cbiAgd2hpbGUgKHRydWUpIHtcbiAgICBjb21taXRVbm1vdW50KGZpbmlzaGVkUm9vdCwgbm9kZSk7IC8vIFZpc2l0IGNoaWxkcmVuIGJlY2F1c2UgdGhleSBtYXkgY29udGFpbiBtb3JlIGNvbXBvc2l0ZSBvciBob3N0IG5vZGVzLlxuICAgIC8vIFNraXAgcG9ydGFscyBiZWNhdXNlIGNvbW1pdFVubW91bnQoKSBjdXJyZW50bHkgdmlzaXRzIHRoZW0gcmVjdXJzaXZlbHkuXG5cbiAgICBpZiAobm9kZS5jaGlsZCAhPT0gbnVsbCAmJiAoIC8vIElmIHdlIHVzZSBtdXRhdGlvbiB3ZSBkcmlsbCBkb3duIGludG8gcG9ydGFscyB1c2luZyBjb21taXRVbm1vdW50IGFib3ZlLlxuICAgIC8vIElmIHdlIGRvbid0IHVzZSBtdXRhdGlvbiB3ZSBkcmlsbCBkb3duIGludG8gcG9ydGFscyBoZXJlIGluc3RlYWQuXG4gICAgIG5vZGUudGFnICE9PSBIb3N0UG9ydGFsKSkge1xuICAgICAgbm9kZS5jaGlsZC5yZXR1cm4gPSBub2RlO1xuICAgICAgbm9kZSA9IG5vZGUuY2hpbGQ7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAobm9kZSA9PT0gcm9vdCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHdoaWxlIChub2RlLnNpYmxpbmcgPT09IG51bGwpIHtcbiAgICAgIGlmIChub2RlLnJldHVybiA9PT0gbnVsbCB8fCBub2RlLnJldHVybiA9PT0gcm9vdCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIG5vZGUgPSBub2RlLnJldHVybjtcbiAgICB9XG5cbiAgICBub2RlLnNpYmxpbmcucmV0dXJuID0gbm9kZS5yZXR1cm47XG4gICAgbm9kZSA9IG5vZGUuc2libGluZztcbiAgfVxufVxuXG5mdW5jdGlvbiBkZXRhY2hGaWJlck11dGF0aW9uKGZpYmVyKSB7XG4gIC8vIEN1dCBvZmYgdGhlIHJldHVybiBwb2ludGVycyB0byBkaXNjb25uZWN0IGl0IGZyb20gdGhlIHRyZWUuIElkZWFsbHksIHdlXG4gIC8vIHNob3VsZCBjbGVhciB0aGUgY2hpbGQgcG9pbnRlciBvZiB0aGUgcGFyZW50IGFsdGVybmF0ZSB0byBsZXQgdGhpc1xuICAvLyBnZXQgR0M6ZWQgYnV0IHdlIGRvbid0IGtub3cgd2hpY2ggZm9yIHN1cmUgd2hpY2ggcGFyZW50IGlzIHRoZSBjdXJyZW50XG4gIC8vIG9uZSBzbyB3ZSdsbCBzZXR0bGUgZm9yIEdDOmluZyB0aGUgc3VidHJlZSBvZiB0aGlzIGNoaWxkLiBUaGlzIGNoaWxkXG4gIC8vIGl0c2VsZiB3aWxsIGJlIEdDOmVkIHdoZW4gdGhlIHBhcmVudCB1cGRhdGVzIHRoZSBuZXh0IHRpbWUuXG4gIC8vIE5vdGU6IHdlIGNhbm5vdCBudWxsIG91dCBzaWJsaW5nIGhlcmUsIG90aGVyd2lzZSBpdCBjYW4gY2F1c2UgaXNzdWVzXG4gIC8vIHdpdGggZmluZERPTU5vZGUgYW5kIGhvdyBpdCByZXF1aXJlcyB0aGUgc2libGluZyBmaWVsZCB0byBjYXJyeSBvdXRcbiAgLy8gdHJhdmVyc2FsIGluIGEgbGF0ZXIgZWZmZWN0LiBTZWUgUFIgIzE2ODIwLiBXZSBub3cgY2xlYXIgdGhlIHNpYmxpbmdcbiAgLy8gZmllbGQgYWZ0ZXIgZWZmZWN0cywgc2VlOiBkZXRhY2hGaWJlckFmdGVyRWZmZWN0cy5cbiAgLy9cbiAgLy8gRG9uJ3QgZGlzY29ubmVjdCBzdGF0ZU5vZGUgbm93OyBpdCB3aWxsIGJlIGRldGFjaGVkIGluIGRldGFjaEZpYmVyQWZ0ZXJFZmZlY3RzLlxuICAvLyBJdCBtYXkgYmUgcmVxdWlyZWQgaWYgdGhlIGN1cnJlbnQgY29tcG9uZW50IGlzIGFuIGVycm9yIGJvdW5kYXJ5LFxuICAvLyBhbmQgb25lIG9mIGl0cyBkZXNjZW5kYW50cyB0aHJvd3Mgd2hpbGUgdW5tb3VudGluZyBhIHBhc3NpdmUgZWZmZWN0LlxuICBmaWJlci5hbHRlcm5hdGUgPSBudWxsO1xuICBmaWJlci5jaGlsZCA9IG51bGw7XG4gIGZpYmVyLmRlcGVuZGVuY2llcyA9IG51bGw7XG4gIGZpYmVyLmZpcnN0RWZmZWN0ID0gbnVsbDtcbiAgZmliZXIubGFzdEVmZmVjdCA9IG51bGw7XG4gIGZpYmVyLm1lbW9pemVkUHJvcHMgPSBudWxsO1xuICBmaWJlci5tZW1vaXplZFN0YXRlID0gbnVsbDtcbiAgZmliZXIucGVuZGluZ1Byb3BzID0gbnVsbDtcbiAgZmliZXIucmV0dXJuID0gbnVsbDtcbiAgZmliZXIudXBkYXRlUXVldWUgPSBudWxsO1xuXG4gIHtcbiAgICBmaWJlci5fZGVidWdPd25lciA9IG51bGw7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0SG9zdFBhcmVudEZpYmVyKGZpYmVyKSB7XG4gIHZhciBwYXJlbnQgPSBmaWJlci5yZXR1cm47XG5cbiAgd2hpbGUgKHBhcmVudCAhPT0gbnVsbCkge1xuICAgIGlmIChpc0hvc3RQYXJlbnQocGFyZW50KSkge1xuICAgICAgcmV0dXJuIHBhcmVudDtcbiAgICB9XG5cbiAgICBwYXJlbnQgPSBwYXJlbnQucmV0dXJuO1xuICB9XG5cbiAge1xuICAgIHtcbiAgICAgIHRocm93IEVycm9yKCBcIkV4cGVjdGVkIHRvIGZpbmQgYSBob3N0IHBhcmVudC4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS5cIiApO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBpc0hvc3RQYXJlbnQoZmliZXIpIHtcbiAgcmV0dXJuIGZpYmVyLnRhZyA9PT0gSG9zdENvbXBvbmVudCB8fCBmaWJlci50YWcgPT09IEhvc3RSb290IHx8IGZpYmVyLnRhZyA9PT0gSG9zdFBvcnRhbDtcbn1cblxuZnVuY3Rpb24gZ2V0SG9zdFNpYmxpbmcoZmliZXIpIHtcbiAgLy8gV2UncmUgZ29pbmcgdG8gc2VhcmNoIGZvcndhcmQgaW50byB0aGUgdHJlZSB1bnRpbCB3ZSBmaW5kIGEgc2libGluZyBob3N0XG4gIC8vIG5vZGUuIFVuZm9ydHVuYXRlbHksIGlmIG11bHRpcGxlIGluc2VydGlvbnMgYXJlIGRvbmUgaW4gYSByb3cgd2UgaGF2ZSB0b1xuICAvLyBzZWFyY2ggcGFzdCB0aGVtLiBUaGlzIGxlYWRzIHRvIGV4cG9uZW50aWFsIHNlYXJjaCBmb3IgdGhlIG5leHQgc2libGluZy5cbiAgLy8gVE9ETzogRmluZCBhIG1vcmUgZWZmaWNpZW50IHdheSB0byBkbyB0aGlzLlxuICB2YXIgbm9kZSA9IGZpYmVyO1xuXG4gIHNpYmxpbmdzOiB3aGlsZSAodHJ1ZSkge1xuICAgIC8vIElmIHdlIGRpZG4ndCBmaW5kIGFueXRoaW5nLCBsZXQncyB0cnkgdGhlIG5leHQgc2libGluZy5cbiAgICB3aGlsZSAobm9kZS5zaWJsaW5nID09PSBudWxsKSB7XG4gICAgICBpZiAobm9kZS5yZXR1cm4gPT09IG51bGwgfHwgaXNIb3N0UGFyZW50KG5vZGUucmV0dXJuKSkge1xuICAgICAgICAvLyBJZiB3ZSBwb3Agb3V0IG9mIHRoZSByb290IG9yIGhpdCB0aGUgcGFyZW50IHRoZSBmaWJlciB3ZSBhcmUgdGhlXG4gICAgICAgIC8vIGxhc3Qgc2libGluZy5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIG5vZGUgPSBub2RlLnJldHVybjtcbiAgICB9XG5cbiAgICBub2RlLnNpYmxpbmcucmV0dXJuID0gbm9kZS5yZXR1cm47XG4gICAgbm9kZSA9IG5vZGUuc2libGluZztcblxuICAgIHdoaWxlIChub2RlLnRhZyAhPT0gSG9zdENvbXBvbmVudCAmJiBub2RlLnRhZyAhPT0gSG9zdFRleHQgJiYgbm9kZS50YWcgIT09IERlaHlkcmF0ZWRGcmFnbWVudCkge1xuICAgICAgLy8gSWYgaXQgaXMgbm90IGhvc3Qgbm9kZSBhbmQsIHdlIG1pZ2h0IGhhdmUgYSBob3N0IG5vZGUgaW5zaWRlIGl0LlxuICAgICAgLy8gVHJ5IHRvIHNlYXJjaCBkb3duIHVudGlsIHdlIGZpbmQgb25lLlxuICAgICAgaWYgKG5vZGUuZmxhZ3MgJiBQbGFjZW1lbnQpIHtcbiAgICAgICAgLy8gSWYgd2UgZG9uJ3QgaGF2ZSBhIGNoaWxkLCB0cnkgdGhlIHNpYmxpbmdzIGluc3RlYWQuXG4gICAgICAgIGNvbnRpbnVlIHNpYmxpbmdzO1xuICAgICAgfSAvLyBJZiB3ZSBkb24ndCBoYXZlIGEgY2hpbGQsIHRyeSB0aGUgc2libGluZ3MgaW5zdGVhZC5cbiAgICAgIC8vIFdlIGFsc28gc2tpcCBwb3J0YWxzIGJlY2F1c2UgdGhleSBhcmUgbm90IHBhcnQgb2YgdGhpcyBob3N0IHRyZWUuXG5cblxuICAgICAgaWYgKG5vZGUuY2hpbGQgPT09IG51bGwgfHwgbm9kZS50YWcgPT09IEhvc3RQb3J0YWwpIHtcbiAgICAgICAgY29udGludWUgc2libGluZ3M7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub2RlLmNoaWxkLnJldHVybiA9IG5vZGU7XG4gICAgICAgIG5vZGUgPSBub2RlLmNoaWxkO1xuICAgICAgfVxuICAgIH0gLy8gQ2hlY2sgaWYgdGhpcyBob3N0IG5vZGUgaXMgc3RhYmxlIG9yIGFib3V0IHRvIGJlIHBsYWNlZC5cblxuXG4gICAgaWYgKCEobm9kZS5mbGFncyAmIFBsYWNlbWVudCkpIHtcbiAgICAgIC8vIEZvdW5kIGl0IVxuICAgICAgcmV0dXJuIG5vZGUuc3RhdGVOb2RlO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjb21taXRQbGFjZW1lbnQoZmluaXNoZWRXb3JrKSB7XG5cblxuICB2YXIgcGFyZW50RmliZXIgPSBnZXRIb3N0UGFyZW50RmliZXIoZmluaXNoZWRXb3JrKTsgLy8gTm90ZTogdGhlc2UgdHdvIHZhcmlhYmxlcyAqbXVzdCogYWx3YXlzIGJlIHVwZGF0ZWQgdG9nZXRoZXIuXG5cbiAgdmFyIHBhcmVudDtcbiAgdmFyIGlzQ29udGFpbmVyO1xuICB2YXIgcGFyZW50U3RhdGVOb2RlID0gcGFyZW50RmliZXIuc3RhdGVOb2RlO1xuXG4gIHN3aXRjaCAocGFyZW50RmliZXIudGFnKSB7XG4gICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAgcGFyZW50ID0gcGFyZW50U3RhdGVOb2RlO1xuICAgICAgaXNDb250YWluZXIgPSBmYWxzZTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBIb3N0Um9vdDpcbiAgICAgIHBhcmVudCA9IHBhcmVudFN0YXRlTm9kZS5jb250YWluZXJJbmZvO1xuICAgICAgaXNDb250YWluZXIgPSB0cnVlO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIEhvc3RQb3J0YWw6XG4gICAgICBwYXJlbnQgPSBwYXJlbnRTdGF0ZU5vZGUuY29udGFpbmVySW5mbztcbiAgICAgIGlzQ29udGFpbmVyID0gdHJ1ZTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBGdW5kYW1lbnRhbENvbXBvbmVudDpcblxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZS1uby1mYWxsdGhyb3VnaFxuXG4gICAgZGVmYXVsdDpcbiAgICAgIHtcbiAgICAgICAge1xuICAgICAgICAgIHRocm93IEVycm9yKCBcIkludmFsaWQgaG9zdCBwYXJlbnQgZmliZXIuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCIgKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gIH1cblxuICBpZiAocGFyZW50RmliZXIuZmxhZ3MgJiBDb250ZW50UmVzZXQpIHtcbiAgICAvLyBSZXNldCB0aGUgdGV4dCBjb250ZW50IG9mIHRoZSBwYXJlbnQgYmVmb3JlIGRvaW5nIGFueSBpbnNlcnRpb25zXG4gICAgcmVzZXRUZXh0Q29udGVudChwYXJlbnQpOyAvLyBDbGVhciBDb250ZW50UmVzZXQgZnJvbSB0aGUgZWZmZWN0IHRhZ1xuXG4gICAgcGFyZW50RmliZXIuZmxhZ3MgJj0gfkNvbnRlbnRSZXNldDtcbiAgfVxuXG4gIHZhciBiZWZvcmUgPSBnZXRIb3N0U2libGluZyhmaW5pc2hlZFdvcmspOyAvLyBXZSBvbmx5IGhhdmUgdGhlIHRvcCBGaWJlciB0aGF0IHdhcyBpbnNlcnRlZCBidXQgd2UgbmVlZCB0byByZWN1cnNlIGRvd24gaXRzXG4gIC8vIGNoaWxkcmVuIHRvIGZpbmQgYWxsIHRoZSB0ZXJtaW5hbCBub2Rlcy5cblxuICBpZiAoaXNDb250YWluZXIpIHtcbiAgICBpbnNlcnRPckFwcGVuZFBsYWNlbWVudE5vZGVJbnRvQ29udGFpbmVyKGZpbmlzaGVkV29yaywgYmVmb3JlLCBwYXJlbnQpO1xuICB9IGVsc2Uge1xuICAgIGluc2VydE9yQXBwZW5kUGxhY2VtZW50Tm9kZShmaW5pc2hlZFdvcmssIGJlZm9yZSwgcGFyZW50KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbnNlcnRPckFwcGVuZFBsYWNlbWVudE5vZGVJbnRvQ29udGFpbmVyKG5vZGUsIGJlZm9yZSwgcGFyZW50KSB7XG4gIHZhciB0YWcgPSBub2RlLnRhZztcbiAgdmFyIGlzSG9zdCA9IHRhZyA9PT0gSG9zdENvbXBvbmVudCB8fCB0YWcgPT09IEhvc3RUZXh0O1xuXG4gIGlmIChpc0hvc3QgfHwgZW5hYmxlRnVuZGFtZW50YWxBUEkgKSB7XG4gICAgdmFyIHN0YXRlTm9kZSA9IGlzSG9zdCA/IG5vZGUuc3RhdGVOb2RlIDogbm9kZS5zdGF0ZU5vZGUuaW5zdGFuY2U7XG5cbiAgICBpZiAoYmVmb3JlKSB7XG4gICAgICBpbnNlcnRJbkNvbnRhaW5lckJlZm9yZShwYXJlbnQsIHN0YXRlTm9kZSwgYmVmb3JlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYXBwZW5kQ2hpbGRUb0NvbnRhaW5lcihwYXJlbnQsIHN0YXRlTm9kZSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKHRhZyA9PT0gSG9zdFBvcnRhbCkgOyBlbHNlIHtcbiAgICB2YXIgY2hpbGQgPSBub2RlLmNoaWxkO1xuXG4gICAgaWYgKGNoaWxkICE9PSBudWxsKSB7XG4gICAgICBpbnNlcnRPckFwcGVuZFBsYWNlbWVudE5vZGVJbnRvQ29udGFpbmVyKGNoaWxkLCBiZWZvcmUsIHBhcmVudCk7XG4gICAgICB2YXIgc2libGluZyA9IGNoaWxkLnNpYmxpbmc7XG5cbiAgICAgIHdoaWxlIChzaWJsaW5nICE9PSBudWxsKSB7XG4gICAgICAgIGluc2VydE9yQXBwZW5kUGxhY2VtZW50Tm9kZUludG9Db250YWluZXIoc2libGluZywgYmVmb3JlLCBwYXJlbnQpO1xuICAgICAgICBzaWJsaW5nID0gc2libGluZy5zaWJsaW5nO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBpbnNlcnRPckFwcGVuZFBsYWNlbWVudE5vZGUobm9kZSwgYmVmb3JlLCBwYXJlbnQpIHtcbiAgdmFyIHRhZyA9IG5vZGUudGFnO1xuICB2YXIgaXNIb3N0ID0gdGFnID09PSBIb3N0Q29tcG9uZW50IHx8IHRhZyA9PT0gSG9zdFRleHQ7XG5cbiAgaWYgKGlzSG9zdCB8fCBlbmFibGVGdW5kYW1lbnRhbEFQSSApIHtcbiAgICB2YXIgc3RhdGVOb2RlID0gaXNIb3N0ID8gbm9kZS5zdGF0ZU5vZGUgOiBub2RlLnN0YXRlTm9kZS5pbnN0YW5jZTtcblxuICAgIGlmIChiZWZvcmUpIHtcbiAgICAgIGluc2VydEJlZm9yZShwYXJlbnQsIHN0YXRlTm9kZSwgYmVmb3JlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYXBwZW5kQ2hpbGQocGFyZW50LCBzdGF0ZU5vZGUpO1xuICAgIH1cbiAgfSBlbHNlIGlmICh0YWcgPT09IEhvc3RQb3J0YWwpIDsgZWxzZSB7XG4gICAgdmFyIGNoaWxkID0gbm9kZS5jaGlsZDtcblxuICAgIGlmIChjaGlsZCAhPT0gbnVsbCkge1xuICAgICAgaW5zZXJ0T3JBcHBlbmRQbGFjZW1lbnROb2RlKGNoaWxkLCBiZWZvcmUsIHBhcmVudCk7XG4gICAgICB2YXIgc2libGluZyA9IGNoaWxkLnNpYmxpbmc7XG5cbiAgICAgIHdoaWxlIChzaWJsaW5nICE9PSBudWxsKSB7XG4gICAgICAgIGluc2VydE9yQXBwZW5kUGxhY2VtZW50Tm9kZShzaWJsaW5nLCBiZWZvcmUsIHBhcmVudCk7XG4gICAgICAgIHNpYmxpbmcgPSBzaWJsaW5nLnNpYmxpbmc7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHVubW91bnRIb3N0Q29tcG9uZW50cyhmaW5pc2hlZFJvb3QsIGN1cnJlbnQsIHJlbmRlclByaW9yaXR5TGV2ZWwpIHtcbiAgLy8gV2Ugb25seSBoYXZlIHRoZSB0b3AgRmliZXIgdGhhdCB3YXMgZGVsZXRlZCBidXQgd2UgbmVlZCB0byByZWN1cnNlIGRvd24gaXRzXG4gIC8vIGNoaWxkcmVuIHRvIGZpbmQgYWxsIHRoZSB0ZXJtaW5hbCBub2Rlcy5cbiAgdmFyIG5vZGUgPSBjdXJyZW50OyAvLyBFYWNoIGl0ZXJhdGlvbiwgY3VycmVudFBhcmVudCBpcyBwb3B1bGF0ZWQgd2l0aCBub2RlJ3MgaG9zdCBwYXJlbnQgaWYgbm90XG4gIC8vIGN1cnJlbnRQYXJlbnRJc1ZhbGlkLlxuXG4gIHZhciBjdXJyZW50UGFyZW50SXNWYWxpZCA9IGZhbHNlOyAvLyBOb3RlOiB0aGVzZSB0d28gdmFyaWFibGVzICptdXN0KiBhbHdheXMgYmUgdXBkYXRlZCB0b2dldGhlci5cblxuICB2YXIgY3VycmVudFBhcmVudDtcbiAgdmFyIGN1cnJlbnRQYXJlbnRJc0NvbnRhaW5lcjtcblxuICB3aGlsZSAodHJ1ZSkge1xuICAgIGlmICghY3VycmVudFBhcmVudElzVmFsaWQpIHtcbiAgICAgIHZhciBwYXJlbnQgPSBub2RlLnJldHVybjtcblxuICAgICAgZmluZFBhcmVudDogd2hpbGUgKHRydWUpIHtcbiAgICAgICAgaWYgKCEocGFyZW50ICE9PSBudWxsKSkge1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKCBcIkV4cGVjdGVkIHRvIGZpbmQgYSBob3N0IHBhcmVudC4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS5cIiApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwYXJlbnRTdGF0ZU5vZGUgPSBwYXJlbnQuc3RhdGVOb2RlO1xuXG4gICAgICAgIHN3aXRjaCAocGFyZW50LnRhZykge1xuICAgICAgICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgICAgICAgIGN1cnJlbnRQYXJlbnQgPSBwYXJlbnRTdGF0ZU5vZGU7XG4gICAgICAgICAgICBjdXJyZW50UGFyZW50SXNDb250YWluZXIgPSBmYWxzZTtcbiAgICAgICAgICAgIGJyZWFrIGZpbmRQYXJlbnQ7XG5cbiAgICAgICAgICBjYXNlIEhvc3RSb290OlxuICAgICAgICAgICAgY3VycmVudFBhcmVudCA9IHBhcmVudFN0YXRlTm9kZS5jb250YWluZXJJbmZvO1xuICAgICAgICAgICAgY3VycmVudFBhcmVudElzQ29udGFpbmVyID0gdHJ1ZTtcbiAgICAgICAgICAgIGJyZWFrIGZpbmRQYXJlbnQ7XG5cbiAgICAgICAgICBjYXNlIEhvc3RQb3J0YWw6XG4gICAgICAgICAgICBjdXJyZW50UGFyZW50ID0gcGFyZW50U3RhdGVOb2RlLmNvbnRhaW5lckluZm87XG4gICAgICAgICAgICBjdXJyZW50UGFyZW50SXNDb250YWluZXIgPSB0cnVlO1xuICAgICAgICAgICAgYnJlYWsgZmluZFBhcmVudDtcblxuICAgICAgICB9XG5cbiAgICAgICAgcGFyZW50ID0gcGFyZW50LnJldHVybjtcbiAgICAgIH1cblxuICAgICAgY3VycmVudFBhcmVudElzVmFsaWQgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmIChub2RlLnRhZyA9PT0gSG9zdENvbXBvbmVudCB8fCBub2RlLnRhZyA9PT0gSG9zdFRleHQpIHtcbiAgICAgIGNvbW1pdE5lc3RlZFVubW91bnRzKGZpbmlzaGVkUm9vdCwgbm9kZSk7IC8vIEFmdGVyIGFsbCB0aGUgY2hpbGRyZW4gaGF2ZSB1bm1vdW50ZWQsIGl0IGlzIG5vdyBzYWZlIHRvIHJlbW92ZSB0aGVcbiAgICAgIC8vIG5vZGUgZnJvbSB0aGUgdHJlZS5cblxuICAgICAgaWYgKGN1cnJlbnRQYXJlbnRJc0NvbnRhaW5lcikge1xuICAgICAgICByZW1vdmVDaGlsZEZyb21Db250YWluZXIoY3VycmVudFBhcmVudCwgbm9kZS5zdGF0ZU5vZGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVtb3ZlQ2hpbGQoY3VycmVudFBhcmVudCwgbm9kZS5zdGF0ZU5vZGUpO1xuICAgICAgfSAvLyBEb24ndCB2aXNpdCBjaGlsZHJlbiBiZWNhdXNlIHdlIGFscmVhZHkgdmlzaXRlZCB0aGVtLlxuXG4gICAgfSBlbHNlIGlmIChub2RlLnRhZyA9PT0gSG9zdFBvcnRhbCkge1xuICAgICAgaWYgKG5vZGUuY2hpbGQgIT09IG51bGwpIHtcbiAgICAgICAgLy8gV2hlbiB3ZSBnbyBpbnRvIGEgcG9ydGFsLCBpdCBiZWNvbWVzIHRoZSBwYXJlbnQgdG8gcmVtb3ZlIGZyb20uXG4gICAgICAgIC8vIFdlIHdpbGwgcmVhc3NpZ24gaXQgYmFjayB3aGVuIHdlIHBvcCB0aGUgcG9ydGFsIG9uIHRoZSB3YXkgdXAuXG4gICAgICAgIGN1cnJlbnRQYXJlbnQgPSBub2RlLnN0YXRlTm9kZS5jb250YWluZXJJbmZvO1xuICAgICAgICBjdXJyZW50UGFyZW50SXNDb250YWluZXIgPSB0cnVlOyAvLyBWaXNpdCBjaGlsZHJlbiBiZWNhdXNlIHBvcnRhbHMgbWlnaHQgY29udGFpbiBob3N0IGNvbXBvbmVudHMuXG5cbiAgICAgICAgbm9kZS5jaGlsZC5yZXR1cm4gPSBub2RlO1xuICAgICAgICBub2RlID0gbm9kZS5jaGlsZDtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbW1pdFVubW91bnQoZmluaXNoZWRSb290LCBub2RlKTsgLy8gVmlzaXQgY2hpbGRyZW4gYmVjYXVzZSB3ZSBtYXkgZmluZCBtb3JlIGhvc3QgY29tcG9uZW50cyBiZWxvdy5cblxuICAgICAgaWYgKG5vZGUuY2hpbGQgIT09IG51bGwpIHtcbiAgICAgICAgbm9kZS5jaGlsZC5yZXR1cm4gPSBub2RlO1xuICAgICAgICBub2RlID0gbm9kZS5jaGlsZDtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG5vZGUgPT09IGN1cnJlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB3aGlsZSAobm9kZS5zaWJsaW5nID09PSBudWxsKSB7XG4gICAgICBpZiAobm9kZS5yZXR1cm4gPT09IG51bGwgfHwgbm9kZS5yZXR1cm4gPT09IGN1cnJlbnQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBub2RlID0gbm9kZS5yZXR1cm47XG5cbiAgICAgIGlmIChub2RlLnRhZyA9PT0gSG9zdFBvcnRhbCkge1xuICAgICAgICAvLyBXaGVuIHdlIGdvIG91dCBvZiB0aGUgcG9ydGFsLCB3ZSBuZWVkIHRvIHJlc3RvcmUgdGhlIHBhcmVudC5cbiAgICAgICAgLy8gU2luY2Ugd2UgZG9uJ3Qga2VlcCBhIHN0YWNrIG9mIHRoZW0sIHdlIHdpbGwgc2VhcmNoIGZvciBpdC5cbiAgICAgICAgY3VycmVudFBhcmVudElzVmFsaWQgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBub2RlLnNpYmxpbmcucmV0dXJuID0gbm9kZS5yZXR1cm47XG4gICAgbm9kZSA9IG5vZGUuc2libGluZztcbiAgfVxufVxuXG5mdW5jdGlvbiBjb21taXREZWxldGlvbihmaW5pc2hlZFJvb3QsIGN1cnJlbnQsIHJlbmRlclByaW9yaXR5TGV2ZWwpIHtcbiAge1xuICAgIC8vIFJlY3Vyc2l2ZWx5IGRlbGV0ZSBhbGwgaG9zdCBub2RlcyBmcm9tIHRoZSBwYXJlbnQuXG4gICAgLy8gRGV0YWNoIHJlZnMgYW5kIGNhbGwgY29tcG9uZW50V2lsbFVubW91bnQoKSBvbiB0aGUgd2hvbGUgc3VidHJlZS5cbiAgICB1bm1vdW50SG9zdENvbXBvbmVudHMoZmluaXNoZWRSb290LCBjdXJyZW50KTtcbiAgfVxuXG4gIHZhciBhbHRlcm5hdGUgPSBjdXJyZW50LmFsdGVybmF0ZTtcbiAgZGV0YWNoRmliZXJNdXRhdGlvbihjdXJyZW50KTtcblxuICBpZiAoYWx0ZXJuYXRlICE9PSBudWxsKSB7XG4gICAgZGV0YWNoRmliZXJNdXRhdGlvbihhbHRlcm5hdGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNvbW1pdFdvcmsoY3VycmVudCwgZmluaXNoZWRXb3JrKSB7XG5cbiAgc3dpdGNoIChmaW5pc2hlZFdvcmsudGFnKSB7XG4gICAgY2FzZSBGdW5jdGlvbkNvbXBvbmVudDpcbiAgICBjYXNlIEZvcndhcmRSZWY6XG4gICAgY2FzZSBNZW1vQ29tcG9uZW50OlxuICAgIGNhc2UgU2ltcGxlTWVtb0NvbXBvbmVudDpcbiAgICBjYXNlIEJsb2NrOlxuICAgICAge1xuICAgICAgICAvLyBMYXlvdXQgZWZmZWN0cyBhcmUgZGVzdHJveWVkIGR1cmluZyB0aGUgbXV0YXRpb24gcGhhc2Ugc28gdGhhdCBhbGxcbiAgICAgICAgLy8gZGVzdHJveSBmdW5jdGlvbnMgZm9yIGFsbCBmaWJlcnMgYXJlIGNhbGxlZCBiZWZvcmUgYW55IGNyZWF0ZSBmdW5jdGlvbnMuXG4gICAgICAgIC8vIFRoaXMgcHJldmVudHMgc2libGluZyBjb21wb25lbnQgZWZmZWN0cyBmcm9tIGludGVyZmVyaW5nIHdpdGggZWFjaCBvdGhlcixcbiAgICAgICAgLy8gZS5nLiBhIGRlc3Ryb3kgZnVuY3Rpb24gaW4gb25lIGNvbXBvbmVudCBzaG91bGQgbmV2ZXIgb3ZlcnJpZGUgYSByZWYgc2V0XG4gICAgICAgIC8vIGJ5IGEgY3JlYXRlIGZ1bmN0aW9uIGluIGFub3RoZXIgY29tcG9uZW50IGR1cmluZyB0aGUgc2FtZSBjb21taXQuXG4gICAgICAgIHtcbiAgICAgICAgICBjb21taXRIb29rRWZmZWN0TGlzdFVubW91bnQoTGF5b3V0IHwgSGFzRWZmZWN0LCBmaW5pc2hlZFdvcmspO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgY2FzZSBDbGFzc0NvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAge1xuICAgICAgICB2YXIgaW5zdGFuY2UgPSBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlO1xuXG4gICAgICAgIGlmIChpbnN0YW5jZSAhPSBudWxsKSB7XG4gICAgICAgICAgLy8gQ29tbWl0IHRoZSB3b3JrIHByZXBhcmVkIGVhcmxpZXIuXG4gICAgICAgICAgdmFyIG5ld1Byb3BzID0gZmluaXNoZWRXb3JrLm1lbW9pemVkUHJvcHM7IC8vIEZvciBoeWRyYXRpb24gd2UgcmV1c2UgdGhlIHVwZGF0ZSBwYXRoIGJ1dCB3ZSB0cmVhdCB0aGUgb2xkUHJvcHNcbiAgICAgICAgICAvLyBhcyB0aGUgbmV3UHJvcHMuIFRoZSB1cGRhdGVQYXlsb2FkIHdpbGwgY29udGFpbiB0aGUgcmVhbCBjaGFuZ2UgaW5cbiAgICAgICAgICAvLyB0aGlzIGNhc2UuXG5cbiAgICAgICAgICB2YXIgb2xkUHJvcHMgPSBjdXJyZW50ICE9PSBudWxsID8gY3VycmVudC5tZW1vaXplZFByb3BzIDogbmV3UHJvcHM7XG4gICAgICAgICAgdmFyIHR5cGUgPSBmaW5pc2hlZFdvcmsudHlwZTsgLy8gVE9ETzogVHlwZSB0aGUgdXBkYXRlUXVldWUgdG8gYmUgc3BlY2lmaWMgdG8gaG9zdCBjb21wb25lbnRzLlxuXG4gICAgICAgICAgdmFyIHVwZGF0ZVBheWxvYWQgPSBmaW5pc2hlZFdvcmsudXBkYXRlUXVldWU7XG4gICAgICAgICAgZmluaXNoZWRXb3JrLnVwZGF0ZVF1ZXVlID0gbnVsbDtcblxuICAgICAgICAgIGlmICh1cGRhdGVQYXlsb2FkICE9PSBudWxsKSB7XG4gICAgICAgICAgICBjb21taXRVcGRhdGUoaW5zdGFuY2UsIHVwZGF0ZVBheWxvYWQsIHR5cGUsIG9sZFByb3BzLCBuZXdQcm9wcyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgY2FzZSBIb3N0VGV4dDpcbiAgICAgIHtcbiAgICAgICAgaWYgKCEoZmluaXNoZWRXb3JrLnN0YXRlTm9kZSAhPT0gbnVsbCkpIHtcbiAgICAgICAgICB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvciggXCJUaGlzIHNob3VsZCBoYXZlIGEgdGV4dCBub2RlIGluaXRpYWxpemVkLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHRleHRJbnN0YW5jZSA9IGZpbmlzaGVkV29yay5zdGF0ZU5vZGU7XG4gICAgICAgIHZhciBuZXdUZXh0ID0gZmluaXNoZWRXb3JrLm1lbW9pemVkUHJvcHM7IC8vIEZvciBoeWRyYXRpb24gd2UgcmV1c2UgdGhlIHVwZGF0ZSBwYXRoIGJ1dCB3ZSB0cmVhdCB0aGUgb2xkUHJvcHNcbiAgICAgICAgLy8gYXMgdGhlIG5ld1Byb3BzLiBUaGUgdXBkYXRlUGF5bG9hZCB3aWxsIGNvbnRhaW4gdGhlIHJlYWwgY2hhbmdlIGluXG4gICAgICAgIC8vIHRoaXMgY2FzZS5cblxuICAgICAgICB2YXIgb2xkVGV4dCA9IGN1cnJlbnQgIT09IG51bGwgPyBjdXJyZW50Lm1lbW9pemVkUHJvcHMgOiBuZXdUZXh0O1xuICAgICAgICBjb21taXRUZXh0VXBkYXRlKHRleHRJbnN0YW5jZSwgb2xkVGV4dCwgbmV3VGV4dCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgICB7XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgX3Jvb3QgPSBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlO1xuXG4gICAgICAgICAgaWYgKF9yb290Lmh5ZHJhdGUpIHtcbiAgICAgICAgICAgIC8vIFdlJ3ZlIGp1c3QgaHlkcmF0ZWQuIE5vIG5lZWQgdG8gaHlkcmF0ZSBhZ2Fpbi5cbiAgICAgICAgICAgIF9yb290Lmh5ZHJhdGUgPSBmYWxzZTtcbiAgICAgICAgICAgIGNvbW1pdEh5ZHJhdGVkQ29udGFpbmVyKF9yb290LmNvbnRhaW5lckluZm8pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgIGNhc2UgUHJvZmlsZXI6XG4gICAgICB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgIGNhc2UgU3VzcGVuc2VDb21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIGNvbW1pdFN1c3BlbnNlQ29tcG9uZW50KGZpbmlzaGVkV29yayk7XG4gICAgICAgIGF0dGFjaFN1c3BlbnNlUmV0cnlMaXN0ZW5lcnMoZmluaXNoZWRXb3JrKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgY2FzZSBTdXNwZW5zZUxpc3RDb21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIGF0dGFjaFN1c3BlbnNlUmV0cnlMaXN0ZW5lcnMoZmluaXNoZWRXb3JrKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgY2FzZSBJbmNvbXBsZXRlQ2xhc3NDb21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgIGNhc2UgRnVuZGFtZW50YWxDb21wb25lbnQ6XG4gICAgICB7XG5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICBjYXNlIFNjb3BlQ29tcG9uZW50OlxuICAgICAge1xuXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgY2FzZSBPZmZzY3JlZW5Db21wb25lbnQ6XG4gICAgY2FzZSBMZWdhY3lIaWRkZW5Db21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIHZhciBuZXdTdGF0ZSA9IGZpbmlzaGVkV29yay5tZW1vaXplZFN0YXRlO1xuICAgICAgICB2YXIgaXNIaWRkZW4gPSBuZXdTdGF0ZSAhPT0gbnVsbDtcbiAgICAgICAgaGlkZU9yVW5oaWRlQWxsQ2hpbGRyZW4oZmluaXNoZWRXb3JrLCBpc0hpZGRlbik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgfVxuXG4gIHtcbiAgICB7XG4gICAgICB0aHJvdyBFcnJvciggXCJUaGlzIHVuaXQgb2Ygd29yayB0YWcgc2hvdWxkIG5vdCBoYXZlIHNpZGUtZWZmZWN0cy4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS5cIiApO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjb21taXRTdXNwZW5zZUNvbXBvbmVudChmaW5pc2hlZFdvcmspIHtcbiAgdmFyIG5ld1N0YXRlID0gZmluaXNoZWRXb3JrLm1lbW9pemVkU3RhdGU7XG5cbiAgaWYgKG5ld1N0YXRlICE9PSBudWxsKSB7XG4gICAgbWFya0NvbW1pdFRpbWVPZkZhbGxiYWNrKCk7XG5cbiAgICB7XG4gICAgICAvLyBIaWRlIHRoZSBPZmZzY3JlZW4gY29tcG9uZW50IHRoYXQgY29udGFpbnMgdGhlIHByaW1hcnkgY2hpbGRyZW4uIFRPRE86XG4gICAgICAvLyBJZGVhbGx5LCB0aGlzIGVmZmVjdCB3b3VsZCBoYXZlIGJlZW4gc2NoZWR1bGVkIG9uIHRoZSBPZmZzY3JlZW4gZmliZXJcbiAgICAgIC8vIGl0c2VsZi4gVGhhdCdzIGhvdyB1bmhpZGluZyB3b3JrczogdGhlIE9mZnNjcmVlbiBjb21wb25lbnQgc2NoZWR1bGVzIGFuXG4gICAgICAvLyBlZmZlY3Qgb24gaXRzZWxmLiBIb3dldmVyLCBpbiB0aGlzIGNhc2UsIHRoZSBjb21wb25lbnQgZGlkbid0IGNvbXBsZXRlLFxuICAgICAgLy8gc28gdGhlIGZpYmVyIHdhcyBuZXZlciBhZGRlZCB0byB0aGUgZWZmZWN0IGxpc3QgaW4gdGhlIG5vcm1hbCBwYXRoLiBXZVxuICAgICAgLy8gY291bGQgaGF2ZSBhcHBlbmRlZCBpdCB0byB0aGUgZWZmZWN0IGxpc3QgaW4gdGhlIFN1c3BlbnNlIGNvbXBvbmVudCdzXG4gICAgICAvLyBzZWNvbmQgcGFzcywgYnV0IGRvaW5nIGl0IHRoaXMgd2F5IGlzIGxlc3MgY29tcGxpY2F0ZWQuIFRoaXMgd291bGQgYmVcbiAgICAgIC8vIHNpbXBsZXIgaWYgd2UgZ290IHJpZCBvZiB0aGUgZWZmZWN0IGxpc3QgYW5kIHRyYXZlcnNlZCB0aGUgdHJlZSwgbGlrZVxuICAgICAgLy8gd2UncmUgcGxhbm5pbmcgdG8gZG8uXG4gICAgICB2YXIgcHJpbWFyeUNoaWxkUGFyZW50ID0gZmluaXNoZWRXb3JrLmNoaWxkO1xuICAgICAgaGlkZU9yVW5oaWRlQWxsQ2hpbGRyZW4ocHJpbWFyeUNoaWxkUGFyZW50LCB0cnVlKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY29tbWl0U3VzcGVuc2VIeWRyYXRpb25DYWxsYmFja3MoZmluaXNoZWRSb290LCBmaW5pc2hlZFdvcmspIHtcblxuICB2YXIgbmV3U3RhdGUgPSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRTdGF0ZTtcblxuICBpZiAobmV3U3RhdGUgPT09IG51bGwpIHtcbiAgICB2YXIgY3VycmVudCA9IGZpbmlzaGVkV29yay5hbHRlcm5hdGU7XG5cbiAgICBpZiAoY3VycmVudCAhPT0gbnVsbCkge1xuICAgICAgdmFyIHByZXZTdGF0ZSA9IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZTtcblxuICAgICAgaWYgKHByZXZTdGF0ZSAhPT0gbnVsbCkge1xuICAgICAgICB2YXIgc3VzcGVuc2VJbnN0YW5jZSA9IHByZXZTdGF0ZS5kZWh5ZHJhdGVkO1xuXG4gICAgICAgIGlmIChzdXNwZW5zZUluc3RhbmNlICE9PSBudWxsKSB7XG4gICAgICAgICAgY29tbWl0SHlkcmF0ZWRTdXNwZW5zZUluc3RhbmNlKHN1c3BlbnNlSW5zdGFuY2UpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGF0dGFjaFN1c3BlbnNlUmV0cnlMaXN0ZW5lcnMoZmluaXNoZWRXb3JrKSB7XG4gIC8vIElmIHRoaXMgYm91bmRhcnkganVzdCB0aW1lZCBvdXQsIHRoZW4gaXQgd2lsbCBoYXZlIGEgc2V0IG9mIHdha2VhYmxlcy5cbiAgLy8gRm9yIGVhY2ggd2FrZWFibGUsIGF0dGFjaCBhIGxpc3RlbmVyIHNvIHRoYXQgd2hlbiBpdCByZXNvbHZlcywgUmVhY3RcbiAgLy8gYXR0ZW1wdHMgdG8gcmUtcmVuZGVyIHRoZSBib3VuZGFyeSBpbiB0aGUgcHJpbWFyeSAocHJlLXRpbWVvdXQpIHN0YXRlLlxuICB2YXIgd2FrZWFibGVzID0gZmluaXNoZWRXb3JrLnVwZGF0ZVF1ZXVlO1xuXG4gIGlmICh3YWtlYWJsZXMgIT09IG51bGwpIHtcbiAgICBmaW5pc2hlZFdvcmsudXBkYXRlUXVldWUgPSBudWxsO1xuICAgIHZhciByZXRyeUNhY2hlID0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZTtcblxuICAgIGlmIChyZXRyeUNhY2hlID09PSBudWxsKSB7XG4gICAgICByZXRyeUNhY2hlID0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZSA9IG5ldyBQb3NzaWJseVdlYWtTZXQoKTtcbiAgICB9XG5cbiAgICB3YWtlYWJsZXMuZm9yRWFjaChmdW5jdGlvbiAod2FrZWFibGUpIHtcbiAgICAgIC8vIE1lbW9pemUgdXNpbmcgdGhlIGJvdW5kYXJ5IGZpYmVyIHRvIHByZXZlbnQgcmVkdW5kYW50IGxpc3RlbmVycy5cbiAgICAgIHZhciByZXRyeSA9IHJlc29sdmVSZXRyeVdha2VhYmxlLmJpbmQobnVsbCwgZmluaXNoZWRXb3JrLCB3YWtlYWJsZSk7XG5cbiAgICAgIGlmICghcmV0cnlDYWNoZS5oYXMod2FrZWFibGUpKSB7XG4gICAgICAgIHtcbiAgICAgICAgICBpZiAod2FrZWFibGUuX19yZWFjdERvTm90VHJhY2VJbnRlcmFjdGlvbnMgIT09IHRydWUpIHtcbiAgICAgICAgICAgIHJldHJ5ID0gdHJhY2luZy51bnN0YWJsZV93cmFwKHJldHJ5KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXRyeUNhY2hlLmFkZCh3YWtlYWJsZSk7XG4gICAgICAgIHdha2VhYmxlLnRoZW4ocmV0cnksIHJldHJ5KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufSAvLyBUaGlzIGZ1bmN0aW9uIGRldGVjdHMgd2hlbiBhIFN1c3BlbnNlIGJvdW5kYXJ5IGdvZXMgZnJvbSB2aXNpYmxlIHRvIGhpZGRlbi5cbi8vIEl0IHJldHVybnMgZmFsc2UgaWYgdGhlIGJvdW5kYXJ5IGlzIGFscmVhZHkgaGlkZGVuLlxuLy8gVE9ETzogVXNlIGFuIGVmZmVjdCB0YWcuXG5cblxuZnVuY3Rpb24gaXNTdXNwZW5zZUJvdW5kYXJ5QmVpbmdIaWRkZW4oY3VycmVudCwgZmluaXNoZWRXb3JrKSB7XG4gIGlmIChjdXJyZW50ICE9PSBudWxsKSB7XG4gICAgdmFyIG9sZFN0YXRlID0gY3VycmVudC5tZW1vaXplZFN0YXRlO1xuXG4gICAgaWYgKG9sZFN0YXRlID09PSBudWxsIHx8IG9sZFN0YXRlLmRlaHlkcmF0ZWQgIT09IG51bGwpIHtcbiAgICAgIHZhciBuZXdTdGF0ZSA9IGZpbmlzaGVkV29yay5tZW1vaXplZFN0YXRlO1xuICAgICAgcmV0dXJuIG5ld1N0YXRlICE9PSBudWxsICYmIG5ld1N0YXRlLmRlaHlkcmF0ZWQgPT09IG51bGw7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBjb21taXRSZXNldFRleHRDb250ZW50KGN1cnJlbnQpIHtcblxuICByZXNldFRleHRDb250ZW50KGN1cnJlbnQuc3RhdGVOb2RlKTtcbn1cblxudmFyIENPTVBPTkVOVF9UWVBFID0gMDtcbnZhciBIQVNfUFNFVURPX0NMQVNTX1RZUEUgPSAxO1xudmFyIFJPTEVfVFlQRSA9IDI7XG52YXIgVEVTVF9OQU1FX1RZUEUgPSAzO1xudmFyIFRFWFRfVFlQRSA9IDQ7XG5cbmlmICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC5mb3IpIHtcbiAgdmFyIHN5bWJvbEZvciQxID0gU3ltYm9sLmZvcjtcbiAgQ09NUE9ORU5UX1RZUEUgPSBzeW1ib2xGb3IkMSgnc2VsZWN0b3IuY29tcG9uZW50Jyk7XG4gIEhBU19QU0VVRE9fQ0xBU1NfVFlQRSA9IHN5bWJvbEZvciQxKCdzZWxlY3Rvci5oYXNfcHNldWRvX2NsYXNzJyk7XG4gIFJPTEVfVFlQRSA9IHN5bWJvbEZvciQxKCdzZWxlY3Rvci5yb2xlJyk7XG4gIFRFU1RfTkFNRV9UWVBFID0gc3ltYm9sRm9yJDEoJ3NlbGVjdG9yLnRlc3RfaWQnKTtcbiAgVEVYVF9UWVBFID0gc3ltYm9sRm9yJDEoJ3NlbGVjdG9yLnRleHQnKTtcbn1cbnZhciBjb21taXRIb29rcyA9IFtdO1xuZnVuY3Rpb24gb25Db21taXRSb290JDEoKSB7XG4gIHtcbiAgICBjb21taXRIb29rcy5mb3JFYWNoKGZ1bmN0aW9uIChjb21taXRIb29rKSB7XG4gICAgICByZXR1cm4gY29tbWl0SG9vaygpO1xuICAgIH0pO1xuICB9XG59XG5cbnZhciBjZWlsID0gTWF0aC5jZWlsO1xudmFyIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMiA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0Q3VycmVudERpc3BhdGNoZXIsXG4gICAgUmVhY3RDdXJyZW50T3duZXIkMiA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0Q3VycmVudE93bmVyLFxuICAgIElzU29tZVJlbmRlcmVyQWN0aW5nID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuSXNTb21lUmVuZGVyZXJBY3Rpbmc7XG52YXIgTm9Db250ZXh0ID1cbi8qICAgICAgICAgICAgICovXG4wO1xudmFyIEJhdGNoZWRDb250ZXh0ID1cbi8qICAgICAgICAgICAgICAgKi9cbjE7XG52YXIgRXZlbnRDb250ZXh0ID1cbi8qICAgICAgICAgICAgICAgICAqL1xuMjtcbnZhciBEaXNjcmV0ZUV2ZW50Q29udGV4dCA9XG4vKiAgICAgICAgICovXG40O1xudmFyIExlZ2FjeVVuYmF0Y2hlZENvbnRleHQgPVxuLyogICAgICAgKi9cbjg7XG52YXIgUmVuZGVyQ29udGV4dCA9XG4vKiAgICAgICAgICAgICAgICAqL1xuMTY7XG52YXIgQ29tbWl0Q29udGV4dCA9XG4vKiAgICAgICAgICAgICAgICAqL1xuMzI7XG52YXIgUmV0cnlBZnRlckVycm9yID1cbi8qICAgICAgICovXG42NDtcbnZhciBSb290SW5jb21wbGV0ZSA9IDA7XG52YXIgUm9vdEZhdGFsRXJyb3JlZCA9IDE7XG52YXIgUm9vdEVycm9yZWQgPSAyO1xudmFyIFJvb3RTdXNwZW5kZWQgPSAzO1xudmFyIFJvb3RTdXNwZW5kZWRXaXRoRGVsYXkgPSA0O1xudmFyIFJvb3RDb21wbGV0ZWQgPSA1OyAvLyBEZXNjcmliZXMgd2hlcmUgd2UgYXJlIGluIHRoZSBSZWFjdCBleGVjdXRpb24gc3RhY2tcblxudmFyIGV4ZWN1dGlvbkNvbnRleHQgPSBOb0NvbnRleHQ7IC8vIFRoZSByb290IHdlJ3JlIHdvcmtpbmcgb25cblxudmFyIHdvcmtJblByb2dyZXNzUm9vdCA9IG51bGw7IC8vIFRoZSBmaWJlciB3ZSdyZSB3b3JraW5nIG9uXG5cbnZhciB3b3JrSW5Qcm9ncmVzcyA9IG51bGw7IC8vIFRoZSBsYW5lcyB3ZSdyZSByZW5kZXJpbmdcblxudmFyIHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzID0gTm9MYW5lczsgLy8gU3RhY2sgdGhhdCBhbGxvd3MgY29tcG9uZW50cyB0byBjaGFuZ2UgdGhlIHJlbmRlciBsYW5lcyBmb3IgaXRzIHN1YnRyZWVcbi8vIFRoaXMgaXMgYSBzdXBlcnNldCBvZiB0aGUgbGFuZXMgd2Ugc3RhcnRlZCB3b3JraW5nIG9uIGF0IHRoZSByb290LiBUaGUgb25seVxuLy8gY2FzZSB3aGVyZSBpdCdzIGRpZmZlcmVudCBmcm9tIGB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lc2AgaXMgd2hlbiB3ZVxuLy8gZW50ZXIgYSBzdWJ0cmVlIHRoYXQgaXMgaGlkZGVuIGFuZCBuZWVkcyB0byBiZSB1bmhpZGRlbjogU3VzcGVuc2UgYW5kXG4vLyBPZmZzY3JlZW4gY29tcG9uZW50LlxuLy9cbi8vIE1vc3QgdGhpbmdzIGluIHRoZSB3b3JrIGxvb3Agc2hvdWxkIGRlYWwgd2l0aCB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcy5cbi8vIE1vc3QgdGhpbmdzIGluIGJlZ2luL2NvbXBsZXRlIHBoYXNlcyBzaG91bGQgZGVhbCB3aXRoIHN1YnRyZWVSZW5kZXJMYW5lcy5cblxudmFyIHN1YnRyZWVSZW5kZXJMYW5lcyA9IE5vTGFuZXM7XG52YXIgc3VidHJlZVJlbmRlckxhbmVzQ3Vyc29yID0gY3JlYXRlQ3Vyc29yKE5vTGFuZXMpOyAvLyBXaGV0aGVyIHRvIHJvb3QgY29tcGxldGVkLCBlcnJvcmVkLCBzdXNwZW5kZWQsIGV0Yy5cblxudmFyIHdvcmtJblByb2dyZXNzUm9vdEV4aXRTdGF0dXMgPSBSb290SW5jb21wbGV0ZTsgLy8gQSBmYXRhbCBlcnJvciwgaWYgb25lIGlzIHRocm93blxuXG52YXIgd29ya0luUHJvZ3Jlc3NSb290RmF0YWxFcnJvciA9IG51bGw7IC8vIFwiSW5jbHVkZWRcIiBsYW5lcyByZWZlciB0byBsYW5lcyB0aGF0IHdlcmUgd29ya2VkIG9uIGR1cmluZyB0aGlzIHJlbmRlci4gSXQnc1xuLy8gc2xpZ2h0bHkgZGlmZmVyZW50IHRoYW4gYHJlbmRlckxhbmVzYCBiZWNhdXNlIGByZW5kZXJMYW5lc2AgY2FuIGNoYW5nZSBhcyB5b3Vcbi8vIGVudGVyIGFuZCBleGl0IGFuIE9mZnNjcmVlbiB0cmVlLiBUaGlzIHZhbHVlIGlzIHRoZSBjb21iaW5hdGlvbiBvZiBhbGwgcmVuZGVyXG4vLyBsYW5lcyBmb3IgdGhlIGVudGlyZSByZW5kZXIgcGhhc2UuXG5cbnZhciB3b3JrSW5Qcm9ncmVzc1Jvb3RJbmNsdWRlZExhbmVzID0gTm9MYW5lczsgLy8gVGhlIHdvcmsgbGVmdCBvdmVyIGJ5IGNvbXBvbmVudHMgdGhhdCB3ZXJlIHZpc2l0ZWQgZHVyaW5nIHRoaXMgcmVuZGVyLiBPbmx5XG4vLyBpbmNsdWRlcyB1bnByb2Nlc3NlZCB1cGRhdGVzLCBub3Qgd29yayBpbiBiYWlsZWQgb3V0IGNoaWxkcmVuLlxuXG52YXIgd29ya0luUHJvZ3Jlc3NSb290U2tpcHBlZExhbmVzID0gTm9MYW5lczsgLy8gTGFuZXMgdGhhdCB3ZXJlIHVwZGF0ZWQgKGluIGFuIGludGVybGVhdmVkIGV2ZW50KSBkdXJpbmcgdGhpcyByZW5kZXIuXG5cbnZhciB3b3JrSW5Qcm9ncmVzc1Jvb3RVcGRhdGVkTGFuZXMgPSBOb0xhbmVzOyAvLyBMYW5lcyB0aGF0IHdlcmUgcGluZ2VkIChpbiBhbiBpbnRlcmxlYXZlZCBldmVudCkgZHVyaW5nIHRoaXMgcmVuZGVyLlxuXG52YXIgd29ya0luUHJvZ3Jlc3NSb290UGluZ2VkTGFuZXMgPSBOb0xhbmVzO1xudmFyIG1vc3RSZWNlbnRseVVwZGF0ZWRSb290ID0gbnVsbDsgLy8gVGhlIG1vc3QgcmVjZW50IHRpbWUgd2UgY29tbWl0dGVkIGEgZmFsbGJhY2suIFRoaXMgbGV0cyB1cyBlbnN1cmUgYSB0cmFpblxuLy8gbW9kZWwgd2hlcmUgd2UgZG9uJ3QgY29tbWl0IG5ldyBsb2FkaW5nIHN0YXRlcyBpbiB0b28gcXVpY2sgc3VjY2Vzc2lvbi5cblxudmFyIGdsb2JhbE1vc3RSZWNlbnRGYWxsYmFja1RpbWUgPSAwO1xudmFyIEZBTExCQUNLX1RIUk9UVExFX01TID0gNTAwOyAvLyBUaGUgYWJzb2x1dGUgdGltZSBmb3Igd2hlbiB3ZSBzaG91bGQgc3RhcnQgZ2l2aW5nIHVwIG9uIHJlbmRlcmluZ1xuLy8gbW9yZSBhbmQgcHJlZmVyIENQVSBzdXNwZW5zZSBoZXVyaXN0aWNzIGluc3RlYWQuXG5cbnZhciB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJUYXJnZXRUaW1lID0gSW5maW5pdHk7IC8vIEhvdyBsb25nIGEgcmVuZGVyIGlzIHN1cHBvc2VkIHRvIHRha2UgYmVmb3JlIHdlIHN0YXJ0IGZvbGxvd2luZyBDUFVcbi8vIHN1c3BlbnNlIGhldXJpc3RpY3MgYW5kIG9wdCBvdXQgb2YgcmVuZGVyaW5nIG1vcmUgY29udGVudC5cblxudmFyIFJFTkRFUl9USU1FT1VUX01TID0gNTAwO1xuXG5mdW5jdGlvbiByZXNldFJlbmRlclRpbWVyKCkge1xuICB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJUYXJnZXRUaW1lID0gbm93KCkgKyBSRU5ERVJfVElNRU9VVF9NUztcbn1cblxuZnVuY3Rpb24gZ2V0UmVuZGVyVGFyZ2V0VGltZSgpIHtcbiAgcmV0dXJuIHdvcmtJblByb2dyZXNzUm9vdFJlbmRlclRhcmdldFRpbWU7XG59XG52YXIgbmV4dEVmZmVjdCA9IG51bGw7XG52YXIgaGFzVW5jYXVnaHRFcnJvciA9IGZhbHNlO1xudmFyIGZpcnN0VW5jYXVnaHRFcnJvciA9IG51bGw7XG52YXIgbGVnYWN5RXJyb3JCb3VuZGFyaWVzVGhhdEFscmVhZHlGYWlsZWQgPSBudWxsO1xudmFyIHJvb3REb2VzSGF2ZVBhc3NpdmVFZmZlY3RzID0gZmFsc2U7XG52YXIgcm9vdFdpdGhQZW5kaW5nUGFzc2l2ZUVmZmVjdHMgPSBudWxsO1xudmFyIHBlbmRpbmdQYXNzaXZlRWZmZWN0c1JlbmRlclByaW9yaXR5ID0gTm9Qcmlvcml0eSQxO1xudmFyIHBlbmRpbmdQYXNzaXZlRWZmZWN0c0xhbmVzID0gTm9MYW5lcztcbnZhciBwZW5kaW5nUGFzc2l2ZUhvb2tFZmZlY3RzTW91bnQgPSBbXTtcbnZhciBwZW5kaW5nUGFzc2l2ZUhvb2tFZmZlY3RzVW5tb3VudCA9IFtdO1xudmFyIHJvb3RzV2l0aFBlbmRpbmdEaXNjcmV0ZVVwZGF0ZXMgPSBudWxsOyAvLyBVc2UgdGhlc2UgdG8gcHJldmVudCBhbiBpbmZpbml0ZSBsb29wIG9mIG5lc3RlZCB1cGRhdGVzXG5cbnZhciBORVNURURfVVBEQVRFX0xJTUlUID0gNTA7XG52YXIgbmVzdGVkVXBkYXRlQ291bnQgPSAwO1xudmFyIHJvb3RXaXRoTmVzdGVkVXBkYXRlcyA9IG51bGw7XG52YXIgTkVTVEVEX1BBU1NJVkVfVVBEQVRFX0xJTUlUID0gNTA7XG52YXIgbmVzdGVkUGFzc2l2ZVVwZGF0ZUNvdW50ID0gMDsgLy8gTWFya3MgdGhlIG5lZWQgdG8gcmVzY2hlZHVsZSBwZW5kaW5nIGludGVyYWN0aW9ucyBhdCB0aGVzZSBsYW5lc1xuLy8gZHVyaW5nIHRoZSBjb21taXQgcGhhc2UuIFRoaXMgZW5hYmxlcyB0aGVtIHRvIGJlIHRyYWNlZCBhY3Jvc3MgY29tcG9uZW50c1xuLy8gdGhhdCBzcGF3biBuZXcgd29yayBkdXJpbmcgcmVuZGVyLiBFLmcuIGhpZGRlbiBib3VuZGFyaWVzLCBzdXNwZW5kZWQgU1NSXG4vLyBoeWRyYXRpb24gb3IgU3VzcGVuc2VMaXN0LlxuLy8gVE9ETzogQ2FuIHVzZSBhIGJpdG1hc2sgaW5zdGVhZCBvZiBhbiBhcnJheVxuXG52YXIgc3Bhd25lZFdvcmtEdXJpbmdSZW5kZXIgPSBudWxsOyAvLyBJZiB0d28gdXBkYXRlcyBhcmUgc2NoZWR1bGVkIHdpdGhpbiB0aGUgc2FtZSBldmVudCwgd2Ugc2hvdWxkIHRyZWF0IHRoZWlyXG4vLyBldmVudCB0aW1lcyBhcyBzaW11bHRhbmVvdXMsIGV2ZW4gaWYgdGhlIGFjdHVhbCBjbG9jayB0aW1lIGhhcyBhZHZhbmNlZFxuLy8gYmV0d2VlbiB0aGUgZmlyc3QgYW5kIHNlY29uZCBjYWxsLlxuXG52YXIgY3VycmVudEV2ZW50VGltZSA9IE5vVGltZXN0YW1wO1xudmFyIGN1cnJlbnRFdmVudFdpcExhbmVzID0gTm9MYW5lcztcbnZhciBjdXJyZW50RXZlbnRQZW5kaW5nTGFuZXMgPSBOb0xhbmVzOyAvLyBEZXYgb25seSBmbGFnIHRoYXQgdHJhY2tzIGlmIHBhc3NpdmUgZWZmZWN0cyBhcmUgY3VycmVudGx5IGJlaW5nIGZsdXNoZWQuXG4vLyBXZSB3YXJuIGFib3V0IHN0YXRlIHVwZGF0ZXMgZm9yIHVubW91bnRlZCBjb21wb25lbnRzIGRpZmZlcmVudGx5IGluIHRoaXMgY2FzZS5cblxudmFyIGlzRmx1c2hpbmdQYXNzaXZlRWZmZWN0cyA9IGZhbHNlO1xudmFyIGZvY3VzZWRJbnN0YW5jZUhhbmRsZSA9IG51bGw7XG52YXIgc2hvdWxkRmlyZUFmdGVyQWN0aXZlSW5zdGFuY2VCbHVyID0gZmFsc2U7XG5mdW5jdGlvbiBnZXRXb3JrSW5Qcm9ncmVzc1Jvb3QoKSB7XG4gIHJldHVybiB3b3JrSW5Qcm9ncmVzc1Jvb3Q7XG59XG5mdW5jdGlvbiByZXF1ZXN0RXZlbnRUaW1lKCkge1xuICBpZiAoKGV4ZWN1dGlvbkNvbnRleHQgJiAoUmVuZGVyQ29udGV4dCB8IENvbW1pdENvbnRleHQpKSAhPT0gTm9Db250ZXh0KSB7XG4gICAgLy8gV2UncmUgaW5zaWRlIFJlYWN0LCBzbyBpdCdzIGZpbmUgdG8gcmVhZCB0aGUgYWN0dWFsIHRpbWUuXG4gICAgcmV0dXJuIG5vdygpO1xuICB9IC8vIFdlJ3JlIG5vdCBpbnNpZGUgUmVhY3QsIHNvIHdlIG1heSBiZSBpbiB0aGUgbWlkZGxlIG9mIGEgYnJvd3NlciBldmVudC5cblxuXG4gIGlmIChjdXJyZW50RXZlbnRUaW1lICE9PSBOb1RpbWVzdGFtcCkge1xuICAgIC8vIFVzZSB0aGUgc2FtZSBzdGFydCB0aW1lIGZvciBhbGwgdXBkYXRlcyB1bnRpbCB3ZSBlbnRlciBSZWFjdCBhZ2Fpbi5cbiAgICByZXR1cm4gY3VycmVudEV2ZW50VGltZTtcbiAgfSAvLyBUaGlzIGlzIHRoZSBmaXJzdCB1cGRhdGUgc2luY2UgUmVhY3QgeWllbGRlZC4gQ29tcHV0ZSBhIG5ldyBzdGFydCB0aW1lLlxuXG5cbiAgY3VycmVudEV2ZW50VGltZSA9IG5vdygpO1xuICByZXR1cm4gY3VycmVudEV2ZW50VGltZTtcbn1cbmZ1bmN0aW9uIHJlcXVlc3RVcGRhdGVMYW5lKGZpYmVyKSB7XG4gIC8vIFNwZWNpYWwgY2FzZXNcbiAgdmFyIG1vZGUgPSBmaWJlci5tb2RlO1xuXG4gIGlmICgobW9kZSAmIEJsb2NraW5nTW9kZSkgPT09IE5vTW9kZSkge1xuICAgIHJldHVybiBTeW5jTGFuZTtcbiAgfSBlbHNlIGlmICgobW9kZSAmIENvbmN1cnJlbnRNb2RlKSA9PT0gTm9Nb2RlKSB7XG4gICAgcmV0dXJuIGdldEN1cnJlbnRQcmlvcml0eUxldmVsKCkgPT09IEltbWVkaWF0ZVByaW9yaXR5JDEgPyBTeW5jTGFuZSA6IFN5bmNCYXRjaGVkTGFuZTtcbiAgfSAvLyBUaGUgYWxnb3JpdGhtIGZvciBhc3NpZ25pbmcgYW4gdXBkYXRlIHRvIGEgbGFuZSBzaG91bGQgYmUgc3RhYmxlIGZvciBhbGxcbiAgLy8gdXBkYXRlcyBhdCB0aGUgc2FtZSBwcmlvcml0eSB3aXRoaW4gdGhlIHNhbWUgZXZlbnQuIFRvIGRvIHRoaXMsIHRoZSBpbnB1dHNcbiAgLy8gdG8gdGhlIGFsZ29yaXRobSBtdXN0IGJlIHRoZSBzYW1lLiBGb3IgZXhhbXBsZSwgd2UgdXNlIHRoZSBgcmVuZGVyTGFuZXNgXG4gIC8vIHRvIGF2b2lkIGNob29zaW5nIGEgbGFuZSB0aGF0IGlzIGFscmVhZHkgaW4gdGhlIG1pZGRsZSBvZiByZW5kZXJpbmcuXG4gIC8vXG4gIC8vIEhvd2V2ZXIsIHRoZSBcImluY2x1ZGVkXCIgbGFuZXMgY291bGQgYmUgbXV0YXRlZCBpbiBiZXR3ZWVuIHVwZGF0ZXMgaW4gdGhlXG4gIC8vIHNhbWUgZXZlbnQsIGxpa2UgaWYgeW91IHBlcmZvcm0gYW4gdXBkYXRlIGluc2lkZSBgZmx1c2hTeW5jYC4gT3IgYW55IG90aGVyXG4gIC8vIGNvZGUgcGF0aCB0aGF0IG1pZ2h0IGNhbGwgYHByZXBhcmVGcmVzaFN0YWNrYC5cbiAgLy9cbiAgLy8gVGhlIHRyaWNrIHdlIHVzZSBpcyB0byBjYWNoZSB0aGUgZmlyc3Qgb2YgZWFjaCBvZiB0aGVzZSBpbnB1dHMgd2l0aGluIGFuXG4gIC8vIGV2ZW50LiBUaGVuIHJlc2V0IHRoZSBjYWNoZWQgdmFsdWVzIG9uY2Ugd2UgY2FuIGJlIHN1cmUgdGhlIGV2ZW50IGlzIG92ZXIuXG4gIC8vIE91ciBoZXVyaXN0aWMgZm9yIHRoYXQgaXMgd2hlbmV2ZXIgd2UgZW50ZXIgYSBjb25jdXJyZW50IHdvcmsgbG9vcC5cbiAgLy9cbiAgLy8gV2UnbGwgZG8gdGhlIHNhbWUgZm9yIGBjdXJyZW50RXZlbnRQZW5kaW5nTGFuZXNgIGJlbG93LlxuXG5cbiAgaWYgKGN1cnJlbnRFdmVudFdpcExhbmVzID09PSBOb0xhbmVzKSB7XG4gICAgY3VycmVudEV2ZW50V2lwTGFuZXMgPSB3b3JrSW5Qcm9ncmVzc1Jvb3RJbmNsdWRlZExhbmVzO1xuICB9XG5cbiAgdmFyIGlzVHJhbnNpdGlvbiA9IHJlcXVlc3RDdXJyZW50VHJhbnNpdGlvbigpICE9PSBOb1RyYW5zaXRpb247XG5cbiAgaWYgKGlzVHJhbnNpdGlvbikge1xuICAgIGlmIChjdXJyZW50RXZlbnRQZW5kaW5nTGFuZXMgIT09IE5vTGFuZXMpIHtcbiAgICAgIGN1cnJlbnRFdmVudFBlbmRpbmdMYW5lcyA9IG1vc3RSZWNlbnRseVVwZGF0ZWRSb290ICE9PSBudWxsID8gbW9zdFJlY2VudGx5VXBkYXRlZFJvb3QucGVuZGluZ0xhbmVzIDogTm9MYW5lcztcbiAgICB9XG5cbiAgICByZXR1cm4gZmluZFRyYW5zaXRpb25MYW5lKGN1cnJlbnRFdmVudFdpcExhbmVzLCBjdXJyZW50RXZlbnRQZW5kaW5nTGFuZXMpO1xuICB9IC8vIFRPRE86IFJlbW92ZSB0aGlzIGRlcGVuZGVuY3kgb24gdGhlIFNjaGVkdWxlciBwcmlvcml0eS5cbiAgLy8gVG8gZG8gdGhhdCwgd2UncmUgcmVwbGFjaW5nIGl0IHdpdGggYW4gdXBkYXRlIGxhbmUgcHJpb3JpdHkuXG5cblxuICB2YXIgc2NoZWR1bGVyUHJpb3JpdHkgPSBnZXRDdXJyZW50UHJpb3JpdHlMZXZlbCgpOyAvLyBUaGUgb2xkIGJlaGF2aW9yIHdhcyB1c2luZyB0aGUgcHJpb3JpdHkgbGV2ZWwgb2YgdGhlIFNjaGVkdWxlci5cbiAgLy8gVGhpcyBjb3VwbGVzIFJlYWN0IHRvIHRoZSBTY2hlZHVsZXIgaW50ZXJuYWxzLCBzbyB3ZSdyZSByZXBsYWNpbmcgaXRcbiAgLy8gd2l0aCB0aGUgY3VycmVudFVwZGF0ZUxhbmVQcmlvcml0eSBhYm92ZS4gQXMgYW4gZXhhbXBsZSBvZiBob3cgdGhpc1xuICAvLyBjb3VsZCBiZSBwcm9ibGVtYXRpYywgaWYgd2UncmUgbm90IGluc2lkZSBgU2NoZWR1bGVyLnJ1bldpdGhQcmlvcml0eWAsXG4gIC8vIHRoZW4gd2UnbGwgZ2V0IHRoZSBwcmlvcml0eSBvZiB0aGUgY3VycmVudCBydW5uaW5nIFNjaGVkdWxlciB0YXNrLFxuICAvLyB3aGljaCBpcyBwcm9iYWJseSBub3Qgd2hhdCB3ZSB3YW50LlxuXG4gIHZhciBsYW5lO1xuXG4gIGlmICggLy8gVE9ETzogVGVtcG9yYXJ5LiBXZSdyZSByZW1vdmluZyB0aGUgY29uY2VwdCBvZiBkaXNjcmV0ZSB1cGRhdGVzLlxuICAoZXhlY3V0aW9uQ29udGV4dCAmIERpc2NyZXRlRXZlbnRDb250ZXh0KSAhPT0gTm9Db250ZXh0ICYmIHNjaGVkdWxlclByaW9yaXR5ID09PSBVc2VyQmxvY2tpbmdQcmlvcml0eSQyKSB7XG4gICAgbGFuZSA9IGZpbmRVcGRhdGVMYW5lKElucHV0RGlzY3JldGVMYW5lUHJpb3JpdHksIGN1cnJlbnRFdmVudFdpcExhbmVzKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgc2NoZWR1bGVyTGFuZVByaW9yaXR5ID0gc2NoZWR1bGVyUHJpb3JpdHlUb0xhbmVQcmlvcml0eShzY2hlZHVsZXJQcmlvcml0eSk7XG5cbiAgICBsYW5lID0gZmluZFVwZGF0ZUxhbmUoc2NoZWR1bGVyTGFuZVByaW9yaXR5LCBjdXJyZW50RXZlbnRXaXBMYW5lcyk7XG4gIH1cblxuICByZXR1cm4gbGFuZTtcbn1cblxuZnVuY3Rpb24gcmVxdWVzdFJldHJ5TGFuZShmaWJlcikge1xuICAvLyBUaGlzIGlzIGEgZm9yayBvZiBgcmVxdWVzdFVwZGF0ZUxhbmVgIGRlc2lnbmVkIHNwZWNpZmljYWxseSBmb3IgU3VzcGVuc2VcbiAgLy8gXCJyZXRyaWVzXCIg4oCUIGEgc3BlY2lhbCB1cGRhdGUgdGhhdCBhdHRlbXB0cyB0byBmbGlwIGEgU3VzcGVuc2UgYm91bmRhcnlcbiAgLy8gZnJvbSBpdHMgcGxhY2Vob2xkZXIgc3RhdGUgdG8gaXRzIHByaW1hcnkvcmVzb2x2ZWQgc3RhdGUuXG4gIC8vIFNwZWNpYWwgY2FzZXNcbiAgdmFyIG1vZGUgPSBmaWJlci5tb2RlO1xuXG4gIGlmICgobW9kZSAmIEJsb2NraW5nTW9kZSkgPT09IE5vTW9kZSkge1xuICAgIHJldHVybiBTeW5jTGFuZTtcbiAgfSBlbHNlIGlmICgobW9kZSAmIENvbmN1cnJlbnRNb2RlKSA9PT0gTm9Nb2RlKSB7XG4gICAgcmV0dXJuIGdldEN1cnJlbnRQcmlvcml0eUxldmVsKCkgPT09IEltbWVkaWF0ZVByaW9yaXR5JDEgPyBTeW5jTGFuZSA6IFN5bmNCYXRjaGVkTGFuZTtcbiAgfSAvLyBTZWUgYHJlcXVlc3RVcGRhdGVMYW5lYCBmb3IgZXhwbGFuYXRpb24gb2YgYGN1cnJlbnRFdmVudFdpcExhbmVzYFxuXG5cbiAgaWYgKGN1cnJlbnRFdmVudFdpcExhbmVzID09PSBOb0xhbmVzKSB7XG4gICAgY3VycmVudEV2ZW50V2lwTGFuZXMgPSB3b3JrSW5Qcm9ncmVzc1Jvb3RJbmNsdWRlZExhbmVzO1xuICB9XG5cbiAgcmV0dXJuIGZpbmRSZXRyeUxhbmUoY3VycmVudEV2ZW50V2lwTGFuZXMpO1xufVxuXG5mdW5jdGlvbiBzY2hlZHVsZVVwZGF0ZU9uRmliZXIoZmliZXIsIGxhbmUsIGV2ZW50VGltZSkge1xuICBjaGVja0Zvck5lc3RlZFVwZGF0ZXMoKTtcbiAgd2FybkFib3V0UmVuZGVyUGhhc2VVcGRhdGVzSW5ERVYoZmliZXIpO1xuICB2YXIgcm9vdCA9IG1hcmtVcGRhdGVMYW5lRnJvbUZpYmVyVG9Sb290KGZpYmVyLCBsYW5lKTtcblxuICBpZiAocm9vdCA9PT0gbnVsbCkge1xuICAgIHdhcm5BYm91dFVwZGF0ZU9uVW5tb3VudGVkRmliZXJJbkRFVihmaWJlcik7XG4gICAgcmV0dXJuIG51bGw7XG4gIH0gLy8gTWFyayB0aGF0IHRoZSByb290IGhhcyBhIHBlbmRpbmcgdXBkYXRlLlxuXG5cbiAgbWFya1Jvb3RVcGRhdGVkKHJvb3QsIGxhbmUsIGV2ZW50VGltZSk7XG5cbiAgaWYgKHJvb3QgPT09IHdvcmtJblByb2dyZXNzUm9vdCkge1xuICAgIC8vIFJlY2VpdmVkIGFuIHVwZGF0ZSB0byBhIHRyZWUgdGhhdCdzIGluIHRoZSBtaWRkbGUgb2YgcmVuZGVyaW5nLiBNYXJrXG4gICAgLy8gdGhhdCB0aGVyZSB3YXMgYW4gaW50ZXJsZWF2ZWQgdXBkYXRlIHdvcmsgb24gdGhpcyByb290LiBVbmxlc3MgdGhlXG4gICAgLy8gYGRlZmVyUmVuZGVyUGhhc2VVcGRhdGVUb05leHRCYXRjaGAgZmxhZyBpcyBvZmYgYW5kIHRoaXMgaXMgYSByZW5kZXJcbiAgICAvLyBwaGFzZSB1cGRhdGUuIEluIHRoYXQgY2FzZSwgd2UgZG9uJ3QgdHJlYXQgcmVuZGVyIHBoYXNlIHVwZGF0ZXMgYXMgaWZcbiAgICAvLyB0aGV5IHdlcmUgaW50ZXJsZWF2ZWQsIGZvciBiYWNrd2FyZHMgY29tcGF0IHJlYXNvbnMuXG4gICAge1xuICAgICAgd29ya0luUHJvZ3Jlc3NSb290VXBkYXRlZExhbmVzID0gbWVyZ2VMYW5lcyh3b3JrSW5Qcm9ncmVzc1Jvb3RVcGRhdGVkTGFuZXMsIGxhbmUpO1xuICAgIH1cblxuICAgIGlmICh3b3JrSW5Qcm9ncmVzc1Jvb3RFeGl0U3RhdHVzID09PSBSb290U3VzcGVuZGVkV2l0aERlbGF5KSB7XG4gICAgICAvLyBUaGUgcm9vdCBhbHJlYWR5IHN1c3BlbmRlZCB3aXRoIGEgZGVsYXksIHdoaWNoIG1lYW5zIHRoaXMgcmVuZGVyXG4gICAgICAvLyBkZWZpbml0ZWx5IHdvbid0IGZpbmlzaC4gU2luY2Ugd2UgaGF2ZSBhIG5ldyB1cGRhdGUsIGxldCdzIG1hcmsgaXQgYXNcbiAgICAgIC8vIHN1c3BlbmRlZCBub3csIHJpZ2h0IGJlZm9yZSBtYXJraW5nIHRoZSBpbmNvbWluZyB1cGRhdGUuIFRoaXMgaGFzIHRoZVxuICAgICAgLy8gZWZmZWN0IG9mIGludGVycnVwdGluZyB0aGUgY3VycmVudCByZW5kZXIgYW5kIHN3aXRjaGluZyB0byB0aGUgdXBkYXRlLlxuICAgICAgLy8gVE9ETzogTWFrZSBzdXJlIHRoaXMgZG9lc24ndCBvdmVycmlkZSBwaW5ncyB0aGF0IGhhcHBlbiB3aGlsZSB3ZSd2ZVxuICAgICAgLy8gYWxyZWFkeSBzdGFydGVkIHJlbmRlcmluZy5cbiAgICAgIG1hcmtSb290U3VzcGVuZGVkJDEocm9vdCwgd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMpO1xuICAgIH1cbiAgfSAvLyBUT0RPOiByZXF1ZXN0VXBkYXRlTGFuZVByaW9yaXR5IGFsc28gcmVhZHMgdGhlIHByaW9yaXR5LiBQYXNzIHRoZVxuICAvLyBwcmlvcml0eSBhcyBhbiBhcmd1bWVudCB0byB0aGF0IGZ1bmN0aW9uIGFuZCB0aGlzIG9uZS5cblxuXG4gIHZhciBwcmlvcml0eUxldmVsID0gZ2V0Q3VycmVudFByaW9yaXR5TGV2ZWwoKTtcblxuICBpZiAobGFuZSA9PT0gU3luY0xhbmUpIHtcbiAgICBpZiAoIC8vIENoZWNrIGlmIHdlJ3JlIGluc2lkZSB1bmJhdGNoZWRVcGRhdGVzXG4gICAgKGV4ZWN1dGlvbkNvbnRleHQgJiBMZWdhY3lVbmJhdGNoZWRDb250ZXh0KSAhPT0gTm9Db250ZXh0ICYmIC8vIENoZWNrIGlmIHdlJ3JlIG5vdCBhbHJlYWR5IHJlbmRlcmluZ1xuICAgIChleGVjdXRpb25Db250ZXh0ICYgKFJlbmRlckNvbnRleHQgfCBDb21taXRDb250ZXh0KSkgPT09IE5vQ29udGV4dCkge1xuICAgICAgLy8gUmVnaXN0ZXIgcGVuZGluZyBpbnRlcmFjdGlvbnMgb24gdGhlIHJvb3QgdG8gYXZvaWQgbG9zaW5nIHRyYWNlZCBpbnRlcmFjdGlvbiBkYXRhLlxuICAgICAgc2NoZWR1bGVQZW5kaW5nSW50ZXJhY3Rpb25zKHJvb3QsIGxhbmUpOyAvLyBUaGlzIGlzIGEgbGVnYWN5IGVkZ2UgY2FzZS4gVGhlIGluaXRpYWwgbW91bnQgb2YgYSBSZWFjdERPTS5yZW5kZXItZWRcbiAgICAgIC8vIHJvb3QgaW5zaWRlIG9mIGJhdGNoZWRVcGRhdGVzIHNob3VsZCBiZSBzeW5jaHJvbm91cywgYnV0IGxheW91dCB1cGRhdGVzXG4gICAgICAvLyBzaG91bGQgYmUgZGVmZXJyZWQgdW50aWwgdGhlIGVuZCBvZiB0aGUgYmF0Y2guXG5cbiAgICAgIHBlcmZvcm1TeW5jV29ya09uUm9vdChyb290KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZW5zdXJlUm9vdElzU2NoZWR1bGVkKHJvb3QsIGV2ZW50VGltZSk7XG4gICAgICBzY2hlZHVsZVBlbmRpbmdJbnRlcmFjdGlvbnMocm9vdCwgbGFuZSk7XG5cbiAgICAgIGlmIChleGVjdXRpb25Db250ZXh0ID09PSBOb0NvbnRleHQpIHtcbiAgICAgICAgLy8gRmx1c2ggdGhlIHN5bmNocm9ub3VzIHdvcmsgbm93LCB1bmxlc3Mgd2UncmUgYWxyZWFkeSB3b3JraW5nIG9yIGluc2lkZVxuICAgICAgICAvLyBhIGJhdGNoLiBUaGlzIGlzIGludGVudGlvbmFsbHkgaW5zaWRlIHNjaGVkdWxlVXBkYXRlT25GaWJlciBpbnN0ZWFkIG9mXG4gICAgICAgIC8vIHNjaGVkdWxlQ2FsbGJhY2tGb3JGaWJlciB0byBwcmVzZXJ2ZSB0aGUgYWJpbGl0eSB0byBzY2hlZHVsZSBhIGNhbGxiYWNrXG4gICAgICAgIC8vIHdpdGhvdXQgaW1tZWRpYXRlbHkgZmx1c2hpbmcgaXQuIFdlIG9ubHkgZG8gdGhpcyBmb3IgdXNlci1pbml0aWF0ZWRcbiAgICAgICAgLy8gdXBkYXRlcywgdG8gcHJlc2VydmUgaGlzdG9yaWNhbCBiZWhhdmlvciBvZiBsZWdhY3kgbW9kZS5cbiAgICAgICAgcmVzZXRSZW5kZXJUaW1lcigpO1xuICAgICAgICBmbHVzaFN5bmNDYWxsYmFja1F1ZXVlKCk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIFNjaGVkdWxlIGEgZGlzY3JldGUgdXBkYXRlIGJ1dCBvbmx5IGlmIGl0J3Mgbm90IFN5bmMuXG4gICAgaWYgKChleGVjdXRpb25Db250ZXh0ICYgRGlzY3JldGVFdmVudENvbnRleHQpICE9PSBOb0NvbnRleHQgJiYgKCAvLyBPbmx5IHVwZGF0ZXMgYXQgdXNlci1ibG9ja2luZyBwcmlvcml0eSBvciBncmVhdGVyIGFyZSBjb25zaWRlcmVkXG4gICAgLy8gZGlzY3JldGUsIGV2ZW4gaW5zaWRlIGEgZGlzY3JldGUgZXZlbnQuXG4gICAgcHJpb3JpdHlMZXZlbCA9PT0gVXNlckJsb2NraW5nUHJpb3JpdHkkMiB8fCBwcmlvcml0eUxldmVsID09PSBJbW1lZGlhdGVQcmlvcml0eSQxKSkge1xuICAgICAgLy8gVGhpcyBpcyB0aGUgcmVzdWx0IG9mIGEgZGlzY3JldGUgZXZlbnQuIFRyYWNrIHRoZSBsb3dlc3QgcHJpb3JpdHlcbiAgICAgIC8vIGRpc2NyZXRlIHVwZGF0ZSBwZXIgcm9vdCBzbyB3ZSBjYW4gZmx1c2ggdGhlbSBlYXJseSwgaWYgbmVlZGVkLlxuICAgICAgaWYgKHJvb3RzV2l0aFBlbmRpbmdEaXNjcmV0ZVVwZGF0ZXMgPT09IG51bGwpIHtcbiAgICAgICAgcm9vdHNXaXRoUGVuZGluZ0Rpc2NyZXRlVXBkYXRlcyA9IG5ldyBTZXQoW3Jvb3RdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJvb3RzV2l0aFBlbmRpbmdEaXNjcmV0ZVVwZGF0ZXMuYWRkKHJvb3QpO1xuICAgICAgfVxuICAgIH0gLy8gU2NoZWR1bGUgb3RoZXIgdXBkYXRlcyBhZnRlciBpbiBjYXNlIHRoZSBjYWxsYmFjayBpcyBzeW5jLlxuXG5cbiAgICBlbnN1cmVSb290SXNTY2hlZHVsZWQocm9vdCwgZXZlbnRUaW1lKTtcbiAgICBzY2hlZHVsZVBlbmRpbmdJbnRlcmFjdGlvbnMocm9vdCwgbGFuZSk7XG4gIH0gLy8gV2UgdXNlIHRoaXMgd2hlbiBhc3NpZ25pbmcgYSBsYW5lIGZvciBhIHRyYW5zaXRpb24gaW5zaWRlXG4gIC8vIGByZXF1ZXN0VXBkYXRlTGFuZWAuIFdlIGFzc3VtZSBpdCdzIHRoZSBzYW1lIGFzIHRoZSByb290IGJlaW5nIHVwZGF0ZWQsXG4gIC8vIHNpbmNlIGluIHRoZSBjb21tb24gY2FzZSBvZiBhIHNpbmdsZSByb290IGFwcCBpdCBwcm9iYWJseSBpcy4gSWYgaXQncyBub3RcbiAgLy8gdGhlIHNhbWUgcm9vdCwgdGhlbiBpdCdzIG5vdCBhIGh1Z2UgZGVhbCwgd2UganVzdCBtaWdodCBiYXRjaCBtb3JlIHN0dWZmXG4gIC8vIHRvZ2V0aGVyIG1vcmUgdGhhbiBuZWNlc3NhcnkuXG5cblxuICBtb3N0UmVjZW50bHlVcGRhdGVkUm9vdCA9IHJvb3Q7XG59IC8vIFRoaXMgaXMgc3BsaXQgaW50byBhIHNlcGFyYXRlIGZ1bmN0aW9uIHNvIHdlIGNhbiBtYXJrIGEgZmliZXIgd2l0aCBwZW5kaW5nXG4vLyB3b3JrIHdpdGhvdXQgdHJlYXRpbmcgaXQgYXMgYSB0eXBpY2FsIHVwZGF0ZSB0aGF0IG9yaWdpbmF0ZXMgZnJvbSBhbiBldmVudDtcbi8vIGUuZy4gcmV0cnlpbmcgYSBTdXNwZW5zZSBib3VuZGFyeSBpc24ndCBhbiB1cGRhdGUsIGJ1dCBpdCBkb2VzIHNjaGVkdWxlIHdvcmtcbi8vIG9uIGEgZmliZXIuXG5cbmZ1bmN0aW9uIG1hcmtVcGRhdGVMYW5lRnJvbUZpYmVyVG9Sb290KHNvdXJjZUZpYmVyLCBsYW5lKSB7XG4gIC8vIFVwZGF0ZSB0aGUgc291cmNlIGZpYmVyJ3MgbGFuZXNcbiAgc291cmNlRmliZXIubGFuZXMgPSBtZXJnZUxhbmVzKHNvdXJjZUZpYmVyLmxhbmVzLCBsYW5lKTtcbiAgdmFyIGFsdGVybmF0ZSA9IHNvdXJjZUZpYmVyLmFsdGVybmF0ZTtcblxuICBpZiAoYWx0ZXJuYXRlICE9PSBudWxsKSB7XG4gICAgYWx0ZXJuYXRlLmxhbmVzID0gbWVyZ2VMYW5lcyhhbHRlcm5hdGUubGFuZXMsIGxhbmUpO1xuICB9XG5cbiAge1xuICAgIGlmIChhbHRlcm5hdGUgPT09IG51bGwgJiYgKHNvdXJjZUZpYmVyLmZsYWdzICYgKFBsYWNlbWVudCB8IEh5ZHJhdGluZykpICE9PSBOb0ZsYWdzKSB7XG4gICAgICB3YXJuQWJvdXRVcGRhdGVPbk5vdFlldE1vdW50ZWRGaWJlckluREVWKHNvdXJjZUZpYmVyKTtcbiAgICB9XG4gIH0gLy8gV2FsayB0aGUgcGFyZW50IHBhdGggdG8gdGhlIHJvb3QgYW5kIHVwZGF0ZSB0aGUgY2hpbGQgZXhwaXJhdGlvbiB0aW1lLlxuXG5cbiAgdmFyIG5vZGUgPSBzb3VyY2VGaWJlcjtcbiAgdmFyIHBhcmVudCA9IHNvdXJjZUZpYmVyLnJldHVybjtcblxuICB3aGlsZSAocGFyZW50ICE9PSBudWxsKSB7XG4gICAgcGFyZW50LmNoaWxkTGFuZXMgPSBtZXJnZUxhbmVzKHBhcmVudC5jaGlsZExhbmVzLCBsYW5lKTtcbiAgICBhbHRlcm5hdGUgPSBwYXJlbnQuYWx0ZXJuYXRlO1xuXG4gICAgaWYgKGFsdGVybmF0ZSAhPT0gbnVsbCkge1xuICAgICAgYWx0ZXJuYXRlLmNoaWxkTGFuZXMgPSBtZXJnZUxhbmVzKGFsdGVybmF0ZS5jaGlsZExhbmVzLCBsYW5lKTtcbiAgICB9IGVsc2Uge1xuICAgICAge1xuICAgICAgICBpZiAoKHBhcmVudC5mbGFncyAmIChQbGFjZW1lbnQgfCBIeWRyYXRpbmcpKSAhPT0gTm9GbGFncykge1xuICAgICAgICAgIHdhcm5BYm91dFVwZGF0ZU9uTm90WWV0TW91bnRlZEZpYmVySW5ERVYoc291cmNlRmliZXIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgbm9kZSA9IHBhcmVudDtcbiAgICBwYXJlbnQgPSBwYXJlbnQucmV0dXJuO1xuICB9XG5cbiAgaWYgKG5vZGUudGFnID09PSBIb3N0Um9vdCkge1xuICAgIHZhciByb290ID0gbm9kZS5zdGF0ZU5vZGU7XG4gICAgcmV0dXJuIHJvb3Q7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn0gLy8gVXNlIHRoaXMgZnVuY3Rpb24gdG8gc2NoZWR1bGUgYSB0YXNrIGZvciBhIHJvb3QuIFRoZXJlJ3Mgb25seSBvbmUgdGFzayBwZXJcbi8vIHJvb3Q7IGlmIGEgdGFzayB3YXMgYWxyZWFkeSBzY2hlZHVsZWQsIHdlJ2xsIGNoZWNrIHRvIG1ha2Ugc3VyZSB0aGUgcHJpb3JpdHlcbi8vIG9mIHRoZSBleGlzdGluZyB0YXNrIGlzIHRoZSBzYW1lIGFzIHRoZSBwcmlvcml0eSBvZiB0aGUgbmV4dCBsZXZlbCB0aGF0IHRoZVxuLy8gcm9vdCBoYXMgd29yayBvbi4gVGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgb24gZXZlcnkgdXBkYXRlLCBhbmQgcmlnaHQgYmVmb3JlXG4vLyBleGl0aW5nIGEgdGFzay5cblxuXG5mdW5jdGlvbiBlbnN1cmVSb290SXNTY2hlZHVsZWQocm9vdCwgY3VycmVudFRpbWUpIHtcbiAgdmFyIGV4aXN0aW5nQ2FsbGJhY2tOb2RlID0gcm9vdC5jYWxsYmFja05vZGU7IC8vIENoZWNrIGlmIGFueSBsYW5lcyBhcmUgYmVpbmcgc3RhcnZlZCBieSBvdGhlciB3b3JrLiBJZiBzbywgbWFyayB0aGVtIGFzXG4gIC8vIGV4cGlyZWQgc28gd2Uga25vdyB0byB3b3JrIG9uIHRob3NlIG5leHQuXG5cbiAgbWFya1N0YXJ2ZWRMYW5lc0FzRXhwaXJlZChyb290LCBjdXJyZW50VGltZSk7IC8vIERldGVybWluZSB0aGUgbmV4dCBsYW5lcyB0byB3b3JrIG9uLCBhbmQgdGhlaXIgcHJpb3JpdHkuXG5cbiAgdmFyIG5leHRMYW5lcyA9IGdldE5leHRMYW5lcyhyb290LCByb290ID09PSB3b3JrSW5Qcm9ncmVzc1Jvb3QgPyB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyA6IE5vTGFuZXMpOyAvLyBUaGlzIHJldHVybnMgdGhlIHByaW9yaXR5IGxldmVsIGNvbXB1dGVkIGR1cmluZyB0aGUgYGdldE5leHRMYW5lc2AgY2FsbC5cblxuICB2YXIgbmV3Q2FsbGJhY2tQcmlvcml0eSA9IHJldHVybk5leHRMYW5lc1ByaW9yaXR5KCk7XG5cbiAgaWYgKG5leHRMYW5lcyA9PT0gTm9MYW5lcykge1xuICAgIC8vIFNwZWNpYWwgY2FzZTogVGhlcmUncyBub3RoaW5nIHRvIHdvcmsgb24uXG4gICAgaWYgKGV4aXN0aW5nQ2FsbGJhY2tOb2RlICE9PSBudWxsKSB7XG4gICAgICBjYW5jZWxDYWxsYmFjayhleGlzdGluZ0NhbGxiYWNrTm9kZSk7XG4gICAgICByb290LmNhbGxiYWNrTm9kZSA9IG51bGw7XG4gICAgICByb290LmNhbGxiYWNrUHJpb3JpdHkgPSBOb0xhbmVQcmlvcml0eTtcbiAgICB9XG5cbiAgICByZXR1cm47XG4gIH0gLy8gQ2hlY2sgaWYgdGhlcmUncyBhbiBleGlzdGluZyB0YXNrLiBXZSBtYXkgYmUgYWJsZSB0byByZXVzZSBpdC5cblxuXG4gIGlmIChleGlzdGluZ0NhbGxiYWNrTm9kZSAhPT0gbnVsbCkge1xuICAgIHZhciBleGlzdGluZ0NhbGxiYWNrUHJpb3JpdHkgPSByb290LmNhbGxiYWNrUHJpb3JpdHk7XG5cbiAgICBpZiAoZXhpc3RpbmdDYWxsYmFja1ByaW9yaXR5ID09PSBuZXdDYWxsYmFja1ByaW9yaXR5KSB7XG4gICAgICAvLyBUaGUgcHJpb3JpdHkgaGFzbid0IGNoYW5nZWQuIFdlIGNhbiByZXVzZSB0aGUgZXhpc3RpbmcgdGFzay4gRXhpdC5cbiAgICAgIHJldHVybjtcbiAgICB9IC8vIFRoZSBwcmlvcml0eSBjaGFuZ2VkLiBDYW5jZWwgdGhlIGV4aXN0aW5nIGNhbGxiYWNrLiBXZSdsbCBzY2hlZHVsZSBhIG5ld1xuICAgIC8vIG9uZSBiZWxvdy5cblxuXG4gICAgY2FuY2VsQ2FsbGJhY2soZXhpc3RpbmdDYWxsYmFja05vZGUpO1xuICB9IC8vIFNjaGVkdWxlIGEgbmV3IGNhbGxiYWNrLlxuXG5cbiAgdmFyIG5ld0NhbGxiYWNrTm9kZTtcblxuICBpZiAobmV3Q2FsbGJhY2tQcmlvcml0eSA9PT0gU3luY0xhbmVQcmlvcml0eSkge1xuICAgIC8vIFNwZWNpYWwgY2FzZTogU3luYyBSZWFjdCBjYWxsYmFja3MgYXJlIHNjaGVkdWxlZCBvbiBhIHNwZWNpYWxcbiAgICAvLyBpbnRlcm5hbCBxdWV1ZVxuICAgIG5ld0NhbGxiYWNrTm9kZSA9IHNjaGVkdWxlU3luY0NhbGxiYWNrKHBlcmZvcm1TeW5jV29ya09uUm9vdC5iaW5kKG51bGwsIHJvb3QpKTtcbiAgfSBlbHNlIGlmIChuZXdDYWxsYmFja1ByaW9yaXR5ID09PSBTeW5jQmF0Y2hlZExhbmVQcmlvcml0eSkge1xuICAgIG5ld0NhbGxiYWNrTm9kZSA9IHNjaGVkdWxlQ2FsbGJhY2soSW1tZWRpYXRlUHJpb3JpdHkkMSwgcGVyZm9ybVN5bmNXb3JrT25Sb290LmJpbmQobnVsbCwgcm9vdCkpO1xuICB9IGVsc2Uge1xuICAgIHZhciBzY2hlZHVsZXJQcmlvcml0eUxldmVsID0gbGFuZVByaW9yaXR5VG9TY2hlZHVsZXJQcmlvcml0eShuZXdDYWxsYmFja1ByaW9yaXR5KTtcbiAgICBuZXdDYWxsYmFja05vZGUgPSBzY2hlZHVsZUNhbGxiYWNrKHNjaGVkdWxlclByaW9yaXR5TGV2ZWwsIHBlcmZvcm1Db25jdXJyZW50V29ya09uUm9vdC5iaW5kKG51bGwsIHJvb3QpKTtcbiAgfVxuXG4gIHJvb3QuY2FsbGJhY2tQcmlvcml0eSA9IG5ld0NhbGxiYWNrUHJpb3JpdHk7XG4gIHJvb3QuY2FsbGJhY2tOb2RlID0gbmV3Q2FsbGJhY2tOb2RlO1xufSAvLyBUaGlzIGlzIHRoZSBlbnRyeSBwb2ludCBmb3IgZXZlcnkgY29uY3VycmVudCB0YXNrLCBpLmUuIGFueXRoaW5nIHRoYXRcbi8vIGdvZXMgdGhyb3VnaCBTY2hlZHVsZXIuXG5cblxuZnVuY3Rpb24gcGVyZm9ybUNvbmN1cnJlbnRXb3JrT25Sb290KHJvb3QpIHtcbiAgLy8gU2luY2Ugd2Uga25vdyB3ZSdyZSBpbiBhIFJlYWN0IGV2ZW50LCB3ZSBjYW4gY2xlYXIgdGhlIGN1cnJlbnRcbiAgLy8gZXZlbnQgdGltZS4gVGhlIG5leHQgdXBkYXRlIHdpbGwgY29tcHV0ZSBhIG5ldyBldmVudCB0aW1lLlxuICBjdXJyZW50RXZlbnRUaW1lID0gTm9UaW1lc3RhbXA7XG4gIGN1cnJlbnRFdmVudFdpcExhbmVzID0gTm9MYW5lcztcbiAgY3VycmVudEV2ZW50UGVuZGluZ0xhbmVzID0gTm9MYW5lcztcblxuICBpZiAoISgoZXhlY3V0aW9uQ29udGV4dCAmIChSZW5kZXJDb250ZXh0IHwgQ29tbWl0Q29udGV4dCkpID09PSBOb0NvbnRleHQpKSB7XG4gICAge1xuICAgICAgdGhyb3cgRXJyb3IoIFwiU2hvdWxkIG5vdCBhbHJlYWR5IGJlIHdvcmtpbmcuXCIgKTtcbiAgICB9XG4gIH0gLy8gRmx1c2ggYW55IHBlbmRpbmcgcGFzc2l2ZSBlZmZlY3RzIGJlZm9yZSBkZWNpZGluZyB3aGljaCBsYW5lcyB0byB3b3JrIG9uLFxuICAvLyBpbiBjYXNlIHRoZXkgc2NoZWR1bGUgYWRkaXRpb25hbCB3b3JrLlxuXG5cbiAgdmFyIG9yaWdpbmFsQ2FsbGJhY2tOb2RlID0gcm9vdC5jYWxsYmFja05vZGU7XG4gIHZhciBkaWRGbHVzaFBhc3NpdmVFZmZlY3RzID0gZmx1c2hQYXNzaXZlRWZmZWN0cygpO1xuXG4gIGlmIChkaWRGbHVzaFBhc3NpdmVFZmZlY3RzKSB7XG4gICAgLy8gU29tZXRoaW5nIGluIHRoZSBwYXNzaXZlIGVmZmVjdCBwaGFzZSBtYXkgaGF2ZSBjYW5jZWxlZCB0aGUgY3VycmVudCB0YXNrLlxuICAgIC8vIENoZWNrIGlmIHRoZSB0YXNrIG5vZGUgZm9yIHRoaXMgcm9vdCB3YXMgY2hhbmdlZC5cbiAgICBpZiAocm9vdC5jYWxsYmFja05vZGUgIT09IG9yaWdpbmFsQ2FsbGJhY2tOb2RlKSB7XG4gICAgICAvLyBUaGUgY3VycmVudCB0YXNrIHdhcyBjYW5jZWxlZC4gRXhpdC4gV2UgZG9uJ3QgbmVlZCB0byBjYWxsXG4gICAgICAvLyBgZW5zdXJlUm9vdElzU2NoZWR1bGVkYCBiZWNhdXNlIHRoZSBjaGVjayBhYm92ZSBpbXBsaWVzIGVpdGhlciB0aGF0XG4gICAgICAvLyB0aGVyZSdzIGEgbmV3IHRhc2ssIG9yIHRoYXQgdGhlcmUncyBubyByZW1haW5pbmcgd29yayBvbiB0aGlzIHJvb3QuXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH0gLy8gRGV0ZXJtaW5lIHRoZSBuZXh0IGV4cGlyYXRpb24gdGltZSB0byB3b3JrIG9uLCB1c2luZyB0aGUgZmllbGRzIHN0b3JlZFxuICAvLyBvbiB0aGUgcm9vdC5cblxuXG4gIHZhciBsYW5lcyA9IGdldE5leHRMYW5lcyhyb290LCByb290ID09PSB3b3JrSW5Qcm9ncmVzc1Jvb3QgPyB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyA6IE5vTGFuZXMpO1xuXG4gIGlmIChsYW5lcyA9PT0gTm9MYW5lcykge1xuICAgIC8vIERlZmVuc2l2ZSBjb2RpbmcuIFRoaXMgaXMgbmV2ZXIgZXhwZWN0ZWQgdG8gaGFwcGVuLlxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIGV4aXRTdGF0dXMgPSByZW5kZXJSb290Q29uY3VycmVudChyb290LCBsYW5lcyk7XG5cbiAgaWYgKGluY2x1ZGVzU29tZUxhbmUod29ya0luUHJvZ3Jlc3NSb290SW5jbHVkZWRMYW5lcywgd29ya0luUHJvZ3Jlc3NSb290VXBkYXRlZExhbmVzKSkge1xuICAgIC8vIFRoZSByZW5kZXIgaW5jbHVkZWQgbGFuZXMgdGhhdCB3ZXJlIHVwZGF0ZWQgZHVyaW5nIHRoZSByZW5kZXIgcGhhc2UuXG4gICAgLy8gRm9yIGV4YW1wbGUsIHdoZW4gdW5oaWRpbmcgYSBoaWRkZW4gdHJlZSwgd2UgaW5jbHVkZSBhbGwgdGhlIGxhbmVzXG4gICAgLy8gdGhhdCB3ZXJlIHByZXZpb3VzbHkgc2tpcHBlZCB3aGVuIHRoZSB0cmVlIHdhcyBoaWRkZW4uIFRoYXQgc2V0IG9mXG4gICAgLy8gbGFuZXMgaXMgYSBzdXBlcnNldCBvZiB0aGUgbGFuZXMgd2Ugc3RhcnRlZCByZW5kZXJpbmcgd2l0aC5cbiAgICAvL1xuICAgIC8vIFNvIHdlJ2xsIHRocm93IG91dCB0aGUgY3VycmVudCB3b3JrIGFuZCByZXN0YXJ0LlxuICAgIHByZXBhcmVGcmVzaFN0YWNrKHJvb3QsIE5vTGFuZXMpO1xuICB9IGVsc2UgaWYgKGV4aXRTdGF0dXMgIT09IFJvb3RJbmNvbXBsZXRlKSB7XG4gICAgaWYgKGV4aXRTdGF0dXMgPT09IFJvb3RFcnJvcmVkKSB7XG4gICAgICBleGVjdXRpb25Db250ZXh0IHw9IFJldHJ5QWZ0ZXJFcnJvcjsgLy8gSWYgYW4gZXJyb3Igb2NjdXJyZWQgZHVyaW5nIGh5ZHJhdGlvbixcbiAgICAgIC8vIGRpc2NhcmQgc2VydmVyIHJlc3BvbnNlIGFuZCBmYWxsIGJhY2sgdG8gY2xpZW50IHNpZGUgcmVuZGVyLlxuXG4gICAgICBpZiAocm9vdC5oeWRyYXRlKSB7XG4gICAgICAgIHJvb3QuaHlkcmF0ZSA9IGZhbHNlO1xuICAgICAgICBjbGVhckNvbnRhaW5lcihyb290LmNvbnRhaW5lckluZm8pO1xuICAgICAgfSAvLyBJZiBzb21ldGhpbmcgdGhyZXcgYW4gZXJyb3IsIHRyeSByZW5kZXJpbmcgb25lIG1vcmUgdGltZS4gV2UnbGwgcmVuZGVyXG4gICAgICAvLyBzeW5jaHJvbm91c2x5IHRvIGJsb2NrIGNvbmN1cnJlbnQgZGF0YSBtdXRhdGlvbnMsIGFuZCB3ZSdsbCBpbmNsdWRlc1xuICAgICAgLy8gYWxsIHBlbmRpbmcgdXBkYXRlcyBhcmUgaW5jbHVkZWQuIElmIGl0IHN0aWxsIGZhaWxzIGFmdGVyIHRoZSBzZWNvbmRcbiAgICAgIC8vIGF0dGVtcHQsIHdlJ2xsIGdpdmUgdXAgYW5kIGNvbW1pdCB0aGUgcmVzdWx0aW5nIHRyZWUuXG5cblxuICAgICAgbGFuZXMgPSBnZXRMYW5lc1RvUmV0cnlTeW5jaHJvbm91c2x5T25FcnJvcihyb290KTtcblxuICAgICAgaWYgKGxhbmVzICE9PSBOb0xhbmVzKSB7XG4gICAgICAgIGV4aXRTdGF0dXMgPSByZW5kZXJSb290U3luYyhyb290LCBsYW5lcyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGV4aXRTdGF0dXMgPT09IFJvb3RGYXRhbEVycm9yZWQpIHtcbiAgICAgIHZhciBmYXRhbEVycm9yID0gd29ya0luUHJvZ3Jlc3NSb290RmF0YWxFcnJvcjtcbiAgICAgIHByZXBhcmVGcmVzaFN0YWNrKHJvb3QsIE5vTGFuZXMpO1xuICAgICAgbWFya1Jvb3RTdXNwZW5kZWQkMShyb290LCBsYW5lcyk7XG4gICAgICBlbnN1cmVSb290SXNTY2hlZHVsZWQocm9vdCwgbm93KCkpO1xuICAgICAgdGhyb3cgZmF0YWxFcnJvcjtcbiAgICB9IC8vIFdlIG5vdyBoYXZlIGEgY29uc2lzdGVudCB0cmVlLiBUaGUgbmV4dCBzdGVwIGlzIGVpdGhlciB0byBjb21taXQgaXQsXG4gICAgLy8gb3IsIGlmIHNvbWV0aGluZyBzdXNwZW5kZWQsIHdhaXQgdG8gY29tbWl0IGl0IGFmdGVyIGEgdGltZW91dC5cblxuXG4gICAgdmFyIGZpbmlzaGVkV29yayA9IHJvb3QuY3VycmVudC5hbHRlcm5hdGU7XG4gICAgcm9vdC5maW5pc2hlZFdvcmsgPSBmaW5pc2hlZFdvcms7XG4gICAgcm9vdC5maW5pc2hlZExhbmVzID0gbGFuZXM7XG4gICAgZmluaXNoQ29uY3VycmVudFJlbmRlcihyb290LCBleGl0U3RhdHVzLCBsYW5lcyk7XG4gIH1cblxuICBlbnN1cmVSb290SXNTY2hlZHVsZWQocm9vdCwgbm93KCkpO1xuXG4gIGlmIChyb290LmNhbGxiYWNrTm9kZSA9PT0gb3JpZ2luYWxDYWxsYmFja05vZGUpIHtcbiAgICAvLyBUaGUgdGFzayBub2RlIHNjaGVkdWxlZCBmb3IgdGhpcyByb290IGlzIHRoZSBzYW1lIG9uZSB0aGF0J3NcbiAgICAvLyBjdXJyZW50bHkgZXhlY3V0ZWQuIE5lZWQgdG8gcmV0dXJuIGEgY29udGludWF0aW9uLlxuICAgIHJldHVybiBwZXJmb3JtQ29uY3VycmVudFdvcmtPblJvb3QuYmluZChudWxsLCByb290KTtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBmaW5pc2hDb25jdXJyZW50UmVuZGVyKHJvb3QsIGV4aXRTdGF0dXMsIGxhbmVzKSB7XG4gIHN3aXRjaCAoZXhpdFN0YXR1cykge1xuICAgIGNhc2UgUm9vdEluY29tcGxldGU6XG4gICAgY2FzZSBSb290RmF0YWxFcnJvcmVkOlxuICAgICAge1xuICAgICAgICB7XG4gICAgICAgICAge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoIFwiUm9vdCBkaWQgbm90IGNvbXBsZXRlLiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LlwiICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgLy8gRmxvdyBrbm93cyBhYm91dCBpbnZhcmlhbnQsIHNvIGl0IGNvbXBsYWlucyBpZiBJIGFkZCBhIGJyZWFrXG4gICAgLy8gc3RhdGVtZW50LCBidXQgZXNsaW50IGRvZXNuJ3Qga25vdyBhYm91dCBpbnZhcmlhbnQsIHNvIGl0IGNvbXBsYWluc1xuICAgIC8vIGlmIEkgZG8uIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1mYWxsdGhyb3VnaFxuXG4gICAgY2FzZSBSb290RXJyb3JlZDpcbiAgICAgIHtcbiAgICAgICAgLy8gV2Ugc2hvdWxkIGhhdmUgYWxyZWFkeSBhdHRlbXB0ZWQgdG8gcmV0cnkgdGhpcyB0cmVlLiBJZiB3ZSByZWFjaGVkXG4gICAgICAgIC8vIHRoaXMgcG9pbnQsIGl0IGVycm9yZWQgYWdhaW4uIENvbW1pdCBpdC5cbiAgICAgICAgY29tbWl0Um9vdChyb290KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICBjYXNlIFJvb3RTdXNwZW5kZWQ6XG4gICAgICB7XG4gICAgICAgIG1hcmtSb290U3VzcGVuZGVkJDEocm9vdCwgbGFuZXMpOyAvLyBXZSBoYXZlIGFuIGFjY2VwdGFibGUgbG9hZGluZyBzdGF0ZS4gV2UgbmVlZCB0byBmaWd1cmUgb3V0IGlmIHdlXG4gICAgICAgIC8vIHNob3VsZCBpbW1lZGlhdGVseSBjb21taXQgaXQgb3Igd2FpdCBhIGJpdC5cblxuICAgICAgICBpZiAoaW5jbHVkZXNPbmx5UmV0cmllcyhsYW5lcykgJiYgLy8gZG8gbm90IGRlbGF5IGlmIHdlJ3JlIGluc2lkZSBhbiBhY3QoKSBzY29wZVxuICAgICAgICAhc2hvdWxkRm9yY2VGbHVzaEZhbGxiYWNrc0luREVWKCkpIHtcbiAgICAgICAgICAvLyBUaGlzIHJlbmRlciBvbmx5IGluY2x1ZGVkIHJldHJpZXMsIG5vIHVwZGF0ZXMuIFRocm90dGxlIGNvbW1pdHRpbmdcbiAgICAgICAgICAvLyByZXRyaWVzIHNvIHRoYXQgd2UgZG9uJ3Qgc2hvdyB0b28gbWFueSBsb2FkaW5nIHN0YXRlcyB0b28gcXVpY2tseS5cbiAgICAgICAgICB2YXIgbXNVbnRpbFRpbWVvdXQgPSBnbG9iYWxNb3N0UmVjZW50RmFsbGJhY2tUaW1lICsgRkFMTEJBQ0tfVEhST1RUTEVfTVMgLSBub3coKTsgLy8gRG9uJ3QgYm90aGVyIHdpdGggYSB2ZXJ5IHNob3J0IHN1c3BlbnNlIHRpbWUuXG5cbiAgICAgICAgICBpZiAobXNVbnRpbFRpbWVvdXQgPiAxMCkge1xuICAgICAgICAgICAgdmFyIG5leHRMYW5lcyA9IGdldE5leHRMYW5lcyhyb290LCBOb0xhbmVzKTtcblxuICAgICAgICAgICAgaWYgKG5leHRMYW5lcyAhPT0gTm9MYW5lcykge1xuICAgICAgICAgICAgICAvLyBUaGVyZSdzIGFkZGl0aW9uYWwgd29yayBvbiB0aGlzIHJvb3QuXG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgc3VzcGVuZGVkTGFuZXMgPSByb290LnN1c3BlbmRlZExhbmVzO1xuXG4gICAgICAgICAgICBpZiAoIWlzU3Vic2V0T2ZMYW5lcyhzdXNwZW5kZWRMYW5lcywgbGFuZXMpKSB7XG4gICAgICAgICAgICAgIC8vIFdlIHNob3VsZCBwcmVmZXIgdG8gcmVuZGVyIHRoZSBmYWxsYmFjayBvZiBhdCB0aGUgbGFzdFxuICAgICAgICAgICAgICAvLyBzdXNwZW5kZWQgbGV2ZWwuIFBpbmcgdGhlIGxhc3Qgc3VzcGVuZGVkIGxldmVsIHRvIHRyeVxuICAgICAgICAgICAgICAvLyByZW5kZXJpbmcgaXQgYWdhaW4uXG4gICAgICAgICAgICAgIC8vIEZJWE1FOiBXaGF0IGlmIHRoZSBzdXNwZW5kZWQgbGFuZXMgYXJlIElkbGU/IFNob3VsZCBub3QgcmVzdGFydC5cbiAgICAgICAgICAgICAgdmFyIGV2ZW50VGltZSA9IHJlcXVlc3RFdmVudFRpbWUoKTtcbiAgICAgICAgICAgICAgbWFya1Jvb3RQaW5nZWQocm9vdCwgc3VzcGVuZGVkTGFuZXMpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH0gLy8gVGhlIHJlbmRlciBpcyBzdXNwZW5kZWQsIGl0IGhhc24ndCB0aW1lZCBvdXQsIGFuZCB0aGVyZSdzIG5vXG4gICAgICAgICAgICAvLyBsb3dlciBwcmlvcml0eSB3b3JrIHRvIGRvLiBJbnN0ZWFkIG9mIGNvbW1pdHRpbmcgdGhlIGZhbGxiYWNrXG4gICAgICAgICAgICAvLyBpbW1lZGlhdGVseSwgd2FpdCBmb3IgbW9yZSBkYXRhIHRvIGFycml2ZS5cblxuXG4gICAgICAgICAgICByb290LnRpbWVvdXRIYW5kbGUgPSBzY2hlZHVsZVRpbWVvdXQoY29tbWl0Um9vdC5iaW5kKG51bGwsIHJvb3QpLCBtc1VudGlsVGltZW91dCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH0gLy8gVGhlIHdvcmsgZXhwaXJlZC4gQ29tbWl0IGltbWVkaWF0ZWx5LlxuXG5cbiAgICAgICAgY29tbWl0Um9vdChyb290KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICBjYXNlIFJvb3RTdXNwZW5kZWRXaXRoRGVsYXk6XG4gICAgICB7XG4gICAgICAgIG1hcmtSb290U3VzcGVuZGVkJDEocm9vdCwgbGFuZXMpO1xuXG4gICAgICAgIGlmIChpbmNsdWRlc09ubHlUcmFuc2l0aW9ucyhsYW5lcykpIHtcbiAgICAgICAgICAvLyBUaGlzIGlzIGEgdHJhbnNpdGlvbiwgc28gd2Ugc2hvdWxkIGV4aXQgd2l0aG91dCBjb21taXR0aW5nIGFcbiAgICAgICAgICAvLyBwbGFjZWhvbGRlciBhbmQgd2l0aG91dCBzY2hlZHVsaW5nIGEgdGltZW91dC4gRGVsYXkgaW5kZWZpbml0ZWx5XG4gICAgICAgICAgLy8gdW50aWwgd2UgcmVjZWl2ZSBtb3JlIGRhdGEuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXNob3VsZEZvcmNlRmx1c2hGYWxsYmFja3NJbkRFVigpKSB7XG4gICAgICAgICAgLy8gVGhpcyBpcyBub3QgYSB0cmFuc2l0aW9uLCBidXQgd2UgZGlkIHRyaWdnZXIgYW4gYXZvaWRlZCBzdGF0ZS5cbiAgICAgICAgICAvLyBTY2hlZHVsZSBhIHBsYWNlaG9sZGVyIHRvIGRpc3BsYXkgYWZ0ZXIgYSBzaG9ydCBkZWxheSwgdXNpbmcgdGhlIEp1c3RcbiAgICAgICAgICAvLyBOb3RpY2VhYmxlIERpZmZlcmVuY2UuXG4gICAgICAgICAgLy8gVE9ETzogSXMgdGhlIEpORCBvcHRpbWl6YXRpb24gd29ydGggdGhlIGFkZGVkIGNvbXBsZXhpdHk/IElmIHRoaXMgaXNcbiAgICAgICAgICAvLyB0aGUgb25seSByZWFzb24gd2UgdHJhY2sgdGhlIGV2ZW50IHRpbWUsIHRoZW4gcHJvYmFibHkgbm90LlxuICAgICAgICAgIC8vIENvbnNpZGVyIHJlbW92aW5nLlxuICAgICAgICAgIHZhciBtb3N0UmVjZW50RXZlbnRUaW1lID0gZ2V0TW9zdFJlY2VudEV2ZW50VGltZShyb290LCBsYW5lcyk7XG4gICAgICAgICAgdmFyIGV2ZW50VGltZU1zID0gbW9zdFJlY2VudEV2ZW50VGltZTtcbiAgICAgICAgICB2YXIgdGltZUVsYXBzZWRNcyA9IG5vdygpIC0gZXZlbnRUaW1lTXM7XG5cbiAgICAgICAgICB2YXIgX21zVW50aWxUaW1lb3V0ID0gam5kKHRpbWVFbGFwc2VkTXMpIC0gdGltZUVsYXBzZWRNczsgLy8gRG9uJ3QgYm90aGVyIHdpdGggYSB2ZXJ5IHNob3J0IHN1c3BlbnNlIHRpbWUuXG5cblxuICAgICAgICAgIGlmIChfbXNVbnRpbFRpbWVvdXQgPiAxMCkge1xuICAgICAgICAgICAgLy8gSW5zdGVhZCBvZiBjb21taXR0aW5nIHRoZSBmYWxsYmFjayBpbW1lZGlhdGVseSwgd2FpdCBmb3IgbW9yZSBkYXRhXG4gICAgICAgICAgICAvLyB0byBhcnJpdmUuXG4gICAgICAgICAgICByb290LnRpbWVvdXRIYW5kbGUgPSBzY2hlZHVsZVRpbWVvdXQoY29tbWl0Um9vdC5iaW5kKG51bGwsIHJvb3QpLCBfbXNVbnRpbFRpbWVvdXQpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vIENvbW1pdCB0aGUgcGxhY2Vob2xkZXIuXG5cblxuICAgICAgICBjb21taXRSb290KHJvb3QpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgIGNhc2UgUm9vdENvbXBsZXRlZDpcbiAgICAgIHtcbiAgICAgICAgLy8gVGhlIHdvcmsgY29tcGxldGVkLiBSZWFkeSB0byBjb21taXQuXG4gICAgICAgIGNvbW1pdFJvb3Qocm9vdCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgZGVmYXVsdDpcbiAgICAgIHtcbiAgICAgICAge1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKCBcIlVua25vd24gcm9vdCBleGl0IHN0YXR1cy5cIiApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIG1hcmtSb290U3VzcGVuZGVkJDEocm9vdCwgc3VzcGVuZGVkTGFuZXMpIHtcbiAgLy8gV2hlbiBzdXNwZW5kaW5nLCB3ZSBzaG91bGQgYWx3YXlzIGV4Y2x1ZGUgbGFuZXMgdGhhdCB3ZXJlIHBpbmdlZCBvciAobW9yZVxuICAvLyByYXJlbHksIHNpbmNlIHdlIHRyeSB0byBhdm9pZCBpdCkgdXBkYXRlZCBkdXJpbmcgdGhlIHJlbmRlciBwaGFzZS5cbiAgLy8gVE9ETzogTG9sIG1heWJlIHRoZXJlJ3MgYSBiZXR0ZXIgd2F5IHRvIGZhY3RvciB0aGlzIGJlc2lkZXMgdGhpc1xuICAvLyBvYm5veGlvdXNseSBuYW1lZCBmdW5jdGlvbiA6KVxuICBzdXNwZW5kZWRMYW5lcyA9IHJlbW92ZUxhbmVzKHN1c3BlbmRlZExhbmVzLCB3b3JrSW5Qcm9ncmVzc1Jvb3RQaW5nZWRMYW5lcyk7XG4gIHN1c3BlbmRlZExhbmVzID0gcmVtb3ZlTGFuZXMoc3VzcGVuZGVkTGFuZXMsIHdvcmtJblByb2dyZXNzUm9vdFVwZGF0ZWRMYW5lcyk7XG4gIG1hcmtSb290U3VzcGVuZGVkKHJvb3QsIHN1c3BlbmRlZExhbmVzKTtcbn0gLy8gVGhpcyBpcyB0aGUgZW50cnkgcG9pbnQgZm9yIHN5bmNocm9ub3VzIHRhc2tzIHRoYXQgZG9uJ3QgZ29cbi8vIHRocm91Z2ggU2NoZWR1bGVyXG5cblxuZnVuY3Rpb24gcGVyZm9ybVN5bmNXb3JrT25Sb290KHJvb3QpIHtcbiAgaWYgKCEoKGV4ZWN1dGlvbkNvbnRleHQgJiAoUmVuZGVyQ29udGV4dCB8IENvbW1pdENvbnRleHQpKSA9PT0gTm9Db250ZXh0KSkge1xuICAgIHtcbiAgICAgIHRocm93IEVycm9yKCBcIlNob3VsZCBub3QgYWxyZWFkeSBiZSB3b3JraW5nLlwiICk7XG4gICAgfVxuICB9XG5cbiAgZmx1c2hQYXNzaXZlRWZmZWN0cygpO1xuICB2YXIgbGFuZXM7XG4gIHZhciBleGl0U3RhdHVzO1xuXG4gIGlmIChyb290ID09PSB3b3JrSW5Qcm9ncmVzc1Jvb3QgJiYgaW5jbHVkZXNTb21lTGFuZShyb290LmV4cGlyZWRMYW5lcywgd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMpKSB7XG4gICAgLy8gVGhlcmUncyBhIHBhcnRpYWwgdHJlZSwgYW5kIGF0IGxlYXN0IG9uZSBvZiBpdHMgbGFuZXMgaGFzIGV4cGlyZWQuIEZpbmlzaFxuICAgIC8vIHJlbmRlcmluZyBpdCBiZWZvcmUgcmVuZGVyaW5nIHRoZSByZXN0IG9mIHRoZSBleHBpcmVkIHdvcmsuXG4gICAgbGFuZXMgPSB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcztcbiAgICBleGl0U3RhdHVzID0gcmVuZGVyUm9vdFN5bmMocm9vdCwgbGFuZXMpO1xuXG4gICAgaWYgKGluY2x1ZGVzU29tZUxhbmUod29ya0luUHJvZ3Jlc3NSb290SW5jbHVkZWRMYW5lcywgd29ya0luUHJvZ3Jlc3NSb290VXBkYXRlZExhbmVzKSkge1xuICAgICAgLy8gVGhlIHJlbmRlciBpbmNsdWRlZCBsYW5lcyB0aGF0IHdlcmUgdXBkYXRlZCBkdXJpbmcgdGhlIHJlbmRlciBwaGFzZS5cbiAgICAgIC8vIEZvciBleGFtcGxlLCB3aGVuIHVuaGlkaW5nIGEgaGlkZGVuIHRyZWUsIHdlIGluY2x1ZGUgYWxsIHRoZSBsYW5lc1xuICAgICAgLy8gdGhhdCB3ZXJlIHByZXZpb3VzbHkgc2tpcHBlZCB3aGVuIHRoZSB0cmVlIHdhcyBoaWRkZW4uIFRoYXQgc2V0IG9mXG4gICAgICAvLyBsYW5lcyBpcyBhIHN1cGVyc2V0IG9mIHRoZSBsYW5lcyB3ZSBzdGFydGVkIHJlbmRlcmluZyB3aXRoLlxuICAgICAgLy9cbiAgICAgIC8vIE5vdGUgdGhhdCB0aGlzIG9ubHkgaGFwcGVucyB3aGVuIHBhcnQgb2YgdGhlIHRyZWUgaXMgcmVuZGVyZWRcbiAgICAgIC8vIGNvbmN1cnJlbnRseS4gSWYgdGhlIHdob2xlIHRyZWUgaXMgcmVuZGVyZWQgc3luY2hyb25vdXNseSwgdGhlbiB0aGVyZVxuICAgICAgLy8gYXJlIG5vIGludGVybGVhdmVkIGV2ZW50cy5cbiAgICAgIGxhbmVzID0gZ2V0TmV4dExhbmVzKHJvb3QsIGxhbmVzKTtcbiAgICAgIGV4aXRTdGF0dXMgPSByZW5kZXJSb290U3luYyhyb290LCBsYW5lcyk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGxhbmVzID0gZ2V0TmV4dExhbmVzKHJvb3QsIE5vTGFuZXMpO1xuICAgIGV4aXRTdGF0dXMgPSByZW5kZXJSb290U3luYyhyb290LCBsYW5lcyk7XG4gIH1cblxuICBpZiAocm9vdC50YWcgIT09IExlZ2FjeVJvb3QgJiYgZXhpdFN0YXR1cyA9PT0gUm9vdEVycm9yZWQpIHtcbiAgICBleGVjdXRpb25Db250ZXh0IHw9IFJldHJ5QWZ0ZXJFcnJvcjsgLy8gSWYgYW4gZXJyb3Igb2NjdXJyZWQgZHVyaW5nIGh5ZHJhdGlvbixcbiAgICAvLyBkaXNjYXJkIHNlcnZlciByZXNwb25zZSBhbmQgZmFsbCBiYWNrIHRvIGNsaWVudCBzaWRlIHJlbmRlci5cblxuICAgIGlmIChyb290Lmh5ZHJhdGUpIHtcbiAgICAgIHJvb3QuaHlkcmF0ZSA9IGZhbHNlO1xuICAgICAgY2xlYXJDb250YWluZXIocm9vdC5jb250YWluZXJJbmZvKTtcbiAgICB9IC8vIElmIHNvbWV0aGluZyB0aHJldyBhbiBlcnJvciwgdHJ5IHJlbmRlcmluZyBvbmUgbW9yZSB0aW1lLiBXZSdsbCByZW5kZXJcbiAgICAvLyBzeW5jaHJvbm91c2x5IHRvIGJsb2NrIGNvbmN1cnJlbnQgZGF0YSBtdXRhdGlvbnMsIGFuZCB3ZSdsbCBpbmNsdWRlc1xuICAgIC8vIGFsbCBwZW5kaW5nIHVwZGF0ZXMgYXJlIGluY2x1ZGVkLiBJZiBpdCBzdGlsbCBmYWlscyBhZnRlciB0aGUgc2Vjb25kXG4gICAgLy8gYXR0ZW1wdCwgd2UnbGwgZ2l2ZSB1cCBhbmQgY29tbWl0IHRoZSByZXN1bHRpbmcgdHJlZS5cblxuXG4gICAgbGFuZXMgPSBnZXRMYW5lc1RvUmV0cnlTeW5jaHJvbm91c2x5T25FcnJvcihyb290KTtcblxuICAgIGlmIChsYW5lcyAhPT0gTm9MYW5lcykge1xuICAgICAgZXhpdFN0YXR1cyA9IHJlbmRlclJvb3RTeW5jKHJvb3QsIGxhbmVzKTtcbiAgICB9XG4gIH1cblxuICBpZiAoZXhpdFN0YXR1cyA9PT0gUm9vdEZhdGFsRXJyb3JlZCkge1xuICAgIHZhciBmYXRhbEVycm9yID0gd29ya0luUHJvZ3Jlc3NSb290RmF0YWxFcnJvcjtcbiAgICBwcmVwYXJlRnJlc2hTdGFjayhyb290LCBOb0xhbmVzKTtcbiAgICBtYXJrUm9vdFN1c3BlbmRlZCQxKHJvb3QsIGxhbmVzKTtcbiAgICBlbnN1cmVSb290SXNTY2hlZHVsZWQocm9vdCwgbm93KCkpO1xuICAgIHRocm93IGZhdGFsRXJyb3I7XG4gIH0gLy8gV2Ugbm93IGhhdmUgYSBjb25zaXN0ZW50IHRyZWUuIEJlY2F1c2UgdGhpcyBpcyBhIHN5bmMgcmVuZGVyLCB3ZVxuICAvLyB3aWxsIGNvbW1pdCBpdCBldmVuIGlmIHNvbWV0aGluZyBzdXNwZW5kZWQuXG5cblxuICB2YXIgZmluaXNoZWRXb3JrID0gcm9vdC5jdXJyZW50LmFsdGVybmF0ZTtcbiAgcm9vdC5maW5pc2hlZFdvcmsgPSBmaW5pc2hlZFdvcms7XG4gIHJvb3QuZmluaXNoZWRMYW5lcyA9IGxhbmVzO1xuICBjb21taXRSb290KHJvb3QpOyAvLyBCZWZvcmUgZXhpdGluZywgbWFrZSBzdXJlIHRoZXJlJ3MgYSBjYWxsYmFjayBzY2hlZHVsZWQgZm9yIHRoZSBuZXh0XG4gIC8vIHBlbmRpbmcgbGV2ZWwuXG5cbiAgZW5zdXJlUm9vdElzU2NoZWR1bGVkKHJvb3QsIG5vdygpKTtcbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBmbHVzaERpc2NyZXRlVXBkYXRlcygpIHtcbiAgLy8gVE9ETzogU2hvdWxkIGJlIGFibGUgdG8gZmx1c2ggaW5zaWRlIGJhdGNoZWRVcGRhdGVzLCBidXQgbm90IGluc2lkZSBgYWN0YC5cbiAgLy8gSG93ZXZlciwgYGFjdGAgdXNlcyBgYmF0Y2hlZFVwZGF0ZXNgLCBzbyB0aGVyZSdzIG5vIHdheSB0byBkaXN0aW5ndWlzaFxuICAvLyB0aG9zZSB0d28gY2FzZXMuIE5lZWQgdG8gZml4IHRoaXMgYmVmb3JlIGV4cG9zaW5nIGZsdXNoRGlzY3JldGVVcGRhdGVzXG4gIC8vIGFzIGEgcHVibGljIEFQSS5cbiAgaWYgKChleGVjdXRpb25Db250ZXh0ICYgKEJhdGNoZWRDb250ZXh0IHwgUmVuZGVyQ29udGV4dCB8IENvbW1pdENvbnRleHQpKSAhPT0gTm9Db250ZXh0KSB7XG4gICAge1xuICAgICAgaWYgKChleGVjdXRpb25Db250ZXh0ICYgUmVuZGVyQ29udGV4dCkgIT09IE5vQ29udGV4dCkge1xuICAgICAgICBlcnJvcigndW5zdGFibGVfZmx1c2hEaXNjcmV0ZVVwZGF0ZXM6IENhbm5vdCBmbHVzaCB1cGRhdGVzIHdoZW4gUmVhY3QgaXMgJyArICdhbHJlYWR5IHJlbmRlcmluZy4nKTtcbiAgICAgIH1cbiAgICB9IC8vIFdlJ3JlIGFscmVhZHkgcmVuZGVyaW5nLCBzbyB3ZSBjYW4ndCBzeW5jaHJvbm91c2x5IGZsdXNoIHBlbmRpbmcgd29yay5cbiAgICAvLyBUaGlzIGlzIHByb2JhYmx5IGEgbmVzdGVkIGV2ZW50IGRpc3BhdGNoIHRyaWdnZXJlZCBieSBhIGxpZmVjeWNsZS9lZmZlY3QsXG4gICAgLy8gbGlrZSBgZWwuZm9jdXMoKWAuIEV4aXQuXG5cblxuICAgIHJldHVybjtcbiAgfVxuXG4gIGZsdXNoUGVuZGluZ0Rpc2NyZXRlVXBkYXRlcygpOyAvLyBJZiB0aGUgZGlzY3JldGUgdXBkYXRlcyBzY2hlZHVsZWQgcGFzc2l2ZSBlZmZlY3RzLCBmbHVzaCB0aGVtIG5vdyBzbyB0aGF0XG4gIC8vIHRoZXkgZmlyZSBiZWZvcmUgdGhlIG5leHQgc2VyaWFsIGV2ZW50LlxuXG4gIGZsdXNoUGFzc2l2ZUVmZmVjdHMoKTtcbn1cblxuZnVuY3Rpb24gZmx1c2hQZW5kaW5nRGlzY3JldGVVcGRhdGVzKCkge1xuICBpZiAocm9vdHNXaXRoUGVuZGluZ0Rpc2NyZXRlVXBkYXRlcyAhPT0gbnVsbCkge1xuICAgIC8vIEZvciBlYWNoIHJvb3Qgd2l0aCBwZW5kaW5nIGRpc2NyZXRlIHVwZGF0ZXMsIHNjaGVkdWxlIGEgY2FsbGJhY2sgdG9cbiAgICAvLyBpbW1lZGlhdGVseSBmbHVzaCB0aGVtLlxuICAgIHZhciByb290cyA9IHJvb3RzV2l0aFBlbmRpbmdEaXNjcmV0ZVVwZGF0ZXM7XG4gICAgcm9vdHNXaXRoUGVuZGluZ0Rpc2NyZXRlVXBkYXRlcyA9IG51bGw7XG4gICAgcm9vdHMuZm9yRWFjaChmdW5jdGlvbiAocm9vdCkge1xuICAgICAgbWFya0Rpc2NyZXRlVXBkYXRlc0V4cGlyZWQocm9vdCk7XG4gICAgICBlbnN1cmVSb290SXNTY2hlZHVsZWQocm9vdCwgbm93KCkpO1xuICAgIH0pO1xuICB9IC8vIE5vdyBmbHVzaCB0aGUgaW1tZWRpYXRlIHF1ZXVlLlxuXG5cbiAgZmx1c2hTeW5jQ2FsbGJhY2tRdWV1ZSgpO1xufVxuXG5mdW5jdGlvbiBiYXRjaGVkVXBkYXRlcyQxKGZuLCBhKSB7XG4gIHZhciBwcmV2RXhlY3V0aW9uQ29udGV4dCA9IGV4ZWN1dGlvbkNvbnRleHQ7XG4gIGV4ZWN1dGlvbkNvbnRleHQgfD0gQmF0Y2hlZENvbnRleHQ7XG5cbiAgdHJ5IHtcbiAgICByZXR1cm4gZm4oYSk7XG4gIH0gZmluYWxseSB7XG4gICAgZXhlY3V0aW9uQ29udGV4dCA9IHByZXZFeGVjdXRpb25Db250ZXh0O1xuXG4gICAgaWYgKGV4ZWN1dGlvbkNvbnRleHQgPT09IE5vQ29udGV4dCkge1xuICAgICAgLy8gRmx1c2ggdGhlIGltbWVkaWF0ZSBjYWxsYmFja3MgdGhhdCB3ZXJlIHNjaGVkdWxlZCBkdXJpbmcgdGhpcyBiYXRjaFxuICAgICAgcmVzZXRSZW5kZXJUaW1lcigpO1xuICAgICAgZmx1c2hTeW5jQ2FsbGJhY2tRdWV1ZSgpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gYmF0Y2hlZEV2ZW50VXBkYXRlcyQxKGZuLCBhKSB7XG4gIHZhciBwcmV2RXhlY3V0aW9uQ29udGV4dCA9IGV4ZWN1dGlvbkNvbnRleHQ7XG4gIGV4ZWN1dGlvbkNvbnRleHQgfD0gRXZlbnRDb250ZXh0O1xuXG4gIHRyeSB7XG4gICAgcmV0dXJuIGZuKGEpO1xuICB9IGZpbmFsbHkge1xuICAgIGV4ZWN1dGlvbkNvbnRleHQgPSBwcmV2RXhlY3V0aW9uQ29udGV4dDtcblxuICAgIGlmIChleGVjdXRpb25Db250ZXh0ID09PSBOb0NvbnRleHQpIHtcbiAgICAgIC8vIEZsdXNoIHRoZSBpbW1lZGlhdGUgY2FsbGJhY2tzIHRoYXQgd2VyZSBzY2hlZHVsZWQgZHVyaW5nIHRoaXMgYmF0Y2hcbiAgICAgIHJlc2V0UmVuZGVyVGltZXIoKTtcbiAgICAgIGZsdXNoU3luY0NhbGxiYWNrUXVldWUoKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGRpc2NyZXRlVXBkYXRlcyQxKGZuLCBhLCBiLCBjLCBkKSB7XG4gIHZhciBwcmV2RXhlY3V0aW9uQ29udGV4dCA9IGV4ZWN1dGlvbkNvbnRleHQ7XG4gIGV4ZWN1dGlvbkNvbnRleHQgfD0gRGlzY3JldGVFdmVudENvbnRleHQ7XG5cbiAge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gcnVuV2l0aFByaW9yaXR5JDEoVXNlckJsb2NraW5nUHJpb3JpdHkkMiwgZm4uYmluZChudWxsLCBhLCBiLCBjLCBkKSk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGV4ZWN1dGlvbkNvbnRleHQgPSBwcmV2RXhlY3V0aW9uQ29udGV4dDtcblxuICAgICAgaWYgKGV4ZWN1dGlvbkNvbnRleHQgPT09IE5vQ29udGV4dCkge1xuICAgICAgICAvLyBGbHVzaCB0aGUgaW1tZWRpYXRlIGNhbGxiYWNrcyB0aGF0IHdlcmUgc2NoZWR1bGVkIGR1cmluZyB0aGlzIGJhdGNoXG4gICAgICAgIHJlc2V0UmVuZGVyVGltZXIoKTtcbiAgICAgICAgZmx1c2hTeW5jQ2FsbGJhY2tRdWV1ZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gdW5iYXRjaGVkVXBkYXRlcyhmbiwgYSkge1xuICB2YXIgcHJldkV4ZWN1dGlvbkNvbnRleHQgPSBleGVjdXRpb25Db250ZXh0O1xuICBleGVjdXRpb25Db250ZXh0ICY9IH5CYXRjaGVkQ29udGV4dDtcbiAgZXhlY3V0aW9uQ29udGV4dCB8PSBMZWdhY3lVbmJhdGNoZWRDb250ZXh0O1xuXG4gIHRyeSB7XG4gICAgcmV0dXJuIGZuKGEpO1xuICB9IGZpbmFsbHkge1xuICAgIGV4ZWN1dGlvbkNvbnRleHQgPSBwcmV2RXhlY3V0aW9uQ29udGV4dDtcblxuICAgIGlmIChleGVjdXRpb25Db250ZXh0ID09PSBOb0NvbnRleHQpIHtcbiAgICAgIC8vIEZsdXNoIHRoZSBpbW1lZGlhdGUgY2FsbGJhY2tzIHRoYXQgd2VyZSBzY2hlZHVsZWQgZHVyaW5nIHRoaXMgYmF0Y2hcbiAgICAgIHJlc2V0UmVuZGVyVGltZXIoKTtcbiAgICAgIGZsdXNoU3luY0NhbGxiYWNrUXVldWUoKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGZsdXNoU3luYyhmbiwgYSkge1xuICB2YXIgcHJldkV4ZWN1dGlvbkNvbnRleHQgPSBleGVjdXRpb25Db250ZXh0O1xuXG4gIGlmICgocHJldkV4ZWN1dGlvbkNvbnRleHQgJiAoUmVuZGVyQ29udGV4dCB8IENvbW1pdENvbnRleHQpKSAhPT0gTm9Db250ZXh0KSB7XG4gICAge1xuICAgICAgZXJyb3IoJ2ZsdXNoU3luYyB3YXMgY2FsbGVkIGZyb20gaW5zaWRlIGEgbGlmZWN5Y2xlIG1ldGhvZC4gUmVhY3QgY2Fubm90ICcgKyAnZmx1c2ggd2hlbiBSZWFjdCBpcyBhbHJlYWR5IHJlbmRlcmluZy4gQ29uc2lkZXIgbW92aW5nIHRoaXMgY2FsbCB0byAnICsgJ2Egc2NoZWR1bGVyIHRhc2sgb3IgbWljcm8gdGFzay4nKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZm4oYSk7XG4gIH1cblxuICBleGVjdXRpb25Db250ZXh0IHw9IEJhdGNoZWRDb250ZXh0O1xuXG4gIHtcbiAgICB0cnkge1xuICAgICAgaWYgKGZuKSB7XG4gICAgICAgIHJldHVybiBydW5XaXRoUHJpb3JpdHkkMShJbW1lZGlhdGVQcmlvcml0eSQxLCBmbi5iaW5kKG51bGwsIGEpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGV4ZWN1dGlvbkNvbnRleHQgPSBwcmV2RXhlY3V0aW9uQ29udGV4dDsgLy8gRmx1c2ggdGhlIGltbWVkaWF0ZSBjYWxsYmFja3MgdGhhdCB3ZXJlIHNjaGVkdWxlZCBkdXJpbmcgdGhpcyBiYXRjaC5cbiAgICAgIC8vIE5vdGUgdGhhdCB0aGlzIHdpbGwgaGFwcGVuIGV2ZW4gaWYgYmF0Y2hlZFVwZGF0ZXMgaXMgaGlnaGVyIHVwXG4gICAgICAvLyB0aGUgc3RhY2suXG5cbiAgICAgIGZsdXNoU3luY0NhbGxiYWNrUXVldWUoKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHB1c2hSZW5kZXJMYW5lcyhmaWJlciwgbGFuZXMpIHtcbiAgcHVzaChzdWJ0cmVlUmVuZGVyTGFuZXNDdXJzb3IsIHN1YnRyZWVSZW5kZXJMYW5lcywgZmliZXIpO1xuICBzdWJ0cmVlUmVuZGVyTGFuZXMgPSBtZXJnZUxhbmVzKHN1YnRyZWVSZW5kZXJMYW5lcywgbGFuZXMpO1xuICB3b3JrSW5Qcm9ncmVzc1Jvb3RJbmNsdWRlZExhbmVzID0gbWVyZ2VMYW5lcyh3b3JrSW5Qcm9ncmVzc1Jvb3RJbmNsdWRlZExhbmVzLCBsYW5lcyk7XG59XG5mdW5jdGlvbiBwb3BSZW5kZXJMYW5lcyhmaWJlcikge1xuICBzdWJ0cmVlUmVuZGVyTGFuZXMgPSBzdWJ0cmVlUmVuZGVyTGFuZXNDdXJzb3IuY3VycmVudDtcbiAgcG9wKHN1YnRyZWVSZW5kZXJMYW5lc0N1cnNvciwgZmliZXIpO1xufVxuXG5mdW5jdGlvbiBwcmVwYXJlRnJlc2hTdGFjayhyb290LCBsYW5lcykge1xuICByb290LmZpbmlzaGVkV29yayA9IG51bGw7XG4gIHJvb3QuZmluaXNoZWRMYW5lcyA9IE5vTGFuZXM7XG4gIHZhciB0aW1lb3V0SGFuZGxlID0gcm9vdC50aW1lb3V0SGFuZGxlO1xuXG4gIGlmICh0aW1lb3V0SGFuZGxlICE9PSBub1RpbWVvdXQpIHtcbiAgICAvLyBUaGUgcm9vdCBwcmV2aW91cyBzdXNwZW5kZWQgYW5kIHNjaGVkdWxlZCBhIHRpbWVvdXQgdG8gY29tbWl0IGEgZmFsbGJhY2tcbiAgICAvLyBzdGF0ZS4gTm93IHRoYXQgd2UgaGF2ZSBhZGRpdGlvbmFsIHdvcmssIGNhbmNlbCB0aGUgdGltZW91dC5cbiAgICByb290LnRpbWVvdXRIYW5kbGUgPSBub1RpbWVvdXQ7IC8vICRGbG93Rml4TWUgQ29tcGxhaW5zIG5vVGltZW91dCBpcyBub3QgYSBUaW1lb3V0SUQsIGRlc3BpdGUgdGhlIGNoZWNrIGFib3ZlXG5cbiAgICBjYW5jZWxUaW1lb3V0KHRpbWVvdXRIYW5kbGUpO1xuICB9XG5cbiAgaWYgKHdvcmtJblByb2dyZXNzICE9PSBudWxsKSB7XG4gICAgdmFyIGludGVycnVwdGVkV29yayA9IHdvcmtJblByb2dyZXNzLnJldHVybjtcblxuICAgIHdoaWxlIChpbnRlcnJ1cHRlZFdvcmsgIT09IG51bGwpIHtcbiAgICAgIHVud2luZEludGVycnVwdGVkV29yayhpbnRlcnJ1cHRlZFdvcmspO1xuICAgICAgaW50ZXJydXB0ZWRXb3JrID0gaW50ZXJydXB0ZWRXb3JrLnJldHVybjtcbiAgICB9XG4gIH1cblxuICB3b3JrSW5Qcm9ncmVzc1Jvb3QgPSByb290O1xuICB3b3JrSW5Qcm9ncmVzcyA9IGNyZWF0ZVdvcmtJblByb2dyZXNzKHJvb3QuY3VycmVudCwgbnVsbCk7XG4gIHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzID0gc3VidHJlZVJlbmRlckxhbmVzID0gd29ya0luUHJvZ3Jlc3NSb290SW5jbHVkZWRMYW5lcyA9IGxhbmVzO1xuICB3b3JrSW5Qcm9ncmVzc1Jvb3RFeGl0U3RhdHVzID0gUm9vdEluY29tcGxldGU7XG4gIHdvcmtJblByb2dyZXNzUm9vdEZhdGFsRXJyb3IgPSBudWxsO1xuICB3b3JrSW5Qcm9ncmVzc1Jvb3RTa2lwcGVkTGFuZXMgPSBOb0xhbmVzO1xuICB3b3JrSW5Qcm9ncmVzc1Jvb3RVcGRhdGVkTGFuZXMgPSBOb0xhbmVzO1xuICB3b3JrSW5Qcm9ncmVzc1Jvb3RQaW5nZWRMYW5lcyA9IE5vTGFuZXM7XG5cbiAge1xuICAgIHNwYXduZWRXb3JrRHVyaW5nUmVuZGVyID0gbnVsbDtcbiAgfVxuXG4gIHtcbiAgICBSZWFjdFN0cmljdE1vZGVXYXJuaW5ncy5kaXNjYXJkUGVuZGluZ1dhcm5pbmdzKCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaGFuZGxlRXJyb3Iocm9vdCwgdGhyb3duVmFsdWUpIHtcbiAgZG8ge1xuICAgIHZhciBlcnJvcmVkV29yayA9IHdvcmtJblByb2dyZXNzO1xuXG4gICAgdHJ5IHtcbiAgICAgIC8vIFJlc2V0IG1vZHVsZS1sZXZlbCBzdGF0ZSB0aGF0IHdhcyBzZXQgZHVyaW5nIHRoZSByZW5kZXIgcGhhc2UuXG4gICAgICByZXNldENvbnRleHREZXBlbmRlbmNpZXMoKTtcbiAgICAgIHJlc2V0SG9va3NBZnRlclRocm93KCk7XG4gICAgICByZXNldEN1cnJlbnRGaWJlcigpOyAvLyBUT0RPOiBJIGZvdW5kIGFuZCBhZGRlZCB0aGlzIG1pc3NpbmcgbGluZSB3aGlsZSBpbnZlc3RpZ2F0aW5nIGFcbiAgICAgIC8vIHNlcGFyYXRlIGlzc3VlLiBXcml0ZSBhIHJlZ3Jlc3Npb24gdGVzdCB1c2luZyBzdHJpbmcgcmVmcy5cblxuICAgICAgUmVhY3RDdXJyZW50T3duZXIkMi5jdXJyZW50ID0gbnVsbDtcblxuICAgICAgaWYgKGVycm9yZWRXb3JrID09PSBudWxsIHx8IGVycm9yZWRXb3JrLnJldHVybiA9PT0gbnVsbCkge1xuICAgICAgICAvLyBFeHBlY3RlZCB0byBiZSB3b3JraW5nIG9uIGEgbm9uLXJvb3QgZmliZXIuIFRoaXMgaXMgYSBmYXRhbCBlcnJvclxuICAgICAgICAvLyBiZWNhdXNlIHRoZXJlJ3Mgbm8gYW5jZXN0b3IgdGhhdCBjYW4gaGFuZGxlIGl0OyB0aGUgcm9vdCBpc1xuICAgICAgICAvLyBzdXBwb3NlZCB0byBjYXB0dXJlIGFsbCBlcnJvcnMgdGhhdCB3ZXJlbid0IGNhdWdodCBieSBhbiBlcnJvclxuICAgICAgICAvLyBib3VuZGFyeS5cbiAgICAgICAgd29ya0luUHJvZ3Jlc3NSb290RXhpdFN0YXR1cyA9IFJvb3RGYXRhbEVycm9yZWQ7XG4gICAgICAgIHdvcmtJblByb2dyZXNzUm9vdEZhdGFsRXJyb3IgPSB0aHJvd25WYWx1ZTsgLy8gU2V0IGB3b3JrSW5Qcm9ncmVzc2AgdG8gbnVsbC4gVGhpcyByZXByZXNlbnRzIGFkdmFuY2luZyB0byB0aGUgbmV4dFxuICAgICAgICAvLyBzaWJsaW5nLCBvciB0aGUgcGFyZW50IGlmIHRoZXJlIGFyZSBubyBzaWJsaW5ncy4gQnV0IHNpbmNlIHRoZSByb290XG4gICAgICAgIC8vIGhhcyBubyBzaWJsaW5ncyBub3IgYSBwYXJlbnQsIHdlIHNldCBpdCB0byBudWxsLiBVc3VhbGx5IHRoaXMgaXNcbiAgICAgICAgLy8gaGFuZGxlZCBieSBgY29tcGxldGVVbml0T2ZXb3JrYCBvciBgdW53aW5kV29ya2AsIGJ1dCBzaW5jZSB3ZSdyZVxuICAgICAgICAvLyBpbnRlbnRpb25hbGx5IG5vdCBjYWxsaW5nIHRob3NlLCB3ZSBuZWVkIHNldCBpdCBoZXJlLlxuICAgICAgICAvLyBUT0RPOiBDb25zaWRlciBjYWxsaW5nIGB1bndpbmRXb3JrYCB0byBwb3AgdGhlIGNvbnRleHRzLlxuXG4gICAgICAgIHdvcmtJblByb2dyZXNzID0gbnVsbDtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoZW5hYmxlUHJvZmlsZXJUaW1lciAmJiBlcnJvcmVkV29yay5tb2RlICYgUHJvZmlsZU1vZGUpIHtcbiAgICAgICAgLy8gUmVjb3JkIHRoZSB0aW1lIHNwZW50IHJlbmRlcmluZyBiZWZvcmUgYW4gZXJyb3Igd2FzIHRocm93bi4gVGhpc1xuICAgICAgICAvLyBhdm9pZHMgaW5hY2N1cmF0ZSBQcm9maWxlciBkdXJhdGlvbnMgaW4gdGhlIGNhc2Ugb2YgYVxuICAgICAgICAvLyBzdXNwZW5kZWQgcmVuZGVyLlxuICAgICAgICBzdG9wUHJvZmlsZXJUaW1lcklmUnVubmluZ0FuZFJlY29yZERlbHRhKGVycm9yZWRXb3JrLCB0cnVlKTtcbiAgICAgIH1cblxuICAgICAgdGhyb3dFeGNlcHRpb24ocm9vdCwgZXJyb3JlZFdvcmsucmV0dXJuLCBlcnJvcmVkV29yaywgdGhyb3duVmFsdWUsIHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzKTtcbiAgICAgIGNvbXBsZXRlVW5pdE9mV29yayhlcnJvcmVkV29yayk7XG4gICAgfSBjYXRjaCAoeWV0QW5vdGhlclRocm93blZhbHVlKSB7XG4gICAgICAvLyBTb21ldGhpbmcgaW4gdGhlIHJldHVybiBwYXRoIGFsc28gdGhyZXcuXG4gICAgICB0aHJvd25WYWx1ZSA9IHlldEFub3RoZXJUaHJvd25WYWx1ZTtcblxuICAgICAgaWYgKHdvcmtJblByb2dyZXNzID09PSBlcnJvcmVkV29yayAmJiBlcnJvcmVkV29yayAhPT0gbnVsbCkge1xuICAgICAgICAvLyBJZiB0aGlzIGJvdW5kYXJ5IGhhcyBhbHJlYWR5IGVycm9yZWQsIHRoZW4gd2UgaGFkIHRyb3VibGUgcHJvY2Vzc2luZ1xuICAgICAgICAvLyB0aGUgZXJyb3IuIEJ1YmJsZSBpdCB0byB0aGUgbmV4dCBib3VuZGFyeS5cbiAgICAgICAgZXJyb3JlZFdvcmsgPSBlcnJvcmVkV29yay5yZXR1cm47XG4gICAgICAgIHdvcmtJblByb2dyZXNzID0gZXJyb3JlZFdvcms7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlcnJvcmVkV29yayA9IHdvcmtJblByb2dyZXNzO1xuICAgICAgfVxuXG4gICAgICBjb250aW51ZTtcbiAgICB9IC8vIFJldHVybiB0byB0aGUgbm9ybWFsIHdvcmsgbG9vcC5cblxuXG4gICAgcmV0dXJuO1xuICB9IHdoaWxlICh0cnVlKTtcbn1cblxuZnVuY3Rpb24gcHVzaERpc3BhdGNoZXIoKSB7XG4gIHZhciBwcmV2RGlzcGF0Y2hlciA9IFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMi5jdXJyZW50O1xuICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDIuY3VycmVudCA9IENvbnRleHRPbmx5RGlzcGF0Y2hlcjtcblxuICBpZiAocHJldkRpc3BhdGNoZXIgPT09IG51bGwpIHtcbiAgICAvLyBUaGUgUmVhY3QgaXNvbW9ycGhpYyBwYWNrYWdlIGRvZXMgbm90IGluY2x1ZGUgYSBkZWZhdWx0IGRpc3BhdGNoZXIuXG4gICAgLy8gSW5zdGVhZCB0aGUgZmlyc3QgcmVuZGVyZXIgd2lsbCBsYXppbHkgYXR0YWNoIG9uZSwgaW4gb3JkZXIgdG8gZ2l2ZVxuICAgIC8vIG5pY2VyIGVycm9yIG1lc3NhZ2VzLlxuICAgIHJldHVybiBDb250ZXh0T25seURpc3BhdGNoZXI7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHByZXZEaXNwYXRjaGVyO1xuICB9XG59XG5cbmZ1bmN0aW9uIHBvcERpc3BhdGNoZXIocHJldkRpc3BhdGNoZXIpIHtcbiAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQyLmN1cnJlbnQgPSBwcmV2RGlzcGF0Y2hlcjtcbn1cblxuZnVuY3Rpb24gcHVzaEludGVyYWN0aW9ucyhyb290KSB7XG4gIHtcbiAgICB2YXIgcHJldkludGVyYWN0aW9ucyA9IHRyYWNpbmcuX19pbnRlcmFjdGlvbnNSZWYuY3VycmVudDtcbiAgICB0cmFjaW5nLl9faW50ZXJhY3Rpb25zUmVmLmN1cnJlbnQgPSByb290Lm1lbW9pemVkSW50ZXJhY3Rpb25zO1xuICAgIHJldHVybiBwcmV2SW50ZXJhY3Rpb25zO1xuICB9XG59XG5cbmZ1bmN0aW9uIHBvcEludGVyYWN0aW9ucyhwcmV2SW50ZXJhY3Rpb25zKSB7XG4gIHtcbiAgICB0cmFjaW5nLl9faW50ZXJhY3Rpb25zUmVmLmN1cnJlbnQgPSBwcmV2SW50ZXJhY3Rpb25zO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1hcmtDb21taXRUaW1lT2ZGYWxsYmFjaygpIHtcbiAgZ2xvYmFsTW9zdFJlY2VudEZhbGxiYWNrVGltZSA9IG5vdygpO1xufVxuZnVuY3Rpb24gbWFya1NraXBwZWRVcGRhdGVMYW5lcyhsYW5lKSB7XG4gIHdvcmtJblByb2dyZXNzUm9vdFNraXBwZWRMYW5lcyA9IG1lcmdlTGFuZXMobGFuZSwgd29ya0luUHJvZ3Jlc3NSb290U2tpcHBlZExhbmVzKTtcbn1cbmZ1bmN0aW9uIHJlbmRlckRpZFN1c3BlbmQoKSB7XG4gIGlmICh3b3JrSW5Qcm9ncmVzc1Jvb3RFeGl0U3RhdHVzID09PSBSb290SW5jb21wbGV0ZSkge1xuICAgIHdvcmtJblByb2dyZXNzUm9vdEV4aXRTdGF0dXMgPSBSb290U3VzcGVuZGVkO1xuICB9XG59XG5mdW5jdGlvbiByZW5kZXJEaWRTdXNwZW5kRGVsYXlJZlBvc3NpYmxlKCkge1xuICBpZiAod29ya0luUHJvZ3Jlc3NSb290RXhpdFN0YXR1cyA9PT0gUm9vdEluY29tcGxldGUgfHwgd29ya0luUHJvZ3Jlc3NSb290RXhpdFN0YXR1cyA9PT0gUm9vdFN1c3BlbmRlZCkge1xuICAgIHdvcmtJblByb2dyZXNzUm9vdEV4aXRTdGF0dXMgPSBSb290U3VzcGVuZGVkV2l0aERlbGF5O1xuICB9IC8vIENoZWNrIGlmIHRoZXJlIGFyZSB1cGRhdGVzIHRoYXQgd2Ugc2tpcHBlZCB0cmVlIHRoYXQgbWlnaHQgaGF2ZSB1bmJsb2NrZWRcbiAgLy8gdGhpcyByZW5kZXIuXG5cblxuICBpZiAod29ya0luUHJvZ3Jlc3NSb290ICE9PSBudWxsICYmIChpbmNsdWRlc05vbklkbGVXb3JrKHdvcmtJblByb2dyZXNzUm9vdFNraXBwZWRMYW5lcykgfHwgaW5jbHVkZXNOb25JZGxlV29yayh3b3JrSW5Qcm9ncmVzc1Jvb3RVcGRhdGVkTGFuZXMpKSkge1xuICAgIC8vIE1hcmsgdGhlIGN1cnJlbnQgcmVuZGVyIGFzIHN1c3BlbmRlZCBzbyB0aGF0IHdlIHN3aXRjaCB0byB3b3JraW5nIG9uXG4gICAgLy8gdGhlIHVwZGF0ZXMgdGhhdCB3ZXJlIHNraXBwZWQuIFVzdWFsbHkgd2Ugb25seSBzdXNwZW5kIGF0IHRoZSBlbmQgb2ZcbiAgICAvLyB0aGUgcmVuZGVyIHBoYXNlLlxuICAgIC8vIFRPRE86IFdlIHNob3VsZCBwcm9iYWJseSBhbHdheXMgbWFyayB0aGUgcm9vdCBhcyBzdXNwZW5kZWQgaW1tZWRpYXRlbHlcbiAgICAvLyAoaW5zaWRlIHRoaXMgZnVuY3Rpb24pLCBzaW5jZSBieSBzdXNwZW5kaW5nIGF0IHRoZSBlbmQgb2YgdGhlIHJlbmRlclxuICAgIC8vIHBoYXNlIGludHJvZHVjZXMgYSBwb3RlbnRpYWwgbWlzdGFrZSB3aGVyZSB3ZSBzdXNwZW5kIGxhbmVzIHRoYXQgd2VyZVxuICAgIC8vIHBpbmdlZCBvciB1cGRhdGVkIHdoaWxlIHdlIHdlcmUgcmVuZGVyaW5nLlxuICAgIG1hcmtSb290U3VzcGVuZGVkJDEod29ya0luUHJvZ3Jlc3NSb290LCB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyk7XG4gIH1cbn1cbmZ1bmN0aW9uIHJlbmRlckRpZEVycm9yKCkge1xuICBpZiAod29ya0luUHJvZ3Jlc3NSb290RXhpdFN0YXR1cyAhPT0gUm9vdENvbXBsZXRlZCkge1xuICAgIHdvcmtJblByb2dyZXNzUm9vdEV4aXRTdGF0dXMgPSBSb290RXJyb3JlZDtcbiAgfVxufSAvLyBDYWxsZWQgZHVyaW5nIHJlbmRlciB0byBkZXRlcm1pbmUgaWYgYW55dGhpbmcgaGFzIHN1c3BlbmRlZC5cbi8vIFJldHVybnMgZmFsc2UgaWYgd2UncmUgbm90IHN1cmUuXG5cbmZ1bmN0aW9uIHJlbmRlckhhc05vdFN1c3BlbmRlZFlldCgpIHtcbiAgLy8gSWYgc29tZXRoaW5nIGVycm9yZWQgb3IgY29tcGxldGVkLCB3ZSBjYW4ndCByZWFsbHkgYmUgc3VyZSxcbiAgLy8gc28gdGhvc2UgYXJlIGZhbHNlLlxuICByZXR1cm4gd29ya0luUHJvZ3Jlc3NSb290RXhpdFN0YXR1cyA9PT0gUm9vdEluY29tcGxldGU7XG59XG5cbmZ1bmN0aW9uIHJlbmRlclJvb3RTeW5jKHJvb3QsIGxhbmVzKSB7XG4gIHZhciBwcmV2RXhlY3V0aW9uQ29udGV4dCA9IGV4ZWN1dGlvbkNvbnRleHQ7XG4gIGV4ZWN1dGlvbkNvbnRleHQgfD0gUmVuZGVyQ29udGV4dDtcbiAgdmFyIHByZXZEaXNwYXRjaGVyID0gcHVzaERpc3BhdGNoZXIoKTsgLy8gSWYgdGhlIHJvb3Qgb3IgbGFuZXMgaGF2ZSBjaGFuZ2VkLCB0aHJvdyBvdXQgdGhlIGV4aXN0aW5nIHN0YWNrXG4gIC8vIGFuZCBwcmVwYXJlIGEgZnJlc2ggb25lLiBPdGhlcndpc2Ugd2UnbGwgY29udGludWUgd2hlcmUgd2UgbGVmdCBvZmYuXG5cbiAgaWYgKHdvcmtJblByb2dyZXNzUm9vdCAhPT0gcm9vdCB8fCB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyAhPT0gbGFuZXMpIHtcbiAgICBwcmVwYXJlRnJlc2hTdGFjayhyb290LCBsYW5lcyk7XG4gICAgc3RhcnRXb3JrT25QZW5kaW5nSW50ZXJhY3Rpb25zKHJvb3QsIGxhbmVzKTtcbiAgfVxuXG4gIHZhciBwcmV2SW50ZXJhY3Rpb25zID0gcHVzaEludGVyYWN0aW9ucyhyb290KTtcblxuICBkbyB7XG4gICAgdHJ5IHtcbiAgICAgIHdvcmtMb29wU3luYygpO1xuICAgICAgYnJlYWs7XG4gICAgfSBjYXRjaCAodGhyb3duVmFsdWUpIHtcbiAgICAgIGhhbmRsZUVycm9yKHJvb3QsIHRocm93blZhbHVlKTtcbiAgICB9XG4gIH0gd2hpbGUgKHRydWUpO1xuXG4gIHJlc2V0Q29udGV4dERlcGVuZGVuY2llcygpO1xuXG4gIHtcbiAgICBwb3BJbnRlcmFjdGlvbnMocHJldkludGVyYWN0aW9ucyk7XG4gIH1cblxuICBleGVjdXRpb25Db250ZXh0ID0gcHJldkV4ZWN1dGlvbkNvbnRleHQ7XG4gIHBvcERpc3BhdGNoZXIocHJldkRpc3BhdGNoZXIpO1xuXG4gIGlmICh3b3JrSW5Qcm9ncmVzcyAhPT0gbnVsbCkge1xuICAgIC8vIFRoaXMgaXMgYSBzeW5jIHJlbmRlciwgc28gd2Ugc2hvdWxkIGhhdmUgZmluaXNoZWQgdGhlIHdob2xlIHRyZWUuXG4gICAge1xuICAgICAge1xuICAgICAgICB0aHJvdyBFcnJvciggXCJDYW5ub3QgY29tbWl0IGFuIGluY29tcGxldGUgcm9vdC4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS5cIiApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG5cbiAgd29ya0luUHJvZ3Jlc3NSb290ID0gbnVsbDtcbiAgd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMgPSBOb0xhbmVzO1xuICByZXR1cm4gd29ya0luUHJvZ3Jlc3NSb290RXhpdFN0YXR1cztcbn0gLy8gVGhlIHdvcmsgbG9vcCBpcyBhbiBleHRyZW1lbHkgaG90IHBhdGguIFRlbGwgQ2xvc3VyZSBub3QgdG8gaW5saW5lIGl0LlxuXG4vKiogQG5vaW5saW5lICovXG5cblxuZnVuY3Rpb24gd29ya0xvb3BTeW5jKCkge1xuICAvLyBBbHJlYWR5IHRpbWVkIG91dCwgc28gcGVyZm9ybSB3b3JrIHdpdGhvdXQgY2hlY2tpbmcgaWYgd2UgbmVlZCB0byB5aWVsZC5cbiAgd2hpbGUgKHdvcmtJblByb2dyZXNzICE9PSBudWxsKSB7XG4gICAgcGVyZm9ybVVuaXRPZldvcmsod29ya0luUHJvZ3Jlc3MpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlbmRlclJvb3RDb25jdXJyZW50KHJvb3QsIGxhbmVzKSB7XG4gIHZhciBwcmV2RXhlY3V0aW9uQ29udGV4dCA9IGV4ZWN1dGlvbkNvbnRleHQ7XG4gIGV4ZWN1dGlvbkNvbnRleHQgfD0gUmVuZGVyQ29udGV4dDtcbiAgdmFyIHByZXZEaXNwYXRjaGVyID0gcHVzaERpc3BhdGNoZXIoKTsgLy8gSWYgdGhlIHJvb3Qgb3IgbGFuZXMgaGF2ZSBjaGFuZ2VkLCB0aHJvdyBvdXQgdGhlIGV4aXN0aW5nIHN0YWNrXG4gIC8vIGFuZCBwcmVwYXJlIGEgZnJlc2ggb25lLiBPdGhlcndpc2Ugd2UnbGwgY29udGludWUgd2hlcmUgd2UgbGVmdCBvZmYuXG5cbiAgaWYgKHdvcmtJblByb2dyZXNzUm9vdCAhPT0gcm9vdCB8fCB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyAhPT0gbGFuZXMpIHtcbiAgICByZXNldFJlbmRlclRpbWVyKCk7XG4gICAgcHJlcGFyZUZyZXNoU3RhY2socm9vdCwgbGFuZXMpO1xuICAgIHN0YXJ0V29ya09uUGVuZGluZ0ludGVyYWN0aW9ucyhyb290LCBsYW5lcyk7XG4gIH1cblxuICB2YXIgcHJldkludGVyYWN0aW9ucyA9IHB1c2hJbnRlcmFjdGlvbnMocm9vdCk7XG5cbiAgZG8ge1xuICAgIHRyeSB7XG4gICAgICB3b3JrTG9vcENvbmN1cnJlbnQoKTtcbiAgICAgIGJyZWFrO1xuICAgIH0gY2F0Y2ggKHRocm93blZhbHVlKSB7XG4gICAgICBoYW5kbGVFcnJvcihyb290LCB0aHJvd25WYWx1ZSk7XG4gICAgfVxuICB9IHdoaWxlICh0cnVlKTtcblxuICByZXNldENvbnRleHREZXBlbmRlbmNpZXMoKTtcblxuICB7XG4gICAgcG9wSW50ZXJhY3Rpb25zKHByZXZJbnRlcmFjdGlvbnMpO1xuICB9XG5cbiAgcG9wRGlzcGF0Y2hlcihwcmV2RGlzcGF0Y2hlcik7XG4gIGV4ZWN1dGlvbkNvbnRleHQgPSBwcmV2RXhlY3V0aW9uQ29udGV4dDtcblxuXG4gIGlmICh3b3JrSW5Qcm9ncmVzcyAhPT0gbnVsbCkge1xuXG4gICAgcmV0dXJuIFJvb3RJbmNvbXBsZXRlO1xuICB9IGVsc2Uge1xuXG5cbiAgICB3b3JrSW5Qcm9ncmVzc1Jvb3QgPSBudWxsO1xuICAgIHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzID0gTm9MYW5lczsgLy8gUmV0dXJuIHRoZSBmaW5hbCBleGl0IHN0YXR1cy5cblxuICAgIHJldHVybiB3b3JrSW5Qcm9ncmVzc1Jvb3RFeGl0U3RhdHVzO1xuICB9XG59XG4vKiogQG5vaW5saW5lICovXG5cblxuZnVuY3Rpb24gd29ya0xvb3BDb25jdXJyZW50KCkge1xuICAvLyBQZXJmb3JtIHdvcmsgdW50aWwgU2NoZWR1bGVyIGFza3MgdXMgdG8geWllbGRcbiAgd2hpbGUgKHdvcmtJblByb2dyZXNzICE9PSBudWxsICYmICFzaG91bGRZaWVsZCgpKSB7XG4gICAgcGVyZm9ybVVuaXRPZldvcmsod29ya0luUHJvZ3Jlc3MpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHBlcmZvcm1Vbml0T2ZXb3JrKHVuaXRPZldvcmspIHtcbiAgLy8gVGhlIGN1cnJlbnQsIGZsdXNoZWQsIHN0YXRlIG9mIHRoaXMgZmliZXIgaXMgdGhlIGFsdGVybmF0ZS4gSWRlYWxseVxuICAvLyBub3RoaW5nIHNob3VsZCByZWx5IG9uIHRoaXMsIGJ1dCByZWx5aW5nIG9uIGl0IGhlcmUgbWVhbnMgdGhhdCB3ZSBkb24ndFxuICAvLyBuZWVkIGFuIGFkZGl0aW9uYWwgZmllbGQgb24gdGhlIHdvcmsgaW4gcHJvZ3Jlc3MuXG4gIHZhciBjdXJyZW50ID0gdW5pdE9mV29yay5hbHRlcm5hdGU7XG4gIHNldEN1cnJlbnRGaWJlcih1bml0T2ZXb3JrKTtcbiAgdmFyIG5leHQ7XG5cbiAgaWYgKCAodW5pdE9mV29yay5tb2RlICYgUHJvZmlsZU1vZGUpICE9PSBOb01vZGUpIHtcbiAgICBzdGFydFByb2ZpbGVyVGltZXIodW5pdE9mV29yayk7XG4gICAgbmV4dCA9IGJlZ2luV29yayQxKGN1cnJlbnQsIHVuaXRPZldvcmssIHN1YnRyZWVSZW5kZXJMYW5lcyk7XG4gICAgc3RvcFByb2ZpbGVyVGltZXJJZlJ1bm5pbmdBbmRSZWNvcmREZWx0YSh1bml0T2ZXb3JrLCB0cnVlKTtcbiAgfSBlbHNlIHtcbiAgICBuZXh0ID0gYmVnaW5Xb3JrJDEoY3VycmVudCwgdW5pdE9mV29yaywgc3VidHJlZVJlbmRlckxhbmVzKTtcbiAgfVxuXG4gIHJlc2V0Q3VycmVudEZpYmVyKCk7XG4gIHVuaXRPZldvcmsubWVtb2l6ZWRQcm9wcyA9IHVuaXRPZldvcmsucGVuZGluZ1Byb3BzO1xuXG4gIGlmIChuZXh0ID09PSBudWxsKSB7XG4gICAgLy8gSWYgdGhpcyBkb2Vzbid0IHNwYXduIG5ldyB3b3JrLCBjb21wbGV0ZSB0aGUgY3VycmVudCB3b3JrLlxuICAgIGNvbXBsZXRlVW5pdE9mV29yayh1bml0T2ZXb3JrKTtcbiAgfSBlbHNlIHtcbiAgICB3b3JrSW5Qcm9ncmVzcyA9IG5leHQ7XG4gIH1cblxuICBSZWFjdEN1cnJlbnRPd25lciQyLmN1cnJlbnQgPSBudWxsO1xufVxuXG5mdW5jdGlvbiBjb21wbGV0ZVVuaXRPZldvcmsodW5pdE9mV29yaykge1xuICAvLyBBdHRlbXB0IHRvIGNvbXBsZXRlIHRoZSBjdXJyZW50IHVuaXQgb2Ygd29yaywgdGhlbiBtb3ZlIHRvIHRoZSBuZXh0XG4gIC8vIHNpYmxpbmcuIElmIHRoZXJlIGFyZSBubyBtb3JlIHNpYmxpbmdzLCByZXR1cm4gdG8gdGhlIHBhcmVudCBmaWJlci5cbiAgdmFyIGNvbXBsZXRlZFdvcmsgPSB1bml0T2ZXb3JrO1xuXG4gIGRvIHtcbiAgICAvLyBUaGUgY3VycmVudCwgZmx1c2hlZCwgc3RhdGUgb2YgdGhpcyBmaWJlciBpcyB0aGUgYWx0ZXJuYXRlLiBJZGVhbGx5XG4gICAgLy8gbm90aGluZyBzaG91bGQgcmVseSBvbiB0aGlzLCBidXQgcmVseWluZyBvbiBpdCBoZXJlIG1lYW5zIHRoYXQgd2UgZG9uJ3RcbiAgICAvLyBuZWVkIGFuIGFkZGl0aW9uYWwgZmllbGQgb24gdGhlIHdvcmsgaW4gcHJvZ3Jlc3MuXG4gICAgdmFyIGN1cnJlbnQgPSBjb21wbGV0ZWRXb3JrLmFsdGVybmF0ZTtcbiAgICB2YXIgcmV0dXJuRmliZXIgPSBjb21wbGV0ZWRXb3JrLnJldHVybjsgLy8gQ2hlY2sgaWYgdGhlIHdvcmsgY29tcGxldGVkIG9yIGlmIHNvbWV0aGluZyB0aHJldy5cblxuICAgIGlmICgoY29tcGxldGVkV29yay5mbGFncyAmIEluY29tcGxldGUpID09PSBOb0ZsYWdzKSB7XG4gICAgICBzZXRDdXJyZW50RmliZXIoY29tcGxldGVkV29yayk7XG4gICAgICB2YXIgbmV4dCA9IHZvaWQgMDtcblxuICAgICAgaWYgKCAoY29tcGxldGVkV29yay5tb2RlICYgUHJvZmlsZU1vZGUpID09PSBOb01vZGUpIHtcbiAgICAgICAgbmV4dCA9IGNvbXBsZXRlV29yayhjdXJyZW50LCBjb21wbGV0ZWRXb3JrLCBzdWJ0cmVlUmVuZGVyTGFuZXMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhcnRQcm9maWxlclRpbWVyKGNvbXBsZXRlZFdvcmspO1xuICAgICAgICBuZXh0ID0gY29tcGxldGVXb3JrKGN1cnJlbnQsIGNvbXBsZXRlZFdvcmssIHN1YnRyZWVSZW5kZXJMYW5lcyk7IC8vIFVwZGF0ZSByZW5kZXIgZHVyYXRpb24gYXNzdW1pbmcgd2UgZGlkbid0IGVycm9yLlxuXG4gICAgICAgIHN0b3BQcm9maWxlclRpbWVySWZSdW5uaW5nQW5kUmVjb3JkRGVsdGEoY29tcGxldGVkV29yaywgZmFsc2UpO1xuICAgICAgfVxuXG4gICAgICByZXNldEN1cnJlbnRGaWJlcigpO1xuXG4gICAgICBpZiAobmV4dCAhPT0gbnVsbCkge1xuICAgICAgICAvLyBDb21wbGV0aW5nIHRoaXMgZmliZXIgc3Bhd25lZCBuZXcgd29yay4gV29yayBvbiB0aGF0IG5leHQuXG4gICAgICAgIHdvcmtJblByb2dyZXNzID0gbmV4dDtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICByZXNldENoaWxkTGFuZXMoY29tcGxldGVkV29yayk7XG5cbiAgICAgIGlmIChyZXR1cm5GaWJlciAhPT0gbnVsbCAmJiAvLyBEbyBub3QgYXBwZW5kIGVmZmVjdHMgdG8gcGFyZW50cyBpZiBhIHNpYmxpbmcgZmFpbGVkIHRvIGNvbXBsZXRlXG4gICAgICAocmV0dXJuRmliZXIuZmxhZ3MgJiBJbmNvbXBsZXRlKSA9PT0gTm9GbGFncykge1xuICAgICAgICAvLyBBcHBlbmQgYWxsIHRoZSBlZmZlY3RzIG9mIHRoZSBzdWJ0cmVlIGFuZCB0aGlzIGZpYmVyIG9udG8gdGhlIGVmZmVjdFxuICAgICAgICAvLyBsaXN0IG9mIHRoZSBwYXJlbnQuIFRoZSBjb21wbGV0aW9uIG9yZGVyIG9mIHRoZSBjaGlsZHJlbiBhZmZlY3RzIHRoZVxuICAgICAgICAvLyBzaWRlLWVmZmVjdCBvcmRlci5cbiAgICAgICAgaWYgKHJldHVybkZpYmVyLmZpcnN0RWZmZWN0ID09PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuRmliZXIuZmlyc3RFZmZlY3QgPSBjb21wbGV0ZWRXb3JrLmZpcnN0RWZmZWN0O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNvbXBsZXRlZFdvcmsubGFzdEVmZmVjdCAhPT0gbnVsbCkge1xuICAgICAgICAgIGlmIChyZXR1cm5GaWJlci5sYXN0RWZmZWN0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm5GaWJlci5sYXN0RWZmZWN0Lm5leHRFZmZlY3QgPSBjb21wbGV0ZWRXb3JrLmZpcnN0RWZmZWN0O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybkZpYmVyLmxhc3RFZmZlY3QgPSBjb21wbGV0ZWRXb3JrLmxhc3RFZmZlY3Q7XG4gICAgICAgIH0gLy8gSWYgdGhpcyBmaWJlciBoYWQgc2lkZS1lZmZlY3RzLCB3ZSBhcHBlbmQgaXQgQUZURVIgdGhlIGNoaWxkcmVuJ3NcbiAgICAgICAgLy8gc2lkZS1lZmZlY3RzLiBXZSBjYW4gcGVyZm9ybSBjZXJ0YWluIHNpZGUtZWZmZWN0cyBlYXJsaWVyIGlmIG5lZWRlZCxcbiAgICAgICAgLy8gYnkgZG9pbmcgbXVsdGlwbGUgcGFzc2VzIG92ZXIgdGhlIGVmZmVjdCBsaXN0LiBXZSBkb24ndCB3YW50IHRvXG4gICAgICAgIC8vIHNjaGVkdWxlIG91ciBvd24gc2lkZS1lZmZlY3Qgb24gb3VyIG93biBsaXN0IGJlY2F1c2UgaWYgZW5kIHVwXG4gICAgICAgIC8vIHJldXNpbmcgY2hpbGRyZW4gd2UnbGwgc2NoZWR1bGUgdGhpcyBlZmZlY3Qgb250byBpdHNlbGYgc2luY2Ugd2UncmVcbiAgICAgICAgLy8gYXQgdGhlIGVuZC5cblxuXG4gICAgICAgIHZhciBmbGFncyA9IGNvbXBsZXRlZFdvcmsuZmxhZ3M7IC8vIFNraXAgYm90aCBOb1dvcmsgYW5kIFBlcmZvcm1lZFdvcmsgdGFncyB3aGVuIGNyZWF0aW5nIHRoZSBlZmZlY3RcbiAgICAgICAgLy8gbGlzdC4gUGVyZm9ybWVkV29yayBlZmZlY3QgaXMgcmVhZCBieSBSZWFjdCBEZXZUb29scyBidXQgc2hvdWxkbid0IGJlXG4gICAgICAgIC8vIGNvbW1pdHRlZC5cblxuICAgICAgICBpZiAoZmxhZ3MgPiBQZXJmb3JtZWRXb3JrKSB7XG4gICAgICAgICAgaWYgKHJldHVybkZpYmVyLmxhc3RFZmZlY3QgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybkZpYmVyLmxhc3RFZmZlY3QubmV4dEVmZmVjdCA9IGNvbXBsZXRlZFdvcms7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybkZpYmVyLmZpcnN0RWZmZWN0ID0gY29tcGxldGVkV29yaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm5GaWJlci5sYXN0RWZmZWN0ID0gY29tcGxldGVkV29yaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUaGlzIGZpYmVyIGRpZCBub3QgY29tcGxldGUgYmVjYXVzZSBzb21ldGhpbmcgdGhyZXcuIFBvcCB2YWx1ZXMgb2ZmXG4gICAgICAvLyB0aGUgc3RhY2sgd2l0aG91dCBlbnRlcmluZyB0aGUgY29tcGxldGUgcGhhc2UuIElmIHRoaXMgaXMgYSBib3VuZGFyeSxcbiAgICAgIC8vIGNhcHR1cmUgdmFsdWVzIGlmIHBvc3NpYmxlLlxuICAgICAgdmFyIF9uZXh0ID0gdW53aW5kV29yayhjb21wbGV0ZWRXb3JrKTsgLy8gQmVjYXVzZSB0aGlzIGZpYmVyIGRpZCBub3QgY29tcGxldGUsIGRvbid0IHJlc2V0IGl0cyBleHBpcmF0aW9uIHRpbWUuXG5cblxuICAgICAgaWYgKF9uZXh0ICE9PSBudWxsKSB7XG4gICAgICAgIC8vIElmIGNvbXBsZXRpbmcgdGhpcyB3b3JrIHNwYXduZWQgbmV3IHdvcmssIGRvIHRoYXQgbmV4dC4gV2UnbGwgY29tZVxuICAgICAgICAvLyBiYWNrIGhlcmUgYWdhaW4uXG4gICAgICAgIC8vIFNpbmNlIHdlJ3JlIHJlc3RhcnRpbmcsIHJlbW92ZSBhbnl0aGluZyB0aGF0IGlzIG5vdCBhIGhvc3QgZWZmZWN0XG4gICAgICAgIC8vIGZyb20gdGhlIGVmZmVjdCB0YWcuXG4gICAgICAgIF9uZXh0LmZsYWdzICY9IEhvc3RFZmZlY3RNYXNrO1xuICAgICAgICB3b3JrSW5Qcm9ncmVzcyA9IF9uZXh0O1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICggKGNvbXBsZXRlZFdvcmsubW9kZSAmIFByb2ZpbGVNb2RlKSAhPT0gTm9Nb2RlKSB7XG4gICAgICAgIC8vIFJlY29yZCB0aGUgcmVuZGVyIGR1cmF0aW9uIGZvciB0aGUgZmliZXIgdGhhdCBlcnJvcmVkLlxuICAgICAgICBzdG9wUHJvZmlsZXJUaW1lcklmUnVubmluZ0FuZFJlY29yZERlbHRhKGNvbXBsZXRlZFdvcmssIGZhbHNlKTsgLy8gSW5jbHVkZSB0aGUgdGltZSBzcGVudCB3b3JraW5nIG9uIGZhaWxlZCBjaGlsZHJlbiBiZWZvcmUgY29udGludWluZy5cblxuICAgICAgICB2YXIgYWN0dWFsRHVyYXRpb24gPSBjb21wbGV0ZWRXb3JrLmFjdHVhbER1cmF0aW9uO1xuICAgICAgICB2YXIgY2hpbGQgPSBjb21wbGV0ZWRXb3JrLmNoaWxkO1xuXG4gICAgICAgIHdoaWxlIChjaGlsZCAhPT0gbnVsbCkge1xuICAgICAgICAgIGFjdHVhbER1cmF0aW9uICs9IGNoaWxkLmFjdHVhbER1cmF0aW9uO1xuICAgICAgICAgIGNoaWxkID0gY2hpbGQuc2libGluZztcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbXBsZXRlZFdvcmsuYWN0dWFsRHVyYXRpb24gPSBhY3R1YWxEdXJhdGlvbjtcbiAgICAgIH1cblxuICAgICAgaWYgKHJldHVybkZpYmVyICE9PSBudWxsKSB7XG4gICAgICAgIC8vIE1hcmsgdGhlIHBhcmVudCBmaWJlciBhcyBpbmNvbXBsZXRlIGFuZCBjbGVhciBpdHMgZWZmZWN0IGxpc3QuXG4gICAgICAgIHJldHVybkZpYmVyLmZpcnN0RWZmZWN0ID0gcmV0dXJuRmliZXIubGFzdEVmZmVjdCA9IG51bGw7XG4gICAgICAgIHJldHVybkZpYmVyLmZsYWdzIHw9IEluY29tcGxldGU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHNpYmxpbmdGaWJlciA9IGNvbXBsZXRlZFdvcmsuc2libGluZztcblxuICAgIGlmIChzaWJsaW5nRmliZXIgIT09IG51bGwpIHtcbiAgICAgIC8vIElmIHRoZXJlIGlzIG1vcmUgd29yayB0byBkbyBpbiB0aGlzIHJldHVybkZpYmVyLCBkbyB0aGF0IG5leHQuXG4gICAgICB3b3JrSW5Qcm9ncmVzcyA9IHNpYmxpbmdGaWJlcjtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIE90aGVyd2lzZSwgcmV0dXJuIHRvIHRoZSBwYXJlbnRcblxuXG4gICAgY29tcGxldGVkV29yayA9IHJldHVybkZpYmVyOyAvLyBVcGRhdGUgdGhlIG5leHQgdGhpbmcgd2UncmUgd29ya2luZyBvbiBpbiBjYXNlIHNvbWV0aGluZyB0aHJvd3MuXG5cbiAgICB3b3JrSW5Qcm9ncmVzcyA9IGNvbXBsZXRlZFdvcms7XG4gIH0gd2hpbGUgKGNvbXBsZXRlZFdvcmsgIT09IG51bGwpOyAvLyBXZSd2ZSByZWFjaGVkIHRoZSByb290LlxuXG5cbiAgaWYgKHdvcmtJblByb2dyZXNzUm9vdEV4aXRTdGF0dXMgPT09IFJvb3RJbmNvbXBsZXRlKSB7XG4gICAgd29ya0luUHJvZ3Jlc3NSb290RXhpdFN0YXR1cyA9IFJvb3RDb21wbGV0ZWQ7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVzZXRDaGlsZExhbmVzKGNvbXBsZXRlZFdvcmspIHtcbiAgaWYgKCAvLyBUT0RPOiBNb3ZlIHRoaXMgY2hlY2sgb3V0IG9mIHRoZSBob3QgcGF0aCBieSBtb3ZpbmcgYHJlc2V0Q2hpbGRMYW5lc2BcbiAgLy8gdG8gc3dpdGNoIHN0YXRlbWVudCBpbiBgY29tcGxldGVXb3JrYC5cbiAgKGNvbXBsZXRlZFdvcmsudGFnID09PSBMZWdhY3lIaWRkZW5Db21wb25lbnQgfHwgY29tcGxldGVkV29yay50YWcgPT09IE9mZnNjcmVlbkNvbXBvbmVudCkgJiYgY29tcGxldGVkV29yay5tZW1vaXplZFN0YXRlICE9PSBudWxsICYmICFpbmNsdWRlc1NvbWVMYW5lKHN1YnRyZWVSZW5kZXJMYW5lcywgT2Zmc2NyZWVuTGFuZSkgJiYgKGNvbXBsZXRlZFdvcmsubW9kZSAmIENvbmN1cnJlbnRNb2RlKSAhPT0gTm9MYW5lcykge1xuICAgIC8vIFRoZSBjaGlsZHJlbiBvZiB0aGlzIGNvbXBvbmVudCBhcmUgaGlkZGVuLiBEb24ndCBidWJibGUgdGhlaXJcbiAgICAvLyBleHBpcmF0aW9uIHRpbWVzLlxuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBuZXdDaGlsZExhbmVzID0gTm9MYW5lczsgLy8gQnViYmxlIHVwIHRoZSBlYXJsaWVzdCBleHBpcmF0aW9uIHRpbWUuXG5cbiAgaWYgKCAoY29tcGxldGVkV29yay5tb2RlICYgUHJvZmlsZU1vZGUpICE9PSBOb01vZGUpIHtcbiAgICAvLyBJbiBwcm9maWxpbmcgbW9kZSwgcmVzZXRDaGlsZEV4cGlyYXRpb25UaW1lIGlzIGFsc28gdXNlZCB0byByZXNldFxuICAgIC8vIHByb2ZpbGVyIGR1cmF0aW9ucy5cbiAgICB2YXIgYWN0dWFsRHVyYXRpb24gPSBjb21wbGV0ZWRXb3JrLmFjdHVhbER1cmF0aW9uO1xuICAgIHZhciB0cmVlQmFzZUR1cmF0aW9uID0gY29tcGxldGVkV29yay5zZWxmQmFzZUR1cmF0aW9uOyAvLyBXaGVuIGEgZmliZXIgaXMgY2xvbmVkLCBpdHMgYWN0dWFsRHVyYXRpb24gaXMgcmVzZXQgdG8gMC4gVGhpcyB2YWx1ZSB3aWxsXG4gICAgLy8gb25seSBiZSB1cGRhdGVkIGlmIHdvcmsgaXMgZG9uZSBvbiB0aGUgZmliZXIgKGkuZS4gaXQgZG9lc24ndCBiYWlsb3V0KS5cbiAgICAvLyBXaGVuIHdvcmsgaXMgZG9uZSwgaXQgc2hvdWxkIGJ1YmJsZSB0byB0aGUgcGFyZW50J3MgYWN0dWFsRHVyYXRpb24uIElmXG4gICAgLy8gdGhlIGZpYmVyIGhhcyBub3QgYmVlbiBjbG9uZWQgdGhvdWdoLCAobWVhbmluZyBubyB3b3JrIHdhcyBkb25lKSwgdGhlblxuICAgIC8vIHRoaXMgdmFsdWUgd2lsbCByZWZsZWN0IHRoZSBhbW91bnQgb2YgdGltZSBzcGVudCB3b3JraW5nIG9uIGEgcHJldmlvdXNcbiAgICAvLyByZW5kZXIuIEluIHRoYXQgY2FzZSBpdCBzaG91bGQgbm90IGJ1YmJsZS4gV2UgZGV0ZXJtaW5lIHdoZXRoZXIgaXQgd2FzXG4gICAgLy8gY2xvbmVkIGJ5IGNvbXBhcmluZyB0aGUgY2hpbGQgcG9pbnRlci5cblxuICAgIHZhciBzaG91bGRCdWJibGVBY3R1YWxEdXJhdGlvbnMgPSBjb21wbGV0ZWRXb3JrLmFsdGVybmF0ZSA9PT0gbnVsbCB8fCBjb21wbGV0ZWRXb3JrLmNoaWxkICE9PSBjb21wbGV0ZWRXb3JrLmFsdGVybmF0ZS5jaGlsZDtcbiAgICB2YXIgY2hpbGQgPSBjb21wbGV0ZWRXb3JrLmNoaWxkO1xuXG4gICAgd2hpbGUgKGNoaWxkICE9PSBudWxsKSB7XG4gICAgICBuZXdDaGlsZExhbmVzID0gbWVyZ2VMYW5lcyhuZXdDaGlsZExhbmVzLCBtZXJnZUxhbmVzKGNoaWxkLmxhbmVzLCBjaGlsZC5jaGlsZExhbmVzKSk7XG5cbiAgICAgIGlmIChzaG91bGRCdWJibGVBY3R1YWxEdXJhdGlvbnMpIHtcbiAgICAgICAgYWN0dWFsRHVyYXRpb24gKz0gY2hpbGQuYWN0dWFsRHVyYXRpb247XG4gICAgICB9XG5cbiAgICAgIHRyZWVCYXNlRHVyYXRpb24gKz0gY2hpbGQudHJlZUJhc2VEdXJhdGlvbjtcbiAgICAgIGNoaWxkID0gY2hpbGQuc2libGluZztcbiAgICB9XG5cbiAgICB2YXIgaXNUaW1lZE91dFN1c3BlbnNlID0gY29tcGxldGVkV29yay50YWcgPT09IFN1c3BlbnNlQ29tcG9uZW50ICYmIGNvbXBsZXRlZFdvcmsubWVtb2l6ZWRTdGF0ZSAhPT0gbnVsbDtcblxuICAgIGlmIChpc1RpbWVkT3V0U3VzcGVuc2UpIHtcbiAgICAgIC8vIERvbid0IGNvdW50IHRpbWUgc3BlbnQgaW4gYSB0aW1lZCBvdXQgU3VzcGVuc2Ugc3VidHJlZSBhcyBwYXJ0IG9mIHRoZSBiYXNlIGR1cmF0aW9uLlxuICAgICAgdmFyIHByaW1hcnlDaGlsZEZyYWdtZW50ID0gY29tcGxldGVkV29yay5jaGlsZDtcblxuICAgICAgaWYgKHByaW1hcnlDaGlsZEZyYWdtZW50ICE9PSBudWxsKSB7XG4gICAgICAgIHRyZWVCYXNlRHVyYXRpb24gLT0gcHJpbWFyeUNoaWxkRnJhZ21lbnQudHJlZUJhc2VEdXJhdGlvbjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb21wbGV0ZWRXb3JrLmFjdHVhbER1cmF0aW9uID0gYWN0dWFsRHVyYXRpb247XG4gICAgY29tcGxldGVkV29yay50cmVlQmFzZUR1cmF0aW9uID0gdHJlZUJhc2VEdXJhdGlvbjtcbiAgfSBlbHNlIHtcbiAgICB2YXIgX2NoaWxkID0gY29tcGxldGVkV29yay5jaGlsZDtcblxuICAgIHdoaWxlIChfY2hpbGQgIT09IG51bGwpIHtcbiAgICAgIG5ld0NoaWxkTGFuZXMgPSBtZXJnZUxhbmVzKG5ld0NoaWxkTGFuZXMsIG1lcmdlTGFuZXMoX2NoaWxkLmxhbmVzLCBfY2hpbGQuY2hpbGRMYW5lcykpO1xuICAgICAgX2NoaWxkID0gX2NoaWxkLnNpYmxpbmc7XG4gICAgfVxuICB9XG5cbiAgY29tcGxldGVkV29yay5jaGlsZExhbmVzID0gbmV3Q2hpbGRMYW5lcztcbn1cblxuZnVuY3Rpb24gY29tbWl0Um9vdChyb290KSB7XG4gIHZhciByZW5kZXJQcmlvcml0eUxldmVsID0gZ2V0Q3VycmVudFByaW9yaXR5TGV2ZWwoKTtcbiAgcnVuV2l0aFByaW9yaXR5JDEoSW1tZWRpYXRlUHJpb3JpdHkkMSwgY29tbWl0Um9vdEltcGwuYmluZChudWxsLCByb290LCByZW5kZXJQcmlvcml0eUxldmVsKSk7XG4gIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBjb21taXRSb290SW1wbChyb290LCByZW5kZXJQcmlvcml0eUxldmVsKSB7XG4gIGRvIHtcbiAgICAvLyBgZmx1c2hQYXNzaXZlRWZmZWN0c2Agd2lsbCBjYWxsIGBmbHVzaFN5bmNVcGRhdGVRdWV1ZWAgYXQgdGhlIGVuZCwgd2hpY2hcbiAgICAvLyBtZWFucyBgZmx1c2hQYXNzaXZlRWZmZWN0c2Agd2lsbCBzb21ldGltZXMgcmVzdWx0IGluIGFkZGl0aW9uYWxcbiAgICAvLyBwYXNzaXZlIGVmZmVjdHMuIFNvIHdlIG5lZWQgdG8ga2VlcCBmbHVzaGluZyBpbiBhIGxvb3AgdW50aWwgdGhlcmUgYXJlXG4gICAgLy8gbm8gbW9yZSBwZW5kaW5nIGVmZmVjdHMuXG4gICAgLy8gVE9ETzogTWlnaHQgYmUgYmV0dGVyIGlmIGBmbHVzaFBhc3NpdmVFZmZlY3RzYCBkaWQgbm90IGF1dG9tYXRpY2FsbHlcbiAgICAvLyBmbHVzaCBzeW5jaHJvbm91cyB3b3JrIGF0IHRoZSBlbmQsIHRvIGF2b2lkIGZhY3RvcmluZyBoYXphcmRzIGxpa2UgdGhpcy5cbiAgICBmbHVzaFBhc3NpdmVFZmZlY3RzKCk7XG4gIH0gd2hpbGUgKHJvb3RXaXRoUGVuZGluZ1Bhc3NpdmVFZmZlY3RzICE9PSBudWxsKTtcblxuICBmbHVzaFJlbmRlclBoYXNlU3RyaWN0TW9kZVdhcm5pbmdzSW5ERVYoKTtcblxuICBpZiAoISgoZXhlY3V0aW9uQ29udGV4dCAmIChSZW5kZXJDb250ZXh0IHwgQ29tbWl0Q29udGV4dCkpID09PSBOb0NvbnRleHQpKSB7XG4gICAge1xuICAgICAgdGhyb3cgRXJyb3IoIFwiU2hvdWxkIG5vdCBhbHJlYWR5IGJlIHdvcmtpbmcuXCIgKTtcbiAgICB9XG4gIH1cblxuICB2YXIgZmluaXNoZWRXb3JrID0gcm9vdC5maW5pc2hlZFdvcms7XG4gIHZhciBsYW5lcyA9IHJvb3QuZmluaXNoZWRMYW5lcztcblxuICBpZiAoZmluaXNoZWRXb3JrID09PSBudWxsKSB7XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHJvb3QuZmluaXNoZWRXb3JrID0gbnVsbDtcbiAgcm9vdC5maW5pc2hlZExhbmVzID0gTm9MYW5lcztcblxuICBpZiAoIShmaW5pc2hlZFdvcmsgIT09IHJvb3QuY3VycmVudCkpIHtcbiAgICB7XG4gICAgICB0aHJvdyBFcnJvciggXCJDYW5ub3QgY29tbWl0IHRoZSBzYW1lIHRyZWUgYXMgYmVmb3JlLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiICk7XG4gICAgfVxuICB9IC8vIGNvbW1pdFJvb3QgbmV2ZXIgcmV0dXJucyBhIGNvbnRpbnVhdGlvbjsgaXQgYWx3YXlzIGZpbmlzaGVzIHN5bmNocm9ub3VzbHkuXG4gIC8vIFNvIHdlIGNhbiBjbGVhciB0aGVzZSBub3cgdG8gYWxsb3cgYSBuZXcgY2FsbGJhY2sgdG8gYmUgc2NoZWR1bGVkLlxuXG5cbiAgcm9vdC5jYWxsYmFja05vZGUgPSBudWxsOyAvLyBVcGRhdGUgdGhlIGZpcnN0IGFuZCBsYXN0IHBlbmRpbmcgdGltZXMgb24gdGhpcyByb290LiBUaGUgbmV3IGZpcnN0XG4gIC8vIHBlbmRpbmcgdGltZSBpcyB3aGF0ZXZlciBpcyBsZWZ0IG9uIHRoZSByb290IGZpYmVyLlxuXG4gIHZhciByZW1haW5pbmdMYW5lcyA9IG1lcmdlTGFuZXMoZmluaXNoZWRXb3JrLmxhbmVzLCBmaW5pc2hlZFdvcmsuY2hpbGRMYW5lcyk7XG4gIG1hcmtSb290RmluaXNoZWQocm9vdCwgcmVtYWluaW5nTGFuZXMpOyAvLyBDbGVhciBhbHJlYWR5IGZpbmlzaGVkIGRpc2NyZXRlIHVwZGF0ZXMgaW4gY2FzZSB0aGF0IGEgbGF0ZXIgY2FsbCBvZlxuICAvLyBgZmx1c2hEaXNjcmV0ZVVwZGF0ZXNgIHN0YXJ0cyBhIHVzZWxlc3MgcmVuZGVyIHBhc3Mgd2hpY2ggbWF5IGNhbmNlbHNcbiAgLy8gYSBzY2hlZHVsZWQgdGltZW91dC5cblxuICBpZiAocm9vdHNXaXRoUGVuZGluZ0Rpc2NyZXRlVXBkYXRlcyAhPT0gbnVsbCkge1xuICAgIGlmICghaGFzRGlzY3JldGVMYW5lcyhyZW1haW5pbmdMYW5lcykgJiYgcm9vdHNXaXRoUGVuZGluZ0Rpc2NyZXRlVXBkYXRlcy5oYXMocm9vdCkpIHtcbiAgICAgIHJvb3RzV2l0aFBlbmRpbmdEaXNjcmV0ZVVwZGF0ZXMuZGVsZXRlKHJvb3QpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChyb290ID09PSB3b3JrSW5Qcm9ncmVzc1Jvb3QpIHtcbiAgICAvLyBXZSBjYW4gcmVzZXQgdGhlc2Ugbm93IHRoYXQgdGhleSBhcmUgZmluaXNoZWQuXG4gICAgd29ya0luUHJvZ3Jlc3NSb290ID0gbnVsbDtcbiAgICB3b3JrSW5Qcm9ncmVzcyA9IG51bGw7XG4gICAgd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMgPSBOb0xhbmVzO1xuICB9IC8vIEdldCB0aGUgbGlzdCBvZiBlZmZlY3RzLlxuXG5cbiAgdmFyIGZpcnN0RWZmZWN0O1xuXG4gIGlmIChmaW5pc2hlZFdvcmsuZmxhZ3MgPiBQZXJmb3JtZWRXb3JrKSB7XG4gICAgLy8gQSBmaWJlcidzIGVmZmVjdCBsaXN0IGNvbnNpc3RzIG9ubHkgb2YgaXRzIGNoaWxkcmVuLCBub3QgaXRzZWxmLiBTbyBpZlxuICAgIC8vIHRoZSByb290IGhhcyBhbiBlZmZlY3QsIHdlIG5lZWQgdG8gYWRkIGl0IHRvIHRoZSBlbmQgb2YgdGhlIGxpc3QuIFRoZVxuICAgIC8vIHJlc3VsdGluZyBsaXN0IGlzIHRoZSBzZXQgdGhhdCB3b3VsZCBiZWxvbmcgdG8gdGhlIHJvb3QncyBwYXJlbnQsIGlmIGl0XG4gICAgLy8gaGFkIG9uZTsgdGhhdCBpcywgYWxsIHRoZSBlZmZlY3RzIGluIHRoZSB0cmVlIGluY2x1ZGluZyB0aGUgcm9vdC5cbiAgICBpZiAoZmluaXNoZWRXb3JrLmxhc3RFZmZlY3QgIT09IG51bGwpIHtcbiAgICAgIGZpbmlzaGVkV29yay5sYXN0RWZmZWN0Lm5leHRFZmZlY3QgPSBmaW5pc2hlZFdvcms7XG4gICAgICBmaXJzdEVmZmVjdCA9IGZpbmlzaGVkV29yay5maXJzdEVmZmVjdDtcbiAgICB9IGVsc2Uge1xuICAgICAgZmlyc3RFZmZlY3QgPSBmaW5pc2hlZFdvcms7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIFRoZXJlIGlzIG5vIGVmZmVjdCBvbiB0aGUgcm9vdC5cbiAgICBmaXJzdEVmZmVjdCA9IGZpbmlzaGVkV29yay5maXJzdEVmZmVjdDtcbiAgfVxuXG4gIGlmIChmaXJzdEVmZmVjdCAhPT0gbnVsbCkge1xuXG4gICAgdmFyIHByZXZFeGVjdXRpb25Db250ZXh0ID0gZXhlY3V0aW9uQ29udGV4dDtcbiAgICBleGVjdXRpb25Db250ZXh0IHw9IENvbW1pdENvbnRleHQ7XG4gICAgdmFyIHByZXZJbnRlcmFjdGlvbnMgPSBwdXNoSW50ZXJhY3Rpb25zKHJvb3QpOyAvLyBSZXNldCB0aGlzIHRvIG51bGwgYmVmb3JlIGNhbGxpbmcgbGlmZWN5Y2xlc1xuXG4gICAgUmVhY3RDdXJyZW50T3duZXIkMi5jdXJyZW50ID0gbnVsbDsgLy8gVGhlIGNvbW1pdCBwaGFzZSBpcyBicm9rZW4gaW50byBzZXZlcmFsIHN1Yi1waGFzZXMuIFdlIGRvIGEgc2VwYXJhdGUgcGFzc1xuICAgIC8vIG9mIHRoZSBlZmZlY3QgbGlzdCBmb3IgZWFjaCBwaGFzZTogYWxsIG11dGF0aW9uIGVmZmVjdHMgY29tZSBiZWZvcmUgYWxsXG4gICAgLy8gbGF5b3V0IGVmZmVjdHMsIGFuZCBzbyBvbi5cbiAgICAvLyBUaGUgZmlyc3QgcGhhc2UgYSBcImJlZm9yZSBtdXRhdGlvblwiIHBoYXNlLiBXZSB1c2UgdGhpcyBwaGFzZSB0byByZWFkIHRoZVxuICAgIC8vIHN0YXRlIG9mIHRoZSBob3N0IHRyZWUgcmlnaHQgYmVmb3JlIHdlIG11dGF0ZSBpdC4gVGhpcyBpcyB3aGVyZVxuICAgIC8vIGdldFNuYXBzaG90QmVmb3JlVXBkYXRlIGlzIGNhbGxlZC5cblxuICAgIGZvY3VzZWRJbnN0YW5jZUhhbmRsZSA9IHByZXBhcmVGb3JDb21taXQocm9vdC5jb250YWluZXJJbmZvKTtcbiAgICBzaG91bGRGaXJlQWZ0ZXJBY3RpdmVJbnN0YW5jZUJsdXIgPSBmYWxzZTtcbiAgICBuZXh0RWZmZWN0ID0gZmlyc3RFZmZlY3Q7XG5cbiAgICBkbyB7XG4gICAgICB7XG4gICAgICAgIGludm9rZUd1YXJkZWRDYWxsYmFjayhudWxsLCBjb21taXRCZWZvcmVNdXRhdGlvbkVmZmVjdHMsIG51bGwpO1xuXG4gICAgICAgIGlmIChoYXNDYXVnaHRFcnJvcigpKSB7XG4gICAgICAgICAgaWYgKCEobmV4dEVmZmVjdCAhPT0gbnVsbCkpIHtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoIFwiU2hvdWxkIGJlIHdvcmtpbmcgb24gYW4gZWZmZWN0LlwiICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIGVycm9yID0gY2xlYXJDYXVnaHRFcnJvcigpO1xuICAgICAgICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKG5leHRFZmZlY3QsIGVycm9yKTtcbiAgICAgICAgICBuZXh0RWZmZWN0ID0gbmV4dEVmZmVjdC5uZXh0RWZmZWN0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSB3aGlsZSAobmV4dEVmZmVjdCAhPT0gbnVsbCk7IC8vIFdlIG5vIGxvbmdlciBuZWVkIHRvIHRyYWNrIHRoZSBhY3RpdmUgaW5zdGFuY2UgZmliZXJcblxuXG4gICAgZm9jdXNlZEluc3RhbmNlSGFuZGxlID0gbnVsbDtcblxuICAgIHtcbiAgICAgIC8vIE1hcmsgdGhlIGN1cnJlbnQgY29tbWl0IHRpbWUgdG8gYmUgc2hhcmVkIGJ5IGFsbCBQcm9maWxlcnMgaW4gdGhpc1xuICAgICAgLy8gYmF0Y2guIFRoaXMgZW5hYmxlcyB0aGVtIHRvIGJlIGdyb3VwZWQgbGF0ZXIuXG4gICAgICByZWNvcmRDb21taXRUaW1lKCk7XG4gICAgfSAvLyBUaGUgbmV4dCBwaGFzZSBpcyB0aGUgbXV0YXRpb24gcGhhc2UsIHdoZXJlIHdlIG11dGF0ZSB0aGUgaG9zdCB0cmVlLlxuXG5cbiAgICBuZXh0RWZmZWN0ID0gZmlyc3RFZmZlY3Q7XG5cbiAgICBkbyB7XG4gICAgICB7XG4gICAgICAgIGludm9rZUd1YXJkZWRDYWxsYmFjayhudWxsLCBjb21taXRNdXRhdGlvbkVmZmVjdHMsIG51bGwsIHJvb3QsIHJlbmRlclByaW9yaXR5TGV2ZWwpO1xuXG4gICAgICAgIGlmIChoYXNDYXVnaHRFcnJvcigpKSB7XG4gICAgICAgICAgaWYgKCEobmV4dEVmZmVjdCAhPT0gbnVsbCkpIHtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoIFwiU2hvdWxkIGJlIHdvcmtpbmcgb24gYW4gZWZmZWN0LlwiICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIF9lcnJvciA9IGNsZWFyQ2F1Z2h0RXJyb3IoKTtcblxuICAgICAgICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKG5leHRFZmZlY3QsIF9lcnJvcik7XG4gICAgICAgICAgbmV4dEVmZmVjdCA9IG5leHRFZmZlY3QubmV4dEVmZmVjdDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gd2hpbGUgKG5leHRFZmZlY3QgIT09IG51bGwpO1xuXG4gICAgcmVzZXRBZnRlckNvbW1pdChyb290LmNvbnRhaW5lckluZm8pOyAvLyBUaGUgd29yay1pbi1wcm9ncmVzcyB0cmVlIGlzIG5vdyB0aGUgY3VycmVudCB0cmVlLiBUaGlzIG11c3QgY29tZSBhZnRlclxuICAgIC8vIHRoZSBtdXRhdGlvbiBwaGFzZSwgc28gdGhhdCB0aGUgcHJldmlvdXMgdHJlZSBpcyBzdGlsbCBjdXJyZW50IGR1cmluZ1xuICAgIC8vIGNvbXBvbmVudFdpbGxVbm1vdW50LCBidXQgYmVmb3JlIHRoZSBsYXlvdXQgcGhhc2UsIHNvIHRoYXQgdGhlIGZpbmlzaGVkXG4gICAgLy8gd29yayBpcyBjdXJyZW50IGR1cmluZyBjb21wb25lbnREaWRNb3VudC9VcGRhdGUuXG5cbiAgICByb290LmN1cnJlbnQgPSBmaW5pc2hlZFdvcms7IC8vIFRoZSBuZXh0IHBoYXNlIGlzIHRoZSBsYXlvdXQgcGhhc2UsIHdoZXJlIHdlIGNhbGwgZWZmZWN0cyB0aGF0IHJlYWRcbiAgICAvLyB0aGUgaG9zdCB0cmVlIGFmdGVyIGl0J3MgYmVlbiBtdXRhdGVkLiBUaGUgaWRpb21hdGljIHVzZSBjYXNlIGZvciB0aGlzIGlzXG4gICAgLy8gbGF5b3V0LCBidXQgY2xhc3MgY29tcG9uZW50IGxpZmVjeWNsZXMgYWxzbyBmaXJlIGhlcmUgZm9yIGxlZ2FjeSByZWFzb25zLlxuXG4gICAgbmV4dEVmZmVjdCA9IGZpcnN0RWZmZWN0O1xuXG4gICAgZG8ge1xuICAgICAge1xuICAgICAgICBpbnZva2VHdWFyZGVkQ2FsbGJhY2sobnVsbCwgY29tbWl0TGF5b3V0RWZmZWN0cywgbnVsbCwgcm9vdCwgbGFuZXMpO1xuXG4gICAgICAgIGlmIChoYXNDYXVnaHRFcnJvcigpKSB7XG4gICAgICAgICAgaWYgKCEobmV4dEVmZmVjdCAhPT0gbnVsbCkpIHtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoIFwiU2hvdWxkIGJlIHdvcmtpbmcgb24gYW4gZWZmZWN0LlwiICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIF9lcnJvcjIgPSBjbGVhckNhdWdodEVycm9yKCk7XG5cbiAgICAgICAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihuZXh0RWZmZWN0LCBfZXJyb3IyKTtcbiAgICAgICAgICBuZXh0RWZmZWN0ID0gbmV4dEVmZmVjdC5uZXh0RWZmZWN0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSB3aGlsZSAobmV4dEVmZmVjdCAhPT0gbnVsbCk7XG5cbiAgICBuZXh0RWZmZWN0ID0gbnVsbDsgLy8gVGVsbCBTY2hlZHVsZXIgdG8geWllbGQgYXQgdGhlIGVuZCBvZiB0aGUgZnJhbWUsIHNvIHRoZSBicm93c2VyIGhhcyBhblxuICAgIC8vIG9wcG9ydHVuaXR5IHRvIHBhaW50LlxuXG4gICAgcmVxdWVzdFBhaW50KCk7XG5cbiAgICB7XG4gICAgICBwb3BJbnRlcmFjdGlvbnMocHJldkludGVyYWN0aW9ucyk7XG4gICAgfVxuXG4gICAgZXhlY3V0aW9uQ29udGV4dCA9IHByZXZFeGVjdXRpb25Db250ZXh0O1xuICB9IGVsc2Uge1xuICAgIC8vIE5vIGVmZmVjdHMuXG4gICAgcm9vdC5jdXJyZW50ID0gZmluaXNoZWRXb3JrOyAvLyBNZWFzdXJlIHRoZXNlIGFueXdheSBzbyB0aGUgZmxhbWVncmFwaCBleHBsaWNpdGx5IHNob3dzIHRoYXQgdGhlcmUgd2VyZVxuICAgIC8vIG5vIGVmZmVjdHMuXG4gICAgLy8gVE9ETzogTWF5YmUgdGhlcmUncyBhIGJldHRlciB3YXkgdG8gcmVwb3J0IHRoaXMuXG5cbiAgICB7XG4gICAgICByZWNvcmRDb21taXRUaW1lKCk7XG4gICAgfVxuICB9XG5cbiAgdmFyIHJvb3REaWRIYXZlUGFzc2l2ZUVmZmVjdHMgPSByb290RG9lc0hhdmVQYXNzaXZlRWZmZWN0cztcblxuICBpZiAocm9vdERvZXNIYXZlUGFzc2l2ZUVmZmVjdHMpIHtcbiAgICAvLyBUaGlzIGNvbW1pdCBoYXMgcGFzc2l2ZSBlZmZlY3RzLiBTdGFzaCBhIHJlZmVyZW5jZSB0byB0aGVtLiBCdXQgZG9uJ3RcbiAgICAvLyBzY2hlZHVsZSBhIGNhbGxiYWNrIHVudGlsIGFmdGVyIGZsdXNoaW5nIGxheW91dCB3b3JrLlxuICAgIHJvb3REb2VzSGF2ZVBhc3NpdmVFZmZlY3RzID0gZmFsc2U7XG4gICAgcm9vdFdpdGhQZW5kaW5nUGFzc2l2ZUVmZmVjdHMgPSByb290O1xuICAgIHBlbmRpbmdQYXNzaXZlRWZmZWN0c0xhbmVzID0gbGFuZXM7XG4gICAgcGVuZGluZ1Bhc3NpdmVFZmZlY3RzUmVuZGVyUHJpb3JpdHkgPSByZW5kZXJQcmlvcml0eUxldmVsO1xuICB9IGVsc2Uge1xuICAgIC8vIFdlIGFyZSBkb25lIHdpdGggdGhlIGVmZmVjdCBjaGFpbiBhdCB0aGlzIHBvaW50IHNvIGxldCdzIGNsZWFyIHRoZVxuICAgIC8vIG5leHRFZmZlY3QgcG9pbnRlcnMgdG8gYXNzaXN0IHdpdGggR0MuIElmIHdlIGhhdmUgcGFzc2l2ZSBlZmZlY3RzLCB3ZSdsbFxuICAgIC8vIGNsZWFyIHRoaXMgaW4gZmx1c2hQYXNzaXZlRWZmZWN0cy5cbiAgICBuZXh0RWZmZWN0ID0gZmlyc3RFZmZlY3Q7XG5cbiAgICB3aGlsZSAobmV4dEVmZmVjdCAhPT0gbnVsbCkge1xuICAgICAgdmFyIG5leHROZXh0RWZmZWN0ID0gbmV4dEVmZmVjdC5uZXh0RWZmZWN0O1xuICAgICAgbmV4dEVmZmVjdC5uZXh0RWZmZWN0ID0gbnVsbDtcblxuICAgICAgaWYgKG5leHRFZmZlY3QuZmxhZ3MgJiBEZWxldGlvbikge1xuICAgICAgICBkZXRhY2hGaWJlckFmdGVyRWZmZWN0cyhuZXh0RWZmZWN0KTtcbiAgICAgIH1cblxuICAgICAgbmV4dEVmZmVjdCA9IG5leHROZXh0RWZmZWN0O1xuICAgIH1cbiAgfSAvLyBSZWFkIHRoaXMgYWdhaW4sIHNpbmNlIGFuIGVmZmVjdCBtaWdodCBoYXZlIHVwZGF0ZWQgaXRcblxuXG4gIHJlbWFpbmluZ0xhbmVzID0gcm9vdC5wZW5kaW5nTGFuZXM7IC8vIENoZWNrIGlmIHRoZXJlJ3MgcmVtYWluaW5nIHdvcmsgb24gdGhpcyByb290XG5cbiAgaWYgKHJlbWFpbmluZ0xhbmVzICE9PSBOb0xhbmVzKSB7XG4gICAge1xuICAgICAgaWYgKHNwYXduZWRXb3JrRHVyaW5nUmVuZGVyICE9PSBudWxsKSB7XG4gICAgICAgIHZhciBleHBpcmF0aW9uVGltZXMgPSBzcGF3bmVkV29ya0R1cmluZ1JlbmRlcjtcbiAgICAgICAgc3Bhd25lZFdvcmtEdXJpbmdSZW5kZXIgPSBudWxsO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZXhwaXJhdGlvblRpbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgc2NoZWR1bGVJbnRlcmFjdGlvbnMocm9vdCwgZXhwaXJhdGlvblRpbWVzW2ldLCByb290Lm1lbW9pemVkSW50ZXJhY3Rpb25zKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBzY2hlZHVsZVBlbmRpbmdJbnRlcmFjdGlvbnMocm9vdCwgcmVtYWluaW5nTGFuZXMpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBJZiB0aGVyZSdzIG5vIHJlbWFpbmluZyB3b3JrLCB3ZSBjYW4gY2xlYXIgdGhlIHNldCBvZiBhbHJlYWR5IGZhaWxlZFxuICAgIC8vIGVycm9yIGJvdW5kYXJpZXMuXG4gICAgbGVnYWN5RXJyb3JCb3VuZGFyaWVzVGhhdEFscmVhZHlGYWlsZWQgPSBudWxsO1xuICB9XG5cbiAge1xuICAgIGlmICghcm9vdERpZEhhdmVQYXNzaXZlRWZmZWN0cykge1xuICAgICAgLy8gSWYgdGhlcmUgYXJlIG5vIHBhc3NpdmUgZWZmZWN0cywgdGhlbiB3ZSBjYW4gY29tcGxldGUgdGhlIHBlbmRpbmcgaW50ZXJhY3Rpb25zLlxuICAgICAgLy8gT3RoZXJ3aXNlLCB3ZSdsbCB3YWl0IHVudGlsIGFmdGVyIHRoZSBwYXNzaXZlIGVmZmVjdHMgYXJlIGZsdXNoZWQuXG4gICAgICAvLyBXYWl0IHRvIGRvIHRoaXMgdW50aWwgYWZ0ZXIgcmVtYWluaW5nIHdvcmsgaGFzIGJlZW4gc2NoZWR1bGVkLFxuICAgICAgLy8gc28gdGhhdCB3ZSBkb24ndCBwcmVtYXR1cmVseSBzaWduYWwgY29tcGxldGUgZm9yIGludGVyYWN0aW9ucyB3aGVuIHRoZXJlJ3MgZS5nLiBoaWRkZW4gd29yay5cbiAgICAgIGZpbmlzaFBlbmRpbmdJbnRlcmFjdGlvbnMocm9vdCwgbGFuZXMpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChyZW1haW5pbmdMYW5lcyA9PT0gU3luY0xhbmUpIHtcbiAgICAvLyBDb3VudCB0aGUgbnVtYmVyIG9mIHRpbWVzIHRoZSByb290IHN5bmNocm9ub3VzbHkgcmUtcmVuZGVycyB3aXRob3V0XG4gICAgLy8gZmluaXNoaW5nLiBJZiB0aGVyZSBhcmUgdG9vIG1hbnksIGl0IGluZGljYXRlcyBhbiBpbmZpbml0ZSB1cGRhdGUgbG9vcC5cbiAgICBpZiAocm9vdCA9PT0gcm9vdFdpdGhOZXN0ZWRVcGRhdGVzKSB7XG4gICAgICBuZXN0ZWRVcGRhdGVDb3VudCsrO1xuICAgIH0gZWxzZSB7XG4gICAgICBuZXN0ZWRVcGRhdGVDb3VudCA9IDA7XG4gICAgICByb290V2l0aE5lc3RlZFVwZGF0ZXMgPSByb290O1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBuZXN0ZWRVcGRhdGVDb3VudCA9IDA7XG4gIH1cblxuICBvbkNvbW1pdFJvb3QoZmluaXNoZWRXb3JrLnN0YXRlTm9kZSwgcmVuZGVyUHJpb3JpdHlMZXZlbCk7XG5cbiAge1xuICAgIG9uQ29tbWl0Um9vdCQxKCk7XG4gIH0gLy8gQWx3YXlzIGNhbGwgdGhpcyBiZWZvcmUgZXhpdGluZyBgY29tbWl0Um9vdGAsIHRvIGVuc3VyZSB0aGF0IGFueVxuICAvLyBhZGRpdGlvbmFsIHdvcmsgb24gdGhpcyByb290IGlzIHNjaGVkdWxlZC5cblxuXG4gIGVuc3VyZVJvb3RJc1NjaGVkdWxlZChyb290LCBub3coKSk7XG5cbiAgaWYgKGhhc1VuY2F1Z2h0RXJyb3IpIHtcbiAgICBoYXNVbmNhdWdodEVycm9yID0gZmFsc2U7XG4gICAgdmFyIF9lcnJvcjMgPSBmaXJzdFVuY2F1Z2h0RXJyb3I7XG4gICAgZmlyc3RVbmNhdWdodEVycm9yID0gbnVsbDtcbiAgICB0aHJvdyBfZXJyb3IzO1xuICB9XG5cbiAgaWYgKChleGVjdXRpb25Db250ZXh0ICYgTGVnYWN5VW5iYXRjaGVkQ29udGV4dCkgIT09IE5vQ29udGV4dCkge1xuICAgIC8vIGEgUmVhY3RET00ucmVuZGVyLWVkIHJvb3QgaW5zaWRlIG9mIGJhdGNoZWRVcGRhdGVzLiBUaGUgY29tbWl0IGZpcmVkXG4gICAgLy8gc3luY2hyb25vdXNseSwgYnV0IGxheW91dCB1cGRhdGVzIHNob3VsZCBiZSBkZWZlcnJlZCB1bnRpbCB0aGUgZW5kXG4gICAgLy8gb2YgdGhlIGJhdGNoLlxuXG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfSAvLyBJZiBsYXlvdXQgd29yayB3YXMgc2NoZWR1bGVkLCBmbHVzaCBpdCBub3cuXG5cblxuICBmbHVzaFN5bmNDYWxsYmFja1F1ZXVlKCk7XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIGNvbW1pdEJlZm9yZU11dGF0aW9uRWZmZWN0cygpIHtcbiAgd2hpbGUgKG5leHRFZmZlY3QgIT09IG51bGwpIHtcbiAgICB2YXIgY3VycmVudCA9IG5leHRFZmZlY3QuYWx0ZXJuYXRlO1xuXG4gICAgaWYgKCFzaG91bGRGaXJlQWZ0ZXJBY3RpdmVJbnN0YW5jZUJsdXIgJiYgZm9jdXNlZEluc3RhbmNlSGFuZGxlICE9PSBudWxsKSB7XG4gICAgICBpZiAoKG5leHRFZmZlY3QuZmxhZ3MgJiBEZWxldGlvbikgIT09IE5vRmxhZ3MpIHtcbiAgICAgICAgaWYgKGRvZXNGaWJlckNvbnRhaW4obmV4dEVmZmVjdCwgZm9jdXNlZEluc3RhbmNlSGFuZGxlKSkge1xuICAgICAgICAgIHNob3VsZEZpcmVBZnRlckFjdGl2ZUluc3RhbmNlQmx1ciA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFRPRE86IE1vdmUgdGhpcyBvdXQgb2YgdGhlIGhvdCBwYXRoIHVzaW5nIGEgZGVkaWNhdGVkIGVmZmVjdCB0YWcuXG4gICAgICAgIGlmIChuZXh0RWZmZWN0LnRhZyA9PT0gU3VzcGVuc2VDb21wb25lbnQgJiYgaXNTdXNwZW5zZUJvdW5kYXJ5QmVpbmdIaWRkZW4oY3VycmVudCwgbmV4dEVmZmVjdCkgJiYgZG9lc0ZpYmVyQ29udGFpbihuZXh0RWZmZWN0LCBmb2N1c2VkSW5zdGFuY2VIYW5kbGUpKSB7XG4gICAgICAgICAgc2hvdWxkRmlyZUFmdGVyQWN0aXZlSW5zdGFuY2VCbHVyID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBmbGFncyA9IG5leHRFZmZlY3QuZmxhZ3M7XG5cbiAgICBpZiAoKGZsYWdzICYgU25hcHNob3QpICE9PSBOb0ZsYWdzKSB7XG4gICAgICBzZXRDdXJyZW50RmliZXIobmV4dEVmZmVjdCk7XG4gICAgICBjb21taXRCZWZvcmVNdXRhdGlvbkxpZmVDeWNsZXMoY3VycmVudCwgbmV4dEVmZmVjdCk7XG4gICAgICByZXNldEN1cnJlbnRGaWJlcigpO1xuICAgIH1cblxuICAgIGlmICgoZmxhZ3MgJiBQYXNzaXZlKSAhPT0gTm9GbGFncykge1xuICAgICAgLy8gSWYgdGhlcmUgYXJlIHBhc3NpdmUgZWZmZWN0cywgc2NoZWR1bGUgYSBjYWxsYmFjayB0byBmbHVzaCBhdFxuICAgICAgLy8gdGhlIGVhcmxpZXN0IG9wcG9ydHVuaXR5LlxuICAgICAgaWYgKCFyb290RG9lc0hhdmVQYXNzaXZlRWZmZWN0cykge1xuICAgICAgICByb290RG9lc0hhdmVQYXNzaXZlRWZmZWN0cyA9IHRydWU7XG4gICAgICAgIHNjaGVkdWxlQ2FsbGJhY2soTm9ybWFsUHJpb3JpdHkkMSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGZsdXNoUGFzc2l2ZUVmZmVjdHMoKTtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgbmV4dEVmZmVjdCA9IG5leHRFZmZlY3QubmV4dEVmZmVjdDtcbiAgfVxufVxuXG5mdW5jdGlvbiBjb21taXRNdXRhdGlvbkVmZmVjdHMocm9vdCwgcmVuZGVyUHJpb3JpdHlMZXZlbCkge1xuICAvLyBUT0RPOiBTaG91bGQgcHJvYmFibHkgbW92ZSB0aGUgYnVsayBvZiB0aGlzIGZ1bmN0aW9uIHRvIGNvbW1pdFdvcmsuXG4gIHdoaWxlIChuZXh0RWZmZWN0ICE9PSBudWxsKSB7XG4gICAgc2V0Q3VycmVudEZpYmVyKG5leHRFZmZlY3QpO1xuICAgIHZhciBmbGFncyA9IG5leHRFZmZlY3QuZmxhZ3M7XG5cbiAgICBpZiAoZmxhZ3MgJiBDb250ZW50UmVzZXQpIHtcbiAgICAgIGNvbW1pdFJlc2V0VGV4dENvbnRlbnQobmV4dEVmZmVjdCk7XG4gICAgfVxuXG4gICAgaWYgKGZsYWdzICYgUmVmKSB7XG4gICAgICB2YXIgY3VycmVudCA9IG5leHRFZmZlY3QuYWx0ZXJuYXRlO1xuXG4gICAgICBpZiAoY3VycmVudCAhPT0gbnVsbCkge1xuICAgICAgICBjb21taXREZXRhY2hSZWYoY3VycmVudCk7XG4gICAgICB9XG4gICAgfSAvLyBUaGUgZm9sbG93aW5nIHN3aXRjaCBzdGF0ZW1lbnQgaXMgb25seSBjb25jZXJuZWQgYWJvdXQgcGxhY2VtZW50LFxuICAgIC8vIHVwZGF0ZXMsIGFuZCBkZWxldGlvbnMuIFRvIGF2b2lkIG5lZWRpbmcgdG8gYWRkIGEgY2FzZSBmb3IgZXZlcnkgcG9zc2libGVcbiAgICAvLyBiaXRtYXAgdmFsdWUsIHdlIHJlbW92ZSB0aGUgc2Vjb25kYXJ5IGVmZmVjdHMgZnJvbSB0aGUgZWZmZWN0IHRhZyBhbmRcbiAgICAvLyBzd2l0Y2ggb24gdGhhdCB2YWx1ZS5cblxuXG4gICAgdmFyIHByaW1hcnlGbGFncyA9IGZsYWdzICYgKFBsYWNlbWVudCB8IFVwZGF0ZSB8IERlbGV0aW9uIHwgSHlkcmF0aW5nKTtcblxuICAgIHN3aXRjaCAocHJpbWFyeUZsYWdzKSB7XG4gICAgICBjYXNlIFBsYWNlbWVudDpcbiAgICAgICAge1xuICAgICAgICAgIGNvbW1pdFBsYWNlbWVudChuZXh0RWZmZWN0KTsgLy8gQ2xlYXIgdGhlIFwicGxhY2VtZW50XCIgZnJvbSBlZmZlY3QgdGFnIHNvIHRoYXQgd2Uga25vdyB0aGF0IHRoaXMgaXNcbiAgICAgICAgICAvLyBpbnNlcnRlZCwgYmVmb3JlIGFueSBsaWZlLWN5Y2xlcyBsaWtlIGNvbXBvbmVudERpZE1vdW50IGdldHMgY2FsbGVkLlxuICAgICAgICAgIC8vIFRPRE86IGZpbmRET01Ob2RlIGRvZXNuJ3QgcmVseSBvbiB0aGlzIGFueSBtb3JlIGJ1dCBpc01vdW50ZWQgZG9lc1xuICAgICAgICAgIC8vIGFuZCBpc01vdW50ZWQgaXMgZGVwcmVjYXRlZCBhbnl3YXkgc28gd2Ugc2hvdWxkIGJlIGFibGUgdG8ga2lsbCB0aGlzLlxuXG4gICAgICAgICAgbmV4dEVmZmVjdC5mbGFncyAmPSB+UGxhY2VtZW50O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgUGxhY2VtZW50QW5kVXBkYXRlOlxuICAgICAgICB7XG4gICAgICAgICAgLy8gUGxhY2VtZW50XG4gICAgICAgICAgY29tbWl0UGxhY2VtZW50KG5leHRFZmZlY3QpOyAvLyBDbGVhciB0aGUgXCJwbGFjZW1lbnRcIiBmcm9tIGVmZmVjdCB0YWcgc28gdGhhdCB3ZSBrbm93IHRoYXQgdGhpcyBpc1xuICAgICAgICAgIC8vIGluc2VydGVkLCBiZWZvcmUgYW55IGxpZmUtY3ljbGVzIGxpa2UgY29tcG9uZW50RGlkTW91bnQgZ2V0cyBjYWxsZWQuXG5cbiAgICAgICAgICBuZXh0RWZmZWN0LmZsYWdzICY9IH5QbGFjZW1lbnQ7IC8vIFVwZGF0ZVxuXG4gICAgICAgICAgdmFyIF9jdXJyZW50ID0gbmV4dEVmZmVjdC5hbHRlcm5hdGU7XG4gICAgICAgICAgY29tbWl0V29yayhfY3VycmVudCwgbmV4dEVmZmVjdCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBIeWRyYXRpbmc6XG4gICAgICAgIHtcbiAgICAgICAgICBuZXh0RWZmZWN0LmZsYWdzICY9IH5IeWRyYXRpbmc7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBIeWRyYXRpbmdBbmRVcGRhdGU6XG4gICAgICAgIHtcbiAgICAgICAgICBuZXh0RWZmZWN0LmZsYWdzICY9IH5IeWRyYXRpbmc7IC8vIFVwZGF0ZVxuXG4gICAgICAgICAgdmFyIF9jdXJyZW50MiA9IG5leHRFZmZlY3QuYWx0ZXJuYXRlO1xuICAgICAgICAgIGNvbW1pdFdvcmsoX2N1cnJlbnQyLCBuZXh0RWZmZWN0KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIFVwZGF0ZTpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBfY3VycmVudDMgPSBuZXh0RWZmZWN0LmFsdGVybmF0ZTtcbiAgICAgICAgICBjb21taXRXb3JrKF9jdXJyZW50MywgbmV4dEVmZmVjdCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBEZWxldGlvbjpcbiAgICAgICAge1xuICAgICAgICAgIGNvbW1pdERlbGV0aW9uKHJvb3QsIG5leHRFZmZlY3QpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmVzZXRDdXJyZW50RmliZXIoKTtcbiAgICBuZXh0RWZmZWN0ID0gbmV4dEVmZmVjdC5uZXh0RWZmZWN0O1xuICB9XG59XG5cbmZ1bmN0aW9uIGNvbW1pdExheW91dEVmZmVjdHMocm9vdCwgY29tbWl0dGVkTGFuZXMpIHtcblxuXG4gIHdoaWxlIChuZXh0RWZmZWN0ICE9PSBudWxsKSB7XG4gICAgc2V0Q3VycmVudEZpYmVyKG5leHRFZmZlY3QpO1xuICAgIHZhciBmbGFncyA9IG5leHRFZmZlY3QuZmxhZ3M7XG5cbiAgICBpZiAoZmxhZ3MgJiAoVXBkYXRlIHwgQ2FsbGJhY2spKSB7XG4gICAgICB2YXIgY3VycmVudCA9IG5leHRFZmZlY3QuYWx0ZXJuYXRlO1xuICAgICAgY29tbWl0TGlmZUN5Y2xlcyhyb290LCBjdXJyZW50LCBuZXh0RWZmZWN0KTtcbiAgICB9XG5cbiAgICB7XG4gICAgICBpZiAoZmxhZ3MgJiBSZWYpIHtcbiAgICAgICAgY29tbWl0QXR0YWNoUmVmKG5leHRFZmZlY3QpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJlc2V0Q3VycmVudEZpYmVyKCk7XG4gICAgbmV4dEVmZmVjdCA9IG5leHRFZmZlY3QubmV4dEVmZmVjdDtcbiAgfVxufVxuXG5mdW5jdGlvbiBmbHVzaFBhc3NpdmVFZmZlY3RzKCkge1xuICAvLyBSZXR1cm5zIHdoZXRoZXIgcGFzc2l2ZSBlZmZlY3RzIHdlcmUgZmx1c2hlZC5cbiAgaWYgKHBlbmRpbmdQYXNzaXZlRWZmZWN0c1JlbmRlclByaW9yaXR5ICE9PSBOb1ByaW9yaXR5JDEpIHtcbiAgICB2YXIgcHJpb3JpdHlMZXZlbCA9IHBlbmRpbmdQYXNzaXZlRWZmZWN0c1JlbmRlclByaW9yaXR5ID4gTm9ybWFsUHJpb3JpdHkkMSA/IE5vcm1hbFByaW9yaXR5JDEgOiBwZW5kaW5nUGFzc2l2ZUVmZmVjdHNSZW5kZXJQcmlvcml0eTtcbiAgICBwZW5kaW5nUGFzc2l2ZUVmZmVjdHNSZW5kZXJQcmlvcml0eSA9IE5vUHJpb3JpdHkkMTtcblxuICAgIHtcbiAgICAgIHJldHVybiBydW5XaXRoUHJpb3JpdHkkMShwcmlvcml0eUxldmVsLCBmbHVzaFBhc3NpdmVFZmZlY3RzSW1wbCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gZW5xdWV1ZVBlbmRpbmdQYXNzaXZlSG9va0VmZmVjdE1vdW50KGZpYmVyLCBlZmZlY3QpIHtcbiAgcGVuZGluZ1Bhc3NpdmVIb29rRWZmZWN0c01vdW50LnB1c2goZWZmZWN0LCBmaWJlcik7XG5cbiAgaWYgKCFyb290RG9lc0hhdmVQYXNzaXZlRWZmZWN0cykge1xuICAgIHJvb3REb2VzSGF2ZVBhc3NpdmVFZmZlY3RzID0gdHJ1ZTtcbiAgICBzY2hlZHVsZUNhbGxiYWNrKE5vcm1hbFByaW9yaXR5JDEsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGZsdXNoUGFzc2l2ZUVmZmVjdHMoKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0pO1xuICB9XG59XG5mdW5jdGlvbiBlbnF1ZXVlUGVuZGluZ1Bhc3NpdmVIb29rRWZmZWN0VW5tb3VudChmaWJlciwgZWZmZWN0KSB7XG4gIHBlbmRpbmdQYXNzaXZlSG9va0VmZmVjdHNVbm1vdW50LnB1c2goZWZmZWN0LCBmaWJlcik7XG5cbiAge1xuICAgIGZpYmVyLmZsYWdzIHw9IFBhc3NpdmVVbm1vdW50UGVuZGluZ0RldjtcbiAgICB2YXIgYWx0ZXJuYXRlID0gZmliZXIuYWx0ZXJuYXRlO1xuXG4gICAgaWYgKGFsdGVybmF0ZSAhPT0gbnVsbCkge1xuICAgICAgYWx0ZXJuYXRlLmZsYWdzIHw9IFBhc3NpdmVVbm1vdW50UGVuZGluZ0RldjtcbiAgICB9XG4gIH1cblxuICBpZiAoIXJvb3REb2VzSGF2ZVBhc3NpdmVFZmZlY3RzKSB7XG4gICAgcm9vdERvZXNIYXZlUGFzc2l2ZUVmZmVjdHMgPSB0cnVlO1xuICAgIHNjaGVkdWxlQ2FsbGJhY2soTm9ybWFsUHJpb3JpdHkkMSwgZnVuY3Rpb24gKCkge1xuICAgICAgZmx1c2hQYXNzaXZlRWZmZWN0cygpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW52b2tlUGFzc2l2ZUVmZmVjdENyZWF0ZShlZmZlY3QpIHtcbiAgdmFyIGNyZWF0ZSA9IGVmZmVjdC5jcmVhdGU7XG4gIGVmZmVjdC5kZXN0cm95ID0gY3JlYXRlKCk7XG59XG5cbmZ1bmN0aW9uIGZsdXNoUGFzc2l2ZUVmZmVjdHNJbXBsKCkge1xuICBpZiAocm9vdFdpdGhQZW5kaW5nUGFzc2l2ZUVmZmVjdHMgPT09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgcm9vdCA9IHJvb3RXaXRoUGVuZGluZ1Bhc3NpdmVFZmZlY3RzO1xuICB2YXIgbGFuZXMgPSBwZW5kaW5nUGFzc2l2ZUVmZmVjdHNMYW5lcztcbiAgcm9vdFdpdGhQZW5kaW5nUGFzc2l2ZUVmZmVjdHMgPSBudWxsO1xuICBwZW5kaW5nUGFzc2l2ZUVmZmVjdHNMYW5lcyA9IE5vTGFuZXM7XG5cbiAgaWYgKCEoKGV4ZWN1dGlvbkNvbnRleHQgJiAoUmVuZGVyQ29udGV4dCB8IENvbW1pdENvbnRleHQpKSA9PT0gTm9Db250ZXh0KSkge1xuICAgIHtcbiAgICAgIHRocm93IEVycm9yKCBcIkNhbm5vdCBmbHVzaCBwYXNzaXZlIGVmZmVjdHMgd2hpbGUgYWxyZWFkeSByZW5kZXJpbmcuXCIgKTtcbiAgICB9XG4gIH1cblxuICB7XG4gICAgaXNGbHVzaGluZ1Bhc3NpdmVFZmZlY3RzID0gdHJ1ZTtcbiAgfVxuXG4gIHZhciBwcmV2RXhlY3V0aW9uQ29udGV4dCA9IGV4ZWN1dGlvbkNvbnRleHQ7XG4gIGV4ZWN1dGlvbkNvbnRleHQgfD0gQ29tbWl0Q29udGV4dDtcbiAgdmFyIHByZXZJbnRlcmFjdGlvbnMgPSBwdXNoSW50ZXJhY3Rpb25zKHJvb3QpOyAvLyBJdCdzIGltcG9ydGFudCB0aGF0IEFMTCBwZW5kaW5nIHBhc3NpdmUgZWZmZWN0IGRlc3Ryb3kgZnVuY3Rpb25zIGFyZSBjYWxsZWRcbiAgLy8gYmVmb3JlIEFOWSBwYXNzaXZlIGVmZmVjdCBjcmVhdGUgZnVuY3Rpb25zIGFyZSBjYWxsZWQuXG4gIC8vIE90aGVyd2lzZSBlZmZlY3RzIGluIHNpYmxpbmcgY29tcG9uZW50cyBtaWdodCBpbnRlcmZlcmUgd2l0aCBlYWNoIG90aGVyLlxuICAvLyBlLmcuIGEgZGVzdHJveSBmdW5jdGlvbiBpbiBvbmUgY29tcG9uZW50IG1heSB1bmludGVudGlvbmFsbHkgb3ZlcnJpZGUgYSByZWZcbiAgLy8gdmFsdWUgc2V0IGJ5IGEgY3JlYXRlIGZ1bmN0aW9uIGluIGFub3RoZXIgY29tcG9uZW50LlxuICAvLyBMYXlvdXQgZWZmZWN0cyBoYXZlIHRoZSBzYW1lIGNvbnN0cmFpbnQuXG4gIC8vIEZpcnN0IHBhc3M6IERlc3Ryb3kgc3RhbGUgcGFzc2l2ZSBlZmZlY3RzLlxuXG4gIHZhciB1bm1vdW50RWZmZWN0cyA9IHBlbmRpbmdQYXNzaXZlSG9va0VmZmVjdHNVbm1vdW50O1xuICBwZW5kaW5nUGFzc2l2ZUhvb2tFZmZlY3RzVW5tb3VudCA9IFtdO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdW5tb3VudEVmZmVjdHMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICB2YXIgX2VmZmVjdCA9IHVubW91bnRFZmZlY3RzW2ldO1xuICAgIHZhciBmaWJlciA9IHVubW91bnRFZmZlY3RzW2kgKyAxXTtcbiAgICB2YXIgZGVzdHJveSA9IF9lZmZlY3QuZGVzdHJveTtcbiAgICBfZWZmZWN0LmRlc3Ryb3kgPSB1bmRlZmluZWQ7XG5cbiAgICB7XG4gICAgICBmaWJlci5mbGFncyAmPSB+UGFzc2l2ZVVubW91bnRQZW5kaW5nRGV2O1xuICAgICAgdmFyIGFsdGVybmF0ZSA9IGZpYmVyLmFsdGVybmF0ZTtcblxuICAgICAgaWYgKGFsdGVybmF0ZSAhPT0gbnVsbCkge1xuICAgICAgICBhbHRlcm5hdGUuZmxhZ3MgJj0gflBhc3NpdmVVbm1vdW50UGVuZGluZ0RldjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGRlc3Ryb3kgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHtcbiAgICAgICAgc2V0Q3VycmVudEZpYmVyKGZpYmVyKTtcblxuICAgICAgICB7XG4gICAgICAgICAgaW52b2tlR3VhcmRlZENhbGxiYWNrKG51bGwsIGRlc3Ryb3ksIG51bGwpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGhhc0NhdWdodEVycm9yKCkpIHtcbiAgICAgICAgICBpZiAoIShmaWJlciAhPT0gbnVsbCkpIHtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoIFwiU2hvdWxkIGJlIHdvcmtpbmcgb24gYW4gZWZmZWN0LlwiICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIGVycm9yID0gY2xlYXJDYXVnaHRFcnJvcigpO1xuICAgICAgICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKGZpYmVyLCBlcnJvcik7XG4gICAgICAgIH1cblxuICAgICAgICByZXNldEN1cnJlbnRGaWJlcigpO1xuICAgICAgfVxuICAgIH1cbiAgfSAvLyBTZWNvbmQgcGFzczogQ3JlYXRlIG5ldyBwYXNzaXZlIGVmZmVjdHMuXG5cblxuICB2YXIgbW91bnRFZmZlY3RzID0gcGVuZGluZ1Bhc3NpdmVIb29rRWZmZWN0c01vdW50O1xuICBwZW5kaW5nUGFzc2l2ZUhvb2tFZmZlY3RzTW91bnQgPSBbXTtcblxuICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgbW91bnRFZmZlY3RzLmxlbmd0aDsgX2kgKz0gMikge1xuICAgIHZhciBfZWZmZWN0MiA9IG1vdW50RWZmZWN0c1tfaV07XG4gICAgdmFyIF9maWJlciA9IG1vdW50RWZmZWN0c1tfaSArIDFdO1xuXG4gICAge1xuICAgICAgc2V0Q3VycmVudEZpYmVyKF9maWJlcik7XG5cbiAgICAgIHtcbiAgICAgICAgaW52b2tlR3VhcmRlZENhbGxiYWNrKG51bGwsIGludm9rZVBhc3NpdmVFZmZlY3RDcmVhdGUsIG51bGwsIF9lZmZlY3QyKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGhhc0NhdWdodEVycm9yKCkpIHtcbiAgICAgICAgaWYgKCEoX2ZpYmVyICE9PSBudWxsKSkge1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKCBcIlNob3VsZCBiZSB3b3JraW5nIG9uIGFuIGVmZmVjdC5cIiApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBfZXJyb3I0ID0gY2xlYXJDYXVnaHRFcnJvcigpO1xuXG4gICAgICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKF9maWJlciwgX2Vycm9yNCk7XG4gICAgICB9XG5cbiAgICAgIHJlc2V0Q3VycmVudEZpYmVyKCk7XG4gICAgfVxuICB9IC8vIE5vdGU6IFRoaXMgY3VycmVudGx5IGFzc3VtZXMgdGhlcmUgYXJlIG5vIHBhc3NpdmUgZWZmZWN0cyBvbiB0aGUgcm9vdCBmaWJlclxuICAvLyBiZWNhdXNlIHRoZSByb290IGlzIG5vdCBwYXJ0IG9mIGl0cyBvd24gZWZmZWN0IGxpc3QuXG4gIC8vIFRoaXMgY291bGQgY2hhbmdlIGluIHRoZSBmdXR1cmUuXG5cblxuICB2YXIgZWZmZWN0ID0gcm9vdC5jdXJyZW50LmZpcnN0RWZmZWN0O1xuXG4gIHdoaWxlIChlZmZlY3QgIT09IG51bGwpIHtcbiAgICB2YXIgbmV4dE5leHRFZmZlY3QgPSBlZmZlY3QubmV4dEVmZmVjdDsgLy8gUmVtb3ZlIG5leHRFZmZlY3QgcG9pbnRlciB0byBhc3Npc3QgR0NcblxuICAgIGVmZmVjdC5uZXh0RWZmZWN0ID0gbnVsbDtcblxuICAgIGlmIChlZmZlY3QuZmxhZ3MgJiBEZWxldGlvbikge1xuICAgICAgZGV0YWNoRmliZXJBZnRlckVmZmVjdHMoZWZmZWN0KTtcbiAgICB9XG5cbiAgICBlZmZlY3QgPSBuZXh0TmV4dEVmZmVjdDtcbiAgfVxuXG4gIHtcbiAgICBwb3BJbnRlcmFjdGlvbnMocHJldkludGVyYWN0aW9ucyk7XG4gICAgZmluaXNoUGVuZGluZ0ludGVyYWN0aW9ucyhyb290LCBsYW5lcyk7XG4gIH1cblxuICB7XG4gICAgaXNGbHVzaGluZ1Bhc3NpdmVFZmZlY3RzID0gZmFsc2U7XG4gIH1cblxuICBleGVjdXRpb25Db250ZXh0ID0gcHJldkV4ZWN1dGlvbkNvbnRleHQ7XG4gIGZsdXNoU3luY0NhbGxiYWNrUXVldWUoKTsgLy8gSWYgYWRkaXRpb25hbCBwYXNzaXZlIGVmZmVjdHMgd2VyZSBzY2hlZHVsZWQsIGluY3JlbWVudCBhIGNvdW50ZXIuIElmIHRoaXNcbiAgLy8gZXhjZWVkcyB0aGUgbGltaXQsIHdlJ2xsIGZpcmUgYSB3YXJuaW5nLlxuXG4gIG5lc3RlZFBhc3NpdmVVcGRhdGVDb3VudCA9IHJvb3RXaXRoUGVuZGluZ1Bhc3NpdmVFZmZlY3RzID09PSBudWxsID8gMCA6IG5lc3RlZFBhc3NpdmVVcGRhdGVDb3VudCArIDE7XG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBpc0FscmVhZHlGYWlsZWRMZWdhY3lFcnJvckJvdW5kYXJ5KGluc3RhbmNlKSB7XG4gIHJldHVybiBsZWdhY3lFcnJvckJvdW5kYXJpZXNUaGF0QWxyZWFkeUZhaWxlZCAhPT0gbnVsbCAmJiBsZWdhY3lFcnJvckJvdW5kYXJpZXNUaGF0QWxyZWFkeUZhaWxlZC5oYXMoaW5zdGFuY2UpO1xufVxuZnVuY3Rpb24gbWFya0xlZ2FjeUVycm9yQm91bmRhcnlBc0ZhaWxlZChpbnN0YW5jZSkge1xuICBpZiAobGVnYWN5RXJyb3JCb3VuZGFyaWVzVGhhdEFscmVhZHlGYWlsZWQgPT09IG51bGwpIHtcbiAgICBsZWdhY3lFcnJvckJvdW5kYXJpZXNUaGF0QWxyZWFkeUZhaWxlZCA9IG5ldyBTZXQoW2luc3RhbmNlXSk7XG4gIH0gZWxzZSB7XG4gICAgbGVnYWN5RXJyb3JCb3VuZGFyaWVzVGhhdEFscmVhZHlGYWlsZWQuYWRkKGluc3RhbmNlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwcmVwYXJlVG9UaHJvd1VuY2F1Z2h0RXJyb3IoZXJyb3IpIHtcbiAgaWYgKCFoYXNVbmNhdWdodEVycm9yKSB7XG4gICAgaGFzVW5jYXVnaHRFcnJvciA9IHRydWU7XG4gICAgZmlyc3RVbmNhdWdodEVycm9yID0gZXJyb3I7XG4gIH1cbn1cblxudmFyIG9uVW5jYXVnaHRFcnJvciA9IHByZXBhcmVUb1Rocm93VW5jYXVnaHRFcnJvcjtcblxuZnVuY3Rpb24gY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3JPblJvb3Qocm9vdEZpYmVyLCBzb3VyY2VGaWJlciwgZXJyb3IpIHtcbiAgdmFyIGVycm9ySW5mbyA9IGNyZWF0ZUNhcHR1cmVkVmFsdWUoZXJyb3IsIHNvdXJjZUZpYmVyKTtcbiAgdmFyIHVwZGF0ZSA9IGNyZWF0ZVJvb3RFcnJvclVwZGF0ZShyb290RmliZXIsIGVycm9ySW5mbywgU3luY0xhbmUpO1xuICBlbnF1ZXVlVXBkYXRlKHJvb3RGaWJlciwgdXBkYXRlKTtcbiAgdmFyIGV2ZW50VGltZSA9IHJlcXVlc3RFdmVudFRpbWUoKTtcbiAgdmFyIHJvb3QgPSBtYXJrVXBkYXRlTGFuZUZyb21GaWJlclRvUm9vdChyb290RmliZXIsIFN5bmNMYW5lKTtcblxuICBpZiAocm9vdCAhPT0gbnVsbCkge1xuICAgIG1hcmtSb290VXBkYXRlZChyb290LCBTeW5jTGFuZSwgZXZlbnRUaW1lKTtcbiAgICBlbnN1cmVSb290SXNTY2hlZHVsZWQocm9vdCwgZXZlbnRUaW1lKTtcbiAgICBzY2hlZHVsZVBlbmRpbmdJbnRlcmFjdGlvbnMocm9vdCwgU3luY0xhbmUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKHNvdXJjZUZpYmVyLCBlcnJvcikge1xuICBpZiAoc291cmNlRmliZXIudGFnID09PSBIb3N0Um9vdCkge1xuICAgIC8vIEVycm9yIHdhcyB0aHJvd24gYXQgdGhlIHJvb3QuIFRoZXJlIGlzIG5vIHBhcmVudCwgc28gdGhlIHJvb3RcbiAgICAvLyBpdHNlbGYgc2hvdWxkIGNhcHR1cmUgaXQuXG4gICAgY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3JPblJvb3Qoc291cmNlRmliZXIsIHNvdXJjZUZpYmVyLCBlcnJvcik7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGZpYmVyID0gc291cmNlRmliZXIucmV0dXJuO1xuXG4gIHdoaWxlIChmaWJlciAhPT0gbnVsbCkge1xuICAgIGlmIChmaWJlci50YWcgPT09IEhvc3RSb290KSB7XG4gICAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvck9uUm9vdChmaWJlciwgc291cmNlRmliZXIsIGVycm9yKTtcbiAgICAgIHJldHVybjtcbiAgICB9IGVsc2UgaWYgKGZpYmVyLnRhZyA9PT0gQ2xhc3NDb21wb25lbnQpIHtcbiAgICAgIHZhciBjdG9yID0gZmliZXIudHlwZTtcbiAgICAgIHZhciBpbnN0YW5jZSA9IGZpYmVyLnN0YXRlTm9kZTtcblxuICAgICAgaWYgKHR5cGVvZiBjdG9yLmdldERlcml2ZWRTdGF0ZUZyb21FcnJvciA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50RGlkQ2F0Y2ggPT09ICdmdW5jdGlvbicgJiYgIWlzQWxyZWFkeUZhaWxlZExlZ2FjeUVycm9yQm91bmRhcnkoaW5zdGFuY2UpKSB7XG4gICAgICAgIHZhciBlcnJvckluZm8gPSBjcmVhdGVDYXB0dXJlZFZhbHVlKGVycm9yLCBzb3VyY2VGaWJlcik7XG4gICAgICAgIHZhciB1cGRhdGUgPSBjcmVhdGVDbGFzc0Vycm9yVXBkYXRlKGZpYmVyLCBlcnJvckluZm8sIFN5bmNMYW5lKTtcbiAgICAgICAgZW5xdWV1ZVVwZGF0ZShmaWJlciwgdXBkYXRlKTtcbiAgICAgICAgdmFyIGV2ZW50VGltZSA9IHJlcXVlc3RFdmVudFRpbWUoKTtcbiAgICAgICAgdmFyIHJvb3QgPSBtYXJrVXBkYXRlTGFuZUZyb21GaWJlclRvUm9vdChmaWJlciwgU3luY0xhbmUpO1xuXG4gICAgICAgIGlmIChyb290ICE9PSBudWxsKSB7XG4gICAgICAgICAgbWFya1Jvb3RVcGRhdGVkKHJvb3QsIFN5bmNMYW5lLCBldmVudFRpbWUpO1xuICAgICAgICAgIGVuc3VyZVJvb3RJc1NjaGVkdWxlZChyb290LCBldmVudFRpbWUpO1xuICAgICAgICAgIHNjaGVkdWxlUGVuZGluZ0ludGVyYWN0aW9ucyhyb290LCBTeW5jTGFuZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gVGhpcyBjb21wb25lbnQgaGFzIGFscmVhZHkgYmVlbiB1bm1vdW50ZWQuXG4gICAgICAgICAgLy8gV2UgY2FuJ3Qgc2NoZWR1bGUgYW55IGZvbGxvdyB1cCB3b3JrIGZvciB0aGUgcm9vdCBiZWNhdXNlIHRoZSBmaWJlciBpcyBhbHJlYWR5IHVubW91bnRlZCxcbiAgICAgICAgICAvLyBidXQgd2UgY2FuIHN0aWxsIGNhbGwgdGhlIGxvZy1vbmx5IGJvdW5kYXJ5IHNvIHRoZSBlcnJvciBpc24ndCBzd2FsbG93ZWQuXG4gICAgICAgICAgLy9cbiAgICAgICAgICAvLyBUT0RPIFRoaXMgaXMgb25seSBhIHRlbXBvcmFyeSBiYW5kYWlkIGZvciB0aGUgb2xkIHJlY29uY2lsZXIgZm9yay5cbiAgICAgICAgICAvLyBXZSBjYW4gZGVsZXRlIHRoaXMgc3BlY2lhbCBjYXNlIG9uY2UgdGhlIG5ldyBmb3JrIGlzIG1lcmdlZC5cbiAgICAgICAgICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudERpZENhdGNoID09PSAnZnVuY3Rpb24nICYmICFpc0FscmVhZHlGYWlsZWRMZWdhY3lFcnJvckJvdW5kYXJ5KGluc3RhbmNlKSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgaW5zdGFuY2UuY29tcG9uZW50RGlkQ2F0Y2goZXJyb3IsIGVycm9ySW5mbyk7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnJvclRvSWdub3JlKSB7Ly8gVE9ETyBJZ25vcmUgdGhpcyBlcnJvcj8gUmV0aHJvdyBpdD9cbiAgICAgICAgICAgICAgLy8gVGhpcyBpcyBraW5kIG9mIGFuIGVkZ2UgY2FzZS5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuXG4gICAgZmliZXIgPSBmaWJlci5yZXR1cm47XG4gIH1cbn1cbmZ1bmN0aW9uIHBpbmdTdXNwZW5kZWRSb290KHJvb3QsIHdha2VhYmxlLCBwaW5nZWRMYW5lcykge1xuICB2YXIgcGluZ0NhY2hlID0gcm9vdC5waW5nQ2FjaGU7XG5cbiAgaWYgKHBpbmdDYWNoZSAhPT0gbnVsbCkge1xuICAgIC8vIFRoZSB3YWtlYWJsZSByZXNvbHZlZCwgc28gd2Ugbm8gbG9uZ2VyIG5lZWQgdG8gbWVtb2l6ZSwgYmVjYXVzZSBpdCB3aWxsXG4gICAgLy8gbmV2ZXIgYmUgdGhyb3duIGFnYWluLlxuICAgIHBpbmdDYWNoZS5kZWxldGUod2FrZWFibGUpO1xuICB9XG5cbiAgdmFyIGV2ZW50VGltZSA9IHJlcXVlc3RFdmVudFRpbWUoKTtcbiAgbWFya1Jvb3RQaW5nZWQocm9vdCwgcGluZ2VkTGFuZXMpO1xuXG4gIGlmICh3b3JrSW5Qcm9ncmVzc1Jvb3QgPT09IHJvb3QgJiYgaXNTdWJzZXRPZkxhbmVzKHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzLCBwaW5nZWRMYW5lcykpIHtcbiAgICAvLyBSZWNlaXZlZCBhIHBpbmcgYXQgdGhlIHNhbWUgcHJpb3JpdHkgbGV2ZWwgYXQgd2hpY2ggd2UncmUgY3VycmVudGx5XG4gICAgLy8gcmVuZGVyaW5nLiBXZSBtaWdodCB3YW50IHRvIHJlc3RhcnQgdGhpcyByZW5kZXIuIFRoaXMgc2hvdWxkIG1pcnJvclxuICAgIC8vIHRoZSBsb2dpYyBvZiB3aGV0aGVyIG9yIG5vdCBhIHJvb3Qgc3VzcGVuZHMgb25jZSBpdCBjb21wbGV0ZXMuXG4gICAgLy8gVE9ETzogSWYgd2UncmUgcmVuZGVyaW5nIHN5bmMgZWl0aGVyIGR1ZSB0byBTeW5jLCBCYXRjaGVkIG9yIGV4cGlyZWQsXG4gICAgLy8gd2Ugc2hvdWxkIHByb2JhYmx5IG5ldmVyIHJlc3RhcnQuXG4gICAgLy8gSWYgd2UncmUgc3VzcGVuZGVkIHdpdGggZGVsYXksIG9yIGlmIGl0J3MgYSByZXRyeSwgd2UnbGwgYWx3YXlzIHN1c3BlbmRcbiAgICAvLyBzbyB3ZSBjYW4gYWx3YXlzIHJlc3RhcnQuXG4gICAgaWYgKHdvcmtJblByb2dyZXNzUm9vdEV4aXRTdGF0dXMgPT09IFJvb3RTdXNwZW5kZWRXaXRoRGVsYXkgfHwgd29ya0luUHJvZ3Jlc3NSb290RXhpdFN0YXR1cyA9PT0gUm9vdFN1c3BlbmRlZCAmJiBpbmNsdWRlc09ubHlSZXRyaWVzKHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzKSAmJiBub3coKSAtIGdsb2JhbE1vc3RSZWNlbnRGYWxsYmFja1RpbWUgPCBGQUxMQkFDS19USFJPVFRMRV9NUykge1xuICAgICAgLy8gUmVzdGFydCBmcm9tIHRoZSByb290LlxuICAgICAgcHJlcGFyZUZyZXNoU3RhY2socm9vdCwgTm9MYW5lcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEV2ZW4gdGhvdWdoIHdlIGNhbid0IHJlc3RhcnQgcmlnaHQgbm93LCB3ZSBtaWdodCBnZXQgYW5cbiAgICAgIC8vIG9wcG9ydHVuaXR5IGxhdGVyLiBTbyB3ZSBtYXJrIHRoaXMgcmVuZGVyIGFzIGhhdmluZyBhIHBpbmcuXG4gICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RQaW5nZWRMYW5lcyA9IG1lcmdlTGFuZXMod29ya0luUHJvZ3Jlc3NSb290UGluZ2VkTGFuZXMsIHBpbmdlZExhbmVzKTtcbiAgICB9XG4gIH1cblxuICBlbnN1cmVSb290SXNTY2hlZHVsZWQocm9vdCwgZXZlbnRUaW1lKTtcbiAgc2NoZWR1bGVQZW5kaW5nSW50ZXJhY3Rpb25zKHJvb3QsIHBpbmdlZExhbmVzKTtcbn1cblxuZnVuY3Rpb24gcmV0cnlUaW1lZE91dEJvdW5kYXJ5KGJvdW5kYXJ5RmliZXIsIHJldHJ5TGFuZSkge1xuICAvLyBUaGUgYm91bmRhcnkgZmliZXIgKGEgU3VzcGVuc2UgY29tcG9uZW50IG9yIFN1c3BlbnNlTGlzdCBjb21wb25lbnQpXG4gIC8vIHByZXZpb3VzbHkgd2FzIHJlbmRlcmVkIGluIGl0cyBmYWxsYmFjayBzdGF0ZS4gT25lIG9mIHRoZSBwcm9taXNlcyB0aGF0XG4gIC8vIHN1c3BlbmRlZCBpdCBoYXMgcmVzb2x2ZWQsIHdoaWNoIG1lYW5zIGF0IGxlYXN0IHBhcnQgb2YgdGhlIHRyZWUgd2FzXG4gIC8vIGxpa2VseSB1bmJsb2NrZWQuIFRyeSByZW5kZXJpbmcgYWdhaW4sIGF0IGEgbmV3IGV4cGlyYXRpb24gdGltZS5cbiAgaWYgKHJldHJ5TGFuZSA9PT0gTm9MYW5lKSB7XG4gICAgcmV0cnlMYW5lID0gcmVxdWVzdFJldHJ5TGFuZShib3VuZGFyeUZpYmVyKTtcbiAgfSAvLyBUT0RPOiBTcGVjaWFsIGNhc2UgaWRsZSBwcmlvcml0eT9cblxuXG4gIHZhciBldmVudFRpbWUgPSByZXF1ZXN0RXZlbnRUaW1lKCk7XG4gIHZhciByb290ID0gbWFya1VwZGF0ZUxhbmVGcm9tRmliZXJUb1Jvb3QoYm91bmRhcnlGaWJlciwgcmV0cnlMYW5lKTtcblxuICBpZiAocm9vdCAhPT0gbnVsbCkge1xuICAgIG1hcmtSb290VXBkYXRlZChyb290LCByZXRyeUxhbmUsIGV2ZW50VGltZSk7XG4gICAgZW5zdXJlUm9vdElzU2NoZWR1bGVkKHJvb3QsIGV2ZW50VGltZSk7XG4gICAgc2NoZWR1bGVQZW5kaW5nSW50ZXJhY3Rpb25zKHJvb3QsIHJldHJ5TGFuZSk7XG4gIH1cbn1cbmZ1bmN0aW9uIHJlc29sdmVSZXRyeVdha2VhYmxlKGJvdW5kYXJ5RmliZXIsIHdha2VhYmxlKSB7XG4gIHZhciByZXRyeUxhbmUgPSBOb0xhbmU7IC8vIERlZmF1bHRcblxuICB2YXIgcmV0cnlDYWNoZTtcblxuICB7XG4gICAgcmV0cnlDYWNoZSA9IGJvdW5kYXJ5RmliZXIuc3RhdGVOb2RlO1xuICB9XG5cbiAgaWYgKHJldHJ5Q2FjaGUgIT09IG51bGwpIHtcbiAgICAvLyBUaGUgd2FrZWFibGUgcmVzb2x2ZWQsIHNvIHdlIG5vIGxvbmdlciBuZWVkIHRvIG1lbW9pemUsIGJlY2F1c2UgaXQgd2lsbFxuICAgIC8vIG5ldmVyIGJlIHRocm93biBhZ2Fpbi5cbiAgICByZXRyeUNhY2hlLmRlbGV0ZSh3YWtlYWJsZSk7XG4gIH1cblxuICByZXRyeVRpbWVkT3V0Qm91bmRhcnkoYm91bmRhcnlGaWJlciwgcmV0cnlMYW5lKTtcbn0gLy8gQ29tcHV0ZXMgdGhlIG5leHQgSnVzdCBOb3RpY2VhYmxlIERpZmZlcmVuY2UgKEpORCkgYm91bmRhcnkuXG4vLyBUaGUgdGhlb3J5IGlzIHRoYXQgYSBwZXJzb24gY2FuJ3QgdGVsbCB0aGUgZGlmZmVyZW5jZSBiZXR3ZWVuIHNtYWxsIGRpZmZlcmVuY2VzIGluIHRpbWUuXG4vLyBUaGVyZWZvcmUsIGlmIHdlIHdhaXQgYSBiaXQgbG9uZ2VyIHRoYW4gbmVjZXNzYXJ5IHRoYXQgd29uJ3QgdHJhbnNsYXRlIHRvIGEgbm90aWNlYWJsZVxuLy8gZGlmZmVyZW5jZSBpbiB0aGUgZXhwZXJpZW5jZS4gSG93ZXZlciwgd2FpdGluZyBmb3IgbG9uZ2VyIG1pZ2h0IG1lYW4gdGhhdCB3ZSBjYW4gYXZvaWRcbi8vIHNob3dpbmcgYW4gaW50ZXJtZWRpYXRlIGxvYWRpbmcgc3RhdGUuIFRoZSBsb25nZXIgd2UgaGF2ZSBhbHJlYWR5IHdhaXRlZCwgdGhlIGhhcmRlciBpdFxuLy8gaXMgdG8gdGVsbCBzbWFsbCBkaWZmZXJlbmNlcyBpbiB0aW1lLiBUaGVyZWZvcmUsIHRoZSBsb25nZXIgd2UndmUgYWxyZWFkeSB3YWl0ZWQsXG4vLyB0aGUgbG9uZ2VyIHdlIGNhbiB3YWl0IGFkZGl0aW9uYWxseS4gQXQgc29tZSBwb2ludCB3ZSBoYXZlIHRvIGdpdmUgdXAgdGhvdWdoLlxuLy8gV2UgcGljayBhIHRyYWluIG1vZGVsIHdoZXJlIHRoZSBuZXh0IGJvdW5kYXJ5IGNvbW1pdHMgYXQgYSBjb25zaXN0ZW50IHNjaGVkdWxlLlxuLy8gVGhlc2UgcGFydGljdWxhciBudW1iZXJzIGFyZSB2YWd1ZSBlc3RpbWF0ZXMuIFdlIGV4cGVjdCB0byBhZGp1c3QgdGhlbSBiYXNlZCBvbiByZXNlYXJjaC5cblxuZnVuY3Rpb24gam5kKHRpbWVFbGFwc2VkKSB7XG4gIHJldHVybiB0aW1lRWxhcHNlZCA8IDEyMCA/IDEyMCA6IHRpbWVFbGFwc2VkIDwgNDgwID8gNDgwIDogdGltZUVsYXBzZWQgPCAxMDgwID8gMTA4MCA6IHRpbWVFbGFwc2VkIDwgMTkyMCA/IDE5MjAgOiB0aW1lRWxhcHNlZCA8IDMwMDAgPyAzMDAwIDogdGltZUVsYXBzZWQgPCA0MzIwID8gNDMyMCA6IGNlaWwodGltZUVsYXBzZWQgLyAxOTYwKSAqIDE5NjA7XG59XG5cbmZ1bmN0aW9uIGNoZWNrRm9yTmVzdGVkVXBkYXRlcygpIHtcbiAgaWYgKG5lc3RlZFVwZGF0ZUNvdW50ID4gTkVTVEVEX1VQREFURV9MSU1JVCkge1xuICAgIG5lc3RlZFVwZGF0ZUNvdW50ID0gMDtcbiAgICByb290V2l0aE5lc3RlZFVwZGF0ZXMgPSBudWxsO1xuXG4gICAge1xuICAgICAge1xuICAgICAgICB0aHJvdyBFcnJvciggXCJNYXhpbXVtIHVwZGF0ZSBkZXB0aCBleGNlZWRlZC4gVGhpcyBjYW4gaGFwcGVuIHdoZW4gYSBjb21wb25lbnQgcmVwZWF0ZWRseSBjYWxscyBzZXRTdGF0ZSBpbnNpZGUgY29tcG9uZW50V2lsbFVwZGF0ZSBvciBjb21wb25lbnREaWRVcGRhdGUuIFJlYWN0IGxpbWl0cyB0aGUgbnVtYmVyIG9mIG5lc3RlZCB1cGRhdGVzIHRvIHByZXZlbnQgaW5maW5pdGUgbG9vcHMuXCIgKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB7XG4gICAgaWYgKG5lc3RlZFBhc3NpdmVVcGRhdGVDb3VudCA+IE5FU1RFRF9QQVNTSVZFX1VQREFURV9MSU1JVCkge1xuICAgICAgbmVzdGVkUGFzc2l2ZVVwZGF0ZUNvdW50ID0gMDtcblxuICAgICAgZXJyb3IoJ01heGltdW0gdXBkYXRlIGRlcHRoIGV4Y2VlZGVkLiBUaGlzIGNhbiBoYXBwZW4gd2hlbiBhIGNvbXBvbmVudCAnICsgXCJjYWxscyBzZXRTdGF0ZSBpbnNpZGUgdXNlRWZmZWN0LCBidXQgdXNlRWZmZWN0IGVpdGhlciBkb2Vzbid0IFwiICsgJ2hhdmUgYSBkZXBlbmRlbmN5IGFycmF5LCBvciBvbmUgb2YgdGhlIGRlcGVuZGVuY2llcyBjaGFuZ2VzIG9uICcgKyAnZXZlcnkgcmVuZGVyLicpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBmbHVzaFJlbmRlclBoYXNlU3RyaWN0TW9kZVdhcm5pbmdzSW5ERVYoKSB7XG4gIHtcbiAgICBSZWFjdFN0cmljdE1vZGVXYXJuaW5ncy5mbHVzaExlZ2FjeUNvbnRleHRXYXJuaW5nKCk7XG5cbiAgICB7XG4gICAgICBSZWFjdFN0cmljdE1vZGVXYXJuaW5ncy5mbHVzaFBlbmRpbmdVbnNhZmVMaWZlY3ljbGVXYXJuaW5ncygpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgZGlkV2FyblN0YXRlVXBkYXRlRm9yTm90WWV0TW91bnRlZENvbXBvbmVudCA9IG51bGw7XG5cbmZ1bmN0aW9uIHdhcm5BYm91dFVwZGF0ZU9uTm90WWV0TW91bnRlZEZpYmVySW5ERVYoZmliZXIpIHtcbiAge1xuICAgIGlmICgoZXhlY3V0aW9uQ29udGV4dCAmIFJlbmRlckNvbnRleHQpICE9PSBOb0NvbnRleHQpIHtcbiAgICAgIC8vIFdlIGxldCB0aGUgb3RoZXIgd2FybmluZyBhYm91dCByZW5kZXIgcGhhc2UgdXBkYXRlcyBkZWFsIHdpdGggdGhpcyBvbmUuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKCEoZmliZXIubW9kZSAmIChCbG9ja2luZ01vZGUgfCBDb25jdXJyZW50TW9kZSkpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHRhZyA9IGZpYmVyLnRhZztcblxuICAgIGlmICh0YWcgIT09IEluZGV0ZXJtaW5hdGVDb21wb25lbnQgJiYgdGFnICE9PSBIb3N0Um9vdCAmJiB0YWcgIT09IENsYXNzQ29tcG9uZW50ICYmIHRhZyAhPT0gRnVuY3Rpb25Db21wb25lbnQgJiYgdGFnICE9PSBGb3J3YXJkUmVmICYmIHRhZyAhPT0gTWVtb0NvbXBvbmVudCAmJiB0YWcgIT09IFNpbXBsZU1lbW9Db21wb25lbnQgJiYgdGFnICE9PSBCbG9jaykge1xuICAgICAgLy8gT25seSB3YXJuIGZvciB1c2VyLWRlZmluZWQgY29tcG9uZW50cywgbm90IGludGVybmFsIG9uZXMgbGlrZSBTdXNwZW5zZS5cbiAgICAgIHJldHVybjtcbiAgICB9IC8vIFdlIHNob3cgdGhlIHdob2xlIHN0YWNrIGJ1dCBkZWR1cGUgb24gdGhlIHRvcCBjb21wb25lbnQncyBuYW1lIGJlY2F1c2VcbiAgICAvLyB0aGUgcHJvYmxlbWF0aWMgY29kZSBhbG1vc3QgYWx3YXlzIGxpZXMgaW5zaWRlIHRoYXQgY29tcG9uZW50LlxuXG5cbiAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWUoZmliZXIudHlwZSkgfHwgJ1JlYWN0Q29tcG9uZW50JztcblxuICAgIGlmIChkaWRXYXJuU3RhdGVVcGRhdGVGb3JOb3RZZXRNb3VudGVkQ29tcG9uZW50ICE9PSBudWxsKSB7XG4gICAgICBpZiAoZGlkV2FyblN0YXRlVXBkYXRlRm9yTm90WWV0TW91bnRlZENvbXBvbmVudC5oYXMoY29tcG9uZW50TmFtZSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBkaWRXYXJuU3RhdGVVcGRhdGVGb3JOb3RZZXRNb3VudGVkQ29tcG9uZW50LmFkZChjb21wb25lbnROYW1lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGlkV2FyblN0YXRlVXBkYXRlRm9yTm90WWV0TW91bnRlZENvbXBvbmVudCA9IG5ldyBTZXQoW2NvbXBvbmVudE5hbWVdKTtcbiAgICB9XG5cbiAgICB2YXIgcHJldmlvdXNGaWJlciA9IGN1cnJlbnQ7XG5cbiAgICB0cnkge1xuICAgICAgc2V0Q3VycmVudEZpYmVyKGZpYmVyKTtcblxuICAgICAgZXJyb3IoXCJDYW4ndCBwZXJmb3JtIGEgUmVhY3Qgc3RhdGUgdXBkYXRlIG9uIGEgY29tcG9uZW50IHRoYXQgaGFzbid0IG1vdW50ZWQgeWV0LiBcIiArICdUaGlzIGluZGljYXRlcyB0aGF0IHlvdSBoYXZlIGEgc2lkZS1lZmZlY3QgaW4geW91ciByZW5kZXIgZnVuY3Rpb24gdGhhdCAnICsgJ2FzeW5jaHJvbm91c2x5IGxhdGVyIGNhbGxzIHRyaWVzIHRvIHVwZGF0ZSB0aGUgY29tcG9uZW50LiBNb3ZlIHRoaXMgd29yayB0byAnICsgJ3VzZUVmZmVjdCBpbnN0ZWFkLicpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBpZiAocHJldmlvdXNGaWJlcikge1xuICAgICAgICBzZXRDdXJyZW50RmliZXIoZmliZXIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzZXRDdXJyZW50RmliZXIoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxudmFyIGRpZFdhcm5TdGF0ZVVwZGF0ZUZvclVubW91bnRlZENvbXBvbmVudCA9IG51bGw7XG5cbmZ1bmN0aW9uIHdhcm5BYm91dFVwZGF0ZU9uVW5tb3VudGVkRmliZXJJbkRFVihmaWJlcikge1xuICB7XG4gICAgdmFyIHRhZyA9IGZpYmVyLnRhZztcblxuICAgIGlmICh0YWcgIT09IEhvc3RSb290ICYmIHRhZyAhPT0gQ2xhc3NDb21wb25lbnQgJiYgdGFnICE9PSBGdW5jdGlvbkNvbXBvbmVudCAmJiB0YWcgIT09IEZvcndhcmRSZWYgJiYgdGFnICE9PSBNZW1vQ29tcG9uZW50ICYmIHRhZyAhPT0gU2ltcGxlTWVtb0NvbXBvbmVudCAmJiB0YWcgIT09IEJsb2NrKSB7XG4gICAgICAvLyBPbmx5IHdhcm4gZm9yIHVzZXItZGVmaW5lZCBjb21wb25lbnRzLCBub3QgaW50ZXJuYWwgb25lcyBsaWtlIFN1c3BlbnNlLlxuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gSWYgdGhlcmUgYXJlIHBlbmRpbmcgcGFzc2l2ZSBlZmZlY3RzIHVubW91bnRzIGZvciB0aGlzIEZpYmVyLFxuICAgIC8vIHdlIGNhbiBhc3N1bWUgdGhhdCB0aGV5IHdvdWxkIGhhdmUgcHJldmVudGVkIHRoaXMgdXBkYXRlLlxuXG5cbiAgICBpZiAoKGZpYmVyLmZsYWdzICYgUGFzc2l2ZVVubW91bnRQZW5kaW5nRGV2KSAhPT0gTm9GbGFncykge1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gV2Ugc2hvdyB0aGUgd2hvbGUgc3RhY2sgYnV0IGRlZHVwZSBvbiB0aGUgdG9wIGNvbXBvbmVudCdzIG5hbWUgYmVjYXVzZVxuICAgIC8vIHRoZSBwcm9ibGVtYXRpYyBjb2RlIGFsbW9zdCBhbHdheXMgbGllcyBpbnNpZGUgdGhhdCBjb21wb25lbnQuXG5cblxuICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZShmaWJlci50eXBlKSB8fCAnUmVhY3RDb21wb25lbnQnO1xuXG4gICAgaWYgKGRpZFdhcm5TdGF0ZVVwZGF0ZUZvclVubW91bnRlZENvbXBvbmVudCAhPT0gbnVsbCkge1xuICAgICAgaWYgKGRpZFdhcm5TdGF0ZVVwZGF0ZUZvclVubW91bnRlZENvbXBvbmVudC5oYXMoY29tcG9uZW50TmFtZSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBkaWRXYXJuU3RhdGVVcGRhdGVGb3JVbm1vdW50ZWRDb21wb25lbnQuYWRkKGNvbXBvbmVudE5hbWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBkaWRXYXJuU3RhdGVVcGRhdGVGb3JVbm1vdW50ZWRDb21wb25lbnQgPSBuZXcgU2V0KFtjb21wb25lbnROYW1lXSk7XG4gICAgfVxuXG4gICAgaWYgKGlzRmx1c2hpbmdQYXNzaXZlRWZmZWN0cykgOyBlbHNlIHtcbiAgICAgIHZhciBwcmV2aW91c0ZpYmVyID0gY3VycmVudDtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgc2V0Q3VycmVudEZpYmVyKGZpYmVyKTtcblxuICAgICAgICBlcnJvcihcIkNhbid0IHBlcmZvcm0gYSBSZWFjdCBzdGF0ZSB1cGRhdGUgb24gYW4gdW5tb3VudGVkIGNvbXBvbmVudC4gVGhpcyBcIiArICdpcyBhIG5vLW9wLCBidXQgaXQgaW5kaWNhdGVzIGEgbWVtb3J5IGxlYWsgaW4geW91ciBhcHBsaWNhdGlvbi4gVG8gJyArICdmaXgsIGNhbmNlbCBhbGwgc3Vic2NyaXB0aW9ucyBhbmQgYXN5bmNocm9ub3VzIHRhc2tzIGluICVzLicsIHRhZyA9PT0gQ2xhc3NDb21wb25lbnQgPyAndGhlIGNvbXBvbmVudFdpbGxVbm1vdW50IG1ldGhvZCcgOiAnYSB1c2VFZmZlY3QgY2xlYW51cCBmdW5jdGlvbicpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgaWYgKHByZXZpb3VzRmliZXIpIHtcbiAgICAgICAgICBzZXRDdXJyZW50RmliZXIoZmliZXIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc2V0Q3VycmVudEZpYmVyKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxudmFyIGJlZ2luV29yayQxO1xuXG57XG4gIHZhciBkdW1teUZpYmVyID0gbnVsbDtcblxuICBiZWdpbldvcmskMSA9IGZ1bmN0aW9uIChjdXJyZW50LCB1bml0T2ZXb3JrLCBsYW5lcykge1xuICAgIC8vIElmIGEgY29tcG9uZW50IHRocm93cyBhbiBlcnJvciwgd2UgcmVwbGF5IGl0IGFnYWluIGluIGEgc3luY2hyb25vdXNseVxuICAgIC8vIGRpc3BhdGNoZWQgZXZlbnQsIHNvIHRoYXQgdGhlIGRlYnVnZ2VyIHdpbGwgdHJlYXQgaXQgYXMgYW4gdW5jYXVnaHRcbiAgICAvLyBlcnJvciBTZWUgUmVhY3RFcnJvclV0aWxzIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICAgIC8vIEJlZm9yZSBlbnRlcmluZyB0aGUgYmVnaW4gcGhhc2UsIGNvcHkgdGhlIHdvcmstaW4tcHJvZ3Jlc3Mgb250byBhIGR1bW15XG4gICAgLy8gZmliZXIuIElmIGJlZ2luV29yayB0aHJvd3MsIHdlJ2xsIHVzZSB0aGlzIHRvIHJlc2V0IHRoZSBzdGF0ZS5cbiAgICB2YXIgb3JpZ2luYWxXb3JrSW5Qcm9ncmVzc0NvcHkgPSBhc3NpZ25GaWJlclByb3BlcnRpZXNJbkRFVihkdW1teUZpYmVyLCB1bml0T2ZXb3JrKTtcblxuICAgIHRyeSB7XG4gICAgICByZXR1cm4gYmVnaW5Xb3JrKGN1cnJlbnQsIHVuaXRPZldvcmssIGxhbmVzKTtcbiAgICB9IGNhdGNoIChvcmlnaW5hbEVycm9yKSB7XG4gICAgICBpZiAob3JpZ2luYWxFcnJvciAhPT0gbnVsbCAmJiB0eXBlb2Ygb3JpZ2luYWxFcnJvciA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG9yaWdpbmFsRXJyb3IudGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyBEb24ndCByZXBsYXkgcHJvbWlzZXMuIFRyZWF0IGV2ZXJ5dGhpbmcgZWxzZSBsaWtlIGFuIGVycm9yLlxuICAgICAgICB0aHJvdyBvcmlnaW5hbEVycm9yO1xuICAgICAgfSAvLyBLZWVwIHRoaXMgY29kZSBpbiBzeW5jIHdpdGggaGFuZGxlRXJyb3I7IGFueSBjaGFuZ2VzIGhlcmUgbXVzdCBoYXZlXG4gICAgICAvLyBjb3JyZXNwb25kaW5nIGNoYW5nZXMgdGhlcmUuXG5cblxuICAgICAgcmVzZXRDb250ZXh0RGVwZW5kZW5jaWVzKCk7XG4gICAgICByZXNldEhvb2tzQWZ0ZXJUaHJvdygpOyAvLyBEb24ndCByZXNldCBjdXJyZW50IGRlYnVnIGZpYmVyLCBzaW5jZSB3ZSdyZSBhYm91dCB0byB3b3JrIG9uIHRoZVxuICAgICAgLy8gc2FtZSBmaWJlciBhZ2Fpbi5cbiAgICAgIC8vIFVud2luZCB0aGUgZmFpbGVkIHN0YWNrIGZyYW1lXG5cbiAgICAgIHVud2luZEludGVycnVwdGVkV29yayh1bml0T2ZXb3JrKTsgLy8gUmVzdG9yZSB0aGUgb3JpZ2luYWwgcHJvcGVydGllcyBvZiB0aGUgZmliZXIuXG5cbiAgICAgIGFzc2lnbkZpYmVyUHJvcGVydGllc0luREVWKHVuaXRPZldvcmssIG9yaWdpbmFsV29ya0luUHJvZ3Jlc3NDb3B5KTtcblxuICAgICAgaWYgKCB1bml0T2ZXb3JrLm1vZGUgJiBQcm9maWxlTW9kZSkge1xuICAgICAgICAvLyBSZXNldCB0aGUgcHJvZmlsZXIgdGltZXIuXG4gICAgICAgIHN0YXJ0UHJvZmlsZXJUaW1lcih1bml0T2ZXb3JrKTtcbiAgICAgIH0gLy8gUnVuIGJlZ2luV29yayBhZ2Fpbi5cblxuXG4gICAgICBpbnZva2VHdWFyZGVkQ2FsbGJhY2sobnVsbCwgYmVnaW5Xb3JrLCBudWxsLCBjdXJyZW50LCB1bml0T2ZXb3JrLCBsYW5lcyk7XG5cbiAgICAgIGlmIChoYXNDYXVnaHRFcnJvcigpKSB7XG4gICAgICAgIHZhciByZXBsYXlFcnJvciA9IGNsZWFyQ2F1Z2h0RXJyb3IoKTsgLy8gYGludm9rZUd1YXJkZWRDYWxsYmFja2Agc29tZXRpbWVzIHNldHMgYW4gZXhwYW5kbyBgX3N1cHByZXNzTG9nZ2luZ2AuXG4gICAgICAgIC8vIFJldGhyb3cgdGhpcyBlcnJvciBpbnN0ZWFkIG9mIHRoZSBvcmlnaW5hbCBvbmUuXG5cbiAgICAgICAgdGhyb3cgcmVwbGF5RXJyb3I7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBUaGlzIGJyYW5jaCBpcyByZWFjaGFibGUgaWYgdGhlIHJlbmRlciBwaGFzZSBpcyBpbXB1cmUuXG4gICAgICAgIHRocm93IG9yaWdpbmFsRXJyb3I7XG4gICAgICB9XG4gICAgfVxuICB9O1xufVxuXG52YXIgZGlkV2FybkFib3V0VXBkYXRlSW5SZW5kZXIgPSBmYWxzZTtcbnZhciBkaWRXYXJuQWJvdXRVcGRhdGVJblJlbmRlckZvckFub3RoZXJDb21wb25lbnQ7XG5cbntcbiAgZGlkV2FybkFib3V0VXBkYXRlSW5SZW5kZXJGb3JBbm90aGVyQ29tcG9uZW50ID0gbmV3IFNldCgpO1xufVxuXG5mdW5jdGlvbiB3YXJuQWJvdXRSZW5kZXJQaGFzZVVwZGF0ZXNJbkRFVihmaWJlcikge1xuICB7XG4gICAgaWYgKGlzUmVuZGVyaW5nICYmIChleGVjdXRpb25Db250ZXh0ICYgUmVuZGVyQ29udGV4dCkgIT09IE5vQ29udGV4dCAmJiAhZ2V0SXNVcGRhdGluZ09wYXF1ZVZhbHVlSW5SZW5kZXJQaGFzZUluREVWKCkpIHtcbiAgICAgIHN3aXRjaCAoZmliZXIudGFnKSB7XG4gICAgICAgIGNhc2UgRnVuY3Rpb25Db21wb25lbnQ6XG4gICAgICAgIGNhc2UgRm9yd2FyZFJlZjpcbiAgICAgICAgY2FzZSBTaW1wbGVNZW1vQ29tcG9uZW50OlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHZhciByZW5kZXJpbmdDb21wb25lbnROYW1lID0gd29ya0luUHJvZ3Jlc3MgJiYgZ2V0Q29tcG9uZW50TmFtZSh3b3JrSW5Qcm9ncmVzcy50eXBlKSB8fCAnVW5rbm93bic7IC8vIERlZHVwZSBieSB0aGUgcmVuZGVyaW5nIGNvbXBvbmVudCBiZWNhdXNlIGl0J3MgdGhlIG9uZSB0aGF0IG5lZWRzIHRvIGJlIGZpeGVkLlxuXG4gICAgICAgICAgICB2YXIgZGVkdXBlS2V5ID0gcmVuZGVyaW5nQ29tcG9uZW50TmFtZTtcblxuICAgICAgICAgICAgaWYgKCFkaWRXYXJuQWJvdXRVcGRhdGVJblJlbmRlckZvckFub3RoZXJDb21wb25lbnQuaGFzKGRlZHVwZUtleSkpIHtcbiAgICAgICAgICAgICAgZGlkV2FybkFib3V0VXBkYXRlSW5SZW5kZXJGb3JBbm90aGVyQ29tcG9uZW50LmFkZChkZWR1cGVLZXkpO1xuICAgICAgICAgICAgICB2YXIgc2V0U3RhdGVDb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZShmaWJlci50eXBlKSB8fCAnVW5rbm93bic7XG5cbiAgICAgICAgICAgICAgZXJyb3IoJ0Nhbm5vdCB1cGRhdGUgYSBjb21wb25lbnQgKGAlc2ApIHdoaWxlIHJlbmRlcmluZyBhICcgKyAnZGlmZmVyZW50IGNvbXBvbmVudCAoYCVzYCkuIFRvIGxvY2F0ZSB0aGUgYmFkIHNldFN0YXRlKCkgY2FsbCBpbnNpZGUgYCVzYCwgJyArICdmb2xsb3cgdGhlIHN0YWNrIHRyYWNlIGFzIGRlc2NyaWJlZCBpbiBodHRwczovL3JlYWN0anMub3JnL2xpbmsvc2V0c3RhdGUtaW4tcmVuZGVyJywgc2V0U3RhdGVDb21wb25lbnROYW1lLCByZW5kZXJpbmdDb21wb25lbnROYW1lLCByZW5kZXJpbmdDb21wb25lbnROYW1lKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG4gICAgICAgICAge1xuICAgICAgICAgICAgaWYgKCFkaWRXYXJuQWJvdXRVcGRhdGVJblJlbmRlcikge1xuICAgICAgICAgICAgICBlcnJvcignQ2Fubm90IHVwZGF0ZSBkdXJpbmcgYW4gZXhpc3Rpbmcgc3RhdGUgdHJhbnNpdGlvbiAoc3VjaCBhcyAnICsgJ3dpdGhpbiBgcmVuZGVyYCkuIFJlbmRlciBtZXRob2RzIHNob3VsZCBiZSBhIHB1cmUgJyArICdmdW5jdGlvbiBvZiBwcm9wcyBhbmQgc3RhdGUuJyk7XG5cbiAgICAgICAgICAgICAgZGlkV2FybkFib3V0VXBkYXRlSW5SZW5kZXIgPSB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59IC8vIGEgJ3NoYXJlZCcgdmFyaWFibGUgdGhhdCBjaGFuZ2VzIHdoZW4gYWN0KCkgb3BlbnMvY2xvc2VzIGluIHRlc3RzLlxuXG5cbnZhciBJc1RoaXNSZW5kZXJlckFjdGluZyA9IHtcbiAgY3VycmVudDogZmFsc2Vcbn07XG5mdW5jdGlvbiB3YXJuSWZOb3RTY29wZWRXaXRoTWF0Y2hpbmdBY3QoZmliZXIpIHtcbiAge1xuICAgIGlmICggSXNTb21lUmVuZGVyZXJBY3RpbmcuY3VycmVudCA9PT0gdHJ1ZSAmJiBJc1RoaXNSZW5kZXJlckFjdGluZy5jdXJyZW50ICE9PSB0cnVlKSB7XG4gICAgICB2YXIgcHJldmlvdXNGaWJlciA9IGN1cnJlbnQ7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHNldEN1cnJlbnRGaWJlcihmaWJlcik7XG5cbiAgICAgICAgZXJyb3IoXCJJdCBsb29rcyBsaWtlIHlvdSdyZSB1c2luZyB0aGUgd3JvbmcgYWN0KCkgYXJvdW5kIHlvdXIgdGVzdCBpbnRlcmFjdGlvbnMuXFxuXCIgKyAnQmUgc3VyZSB0byB1c2UgdGhlIG1hdGNoaW5nIHZlcnNpb24gb2YgYWN0KCkgY29ycmVzcG9uZGluZyB0byB5b3VyIHJlbmRlcmVyOlxcblxcbicgKyAnLy8gZm9yIHJlYWN0LWRvbTpcXG4nICsgLy8gQnJlYWsgdXAgaW1wb3J0cyB0byBhdm9pZCBhY2NpZGVudGFsbHkgcGFyc2luZyB0aGVtIGFzIGRlcGVuZGVuY2llcy5cbiAgICAgICAgJ2ltcG9ydCB7YWN0fSBmcicgKyBcIm9tICdyZWFjdC1kb20vdGVzdC11dGlscyc7XFxuXCIgKyAnLy8gLi4uXFxuJyArICdhY3QoKCkgPT4gLi4uKTtcXG5cXG4nICsgJy8vIGZvciByZWFjdC10ZXN0LXJlbmRlcmVyOlxcbicgKyAvLyBCcmVhayB1cCBpbXBvcnRzIHRvIGF2b2lkIGFjY2lkZW50YWxseSBwYXJzaW5nIHRoZW0gYXMgZGVwZW5kZW5jaWVzLlxuICAgICAgICAnaW1wb3J0IFRlc3RSZW5kZXJlciBmcicgKyBcIm9tIHJlYWN0LXRlc3QtcmVuZGVyZXInO1xcblwiICsgJ2NvbnN0IHthY3R9ID0gVGVzdFJlbmRlcmVyO1xcbicgKyAnLy8gLi4uXFxuJyArICdhY3QoKCkgPT4gLi4uKTsnKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGlmIChwcmV2aW91c0ZpYmVyKSB7XG4gICAgICAgICAgc2V0Q3VycmVudEZpYmVyKGZpYmVyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXNldEN1cnJlbnRGaWJlcigpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiB3YXJuSWZOb3RDdXJyZW50bHlBY3RpbmdFZmZlY3RzSW5ERVYoZmliZXIpIHtcbiAge1xuICAgIGlmICggKGZpYmVyLm1vZGUgJiBTdHJpY3RNb2RlKSAhPT0gTm9Nb2RlICYmIElzU29tZVJlbmRlcmVyQWN0aW5nLmN1cnJlbnQgPT09IGZhbHNlICYmIElzVGhpc1JlbmRlcmVyQWN0aW5nLmN1cnJlbnQgPT09IGZhbHNlKSB7XG4gICAgICBlcnJvcignQW4gdXBkYXRlIHRvICVzIHJhbiBhbiBlZmZlY3QsIGJ1dCB3YXMgbm90IHdyYXBwZWQgaW4gYWN0KC4uLikuXFxuXFxuJyArICdXaGVuIHRlc3RpbmcsIGNvZGUgdGhhdCBjYXVzZXMgUmVhY3Qgc3RhdGUgdXBkYXRlcyBzaG91bGQgYmUgJyArICd3cmFwcGVkIGludG8gYWN0KC4uLik6XFxuXFxuJyArICdhY3QoKCkgPT4ge1xcbicgKyAnICAvKiBmaXJlIGV2ZW50cyB0aGF0IHVwZGF0ZSBzdGF0ZSAqL1xcbicgKyAnfSk7XFxuJyArICcvKiBhc3NlcnQgb24gdGhlIG91dHB1dCAqL1xcblxcbicgKyBcIlRoaXMgZW5zdXJlcyB0aGF0IHlvdSdyZSB0ZXN0aW5nIHRoZSBiZWhhdmlvciB0aGUgdXNlciB3b3VsZCBzZWUgXCIgKyAnaW4gdGhlIGJyb3dzZXIuJyArICcgTGVhcm4gbW9yZSBhdCBodHRwczovL3JlYWN0anMub3JnL2xpbmsvd3JhcC10ZXN0cy13aXRoLWFjdCcsIGdldENvbXBvbmVudE5hbWUoZmliZXIudHlwZSkpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiB3YXJuSWZOb3RDdXJyZW50bHlBY3RpbmdVcGRhdGVzSW5ERVYoZmliZXIpIHtcbiAge1xuICAgIGlmICggZXhlY3V0aW9uQ29udGV4dCA9PT0gTm9Db250ZXh0ICYmIElzU29tZVJlbmRlcmVyQWN0aW5nLmN1cnJlbnQgPT09IGZhbHNlICYmIElzVGhpc1JlbmRlcmVyQWN0aW5nLmN1cnJlbnQgPT09IGZhbHNlKSB7XG4gICAgICB2YXIgcHJldmlvdXNGaWJlciA9IGN1cnJlbnQ7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHNldEN1cnJlbnRGaWJlcihmaWJlcik7XG5cbiAgICAgICAgZXJyb3IoJ0FuIHVwZGF0ZSB0byAlcyBpbnNpZGUgYSB0ZXN0IHdhcyBub3Qgd3JhcHBlZCBpbiBhY3QoLi4uKS5cXG5cXG4nICsgJ1doZW4gdGVzdGluZywgY29kZSB0aGF0IGNhdXNlcyBSZWFjdCBzdGF0ZSB1cGRhdGVzIHNob3VsZCBiZSAnICsgJ3dyYXBwZWQgaW50byBhY3QoLi4uKTpcXG5cXG4nICsgJ2FjdCgoKSA9PiB7XFxuJyArICcgIC8qIGZpcmUgZXZlbnRzIHRoYXQgdXBkYXRlIHN0YXRlICovXFxuJyArICd9KTtcXG4nICsgJy8qIGFzc2VydCBvbiB0aGUgb3V0cHV0ICovXFxuXFxuJyArIFwiVGhpcyBlbnN1cmVzIHRoYXQgeW91J3JlIHRlc3RpbmcgdGhlIGJlaGF2aW9yIHRoZSB1c2VyIHdvdWxkIHNlZSBcIiArICdpbiB0aGUgYnJvd3Nlci4nICsgJyBMZWFybiBtb3JlIGF0IGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay93cmFwLXRlc3RzLXdpdGgtYWN0JywgZ2V0Q29tcG9uZW50TmFtZShmaWJlci50eXBlKSk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBpZiAocHJldmlvdXNGaWJlcikge1xuICAgICAgICAgIHNldEN1cnJlbnRGaWJlcihmaWJlcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzZXRDdXJyZW50RmliZXIoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG52YXIgd2FybklmTm90Q3VycmVudGx5QWN0aW5nVXBkYXRlc0luRGV2ID0gd2FybklmTm90Q3VycmVudGx5QWN0aW5nVXBkYXRlc0luREVWOyAvLyBJbiB0ZXN0cywgd2Ugd2FudCB0byBlbmZvcmNlIGEgbW9ja2VkIHNjaGVkdWxlci5cblxudmFyIGRpZFdhcm5BYm91dFVubW9ja2VkU2NoZWR1bGVyID0gZmFsc2U7IC8vIFRPRE8gQmVmb3JlIHdlIHJlbGVhc2UgY29uY3VycmVudCBtb2RlLCByZXZpc2l0IHRoaXMgYW5kIGRlY2lkZSB3aGV0aGVyIGEgbW9ja2VkXG4vLyBzY2hlZHVsZXIgaXMgdGhlIGFjdHVhbCByZWNvbW1lbmRhdGlvbi4gVGhlIGFsdGVybmF0aXZlIGNvdWxkIGJlIGEgdGVzdGluZyBidWlsZCxcbi8vIGEgbmV3IGxpYiwgb3Igd2hhdGV2ZXI7IHdlIGR1bm5vIGp1c3QgeWV0LiBUaGlzIG1lc3NhZ2UgaXMgZm9yIGVhcmx5IGFkb3B0ZXJzXG4vLyB0byBnZXQgdGhlaXIgdGVzdHMgcmlnaHQuXG5cbmZ1bmN0aW9uIHdhcm5JZlVubW9ja2VkU2NoZWR1bGVyKGZpYmVyKSB7XG4gIHtcbiAgICBpZiAoZGlkV2FybkFib3V0VW5tb2NrZWRTY2hlZHVsZXIgPT09IGZhbHNlICYmIFNjaGVkdWxlci51bnN0YWJsZV9mbHVzaEFsbFdpdGhvdXRBc3NlcnRpbmcgPT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKGZpYmVyLm1vZGUgJiBCbG9ja2luZ01vZGUgfHwgZmliZXIubW9kZSAmIENvbmN1cnJlbnRNb2RlKSB7XG4gICAgICAgIGRpZFdhcm5BYm91dFVubW9ja2VkU2NoZWR1bGVyID0gdHJ1ZTtcblxuICAgICAgICBlcnJvcignSW4gQ29uY3VycmVudCBvciBTeW5jIG1vZGVzLCB0aGUgXCJzY2hlZHVsZXJcIiBtb2R1bGUgbmVlZHMgdG8gYmUgbW9ja2VkICcgKyAndG8gZ3VhcmFudGVlIGNvbnNpc3RlbnQgYmVoYXZpb3VyIGFjcm9zcyB0ZXN0cyBhbmQgYnJvd3NlcnMuICcgKyAnRm9yIGV4YW1wbGUsIHdpdGggamVzdDogXFxuJyArIC8vIEJyZWFrIHVwIHJlcXVpcmVzIHRvIGF2b2lkIGFjY2lkZW50YWxseSBwYXJzaW5nIHRoZW0gYXMgZGVwZW5kZW5jaWVzLlxuICAgICAgICBcImplc3QubW9jaygnc2NoZWR1bGVyJywgKCkgPT4gcmVxdWlyZVwiICsgXCIoJ3NjaGVkdWxlci91bnN0YWJsZV9tb2NrJykpO1xcblxcblwiICsgJ0ZvciBtb3JlIGluZm8sIHZpc2l0IGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9tb2NrLXNjaGVkdWxlcicpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjb21wdXRlVGhyZWFkSUQocm9vdCwgbGFuZSkge1xuICAvLyBJbnRlcmFjdGlvbiB0aHJlYWRzIGFyZSB1bmlxdWUgcGVyIHJvb3QgYW5kIGV4cGlyYXRpb24gdGltZS5cbiAgLy8gTk9URTogSW50ZW50aW9uYWxseSB1bnNvdW5kIGNhc3QuIEFsbCB0aGF0IG1hdHRlcnMgaXMgdGhhdCBpdCdzIGEgbnVtYmVyXG4gIC8vIGFuZCBpdCByZXByZXNlbnRzIGEgYmF0Y2ggb2Ygd29yay4gQ291bGQgbWFrZSBhIGhlbHBlciBmdW5jdGlvbiBpbnN0ZWFkLFxuICAvLyBidXQgbWVoIHRoaXMgaXMgZmluZSBmb3Igbm93LlxuICByZXR1cm4gbGFuZSAqIDEwMDAgKyByb290LmludGVyYWN0aW9uVGhyZWFkSUQ7XG59XG5cbmZ1bmN0aW9uIG1hcmtTcGF3bmVkV29yayhsYW5lKSB7XG5cbiAgaWYgKHNwYXduZWRXb3JrRHVyaW5nUmVuZGVyID09PSBudWxsKSB7XG4gICAgc3Bhd25lZFdvcmtEdXJpbmdSZW5kZXIgPSBbbGFuZV07XG4gIH0gZWxzZSB7XG4gICAgc3Bhd25lZFdvcmtEdXJpbmdSZW5kZXIucHVzaChsYW5lKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzY2hlZHVsZUludGVyYWN0aW9ucyhyb290LCBsYW5lLCBpbnRlcmFjdGlvbnMpIHtcblxuICBpZiAoaW50ZXJhY3Rpb25zLnNpemUgPiAwKSB7XG4gICAgdmFyIHBlbmRpbmdJbnRlcmFjdGlvbk1hcCA9IHJvb3QucGVuZGluZ0ludGVyYWN0aW9uTWFwO1xuICAgIHZhciBwZW5kaW5nSW50ZXJhY3Rpb25zID0gcGVuZGluZ0ludGVyYWN0aW9uTWFwLmdldChsYW5lKTtcblxuICAgIGlmIChwZW5kaW5nSW50ZXJhY3Rpb25zICE9IG51bGwpIHtcbiAgICAgIGludGVyYWN0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChpbnRlcmFjdGlvbikge1xuICAgICAgICBpZiAoIXBlbmRpbmdJbnRlcmFjdGlvbnMuaGFzKGludGVyYWN0aW9uKSkge1xuICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgcGVuZGluZyBhc3luYyB3b3JrIGNvdW50IGZvciBwcmV2aW91c2x5IHVuc2NoZWR1bGVkIGludGVyYWN0aW9uLlxuICAgICAgICAgIGludGVyYWN0aW9uLl9fY291bnQrKztcbiAgICAgICAgfVxuXG4gICAgICAgIHBlbmRpbmdJbnRlcmFjdGlvbnMuYWRkKGludGVyYWN0aW9uKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBwZW5kaW5nSW50ZXJhY3Rpb25NYXAuc2V0KGxhbmUsIG5ldyBTZXQoaW50ZXJhY3Rpb25zKSk7IC8vIFVwZGF0ZSB0aGUgcGVuZGluZyBhc3luYyB3b3JrIGNvdW50IGZvciB0aGUgY3VycmVudCBpbnRlcmFjdGlvbnMuXG5cbiAgICAgIGludGVyYWN0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChpbnRlcmFjdGlvbikge1xuICAgICAgICBpbnRlcmFjdGlvbi5fX2NvdW50Kys7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICB2YXIgc3Vic2NyaWJlciA9IHRyYWNpbmcuX19zdWJzY3JpYmVyUmVmLmN1cnJlbnQ7XG5cbiAgICBpZiAoc3Vic2NyaWJlciAhPT0gbnVsbCkge1xuICAgICAgdmFyIHRocmVhZElEID0gY29tcHV0ZVRocmVhZElEKHJvb3QsIGxhbmUpO1xuICAgICAgc3Vic2NyaWJlci5vbldvcmtTY2hlZHVsZWQoaW50ZXJhY3Rpb25zLCB0aHJlYWRJRCk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHNjaGVkdWxlUGVuZGluZ0ludGVyYWN0aW9ucyhyb290LCBsYW5lKSB7XG5cbiAgc2NoZWR1bGVJbnRlcmFjdGlvbnMocm9vdCwgbGFuZSwgdHJhY2luZy5fX2ludGVyYWN0aW9uc1JlZi5jdXJyZW50KTtcbn1cblxuZnVuY3Rpb24gc3RhcnRXb3JrT25QZW5kaW5nSW50ZXJhY3Rpb25zKHJvb3QsIGxhbmVzKSB7XG4gIC8vIHdlIGNhbiBhY2N1cmF0ZWx5IGF0dHJpYnV0ZSB0aW1lIHNwZW50IHdvcmtpbmcgb24gaXQsIEFuZCBzbyB0aGF0IGNhc2NhZGluZ1xuICAvLyB3b3JrIHRyaWdnZXJlZCBkdXJpbmcgdGhlIHJlbmRlciBwaGFzZSB3aWxsIGJlIGFzc29jaWF0ZWQgd2l0aCBpdC5cblxuXG4gIHZhciBpbnRlcmFjdGlvbnMgPSBuZXcgU2V0KCk7XG4gIHJvb3QucGVuZGluZ0ludGVyYWN0aW9uTWFwLmZvckVhY2goZnVuY3Rpb24gKHNjaGVkdWxlZEludGVyYWN0aW9ucywgc2NoZWR1bGVkTGFuZSkge1xuICAgIGlmIChpbmNsdWRlc1NvbWVMYW5lKGxhbmVzLCBzY2hlZHVsZWRMYW5lKSkge1xuICAgICAgc2NoZWR1bGVkSW50ZXJhY3Rpb25zLmZvckVhY2goZnVuY3Rpb24gKGludGVyYWN0aW9uKSB7XG4gICAgICAgIHJldHVybiBpbnRlcmFjdGlvbnMuYWRkKGludGVyYWN0aW9uKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7IC8vIFN0b3JlIHRoZSBjdXJyZW50IHNldCBvZiBpbnRlcmFjdGlvbnMgb24gdGhlIEZpYmVyUm9vdCBmb3IgYSBmZXcgcmVhc29uczpcbiAgLy8gV2UgY2FuIHJlLXVzZSBpdCBpbiBob3QgZnVuY3Rpb25zIGxpa2UgcGVyZm9ybUNvbmN1cnJlbnRXb3JrT25Sb290KClcbiAgLy8gd2l0aG91dCBoYXZpbmcgdG8gcmVjYWxjdWxhdGUgaXQuIFdlIHdpbGwgYWxzbyB1c2UgaXQgaW4gY29tbWl0V29yaygpIHRvXG4gIC8vIHBhc3MgdG8gYW55IFByb2ZpbGVyIG9uUmVuZGVyKCkgaG9va3MuIFRoaXMgYWxzbyBwcm92aWRlcyBEZXZUb29scyB3aXRoIGFcbiAgLy8gd2F5IHRvIGFjY2VzcyBpdCB3aGVuIHRoZSBvbkNvbW1pdFJvb3QoKSBob29rIGlzIGNhbGxlZC5cblxuICByb290Lm1lbW9pemVkSW50ZXJhY3Rpb25zID0gaW50ZXJhY3Rpb25zO1xuXG4gIGlmIChpbnRlcmFjdGlvbnMuc2l6ZSA+IDApIHtcbiAgICB2YXIgc3Vic2NyaWJlciA9IHRyYWNpbmcuX19zdWJzY3JpYmVyUmVmLmN1cnJlbnQ7XG5cbiAgICBpZiAoc3Vic2NyaWJlciAhPT0gbnVsbCkge1xuICAgICAgdmFyIHRocmVhZElEID0gY29tcHV0ZVRocmVhZElEKHJvb3QsIGxhbmVzKTtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgc3Vic2NyaWJlci5vbldvcmtTdGFydGVkKGludGVyYWN0aW9ucywgdGhyZWFkSUQpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgLy8gSWYgdGhlIHN1YnNjcmliZXIgdGhyb3dzLCByZXRocm93IGl0IGluIGEgc2VwYXJhdGUgdGFza1xuICAgICAgICBzY2hlZHVsZUNhbGxiYWNrKEltbWVkaWF0ZVByaW9yaXR5JDEsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGZpbmlzaFBlbmRpbmdJbnRlcmFjdGlvbnMocm9vdCwgY29tbWl0dGVkTGFuZXMpIHtcblxuICB2YXIgcmVtYWluaW5nTGFuZXNBZnRlckNvbW1pdCA9IHJvb3QucGVuZGluZ0xhbmVzO1xuICB2YXIgc3Vic2NyaWJlcjtcblxuICB0cnkge1xuICAgIHN1YnNjcmliZXIgPSB0cmFjaW5nLl9fc3Vic2NyaWJlclJlZi5jdXJyZW50O1xuXG4gICAgaWYgKHN1YnNjcmliZXIgIT09IG51bGwgJiYgcm9vdC5tZW1vaXplZEludGVyYWN0aW9ucy5zaXplID4gMCkge1xuICAgICAgLy8gRklYTUU6IE1vcmUgdGhhbiBvbmUgbGFuZSBjYW4gZmluaXNoIGluIGEgc2luZ2xlIGNvbW1pdC5cbiAgICAgIHZhciB0aHJlYWRJRCA9IGNvbXB1dGVUaHJlYWRJRChyb290LCBjb21taXR0ZWRMYW5lcyk7XG4gICAgICBzdWJzY3JpYmVyLm9uV29ya1N0b3BwZWQocm9vdC5tZW1vaXplZEludGVyYWN0aW9ucywgdGhyZWFkSUQpO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAvLyBJZiB0aGUgc3Vic2NyaWJlciB0aHJvd3MsIHJldGhyb3cgaXQgaW4gYSBzZXBhcmF0ZSB0YXNrXG4gICAgc2NoZWR1bGVDYWxsYmFjayhJbW1lZGlhdGVQcmlvcml0eSQxLCBmdW5jdGlvbiAoKSB7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9KTtcbiAgfSBmaW5hbGx5IHtcbiAgICAvLyBDbGVhciBjb21wbGV0ZWQgaW50ZXJhY3Rpb25zIGZyb20gdGhlIHBlbmRpbmcgTWFwLlxuICAgIC8vIFVubGVzcyB0aGUgcmVuZGVyIHdhcyBzdXNwZW5kZWQgb3IgY2FzY2FkaW5nIHdvcmsgd2FzIHNjaGVkdWxlZCxcbiAgICAvLyBJbiB3aGljaCBjYXNl4oCTIGxlYXZlIHBlbmRpbmcgaW50ZXJhY3Rpb25zIHVudGlsIHRoZSBzdWJzZXF1ZW50IHJlbmRlci5cbiAgICB2YXIgcGVuZGluZ0ludGVyYWN0aW9uTWFwID0gcm9vdC5wZW5kaW5nSW50ZXJhY3Rpb25NYXA7XG4gICAgcGVuZGluZ0ludGVyYWN0aW9uTWFwLmZvckVhY2goZnVuY3Rpb24gKHNjaGVkdWxlZEludGVyYWN0aW9ucywgbGFuZSkge1xuICAgICAgLy8gT25seSBkZWNyZW1lbnQgdGhlIHBlbmRpbmcgaW50ZXJhY3Rpb24gY291bnQgaWYgd2UncmUgZG9uZS5cbiAgICAgIC8vIElmIHRoZXJlJ3Mgc3RpbGwgd29yayBhdCB0aGUgY3VycmVudCBwcmlvcml0eSxcbiAgICAgIC8vIFRoYXQgaW5kaWNhdGVzIHRoYXQgd2UgYXJlIHdhaXRpbmcgZm9yIHN1c3BlbnNlIGRhdGEuXG4gICAgICBpZiAoIWluY2x1ZGVzU29tZUxhbmUocmVtYWluaW5nTGFuZXNBZnRlckNvbW1pdCwgbGFuZSkpIHtcbiAgICAgICAgcGVuZGluZ0ludGVyYWN0aW9uTWFwLmRlbGV0ZShsYW5lKTtcbiAgICAgICAgc2NoZWR1bGVkSW50ZXJhY3Rpb25zLmZvckVhY2goZnVuY3Rpb24gKGludGVyYWN0aW9uKSB7XG4gICAgICAgICAgaW50ZXJhY3Rpb24uX19jb3VudC0tO1xuXG4gICAgICAgICAgaWYgKHN1YnNjcmliZXIgIT09IG51bGwgJiYgaW50ZXJhY3Rpb24uX19jb3VudCA9PT0gMCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgc3Vic2NyaWJlci5vbkludGVyYWN0aW9uU2NoZWR1bGVkV29ya0NvbXBsZXRlZChpbnRlcmFjdGlvbik7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAvLyBJZiB0aGUgc3Vic2NyaWJlciB0aHJvd3MsIHJldGhyb3cgaXQgaW4gYSBzZXBhcmF0ZSB0YXNrXG4gICAgICAgICAgICAgIHNjaGVkdWxlQ2FsbGJhY2soSW1tZWRpYXRlUHJpb3JpdHkkMSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59IC8vIGBhY3RgIHRlc3RpbmcgQVBJXG5cbmZ1bmN0aW9uIHNob3VsZEZvcmNlRmx1c2hGYWxsYmFja3NJbkRFVigpIHtcbiAgLy8gTmV2ZXIgZm9yY2UgZmx1c2ggaW4gcHJvZHVjdGlvbi4gVGhpcyBmdW5jdGlvbiBzaG91bGQgZ2V0IHN0cmlwcGVkIG91dC5cbiAgcmV0dXJuICBhY3RpbmdVcGRhdGVzU2NvcGVEZXB0aCA+IDA7XG59XG4vLyBzbyB3ZSBjYW4gdGVsbCBpZiBhbnkgYXN5bmMgYWN0KCkgY2FsbHMgdHJ5IHRvIHJ1biBpbiBwYXJhbGxlbC5cblxuXG52YXIgYWN0aW5nVXBkYXRlc1Njb3BlRGVwdGggPSAwO1xuXG5mdW5jdGlvbiBkZXRhY2hGaWJlckFmdGVyRWZmZWN0cyhmaWJlcikge1xuICBmaWJlci5zaWJsaW5nID0gbnVsbDtcbiAgZmliZXIuc3RhdGVOb2RlID0gbnVsbDtcbn1cblxudmFyIHJlc29sdmVGYW1pbHkgPSBudWxsOyAvLyAkRmxvd0ZpeE1lIEZsb3cgZ2V0cyBjb25mdXNlZCBieSBhIFdlYWtTZXQgZmVhdHVyZSBjaGVjayBiZWxvdy5cblxudmFyIGZhaWxlZEJvdW5kYXJpZXMgPSBudWxsO1xudmFyIHNldFJlZnJlc2hIYW5kbGVyID0gZnVuY3Rpb24gKGhhbmRsZXIpIHtcbiAge1xuICAgIHJlc29sdmVGYW1pbHkgPSBoYW5kbGVyO1xuICB9XG59O1xuZnVuY3Rpb24gcmVzb2x2ZUZ1bmN0aW9uRm9ySG90UmVsb2FkaW5nKHR5cGUpIHtcbiAge1xuICAgIGlmIChyZXNvbHZlRmFtaWx5ID09PSBudWxsKSB7XG4gICAgICAvLyBIb3QgcmVsb2FkaW5nIGlzIGRpc2FibGVkLlxuICAgICAgcmV0dXJuIHR5cGU7XG4gICAgfVxuXG4gICAgdmFyIGZhbWlseSA9IHJlc29sdmVGYW1pbHkodHlwZSk7XG5cbiAgICBpZiAoZmFtaWx5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB0eXBlO1xuICAgIH0gLy8gVXNlIHRoZSBsYXRlc3Qga25vd24gaW1wbGVtZW50YXRpb24uXG5cblxuICAgIHJldHVybiBmYW1pbHkuY3VycmVudDtcbiAgfVxufVxuZnVuY3Rpb24gcmVzb2x2ZUNsYXNzRm9ySG90UmVsb2FkaW5nKHR5cGUpIHtcbiAgLy8gTm8gaW1wbGVtZW50YXRpb24gZGlmZmVyZW5jZXMuXG4gIHJldHVybiByZXNvbHZlRnVuY3Rpb25Gb3JIb3RSZWxvYWRpbmcodHlwZSk7XG59XG5mdW5jdGlvbiByZXNvbHZlRm9yd2FyZFJlZkZvckhvdFJlbG9hZGluZyh0eXBlKSB7XG4gIHtcbiAgICBpZiAocmVzb2x2ZUZhbWlseSA9PT0gbnVsbCkge1xuICAgICAgLy8gSG90IHJlbG9hZGluZyBpcyBkaXNhYmxlZC5cbiAgICAgIHJldHVybiB0eXBlO1xuICAgIH1cblxuICAgIHZhciBmYW1pbHkgPSByZXNvbHZlRmFtaWx5KHR5cGUpO1xuXG4gICAgaWYgKGZhbWlseSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBDaGVjayBpZiB3ZSdyZSBkZWFsaW5nIHdpdGggYSByZWFsIGZvcndhcmRSZWYuIERvbid0IHdhbnQgdG8gY3Jhc2ggZWFybHkuXG4gICAgICBpZiAodHlwZSAhPT0gbnVsbCAmJiB0eXBlICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIHR5cGUucmVuZGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIEZvcndhcmRSZWYgaXMgc3BlY2lhbCBiZWNhdXNlIGl0cyByZXNvbHZlZCAudHlwZSBpcyBhbiBvYmplY3QsXG4gICAgICAgIC8vIGJ1dCBpdCdzIHBvc3NpYmxlIHRoYXQgd2Ugb25seSBoYXZlIGl0cyBpbm5lciByZW5kZXIgZnVuY3Rpb24gaW4gdGhlIG1hcC5cbiAgICAgICAgLy8gSWYgdGhhdCBpbm5lciByZW5kZXIgZnVuY3Rpb24gaXMgZGlmZmVyZW50LCB3ZSdsbCBidWlsZCBhIG5ldyBmb3J3YXJkUmVmIHR5cGUuXG4gICAgICAgIHZhciBjdXJyZW50UmVuZGVyID0gcmVzb2x2ZUZ1bmN0aW9uRm9ySG90UmVsb2FkaW5nKHR5cGUucmVuZGVyKTtcblxuICAgICAgICBpZiAodHlwZS5yZW5kZXIgIT09IGN1cnJlbnRSZW5kZXIpIHtcbiAgICAgICAgICB2YXIgc3ludGhldGljVHlwZSA9IHtcbiAgICAgICAgICAgICQkdHlwZW9mOiBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFLFxuICAgICAgICAgICAgcmVuZGVyOiBjdXJyZW50UmVuZGVyXG4gICAgICAgICAgfTtcblxuICAgICAgICAgIGlmICh0eXBlLmRpc3BsYXlOYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHN5bnRoZXRpY1R5cGUuZGlzcGxheU5hbWUgPSB0eXBlLmRpc3BsYXlOYW1lO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBzeW50aGV0aWNUeXBlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0eXBlO1xuICAgIH0gLy8gVXNlIHRoZSBsYXRlc3Qga25vd24gaW1wbGVtZW50YXRpb24uXG5cblxuICAgIHJldHVybiBmYW1pbHkuY3VycmVudDtcbiAgfVxufVxuZnVuY3Rpb24gaXNDb21wYXRpYmxlRmFtaWx5Rm9ySG90UmVsb2FkaW5nKGZpYmVyLCBlbGVtZW50KSB7XG4gIHtcbiAgICBpZiAocmVzb2x2ZUZhbWlseSA9PT0gbnVsbCkge1xuICAgICAgLy8gSG90IHJlbG9hZGluZyBpcyBkaXNhYmxlZC5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgcHJldlR5cGUgPSBmaWJlci5lbGVtZW50VHlwZTtcbiAgICB2YXIgbmV4dFR5cGUgPSBlbGVtZW50LnR5cGU7IC8vIElmIHdlIGdvdCBoZXJlLCB3ZSBrbm93IHR5cGVzIGFyZW4ndCA9PT0gZXF1YWwuXG5cbiAgICB2YXIgbmVlZHNDb21wYXJlRmFtaWxpZXMgPSBmYWxzZTtcbiAgICB2YXIgJCR0eXBlb2ZOZXh0VHlwZSA9IHR5cGVvZiBuZXh0VHlwZSA9PT0gJ29iamVjdCcgJiYgbmV4dFR5cGUgIT09IG51bGwgPyBuZXh0VHlwZS4kJHR5cGVvZiA6IG51bGw7XG5cbiAgICBzd2l0Y2ggKGZpYmVyLnRhZykge1xuICAgICAgY2FzZSBDbGFzc0NvbXBvbmVudDpcbiAgICAgICAge1xuICAgICAgICAgIGlmICh0eXBlb2YgbmV4dFR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIG5lZWRzQ29tcGFyZUZhbWlsaWVzID0gdHJ1ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIEZ1bmN0aW9uQ29tcG9uZW50OlxuICAgICAgICB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBuZXh0VHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgbmVlZHNDb21wYXJlRmFtaWxpZXMgPSB0cnVlO1xuICAgICAgICAgIH0gZWxzZSBpZiAoJCR0eXBlb2ZOZXh0VHlwZSA9PT0gUkVBQ1RfTEFaWV9UWVBFKSB7XG4gICAgICAgICAgICAvLyBXZSBkb24ndCBrbm93IHRoZSBpbm5lciB0eXBlIHlldC5cbiAgICAgICAgICAgIC8vIFdlJ3JlIGdvaW5nIHRvIGFzc3VtZSB0aGF0IHRoZSBsYXp5IGlubmVyIHR5cGUgaXMgc3RhYmxlLFxuICAgICAgICAgICAgLy8gYW5kIHNvIGl0IGlzIHN1ZmZpY2llbnQgdG8gYXZvaWQgcmVjb25jaWxpbmcgaXQgYXdheS5cbiAgICAgICAgICAgIC8vIFdlJ3JlIG5vdCBnb2luZyB0byB1bndyYXAgb3IgYWN0dWFsbHkgdXNlIHRoZSBuZXcgbGF6eSB0eXBlLlxuICAgICAgICAgICAgbmVlZHNDb21wYXJlRmFtaWxpZXMgPSB0cnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgRm9yd2FyZFJlZjpcbiAgICAgICAge1xuICAgICAgICAgIGlmICgkJHR5cGVvZk5leHRUeXBlID09PSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFKSB7XG4gICAgICAgICAgICBuZWVkc0NvbXBhcmVGYW1pbGllcyA9IHRydWU7XG4gICAgICAgICAgfSBlbHNlIGlmICgkJHR5cGVvZk5leHRUeXBlID09PSBSRUFDVF9MQVpZX1RZUEUpIHtcbiAgICAgICAgICAgIG5lZWRzQ29tcGFyZUZhbWlsaWVzID0gdHJ1ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIE1lbW9Db21wb25lbnQ6XG4gICAgICBjYXNlIFNpbXBsZU1lbW9Db21wb25lbnQ6XG4gICAgICAgIHtcbiAgICAgICAgICBpZiAoJCR0eXBlb2ZOZXh0VHlwZSA9PT0gUkVBQ1RfTUVNT19UWVBFKSB7XG4gICAgICAgICAgICAvLyBUT0RPOiBpZiBpdCB3YXMgYnV0IGNhbiBubyBsb25nZXIgYmUgc2ltcGxlLFxuICAgICAgICAgICAgLy8gd2Ugc2hvdWxkbid0IHNldCB0aGlzLlxuICAgICAgICAgICAgbmVlZHNDb21wYXJlRmFtaWxpZXMgPSB0cnVlO1xuICAgICAgICAgIH0gZWxzZSBpZiAoJCR0eXBlb2ZOZXh0VHlwZSA9PT0gUkVBQ1RfTEFaWV9UWVBFKSB7XG4gICAgICAgICAgICBuZWVkc0NvbXBhcmVGYW1pbGllcyA9IHRydWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gLy8gQ2hlY2sgaWYgYm90aCB0eXBlcyBoYXZlIGEgZmFtaWx5IGFuZCBpdCdzIHRoZSBzYW1lIG9uZS5cblxuXG4gICAgaWYgKG5lZWRzQ29tcGFyZUZhbWlsaWVzKSB7XG4gICAgICAvLyBOb3RlOiBtZW1vKCkgYW5kIGZvcndhcmRSZWYoKSB3ZSdsbCBjb21wYXJlIG91dGVyIHJhdGhlciB0aGFuIGlubmVyIHR5cGUuXG4gICAgICAvLyBUaGlzIG1lYW5zIGJvdGggb2YgdGhlbSBuZWVkIHRvIGJlIHJlZ2lzdGVyZWQgdG8gcHJlc2VydmUgc3RhdGUuXG4gICAgICAvLyBJZiB3ZSB1bndyYXBwZWQgYW5kIGNvbXBhcmVkIHRoZSBpbm5lciB0eXBlcyBmb3Igd3JhcHBlcnMgaW5zdGVhZCxcbiAgICAgIC8vIHRoZW4gd2Ugd291bGQgcmlzayBmYWxzZWx5IHNheWluZyB0d28gc2VwYXJhdGUgbWVtbyhGb28pXG4gICAgICAvLyBjYWxscyBhcmUgZXF1aXZhbGVudCBiZWNhdXNlIHRoZXkgd3JhcCB0aGUgc2FtZSBGb28gZnVuY3Rpb24uXG4gICAgICB2YXIgcHJldkZhbWlseSA9IHJlc29sdmVGYW1pbHkocHJldlR5cGUpO1xuXG4gICAgICBpZiAocHJldkZhbWlseSAhPT0gdW5kZWZpbmVkICYmIHByZXZGYW1pbHkgPT09IHJlc29sdmVGYW1pbHkobmV4dFR5cGUpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuZnVuY3Rpb24gbWFya0ZhaWxlZEVycm9yQm91bmRhcnlGb3JIb3RSZWxvYWRpbmcoZmliZXIpIHtcbiAge1xuICAgIGlmIChyZXNvbHZlRmFtaWx5ID09PSBudWxsKSB7XG4gICAgICAvLyBIb3QgcmVsb2FkaW5nIGlzIGRpc2FibGVkLlxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgV2Vha1NldCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChmYWlsZWRCb3VuZGFyaWVzID09PSBudWxsKSB7XG4gICAgICBmYWlsZWRCb3VuZGFyaWVzID0gbmV3IFdlYWtTZXQoKTtcbiAgICB9XG5cbiAgICBmYWlsZWRCb3VuZGFyaWVzLmFkZChmaWJlcik7XG4gIH1cbn1cbnZhciBzY2hlZHVsZVJlZnJlc2ggPSBmdW5jdGlvbiAocm9vdCwgdXBkYXRlKSB7XG4gIHtcbiAgICBpZiAocmVzb2x2ZUZhbWlseSA9PT0gbnVsbCkge1xuICAgICAgLy8gSG90IHJlbG9hZGluZyBpcyBkaXNhYmxlZC5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgc3RhbGVGYW1pbGllcyA9IHVwZGF0ZS5zdGFsZUZhbWlsaWVzLFxuICAgICAgICB1cGRhdGVkRmFtaWxpZXMgPSB1cGRhdGUudXBkYXRlZEZhbWlsaWVzO1xuICAgIGZsdXNoUGFzc2l2ZUVmZmVjdHMoKTtcbiAgICBmbHVzaFN5bmMoZnVuY3Rpb24gKCkge1xuICAgICAgc2NoZWR1bGVGaWJlcnNXaXRoRmFtaWxpZXNSZWN1cnNpdmVseShyb290LmN1cnJlbnQsIHVwZGF0ZWRGYW1pbGllcywgc3RhbGVGYW1pbGllcyk7XG4gICAgfSk7XG4gIH1cbn07XG52YXIgc2NoZWR1bGVSb290ID0gZnVuY3Rpb24gKHJvb3QsIGVsZW1lbnQpIHtcbiAge1xuICAgIGlmIChyb290LmNvbnRleHQgIT09IGVtcHR5Q29udGV4dE9iamVjdCkge1xuICAgICAgLy8gU3VwZXIgZWRnZSBjYXNlOiByb290IGhhcyBhIGxlZ2FjeSBfcmVuZGVyU3VidHJlZSBjb250ZXh0XG4gICAgICAvLyBidXQgd2UgZG9uJ3Qga25vdyB0aGUgcGFyZW50Q29tcG9uZW50IHNvIHdlIGNhbid0IHBhc3MgaXQuXG4gICAgICAvLyBKdXN0IGlnbm9yZS4gV2UnbGwgZGVsZXRlIHRoaXMgd2l0aCBfcmVuZGVyU3VidHJlZSBjb2RlIHBhdGggbGF0ZXIuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZmx1c2hQYXNzaXZlRWZmZWN0cygpO1xuICAgIGZsdXNoU3luYyhmdW5jdGlvbiAoKSB7XG4gICAgICB1cGRhdGVDb250YWluZXIoZWxlbWVudCwgcm9vdCwgbnVsbCwgbnVsbCk7XG4gICAgfSk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIHNjaGVkdWxlRmliZXJzV2l0aEZhbWlsaWVzUmVjdXJzaXZlbHkoZmliZXIsIHVwZGF0ZWRGYW1pbGllcywgc3RhbGVGYW1pbGllcykge1xuICB7XG4gICAgdmFyIGFsdGVybmF0ZSA9IGZpYmVyLmFsdGVybmF0ZSxcbiAgICAgICAgY2hpbGQgPSBmaWJlci5jaGlsZCxcbiAgICAgICAgc2libGluZyA9IGZpYmVyLnNpYmxpbmcsXG4gICAgICAgIHRhZyA9IGZpYmVyLnRhZyxcbiAgICAgICAgdHlwZSA9IGZpYmVyLnR5cGU7XG4gICAgdmFyIGNhbmRpZGF0ZVR5cGUgPSBudWxsO1xuXG4gICAgc3dpdGNoICh0YWcpIHtcbiAgICAgIGNhc2UgRnVuY3Rpb25Db21wb25lbnQ6XG4gICAgICBjYXNlIFNpbXBsZU1lbW9Db21wb25lbnQ6XG4gICAgICBjYXNlIENsYXNzQ29tcG9uZW50OlxuICAgICAgICBjYW5kaWRhdGVUeXBlID0gdHlwZTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgRm9yd2FyZFJlZjpcbiAgICAgICAgY2FuZGlkYXRlVHlwZSA9IHR5cGUucmVuZGVyO1xuICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICBpZiAocmVzb2x2ZUZhbWlseSA9PT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCByZXNvbHZlRmFtaWx5IHRvIGJlIHNldCBkdXJpbmcgaG90IHJlbG9hZC4nKTtcbiAgICB9XG5cbiAgICB2YXIgbmVlZHNSZW5kZXIgPSBmYWxzZTtcbiAgICB2YXIgbmVlZHNSZW1vdW50ID0gZmFsc2U7XG5cbiAgICBpZiAoY2FuZGlkYXRlVHlwZSAhPT0gbnVsbCkge1xuICAgICAgdmFyIGZhbWlseSA9IHJlc29sdmVGYW1pbHkoY2FuZGlkYXRlVHlwZSk7XG5cbiAgICAgIGlmIChmYW1pbHkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoc3RhbGVGYW1pbGllcy5oYXMoZmFtaWx5KSkge1xuICAgICAgICAgIG5lZWRzUmVtb3VudCA9IHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAodXBkYXRlZEZhbWlsaWVzLmhhcyhmYW1pbHkpKSB7XG4gICAgICAgICAgaWYgKHRhZyA9PT0gQ2xhc3NDb21wb25lbnQpIHtcbiAgICAgICAgICAgIG5lZWRzUmVtb3VudCA9IHRydWU7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5lZWRzUmVuZGVyID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZmFpbGVkQm91bmRhcmllcyAhPT0gbnVsbCkge1xuICAgICAgaWYgKGZhaWxlZEJvdW5kYXJpZXMuaGFzKGZpYmVyKSB8fCBhbHRlcm5hdGUgIT09IG51bGwgJiYgZmFpbGVkQm91bmRhcmllcy5oYXMoYWx0ZXJuYXRlKSkge1xuICAgICAgICBuZWVkc1JlbW91bnQgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChuZWVkc1JlbW91bnQpIHtcbiAgICAgIGZpYmVyLl9kZWJ1Z05lZWRzUmVtb3VudCA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKG5lZWRzUmVtb3VudCB8fCBuZWVkc1JlbmRlcikge1xuICAgICAgc2NoZWR1bGVVcGRhdGVPbkZpYmVyKGZpYmVyLCBTeW5jTGFuZSwgTm9UaW1lc3RhbXApO1xuICAgIH1cblxuICAgIGlmIChjaGlsZCAhPT0gbnVsbCAmJiAhbmVlZHNSZW1vdW50KSB7XG4gICAgICBzY2hlZHVsZUZpYmVyc1dpdGhGYW1pbGllc1JlY3Vyc2l2ZWx5KGNoaWxkLCB1cGRhdGVkRmFtaWxpZXMsIHN0YWxlRmFtaWxpZXMpO1xuICAgIH1cblxuICAgIGlmIChzaWJsaW5nICE9PSBudWxsKSB7XG4gICAgICBzY2hlZHVsZUZpYmVyc1dpdGhGYW1pbGllc1JlY3Vyc2l2ZWx5KHNpYmxpbmcsIHVwZGF0ZWRGYW1pbGllcywgc3RhbGVGYW1pbGllcyk7XG4gICAgfVxuICB9XG59XG5cbnZhciBmaW5kSG9zdEluc3RhbmNlc0ZvclJlZnJlc2ggPSBmdW5jdGlvbiAocm9vdCwgZmFtaWxpZXMpIHtcbiAge1xuICAgIHZhciBob3N0SW5zdGFuY2VzID0gbmV3IFNldCgpO1xuICAgIHZhciB0eXBlcyA9IG5ldyBTZXQoZmFtaWxpZXMubWFwKGZ1bmN0aW9uIChmYW1pbHkpIHtcbiAgICAgIHJldHVybiBmYW1pbHkuY3VycmVudDtcbiAgICB9KSk7XG4gICAgZmluZEhvc3RJbnN0YW5jZXNGb3JNYXRjaGluZ0ZpYmVyc1JlY3Vyc2l2ZWx5KHJvb3QuY3VycmVudCwgdHlwZXMsIGhvc3RJbnN0YW5jZXMpO1xuICAgIHJldHVybiBob3N0SW5zdGFuY2VzO1xuICB9XG59O1xuXG5mdW5jdGlvbiBmaW5kSG9zdEluc3RhbmNlc0Zvck1hdGNoaW5nRmliZXJzUmVjdXJzaXZlbHkoZmliZXIsIHR5cGVzLCBob3N0SW5zdGFuY2VzKSB7XG4gIHtcbiAgICB2YXIgY2hpbGQgPSBmaWJlci5jaGlsZCxcbiAgICAgICAgc2libGluZyA9IGZpYmVyLnNpYmxpbmcsXG4gICAgICAgIHRhZyA9IGZpYmVyLnRhZyxcbiAgICAgICAgdHlwZSA9IGZpYmVyLnR5cGU7XG4gICAgdmFyIGNhbmRpZGF0ZVR5cGUgPSBudWxsO1xuXG4gICAgc3dpdGNoICh0YWcpIHtcbiAgICAgIGNhc2UgRnVuY3Rpb25Db21wb25lbnQ6XG4gICAgICBjYXNlIFNpbXBsZU1lbW9Db21wb25lbnQ6XG4gICAgICBjYXNlIENsYXNzQ29tcG9uZW50OlxuICAgICAgICBjYW5kaWRhdGVUeXBlID0gdHlwZTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgRm9yd2FyZFJlZjpcbiAgICAgICAgY2FuZGlkYXRlVHlwZSA9IHR5cGUucmVuZGVyO1xuICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICB2YXIgZGlkTWF0Y2ggPSBmYWxzZTtcblxuICAgIGlmIChjYW5kaWRhdGVUeXBlICE9PSBudWxsKSB7XG4gICAgICBpZiAodHlwZXMuaGFzKGNhbmRpZGF0ZVR5cGUpKSB7XG4gICAgICAgIGRpZE1hdGNoID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZGlkTWF0Y2gpIHtcbiAgICAgIC8vIFdlIGhhdmUgYSBtYXRjaC4gVGhpcyBvbmx5IGRyaWxscyBkb3duIHRvIHRoZSBjbG9zZXN0IGhvc3QgY29tcG9uZW50cy5cbiAgICAgIC8vIFRoZXJlJ3Mgbm8gbmVlZCB0byBzZWFyY2ggZGVlcGVyIGJlY2F1c2UgZm9yIHRoZSBwdXJwb3NlIG9mIGdpdmluZ1xuICAgICAgLy8gdmlzdWFsIGZlZWRiYWNrLCBcImZsYXNoaW5nXCIgb3V0ZXJtb3N0IHBhcmVudCByZWN0YW5nbGVzIGlzIHN1ZmZpY2llbnQuXG4gICAgICBmaW5kSG9zdEluc3RhbmNlc0ZvckZpYmVyU2hhbGxvd2x5KGZpYmVyLCBob3N0SW5zdGFuY2VzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSWYgdGhlcmUncyBubyBtYXRjaCwgbWF5YmUgdGhlcmUgd2lsbCBiZSBvbmUgZnVydGhlciBkb3duIGluIHRoZSBjaGlsZCB0cmVlLlxuICAgICAgaWYgKGNoaWxkICE9PSBudWxsKSB7XG4gICAgICAgIGZpbmRIb3N0SW5zdGFuY2VzRm9yTWF0Y2hpbmdGaWJlcnNSZWN1cnNpdmVseShjaGlsZCwgdHlwZXMsIGhvc3RJbnN0YW5jZXMpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzaWJsaW5nICE9PSBudWxsKSB7XG4gICAgICBmaW5kSG9zdEluc3RhbmNlc0Zvck1hdGNoaW5nRmliZXJzUmVjdXJzaXZlbHkoc2libGluZywgdHlwZXMsIGhvc3RJbnN0YW5jZXMpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBmaW5kSG9zdEluc3RhbmNlc0ZvckZpYmVyU2hhbGxvd2x5KGZpYmVyLCBob3N0SW5zdGFuY2VzKSB7XG4gIHtcbiAgICB2YXIgZm91bmRIb3N0SW5zdGFuY2VzID0gZmluZENoaWxkSG9zdEluc3RhbmNlc0ZvckZpYmVyU2hhbGxvd2x5KGZpYmVyLCBob3N0SW5zdGFuY2VzKTtcblxuICAgIGlmIChmb3VuZEhvc3RJbnN0YW5jZXMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIElmIHdlIGRpZG4ndCBmaW5kIGFueSBob3N0IGNoaWxkcmVuLCBmYWxsYmFjayB0byBjbG9zZXN0IGhvc3QgcGFyZW50LlxuXG5cbiAgICB2YXIgbm9kZSA9IGZpYmVyO1xuXG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIHN3aXRjaCAobm9kZS50YWcpIHtcbiAgICAgICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAgICAgIGhvc3RJbnN0YW5jZXMuYWRkKG5vZGUuc3RhdGVOb2RlKTtcbiAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgY2FzZSBIb3N0UG9ydGFsOlxuICAgICAgICAgIGhvc3RJbnN0YW5jZXMuYWRkKG5vZGUuc3RhdGVOb2RlLmNvbnRhaW5lckluZm8pO1xuICAgICAgICAgIHJldHVybjtcblxuICAgICAgICBjYXNlIEhvc3RSb290OlxuICAgICAgICAgIGhvc3RJbnN0YW5jZXMuYWRkKG5vZGUuc3RhdGVOb2RlLmNvbnRhaW5lckluZm8pO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKG5vZGUucmV0dXJuID09PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgdG8gcmVhY2ggcm9vdCBmaXJzdC4nKTtcbiAgICAgIH1cblxuICAgICAgbm9kZSA9IG5vZGUucmV0dXJuO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBmaW5kQ2hpbGRIb3N0SW5zdGFuY2VzRm9yRmliZXJTaGFsbG93bHkoZmliZXIsIGhvc3RJbnN0YW5jZXMpIHtcbiAge1xuICAgIHZhciBub2RlID0gZmliZXI7XG4gICAgdmFyIGZvdW5kSG9zdEluc3RhbmNlcyA9IGZhbHNlO1xuXG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIGlmIChub2RlLnRhZyA9PT0gSG9zdENvbXBvbmVudCkge1xuICAgICAgICAvLyBXZSBnb3QgYSBtYXRjaC5cbiAgICAgICAgZm91bmRIb3N0SW5zdGFuY2VzID0gdHJ1ZTtcbiAgICAgICAgaG9zdEluc3RhbmNlcy5hZGQobm9kZS5zdGF0ZU5vZGUpOyAvLyBUaGVyZSBtYXkgc3RpbGwgYmUgbW9yZSwgc28ga2VlcCBzZWFyY2hpbmcuXG4gICAgICB9IGVsc2UgaWYgKG5vZGUuY2hpbGQgIT09IG51bGwpIHtcbiAgICAgICAgbm9kZS5jaGlsZC5yZXR1cm4gPSBub2RlO1xuICAgICAgICBub2RlID0gbm9kZS5jaGlsZDtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChub2RlID09PSBmaWJlcikge1xuICAgICAgICByZXR1cm4gZm91bmRIb3N0SW5zdGFuY2VzO1xuICAgICAgfVxuXG4gICAgICB3aGlsZSAobm9kZS5zaWJsaW5nID09PSBudWxsKSB7XG4gICAgICAgIGlmIChub2RlLnJldHVybiA9PT0gbnVsbCB8fCBub2RlLnJldHVybiA9PT0gZmliZXIpIHtcbiAgICAgICAgICByZXR1cm4gZm91bmRIb3N0SW5zdGFuY2VzO1xuICAgICAgICB9XG5cbiAgICAgICAgbm9kZSA9IG5vZGUucmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBub2RlLnNpYmxpbmcucmV0dXJuID0gbm9kZS5yZXR1cm47XG4gICAgICBub2RlID0gbm9kZS5zaWJsaW5nO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxudmFyIGhhc0JhZE1hcFBvbHlmaWxsO1xuXG57XG4gIGhhc0JhZE1hcFBvbHlmaWxsID0gZmFsc2U7XG5cbiAgdHJ5IHtcbiAgICB2YXIgbm9uRXh0ZW5zaWJsZU9iamVjdCA9IE9iamVjdC5wcmV2ZW50RXh0ZW5zaW9ucyh7fSk7XG4gICAgLyogZXNsaW50LWRpc2FibGUgbm8tbmV3ICovXG5cbiAgICBuZXcgTWFwKFtbbm9uRXh0ZW5zaWJsZU9iamVjdCwgbnVsbF1dKTtcbiAgICBuZXcgU2V0KFtub25FeHRlbnNpYmxlT2JqZWN0XSk7XG4gICAgLyogZXNsaW50LWVuYWJsZSBuby1uZXcgKi9cbiAgfSBjYXRjaCAoZSkge1xuICAgIC8vIFRPRE86IENvbnNpZGVyIHdhcm5pbmcgYWJvdXQgYmFkIHBvbHlmaWxsc1xuICAgIGhhc0JhZE1hcFBvbHlmaWxsID0gdHJ1ZTtcbiAgfVxufVxuXG52YXIgZGVidWdDb3VudGVyID0gMTtcblxuZnVuY3Rpb24gRmliZXJOb2RlKHRhZywgcGVuZGluZ1Byb3BzLCBrZXksIG1vZGUpIHtcbiAgLy8gSW5zdGFuY2VcbiAgdGhpcy50YWcgPSB0YWc7XG4gIHRoaXMua2V5ID0ga2V5O1xuICB0aGlzLmVsZW1lbnRUeXBlID0gbnVsbDtcbiAgdGhpcy50eXBlID0gbnVsbDtcbiAgdGhpcy5zdGF0ZU5vZGUgPSBudWxsOyAvLyBGaWJlclxuXG4gIHRoaXMucmV0dXJuID0gbnVsbDtcbiAgdGhpcy5jaGlsZCA9IG51bGw7XG4gIHRoaXMuc2libGluZyA9IG51bGw7XG4gIHRoaXMuaW5kZXggPSAwO1xuICB0aGlzLnJlZiA9IG51bGw7XG4gIHRoaXMucGVuZGluZ1Byb3BzID0gcGVuZGluZ1Byb3BzO1xuICB0aGlzLm1lbW9pemVkUHJvcHMgPSBudWxsO1xuICB0aGlzLnVwZGF0ZVF1ZXVlID0gbnVsbDtcbiAgdGhpcy5tZW1vaXplZFN0YXRlID0gbnVsbDtcbiAgdGhpcy5kZXBlbmRlbmNpZXMgPSBudWxsO1xuICB0aGlzLm1vZGUgPSBtb2RlOyAvLyBFZmZlY3RzXG5cbiAgdGhpcy5mbGFncyA9IE5vRmxhZ3M7XG4gIHRoaXMubmV4dEVmZmVjdCA9IG51bGw7XG4gIHRoaXMuZmlyc3RFZmZlY3QgPSBudWxsO1xuICB0aGlzLmxhc3RFZmZlY3QgPSBudWxsO1xuICB0aGlzLmxhbmVzID0gTm9MYW5lcztcbiAgdGhpcy5jaGlsZExhbmVzID0gTm9MYW5lcztcbiAgdGhpcy5hbHRlcm5hdGUgPSBudWxsO1xuXG4gIHtcbiAgICAvLyBOb3RlOiBUaGUgZm9sbG93aW5nIGlzIGRvbmUgdG8gYXZvaWQgYSB2OCBwZXJmb3JtYW5jZSBjbGlmZi5cbiAgICAvL1xuICAgIC8vIEluaXRpYWxpemluZyB0aGUgZmllbGRzIGJlbG93IHRvIHNtaXMgYW5kIGxhdGVyIHVwZGF0aW5nIHRoZW0gd2l0aFxuICAgIC8vIGRvdWJsZSB2YWx1ZXMgd2lsbCBjYXVzZSBGaWJlcnMgdG8gZW5kIHVwIGhhdmluZyBzZXBhcmF0ZSBzaGFwZXMuXG4gICAgLy8gVGhpcyBiZWhhdmlvci9idWcgaGFzIHNvbWV0aGluZyB0byBkbyB3aXRoIE9iamVjdC5wcmV2ZW50RXh0ZW5zaW9uKCkuXG4gICAgLy8gRm9ydHVuYXRlbHkgdGhpcyBvbmx5IGltcGFjdHMgREVWIGJ1aWxkcy5cbiAgICAvLyBVbmZvcnR1bmF0ZWx5IGl0IG1ha2VzIFJlYWN0IHVudXNhYmx5IHNsb3cgZm9yIHNvbWUgYXBwbGljYXRpb25zLlxuICAgIC8vIFRvIHdvcmsgYXJvdW5kIHRoaXMsIGluaXRpYWxpemUgdGhlIGZpZWxkcyBiZWxvdyB3aXRoIGRvdWJsZXMuXG4gICAgLy9cbiAgICAvLyBMZWFybiBtb3JlIGFib3V0IHRoaXMgaGVyZTpcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzE0MzY1XG4gICAgLy8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9ODUzOFxuICAgIHRoaXMuYWN0dWFsRHVyYXRpb24gPSBOdW1iZXIuTmFOO1xuICAgIHRoaXMuYWN0dWFsU3RhcnRUaW1lID0gTnVtYmVyLk5hTjtcbiAgICB0aGlzLnNlbGZCYXNlRHVyYXRpb24gPSBOdW1iZXIuTmFOO1xuICAgIHRoaXMudHJlZUJhc2VEdXJhdGlvbiA9IE51bWJlci5OYU47IC8vIEl0J3Mgb2theSB0byByZXBsYWNlIHRoZSBpbml0aWFsIGRvdWJsZXMgd2l0aCBzbWlzIGFmdGVyIGluaXRpYWxpemF0aW9uLlxuICAgIC8vIFRoaXMgd29uJ3QgdHJpZ2dlciB0aGUgcGVyZm9ybWFuY2UgY2xpZmYgbWVudGlvbmVkIGFib3ZlLFxuICAgIC8vIGFuZCBpdCBzaW1wbGlmaWVzIG90aGVyIHByb2ZpbGVyIGNvZGUgKGluY2x1ZGluZyBEZXZUb29scykuXG5cbiAgICB0aGlzLmFjdHVhbER1cmF0aW9uID0gMDtcbiAgICB0aGlzLmFjdHVhbFN0YXJ0VGltZSA9IC0xO1xuICAgIHRoaXMuc2VsZkJhc2VEdXJhdGlvbiA9IDA7XG4gICAgdGhpcy50cmVlQmFzZUR1cmF0aW9uID0gMDtcbiAgfVxuXG4gIHtcbiAgICAvLyBUaGlzIGlzbid0IGRpcmVjdGx5IHVzZWQgYnV0IGlzIGhhbmR5IGZvciBkZWJ1Z2dpbmcgaW50ZXJuYWxzOlxuICAgIHRoaXMuX2RlYnVnSUQgPSBkZWJ1Z0NvdW50ZXIrKztcbiAgICB0aGlzLl9kZWJ1Z1NvdXJjZSA9IG51bGw7XG4gICAgdGhpcy5fZGVidWdPd25lciA9IG51bGw7XG4gICAgdGhpcy5fZGVidWdOZWVkc1JlbW91bnQgPSBmYWxzZTtcbiAgICB0aGlzLl9kZWJ1Z0hvb2tUeXBlcyA9IG51bGw7XG5cbiAgICBpZiAoIWhhc0JhZE1hcFBvbHlmaWxsICYmIHR5cGVvZiBPYmplY3QucHJldmVudEV4dGVuc2lvbnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIE9iamVjdC5wcmV2ZW50RXh0ZW5zaW9ucyh0aGlzKTtcbiAgICB9XG4gIH1cbn0gLy8gVGhpcyBpcyBhIGNvbnN0cnVjdG9yIGZ1bmN0aW9uLCByYXRoZXIgdGhhbiBhIFBPSk8gY29uc3RydWN0b3IsIHN0aWxsXG4vLyBwbGVhc2UgZW5zdXJlIHdlIGRvIHRoZSBmb2xsb3dpbmc6XG4vLyAxKSBOb2JvZHkgc2hvdWxkIGFkZCBhbnkgaW5zdGFuY2UgbWV0aG9kcyBvbiB0aGlzLiBJbnN0YW5jZSBtZXRob2RzIGNhbiBiZVxuLy8gICAgbW9yZSBkaWZmaWN1bHQgdG8gcHJlZGljdCB3aGVuIHRoZXkgZ2V0IG9wdGltaXplZCBhbmQgdGhleSBhcmUgYWxtb3N0XG4vLyAgICBuZXZlciBpbmxpbmVkIHByb3Blcmx5IGluIHN0YXRpYyBjb21waWxlcnMuXG4vLyAyKSBOb2JvZHkgc2hvdWxkIHJlbHkgb24gYGluc3RhbmNlb2YgRmliZXJgIGZvciB0eXBlIHRlc3RpbmcuIFdlIHNob3VsZFxuLy8gICAgYWx3YXlzIGtub3cgd2hlbiBpdCBpcyBhIGZpYmVyLlxuLy8gMykgV2UgbWlnaHQgd2FudCB0byBleHBlcmltZW50IHdpdGggdXNpbmcgbnVtZXJpYyBrZXlzIHNpbmNlIHRoZXkgYXJlIGVhc2llclxuLy8gICAgdG8gb3B0aW1pemUgaW4gYSBub24tSklUIGVudmlyb25tZW50LlxuLy8gNCkgV2UgY2FuIGVhc2lseSBnbyBmcm9tIGEgY29uc3RydWN0b3IgdG8gYSBjcmVhdGVGaWJlciBvYmplY3QgbGl0ZXJhbCBpZiB0aGF0XG4vLyAgICBpcyBmYXN0ZXIuXG4vLyA1KSBJdCBzaG91bGQgYmUgZWFzeSB0byBwb3J0IHRoaXMgdG8gYSBDIHN0cnVjdCBhbmQga2VlcCBhIEMgaW1wbGVtZW50YXRpb25cbi8vICAgIGNvbXBhdGlibGUuXG5cblxudmFyIGNyZWF0ZUZpYmVyID0gZnVuY3Rpb24gKHRhZywgcGVuZGluZ1Byb3BzLCBrZXksIG1vZGUpIHtcbiAgLy8gJEZsb3dGaXhNZTogdGhlIHNoYXBlcyBhcmUgZXhhY3QgaGVyZSBidXQgRmxvdyBkb2Vzbid0IGxpa2UgY29uc3RydWN0b3JzXG4gIHJldHVybiBuZXcgRmliZXJOb2RlKHRhZywgcGVuZGluZ1Byb3BzLCBrZXksIG1vZGUpO1xufTtcblxuZnVuY3Rpb24gc2hvdWxkQ29uc3RydWN0JDEoQ29tcG9uZW50KSB7XG4gIHZhciBwcm90b3R5cGUgPSBDb21wb25lbnQucHJvdG90eXBlO1xuICByZXR1cm4gISEocHJvdG90eXBlICYmIHByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50KTtcbn1cblxuZnVuY3Rpb24gaXNTaW1wbGVGdW5jdGlvbkNvbXBvbmVudCh0eXBlKSB7XG4gIHJldHVybiB0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJyAmJiAhc2hvdWxkQ29uc3RydWN0JDEodHlwZSkgJiYgdHlwZS5kZWZhdWx0UHJvcHMgPT09IHVuZGVmaW5lZDtcbn1cbmZ1bmN0aW9uIHJlc29sdmVMYXp5Q29tcG9uZW50VGFnKENvbXBvbmVudCkge1xuICBpZiAodHlwZW9mIENvbXBvbmVudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBzaG91bGRDb25zdHJ1Y3QkMShDb21wb25lbnQpID8gQ2xhc3NDb21wb25lbnQgOiBGdW5jdGlvbkNvbXBvbmVudDtcbiAgfSBlbHNlIGlmIChDb21wb25lbnQgIT09IHVuZGVmaW5lZCAmJiBDb21wb25lbnQgIT09IG51bGwpIHtcbiAgICB2YXIgJCR0eXBlb2YgPSBDb21wb25lbnQuJCR0eXBlb2Y7XG5cbiAgICBpZiAoJCR0eXBlb2YgPT09IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUpIHtcbiAgICAgIHJldHVybiBGb3J3YXJkUmVmO1xuICAgIH1cblxuICAgIGlmICgkJHR5cGVvZiA9PT0gUkVBQ1RfTUVNT19UWVBFKSB7XG4gICAgICByZXR1cm4gTWVtb0NvbXBvbmVudDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gSW5kZXRlcm1pbmF0ZUNvbXBvbmVudDtcbn0gLy8gVGhpcyBpcyB1c2VkIHRvIGNyZWF0ZSBhbiBhbHRlcm5hdGUgZmliZXIgdG8gZG8gd29yayBvbi5cblxuZnVuY3Rpb24gY3JlYXRlV29ya0luUHJvZ3Jlc3MoY3VycmVudCwgcGVuZGluZ1Byb3BzKSB7XG4gIHZhciB3b3JrSW5Qcm9ncmVzcyA9IGN1cnJlbnQuYWx0ZXJuYXRlO1xuXG4gIGlmICh3b3JrSW5Qcm9ncmVzcyA9PT0gbnVsbCkge1xuICAgIC8vIFdlIHVzZSBhIGRvdWJsZSBidWZmZXJpbmcgcG9vbGluZyB0ZWNobmlxdWUgYmVjYXVzZSB3ZSBrbm93IHRoYXQgd2UnbGxcbiAgICAvLyBvbmx5IGV2ZXIgbmVlZCBhdCBtb3N0IHR3byB2ZXJzaW9ucyBvZiBhIHRyZWUuIFdlIHBvb2wgdGhlIFwib3RoZXJcIiB1bnVzZWRcbiAgICAvLyBub2RlIHRoYXQgd2UncmUgZnJlZSB0byByZXVzZS4gVGhpcyBpcyBsYXppbHkgY3JlYXRlZCB0byBhdm9pZCBhbGxvY2F0aW5nXG4gICAgLy8gZXh0cmEgb2JqZWN0cyBmb3IgdGhpbmdzIHRoYXQgYXJlIG5ldmVyIHVwZGF0ZWQuIEl0IGFsc28gYWxsb3cgdXMgdG9cbiAgICAvLyByZWNsYWltIHRoZSBleHRyYSBtZW1vcnkgaWYgbmVlZGVkLlxuICAgIHdvcmtJblByb2dyZXNzID0gY3JlYXRlRmliZXIoY3VycmVudC50YWcsIHBlbmRpbmdQcm9wcywgY3VycmVudC5rZXksIGN1cnJlbnQubW9kZSk7XG4gICAgd29ya0luUHJvZ3Jlc3MuZWxlbWVudFR5cGUgPSBjdXJyZW50LmVsZW1lbnRUeXBlO1xuICAgIHdvcmtJblByb2dyZXNzLnR5cGUgPSBjdXJyZW50LnR5cGU7XG4gICAgd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlID0gY3VycmVudC5zdGF0ZU5vZGU7XG5cbiAgICB7XG4gICAgICAvLyBERVYtb25seSBmaWVsZHNcbiAgICAgIHdvcmtJblByb2dyZXNzLl9kZWJ1Z0lEID0gY3VycmVudC5fZGVidWdJRDtcbiAgICAgIHdvcmtJblByb2dyZXNzLl9kZWJ1Z1NvdXJjZSA9IGN1cnJlbnQuX2RlYnVnU291cmNlO1xuICAgICAgd29ya0luUHJvZ3Jlc3MuX2RlYnVnT3duZXIgPSBjdXJyZW50Ll9kZWJ1Z093bmVyO1xuICAgICAgd29ya0luUHJvZ3Jlc3MuX2RlYnVnSG9va1R5cGVzID0gY3VycmVudC5fZGVidWdIb29rVHlwZXM7XG4gICAgfVxuXG4gICAgd29ya0luUHJvZ3Jlc3MuYWx0ZXJuYXRlID0gY3VycmVudDtcbiAgICBjdXJyZW50LmFsdGVybmF0ZSA9IHdvcmtJblByb2dyZXNzO1xuICB9IGVsc2Uge1xuICAgIHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcyA9IHBlbmRpbmdQcm9wczsgLy8gTmVlZGVkIGJlY2F1c2UgQmxvY2tzIHN0b3JlIGRhdGEgb24gdHlwZS5cblxuICAgIHdvcmtJblByb2dyZXNzLnR5cGUgPSBjdXJyZW50LnR5cGU7IC8vIFdlIGFscmVhZHkgaGF2ZSBhbiBhbHRlcm5hdGUuXG4gICAgLy8gUmVzZXQgdGhlIGVmZmVjdCB0YWcuXG5cbiAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyA9IE5vRmxhZ3M7IC8vIFRoZSBlZmZlY3QgbGlzdCBpcyBubyBsb25nZXIgdmFsaWQuXG5cbiAgICB3b3JrSW5Qcm9ncmVzcy5uZXh0RWZmZWN0ID0gbnVsbDtcbiAgICB3b3JrSW5Qcm9ncmVzcy5maXJzdEVmZmVjdCA9IG51bGw7XG4gICAgd29ya0luUHJvZ3Jlc3MubGFzdEVmZmVjdCA9IG51bGw7XG5cbiAgICB7XG4gICAgICAvLyBXZSBpbnRlbnRpb25hbGx5IHJlc2V0LCByYXRoZXIgdGhhbiBjb3B5LCBhY3R1YWxEdXJhdGlvbiAmIGFjdHVhbFN0YXJ0VGltZS5cbiAgICAgIC8vIFRoaXMgcHJldmVudHMgdGltZSBmcm9tIGVuZGxlc3NseSBhY2N1bXVsYXRpbmcgaW4gbmV3IGNvbW1pdHMuXG4gICAgICAvLyBUaGlzIGhhcyB0aGUgZG93bnNpZGUgb2YgcmVzZXR0aW5nIHZhbHVlcyBmb3IgZGlmZmVyZW50IHByaW9yaXR5IHJlbmRlcnMsXG4gICAgICAvLyBCdXQgd29ya3MgZm9yIHlpZWxkaW5nICh0aGUgY29tbW9uIGNhc2UpIGFuZCBzaG91bGQgc3VwcG9ydCByZXN1bWluZy5cbiAgICAgIHdvcmtJblByb2dyZXNzLmFjdHVhbER1cmF0aW9uID0gMDtcbiAgICAgIHdvcmtJblByb2dyZXNzLmFjdHVhbFN0YXJ0VGltZSA9IC0xO1xuICAgIH1cbiAgfVxuXG4gIHdvcmtJblByb2dyZXNzLmNoaWxkTGFuZXMgPSBjdXJyZW50LmNoaWxkTGFuZXM7XG4gIHdvcmtJblByb2dyZXNzLmxhbmVzID0gY3VycmVudC5sYW5lcztcbiAgd29ya0luUHJvZ3Jlc3MuY2hpbGQgPSBjdXJyZW50LmNoaWxkO1xuICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFByb3BzID0gY3VycmVudC5tZW1vaXplZFByb3BzO1xuICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0gY3VycmVudC5tZW1vaXplZFN0YXRlO1xuICB3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZSA9IGN1cnJlbnQudXBkYXRlUXVldWU7IC8vIENsb25lIHRoZSBkZXBlbmRlbmNpZXMgb2JqZWN0LiBUaGlzIGlzIG11dGF0ZWQgZHVyaW5nIHRoZSByZW5kZXIgcGhhc2UsIHNvXG4gIC8vIGl0IGNhbm5vdCBiZSBzaGFyZWQgd2l0aCB0aGUgY3VycmVudCBmaWJlci5cblxuICB2YXIgY3VycmVudERlcGVuZGVuY2llcyA9IGN1cnJlbnQuZGVwZW5kZW5jaWVzO1xuICB3b3JrSW5Qcm9ncmVzcy5kZXBlbmRlbmNpZXMgPSBjdXJyZW50RGVwZW5kZW5jaWVzID09PSBudWxsID8gbnVsbCA6IHtcbiAgICBsYW5lczogY3VycmVudERlcGVuZGVuY2llcy5sYW5lcyxcbiAgICBmaXJzdENvbnRleHQ6IGN1cnJlbnREZXBlbmRlbmNpZXMuZmlyc3RDb250ZXh0XG4gIH07IC8vIFRoZXNlIHdpbGwgYmUgb3ZlcnJpZGRlbiBkdXJpbmcgdGhlIHBhcmVudCdzIHJlY29uY2lsaWF0aW9uXG5cbiAgd29ya0luUHJvZ3Jlc3Muc2libGluZyA9IGN1cnJlbnQuc2libGluZztcbiAgd29ya0luUHJvZ3Jlc3MuaW5kZXggPSBjdXJyZW50LmluZGV4O1xuICB3b3JrSW5Qcm9ncmVzcy5yZWYgPSBjdXJyZW50LnJlZjtcblxuICB7XG4gICAgd29ya0luUHJvZ3Jlc3Muc2VsZkJhc2VEdXJhdGlvbiA9IGN1cnJlbnQuc2VsZkJhc2VEdXJhdGlvbjtcbiAgICB3b3JrSW5Qcm9ncmVzcy50cmVlQmFzZUR1cmF0aW9uID0gY3VycmVudC50cmVlQmFzZUR1cmF0aW9uO1xuICB9XG5cbiAge1xuICAgIHdvcmtJblByb2dyZXNzLl9kZWJ1Z05lZWRzUmVtb3VudCA9IGN1cnJlbnQuX2RlYnVnTmVlZHNSZW1vdW50O1xuXG4gICAgc3dpdGNoICh3b3JrSW5Qcm9ncmVzcy50YWcpIHtcbiAgICAgIGNhc2UgSW5kZXRlcm1pbmF0ZUNvbXBvbmVudDpcbiAgICAgIGNhc2UgRnVuY3Rpb25Db21wb25lbnQ6XG4gICAgICBjYXNlIFNpbXBsZU1lbW9Db21wb25lbnQ6XG4gICAgICAgIHdvcmtJblByb2dyZXNzLnR5cGUgPSByZXNvbHZlRnVuY3Rpb25Gb3JIb3RSZWxvYWRpbmcoY3VycmVudC50eXBlKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG4gICAgICAgIHdvcmtJblByb2dyZXNzLnR5cGUgPSByZXNvbHZlQ2xhc3NGb3JIb3RSZWxvYWRpbmcoY3VycmVudC50eXBlKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgRm9yd2FyZFJlZjpcbiAgICAgICAgd29ya0luUHJvZ3Jlc3MudHlwZSA9IHJlc29sdmVGb3J3YXJkUmVmRm9ySG90UmVsb2FkaW5nKGN1cnJlbnQudHlwZSk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB3b3JrSW5Qcm9ncmVzcztcbn0gLy8gVXNlZCB0byByZXVzZSBhIEZpYmVyIGZvciBhIHNlY29uZCBwYXNzLlxuXG5mdW5jdGlvbiByZXNldFdvcmtJblByb2dyZXNzKHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcykge1xuICAvLyBUaGlzIHJlc2V0cyB0aGUgRmliZXIgdG8gd2hhdCBjcmVhdGVGaWJlciBvciBjcmVhdGVXb3JrSW5Qcm9ncmVzcyB3b3VsZFxuICAvLyBoYXZlIHNldCB0aGUgdmFsdWVzIHRvIGJlZm9yZSBkdXJpbmcgdGhlIGZpcnN0IHBhc3MuIElkZWFsbHkgdGhpcyB3b3VsZG4ndFxuICAvLyBiZSBuZWNlc3NhcnkgYnV0IHVuZm9ydHVuYXRlbHkgbWFueSBjb2RlIHBhdGhzIHJlYWRzIGZyb20gdGhlIHdvcmtJblByb2dyZXNzXG4gIC8vIHdoZW4gdGhleSBzaG91bGQgYmUgcmVhZGluZyBmcm9tIGN1cnJlbnQgYW5kIHdyaXRpbmcgdG8gd29ya0luUHJvZ3Jlc3MuXG4gIC8vIFdlIGFzc3VtZSBwZW5kaW5nUHJvcHMsIGluZGV4LCBrZXksIHJlZiwgcmV0dXJuIGFyZSBzdGlsbCB1bnRvdWNoZWQgdG9cbiAgLy8gYXZvaWQgZG9pbmcgYW5vdGhlciByZWNvbmNpbGlhdGlvbi5cbiAgLy8gUmVzZXQgdGhlIGVmZmVjdCB0YWcgYnV0IGtlZXAgYW55IFBsYWNlbWVudCB0YWdzLCBzaW5jZSB0aGF0J3Mgc29tZXRoaW5nXG4gIC8vIHRoYXQgY2hpbGQgZmliZXIgaXMgc2V0dGluZywgbm90IHRoZSByZWNvbmNpbGlhdGlvbi5cbiAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgJj0gUGxhY2VtZW50OyAvLyBUaGUgZWZmZWN0IGxpc3QgaXMgbm8gbG9uZ2VyIHZhbGlkLlxuXG4gIHdvcmtJblByb2dyZXNzLm5leHRFZmZlY3QgPSBudWxsO1xuICB3b3JrSW5Qcm9ncmVzcy5maXJzdEVmZmVjdCA9IG51bGw7XG4gIHdvcmtJblByb2dyZXNzLmxhc3RFZmZlY3QgPSBudWxsO1xuICB2YXIgY3VycmVudCA9IHdvcmtJblByb2dyZXNzLmFsdGVybmF0ZTtcblxuICBpZiAoY3VycmVudCA9PT0gbnVsbCkge1xuICAgIC8vIFJlc2V0IHRvIGNyZWF0ZUZpYmVyJ3MgaW5pdGlhbCB2YWx1ZXMuXG4gICAgd29ya0luUHJvZ3Jlc3MuY2hpbGRMYW5lcyA9IE5vTGFuZXM7XG4gICAgd29ya0luUHJvZ3Jlc3MubGFuZXMgPSByZW5kZXJMYW5lcztcbiAgICB3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IG51bGw7XG4gICAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcyA9IG51bGw7XG4gICAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IG51bGw7XG4gICAgd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWUgPSBudWxsO1xuICAgIHdvcmtJblByb2dyZXNzLmRlcGVuZGVuY2llcyA9IG51bGw7XG4gICAgd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlID0gbnVsbDtcblxuICAgIHtcbiAgICAgIC8vIE5vdGU6IFdlIGRvbid0IHJlc2V0IHRoZSBhY3R1YWxUaW1lIGNvdW50cy4gSXQncyB1c2VmdWwgdG8gYWNjdW11bGF0ZVxuICAgICAgLy8gYWN0dWFsIHRpbWUgYWNyb3NzIG11bHRpcGxlIHJlbmRlciBwYXNzZXMuXG4gICAgICB3b3JrSW5Qcm9ncmVzcy5zZWxmQmFzZUR1cmF0aW9uID0gMDtcbiAgICAgIHdvcmtJblByb2dyZXNzLnRyZWVCYXNlRHVyYXRpb24gPSAwO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBSZXNldCB0byB0aGUgY2xvbmVkIHZhbHVlcyB0aGF0IGNyZWF0ZVdvcmtJblByb2dyZXNzIHdvdWxkJ3ZlLlxuICAgIHdvcmtJblByb2dyZXNzLmNoaWxkTGFuZXMgPSBjdXJyZW50LmNoaWxkTGFuZXM7XG4gICAgd29ya0luUHJvZ3Jlc3MubGFuZXMgPSBjdXJyZW50LmxhbmVzO1xuICAgIHdvcmtJblByb2dyZXNzLmNoaWxkID0gY3VycmVudC5jaGlsZDtcbiAgICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFByb3BzID0gY3VycmVudC5tZW1vaXplZFByb3BzO1xuICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBjdXJyZW50Lm1lbW9pemVkU3RhdGU7XG4gICAgd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWUgPSBjdXJyZW50LnVwZGF0ZVF1ZXVlOyAvLyBOZWVkZWQgYmVjYXVzZSBCbG9ja3Mgc3RvcmUgZGF0YSBvbiB0eXBlLlxuXG4gICAgd29ya0luUHJvZ3Jlc3MudHlwZSA9IGN1cnJlbnQudHlwZTsgLy8gQ2xvbmUgdGhlIGRlcGVuZGVuY2llcyBvYmplY3QuIFRoaXMgaXMgbXV0YXRlZCBkdXJpbmcgdGhlIHJlbmRlciBwaGFzZSwgc29cbiAgICAvLyBpdCBjYW5ub3QgYmUgc2hhcmVkIHdpdGggdGhlIGN1cnJlbnQgZmliZXIuXG5cbiAgICB2YXIgY3VycmVudERlcGVuZGVuY2llcyA9IGN1cnJlbnQuZGVwZW5kZW5jaWVzO1xuICAgIHdvcmtJblByb2dyZXNzLmRlcGVuZGVuY2llcyA9IGN1cnJlbnREZXBlbmRlbmNpZXMgPT09IG51bGwgPyBudWxsIDoge1xuICAgICAgbGFuZXM6IGN1cnJlbnREZXBlbmRlbmNpZXMubGFuZXMsXG4gICAgICBmaXJzdENvbnRleHQ6IGN1cnJlbnREZXBlbmRlbmNpZXMuZmlyc3RDb250ZXh0XG4gICAgfTtcblxuICAgIHtcbiAgICAgIC8vIE5vdGU6IFdlIGRvbid0IHJlc2V0IHRoZSBhY3R1YWxUaW1lIGNvdW50cy4gSXQncyB1c2VmdWwgdG8gYWNjdW11bGF0ZVxuICAgICAgLy8gYWN0dWFsIHRpbWUgYWNyb3NzIG11bHRpcGxlIHJlbmRlciBwYXNzZXMuXG4gICAgICB3b3JrSW5Qcm9ncmVzcy5zZWxmQmFzZUR1cmF0aW9uID0gY3VycmVudC5zZWxmQmFzZUR1cmF0aW9uO1xuICAgICAgd29ya0luUHJvZ3Jlc3MudHJlZUJhc2VEdXJhdGlvbiA9IGN1cnJlbnQudHJlZUJhc2VEdXJhdGlvbjtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gd29ya0luUHJvZ3Jlc3M7XG59XG5mdW5jdGlvbiBjcmVhdGVIb3N0Um9vdEZpYmVyKHRhZykge1xuICB2YXIgbW9kZTtcblxuICBpZiAodGFnID09PSBDb25jdXJyZW50Um9vdCkge1xuICAgIG1vZGUgPSBDb25jdXJyZW50TW9kZSB8IEJsb2NraW5nTW9kZSB8IFN0cmljdE1vZGU7XG4gIH0gZWxzZSBpZiAodGFnID09PSBCbG9ja2luZ1Jvb3QpIHtcbiAgICBtb2RlID0gQmxvY2tpbmdNb2RlIHwgU3RyaWN0TW9kZTtcbiAgfSBlbHNlIHtcbiAgICBtb2RlID0gTm9Nb2RlO1xuICB9XG5cbiAgaWYgKCBpc0RldlRvb2xzUHJlc2VudCkge1xuICAgIC8vIEFsd2F5cyBjb2xsZWN0IHByb2ZpbGUgdGltaW5ncyB3aGVuIERldlRvb2xzIGFyZSBwcmVzZW50LlxuICAgIC8vIFRoaXMgZW5hYmxlcyBEZXZUb29scyB0byBzdGFydCBjYXB0dXJpbmcgdGltaW5nIGF0IGFueSBwb2ludOKAk1xuICAgIC8vIFdpdGhvdXQgc29tZSBub2RlcyBpbiB0aGUgdHJlZSBoYXZpbmcgZW1wdHkgYmFzZSB0aW1lcy5cbiAgICBtb2RlIHw9IFByb2ZpbGVNb2RlO1xuICB9XG5cbiAgcmV0dXJuIGNyZWF0ZUZpYmVyKEhvc3RSb290LCBudWxsLCBudWxsLCBtb2RlKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUZpYmVyRnJvbVR5cGVBbmRQcm9wcyh0eXBlLCAvLyBSZWFjdCRFbGVtZW50VHlwZVxua2V5LCBwZW5kaW5nUHJvcHMsIG93bmVyLCBtb2RlLCBsYW5lcykge1xuICB2YXIgZmliZXJUYWcgPSBJbmRldGVybWluYXRlQ29tcG9uZW50OyAvLyBUaGUgcmVzb2x2ZWQgdHlwZSBpcyBzZXQgaWYgd2Uga25vdyB3aGF0IHRoZSBmaW5hbCB0eXBlIHdpbGwgYmUuIEkuZS4gaXQncyBub3QgbGF6eS5cblxuICB2YXIgcmVzb2x2ZWRUeXBlID0gdHlwZTtcblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICBpZiAoc2hvdWxkQ29uc3RydWN0JDEodHlwZSkpIHtcbiAgICAgIGZpYmVyVGFnID0gQ2xhc3NDb21wb25lbnQ7XG5cbiAgICAgIHtcbiAgICAgICAgcmVzb2x2ZWRUeXBlID0gcmVzb2x2ZUNsYXNzRm9ySG90UmVsb2FkaW5nKHJlc29sdmVkVHlwZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHtcbiAgICAgICAgcmVzb2x2ZWRUeXBlID0gcmVzb2x2ZUZ1bmN0aW9uRm9ySG90UmVsb2FkaW5nKHJlc29sdmVkVHlwZSk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgIGZpYmVyVGFnID0gSG9zdENvbXBvbmVudDtcbiAgfSBlbHNlIHtcbiAgICBnZXRUYWc6IHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSBSRUFDVF9GUkFHTUVOVF9UWVBFOlxuICAgICAgICByZXR1cm4gY3JlYXRlRmliZXJGcm9tRnJhZ21lbnQocGVuZGluZ1Byb3BzLmNoaWxkcmVuLCBtb2RlLCBsYW5lcywga2V5KTtcblxuICAgICAgY2FzZSBSRUFDVF9ERUJVR19UUkFDSU5HX01PREVfVFlQRTpcbiAgICAgICAgZmliZXJUYWcgPSBNb2RlO1xuICAgICAgICBtb2RlIHw9IERlYnVnVHJhY2luZ01vZGU7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIFJFQUNUX1NUUklDVF9NT0RFX1RZUEU6XG4gICAgICAgIGZpYmVyVGFnID0gTW9kZTtcbiAgICAgICAgbW9kZSB8PSBTdHJpY3RNb2RlO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBSRUFDVF9QUk9GSUxFUl9UWVBFOlxuICAgICAgICByZXR1cm4gY3JlYXRlRmliZXJGcm9tUHJvZmlsZXIocGVuZGluZ1Byb3BzLCBtb2RlLCBsYW5lcywga2V5KTtcblxuICAgICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgICByZXR1cm4gY3JlYXRlRmliZXJGcm9tU3VzcGVuc2UocGVuZGluZ1Byb3BzLCBtb2RlLCBsYW5lcywga2V5KTtcblxuICAgICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEU6XG4gICAgICAgIHJldHVybiBjcmVhdGVGaWJlckZyb21TdXNwZW5zZUxpc3QocGVuZGluZ1Byb3BzLCBtb2RlLCBsYW5lcywga2V5KTtcblxuICAgICAgY2FzZSBSRUFDVF9PRkZTQ1JFRU5fVFlQRTpcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUZpYmVyRnJvbU9mZnNjcmVlbihwZW5kaW5nUHJvcHMsIG1vZGUsIGxhbmVzLCBrZXkpO1xuXG4gICAgICBjYXNlIFJFQUNUX0xFR0FDWV9ISURERU5fVFlQRTpcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUZpYmVyRnJvbUxlZ2FjeUhpZGRlbihwZW5kaW5nUHJvcHMsIG1vZGUsIGxhbmVzLCBrZXkpO1xuXG4gICAgICBjYXNlIFJFQUNUX1NDT1BFX1RZUEU6XG5cbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1mYWxsdGhyb3VnaFxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICB7XG4gICAgICAgICAgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JyAmJiB0eXBlICE9PSBudWxsKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHR5cGUuJCR0eXBlb2YpIHtcbiAgICAgICAgICAgICAgY2FzZSBSRUFDVF9QUk9WSURFUl9UWVBFOlxuICAgICAgICAgICAgICAgIGZpYmVyVGFnID0gQ29udGV4dFByb3ZpZGVyO1xuICAgICAgICAgICAgICAgIGJyZWFrIGdldFRhZztcblxuICAgICAgICAgICAgICBjYXNlIFJFQUNUX0NPTlRFWFRfVFlQRTpcbiAgICAgICAgICAgICAgICAvLyBUaGlzIGlzIGEgY29uc3VtZXJcbiAgICAgICAgICAgICAgICBmaWJlclRhZyA9IENvbnRleHRDb25zdW1lcjtcbiAgICAgICAgICAgICAgICBicmVhayBnZXRUYWc7XG5cbiAgICAgICAgICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxuICAgICAgICAgICAgICAgIGZpYmVyVGFnID0gRm9yd2FyZFJlZjtcblxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIHJlc29sdmVkVHlwZSA9IHJlc29sdmVGb3J3YXJkUmVmRm9ySG90UmVsb2FkaW5nKHJlc29sdmVkVHlwZSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgYnJlYWsgZ2V0VGFnO1xuXG4gICAgICAgICAgICAgIGNhc2UgUkVBQ1RfTUVNT19UWVBFOlxuICAgICAgICAgICAgICAgIGZpYmVyVGFnID0gTWVtb0NvbXBvbmVudDtcbiAgICAgICAgICAgICAgICBicmVhayBnZXRUYWc7XG5cbiAgICAgICAgICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgICAgICAgICAgZmliZXJUYWcgPSBMYXp5Q29tcG9uZW50O1xuICAgICAgICAgICAgICAgIHJlc29sdmVkVHlwZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgYnJlYWsgZ2V0VGFnO1xuXG4gICAgICAgICAgICAgIGNhc2UgUkVBQ1RfQkxPQ0tfVFlQRTpcbiAgICAgICAgICAgICAgICBmaWJlclRhZyA9IEJsb2NrO1xuICAgICAgICAgICAgICAgIGJyZWFrIGdldFRhZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgaW5mbyA9ICcnO1xuXG4gICAgICAgICAge1xuICAgICAgICAgICAgaWYgKHR5cGUgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgdHlwZSAhPT0gbnVsbCAmJiBPYmplY3Qua2V5cyh0eXBlKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgaW5mbyArPSAnIFlvdSBsaWtlbHkgZm9yZ290IHRvIGV4cG9ydCB5b3VyIGNvbXBvbmVudCBmcm9tIHRoZSBmaWxlICcgKyBcIml0J3MgZGVmaW5lZCBpbiwgb3IgeW91IG1pZ2h0IGhhdmUgbWl4ZWQgdXAgZGVmYXVsdCBhbmQgXCIgKyAnbmFtZWQgaW1wb3J0cy4nO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgb3duZXJOYW1lID0gb3duZXIgPyBnZXRDb21wb25lbnROYW1lKG93bmVyLnR5cGUpIDogbnVsbDtcblxuICAgICAgICAgICAgaWYgKG93bmVyTmFtZSkge1xuICAgICAgICAgICAgICBpbmZvICs9ICdcXG5cXG5DaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBgJyArIG93bmVyTmFtZSArICdgLic7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAge1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICB0aHJvdyBFcnJvciggXCJFbGVtZW50IHR5cGUgaXMgaW52YWxpZDogZXhwZWN0ZWQgYSBzdHJpbmcgKGZvciBidWlsdC1pbiBjb21wb25lbnRzKSBvciBhIGNsYXNzL2Z1bmN0aW9uIChmb3IgY29tcG9zaXRlIGNvbXBvbmVudHMpIGJ1dCBnb3Q6IFwiICsgKHR5cGUgPT0gbnVsbCA/IHR5cGUgOiB0eXBlb2YgdHlwZSkgKyBcIi5cIiArIGluZm8gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2YXIgZmliZXIgPSBjcmVhdGVGaWJlcihmaWJlclRhZywgcGVuZGluZ1Byb3BzLCBrZXksIG1vZGUpO1xuICBmaWJlci5lbGVtZW50VHlwZSA9IHR5cGU7XG4gIGZpYmVyLnR5cGUgPSByZXNvbHZlZFR5cGU7XG4gIGZpYmVyLmxhbmVzID0gbGFuZXM7XG5cbiAge1xuICAgIGZpYmVyLl9kZWJ1Z093bmVyID0gb3duZXI7XG4gIH1cblxuICByZXR1cm4gZmliZXI7XG59XG5mdW5jdGlvbiBjcmVhdGVGaWJlckZyb21FbGVtZW50KGVsZW1lbnQsIG1vZGUsIGxhbmVzKSB7XG4gIHZhciBvd25lciA9IG51bGw7XG5cbiAge1xuICAgIG93bmVyID0gZWxlbWVudC5fb3duZXI7XG4gIH1cblxuICB2YXIgdHlwZSA9IGVsZW1lbnQudHlwZTtcbiAgdmFyIGtleSA9IGVsZW1lbnQua2V5O1xuICB2YXIgcGVuZGluZ1Byb3BzID0gZWxlbWVudC5wcm9wcztcbiAgdmFyIGZpYmVyID0gY3JlYXRlRmliZXJGcm9tVHlwZUFuZFByb3BzKHR5cGUsIGtleSwgcGVuZGluZ1Byb3BzLCBvd25lciwgbW9kZSwgbGFuZXMpO1xuXG4gIHtcbiAgICBmaWJlci5fZGVidWdTb3VyY2UgPSBlbGVtZW50Ll9zb3VyY2U7XG4gICAgZmliZXIuX2RlYnVnT3duZXIgPSBlbGVtZW50Ll9vd25lcjtcbiAgfVxuXG4gIHJldHVybiBmaWJlcjtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUZpYmVyRnJvbUZyYWdtZW50KGVsZW1lbnRzLCBtb2RlLCBsYW5lcywga2V5KSB7XG4gIHZhciBmaWJlciA9IGNyZWF0ZUZpYmVyKEZyYWdtZW50LCBlbGVtZW50cywga2V5LCBtb2RlKTtcbiAgZmliZXIubGFuZXMgPSBsYW5lcztcbiAgcmV0dXJuIGZpYmVyO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVGaWJlckZyb21Qcm9maWxlcihwZW5kaW5nUHJvcHMsIG1vZGUsIGxhbmVzLCBrZXkpIHtcbiAge1xuICAgIGlmICh0eXBlb2YgcGVuZGluZ1Byb3BzLmlkICE9PSAnc3RyaW5nJykge1xuICAgICAgZXJyb3IoJ1Byb2ZpbGVyIG11c3Qgc3BlY2lmeSBhbiBcImlkXCIgYXMgYSBwcm9wJyk7XG4gICAgfVxuICB9XG5cbiAgdmFyIGZpYmVyID0gY3JlYXRlRmliZXIoUHJvZmlsZXIsIHBlbmRpbmdQcm9wcywga2V5LCBtb2RlIHwgUHJvZmlsZU1vZGUpOyAvLyBUT0RPOiBUaGUgUHJvZmlsZXIgZmliZXIgc2hvdWxkbid0IGhhdmUgYSB0eXBlLiBJdCBoYXMgYSB0YWcuXG5cbiAgZmliZXIuZWxlbWVudFR5cGUgPSBSRUFDVF9QUk9GSUxFUl9UWVBFO1xuICBmaWJlci50eXBlID0gUkVBQ1RfUFJPRklMRVJfVFlQRTtcbiAgZmliZXIubGFuZXMgPSBsYW5lcztcblxuICB7XG4gICAgZmliZXIuc3RhdGVOb2RlID0ge1xuICAgICAgZWZmZWN0RHVyYXRpb246IDAsXG4gICAgICBwYXNzaXZlRWZmZWN0RHVyYXRpb246IDBcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIGZpYmVyO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVGaWJlckZyb21TdXNwZW5zZShwZW5kaW5nUHJvcHMsIG1vZGUsIGxhbmVzLCBrZXkpIHtcbiAgdmFyIGZpYmVyID0gY3JlYXRlRmliZXIoU3VzcGVuc2VDb21wb25lbnQsIHBlbmRpbmdQcm9wcywga2V5LCBtb2RlKTsgLy8gVE9ETzogVGhlIFN1c3BlbnNlQ29tcG9uZW50IGZpYmVyIHNob3VsZG4ndCBoYXZlIGEgdHlwZS4gSXQgaGFzIGEgdGFnLlxuICAvLyBUaGlzIG5lZWRzIHRvIGJlIGZpeGVkIGluIGdldENvbXBvbmVudE5hbWUgc28gdGhhdCBpdCByZWxpZXMgb24gdGhlIHRhZ1xuICAvLyBpbnN0ZWFkLlxuXG4gIGZpYmVyLnR5cGUgPSBSRUFDVF9TVVNQRU5TRV9UWVBFO1xuICBmaWJlci5lbGVtZW50VHlwZSA9IFJFQUNUX1NVU1BFTlNFX1RZUEU7XG4gIGZpYmVyLmxhbmVzID0gbGFuZXM7XG4gIHJldHVybiBmaWJlcjtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUZpYmVyRnJvbVN1c3BlbnNlTGlzdChwZW5kaW5nUHJvcHMsIG1vZGUsIGxhbmVzLCBrZXkpIHtcbiAgdmFyIGZpYmVyID0gY3JlYXRlRmliZXIoU3VzcGVuc2VMaXN0Q29tcG9uZW50LCBwZW5kaW5nUHJvcHMsIGtleSwgbW9kZSk7XG5cbiAge1xuICAgIC8vIFRPRE86IFRoZSBTdXNwZW5zZUxpc3RDb21wb25lbnQgZmliZXIgc2hvdWxkbid0IGhhdmUgYSB0eXBlLiBJdCBoYXMgYSB0YWcuXG4gICAgLy8gVGhpcyBuZWVkcyB0byBiZSBmaXhlZCBpbiBnZXRDb21wb25lbnROYW1lIHNvIHRoYXQgaXQgcmVsaWVzIG9uIHRoZSB0YWdcbiAgICAvLyBpbnN0ZWFkLlxuICAgIGZpYmVyLnR5cGUgPSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEU7XG4gIH1cblxuICBmaWJlci5lbGVtZW50VHlwZSA9IFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTtcbiAgZmliZXIubGFuZXMgPSBsYW5lcztcbiAgcmV0dXJuIGZpYmVyO1xufVxuZnVuY3Rpb24gY3JlYXRlRmliZXJGcm9tT2Zmc2NyZWVuKHBlbmRpbmdQcm9wcywgbW9kZSwgbGFuZXMsIGtleSkge1xuICB2YXIgZmliZXIgPSBjcmVhdGVGaWJlcihPZmZzY3JlZW5Db21wb25lbnQsIHBlbmRpbmdQcm9wcywga2V5LCBtb2RlKTsgLy8gVE9ETzogVGhlIE9mZnNjcmVlbkNvbXBvbmVudCBmaWJlciBzaG91bGRuJ3QgaGF2ZSBhIHR5cGUuIEl0IGhhcyBhIHRhZy5cbiAgLy8gVGhpcyBuZWVkcyB0byBiZSBmaXhlZCBpbiBnZXRDb21wb25lbnROYW1lIHNvIHRoYXQgaXQgcmVsaWVzIG9uIHRoZSB0YWdcbiAgLy8gaW5zdGVhZC5cblxuICB7XG4gICAgZmliZXIudHlwZSA9IFJFQUNUX09GRlNDUkVFTl9UWVBFO1xuICB9XG5cbiAgZmliZXIuZWxlbWVudFR5cGUgPSBSRUFDVF9PRkZTQ1JFRU5fVFlQRTtcbiAgZmliZXIubGFuZXMgPSBsYW5lcztcbiAgcmV0dXJuIGZpYmVyO1xufVxuZnVuY3Rpb24gY3JlYXRlRmliZXJGcm9tTGVnYWN5SGlkZGVuKHBlbmRpbmdQcm9wcywgbW9kZSwgbGFuZXMsIGtleSkge1xuICB2YXIgZmliZXIgPSBjcmVhdGVGaWJlcihMZWdhY3lIaWRkZW5Db21wb25lbnQsIHBlbmRpbmdQcm9wcywga2V5LCBtb2RlKTsgLy8gVE9ETzogVGhlIExlZ2FjeUhpZGRlbiBmaWJlciBzaG91bGRuJ3QgaGF2ZSBhIHR5cGUuIEl0IGhhcyBhIHRhZy5cbiAgLy8gVGhpcyBuZWVkcyB0byBiZSBmaXhlZCBpbiBnZXRDb21wb25lbnROYW1lIHNvIHRoYXQgaXQgcmVsaWVzIG9uIHRoZSB0YWdcbiAgLy8gaW5zdGVhZC5cblxuICB7XG4gICAgZmliZXIudHlwZSA9IFJFQUNUX0xFR0FDWV9ISURERU5fVFlQRTtcbiAgfVxuXG4gIGZpYmVyLmVsZW1lbnRUeXBlID0gUkVBQ1RfTEVHQUNZX0hJRERFTl9UWVBFO1xuICBmaWJlci5sYW5lcyA9IGxhbmVzO1xuICByZXR1cm4gZmliZXI7XG59XG5mdW5jdGlvbiBjcmVhdGVGaWJlckZyb21UZXh0KGNvbnRlbnQsIG1vZGUsIGxhbmVzKSB7XG4gIHZhciBmaWJlciA9IGNyZWF0ZUZpYmVyKEhvc3RUZXh0LCBjb250ZW50LCBudWxsLCBtb2RlKTtcbiAgZmliZXIubGFuZXMgPSBsYW5lcztcbiAgcmV0dXJuIGZpYmVyO1xufVxuZnVuY3Rpb24gY3JlYXRlRmliZXJGcm9tSG9zdEluc3RhbmNlRm9yRGVsZXRpb24oKSB7XG4gIHZhciBmaWJlciA9IGNyZWF0ZUZpYmVyKEhvc3RDb21wb25lbnQsIG51bGwsIG51bGwsIE5vTW9kZSk7IC8vIFRPRE86IFRoZXNlIHNob3VsZCBub3QgbmVlZCBhIHR5cGUuXG5cbiAgZmliZXIuZWxlbWVudFR5cGUgPSAnREVMRVRFRCc7XG4gIGZpYmVyLnR5cGUgPSAnREVMRVRFRCc7XG4gIHJldHVybiBmaWJlcjtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUZpYmVyRnJvbVBvcnRhbChwb3J0YWwsIG1vZGUsIGxhbmVzKSB7XG4gIHZhciBwZW5kaW5nUHJvcHMgPSBwb3J0YWwuY2hpbGRyZW4gIT09IG51bGwgPyBwb3J0YWwuY2hpbGRyZW4gOiBbXTtcbiAgdmFyIGZpYmVyID0gY3JlYXRlRmliZXIoSG9zdFBvcnRhbCwgcGVuZGluZ1Byb3BzLCBwb3J0YWwua2V5LCBtb2RlKTtcbiAgZmliZXIubGFuZXMgPSBsYW5lcztcbiAgZmliZXIuc3RhdGVOb2RlID0ge1xuICAgIGNvbnRhaW5lckluZm86IHBvcnRhbC5jb250YWluZXJJbmZvLFxuICAgIHBlbmRpbmdDaGlsZHJlbjogbnVsbCxcbiAgICAvLyBVc2VkIGJ5IHBlcnNpc3RlbnQgdXBkYXRlc1xuICAgIGltcGxlbWVudGF0aW9uOiBwb3J0YWwuaW1wbGVtZW50YXRpb25cbiAgfTtcbiAgcmV0dXJuIGZpYmVyO1xufSAvLyBVc2VkIGZvciBzdGFzaGluZyBXSVAgcHJvcGVydGllcyB0byByZXBsYXkgZmFpbGVkIHdvcmsgaW4gREVWLlxuXG5mdW5jdGlvbiBhc3NpZ25GaWJlclByb3BlcnRpZXNJbkRFVih0YXJnZXQsIHNvdXJjZSkge1xuICBpZiAodGFyZ2V0ID09PSBudWxsKSB7XG4gICAgLy8gVGhpcyBGaWJlcidzIGluaXRpYWwgcHJvcGVydGllcyB3aWxsIGFsd2F5cyBiZSBvdmVyd3JpdHRlbi5cbiAgICAvLyBXZSBvbmx5IHVzZSBhIEZpYmVyIHRvIGVuc3VyZSB0aGUgc2FtZSBoaWRkZW4gY2xhc3Mgc28gREVWIGlzbid0IHNsb3cuXG4gICAgdGFyZ2V0ID0gY3JlYXRlRmliZXIoSW5kZXRlcm1pbmF0ZUNvbXBvbmVudCwgbnVsbCwgbnVsbCwgTm9Nb2RlKTtcbiAgfSAvLyBUaGlzIGlzIGludGVudGlvbmFsbHkgd3JpdHRlbiBhcyBhIGxpc3Qgb2YgYWxsIHByb3BlcnRpZXMuXG4gIC8vIFdlIHRyaWVkIHRvIHVzZSBPYmplY3QuYXNzaWduKCkgaW5zdGVhZCBidXQgdGhpcyBpcyBjYWxsZWQgaW5cbiAgLy8gdGhlIGhvdHRlc3QgcGF0aCwgYW5kIE9iamVjdC5hc3NpZ24oKSB3YXMgdG9vIHNsb3c6XG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTI1MDJcbiAgLy8gVGhpcyBjb2RlIGlzIERFVi1vbmx5IHNvIHNpemUgaXMgbm90IGEgY29uY2Vybi5cblxuXG4gIHRhcmdldC50YWcgPSBzb3VyY2UudGFnO1xuICB0YXJnZXQua2V5ID0gc291cmNlLmtleTtcbiAgdGFyZ2V0LmVsZW1lbnRUeXBlID0gc291cmNlLmVsZW1lbnRUeXBlO1xuICB0YXJnZXQudHlwZSA9IHNvdXJjZS50eXBlO1xuICB0YXJnZXQuc3RhdGVOb2RlID0gc291cmNlLnN0YXRlTm9kZTtcbiAgdGFyZ2V0LnJldHVybiA9IHNvdXJjZS5yZXR1cm47XG4gIHRhcmdldC5jaGlsZCA9IHNvdXJjZS5jaGlsZDtcbiAgdGFyZ2V0LnNpYmxpbmcgPSBzb3VyY2Uuc2libGluZztcbiAgdGFyZ2V0LmluZGV4ID0gc291cmNlLmluZGV4O1xuICB0YXJnZXQucmVmID0gc291cmNlLnJlZjtcbiAgdGFyZ2V0LnBlbmRpbmdQcm9wcyA9IHNvdXJjZS5wZW5kaW5nUHJvcHM7XG4gIHRhcmdldC5tZW1vaXplZFByb3BzID0gc291cmNlLm1lbW9pemVkUHJvcHM7XG4gIHRhcmdldC51cGRhdGVRdWV1ZSA9IHNvdXJjZS51cGRhdGVRdWV1ZTtcbiAgdGFyZ2V0Lm1lbW9pemVkU3RhdGUgPSBzb3VyY2UubWVtb2l6ZWRTdGF0ZTtcbiAgdGFyZ2V0LmRlcGVuZGVuY2llcyA9IHNvdXJjZS5kZXBlbmRlbmNpZXM7XG4gIHRhcmdldC5tb2RlID0gc291cmNlLm1vZGU7XG4gIHRhcmdldC5mbGFncyA9IHNvdXJjZS5mbGFncztcbiAgdGFyZ2V0Lm5leHRFZmZlY3QgPSBzb3VyY2UubmV4dEVmZmVjdDtcbiAgdGFyZ2V0LmZpcnN0RWZmZWN0ID0gc291cmNlLmZpcnN0RWZmZWN0O1xuICB0YXJnZXQubGFzdEVmZmVjdCA9IHNvdXJjZS5sYXN0RWZmZWN0O1xuICB0YXJnZXQubGFuZXMgPSBzb3VyY2UubGFuZXM7XG4gIHRhcmdldC5jaGlsZExhbmVzID0gc291cmNlLmNoaWxkTGFuZXM7XG4gIHRhcmdldC5hbHRlcm5hdGUgPSBzb3VyY2UuYWx0ZXJuYXRlO1xuXG4gIHtcbiAgICB0YXJnZXQuYWN0dWFsRHVyYXRpb24gPSBzb3VyY2UuYWN0dWFsRHVyYXRpb247XG4gICAgdGFyZ2V0LmFjdHVhbFN0YXJ0VGltZSA9IHNvdXJjZS5hY3R1YWxTdGFydFRpbWU7XG4gICAgdGFyZ2V0LnNlbGZCYXNlRHVyYXRpb24gPSBzb3VyY2Uuc2VsZkJhc2VEdXJhdGlvbjtcbiAgICB0YXJnZXQudHJlZUJhc2VEdXJhdGlvbiA9IHNvdXJjZS50cmVlQmFzZUR1cmF0aW9uO1xuICB9XG5cbiAgdGFyZ2V0Ll9kZWJ1Z0lEID0gc291cmNlLl9kZWJ1Z0lEO1xuICB0YXJnZXQuX2RlYnVnU291cmNlID0gc291cmNlLl9kZWJ1Z1NvdXJjZTtcbiAgdGFyZ2V0Ll9kZWJ1Z093bmVyID0gc291cmNlLl9kZWJ1Z093bmVyO1xuICB0YXJnZXQuX2RlYnVnTmVlZHNSZW1vdW50ID0gc291cmNlLl9kZWJ1Z05lZWRzUmVtb3VudDtcbiAgdGFyZ2V0Ll9kZWJ1Z0hvb2tUeXBlcyA9IHNvdXJjZS5fZGVidWdIb29rVHlwZXM7XG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbmZ1bmN0aW9uIEZpYmVyUm9vdE5vZGUoY29udGFpbmVySW5mbywgdGFnLCBoeWRyYXRlKSB7XG4gIHRoaXMudGFnID0gdGFnO1xuICB0aGlzLmNvbnRhaW5lckluZm8gPSBjb250YWluZXJJbmZvO1xuICB0aGlzLnBlbmRpbmdDaGlsZHJlbiA9IG51bGw7XG4gIHRoaXMuY3VycmVudCA9IG51bGw7XG4gIHRoaXMucGluZ0NhY2hlID0gbnVsbDtcbiAgdGhpcy5maW5pc2hlZFdvcmsgPSBudWxsO1xuICB0aGlzLnRpbWVvdXRIYW5kbGUgPSBub1RpbWVvdXQ7XG4gIHRoaXMuY29udGV4dCA9IG51bGw7XG4gIHRoaXMucGVuZGluZ0NvbnRleHQgPSBudWxsO1xuICB0aGlzLmh5ZHJhdGUgPSBoeWRyYXRlO1xuICB0aGlzLmNhbGxiYWNrTm9kZSA9IG51bGw7XG4gIHRoaXMuY2FsbGJhY2tQcmlvcml0eSA9IE5vTGFuZVByaW9yaXR5O1xuICB0aGlzLmV2ZW50VGltZXMgPSBjcmVhdGVMYW5lTWFwKE5vTGFuZXMpO1xuICB0aGlzLmV4cGlyYXRpb25UaW1lcyA9IGNyZWF0ZUxhbmVNYXAoTm9UaW1lc3RhbXApO1xuICB0aGlzLnBlbmRpbmdMYW5lcyA9IE5vTGFuZXM7XG4gIHRoaXMuc3VzcGVuZGVkTGFuZXMgPSBOb0xhbmVzO1xuICB0aGlzLnBpbmdlZExhbmVzID0gTm9MYW5lcztcbiAgdGhpcy5leHBpcmVkTGFuZXMgPSBOb0xhbmVzO1xuICB0aGlzLm11dGFibGVSZWFkTGFuZXMgPSBOb0xhbmVzO1xuICB0aGlzLmZpbmlzaGVkTGFuZXMgPSBOb0xhbmVzO1xuICB0aGlzLmVudGFuZ2xlZExhbmVzID0gTm9MYW5lcztcbiAgdGhpcy5lbnRhbmdsZW1lbnRzID0gY3JlYXRlTGFuZU1hcChOb0xhbmVzKTtcblxuICB7XG4gICAgdGhpcy5tdXRhYmxlU291cmNlRWFnZXJIeWRyYXRpb25EYXRhID0gbnVsbDtcbiAgfVxuXG4gIHtcbiAgICB0aGlzLmludGVyYWN0aW9uVGhyZWFkSUQgPSB0cmFjaW5nLnVuc3RhYmxlX2dldFRocmVhZElEKCk7XG4gICAgdGhpcy5tZW1vaXplZEludGVyYWN0aW9ucyA9IG5ldyBTZXQoKTtcbiAgICB0aGlzLnBlbmRpbmdJbnRlcmFjdGlvbk1hcCA9IG5ldyBNYXAoKTtcbiAgfVxuXG4gIHtcbiAgICBzd2l0Y2ggKHRhZykge1xuICAgICAgY2FzZSBCbG9ja2luZ1Jvb3Q6XG4gICAgICAgIHRoaXMuX2RlYnVnUm9vdFR5cGUgPSAnY3JlYXRlQmxvY2tpbmdSb290KCknO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBDb25jdXJyZW50Um9vdDpcbiAgICAgICAgdGhpcy5fZGVidWdSb290VHlwZSA9ICdjcmVhdGVSb290KCknO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBMZWdhY3lSb290OlxuICAgICAgICB0aGlzLl9kZWJ1Z1Jvb3RUeXBlID0gJ2NyZWF0ZUxlZ2FjeVJvb3QoKSc7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVGaWJlclJvb3QoY29udGFpbmVySW5mbywgdGFnLCBoeWRyYXRlLCBoeWRyYXRpb25DYWxsYmFja3MpIHtcbiAgdmFyIHJvb3QgPSBuZXcgRmliZXJSb290Tm9kZShjb250YWluZXJJbmZvLCB0YWcsIGh5ZHJhdGUpO1xuICAvLyBzdGF0ZU5vZGUgaXMgYW55LlxuXG5cbiAgdmFyIHVuaW5pdGlhbGl6ZWRGaWJlciA9IGNyZWF0ZUhvc3RSb290RmliZXIodGFnKTtcbiAgcm9vdC5jdXJyZW50ID0gdW5pbml0aWFsaXplZEZpYmVyO1xuICB1bmluaXRpYWxpemVkRmliZXIuc3RhdGVOb2RlID0gcm9vdDtcbiAgaW5pdGlhbGl6ZVVwZGF0ZVF1ZXVlKHVuaW5pdGlhbGl6ZWRGaWJlcik7XG4gIHJldHVybiByb290O1xufVxuXG4vLyBUaGlzIGVuc3VyZXMgdGhhdCB0aGUgdmVyc2lvbiB1c2VkIGZvciBzZXJ2ZXIgcmVuZGVyaW5nIG1hdGNoZXMgdGhlIG9uZVxuLy8gdGhhdCBpcyBldmVudHVhbGx5IHJlYWQgZHVyaW5nIGh5ZHJhdGlvbi5cbi8vIElmIHRoZXkgZG9uJ3QgbWF0Y2ggdGhlcmUncyBhIHBvdGVudGlhbCB0ZWFyIGFuZCBhIGZ1bGwgZGVvcHQgcmVuZGVyIGlzIHJlcXVpcmVkLlxuXG5mdW5jdGlvbiByZWdpc3Rlck11dGFibGVTb3VyY2VGb3JIeWRyYXRpb24ocm9vdCwgbXV0YWJsZVNvdXJjZSkge1xuICB2YXIgZ2V0VmVyc2lvbiA9IG11dGFibGVTb3VyY2UuX2dldFZlcnNpb247XG4gIHZhciB2ZXJzaW9uID0gZ2V0VmVyc2lvbihtdXRhYmxlU291cmNlLl9zb3VyY2UpOyAvLyBUT0RPIENsZWFyIHRoaXMgZGF0YSBvbmNlIGFsbCBwZW5kaW5nIGh5ZHJhdGlvbiB3b3JrIGlzIGZpbmlzaGVkLlxuICAvLyBSZXRhaW5pbmcgaXQgZm9yZXZlciBtYXkgaW50ZXJmZXJlIHdpdGggR0MuXG5cbiAgaWYgKHJvb3QubXV0YWJsZVNvdXJjZUVhZ2VySHlkcmF0aW9uRGF0YSA9PSBudWxsKSB7XG4gICAgcm9vdC5tdXRhYmxlU291cmNlRWFnZXJIeWRyYXRpb25EYXRhID0gW211dGFibGVTb3VyY2UsIHZlcnNpb25dO1xuICB9IGVsc2Uge1xuICAgIHJvb3QubXV0YWJsZVNvdXJjZUVhZ2VySHlkcmF0aW9uRGF0YS5wdXNoKG11dGFibGVTb3VyY2UsIHZlcnNpb24pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVBvcnRhbChjaGlsZHJlbiwgY29udGFpbmVySW5mbywgLy8gVE9ETzogZmlndXJlIG91dCB0aGUgQVBJIGZvciBjcm9zcy1yZW5kZXJlciBpbXBsZW1lbnRhdGlvbi5cbmltcGxlbWVudGF0aW9uKSB7XG4gIHZhciBrZXkgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IG51bGw7XG4gIHJldHVybiB7XG4gICAgLy8gVGhpcyB0YWcgYWxsb3cgdXMgdG8gdW5pcXVlbHkgaWRlbnRpZnkgdGhpcyBhcyBhIFJlYWN0IFBvcnRhbFxuICAgICQkdHlwZW9mOiBSRUFDVF9QT1JUQUxfVFlQRSxcbiAgICBrZXk6IGtleSA9PSBudWxsID8gbnVsbCA6ICcnICsga2V5LFxuICAgIGNoaWxkcmVuOiBjaGlsZHJlbixcbiAgICBjb250YWluZXJJbmZvOiBjb250YWluZXJJbmZvLFxuICAgIGltcGxlbWVudGF0aW9uOiBpbXBsZW1lbnRhdGlvblxuICB9O1xufVxuXG52YXIgZGlkV2FybkFib3V0TmVzdGVkVXBkYXRlcztcbnZhciBkaWRXYXJuQWJvdXRGaW5kTm9kZUluU3RyaWN0TW9kZTtcblxue1xuICBkaWRXYXJuQWJvdXROZXN0ZWRVcGRhdGVzID0gZmFsc2U7XG4gIGRpZFdhcm5BYm91dEZpbmROb2RlSW5TdHJpY3RNb2RlID0ge307XG59XG5cbmZ1bmN0aW9uIGdldENvbnRleHRGb3JTdWJ0cmVlKHBhcmVudENvbXBvbmVudCkge1xuICBpZiAoIXBhcmVudENvbXBvbmVudCkge1xuICAgIHJldHVybiBlbXB0eUNvbnRleHRPYmplY3Q7XG4gIH1cblxuICB2YXIgZmliZXIgPSBnZXQocGFyZW50Q29tcG9uZW50KTtcbiAgdmFyIHBhcmVudENvbnRleHQgPSBmaW5kQ3VycmVudFVubWFza2VkQ29udGV4dChmaWJlcik7XG5cbiAgaWYgKGZpYmVyLnRhZyA9PT0gQ2xhc3NDb21wb25lbnQpIHtcbiAgICB2YXIgQ29tcG9uZW50ID0gZmliZXIudHlwZTtcblxuICAgIGlmIChpc0NvbnRleHRQcm92aWRlcihDb21wb25lbnQpKSB7XG4gICAgICByZXR1cm4gcHJvY2Vzc0NoaWxkQ29udGV4dChmaWJlciwgQ29tcG9uZW50LCBwYXJlbnRDb250ZXh0KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcGFyZW50Q29udGV4dDtcbn1cblxuZnVuY3Rpb24gZmluZEhvc3RJbnN0YW5jZVdpdGhXYXJuaW5nKGNvbXBvbmVudCwgbWV0aG9kTmFtZSkge1xuICB7XG4gICAgdmFyIGZpYmVyID0gZ2V0KGNvbXBvbmVudCk7XG5cbiAgICBpZiAoZmliZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKHR5cGVvZiBjb21wb25lbnQucmVuZGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHtcbiAgICAgICAgICB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvciggXCJVbmFibGUgdG8gZmluZCBub2RlIG9uIGFuIHVubW91bnRlZCBjb21wb25lbnQuXCIgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHtcbiAgICAgICAgICB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvciggXCJBcmd1bWVudCBhcHBlYXJzIHRvIG5vdCBiZSBhIFJlYWN0Q29tcG9uZW50LiBLZXlzOiBcIiArIE9iamVjdC5rZXlzKGNvbXBvbmVudCkgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgaG9zdEZpYmVyID0gZmluZEN1cnJlbnRIb3N0RmliZXIoZmliZXIpO1xuXG4gICAgaWYgKGhvc3RGaWJlciA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgaWYgKGhvc3RGaWJlci5tb2RlICYgU3RyaWN0TW9kZSkge1xuICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lKGZpYmVyLnR5cGUpIHx8ICdDb21wb25lbnQnO1xuXG4gICAgICBpZiAoIWRpZFdhcm5BYm91dEZpbmROb2RlSW5TdHJpY3RNb2RlW2NvbXBvbmVudE5hbWVdKSB7XG4gICAgICAgIGRpZFdhcm5BYm91dEZpbmROb2RlSW5TdHJpY3RNb2RlW2NvbXBvbmVudE5hbWVdID0gdHJ1ZTtcbiAgICAgICAgdmFyIHByZXZpb3VzRmliZXIgPSBjdXJyZW50O1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgc2V0Q3VycmVudEZpYmVyKGhvc3RGaWJlcik7XG5cbiAgICAgICAgICBpZiAoZmliZXIubW9kZSAmIFN0cmljdE1vZGUpIHtcbiAgICAgICAgICAgIGVycm9yKCclcyBpcyBkZXByZWNhdGVkIGluIFN0cmljdE1vZGUuICcgKyAnJXMgd2FzIHBhc3NlZCBhbiBpbnN0YW5jZSBvZiAlcyB3aGljaCBpcyBpbnNpZGUgU3RyaWN0TW9kZS4gJyArICdJbnN0ZWFkLCBhZGQgYSByZWYgZGlyZWN0bHkgdG8gdGhlIGVsZW1lbnQgeW91IHdhbnQgdG8gcmVmZXJlbmNlLiAnICsgJ0xlYXJuIG1vcmUgYWJvdXQgdXNpbmcgcmVmcyBzYWZlbHkgaGVyZTogJyArICdodHRwczovL3JlYWN0anMub3JnL2xpbmsvc3RyaWN0LW1vZGUtZmluZC1ub2RlJywgbWV0aG9kTmFtZSwgbWV0aG9kTmFtZSwgY29tcG9uZW50TmFtZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGVycm9yKCclcyBpcyBkZXByZWNhdGVkIGluIFN0cmljdE1vZGUuICcgKyAnJXMgd2FzIHBhc3NlZCBhbiBpbnN0YW5jZSBvZiAlcyB3aGljaCByZW5kZXJzIFN0cmljdE1vZGUgY2hpbGRyZW4uICcgKyAnSW5zdGVhZCwgYWRkIGEgcmVmIGRpcmVjdGx5IHRvIHRoZSBlbGVtZW50IHlvdSB3YW50IHRvIHJlZmVyZW5jZS4gJyArICdMZWFybiBtb3JlIGFib3V0IHVzaW5nIHJlZnMgc2FmZWx5IGhlcmU6ICcgKyAnaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3N0cmljdC1tb2RlLWZpbmQtbm9kZScsIG1ldGhvZE5hbWUsIG1ldGhvZE5hbWUsIGNvbXBvbmVudE5hbWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAvLyBJZGVhbGx5IHRoaXMgc2hvdWxkIHJlc2V0IHRvIHByZXZpb3VzIGJ1dCB0aGlzIHNob3VsZG4ndCBiZSBjYWxsZWQgaW5cbiAgICAgICAgICAvLyByZW5kZXIgYW5kIHRoZXJlJ3MgYW5vdGhlciB3YXJuaW5nIGZvciB0aGF0IGFueXdheS5cbiAgICAgICAgICBpZiAocHJldmlvdXNGaWJlcikge1xuICAgICAgICAgICAgc2V0Q3VycmVudEZpYmVyKHByZXZpb3VzRmliZXIpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXNldEN1cnJlbnRGaWJlcigpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBob3N0RmliZXIuc3RhdGVOb2RlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUNvbnRhaW5lcihjb250YWluZXJJbmZvLCB0YWcsIGh5ZHJhdGUsIGh5ZHJhdGlvbkNhbGxiYWNrcykge1xuICByZXR1cm4gY3JlYXRlRmliZXJSb290KGNvbnRhaW5lckluZm8sIHRhZywgaHlkcmF0ZSk7XG59XG5mdW5jdGlvbiB1cGRhdGVDb250YWluZXIoZWxlbWVudCwgY29udGFpbmVyLCBwYXJlbnRDb21wb25lbnQsIGNhbGxiYWNrKSB7XG4gIHtcbiAgICBvblNjaGVkdWxlUm9vdChjb250YWluZXIsIGVsZW1lbnQpO1xuICB9XG5cbiAgdmFyIGN1cnJlbnQkMSA9IGNvbnRhaW5lci5jdXJyZW50O1xuICB2YXIgZXZlbnRUaW1lID0gcmVxdWVzdEV2ZW50VGltZSgpO1xuXG4gIHtcbiAgICAvLyAkRmxvd0V4cGVjdGVkRXJyb3IgLSBqZXN0IGlzbid0IGEgZ2xvYmFsLCBhbmQgaXNuJ3QgcmVjb2duaXplZCBvdXRzaWRlIG9mIHRlc3RzXG4gICAgaWYgKCd1bmRlZmluZWQnICE9PSB0eXBlb2YgamVzdCkge1xuICAgICAgd2FybklmVW5tb2NrZWRTY2hlZHVsZXIoY3VycmVudCQxKTtcbiAgICAgIHdhcm5JZk5vdFNjb3BlZFdpdGhNYXRjaGluZ0FjdChjdXJyZW50JDEpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBsYW5lID0gcmVxdWVzdFVwZGF0ZUxhbmUoY3VycmVudCQxKTtcblxuICB2YXIgY29udGV4dCA9IGdldENvbnRleHRGb3JTdWJ0cmVlKHBhcmVudENvbXBvbmVudCk7XG5cbiAgaWYgKGNvbnRhaW5lci5jb250ZXh0ID09PSBudWxsKSB7XG4gICAgY29udGFpbmVyLmNvbnRleHQgPSBjb250ZXh0O1xuICB9IGVsc2Uge1xuICAgIGNvbnRhaW5lci5wZW5kaW5nQ29udGV4dCA9IGNvbnRleHQ7XG4gIH1cblxuICB7XG4gICAgaWYgKGlzUmVuZGVyaW5nICYmIGN1cnJlbnQgIT09IG51bGwgJiYgIWRpZFdhcm5BYm91dE5lc3RlZFVwZGF0ZXMpIHtcbiAgICAgIGRpZFdhcm5BYm91dE5lc3RlZFVwZGF0ZXMgPSB0cnVlO1xuXG4gICAgICBlcnJvcignUmVuZGVyIG1ldGhvZHMgc2hvdWxkIGJlIGEgcHVyZSBmdW5jdGlvbiBvZiBwcm9wcyBhbmQgc3RhdGU7ICcgKyAndHJpZ2dlcmluZyBuZXN0ZWQgY29tcG9uZW50IHVwZGF0ZXMgZnJvbSByZW5kZXIgaXMgbm90IGFsbG93ZWQuICcgKyAnSWYgbmVjZXNzYXJ5LCB0cmlnZ2VyIG5lc3RlZCB1cGRhdGVzIGluIGNvbXBvbmVudERpZFVwZGF0ZS5cXG5cXG4nICsgJ0NoZWNrIHRoZSByZW5kZXIgbWV0aG9kIG9mICVzLicsIGdldENvbXBvbmVudE5hbWUoY3VycmVudC50eXBlKSB8fCAnVW5rbm93bicpO1xuICAgIH1cbiAgfVxuXG4gIHZhciB1cGRhdGUgPSBjcmVhdGVVcGRhdGUoZXZlbnRUaW1lLCBsYW5lKTsgLy8gQ2F1dGlvbjogUmVhY3QgRGV2VG9vbHMgY3VycmVudGx5IGRlcGVuZHMgb24gdGhpcyBwcm9wZXJ0eVxuICAvLyBiZWluZyBjYWxsZWQgXCJlbGVtZW50XCIuXG5cbiAgdXBkYXRlLnBheWxvYWQgPSB7XG4gICAgZWxlbWVudDogZWxlbWVudFxuICB9O1xuICBjYWxsYmFjayA9IGNhbGxiYWNrID09PSB1bmRlZmluZWQgPyBudWxsIDogY2FsbGJhY2s7XG5cbiAgaWYgKGNhbGxiYWNrICE9PSBudWxsKSB7XG4gICAge1xuICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBlcnJvcigncmVuZGVyKC4uLik6IEV4cGVjdGVkIHRoZSBsYXN0IG9wdGlvbmFsIGBjYWxsYmFja2AgYXJndW1lbnQgdG8gYmUgYSAnICsgJ2Z1bmN0aW9uLiBJbnN0ZWFkIHJlY2VpdmVkOiAlcy4nLCBjYWxsYmFjayk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdXBkYXRlLmNhbGxiYWNrID0gY2FsbGJhY2s7XG4gIH1cblxuICBlbnF1ZXVlVXBkYXRlKGN1cnJlbnQkMSwgdXBkYXRlKTtcbiAgc2NoZWR1bGVVcGRhdGVPbkZpYmVyKGN1cnJlbnQkMSwgbGFuZSwgZXZlbnRUaW1lKTtcbiAgcmV0dXJuIGxhbmU7XG59XG5mdW5jdGlvbiBnZXRQdWJsaWNSb290SW5zdGFuY2UoY29udGFpbmVyKSB7XG4gIHZhciBjb250YWluZXJGaWJlciA9IGNvbnRhaW5lci5jdXJyZW50O1xuXG4gIGlmICghY29udGFpbmVyRmliZXIuY2hpbGQpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHN3aXRjaCAoY29udGFpbmVyRmliZXIuY2hpbGQudGFnKSB7XG4gICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAgcmV0dXJuIGdldFB1YmxpY0luc3RhbmNlKGNvbnRhaW5lckZpYmVyLmNoaWxkLnN0YXRlTm9kZSk7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGNvbnRhaW5lckZpYmVyLmNoaWxkLnN0YXRlTm9kZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBtYXJrUmV0cnlMYW5lSW1wbChmaWJlciwgcmV0cnlMYW5lKSB7XG4gIHZhciBzdXNwZW5zZVN0YXRlID0gZmliZXIubWVtb2l6ZWRTdGF0ZTtcblxuICBpZiAoc3VzcGVuc2VTdGF0ZSAhPT0gbnVsbCAmJiBzdXNwZW5zZVN0YXRlLmRlaHlkcmF0ZWQgIT09IG51bGwpIHtcbiAgICBzdXNwZW5zZVN0YXRlLnJldHJ5TGFuZSA9IGhpZ2hlclByaW9yaXR5TGFuZShzdXNwZW5zZVN0YXRlLnJldHJ5TGFuZSwgcmV0cnlMYW5lKTtcbiAgfVxufSAvLyBJbmNyZWFzZXMgdGhlIHByaW9yaXR5IG9mIHRoZW5uYWJsZXMgd2hlbiB0aGV5IHJlc29sdmUgd2l0aGluIHRoaXMgYm91bmRhcnkuXG5cblxuZnVuY3Rpb24gbWFya1JldHJ5TGFuZUlmTm90SHlkcmF0ZWQoZmliZXIsIHJldHJ5TGFuZSkge1xuICBtYXJrUmV0cnlMYW5lSW1wbChmaWJlciwgcmV0cnlMYW5lKTtcbiAgdmFyIGFsdGVybmF0ZSA9IGZpYmVyLmFsdGVybmF0ZTtcblxuICBpZiAoYWx0ZXJuYXRlKSB7XG4gICAgbWFya1JldHJ5TGFuZUltcGwoYWx0ZXJuYXRlLCByZXRyeUxhbmUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGF0dGVtcHRVc2VyQmxvY2tpbmdIeWRyYXRpb24kMShmaWJlcikge1xuICBpZiAoZmliZXIudGFnICE9PSBTdXNwZW5zZUNvbXBvbmVudCkge1xuICAgIC8vIFdlIGlnbm9yZSBIb3N0Um9vdHMgaGVyZSBiZWNhdXNlIHdlIGNhbid0IGluY3JlYXNlXG4gICAgLy8gdGhlaXIgcHJpb3JpdHkgYW5kIHRoZXkgc2hvdWxkIG5vdCBzdXNwZW5kIG9uIEkvTyxcbiAgICAvLyBzaW5jZSB5b3UgaGF2ZSB0byB3cmFwIGFueXRoaW5nIHRoYXQgbWlnaHQgc3VzcGVuZCBpblxuICAgIC8vIFN1c3BlbnNlLlxuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBldmVudFRpbWUgPSByZXF1ZXN0RXZlbnRUaW1lKCk7XG4gIHZhciBsYW5lID0gSW5wdXREaXNjcmV0ZUh5ZHJhdGlvbkxhbmU7XG4gIHNjaGVkdWxlVXBkYXRlT25GaWJlcihmaWJlciwgbGFuZSwgZXZlbnRUaW1lKTtcbiAgbWFya1JldHJ5TGFuZUlmTm90SHlkcmF0ZWQoZmliZXIsIGxhbmUpO1xufVxuZnVuY3Rpb24gYXR0ZW1wdENvbnRpbnVvdXNIeWRyYXRpb24kMShmaWJlcikge1xuICBpZiAoZmliZXIudGFnICE9PSBTdXNwZW5zZUNvbXBvbmVudCkge1xuICAgIC8vIFdlIGlnbm9yZSBIb3N0Um9vdHMgaGVyZSBiZWNhdXNlIHdlIGNhbid0IGluY3JlYXNlXG4gICAgLy8gdGhlaXIgcHJpb3JpdHkgYW5kIHRoZXkgc2hvdWxkIG5vdCBzdXNwZW5kIG9uIEkvTyxcbiAgICAvLyBzaW5jZSB5b3UgaGF2ZSB0byB3cmFwIGFueXRoaW5nIHRoYXQgbWlnaHQgc3VzcGVuZCBpblxuICAgIC8vIFN1c3BlbnNlLlxuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBldmVudFRpbWUgPSByZXF1ZXN0RXZlbnRUaW1lKCk7XG4gIHZhciBsYW5lID0gU2VsZWN0aXZlSHlkcmF0aW9uTGFuZTtcbiAgc2NoZWR1bGVVcGRhdGVPbkZpYmVyKGZpYmVyLCBsYW5lLCBldmVudFRpbWUpO1xuICBtYXJrUmV0cnlMYW5lSWZOb3RIeWRyYXRlZChmaWJlciwgbGFuZSk7XG59XG5mdW5jdGlvbiBhdHRlbXB0SHlkcmF0aW9uQXRDdXJyZW50UHJpb3JpdHkkMShmaWJlcikge1xuICBpZiAoZmliZXIudGFnICE9PSBTdXNwZW5zZUNvbXBvbmVudCkge1xuICAgIC8vIFdlIGlnbm9yZSBIb3N0Um9vdHMgaGVyZSBiZWNhdXNlIHdlIGNhbid0IGluY3JlYXNlXG4gICAgLy8gdGhlaXIgcHJpb3JpdHkgb3RoZXIgdGhhbiBzeW5jaHJvbm91c2x5IGZsdXNoIGl0LlxuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBldmVudFRpbWUgPSByZXF1ZXN0RXZlbnRUaW1lKCk7XG4gIHZhciBsYW5lID0gcmVxdWVzdFVwZGF0ZUxhbmUoZmliZXIpO1xuICBzY2hlZHVsZVVwZGF0ZU9uRmliZXIoZmliZXIsIGxhbmUsIGV2ZW50VGltZSk7XG4gIG1hcmtSZXRyeUxhbmVJZk5vdEh5ZHJhdGVkKGZpYmVyLCBsYW5lKTtcbn1cbmZ1bmN0aW9uIHJ1bldpdGhQcmlvcml0eSQyKHByaW9yaXR5LCBmbikge1xuXG4gIHRyeSB7XG4gICAgc2V0Q3VycmVudFVwZGF0ZUxhbmVQcmlvcml0eShwcmlvcml0eSk7XG4gICAgcmV0dXJuIGZuKCk7XG4gIH0gZmluYWxseSB7XG4gIH1cbn1cbmZ1bmN0aW9uIGZpbmRIb3N0SW5zdGFuY2VXaXRoTm9Qb3J0YWxzKGZpYmVyKSB7XG4gIHZhciBob3N0RmliZXIgPSBmaW5kQ3VycmVudEhvc3RGaWJlcldpdGhOb1BvcnRhbHMoZmliZXIpO1xuXG4gIGlmIChob3N0RmliZXIgPT09IG51bGwpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGlmIChob3N0RmliZXIudGFnID09PSBGdW5kYW1lbnRhbENvbXBvbmVudCkge1xuICAgIHJldHVybiBob3N0RmliZXIuc3RhdGVOb2RlLmluc3RhbmNlO1xuICB9XG5cbiAgcmV0dXJuIGhvc3RGaWJlci5zdGF0ZU5vZGU7XG59XG5cbnZhciBzaG91bGRTdXNwZW5kSW1wbCA9IGZ1bmN0aW9uIChmaWJlcikge1xuICByZXR1cm4gZmFsc2U7XG59O1xuXG5mdW5jdGlvbiBzaG91bGRTdXNwZW5kKGZpYmVyKSB7XG4gIHJldHVybiBzaG91bGRTdXNwZW5kSW1wbChmaWJlcik7XG59XG52YXIgb3ZlcnJpZGVIb29rU3RhdGUgPSBudWxsO1xudmFyIG92ZXJyaWRlSG9va1N0YXRlRGVsZXRlUGF0aCA9IG51bGw7XG52YXIgb3ZlcnJpZGVIb29rU3RhdGVSZW5hbWVQYXRoID0gbnVsbDtcbnZhciBvdmVycmlkZVByb3BzID0gbnVsbDtcbnZhciBvdmVycmlkZVByb3BzRGVsZXRlUGF0aCA9IG51bGw7XG52YXIgb3ZlcnJpZGVQcm9wc1JlbmFtZVBhdGggPSBudWxsO1xudmFyIHNjaGVkdWxlVXBkYXRlID0gbnVsbDtcbnZhciBzZXRTdXNwZW5zZUhhbmRsZXIgPSBudWxsO1xuXG57XG4gIHZhciBjb3B5V2l0aERlbGV0ZUltcGwgPSBmdW5jdGlvbiAob2JqLCBwYXRoLCBpbmRleCkge1xuICAgIHZhciBrZXkgPSBwYXRoW2luZGV4XTtcbiAgICB2YXIgdXBkYXRlZCA9IEFycmF5LmlzQXJyYXkob2JqKSA/IG9iai5zbGljZSgpIDogX2Fzc2lnbih7fSwgb2JqKTtcblxuICAgIGlmIChpbmRleCArIDEgPT09IHBhdGgubGVuZ3RoKSB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh1cGRhdGVkKSkge1xuICAgICAgICB1cGRhdGVkLnNwbGljZShrZXksIDEpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVsZXRlIHVwZGF0ZWRba2V5XTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHVwZGF0ZWQ7XG4gICAgfSAvLyAkRmxvd0ZpeE1lIG51bWJlciBvciBzdHJpbmcgaXMgZmluZSBoZXJlXG5cblxuICAgIHVwZGF0ZWRba2V5XSA9IGNvcHlXaXRoRGVsZXRlSW1wbChvYmpba2V5XSwgcGF0aCwgaW5kZXggKyAxKTtcbiAgICByZXR1cm4gdXBkYXRlZDtcbiAgfTtcblxuICB2YXIgY29weVdpdGhEZWxldGUgPSBmdW5jdGlvbiAob2JqLCBwYXRoKSB7XG4gICAgcmV0dXJuIGNvcHlXaXRoRGVsZXRlSW1wbChvYmosIHBhdGgsIDApO1xuICB9O1xuXG4gIHZhciBjb3B5V2l0aFJlbmFtZUltcGwgPSBmdW5jdGlvbiAob2JqLCBvbGRQYXRoLCBuZXdQYXRoLCBpbmRleCkge1xuICAgIHZhciBvbGRLZXkgPSBvbGRQYXRoW2luZGV4XTtcbiAgICB2YXIgdXBkYXRlZCA9IEFycmF5LmlzQXJyYXkob2JqKSA/IG9iai5zbGljZSgpIDogX2Fzc2lnbih7fSwgb2JqKTtcblxuICAgIGlmIChpbmRleCArIDEgPT09IG9sZFBhdGgubGVuZ3RoKSB7XG4gICAgICB2YXIgbmV3S2V5ID0gbmV3UGF0aFtpbmRleF07IC8vICRGbG93Rml4TWUgbnVtYmVyIG9yIHN0cmluZyBpcyBmaW5lIGhlcmVcblxuICAgICAgdXBkYXRlZFtuZXdLZXldID0gdXBkYXRlZFtvbGRLZXldO1xuXG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh1cGRhdGVkKSkge1xuICAgICAgICB1cGRhdGVkLnNwbGljZShvbGRLZXksIDEpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVsZXRlIHVwZGF0ZWRbb2xkS2V5XTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gJEZsb3dGaXhNZSBudW1iZXIgb3Igc3RyaW5nIGlzIGZpbmUgaGVyZVxuICAgICAgdXBkYXRlZFtvbGRLZXldID0gY29weVdpdGhSZW5hbWVJbXBsKCAvLyAkRmxvd0ZpeE1lIG51bWJlciBvciBzdHJpbmcgaXMgZmluZSBoZXJlXG4gICAgICBvYmpbb2xkS2V5XSwgb2xkUGF0aCwgbmV3UGF0aCwgaW5kZXggKyAxKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdXBkYXRlZDtcbiAgfTtcblxuICB2YXIgY29weVdpdGhSZW5hbWUgPSBmdW5jdGlvbiAob2JqLCBvbGRQYXRoLCBuZXdQYXRoKSB7XG4gICAgaWYgKG9sZFBhdGgubGVuZ3RoICE9PSBuZXdQYXRoLmxlbmd0aCkge1xuICAgICAgd2FybignY29weVdpdGhSZW5hbWUoKSBleHBlY3RzIHBhdGhzIG9mIHRoZSBzYW1lIGxlbmd0aCcpO1xuXG4gICAgICByZXR1cm47XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmV3UGF0aC5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgaWYgKG9sZFBhdGhbaV0gIT09IG5ld1BhdGhbaV0pIHtcbiAgICAgICAgICB3YXJuKCdjb3B5V2l0aFJlbmFtZSgpIGV4cGVjdHMgcGF0aHMgdG8gYmUgdGhlIHNhbWUgZXhjZXB0IGZvciB0aGUgZGVlcGVzdCBrZXknKTtcblxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBjb3B5V2l0aFJlbmFtZUltcGwob2JqLCBvbGRQYXRoLCBuZXdQYXRoLCAwKTtcbiAgfTtcblxuICB2YXIgY29weVdpdGhTZXRJbXBsID0gZnVuY3Rpb24gKG9iaiwgcGF0aCwgaW5kZXgsIHZhbHVlKSB7XG4gICAgaWYgKGluZGV4ID49IHBhdGgubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgdmFyIGtleSA9IHBhdGhbaW5kZXhdO1xuICAgIHZhciB1cGRhdGVkID0gQXJyYXkuaXNBcnJheShvYmopID8gb2JqLnNsaWNlKCkgOiBfYXNzaWduKHt9LCBvYmopOyAvLyAkRmxvd0ZpeE1lIG51bWJlciBvciBzdHJpbmcgaXMgZmluZSBoZXJlXG5cbiAgICB1cGRhdGVkW2tleV0gPSBjb3B5V2l0aFNldEltcGwob2JqW2tleV0sIHBhdGgsIGluZGV4ICsgMSwgdmFsdWUpO1xuICAgIHJldHVybiB1cGRhdGVkO1xuICB9O1xuXG4gIHZhciBjb3B5V2l0aFNldCA9IGZ1bmN0aW9uIChvYmosIHBhdGgsIHZhbHVlKSB7XG4gICAgcmV0dXJuIGNvcHlXaXRoU2V0SW1wbChvYmosIHBhdGgsIDAsIHZhbHVlKTtcbiAgfTtcblxuICB2YXIgZmluZEhvb2sgPSBmdW5jdGlvbiAoZmliZXIsIGlkKSB7XG4gICAgLy8gRm9yIG5vdywgdGhlIFwiaWRcIiBvZiBzdGF0ZWZ1bCBob29rcyBpcyBqdXN0IHRoZSBzdGF0ZWZ1bCBob29rIGluZGV4LlxuICAgIC8vIFRoaXMgbWF5IGNoYW5nZSBpbiB0aGUgZnV0dXJlIHdpdGggZS5nLiBuZXN0ZWQgaG9va3MuXG4gICAgdmFyIGN1cnJlbnRIb29rID0gZmliZXIubWVtb2l6ZWRTdGF0ZTtcblxuICAgIHdoaWxlIChjdXJyZW50SG9vayAhPT0gbnVsbCAmJiBpZCA+IDApIHtcbiAgICAgIGN1cnJlbnRIb29rID0gY3VycmVudEhvb2submV4dDtcbiAgICAgIGlkLS07XG4gICAgfVxuXG4gICAgcmV0dXJuIGN1cnJlbnRIb29rO1xuICB9OyAvLyBTdXBwb3J0IERldlRvb2xzIGVkaXRhYmxlIHZhbHVlcyBmb3IgdXNlU3RhdGUgYW5kIHVzZVJlZHVjZXIuXG5cblxuICBvdmVycmlkZUhvb2tTdGF0ZSA9IGZ1bmN0aW9uIChmaWJlciwgaWQsIHBhdGgsIHZhbHVlKSB7XG4gICAgdmFyIGhvb2sgPSBmaW5kSG9vayhmaWJlciwgaWQpO1xuXG4gICAgaWYgKGhvb2sgIT09IG51bGwpIHtcbiAgICAgIHZhciBuZXdTdGF0ZSA9IGNvcHlXaXRoU2V0KGhvb2subWVtb2l6ZWRTdGF0ZSwgcGF0aCwgdmFsdWUpO1xuICAgICAgaG9vay5tZW1vaXplZFN0YXRlID0gbmV3U3RhdGU7XG4gICAgICBob29rLmJhc2VTdGF0ZSA9IG5ld1N0YXRlOyAvLyBXZSBhcmVuJ3QgYWN0dWFsbHkgYWRkaW5nIGFuIHVwZGF0ZSB0byB0aGUgcXVldWUsXG4gICAgICAvLyBiZWNhdXNlIHRoZXJlIGlzIG5vIHVwZGF0ZSB3ZSBjYW4gYWRkIGZvciB1c2VSZWR1Y2VyIGhvb2tzIHRoYXQgd29uJ3QgdHJpZ2dlciBhbiBlcnJvci5cbiAgICAgIC8vIChUaGVyZSdzIG5vIGFwcHJvcHJpYXRlIGFjdGlvbiB0eXBlIGZvciBEZXZUb29scyBvdmVycmlkZXMuKVxuICAgICAgLy8gQXMgYSByZXN1bHQgdGhvdWdoLCBSZWFjdCB3aWxsIHNlZSB0aGUgc2NoZWR1bGVkIHVwZGF0ZSBhcyBhIG5vb3AgYW5kIGJhaWxvdXQuXG4gICAgICAvLyBTaGFsbG93IGNsb25pbmcgcHJvcHMgd29ya3MgYXMgYSB3b3JrYXJvdW5kIGZvciBub3cgdG8gYnlwYXNzIHRoZSBiYWlsb3V0IGNoZWNrLlxuXG4gICAgICBmaWJlci5tZW1vaXplZFByb3BzID0gX2Fzc2lnbih7fSwgZmliZXIubWVtb2l6ZWRQcm9wcyk7XG4gICAgICBzY2hlZHVsZVVwZGF0ZU9uRmliZXIoZmliZXIsIFN5bmNMYW5lLCBOb1RpbWVzdGFtcCk7XG4gICAgfVxuICB9O1xuXG4gIG92ZXJyaWRlSG9va1N0YXRlRGVsZXRlUGF0aCA9IGZ1bmN0aW9uIChmaWJlciwgaWQsIHBhdGgpIHtcbiAgICB2YXIgaG9vayA9IGZpbmRIb29rKGZpYmVyLCBpZCk7XG5cbiAgICBpZiAoaG9vayAhPT0gbnVsbCkge1xuICAgICAgdmFyIG5ld1N0YXRlID0gY29weVdpdGhEZWxldGUoaG9vay5tZW1vaXplZFN0YXRlLCBwYXRoKTtcbiAgICAgIGhvb2subWVtb2l6ZWRTdGF0ZSA9IG5ld1N0YXRlO1xuICAgICAgaG9vay5iYXNlU3RhdGUgPSBuZXdTdGF0ZTsgLy8gV2UgYXJlbid0IGFjdHVhbGx5IGFkZGluZyBhbiB1cGRhdGUgdG8gdGhlIHF1ZXVlLFxuICAgICAgLy8gYmVjYXVzZSB0aGVyZSBpcyBubyB1cGRhdGUgd2UgY2FuIGFkZCBmb3IgdXNlUmVkdWNlciBob29rcyB0aGF0IHdvbid0IHRyaWdnZXIgYW4gZXJyb3IuXG4gICAgICAvLyAoVGhlcmUncyBubyBhcHByb3ByaWF0ZSBhY3Rpb24gdHlwZSBmb3IgRGV2VG9vbHMgb3ZlcnJpZGVzLilcbiAgICAgIC8vIEFzIGEgcmVzdWx0IHRob3VnaCwgUmVhY3Qgd2lsbCBzZWUgdGhlIHNjaGVkdWxlZCB1cGRhdGUgYXMgYSBub29wIGFuZCBiYWlsb3V0LlxuICAgICAgLy8gU2hhbGxvdyBjbG9uaW5nIHByb3BzIHdvcmtzIGFzIGEgd29ya2Fyb3VuZCBmb3Igbm93IHRvIGJ5cGFzcyB0aGUgYmFpbG91dCBjaGVjay5cblxuICAgICAgZmliZXIubWVtb2l6ZWRQcm9wcyA9IF9hc3NpZ24oe30sIGZpYmVyLm1lbW9pemVkUHJvcHMpO1xuICAgICAgc2NoZWR1bGVVcGRhdGVPbkZpYmVyKGZpYmVyLCBTeW5jTGFuZSwgTm9UaW1lc3RhbXApO1xuICAgIH1cbiAgfTtcblxuICBvdmVycmlkZUhvb2tTdGF0ZVJlbmFtZVBhdGggPSBmdW5jdGlvbiAoZmliZXIsIGlkLCBvbGRQYXRoLCBuZXdQYXRoKSB7XG4gICAgdmFyIGhvb2sgPSBmaW5kSG9vayhmaWJlciwgaWQpO1xuXG4gICAgaWYgKGhvb2sgIT09IG51bGwpIHtcbiAgICAgIHZhciBuZXdTdGF0ZSA9IGNvcHlXaXRoUmVuYW1lKGhvb2subWVtb2l6ZWRTdGF0ZSwgb2xkUGF0aCwgbmV3UGF0aCk7XG4gICAgICBob29rLm1lbW9pemVkU3RhdGUgPSBuZXdTdGF0ZTtcbiAgICAgIGhvb2suYmFzZVN0YXRlID0gbmV3U3RhdGU7IC8vIFdlIGFyZW4ndCBhY3R1YWxseSBhZGRpbmcgYW4gdXBkYXRlIHRvIHRoZSBxdWV1ZSxcbiAgICAgIC8vIGJlY2F1c2UgdGhlcmUgaXMgbm8gdXBkYXRlIHdlIGNhbiBhZGQgZm9yIHVzZVJlZHVjZXIgaG9va3MgdGhhdCB3b24ndCB0cmlnZ2VyIGFuIGVycm9yLlxuICAgICAgLy8gKFRoZXJlJ3Mgbm8gYXBwcm9wcmlhdGUgYWN0aW9uIHR5cGUgZm9yIERldlRvb2xzIG92ZXJyaWRlcy4pXG4gICAgICAvLyBBcyBhIHJlc3VsdCB0aG91Z2gsIFJlYWN0IHdpbGwgc2VlIHRoZSBzY2hlZHVsZWQgdXBkYXRlIGFzIGEgbm9vcCBhbmQgYmFpbG91dC5cbiAgICAgIC8vIFNoYWxsb3cgY2xvbmluZyBwcm9wcyB3b3JrcyBhcyBhIHdvcmthcm91bmQgZm9yIG5vdyB0byBieXBhc3MgdGhlIGJhaWxvdXQgY2hlY2suXG5cbiAgICAgIGZpYmVyLm1lbW9pemVkUHJvcHMgPSBfYXNzaWduKHt9LCBmaWJlci5tZW1vaXplZFByb3BzKTtcbiAgICAgIHNjaGVkdWxlVXBkYXRlT25GaWJlcihmaWJlciwgU3luY0xhbmUsIE5vVGltZXN0YW1wKTtcbiAgICB9XG4gIH07IC8vIFN1cHBvcnQgRGV2VG9vbHMgcHJvcHMgZm9yIGZ1bmN0aW9uIGNvbXBvbmVudHMsIGZvcndhcmRSZWYsIG1lbW8sIGhvc3QgY29tcG9uZW50cywgZXRjLlxuXG5cbiAgb3ZlcnJpZGVQcm9wcyA9IGZ1bmN0aW9uIChmaWJlciwgcGF0aCwgdmFsdWUpIHtcbiAgICBmaWJlci5wZW5kaW5nUHJvcHMgPSBjb3B5V2l0aFNldChmaWJlci5tZW1vaXplZFByb3BzLCBwYXRoLCB2YWx1ZSk7XG5cbiAgICBpZiAoZmliZXIuYWx0ZXJuYXRlKSB7XG4gICAgICBmaWJlci5hbHRlcm5hdGUucGVuZGluZ1Byb3BzID0gZmliZXIucGVuZGluZ1Byb3BzO1xuICAgIH1cblxuICAgIHNjaGVkdWxlVXBkYXRlT25GaWJlcihmaWJlciwgU3luY0xhbmUsIE5vVGltZXN0YW1wKTtcbiAgfTtcblxuICBvdmVycmlkZVByb3BzRGVsZXRlUGF0aCA9IGZ1bmN0aW9uIChmaWJlciwgcGF0aCkge1xuICAgIGZpYmVyLnBlbmRpbmdQcm9wcyA9IGNvcHlXaXRoRGVsZXRlKGZpYmVyLm1lbW9pemVkUHJvcHMsIHBhdGgpO1xuXG4gICAgaWYgKGZpYmVyLmFsdGVybmF0ZSkge1xuICAgICAgZmliZXIuYWx0ZXJuYXRlLnBlbmRpbmdQcm9wcyA9IGZpYmVyLnBlbmRpbmdQcm9wcztcbiAgICB9XG5cbiAgICBzY2hlZHVsZVVwZGF0ZU9uRmliZXIoZmliZXIsIFN5bmNMYW5lLCBOb1RpbWVzdGFtcCk7XG4gIH07XG5cbiAgb3ZlcnJpZGVQcm9wc1JlbmFtZVBhdGggPSBmdW5jdGlvbiAoZmliZXIsIG9sZFBhdGgsIG5ld1BhdGgpIHtcbiAgICBmaWJlci5wZW5kaW5nUHJvcHMgPSBjb3B5V2l0aFJlbmFtZShmaWJlci5tZW1vaXplZFByb3BzLCBvbGRQYXRoLCBuZXdQYXRoKTtcblxuICAgIGlmIChmaWJlci5hbHRlcm5hdGUpIHtcbiAgICAgIGZpYmVyLmFsdGVybmF0ZS5wZW5kaW5nUHJvcHMgPSBmaWJlci5wZW5kaW5nUHJvcHM7XG4gICAgfVxuXG4gICAgc2NoZWR1bGVVcGRhdGVPbkZpYmVyKGZpYmVyLCBTeW5jTGFuZSwgTm9UaW1lc3RhbXApO1xuICB9O1xuXG4gIHNjaGVkdWxlVXBkYXRlID0gZnVuY3Rpb24gKGZpYmVyKSB7XG4gICAgc2NoZWR1bGVVcGRhdGVPbkZpYmVyKGZpYmVyLCBTeW5jTGFuZSwgTm9UaW1lc3RhbXApO1xuICB9O1xuXG4gIHNldFN1c3BlbnNlSGFuZGxlciA9IGZ1bmN0aW9uIChuZXdTaG91bGRTdXNwZW5kSW1wbCkge1xuICAgIHNob3VsZFN1c3BlbmRJbXBsID0gbmV3U2hvdWxkU3VzcGVuZEltcGw7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGZpbmRIb3N0SW5zdGFuY2VCeUZpYmVyKGZpYmVyKSB7XG4gIHZhciBob3N0RmliZXIgPSBmaW5kQ3VycmVudEhvc3RGaWJlcihmaWJlcik7XG5cbiAgaWYgKGhvc3RGaWJlciA9PT0gbnVsbCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgcmV0dXJuIGhvc3RGaWJlci5zdGF0ZU5vZGU7XG59XG5cbmZ1bmN0aW9uIGVtcHR5RmluZEZpYmVyQnlIb3N0SW5zdGFuY2UoaW5zdGFuY2UpIHtcbiAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIGdldEN1cnJlbnRGaWJlckZvckRldlRvb2xzKCkge1xuICByZXR1cm4gY3VycmVudDtcbn1cblxuZnVuY3Rpb24gaW5qZWN0SW50b0RldlRvb2xzKGRldlRvb2xzQ29uZmlnKSB7XG4gIHZhciBmaW5kRmliZXJCeUhvc3RJbnN0YW5jZSA9IGRldlRvb2xzQ29uZmlnLmZpbmRGaWJlckJ5SG9zdEluc3RhbmNlO1xuICB2YXIgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0Q3VycmVudERpc3BhdGNoZXI7XG4gIHJldHVybiBpbmplY3RJbnRlcm5hbHMoe1xuICAgIGJ1bmRsZVR5cGU6IGRldlRvb2xzQ29uZmlnLmJ1bmRsZVR5cGUsXG4gICAgdmVyc2lvbjogZGV2VG9vbHNDb25maWcudmVyc2lvbixcbiAgICByZW5kZXJlclBhY2thZ2VOYW1lOiBkZXZUb29sc0NvbmZpZy5yZW5kZXJlclBhY2thZ2VOYW1lLFxuICAgIHJlbmRlcmVyQ29uZmlnOiBkZXZUb29sc0NvbmZpZy5yZW5kZXJlckNvbmZpZyxcbiAgICBvdmVycmlkZUhvb2tTdGF0ZTogb3ZlcnJpZGVIb29rU3RhdGUsXG4gICAgb3ZlcnJpZGVIb29rU3RhdGVEZWxldGVQYXRoOiBvdmVycmlkZUhvb2tTdGF0ZURlbGV0ZVBhdGgsXG4gICAgb3ZlcnJpZGVIb29rU3RhdGVSZW5hbWVQYXRoOiBvdmVycmlkZUhvb2tTdGF0ZVJlbmFtZVBhdGgsXG4gICAgb3ZlcnJpZGVQcm9wczogb3ZlcnJpZGVQcm9wcyxcbiAgICBvdmVycmlkZVByb3BzRGVsZXRlUGF0aDogb3ZlcnJpZGVQcm9wc0RlbGV0ZVBhdGgsXG4gICAgb3ZlcnJpZGVQcm9wc1JlbmFtZVBhdGg6IG92ZXJyaWRlUHJvcHNSZW5hbWVQYXRoLFxuICAgIHNldFN1c3BlbnNlSGFuZGxlcjogc2V0U3VzcGVuc2VIYW5kbGVyLFxuICAgIHNjaGVkdWxlVXBkYXRlOiBzY2hlZHVsZVVwZGF0ZSxcbiAgICBjdXJyZW50RGlzcGF0Y2hlclJlZjogUmVhY3RDdXJyZW50RGlzcGF0Y2hlcixcbiAgICBmaW5kSG9zdEluc3RhbmNlQnlGaWJlcjogZmluZEhvc3RJbnN0YW5jZUJ5RmliZXIsXG4gICAgZmluZEZpYmVyQnlIb3N0SW5zdGFuY2U6IGZpbmRGaWJlckJ5SG9zdEluc3RhbmNlIHx8IGVtcHR5RmluZEZpYmVyQnlIb3N0SW5zdGFuY2UsXG4gICAgLy8gUmVhY3QgUmVmcmVzaFxuICAgIGZpbmRIb3N0SW5zdGFuY2VzRm9yUmVmcmVzaDogIGZpbmRIb3N0SW5zdGFuY2VzRm9yUmVmcmVzaCAsXG4gICAgc2NoZWR1bGVSZWZyZXNoOiAgc2NoZWR1bGVSZWZyZXNoICxcbiAgICBzY2hlZHVsZVJvb3Q6ICBzY2hlZHVsZVJvb3QgLFxuICAgIHNldFJlZnJlc2hIYW5kbGVyOiAgc2V0UmVmcmVzaEhhbmRsZXIgLFxuICAgIC8vIEVuYWJsZXMgRGV2VG9vbHMgdG8gYXBwZW5kIG93bmVyIHN0YWNrcyB0byBlcnJvciBtZXNzYWdlcyBpbiBERVYgbW9kZS5cbiAgICBnZXRDdXJyZW50RmliZXI6ICBnZXRDdXJyZW50RmliZXJGb3JEZXZUb29scyBcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIFJlYWN0RE9NUm9vdChjb250YWluZXIsIG9wdGlvbnMpIHtcbiAgdGhpcy5faW50ZXJuYWxSb290ID0gY3JlYXRlUm9vdEltcGwoY29udGFpbmVyLCBDb25jdXJyZW50Um9vdCwgb3B0aW9ucyk7XG59XG5cbmZ1bmN0aW9uIFJlYWN0RE9NQmxvY2tpbmdSb290KGNvbnRhaW5lciwgdGFnLCBvcHRpb25zKSB7XG4gIHRoaXMuX2ludGVybmFsUm9vdCA9IGNyZWF0ZVJvb3RJbXBsKGNvbnRhaW5lciwgdGFnLCBvcHRpb25zKTtcbn1cblxuUmVhY3RET01Sb290LnByb3RvdHlwZS5yZW5kZXIgPSBSZWFjdERPTUJsb2NraW5nUm9vdC5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKGNoaWxkcmVuKSB7XG4gIHZhciByb290ID0gdGhpcy5faW50ZXJuYWxSb290O1xuXG4gIHtcbiAgICBpZiAodHlwZW9mIGFyZ3VtZW50c1sxXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgZXJyb3IoJ3JlbmRlciguLi4pOiBkb2VzIG5vdCBzdXBwb3J0IHRoZSBzZWNvbmQgY2FsbGJhY2sgYXJndW1lbnQuICcgKyAnVG8gZXhlY3V0ZSBhIHNpZGUgZWZmZWN0IGFmdGVyIHJlbmRlcmluZywgZGVjbGFyZSBpdCBpbiBhIGNvbXBvbmVudCBib2R5IHdpdGggdXNlRWZmZWN0KCkuJyk7XG4gICAgfVxuXG4gICAgdmFyIGNvbnRhaW5lciA9IHJvb3QuY29udGFpbmVySW5mbztcblxuICAgIGlmIChjb250YWluZXIubm9kZVR5cGUgIT09IENPTU1FTlRfTk9ERSkge1xuICAgICAgdmFyIGhvc3RJbnN0YW5jZSA9IGZpbmRIb3N0SW5zdGFuY2VXaXRoTm9Qb3J0YWxzKHJvb3QuY3VycmVudCk7XG5cbiAgICAgIGlmIChob3N0SW5zdGFuY2UpIHtcbiAgICAgICAgaWYgKGhvc3RJbnN0YW5jZS5wYXJlbnROb2RlICE9PSBjb250YWluZXIpIHtcbiAgICAgICAgICBlcnJvcigncmVuZGVyKC4uLik6IEl0IGxvb2tzIGxpa2UgdGhlIFJlYWN0LXJlbmRlcmVkIGNvbnRlbnQgb2YgdGhlICcgKyAncm9vdCBjb250YWluZXIgd2FzIHJlbW92ZWQgd2l0aG91dCB1c2luZyBSZWFjdC4gVGhpcyBpcyBub3QgJyArICdzdXBwb3J0ZWQgYW5kIHdpbGwgY2F1c2UgZXJyb3JzLiBJbnN0ZWFkLCBjYWxsICcgKyBcInJvb3QudW5tb3VudCgpIHRvIGVtcHR5IGEgcm9vdCdzIGNvbnRhaW5lci5cIik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB1cGRhdGVDb250YWluZXIoY2hpbGRyZW4sIHJvb3QsIG51bGwsIG51bGwpO1xufTtcblxuUmVhY3RET01Sb290LnByb3RvdHlwZS51bm1vdW50ID0gUmVhY3RET01CbG9ja2luZ1Jvb3QucHJvdG90eXBlLnVubW91bnQgPSBmdW5jdGlvbiAoKSB7XG4gIHtcbiAgICBpZiAodHlwZW9mIGFyZ3VtZW50c1swXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgZXJyb3IoJ3VubW91bnQoLi4uKTogZG9lcyBub3Qgc3VwcG9ydCBhIGNhbGxiYWNrIGFyZ3VtZW50LiAnICsgJ1RvIGV4ZWN1dGUgYSBzaWRlIGVmZmVjdCBhZnRlciByZW5kZXJpbmcsIGRlY2xhcmUgaXQgaW4gYSBjb21wb25lbnQgYm9keSB3aXRoIHVzZUVmZmVjdCgpLicpO1xuICAgIH1cbiAgfVxuXG4gIHZhciByb290ID0gdGhpcy5faW50ZXJuYWxSb290O1xuICB2YXIgY29udGFpbmVyID0gcm9vdC5jb250YWluZXJJbmZvO1xuICB1cGRhdGVDb250YWluZXIobnVsbCwgcm9vdCwgbnVsbCwgZnVuY3Rpb24gKCkge1xuICAgIHVubWFya0NvbnRhaW5lckFzUm9vdChjb250YWluZXIpO1xuICB9KTtcbn07XG5cbmZ1bmN0aW9uIGNyZWF0ZVJvb3RJbXBsKGNvbnRhaW5lciwgdGFnLCBvcHRpb25zKSB7XG4gIC8vIFRhZyBpcyBlaXRoZXIgTGVnYWN5Um9vdCBvciBDb25jdXJyZW50IFJvb3RcbiAgdmFyIGh5ZHJhdGUgPSBvcHRpb25zICE9IG51bGwgJiYgb3B0aW9ucy5oeWRyYXRlID09PSB0cnVlO1xuICB2YXIgaHlkcmF0aW9uQ2FsbGJhY2tzID0gb3B0aW9ucyAhPSBudWxsICYmIG9wdGlvbnMuaHlkcmF0aW9uT3B0aW9ucyB8fCBudWxsO1xuICB2YXIgbXV0YWJsZVNvdXJjZXMgPSBvcHRpb25zICE9IG51bGwgJiYgb3B0aW9ucy5oeWRyYXRpb25PcHRpb25zICE9IG51bGwgJiYgb3B0aW9ucy5oeWRyYXRpb25PcHRpb25zLm11dGFibGVTb3VyY2VzIHx8IG51bGw7XG4gIHZhciByb290ID0gY3JlYXRlQ29udGFpbmVyKGNvbnRhaW5lciwgdGFnLCBoeWRyYXRlKTtcbiAgbWFya0NvbnRhaW5lckFzUm9vdChyb290LmN1cnJlbnQsIGNvbnRhaW5lcik7XG4gIHZhciBjb250YWluZXJOb2RlVHlwZSA9IGNvbnRhaW5lci5ub2RlVHlwZTtcblxuICB7XG4gICAgdmFyIHJvb3RDb250YWluZXJFbGVtZW50ID0gY29udGFpbmVyLm5vZGVUeXBlID09PSBDT01NRU5UX05PREUgPyBjb250YWluZXIucGFyZW50Tm9kZSA6IGNvbnRhaW5lcjtcbiAgICBsaXN0ZW5Ub0FsbFN1cHBvcnRlZEV2ZW50cyhyb290Q29udGFpbmVyRWxlbWVudCk7XG4gIH1cblxuICBpZiAobXV0YWJsZVNvdXJjZXMpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG11dGFibGVTb3VyY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgbXV0YWJsZVNvdXJjZSA9IG11dGFibGVTb3VyY2VzW2ldO1xuICAgICAgcmVnaXN0ZXJNdXRhYmxlU291cmNlRm9ySHlkcmF0aW9uKHJvb3QsIG11dGFibGVTb3VyY2UpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByb290O1xufVxuZnVuY3Rpb24gY3JlYXRlTGVnYWN5Um9vdChjb250YWluZXIsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIG5ldyBSZWFjdERPTUJsb2NraW5nUm9vdChjb250YWluZXIsIExlZ2FjeVJvb3QsIG9wdGlvbnMpO1xufVxuZnVuY3Rpb24gaXNWYWxpZENvbnRhaW5lcihub2RlKSB7XG4gIHJldHVybiAhIShub2RlICYmIChub2RlLm5vZGVUeXBlID09PSBFTEVNRU5UX05PREUgfHwgbm9kZS5ub2RlVHlwZSA9PT0gRE9DVU1FTlRfTk9ERSB8fCBub2RlLm5vZGVUeXBlID09PSBET0NVTUVOVF9GUkFHTUVOVF9OT0RFIHx8IG5vZGUubm9kZVR5cGUgPT09IENPTU1FTlRfTk9ERSAmJiBub2RlLm5vZGVWYWx1ZSA9PT0gJyByZWFjdC1tb3VudC1wb2ludC11bnN0YWJsZSAnKSk7XG59XG5cbnZhciBSZWFjdEN1cnJlbnRPd25lciQzID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3RDdXJyZW50T3duZXI7XG52YXIgdG9wTGV2ZWxVcGRhdGVXYXJuaW5ncztcbnZhciB3YXJuZWRBYm91dEh5ZHJhdGVBUEkgPSBmYWxzZTtcblxue1xuICB0b3BMZXZlbFVwZGF0ZVdhcm5pbmdzID0gZnVuY3Rpb24gKGNvbnRhaW5lcikge1xuICAgIGlmIChjb250YWluZXIuX3JlYWN0Um9vdENvbnRhaW5lciAmJiBjb250YWluZXIubm9kZVR5cGUgIT09IENPTU1FTlRfTk9ERSkge1xuICAgICAgdmFyIGhvc3RJbnN0YW5jZSA9IGZpbmRIb3N0SW5zdGFuY2VXaXRoTm9Qb3J0YWxzKGNvbnRhaW5lci5fcmVhY3RSb290Q29udGFpbmVyLl9pbnRlcm5hbFJvb3QuY3VycmVudCk7XG5cbiAgICAgIGlmIChob3N0SW5zdGFuY2UpIHtcbiAgICAgICAgaWYgKGhvc3RJbnN0YW5jZS5wYXJlbnROb2RlICE9PSBjb250YWluZXIpIHtcbiAgICAgICAgICBlcnJvcigncmVuZGVyKC4uLik6IEl0IGxvb2tzIGxpa2UgdGhlIFJlYWN0LXJlbmRlcmVkIGNvbnRlbnQgb2YgdGhpcyAnICsgJ2NvbnRhaW5lciB3YXMgcmVtb3ZlZCB3aXRob3V0IHVzaW5nIFJlYWN0LiBUaGlzIGlzIG5vdCAnICsgJ3N1cHBvcnRlZCBhbmQgd2lsbCBjYXVzZSBlcnJvcnMuIEluc3RlYWQsIGNhbGwgJyArICdSZWFjdERPTS51bm1vdW50Q29tcG9uZW50QXROb2RlIHRvIGVtcHR5IGEgY29udGFpbmVyLicpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGlzUm9vdFJlbmRlcmVkQnlTb21lUmVhY3QgPSAhIWNvbnRhaW5lci5fcmVhY3RSb290Q29udGFpbmVyO1xuICAgIHZhciByb290RWwgPSBnZXRSZWFjdFJvb3RFbGVtZW50SW5Db250YWluZXIoY29udGFpbmVyKTtcbiAgICB2YXIgaGFzTm9uUm9vdFJlYWN0Q2hpbGQgPSAhIShyb290RWwgJiYgZ2V0SW5zdGFuY2VGcm9tTm9kZShyb290RWwpKTtcblxuICAgIGlmIChoYXNOb25Sb290UmVhY3RDaGlsZCAmJiAhaXNSb290UmVuZGVyZWRCeVNvbWVSZWFjdCkge1xuICAgICAgZXJyb3IoJ3JlbmRlciguLi4pOiBSZXBsYWNpbmcgUmVhY3QtcmVuZGVyZWQgY2hpbGRyZW4gd2l0aCBhIG5ldyByb290ICcgKyAnY29tcG9uZW50LiBJZiB5b3UgaW50ZW5kZWQgdG8gdXBkYXRlIHRoZSBjaGlsZHJlbiBvZiB0aGlzIG5vZGUsICcgKyAneW91IHNob3VsZCBpbnN0ZWFkIGhhdmUgdGhlIGV4aXN0aW5nIGNoaWxkcmVuIHVwZGF0ZSB0aGVpciBzdGF0ZSAnICsgJ2FuZCByZW5kZXIgdGhlIG5ldyBjb21wb25lbnRzIGluc3RlYWQgb2YgY2FsbGluZyBSZWFjdERPTS5yZW5kZXIuJyk7XG4gICAgfVxuXG4gICAgaWYgKGNvbnRhaW5lci5ub2RlVHlwZSA9PT0gRUxFTUVOVF9OT0RFICYmIGNvbnRhaW5lci50YWdOYW1lICYmIGNvbnRhaW5lci50YWdOYW1lLnRvVXBwZXJDYXNlKCkgPT09ICdCT0RZJykge1xuICAgICAgZXJyb3IoJ3JlbmRlcigpOiBSZW5kZXJpbmcgY29tcG9uZW50cyBkaXJlY3RseSBpbnRvIGRvY3VtZW50LmJvZHkgaXMgJyArICdkaXNjb3VyYWdlZCwgc2luY2UgaXRzIGNoaWxkcmVuIGFyZSBvZnRlbiBtYW5pcHVsYXRlZCBieSB0aGlyZC1wYXJ0eSAnICsgJ3NjcmlwdHMgYW5kIGJyb3dzZXIgZXh0ZW5zaW9ucy4gVGhpcyBtYXkgbGVhZCB0byBzdWJ0bGUgJyArICdyZWNvbmNpbGlhdGlvbiBpc3N1ZXMuIFRyeSByZW5kZXJpbmcgaW50byBhIGNvbnRhaW5lciBlbGVtZW50IGNyZWF0ZWQgJyArICdmb3IgeW91ciBhcHAuJyk7XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBnZXRSZWFjdFJvb3RFbGVtZW50SW5Db250YWluZXIoY29udGFpbmVyKSB7XG4gIGlmICghY29udGFpbmVyKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBpZiAoY29udGFpbmVyLm5vZGVUeXBlID09PSBET0NVTUVOVF9OT0RFKSB7XG4gICAgcmV0dXJuIGNvbnRhaW5lci5kb2N1bWVudEVsZW1lbnQ7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGNvbnRhaW5lci5maXJzdENoaWxkO1xuICB9XG59XG5cbmZ1bmN0aW9uIHNob3VsZEh5ZHJhdGVEdWVUb0xlZ2FjeUhldXJpc3RpYyhjb250YWluZXIpIHtcbiAgdmFyIHJvb3RFbGVtZW50ID0gZ2V0UmVhY3RSb290RWxlbWVudEluQ29udGFpbmVyKGNvbnRhaW5lcik7XG4gIHJldHVybiAhIShyb290RWxlbWVudCAmJiByb290RWxlbWVudC5ub2RlVHlwZSA9PT0gRUxFTUVOVF9OT0RFICYmIHJvb3RFbGVtZW50Lmhhc0F0dHJpYnV0ZShST09UX0FUVFJJQlVURV9OQU1FKSk7XG59XG5cbmZ1bmN0aW9uIGxlZ2FjeUNyZWF0ZVJvb3RGcm9tRE9NQ29udGFpbmVyKGNvbnRhaW5lciwgZm9yY2VIeWRyYXRlKSB7XG4gIHZhciBzaG91bGRIeWRyYXRlID0gZm9yY2VIeWRyYXRlIHx8IHNob3VsZEh5ZHJhdGVEdWVUb0xlZ2FjeUhldXJpc3RpYyhjb250YWluZXIpOyAvLyBGaXJzdCBjbGVhciBhbnkgZXhpc3RpbmcgY29udGVudC5cblxuICBpZiAoIXNob3VsZEh5ZHJhdGUpIHtcbiAgICB2YXIgd2FybmVkID0gZmFsc2U7XG4gICAgdmFyIHJvb3RTaWJsaW5nO1xuXG4gICAgd2hpbGUgKHJvb3RTaWJsaW5nID0gY29udGFpbmVyLmxhc3RDaGlsZCkge1xuICAgICAge1xuICAgICAgICBpZiAoIXdhcm5lZCAmJiByb290U2libGluZy5ub2RlVHlwZSA9PT0gRUxFTUVOVF9OT0RFICYmIHJvb3RTaWJsaW5nLmhhc0F0dHJpYnV0ZShST09UX0FUVFJJQlVURV9OQU1FKSkge1xuICAgICAgICAgIHdhcm5lZCA9IHRydWU7XG5cbiAgICAgICAgICBlcnJvcigncmVuZGVyKCk6IFRhcmdldCBub2RlIGhhcyBtYXJrdXAgcmVuZGVyZWQgYnkgUmVhY3QsIGJ1dCB0aGVyZSAnICsgJ2FyZSB1bnJlbGF0ZWQgbm9kZXMgYXMgd2VsbC4gVGhpcyBpcyBtb3N0IGNvbW1vbmx5IGNhdXNlZCBieSAnICsgJ3doaXRlLXNwYWNlIGluc2VydGVkIGFyb3VuZCBzZXJ2ZXItcmVuZGVyZWQgbWFya3VwLicpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNvbnRhaW5lci5yZW1vdmVDaGlsZChyb290U2libGluZyk7XG4gICAgfVxuICB9XG5cbiAge1xuICAgIGlmIChzaG91bGRIeWRyYXRlICYmICFmb3JjZUh5ZHJhdGUgJiYgIXdhcm5lZEFib3V0SHlkcmF0ZUFQSSkge1xuICAgICAgd2FybmVkQWJvdXRIeWRyYXRlQVBJID0gdHJ1ZTtcblxuICAgICAgd2FybigncmVuZGVyKCk6IENhbGxpbmcgUmVhY3RET00ucmVuZGVyKCkgdG8gaHlkcmF0ZSBzZXJ2ZXItcmVuZGVyZWQgbWFya3VwICcgKyAnd2lsbCBzdG9wIHdvcmtpbmcgaW4gUmVhY3QgdjE4LiBSZXBsYWNlIHRoZSBSZWFjdERPTS5yZW5kZXIoKSBjYWxsICcgKyAnd2l0aCBSZWFjdERPTS5oeWRyYXRlKCkgaWYgeW91IHdhbnQgUmVhY3QgdG8gYXR0YWNoIHRvIHRoZSBzZXJ2ZXIgSFRNTC4nKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gY3JlYXRlTGVnYWN5Um9vdChjb250YWluZXIsIHNob3VsZEh5ZHJhdGUgPyB7XG4gICAgaHlkcmF0ZTogdHJ1ZVxuICB9IDogdW5kZWZpbmVkKTtcbn1cblxuZnVuY3Rpb24gd2Fybk9uSW52YWxpZENhbGxiYWNrJDEoY2FsbGJhY2ssIGNhbGxlck5hbWUpIHtcbiAge1xuICAgIGlmIChjYWxsYmFjayAhPT0gbnVsbCAmJiB0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGVycm9yKCclcyguLi4pOiBFeHBlY3RlZCB0aGUgbGFzdCBvcHRpb25hbCBgY2FsbGJhY2tgIGFyZ3VtZW50IHRvIGJlIGEgJyArICdmdW5jdGlvbi4gSW5zdGVhZCByZWNlaXZlZDogJXMuJywgY2FsbGVyTmFtZSwgY2FsbGJhY2spO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBsZWdhY3lSZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lcihwYXJlbnRDb21wb25lbnQsIGNoaWxkcmVuLCBjb250YWluZXIsIGZvcmNlSHlkcmF0ZSwgY2FsbGJhY2spIHtcbiAge1xuICAgIHRvcExldmVsVXBkYXRlV2FybmluZ3MoY29udGFpbmVyKTtcbiAgICB3YXJuT25JbnZhbGlkQ2FsbGJhY2skMShjYWxsYmFjayA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGNhbGxiYWNrLCAncmVuZGVyJyk7XG4gIH0gLy8gVE9ETzogV2l0aG91dCBgYW55YCB0eXBlLCBGbG93IHNheXMgXCJQcm9wZXJ0eSBjYW5ub3QgYmUgYWNjZXNzZWQgb24gYW55XG4gIC8vIG1lbWJlciBvZiBpbnRlcnNlY3Rpb24gdHlwZS5cIiBXaHl5eXl5eS5cblxuXG4gIHZhciByb290ID0gY29udGFpbmVyLl9yZWFjdFJvb3RDb250YWluZXI7XG4gIHZhciBmaWJlclJvb3Q7XG5cbiAgaWYgKCFyb290KSB7XG4gICAgLy8gSW5pdGlhbCBtb3VudFxuICAgIHJvb3QgPSBjb250YWluZXIuX3JlYWN0Um9vdENvbnRhaW5lciA9IGxlZ2FjeUNyZWF0ZVJvb3RGcm9tRE9NQ29udGFpbmVyKGNvbnRhaW5lciwgZm9yY2VIeWRyYXRlKTtcbiAgICBmaWJlclJvb3QgPSByb290Ll9pbnRlcm5hbFJvb3Q7XG5cbiAgICBpZiAodHlwZW9mIGNhbGxiYWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB2YXIgb3JpZ2luYWxDYWxsYmFjayA9IGNhbGxiYWNrO1xuXG4gICAgICBjYWxsYmFjayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGluc3RhbmNlID0gZ2V0UHVibGljUm9vdEluc3RhbmNlKGZpYmVyUm9vdCk7XG4gICAgICAgIG9yaWdpbmFsQ2FsbGJhY2suY2FsbChpbnN0YW5jZSk7XG4gICAgICB9O1xuICAgIH0gLy8gSW5pdGlhbCBtb3VudCBzaG91bGQgbm90IGJlIGJhdGNoZWQuXG5cblxuICAgIHVuYmF0Y2hlZFVwZGF0ZXMoZnVuY3Rpb24gKCkge1xuICAgICAgdXBkYXRlQ29udGFpbmVyKGNoaWxkcmVuLCBmaWJlclJvb3QsIHBhcmVudENvbXBvbmVudCwgY2FsbGJhY2spO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIGZpYmVyUm9vdCA9IHJvb3QuX2ludGVybmFsUm9vdDtcblxuICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHZhciBfb3JpZ2luYWxDYWxsYmFjayA9IGNhbGxiYWNrO1xuXG4gICAgICBjYWxsYmFjayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGluc3RhbmNlID0gZ2V0UHVibGljUm9vdEluc3RhbmNlKGZpYmVyUm9vdCk7XG5cbiAgICAgICAgX29yaWdpbmFsQ2FsbGJhY2suY2FsbChpbnN0YW5jZSk7XG4gICAgICB9O1xuICAgIH0gLy8gVXBkYXRlXG5cblxuICAgIHVwZGF0ZUNvbnRhaW5lcihjaGlsZHJlbiwgZmliZXJSb290LCBwYXJlbnRDb21wb25lbnQsIGNhbGxiYWNrKTtcbiAgfVxuXG4gIHJldHVybiBnZXRQdWJsaWNSb290SW5zdGFuY2UoZmliZXJSb290KTtcbn1cblxuZnVuY3Rpb24gZmluZERPTU5vZGUoY29tcG9uZW50T3JFbGVtZW50KSB7XG4gIHtcbiAgICB2YXIgb3duZXIgPSBSZWFjdEN1cnJlbnRPd25lciQzLmN1cnJlbnQ7XG5cbiAgICBpZiAob3duZXIgIT09IG51bGwgJiYgb3duZXIuc3RhdGVOb2RlICE9PSBudWxsKSB7XG4gICAgICB2YXIgd2FybmVkQWJvdXRSZWZzSW5SZW5kZXIgPSBvd25lci5zdGF0ZU5vZGUuX3dhcm5lZEFib3V0UmVmc0luUmVuZGVyO1xuXG4gICAgICBpZiAoIXdhcm5lZEFib3V0UmVmc0luUmVuZGVyKSB7XG4gICAgICAgIGVycm9yKCclcyBpcyBhY2Nlc3NpbmcgZmluZERPTU5vZGUgaW5zaWRlIGl0cyByZW5kZXIoKS4gJyArICdyZW5kZXIoKSBzaG91bGQgYmUgYSBwdXJlIGZ1bmN0aW9uIG9mIHByb3BzIGFuZCBzdGF0ZS4gSXQgc2hvdWxkICcgKyAnbmV2ZXIgYWNjZXNzIHNvbWV0aGluZyB0aGF0IHJlcXVpcmVzIHN0YWxlIGRhdGEgZnJvbSB0aGUgcHJldmlvdXMgJyArICdyZW5kZXIsIHN1Y2ggYXMgcmVmcy4gTW92ZSB0aGlzIGxvZ2ljIHRvIGNvbXBvbmVudERpZE1vdW50IGFuZCAnICsgJ2NvbXBvbmVudERpZFVwZGF0ZSBpbnN0ZWFkLicsIGdldENvbXBvbmVudE5hbWUob3duZXIudHlwZSkgfHwgJ0EgY29tcG9uZW50Jyk7XG4gICAgICB9XG5cbiAgICAgIG93bmVyLnN0YXRlTm9kZS5fd2FybmVkQWJvdXRSZWZzSW5SZW5kZXIgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIGlmIChjb21wb25lbnRPckVsZW1lbnQgPT0gbnVsbCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgaWYgKGNvbXBvbmVudE9yRWxlbWVudC5ub2RlVHlwZSA9PT0gRUxFTUVOVF9OT0RFKSB7XG4gICAgcmV0dXJuIGNvbXBvbmVudE9yRWxlbWVudDtcbiAgfVxuXG4gIHtcbiAgICByZXR1cm4gZmluZEhvc3RJbnN0YW5jZVdpdGhXYXJuaW5nKGNvbXBvbmVudE9yRWxlbWVudCwgJ2ZpbmRET01Ob2RlJyk7XG4gIH1cbn1cbmZ1bmN0aW9uIGh5ZHJhdGUoZWxlbWVudCwgY29udGFpbmVyLCBjYWxsYmFjaykge1xuICBpZiAoIWlzVmFsaWRDb250YWluZXIoY29udGFpbmVyKSkge1xuICAgIHtcbiAgICAgIHRocm93IEVycm9yKCBcIlRhcmdldCBjb250YWluZXIgaXMgbm90IGEgRE9NIGVsZW1lbnQuXCIgKTtcbiAgICB9XG4gIH1cblxuICB7XG4gICAgdmFyIGlzTW9kZXJuUm9vdCA9IGlzQ29udGFpbmVyTWFya2VkQXNSb290KGNvbnRhaW5lcikgJiYgY29udGFpbmVyLl9yZWFjdFJvb3RDb250YWluZXIgPT09IHVuZGVmaW5lZDtcblxuICAgIGlmIChpc01vZGVyblJvb3QpIHtcbiAgICAgIGVycm9yKCdZb3UgYXJlIGNhbGxpbmcgUmVhY3RET00uaHlkcmF0ZSgpIG9uIGEgY29udGFpbmVyIHRoYXQgd2FzIHByZXZpb3VzbHkgJyArICdwYXNzZWQgdG8gUmVhY3RET00uY3JlYXRlUm9vdCgpLiBUaGlzIGlzIG5vdCBzdXBwb3J0ZWQuICcgKyAnRGlkIHlvdSBtZWFuIHRvIGNhbGwgY3JlYXRlUm9vdChjb250YWluZXIsIHtoeWRyYXRlOiB0cnVlfSkucmVuZGVyKGVsZW1lbnQpPycpO1xuICAgIH1cbiAgfSAvLyBUT0RPOiB0aHJvdyBvciB3YXJuIGlmIHdlIGNvdWxkbid0IGh5ZHJhdGU/XG5cblxuICByZXR1cm4gbGVnYWN5UmVuZGVyU3VidHJlZUludG9Db250YWluZXIobnVsbCwgZWxlbWVudCwgY29udGFpbmVyLCB0cnVlLCBjYWxsYmFjayk7XG59XG5mdW5jdGlvbiByZW5kZXIoZWxlbWVudCwgY29udGFpbmVyLCBjYWxsYmFjaykge1xuICBpZiAoIWlzVmFsaWRDb250YWluZXIoY29udGFpbmVyKSkge1xuICAgIHtcbiAgICAgIHRocm93IEVycm9yKCBcIlRhcmdldCBjb250YWluZXIgaXMgbm90IGEgRE9NIGVsZW1lbnQuXCIgKTtcbiAgICB9XG4gIH1cblxuICB7XG4gICAgdmFyIGlzTW9kZXJuUm9vdCA9IGlzQ29udGFpbmVyTWFya2VkQXNSb290KGNvbnRhaW5lcikgJiYgY29udGFpbmVyLl9yZWFjdFJvb3RDb250YWluZXIgPT09IHVuZGVmaW5lZDtcblxuICAgIGlmIChpc01vZGVyblJvb3QpIHtcbiAgICAgIGVycm9yKCdZb3UgYXJlIGNhbGxpbmcgUmVhY3RET00ucmVuZGVyKCkgb24gYSBjb250YWluZXIgdGhhdCB3YXMgcHJldmlvdXNseSAnICsgJ3Bhc3NlZCB0byBSZWFjdERPTS5jcmVhdGVSb290KCkuIFRoaXMgaXMgbm90IHN1cHBvcnRlZC4gJyArICdEaWQgeW91IG1lYW4gdG8gY2FsbCByb290LnJlbmRlcihlbGVtZW50KT8nKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbGVnYWN5UmVuZGVyU3VidHJlZUludG9Db250YWluZXIobnVsbCwgZWxlbWVudCwgY29udGFpbmVyLCBmYWxzZSwgY2FsbGJhY2spO1xufVxuZnVuY3Rpb24gdW5zdGFibGVfcmVuZGVyU3VidHJlZUludG9Db250YWluZXIocGFyZW50Q29tcG9uZW50LCBlbGVtZW50LCBjb250YWluZXJOb2RlLCBjYWxsYmFjaykge1xuICBpZiAoIWlzVmFsaWRDb250YWluZXIoY29udGFpbmVyTm9kZSkpIHtcbiAgICB7XG4gICAgICB0aHJvdyBFcnJvciggXCJUYXJnZXQgY29udGFpbmVyIGlzIG5vdCBhIERPTSBlbGVtZW50LlwiICk7XG4gICAgfVxuICB9XG5cbiAgaWYgKCEocGFyZW50Q29tcG9uZW50ICE9IG51bGwgJiYgaGFzKHBhcmVudENvbXBvbmVudCkpKSB7XG4gICAge1xuICAgICAgdGhyb3cgRXJyb3IoIFwicGFyZW50Q29tcG9uZW50IG11c3QgYmUgYSB2YWxpZCBSZWFjdCBDb21wb25lbnRcIiApO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBsZWdhY3lSZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lcihwYXJlbnRDb21wb25lbnQsIGVsZW1lbnQsIGNvbnRhaW5lck5vZGUsIGZhbHNlLCBjYWxsYmFjayk7XG59XG5mdW5jdGlvbiB1bm1vdW50Q29tcG9uZW50QXROb2RlKGNvbnRhaW5lcikge1xuICBpZiAoIWlzVmFsaWRDb250YWluZXIoY29udGFpbmVyKSkge1xuICAgIHtcbiAgICAgIHRocm93IEVycm9yKCBcInVubW91bnRDb21wb25lbnRBdE5vZGUoLi4uKTogVGFyZ2V0IGNvbnRhaW5lciBpcyBub3QgYSBET00gZWxlbWVudC5cIiApO1xuICAgIH1cbiAgfVxuXG4gIHtcbiAgICB2YXIgaXNNb2Rlcm5Sb290ID0gaXNDb250YWluZXJNYXJrZWRBc1Jvb3QoY29udGFpbmVyKSAmJiBjb250YWluZXIuX3JlYWN0Um9vdENvbnRhaW5lciA9PT0gdW5kZWZpbmVkO1xuXG4gICAgaWYgKGlzTW9kZXJuUm9vdCkge1xuICAgICAgZXJyb3IoJ1lvdSBhcmUgY2FsbGluZyBSZWFjdERPTS51bm1vdW50Q29tcG9uZW50QXROb2RlKCkgb24gYSBjb250YWluZXIgdGhhdCB3YXMgcHJldmlvdXNseSAnICsgJ3Bhc3NlZCB0byBSZWFjdERPTS5jcmVhdGVSb290KCkuIFRoaXMgaXMgbm90IHN1cHBvcnRlZC4gRGlkIHlvdSBtZWFuIHRvIGNhbGwgcm9vdC51bm1vdW50KCk/Jyk7XG4gICAgfVxuICB9XG5cbiAgaWYgKGNvbnRhaW5lci5fcmVhY3RSb290Q29udGFpbmVyKSB7XG4gICAge1xuICAgICAgdmFyIHJvb3RFbCA9IGdldFJlYWN0Um9vdEVsZW1lbnRJbkNvbnRhaW5lcihjb250YWluZXIpO1xuICAgICAgdmFyIHJlbmRlcmVkQnlEaWZmZXJlbnRSZWFjdCA9IHJvb3RFbCAmJiAhZ2V0SW5zdGFuY2VGcm9tTm9kZShyb290RWwpO1xuXG4gICAgICBpZiAocmVuZGVyZWRCeURpZmZlcmVudFJlYWN0KSB7XG4gICAgICAgIGVycm9yKFwidW5tb3VudENvbXBvbmVudEF0Tm9kZSgpOiBUaGUgbm9kZSB5b3UncmUgYXR0ZW1wdGluZyB0byB1bm1vdW50IFwiICsgJ3dhcyByZW5kZXJlZCBieSBhbm90aGVyIGNvcHkgb2YgUmVhY3QuJyk7XG4gICAgICB9XG4gICAgfSAvLyBVbm1vdW50IHNob3VsZCBub3QgYmUgYmF0Y2hlZC5cblxuXG4gICAgdW5iYXRjaGVkVXBkYXRlcyhmdW5jdGlvbiAoKSB7XG4gICAgICBsZWdhY3lSZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lcihudWxsLCBudWxsLCBjb250YWluZXIsIGZhbHNlLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vICRGbG93Rml4TWUgVGhpcyBzaG91bGQgcHJvYmFibHkgdXNlIGBkZWxldGUgY29udGFpbmVyLl9yZWFjdFJvb3RDb250YWluZXJgXG4gICAgICAgIGNvbnRhaW5lci5fcmVhY3RSb290Q29udGFpbmVyID0gbnVsbDtcbiAgICAgICAgdW5tYXJrQ29udGFpbmVyQXNSb290KGNvbnRhaW5lcik7XG4gICAgICB9KTtcbiAgICB9KTsgLy8gSWYgeW91IGNhbGwgdW5tb3VudENvbXBvbmVudEF0Tm9kZSB0d2ljZSBpbiBxdWljayBzdWNjZXNzaW9uLCB5b3UnbGxcbiAgICAvLyBnZXQgYHRydWVgIHR3aWNlLiBUaGF0J3MgcHJvYmFibHkgZmluZT9cblxuICAgIHJldHVybiB0cnVlO1xuICB9IGVsc2Uge1xuICAgIHtcbiAgICAgIHZhciBfcm9vdEVsID0gZ2V0UmVhY3RSb290RWxlbWVudEluQ29udGFpbmVyKGNvbnRhaW5lcik7XG5cbiAgICAgIHZhciBoYXNOb25Sb290UmVhY3RDaGlsZCA9ICEhKF9yb290RWwgJiYgZ2V0SW5zdGFuY2VGcm9tTm9kZShfcm9vdEVsKSk7IC8vIENoZWNrIGlmIHRoZSBjb250YWluZXIgaXRzZWxmIGlzIGEgUmVhY3Qgcm9vdCBub2RlLlxuXG4gICAgICB2YXIgaXNDb250YWluZXJSZWFjdFJvb3QgPSBjb250YWluZXIubm9kZVR5cGUgPT09IEVMRU1FTlRfTk9ERSAmJiBpc1ZhbGlkQ29udGFpbmVyKGNvbnRhaW5lci5wYXJlbnROb2RlKSAmJiAhIWNvbnRhaW5lci5wYXJlbnROb2RlLl9yZWFjdFJvb3RDb250YWluZXI7XG5cbiAgICAgIGlmIChoYXNOb25Sb290UmVhY3RDaGlsZCkge1xuICAgICAgICBlcnJvcihcInVubW91bnRDb21wb25lbnRBdE5vZGUoKTogVGhlIG5vZGUgeW91J3JlIGF0dGVtcHRpbmcgdG8gdW5tb3VudCBcIiArICd3YXMgcmVuZGVyZWQgYnkgUmVhY3QgYW5kIGlzIG5vdCBhIHRvcC1sZXZlbCBjb250YWluZXIuICVzJywgaXNDb250YWluZXJSZWFjdFJvb3QgPyAnWW91IG1heSBoYXZlIGFjY2lkZW50YWxseSBwYXNzZWQgaW4gYSBSZWFjdCByb290IG5vZGUgaW5zdGVhZCAnICsgJ29mIGl0cyBjb250YWluZXIuJyA6ICdJbnN0ZWFkLCBoYXZlIHRoZSBwYXJlbnQgY29tcG9uZW50IHVwZGF0ZSBpdHMgc3RhdGUgYW5kICcgKyAncmVyZW5kZXIgaW4gb3JkZXIgdG8gcmVtb3ZlIHRoaXMgY29tcG9uZW50LicpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG5zZXRBdHRlbXB0VXNlckJsb2NraW5nSHlkcmF0aW9uKGF0dGVtcHRVc2VyQmxvY2tpbmdIeWRyYXRpb24kMSk7XG5zZXRBdHRlbXB0Q29udGludW91c0h5ZHJhdGlvbihhdHRlbXB0Q29udGludW91c0h5ZHJhdGlvbiQxKTtcbnNldEF0dGVtcHRIeWRyYXRpb25BdEN1cnJlbnRQcmlvcml0eShhdHRlbXB0SHlkcmF0aW9uQXRDdXJyZW50UHJpb3JpdHkkMSk7XG5zZXRBdHRlbXB0SHlkcmF0aW9uQXRQcmlvcml0eShydW5XaXRoUHJpb3JpdHkkMik7XG52YXIgZGlkV2FybkFib3V0VW5zdGFibGVDcmVhdGVQb3J0YWwgPSBmYWxzZTtcblxue1xuICBpZiAodHlwZW9mIE1hcCAhPT0gJ2Z1bmN0aW9uJyB8fCAvLyAkRmxvd0lzc3VlIEZsb3cgaW5jb3JyZWN0bHkgdGhpbmtzIE1hcCBoYXMgbm8gcHJvdG90eXBlXG4gIE1hcC5wcm90b3R5cGUgPT0gbnVsbCB8fCB0eXBlb2YgTWFwLnByb3RvdHlwZS5mb3JFYWNoICE9PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBTZXQgIT09ICdmdW5jdGlvbicgfHwgLy8gJEZsb3dJc3N1ZSBGbG93IGluY29ycmVjdGx5IHRoaW5rcyBTZXQgaGFzIG5vIHByb3RvdHlwZVxuICBTZXQucHJvdG90eXBlID09IG51bGwgfHwgdHlwZW9mIFNldC5wcm90b3R5cGUuY2xlYXIgIT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIFNldC5wcm90b3R5cGUuZm9yRWFjaCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIGVycm9yKCdSZWFjdCBkZXBlbmRzIG9uIE1hcCBhbmQgU2V0IGJ1aWx0LWluIHR5cGVzLiBNYWtlIHN1cmUgdGhhdCB5b3UgbG9hZCBhICcgKyAncG9seWZpbGwgaW4gb2xkZXIgYnJvd3NlcnMuIGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9yZWFjdC1wb2x5ZmlsbHMnKTtcbiAgfVxufVxuXG5zZXRSZXN0b3JlSW1wbGVtZW50YXRpb24ocmVzdG9yZUNvbnRyb2xsZWRTdGF0ZSQzKTtcbnNldEJhdGNoaW5nSW1wbGVtZW50YXRpb24oYmF0Y2hlZFVwZGF0ZXMkMSwgZGlzY3JldGVVcGRhdGVzJDEsIGZsdXNoRGlzY3JldGVVcGRhdGVzLCBiYXRjaGVkRXZlbnRVcGRhdGVzJDEpO1xuXG5mdW5jdGlvbiBjcmVhdGVQb3J0YWwkMShjaGlsZHJlbiwgY29udGFpbmVyKSB7XG4gIHZhciBrZXkgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IG51bGw7XG5cbiAgaWYgKCFpc1ZhbGlkQ29udGFpbmVyKGNvbnRhaW5lcikpIHtcbiAgICB7XG4gICAgICB0aHJvdyBFcnJvciggXCJUYXJnZXQgY29udGFpbmVyIGlzIG5vdCBhIERPTSBlbGVtZW50LlwiICk7XG4gICAgfVxuICB9IC8vIFRPRE86IHBhc3MgUmVhY3RET00gcG9ydGFsIGltcGxlbWVudGF0aW9uIGFzIHRoaXJkIGFyZ3VtZW50XG4gIC8vICRGbG93Rml4TWUgVGhlIEZsb3cgdHlwZSBpcyBvcGFxdWUgYnV0IHRoZXJlJ3Mgbm8gd2F5IHRvIGFjdHVhbGx5IGNyZWF0ZSBpdC5cblxuXG4gIHJldHVybiBjcmVhdGVQb3J0YWwoY2hpbGRyZW4sIGNvbnRhaW5lciwgbnVsbCwga2V5KTtcbn1cblxuZnVuY3Rpb24gcmVuZGVyU3VidHJlZUludG9Db250YWluZXIocGFyZW50Q29tcG9uZW50LCBlbGVtZW50LCBjb250YWluZXJOb2RlLCBjYWxsYmFjaykge1xuXG4gIHJldHVybiB1bnN0YWJsZV9yZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lcihwYXJlbnRDb21wb25lbnQsIGVsZW1lbnQsIGNvbnRhaW5lck5vZGUsIGNhbGxiYWNrKTtcbn1cblxuZnVuY3Rpb24gdW5zdGFibGVfY3JlYXRlUG9ydGFsKGNoaWxkcmVuLCBjb250YWluZXIpIHtcbiAgdmFyIGtleSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogbnVsbDtcblxuICB7XG4gICAgaWYgKCFkaWRXYXJuQWJvdXRVbnN0YWJsZUNyZWF0ZVBvcnRhbCkge1xuICAgICAgZGlkV2FybkFib3V0VW5zdGFibGVDcmVhdGVQb3J0YWwgPSB0cnVlO1xuXG4gICAgICB3YXJuKCdUaGUgUmVhY3RET00udW5zdGFibGVfY3JlYXRlUG9ydGFsKCkgYWxpYXMgaGFzIGJlZW4gZGVwcmVjYXRlZCwgJyArICdhbmQgd2lsbCBiZSByZW1vdmVkIGluIFJlYWN0IDE4Ky4gVXBkYXRlIHlvdXIgY29kZSB0byB1c2UgJyArICdSZWFjdERPTS5jcmVhdGVQb3J0YWwoKSBpbnN0ZWFkLiBJdCBoYXMgdGhlIGV4YWN0IHNhbWUgQVBJLCAnICsgJ2J1dCB3aXRob3V0IHRoZSBcInVuc3RhYmxlX1wiIHByZWZpeC4nKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gY3JlYXRlUG9ydGFsJDEoY2hpbGRyZW4sIGNvbnRhaW5lciwga2V5KTtcbn1cblxudmFyIEludGVybmFscyA9IHtcbiAgLy8gS2VlcCBpbiBzeW5jIHdpdGggUmVhY3RUZXN0VXRpbHMuanMsIGFuZCBSZWFjdFRlc3RVdGlsc0FjdC5qcy5cbiAgLy8gVGhpcyBpcyBhbiBhcnJheSBmb3IgYmV0dGVyIG1pbmlmaWNhdGlvbi5cbiAgRXZlbnRzOiBbZ2V0SW5zdGFuY2VGcm9tTm9kZSwgZ2V0Tm9kZUZyb21JbnN0YW5jZSwgZ2V0RmliZXJDdXJyZW50UHJvcHNGcm9tTm9kZSwgZW5xdWV1ZVN0YXRlUmVzdG9yZSwgcmVzdG9yZVN0YXRlSWZOZWVkZWQsIGZsdXNoUGFzc2l2ZUVmZmVjdHMsIC8vIFRPRE86IFRoaXMgaXMgcmVsYXRlZCB0byBgYWN0YCwgbm90IGV2ZW50cy4gTW92ZSB0byBzZXBhcmF0ZSBrZXk/XG4gIElzVGhpc1JlbmRlcmVyQWN0aW5nXVxufTtcbnZhciBmb3VuZERldlRvb2xzID0gaW5qZWN0SW50b0RldlRvb2xzKHtcbiAgZmluZEZpYmVyQnlIb3N0SW5zdGFuY2U6IGdldENsb3Nlc3RJbnN0YW5jZUZyb21Ob2RlLFxuICBidW5kbGVUeXBlOiAgMSAsXG4gIHZlcnNpb246IFJlYWN0VmVyc2lvbixcbiAgcmVuZGVyZXJQYWNrYWdlTmFtZTogJ3JlYWN0LWRvbSdcbn0pO1xuXG57XG4gIGlmICghZm91bmREZXZUb29scyAmJiBjYW5Vc2VET00gJiYgd2luZG93LnRvcCA9PT0gd2luZG93LnNlbGYpIHtcbiAgICAvLyBJZiB3ZSdyZSBpbiBDaHJvbWUgb3IgRmlyZWZveCwgcHJvdmlkZSBhIGRvd25sb2FkIGxpbmsgaWYgbm90IGluc3RhbGxlZC5cbiAgICBpZiAobmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCdDaHJvbWUnKSA+IC0xICYmIG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZignRWRnZScpID09PSAtMSB8fCBuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoJ0ZpcmVmb3gnKSA+IC0xKSB7XG4gICAgICB2YXIgcHJvdG9jb2wgPSB3aW5kb3cubG9jYXRpb24ucHJvdG9jb2w7IC8vIERvbid0IHdhcm4gaW4gZXhvdGljIGNhc2VzIGxpa2UgY2hyb21lLWV4dGVuc2lvbjovLy5cblxuICAgICAgaWYgKC9eKGh0dHBzP3xmaWxlKTokLy50ZXN0KHByb3RvY29sKSkge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nXG4gICAgICAgIGNvbnNvbGUuaW5mbygnJWNEb3dubG9hZCB0aGUgUmVhY3QgRGV2VG9vbHMgJyArICdmb3IgYSBiZXR0ZXIgZGV2ZWxvcG1lbnQgZXhwZXJpZW5jZTogJyArICdodHRwczovL3JlYWN0anMub3JnL2xpbmsvcmVhY3QtZGV2dG9vbHMnICsgKHByb3RvY29sID09PSAnZmlsZTonID8gJ1xcbllvdSBtaWdodCBuZWVkIHRvIHVzZSBhIGxvY2FsIEhUVFAgc2VydmVyIChpbnN0ZWFkIG9mIGZpbGU6Ly8pOiAnICsgJ2h0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9yZWFjdC1kZXZ0b29scy1mYXEnIDogJycpLCAnZm9udC13ZWlnaHQ6Ym9sZCcpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5leHBvcnRzLl9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEID0gSW50ZXJuYWxzO1xuZXhwb3J0cy5jcmVhdGVQb3J0YWwgPSBjcmVhdGVQb3J0YWwkMTtcbmV4cG9ydHMuZmluZERPTU5vZGUgPSBmaW5kRE9NTm9kZTtcbmV4cG9ydHMuZmx1c2hTeW5jID0gZmx1c2hTeW5jO1xuZXhwb3J0cy5oeWRyYXRlID0gaHlkcmF0ZTtcbmV4cG9ydHMucmVuZGVyID0gcmVuZGVyO1xuZXhwb3J0cy51bm1vdW50Q29tcG9uZW50QXROb2RlID0gdW5tb3VudENvbXBvbmVudEF0Tm9kZTtcbmV4cG9ydHMudW5zdGFibGVfYmF0Y2hlZFVwZGF0ZXMgPSBiYXRjaGVkVXBkYXRlcyQxO1xuZXhwb3J0cy51bnN0YWJsZV9jcmVhdGVQb3J0YWwgPSB1bnN0YWJsZV9jcmVhdGVQb3J0YWw7XG5leHBvcnRzLnVuc3RhYmxlX3JlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyID0gcmVuZGVyU3VidHJlZUludG9Db250YWluZXI7XG5leHBvcnRzLnZlcnNpb24gPSBSZWFjdFZlcnNpb247XG4gIH0pKCk7XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIGNoZWNrRENFKCkge1xuICAvKiBnbG9iYWwgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fICovXG4gIGlmIChcbiAgICB0eXBlb2YgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fID09PSAndW5kZWZpbmVkJyB8fFxuICAgIHR5cGVvZiBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18uY2hlY2tEQ0UgIT09ICdmdW5jdGlvbidcbiAgKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgLy8gVGhpcyBicmFuY2ggaXMgdW5yZWFjaGFibGUgYmVjYXVzZSB0aGlzIGZ1bmN0aW9uIGlzIG9ubHkgY2FsbGVkXG4gICAgLy8gaW4gcHJvZHVjdGlvbiwgYnV0IHRoZSBjb25kaXRpb24gaXMgdHJ1ZSBvbmx5IGluIGRldmVsb3BtZW50LlxuICAgIC8vIFRoZXJlZm9yZSBpZiB0aGUgYnJhbmNoIGlzIHN0aWxsIGhlcmUsIGRlYWQgY29kZSBlbGltaW5hdGlvbiB3YXNuJ3RcbiAgICAvLyBwcm9wZXJseSBhcHBsaWVkLlxuICAgIC8vIERvbid0IGNoYW5nZSB0aGUgbWVzc2FnZS4gUmVhY3QgRGV2VG9vbHMgcmVsaWVzIG9uIGl0LiBBbHNvIG1ha2Ugc3VyZVxuICAgIC8vIHRoaXMgbWVzc2FnZSBkb2Vzbid0IG9jY3VyIGVsc2V3aGVyZSBpbiB0aGlzIGZ1bmN0aW9uLCBvciBpdCB3aWxsIGNhdXNlXG4gICAgLy8gYSBmYWxzZSBwb3NpdGl2ZS5cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ15fXicpO1xuICB9XG4gIHRyeSB7XG4gICAgLy8gVmVyaWZ5IHRoYXQgdGhlIGNvZGUgYWJvdmUgaGFzIGJlZW4gZGVhZCBjb2RlIGVsaW1pbmF0ZWQgKERDRSdkKS5cbiAgICBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18uY2hlY2tEQ0UoY2hlY2tEQ0UpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICAvLyBEZXZUb29scyBzaG91bGRuJ3QgY3Jhc2ggUmVhY3QsIG5vIG1hdHRlciB3aGF0LlxuICAgIC8vIFdlIHNob3VsZCBzdGlsbCByZXBvcnQgaW4gY2FzZSB3ZSBicmVhayB0aGlzIGNvZGUuXG4gICAgY29uc29sZS5lcnJvcihlcnIpO1xuICB9XG59XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIC8vIERDRSBjaGVjayBzaG91bGQgaGFwcGVuIGJlZm9yZSBSZWFjdERPTSBidW5kbGUgZXhlY3V0ZXMgc28gdGhhdFxuICAvLyBEZXZUb29scyBjYW4gcmVwb3J0IGJhZCBtaW5pZmljYXRpb24gZHVyaW5nIGluamVjdGlvbi5cbiAgY2hlY2tEQ0UoKTtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC1kb20ucHJvZHVjdGlvbi5taW4uanMnKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtZG9tLmRldmVsb3BtZW50LmpzJyk7XG59XG4iLCIvKiogQGxpY2Vuc2UgUmVhY3QgdjE3LjAuMlxuICogcmVhY3QuZGV2ZWxvcG1lbnQuanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgKGZ1bmN0aW9uKCkge1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX2Fzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcblxuLy8gVE9ETzogdGhpcyBpcyBzcGVjaWFsIGJlY2F1c2UgaXQgZ2V0cyBpbXBvcnRlZCBkdXJpbmcgYnVpbGQuXG52YXIgUmVhY3RWZXJzaW9uID0gJzE3LjAuMic7XG5cbi8vIEFUVEVOVElPTlxuLy8gV2hlbiBhZGRpbmcgbmV3IHN5bWJvbHMgdG8gdGhpcyBmaWxlLFxuLy8gUGxlYXNlIGNvbnNpZGVyIGFsc28gYWRkaW5nIHRvICdyZWFjdC1kZXZ0b29scy1zaGFyZWQvc3JjL2JhY2tlbmQvUmVhY3RTeW1ib2xzJ1xuLy8gVGhlIFN5bWJvbCB1c2VkIHRvIHRhZyB0aGUgUmVhY3RFbGVtZW50LWxpa2UgdHlwZXMuIElmIHRoZXJlIGlzIG5vIG5hdGl2ZSBTeW1ib2xcbi8vIG5vciBwb2x5ZmlsbCwgdGhlbiBhIHBsYWluIG51bWJlciBpcyB1c2VkIGZvciBwZXJmb3JtYW5jZS5cbnZhciBSRUFDVF9FTEVNRU5UX1RZUEUgPSAweGVhYzc7XG52YXIgUkVBQ1RfUE9SVEFMX1RZUEUgPSAweGVhY2E7XG5leHBvcnRzLkZyYWdtZW50ID0gMHhlYWNiO1xuZXhwb3J0cy5TdHJpY3RNb2RlID0gMHhlYWNjO1xuZXhwb3J0cy5Qcm9maWxlciA9IDB4ZWFkMjtcbnZhciBSRUFDVF9QUk9WSURFUl9UWVBFID0gMHhlYWNkO1xudmFyIFJFQUNUX0NPTlRFWFRfVFlQRSA9IDB4ZWFjZTtcbnZhciBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFID0gMHhlYWQwO1xuZXhwb3J0cy5TdXNwZW5zZSA9IDB4ZWFkMTtcbnZhciBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUgPSAweGVhZDg7XG52YXIgUkVBQ1RfTUVNT19UWVBFID0gMHhlYWQzO1xudmFyIFJFQUNUX0xBWllfVFlQRSA9IDB4ZWFkNDtcbnZhciBSRUFDVF9CTE9DS19UWVBFID0gMHhlYWQ5O1xudmFyIFJFQUNUX1NFUlZFUl9CTE9DS19UWVBFID0gMHhlYWRhO1xudmFyIFJFQUNUX0ZVTkRBTUVOVEFMX1RZUEUgPSAweGVhZDU7XG52YXIgUkVBQ1RfU0NPUEVfVFlQRSA9IDB4ZWFkNztcbnZhciBSRUFDVF9PUEFRVUVfSURfVFlQRSA9IDB4ZWFlMDtcbnZhciBSRUFDVF9ERUJVR19UUkFDSU5HX01PREVfVFlQRSA9IDB4ZWFlMTtcbnZhciBSRUFDVF9PRkZTQ1JFRU5fVFlQRSA9IDB4ZWFlMjtcbnZhciBSRUFDVF9MRUdBQ1lfSElEREVOX1RZUEUgPSAweGVhZTM7XG5cbmlmICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC5mb3IpIHtcbiAgdmFyIHN5bWJvbEZvciA9IFN5bWJvbC5mb3I7XG4gIFJFQUNUX0VMRU1FTlRfVFlQRSA9IHN5bWJvbEZvcigncmVhY3QuZWxlbWVudCcpO1xuICBSRUFDVF9QT1JUQUxfVFlQRSA9IHN5bWJvbEZvcigncmVhY3QucG9ydGFsJyk7XG4gIGV4cG9ydHMuRnJhZ21lbnQgPSBzeW1ib2xGb3IoJ3JlYWN0LmZyYWdtZW50Jyk7XG4gIGV4cG9ydHMuU3RyaWN0TW9kZSA9IHN5bWJvbEZvcigncmVhY3Quc3RyaWN0X21vZGUnKTtcbiAgZXhwb3J0cy5Qcm9maWxlciA9IHN5bWJvbEZvcigncmVhY3QucHJvZmlsZXInKTtcbiAgUkVBQ1RfUFJPVklERVJfVFlQRSA9IHN5bWJvbEZvcigncmVhY3QucHJvdmlkZXInKTtcbiAgUkVBQ1RfQ09OVEVYVF9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5jb250ZXh0Jyk7XG4gIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LmZvcndhcmRfcmVmJyk7XG4gIGV4cG9ydHMuU3VzcGVuc2UgPSBzeW1ib2xGb3IoJ3JlYWN0LnN1c3BlbnNlJyk7XG4gIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSA9IHN5bWJvbEZvcigncmVhY3Quc3VzcGVuc2VfbGlzdCcpO1xuICBSRUFDVF9NRU1PX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0Lm1lbW8nKTtcbiAgUkVBQ1RfTEFaWV9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5sYXp5Jyk7XG4gIFJFQUNUX0JMT0NLX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LmJsb2NrJyk7XG4gIFJFQUNUX1NFUlZFUl9CTE9DS19UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5zZXJ2ZXIuYmxvY2snKTtcbiAgUkVBQ1RfRlVOREFNRU5UQUxfVFlQRSA9IHN5bWJvbEZvcigncmVhY3QuZnVuZGFtZW50YWwnKTtcbiAgUkVBQ1RfU0NPUEVfVFlQRSA9IHN5bWJvbEZvcigncmVhY3Quc2NvcGUnKTtcbiAgUkVBQ1RfT1BBUVVFX0lEX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0Lm9wYXF1ZS5pZCcpO1xuICBSRUFDVF9ERUJVR19UUkFDSU5HX01PREVfVFlQRSA9IHN5bWJvbEZvcigncmVhY3QuZGVidWdfdHJhY2VfbW9kZScpO1xuICBSRUFDVF9PRkZTQ1JFRU5fVFlQRSA9IHN5bWJvbEZvcigncmVhY3Qub2Zmc2NyZWVuJyk7XG4gIFJFQUNUX0xFR0FDWV9ISURERU5fVFlQRSA9IHN5bWJvbEZvcigncmVhY3QubGVnYWN5X2hpZGRlbicpO1xufVxuXG52YXIgTUFZQkVfSVRFUkFUT1JfU1lNQk9MID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wuaXRlcmF0b3I7XG52YXIgRkFVWF9JVEVSQVRPUl9TWU1CT0wgPSAnQEBpdGVyYXRvcic7XG5mdW5jdGlvbiBnZXRJdGVyYXRvckZuKG1heWJlSXRlcmFibGUpIHtcbiAgaWYgKG1heWJlSXRlcmFibGUgPT09IG51bGwgfHwgdHlwZW9mIG1heWJlSXRlcmFibGUgIT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgbWF5YmVJdGVyYXRvciA9IE1BWUJFX0lURVJBVE9SX1NZTUJPTCAmJiBtYXliZUl0ZXJhYmxlW01BWUJFX0lURVJBVE9SX1NZTUJPTF0gfHwgbWF5YmVJdGVyYWJsZVtGQVVYX0lURVJBVE9SX1NZTUJPTF07XG5cbiAgaWYgKHR5cGVvZiBtYXliZUl0ZXJhdG9yID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIG1heWJlSXRlcmF0b3I7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxuLyoqXG4gKiBLZWVwcyB0cmFjayBvZiB0aGUgY3VycmVudCBkaXNwYXRjaGVyLlxuICovXG52YXIgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciA9IHtcbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKiBAdHlwZSB7UmVhY3RDb21wb25lbnR9XG4gICAqL1xuICBjdXJyZW50OiBudWxsXG59O1xuXG4vKipcbiAqIEtlZXBzIHRyYWNrIG9mIHRoZSBjdXJyZW50IGJhdGNoJ3MgY29uZmlndXJhdGlvbiBzdWNoIGFzIGhvdyBsb25nIGFuIHVwZGF0ZVxuICogc2hvdWxkIHN1c3BlbmQgZm9yIGlmIGl0IG5lZWRzIHRvLlxuICovXG52YXIgUmVhY3RDdXJyZW50QmF0Y2hDb25maWcgPSB7XG4gIHRyYW5zaXRpb246IDBcbn07XG5cbi8qKlxuICogS2VlcHMgdHJhY2sgb2YgdGhlIGN1cnJlbnQgb3duZXIuXG4gKlxuICogVGhlIGN1cnJlbnQgb3duZXIgaXMgdGhlIGNvbXBvbmVudCB3aG8gc2hvdWxkIG93biBhbnkgY29tcG9uZW50cyB0aGF0IGFyZVxuICogY3VycmVudGx5IGJlaW5nIGNvbnN0cnVjdGVkLlxuICovXG52YXIgUmVhY3RDdXJyZW50T3duZXIgPSB7XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICogQHR5cGUge1JlYWN0Q29tcG9uZW50fVxuICAgKi9cbiAgY3VycmVudDogbnVsbFxufTtcblxudmFyIFJlYWN0RGVidWdDdXJyZW50RnJhbWUgPSB7fTtcbnZhciBjdXJyZW50RXh0cmFTdGFja0ZyYW1lID0gbnVsbDtcbmZ1bmN0aW9uIHNldEV4dHJhU3RhY2tGcmFtZShzdGFjaykge1xuICB7XG4gICAgY3VycmVudEV4dHJhU3RhY2tGcmFtZSA9IHN0YWNrO1xuICB9XG59XG5cbntcbiAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5zZXRFeHRyYVN0YWNrRnJhbWUgPSBmdW5jdGlvbiAoc3RhY2spIHtcbiAgICB7XG4gICAgICBjdXJyZW50RXh0cmFTdGFja0ZyYW1lID0gc3RhY2s7XG4gICAgfVxuICB9OyAvLyBTdGFjayBpbXBsZW1lbnRhdGlvbiBpbmplY3RlZCBieSB0aGUgY3VycmVudCByZW5kZXJlci5cblxuXG4gIFJlYWN0RGVidWdDdXJyZW50RnJhbWUuZ2V0Q3VycmVudFN0YWNrID0gbnVsbDtcblxuICBSZWFjdERlYnVnQ3VycmVudEZyYW1lLmdldFN0YWNrQWRkZW5kdW0gPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHN0YWNrID0gJyc7IC8vIEFkZCBhbiBleHRyYSB0b3AgZnJhbWUgd2hpbGUgYW4gZWxlbWVudCBpcyBiZWluZyB2YWxpZGF0ZWRcblxuICAgIGlmIChjdXJyZW50RXh0cmFTdGFja0ZyYW1lKSB7XG4gICAgICBzdGFjayArPSBjdXJyZW50RXh0cmFTdGFja0ZyYW1lO1xuICAgIH0gLy8gRGVsZWdhdGUgdG8gdGhlIGluamVjdGVkIHJlbmRlcmVyLXNwZWNpZmljIGltcGxlbWVudGF0aW9uXG5cblxuICAgIHZhciBpbXBsID0gUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5nZXRDdXJyZW50U3RhY2s7XG5cbiAgICBpZiAoaW1wbCkge1xuICAgICAgc3RhY2sgKz0gaW1wbCgpIHx8ICcnO1xuICAgIH1cblxuICAgIHJldHVybiBzdGFjaztcbiAgfTtcbn1cblxuLyoqXG4gKiBVc2VkIGJ5IGFjdCgpIHRvIHRyYWNrIHdoZXRoZXIgeW91J3JlIGluc2lkZSBhbiBhY3QoKSBzY29wZS5cbiAqL1xudmFyIElzU29tZVJlbmRlcmVyQWN0aW5nID0ge1xuICBjdXJyZW50OiBmYWxzZVxufTtcblxudmFyIFJlYWN0U2hhcmVkSW50ZXJuYWxzID0ge1xuICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyOiBSZWFjdEN1cnJlbnREaXNwYXRjaGVyLFxuICBSZWFjdEN1cnJlbnRCYXRjaENvbmZpZzogUmVhY3RDdXJyZW50QmF0Y2hDb25maWcsXG4gIFJlYWN0Q3VycmVudE93bmVyOiBSZWFjdEN1cnJlbnRPd25lcixcbiAgSXNTb21lUmVuZGVyZXJBY3Rpbmc6IElzU29tZVJlbmRlcmVyQWN0aW5nLFxuICAvLyBVc2VkIGJ5IHJlbmRlcmVycyB0byBhdm9pZCBidW5kbGluZyBvYmplY3QtYXNzaWduIHR3aWNlIGluIFVNRCBidW5kbGVzOlxuICBhc3NpZ246IF9hc3NpZ25cbn07XG5cbntcbiAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSA9IFJlYWN0RGVidWdDdXJyZW50RnJhbWU7XG59XG5cbi8vIGJ5IGNhbGxzIHRvIHRoZXNlIG1ldGhvZHMgYnkgYSBCYWJlbCBwbHVnaW4uXG4vL1xuLy8gSW4gUFJPRCAob3IgaW4gcGFja2FnZXMgd2l0aG91dCBhY2Nlc3MgdG8gUmVhY3QgaW50ZXJuYWxzKSxcbi8vIHRoZXkgYXJlIGxlZnQgYXMgdGhleSBhcmUgaW5zdGVhZC5cblxuZnVuY3Rpb24gd2Fybihmb3JtYXQpIHtcbiAge1xuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIHByaW50V2FybmluZygnd2FybicsIGZvcm1hdCwgYXJncyk7XG4gIH1cbn1cbmZ1bmN0aW9uIGVycm9yKGZvcm1hdCkge1xuICB7XG4gICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4yID4gMSA/IF9sZW4yIC0gMSA6IDApLCBfa2V5MiA9IDE7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgIGFyZ3NbX2tleTIgLSAxXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgfVxuXG4gICAgcHJpbnRXYXJuaW5nKCdlcnJvcicsIGZvcm1hdCwgYXJncyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJpbnRXYXJuaW5nKGxldmVsLCBmb3JtYXQsIGFyZ3MpIHtcbiAgLy8gV2hlbiBjaGFuZ2luZyB0aGlzIGxvZ2ljLCB5b3UgbWlnaHQgd2FudCB0byBhbHNvXG4gIC8vIHVwZGF0ZSBjb25zb2xlV2l0aFN0YWNrRGV2Lnd3dy5qcyBhcyB3ZWxsLlxuICB7XG4gICAgdmFyIFJlYWN0RGVidWdDdXJyZW50RnJhbWUgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdERlYnVnQ3VycmVudEZyYW1lO1xuICAgIHZhciBzdGFjayA9IFJlYWN0RGVidWdDdXJyZW50RnJhbWUuZ2V0U3RhY2tBZGRlbmR1bSgpO1xuXG4gICAgaWYgKHN0YWNrICE9PSAnJykge1xuICAgICAgZm9ybWF0ICs9ICclcyc7XG4gICAgICBhcmdzID0gYXJncy5jb25jYXQoW3N0YWNrXSk7XG4gICAgfVxuXG4gICAgdmFyIGFyZ3NXaXRoRm9ybWF0ID0gYXJncy5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIHJldHVybiAnJyArIGl0ZW07XG4gICAgfSk7IC8vIENhcmVmdWw6IFJOIGN1cnJlbnRseSBkZXBlbmRzIG9uIHRoaXMgcHJlZml4XG5cbiAgICBhcmdzV2l0aEZvcm1hdC51bnNoaWZ0KCdXYXJuaW5nOiAnICsgZm9ybWF0KTsgLy8gV2UgaW50ZW50aW9uYWxseSBkb24ndCB1c2Ugc3ByZWFkIChvciAuYXBwbHkpIGRpcmVjdGx5IGJlY2F1c2UgaXRcbiAgICAvLyBicmVha3MgSUU5OiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzEzNjEwXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZ1xuXG4gICAgRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmNhbGwoY29uc29sZVtsZXZlbF0sIGNvbnNvbGUsIGFyZ3NXaXRoRm9ybWF0KTtcbiAgfVxufVxuXG52YXIgZGlkV2FyblN0YXRlVXBkYXRlRm9yVW5tb3VudGVkQ29tcG9uZW50ID0ge307XG5cbmZ1bmN0aW9uIHdhcm5Ob29wKHB1YmxpY0luc3RhbmNlLCBjYWxsZXJOYW1lKSB7XG4gIHtcbiAgICB2YXIgX2NvbnN0cnVjdG9yID0gcHVibGljSW5zdGFuY2UuY29uc3RydWN0b3I7XG4gICAgdmFyIGNvbXBvbmVudE5hbWUgPSBfY29uc3RydWN0b3IgJiYgKF9jb25zdHJ1Y3Rvci5kaXNwbGF5TmFtZSB8fCBfY29uc3RydWN0b3IubmFtZSkgfHwgJ1JlYWN0Q2xhc3MnO1xuICAgIHZhciB3YXJuaW5nS2V5ID0gY29tcG9uZW50TmFtZSArIFwiLlwiICsgY2FsbGVyTmFtZTtcblxuICAgIGlmIChkaWRXYXJuU3RhdGVVcGRhdGVGb3JVbm1vdW50ZWRDb21wb25lbnRbd2FybmluZ0tleV0pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBlcnJvcihcIkNhbid0IGNhbGwgJXMgb24gYSBjb21wb25lbnQgdGhhdCBpcyBub3QgeWV0IG1vdW50ZWQuIFwiICsgJ1RoaXMgaXMgYSBuby1vcCwgYnV0IGl0IG1pZ2h0IGluZGljYXRlIGEgYnVnIGluIHlvdXIgYXBwbGljYXRpb24uICcgKyAnSW5zdGVhZCwgYXNzaWduIHRvIGB0aGlzLnN0YXRlYCBkaXJlY3RseSBvciBkZWZpbmUgYSBgc3RhdGUgPSB7fTtgICcgKyAnY2xhc3MgcHJvcGVydHkgd2l0aCB0aGUgZGVzaXJlZCBzdGF0ZSBpbiB0aGUgJXMgY29tcG9uZW50LicsIGNhbGxlck5hbWUsIGNvbXBvbmVudE5hbWUpO1xuXG4gICAgZGlkV2FyblN0YXRlVXBkYXRlRm9yVW5tb3VudGVkQ29tcG9uZW50W3dhcm5pbmdLZXldID0gdHJ1ZTtcbiAgfVxufVxuLyoqXG4gKiBUaGlzIGlzIHRoZSBhYnN0cmFjdCBBUEkgZm9yIGFuIHVwZGF0ZSBxdWV1ZS5cbiAqL1xuXG5cbnZhciBSZWFjdE5vb3BVcGRhdGVRdWV1ZSA9IHtcbiAgLyoqXG4gICAqIENoZWNrcyB3aGV0aGVyIG9yIG5vdCB0aGlzIGNvbXBvc2l0ZSBjb21wb25lbnQgaXMgbW91bnRlZC5cbiAgICogQHBhcmFtIHtSZWFjdENsYXNzfSBwdWJsaWNJbnN0YW5jZSBUaGUgaW5zdGFuY2Ugd2Ugd2FudCB0byB0ZXN0LlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIG1vdW50ZWQsIGZhbHNlIG90aGVyd2lzZS5cbiAgICogQHByb3RlY3RlZFxuICAgKiBAZmluYWxcbiAgICovXG4gIGlzTW91bnRlZDogZnVuY3Rpb24gKHB1YmxpY0luc3RhbmNlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBGb3JjZXMgYW4gdXBkYXRlLiBUaGlzIHNob3VsZCBvbmx5IGJlIGludm9rZWQgd2hlbiBpdCBpcyBrbm93biB3aXRoXG4gICAqIGNlcnRhaW50eSB0aGF0IHdlIGFyZSAqKm5vdCoqIGluIGEgRE9NIHRyYW5zYWN0aW9uLlxuICAgKlxuICAgKiBZb3UgbWF5IHdhbnQgdG8gY2FsbCB0aGlzIHdoZW4geW91IGtub3cgdGhhdCBzb21lIGRlZXBlciBhc3BlY3Qgb2YgdGhlXG4gICAqIGNvbXBvbmVudCdzIHN0YXRlIGhhcyBjaGFuZ2VkIGJ1dCBgc2V0U3RhdGVgIHdhcyBub3QgY2FsbGVkLlxuICAgKlxuICAgKiBUaGlzIHdpbGwgbm90IGludm9rZSBgc2hvdWxkQ29tcG9uZW50VXBkYXRlYCwgYnV0IGl0IHdpbGwgaW52b2tlXG4gICAqIGBjb21wb25lbnRXaWxsVXBkYXRlYCBhbmQgYGNvbXBvbmVudERpZFVwZGF0ZWAuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RDbGFzc30gcHVibGljSW5zdGFuY2UgVGhlIGluc3RhbmNlIHRoYXQgc2hvdWxkIHJlcmVuZGVyLlxuICAgKiBAcGFyYW0gez9mdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGVkIGFmdGVyIGNvbXBvbmVudCBpcyB1cGRhdGVkLlxuICAgKiBAcGFyYW0gez9zdHJpbmd9IGNhbGxlck5hbWUgbmFtZSBvZiB0aGUgY2FsbGluZyBmdW5jdGlvbiBpbiB0aGUgcHVibGljIEFQSS5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBlbnF1ZXVlRm9yY2VVcGRhdGU6IGZ1bmN0aW9uIChwdWJsaWNJbnN0YW5jZSwgY2FsbGJhY2ssIGNhbGxlck5hbWUpIHtcbiAgICB3YXJuTm9vcChwdWJsaWNJbnN0YW5jZSwgJ2ZvcmNlVXBkYXRlJyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlcGxhY2VzIGFsbCBvZiB0aGUgc3RhdGUuIEFsd2F5cyB1c2UgdGhpcyBvciBgc2V0U3RhdGVgIHRvIG11dGF0ZSBzdGF0ZS5cbiAgICogWW91IHNob3VsZCB0cmVhdCBgdGhpcy5zdGF0ZWAgYXMgaW1tdXRhYmxlLlxuICAgKlxuICAgKiBUaGVyZSBpcyBubyBndWFyYW50ZWUgdGhhdCBgdGhpcy5zdGF0ZWAgd2lsbCBiZSBpbW1lZGlhdGVseSB1cGRhdGVkLCBzb1xuICAgKiBhY2Nlc3NpbmcgYHRoaXMuc3RhdGVgIGFmdGVyIGNhbGxpbmcgdGhpcyBtZXRob2QgbWF5IHJldHVybiB0aGUgb2xkIHZhbHVlLlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0Q2xhc3N9IHB1YmxpY0luc3RhbmNlIFRoZSBpbnN0YW5jZSB0aGF0IHNob3VsZCByZXJlbmRlci5cbiAgICogQHBhcmFtIHtvYmplY3R9IGNvbXBsZXRlU3RhdGUgTmV4dCBzdGF0ZS5cbiAgICogQHBhcmFtIHs/ZnVuY3Rpb259IGNhbGxiYWNrIENhbGxlZCBhZnRlciBjb21wb25lbnQgaXMgdXBkYXRlZC5cbiAgICogQHBhcmFtIHs/c3RyaW5nfSBjYWxsZXJOYW1lIG5hbWUgb2YgdGhlIGNhbGxpbmcgZnVuY3Rpb24gaW4gdGhlIHB1YmxpYyBBUEkuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZW5xdWV1ZVJlcGxhY2VTdGF0ZTogZnVuY3Rpb24gKHB1YmxpY0luc3RhbmNlLCBjb21wbGV0ZVN0YXRlLCBjYWxsYmFjaywgY2FsbGVyTmFtZSkge1xuICAgIHdhcm5Ob29wKHB1YmxpY0luc3RhbmNlLCAncmVwbGFjZVN0YXRlJyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNldHMgYSBzdWJzZXQgb2YgdGhlIHN0YXRlLiBUaGlzIG9ubHkgZXhpc3RzIGJlY2F1c2UgX3BlbmRpbmdTdGF0ZSBpc1xuICAgKiBpbnRlcm5hbC4gVGhpcyBwcm92aWRlcyBhIG1lcmdpbmcgc3RyYXRlZ3kgdGhhdCBpcyBub3QgYXZhaWxhYmxlIHRvIGRlZXBcbiAgICogcHJvcGVydGllcyB3aGljaCBpcyBjb25mdXNpbmcuIFRPRE86IEV4cG9zZSBwZW5kaW5nU3RhdGUgb3IgZG9uJ3QgdXNlIGl0XG4gICAqIGR1cmluZyB0aGUgbWVyZ2UuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RDbGFzc30gcHVibGljSW5zdGFuY2UgVGhlIGluc3RhbmNlIHRoYXQgc2hvdWxkIHJlcmVuZGVyLlxuICAgKiBAcGFyYW0ge29iamVjdH0gcGFydGlhbFN0YXRlIE5leHQgcGFydGlhbCBzdGF0ZSB0byBiZSBtZXJnZWQgd2l0aCBzdGF0ZS5cbiAgICogQHBhcmFtIHs/ZnVuY3Rpb259IGNhbGxiYWNrIENhbGxlZCBhZnRlciBjb21wb25lbnQgaXMgdXBkYXRlZC5cbiAgICogQHBhcmFtIHs/c3RyaW5nfSBOYW1lIG9mIHRoZSBjYWxsaW5nIGZ1bmN0aW9uIGluIHRoZSBwdWJsaWMgQVBJLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGVucXVldWVTZXRTdGF0ZTogZnVuY3Rpb24gKHB1YmxpY0luc3RhbmNlLCBwYXJ0aWFsU3RhdGUsIGNhbGxiYWNrLCBjYWxsZXJOYW1lKSB7XG4gICAgd2Fybk5vb3AocHVibGljSW5zdGFuY2UsICdzZXRTdGF0ZScpO1xuICB9XG59O1xuXG52YXIgZW1wdHlPYmplY3QgPSB7fTtcblxue1xuICBPYmplY3QuZnJlZXplKGVtcHR5T2JqZWN0KTtcbn1cbi8qKlxuICogQmFzZSBjbGFzcyBoZWxwZXJzIGZvciB0aGUgdXBkYXRpbmcgc3RhdGUgb2YgYSBjb21wb25lbnQuXG4gKi9cblxuXG5mdW5jdGlvbiBDb21wb25lbnQocHJvcHMsIGNvbnRleHQsIHVwZGF0ZXIpIHtcbiAgdGhpcy5wcm9wcyA9IHByb3BzO1xuICB0aGlzLmNvbnRleHQgPSBjb250ZXh0OyAvLyBJZiBhIGNvbXBvbmVudCBoYXMgc3RyaW5nIHJlZnMsIHdlIHdpbGwgYXNzaWduIGEgZGlmZmVyZW50IG9iamVjdCBsYXRlci5cblxuICB0aGlzLnJlZnMgPSBlbXB0eU9iamVjdDsgLy8gV2UgaW5pdGlhbGl6ZSB0aGUgZGVmYXVsdCB1cGRhdGVyIGJ1dCB0aGUgcmVhbCBvbmUgZ2V0cyBpbmplY3RlZCBieSB0aGVcbiAgLy8gcmVuZGVyZXIuXG5cbiAgdGhpcy51cGRhdGVyID0gdXBkYXRlciB8fCBSZWFjdE5vb3BVcGRhdGVRdWV1ZTtcbn1cblxuQ29tcG9uZW50LnByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50ID0ge307XG4vKipcbiAqIFNldHMgYSBzdWJzZXQgb2YgdGhlIHN0YXRlLiBBbHdheXMgdXNlIHRoaXMgdG8gbXV0YXRlXG4gKiBzdGF0ZS4gWW91IHNob3VsZCB0cmVhdCBgdGhpcy5zdGF0ZWAgYXMgaW1tdXRhYmxlLlxuICpcbiAqIFRoZXJlIGlzIG5vIGd1YXJhbnRlZSB0aGF0IGB0aGlzLnN0YXRlYCB3aWxsIGJlIGltbWVkaWF0ZWx5IHVwZGF0ZWQsIHNvXG4gKiBhY2Nlc3NpbmcgYHRoaXMuc3RhdGVgIGFmdGVyIGNhbGxpbmcgdGhpcyBtZXRob2QgbWF5IHJldHVybiB0aGUgb2xkIHZhbHVlLlxuICpcbiAqIFRoZXJlIGlzIG5vIGd1YXJhbnRlZSB0aGF0IGNhbGxzIHRvIGBzZXRTdGF0ZWAgd2lsbCBydW4gc3luY2hyb25vdXNseSxcbiAqIGFzIHRoZXkgbWF5IGV2ZW50dWFsbHkgYmUgYmF0Y2hlZCB0b2dldGhlci4gIFlvdSBjYW4gcHJvdmlkZSBhbiBvcHRpb25hbFxuICogY2FsbGJhY2sgdGhhdCB3aWxsIGJlIGV4ZWN1dGVkIHdoZW4gdGhlIGNhbGwgdG8gc2V0U3RhdGUgaXMgYWN0dWFsbHlcbiAqIGNvbXBsZXRlZC5cbiAqXG4gKiBXaGVuIGEgZnVuY3Rpb24gaXMgcHJvdmlkZWQgdG8gc2V0U3RhdGUsIGl0IHdpbGwgYmUgY2FsbGVkIGF0IHNvbWUgcG9pbnQgaW5cbiAqIHRoZSBmdXR1cmUgKG5vdCBzeW5jaHJvbm91c2x5KS4gSXQgd2lsbCBiZSBjYWxsZWQgd2l0aCB0aGUgdXAgdG8gZGF0ZVxuICogY29tcG9uZW50IGFyZ3VtZW50cyAoc3RhdGUsIHByb3BzLCBjb250ZXh0KS4gVGhlc2UgdmFsdWVzIGNhbiBiZSBkaWZmZXJlbnRcbiAqIGZyb20gdGhpcy4qIGJlY2F1c2UgeW91ciBmdW5jdGlvbiBtYXkgYmUgY2FsbGVkIGFmdGVyIHJlY2VpdmVQcm9wcyBidXQgYmVmb3JlXG4gKiBzaG91bGRDb21wb25lbnRVcGRhdGUsIGFuZCB0aGlzIG5ldyBzdGF0ZSwgcHJvcHMsIGFuZCBjb250ZXh0IHdpbGwgbm90IHlldCBiZVxuICogYXNzaWduZWQgdG8gdGhpcy5cbiAqXG4gKiBAcGFyYW0ge29iamVjdHxmdW5jdGlvbn0gcGFydGlhbFN0YXRlIE5leHQgcGFydGlhbCBzdGF0ZSBvciBmdW5jdGlvbiB0b1xuICogICAgICAgIHByb2R1Y2UgbmV4dCBwYXJ0aWFsIHN0YXRlIHRvIGJlIG1lcmdlZCB3aXRoIGN1cnJlbnQgc3RhdGUuXG4gKiBAcGFyYW0gez9mdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGVkIGFmdGVyIHN0YXRlIGlzIHVwZGF0ZWQuXG4gKiBAZmluYWxcbiAqIEBwcm90ZWN0ZWRcbiAqL1xuXG5Db21wb25lbnQucHJvdG90eXBlLnNldFN0YXRlID0gZnVuY3Rpb24gKHBhcnRpYWxTdGF0ZSwgY2FsbGJhY2spIHtcbiAgaWYgKCEodHlwZW9mIHBhcnRpYWxTdGF0ZSA9PT0gJ29iamVjdCcgfHwgdHlwZW9mIHBhcnRpYWxTdGF0ZSA9PT0gJ2Z1bmN0aW9uJyB8fCBwYXJ0aWFsU3RhdGUgPT0gbnVsbCkpIHtcbiAgICB7XG4gICAgICB0aHJvdyBFcnJvciggXCJzZXRTdGF0ZSguLi4pOiB0YWtlcyBhbiBvYmplY3Qgb2Ygc3RhdGUgdmFyaWFibGVzIHRvIHVwZGF0ZSBvciBhIGZ1bmN0aW9uIHdoaWNoIHJldHVybnMgYW4gb2JqZWN0IG9mIHN0YXRlIHZhcmlhYmxlcy5cIiApO1xuICAgIH1cbiAgfVxuXG4gIHRoaXMudXBkYXRlci5lbnF1ZXVlU2V0U3RhdGUodGhpcywgcGFydGlhbFN0YXRlLCBjYWxsYmFjaywgJ3NldFN0YXRlJyk7XG59O1xuLyoqXG4gKiBGb3JjZXMgYW4gdXBkYXRlLiBUaGlzIHNob3VsZCBvbmx5IGJlIGludm9rZWQgd2hlbiBpdCBpcyBrbm93biB3aXRoXG4gKiBjZXJ0YWludHkgdGhhdCB3ZSBhcmUgKipub3QqKiBpbiBhIERPTSB0cmFuc2FjdGlvbi5cbiAqXG4gKiBZb3UgbWF5IHdhbnQgdG8gY2FsbCB0aGlzIHdoZW4geW91IGtub3cgdGhhdCBzb21lIGRlZXBlciBhc3BlY3Qgb2YgdGhlXG4gKiBjb21wb25lbnQncyBzdGF0ZSBoYXMgY2hhbmdlZCBidXQgYHNldFN0YXRlYCB3YXMgbm90IGNhbGxlZC5cbiAqXG4gKiBUaGlzIHdpbGwgbm90IGludm9rZSBgc2hvdWxkQ29tcG9uZW50VXBkYXRlYCwgYnV0IGl0IHdpbGwgaW52b2tlXG4gKiBgY29tcG9uZW50V2lsbFVwZGF0ZWAgYW5kIGBjb21wb25lbnREaWRVcGRhdGVgLlxuICpcbiAqIEBwYXJhbSB7P2Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsZWQgYWZ0ZXIgdXBkYXRlIGlzIGNvbXBsZXRlLlxuICogQGZpbmFsXG4gKiBAcHJvdGVjdGVkXG4gKi9cblxuXG5Db21wb25lbnQucHJvdG90eXBlLmZvcmNlVXBkYXRlID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gIHRoaXMudXBkYXRlci5lbnF1ZXVlRm9yY2VVcGRhdGUodGhpcywgY2FsbGJhY2ssICdmb3JjZVVwZGF0ZScpO1xufTtcbi8qKlxuICogRGVwcmVjYXRlZCBBUElzLiBUaGVzZSBBUElzIHVzZWQgdG8gZXhpc3Qgb24gY2xhc3NpYyBSZWFjdCBjbGFzc2VzIGJ1dCBzaW5jZVxuICogd2Ugd291bGQgbGlrZSB0byBkZXByZWNhdGUgdGhlbSwgd2UncmUgbm90IGdvaW5nIHRvIG1vdmUgdGhlbSBvdmVyIHRvIHRoaXNcbiAqIG1vZGVybiBiYXNlIGNsYXNzLiBJbnN0ZWFkLCB3ZSBkZWZpbmUgYSBnZXR0ZXIgdGhhdCB3YXJucyBpZiBpdCdzIGFjY2Vzc2VkLlxuICovXG5cblxue1xuICB2YXIgZGVwcmVjYXRlZEFQSXMgPSB7XG4gICAgaXNNb3VudGVkOiBbJ2lzTW91bnRlZCcsICdJbnN0ZWFkLCBtYWtlIHN1cmUgdG8gY2xlYW4gdXAgc3Vic2NyaXB0aW9ucyBhbmQgcGVuZGluZyByZXF1ZXN0cyBpbiAnICsgJ2NvbXBvbmVudFdpbGxVbm1vdW50IHRvIHByZXZlbnQgbWVtb3J5IGxlYWtzLiddLFxuICAgIHJlcGxhY2VTdGF0ZTogWydyZXBsYWNlU3RhdGUnLCAnUmVmYWN0b3IgeW91ciBjb2RlIHRvIHVzZSBzZXRTdGF0ZSBpbnN0ZWFkIChzZWUgJyArICdodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzMyMzYpLiddXG4gIH07XG5cbiAgdmFyIGRlZmluZURlcHJlY2F0aW9uV2FybmluZyA9IGZ1bmN0aW9uIChtZXRob2ROYW1lLCBpbmZvKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbXBvbmVudC5wcm90b3R5cGUsIG1ldGhvZE5hbWUsIHtcbiAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICB3YXJuKCclcyguLi4pIGlzIGRlcHJlY2F0ZWQgaW4gcGxhaW4gSmF2YVNjcmlwdCBSZWFjdCBjbGFzc2VzLiAlcycsIGluZm9bMF0sIGluZm9bMV0pO1xuXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgZm9yICh2YXIgZm5OYW1lIGluIGRlcHJlY2F0ZWRBUElzKSB7XG4gICAgaWYgKGRlcHJlY2F0ZWRBUElzLmhhc093blByb3BlcnR5KGZuTmFtZSkpIHtcbiAgICAgIGRlZmluZURlcHJlY2F0aW9uV2FybmluZyhmbk5hbWUsIGRlcHJlY2F0ZWRBUElzW2ZuTmFtZV0pO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBDb21wb25lbnREdW1teSgpIHt9XG5cbkNvbXBvbmVudER1bW15LnByb3RvdHlwZSA9IENvbXBvbmVudC5wcm90b3R5cGU7XG4vKipcbiAqIENvbnZlbmllbmNlIGNvbXBvbmVudCB3aXRoIGRlZmF1bHQgc2hhbGxvdyBlcXVhbGl0eSBjaGVjayBmb3Igc0NVLlxuICovXG5cbmZ1bmN0aW9uIFB1cmVDb21wb25lbnQocHJvcHMsIGNvbnRleHQsIHVwZGF0ZXIpIHtcbiAgdGhpcy5wcm9wcyA9IHByb3BzO1xuICB0aGlzLmNvbnRleHQgPSBjb250ZXh0OyAvLyBJZiBhIGNvbXBvbmVudCBoYXMgc3RyaW5nIHJlZnMsIHdlIHdpbGwgYXNzaWduIGEgZGlmZmVyZW50IG9iamVjdCBsYXRlci5cblxuICB0aGlzLnJlZnMgPSBlbXB0eU9iamVjdDtcbiAgdGhpcy51cGRhdGVyID0gdXBkYXRlciB8fCBSZWFjdE5vb3BVcGRhdGVRdWV1ZTtcbn1cblxudmFyIHB1cmVDb21wb25lbnRQcm90b3R5cGUgPSBQdXJlQ29tcG9uZW50LnByb3RvdHlwZSA9IG5ldyBDb21wb25lbnREdW1teSgpO1xucHVyZUNvbXBvbmVudFByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFB1cmVDb21wb25lbnQ7IC8vIEF2b2lkIGFuIGV4dHJhIHByb3RvdHlwZSBqdW1wIGZvciB0aGVzZSBtZXRob2RzLlxuXG5fYXNzaWduKHB1cmVDb21wb25lbnRQcm90b3R5cGUsIENvbXBvbmVudC5wcm90b3R5cGUpO1xuXG5wdXJlQ29tcG9uZW50UHJvdG90eXBlLmlzUHVyZVJlYWN0Q29tcG9uZW50ID0gdHJ1ZTtcblxuLy8gYW4gaW1tdXRhYmxlIG9iamVjdCB3aXRoIGEgc2luZ2xlIG11dGFibGUgdmFsdWVcbmZ1bmN0aW9uIGNyZWF0ZVJlZigpIHtcbiAgdmFyIHJlZk9iamVjdCA9IHtcbiAgICBjdXJyZW50OiBudWxsXG4gIH07XG5cbiAge1xuICAgIE9iamVjdC5zZWFsKHJlZk9iamVjdCk7XG4gIH1cblxuICByZXR1cm4gcmVmT2JqZWN0O1xufVxuXG5mdW5jdGlvbiBnZXRXcmFwcGVkTmFtZShvdXRlclR5cGUsIGlubmVyVHlwZSwgd3JhcHBlck5hbWUpIHtcbiAgdmFyIGZ1bmN0aW9uTmFtZSA9IGlubmVyVHlwZS5kaXNwbGF5TmFtZSB8fCBpbm5lclR5cGUubmFtZSB8fCAnJztcbiAgcmV0dXJuIG91dGVyVHlwZS5kaXNwbGF5TmFtZSB8fCAoZnVuY3Rpb25OYW1lICE9PSAnJyA/IHdyYXBwZXJOYW1lICsgXCIoXCIgKyBmdW5jdGlvbk5hbWUgKyBcIilcIiA6IHdyYXBwZXJOYW1lKTtcbn1cblxuZnVuY3Rpb24gZ2V0Q29udGV4dE5hbWUodHlwZSkge1xuICByZXR1cm4gdHlwZS5kaXNwbGF5TmFtZSB8fCAnQ29udGV4dCc7XG59XG5cbmZ1bmN0aW9uIGdldENvbXBvbmVudE5hbWUodHlwZSkge1xuICBpZiAodHlwZSA9PSBudWxsKSB7XG4gICAgLy8gSG9zdCByb290LCB0ZXh0IG5vZGUgb3IganVzdCBpbnZhbGlkIHR5cGUuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB7XG4gICAgaWYgKHR5cGVvZiB0eXBlLnRhZyA9PT0gJ251bWJlcicpIHtcbiAgICAgIGVycm9yKCdSZWNlaXZlZCBhbiB1bmV4cGVjdGVkIG9iamVjdCBpbiBnZXRDb21wb25lbnROYW1lKCkuICcgKyAnVGhpcyBpcyBsaWtlbHkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiB0eXBlLmRpc3BsYXlOYW1lIHx8IHR5cGUubmFtZSB8fCBudWxsO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB0eXBlO1xuICB9XG5cbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBleHBvcnRzLkZyYWdtZW50OlxuICAgICAgcmV0dXJuICdGcmFnbWVudCc7XG5cbiAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgcmV0dXJuICdQb3J0YWwnO1xuXG4gICAgY2FzZSBleHBvcnRzLlByb2ZpbGVyOlxuICAgICAgcmV0dXJuICdQcm9maWxlcic7XG5cbiAgICBjYXNlIGV4cG9ydHMuU3RyaWN0TW9kZTpcbiAgICAgIHJldHVybiAnU3RyaWN0TW9kZSc7XG5cbiAgICBjYXNlIGV4cG9ydHMuU3VzcGVuc2U6XG4gICAgICByZXR1cm4gJ1N1c3BlbnNlJztcblxuICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFOlxuICAgICAgcmV0dXJuICdTdXNwZW5zZUxpc3QnO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0Jykge1xuICAgIHN3aXRjaCAodHlwZS4kJHR5cGVvZikge1xuICAgICAgY2FzZSBSRUFDVF9DT05URVhUX1RZUEU6XG4gICAgICAgIHZhciBjb250ZXh0ID0gdHlwZTtcbiAgICAgICAgcmV0dXJuIGdldENvbnRleHROYW1lKGNvbnRleHQpICsgJy5Db25zdW1lcic7XG5cbiAgICAgIGNhc2UgUkVBQ1RfUFJPVklERVJfVFlQRTpcbiAgICAgICAgdmFyIHByb3ZpZGVyID0gdHlwZTtcbiAgICAgICAgcmV0dXJuIGdldENvbnRleHROYW1lKHByb3ZpZGVyLl9jb250ZXh0KSArICcuUHJvdmlkZXInO1xuXG4gICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XG4gICAgICAgIHJldHVybiBnZXRXcmFwcGVkTmFtZSh0eXBlLCB0eXBlLnJlbmRlciwgJ0ZvcndhcmRSZWYnKTtcblxuICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XG4gICAgICAgIHJldHVybiBnZXRDb21wb25lbnROYW1lKHR5cGUudHlwZSk7XG5cbiAgICAgIGNhc2UgUkVBQ1RfQkxPQ0tfVFlQRTpcbiAgICAgICAgcmV0dXJuIGdldENvbXBvbmVudE5hbWUodHlwZS5fcmVuZGVyKTtcblxuICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgbGF6eUNvbXBvbmVudCA9IHR5cGU7XG4gICAgICAgICAgdmFyIHBheWxvYWQgPSBsYXp5Q29tcG9uZW50Ll9wYXlsb2FkO1xuICAgICAgICAgIHZhciBpbml0ID0gbGF6eUNvbXBvbmVudC5faW5pdDtcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50TmFtZShpbml0KHBheWxvYWQpKTtcbiAgICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBSRVNFUlZFRF9QUk9QUyA9IHtcbiAga2V5OiB0cnVlLFxuICByZWY6IHRydWUsXG4gIF9fc2VsZjogdHJ1ZSxcbiAgX19zb3VyY2U6IHRydWVcbn07XG52YXIgc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd24sIHNwZWNpYWxQcm9wUmVmV2FybmluZ1Nob3duLCBkaWRXYXJuQWJvdXRTdHJpbmdSZWZzO1xuXG57XG4gIGRpZFdhcm5BYm91dFN0cmluZ1JlZnMgPSB7fTtcbn1cblxuZnVuY3Rpb24gaGFzVmFsaWRSZWYoY29uZmlnKSB7XG4gIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsICdyZWYnKSkge1xuICAgICAgdmFyIGdldHRlciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoY29uZmlnLCAncmVmJykuZ2V0O1xuXG4gICAgICBpZiAoZ2V0dGVyICYmIGdldHRlci5pc1JlYWN0V2FybmluZykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGNvbmZpZy5yZWYgIT09IHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gaGFzVmFsaWRLZXkoY29uZmlnKSB7XG4gIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsICdrZXknKSkge1xuICAgICAgdmFyIGdldHRlciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoY29uZmlnLCAna2V5JykuZ2V0O1xuXG4gICAgICBpZiAoZ2V0dGVyICYmIGdldHRlci5pc1JlYWN0V2FybmluZykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGNvbmZpZy5rZXkgIT09IHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gZGVmaW5lS2V5UHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKSB7XG4gIHZhciB3YXJuQWJvdXRBY2Nlc3NpbmdLZXkgPSBmdW5jdGlvbiAoKSB7XG4gICAge1xuICAgICAgaWYgKCFzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93bikge1xuICAgICAgICBzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93biA9IHRydWU7XG5cbiAgICAgICAgZXJyb3IoJyVzOiBga2V5YCBpcyBub3QgYSBwcm9wLiBUcnlpbmcgdG8gYWNjZXNzIGl0IHdpbGwgcmVzdWx0ICcgKyAnaW4gYHVuZGVmaW5lZGAgYmVpbmcgcmV0dXJuZWQuIElmIHlvdSBuZWVkIHRvIGFjY2VzcyB0aGUgc2FtZSAnICsgJ3ZhbHVlIHdpdGhpbiB0aGUgY2hpbGQgY29tcG9uZW50LCB5b3Ugc2hvdWxkIHBhc3MgaXQgYXMgYSBkaWZmZXJlbnQgJyArICdwcm9wLiAoaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3NwZWNpYWwtcHJvcHMpJywgZGlzcGxheU5hbWUpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICB3YXJuQWJvdXRBY2Nlc3NpbmdLZXkuaXNSZWFjdFdhcm5pbmcgPSB0cnVlO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvcHMsICdrZXknLCB7XG4gICAgZ2V0OiB3YXJuQWJvdXRBY2Nlc3NpbmdLZXksXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xufVxuXG5mdW5jdGlvbiBkZWZpbmVSZWZQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpIHtcbiAgdmFyIHdhcm5BYm91dEFjY2Vzc2luZ1JlZiA9IGZ1bmN0aW9uICgpIHtcbiAgICB7XG4gICAgICBpZiAoIXNwZWNpYWxQcm9wUmVmV2FybmluZ1Nob3duKSB7XG4gICAgICAgIHNwZWNpYWxQcm9wUmVmV2FybmluZ1Nob3duID0gdHJ1ZTtcblxuICAgICAgICBlcnJvcignJXM6IGByZWZgIGlzIG5vdCBhIHByb3AuIFRyeWluZyB0byBhY2Nlc3MgaXQgd2lsbCByZXN1bHQgJyArICdpbiBgdW5kZWZpbmVkYCBiZWluZyByZXR1cm5lZC4gSWYgeW91IG5lZWQgdG8gYWNjZXNzIHRoZSBzYW1lICcgKyAndmFsdWUgd2l0aGluIHRoZSBjaGlsZCBjb21wb25lbnQsIHlvdSBzaG91bGQgcGFzcyBpdCBhcyBhIGRpZmZlcmVudCAnICsgJ3Byb3AuIChodHRwczovL3JlYWN0anMub3JnL2xpbmsvc3BlY2lhbC1wcm9wcyknLCBkaXNwbGF5TmFtZSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIHdhcm5BYm91dEFjY2Vzc2luZ1JlZi5pc1JlYWN0V2FybmluZyA9IHRydWU7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm9wcywgJ3JlZicsIHtcbiAgICBnZXQ6IHdhcm5BYm91dEFjY2Vzc2luZ1JlZixcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHdhcm5JZlN0cmluZ1JlZkNhbm5vdEJlQXV0b0NvbnZlcnRlZChjb25maWcpIHtcbiAge1xuICAgIGlmICh0eXBlb2YgY29uZmlnLnJlZiA9PT0gJ3N0cmluZycgJiYgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCAmJiBjb25maWcuX19zZWxmICYmIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQuc3RhdGVOb2RlICE9PSBjb25maWcuX19zZWxmKSB7XG4gICAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWUoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudC50eXBlKTtcblxuICAgICAgaWYgKCFkaWRXYXJuQWJvdXRTdHJpbmdSZWZzW2NvbXBvbmVudE5hbWVdKSB7XG4gICAgICAgIGVycm9yKCdDb21wb25lbnQgXCIlc1wiIGNvbnRhaW5zIHRoZSBzdHJpbmcgcmVmIFwiJXNcIi4gJyArICdTdXBwb3J0IGZvciBzdHJpbmcgcmVmcyB3aWxsIGJlIHJlbW92ZWQgaW4gYSBmdXR1cmUgbWFqb3IgcmVsZWFzZS4gJyArICdUaGlzIGNhc2UgY2Fubm90IGJlIGF1dG9tYXRpY2FsbHkgY29udmVydGVkIHRvIGFuIGFycm93IGZ1bmN0aW9uLiAnICsgJ1dlIGFzayB5b3UgdG8gbWFudWFsbHkgZml4IHRoaXMgY2FzZSBieSB1c2luZyB1c2VSZWYoKSBvciBjcmVhdGVSZWYoKSBpbnN0ZWFkLiAnICsgJ0xlYXJuIG1vcmUgYWJvdXQgdXNpbmcgcmVmcyBzYWZlbHkgaGVyZTogJyArICdodHRwczovL3JlYWN0anMub3JnL2xpbmsvc3RyaWN0LW1vZGUtc3RyaW5nLXJlZicsIGNvbXBvbmVudE5hbWUsIGNvbmZpZy5yZWYpO1xuXG4gICAgICAgIGRpZFdhcm5BYm91dFN0cmluZ1JlZnNbY29tcG9uZW50TmFtZV0gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuLyoqXG4gKiBGYWN0b3J5IG1ldGhvZCB0byBjcmVhdGUgYSBuZXcgUmVhY3QgZWxlbWVudC4gVGhpcyBubyBsb25nZXIgYWRoZXJlcyB0b1xuICogdGhlIGNsYXNzIHBhdHRlcm4sIHNvIGRvIG5vdCB1c2UgbmV3IHRvIGNhbGwgaXQuIEFsc28sIGluc3RhbmNlb2YgY2hlY2tcbiAqIHdpbGwgbm90IHdvcmsuIEluc3RlYWQgdGVzdCAkJHR5cGVvZiBmaWVsZCBhZ2FpbnN0IFN5bWJvbC5mb3IoJ3JlYWN0LmVsZW1lbnQnKSB0byBjaGVja1xuICogaWYgc29tZXRoaW5nIGlzIGEgUmVhY3QgRWxlbWVudC5cbiAqXG4gKiBAcGFyYW0geyp9IHR5cGVcbiAqIEBwYXJhbSB7Kn0gcHJvcHNcbiAqIEBwYXJhbSB7Kn0ga2V5XG4gKiBAcGFyYW0ge3N0cmluZ3xvYmplY3R9IHJlZlxuICogQHBhcmFtIHsqfSBvd25lclxuICogQHBhcmFtIHsqfSBzZWxmIEEgKnRlbXBvcmFyeSogaGVscGVyIHRvIGRldGVjdCBwbGFjZXMgd2hlcmUgYHRoaXNgIGlzXG4gKiBkaWZmZXJlbnQgZnJvbSB0aGUgYG93bmVyYCB3aGVuIFJlYWN0LmNyZWF0ZUVsZW1lbnQgaXMgY2FsbGVkLCBzbyB0aGF0IHdlXG4gKiBjYW4gd2Fybi4gV2Ugd2FudCB0byBnZXQgcmlkIG9mIG93bmVyIGFuZCByZXBsYWNlIHN0cmluZyBgcmVmYHMgd2l0aCBhcnJvd1xuICogZnVuY3Rpb25zLCBhbmQgYXMgbG9uZyBhcyBgdGhpc2AgYW5kIG93bmVyIGFyZSB0aGUgc2FtZSwgdGhlcmUgd2lsbCBiZSBub1xuICogY2hhbmdlIGluIGJlaGF2aW9yLlxuICogQHBhcmFtIHsqfSBzb3VyY2UgQW4gYW5ub3RhdGlvbiBvYmplY3QgKGFkZGVkIGJ5IGEgdHJhbnNwaWxlciBvciBvdGhlcndpc2UpXG4gKiBpbmRpY2F0aW5nIGZpbGVuYW1lLCBsaW5lIG51bWJlciwgYW5kL29yIG90aGVyIGluZm9ybWF0aW9uLlxuICogQGludGVybmFsXG4gKi9cblxuXG52YXIgUmVhY3RFbGVtZW50ID0gZnVuY3Rpb24gKHR5cGUsIGtleSwgcmVmLCBzZWxmLCBzb3VyY2UsIG93bmVyLCBwcm9wcykge1xuICB2YXIgZWxlbWVudCA9IHtcbiAgICAvLyBUaGlzIHRhZyBhbGxvd3MgdXMgdG8gdW5pcXVlbHkgaWRlbnRpZnkgdGhpcyBhcyBhIFJlYWN0IEVsZW1lbnRcbiAgICAkJHR5cGVvZjogUkVBQ1RfRUxFTUVOVF9UWVBFLFxuICAgIC8vIEJ1aWx0LWluIHByb3BlcnRpZXMgdGhhdCBiZWxvbmcgb24gdGhlIGVsZW1lbnRcbiAgICB0eXBlOiB0eXBlLFxuICAgIGtleToga2V5LFxuICAgIHJlZjogcmVmLFxuICAgIHByb3BzOiBwcm9wcyxcbiAgICAvLyBSZWNvcmQgdGhlIGNvbXBvbmVudCByZXNwb25zaWJsZSBmb3IgY3JlYXRpbmcgdGhpcyBlbGVtZW50LlxuICAgIF9vd25lcjogb3duZXJcbiAgfTtcblxuICB7XG4gICAgLy8gVGhlIHZhbGlkYXRpb24gZmxhZyBpcyBjdXJyZW50bHkgbXV0YXRpdmUuIFdlIHB1dCBpdCBvblxuICAgIC8vIGFuIGV4dGVybmFsIGJhY2tpbmcgc3RvcmUgc28gdGhhdCB3ZSBjYW4gZnJlZXplIHRoZSB3aG9sZSBvYmplY3QuXG4gICAgLy8gVGhpcyBjYW4gYmUgcmVwbGFjZWQgd2l0aCBhIFdlYWtNYXAgb25jZSB0aGV5IGFyZSBpbXBsZW1lbnRlZCBpblxuICAgIC8vIGNvbW1vbmx5IHVzZWQgZGV2ZWxvcG1lbnQgZW52aXJvbm1lbnRzLlxuICAgIGVsZW1lbnQuX3N0b3JlID0ge307IC8vIFRvIG1ha2UgY29tcGFyaW5nIFJlYWN0RWxlbWVudHMgZWFzaWVyIGZvciB0ZXN0aW5nIHB1cnBvc2VzLCB3ZSBtYWtlXG4gICAgLy8gdGhlIHZhbGlkYXRpb24gZmxhZyBub24tZW51bWVyYWJsZSAod2hlcmUgcG9zc2libGUsIHdoaWNoIHNob3VsZFxuICAgIC8vIGluY2x1ZGUgZXZlcnkgZW52aXJvbm1lbnQgd2UgcnVuIHRlc3RzIGluKSwgc28gdGhlIHRlc3QgZnJhbWV3b3JrXG4gICAgLy8gaWdub3JlcyBpdC5cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50Ll9zdG9yZSwgJ3ZhbGlkYXRlZCcsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgdmFsdWU6IGZhbHNlXG4gICAgfSk7IC8vIHNlbGYgYW5kIHNvdXJjZSBhcmUgREVWIG9ubHkgcHJvcGVydGllcy5cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50LCAnX3NlbGYnLCB7XG4gICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICB2YWx1ZTogc2VsZlxuICAgIH0pOyAvLyBUd28gZWxlbWVudHMgY3JlYXRlZCBpbiB0d28gZGlmZmVyZW50IHBsYWNlcyBzaG91bGQgYmUgY29uc2lkZXJlZFxuICAgIC8vIGVxdWFsIGZvciB0ZXN0aW5nIHB1cnBvc2VzIGFuZCB0aGVyZWZvcmUgd2UgaGlkZSBpdCBmcm9tIGVudW1lcmF0aW9uLlxuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVsZW1lbnQsICdfc291cmNlJywge1xuICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgdmFsdWU6IHNvdXJjZVxuICAgIH0pO1xuXG4gICAgaWYgKE9iamVjdC5mcmVlemUpIHtcbiAgICAgIE9iamVjdC5mcmVlemUoZWxlbWVudC5wcm9wcyk7XG4gICAgICBPYmplY3QuZnJlZXplKGVsZW1lbnQpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBlbGVtZW50O1xufTtcbi8qKlxuICogQ3JlYXRlIGFuZCByZXR1cm4gYSBuZXcgUmVhY3RFbGVtZW50IG9mIHRoZSBnaXZlbiB0eXBlLlxuICogU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1hcGkuaHRtbCNjcmVhdGVlbGVtZW50XG4gKi9cblxuZnVuY3Rpb24gY3JlYXRlRWxlbWVudCh0eXBlLCBjb25maWcsIGNoaWxkcmVuKSB7XG4gIHZhciBwcm9wTmFtZTsgLy8gUmVzZXJ2ZWQgbmFtZXMgYXJlIGV4dHJhY3RlZFxuXG4gIHZhciBwcm9wcyA9IHt9O1xuICB2YXIga2V5ID0gbnVsbDtcbiAgdmFyIHJlZiA9IG51bGw7XG4gIHZhciBzZWxmID0gbnVsbDtcbiAgdmFyIHNvdXJjZSA9IG51bGw7XG5cbiAgaWYgKGNvbmZpZyAhPSBudWxsKSB7XG4gICAgaWYgKGhhc1ZhbGlkUmVmKGNvbmZpZykpIHtcbiAgICAgIHJlZiA9IGNvbmZpZy5yZWY7XG5cbiAgICAgIHtcbiAgICAgICAgd2FybklmU3RyaW5nUmVmQ2Fubm90QmVBdXRvQ29udmVydGVkKGNvbmZpZyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGhhc1ZhbGlkS2V5KGNvbmZpZykpIHtcbiAgICAgIGtleSA9ICcnICsgY29uZmlnLmtleTtcbiAgICB9XG5cbiAgICBzZWxmID0gY29uZmlnLl9fc2VsZiA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGNvbmZpZy5fX3NlbGY7XG4gICAgc291cmNlID0gY29uZmlnLl9fc291cmNlID09PSB1bmRlZmluZWQgPyBudWxsIDogY29uZmlnLl9fc291cmNlOyAvLyBSZW1haW5pbmcgcHJvcGVydGllcyBhcmUgYWRkZWQgdG8gYSBuZXcgcHJvcHMgb2JqZWN0XG5cbiAgICBmb3IgKHByb3BOYW1lIGluIGNvbmZpZykge1xuICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCBwcm9wTmFtZSkgJiYgIVJFU0VSVkVEX1BST1BTLmhhc093blByb3BlcnR5KHByb3BOYW1lKSkge1xuICAgICAgICBwcm9wc1twcm9wTmFtZV0gPSBjb25maWdbcHJvcE5hbWVdO1xuICAgICAgfVxuICAgIH1cbiAgfSAvLyBDaGlsZHJlbiBjYW4gYmUgbW9yZSB0aGFuIG9uZSBhcmd1bWVudCwgYW5kIHRob3NlIGFyZSB0cmFuc2ZlcnJlZCBvbnRvXG4gIC8vIHRoZSBuZXdseSBhbGxvY2F0ZWQgcHJvcHMgb2JqZWN0LlxuXG5cbiAgdmFyIGNoaWxkcmVuTGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aCAtIDI7XG5cbiAgaWYgKGNoaWxkcmVuTGVuZ3RoID09PSAxKSB7XG4gICAgcHJvcHMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgfSBlbHNlIGlmIChjaGlsZHJlbkxlbmd0aCA+IDEpIHtcbiAgICB2YXIgY2hpbGRBcnJheSA9IEFycmF5KGNoaWxkcmVuTGVuZ3RoKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW5MZW5ndGg7IGkrKykge1xuICAgICAgY2hpbGRBcnJheVtpXSA9IGFyZ3VtZW50c1tpICsgMl07XG4gICAgfVxuXG4gICAge1xuICAgICAgaWYgKE9iamVjdC5mcmVlemUpIHtcbiAgICAgICAgT2JqZWN0LmZyZWV6ZShjaGlsZEFycmF5KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBwcm9wcy5jaGlsZHJlbiA9IGNoaWxkQXJyYXk7XG4gIH0gLy8gUmVzb2x2ZSBkZWZhdWx0IHByb3BzXG5cblxuICBpZiAodHlwZSAmJiB0eXBlLmRlZmF1bHRQcm9wcykge1xuICAgIHZhciBkZWZhdWx0UHJvcHMgPSB0eXBlLmRlZmF1bHRQcm9wcztcblxuICAgIGZvciAocHJvcE5hbWUgaW4gZGVmYXVsdFByb3BzKSB7XG4gICAgICBpZiAocHJvcHNbcHJvcE5hbWVdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcHJvcHNbcHJvcE5hbWVdID0gZGVmYXVsdFByb3BzW3Byb3BOYW1lXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB7XG4gICAgaWYgKGtleSB8fCByZWYpIHtcbiAgICAgIHZhciBkaXNwbGF5TmFtZSA9IHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nID8gdHlwZS5kaXNwbGF5TmFtZSB8fCB0eXBlLm5hbWUgfHwgJ1Vua25vd24nIDogdHlwZTtcblxuICAgICAgaWYgKGtleSkge1xuICAgICAgICBkZWZpbmVLZXlQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpO1xuICAgICAgfVxuXG4gICAgICBpZiAocmVmKSB7XG4gICAgICAgIGRlZmluZVJlZlByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIFJlYWN0RWxlbWVudCh0eXBlLCBrZXksIHJlZiwgc2VsZiwgc291cmNlLCBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LCBwcm9wcyk7XG59XG5mdW5jdGlvbiBjbG9uZUFuZFJlcGxhY2VLZXkob2xkRWxlbWVudCwgbmV3S2V5KSB7XG4gIHZhciBuZXdFbGVtZW50ID0gUmVhY3RFbGVtZW50KG9sZEVsZW1lbnQudHlwZSwgbmV3S2V5LCBvbGRFbGVtZW50LnJlZiwgb2xkRWxlbWVudC5fc2VsZiwgb2xkRWxlbWVudC5fc291cmNlLCBvbGRFbGVtZW50Ll9vd25lciwgb2xkRWxlbWVudC5wcm9wcyk7XG4gIHJldHVybiBuZXdFbGVtZW50O1xufVxuLyoqXG4gKiBDbG9uZSBhbmQgcmV0dXJuIGEgbmV3IFJlYWN0RWxlbWVudCB1c2luZyBlbGVtZW50IGFzIHRoZSBzdGFydGluZyBwb2ludC5cbiAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtYXBpLmh0bWwjY2xvbmVlbGVtZW50XG4gKi9cblxuZnVuY3Rpb24gY2xvbmVFbGVtZW50KGVsZW1lbnQsIGNvbmZpZywgY2hpbGRyZW4pIHtcbiAgaWYgKCEhKGVsZW1lbnQgPT09IG51bGwgfHwgZWxlbWVudCA9PT0gdW5kZWZpbmVkKSkge1xuICAgIHtcbiAgICAgIHRocm93IEVycm9yKCBcIlJlYWN0LmNsb25lRWxlbWVudCguLi4pOiBUaGUgYXJndW1lbnQgbXVzdCBiZSBhIFJlYWN0IGVsZW1lbnQsIGJ1dCB5b3UgcGFzc2VkIFwiICsgZWxlbWVudCArIFwiLlwiICk7XG4gICAgfVxuICB9XG5cbiAgdmFyIHByb3BOYW1lOyAvLyBPcmlnaW5hbCBwcm9wcyBhcmUgY29waWVkXG5cbiAgdmFyIHByb3BzID0gX2Fzc2lnbih7fSwgZWxlbWVudC5wcm9wcyk7IC8vIFJlc2VydmVkIG5hbWVzIGFyZSBleHRyYWN0ZWRcblxuXG4gIHZhciBrZXkgPSBlbGVtZW50LmtleTtcbiAgdmFyIHJlZiA9IGVsZW1lbnQucmVmOyAvLyBTZWxmIGlzIHByZXNlcnZlZCBzaW5jZSB0aGUgb3duZXIgaXMgcHJlc2VydmVkLlxuXG4gIHZhciBzZWxmID0gZWxlbWVudC5fc2VsZjsgLy8gU291cmNlIGlzIHByZXNlcnZlZCBzaW5jZSBjbG9uZUVsZW1lbnQgaXMgdW5saWtlbHkgdG8gYmUgdGFyZ2V0ZWQgYnkgYVxuICAvLyB0cmFuc3BpbGVyLCBhbmQgdGhlIG9yaWdpbmFsIHNvdXJjZSBpcyBwcm9iYWJseSBhIGJldHRlciBpbmRpY2F0b3Igb2YgdGhlXG4gIC8vIHRydWUgb3duZXIuXG5cbiAgdmFyIHNvdXJjZSA9IGVsZW1lbnQuX3NvdXJjZTsgLy8gT3duZXIgd2lsbCBiZSBwcmVzZXJ2ZWQsIHVubGVzcyByZWYgaXMgb3ZlcnJpZGRlblxuXG4gIHZhciBvd25lciA9IGVsZW1lbnQuX293bmVyO1xuXG4gIGlmIChjb25maWcgIT0gbnVsbCkge1xuICAgIGlmIChoYXNWYWxpZFJlZihjb25maWcpKSB7XG4gICAgICAvLyBTaWxlbnRseSBzdGVhbCB0aGUgcmVmIGZyb20gdGhlIHBhcmVudC5cbiAgICAgIHJlZiA9IGNvbmZpZy5yZWY7XG4gICAgICBvd25lciA9IFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQ7XG4gICAgfVxuXG4gICAgaWYgKGhhc1ZhbGlkS2V5KGNvbmZpZykpIHtcbiAgICAgIGtleSA9ICcnICsgY29uZmlnLmtleTtcbiAgICB9IC8vIFJlbWFpbmluZyBwcm9wZXJ0aWVzIG92ZXJyaWRlIGV4aXN0aW5nIHByb3BzXG5cblxuICAgIHZhciBkZWZhdWx0UHJvcHM7XG5cbiAgICBpZiAoZWxlbWVudC50eXBlICYmIGVsZW1lbnQudHlwZS5kZWZhdWx0UHJvcHMpIHtcbiAgICAgIGRlZmF1bHRQcm9wcyA9IGVsZW1lbnQudHlwZS5kZWZhdWx0UHJvcHM7XG4gICAgfVxuXG4gICAgZm9yIChwcm9wTmFtZSBpbiBjb25maWcpIHtcbiAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgcHJvcE5hbWUpICYmICFSRVNFUlZFRF9QUk9QUy5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkpIHtcbiAgICAgICAgaWYgKGNvbmZpZ1twcm9wTmFtZV0gPT09IHVuZGVmaW5lZCAmJiBkZWZhdWx0UHJvcHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIC8vIFJlc29sdmUgZGVmYXVsdCBwcm9wc1xuICAgICAgICAgIHByb3BzW3Byb3BOYW1lXSA9IGRlZmF1bHRQcm9wc1twcm9wTmFtZV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcHJvcHNbcHJvcE5hbWVdID0gY29uZmlnW3Byb3BOYW1lXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSAvLyBDaGlsZHJlbiBjYW4gYmUgbW9yZSB0aGFuIG9uZSBhcmd1bWVudCwgYW5kIHRob3NlIGFyZSB0cmFuc2ZlcnJlZCBvbnRvXG4gIC8vIHRoZSBuZXdseSBhbGxvY2F0ZWQgcHJvcHMgb2JqZWN0LlxuXG5cbiAgdmFyIGNoaWxkcmVuTGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aCAtIDI7XG5cbiAgaWYgKGNoaWxkcmVuTGVuZ3RoID09PSAxKSB7XG4gICAgcHJvcHMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgfSBlbHNlIGlmIChjaGlsZHJlbkxlbmd0aCA+IDEpIHtcbiAgICB2YXIgY2hpbGRBcnJheSA9IEFycmF5KGNoaWxkcmVuTGVuZ3RoKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW5MZW5ndGg7IGkrKykge1xuICAgICAgY2hpbGRBcnJheVtpXSA9IGFyZ3VtZW50c1tpICsgMl07XG4gICAgfVxuXG4gICAgcHJvcHMuY2hpbGRyZW4gPSBjaGlsZEFycmF5O1xuICB9XG5cbiAgcmV0dXJuIFJlYWN0RWxlbWVudChlbGVtZW50LnR5cGUsIGtleSwgcmVmLCBzZWxmLCBzb3VyY2UsIG93bmVyLCBwcm9wcyk7XG59XG4vKipcbiAqIFZlcmlmaWVzIHRoZSBvYmplY3QgaXMgYSBSZWFjdEVsZW1lbnQuXG4gKiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3JlYWN0LWFwaS5odG1sI2lzdmFsaWRlbGVtZW50XG4gKiBAcGFyYW0gez9vYmplY3R9IG9iamVjdFxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBgb2JqZWN0YCBpcyBhIFJlYWN0RWxlbWVudC5cbiAqIEBmaW5hbFxuICovXG5cbmZ1bmN0aW9uIGlzVmFsaWRFbGVtZW50KG9iamVjdCkge1xuICByZXR1cm4gdHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCcgJiYgb2JqZWN0ICE9PSBudWxsICYmIG9iamVjdC4kJHR5cGVvZiA9PT0gUkVBQ1RfRUxFTUVOVF9UWVBFO1xufVxuXG52YXIgU0VQQVJBVE9SID0gJy4nO1xudmFyIFNVQlNFUEFSQVRPUiA9ICc6Jztcbi8qKlxuICogRXNjYXBlIGFuZCB3cmFwIGtleSBzbyBpdCBpcyBzYWZlIHRvIHVzZSBhcyBhIHJlYWN0aWRcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IHRvIGJlIGVzY2FwZWQuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IHRoZSBlc2NhcGVkIGtleS5cbiAqL1xuXG5mdW5jdGlvbiBlc2NhcGUoa2V5KSB7XG4gIHZhciBlc2NhcGVSZWdleCA9IC9bPTpdL2c7XG4gIHZhciBlc2NhcGVyTG9va3VwID0ge1xuICAgICc9JzogJz0wJyxcbiAgICAnOic6ICc9MidcbiAgfTtcbiAgdmFyIGVzY2FwZWRTdHJpbmcgPSBrZXkucmVwbGFjZShlc2NhcGVSZWdleCwgZnVuY3Rpb24gKG1hdGNoKSB7XG4gICAgcmV0dXJuIGVzY2FwZXJMb29rdXBbbWF0Y2hdO1xuICB9KTtcbiAgcmV0dXJuICckJyArIGVzY2FwZWRTdHJpbmc7XG59XG4vKipcbiAqIFRPRE86IFRlc3QgdGhhdCBhIHNpbmdsZSBjaGlsZCBhbmQgYW4gYXJyYXkgd2l0aCBvbmUgaXRlbSBoYXZlIHRoZSBzYW1lIGtleVxuICogcGF0dGVybi5cbiAqL1xuXG5cbnZhciBkaWRXYXJuQWJvdXRNYXBzID0gZmFsc2U7XG52YXIgdXNlclByb3ZpZGVkS2V5RXNjYXBlUmVnZXggPSAvXFwvKy9nO1xuXG5mdW5jdGlvbiBlc2NhcGVVc2VyUHJvdmlkZWRLZXkodGV4dCkge1xuICByZXR1cm4gdGV4dC5yZXBsYWNlKHVzZXJQcm92aWRlZEtleUVzY2FwZVJlZ2V4LCAnJCYvJyk7XG59XG4vKipcbiAqIEdlbmVyYXRlIGEga2V5IHN0cmluZyB0aGF0IGlkZW50aWZpZXMgYSBlbGVtZW50IHdpdGhpbiBhIHNldC5cbiAqXG4gKiBAcGFyYW0geyp9IGVsZW1lbnQgQSBlbGVtZW50IHRoYXQgY291bGQgY29udGFpbiBhIG1hbnVhbCBrZXkuXG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXggSW5kZXggdGhhdCBpcyB1c2VkIGlmIGEgbWFudWFsIGtleSBpcyBub3QgcHJvdmlkZWQuXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cblxuXG5mdW5jdGlvbiBnZXRFbGVtZW50S2V5KGVsZW1lbnQsIGluZGV4KSB7XG4gIC8vIERvIHNvbWUgdHlwZWNoZWNraW5nIGhlcmUgc2luY2Ugd2UgY2FsbCB0aGlzIGJsaW5kbHkuIFdlIHdhbnQgdG8gZW5zdXJlXG4gIC8vIHRoYXQgd2UgZG9uJ3QgYmxvY2sgcG90ZW50aWFsIGZ1dHVyZSBFUyBBUElzLlxuICBpZiAodHlwZW9mIGVsZW1lbnQgPT09ICdvYmplY3QnICYmIGVsZW1lbnQgIT09IG51bGwgJiYgZWxlbWVudC5rZXkgIT0gbnVsbCkge1xuICAgIC8vIEV4cGxpY2l0IGtleVxuICAgIHJldHVybiBlc2NhcGUoJycgKyBlbGVtZW50LmtleSk7XG4gIH0gLy8gSW1wbGljaXQga2V5IGRldGVybWluZWQgYnkgdGhlIGluZGV4IGluIHRoZSBzZXRcblxuXG4gIHJldHVybiBpbmRleC50b1N0cmluZygzNik7XG59XG5cbmZ1bmN0aW9uIG1hcEludG9BcnJheShjaGlsZHJlbiwgYXJyYXksIGVzY2FwZWRQcmVmaXgsIG5hbWVTb0ZhciwgY2FsbGJhY2spIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgY2hpbGRyZW47XG5cbiAgaWYgKHR5cGUgPT09ICd1bmRlZmluZWQnIHx8IHR5cGUgPT09ICdib29sZWFuJykge1xuICAgIC8vIEFsbCBvZiB0aGUgYWJvdmUgYXJlIHBlcmNlaXZlZCBhcyBudWxsLlxuICAgIGNoaWxkcmVuID0gbnVsbDtcbiAgfVxuXG4gIHZhciBpbnZva2VDYWxsYmFjayA9IGZhbHNlO1xuXG4gIGlmIChjaGlsZHJlbiA9PT0gbnVsbCkge1xuICAgIGludm9rZUNhbGxiYWNrID0gdHJ1ZTtcbiAgfSBlbHNlIHtcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICBpbnZva2VDYWxsYmFjayA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICBzd2l0Y2ggKGNoaWxkcmVuLiQkdHlwZW9mKSB7XG4gICAgICAgICAgY2FzZSBSRUFDVF9FTEVNRU5UX1RZUEU6XG4gICAgICAgICAgY2FzZSBSRUFDVF9QT1JUQUxfVFlQRTpcbiAgICAgICAgICAgIGludm9rZUNhbGxiYWNrID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgfVxuICB9XG5cbiAgaWYgKGludm9rZUNhbGxiYWNrKSB7XG4gICAgdmFyIF9jaGlsZCA9IGNoaWxkcmVuO1xuICAgIHZhciBtYXBwZWRDaGlsZCA9IGNhbGxiYWNrKF9jaGlsZCk7IC8vIElmIGl0J3MgdGhlIG9ubHkgY2hpbGQsIHRyZWF0IHRoZSBuYW1lIGFzIGlmIGl0IHdhcyB3cmFwcGVkIGluIGFuIGFycmF5XG4gICAgLy8gc28gdGhhdCBpdCdzIGNvbnNpc3RlbnQgaWYgdGhlIG51bWJlciBvZiBjaGlsZHJlbiBncm93czpcblxuICAgIHZhciBjaGlsZEtleSA9IG5hbWVTb0ZhciA9PT0gJycgPyBTRVBBUkFUT1IgKyBnZXRFbGVtZW50S2V5KF9jaGlsZCwgMCkgOiBuYW1lU29GYXI7XG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShtYXBwZWRDaGlsZCkpIHtcbiAgICAgIHZhciBlc2NhcGVkQ2hpbGRLZXkgPSAnJztcblxuICAgICAgaWYgKGNoaWxkS2V5ICE9IG51bGwpIHtcbiAgICAgICAgZXNjYXBlZENoaWxkS2V5ID0gZXNjYXBlVXNlclByb3ZpZGVkS2V5KGNoaWxkS2V5KSArICcvJztcbiAgICAgIH1cblxuICAgICAgbWFwSW50b0FycmF5KG1hcHBlZENoaWxkLCBhcnJheSwgZXNjYXBlZENoaWxkS2V5LCAnJywgZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgcmV0dXJuIGM7XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKG1hcHBlZENoaWxkICE9IG51bGwpIHtcbiAgICAgIGlmIChpc1ZhbGlkRWxlbWVudChtYXBwZWRDaGlsZCkpIHtcbiAgICAgICAgbWFwcGVkQ2hpbGQgPSBjbG9uZUFuZFJlcGxhY2VLZXkobWFwcGVkQ2hpbGQsIC8vIEtlZXAgYm90aCB0aGUgKG1hcHBlZCkgYW5kIG9sZCBrZXlzIGlmIHRoZXkgZGlmZmVyLCBqdXN0IGFzXG4gICAgICAgIC8vIHRyYXZlcnNlQWxsQ2hpbGRyZW4gdXNlZCB0byBkbyBmb3Igb2JqZWN0cyBhcyBjaGlsZHJlblxuICAgICAgICBlc2NhcGVkUHJlZml4ICsgKCAvLyAkRmxvd0ZpeE1lIEZsb3cgaW5jb3JyZWN0bHkgdGhpbmtzIFJlYWN0LlBvcnRhbCBkb2Vzbid0IGhhdmUgYSBrZXlcbiAgICAgICAgbWFwcGVkQ2hpbGQua2V5ICYmICghX2NoaWxkIHx8IF9jaGlsZC5rZXkgIT09IG1hcHBlZENoaWxkLmtleSkgPyAvLyAkRmxvd0ZpeE1lIEZsb3cgaW5jb3JyZWN0bHkgdGhpbmtzIGV4aXN0aW5nIGVsZW1lbnQncyBrZXkgY2FuIGJlIGEgbnVtYmVyXG4gICAgICAgIGVzY2FwZVVzZXJQcm92aWRlZEtleSgnJyArIG1hcHBlZENoaWxkLmtleSkgKyAnLycgOiAnJykgKyBjaGlsZEtleSk7XG4gICAgICB9XG5cbiAgICAgIGFycmF5LnB1c2gobWFwcGVkQ2hpbGQpO1xuICAgIH1cblxuICAgIHJldHVybiAxO1xuICB9XG5cbiAgdmFyIGNoaWxkO1xuICB2YXIgbmV4dE5hbWU7XG4gIHZhciBzdWJ0cmVlQ291bnQgPSAwOyAvLyBDb3VudCBvZiBjaGlsZHJlbiBmb3VuZCBpbiB0aGUgY3VycmVudCBzdWJ0cmVlLlxuXG4gIHZhciBuZXh0TmFtZVByZWZpeCA9IG5hbWVTb0ZhciA9PT0gJycgPyBTRVBBUkFUT1IgOiBuYW1lU29GYXIgKyBTVUJTRVBBUkFUT1I7XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgY2hpbGQgPSBjaGlsZHJlbltpXTtcbiAgICAgIG5leHROYW1lID0gbmV4dE5hbWVQcmVmaXggKyBnZXRFbGVtZW50S2V5KGNoaWxkLCBpKTtcbiAgICAgIHN1YnRyZWVDb3VudCArPSBtYXBJbnRvQXJyYXkoY2hpbGQsIGFycmF5LCBlc2NhcGVkUHJlZml4LCBuZXh0TmFtZSwgY2FsbGJhY2spO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4oY2hpbGRyZW4pO1xuXG4gICAgaWYgKHR5cGVvZiBpdGVyYXRvckZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB2YXIgaXRlcmFibGVDaGlsZHJlbiA9IGNoaWxkcmVuO1xuXG4gICAgICB7XG4gICAgICAgIC8vIFdhcm4gYWJvdXQgdXNpbmcgTWFwcyBhcyBjaGlsZHJlblxuICAgICAgICBpZiAoaXRlcmF0b3JGbiA9PT0gaXRlcmFibGVDaGlsZHJlbi5lbnRyaWVzKSB7XG4gICAgICAgICAgaWYgKCFkaWRXYXJuQWJvdXRNYXBzKSB7XG4gICAgICAgICAgICB3YXJuKCdVc2luZyBNYXBzIGFzIGNoaWxkcmVuIGlzIG5vdCBzdXBwb3J0ZWQuICcgKyAnVXNlIGFuIGFycmF5IG9mIGtleWVkIFJlYWN0RWxlbWVudHMgaW5zdGVhZC4nKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBkaWRXYXJuQWJvdXRNYXBzID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgaXRlcmF0b3IgPSBpdGVyYXRvckZuLmNhbGwoaXRlcmFibGVDaGlsZHJlbik7XG4gICAgICB2YXIgc3RlcDtcbiAgICAgIHZhciBpaSA9IDA7XG5cbiAgICAgIHdoaWxlICghKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgICAgY2hpbGQgPSBzdGVwLnZhbHVlO1xuICAgICAgICBuZXh0TmFtZSA9IG5leHROYW1lUHJlZml4ICsgZ2V0RWxlbWVudEtleShjaGlsZCwgaWkrKyk7XG4gICAgICAgIHN1YnRyZWVDb3VudCArPSBtYXBJbnRvQXJyYXkoY2hpbGQsIGFycmF5LCBlc2NhcGVkUHJlZml4LCBuZXh0TmFtZSwgY2FsbGJhY2spO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHZhciBjaGlsZHJlblN0cmluZyA9ICcnICsgY2hpbGRyZW47XG5cbiAgICAgIHtcbiAgICAgICAge1xuICAgICAgICAgIHRocm93IEVycm9yKCBcIk9iamVjdHMgYXJlIG5vdCB2YWxpZCBhcyBhIFJlYWN0IGNoaWxkIChmb3VuZDogXCIgKyAoY2hpbGRyZW5TdHJpbmcgPT09ICdbb2JqZWN0IE9iamVjdF0nID8gJ29iamVjdCB3aXRoIGtleXMgeycgKyBPYmplY3Qua2V5cyhjaGlsZHJlbikuam9pbignLCAnKSArICd9JyA6IGNoaWxkcmVuU3RyaW5nKSArIFwiKS4gSWYgeW91IG1lYW50IHRvIHJlbmRlciBhIGNvbGxlY3Rpb24gb2YgY2hpbGRyZW4sIHVzZSBhbiBhcnJheSBpbnN0ZWFkLlwiICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gc3VidHJlZUNvdW50O1xufVxuXG4vKipcbiAqIE1hcHMgY2hpbGRyZW4gdGhhdCBhcmUgdHlwaWNhbGx5IHNwZWNpZmllZCBhcyBgcHJvcHMuY2hpbGRyZW5gLlxuICpcbiAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtYXBpLmh0bWwjcmVhY3RjaGlsZHJlbm1hcFxuICpcbiAqIFRoZSBwcm92aWRlZCBtYXBGdW5jdGlvbihjaGlsZCwgaW5kZXgpIHdpbGwgYmUgY2FsbGVkIGZvciBlYWNoXG4gKiBsZWFmIGNoaWxkLlxuICpcbiAqIEBwYXJhbSB7Pyp9IGNoaWxkcmVuIENoaWxkcmVuIHRyZWUgY29udGFpbmVyLlxuICogQHBhcmFtIHtmdW5jdGlvbigqLCBpbnQpfSBmdW5jIFRoZSBtYXAgZnVuY3Rpb24uXG4gKiBAcGFyYW0geyp9IGNvbnRleHQgQ29udGV4dCBmb3IgbWFwRnVuY3Rpb24uXG4gKiBAcmV0dXJuIHtvYmplY3R9IE9iamVjdCBjb250YWluaW5nIHRoZSBvcmRlcmVkIG1hcCBvZiByZXN1bHRzLlxuICovXG5mdW5jdGlvbiBtYXBDaGlsZHJlbihjaGlsZHJlbiwgZnVuYywgY29udGV4dCkge1xuICBpZiAoY2hpbGRyZW4gPT0gbnVsbCkge1xuICAgIHJldHVybiBjaGlsZHJlbjtcbiAgfVxuXG4gIHZhciByZXN1bHQgPSBbXTtcbiAgdmFyIGNvdW50ID0gMDtcbiAgbWFwSW50b0FycmF5KGNoaWxkcmVuLCByZXN1bHQsICcnLCAnJywgZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgcmV0dXJuIGZ1bmMuY2FsbChjb250ZXh0LCBjaGlsZCwgY291bnQrKyk7XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuLyoqXG4gKiBDb3VudCB0aGUgbnVtYmVyIG9mIGNoaWxkcmVuIHRoYXQgYXJlIHR5cGljYWxseSBzcGVjaWZpZWQgYXNcbiAqIGBwcm9wcy5jaGlsZHJlbmAuXG4gKlxuICogU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1hcGkuaHRtbCNyZWFjdGNoaWxkcmVuY291bnRcbiAqXG4gKiBAcGFyYW0gez8qfSBjaGlsZHJlbiBDaGlsZHJlbiB0cmVlIGNvbnRhaW5lci5cbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIG51bWJlciBvZiBjaGlsZHJlbi5cbiAqL1xuXG5cbmZ1bmN0aW9uIGNvdW50Q2hpbGRyZW4oY2hpbGRyZW4pIHtcbiAgdmFyIG4gPSAwO1xuICBtYXBDaGlsZHJlbihjaGlsZHJlbiwgZnVuY3Rpb24gKCkge1xuICAgIG4rKzsgLy8gRG9uJ3QgcmV0dXJuIGFueXRoaW5nXG4gIH0pO1xuICByZXR1cm4gbjtcbn1cblxuLyoqXG4gKiBJdGVyYXRlcyB0aHJvdWdoIGNoaWxkcmVuIHRoYXQgYXJlIHR5cGljYWxseSBzcGVjaWZpZWQgYXMgYHByb3BzLmNoaWxkcmVuYC5cbiAqXG4gKiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3JlYWN0LWFwaS5odG1sI3JlYWN0Y2hpbGRyZW5mb3JlYWNoXG4gKlxuICogVGhlIHByb3ZpZGVkIGZvckVhY2hGdW5jKGNoaWxkLCBpbmRleCkgd2lsbCBiZSBjYWxsZWQgZm9yIGVhY2hcbiAqIGxlYWYgY2hpbGQuXG4gKlxuICogQHBhcmFtIHs/Kn0gY2hpbGRyZW4gQ2hpbGRyZW4gdHJlZSBjb250YWluZXIuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKCosIGludCl9IGZvckVhY2hGdW5jXG4gKiBAcGFyYW0geyp9IGZvckVhY2hDb250ZXh0IENvbnRleHQgZm9yIGZvckVhY2hDb250ZXh0LlxuICovXG5mdW5jdGlvbiBmb3JFYWNoQ2hpbGRyZW4oY2hpbGRyZW4sIGZvckVhY2hGdW5jLCBmb3JFYWNoQ29udGV4dCkge1xuICBtYXBDaGlsZHJlbihjaGlsZHJlbiwgZnVuY3Rpb24gKCkge1xuICAgIGZvckVhY2hGdW5jLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IC8vIERvbid0IHJldHVybiBhbnl0aGluZy5cbiAgfSwgZm9yRWFjaENvbnRleHQpO1xufVxuLyoqXG4gKiBGbGF0dGVuIGEgY2hpbGRyZW4gb2JqZWN0ICh0eXBpY2FsbHkgc3BlY2lmaWVkIGFzIGBwcm9wcy5jaGlsZHJlbmApIGFuZFxuICogcmV0dXJuIGFuIGFycmF5IHdpdGggYXBwcm9wcmlhdGVseSByZS1rZXllZCBjaGlsZHJlbi5cbiAqXG4gKiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3JlYWN0LWFwaS5odG1sI3JlYWN0Y2hpbGRyZW50b2FycmF5XG4gKi9cblxuXG5mdW5jdGlvbiB0b0FycmF5KGNoaWxkcmVuKSB7XG4gIHJldHVybiBtYXBDaGlsZHJlbihjaGlsZHJlbiwgZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgcmV0dXJuIGNoaWxkO1xuICB9KSB8fCBbXTtcbn1cbi8qKlxuICogUmV0dXJucyB0aGUgZmlyc3QgY2hpbGQgaW4gYSBjb2xsZWN0aW9uIG9mIGNoaWxkcmVuIGFuZCB2ZXJpZmllcyB0aGF0IHRoZXJlXG4gKiBpcyBvbmx5IG9uZSBjaGlsZCBpbiB0aGUgY29sbGVjdGlvbi5cbiAqXG4gKiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3JlYWN0LWFwaS5odG1sI3JlYWN0Y2hpbGRyZW5vbmx5XG4gKlxuICogVGhlIGN1cnJlbnQgaW1wbGVtZW50YXRpb24gb2YgdGhpcyBmdW5jdGlvbiBhc3N1bWVzIHRoYXQgYSBzaW5nbGUgY2hpbGQgZ2V0c1xuICogcGFzc2VkIHdpdGhvdXQgYSB3cmFwcGVyLCBidXQgdGhlIHB1cnBvc2Ugb2YgdGhpcyBoZWxwZXIgZnVuY3Rpb24gaXMgdG9cbiAqIGFic3RyYWN0IGF3YXkgdGhlIHBhcnRpY3VsYXIgc3RydWN0dXJlIG9mIGNoaWxkcmVuLlxuICpcbiAqIEBwYXJhbSB7P29iamVjdH0gY2hpbGRyZW4gQ2hpbGQgY29sbGVjdGlvbiBzdHJ1Y3R1cmUuXG4gKiBAcmV0dXJuIHtSZWFjdEVsZW1lbnR9IFRoZSBmaXJzdCBhbmQgb25seSBgUmVhY3RFbGVtZW50YCBjb250YWluZWQgaW4gdGhlXG4gKiBzdHJ1Y3R1cmUuXG4gKi9cblxuXG5mdW5jdGlvbiBvbmx5Q2hpbGQoY2hpbGRyZW4pIHtcbiAgaWYgKCFpc1ZhbGlkRWxlbWVudChjaGlsZHJlbikpIHtcbiAgICB7XG4gICAgICB0aHJvdyBFcnJvciggXCJSZWFjdC5DaGlsZHJlbi5vbmx5IGV4cGVjdGVkIHRvIHJlY2VpdmUgYSBzaW5nbGUgUmVhY3QgZWxlbWVudCBjaGlsZC5cIiApO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjaGlsZHJlbjtcbn1cblxuZnVuY3Rpb24gY3JlYXRlQ29udGV4dChkZWZhdWx0VmFsdWUsIGNhbGN1bGF0ZUNoYW5nZWRCaXRzKSB7XG4gIGlmIChjYWxjdWxhdGVDaGFuZ2VkQml0cyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgY2FsY3VsYXRlQ2hhbmdlZEJpdHMgPSBudWxsO1xuICB9IGVsc2Uge1xuICAgIHtcbiAgICAgIGlmIChjYWxjdWxhdGVDaGFuZ2VkQml0cyAhPT0gbnVsbCAmJiB0eXBlb2YgY2FsY3VsYXRlQ2hhbmdlZEJpdHMgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgZXJyb3IoJ2NyZWF0ZUNvbnRleHQ6IEV4cGVjdGVkIHRoZSBvcHRpb25hbCBzZWNvbmQgYXJndW1lbnQgdG8gYmUgYSAnICsgJ2Z1bmN0aW9uLiBJbnN0ZWFkIHJlY2VpdmVkOiAlcycsIGNhbGN1bGF0ZUNoYW5nZWRCaXRzKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2YXIgY29udGV4dCA9IHtcbiAgICAkJHR5cGVvZjogUkVBQ1RfQ09OVEVYVF9UWVBFLFxuICAgIF9jYWxjdWxhdGVDaGFuZ2VkQml0czogY2FsY3VsYXRlQ2hhbmdlZEJpdHMsXG4gICAgLy8gQXMgYSB3b3JrYXJvdW5kIHRvIHN1cHBvcnQgbXVsdGlwbGUgY29uY3VycmVudCByZW5kZXJlcnMsIHdlIGNhdGVnb3JpemVcbiAgICAvLyBzb21lIHJlbmRlcmVycyBhcyBwcmltYXJ5IGFuZCBvdGhlcnMgYXMgc2Vjb25kYXJ5LiBXZSBvbmx5IGV4cGVjdFxuICAgIC8vIHRoZXJlIHRvIGJlIHR3byBjb25jdXJyZW50IHJlbmRlcmVycyBhdCBtb3N0OiBSZWFjdCBOYXRpdmUgKHByaW1hcnkpIGFuZFxuICAgIC8vIEZhYnJpYyAoc2Vjb25kYXJ5KTsgUmVhY3QgRE9NIChwcmltYXJ5KSBhbmQgUmVhY3QgQVJUIChzZWNvbmRhcnkpLlxuICAgIC8vIFNlY29uZGFyeSByZW5kZXJlcnMgc3RvcmUgdGhlaXIgY29udGV4dCB2YWx1ZXMgb24gc2VwYXJhdGUgZmllbGRzLlxuICAgIF9jdXJyZW50VmFsdWU6IGRlZmF1bHRWYWx1ZSxcbiAgICBfY3VycmVudFZhbHVlMjogZGVmYXVsdFZhbHVlLFxuICAgIC8vIFVzZWQgdG8gdHJhY2sgaG93IG1hbnkgY29uY3VycmVudCByZW5kZXJlcnMgdGhpcyBjb250ZXh0IGN1cnJlbnRseVxuICAgIC8vIHN1cHBvcnRzIHdpdGhpbiBpbiBhIHNpbmdsZSByZW5kZXJlci4gU3VjaCBhcyBwYXJhbGxlbCBzZXJ2ZXIgcmVuZGVyaW5nLlxuICAgIF90aHJlYWRDb3VudDogMCxcbiAgICAvLyBUaGVzZSBhcmUgY2lyY3VsYXJcbiAgICBQcm92aWRlcjogbnVsbCxcbiAgICBDb25zdW1lcjogbnVsbFxuICB9O1xuICBjb250ZXh0LlByb3ZpZGVyID0ge1xuICAgICQkdHlwZW9mOiBSRUFDVF9QUk9WSURFUl9UWVBFLFxuICAgIF9jb250ZXh0OiBjb250ZXh0XG4gIH07XG4gIHZhciBoYXNXYXJuZWRBYm91dFVzaW5nTmVzdGVkQ29udGV4dENvbnN1bWVycyA9IGZhbHNlO1xuICB2YXIgaGFzV2FybmVkQWJvdXRVc2luZ0NvbnN1bWVyUHJvdmlkZXIgPSBmYWxzZTtcbiAgdmFyIGhhc1dhcm5lZEFib3V0RGlzcGxheU5hbWVPbkNvbnN1bWVyID0gZmFsc2U7XG5cbiAge1xuICAgIC8vIEEgc2VwYXJhdGUgb2JqZWN0LCBidXQgcHJveGllcyBiYWNrIHRvIHRoZSBvcmlnaW5hbCBjb250ZXh0IG9iamVjdCBmb3JcbiAgICAvLyBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eS4gSXQgaGFzIGEgZGlmZmVyZW50ICQkdHlwZW9mLCBzbyB3ZSBjYW4gcHJvcGVybHlcbiAgICAvLyB3YXJuIGZvciB0aGUgaW5jb3JyZWN0IHVzYWdlIG9mIENvbnRleHQgYXMgYSBDb25zdW1lci5cbiAgICB2YXIgQ29uc3VtZXIgPSB7XG4gICAgICAkJHR5cGVvZjogUkVBQ1RfQ09OVEVYVF9UWVBFLFxuICAgICAgX2NvbnRleHQ6IGNvbnRleHQsXG4gICAgICBfY2FsY3VsYXRlQ2hhbmdlZEJpdHM6IGNvbnRleHQuX2NhbGN1bGF0ZUNoYW5nZWRCaXRzXG4gICAgfTsgLy8gJEZsb3dGaXhNZTogRmxvdyBjb21wbGFpbnMgYWJvdXQgbm90IHNldHRpbmcgYSB2YWx1ZSwgd2hpY2ggaXMgaW50ZW50aW9uYWwgaGVyZVxuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoQ29uc3VtZXIsIHtcbiAgICAgIFByb3ZpZGVyOiB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmICghaGFzV2FybmVkQWJvdXRVc2luZ0NvbnN1bWVyUHJvdmlkZXIpIHtcbiAgICAgICAgICAgIGhhc1dhcm5lZEFib3V0VXNpbmdDb25zdW1lclByb3ZpZGVyID0gdHJ1ZTtcblxuICAgICAgICAgICAgZXJyb3IoJ1JlbmRlcmluZyA8Q29udGV4dC5Db25zdW1lci5Qcm92aWRlcj4gaXMgbm90IHN1cHBvcnRlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluICcgKyAnYSBmdXR1cmUgbWFqb3IgcmVsZWFzZS4gRGlkIHlvdSBtZWFuIHRvIHJlbmRlciA8Q29udGV4dC5Qcm92aWRlcj4gaW5zdGVhZD8nKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gY29udGV4dC5Qcm92aWRlcjtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAoX1Byb3ZpZGVyKSB7XG4gICAgICAgICAgY29udGV4dC5Qcm92aWRlciA9IF9Qcm92aWRlcjtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIF9jdXJyZW50VmFsdWU6IHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIGNvbnRleHQuX2N1cnJlbnRWYWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAoX2N1cnJlbnRWYWx1ZSkge1xuICAgICAgICAgIGNvbnRleHQuX2N1cnJlbnRWYWx1ZSA9IF9jdXJyZW50VmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBfY3VycmVudFZhbHVlMjoge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gY29udGV4dC5fY3VycmVudFZhbHVlMjtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAoX2N1cnJlbnRWYWx1ZTIpIHtcbiAgICAgICAgICBjb250ZXh0Ll9jdXJyZW50VmFsdWUyID0gX2N1cnJlbnRWYWx1ZTI7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBfdGhyZWFkQ291bnQ6IHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIGNvbnRleHQuX3RocmVhZENvdW50O1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIChfdGhyZWFkQ291bnQpIHtcbiAgICAgICAgICBjb250ZXh0Ll90aHJlYWRDb3VudCA9IF90aHJlYWRDb3VudDtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIENvbnN1bWVyOiB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmICghaGFzV2FybmVkQWJvdXRVc2luZ05lc3RlZENvbnRleHRDb25zdW1lcnMpIHtcbiAgICAgICAgICAgIGhhc1dhcm5lZEFib3V0VXNpbmdOZXN0ZWRDb250ZXh0Q29uc3VtZXJzID0gdHJ1ZTtcblxuICAgICAgICAgICAgZXJyb3IoJ1JlbmRlcmluZyA8Q29udGV4dC5Db25zdW1lci5Db25zdW1lcj4gaXMgbm90IHN1cHBvcnRlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluICcgKyAnYSBmdXR1cmUgbWFqb3IgcmVsZWFzZS4gRGlkIHlvdSBtZWFuIHRvIHJlbmRlciA8Q29udGV4dC5Db25zdW1lcj4gaW5zdGVhZD8nKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gY29udGV4dC5Db25zdW1lcjtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGRpc3BsYXlOYW1lOiB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBjb250ZXh0LmRpc3BsYXlOYW1lO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIChkaXNwbGF5TmFtZSkge1xuICAgICAgICAgIGlmICghaGFzV2FybmVkQWJvdXREaXNwbGF5TmFtZU9uQ29uc3VtZXIpIHtcbiAgICAgICAgICAgIHdhcm4oJ1NldHRpbmcgYGRpc3BsYXlOYW1lYCBvbiBDb250ZXh0LkNvbnN1bWVyIGhhcyBubyBlZmZlY3QuICcgKyBcIllvdSBzaG91bGQgc2V0IGl0IGRpcmVjdGx5IG9uIHRoZSBjb250ZXh0IHdpdGggQ29udGV4dC5kaXNwbGF5TmFtZSA9ICclcycuXCIsIGRpc3BsYXlOYW1lKTtcblxuICAgICAgICAgICAgaGFzV2FybmVkQWJvdXREaXNwbGF5TmFtZU9uQ29uc3VtZXIgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pOyAvLyAkRmxvd0ZpeE1lOiBGbG93IGNvbXBsYWlucyBhYm91dCBtaXNzaW5nIHByb3BlcnRpZXMgYmVjYXVzZSBpdCBkb2Vzbid0IHVuZGVyc3RhbmQgZGVmaW5lUHJvcGVydHlcblxuICAgIGNvbnRleHQuQ29uc3VtZXIgPSBDb25zdW1lcjtcbiAgfVxuXG4gIHtcbiAgICBjb250ZXh0Ll9jdXJyZW50UmVuZGVyZXIgPSBudWxsO1xuICAgIGNvbnRleHQuX2N1cnJlbnRSZW5kZXJlcjIgPSBudWxsO1xuICB9XG5cbiAgcmV0dXJuIGNvbnRleHQ7XG59XG5cbnZhciBVbmluaXRpYWxpemVkID0gLTE7XG52YXIgUGVuZGluZyA9IDA7XG52YXIgUmVzb2x2ZWQgPSAxO1xudmFyIFJlamVjdGVkID0gMjtcblxuZnVuY3Rpb24gbGF6eUluaXRpYWxpemVyKHBheWxvYWQpIHtcbiAgaWYgKHBheWxvYWQuX3N0YXR1cyA9PT0gVW5pbml0aWFsaXplZCkge1xuICAgIHZhciBjdG9yID0gcGF5bG9hZC5fcmVzdWx0O1xuICAgIHZhciB0aGVuYWJsZSA9IGN0b3IoKTsgLy8gVHJhbnNpdGlvbiB0byB0aGUgbmV4dCBzdGF0ZS5cblxuICAgIHZhciBwZW5kaW5nID0gcGF5bG9hZDtcbiAgICBwZW5kaW5nLl9zdGF0dXMgPSBQZW5kaW5nO1xuICAgIHBlbmRpbmcuX3Jlc3VsdCA9IHRoZW5hYmxlO1xuICAgIHRoZW5hYmxlLnRoZW4oZnVuY3Rpb24gKG1vZHVsZU9iamVjdCkge1xuICAgICAgaWYgKHBheWxvYWQuX3N0YXR1cyA9PT0gUGVuZGluZykge1xuICAgICAgICB2YXIgZGVmYXVsdEV4cG9ydCA9IG1vZHVsZU9iamVjdC5kZWZhdWx0O1xuXG4gICAgICAgIHtcbiAgICAgICAgICBpZiAoZGVmYXVsdEV4cG9ydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBlcnJvcignbGF6eTogRXhwZWN0ZWQgdGhlIHJlc3VsdCBvZiBhIGR5bmFtaWMgaW1wb3J0KCkgY2FsbC4gJyArICdJbnN0ZWFkIHJlY2VpdmVkOiAlc1xcblxcbllvdXIgY29kZSBzaG91bGQgbG9vayBsaWtlOiBcXG4gICcgKyAvLyBCcmVhayB1cCBpbXBvcnRzIHRvIGF2b2lkIGFjY2lkZW50YWxseSBwYXJzaW5nIHRoZW0gYXMgZGVwZW5kZW5jaWVzLlxuICAgICAgICAgICAgJ2NvbnN0IE15Q29tcG9uZW50ID0gbGF6eSgoKSA9PiBpbXAnICsgXCJvcnQoJy4vTXlDb21wb25lbnQnKSlcIiwgbW9kdWxlT2JqZWN0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gLy8gVHJhbnNpdGlvbiB0byB0aGUgbmV4dCBzdGF0ZS5cblxuXG4gICAgICAgIHZhciByZXNvbHZlZCA9IHBheWxvYWQ7XG4gICAgICAgIHJlc29sdmVkLl9zdGF0dXMgPSBSZXNvbHZlZDtcbiAgICAgICAgcmVzb2x2ZWQuX3Jlc3VsdCA9IGRlZmF1bHRFeHBvcnQ7XG4gICAgICB9XG4gICAgfSwgZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICBpZiAocGF5bG9hZC5fc3RhdHVzID09PSBQZW5kaW5nKSB7XG4gICAgICAgIC8vIFRyYW5zaXRpb24gdG8gdGhlIG5leHQgc3RhdGUuXG4gICAgICAgIHZhciByZWplY3RlZCA9IHBheWxvYWQ7XG4gICAgICAgIHJlamVjdGVkLl9zdGF0dXMgPSBSZWplY3RlZDtcbiAgICAgICAgcmVqZWN0ZWQuX3Jlc3VsdCA9IGVycm9yO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgaWYgKHBheWxvYWQuX3N0YXR1cyA9PT0gUmVzb2x2ZWQpIHtcbiAgICByZXR1cm4gcGF5bG9hZC5fcmVzdWx0O1xuICB9IGVsc2Uge1xuICAgIHRocm93IHBheWxvYWQuX3Jlc3VsdDtcbiAgfVxufVxuXG5mdW5jdGlvbiBsYXp5KGN0b3IpIHtcbiAgdmFyIHBheWxvYWQgPSB7XG4gICAgLy8gV2UgdXNlIHRoZXNlIGZpZWxkcyB0byBzdG9yZSB0aGUgcmVzdWx0LlxuICAgIF9zdGF0dXM6IC0xLFxuICAgIF9yZXN1bHQ6IGN0b3JcbiAgfTtcbiAgdmFyIGxhenlUeXBlID0ge1xuICAgICQkdHlwZW9mOiBSRUFDVF9MQVpZX1RZUEUsXG4gICAgX3BheWxvYWQ6IHBheWxvYWQsXG4gICAgX2luaXQ6IGxhenlJbml0aWFsaXplclxuICB9O1xuXG4gIHtcbiAgICAvLyBJbiBwcm9kdWN0aW9uLCB0aGlzIHdvdWxkIGp1c3Qgc2V0IGl0IG9uIHRoZSBvYmplY3QuXG4gICAgdmFyIGRlZmF1bHRQcm9wcztcbiAgICB2YXIgcHJvcFR5cGVzOyAvLyAkRmxvd0ZpeE1lXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhsYXp5VHlwZSwge1xuICAgICAgZGVmYXVsdFByb3BzOiB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIGRlZmF1bHRQcm9wcztcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAobmV3RGVmYXVsdFByb3BzKSB7XG4gICAgICAgICAgZXJyb3IoJ1JlYWN0LmxhenkoLi4uKTogSXQgaXMgbm90IHN1cHBvcnRlZCB0byBhc3NpZ24gYGRlZmF1bHRQcm9wc2AgdG8gJyArICdhIGxhenkgY29tcG9uZW50IGltcG9ydC4gRWl0aGVyIHNwZWNpZnkgdGhlbSB3aGVyZSB0aGUgY29tcG9uZW50ICcgKyAnaXMgZGVmaW5lZCwgb3IgY3JlYXRlIGEgd3JhcHBpbmcgY29tcG9uZW50IGFyb3VuZCBpdC4nKTtcblxuICAgICAgICAgIGRlZmF1bHRQcm9wcyA9IG5ld0RlZmF1bHRQcm9wczsgLy8gTWF0Y2ggcHJvZHVjdGlvbiBiZWhhdmlvciBtb3JlIGNsb3NlbHk6XG4gICAgICAgICAgLy8gJEZsb3dGaXhNZVxuXG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGxhenlUeXBlLCAnZGVmYXVsdFByb3BzJywge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgcHJvcFR5cGVzOiB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIHByb3BUeXBlcztcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAobmV3UHJvcFR5cGVzKSB7XG4gICAgICAgICAgZXJyb3IoJ1JlYWN0LmxhenkoLi4uKTogSXQgaXMgbm90IHN1cHBvcnRlZCB0byBhc3NpZ24gYHByb3BUeXBlc2AgdG8gJyArICdhIGxhenkgY29tcG9uZW50IGltcG9ydC4gRWl0aGVyIHNwZWNpZnkgdGhlbSB3aGVyZSB0aGUgY29tcG9uZW50ICcgKyAnaXMgZGVmaW5lZCwgb3IgY3JlYXRlIGEgd3JhcHBpbmcgY29tcG9uZW50IGFyb3VuZCBpdC4nKTtcblxuICAgICAgICAgIHByb3BUeXBlcyA9IG5ld1Byb3BUeXBlczsgLy8gTWF0Y2ggcHJvZHVjdGlvbiBiZWhhdmlvciBtb3JlIGNsb3NlbHk6XG4gICAgICAgICAgLy8gJEZsb3dGaXhNZVxuXG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGxhenlUeXBlLCAncHJvcFR5cGVzJywge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gbGF6eVR5cGU7XG59XG5cbmZ1bmN0aW9uIGZvcndhcmRSZWYocmVuZGVyKSB7XG4gIHtcbiAgICBpZiAocmVuZGVyICE9IG51bGwgJiYgcmVuZGVyLiQkdHlwZW9mID09PSBSRUFDVF9NRU1PX1RZUEUpIHtcbiAgICAgIGVycm9yKCdmb3J3YXJkUmVmIHJlcXVpcmVzIGEgcmVuZGVyIGZ1bmN0aW9uIGJ1dCByZWNlaXZlZCBhIGBtZW1vYCAnICsgJ2NvbXBvbmVudC4gSW5zdGVhZCBvZiBmb3J3YXJkUmVmKG1lbW8oLi4uKSksIHVzZSAnICsgJ21lbW8oZm9yd2FyZFJlZiguLi4pKS4nKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiByZW5kZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGVycm9yKCdmb3J3YXJkUmVmIHJlcXVpcmVzIGEgcmVuZGVyIGZ1bmN0aW9uIGJ1dCB3YXMgZ2l2ZW4gJXMuJywgcmVuZGVyID09PSBudWxsID8gJ251bGwnIDogdHlwZW9mIHJlbmRlcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChyZW5kZXIubGVuZ3RoICE9PSAwICYmIHJlbmRlci5sZW5ndGggIT09IDIpIHtcbiAgICAgICAgZXJyb3IoJ2ZvcndhcmRSZWYgcmVuZGVyIGZ1bmN0aW9ucyBhY2NlcHQgZXhhY3RseSB0d28gcGFyYW1ldGVyczogcHJvcHMgYW5kIHJlZi4gJXMnLCByZW5kZXIubGVuZ3RoID09PSAxID8gJ0RpZCB5b3UgZm9yZ2V0IHRvIHVzZSB0aGUgcmVmIHBhcmFtZXRlcj8nIDogJ0FueSBhZGRpdGlvbmFsIHBhcmFtZXRlciB3aWxsIGJlIHVuZGVmaW5lZC4nKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocmVuZGVyICE9IG51bGwpIHtcbiAgICAgIGlmIChyZW5kZXIuZGVmYXVsdFByb3BzICE9IG51bGwgfHwgcmVuZGVyLnByb3BUeXBlcyAhPSBudWxsKSB7XG4gICAgICAgIGVycm9yKCdmb3J3YXJkUmVmIHJlbmRlciBmdW5jdGlvbnMgZG8gbm90IHN1cHBvcnQgcHJvcFR5cGVzIG9yIGRlZmF1bHRQcm9wcy4gJyArICdEaWQgeW91IGFjY2lkZW50YWxseSBwYXNzIGEgUmVhY3QgY29tcG9uZW50PycpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciBlbGVtZW50VHlwZSA9IHtcbiAgICAkJHR5cGVvZjogUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSxcbiAgICByZW5kZXI6IHJlbmRlclxuICB9O1xuXG4gIHtcbiAgICB2YXIgb3duTmFtZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudFR5cGUsICdkaXNwbGF5TmFtZScsIHtcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBvd25OYW1lO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgb3duTmFtZSA9IG5hbWU7XG5cbiAgICAgICAgaWYgKHJlbmRlci5kaXNwbGF5TmFtZSA9PSBudWxsKSB7XG4gICAgICAgICAgcmVuZGVyLmRpc3BsYXlOYW1lID0gbmFtZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIGVsZW1lbnRUeXBlO1xufVxuXG4vLyBGaWx0ZXIgY2VydGFpbiBET00gYXR0cmlidXRlcyAoZS5nLiBzcmMsIGhyZWYpIGlmIHRoZWlyIHZhbHVlcyBhcmUgZW1wdHkgc3RyaW5ncy5cblxudmFyIGVuYWJsZVNjb3BlQVBJID0gZmFsc2U7IC8vIEV4cGVyaW1lbnRhbCBDcmVhdGUgRXZlbnQgSGFuZGxlIEFQSS5cblxuZnVuY3Rpb24gaXNWYWxpZEVsZW1lbnRUeXBlKHR5cGUpIHtcbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiB0cnVlO1xuICB9IC8vIE5vdGU6IHR5cGVvZiBtaWdodCBiZSBvdGhlciB0aGFuICdzeW1ib2wnIG9yICdudW1iZXInIChlLmcuIGlmIGl0J3MgYSBwb2x5ZmlsbCkuXG5cblxuICBpZiAodHlwZSA9PT0gZXhwb3J0cy5GcmFnbWVudCB8fCB0eXBlID09PSBleHBvcnRzLlByb2ZpbGVyIHx8IHR5cGUgPT09IFJFQUNUX0RFQlVHX1RSQUNJTkdfTU9ERV9UWVBFIHx8IHR5cGUgPT09IGV4cG9ydHMuU3RyaWN0TW9kZSB8fCB0eXBlID09PSBleHBvcnRzLlN1c3BlbnNlIHx8IHR5cGUgPT09IFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9MRUdBQ1lfSElEREVOX1RZUEUgfHwgZW5hYmxlU2NvcGVBUEkgKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmIHR5cGUgIT09IG51bGwpIHtcbiAgICBpZiAodHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTEFaWV9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX01FTU9fVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9QUk9WSURFUl9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NPTlRFWFRfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0ZVTkRBTUVOVEFMX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQkxPQ0tfVFlQRSB8fCB0eXBlWzBdID09PSBSRUFDVF9TRVJWRVJfQkxPQ0tfVFlQRSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBtZW1vKHR5cGUsIGNvbXBhcmUpIHtcbiAge1xuICAgIGlmICghaXNWYWxpZEVsZW1lbnRUeXBlKHR5cGUpKSB7XG4gICAgICBlcnJvcignbWVtbzogVGhlIGZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYSBjb21wb25lbnQuIEluc3RlYWQgJyArICdyZWNlaXZlZDogJXMnLCB0eXBlID09PSBudWxsID8gJ251bGwnIDogdHlwZW9mIHR5cGUpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBlbGVtZW50VHlwZSA9IHtcbiAgICAkJHR5cGVvZjogUkVBQ1RfTUVNT19UWVBFLFxuICAgIHR5cGU6IHR5cGUsXG4gICAgY29tcGFyZTogY29tcGFyZSA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGNvbXBhcmVcbiAgfTtcblxuICB7XG4gICAgdmFyIG93bk5hbWU7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVsZW1lbnRUeXBlLCAnZGlzcGxheU5hbWUnLCB7XG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gb3duTmFtZTtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIG93bk5hbWUgPSBuYW1lO1xuXG4gICAgICAgIGlmICh0eXBlLmRpc3BsYXlOYW1lID09IG51bGwpIHtcbiAgICAgICAgICB0eXBlLmRpc3BsYXlOYW1lID0gbmFtZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIGVsZW1lbnRUeXBlO1xufVxuXG5mdW5jdGlvbiByZXNvbHZlRGlzcGF0Y2hlcigpIHtcbiAgdmFyIGRpc3BhdGNoZXIgPSBSZWFjdEN1cnJlbnREaXNwYXRjaGVyLmN1cnJlbnQ7XG5cbiAgaWYgKCEoZGlzcGF0Y2hlciAhPT0gbnVsbCkpIHtcbiAgICB7XG4gICAgICB0aHJvdyBFcnJvciggXCJJbnZhbGlkIGhvb2sgY2FsbC4gSG9va3MgY2FuIG9ubHkgYmUgY2FsbGVkIGluc2lkZSBvZiB0aGUgYm9keSBvZiBhIGZ1bmN0aW9uIGNvbXBvbmVudC4gVGhpcyBjb3VsZCBoYXBwZW4gZm9yIG9uZSBvZiB0aGUgZm9sbG93aW5nIHJlYXNvbnM6XFxuMS4gWW91IG1pZ2h0IGhhdmUgbWlzbWF0Y2hpbmcgdmVyc2lvbnMgb2YgUmVhY3QgYW5kIHRoZSByZW5kZXJlciAoc3VjaCBhcyBSZWFjdCBET00pXFxuMi4gWW91IG1pZ2h0IGJlIGJyZWFraW5nIHRoZSBSdWxlcyBvZiBIb29rc1xcbjMuIFlvdSBtaWdodCBoYXZlIG1vcmUgdGhhbiBvbmUgY29weSBvZiBSZWFjdCBpbiB0aGUgc2FtZSBhcHBcXG5TZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL2ludmFsaWQtaG9vay1jYWxsIGZvciB0aXBzIGFib3V0IGhvdyB0byBkZWJ1ZyBhbmQgZml4IHRoaXMgcHJvYmxlbS5cIiApO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBkaXNwYXRjaGVyO1xufVxuXG5mdW5jdGlvbiB1c2VDb250ZXh0KENvbnRleHQsIHVuc3RhYmxlX29ic2VydmVkQml0cykge1xuICB2YXIgZGlzcGF0Y2hlciA9IHJlc29sdmVEaXNwYXRjaGVyKCk7XG5cbiAge1xuICAgIGlmICh1bnN0YWJsZV9vYnNlcnZlZEJpdHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgZXJyb3IoJ3VzZUNvbnRleHQoKSBzZWNvbmQgYXJndW1lbnQgaXMgcmVzZXJ2ZWQgZm9yIGZ1dHVyZSAnICsgJ3VzZSBpbiBSZWFjdC4gUGFzc2luZyBpdCBpcyBub3Qgc3VwcG9ydGVkLiAnICsgJ1lvdSBwYXNzZWQ6ICVzLiVzJywgdW5zdGFibGVfb2JzZXJ2ZWRCaXRzLCB0eXBlb2YgdW5zdGFibGVfb2JzZXJ2ZWRCaXRzID09PSAnbnVtYmVyJyAmJiBBcnJheS5pc0FycmF5KGFyZ3VtZW50c1syXSkgPyAnXFxuXFxuRGlkIHlvdSBjYWxsIGFycmF5Lm1hcCh1c2VDb250ZXh0KT8gJyArICdDYWxsaW5nIEhvb2tzIGluc2lkZSBhIGxvb3AgaXMgbm90IHN1cHBvcnRlZC4gJyArICdMZWFybiBtb3JlIGF0IGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9ydWxlcy1vZi1ob29rcycgOiAnJyk7XG4gICAgfSAvLyBUT0RPOiBhZGQgYSBtb3JlIGdlbmVyaWMgd2FybmluZyBmb3IgaW52YWxpZCB2YWx1ZXMuXG5cblxuICAgIGlmIChDb250ZXh0Ll9jb250ZXh0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHZhciByZWFsQ29udGV4dCA9IENvbnRleHQuX2NvbnRleHQ7IC8vIERvbid0IGRlZHVwbGljYXRlIGJlY2F1c2UgdGhpcyBsZWdpdGltYXRlbHkgY2F1c2VzIGJ1Z3NcbiAgICAgIC8vIGFuZCBub2JvZHkgc2hvdWxkIGJlIHVzaW5nIHRoaXMgaW4gZXhpc3RpbmcgY29kZS5cblxuICAgICAgaWYgKHJlYWxDb250ZXh0LkNvbnN1bWVyID09PSBDb250ZXh0KSB7XG4gICAgICAgIGVycm9yKCdDYWxsaW5nIHVzZUNvbnRleHQoQ29udGV4dC5Db25zdW1lcikgaXMgbm90IHN1cHBvcnRlZCwgbWF5IGNhdXNlIGJ1Z3MsIGFuZCB3aWxsIGJlICcgKyAncmVtb3ZlZCBpbiBhIGZ1dHVyZSBtYWpvciByZWxlYXNlLiBEaWQgeW91IG1lYW4gdG8gY2FsbCB1c2VDb250ZXh0KENvbnRleHQpIGluc3RlYWQ/Jyk7XG4gICAgICB9IGVsc2UgaWYgKHJlYWxDb250ZXh0LlByb3ZpZGVyID09PSBDb250ZXh0KSB7XG4gICAgICAgIGVycm9yKCdDYWxsaW5nIHVzZUNvbnRleHQoQ29udGV4dC5Qcm92aWRlcikgaXMgbm90IHN1cHBvcnRlZC4gJyArICdEaWQgeW91IG1lYW4gdG8gY2FsbCB1c2VDb250ZXh0KENvbnRleHQpIGluc3RlYWQ/Jyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGRpc3BhdGNoZXIudXNlQ29udGV4dChDb250ZXh0LCB1bnN0YWJsZV9vYnNlcnZlZEJpdHMpO1xufVxuZnVuY3Rpb24gdXNlU3RhdGUoaW5pdGlhbFN0YXRlKSB7XG4gIHZhciBkaXNwYXRjaGVyID0gcmVzb2x2ZURpc3BhdGNoZXIoKTtcbiAgcmV0dXJuIGRpc3BhdGNoZXIudXNlU3RhdGUoaW5pdGlhbFN0YXRlKTtcbn1cbmZ1bmN0aW9uIHVzZVJlZHVjZXIocmVkdWNlciwgaW5pdGlhbEFyZywgaW5pdCkge1xuICB2YXIgZGlzcGF0Y2hlciA9IHJlc29sdmVEaXNwYXRjaGVyKCk7XG4gIHJldHVybiBkaXNwYXRjaGVyLnVzZVJlZHVjZXIocmVkdWNlciwgaW5pdGlhbEFyZywgaW5pdCk7XG59XG5mdW5jdGlvbiB1c2VSZWYoaW5pdGlhbFZhbHVlKSB7XG4gIHZhciBkaXNwYXRjaGVyID0gcmVzb2x2ZURpc3BhdGNoZXIoKTtcbiAgcmV0dXJuIGRpc3BhdGNoZXIudXNlUmVmKGluaXRpYWxWYWx1ZSk7XG59XG5mdW5jdGlvbiB1c2VFZmZlY3QoY3JlYXRlLCBkZXBzKSB7XG4gIHZhciBkaXNwYXRjaGVyID0gcmVzb2x2ZURpc3BhdGNoZXIoKTtcbiAgcmV0dXJuIGRpc3BhdGNoZXIudXNlRWZmZWN0KGNyZWF0ZSwgZGVwcyk7XG59XG5mdW5jdGlvbiB1c2VMYXlvdXRFZmZlY3QoY3JlYXRlLCBkZXBzKSB7XG4gIHZhciBkaXNwYXRjaGVyID0gcmVzb2x2ZURpc3BhdGNoZXIoKTtcbiAgcmV0dXJuIGRpc3BhdGNoZXIudXNlTGF5b3V0RWZmZWN0KGNyZWF0ZSwgZGVwcyk7XG59XG5mdW5jdGlvbiB1c2VDYWxsYmFjayhjYWxsYmFjaywgZGVwcykge1xuICB2YXIgZGlzcGF0Y2hlciA9IHJlc29sdmVEaXNwYXRjaGVyKCk7XG4gIHJldHVybiBkaXNwYXRjaGVyLnVzZUNhbGxiYWNrKGNhbGxiYWNrLCBkZXBzKTtcbn1cbmZ1bmN0aW9uIHVzZU1lbW8oY3JlYXRlLCBkZXBzKSB7XG4gIHZhciBkaXNwYXRjaGVyID0gcmVzb2x2ZURpc3BhdGNoZXIoKTtcbiAgcmV0dXJuIGRpc3BhdGNoZXIudXNlTWVtbyhjcmVhdGUsIGRlcHMpO1xufVxuZnVuY3Rpb24gdXNlSW1wZXJhdGl2ZUhhbmRsZShyZWYsIGNyZWF0ZSwgZGVwcykge1xuICB2YXIgZGlzcGF0Y2hlciA9IHJlc29sdmVEaXNwYXRjaGVyKCk7XG4gIHJldHVybiBkaXNwYXRjaGVyLnVzZUltcGVyYXRpdmVIYW5kbGUocmVmLCBjcmVhdGUsIGRlcHMpO1xufVxuZnVuY3Rpb24gdXNlRGVidWdWYWx1ZSh2YWx1ZSwgZm9ybWF0dGVyRm4pIHtcbiAge1xuICAgIHZhciBkaXNwYXRjaGVyID0gcmVzb2x2ZURpc3BhdGNoZXIoKTtcbiAgICByZXR1cm4gZGlzcGF0Y2hlci51c2VEZWJ1Z1ZhbHVlKHZhbHVlLCBmb3JtYXR0ZXJGbik7XG4gIH1cbn1cblxuLy8gSGVscGVycyB0byBwYXRjaCBjb25zb2xlLmxvZ3MgdG8gYXZvaWQgbG9nZ2luZyBkdXJpbmcgc2lkZS1lZmZlY3QgZnJlZVxuLy8gcmVwbGF5aW5nIG9uIHJlbmRlciBmdW5jdGlvbi4gVGhpcyBjdXJyZW50bHkgb25seSBwYXRjaGVzIHRoZSBvYmplY3Rcbi8vIGxhemlseSB3aGljaCB3b24ndCBjb3ZlciBpZiB0aGUgbG9nIGZ1bmN0aW9uIHdhcyBleHRyYWN0ZWQgZWFnZXJseS5cbi8vIFdlIGNvdWxkIGFsc28gZWFnZXJseSBwYXRjaCB0aGUgbWV0aG9kLlxudmFyIGRpc2FibGVkRGVwdGggPSAwO1xudmFyIHByZXZMb2c7XG52YXIgcHJldkluZm87XG52YXIgcHJldldhcm47XG52YXIgcHJldkVycm9yO1xudmFyIHByZXZHcm91cDtcbnZhciBwcmV2R3JvdXBDb2xsYXBzZWQ7XG52YXIgcHJldkdyb3VwRW5kO1xuXG5mdW5jdGlvbiBkaXNhYmxlZExvZygpIHt9XG5cbmRpc2FibGVkTG9nLl9fcmVhY3REaXNhYmxlZExvZyA9IHRydWU7XG5mdW5jdGlvbiBkaXNhYmxlTG9ncygpIHtcbiAge1xuICAgIGlmIChkaXNhYmxlZERlcHRoID09PSAwKSB7XG4gICAgICAvKiBlc2xpbnQtZGlzYWJsZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmcgKi9cbiAgICAgIHByZXZMb2cgPSBjb25zb2xlLmxvZztcbiAgICAgIHByZXZJbmZvID0gY29uc29sZS5pbmZvO1xuICAgICAgcHJldldhcm4gPSBjb25zb2xlLndhcm47XG4gICAgICBwcmV2RXJyb3IgPSBjb25zb2xlLmVycm9yO1xuICAgICAgcHJldkdyb3VwID0gY29uc29sZS5ncm91cDtcbiAgICAgIHByZXZHcm91cENvbGxhcHNlZCA9IGNvbnNvbGUuZ3JvdXBDb2xsYXBzZWQ7XG4gICAgICBwcmV2R3JvdXBFbmQgPSBjb25zb2xlLmdyb3VwRW5kOyAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzE5MDk5XG5cbiAgICAgIHZhciBwcm9wcyA9IHtcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICB2YWx1ZTogZGlzYWJsZWRMb2csXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICB9OyAvLyAkRmxvd0ZpeE1lIEZsb3cgdGhpbmtzIGNvbnNvbGUgaXMgaW1tdXRhYmxlLlxuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhjb25zb2xlLCB7XG4gICAgICAgIGluZm86IHByb3BzLFxuICAgICAgICBsb2c6IHByb3BzLFxuICAgICAgICB3YXJuOiBwcm9wcyxcbiAgICAgICAgZXJyb3I6IHByb3BzLFxuICAgICAgICBncm91cDogcHJvcHMsXG4gICAgICAgIGdyb3VwQ29sbGFwc2VkOiBwcm9wcyxcbiAgICAgICAgZ3JvdXBFbmQ6IHByb3BzXG4gICAgICB9KTtcbiAgICAgIC8qIGVzbGludC1lbmFibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgfVxuXG4gICAgZGlzYWJsZWREZXB0aCsrO1xuICB9XG59XG5mdW5jdGlvbiByZWVuYWJsZUxvZ3MoKSB7XG4gIHtcbiAgICBkaXNhYmxlZERlcHRoLS07XG5cbiAgICBpZiAoZGlzYWJsZWREZXB0aCA9PT0gMCkge1xuICAgICAgLyogZXNsaW50LWRpc2FibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgICB2YXIgcHJvcHMgPSB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgIH07IC8vICRGbG93Rml4TWUgRmxvdyB0aGlua3MgY29uc29sZSBpcyBpbW11dGFibGUuXG5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGNvbnNvbGUsIHtcbiAgICAgICAgbG9nOiBfYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2TG9nXG4gICAgICAgIH0pLFxuICAgICAgICBpbmZvOiBfYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2SW5mb1xuICAgICAgICB9KSxcbiAgICAgICAgd2FybjogX2Fzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldldhcm5cbiAgICAgICAgfSksXG4gICAgICAgIGVycm9yOiBfYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2RXJyb3JcbiAgICAgICAgfSksXG4gICAgICAgIGdyb3VwOiBfYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2R3JvdXBcbiAgICAgICAgfSksXG4gICAgICAgIGdyb3VwQ29sbGFwc2VkOiBfYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2R3JvdXBDb2xsYXBzZWRcbiAgICAgICAgfSksXG4gICAgICAgIGdyb3VwRW5kOiBfYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2R3JvdXBFbmRcbiAgICAgICAgfSlcbiAgICAgIH0pO1xuICAgICAgLyogZXNsaW50LWVuYWJsZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmcgKi9cbiAgICB9XG5cbiAgICBpZiAoZGlzYWJsZWREZXB0aCA8IDApIHtcbiAgICAgIGVycm9yKCdkaXNhYmxlZERlcHRoIGZlbGwgYmVsb3cgemVyby4gJyArICdUaGlzIGlzIGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0Q3VycmVudERpc3BhdGNoZXI7XG52YXIgcHJlZml4O1xuZnVuY3Rpb24gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUobmFtZSwgc291cmNlLCBvd25lckZuKSB7XG4gIHtcbiAgICBpZiAocHJlZml4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIEV4dHJhY3QgdGhlIFZNIHNwZWNpZmljIHByZWZpeCB1c2VkIGJ5IGVhY2ggbGluZS5cbiAgICAgIHRyeSB7XG4gICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgIHZhciBtYXRjaCA9IHguc3RhY2sudHJpbSgpLm1hdGNoKC9cXG4oICooYXQgKT8pLyk7XG4gICAgICAgIHByZWZpeCA9IG1hdGNoICYmIG1hdGNoWzFdIHx8ICcnO1xuICAgICAgfVxuICAgIH0gLy8gV2UgdXNlIHRoZSBwcmVmaXggdG8gZW5zdXJlIG91ciBzdGFja3MgbGluZSB1cCB3aXRoIG5hdGl2ZSBzdGFjayBmcmFtZXMuXG5cblxuICAgIHJldHVybiAnXFxuJyArIHByZWZpeCArIG5hbWU7XG4gIH1cbn1cbnZhciByZWVudHJ5ID0gZmFsc2U7XG52YXIgY29tcG9uZW50RnJhbWVDYWNoZTtcblxue1xuICB2YXIgUG9zc2libHlXZWFrTWFwID0gdHlwZW9mIFdlYWtNYXAgPT09ICdmdW5jdGlvbicgPyBXZWFrTWFwIDogTWFwO1xuICBjb21wb25lbnRGcmFtZUNhY2hlID0gbmV3IFBvc3NpYmx5V2Vha01hcCgpO1xufVxuXG5mdW5jdGlvbiBkZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lKGZuLCBjb25zdHJ1Y3QpIHtcbiAgLy8gSWYgc29tZXRoaW5nIGFza2VkIGZvciBhIHN0YWNrIGluc2lkZSBhIGZha2UgcmVuZGVyLCBpdCBzaG91bGQgZ2V0IGlnbm9yZWQuXG4gIGlmICghZm4gfHwgcmVlbnRyeSkge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIHtcbiAgICB2YXIgZnJhbWUgPSBjb21wb25lbnRGcmFtZUNhY2hlLmdldChmbik7XG5cbiAgICBpZiAoZnJhbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGZyYW1lO1xuICAgIH1cbiAgfVxuXG4gIHZhciBjb250cm9sO1xuICByZWVudHJ5ID0gdHJ1ZTtcbiAgdmFyIHByZXZpb3VzUHJlcGFyZVN0YWNrVHJhY2UgPSBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZTsgLy8gJEZsb3dGaXhNZSBJdCBkb2VzIGFjY2VwdCB1bmRlZmluZWQuXG5cbiAgRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSB1bmRlZmluZWQ7XG4gIHZhciBwcmV2aW91c0Rpc3BhdGNoZXI7XG5cbiAge1xuICAgIHByZXZpb3VzRGlzcGF0Y2hlciA9IFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50OyAvLyBTZXQgdGhlIGRpc3BhdGNoZXIgaW4gREVWIGJlY2F1c2UgdGhpcyBtaWdodCBiZSBjYWxsIGluIHRoZSByZW5kZXIgZnVuY3Rpb25cbiAgICAvLyBmb3Igd2FybmluZ3MuXG5cbiAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudCA9IG51bGw7XG4gICAgZGlzYWJsZUxvZ3MoKTtcbiAgfVxuXG4gIHRyeSB7XG4gICAgLy8gVGhpcyBzaG91bGQgdGhyb3cuXG4gICAgaWYgKGNvbnN0cnVjdCkge1xuICAgICAgLy8gU29tZXRoaW5nIHNob3VsZCBiZSBzZXR0aW5nIHRoZSBwcm9wcyBpbiB0aGUgY29uc3RydWN0b3IuXG4gICAgICB2YXIgRmFrZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgIH07IC8vICRGbG93Rml4TWVcblxuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRmFrZS5wcm90b3R5cGUsICdwcm9wcycsIHtcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgLy8gV2UgdXNlIGEgdGhyb3dpbmcgc2V0dGVyIGluc3RlYWQgb2YgZnJvemVuIG9yIG5vbi13cml0YWJsZSBwcm9wc1xuICAgICAgICAgIC8vIGJlY2F1c2UgdGhhdCB3b24ndCB0aHJvdyBpbiBhIG5vbi1zdHJpY3QgbW9kZSBmdW5jdGlvbi5cbiAgICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSAnb2JqZWN0JyAmJiBSZWZsZWN0LmNvbnN0cnVjdCkge1xuICAgICAgICAvLyBXZSBjb25zdHJ1Y3QgYSBkaWZmZXJlbnQgY29udHJvbCBmb3IgdGhpcyBjYXNlIHRvIGluY2x1ZGUgYW55IGV4dHJhXG4gICAgICAgIC8vIGZyYW1lcyBhZGRlZCBieSB0aGUgY29uc3RydWN0IGNhbGwuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgUmVmbGVjdC5jb25zdHJ1Y3QoRmFrZSwgW10pO1xuICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgY29udHJvbCA9IHg7XG4gICAgICAgIH1cblxuICAgICAgICBSZWZsZWN0LmNvbnN0cnVjdChmbiwgW10sIEZha2UpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBGYWtlLmNhbGwoKTtcbiAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgIGNvbnRyb2wgPSB4O1xuICAgICAgICB9XG5cbiAgICAgICAgZm4uY2FsbChGYWtlLnByb3RvdHlwZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgIGNvbnRyb2wgPSB4O1xuICAgICAgfVxuXG4gICAgICBmbigpO1xuICAgIH1cbiAgfSBjYXRjaCAoc2FtcGxlKSB7XG4gICAgLy8gVGhpcyBpcyBpbmxpbmVkIG1hbnVhbGx5IGJlY2F1c2UgY2xvc3VyZSBkb2Vzbid0IGRvIGl0IGZvciB1cy5cbiAgICBpZiAoc2FtcGxlICYmIGNvbnRyb2wgJiYgdHlwZW9mIHNhbXBsZS5zdGFjayA9PT0gJ3N0cmluZycpIHtcbiAgICAgIC8vIFRoaXMgZXh0cmFjdHMgdGhlIGZpcnN0IGZyYW1lIGZyb20gdGhlIHNhbXBsZSB0aGF0IGlzbid0IGFsc28gaW4gdGhlIGNvbnRyb2wuXG4gICAgICAvLyBTa2lwcGluZyBvbmUgZnJhbWUgdGhhdCB3ZSBhc3N1bWUgaXMgdGhlIGZyYW1lIHRoYXQgY2FsbHMgdGhlIHR3by5cbiAgICAgIHZhciBzYW1wbGVMaW5lcyA9IHNhbXBsZS5zdGFjay5zcGxpdCgnXFxuJyk7XG4gICAgICB2YXIgY29udHJvbExpbmVzID0gY29udHJvbC5zdGFjay5zcGxpdCgnXFxuJyk7XG4gICAgICB2YXIgcyA9IHNhbXBsZUxpbmVzLmxlbmd0aCAtIDE7XG4gICAgICB2YXIgYyA9IGNvbnRyb2xMaW5lcy5sZW5ndGggLSAxO1xuXG4gICAgICB3aGlsZSAocyA+PSAxICYmIGMgPj0gMCAmJiBzYW1wbGVMaW5lc1tzXSAhPT0gY29udHJvbExpbmVzW2NdKSB7XG4gICAgICAgIC8vIFdlIGV4cGVjdCBhdCBsZWFzdCBvbmUgc3RhY2sgZnJhbWUgdG8gYmUgc2hhcmVkLlxuICAgICAgICAvLyBUeXBpY2FsbHkgdGhpcyB3aWxsIGJlIHRoZSByb290IG1vc3Qgb25lLiBIb3dldmVyLCBzdGFjayBmcmFtZXMgbWF5IGJlXG4gICAgICAgIC8vIGN1dCBvZmYgZHVlIHRvIG1heGltdW0gc3RhY2sgbGltaXRzLiBJbiB0aGlzIGNhc2UsIG9uZSBtYXliZSBjdXQgb2ZmXG4gICAgICAgIC8vIGVhcmxpZXIgdGhhbiB0aGUgb3RoZXIuIFdlIGFzc3VtZSB0aGF0IHRoZSBzYW1wbGUgaXMgbG9uZ2VyIG9yIHRoZSBzYW1lXG4gICAgICAgIC8vIGFuZCB0aGVyZSBmb3IgY3V0IG9mZiBlYXJsaWVyLiBTbyB3ZSBzaG91bGQgZmluZCB0aGUgcm9vdCBtb3N0IGZyYW1lIGluXG4gICAgICAgIC8vIHRoZSBzYW1wbGUgc29tZXdoZXJlIGluIHRoZSBjb250cm9sLlxuICAgICAgICBjLS07XG4gICAgICB9XG5cbiAgICAgIGZvciAoOyBzID49IDEgJiYgYyA+PSAwOyBzLS0sIGMtLSkge1xuICAgICAgICAvLyBOZXh0IHdlIGZpbmQgdGhlIGZpcnN0IG9uZSB0aGF0IGlzbid0IHRoZSBzYW1lIHdoaWNoIHNob3VsZCBiZSB0aGVcbiAgICAgICAgLy8gZnJhbWUgdGhhdCBjYWxsZWQgb3VyIHNhbXBsZSBmdW5jdGlvbiBhbmQgdGhlIGNvbnRyb2wuXG4gICAgICAgIGlmIChzYW1wbGVMaW5lc1tzXSAhPT0gY29udHJvbExpbmVzW2NdKSB7XG4gICAgICAgICAgLy8gSW4gVjgsIHRoZSBmaXJzdCBsaW5lIGlzIGRlc2NyaWJpbmcgdGhlIG1lc3NhZ2UgYnV0IG90aGVyIFZNcyBkb24ndC5cbiAgICAgICAgICAvLyBJZiB3ZSdyZSBhYm91dCB0byByZXR1cm4gdGhlIGZpcnN0IGxpbmUsIGFuZCB0aGUgY29udHJvbCBpcyBhbHNvIG9uIHRoZSBzYW1lXG4gICAgICAgICAgLy8gbGluZSwgdGhhdCdzIGEgcHJldHR5IGdvb2QgaW5kaWNhdG9yIHRoYXQgb3VyIHNhbXBsZSB0aHJldyBhdCBzYW1lIGxpbmUgYXNcbiAgICAgICAgICAvLyB0aGUgY29udHJvbC4gSS5lLiBiZWZvcmUgd2UgZW50ZXJlZCB0aGUgc2FtcGxlIGZyYW1lLiBTbyB3ZSBpZ25vcmUgdGhpcyByZXN1bHQuXG4gICAgICAgICAgLy8gVGhpcyBjYW4gaGFwcGVuIGlmIHlvdSBwYXNzZWQgYSBjbGFzcyB0byBmdW5jdGlvbiBjb21wb25lbnQsIG9yIG5vbi1mdW5jdGlvbi5cbiAgICAgICAgICBpZiAocyAhPT0gMSB8fCBjICE9PSAxKSB7XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgIHMtLTtcbiAgICAgICAgICAgICAgYy0tOyAvLyBXZSBtYXkgc3RpbGwgaGF2ZSBzaW1pbGFyIGludGVybWVkaWF0ZSBmcmFtZXMgZnJvbSB0aGUgY29uc3RydWN0IGNhbGwuXG4gICAgICAgICAgICAgIC8vIFRoZSBuZXh0IG9uZSB0aGF0IGlzbid0IHRoZSBzYW1lIHNob3VsZCBiZSBvdXIgbWF0Y2ggdGhvdWdoLlxuXG4gICAgICAgICAgICAgIGlmIChjIDwgMCB8fCBzYW1wbGVMaW5lc1tzXSAhPT0gY29udHJvbExpbmVzW2NdKSB7XG4gICAgICAgICAgICAgICAgLy8gVjggYWRkcyBhIFwibmV3XCIgcHJlZml4IGZvciBuYXRpdmUgY2xhc3Nlcy4gTGV0J3MgcmVtb3ZlIGl0IHRvIG1ha2UgaXQgcHJldHRpZXIuXG4gICAgICAgICAgICAgICAgdmFyIF9mcmFtZSA9ICdcXG4nICsgc2FtcGxlTGluZXNbc10ucmVwbGFjZSgnIGF0IG5ldyAnLCAnIGF0ICcpO1xuXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnRGcmFtZUNhY2hlLnNldChmbiwgX2ZyYW1lKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IC8vIFJldHVybiB0aGUgbGluZSB3ZSBmb3VuZC5cblxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9mcmFtZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSB3aGlsZSAocyA+PSAxICYmIGMgPj0gMCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0gZmluYWxseSB7XG4gICAgcmVlbnRyeSA9IGZhbHNlO1xuXG4gICAge1xuICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSBwcmV2aW91c0Rpc3BhdGNoZXI7XG4gICAgICByZWVuYWJsZUxvZ3MoKTtcbiAgICB9XG5cbiAgICBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZSA9IHByZXZpb3VzUHJlcGFyZVN0YWNrVHJhY2U7XG4gIH0gLy8gRmFsbGJhY2sgdG8ganVzdCB1c2luZyB0aGUgbmFtZSBpZiB3ZSBjb3VsZG4ndCBtYWtlIGl0IHRocm93LlxuXG5cbiAgdmFyIG5hbWUgPSBmbiA/IGZuLmRpc3BsYXlOYW1lIHx8IGZuLm5hbWUgOiAnJztcbiAgdmFyIHN5bnRoZXRpY0ZyYW1lID0gbmFtZSA/IGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKG5hbWUpIDogJyc7XG5cbiAge1xuICAgIGlmICh0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNvbXBvbmVudEZyYW1lQ2FjaGUuc2V0KGZuLCBzeW50aGV0aWNGcmFtZSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHN5bnRoZXRpY0ZyYW1lO1xufVxuZnVuY3Rpb24gZGVzY3JpYmVGdW5jdGlvbkNvbXBvbmVudEZyYW1lKGZuLCBzb3VyY2UsIG93bmVyRm4pIHtcbiAge1xuICAgIHJldHVybiBkZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lKGZuLCBmYWxzZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc2hvdWxkQ29uc3RydWN0KENvbXBvbmVudCkge1xuICB2YXIgcHJvdG90eXBlID0gQ29tcG9uZW50LnByb3RvdHlwZTtcbiAgcmV0dXJuICEhKHByb3RvdHlwZSAmJiBwcm90b3R5cGUuaXNSZWFjdENvbXBvbmVudCk7XG59XG5cbmZ1bmN0aW9uIGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVih0eXBlLCBzb3VyY2UsIG93bmVyRm4pIHtcblxuICBpZiAodHlwZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAge1xuICAgICAgcmV0dXJuIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUodHlwZSwgc2hvdWxkQ29uc3RydWN0KHR5cGUpKTtcbiAgICB9XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKHR5cGUpO1xuICB9XG5cbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBleHBvcnRzLlN1c3BlbnNlOlxuICAgICAgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKCdTdXNwZW5zZScpO1xuXG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEU6XG4gICAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoJ1N1c3BlbnNlTGlzdCcpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0Jykge1xuICAgIHN3aXRjaCAodHlwZS4kJHR5cGVvZikge1xuICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxuICAgICAgICByZXR1cm4gZGVzY3JpYmVGdW5jdGlvbkNvbXBvbmVudEZyYW1lKHR5cGUucmVuZGVyKTtcblxuICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XG4gICAgICAgIC8vIE1lbW8gbWF5IGNvbnRhaW4gYW55IGNvbXBvbmVudCB0eXBlIHNvIHdlIHJlY3Vyc2l2ZWx5IHJlc29sdmUgaXQuXG4gICAgICAgIHJldHVybiBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYodHlwZS50eXBlLCBzb3VyY2UsIG93bmVyRm4pO1xuXG4gICAgICBjYXNlIFJFQUNUX0JMT0NLX1RZUEU6XG4gICAgICAgIHJldHVybiBkZXNjcmliZUZ1bmN0aW9uQ29tcG9uZW50RnJhbWUodHlwZS5fcmVuZGVyKTtcblxuICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgbGF6eUNvbXBvbmVudCA9IHR5cGU7XG4gICAgICAgICAgdmFyIHBheWxvYWQgPSBsYXp5Q29tcG9uZW50Ll9wYXlsb2FkO1xuICAgICAgICAgIHZhciBpbml0ID0gbGF6eUNvbXBvbmVudC5faW5pdDtcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBMYXp5IG1heSBjb250YWluIGFueSBjb21wb25lbnQgdHlwZSBzbyB3ZSByZWN1cnNpdmVseSByZXNvbHZlIGl0LlxuICAgICAgICAgICAgcmV0dXJuIGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVihpbml0KHBheWxvYWQpLCBzb3VyY2UsIG93bmVyRm4pO1xuICAgICAgICAgIH0gY2F0Y2ggKHgpIHt9XG4gICAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gJyc7XG59XG5cbnZhciBsb2dnZWRUeXBlRmFpbHVyZXMgPSB7fTtcbnZhciBSZWFjdERlYnVnQ3VycmVudEZyYW1lJDEgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdERlYnVnQ3VycmVudEZyYW1lO1xuXG5mdW5jdGlvbiBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChlbGVtZW50KSB7XG4gIHtcbiAgICBpZiAoZWxlbWVudCkge1xuICAgICAgdmFyIG93bmVyID0gZWxlbWVudC5fb3duZXI7XG4gICAgICB2YXIgc3RhY2sgPSBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYoZWxlbWVudC50eXBlLCBlbGVtZW50Ll9zb3VyY2UsIG93bmVyID8gb3duZXIudHlwZSA6IG51bGwpO1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSQxLnNldEV4dHJhU3RhY2tGcmFtZShzdGFjayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWUkMS5zZXRFeHRyYVN0YWNrRnJhbWUobnVsbCk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNoZWNrUHJvcFR5cGVzKHR5cGVTcGVjcywgdmFsdWVzLCBsb2NhdGlvbiwgY29tcG9uZW50TmFtZSwgZWxlbWVudCkge1xuICB7XG4gICAgLy8gJEZsb3dGaXhNZSBUaGlzIGlzIG9rYXkgYnV0IEZsb3cgZG9lc24ndCBrbm93IGl0LlxuICAgIHZhciBoYXMgPSBGdW5jdGlvbi5jYWxsLmJpbmQoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSk7XG5cbiAgICBmb3IgKHZhciB0eXBlU3BlY05hbWUgaW4gdHlwZVNwZWNzKSB7XG4gICAgICBpZiAoaGFzKHR5cGVTcGVjcywgdHlwZVNwZWNOYW1lKSkge1xuICAgICAgICB2YXIgZXJyb3IkMSA9IHZvaWQgMDsgLy8gUHJvcCB0eXBlIHZhbGlkYXRpb24gbWF5IHRocm93LiBJbiBjYXNlIHRoZXkgZG8sIHdlIGRvbid0IHdhbnQgdG9cbiAgICAgICAgLy8gZmFpbCB0aGUgcmVuZGVyIHBoYXNlIHdoZXJlIGl0IGRpZG4ndCBmYWlsIGJlZm9yZS4gU28gd2UgbG9nIGl0LlxuICAgICAgICAvLyBBZnRlciB0aGVzZSBoYXZlIGJlZW4gY2xlYW5lZCB1cCwgd2UnbGwgbGV0IHRoZW0gdGhyb3cuXG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyBUaGlzIGlzIGludGVudGlvbmFsbHkgYW4gaW52YXJpYW50IHRoYXQgZ2V0cyBjYXVnaHQuIEl0J3MgdGhlIHNhbWVcbiAgICAgICAgICAvLyBiZWhhdmlvciBhcyB3aXRob3V0IHRoaXMgc3RhdGVtZW50IGV4Y2VwdCB3aXRoIGEgYmV0dGVyIG1lc3NhZ2UuXG4gICAgICAgICAgaWYgKHR5cGVvZiB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdmFyIGVyciA9IEVycm9yKChjb21wb25lbnROYW1lIHx8ICdSZWFjdCBjbGFzcycpICsgJzogJyArIGxvY2F0aW9uICsgJyB0eXBlIGAnICsgdHlwZVNwZWNOYW1lICsgJ2AgaXMgaW52YWxpZDsgJyArICdpdCBtdXN0IGJlIGEgZnVuY3Rpb24sIHVzdWFsbHkgZnJvbSB0aGUgYHByb3AtdHlwZXNgIHBhY2thZ2UsIGJ1dCByZWNlaXZlZCBgJyArIHR5cGVvZiB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSArICdgLicgKyAnVGhpcyBvZnRlbiBoYXBwZW5zIGJlY2F1c2Ugb2YgdHlwb3Mgc3VjaCBhcyBgUHJvcFR5cGVzLmZ1bmN0aW9uYCBpbnN0ZWFkIG9mIGBQcm9wVHlwZXMuZnVuY2AuJyk7XG4gICAgICAgICAgICBlcnIubmFtZSA9ICdJbnZhcmlhbnQgVmlvbGF0aW9uJztcbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBlcnJvciQxID0gdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0odmFsdWVzLCB0eXBlU3BlY05hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBudWxsLCAnU0VDUkVUX0RPX05PVF9QQVNTX1RISVNfT1JfWU9VX1dJTExfQkVfRklSRUQnKTtcbiAgICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgICBlcnJvciQxID0gZXg7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXJyb3IkMSAmJiAhKGVycm9yJDEgaW5zdGFuY2VvZiBFcnJvcikpIHtcbiAgICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChlbGVtZW50KTtcblxuICAgICAgICAgIGVycm9yKCclczogdHlwZSBzcGVjaWZpY2F0aW9uIG9mICVzJyArICcgYCVzYCBpcyBpbnZhbGlkOyB0aGUgdHlwZSBjaGVja2VyICcgKyAnZnVuY3Rpb24gbXVzdCByZXR1cm4gYG51bGxgIG9yIGFuIGBFcnJvcmAgYnV0IHJldHVybmVkIGEgJXMuICcgKyAnWW91IG1heSBoYXZlIGZvcmdvdHRlbiB0byBwYXNzIGFuIGFyZ3VtZW50IHRvIHRoZSB0eXBlIGNoZWNrZXIgJyArICdjcmVhdG9yIChhcnJheU9mLCBpbnN0YW5jZU9mLCBvYmplY3RPZiwgb25lT2YsIG9uZU9mVHlwZSwgYW5kICcgKyAnc2hhcGUgYWxsIHJlcXVpcmUgYW4gYXJndW1lbnQpLicsIGNvbXBvbmVudE5hbWUgfHwgJ1JlYWN0IGNsYXNzJywgbG9jYXRpb24sIHR5cGVTcGVjTmFtZSwgdHlwZW9mIGVycm9yJDEpO1xuXG4gICAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQobnVsbCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXJyb3IkMSBpbnN0YW5jZW9mIEVycm9yICYmICEoZXJyb3IkMS5tZXNzYWdlIGluIGxvZ2dlZFR5cGVGYWlsdXJlcykpIHtcbiAgICAgICAgICAvLyBPbmx5IG1vbml0b3IgdGhpcyBmYWlsdXJlIG9uY2UgYmVjYXVzZSB0aGVyZSB0ZW5kcyB0byBiZSBhIGxvdCBvZiB0aGVcbiAgICAgICAgICAvLyBzYW1lIGVycm9yLlxuICAgICAgICAgIGxvZ2dlZFR5cGVGYWlsdXJlc1tlcnJvciQxLm1lc3NhZ2VdID0gdHJ1ZTtcbiAgICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChlbGVtZW50KTtcblxuICAgICAgICAgIGVycm9yKCdGYWlsZWQgJXMgdHlwZTogJXMnLCBsb2NhdGlvbiwgZXJyb3IkMS5tZXNzYWdlKTtcblxuICAgICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KG51bGwpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEoZWxlbWVudCkge1xuICB7XG4gICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgIHZhciBvd25lciA9IGVsZW1lbnQuX293bmVyO1xuICAgICAgdmFyIHN0YWNrID0gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKGVsZW1lbnQudHlwZSwgZWxlbWVudC5fc291cmNlLCBvd25lciA/IG93bmVyLnR5cGUgOiBudWxsKTtcbiAgICAgIHNldEV4dHJhU3RhY2tGcmFtZShzdGFjayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNldEV4dHJhU3RhY2tGcmFtZShudWxsKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIHByb3BUeXBlc01pc3NwZWxsV2FybmluZ1Nob3duO1xuXG57XG4gIHByb3BUeXBlc01pc3NwZWxsV2FybmluZ1Nob3duID0gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bSgpIHtcbiAgaWYgKFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQpIHtcbiAgICB2YXIgbmFtZSA9IGdldENvbXBvbmVudE5hbWUoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudC50eXBlKTtcblxuICAgIGlmIChuYW1lKSB7XG4gICAgICByZXR1cm4gJ1xcblxcbkNoZWNrIHRoZSByZW5kZXIgbWV0aG9kIG9mIGAnICsgbmFtZSArICdgLic7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuICcnO1xufVxuXG5mdW5jdGlvbiBnZXRTb3VyY2VJbmZvRXJyb3JBZGRlbmR1bShzb3VyY2UpIHtcbiAgaWYgKHNvdXJjZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdmFyIGZpbGVOYW1lID0gc291cmNlLmZpbGVOYW1lLnJlcGxhY2UoL14uKltcXFxcXFwvXS8sICcnKTtcbiAgICB2YXIgbGluZU51bWJlciA9IHNvdXJjZS5saW5lTnVtYmVyO1xuICAgIHJldHVybiAnXFxuXFxuQ2hlY2sgeW91ciBjb2RlIGF0ICcgKyBmaWxlTmFtZSArICc6JyArIGxpbmVOdW1iZXIgKyAnLic7XG4gIH1cblxuICByZXR1cm4gJyc7XG59XG5cbmZ1bmN0aW9uIGdldFNvdXJjZUluZm9FcnJvckFkZGVuZHVtRm9yUHJvcHMoZWxlbWVudFByb3BzKSB7XG4gIGlmIChlbGVtZW50UHJvcHMgIT09IG51bGwgJiYgZWxlbWVudFByb3BzICE9PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gZ2V0U291cmNlSW5mb0Vycm9yQWRkZW5kdW0oZWxlbWVudFByb3BzLl9fc291cmNlKTtcbiAgfVxuXG4gIHJldHVybiAnJztcbn1cbi8qKlxuICogV2FybiBpZiB0aGVyZSdzIG5vIGtleSBleHBsaWNpdGx5IHNldCBvbiBkeW5hbWljIGFycmF5cyBvZiBjaGlsZHJlbiBvclxuICogb2JqZWN0IGtleXMgYXJlIG5vdCB2YWxpZC4gVGhpcyBhbGxvd3MgdXMgdG8ga2VlcCB0cmFjayBvZiBjaGlsZHJlbiBiZXR3ZWVuXG4gKiB1cGRhdGVzLlxuICovXG5cblxudmFyIG93bmVySGFzS2V5VXNlV2FybmluZyA9IHt9O1xuXG5mdW5jdGlvbiBnZXRDdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvKHBhcmVudFR5cGUpIHtcbiAgdmFyIGluZm8gPSBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKTtcblxuICBpZiAoIWluZm8pIHtcbiAgICB2YXIgcGFyZW50TmFtZSA9IHR5cGVvZiBwYXJlbnRUeXBlID09PSAnc3RyaW5nJyA/IHBhcmVudFR5cGUgOiBwYXJlbnRUeXBlLmRpc3BsYXlOYW1lIHx8IHBhcmVudFR5cGUubmFtZTtcblxuICAgIGlmIChwYXJlbnROYW1lKSB7XG4gICAgICBpbmZvID0gXCJcXG5cXG5DaGVjayB0aGUgdG9wLWxldmVsIHJlbmRlciBjYWxsIHVzaW5nIDxcIiArIHBhcmVudE5hbWUgKyBcIj4uXCI7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGluZm87XG59XG4vKipcbiAqIFdhcm4gaWYgdGhlIGVsZW1lbnQgZG9lc24ndCBoYXZlIGFuIGV4cGxpY2l0IGtleSBhc3NpZ25lZCB0byBpdC5cbiAqIFRoaXMgZWxlbWVudCBpcyBpbiBhbiBhcnJheS4gVGhlIGFycmF5IGNvdWxkIGdyb3cgYW5kIHNocmluayBvciBiZVxuICogcmVvcmRlcmVkLiBBbGwgY2hpbGRyZW4gdGhhdCBoYXZlbid0IGFscmVhZHkgYmVlbiB2YWxpZGF0ZWQgYXJlIHJlcXVpcmVkIHRvXG4gKiBoYXZlIGEgXCJrZXlcIiBwcm9wZXJ0eSBhc3NpZ25lZCB0byBpdC4gRXJyb3Igc3RhdHVzZXMgYXJlIGNhY2hlZCBzbyBhIHdhcm5pbmdcbiAqIHdpbGwgb25seSBiZSBzaG93biBvbmNlLlxuICpcbiAqIEBpbnRlcm5hbFxuICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGVsZW1lbnQgRWxlbWVudCB0aGF0IHJlcXVpcmVzIGEga2V5LlxuICogQHBhcmFtIHsqfSBwYXJlbnRUeXBlIGVsZW1lbnQncyBwYXJlbnQncyB0eXBlLlxuICovXG5cblxuZnVuY3Rpb24gdmFsaWRhdGVFeHBsaWNpdEtleShlbGVtZW50LCBwYXJlbnRUeXBlKSB7XG4gIGlmICghZWxlbWVudC5fc3RvcmUgfHwgZWxlbWVudC5fc3RvcmUudmFsaWRhdGVkIHx8IGVsZW1lbnQua2V5ICE9IG51bGwpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBlbGVtZW50Ll9zdG9yZS52YWxpZGF0ZWQgPSB0cnVlO1xuICB2YXIgY3VycmVudENvbXBvbmVudEVycm9ySW5mbyA9IGdldEN1cnJlbnRDb21wb25lbnRFcnJvckluZm8ocGFyZW50VHlwZSk7XG5cbiAgaWYgKG93bmVySGFzS2V5VXNlV2FybmluZ1tjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvXSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIG93bmVySGFzS2V5VXNlV2FybmluZ1tjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvXSA9IHRydWU7IC8vIFVzdWFsbHkgdGhlIGN1cnJlbnQgb3duZXIgaXMgdGhlIG9mZmVuZGVyLCBidXQgaWYgaXQgYWNjZXB0cyBjaGlsZHJlbiBhcyBhXG4gIC8vIHByb3BlcnR5LCBpdCBtYXkgYmUgdGhlIGNyZWF0b3Igb2YgdGhlIGNoaWxkIHRoYXQncyByZXNwb25zaWJsZSBmb3JcbiAgLy8gYXNzaWduaW5nIGl0IGEga2V5LlxuXG4gIHZhciBjaGlsZE93bmVyID0gJyc7XG5cbiAgaWYgKGVsZW1lbnQgJiYgZWxlbWVudC5fb3duZXIgJiYgZWxlbWVudC5fb3duZXIgIT09IFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQpIHtcbiAgICAvLyBHaXZlIHRoZSBjb21wb25lbnQgdGhhdCBvcmlnaW5hbGx5IGNyZWF0ZWQgdGhpcyBjaGlsZC5cbiAgICBjaGlsZE93bmVyID0gXCIgSXQgd2FzIHBhc3NlZCBhIGNoaWxkIGZyb20gXCIgKyBnZXRDb21wb25lbnROYW1lKGVsZW1lbnQuX293bmVyLnR5cGUpICsgXCIuXCI7XG4gIH1cblxuICB7XG4gICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShlbGVtZW50KTtcblxuICAgIGVycm9yKCdFYWNoIGNoaWxkIGluIGEgbGlzdCBzaG91bGQgaGF2ZSBhIHVuaXF1ZSBcImtleVwiIHByb3AuJyArICclcyVzIFNlZSBodHRwczovL3JlYWN0anMub3JnL2xpbmsvd2FybmluZy1rZXlzIGZvciBtb3JlIGluZm9ybWF0aW9uLicsIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8sIGNoaWxkT3duZXIpO1xuXG4gICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShudWxsKTtcbiAgfVxufVxuLyoqXG4gKiBFbnN1cmUgdGhhdCBldmVyeSBlbGVtZW50IGVpdGhlciBpcyBwYXNzZWQgaW4gYSBzdGF0aWMgbG9jYXRpb24sIGluIGFuXG4gKiBhcnJheSB3aXRoIGFuIGV4cGxpY2l0IGtleXMgcHJvcGVydHkgZGVmaW5lZCwgb3IgaW4gYW4gb2JqZWN0IGxpdGVyYWxcbiAqIHdpdGggdmFsaWQga2V5IHByb3BlcnR5LlxuICpcbiAqIEBpbnRlcm5hbFxuICogQHBhcmFtIHtSZWFjdE5vZGV9IG5vZGUgU3RhdGljYWxseSBwYXNzZWQgY2hpbGQgb2YgYW55IHR5cGUuXG4gKiBAcGFyYW0geyp9IHBhcmVudFR5cGUgbm9kZSdzIHBhcmVudCdzIHR5cGUuXG4gKi9cblxuXG5mdW5jdGlvbiB2YWxpZGF0ZUNoaWxkS2V5cyhub2RlLCBwYXJlbnRUeXBlKSB7XG4gIGlmICh0eXBlb2Ygbm9kZSAhPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoQXJyYXkuaXNBcnJheShub2RlKSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZS5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGNoaWxkID0gbm9kZVtpXTtcblxuICAgICAgaWYgKGlzVmFsaWRFbGVtZW50KGNoaWxkKSkge1xuICAgICAgICB2YWxpZGF0ZUV4cGxpY2l0S2V5KGNoaWxkLCBwYXJlbnRUeXBlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNWYWxpZEVsZW1lbnQobm9kZSkpIHtcbiAgICAvLyBUaGlzIGVsZW1lbnQgd2FzIHBhc3NlZCBpbiBhIHZhbGlkIGxvY2F0aW9uLlxuICAgIGlmIChub2RlLl9zdG9yZSkge1xuICAgICAgbm9kZS5fc3RvcmUudmFsaWRhdGVkID0gdHJ1ZTtcbiAgICB9XG4gIH0gZWxzZSBpZiAobm9kZSkge1xuICAgIHZhciBpdGVyYXRvckZuID0gZ2V0SXRlcmF0b3JGbihub2RlKTtcblxuICAgIGlmICh0eXBlb2YgaXRlcmF0b3JGbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgLy8gRW50cnkgaXRlcmF0b3JzIHVzZWQgdG8gcHJvdmlkZSBpbXBsaWNpdCBrZXlzLFxuICAgICAgLy8gYnV0IG5vdyB3ZSBwcmludCBhIHNlcGFyYXRlIHdhcm5pbmcgZm9yIHRoZW0gbGF0ZXIuXG4gICAgICBpZiAoaXRlcmF0b3JGbiAhPT0gbm9kZS5lbnRyaWVzKSB7XG4gICAgICAgIHZhciBpdGVyYXRvciA9IGl0ZXJhdG9yRm4uY2FsbChub2RlKTtcbiAgICAgICAgdmFyIHN0ZXA7XG5cbiAgICAgICAgd2hpbGUgKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xuICAgICAgICAgIGlmIChpc1ZhbGlkRWxlbWVudChzdGVwLnZhbHVlKSkge1xuICAgICAgICAgICAgdmFsaWRhdGVFeHBsaWNpdEtleShzdGVwLnZhbHVlLCBwYXJlbnRUeXBlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbi8qKlxuICogR2l2ZW4gYW4gZWxlbWVudCwgdmFsaWRhdGUgdGhhdCBpdHMgcHJvcHMgZm9sbG93IHRoZSBwcm9wVHlwZXMgZGVmaW5pdGlvbixcbiAqIHByb3ZpZGVkIGJ5IHRoZSB0eXBlLlxuICpcbiAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBlbGVtZW50XG4gKi9cblxuXG5mdW5jdGlvbiB2YWxpZGF0ZVByb3BUeXBlcyhlbGVtZW50KSB7XG4gIHtcbiAgICB2YXIgdHlwZSA9IGVsZW1lbnQudHlwZTtcblxuICAgIGlmICh0eXBlID09PSBudWxsIHx8IHR5cGUgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgcHJvcFR5cGVzO1xuXG4gICAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBwcm9wVHlwZXMgPSB0eXBlLnByb3BUeXBlcztcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JyAmJiAodHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSB8fCAvLyBOb3RlOiBNZW1vIG9ubHkgY2hlY2tzIG91dGVyIHByb3BzIGhlcmUuXG4gICAgLy8gSW5uZXIgcHJvcHMgYXJlIGNoZWNrZWQgaW4gdGhlIHJlY29uY2lsZXIuXG4gICAgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTUVNT19UWVBFKSkge1xuICAgICAgcHJvcFR5cGVzID0gdHlwZS5wcm9wVHlwZXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAocHJvcFR5cGVzKSB7XG4gICAgICAvLyBJbnRlbnRpb25hbGx5IGluc2lkZSB0byBhdm9pZCB0cmlnZ2VyaW5nIGxhenkgaW5pdGlhbGl6ZXJzOlxuICAgICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lKHR5cGUpO1xuICAgICAgY2hlY2tQcm9wVHlwZXMocHJvcFR5cGVzLCBlbGVtZW50LnByb3BzLCAncHJvcCcsIG5hbWUsIGVsZW1lbnQpO1xuICAgIH0gZWxzZSBpZiAodHlwZS5Qcm9wVHlwZXMgIT09IHVuZGVmaW5lZCAmJiAhcHJvcFR5cGVzTWlzc3BlbGxXYXJuaW5nU2hvd24pIHtcbiAgICAgIHByb3BUeXBlc01pc3NwZWxsV2FybmluZ1Nob3duID0gdHJ1ZTsgLy8gSW50ZW50aW9uYWxseSBpbnNpZGUgdG8gYXZvaWQgdHJpZ2dlcmluZyBsYXp5IGluaXRpYWxpemVyczpcblxuICAgICAgdmFyIF9uYW1lID0gZ2V0Q29tcG9uZW50TmFtZSh0eXBlKTtcblxuICAgICAgZXJyb3IoJ0NvbXBvbmVudCAlcyBkZWNsYXJlZCBgUHJvcFR5cGVzYCBpbnN0ZWFkIG9mIGBwcm9wVHlwZXNgLiBEaWQgeW91IG1pc3NwZWxsIHRoZSBwcm9wZXJ0eSBhc3NpZ25tZW50PycsIF9uYW1lIHx8ICdVbmtub3duJyk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiB0eXBlLmdldERlZmF1bHRQcm9wcyA9PT0gJ2Z1bmN0aW9uJyAmJiAhdHlwZS5nZXREZWZhdWx0UHJvcHMuaXNSZWFjdENsYXNzQXBwcm92ZWQpIHtcbiAgICAgIGVycm9yKCdnZXREZWZhdWx0UHJvcHMgaXMgb25seSB1c2VkIG9uIGNsYXNzaWMgUmVhY3QuY3JlYXRlQ2xhc3MgJyArICdkZWZpbml0aW9ucy4gVXNlIGEgc3RhdGljIHByb3BlcnR5IG5hbWVkIGBkZWZhdWx0UHJvcHNgIGluc3RlYWQuJyk7XG4gICAgfVxuICB9XG59XG4vKipcbiAqIEdpdmVuIGEgZnJhZ21lbnQsIHZhbGlkYXRlIHRoYXQgaXQgY2FuIG9ubHkgYmUgcHJvdmlkZWQgd2l0aCBmcmFnbWVudCBwcm9wc1xuICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGZyYWdtZW50XG4gKi9cblxuXG5mdW5jdGlvbiB2YWxpZGF0ZUZyYWdtZW50UHJvcHMoZnJhZ21lbnQpIHtcbiAge1xuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoZnJhZ21lbnQucHJvcHMpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIga2V5ID0ga2V5c1tpXTtcblxuICAgICAgaWYgKGtleSAhPT0gJ2NoaWxkcmVuJyAmJiBrZXkgIT09ICdrZXknKSB7XG4gICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEoZnJhZ21lbnQpO1xuXG4gICAgICAgIGVycm9yKCdJbnZhbGlkIHByb3AgYCVzYCBzdXBwbGllZCB0byBgUmVhY3QuRnJhZ21lbnRgLiAnICsgJ1JlYWN0LkZyYWdtZW50IGNhbiBvbmx5IGhhdmUgYGtleWAgYW5kIGBjaGlsZHJlbmAgcHJvcHMuJywga2V5KTtcblxuICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKG51bGwpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZnJhZ21lbnQucmVmICE9PSBudWxsKSB7XG4gICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKGZyYWdtZW50KTtcblxuICAgICAgZXJyb3IoJ0ludmFsaWQgYXR0cmlidXRlIGByZWZgIHN1cHBsaWVkIHRvIGBSZWFjdC5GcmFnbWVudGAuJyk7XG5cbiAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEobnVsbCk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBjcmVhdGVFbGVtZW50V2l0aFZhbGlkYXRpb24odHlwZSwgcHJvcHMsIGNoaWxkcmVuKSB7XG4gIHZhciB2YWxpZFR5cGUgPSBpc1ZhbGlkRWxlbWVudFR5cGUodHlwZSk7IC8vIFdlIHdhcm4gaW4gdGhpcyBjYXNlIGJ1dCBkb24ndCB0aHJvdy4gV2UgZXhwZWN0IHRoZSBlbGVtZW50IGNyZWF0aW9uIHRvXG4gIC8vIHN1Y2NlZWQgYW5kIHRoZXJlIHdpbGwgbGlrZWx5IGJlIGVycm9ycyBpbiByZW5kZXIuXG5cbiAgaWYgKCF2YWxpZFR5cGUpIHtcbiAgICB2YXIgaW5mbyA9ICcnO1xuXG4gICAgaWYgKHR5cGUgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgdHlwZSAhPT0gbnVsbCAmJiBPYmplY3Qua2V5cyh0eXBlKS5sZW5ndGggPT09IDApIHtcbiAgICAgIGluZm8gKz0gJyBZb3UgbGlrZWx5IGZvcmdvdCB0byBleHBvcnQgeW91ciBjb21wb25lbnQgZnJvbSB0aGUgZmlsZSAnICsgXCJpdCdzIGRlZmluZWQgaW4sIG9yIHlvdSBtaWdodCBoYXZlIG1peGVkIHVwIGRlZmF1bHQgYW5kIG5hbWVkIGltcG9ydHMuXCI7XG4gICAgfVxuXG4gICAgdmFyIHNvdXJjZUluZm8gPSBnZXRTb3VyY2VJbmZvRXJyb3JBZGRlbmR1bUZvclByb3BzKHByb3BzKTtcblxuICAgIGlmIChzb3VyY2VJbmZvKSB7XG4gICAgICBpbmZvICs9IHNvdXJjZUluZm87XG4gICAgfSBlbHNlIHtcbiAgICAgIGluZm8gKz0gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKCk7XG4gICAgfVxuXG4gICAgdmFyIHR5cGVTdHJpbmc7XG5cbiAgICBpZiAodHlwZSA9PT0gbnVsbCkge1xuICAgICAgdHlwZVN0cmluZyA9ICdudWxsJztcbiAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodHlwZSkpIHtcbiAgICAgIHR5cGVTdHJpbmcgPSAnYXJyYXknO1xuICAgIH0gZWxzZSBpZiAodHlwZSAhPT0gdW5kZWZpbmVkICYmIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRSkge1xuICAgICAgdHlwZVN0cmluZyA9IFwiPFwiICsgKGdldENvbXBvbmVudE5hbWUodHlwZS50eXBlKSB8fCAnVW5rbm93bicpICsgXCIgLz5cIjtcbiAgICAgIGluZm8gPSAnIERpZCB5b3UgYWNjaWRlbnRhbGx5IGV4cG9ydCBhIEpTWCBsaXRlcmFsIGluc3RlYWQgb2YgYSBjb21wb25lbnQ/JztcbiAgICB9IGVsc2Uge1xuICAgICAgdHlwZVN0cmluZyA9IHR5cGVvZiB0eXBlO1xuICAgIH1cblxuICAgIHtcbiAgICAgIGVycm9yKCdSZWFjdC5jcmVhdGVFbGVtZW50OiB0eXBlIGlzIGludmFsaWQgLS0gZXhwZWN0ZWQgYSBzdHJpbmcgKGZvciAnICsgJ2J1aWx0LWluIGNvbXBvbmVudHMpIG9yIGEgY2xhc3MvZnVuY3Rpb24gKGZvciBjb21wb3NpdGUgJyArICdjb21wb25lbnRzKSBidXQgZ290OiAlcy4lcycsIHR5cGVTdHJpbmcsIGluZm8pO1xuICAgIH1cbiAgfVxuXG4gIHZhciBlbGVtZW50ID0gY3JlYXRlRWxlbWVudC5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyAvLyBUaGUgcmVzdWx0IGNhbiBiZSBudWxsaXNoIGlmIGEgbW9jayBvciBhIGN1c3RvbSBmdW5jdGlvbiBpcyB1c2VkLlxuICAvLyBUT0RPOiBEcm9wIHRoaXMgd2hlbiB0aGVzZSBhcmUgbm8gbG9uZ2VyIGFsbG93ZWQgYXMgdGhlIHR5cGUgYXJndW1lbnQuXG5cbiAgaWYgKGVsZW1lbnQgPT0gbnVsbCkge1xuICAgIHJldHVybiBlbGVtZW50O1xuICB9IC8vIFNraXAga2V5IHdhcm5pbmcgaWYgdGhlIHR5cGUgaXNuJ3QgdmFsaWQgc2luY2Ugb3VyIGtleSB2YWxpZGF0aW9uIGxvZ2ljXG4gIC8vIGRvZXNuJ3QgZXhwZWN0IGEgbm9uLXN0cmluZy9mdW5jdGlvbiB0eXBlIGFuZCBjYW4gdGhyb3cgY29uZnVzaW5nIGVycm9ycy5cbiAgLy8gV2UgZG9uJ3Qgd2FudCBleGNlcHRpb24gYmVoYXZpb3IgdG8gZGlmZmVyIGJldHdlZW4gZGV2IGFuZCBwcm9kLlxuICAvLyAoUmVuZGVyaW5nIHdpbGwgdGhyb3cgd2l0aCBhIGhlbHBmdWwgbWVzc2FnZSBhbmQgYXMgc29vbiBhcyB0aGUgdHlwZSBpc1xuICAvLyBmaXhlZCwgdGhlIGtleSB3YXJuaW5ncyB3aWxsIGFwcGVhci4pXG5cblxuICBpZiAodmFsaWRUeXBlKSB7XG4gICAgZm9yICh2YXIgaSA9IDI7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhbGlkYXRlQ2hpbGRLZXlzKGFyZ3VtZW50c1tpXSwgdHlwZSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHR5cGUgPT09IGV4cG9ydHMuRnJhZ21lbnQpIHtcbiAgICB2YWxpZGF0ZUZyYWdtZW50UHJvcHMoZWxlbWVudCk7XG4gIH0gZWxzZSB7XG4gICAgdmFsaWRhdGVQcm9wVHlwZXMoZWxlbWVudCk7XG4gIH1cblxuICByZXR1cm4gZWxlbWVudDtcbn1cbnZhciBkaWRXYXJuQWJvdXREZXByZWNhdGVkQ3JlYXRlRmFjdG9yeSA9IGZhbHNlO1xuZnVuY3Rpb24gY3JlYXRlRmFjdG9yeVdpdGhWYWxpZGF0aW9uKHR5cGUpIHtcbiAgdmFyIHZhbGlkYXRlZEZhY3RvcnkgPSBjcmVhdGVFbGVtZW50V2l0aFZhbGlkYXRpb24uYmluZChudWxsLCB0eXBlKTtcbiAgdmFsaWRhdGVkRmFjdG9yeS50eXBlID0gdHlwZTtcblxuICB7XG4gICAgaWYgKCFkaWRXYXJuQWJvdXREZXByZWNhdGVkQ3JlYXRlRmFjdG9yeSkge1xuICAgICAgZGlkV2FybkFib3V0RGVwcmVjYXRlZENyZWF0ZUZhY3RvcnkgPSB0cnVlO1xuXG4gICAgICB3YXJuKCdSZWFjdC5jcmVhdGVGYWN0b3J5KCkgaXMgZGVwcmVjYXRlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluICcgKyAnYSBmdXR1cmUgbWFqb3IgcmVsZWFzZS4gQ29uc2lkZXIgdXNpbmcgSlNYICcgKyAnb3IgdXNlIFJlYWN0LmNyZWF0ZUVsZW1lbnQoKSBkaXJlY3RseSBpbnN0ZWFkLicpO1xuICAgIH0gLy8gTGVnYWN5IGhvb2s6IHJlbW92ZSBpdFxuXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodmFsaWRhdGVkRmFjdG9yeSwgJ3R5cGUnLCB7XG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICB3YXJuKCdGYWN0b3J5LnR5cGUgaXMgZGVwcmVjYXRlZC4gQWNjZXNzIHRoZSBjbGFzcyBkaXJlY3RseSAnICsgJ2JlZm9yZSBwYXNzaW5nIGl0IHRvIGNyZWF0ZUZhY3RvcnkuJyk7XG5cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICd0eXBlJywge1xuICAgICAgICAgIHZhbHVlOiB0eXBlXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdHlwZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiB2YWxpZGF0ZWRGYWN0b3J5O1xufVxuZnVuY3Rpb24gY2xvbmVFbGVtZW50V2l0aFZhbGlkYXRpb24oZWxlbWVudCwgcHJvcHMsIGNoaWxkcmVuKSB7XG4gIHZhciBuZXdFbGVtZW50ID0gY2xvbmVFbGVtZW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgZm9yICh2YXIgaSA9IDI7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YWxpZGF0ZUNoaWxkS2V5cyhhcmd1bWVudHNbaV0sIG5ld0VsZW1lbnQudHlwZSk7XG4gIH1cblxuICB2YWxpZGF0ZVByb3BUeXBlcyhuZXdFbGVtZW50KTtcbiAgcmV0dXJuIG5ld0VsZW1lbnQ7XG59XG5cbntcblxuICB0cnkge1xuICAgIHZhciBmcm96ZW5PYmplY3QgPSBPYmplY3QuZnJlZXplKHt9KTtcbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1uZXcgKi9cblxuICAgIG5ldyBNYXAoW1tmcm96ZW5PYmplY3QsIG51bGxdXSk7XG4gICAgbmV3IFNldChbZnJvemVuT2JqZWN0XSk7XG4gICAgLyogZXNsaW50LWVuYWJsZSBuby1uZXcgKi9cbiAgfSBjYXRjaCAoZSkge1xuICB9XG59XG5cbnZhciBjcmVhdGVFbGVtZW50JDEgPSAgY3JlYXRlRWxlbWVudFdpdGhWYWxpZGF0aW9uIDtcbnZhciBjbG9uZUVsZW1lbnQkMSA9ICBjbG9uZUVsZW1lbnRXaXRoVmFsaWRhdGlvbiA7XG52YXIgY3JlYXRlRmFjdG9yeSA9ICBjcmVhdGVGYWN0b3J5V2l0aFZhbGlkYXRpb24gO1xudmFyIENoaWxkcmVuID0ge1xuICBtYXA6IG1hcENoaWxkcmVuLFxuICBmb3JFYWNoOiBmb3JFYWNoQ2hpbGRyZW4sXG4gIGNvdW50OiBjb3VudENoaWxkcmVuLFxuICB0b0FycmF5OiB0b0FycmF5LFxuICBvbmx5OiBvbmx5Q2hpbGRcbn07XG5cbmV4cG9ydHMuQ2hpbGRyZW4gPSBDaGlsZHJlbjtcbmV4cG9ydHMuQ29tcG9uZW50ID0gQ29tcG9uZW50O1xuZXhwb3J0cy5QdXJlQ29tcG9uZW50ID0gUHVyZUNvbXBvbmVudDtcbmV4cG9ydHMuX19TRUNSRVRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfRklSRUQgPSBSZWFjdFNoYXJlZEludGVybmFscztcbmV4cG9ydHMuY2xvbmVFbGVtZW50ID0gY2xvbmVFbGVtZW50JDE7XG5leHBvcnRzLmNyZWF0ZUNvbnRleHQgPSBjcmVhdGVDb250ZXh0O1xuZXhwb3J0cy5jcmVhdGVFbGVtZW50ID0gY3JlYXRlRWxlbWVudCQxO1xuZXhwb3J0cy5jcmVhdGVGYWN0b3J5ID0gY3JlYXRlRmFjdG9yeTtcbmV4cG9ydHMuY3JlYXRlUmVmID0gY3JlYXRlUmVmO1xuZXhwb3J0cy5mb3J3YXJkUmVmID0gZm9yd2FyZFJlZjtcbmV4cG9ydHMuaXNWYWxpZEVsZW1lbnQgPSBpc1ZhbGlkRWxlbWVudDtcbmV4cG9ydHMubGF6eSA9IGxhenk7XG5leHBvcnRzLm1lbW8gPSBtZW1vO1xuZXhwb3J0cy51c2VDYWxsYmFjayA9IHVzZUNhbGxiYWNrO1xuZXhwb3J0cy51c2VDb250ZXh0ID0gdXNlQ29udGV4dDtcbmV4cG9ydHMudXNlRGVidWdWYWx1ZSA9IHVzZURlYnVnVmFsdWU7XG5leHBvcnRzLnVzZUVmZmVjdCA9IHVzZUVmZmVjdDtcbmV4cG9ydHMudXNlSW1wZXJhdGl2ZUhhbmRsZSA9IHVzZUltcGVyYXRpdmVIYW5kbGU7XG5leHBvcnRzLnVzZUxheW91dEVmZmVjdCA9IHVzZUxheW91dEVmZmVjdDtcbmV4cG9ydHMudXNlTWVtbyA9IHVzZU1lbW87XG5leHBvcnRzLnVzZVJlZHVjZXIgPSB1c2VSZWR1Y2VyO1xuZXhwb3J0cy51c2VSZWYgPSB1c2VSZWY7XG5leHBvcnRzLnVzZVN0YXRlID0gdXNlU3RhdGU7XG5leHBvcnRzLnZlcnNpb24gPSBSZWFjdFZlcnNpb247XG4gIH0pKCk7XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QucHJvZHVjdGlvbi5taW4uanMnKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QuZGV2ZWxvcG1lbnQuanMnKTtcbn1cbiIsIi8qKiBAbGljZW5zZSBSZWFjdCB2MC4yMC4yXG4gKiBzY2hlZHVsZXItdHJhY2luZy5kZXZlbG9wbWVudC5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAoZnVuY3Rpb24oKSB7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBERUZBVUxUX1RIUkVBRF9JRCA9IDA7IC8vIENvdW50ZXJzIHVzZWQgdG8gZ2VuZXJhdGUgdW5pcXVlIElEcy5cblxudmFyIGludGVyYWN0aW9uSURDb3VudGVyID0gMDtcbnZhciB0aHJlYWRJRENvdW50ZXIgPSAwOyAvLyBTZXQgb2YgY3VycmVudGx5IHRyYWNlZCBpbnRlcmFjdGlvbnMuXG4vLyBJbnRlcmFjdGlvbnMgXCJzdGFja1wi4oCTXG4vLyBNZWFuaW5nIHRoYXQgbmV3bHkgdHJhY2VkIGludGVyYWN0aW9ucyBhcmUgYXBwZW5kZWQgdG8gdGhlIHByZXZpb3VzbHkgYWN0aXZlIHNldC5cbi8vIFdoZW4gYW4gaW50ZXJhY3Rpb24gZ29lcyBvdXQgb2Ygc2NvcGUsIHRoZSBwcmV2aW91cyBzZXQgKGlmIGFueSkgaXMgcmVzdG9yZWQuXG5cbmV4cG9ydHMuX19pbnRlcmFjdGlvbnNSZWYgPSBudWxsOyAvLyBMaXN0ZW5lcihzKSB0byBub3RpZnkgd2hlbiBpbnRlcmFjdGlvbnMgYmVnaW4gYW5kIGVuZC5cblxuZXhwb3J0cy5fX3N1YnNjcmliZXJSZWYgPSBudWxsO1xuXG57XG4gIGV4cG9ydHMuX19pbnRlcmFjdGlvbnNSZWYgPSB7XG4gICAgY3VycmVudDogbmV3IFNldCgpXG4gIH07XG4gIGV4cG9ydHMuX19zdWJzY3JpYmVyUmVmID0ge1xuICAgIGN1cnJlbnQ6IG51bGxcbiAgfTtcbn1cbmZ1bmN0aW9uIHVuc3RhYmxlX2NsZWFyKGNhbGxiYWNrKSB7XG5cbiAgdmFyIHByZXZJbnRlcmFjdGlvbnMgPSBleHBvcnRzLl9faW50ZXJhY3Rpb25zUmVmLmN1cnJlbnQ7XG4gIGV4cG9ydHMuX19pbnRlcmFjdGlvbnNSZWYuY3VycmVudCA9IG5ldyBTZXQoKTtcblxuICB0cnkge1xuICAgIHJldHVybiBjYWxsYmFjaygpO1xuICB9IGZpbmFsbHkge1xuICAgIGV4cG9ydHMuX19pbnRlcmFjdGlvbnNSZWYuY3VycmVudCA9IHByZXZJbnRlcmFjdGlvbnM7XG4gIH1cbn1cbmZ1bmN0aW9uIHVuc3RhYmxlX2dldEN1cnJlbnQoKSB7XG4gIHtcbiAgICByZXR1cm4gZXhwb3J0cy5fX2ludGVyYWN0aW9uc1JlZi5jdXJyZW50O1xuICB9XG59XG5mdW5jdGlvbiB1bnN0YWJsZV9nZXRUaHJlYWRJRCgpIHtcbiAgcmV0dXJuICsrdGhyZWFkSURDb3VudGVyO1xufVxuZnVuY3Rpb24gdW5zdGFibGVfdHJhY2UobmFtZSwgdGltZXN0YW1wLCBjYWxsYmFjaykge1xuICB2YXIgdGhyZWFkSUQgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IERFRkFVTFRfVEhSRUFEX0lEO1xuXG4gIHZhciBpbnRlcmFjdGlvbiA9IHtcbiAgICBfX2NvdW50OiAxLFxuICAgIGlkOiBpbnRlcmFjdGlvbklEQ291bnRlcisrLFxuICAgIG5hbWU6IG5hbWUsXG4gICAgdGltZXN0YW1wOiB0aW1lc3RhbXBcbiAgfTtcbiAgdmFyIHByZXZJbnRlcmFjdGlvbnMgPSBleHBvcnRzLl9faW50ZXJhY3Rpb25zUmVmLmN1cnJlbnQ7IC8vIFRyYWNlZCBpbnRlcmFjdGlvbnMgc2hvdWxkIHN0YWNrL2FjY3VtdWxhdGUuXG4gIC8vIFRvIGRvIHRoYXQsIGNsb25lIHRoZSBjdXJyZW50IGludGVyYWN0aW9ucy5cbiAgLy8gVGhlIHByZXZpb3VzIHNldCB3aWxsIGJlIHJlc3RvcmVkIHVwb24gY29tcGxldGlvbi5cblxuICB2YXIgaW50ZXJhY3Rpb25zID0gbmV3IFNldChwcmV2SW50ZXJhY3Rpb25zKTtcbiAgaW50ZXJhY3Rpb25zLmFkZChpbnRlcmFjdGlvbik7XG4gIGV4cG9ydHMuX19pbnRlcmFjdGlvbnNSZWYuY3VycmVudCA9IGludGVyYWN0aW9ucztcbiAgdmFyIHN1YnNjcmliZXIgPSBleHBvcnRzLl9fc3Vic2NyaWJlclJlZi5jdXJyZW50O1xuICB2YXIgcmV0dXJuVmFsdWU7XG5cbiAgdHJ5IHtcbiAgICBpZiAoc3Vic2NyaWJlciAhPT0gbnVsbCkge1xuICAgICAgc3Vic2NyaWJlci5vbkludGVyYWN0aW9uVHJhY2VkKGludGVyYWN0aW9uKTtcbiAgICB9XG4gIH0gZmluYWxseSB7XG4gICAgdHJ5IHtcbiAgICAgIGlmIChzdWJzY3JpYmVyICE9PSBudWxsKSB7XG4gICAgICAgIHN1YnNjcmliZXIub25Xb3JrU3RhcnRlZChpbnRlcmFjdGlvbnMsIHRocmVhZElEKTtcbiAgICAgIH1cbiAgICB9IGZpbmFsbHkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuVmFsdWUgPSBjYWxsYmFjaygpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgZXhwb3J0cy5fX2ludGVyYWN0aW9uc1JlZi5jdXJyZW50ID0gcHJldkludGVyYWN0aW9ucztcblxuICAgICAgICB0cnkge1xuICAgICAgICAgIGlmIChzdWJzY3JpYmVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICBzdWJzY3JpYmVyLm9uV29ya1N0b3BwZWQoaW50ZXJhY3Rpb25zLCB0aHJlYWRJRCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIGludGVyYWN0aW9uLl9fY291bnQtLTsgLy8gSWYgbm8gYXN5bmMgd29yayB3YXMgc2NoZWR1bGVkIGZvciB0aGlzIGludGVyYWN0aW9uLFxuICAgICAgICAgIC8vIE5vdGlmeSBzdWJzY3JpYmVycyB0aGF0IGl0J3MgY29tcGxldGVkLlxuXG4gICAgICAgICAgaWYgKHN1YnNjcmliZXIgIT09IG51bGwgJiYgaW50ZXJhY3Rpb24uX19jb3VudCA9PT0gMCkge1xuICAgICAgICAgICAgc3Vic2NyaWJlci5vbkludGVyYWN0aW9uU2NoZWR1bGVkV29ya0NvbXBsZXRlZChpbnRlcmFjdGlvbik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJldHVyblZhbHVlO1xufVxuZnVuY3Rpb24gdW5zdGFibGVfd3JhcChjYWxsYmFjaykge1xuICB2YXIgdGhyZWFkSUQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IERFRkFVTFRfVEhSRUFEX0lEO1xuXG4gIHZhciB3cmFwcGVkSW50ZXJhY3Rpb25zID0gZXhwb3J0cy5fX2ludGVyYWN0aW9uc1JlZi5jdXJyZW50O1xuICB2YXIgc3Vic2NyaWJlciA9IGV4cG9ydHMuX19zdWJzY3JpYmVyUmVmLmN1cnJlbnQ7XG5cbiAgaWYgKHN1YnNjcmliZXIgIT09IG51bGwpIHtcbiAgICBzdWJzY3JpYmVyLm9uV29ya1NjaGVkdWxlZCh3cmFwcGVkSW50ZXJhY3Rpb25zLCB0aHJlYWRJRCk7XG4gIH0gLy8gVXBkYXRlIHRoZSBwZW5kaW5nIGFzeW5jIHdvcmsgY291bnQgZm9yIHRoZSBjdXJyZW50IGludGVyYWN0aW9ucy5cbiAgLy8gVXBkYXRlIGFmdGVyIGNhbGxpbmcgc3Vic2NyaWJlcnMgaW4gY2FzZSBvZiBlcnJvci5cblxuXG4gIHdyYXBwZWRJbnRlcmFjdGlvbnMuZm9yRWFjaChmdW5jdGlvbiAoaW50ZXJhY3Rpb24pIHtcbiAgICBpbnRlcmFjdGlvbi5fX2NvdW50Kys7XG4gIH0pO1xuICB2YXIgaGFzUnVuID0gZmFsc2U7XG5cbiAgZnVuY3Rpb24gd3JhcHBlZCgpIHtcbiAgICB2YXIgcHJldkludGVyYWN0aW9ucyA9IGV4cG9ydHMuX19pbnRlcmFjdGlvbnNSZWYuY3VycmVudDtcbiAgICBleHBvcnRzLl9faW50ZXJhY3Rpb25zUmVmLmN1cnJlbnQgPSB3cmFwcGVkSW50ZXJhY3Rpb25zO1xuICAgIHN1YnNjcmliZXIgPSBleHBvcnRzLl9fc3Vic2NyaWJlclJlZi5jdXJyZW50O1xuXG4gICAgdHJ5IHtcbiAgICAgIHZhciByZXR1cm5WYWx1ZTtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKHN1YnNjcmliZXIgIT09IG51bGwpIHtcbiAgICAgICAgICBzdWJzY3JpYmVyLm9uV29ya1N0YXJ0ZWQod3JhcHBlZEludGVyYWN0aW9ucywgdGhyZWFkSUQpO1xuICAgICAgICB9XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVyblZhbHVlID0gY2FsbGJhY2suYXBwbHkodW5kZWZpbmVkLCBhcmd1bWVudHMpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIGV4cG9ydHMuX19pbnRlcmFjdGlvbnNSZWYuY3VycmVudCA9IHByZXZJbnRlcmFjdGlvbnM7XG5cbiAgICAgICAgICBpZiAoc3Vic2NyaWJlciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgc3Vic2NyaWJlci5vbldvcmtTdG9wcGVkKHdyYXBwZWRJbnRlcmFjdGlvbnMsIHRocmVhZElEKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJldHVyblZhbHVlO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBpZiAoIWhhc1J1bikge1xuICAgICAgICAvLyBXZSBvbmx5IGV4cGVjdCBhIHdyYXBwZWQgZnVuY3Rpb24gdG8gYmUgZXhlY3V0ZWQgb25jZSxcbiAgICAgICAgLy8gQnV0IGluIHRoZSBldmVudCB0aGF0IGl0J3MgZXhlY3V0ZWQgbW9yZSB0aGFuIG9uY2XigJNcbiAgICAgICAgLy8gT25seSBkZWNyZW1lbnQgdGhlIG91dHN0YW5kaW5nIGludGVyYWN0aW9uIGNvdW50cyBvbmNlLlxuICAgICAgICBoYXNSdW4gPSB0cnVlOyAvLyBVcGRhdGUgcGVuZGluZyBhc3luYyBjb3VudHMgZm9yIGFsbCB3cmFwcGVkIGludGVyYWN0aW9ucy5cbiAgICAgICAgLy8gSWYgdGhpcyB3YXMgdGhlIGxhc3Qgc2NoZWR1bGVkIGFzeW5jIHdvcmsgZm9yIGFueSBvZiB0aGVtLFxuICAgICAgICAvLyBNYXJrIHRoZW0gYXMgY29tcGxldGVkLlxuXG4gICAgICAgIHdyYXBwZWRJbnRlcmFjdGlvbnMuZm9yRWFjaChmdW5jdGlvbiAoaW50ZXJhY3Rpb24pIHtcbiAgICAgICAgICBpbnRlcmFjdGlvbi5fX2NvdW50LS07XG5cbiAgICAgICAgICBpZiAoc3Vic2NyaWJlciAhPT0gbnVsbCAmJiBpbnRlcmFjdGlvbi5fX2NvdW50ID09PSAwKSB7XG4gICAgICAgICAgICBzdWJzY3JpYmVyLm9uSW50ZXJhY3Rpb25TY2hlZHVsZWRXb3JrQ29tcGxldGVkKGludGVyYWN0aW9uKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHdyYXBwZWQuY2FuY2VsID0gZnVuY3Rpb24gY2FuY2VsKCkge1xuICAgIHN1YnNjcmliZXIgPSBleHBvcnRzLl9fc3Vic2NyaWJlclJlZi5jdXJyZW50O1xuXG4gICAgdHJ5IHtcbiAgICAgIGlmIChzdWJzY3JpYmVyICE9PSBudWxsKSB7XG4gICAgICAgIHN1YnNjcmliZXIub25Xb3JrQ2FuY2VsZWQod3JhcHBlZEludGVyYWN0aW9ucywgdGhyZWFkSUQpO1xuICAgICAgfVxuICAgIH0gZmluYWxseSB7XG4gICAgICAvLyBVcGRhdGUgcGVuZGluZyBhc3luYyBjb3VudHMgZm9yIGFsbCB3cmFwcGVkIGludGVyYWN0aW9ucy5cbiAgICAgIC8vIElmIHRoaXMgd2FzIHRoZSBsYXN0IHNjaGVkdWxlZCBhc3luYyB3b3JrIGZvciBhbnkgb2YgdGhlbSxcbiAgICAgIC8vIE1hcmsgdGhlbSBhcyBjb21wbGV0ZWQuXG4gICAgICB3cmFwcGVkSW50ZXJhY3Rpb25zLmZvckVhY2goZnVuY3Rpb24gKGludGVyYWN0aW9uKSB7XG4gICAgICAgIGludGVyYWN0aW9uLl9fY291bnQtLTtcblxuICAgICAgICBpZiAoc3Vic2NyaWJlciAmJiBpbnRlcmFjdGlvbi5fX2NvdW50ID09PSAwKSB7XG4gICAgICAgICAgc3Vic2NyaWJlci5vbkludGVyYWN0aW9uU2NoZWR1bGVkV29ya0NvbXBsZXRlZChpbnRlcmFjdGlvbik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gd3JhcHBlZDtcbn1cblxudmFyIHN1YnNjcmliZXJzID0gbnVsbDtcblxue1xuICBzdWJzY3JpYmVycyA9IG5ldyBTZXQoKTtcbn1cblxuZnVuY3Rpb24gdW5zdGFibGVfc3Vic2NyaWJlKHN1YnNjcmliZXIpIHtcbiAge1xuICAgIHN1YnNjcmliZXJzLmFkZChzdWJzY3JpYmVyKTtcblxuICAgIGlmIChzdWJzY3JpYmVycy5zaXplID09PSAxKSB7XG4gICAgICBleHBvcnRzLl9fc3Vic2NyaWJlclJlZi5jdXJyZW50ID0ge1xuICAgICAgICBvbkludGVyYWN0aW9uU2NoZWR1bGVkV29ya0NvbXBsZXRlZDogb25JbnRlcmFjdGlvblNjaGVkdWxlZFdvcmtDb21wbGV0ZWQsXG4gICAgICAgIG9uSW50ZXJhY3Rpb25UcmFjZWQ6IG9uSW50ZXJhY3Rpb25UcmFjZWQsXG4gICAgICAgIG9uV29ya0NhbmNlbGVkOiBvbldvcmtDYW5jZWxlZCxcbiAgICAgICAgb25Xb3JrU2NoZWR1bGVkOiBvbldvcmtTY2hlZHVsZWQsXG4gICAgICAgIG9uV29ya1N0YXJ0ZWQ6IG9uV29ya1N0YXJ0ZWQsXG4gICAgICAgIG9uV29ya1N0b3BwZWQ6IG9uV29ya1N0b3BwZWRcbiAgICAgIH07XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiB1bnN0YWJsZV91bnN1YnNjcmliZShzdWJzY3JpYmVyKSB7XG4gIHtcbiAgICBzdWJzY3JpYmVycy5kZWxldGUoc3Vic2NyaWJlcik7XG5cbiAgICBpZiAoc3Vic2NyaWJlcnMuc2l6ZSA9PT0gMCkge1xuICAgICAgZXhwb3J0cy5fX3N1YnNjcmliZXJSZWYuY3VycmVudCA9IG51bGw7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIG9uSW50ZXJhY3Rpb25UcmFjZWQoaW50ZXJhY3Rpb24pIHtcbiAgdmFyIGRpZENhdGNoRXJyb3IgPSBmYWxzZTtcbiAgdmFyIGNhdWdodEVycm9yID0gbnVsbDtcbiAgc3Vic2NyaWJlcnMuZm9yRWFjaChmdW5jdGlvbiAoc3Vic2NyaWJlcikge1xuICAgIHRyeSB7XG4gICAgICBzdWJzY3JpYmVyLm9uSW50ZXJhY3Rpb25UcmFjZWQoaW50ZXJhY3Rpb24pO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpZiAoIWRpZENhdGNoRXJyb3IpIHtcbiAgICAgICAgZGlkQ2F0Y2hFcnJvciA9IHRydWU7XG4gICAgICAgIGNhdWdodEVycm9yID0gZXJyb3I7XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICBpZiAoZGlkQ2F0Y2hFcnJvcikge1xuICAgIHRocm93IGNhdWdodEVycm9yO1xuICB9XG59XG5cbmZ1bmN0aW9uIG9uSW50ZXJhY3Rpb25TY2hlZHVsZWRXb3JrQ29tcGxldGVkKGludGVyYWN0aW9uKSB7XG4gIHZhciBkaWRDYXRjaEVycm9yID0gZmFsc2U7XG4gIHZhciBjYXVnaHRFcnJvciA9IG51bGw7XG4gIHN1YnNjcmliZXJzLmZvckVhY2goZnVuY3Rpb24gKHN1YnNjcmliZXIpIHtcbiAgICB0cnkge1xuICAgICAgc3Vic2NyaWJlci5vbkludGVyYWN0aW9uU2NoZWR1bGVkV29ya0NvbXBsZXRlZChpbnRlcmFjdGlvbik7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmICghZGlkQ2F0Y2hFcnJvcikge1xuICAgICAgICBkaWRDYXRjaEVycm9yID0gdHJ1ZTtcbiAgICAgICAgY2F1Z2h0RXJyb3IgPSBlcnJvcjtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIGlmIChkaWRDYXRjaEVycm9yKSB7XG4gICAgdGhyb3cgY2F1Z2h0RXJyb3I7XG4gIH1cbn1cblxuZnVuY3Rpb24gb25Xb3JrU2NoZWR1bGVkKGludGVyYWN0aW9ucywgdGhyZWFkSUQpIHtcbiAgdmFyIGRpZENhdGNoRXJyb3IgPSBmYWxzZTtcbiAgdmFyIGNhdWdodEVycm9yID0gbnVsbDtcbiAgc3Vic2NyaWJlcnMuZm9yRWFjaChmdW5jdGlvbiAoc3Vic2NyaWJlcikge1xuICAgIHRyeSB7XG4gICAgICBzdWJzY3JpYmVyLm9uV29ya1NjaGVkdWxlZChpbnRlcmFjdGlvbnMsIHRocmVhZElEKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKCFkaWRDYXRjaEVycm9yKSB7XG4gICAgICAgIGRpZENhdGNoRXJyb3IgPSB0cnVlO1xuICAgICAgICBjYXVnaHRFcnJvciA9IGVycm9yO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG5cbiAgaWYgKGRpZENhdGNoRXJyb3IpIHtcbiAgICB0aHJvdyBjYXVnaHRFcnJvcjtcbiAgfVxufVxuXG5mdW5jdGlvbiBvbldvcmtTdGFydGVkKGludGVyYWN0aW9ucywgdGhyZWFkSUQpIHtcbiAgdmFyIGRpZENhdGNoRXJyb3IgPSBmYWxzZTtcbiAgdmFyIGNhdWdodEVycm9yID0gbnVsbDtcbiAgc3Vic2NyaWJlcnMuZm9yRWFjaChmdW5jdGlvbiAoc3Vic2NyaWJlcikge1xuICAgIHRyeSB7XG4gICAgICBzdWJzY3JpYmVyLm9uV29ya1N0YXJ0ZWQoaW50ZXJhY3Rpb25zLCB0aHJlYWRJRCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmICghZGlkQ2F0Y2hFcnJvcikge1xuICAgICAgICBkaWRDYXRjaEVycm9yID0gdHJ1ZTtcbiAgICAgICAgY2F1Z2h0RXJyb3IgPSBlcnJvcjtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIGlmIChkaWRDYXRjaEVycm9yKSB7XG4gICAgdGhyb3cgY2F1Z2h0RXJyb3I7XG4gIH1cbn1cblxuZnVuY3Rpb24gb25Xb3JrU3RvcHBlZChpbnRlcmFjdGlvbnMsIHRocmVhZElEKSB7XG4gIHZhciBkaWRDYXRjaEVycm9yID0gZmFsc2U7XG4gIHZhciBjYXVnaHRFcnJvciA9IG51bGw7XG4gIHN1YnNjcmliZXJzLmZvckVhY2goZnVuY3Rpb24gKHN1YnNjcmliZXIpIHtcbiAgICB0cnkge1xuICAgICAgc3Vic2NyaWJlci5vbldvcmtTdG9wcGVkKGludGVyYWN0aW9ucywgdGhyZWFkSUQpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpZiAoIWRpZENhdGNoRXJyb3IpIHtcbiAgICAgICAgZGlkQ2F0Y2hFcnJvciA9IHRydWU7XG4gICAgICAgIGNhdWdodEVycm9yID0gZXJyb3I7XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICBpZiAoZGlkQ2F0Y2hFcnJvcikge1xuICAgIHRocm93IGNhdWdodEVycm9yO1xuICB9XG59XG5cbmZ1bmN0aW9uIG9uV29ya0NhbmNlbGVkKGludGVyYWN0aW9ucywgdGhyZWFkSUQpIHtcbiAgdmFyIGRpZENhdGNoRXJyb3IgPSBmYWxzZTtcbiAgdmFyIGNhdWdodEVycm9yID0gbnVsbDtcbiAgc3Vic2NyaWJlcnMuZm9yRWFjaChmdW5jdGlvbiAoc3Vic2NyaWJlcikge1xuICAgIHRyeSB7XG4gICAgICBzdWJzY3JpYmVyLm9uV29ya0NhbmNlbGVkKGludGVyYWN0aW9ucywgdGhyZWFkSUQpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpZiAoIWRpZENhdGNoRXJyb3IpIHtcbiAgICAgICAgZGlkQ2F0Y2hFcnJvciA9IHRydWU7XG4gICAgICAgIGNhdWdodEVycm9yID0gZXJyb3I7XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICBpZiAoZGlkQ2F0Y2hFcnJvcikge1xuICAgIHRocm93IGNhdWdodEVycm9yO1xuICB9XG59XG5cbmV4cG9ydHMudW5zdGFibGVfY2xlYXIgPSB1bnN0YWJsZV9jbGVhcjtcbmV4cG9ydHMudW5zdGFibGVfZ2V0Q3VycmVudCA9IHVuc3RhYmxlX2dldEN1cnJlbnQ7XG5leHBvcnRzLnVuc3RhYmxlX2dldFRocmVhZElEID0gdW5zdGFibGVfZ2V0VGhyZWFkSUQ7XG5leHBvcnRzLnVuc3RhYmxlX3N1YnNjcmliZSA9IHVuc3RhYmxlX3N1YnNjcmliZTtcbmV4cG9ydHMudW5zdGFibGVfdHJhY2UgPSB1bnN0YWJsZV90cmFjZTtcbmV4cG9ydHMudW5zdGFibGVfdW5zdWJzY3JpYmUgPSB1bnN0YWJsZV91bnN1YnNjcmliZTtcbmV4cG9ydHMudW5zdGFibGVfd3JhcCA9IHVuc3RhYmxlX3dyYXA7XG4gIH0pKCk7XG59XG4iLCIvKiogQGxpY2Vuc2UgUmVhY3QgdjAuMjAuMlxuICogc2NoZWR1bGVyLmRldmVsb3BtZW50LmpzXG4gKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gIChmdW5jdGlvbigpIHtcbid1c2Ugc3RyaWN0JztcblxudmFyIGVuYWJsZVNjaGVkdWxlckRlYnVnZ2luZyA9IGZhbHNlO1xudmFyIGVuYWJsZVByb2ZpbGluZyA9IGZhbHNlO1xuXG52YXIgcmVxdWVzdEhvc3RDYWxsYmFjaztcbnZhciByZXF1ZXN0SG9zdFRpbWVvdXQ7XG52YXIgY2FuY2VsSG9zdFRpbWVvdXQ7XG52YXIgcmVxdWVzdFBhaW50O1xudmFyIGhhc1BlcmZvcm1hbmNlTm93ID0gdHlwZW9mIHBlcmZvcm1hbmNlID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgcGVyZm9ybWFuY2Uubm93ID09PSAnZnVuY3Rpb24nO1xuXG5pZiAoaGFzUGVyZm9ybWFuY2VOb3cpIHtcbiAgdmFyIGxvY2FsUGVyZm9ybWFuY2UgPSBwZXJmb3JtYW5jZTtcblxuICBleHBvcnRzLnVuc3RhYmxlX25vdyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gbG9jYWxQZXJmb3JtYW5jZS5ub3coKTtcbiAgfTtcbn0gZWxzZSB7XG4gIHZhciBsb2NhbERhdGUgPSBEYXRlO1xuICB2YXIgaW5pdGlhbFRpbWUgPSBsb2NhbERhdGUubm93KCk7XG5cbiAgZXhwb3J0cy51bnN0YWJsZV9ub3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGxvY2FsRGF0ZS5ub3coKSAtIGluaXRpYWxUaW1lO1xuICB9O1xufVxuXG5pZiAoIC8vIElmIFNjaGVkdWxlciBydW5zIGluIGEgbm9uLURPTSBlbnZpcm9ubWVudCwgaXQgZmFsbHMgYmFjayB0byBhIG5haXZlXG4vLyBpbXBsZW1lbnRhdGlvbiB1c2luZyBzZXRUaW1lb3V0LlxudHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgfHwgLy8gQ2hlY2sgaWYgTWVzc2FnZUNoYW5uZWwgaXMgc3VwcG9ydGVkLCB0b28uXG50eXBlb2YgTWVzc2FnZUNoYW5uZWwgIT09ICdmdW5jdGlvbicpIHtcbiAgLy8gSWYgdGhpcyBhY2NpZGVudGFsbHkgZ2V0cyBpbXBvcnRlZCBpbiBhIG5vbi1icm93c2VyIGVudmlyb25tZW50LCBlLmcuIEphdmFTY3JpcHRDb3JlLFxuICAvLyBmYWxsYmFjayB0byBhIG5haXZlIGltcGxlbWVudGF0aW9uLlxuICB2YXIgX2NhbGxiYWNrID0gbnVsbDtcbiAgdmFyIF90aW1lb3V0SUQgPSBudWxsO1xuXG4gIHZhciBfZmx1c2hDYWxsYmFjayA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoX2NhbGxiYWNrICE9PSBudWxsKSB7XG4gICAgICB0cnkge1xuICAgICAgICB2YXIgY3VycmVudFRpbWUgPSBleHBvcnRzLnVuc3RhYmxlX25vdygpO1xuICAgICAgICB2YXIgaGFzUmVtYWluaW5nVGltZSA9IHRydWU7XG5cbiAgICAgICAgX2NhbGxiYWNrKGhhc1JlbWFpbmluZ1RpbWUsIGN1cnJlbnRUaW1lKTtcblxuICAgICAgICBfY2FsbGJhY2sgPSBudWxsO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBzZXRUaW1lb3V0KF9mbHVzaENhbGxiYWNrLCAwKTtcbiAgICAgICAgdGhyb3cgZTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgcmVxdWVzdEhvc3RDYWxsYmFjayA9IGZ1bmN0aW9uIChjYikge1xuICAgIGlmIChfY2FsbGJhY2sgIT09IG51bGwpIHtcbiAgICAgIC8vIFByb3RlY3QgYWdhaW5zdCByZS1lbnRyYW5jeS5cbiAgICAgIHNldFRpbWVvdXQocmVxdWVzdEhvc3RDYWxsYmFjaywgMCwgY2IpO1xuICAgIH0gZWxzZSB7XG4gICAgICBfY2FsbGJhY2sgPSBjYjtcbiAgICAgIHNldFRpbWVvdXQoX2ZsdXNoQ2FsbGJhY2ssIDApO1xuICAgIH1cbiAgfTtcblxuICByZXF1ZXN0SG9zdFRpbWVvdXQgPSBmdW5jdGlvbiAoY2IsIG1zKSB7XG4gICAgX3RpbWVvdXRJRCA9IHNldFRpbWVvdXQoY2IsIG1zKTtcbiAgfTtcblxuICBjYW5jZWxIb3N0VGltZW91dCA9IGZ1bmN0aW9uICgpIHtcbiAgICBjbGVhclRpbWVvdXQoX3RpbWVvdXRJRCk7XG4gIH07XG5cbiAgZXhwb3J0cy51bnN0YWJsZV9zaG91bGRZaWVsZCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG5cbiAgcmVxdWVzdFBhaW50ID0gZXhwb3J0cy51bnN0YWJsZV9mb3JjZUZyYW1lUmF0ZSA9IGZ1bmN0aW9uICgpIHt9O1xufSBlbHNlIHtcbiAgLy8gQ2FwdHVyZSBsb2NhbCByZWZlcmVuY2VzIHRvIG5hdGl2ZSBBUElzLCBpbiBjYXNlIGEgcG9seWZpbGwgb3ZlcnJpZGVzIHRoZW0uXG4gIHZhciBfc2V0VGltZW91dCA9IHdpbmRvdy5zZXRUaW1lb3V0O1xuICB2YXIgX2NsZWFyVGltZW91dCA9IHdpbmRvdy5jbGVhclRpbWVvdXQ7XG5cbiAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJykge1xuICAgIC8vIFRPRE86IFNjaGVkdWxlciBubyBsb25nZXIgcmVxdWlyZXMgdGhlc2UgbWV0aG9kcyB0byBiZSBwb2x5ZmlsbGVkLiBCdXRcbiAgICAvLyBtYXliZSB3ZSB3YW50IHRvIGNvbnRpbnVlIHdhcm5pbmcgaWYgdGhleSBkb24ndCBleGlzdCwgdG8gcHJlc2VydmUgdGhlXG4gICAgLy8gb3B0aW9uIHRvIHJlbHkgb24gaXQgaW4gdGhlIGZ1dHVyZT9cbiAgICB2YXIgcmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZTtcbiAgICB2YXIgY2FuY2VsQW5pbWF0aW9uRnJhbWUgPSB3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWU7XG5cbiAgICBpZiAodHlwZW9mIHJlcXVlc3RBbmltYXRpb25GcmFtZSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgLy8gVXNpbmcgY29uc29sZVsnZXJyb3InXSB0byBldmFkZSBCYWJlbCBhbmQgRVNMaW50XG4gICAgICBjb25zb2xlWydlcnJvciddKFwiVGhpcyBicm93c2VyIGRvZXNuJ3Qgc3VwcG9ydCByZXF1ZXN0QW5pbWF0aW9uRnJhbWUuIFwiICsgJ01ha2Ugc3VyZSB0aGF0IHlvdSBsb2FkIGEgJyArICdwb2x5ZmlsbCBpbiBvbGRlciBicm93c2Vycy4gaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3JlYWN0LXBvbHlmaWxscycpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgY2FuY2VsQW5pbWF0aW9uRnJhbWUgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIC8vIFVzaW5nIGNvbnNvbGVbJ2Vycm9yJ10gdG8gZXZhZGUgQmFiZWwgYW5kIEVTTGludFxuICAgICAgY29uc29sZVsnZXJyb3InXShcIlRoaXMgYnJvd3NlciBkb2Vzbid0IHN1cHBvcnQgY2FuY2VsQW5pbWF0aW9uRnJhbWUuIFwiICsgJ01ha2Ugc3VyZSB0aGF0IHlvdSBsb2FkIGEgJyArICdwb2x5ZmlsbCBpbiBvbGRlciBicm93c2Vycy4gaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3JlYWN0LXBvbHlmaWxscycpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBpc01lc3NhZ2VMb29wUnVubmluZyA9IGZhbHNlO1xuICB2YXIgc2NoZWR1bGVkSG9zdENhbGxiYWNrID0gbnVsbDtcbiAgdmFyIHRhc2tUaW1lb3V0SUQgPSAtMTsgLy8gU2NoZWR1bGVyIHBlcmlvZGljYWxseSB5aWVsZHMgaW4gY2FzZSB0aGVyZSBpcyBvdGhlciB3b3JrIG9uIHRoZSBtYWluXG4gIC8vIHRocmVhZCwgbGlrZSB1c2VyIGV2ZW50cy4gQnkgZGVmYXVsdCwgaXQgeWllbGRzIG11bHRpcGxlIHRpbWVzIHBlciBmcmFtZS5cbiAgLy8gSXQgZG9lcyBub3QgYXR0ZW1wdCB0byBhbGlnbiB3aXRoIGZyYW1lIGJvdW5kYXJpZXMsIHNpbmNlIG1vc3QgdGFza3MgZG9uJ3RcbiAgLy8gbmVlZCB0byBiZSBmcmFtZSBhbGlnbmVkOyBmb3IgdGhvc2UgdGhhdCBkbywgdXNlIHJlcXVlc3RBbmltYXRpb25GcmFtZS5cblxuICB2YXIgeWllbGRJbnRlcnZhbCA9IDU7XG4gIHZhciBkZWFkbGluZSA9IDA7IC8vIFRPRE86IE1ha2UgdGhpcyBjb25maWd1cmFibGVcblxuICB7XG4gICAgLy8gYGlzSW5wdXRQZW5kaW5nYCBpcyBub3QgYXZhaWxhYmxlLiBTaW5jZSB3ZSBoYXZlIG5vIHdheSBvZiBrbm93aW5nIGlmXG4gICAgLy8gdGhlcmUncyBwZW5kaW5nIGlucHV0LCBhbHdheXMgeWllbGQgYXQgdGhlIGVuZCBvZiB0aGUgZnJhbWUuXG4gICAgZXhwb3J0cy51bnN0YWJsZV9zaG91bGRZaWVsZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBleHBvcnRzLnVuc3RhYmxlX25vdygpID49IGRlYWRsaW5lO1xuICAgIH07IC8vIFNpbmNlIHdlIHlpZWxkIGV2ZXJ5IGZyYW1lIHJlZ2FyZGxlc3MsIGByZXF1ZXN0UGFpbnRgIGhhcyBubyBlZmZlY3QuXG5cblxuICAgIHJlcXVlc3RQYWludCA9IGZ1bmN0aW9uICgpIHt9O1xuICB9XG5cbiAgZXhwb3J0cy51bnN0YWJsZV9mb3JjZUZyYW1lUmF0ZSA9IGZ1bmN0aW9uIChmcHMpIHtcbiAgICBpZiAoZnBzIDwgMCB8fCBmcHMgPiAxMjUpIHtcbiAgICAgIC8vIFVzaW5nIGNvbnNvbGVbJ2Vycm9yJ10gdG8gZXZhZGUgQmFiZWwgYW5kIEVTTGludFxuICAgICAgY29uc29sZVsnZXJyb3InXSgnZm9yY2VGcmFtZVJhdGUgdGFrZXMgYSBwb3NpdGl2ZSBpbnQgYmV0d2VlbiAwIGFuZCAxMjUsICcgKyAnZm9yY2luZyBmcmFtZSByYXRlcyBoaWdoZXIgdGhhbiAxMjUgZnBzIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoZnBzID4gMCkge1xuICAgICAgeWllbGRJbnRlcnZhbCA9IE1hdGguZmxvb3IoMTAwMCAvIGZwcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHJlc2V0IHRoZSBmcmFtZXJhdGVcbiAgICAgIHlpZWxkSW50ZXJ2YWwgPSA1O1xuICAgIH1cbiAgfTtcblxuICB2YXIgcGVyZm9ybVdvcmtVbnRpbERlYWRsaW5lID0gZnVuY3Rpb24gKCkge1xuICAgIGlmIChzY2hlZHVsZWRIb3N0Q2FsbGJhY2sgIT09IG51bGwpIHtcbiAgICAgIHZhciBjdXJyZW50VGltZSA9IGV4cG9ydHMudW5zdGFibGVfbm93KCk7IC8vIFlpZWxkIGFmdGVyIGB5aWVsZEludGVydmFsYCBtcywgcmVnYXJkbGVzcyBvZiB3aGVyZSB3ZSBhcmUgaW4gdGhlIHZzeW5jXG4gICAgICAvLyBjeWNsZS4gVGhpcyBtZWFucyB0aGVyZSdzIGFsd2F5cyB0aW1lIHJlbWFpbmluZyBhdCB0aGUgYmVnaW5uaW5nIG9mXG4gICAgICAvLyB0aGUgbWVzc2FnZSBldmVudC5cblxuICAgICAgZGVhZGxpbmUgPSBjdXJyZW50VGltZSArIHlpZWxkSW50ZXJ2YWw7XG4gICAgICB2YXIgaGFzVGltZVJlbWFpbmluZyA9IHRydWU7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciBoYXNNb3JlV29yayA9IHNjaGVkdWxlZEhvc3RDYWxsYmFjayhoYXNUaW1lUmVtYWluaW5nLCBjdXJyZW50VGltZSk7XG5cbiAgICAgICAgaWYgKCFoYXNNb3JlV29yaykge1xuICAgICAgICAgIGlzTWVzc2FnZUxvb3BSdW5uaW5nID0gZmFsc2U7XG4gICAgICAgICAgc2NoZWR1bGVkSG9zdENhbGxiYWNrID0gbnVsbDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBJZiB0aGVyZSdzIG1vcmUgd29yaywgc2NoZWR1bGUgdGhlIG5leHQgbWVzc2FnZSBldmVudCBhdCB0aGUgZW5kXG4gICAgICAgICAgLy8gb2YgdGhlIHByZWNlZGluZyBvbmUuXG4gICAgICAgICAgcG9ydC5wb3N0TWVzc2FnZShudWxsKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgLy8gSWYgYSBzY2hlZHVsZXIgdGFzayB0aHJvd3MsIGV4aXQgdGhlIGN1cnJlbnQgYnJvd3NlciB0YXNrIHNvIHRoZVxuICAgICAgICAvLyBlcnJvciBjYW4gYmUgb2JzZXJ2ZWQuXG4gICAgICAgIHBvcnQucG9zdE1lc3NhZ2UobnVsbCk7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpc01lc3NhZ2VMb29wUnVubmluZyA9IGZhbHNlO1xuICAgIH0gLy8gWWllbGRpbmcgdG8gdGhlIGJyb3dzZXIgd2lsbCBnaXZlIGl0IGEgY2hhbmNlIHRvIHBhaW50LCBzbyB3ZSBjYW5cbiAgfTtcblxuICB2YXIgY2hhbm5lbCA9IG5ldyBNZXNzYWdlQ2hhbm5lbCgpO1xuICB2YXIgcG9ydCA9IGNoYW5uZWwucG9ydDI7XG4gIGNoYW5uZWwucG9ydDEub25tZXNzYWdlID0gcGVyZm9ybVdvcmtVbnRpbERlYWRsaW5lO1xuXG4gIHJlcXVlc3RIb3N0Q2FsbGJhY2sgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICBzY2hlZHVsZWRIb3N0Q2FsbGJhY2sgPSBjYWxsYmFjaztcblxuICAgIGlmICghaXNNZXNzYWdlTG9vcFJ1bm5pbmcpIHtcbiAgICAgIGlzTWVzc2FnZUxvb3BSdW5uaW5nID0gdHJ1ZTtcbiAgICAgIHBvcnQucG9zdE1lc3NhZ2UobnVsbCk7XG4gICAgfVxuICB9O1xuXG4gIHJlcXVlc3RIb3N0VGltZW91dCA9IGZ1bmN0aW9uIChjYWxsYmFjaywgbXMpIHtcbiAgICB0YXNrVGltZW91dElEID0gX3NldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgY2FsbGJhY2soZXhwb3J0cy51bnN0YWJsZV9ub3coKSk7XG4gICAgfSwgbXMpO1xuICB9O1xuXG4gIGNhbmNlbEhvc3RUaW1lb3V0ID0gZnVuY3Rpb24gKCkge1xuICAgIF9jbGVhclRpbWVvdXQodGFza1RpbWVvdXRJRCk7XG5cbiAgICB0YXNrVGltZW91dElEID0gLTE7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHB1c2goaGVhcCwgbm9kZSkge1xuICB2YXIgaW5kZXggPSBoZWFwLmxlbmd0aDtcbiAgaGVhcC5wdXNoKG5vZGUpO1xuICBzaWZ0VXAoaGVhcCwgbm9kZSwgaW5kZXgpO1xufVxuZnVuY3Rpb24gcGVlayhoZWFwKSB7XG4gIHZhciBmaXJzdCA9IGhlYXBbMF07XG4gIHJldHVybiBmaXJzdCA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGZpcnN0O1xufVxuZnVuY3Rpb24gcG9wKGhlYXApIHtcbiAgdmFyIGZpcnN0ID0gaGVhcFswXTtcblxuICBpZiAoZmlyc3QgIT09IHVuZGVmaW5lZCkge1xuICAgIHZhciBsYXN0ID0gaGVhcC5wb3AoKTtcblxuICAgIGlmIChsYXN0ICE9PSBmaXJzdCkge1xuICAgICAgaGVhcFswXSA9IGxhc3Q7XG4gICAgICBzaWZ0RG93bihoZWFwLCBsYXN0LCAwKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmlyc3Q7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuZnVuY3Rpb24gc2lmdFVwKGhlYXAsIG5vZGUsIGkpIHtcbiAgdmFyIGluZGV4ID0gaTtcblxuICB3aGlsZSAodHJ1ZSkge1xuICAgIHZhciBwYXJlbnRJbmRleCA9IGluZGV4IC0gMSA+Pj4gMTtcbiAgICB2YXIgcGFyZW50ID0gaGVhcFtwYXJlbnRJbmRleF07XG5cbiAgICBpZiAocGFyZW50ICE9PSB1bmRlZmluZWQgJiYgY29tcGFyZShwYXJlbnQsIG5vZGUpID4gMCkge1xuICAgICAgLy8gVGhlIHBhcmVudCBpcyBsYXJnZXIuIFN3YXAgcG9zaXRpb25zLlxuICAgICAgaGVhcFtwYXJlbnRJbmRleF0gPSBub2RlO1xuICAgICAgaGVhcFtpbmRleF0gPSBwYXJlbnQ7XG4gICAgICBpbmRleCA9IHBhcmVudEluZGV4O1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUaGUgcGFyZW50IGlzIHNtYWxsZXIuIEV4aXQuXG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHNpZnREb3duKGhlYXAsIG5vZGUsIGkpIHtcbiAgdmFyIGluZGV4ID0gaTtcbiAgdmFyIGxlbmd0aCA9IGhlYXAubGVuZ3RoO1xuXG4gIHdoaWxlIChpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBsZWZ0SW5kZXggPSAoaW5kZXggKyAxKSAqIDIgLSAxO1xuICAgIHZhciBsZWZ0ID0gaGVhcFtsZWZ0SW5kZXhdO1xuICAgIHZhciByaWdodEluZGV4ID0gbGVmdEluZGV4ICsgMTtcbiAgICB2YXIgcmlnaHQgPSBoZWFwW3JpZ2h0SW5kZXhdOyAvLyBJZiB0aGUgbGVmdCBvciByaWdodCBub2RlIGlzIHNtYWxsZXIsIHN3YXAgd2l0aCB0aGUgc21hbGxlciBvZiB0aG9zZS5cblxuICAgIGlmIChsZWZ0ICE9PSB1bmRlZmluZWQgJiYgY29tcGFyZShsZWZ0LCBub2RlKSA8IDApIHtcbiAgICAgIGlmIChyaWdodCAhPT0gdW5kZWZpbmVkICYmIGNvbXBhcmUocmlnaHQsIGxlZnQpIDwgMCkge1xuICAgICAgICBoZWFwW2luZGV4XSA9IHJpZ2h0O1xuICAgICAgICBoZWFwW3JpZ2h0SW5kZXhdID0gbm9kZTtcbiAgICAgICAgaW5kZXggPSByaWdodEluZGV4O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaGVhcFtpbmRleF0gPSBsZWZ0O1xuICAgICAgICBoZWFwW2xlZnRJbmRleF0gPSBub2RlO1xuICAgICAgICBpbmRleCA9IGxlZnRJbmRleDtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHJpZ2h0ICE9PSB1bmRlZmluZWQgJiYgY29tcGFyZShyaWdodCwgbm9kZSkgPCAwKSB7XG4gICAgICBoZWFwW2luZGV4XSA9IHJpZ2h0O1xuICAgICAgaGVhcFtyaWdodEluZGV4XSA9IG5vZGU7XG4gICAgICBpbmRleCA9IHJpZ2h0SW5kZXg7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIE5laXRoZXIgY2hpbGQgaXMgc21hbGxlci4gRXhpdC5cbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY29tcGFyZShhLCBiKSB7XG4gIC8vIENvbXBhcmUgc29ydCBpbmRleCBmaXJzdCwgdGhlbiB0YXNrIGlkLlxuICB2YXIgZGlmZiA9IGEuc29ydEluZGV4IC0gYi5zb3J0SW5kZXg7XG4gIHJldHVybiBkaWZmICE9PSAwID8gZGlmZiA6IGEuaWQgLSBiLmlkO1xufVxuXG4vLyBUT0RPOiBVc2Ugc3ltYm9scz9cbnZhciBJbW1lZGlhdGVQcmlvcml0eSA9IDE7XG52YXIgVXNlckJsb2NraW5nUHJpb3JpdHkgPSAyO1xudmFyIE5vcm1hbFByaW9yaXR5ID0gMztcbnZhciBMb3dQcmlvcml0eSA9IDQ7XG52YXIgSWRsZVByaW9yaXR5ID0gNTtcblxuZnVuY3Rpb24gbWFya1Rhc2tFcnJvcmVkKHRhc2ssIG1zKSB7XG59XG5cbi8qIGVzbGludC1kaXNhYmxlIG5vLXZhciAqL1xuLy8gTWF0aC5wb3coMiwgMzApIC0gMVxuLy8gMGIxMTExMTExMTExMTExMTExMTExMTExMTExMTExMTFcblxudmFyIG1heFNpZ25lZDMxQml0SW50ID0gMTA3Mzc0MTgyMzsgLy8gVGltZXMgb3V0IGltbWVkaWF0ZWx5XG5cbnZhciBJTU1FRElBVEVfUFJJT1JJVFlfVElNRU9VVCA9IC0xOyAvLyBFdmVudHVhbGx5IHRpbWVzIG91dFxuXG52YXIgVVNFUl9CTE9DS0lOR19QUklPUklUWV9USU1FT1VUID0gMjUwO1xudmFyIE5PUk1BTF9QUklPUklUWV9USU1FT1VUID0gNTAwMDtcbnZhciBMT1dfUFJJT1JJVFlfVElNRU9VVCA9IDEwMDAwOyAvLyBOZXZlciB0aW1lcyBvdXRcblxudmFyIElETEVfUFJJT1JJVFlfVElNRU9VVCA9IG1heFNpZ25lZDMxQml0SW50OyAvLyBUYXNrcyBhcmUgc3RvcmVkIG9uIGEgbWluIGhlYXBcblxudmFyIHRhc2tRdWV1ZSA9IFtdO1xudmFyIHRpbWVyUXVldWUgPSBbXTsgLy8gSW5jcmVtZW50aW5nIGlkIGNvdW50ZXIuIFVzZWQgdG8gbWFpbnRhaW4gaW5zZXJ0aW9uIG9yZGVyLlxuXG52YXIgdGFza0lkQ291bnRlciA9IDE7IC8vIFBhdXNpbmcgdGhlIHNjaGVkdWxlciBpcyB1c2VmdWwgZm9yIGRlYnVnZ2luZy5cbnZhciBjdXJyZW50VGFzayA9IG51bGw7XG52YXIgY3VycmVudFByaW9yaXR5TGV2ZWwgPSBOb3JtYWxQcmlvcml0eTsgLy8gVGhpcyBpcyBzZXQgd2hpbGUgcGVyZm9ybWluZyB3b3JrLCB0byBwcmV2ZW50IHJlLWVudHJhbmN5LlxuXG52YXIgaXNQZXJmb3JtaW5nV29yayA9IGZhbHNlO1xudmFyIGlzSG9zdENhbGxiYWNrU2NoZWR1bGVkID0gZmFsc2U7XG52YXIgaXNIb3N0VGltZW91dFNjaGVkdWxlZCA9IGZhbHNlO1xuXG5mdW5jdGlvbiBhZHZhbmNlVGltZXJzKGN1cnJlbnRUaW1lKSB7XG4gIC8vIENoZWNrIGZvciB0YXNrcyB0aGF0IGFyZSBubyBsb25nZXIgZGVsYXllZCBhbmQgYWRkIHRoZW0gdG8gdGhlIHF1ZXVlLlxuICB2YXIgdGltZXIgPSBwZWVrKHRpbWVyUXVldWUpO1xuXG4gIHdoaWxlICh0aW1lciAhPT0gbnVsbCkge1xuICAgIGlmICh0aW1lci5jYWxsYmFjayA9PT0gbnVsbCkge1xuICAgICAgLy8gVGltZXIgd2FzIGNhbmNlbGxlZC5cbiAgICAgIHBvcCh0aW1lclF1ZXVlKTtcbiAgICB9IGVsc2UgaWYgKHRpbWVyLnN0YXJ0VGltZSA8PSBjdXJyZW50VGltZSkge1xuICAgICAgLy8gVGltZXIgZmlyZWQuIFRyYW5zZmVyIHRvIHRoZSB0YXNrIHF1ZXVlLlxuICAgICAgcG9wKHRpbWVyUXVldWUpO1xuICAgICAgdGltZXIuc29ydEluZGV4ID0gdGltZXIuZXhwaXJhdGlvblRpbWU7XG4gICAgICBwdXNoKHRhc2tRdWV1ZSwgdGltZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBSZW1haW5pbmcgdGltZXJzIGFyZSBwZW5kaW5nLlxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRpbWVyID0gcGVlayh0aW1lclF1ZXVlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBoYW5kbGVUaW1lb3V0KGN1cnJlbnRUaW1lKSB7XG4gIGlzSG9zdFRpbWVvdXRTY2hlZHVsZWQgPSBmYWxzZTtcbiAgYWR2YW5jZVRpbWVycyhjdXJyZW50VGltZSk7XG5cbiAgaWYgKCFpc0hvc3RDYWxsYmFja1NjaGVkdWxlZCkge1xuICAgIGlmIChwZWVrKHRhc2tRdWV1ZSkgIT09IG51bGwpIHtcbiAgICAgIGlzSG9zdENhbGxiYWNrU2NoZWR1bGVkID0gdHJ1ZTtcbiAgICAgIHJlcXVlc3RIb3N0Q2FsbGJhY2soZmx1c2hXb3JrKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGZpcnN0VGltZXIgPSBwZWVrKHRpbWVyUXVldWUpO1xuXG4gICAgICBpZiAoZmlyc3RUaW1lciAhPT0gbnVsbCkge1xuICAgICAgICByZXF1ZXN0SG9zdFRpbWVvdXQoaGFuZGxlVGltZW91dCwgZmlyc3RUaW1lci5zdGFydFRpbWUgLSBjdXJyZW50VGltZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGZsdXNoV29yayhoYXNUaW1lUmVtYWluaW5nLCBpbml0aWFsVGltZSkge1xuXG5cbiAgaXNIb3N0Q2FsbGJhY2tTY2hlZHVsZWQgPSBmYWxzZTtcblxuICBpZiAoaXNIb3N0VGltZW91dFNjaGVkdWxlZCkge1xuICAgIC8vIFdlIHNjaGVkdWxlZCBhIHRpbWVvdXQgYnV0IGl0J3Mgbm8gbG9uZ2VyIG5lZWRlZC4gQ2FuY2VsIGl0LlxuICAgIGlzSG9zdFRpbWVvdXRTY2hlZHVsZWQgPSBmYWxzZTtcbiAgICBjYW5jZWxIb3N0VGltZW91dCgpO1xuICB9XG5cbiAgaXNQZXJmb3JtaW5nV29yayA9IHRydWU7XG4gIHZhciBwcmV2aW91c1ByaW9yaXR5TGV2ZWwgPSBjdXJyZW50UHJpb3JpdHlMZXZlbDtcblxuICB0cnkge1xuICAgIGlmIChlbmFibGVQcm9maWxpbmcpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiB3b3JrTG9vcChoYXNUaW1lUmVtYWluaW5nLCBpbml0aWFsVGltZSk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBpZiAoY3VycmVudFRhc2sgIT09IG51bGwpIHtcbiAgICAgICAgICB2YXIgY3VycmVudFRpbWUgPSBleHBvcnRzLnVuc3RhYmxlX25vdygpO1xuICAgICAgICAgIG1hcmtUYXNrRXJyb3JlZChjdXJyZW50VGFzaywgY3VycmVudFRpbWUpO1xuICAgICAgICAgIGN1cnJlbnRUYXNrLmlzUXVldWVkID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gTm8gY2F0Y2ggaW4gcHJvZCBjb2RlIHBhdGguXG4gICAgICByZXR1cm4gd29ya0xvb3AoaGFzVGltZVJlbWFpbmluZywgaW5pdGlhbFRpbWUpO1xuICAgIH1cbiAgfSBmaW5hbGx5IHtcbiAgICBjdXJyZW50VGFzayA9IG51bGw7XG4gICAgY3VycmVudFByaW9yaXR5TGV2ZWwgPSBwcmV2aW91c1ByaW9yaXR5TGV2ZWw7XG4gICAgaXNQZXJmb3JtaW5nV29yayA9IGZhbHNlO1xuICB9XG59XG5cbmZ1bmN0aW9uIHdvcmtMb29wKGhhc1RpbWVSZW1haW5pbmcsIGluaXRpYWxUaW1lKSB7XG4gIHZhciBjdXJyZW50VGltZSA9IGluaXRpYWxUaW1lO1xuICBhZHZhbmNlVGltZXJzKGN1cnJlbnRUaW1lKTtcbiAgY3VycmVudFRhc2sgPSBwZWVrKHRhc2tRdWV1ZSk7XG5cbiAgd2hpbGUgKGN1cnJlbnRUYXNrICE9PSBudWxsICYmICEoZW5hYmxlU2NoZWR1bGVyRGVidWdnaW5nICkpIHtcbiAgICBpZiAoY3VycmVudFRhc2suZXhwaXJhdGlvblRpbWUgPiBjdXJyZW50VGltZSAmJiAoIWhhc1RpbWVSZW1haW5pbmcgfHwgZXhwb3J0cy51bnN0YWJsZV9zaG91bGRZaWVsZCgpKSkge1xuICAgICAgLy8gVGhpcyBjdXJyZW50VGFzayBoYXNuJ3QgZXhwaXJlZCwgYW5kIHdlJ3ZlIHJlYWNoZWQgdGhlIGRlYWRsaW5lLlxuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgdmFyIGNhbGxiYWNrID0gY3VycmVudFRhc2suY2FsbGJhY2s7XG5cbiAgICBpZiAodHlwZW9mIGNhbGxiYWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjdXJyZW50VGFzay5jYWxsYmFjayA9IG51bGw7XG4gICAgICBjdXJyZW50UHJpb3JpdHlMZXZlbCA9IGN1cnJlbnRUYXNrLnByaW9yaXR5TGV2ZWw7XG4gICAgICB2YXIgZGlkVXNlckNhbGxiYWNrVGltZW91dCA9IGN1cnJlbnRUYXNrLmV4cGlyYXRpb25UaW1lIDw9IGN1cnJlbnRUaW1lO1xuXG4gICAgICB2YXIgY29udGludWF0aW9uQ2FsbGJhY2sgPSBjYWxsYmFjayhkaWRVc2VyQ2FsbGJhY2tUaW1lb3V0KTtcbiAgICAgIGN1cnJlbnRUaW1lID0gZXhwb3J0cy51bnN0YWJsZV9ub3coKTtcblxuICAgICAgaWYgKHR5cGVvZiBjb250aW51YXRpb25DYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBjdXJyZW50VGFzay5jYWxsYmFjayA9IGNvbnRpbnVhdGlvbkNhbGxiYWNrO1xuICAgICAgfSBlbHNlIHtcblxuICAgICAgICBpZiAoY3VycmVudFRhc2sgPT09IHBlZWsodGFza1F1ZXVlKSkge1xuICAgICAgICAgIHBvcCh0YXNrUXVldWUpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGFkdmFuY2VUaW1lcnMoY3VycmVudFRpbWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwb3AodGFza1F1ZXVlKTtcbiAgICB9XG5cbiAgICBjdXJyZW50VGFzayA9IHBlZWsodGFza1F1ZXVlKTtcbiAgfSAvLyBSZXR1cm4gd2hldGhlciB0aGVyZSdzIGFkZGl0aW9uYWwgd29ya1xuXG5cbiAgaWYgKGN1cnJlbnRUYXNrICE9PSBudWxsKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGZpcnN0VGltZXIgPSBwZWVrKHRpbWVyUXVldWUpO1xuXG4gICAgaWYgKGZpcnN0VGltZXIgIT09IG51bGwpIHtcbiAgICAgIHJlcXVlc3RIb3N0VGltZW91dChoYW5kbGVUaW1lb3V0LCBmaXJzdFRpbWVyLnN0YXJ0VGltZSAtIGN1cnJlbnRUaW1lKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuZnVuY3Rpb24gdW5zdGFibGVfcnVuV2l0aFByaW9yaXR5KHByaW9yaXR5TGV2ZWwsIGV2ZW50SGFuZGxlcikge1xuICBzd2l0Y2ggKHByaW9yaXR5TGV2ZWwpIHtcbiAgICBjYXNlIEltbWVkaWF0ZVByaW9yaXR5OlxuICAgIGNhc2UgVXNlckJsb2NraW5nUHJpb3JpdHk6XG4gICAgY2FzZSBOb3JtYWxQcmlvcml0eTpcbiAgICBjYXNlIExvd1ByaW9yaXR5OlxuICAgIGNhc2UgSWRsZVByaW9yaXR5OlxuICAgICAgYnJlYWs7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgcHJpb3JpdHlMZXZlbCA9IE5vcm1hbFByaW9yaXR5O1xuICB9XG5cbiAgdmFyIHByZXZpb3VzUHJpb3JpdHlMZXZlbCA9IGN1cnJlbnRQcmlvcml0eUxldmVsO1xuICBjdXJyZW50UHJpb3JpdHlMZXZlbCA9IHByaW9yaXR5TGV2ZWw7XG5cbiAgdHJ5IHtcbiAgICByZXR1cm4gZXZlbnRIYW5kbGVyKCk7XG4gIH0gZmluYWxseSB7XG4gICAgY3VycmVudFByaW9yaXR5TGV2ZWwgPSBwcmV2aW91c1ByaW9yaXR5TGV2ZWw7XG4gIH1cbn1cblxuZnVuY3Rpb24gdW5zdGFibGVfbmV4dChldmVudEhhbmRsZXIpIHtcbiAgdmFyIHByaW9yaXR5TGV2ZWw7XG5cbiAgc3dpdGNoIChjdXJyZW50UHJpb3JpdHlMZXZlbCkge1xuICAgIGNhc2UgSW1tZWRpYXRlUHJpb3JpdHk6XG4gICAgY2FzZSBVc2VyQmxvY2tpbmdQcmlvcml0eTpcbiAgICBjYXNlIE5vcm1hbFByaW9yaXR5OlxuICAgICAgLy8gU2hpZnQgZG93biB0byBub3JtYWwgcHJpb3JpdHlcbiAgICAgIHByaW9yaXR5TGV2ZWwgPSBOb3JtYWxQcmlvcml0eTtcbiAgICAgIGJyZWFrO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIC8vIEFueXRoaW5nIGxvd2VyIHRoYW4gbm9ybWFsIHByaW9yaXR5IHNob3VsZCByZW1haW4gYXQgdGhlIGN1cnJlbnQgbGV2ZWwuXG4gICAgICBwcmlvcml0eUxldmVsID0gY3VycmVudFByaW9yaXR5TGV2ZWw7XG4gICAgICBicmVhaztcbiAgfVxuXG4gIHZhciBwcmV2aW91c1ByaW9yaXR5TGV2ZWwgPSBjdXJyZW50UHJpb3JpdHlMZXZlbDtcbiAgY3VycmVudFByaW9yaXR5TGV2ZWwgPSBwcmlvcml0eUxldmVsO1xuXG4gIHRyeSB7XG4gICAgcmV0dXJuIGV2ZW50SGFuZGxlcigpO1xuICB9IGZpbmFsbHkge1xuICAgIGN1cnJlbnRQcmlvcml0eUxldmVsID0gcHJldmlvdXNQcmlvcml0eUxldmVsO1xuICB9XG59XG5cbmZ1bmN0aW9uIHVuc3RhYmxlX3dyYXBDYWxsYmFjayhjYWxsYmFjaykge1xuICB2YXIgcGFyZW50UHJpb3JpdHlMZXZlbCA9IGN1cnJlbnRQcmlvcml0eUxldmVsO1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIC8vIFRoaXMgaXMgYSBmb3JrIG9mIHJ1bldpdGhQcmlvcml0eSwgaW5saW5lZCBmb3IgcGVyZm9ybWFuY2UuXG4gICAgdmFyIHByZXZpb3VzUHJpb3JpdHlMZXZlbCA9IGN1cnJlbnRQcmlvcml0eUxldmVsO1xuICAgIGN1cnJlbnRQcmlvcml0eUxldmVsID0gcGFyZW50UHJpb3JpdHlMZXZlbDtcblxuICAgIHRyeSB7XG4gICAgICByZXR1cm4gY2FsbGJhY2suYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgY3VycmVudFByaW9yaXR5TGV2ZWwgPSBwcmV2aW91c1ByaW9yaXR5TGV2ZWw7XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiB1bnN0YWJsZV9zY2hlZHVsZUNhbGxiYWNrKHByaW9yaXR5TGV2ZWwsIGNhbGxiYWNrLCBvcHRpb25zKSB7XG4gIHZhciBjdXJyZW50VGltZSA9IGV4cG9ydHMudW5zdGFibGVfbm93KCk7XG4gIHZhciBzdGFydFRpbWU7XG5cbiAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnb2JqZWN0JyAmJiBvcHRpb25zICE9PSBudWxsKSB7XG4gICAgdmFyIGRlbGF5ID0gb3B0aW9ucy5kZWxheTtcblxuICAgIGlmICh0eXBlb2YgZGVsYXkgPT09ICdudW1iZXInICYmIGRlbGF5ID4gMCkge1xuICAgICAgc3RhcnRUaW1lID0gY3VycmVudFRpbWUgKyBkZWxheTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhcnRUaW1lID0gY3VycmVudFRpbWU7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHN0YXJ0VGltZSA9IGN1cnJlbnRUaW1lO1xuICB9XG5cbiAgdmFyIHRpbWVvdXQ7XG5cbiAgc3dpdGNoIChwcmlvcml0eUxldmVsKSB7XG4gICAgY2FzZSBJbW1lZGlhdGVQcmlvcml0eTpcbiAgICAgIHRpbWVvdXQgPSBJTU1FRElBVEVfUFJJT1JJVFlfVElNRU9VVDtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBVc2VyQmxvY2tpbmdQcmlvcml0eTpcbiAgICAgIHRpbWVvdXQgPSBVU0VSX0JMT0NLSU5HX1BSSU9SSVRZX1RJTUVPVVQ7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgSWRsZVByaW9yaXR5OlxuICAgICAgdGltZW91dCA9IElETEVfUFJJT1JJVFlfVElNRU9VVDtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBMb3dQcmlvcml0eTpcbiAgICAgIHRpbWVvdXQgPSBMT1dfUFJJT1JJVFlfVElNRU9VVDtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBOb3JtYWxQcmlvcml0eTpcbiAgICBkZWZhdWx0OlxuICAgICAgdGltZW91dCA9IE5PUk1BTF9QUklPUklUWV9USU1FT1VUO1xuICAgICAgYnJlYWs7XG4gIH1cblxuICB2YXIgZXhwaXJhdGlvblRpbWUgPSBzdGFydFRpbWUgKyB0aW1lb3V0O1xuICB2YXIgbmV3VGFzayA9IHtcbiAgICBpZDogdGFza0lkQ291bnRlcisrLFxuICAgIGNhbGxiYWNrOiBjYWxsYmFjayxcbiAgICBwcmlvcml0eUxldmVsOiBwcmlvcml0eUxldmVsLFxuICAgIHN0YXJ0VGltZTogc3RhcnRUaW1lLFxuICAgIGV4cGlyYXRpb25UaW1lOiBleHBpcmF0aW9uVGltZSxcbiAgICBzb3J0SW5kZXg6IC0xXG4gIH07XG5cbiAgaWYgKHN0YXJ0VGltZSA+IGN1cnJlbnRUaW1lKSB7XG4gICAgLy8gVGhpcyBpcyBhIGRlbGF5ZWQgdGFzay5cbiAgICBuZXdUYXNrLnNvcnRJbmRleCA9IHN0YXJ0VGltZTtcbiAgICBwdXNoKHRpbWVyUXVldWUsIG5ld1Rhc2spO1xuXG4gICAgaWYgKHBlZWsodGFza1F1ZXVlKSA9PT0gbnVsbCAmJiBuZXdUYXNrID09PSBwZWVrKHRpbWVyUXVldWUpKSB7XG4gICAgICAvLyBBbGwgdGFza3MgYXJlIGRlbGF5ZWQsIGFuZCB0aGlzIGlzIHRoZSB0YXNrIHdpdGggdGhlIGVhcmxpZXN0IGRlbGF5LlxuICAgICAgaWYgKGlzSG9zdFRpbWVvdXRTY2hlZHVsZWQpIHtcbiAgICAgICAgLy8gQ2FuY2VsIGFuIGV4aXN0aW5nIHRpbWVvdXQuXG4gICAgICAgIGNhbmNlbEhvc3RUaW1lb3V0KCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpc0hvc3RUaW1lb3V0U2NoZWR1bGVkID0gdHJ1ZTtcbiAgICAgIH0gLy8gU2NoZWR1bGUgYSB0aW1lb3V0LlxuXG5cbiAgICAgIHJlcXVlc3RIb3N0VGltZW91dChoYW5kbGVUaW1lb3V0LCBzdGFydFRpbWUgLSBjdXJyZW50VGltZSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIG5ld1Rhc2suc29ydEluZGV4ID0gZXhwaXJhdGlvblRpbWU7XG4gICAgcHVzaCh0YXNrUXVldWUsIG5ld1Rhc2spO1xuICAgIC8vIHdhaXQgdW50aWwgdGhlIG5leHQgdGltZSB3ZSB5aWVsZC5cblxuXG4gICAgaWYgKCFpc0hvc3RDYWxsYmFja1NjaGVkdWxlZCAmJiAhaXNQZXJmb3JtaW5nV29yaykge1xuICAgICAgaXNIb3N0Q2FsbGJhY2tTY2hlZHVsZWQgPSB0cnVlO1xuICAgICAgcmVxdWVzdEhvc3RDYWxsYmFjayhmbHVzaFdvcmspO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuZXdUYXNrO1xufVxuXG5mdW5jdGlvbiB1bnN0YWJsZV9wYXVzZUV4ZWN1dGlvbigpIHtcbn1cblxuZnVuY3Rpb24gdW5zdGFibGVfY29udGludWVFeGVjdXRpb24oKSB7XG5cbiAgaWYgKCFpc0hvc3RDYWxsYmFja1NjaGVkdWxlZCAmJiAhaXNQZXJmb3JtaW5nV29yaykge1xuICAgIGlzSG9zdENhbGxiYWNrU2NoZWR1bGVkID0gdHJ1ZTtcbiAgICByZXF1ZXN0SG9zdENhbGxiYWNrKGZsdXNoV29yayk7XG4gIH1cbn1cblxuZnVuY3Rpb24gdW5zdGFibGVfZ2V0Rmlyc3RDYWxsYmFja05vZGUoKSB7XG4gIHJldHVybiBwZWVrKHRhc2tRdWV1ZSk7XG59XG5cbmZ1bmN0aW9uIHVuc3RhYmxlX2NhbmNlbENhbGxiYWNrKHRhc2spIHtcbiAgLy8gcmVtb3ZlIGZyb20gdGhlIHF1ZXVlIGJlY2F1c2UgeW91IGNhbid0IHJlbW92ZSBhcmJpdHJhcnkgbm9kZXMgZnJvbSBhblxuICAvLyBhcnJheSBiYXNlZCBoZWFwLCBvbmx5IHRoZSBmaXJzdCBvbmUuKVxuXG5cbiAgdGFzay5jYWxsYmFjayA9IG51bGw7XG59XG5cbmZ1bmN0aW9uIHVuc3RhYmxlX2dldEN1cnJlbnRQcmlvcml0eUxldmVsKCkge1xuICByZXR1cm4gY3VycmVudFByaW9yaXR5TGV2ZWw7XG59XG5cbnZhciB1bnN0YWJsZV9yZXF1ZXN0UGFpbnQgPSByZXF1ZXN0UGFpbnQ7XG52YXIgdW5zdGFibGVfUHJvZmlsaW5nID0gIG51bGw7XG5cbmV4cG9ydHMudW5zdGFibGVfSWRsZVByaW9yaXR5ID0gSWRsZVByaW9yaXR5O1xuZXhwb3J0cy51bnN0YWJsZV9JbW1lZGlhdGVQcmlvcml0eSA9IEltbWVkaWF0ZVByaW9yaXR5O1xuZXhwb3J0cy51bnN0YWJsZV9Mb3dQcmlvcml0eSA9IExvd1ByaW9yaXR5O1xuZXhwb3J0cy51bnN0YWJsZV9Ob3JtYWxQcmlvcml0eSA9IE5vcm1hbFByaW9yaXR5O1xuZXhwb3J0cy51bnN0YWJsZV9Qcm9maWxpbmcgPSB1bnN0YWJsZV9Qcm9maWxpbmc7XG5leHBvcnRzLnVuc3RhYmxlX1VzZXJCbG9ja2luZ1ByaW9yaXR5ID0gVXNlckJsb2NraW5nUHJpb3JpdHk7XG5leHBvcnRzLnVuc3RhYmxlX2NhbmNlbENhbGxiYWNrID0gdW5zdGFibGVfY2FuY2VsQ2FsbGJhY2s7XG5leHBvcnRzLnVuc3RhYmxlX2NvbnRpbnVlRXhlY3V0aW9uID0gdW5zdGFibGVfY29udGludWVFeGVjdXRpb247XG5leHBvcnRzLnVuc3RhYmxlX2dldEN1cnJlbnRQcmlvcml0eUxldmVsID0gdW5zdGFibGVfZ2V0Q3VycmVudFByaW9yaXR5TGV2ZWw7XG5leHBvcnRzLnVuc3RhYmxlX2dldEZpcnN0Q2FsbGJhY2tOb2RlID0gdW5zdGFibGVfZ2V0Rmlyc3RDYWxsYmFja05vZGU7XG5leHBvcnRzLnVuc3RhYmxlX25leHQgPSB1bnN0YWJsZV9uZXh0O1xuZXhwb3J0cy51bnN0YWJsZV9wYXVzZUV4ZWN1dGlvbiA9IHVuc3RhYmxlX3BhdXNlRXhlY3V0aW9uO1xuZXhwb3J0cy51bnN0YWJsZV9yZXF1ZXN0UGFpbnQgPSB1bnN0YWJsZV9yZXF1ZXN0UGFpbnQ7XG5leHBvcnRzLnVuc3RhYmxlX3J1bldpdGhQcmlvcml0eSA9IHVuc3RhYmxlX3J1bldpdGhQcmlvcml0eTtcbmV4cG9ydHMudW5zdGFibGVfc2NoZWR1bGVDYWxsYmFjayA9IHVuc3RhYmxlX3NjaGVkdWxlQ2FsbGJhY2s7XG5leHBvcnRzLnVuc3RhYmxlX3dyYXBDYWxsYmFjayA9IHVuc3RhYmxlX3dyYXBDYWxsYmFjaztcbiAgfSkoKTtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9zY2hlZHVsZXIucHJvZHVjdGlvbi5taW4uanMnKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvc2NoZWR1bGVyLmRldmVsb3BtZW50LmpzJyk7XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvc2NoZWR1bGVyLXRyYWNpbmcucHJvZHVjdGlvbi5taW4uanMnKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvc2NoZWR1bGVyLXRyYWNpbmcuZGV2ZWxvcG1lbnQuanMnKTtcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgaXNPbGRJRSA9IGZ1bmN0aW9uIGlzT2xkSUUoKSB7XG4gIHZhciBtZW1vO1xuICByZXR1cm4gZnVuY3Rpb24gbWVtb3JpemUoKSB7XG4gICAgaWYgKHR5cGVvZiBtZW1vID09PSAndW5kZWZpbmVkJykge1xuICAgICAgLy8gVGVzdCBmb3IgSUUgPD0gOSBhcyBwcm9wb3NlZCBieSBCcm93c2VyaGFja3NcbiAgICAgIC8vIEBzZWUgaHR0cDovL2Jyb3dzZXJoYWNrcy5jb20vI2hhY2stZTcxZDg2OTJmNjUzMzQxNzNmZWU3MTVjMjIyY2I4MDVcbiAgICAgIC8vIFRlc3RzIGZvciBleGlzdGVuY2Ugb2Ygc3RhbmRhcmQgZ2xvYmFscyBpcyB0byBhbGxvdyBzdHlsZS1sb2FkZXJcbiAgICAgIC8vIHRvIG9wZXJhdGUgY29ycmVjdGx5IGludG8gbm9uLXN0YW5kYXJkIGVudmlyb25tZW50c1xuICAgICAgLy8gQHNlZSBodHRwczovL2dpdGh1Yi5jb20vd2VicGFjay1jb250cmliL3N0eWxlLWxvYWRlci9pc3N1ZXMvMTc3XG4gICAgICBtZW1vID0gQm9vbGVhbih3aW5kb3cgJiYgZG9jdW1lbnQgJiYgZG9jdW1lbnQuYWxsICYmICF3aW5kb3cuYXRvYik7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1lbW87XG4gIH07XG59KCk7XG5cbnZhciBnZXRUYXJnZXQgPSBmdW5jdGlvbiBnZXRUYXJnZXQoKSB7XG4gIHZhciBtZW1vID0ge307XG4gIHJldHVybiBmdW5jdGlvbiBtZW1vcml6ZSh0YXJnZXQpIHtcbiAgICBpZiAodHlwZW9mIG1lbW9bdGFyZ2V0XSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHZhciBzdHlsZVRhcmdldCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IodGFyZ2V0KTsgLy8gU3BlY2lhbCBjYXNlIHRvIHJldHVybiBoZWFkIG9mIGlmcmFtZSBpbnN0ZWFkIG9mIGlmcmFtZSBpdHNlbGZcblxuICAgICAgaWYgKHdpbmRvdy5IVE1MSUZyYW1lRWxlbWVudCAmJiBzdHlsZVRhcmdldCBpbnN0YW5jZW9mIHdpbmRvdy5IVE1MSUZyYW1lRWxlbWVudCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIC8vIFRoaXMgd2lsbCB0aHJvdyBhbiBleGNlcHRpb24gaWYgYWNjZXNzIHRvIGlmcmFtZSBpcyBibG9ja2VkXG4gICAgICAgICAgLy8gZHVlIHRvIGNyb3NzLW9yaWdpbiByZXN0cmljdGlvbnNcbiAgICAgICAgICBzdHlsZVRhcmdldCA9IHN0eWxlVGFyZ2V0LmNvbnRlbnREb2N1bWVudC5oZWFkO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgLy8gaXN0YW5idWwgaWdub3JlIG5leHRcbiAgICAgICAgICBzdHlsZVRhcmdldCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgbWVtb1t0YXJnZXRdID0gc3R5bGVUYXJnZXQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1lbW9bdGFyZ2V0XTtcbiAgfTtcbn0oKTtcblxudmFyIHN0eWxlc0luRG9tID0gW107XG5cbmZ1bmN0aW9uIGdldEluZGV4QnlJZGVudGlmaWVyKGlkZW50aWZpZXIpIHtcbiAgdmFyIHJlc3VsdCA9IC0xO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3R5bGVzSW5Eb20ubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoc3R5bGVzSW5Eb21baV0uaWRlbnRpZmllciA9PT0gaWRlbnRpZmllcikge1xuICAgICAgcmVzdWx0ID0gaTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIG1vZHVsZXNUb0RvbShsaXN0LCBvcHRpb25zKSB7XG4gIHZhciBpZENvdW50TWFwID0ge307XG4gIHZhciBpZGVudGlmaWVycyA9IFtdO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgIHZhciBpdGVtID0gbGlzdFtpXTtcbiAgICB2YXIgaWQgPSBvcHRpb25zLmJhc2UgPyBpdGVtWzBdICsgb3B0aW9ucy5iYXNlIDogaXRlbVswXTtcbiAgICB2YXIgY291bnQgPSBpZENvdW50TWFwW2lkXSB8fCAwO1xuICAgIHZhciBpZGVudGlmaWVyID0gXCJcIi5jb25jYXQoaWQsIFwiIFwiKS5jb25jYXQoY291bnQpO1xuICAgIGlkQ291bnRNYXBbaWRdID0gY291bnQgKyAxO1xuICAgIHZhciBpbmRleCA9IGdldEluZGV4QnlJZGVudGlmaWVyKGlkZW50aWZpZXIpO1xuICAgIHZhciBvYmogPSB7XG4gICAgICBjc3M6IGl0ZW1bMV0sXG4gICAgICBtZWRpYTogaXRlbVsyXSxcbiAgICAgIHNvdXJjZU1hcDogaXRlbVszXVxuICAgIH07XG5cbiAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICBzdHlsZXNJbkRvbVtpbmRleF0ucmVmZXJlbmNlcysrO1xuICAgICAgc3R5bGVzSW5Eb21baW5kZXhdLnVwZGF0ZXIob2JqKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3R5bGVzSW5Eb20ucHVzaCh7XG4gICAgICAgIGlkZW50aWZpZXI6IGlkZW50aWZpZXIsXG4gICAgICAgIHVwZGF0ZXI6IGFkZFN0eWxlKG9iaiwgb3B0aW9ucyksXG4gICAgICAgIHJlZmVyZW5jZXM6IDFcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlkZW50aWZpZXJzLnB1c2goaWRlbnRpZmllcik7XG4gIH1cblxuICByZXR1cm4gaWRlbnRpZmllcnM7XG59XG5cbmZ1bmN0aW9uIGluc2VydFN0eWxlRWxlbWVudChvcHRpb25zKSB7XG4gIHZhciBzdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJyk7XG4gIHZhciBhdHRyaWJ1dGVzID0gb3B0aW9ucy5hdHRyaWJ1dGVzIHx8IHt9O1xuXG4gIGlmICh0eXBlb2YgYXR0cmlidXRlcy5ub25jZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB2YXIgbm9uY2UgPSB0eXBlb2YgX193ZWJwYWNrX25vbmNlX18gIT09ICd1bmRlZmluZWQnID8gX193ZWJwYWNrX25vbmNlX18gOiBudWxsO1xuXG4gICAgaWYgKG5vbmNlKSB7XG4gICAgICBhdHRyaWJ1dGVzLm5vbmNlID0gbm9uY2U7XG4gICAgfVxuICB9XG5cbiAgT2JqZWN0LmtleXMoYXR0cmlidXRlcykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgc3R5bGUuc2V0QXR0cmlidXRlKGtleSwgYXR0cmlidXRlc1trZXldKTtcbiAgfSk7XG5cbiAgaWYgKHR5cGVvZiBvcHRpb25zLmluc2VydCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIG9wdGlvbnMuaW5zZXJ0KHN0eWxlKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgdGFyZ2V0ID0gZ2V0VGFyZ2V0KG9wdGlvbnMuaW5zZXJ0IHx8ICdoZWFkJyk7XG5cbiAgICBpZiAoIXRhcmdldCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ291bGRuJ3QgZmluZCBhIHN0eWxlIHRhcmdldC4gVGhpcyBwcm9iYWJseSBtZWFucyB0aGF0IHRoZSB2YWx1ZSBmb3IgdGhlICdpbnNlcnQnIHBhcmFtZXRlciBpcyBpbnZhbGlkLlwiKTtcbiAgICB9XG5cbiAgICB0YXJnZXQuYXBwZW5kQ2hpbGQoc3R5bGUpO1xuICB9XG5cbiAgcmV0dXJuIHN0eWxlO1xufVxuXG5mdW5jdGlvbiByZW1vdmVTdHlsZUVsZW1lbnQoc3R5bGUpIHtcbiAgLy8gaXN0YW5idWwgaWdub3JlIGlmXG4gIGlmIChzdHlsZS5wYXJlbnROb2RlID09PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgc3R5bGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzdHlsZSk7XG59XG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAgKi9cblxuXG52YXIgcmVwbGFjZVRleHQgPSBmdW5jdGlvbiByZXBsYWNlVGV4dCgpIHtcbiAgdmFyIHRleHRTdG9yZSA9IFtdO1xuICByZXR1cm4gZnVuY3Rpb24gcmVwbGFjZShpbmRleCwgcmVwbGFjZW1lbnQpIHtcbiAgICB0ZXh0U3RvcmVbaW5kZXhdID0gcmVwbGFjZW1lbnQ7XG4gICAgcmV0dXJuIHRleHRTdG9yZS5maWx0ZXIoQm9vbGVhbikuam9pbignXFxuJyk7XG4gIH07XG59KCk7XG5cbmZ1bmN0aW9uIGFwcGx5VG9TaW5nbGV0b25UYWcoc3R5bGUsIGluZGV4LCByZW1vdmUsIG9iaikge1xuICB2YXIgY3NzID0gcmVtb3ZlID8gJycgOiBvYmoubWVkaWEgPyBcIkBtZWRpYSBcIi5jb25jYXQob2JqLm1lZGlhLCBcIiB7XCIpLmNvbmNhdChvYmouY3NzLCBcIn1cIikgOiBvYmouY3NzOyAvLyBGb3Igb2xkIElFXG5cbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICAqL1xuXG4gIGlmIChzdHlsZS5zdHlsZVNoZWV0KSB7XG4gICAgc3R5bGUuc3R5bGVTaGVldC5jc3NUZXh0ID0gcmVwbGFjZVRleHQoaW5kZXgsIGNzcyk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGNzc05vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjc3MpO1xuICAgIHZhciBjaGlsZE5vZGVzID0gc3R5bGUuY2hpbGROb2RlcztcblxuICAgIGlmIChjaGlsZE5vZGVzW2luZGV4XSkge1xuICAgICAgc3R5bGUucmVtb3ZlQ2hpbGQoY2hpbGROb2Rlc1tpbmRleF0pO1xuICAgIH1cblxuICAgIGlmIChjaGlsZE5vZGVzLmxlbmd0aCkge1xuICAgICAgc3R5bGUuaW5zZXJ0QmVmb3JlKGNzc05vZGUsIGNoaWxkTm9kZXNbaW5kZXhdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3R5bGUuYXBwZW5kQ2hpbGQoY3NzTm9kZSk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGFwcGx5VG9UYWcoc3R5bGUsIG9wdGlvbnMsIG9iaikge1xuICB2YXIgY3NzID0gb2JqLmNzcztcbiAgdmFyIG1lZGlhID0gb2JqLm1lZGlhO1xuICB2YXIgc291cmNlTWFwID0gb2JqLnNvdXJjZU1hcDtcblxuICBpZiAobWVkaWEpIHtcbiAgICBzdHlsZS5zZXRBdHRyaWJ1dGUoJ21lZGlhJywgbWVkaWEpO1xuICB9IGVsc2Uge1xuICAgIHN0eWxlLnJlbW92ZUF0dHJpYnV0ZSgnbWVkaWEnKTtcbiAgfVxuXG4gIGlmIChzb3VyY2VNYXAgJiYgdHlwZW9mIGJ0b2EgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgY3NzICs9IFwiXFxuLyojIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxcIi5jb25jYXQoYnRvYSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkoc291cmNlTWFwKSkpKSwgXCIgKi9cIik7XG4gIH0gLy8gRm9yIG9sZCBJRVxuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAgKi9cblxuXG4gIGlmIChzdHlsZS5zdHlsZVNoZWV0KSB7XG4gICAgc3R5bGUuc3R5bGVTaGVldC5jc3NUZXh0ID0gY3NzO1xuICB9IGVsc2Uge1xuICAgIHdoaWxlIChzdHlsZS5maXJzdENoaWxkKSB7XG4gICAgICBzdHlsZS5yZW1vdmVDaGlsZChzdHlsZS5maXJzdENoaWxkKTtcbiAgICB9XG5cbiAgICBzdHlsZS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjc3MpKTtcbiAgfVxufVxuXG52YXIgc2luZ2xldG9uID0gbnVsbDtcbnZhciBzaW5nbGV0b25Db3VudGVyID0gMDtcblxuZnVuY3Rpb24gYWRkU3R5bGUob2JqLCBvcHRpb25zKSB7XG4gIHZhciBzdHlsZTtcbiAgdmFyIHVwZGF0ZTtcbiAgdmFyIHJlbW92ZTtcblxuICBpZiAob3B0aW9ucy5zaW5nbGV0b24pIHtcbiAgICB2YXIgc3R5bGVJbmRleCA9IHNpbmdsZXRvbkNvdW50ZXIrKztcbiAgICBzdHlsZSA9IHNpbmdsZXRvbiB8fCAoc2luZ2xldG9uID0gaW5zZXJ0U3R5bGVFbGVtZW50KG9wdGlvbnMpKTtcbiAgICB1cGRhdGUgPSBhcHBseVRvU2luZ2xldG9uVGFnLmJpbmQobnVsbCwgc3R5bGUsIHN0eWxlSW5kZXgsIGZhbHNlKTtcbiAgICByZW1vdmUgPSBhcHBseVRvU2luZ2xldG9uVGFnLmJpbmQobnVsbCwgc3R5bGUsIHN0eWxlSW5kZXgsIHRydWUpO1xuICB9IGVsc2Uge1xuICAgIHN0eWxlID0gaW5zZXJ0U3R5bGVFbGVtZW50KG9wdGlvbnMpO1xuICAgIHVwZGF0ZSA9IGFwcGx5VG9UYWcuYmluZChudWxsLCBzdHlsZSwgb3B0aW9ucyk7XG5cbiAgICByZW1vdmUgPSBmdW5jdGlvbiByZW1vdmUoKSB7XG4gICAgICByZW1vdmVTdHlsZUVsZW1lbnQoc3R5bGUpO1xuICAgIH07XG4gIH1cblxuICB1cGRhdGUob2JqKTtcbiAgcmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZVN0eWxlKG5ld09iaikge1xuICAgIGlmIChuZXdPYmopIHtcbiAgICAgIGlmIChuZXdPYmouY3NzID09PSBvYmouY3NzICYmIG5ld09iai5tZWRpYSA9PT0gb2JqLm1lZGlhICYmIG5ld09iai5zb3VyY2VNYXAgPT09IG9iai5zb3VyY2VNYXApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB1cGRhdGUob2JqID0gbmV3T2JqKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVtb3ZlKCk7XG4gICAgfVxuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChsaXN0LCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9OyAvLyBGb3JjZSBzaW5nbGUtdGFnIHNvbHV0aW9uIG9uIElFNi05LCB3aGljaCBoYXMgYSBoYXJkIGxpbWl0IG9uIHRoZSAjIG9mIDxzdHlsZT5cbiAgLy8gdGFncyBpdCB3aWxsIGFsbG93IG9uIGEgcGFnZVxuXG4gIGlmICghb3B0aW9ucy5zaW5nbGV0b24gJiYgdHlwZW9mIG9wdGlvbnMuc2luZ2xldG9uICE9PSAnYm9vbGVhbicpIHtcbiAgICBvcHRpb25zLnNpbmdsZXRvbiA9IGlzT2xkSUUoKTtcbiAgfVxuXG4gIGxpc3QgPSBsaXN0IHx8IFtdO1xuICB2YXIgbGFzdElkZW50aWZpZXJzID0gbW9kdWxlc1RvRG9tKGxpc3QsIG9wdGlvbnMpO1xuICByZXR1cm4gZnVuY3Rpb24gdXBkYXRlKG5ld0xpc3QpIHtcbiAgICBuZXdMaXN0ID0gbmV3TGlzdCB8fCBbXTtcblxuICAgIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobmV3TGlzdCkgIT09ICdbb2JqZWN0IEFycmF5XScpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxhc3RJZGVudGlmaWVycy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGlkZW50aWZpZXIgPSBsYXN0SWRlbnRpZmllcnNbaV07XG4gICAgICB2YXIgaW5kZXggPSBnZXRJbmRleEJ5SWRlbnRpZmllcihpZGVudGlmaWVyKTtcbiAgICAgIHN0eWxlc0luRG9tW2luZGV4XS5yZWZlcmVuY2VzLS07XG4gICAgfVxuXG4gICAgdmFyIG5ld0xhc3RJZGVudGlmaWVycyA9IG1vZHVsZXNUb0RvbShuZXdMaXN0LCBvcHRpb25zKTtcblxuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBsYXN0SWRlbnRpZmllcnMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICB2YXIgX2lkZW50aWZpZXIgPSBsYXN0SWRlbnRpZmllcnNbX2ldO1xuXG4gICAgICB2YXIgX2luZGV4ID0gZ2V0SW5kZXhCeUlkZW50aWZpZXIoX2lkZW50aWZpZXIpO1xuXG4gICAgICBpZiAoc3R5bGVzSW5Eb21bX2luZGV4XS5yZWZlcmVuY2VzID09PSAwKSB7XG4gICAgICAgIHN0eWxlc0luRG9tW19pbmRleF0udXBkYXRlcigpO1xuXG4gICAgICAgIHN0eWxlc0luRG9tLnNwbGljZShfaW5kZXgsIDEpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGxhc3RJZGVudGlmaWVycyA9IG5ld0xhc3RJZGVudGlmaWVycztcbiAgfTtcbn07IiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xuXG5mdW5jdGlvbiB1c2VBc3luY0VmZmVjdChlZmZlY3QsIGRlc3Ryb3ksIGlucHV0cykge1xuICB2YXIgaGFzRGVzdHJveSA9IHR5cGVvZiBkZXN0cm95ID09PSAnZnVuY3Rpb24nO1xuXG4gIFJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHJlc3VsdDtcbiAgICB2YXIgbW91bnRlZCA9IHRydWU7XG4gICAgdmFyIG1heWJlUHJvbWlzZSA9IGVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gbW91bnRlZDtcbiAgICB9KTtcblxuICAgIFByb21pc2UucmVzb2x2ZShtYXliZVByb21pc2UpLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICByZXN1bHQgPSB2YWx1ZTtcbiAgICB9KTtcblxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICBtb3VudGVkID0gZmFsc2U7XG5cbiAgICAgIGlmIChoYXNEZXN0cm95KSB7XG4gICAgICAgIGRlc3Ryb3kocmVzdWx0KTtcbiAgICAgIH1cbiAgICB9O1xuICB9LCBoYXNEZXN0cm95ID8gaW5wdXRzIDogZGVzdHJveSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdXNlQXN5bmNFZmZlY3Q7XG5tb2R1bGUuZXhwb3J0cy51c2VBc3luY0VmZmVjdCA9IHVzZUFzeW5jRWZmZWN0O1xuIiwidmFyIGFwaSA9IHJlcXVpcmUoXCIhLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvaW5qZWN0U3R5bGVzSW50b1N0eWxlVGFnLmpzXCIpO1xuICAgICAgICAgICAgdmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcz8/cnVsZVNldFsxXS5ydWxlc1syXS51c2VbMV0hLi4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtbG9hZGVyL3NyYy9pbmRleC5qcz8/cnVsZVNldFsxXS5ydWxlc1syXS51c2VbMl0hLi9zdHlsZS5jc3NcIik7XG5cbiAgICAgICAgICAgIGNvbnRlbnQgPSBjb250ZW50Ll9fZXNNb2R1bGUgPyBjb250ZW50LmRlZmF1bHQgOiBjb250ZW50O1xuXG4gICAgICAgICAgICBpZiAodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbiAgICAgICAgICAgIH1cblxudmFyIG9wdGlvbnMgPSB7fTtcblxub3B0aW9ucy5pbnNlcnQgPSBcImhlYWRcIjtcbm9wdGlvbnMuc2luZ2xldG9uID0gZmFsc2U7XG5cbnZhciB1cGRhdGUgPSBhcGkoY29udGVudCwgb3B0aW9ucyk7XG5cblxuXG5tb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzIHx8IHt9OyIsIi8vIFRoZSBtb2R1bGUgY2FjaGVcbnZhciBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX18gPSB7fTtcblxuLy8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbmZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG5cdHZhciBjYWNoZWRNb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdO1xuXHRpZiAoY2FjaGVkTW9kdWxlICE9PSB1bmRlZmluZWQpIHtcblx0XHRyZXR1cm4gY2FjaGVkTW9kdWxlLmV4cG9ydHM7XG5cdH1cblx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcblx0dmFyIG1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF0gPSB7XG5cdFx0aWQ6IG1vZHVsZUlkLFxuXHRcdC8vIG5vIG1vZHVsZS5sb2FkZWQgbmVlZGVkXG5cdFx0ZXhwb3J0czoge31cblx0fTtcblxuXHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cblx0X193ZWJwYWNrX21vZHVsZXNfX1ttb2R1bGVJZF0obW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cblx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcblx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xufVxuXG4iLCIvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuX193ZWJwYWNrX3JlcXVpcmVfXy5uID0gKG1vZHVsZSkgPT4ge1xuXHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cblx0XHQoKSA9PiAobW9kdWxlWydkZWZhdWx0J10pIDpcblx0XHQoKSA9PiAobW9kdWxlKTtcblx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgeyBhOiBnZXR0ZXIgfSk7XG5cdHJldHVybiBnZXR0ZXI7XG59OyIsIi8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb25zIGZvciBoYXJtb255IGV4cG9ydHNcbl9fd2VicGFja19yZXF1aXJlX18uZCA9IChleHBvcnRzLCBkZWZpbml0aW9uKSA9PiB7XG5cdGZvcih2YXIga2V5IGluIGRlZmluaXRpb24pIHtcblx0XHRpZihfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZGVmaW5pdGlvbiwga2V5KSAmJiAhX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIGtleSkpIHtcblx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBkZWZpbml0aW9uW2tleV0gfSk7XG5cdFx0fVxuXHR9XG59OyIsIl9fd2VicGFja19yZXF1aXJlX18ubyA9IChvYmosIHByb3ApID0+IChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKSkiLCIvLyBkZWZpbmUgX19lc01vZHVsZSBvbiBleHBvcnRzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIgPSAoZXhwb3J0cykgPT4ge1xuXHRpZih0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcpIHtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcblx0fVxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xufTsiLCJpbXBvcnQgeyBSYWlud2F5UnVudGltZSB9IGZyb20gXCJyYWlud2F5LXNka1wiO1xuaW1wb3J0IFJlYWN0LCB7IHVzZUVmZmVjdCwgdXNlUmVmLCB1c2VTdGF0ZSB9IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IFJlYWN0RE9NIGZyb20gXCJyZWFjdC1kb21cIjtcbmltcG9ydCBcIi4uL3N0eWxlLmNzc1wiO1xuaW1wb3J0IHVzZUFzeW5jRWZmZWN0IGZyb20gXCJ1c2UtYXN5bmMtZWZmZWN0XCI7XG5cbmNvbnN0IFF1aWNrRGVtbyA9ICgpID0+IHtcbiAgY29uc3QgW3J1bnRpbWUsIHNldFJ1bnRpbWVdID0gdXNlU3RhdGU8UmFpbndheVJ1bnRpbWUgfCB1bmRlZmluZWQ+KCk7XG4gIGNvbnN0IFtlcnJvciwgc2V0RXJyb3JdID0gdXNlU3RhdGU8c3RyaW5nPihcIlwiKTtcbiAgdXNlQXN5bmNFZmZlY3QoYXN5bmMgKGlzQWxpdmUpID0+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcnQgPSBhd2FpdCBSYWlud2F5UnVudGltZS5pbml0aWFsaXplKHtcbiAgICAgICAgYXBpS2V5OlxuICAgICAgICAgIG5ldyBVUkxTZWFyY2hQYXJhbXMod2luZG93LmxvY2F0aW9uLnNlYXJjaCkuZ2V0KFwiYXBpX2tleVwiKSA/PyBcIlwiLFxuICAgICAgICBleHRlcm5hbElkOiBcIndlYi1kZW1vLXF1aWNrXCIsXG4gICAgICAgIG9uUnVudGltZUNvbm5lY3Rpb25Mb3N0OiAoZXJyb3IpID0+IHtcbiAgICAgICAgICBzZXRSdW50aW1lKHVuZGVmaW5lZCk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uQ29ubmVjdGlvblJlcXVlc3Q6IChyZXF1ZXN0KSA9PiB7XG4gICAgICAgICAgcmVxdWVzdC5hY2NlcHQoKTtcbiAgICAgICAgfSxcbiAgICAgICAgb25QZWVyTWVzc2FnZTogKCkgPT4ge30sXG4gICAgICAgIG9uUGVlckRhdGFDaGFubmVsOiAoKSA9PiB7fSxcbiAgICAgICAgb25QZWVyRXJyb3I6IChwZWVyLCBlcnJvcikgPT4ge1xuICAgICAgICAgIGNvbnNvbGUud2FybihcIm9uUGVlckVycm9yXCIsIHBlZXIsIGVycm9yKTtcbiAgICAgICAgfSxcbiAgICAgICAgb25QZWVyU3RhdGVDaGFuZ2U6IChwZWVyLCBzdGF0ZSkgPT4ge1xuICAgICAgICAgIGNvbnNvbGUubG9nKGBQZWVyICR7cGVlci5wZWVySWR9IGNoYW5nZWQgc3RhdGVzIHRvICR7c3RhdGV9YCk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uU3RyZWFtQW5ub3VuY2VtZW50OiAoKSA9PiB7fSxcbiAgICAgICAgb25TdHJlYW1TdG9wOiAoKSA9PiB7fSxcbiAgICAgICAgbG9nU2luazogKCkgPT4ge30sXG4gICAgICB9KTtcbiAgICAgIGlmICghaXNBbGl2ZSgpKSByZXR1cm47XG4gICAgICBzZXRSdW50aW1lKHJ0KTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBzZXRFcnJvcigoZSBhcyBFcnJvcikubWVzc2FnZSk7XG4gICAgICBjb25zb2xlLmxvZyhlKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gKFxuICAgIDxtYWluIGNsYXNzTmFtZT1cIm0tdC04IG0tbC04IG0tci04IG0tYi04XCI+XG4gICAgICB7ZXJyb3IgPyBlcnJvciA6IHJ1bnRpbWUgPyBcIkNvbm5lY3RlZC5cIiA6IFwiQ29ubmVjdGluZ+KAplwifVxuICAgIDwvbWFpbj5cbiAgKTtcbn07XG5cblJlYWN0RE9NLnJlbmRlcihcbiAgPFJlYWN0LlN0cmljdE1vZGU+XG4gICAgPFF1aWNrRGVtbyAvPlxuICA8L1JlYWN0LlN0cmljdE1vZGU+LFxuICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInJlYWN0LXJvb3RcIiksXG4pO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==