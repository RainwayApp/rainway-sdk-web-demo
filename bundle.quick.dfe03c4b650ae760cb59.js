/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[2].use[1]!./node_modules/postcss-loader/src/index.js??ruleSet[1].rules[2].use[2]!./src/style.css":
/*!****************************************************************************************************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[2].use[1]!./node_modules/postcss-loader/src/index.js??ruleSet[1].rules[2].use[2]!./src/style.css ***!
  \****************************************************************************************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

// Imports
var ___CSS_LOADER_API_IMPORT___ = __webpack_require__(/*! ../node_modules/css-loader/dist/runtime/api.js */ "./node_modules/css-loader/dist/runtime/api.js");
exports = ___CSS_LOADER_API_IMPORT___(false);
exports.push([module.id, "@import url(https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Questrial&family=Poppins:wght@400;500;600&family=Barlow:wght@400;500;600;700&display=swap);"]);
// Module
exports.push([module.id, ":root {\n  --logo-font-family: \"Poppins\", sans-serif;\n  --body-font-family: \"Inter\", sans-serif;\n  --heading-font-family: \"Poppins\", sans-serif;\n  --header-font-family: \"Questrial\", sans-serif;\n\n  /* Slate Blue */\n  --clr-primary-100: #e0e2f4;\n  --clr-primary-200: #bfc3ec;\n  --clr-primary-300: #9fa7e2;\n  --clr-primary-400: #7e89d8;\n  --clr-primary-500: #616acb;\n  --clr-primary-600: #4854bb;\n  --clr-primary-700: #3943a2;\n  --clr-primary-800: #2f3885;\n  --clr-primary-900: #242b67;\n  --clr-primary-950: #191e4d;\n  --clr-primary-975: #0f122e;\n  --clr-primary-999: #05060f;\n\n  /* Mantis */\n  --clr-green-100: #f4fbf0;\n  --clr-green-200: #dff1d2;\n  --clr-green-300: #bfe2a6;\n  --clr-green-400: #a0d57b;\n  --clr-green-500: #8ccc61;\n  --clr-green-600: #6fad45;\n  --clr-green-700: #5b8d38;\n  --clr-green-800: #33571c;\n  --clr-green-900: #1e2f12;\n\n  /* Dandelion */\n  --clr-yellow-100: #fffdf1;\n  --clr-yellow-200: #fdf7db;\n  --clr-yellow-300: #faedb7;\n  --clr-yellow-400: #f7e695;\n  --clr-yellow-500: #f9dc5c;\n  --clr-yellow-600: #e5c343;\n  --clr-yellow-700: #9f8004;\n  --clr-yellow-800: #504102;\n  --clr-yellow-900: #282001;\n\n  /* Tomato */\n  --clr-red-100: #fff5f3;\n  --clr-red-200: #fbded8;\n  --clr-red-300: #f0b5a9;\n  --clr-red-400: #fa927b;\n  --clr-red-500: #fc6948;\n  --clr-red-600: #e9502f;\n  --clr-red-700: #cb3413;\n  --clr-red-800: #a30303;\n  --clr-red-900: #5c1111;\n\n  /* Neutrals */\n  --clr-neutral-0: #ffffff;\n  --clr-neutral-50: #f4f4f6;\n  --clr-neutral-100: #e9e9ec;\n  --clr-neutral-200: #d3d3d9;\n  --clr-neutral-300: #b3b3bc;\n  --clr-neutral-400: #9d9da9;\n  --clr-neutral-450: #868695;\n  --clr-neutral-500: #686877;\n  --clr-neutral-600: #5f5f6c;\n  --clr-neutral-700: #4c4c56;\n  --clr-neutral-800: #393941;\n  --clr-neutral-850: #2c2c33;\n  --clr-neutral-900: #26262c;\n  --clr-neutral-925: #1e1e23;\n  --clr-neutral-950: #131316;\n  --clr-neutral-975: #09090b;\n  --clr-neutral-990: #040405;\n  --clr-neutral-1000: #000000;\n}\n\n.spacer {\n  flex-grow: 1;\n}\n\n/** Margin and Padding helpers */\n.m-t-0 {\n  margin-top: 0px !important;\n}\n.p-t-0 {\n  padding-top: 0px !important;\n}\n.m-b-0 {\n  margin-bottom: 0px !important;\n}\n.p-b-0 {\n  padding-bottom: 0px !important;\n}\n.m-l-0 {\n  margin-left: 0px !important;\n}\n.p-l-0 {\n  padding-left: 0px !important;\n}\n.m-r-0 {\n  margin-right: 0px !important;\n}\n.p-r-0 {\n  padding-right: 0px !important;\n}\n.m-t-4 {\n  margin-top: 4px !important;\n}\n.p-t-4 {\n  padding-top: 4px !important;\n}\n.m-b-4 {\n  margin-bottom: 4px !important;\n}\n.p-b-4 {\n  padding-bottom: 4px !important;\n}\n.m-l-4 {\n  margin-left: 4px !important;\n}\n.p-l-4 {\n  padding-left: 4px !important;\n}\n.m-r-4 {\n  margin-right: 4px !important;\n}\n.p-r-4 {\n  padding-right: 4px !important;\n}\n.m-t-8 {\n  margin-top: 8px !important;\n}\n.p-t-8 {\n  padding-top: 8px !important;\n}\n.m-b-8 {\n  margin-bottom: 8px !important;\n}\n.p-b-8 {\n  padding-bottom: 8px !important;\n}\n.m-l-8 {\n  margin-left: 8px !important;\n}\n.p-l-8 {\n  padding-left: 8px !important;\n}\n.m-r-8 {\n  margin-right: 8px !important;\n}\n.p-r-8 {\n  padding-right: 8px !important;\n}\n.m-t-16 {\n  margin-top: 16px !important;\n}\n.p-t-16 {\n  padding-top: 16px !important;\n}\n.m-b-16 {\n  margin-bottom: 16px !important;\n}\n.p-b-16 {\n  padding-bottom: 16px !important;\n}\n.m-l-16 {\n  margin-left: 16px !important;\n}\n.p-l-16 {\n  padding-left: 16px !important;\n}\n.m-r-16 {\n  margin-right: 16px !important;\n}\n.p-r-16 {\n  padding-right: 16px !important;\n}\n.m-t-24 {\n  margin-top: 24px !important;\n}\n.p-t-24 {\n  padding-top: 24px !important;\n}\n.m-b-24 {\n  margin-bottom: 24px !important;\n}\n.p-b-24 {\n  padding-bottom: 24px !important;\n}\n.m-l-24 {\n  margin-left: 24px !important;\n}\n.p-l-24 {\n  padding-left: 24px !important;\n}\n.m-r-24 {\n  margin-right: 24px !important;\n}\n.p-r-24 {\n  padding-right: 24px !important;\n}\n.m-t-32 {\n  margin-top: 32px !important;\n}\n.p-t-32 {\n  padding-top: 32px !important;\n}\n.m-b-32 {\n  margin-bottom: 32px !important;\n}\n.p-b-32 {\n  padding-bottom: 32px !important;\n}\n.m-l-32 {\n  margin-left: 32px !important;\n}\n.p-l-32 {\n  padding-left: 32px !important;\n}\n.m-r-32 {\n  margin-right: 32px !important;\n}\n.p-r-32 {\n  padding-right: 32px !important;\n}\n.m-t-40 {\n  margin-top: 40px !important;\n}\n.p-t-40 {\n  padding-top: 40px !important;\n}\n.m-b-40 {\n  margin-bottom: 40px !important;\n}\n.p-b-40 {\n  padding-bottom: 40px !important;\n}\n.m-l-40 {\n  margin-left: 40px !important;\n}\n.p-l-40 {\n  padding-left: 40px !important;\n}\n.m-r-40 {\n  margin-right: 40px !important;\n}\n.p-r-40 {\n  padding-right: 40px !important;\n}\n.m-t-48 {\n  margin-top: 48px !important;\n}\n.p-t-48 {\n  padding-top: 48px !important;\n}\n.m-b-48 {\n  margin-bottom: 48px !important;\n}\n.p-b-48 {\n  padding-bottom: 48px !important;\n}\n.m-l-48 {\n  margin-left: 48px !important;\n}\n.p-l-48 {\n  padding-left: 48px !important;\n}\n.m-r-48 {\n  margin-right: 48px !important;\n}\n.p-r-48 {\n  padding-right: 48px !important;\n}\n.m-t-56 {\n  margin-top: 56px !important;\n}\n.p-t-56 {\n  padding-top: 56px !important;\n}\n.m-b-56 {\n  margin-bottom: 56px !important;\n}\n.p-b-56 {\n  padding-bottom: 56px !important;\n}\n.m-l-56 {\n  margin-left: 56px !important;\n}\n.p-l-56 {\n  padding-left: 56px !important;\n}\n.m-r-56 {\n  margin-right: 56px !important;\n}\n.p-r-56 {\n  padding-right: 56px !important;\n}\n.m-t-64 {\n  margin-top: 64px !important;\n}\n.p-t-64 {\n  padding-top: 64px !important;\n}\n.m-b-64 {\n  margin-bottom: 64px !important;\n}\n.p-b-64 {\n  padding-bottom: 64px !important;\n}\n.m-l-64 {\n  margin-left: 64px !important;\n}\n.p-l-64 {\n  padding-left: 64px !important;\n}\n.m-r-64 {\n  margin-right: 64px !important;\n}\n.p-r-64 {\n  padding-right: 64px !important;\n}\n.m-t-72 {\n  margin-top: 72px !important;\n}\n.p-t-72 {\n  padding-top: 72px !important;\n}\n.m-b-72 {\n  margin-bottom: 72px !important;\n}\n.p-b-72 {\n  padding-bottom: 72px !important;\n}\n.m-l-72 {\n  margin-left: 72px !important;\n}\n.p-l-72 {\n  padding-left: 72px !important;\n}\n.m-r-72 {\n  margin-right: 72px !important;\n}\n.p-r-72 {\n  padding-right: 72px !important;\n}\n.m-t-80 {\n  margin-top: 80px !important;\n}\n.p-t-80 {\n  padding-top: 80px !important;\n}\n.m-b-80 {\n  margin-bottom: 80px !important;\n}\n.p-b-80 {\n  padding-bottom: 80px !important;\n}\n.m-l-80 {\n  margin-left: 80px !important;\n}\n.p-l-80 {\n  padding-left: 80px !important;\n}\n.m-r-80 {\n  margin-right: 80px !important;\n}\n.p-r-80 {\n  padding-right: 80px !important;\n}\n.m-t-120 {\n  margin-top: 120px !important;\n}\n.p-t-120 {\n  padding-top: 120px !important;\n}\n.m-b-120 {\n  margin-bottom: 120px !important;\n}\n.p-b-120 {\n  padding-bottom: 120px !important;\n}\n.m-l-120 {\n  margin-left: 120px !important;\n}\n.p-l-120 {\n  padding-left: 120px !important;\n}\n.m-r-120 {\n  margin-right: 120px !important;\n}\n.p-r-120 {\n  padding-right: 120px !important;\n}\n.m-t-160 {\n  margin-top: 160px !important;\n}\n.p-t-160 {\n  padding-top: 160px !important;\n}\n.m-b-160 {\n  margin-bottom: 160px !important;\n}\n.p-b-160 {\n  padding-bottom: 160px !important;\n}\n.m-l-160 {\n  margin-left: 160px !important;\n}\n.p-l-160 {\n  padding-left: 160px !important;\n}\n.m-r-160 {\n  margin-right: 160px !important;\n}\n.p-r-160 {\n  padding-right: 160px !important;\n}\n\n* {\n  margin: 0;\n  padding: 0;\n  box-sizing: border-box;\n}\n\nhtml {\n  background: #131316;\n  scroll-behavior: smooth;\n  color-scheme: dark;\n}\n\nbody {\n  font-family: var(--body-font-family);\n  font-size: 14px;\n  color: var(--clr-neutral-300);\n}\n\nheader {\n  padding: 24px 32px;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  background: #000000;\n  box-shadow: 0px 1px 0px rgba(255, 255, 255, 0.15);\n}\n\n.header-inner {\n  flex: 1;\n  display: flex;\n  align-items: center;\n  max-width: 1100px;\n}\n\n.build-notes {\n  flex: 1;\n  display: flex;\n  justify-content: flex-end;\n  align-items: center;\n}\n\n.build-note {\n  line-height: 1;\n  display: flex;\n  align-items: center;\n  color: var(--clr-neutral-450);\n}\n\n.build-note + .build-note {\n  margin-left: 16px;\n}\n\n.build-note > svg {\n  margin-right: 8px;\n}\n\nh1 {\n  font-family: var(--heading-font-family);\n  font-size: 20px;\n  font-weight: bold;\n  color: var(--clr-neutral-0);\n}\n\nh2 {\n  font-family: var(--heading-font-family);\n  font-size: 16px;\n  font-weight: 600;\n  color: var(--clr-neutral-50);\n}\n\nh3 {\n  font-family: var(--heading-font-family);\n  font-size: 16px;\n  font-weight: 500;\n  color: var(--clr-neutral-100);\n}\n\nbutton {\n  border: none;\n  color: var(--clr-neutral-50);\n  background: linear-gradient(90deg, #616acb 0%, #4854bb 100%);\n  border-radius: 4px;\n  font-family: var(--body-font-family);\n  font-size: 14px;\n  padding: 12px 18px;\n  cursor: pointer;\n}\n\nbutton.secondary {\n  border: 1px solid var(--clr-primary-500);\n  background: transparent;\n}\n\nbutton:disabled {\n  color: var(--clr-neutral-400);\n  background: var(--clr-neutral-850);\n  cursor: inherit;\n}\n\ninput {\n  font-size: 14px;\n}\n\ninput[type=\"text\"] {\n  font-family: var(--body-font-family);\n  background: var(--clr-neutral-950);\n  border: 1px solid var(--clr-neutral-850);\n  border-radius: 5px;\n  padding: 12px 16px;\n}\n\n.badge {\n  display: flex;\n  flex-direction: row;\n  justify-content: center;\n  align-items: center;\n  padding: 4px 8px;\n  font-size: 12px;\n  font-weight: 500;\n  border-radius: 24px;\n  background: var(--clr-neutral-900);\n  color: var(--clr-neutral-300);\n}\n\n.badge.ok {\n  background: var(--clr-primary-900);\n  color: var(--clr-primary-300);\n}\n\n.backdrop {\n  width: 100%;\n  height: 180px;\n  position: absolute;\n  z-index: -5;\n  pointer-events: none;\n  background: #000000;\n}\n\n.demo {\n  padding: 32px;\n  max-width: 1100px;\n  margin: auto;\n}\n\n.flex {\n  display: flex;\n  align-items: center;\n}\n\nsvg {\n  flex-shrink: 0;\n}\n\n.card {\n  background: var(--clr-neutral-925);\n  box-shadow: 0px 8px 50px rgba(0, 0, 0, 0.25);\n  border-radius: 8px;\n  padding: 24px;\n  margin: 24px 0;\n}\n\n.card-top {\n  display: flex;\n  align-items: center;\n  margin-bottom: 8px;\n}\n\n.card-top > * + * {\n  margin-left: 8px;\n}\n\n.widget-body {\n  display: flex;\n}\n\n.stream-column {\n  flex: 2;\n}\n\n.chat-column {\n  flex: 1;\n  display: flex;\n  flex-direction: column;\n}\n\n.chat-history {\n  flex: 1;\n}\n\n.chat-bottom {\n  display: flex;\n  position: relative;\n  align-items: center;\n}\n\n.chat-input {\n  flex: 1;\n}\n\nbutton.chat-send-button {\n  cursor: pointer;\n  background: none;\n  padding: 0;\n  margin: 0;\n  position: absolute;\n  right: 16px;\n  margin-top: auto;\n}\n\nbutton.chat-send-button:disabled {\n  cursor: inherit;\n  filter: grayscale();\n}\n\n.stream-wrapper {\n  border: 1px solid rgba(0, 0, 0, 0.4);\n  background-image: /* url(\"https://rainway.com/images/logo.svg\"), */\n    linear-gradient(-45deg, #141625, #241635);\n  background-repeat: no-repeat;\n  background-position: center;\n  width: 100%;\n  height: 393px;\n}\n\na {\n  color: var(--clr-primary-400);\n  font-weight: 600;\n  text-decoration: none;\n  transition: color 0.2s ease;\n}\n\na:hover {\n  color: var(--clr-neutral-50);\n}\n", ""]);
// Exports
module.exports = exports;


/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/api.js":
/*!*****************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/api.js ***!
  \*****************************************************/
/***/ ((module) => {

"use strict";


/*
  MIT License http://www.opensource.org/licenses/mit-license.php
  Author Tobias Koppers @sokra
*/
// css base code, injected by the css-loader
// eslint-disable-next-line func-names
module.exports = function (useSourceMap) {
  var list = []; // return the list of modules as css string

  list.toString = function toString() {
    return this.map(function (item) {
      var content = cssWithMappingToString(item, useSourceMap);

      if (item[2]) {
        return "@media ".concat(item[2], " {").concat(content, "}");
      }

      return content;
    }).join('');
  }; // import a list of modules into the list
  // eslint-disable-next-line func-names


  list.i = function (modules, mediaQuery, dedupe) {
    if (typeof modules === 'string') {
      // eslint-disable-next-line no-param-reassign
      modules = [[null, modules, '']];
    }

    var alreadyImportedModules = {};

    if (dedupe) {
      for (var i = 0; i < this.length; i++) {
        // eslint-disable-next-line prefer-destructuring
        var id = this[i][0];

        if (id != null) {
          alreadyImportedModules[id] = true;
        }
      }
    }

    for (var _i = 0; _i < modules.length; _i++) {
      var item = [].concat(modules[_i]);

      if (dedupe && alreadyImportedModules[item[0]]) {
        // eslint-disable-next-line no-continue
        continue;
      }

      if (mediaQuery) {
        if (!item[2]) {
          item[2] = mediaQuery;
        } else {
          item[2] = "".concat(mediaQuery, " and ").concat(item[2]);
        }
      }

      list.push(item);
    }
  };

  return list;
};

function cssWithMappingToString(item, useSourceMap) {
  var content = item[1] || ''; // eslint-disable-next-line prefer-destructuring

  var cssMapping = item[3];

  if (!cssMapping) {
    return content;
  }

  if (useSourceMap && typeof btoa === 'function') {
    var sourceMapping = toComment(cssMapping);
    var sourceURLs = cssMapping.sources.map(function (source) {
      return "/*# sourceURL=".concat(cssMapping.sourceRoot || '').concat(source, " */");
    });
    return [content].concat(sourceURLs).concat([sourceMapping]).join('\n');
  }

  return [content].join('\n');
} // Adapted from convert-source-map (MIT)


function toComment(sourceMap) {
  // eslint-disable-next-line no-undef
  var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));
  var data = "sourceMappingURL=data:application/json;charset=utf-8;base64,".concat(base64);
  return "/*# ".concat(data, " */");
}

/***/ }),

/***/ "./node_modules/object-assign/index.js":
/*!*********************************************!*\
  !*** ./node_modules/object-assign/index.js ***!
  \*********************************************/
/***/ ((module) => {

"use strict";
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/


/* eslint-disable no-unused-vars */
var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var hasOwnProperty = Object.prototype.hasOwnProperty;
var propIsEnumerable = Object.prototype.propertyIsEnumerable;

function toObject(val) {
	if (val === null || val === undefined) {
		throw new TypeError('Object.assign cannot be called with null or undefined');
	}

	return Object(val);
}

function shouldUseNative() {
	try {
		if (!Object.assign) {
			return false;
		}

		// Detect buggy property enumeration order in older V8 versions.

		// https://bugs.chromium.org/p/v8/issues/detail?id=4118
		var test1 = new String('abc');  // eslint-disable-line no-new-wrappers
		test1[5] = 'de';
		if (Object.getOwnPropertyNames(test1)[0] === '5') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test2 = {};
		for (var i = 0; i < 10; i++) {
			test2['_' + String.fromCharCode(i)] = i;
		}
		var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
			return test2[n];
		});
		if (order2.join('') !== '0123456789') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test3 = {};
		'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
			test3[letter] = letter;
		});
		if (Object.keys(Object.assign({}, test3)).join('') !==
				'abcdefghijklmnopqrst') {
			return false;
		}

		return true;
	} catch (err) {
		// We don't expect any of the above to throw, but better to be safe.
		return false;
	}
}

module.exports = shouldUseNative() ? Object.assign : function (target, source) {
	var from;
	var to = toObject(target);
	var symbols;

	for (var s = 1; s < arguments.length; s++) {
		from = Object(arguments[s]);

		for (var key in from) {
			if (hasOwnProperty.call(from, key)) {
				to[key] = from[key];
			}
		}

		if (getOwnPropertySymbols) {
			symbols = getOwnPropertySymbols(from);
			for (var i = 0; i < symbols.length; i++) {
				if (propIsEnumerable.call(from, symbols[i])) {
					to[symbols[i]] = from[symbols[i]];
				}
			}
		}
	}

	return to;
};


/***/ }),

/***/ "./node_modules/rainway-sdk/dist/index.js":
/*!************************************************!*\
  !*** ./node_modules/rainway-sdk/dist/index.js ***!
  \************************************************/
/***/ ((module) => {

!function(A,I){ true?module.exports=I():0}(self,(function(){return(()=>{var A={120:(A,I,g)=>{"use strict";Object.defineProperty(I,"__esModule",{value:!0}),I.BebopView=I.BebopRuntimeError=void 0;const e="0123456789abcdef",B=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,2,3,4,5,6,7,8,9,0,0,0,0,0,0,0,10,11,12,13,14,15,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,10,11,12,13,14,15,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],i=new Uint8Array(0),t=[];for(const A of e)for(const I of e)t.push(A+I);"undefined"==typeof TextDecoder&&(g.g.TextDecoder=g(700).TextDecoder);class Q extends Error{constructor(A){super(A),this.name="BebopRuntimeError"}}I.BebopRuntimeError=Q;class C{static textDecoder=new TextDecoder;static writeBuffer=new Uint8Array(256);static writeBufferView=new DataView(C.writeBuffer.buffer);static instance;static getInstance(){return C.instance||(C.instance=new C),C.instance}minimumTextDecoderLength=300;buffer;view;index;length;constructor(){this.buffer=C.writeBuffer,this.view=C.writeBufferView,this.index=0,this.length=0}startReading(A){this.buffer=A,this.view=new DataView(this.buffer.buffer,this.buffer.byteOffset,this.buffer.byteLength),this.index=0,this.length=A.length}startWriting(){this.buffer=C.writeBuffer,this.view=C.writeBufferView,this.index=0,this.length=0}guaranteeBufferLength(A){if(A>this.buffer.length){const I=new Uint8Array(A<<1);I.set(this.buffer),this.buffer=I,this.view=new DataView(I.buffer)}}growBy(A){this.length+=A,this.guaranteeBufferLength(this.length)}skip(A){this.index+=A}toArray(){return this.buffer.subarray(0,this.length)}readByte(){return this.buffer[this.index++]}readUint16(){const A=this.view.getUint16(this.index,!0);return this.index+=2,A}readInt16(){const A=this.view.getInt16(this.index,!0);return this.index+=2,A}readUint32(){const A=this.view.getUint32(this.index,!0);return this.index+=4,A}readInt32(){const A=this.view.getInt32(this.index,!0);return this.index+=4,A}readUint64(){const A=this.view.getBigUint64(this.index,!0);return this.index+=8,A}readInt64(){const A=this.view.getBigInt64(this.index,!0);return this.index+=8,A}readFloat32(){const A=this.view.getFloat32(this.index,!0);return this.index+=4,A}readFloat64(){const A=this.view.getFloat64(this.index,!0);return this.index+=8,A}writeByte(A){const I=this.length;this.growBy(1),this.buffer[I]=A}writeUint16(A){const I=this.length;this.growBy(2),this.view.setUint16(I,A,!0)}writeInt16(A){const I=this.length;this.growBy(2),this.view.setInt16(I,A,!0)}writeUint32(A){const I=this.length;this.growBy(4),this.view.setUint32(I,A,!0)}writeInt32(A){const I=this.length;this.growBy(4),this.view.setInt32(I,A,!0)}writeUint64(A){const I=this.length;this.growBy(8),this.view.setBigUint64(I,A,!0)}writeInt64(A){const I=this.length;this.growBy(8),this.view.setBigInt64(I,A,!0)}writeFloat32(A){const I=this.length;this.growBy(4),this.view.setFloat32(I,A,!0)}writeFloat64(A){const I=this.length;this.growBy(8),this.view.setFloat64(I,A,!0)}readBytes(){const A=this.readUint32();if(0===A)return i;const I=this.index,g=I+A;return this.index=g,this.buffer.subarray(I,g)}writeBytes(A){const I=A.length;if(this.writeUint32(I),0===I)return;const g=this.length;this.growBy(I),this.buffer.set(A,g)}readString(){const A=this.readUint32();if(0===A)return"";if(A>=this.minimumTextDecoderLength)return C.textDecoder.decode(this.buffer.subarray(this.index,this.index+=A));const I=this.index+A;let g,e="";for(;this.index<I;){const A=this.buffer[this.index++];if(A<192)g=A;else{const I=this.buffer[this.index++];if(A<224)g=(31&A)<<6|63&I;else{const e=this.buffer[this.index++];g=A<240?(15&A)<<12|(63&I)<<6|63&e:(7&A)<<18|(63&I)<<12|(63&e)<<6|63&this.buffer[this.index++]}}g<65536?e+=String.fromCharCode(g):(g-=65536,e+=String.fromCharCode(55296+(g>>10),56320+(1023&g)))}return this.index=I,e}writeString(A){const I=A.length;if(0===I)return void this.writeUint32(0);const g=4+3*I;this.guaranteeBufferLength(this.length+g);let e=this.length+4;const B=e;let i;for(let g=0;g<I;g++){const B=A.charCodeAt(g);i=g+1===I||B<55296||B>=56320?B:(B<<10)+A.charCodeAt(++g)+-56613888,i<128?this.buffer[e++]=i:(i<2048?this.buffer[e++]=i>>6&31|192:(i<65536?this.buffer[e++]=i>>12&15|224:(this.buffer[e++]=i>>18&7|240,this.buffer[e++]=i>>12&63|128),this.buffer[e++]=i>>6&63|128),this.buffer[e++]=63&i|128)}const t=e-B;this.view.setUint32(this.length,t,!0),this.length+=4+t}readGuid(){const A=t,I=this.buffer,g=this.index,e="-";var B=A[I[g+3]];return B+=A[I[g+2]],B+=A[I[g+1]],B+=A[I[g]],B+=e,B+=A[I[g+5]],B+=A[I[g+4]],B+=e,B+=A[I[g+7]],B+=A[I[g+6]],B+=e,B+=A[I[g+8]],B+=A[I[g+9]],B+=e,B+=A[I[g+10]],B+=A[I[g+11]],B+=A[I[g+12]],B+=A[I[g+13]],B+=A[I[g+14]],B+=A[I[g+15]],this.index+=16,B}writeGuid(A){const I=this.view,g=this.length;this.growBy(16);var e=0,i=0;i=(i=(i=(i=(i=(i=(i=(i=i<<4|B[A.charCodeAt(e++)])<<4|B[A.charCodeAt(e++)])<<4|B[A.charCodeAt(e++)])<<4|B[A.charCodeAt(e++)])<<4|B[A.charCodeAt(e++)])<<4|B[A.charCodeAt(e++)])<<4|B[A.charCodeAt(e++)])<<4|B[A.charCodeAt(e++)],e+=45===A.charCodeAt(e),I.setUint32(g,i,!0),i=(i=(i=(i=i<<4|B[A.charCodeAt(e++)])<<4|B[A.charCodeAt(e++)])<<4|B[A.charCodeAt(e++)])<<4|B[A.charCodeAt(e++)],e+=45===A.charCodeAt(e),I.setUint16(g+4,i,!0),i=(i=(i=(i=i<<4|B[A.charCodeAt(e++)])<<4|B[A.charCodeAt(e++)])<<4|B[A.charCodeAt(e++)])<<4|B[A.charCodeAt(e++)],e+=45===A.charCodeAt(e),I.setUint16(g+6,i,!0),i=(i=(i=(i=i<<4|B[A.charCodeAt(e++)])<<4|B[A.charCodeAt(e++)])<<4|B[A.charCodeAt(e++)])<<4|B[A.charCodeAt(e++)],e+=45===A.charCodeAt(e),i=(i=(i=(i=i<<4|B[A.charCodeAt(e++)])<<4|B[A.charCodeAt(e++)])<<4|B[A.charCodeAt(e++)])<<4|B[A.charCodeAt(e++)],I.setUint32(g+8,i,!1),i=(i=(i=(i=(i=(i=(i=(i=i<<4|B[A.charCodeAt(e++)])<<4|B[A.charCodeAt(e++)])<<4|B[A.charCodeAt(e++)])<<4|B[A.charCodeAt(e++)])<<4|B[A.charCodeAt(e++)])<<4|B[A.charCodeAt(e++)])<<4|B[A.charCodeAt(e++)])<<4|B[A.charCodeAt(e++)],I.setUint32(g+12,i,!1)}readDate(){const A=this.readUint32(),I=1073741823&this.readUint32();return new Date(429496.7296*I+1e-4*A-621355968e5)}writeDate(A){const I=A.getTime()+621355968e5,g=I%429496.7296*1e4|0,e=I/429496.7296|1073741824;this.writeUint32(g),this.writeUint32(e)}reserveMessageLength(){const A=this.length;return this.growBy(4),A}fillMessageLength(A,I){this.view.setUint32(A,I,!0)}readMessageLength(){const A=this.view.getUint32(this.index,!0);return this.index+=4,A}}I.BebopView=C},290:function(A,I,g){"use strict";var e=this&&this.__awaiter||function(A,I,g,e){return new(g||(g=Promise))((function(B,i){function t(A){try{C(e.next(A))}catch(A){i(A)}}function Q(A){try{C(e.throw(A))}catch(A){i(A)}}function C(A){var I;A.done?B(A.value):(I=A.value,I instanceof g?I:new g((function(A){A(I)}))).then(t,Q)}C((e=e.apply(A,I||[])).next())}))};Object.defineProperty(I,"__esModule",{value:!0}),I.fetchNewPeerId=I.getOrganizationInfo=void 0;const B=g(464),i=g(994),t="https://api.rainway.network/v1";I.getOrganizationInfo=function(A){return e(this,void 0,void 0,(function*(){try{const I=yield fetch(t+"/keys/validate",{headers:{Authorization:`Bearer ${A}`,Accept:"application/json"}}),g=yield I.json();return{universeFlag:g.universe,organizationId:g.org_id}}catch(A){throw B.RainwayLogging.error(String(A)),new i.RainwayError("The Rainway API key is invalid.")}}))},I.fetchNewPeerId=function(){return e(this,void 0,void 0,(function*(){const A=yield fetch(t+"/druid/next",{headers:{Accept:"application/json"}});return BigInt(yield A.text())}))}},434:(A,I)=>{"use strict";var g,e;Object.defineProperty(I,"__esModule",{value:!0}),I.AudioReadyState=I.VideoReadyState=void 0,(e=I.VideoReadyState||(I.VideoReadyState={}))[e.Detached=0]="Detached",e[e.Initializing=1]="Initializing",e[e.WaitingForKeyframe=2]="WaitingForKeyframe",e[e.Playing=3]="Playing",e[e.Paused=4]="Paused",e[e.Disposed=5]="Disposed",(g=I.AudioReadyState||(I.AudioReadyState={}))[g.Detached=0]="Detached",g[g.Uninitialized=1]="Uninitialized",g[g.Initializing=2]="Initializing",g[g.Playing=3]="Playing",g[g.Paused=4]="Paused"},528:(A,I)=>{"use strict";Object.defineProperty(I,"__esModule",{value:!0}),I.isDesktopSafari=void 0,I.isDesktopSafari=/Macintosh;.*Safari/.test(navigator.userAgent)&&!/Chrome|Android/i.test(navigator.userAgent)},987:(A,I)=>{"use strict";Object.defineProperty(I,"__esModule",{value:!0}),I.reassemble=I.eachChunk=void 0;let g=0;I.eachChunk=function(A,I,e=16e3){const B=Math.ceil(A.length/e),i=++g;for(let g=0;g<B;g++){const t=g*e,Q=Math.min((g+1)*e,A.length);I({chunksInGroup:B,groupId:i,index:g,data:A.slice(t,Q)})}},I.reassemble=function(A){let I=0;const g=A.chunks.length;for(let e=0;e<g;e++)I+=A.chunks[e].byteLength;const e=new Uint8Array(I);let B=0;for(let I=0;I<g;I++){const g=A.chunks[I];e.set(g,B),B+=g.byteLength}return e}},24:(A,I)=>{"use strict";Object.defineProperty(I,"__esModule",{value:!0}),I.Action=void 0,I.Action=class{constructor(){this.handlers=[]}addHandler(A){this.handlers.push(A)}removeHandler(A){this.handlers=this.handlers.filter((I=>I!==A))}invoke(A){for(let I=0;I<this.handlers.length;I++)this.handlers[I](A)}}},930:(A,I)=>{"use strict";Object.defineProperty(I,"__esModule",{value:!0}),I.boundingRectangle=void 0,I.boundingRectangle=function(A){const I=A.length;if(0===I)throw new Error("boundingRectangle() of 0 rectangles");const g=A[0];let{left:e,top:B}=g,i=e+g.width,t=B+g.height;for(let g=1;g<I;g++){const I=A[g];e=Math.min(e,I.left),B=Math.min(B,I.top),i=Math.max(i,I.left+I.width),t=Math.max(t,I.top+I.height)}return{left:e,top:B,width:i-e,height:t-B}}},198:(A,I)=>{"use strict";function g(A){if(0===A.length)return NaN;let I=0;for(const g of A)I+=g;return I/A.length}Object.defineProperty(I,"__esModule",{value:!0}),I.meanOrZero=I.mean=I.standardDeviation=I.interquartileRange=I.median=I.WindowTrack=void 0,I.WindowTrack=class{constructor(A,I){this.sizeMs=A,this.averageOperation=I,this.cachedAverage=void 0,this.buffer=[]}get values(){return this.trim(),this.buffer.map((A=>A.value))}get measurements(){return this.trim(),this.buffer}trim(){const A=performance.now(),I=this.buffer.findIndex((I=>I.time>A-this.sizeMs));I>0?(this.buffer.splice(0,I),this.cachedAverage=void 0):-1===I&&(this.buffer.splice(0,this.buffer.length),this.cachedAverage=void 0)}feed(A){const I=performance.now();this.buffer.push({time:I,value:A}),this.buffer.length>=500&&this.trim(),this.cachedAverage=void 0}average(){if(this.trim(),this.cachedAverage)return this.cachedAverage;const A=this.buffer.map((A=>A.value));return this.cachedAverage=this.averageOperation(A)}},I.median=function(A){return 0===A.length?NaN:(A.sort(((A,I)=>A-I)),A[Math.floor(A.length/2)])},I.interquartileRange=function(A){if(0===A.length)return NaN;A.sort(((A,I)=>A-I));const I=Math.floor(.25*A.length);return A[Math.floor(.75*A.length)]-A[I]},I.standardDeviation=function(A){if(0===A.length)return NaN;const I=A.length,g=A.reduce(((A,I)=>A+I),0)/I;return Math.sqrt(A.map((A=>Math.pow(A-g,2))).reduce(((A,I)=>A+I),0)/I)},I.mean=g,I.meanOrZero=function(A){return 0===A.length?0:g(A)}},904:function(A,I,g){"use strict";var e=this&&this.__createBinding||(Object.create?function(A,I,g,e){void 0===e&&(e=g),Object.defineProperty(A,e,{enumerable:!0,get:function(){return I[g]}})}:function(A,I,g,e){void 0===e&&(e=g),A[e]=I[g]}),B=this&&this.__exportStar||function(A,I){for(var g in A)"default"===g||Object.prototype.hasOwnProperty.call(I,g)||e(I,A,g)};Object.defineProperty(I,"__esModule",{value:!0}),B(g(162),I)},162:(A,I,g)=>{"use strict";Object.defineProperty(I,"__esModule",{value:!0}),I.WindowsPointerFlags=I.VirtualKey=I.KeyboardAction=I.ScrollAxis=I.MouseButton=I.ButtonAction=I.XInputButtons=I.ArbitraryDatagram=I.MediaDatagram=I.LogicDatagram=I.InputDatagram=I.Chunk=I.RainwayHeader=I.Guid=I.TelemetryValueType=I.RainwayTelemetryDimension=I.RainwayTelemetryRecord=I.RainwayTelemetryRequest=I.TelemetryBatchesKeyTemplate=I.TelemetrySetKey=I.GatewayForwardableBody=I.PeerSignalingInformation=I.RejectedConnectionRequest=I.AcceptedConnectionRequest=I.ConnectionRequest=I.GatewayResponseBody=I.GatewayHello=I.GatewayRequestBody=I.InitConnectionRequest=I.GatewayBody=I.GatewayForwardable=I.GatewayAlert=I.GatewayResponse=I.GatewayRequest=I.GatewayDatagram=I.GatewayHeader=I.PendingConnectionRequest=I.Peer=I.GatewayIdentity=I.GatewayTrunk=I.PeerInformationType=I.PeerTransportType=I.GatewayAlertDescription=I.GatewayAlertLevel=I.GatewayResponseContext=I.PeerSetKeyTemplate=I.AcceptedConnectionRequestKeyTemplate=I.PendingConnectionRequestKeyTemplate=I.PeerKeyTemplate=I.DatagramChannel=void 0,I.LogicBody=I.InputLevelRequest=I.InputLevelUpdate=I.RejectStreamRequest=I.PauseStream=I.JoinStream=I.VideoBitrateRequest=I.KeyframeRequest=I.StreamStopping=I.LeaveStream=I.StreamStarting=I.StreamRequest=I.ErrorResponse=I.ClientCapabilities=I.CodecPackResponse=I.CodecPackRequest=I.DeviceInfo=I.InputLevel=I.VideoConfig=I.CaptureMode=I.AudioConfig=I.LogicError=I.VideoContainer=I.AudioContainer=I.AudioCodec=I.AudioChannels=I.NetworkProtocol=I.OperatingSystem=I.FormFactor=I.VideoCodec=I.Vendor=I.VideoCodecType=I.InputBody=I.SetClipboardText=I.ViewportResize=I.PenAbsolute=I.TouchesAbsolute=I.LogicalInput=I.KeyboardInput=I.MouseScroll=I.MouseClick=I.MouseRelative=I.MouseAbsolute=I.GamepadRumble=I.GamepadReport=I.TouchAbsolute=I.PenFlags=I.PenMask=I.TouchMask=I.TouchPenPointerInfo=void 0,I.MediaBody=I.MediaChunk=I.AudioData=I.PointerData=I.VideoData=I.DesktopRect=I.AudioDataType=I.VideoDataType=void 0;const e=g(120);var B,i,t,Q,C,E,o,a,n,s,r,d,h,c,D,w,u,y,l,S,F,R,G,k,p,U,m,N,f;I.DatagramChannel="network:datagrams",I.PeerKeyTemplate="network:peers:{0}",I.PendingConnectionRequestKeyTemplate="network:connection.requests:pending:{0}",I.AcceptedConnectionRequestKeyTemplate="network:connection.requests:accepted:{0}",I.PeerSetKeyTemplate="network:active.peers:{0}",I.GatewayResponseContext={encode(A){const I=e.BebopView.getInstance();return I.startWriting(),this.encodeInto(A,I),I.toArray()},encodeInto(A,g){const e=g.length;return g.writeInt64(A.sourcePeerId),g.writeInt64(A.targetPeerId),I.GatewayDatagram.encodeInto(A.datagram,g),g.length-e},decode(A){const I=e.BebopView.getInstance();return I.startReading(A),this.readFrom(I)},readFrom(A){let g,e,B;return g=A.readInt64(),e=A.readInt64(),B=I.GatewayDatagram.readFrom(A),{sourcePeerId:g,targetPeerId:e,datagram:B}}},(f=I.GatewayAlertLevel||(I.GatewayAlertLevel={}))[f.Unknown=0]="Unknown",f[f.Warning=1]="Warning",f[f.Fatal=2]="Fatal",(N=I.GatewayAlertDescription||(I.GatewayAlertDescription={}))[N.CloseNotify=0]="CloseNotify",N[N.UnexpectedMessage=10]="UnexpectedMessage",N[N.RecordOverflow=20]="RecordOverflow",N[N.TicketValidationError=30]="TicketValidationError",N[N.AccessDenied=49]="AccessDenied",N[N.DecodeError=50]="DecodeError",N[N.DecryptError=51]="DecryptError",N[N.ProtocolVersion=70]="ProtocolVersion",N[N.InternalError=80]="InternalError",N[N.PeerGoneAway=90]="PeerGoneAway",N[N.CommitFailure=100]="CommitFailure",N[N.ResourceExpired=200]="ResourceExpired",(m=I.PeerTransportType||(I.PeerTransportType={}))[m.Invalid=0]="Invalid",m[m.SCTP=1]="SCTP",m[m.GUDP=2]="GUDP",m[m.Reserved=3]="Reserved",(U=I.PeerInformationType||(I.PeerInformationType={}))[U.Invalid=0]="Invalid",U[U.Offer=1]="Offer",U[U.Answer=2]="Answer",U[U.Candidate=3]="Candidate",I.GatewayTrunk={encode(A){const I=e.BebopView.getInstance();return I.startWriting(),this.encodeInto(A,I),I.toArray()},encodeInto(A,I){const g=I.length;return I.writeString(A.machineId),I.writeDate(A.startDate),I.length-g},decode(A){const I=e.BebopView.getInstance();return I.startReading(A),this.readFrom(I)},readFrom(A){let I,g;return I=A.readString(),g=A.readDate(),{machineId:I,startDate:g}}},I.GatewayIdentity={encode(A){const I=e.BebopView.getInstance();return I.startWriting(),this.encodeInto(A,I),I.toArray()},encodeInto(A,I){const g=I.length;return I.writeString(A.apiKey),I.writeInt64(A.id),I.writeString(A.externalId),I.length-g},decode(A){const I=e.BebopView.getInstance();return I.startReading(A),this.readFrom(I)},readFrom(A){let I,g,e;return I=A.readString(),g=A.readInt64(),e=A.readString(),{apiKey:I,id:g,externalId:e}}},I.Peer={encode(A){const I=e.BebopView.getInstance();return I.startWriting(),this.encodeInto(A,I),I.toArray()},encodeInto(A,I){const g=I.length;return I.writeInt64(A.id),I.writeString(A.externalId),I.writeDate(A.connectionDate),I.writeInt64(A.organizationId),I.length-g},decode(A){const I=e.BebopView.getInstance();return I.startReading(A),this.readFrom(I)},readFrom(A){let I,g,e,B;return I=A.readInt64(),g=A.readString(),e=A.readDate(),B=A.readInt64(),{id:I,externalId:g,connectionDate:e,organizationId:B}}},I.PendingConnectionRequest={encode(A){const I=e.BebopView.getInstance();return I.startWriting(),this.encodeInto(A,I),I.toArray()},encodeInto(A,I){const g=I.length;return I.writeInt64(A.sourcePeerId),I.writeInt64(A.targetPeerId),I.length-g},decode(A){const I=e.BebopView.getInstance();return I.startReading(A),this.readFrom(I)},readFrom(A){let I,g;return I=A.readInt64(),g=A.readInt64(),{sourcePeerId:I,targetPeerId:g}}},I.GatewayHeader={encode(A){const I=e.BebopView.getInstance();return I.startWriting(),this.encodeInto(A,I),I.toArray()},encodeInto(A,I){const g=I.length;return I.writeUint32(A.syncKey),I.length-g},decode(A){const I=e.BebopView.getInstance();return I.startReading(A),this.readFrom(I)},readFrom(A){let I;return I=A.readUint32(),{syncKey:I}}},I.GatewayDatagram={encode(A){const I=e.BebopView.getInstance();return I.startWriting(),this.encodeInto(A,I),I.toArray()},encodeInto(A,g){const e=g.length;return I.GatewayHeader.encodeInto(A.header,g),I.GatewayBody.encodeInto(A.body,g),g.length-e},decode(A){const I=e.BebopView.getInstance();return I.startReading(A),this.readFrom(I)},readFrom(A){let g,e;return g=I.GatewayHeader.readFrom(A),e=I.GatewayBody.readFrom(A),{header:g,body:e}}},I.GatewayRequest={discriminator:1,encode(A){const I=e.BebopView.getInstance();return I.startWriting(),this.encodeInto(A,I),I.toArray()},encodeInto(A,g){const e=g.length;return I.GatewayRequestBody.encodeInto(A.body,g),g.length-e},decode(A){const I=e.BebopView.getInstance();return I.startReading(A),this.readFrom(I)},readFrom(A){let g;return g=I.GatewayRequestBody.readFrom(A),{body:g}}},I.GatewayResponse={discriminator:2,encode(A){const I=e.BebopView.getInstance();return I.startWriting(),this.encodeInto(A,I),I.toArray()},encodeInto(A,g){const e=g.length;return I.GatewayResponseBody.encodeInto(A.body,g),g.length-e},decode(A){const I=e.BebopView.getInstance();return I.startReading(A),this.readFrom(I)},readFrom(A){let g;return g=I.GatewayResponseBody.readFrom(A),{body:g}}},I.GatewayAlert={discriminator:3,encode(A){const I=e.BebopView.getInstance();return I.startWriting(),this.encodeInto(A,I),I.toArray()},encodeInto(A,I){const g=I.length;return I.writeUint32(A.level),I.writeUint32(A.description),I.length-g},decode(A){const I=e.BebopView.getInstance();return I.startReading(A),this.readFrom(I)},readFrom(A){let I,g;return I=A.readUint32(),g=A.readUint32(),{level:I,description:g}}},I.GatewayForwardable={discriminator:4,encode(A){const I=e.BebopView.getInstance();return I.startWriting(),this.encodeInto(A,I),I.toArray()},encodeInto(A,g){const e=g.length;return g.writeInt64(A.targetPeerId),I.GatewayForwardableBody.encodeInto(A.body,g),g.length-e},decode(A){const I=e.BebopView.getInstance();return I.startReading(A),this.readFrom(I)},readFrom(A){let g,e;return g=A.readInt64(),e=I.GatewayForwardableBody.readFrom(A),{targetPeerId:g,body:e}}},I.GatewayBody={encode(A){const I=e.BebopView.getInstance();return I.startWriting(),this.encodeInto(A,I),I.toArray()},encodeInto(A,g){const e=g.length,B=g.reserveMessageLength(),i=g.length+1;switch(g.writeByte(A.discriminator),A.discriminator){case 1:I.GatewayRequest.encodeInto(A.value,g);break;case 2:I.GatewayResponse.encodeInto(A.value,g);break;case 3:I.GatewayAlert.encodeInto(A.value,g);break;case 4:I.GatewayForwardable.encodeInto(A.value,g)}const t=g.length;return g.fillMessageLength(B,t-i),g.length-e},decode(A){const I=e.BebopView.getInstance();return I.startReading(A),this.readFrom(I)},readFrom(A){const g=A.readMessageLength(),B=A.index+1+g;switch(A.readByte()){case 1:return{discriminator:1,value:I.GatewayRequest.readFrom(A)};case 2:return{discriminator:2,value:I.GatewayResponse.readFrom(A)};case 3:return{discriminator:3,value:I.GatewayAlert.readFrom(A)};case 4:return{discriminator:4,value:I.GatewayForwardable.readFrom(A)};default:throw A.index=B,new e.BebopRuntimeError("Unrecognized discriminator while decoding GatewayBody")}}},I.InitConnectionRequest={discriminator:1,encode(A){const I=e.BebopView.getInstance();return I.startWriting(),this.encodeInto(A,I),I.toArray()},encodeInto(A,I){const g=I.length;return I.writeInt64(A.targetPeerId),I.writeUint32(A.desiredTransport),I.length-g},decode(A){const I=e.BebopView.getInstance();return I.startReading(A),this.readFrom(I)},readFrom(A){let I,g;return I=A.readInt64(),g=A.readUint32(),{targetPeerId:I,desiredTransport:g}}},I.GatewayRequestBody={encode(A){const I=e.BebopView.getInstance();return I.startWriting(),this.encodeInto(A,I),I.toArray()},encodeInto(A,g){const e=g.length,B=g.reserveMessageLength(),i=g.length+1;g.writeByte(A.discriminator),1===A.discriminator&&I.InitConnectionRequest.encodeInto(A.value,g);const t=g.length;return g.fillMessageLength(B,t-i),g.length-e},decode(A){const I=e.BebopView.getInstance();return I.startReading(A),this.readFrom(I)},readFrom(A){const g=A.readMessageLength(),B=A.index+1+g;if(1===A.readByte())return{discriminator:1,value:I.InitConnectionRequest.readFrom(A)};throw A.index=B,new e.BebopRuntimeError("Unrecognized discriminator while decoding GatewayRequestBody")}},I.GatewayHello={discriminator:1,encode(A){const I=e.BebopView.getInstance();return I.startWriting(),this.encodeInto(A,I),I.toArray()},encodeInto(A,I){const g=I.length;return I.length-g},decode(A){const I=e.BebopView.getInstance();return I.startReading(A),this.readFrom(I)},readFrom:A=>({})},I.GatewayResponseBody={encode(A){const I=e.BebopView.getInstance();return I.startWriting(),this.encodeInto(A,I),I.toArray()},encodeInto(A,g){const e=g.length,B=g.reserveMessageLength(),i=g.length+1;g.writeByte(A.discriminator),1===A.discriminator&&I.GatewayHello.encodeInto(A.value,g);const t=g.length;return g.fillMessageLength(B,t-i),g.length-e},decode(A){const I=e.BebopView.getInstance();return I.startReading(A),this.readFrom(I)},readFrom(A){const g=A.readMessageLength(),B=A.index+1+g;if(1===A.readByte())return{discriminator:1,value:I.GatewayHello.readFrom(A)};throw A.index=B,new e.BebopRuntimeError("Unrecognized discriminator while decoding GatewayResponseBody")}},I.ConnectionRequest={discriminator:1,encode(A){const I=e.BebopView.getInstance();return I.startWriting(),this.encodeInto(A,I),I.toArray()},encodeInto(A,I){const g=I.length;return I.writeInt64(A.sourcePeerId),I.writeString(A.sourceExternalId),I.writeUint32(A.desiredTransport),I.writeGuid(A.id),I.writeDate(A.expirationDate),I.length-g},decode(A){const I=e.BebopView.getInstance();return I.startReading(A),this.readFrom(I)},readFrom(A){let I,g,e,B,i;return I=A.readInt64(),g=A.readString(),e=A.readUint32(),B=A.readGuid(),i=A.readDate(),{sourcePeerId:I,sourceExternalId:g,desiredTransport:e,id:B,expirationDate:i}}},I.AcceptedConnectionRequest={discriminator:2,encode(A){const I=e.BebopView.getInstance();return I.startWriting(),this.encodeInto(A,I),I.toArray()},encodeInto(A,I){const g=I.length;return I.writeInt64(A.sourcePeerId),I.writeString(A.sourceExternalId),I.writeGuid(A.id),I.length-g},decode(A){const I=e.BebopView.getInstance();return I.startReading(A),this.readFrom(I)},readFrom(A){let I,g,e;return I=A.readInt64(),g=A.readString(),e=A.readGuid(),{sourcePeerId:I,sourceExternalId:g,id:e}}},I.RejectedConnectionRequest={discriminator:3,encode(A){const I=e.BebopView.getInstance();return I.startWriting(),this.encodeInto(A,I),I.toArray()},encodeInto(A,I){const g=I.length;return I.writeInt64(A.sourcePeerId),I.writeString(A.sourceExternalId),I.writeGuid(A.id),I.writeString(A.reason),I.length-g},decode(A){const I=e.BebopView.getInstance();return I.startReading(A),this.readFrom(I)},readFrom(A){let I,g,e,B;return I=A.readInt64(),g=A.readString(),e=A.readGuid(),B=A.readString(),{sourcePeerId:I,sourceExternalId:g,id:e,reason:B}}},I.PeerSignalingInformation={discriminator:4,encode(A){const I=e.BebopView.getInstance();return I.startWriting(),this.encodeInto(A,I),I.toArray()},encodeInto(A,I){const g=I.length;return I.writeGuid(A.id),I.writeUint32(A.type),I.writeString(A.data),I.length-g},decode(A){const I=e.BebopView.getInstance();return I.startReading(A),this.readFrom(I)},readFrom(A){let I,g,e;return I=A.readGuid(),g=A.readUint32(),e=A.readString(),{id:I,type:g,data:e}}},I.GatewayForwardableBody={encode(A){const I=e.BebopView.getInstance();return I.startWriting(),this.encodeInto(A,I),I.toArray()},encodeInto(A,g){const e=g.length,B=g.reserveMessageLength(),i=g.length+1;switch(g.writeByte(A.discriminator),A.discriminator){case 1:I.ConnectionRequest.encodeInto(A.value,g);break;case 2:I.AcceptedConnectionRequest.encodeInto(A.value,g);break;case 3:I.RejectedConnectionRequest.encodeInto(A.value,g);break;case 4:I.PeerSignalingInformation.encodeInto(A.value,g)}const t=g.length;return g.fillMessageLength(B,t-i),g.length-e},decode(A){const I=e.BebopView.getInstance();return I.startReading(A),this.readFrom(I)},readFrom(A){const g=A.readMessageLength(),B=A.index+1+g;switch(A.readByte()){case 1:return{discriminator:1,value:I.ConnectionRequest.readFrom(A)};case 2:return{discriminator:2,value:I.AcceptedConnectionRequest.readFrom(A)};case 3:return{discriminator:3,value:I.RejectedConnectionRequest.readFrom(A)};case 4:return{discriminator:4,value:I.PeerSignalingInformation.readFrom(A)};default:throw A.index=B,new e.BebopRuntimeError("Unrecognized discriminator while decoding GatewayForwardableBody")}}},I.TelemetrySetKey="network:telemetry:batches",I.TelemetryBatchesKeyTemplate="network:telemetry:batches:{0}",I.RainwayTelemetryRequest={encode(A){const I=e.BebopView.getInstance();return I.startWriting(),this.encodeInto(A,I),I.toArray()},encodeInto(A,g){const e=g.length,B=g.reserveMessageLength(),i=g.length;if(null!=A.records){g.writeByte(1);{const e=A.records.length;g.writeUint32(e);for(let B=0;B<e;B++)I.RainwayTelemetryRecord.encodeInto(A.records[B],g)}}null!=A.commonAttributes&&(g.writeByte(2),I.RainwayTelemetryRecord.encodeInto(A.commonAttributes,g)),g.writeByte(0);const t=g.length;return g.fillMessageLength(B,t-i),g.length-e},decode(A){const I=e.BebopView.getInstance();return I.startReading(A),this.readFrom(I)},readFrom(A){let g={};const e=A.readMessageLength(),B=A.index+e;for(;;)switch(A.readByte()){case 0:return g;case 1:{let e=A.readUint32();g.records=new Array(e);for(let B=0;B<e;B++){let e;e=I.RainwayTelemetryRecord.readFrom(A),g.records[B]=e}}break;case 2:g.commonAttributes=I.RainwayTelemetryRecord.readFrom(A);break;default:return A.index=B,g}}},I.RainwayTelemetryRecord={encode(A){const I=e.BebopView.getInstance();return I.startWriting(),this.encodeInto(A,I),I.toArray()},encodeInto(A,g){const e=g.length,B=g.reserveMessageLength(),i=g.length;if(null!=A.name&&(g.writeByte(1),g.writeString(A.name)),null!=A.value&&(g.writeByte(2),g.writeString(A.value)),null!=A.time&&(g.writeByte(3),g.writeDate(A.time)),null!=A.type&&(g.writeByte(4),g.writeUint32(A.type)),null!=A.dimensions){g.writeByte(5);{const e=A.dimensions.length;g.writeUint32(e);for(let B=0;B<e;B++)I.RainwayTelemetryDimension.encodeInto(A.dimensions[B],g)}}g.writeByte(0);const t=g.length;return g.fillMessageLength(B,t-i),g.length-e},decode(A){const I=e.BebopView.getInstance();return I.startReading(A),this.readFrom(I)},readFrom(A){let g={};const e=A.readMessageLength(),B=A.index+e;for(;;)switch(A.readByte()){case 0:return g;case 1:g.name=A.readString();break;case 2:g.value=A.readString();break;case 3:g.time=A.readDate();break;case 4:g.type=A.readUint32();break;case 5:{let e=A.readUint32();g.dimensions=new Array(e);for(let B=0;B<e;B++){let e;e=I.RainwayTelemetryDimension.readFrom(A),g.dimensions[B]=e}}break;default:return A.index=B,g}}},I.RainwayTelemetryDimension={encode(A){const I=e.BebopView.getInstance();return I.startWriting(),this.encodeInto(A,I),I.toArray()},encodeInto(A,I){const g=I.length;return I.writeString(A.name),I.writeString(A.value),I.length-g},decode(A){const I=e.BebopView.getInstance();return I.startReading(A),this.readFrom(I)},readFrom(A){let I,g;return I=A.readString(),g=A.readString(),{name:I,value:g}}},(p=I.TelemetryValueType||(I.TelemetryValueType={}))[p.Double=0]="Double",p[p.BigInt=1]="BigInt",p[p.VarChar=2]="VarChar",p[p.Bool=3]="Bool",I.Guid={encode(A){const I=e.BebopView.getInstance();return I.startWriting(),this.encodeInto(A,I),I.toArray()},encodeInto(A,I){const g=I.length;return I.writeGuid(A.value),I.length-g},decode(A){const I=e.BebopView.getInstance();return I.startReading(A),this.readFrom(I)},readFrom(A){let I;return I=A.readGuid(),{value:I}}},I.RainwayHeader={encode(A){const I=e.BebopView.getInstance();return I.startWriting(),this.encodeInto(A,I),I.toArray()},encodeInto(A,I){const g=I.length;return I.writeUint32(A.magicNumber),I.writeUint32(A.syncKey),I.writeInt64(A.sourcePeerId),I.writeInt64(A.targetPeerId),I.length-g},decode(A){const I=e.BebopView.getInstance();return I.startReading(A),this.readFrom(I)},readFrom(A){let I,g,e,B;return I=A.readUint32(),g=A.readUint32(),e=A.readInt64(),B=A.readInt64(),{magicNumber:I,syncKey:g,sourcePeerId:e,targetPeerId:B}}},I.Chunk={encode(A){const I=e.BebopView.getInstance();return I.startWriting(),this.encodeInto(A,I),I.toArray()},encodeInto(A,I){const g=I.length;return I.writeUint16(A.groupId),I.writeByte(A.index),I.writeByte(A.chunksInGroup),I.writeBytes(A.data),I.length-g},decode(A){const I=e.BebopView.getInstance();return I.startReading(A),this.readFrom(I)},readFrom(A){let I,g,e,B;return I=A.readUint16(),g=A.readByte(),e=A.readByte(),B=A.readBytes(),{groupId:I,index:g,chunksInGroup:e,data:B}}},I.InputDatagram={encode(A){const I=e.BebopView.getInstance();return I.startWriting(),this.encodeInto(A,I),I.toArray()},encodeInto(A,g){const e=g.length;return I.RainwayHeader.encodeInto(A.header,g),I.InputBody.encodeInto(A.body,g),g.length-e},decode(A){const I=e.BebopView.getInstance();return I.startReading(A),this.readFrom(I)},readFrom(A){let g,e;return g=I.RainwayHeader.readFrom(A),e=I.InputBody.readFrom(A),{header:g,body:e}}},I.LogicDatagram={encode(A){const I=e.BebopView.getInstance();return I.startWriting(),this.encodeInto(A,I),I.toArray()},encodeInto(A,g){const e=g.length;return I.RainwayHeader.encodeInto(A.header,g),I.LogicBody.encodeInto(A.body,g),g.length-e},decode(A){const I=e.BebopView.getInstance();return I.startReading(A),this.readFrom(I)},readFrom(A){let g,e;return g=I.RainwayHeader.readFrom(A),e=I.LogicBody.readFrom(A),{header:g,body:e}}},I.MediaDatagram={encode(A){const I=e.BebopView.getInstance();return I.startWriting(),this.encodeInto(A,I),I.toArray()},encodeInto(A,g){const e=g.length;return I.RainwayHeader.encodeInto(A.header,g),I.MediaBody.encodeInto(A.body,g),g.length-e},decode(A){const I=e.BebopView.getInstance();return I.startReading(A),this.readFrom(I)},readFrom(A){let g,e;return g=I.RainwayHeader.readFrom(A),e=I.MediaBody.readFrom(A),{header:g,body:e}}},I.ArbitraryDatagram={encode(A){const I=e.BebopView.getInstance();return I.startWriting(),this.encodeInto(A,I),I.toArray()},encodeInto(A,g){const e=g.length;return I.RainwayHeader.encodeInto(A.header,g),I.Chunk.encodeInto(A.body,g),g.length-e},decode(A){const I=e.BebopView.getInstance();return I.startReading(A),this.readFrom(I)},readFrom(A){let g,e;return g=I.RainwayHeader.readFrom(A),e=I.Chunk.readFrom(A),{header:g,body:e}}},(k=I.XInputButtons||(I.XInputButtons={}))[k.None=0]="None",k[k.DpadUp=1]="DpadUp",k[k.DpadDown=2]="DpadDown",k[k.DpadLeft=4]="DpadLeft",k[k.DpadRight=8]="DpadRight",k[k.Start=16]="Start",k[k.Back=32]="Back",k[k.LeftStick=64]="LeftStick",k[k.RightStick=128]="RightStick",k[k.LeftBumper=256]="LeftBumper",k[k.RightBumper=512]="RightBumper",k[k.Guide=1024]="Guide",k[k.A=4096]="A",k[k.B=8192]="B",k[k.X=16384]="X",k[k.Y=32768]="Y",(G=I.ButtonAction||(I.ButtonAction={}))[G.ButtonDown=0]="ButtonDown",G[G.ButtonUp=1]="ButtonUp",(R=I.MouseButton||(I.MouseButton={}))[R.Left=0]="Left",R[R.Right=1]="Right",R[R.Middle=2]="Middle",R[R.X1=3]="X1",R[R.X2=4]="X2",(F=I.ScrollAxis||(I.ScrollAxis={}))[F.Horizontal=0]="Horizontal",F[F.Vertical=1]="Vertical",(S=I.KeyboardAction||(I.KeyboardAction={}))[S.KeyDown=0]="KeyDown",S[S.KeyUp=1]="KeyUp",(l=I.VirtualKey||(I.VirtualKey={}))[l.None=0]="None",l[l.Cancel=1]="Cancel",l[l.Back=2]="Back",l[l.Tab=3]="Tab",l[l.LineFeed=4]="LineFeed",l[l.Clear=5]="Clear",l[l.Enter=6]="Enter",l[l.Pause=7]="Pause",l[l.CapsLock=8]="CapsLock",l[l.HangulMode=9]="HangulMode",l[l.JunjaMode=10]="JunjaMode",l[l.FinalMode=11]="FinalMode",l[l.HanjaMode=12]="HanjaMode",l[l.Escape=13]="Escape",l[l.ImeConvert=14]="ImeConvert",l[l.ImeNonConvert=15]="ImeNonConvert",l[l.ImeAccept=16]="ImeAccept",l[l.ImeModeChange=17]="ImeModeChange",l[l.Space=18]="Space",l[l.PageUp=19]="PageUp",l[l.PageDown=20]="PageDown",l[l.End=21]="End",l[l.Home=22]="Home",l[l.Left=23]="Left",l[l.Up=24]="Up",l[l.Right=25]="Right",l[l.Down=26]="Down",l[l.Select=27]="Select",l[l.Print=28]="Print",l[l.Execute=29]="Execute",l[l.PrintScreen=30]="PrintScreen",l[l.Insert=31]="Insert",l[l.Delete=32]="Delete",l[l.Help=33]="Help",l[l.D0=34]="D0",l[l.D1=35]="D1",l[l.D2=36]="D2",l[l.D3=37]="D3",l[l.D4=38]="D4",l[l.D5=39]="D5",l[l.D6=40]="D6",l[l.D7=41]="D7",l[l.D8=42]="D8",l[l.D9=43]="D9",l[l.A=44]="A",l[l.B=45]="B",l[l.C=46]="C",l[l.D=47]="D",l[l.E=48]="E",l[l.F=49]="F",l[l.G=50]="G",l[l.H=51]="H",l[l.I=52]="I",l[l.J=53]="J",l[l.K=54]="K",l[l.L=55]="L",l[l.M=56]="M",l[l.N=57]="N",l[l.O=58]="O",l[l.P=59]="P",l[l.Q=60]="Q",l[l.R=61]="R",l[l.S=62]="S",l[l.T=63]="T",l[l.U=64]="U",l[l.V=65]="V",l[l.W=66]="W",l[l.X=67]="X",l[l.Y=68]="Y",l[l.Z=69]="Z",l[l.LWin=70]="LWin",l[l.RWin=71]="RWin",l[l.Apps=72]="Apps",l[l.Sleep=73]="Sleep",l[l.NumPad0=74]="NumPad0",l[l.NumPad1=75]="NumPad1",l[l.NumPad2=76]="NumPad2",l[l.NumPad3=77]="NumPad3",l[l.NumPad4=78]="NumPad4",l[l.NumPad5=79]="NumPad5",l[l.NumPad6=80]="NumPad6",l[l.NumPad7=81]="NumPad7",l[l.NumPad8=82]="NumPad8",l[l.NumPad9=83]="NumPad9",l[l.Multiply=84]="Multiply",l[l.Add=85]="Add",l[l.Separator=86]="Separator",l[l.Subtract=87]="Subtract",l[l.Decimal=88]="Decimal",l[l.Divide=89]="Divide",l[l.F1=90]="F1",l[l.F2=91]="F2",l[l.F3=92]="F3",l[l.F4=93]="F4",l[l.F5=94]="F5",l[l.F6=95]="F6",l[l.F7=96]="F7",l[l.F8=97]="F8",l[l.F9=98]="F9",l[l.F10=99]="F10",l[l.F11=100]="F11",l[l.F12=101]="F12",l[l.F13=102]="F13",l[l.F14=103]="F14",l[l.F15=104]="F15",l[l.F16=105]="F16",l[l.F17=106]="F17",l[l.F18=107]="F18",l[l.F19=108]="F19",l[l.F20=109]="F20",l[l.F21=110]="F21",l[l.F22=111]="F22",l[l.F23=112]="F23",l[l.F24=113]="F24",l[l.NumLock=114]="NumLock",l[l.Scroll=115]="Scroll",l[l.LeftShift=116]="LeftShift",l[l.RightShift=117]="RightShift",l[l.LeftCtrl=118]="LeftCtrl",l[l.RightCtrl=119]="RightCtrl",l[l.LeftAlt=120]="LeftAlt",l[l.RightAlt=121]="RightAlt",l[l.BrowserBack=122]="BrowserBack",l[l.BrowserForward=123]="BrowserForward",l[l.BrowserRefresh=124]="BrowserRefresh",l[l.BrowserStop=125]="BrowserStop",l[l.BrowserSearch=126]="BrowserSearch",l[l.BrowserFavorites=127]="BrowserFavorites",l[l.BrowserHome=128]="BrowserHome",l[l.VolumeMute=129]="VolumeMute",l[l.VolumeDown=130]="VolumeDown",l[l.VolumeUp=131]="VolumeUp",l[l.MediaNextTrack=132]="MediaNextTrack",l[l.MediaPreviousTrack=133]="MediaPreviousTrack",l[l.MediaStop=134]="MediaStop",l[l.MediaPlayPause=135]="MediaPlayPause",l[l.LaunchMail=136]="LaunchMail",l[l.SelectMedia=137]="SelectMedia",l[l.LaunchApplication1=138]="LaunchApplication1",l[l.LaunchApplication2=139]="LaunchApplication2",l[l.Oem1=140]="Oem1",l[l.OemPlus=141]="OemPlus",l[l.OemComma=142]="OemComma",l[l.OemMinus=143]="OemMinus",l[l.OemPeriod=144]="OemPeriod",l[l.Oem2=145]="Oem2",l[l.Oem3=146]="Oem3",l[l.AbntC1=147]="AbntC1",l[l.AbntC2=148]="AbntC2",l[l.Oem4=149]="Oem4",l[l.Oem5=150]="Oem5",l[l.Oem6=151]="Oem6",l[l.Oem7=152]="Oem7",l[l.Oem8=153]="Oem8",l[l.Oem102=154]="Oem102",l[l.ImeProcessed=155]="ImeProcessed",l[l.System=156]="System",l[l.OemAttn=157]="OemAttn",l[l.OemFinish=158]="OemFinish",l[l.OemCopy=159]="OemCopy",l[l.OemAuto=160]="OemAuto",l[l.OemEnlw=161]="OemEnlw",l[l.OemBackTab=162]="OemBackTab",l[l.Attn=163]="Attn",l[l.CrSel=164]="CrSel",l[l.ExSel=165]="ExSel",l[l.EraseEof=166]="EraseEof",l[l.Play=167]="Play",l[l.Zoom=168]="Zoom",l[l.NoName=169]="NoName",l[l.Pa1=170]="Pa1",l[l.OemClear=171]="OemClear",l[l.DeadCharProcessed=172]="DeadCharProcessed",(y=I.WindowsPointerFlags||(I.WindowsPointerFlags={}))[y.New=1]="New",y[y.InRange=2]="InRange",y[y.InContact=4]="InContact",y[y.FirstButton=16]="FirstButton",y[y.SecondButton=32]="SecondButton",y[y.ThirdButton=64]="ThirdButton",y[y.FourthButton=128]="FourthButton",y[y.FifthButton=256]="FifthButton",y[y.Primary=8192]="Primary",y[y.Confidence=16384]="Confidence",y[y.Canceled=32768]="Canceled",y[y.Down=65536]="Down",y[y.Update=131072]="Update",y[y.Up=262144]="Up",y[y.Wheel=524288]="Wheel",y[y.HWheel=1048576]="HWheel",y[y.CaptureChanged=2097152]="CaptureChanged",y[y.HasTransform=4194304]="HasTransform",I.TouchPenPointerInfo={encode(A){const I=e.BebopView.getInstance();return I.startWriting(),this.encodeInto(A,I),I.toArray()},encodeInto(A,I){const g=I.length;return I.writeUint32(A.pointerId),I.writeUint32(A.frameId),I.writeUint32(A.pointerFlags),I.writeInt32(A.x),I.writeInt32(A.y),I.length-g},decode(A){const I=e.BebopView.getInstance();return I.startReading(A),this.readFrom(I)},readFrom(A){let I,g,e,B,i;return I=A.readUint32(),g=A.readUint32(),e=A.readUint32(),B=A.readInt32(),i=A.readInt32(),{pointerId:I,frameId:g,pointerFlags:e,x:B,y:i}}},(u=I.TouchMask||(I.TouchMask={}))[u.ContactArea=1]="ContactArea",u[u.Orientation=2]="Orientation",u[u.Pressure=4]="Pressure",(w=I.PenMask||(I.PenMask={}))[w.Pressure=1]="Pressure",w[w.Rotation=2]="Rotation",w[w.TiltX=4]="TiltX",w[w.TiltY=8]="TiltY",(D=I.PenFlags||(I.PenFlags={}))[D.Barrel=1]="Barrel",D[D.Inverted=2]="Inverted",D[D.Eraser=4]="Eraser",I.TouchAbsolute={encode(A){const I=e.BebopView.getInstance();return I.startWriting(),this.encodeInto(A,I),I.toArray()},encodeInto(A,g){const e=g.length;return I.TouchPenPointerInfo.encodeInto(A.pointerInfo,g),g.writeUint32(A.touchMask),g.writeInt32(A.contactLeft),g.writeInt32(A.contactTop),g.writeInt32(A.contactRight),g.writeInt32(A.contactBottom),g.writeUint32(A.orientation),g.writeUint32(A.pressure),g.length-e},decode(A){const I=e.BebopView.getInstance();return I.startReading(A),this.readFrom(I)},readFrom(A){let g,e,B,i,t,Q,C,E;return g=I.TouchPenPointerInfo.readFrom(A),e=A.readUint32(),B=A.readInt32(),i=A.readInt32(),t=A.readInt32(),Q=A.readInt32(),C=A.readUint32(),E=A.readUint32(),{pointerInfo:g,touchMask:e,contactLeft:B,contactTop:i,contactRight:t,contactBottom:Q,orientation:C,pressure:E}}},I.GamepadReport={discriminator:1,encode(A){const I=e.BebopView.getInstance();return I.startWriting(),this.encodeInto(A,I),I.toArray()},encodeInto(A,I){const g=I.length;return I.writeUint32(A.buttons),I.writeByte(A.leftTrigger),I.writeByte(A.rightTrigger),I.writeInt16(A.leftThumbX),I.writeInt16(A.leftThumbY),I.writeInt16(A.rightThumbX),I.writeInt16(A.rightThumbY),I.writeByte(A.slot),I.length-g},decode(A){const I=e.BebopView.getInstance();return I.startReading(A),this.readFrom(I)},readFrom(A){let I,g,e,B,i,t,Q,C;return I=A.readUint32(),g=A.readByte(),e=A.readByte(),B=A.readInt16(),i=A.readInt16(),t=A.readInt16(),Q=A.readInt16(),C=A.readByte(),{buttons:I,leftTrigger:g,rightTrigger:e,leftThumbX:B,leftThumbY:i,rightThumbX:t,rightThumbY:Q,slot:C}}},I.GamepadRumble={discriminator:2,encode(A){const I=e.BebopView.getInstance();return I.startWriting(),this.encodeInto(A,I),I.toArray()},encodeInto(A,I){const g=I.length;return I.writeByte(A.port),I.writeUint16(A.leftMotorSpeed),I.writeUint16(A.rightMotorSpeed),I.length-g},decode(A){const I=e.BebopView.getInstance();return I.startReading(A),this.readFrom(I)},readFrom(A){let I,g,e;return I=A.readByte(),g=A.readUint16(),e=A.readUint16(),{port:I,leftMotorSpeed:g,rightMotorSpeed:e}}},I.MouseAbsolute={discriminator:3,encode(A){const I=e.BebopView.getInstance();return I.startWriting(),this.encodeInto(A,I),I.toArray()},encodeInto(A,I){const g=I.length;return I.writeInt32(A.x),I.writeInt32(A.y),I.length-g},decode(A){const I=e.BebopView.getInstance();return I.startReading(A),this.readFrom(I)},readFrom(A){let I,g;return I=A.readInt32(),g=A.readInt32(),{x:I,y:g}}},I.MouseRelative={discriminator:4,encode(A){const I=e.BebopView.getInstance();return I.startWriting(),this.encodeInto(A,I),I.toArray()},encodeInto(A,I){const g=I.length;return I.writeInt32(A.dx),I.writeInt32(A.dy),I.length-g},decode(A){const I=e.BebopView.getInstance();return I.startReading(A),this.readFrom(I)},readFrom(A){let I,g;return I=A.readInt32(),g=A.readInt32(),{dx:I,dy:g}}},I.MouseClick={discriminator:5,encode(A){const I=e.BebopView.getInstance();return I.startWriting(),this.encodeInto(A,I),I.toArray()},encodeInto(A,I){const g=I.length;return I.writeUint32(A.action),I.writeUint32(A.button),I.length-g},decode(A){const I=e.BebopView.getInstance();return I.startReading(A),this.readFrom(I)},readFrom(A){let I,g;return I=A.readUint32(),g=A.readUint32(),{action:I,button:g}}},I.MouseScroll={discriminator:6,encode(A){const I=e.BebopView.getInstance();return I.startWriting(),this.encodeInto(A,I),I.toArray()},encodeInto(A,I){const g=I.length;return I.writeUint32(A.axis),I.writeInt32(A.delta),I.length-g},decode(A){const I=e.BebopView.getInstance();return I.startReading(A),this.readFrom(I)},readFrom(A){let I,g;return I=A.readUint32(),g=A.readInt32(),{axis:I,delta:g}}},I.KeyboardInput={discriminator:7,encode(A){const I=e.BebopView.getInstance();return I.startWriting(),this.encodeInto(A,I),I.toArray()},encodeInto(A,I){const g=I.length;return I.writeUint32(A.action),I.writeUint32(A.keycode),I.length-g},decode(A){const I=e.BebopView.getInstance();return I.startReading(A),this.readFrom(I)},readFrom(A){let I,g;return I=A.readUint32(),g=A.readUint32(),{action:I,keycode:g}}},I.LogicalInput={discriminator:8,encode(A){const I=e.BebopView.getInstance();return I.startWriting(),this.encodeInto(A,I),I.toArray()},encodeInto(A,I){const g=I.length;return I.writeString(A.inputString),I.length-g},decode(A){const I=e.BebopView.getInstance();return I.startReading(A),this.readFrom(I)},readFrom(A){let I;return I=A.readString(),{inputString:I}}},I.TouchesAbsolute={discriminator:9,encode(A){const I=e.BebopView.getInstance();return I.startWriting(),this.encodeInto(A,I),I.toArray()},encodeInto(A,g){const e=g.length;{const e=A.touches.length;g.writeUint32(e);for(let B=0;B<e;B++)I.TouchAbsolute.encodeInto(A.touches[B],g)}return g.length-e},decode(A){const I=e.BebopView.getInstance();return I.startReading(A),this.readFrom(I)},readFrom(A){let g;{let e=A.readUint32();g=new Array(e);for(let B=0;B<e;B++){let e;e=I.TouchAbsolute.readFrom(A),g[B]=e}}return{touches:g}}},I.PenAbsolute={discriminator:10,encode(A){const I=e.BebopView.getInstance();return I.startWriting(),this.encodeInto(A,I),I.toArray()},encodeInto(A,g){const e=g.length;return I.TouchPenPointerInfo.encodeInto(A.pointerInfo,g),g.writeUint32(A.penFlags),g.writeUint32(A.penMask),g.writeUint32(A.pressure),g.writeUint32(A.rotation),g.writeInt32(A.tiltX),g.writeInt32(A.tiltY),g.length-e},decode(A){const I=e.BebopView.getInstance();return I.startReading(A),this.readFrom(I)},readFrom(A){let g,e,B,i,t,Q,C;return g=I.TouchPenPointerInfo.readFrom(A),e=A.readUint32(),B=A.readUint32(),i=A.readUint32(),t=A.readUint32(),Q=A.readInt32(),C=A.readInt32(),{pointerInfo:g,penFlags:e,penMask:B,pressure:i,rotation:t,tiltX:Q,tiltY:C}}},I.ViewportResize={discriminator:11,encode(A){const I=e.BebopView.getInstance();return I.startWriting(),this.encodeInto(A,I),I.toArray()},encodeInto(A,I){const g=I.length;return I.writeUint32(A.width),I.writeUint32(A.height),I.length-g},decode(A){const I=e.BebopView.getInstance();return I.startReading(A),this.readFrom(I)},readFrom(A){let I,g;return I=A.readUint32(),g=A.readUint32(),{width:I,height:g}}},I.SetClipboardText={discriminator:12,encode(A){const I=e.BebopView.getInstance();return I.startWriting(),this.encodeInto(A,I),I.toArray()},encodeInto(A,I){const g=I.length;return I.writeString(A.text),I.length-g},decode(A){const I=e.BebopView.getInstance();return I.startReading(A),this.readFrom(I)},readFrom(A){let I;return I=A.readString(),{text:I}}},I.InputBody={encode(A){const I=e.BebopView.getInstance();return I.startWriting(),this.encodeInto(A,I),I.toArray()},encodeInto(A,g){const e=g.length,B=g.reserveMessageLength(),i=g.length+1;switch(g.writeByte(A.discriminator),A.discriminator){case 1:I.GamepadReport.encodeInto(A.value,g);break;case 2:I.GamepadRumble.encodeInto(A.value,g);break;case 3:I.MouseAbsolute.encodeInto(A.value,g);break;case 4:I.MouseRelative.encodeInto(A.value,g);break;case 5:I.MouseClick.encodeInto(A.value,g);break;case 6:I.MouseScroll.encodeInto(A.value,g);break;case 7:I.KeyboardInput.encodeInto(A.value,g);break;case 8:I.LogicalInput.encodeInto(A.value,g);break;case 9:I.TouchesAbsolute.encodeInto(A.value,g);break;case 10:I.PenAbsolute.encodeInto(A.value,g);break;case 11:I.ViewportResize.encodeInto(A.value,g);break;case 12:I.SetClipboardText.encodeInto(A.value,g)}const t=g.length;return g.fillMessageLength(B,t-i),g.length-e},decode(A){const I=e.BebopView.getInstance();return I.startReading(A),this.readFrom(I)},readFrom(A){const g=A.readMessageLength(),B=A.index+1+g;switch(A.readByte()){case 1:return{discriminator:1,value:I.GamepadReport.readFrom(A)};case 2:return{discriminator:2,value:I.GamepadRumble.readFrom(A)};case 3:return{discriminator:3,value:I.MouseAbsolute.readFrom(A)};case 4:return{discriminator:4,value:I.MouseRelative.readFrom(A)};case 5:return{discriminator:5,value:I.MouseClick.readFrom(A)};case 6:return{discriminator:6,value:I.MouseScroll.readFrom(A)};case 7:return{discriminator:7,value:I.KeyboardInput.readFrom(A)};case 8:return{discriminator:8,value:I.LogicalInput.readFrom(A)};case 9:return{discriminator:9,value:I.TouchesAbsolute.readFrom(A)};case 10:return{discriminator:10,value:I.PenAbsolute.readFrom(A)};case 11:return{discriminator:11,value:I.ViewportResize.readFrom(A)};case 12:return{discriminator:12,value:I.SetClipboardText.readFrom(A)};default:throw A.index=B,new e.BebopRuntimeError("Unrecognized discriminator while decoding InputBody")}}},(c=I.VideoCodecType||(I.VideoCodecType={}))[c.Baseline=1]="Baseline",c[c.Main=2]="Main",c[c.High=4]="High",c[c.H264=7]="H264",c[c.H265=8]="H265",(h=I.Vendor||(I.Vendor={}))[h.Unknown=0]="Unknown",h[h.Amd=4098]="Amd",h[h.Nvidia=4318]="Nvidia",h[h.Intel=32902]="Intel",I.VideoCodec={encode(A){const I=e.BebopView.getInstance();return I.startWriting(),this.encodeInto(A,I),I.toArray()},encodeInto(A,I){const g=I.length;return I.writeString(A.friendlyName),I.writeUint32(A.width),I.writeUint32(A.height),I.writeUint32(A.refreshRate),I.writeBytes(A.data),I.writeUint32(A.type),I.length-g},decode(A){const I=e.BebopView.getInstance();return I.startReading(A),this.readFrom(I)},readFrom(A){let I,g,e,B,i,t;return I=A.readString(),g=A.readUint32(),e=A.readUint32(),B=A.readUint32(),i=A.readBytes(),t=A.readUint32(),{friendlyName:I,width:g,height:e,refreshRate:B,data:i,type:t}}},(d=I.FormFactor||(I.FormFactor={}))[d.Unknown=0]="Unknown",d[d.Phone=1]="Phone",d[d.Tablet=2]="Tablet",d[d.Computer=3]="Computer",d[d.Console=4]="Console",d[d.Tv=5]="Tv",(r=I.OperatingSystem||(I.OperatingSystem={}))[r.Other=0]="Other",r[r.IOS=1]="IOS",r[r.TvOS=2]="TvOS",r[r.Android=3]="Android",r[r.Windows=4]="Windows",r[r.MacOS=5]="MacOS",r[r.Linux=6]="Linux",r[r.Roku=7]="Roku",(s=I.NetworkProtocol||(I.NetworkProtocol={}))[s.WebRTC=0]="WebRTC",s[s.Geyser=1]="Geyser",(n=I.AudioChannels||(I.AudioChannels={}))[n.Mono=0]="Mono",n[n.Stereo=1]="Stereo",n[n.Surround51=2]="Surround51",n[n.Surround71=3]="Surround71",(a=I.AudioCodec||(I.AudioCodec={}))[a.Opus=0]="Opus",a[a.Aac=1]="Aac",(o=I.AudioContainer||(I.AudioContainer={}))[o.Raw=0]="Raw",o[o.WebM=1]="WebM",o[o.IsoBMFF=2]="IsoBMFF",(E=I.VideoContainer||(I.VideoContainer={}))[E.Raw=0]="Raw",E[E.IsoBMFF=1]="IsoBMFF",(C=I.LogicError||(I.LogicError={}))[C.UnknownError=0]="UnknownError",C[C.DisplaysMissing=1]="DisplaysMissing",C[C.NoAvailableEncoder=2]="NoAvailableEncoder",C[C.InvalidEncodingConfig=3]="InvalidEncodingConfig",C[C.NoCodecsExchanged=4]="NoCodecsExchanged",C[C.NoCapabilities=5]="NoCapabilities",C[C.NoSuchStream=6]="NoSuchStream",C[C.ForceSegmentFailed=7]="ForceSegmentFailed",I.AudioConfig={encode(A){const I=e.BebopView.getInstance();return I.startWriting(),this.encodeInto(A,I),I.toArray()},encodeInto(A,I){const g=I.length;return I.writeUint32(A.codec),I.writeUint32(A.container),I.length-g},decode(A){const I=e.BebopView.getInstance();return I.startReading(A),this.readFrom(I)},readFrom(A){let I,g;return I=A.readUint32(),g=A.readUint32(),{codec:I,container:g}}},(Q=I.CaptureMode||(I.CaptureMode={}))[Q.Unknown=0]="Unknown",Q[Q.FullDesktop=1]="FullDesktop",Q[Q.AppIsolation=2]="AppIsolation",Q[Q.Direct=3]="Direct",I.VideoConfig={encode(A){const I=e.BebopView.getInstance();return I.startWriting(),this.encodeInto(A,I),I.toArray()},encodeInto(A,g){const e=g.length;return I.VideoCodec.encodeInto(A.codec,g),g.writeUint32(A.container),g.length-e},decode(A){const I=e.BebopView.getInstance();return I.startReading(A),this.readFrom(I)},readFrom(A){let g,e;return g=I.VideoCodec.readFrom(A),e=A.readUint32(),{codec:g,container:e}}},(t=I.InputLevel||(I.InputLevel={}))[t.None=0]="None",t[t.GamepadPort1=1]="GamepadPort1",t[t.GamepadPort2=2]="GamepadPort2",t[t.GamepadPort3=4]="GamepadPort3",t[t.GamepadPort4=8]="GamepadPort4",t[t.Gamepad=15]="Gamepad",t[t.Mouse=16]="Mouse",t[t.Keyboard=32]="Keyboard",t[t.Clipboard=64]="Clipboard",t[t.All=63]="All",I.DeviceInfo={discriminator:1,encode(A){const I=e.BebopView.getInstance();return I.startWriting(),this.encodeInto(A,I),I.toArray()},encodeInto(A,I){const g=I.length;return I.writeUint32(A.formFactor),I.writeString(A.deviceName),I.writeUint32(A.deviceOs),I.writeString(A.deviceOsVersion),I.writeString(A.deviceModel),I.writeString(A.userAgent),I.writeString(A.deviceId),I.writeByte(Number(A.isWeb)),I.length-g},decode(A){const I=e.BebopView.getInstance();return I.startReading(A),this.readFrom(I)},readFrom(A){let I,g,e,B,i,t,Q,C;return I=A.readUint32(),g=A.readString(),e=A.readUint32(),B=A.readString(),i=A.readString(),t=A.readString(),Q=A.readString(),C=!!A.readByte(),{formFactor:I,deviceName:g,deviceOs:e,deviceOsVersion:B,deviceModel:i,userAgent:t,deviceId:Q,isWeb:C}}},I.CodecPackRequest={discriminator:2,encode(A){const I=e.BebopView.getInstance();return I.startWriting(),this.encodeInto(A,I),I.toArray()},encodeInto(A,I){const g=I.length;return I.length-g},decode(A){const I=e.BebopView.getInstance();return I.startReading(A),this.readFrom(I)},readFrom:A=>({})},I.CodecPackResponse={discriminator:3,encode(A){const I=e.BebopView.getInstance();return I.startWriting(),this.encodeInto(A,I),I.toArray()},encodeInto(A,g){const e=g.length;{const e=A.videoCodecs.length;g.writeUint32(e);for(let B=0;B<e;B++)I.VideoCodec.encodeInto(A.videoCodecs[B],g)}return g.length-e},decode(A){const I=e.BebopView.getInstance();return I.startReading(A),this.readFrom(I)},readFrom(A){let g;{let e=A.readUint32();g=new Array(e);for(let B=0;B<e;B++){let e;e=I.VideoCodec.readFrom(A),g[B]=e}}return{videoCodecs:g}}},I.ClientCapabilities={discriminator:4,encode(A){const I=e.BebopView.getInstance();return I.startWriting(),this.encodeInto(A,I),I.toArray()},encodeInto(A,g){const e=g.length;g.writeUint32(A.preferredWidth),g.writeUint32(A.preferredHeight),g.writeUint32(A.preferredFps),g.writeUint32(A.preferredAudioBitrate),g.writeUint32(A.preferredVideoBitrate),g.writeUint32(A.preferredAudioChannels),I.AudioConfig.encodeInto(A.preferredAudioConfig,g),I.VideoConfig.encodeInto(A.preferredVideoConfig,g);{const I=A.supportedAudioChannels.length;g.writeUint32(I);for(let e=0;e<I;e++)g.writeUint32(A.supportedAudioChannels[e])}{const e=A.supportedAudioConfigs.length;g.writeUint32(e);for(let B=0;B<e;B++)I.AudioConfig.encodeInto(A.supportedAudioConfigs[B],g)}{const e=A.supportedVideoConfigs.length;g.writeUint32(e);for(let B=0;B<e;B++)I.VideoConfig.encodeInto(A.supportedVideoConfigs[B],g)}return g.writeByte(Number(A.supportsOver1080P)),g.writeByte(Number(A.supportsTemporalScaling)),g.writeByte(Number(A.supportsAppIsolation)),g.length-e},decode(A){const I=e.BebopView.getInstance();return I.startReading(A),this.readFrom(I)},readFrom(A){let g,e,B,i,t,Q,C,E,o,a,n,s,r,d;g=A.readUint32(),e=A.readUint32(),B=A.readUint32(),i=A.readUint32(),t=A.readUint32(),Q=A.readUint32(),C=I.AudioConfig.readFrom(A),E=I.VideoConfig.readFrom(A);{let I=A.readUint32();o=new Array(I);for(let g=0;g<I;g++){let I;I=A.readUint32(),o[g]=I}}{let g=A.readUint32();a=new Array(g);for(let e=0;e<g;e++){let g;g=I.AudioConfig.readFrom(A),a[e]=g}}{let g=A.readUint32();n=new Array(g);for(let e=0;e<g;e++){let g;g=I.VideoConfig.readFrom(A),n[e]=g}}return s=!!A.readByte(),r=!!A.readByte(),d=!!A.readByte(),{preferredWidth:g,preferredHeight:e,preferredFps:B,preferredAudioBitrate:i,preferredVideoBitrate:t,preferredAudioChannels:Q,preferredAudioConfig:C,preferredVideoConfig:E,supportedAudioChannels:o,supportedAudioConfigs:a,supportedVideoConfigs:n,supportsOver1080P:s,supportsTemporalScaling:r,supportsAppIsolation:d}}},I.ErrorResponse={discriminator:5,encode(A){const I=e.BebopView.getInstance();return I.startWriting(),this.encodeInto(A,I),I.toArray()},encodeInto(A,I){const g=I.length;return I.writeUint32(A.error),I.length-g},decode(A){const I=e.BebopView.getInstance();return I.startReading(A),this.readFrom(I)},readFrom(A){let I;return I=A.readUint32(),{error:I}}},I.StreamRequest={discriminator:6,encode(A){const I=e.BebopView.getInstance();return I.startWriting(),this.encodeInto(A,I),I.toArray()},encodeInto(A,I){const g=I.length;return I.writeUint32(A.inputLevel),I.length-g},decode(A){const I=e.BebopView.getInstance();return I.startReading(A),this.readFrom(I)},readFrom(A){let I;return I=A.readUint32(),{inputLevel:I}}},I.StreamStarting={discriminator:7,encode(A){const I=e.BebopView.getInstance();return I.startWriting(),this.encodeInto(A,I),I.toArray()},encodeInto(A,g){const e=g.length;return g.writeByte(A.streamId),g.writeUint32(A.inputLevel),g.writeFloat32(A.temporalScaleFactor),I.AudioConfig.encodeInto(A.chosenAudioConfig,g),I.VideoConfig.encodeInto(A.chosenVideoConfig,g),g.writeUint32(A.captureMode),g.length-e},decode(A){const I=e.BebopView.getInstance();return I.startReading(A),this.readFrom(I)},readFrom(A){let g,e,B,i,t,Q;return g=A.readByte(),e=A.readUint32(),B=A.readFloat32(),i=I.AudioConfig.readFrom(A),t=I.VideoConfig.readFrom(A),Q=A.readUint32(),{streamId:g,inputLevel:e,temporalScaleFactor:B,chosenAudioConfig:i,chosenVideoConfig:t,captureMode:Q}}},I.LeaveStream={discriminator:8,encode(A){const I=e.BebopView.getInstance();return I.startWriting(),this.encodeInto(A,I),I.toArray()},encodeInto(A,I){const g=I.length;return I.writeByte(A.streamId),I.length-g},decode(A){const I=e.BebopView.getInstance();return I.startReading(A),this.readFrom(I)},readFrom(A){let I;return I=A.readByte(),{streamId:I}}},I.StreamStopping={discriminator:9,encode(A){const I=e.BebopView.getInstance();return I.startWriting(),this.encodeInto(A,I),I.toArray()},encodeInto(A,I){const g=I.length;return I.writeByte(A.streamId),I.length-g},decode(A){const I=e.BebopView.getInstance();return I.startReading(A),this.readFrom(I)},readFrom(A){let I;return I=A.readByte(),{streamId:I}}},I.KeyframeRequest={discriminator:10,encode(A){const I=e.BebopView.getInstance();return I.startWriting(),this.encodeInto(A,I),I.toArray()},encodeInto(A,I){const g=I.length;return I.writeByte(A.streamId),I.length-g},decode(A){const I=e.BebopView.getInstance();return I.startReading(A),this.readFrom(I)},readFrom(A){let I;return I=A.readByte(),{streamId:I}}},I.VideoBitrateRequest={discriminator:11,encode(A){const I=e.BebopView.getInstance();return I.startWriting(),this.encodeInto(A,I),I.toArray()},encodeInto(A,I){const g=I.length;return I.writeByte(A.streamId),I.writeUint32(A.bitsPerSecond),I.length-g},decode(A){const I=e.BebopView.getInstance();return I.startReading(A),this.readFrom(I)},readFrom(A){let I,g;return I=A.readByte(),g=A.readUint32(),{streamId:I,bitsPerSecond:g}}},I.JoinStream={discriminator:12,encode(A){const I=e.BebopView.getInstance();return I.startWriting(),this.encodeInto(A,I),I.toArray()},encodeInto(A,I){const g=I.length;return I.writeByte(A.streamId),I.length-g},decode(A){const I=e.BebopView.getInstance();return I.startReading(A),this.readFrom(I)},readFrom(A){let I;return I=A.readByte(),{streamId:I}}},I.PauseStream={discriminator:13,encode(A){const I=e.BebopView.getInstance();return I.startWriting(),this.encodeInto(A,I),I.toArray()},encodeInto(A,I){const g=I.length;return I.writeByte(A.streamId),I.length-g},decode(A){const I=e.BebopView.getInstance();return I.startReading(A),this.readFrom(I)},readFrom(A){let I;return I=A.readByte(),{streamId:I}}},I.RejectStreamRequest={discriminator:14,encode(A){const I=e.BebopView.getInstance();return I.startWriting(),this.encodeInto(A,I),I.toArray()},encodeInto(A,I){const g=I.length;return I.writeString(A.reason),I.length-g},decode(A){const I=e.BebopView.getInstance();return I.startReading(A),this.readFrom(I)},readFrom(A){let I;return I=A.readString(),{reason:I}}},I.InputLevelUpdate={discriminator:15,encode(A){const I=e.BebopView.getInstance();return I.startWriting(),this.encodeInto(A,I),I.toArray()},encodeInto(A,I){const g=I.length;return I.writeByte(A.streamId),I.writeUint32(A.inputLevel),I.length-g},decode(A){const I=e.BebopView.getInstance();return I.startReading(A),this.readFrom(I)},readFrom(A){let I,g;return I=A.readByte(),g=A.readUint32(),{streamId:I,inputLevel:g}}},I.InputLevelRequest={discriminator:16,encode(A){const I=e.BebopView.getInstance();return I.startWriting(),this.encodeInto(A,I),I.toArray()},encodeInto(A,I){const g=I.length;return I.writeByte(A.streamId),I.writeUint32(A.inputLevel),I.length-g},decode(A){const I=e.BebopView.getInstance();return I.startReading(A),this.readFrom(I)},readFrom(A){let I,g;return I=A.readByte(),g=A.readUint32(),{streamId:I,inputLevel:g}}},I.LogicBody={encode(A){const I=e.BebopView.getInstance();return I.startWriting(),this.encodeInto(A,I),I.toArray()},encodeInto(A,g){const e=g.length,B=g.reserveMessageLength(),i=g.length+1;switch(g.writeByte(A.discriminator),A.discriminator){case 1:I.DeviceInfo.encodeInto(A.value,g);break;case 2:I.CodecPackRequest.encodeInto(A.value,g);break;case 3:I.CodecPackResponse.encodeInto(A.value,g);break;case 4:I.ClientCapabilities.encodeInto(A.value,g);break;case 5:I.ErrorResponse.encodeInto(A.value,g);break;case 6:I.StreamRequest.encodeInto(A.value,g);break;case 7:I.StreamStarting.encodeInto(A.value,g);break;case 8:I.LeaveStream.encodeInto(A.value,g);break;case 9:I.StreamStopping.encodeInto(A.value,g);break;case 10:I.KeyframeRequest.encodeInto(A.value,g);break;case 11:I.VideoBitrateRequest.encodeInto(A.value,g);break;case 12:I.JoinStream.encodeInto(A.value,g);break;case 13:I.PauseStream.encodeInto(A.value,g);break;case 14:I.RejectStreamRequest.encodeInto(A.value,g);break;case 15:I.InputLevelUpdate.encodeInto(A.value,g);break;case 16:I.InputLevelRequest.encodeInto(A.value,g)}const t=g.length;return g.fillMessageLength(B,t-i),g.length-e},decode(A){const I=e.BebopView.getInstance();return I.startReading(A),this.readFrom(I)},readFrom(A){const g=A.readMessageLength(),B=A.index+1+g;switch(A.readByte()){case 1:return{discriminator:1,value:I.DeviceInfo.readFrom(A)};case 2:return{discriminator:2,value:I.CodecPackRequest.readFrom(A)};case 3:return{discriminator:3,value:I.CodecPackResponse.readFrom(A)};case 4:return{discriminator:4,value:I.ClientCapabilities.readFrom(A)};case 5:return{discriminator:5,value:I.ErrorResponse.readFrom(A)};case 6:return{discriminator:6,value:I.StreamRequest.readFrom(A)};case 7:return{discriminator:7,value:I.StreamStarting.readFrom(A)};case 8:return{discriminator:8,value:I.LeaveStream.readFrom(A)};case 9:return{discriminator:9,value:I.StreamStopping.readFrom(A)};case 10:return{discriminator:10,value:I.KeyframeRequest.readFrom(A)};case 11:return{discriminator:11,value:I.VideoBitrateRequest.readFrom(A)};case 12:return{discriminator:12,value:I.JoinStream.readFrom(A)};case 13:return{discriminator:13,value:I.PauseStream.readFrom(A)};case 14:return{discriminator:14,value:I.RejectStreamRequest.readFrom(A)};case 15:return{discriminator:15,value:I.InputLevelUpdate.readFrom(A)};case 16:return{discriminator:16,value:I.InputLevelRequest.readFrom(A)};default:throw A.index=B,new e.BebopRuntimeError("Unrecognized discriminator while decoding LogicBody")}}},(i=I.VideoDataType||(I.VideoDataType={}))[i.Metadata=0]="Metadata",i[i.CleanPointFrame=1]="CleanPointFrame",i[i.FrameDiff=2]="FrameDiff",(B=I.AudioDataType||(I.AudioDataType={}))[B.Metadata=0]="Metadata",B[B.Frame=1]="Frame",I.DesktopRect={encode(A){const I=e.BebopView.getInstance();return I.startWriting(),this.encodeInto(A,I),I.toArray()},encodeInto(A,I){const g=I.length;return I.writeInt32(A.left),I.writeInt32(A.top),I.writeUint32(A.width),I.writeUint32(A.height),I.length-g},decode(A){const I=e.BebopView.getInstance();return I.startReading(A),this.readFrom(I)},readFrom(A){let I,g,e,B;return I=A.readInt32(),g=A.readInt32(),e=A.readUint32(),B=A.readUint32(),{left:I,top:g,width:e,height:B}}},I.VideoData={discriminator:1,encode(A){const I=e.BebopView.getInstance();return I.startWriting(),this.encodeInto(A,I),I.toArray()},encodeInto(A,g){const e=g.length;g.writeBytes(A.data),g.writeUint64(A.segmentTime),g.writeUint32(A.type),g.writeByte(A.streamId),I.DesktopRect.encodeInto(A.desktopRect,g);{const e=A.mask.length;g.writeUint32(e);for(let B=0;B<e;B++)I.DesktopRect.encodeInto(A.mask[B],g)}return g.length-e},decode(A){const I=e.BebopView.getInstance();return I.startReading(A),this.readFrom(I)},readFrom(A){let g,e,B,i,t,Q;g=A.readBytes(),e=A.readUint64(),B=A.readUint32(),i=A.readByte(),t=I.DesktopRect.readFrom(A);{let g=A.readUint32();Q=new Array(g);for(let e=0;e<g;e++){let g;g=I.DesktopRect.readFrom(A),Q[e]=g}}return{data:g,segmentTime:e,type:B,streamId:i,desktopRect:t,mask:Q}}},I.PointerData={discriminator:2,encode(A){const I=e.BebopView.getInstance();return I.startWriting(),this.encodeInto(A,I),I.toArray()},encodeInto(A,I){const g=I.length;return I.writeBytes(A.data),I.writeUint32(A.monitorWidth),I.writeUint32(A.monitorHeight),I.writeUint32(A.shapeWidth),I.writeUint32(A.shapeHeight),I.writeInt32(A.spotX),I.writeInt32(A.spotY),I.writeByte(Number(A.visible)),I.writeInt32(A.positionX),I.writeInt32(A.positionY),I.writeByte(A.streamId),I.length-g},decode(A){const I=e.BebopView.getInstance();return I.startReading(A),this.readFrom(I)},readFrom(A){let I,g,e,B,i,t,Q,C,E,o,a;return I=A.readBytes(),g=A.readUint32(),e=A.readUint32(),B=A.readUint32(),i=A.readUint32(),t=A.readInt32(),Q=A.readInt32(),C=!!A.readByte(),E=A.readInt32(),o=A.readInt32(),a=A.readByte(),{data:I,monitorWidth:g,monitorHeight:e,shapeWidth:B,shapeHeight:i,spotX:t,spotY:Q,visible:C,positionX:E,positionY:o,streamId:a}}},I.AudioData={discriminator:3,encode(A){const I=e.BebopView.getInstance();return I.startWriting(),this.encodeInto(A,I),I.toArray()},encodeInto(A,I){const g=I.length;return I.writeBytes(A.data),I.writeUint32(A.type),I.writeByte(A.streamId),I.length-g},decode(A){const I=e.BebopView.getInstance();return I.startReading(A),this.readFrom(I)},readFrom(A){let I,g,e;return I=A.readBytes(),g=A.readUint32(),e=A.readByte(),{data:I,type:g,streamId:e}}},I.MediaChunk={discriminator:4,encode(A){const I=e.BebopView.getInstance();return I.startWriting(),this.encodeInto(A,I),I.toArray()},encodeInto(A,g){const e=g.length;return I.Chunk.encodeInto(A.chunk,g),g.length-e},decode(A){const I=e.BebopView.getInstance();return I.startReading(A),this.readFrom(I)},readFrom(A){let g;return g=I.Chunk.readFrom(A),{chunk:g}}},I.MediaBody={encode(A){const I=e.BebopView.getInstance();return I.startWriting(),this.encodeInto(A,I),I.toArray()},encodeInto(A,g){const e=g.length,B=g.reserveMessageLength(),i=g.length+1;switch(g.writeByte(A.discriminator),A.discriminator){case 1:I.VideoData.encodeInto(A.value,g);break;case 2:I.PointerData.encodeInto(A.value,g);break;case 3:I.AudioData.encodeInto(A.value,g);break;case 4:I.MediaChunk.encodeInto(A.value,g)}const t=g.length;return g.fillMessageLength(B,t-i),g.length-e},decode(A){const I=e.BebopView.getInstance();return I.startReading(A),this.readFrom(I)},readFrom(A){const g=A.readMessageLength(),B=A.index+1+g;switch(A.readByte()){case 1:return{discriminator:1,value:I.VideoData.readFrom(A)};case 2:return{discriminator:2,value:I.PointerData.readFrom(A)};case 3:return{discriminator:3,value:I.AudioData.readFrom(A)};case 4:return{discriminator:4,value:I.MediaChunk.readFrom(A)};default:throw A.index=B,new e.BebopRuntimeError("Unrecognized discriminator while decoding MediaBody")}}}},14:function(A,I,g){"use strict";var e=this&&this.__createBinding||(Object.create?function(A,I,g,e){void 0===e&&(e=g),Object.defineProperty(A,e,{enumerable:!0,get:function(){return I[g]}})}:function(A,I,g,e){void 0===e&&(e=g),A[e]=I[g]}),B=this&&this.__exportStar||function(A,I){for(var g in A)"default"===g||Object.prototype.hasOwnProperty.call(I,g)||e(I,A,g)};Object.defineProperty(I,"__esModule",{value:!0}),I.RainwayError=I.HeldKeys=I.InputType=I.RainwayStreamFit=I.RainwayStream=I.RainwayRuntime=I.RainwayTransportStatus=I.RainwayTransport=I.RTCTransport=I.friendlyGamepadName=I.RainwayLogLevel=I.RainwayLogging=I.RainwayChannelMode=I.RainwayPeer=I.RainwayPeerState=void 0;var i=g(783);Object.defineProperty(I,"RainwayPeerState",{enumerable:!0,get:function(){return i.RainwayPeerState}});var t=g(420);Object.defineProperty(I,"RainwayPeer",{enumerable:!0,get:function(){return t.RainwayPeer}}),Object.defineProperty(I,"RainwayChannelMode",{enumerable:!0,get:function(){return t.RainwayChannelMode}});var Q=g(464);Object.defineProperty(I,"RainwayLogging",{enumerable:!0,get:function(){return Q.RainwayLogging}}),Object.defineProperty(I,"RainwayLogLevel",{enumerable:!0,get:function(){return Q.RainwayLogLevel}});var C=g(99);Object.defineProperty(I,"friendlyGamepadName",{enumerable:!0,get:function(){return C.friendlyGamepadName}});var E=g(145);Object.defineProperty(I,"RTCTransport",{enumerable:!0,get:function(){return E.RTCTransport}});var o=g(9);Object.defineProperty(I,"RainwayTransport",{enumerable:!0,get:function(){return o.RainwayTransport}}),Object.defineProperty(I,"RainwayTransportStatus",{enumerable:!0,get:function(){return o.RainwayTransportStatus}});var a=g(783);Object.defineProperty(I,"RainwayRuntime",{enumerable:!0,get:function(){return a.RainwayRuntime}});var n=g(876);Object.defineProperty(I,"RainwayStream",{enumerable:!0,get:function(){return n.RainwayStream}});var s=g(425);Object.defineProperty(I,"RainwayStreamFit",{enumerable:!0,get:function(){return s.RainwayStreamFit}});var r=g(884);Object.defineProperty(I,"InputType",{enumerable:!0,get:function(){return r.InputType}}),Object.defineProperty(I,"HeldKeys",{enumerable:!0,get:function(){return r.HeldKeys}});var d=g(994);Object.defineProperty(I,"RainwayError",{enumerable:!0,get:function(){return d.RainwayError}}),B(g(904),I)},65:(A,I)=>{"use strict";Object.defineProperty(I,"__esModule",{value:!0}),I.RainwayCursorPainter=void 0,I.RainwayCursorPainter=class{constructor(A,I,g,e=100){this.correctRemoteCursor=A,this.transformPointerOffsetToRemote=I,this.getCurrentFrameSize=g,this.cursorSyncInterval=e,this.container=void 0,this.video=void 0,this.canvas=void 0,this.cursorDiv=void 0,this.cursorImg=void 0,this.cursorState={visible:!1,x:0,y:0,spotX:0,spotY:0,extentWidth:0,extentHeight:0},this.wantsRemotePosition=!0,this.videoRect=new DOMRect(0,0,0,0),this.windowWidth=void 0,this.windowHeight=void 0,this.drawDebugDot=!1,this.debugDot=void 0,this.setVideoDimensions=()=>{for(const A of[this.video,this.canvas]){if(!A)continue;const I=A.getBoundingClientRect();if(I.width>0&&I.height>0)return this.videoRect=I,void this.applyCursorDivTransform()}},this.cursorSyncCounter=this.cursorSyncInterval,this.videoResizeObserver=new ResizeObserver((()=>{this.setVideoDimensions()})),["webkitfullscreenchange","mozfullscreenchange","fullscreenchange","MSFullscreenChange"].forEach((A=>{document.addEventListener(A,this.setVideoDimensions,!1)})),window.addEventListener("resize",this.setWindowDimensions)}detach(){["webkitfullscreenchange","mozfullscreenchange","fullscreenchange","MSFullscreenChange"].forEach((A=>{document.removeEventListener(A,this.setVideoDimensions,!1)})),window.removeEventListener("resize",this.setWindowDimensions),this.videoResizeObserver.disconnect()}setWindowDimensions(){this.windowWidth=window.innerWidth,this.windowHeight=window.innerHeight}setContainer(A){this.container=A,A.style.overflow="hidden",this.video&&this.videoResizeObserver.unobserve(this.video),this.canvas&&this.videoResizeObserver.unobserve(this.canvas),this.cursorDiv=void 0;const I=A.childNodes;for(let A=0;A<I.length;A++){const g=I[A];g instanceof HTMLVideoElement?(this.video=g,this.setVideoDimensions(),this.videoResizeObserver.observe(this.video)):g instanceof HTMLCanvasElement&&(g.classList.contains("rainway-canvas")||g.classList.contains("rainway-isolation-canvas"))?(this.canvas=g,this.setVideoDimensions(),this.videoResizeObserver.observe(this.canvas)):g instanceof HTMLDivElement&&(g.className.includes("rainway-cursor")?this.cursorDiv=g:g.className.includes("rainway-debug-dot")&&(this.debugDot=g))}this.cursorDiv||(this.cursorDiv=document.createElement("div"),this.cursorDiv.className="rainway-cursor",this.cursorDiv.style.position="absolute",this.cursorDiv.style.top="0px",this.cursorDiv.style.left="0px",this.cursorDiv.style.zIndex="1",this.cursorDiv.style.pointerEvents="none",this.cursorDiv.style.willChange="transform",this.cursorDiv.style.transformOrigin="top left",this.applyCursorDivTransform(),this.cursorImg=document.createElement("img"),this.cursorDiv.appendChild(this.cursorImg),A.appendChild(this.cursorDiv)),this.drawDebugDot&&!this.debugDot&&(this.debugDot=document.createElement("div"),this.debugDot.className="rainway-debug-dot",this.debugDot.style.position="absolute",this.debugDot.style.top="0px",this.debugDot.style.left="0px",this.debugDot.style.zIndex="1",this.debugDot.style.pointerEvents="none",this.debugDot.style.willChange="transform",this.debugDot.style.transformOrigin="top left",this.debugDot.style.width="3px",this.debugDot.style.height="3px",this.debugDot.style.backgroundColor="#ff0000",A.appendChild(this.debugDot))}unsetContainer(){var A,I;this.detach(),null===(A=this.cursorDiv)||void 0===A||A.remove(),null===(I=this.debugDot)||void 0===I||I.remove(),this.container=void 0}computeTransform(A){var I,g;const{x:e,y:B,spotX:i,spotY:t}=A,Q={left:0,top:0,width:A.extentWidth,height:A.extentHeight},{width:C,height:E}=this.videoRect,o=this.getCurrentFrameSize(),a=o.codecWidth,n=o.codecHeight,s=null!==(I=o.streamBounds)&&void 0!==I?I:Q,r=null!==(g=o.fullDesktopBounds)&&void 0!==g?g:Q,{left:d,top:h,width:c,height:D}=r,{left:w,top:u,width:y,height:l}=s,S=y*a/c,F=l*n/D,R=Math.min(C/S,E/F),G=Math.round(e-i-(w-d)),k=Math.round(B-t-(u-h)),p=R*a/c,U=R*n/D;return`translate(${Math.round((C-R*S)/2)}px,${Math.round((E-R*F)/2)}px) scale(${p},${U}) translate(${G}px,${k}px)`}applyCursorDivTransform(){this.cursorDiv&&(this.cursorState.visible?(this.cursorDiv.style.visibility="visible",this.cursorDiv.style.transform=this.computeTransform(this.cursorState)):this.cursorDiv.style.visibility="hidden")}moveDebugDotTo(A){this.debugDot&&(this.debugDot.style.transform=this.computeTransform(A))}processCursor(A){if(this.cursorDiv)if(A.visible&&!this.cursorState.visible&&(this.wantsRemotePosition=!0),this.cursorState.visible=A.visible,this.cursorState.spotX=A.spotX,this.cursorState.spotY=A.spotY,this.cursorState.extentWidth=A.extentWidth,this.cursorState.extentHeight=A.extentHeight,this.drawDebugDot&&this.moveDebugDotTo(A),this.cursorState.visible){if(this.wantsRemotePosition?(this.cursorState.x=A.x,this.cursorState.y=A.y,this.wantsRemotePosition=!1,this.cursorSyncCounter=this.cursorSyncInterval):0==--this.cursorSyncCounter&&(this.correctRemoteCursor(this.cursorState.x,this.cursorState.y),this.cursorSyncCounter=this.cursorSyncInterval),this.cursorDiv.style.width=`${A.shapeWidth}px`,this.cursorDiv.style.height=`${A.shapeHeight}px`,A.hasPointerImage&&this.cursorImg){const I=function(A){let I="";const g=new Uint8Array(A),e=g.byteLength;for(let A=0;A<e;A++)I+=String.fromCharCode(g[A]);return window.btoa(I)}(A.pointerImage);this.cursorImg.src=`data:image/png;base64,${I}`}this.applyCursorDivTransform()}else this.cursorDiv.style.visibility="hidden"}update(A,I,g){var e;if(this.cursorDiv&&("pointermove"===A.type||"mousemove"===A.type)){if("mouse"!==(null!==(e=A.pointerType)&&void 0!==e?e:"mouse")){const A=this.transformPointerOffsetToRemote(I,g);A&&(this.cursorState.x=A.x,this.cursorState.y=A.y)}else{const I=this.cursorState,g=A.movementX,e=A.movementY,B=this.getCurrentFrameSize();if(B.streamBounds){const{top:A,left:i,height:t,width:Q}=B.streamBounds;this.cursorState.x=Math.max(i,Math.min(I.x+g,i+Q)),this.cursorState.y=Math.max(A,Math.min(I.y+e,A+t))}else console.warn("Don't have streamBounds in CursorPainter.update?"),this.cursorState.x=Math.max(0,Math.min(I.x+g,I.extentWidth)),this.cursorState.y=Math.max(0,Math.min(I.y+e,I.extentHeight))}this.applyCursorDivTransform()}}}},99:(A,I)=>{"use strict";Object.defineProperty(I,"__esModule",{value:!0}),I.friendlyGamepadName=void 0;const g={"054c":{"0268":"DualShock 3","05c4":"DualShock 4","09cc":"DualShock 4 (2nd Gen)"},"2dc8":{6101:"N30 Pro"},"0955":{b400:"NVIDIA Shield"},2563:{"0523":"ShanWan PS3 Controller"},"045e":{"02d1":"Xbox One Controller","02dd":"Xbox One Controller (Firmware 2015)","02e3":"Xbox One Elite Controller","02ea":"Xbox One S Controller","02fd":"Xbox One S Controller (Bluetooth)","028f":"Xbox360 Wireless Controller","028e":"Xbox360 Controller","0289":"Xbox Controller S","0285":"Xbox Controller S","0202":"Xbox Controller"},"046d":{c299:"G25 Racing Wheel",c29B:"G27 Racing Wheel",caa3:"DriveFX Racing Wheel",c295:"Momo Force Steering Wheel",c298:"Driving Force Pro"}};I.friendlyGamepadName=function(A,I){var e,B,i,t;const Q=A.id.split("(")[0].trim()||"Unknown gamepad",C=A.id.match(/\b([0-9a-f]{4})\b.*\b([0-9a-f]{4})\b/);if(!C)return Q;const E=C[1],o=C[2];return null!==(t=null!==(B=null===(e=null==I?void 0:I[E])||void 0===e?void 0:e[o])&&void 0!==B?B:null===(i=g[E])||void 0===i?void 0:i[o])&&void 0!==t?t:Q}},322:(A,I)=>{"use strict";Object.defineProperty(I,"__esModule",{value:!0}),I.RainwayGestureRecognizer=void 0;const g={clickDurationMs:60,dragDelayMs:300,rightClickDelayMs:500,touchSlopRadius:8,doubleTapWindowMs:400,doubleTapRadius:12,scrollGestureThresholdPixels:20,scrollEpsilonPixels:5,scrollSensitivity:4};var e,B,i;function t(A){return A==B.left?1:A==B.middle?4:A==B.right?2:0}!function(A){A[A.idle=0]="idle",A[A.oneFingerDeciding=1]="oneFingerDeciding",A[A.twoFingersDeciding=2]="twoFingersDeciding",A[A.moving=3]="moving",A[A.dragging=4]="dragging",A[A.holdingRightMouseButton=5]="holdingRightMouseButton",A[A.zooming=6]="zooming",A[A.scrolling=7]="scrolling"}(e||(e={})),function(A){A[A.left=0]="left",A[A.middle=1]="middle",A[A.right=2]="right"}(B||(B={})),function(A){A[A.pixels=0]="pixels",A[A.lines=1]="lines",A[A.pages=2]="pages"}(i||(i={})),I.RainwayGestureRecognizer=class{constructor(A,I,i=g){this.reportPointerEvent=A,this.reportWheelEvent=I,this.parameters=i,this.state=e.idle,this.primary=void 0,this.secondary=void 0,this.centroidY=0,this.lastTapTime=new Date,this.rightClickTimer=void 0,this.rightClick=()=>{this.reportMouseDown(B.right),this.toState(e.holdingRightMouseButton),this.rightClickTimer=void 0},this.tapReleaseTimer=void 0,this.tapRelease=()=>{this.reportMouseUp(B.left),this.toState(e.idle),this.rightClickTimer=void 0},this.onPointerDown=A=>{const I={pointerId:A.pointerId,homeOffsetX:A.offsetX,homeOffsetY:A.offsetY,currentOffsetX:A.offsetX,currentOffsetY:A.offsetY,downTime:new Date,awake:!1};void 0===this.primary?(this.toState(e.oneFingerDeciding),this.primary=I,window.clearTimeout(this.rightClickTimer),this.rightClickTimer=window.setTimeout(this.rightClick,this.parameters.rightClickDelayMs)):void 0===this.secondary&&(this.toState(e.twoFingersDeciding),this.secondary=I,window.clearTimeout(this.rightClickTimer))},this.onPointerUp=A=>{var I;window.clearTimeout(this.rightClickTimer);const g=A.pointerId===(null===(I=this.primary)||void 0===I?void 0:I.pointerId);if(this.state===e.oneFingerDeciding&&g){this.log("pointer up from deciding, tapping"),window.clearTimeout(this.rightClickTimer);const I=Object.assign(Object.assign({},A),{offsetX:A.offsetX,offsetY:A.offsetY,pointerType:"touch",type:"pointermove"});this.reportPointerEvent(I),this.reportMouseDown(B.left),this.primary=void 0,this.lastTapTime=new Date,this.tapReleaseTimer=window.setTimeout(this.tapRelease,this.parameters.clickDurationMs)}else this.primary&&this.secondary?(this.log("stopping two finger gesture"),this.primary=void 0,this.secondary=void 0,this.toState(e.idle)):this.state===e.moving&&g?(this.log("stop moving"),this.primary=void 0,this.toState(e.idle)):this.state===e.dragging&&g?(this.log("stop dragging"),this.reportMouseUp(B.left),this.primary=void 0,this.toState(e.idle)):this.state===e.holdingRightMouseButton&&g&&(this.log("stop right click"),this.reportMouseUp(B.right),this.primary=void 0,this.toState(e.idle))},this.onPointerMove=A=>{var I,g;const i=A.pointerId===(null===(I=this.primary)||void 0===I?void 0:I.pointerId),t=A.pointerId===(null===(g=this.secondary)||void 0===g?void 0:g.pointerId);if(this.primary&&i?(this.primary.currentOffsetX=A.offsetX,this.primary.currentOffsetY=A.offsetY):this.secondary&&t&&(this.secondary.currentOffsetX=A.offsetX,this.secondary.currentOffsetY=A.offsetY),this.primary&&i&&!this.secondary)this.state===e.oneFingerDeciding&&function(A,I){const g=A.currentOffsetX-A.homeOffsetX,e=A.currentOffsetY-A.homeOffsetY;return g*g+e*e>I*I}(this.primary,this.parameters.touchSlopRadius)?(this.log("left touch slop radius"),window.clearTimeout(this.rightClickTimer),this.primary.awake=!0,(new Date).valueOf()-this.lastTapTime.valueOf()<this.parameters.dragDelayMs?(this.reportMouseDown(B.left),this.toState(e.dragging)):this.toState(e.moving)):this.state!==e.dragging&&this.state!==e.moving&&this.state!==e.holdingRightMouseButton||this.reportPointerEvent(A);else if(this.primary&&this.secondary)if(this.state===e.twoFingersDeciding){const A=this.primary.currentOffsetY-this.primary.homeOffsetY,I=this.secondary.currentOffsetY-this.secondary.homeOffsetY,g=this.parameters.scrollGestureThresholdPixels;(A>g&&I>g||A<g&&I<g)&&(this.toState(e.scrolling),this.centroidY=(A+I)/2)}else if(this.state===e.scrolling){const A=this.parameters.scrollEpsilonPixels,I=(this.primary.currentOffsetY-this.primary.homeOffsetY+(this.secondary.currentOffsetY-this.secondary.homeOffsetY))/2;I>this.centroidY+A?(this.reportScroll(this.parameters.scrollSensitivity*A),this.centroidY=I):I<this.centroidY-A&&(this.reportScroll(this.parameters.scrollSensitivity*-A),this.centroidY=I)}}}log(...A){}reportMouseUp(A){this.log("--\x3e report pointerup",A);const I=new PointerEvent("pointerup",{pointerType:"mouse",buttons:0,button:A});this.reportPointerEvent(I)}reportMouseDown(A){this.log("--\x3e report pointerdown",A);const I=new PointerEvent("pointerdown",{pointerType:"mouse",buttons:t(A),button:A});this.reportPointerEvent(I)}reportScroll(A){const I=new WheelEvent("syntheticWheel",{deltaY:A,deltaMode:i.pixels});this.reportWheelEvent(I)}toState(A){this.log(["idle","oneFingerDeciding","twoFingersDeciding","moving","dragging","holdingRightMouseButton","zooming","scrolling"][A]),this.state=A}processPointerEvent(A){if("touch"===A.pointerType)switch(A.type){case"pointerdown":this.onPointerDown(A);break;case"pointerup":this.onPointerUp(A);break;case"pointerrawupdate":case"pointermove":this.onPointerMove(A)}else this.reportPointerEvent(A)}}},824:(A,I,g)=>{"use strict";Object.defineProperty(I,"__esModule",{value:!0}),I.RainwayInputManager=I.mouseClickFrom=void 0;const e=g(994),B=g(904),i=g(40),t=g(322),Q=g(65),C=g(528),E=g(904),o=g(884);function a(A){let I,g;switch(A.button){default:case 0:I=0!=(1&A.buttons),g=E.MouseButton.Left;break;case 1:I=0!=(4&A.buttons),g=E.MouseButton.Middle;break;case 2:I=0!=(2&A.buttons),g=E.MouseButton.Right;break;case 3:I=0!=(8&A.buttons),g=E.MouseButton.X1;break;case 4:I=0!=(16&A.buttons),g=E.MouseButton.X2}return{button:g,action:I?E.ButtonAction.ButtonDown:E.ButtonAction.ButtonUp}}function n(A){return A.axes.length>=4&&A.buttons.length>=16}function s(A,I){if(A===I)return!0;if(A.length!==I.length)return!1;for(let g=0;g<A.length;++g)if(A[g]!==I[g])return!1;return!0}I.mouseClickFrom=a,I.RainwayInputManager=class{constructor(A,I={touchGestures:!1,unlockedMousePointer:!1,embraceMouseAcceleration:!1}){this.rainwayStream=A,this.options=I,this.level=B.InputLevel.None,this.container=void 0,this.heldKeys=new Set,this.alwaysReportGamepadPoll=!0,this.lockPointer=()=>{if(this.options.unlockedMousePointer)return;if(!this.container)return;if(!this.container.requestPointerLock)return;const A=!this.options.embraceMouseAcceleration,I=A?this.container.requestPointerLock({unadjustedMovement:!0}):this.container.requestPointerLock();I instanceof Promise?I.catch((I=>{var g;"NotSupportedError"===I.name&&A&&(null===(g=this.container)||void 0===g||g.requestPointerLock())})):this.container.onpointerlockerror=()=>{var I;A&&(null===(I=this.container)||void 0===I||I.requestPointerLock())},this.container.focus()},this.focusContainer=()=>{var A;return null===(A=this.container)||void 0===A?void 0:A.focus()},this.onPointerEventWithGestureProcessing=A=>{(A.pointerType&&"mouse"!==A.pointerType||document.pointerLockElement===this.container)&&(this.options.touchGestures&&"touch"===A.pointerType?(A.preventDefault(),this.gestureRecognizer.processPointerEvent(A)):this.onPointerEvent(A))},this.onPointerEventFromGestureRecognizer=A=>{this.onPointerEvent(A)},this.onPointerEvent=A=>{this.cursorPainter.update(A,this.rememberedOffsetX,this.rememberedOffsetY),this.reportPointerEvent(A)},this.scrolledAmount=0,this.onWheelEvent=A=>{this.scrolledAmount+=.05*A.deltaY,this.scrolledAmount>=1?(this.sendVerticalScroll(Math.floor(this.scrolledAmount)),this.scrolledAmount%=1):this.scrolledAmount<=-1&&(this.sendVerticalScroll(Math.ceil(this.scrolledAmount)),this.scrolledAmount%=-1)},this.onKeyboardEvent=A=>{A.preventDefault();const I=i.RainwayVirtualKeyFromWebKeyCode[A.code],g="keydown"===A.type;I&&(g?this.heldKeys.add(I):this.heldKeys.delete(I),this.sendInputDatagram({discriminator:E.KeyboardInput.discriminator,value:{action:g?E.KeyboardAction.KeyDown:E.KeyboardAction.KeyUp,keycode:I}}))},this.onGamepadConnectedEvent=A=>{},this.onGamepadDisconnectedEvent=A=>{},this.onDeviceMotion=A=>{},this.onDeviceOrientation=A=>{},this.gamepadCache=new Map,this.pollGamepads=A=>{if(navigator.getGamepads){if(this.container===document.activeElement){const A=[];for(const I of navigator.getGamepads()){if(!I||!n(I))continue;const g=I.buttons.map((A=>A.value)),e=this.gamepadCache.get(I.index);e&&s(e.axes,I.axes)&&s(e.buttonValues,g)||(A.push(this.makeGamepadInputEvent(I)),this.gamepadCache.set(I.index,{axes:[...I.axes],buttonValues:g}))}(this.alwaysReportGamepadPoll||A.length>0)&&this.reportGamepadEvents(A)}this.level&B.InputLevel.Gamepad&&(this.gamepadFrameHandle=window.requestAnimationFrame(this.pollGamepads))}},this.reportGamepadEvents=A=>{for(const I of A){let A=0;I.buttons.dpadUp&&(A|=1),I.buttons.dpadDown&&(A|=2),I.buttons.dpadLeft&&(A|=4),I.buttons.dpadRight&&(A|=8),I.buttons.start&&(A|=16),I.buttons.select&&(A|=32),I.buttons.leftStickPressed&&(A|=64),I.buttons.rightStickPressed&&(A|=128),I.buttons.leftShoulder&&(A|=256),I.buttons.rightShoulder&&(A|=512),I.buttons.a&&(A|=4096),I.buttons.b&&(A|=8192),I.buttons.x&&(A|=16384),I.buttons.y&&(A|=32768);const g={buttons:A,leftTrigger:Math.round(255*I.buttons.leftTrigger),rightTrigger:Math.round(255*I.buttons.rightTrigger),leftThumbX:Math.round(32767*I.sticks.left.x),leftThumbY:Math.round(32767*-I.sticks.left.y),rightThumbX:Math.round(32767*I.sticks.right.x),rightThumbY:Math.round(32767*-I.sticks.right.y),slot:1};this.sendInputDatagram({discriminator:E.GamepadReport.discriminator,value:g})}},this.moveMouseRelativeXY=(A,I)=>{this.sendMouseMove("relative",A,I)},this.moveMouseAbsoluteXY=(A,I)=>{this.sendMouseMove("absolute",A,I)},this.pointerFrameId=0,this.rememberedOffsetX=0,this.rememberedOffsetY=0,this.touches=new Map,this.reportPointerEvent=A=>{if("touch"===A.pointerType||"pen"===A.pointerType){if(document.pointerLockElement===this.container){const I=this.container.clientWidth,g=this.container.clientHeight,e=A.movementX,B=A.movementY;this.rememberedOffsetX=Math.max(0,Math.min(I,this.rememberedOffsetX+e)),this.rememberedOffsetY=Math.max(0,Math.min(g,this.rememberedOffsetY+B))}else this.rememberedOffsetX=A.offsetX,this.rememberedOffsetY=A.offsetY;const I=this.rainwayStream.transformPointerOffsetToRemote(this.rememberedOffsetX,this.rememberedOffsetY);if(!I)return;const{x:g,y:e}=I,i=Math.ceil(A.width/2),t=Math.ceil(A.height/2),{pointerId:Q,buttons:C}=A,E="pointercancel"===A.type||"pointerout"===A.type||"pointerleave"===A.type,o=C>0,a=("pointerover"===A.type?B.WindowsPointerFlags.New:0)|(o?B.WindowsPointerFlags.InContact:0)|(1==(3&C)?B.WindowsPointerFlags.FirstButton:0)|(3==(3&C)?B.WindowsPointerFlags.SecondButton:0)|(A.isPrimary?B.WindowsPointerFlags.Primary:0)|("pointercancel"===A.type?B.WindowsPointerFlags.Canceled:0)|("pointerdown"===A.type?B.WindowsPointerFlags.Down:"pointerup"===A.type?B.WindowsPointerFlags.Up:B.WindowsPointerFlags.Update)|(E?o?B.WindowsPointerFlags.Up:B.WindowsPointerFlags.Update:B.WindowsPointerFlags.InRange),n={pointerId:Q,frameId:++this.pointerFrameId,pointerFlags:a,x:g,y:e},s=Math.round(A.twist)%360,r=Math.round(1024*A.pressure);if("touch"===A.pointerType){const A={pointerInfo:n,touchMask:B.TouchMask.ContactArea|B.TouchMask.Orientation|B.TouchMask.Pressure,contactLeft:g-i,contactTop:e-t,contactRight:g+i,contactBottom:e+t,orientation:s,pressure:r};this.touches.set(Q,A),this.sendInputDatagram({discriminator:B.TouchesAbsolute.discriminator,value:{touches:[...this.touches.values()]}}),E&&this.touches.delete(Q)}else{const I=(2&C?B.PenFlags.Barrel:0)|(32&C?B.PenFlags.Eraser:0);this.sendInputDatagram({discriminator:B.PenAbsolute.discriminator,value:{pointerInfo:n,penMask:B.PenMask.Pressure|B.PenMask.Rotation|B.PenMask.TiltX|B.PenMask.TiltY,penFlags:I,rotation:s,pressure:r,tiltX:Math.round(A.tiltX),tiltY:Math.round(A.tiltY)}})}}else if((A.movementX||A.movementY)&&this.sendMouseMove("relative",A.movementX,A.movementY),A.button>-1){const I=a(A);this.sendMouseClick(I)}},this.cursorPainter=new Q.RainwayCursorPainter(this.moveMouseAbsoluteXY,((A,I)=>this.rainwayStream.transformPointerOffsetToRemote(A,I)),(()=>this.rainwayStream.currentFrameSize)),this.gestureRecognizer=new t.RainwayGestureRecognizer(this.onPointerEventFromGestureRecognizer,this.onWheelEvent),this.outgoingInputFilter=()=>!0}setContainer(A){if(this.cursorPainter.setContainer(A),this.container){const I=this.level;this.setInputLevel(B.InputLevel.None,!1),this.container=A,this.setInputLevel(I,!1)}else this.container=A}unsetContainer(){this.setInputLevel(B.InputLevel.None,!1),this.cursorPainter.unsetContainer(),this.container=void 0}setInputLevel(A,I=!0,g=!0){this.alwaysReportGamepadPoll=g;const e=A&~this.level,i=this.level&~A;this.level=A,e&B.InputLevel.Gamepad&&this.startGamepad(I),i&B.InputLevel.Gamepad&&this.stopGamepad(),e&B.InputLevel.Mouse&&this.startMouse(),i&B.InputLevel.Mouse&&this.stopMouse(),e&B.InputLevel.Keyboard&&this.startKeyboard(),i&B.InputLevel.Keyboard&&this.stopKeyboard()}getInputLevel(){return this.level}startGamepad(A){window.addEventListener("gamepadconnected",this.onGamepadConnectedEvent),window.addEventListener("gamepaddisconnected",this.onGamepadDisconnectedEvent),this.gamepadFrameHandle=window.requestAnimationFrame(this.pollGamepads),A&&this.reportConnectedGamepads()}reportConnectedGamepads(){for(const A of navigator.getGamepads())A&&this.onGamepadConnectedEvent(new GamepadEvent("gamepadconnected",{gamepad:A}))}stopGamepad(){window.removeEventListener("gamepadconnected",this.onGamepadConnectedEvent),window.removeEventListener("gamepaddisconnected",this.onGamepadDisconnectedEvent),this.gamepadFrameHandle&&window.cancelAnimationFrame(this.gamepadFrameHandle),this.gamepadFrameHandle=void 0}pointerEventListeners(A){if(!window.PointerEvent)throw new Error("browser does not support PointerEvent");A(C.isDesktopSafari&&navigator.maxTouchPoints<1?"mousemove":window.onpointerrawupdate?"pointerrawupdate":"pointermove",this.onPointerEventWithGestureProcessing),A("pointerdown",this.onPointerEventWithGestureProcessing),A("pointerup",this.onPointerEventWithGestureProcessing),A("pointerover",this.onPointerEventWithGestureProcessing),A("pointerenter",this.onPointerEventWithGestureProcessing),A("pointercancel",this.onPointerEventWithGestureProcessing),A("pointerout",this.onPointerEventWithGestureProcessing),A("pointerleave",this.onPointerEventWithGestureProcessing),A("wheel",this.onWheelEvent),A("mouseup",this.lockPointer)}startMouse(){if(!this.container)throw new e.RainwayError("Rainway tried to add an event listener to its container to handle mouse input, but no container element is set. Try calling setContainer() first.");this.pointerEventListeners(this.container.addEventListener.bind(this.container))}stopMouse(){this.container&&this.pointerEventListeners(this.container.removeEventListener.bind(this.container))}startKeyboard(){if(!this.container)throw new e.RainwayError("Rainway tried to add an event listener to its container to handle keyboard input, but no container element is set. Try calling setContainer() first.");this.container.addEventListener("keydown",this.onKeyboardEvent),this.container.addEventListener("keyup",this.onKeyboardEvent),this.container.addEventListener("click",this.focusContainer),this.container.focus()}stopKeyboard(){this.container&&(this.releaseKeys(),this.container.removeEventListener("keydown",this.onKeyboardEvent),this.container.removeEventListener("keyup",this.onKeyboardEvent),this.container.removeEventListener("click",this.focusContainer))}startDeviceMotionEvents(){window.addEventListener("devicemotion",this.onDeviceMotion)}stopDeviceMotionEvents(){window.removeEventListener("devicemotion",this.onDeviceMotion)}startDeviceOrientationEvents(){window.addEventListener("deviceorientation",this.onDeviceOrientation)}stopDeviceOrientationEvents(){window.removeEventListener("deviceorientation",this.onDeviceOrientation)}sendVerticalScroll(A){this.sendInputDatagram({discriminator:E.MouseScroll.discriminator,value:{axis:E.ScrollAxis.Vertical,delta:A}})}makeGamepadInputEvent(A){var I,g,e,B,i,t,Q,C,E,o,a,n,s,r,d,h,c,D,w,u,y,l,S,F,R,G,k,p,U,m,N,f,M,L,H,K,v,q;return{id:A.id,index:A.index,buttons:{a:null!==(g=null===(I=A.buttons[0])||void 0===I?void 0:I.value)&&void 0!==g?g:0,b:null!==(B=null===(e=A.buttons[1])||void 0===e?void 0:e.value)&&void 0!==B?B:0,x:null!==(t=null===(i=A.buttons[2])||void 0===i?void 0:i.value)&&void 0!==t?t:0,y:null!==(C=null===(Q=A.buttons[3])||void 0===Q?void 0:Q.value)&&void 0!==C?C:0,leftShoulder:null!==(o=null===(E=A.buttons[4])||void 0===E?void 0:E.value)&&void 0!==o?o:0,rightShoulder:null!==(n=null===(a=A.buttons[5])||void 0===a?void 0:a.value)&&void 0!==n?n:0,leftTrigger:null!==(r=null===(s=A.buttons[6])||void 0===s?void 0:s.value)&&void 0!==r?r:0,rightTrigger:null!==(h=null===(d=A.buttons[7])||void 0===d?void 0:d.value)&&void 0!==h?h:0,select:null!==(D=null===(c=A.buttons[8])||void 0===c?void 0:c.value)&&void 0!==D?D:0,start:null!==(u=null===(w=A.buttons[9])||void 0===w?void 0:w.value)&&void 0!==u?u:0,leftStickPressed:null!==(l=null===(y=A.buttons[10])||void 0===y?void 0:y.value)&&void 0!==l?l:0,rightStickPressed:null!==(F=null===(S=A.buttons[11])||void 0===S?void 0:S.value)&&void 0!==F?F:0,dpadUp:null!==(G=null===(R=A.buttons[12])||void 0===R?void 0:R.value)&&void 0!==G?G:0,dpadDown:null!==(p=null===(k=A.buttons[13])||void 0===k?void 0:k.value)&&void 0!==p?p:0,dpadLeft:null!==(m=null===(U=A.buttons[14])||void 0===U?void 0:U.value)&&void 0!==m?m:0,dpadRight:null!==(f=null===(N=A.buttons[15])||void 0===N?void 0:N.value)&&void 0!==f?f:0,home:null!==(L=null===(M=A.buttons[16])||void 0===M?void 0:M.value)&&void 0!==L?L:0},sticks:{left:{x:null!==(H=A.axes[0])&&void 0!==H?H:0,y:null!==(K=A.axes[1])&&void 0!==K?K:0},right:{x:null!==(v=A.axes[2])&&void 0!==v?v:0,y:null!==(q=A.axes[3])&&void 0!==q?q:0}}}}feedGamepadInputEvent(A){this.reportGamepadEvents(A)}static vibrateGamepad(A,I){var g,e;const B=navigator.getGamepads()[A];if(null==B?void 0:B.vibrationActuator)null===(e=(g=B.vibrationActuator).playEffect)||void 0===e||e.call(g,"dual-rumble",I);else if(null==B?void 0:B.hapticActuators){const A=null==B?void 0:B.hapticActuators;setTimeout((()=>{var g,e,B;for(const i of A)if("pulse"in i){const A=Math.max(null!==(g=I.strongMagnitude)&&void 0!==g?g:0,null!==(e=I.weakMagnitude)&&void 0!==e?e:0);i.pulse(A,null!==(B=I.duration)&&void 0!==B?B:0)}}),I.startDelay)}}feedKeyboardEvent(A){this.onKeyboardEvent(A)}releaseKeys(){for(const A of this.heldKeys)this.sendInputDatagram({discriminator:E.KeyboardInput.discriminator,value:{action:E.KeyboardAction.KeyUp,keycode:A}});this.heldKeys.clear()}feedPointerEvent(A){this.onPointerEvent(A)}feedWheelEvent(A){this.onWheelEvent(A)}processCursor(A){this.cursorPainter.processCursor(A)}enableGestures(){this.options.touchGestures=!0}disableGestures(){this.options.touchGestures=!1}sendMouseMove(A,I,g){"absolute"===A?this.sendInputDatagram({discriminator:E.MouseAbsolute.discriminator,value:{x:I,y:g}}):this.sendInputDatagram({discriminator:E.MouseRelative.discriminator,value:{dx:I,dy:g}})}sendMouseClick(A){this.sendInputDatagram({discriminator:E.MouseClick.discriminator,value:A})}sendInputDatagram(A){const I=o.toOutgoingInput(A);I&&this.outgoingInputFilter(I,new o.HeldKeys(this.heldKeys))&&this.rainwayStream.sendInput(A)}dispose(){this.unsetContainer()}}},884:(A,I,g)=>{"use strict";Object.defineProperty(I,"__esModule",{value:!0}),I.HeldKeys=I.toOutgoingInput=I.InputType=void 0;const e=g(904);var B;!function(A){A[A.Gamepad=0]="Gamepad",A[A.MouseAbsolute=1]="MouseAbsolute",A[A.MouseRelative=2]="MouseRelative",A[A.MouseClick=3]="MouseClick",A[A.MouseScroll=4]="MouseScroll",A[A.Keyboard=5]="Keyboard",A[A.PasteText=6]="PasteText",A[A.TouchesAbsolute=7]="TouchesAbsolute",A[A.PenAbsolute=8]="PenAbsolute",A[A.ViewportResize=9]="ViewportResize",A[A.SetClipboardText=10]="SetClipboardText"}(B=I.InputType||(I.InputType={})),I.toOutgoingInput=function(A){switch(A.discriminator){case e.GamepadReport.discriminator:return Object.assign({type:B.Gamepad},A.value);case e.GamepadRumble.discriminator:return;case e.MouseAbsolute.discriminator:return Object.assign({type:B.MouseAbsolute},A.value);case e.MouseRelative.discriminator:return Object.assign({type:B.MouseRelative},A.value);case e.MouseClick.discriminator:return Object.assign({type:B.MouseClick},A.value);case e.MouseScroll.discriminator:return Object.assign({type:B.MouseScroll},A.value);case e.KeyboardInput.discriminator:{const I=A.value.keycode;return{type:B.Keyboard,action:A.value.action,key:I}}case e.LogicalInput.discriminator:return Object.assign({type:B.PasteText},A.value);case e.TouchesAbsolute.discriminator:return Object.assign({type:B.TouchesAbsolute},A.value);case e.PenAbsolute.discriminator:return Object.assign({type:B.PenAbsolute},A.value);case e.ViewportResize.discriminator:return Object.assign({type:B.ViewportResize},A.value);case e.SetClipboardText.discriminator:return Object.assign({type:B.SetClipboardText},A.value)}},I.HeldKeys=class{constructor(A){this.heldKeys=A}get keys(){return this.heldKeys}has(A){return this.heldKeys.has(A)}get ctrl(){return this.heldKeys.has(e.VirtualKey.LeftCtrl)||this.heldKeys.has(e.VirtualKey.RightCtrl)}get alt(){return this.heldKeys.has(e.VirtualKey.LeftAlt)||this.heldKeys.has(e.VirtualKey.RightAlt)}get win(){return this.heldKeys.has(e.VirtualKey.LWin)||this.heldKeys.has(e.VirtualKey.RWin)}get shift(){return this.heldKeys.has(e.VirtualKey.LeftShift)||this.heldKeys.has(e.VirtualKey.RightShift)}}},40:(A,I,g)=>{"use strict";Object.defineProperty(I,"__esModule",{value:!0}),I.RainwayVirtualKeyFromWebKeyCode=void 0;const e=g(904);I.RainwayVirtualKeyFromWebKeyCode={Unidentified:e.VirtualKey.None,Cancel:e.VirtualKey.Cancel,Backspace:e.VirtualKey.Back,Tab:e.VirtualKey.Tab,Enter:e.VirtualKey.Enter,Pause:e.VirtualKey.Pause,CapsLock:e.VirtualKey.CapsLock,HangulMode:e.VirtualKey.HangulMode,KanaMode:e.VirtualKey.HangulMode,Lang1:e.VirtualKey.HangulMode,Hanja:e.VirtualKey.HanjaMode,Lang2:e.VirtualKey.HanjaMode,Escape:e.VirtualKey.Escape,Convert:e.VirtualKey.ImeConvert,NonConvert:e.VirtualKey.ImeNonConvert,Space:e.VirtualKey.Space," ":e.VirtualKey.Space,Spacebar:e.VirtualKey.Space,PageUp:e.VirtualKey.PageUp,PageDown:e.VirtualKey.PageDown,End:e.VirtualKey.End,Home:e.VirtualKey.Home,ArrowLeft:e.VirtualKey.Left,ArrowUp:e.VirtualKey.Up,ArrowRight:e.VirtualKey.Right,ArrowDown:e.VirtualKey.Down,Select:e.VirtualKey.Select,PrintScreen:e.VirtualKey.PrintScreen,Insert:e.VirtualKey.Insert,Delete:e.VirtualKey.Delete,Help:e.VirtualKey.Help,Digit0:e.VirtualKey.D0,Digit1:e.VirtualKey.D1,Digit2:e.VirtualKey.D2,Digit3:e.VirtualKey.D3,Digit4:e.VirtualKey.D4,Digit5:e.VirtualKey.D5,Digit6:e.VirtualKey.D6,Digit7:e.VirtualKey.D7,Digit8:e.VirtualKey.D8,Digit9:e.VirtualKey.D9,KeyA:e.VirtualKey.A,KeyB:e.VirtualKey.B,KeyC:e.VirtualKey.C,KeyD:e.VirtualKey.D,KeyE:e.VirtualKey.E,KeyF:e.VirtualKey.F,KeyG:e.VirtualKey.G,KeyH:e.VirtualKey.H,KeyI:e.VirtualKey.I,KeyJ:e.VirtualKey.J,KeyK:e.VirtualKey.K,KeyL:e.VirtualKey.L,KeyM:e.VirtualKey.M,KeyN:e.VirtualKey.N,KeyO:e.VirtualKey.O,KeyP:e.VirtualKey.P,KeyQ:e.VirtualKey.Q,KeyR:e.VirtualKey.R,KeyS:e.VirtualKey.S,KeyT:e.VirtualKey.T,KeyU:e.VirtualKey.U,KeyV:e.VirtualKey.V,KeyW:e.VirtualKey.W,KeyX:e.VirtualKey.X,KeyY:e.VirtualKey.Y,KeyZ:e.VirtualKey.Z,MetaLeft:e.VirtualKey.LWin,OSLeft:e.VirtualKey.LWin,MetaRight:e.VirtualKey.RWin,OSRight:e.VirtualKey.RWin,ContextMenu:e.VirtualKey.Apps,Sleep:e.VirtualKey.Sleep,Numpad0:e.VirtualKey.NumPad0,Numpad1:e.VirtualKey.NumPad1,Numpad2:e.VirtualKey.NumPad2,Numpad3:e.VirtualKey.NumPad3,Numpad4:e.VirtualKey.NumPad4,Numpad5:e.VirtualKey.NumPad5,Numpad6:e.VirtualKey.NumPad6,Numpad7:e.VirtualKey.NumPad7,Numpad8:e.VirtualKey.NumPad8,Numpad9:e.VirtualKey.NumPad9,NumpadMultiply:e.VirtualKey.Multiply,NumpadAdd:e.VirtualKey.Add,NumpadComma:e.VirtualKey.Separator,NumpadSubtract:e.VirtualKey.Subtract,NumpadDecimal:e.VirtualKey.Decimal,NumpadDivide:e.VirtualKey.Divide,F1:e.VirtualKey.F1,F2:e.VirtualKey.F2,F3:e.VirtualKey.F3,F4:e.VirtualKey.F4,F5:e.VirtualKey.F5,F6:e.VirtualKey.F6,F7:e.VirtualKey.F7,F8:e.VirtualKey.F8,F9:e.VirtualKey.F9,F10:e.VirtualKey.F10,F11:e.VirtualKey.F11,F12:e.VirtualKey.F12,F13:e.VirtualKey.F13,F14:e.VirtualKey.F14,F15:e.VirtualKey.F15,F16:e.VirtualKey.F16,F17:e.VirtualKey.F17,F18:e.VirtualKey.F18,F19:e.VirtualKey.F19,F20:e.VirtualKey.F20,F21:e.VirtualKey.F21,F22:e.VirtualKey.F22,F23:e.VirtualKey.F23,F24:e.VirtualKey.F24,NumLock:e.VirtualKey.NumLock,ScrollLock:e.VirtualKey.Scroll,ShiftLeft:e.VirtualKey.LeftShift,ShiftRight:e.VirtualKey.RightShift,ControlLeft:e.VirtualKey.LeftCtrl,ControlRight:e.VirtualKey.RightCtrl,AltLeft:e.VirtualKey.LeftAlt,AltRight:e.VirtualKey.RightAlt,BrowserBack:e.VirtualKey.BrowserBack,BrowserForward:e.VirtualKey.BrowserForward,BrowserRefresh:e.VirtualKey.BrowserRefresh,BrowserStop:e.VirtualKey.BrowserStop,BrowserSearch:e.VirtualKey.BrowserSearch,BrowserFavorites:e.VirtualKey.BrowserFavorites,BrowserHome:e.VirtualKey.BrowserHome,AudioVolumeMute:e.VirtualKey.VolumeMute,AudioVolumeDown:e.VirtualKey.VolumeDown,AudioVolumeUp:e.VirtualKey.VolumeUp,MediaTrackNext:e.VirtualKey.MediaNextTrack,MediaTrackPrevious:e.VirtualKey.MediaPreviousTrack,MediaStop:e.VirtualKey.MediaStop,MediaPlayPause:e.VirtualKey.MediaPlayPause,LaunchMail:e.VirtualKey.LaunchMail,LaunchMediaPlayer:e.VirtualKey.SelectMedia,MediaSelect:e.VirtualKey.SelectMedia,LaunchApp1:e.VirtualKey.LaunchApplication1,LaunchApp2:e.VirtualKey.LaunchApplication2,Semicolon:e.VirtualKey.Oem1,Equal:e.VirtualKey.OemPlus,Comma:e.VirtualKey.OemComma,Minus:e.VirtualKey.OemMinus,Period:e.VirtualKey.OemPeriod,Slash:e.VirtualKey.Oem2,Backquote:e.VirtualKey.Oem3,BracketLeft:e.VirtualKey.Oem4,Backslash:e.VirtualKey.Oem5,BracketRight:e.VirtualKey.Oem6,Quote:e.VirtualKey.Oem7,IntlBackslash:e.VirtualKey.Oem102}},464:(A,I)=>{"use strict";var g;Object.defineProperty(I,"__esModule",{value:!0}),I.RainwayLogging=I.RainwayLogLevel=void 0,function(A){A[A.Trace=0]="Trace",A[A.Debug=1]="Debug",A[A.Information=2]="Information",A[A.Warning=3]="Warning",A[A.Error=4]="Error",A[A.Critical=5]="Critical",A[A.Silent=6]="Silent"}(g=I.RainwayLogLevel||(I.RainwayLogLevel={}));class e{static setLogSink(A){e._logSink=A}static log(A,I){var g;null===(g=e._logSink)||void 0===g||g.call(e,A,I)}}I.RainwayLogging=e,e.trace=A=>e.log(g.Trace,A),e.debug=A=>e.log(g.Debug,A),e.information=A=>e.log(g.Information,A),e.warning=A=>e.log(g.Warning,A),e.error=A=>e.log(g.Error,A),e.critical=A=>e.log(g.Critical,A)},585:function(A,I,g){"use strict";var e=this&&this.__awaiter||function(A,I,g,e){return new(g||(g=Promise))((function(B,i){function t(A){try{C(e.next(A))}catch(A){i(A)}}function Q(A){try{C(e.throw(A))}catch(A){i(A)}}function C(A){var I;A.done?B(A.value):(I=A.value,I instanceof g?I:new g((function(A){A(I)}))).then(t,Q)}C((e=e.apply(A,I||[])).next())}))},B=this&&this.__importDefault||function(A){return A&&A.__esModule?A:{default:A}};Object.defineProperty(I,"__esModule",{value:!0}),I.AudioStream=void 0;const i=B(g(53)),t=g(994),Q=g(464);I.AudioStream=class{constructor(){this.sampleRateHz=48e3,this.sampleRateKhz=48,this.channelCount=2,this.decodedCount=0,this.totalSamplesDecoded=0,this.waitingToDecodeQueue=[],this.decodeQueueSize=0,this.logPerformance=!1,this.maxDecodingTimeMs=0,this.totalDecodingTimeMs=0,this.totalQueuedSize=0,this.maxQueuedSize=0,this.startStreamTimeMs=0,this.outputBuffers=[],this.currentOutputBuffer=void 0,this.currentBufferReadIndex=0,this.nextStartTime=void 0,this.playing=!1,this.dataDurationMs=10,this.minLatencyMs=60,this.maxLatencyMs=100,this.prevDroppedFrameTimeMs=void 0,this.decodedSamplesPerFrame=0,this.audioBufferSize=0,this.audioBufferPool=[],this.maxAudioBufferPoolCount=5,this.resampledAudioBufferSize=0,this.onDecode=({startTimestamp:A,outputData:I,samplesDecoded:g})=>{--this.decodeQueueSize;const e=new Float32Array(I);this.outputBuffers.push(e);try{if(g>0&&(++this.decodedCount,this.totalSamplesDecoded+=g,this.logPerformance&&this.logPerfTiming(A),this.totalSamplesDecoded>=this.audioBufferSize&&(this.nextStartTime&&this.nextStartTime<this.audioContext.currentTime&&(this.nextStartTime=void 0),this.nextStartTime||this.totalSamplesDecoded>=2*this.audioBufferSize))){const A=Math.floor(this.totalSamplesDecoded/this.audioBufferSize);for(let I=0;I<A;++I){const A=this.nextStartTime?1e3*(this.nextStartTime-this.audioContext.currentTime):0;if(A>this.maxLatencyMs){let I=0;const g=Date.now(),e=this.prevDroppedFrameTimeMs?g-this.prevDroppedFrameTimeMs:void 0,B=1e4;if(e&&e<B)I=this.dropDecodedSamples(this.totalSamplesDecoded);else{const g=A-this.maxLatencyMs+this.dataDurationMs,e=Math.floor(this.sampleRateKhz*g);I=this.dropDecodedSamples(e)}this.prevDroppedFrameTimeMs=g,this.totalSamplesDecoded-=I}if(!(this.totalSamplesDecoded>=this.audioBufferSize))break;{const A=this.copyDecodedSamplesToAudioBuffer();this.scheduleBufferForPlaybackFunc(A),this.totalSamplesDecoded-=A.length}}}}catch(A){Q.RainwayLogging.warning("Caught exception in AudioStream onDecode: "+A+" "+A.stack),this.stop(),this.play()}this.sendDecoderWaitingToDecodeFrames()}}initialize(){return e(this,void 0,void 0,(function*(){this.opusDecoderWorker=new i.default,yield this.opusDecoderWorker.initialize(),this.opusDecoderWorker.onDecode=this.onDecode.bind(this)}))}dispose(){var A;null===(A=this.opusDecoderWorker)||void 0===A||A.dispose(),this.opusDecoderWorker=void 0}configure({audioContext:A,sampleRateHz:I,channelCount:g,dataDurationMs:e,minLatencyMs:B,maxLatencyMs:i}){if(this.sampleRateHz=null!=I?I:this.sampleRateHz,8e3!=this.sampleRateHz&&12e3!=this.sampleRateHz&&16e3!=this.sampleRateHz&&24e3!=this.sampleRateHz&&48e3!=this.sampleRateHz)throw new t.RainwayError(`invalid audio sample rate: ${this.sampleRateHz} (must be 8000, 12000, 16000, 24000, or 48000)`);if(this.sampleRateKhz=this.sampleRateHz/1e3,this.channelCount=null!=g?g:this.channelCount,1!=this.channelCount&&2!=this.channelCount&&6!=this.channelCount)throw new t.RainwayError(`invalid channel count: ${this.channelCount} (must be 1, 2, or 6)`);if(this.dataDurationMs=null!=e?e:this.dataDurationMs,this.minLatencyMs=null!=B?B:this.minLatencyMs,this.maxLatencyMs=null!=i?i:this.maxLatencyMs,this.dataDurationMs<=0)throw new t.RainwayError(`dataDurationMs must be positive, but is ${this.dataDurationMs}`);if(this.dataDurationMs>this.minLatencyMs)throw new t.RainwayError("dataDurationMs may not exceed minLatencyMs");if(this.maxLatencyMs<=this.minLatencyMs)throw new t.RainwayError("maxLatencyMs must be greater than minLatencyMs");this.decodedSamplesPerFrame=this.dataDurationMs*this.sampleRateKhz,this.currentOutputBuffer=void 0,this.currentBufferReadIndex=0;const C=this.sampleRateKhz*this.minLatencyMs;this.audioBufferSize=Math.floor(C/2),null==A?(this.audioContext=new(window.AudioContext||window.webkitAudioContext)({latencyHint:"interactive",sampleRate:this.sampleRateHz}),this.audioContext.createBufferSource()):this.audioContext=A,this.volumeNode=this.audioContext.createGain(),this.volumeNode.connect(this.audioContext.destination),this.audioContext.resume(),"suspended"==this.audioContext.state&&Q.RainwayLogging.information("AudioContext is suspended. Note, on Safari, must be created directly from user interaction (i.e. no 'await'))."),this.audioContext.sampleRate!=this.sampleRateHz?(Q.RainwayLogging.warning("Configured sample rate: "+this.sampleRateHz+" does not match AudioContext: "+this.audioContext.sampleRate+". Resampling is required!"),this.resampledAudioBufferSize=Math.floor(this.audioContext.sampleRate/1e3*this.minLatencyMs/2),this.scheduleBufferForPlaybackFunc=this.resampleBufferThenScheduleForPlayback.bind(this)):this.scheduleBufferForPlaybackFunc=this.scheduleBufferForPlayback.bind(this),this.audioBufferPool=[];let E=!1;this.playing&&(E=!0,this.stop()),E&&this.play()}play(){if(!this.opusDecoderWorker)throw new t.RainwayError("play() has no opusDecoderWorker");if(!this.sampleRateHz)throw new t.RainwayError("play() has no sampleRateHz");if(!this.channelCount)throw new t.RainwayError("play() has no channelCount");if(!this.audioContext)throw new t.RainwayError("play() has no audioContext");this.playing||(this.maxDecodingTimeMs=0,this.totalDecodingTimeMs=0,this.totalQueuedSize=0,this.maxQueuedSize=0,this.startStreamTimeMs=Date.now(),this.opusDecoderWorker.startStream(this.sampleRateHz,this.channelCount,this.decodedSamplesPerFrame),this.playing=!0)}stop(){if(!this.opusDecoderWorker)throw new t.RainwayError("stop() has no opusDecoderWorker");this.waitingToDecodeQueue=[],this.outputBuffers=[],this.nextStartTime=void 0,this.totalSamplesDecoded=0,this.currentOutputBuffer=void 0,this.currentBufferReadIndex=0,this.prevDroppedFrameTimeMs=void 0,this.opusDecoderWorker.stopStream(),this.playing=!1}pushData(A){this.playing&&this.audioContext&&this.opusDecoderWorker&&(0==this.decodeQueueSize?(0!=this.waitingToDecodeQueue.length&&(Q.RainwayLogging.error("[AudioStream] empty decoder queue, but waiting to decode queue not empty!"),this.waitingToDecodeQueue=[]),this.sendToDecoder({startTimestamp:Date.now(),inputData:A})):(this.waitingToDecodeQueue.push({startTimestamp:Date.now(),inputData:A}),this.decodeQueueSize<3&&this.sendDecoderWaitingToDecodeFrames()))}sendDecoderWaitingToDecodeFrames(){const A=(this.decodeQueueSize+this.waitingToDecodeQueue.length)*this.dataDurationMs;if(A>this.maxLatencyMs){const I=A-this.maxLatencyMs,g=Math.floor(I/this.dataDurationMs),e=Math.max(Math.max(this.waitingToDecodeQueue.length-g,3-this.decodeQueueSize),1),B=this.waitingToDecodeQueue.length-e;this.waitingToDecodeQueue=this.waitingToDecodeQueue.slice(B)}for(;this.decodeQueueSize<3&&this.waitingToDecodeQueue.length>0;){const A=this.waitingToDecodeQueue.shift();this.sendToDecoder(A)}}sendToDecoder(A){++this.decodeQueueSize,this.opusDecoderWorker.decode(A.startTimestamp,A.inputData)}dropDecodedSamples(A){let I=0;for(this.currentOutputBuffer&&(I+=this.dropCurrentOutputBufferSamples(A),A-=I);A>0&&this.outputBuffers.length>0;)if(A<this.decodedSamplesPerFrame){this.currentOutputBuffer=this.outputBuffers.shift(),this.currentBufferReadIndex=0;const g=this.dropCurrentOutputBufferSamples(A);I+=g,A-=g}else this.outputBuffers.shift(),I+=this.decodedSamplesPerFrame,A-=this.decodedSamplesPerFrame;return I}dropCurrentOutputBufferSamples(A){const I=Math.floor((this.currentOutputBuffer.length-this.currentBufferReadIndex)/this.channelCount),g=Math.min(I,A);return this.currentBufferReadIndex+=g*this.channelCount,this.currentBufferReadIndex>=this.currentOutputBuffer.length&&(this.currentOutputBuffer=void 0),g}copyDecodedSamplesToAudioBuffer(){const A=this.getOrCreateAudioBuffer();for(let I=0;I<this.audioBufferSize;){this.currentOutputBuffer||(this.currentOutputBuffer=this.outputBuffers.shift(),this.currentBufferReadIndex=0);const g=this.currentOutputBuffer;if(1==this.channelCount){const e=A.getChannelData(0);for(;this.currentBufferReadIndex<g.length&&(e[I]=g[this.currentBufferReadIndex],this.currentBufferReadIndex+=this.channelCount,++I,!(I>=this.audioBufferSize)););}else if(2==this.channelCount){const e=A.getChannelData(0),B=A.getChannelData(1);for(;this.currentBufferReadIndex<g.length&&(e[I]=g[this.currentBufferReadIndex],B[I]=g[this.currentBufferReadIndex+1],this.currentBufferReadIndex+=this.channelCount,++I,!(I>=this.audioBufferSize)););}else{const e=A.getChannelData(0),B=A.getChannelData(1),i=A.getChannelData(2),t=A.getChannelData(3),Q=A.getChannelData(4),C=A.getChannelData(5);for(;this.currentBufferReadIndex<g.length&&(e[I]=g[this.currentBufferReadIndex],B[I]=g[this.currentBufferReadIndex+1],Q[I]=g[this.currentBufferReadIndex+2],C[I]=g[this.currentBufferReadIndex+3],i[I]=g[this.currentBufferReadIndex+4],t[I]=g[this.currentBufferReadIndex+5],this.currentBufferReadIndex+=this.channelCount,++I,!(I>=this.audioBufferSize)););}this.currentBufferReadIndex>=this.currentOutputBuffer.length&&(this.currentOutputBuffer=void 0)}return A}getOrCreateAudioBuffer(){return 0==this.audioBufferPool.length?this.audioContext.createBuffer(this.channelCount,this.audioBufferSize,this.sampleRateHz):this.audioBufferPool.pop()}returnAudioBufferToPool(A,I){this.audioBufferPool.length<this.maxAudioBufferPoolCount&&this.audioBufferPool.push(A)}logPerfTiming(A){const I=Date.now(),g=I-A;this.totalDecodingTimeMs+=g,g>this.maxDecodingTimeMs&&(this.maxDecodingTimeMs=g);const e=this.waitingToDecodeQueue.length+this.decodeQueueSize;this.totalQueuedSize+=e,e>this.maxQueuedSize&&(this.maxQueuedSize=e),1500==this.decodedCount&&(Q.RainwayLogging.information("[AudioStream] Avg queue: "+this.totalQueuedSize/this.decodedCount+", Max: "+this.maxQueuedSize+" Avg FPS: "+this.decodedCount/((I-this.startStreamTimeMs)/1e3)+" Avg decode: "+this.totalDecodingTimeMs/this.decodedCount+"ms, Max: "+this.maxDecodingTimeMs+"ms"),this.totalDecodingTimeMs=0,this.maxDecodingTimeMs=0,this.totalQueuedSize=0,this.maxQueuedSize=0,this.decodedCount=0,this.startStreamTimeMs=I)}resampleBufferThenScheduleForPlayback(A){const I=new(window.OfflineAudioContext||window.webkitOfflineAudioContext)(this.channelCount,this.resampledAudioBufferSize,this.audioContext.sampleRate),g=I.createBufferSource();g.buffer=A,g.connect(I.destination),g.start(),I.startRendering(),I.oncomplete=this.scheduleResampledBufferPlayback.bind(this,A)}scheduleResampledBufferPlayback(A,I){this.schedulePlaybackWithOnEnded(I.renderedBuffer),this.returnAudioBufferToPool(A,I)}scheduleBufferForPlayback(A){this.schedulePlaybackWithOnEnded(A,this.returnAudioBufferToPool.bind(this,A))}schedulePlaybackWithOnEnded(A,I=null){const g=this.audioContext.createBufferSource();g.buffer=A,this.nextStartTime||(this.nextStartTime=this.audioContext.currentTime),g.playbackRate.value=1,g.connect(this.volumeNode),g.start(this.nextStartTime),g.onended=I,this.nextStartTime+=A.duration}setVolume(A){this.volumeNode.gain.value=A}}},514:(A,I,g)=>{"use strict";Object.defineProperty(I,"__esModule",{value:!0}),I.makeClientCapabilities=void 0;const e=g(904),B=g(643),i=g(695);I.makeClientCapabilities=function(A){const{filtered:I,preferred:g}=i.filterCodecPack(A),t={codec:e.AudioCodec.Opus,container:e.AudioContainer.Raw},Q="MediaSource"in window?e.VideoContainer.IsoBMFF:e.VideoContainer.Raw,C=!!window.chrome;return{preferredWidth:screen.availWidth,preferredHeight:screen.availHeight,preferredFps:60,preferredAudioBitrate:96e3,preferredVideoBitrate:1e3*B.defaultRateControlParameters.initialBitrateKbps,preferredAudioChannels:e.AudioChannels.Stereo,preferredAudioConfig:t,preferredVideoConfig:{codec:g,container:Q},supportedAudioChannels:[e.AudioChannels.Mono,e.AudioChannels.Stereo],supportedAudioConfigs:[t],supportedVideoConfigs:I.map((A=>({codec:A,container:Q}))),supportsOver1080P:!1,supportsTemporalScaling:!0,supportsAppIsolation:C}}},695:(A,I,g)=>{"use strict";Object.defineProperty(I,"__esModule",{value:!0}),I.filterCodecPack=I.videoCodecMimeType=void 0;const e=g(904);function B(A){const I=A.data;return`video/mp4; codecs="avc1.${(I[5]<<16|I[6]<<8|I[7]).toString(16).padStart(6,"0")}"`}function i(A){if(!("MediaSource"in window))return!1;const I=A.data;if(I.length<8||7!=(31&I[4]))return!1;const g=B(A);return MediaSource.isTypeSupported(g)}function t(A){const I=A.data;if(I.length<8||7!=(31&I[4]))return e.VideoCodecType.Baseline;const g=I[5];return I[6],116==g||122==g||110==g||100==g?e.VideoCodecType.High:88==g||77==g?e.VideoCodecType.Main:e.VideoCodecType.Baseline}I.videoCodecMimeType=B,I.filterCodecPack=function(A){if(0===A.length)throw new Error("Host supplied an empty CodecPack");let I=A.filter(i);if(0===I.length&&(console.warn("Found no browser-confirmed working codec, falling back to baseline"),I=A.filter((A=>t(A)<=e.VideoCodecType.Baseline))),0===I.length)throw new Error("Host supplied an unsupported CodecPack");const g=I.reduce(((A,I)=>t(A)>t(I)?A:I));return{filtered:I,preferred:g}}},919:(A,I,g)=>{"use strict";Object.defineProperty(I,"__esModule",{value:!0});const e=g(464);class B{constructor(A,I,g){this.glCtx=void 0,this.program=void 0,this.glCtx=A,this.program=this.glCtx.createProgram(),this.glCtx.attachShader(this.program,I),this.glCtx.attachShader(this.program,g),this.glCtx.linkProgram(this.program),this.glCtx.getProgramParameter(this.program,this.glCtx.LINK_STATUS)||e.RainwayLogging.error("Shader link failed.")}static compile(A,I,g){let B;return B="vertex"===I?A.createShader(A.VERTEX_SHADER):A.createShader(A.FRAGMENT_SHADER),A.shaderSource(B,g),A.compileShader(B),0==A.getShaderParameter(B,A.COMPILE_STATUS)&&e.RainwayLogging.error("Shader compile failed, log: "+A.getShaderInfoLog(B)),B}static create(A,I,g){const e=B.compile(A,"vertex",I),i=B.compile(A,"fragment",g);return new B(A,e,i)}use(){this.glCtx.useProgram(this.program)}getAttributeLocation(A){return this.glCtx.getAttribLocation(this.program,A)}getUniformLocation(A){const I=this.glCtx.getUniformLocation(this.program,A);if(I)return I}setMatrixUniform(A,I){this.glCtx.uniformMatrix4fv(A,!1,I)}}I.default=B},756:function(A,I,g){"use strict";var e=this&&this.__importDefault||function(A){return A&&A.__esModule?A:{default:A}};Object.defineProperty(I,"__esModule",{value:!0}),I.yuvFragShaderSrc=void 0;const B=e(g(919));I.yuvFragShaderSrc="\n    precision lowp float;\n    \n    varying vec2 vTexCoord;\n    \n    uniform sampler2D yTexture;\n    uniform sampler2D uTexture;\n    uniform sampler2D vTexture;\n    const mat3 conversion = mat3(\n        1.164, 0.000,  1.596,\n        1.164, -0.391, -0.813,\n        1.164, 2.018,  0.000\n    );\n\n    const vec3 offset = vec3(0.0625, 0.5, 0.5);\n        \n    void main(void) {\n        float y = texture2D(yTexture, vTexCoord).x;\n        float u = texture2D(uTexture, vTexCoord).x;\n        float v = texture2D(vTexture, vTexCoord).x;\n        vec3 yuv = vec3(y, u, v) - offset;\n\n        vec3 rgb = (yuv * conversion);\n\n        gl_FragColor = vec4(rgb, 1.0);\n    }\n";class i{constructor(A,I,g,e,B,i,t,Q,C){this.glCtx=A,this.program=I,this.projectionMtxLoc=g,this.positionAttr=e,this.texCoordAttr=B,this.vertexBuffer=i,this.yTextureLoc=t,this.uTextureLoc=Q,this.vTextureLoc=C}static create(A){const g=B.default.create(A,"\n    precision mediump float;\n\n    uniform mat4 uProjection;\n    attribute vec2 aPosition;\n    attribute vec2 aTexCoord;\n\n    varying vec2 vTexCoord;\n    void main(){\n        vTexCoord = aTexCoord;\n        gl_Position = uProjection * vec4(aPosition, 0.0, 1.0);\n    }\n",I.yuvFragShaderSrc);g.use();const e=g.getUniformLocation("uProjection"),t=g.getAttributeLocation("aPosition");A.enableVertexAttribArray(t);const Q=g.getAttributeLocation("aTexCoord");A.enableVertexAttribArray(Q);const C=A.createBuffer(),E=g.getUniformLocation("yTexture"),o=g.getUniformLocation("uTexture"),a=g.getUniformLocation("vTexture");return new i(A,g,e,t,Q,C,E,o,a)}bindInputTextures(A,I,g){const e=this.glCtx;e.uniform1i(this.yTextureLoc,0),e.activeTexture(e.TEXTURE0),e.bindTexture(e.TEXTURE_2D,A.textureId),e.uniform1i(this.uTextureLoc,1),e.activeTexture(e.TEXTURE1),e.bindTexture(e.TEXTURE_2D,I.textureId),e.uniform1i(this.vTextureLoc,2),e.activeTexture(e.TEXTURE2),e.bindTexture(e.TEXTURE_2D,g.textureId)}use(){this.program.use()}drop(){this.glCtx.useProgram(0)}update(A,I,g,e){this.glCtx.viewport(0,0,A,I),this.program.setMatrixUniform(this.projectionMtxLoc,[2/A,0,0,0,0,2/-I,0,0,0,0,1,0,-1,1,0,1]),this.glCtx.bindBuffer(this.glCtx.ARRAY_BUFFER,this.vertexBuffer),this.glCtx.bufferData(this.glCtx.ARRAY_BUFFER,new Float32Array([0,0,0,0,A,0,g,0,A,I,g,e,A,I,g,e,0,I,0,e,0,0,0,0]),this.glCtx.DYNAMIC_DRAW),this.glCtx.vertexAttribPointer(this.positionAttr,2,this.glCtx.FLOAT,!1,16,0),this.glCtx.vertexAttribPointer(this.texCoordAttr,2,this.glCtx.FLOAT,!1,16,8)}draw(){const A=this.glCtx;A.clear(A.COLOR_BUFFER_BIT|A.DEPTH_BUFFER_BIT|A.STENCIL_BUFFER_BIT),A.drawArrays(A.TRIANGLE_STRIP,0,6),A.bindTexture(A.TEXTURE_2D,null)}}I.default=i},346:(A,I)=>{"use strict";Object.defineProperty(I,"__esModule",{value:!0});class g{constructor(A,I){this.glCtx=void 0,this.textureId=void 0,this.glCtx=A,this.textureId=I}static create(A){const I=A.createTexture();return A.bindTexture(A.TEXTURE_2D,I),A.texParameteri(A.TEXTURE_2D,A.TEXTURE_MAG_FILTER,A.NEAREST),A.texParameteri(A.TEXTURE_2D,A.TEXTURE_MIN_FILTER,A.NEAREST),A.texParameteri(A.TEXTURE_2D,A.TEXTURE_WRAP_S,A.CLAMP_TO_EDGE),A.texParameteri(A.TEXTURE_2D,A.TEXTURE_WRAP_T,A.CLAMP_TO_EDGE),A.bindTexture(A.TEXTURE_2D,null),new g(A,I)}uploadBuffer(A,I,g){const e=this.glCtx;e.bindTexture(e.TEXTURE_2D,this.textureId),e.texImage2D(e.TEXTURE_2D,0,e.LUMINANCE,I,g,0,e.LUMINANCE,e.UNSIGNED_BYTE,A),e.bindTexture(e.TEXTURE_2D,null)}delete(){null!=this.glCtx&&0!=this.textureId&&(this.glCtx.deleteTexture(this.textureId),this.textureId=0)}}I.default=g},425:function(A,I,g){"use strict";var e,B=this&&this.__awaiter||function(A,I,g,e){return new(g||(g=Promise))((function(B,i){function t(A){try{C(e.next(A))}catch(A){i(A)}}function Q(A){try{C(e.throw(A))}catch(A){i(A)}}function C(A){var I;A.done?B(A.value):(I=A.value,I instanceof g?I:new g((function(A){A(I)}))).then(t,Q)}C((e=e.apply(A,I||[])).next())}))},i=this&&this.__classPrivateFieldSet||function(A,I,g){if(!I.has(A))throw new TypeError("attempted to set private field on non-instance");return I.set(A,g),g},t=this&&this.__classPrivateFieldGet||function(A,I){if(!I.has(A))throw new TypeError("attempted to get private field on non-instance");return I.get(A)};Object.defineProperty(I,"__esModule",{value:!0}),I.MediaManager=I.RainwayStreamFit=I.RainwayVideoFormat=I.RainwayVideoDecoder=void 0;const Q=g(900),C=g(585),E=g(78),o=g(914),a=g(146),n=g(930),s=g(904);var r,d,h;!function(A){A[A.MSE=0]="MSE",A[A.Software=1]="Software"}(r=I.RainwayVideoDecoder||(I.RainwayVideoDecoder={})),function(A){A[A.AnnexB=0]="AnnexB",A[A.LengthPrefixed=1]="LengthPrefixed"}(d=I.RainwayVideoFormat||(I.RainwayVideoFormat={})),function(A){A[A.IsolatedApps=0]="IsolatedApps",A[A.FullDesktop=1]="FullDesktop"}(h=I.RainwayStreamFit||(I.RainwayStreamFit={})),I.MediaManager=class{constructor(A,I,g,B){var n;this.captureMode=A,this.chosenVideoConfig=I,e.set(this,void 0),this.overlayEnabled=!1,this.streamFit=h.IsolatedApps,i(this,e,{video:Object.assign(Object.assign({codecString:'video/mp4; codecs="avc1.42c020"'},this.autodetectVideoConfiguration()),g.video),videoPerformance:null!==(n=g.videoPerformance)&&void 0!==n?n:{},audio:Object.assign({},g.audio)}),t(this,e).video.decoder===r.Software?this.videoStream=new a.VideoStreamSoftwareDecoder(t(this,e).video.codecString,d.LengthPrefixed):this.videoStream=new Q.VideoStreamMSE(t(this,e).video.codecString),this.audioStream=new C.AudioStream,this.audioStream.configure(t(this,e).audio),this.videoPerformanceMonitor=new E.VideoPerformanceMonitor(this.videoStream,t(this,e).videoPerformance),this.videoStatsOverlay=new o.VideoStatsOverlay(this.videoStream,t(this,e).video.decoder===r.Software,B)}get videoReadyStateChangeEvent(){return this.videoStream.readyStateChangeEvent}get videoNeedsRestartEvent(){return this.videoStream.needsRestartEvent}get audioContext(){return this.audioStream.audioContext}get currentStreamBounds(){return this.streamBounds}get currentFullDesktopBounds(){return this.fullDesktopBounds}initialize(){return B(this,void 0,void 0,(function*(){yield this.audioStream.initialize(),this.audioStream.play()}))}get config(){return t(this,e)}autodetectVideoConfiguration(){return{decoder:window.MediaSource?r.MSE:r.Software}}setContainer(A){if(this.unsetContainer(),this.container=A,this.captureMode===s.CaptureMode.AppIsolation){const A=this.createIsolationCanvasElement();this.showStreamElement(A),t(this,e).video.decoder===r.MSE?this.setIsolationSource(this.createVideoElement()):this.setIsolationSource(this.createCanvasElement())}else t(this,e).video.decoder===r.MSE?this.showStreamElement(this.createVideoElement()):this.showStreamElement(this.createCanvasElement());this.overlayEnabled&&this.createAndShowStatsOverlay()}setIsolationSource(A){this.isolationSource=A}createAndShowStatsOverlay(){const A=this.createOverlayCanvasElement();this.showOverlayElement(A),t(this,e).video.decoder===r.MSE?this.videoStatsOverlay.setElements({video:this.videoElement,canvas:A,usingOutputCanvas:!1}):this.videoStatsOverlay.setElements({canvas:A,usingOutputCanvas:!1})}unsetContainer(){var A,I,g,e,B,i,t,Q;this.disposeVideoElement(),this.disposeCanvasElement(),this.disposeOverlayCanvasElement(),this.disposeIsolationCanvasElement(),null===(I=null===(A=this.container)||void 0===A?void 0:A.querySelector(".rainway-video"))||void 0===I||I.remove(),null===(e=null===(g=this.container)||void 0===g?void 0:g.querySelector(".rainway-canvas"))||void 0===e||e.remove(),null===(i=null===(B=this.container)||void 0===B?void 0:B.querySelector(".rainway-overlay-canvas"))||void 0===i||i.remove(),null===(Q=null===(t=this.container)||void 0===t?void 0:t.querySelector(".rainway-isolation-canvas"))||void 0===Q||Q.remove(),this.container=void 0}showOverlayElement(A){Object.assign(A.style,{position:"absolute",top:"0",bottom:"0",left:"0",right:"0",width:"100%",height:"100%",pointerEvents:"none"})}createVideoElement(){var A,I;null===(I=null===(A=this.container)||void 0===A?void 0:A.querySelector(".rainway-video"))||void 0===I||I.remove(),this.videoElement=document.createElement("video");const g=this.videoElement;return g.oncontextmenu=()=>!1,g.className="rainway-video",g.autoplay=!0,g.muted=!0,g.style.display="none",this.container.appendChild(g),this.videoStream.attachToElement(g),this.videoElement}disposeVideoElement(){this.videoElement&&(this.videoStream.detachFromElement(),this.videoElement.remove(),this.videoElement=void 0)}createOverlayCanvasElement(){var A,I,g;null===(I=null===(A=this.container)||void 0===A?void 0:A.querySelector(".rainway-overlay-canvas"))||void 0===I||I.remove(),this.canvasElement=document.createElement("canvas");const e=this.canvasElement;return e.oncontextmenu=()=>!1,e.className="rainway-overlay-canvas",this.container.appendChild(e),null===(g=e.getContext("2d"))||void 0===g||g.clearRect(0,0,e.width,e.height),e}disposeOverlayCanvasElement(){var A,I;null===(I=null===(A=this.container)||void 0===A?void 0:A.querySelector(".rainway-overlay-canvas"))||void 0===I||I.remove(),this.overlayCanvasElement&&(this.overlayCanvasElement.remove(),this.overlayCanvasElement=void 0)}createCanvasElement(){var A,I,g;null===(I=null===(A=this.container)||void 0===A?void 0:A.querySelector(".rainway-canvas"))||void 0===I||I.remove(),this.canvasElement=document.createElement("canvas");const e=this.canvasElement;return e.oncontextmenu=()=>!1,e.className="rainway-canvas",e.style.display="none",this.container.appendChild(e),this.videoStream instanceof a.VideoStreamSoftwareDecoder&&this.videoStream.attachToCanvas(e),null===(g=e.getContext("2d"))||void 0===g||g.clearRect(0,0,e.width,e.height),e}disposeCanvasElement(){this.canvasElement&&(this.videoStream instanceof a.VideoStreamSoftwareDecoder&&this.videoStream.detachFromCanvas(),this.canvasElement.remove(),this.canvasElement=void 0)}createIsolationCanvasElement(){var A,I,g;null===(I=null===(A=this.container)||void 0===A?void 0:A.querySelector(".rainway-isolation-canvas"))||void 0===I||I.remove(),this.isolationCanvasElement=document.createElement("canvas");const e=this.isolationCanvasElement;return e.oncontextmenu=()=>!1,e.className="rainway-isolation-canvas",this.container.appendChild(e),null===(g=e.getContext("2d"))||void 0===g||g.clearRect(0,0,e.width,e.height),e}disposeIsolationCanvasElement(){this.isolationCanvasElement&&(this.isolationCanvasElement.remove(),this.isolationCanvasElement=void 0)}hideStreamElement(A){A.style.width="0",A.style.height="0"}showStreamElement(A){this.container&&(this.streamElement=A,A.style.width="100%",A.style.height="100%",A.style.display="block",A.style.objectFit="contain")}pause(){this.videoStream.pause(),this.audioStream.stop()}play(){this.videoStream.play(),this.audioStream.play()}renderVideoFrame(A,I){this.videoStream.pushData(A,I),this.fullDesktopBounds={left:A.x,top:A.y,width:A.width,height:A.height},this.captureMode===s.CaptureMode.AppIsolation?(A.mask.length>0&&(this.mask=A.mask),A.width>0&&(this.frameWidth=A.width),A.height>0&&(this.frameHeight=A.height),this.renderIsolatedApp()):this.streamBounds=this.fullDesktopBounds}renderIsolatedApp(){if(!this.mask)return;if(!this.frameWidth)return;if(!this.frameHeight)return;const A=this.isolationSource;if(!A)return;const I=this.isolationCanvasElement;if(!I)return;const g=I.getContext("2d");if(!g)return;const e=this.streamFit==h.IsolatedApps?n.boundingRectangle(this.mask):this.fullDesktopBounds;this.streamBounds=e;const B=this.chosenVideoConfig.codec.width/this.frameWidth,i=this.chosenVideoConfig.codec.height/this.frameHeight;I.width=e.width*B,I.height=e.height*i;for(const{left:I,top:t,width:Q,height:C}of this.mask){const E=I*B,o=t*i,a=Q*B,n=C*i,s=(I-e.left)*B,r=(t-e.top)*i;g.drawImage(A,E,o,a,n,s,r,a,n)}}processAudio(A){this.audioStream.pushData(A)}getVideoStats(){return this.videoStream.getStats()}configureAudio(A){return B(this,void 0,void 0,(function*(){t(this,e).audio=Object.assign(Object.assign({},t(this,e).audio),A),this.audioStream.configure(A)}))}enableStatsOverlay(){this.overlayEnabled=!0,this.videoStatsOverlay.enable(),this.disposeOverlayCanvasElement(),this.createAndShowStatsOverlay()}disableStatsOverlay(){this.disposeOverlayCanvasElement(),this.overlayEnabled=!1,this.videoStatsOverlay.disable()}dispose(){this.pause(),this.unsetContainer(),this.audioStream.dispose(),this.videoStream.dispose()}setVolume(A){this.audioStream.setVolume(A)}},e=new WeakMap},633:function(A,I){"use strict";var g,e=this&&this.__awaiter||function(A,I,g,e){return new(g||(g=Promise))((function(B,i){function t(A){try{C(e.next(A))}catch(A){i(A)}}function Q(A){try{C(e.throw(A))}catch(A){i(A)}}function C(A){var I;A.done?B(A.value):(I=A.value,I instanceof g?I:new g((function(A){A(I)}))).then(t,Q)}C((e=e.apply(A,I||[])).next())}))},B=this&&this.__classPrivateFieldGet||function(A,I){if(!I.has(A))throw new TypeError("attempted to get private field on non-instance");return I.get(A)},i=this&&this.__classPrivateFieldSet||function(A,I,g){if(!I.has(A))throw new TypeError("attempted to set private field on non-instance");return I.set(A,g),g};Object.defineProperty(I,"__esModule",{value:!0}),I.CircularBuffer=I.average=I.createSourceBuffer=I.awaitMediaSourceOpen=I.createMediaSource=I.MediaUnsupportedError=void 0;class t extends Error{}function Q(A,I){return e(this,void 0,void 0,(function*(){return new Promise(((g,e)=>{let B=!1;const i=()=>{A.removeEventListener("sourceopen",t),null==I||I.removeHandler(E),window.clearInterval(C),B=!0},t=()=>{i(),g(!0)},Q=()=>{B||"open"===A.readyState&&(i(),g(!0))},C=window.setInterval(Q,500);Q(),window.setTimeout((()=>{B||(i(),e(new Error("MediaSource open timed out.")))}),1e4),A.addEventListener("sourceopen",t);const E=()=>{i(),g(!1)};null==I||I.addHandler(E)}))}))}I.MediaUnsupportedError=t,I.createMediaSource=function(A,I){return e(this,void 0,void 0,(function*(){if(!window.MediaSource)throw new t("Browser does not support MSE.");const g=new MediaSource,e=window.URL.createObjectURL(g);if(A.src=void 0,A.src=e,A.load(),yield Q(g,I))return g.duration=Number.POSITIVE_INFINITY,g}))},I.awaitMediaSourceOpen=Q,I.createSourceBuffer=function(A,I){const g=A.addSourceBuffer(I);return g.mode="sequence",g},I.average=function(A){return 0===A.length?0:A.reduce(((A,I)=>A+I),0)/A.length},I.CircularBuffer=class{constructor(A){this.maxLength=A,this.nextIndex=0,this.list=Array(this.maxLength),g.set(this,0)}get length(){return B(this,g)}push(A){this.list[this.nextIndex++]=A,i(this,g,Math.max(B(this,g),this.nextIndex)),this.nextIndex%=this.maxLength}values(){return this.list.slice(0,B(this,g))}},g=new WeakMap},78:(A,I,g)=>{"use strict";Object.defineProperty(I,"__esModule",{value:!0}),I.VideoPerformanceMonitor=void 0;const e=g(198),B=g(434),i=g(24),t={targetFramerate:60,bufferLimitMs:500,cpuStarvationThreshold:1,decoderStrugglingThreshold:1,checkInterval:1500,windowMs:500};I.VideoPerformanceMonitor=class{constructor(A,I={}){this.videoStream=A,this.decoderStrugglingEvent=new i.Action,this.cpuStarvationEvent=new i.Action,this.cpuStarvationCounter=0,this.decoderStrugglingCounter=0,this.readyStateChangeHandler=A=>{A===B.VideoReadyState.Detached?this.stopChecking():this.lastVideoReadyState===B.VideoReadyState.Detached&&this.startChecking(),this.lastVideoReadyState=A},this.videoFrameMetadataHandler=A=>{this.processingDurationTrack.feed(A)},this.checkPerformance=()=>{if(this.videoStream.readyState===B.VideoReadyState.Playing){const A=1/this.config.targetFramerate,I=1e3*A,g=Math.floor(this.config.bufferLimitMs/I),e=this.videoStream.getStats();(e.endOfBuffered>e.currentTime+this.config.bufferLimitMs/1e3||this.videoStream.dataQueueLength>g)&&this.videoStream.restart("checkPerformance"),this.videoStream.dataQueueLength>g?this.cpuStarvationCounter+=1:this.cpuStarvationCounter=Math.max(0,this.cpuStarvationCounter-1),this.processingDurationTrack.average()>A?(this.decoderStrugglingCounter+=1,this.cpuStarvationCounter=Math.max(0,this.cpuStarvationCounter-1)):this.decoderStrugglingCounter=Math.max(0,this.decoderStrugglingCounter-1),this.cpuStarvationCounter,this.config.cpuStarvationThreshold,this.decoderStrugglingCounter,this.config.decoderStrugglingThreshold}},this.config=Object.assign(Object.assign({},t),I),this.processingDurationTrack=new e.WindowTrack(this.config.windowMs,e.meanOrZero),this.videoStream.readyStateChangeEvent.addHandler(this.readyStateChangeHandler),this.videoStream.videoFrameProcessingDurationEvent.addHandler(this.videoFrameMetadataHandler),this.lastVideoReadyState=this.videoStream.readyState,this.videoStream.readyState!==B.VideoReadyState.Detached&&this.startChecking()}dispose(){this.stopChecking(),this.videoStream.readyStateChangeEvent.removeHandler(this.readyStateChangeHandler),this.videoStream.videoFrameProcessingDurationEvent.removeHandler(this.videoFrameMetadataHandler)}startChecking(){this.processingDurationTrack=new e.WindowTrack(this.config.windowMs,e.meanOrZero),this.checkPerformanceInterval=window.setInterval(this.checkPerformance,this.config.checkInterval)}stopChecking(){this.checkPerformanceInterval&&(window.clearInterval(this.checkPerformanceInterval),this.checkPerformanceInterval=void 0)}}},914:function(A,I,g){"use strict";var e=this&&this.__awaiter||function(A,I,g,e){return new(g||(g=Promise))((function(B,i){function t(A){try{C(e.next(A))}catch(A){i(A)}}function Q(A){try{C(e.throw(A))}catch(A){i(A)}}function C(A){var I;A.done?B(A.value):(I=A.value,I instanceof g?I:new g((function(A){A(I)}))).then(t,Q)}C((e=e.apply(A,I||[])).next())}))};Object.defineProperty(I,"__esModule",{value:!0}),I.VideoStatsOverlay=void 0;const B=g(146),i=g(434),t=g(198),Q=5e3,C={droppedFrames:"Dropped frames",totalFrames:"Total frames",currentTime:"Current video time",endOfBuffered:"End of video buffer",endOfSeekable:"End of video seekable",dataInterval:"Video data interval",dataSize:"Video frame size",processingDuration:"Frame processing duration"};I.VideoStatsOverlay=class{constructor(A,I,g){this.videoStream=A,this.usingOutputCanvas=I,this.getStats=g,this.compositingTimeTrack=new t.WindowTrack(Q,t.mean),this.processingDurationTrack=new t.WindowTrack(Q,t.mean),this.frameTrack=new t.WindowTrack(Q,t.mean),this.drawIntervalTrack=new t.WindowTrack(Q,t.mean),this.displayTimeIntervalTrack=new t.WindowTrack(Q,t.mean),this.frameCounter=0,this.throughput=[],this.fetchStats=()=>e(this,void 0,void 0,(function*(){this.videoStream.readyState===i.VideoReadyState.Playing&&(this.stats=this.videoStream.getStats(),this.lastTransportStats=this.transportStats,this.transportStats=yield this.getStats(),this.throughput=this.getThroughput())})),this.animationFrameHandler=()=>{this.frameTrack.feed(this.frameCounter),this.frameCounter=0,this.animationFrameHandle=window.requestAnimationFrame(this.animationFrameHandler)},this.drawStatsOnlyOnAnimationFrame=()=>{if(this.drawStatsOnlyHandle=window.requestAnimationFrame(this.drawStatsOnlyOnAnimationFrame),!this.canvasContext||this.videoStream.readyState!==i.VideoReadyState.Playing)return;const A=this.canvasContext;this.usingOutputCanvas||(A.canvas.width!==A.canvas.clientWidth&&(A.canvas.width=A.canvas.clientWidth),A.canvas.height!==A.canvas.clientHeight&&(A.canvas.height=A.canvas.clientHeight),A.clearRect(0,0,A.canvas.width,A.canvas.height)),this.drawStats()},this.drawStatsAndGraphsOnVideoFrame=([A,I])=>{if(this.frameCounter++,!this.canvasContext||this.videoStream.readyState!==i.VideoReadyState.Playing||!I)return;const g=this.canvasContext;this.usingOutputCanvas||(g.canvas.width!==g.canvas.clientWidth&&(g.canvas.width=g.canvas.clientWidth),g.canvas.height!==g.canvas.clientHeight&&(g.canvas.height=g.canvas.clientHeight),g.clearRect(0,0,g.canvas.width,g.canvas.height));const e=performance.now();this.lastCanvasDrawTime&&this.drawIntervalTrack.feed(e-this.lastCanvasDrawTime),this.lastCanvasDrawTime=e;const B=I.expectedDisplayTime;this.lastDisplayTime&&this.displayTimeIntervalTrack.feed(B-this.lastDisplayTime),this.lastDisplayTime=B,this.compositingTimeTrack.feed(I.expectedDisplayTime-A),this.processingDurationTrack.feed(I.processingDuration);const t=g.canvas;t.width,t.clientWidth,t.height,t.clientHeight,this.drawStats(I)}}setElements({video:A,canvas:I,usingOutputCanvas:g=!1}){this.usingOutputCanvas=g,this.canvas=I,this.video=A,this.canvas&&(this.canvasContext=this.canvas.getContext("2d",{alpha:!this.usingOutputCanvas}))}enable(){this.animationFrameHandle&&window.cancelAnimationFrame(this.animationFrameHandle),this.drawStatsOnlyHandle&&window.cancelAnimationFrame(this.drawStatsOnlyHandle),this.videoStream instanceof B.VideoStreamSoftwareDecoder||"requestVideoFrameCallback"in HTMLVideoElement.prototype?(this.animationFrameHandle=window.requestAnimationFrame(this.animationFrameHandler),this.videoStream.videoFrameEvent.addHandler(this.drawStatsAndGraphsOnVideoFrame)):this.drawStatsOnlyHandle=window.requestAnimationFrame(this.drawStatsOnlyOnAnimationFrame),this.statsInterval=window.setInterval(this.fetchStats,1e3)}disable(){this.animationFrameHandle&&window.cancelAnimationFrame(this.animationFrameHandle),this.drawStatsOnlyHandle&&window.cancelAnimationFrame(this.drawStatsOnlyHandle),this.videoStream.videoFrameEvent.removeHandler(this.drawStatsAndGraphsOnVideoFrame),window.clearInterval(this.statsInterval)}getThroughput(){var A;return this.transportStats&&this.lastTransportStats?Object.entries(null===(A=this.transportStats)||void 0===A?void 0:A.channels).map((([A,I])=>this.lastTransportStats?[A,I.bytesSent-this.lastTransportStats.channels[A].bytesSent,I.bytesReceived-this.lastTransportStats.channels[A].bytesReceived]:[A,0,0])):[]}drawStats(A){var I,g;if(!this.canvasContext||this.videoStream.readyState!==i.VideoReadyState.Playing)return;const e=this.canvasContext,B=e.canvas,t=B.width/B.clientWidth,Q=B.height/B.clientHeight,E=this.throughput;if(this.stats){const i=Object.entries(this.stats),o=i.length+E.length,a=e.measureText("M").width;e.fillStyle="rgba(0, 0, 0, 0.5)";const n=(o+2)*a+2*(a+2*Q)+15*Q;e.fillRect(10*t,B.height-(n+10*Q),300*t,n),e.fillStyle="white",e.font=`${(12*t).toFixed(0)}px sans-serif`,e.textBaseline="top";let s=0;const r=B.height-(n+15*Q)+15*t;A?e.fillText(`Resolution: ${A.width}x${A.height}`,15*t,r):e.fillText(`Resolution: ${null===(I=this.video)||void 0===I?void 0:I.videoWidth}x${null===(g=this.video)||void 0===g?void 0:g.videoHeight}`,15*t,r),e.fillText(`Element size: ${B.clientWidth}x${B.clientHeight}`,15*t,r+a);for(const[A,I]of i){let g,B="";"processingDuration"===A?(B="ms",g=1e3*I):g=I,"endOfBuffered"===A||"endOfSeekable"===A||"currentTime"===A?B="s":"dataInterval"===A?B="ms":"dataSize"===A&&(B="bytes"),e.fillText(`${C[A]}: ${g.toFixed(2)} ${B}`,15*t,s*(a+2*Q)+2*(a+2*Q)+r),s++}for(const[A,I,g]of E)e.fillText(`${A} throughput - up: ${(I/1e3).toFixed(0)} kb/s, down: ${(g/1e3).toFixed(0)} kb/s`,15*t,s*(a+2*Q)+2*(a+2*Q)+r),s++}}}},441:(A,I,g)=>{"use strict";Object.defineProperty(I,"__esModule",{value:!0}),I.VideoStats=void 0;const e=g(994),B=g(633);I.VideoStats=class{constructor(){this.processingDurations=new Map,this.dataIntervals=new B.CircularBuffer(60),this.dataSizes=new B.CircularBuffer(60),this.totalFrames=0,this.presentedFrames=0}pushFrameMetadata(A){this.presentedFrames+=1;const{processingDuration:I}=A,g=(new Date).getTime();this.processingDurations.set(g,I);for(const[A]of this.processingDurations.entries())A<g-1e3&&this.processingDurations.delete(A)}reportFrameSubmitted(){this.totalFrames+=1}resetFrameCounts(){this.totalFrames=0,this.presentedFrames=0}pushData(A){this.dataSizes.push(A.byteLength);const I=(new Date).getTime();this.lastDataTimestamp&&this.dataIntervals.push(I-this.lastDataTimestamp),this.lastDataTimestamp=I}setElement(A){this.element=A}getReport(){if(!this.element)throw new e.RainwayError("getReport() has no video element");const A=B.average(Array.from(this.processingDurations.values())),I=this.element.buffered,g=I.length>0?I.end(I.length-1):0,i=this.element.seekable,t=i.length>0?i.end(i.length-1):0;return{processingDuration:A,droppedFrames:this.totalFrames-this.presentedFrames,totalFrames:this.totalFrames,dataInterval:B.average(this.dataIntervals.values()),dataSize:B.average(this.dataSizes.values()),currentTime:this.element.currentTime,endOfBuffered:g,endOfSeekable:t}}createReport(A,I){return{processingDuration:B.average(Array.from(this.processingDurations.values())),droppedFrames:null!=A?A:0,totalFrames:null!=I?I:0,dataInterval:B.average(this.dataIntervals.values()),dataSize:B.average(this.dataSizes.values()),currentTime:0,endOfBuffered:0,endOfSeekable:0}}}},900:function(A,I,g){"use strict";var e=this&&this.__awaiter||function(A,I,g,e){return new(g||(g=Promise))((function(B,i){function t(A){try{C(e.next(A))}catch(A){i(A)}}function Q(A){try{C(e.throw(A))}catch(A){i(A)}}function C(A){var I;A.done?B(A.value):(I=A.value,I instanceof g?I:new g((function(A){A(I)}))).then(t,Q)}C((e=e.apply(A,I||[])).next())}))};Object.defineProperty(I,"__esModule",{value:!0}),I.VideoStreamMSE=void 0;const B=g(24),i=g(633),t=g(434),Q=g(464),C=g(441);function E(A){return 102===A[4]&&116===A[5]&&121===A[6]&&112===A[7]}I.VideoStreamMSE=class{constructor(A){this.codecString=A,this.readyState=t.VideoReadyState.Detached,this.needsRestartEvent=new B.Action,this.sourceOpenEvent=new B.Action,this.readyStateChangeEvent=new B.Action,this.videoFrameEvent=new B.Action,this.videoFrameProcessingDurationEvent=new B.Action,this.cancelInitializeEvent=new B.Action,this.dataQueue=[],this.stats=new C.VideoStats,this.justClearedBuffer=!1,this.lastBufferEnd=0,this.framesFrozenFor=0,this.ensureBuffer=()=>{if(this.readyState!==t.VideoReadyState.Paused&&this.readyState!==t.VideoReadyState.Detached&&this.element&&0===this.element.buffered.length){if(this.sourceBuffer&&!this.sourceBuffer.updating&&this.sourceBuffer.timestampOffset<=0){const A=this.sourceBuffer.timestampOffset.toFixed(2);this.sourceBuffer.timestampOffset=1;const I=this.sourceBuffer.timestampOffset.toFixed(2);this.warn(`Poked timestampOffset from ${A} to ${I}`)}this.restart("ensureBuffer")}},this.videoFrameHandler=(A,I)=>{(null==I?void 0:I.processingDuration)&&this.videoFrameProcessingDurationEvent.invoke(I.processingDuration),I&&this.stats.pushFrameMetadata(I),this.videoFrameEvent.invoke([A,I]),this.requestNextFrameCallback()},this.fallbackVideoFrameHandler=A=>{this.videoFrameHandler(A,void 0)},this.sourceBufferUpdateHandler=()=>{this.submitData()},window.__rainwayVideo=this}info(A){Q.RainwayLogging.information(`[VideoStream] ${String(A)}`)}debug(A){Q.RainwayLogging.debug(`[VideoStream] ${String(A)}`)}warn(A){Q.RainwayLogging.warning(`[VideoStream] ${String(A)}`)}get dataQueueLength(){return this.dataQueue.length}attachToElement(A){this.info("Attaching to element: "+A),this.cancelInitializeEvent.invoke(),this.element=A,this.stats.setElement(this.element),this.stats.resetFrameCounts(),this.restart("attachToElement"),this.info("Attached to element.")}detachFromElement(){this.destroyMedia(),this.element=void 0,this.setReadyState(t.VideoReadyState.Detached),this.info("Detached from element.")}pause(){this.setReadyState(t.VideoReadyState.Paused)}play(){this.readyState===t.VideoReadyState.Paused&&this.restart("play")}pushData(A,I){if(this.dataQueue.length>8)return void this.restart("pushData.dataQueue too long");const g=new Uint8Array(I);return this.stats.pushData(g),this.readyState!==t.VideoReadyState.Paused?E(g)&&this.readyState===t.VideoReadyState.WaitingForKeyframe&&this.element?(this.debug(`Got requested keyframe (${g.length} bytes)`),this.getStats(),this.dataQueue.push(g),this.submitData(),void this.initializeMedia()):void(this.readyState!==t.VideoReadyState.WaitingForKeyframe&&this.element?(this.dataQueue.push(g),this.submitData()):this.startEnsuringBuffer()):void 0}getStats(){return this.stats.getReport()}setReadyState(A){this.info(`ReadyState changed: ${t.VideoReadyState[this.readyState]} => ${t.VideoReadyState[A]}`),this.readyState=A,this.readyStateChangeEvent.invoke(A)}submitData(){if(0!==this.dataQueue.length)if(void 0!==this.mediaSource)if(this.sourceBuffer){if(!this.sourceBuffer.updating)if(this.element){if(this.sourceBuffer.buffered.length>=1){const A=this.sourceBuffer.buffered.end(this.sourceBuffer.buffered.length-1);this.justClearedBuffer&&(this.element.currentTime=A,this.justClearedBuffer=!1),A===this.lastBufferEnd?(this.framesFrozenFor++,this.debug(`Frozen for ${this.framesFrozenFor} frames...`)):this.framesFrozenFor=0,this.lastBufferEnd=A}if(this.framesFrozenFor>=4)return this.restart("sourceBuffer FrozenFrames"),void(this.framesFrozenFor=0);try{const A=this.dataQueue[0];if(E(A)&&!this.justClearedBuffer)return this.debug("Got keyframe. Clearing sourcebuffer."),this.getStats(),this.sourceBuffer.remove(0,1/0),void(this.justClearedBuffer=!0);this.dataQueue.shift(),this.sourceBuffer.appendBuffer(A),this.stats.reportFrameSubmitted()}catch(A){Q.RainwayLogging.error(String(A)),this.restart("submitData, sourceBuffer.appendBuffer error.")}}else this.debug("Idling because !element")}else this.debug("Idling because !sourceBuffer");else this.debug("Idling because mediaSource === undefined")}initializeMedia(){var A,I;return e(this,void 0,void 0,(function*(){if(this.setReadyState(t.VideoReadyState.Initializing),this.cancelInitializeEvent.invoke(),void 0!==this.mediaSource)return this.setReadyState(t.VideoReadyState.Playing),void(null===(A=this.element)||void 0===A||A.play());if(!this.element)throw new Error("Stream not attached to element.");try{const A=yield i.createMediaSource(this.element,this.cancelInitializeEvent);if(!A)return void this.setReadyState(t.VideoReadyState.WaitingForKeyframe);this.mediaSource=A,this.sourceBuffer=i.createSourceBuffer(this.mediaSource,this.codecString),this.sourceBuffer.addEventListener("updateend",this.sourceBufferUpdateHandler),this.sourceBuffer.addEventListener("error",(A=>console.error("sourceBuffer error:",A))),this.startEnsuringBuffer(),this.setReadyState(t.VideoReadyState.Playing),this.requestNextFrameCallback(),this.submitData(),null===(I=this.element)||void 0===I||I.play()}catch(A){this.setReadyState(t.VideoReadyState.WaitingForKeyframe)}}))}startEnsuringBuffer(){void 0===this.ensureBufferInterval&&(this.debug("Starting ensureBuffer loop"),this.ensureBufferInterval=window.setInterval(this.ensureBuffer,1e3))}destroyMedia(){var A,I;if(this.debug("destroyMedia() called"),void 0!==this.mediaSource){if(this.cancelFrameCallback(),null===(A=this.element)||void 0===A||A.pause(),null===(I=this.sourceBuffer)||void 0===I||I.removeEventListener("updateend",this.sourceBufferUpdateHandler),this.mediaSource){if(this.sourceBuffer){try{this.mediaSource.removeSourceBuffer(this.sourceBuffer)}catch(A){}this.sourceBuffer=void 0}if("open"===this.mediaSource.readyState)try{this.mediaSource.endOfStream()}catch(A){}this.mediaSource=void 0,this.element&&window.URL.revokeObjectURL(this.element.src)}window.clearInterval(this.ensureBufferInterval),this.ensureBufferInterval=void 0,this.setReadyState(t.VideoReadyState.WaitingForKeyframe)}}restart(A=""){const I=A?`Restarting Video Stream... Reason: '${A}'.`:"Restarting Video Stream.";this.warn(I),this.dataQueue=[],this.setReadyState(t.VideoReadyState.WaitingForKeyframe),this.needsRestartEvent.invoke()}requestNextFrameCallback(){var A,I,g,e;"requestVideoFrameCallback"in HTMLVideoElement.prototype?(this.frameHandle&&(null===(I=null===(A=this.element)||void 0===A?void 0:A.cancelVideoFrameCallback)||void 0===I||I.call(A,this.frameHandle),this.frameHandle=void 0),this.frameHandle=null===(e=null===(g=this.element)||void 0===g?void 0:g.requestVideoFrameCallback)||void 0===e?void 0:e.call(g,this.videoFrameHandler)):(this.frameHandle&&(window.cancelAnimationFrame(this.frameHandle),this.frameHandle=void 0),this.frameHandle=window.requestAnimationFrame(this.fallbackVideoFrameHandler))}cancelFrameCallback(){var A,I;"requestVideoFrameCallback"in HTMLVideoElement.prototype?this.frameHandle&&(null===(I=null===(A=this.element)||void 0===A?void 0:A.cancelVideoFrameCallback)||void 0===I||I.call(A,this.frameHandle),this.frameHandle=void 0):this.frameHandle&&(window.cancelAnimationFrame(this.frameHandle),this.frameHandle=void 0)}dispose(){this.cancelFrameCallback(),this.destroyMedia(),window.clearInterval(this.ensureBufferInterval),this.setReadyState(t.VideoReadyState.Disposed)}}},146:function(A,I,g){"use strict";var e=this&&this.__importDefault||function(A){return A&&A.__esModule?A:{default:A}};Object.defineProperty(I,"__esModule",{value:!0}),I.VideoStreamSoftwareDecoder=void 0;const B=g(434),i=g(24),t=g(425),Q=e(g(859)),C=e(g(756)),E=e(g(346)),o=g(464),a=g(441);I.VideoStreamSoftwareDecoder=class{constructor(A,I){this.codecString=A,this.format=I,this.readyState=B.VideoReadyState.Detached,this.needsRestartEvent=new i.Action,this.readyStateChangeEvent=new i.Action,this.videoFrameProcessingDurationEvent=new i.Action,this.videoFrameEvent=new i.Action,this.currentFrameInfo={containsSPS:!1,containsPPS:!1,containsFrameData:!0},this.paused=!1,this.stats=new a.VideoStats,this.totalFrames=0,this.waitingToDecodeQueue=[],this.decodeQueue=[],this.maxDecodeQueueSize=3,this.maxLatencyFrameCount=7,this.maxConsecutiveFramesDrops=3,this.framesDroppedSinceLastRender=0,this.totalFramesDropped=0,this.canvas=void 0,this.shader=void 0,this.yTexture=void 0,this.uTexture=void 0,this.vTexture=void 0,this.onDecode=({width:A,height:I,data:g})=>{if(0==this.decodeQueue.length)return o.RainwayLogging.error("[VideoStreamSoftwareDecoder] onDecode called with empty decoder queue!"),void this.sendDecoderWaitingToDecodeFrames();++this.totalFrames;const e=this.decodeQueue.shift();if(!this.paused){const B=Date.now();if(e.processingDuration=(B-e.mediaTime)/1e3,this.videoFrameProcessingDurationEvent.invoke(e.processingDuration),this.dataQueueLength>this.maxLatencyFrameCount&&this.framesDroppedSinceLastRender<this.maxConsecutiveFramesDrops)++this.framesDroppedSinceLastRender,++this.totalFramesDropped;else{this.framesDroppedSinceLastRender=0;const B=e.width,i=e.height;e.width=A,e.height=I,this.stats.pushFrameMetadata(e),this.renderFrame(B,i,g,A,I),this.videoFrameEvent.invoke([performance.now(),e])}}this.sendDecoderWaitingToDecodeFrames()},this.ensureBuffer=()=>{this.readyState===B.VideoReadyState.WaitingForKeyframe&&0===this.dataQueueLength&&(o.RainwayLogging.debug("Sending another request for a keyframe."),this.restart())},this.videoFormat=I,this.decoderWorker=new Q.default,this.decoderWorker.initialize(),this.decoderWorker.onDecode=this.onDecode.bind(this),this.ensureBufferInterval=window.setInterval(this.ensureBuffer,1e3)}get dataQueueLength(){return this.waitingToDecodeQueue.length+this.decodeQueue.length}configure(A,I,g){this.maxDecodeQueueSize=A,this.maxLatencyFrameCount=I,this.maxConsecutiveFramesDrops=g}attachToElement(A){this.stats.resetFrameCounts(),this.readyState!=B.VideoReadyState.WaitingForKeyframe&&this.restart()}attachToCanvas(A){this.readyState!=B.VideoReadyState.WaitingForKeyframe&&this.restart(),this.canvas&&this.detachFromCanvas(),this.canvas=A;const I=A.getContext("webgl");this.shader=C.default.create(I),this.yTexture=E.default.create(I),this.uTexture=E.default.create(I),this.vTexture=E.default.create(I)}detachFromElement(){this.setReadyState(B.VideoReadyState.Detached)}detachFromCanvas(){this.decoderWorker.release(),this.yTexture&&this.yTexture.delete(),this.uTexture&&this.uTexture.delete(),this.vTexture&&this.vTexture.delete(),this.canvas=void 0}pause(){this.paused=!0,this.setReadyState(B.VideoReadyState.Paused)}play(){this.paused&&(this.paused=!1,this.restart())}restart(){this.totalFrames=0,this.totalFramesDropped=0,this.framesDroppedSinceLastRender=0,this.waitingToDecodeQueue=[],this.setReadyState(B.VideoReadyState.WaitingForKeyframe),this.needsRestartEvent.invoke()}pushData(A,I){var g,e,i;if(this.stats.pushData(I),this.paused)return;const Q=new Uint8Array(I);let C=!1;if(this.videoFormat==t.RainwayVideoFormat.LengthPrefixed?C=this.convertToAnnexbFormat(Q):this.readyState==B.VideoReadyState.WaitingForKeyframe&&(C=this.parseAnnexbFrameInfo(Q)),this.readyState==B.VideoReadyState.WaitingForKeyframe)if(C)this.setReadyState(B.VideoReadyState.Playing);else if(!(null===(g=this.currentFrameInfo)||void 0===g?void 0:g.containsFrameData))return((null===(e=this.currentFrameInfo)||void 0===e?void 0:e.containsSPS)||(null===(i=this.currentFrameInfo)||void 0===i?void 0:i.containsPPS))&&this.decoderWorker.decode(Q),this.currentFrameInfo.containsSPS=!1,this.currentFrameInfo.containsPPS=!1,void(this.currentFrameInfo.containsFrameData=!0);if(this.readyState!=B.VideoReadyState.WaitingForKeyframe&&this.currentFrameInfo.containsFrameData){const I={width:A.width,height:A.height,mediaTime:Date.now(),processingDuration:0,expectedDisplayTime:0,presentationTime:0,presentedFrames:0};this.decode(I,Q)}}convertToAnnexbFormat(A){let I=!1;this.currentFrameInfo.containsFrameData=!1;for(let g=0;g<A.length;){const e=this.ntohl(A,g);A[g]=0,A[++g]=0,A[++g]=0,A[++g]=1,++g;const B=31&A[g];B<=5&&B>=1?(I=5==B,this.currentFrameInfo.containsFrameData=!0):7==B?this.currentFrameInfo.containsSPS=!0:8==B&&(this.currentFrameInfo.containsPPS=!0),g+=e}return I}ntohl(A,I){return(255&A[I])<<24|(255&A[I+1])<<16|(255&A[I+2])<<8|255&A[I+3]}parseAnnexbFrameInfo(A){let I=!1;this.currentFrameInfo.containsFrameData=!1;for(let g=0;g<A.length;)if(0==A[g]&&0==A[g+1]){let e=0;if(1==A[g+2]?(g+=3,e=31&A[g]):0==A[g+2]&&1==A[g+3]?(g+=4,e=31&A[g]):++g,e<=5&&e>=1){if(this.currentFrameInfo.containsFrameData=!0,5==e){I=!0;break}}else 7==e?this.currentFrameInfo.containsSPS=!0:8==e&&(this.currentFrameInfo.containsPPS=!0)}else++g;return I}decode(A,I){0==this.decodeQueue.length?(0!=this.waitingToDecodeQueue.length&&(o.RainwayLogging.error("[VideoStreamSoftwareDecoder] empty decoder queue, but waiting to decode queue not empty!"),this.waitingToDecodeQueue=[]),this.sendToDecoder(A,I)):(this.waitingToDecodeQueue.push({metadata:A,data:I}),this.decodeQueue.length<this.maxDecodeQueueSize&&this.sendDecoderWaitingToDecodeFrames())}sendDecoderWaitingToDecodeFrames(){for(;this.decodeQueue.length<this.maxDecodeQueueSize&&this.waitingToDecodeQueue.length>0;){const A=this.waitingToDecodeQueue.shift();this.sendToDecoder(A.metadata,A.data)}}sendToDecoder(A,I){this.stats.reportFrameSubmitted(),this.decodeQueue.push(A),this.decoderWorker.decode(I)}renderFrame(A,I,g,e,B){this.canvas.width=A,this.canvas.height=I;const i=new Uint8Array(g),t=e*B,Q=i.subarray(0,t),C=t>>2,E=i.subarray(t,t+C),o=i.subarray(t+C,t+2*C);this.yTexture.uploadBuffer(Q,e,B);const a=e>>1,n=B>>1;this.uTexture.uploadBuffer(E,a,n),this.vTexture.uploadBuffer(o,a,n),this.shader.bindInputTextures(this.yTexture,this.uTexture,this.vTexture);const s=A/e,r=I/B;this.shader.update(e,B,s,r),this.shader.draw()}getStats(){return this.stats.createReport(this.totalFramesDropped,this.totalFrames)}setReadyState(A){this.readyState=A,this.readyStateChangeEvent.invoke(A)}dispose(){o.RainwayLogging.debug("Disposing VideoStreamSoftwareDecoder"),this.readyState=B.VideoReadyState.Disposed,this.decoderWorker.release(),this.decoderWorker.dispose(),window.clearInterval(this.ensureBufferInterval)}}},104:function(A,I,g){"use strict";var e,B=this&&this.__awaiter||function(A,I,g,e){return new(g||(g=Promise))((function(B,i){function t(A){try{C(e.next(A))}catch(A){i(A)}}function Q(A){try{C(e.throw(A))}catch(A){i(A)}}function C(A){var I;A.done?B(A.value):(I=A.value,I instanceof g?I:new g((function(A){A(I)}))).then(t,Q)}C((e=e.apply(A,I||[])).next())}))},i=this&&this.__classPrivateFieldGet||function(A,I){if(!I.has(A))throw new TypeError("attempted to get private field on non-instance");return I.get(A)},t=this&&this.__classPrivateFieldSet||function(A,I,g){if(!I.has(A))throw new TypeError("attempted to set private field on non-instance");return I.set(A,g),g};Object.defineProperty(I,"__esModule",{value:!0}),I.Gateway=I.getHandshakeDataBase64=I.getPeerId=I.GatewayStatus=void 0;const Q=g(290),C=g(994),E=g(464),o=g(904),a=g(24);var n;function s(A,I,g){const e=o.GatewayIdentity.encode({id:A,apiKey:I,externalId:g});return btoa(String.fromCharCode(...e)).replace(/=*$/,"").replace(/\+/g,"-").replace(/\//g,"_")}!function(A){A[A.Open=0]="Open",A[A.Closed=1]="Closed"}(n=I.GatewayStatus||(I.GatewayStatus={})),I.getPeerId=function(A){var I;return B(this,void 0,void 0,(function*(){const g=yield Q.getOrganizationInfo(A),e=`rainway-hostname-${g.organizationId.toString(16).padStart(8,"0")}-${g.universeFlag}`,B=BigInt(null!==(I=localStorage.getItem(e))&&void 0!==I?I:yield Q.fetchNewPeerId());return localStorage.setItem(e,B.toString()),B}))},I.getHandshakeDataBase64=s,I.Gateway=class{constructor(A,I,g,i,t,Q,C="wss://gateway.rainway.network"){this.ownPeerId=A,this.apiKey=I,this.externalId=g,this.handlePeerInfo=i,this.connectionRequestHandler=t,this.addAcceptedPeer=Q,this.connections=new Map,this.connectionLostEvent=new a.Action,e.set(this,n.Closed),this.syncKey=0,this.peerIdToExternalId=new Map,this.onMessage=A=>B(this,void 0,void 0,(function*(){var I;if(void 0!==this.socket&&"[object ArrayBuffer]"===A.data.toString()){const g=o.GatewayDatagram.decode(new Uint8Array(A.data)),{header:{syncKey:e},body:B}=g;switch(B.discriminator){case o.GatewayRequest.discriminator:E.RainwayLogging.warning("got GatewayRequest?! i am not a gateway. ignoring");break;case o.GatewayResponse.discriminator:{const A=B.value.body.value;E.RainwayLogging.trace("got GatewayHello"),null===(I=this.resolveConnectToGatewayPromise)||void 0===I||I.call(this,A);break}case o.GatewayAlert.discriminator:{const{level:A,description:I}=B.value;A===o.GatewayAlertLevel.Fatal?(E.RainwayLogging.error("Fatal GatewayAlert: "+o.GatewayAlertDescription[I]),this.die(I,"The connection to the Rainway server encountered a fatal error.")):this.onNonFatalAlert(e,I);break}case o.GatewayForwardable.discriminator:this.onForwardable(e,B.value)}}})),this.onClose=A=>{this.die(A,"The connection to the Rainway server was closed.")},this.onError=A=>{this.die(A,"The connection to the Rainway server was lost.")},window.__rainwayGateway=this,this.url=C}get status(){return i(this,e)}connect(){var A;return B(this,void 0,void 0,(function*(){return null!==(A=this.connectToGatewayPromise)&&void 0!==A?A:this.connectToGatewayPromise=new Promise(((A,I)=>{this.resolveConnectToGatewayPromise=A,this.rejectConnectToGatewayPromise=I,this.open()}))}))}open(){return B(this,void 0,void 0,(function*(){this.socket=yield this.makeWebSocket(this.url),E.RainwayLogging.debug("Gateway: connected WebSocket"),this.socket.addEventListener("message",this.onMessage),this.socket.addEventListener("close",this.onClose),t(this,e,n.Open)}))}makeWebSocket(A){return new Promise(((I,g)=>{const e=new WebSocket(A,["handshake",s(this.ownPeerId,this.apiKey,this.externalId)]);e.binaryType="arraybuffer",e.onopen=()=>{I(e)},e.onerror=A=>{this.onError(A),g(A),this.connectToGatewayPromise=void 0}}))}disconnect(){var A;if(E.RainwayLogging.debug("Gateway: close()"),void 0!==this.socket){this.socket.close(3e3,"Signaling websocket closed.");const A=this.socket;window.setTimeout((()=>{A.removeEventListener("close",this.onClose),A.removeEventListener("message",this.onMessage)}),0)}null===(A=this.rejectConnectToGatewayPromise)||void 0===A||A.call(this,void 0),t(this,e,n.Closed),this.connectToGatewayPromise=void 0,this.resolveConnectToGatewayPromise=void 0,this.rejectConnectToGatewayPromise=void 0,this.socket=void 0,this.connections.clear()}makeDatagram(A){return{header:{syncKey:++this.syncKey},body:A}}makeForwardable(A,I){return this.makeDatagram({discriminator:o.GatewayForwardable.discriminator,value:{targetPeerId:A,body:I}})}connectToHost(A,I){const g=this.connections.get(A);if(void 0!==g){if(g.owned)throw new C.RainwayError("already connected in other direction");return g.promise}if(void 0===this.socket)throw new C.RainwayError("socket undefined in sendInitConnectionRequest");if(this.status!==n.Open)throw new C.RainwayError("signaling channel not open in sendInitConnectionRequest");const e=this.socket,B={pending:!0};return B.promise=new Promise(((g,i)=>{B.resolve=g,B.reject=i,E.RainwayLogging.trace(`Gateway: Adding ${A} to pendingConnections`);const t=this.makeDatagram({discriminator:o.GatewayRequest.discriminator,value:{body:{discriminator:o.InitConnectionRequest.discriminator,value:{desiredTransport:I,targetPeerId:A}}}});B.syncKey=t.header.syncKey,this.connections.set(A,B),e.send(o.GatewayDatagram.encode(t))})),B.promise}cancelConnectionAttempt(A){const I=this.connections.get(A);void 0!==I&&I.pending&&(I.resolve({canceled:!0}),this.connections.delete(A))}deleteConnection(A){this.connections.delete(A)}sendPeerInfo(A,I,g){if(void 0===this.socket)throw new C.RainwayError("socket unset in Gateway.sendPeerInfo");const e=this.connections.get(A);if(void 0===e)throw new C.RainwayError(`can't send peer info to unknown peerId ${A}`);if(e.pending)throw new C.RainwayError(`can't send peer info to pending peerId ${A}`);const B=this.makeForwardable(A,{discriminator:o.PeerSignalingInformation.discriminator,value:{id:e.connectionRequestId,type:I,data:g}}),i=o.GatewayDatagram.encode(B);this.socket.send(i)}sendOffer(A,I){E.RainwayLogging.debug("sending offer: "+I),this.sendPeerInfo(A,o.PeerInformationType.Offer,I)}sendAnswer(A,I){E.RainwayLogging.debug("sending offer: "+I),this.sendPeerInfo(A,o.PeerInformationType.Answer,I)}sendCandidate(A,I){E.RainwayLogging.debug("sending candidate"+I.candidate),this.sendPeerInfo(A,o.PeerInformationType.Candidate,I.candidate)}onNonFatalAlert(A,I){if(I===o.GatewayAlertDescription.PeerGoneAway)for(const[I,g]of this.connections.entries())g.pending&&g.syncKey===A&&(g.reject("The target peer is not connected to Rainway."),this.connections.delete(I))}onForwardable(A,I){const{targetPeerId:g,body:e}=I;switch(e.discriminator){case o.ConnectionRequest.discriminator:{const{sourcePeerId:I,sourceExternalId:g,desiredTransport:B,id:i,expirationDate:t}=e.value,Q=i;this.peerIdToExternalId.set(I,g),this.connectionRequestHandler({peerId:I,externalId:e.value.sourceExternalId,accept:()=>{if(void 0===this.socket)throw new C.RainwayError("Couldn't send accept message because the connection to Rainway was lost.");const e=o.GatewayDatagram.encode({header:{syncKey:A},body:{discriminator:o.GatewayForwardable.discriminator,value:{targetPeerId:I,body:{discriminator:o.AcceptedConnectionRequest.discriminator,value:{sourcePeerId:this.ownPeerId,sourceExternalId:this.externalId,id:i}}}}});this.socket.send(e),this.connections.set(I,{pending:!1,owned:!0,connectionRequestId:Q}),this.addAcceptedPeer(I,g,Q)},reject:g=>{if(void 0===this.socket)throw new C.RainwayError("Couldn't send reject message because the connection to Rainway was lost.");const e=o.GatewayDatagram.encode({header:{syncKey:A},body:{discriminator:o.GatewayForwardable.discriminator,value:{targetPeerId:I,body:{discriminator:o.RejectedConnectionRequest.discriminator,value:{sourcePeerId:this.ownPeerId,sourceExternalId:this.externalId,id:i,reason:g}}}}});this.socket.send(e)}});break}case o.AcceptedConnectionRequest.discriminator:{const{id:A,sourcePeerId:I,sourceExternalId:g}=e.value,B=A,i=this.connections.get(I);if(void 0===i)return void E.RainwayLogging.warning("Ignoring AcceptedConnectionRequest from unexpected hostname: "+I);if(!i.pending)return void E.RainwayLogging.warning("Ignoring AcceptedConnectionRequest from already-connected hostname: "+I);i.resolve({canceled:!1,accepted:!0,connectionRequestId:B,hostExternalId:g,transportProtocol:o.PeerTransportType.SCTP}),this.connections.set(I,{pending:!1,owned:!1,promise:i.promise,connectionRequestId:B});break}case o.RejectedConnectionRequest.discriminator:{const{id:A,sourcePeerId:I,sourceExternalId:g}=e.value,B=A,i=this.connections.get(I);if(void 0===i)return void E.RainwayLogging.warning("Ignoring RejectedConnectionRequest from unexpected hostname: "+I);if(!i.pending)return void E.RainwayLogging.warning("Ignoring RejectedConnectionRequest from already-connected hostname: "+I);i.resolve({canceled:!1,accepted:!1,connectionRequestId:B,hostExternalId:g,transportProtocol:o.PeerTransportType.SCTP,reason:e.value.reason}),this.connections.delete(I);break}case o.PeerSignalingInformation.discriminator:E.RainwayLogging.trace("Got peer info:\n"+JSON.stringify(e.value)),this.handlePeerInfo(e.value)}}die(A,I){var g,e;null===(g=this.rejectConnectToGatewayPromise)||void 0===g||g.call(this,A),this.connectToGatewayPromise=void 0,this.resolveConnectToGatewayPromise=void 0,this.rejectConnectToGatewayPromise=void 0;for(const A of this.connections.values())A.pending&&A.reject(I);this.connections.clear(),null===(e=this.connectionLostEvent)||void 0===e||e.invoke(new C.RainwayError(I))}unsetConnectToGatewayPromise(){this.connectToGatewayPromise=void 0,this.resolveConnectToGatewayPromise=void 0,this.rejectConnectToGatewayPromise=void 0}},e=new WeakMap},643:function(A,I,g){"use strict";var e,B=this&&this.__awaiter||function(A,I,g,e){return new(g||(g=Promise))((function(B,i){function t(A){try{C(e.next(A))}catch(A){i(A)}}function Q(A){try{C(e.throw(A))}catch(A){i(A)}}function C(A){var I;A.done?B(A.value):(I=A.value,I instanceof g?I:new g((function(A){A(I)}))).then(t,Q)}C((e=e.apply(A,I||[])).next())}))};Object.defineProperty(I,"__esModule",{value:!0}),I.RainwayRateController=I.defaultRateControlParameters=I.QualityAdjustment=void 0;const i=g(198),t=g(434),Q=g(464),C=g(695);var E;!function(A){A[A.Up=0]="Up",A[A.Down=1]="Down"}(E=I.QualityAdjustment||(I.QualityAdjustment={})),I.defaultRateControlParameters={beatMs:2500,windowMs:4500,badBeats:2,goodBeats:4,backoffFactor:2,latenessThresholdMs:200,latenessSmoothingFactor:.9375,badLateFrameRatio:.75,initialBitrateKbps:Number(null!==(e=new URLSearchParams(window.location.search).get("initial-bitrate"))&&void 0!==e?e:5e3),qualityStepFactor:1.1875},I.RainwayRateController=class{constructor(A=I.defaultRateControlParameters,g,e,Q){this.chosenVideoConfig=g,this.performanceMonitor=Q,this.badBeatCount=0,this.goodBeatCount=0,this.lastAdjustment=void 0,this.history=[],this.lowestDelta=void 0,this.smoothLateness=0,this.framesThisBeat=0,this.lateFramesThisBeat=0,this.debugLatenessSmoothing=!1,this.badCpuPerfThisBeat=!1,this.badDecoderPerfThisBeat=!1,this.badCpuPerfHandler=()=>{this.badCpuPerfThisBeat=!0},this.badDecoderPerfHandler=()=>{this.badDecoderPerfThisBeat=!0},this.handleVideoReadyState=A=>{A===t.VideoReadyState.Detached||A===t.VideoReadyState.Paused||A===t.VideoReadyState.WaitingForKeyframe?this.stop():this.start()},this.check=()=>B(this,void 0,void 0,(function*(){0!==this.framesThisBeat&&((yield this.beatIsBad())?this.badBeat():this.goodBeat(),this.framesThisBeat=0,this.lateFramesThisBeat=0,this.badCpuPerfThisBeat=!1,this.badDecoderPerfThisBeat=!1)})),this.ownMaximumKbps=1/0,this.chosenVideoConfigMimeType=C.videoCodecMimeType(g.codec),this.parameters=Object.assign(Object.assign({},I.defaultRateControlParameters),A),this.suggestBitrateKbps=e,this.currentBitrateKbps=this.parameters.initialBitrateKbps,this.frameVarianceMs=new i.WindowTrack(this.parameters.windowMs,i.standardDeviation)}format(A){return`[RateControl: ${this.currentBitrateKbps.toFixed(0)+"kbps"}, +${this.smoothLateness.toFixed(0)}ms] ${A}`}debug(A){Q.RainwayLogging.debug(this.format(A))}info(A){Q.RainwayLogging.information(this.format(A))}start(){var A,I;this.checkInterval||(this.info("Starting rate control!"),this.checkInterval=window.setInterval(this.check,this.parameters.beatMs),null===(A=this.performanceMonitor)||void 0===A||A.cpuStarvationEvent.addHandler(this.badCpuPerfHandler),null===(I=this.performanceMonitor)||void 0===I||I.decoderStrugglingEvent.addHandler(this.badDecoderPerfHandler))}stop(){var A,I;this.checkInterval&&(this.info("Stopping rate control!"),window.clearInterval(this.checkInterval),this.checkInterval=void 0,null===(A=this.performanceMonitor)||void 0===A||A.cpuStarvationEvent.removeHandler(this.badCpuPerfHandler),null===(I=this.performanceMonitor)||void 0===I||I.decoderStrugglingEvent.removeHandler(this.badDecoderPerfHandler))}feedFrameTimestamp(A){const I=performance.now()-A;(void 0===this.lowestDelta||I<this.lowestDelta||Math.abs(this.lowestDelta-I)>5e4)&&(this.lowestDelta=I);const g=I-this.lowestDelta,e=this.parameters.latenessSmoothingFactor;if(this.smoothLateness=e*this.smoothLateness+(1-e)*g,this.framesThisBeat++,this.smoothLateness>=this.parameters.latenessThresholdMs&&this.lateFramesThisBeat++,this.debugLatenessSmoothing){const A=new Array(100);A.fill("-");const I=g,e=this.smoothLateness;A[50]=".",A[Math.max(0,Math.min(Math.round(I/10+50),99))]="L",A[Math.max(0,Math.min(Math.round(e/10+50),99))]="S",this.beatIsBad().then((g=>Q.RainwayLogging.debug(`${A.join("")} L=${I} S=${e} bad=${g} ld=${this.lowestDelta}`)))}}decodingInfoAtBitrate(A){return navigator.mediaCapabilities.decodingInfo({type:"media-source",video:{width:this.chosenVideoConfig.codec.width,height:this.chosenVideoConfig.codec.height,framerate:this.chosenVideoConfig.codec.refreshRate,bitrate:1e3*A,contentType:C.videoCodecMimeType(this.chosenVideoConfig.codec)}})}capabilitiesBad(){return B(this,void 0,void 0,(function*(){if(!("MediaSource"in window))return!1;if(!("mediaCapabilities"in navigator))return!1;const A=yield this.decodingInfoAtBitrate(this.currentBitrateKbps),I=yield this.decodingInfoAtBitrate(this.bitrateOneStepDownKbps());return I.smooth&&!A.smooth||I.powerEfficient&&!A.powerEfficient}))}lateFrameRatioBad(){return this.lateFramesThisBeat/this.framesThisBeat>=this.parameters.badLateFrameRatio}beatIsBad(){return B(this,void 0,void 0,(function*(){return this.badDecoderPerfThisBeat||this.badCpuPerfThisBeat||this.lateFrameRatioBad()||(yield this.capabilitiesBad())}))}badBeat(){if(this.currentBitrateKbps<=this.lowestSupportedBitrateKbps())return void this.debug(`crashed at ${this.currentBitrateKbps.toFixed(0)}kbps, ignoring bad beat`);this.badBeatCount++,this.goodBeatCount=0,this.currentBitrateKbps;const A=this.parameters.badBeats;if(this.debug(`bad beat: ${this.badBeatCount}/${A}`),this.badBeatCount>=this.parameters.badBeats){this.goodBeatCount=this.badBeatCount=0;const A=this.lastAdjustment===E.Up;this.qualityDown(),this.debug("went down in quality"),A&&this.currentBitrateKbps<this.ownMaximumKbps&&(this.ownMaximumKbps=this.currentBitrateKbps,this.info(`setting a new maximum at ${this.ownMaximumKbps.toFixed(0)}kbps`))}}goodBeat(){if(this.currentBitrateKbps>=this.ownMaximumKbps||this.currentBitrateKbps>=this.highestSupportedBitrateKbps())return this.debug(`maxed at ${this.currentBitrateKbps.toFixed(0)}kbps, ignoring good beat`),void(this.badBeatCount=0);this.goodBeatCount++,this.badBeatCount=0,this.currentBitrateKbps;const A=this.parameters.goodBeats;this.debug(`good beat: ${this.goodBeatCount}/${A}`),this.goodBeatCount>=A&&(this.goodBeatCount=this.badBeatCount=0,this.qualityUp(),this.debug("went up in quality"))}bitrateOneStepUpKbps(){return Math.min(this.highestSupportedBitrateKbps(),this.currentBitrateKbps*this.parameters.qualityStepFactor)}bitrateOneStepDownKbps(){return Math.max(this.lowestSupportedBitrateKbps(),this.currentBitrateKbps/this.parameters.qualityStepFactor)}qualityUp(){this.currentBitrateKbps=this.bitrateOneStepUpKbps(),this.suggestBitrateKbps(this.currentBitrateKbps),this.lastAdjustment=E.Up,this.history.push({time:performance.now(),bitrate:this.currentBitrateKbps})}qualityDown(){this.currentBitrateKbps=this.bitrateOneStepDownKbps(),this.suggestBitrateKbps(this.currentBitrateKbps),this.lastAdjustment=E.Down,this.history.push({time:performance.now(),bitrate:this.currentBitrateKbps}),this.lowestDelta=void 0}lowestSupportedBitrateKbps(){var A;return Number(null!==(A=new URLSearchParams(window.location.search).get("lowest-bitrate"))&&void 0!==A?A:5e3)}highestSupportedBitrateKbps(){var A;return Number(null!==(A=new URLSearchParams(window.location.search).get("max-bitrate"))&&void 0!==A?A:1e4)}}},145:function(A,I,g){"use strict";var e,B=this&&this.__awaiter||function(A,I,g,e){return new(g||(g=Promise))((function(B,i){function t(A){try{C(e.next(A))}catch(A){i(A)}}function Q(A){try{C(e.throw(A))}catch(A){i(A)}}function C(A){var I;A.done?B(A.value):(I=A.value,I instanceof g?I:new g((function(A){A(I)}))).then(t,Q)}C((e=e.apply(A,I||[])).next())}))},i=this&&this.__classPrivateFieldSet||function(A,I,g){if(!I.has(A))throw new TypeError("attempted to set private field on non-instance");return I.set(A,g),g},t=this&&this.__classPrivateFieldGet||function(A,I){if(!I.has(A))throw new TypeError("attempted to get private field on non-instance");return I.get(A)};Object.defineProperty(I,"__esModule",{value:!0}),I.RTCTransport=void 0;const Q=g(994),C=g(9),E=g(464),o=g(904),a=g(987),n=g(420),s=g(783),r={iceServers:[{urls:"stun:stun.rainway.com:3478"}]};class d extends C.RainwayTransport{constructor(A,I,g,B,t,a){super(),this.ownPeerId=A,this.targetPeerId=I,this.sendLocalOfferSdp=g,this.sendLocalAnswerSdp=B,this.sendLocalIceCandidate=t,this.reportStateChange=a,e.set(this,C.RainwayTransportStatus.Disconnected),this.rtcConfiguration=r,this.dataChannelsConfig={},this.syncKey=0,this.onRainwayMessage=()=>{},this.onApplicationMessage=()=>{},this.onClose=()=>{},this.handlePeerInfo=A=>{var I,g,e;if(A.type===o.PeerInformationType.Answer)E.RainwayLogging.debug("Got Answer in CRID "+A.id+"\n"+A.data),null===(I=this.peerConnection)||void 0===I||I.setRemoteDescription({type:"answer",sdp:A.data});else if(A.type===o.PeerInformationType.Offer)E.RainwayLogging.debug("Got Offer in CRID "+A.id+"\n"+A.data),null===(g=this.peerConnection)||void 0===g||g.setRemoteDescription({type:"offer",sdp:A.data}),this.sendAnswer();else{if(A.type!==o.PeerInformationType.Candidate){const I=o.PeerInformationType[A.type];throw new Q.RainwayError(`unexpected PeerInformationType ${I} in handlePeerInfo`)}E.RainwayLogging.debug("Got Candidate in CRID "+A.id+"\n"+A.data),null===(e=this.peerConnection)||void 0===e||e.addIceCandidate(new RTCIceCandidate({candidate:A.data,sdpMid:"",sdpMLineIndex:0}))}},this.handleLocalIceCandidate=A=>{A.candidate&&"1"===A.candidate.candidate.split(" ")[1]&&this.sendLocalIceCandidate(A.candidate)},this.handleIceConnectionStateChange=()=>{if(!this.peerConnection)return;const A=this.peerConnection.iceConnectionState;E.RainwayLogging.information(`ICE connection state changed to ${A}`)},this.handleConnectionStateChange=()=>{var A;if(!this.peerConnection)return;const I=this.peerConnection.connectionState;E.RainwayLogging.information(`Connection state changed to ${I}`),"closed"===I||"failed"===I?(this.reportStateChange(s.RainwayPeerState.Failed),null===(A=this.openReject)||void 0===A||A.call(this),this.onClose(),i(this,e,C.RainwayTransportStatus.Disconnected),this.dispose()):"disconnected"===I?this.reportStateChange(s.RainwayPeerState.Disconnected):"connecting"===I?this.reportStateChange(s.RainwayPeerState.Connecting):"connected"===I?this.reportStateChange(s.RainwayPeerState.Connected):"new"===I&&this.reportStateChange(s.RainwayPeerState.New)},this.handleDataChannelMessage=A=>{const I=A.target.label;this.handleLabelAndData(I,new Uint8Array(A.data))},this.handleDataChannelClose=A=>{const I=A.target.label;E.RainwayLogging.warning("RTC channel closed: "+I)},this.handleDataChannelError=A=>{const I=A.target.label;E.RainwayLogging.warning("RTC channel errored: "+I)},this.chunkedMessages=new Map,this.highestChunkGroup=0;const n={protocol:"sctp",negotiated:!1},d={ordered:!1,maxRetransmits:0};this.dataChannelsConfig={RW_Logic:Object.assign(Object.assign({id:0},n),{ordered:!0}),RW_Video:Object.assign(Object.assign({id:1},n),d),RW_Audio:Object.assign(Object.assign({id:2},n),d),RW_Input:Object.assign(Object.assign({id:3},n),d)}}createDataChannel(A,I){var g,e;const B={protocol:"sctp",negotiated:!1},i=null===(g=this.peerConnection)||void 0===g?void 0:g.createDataChannel(A,I===n.RainwayChannelMode.Reliable?Object.assign(Object.assign({},B),{ordered:!0}):Object.assign(Object.assign({},B),{ordered:!1,maxRetransmits:0}));return i&&(i.addEventListener("close",this.handleDataChannelClose),i.addEventListener("error",this.handleDataChannelError),i.addEventListener("message",this.handleDataChannelMessage),null!==(e=this.dataChannels)&&void 0!==e||(this.dataChannels={}),this.dataChannels[A]=i),i}sendMessage(A,I){var g;if(!A)throw new Q.RainwayError("sendMessage: no label");if(!this.dataChannels)throw new Q.RainwayError("sendMessage: dataChannels not initialized");const e=null===(g=this.dataChannels)||void 0===g?void 0:g[A];if(!e)throw new Q.RainwayError(`sendMessage: channel "${A}" does not exist`);if("open"!==e.readyState)throw new Q.RainwayError(`sendMessage: channel "${A}" is not open`);e.send(I)}get status(){return t(this,e)}get maxMessageSize(){var A,I,g;return null!==(g=null===(I=null===(A=this.peerConnection)||void 0===A?void 0:A.sctp)||void 0===I?void 0:I.maxMessageSize)&&void 0!==g?g:262144}getStats(){return B(this,void 0,void 0,(function*(){if(!this.peerConnection)throw new Q.RainwayError("getStats() but no peerConnection");const A=yield this.peerConnection.getStats(void 0),I={channels:{},raw:A};return A.forEach((A=>{"data-channel"===A.type&&(I.channels[A.label]=A)})),I}))}checkHeader(A){if(2036430674!==A.magicNumber)throw new Q.RainwayError("Invalid magicNumber in checkHeader.");if(A.targetPeerId!==this.ownPeerId)throw new Q.RainwayError("Invalid destination host name (not ours) in checkHeader.")}handleLabelAndData(A,I){if("RW_Logic"===A){const A=o.LogicDatagram.decode(I);this.checkHeader(A.header),this.onRainwayMessage({kind:"Logic",body:A.body})}else if("RW_Input"===A){const A=o.InputDatagram.decode(I);this.checkHeader(A.header),this.onRainwayMessage({kind:"Input",body:A.body})}else if("RW_Audio"===A||"RW_Video"==A){const g=o.MediaDatagram.decode(I);this.checkHeader(g.header),g.body.discriminator===o.MediaChunk.discriminator?this.handleChunk(A,g.body.value.chunk):this.onRainwayMessage({kind:"Media",body:g.body})}else if(/^RW_/.test(A))E.RainwayLogging.warning(`Unknown Rainway-reserved RTC label? ${A}`);else{const g=o.ArbitraryDatagram.decode(I);this.checkHeader(g.header),this.handleChunk(A,g.body)}}getDatagramHeader(A){return{magicNumber:2036430674,syncKey:A?++this.syncKey:0,sourcePeerId:this.ownPeerId,targetPeerId:this.targetPeerId}}sendArbitraryDatagram(A,I){a.eachChunk(I,(I=>{this.sendMessage(A,o.ArbitraryDatagram.encode({header:this.getDatagramHeader(!0),body:I}))}))}sendLogicDatagram(A){this.sendMessage("RW_Logic",o.LogicDatagram.encode({header:this.getDatagramHeader(!0),body:A}))}sendInputDatagram(A){this.sendMessage("RW_Input",o.InputDatagram.encode({header:this.getDatagramHeader(!1),body:A}))}open(A){return B(this,void 0,void 0,(function*(){yield new Promise(((I,g)=>B(this,void 0,void 0,(function*(){var B;this.openResolve=I,this.openReject=g,i(this,e,C.RainwayTransportStatus.Connecting),this.peerConnection=new RTCPeerConnection(this.rtcConfiguration),this.peerConnection.addEventListener("iceconnectionstatechange",this.handleIceConnectionStateChange),this.peerConnection.addEventListener("connectionstatechange",this.handleConnectionStateChange),this.handleConnectionStateChange(),null!==(B=this.dataChannels)&&void 0!==B||(this.dataChannels={});const t=Object.keys(this.dataChannelsConfig).length;let Q=0;const E=(A,g)=>{const B=()=>{var A;++Q,Q===t&&(null===(A=this.peerConnection)||void 0===A||A.removeEventListener("icecandidate",this.handleLocalIceCandidate),i(this,e,C.RainwayTransportStatus.Connected),I()),g.removeEventListener("open",B)};g.addEventListener("open",B),g.addEventListener("close",this.handleDataChannelClose),g.addEventListener("error",this.handleDataChannelError),g.addEventListener("message",this.handleDataChannelMessage)};if("offer"===A)for(const[A,I]of Object.entries(this.dataChannelsConfig)){const g=this.peerConnection.createDataChannel(A,I);this.dataChannels[A]=g,g.binaryType="arraybuffer",E(0,g)}else this.peerConnection.addEventListener("datachannel",(A=>{var I;const g=A.channel.label;null!==(I=this.dataChannels)&&void 0!==I||(this.dataChannels={}),this.dataChannels[g]=A.channel,E(A.channel.label,A.channel)}));this.peerConnection.addEventListener("icecandidate",this.handleLocalIceCandidate),"offer"===A&&(yield this.sendOffer())}))))}))}sendOffer(){return B(this,void 0,void 0,(function*(){if(void 0===this.peerConnection)throw new Q.RainwayError("sendOffer(): no peer connection");const A=yield this.peerConnection.createOffer();if(yield this.peerConnection.setLocalDescription(A),!A.sdp)throw new Q.RainwayError("Created offer contained no sdp?");this.sendLocalOfferSdp(A.sdp)}))}sendAnswer(){return B(this,void 0,void 0,(function*(){if(void 0===this.peerConnection)throw new Q.RainwayError("sendOffer(): no peer connection");const A=yield this.peerConnection.createAnswer();if(yield this.peerConnection.setLocalDescription(A),!A.sdp)throw new Q.RainwayError("Created answer contained no sdp?");this.sendLocalAnswerSdp(A.sdp)}))}close(){var A;this.status!==C.RainwayTransportStatus.Disconnected&&(E.RainwayLogging.debug("rtc-transport close()."),null===(A=this.peerConnection)||void 0===A||A.close(),this.onClose(),this.dispose())}dispose(){var A,I,g;if(null===(A=this.peerConnection)||void 0===A||A.removeEventListener("iceconnectionstatechange",this.handleIceConnectionStateChange),null===(I=this.peerConnection)||void 0===I||I.removeEventListener("connectionstatechange",this.handleConnectionStateChange),null===(g=this.peerConnection)||void 0===g||g.removeEventListener("icecandidate",this.handleLocalIceCandidate),this.dataChannels)for(const A of Object.values(this.dataChannels))A.removeEventListener("message",this.handleDataChannelMessage);this.dataChannels=void 0,this.peerConnection=void 0,this.openResolve=void 0,this.openReject=void 0}handleChunk(A,I){I.groupId<this.highestChunkGroup&&(this.chunkedMessages=new Map,this.highestChunkGroup=0);let g=this.chunkedMessages.get(I.groupId);if(g||(g={receivedChunkCount:0,chunks:[]},this.chunkedMessages.set(I.groupId,g)),g.chunks[I.index]=I.data,g.receivedChunkCount++,g.receivedChunkCount===I.chunksInGroup){this.highestChunkGroup=I.groupId,this.chunkedMessages.delete(I.groupId);const e=a.reassemble(g);/^RW_(Logic|Input|Audio|Video)$/.test(A)?this.handleLabelAndData(A,e):this.onApplicationMessage(A,e)}}}I.RTCTransport=d,e=new WeakMap},9:(A,I)=>{"use strict";var g;Object.defineProperty(I,"__esModule",{value:!0}),I.RainwayTransport=I.RainwayTransportStatus=void 0,(g=I.RainwayTransportStatus||(I.RainwayTransportStatus={}))[g.Disconnected=0]="Disconnected",g[g.Connecting=1]="Connecting",g[g.Connected=2]="Connected",I.RainwayTransport=class{}},420:function(A,I,g){"use strict";var e,B,i,t,Q=this&&this.__awaiter||function(A,I,g,e){return new(g||(g=Promise))((function(B,i){function t(A){try{C(e.next(A))}catch(A){i(A)}}function Q(A){try{C(e.throw(A))}catch(A){i(A)}}function C(A){var I;A.done?B(A.value):(I=A.value,I instanceof g?I:new g((function(A){A(I)}))).then(t,Q)}C((e=e.apply(A,I||[])).next())}))},C=this&&this.__classPrivateFieldSet||function(A,I,g){if(!I.has(A))throw new TypeError("attempted to set private field on non-instance");return I.set(A,g),g},E=this&&this.__classPrivateFieldGet||function(A,I){if(!I.has(A))throw new TypeError("attempted to get private field on non-instance");return I.get(A)};Object.defineProperty(I,"__esModule",{value:!0}),I.RainwayPeer=I.RainwayChannelMode=void 0;const o=g(904),a=g(824),n=g(464),s=g(514),r=g(783),d=g(876),h=g(994);var c;(c=I.RainwayChannelMode||(I.RainwayChannelMode={}))[c.Unreliable=0]="Unreliable",c[c.Reliable=1]="Reliable";class D{constructor(A,I,g,Q,E,o,a){this.transport=g,this.outerOnClose=Q,this.onError=E,this.onStreamAnnouncement=o,this.onStreamStop=a,e.set(this,r.RainwayPeerState.New),B.set(this,new Map),i.set(this,void 0),t.set(this,void 0),this.lastTimestamp=void 0,C(this,i,A),C(this,t,I),g.onRainwayMessage=this.onMessage.bind(this),g.onClose=this.onClose.bind(this),this.readyToStream=new Promise(((A,I)=>{this.resolveReadyToStream=A}))}get state(){return E(this,e)}get disconnected(){return this.state===r.RainwayPeerState.Disconnected||this.state===r.RainwayPeerState.Failed}get stream(){const A=[...E(this,B).entries()];if(0!==A.length)return A.sort(((A,I)=>A[0]-I[0])),A[0][1]}get streams(){return E(this,B)}get peerId(){return E(this,i)}get externalId(){return E(this,t)}onClose(){this.onPeerStateChange(r.RainwayPeerState.Failed)}onPeerStateChange(A){C(this,e,A),A===r.RainwayPeerState.Failed&&(this.dispose(),this.outerOnClose())}sendDeviceInfoAndExchangeCodecs(){if(this.disconnected)throw new h.RainwayError("Couldn't send device info and exchange codecs: peer is disconnected");this.sendDeviceInfo(),this.exchangeCodecs().then((A=>{var I,g;0===A.length?null===(I=this.resolveReadyToStream)||void 0===I||I.call(this,!1):(this.transport.sendLogicDatagram({discriminator:o.ClientCapabilities.discriminator,value:s.makeClientCapabilities(A)}),null===(g=this.resolveReadyToStream)||void 0===g||g.call(this,!0))}))}onMessage(A){"Logic"===A.kind?this.handleLogicMessage(A.body):"Input"===A.kind?this.handleInputMessage(A.body):"Media"===A.kind&&this.handleMediaMessage(A.body)}sendDeviceInfo(){if(this.disconnected)throw new h.RainwayError("Couldn't send device info: peer is disconnected");this.transport.sendLogicDatagram({discriminator:o.DeviceInfo.discriminator,value:{isWeb:!0,formFactor:o.FormFactor.Computer,deviceName:"deviceName",deviceId:"deviceId",deviceModel:"",deviceOs:o.OperatingSystem.Other,deviceOsVersion:"",userAgent:navigator.userAgent}})}send(A,I){if(A.startsWith("RW_"))throw new h.RainwayError("Data channel names starting with RW_ are reserved for Rainway");if(this.disconnected)throw new h.RainwayError("Couldn't send message: peer is disconnected");const g="string"==typeof I?D.textEncoder.encode(I):I;this.transport.sendArbitraryDatagram(A,g)}disconnect(){this.dispose(),this.transport.close()}dispose(){for(const A of E(this,B).values())A.leave();E(this,B).clear()}requestStream(A){return Q(this,void 0,void 0,(function*(){if(this.disconnected)throw new h.RainwayError("Couldn't request stream: peer is disconnected");return yield this.readyToStream,this.transport.sendLogicDatagram({discriminator:o.StreamRequest.discriminator,value:{inputLevel:A}}),new Promise(((A,I)=>{this.resolveStream=A,this.rejectStream=I}))}))}handleLogicMessage(A){var I;return Q(this,void 0,void 0,(function*(){if(A.discriminator===o.DeviceInfo.discriminator)n.RainwayLogging.debug("Got remote DeviceInfo:\n"+JSON.stringify(A.value));else if(A.discriminator===o.CodecPackRequest.discriminator)this.transport.sendLogicDatagram({discriminator:o.CodecPackResponse.discriminator,value:{videoCodecs:[]}});else if(A.discriminator===o.CodecPackResponse.discriminator)null===(I=this.codecsResolve)||void 0===I||I.call(this,A.value.videoCodecs);else if(A.discriminator===o.ClientCapabilities.discriminator)n.RainwayLogging.debug("Got remote ClientCapabilities:\n"+JSON.stringify(A.value));else if(A.discriminator===o.StreamRequest.discriminator)n.RainwayLogging.warning("Got remote StreamRequest?\n"+JSON.stringify(A.value));else if(A.discriminator===o.StreamStarting.discriminator)if(void 0===this.resolveStream)this.onStreamAnnouncement({info:A.value,join:()=>Q(this,void 0,void 0,(function*(){const I=yield this.createStream(A.value);return E(this,B).set(I.streamId,I),this.transport.sendLogicDatagram({discriminator:o.JoinStream.discriminator,value:{streamId:A.value.streamId}}),I}))});else{const I=yield this.createStream(A.value);E(this,B).set(I.streamId,I),this.transport.sendLogicDatagram({discriminator:o.JoinStream.discriminator,value:{streamId:A.value.streamId}}),this.resolveStream(I),this.resolveStream=void 0,this.rejectStream=void 0}else A.discriminator===o.RejectStreamRequest.discriminator?void 0!==this.rejectStream?(this.rejectStream(A.value.reason),this.resolveStream=void 0,this.rejectStream=void 0):n.RainwayLogging.warning("Got RejectStreamRequest, but didn't ask for a stream."):A.discriminator===o.LeaveStream.discriminator?n.RainwayLogging.warning("Got remote LeaveStream?\n"+JSON.stringify(A.value)):A.discriminator===o.StreamStopping.discriminator&&(n.RainwayLogging.debug("Got remote StreamStopping:\n"+JSON.stringify(A.value)),this.discardStream(A.value.streamId))}))}createStream(A){return d.RainwayStream.createAndInitialize(this,A.streamId,A.inputLevel,A.chosenAudioConfig,A.chosenVideoConfig,A.captureMode,(A=>this.transport.sendInputDatagram(A)),(A=>this.transport.sendLogicDatagram(A)),(()=>this.transport.getStats()),(()=>this.discardStream(A.streamId)))}discardStream(A){const I=E(this,B).get(A);void 0!==I&&this.onStreamStop(I),E(this,B).delete(A)}handleInputMessage(A){var I;if(A.discriminator===o.GamepadRumble.discriminator){const I=A.value.leftMotorSpeed,g=A.value.rightMotorSpeed;a.RainwayInputManager.vibrateGamepad(A.value.port,{duration:100,startDelay:0,strongMagnitude:Math.max(I,g)/65535,weakMagnitude:0})}else if(A.discriminator===o.SetClipboardText.discriminator){const g=A.value.text;"function"==typeof(null===(I=null===navigator||void 0===navigator?void 0:navigator.clipboard)||void 0===I?void 0:I.writeText)&&navigator.clipboard.writeText(g).then((()=>{}))}else n.RainwayLogging.warning(`Ignoring unrecognized Input discriminator ${A.discriminator}`)}handleMediaMessage(A){if(A.discriminator===o.VideoData.discriminator){const{data:I,segmentTime:g,type:e,desktopRect:i,mask:t,streamId:Q}=A.value,C=E(this,B).get(Q);if(!C)return;const a=I.buffer.slice(I.byteOffset,I.byteOffset+I.length),s=1e-4*Number(g);e===o.VideoDataType.FrameDiff&&void 0!==this.lastTimestamp&&s-this.lastTimestamp<3&&n.RainwayLogging.warning(`Difference between successive timestamps was ${(s-this.lastTimestamp).toFixed(1)}`),e!==o.VideoDataType.Metadata&&(this.lastTimestamp=s),C.renderVideoFrame({timestamp:s,x:i.left,y:i.top,width:i.width,height:i.height,mask:t},a)}else if(A.discriminator===o.PointerData.discriminator){const I=E(this,B).get(A.value.streamId);if(!I)return;I.processCursor({x:A.value.positionX,y:A.value.positionY,spotX:A.value.spotX,spotY:A.value.spotY,shapeWidth:A.value.shapeWidth,shapeHeight:A.value.shapeHeight,extentWidth:A.value.monitorWidth,extentHeight:A.value.monitorHeight,visible:A.value.visible,hasPointerImage:A.value.data.length>0,pointerImage:A.value.data})}else if(A.discriminator===o.AudioData.discriminator){const I=E(this,B).get(A.value.streamId);if(!I)return;const{data:g,type:e}=A.value,i=g.buffer.slice(g.byteOffset,g.byteOffset+g.length);I.processAudio(i)}}exchangeCodecs(){return Q(this,void 0,void 0,(function*(){if(this.disconnected)throw new h.RainwayError("Couldn't exchange codecs: peer is disconnected");const A=yield new Promise((A=>{this.transport.sendLogicDatagram({discriminator:o.CodecPackRequest.discriminator,value:{}}),this.codecsResolve=A}));return this.codecsResolve=void 0,A}))}createDataChannel(A,I){if(A.startsWith("RW_"))throw new h.RainwayError("Data channel names starting with RW_ are reserved for Rainway");return void 0!==this.transport.createDataChannel(A,I)}}I.RainwayPeer=D,e=new WeakMap,B=new WeakMap,i=new WeakMap,t=new WeakMap,D.textEncoder=new TextEncoder},783:function(A,I,g){"use strict";var e,B,i,t,Q,C,E=this&&this.__awaiter||function(A,I,g,e){return new(g||(g=Promise))((function(B,i){function t(A){try{C(e.next(A))}catch(A){i(A)}}function Q(A){try{C(e.throw(A))}catch(A){i(A)}}function C(A){var I;A.done?B(A.value):(I=A.value,I instanceof g?I:new g((function(A){A(I)}))).then(t,Q)}C((e=e.apply(A,I||[])).next())}))},o=this&&this.__classPrivateFieldSet||function(A,I,g){if(!I.has(A))throw new TypeError("attempted to set private field on non-instance");return I.set(A,g),g},a=this&&this.__classPrivateFieldGet||function(A,I){if(!I.has(A))throw new TypeError("attempted to get private field on non-instance");return I.get(A)};Object.defineProperty(I,"__esModule",{value:!0}),I.RainwayRuntime=I.RainwayPeerState=void 0;const n=g(104),s=g(994),r=g(464),d=g(145),h=g(904),c=g(420);var D;null!==(e=(i=DataView.prototype).setBigUint64)&&void 0!==e||(i.setBigUint64=function(A,I,g){const e=BigInt(4294967295),B=Number(I>>BigInt(32)&e),i=Number(I&e),[t,Q]=g?[4,0]:[0,4];this.setUint32(A+t,B,g),this.setUint32(A+Q,i,g)}),null!==(B=(t=DataView.prototype).getBigUint64)&&void 0!==B||(t.getBigUint64=function(A,I){const[g,e]=I?[4,0]:[0,4],B=BigInt(this.getUint32(A+g,I)),i=BigInt(this.getUint32(A+e,I));return B<<BigInt(32)|i}),function(A){A[A.New=0]="New",A[A.Connecting=1]="Connecting",A[A.Connected=2]="Connected",A[A.Disconnected=3]="Disconnected",A[A.Failed=4]="Failed"}(D=I.RainwayPeerState||(I.RainwayPeerState={}));class w{constructor(A,I){Q.set(this,void 0),C.set(this,new Map),this.connectionTransports=new Map,this.documentVisibilityChangeHandler=()=>{if(document.hidden)for(const A of this.peers.values())for(const I of A.streams.values())I.releaseKeys(),I.pause();else for(const A of this.peers.values())for(const I of A.streams.values())I.play()},this.windowBlurHandler=()=>{for(const A of this.peers.values())for(const I of A.streams.values())I.releaseKeys()},this.beforeUnloadHandler=A=>{const I=location.hash;return[...this.peers.values()].some((A=>A.streams.size>0))&&(setTimeout((()=>{location.hash="?hj="+~~(9999*Math.random()),location.hash=I}),0),A.preventDefault(),A.returnValue=""),!1},window.__rainwayRuntime=this,o(this,Q,A),this.config=Object.assign({externalId:"",preventUnloadingPage:!0,logSink:()=>{}},I),this.setLogSink(this.config.logSink),this.gateway=new n.Gateway(a(this,Q),this.config.apiKey,this.config.externalId,(A=>this.handlePeerInfo(A)),(A=>this.config.onConnectionRequest(this,A)),((A,I,g)=>this.addPeer(A,I,g,"answer"))),this.gateway.connectionLostEvent.addHandler((A=>{a(this,C).clear(),this.config.onRuntimeConnectionLost(this,A)}))}get peers(){return[...a(this,C).values()]}static initialize(A){return E(this,void 0,void 0,(function*(){if(w.initialized)throw new s.RainwayError("RainwayRuntime may only be initialized once. Don't worry: you can manage multiple Rainway connections from a single RainwayRuntime object.");const I=yield n.getPeerId(A.apiKey),g=new w(I,A);return yield g.gateway.connect(),window.addEventListener("beforeunload",(A=>g.beforeUnloadHandler(A))),window.addEventListener("blur",(A=>g.windowBlurHandler())),document.addEventListener("visibilitychange",(A=>g.documentVisibilityChangeHandler())),w.initialized=!0,g}))}getPeerId(){return a(this,Q)}connect(A){return E(this,void 0,void 0,(function*(){if(yield this.gateway.connect(),a(this,C).has(A))throw new s.RainwayError(`Already connected to ${A}`);const I=yield this.gateway.connectToHost(A,h.PeerTransportType.SCTP);if(I.canceled)throw new s.RainwayError("The connection attempt was canceled.");if(!I.accepted)throw new s.RainwayError(`The peer at ${A} rejected the connection, with reason: ${I.reason}`);return this.addPeer(A,I.hostExternalId,I.connectionRequestId,"offer")}))}addPeer(A,I,g,e){return E(this,void 0,void 0,(function*(){const B=new d.RTCTransport(a(this,Q),A,(I=>this.gateway.sendOffer(A,I)),(I=>this.gateway.sendAnswer(A,I)),(I=>this.gateway.sendCandidate(A,I)),(A=>{i.onPeerStateChange(A),this.config.onPeerStateChange(this,i,A)})),i=new c.RainwayPeer(A,I,B,(()=>{this.gateway.deleteConnection(A),a(this,C).delete(A)}),(A=>{this.config.onPeerError(this,i,A)}),(A=>{this.config.onStreamAnnouncement(this,i,A)}),(A=>{this.config.onStreamStop(this,A)}));this.connectionTransports.set(g,B),B.onApplicationMessage=(A,I)=>this.config.onPeerMessage(this,i,A,I);try{yield B.open(e)}finally{this.connectionTransports.delete(g)}return i.sendDeviceInfoAndExchangeCodecs(),a(this,C).set(A,i),this.config.onPeerStateChange(this,i,D.Connected),i}))}cancelConnectionAttempt(A){this.gateway.cancelConnectionAttempt(A)}handlePeerInfo(A){const I=this.connectionTransports.get(A.id);void 0!==I?I.handlePeerInfo(A):A.type!==h.PeerInformationType.Candidate&&r.RainwayLogging.warning("Got peer info for unexpected CRID? "+A.id)}getMediaCapabilities(A){return navigator.mediaCapabilities.decodingInfo(A)}setLogSink(A){r.RainwayLogging.setLogSink(A)}}I.RainwayRuntime=w,Q=new WeakMap,C=new WeakMap,w.initialized=!1},876:function(A,I,g){"use strict";var e,B=this&&this.__awaiter||function(A,I,g,e){return new(g||(g=Promise))((function(B,i){function t(A){try{C(e.next(A))}catch(A){i(A)}}function Q(A){try{C(e.throw(A))}catch(A){i(A)}}function C(A){var I;A.done?B(A.value):(I=A.value,I instanceof g?I:new g((function(A){A(I)}))).then(t,Q)}C((e=e.apply(A,I||[])).next())}))},i=this&&this.__classPrivateFieldGet||function(A,I){if(!I.has(A))throw new TypeError("attempted to get private field on non-instance");return I.get(A)},t=this&&this.__classPrivateFieldSet||function(A,I,g){if(!I.has(A))throw new TypeError("attempted to set private field on non-instance");return I.set(A,g),g};Object.defineProperty(I,"__esModule",{value:!0}),I.RainwayStream=void 0;const Q=g(994),C=g(904),E=g(824),o=g(425),a=g(643),n=g(464),s=g(695),r=g(528);class d{constructor(A,I,g,B,i,t,Q,n,d,h){this.host=A,this.streamId=I,this.chosenAudioConfig=B,this.chosenVideoConfig=i,this.captureMode=t,this.sendInput=Q,this.sendLogic=n,this.peerDiscardStream=h,this.resizeDebounceHandle=void 0,e.set(this,!1),this.sendKeyframeRequest=()=>{this.sendLogic({discriminator:C.KeyframeRequest.discriminator,value:{streamId:this.streamId}})},this.feedVideoStateIntoRateController=A=>{this.rateController.handleVideoReadyState(A)},this.setRemoteClipboard=()=>{var A;"function"!=typeof(null===(A=null===navigator||void 0===navigator?void 0:navigator.clipboard)||void 0===A?void 0:A.readText)||r.isDesktopSafari||navigator.clipboard.readText().then((A=>{this.sendInput({discriminator:C.SetClipboardText.discriminator,value:{text:A}})}))};const c=document.createElement("div");c.tabIndex=0,c.style.touchAction="none",c.style.userSelect="none",c.style.webkitUserSelect="none",c.style.position="relative",c.style.width="100%",c.style.height="100%",c.className="rainway-inner-container",c.addEventListener("focus",this.setRemoteClipboard),this.innerContainer=c,this.inputManager=new E.RainwayInputManager(this),this.mediaManager=new o.MediaManager(t,i,{video:{codecString:s.videoCodecMimeType(i.codec)}},d),this.rateController=new a.RainwayRateController(void 0,i,(A=>this.sendLogic({discriminator:C.VideoBitrateRequest.discriminator,value:{streamId:I,bitsPerSecond:1e3*A}})),this.mediaManager.videoPerformanceMonitor),c.addEventListener("click",(()=>{this.resumeAudio()})),this.mediaManager.setContainer(c),this.mediaManager.videoNeedsRestartEvent.addHandler(this.sendKeyframeRequest),this.mediaManager.videoReadyStateChangeEvent.addHandler(this.feedVideoStateIntoRateController),this.inputManager.setContainer(c),this.inputManager.setInputLevel(g),this.containerResizeObserver=new ResizeObserver((()=>{this.resizeDebounceHandle&&window.clearTimeout(this.resizeDebounceHandle),this.resizeDebounceHandle=window.setTimeout((()=>{this.sendInput({discriminator:C.ViewportResize.discriminator,value:{width:this.innerContainer.clientWidth,height:this.innerContainer.clientHeight}}),this.resizeDebounceHandle=void 0}),100)})),this.containerResizeObserver.observe(c),window.__rainwayStream=this}get dead(){return i(this,e)}get container(){return this.innerContainer}get inputLevel(){return this.inputManager.getInputLevel()}get currentFrameSize(){const{codec:A}=this.chosenVideoConfig;return{codecWidth:A.width,codecHeight:A.height,streamBounds:this.mediaManager.currentStreamBounds,fullDesktopBounds:this.mediaManager.currentFullDesktopBounds}}static createAndInitialize(A,I,g,e,i,t,Q,C,E,o){return B(this,void 0,void 0,(function*(){const B=new d(A,I,g,e,i,t,Q,C,E,o);return yield B.mediaManager.initialize(),B}))}processAudio(A){this.mediaManager.processAudio(A)}processCursor(A){this.inputManager.processCursor(A)}renderVideoFrame(A,I){this.rateController.feedFrameTimestamp(A.timestamp),this.mediaManager.renderVideoFrame(A,I)}transformPointerOffsetToRemote(A,I){const g=this.mediaManager.currentStreamBounds;if(!g)return;const e=this.mediaManager.currentFullDesktopBounds;if(!e)return;const{left:B,top:i,width:t,height:Q}=e,{left:C,top:E,width:o,height:a}=g,n=this.chosenVideoConfig.codec.width,s=this.chosenVideoConfig.codec.height,r=this.innerContainer.clientWidth,d=this.innerContainer.clientHeight,h=o*n/t,c=a*s/Q,D=Math.min(r/h,d/c);return{x:(A-(r-D*h)/2)/(D*n/t)+C-B,y:(I-(d-D*c)/2)/(D*s/Q)+E-i}}releaseKeys(){this.inputManager.releaseKeys()}enableVideoStatsOverlay(){var A;null===(A=this.mediaManager)||void 0===A||A.enableStatsOverlay()}disableVideoStatsOverlay(){var A;null===(A=this.mediaManager)||void 0===A||A.disableStatsOverlay()}requestFullscreen(A){var I,g,e;const B=null===(I=null==A?void 0:A.lockKeyboard)||void 0===I||I,i=null===(g=null==A?void 0:A.lockPointer)||void 0===g||g;if(this.innerContainer.requestFullscreen?this.innerContainer.requestFullscreen({navigationUI:"hide"}):this.innerContainer.webkitRequestFullscreen({navigationUI:"hide"}),B&&"keyboard"in navigator)try{navigator.keyboard.lock()}catch(A){}i&&(null===(e=this.inputManager)||void 0===e||e.lockPointer())}play(){if(i(this,e))throw new Q.RainwayError("Attempted to play a dead stream");this.mediaManager.play(),this.rateController.start()}pause(){if(i(this,e))throw new Q.RainwayError("Attempted to pause a dead stream");this.mediaManager.pause(),this.rateController.stop()}leave(){i(this,e)?n.RainwayLogging.warning("Attempted to leave a dead stream"):(this.sendLogic({discriminator:C.LeaveStream.discriminator,value:{streamId:this.streamId}}),this.peerDiscardStream(),this.resizeDebounceHandle&&clearTimeout(this.resizeDebounceHandle),this.innerContainer.removeEventListener("focus",this.setRemoteClipboard),this.containerResizeObserver.disconnect(),this.mediaManager.videoNeedsRestartEvent.removeHandler(this.sendKeyframeRequest),this.mediaManager.videoReadyStateChangeEvent.removeHandler(this.feedVideoStateIntoRateController),this.inputManager.dispose(),this.mediaManager.dispose(),this.rateController.stop(),t(this,e,!0))}resumeAudio(){var A,I;null===(I=null===(A=this.mediaManager)||void 0===A?void 0:A.audioContext)||void 0===I||I.resume()}enableGestures(){var A;null===(A=this.inputManager)||void 0===A||A.enableGestures()}disableGestures(){var A;null===(A=this.inputManager)||void 0===A||A.disableGestures()}setStreamFit(A){this.mediaManager.streamFit=A}setOutgoingInputFilter(A){this.inputManager.outgoingInputFilter=A}}I.RainwayStream=d,e=new WeakMap},994:(A,I)=>{"use strict";Object.defineProperty(I,"__esModule",{value:!0}),I.RainwayError=void 0;class g extends Error{constructor(A){super(`Rainway SDK Error: ${A}`),this.name=this.constructor.name,"function"==typeof Error.captureStackTrace?Error.captureStackTrace(this,this.constructor):this.stack=new Error(`Rainway SDK Error: ${A}`).stack,Object.setPrototypeOf(this,g.prototype)}}I.RainwayError=g},859:A=>{self,A.exports=(()=>{"use strict";var A={114:function(A,I,g){var e=this&&this.__importDefault||function(A){return A&&A.__esModule?A:{default:A}};Object.defineProperty(I,"__esModule",{value:!0});const B=e(g(170));class i{initialize(){return this.id=i.uniqueIdCounter++,new Promise(((A,I)=>{this.worker=new B.default,this.worker.addEventListener("message",(I=>{var g;const e=I.data;"decoderReady"===e.type?A(0):"pictureReady"===e.type&&(null===(g=this.onDecode)||void 0===g||g.call(this,e))}))}))}decode(A){this.worker&&this.worker.postMessage({type:"decode",data:A.buffer,offset:A.byteOffset,length:A.byteLength,renderStateId:this.id},[A.buffer])}release(){this.worker&&this.worker.postMessage({type:"release",renderStateId:this.id})}dispose(){this.worker&&(this.worker.terminate(),this.worker=void 0)}}I.default=i,i.uniqueIdCounter=1},170:(A,I,g)=>{g.r(I),g.d(I,{default:()=>i});var e=g(614),B=g.n(e);function i(){return B()('/*! For license information please see index.worker.js.LICENSE.txt */\n(()=>{var A={719:A=>{var I,g=(I="undefined"!=typeof document&&document.currentScript?document.currentScript.src:void 0,function(A){(A=A||{})||(A=void 0!==A?A:{});var g,B={};for(g in A)A.hasOwnProperty(g)&&(B[g]=A[g]);var Q,C=[],E="";E=self.location.href,I&&(E=I),E=0!==E.indexOf("blob:")?E.substr(0,E.lastIndexOf("/")+1):"",Q=function(A){var I=new XMLHttpRequest;return I.open("GET",A,!1),I.responseType="arraybuffer",I.send(null),new Uint8Array(I.response)};var i,D,o=A.print||console.log.bind(console),a=A.printErr||console.warn.bind(console);for(g in B)B.hasOwnProperty(g)&&(A[g]=B[g]);B=null,A.arguments&&(C=A.arguments),A.thisProgram&&A.thisProgram,A.quit&&A.quit,A.wasmBinary&&(i=A.wasmBinary),A.noExitRuntime&&A.noExitRuntime,"object"!=typeof WebAssembly&&a("no native wasm support detected");var G,S,F,N,w,y,R,h=new WebAssembly.Table({initial:1,maximum:1,element:"anyfunc"}),s=!1;function k(I){G=I,A.HEAP8=S=new Int8Array(I),A.HEAP16=N=new Int16Array(I),A.HEAP32=w=new Int32Array(I),A.HEAPU8=F=new Uint8Array(I),A.HEAPU16=new Uint16Array(I),A.HEAPU32=new Uint32Array(I),A.HEAPF32=y=new Float32Array(I),A.HEAPF64=R=new Float64Array(I)}var L=A.INITIAL_MEMORY||16777216;function M(I){for(;I.length>0;){var g=I.shift();if("function"!=typeof g){var B=g.func;"number"==typeof B?void 0===g.arg?A.dynCall_v(B):A.dynCall_vi(B,g.arg):B(void 0===g.arg?null:g.arg)}else g(A)}}(D=A.wasmMemory?A.wasmMemory:new WebAssembly.Memory({initial:L/65536,maximum:32768}))&&(G=D.buffer),L=G.byteLength,k(G),w[2188]=5251792;var U=[],Y=[],J=[],q=[],K=0,H=null,t=null;function c(I){throw A.onAbort&&A.onAbort(I),o(I+=""),a(I),s=!0,I="abort("+I+"). Build with -s ASSERTIONS=1 for more info.",new WebAssembly.RuntimeError(I)}function d(A){return I=A,g="data:application/octet-stream;base64,",String.prototype.startsWith?I.startsWith(g):0===I.indexOf(g);var I,g}A.preloadedImages={},A.preloadedAudios={};var n,p="TinyH264.wasm";function f(){try{if(i)return new Uint8Array(i);if(Q)return Q(p);throw"both async and sync fetching of the wasm failed"}catch(A){c(A)}}function r(A){try{return D.grow(A-G.byteLength+65535>>>16),k(D.buffer),1}catch(A){}}d(p)||(n=p,p=A.locateFile?A.locateFile(n,E):E+n),Y.push({func:function(){x()}});var e={a:function(A,I,g){F.copyWithin(A,I,I+g)},b:function(A){A>>>=0;var I=F.length,g=2147483648;if(A>g)return!1;for(var B,Q=1;Q<=4;Q*=2){var C=I*(1+.2/Q);if(C=Math.min(C,A+100663296),r(Math.min(g,((B=Math.max(16777216,A,C))%65536>0&&(B+=65536-B%65536),B))))return!0}return!1},memory:D,table:h},m=function(){var I={a:e};function g(I,g){var B=I.exports;A.asm=B,function(I){if(K--,A.monitorRunDependencies&&A.monitorRunDependencies(K),0==K&&(null!==H&&(clearInterval(H),H=null),t)){var g=t;t=null,g()}}()}function B(A){g(A.instance)}function Q(A){return(i||"function"!=typeof fetch?new Promise((function(A,I){A(f())})):fetch(p,{credentials:"same-origin"}).then((function(A){if(!A.ok)throw"failed to load wasm binary file at \'"+p+"\'";return A.arrayBuffer()})).catch((function(){return f()}))).then((function(A){return WebAssembly.instantiate(A,I)})).then(A,(function(A){a("failed to asynchronously prepare wasm: "+A),c(A)}))}if(K++,A.monitorRunDependencies&&A.monitorRunDependencies(K),A.instantiateWasm)try{return A.instantiateWasm(I,g)}catch(A){return a("Module.instantiateWasm callback failed with error: "+A),!1}return function(){if(i||"function"!=typeof WebAssembly.instantiateStreaming||d(p)||"function"!=typeof fetch)return Q(B);fetch(p,{credentials:"same-origin"}).then((function(A){return WebAssembly.instantiateStreaming(A,I).then(B,(function(A){a("wasm streaming compile failed: "+A),a("falling back to ArrayBuffer instantiation"),Q(B)}))}))}(),{}}();A.asm=m;var W,x=A.___wasm_call_ctors=function(){return(x=A.___wasm_call_ctors=A.asm.c).apply(null,arguments)};function X(I){function g(){W||(W=!0,A.calledRun=!0,s||(M(Y),M(J),A.onRuntimeInitialized&&A.onRuntimeInitialized(),function(){if(A.postRun)for("function"==typeof A.postRun&&(A.postRun=[A.postRun]);A.postRun.length;)I=A.postRun.shift(),q.unshift(I);var I;M(q)}()))}I=I||C,K>0||(function(){if(A.preRun)for("function"==typeof A.preRun&&(A.preRun=[A.preRun]);A.preRun.length;)I=A.preRun.shift(),U.unshift(I);var I;M(U)}(),K>0||(A.setStatus?(A.setStatus("Running..."),setTimeout((function(){setTimeout((function(){A.setStatus("")}),1),g()}),1)):g()))}if(A._h264bsdInit=function(){return(A._h264bsdInit=A.asm.d).apply(null,arguments)},A._malloc=function(){return(A._malloc=A.asm.e).apply(null,arguments)},A._free=function(){return(A._free=A.asm.f).apply(null,arguments)},A._h264bsdDecode=function(){return(A._h264bsdDecode=A.asm.g).apply(null,arguments)},A._h264bsdShutdown=function(){return(A._h264bsdShutdown=A.asm.h).apply(null,arguments)},A._h264bsdAlloc=function(){return(A._h264bsdAlloc=A.asm.i).apply(null,arguments)},A._h264bsdFree=function(){return(A._h264bsdFree=A.asm.j).apply(null,arguments)},A.asm=m,A.getValue=function(A,I,g){switch("*"===(I=I||"i8").charAt(I.length-1)&&(I="i32"),I){case"i1":case"i8":return S[A>>0];case"i16":return N[A>>1];case"i32":case"i64":return w[A>>2];case"float":return y[A>>2];case"double":return R[A>>3];default:c("invalid type for getValue: "+I)}return null},A.then=function(I){if(W)I(A);else{var g=A.onRuntimeInitialized;A.onRuntimeInitialized=function(){g&&g(),I(A)}}return A},t=function A(){W||X(),W||(t=A)},A.run=X,A.preInit)for("function"==typeof A.preInit&&(A.preInit=[A.preInit]);A.preInit.length>0;)A.preInit.pop()();return X(),A});A.exports=g},340:(A,I,g)=>{"use strict";g.r(I),g.d(I,{init:()=>o});var B=function(){function A(A,I){this.tinyH264Module=A,this.onPictureReady=I,this.pStorage=this.tinyH264Module._h264bsdAlloc(),this.pWidth=this.tinyH264Module._malloc(4),this.pHeight=this.tinyH264Module._malloc(4),this.pPicture=this.tinyH264Module._malloc(4),this._decBuffer=this.tinyH264Module._malloc(1048576),this.tinyH264Module._h264bsdInit(this.pStorage,0)}var I=A.prototype;return I.release=function(){var A=this.pStorage;0!==A&&(this.tinyH264Module._h264bsdShutdown(A),this.tinyH264Module._h264bsdFree(A)),this.tinyH264Module._free(this.pWidth),this.tinyH264Module._free(this.pHeight),this.tinyH264Module._free(this.pPicture),this.pStorage=0,this.pWidth=0,this.pHeight=0},I.decode=function(I){if(I instanceof ArrayBuffer&&(I=new Uint8Array(I)),this.tinyH264Module.HEAPU8.set(I,this._decBuffer),this.tinyH264Module._h264bsdDecode(this.pStorage,this._decBuffer,I.byteLength,this.pPicture,this.pWidth,this.pHeight)===A.PIC_RDY){var g=this.tinyH264Module.getValue(this.pWidth,"i32"),B=this.tinyH264Module.getValue(this.pHeight,"i32"),Q=this.tinyH264Module.getValue(this.pPicture,"i8*"),C=new Uint8Array(this.tinyH264Module.HEAPU8.subarray(Q,Q+g*B*3/2));this.onPictureReady(C,g,B)}},A}();B.RDY=0,B.PIC_RDY=1,B.HDRS_RDY=2,B.ERROR=3,B.PARAM_SET_ERROR=4,B.MEMALLOC_ERROR=5;const Q=B;var C=g(719),E=g.n(C),i={"TinyH264.wasm":"data:;base64,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ZGogATYCACAEIANBBHFBGHIiBGsiAkEgSQ0AIAGtIgVCIIYgBYQhBSADIARqIQEDQCABIAU3AxggASAFNwMQIAEgBTcDCCABIAU3AwAgAUEgaiEBIAJBYGoiAkEfSw0ACwsgAAvyAwEDfyABKAIAIgNB////B0cEQCABKAIEIQQgACACIAJBA3EgAkEQSSICG0ECdCIFQfApaigCAEEQQQggAhsiAmxqIAVBsClqKAIAaiIAIAMgAC0AAGpBsC5qLQAAOgAAIAEoAgghAyAAIAQgAC0AAWpBsC5qLQAAOgABIAEoAgwhBCAAIAMgAC0AAmpBsC5qLQAAOgACIAAgBCAALQADakGwLmotAAA6AAMgASgCFCEDIAAgAmoiACABKAIQIAAtAABqQbAuai0AADoAACABKAIYIQQgACADIAAtAAFqQbAuai0AADoAASABKAIcIQMgACAEIAAtAAJqQbAuai0AADoAAiAAIAMgAC0AA2pBsC5qLQAAOgADIAEoAiQhAyAAIAJqIgAgASgCICAALQAAakGwLmotAAA6AAAgASgCKCEEIAAgAyAALQABakGwLmotAAA6AAEgASgCLCEDIAAgBCAALQACakGwLmotAAA6AAIgACADIAAtAANqQbAuai0AADoAAyABKAI0IQMgACACaiIAIAEoAjAgAC0AAGpBsC5qLQAAOgAAIAEoAjghAiAAIAMgAC0AAWpBsC5qLQAAOgABIAEoAjwhASAAIAIgAC0AAmpBsC5qLQAAOgACIAAgASAALQADakGwLmotAAA6AAMLC9MQAQx/IwBBgAFrIgokACAAEA8hBEEBIQUCQAJAAn8gAkEBTQRAIARBAEgNAiAEQRl2Qf4AcUGACGogBEGAgIDgAE8NARogBEEVdkH+D3FBwAhqIARBgICACE8NARogBEERdkH+/wFxQZAJaiAEQYCAgAFPDQEaIARBEHZBAXRBkApqDAELIAJBA00EQCAEQX9MBEBBAkGiECAEQYCAgIAEcRshBQwDCyAEQRl2Qf4AcUHQCmogBEGAgICAAU8NARogBEEWdkH+B3FBkAtqIARBgICAEE8NARogBEERdkH+/wFxQdALagwBCyACQQdNBEAgBEEadiICQXhqQThJBEAgAkEBdEHQDWoMAgsgBEEVdkH+D3FB0A5qDAELIARBGXZB/gBxQdAQaiACQRBNDQAaIARBHXYiAgRAIAJBAXRB0BFqDAELIARBF3ZB/gNxQeARagsvAQAiBQ0AQQEhCwwBC0EBIQsgBUELdiIJIANLDQBBICAFQR9xIgZrIQICQCAJRQRADAELIAQgBnQhBAJAIAVBBXZBP3EiDEUEQAwBCyACIAxJBEAgACAGEAtBf0YNAyAAEA8hBEEgIQILIAQgDHQhBkEBIAxBf2p0IQcgBEEgIAxrdiEEA0AgCkFAayAIQQJ0akF/QQEgBCAHcRs2AgAgCEEBaiEIIAdBAXYiBw0ACyACIAxrIQIgBiEECyAIIAlJBEAgDEEDSSIPIAVB/68BS3EhBQNAIAJBD00EQCAAQSAgAmsQC0F/RgRADAULIAAQDyEEQSAhAgtBACEGAkACQAJ/AkAgBEEASA0AQQEhBiAEQf////8DSw0AQQIhBiAEQf////8BSw0AQQMhBiAEQf////8ASw0AQQQhBiAEQf///z9LDQBBBSEGIARB////H0sNAEEGIQYgBEH///8PSw0AQQchBiAEQf///wdLDQBBCCEGIARB////A0sNAEEJIQYgBEH///8BSw0AQQohBiAEQf///wBLDQBBCyEGIARB//8/Sw0AQQwhBiAEQf//H0sNAEENIQYgBEH//w9LDQACfwJAIARB//8HTQRAIARBgIB8cUGAgARGDQEMCgsgBUEEIAUbIQYgBEEPdCEEQQ4hByACQXFqDAELIAVBASAFGyEFIARBEHQhBEEMIQZBDyEHIAJBcGoLIQIgByAFdCEHIAVFDAELIAYgBXQhB0EBIQ4gAiAGQQFqIgZrIQIgBCAGdCEEIAVFDQEgBSEGQQALIQ4gAiAGTwR/IAQFIABBICACaxALQX9GBEAMBwtBICECIAAQDwshDSACIAZrIQIgDSAGdCEEIA1BICAGa3YgB2ohBwwBC0EAIQULIApBQGsgCEECdGpBACAHQQJqIAcgCCAMRhsgByAPGyINQQJqQQF2IgZrIAYgDUEBcRs2AgBBASAFIA4bIgUgBUEGSSAGQQMgBUF/anRKcWohBSAIQQFqIgggCUcNAAsLQQAhBwJAIAkgA08EQEEAIQgMAQsCQCACQQhLBEAgAiEFDAELQSAhBSAAQSAgAmsQC0F/Rg0DIAAQDyEECwJAAkACfwJAIANBBEcEQCAJQX9qIgJBDUsNAwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIAJBAWsODQABAgMEBQYHCAkKCwwOCyAEQRp2QeASagwOCyAEQRp2QaATagwNCyAEQRt2QeATagwMCyAEQRt2QYAUagwLCyAEQRp2QaAUagwKCyAEQRp2QeAUagwJCyAEQRp2QaAVagwICyAEQRp2QeAVagwHCyAEQRt2QaAWagwGCyAEQRx2QcAWagwFCyAEQRx2QdAWagwECyAEQR12QeAWagwDCyAEQR52QegWagwCCyAEQQBIBEBBASECDAQLQREhAiAJQQNGDQNBEiECIARB/////wNLDQNBIiECIAlBAkYNA0EjQTMgBEH/////AUsbIQIMAwsgBEEbdkGgEmogBEEXdkHAEmogBEH/////AEsbCy0AACICDQEMBAtBEUEBIARBAEgbIQILIAJBBHYhCCAFIAJBD3EiA2shAiAEIAN0IQQLIAlBf2oiAwRAA0ACfyAIBEAgAkEKTQRAIABBICACaxALQX9GBEAMBwsgABAPIQRBICECCwJAAn8CQCAIQX9qIgVBBU0EQAJAAkACQAJAAkAgBUEBaw4FAAECAwQGCyAEQR52Qe4WagwGCyAEQR52QfIWagwFCyAEQR12QfYWagwECyAEQR12Qf4WagwDCyAEQR12QYYXagwCCwJ/QfMAIARBGXZB8ABxayAEQYCAgIACTw0AGkH0ACAEQf////8ASw0AGkGFASAEQf///z9LDQAaQZYBIARB////H0sNABpBpwEgBEH///8PSw0AGkG4ASAEQf///wdLDQAaQckBIARB////A0sNABpB2gEgBEH///8BSw0AGkEAQesBIARBgICAAUkbCyIFQQR2IAhNDQIMCAsgBEEfdkHsFmoLLQAAIQULIAVFBEAMBgsgCiAHQQJ0aiAFQQR2IgZBAWo2AgAgAiAFQQ9xIgVrIQIgBCAFdCEEIAggBmsMAQsgCiAHQQJ0akEBNgIAQQALIQggB0EBaiIHIANHDQALIAEgCEECdGogCkFAayADQQJ0aigCADYCACAJQX5qIQVBASAIdCEHA0AgASAKIAUiA0ECdCIFaigCACAIaiIIQQJ0aiAKQUBrIAVqKAIANgIAIANBf2ohBUEBIAh0IAdyIQcgAw0ACwwBCyABIAhBAnRqIApBQGsgA0ECdGooAgA2AgBBASAIdCEHCyAA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ASAAKALMASADQQF0ai4BHGpBAWpBAXUPCyAFQQRGBEAgAiADQQF0ai4BACEBAn8gACgCyAEiAgRAIAAoAgQgAigCBEYMAQtBAAtFDQEgASAAKALIASAEQQF0ai4BHGpBAWpBAXUPCwJ/An8gACgCyAEiAQRAIAAoAgQgASgCBEYMAQtBAAtFBEBBACECQQAMAQtBASECIAAoAsgBIARBAXRqLgEcCyEBAn8gACgCzAEiBARAIAAoAgQgBCgCBEYMAQtBAAtFDQAgACgCzAEgA0EBdGouARwhACACRQRAIAAPCyAAIAFqQQFqQQF1IQELIAELiQcBB38gAyAFaiINIAEuAQAiDEECdWohAyAEIAZqIg4gAS4BAiIPQQJ1aiEEIAIoAghBBHQhCSACKAIEQQR0IQogACAGQQR0aiAFaiELAkAgDEEDcUEEdCAPQQNxQQJ0ckHQO2ooAgAiDEEOTQRAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIAxBAWsODgECAwQFBgcICQoLDA0OAAsgAigCACALIAMgBCAKIAkgByAIQRAQDAwPCyACKAIAIAsgAyAEQX5qIAogCSAHIAhBABAkDA4LIAIoAgAgCyADIARBfmogCiAJIAcgCBBHDA0LIAIoAgAgCyADIARBfmogCiAJIAcgCEEBECQMDAsgAigCACALIANBfmogBCAKIAkgByAIQQAQIwwLCyACKAIAIAsgA0F+aiAEQX5qIAogCSAHIAhBABAaDAoLIAIoAgAgCyADQX5qIARBfmogCiAJIAcgCEEAECEMCQsgAigCACALIANBfmogBEF+aiAKIAkgByAIQQIQGgwICyACKAIAIAsgA0F+aiAEIAogCSAHIAgQRgwHCyACKAIAIAsgA0F+aiAEQX5qIAogCSAHIAhBABAiDAYLIAIoAgAgCyADQX5qIARBfmogCiAJIAcgCBBFDAULIAIoAgAgCyADQX5qIARBfmogCiAJIAcgCEEBECIMBAsgAigCACALIANBfmogBCAKIAkgByAIQQEQIwwDCyACKAIAIAsgA0F+aiAEQX5qIAogCSAHIAhBARAaDAILIAIoAgAgCyADQX5qIARBfmogCiAJIAcgCEEBECEMAQsgAigCACALIANBfmogBEF+aiAKIAkgByAIQQMQGgsgDUEBdiABLgEAIglBA3VqIQMgDkEBdiABLgECIgFBA3VqIQQgAigCACACKAIEIgogAigCCCILbEEIdGohAiAAIAZBAnRBeHFqIAVBAXZqQYACaiEFIAhBAXYhBiAHQQF2IQcgAUEHcSEIIAtBA3QhACAKQQN0IQECQCAJQQdxIglFDQAgCEUNACACIAUgAyAEIAEgACAJIAggByAGEEgPCyAJBEAgAiAFIAMgBCABIAAgCSAHIAYQSw8LIAgEQCACIAUgAyAEIAEgACAIIAcgBhBKDwsgAiAFIAMgBCABIAAgByAGQQgQDCACIAAgAWxqIAVBQGsgAyAEIAEgACAHIAZBCBAMC8cBAQR/IAAoAgQhAgJAIAAoAgxBA3QgACgCEGsiA0EgTgRAIAIoAAAiAUEYdCABQQh0QYCA/AdxciABQQh2QYD+A3EgAUEYdnJyIQEgACgCCCIARQ0BIAEgAHQgAi0ABEEIIABrdnIPCyADQQFIBEBBAA8LIAItAAAgACgCCCIAQRhqIgR0IQEgACADakF4aiIAQQFIDQADQCACLQABIARBeGoiBHQgAXIhASAAQQhKIQMgAkEBaiECIABBeGohACADDQALCyABC4wEAQd/AkAgAEF/aiIILQAAIgUgAC0AACIGayIEIARBH3UiBGogBHMgAigCBE8NACAAQX5qLQAAIgQgBWsiByAHQR91IgdqIAdzIAIoAggiCU8NACAALQABIgcgBmsiCiAKQR91IgpqIApzIAlPDQAgAUEDTQRAIAggBSABIAIoAgBqQX9qLQAAIghBf3MiCSAIQQFqIgggBiAFa0ECdCAHayAEakEEakEDdSIFIAUgCEobIAUgCUgbIgVqQbAuai0AADoAACAAIAYgBWtBsC5qLQAAOgAADAELIAggBSAHaiAEQQF0akECakECdjoAACAAIAYgB0EBdGogBGpBAmpBAnY6AAALAkAgACADaiIAQX9qIgctAAAiAyAALQAAIgVrIgYgBkEfdSIGaiAGcyACKAIETw0AIABBfmotAAAiBiADayIEIARBH3UiBGogBHMgAigCCCIITw0AIAAtAAEiBCAFayIJIAlBH3UiCWogCXMgCE8NACABQQNNBEAgByABIAIoAgBqQX9qLQAAIgFBf3MiAiABQQFqIgcgBSADa0ECdCAEayAGakEEakEDdSIBIAEgB0obIAEgAkgbIgEg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QRBqIQELIAdBAnYiBEUNAEHAACAGayEQIAlBAXQhCiAJQQJ0IAZrIQtBACAJayIMQQF0IRIgASAHQQR0ayECIAkgE2ogCEEBcWpBAmoiACAJQQVsaiEBA0AgBiIDBEADQCACIAAgCmotAAAiBSABIApqLQAAIAEgCWotAAAiDiABIBJqLQAAIgdqIghrIAhBAnRraiABLQAAIg0gASAMai0AACIIakEUbGpBEGpBBXVBsC5qLQAAIAItADBqQQFqQQF2OgAwIAIgACAJai0AACIPIA4gByAIakEUbGogBSANaiIOayAOQQJ0a2pBEGpBBXVBsC5qLQAAIAItACBqQQFqQQF2OgAgIAIgAC0AACIOIA0gBSAHakEUbGogCCAPaiINayANQQJ0a2pBEGpBBXVBsC5qLQAAIAItABBqQQFqQQF2OgAQIAIgACAMai0AACAIIAUgD2pBFGxqIAcgDmoiBWsgBUECdGtqQRBqQQV1QbAuai0AACACLQAAakEBakEBdjoAACAAQQFqIQAgAkEBaiECIAFBAWohASADQX9qIgMNAAsLIAIgEGohAiABIAtqIQEgACALaiEAIARBf2oiBA0ACwsgEUHAA2okAAu1BQEEfyAAKAIUIQMgACgCECEEIAAoAgQhBSAAKAIMIgIgASkCADcCACACIAEpAgg3AgggAiAFQQR0IgBqIgIgASkCEDcCACACIAEpAhg3AgggACACaiICIAEpAiA3AgAgAiABKQIoNwIIIAAgAmoiAiABKQIwNwIAIAIgASkCODcCCCAAIAJqIgIgASkCQDcCACACIAEpAkg3AgggACACaiICIAEpAlA3AgAgAiABKQJYNwIIIAAgAmoiAiABKQJgNwIAIAIgASkCaDcCCCAAIAJqIgIgASkCcDcCACACIAEpAng3AgggACACaiICIAEpAoABNwIAIAIgASkCiAE3AgggACACaiICIAEpApABNwIAIAIgASkCmAE3AgggACACaiICIAEpAqABNwIAIAIgASkCqAE3AgggACACaiICIAEpArABNwIAIAIgASkCuAE3AgggACACaiICIAEpAsABNwIAIAIgASkCyAE3AgggACACaiICIAEpAtABNwIAIAIgASkC2AE3AgggACACaiICIAEpAuABNwIAIAIgASkC6AE3AgggACACaiIAIAEpAvABNwIAIAAgASkC+AE3AgggBCABKQKAAjcCACAEIAVBA3QiAGoiBCABKQKIAjcCACAAIARqIgQgASkCkAI3AgAgACAEaiIEIAEpApgCNwIAIAAgBGoiBCABKQKgAjcCACAAIARqIgQgASkCqAI3AgAgACAEaiIEIAEpArACNwIAIAAgBGogASkCuAI3AgAgAyABKQLAAjcCACAAIANqIgMgASkCyAI3AgAgACADaiIDIAEpAtACNwIAIAAgA2oiAyABKQLYAjcCACAAIANqIgMgASkC4AI3AgAgACADaiIDIAEpAugCNwIAIAAgA2oiAyABKQLwAjcCACAAIANqIAEpAvgCNwIAC+gCAQV/AkAgACABEAIiAw0AQQEhAyABIAEoAgBBAWoiAjYCACACQSBLDQAgAEEEEAMiAkF/Rg0AIAEgAjYCBCAAQQQQAyICQX9GDQAgASACNgIIIAEoAgAEQANAIAAgASAFQQJ0aiICIgRBDGoQAiIDDQJBASEDIAQoAgwiBkF/Rg0CIAQgBkEBaiIDNgIMIAQgAyABKAIEQQZqdDYCDCAAIAJBjAFqEAIiAw0CQQEhAyACKAKMASIEQX9GDQIgAiAEQQFqIgQ2AowBIAIgBCABKAIIQQRqdDYCjAEgAEEBEAMiBEF/Rg0CIAIgBEEBRjYCjAIgBUEBaiIFIAEoAgBJDQALCyAAQQUQAyICQX9GDQAgASACQQFqNgKMAyAAQQUQAyICQX9GDQAgASACQQFqNgKQAyAAQQUQAyICQX9GDQAgASACQQFqNgKUAyAAQQUQAyIAQX9GDQAgASAANgKYA0EAIQMLIAMLWwEDfyAAIAAoAgAiBCABIAAoAgQiAnAiA0EEdGogASADayIBQQh0ajYCDCAAIAQgAiAAKAIIbCICQQh0aiABQQZ0aiADQQN0aiIBNgIQIAAgASACQQZ0ajYCFAtVAQJ/IAEgAkEBaiIDIAMgAUkbIQMgACACQQJ0aigCACEEA0ACQCACQQFqIgIgAU8EQCADIQIMAQsgACACQQJ0aigCACAERw0BCwtBACACIAEgAkYbCycAIABBCCAAKAIIIgBrEANBf0YEQA8LQQAgAGtBAnRBzD9qKAIAGgt6AQJ/IwBBIGsiAiQAIAIgACgCEDYCECACIAApAgg3AwggAiAAKQIANwMAAkAgAiACQRxqEAIiAA0AIAIgAkEcahACIgANACACIAJBHGoQAiIADQBBASEAIAIoAhwiA0H/AUsNACABIAM2AgBBACEACyACQSBqJAAgAAvnBwESfyMAQYAOayIMJAAgBkEFaiEJAkACQCACQQBIDQAgA0EASA0AIAIgCWogBEsNACADIAdqQQVqIAVLDQAgAyEKDAELIAAgDEHACmogAiADIAQgBSAJIAdBBWogCRAMIAxBwApqIQAgCSEEQQAhAgsCQCAHQQJ2IhRFDQAgCUUNACAEQQF0IRVBACAEayIWQQF0IRogBEECdCAGa0F7aiEXIAAgBCAKbCACamogBGoiACAEQQVsaiECIAwgCUECdCIQaiEDIAlBA3QhDUEAIAlrQQJ0IQ4gCUEDbEECdCEPA0AgCSEFA0AgAyANaiAAIBVqLQAAIhEgAiAVai0AACACIARqLQAAIgsgAiAaai0AACISaiIKayAKQQJ0a2ogAi0AACIYIAIgFmotAAAiE2pBFGxqNgIAIAMgEGogACAEai0AACIZIAsgEiATakEUbGogESAYaiIKayAKQQJ0a2o2AgAgAyAALQAAIgsgGCARIBJqQRRsaiATIBlqIgprIApBAnRrajYCACADIA5qIAAgFmotAAAgEyARIBlqQRRsaiALIBJqIgprIApBAnRrajYCACAAQQFqIQAgA0EEaiEDIAJBAWohAiAFQX9qIgUNAAsgAiAXaiECIAAgF2ohACADIA9qIQMgFEF/aiIUDQALCyAHBEBBECAGayEQIAZBAnYhCiAMIAhBAnRqQQhqIQAgDEEUaiECA0AgCgRAIAJBbGooAgAhBCACQXBqKAIAIQ8gAkF0aigCACENIAJBeGooAgAhBSACQXxqKAIAIQMgCiEJA0AgASACKAIAIg4gBCADIA9qIgRrIAUgDWpBFGxqIARBAnRrakGABGpBCnVBsC5qLQAAIAAoAgBBEGpBBXVBsC5qLQAAakEBakEBdjoAACABIAIoAgQiCyAPIAMgBWpBFGxqIA0gDmoiBGsgBEECdGtqQYAEakEKdUGwLmotAAAgACgCBEEQakEFdUGwLmotAABqQQFqQQF2OgABIAEgAigCCCIIIA0gAyAOakEUbGogBSALaiIEayAEQQJ0a2pBgARqQQp1QbAuai0AACAAKAIIQRBqQQV1QbAuai0AAGpBAWpBAXY6AAIgASACKAIM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KAIABEAgAyAAQewMaiABIABB5ApqKAIAIAIgACgC0ApBBUYgACgCuAkgACgCtAkQKQwBCyADQQAgASAAQeQKaigCACACIAAoAtAKQQVGIAAoArgJIAAoArQJECkLIABCADcCoAlBASEFCyAEQZABaiQAIAULqAwBC38CQCABQQRPBEBBACADayINQQF0IQoCQCAAIANrIgUtAAAiBiAALQAAIghrIgEgAUEfdSIBaiABcyACKAIEIgFPDQAgACAKai0AACIHIAZrIgQgBEEfdSIEaiAEcyACKAIIIgxPDQAgACADai0AACIEIAhrIgsgC0EfdSILaiALcyAMTw0AIAUgBCAGaiAHQQF0akECakECdjoAACAAIAggBEEBdGogB2pBAmpBAnY6AAAgAigCBCEBCwJAIABBAWoiBiANaiIMLQAAIgggAC0AASIHayIEIARBH3UiBGogBHMgAU8NACAGIApqLQAAIgQgCGsiBSAFQR91IgVqIAVzIAIoAggiC08NACADIAZqLQAAIgUgB2siCSAJQR91IglqIAlzIAtPDQAgDCAFIAhqIARBAXRqQQJqQQJ2OgAAIAYgByAFQQF0aiAEakECakECdjoAACACKAIEIQELAkAgAEECaiIGIA1qIgwtAAAiCCAALQACIgdrIgQgBEEfdSIEaiAEcyABTw0AIAYgCmotAAAiBCAIayIFIAVBH3UiBWogBXMgAigCCCILTw0AIAMgBmotAAAiBSAHayIJIAlBH3UiCWogCXMgC08NACAMIAUgCGogBEEBdGpBAmpBAnY6AAAgBiAHIAVBAXRqIARqQQJqQQJ2OgAAIAIoAgQhAQsCQCAAQQNqIgYgDWoiDC0AACIIIAAtAAMiB2siBCAEQR91IgRqIARzIAFPDQAgBiAKai0AACIEIAhrIgUgBUEfdSIFaiAFcyACKAIIIgtPDQAgAyAGai0AACIFIAdrIgkgCUEfdSIJaiAJcyALTw0AIAwgBSAIaiAEQQF0akECakECdjoAACAGIAcgBUEBdGogBGpBAmpBAnY6AAAgAigCBCEBCwJAIABBBGoiBiANaiIMLQAAIgggAC0ABCIHayIEIARBH3UiBGogBHMgAU8NACAGIApqLQAAIgQgCGsiBSAFQR91IgVqIAVzIAIoAggiC08NACADIAZqLQAAIgUgB2siCSAJQR91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ayISNgI8IAAgAiANayICIAMgDmsiA2siDTYCOCAAIAIgA2oiDjYCNCAAIBMgFGoiEzYCMCABQZA8ai0AACECIAFBoD1qLQAAQQxsQdA8aigCACEDIAFBDE8EQCAAIAMgAkF+anQiASAFIAtqIgMgCCATaiICa2w2AjAgACALIAVrIgUgCCATayIIayABbDYCICAAIAUgCGogAWw2AhAgACACIANqIAFsNgIAIAAgBCAJaiIDIAcgDmoiAmsgAWw2AjQgACAJIARrIgQgByAOayIFayABbDYCJCAAIAQgBWogAWw2AhQgACACIANqIAFsNgIEIAAgBiAPaiIDIAogDWoiAmsgAWw2AjggACAPIAZrIgYgCiANayIEayABbDYCKCAAIAQgBmogAWw2AhggACACIANqIAFsNgIIIAAgDCARayIDIBAgEmsiAmsgAWw2AiwgACACIANqIAFsNgIcIAAgECASaiIDIAwgEWoiAmogAWw2AgwgACACIANrIAFsNgI8DwsgAEEBQQIgAUF6akEGSRsiASAFIAtqIhQgCCATaiIVayADbGpBAiACayICdTYCMCAAIAsgBWsiBSAIIBNrIghrIANsIAFqIAJ1NgIgIAAgBSAIaiADbCABaiACdTYCECAAIBQgFWogA2wgAWogAnU2AgAgACAEIAlqIgUgByAOaiIIayADbCABaiACdTYCNCAAIAkgBGsiBCAHIA5rIgdrIANsIAFqIAJ1NgIkIAAgBCAHaiADbCABaiACdTYCFCAAIAUgCGogA2wgAWogAnU2AgQgACAGIA9qIgQgCiANaiIFayADbCABaiACdTYCOCAAIA8gBmsiBiAKIA1rIgprIANsIAFqIAJ1NgIoIAAgBiAKaiADbCABaiACdTYCGCAAIAQgBWogA2wgAWogAnU2AgggACAMIBFrIgYgECASayIEayADbCABaiACdTYCLCAAIAQgBmogA2wgAWogAnU2AhwgACAQIBJqIgYgDCARaiIRaiADbCABaiACdTYCDCAAIBEgBmsgA2wgAWogAnU2AjwLvQUBBn8jAEEgayIFJAAgA0EANgIAAkAgASgCACIGQRJLDQBBASAGdCIGQcDfH3FFBEAgBkEicUUNASACQbQKaigCAARAIANBATYCACACQQA2ArQKCyAAIAVBHGoQICIEDQFB8P8DIQQgAiAF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IAFBf2oQA0F/RgRAQQEhAAwBCyAEIAMQBSEACyAEQSBqJAAgAAvmAQEDfyMAQSBrIgQkACAEIAAoAhA2AhAgBCAAKQIINwMIIAQgACkCADcDAAJAIAQgBEEcahACIgANACAEIARBHGoQAiIADQAgBCAEQRxqEAIiAA0AIAEoAgwhBkEAIQADQCAAIgVBAWohACAGIAV2DQALIAQgBUF/ahADQX9GBEBBASEADAELIAJBBUYEQCAEIARBHGoQAiIADQELIAEoAhQhAkEAIQADQCAAIgFBAWohACACIAF2DQALIAQgAUF/ahADIgBBf0YEQEEBIQAMAQsgAyAANgIAQQAhAAsgBEEgaiQAIAALkgEBAn8jAEEgayIDJAAgAyAAKAIQNgIQIAMgACkCADcDACADIAApAgg3AwgCQCADIANBHGoQAiIADQAgAyADQRxqEAIiAA0AIAMgA0EcahACIgANAEEAIQADQCAAIgRBAWohACABIAR2DQALIAMgBEF/ahADQX9GBEBBASEADAELIAMgAhACIQALIANBIGokACAAC5cBAQJ/IwBBIGsiAyQAIAMgACgCEDYCECADIAApAgg3AwggAyAAKQIANwMAAkAgAyADQRxqEAIiAA0AIAMgA0EcahACIgANACADIANBHGoQAiIADQBBACEAA0AgACIEQQFqIQAgASAEdg0ACyADIARBf2oQAyIAQX9GBEBBASEADAELIAIgADYCAEEAIQALIANBIGokACAAC68OAQp/IwBBEGsiBSQAIAFBAEHcBxAHIQcgAigCNCEGIAIoAjghCAJAIAAgBUEEahACIgENACAHIAUoAgQiATYCACABIAYgCGwiC08EQEEBIQEMAQsgACAFQQRqEAIiAQ0AIAcgBSgCBCIGNgIEIAZBB0sEQEEBIQEMAQtBASEBAkACQCAGQQFrDgcCAQICAAIBAAsgBCgCAEEFRgRADAILIAIoAiwNAAwBCyAAIAVBBGoQAiIBDQAgByAFKAIEIgY2AghBASEBIAYgAygCAEcNACACKAIMIQhBACEBA0AgASIGQQFqIQEgCCAGdg0AC0EBIQEgACAGQX9qEAMiBkF/Rg0AIAZBACAEKAIAIghBBUYbDQAgByAGNgIMIAhBBUYEQCAAIAVBBGoQAiIBDQEgByAFKAIEIgY2AhBBASEBIAZB//8DSw0B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IgMgAiANai0AACACIARqLQAAIgkgAiASai0AACIFaiIIayAIQQJ0a2ogAi0AACIKIAIgD2otAAAiCGpBFGxqQRBqQQV1QbAuai0AADoAMCABIAQgB2otAAAiECAJIAUgCGpBFGxqIAMgCmoiCWsgCUECdGtqQRBqQQV1QbAuai0AADoAICABIActAAAiCSAKIAMgBWpBFGxqIAggEGoiCmsgCkECdGtqQRBqQQV1QbAuai0AADoAECABIAcgD2otAAAgCCADIBBqQRRsaiAFIAlqIgNrIANBAnRrakEQakEFdUGwLmotAAA6AAAgB0EBaiEHIAFBAWohASACQQFqIQIgAEF/aiIADQALIAEgEWohASACIA5qIQIgByAOaiEHIAxBf2oiDA0ACwsgC0HAA2okAAuqBgENfyMAQbABayIRJAAgCEEBaiEKAkACQCACQQBIDQAgA0EASA0AIAIgCmogBEsNACADIAlqQQFqIAVLDQAgBSEMIAQhCiADIQ8MAQsgACARIAIgAyAEIAUgCiAJQQFqIgwgChAMIAAgBCAFbGogESAKIAxsaiACIAMgBCAFIAogDCAKEAwgESEAQQAhAgsCQCAJQQF2IgVFDQAgCEEBdiIERQ0AQRAgCGshE0EIIAdrIQtBCCAGayENIApBAXQiDiAIayEUIAAgAmoiFiAKIA9saiECIAEhACAFIRUDQCACIA5qLQAAIAdsIAsgAiAKai0AACIDbGohCCADIAdsIAsgAi0AAGxqIQkgBCEDA0AgAkEBaiIQIA5qLQAAIRIgACAJIA1sIAogEGotAAAiCSAHbCALIAItAAFsaiIQIAZsakEgakEGdjoAACAAIAggDWwgByASbCAJIAtsaiIIIAZsakEgakEGdjoACCACLQACIQkgAkECaiICIA5qLQAAIRIgACANIBBsIAIgCmotAAAiECAHbCAJIAtsaiIJIAZsakEgakEGdjoAASAAIAggDWwgByASbCALIBBsaiIIIAZsakEgakEGdjoACSAAQQJqIQAgA0F/aiIDDQALIAIgFGohAiAAIBNqIQAgFUF/aiIVDQALIAFBQGshACAWIAwgD2ogCmxqIQIDQCACIA5qLQAAIAdsIAsgAiAKai0AACIBbGohCCABIAdsIAsgAi0AAGxqIQkgBCEDA0AgAkEBaiIBIA5qLQAAIQwgACAJ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AmogAnNBA0shCgsgAyAKNgJoIAEuAaYBIR5BAiEbQQIhEwJAIC8gAS8BLCI0cg0AQQEhEyABLgGkASABLgGMAWsiAiACQR91IgJqIAJzQQNLDQAgHiAEayICIAJBH3UiAmogAnNBA0sNACABKAJ8IAEoAnRHIRMLIAMgEzYCcCABLgGqASEOAkAgECABLwEuIhhyDQBBASEbIAEuAagBIAEuAZABayICIAJBH3UiAmogAnNBA0sNACAOIAZrIgIgAkEfdSICaiACc0EDSw0AIAEoAnwgASgCdEchGwsgAyAbNgJ4IAEuAbYBIRlBAiESQQIhFQJAIBcgAS8BNCIgcg0AQQEhFSABLgG0ASABLgGcAWsiAiACQR91IgJqIAJzQQNLDQAgGSAHayICIAJBH3UiAmogAnNBA0sNACABKAKAASABKAJ4RyEVCyADIBU2AoABIAEuAboBISECQCAzIAEvATYiNXINAEEBIRIgAS4BuAEgAS4BoAFrIgIgAkEfdSICaiACc0EDSw0AICEgC2siAiACQR91IgJqIAJzQQNLDQAgASgCgAEgASgCeEchEgsgAyASNgKIASABLgGuASE2QQIhDSADAn9BAiA0IAEvATAiQXINABpBASABLgGsASABLgGkAWsiAiACQR91IgJqIAJzQQNLDQAaIDYgHmsiAiACQR91IgJqIAJzQQNLCyIdNgKQASABLgGyASEkAkAgGCABLwEyIjdyDQBBASENIAEuAbABIAEuAagBayICIAJBH3UiAmogAnNBA0sNACAkIA5rIgIgAkEfdSICaiACc0EDSyENCyADIA02ApgBIAEuAb4BISlBAiEcIAMCf0ECICAgAS8BOCI4cg0AGkEBIAEuAbwBIAEuAbQBayICIAJBH3UiAmogAnNBA0sNABogKSAZayICIAJBH3UiAmogAnNBA0sLIiY2AqABIAEuAcIBITkCQCA1IAEvAToiQnINAEEBIRwgAS4BwAEgAS4BuAFrIgIgAkEfdSICaiACc0EDSw0AIDkgIWsiAiACQR91IgJqIAJzQQNLIRwLIAMgHDYCqAFBAiECIAMCf0ECIBEgMHINABpBASABLgGIASABLgGEAWsiESARQR91IhFqIBFzQQNLDQAaIAggFGsiFCAUQR91IhRqIBRzQQNLCyIRNgI8AkAgMCAxcg0AQQEhAiAB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BSADLQAGampqQQJqQQJ2DAELIAcEQCADLQAEIAMtAAMgAy0AASADLQACampqQQJqQQJ2IQYgAy0ACCADLQAHIAMtAAUgAy0ABmpqakECakECdgwBCyAKRQRAQYABIQZBgAEMAQsgBC0AAyAELQACIAQtAAAgBC0AAWpqakECakECdiIGC0H/AXFBgYKECGwiADYAHCABIAZB/wFxQYGChAhsIgY2ABggASAANgAUIAEgBjYAECABIAA2AAwgASAGNgAIIAEgADYABCABIAY2AAACfyAKBEAgBC0AByAELQAGIAQtAAUgBC0ABGpqaiIGQQJqQQJ2IgAgB0UNARogAy0ACCADLQAHIAMtAAYgBiADLQAFampqakEEakEDdgwBCyAHRQRAQYABIQBBgAEMAQsgAy0ABCADLQADIAMtAAEgAy0AAmpqakECakECdiEAIAMtAAggAy0AByADLQAFIAMtAAZqampBAmpBAnYLIQYgASAAQf8BcUGBgoQIbCIANgAgIAEgBkH/AXFBgYKECGwiBjYAPCABIAA2ADggASAGNgA0IAEgADYAMCABIAY2ACwgASAANgAoIAEgBjYAJAwDCyAKRQRAQQEPCyABIAQtAAA6AAAgASAELQAAOgABIAEgBC0AADoAAiABIAQtAAA6AAMgASAELQAAOgAEIAEgBC0AADoABSABIAQtAAA6AAYgASAELQAAOgAHIAEgBC0AAToACCABIAQtAAE6AAkgASAELQABOgAKIAEgBC0AAToACyABIAQtAAE6AAwgASAELQABOgANIAEgBC0AAToADiABIAQtAAE6AA8gASAELQACOgAQIAEgBC0AAjoAESABIAQtAAI6ABIgASAELQACOgATIAEgBC0AAjoAFCABIAQtAAI6ABUgASAELQACOgAWIAEgBC0AAjoAFyABIAQtAAM6ABggASAELQADOgAZIAEgBC0AAzoAGiABIAQtAAM6ABsgASAELQADOgAcIAEgBC0AAzoAHSABIAQtAAM6AB4gASAELQADOgAfIAEgBC0ABDoAICABIAQtAAQ6ACEgASAELQAEOgAiIAEgBC0ABDoAIyABIAQtAAQ6ACQgASAELQAEOgAlIAEgBC0ABDoAJiABIAQtAAQ6ACcgASAELQAFOgAoIAEgBC0ABToAKSABIAQtAAU6ACogASAELQAFOgArIAEgBC0ABToALCABIAQtAAU6AC0gASAELQAFOgAuIAEgBC0ABToALyABIAQtAAY6ADAgASAELQAGOgAxIAEgBC0ABjoAMiABIAQtAAY6ADMgASAELQAGOgA0IAEgBC0ABjoANSABIAQtAAY6ADYgASAELQAGOgA3IAEgBC0ABzoAOCABIAQtAAc6ADkgASAELQAHOgA6IAEgBC0ABzoAOyABIAQtAAc6ADwgASAELQAHOgA9IAEgBC0ABzoAPiABIAQtAAc6AD8MAgsgB0UEQEEBDwsgASADLQABOgAAIAEgAy0AAToACCABIAMtAAE6ABAgASADLQABOgAYIAEgAy0AAToAICABIAMtAAE6ACggASADLQABOgAwIAEgAy0AAToAOCABIAMtAAI6AAEgASADLQACOgAJIAEgAy0AAjoAESABIAMtAAI6ABkgASADLQACOgAhIAEgAy0AAjoAKSABIAMtAAI6ADEgASADLQACOgA5IAEgAy0AAzoAAiABIAMtAAM6AAogASADLQADOgASIAEgAy0AAzoAGiABIAMtAAM6ACIgASADLQADOgAqIAEgAy0AAzoAMiABIAMtAAM6ADogASADLQAEOgADIAEgAy0ABDoACyABIAMtAAQ6ABMgASADLQAEOgAbIAEgAy0ABDoAIyABIAMtAAQ6ACsgASADLQAEOgAzIAEgAy0ABDoAOyABIAMtAAU6AAQgASADLQAFOgAMIAEgAy0ABToAFCABIAMtAAU6ABwgASADLQAFOgAkIAEgAy0ABToALCABIAMtAAU6ADQgASADLQAFOgA8IAEgAy0ABjoABSABIAMtAAY6AA0gASADLQAGOgAVIAEgAy0ABjoAHSABIAMtAAY6ACUgASADLQAGOgAtIAEgAy0ABjoANSABIAMtAAY6AD0gASADLQAHOgAGIAEgAy0ABzoADiABIAMtAAc6ABYgASADLQAHOgAeIAEgAy0ABzoAJiABIAMtAAc6AC4gASADLQAHOgA2IAEgAy0ABzoAPiABIAMtAAg6AAcgASADLQAIOgAPIAEgAy0ACDoAFyABIAMtAAg6AB8gASADLQAIOgAnIAEgAy0ACDoALyABIAMtAAg6ADcgASADLQAIOgA/DAELIA5FBEBBAQ8LIAMtAAUgAy0AA2sgAy0ABiADLQACa0EBdGogAy0AByADLQABa0EDbGogAy0ACCIAIAMtAAAiCWtBAnRqQRFsQRBqQQV1IgZBfWwhECAAIAQtAAciDGpBBHQgBC0ABCAELQACayAMIAlrQQJ0aiAELQAFIAQtAAFrQQF0aiAELQAGIAQtAABrQQNsakERbEEQakEFdSIRQX1sakEQaiEJQQghDCABIQADQCAAIAkgEGoiCEEFdUGwLmotAAA6AAAgACAGIAhqIghBBXVBsC5qLQAAOgABIAAgBiAIaiIIQQV1QbAuai0AADoAAiAAIAYgCGoiCEEFdUGwLmotAAA6AAMgACAGIAhqIghBBXVBsC5qLQAAOgAEIAAgBiAIaiIIQQV1QbAuai0AADoABSAAIAYgCGoiCEEFdUGwLmotAAA6AAYgACAGIAhqQQV1QbAuai0AADoAByAJIBFqIQkgAEEIaiEAIAxBf2oiDA0ACwsgASACIAsQCCABIAJBQGsgC0EBchAIIAEgAkGAAWogC0ECchAIIAEgAkHAAWogC0EDchAIIAJBgAJqIQIgBEEIaiEEIANBCWohAyABQUBrIQEgC0EEaiELIBJBAWoiEkECRw0AC0EAC6EVAhh/An4CfwNAAn8gACIIIBZBA3RBsDVqKQIAIh6nEBEiCSIGBEAgCCgCBCAGKAIERgwBC0EACyENAkAgBUUNACANRQ0AQQAgDUECIAkoAgAiBkEGRyAGQQZJG0ECRhshDQsCfyAIIBZBA3RB8DZqKQIAIh+nEBEiByIGBEAgCCgCBCAGKAIERgwBC0EACyEPAkAgBUUNACAPRQ0AQQAgD0ECIAcoAgAiBkEGRyAGQQZJG0ECRhshDwtBAiEMIA1BAEcgD0EAR3EiEkEBRgRAQQIhBgJ/QQIgCSgCACILQQZHIAtBBkkbRQRAIAkgHkIgiKdB/wFxai0AUiEGCyAGCwJ/QQIgBygCACIJQQZHIAlBBkkbRQRAIAcgH0IgiKdB/wFxai0AUiEMCyAMCyAGIAxJGyEMCyACIBZBAnQiCWoiBigCDEUEQCAGKAJMIgYgBiAMT2ohDAsgCCAWaiAMOgBSAn8gCCAWQQN0QbA4aigCABARIgYiBwRAIAgoAgQgBygCBEYMAQtBAAshDgJAIAVFDQAgDkUNAEEAIA5BAiAGKAIAIgZBBkcgBkEGSRtBAkYbIQ4LAn8gACAWQQN0QfA5aigCABARIggiBgRAIAAoAgQgBigCBEYMAQtBAAshEQJAIAVFDQAgEUUNAEEAIBFBAiAIKAIAIghBBkcgCEEGSRtBAkYbIRELIAlB8ClqKAIAIRcgCUGwKWooAgAhGAJ/QYUKIBZ2QQFxIhwEQCAXQQNqIQcgBCAXaiIIQQJqIQYgCEEBaiELIAQMAQsgF0EEdCAYaiIIQS9qIQcgASAIaiIIQR9qIQYgCEEPaiELIAhBf2ohCCABCyEJIAcgCWotAAAhCiAGLQAAIRAgCy0AACETIAgtAAAhFAJAQTMgFnZBAXEEQCADIBhqIgctAAghGyAHLQAHIRkgBy0ABiEVIActAAUhGiAHLQAEIQYgBy0AAyELIActAAIhCSAHLQABIQgMAQsgASAXQX9qIh1BBHQgGGpqIgctAAAhCCAHLQAHIRsgBy0ABiEZIActAAUhFSAHLQAEIRogBy0AAyEGIActAAIhCyAHLQABIQkgHARAIAQgHWohBwwBCyAHQX9qIQcLAkAgDEEHTQRAIActAAAhBwJAAkACQAJAAkACQAJAAkAgDEEBaw4HAQIDBAUGBwALIA9FBEBBAQ8LIAhB/wFxIAtB/wFxQRB0IAZBGHRyciAJQf8BcUEIdHIhFSAIIgwhDSAJIg4hEiALIg8hCiAGIhEhBwwICyANRQRAQQEPCyAKQYGChAhsIRUgEEGBgoQIbCINQRh2IQcgDUEQdiEKIA1BCHYhEiATQYGChAhsIgxBGHYhESAMQRB2IQ8gDEEIdiEOIBRBgYKECGwiCEEYdiEGIAhBEHYhCyAIQQh2IQkMBwsCfyATIBRqIApqIBBqIAZB/wFxaiALQf8BcWogCUH/AXFqIAhB/wFxakEEakEDdiASDQAaIBMgFGogCmogEGpBAmpBAnYgDQ0AGkGAASAPRQ0AGiAGQf8BcSALQf8BcWogCUH/AXFqIAhB/wFxakECakECdgsiCEGBgoQIbCEVIAgiCSILIgYiDCIOIg8iESINIhIiCiEHDAYLIA9FBEBBAQ8LIAZB/wFxIg1BAmoiESAVIAYgDhtB/wFxIgdqIBogBiAOG0H/AXEiCkEBdGpBAnYiDyAZIAYgDhtB/wFxIgwgGyAGIA4bQf8BcSIGQQNsakEWdEGAgIAEakGAgIB4cXIgCiAMaiAHQQF0akECaiIQQQZ0QYD+A3FyIAYgB2ogDEEBdGpBAmoiBkEOdEGAgPwHcXIhFSAGQQJ2IQcgC0H/AXEiBkECaiILIAhB/wFxaiAJQf8BcSIJQQF0akECdiEIIAkgEWogBkEBdGpBAnYiCSEMIAogC2ogDUEBdGpBAnYiCyEOIAshDSAPIgYhEiAQQQJ2IhEhCgwFC0EBIBFFIBJBAXNyDQYaIBQgE0EBdGogEGpBAmoiDkEGdEGA/gNxIAogE0ECaiIPaiAQQQF0akECdnIgCEH/AXEiCkECaiIMIBRqIAdBAXRqQQJ2IghBGHRyIA8gFEEBdGogB2oiEEEOdEGAgPwHcXIhFSAJQf8BcSIRQQJqIgkgBkH/AXFqIAtB/wFxIgtBAXRqQQJ2IQYgDkECdiENIAkgCkEBdGogB2pBAnYiCSEPIBFBAXQgC2ogDGpBAnYiCyERIBBBAnYiDCESIAgiDiEKIAkhBwwEC0EBIBFFIBJBAXNyDQUaIAhB/wFxIgpBAmoiDiALQf8BcSIIIAlB/wFxIgtBAXRqakECdiIPQRh0IBQgE0EBdGogEGpBAmpBAnZyIA4gFGogB0EBdGoiCUEGdEGA/gNxciALQQJqIg4gCkEBdGogB2oiDUEOdEGAgPwHcXIhFSAIQQFqIhAgBkH/AXEiDGpBAXYhBiAMIA5qIAhBAXRqQQJ2IREgCUECdiEMIA1BAnYhDiATIBRBAXRqIAdqQQJqQQJ2IQ0gByAKakEBakEBdiIIIRIgCiALakEBakEBdiIJIQogCyAQakEBdiILIQcMAwtBASARRSASQQFzcg0EGiATQQJqIg4gCmogEEEBdGpBBnRBgP4DcSAQIBNqQQFqIg9BD3RBgID8B3EgFEECaiIMIBNBAXRqIBBqQQJ2IhJBGHRyIAogEGpBAWpBAXZyciEVIAhB/wFxIgggC0H/AXFqIAlB/wFxIglBAXRqQQJqQQJ2IQYgCSAIQQF0aiAHakECakECdiELIA9BAXYhDSAIIAxqIAdBAXRqQQJ2IhEhCSAUQQFqIgogB2pBAXYiCCEPIAogE2pBAXYiDCEKIA4gFEEBdGogB2pBAnYiDiEHDAILIA9FBEBBAQ8LIBogBiAOG0H/AXEiCiAZIAYgDhtB/wFxaiAVIAYgDhtB/wFxIgdBAXRqQRZ0IAtB/wFxIgtBAmoiDCAKaiAGQf8BcSIGQQF0aiIPQQZ0ckGAgIAEakGA/oN4cSAGQQJqIg0gCUH/AXEiCWogC0EBdGpBAnYiDnIgByANaiAKQQF0aiINQQ50QYCA/AdxciEVIAcgCmpBAWpBAXYhByANQQJ2IREgCSAIQf8BcSINakEBakEBdiEIIA9BAnYhDyAMIA1qIAlBAXRqQQJ2IQwgCSALakEBakEBdiIJIQ0gBkEBaiIGIAtqQQF2IgshEiAGIApqQQF2IgYhCgwBCyANRQRAQQEPCyAKQQh0IApyIApBEHRyIApBGHRyIRUgEEECaiIHIBRqIBNBAXRqQQJ2IQkgE0EBaiIGIBRqQQF2IQggBiAQakEBdiILIQwgCiATaiAQQQF0akECakECdiIGIQ4gCiAQakEBakEBdiIPIQ0gByAKQQNsakECdiIRIRIgCiEHCyABIBdBBHQgGGpqIhAgFTYCMCAQIA1B/wFxIBJB/wFxQQh0ciAKQf8BcUEQdHIgB0EYdHI2AiAgECAMQf8BcSAOQf8BcUEIdHIgD0H/AXFBEHRyIBFBGHRyNgIQIBAgCEH/AXEgCUH/AXFBCHRyIAtB/wFxQRB0ciAGQRh0cjYCACABIAIgFkEGdGpByAJqIBYQCCAWQQFqIhZBEEcNAAtBAAsLxRIBEH8CfyAAKALIASIHBEAgACgCBCAHKAIERgwBC0EACyEHAkAgBUUNACAHRQ0AQQAgB0ECIAAoAsgBKAIAIgdBBkcgB0EGSRtBAkYbIQcLAn8gACgCzAEiCARAIAAoAgQgCCgCBEYMAQtBAAshCAJAIAVFDQAgCEUNAEEAIAhBAiAAKALMASgCACIIQQZHIAhBBkkbQQJGGyEICwJ/IAAoAtQBIgkEQCAAKAIEIAkoAgRGDAELQQALIQkCQCAFRQ0AIAlFDQBBAiAAKALUASgCACIFQQZHIAVBBkkbQQJHIQkLAkACQCAAKAIAQQFqQQNxIgBBAk0EQAJAAkACQCAAQQFrDgIBAgALIAhFBEBBAQ8LQQAhBSABIQADQCAAIAMtAAE6AAAgACADLQACOgABIAAgAy0AAzoAAiAAIAMtAAQ6AAMgACADLQAFOgAEIAAgAy0ABjoABSAAIAMtAAc6AAYgACADLQAIOgAHIAAgAy0ACToACCAAIAMtAAo6AAkgACADLQALOgAKIAAgAy0ADDoACyAAIAMtAA06AAwgACADLQAOOgANIAAgAy0ADzoADiAAIAMtABA6AA8gAEEQaiEAIAVBAWoiBUEQRw0ACwwDCyAHRQRAQQEPC0EAIQUgASEAA0AgACAEIAVqIgMtAAA6AAAgACADLQAAOgABIAAgAy0AADoAAiAAIAMtAAA6AAMgACADLQAAOgAEIAAgAy0AADoABSAAIAMtAAA6AAYgACADLQAAOgAHIAAgAy0AADoACCAAIAMtAAA6AAkgACADLQAAOgAKIAAgAy0AADoACyAAIAMtAAA6AAwgACADLQAAOgANIAAgAy0AADoADiAAIAMtAAA6AA8gAEEQaiEAIAVBAWoiBUEQRw0ACwwCCyABAn8CQCAHRQ0AIAhFDQAgBC0ADyADLQAQIAQtAA4gAy0ADyAELQANIAMtAA4gBC0ADCADLQANIAQtAAsgAy0ADCAELQAKIAMtAAsgBC0ACSADLQAKIAQtAAggAy0ACSAELQAHIAMtAAggBC0ABiADLQAHIAQtAAUgAy0ABiAELQAEIAMtAAUgBC0AAyADLQAEIAQtAAIgAy0AAyAELQABIAMtAAIgAy0AASAELQAAampqampqampqampqampqampqampqampqampqampqakEQakEFdgwBCyAHBEAgBC0ADyAELQAOIAQtAA0gBC0ADCAELQALIAQtAAogBC0ACSAELQAIIAQtAAcgBC0ABiAELQAFIAQtAAQgBC0AAyAELQACIAQtAAAgBC0AAWpqampqampqampqampqakEIakEEdgwBC0GAASAIRQ0AGiADLQAQIAMtAA8gAy0ADiADLQANIAMtAAwgAy0ACyADLQAKIAMtAAkgAy0ACCADLQAHIAMtAAYgAy0ABSADLQAEIAMtAAMgAy0AASADLQACampqampqampqampqampqQQhqQQR2C0GAAhAHGgwBC0EBIQAgB0UNASAIRQ0BIAlFDQEgBC0ACCAELQAGayAELQAPIgAgAy0AACIFa0EDdGogBC0ACSAELQAFa0EBdGogBC0ACiAELQAEa0EDbGogBC0ACyAELQADa0ECdGogBC0ADCAELQACa0EFbGogBC0ADSAELQABa0EGbGogBC0ADiAELQAAa0EHbGpBBWxBIGpBBnUhByADLQAJIAMtAAdrIAMtAAogAy0ABmtBAXRqIAMtAAsgAy0ABWtBA2xqIAMtAAwgAy0ABGtBAnRqIAMtAA0gAy0AA2tBBWxqIAMtAA4gAy0AAmtBBmxqIAMtAA8gAy0AAWtBB2xqIAMtABAiAyAFa0EDdGpBBWxBIGpBBnUiBEEDdCEIIARBB2whCSAEQQZsIQogBEEFbCELIARBA2whDCAEQX1sIQ0gBEF7bCEOIARBemwhDyAEQXlsIRBBACAEQQF0IhFrIRJBACAEQQJ0IhNrIRQgACADakEEdEEQaiEVQQAhBQNAIAEgBUEEdCIAaiAVIAVBeWogB2xqIgMgEGpBBXUiBkH/ASAGQf8BSBsiBkEAIAZBAEobOgAAIAEgAEEBcmogAyAPakEFdSIGQf8BIAZB/wFIGyIGQQAgBkEAShs6AAAgASAAQQJyaiADIA5qQQV1IgZB/wEgBkH/AUgbIgZBACAGQQBKGzoAACABIABBA3JqIAMgFGpBBXUiBkH/ASAGQf8BSBsiBkEAIAZBAEobOgAAIAEgAEEEcmogAyANakEFdSIGQf8BIAZB/wFIGyIGQQAgBkEAShs6AAAgASAAQQVyaiADIBJqQQV1IgZB/wEgBkH/AUgbIgZBACAGQQBKGzoAACABIABBBnJqIAMgBGtBBXUiBkH/ASAGQf8BSBsiBkEAIAZBAEobOgAAIAEgAEEHcmogA0EFdSIGQf8BIAZB/wFIGyIGQQAgBkEAShs6AAAgASAAQQhyaiADIARqQQV1IgZB/wEgBkH/AUgbIgZBACAGQQBKGzoAACABIABBCXJqIAMgEWpBBXUiBkH/ASAGQf8BSBsiBkEAIAZBAEobOgAAIAEgAEEKcmogAyAMakEFdSIGQf8BIAZB/wFIGyIGQQAgBkEAShs6AAAgASAAQQtyaiADIBNqQQV1IgZB/wEgBkH/AUgbIgZBACAGQQBKGzoAACABIABBDHJqIAMgC2pBBXUiBkH/ASAGQf8BSBsiBkEAIAZBAEobOgAAIAEgAEENcmogAyAKakEFdSIGQf8BIAZB/wFIGyIGQQAgBkEAShs6AAAgASAAQQ5yaiADIAlqQQV1IgZB/wEgBkH/AUgbIgZBACAGQQBKGzoAACABIABBD3JqIAMgCGpBBXUiAEH/ASAAQf8BSBsiAEEAIABBAEobOgAAIAVBAWoiBUEQRw0ACwtBACEAIAEgAkEAEAggASACQUBrQQEQCCABIAJBgAFqQQIQCCABIAJBwAFqQQMQCCABIAJBgAJqQQQQCCABIAJBwAJqQQUQCCABIAJBgANqQQYQCCABIAJBwANqQQcQCCABIAJBgARqQQgQCCABIAJBwARqQQkQCCABIAJBgAVqQQoQCCABIAJBwAVqQQsQCCABIAJBgAZqQQwQCCABIAJBwAZqQQ0QCCABIAJBgAdqQQ4QCCABIAJBwAdqQQ8QCAsgAAvBCAEHfwJAIANFDQAgACgCACADIAAoAgQiBW4iCCAFbCIEQQh0aiADIARrIgdBBHRqIQYgBUEEdCEEIAAoAgghCSAFIANLIgpFBEAgASAGIARBf3NqIgMtAAA6AAAgASAGIARrLQAAOgABIAEgAy0AAjoAAiABIAMtAAM6AAMgASADLQAEOgAEIAEgAy0ABToABSABIAMtAAY6AAYgASADLQAHOgAHIAEgAy0ACDoACCABIAMtAAk6AAkgASADLQAKOgAKIAEgAy0ACzoACyABIAMtAAw6AAwgASADLQANOgANIAEgAy0ADjoADiABIAMtAA86AA8gASADLQAQOgAQIAEgAy0AEToAESABIAMtABI6ABIgASADLQATOgATIAEgAy0AFDoAFCABQRVqIQELIAcEQCACIAZBf2oiAy0AADoAACACIAMgBGoiAy0AADoAASACIAMgBGoiAy0AADoAAiACIAMgBGoiAy0AADoAAyACIAMgBGoiAy0AADoABCACIAMgBGoiAy0AADoABSACIAMgBGoiAy0AADoABiACIAMgBGoiAy0AADoAByACIAMgBGoiAy0AADoACCACIAMgBGoiAy0AADoACSACIAMgBGoiAy0AADoACiACIAMgBGoiAy0AADoACyACIAMgBGoiAy0AADoADCACIAMgBGoiAy0AADoADSACIAMgBGoiAy0AADoADiACIAMgBGotAAA6AA8gAkEQaiECCyAAKAIAIAUgCWwiBkEIdGogCCAFQQN0IgBsQQN0aiAHQQN0aiEEIABB+P///wdxIQAgCkUEQCABIAQgAEF/c2oiAy0AADoAACABIAQgAGstAAA6AAEgASADLQACOgACIAEgAy0AAzoAAyABIAMtAAQ6AAQgASADLQAFOgAFIAEgAy0ABjoABiABIAMtAAc6AAcgASADQQhqIgMtAAA6AAggASAGQQZ0IANqIgNBeGotAAA6AAkgASADQXlqLQAAOgAKIAEgA0F6ai0AADoACyABIANBe2otAAA6AAwgASADQXxqLQAAOgANIAEgA0F9ai0AADoADiABIANBfmotAAA6AA8gASADQX9qLQAAOgAQIAEgAy0AADoAEQsgB0UNACACIARBf2oiAS0AADoAACACIAAgAWoiAS0AADoAASACIAAgAWoiAS0AADoAAiACIAAgAWoiAS0AADoAAyACIAAgAWoiAS0AADoABCACIAAgAWoiAS0AADoABSACIAAgAWoiAS0AADoABiACIAAgAWoiAS0AADoAByACIAAgAWogBiAFa0EGdGoiAS0AADoACCACIAAgAWoiAS0AADoACSACIAAgAWoiAS0AADoACiACIAAgAWoiAS0AADoACyACIAAgAWoiAS0AADoADCACIAAgAWoiAS0AADoADSACIAAgAWoiAS0AADoADiACIAAgAWotAAA6AA8LC68BAQF/IwBB0ABrIgYkACACIAZBIGogBiADEFUCQAJAQQIgACgCACIDQQZHIANBBkkbQQFGBEAgACAFIAFByAJqIAZBIGogBiAEEFQiA0UNAQwCCyAAIAUgASAGQSBqIAYgBBBTIgMNAQsgACAFQYACaiABQcgKaiAGQTVqIAZBEGogASgCjAEgBBBSIgMNAEEAIQMgACgCxAFBAUsNACACIAUQGwsgBkHQAGokACADC6MqASR/IwBBIGsiECQAIBAgBCgCBCIINgIMIBAgBCgCCDYCECADIAhuIgZBBHQhFCADIAYgCGxrQQR0IRUCQAJAAkACQAJAAkACQAJAIAAoAgAiBkEDTQRAAkACQAJAIAZBAmsOAgECAAsgASgCkAEhEyAAKAIEIQ5BfyEPAn8gACgCyAEiCUUEQEEAIQhBfwwBC0EAIQhBfyAJKAIEIA5HDQAaQQEhEkF/IAkoAgBBBUsNABogCSgCmAEiCEEQdiEHIAkoAmgLIQ0gACgCzAEiCUUNCCAJKAIEIA5HDQhBASEWIAkoAgBBBUsNCCAJKAKsASIRQRB2IQogCSgCbCEPDAgLIAEoApABIRMgAS8BogEhDSABLwGgASEMIAAoAgQhC0F/IQcCQCAAKALMASIGRQ0AIAsgBigCBEcEQAwBC0EBIRIgBigCAEEFSw0AIAYoAqwBIglBEHYhCiAGKAJsIQcLIAcgE0YEQCAKIQcgCSEGDAcLQX8hDwJAAkACQCAAKALIASIIRQRAQQAh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AAAJAAAABAAAAAwAAAD/AAAAAAAAAP8AAAAAAAAABAAAAAkAAAAEAAAADAAAAAQAAAALAAAABAAAAA4AAAABAAAACgAAAP8AAAAAAAAA/wAAAAAAAAD/AAAAAAAAAAEAAAAKAAAABAAAAAAAAAD/AAAAAAAAAP8AAAAAAAAAAQAAAAoAAAABAAAACwAAAP8AAAAAAAAA/wAAAAAAAAABAAAACgAAAAEAAAALAAAABAAAAAAAAAAEAAAAAQAAAAEAAAAOAAAA/wAAAAAAAAD/AAAAAAAAAP8AAAAAAAAAAQAAAA4AAAAEAAAABAAAAP8AAAAAAAAA/wAAAAAAAAABAAAADgAAAAEAAAAPAAAA/wAAAAAAAAD/AAAAAAAAAAEAAAAOAAAAAQAAAA8AAAAEAAAABAAAAAQAAAAFAAAABAAAAAIAAAD/AAAAAAAAAP8AAAAAAAAA/wAAAAAAAAAEAAAAAgAAAAQAAAAIAAAA/wAAAAAAAAD/AAAAAAAAAAQAAAACAAAABAAAAAMAAAD/AAAAAAAAAP8AAAAAAAAABAAAAAIAAAAEAAAAAwAAAAQAAAAIAAAABAAAAAkAAAAEAAAABgAAAP8AAAAAAAAA/wAAAAAAAAD/AAAAAAAAAAQAAAAGAAAABAAAAAwAAAD/AAAAAAAAAP8AAAAAAAAABAAAAAYAAAAEAAAABwAAAP8AAAAAAAAA/wAAAAAAAAAEAAAABgAAAAQAAAAHAAAABAAAAAwAAAAEAAAADQAAAAEAAAAOAAAA/wAAAAAAAAD/AAAAAAAAAP8AAAAAAAAAAQAAAA4AAAD/AAAABAAAAP8AAAAAAAAA/wAAAAAAAAABAAAACwAAAAEAAAAOAAAA/wAAAAAAAAD/AAAAAAAAAAEAAAALAAAAAQAAAA4AAAAEAAAAAQAAAP8AAAAEAAAAAgAAAAoAAAD/AAAAAAAAAP8AAAAAAAAA/wAAAAAAAAACAAAACgAAAP8AAAAAAAAA/wAAAAAAAAD/AAAAAAAAAAEAAAAPAAAAAgAAAAoAAAD/AAAAAAAAAP8AAAAAAAAAAQAAAA8AAAACAAAACgAAAAQAAAAFAAAA/wAAAAAAAAAEAAAABgAAAP8AAAAAAAAA/wAAAAAAAAD/AAAAAAAAAAQAAAAGAAAA/wAAAAwAAAD/AAAAAAAAAP8AAAAAAAAABAAAAAMAAAAEAAAABgAAAP8AAAAAAAAA/wAAAAAAAAAEAAAAAwAAAAQAAAAGAAAABAAAAAkAAAD/AAAADAAAAP8AAAACAAAA/wAAAAAAAAD/AAAAAAAAAP8AAAAAAAAA/wAAAAIAAAD/AAAACAAAAP8AAAAAAAAA/wAAAAAAAAAEAAAABwAAAP8AAAACAAAA/wAAAAAAAAD/AAAAAAAAAAQAAAAHAAAA/wAAAAIAAAAEAAAADQAAAP8AAAAIAAAAAwAAAA8AAAD/AAAAAAAAAP8AAAAAAAAA/wAAAAAAAAADAAAADwAAAAAAAAAFAAAA/wAAAAAAAAD/AAAAAAAAAAMAAAAPAAAAAQAAAAoAAAD/AAAAAAAAAP8AAAAAAAAAAwAAAA8AAAABAAAACgAAAAAAAAAFAAAABAAAAAAAAAABAAAACwAAAP8AAAAAAAAA/wAAAAAAAAD/AAAAAAAAAAEAAAALAAAABAAAAAEAAAD/AAAAAAAAAP8AAAAAAAAAAQAAAAsAAAABAAAADgAAAP8AAAAAAAAA/wAAAAAAAAABAAAACwAAAAEAAAAOAAAABAAAAAEAAAAEAAAABAAAAAAAAAAHAAAA/wAAAAAAAAD/AAAAAAAAAP8AQdQnCxUHAAAAAAAAAA0AAAD/AAAAAAAAAP8AQfQnCxUHAAAABAAAAAIAAAD/AAAAAAAAAP8AQZQoC9kBBwAAAAQAAAACAAAAAAAAAA0AAAAEAAAACAAAAAQAAAADAAAA/wAAAAAAAAD/AAAAAAAAAP8AAAAAAAAABAAAAAMAAAAEAAAACQAAAP8AAAAAAAAA/wAAAAAAAAAEAAAAAwAAAAQAAAAGAAAA/wAAAAAAAAD/AAAAAAAAAAQAAAADAAAABAAAAAYAAAAEAAAACQAAAAQAAAAMAAAAAAAAAAQAAAAAAAAABAAAAAgAAAAMAAAACAAAAAwAAAAAAAAABAAAAAAAAAAEAAAACAAAAAwAAAAIAAAADABB+CkLBQQAAAAEAEGIKgslBAAAAAQAAAAIAAAACAAAAAwAAAAMAAAACAAAAAgAAAAMAAAADABBsS4LyAYBAgMEBQYHCAkKCwwNDg8QERITFBUWFxgZGhscHR4fICEiIyQlJicoKSorLC0uLzAxMjM0NTY3ODk6Ozw9Pj9AQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVpbXF1eX2BhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ent8fX5/gIGCg4SFhoeIiYqLjI2Oj5CRkpOUlZaXmJmam5ydnp+goaKjpKWmp6ipqqusra6vsLGys7S1tre4ubq7vL2+v8DBwsPExcbHyMnKy8zNzs/Q0dLT1NXW19jZ2tvc3d7f4OHi4+Tl5ufo6err7O3u7/Dx8vP09fb3+Pn6+/z9/v///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////wAAAAABAAAABAAAAAUAAAACAAAAAwAAAAYAAAAHAAAACAAAAAkAAAAMAAAADQAAAAoAAAALAAAADgAAAA8AAAAAAAAAAQAAAAEAQYQ1CyEBAAAAAQAAAAEAAAABAAAAAgAAAAIAAAABAAAAAgAAAAIAQbQ1CwUFAAAABABBxDULyQYHAAAABAAAAAIAAAAEAAAAAQAAAAQAAAAEAAAABAAAAAMAAAAEAAAABgAAAAAAAAANAAAABAAAAAgAAAAAAAAADwAAAAQAAAAKAAAABAAAAAkAAAAEAAAADAAAAAQAAAALAAAABAAAAA4AAAAAAAAAEQAAAAQAAAAQAAAAAAAAABMAAAAEAAAAEgAAAAAAAAAVAAAABAAAABQAAAAAAAAAFwAAAAQAAAAWAAAAAQAAAAoAAAABAAAACwAAAAQAAAAAAAAABAAAAAEAAAABAAAADgAAAAEAAAAPAAAABAAAAAQAAAAEAAAABQAAAAQAAAACAAAABAAAAAMAAAAEAAAACAAAAAQAAAAJAAAABAAAAAYAAAAEAAAABwAAAAQAAAAMAAAABAAAAA0AAAABAAAAEgAAAAEAAAATAAAABAAAABAAAAAEAAAAEQAAAAEAAAAWAAAAAQAAABcAAAAEAAAAFAAAAAQAAAAVAAAAAQAAAAsAAAABAAAADgAAAAQAAAABAAAA/wAAAAQAAAABAAAADwAAAAIAAAAKAAAABAAAAAUAAAD/AAAAAAAAAAQAAAADAAAABAAAAAYAAAAEAAAACQAAAP8AAAAMAAAABAAAAAcAAAD/AAAAAgAAAAQAAAANAAAA/wAAAAgAAAABAAAAEwAAAAIAAAASAAAABAAAABEAAAD/AAAAEAAAAAEAAAAXAAAAAgAAABYAAAAEAAAAFQAAAP8AAAAUAAAAAwAAAA8AAAABAAAACgAAAAAAAAAFAAAABAAAAAAAAAABAAAACwAAAAEAAAAOAAAABAAAAAEAAAAEAAAABAAAAAAAAAAHAAAABAAAAAIAAAAAAAAADQAAAAQAAAAIAAAABAAAAAMAAAAEAAAABgAAAAQAAAAJAAAABAAAAAwAAAADAAAAEwAAAAEAAAASAAAAAAAAABEAAAAEAAAAEAAAAAMAAAAXAAAAAQAAABYAAAAAAAAAFQAAAAQAAAAUAAAAAQAAAAEAAAACAAAAAgAAAAMAAAADAAAAAwAAAAMAAAAAAAAAAQAAAAIAAAADAAAABAAAAAUAAAAGAAAABwAAAAgAAAAJAAAACgAAAAsAAAAMAAAADQAAAA4AAAAPAEGWPAsuAQEBAQEBAgICAgICAwMDAwMDBAQEBAQEBQUFBQUFBgYGBgYGBwcHBwcHCAgICABB0DwLRQoAAAANAAAAEAAAAAsAAAAOAAAAEgAAAA0AAAAQAAAAFAAAAA4AAAASAAAAFwAAABAAAAAUAAAAGQAAABIAAAAXAAAAHQBBoT0LMwECAwQFAAECAwQFAAECAwQFAAECAwQFAAECAwQFAAECAwQFAAECAwQFAAECAwQFAAECAwBB5D0LzAIBAAAAAgAAAAMAAAAEAAAABQAAAAYAAAAHAAAACAAAAAkAAAAKAAAACwAAAAwAAAANAAAADgAAAA8AAAAQAAAAEQAAABIAAAATAAAAFAAAABUAAAAWAAAAFwAAABgAAAAZAAAAGgAAABsAAAAcAAAAHQAAAB0AAAAeAAAAHwAAACAAAAAgAAAAIQAAACIAAAAiAAAAIwAAACMAAAAkAAAAJAAAACUAAAAlAAAAJQAAACYAAAAmAAAAJgAAACcAAAAnAAAAJwAAACcAAAABAAAAAgAAAAQAAAAIAAAAEAAAACAAAABAAAAAgAAAAC8fDwAXGx0eBwsNDicrLS4QAwUKDBMVGhwjJSosAQIECBESFBgGCRYZICEiJCgmKQAQAQIECCADBQoMDy8HCw0OBgkfIyUqLCEiJCgnKy0uERIUGBMVGhwXGx0eFhkmKQ=="},D={};function o(){var A,I=E()({locateFile:function(A){return i[A]}});return(A=I,new Promise((function(I){A.calledRun?I():A.onRuntimeInitialized=function(){return I()}}))).then((function(){self.addEventListener("message",(function(A){var g=A.data,B=g.renderStateId;switch(g.type){case"decode":var C=D[B];C||(C=new Q(I,(function(A,I,g){postMessage({type:"pictureReady",width:I,height:g,renderStateId:B,data:A.buffer},[A.buffer])})),D[B]=C),C.decode(new Uint8Array(g.data,g.offset,g.length));break;case"release":var E=D[B];E&&(E.release(),delete D[B])}})),self.postMessage({type:"decoderReady"})}))}}},I={};function g(B){var Q=I[B];if(void 0!==Q)return Q.exports;var C=I[B]={exports:{}};return A[B](C,C.exports,g),C.exports}g.n=A=>{var I=A&&A.__esModule?()=>A.default:()=>A;return g.d(I,{a:I}),I},g.d=(A,I)=>{for(var B in I)g.o(I,B)&&!g.o(A,B)&&Object.defineProperty(A,B,{enumerable:!0,get:I[B]})},g.o=(A,I)=>Object.prototype.hasOwnProperty.call(A,I),g.r=A=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(A,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(A,"__esModule",{value:!0})},(()=>{"use strict";g(340).init()})()})();',"Worker",void 0,void 0)}},614:A=>{A.exports=function(A,I,g,e){var B=self||window;try{try{var i;try{i=new B.Blob([A])}catch(I){(i=new(B.BlobBuilder||B.WebKitBlobBuilder||B.MozBlobBuilder||B.MSBlobBuilder)).append(A),i=i.getBlob()}var t=B.URL||B.webkitURL,Q=t.createObjectURL(i),C=new B[I](Q,g);return t.revokeObjectURL(Q),C}catch(e){return new B[I]("data:application/javascript,".concat(encodeURIComponent(A)),g)}}catch(A){if(!e)throw Error("Inline worker is not supported");return new B[I](e,g)}}}},I={};function g(e){var B=I[e];if(void 0!==B)return B.exports;var i=I[e]={exports:{}};return A[e].call(i.exports,i,i.exports,g),i.exports}return g.n=A=>{var I=A&&A.__esModule?()=>A.default:()=>A;return g.d(I,{a:I}),I},g.d=(A,I)=>{for(var e in I)g.o(I,e)&&!g.o(A,e)&&Object.defineProperty(A,e,{enumerable:!0,get:I[e]})},g.o=(A,I)=>Object.prototype.hasOwnProperty.call(A,I),g.r=A=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(A,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(A,"__esModule",{value:!0})},g(114)})()},53:A=>{self,A.exports=(()=>{"use strict";var A={114:function(A,I,g){var e=this&&this.__importDefault||function(A){return A&&A.__esModule?A:{default:A}};Object.defineProperty(I,"__esModule",{value:!0});const B=e(g(289));I.default=class{initialize(){return new Promise(((A,I)=>{this.worker=new B.default,this.worker.addEventListener("message",(I=>{var g;const e=I.data;"decoderReady"===e.type?A(0):"decodeDone"===e.type&&(null===(g=this.onDecode)||void 0===g||g.call(this,e))}))}))}startStream(A,I,g){this.worker&&this.worker.postMessage({type:"startStream",sampleRateHz:A,channelCount:I,decodedSamplesPerFrame:g})}stopStream(){this.worker&&this.worker.postMessage({type:"stopStream"})}decode(A,I){this.worker&&this.worker.postMessage({type:"decode",startTimestamp:A,inputData:I},[I])}release(){this.worker&&this.worker.postMessage({type:"release"})}dispose(){this.worker&&(this.worker.terminate(),this.worker=void 0)}}},289:(A,I,g)=>{g.r(I),g.d(I,{default:()=>i});var e=g(614),B=g.n(e);function i(){return B()('(()=>{var A={305:A=>{var I,g=(I="undefined"!=typeof document&&document.currentScript?document.currentScript.src:void 0,function(A){var g,B;(A=void 0!==(A=A||{})?A:{}).ready=new Promise((function(A,I){g=A,B=I}));var Q,C={};for(Q in A)A.hasOwnProperty(Q)&&(C[Q]=A[Q]);var E=[],i="./this.program",D=function(A,I){throw I},o="";"undefined"!=typeof document&&document.currentScript&&(o=document.currentScript.src),I&&(o=I),o=0!==o.indexOf("blob:")?o.substr(0,o.lastIndexOf("/")+1):"";var w,F,G=A.print||console.log.bind(console),R=A.printErr||console.warn.bind(console);for(Q in C)C.hasOwnProperty(Q)&&(A[Q]=C[Q]);C=null,A.arguments&&(E=A.arguments),A.thisProgram&&(i=A.thisProgram),A.quit&&(D=A.quit),A.wasmBinary&&(w=A.wasmBinary),A.noExitRuntime&&(F=A.noExitRuntime),"object"!=typeof WebAssembly&&n("no native wasm support detected");var S=!1;function U(I){var g,B=A["_"+I];return g="Cannot call unknown function "+I+", make sure it is exported",B||n("Assertion failed: "+g),B}function a(A,I,g,B,Q){var C={string:function(A){var I=0;if(null!=A&&0!==A){var g=1+(A.length<<2);!function(A,I,g){J(A,k,I,g)}(A,I=V(g),g)}return I},array:function(A){var I,g,B=V(A.length);return I=A,g=B,s.set(I,g),B}},E=U(A),i=[],D=0;if(B)for(var o=0;o<B.length;o++){var w=C[g[o]];w?(0===D&&(D=X()),i[o]=w(B[o])):i[o]=B[o]}var F=E.apply(null,i);return F=function(A){return"string"===I?H(A):"boolean"===I?Boolean(A):A}(F),0!==D&&Z(D),F}var s,k,h,N="undefined"!=typeof TextDecoder?new TextDecoder("utf8"):void 0;function y(A,I,g){for(var B=I+g,Q=I;A[Q]&&!(Q>=B);)++Q;if(Q-I>16&&A.subarray&&N)return N.decode(A.subarray(I,Q));for(var C="";I<Q;){var E=A[I++];if(128&E){var i=63&A[I++];if(192!=(224&E)){var D=63&A[I++];if((E=224==(240&E)?(15&E)<<12|i<<6|D:(7&E)<<18|i<<12|D<<6|63&A[I++])<65536)C+=String.fromCharCode(E);else{var o=E-65536;C+=String.fromCharCode(55296|o>>10,56320|1023&o)}}else C+=String.fromCharCode((31&E)<<6|i)}else C+=String.fromCharCode(E)}return C}function H(A,I){return A?y(k,A,I):""}function J(A,I,g,B){if(!(B>0))return 0;for(var Q=g,C=g+B-1,E=0;E<A.length;++E){var i=A.charCodeAt(E);if(i>=55296&&i<=57343&&(i=65536+((1023&i)<<10)|1023&A.charCodeAt(++E)),i<=127){if(g>=C)break;I[g++]=i}else if(i<=2047){if(g+1>=C)break;I[g++]=192|i>>6,I[g++]=128|63&i}else if(i<=65535){if(g+2>=C)break;I[g++]=224|i>>12,I[g++]=128|i>>6&63,I[g++]=128|63&i}else{if(g+3>=C)break;I[g++]=240|i>>18,I[g++]=128|i>>12&63,I[g++]=128|i>>6&63,I[g++]=128|63&i}}return I[g]=0,g-Q}function L(A){var I=function(A){for(var I=0,g=0;g<A.length;++g){var B=A.charCodeAt(g);B>=55296&&B<=57343&&(B=65536+((1023&B)<<10)|1023&A.charCodeAt(++g)),B<=127?++I:I+=B<=2047?2:B<=65535?3:4}return I}(A)+1,g=V(I);return J(A,s,g,I),g}A.INITIAL_MEMORY;var q,M=[],K=[],c=[],Y=[];K.push({func:function(){l()}});var d=0,P=null,t=null;function n(I){A.onAbort&&A.onAbort(I),R(I+=""),S=!0,I="abort("+I+"). Build with -s ASSERTIONS=1 for more info.";var g=new WebAssembly.RuntimeError(I);throw B(g),g}A.preloadedImages={},A.preloadedAudios={};var r="data:application/octet-stream;base64,";function f(A){return I=A,g=r,String.prototype.startsWith?I.startsWith(g):0===I.indexOf(g);var I,g}var W,b="data:application/octet-stream;base64,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AXgB2AEEAGQAxAAkAYQBJACEAOQARAGkAUQApAAEAWQBxAEMAGwAzAAsAYwBLACMAOwATAGsAUwArAAMAWwBzAEUAHQA1AA0AZQBNACUAPQAVAG0AVQAtAAUAXQB1AEcAHwA3AA8AZwBPACcAPwAXAG8AVwAvAAcAXwB3AEBAGEAwQAhAYEBIQCBAOEAQQGhAUEAoQABAWEBwQEJAGkAyQApAYkBKQCJAOkASQGpAUkAqQAJAWkByQERAHEA0QAxAZEBMQCRAPEAUQGxAVEAsQARAXEB0QEZAHkA2QA5AZkBOQCZAPkAWQG5AVkAuQAZAXkB2QEFAGUAxQAlAYUBJQCFAOUARQGlAUUApQAFAWUBxQENAG0AzQAtAY0BLQCNAO0ATQGtAU0ArQANAW0BzQEVAHUA1QA1AZUBNQCVAPUAVQG1AVUAtQAVAXUB1QEdAH0A3QA9AZ0BPQCdAP0AXQG9AV0AvQAdAX0B3QECAGIAwgAiAYIBIgCCAOIAQgGiAUIAogACAWIBwgEKAGoAygAqAYoBKgCKAOoASgGqAUoAqgAKAWoBygESAHIA0gAyAZIBMgCSAPIAUgGyAVIAsgASAXIB0gEaAHoA2gA6AZoBOgCaAPoAWgG6AVoAugAaAXoB2gEGAGYAxgAmAYYBJgCGAOYARgGmAUYApgAGAWYBxgEOAG4AzgAuAY4BLgCOAO4ATgGuAU4ArgAOAW4BzgEWAHYA1gA2AZYBNgCWAPYAVgG2AVYAtgAWAXYB1gEeAH4A3gA+AZ4BPgCeAP4AXgG+AV4AvgAeAX4B3gEDAGMAwwAjAYMBIwCDAOMAQwGjAUMAowADAWMBwwELAGsAywArAYsBKwCLAOsASwGrAUsAqwALAWsBywETAHMA0wAzAZMBMwCTAPMAUwGzAVMAswATAXMB0wEbAHsA2wA7AZsBOwCbAPsAWwG7AVsAuwAbAXsB2wEHAGcAxwAnAYcBJwCHAOcARwGnAUcApwAHAWcBxwEPAG8AzwAvAY8BLwCPAO8ATwGvAU8ArwAPAW8BzwEXAHcA1wA3AZcBNwCXAPcAVwG3AVcAtwAXAXcB1wEfAH8A3wA/AZ8BPwCfAP8AXwG/AV8AvwAfAX8B3wEAAIA/AAAAgGP6fz+/dVa8i+l/Pwpx1rx5zX8/584gvS+mfz86Xla9r3N/PxPyhb35NX8/Kq+g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PjB8dD9M1Jc+NnV1P3VqkT53Y3Y/PvqKPupGdz/ug4Q+hB94P5wPfD487Xg/TQxvPgmweT+C/mE+4md6P83mVD6+FHs/wsVHPpi2ez/zmzo+Z018P/VpLT4l2Xw/XDAgPstZfT+77xI+Vc99P6ioBT68OX4/c7fwPf2Yfj8EE9Y9Eu1+PzNluz35NX8/Kq+gPa9zfz8T8oU9L6Z/PzpeVj15zX8/584gPYvpfz8KcdY8Y/p/P791VjwAADAAYACQAMAAEABAAHAAoADQACAAUACAALAA4AAEADQAZACUAMQAFABEAHQApADUACQAVACEALQA5AAIADgAaACYAMgAGABIAHgAqADYACgAWACIALgA6AAMADwAbACcAMwAHABMAHwArADcACwAXACMALwA7AABADEAYQCRAMEAEQBBAHEAoQDRACEAUQCBALEA4QAFADUAZQCVAMUAFQBFAHUApQDVACUAVQCFALUA5QAJADkAaQCZAMkAGQBJAHkAqQDZACkAWQCJALkA6QANAD0AbQCdAM0AHQBNAH0ArQDdAC0AXQCNAL0A7QACADIAYgCSAMIAEgBCAHIAogDSACIAUgCCALIA4gAGADYAZgCWAMYAFgBGAHYApgDWACYAVgCGALYA5gAKADoAagCaAMoAGgBKAHoAqgDaACoAWgCKALoA6gAOAD4AbgCeAM4AHgBOAH4ArgDeAC4AXgCOAL4A7gADADMAYwCTAMMAEwBDAHMAowDTACMAUwCDALMA4wAHADcAZwCXAMcAFwBHAHcApwDXACcAVwCHALcA5wALADsAawCbAMsAGwBLAHsAqwDbACsAWwCLALsA6wAPAD8AbwCfAM8AHwBPAH8ArwDfAC8AXwCPAL8A7wDwAAAAiYiIOwEAAAAFADAAAwAQAAQABAAEAAEAQYytAQsGgFQAAIBFAEGirQELiQIYADAASABgAAgAIAA4AFAAaAAQACgAQABYAHAABAAcADQATABkAAwAJAA8AFQAbAAUACwARABcAHQAAQAZADEASQBhAAkAIQA5AFEAaQARACkAQQBZAHEABQAdADUATQBlAA0AJQA9AFUAbQAVAC0ARQBdAHUAAgAaADIASgBiAAoAIgA6AFIAagASACoAQgBaAHIABgAeADYATgBmAA4AJgA+AFYAbgAWAC4ARgBeAHYAAwAbADMASwBjAAsAIwA7AFMAawATACsAQwBbAHMABwAfADcATwBnAA8AJwA/AFcAbwAXAC8ARwBfAHcAeAAAAIiICDwCAAAABQAYAAMACAACAAQABAABAEG8rwELBqBWAACARQBB0q8BC40BDAAYACQAMAAEABAAHAAoADQACAAUACAALAA4AAEADQAZACUAMQAFABEAHQApADUACQAVACEALQA5AAIADgAaACYAMgAGABIAHgAqADYACgAWACIALgA6AAMADwAbACcAMwAHABMAHwArADcACwAXACMALwA7ADwAAACJiIg8AwAAAAUADAADAAQABAABAEH0sAELTdBXAACARQAAAAAAAMBYAACAWwAAPF4AAPRgAACoYwAAWGYAAARpAABsagAAKGsAAJxrAADoawAAIGwAAEBsAABYbAAAZGwAAAAAAAABAEGEtwELoCMBAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAA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";function e(A){try{if(A==b&&w)return new Uint8Array(w);var I=function(A){if(f(A))return function(A){try{for(var I=p(A),g=new Uint8Array(I.length),B=0;B<I.length;++B)g[B]=I.charCodeAt(B);return g}catch(A){throw new Error("Converting base64 string to bytes failed.")}}(A.slice(r.length))}(A);if(I)return I;throw"both async and sync fetching of the wasm failed"}catch(A){n(A)}}function x(I){for(;I.length>0;){var g=I.shift();if("function"!=typeof g){var B=g.func;"number"==typeof B?void 0===g.arg?q.get(B)():q.get(B)(g.arg):B(void 0===g.arg?null:g.arg)}else g(A)}}f(b)||(W=b,b=A.locateFile?A.locateFile(W,o):o+W);var v={mappings:{},buffers:[null,[],[]],printChar:function(A,I){var g=v.buffers[A];0===I||10===I?((1===A?G:R)(y(g,0)),g.length=0):g.push(I)},varargs:void 0,get:function(){return v.varargs+=4,h[v.varargs-4>>2]},getStr:function(A){return H(A)},get64:function(A,I){return A}},p="function"==typeof atob?atob:function(A){var I,g,B,Q,C,E,i="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",D="",o=0;A=A.replace(/[^A-Za-z0-9\\+\\/\\=]/g,"");do{I=i.indexOf(A.charAt(o++))<<2|(Q=i.indexOf(A.charAt(o++)))>>4,g=(15&Q)<<4|(C=i.indexOf(A.charAt(o++)))>>2,B=(3&C)<<6|(E=i.indexOf(A.charAt(o++))),D+=String.fromCharCode(I),64!==C&&(D+=String.fromCharCode(g)),64!==E&&(D+=String.fromCharCode(B))}while(o<A.length);return D};var T,O={b:function(A,I,g){k.copyWithin(A,I,I+g)},c:function(A){n("OOM")},a:function(A,I,g,B){for(var Q=0,C=0;C<g;C++){for(var E=h[I+8*C>>2],i=h[I+(8*C+4)>>2],D=0;D<i;D++)v.printChar(A,k[E+D]);Q+=i}return h[B>>2]=Q,0}},l=(function(){var I={a:O};function g(I,g){var B,Q=I.exports;A.asm=Q,B=A.asm.d.buffer,A.HEAP8=s=new Int8Array(B),A.HEAP16=new Int16Array(B),A.HEAP32=h=new Int32Array(B),A.HEAPU8=k=new Uint8Array(B),A.HEAPU16=new Uint16Array(B),A.HEAPU32=new Uint32Array(B),A.HEAPF32=new Float32Array(B),A.HEAPF64=new Float64Array(B),q=A.asm.e,function(I){if(d--,A.monitorRunDependencies&&A.monitorRunDependencies(d),0==d&&(null!==P&&(clearInterval(P),P=null),t)){var g=t;t=null,g()}}()}function Q(A){g(A.instance)}function C(A){return(w||"function"!=typeof fetch?Promise.resolve().then((function(){return e(b)})):fetch(b,{credentials:"same-origin"}).then((function(A){if(!A.ok)throw"failed to load wasm binary file at \'"+b+"\'";return A.arrayBuffer()})).catch((function(){return e(b)}))).then((function(A){return WebAssembly.instantiate(A,I)})).then(A,(function(A){R("failed to asynchronously prepare wasm: "+A),n(A)}))}if(d++,A.monitorRunDependencies&&A.monitorRunDependencies(d),A.instantiateWasm)try{return A.instantiateWasm(I,g)}catch(A){return R("Module.instantiateWasm callback failed with error: "+A),!1}(w||"function"!=typeof WebAssembly.instantiateStreaming||f(b)||"function"!=typeof fetch?C(Q):fetch(b,{credentials:"same-origin"}).then((function(A){return WebAssembly.instantiateStreaming(A,I).then(Q,(function(A){return R("wasm streaming compile failed: "+A),R("falling back to ArrayBuffer instantiation"),C(Q)}))}))).catch(B)}(),A.___wasm_call_ctors=function(){return(l=A.___wasm_call_ctors=A.asm.f).apply(null,arguments)}),X=(A._stopStream=function(){return(A._stopStream=A.asm.g).apply(null,arguments)},A._startStream=function(){return(A._startStream=A.asm.h).apply(null,arguments)},A._decode=function(){return(A._decode=A.asm.i).apply(null,arguments)},A._createBuffer=function(){return(A._createBuffer=A.asm.j).apply(null,arguments)},A._freeBuffer=function(){return(A._freeBuffer=A.asm.k).apply(null,arguments)},A._main=function(){return(A._main=A.asm.l).apply(null,arguments)},A.stackSave=function(){return(X=A.stackSave=A.asm.m).apply(null,arguments)}),Z=A.stackRestore=function(){return(Z=A.stackRestore=A.asm.n).apply(null,arguments)},V=A.stackAlloc=function(){return(V=A.stackAlloc=A.asm.o).apply(null,arguments)};function z(A){this.name="ExitStatus",this.message="Program terminated with exit("+A+")",this.status=A}function j(I){function B(){T||(T=!0,A.calledRun=!0,S||(x(K),x(c),g(A),A.onRuntimeInitialized&&A.onRuntimeInitialized(),u&&function(I){var g,B=A._main,Q=(I=I||[]).length+1,C=V(4*(Q+1));h[C>>2]=L(i);for(var E=1;E<Q;E++)h[(C>>2)+E]=L(I[E-1]);h[(C>>2)+Q]=0;try{g=B(Q,C),F&&0===g||(F||(A.onExit&&A.onExit(g),S=!0),D(g,new z(g)))}catch(A){if(A instanceof z)return;if("unwind"==A)return void(F=!0);var o=A;A&&"object"==typeof A&&A.stack&&(o=[A,A.stack]),R("exception thrown: "+o),D(1,A)}}(I),function(){if(A.postRun)for("function"==typeof A.postRun&&(A.postRun=[A.postRun]);A.postRun.length;)I=A.postRun.shift(),Y.unshift(I);var I;x(Y)}()))}I=I||E,d>0||(function(){if(A.preRun)for("function"==typeof A.preRun&&(A.preRun=[A.preRun]);A.preRun.length;)I=A.preRun.shift(),M.unshift(I);var I;x(M)}(),d>0||(A.setStatus?(A.setStatus("Running..."),setTimeout((function(){setTimeout((function(){A.setStatus("")}),1),B()}),1)):B()))}if(A.cwrap=function(A,I,g,B){var Q=(g=g||[]).every((function(A){return"number"===A}));return"string"!==I&&Q&&!B?U(A):function(){return a(A,I,g,arguments)}},t=function A(){T||j(),T||(t=A)},A.run=j,A.preInit)for("function"==typeof A.preInit&&(A.preInit=[A.preInit]);A.preInit.length>0;)A.preInit.pop()();var u=!0;return A.noInitialRun&&(u=!1),F=!0,j(),A.ready});A.exports=g}},I={};function g(B){var Q=I[B];if(void 0!==Q)return Q.exports;var C=I[B]={exports:{}};return A[B](C,C.exports,g),C.exports}g.n=A=>{var I=A&&A.__esModule?()=>A.default:()=>A;return g.d(I,{a:I}),I},g.d=(A,I)=>{for(var B in I)g.o(I,B)&&!g.o(A,B)&&Object.defineProperty(A,B,{enumerable:!0,get:I[B]})},g.o=(A,I)=>Object.prototype.hasOwnProperty.call(A,I),(()=>{"use strict";var A,I=g(305),B=g.n(I),Q=0,C=0,E=0,i=0,D=0,o=0;!async function(){A=await B()(),self.addEventListener("message",(async function(I){var g=I.data;switch(g.type){case"startStream":o=g.decodedSamplesPerFrame,D=o*g.channelCount,A._startStream(g.sampleRateHz,g.channelCount);break;case"stopStream":A._stopStream();break;case"decode":{const I=g.startTimestamp,B=function(I){const g=I.byteLength;return 0!=Q&&C<g&&(A._freeBuffer(Q),Q=0,C=0),0==Q&&(Q=A._createBuffer(I.BYTES_PER_ELEMENT*g),C=g),A.HEAPU8.set(I,Q),Q}(new Uint8Array(g.inputData)),w=(0!=E&&i<D&&(A._freeBuffer(E),E=0,i=0),0==E&&(E=A._createBuffer(Float32Array.BYTES_PER_ELEMENT*D),i=D),E),F=new Float32Array(A.HEAPF32.buffer,w,D),G=A._decode(B,g.inputData.byteLength,w,o),R=F.buffer.slice(w,w+D*F.BYTES_PER_ELEMENT);postMessage({type:"decodeDone",startTimestamp:I,outputData:R,samplesDecoded:G},[R]);break}case"release":0!=Q&&(A._freeBuffer(Q),Q=0,C=0),0!=E&&(A._freeBuffer(E),E=0,i=0),A._stopStream()}})),postMessage({type:"decoderReady"})}()})()})();',"Worker",void 0,void 0)}},614:A=>{A.exports=function(A,I,g,e){var B=self||window;try{try{var i;try{i=new B.Blob([A])}catch(I){(i=new(B.BlobBuilder||B.WebKitBlobBuilder||B.MozBlobBuilder||B.MSBlobBuilder)).append(A),i=i.getBlob()}var t=B.URL||B.webkitURL,Q=t.createObjectURL(i),C=new B[I](Q,g);return t.revokeObjectURL(Q),C}catch(e){return new B[I]("data:application/javascript,".concat(encodeURIComponent(A)),g)}}catch(A){if(!e)throw Error("Inline worker is not supported");return new B[I](e,g)}}}},I={};function g(e){var B=I[e];if(void 0!==B)return B.exports;var i=I[e]={exports:{}};return A[e].call(i.exports,i,i.exports,g),i.exports}return g.n=A=>{var I=A&&A.__esModule?()=>A.default:()=>A;return g.d(I,{a:I}),I},g.d=(A,I)=>{for(var e in I)g.o(I,e)&&!g.o(A,e)&&Object.defineProperty(A,e,{enumerable:!0,get:I[e]})},g.o=(A,I)=>Object.prototype.hasOwnProperty.call(A,I),g.r=A=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(A,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(A,"__esModule",{value:!0})},g(114)})()},700:()=>{}},I={};function g(e){var B=I[e];if(void 0!==B)return B.exports;var i=I[e]={exports:{}};return A[e].call(i.exports,i,i.exports,g),i.exports}return g.g=function(){if("object"==typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(A){if("object"==typeof window)return window}}(),g(14)})()}));

/***/ }),

/***/ "./node_modules/react-dom/cjs/react-dom.development.js":
/*!*************************************************************!*\
  !*** ./node_modules/react-dom/cjs/react-dom.development.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/** @license React v17.0.2
 * react-dom.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



if (true) {
  (function() {
'use strict';

var React = __webpack_require__(/*! react */ "./node_modules/react/index.js");
var _assign = __webpack_require__(/*! object-assign */ "./node_modules/object-assign/index.js");
var Scheduler = __webpack_require__(/*! scheduler */ "./node_modules/scheduler/index.js");
var tracing = __webpack_require__(/*! scheduler/tracing */ "./node_modules/scheduler/tracing.js");

var ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;

// by calls to these methods by a Babel plugin.
//
// In PROD (or in packages without access to React internals),
// they are left as they are instead.

function warn(format) {
  {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    printWarning('warn', format, args);
  }
}
function error(format) {
  {
    for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
      args[_key2 - 1] = arguments[_key2];
    }

    printWarning('error', format, args);
  }
}

function printWarning(level, format, args) {
  // When changing this logic, you might want to also
  // update consoleWithStackDev.www.js as well.
  {
    var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
    var stack = ReactDebugCurrentFrame.getStackAddendum();

    if (stack !== '') {
      format += '%s';
      args = args.concat([stack]);
    }

    var argsWithFormat = args.map(function (item) {
      return '' + item;
    }); // Careful: RN currently depends on this prefix

    argsWithFormat.unshift('Warning: ' + format); // We intentionally don't use spread (or .apply) directly because it
    // breaks IE9: https://github.com/facebook/react/issues/13610
    // eslint-disable-next-line react-internal/no-production-logging

    Function.prototype.apply.call(console[level], console, argsWithFormat);
  }
}

if (!React) {
  {
    throw Error( "ReactDOM was loaded before React. Make sure you load the React package before loading ReactDOM." );
  }
}

var FunctionComponent = 0;
var ClassComponent = 1;
var IndeterminateComponent = 2; // Before we know whether it is function or class

var HostRoot = 3; // Root of a host tree. Could be nested inside another node.

var HostPortal = 4; // A subtree. Could be an entry point to a different renderer.

var HostComponent = 5;
var HostText = 6;
var Fragment = 7;
var Mode = 8;
var ContextConsumer = 9;
var ContextProvider = 10;
var ForwardRef = 11;
var Profiler = 12;
var SuspenseComponent = 13;
var MemoComponent = 14;
var SimpleMemoComponent = 15;
var LazyComponent = 16;
var IncompleteClassComponent = 17;
var DehydratedFragment = 18;
var SuspenseListComponent = 19;
var FundamentalComponent = 20;
var ScopeComponent = 21;
var Block = 22;
var OffscreenComponent = 23;
var LegacyHiddenComponent = 24;

// Filter certain DOM attributes (e.g. src, href) if their values are empty strings.

var enableProfilerTimer = true; // Record durations for commit and passive effects phases.

var enableFundamentalAPI = false; // Experimental Scope support.
var enableNewReconciler = false; // Errors that are thrown while unmounting (or after in the case of passive effects)
var warnAboutStringRefs = false;

var allNativeEvents = new Set();
/**
 * Mapping from registration name to event name
 */


var registrationNameDependencies = {};
/**
 * Mapping from lowercase registration names to the properly cased version,
 * used to warn in the case of missing event handlers. Available
 * only in true.
 * @type {Object}
 */

var possibleRegistrationNames =  {} ; // Trust the developer to only use possibleRegistrationNames in true

function registerTwoPhaseEvent(registrationName, dependencies) {
  registerDirectEvent(registrationName, dependencies);
  registerDirectEvent(registrationName + 'Capture', dependencies);
}
function registerDirectEvent(registrationName, dependencies) {
  {
    if (registrationNameDependencies[registrationName]) {
      error('EventRegistry: More than one plugin attempted to publish the same ' + 'registration name, `%s`.', registrationName);
    }
  }

  registrationNameDependencies[registrationName] = dependencies;

  {
    var lowerCasedName = registrationName.toLowerCase();
    possibleRegistrationNames[lowerCasedName] = registrationName;

    if (registrationName === 'onDoubleClick') {
      possibleRegistrationNames.ondblclick = registrationName;
    }
  }

  for (var i = 0; i < dependencies.length; i++) {
    allNativeEvents.add(dependencies[i]);
  }
}

var canUseDOM = !!(typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined');

// A reserved attribute.
// It is handled by React separately and shouldn't be written to the DOM.
var RESERVED = 0; // A simple string attribute.
// Attributes that aren't in the filter are presumed to have this type.

var STRING = 1; // A string attribute that accepts booleans in React. In HTML, these are called
// "enumerated" attributes with "true" and "false" as possible values.
// When true, it should be set to a "true" string.
// When false, it should be set to a "false" string.

var BOOLEANISH_STRING = 2; // A real boolean attribute.
// When true, it should be present (set either to an empty string or its name).
// When false, it should be omitted.

var BOOLEAN = 3; // An attribute that can be used as a flag as well as with a value.
// When true, it should be present (set either to an empty string or its name).
// When false, it should be omitted.
// For any other value, should be present with that value.

var OVERLOADED_BOOLEAN = 4; // An attribute that must be numeric or parse as a numeric.
// When falsy, it should be removed.

var NUMERIC = 5; // An attribute that must be positive numeric or parse as a positive numeric.
// When falsy, it should be removed.

var POSITIVE_NUMERIC = 6;

/* eslint-disable max-len */
var ATTRIBUTE_NAME_START_CHAR = ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD";
/* eslint-enable max-len */

var ATTRIBUTE_NAME_CHAR = ATTRIBUTE_NAME_START_CHAR + "\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040";
var ROOT_ATTRIBUTE_NAME = 'data-reactroot';
var VALID_ATTRIBUTE_NAME_REGEX = new RegExp('^[' + ATTRIBUTE_NAME_START_CHAR + '][' + ATTRIBUTE_NAME_CHAR + ']*$');
var hasOwnProperty = Object.prototype.hasOwnProperty;
var illegalAttributeNameCache = {};
var validatedAttributeNameCache = {};
function isAttributeNameSafe(attributeName) {
  if (hasOwnProperty.call(validatedAttributeNameCache, attributeName)) {
    return true;
  }

  if (hasOwnProperty.call(illegalAttributeNameCache, attributeName)) {
    return false;
  }

  if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName)) {
    validatedAttributeNameCache[attributeName] = true;
    return true;
  }

  illegalAttributeNameCache[attributeName] = true;

  {
    error('Invalid attribute name: `%s`', attributeName);
  }

  return false;
}
function shouldIgnoreAttribute(name, propertyInfo, isCustomComponentTag) {
  if (propertyInfo !== null) {
    return propertyInfo.type === RESERVED;
  }

  if (isCustomComponentTag) {
    return false;
  }

  if (name.length > 2 && (name[0] === 'o' || name[0] === 'O') && (name[1] === 'n' || name[1] === 'N')) {
    return true;
  }

  return false;
}
function shouldRemoveAttributeWithWarning(name, value, propertyInfo, isCustomComponentTag) {
  if (propertyInfo !== null && propertyInfo.type === RESERVED) {
    return false;
  }

  switch (typeof value) {
    case 'function': // $FlowIssue symbol is perfectly valid here

    case 'symbol':
      // eslint-disable-line
      return true;

    case 'boolean':
      {
        if (isCustomComponentTag) {
          return false;
        }

        if (propertyInfo !== null) {
          return !propertyInfo.acceptsBooleans;
        } else {
          var prefix = name.toLowerCase().slice(0, 5);
          return prefix !== 'data-' && prefix !== 'aria-';
        }
      }

    default:
      return false;
  }
}
function shouldRemoveAttribute(name, value, propertyInfo, isCustomComponentTag) {
  if (value === null || typeof value === 'undefined') {
    return true;
  }

  if (shouldRemoveAttributeWithWarning(name, value, propertyInfo, isCustomComponentTag)) {
    return true;
  }

  if (isCustomComponentTag) {
    return false;
  }

  if (propertyInfo !== null) {

    switch (propertyInfo.type) {
      case BOOLEAN:
        return !value;

      case OVERLOADED_BOOLEAN:
        return value === false;

      case NUMERIC:
        return isNaN(value);

      case POSITIVE_NUMERIC:
        return isNaN(value) || value < 1;
    }
  }

  return false;
}
function getPropertyInfo(name) {
  return properties.hasOwnProperty(name) ? properties[name] : null;
}

function PropertyInfoRecord(name, type, mustUseProperty, attributeName, attributeNamespace, sanitizeURL, removeEmptyString) {
  this.acceptsBooleans = type === BOOLEANISH_STRING || type === BOOLEAN || type === OVERLOADED_BOOLEAN;
  this.attributeName = attributeName;
  this.attributeNamespace = attributeNamespace;
  this.mustUseProperty = mustUseProperty;
  this.propertyName = name;
  this.type = type;
  this.sanitizeURL = sanitizeURL;
  this.removeEmptyString = removeEmptyString;
} // When adding attributes to this list, be sure to also add them to
// the `possibleStandardNames` module to ensure casing and incorrect
// name warnings.


var properties = {}; // These props are reserved by React. They shouldn't be written to the DOM.

var reservedProps = ['children', 'dangerouslySetInnerHTML', // TODO: This prevents the assignment of defaultValue to regular
// elements (not just inputs). Now that ReactDOMInput assigns to the
// defaultValue property -- do we need this?
'defaultValue', 'defaultChecked', 'innerHTML', 'suppressContentEditableWarning', 'suppressHydrationWarning', 'style'];
reservedProps.forEach(function (name) {
  properties[name] = new PropertyInfoRecord(name, RESERVED, false, // mustUseProperty
  name, // attributeName
  null, // attributeNamespace
  false, // sanitizeURL
  false);
}); // A few React string attributes have a different name.
// This is a mapping from React prop names to the attribute names.

[['acceptCharset', 'accept-charset'], ['className', 'class'], ['htmlFor', 'for'], ['httpEquiv', 'http-equiv']].forEach(function (_ref) {
  var name = _ref[0],
      attributeName = _ref[1];
  properties[name] = new PropertyInfoRecord(name, STRING, false, // mustUseProperty
  attributeName, // attributeName
  null, // attributeNamespace
  false, // sanitizeURL
  false);
}); // These are "enumerated" HTML attributes that accept "true" and "false".
// In React, we let users pass `true` and `false` even though technically
// these aren't boolean attributes (they are coerced to strings).

['contentEditable', 'draggable', 'spellCheck', 'value'].forEach(function (name) {
  properties[name] = new PropertyInfoRecord(name, BOOLEANISH_STRING, false, // mustUseProperty
  name.toLowerCase(), // attributeName
  null, // attributeNamespace
  false, // sanitizeURL
  false);
}); // These are "enumerated" SVG attributes that accept "true" and "false".
// In React, we let users pass `true` and `false` even though technically
// these aren't boolean attributes (they are coerced to strings).
// Since these are SVG attributes, their attribute names are case-sensitive.

['autoReverse', 'externalResourcesRequired', 'focusable', 'preserveAlpha'].forEach(function (name) {
  properties[name] = new PropertyInfoRecord(name, BOOLEANISH_STRING, false, // mustUseProperty
  name, // attributeName
  null, // attributeNamespace
  false, // sanitizeURL
  false);
}); // These are HTML boolean attributes.

['allowFullScreen', 'async', // Note: there is a special case that prevents it from being written to the DOM
// on the client side because the browsers are inconsistent. Instead we call focus().
'autoFocus', 'autoPlay', 'controls', 'default', 'defer', 'disabled', 'disablePictureInPicture', 'disableRemotePlayback', 'formNoValidate', 'hidden', 'loop', 'noModule', 'noValidate', 'open', 'playsInline', 'readOnly', 'required', 'reversed', 'scoped', 'seamless', // Microdata
'itemScope'].forEach(function (name) {
  properties[name] = new PropertyInfoRecord(name, BOOLEAN, false, // mustUseProperty
  name.toLowerCase(), // attributeName
  null, // attributeNamespace
  false, // sanitizeURL
  false);
}); // These are the few React props that we set as DOM properties
// rather than attributes. These are all booleans.

['checked', // Note: `option.selected` is not updated if `select.multiple` is
// disabled with `removeAttribute`. We have special logic for handling this.
'multiple', 'muted', 'selected' // NOTE: if you add a camelCased prop to this list,
// you'll need to set attributeName to name.toLowerCase()
// instead in the assignment below.
].forEach(function (name) {
  properties[name] = new PropertyInfoRecord(name, BOOLEAN, true, // mustUseProperty
  name, // attributeName
  null, // attributeNamespace
  false, // sanitizeURL
  false);
}); // These are HTML attributes that are "overloaded booleans": they behave like
// booleans, but can also accept a string value.

['capture', 'download' // NOTE: if you add a camelCased prop to this list,
// you'll need to set attributeName to name.toLowerCase()
// instead in the assignment below.
].forEach(function (name) {
  properties[name] = new PropertyInfoRecord(name, OVERLOADED_BOOLEAN, false, // mustUseProperty
  name, // attributeName
  null, // attributeNamespace
  false, // sanitizeURL
  false);
}); // These are HTML attributes that must be positive numbers.

['cols', 'rows', 'size', 'span' // NOTE: if you add a camelCased prop to this list,
// you'll need to set attributeName to name.toLowerCase()
// instead in the assignment below.
].forEach(function (name) {
  properties[name] = new PropertyInfoRecord(name, POSITIVE_NUMERIC, false, // mustUseProperty
  name, // attributeName
  null, // attributeNamespace
  false, // sanitizeURL
  false);
}); // These are HTML attributes that must be numbers.

['rowSpan', 'start'].forEach(function (name) {
  properties[name] = new PropertyInfoRecord(name, NUMERIC, false, // mustUseProperty
  name.toLowerCase(), // attributeName
  null, // attributeNamespace
  false, // sanitizeURL
  false);
});
var CAMELIZE = /[\-\:]([a-z])/g;

var capitalize = function (token) {
  return token[1].toUpperCase();
}; // This is a list of all SVG attributes that need special casing, namespacing,
// or boolean value assignment. Regular attributes that just accept strings
// and have the same names are omitted, just like in the HTML attribute filter.
// Some of these attributes can be hard to find. This list was created by
// scraping the MDN documentation.


['accent-height', 'alignment-baseline', 'arabic-form', 'baseline-shift', 'cap-height', 'clip-path', 'clip-rule', 'color-interpolation', 'color-interpolation-filters', 'color-profile', 'color-rendering', 'dominant-baseline', 'enable-background', 'fill-opacity', 'fill-rule', 'flood-color', 'flood-opacity', 'font-family', 'font-size', 'font-size-adjust', 'font-stretch', 'font-style', 'font-variant', 'font-weight', 'glyph-name', 'glyph-orientation-horizontal', 'glyph-orientation-vertical', 'horiz-adv-x', 'horiz-origin-x', 'image-rendering', 'letter-spacing', 'lighting-color', 'marker-end', 'marker-mid', 'marker-start', 'overline-position', 'overline-thickness', 'paint-order', 'panose-1', 'pointer-events', 'rendering-intent', 'shape-rendering', 'stop-color', 'stop-opacity', 'strikethrough-position', 'strikethrough-thickness', 'stroke-dasharray', 'stroke-dashoffset', 'stroke-linecap', 'stroke-linejoin', 'stroke-miterlimit', 'stroke-opacity', 'stroke-width', 'text-anchor', 'text-decoration', 'text-rendering', 'underline-position', 'underline-thickness', 'unicode-bidi', 'unicode-range', 'units-per-em', 'v-alphabetic', 'v-hanging', 'v-ideographic', 'v-mathematical', 'vector-effect', 'vert-adv-y', 'vert-origin-x', 'vert-origin-y', 'word-spacing', 'writing-mode', 'xmlns:xlink', 'x-height' // NOTE: if you add a camelCased prop to this list,
// you'll need to set attributeName to name.toLowerCase()
// instead in the assignment below.
].forEach(function (attributeName) {
  var name = attributeName.replace(CAMELIZE, capitalize);
  properties[name] = new PropertyInfoRecord(name, STRING, false, // mustUseProperty
  attributeName, null, // attributeNamespace
  false, // sanitizeURL
  false);
}); // String SVG attributes with the xlink namespace.

['xlink:actuate', 'xlink:arcrole', 'xlink:role', 'xlink:show', 'xlink:title', 'xlink:type' // NOTE: if you add a camelCased prop to this list,
// you'll need to set attributeName to name.toLowerCase()
// instead in the assignment below.
].forEach(function (attributeName) {
  var name = attributeName.replace(CAMELIZE, capitalize);
  properties[name] = new PropertyInfoRecord(name, STRING, false, // mustUseProperty
  attributeName, 'http://www.w3.org/1999/xlink', false, // sanitizeURL
  false);
}); // String SVG attributes with the xml namespace.

['xml:base', 'xml:lang', 'xml:space' // NOTE: if you add a camelCased prop to this list,
// you'll need to set attributeName to name.toLowerCase()
// instead in the assignment below.
].forEach(function (attributeName) {
  var name = attributeName.replace(CAMELIZE, capitalize);
  properties[name] = new PropertyInfoRecord(name, STRING, false, // mustUseProperty
  attributeName, 'http://www.w3.org/XML/1998/namespace', false, // sanitizeURL
  false);
}); // These attribute exists both in HTML and SVG.
// The attribute name is case-sensitive in SVG so we can't just use
// the React name like we do for attributes that exist only in HTML.

['tabIndex', 'crossOrigin'].forEach(function (attributeName) {
  properties[attributeName] = new PropertyInfoRecord(attributeName, STRING, false, // mustUseProperty
  attributeName.toLowerCase(), // attributeName
  null, // attributeNamespace
  false, // sanitizeURL
  false);
}); // These attributes accept URLs. These must not allow javascript: URLS.
// These will also need to accept Trusted Types object in the future.

var xlinkHref = 'xlinkHref';
properties[xlinkHref] = new PropertyInfoRecord('xlinkHref', STRING, false, // mustUseProperty
'xlink:href', 'http://www.w3.org/1999/xlink', true, // sanitizeURL
false);
['src', 'href', 'action', 'formAction'].forEach(function (attributeName) {
  properties[attributeName] = new PropertyInfoRecord(attributeName, STRING, false, // mustUseProperty
  attributeName.toLowerCase(), // attributeName
  null, // attributeNamespace
  true, // sanitizeURL
  true);
});

// and any newline or tab are filtered out as if they're not part of the URL.
// https://url.spec.whatwg.org/#url-parsing
// Tab or newline are defined as \r\n\t:
// https://infra.spec.whatwg.org/#ascii-tab-or-newline
// A C0 control is a code point in the range \u0000 NULL to \u001F
// INFORMATION SEPARATOR ONE, inclusive:
// https://infra.spec.whatwg.org/#c0-control-or-space

/* eslint-disable max-len */

var isJavaScriptProtocol = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*\:/i;
var didWarn = false;

function sanitizeURL(url) {
  {
    if (!didWarn && isJavaScriptProtocol.test(url)) {
      didWarn = true;

      error('A future version of React will block javascript: URLs as a security precaution. ' + 'Use event handlers instead if you can. If you need to generate unsafe HTML try ' + 'using dangerouslySetInnerHTML instead. React was passed %s.', JSON.stringify(url));
    }
  }
}

/**
 * Get the value for a property on a node. Only used in DEV for SSR validation.
 * The "expected" argument is used as a hint of what the expected value is.
 * Some properties have multiple equivalent values.
 */
function getValueForProperty(node, name, expected, propertyInfo) {
  {
    if (propertyInfo.mustUseProperty) {
      var propertyName = propertyInfo.propertyName;
      return node[propertyName];
    } else {
      if ( propertyInfo.sanitizeURL) {
        // If we haven't fully disabled javascript: URLs, and if
        // the hydration is successful of a javascript: URL, we
        // still want to warn on the client.
        sanitizeURL('' + expected);
      }

      var attributeName = propertyInfo.attributeName;
      var stringValue = null;

      if (propertyInfo.type === OVERLOADED_BOOLEAN) {
        if (node.hasAttribute(attributeName)) {
          var value = node.getAttribute(attributeName);

          if (value === '') {
            return true;
          }

          if (shouldRemoveAttribute(name, expected, propertyInfo, false)) {
            return value;
          }

          if (value === '' + expected) {
            return expected;
          }

          return value;
        }
      } else if (node.hasAttribute(attributeName)) {
        if (shouldRemoveAttribute(name, expected, propertyInfo, false)) {
          // We had an attribute but shouldn't have had one, so read it
          // for the error message.
          return node.getAttribute(attributeName);
        }

        if (propertyInfo.type === BOOLEAN) {
          // If this was a boolean, it doesn't matter what the value is
          // the fact that we have it is the same as the expected.
          return expected;
        } // Even if this property uses a namespace we use getAttribute
        // because we assume its namespaced name is the same as our config.
        // To use getAttributeNS we need the local name which we don't have
        // in our config atm.


        stringValue = node.getAttribute(attributeName);
      }

      if (shouldRemoveAttribute(name, expected, propertyInfo, false)) {
        return stringValue === null ? expected : stringValue;
      } else if (stringValue === '' + expected) {
        return expected;
      } else {
        return stringValue;
      }
    }
  }
}
/**
 * Get the value for a attribute on a node. Only used in DEV for SSR validation.
 * The third argument is used as a hint of what the expected value is. Some
 * attributes have multiple equivalent values.
 */

function getValueForAttribute(node, name, expected) {
  {
    if (!isAttributeNameSafe(name)) {
      return;
    } // If the object is an opaque reference ID, it's expected that
    // the next prop is different than the server value, so just return
    // expected


    if (isOpaqueHydratingObject(expected)) {
      return expected;
    }

    if (!node.hasAttribute(name)) {
      return expected === undefined ? undefined : null;
    }

    var value = node.getAttribute(name);

    if (value === '' + expected) {
      return expected;
    }

    return value;
  }
}
/**
 * Sets the value for a property on a node.
 *
 * @param {DOMElement} node
 * @param {string} name
 * @param {*} value
 */

function setValueForProperty(node, name, value, isCustomComponentTag) {
  var propertyInfo = getPropertyInfo(name);

  if (shouldIgnoreAttribute(name, propertyInfo, isCustomComponentTag)) {
    return;
  }

  if (shouldRemoveAttribute(name, value, propertyInfo, isCustomComponentTag)) {
    value = null;
  } // If the prop isn't in the special list, treat it as a simple attribute.


  if (isCustomComponentTag || propertyInfo === null) {
    if (isAttributeNameSafe(name)) {
      var _attributeName = name;

      if (value === null) {
        node.removeAttribute(_attributeName);
      } else {
        node.setAttribute(_attributeName,  '' + value);
      }
    }

    return;
  }

  var mustUseProperty = propertyInfo.mustUseProperty;

  if (mustUseProperty) {
    var propertyName = propertyInfo.propertyName;

    if (value === null) {
      var type = propertyInfo.type;
      node[propertyName] = type === BOOLEAN ? false : '';
    } else {
      // Contrary to `setAttribute`, object properties are properly
      // `toString`ed by IE8/9.
      node[propertyName] = value;
    }

    return;
  } // The rest are treated as attributes with special cases.


  var attributeName = propertyInfo.attributeName,
      attributeNamespace = propertyInfo.attributeNamespace;

  if (value === null) {
    node.removeAttribute(attributeName);
  } else {
    var _type = propertyInfo.type;
    var attributeValue;

    if (_type === BOOLEAN || _type === OVERLOADED_BOOLEAN && value === true) {
      // If attribute type is boolean, we know for sure it won't be an execution sink
      // and we won't require Trusted Type here.
      attributeValue = '';
    } else {
      // `setAttribute` with objects becomes only `[object]` in IE8/9,
      // ('' + value) makes it output the correct toString()-value.
      {
        attributeValue = '' + value;
      }

      if (propertyInfo.sanitizeURL) {
        sanitizeURL(attributeValue.toString());
      }
    }

    if (attributeNamespace) {
      node.setAttributeNS(attributeNamespace, attributeName, attributeValue);
    } else {
      node.setAttribute(attributeName, attributeValue);
    }
  }
}

// ATTENTION
// When adding new symbols to this file,
// Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'
// The Symbol used to tag the ReactElement-like types. If there is no native Symbol
// nor polyfill, then a plain number is used for performance.
var REACT_ELEMENT_TYPE = 0xeac7;
var REACT_PORTAL_TYPE = 0xeaca;
var REACT_FRAGMENT_TYPE = 0xeacb;
var REACT_STRICT_MODE_TYPE = 0xeacc;
var REACT_PROFILER_TYPE = 0xead2;
var REACT_PROVIDER_TYPE = 0xeacd;
var REACT_CONTEXT_TYPE = 0xeace;
var REACT_FORWARD_REF_TYPE = 0xead0;
var REACT_SUSPENSE_TYPE = 0xead1;
var REACT_SUSPENSE_LIST_TYPE = 0xead8;
var REACT_MEMO_TYPE = 0xead3;
var REACT_LAZY_TYPE = 0xead4;
var REACT_BLOCK_TYPE = 0xead9;
var REACT_SERVER_BLOCK_TYPE = 0xeada;
var REACT_FUNDAMENTAL_TYPE = 0xead5;
var REACT_SCOPE_TYPE = 0xead7;
var REACT_OPAQUE_ID_TYPE = 0xeae0;
var REACT_DEBUG_TRACING_MODE_TYPE = 0xeae1;
var REACT_OFFSCREEN_TYPE = 0xeae2;
var REACT_LEGACY_HIDDEN_TYPE = 0xeae3;

if (typeof Symbol === 'function' && Symbol.for) {
  var symbolFor = Symbol.for;
  REACT_ELEMENT_TYPE = symbolFor('react.element');
  REACT_PORTAL_TYPE = symbolFor('react.portal');
  REACT_FRAGMENT_TYPE = symbolFor('react.fragment');
  REACT_STRICT_MODE_TYPE = symbolFor('react.strict_mode');
  REACT_PROFILER_TYPE = symbolFor('react.profiler');
  REACT_PROVIDER_TYPE = symbolFor('react.provider');
  REACT_CONTEXT_TYPE = symbolFor('react.context');
  REACT_FORWARD_REF_TYPE = symbolFor('react.forward_ref');
  REACT_SUSPENSE_TYPE = symbolFor('react.suspense');
  REACT_SUSPENSE_LIST_TYPE = symbolFor('react.suspense_list');
  REACT_MEMO_TYPE = symbolFor('react.memo');
  REACT_LAZY_TYPE = symbolFor('react.lazy');
  REACT_BLOCK_TYPE = symbolFor('react.block');
  REACT_SERVER_BLOCK_TYPE = symbolFor('react.server.block');
  REACT_FUNDAMENTAL_TYPE = symbolFor('react.fundamental');
  REACT_SCOPE_TYPE = symbolFor('react.scope');
  REACT_OPAQUE_ID_TYPE = symbolFor('react.opaque.id');
  REACT_DEBUG_TRACING_MODE_TYPE = symbolFor('react.debug_trace_mode');
  REACT_OFFSCREEN_TYPE = symbolFor('react.offscreen');
  REACT_LEGACY_HIDDEN_TYPE = symbolFor('react.legacy_hidden');
}

var MAYBE_ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
var FAUX_ITERATOR_SYMBOL = '@@iterator';
function getIteratorFn(maybeIterable) {
  if (maybeIterable === null || typeof maybeIterable !== 'object') {
    return null;
  }

  var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];

  if (typeof maybeIterator === 'function') {
    return maybeIterator;
  }

  return null;
}

// Helpers to patch console.logs to avoid logging during side-effect free
// replaying on render function. This currently only patches the object
// lazily which won't cover if the log function was extracted eagerly.
// We could also eagerly patch the method.
var disabledDepth = 0;
var prevLog;
var prevInfo;
var prevWarn;
var prevError;
var prevGroup;
var prevGroupCollapsed;
var prevGroupEnd;

function disabledLog() {}

disabledLog.__reactDisabledLog = true;
function disableLogs() {
  {
    if (disabledDepth === 0) {
      /* eslint-disable react-internal/no-production-logging */
      prevLog = console.log;
      prevInfo = console.info;
      prevWarn = console.warn;
      prevError = console.error;
      prevGroup = console.group;
      prevGroupCollapsed = console.groupCollapsed;
      prevGroupEnd = console.groupEnd; // https://github.com/facebook/react/issues/19099

      var props = {
        configurable: true,
        enumerable: true,
        value: disabledLog,
        writable: true
      }; // $FlowFixMe Flow thinks console is immutable.

      Object.defineProperties(console, {
        info: props,
        log: props,
        warn: props,
        error: props,
        group: props,
        groupCollapsed: props,
        groupEnd: props
      });
      /* eslint-enable react-internal/no-production-logging */
    }

    disabledDepth++;
  }
}
function reenableLogs() {
  {
    disabledDepth--;

    if (disabledDepth === 0) {
      /* eslint-disable react-internal/no-production-logging */
      var props = {
        configurable: true,
        enumerable: true,
        writable: true
      }; // $FlowFixMe Flow thinks console is immutable.

      Object.defineProperties(console, {
        log: _assign({}, props, {
          value: prevLog
        }),
        info: _assign({}, props, {
          value: prevInfo
        }),
        warn: _assign({}, props, {
          value: prevWarn
        }),
        error: _assign({}, props, {
          value: prevError
        }),
        group: _assign({}, props, {
          value: prevGroup
        }),
        groupCollapsed: _assign({}, props, {
          value: prevGroupCollapsed
        }),
        groupEnd: _assign({}, props, {
          value: prevGroupEnd
        })
      });
      /* eslint-enable react-internal/no-production-logging */
    }

    if (disabledDepth < 0) {
      error('disabledDepth fell below zero. ' + 'This is a bug in React. Please file an issue.');
    }
  }
}

var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;
var prefix;
function describeBuiltInComponentFrame(name, source, ownerFn) {
  {
    if (prefix === undefined) {
      // Extract the VM specific prefix used by each line.
      try {
        throw Error();
      } catch (x) {
        var match = x.stack.trim().match(/\n( *(at )?)/);
        prefix = match && match[1] || '';
      }
    } // We use the prefix to ensure our stacks line up with native stack frames.


    return '\n' + prefix + name;
  }
}
var reentry = false;
var componentFrameCache;

{
  var PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map;
  componentFrameCache = new PossiblyWeakMap();
}

function describeNativeComponentFrame(fn, construct) {
  // If something asked for a stack inside a fake render, it should get ignored.
  if (!fn || reentry) {
    return '';
  }

  {
    var frame = componentFrameCache.get(fn);

    if (frame !== undefined) {
      return frame;
    }
  }

  var control;
  reentry = true;
  var previousPrepareStackTrace = Error.prepareStackTrace; // $FlowFixMe It does accept undefined.

  Error.prepareStackTrace = undefined;
  var previousDispatcher;

  {
    previousDispatcher = ReactCurrentDispatcher.current; // Set the dispatcher in DEV because this might be call in the render function
    // for warnings.

    ReactCurrentDispatcher.current = null;
    disableLogs();
  }

  try {
    // This should throw.
    if (construct) {
      // Something should be setting the props in the constructor.
      var Fake = function () {
        throw Error();
      }; // $FlowFixMe


      Object.defineProperty(Fake.prototype, 'props', {
        set: function () {
          // We use a throwing setter instead of frozen or non-writable props
          // because that won't throw in a non-strict mode function.
          throw Error();
        }
      });

      if (typeof Reflect === 'object' && Reflect.construct) {
        // We construct a different control for this case to include any extra
        // frames added by the construct call.
        try {
          Reflect.construct(Fake, []);
        } catch (x) {
          control = x;
        }

        Reflect.construct(fn, [], Fake);
      } else {
        try {
          Fake.call();
        } catch (x) {
          control = x;
        }

        fn.call(Fake.prototype);
      }
    } else {
      try {
        throw Error();
      } catch (x) {
        control = x;
      }

      fn();
    }
  } catch (sample) {
    // This is inlined manually because closure doesn't do it for us.
    if (sample && control && typeof sample.stack === 'string') {
      // This extracts the first frame from the sample that isn't also in the control.
      // Skipping one frame that we assume is the frame that calls the two.
      var sampleLines = sample.stack.split('\n');
      var controlLines = control.stack.split('\n');
      var s = sampleLines.length - 1;
      var c = controlLines.length - 1;

      while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {
        // We expect at least one stack frame to be shared.
        // Typically this will be the root most one. However, stack frames may be
        // cut off due to maximum stack limits. In this case, one maybe cut off
        // earlier than the other. We assume that the sample is longer or the same
        // and there for cut off earlier. So we should find the root most frame in
        // the sample somewhere in the control.
        c--;
      }

      for (; s >= 1 && c >= 0; s--, c--) {
        // Next we find the first one that isn't the same which should be the
        // frame that called our sample function and the control.
        if (sampleLines[s] !== controlLines[c]) {
          // In V8, the first line is describing the message but other VMs don't.
          // If we're about to return the first line, and the control is also on the same
          // line, that's a pretty good indicator that our sample threw at same line as
          // the control. I.e. before we entered the sample frame. So we ignore this result.
          // This can happen if you passed a class to function component, or non-function.
          if (s !== 1 || c !== 1) {
            do {
              s--;
              c--; // We may still have similar intermediate frames from the construct call.
              // The next one that isn't the same should be our match though.

              if (c < 0 || sampleLines[s] !== controlLines[c]) {
                // V8 adds a "new" prefix for native classes. Let's remove it to make it prettier.
                var _frame = '\n' + sampleLines[s].replace(' at new ', ' at ');

                {
                  if (typeof fn === 'function') {
                    componentFrameCache.set(fn, _frame);
                  }
                } // Return the line we found.


                return _frame;
              }
            } while (s >= 1 && c >= 0);
          }

          break;
        }
      }
    }
  } finally {
    reentry = false;

    {
      ReactCurrentDispatcher.current = previousDispatcher;
      reenableLogs();
    }

    Error.prepareStackTrace = previousPrepareStackTrace;
  } // Fallback to just using the name if we couldn't make it throw.


  var name = fn ? fn.displayName || fn.name : '';
  var syntheticFrame = name ? describeBuiltInComponentFrame(name) : '';

  {
    if (typeof fn === 'function') {
      componentFrameCache.set(fn, syntheticFrame);
    }
  }

  return syntheticFrame;
}

function describeClassComponentFrame(ctor, source, ownerFn) {
  {
    return describeNativeComponentFrame(ctor, true);
  }
}
function describeFunctionComponentFrame(fn, source, ownerFn) {
  {
    return describeNativeComponentFrame(fn, false);
  }
}

function shouldConstruct(Component) {
  var prototype = Component.prototype;
  return !!(prototype && prototype.isReactComponent);
}

function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {

  if (type == null) {
    return '';
  }

  if (typeof type === 'function') {
    {
      return describeNativeComponentFrame(type, shouldConstruct(type));
    }
  }

  if (typeof type === 'string') {
    return describeBuiltInComponentFrame(type);
  }

  switch (type) {
    case REACT_SUSPENSE_TYPE:
      return describeBuiltInComponentFrame('Suspense');

    case REACT_SUSPENSE_LIST_TYPE:
      return describeBuiltInComponentFrame('SuspenseList');
  }

  if (typeof type === 'object') {
    switch (type.$$typeof) {
      case REACT_FORWARD_REF_TYPE:
        return describeFunctionComponentFrame(type.render);

      case REACT_MEMO_TYPE:
        // Memo may contain any component type so we recursively resolve it.
        return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);

      case REACT_BLOCK_TYPE:
        return describeFunctionComponentFrame(type._render);

      case REACT_LAZY_TYPE:
        {
          var lazyComponent = type;
          var payload = lazyComponent._payload;
          var init = lazyComponent._init;

          try {
            // Lazy may contain any component type so we recursively resolve it.
            return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);
          } catch (x) {}
        }
    }
  }

  return '';
}

function describeFiber(fiber) {
  var owner =  fiber._debugOwner ? fiber._debugOwner.type : null ;
  var source =  fiber._debugSource ;

  switch (fiber.tag) {
    case HostComponent:
      return describeBuiltInComponentFrame(fiber.type);

    case LazyComponent:
      return describeBuiltInComponentFrame('Lazy');

    case SuspenseComponent:
      return describeBuiltInComponentFrame('Suspense');

    case SuspenseListComponent:
      return describeBuiltInComponentFrame('SuspenseList');

    case FunctionComponent:
    case IndeterminateComponent:
    case SimpleMemoComponent:
      return describeFunctionComponentFrame(fiber.type);

    case ForwardRef:
      return describeFunctionComponentFrame(fiber.type.render);

    case Block:
      return describeFunctionComponentFrame(fiber.type._render);

    case ClassComponent:
      return describeClassComponentFrame(fiber.type);

    default:
      return '';
  }
}

function getStackByFiberInDevAndProd(workInProgress) {
  try {
    var info = '';
    var node = workInProgress;

    do {
      info += describeFiber(node);
      node = node.return;
    } while (node);

    return info;
  } catch (x) {
    return '\nError generating stack: ' + x.message + '\n' + x.stack;
  }
}

function getWrappedName(outerType, innerType, wrapperName) {
  var functionName = innerType.displayName || innerType.name || '';
  return outerType.displayName || (functionName !== '' ? wrapperName + "(" + functionName + ")" : wrapperName);
}

function getContextName(type) {
  return type.displayName || 'Context';
}

function getComponentName(type) {
  if (type == null) {
    // Host root, text node or just invalid type.
    return null;
  }

  {
    if (typeof type.tag === 'number') {
      error('Received an unexpected object in getComponentName(). ' + 'This is likely a bug in React. Please file an issue.');
    }
  }

  if (typeof type === 'function') {
    return type.displayName || type.name || null;
  }

  if (typeof type === 'string') {
    return type;
  }

  switch (type) {
    case REACT_FRAGMENT_TYPE:
      return 'Fragment';

    case REACT_PORTAL_TYPE:
      return 'Portal';

    case REACT_PROFILER_TYPE:
      return 'Profiler';

    case REACT_STRICT_MODE_TYPE:
      return 'StrictMode';

    case REACT_SUSPENSE_TYPE:
      return 'Suspense';

    case REACT_SUSPENSE_LIST_TYPE:
      return 'SuspenseList';
  }

  if (typeof type === 'object') {
    switch (type.$$typeof) {
      case REACT_CONTEXT_TYPE:
        var context = type;
        return getContextName(context) + '.Consumer';

      case REACT_PROVIDER_TYPE:
        var provider = type;
        return getContextName(provider._context) + '.Provider';

      case REACT_FORWARD_REF_TYPE:
        return getWrappedName(type, type.render, 'ForwardRef');

      case REACT_MEMO_TYPE:
        return getComponentName(type.type);

      case REACT_BLOCK_TYPE:
        return getComponentName(type._render);

      case REACT_LAZY_TYPE:
        {
          var lazyComponent = type;
          var payload = lazyComponent._payload;
          var init = lazyComponent._init;

          try {
            return getComponentName(init(payload));
          } catch (x) {
            return null;
          }
        }
    }
  }

  return null;
}

var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
var current = null;
var isRendering = false;
function getCurrentFiberOwnerNameInDevOrNull() {
  {
    if (current === null) {
      return null;
    }

    var owner = current._debugOwner;

    if (owner !== null && typeof owner !== 'undefined') {
      return getComponentName(owner.type);
    }
  }

  return null;
}

function getCurrentFiberStackInDev() {
  {
    if (current === null) {
      return '';
    } // Safe because if current fiber exists, we are reconciling,
    // and it is guaranteed to be the work-in-progress version.


    return getStackByFiberInDevAndProd(current);
  }
}

function resetCurrentFiber() {
  {
    ReactDebugCurrentFrame.getCurrentStack = null;
    current = null;
    isRendering = false;
  }
}
function setCurrentFiber(fiber) {
  {
    ReactDebugCurrentFrame.getCurrentStack = getCurrentFiberStackInDev;
    current = fiber;
    isRendering = false;
  }
}
function setIsRendering(rendering) {
  {
    isRendering = rendering;
  }
}
function getIsRendering() {
  {
    return isRendering;
  }
}

// Flow does not allow string concatenation of most non-string types. To work
// around this limitation, we use an opaque type that can only be obtained by
// passing the value through getToStringValue first.
function toString(value) {
  return '' + value;
}
function getToStringValue(value) {
  switch (typeof value) {
    case 'boolean':
    case 'number':
    case 'object':
    case 'string':
    case 'undefined':
      return value;

    default:
      // function, symbol are assigned as empty strings
      return '';
  }
}

var hasReadOnlyValue = {
  button: true,
  checkbox: true,
  image: true,
  hidden: true,
  radio: true,
  reset: true,
  submit: true
};
function checkControlledValueProps(tagName, props) {
  {
    if (!(hasReadOnlyValue[props.type] || props.onChange || props.onInput || props.readOnly || props.disabled || props.value == null)) {
      error('You provided a `value` prop to a form field without an ' + '`onChange` handler. This will render a read-only field. If ' + 'the field should be mutable use `defaultValue`. Otherwise, ' + 'set either `onChange` or `readOnly`.');
    }

    if (!(props.onChange || props.readOnly || props.disabled || props.checked == null)) {
      error('You provided a `checked` prop to a form field without an ' + '`onChange` handler. This will render a read-only field. If ' + 'the field should be mutable use `defaultChecked`. Otherwise, ' + 'set either `onChange` or `readOnly`.');
    }
  }
}

function isCheckable(elem) {
  var type = elem.type;
  var nodeName = elem.nodeName;
  return nodeName && nodeName.toLowerCase() === 'input' && (type === 'checkbox' || type === 'radio');
}

function getTracker(node) {
  return node._valueTracker;
}

function detachTracker(node) {
  node._valueTracker = null;
}

function getValueFromNode(node) {
  var value = '';

  if (!node) {
    return value;
  }

  if (isCheckable(node)) {
    value = node.checked ? 'true' : 'false';
  } else {
    value = node.value;
  }

  return value;
}

function trackValueOnNode(node) {
  var valueField = isCheckable(node) ? 'checked' : 'value';
  var descriptor = Object.getOwnPropertyDescriptor(node.constructor.prototype, valueField);
  var currentValue = '' + node[valueField]; // if someone has already defined a value or Safari, then bail
  // and don't track value will cause over reporting of changes,
  // but it's better then a hard failure
  // (needed for certain tests that spyOn input values and Safari)

  if (node.hasOwnProperty(valueField) || typeof descriptor === 'undefined' || typeof descriptor.get !== 'function' || typeof descriptor.set !== 'function') {
    return;
  }

  var get = descriptor.get,
      set = descriptor.set;
  Object.defineProperty(node, valueField, {
    configurable: true,
    get: function () {
      return get.call(this);
    },
    set: function (value) {
      currentValue = '' + value;
      set.call(this, value);
    }
  }); // We could've passed this the first time
  // but it triggers a bug in IE11 and Edge 14/15.
  // Calling defineProperty() again should be equivalent.
  // https://github.com/facebook/react/issues/11768

  Object.defineProperty(node, valueField, {
    enumerable: descriptor.enumerable
  });
  var tracker = {
    getValue: function () {
      return currentValue;
    },
    setValue: function (value) {
      currentValue = '' + value;
    },
    stopTracking: function () {
      detachTracker(node);
      delete node[valueField];
    }
  };
  return tracker;
}

function track(node) {
  if (getTracker(node)) {
    return;
  } // TODO: Once it's just Fiber we can move this to node._wrapperState


  node._valueTracker = trackValueOnNode(node);
}
function updateValueIfChanged(node) {
  if (!node) {
    return false;
  }

  var tracker = getTracker(node); // if there is no tracker at this point it's unlikely
  // that trying again will succeed

  if (!tracker) {
    return true;
  }

  var lastValue = tracker.getValue();
  var nextValue = getValueFromNode(node);

  if (nextValue !== lastValue) {
    tracker.setValue(nextValue);
    return true;
  }

  return false;
}

function getActiveElement(doc) {
  doc = doc || (typeof document !== 'undefined' ? document : undefined);

  if (typeof doc === 'undefined') {
    return null;
  }

  try {
    return doc.activeElement || doc.body;
  } catch (e) {
    return doc.body;
  }
}

var didWarnValueDefaultValue = false;
var didWarnCheckedDefaultChecked = false;
var didWarnControlledToUncontrolled = false;
var didWarnUncontrolledToControlled = false;

function isControlled(props) {
  var usesChecked = props.type === 'checkbox' || props.type === 'radio';
  return usesChecked ? props.checked != null : props.value != null;
}
/**
 * Implements an <input> host component that allows setting these optional
 * props: `checked`, `value`, `defaultChecked`, and `defaultValue`.
 *
 * If `checked` or `value` are not supplied (or null/undefined), user actions
 * that affect the checked state or value will trigger updates to the element.
 *
 * If they are supplied (and not null/undefined), the rendered element will not
 * trigger updates to the element. Instead, the props must change in order for
 * the rendered element to be updated.
 *
 * The rendered element will be initialized as unchecked (or `defaultChecked`)
 * with an empty value (or `defaultValue`).
 *
 * See http://www.w3.org/TR/2012/WD-html5-20121025/the-input-element.html
 */


function getHostProps(element, props) {
  var node = element;
  var checked = props.checked;

  var hostProps = _assign({}, props, {
    defaultChecked: undefined,
    defaultValue: undefined,
    value: undefined,
    checked: checked != null ? checked : node._wrapperState.initialChecked
  });

  return hostProps;
}
function initWrapperState(element, props) {
  {
    checkControlledValueProps('input', props);

    if (props.checked !== undefined && props.defaultChecked !== undefined && !didWarnCheckedDefaultChecked) {
      error('%s contains an input of type %s with both checked and defaultChecked props. ' + 'Input elements must be either controlled or uncontrolled ' + '(specify either the checked prop, or the defaultChecked prop, but not ' + 'both). Decide between using a controlled or uncontrolled input ' + 'element and remove one of these props. More info: ' + 'https://reactjs.org/link/controlled-components', getCurrentFiberOwnerNameInDevOrNull() || 'A component', props.type);

      didWarnCheckedDefaultChecked = true;
    }

    if (props.value !== undefined && props.defaultValue !== undefined && !didWarnValueDefaultValue) {
      error('%s contains an input of type %s with both value and defaultValue props. ' + 'Input elements must be either controlled or uncontrolled ' + '(specify either the value prop, or the defaultValue prop, but not ' + 'both). Decide between using a controlled or uncontrolled input ' + 'element and remove one of these props. More info: ' + 'https://reactjs.org/link/controlled-components', getCurrentFiberOwnerNameInDevOrNull() || 'A component', props.type);

      didWarnValueDefaultValue = true;
    }
  }

  var node = element;
  var defaultValue = props.defaultValue == null ? '' : props.defaultValue;
  node._wrapperState = {
    initialChecked: props.checked != null ? props.checked : props.defaultChecked,
    initialValue: getToStringValue(props.value != null ? props.value : defaultValue),
    controlled: isControlled(props)
  };
}
function updateChecked(element, props) {
  var node = element;
  var checked = props.checked;

  if (checked != null) {
    setValueForProperty(node, 'checked', checked, false);
  }
}
function updateWrapper(element, props) {
  var node = element;

  {
    var controlled = isControlled(props);

    if (!node._wrapperState.controlled && controlled && !didWarnUncontrolledToControlled) {
      error('A component is changing an uncontrolled input to be controlled. ' + 'This is likely caused by the value changing from undefined to ' + 'a defined value, which should not happen. ' + 'Decide between using a controlled or uncontrolled input ' + 'element for the lifetime of the component. More info: https://reactjs.org/link/controlled-components');

      didWarnUncontrolledToControlled = true;
    }

    if (node._wrapperState.controlled && !controlled && !didWarnControlledToUncontrolled) {
      error('A component is changing a controlled input to be uncontrolled. ' + 'This is likely caused by the value changing from a defined to ' + 'undefined, which should not happen. ' + 'Decide between using a controlled or uncontrolled input ' + 'element for the lifetime of the component. More info: https://reactjs.org/link/controlled-components');

      didWarnControlledToUncontrolled = true;
    }
  }

  updateChecked(element, props);
  var value = getToStringValue(props.value);
  var type = props.type;

  if (value != null) {
    if (type === 'number') {
      if (value === 0 && node.value === '' || // We explicitly want to coerce to number here if possible.
      // eslint-disable-next-line
      node.value != value) {
        node.value = toString(value);
      }
    } else if (node.value !== toString(value)) {
      node.value = toString(value);
    }
  } else if (type === 'submit' || type === 'reset') {
    // Submit/reset inputs need the attribute removed completely to avoid
    // blank-text buttons.
    node.removeAttribute('value');
    return;
  }

  {
    // When syncing the value attribute, the value comes from a cascade of
    // properties:
    //  1. The value React property
    //  2. The defaultValue React property
    //  3. Otherwise there should be no change
    if (props.hasOwnProperty('value')) {
      setDefaultValue(node, props.type, value);
    } else if (props.hasOwnProperty('defaultValue')) {
      setDefaultValue(node, props.type, getToStringValue(props.defaultValue));
    }
  }

  {
    // When syncing the checked attribute, it only changes when it needs
    // to be removed, such as transitioning from a checkbox into a text input
    if (props.checked == null && props.defaultChecked != null) {
      node.defaultChecked = !!props.defaultChecked;
    }
  }
}
function postMountWrapper(element, props, isHydrating) {
  var node = element; // Do not assign value if it is already set. This prevents user text input
  // from being lost during SSR hydration.

  if (props.hasOwnProperty('value') || props.hasOwnProperty('defaultValue')) {
    var type = props.type;
    var isButton = type === 'submit' || type === 'reset'; // Avoid setting value attribute on submit/reset inputs as it overrides the
    // default value provided by the browser. See: #12872

    if (isButton && (props.value === undefined || props.value === null)) {
      return;
    }

    var initialValue = toString(node._wrapperState.initialValue); // Do not assign value if it is already set. This prevents user text input
    // from being lost during SSR hydration.

    if (!isHydrating) {
      {
        // When syncing the value attribute, the value property should use
        // the wrapperState._initialValue property. This uses:
        //
        //   1. The value React property when present
        //   2. The defaultValue React property when present
        //   3. An empty string
        if (initialValue !== node.value) {
          node.value = initialValue;
        }
      }
    }

    {
      // Otherwise, the value attribute is synchronized to the property,
      // so we assign defaultValue to the same thing as the value property
      // assignment step above.
      node.defaultValue = initialValue;
    }
  } // Normally, we'd just do `node.checked = node.checked` upon initial mount, less this bug
  // this is needed to work around a chrome bug where setting defaultChecked
  // will sometimes influence the value of checked (even after detachment).
  // Reference: https://bugs.chromium.org/p/chromium/issues/detail?id=608416
  // We need to temporarily unset name to avoid disrupting radio button groups.


  var name = node.name;

  if (name !== '') {
    node.name = '';
  }

  {
    // When syncing the checked attribute, both the checked property and
    // attribute are assigned at the same time using defaultChecked. This uses:
    //
    //   1. The checked React property when present
    //   2. The defaultChecked React property when present
    //   3. Otherwise, false
    node.defaultChecked = !node.defaultChecked;
    node.defaultChecked = !!node._wrapperState.initialChecked;
  }

  if (name !== '') {
    node.name = name;
  }
}
function restoreControlledState(element, props) {
  var node = element;
  updateWrapper(node, props);
  updateNamedCousins(node, props);
}

function updateNamedCousins(rootNode, props) {
  var name = props.name;

  if (props.type === 'radio' && name != null) {
    var queryRoot = rootNode;

    while (queryRoot.parentNode) {
      queryRoot = queryRoot.parentNode;
    } // If `rootNode.form` was non-null, then we could try `form.elements`,
    // but that sometimes behaves strangely in IE8. We could also try using
    // `form.getElementsByName`, but that will only return direct children
    // and won't include inputs that use the HTML5 `form=` attribute. Since
    // the input might not even be in a form. It might not even be in the
    // document. Let's just use the local `querySelectorAll` to ensure we don't
    // miss anything.


    var group = queryRoot.querySelectorAll('input[name=' + JSON.stringify('' + name) + '][type="radio"]');

    for (var i = 0; i < group.length; i++) {
      var otherNode = group[i];

      if (otherNode === rootNode || otherNode.form !== rootNode.form) {
        continue;
      } // This will throw if radio buttons rendered by different copies of React
      // and the same name are rendered into the same form (same as #1939).
      // That's probably okay; we don't support it just as we don't support
      // mixing React radio buttons with non-React ones.


      var otherProps = getFiberCurrentPropsFromNode(otherNode);

      if (!otherProps) {
        {
          throw Error( "ReactDOMInput: Mixing React and non-React radio inputs with the same `name` is not supported." );
        }
      } // We need update the tracked value on the named cousin since the value
      // was changed but the input saw no event or value set


      updateValueIfChanged(otherNode); // If this is a controlled radio button group, forcing the input that
      // was previously checked to update will cause it to be come re-checked
      // as appropriate.

      updateWrapper(otherNode, otherProps);
    }
  }
} // In Chrome, assigning defaultValue to certain input types triggers input validation.
// For number inputs, the display value loses trailing decimal points. For email inputs,
// Chrome raises "The specified value <x> is not a valid email address".
//
// Here we check to see if the defaultValue has actually changed, avoiding these problems
// when the user is inputting text
//
// https://github.com/facebook/react/issues/7253


function setDefaultValue(node, type, value) {
  if ( // Focused number inputs synchronize on blur. See ChangeEventPlugin.js
  type !== 'number' || getActiveElement(node.ownerDocument) !== node) {
    if (value == null) {
      node.defaultValue = toString(node._wrapperState.initialValue);
    } else if (node.defaultValue !== toString(value)) {
      node.defaultValue = toString(value);
    }
  }
}

var didWarnSelectedSetOnOption = false;
var didWarnInvalidChild = false;

function flattenChildren(children) {
  var content = ''; // Flatten children. We'll warn if they are invalid
  // during validateProps() which runs for hydration too.
  // Note that this would throw on non-element objects.
  // Elements are stringified (which is normally irrelevant
  // but matters for <fbt>).

  React.Children.forEach(children, function (child) {
    if (child == null) {
      return;
    }

    content += child; // Note: we don't warn about invalid children here.
    // Instead, this is done separately below so that
    // it happens during the hydration code path too.
  });
  return content;
}
/**
 * Implements an <option> host component that warns when `selected` is set.
 */


function validateProps(element, props) {
  {
    // This mirrors the code path above, but runs for hydration too.
    // Warn about invalid children here so that client and hydration are consistent.
    // TODO: this seems like it could cause a DEV-only throw for hydration
    // if children contains a non-element object. We should try to avoid that.
    if (typeof props.children === 'object' && props.children !== null) {
      React.Children.forEach(props.children, function (child) {
        if (child == null) {
          return;
        }

        if (typeof child === 'string' || typeof child === 'number') {
          return;
        }

        if (typeof child.type !== 'string') {
          return;
        }

        if (!didWarnInvalidChild) {
          didWarnInvalidChild = true;

          error('Only strings and numbers are supported as <option> children.');
        }
      });
    } // TODO: Remove support for `selected` in <option>.


    if (props.selected != null && !didWarnSelectedSetOnOption) {
      error('Use the `defaultValue` or `value` props on <select> instead of ' + 'setting `selected` on <option>.');

      didWarnSelectedSetOnOption = true;
    }
  }
}
function postMountWrapper$1(element, props) {
  // value="" should make a value attribute (#6219)
  if (props.value != null) {
    element.setAttribute('value', toString(getToStringValue(props.value)));
  }
}
function getHostProps$1(element, props) {
  var hostProps = _assign({
    children: undefined
  }, props);

  var content = flattenChildren(props.children);

  if (content) {
    hostProps.children = content;
  }

  return hostProps;
}

var didWarnValueDefaultValue$1;

{
  didWarnValueDefaultValue$1 = false;
}

function getDeclarationErrorAddendum() {
  var ownerName = getCurrentFiberOwnerNameInDevOrNull();

  if (ownerName) {
    return '\n\nCheck the render method of `' + ownerName + '`.';
  }

  return '';
}

var valuePropNames = ['value', 'defaultValue'];
/**
 * Validation function for `value` and `defaultValue`.
 */

function checkSelectPropTypes(props) {
  {
    checkControlledValueProps('select', props);

    for (var i = 0; i < valuePropNames.length; i++) {
      var propName = valuePropNames[i];

      if (props[propName] == null) {
        continue;
      }

      var isArray = Array.isArray(props[propName]);

      if (props.multiple && !isArray) {
        error('The `%s` prop supplied to <select> must be an array if ' + '`multiple` is true.%s', propName, getDeclarationErrorAddendum());
      } else if (!props.multiple && isArray) {
        error('The `%s` prop supplied to <select> must be a scalar ' + 'value if `multiple` is false.%s', propName, getDeclarationErrorAddendum());
      }
    }
  }
}

function updateOptions(node, multiple, propValue, setDefaultSelected) {
  var options = node.options;

  if (multiple) {
    var selectedValues = propValue;
    var selectedValue = {};

    for (var i = 0; i < selectedValues.length; i++) {
      // Prefix to avoid chaos with special keys.
      selectedValue['$' + selectedValues[i]] = true;
    }

    for (var _i = 0; _i < options.length; _i++) {
      var selected = selectedValue.hasOwnProperty('$' + options[_i].value);

      if (options[_i].selected !== selected) {
        options[_i].selected = selected;
      }

      if (selected && setDefaultSelected) {
        options[_i].defaultSelected = true;
      }
    }
  } else {
    // Do not set `select.value` as exact behavior isn't consistent across all
    // browsers for all cases.
    var _selectedValue = toString(getToStringValue(propValue));

    var defaultSelected = null;

    for (var _i2 = 0; _i2 < options.length; _i2++) {
      if (options[_i2].value === _selectedValue) {
        options[_i2].selected = true;

        if (setDefaultSelected) {
          options[_i2].defaultSelected = true;
        }

        return;
      }

      if (defaultSelected === null && !options[_i2].disabled) {
        defaultSelected = options[_i2];
      }
    }

    if (defaultSelected !== null) {
      defaultSelected.selected = true;
    }
  }
}
/**
 * Implements a <select> host component that allows optionally setting the
 * props `value` and `defaultValue`. If `multiple` is false, the prop must be a
 * stringable. If `multiple` is true, the prop must be an array of stringables.
 *
 * If `value` is not supplied (or null/undefined), user actions that change the
 * selected option will trigger updates to the rendered options.
 *
 * If it is supplied (and not null/undefined), the rendered options will not
 * update in response to user actions. Instead, the `value` prop must change in
 * order for the rendered options to update.
 *
 * If `defaultValue` is provided, any options with the supplied values will be
 * selected.
 */


function getHostProps$2(element, props) {
  return _assign({}, props, {
    value: undefined
  });
}
function initWrapperState$1(element, props) {
  var node = element;

  {
    checkSelectPropTypes(props);
  }

  node._wrapperState = {
    wasMultiple: !!props.multiple
  };

  {
    if (props.value !== undefined && props.defaultValue !== undefined && !didWarnValueDefaultValue$1) {
      error('Select elements must be either controlled or uncontrolled ' + '(specify either the value prop, or the defaultValue prop, but not ' + 'both). Decide between using a controlled or uncontrolled select ' + 'element and remove one of these props. More info: ' + 'https://reactjs.org/link/controlled-components');

      didWarnValueDefaultValue$1 = true;
    }
  }
}
function postMountWrapper$2(element, props) {
  var node = element;
  node.multiple = !!props.multiple;
  var value = props.value;

  if (value != null) {
    updateOptions(node, !!props.multiple, value, false);
  } else if (props.defaultValue != null) {
    updateOptions(node, !!props.multiple, props.defaultValue, true);
  }
}
function postUpdateWrapper(element, props) {
  var node = element;
  var wasMultiple = node._wrapperState.wasMultiple;
  node._wrapperState.wasMultiple = !!props.multiple;
  var value = props.value;

  if (value != null) {
    updateOptions(node, !!props.multiple, value, false);
  } else if (wasMultiple !== !!props.multiple) {
    // For simplicity, reapply `defaultValue` if `multiple` is toggled.
    if (props.defaultValue != null) {
      updateOptions(node, !!props.multiple, props.defaultValue, true);
    } else {
      // Revert the select back to its default unselected state.
      updateOptions(node, !!props.multiple, props.multiple ? [] : '', false);
    }
  }
}
function restoreControlledState$1(element, props) {
  var node = element;
  var value = props.value;

  if (value != null) {
    updateOptions(node, !!props.multiple, value, false);
  }
}

var didWarnValDefaultVal = false;

/**
 * Implements a <textarea> host component that allows setting `value`, and
 * `defaultValue`. This differs from the traditional DOM API because value is
 * usually set as PCDATA children.
 *
 * If `value` is not supplied (or null/undefined), user actions that affect the
 * value will trigger updates to the element.
 *
 * If `value` is supplied (and not null/undefined), the rendered element will
 * not trigger updates to the element. Instead, the `value` prop must change in
 * order for the rendered element to be updated.
 *
 * The rendered element will be initialized with an empty value, the prop
 * `defaultValue` if specified, or the children content (deprecated).
 */
function getHostProps$3(element, props) {
  var node = element;

  if (!(props.dangerouslySetInnerHTML == null)) {
    {
      throw Error( "`dangerouslySetInnerHTML` does not make sense on <textarea>." );
    }
  } // Always set children to the same thing. In IE9, the selection range will
  // get reset if `textContent` is mutated.  We could add a check in setTextContent
  // to only set the value if/when the value differs from the node value (which would
  // completely solve this IE9 bug), but Sebastian+Sophie seemed to like this
  // solution. The value can be a boolean or object so that's why it's forced
  // to be a string.


  var hostProps = _assign({}, props, {
    value: undefined,
    defaultValue: undefined,
    children: toString(node._wrapperState.initialValue)
  });

  return hostProps;
}
function initWrapperState$2(element, props) {
  var node = element;

  {
    checkControlledValueProps('textarea', props);

    if (props.value !== undefined && props.defaultValue !== undefined && !didWarnValDefaultVal) {
      error('%s contains a textarea with both value and defaultValue props. ' + 'Textarea elements must be either controlled or uncontrolled ' + '(specify either the value prop, or the defaultValue prop, but not ' + 'both). Decide between using a controlled or uncontrolled textarea ' + 'and remove one of these props. More info: ' + 'https://reactjs.org/link/controlled-components', getCurrentFiberOwnerNameInDevOrNull() || 'A component');

      didWarnValDefaultVal = true;
    }
  }

  var initialValue = props.value; // Only bother fetching default value if we're going to use it

  if (initialValue == null) {
    var children = props.children,
        defaultValue = props.defaultValue;

    if (children != null) {
      {
        error('Use the `defaultValue` or `value` props instead of setting ' + 'children on <textarea>.');
      }

      {
        if (!(defaultValue == null)) {
          {
            throw Error( "If you supply `defaultValue` on a <textarea>, do not pass children." );
          }
        }

        if (Array.isArray(children)) {
          if (!(children.length <= 1)) {
            {
              throw Error( "<textarea> can only have at most one child." );
            }
          }

          children = children[0];
        }

        defaultValue = children;
      }
    }

    if (defaultValue == null) {
      defaultValue = '';
    }

    initialValue = defaultValue;
  }

  node._wrapperState = {
    initialValue: getToStringValue(initialValue)
  };
}
function updateWrapper$1(element, props) {
  var node = element;
  var value = getToStringValue(props.value);
  var defaultValue = getToStringValue(props.defaultValue);

  if (value != null) {
    // Cast `value` to a string to ensure the value is set correctly. While
    // browsers typically do this as necessary, jsdom doesn't.
    var newValue = toString(value); // To avoid side effects (such as losing text selection), only set value if changed

    if (newValue !== node.value) {
      node.value = newValue;
    }

    if (props.defaultValue == null && node.defaultValue !== newValue) {
      node.defaultValue = newValue;
    }
  }

  if (defaultValue != null) {
    node.defaultValue = toString(defaultValue);
  }
}
function postMountWrapper$3(element, props) {
  var node = element; // This is in postMount because we need access to the DOM node, which is not
  // available until after the component has mounted.

  var textContent = node.textContent; // Only set node.value if textContent is equal to the expected
  // initial value. In IE10/IE11 there is a bug where the placeholder attribute
  // will populate textContent as well.
  // https://developer.microsoft.com/microsoft-edge/platform/issues/101525/

  if (textContent === node._wrapperState.initialValue) {
    if (textContent !== '' && textContent !== null) {
      node.value = textContent;
    }
  }
}
function restoreControlledState$2(element, props) {
  // DOM component is still mounted; update
  updateWrapper$1(element, props);
}

var HTML_NAMESPACE = 'http://www.w3.org/1999/xhtml';
var MATH_NAMESPACE = 'http://www.w3.org/1998/Math/MathML';
var SVG_NAMESPACE = 'http://www.w3.org/2000/svg';
var Namespaces = {
  html: HTML_NAMESPACE,
  mathml: MATH_NAMESPACE,
  svg: SVG_NAMESPACE
}; // Assumes there is no parent namespace.

function getIntrinsicNamespace(type) {
  switch (type) {
    case 'svg':
      return SVG_NAMESPACE;

    case 'math':
      return MATH_NAMESPACE;

    default:
      return HTML_NAMESPACE;
  }
}
function getChildNamespace(parentNamespace, type) {
  if (parentNamespace == null || parentNamespace === HTML_NAMESPACE) {
    // No (or default) parent namespace: potential entry point.
    return getIntrinsicNamespace(type);
  }

  if (parentNamespace === SVG_NAMESPACE && type === 'foreignObject') {
    // We're leaving SVG.
    return HTML_NAMESPACE;
  } // By default, pass namespace below.


  return parentNamespace;
}

/* globals MSApp */

/**
 * Create a function which has 'unsafe' privileges (required by windows8 apps)
 */
var createMicrosoftUnsafeLocalFunction = function (func) {
  if (typeof MSApp !== 'undefined' && MSApp.execUnsafeLocalFunction) {
    return function (arg0, arg1, arg2, arg3) {
      MSApp.execUnsafeLocalFunction(function () {
        return func(arg0, arg1, arg2, arg3);
      });
    };
  } else {
    return func;
  }
};

var reusableSVGContainer;
/**
 * Set the innerHTML property of a node
 *
 * @param {DOMElement} node
 * @param {string} html
 * @internal
 */

var setInnerHTML = createMicrosoftUnsafeLocalFunction(function (node, html) {
  if (node.namespaceURI === Namespaces.svg) {

    if (!('innerHTML' in node)) {
      // IE does not have innerHTML for SVG nodes, so instead we inject the
      // new markup in a temp node and then move the child nodes across into
      // the target node
      reusableSVGContainer = reusableSVGContainer || document.createElement('div');
      reusableSVGContainer.innerHTML = '<svg>' + html.valueOf().toString() + '</svg>';
      var svgNode = reusableSVGContainer.firstChild;

      while (node.firstChild) {
        node.removeChild(node.firstChild);
      }

      while (svgNode.firstChild) {
        node.appendChild(svgNode.firstChild);
      }

      return;
    }
  }

  node.innerHTML = html;
});

/**
 * HTML nodeType values that represent the type of the node
 */
var ELEMENT_NODE = 1;
var TEXT_NODE = 3;
var COMMENT_NODE = 8;
var DOCUMENT_NODE = 9;
var DOCUMENT_FRAGMENT_NODE = 11;

/**
 * Set the textContent property of a node. For text updates, it's faster
 * to set the `nodeValue` of the Text node directly instead of using
 * `.textContent` which will remove the existing node and create a new one.
 *
 * @param {DOMElement} node
 * @param {string} text
 * @internal
 */

var setTextContent = function (node, text) {
  if (text) {
    var firstChild = node.firstChild;

    if (firstChild && firstChild === node.lastChild && firstChild.nodeType === TEXT_NODE) {
      firstChild.nodeValue = text;
      return;
    }
  }

  node.textContent = text;
};

// List derived from Gecko source code:
// https://github.com/mozilla/gecko-dev/blob/4e638efc71/layout/style/test/property_database.js
var shorthandToLonghand = {
  animation: ['animationDelay', 'animationDirection', 'animationDuration', 'animationFillMode', 'animationIterationCount', 'animationName', 'animationPlayState', 'animationTimingFunction'],
  background: ['backgroundAttachment', 'backgroundClip', 'backgroundColor', 'backgroundImage', 'backgroundOrigin', 'backgroundPositionX', 'backgroundPositionY', 'backgroundRepeat', 'backgroundSize'],
  backgroundPosition: ['backgroundPositionX', 'backgroundPositionY'],
  border: ['borderBottomColor', 'borderBottomStyle', 'borderBottomWidth', 'borderImageOutset', 'borderImageRepeat', 'borderImageSlice', 'borderImageSource', 'borderImageWidth', 'borderLeftColor', 'borderLeftStyle', 'borderLeftWidth', 'borderRightColor', 'borderRightStyle', 'borderRightWidth', 'borderTopColor', 'borderTopStyle', 'borderTopWidth'],
  borderBlockEnd: ['borderBlockEndColor', 'borderBlockEndStyle', 'borderBlockEndWidth'],
  borderBlockStart: ['borderBlockStartColor', 'borderBlockStartStyle', 'borderBlockStartWidth'],
  borderBottom: ['borderBottomColor', 'borderBottomStyle', 'borderBottomWidth'],
  borderColor: ['borderBottomColor', 'borderLeftColor', 'borderRightColor', 'borderTopColor'],
  borderImage: ['borderImageOutset', 'borderImageRepeat', 'borderImageSlice', 'borderImageSource', 'borderImageWidth'],
  borderInlineEnd: ['borderInlineEndColor', 'borderInlineEndStyle', 'borderInlineEndWidth'],
  borderInlineStart: ['borderInlineStartColor', 'borderInlineStartStyle', 'borderInlineStartWidth'],
  borderLeft: ['borderLeftColor', 'borderLeftStyle', 'borderLeftWidth'],
  borderRadius: ['borderBottomLeftRadius', 'borderBottomRightRadius', 'borderTopLeftRadius', 'borderTopRightRadius'],
  borderRight: ['borderRightColor', 'borderRightStyle', 'borderRightWidth'],
  borderStyle: ['borderBottomStyle', 'borderLeftStyle', 'borderRightStyle', 'borderTopStyle'],
  borderTop: ['borderTopColor', 'borderTopStyle', 'borderTopWidth'],
  borderWidth: ['borderBottomWidth', 'borderLeftWidth', 'borderRightWidth', 'borderTopWidth'],
  columnRule: ['columnRuleColor', 'columnRuleStyle', 'columnRuleWidth'],
  columns: ['columnCount', 'columnWidth'],
  flex: ['flexBasis', 'flexGrow', 'flexShrink'],
  flexFlow: ['flexDirection', 'flexWrap'],
  font: ['fontFamily', 'fontFeatureSettings', 'fontKerning', 'fontLanguageOverride', 'fontSize', 'fontSizeAdjust', 'fontStretch', 'fontStyle', 'fontVariant', 'fontVariantAlternates', 'fontVariantCaps', 'fontVariantEastAsian', 'fontVariantLigatures', 'fontVariantNumeric', 'fontVariantPosition', 'fontWeight', 'lineHeight'],
  fontVariant: ['fontVariantAlternates', 'fontVariantCaps', 'fontVariantEastAsian', 'fontVariantLigatures', 'fontVariantNumeric', 'fontVariantPosition'],
  gap: ['columnGap', 'rowGap'],
  grid: ['gridAutoColumns', 'gridAutoFlow', 'gridAutoRows', 'gridTemplateAreas', 'gridTemplateColumns', 'gridTemplateRows'],
  gridArea: ['gridColumnEnd', 'gridColumnStart', 'gridRowEnd', 'gridRowStart'],
  gridColumn: ['gridColumnEnd', 'gridColumnStart'],
  gridColumnGap: ['columnGap'],
  gridGap: ['columnGap', 'rowGap'],
  gridRow: ['gridRowEnd', 'gridRowStart'],
  gridRowGap: ['rowGap'],
  gridTemplate: ['gridTemplateAreas', 'gridTemplateColumns', 'gridTemplateRows'],
  listStyle: ['listStyleImage', 'listStylePosition', 'listStyleType'],
  margin: ['marginBottom', 'marginLeft', 'marginRight', 'marginTop'],
  marker: ['markerEnd', 'markerMid', 'markerStart'],
  mask: ['maskClip', 'maskComposite', 'maskImage', 'maskMode', 'maskOrigin', 'maskPositionX', 'maskPositionY', 'maskRepeat', 'maskSize'],
  maskPosition: ['maskPositionX', 'maskPositionY'],
  outline: ['outlineColor', 'outlineStyle', 'outlineWidth'],
  overflow: ['overflowX', 'overflowY'],
  padding: ['paddingBottom', 'paddingLeft', 'paddingRight', 'paddingTop'],
  placeContent: ['alignContent', 'justifyContent'],
  placeItems: ['alignItems', 'justifyItems'],
  placeSelf: ['alignSelf', 'justifySelf'],
  textDecoration: ['textDecorationColor', 'textDecorationLine', 'textDecorationStyle'],
  textEmphasis: ['textEmphasisColor', 'textEmphasisStyle'],
  transition: ['transitionDelay', 'transitionDuration', 'transitionProperty', 'transitionTimingFunction'],
  wordWrap: ['overflowWrap']
};

/**
 * CSS properties which accept numbers but are not in units of "px".
 */
var isUnitlessNumber = {
  animationIterationCount: true,
  borderImageOutset: true,
  borderImageSlice: true,
  borderImageWidth: true,
  boxFlex: true,
  boxFlexGroup: true,
  boxOrdinalGroup: true,
  columnCount: true,
  columns: true,
  flex: true,
  flexGrow: true,
  flexPositive: true,
  flexShrink: true,
  flexNegative: true,
  flexOrder: true,
  gridArea: true,
  gridRow: true,
  gridRowEnd: true,
  gridRowSpan: true,
  gridRowStart: true,
  gridColumn: true,
  gridColumnEnd: true,
  gridColumnSpan: true,
  gridColumnStart: true,
  fontWeight: true,
  lineClamp: true,
  lineHeight: true,
  opacity: true,
  order: true,
  orphans: true,
  tabSize: true,
  widows: true,
  zIndex: true,
  zoom: true,
  // SVG-related properties
  fillOpacity: true,
  floodOpacity: true,
  stopOpacity: true,
  strokeDasharray: true,
  strokeDashoffset: true,
  strokeMiterlimit: true,
  strokeOpacity: true,
  strokeWidth: true
};
/**
 * @param {string} prefix vendor-specific prefix, eg: Webkit
 * @param {string} key style name, eg: transitionDuration
 * @return {string} style name prefixed with `prefix`, properly camelCased, eg:
 * WebkitTransitionDuration
 */

function prefixKey(prefix, key) {
  return prefix + key.charAt(0).toUpperCase() + key.substring(1);
}
/**
 * Support style names that may come passed in prefixed by adding permutations
 * of vendor prefixes.
 */


var prefixes = ['Webkit', 'ms', 'Moz', 'O']; // Using Object.keys here, or else the vanilla for-in loop makes IE8 go into an
// infinite loop, because it iterates over the newly added props too.

Object.keys(isUnitlessNumber).forEach(function (prop) {
  prefixes.forEach(function (prefix) {
    isUnitlessNumber[prefixKey(prefix, prop)] = isUnitlessNumber[prop];
  });
});

/**
 * Convert a value into the proper css writable value. The style name `name`
 * should be logical (no hyphens), as specified
 * in `CSSProperty.isUnitlessNumber`.
 *
 * @param {string} name CSS property name such as `topMargin`.
 * @param {*} value CSS property value such as `10px`.
 * @return {string} Normalized style value with dimensions applied.
 */

function dangerousStyleValue(name, value, isCustomProperty) {
  // Note that we've removed escapeTextForBrowser() calls here since the
  // whole string will be escaped when the attribute is injected into
  // the markup. If you provide unsafe user data here they can inject
  // arbitrary CSS which may be problematic (I couldn't repro this):
  // https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet
  // http://www.thespanner.co.uk/2007/11/26/ultimate-xss-css-injection/
  // This is not an XSS hole but instead a potential CSS injection issue
  // which has lead to a greater discussion about how we're going to
  // trust URLs moving forward. See #2115901
  var isEmpty = value == null || typeof value === 'boolean' || value === '';

  if (isEmpty) {
    return '';
  }

  if (!isCustomProperty && typeof value === 'number' && value !== 0 && !(isUnitlessNumber.hasOwnProperty(name) && isUnitlessNumber[name])) {
    return value + 'px'; // Presumes implicit 'px' suffix for unitless numbers
  }

  return ('' + value).trim();
}

var uppercasePattern = /([A-Z])/g;
var msPattern = /^ms-/;
/**
 * Hyphenates a camelcased CSS property name, for example:
 *
 *   > hyphenateStyleName('backgroundColor')
 *   < "background-color"
 *   > hyphenateStyleName('MozTransition')
 *   < "-moz-transition"
 *   > hyphenateStyleName('msTransition')
 *   < "-ms-transition"
 *
 * As Modernizr suggests (http://modernizr.com/docs/#prefixed), an `ms` prefix
 * is converted to `-ms-`.
 */

function hyphenateStyleName(name) {
  return name.replace(uppercasePattern, '-$1').toLowerCase().replace(msPattern, '-ms-');
}

var warnValidStyle = function () {};

{
  // 'msTransform' is correct, but the other prefixes should be capitalized
  var badVendoredStyleNamePattern = /^(?:webkit|moz|o)[A-Z]/;
  var msPattern$1 = /^-ms-/;
  var hyphenPattern = /-(.)/g; // style values shouldn't contain a semicolon

  var badStyleValueWithSemicolonPattern = /;\s*$/;
  var warnedStyleNames = {};
  var warnedStyleValues = {};
  var warnedForNaNValue = false;
  var warnedForInfinityValue = false;

  var camelize = function (string) {
    return string.replace(hyphenPattern, function (_, character) {
      return character.toUpperCase();
    });
  };

  var warnHyphenatedStyleName = function (name) {
    if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {
      return;
    }

    warnedStyleNames[name] = true;

    error('Unsupported style property %s. Did you mean %s?', name, // As Andi Smith suggests
    // (http://www.andismith.com/blog/2012/02/modernizr-prefixed/), an `-ms` prefix
    // is converted to lowercase `ms`.
    camelize(name.replace(msPattern$1, 'ms-')));
  };

  var warnBadVendoredStyleName = function (name) {
    if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {
      return;
    }

    warnedStyleNames[name] = true;

    error('Unsupported vendor-prefixed style property %s. Did you mean %s?', name, name.charAt(0).toUpperCase() + name.slice(1));
  };

  var warnStyleValueWithSemicolon = function (name, value) {
    if (warnedStyleValues.hasOwnProperty(value) && warnedStyleValues[value]) {
      return;
    }

    warnedStyleValues[value] = true;

    error("Style property values shouldn't contain a semicolon. " + 'Try "%s: %s" instead.', name, value.replace(badStyleValueWithSemicolonPattern, ''));
  };

  var warnStyleValueIsNaN = function (name, value) {
    if (warnedForNaNValue) {
      return;
    }

    warnedForNaNValue = true;

    error('`NaN` is an invalid value for the `%s` css style property.', name);
  };

  var warnStyleValueIsInfinity = function (name, value) {
    if (warnedForInfinityValue) {
      return;
    }

    warnedForInfinityValue = true;

    error('`Infinity` is an invalid value for the `%s` css style property.', name);
  };

  warnValidStyle = function (name, value) {
    if (name.indexOf('-') > -1) {
      warnHyphenatedStyleName(name);
    } else if (badVendoredStyleNamePattern.test(name)) {
      warnBadVendoredStyleName(name);
    } else if (badStyleValueWithSemicolonPattern.test(value)) {
      warnStyleValueWithSemicolon(name, value);
    }

    if (typeof value === 'number') {
      if (isNaN(value)) {
        warnStyleValueIsNaN(name, value);
      } else if (!isFinite(value)) {
        warnStyleValueIsInfinity(name, value);
      }
    }
  };
}

var warnValidStyle$1 = warnValidStyle;

/**
 * Operations for dealing with CSS properties.
 */

/**
 * This creates a string that is expected to be equivalent to the style
 * attribute generated by server-side rendering. It by-passes warnings and
 * security checks so it's not safe to use this value for anything other than
 * comparison. It is only used in DEV for SSR validation.
 */

function createDangerousStringForStyles(styles) {
  {
    var serialized = '';
    var delimiter = '';

    for (var styleName in styles) {
      if (!styles.hasOwnProperty(styleName)) {
        continue;
      }

      var styleValue = styles[styleName];

      if (styleValue != null) {
        var isCustomProperty = styleName.indexOf('--') === 0;
        serialized += delimiter + (isCustomProperty ? styleName : hyphenateStyleName(styleName)) + ':';
        serialized += dangerousStyleValue(styleName, styleValue, isCustomProperty);
        delimiter = ';';
      }
    }

    return serialized || null;
  }
}
/**
 * Sets the value for multiple styles on a node.  If a value is specified as
 * '' (empty string), the corresponding style property will be unset.
 *
 * @param {DOMElement} node
 * @param {object} styles
 */

function setValueForStyles(node, styles) {
  var style = node.style;

  for (var styleName in styles) {
    if (!styles.hasOwnProperty(styleName)) {
      continue;
    }

    var isCustomProperty = styleName.indexOf('--') === 0;

    {
      if (!isCustomProperty) {
        warnValidStyle$1(styleName, styles[styleName]);
      }
    }

    var styleValue = dangerousStyleValue(styleName, styles[styleName], isCustomProperty);

    if (styleName === 'float') {
      styleName = 'cssFloat';
    }

    if (isCustomProperty) {
      style.setProperty(styleName, styleValue);
    } else {
      style[styleName] = styleValue;
    }
  }
}

function isValueEmpty(value) {
  return value == null || typeof value === 'boolean' || value === '';
}
/**
 * Given {color: 'red', overflow: 'hidden'} returns {
 *   color: 'color',
 *   overflowX: 'overflow',
 *   overflowY: 'overflow',
 * }. This can be read as "the overflowY property was set by the overflow
 * shorthand". That is, the values are the property that each was derived from.
 */


function expandShorthandMap(styles) {
  var expanded = {};

  for (var key in styles) {
    var longhands = shorthandToLonghand[key] || [key];

    for (var i = 0; i < longhands.length; i++) {
      expanded[longhands[i]] = key;
    }
  }

  return expanded;
}
/**
 * When mixing shorthand and longhand property names, we warn during updates if
 * we expect an incorrect result to occur. In particular, we warn for:
 *
 * Updating a shorthand property (longhand gets overwritten):
 *   {font: 'foo', fontVariant: 'bar'} -> {font: 'baz', fontVariant: 'bar'}
 *   becomes .style.font = 'baz'
 * Removing a shorthand property (longhand gets lost too):
 *   {font: 'foo', fontVariant: 'bar'} -> {fontVariant: 'bar'}
 *   becomes .style.font = ''
 * Removing a longhand property (should revert to shorthand; doesn't):
 *   {font: 'foo', fontVariant: 'bar'} -> {font: 'foo'}
 *   becomes .style.fontVariant = ''
 */


function validateShorthandPropertyCollisionInDev(styleUpdates, nextStyles) {
  {
    if (!nextStyles) {
      return;
    }

    var expandedUpdates = expandShorthandMap(styleUpdates);
    var expandedStyles = expandShorthandMap(nextStyles);
    var warnedAbout = {};

    for (var key in expandedUpdates) {
      var originalKey = expandedUpdates[key];
      var correctOriginalKey = expandedStyles[key];

      if (correctOriginalKey && originalKey !== correctOriginalKey) {
        var warningKey = originalKey + ',' + correctOriginalKey;

        if (warnedAbout[warningKey]) {
          continue;
        }

        warnedAbout[warningKey] = true;

        error('%s a style property during rerender (%s) when a ' + 'conflicting property is set (%s) can lead to styling bugs. To ' + "avoid this, don't mix shorthand and non-shorthand properties " + 'for the same value; instead, replace the shorthand with ' + 'separate values.', isValueEmpty(styleUpdates[originalKey]) ? 'Removing' : 'Updating', originalKey, correctOriginalKey);
      }
    }
  }
}

// For HTML, certain tags should omit their close tag. We keep a list for
// those special-case tags.
var omittedCloseTags = {
  area: true,
  base: true,
  br: true,
  col: true,
  embed: true,
  hr: true,
  img: true,
  input: true,
  keygen: true,
  link: true,
  meta: true,
  param: true,
  source: true,
  track: true,
  wbr: true // NOTE: menuitem's close tag should be omitted, but that causes problems.

};

// `omittedCloseTags` except that `menuitem` should still have its closing tag.

var voidElementTags = _assign({
  menuitem: true
}, omittedCloseTags);

var HTML = '__html';

function assertValidProps(tag, props) {
  if (!props) {
    return;
  } // Note the use of `==` which checks for null or undefined.


  if (voidElementTags[tag]) {
    if (!(props.children == null && props.dangerouslySetInnerHTML == null)) {
      {
        throw Error( tag + " is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`." );
      }
    }
  }

  if (props.dangerouslySetInnerHTML != null) {
    if (!(props.children == null)) {
      {
        throw Error( "Can only set one of `children` or `props.dangerouslySetInnerHTML`." );
      }
    }

    if (!(typeof props.dangerouslySetInnerHTML === 'object' && HTML in props.dangerouslySetInnerHTML)) {
      {
        throw Error( "`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://reactjs.org/link/dangerously-set-inner-html for more information." );
      }
    }
  }

  {
    if (!props.suppressContentEditableWarning && props.contentEditable && props.children != null) {
      error('A component is `contentEditable` and contains `children` managed by ' + 'React. It is now your responsibility to guarantee that none of ' + 'those nodes are unexpectedly modified or duplicated. This is ' + 'probably not intentional.');
    }
  }

  if (!(props.style == null || typeof props.style === 'object')) {
    {
      throw Error( "The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX." );
    }
  }
}

function isCustomComponent(tagName, props) {
  if (tagName.indexOf('-') === -1) {
    return typeof props.is === 'string';
  }

  switch (tagName) {
    // These are reserved SVG and MathML elements.
    // We don't mind this list too much because we expect it to never grow.
    // The alternative is to track the namespace in a few places which is convoluted.
    // https://w3c.github.io/webcomponents/spec/custom/#custom-elements-core-concepts
    case 'annotation-xml':
    case 'color-profile':
    case 'font-face':
    case 'font-face-src':
    case 'font-face-uri':
    case 'font-face-format':
    case 'font-face-name':
    case 'missing-glyph':
      return false;

    default:
      return true;
  }
}

// When adding attributes to the HTML or SVG allowed attribute list, be sure to
// also add them to this module to ensure casing and incorrect name
// warnings.
var possibleStandardNames = {
  // HTML
  accept: 'accept',
  acceptcharset: 'acceptCharset',
  'accept-charset': 'acceptCharset',
  accesskey: 'accessKey',
  action: 'action',
  allowfullscreen: 'allowFullScreen',
  alt: 'alt',
  as: 'as',
  async: 'async',
  autocapitalize: 'autoCapitalize',
  autocomplete: 'autoComplete',
  autocorrect: 'autoCorrect',
  autofocus: 'autoFocus',
  autoplay: 'autoPlay',
  autosave: 'autoSave',
  capture: 'capture',
  cellpadding: 'cellPadding',
  cellspacing: 'cellSpacing',
  challenge: 'challenge',
  charset: 'charSet',
  checked: 'checked',
  children: 'children',
  cite: 'cite',
  class: 'className',
  classid: 'classID',
  classname: 'className',
  cols: 'cols',
  colspan: 'colSpan',
  content: 'content',
  contenteditable: 'contentEditable',
  contextmenu: 'contextMenu',
  controls: 'controls',
  controlslist: 'controlsList',
  coords: 'coords',
  crossorigin: 'crossOrigin',
  dangerouslysetinnerhtml: 'dangerouslySetInnerHTML',
  data: 'data',
  datetime: 'dateTime',
  default: 'default',
  defaultchecked: 'defaultChecked',
  defaultvalue: 'defaultValue',
  defer: 'defer',
  dir: 'dir',
  disabled: 'disabled',
  disablepictureinpicture: 'disablePictureInPicture',
  disableremoteplayback: 'disableRemotePlayback',
  download: 'download',
  draggable: 'draggable',
  enctype: 'encType',
  enterkeyhint: 'enterKeyHint',
  for: 'htmlFor',
  form: 'form',
  formmethod: 'formMethod',
  formaction: 'formAction',
  formenctype: 'formEncType',
  formnovalidate: 'formNoValidate',
  formtarget: 'formTarget',
  frameborder: 'frameBorder',
  headers: 'headers',
  height: 'height',
  hidden: 'hidden',
  high: 'high',
  href: 'href',
  hreflang: 'hrefLang',
  htmlfor: 'htmlFor',
  httpequiv: 'httpEquiv',
  'http-equiv': 'httpEquiv',
  icon: 'icon',
  id: 'id',
  innerhtml: 'innerHTML',
  inputmode: 'inputMode',
  integrity: 'integrity',
  is: 'is',
  itemid: 'itemID',
  itemprop: 'itemProp',
  itemref: 'itemRef',
  itemscope: 'itemScope',
  itemtype: 'itemType',
  keyparams: 'keyParams',
  keytype: 'keyType',
  kind: 'kind',
  label: 'label',
  lang: 'lang',
  list: 'list',
  loop: 'loop',
  low: 'low',
  manifest: 'manifest',
  marginwidth: 'marginWidth',
  marginheight: 'marginHeight',
  max: 'max',
  maxlength: 'maxLength',
  media: 'media',
  mediagroup: 'mediaGroup',
  method: 'method',
  min: 'min',
  minlength: 'minLength',
  multiple: 'multiple',
  muted: 'muted',
  name: 'name',
  nomodule: 'noModule',
  nonce: 'nonce',
  novalidate: 'noValidate',
  open: 'open',
  optimum: 'optimum',
  pattern: 'pattern',
  placeholder: 'placeholder',
  playsinline: 'playsInline',
  poster: 'poster',
  preload: 'preload',
  profile: 'profile',
  radiogroup: 'radioGroup',
  readonly: 'readOnly',
  referrerpolicy: 'referrerPolicy',
  rel: 'rel',
  required: 'required',
  reversed: 'reversed',
  role: 'role',
  rows: 'rows',
  rowspan: 'rowSpan',
  sandbox: 'sandbox',
  scope: 'scope',
  scoped: 'scoped',
  scrolling: 'scrolling',
  seamless: 'seamless',
  selected: 'selected',
  shape: 'shape',
  size: 'size',
  sizes: 'sizes',
  span: 'span',
  spellcheck: 'spellCheck',
  src: 'src',
  srcdoc: 'srcDoc',
  srclang: 'srcLang',
  srcset: 'srcSet',
  start: 'start',
  step: 'step',
  style: 'style',
  summary: 'summary',
  tabindex: 'tabIndex',
  target: 'target',
  title: 'title',
  type: 'type',
  usemap: 'useMap',
  value: 'value',
  width: 'width',
  wmode: 'wmode',
  wrap: 'wrap',
  // SVG
  about: 'about',
  accentheight: 'accentHeight',
  'accent-height': 'accentHeight',
  accumulate: 'accumulate',
  additive: 'additive',
  alignmentbaseline: 'alignmentBaseline',
  'alignment-baseline': 'alignmentBaseline',
  allowreorder: 'allowReorder',
  alphabetic: 'alphabetic',
  amplitude: 'amplitude',
  arabicform: 'arabicForm',
  'arabic-form': 'arabicForm',
  ascent: 'ascent',
  attributename: 'attributeName',
  attributetype: 'attributeType',
  autoreverse: 'autoReverse',
  azimuth: 'azimuth',
  basefrequency: 'baseFrequency',
  baselineshift: 'baselineShift',
  'baseline-shift': 'baselineShift',
  baseprofile: 'baseProfile',
  bbox: 'bbox',
  begin: 'begin',
  bias: 'bias',
  by: 'by',
  calcmode: 'calcMode',
  capheight: 'capHeight',
  'cap-height': 'capHeight',
  clip: 'clip',
  clippath: 'clipPath',
  'clip-path': 'clipPath',
  clippathunits: 'clipPathUnits',
  cliprule: 'clipRule',
  'clip-rule': 'clipRule',
  color: 'color',
  colorinterpolation: 'colorInterpolation',
  'color-interpolation': 'colorInterpolation',
  colorinterpolationfilters: 'colorInterpolationFilters',
  'color-interpolation-filters': 'colorInterpolationFilters',
  colorprofile: 'colorProfile',
  'color-profile': 'colorProfile',
  colorrendering: 'colorRendering',
  'color-rendering': 'colorRendering',
  contentscripttype: 'contentScriptType',
  contentstyletype: 'contentStyleType',
  cursor: 'cursor',
  cx: 'cx',
  cy: 'cy',
  d: 'd',
  datatype: 'datatype',
  decelerate: 'decelerate',
  descent: 'descent',
  diffuseconstant: 'diffuseConstant',
  direction: 'direction',
  display: 'display',
  divisor: 'divisor',
  dominantbaseline: 'dominantBaseline',
  'dominant-baseline': 'dominantBaseline',
  dur: 'dur',
  dx: 'dx',
  dy: 'dy',
  edgemode: 'edgeMode',
  elevation: 'elevation',
  enablebackground: 'enableBackground',
  'enable-background': 'enableBackground',
  end: 'end',
  exponent: 'exponent',
  externalresourcesrequired: 'externalResourcesRequired',
  fill: 'fill',
  fillopacity: 'fillOpacity',
  'fill-opacity': 'fillOpacity',
  fillrule: 'fillRule',
  'fill-rule': 'fillRule',
  filter: 'filter',
  filterres: 'filterRes',
  filterunits: 'filterUnits',
  floodopacity: 'floodOpacity',
  'flood-opacity': 'floodOpacity',
  floodcolor: 'floodColor',
  'flood-color': 'floodColor',
  focusable: 'focusable',
  fontfamily: 'fontFamily',
  'font-family': 'fontFamily',
  fontsize: 'fontSize',
  'font-size': 'fontSize',
  fontsizeadjust: 'fontSizeAdjust',
  'font-size-adjust': 'fontSizeAdjust',
  fontstretch: 'fontStretch',
  'font-stretch': 'fontStretch',
  fontstyle: 'fontStyle',
  'font-style': 'fontStyle',
  fontvariant: 'fontVariant',
  'font-variant': 'fontVariant',
  fontweight: 'fontWeight',
  'font-weight': 'fontWeight',
  format: 'format',
  from: 'from',
  fx: 'fx',
  fy: 'fy',
  g1: 'g1',
  g2: 'g2',
  glyphname: 'glyphName',
  'glyph-name': 'glyphName',
  glyphorientationhorizontal: 'glyphOrientationHorizontal',
  'glyph-orientation-horizontal': 'glyphOrientationHorizontal',
  glyphorientationvertical: 'glyphOrientationVertical',
  'glyph-orientation-vertical': 'glyphOrientationVertical',
  glyphref: 'glyphRef',
  gradienttransform: 'gradientTransform',
  gradientunits: 'gradientUnits',
  hanging: 'hanging',
  horizadvx: 'horizAdvX',
  'horiz-adv-x': 'horizAdvX',
  horizoriginx: 'horizOriginX',
  'horiz-origin-x': 'horizOriginX',
  ideographic: 'ideographic',
  imagerendering: 'imageRendering',
  'image-rendering': 'imageRendering',
  in2: 'in2',
  in: 'in',
  inlist: 'inlist',
  intercept: 'intercept',
  k1: 'k1',
  k2: 'k2',
  k3: 'k3',
  k4: 'k4',
  k: 'k',
  kernelmatrix: 'kernelMatrix',
  kernelunitlength: 'kernelUnitLength',
  kerning: 'kerning',
  keypoints: 'keyPoints',
  keysplines: 'keySplines',
  keytimes: 'keyTimes',
  lengthadjust: 'lengthAdjust',
  letterspacing: 'letterSpacing',
  'letter-spacing': 'letterSpacing',
  lightingcolor: 'lightingColor',
  'lighting-color': 'lightingColor',
  limitingconeangle: 'limitingConeAngle',
  local: 'local',
  markerend: 'markerEnd',
  'marker-end': 'markerEnd',
  markerheight: 'markerHeight',
  markermid: 'markerMid',
  'marker-mid': 'markerMid',
  markerstart: 'markerStart',
  'marker-start': 'markerStart',
  markerunits: 'markerUnits',
  markerwidth: 'markerWidth',
  mask: 'mask',
  maskcontentunits: 'maskContentUnits',
  maskunits: 'maskUnits',
  mathematical: 'mathematical',
  mode: 'mode',
  numoctaves: 'numOctaves',
  offset: 'offset',
  opacity: 'opacity',
  operator: 'operator',
  order: 'order',
  orient: 'orient',
  orientation: 'orientation',
  origin: 'origin',
  overflow: 'overflow',
  overlineposition: 'overlinePosition',
  'overline-position': 'overlinePosition',
  overlinethickness: 'overlineThickness',
  'overline-thickness': 'overlineThickness',
  paintorder: 'paintOrder',
  'paint-order': 'paintOrder',
  panose1: 'panose1',
  'panose-1': 'panose1',
  pathlength: 'pathLength',
  patterncontentunits: 'patternContentUnits',
  patterntransform: 'patternTransform',
  patternunits: 'patternUnits',
  pointerevents: 'pointerEvents',
  'pointer-events': 'pointerEvents',
  points: 'points',
  pointsatx: 'pointsAtX',
  pointsaty: 'pointsAtY',
  pointsatz: 'pointsAtZ',
  prefix: 'prefix',
  preservealpha: 'preserveAlpha',
  preserveaspectratio: 'preserveAspectRatio',
  primitiveunits: 'primitiveUnits',
  property: 'property',
  r: 'r',
  radius: 'radius',
  refx: 'refX',
  refy: 'refY',
  renderingintent: 'renderingIntent',
  'rendering-intent': 'renderingIntent',
  repeatcount: 'repeatCount',
  repeatdur: 'repeatDur',
  requiredextensions: 'requiredExtensions',
  requiredfeatures: 'requiredFeatures',
  resource: 'resource',
  restart: 'restart',
  result: 'result',
  results: 'results',
  rotate: 'rotate',
  rx: 'rx',
  ry: 'ry',
  scale: 'scale',
  security: 'security',
  seed: 'seed',
  shaperendering: 'shapeRendering',
  'shape-rendering': 'shapeRendering',
  slope: 'slope',
  spacing: 'spacing',
  specularconstant: 'specularConstant',
  specularexponent: 'specularExponent',
  speed: 'speed',
  spreadmethod: 'spreadMethod',
  startoffset: 'startOffset',
  stddeviation: 'stdDeviation',
  stemh: 'stemh',
  stemv: 'stemv',
  stitchtiles: 'stitchTiles',
  stopcolor: 'stopColor',
  'stop-color': 'stopColor',
  stopopacity: 'stopOpacity',
  'stop-opacity': 'stopOpacity',
  strikethroughposition: 'strikethroughPosition',
  'strikethrough-position': 'strikethroughPosition',
  strikethroughthickness: 'strikethroughThickness',
  'strikethrough-thickness': 'strikethroughThickness',
  string: 'string',
  stroke: 'stroke',
  strokedasharray: 'strokeDasharray',
  'stroke-dasharray': 'strokeDasharray',
  strokedashoffset: 'strokeDashoffset',
  'stroke-dashoffset': 'strokeDashoffset',
  strokelinecap: 'strokeLinecap',
  'stroke-linecap': 'strokeLinecap',
  strokelinejoin: 'strokeLinejoin',
  'stroke-linejoin': 'strokeLinejoin',
  strokemiterlimit: 'strokeMiterlimit',
  'stroke-miterlimit': 'strokeMiterlimit',
  strokewidth: 'strokeWidth',
  'stroke-width': 'strokeWidth',
  strokeopacity: 'strokeOpacity',
  'stroke-opacity': 'strokeOpacity',
  suppresscontenteditablewarning: 'suppressContentEditableWarning',
  suppresshydrationwarning: 'suppressHydrationWarning',
  surfacescale: 'surfaceScale',
  systemlanguage: 'systemLanguage',
  tablevalues: 'tableValues',
  targetx: 'targetX',
  targety: 'targetY',
  textanchor: 'textAnchor',
  'text-anchor': 'textAnchor',
  textdecoration: 'textDecoration',
  'text-decoration': 'textDecoration',
  textlength: 'textLength',
  textrendering: 'textRendering',
  'text-rendering': 'textRendering',
  to: 'to',
  transform: 'transform',
  typeof: 'typeof',
  u1: 'u1',
  u2: 'u2',
  underlineposition: 'underlinePosition',
  'underline-position': 'underlinePosition',
  underlinethickness: 'underlineThickness',
  'underline-thickness': 'underlineThickness',
  unicode: 'unicode',
  unicodebidi: 'unicodeBidi',
  'unicode-bidi': 'unicodeBidi',
  unicoderange: 'unicodeRange',
  'unicode-range': 'unicodeRange',
  unitsperem: 'unitsPerEm',
  'units-per-em': 'unitsPerEm',
  unselectable: 'unselectable',
  valphabetic: 'vAlphabetic',
  'v-alphabetic': 'vAlphabetic',
  values: 'values',
  vectoreffect: 'vectorEffect',
  'vector-effect': 'vectorEffect',
  version: 'version',
  vertadvy: 'vertAdvY',
  'vert-adv-y': 'vertAdvY',
  vertoriginx: 'vertOriginX',
  'vert-origin-x': 'vertOriginX',
  vertoriginy: 'vertOriginY',
  'vert-origin-y': 'vertOriginY',
  vhanging: 'vHanging',
  'v-hanging': 'vHanging',
  videographic: 'vIdeographic',
  'v-ideographic': 'vIdeographic',
  viewbox: 'viewBox',
  viewtarget: 'viewTarget',
  visibility: 'visibility',
  vmathematical: 'vMathematical',
  'v-mathematical': 'vMathematical',
  vocab: 'vocab',
  widths: 'widths',
  wordspacing: 'wordSpacing',
  'word-spacing': 'wordSpacing',
  writingmode: 'writingMode',
  'writing-mode': 'writingMode',
  x1: 'x1',
  x2: 'x2',
  x: 'x',
  xchannelselector: 'xChannelSelector',
  xheight: 'xHeight',
  'x-height': 'xHeight',
  xlinkactuate: 'xlinkActuate',
  'xlink:actuate': 'xlinkActuate',
  xlinkarcrole: 'xlinkArcrole',
  'xlink:arcrole': 'xlinkArcrole',
  xlinkhref: 'xlinkHref',
  'xlink:href': 'xlinkHref',
  xlinkrole: 'xlinkRole',
  'xlink:role': 'xlinkRole',
  xlinkshow: 'xlinkShow',
  'xlink:show': 'xlinkShow',
  xlinktitle: 'xlinkTitle',
  'xlink:title': 'xlinkTitle',
  xlinktype: 'xlinkType',
  'xlink:type': 'xlinkType',
  xmlbase: 'xmlBase',
  'xml:base': 'xmlBase',
  xmllang: 'xmlLang',
  'xml:lang': 'xmlLang',
  xmlns: 'xmlns',
  'xml:space': 'xmlSpace',
  xmlnsxlink: 'xmlnsXlink',
  'xmlns:xlink': 'xmlnsXlink',
  xmlspace: 'xmlSpace',
  y1: 'y1',
  y2: 'y2',
  y: 'y',
  ychannelselector: 'yChannelSelector',
  z: 'z',
  zoomandpan: 'zoomAndPan'
};

var ariaProperties = {
  'aria-current': 0,
  // state
  'aria-details': 0,
  'aria-disabled': 0,
  // state
  'aria-hidden': 0,
  // state
  'aria-invalid': 0,
  // state
  'aria-keyshortcuts': 0,
  'aria-label': 0,
  'aria-roledescription': 0,
  // Widget Attributes
  'aria-autocomplete': 0,
  'aria-checked': 0,
  'aria-expanded': 0,
  'aria-haspopup': 0,
  'aria-level': 0,
  'aria-modal': 0,
  'aria-multiline': 0,
  'aria-multiselectable': 0,
  'aria-orientation': 0,
  'aria-placeholder': 0,
  'aria-pressed': 0,
  'aria-readonly': 0,
  'aria-required': 0,
  'aria-selected': 0,
  'aria-sort': 0,
  'aria-valuemax': 0,
  'aria-valuemin': 0,
  'aria-valuenow': 0,
  'aria-valuetext': 0,
  // Live Region Attributes
  'aria-atomic': 0,
  'aria-busy': 0,
  'aria-live': 0,
  'aria-relevant': 0,
  // Drag-and-Drop Attributes
  'aria-dropeffect': 0,
  'aria-grabbed': 0,
  // Relationship Attributes
  'aria-activedescendant': 0,
  'aria-colcount': 0,
  'aria-colindex': 0,
  'aria-colspan': 0,
  'aria-controls': 0,
  'aria-describedby': 0,
  'aria-errormessage': 0,
  'aria-flowto': 0,
  'aria-labelledby': 0,
  'aria-owns': 0,
  'aria-posinset': 0,
  'aria-rowcount': 0,
  'aria-rowindex': 0,
  'aria-rowspan': 0,
  'aria-setsize': 0
};

var warnedProperties = {};
var rARIA = new RegExp('^(aria)-[' + ATTRIBUTE_NAME_CHAR + ']*$');
var rARIACamel = new RegExp('^(aria)[A-Z][' + ATTRIBUTE_NAME_CHAR + ']*$');
var hasOwnProperty$1 = Object.prototype.hasOwnProperty;

function validateProperty(tagName, name) {
  {
    if (hasOwnProperty$1.call(warnedProperties, name) && warnedProperties[name]) {
      return true;
    }

    if (rARIACamel.test(name)) {
      var ariaName = 'aria-' + name.slice(4).toLowerCase();
      var correctName = ariaProperties.hasOwnProperty(ariaName) ? ariaName : null; // If this is an aria-* attribute, but is not listed in the known DOM
      // DOM properties, then it is an invalid aria-* attribute.

      if (correctName == null) {
        error('Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.', name);

        warnedProperties[name] = true;
        return true;
      } // aria-* attributes should be lowercase; suggest the lowercase version.


      if (name !== correctName) {
        error('Invalid ARIA attribute `%s`. Did you mean `%s`?', name, correctName);

        warnedProperties[name] = true;
        return true;
      }
    }

    if (rARIA.test(name)) {
      var lowerCasedName = name.toLowerCase();
      var standardName = ariaProperties.hasOwnProperty(lowerCasedName) ? lowerCasedName : null; // If this is an aria-* attribute, but is not listed in the known DOM
      // DOM properties, then it is an invalid aria-* attribute.

      if (standardName == null) {
        warnedProperties[name] = true;
        return false;
      } // aria-* attributes should be lowercase; suggest the lowercase version.


      if (name !== standardName) {
        error('Unknown ARIA attribute `%s`. Did you mean `%s`?', name, standardName);

        warnedProperties[name] = true;
        return true;
      }
    }
  }

  return true;
}

function warnInvalidARIAProps(type, props) {
  {
    var invalidProps = [];

    for (var key in props) {
      var isValid = validateProperty(type, key);

      if (!isValid) {
        invalidProps.push(key);
      }
    }

    var unknownPropString = invalidProps.map(function (prop) {
      return '`' + prop + '`';
    }).join(', ');

    if (invalidProps.length === 1) {
      error('Invalid aria prop %s on <%s> tag. ' + 'For details, see https://reactjs.org/link/invalid-aria-props', unknownPropString, type);
    } else if (invalidProps.length > 1) {
      error('Invalid aria props %s on <%s> tag. ' + 'For details, see https://reactjs.org/link/invalid-aria-props', unknownPropString, type);
    }
  }
}

function validateProperties(type, props) {
  if (isCustomComponent(type, props)) {
    return;
  }

  warnInvalidARIAProps(type, props);
}

var didWarnValueNull = false;
function validateProperties$1(type, props) {
  {
    if (type !== 'input' && type !== 'textarea' && type !== 'select') {
      return;
    }

    if (props != null && props.value === null && !didWarnValueNull) {
      didWarnValueNull = true;

      if (type === 'select' && props.multiple) {
        error('`value` prop on `%s` should not be null. ' + 'Consider using an empty array when `multiple` is set to `true` ' + 'to clear the component or `undefined` for uncontrolled components.', type);
      } else {
        error('`value` prop on `%s` should not be null. ' + 'Consider using an empty string to clear the component or `undefined` ' + 'for uncontrolled components.', type);
      }
    }
  }
}

var validateProperty$1 = function () {};

{
  var warnedProperties$1 = {};
  var _hasOwnProperty = Object.prototype.hasOwnProperty;
  var EVENT_NAME_REGEX = /^on./;
  var INVALID_EVENT_NAME_REGEX = /^on[^A-Z]/;
  var rARIA$1 = new RegExp('^(aria)-[' + ATTRIBUTE_NAME_CHAR + ']*$');
  var rARIACamel$1 = new RegExp('^(aria)[A-Z][' + ATTRIBUTE_NAME_CHAR + ']*$');

  validateProperty$1 = function (tagName, name, value, eventRegistry) {
    if (_hasOwnProperty.call(warnedProperties$1, name) && warnedProperties$1[name]) {
      return true;
    }

    var lowerCasedName = name.toLowerCase();

    if (lowerCasedName === 'onfocusin' || lowerCasedName === 'onfocusout') {
      error('React uses onFocus and onBlur instead of onFocusIn and onFocusOut. ' + 'All React events are normalized to bubble, so onFocusIn and onFocusOut ' + 'are not needed/supported by React.');

      warnedProperties$1[name] = true;
      return true;
    } // We can't rely on the event system being injected on the server.


    if (eventRegistry != null) {
      var registrationNameDependencies = eventRegistry.registrationNameDependencies,
          possibleRegistrationNames = eventRegistry.possibleRegistrationNames;

      if (registrationNameDependencies.hasOwnProperty(name)) {
        return true;
      }

      var registrationName = possibleRegistrationNames.hasOwnProperty(lowerCasedName) ? possibleRegistrationNames[lowerCasedName] : null;

      if (registrationName != null) {
        error('Invalid event handler property `%s`. Did you mean `%s`?', name, registrationName);

        warnedProperties$1[name] = true;
        return true;
      }

      if (EVENT_NAME_REGEX.test(name)) {
        error('Unknown event handler property `%s`. It will be ignored.', name);

        warnedProperties$1[name] = true;
        return true;
      }
    } else if (EVENT_NAME_REGEX.test(name)) {
      // If no event plugins have been injected, we are in a server environment.
      // So we can't tell if the event name is correct for sure, but we can filter
      // out known bad ones like `onclick`. We can't suggest a specific replacement though.
      if (INVALID_EVENT_NAME_REGEX.test(name)) {
        error('Invalid event handler property `%s`. ' + 'React events use the camelCase naming convention, for example `onClick`.', name);
      }

      warnedProperties$1[name] = true;
      return true;
    } // Let the ARIA attribute hook validate ARIA attributes


    if (rARIA$1.test(name) || rARIACamel$1.test(name)) {
      return true;
    }

    if (lowerCasedName === 'innerhtml') {
      error('Directly setting property `innerHTML` is not permitted. ' + 'For more information, lookup documentation on `dangerouslySetInnerHTML`.');

      warnedProperties$1[name] = true;
      return true;
    }

    if (lowerCasedName === 'aria') {
      error('The `aria` attribute is reserved for future use in React. ' + 'Pass individual `aria-` attributes instead.');

      warnedProperties$1[name] = true;
      return true;
    }

    if (lowerCasedName === 'is' && value !== null && value !== undefined && typeof value !== 'string') {
      error('Received a `%s` for a string attribute `is`. If this is expected, cast ' + 'the value to a string.', typeof value);

      warnedProperties$1[name] = true;
      return true;
    }

    if (typeof value === 'number' && isNaN(value)) {
      error('Received NaN for the `%s` attribute. If this is expected, cast ' + 'the value to a string.', name);

      warnedProperties$1[name] = true;
      return true;
    }

    var propertyInfo = getPropertyInfo(name);
    var isReserved = propertyInfo !== null && propertyInfo.type === RESERVED; // Known attributes should match the casing specified in the property config.

    if (possibleStandardNames.hasOwnProperty(lowerCasedName)) {
      var standardName = possibleStandardNames[lowerCasedName];

      if (standardName !== name) {
        error('Invalid DOM property `%s`. Did you mean `%s`?', name, standardName);

        warnedProperties$1[name] = true;
        return true;
      }
    } else if (!isReserved && name !== lowerCasedName) {
      // Unknown attributes should have lowercase casing since that's how they
      // will be cased anyway with server rendering.
      error('React does not recognize the `%s` prop on a DOM element. If you ' + 'intentionally want it to appear in the DOM as a custom ' + 'attribute, spell it as lowercase `%s` instead. ' + 'If you accidentally passed it from a parent component, remove ' + 'it from the DOM element.', name, lowerCasedName);

      warnedProperties$1[name] = true;
      return true;
    }

    if (typeof value === 'boolean' && shouldRemoveAttributeWithWarning(name, value, propertyInfo, false)) {
      if (value) {
        error('Received `%s` for a non-boolean attribute `%s`.\n\n' + 'If you want to write it to the DOM, pass a string instead: ' + '%s="%s" or %s={value.toString()}.', value, name, name, value, name);
      } else {
        error('Received `%s` for a non-boolean attribute `%s`.\n\n' + 'If you want to write it to the DOM, pass a string instead: ' + '%s="%s" or %s={value.toString()}.\n\n' + 'If you used to conditionally omit it with %s={condition && value}, ' + 'pass %s={condition ? value : undefined} instead.', value, name, name, value, name, name, name);
      }

      warnedProperties$1[name] = true;
      return true;
    } // Now that we've validated casing, do not validate
    // data types for reserved props


    if (isReserved) {
      return true;
    } // Warn when a known attribute is a bad type


    if (shouldRemoveAttributeWithWarning(name, value, propertyInfo, false)) {
      warnedProperties$1[name] = true;
      return false;
    } // Warn when passing the strings 'false' or 'true' into a boolean prop


    if ((value === 'false' || value === 'true') && propertyInfo !== null && propertyInfo.type === BOOLEAN) {
      error('Received the string `%s` for the boolean attribute `%s`. ' + '%s ' + 'Did you mean %s={%s}?', value, name, value === 'false' ? 'The browser will interpret it as a truthy value.' : 'Although this works, it will not work as expected if you pass the string "false".', name, value);

      warnedProperties$1[name] = true;
      return true;
    }

    return true;
  };
}

var warnUnknownProperties = function (type, props, eventRegistry) {
  {
    var unknownProps = [];

    for (var key in props) {
      var isValid = validateProperty$1(type, key, props[key], eventRegistry);

      if (!isValid) {
        unknownProps.push(key);
      }
    }

    var unknownPropString = unknownProps.map(function (prop) {
      return '`' + prop + '`';
    }).join(', ');

    if (unknownProps.length === 1) {
      error('Invalid value for prop %s on <%s> tag. Either remove it from the element, ' + 'or pass a string or number value to keep it in the DOM. ' + 'For details, see https://reactjs.org/link/attribute-behavior ', unknownPropString, type);
    } else if (unknownProps.length > 1) {
      error('Invalid values for props %s on <%s> tag. Either remove them from the element, ' + 'or pass a string or number value to keep them in the DOM. ' + 'For details, see https://reactjs.org/link/attribute-behavior ', unknownPropString, type);
    }
  }
};

function validateProperties$2(type, props, eventRegistry) {
  if (isCustomComponent(type, props)) {
    return;
  }

  warnUnknownProperties(type, props, eventRegistry);
}

var IS_EVENT_HANDLE_NON_MANAGED_NODE = 1;
var IS_NON_DELEGATED = 1 << 1;
var IS_CAPTURE_PHASE = 1 << 2;
var IS_REPLAYED = 1 << 4;
// set to LEGACY_FB_SUPPORT. LEGACY_FB_SUPPORT only gets set when
// we call willDeferLaterForLegacyFBSupport, thus not bailing out
// will result in endless cycles like an infinite loop.
// We also don't want to defer during event replaying.

var SHOULD_NOT_PROCESS_POLYFILL_EVENT_PLUGINS = IS_EVENT_HANDLE_NON_MANAGED_NODE | IS_NON_DELEGATED | IS_CAPTURE_PHASE;

/**
 * Gets the target node from a native browser event by accounting for
 * inconsistencies in browser DOM APIs.
 *
 * @param {object} nativeEvent Native browser event.
 * @return {DOMEventTarget} Target node.
 */

function getEventTarget(nativeEvent) {
  // Fallback to nativeEvent.srcElement for IE9
  // https://github.com/facebook/react/issues/12506
  var target = nativeEvent.target || nativeEvent.srcElement || window; // Normalize SVG <use> element events #4963

  if (target.correspondingUseElement) {
    target = target.correspondingUseElement;
  } // Safari may fire events on text nodes (Node.TEXT_NODE is 3).
  // @see http://www.quirksmode.org/js/events_properties.html


  return target.nodeType === TEXT_NODE ? target.parentNode : target;
}

var restoreImpl = null;
var restoreTarget = null;
var restoreQueue = null;

function restoreStateOfTarget(target) {
  // We perform this translation at the end of the event loop so that we
  // always receive the correct fiber here
  var internalInstance = getInstanceFromNode(target);

  if (!internalInstance) {
    // Unmounted
    return;
  }

  if (!(typeof restoreImpl === 'function')) {
    {
      throw Error( "setRestoreImplementation() needs to be called to handle a target for controlled events. This error is likely caused by a bug in React. Please file an issue." );
    }
  }

  var stateNode = internalInstance.stateNode; // Guard against Fiber being unmounted.

  if (stateNode) {
    var _props = getFiberCurrentPropsFromNode(stateNode);

    restoreImpl(internalInstance.stateNode, internalInstance.type, _props);
  }
}

function setRestoreImplementation(impl) {
  restoreImpl = impl;
}
function enqueueStateRestore(target) {
  if (restoreTarget) {
    if (restoreQueue) {
      restoreQueue.push(target);
    } else {
      restoreQueue = [target];
    }
  } else {
    restoreTarget = target;
  }
}
function needsStateRestore() {
  return restoreTarget !== null || restoreQueue !== null;
}
function restoreStateIfNeeded() {
  if (!restoreTarget) {
    return;
  }

  var target = restoreTarget;
  var queuedTargets = restoreQueue;
  restoreTarget = null;
  restoreQueue = null;
  restoreStateOfTarget(target);

  if (queuedTargets) {
    for (var i = 0; i < queuedTargets.length; i++) {
      restoreStateOfTarget(queuedTargets[i]);
    }
  }
}

// the renderer. Such as when we're dispatching events or if third party
// libraries need to call batchedUpdates. Eventually, this API will go away when
// everything is batched by default. We'll then have a similar API to opt-out of
// scheduled work and instead do synchronous work.
// Defaults

var batchedUpdatesImpl = function (fn, bookkeeping) {
  return fn(bookkeeping);
};

var discreteUpdatesImpl = function (fn, a, b, c, d) {
  return fn(a, b, c, d);
};

var flushDiscreteUpdatesImpl = function () {};

var batchedEventUpdatesImpl = batchedUpdatesImpl;
var isInsideEventHandler = false;
var isBatchingEventUpdates = false;

function finishEventHandler() {
  // Here we wait until all updates have propagated, which is important
  // when using controlled components within layers:
  // https://github.com/facebook/react/issues/1698
  // Then we restore state of any controlled component.
  var controlledComponentsHavePendingUpdates = needsStateRestore();

  if (controlledComponentsHavePendingUpdates) {
    // If a controlled event was fired, we may need to restore the state of
    // the DOM node back to the controlled value. This is necessary when React
    // bails out of the update without touching the DOM.
    flushDiscreteUpdatesImpl();
    restoreStateIfNeeded();
  }
}

function batchedUpdates(fn, bookkeeping) {
  if (isInsideEventHandler) {
    // If we are currently inside another batch, we need to wait until it
    // fully completes before restoring state.
    return fn(bookkeeping);
  }

  isInsideEventHandler = true;

  try {
    return batchedUpdatesImpl(fn, bookkeeping);
  } finally {
    isInsideEventHandler = false;
    finishEventHandler();
  }
}
function batchedEventUpdates(fn, a, b) {
  if (isBatchingEventUpdates) {
    // If we are currently inside another batch, we need to wait until it
    // fully completes before restoring state.
    return fn(a, b);
  }

  isBatchingEventUpdates = true;

  try {
    return batchedEventUpdatesImpl(fn, a, b);
  } finally {
    isBatchingEventUpdates = false;
    finishEventHandler();
  }
}
function discreteUpdates(fn, a, b, c, d) {
  var prevIsInsideEventHandler = isInsideEventHandler;
  isInsideEventHandler = true;

  try {
    return discreteUpdatesImpl(fn, a, b, c, d);
  } finally {
    isInsideEventHandler = prevIsInsideEventHandler;

    if (!isInsideEventHandler) {
      finishEventHandler();
    }
  }
}
function flushDiscreteUpdatesIfNeeded(timeStamp) {
  {
    if (!isInsideEventHandler) {
      flushDiscreteUpdatesImpl();
    }
  }
}
function setBatchingImplementation(_batchedUpdatesImpl, _discreteUpdatesImpl, _flushDiscreteUpdatesImpl, _batchedEventUpdatesImpl) {
  batchedUpdatesImpl = _batchedUpdatesImpl;
  discreteUpdatesImpl = _discreteUpdatesImpl;
  flushDiscreteUpdatesImpl = _flushDiscreteUpdatesImpl;
  batchedEventUpdatesImpl = _batchedEventUpdatesImpl;
}

function isInteractive(tag) {
  return tag === 'button' || tag === 'input' || tag === 'select' || tag === 'textarea';
}

function shouldPreventMouseEvent(name, type, props) {
  switch (name) {
    case 'onClick':
    case 'onClickCapture':
    case 'onDoubleClick':
    case 'onDoubleClickCapture':
    case 'onMouseDown':
    case 'onMouseDownCapture':
    case 'onMouseMove':
    case 'onMouseMoveCapture':
    case 'onMouseUp':
    case 'onMouseUpCapture':
    case 'onMouseEnter':
      return !!(props.disabled && isInteractive(type));

    default:
      return false;
  }
}
/**
 * @param {object} inst The instance, which is the source of events.
 * @param {string} registrationName Name of listener (e.g. `onClick`).
 * @return {?function} The stored callback.
 */


function getListener(inst, registrationName) {
  var stateNode = inst.stateNode;

  if (stateNode === null) {
    // Work in progress (ex: onload events in incremental mode).
    return null;
  }

  var props = getFiberCurrentPropsFromNode(stateNode);

  if (props === null) {
    // Work in progress.
    return null;
  }

  var listener = props[registrationName];

  if (shouldPreventMouseEvent(registrationName, inst.type, props)) {
    return null;
  }

  if (!(!listener || typeof listener === 'function')) {
    {
      throw Error( "Expected `" + registrationName + "` listener to be a function, instead got a value of `" + typeof listener + "` type." );
    }
  }

  return listener;
}

var passiveBrowserEventsSupported = false; // Check if browser support events with passive listeners
// https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#Safely_detecting_option_support

if (canUseDOM) {
  try {
    var options = {}; // $FlowFixMe: Ignore Flow complaining about needing a value

    Object.defineProperty(options, 'passive', {
      get: function () {
        passiveBrowserEventsSupported = true;
      }
    });
    window.addEventListener('test', options, options);
    window.removeEventListener('test', options, options);
  } catch (e) {
    passiveBrowserEventsSupported = false;
  }
}

function invokeGuardedCallbackProd(name, func, context, a, b, c, d, e, f) {
  var funcArgs = Array.prototype.slice.call(arguments, 3);

  try {
    func.apply(context, funcArgs);
  } catch (error) {
    this.onError(error);
  }
}

var invokeGuardedCallbackImpl = invokeGuardedCallbackProd;

{
  // In DEV mode, we swap out invokeGuardedCallback for a special version
  // that plays more nicely with the browser's DevTools. The idea is to preserve
  // "Pause on exceptions" behavior. Because React wraps all user-provided
  // functions in invokeGuardedCallback, and the production version of
  // invokeGuardedCallback uses a try-catch, all user exceptions are treated
  // like caught exceptions, and the DevTools won't pause unless the developer
  // takes the extra step of enabling pause on caught exceptions. This is
  // unintuitive, though, because even though React has caught the error, from
  // the developer's perspective, the error is uncaught.
  //
  // To preserve the expected "Pause on exceptions" behavior, we don't use a
  // try-catch in DEV. Instead, we synchronously dispatch a fake event to a fake
  // DOM node, and call the user-provided callback from inside an event handler
  // for that fake event. If the callback throws, the error is "captured" using
  // a global event handler. But because the error happens in a different
  // event loop context, it does not interrupt the normal program flow.
  // Effectively, this gives us try-catch behavior without actually using
  // try-catch. Neat!
  // Check that the browser supports the APIs we need to implement our special
  // DEV version of invokeGuardedCallback
  if (typeof window !== 'undefined' && typeof window.dispatchEvent === 'function' && typeof document !== 'undefined' && typeof document.createEvent === 'function') {
    var fakeNode = document.createElement('react');

    invokeGuardedCallbackImpl = function invokeGuardedCallbackDev(name, func, context, a, b, c, d, e, f) {
      // If document doesn't exist we know for sure we will crash in this method
      // when we call document.createEvent(). However this can cause confusing
      // errors: https://github.com/facebookincubator/create-react-app/issues/3482
      // So we preemptively throw with a better message instead.
      if (!(typeof document !== 'undefined')) {
        {
          throw Error( "The `document` global was defined when React was initialized, but is not defined anymore. This can happen in a test environment if a component schedules an update from an asynchronous callback, but the test has already finished running. To solve this, you can either unmount the component at the end of your test (and ensure that any asynchronous operations get canceled in `componentWillUnmount`), or you can change the test itself to be asynchronous." );
        }
      }

      var evt = document.createEvent('Event');
      var didCall = false; // Keeps track of whether the user-provided callback threw an error. We
      // set this to true at the beginning, then set it to false right after
      // calling the function. If the function errors, `didError` will never be
      // set to false. This strategy works even if the browser is flaky and
      // fails to call our global error handler, because it doesn't rely on
      // the error event at all.

      var didError = true; // Keeps track of the value of window.event so that we can reset it
      // during the callback to let user code access window.event in the
      // browsers that support it.

      var windowEvent = window.event; // Keeps track of the descriptor of window.event to restore it after event
      // dispatching: https://github.com/facebook/react/issues/13688

      var windowEventDescriptor = Object.getOwnPropertyDescriptor(window, 'event');

      function restoreAfterDispatch() {
        // We immediately remove the callback from event listeners so that
        // nested `invokeGuardedCallback` calls do not clash. Otherwise, a
        // nested call would trigger the fake event handlers of any call higher
        // in the stack.
        fakeNode.removeEventListener(evtType, callCallback, false); // We check for window.hasOwnProperty('event') to prevent the
        // window.event assignment in both IE <= 10 as they throw an error
        // "Member not found" in strict mode, and in Firefox which does not
        // support window.event.

        if (typeof window.event !== 'undefined' && window.hasOwnProperty('event')) {
          window.event = windowEvent;
        }
      } // Create an event handler for our fake event. We will synchronously
      // dispatch our fake event using `dispatchEvent`. Inside the handler, we
      // call the user-provided callback.


      var funcArgs = Array.prototype.slice.call(arguments, 3);

      function callCallback() {
        didCall = true;
        restoreAfterDispatch();
        func.apply(context, funcArgs);
        didError = false;
      } // Create a global error event handler. We use this to capture the value
      // that was thrown. It's possible that this error handler will fire more
      // than once; for example, if non-React code also calls `dispatchEvent`
      // and a handler for that event throws. We should be resilient to most of
      // those cases. Even if our error event handler fires more than once, the
      // last error event is always used. If the callback actually does error,
      // we know that the last error event is the correct one, because it's not
      // possible for anything else to have happened in between our callback
      // erroring and the code that follows the `dispatchEvent` call below. If
      // the callback doesn't error, but the error event was fired, we know to
      // ignore it because `didError` will be false, as described above.


      var error; // Use this to track whether the error event is ever called.

      var didSetError = false;
      var isCrossOriginError = false;

      function handleWindowError(event) {
        error = event.error;
        didSetError = true;

        if (error === null && event.colno === 0 && event.lineno === 0) {
          isCrossOriginError = true;
        }

        if (event.defaultPrevented) {
          // Some other error handler has prevented default.
          // Browsers silence the error report if this happens.
          // We'll remember this to later decide whether to log it or not.
          if (error != null && typeof error === 'object') {
            try {
              error._suppressLogging = true;
            } catch (inner) {// Ignore.
            }
          }
        }
      } // Create a fake event type.


      var evtType = "react-" + (name ? name : 'invokeguardedcallback'); // Attach our event handlers

      window.addEventListener('error', handleWindowError);
      fakeNode.addEventListener(evtType, callCallback, false); // Synchronously dispatch our fake event. If the user-provided function
      // errors, it will trigger our global error handler.

      evt.initEvent(evtType, false, false);
      fakeNode.dispatchEvent(evt);

      if (windowEventDescriptor) {
        Object.defineProperty(window, 'event', windowEventDescriptor);
      }

      if (didCall && didError) {
        if (!didSetError) {
          // The callback errored, but the error event never fired.
          error = new Error('An error was thrown inside one of your components, but React ' + "doesn't know what it was. This is likely due to browser " + 'flakiness. React does its best to preserve the "Pause on ' + 'exceptions" behavior of the DevTools, which requires some ' + "DEV-mode only tricks. It's possible that these don't work in " + 'your browser. Try triggering the error in production mode, ' + 'or switching to a modern browser. If you suspect that this is ' + 'actually an issue with React, please file an issue.');
        } else if (isCrossOriginError) {
          error = new Error("A cross-origin error was thrown. React doesn't have access to " + 'the actual error object in development. ' + 'See https://reactjs.org/link/crossorigin-error for more information.');
        }

        this.onError(error);
      } // Remove our event listeners


      window.removeEventListener('error', handleWindowError);

      if (!didCall) {
        // Something went really wrong, and our event was not dispatched.
        // https://github.com/facebook/react/issues/16734
        // https://github.com/facebook/react/issues/16585
        // Fall back to the production implementation.
        restoreAfterDispatch();
        return invokeGuardedCallbackProd.apply(this, arguments);
      }
    };
  }
}

var invokeGuardedCallbackImpl$1 = invokeGuardedCallbackImpl;

var hasError = false;
var caughtError = null; // Used by event system to capture/rethrow the first error.

var hasRethrowError = false;
var rethrowError = null;
var reporter = {
  onError: function (error) {
    hasError = true;
    caughtError = error;
  }
};
/**
 * Call a function while guarding against errors that happens within it.
 * Returns an error if it throws, otherwise null.
 *
 * In production, this is implemented using a try-catch. The reason we don't
 * use a try-catch directly is so that we can swap out a different
 * implementation in DEV mode.
 *
 * @param {String} name of the guard to use for logging or debugging
 * @param {Function} func The function to invoke
 * @param {*} context The context to use when calling the function
 * @param {...*} args Arguments for function
 */

function invokeGuardedCallback(name, func, context, a, b, c, d, e, f) {
  hasError = false;
  caughtError = null;
  invokeGuardedCallbackImpl$1.apply(reporter, arguments);
}
/**
 * Same as invokeGuardedCallback, but instead of returning an error, it stores
 * it in a global so it can be rethrown by `rethrowCaughtError` later.
 * TODO: See if caughtError and rethrowError can be unified.
 *
 * @param {String} name of the guard to use for logging or debugging
 * @param {Function} func The function to invoke
 * @param {*} context The context to use when calling the function
 * @param {...*} args Arguments for function
 */

function invokeGuardedCallbackAndCatchFirstError(name, func, context, a, b, c, d, e, f) {
  invokeGuardedCallback.apply(this, arguments);

  if (hasError) {
    var error = clearCaughtError();

    if (!hasRethrowError) {
      hasRethrowError = true;
      rethrowError = error;
    }
  }
}
/**
 * During execution of guarded functions we will capture the first error which
 * we will rethrow to be handled by the top level error handler.
 */

function rethrowCaughtError() {
  if (hasRethrowError) {
    var error = rethrowError;
    hasRethrowError = false;
    rethrowError = null;
    throw error;
  }
}
function hasCaughtError() {
  return hasError;
}
function clearCaughtError() {
  if (hasError) {
    var error = caughtError;
    hasError = false;
    caughtError = null;
    return error;
  } else {
    {
      {
        throw Error( "clearCaughtError was called but no error was captured. This error is likely caused by a bug in React. Please file an issue." );
      }
    }
  }
}

/**
 * `ReactInstanceMap` maintains a mapping from a public facing stateful
 * instance (key) and the internal representation (value). This allows public
 * methods to accept the user facing instance as an argument and map them back
 * to internal methods.
 *
 * Note that this module is currently shared and assumed to be stateless.
 * If this becomes an actual Map, that will break.
 */
function get(key) {
  return key._reactInternals;
}
function has(key) {
  return key._reactInternals !== undefined;
}
function set(key, value) {
  key._reactInternals = value;
}

// Don't change these two values. They're used by React Dev Tools.
var NoFlags =
/*                      */
0;
var PerformedWork =
/*                */
1; // You can change the rest (and add more).

var Placement =
/*                    */
2;
var Update =
/*                       */
4;
var PlacementAndUpdate =
/*           */
6;
var Deletion =
/*                     */
8;
var ContentReset =
/*                 */
16;
var Callback =
/*                     */
32;
var DidCapture =
/*                   */
64;
var Ref =
/*                          */
128;
var Snapshot =
/*                     */
256;
var Passive =
/*                      */
512; // TODO (effects) Remove this bit once the new reconciler is synced to the old.

var PassiveUnmountPendingDev =
/*     */
8192;
var Hydrating =
/*                    */
1024;
var HydratingAndUpdate =
/*           */
1028; // Passive & Update & Callback & Ref & Snapshot

var LifecycleEffectMask =
/*          */
932; // Union of all host effects

var HostEffectMask =
/*               */
2047; // These are not really side effects, but we still reuse this field.

var Incomplete =
/*                   */
2048;
var ShouldCapture =
/*                */
4096;
var ForceUpdateForLegacySuspense =
/* */
16384; // Static tags describe aspects of a fiber that are not specific to a render,

var ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;
function getNearestMountedFiber(fiber) {
  var node = fiber;
  var nearestMounted = fiber;

  if (!fiber.alternate) {
    // If there is no alternate, this might be a new tree that isn't inserted
    // yet. If it is, then it will have a pending insertion effect on it.
    var nextNode = node;

    do {
      node = nextNode;

      if ((node.flags & (Placement | Hydrating)) !== NoFlags) {
        // This is an insertion or in-progress hydration. The nearest possible
        // mounted fiber is the parent but we need to continue to figure out
        // if that one is still mounted.
        nearestMounted = node.return;
      }

      nextNode = node.return;
    } while (nextNode);
  } else {
    while (node.return) {
      node = node.return;
    }
  }

  if (node.tag === HostRoot) {
    // TODO: Check if this was a nested HostRoot when used with
    // renderContainerIntoSubtree.
    return nearestMounted;
  } // If we didn't hit the root, that means that we're in an disconnected tree
  // that has been unmounted.


  return null;
}
function getSuspenseInstanceFromFiber(fiber) {
  if (fiber.tag === SuspenseComponent) {
    var suspenseState = fiber.memoizedState;

    if (suspenseState === null) {
      var current = fiber.alternate;

      if (current !== null) {
        suspenseState = current.memoizedState;
      }
    }

    if (suspenseState !== null) {
      return suspenseState.dehydrated;
    }
  }

  return null;
}
function getContainerFromFiber(fiber) {
  return fiber.tag === HostRoot ? fiber.stateNode.containerInfo : null;
}
function isFiberMounted(fiber) {
  return getNearestMountedFiber(fiber) === fiber;
}
function isMounted(component) {
  {
    var owner = ReactCurrentOwner.current;

    if (owner !== null && owner.tag === ClassComponent) {
      var ownerFiber = owner;
      var instance = ownerFiber.stateNode;

      if (!instance._warnedAboutRefsInRender) {
        error('%s is accessing isMounted inside its render() function. ' + 'render() should be a pure function of props and state. It should ' + 'never access something that requires stale data from the previous ' + 'render, such as refs. Move this logic to componentDidMount and ' + 'componentDidUpdate instead.', getComponentName(ownerFiber.type) || 'A component');
      }

      instance._warnedAboutRefsInRender = true;
    }
  }

  var fiber = get(component);

  if (!fiber) {
    return false;
  }

  return getNearestMountedFiber(fiber) === fiber;
}

function assertIsMounted(fiber) {
  if (!(getNearestMountedFiber(fiber) === fiber)) {
    {
      throw Error( "Unable to find node on an unmounted component." );
    }
  }
}

function findCurrentFiberUsingSlowPath(fiber) {
  var alternate = fiber.alternate;

  if (!alternate) {
    // If there is no alternate, then we only need to check if it is mounted.
    var nearestMounted = getNearestMountedFiber(fiber);

    if (!(nearestMounted !== null)) {
      {
        throw Error( "Unable to find node on an unmounted component." );
      }
    }

    if (nearestMounted !== fiber) {
      return null;
    }

    return fiber;
  } // If we have two possible branches, we'll walk backwards up to the root
  // to see what path the root points to. On the way we may hit one of the
  // special cases and we'll deal with them.


  var a = fiber;
  var b = alternate;

  while (true) {
    var parentA = a.return;

    if (parentA === null) {
      // We're at the root.
      break;
    }

    var parentB = parentA.alternate;

    if (parentB === null) {
      // There is no alternate. This is an unusual case. Currently, it only
      // happens when a Suspense component is hidden. An extra fragment fiber
      // is inserted in between the Suspense fiber and its children. Skip
      // over this extra fragment fiber and proceed to the next parent.
      var nextParent = parentA.return;

      if (nextParent !== null) {
        a = b = nextParent;
        continue;
      } // If there's no parent, we're at the root.


      break;
    } // If both copies of the parent fiber point to the same child, we can
    // assume that the child is current. This happens when we bailout on low
    // priority: the bailed out fiber's child reuses the current child.


    if (parentA.child === parentB.child) {
      var child = parentA.child;

      while (child) {
        if (child === a) {
          // We've determined that A is the current branch.
          assertIsMounted(parentA);
          return fiber;
        }

        if (child === b) {
          // We've determined that B is the current branch.
          assertIsMounted(parentA);
          return alternate;
        }

        child = child.sibling;
      } // We should never have an alternate for any mounting node. So the only
      // way this could possibly happen is if this was unmounted, if at all.


      {
        {
          throw Error( "Unable to find node on an unmounted component." );
        }
      }
    }

    if (a.return !== b.return) {
      // The return pointer of A and the return pointer of B point to different
      // fibers. We assume that return pointers never criss-cross, so A must
      // belong to the child set of A.return, and B must belong to the child
      // set of B.return.
      a = parentA;
      b = parentB;
    } else {
      // The return pointers point to the same fiber. We'll have to use the
      // default, slow path: scan the child sets of each parent alternate to see
      // which child belongs to which set.
      //
      // Search parent A's child set
      var didFindChild = false;
      var _child = parentA.child;

      while (_child) {
        if (_child === a) {
          didFindChild = true;
          a = parentA;
          b = parentB;
          break;
        }

        if (_child === b) {
          didFindChild = true;
          b = parentA;
          a = parentB;
          break;
        }

        _child = _child.sibling;
      }

      if (!didFindChild) {
        // Search parent B's child set
        _child = parentB.child;

        while (_child) {
          if (_child === a) {
            didFindChild = true;
            a = parentB;
            b = parentA;
            break;
          }

          if (_child === b) {
            didFindChild = true;
            b = parentB;
            a = parentA;
            break;
          }

          _child = _child.sibling;
        }

        if (!didFindChild) {
          {
            throw Error( "Child was not found in either parent set. This indicates a bug in React related to the return pointer. Please file an issue." );
          }
        }
      }
    }

    if (!(a.alternate === b)) {
      {
        throw Error( "Return fibers should always be each others' alternates. This error is likely caused by a bug in React. Please file an issue." );
      }
    }
  } // If the root is not a host container, we're in a disconnected tree. I.e.
  // unmounted.


  if (!(a.tag === HostRoot)) {
    {
      throw Error( "Unable to find node on an unmounted component." );
    }
  }

  if (a.stateNode.current === a) {
    // We've determined that A is the current branch.
    return fiber;
  } // Otherwise B has to be current branch.


  return alternate;
}
function findCurrentHostFiber(parent) {
  var currentParent = findCurrentFiberUsingSlowPath(parent);

  if (!currentParent) {
    return null;
  } // Next we'll drill down this component to find the first HostComponent/Text.


  var node = currentParent;

  while (true) {
    if (node.tag === HostComponent || node.tag === HostText) {
      return node;
    } else if (node.child) {
      node.child.return = node;
      node = node.child;
      continue;
    }

    if (node === currentParent) {
      return null;
    }

    while (!node.sibling) {
      if (!node.return || node.return === currentParent) {
        return null;
      }

      node = node.return;
    }

    node.sibling.return = node.return;
    node = node.sibling;
  } // Flow needs the return null here, but ESLint complains about it.
  // eslint-disable-next-line no-unreachable


  return null;
}
function findCurrentHostFiberWithNoPortals(parent) {
  var currentParent = findCurrentFiberUsingSlowPath(parent);

  if (!currentParent) {
    return null;
  } // Next we'll drill down this component to find the first HostComponent/Text.


  var node = currentParent;

  while (true) {
    if (node.tag === HostComponent || node.tag === HostText || enableFundamentalAPI ) {
      return node;
    } else if (node.child && node.tag !== HostPortal) {
      node.child.return = node;
      node = node.child;
      continue;
    }

    if (node === currentParent) {
      return null;
    }

    while (!node.sibling) {
      if (!node.return || node.return === currentParent) {
        return null;
      }

      node = node.return;
    }

    node.sibling.return = node.return;
    node = node.sibling;
  } // Flow needs the return null here, but ESLint complains about it.
  // eslint-disable-next-line no-unreachable


  return null;
}
function doesFiberContain(parentFiber, childFiber) {
  var node = childFiber;
  var parentFiberAlternate = parentFiber.alternate;

  while (node !== null) {
    if (node === parentFiber || node === parentFiberAlternate) {
      return true;
    }

    node = node.return;
  }

  return false;
}

var attemptUserBlockingHydration;
function setAttemptUserBlockingHydration(fn) {
  attemptUserBlockingHydration = fn;
}
var attemptContinuousHydration;
function setAttemptContinuousHydration(fn) {
  attemptContinuousHydration = fn;
}
var attemptHydrationAtCurrentPriority;
function setAttemptHydrationAtCurrentPriority(fn) {
  attemptHydrationAtCurrentPriority = fn;
}
var attemptHydrationAtPriority;
function setAttemptHydrationAtPriority(fn) {
  attemptHydrationAtPriority = fn;
} // TODO: Upgrade this definition once we're on a newer version of Flow that
var hasScheduledReplayAttempt = false; // The queue of discrete events to be replayed.

var queuedDiscreteEvents = []; // Indicates if any continuous event targets are non-null for early bailout.
// if the last target was dehydrated.

var queuedFocus = null;
var queuedDrag = null;
var queuedMouse = null; // For pointer events there can be one latest event per pointerId.

var queuedPointers = new Map();
var queuedPointerCaptures = new Map(); // We could consider replaying selectionchange and touchmoves too.

var queuedExplicitHydrationTargets = [];
function hasQueuedDiscreteEvents() {
  return queuedDiscreteEvents.length > 0;
}
var discreteReplayableEvents = ['mousedown', 'mouseup', 'touchcancel', 'touchend', 'touchstart', 'auxclick', 'dblclick', 'pointercancel', 'pointerdown', 'pointerup', 'dragend', 'dragstart', 'drop', 'compositionend', 'compositionstart', 'keydown', 'keypress', 'keyup', 'input', 'textInput', // Intentionally camelCase
'copy', 'cut', 'paste', 'click', 'change', 'contextmenu', 'reset', 'submit'];
function isReplayableDiscreteEvent(eventType) {
  return discreteReplayableEvents.indexOf(eventType) > -1;
}

function createQueuedReplayableEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent) {
  return {
    blockedOn: blockedOn,
    domEventName: domEventName,
    eventSystemFlags: eventSystemFlags | IS_REPLAYED,
    nativeEvent: nativeEvent,
    targetContainers: [targetContainer]
  };
}

function queueDiscreteEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent) {
  var queuedEvent = createQueuedReplayableEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent);
  queuedDiscreteEvents.push(queuedEvent);
} // Resets the replaying for this type of continuous event to no event.

function clearIfContinuousEvent(domEventName, nativeEvent) {
  switch (domEventName) {
    case 'focusin':
    case 'focusout':
      queuedFocus = null;
      break;

    case 'dragenter':
    case 'dragleave':
      queuedDrag = null;
      break;

    case 'mouseover':
    case 'mouseout':
      queuedMouse = null;
      break;

    case 'pointerover':
    case 'pointerout':
      {
        var pointerId = nativeEvent.pointerId;
        queuedPointers.delete(pointerId);
        break;
      }

    case 'gotpointercapture':
    case 'lostpointercapture':
      {
        var _pointerId = nativeEvent.pointerId;
        queuedPointerCaptures.delete(_pointerId);
        break;
      }
  }
}

function accumulateOrCreateContinuousQueuedReplayableEvent(existingQueuedEvent, blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent) {
  if (existingQueuedEvent === null || existingQueuedEvent.nativeEvent !== nativeEvent) {
    var queuedEvent = createQueuedReplayableEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent);

    if (blockedOn !== null) {
      var _fiber2 = getInstanceFromNode(blockedOn);

      if (_fiber2 !== null) {
        // Attempt to increase the priority of this target.
        attemptContinuousHydration(_fiber2);
      }
    }

    return queuedEvent;
  } // If we have already queued this exact event, then it's because
  // the different event systems have different DOM event listeners.
  // We can accumulate the flags, and the targetContainers, and
  // store a single event to be replayed.


  existingQueuedEvent.eventSystemFlags |= eventSystemFlags;
  var targetContainers = existingQueuedEvent.targetContainers;

  if (targetContainer !== null && targetContainers.indexOf(targetContainer) === -1) {
    targetContainers.push(targetContainer);
  }

  return existingQueuedEvent;
}

function queueIfContinuousEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent) {
  // These set relatedTarget to null because the replayed event will be treated as if we
  // moved from outside the window (no target) onto the target once it hydrates.
  // Instead of mutating we could clone the event.
  switch (domEventName) {
    case 'focusin':
      {
        var focusEvent = nativeEvent;
        queuedFocus = accumulateOrCreateContinuousQueuedReplayableEvent(queuedFocus, blockedOn, domEventName, eventSystemFlags, targetContainer, focusEvent);
        return true;
      }

    case 'dragenter':
      {
        var dragEvent = nativeEvent;
        queuedDrag = accumulateOrCreateContinuousQueuedReplayableEvent(queuedDrag, blockedOn, domEventName, eventSystemFlags, targetContainer, dragEvent);
        return true;
      }

    case 'mouseover':
      {
        var mouseEvent = nativeEvent;
        queuedMouse = accumulateOrCreateContinuousQueuedReplayableEvent(queuedMouse, blockedOn, domEventName, eventSystemFlags, targetContainer, mouseEvent);
        return true;
      }

    case 'pointerover':
      {
        var pointerEvent = nativeEvent;
        var pointerId = pointerEvent.pointerId;
        queuedPointers.set(pointerId, accumulateOrCreateContinuousQueuedReplayableEvent(queuedPointers.get(pointerId) || null, blockedOn, domEventName, eventSystemFlags, targetContainer, pointerEvent));
        return true;
      }

    case 'gotpointercapture':
      {
        var _pointerEvent = nativeEvent;
        var _pointerId2 = _pointerEvent.pointerId;
        queuedPointerCaptures.set(_pointerId2, accumulateOrCreateContinuousQueuedReplayableEvent(queuedPointerCaptures.get(_pointerId2) || null, blockedOn, domEventName, eventSystemFlags, targetContainer, _pointerEvent));
        return true;
      }
  }

  return false;
} // Check if this target is unblocked. Returns true if it's unblocked.

function attemptExplicitHydrationTarget(queuedTarget) {
  // TODO: This function shares a lot of logic with attemptToDispatchEvent.
  // Try to unify them. It's a bit tricky since it would require two return
  // values.
  var targetInst = getClosestInstanceFromNode(queuedTarget.target);

  if (targetInst !== null) {
    var nearestMounted = getNearestMountedFiber(targetInst);

    if (nearestMounted !== null) {
      var tag = nearestMounted.tag;

      if (tag === SuspenseComponent) {
        var instance = getSuspenseInstanceFromFiber(nearestMounted);

        if (instance !== null) {
          // We're blocked on hydrating this boundary.
          // Increase its priority.
          queuedTarget.blockedOn = instance;
          attemptHydrationAtPriority(queuedTarget.lanePriority, function () {
            Scheduler.unstable_runWithPriority(queuedTarget.priority, function () {
              attemptHydrationAtCurrentPriority(nearestMounted);
            });
          });
          return;
        }
      } else if (tag === HostRoot) {
        var root = nearestMounted.stateNode;

        if (root.hydrate) {
          queuedTarget.blockedOn = getContainerFromFiber(nearestMounted); // We don't currently have a way to increase the priority of
          // a root other than sync.

          return;
        }
      }
    }
  }

  queuedTarget.blockedOn = null;
}

function attemptReplayContinuousQueuedEvent(queuedEvent) {
  if (queuedEvent.blockedOn !== null) {
    return false;
  }

  var targetContainers = queuedEvent.targetContainers;

  while (targetContainers.length > 0) {
    var targetContainer = targetContainers[0];
    var nextBlockedOn = attemptToDispatchEvent(queuedEvent.domEventName, queuedEvent.eventSystemFlags, targetContainer, queuedEvent.nativeEvent);

    if (nextBlockedOn !== null) {
      // We're still blocked. Try again later.
      var _fiber3 = getInstanceFromNode(nextBlockedOn);

      if (_fiber3 !== null) {
        attemptContinuousHydration(_fiber3);
      }

      queuedEvent.blockedOn = nextBlockedOn;
      return false;
    } // This target container was successfully dispatched. Try the next.


    targetContainers.shift();
  }

  return true;
}

function attemptReplayContinuousQueuedEventInMap(queuedEvent, key, map) {
  if (attemptReplayContinuousQueuedEvent(queuedEvent)) {
    map.delete(key);
  }
}

function replayUnblockedEvents() {
  hasScheduledReplayAttempt = false; // First replay discrete events.

  while (queuedDiscreteEvents.length > 0) {
    var nextDiscreteEvent = queuedDiscreteEvents[0];

    if (nextDiscreteEvent.blockedOn !== null) {
      // We're still blocked.
      // Increase the priority of this boundary to unblock
      // the next discrete event.
      var _fiber4 = getInstanceFromNode(nextDiscreteEvent.blockedOn);

      if (_fiber4 !== null) {
        attemptUserBlockingHydration(_fiber4);
      }

      break;
    }

    var targetContainers = nextDiscreteEvent.targetContainers;

    while (targetContainers.length > 0) {
      var targetContainer = targetContainers[0];
      var nextBlockedOn = attemptToDispatchEvent(nextDiscreteEvent.domEventName, nextDiscreteEvent.eventSystemFlags, targetContainer, nextDiscreteEvent.nativeEvent);

      if (nextBlockedOn !== null) {
        // We're still blocked. Try again later.
        nextDiscreteEvent.blockedOn = nextBlockedOn;
        break;
      } // This target container was successfully dispatched. Try the next.


      targetContainers.shift();
    }

    if (nextDiscreteEvent.blockedOn === null) {
      // We've successfully replayed the first event. Let's try the next one.
      queuedDiscreteEvents.shift();
    }
  } // Next replay any continuous events.


  if (queuedFocus !== null && attemptReplayContinuousQueuedEvent(queuedFocus)) {
    queuedFocus = null;
  }

  if (queuedDrag !== null && attemptReplayContinuousQueuedEvent(queuedDrag)) {
    queuedDrag = null;
  }

  if (queuedMouse !== null && attemptReplayContinuousQueuedEvent(queuedMouse)) {
    queuedMouse = null;
  }

  queuedPointers.forEach(attemptReplayContinuousQueuedEventInMap);
  queuedPointerCaptures.forEach(attemptReplayContinuousQueuedEventInMap);
}

function scheduleCallbackIfUnblocked(queuedEvent, unblocked) {
  if (queuedEvent.blockedOn === unblocked) {
    queuedEvent.blockedOn = null;

    if (!hasScheduledReplayAttempt) {
      hasScheduledReplayAttempt = true; // Schedule a callback to attempt replaying as many events as are
      // now unblocked. This first might not actually be unblocked yet.
      // We could check it early to avoid scheduling an unnecessary callback.

      Scheduler.unstable_scheduleCallback(Scheduler.unstable_NormalPriority, replayUnblockedEvents);
    }
  }
}

function retryIfBlockedOn(unblocked) {
  // Mark anything that was blocked on this as no longer blocked
  // and eligible for a replay.
  if (queuedDiscreteEvents.length > 0) {
    scheduleCallbackIfUnblocked(queuedDiscreteEvents[0], unblocked); // This is a exponential search for each boundary that commits. I think it's
    // worth it because we expect very few discrete events to queue up and once
    // we are actually fully unblocked it will be fast to replay them.

    for (var i = 1; i < queuedDiscreteEvents.length; i++) {
      var queuedEvent = queuedDiscreteEvents[i];

      if (queuedEvent.blockedOn === unblocked) {
        queuedEvent.blockedOn = null;
      }
    }
  }

  if (queuedFocus !== null) {
    scheduleCallbackIfUnblocked(queuedFocus, unblocked);
  }

  if (queuedDrag !== null) {
    scheduleCallbackIfUnblocked(queuedDrag, unblocked);
  }

  if (queuedMouse !== null) {
    scheduleCallbackIfUnblocked(queuedMouse, unblocked);
  }

  var unblock = function (queuedEvent) {
    return scheduleCallbackIfUnblocked(queuedEvent, unblocked);
  };

  queuedPointers.forEach(unblock);
  queuedPointerCaptures.forEach(unblock);

  for (var _i = 0; _i < queuedExplicitHydrationTargets.length; _i++) {
    var queuedTarget = queuedExplicitHydrationTargets[_i];

    if (queuedTarget.blockedOn === unblocked) {
      queuedTarget.blockedOn = null;
    }
  }

  while (queuedExplicitHydrationTargets.length > 0) {
    var nextExplicitTarget = queuedExplicitHydrationTargets[0];

    if (nextExplicitTarget.blockedOn !== null) {
      // We're still blocked.
      break;
    } else {
      attemptExplicitHydrationTarget(nextExplicitTarget);

      if (nextExplicitTarget.blockedOn === null) {
        // We're unblocked.
        queuedExplicitHydrationTargets.shift();
      }
    }
  }
}

var DiscreteEvent = 0;
var UserBlockingEvent = 1;
var ContinuousEvent = 2;

/**
 * Generate a mapping of standard vendor prefixes using the defined style property and event name.
 *
 * @param {string} styleProp
 * @param {string} eventName
 * @returns {object}
 */

function makePrefixMap(styleProp, eventName) {
  var prefixes = {};
  prefixes[styleProp.toLowerCase()] = eventName.toLowerCase();
  prefixes['Webkit' + styleProp] = 'webkit' + eventName;
  prefixes['Moz' + styleProp] = 'moz' + eventName;
  return prefixes;
}
/**
 * A list of event names to a configurable list of vendor prefixes.
 */


var vendorPrefixes = {
  animationend: makePrefixMap('Animation', 'AnimationEnd'),
  animationiteration: makePrefixMap('Animation', 'AnimationIteration'),
  animationstart: makePrefixMap('Animation', 'AnimationStart'),
  transitionend: makePrefixMap('Transition', 'TransitionEnd')
};
/**
 * Event names that have already been detected and prefixed (if applicable).
 */

var prefixedEventNames = {};
/**
 * Element to check for prefixes on.
 */

var style = {};
/**
 * Bootstrap if a DOM exists.
 */

if (canUseDOM) {
  style = document.createElement('div').style; // On some platforms, in particular some releases of Android 4.x,
  // the un-prefixed "animation" and "transition" properties are defined on the
  // style object but the events that fire will still be prefixed, so we need
  // to check if the un-prefixed events are usable, and if not remove them from the map.

  if (!('AnimationEvent' in window)) {
    delete vendorPrefixes.animationend.animation;
    delete vendorPrefixes.animationiteration.animation;
    delete vendorPrefixes.animationstart.animation;
  } // Same as above


  if (!('TransitionEvent' in window)) {
    delete vendorPrefixes.transitionend.transition;
  }
}
/**
 * Attempts to determine the correct vendor prefixed event name.
 *
 * @param {string} eventName
 * @returns {string}
 */


function getVendorPrefixedEventName(eventName) {
  if (prefixedEventNames[eventName]) {
    return prefixedEventNames[eventName];
  } else if (!vendorPrefixes[eventName]) {
    return eventName;
  }

  var prefixMap = vendorPrefixes[eventName];

  for (var styleProp in prefixMap) {
    if (prefixMap.hasOwnProperty(styleProp) && styleProp in style) {
      return prefixedEventNames[eventName] = prefixMap[styleProp];
    }
  }

  return eventName;
}

var ANIMATION_END = getVendorPrefixedEventName('animationend');
var ANIMATION_ITERATION = getVendorPrefixedEventName('animationiteration');
var ANIMATION_START = getVendorPrefixedEventName('animationstart');
var TRANSITION_END = getVendorPrefixedEventName('transitionend');

var topLevelEventsToReactNames = new Map();
var eventPriorities = new Map(); // We store most of the events in this module in pairs of two strings so we can re-use
// the code required to apply the same logic for event prioritization and that of the
// SimpleEventPlugin. This complicates things slightly, but the aim is to reduce code
// duplication (for which there would be quite a bit). For the events that are not needed
// for the SimpleEventPlugin (otherDiscreteEvents) we process them separately as an
// array of top level events.
// Lastly, we ignore prettier so we can keep the formatting sane.
// prettier-ignore

var discreteEventPairsForSimpleEventPlugin = ['cancel', 'cancel', 'click', 'click', 'close', 'close', 'contextmenu', 'contextMenu', 'copy', 'copy', 'cut', 'cut', 'auxclick', 'auxClick', 'dblclick', 'doubleClick', // Careful!
'dragend', 'dragEnd', 'dragstart', 'dragStart', 'drop', 'drop', 'focusin', 'focus', // Careful!
'focusout', 'blur', // Careful!
'input', 'input', 'invalid', 'invalid', 'keydown', 'keyDown', 'keypress', 'keyPress', 'keyup', 'keyUp', 'mousedown', 'mouseDown', 'mouseup', 'mouseUp', 'paste', 'paste', 'pause', 'pause', 'play', 'play', 'pointercancel', 'pointerCancel', 'pointerdown', 'pointerDown', 'pointerup', 'pointerUp', 'ratechange', 'rateChange', 'reset', 'reset', 'seeked', 'seeked', 'submit', 'submit', 'touchcancel', 'touchCancel', 'touchend', 'touchEnd', 'touchstart', 'touchStart', 'volumechange', 'volumeChange'];
var otherDiscreteEvents = ['change', 'selectionchange', 'textInput', 'compositionstart', 'compositionend', 'compositionupdate'];


var userBlockingPairsForSimpleEventPlugin = ['drag', 'drag', 'dragenter', 'dragEnter', 'dragexit', 'dragExit', 'dragleave', 'dragLeave', 'dragover', 'dragOver', 'mousemove', 'mouseMove', 'mouseout', 'mouseOut', 'mouseover', 'mouseOver', 'pointermove', 'pointerMove', 'pointerout', 'pointerOut', 'pointerover', 'pointerOver', 'scroll', 'scroll', 'toggle', 'toggle', 'touchmove', 'touchMove', 'wheel', 'wheel']; // prettier-ignore

var continuousPairsForSimpleEventPlugin = ['abort', 'abort', ANIMATION_END, 'animationEnd', ANIMATION_ITERATION, 'animationIteration', ANIMATION_START, 'animationStart', 'canplay', 'canPlay', 'canplaythrough', 'canPlayThrough', 'durationchange', 'durationChange', 'emptied', 'emptied', 'encrypted', 'encrypted', 'ended', 'ended', 'error', 'error', 'gotpointercapture', 'gotPointerCapture', 'load', 'load', 'loadeddata', 'loadedData', 'loadedmetadata', 'loadedMetadata', 'loadstart', 'loadStart', 'lostpointercapture', 'lostPointerCapture', 'playing', 'playing', 'progress', 'progress', 'seeking', 'seeking', 'stalled', 'stalled', 'suspend', 'suspend', 'timeupdate', 'timeUpdate', TRANSITION_END, 'transitionEnd', 'waiting', 'waiting'];
/**
 * Turns
 * ['abort', ...]
 *
 * into
 *
 * topLevelEventsToReactNames = new Map([
 *   ['abort', 'onAbort'],
 * ]);
 *
 * and registers them.
 */

function registerSimplePluginEventsAndSetTheirPriorities(eventTypes, priority) {
  // As the event types are in pairs of two, we need to iterate
  // through in twos. The events are in pairs of two to save code
  // and improve init perf of processing this array, as it will
  // result in far fewer object allocations and property accesses
  // if we only use three arrays to process all the categories of
  // instead of tuples.
  for (var i = 0; i < eventTypes.length; i += 2) {
    var topEvent = eventTypes[i];
    var event = eventTypes[i + 1];
    var capitalizedEvent = event[0].toUpperCase() + event.slice(1);
    var reactName = 'on' + capitalizedEvent;
    eventPriorities.set(topEvent, priority);
    topLevelEventsToReactNames.set(topEvent, reactName);
    registerTwoPhaseEvent(reactName, [topEvent]);
  }
}

function setEventPriorities(eventTypes, priority) {
  for (var i = 0; i < eventTypes.length; i++) {
    eventPriorities.set(eventTypes[i], priority);
  }
}

function getEventPriorityForPluginSystem(domEventName) {
  var priority = eventPriorities.get(domEventName); // Default to a ContinuousEvent. Note: we might
  // want to warn if we can't detect the priority
  // for the event.

  return priority === undefined ? ContinuousEvent : priority;
}
function registerSimpleEvents() {
  registerSimplePluginEventsAndSetTheirPriorities(discreteEventPairsForSimpleEventPlugin, DiscreteEvent);
  registerSimplePluginEventsAndSetTheirPriorities(userBlockingPairsForSimpleEventPlugin, UserBlockingEvent);
  registerSimplePluginEventsAndSetTheirPriorities(continuousPairsForSimpleEventPlugin, ContinuousEvent);
  setEventPriorities(otherDiscreteEvents, DiscreteEvent);
}

var Scheduler_now = Scheduler.unstable_now;

{
  // Provide explicit error message when production+profiling bundle of e.g.
  // react-dom is used with production (non-profiling) bundle of
  // scheduler/tracing
  if (!(tracing.__interactionsRef != null && tracing.__interactionsRef.current != null)) {
    {
      throw Error( "It is not supported to run the profiling version of a renderer (for example, `react-dom/profiling`) without also replacing the `scheduler/tracing` module with `scheduler/tracing-profiling`. Your bundler might have a setting for aliasing both modules. Learn more at https://reactjs.org/link/profiling" );
    }
  }
}
// ascending numbers so we can compare them like numbers. They start at 90 to
// avoid clashing with Scheduler's priorities.

var ImmediatePriority = 99;
var UserBlockingPriority = 98;
var NormalPriority = 97;
var LowPriority = 96;
var IdlePriority = 95; // NoPriority is the absence of priority. Also React-only.

var NoPriority = 90;
var initialTimeMs = Scheduler_now(); // If the initial timestamp is reasonably small, use Scheduler's `now` directly.

var SyncLanePriority = 15;
var SyncBatchedLanePriority = 14;
var InputDiscreteHydrationLanePriority = 13;
var InputDiscreteLanePriority = 12;
var InputContinuousHydrationLanePriority = 11;
var InputContinuousLanePriority = 10;
var DefaultHydrationLanePriority = 9;
var DefaultLanePriority = 8;
var TransitionHydrationPriority = 7;
var TransitionPriority = 6;
var RetryLanePriority = 5;
var SelectiveHydrationLanePriority = 4;
var IdleHydrationLanePriority = 3;
var IdleLanePriority = 2;
var OffscreenLanePriority = 1;
var NoLanePriority = 0;
var TotalLanes = 31;
var NoLanes =
/*                        */
0;
var NoLane =
/*                          */
0;
var SyncLane =
/*                        */
1;
var SyncBatchedLane =
/*                 */
2;
var InputDiscreteHydrationLane =
/*      */
4;
var InputDiscreteLanes =
/*                    */
24;
var InputContinuousHydrationLane =
/*           */
32;
var InputContinuousLanes =
/*                  */
192;
var DefaultHydrationLane =
/*            */
256;
var DefaultLanes =
/*                   */
3584;
var TransitionHydrationLane =
/*                */
4096;
var TransitionLanes =
/*                       */
4186112;
var RetryLanes =
/*                            */
62914560;
var SomeRetryLane =
/*                  */
33554432;
var SelectiveHydrationLane =
/*          */
67108864;
var NonIdleLanes =
/*                                 */
134217727;
var IdleHydrationLane =
/*               */
134217728;
var IdleLanes =
/*                             */
805306368;
var OffscreenLane =
/*                   */
1073741824;
var NoTimestamp = -1;
function setCurrentUpdateLanePriority(newLanePriority) {
} // "Registers" used to "return" multiple values
// Used by getHighestPriorityLanes and getNextLanes:

var return_highestLanePriority = DefaultLanePriority;

function getHighestPriorityLanes(lanes) {
  if ((SyncLane & lanes) !== NoLanes) {
    return_highestLanePriority = SyncLanePriority;
    return SyncLane;
  }

  if ((SyncBatchedLane & lanes) !== NoLanes) {
    return_highestLanePriority = SyncBatchedLanePriority;
    return SyncBatchedLane;
  }

  if ((InputDiscreteHydrationLane & lanes) !== NoLanes) {
    return_highestLanePriority = InputDiscreteHydrationLanePriority;
    return InputDiscreteHydrationLane;
  }

  var inputDiscreteLanes = InputDiscreteLanes & lanes;

  if (inputDiscreteLanes !== NoLanes) {
    return_highestLanePriority = InputDiscreteLanePriority;
    return inputDiscreteLanes;
  }

  if ((lanes & InputContinuousHydrationLane) !== NoLanes) {
    return_highestLanePriority = InputContinuousHydrationLanePriority;
    return InputContinuousHydrationLane;
  }

  var inputContinuousLanes = InputContinuousLanes & lanes;

  if (inputContinuousLanes !== NoLanes) {
    return_highestLanePriority = InputContinuousLanePriority;
    return inputContinuousLanes;
  }

  if ((lanes & DefaultHydrationLane) !== NoLanes) {
    return_highestLanePriority = DefaultHydrationLanePriority;
    return DefaultHydrationLane;
  }

  var defaultLanes = DefaultLanes & lanes;

  if (defaultLanes !== NoLanes) {
    return_highestLanePriority = DefaultLanePriority;
    return defaultLanes;
  }

  if ((lanes & TransitionHydrationLane) !== NoLanes) {
    return_highestLanePriority = TransitionHydrationPriority;
    return TransitionHydrationLane;
  }

  var transitionLanes = TransitionLanes & lanes;

  if (transitionLanes !== NoLanes) {
    return_highestLanePriority = TransitionPriority;
    return transitionLanes;
  }

  var retryLanes = RetryLanes & lanes;

  if (retryLanes !== NoLanes) {
    return_highestLanePriority = RetryLanePriority;
    return retryLanes;
  }

  if (lanes & SelectiveHydrationLane) {
    return_highestLanePriority = SelectiveHydrationLanePriority;
    return SelectiveHydrationLane;
  }

  if ((lanes & IdleHydrationLane) !== NoLanes) {
    return_highestLanePriority = IdleHydrationLanePriority;
    return IdleHydrationLane;
  }

  var idleLanes = IdleLanes & lanes;

  if (idleLanes !== NoLanes) {
    return_highestLanePriority = IdleLanePriority;
    return idleLanes;
  }

  if ((OffscreenLane & lanes) !== NoLanes) {
    return_highestLanePriority = OffscreenLanePriority;
    return OffscreenLane;
  }

  {
    error('Should have found matching lanes. This is a bug in React.');
  } // This shouldn't be reachable, but as a fallback, return the entire bitmask.


  return_highestLanePriority = DefaultLanePriority;
  return lanes;
}

function schedulerPriorityToLanePriority(schedulerPriorityLevel) {
  switch (schedulerPriorityLevel) {
    case ImmediatePriority:
      return SyncLanePriority;

    case UserBlockingPriority:
      return InputContinuousLanePriority;

    case NormalPriority:
    case LowPriority:
      // TODO: Handle LowSchedulerPriority, somehow. Maybe the same lane as hydration.
      return DefaultLanePriority;

    case IdlePriority:
      return IdleLanePriority;

    default:
      return NoLanePriority;
  }
}
function lanePriorityToSchedulerPriority(lanePriority) {
  switch (lanePriority) {
    case SyncLanePriority:
    case SyncBatchedLanePriority:
      return ImmediatePriority;

    case InputDiscreteHydrationLanePriority:
    case InputDiscreteLanePriority:
    case InputContinuousHydrationLanePriority:
    case InputContinuousLanePriority:
      return UserBlockingPriority;

    case DefaultHydrationLanePriority:
    case DefaultLanePriority:
    case TransitionHydrationPriority:
    case TransitionPriority:
    case SelectiveHydrationLanePriority:
    case RetryLanePriority:
      return NormalPriority;

    case IdleHydrationLanePriority:
    case IdleLanePriority:
    case OffscreenLanePriority:
      return IdlePriority;

    case NoLanePriority:
      return NoPriority;

    default:
      {
        {
          throw Error( "Invalid update priority: " + lanePriority + ". This is a bug in React." );
        }
      }

  }
}
function getNextLanes(root, wipLanes) {
  // Early bailout if there's no pending work left.
  var pendingLanes = root.pendingLanes;

  if (pendingLanes === NoLanes) {
    return_highestLanePriority = NoLanePriority;
    return NoLanes;
  }

  var nextLanes = NoLanes;
  var nextLanePriority = NoLanePriority;
  var expiredLanes = root.expiredLanes;
  var suspendedLanes = root.suspendedLanes;
  var pingedLanes = root.pingedLanes; // Check if any work has expired.

  if (expiredLanes !== NoLanes) {
    nextLanes = expiredLanes;
    nextLanePriority = return_highestLanePriority = SyncLanePriority;
  } else {
    // Do not work on any idle work until all the non-idle work has finished,
    // even if the work is suspended.
    var nonIdlePendingLanes = pendingLanes & NonIdleLanes;

    if (nonIdlePendingLanes !== NoLanes) {
      var nonIdleUnblockedLanes = nonIdlePendingLanes & ~suspendedLanes;

      if (nonIdleUnblockedLanes !== NoLanes) {
        nextLanes = getHighestPriorityLanes(nonIdleUnblockedLanes);
        nextLanePriority = return_highestLanePriority;
      } else {
        var nonIdlePingedLanes = nonIdlePendingLanes & pingedLanes;

        if (nonIdlePingedLanes !== NoLanes) {
          nextLanes = getHighestPriorityLanes(nonIdlePingedLanes);
          nextLanePriority = return_highestLanePriority;
        }
      }
    } else {
      // The only remaining work is Idle.
      var unblockedLanes = pendingLanes & ~suspendedLanes;

      if (unblockedLanes !== NoLanes) {
        nextLanes = getHighestPriorityLanes(unblockedLanes);
        nextLanePriority = return_highestLanePriority;
      } else {
        if (pingedLanes !== NoLanes) {
          nextLanes = getHighestPriorityLanes(pingedLanes);
          nextLanePriority = return_highestLanePriority;
        }
      }
    }
  }

  if (nextLanes === NoLanes) {
    // This should only be reachable if we're suspended
    // TODO: Consider warning in this path if a fallback timer is not scheduled.
    return NoLanes;
  } // If there are higher priority lanes, we'll include them even if they
  // are suspended.


  nextLanes = pendingLanes & getEqualOrHigherPriorityLanes(nextLanes); // If we're already in the middle of a render, switching lanes will interrupt
  // it and we'll lose our progress. We should only do this if the new lanes are
  // higher priority.

  if (wipLanes !== NoLanes && wipLanes !== nextLanes && // If we already suspended with a delay, then interrupting is fine. Don't
  // bother waiting until the root is complete.
  (wipLanes & suspendedLanes) === NoLanes) {
    getHighestPriorityLanes(wipLanes);
    var wipLanePriority = return_highestLanePriority;

    if (nextLanePriority <= wipLanePriority) {
      return wipLanes;
    } else {
      return_highestLanePriority = nextLanePriority;
    }
  } // Check for entangled lanes and add them to the batch.
  //
  // A lane is said to be entangled with another when it's not allowed to render
  // in a batch that does not also include the other lane. Typically we do this
  // when multiple updates have the same source, and we only want to respond to
  // the most recent event from that source.
  //
  // Note that we apply entanglements *after* checking for partial work above.
  // This means that if a lane is entangled during an interleaved event while
  // it's already rendering, we won't interrupt it. This is intentional, since
  // entanglement is usually "best effort": we'll try our best to render the
  // lanes in the same batch, but it's not worth throwing out partially
  // completed work in order to do it.
  //
  // For those exceptions where entanglement is semantically important, like
  // useMutableSource, we should ensure that there is no partial work at the
  // time we apply the entanglement.


  var entangledLanes = root.entangledLanes;

  if (entangledLanes !== NoLanes) {
    var entanglements = root.entanglements;
    var lanes = nextLanes & entangledLanes;

    while (lanes > 0) {
      var index = pickArbitraryLaneIndex(lanes);
      var lane = 1 << index;
      nextLanes |= entanglements[index];
      lanes &= ~lane;
    }
  }

  return nextLanes;
}
function getMostRecentEventTime(root, lanes) {
  var eventTimes = root.eventTimes;
  var mostRecentEventTime = NoTimestamp;

  while (lanes > 0) {
    var index = pickArbitraryLaneIndex(lanes);
    var lane = 1 << index;
    var eventTime = eventTimes[index];

    if (eventTime > mostRecentEventTime) {
      mostRecentEventTime = eventTime;
    }

    lanes &= ~lane;
  }

  return mostRecentEventTime;
}

function computeExpirationTime(lane, currentTime) {
  // TODO: Expiration heuristic is constant per lane, so could use a map.
  getHighestPriorityLanes(lane);
  var priority = return_highestLanePriority;

  if (priority >= InputContinuousLanePriority) {
    // User interactions should expire slightly more quickly.
    //
    // NOTE: This is set to the corresponding constant as in Scheduler.js. When
    // we made it larger, a product metric in www regressed, suggesting there's
    // a user interaction that's being starved by a series of synchronous
    // updates. If that theory is correct, the proper solution is to fix the
    // starvation. However, this scenario supports the idea that expiration
    // times are an important safeguard when starvation does happen.
    //
    // Also note that, in the case of user input specifically, this will soon no
    // longer be an issue because we plan to make user input synchronous by
    // default (until you enter `startTransition`, of course.)
    //
    // If weren't planning to make these updates synchronous soon anyway, I
    // would probably make this number a configurable parameter.
    return currentTime + 250;
  } else if (priority >= TransitionPriority) {
    return currentTime + 5000;
  } else {
    // Anything idle priority or lower should never expire.
    return NoTimestamp;
  }
}

function markStarvedLanesAsExpired(root, currentTime) {
  // TODO: This gets called every time we yield. We can optimize by storing
  // the earliest expiration time on the root. Then use that to quickly bail out
  // of this function.
  var pendingLanes = root.pendingLanes;
  var suspendedLanes = root.suspendedLanes;
  var pingedLanes = root.pingedLanes;
  var expirationTimes = root.expirationTimes; // Iterate through the pending lanes and check if we've reached their
  // expiration time. If so, we'll assume the update is being starved and mark
  // it as expired to force it to finish.

  var lanes = pendingLanes;

  while (lanes > 0) {
    var index = pickArbitraryLaneIndex(lanes);
    var lane = 1 << index;
    var expirationTime = expirationTimes[index];

    if (expirationTime === NoTimestamp) {
      // Found a pending lane with no expiration time. If it's not suspended, or
      // if it's pinged, assume it's CPU-bound. Compute a new expiration time
      // using the current time.
      if ((lane & suspendedLanes) === NoLanes || (lane & pingedLanes) !== NoLanes) {
        // Assumes timestamps are monotonically increasing.
        expirationTimes[index] = computeExpirationTime(lane, currentTime);
      }
    } else if (expirationTime <= currentTime) {
      // This lane expired
      root.expiredLanes |= lane;
    }

    lanes &= ~lane;
  }
} // This returns the highest priority pending lanes regardless of whether they
function getLanesToRetrySynchronouslyOnError(root) {
  var everythingButOffscreen = root.pendingLanes & ~OffscreenLane;

  if (everythingButOffscreen !== NoLanes) {
    return everythingButOffscreen;
  }

  if (everythingButOffscreen & OffscreenLane) {
    return OffscreenLane;
  }

  return NoLanes;
}
function returnNextLanesPriority() {
  return return_highestLanePriority;
}
function includesNonIdleWork(lanes) {
  return (lanes & NonIdleLanes) !== NoLanes;
}
function includesOnlyRetries(lanes) {
  return (lanes & RetryLanes) === lanes;
}
function includesOnlyTransitions(lanes) {
  return (lanes & TransitionLanes) === lanes;
} // To ensure consistency across multiple updates in the same event, this should
// be a pure function, so that it always returns the same lane for given inputs.

function findUpdateLane(lanePriority, wipLanes) {
  switch (lanePriority) {
    case NoLanePriority:
      break;

    case SyncLanePriority:
      return SyncLane;

    case SyncBatchedLanePriority:
      return SyncBatchedLane;

    case InputDiscreteLanePriority:
      {
        var _lane = pickArbitraryLane(InputDiscreteLanes & ~wipLanes);

        if (_lane === NoLane) {
          // Shift to the next priority level
          return findUpdateLane(InputContinuousLanePriority, wipLanes);
        }

        return _lane;
      }

    case InputContinuousLanePriority:
      {
        var _lane2 = pickArbitraryLane(InputContinuousLanes & ~wipLanes);

        if (_lane2 === NoLane) {
          // Shift to the next priority level
          return findUpdateLane(DefaultLanePriority, wipLanes);
        }

        return _lane2;
      }

    case DefaultLanePriority:
      {
        var _lane3 = pickArbitraryLane(DefaultLanes & ~wipLanes);

        if (_lane3 === NoLane) {
          // If all the default lanes are already being worked on, look for a
          // lane in the transition range.
          _lane3 = pickArbitraryLane(TransitionLanes & ~wipLanes);

          if (_lane3 === NoLane) {
            // All the transition lanes are taken, too. This should be very
            // rare, but as a last resort, pick a default lane. This will have
            // the effect of interrupting the current work-in-progress render.
            _lane3 = pickArbitraryLane(DefaultLanes);
          }
        }

        return _lane3;
      }

    case TransitionPriority: // Should be handled by findTransitionLane instead

    case RetryLanePriority:
      // Should be handled by findRetryLane instead
      break;

    case IdleLanePriority:
      var lane = pickArbitraryLane(IdleLanes & ~wipLanes);

      if (lane === NoLane) {
        lane = pickArbitraryLane(IdleLanes);
      }

      return lane;
  }

  {
    {
      throw Error( "Invalid update priority: " + lanePriority + ". This is a bug in React." );
    }
  }
} // To ensure consistency across multiple updates in the same event, this should
// be pure function, so that it always returns the same lane for given inputs.

function findTransitionLane(wipLanes, pendingLanes) {
  // First look for lanes that are completely unclaimed, i.e. have no
  // pending work.
  var lane = pickArbitraryLane(TransitionLanes & ~pendingLanes);

  if (lane === NoLane) {
    // If all lanes have pending work, look for a lane that isn't currently
    // being worked on.
    lane = pickArbitraryLane(TransitionLanes & ~wipLanes);

    if (lane === NoLane) {
      // If everything is being worked on, pick any lane. This has the
      // effect of interrupting the current work-in-progress.
      lane = pickArbitraryLane(TransitionLanes);
    }
  }

  return lane;
} // To ensure consistency across multiple updates in the same event, this should
// be pure function, so that it always returns the same lane for given inputs.

function findRetryLane(wipLanes) {
  // This is a fork of `findUpdateLane` designed specifically for Suspense
  // "retries"  a special update that attempts to flip a Suspense boundary
  // from its placeholder state to its primary/resolved state.
  var lane = pickArbitraryLane(RetryLanes & ~wipLanes);

  if (lane === NoLane) {
    lane = pickArbitraryLane(RetryLanes);
  }

  return lane;
}

function getHighestPriorityLane(lanes) {
  return lanes & -lanes;
}

function getLowestPriorityLane(lanes) {
  // This finds the most significant non-zero bit.
  var index = 31 - clz32(lanes);
  return index < 0 ? NoLanes : 1 << index;
}

function getEqualOrHigherPriorityLanes(lanes) {
  return (getLowestPriorityLane(lanes) << 1) - 1;
}

function pickArbitraryLane(lanes) {
  // This wrapper function gets inlined. Only exists so to communicate that it
  // doesn't matter which bit is selected; you can pick any bit without
  // affecting the algorithms where its used. Here I'm using
  // getHighestPriorityLane because it requires the fewest operations.
  return getHighestPriorityLane(lanes);
}

function pickArbitraryLaneIndex(lanes) {
  return 31 - clz32(lanes);
}

function laneToIndex(lane) {
  return pickArbitraryLaneIndex(lane);
}

function includesSomeLane(a, b) {
  return (a & b) !== NoLanes;
}
function isSubsetOfLanes(set, subset) {
  return (set & subset) === subset;
}
function mergeLanes(a, b) {
  return a | b;
}
function removeLanes(set, subset) {
  return set & ~subset;
} // Seems redundant, but it changes the type from a single lane (used for
// updates) to a group of lanes (used for flushing work).

function laneToLanes(lane) {
  return lane;
}
function higherPriorityLane(a, b) {
  // This works because the bit ranges decrease in priority as you go left.
  return a !== NoLane && a < b ? a : b;
}
function createLaneMap(initial) {
  // Intentionally pushing one by one.
  // https://v8.dev/blog/elements-kinds#avoid-creating-holes
  var laneMap = [];

  for (var i = 0; i < TotalLanes; i++) {
    laneMap.push(initial);
  }

  return laneMap;
}
function markRootUpdated(root, updateLane, eventTime) {
  root.pendingLanes |= updateLane; // TODO: Theoretically, any update to any lane can unblock any other lane. But
  // it's not practical to try every single possible combination. We need a
  // heuristic to decide which lanes to attempt to render, and in which batches.
  // For now, we use the same heuristic as in the old ExpirationTimes model:
  // retry any lane at equal or lower priority, but don't try updates at higher
  // priority without also including the lower priority updates. This works well
  // when considering updates across different priority levels, but isn't
  // sufficient for updates within the same priority, since we want to treat
  // those updates as parallel.
  // Unsuspend any update at equal or lower priority.

  var higherPriorityLanes = updateLane - 1; // Turns 0b1000 into 0b0111

  root.suspendedLanes &= higherPriorityLanes;
  root.pingedLanes &= higherPriorityLanes;
  var eventTimes = root.eventTimes;
  var index = laneToIndex(updateLane); // We can always overwrite an existing timestamp because we prefer the most
  // recent event, and we assume time is monotonically increasing.

  eventTimes[index] = eventTime;
}
function markRootSuspended(root, suspendedLanes) {
  root.suspendedLanes |= suspendedLanes;
  root.pingedLanes &= ~suspendedLanes; // The suspended lanes are no longer CPU-bound. Clear their expiration times.

  var expirationTimes = root.expirationTimes;
  var lanes = suspendedLanes;

  while (lanes > 0) {
    var index = pickArbitraryLaneIndex(lanes);
    var lane = 1 << index;
    expirationTimes[index] = NoTimestamp;
    lanes &= ~lane;
  }
}
function markRootPinged(root, pingedLanes, eventTime) {
  root.pingedLanes |= root.suspendedLanes & pingedLanes;
}
function markDiscreteUpdatesExpired(root) {
  root.expiredLanes |= InputDiscreteLanes & root.pendingLanes;
}
function hasDiscreteLanes(lanes) {
  return (lanes & InputDiscreteLanes) !== NoLanes;
}
function markRootMutableRead(root, updateLane) {
  root.mutableReadLanes |= updateLane & root.pendingLanes;
}
function markRootFinished(root, remainingLanes) {
  var noLongerPendingLanes = root.pendingLanes & ~remainingLanes;
  root.pendingLanes = remainingLanes; // Let's try everything again

  root.suspendedLanes = 0;
  root.pingedLanes = 0;
  root.expiredLanes &= remainingLanes;
  root.mutableReadLanes &= remainingLanes;
  root.entangledLanes &= remainingLanes;
  var entanglements = root.entanglements;
  var eventTimes = root.eventTimes;
  var expirationTimes = root.expirationTimes; // Clear the lanes that no longer have pending work

  var lanes = noLongerPendingLanes;

  while (lanes > 0) {
    var index = pickArbitraryLaneIndex(lanes);
    var lane = 1 << index;
    entanglements[index] = NoLanes;
    eventTimes[index] = NoTimestamp;
    expirationTimes[index] = NoTimestamp;
    lanes &= ~lane;
  }
}
function markRootEntangled(root, entangledLanes) {
  root.entangledLanes |= entangledLanes;
  var entanglements = root.entanglements;
  var lanes = entangledLanes;

  while (lanes > 0) {
    var index = pickArbitraryLaneIndex(lanes);
    var lane = 1 << index;
    entanglements[index] |= entangledLanes;
    lanes &= ~lane;
  }
}
var clz32 = Math.clz32 ? Math.clz32 : clz32Fallback; // Count leading zeros. Only used on lanes, so assume input is an integer.
// Based on:
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/clz32

var log = Math.log;
var LN2 = Math.LN2;

function clz32Fallback(lanes) {
  if (lanes === 0) {
    return 32;
  }

  return 31 - (log(lanes) / LN2 | 0) | 0;
}

// Intentionally not named imports because Rollup would use dynamic dispatch for
var UserBlockingPriority$1 = Scheduler.unstable_UserBlockingPriority,
    runWithPriority = Scheduler.unstable_runWithPriority; // TODO: can we stop exporting these?

var _enabled = true; // This is exported in FB builds for use by legacy FB layer infra.
// We'd like to remove this but it's not clear if this is safe.

function setEnabled(enabled) {
  _enabled = !!enabled;
}
function isEnabled() {
  return _enabled;
}
function createEventListenerWrapperWithPriority(targetContainer, domEventName, eventSystemFlags) {
  var eventPriority = getEventPriorityForPluginSystem(domEventName);
  var listenerWrapper;

  switch (eventPriority) {
    case DiscreteEvent:
      listenerWrapper = dispatchDiscreteEvent;
      break;

    case UserBlockingEvent:
      listenerWrapper = dispatchUserBlockingUpdate;
      break;

    case ContinuousEvent:
    default:
      listenerWrapper = dispatchEvent;
      break;
  }

  return listenerWrapper.bind(null, domEventName, eventSystemFlags, targetContainer);
}

function dispatchDiscreteEvent(domEventName, eventSystemFlags, container, nativeEvent) {
  {
    flushDiscreteUpdatesIfNeeded(nativeEvent.timeStamp);
  }

  discreteUpdates(dispatchEvent, domEventName, eventSystemFlags, container, nativeEvent);
}

function dispatchUserBlockingUpdate(domEventName, eventSystemFlags, container, nativeEvent) {
  {
    runWithPriority(UserBlockingPriority$1, dispatchEvent.bind(null, domEventName, eventSystemFlags, container, nativeEvent));
  }
}

function dispatchEvent(domEventName, eventSystemFlags, targetContainer, nativeEvent) {
  if (!_enabled) {
    return;
  }

  var allowReplay = true;

  {
    // TODO: replaying capture phase events is currently broken
    // because we used to do it during top-level native bubble handlers
    // but now we use different bubble and capture handlers.
    // In eager mode, we attach capture listeners early, so we need
    // to filter them out until we fix the logic to handle them correctly.
    // This could've been outside the flag but I put it inside to reduce risk.
    allowReplay = (eventSystemFlags & IS_CAPTURE_PHASE) === 0;
  }

  if (allowReplay && hasQueuedDiscreteEvents() && isReplayableDiscreteEvent(domEventName)) {
    // If we already have a queue of discrete events, and this is another discrete
    // event, then we can't dispatch it regardless of its target, since they
    // need to dispatch in order.
    queueDiscreteEvent(null, // Flags that we're not actually blocked on anything as far as we know.
    domEventName, eventSystemFlags, targetContainer, nativeEvent);
    return;
  }

  var blockedOn = attemptToDispatchEvent(domEventName, eventSystemFlags, targetContainer, nativeEvent);

  if (blockedOn === null) {
    // We successfully dispatched this event.
    if (allowReplay) {
      clearIfContinuousEvent(domEventName, nativeEvent);
    }

    return;
  }

  if (allowReplay) {
    if (isReplayableDiscreteEvent(domEventName)) {
      // This this to be replayed later once the target is available.
      queueDiscreteEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent);
      return;
    }

    if (queueIfContinuousEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent)) {
      return;
    } // We need to clear only if we didn't queue because
    // queueing is accummulative.


    clearIfContinuousEvent(domEventName, nativeEvent);
  } // This is not replayable so we'll invoke it but without a target,
  // in case the event system needs to trace it.


  dispatchEventForPluginEventSystem(domEventName, eventSystemFlags, nativeEvent, null, targetContainer);
} // Attempt dispatching an event. Returns a SuspenseInstance or Container if it's blocked.

function attemptToDispatchEvent(domEventName, eventSystemFlags, targetContainer, nativeEvent) {
  // TODO: Warn if _enabled is false.
  var nativeEventTarget = getEventTarget(nativeEvent);
  var targetInst = getClosestInstanceFromNode(nativeEventTarget);

  if (targetInst !== null) {
    var nearestMounted = getNearestMountedFiber(targetInst);

    if (nearestMounted === null) {
      // This tree has been unmounted already. Dispatch without a target.
      targetInst = null;
    } else {
      var tag = nearestMounted.tag;

      if (tag === SuspenseComponent) {
        var instance = getSuspenseInstanceFromFiber(nearestMounted);

        if (instance !== null) {
          // Queue the event to be replayed later. Abort dispatching since we
          // don't want this event dispatched twice through the event system.
          // TODO: If this is the first discrete event in the queue. Schedule an increased
          // priority for this boundary.
          return instance;
        } // This shouldn't happen, something went wrong but to avoid blocking
        // the whole system, dispatch the event without a target.
        // TODO: Warn.


        targetInst = null;
      } else if (tag === HostRoot) {
        var root = nearestMounted.stateNode;

        if (root.hydrate) {
          // If this happens during a replay something went wrong and it might block
          // the whole system.
          return getContainerFromFiber(nearestMounted);
        }

        targetInst = null;
      } else if (nearestMounted !== targetInst) {
        // If we get an event (ex: img onload) before committing that
        // component's mount, ignore it for now (that is, treat it as if it was an
        // event on a non-React tree). We might also consider queueing events and
        // dispatching them after the mount.
        targetInst = null;
      }
    }
  }

  dispatchEventForPluginEventSystem(domEventName, eventSystemFlags, nativeEvent, targetInst, targetContainer); // We're not blocked on anything.

  return null;
}

function addEventBubbleListener(target, eventType, listener) {
  target.addEventListener(eventType, listener, false);
  return listener;
}
function addEventCaptureListener(target, eventType, listener) {
  target.addEventListener(eventType, listener, true);
  return listener;
}
function addEventCaptureListenerWithPassiveFlag(target, eventType, listener, passive) {
  target.addEventListener(eventType, listener, {
    capture: true,
    passive: passive
  });
  return listener;
}
function addEventBubbleListenerWithPassiveFlag(target, eventType, listener, passive) {
  target.addEventListener(eventType, listener, {
    passive: passive
  });
  return listener;
}

/**
 * These variables store information about text content of a target node,
 * allowing comparison of content before and after a given event.
 *
 * Identify the node where selection currently begins, then observe
 * both its text content and its current position in the DOM. Since the
 * browser may natively replace the target node during composition, we can
 * use its position to find its replacement.
 *
 *
 */
var root = null;
var startText = null;
var fallbackText = null;
function initialize(nativeEventTarget) {
  root = nativeEventTarget;
  startText = getText();
  return true;
}
function reset() {
  root = null;
  startText = null;
  fallbackText = null;
}
function getData() {
  if (fallbackText) {
    return fallbackText;
  }

  var start;
  var startValue = startText;
  var startLength = startValue.length;
  var end;
  var endValue = getText();
  var endLength = endValue.length;

  for (start = 0; start < startLength; start++) {
    if (startValue[start] !== endValue[start]) {
      break;
    }
  }

  var minEnd = startLength - start;

  for (end = 1; end <= minEnd; end++) {
    if (startValue[startLength - end] !== endValue[endLength - end]) {
      break;
    }
  }

  var sliceTail = end > 1 ? 1 - end : undefined;
  fallbackText = endValue.slice(start, sliceTail);
  return fallbackText;
}
function getText() {
  if ('value' in root) {
    return root.value;
  }

  return root.textContent;
}

/**
 * `charCode` represents the actual "character code" and is safe to use with
 * `String.fromCharCode`. As such, only keys that correspond to printable
 * characters produce a valid `charCode`, the only exception to this is Enter.
 * The Tab-key is considered non-printable and does not have a `charCode`,
 * presumably because it does not produce a tab-character in browsers.
 *
 * @param {object} nativeEvent Native browser event.
 * @return {number} Normalized `charCode` property.
 */
function getEventCharCode(nativeEvent) {
  var charCode;
  var keyCode = nativeEvent.keyCode;

  if ('charCode' in nativeEvent) {
    charCode = nativeEvent.charCode; // FF does not set `charCode` for the Enter-key, check against `keyCode`.

    if (charCode === 0 && keyCode === 13) {
      charCode = 13;
    }
  } else {
    // IE8 does not implement `charCode`, but `keyCode` has the correct value.
    charCode = keyCode;
  } // IE and Edge (on Windows) and Chrome / Safari (on Windows and Linux)
  // report Enter as charCode 10 when ctrl is pressed.


  if (charCode === 10) {
    charCode = 13;
  } // Some non-printable keys are reported in `charCode`/`keyCode`, discard them.
  // Must not discard the (non-)printable Enter-key.


  if (charCode >= 32 || charCode === 13) {
    return charCode;
  }

  return 0;
}

function functionThatReturnsTrue() {
  return true;
}

function functionThatReturnsFalse() {
  return false;
} // This is intentionally a factory so that we have different returned constructors.
// If we had a single constructor, it would be megamorphic and engines would deopt.


function createSyntheticEvent(Interface) {
  /**
   * Synthetic events are dispatched by event plugins, typically in response to a
   * top-level event delegation handler.
   *
   * These systems should generally use pooling to reduce the frequency of garbage
   * collection. The system should check `isPersistent` to determine whether the
   * event should be released into the pool after being dispatched. Users that
   * need a persisted event should invoke `persist`.
   *
   * Synthetic events (and subclasses) implement the DOM Level 3 Events API by
   * normalizing browser quirks. Subclasses do not necessarily have to implement a
   * DOM interface; custom application-specific events can also subclass this.
   */
  function SyntheticBaseEvent(reactName, reactEventType, targetInst, nativeEvent, nativeEventTarget) {
    this._reactName = reactName;
    this._targetInst = targetInst;
    this.type = reactEventType;
    this.nativeEvent = nativeEvent;
    this.target = nativeEventTarget;
    this.currentTarget = null;

    for (var _propName in Interface) {
      if (!Interface.hasOwnProperty(_propName)) {
        continue;
      }

      var normalize = Interface[_propName];

      if (normalize) {
        this[_propName] = normalize(nativeEvent);
      } else {
        this[_propName] = nativeEvent[_propName];
      }
    }

    var defaultPrevented = nativeEvent.defaultPrevented != null ? nativeEvent.defaultPrevented : nativeEvent.returnValue === false;

    if (defaultPrevented) {
      this.isDefaultPrevented = functionThatReturnsTrue;
    } else {
      this.isDefaultPrevented = functionThatReturnsFalse;
    }

    this.isPropagationStopped = functionThatReturnsFalse;
    return this;
  }

  _assign(SyntheticBaseEvent.prototype, {
    preventDefault: function () {
      this.defaultPrevented = true;
      var event = this.nativeEvent;

      if (!event) {
        return;
      }

      if (event.preventDefault) {
        event.preventDefault(); // $FlowFixMe - flow is not aware of `unknown` in IE
      } else if (typeof event.returnValue !== 'unknown') {
        event.returnValue = false;
      }

      this.isDefaultPrevented = functionThatReturnsTrue;
    },
    stopPropagation: function () {
      var event = this.nativeEvent;

      if (!event) {
        return;
      }

      if (event.stopPropagation) {
        event.stopPropagation(); // $FlowFixMe - flow is not aware of `unknown` in IE
      } else if (typeof event.cancelBubble !== 'unknown') {
        // The ChangeEventPlugin registers a "propertychange" event for
        // IE. This event does not support bubbling or cancelling, and
        // any references to cancelBubble throw "Member not found".  A
        // typeof check of "unknown" circumvents this issue (and is also
        // IE specific).
        event.cancelBubble = true;
      }

      this.isPropagationStopped = functionThatReturnsTrue;
    },

    /**
     * We release all dispatched `SyntheticEvent`s after each event loop, adding
     * them back into the pool. This allows a way to hold onto a reference that
     * won't be added back into the pool.
     */
    persist: function () {// Modern event system doesn't use pooling.
    },

    /**
     * Checks if this event should be released back into the pool.
     *
     * @return {boolean} True if this should not be released, false otherwise.
     */
    isPersistent: functionThatReturnsTrue
  });

  return SyntheticBaseEvent;
}
/**
 * @interface Event
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */


var EventInterface = {
  eventPhase: 0,
  bubbles: 0,
  cancelable: 0,
  timeStamp: function (event) {
    return event.timeStamp || Date.now();
  },
  defaultPrevented: 0,
  isTrusted: 0
};
var SyntheticEvent = createSyntheticEvent(EventInterface);

var UIEventInterface = _assign({}, EventInterface, {
  view: 0,
  detail: 0
});

var SyntheticUIEvent = createSyntheticEvent(UIEventInterface);
var lastMovementX;
var lastMovementY;
var lastMouseEvent;

function updateMouseMovementPolyfillState(event) {
  if (event !== lastMouseEvent) {
    if (lastMouseEvent && event.type === 'mousemove') {
      lastMovementX = event.screenX - lastMouseEvent.screenX;
      lastMovementY = event.screenY - lastMouseEvent.screenY;
    } else {
      lastMovementX = 0;
      lastMovementY = 0;
    }

    lastMouseEvent = event;
  }
}
/**
 * @interface MouseEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */


var MouseEventInterface = _assign({}, UIEventInterface, {
  screenX: 0,
  screenY: 0,
  clientX: 0,
  clientY: 0,
  pageX: 0,
  pageY: 0,
  ctrlKey: 0,
  shiftKey: 0,
  altKey: 0,
  metaKey: 0,
  getModifierState: getEventModifierState,
  button: 0,
  buttons: 0,
  relatedTarget: function (event) {
    if (event.relatedTarget === undefined) return event.fromElement === event.srcElement ? event.toElement : event.fromElement;
    return event.relatedTarget;
  },
  movementX: function (event) {
    if ('movementX' in event) {
      return event.movementX;
    }

    updateMouseMovementPolyfillState(event);
    return lastMovementX;
  },
  movementY: function (event) {
    if ('movementY' in event) {
      return event.movementY;
    } // Don't need to call updateMouseMovementPolyfillState() here
    // because it's guaranteed to have already run when movementX
    // was copied.


    return lastMovementY;
  }
});

var SyntheticMouseEvent = createSyntheticEvent(MouseEventInterface);
/**
 * @interface DragEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */

var DragEventInterface = _assign({}, MouseEventInterface, {
  dataTransfer: 0
});

var SyntheticDragEvent = createSyntheticEvent(DragEventInterface);
/**
 * @interface FocusEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */

var FocusEventInterface = _assign({}, UIEventInterface, {
  relatedTarget: 0
});

var SyntheticFocusEvent = createSyntheticEvent(FocusEventInterface);
/**
 * @interface Event
 * @see http://www.w3.org/TR/css3-animations/#AnimationEvent-interface
 * @see https://developer.mozilla.org/en-US/docs/Web/API/AnimationEvent
 */

var AnimationEventInterface = _assign({}, EventInterface, {
  animationName: 0,
  elapsedTime: 0,
  pseudoElement: 0
});

var SyntheticAnimationEvent = createSyntheticEvent(AnimationEventInterface);
/**
 * @interface Event
 * @see http://www.w3.org/TR/clipboard-apis/
 */

var ClipboardEventInterface = _assign({}, EventInterface, {
  clipboardData: function (event) {
    return 'clipboardData' in event ? event.clipboardData : window.clipboardData;
  }
});

var SyntheticClipboardEvent = createSyntheticEvent(ClipboardEventInterface);
/**
 * @interface Event
 * @see http://www.w3.org/TR/DOM-Level-3-Events/#events-compositionevents
 */

var CompositionEventInterface = _assign({}, EventInterface, {
  data: 0
});

var SyntheticCompositionEvent = createSyntheticEvent(CompositionEventInterface);
/**
 * @interface Event
 * @see http://www.w3.org/TR/2013/WD-DOM-Level-3-Events-20131105
 *      /#events-inputevents
 */
// Happens to share the same list for now.

var SyntheticInputEvent = SyntheticCompositionEvent;
/**
 * Normalization of deprecated HTML5 `key` values
 * @see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent#Key_names
 */

var normalizeKey = {
  Esc: 'Escape',
  Spacebar: ' ',
  Left: 'ArrowLeft',
  Up: 'ArrowUp',
  Right: 'ArrowRight',
  Down: 'ArrowDown',
  Del: 'Delete',
  Win: 'OS',
  Menu: 'ContextMenu',
  Apps: 'ContextMenu',
  Scroll: 'ScrollLock',
  MozPrintableKey: 'Unidentified'
};
/**
 * Translation from legacy `keyCode` to HTML5 `key`
 * Only special keys supported, all others depend on keyboard layout or browser
 * @see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent#Key_names
 */

var translateToKey = {
  '8': 'Backspace',
  '9': 'Tab',
  '12': 'Clear',
  '13': 'Enter',
  '16': 'Shift',
  '17': 'Control',
  '18': 'Alt',
  '19': 'Pause',
  '20': 'CapsLock',
  '27': 'Escape',
  '32': ' ',
  '33': 'PageUp',
  '34': 'PageDown',
  '35': 'End',
  '36': 'Home',
  '37': 'ArrowLeft',
  '38': 'ArrowUp',
  '39': 'ArrowRight',
  '40': 'ArrowDown',
  '45': 'Insert',
  '46': 'Delete',
  '112': 'F1',
  '113': 'F2',
  '114': 'F3',
  '115': 'F4',
  '116': 'F5',
  '117': 'F6',
  '118': 'F7',
  '119': 'F8',
  '120': 'F9',
  '121': 'F10',
  '122': 'F11',
  '123': 'F12',
  '144': 'NumLock',
  '145': 'ScrollLock',
  '224': 'Meta'
};
/**
 * @param {object} nativeEvent Native browser event.
 * @return {string} Normalized `key` property.
 */

function getEventKey(nativeEvent) {
  if (nativeEvent.key) {
    // Normalize inconsistent values reported by browsers due to
    // implementations of a working draft specification.
    // FireFox implements `key` but returns `MozPrintableKey` for all
    // printable characters (normalized to `Unidentified`), ignore it.
    var key = normalizeKey[nativeEvent.key] || nativeEvent.key;

    if (key !== 'Unidentified') {
      return key;
    }
  } // Browser does not implement `key`, polyfill as much of it as we can.


  if (nativeEvent.type === 'keypress') {
    var charCode = getEventCharCode(nativeEvent); // The enter-key is technically both printable and non-printable and can
    // thus be captured by `keypress`, no other non-printable key should.

    return charCode === 13 ? 'Enter' : String.fromCharCode(charCode);
  }

  if (nativeEvent.type === 'keydown' || nativeEvent.type === 'keyup') {
    // While user keyboard layout determines the actual meaning of each
    // `keyCode` value, almost all function keys have a universal value.
    return translateToKey[nativeEvent.keyCode] || 'Unidentified';
  }

  return '';
}
/**
 * Translation from modifier key to the associated property in the event.
 * @see http://www.w3.org/TR/DOM-Level-3-Events/#keys-Modifiers
 */


var modifierKeyToProp = {
  Alt: 'altKey',
  Control: 'ctrlKey',
  Meta: 'metaKey',
  Shift: 'shiftKey'
}; // Older browsers (Safari <= 10, iOS Safari <= 10.2) do not support
// getModifierState. If getModifierState is not supported, we map it to a set of
// modifier keys exposed by the event. In this case, Lock-keys are not supported.

function modifierStateGetter(keyArg) {
  var syntheticEvent = this;
  var nativeEvent = syntheticEvent.nativeEvent;

  if (nativeEvent.getModifierState) {
    return nativeEvent.getModifierState(keyArg);
  }

  var keyProp = modifierKeyToProp[keyArg];
  return keyProp ? !!nativeEvent[keyProp] : false;
}

function getEventModifierState(nativeEvent) {
  return modifierStateGetter;
}
/**
 * @interface KeyboardEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */


var KeyboardEventInterface = _assign({}, UIEventInterface, {
  key: getEventKey,
  code: 0,
  location: 0,
  ctrlKey: 0,
  shiftKey: 0,
  altKey: 0,
  metaKey: 0,
  repeat: 0,
  locale: 0,
  getModifierState: getEventModifierState,
  // Legacy Interface
  charCode: function (event) {
    // `charCode` is the result of a KeyPress event and represents the value of
    // the actual printable character.
    // KeyPress is deprecated, but its replacement is not yet final and not
    // implemented in any major browser. Only KeyPress has charCode.
    if (event.type === 'keypress') {
      return getEventCharCode(event);
    }

    return 0;
  },
  keyCode: function (event) {
    // `keyCode` is the result of a KeyDown/Up event and represents the value of
    // physical keyboard key.
    // The actual meaning of the value depends on the users' keyboard layout
    // which cannot be detected. Assuming that it is a US keyboard layout
    // provides a surprisingly accurate mapping for US and European users.
    // Due to this, it is left to the user to implement at this time.
    if (event.type === 'keydown' || event.type === 'keyup') {
      return event.keyCode;
    }

    return 0;
  },
  which: function (event) {
    // `which` is an alias for either `keyCode` or `charCode` depending on the
    // type of the event.
    if (event.type === 'keypress') {
      return getEventCharCode(event);
    }

    if (event.type === 'keydown' || event.type === 'keyup') {
      return event.keyCode;
    }

    return 0;
  }
});

var SyntheticKeyboardEvent = createSyntheticEvent(KeyboardEventInterface);
/**
 * @interface PointerEvent
 * @see http://www.w3.org/TR/pointerevents/
 */

var PointerEventInterface = _assign({}, MouseEventInterface, {
  pointerId: 0,
  width: 0,
  height: 0,
  pressure: 0,
  tangentialPressure: 0,
  tiltX: 0,
  tiltY: 0,
  twist: 0,
  pointerType: 0,
  isPrimary: 0
});

var SyntheticPointerEvent = createSyntheticEvent(PointerEventInterface);
/**
 * @interface TouchEvent
 * @see http://www.w3.org/TR/touch-events/
 */

var TouchEventInterface = _assign({}, UIEventInterface, {
  touches: 0,
  targetTouches: 0,
  changedTouches: 0,
  altKey: 0,
  metaKey: 0,
  ctrlKey: 0,
  shiftKey: 0,
  getModifierState: getEventModifierState
});

var SyntheticTouchEvent = createSyntheticEvent(TouchEventInterface);
/**
 * @interface Event
 * @see http://www.w3.org/TR/2009/WD-css3-transitions-20090320/#transition-events-
 * @see https://developer.mozilla.org/en-US/docs/Web/API/TransitionEvent
 */

var TransitionEventInterface = _assign({}, EventInterface, {
  propertyName: 0,
  elapsedTime: 0,
  pseudoElement: 0
});

var SyntheticTransitionEvent = createSyntheticEvent(TransitionEventInterface);
/**
 * @interface WheelEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */

var WheelEventInterface = _assign({}, MouseEventInterface, {
  deltaX: function (event) {
    return 'deltaX' in event ? event.deltaX : // Fallback to `wheelDeltaX` for Webkit and normalize (right is positive).
    'wheelDeltaX' in event ? -event.wheelDeltaX : 0;
  },
  deltaY: function (event) {
    return 'deltaY' in event ? event.deltaY : // Fallback to `wheelDeltaY` for Webkit and normalize (down is positive).
    'wheelDeltaY' in event ? -event.wheelDeltaY : // Fallback to `wheelDelta` for IE<9 and normalize (down is positive).
    'wheelDelta' in event ? -event.wheelDelta : 0;
  },
  deltaZ: 0,
  // Browsers without "deltaMode" is reporting in raw wheel delta where one
  // notch on the scroll is always +/- 120, roughly equivalent to pixels.
  // A good approximation of DOM_DELTA_LINE (1) is 5% of viewport size or
  // ~40 pixels, for DOM_DELTA_SCREEN (2) it is 87.5% of viewport size.
  deltaMode: 0
});

var SyntheticWheelEvent = createSyntheticEvent(WheelEventInterface);

var END_KEYCODES = [9, 13, 27, 32]; // Tab, Return, Esc, Space

var START_KEYCODE = 229;
var canUseCompositionEvent = canUseDOM && 'CompositionEvent' in window;
var documentMode = null;

if (canUseDOM && 'documentMode' in document) {
  documentMode = document.documentMode;
} // Webkit offers a very useful `textInput` event that can be used to
// directly represent `beforeInput`. The IE `textinput` event is not as
// useful, so we don't use it.


var canUseTextInputEvent = canUseDOM && 'TextEvent' in window && !documentMode; // In IE9+, we have access to composition events, but the data supplied
// by the native compositionend event may be incorrect. Japanese ideographic
// spaces, for instance (\u3000) are not recorded correctly.

var useFallbackCompositionData = canUseDOM && (!canUseCompositionEvent || documentMode && documentMode > 8 && documentMode <= 11);
var SPACEBAR_CODE = 32;
var SPACEBAR_CHAR = String.fromCharCode(SPACEBAR_CODE);

function registerEvents() {
  registerTwoPhaseEvent('onBeforeInput', ['compositionend', 'keypress', 'textInput', 'paste']);
  registerTwoPhaseEvent('onCompositionEnd', ['compositionend', 'focusout', 'keydown', 'keypress', 'keyup', 'mousedown']);
  registerTwoPhaseEvent('onCompositionStart', ['compositionstart', 'focusout', 'keydown', 'keypress', 'keyup', 'mousedown']);
  registerTwoPhaseEvent('onCompositionUpdate', ['compositionupdate', 'focusout', 'keydown', 'keypress', 'keyup', 'mousedown']);
} // Track whether we've ever handled a keypress on the space key.


var hasSpaceKeypress = false;
/**
 * Return whether a native keypress event is assumed to be a command.
 * This is required because Firefox fires `keypress` events for key commands
 * (cut, copy, select-all, etc.) even though no character is inserted.
 */

function isKeypressCommand(nativeEvent) {
  return (nativeEvent.ctrlKey || nativeEvent.altKey || nativeEvent.metaKey) && // ctrlKey && altKey is equivalent to AltGr, and is not a command.
  !(nativeEvent.ctrlKey && nativeEvent.altKey);
}
/**
 * Translate native top level events into event types.
 */


function getCompositionEventType(domEventName) {
  switch (domEventName) {
    case 'compositionstart':
      return 'onCompositionStart';

    case 'compositionend':
      return 'onCompositionEnd';

    case 'compositionupdate':
      return 'onCompositionUpdate';
  }
}
/**
 * Does our fallback best-guess model think this event signifies that
 * composition has begun?
 */


function isFallbackCompositionStart(domEventName, nativeEvent) {
  return domEventName === 'keydown' && nativeEvent.keyCode === START_KEYCODE;
}
/**
 * Does our fallback mode think that this event is the end of composition?
 */


function isFallbackCompositionEnd(domEventName, nativeEvent) {
  switch (domEventName) {
    case 'keyup':
      // Command keys insert or clear IME input.
      return END_KEYCODES.indexOf(nativeEvent.keyCode) !== -1;

    case 'keydown':
      // Expect IME keyCode on each keydown. If we get any other
      // code we must have exited earlier.
      return nativeEvent.keyCode !== START_KEYCODE;

    case 'keypress':
    case 'mousedown':
    case 'focusout':
      // Events are not possible without cancelling IME.
      return true;

    default:
      return false;
  }
}
/**
 * Google Input Tools provides composition data via a CustomEvent,
 * with the `data` property populated in the `detail` object. If this
 * is available on the event object, use it. If not, this is a plain
 * composition event and we have nothing special to extract.
 *
 * @param {object} nativeEvent
 * @return {?string}
 */


function getDataFromCustomEvent(nativeEvent) {
  var detail = nativeEvent.detail;

  if (typeof detail === 'object' && 'data' in detail) {
    return detail.data;
  }

  return null;
}
/**
 * Check if a composition event was triggered by Korean IME.
 * Our fallback mode does not work well with IE's Korean IME,
 * so just use native composition events when Korean IME is used.
 * Although CompositionEvent.locale property is deprecated,
 * it is available in IE, where our fallback mode is enabled.
 *
 * @param {object} nativeEvent
 * @return {boolean}
 */


function isUsingKoreanIME(nativeEvent) {
  return nativeEvent.locale === 'ko';
} // Track the current IME composition status, if any.


var isComposing = false;
/**
 * @return {?object} A SyntheticCompositionEvent.
 */

function extractCompositionEvent(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget) {
  var eventType;
  var fallbackData;

  if (canUseCompositionEvent) {
    eventType = getCompositionEventType(domEventName);
  } else if (!isComposing) {
    if (isFallbackCompositionStart(domEventName, nativeEvent)) {
      eventType = 'onCompositionStart';
    }
  } else if (isFallbackCompositionEnd(domEventName, nativeEvent)) {
    eventType = 'onCompositionEnd';
  }

  if (!eventType) {
    return null;
  }

  if (useFallbackCompositionData && !isUsingKoreanIME(nativeEvent)) {
    // The current composition is stored statically and must not be
    // overwritten while composition continues.
    if (!isComposing && eventType === 'onCompositionStart') {
      isComposing = initialize(nativeEventTarget);
    } else if (eventType === 'onCompositionEnd') {
      if (isComposing) {
        fallbackData = getData();
      }
    }
  }

  var listeners = accumulateTwoPhaseListeners(targetInst, eventType);

  if (listeners.length > 0) {
    var event = new SyntheticCompositionEvent(eventType, domEventName, null, nativeEvent, nativeEventTarget);
    dispatchQueue.push({
      event: event,
      listeners: listeners
    });

    if (fallbackData) {
      // Inject data generated from fallback path into the synthetic event.
      // This matches the property of native CompositionEventInterface.
      event.data = fallbackData;
    } else {
      var customData = getDataFromCustomEvent(nativeEvent);

      if (customData !== null) {
        event.data = customData;
      }
    }
  }
}

function getNativeBeforeInputChars(domEventName, nativeEvent) {
  switch (domEventName) {
    case 'compositionend':
      return getDataFromCustomEvent(nativeEvent);

    case 'keypress':
      /**
       * If native `textInput` events are available, our goal is to make
       * use of them. However, there is a special case: the spacebar key.
       * In Webkit, preventing default on a spacebar `textInput` event
       * cancels character insertion, but it *also* causes the browser
       * to fall back to its default spacebar behavior of scrolling the
       * page.
       *
       * Tracking at:
       * https://code.google.com/p/chromium/issues/detail?id=355103
       *
       * To avoid this issue, use the keypress event as if no `textInput`
       * event is available.
       */
      var which = nativeEvent.which;

      if (which !== SPACEBAR_CODE) {
        return null;
      }

      hasSpaceKeypress = true;
      return SPACEBAR_CHAR;

    case 'textInput':
      // Record the characters to be added to the DOM.
      var chars = nativeEvent.data; // If it's a spacebar character, assume that we have already handled
      // it at the keypress level and bail immediately. Android Chrome
      // doesn't give us keycodes, so we need to ignore it.

      if (chars === SPACEBAR_CHAR && hasSpaceKeypress) {
        return null;
      }

      return chars;

    default:
      // For other native event types, do nothing.
      return null;
  }
}
/**
 * For browsers that do not provide the `textInput` event, extract the
 * appropriate string to use for SyntheticInputEvent.
 */


function getFallbackBeforeInputChars(domEventName, nativeEvent) {
  // If we are currently composing (IME) and using a fallback to do so,
  // try to extract the composed characters from the fallback object.
  // If composition event is available, we extract a string only at
  // compositionevent, otherwise extract it at fallback events.
  if (isComposing) {
    if (domEventName === 'compositionend' || !canUseCompositionEvent && isFallbackCompositionEnd(domEventName, nativeEvent)) {
      var chars = getData();
      reset();
      isComposing = false;
      return chars;
    }

    return null;
  }

  switch (domEventName) {
    case 'paste':
      // If a paste event occurs after a keypress, throw out the input
      // chars. Paste events should not lead to BeforeInput events.
      return null;

    case 'keypress':
      /**
       * As of v27, Firefox may fire keypress events even when no character
       * will be inserted. A few possibilities:
       *
       * - `which` is `0`. Arrow keys, Esc key, etc.
       *
       * - `which` is the pressed key code, but no char is available.
       *   Ex: 'AltGr + d` in Polish. There is no modified character for
       *   this key combination and no character is inserted into the
       *   document, but FF fires the keypress for char code `100` anyway.
       *   No `input` event will occur.
       *
       * - `which` is the pressed key code, but a command combination is
       *   being used. Ex: `Cmd+C`. No character is inserted, and no
       *   `input` event will occur.
       */
      if (!isKeypressCommand(nativeEvent)) {
        // IE fires the `keypress` event when a user types an emoji via
        // Touch keyboard of Windows.  In such a case, the `char` property
        // holds an emoji character like `\uD83D\uDE0A`.  Because its length
        // is 2, the property `which` does not represent an emoji correctly.
        // In such a case, we directly return the `char` property instead of
        // using `which`.
        if (nativeEvent.char && nativeEvent.char.length > 1) {
          return nativeEvent.char;
        } else if (nativeEvent.which) {
          return String.fromCharCode(nativeEvent.which);
        }
      }

      return null;

    case 'compositionend':
      return useFallbackCompositionData && !isUsingKoreanIME(nativeEvent) ? null : nativeEvent.data;

    default:
      return null;
  }
}
/**
 * Extract a SyntheticInputEvent for `beforeInput`, based on either native
 * `textInput` or fallback behavior.
 *
 * @return {?object} A SyntheticInputEvent.
 */


function extractBeforeInputEvent(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget) {
  var chars;

  if (canUseTextInputEvent) {
    chars = getNativeBeforeInputChars(domEventName, nativeEvent);
  } else {
    chars = getFallbackBeforeInputChars(domEventName, nativeEvent);
  } // If no characters are being inserted, no BeforeInput event should
  // be fired.


  if (!chars) {
    return null;
  }

  var listeners = accumulateTwoPhaseListeners(targetInst, 'onBeforeInput');

  if (listeners.length > 0) {
    var event = new SyntheticInputEvent('onBeforeInput', 'beforeinput', null, nativeEvent, nativeEventTarget);
    dispatchQueue.push({
      event: event,
      listeners: listeners
    });
    event.data = chars;
  }
}
/**
 * Create an `onBeforeInput` event to match
 * http://www.w3.org/TR/2013/WD-DOM-Level-3-Events-20131105/#events-inputevents.
 *
 * This event plugin is based on the native `textInput` event
 * available in Chrome, Safari, Opera, and IE. This event fires after
 * `onKeyPress` and `onCompositionEnd`, but before `onInput`.
 *
 * `beforeInput` is spec'd but not implemented in any browsers, and
 * the `input` event does not provide any useful information about what has
 * actually been added, contrary to the spec. Thus, `textInput` is the best
 * available event to identify the characters that have actually been inserted
 * into the target node.
 *
 * This plugin is also responsible for emitting `composition` events, thus
 * allowing us to share composition fallback code for both `beforeInput` and
 * `composition` event types.
 */


function extractEvents(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer) {
  extractCompositionEvent(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget);
  extractBeforeInputEvent(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget);
}

/**
 * @see http://www.whatwg.org/specs/web-apps/current-work/multipage/the-input-element.html#input-type-attr-summary
 */
var supportedInputTypes = {
  color: true,
  date: true,
  datetime: true,
  'datetime-local': true,
  email: true,
  month: true,
  number: true,
  password: true,
  range: true,
  search: true,
  tel: true,
  text: true,
  time: true,
  url: true,
  week: true
};

function isTextInputElement(elem) {
  var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();

  if (nodeName === 'input') {
    return !!supportedInputTypes[elem.type];
  }

  if (nodeName === 'textarea') {
    return true;
  }

  return false;
}

/**
 * Checks if an event is supported in the current execution environment.
 *
 * NOTE: This will not work correctly for non-generic events such as `change`,
 * `reset`, `load`, `error`, and `select`.
 *
 * Borrows from Modernizr.
 *
 * @param {string} eventNameSuffix Event name, e.g. "click".
 * @return {boolean} True if the event is supported.
 * @internal
 * @license Modernizr 3.0.0pre (Custom Build) | MIT
 */

function isEventSupported(eventNameSuffix) {
  if (!canUseDOM) {
    return false;
  }

  var eventName = 'on' + eventNameSuffix;
  var isSupported = (eventName in document);

  if (!isSupported) {
    var element = document.createElement('div');
    element.setAttribute(eventName, 'return;');
    isSupported = typeof element[eventName] === 'function';
  }

  return isSupported;
}

function registerEvents$1() {
  registerTwoPhaseEvent('onChange', ['change', 'click', 'focusin', 'focusout', 'input', 'keydown', 'keyup', 'selectionchange']);
}

function createAndAccumulateChangeEvent(dispatchQueue, inst, nativeEvent, target) {
  // Flag this event loop as needing state restore.
  enqueueStateRestore(target);
  var listeners = accumulateTwoPhaseListeners(inst, 'onChange');

  if (listeners.length > 0) {
    var event = new SyntheticEvent('onChange', 'change', null, nativeEvent, target);
    dispatchQueue.push({
      event: event,
      listeners: listeners
    });
  }
}
/**
 * For IE shims
 */


var activeElement = null;
var activeElementInst = null;
/**
 * SECTION: handle `change` event
 */

function shouldUseChangeEvent(elem) {
  var nodeName = elem.nodeName && elem.nodeName.toLowerCase();
  return nodeName === 'select' || nodeName === 'input' && elem.type === 'file';
}

function manualDispatchChangeEvent(nativeEvent) {
  var dispatchQueue = [];
  createAndAccumulateChangeEvent(dispatchQueue, activeElementInst, nativeEvent, getEventTarget(nativeEvent)); // If change and propertychange bubbled, we'd just bind to it like all the
  // other events and have it go through ReactBrowserEventEmitter. Since it
  // doesn't, we manually listen for the events and so we have to enqueue and
  // process the abstract event manually.
  //
  // Batching is necessary here in order to ensure that all event handlers run
  // before the next rerender (including event handlers attached to ancestor
  // elements instead of directly on the input). Without this, controlled
  // components don't work properly in conjunction with event bubbling because
  // the component is rerendered and the value reverted before all the event
  // handlers can run. See https://github.com/facebook/react/issues/708.

  batchedUpdates(runEventInBatch, dispatchQueue);
}

function runEventInBatch(dispatchQueue) {
  processDispatchQueue(dispatchQueue, 0);
}

function getInstIfValueChanged(targetInst) {
  var targetNode = getNodeFromInstance(targetInst);

  if (updateValueIfChanged(targetNode)) {
    return targetInst;
  }
}

function getTargetInstForChangeEvent(domEventName, targetInst) {
  if (domEventName === 'change') {
    return targetInst;
  }
}
/**
 * SECTION: handle `input` event
 */


var isInputEventSupported = false;

if (canUseDOM) {
  // IE9 claims to support the input event but fails to trigger it when
  // deleting text, so we ignore its input events.
  isInputEventSupported = isEventSupported('input') && (!document.documentMode || document.documentMode > 9);
}
/**
 * (For IE <=9) Starts tracking propertychange events on the passed-in element
 * and override the value property so that we can distinguish user events from
 * value changes in JS.
 */


function startWatchingForValueChange(target, targetInst) {
  activeElement = target;
  activeElementInst = targetInst;
  activeElement.attachEvent('onpropertychange', handlePropertyChange);
}
/**
 * (For IE <=9) Removes the event listeners from the currently-tracked element,
 * if any exists.
 */


function stopWatchingForValueChange() {
  if (!activeElement) {
    return;
  }

  activeElement.detachEvent('onpropertychange', handlePropertyChange);
  activeElement = null;
  activeElementInst = null;
}
/**
 * (For IE <=9) Handles a propertychange event, sending a `change` event if
 * the value of the active element has changed.
 */


function handlePropertyChange(nativeEvent) {
  if (nativeEvent.propertyName !== 'value') {
    return;
  }

  if (getInstIfValueChanged(activeElementInst)) {
    manualDispatchChangeEvent(nativeEvent);
  }
}

function handleEventsForInputEventPolyfill(domEventName, target, targetInst) {
  if (domEventName === 'focusin') {
    // In IE9, propertychange fires for most input events but is buggy and
    // doesn't fire when text is deleted, but conveniently, selectionchange
    // appears to fire in all of the remaining cases so we catch those and
    // forward the event if the value has changed
    // In either case, we don't want to call the event handler if the value
    // is changed from JS so we redefine a setter for `.value` that updates
    // our activeElementValue variable, allowing us to ignore those changes
    //
    // stopWatching() should be a noop here but we call it just in case we
    // missed a blur event somehow.
    stopWatchingForValueChange();
    startWatchingForValueChange(target, targetInst);
  } else if (domEventName === 'focusout') {
    stopWatchingForValueChange();
  }
} // For IE8 and IE9.


function getTargetInstForInputEventPolyfill(domEventName, targetInst) {
  if (domEventName === 'selectionchange' || domEventName === 'keyup' || domEventName === 'keydown') {
    // On the selectionchange event, the target is just document which isn't
    // helpful for us so just check activeElement instead.
    //
    // 99% of the time, keydown and keyup aren't necessary. IE8 fails to fire
    // propertychange on the first input event after setting `value` from a
    // script and fires only keydown, keypress, keyup. Catching keyup usually
    // gets it and catching keydown lets us fire an event for the first
    // keystroke if user does a key repeat (it'll be a little delayed: right
    // before the second keystroke). Other input methods (e.g., paste) seem to
    // fire selectionchange normally.
    return getInstIfValueChanged(activeElementInst);
  }
}
/**
 * SECTION: handle `click` event
 */


function shouldUseClickEvent(elem) {
  // Use the `click` event to detect changes to checkbox and radio inputs.
  // This approach works across all browsers, whereas `change` does not fire
  // until `blur` in IE8.
  var nodeName = elem.nodeName;
  return nodeName && nodeName.toLowerCase() === 'input' && (elem.type === 'checkbox' || elem.type === 'radio');
}

function getTargetInstForClickEvent(domEventName, targetInst) {
  if (domEventName === 'click') {
    return getInstIfValueChanged(targetInst);
  }
}

function getTargetInstForInputOrChangeEvent(domEventName, targetInst) {
  if (domEventName === 'input' || domEventName === 'change') {
    return getInstIfValueChanged(targetInst);
  }
}

function handleControlledInputBlur(node) {
  var state = node._wrapperState;

  if (!state || !state.controlled || node.type !== 'number') {
    return;
  }

  {
    // If controlled, assign the value attribute to the current value on blur
    setDefaultValue(node, 'number', node.value);
  }
}
/**
 * This plugin creates an `onChange` event that normalizes change events
 * across form elements. This event fires at a time when it's possible to
 * change the element's value without seeing a flicker.
 *
 * Supported elements are:
 * - input (see `isTextInputElement`)
 * - textarea
 * - select
 */


function extractEvents$1(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer) {
  var targetNode = targetInst ? getNodeFromInstance(targetInst) : window;
  var getTargetInstFunc, handleEventFunc;

  if (shouldUseChangeEvent(targetNode)) {
    getTargetInstFunc = getTargetInstForChangeEvent;
  } else if (isTextInputElement(targetNode)) {
    if (isInputEventSupported) {
      getTargetInstFunc = getTargetInstForInputOrChangeEvent;
    } else {
      getTargetInstFunc = getTargetInstForInputEventPolyfill;
      handleEventFunc = handleEventsForInputEventPolyfill;
    }
  } else if (shouldUseClickEvent(targetNode)) {
    getTargetInstFunc = getTargetInstForClickEvent;
  }

  if (getTargetInstFunc) {
    var inst = getTargetInstFunc(domEventName, targetInst);

    if (inst) {
      createAndAccumulateChangeEvent(dispatchQueue, inst, nativeEvent, nativeEventTarget);
      return;
    }
  }

  if (handleEventFunc) {
    handleEventFunc(domEventName, targetNode, targetInst);
  } // When blurring, set the value attribute for number inputs


  if (domEventName === 'focusout') {
    handleControlledInputBlur(targetNode);
  }
}

function registerEvents$2() {
  registerDirectEvent('onMouseEnter', ['mouseout', 'mouseover']);
  registerDirectEvent('onMouseLeave', ['mouseout', 'mouseover']);
  registerDirectEvent('onPointerEnter', ['pointerout', 'pointerover']);
  registerDirectEvent('onPointerLeave', ['pointerout', 'pointerover']);
}
/**
 * For almost every interaction we care about, there will be both a top-level
 * `mouseover` and `mouseout` event that occurs. Only use `mouseout` so that
 * we do not extract duplicate events. However, moving the mouse into the
 * browser from outside will not fire a `mouseout` event. In this case, we use
 * the `mouseover` top-level event.
 */


function extractEvents$2(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer) {
  var isOverEvent = domEventName === 'mouseover' || domEventName === 'pointerover';
  var isOutEvent = domEventName === 'mouseout' || domEventName === 'pointerout';

  if (isOverEvent && (eventSystemFlags & IS_REPLAYED) === 0) {
    // If this is an over event with a target, we might have already dispatched
    // the event in the out event of the other target. If this is replayed,
    // then it's because we couldn't dispatch against this target previously
    // so we have to do it now instead.
    var related = nativeEvent.relatedTarget || nativeEvent.fromElement;

    if (related) {
      // If the related node is managed by React, we can assume that we have
      // already dispatched the corresponding events during its mouseout.
      if (getClosestInstanceFromNode(related) || isContainerMarkedAsRoot(related)) {
        return;
      }
    }
  }

  if (!isOutEvent && !isOverEvent) {
    // Must not be a mouse or pointer in or out - ignoring.
    return;
  }

  var win; // TODO: why is this nullable in the types but we read from it?

  if (nativeEventTarget.window === nativeEventTarget) {
    // `nativeEventTarget` is probably a window object.
    win = nativeEventTarget;
  } else {
    // TODO: Figure out why `ownerDocument` is sometimes undefined in IE8.
    var doc = nativeEventTarget.ownerDocument;

    if (doc) {
      win = doc.defaultView || doc.parentWindow;
    } else {
      win = window;
    }
  }

  var from;
  var to;

  if (isOutEvent) {
    var _related = nativeEvent.relatedTarget || nativeEvent.toElement;

    from = targetInst;
    to = _related ? getClosestInstanceFromNode(_related) : null;

    if (to !== null) {
      var nearestMounted = getNearestMountedFiber(to);

      if (to !== nearestMounted || to.tag !== HostComponent && to.tag !== HostText) {
        to = null;
      }
    }
  } else {
    // Moving to a node from outside the window.
    from = null;
    to = targetInst;
  }

  if (from === to) {
    // Nothing pertains to our managed components.
    return;
  }

  var SyntheticEventCtor = SyntheticMouseEvent;
  var leaveEventType = 'onMouseLeave';
  var enterEventType = 'onMouseEnter';
  var eventTypePrefix = 'mouse';

  if (domEventName === 'pointerout' || domEventName === 'pointerover') {
    SyntheticEventCtor = SyntheticPointerEvent;
    leaveEventType = 'onPointerLeave';
    enterEventType = 'onPointerEnter';
    eventTypePrefix = 'pointer';
  }

  var fromNode = from == null ? win : getNodeFromInstance(from);
  var toNode = to == null ? win : getNodeFromInstance(to);
  var leave = new SyntheticEventCtor(leaveEventType, eventTypePrefix + 'leave', from, nativeEvent, nativeEventTarget);
  leave.target = fromNode;
  leave.relatedTarget = toNode;
  var enter = null; // We should only process this nativeEvent if we are processing
  // the first ancestor. Next time, we will ignore the event.

  var nativeTargetInst = getClosestInstanceFromNode(nativeEventTarget);

  if (nativeTargetInst === targetInst) {
    var enterEvent = new SyntheticEventCtor(enterEventType, eventTypePrefix + 'enter', to, nativeEvent, nativeEventTarget);
    enterEvent.target = toNode;
    enterEvent.relatedTarget = fromNode;
    enter = enterEvent;
  }

  accumulateEnterLeaveTwoPhaseListeners(dispatchQueue, leave, enter, from, to);
}

/**
 * inlined Object.is polyfill to avoid requiring consumers ship their own
 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
 */
function is(x, y) {
  return x === y && (x !== 0 || 1 / x === 1 / y) || x !== x && y !== y // eslint-disable-line no-self-compare
  ;
}

var objectIs = typeof Object.is === 'function' ? Object.is : is;

var hasOwnProperty$2 = Object.prototype.hasOwnProperty;
/**
 * Performs equality by iterating through keys on an object and returning false
 * when any key has values which are not strictly equal between the arguments.
 * Returns true when the values of all keys are strictly equal.
 */

function shallowEqual(objA, objB) {
  if (objectIs(objA, objB)) {
    return true;
  }

  if (typeof objA !== 'object' || objA === null || typeof objB !== 'object' || objB === null) {
    return false;
  }

  var keysA = Object.keys(objA);
  var keysB = Object.keys(objB);

  if (keysA.length !== keysB.length) {
    return false;
  } // Test for A's keys different from B.


  for (var i = 0; i < keysA.length; i++) {
    if (!hasOwnProperty$2.call(objB, keysA[i]) || !objectIs(objA[keysA[i]], objB[keysA[i]])) {
      return false;
    }
  }

  return true;
}

/**
 * Given any node return the first leaf node without children.
 *
 * @param {DOMElement|DOMTextNode} node
 * @return {DOMElement|DOMTextNode}
 */

function getLeafNode(node) {
  while (node && node.firstChild) {
    node = node.firstChild;
  }

  return node;
}
/**
 * Get the next sibling within a container. This will walk up the
 * DOM if a node's siblings have been exhausted.
 *
 * @param {DOMElement|DOMTextNode} node
 * @return {?DOMElement|DOMTextNode}
 */


function getSiblingNode(node) {
  while (node) {
    if (node.nextSibling) {
      return node.nextSibling;
    }

    node = node.parentNode;
  }
}
/**
 * Get object describing the nodes which contain characters at offset.
 *
 * @param {DOMElement|DOMTextNode} root
 * @param {number} offset
 * @return {?object}
 */


function getNodeForCharacterOffset(root, offset) {
  var node = getLeafNode(root);
  var nodeStart = 0;
  var nodeEnd = 0;

  while (node) {
    if (node.nodeType === TEXT_NODE) {
      nodeEnd = nodeStart + node.textContent.length;

      if (nodeStart <= offset && nodeEnd >= offset) {
        return {
          node: node,
          offset: offset - nodeStart
        };
      }

      nodeStart = nodeEnd;
    }

    node = getLeafNode(getSiblingNode(node));
  }
}

/**
 * @param {DOMElement} outerNode
 * @return {?object}
 */

function getOffsets(outerNode) {
  var ownerDocument = outerNode.ownerDocument;
  var win = ownerDocument && ownerDocument.defaultView || window;
  var selection = win.getSelection && win.getSelection();

  if (!selection || selection.rangeCount === 0) {
    return null;
  }

  var anchorNode = selection.anchorNode,
      anchorOffset = selection.anchorOffset,
      focusNode = selection.focusNode,
      focusOffset = selection.focusOffset; // In Firefox, anchorNode and focusNode can be "anonymous divs", e.g. the
  // up/down buttons on an <input type="number">. Anonymous divs do not seem to
  // expose properties, triggering a "Permission denied error" if any of its
  // properties are accessed. The only seemingly possible way to avoid erroring
  // is to access a property that typically works for non-anonymous divs and
  // catch any error that may otherwise arise. See
  // https://bugzilla.mozilla.org/show_bug.cgi?id=208427

  try {
    /* eslint-disable no-unused-expressions */
    anchorNode.nodeType;
    focusNode.nodeType;
    /* eslint-enable no-unused-expressions */
  } catch (e) {
    return null;
  }

  return getModernOffsetsFromPoints(outerNode, anchorNode, anchorOffset, focusNode, focusOffset);
}
/**
 * Returns {start, end} where `start` is the character/codepoint index of
 * (anchorNode, anchorOffset) within the textContent of `outerNode`, and
 * `end` is the index of (focusNode, focusOffset).
 *
 * Returns null if you pass in garbage input but we should probably just crash.
 *
 * Exported only for testing.
 */

function getModernOffsetsFromPoints(outerNode, anchorNode, anchorOffset, focusNode, focusOffset) {
  var length = 0;
  var start = -1;
  var end = -1;
  var indexWithinAnchor = 0;
  var indexWithinFocus = 0;
  var node = outerNode;
  var parentNode = null;

  outer: while (true) {
    var next = null;

    while (true) {
      if (node === anchorNode && (anchorOffset === 0 || node.nodeType === TEXT_NODE)) {
        start = length + anchorOffset;
      }

      if (node === focusNode && (focusOffset === 0 || node.nodeType === TEXT_NODE)) {
        end = length + focusOffset;
      }

      if (node.nodeType === TEXT_NODE) {
        length += node.nodeValue.length;
      }

      if ((next = node.firstChild) === null) {
        break;
      } // Moving from `node` to its first child `next`.


      parentNode = node;
      node = next;
    }

    while (true) {
      if (node === outerNode) {
        // If `outerNode` has children, this is always the second time visiting
        // it. If it has no children, this is still the first loop, and the only
        // valid selection is anchorNode and focusNode both equal to this node
        // and both offsets 0, in which case we will have handled above.
        break outer;
      }

      if (parentNode === anchorNode && ++indexWithinAnchor === anchorOffset) {
        start = length;
      }

      if (parentNode === focusNode && ++indexWithinFocus === focusOffset) {
        end = length;
      }

      if ((next = node.nextSibling) !== null) {
        break;
      }

      node = parentNode;
      parentNode = node.parentNode;
    } // Moving from `node` to its next sibling `next`.


    node = next;
  }

  if (start === -1 || end === -1) {
    // This should never happen. (Would happen if the anchor/focus nodes aren't
    // actually inside the passed-in node.)
    return null;
  }

  return {
    start: start,
    end: end
  };
}
/**
 * In modern non-IE browsers, we can support both forward and backward
 * selections.
 *
 * Note: IE10+ supports the Selection object, but it does not support
 * the `extend` method, which means that even in modern IE, it's not possible
 * to programmatically create a backward selection. Thus, for all IE
 * versions, we use the old IE API to create our selections.
 *
 * @param {DOMElement|DOMTextNode} node
 * @param {object} offsets
 */

function setOffsets(node, offsets) {
  var doc = node.ownerDocument || document;
  var win = doc && doc.defaultView || window; // Edge fails with "Object expected" in some scenarios.
  // (For instance: TinyMCE editor used in a list component that supports pasting to add more,
  // fails when pasting 100+ items)

  if (!win.getSelection) {
    return;
  }

  var selection = win.getSelection();
  var length = node.textContent.length;
  var start = Math.min(offsets.start, length);
  var end = offsets.end === undefined ? start : Math.min(offsets.end, length); // IE 11 uses modern selection, but doesn't support the extend method.
  // Flip backward selections, so we can set with a single range.

  if (!selection.extend && start > end) {
    var temp = end;
    end = start;
    start = temp;
  }

  var startMarker = getNodeForCharacterOffset(node, start);
  var endMarker = getNodeForCharacterOffset(node, end);

  if (startMarker && endMarker) {
    if (selection.rangeCount === 1 && selection.anchorNode === startMarker.node && selection.anchorOffset === startMarker.offset && selection.focusNode === endMarker.node && selection.focusOffset === endMarker.offset) {
      return;
    }

    var range = doc.createRange();
    range.setStart(startMarker.node, startMarker.offset);
    selection.removeAllRanges();

    if (start > end) {
      selection.addRange(range);
      selection.extend(endMarker.node, endMarker.offset);
    } else {
      range.setEnd(endMarker.node, endMarker.offset);
      selection.addRange(range);
    }
  }
}

function isTextNode(node) {
  return node && node.nodeType === TEXT_NODE;
}

function containsNode(outerNode, innerNode) {
  if (!outerNode || !innerNode) {
    return false;
  } else if (outerNode === innerNode) {
    return true;
  } else if (isTextNode(outerNode)) {
    return false;
  } else if (isTextNode(innerNode)) {
    return containsNode(outerNode, innerNode.parentNode);
  } else if ('contains' in outerNode) {
    return outerNode.contains(innerNode);
  } else if (outerNode.compareDocumentPosition) {
    return !!(outerNode.compareDocumentPosition(innerNode) & 16);
  } else {
    return false;
  }
}

function isInDocument(node) {
  return node && node.ownerDocument && containsNode(node.ownerDocument.documentElement, node);
}

function isSameOriginFrame(iframe) {
  try {
    // Accessing the contentDocument of a HTMLIframeElement can cause the browser
    // to throw, e.g. if it has a cross-origin src attribute.
    // Safari will show an error in the console when the access results in "Blocked a frame with origin". e.g:
    // iframe.contentDocument.defaultView;
    // A safety way is to access one of the cross origin properties: Window or Location
    // Which might result in "SecurityError" DOM Exception and it is compatible to Safari.
    // https://html.spec.whatwg.org/multipage/browsers.html#integration-with-idl
    return typeof iframe.contentWindow.location.href === 'string';
  } catch (err) {
    return false;
  }
}

function getActiveElementDeep() {
  var win = window;
  var element = getActiveElement();

  while (element instanceof win.HTMLIFrameElement) {
    if (isSameOriginFrame(element)) {
      win = element.contentWindow;
    } else {
      return element;
    }

    element = getActiveElement(win.document);
  }

  return element;
}
/**
 * @ReactInputSelection: React input selection module. Based on Selection.js,
 * but modified to be suitable for react and has a couple of bug fixes (doesn't
 * assume buttons have range selections allowed).
 * Input selection module for React.
 */

/**
 * @hasSelectionCapabilities: we get the element types that support selection
 * from https://html.spec.whatwg.org/#do-not-apply, looking at `selectionStart`
 * and `selectionEnd` rows.
 */


function hasSelectionCapabilities(elem) {
  var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
  return nodeName && (nodeName === 'input' && (elem.type === 'text' || elem.type === 'search' || elem.type === 'tel' || elem.type === 'url' || elem.type === 'password') || nodeName === 'textarea' || elem.contentEditable === 'true');
}
function getSelectionInformation() {
  var focusedElem = getActiveElementDeep();
  return {
    focusedElem: focusedElem,
    selectionRange: hasSelectionCapabilities(focusedElem) ? getSelection(focusedElem) : null
  };
}
/**
 * @restoreSelection: If any selection information was potentially lost,
 * restore it. This is useful when performing operations that could remove dom
 * nodes and place them back in, resulting in focus being lost.
 */

function restoreSelection(priorSelectionInformation) {
  var curFocusedElem = getActiveElementDeep();
  var priorFocusedElem = priorSelectionInformation.focusedElem;
  var priorSelectionRange = priorSelectionInformation.selectionRange;

  if (curFocusedElem !== priorFocusedElem && isInDocument(priorFocusedElem)) {
    if (priorSelectionRange !== null && hasSelectionCapabilities(priorFocusedElem)) {
      setSelection(priorFocusedElem, priorSelectionRange);
    } // Focusing a node can change the scroll position, which is undesirable


    var ancestors = [];
    var ancestor = priorFocusedElem;

    while (ancestor = ancestor.parentNode) {
      if (ancestor.nodeType === ELEMENT_NODE) {
        ancestors.push({
          element: ancestor,
          left: ancestor.scrollLeft,
          top: ancestor.scrollTop
        });
      }
    }

    if (typeof priorFocusedElem.focus === 'function') {
      priorFocusedElem.focus();
    }

    for (var i = 0; i < ancestors.length; i++) {
      var info = ancestors[i];
      info.element.scrollLeft = info.left;
      info.element.scrollTop = info.top;
    }
  }
}
/**
 * @getSelection: Gets the selection bounds of a focused textarea, input or
 * contentEditable node.
 * -@input: Look up selection bounds of this input
 * -@return {start: selectionStart, end: selectionEnd}
 */

function getSelection(input) {
  var selection;

  if ('selectionStart' in input) {
    // Modern browser with input or textarea.
    selection = {
      start: input.selectionStart,
      end: input.selectionEnd
    };
  } else {
    // Content editable or old IE textarea.
    selection = getOffsets(input);
  }

  return selection || {
    start: 0,
    end: 0
  };
}
/**
 * @setSelection: Sets the selection bounds of a textarea or input and focuses
 * the input.
 * -@input     Set selection bounds of this input or textarea
 * -@offsets   Object of same form that is returned from get*
 */

function setSelection(input, offsets) {
  var start = offsets.start;
  var end = offsets.end;

  if (end === undefined) {
    end = start;
  }

  if ('selectionStart' in input) {
    input.selectionStart = start;
    input.selectionEnd = Math.min(end, input.value.length);
  } else {
    setOffsets(input, offsets);
  }
}

var skipSelectionChangeEvent = canUseDOM && 'documentMode' in document && document.documentMode <= 11;

function registerEvents$3() {
  registerTwoPhaseEvent('onSelect', ['focusout', 'contextmenu', 'dragend', 'focusin', 'keydown', 'keyup', 'mousedown', 'mouseup', 'selectionchange']);
}

var activeElement$1 = null;
var activeElementInst$1 = null;
var lastSelection = null;
var mouseDown = false;
/**
 * Get an object which is a unique representation of the current selection.
 *
 * The return value will not be consistent across nodes or browsers, but
 * two identical selections on the same node will return identical objects.
 */

function getSelection$1(node) {
  if ('selectionStart' in node && hasSelectionCapabilities(node)) {
    return {
      start: node.selectionStart,
      end: node.selectionEnd
    };
  } else {
    var win = node.ownerDocument && node.ownerDocument.defaultView || window;
    var selection = win.getSelection();
    return {
      anchorNode: selection.anchorNode,
      anchorOffset: selection.anchorOffset,
      focusNode: selection.focusNode,
      focusOffset: selection.focusOffset
    };
  }
}
/**
 * Get document associated with the event target.
 */


function getEventTargetDocument(eventTarget) {
  return eventTarget.window === eventTarget ? eventTarget.document : eventTarget.nodeType === DOCUMENT_NODE ? eventTarget : eventTarget.ownerDocument;
}
/**
 * Poll selection to see whether it's changed.
 *
 * @param {object} nativeEvent
 * @param {object} nativeEventTarget
 * @return {?SyntheticEvent}
 */


function constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget) {
  // Ensure we have the right element, and that the user is not dragging a
  // selection (this matches native `select` event behavior). In HTML5, select
  // fires only on input and textarea thus if there's no focused element we
  // won't dispatch.
  var doc = getEventTargetDocument(nativeEventTarget);

  if (mouseDown || activeElement$1 == null || activeElement$1 !== getActiveElement(doc)) {
    return;
  } // Only fire when selection has actually changed.


  var currentSelection = getSelection$1(activeElement$1);

  if (!lastSelection || !shallowEqual(lastSelection, currentSelection)) {
    lastSelection = currentSelection;
    var listeners = accumulateTwoPhaseListeners(activeElementInst$1, 'onSelect');

    if (listeners.length > 0) {
      var event = new SyntheticEvent('onSelect', 'select', null, nativeEvent, nativeEventTarget);
      dispatchQueue.push({
        event: event,
        listeners: listeners
      });
      event.target = activeElement$1;
    }
  }
}
/**
 * This plugin creates an `onSelect` event that normalizes select events
 * across form elements.
 *
 * Supported elements are:
 * - input (see `isTextInputElement`)
 * - textarea
 * - contentEditable
 *
 * This differs from native browser implementations in the following ways:
 * - Fires on contentEditable fields as well as inputs.
 * - Fires for collapsed selection.
 * - Fires after user input.
 */


function extractEvents$3(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer) {

  var targetNode = targetInst ? getNodeFromInstance(targetInst) : window;

  switch (domEventName) {
    // Track the input node that has focus.
    case 'focusin':
      if (isTextInputElement(targetNode) || targetNode.contentEditable === 'true') {
        activeElement$1 = targetNode;
        activeElementInst$1 = targetInst;
        lastSelection = null;
      }

      break;

    case 'focusout':
      activeElement$1 = null;
      activeElementInst$1 = null;
      lastSelection = null;
      break;
    // Don't fire the event while the user is dragging. This matches the
    // semantics of the native select event.

    case 'mousedown':
      mouseDown = true;
      break;

    case 'contextmenu':
    case 'mouseup':
    case 'dragend':
      mouseDown = false;
      constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget);
      break;
    // Chrome and IE fire non-standard event when selection is changed (and
    // sometimes when it hasn't). IE's event fires out of order with respect
    // to key and input events on deletion, so we discard it.
    //
    // Firefox doesn't support selectionchange, so check selection status
    // after each key entry. The selection changes after keydown and before
    // keyup, but we check on keydown as well in the case of holding down a
    // key, when multiple keydown events are fired but only one keyup is.
    // This is also our approach for IE handling, for the reason above.

    case 'selectionchange':
      if (skipSelectionChangeEvent) {
        break;
      }

    // falls through

    case 'keydown':
    case 'keyup':
      constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget);
  }
}

function extractEvents$4(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer) {
  var reactName = topLevelEventsToReactNames.get(domEventName);

  if (reactName === undefined) {
    return;
  }

  var SyntheticEventCtor = SyntheticEvent;
  var reactEventType = domEventName;

  switch (domEventName) {
    case 'keypress':
      // Firefox creates a keypress event for function keys too. This removes
      // the unwanted keypress events. Enter is however both printable and
      // non-printable. One would expect Tab to be as well (but it isn't).
      if (getEventCharCode(nativeEvent) === 0) {
        return;
      }

    /* falls through */

    case 'keydown':
    case 'keyup':
      SyntheticEventCtor = SyntheticKeyboardEvent;
      break;

    case 'focusin':
      reactEventType = 'focus';
      SyntheticEventCtor = SyntheticFocusEvent;
      break;

    case 'focusout':
      reactEventType = 'blur';
      SyntheticEventCtor = SyntheticFocusEvent;
      break;

    case 'beforeblur':
    case 'afterblur':
      SyntheticEventCtor = SyntheticFocusEvent;
      break;

    case 'click':
      // Firefox creates a click event on right mouse clicks. This removes the
      // unwanted click events.
      if (nativeEvent.button === 2) {
        return;
      }

    /* falls through */

    case 'auxclick':
    case 'dblclick':
    case 'mousedown':
    case 'mousemove':
    case 'mouseup': // TODO: Disabled elements should not respond to mouse events

    /* falls through */

    case 'mouseout':
    case 'mouseover':
    case 'contextmenu':
      SyntheticEventCtor = SyntheticMouseEvent;
      break;

    case 'drag':
    case 'dragend':
    case 'dragenter':
    case 'dragexit':
    case 'dragleave':
    case 'dragover':
    case 'dragstart':
    case 'drop':
      SyntheticEventCtor = SyntheticDragEvent;
      break;

    case 'touchcancel':
    case 'touchend':
    case 'touchmove':
    case 'touchstart':
      SyntheticEventCtor = SyntheticTouchEvent;
      break;

    case ANIMATION_END:
    case ANIMATION_ITERATION:
    case ANIMATION_START:
      SyntheticEventCtor = SyntheticAnimationEvent;
      break;

    case TRANSITION_END:
      SyntheticEventCtor = SyntheticTransitionEvent;
      break;

    case 'scroll':
      SyntheticEventCtor = SyntheticUIEvent;
      break;

    case 'wheel':
      SyntheticEventCtor = SyntheticWheelEvent;
      break;

    case 'copy':
    case 'cut':
    case 'paste':
      SyntheticEventCtor = SyntheticClipboardEvent;
      break;

    case 'gotpointercapture':
    case 'lostpointercapture':
    case 'pointercancel':
    case 'pointerdown':
    case 'pointermove':
    case 'pointerout':
    case 'pointerover':
    case 'pointerup':
      SyntheticEventCtor = SyntheticPointerEvent;
      break;
  }

  var inCapturePhase = (eventSystemFlags & IS_CAPTURE_PHASE) !== 0;

  {
    // Some events don't bubble in the browser.
    // In the past, React has always bubbled them, but this can be surprising.
    // We're going to try aligning closer to the browser behavior by not bubbling
    // them in React either. We'll start by not bubbling onScroll, and then expand.
    var accumulateTargetOnly = !inCapturePhase && // TODO: ideally, we'd eventually add all events from
    // nonDelegatedEvents list in DOMPluginEventSystem.
    // Then we can remove this special list.
    // This is a breaking change that can wait until React 18.
    domEventName === 'scroll';

    var _listeners = accumulateSinglePhaseListeners(targetInst, reactName, nativeEvent.type, inCapturePhase, accumulateTargetOnly);

    if (_listeners.length > 0) {
      // Intentionally create event lazily.
      var _event = new SyntheticEventCtor(reactName, reactEventType, null, nativeEvent, nativeEventTarget);

      dispatchQueue.push({
        event: _event,
        listeners: _listeners
      });
    }
  }
}

// TODO: remove top-level side effect.
registerSimpleEvents();
registerEvents$2();
registerEvents$1();
registerEvents$3();
registerEvents();

function extractEvents$5(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer) {
  // TODO: we should remove the concept of a "SimpleEventPlugin".
  // This is the basic functionality of the event system. All
  // the other plugins are essentially polyfills. So the plugin
  // should probably be inlined somewhere and have its logic
  // be core the to event system. This would potentially allow
  // us to ship builds of React without the polyfilled plugins below.
  extractEvents$4(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags);
  var shouldProcessPolyfillPlugins = (eventSystemFlags & SHOULD_NOT_PROCESS_POLYFILL_EVENT_PLUGINS) === 0; // We don't process these events unless we are in the
  // event's native "bubble" phase, which means that we're
  // not in the capture phase. That's because we emulate
  // the capture phase here still. This is a trade-off,
  // because in an ideal world we would not emulate and use
  // the phases properly, like we do with the SimpleEvent
  // plugin. However, the plugins below either expect
  // emulation (EnterLeave) or use state localized to that
  // plugin (BeforeInput, Change, Select). The state in
  // these modules complicates things, as you'll essentially
  // get the case where the capture phase event might change
  // state, only for the following bubble event to come in
  // later and not trigger anything as the state now
  // invalidates the heuristics of the event plugin. We
  // could alter all these plugins to work in such ways, but
  // that might cause other unknown side-effects that we
  // can't forsee right now.

  if (shouldProcessPolyfillPlugins) {
    extractEvents$2(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags);
    extractEvents$1(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget);
    extractEvents$3(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget);
    extractEvents(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget);
  }
} // List of events that need to be individually attached to media elements.


var mediaEventTypes = ['abort', 'canplay', 'canplaythrough', 'durationchange', 'emptied', 'encrypted', 'ended', 'error', 'loadeddata', 'loadedmetadata', 'loadstart', 'pause', 'play', 'playing', 'progress', 'ratechange', 'seeked', 'seeking', 'stalled', 'suspend', 'timeupdate', 'volumechange', 'waiting']; // We should not delegate these events to the container, but rather
// set them on the actual target element itself. This is primarily
// because these events do not consistently bubble in the DOM.

var nonDelegatedEvents = new Set(['cancel', 'close', 'invalid', 'load', 'scroll', 'toggle'].concat(mediaEventTypes));

function executeDispatch(event, listener, currentTarget) {
  var type = event.type || 'unknown-event';
  event.currentTarget = currentTarget;
  invokeGuardedCallbackAndCatchFirstError(type, listener, undefined, event);
  event.currentTarget = null;
}

function processDispatchQueueItemsInOrder(event, dispatchListeners, inCapturePhase) {
  var previousInstance;

  if (inCapturePhase) {
    for (var i = dispatchListeners.length - 1; i >= 0; i--) {
      var _dispatchListeners$i = dispatchListeners[i],
          instance = _dispatchListeners$i.instance,
          currentTarget = _dispatchListeners$i.currentTarget,
          listener = _dispatchListeners$i.listener;

      if (instance !== previousInstance && event.isPropagationStopped()) {
        return;
      }

      executeDispatch(event, listener, currentTarget);
      previousInstance = instance;
    }
  } else {
    for (var _i = 0; _i < dispatchListeners.length; _i++) {
      var _dispatchListeners$_i = dispatchListeners[_i],
          _instance = _dispatchListeners$_i.instance,
          _currentTarget = _dispatchListeners$_i.currentTarget,
          _listener = _dispatchListeners$_i.listener;

      if (_instance !== previousInstance && event.isPropagationStopped()) {
        return;
      }

      executeDispatch(event, _listener, _currentTarget);
      previousInstance = _instance;
    }
  }
}

function processDispatchQueue(dispatchQueue, eventSystemFlags) {
  var inCapturePhase = (eventSystemFlags & IS_CAPTURE_PHASE) !== 0;

  for (var i = 0; i < dispatchQueue.length; i++) {
    var _dispatchQueue$i = dispatchQueue[i],
        event = _dispatchQueue$i.event,
        listeners = _dispatchQueue$i.listeners;
    processDispatchQueueItemsInOrder(event, listeners, inCapturePhase); //  event system doesn't use pooling.
  } // This would be a good time to rethrow if any of the event handlers threw.


  rethrowCaughtError();
}

function dispatchEventsForPlugins(domEventName, eventSystemFlags, nativeEvent, targetInst, targetContainer) {
  var nativeEventTarget = getEventTarget(nativeEvent);
  var dispatchQueue = [];
  extractEvents$5(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags);
  processDispatchQueue(dispatchQueue, eventSystemFlags);
}

function listenToNonDelegatedEvent(domEventName, targetElement) {
  var isCapturePhaseListener = false;
  var listenerSet = getEventListenerSet(targetElement);
  var listenerSetKey = getListenerSetKey(domEventName, isCapturePhaseListener);

  if (!listenerSet.has(listenerSetKey)) {
    addTrappedEventListener(targetElement, domEventName, IS_NON_DELEGATED, isCapturePhaseListener);
    listenerSet.add(listenerSetKey);
  }
}
var listeningMarker = '_reactListening' + Math.random().toString(36).slice(2);
function listenToAllSupportedEvents(rootContainerElement) {
  {
    if (rootContainerElement[listeningMarker]) {
      // Performance optimization: don't iterate through events
      // for the same portal container or root node more than once.
      // TODO: once we remove the flag, we may be able to also
      // remove some of the bookkeeping maps used for laziness.
      return;
    }

    rootContainerElement[listeningMarker] = true;
    allNativeEvents.forEach(function (domEventName) {
      if (!nonDelegatedEvents.has(domEventName)) {
        listenToNativeEvent(domEventName, false, rootContainerElement, null);
      }

      listenToNativeEvent(domEventName, true, rootContainerElement, null);
    });
  }
}
function listenToNativeEvent(domEventName, isCapturePhaseListener, rootContainerElement, targetElement) {
  var eventSystemFlags = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;
  var target = rootContainerElement; // selectionchange needs to be attached to the document
  // otherwise it won't capture incoming events that are only
  // triggered on the document directly.

  if (domEventName === 'selectionchange' && rootContainerElement.nodeType !== DOCUMENT_NODE) {
    target = rootContainerElement.ownerDocument;
  } // If the event can be delegated (or is capture phase), we can
  // register it to the root container. Otherwise, we should
  // register the event to the target element and mark it as
  // a non-delegated event.


  if (targetElement !== null && !isCapturePhaseListener && nonDelegatedEvents.has(domEventName)) {
    // For all non-delegated events, apart from scroll, we attach
    // their event listeners to the respective elements that their
    // events fire on. That means we can skip this step, as event
    // listener has already been added previously. However, we
    // special case the scroll event because the reality is that any
    // element can scroll.
    // TODO: ideally, we'd eventually apply the same logic to all
    // events from the nonDelegatedEvents list. Then we can remove
    // this special case and use the same logic for all events.
    if (domEventName !== 'scroll') {
      return;
    }

    eventSystemFlags |= IS_NON_DELEGATED;
    target = targetElement;
  }

  var listenerSet = getEventListenerSet(target);
  var listenerSetKey = getListenerSetKey(domEventName, isCapturePhaseListener); // If the listener entry is empty or we should upgrade, then
  // we need to trap an event listener onto the target.

  if (!listenerSet.has(listenerSetKey)) {
    if (isCapturePhaseListener) {
      eventSystemFlags |= IS_CAPTURE_PHASE;
    }

    addTrappedEventListener(target, domEventName, eventSystemFlags, isCapturePhaseListener);
    listenerSet.add(listenerSetKey);
  }
}

function addTrappedEventListener(targetContainer, domEventName, eventSystemFlags, isCapturePhaseListener, isDeferredListenerForLegacyFBSupport) {
  var listener = createEventListenerWrapperWithPriority(targetContainer, domEventName, eventSystemFlags); // If passive option is not supported, then the event will be
  // active and not passive.

  var isPassiveListener = undefined;

  if (passiveBrowserEventsSupported) {
    // Browsers introduced an intervention, making these events
    // passive by default on document. React doesn't bind them
    // to document anymore, but changing this now would undo
    // the performance wins from the change. So we emulate
    // the existing behavior manually on the roots now.
    // https://github.com/facebook/react/issues/19651
    if (domEventName === 'touchstart' || domEventName === 'touchmove' || domEventName === 'wheel') {
      isPassiveListener = true;
    }
  }

  targetContainer =  targetContainer;
  var unsubscribeListener; // When legacyFBSupport is enabled, it's for when we


  if (isCapturePhaseListener) {
    if (isPassiveListener !== undefined) {
      unsubscribeListener = addEventCaptureListenerWithPassiveFlag(targetContainer, domEventName, listener, isPassiveListener);
    } else {
      unsubscribeListener = addEventCaptureListener(targetContainer, domEventName, listener);
    }
  } else {
    if (isPassiveListener !== undefined) {
      unsubscribeListener = addEventBubbleListenerWithPassiveFlag(targetContainer, domEventName, listener, isPassiveListener);
    } else {
      unsubscribeListener = addEventBubbleListener(targetContainer, domEventName, listener);
    }
  }
}

function isMatchingRootContainer(grandContainer, targetContainer) {
  return grandContainer === targetContainer || grandContainer.nodeType === COMMENT_NODE && grandContainer.parentNode === targetContainer;
}

function dispatchEventForPluginEventSystem(domEventName, eventSystemFlags, nativeEvent, targetInst, targetContainer) {
  var ancestorInst = targetInst;

  if ((eventSystemFlags & IS_EVENT_HANDLE_NON_MANAGED_NODE) === 0 && (eventSystemFlags & IS_NON_DELEGATED) === 0) {
    var targetContainerNode = targetContainer; // If we are using the legacy FB support flag, we

    if (targetInst !== null) {
      // The below logic attempts to work out if we need to change
      // the target fiber to a different ancestor. We had similar logic
      // in the legacy event system, except the big difference between
      // systems is that the modern event system now has an event listener
      // attached to each React Root and React Portal Root. Together,
      // the DOM nodes representing these roots are the "rootContainer".
      // To figure out which ancestor instance we should use, we traverse
      // up the fiber tree from the target instance and attempt to find
      // root boundaries that match that of our current "rootContainer".
      // If we find that "rootContainer", we find the parent fiber
      // sub-tree for that root and make that our ancestor instance.
      var node = targetInst;

      mainLoop: while (true) {
        if (node === null) {
          return;
        }

        var nodeTag = node.tag;

        if (nodeTag === HostRoot || nodeTag === HostPortal) {
          var container = node.stateNode.containerInfo;

          if (isMatchingRootContainer(container, targetContainerNode)) {
            break;
          }

          if (nodeTag === HostPortal) {
            // The target is a portal, but it's not the rootContainer we're looking for.
            // Normally portals handle their own events all the way down to the root.
            // So we should be able to stop now. However, we don't know if this portal
            // was part of *our* root.
            var grandNode = node.return;

            while (grandNode !== null) {
              var grandTag = grandNode.tag;

              if (grandTag === HostRoot || grandTag === HostPortal) {
                var grandContainer = grandNode.stateNode.containerInfo;

                if (isMatchingRootContainer(grandContainer, targetContainerNode)) {
                  // This is the rootContainer we're looking for and we found it as
                  // a parent of the Portal. That means we can ignore it because the
                  // Portal will bubble through to us.
                  return;
                }
              }

              grandNode = grandNode.return;
            }
          } // Now we need to find it's corresponding host fiber in the other
          // tree. To do this we can use getClosestInstanceFromNode, but we
          // need to validate that the fiber is a host instance, otherwise
          // we need to traverse up through the DOM till we find the correct
          // node that is from the other tree.


          while (container !== null) {
            var parentNode = getClosestInstanceFromNode(container);

            if (parentNode === null) {
              return;
            }

            var parentTag = parentNode.tag;

            if (parentTag === HostComponent || parentTag === HostText) {
              node = ancestorInst = parentNode;
              continue mainLoop;
            }

            container = container.parentNode;
          }
        }

        node = node.return;
      }
    }
  }

  batchedEventUpdates(function () {
    return dispatchEventsForPlugins(domEventName, eventSystemFlags, nativeEvent, ancestorInst);
  });
}

function createDispatchListener(instance, listener, currentTarget) {
  return {
    instance: instance,
    listener: listener,
    currentTarget: currentTarget
  };
}

function accumulateSinglePhaseListeners(targetFiber, reactName, nativeEventType, inCapturePhase, accumulateTargetOnly) {
  var captureName = reactName !== null ? reactName + 'Capture' : null;
  var reactEventName = inCapturePhase ? captureName : reactName;
  var listeners = [];
  var instance = targetFiber;
  var lastHostComponent = null; // Accumulate all instances and listeners via the target -> root path.

  while (instance !== null) {
    var _instance2 = instance,
        stateNode = _instance2.stateNode,
        tag = _instance2.tag; // Handle listeners that are on HostComponents (i.e. <div>)

    if (tag === HostComponent && stateNode !== null) {
      lastHostComponent = stateNode; // createEventHandle listeners


      if (reactEventName !== null) {
        var listener = getListener(instance, reactEventName);

        if (listener != null) {
          listeners.push(createDispatchListener(instance, listener, lastHostComponent));
        }
      }
    } // If we are only accumulating events for the target, then we don't
    // continue to propagate through the React fiber tree to find other
    // listeners.


    if (accumulateTargetOnly) {
      break;
    }

    instance = instance.return;
  }

  return listeners;
} // We should only use this function for:
// - BeforeInputEventPlugin
// - ChangeEventPlugin
// - SelectEventPlugin
// This is because we only process these plugins
// in the bubble phase, so we need to accumulate two
// phase event listeners (via emulation).

function accumulateTwoPhaseListeners(targetFiber, reactName) {
  var captureName = reactName + 'Capture';
  var listeners = [];
  var instance = targetFiber; // Accumulate all instances and listeners via the target -> root path.

  while (instance !== null) {
    var _instance3 = instance,
        stateNode = _instance3.stateNode,
        tag = _instance3.tag; // Handle listeners that are on HostComponents (i.e. <div>)

    if (tag === HostComponent && stateNode !== null) {
      var currentTarget = stateNode;
      var captureListener = getListener(instance, captureName);

      if (captureListener != null) {
        listeners.unshift(createDispatchListener(instance, captureListener, currentTarget));
      }

      var bubbleListener = getListener(instance, reactName);

      if (bubbleListener != null) {
        listeners.push(createDispatchListener(instance, bubbleListener, currentTarget));
      }
    }

    instance = instance.return;
  }

  return listeners;
}

function getParent(inst) {
  if (inst === null) {
    return null;
  }

  do {
    inst = inst.return; // TODO: If this is a HostRoot we might want to bail out.
    // That is depending on if we want nested subtrees (layers) to bubble
    // events to their parent. We could also go through parentNode on the
    // host node but that wouldn't work for React Native and doesn't let us
    // do the portal feature.
  } while (inst && inst.tag !== HostComponent);

  if (inst) {
    return inst;
  }

  return null;
}
/**
 * Return the lowest common ancestor of A and B, or null if they are in
 * different trees.
 */


function getLowestCommonAncestor(instA, instB) {
  var nodeA = instA;
  var nodeB = instB;
  var depthA = 0;

  for (var tempA = nodeA; tempA; tempA = getParent(tempA)) {
    depthA++;
  }

  var depthB = 0;

  for (var tempB = nodeB; tempB; tempB = getParent(tempB)) {
    depthB++;
  } // If A is deeper, crawl up.


  while (depthA - depthB > 0) {
    nodeA = getParent(nodeA);
    depthA--;
  } // If B is deeper, crawl up.


  while (depthB - depthA > 0) {
    nodeB = getParent(nodeB);
    depthB--;
  } // Walk in lockstep until we find a match.


  var depth = depthA;

  while (depth--) {
    if (nodeA === nodeB || nodeB !== null && nodeA === nodeB.alternate) {
      return nodeA;
    }

    nodeA = getParent(nodeA);
    nodeB = getParent(nodeB);
  }

  return null;
}

function accumulateEnterLeaveListenersForEvent(dispatchQueue, event, target, common, inCapturePhase) {
  var registrationName = event._reactName;
  var listeners = [];
  var instance = target;

  while (instance !== null) {
    if (instance === common) {
      break;
    }

    var _instance4 = instance,
        alternate = _instance4.alternate,
        stateNode = _instance4.stateNode,
        tag = _instance4.tag;

    if (alternate !== null && alternate === common) {
      break;
    }

    if (tag === HostComponent && stateNode !== null) {
      var currentTarget = stateNode;

      if (inCapturePhase) {
        var captureListener = getListener(instance, registrationName);

        if (captureListener != null) {
          listeners.unshift(createDispatchListener(instance, captureListener, currentTarget));
        }
      } else if (!inCapturePhase) {
        var bubbleListener = getListener(instance, registrationName);

        if (bubbleListener != null) {
          listeners.push(createDispatchListener(instance, bubbleListener, currentTarget));
        }
      }
    }

    instance = instance.return;
  }

  if (listeners.length !== 0) {
    dispatchQueue.push({
      event: event,
      listeners: listeners
    });
  }
} // We should only use this function for:
// - EnterLeaveEventPlugin
// This is because we only process this plugin
// in the bubble phase, so we need to accumulate two
// phase event listeners.


function accumulateEnterLeaveTwoPhaseListeners(dispatchQueue, leaveEvent, enterEvent, from, to) {
  var common = from && to ? getLowestCommonAncestor(from, to) : null;

  if (from !== null) {
    accumulateEnterLeaveListenersForEvent(dispatchQueue, leaveEvent, from, common, false);
  }

  if (to !== null && enterEvent !== null) {
    accumulateEnterLeaveListenersForEvent(dispatchQueue, enterEvent, to, common, true);
  }
}
function getListenerSetKey(domEventName, capture) {
  return domEventName + "__" + (capture ? 'capture' : 'bubble');
}

var didWarnInvalidHydration = false;
var DANGEROUSLY_SET_INNER_HTML = 'dangerouslySetInnerHTML';
var SUPPRESS_CONTENT_EDITABLE_WARNING = 'suppressContentEditableWarning';
var SUPPRESS_HYDRATION_WARNING = 'suppressHydrationWarning';
var AUTOFOCUS = 'autoFocus';
var CHILDREN = 'children';
var STYLE = 'style';
var HTML$1 = '__html';
var HTML_NAMESPACE$1 = Namespaces.html;
var warnedUnknownTags;
var suppressHydrationWarning;
var validatePropertiesInDevelopment;
var warnForTextDifference;
var warnForPropDifference;
var warnForExtraAttributes;
var warnForInvalidEventListener;
var canDiffStyleForHydrationWarning;
var normalizeMarkupForTextOrAttribute;
var normalizeHTML;

{
  warnedUnknownTags = {
    // There are working polyfills for <dialog>. Let people use it.
    dialog: true,
    // Electron ships a custom <webview> tag to display external web content in
    // an isolated frame and process.
    // This tag is not present in non Electron environments such as JSDom which
    // is often used for testing purposes.
    // @see https://electronjs.org/docs/api/webview-tag
    webview: true
  };

  validatePropertiesInDevelopment = function (type, props) {
    validateProperties(type, props);
    validateProperties$1(type, props);
    validateProperties$2(type, props, {
      registrationNameDependencies: registrationNameDependencies,
      possibleRegistrationNames: possibleRegistrationNames
    });
  }; // IE 11 parses & normalizes the style attribute as opposed to other
  // browsers. It adds spaces and sorts the properties in some
  // non-alphabetical order. Handling that would require sorting CSS
  // properties in the client & server versions or applying
  // `expectedStyle` to a temporary DOM node to read its `style` attribute
  // normalized. Since it only affects IE, we're skipping style warnings
  // in that browser completely in favor of doing all that work.
  // See https://github.com/facebook/react/issues/11807


  canDiffStyleForHydrationWarning = canUseDOM && !document.documentMode; // HTML parsing normalizes CR and CRLF to LF.
  // It also can turn \u0000 into \uFFFD inside attributes.
  // https://www.w3.org/TR/html5/single-page.html#preprocessing-the-input-stream
  // If we have a mismatch, it might be caused by that.
  // We will still patch up in this case but not fire the warning.

  var NORMALIZE_NEWLINES_REGEX = /\r\n?/g;
  var NORMALIZE_NULL_AND_REPLACEMENT_REGEX = /\u0000|\uFFFD/g;

  normalizeMarkupForTextOrAttribute = function (markup) {
    var markupString = typeof markup === 'string' ? markup : '' + markup;
    return markupString.replace(NORMALIZE_NEWLINES_REGEX, '\n').replace(NORMALIZE_NULL_AND_REPLACEMENT_REGEX, '');
  };

  warnForTextDifference = function (serverText, clientText) {
    if (didWarnInvalidHydration) {
      return;
    }

    var normalizedClientText = normalizeMarkupForTextOrAttribute(clientText);
    var normalizedServerText = normalizeMarkupForTextOrAttribute(serverText);

    if (normalizedServerText === normalizedClientText) {
      return;
    }

    didWarnInvalidHydration = true;

    error('Text content did not match. Server: "%s" Client: "%s"', normalizedServerText, normalizedClientText);
  };

  warnForPropDifference = function (propName, serverValue, clientValue) {
    if (didWarnInvalidHydration) {
      return;
    }

    var normalizedClientValue = normalizeMarkupForTextOrAttribute(clientValue);
    var normalizedServerValue = normalizeMarkupForTextOrAttribute(serverValue);

    if (normalizedServerValue === normalizedClientValue) {
      return;
    }

    didWarnInvalidHydration = true;

    error('Prop `%s` did not match. Server: %s Client: %s', propName, JSON.stringify(normalizedServerValue), JSON.stringify(normalizedClientValue));
  };

  warnForExtraAttributes = function (attributeNames) {
    if (didWarnInvalidHydration) {
      return;
    }

    didWarnInvalidHydration = true;
    var names = [];
    attributeNames.forEach(function (name) {
      names.push(name);
    });

    error('Extra attributes from the server: %s', names);
  };

  warnForInvalidEventListener = function (registrationName, listener) {
    if (listener === false) {
      error('Expected `%s` listener to be a function, instead got `false`.\n\n' + 'If you used to conditionally omit it with %s={condition && value}, ' + 'pass %s={condition ? value : undefined} instead.', registrationName, registrationName, registrationName);
    } else {
      error('Expected `%s` listener to be a function, instead got a value of `%s` type.', registrationName, typeof listener);
    }
  }; // Parse the HTML and read it back to normalize the HTML string so that it
  // can be used for comparison.


  normalizeHTML = function (parent, html) {
    // We could have created a separate document here to avoid
    // re-initializing custom elements if they exist. But this breaks
    // how <noscript> is being handled. So we use the same document.
    // See the discussion in https://github.com/facebook/react/pull/11157.
    var testElement = parent.namespaceURI === HTML_NAMESPACE$1 ? parent.ownerDocument.createElement(parent.tagName) : parent.ownerDocument.createElementNS(parent.namespaceURI, parent.tagName);
    testElement.innerHTML = html;
    return testElement.innerHTML;
  };
}

function getOwnerDocumentFromRootContainer(rootContainerElement) {
  return rootContainerElement.nodeType === DOCUMENT_NODE ? rootContainerElement : rootContainerElement.ownerDocument;
}

function noop() {}

function trapClickOnNonInteractiveElement(node) {
  // Mobile Safari does not fire properly bubble click events on
  // non-interactive elements, which means delegated click listeners do not
  // fire. The workaround for this bug involves attaching an empty click
  // listener on the target node.
  // https://www.quirksmode.org/blog/archives/2010/09/click_event_del.html
  // Just set it using the onclick property so that we don't have to manage any
  // bookkeeping for it. Not sure if we need to clear it when the listener is
  // removed.
  // TODO: Only do this for the relevant Safaris maybe?
  node.onclick = noop;
}

function setInitialDOMProperties(tag, domElement, rootContainerElement, nextProps, isCustomComponentTag) {
  for (var propKey in nextProps) {
    if (!nextProps.hasOwnProperty(propKey)) {
      continue;
    }

    var nextProp = nextProps[propKey];

    if (propKey === STYLE) {
      {
        if (nextProp) {
          // Freeze the next style object so that we can assume it won't be
          // mutated. We have already warned for this in the past.
          Object.freeze(nextProp);
        }
      } // Relies on `updateStylesByID` not mutating `styleUpdates`.


      setValueForStyles(domElement, nextProp);
    } else if (propKey === DANGEROUSLY_SET_INNER_HTML) {
      var nextHtml = nextProp ? nextProp[HTML$1] : undefined;

      if (nextHtml != null) {
        setInnerHTML(domElement, nextHtml);
      }
    } else if (propKey === CHILDREN) {
      if (typeof nextProp === 'string') {
        // Avoid setting initial textContent when the text is empty. In IE11 setting
        // textContent on a <textarea> will cause the placeholder to not
        // show within the <textarea> until it has been focused and blurred again.
        // https://github.com/facebook/react/issues/6731#issuecomment-254874553
        var canSetTextContent = tag !== 'textarea' || nextProp !== '';

        if (canSetTextContent) {
          setTextContent(domElement, nextProp);
        }
      } else if (typeof nextProp === 'number') {
        setTextContent(domElement, '' + nextProp);
      }
    } else if (propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING) ; else if (propKey === AUTOFOCUS) ; else if (registrationNameDependencies.hasOwnProperty(propKey)) {
      if (nextProp != null) {
        if ( typeof nextProp !== 'function') {
          warnForInvalidEventListener(propKey, nextProp);
        }

        if (propKey === 'onScroll') {
          listenToNonDelegatedEvent('scroll', domElement);
        }
      }
    } else if (nextProp != null) {
      setValueForProperty(domElement, propKey, nextProp, isCustomComponentTag);
    }
  }
}

function updateDOMProperties(domElement, updatePayload, wasCustomComponentTag, isCustomComponentTag) {
  // TODO: Handle wasCustomComponentTag
  for (var i = 0; i < updatePayload.length; i += 2) {
    var propKey = updatePayload[i];
    var propValue = updatePayload[i + 1];

    if (propKey === STYLE) {
      setValueForStyles(domElement, propValue);
    } else if (propKey === DANGEROUSLY_SET_INNER_HTML) {
      setInnerHTML(domElement, propValue);
    } else if (propKey === CHILDREN) {
      setTextContent(domElement, propValue);
    } else {
      setValueForProperty(domElement, propKey, propValue, isCustomComponentTag);
    }
  }
}

function createElement(type, props, rootContainerElement, parentNamespace) {
  var isCustomComponentTag; // We create tags in the namespace of their parent container, except HTML
  // tags get no namespace.

  var ownerDocument = getOwnerDocumentFromRootContainer(rootContainerElement);
  var domElement;
  var namespaceURI = parentNamespace;

  if (namespaceURI === HTML_NAMESPACE$1) {
    namespaceURI = getIntrinsicNamespace(type);
  }

  if (namespaceURI === HTML_NAMESPACE$1) {
    {
      isCustomComponentTag = isCustomComponent(type, props); // Should this check be gated by parent namespace? Not sure we want to
      // allow <SVG> or <mATH>.

      if (!isCustomComponentTag && type !== type.toLowerCase()) {
        error('<%s /> is using incorrect casing. ' + 'Use PascalCase for React components, ' + 'or lowercase for HTML elements.', type);
      }
    }

    if (type === 'script') {
      // Create the script via .innerHTML so its "parser-inserted" flag is
      // set to true and it does not execute
      var div = ownerDocument.createElement('div');

      div.innerHTML = '<script><' + '/script>'; // eslint-disable-line
      // This is guaranteed to yield a script element.

      var firstChild = div.firstChild;
      domElement = div.removeChild(firstChild);
    } else if (typeof props.is === 'string') {
      // $FlowIssue `createElement` should be updated for Web Components
      domElement = ownerDocument.createElement(type, {
        is: props.is
      });
    } else {
      // Separate else branch instead of using `props.is || undefined` above because of a Firefox bug.
      // See discussion in https://github.com/facebook/react/pull/6896
      // and discussion in https://bugzilla.mozilla.org/show_bug.cgi?id=1276240
      domElement = ownerDocument.createElement(type); // Normally attributes are assigned in `setInitialDOMProperties`, however the `multiple` and `size`
      // attributes on `select`s needs to be added before `option`s are inserted.
      // This prevents:
      // - a bug where the `select` does not scroll to the correct option because singular
      //  `select` elements automatically pick the first item #13222
      // - a bug where the `select` set the first item as selected despite the `size` attribute #14239
      // See https://github.com/facebook/react/issues/13222
      // and https://github.com/facebook/react/issues/14239

      if (type === 'select') {
        var node = domElement;

        if (props.multiple) {
          node.multiple = true;
        } else if (props.size) {
          // Setting a size greater than 1 causes a select to behave like `multiple=true`, where
          // it is possible that no option is selected.
          //
          // This is only necessary when a select in "single selection mode".
          node.size = props.size;
        }
      }
    }
  } else {
    domElement = ownerDocument.createElementNS(namespaceURI, type);
  }

  {
    if (namespaceURI === HTML_NAMESPACE$1) {
      if (!isCustomComponentTag && Object.prototype.toString.call(domElement) === '[object HTMLUnknownElement]' && !Object.prototype.hasOwnProperty.call(warnedUnknownTags, type)) {
        warnedUnknownTags[type] = true;

        error('The tag <%s> is unrecognized in this browser. ' + 'If you meant to render a React component, start its name with ' + 'an uppercase letter.', type);
      }
    }
  }

  return domElement;
}
function createTextNode(text, rootContainerElement) {
  return getOwnerDocumentFromRootContainer(rootContainerElement).createTextNode(text);
}
function setInitialProperties(domElement, tag, rawProps, rootContainerElement) {
  var isCustomComponentTag = isCustomComponent(tag, rawProps);

  {
    validatePropertiesInDevelopment(tag, rawProps);
  } // TODO: Make sure that we check isMounted before firing any of these events.


  var props;

  switch (tag) {
    case 'dialog':
      listenToNonDelegatedEvent('cancel', domElement);
      listenToNonDelegatedEvent('close', domElement);
      props = rawProps;
      break;

    case 'iframe':
    case 'object':
    case 'embed':
      // We listen to this event in case to ensure emulated bubble
      // listeners still fire for the load event.
      listenToNonDelegatedEvent('load', domElement);
      props = rawProps;
      break;

    case 'video':
    case 'audio':
      // We listen to these events in case to ensure emulated bubble
      // listeners still fire for all the media events.
      for (var i = 0; i < mediaEventTypes.length; i++) {
        listenToNonDelegatedEvent(mediaEventTypes[i], domElement);
      }

      props = rawProps;
      break;

    case 'source':
      // We listen to this event in case to ensure emulated bubble
      // listeners still fire for the error event.
      listenToNonDelegatedEvent('error', domElement);
      props = rawProps;
      break;

    case 'img':
    case 'image':
    case 'link':
      // We listen to these events in case to ensure emulated bubble
      // listeners still fire for error and load events.
      listenToNonDelegatedEvent('error', domElement);
      listenToNonDelegatedEvent('load', domElement);
      props = rawProps;
      break;

    case 'details':
      // We listen to this event in case to ensure emulated bubble
      // listeners still fire for the toggle event.
      listenToNonDelegatedEvent('toggle', domElement);
      props = rawProps;
      break;

    case 'input':
      initWrapperState(domElement, rawProps);
      props = getHostProps(domElement, rawProps); // We listen to this event in case to ensure emulated bubble
      // listeners still fire for the invalid event.

      listenToNonDelegatedEvent('invalid', domElement);

      break;

    case 'option':
      validateProps(domElement, rawProps);
      props = getHostProps$1(domElement, rawProps);
      break;

    case 'select':
      initWrapperState$1(domElement, rawProps);
      props = getHostProps$2(domElement, rawProps); // We listen to this event in case to ensure emulated bubble
      // listeners still fire for the invalid event.

      listenToNonDelegatedEvent('invalid', domElement);

      break;

    case 'textarea':
      initWrapperState$2(domElement, rawProps);
      props = getHostProps$3(domElement, rawProps); // We listen to this event in case to ensure emulated bubble
      // listeners still fire for the invalid event.

      listenToNonDelegatedEvent('invalid', domElement);

      break;

    default:
      props = rawProps;
  }

  assertValidProps(tag, props);
  setInitialDOMProperties(tag, domElement, rootContainerElement, props, isCustomComponentTag);

  switch (tag) {
    case 'input':
      // TODO: Make sure we check if this is still unmounted or do any clean
      // up necessary since we never stop tracking anymore.
      track(domElement);
      postMountWrapper(domElement, rawProps, false);
      break;

    case 'textarea':
      // TODO: Make sure we check if this is still unmounted or do any clean
      // up necessary since we never stop tracking anymore.
      track(domElement);
      postMountWrapper$3(domElement);
      break;

    case 'option':
      postMountWrapper$1(domElement, rawProps);
      break;

    case 'select':
      postMountWrapper$2(domElement, rawProps);
      break;

    default:
      if (typeof props.onClick === 'function') {
        // TODO: This cast may not be sound for SVG, MathML or custom elements.
        trapClickOnNonInteractiveElement(domElement);
      }

      break;
  }
} // Calculate the diff between the two objects.

function diffProperties(domElement, tag, lastRawProps, nextRawProps, rootContainerElement) {
  {
    validatePropertiesInDevelopment(tag, nextRawProps);
  }

  var updatePayload = null;
  var lastProps;
  var nextProps;

  switch (tag) {
    case 'input':
      lastProps = getHostProps(domElement, lastRawProps);
      nextProps = getHostProps(domElement, nextRawProps);
      updatePayload = [];
      break;

    case 'option':
      lastProps = getHostProps$1(domElement, lastRawProps);
      nextProps = getHostProps$1(domElement, nextRawProps);
      updatePayload = [];
      break;

    case 'select':
      lastProps = getHostProps$2(domElement, lastRawProps);
      nextProps = getHostProps$2(domElement, nextRawProps);
      updatePayload = [];
      break;

    case 'textarea':
      lastProps = getHostProps$3(domElement, lastRawProps);
      nextProps = getHostProps$3(domElement, nextRawProps);
      updatePayload = [];
      break;

    default:
      lastProps = lastRawProps;
      nextProps = nextRawProps;

      if (typeof lastProps.onClick !== 'function' && typeof nextProps.onClick === 'function') {
        // TODO: This cast may not be sound for SVG, MathML or custom elements.
        trapClickOnNonInteractiveElement(domElement);
      }

      break;
  }

  assertValidProps(tag, nextProps);
  var propKey;
  var styleName;
  var styleUpdates = null;

  for (propKey in lastProps) {
    if (nextProps.hasOwnProperty(propKey) || !lastProps.hasOwnProperty(propKey) || lastProps[propKey] == null) {
      continue;
    }

    if (propKey === STYLE) {
      var lastStyle = lastProps[propKey];

      for (styleName in lastStyle) {
        if (lastStyle.hasOwnProperty(styleName)) {
          if (!styleUpdates) {
            styleUpdates = {};
          }

          styleUpdates[styleName] = '';
        }
      }
    } else if (propKey === DANGEROUSLY_SET_INNER_HTML || propKey === CHILDREN) ; else if (propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING) ; else if (propKey === AUTOFOCUS) ; else if (registrationNameDependencies.hasOwnProperty(propKey)) {
      // This is a special case. If any listener updates we need to ensure
      // that the "current" fiber pointer gets updated so we need a commit
      // to update this element.
      if (!updatePayload) {
        updatePayload = [];
      }
    } else {
      // For all other deleted properties we add it to the queue. We use
      // the allowed property list in the commit phase instead.
      (updatePayload = updatePayload || []).push(propKey, null);
    }
  }

  for (propKey in nextProps) {
    var nextProp = nextProps[propKey];
    var lastProp = lastProps != null ? lastProps[propKey] : undefined;

    if (!nextProps.hasOwnProperty(propKey) || nextProp === lastProp || nextProp == null && lastProp == null) {
      continue;
    }

    if (propKey === STYLE) {
      {
        if (nextProp) {
          // Freeze the next style object so that we can assume it won't be
          // mutated. We have already warned for this in the past.
          Object.freeze(nextProp);
        }
      }

      if (lastProp) {
        // Unset styles on `lastProp` but not on `nextProp`.
        for (styleName in lastProp) {
          if (lastProp.hasOwnProperty(styleName) && (!nextProp || !nextProp.hasOwnProperty(styleName))) {
            if (!styleUpdates) {
              styleUpdates = {};
            }

            styleUpdates[styleName] = '';
          }
        } // Update styles that changed since `lastProp`.


        for (styleName in nextProp) {
          if (nextProp.hasOwnProperty(styleName) && lastProp[styleName] !== nextProp[styleName]) {
            if (!styleUpdates) {
              styleUpdates = {};
            }

            styleUpdates[styleName] = nextProp[styleName];
          }
        }
      } else {
        // Relies on `updateStylesByID` not mutating `styleUpdates`.
        if (!styleUpdates) {
          if (!updatePayload) {
            updatePayload = [];
          }

          updatePayload.push(propKey, styleUpdates);
        }

        styleUpdates = nextProp;
      }
    } else if (propKey === DANGEROUSLY_SET_INNER_HTML) {
      var nextHtml = nextProp ? nextProp[HTML$1] : undefined;
      var lastHtml = lastProp ? lastProp[HTML$1] : undefined;

      if (nextHtml != null) {
        if (lastHtml !== nextHtml) {
          (updatePayload = updatePayload || []).push(propKey, nextHtml);
        }
      }
    } else if (propKey === CHILDREN) {
      if (typeof nextProp === 'string' || typeof nextProp === 'number') {
        (updatePayload = updatePayload || []).push(propKey, '' + nextProp);
      }
    } else if (propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING) ; else if (registrationNameDependencies.hasOwnProperty(propKey)) {
      if (nextProp != null) {
        // We eagerly listen to this even though we haven't committed yet.
        if ( typeof nextProp !== 'function') {
          warnForInvalidEventListener(propKey, nextProp);
        }

        if (propKey === 'onScroll') {
          listenToNonDelegatedEvent('scroll', domElement);
        }
      }

      if (!updatePayload && lastProp !== nextProp) {
        // This is a special case. If any listener updates we need to ensure
        // that the "current" props pointer gets updated so we need a commit
        // to update this element.
        updatePayload = [];
      }
    } else if (typeof nextProp === 'object' && nextProp !== null && nextProp.$$typeof === REACT_OPAQUE_ID_TYPE) {
      // If we encounter useOpaqueReference's opaque object, this means we are hydrating.
      // In this case, call the opaque object's toString function which generates a new client
      // ID so client and server IDs match and throws to rerender.
      nextProp.toString();
    } else {
      // For any other property we always add it to the queue and then we
      // filter it out using the allowed property list during the commit.
      (updatePayload = updatePayload || []).push(propKey, nextProp);
    }
  }

  if (styleUpdates) {
    {
      validateShorthandPropertyCollisionInDev(styleUpdates, nextProps[STYLE]);
    }

    (updatePayload = updatePayload || []).push(STYLE, styleUpdates);
  }

  return updatePayload;
} // Apply the diff.

function updateProperties(domElement, updatePayload, tag, lastRawProps, nextRawProps) {
  // Update checked *before* name.
  // In the middle of an update, it is possible to have multiple checked.
  // When a checked radio tries to change name, browser makes another radio's checked false.
  if (tag === 'input' && nextRawProps.type === 'radio' && nextRawProps.name != null) {
    updateChecked(domElement, nextRawProps);
  }

  var wasCustomComponentTag = isCustomComponent(tag, lastRawProps);
  var isCustomComponentTag = isCustomComponent(tag, nextRawProps); // Apply the diff.

  updateDOMProperties(domElement, updatePayload, wasCustomComponentTag, isCustomComponentTag); // TODO: Ensure that an update gets scheduled if any of the special props
  // changed.

  switch (tag) {
    case 'input':
      // Update the wrapper around inputs *after* updating props. This has to
      // happen after `updateDOMProperties`. Otherwise HTML5 input validations
      // raise warnings and prevent the new value from being assigned.
      updateWrapper(domElement, nextRawProps);
      break;

    case 'textarea':
      updateWrapper$1(domElement, nextRawProps);
      break;

    case 'select':
      // <select> value update needs to occur after <option> children
      // reconciliation
      postUpdateWrapper(domElement, nextRawProps);
      break;
  }
}

function getPossibleStandardName(propName) {
  {
    var lowerCasedName = propName.toLowerCase();

    if (!possibleStandardNames.hasOwnProperty(lowerCasedName)) {
      return null;
    }

    return possibleStandardNames[lowerCasedName] || null;
  }
}

function diffHydratedProperties(domElement, tag, rawProps, parentNamespace, rootContainerElement) {
  var isCustomComponentTag;
  var extraAttributeNames;

  {
    suppressHydrationWarning = rawProps[SUPPRESS_HYDRATION_WARNING] === true;
    isCustomComponentTag = isCustomComponent(tag, rawProps);
    validatePropertiesInDevelopment(tag, rawProps);
  } // TODO: Make sure that we check isMounted before firing any of these events.


  switch (tag) {
    case 'dialog':
      listenToNonDelegatedEvent('cancel', domElement);
      listenToNonDelegatedEvent('close', domElement);
      break;

    case 'iframe':
    case 'object':
    case 'embed':
      // We listen to this event in case to ensure emulated bubble
      // listeners still fire for the load event.
      listenToNonDelegatedEvent('load', domElement);
      break;

    case 'video':
    case 'audio':
      // We listen to these events in case to ensure emulated bubble
      // listeners still fire for all the media events.
      for (var i = 0; i < mediaEventTypes.length; i++) {
        listenToNonDelegatedEvent(mediaEventTypes[i], domElement);
      }

      break;

    case 'source':
      // We listen to this event in case to ensure emulated bubble
      // listeners still fire for the error event.
      listenToNonDelegatedEvent('error', domElement);
      break;

    case 'img':
    case 'image':
    case 'link':
      // We listen to these events in case to ensure emulated bubble
      // listeners still fire for error and load events.
      listenToNonDelegatedEvent('error', domElement);
      listenToNonDelegatedEvent('load', domElement);
      break;

    case 'details':
      // We listen to this event in case to ensure emulated bubble
      // listeners still fire for the toggle event.
      listenToNonDelegatedEvent('toggle', domElement);
      break;

    case 'input':
      initWrapperState(domElement, rawProps); // We listen to this event in case to ensure emulated bubble
      // listeners still fire for the invalid event.

      listenToNonDelegatedEvent('invalid', domElement);

      break;

    case 'option':
      validateProps(domElement, rawProps);
      break;

    case 'select':
      initWrapperState$1(domElement, rawProps); // We listen to this event in case to ensure emulated bubble
      // listeners still fire for the invalid event.

      listenToNonDelegatedEvent('invalid', domElement);

      break;

    case 'textarea':
      initWrapperState$2(domElement, rawProps); // We listen to this event in case to ensure emulated bubble
      // listeners still fire for the invalid event.

      listenToNonDelegatedEvent('invalid', domElement);

      break;
  }

  assertValidProps(tag, rawProps);

  {
    extraAttributeNames = new Set();
    var attributes = domElement.attributes;

    for (var _i = 0; _i < attributes.length; _i++) {
      var name = attributes[_i].name.toLowerCase();

      switch (name) {
        // Built-in SSR attribute is allowed
        case 'data-reactroot':
          break;
        // Controlled attributes are not validated
        // TODO: Only ignore them on controlled tags.

        case 'value':
          break;

        case 'checked':
          break;

        case 'selected':
          break;

        default:
          // Intentionally use the original name.
          // See discussion in https://github.com/facebook/react/pull/10676.
          extraAttributeNames.add(attributes[_i].name);
      }
    }
  }

  var updatePayload = null;

  for (var propKey in rawProps) {
    if (!rawProps.hasOwnProperty(propKey)) {
      continue;
    }

    var nextProp = rawProps[propKey];

    if (propKey === CHILDREN) {
      // For text content children we compare against textContent. This
      // might match additional HTML that is hidden when we read it using
      // textContent. E.g. "foo" will match "f<span>oo</span>" but that still
      // satisfies our requirement. Our requirement is not to produce perfect
      // HTML and attributes. Ideally we should preserve structure but it's
      // ok not to if the visible content is still enough to indicate what
      // even listeners these nodes might be wired up to.
      // TODO: Warn if there is more than a single textNode as a child.
      // TODO: Should we use domElement.firstChild.nodeValue to compare?
      if (typeof nextProp === 'string') {
        if (domElement.textContent !== nextProp) {
          if ( !suppressHydrationWarning) {
            warnForTextDifference(domElement.textContent, nextProp);
          }

          updatePayload = [CHILDREN, nextProp];
        }
      } else if (typeof nextProp === 'number') {
        if (domElement.textContent !== '' + nextProp) {
          if ( !suppressHydrationWarning) {
            warnForTextDifference(domElement.textContent, nextProp);
          }

          updatePayload = [CHILDREN, '' + nextProp];
        }
      }
    } else if (registrationNameDependencies.hasOwnProperty(propKey)) {
      if (nextProp != null) {
        if ( typeof nextProp !== 'function') {
          warnForInvalidEventListener(propKey, nextProp);
        }

        if (propKey === 'onScroll') {
          listenToNonDelegatedEvent('scroll', domElement);
        }
      }
    } else if ( // Convince Flow we've calculated it (it's DEV-only in this method.)
    typeof isCustomComponentTag === 'boolean') {
      // Validate that the properties correspond to their expected values.
      var serverValue = void 0;
      var propertyInfo = getPropertyInfo(propKey);

      if (suppressHydrationWarning) ; else if (propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING || // Controlled attributes are not validated
      // TODO: Only ignore them on controlled tags.
      propKey === 'value' || propKey === 'checked' || propKey === 'selected') ; else if (propKey === DANGEROUSLY_SET_INNER_HTML) {
        var serverHTML = domElement.innerHTML;
        var nextHtml = nextProp ? nextProp[HTML$1] : undefined;

        if (nextHtml != null) {
          var expectedHTML = normalizeHTML(domElement, nextHtml);

          if (expectedHTML !== serverHTML) {
            warnForPropDifference(propKey, serverHTML, expectedHTML);
          }
        }
      } else if (propKey === STYLE) {
        // $FlowFixMe - Should be inferred as not undefined.
        extraAttributeNames.delete(propKey);

        if (canDiffStyleForHydrationWarning) {
          var expectedStyle = createDangerousStringForStyles(nextProp);
          serverValue = domElement.getAttribute('style');

          if (expectedStyle !== serverValue) {
            warnForPropDifference(propKey, serverValue, expectedStyle);
          }
        }
      } else if (isCustomComponentTag) {
        // $FlowFixMe - Should be inferred as not undefined.
        extraAttributeNames.delete(propKey.toLowerCase());
        serverValue = getValueForAttribute(domElement, propKey, nextProp);

        if (nextProp !== serverValue) {
          warnForPropDifference(propKey, serverValue, nextProp);
        }
      } else if (!shouldIgnoreAttribute(propKey, propertyInfo, isCustomComponentTag) && !shouldRemoveAttribute(propKey, nextProp, propertyInfo, isCustomComponentTag)) {
        var isMismatchDueToBadCasing = false;

        if (propertyInfo !== null) {
          // $FlowFixMe - Should be inferred as not undefined.
          extraAttributeNames.delete(propertyInfo.attributeName);
          serverValue = getValueForProperty(domElement, propKey, nextProp, propertyInfo);
        } else {
          var ownNamespace = parentNamespace;

          if (ownNamespace === HTML_NAMESPACE$1) {
            ownNamespace = getIntrinsicNamespace(tag);
          }

          if (ownNamespace === HTML_NAMESPACE$1) {
            // $FlowFixMe - Should be inferred as not undefined.
            extraAttributeNames.delete(propKey.toLowerCase());
          } else {
            var standardName = getPossibleStandardName(propKey);

            if (standardName !== null && standardName !== propKey) {
              // If an SVG prop is supplied with bad casing, it will
              // be successfully parsed from HTML, but will produce a mismatch
              // (and would be incorrectly rendered on the client).
              // However, we already warn about bad casing elsewhere.
              // So we'll skip the misleading extra mismatch warning in this case.
              isMismatchDueToBadCasing = true; // $FlowFixMe - Should be inferred as not undefined.

              extraAttributeNames.delete(standardName);
            } // $FlowFixMe - Should be inferred as not undefined.


            extraAttributeNames.delete(propKey);
          }

          serverValue = getValueForAttribute(domElement, propKey, nextProp);
        }

        if (nextProp !== serverValue && !isMismatchDueToBadCasing) {
          warnForPropDifference(propKey, serverValue, nextProp);
        }
      }
    }
  }

  {
    // $FlowFixMe - Should be inferred as not undefined.
    if (extraAttributeNames.size > 0 && !suppressHydrationWarning) {
      // $FlowFixMe - Should be inferred as not undefined.
      warnForExtraAttributes(extraAttributeNames);
    }
  }

  switch (tag) {
    case 'input':
      // TODO: Make sure we check if this is still unmounted or do any clean
      // up necessary since we never stop tracking anymore.
      track(domElement);
      postMountWrapper(domElement, rawProps, true);
      break;

    case 'textarea':
      // TODO: Make sure we check if this is still unmounted or do any clean
      // up necessary since we never stop tracking anymore.
      track(domElement);
      postMountWrapper$3(domElement);
      break;

    case 'select':
    case 'option':
      // For input and textarea we current always set the value property at
      // post mount to force it to diverge from attributes. However, for
      // option and select we don't quite do the same thing and select
      // is not resilient to the DOM state changing so we don't do that here.
      // TODO: Consider not doing this for input and textarea.
      break;

    default:
      if (typeof rawProps.onClick === 'function') {
        // TODO: This cast may not be sound for SVG, MathML or custom elements.
        trapClickOnNonInteractiveElement(domElement);
      }

      break;
  }

  return updatePayload;
}
function diffHydratedText(textNode, text) {
  var isDifferent = textNode.nodeValue !== text;
  return isDifferent;
}
function warnForUnmatchedText(textNode, text) {
  {
    warnForTextDifference(textNode.nodeValue, text);
  }
}
function warnForDeletedHydratableElement(parentNode, child) {
  {
    if (didWarnInvalidHydration) {
      return;
    }

    didWarnInvalidHydration = true;

    error('Did not expect server HTML to contain a <%s> in <%s>.', child.nodeName.toLowerCase(), parentNode.nodeName.toLowerCase());
  }
}
function warnForDeletedHydratableText(parentNode, child) {
  {
    if (didWarnInvalidHydration) {
      return;
    }

    didWarnInvalidHydration = true;

    error('Did not expect server HTML to contain the text node "%s" in <%s>.', child.nodeValue, parentNode.nodeName.toLowerCase());
  }
}
function warnForInsertedHydratedElement(parentNode, tag, props) {
  {
    if (didWarnInvalidHydration) {
      return;
    }

    didWarnInvalidHydration = true;

    error('Expected server HTML to contain a matching <%s> in <%s>.', tag, parentNode.nodeName.toLowerCase());
  }
}
function warnForInsertedHydratedText(parentNode, text) {
  {
    if (text === '') {
      // We expect to insert empty text nodes since they're not represented in
      // the HTML.
      // TODO: Remove this special case if we can just avoid inserting empty
      // text nodes.
      return;
    }

    if (didWarnInvalidHydration) {
      return;
    }

    didWarnInvalidHydration = true;

    error('Expected server HTML to contain a matching text node for "%s" in <%s>.', text, parentNode.nodeName.toLowerCase());
  }
}
function restoreControlledState$3(domElement, tag, props) {
  switch (tag) {
    case 'input':
      restoreControlledState(domElement, props);
      return;

    case 'textarea':
      restoreControlledState$2(domElement, props);
      return;

    case 'select':
      restoreControlledState$1(domElement, props);
      return;
  }
}

var validateDOMNesting = function () {};

var updatedAncestorInfo = function () {};

{
  // This validation code was written based on the HTML5 parsing spec:
  // https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-scope
  //
  // Note: this does not catch all invalid nesting, nor does it try to (as it's
  // not clear what practical benefit doing so provides); instead, we warn only
  // for cases where the parser will give a parse tree differing from what React
  // intended. For example, <b><div></div></b> is invalid but we don't warn
  // because it still parses correctly; we do warn for other cases like nested
  // <p> tags where the beginning of the second element implicitly closes the
  // first, causing a confusing mess.
  // https://html.spec.whatwg.org/multipage/syntax.html#special
  var specialTags = ['address', 'applet', 'area', 'article', 'aside', 'base', 'basefont', 'bgsound', 'blockquote', 'body', 'br', 'button', 'caption', 'center', 'col', 'colgroup', 'dd', 'details', 'dir', 'div', 'dl', 'dt', 'embed', 'fieldset', 'figcaption', 'figure', 'footer', 'form', 'frame', 'frameset', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hgroup', 'hr', 'html', 'iframe', 'img', 'input', 'isindex', 'li', 'link', 'listing', 'main', 'marquee', 'menu', 'menuitem', 'meta', 'nav', 'noembed', 'noframes', 'noscript', 'object', 'ol', 'p', 'param', 'plaintext', 'pre', 'script', 'section', 'select', 'source', 'style', 'summary', 'table', 'tbody', 'td', 'template', 'textarea', 'tfoot', 'th', 'thead', 'title', 'tr', 'track', 'ul', 'wbr', 'xmp']; // https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-scope

  var inScopeTags = ['applet', 'caption', 'html', 'table', 'td', 'th', 'marquee', 'object', 'template', // https://html.spec.whatwg.org/multipage/syntax.html#html-integration-point
  // TODO: Distinguish by namespace here -- for <title>, including it here
  // errs on the side of fewer warnings
  'foreignObject', 'desc', 'title']; // https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-button-scope

  var buttonScopeTags = inScopeTags.concat(['button']); // https://html.spec.whatwg.org/multipage/syntax.html#generate-implied-end-tags

  var impliedEndTags = ['dd', 'dt', 'li', 'option', 'optgroup', 'p', 'rp', 'rt'];
  var emptyAncestorInfo = {
    current: null,
    formTag: null,
    aTagInScope: null,
    buttonTagInScope: null,
    nobrTagInScope: null,
    pTagInButtonScope: null,
    listItemTagAutoclosing: null,
    dlItemTagAutoclosing: null
  };

  updatedAncestorInfo = function (oldInfo, tag) {
    var ancestorInfo = _assign({}, oldInfo || emptyAncestorInfo);

    var info = {
      tag: tag
    };

    if (inScopeTags.indexOf(tag) !== -1) {
      ancestorInfo.aTagInScope = null;
      ancestorInfo.buttonTagInScope = null;
      ancestorInfo.nobrTagInScope = null;
    }

    if (buttonScopeTags.indexOf(tag) !== -1) {
      ancestorInfo.pTagInButtonScope = null;
    } // See rules for 'li', 'dd', 'dt' start tags in
    // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inbody


    if (specialTags.indexOf(tag) !== -1 && tag !== 'address' && tag !== 'div' && tag !== 'p') {
      ancestorInfo.listItemTagAutoclosing = null;
      ancestorInfo.dlItemTagAutoclosing = null;
    }

    ancestorInfo.current = info;

    if (tag === 'form') {
      ancestorInfo.formTag = info;
    }

    if (tag === 'a') {
      ancestorInfo.aTagInScope = info;
    }

    if (tag === 'button') {
      ancestorInfo.buttonTagInScope = info;
    }

    if (tag === 'nobr') {
      ancestorInfo.nobrTagInScope = info;
    }

    if (tag === 'p') {
      ancestorInfo.pTagInButtonScope = info;
    }

    if (tag === 'li') {
      ancestorInfo.listItemTagAutoclosing = info;
    }

    if (tag === 'dd' || tag === 'dt') {
      ancestorInfo.dlItemTagAutoclosing = info;
    }

    return ancestorInfo;
  };
  /**
   * Returns whether
   */


  var isTagValidWithParent = function (tag, parentTag) {
    // First, let's check if we're in an unusual parsing mode...
    switch (parentTag) {
      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inselect
      case 'select':
        return tag === 'option' || tag === 'optgroup' || tag === '#text';

      case 'optgroup':
        return tag === 'option' || tag === '#text';
      // Strictly speaking, seeing an <option> doesn't mean we're in a <select>
      // but

      case 'option':
        return tag === '#text';
      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intd
      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incaption
      // No special behavior since these rules fall back to "in body" mode for
      // all except special table nodes which cause bad parsing behavior anyway.
      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intr

      case 'tr':
        return tag === 'th' || tag === 'td' || tag === 'style' || tag === 'script' || tag === 'template';
      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intbody

      case 'tbody':
      case 'thead':
      case 'tfoot':
        return tag === 'tr' || tag === 'style' || tag === 'script' || tag === 'template';
      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incolgroup

      case 'colgroup':
        return tag === 'col' || tag === 'template';
      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intable

      case 'table':
        return tag === 'caption' || tag === 'colgroup' || tag === 'tbody' || tag === 'tfoot' || tag === 'thead' || tag === 'style' || tag === 'script' || tag === 'template';
      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inhead

      case 'head':
        return tag === 'base' || tag === 'basefont' || tag === 'bgsound' || tag === 'link' || tag === 'meta' || tag === 'title' || tag === 'noscript' || tag === 'noframes' || tag === 'style' || tag === 'script' || tag === 'template';
      // https://html.spec.whatwg.org/multipage/semantics.html#the-html-element

      case 'html':
        return tag === 'head' || tag === 'body' || tag === 'frameset';

      case 'frameset':
        return tag === 'frame';

      case '#document':
        return tag === 'html';
    } // Probably in the "in body" parsing mode, so we outlaw only tag combos
    // where the parsing rules cause implicit opens or closes to be added.
    // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inbody


    switch (tag) {
      case 'h1':
      case 'h2':
      case 'h3':
      case 'h4':
      case 'h5':
      case 'h6':
        return parentTag !== 'h1' && parentTag !== 'h2' && parentTag !== 'h3' && parentTag !== 'h4' && parentTag !== 'h5' && parentTag !== 'h6';

      case 'rp':
      case 'rt':
        return impliedEndTags.indexOf(parentTag) === -1;

      case 'body':
      case 'caption':
      case 'col':
      case 'colgroup':
      case 'frameset':
      case 'frame':
      case 'head':
      case 'html':
      case 'tbody':
      case 'td':
      case 'tfoot':
      case 'th':
      case 'thead':
      case 'tr':
        // These tags are only valid with a few parents that have special child
        // parsing rules -- if we're down here, then none of those matched and
        // so we allow it only if we don't know what the parent is, as all other
        // cases are invalid.
        return parentTag == null;
    }

    return true;
  };
  /**
   * Returns whether
   */


  var findInvalidAncestorForTag = function (tag, ancestorInfo) {
    switch (tag) {
      case 'address':
      case 'article':
      case 'aside':
      case 'blockquote':
      case 'center':
      case 'details':
      case 'dialog':
      case 'dir':
      case 'div':
      case 'dl':
      case 'fieldset':
      case 'figcaption':
      case 'figure':
      case 'footer':
      case 'header':
      case 'hgroup':
      case 'main':
      case 'menu':
      case 'nav':
      case 'ol':
      case 'p':
      case 'section':
      case 'summary':
      case 'ul':
      case 'pre':
      case 'listing':
      case 'table':
      case 'hr':
      case 'xmp':
      case 'h1':
      case 'h2':
      case 'h3':
      case 'h4':
      case 'h5':
      case 'h6':
        return ancestorInfo.pTagInButtonScope;

      case 'form':
        return ancestorInfo.formTag || ancestorInfo.pTagInButtonScope;

      case 'li':
        return ancestorInfo.listItemTagAutoclosing;

      case 'dd':
      case 'dt':
        return ancestorInfo.dlItemTagAutoclosing;

      case 'button':
        return ancestorInfo.buttonTagInScope;

      case 'a':
        // Spec says something about storing a list of markers, but it sounds
        // equivalent to this check.
        return ancestorInfo.aTagInScope;

      case 'nobr':
        return ancestorInfo.nobrTagInScope;
    }

    return null;
  };

  var didWarn$1 = {};

  validateDOMNesting = function (childTag, childText, ancestorInfo) {
    ancestorInfo = ancestorInfo || emptyAncestorInfo;
    var parentInfo = ancestorInfo.current;
    var parentTag = parentInfo && parentInfo.tag;

    if (childText != null) {
      if (childTag != null) {
        error('validateDOMNesting: when childText is passed, childTag should be null');
      }

      childTag = '#text';
    }

    var invalidParent = isTagValidWithParent(childTag, parentTag) ? null : parentInfo;
    var invalidAncestor = invalidParent ? null : findInvalidAncestorForTag(childTag, ancestorInfo);
    var invalidParentOrAncestor = invalidParent || invalidAncestor;

    if (!invalidParentOrAncestor) {
      return;
    }

    var ancestorTag = invalidParentOrAncestor.tag;
    var warnKey = !!invalidParent + '|' + childTag + '|' + ancestorTag;

    if (didWarn$1[warnKey]) {
      return;
    }

    didWarn$1[warnKey] = true;
    var tagDisplayName = childTag;
    var whitespaceInfo = '';

    if (childTag === '#text') {
      if (/\S/.test(childText)) {
        tagDisplayName = 'Text nodes';
      } else {
        tagDisplayName = 'Whitespace text nodes';
        whitespaceInfo = " Make sure you don't have any extra whitespace between tags on " + 'each line of your source code.';
      }
    } else {
      tagDisplayName = '<' + childTag + '>';
    }

    if (invalidParent) {
      var info = '';

      if (ancestorTag === 'table' && childTag === 'tr') {
        info += ' Add a <tbody>, <thead> or <tfoot> to your code to match the DOM tree generated by ' + 'the browser.';
      }

      error('validateDOMNesting(...): %s cannot appear as a child of <%s>.%s%s', tagDisplayName, ancestorTag, whitespaceInfo, info);
    } else {
      error('validateDOMNesting(...): %s cannot appear as a descendant of ' + '<%s>.', tagDisplayName, ancestorTag);
    }
  };
}

var SUPPRESS_HYDRATION_WARNING$1;

{
  SUPPRESS_HYDRATION_WARNING$1 = 'suppressHydrationWarning';
}

var SUSPENSE_START_DATA = '$';
var SUSPENSE_END_DATA = '/$';
var SUSPENSE_PENDING_START_DATA = '$?';
var SUSPENSE_FALLBACK_START_DATA = '$!';
var STYLE$1 = 'style';
var eventsEnabled = null;
var selectionInformation = null;

function shouldAutoFocusHostComponent(type, props) {
  switch (type) {
    case 'button':
    case 'input':
    case 'select':
    case 'textarea':
      return !!props.autoFocus;
  }

  return false;
}
function getRootHostContext(rootContainerInstance) {
  var type;
  var namespace;
  var nodeType = rootContainerInstance.nodeType;

  switch (nodeType) {
    case DOCUMENT_NODE:
    case DOCUMENT_FRAGMENT_NODE:
      {
        type = nodeType === DOCUMENT_NODE ? '#document' : '#fragment';
        var root = rootContainerInstance.documentElement;
        namespace = root ? root.namespaceURI : getChildNamespace(null, '');
        break;
      }

    default:
      {
        var container = nodeType === COMMENT_NODE ? rootContainerInstance.parentNode : rootContainerInstance;
        var ownNamespace = container.namespaceURI || null;
        type = container.tagName;
        namespace = getChildNamespace(ownNamespace, type);
        break;
      }
  }

  {
    var validatedTag = type.toLowerCase();
    var ancestorInfo = updatedAncestorInfo(null, validatedTag);
    return {
      namespace: namespace,
      ancestorInfo: ancestorInfo
    };
  }
}
function getChildHostContext(parentHostContext, type, rootContainerInstance) {
  {
    var parentHostContextDev = parentHostContext;
    var namespace = getChildNamespace(parentHostContextDev.namespace, type);
    var ancestorInfo = updatedAncestorInfo(parentHostContextDev.ancestorInfo, type);
    return {
      namespace: namespace,
      ancestorInfo: ancestorInfo
    };
  }
}
function getPublicInstance(instance) {
  return instance;
}
function prepareForCommit(containerInfo) {
  eventsEnabled = isEnabled();
  selectionInformation = getSelectionInformation();
  var activeInstance = null;

  setEnabled(false);
  return activeInstance;
}
function resetAfterCommit(containerInfo) {
  restoreSelection(selectionInformation);
  setEnabled(eventsEnabled);
  eventsEnabled = null;
  selectionInformation = null;
}
function createInstance(type, props, rootContainerInstance, hostContext, internalInstanceHandle) {
  var parentNamespace;

  {
    // TODO: take namespace into account when validating.
    var hostContextDev = hostContext;
    validateDOMNesting(type, null, hostContextDev.ancestorInfo);

    if (typeof props.children === 'string' || typeof props.children === 'number') {
      var string = '' + props.children;
      var ownAncestorInfo = updatedAncestorInfo(hostContextDev.ancestorInfo, type);
      validateDOMNesting(null, string, ownAncestorInfo);
    }

    parentNamespace = hostContextDev.namespace;
  }

  var domElement = createElement(type, props, rootContainerInstance, parentNamespace);
  precacheFiberNode(internalInstanceHandle, domElement);
  updateFiberProps(domElement, props);
  return domElement;
}
function appendInitialChild(parentInstance, child) {
  parentInstance.appendChild(child);
}
function finalizeInitialChildren(domElement, type, props, rootContainerInstance, hostContext) {
  setInitialProperties(domElement, type, props, rootContainerInstance);
  return shouldAutoFocusHostComponent(type, props);
}
function prepareUpdate(domElement, type, oldProps, newProps, rootContainerInstance, hostContext) {
  {
    var hostContextDev = hostContext;

    if (typeof newProps.children !== typeof oldProps.children && (typeof newProps.children === 'string' || typeof newProps.children === 'number')) {
      var string = '' + newProps.children;
      var ownAncestorInfo = updatedAncestorInfo(hostContextDev.ancestorInfo, type);
      validateDOMNesting(null, string, ownAncestorInfo);
    }
  }

  return diffProperties(domElement, type, oldProps, newProps);
}
function shouldSetTextContent(type, props) {
  return type === 'textarea' || type === 'option' || type === 'noscript' || typeof props.children === 'string' || typeof props.children === 'number' || typeof props.dangerouslySetInnerHTML === 'object' && props.dangerouslySetInnerHTML !== null && props.dangerouslySetInnerHTML.__html != null;
}
function createTextInstance(text, rootContainerInstance, hostContext, internalInstanceHandle) {
  {
    var hostContextDev = hostContext;
    validateDOMNesting(null, text, hostContextDev.ancestorInfo);
  }

  var textNode = createTextNode(text, rootContainerInstance);
  precacheFiberNode(internalInstanceHandle, textNode);
  return textNode;
}
// if a component just imports ReactDOM (e.g. for findDOMNode).
// Some environments might not have setTimeout or clearTimeout.

var scheduleTimeout = typeof setTimeout === 'function' ? setTimeout : undefined;
var cancelTimeout = typeof clearTimeout === 'function' ? clearTimeout : undefined;
var noTimeout = -1; // -------------------
function commitMount(domElement, type, newProps, internalInstanceHandle) {
  // Despite the naming that might imply otherwise, this method only
  // fires if there is an `Update` effect scheduled during mounting.
  // This happens if `finalizeInitialChildren` returns `true` (which it
  // does to implement the `autoFocus` attribute on the client). But
  // there are also other cases when this might happen (such as patching
  // up text content during hydration mismatch). So we'll check this again.
  if (shouldAutoFocusHostComponent(type, newProps)) {
    domElement.focus();
  }
}
function commitUpdate(domElement, updatePayload, type, oldProps, newProps, internalInstanceHandle) {
  // Update the props handle so that we know which props are the ones with
  // with current event handlers.
  updateFiberProps(domElement, newProps); // Apply the diff to the DOM node.

  updateProperties(domElement, updatePayload, type, oldProps, newProps);
}
function resetTextContent(domElement) {
  setTextContent(domElement, '');
}
function commitTextUpdate(textInstance, oldText, newText) {
  textInstance.nodeValue = newText;
}
function appendChild(parentInstance, child) {
  parentInstance.appendChild(child);
}
function appendChildToContainer(container, child) {
  var parentNode;

  if (container.nodeType === COMMENT_NODE) {
    parentNode = container.parentNode;
    parentNode.insertBefore(child, container);
  } else {
    parentNode = container;
    parentNode.appendChild(child);
  } // This container might be used for a portal.
  // If something inside a portal is clicked, that click should bubble
  // through the React tree. However, on Mobile Safari the click would
  // never bubble through the *DOM* tree unless an ancestor with onclick
  // event exists. So we wouldn't see it and dispatch it.
  // This is why we ensure that non React root containers have inline onclick
  // defined.
  // https://github.com/facebook/react/issues/11918


  var reactRootContainer = container._reactRootContainer;

  if ((reactRootContainer === null || reactRootContainer === undefined) && parentNode.onclick === null) {
    // TODO: This cast may not be sound for SVG, MathML or custom elements.
    trapClickOnNonInteractiveElement(parentNode);
  }
}
function insertBefore(parentInstance, child, beforeChild) {
  parentInstance.insertBefore(child, beforeChild);
}
function insertInContainerBefore(container, child, beforeChild) {
  if (container.nodeType === COMMENT_NODE) {
    container.parentNode.insertBefore(child, beforeChild);
  } else {
    container.insertBefore(child, beforeChild);
  }
}

function removeChild(parentInstance, child) {
  parentInstance.removeChild(child);
}
function removeChildFromContainer(container, child) {
  if (container.nodeType === COMMENT_NODE) {
    container.parentNode.removeChild(child);
  } else {
    container.removeChild(child);
  }
}
function hideInstance(instance) {
  // TODO: Does this work for all element types? What about MathML? Should we
  // pass host context to this method?
  instance = instance;
  var style = instance.style;

  if (typeof style.setProperty === 'function') {
    style.setProperty('display', 'none', 'important');
  } else {
    style.display = 'none';
  }
}
function hideTextInstance(textInstance) {
  textInstance.nodeValue = '';
}
function unhideInstance(instance, props) {
  instance = instance;
  var styleProp = props[STYLE$1];
  var display = styleProp !== undefined && styleProp !== null && styleProp.hasOwnProperty('display') ? styleProp.display : null;
  instance.style.display = dangerousStyleValue('display', display);
}
function unhideTextInstance(textInstance, text) {
  textInstance.nodeValue = text;
}
function clearContainer(container) {
  if (container.nodeType === ELEMENT_NODE) {
    container.textContent = '';
  } else if (container.nodeType === DOCUMENT_NODE) {
    var body = container.body;

    if (body != null) {
      body.textContent = '';
    }
  }
} // -------------------
function canHydrateInstance(instance, type, props) {
  if (instance.nodeType !== ELEMENT_NODE || type.toLowerCase() !== instance.nodeName.toLowerCase()) {
    return null;
  } // This has now been refined to an element node.


  return instance;
}
function canHydrateTextInstance(instance, text) {
  if (text === '' || instance.nodeType !== TEXT_NODE) {
    // Empty strings are not parsed by HTML so there won't be a correct match here.
    return null;
  } // This has now been refined to a text node.


  return instance;
}
function isSuspenseInstancePending(instance) {
  return instance.data === SUSPENSE_PENDING_START_DATA;
}
function isSuspenseInstanceFallback(instance) {
  return instance.data === SUSPENSE_FALLBACK_START_DATA;
}

function getNextHydratable(node) {
  // Skip non-hydratable nodes.
  for (; node != null; node = node.nextSibling) {
    var nodeType = node.nodeType;

    if (nodeType === ELEMENT_NODE || nodeType === TEXT_NODE) {
      break;
    }
  }

  return node;
}

function getNextHydratableSibling(instance) {
  return getNextHydratable(instance.nextSibling);
}
function getFirstHydratableChild(parentInstance) {
  return getNextHydratable(parentInstance.firstChild);
}
function hydrateInstance(instance, type, props, rootContainerInstance, hostContext, internalInstanceHandle) {
  precacheFiberNode(internalInstanceHandle, instance); // TODO: Possibly defer this until the commit phase where all the events
  // get attached.

  updateFiberProps(instance, props);
  var parentNamespace;

  {
    var hostContextDev = hostContext;
    parentNamespace = hostContextDev.namespace;
  }

  return diffHydratedProperties(instance, type, props, parentNamespace);
}
function hydrateTextInstance(textInstance, text, internalInstanceHandle) {
  precacheFiberNode(internalInstanceHandle, textInstance);
  return diffHydratedText(textInstance, text);
}
function getNextHydratableInstanceAfterSuspenseInstance(suspenseInstance) {
  var node = suspenseInstance.nextSibling; // Skip past all nodes within this suspense boundary.
  // There might be nested nodes so we need to keep track of how
  // deep we are and only break out when we're back on top.

  var depth = 0;

  while (node) {
    if (node.nodeType === COMMENT_NODE) {
      var data = node.data;

      if (data === SUSPENSE_END_DATA) {
        if (depth === 0) {
          return getNextHydratableSibling(node);
        } else {
          depth--;
        }
      } else if (data === SUSPENSE_START_DATA || data === SUSPENSE_FALLBACK_START_DATA || data === SUSPENSE_PENDING_START_DATA) {
        depth++;
      }
    }

    node = node.nextSibling;
  } // TODO: Warn, we didn't find the end comment boundary.


  return null;
} // Returns the SuspenseInstance if this node is a direct child of a
// SuspenseInstance. I.e. if its previous sibling is a Comment with
// SUSPENSE_x_START_DATA. Otherwise, null.

function getParentSuspenseInstance(targetInstance) {
  var node = targetInstance.previousSibling; // Skip past all nodes within this suspense boundary.
  // There might be nested nodes so we need to keep track of how
  // deep we are and only break out when we're back on top.

  var depth = 0;

  while (node) {
    if (node.nodeType === COMMENT_NODE) {
      var data = node.data;

      if (data === SUSPENSE_START_DATA || data === SUSPENSE_FALLBACK_START_DATA || data === SUSPENSE_PENDING_START_DATA) {
        if (depth === 0) {
          return node;
        } else {
          depth--;
        }
      } else if (data === SUSPENSE_END_DATA) {
        depth++;
      }
    }

    node = node.previousSibling;
  }

  return null;
}
function commitHydratedContainer(container) {
  // Retry if any event replaying was blocked on this.
  retryIfBlockedOn(container);
}
function commitHydratedSuspenseInstance(suspenseInstance) {
  // Retry if any event replaying was blocked on this.
  retryIfBlockedOn(suspenseInstance);
}
function didNotMatchHydratedContainerTextInstance(parentContainer, textInstance, text) {
  {
    warnForUnmatchedText(textInstance, text);
  }
}
function didNotMatchHydratedTextInstance(parentType, parentProps, parentInstance, textInstance, text) {
  if ( parentProps[SUPPRESS_HYDRATION_WARNING$1] !== true) {
    warnForUnmatchedText(textInstance, text);
  }
}
function didNotHydrateContainerInstance(parentContainer, instance) {
  {
    if (instance.nodeType === ELEMENT_NODE) {
      warnForDeletedHydratableElement(parentContainer, instance);
    } else if (instance.nodeType === COMMENT_NODE) ; else {
      warnForDeletedHydratableText(parentContainer, instance);
    }
  }
}
function didNotHydrateInstance(parentType, parentProps, parentInstance, instance) {
  if ( parentProps[SUPPRESS_HYDRATION_WARNING$1] !== true) {
    if (instance.nodeType === ELEMENT_NODE) {
      warnForDeletedHydratableElement(parentInstance, instance);
    } else if (instance.nodeType === COMMENT_NODE) ; else {
      warnForDeletedHydratableText(parentInstance, instance);
    }
  }
}
function didNotFindHydratableContainerInstance(parentContainer, type, props) {
  {
    warnForInsertedHydratedElement(parentContainer, type);
  }
}
function didNotFindHydratableContainerTextInstance(parentContainer, text) {
  {
    warnForInsertedHydratedText(parentContainer, text);
  }
}
function didNotFindHydratableInstance(parentType, parentProps, parentInstance, type, props) {
  if ( parentProps[SUPPRESS_HYDRATION_WARNING$1] !== true) {
    warnForInsertedHydratedElement(parentInstance, type);
  }
}
function didNotFindHydratableTextInstance(parentType, parentProps, parentInstance, text) {
  if ( parentProps[SUPPRESS_HYDRATION_WARNING$1] !== true) {
    warnForInsertedHydratedText(parentInstance, text);
  }
}
function didNotFindHydratableSuspenseInstance(parentType, parentProps, parentInstance) {
  if ( parentProps[SUPPRESS_HYDRATION_WARNING$1] !== true) ;
}
var clientId = 0;
function makeClientIdInDEV(warnOnAccessInDEV) {
  var id = 'r:' + (clientId++).toString(36);
  return {
    toString: function () {
      warnOnAccessInDEV();
      return id;
    },
    valueOf: function () {
      warnOnAccessInDEV();
      return id;
    }
  };
}
function isOpaqueHydratingObject(value) {
  return value !== null && typeof value === 'object' && value.$$typeof === REACT_OPAQUE_ID_TYPE;
}
function makeOpaqueHydratingObject(attemptToReadValue) {
  return {
    $$typeof: REACT_OPAQUE_ID_TYPE,
    toString: attemptToReadValue,
    valueOf: attemptToReadValue
  };
}
function preparePortalMount(portalInstance) {
  {
    listenToAllSupportedEvents(portalInstance);
  }
}

var randomKey = Math.random().toString(36).slice(2);
var internalInstanceKey = '__reactFiber$' + randomKey;
var internalPropsKey = '__reactProps$' + randomKey;
var internalContainerInstanceKey = '__reactContainer$' + randomKey;
var internalEventHandlersKey = '__reactEvents$' + randomKey;
function precacheFiberNode(hostInst, node) {
  node[internalInstanceKey] = hostInst;
}
function markContainerAsRoot(hostRoot, node) {
  node[internalContainerInstanceKey] = hostRoot;
}
function unmarkContainerAsRoot(node) {
  node[internalContainerInstanceKey] = null;
}
function isContainerMarkedAsRoot(node) {
  return !!node[internalContainerInstanceKey];
} // Given a DOM node, return the closest HostComponent or HostText fiber ancestor.
// If the target node is part of a hydrated or not yet rendered subtree, then
// this may also return a SuspenseComponent or HostRoot to indicate that.
// Conceptually the HostRoot fiber is a child of the Container node. So if you
// pass the Container node as the targetNode, you will not actually get the
// HostRoot back. To get to the HostRoot, you need to pass a child of it.
// The same thing applies to Suspense boundaries.

function getClosestInstanceFromNode(targetNode) {
  var targetInst = targetNode[internalInstanceKey];

  if (targetInst) {
    // Don't return HostRoot or SuspenseComponent here.
    return targetInst;
  } // If the direct event target isn't a React owned DOM node, we need to look
  // to see if one of its parents is a React owned DOM node.


  var parentNode = targetNode.parentNode;

  while (parentNode) {
    // We'll check if this is a container root that could include
    // React nodes in the future. We need to check this first because
    // if we're a child of a dehydrated container, we need to first
    // find that inner container before moving on to finding the parent
    // instance. Note that we don't check this field on  the targetNode
    // itself because the fibers are conceptually between the container
    // node and the first child. It isn't surrounding the container node.
    // If it's not a container, we check if it's an instance.
    targetInst = parentNode[internalContainerInstanceKey] || parentNode[internalInstanceKey];

    if (targetInst) {
      // Since this wasn't the direct target of the event, we might have
      // stepped past dehydrated DOM nodes to get here. However they could
      // also have been non-React nodes. We need to answer which one.
      // If we the instance doesn't have any children, then there can't be
      // a nested suspense boundary within it. So we can use this as a fast
      // bailout. Most of the time, when people add non-React children to
      // the tree, it is using a ref to a child-less DOM node.
      // Normally we'd only need to check one of the fibers because if it
      // has ever gone from having children to deleting them or vice versa
      // it would have deleted the dehydrated boundary nested inside already.
      // However, since the HostRoot starts out with an alternate it might
      // have one on the alternate so we need to check in case this was a
      // root.
      var alternate = targetInst.alternate;

      if (targetInst.child !== null || alternate !== null && alternate.child !== null) {
        // Next we need to figure out if the node that skipped past is
        // nested within a dehydrated boundary and if so, which one.
        var suspenseInstance = getParentSuspenseInstance(targetNode);

        while (suspenseInstance !== null) {
          // We found a suspense instance. That means that we haven't
          // hydrated it yet. Even though we leave the comments in the
          // DOM after hydrating, and there are boundaries in the DOM
          // that could already be hydrated, we wouldn't have found them
          // through this pass since if the target is hydrated it would
          // have had an internalInstanceKey on it.
          // Let's get the fiber associated with the SuspenseComponent
          // as the deepest instance.
          var targetSuspenseInst = suspenseInstance[internalInstanceKey];

          if (targetSuspenseInst) {
            return targetSuspenseInst;
          } // If we don't find a Fiber on the comment, it might be because
          // we haven't gotten to hydrate it yet. There might still be a
          // parent boundary that hasn't above this one so we need to find
          // the outer most that is known.


          suspenseInstance = getParentSuspenseInstance(suspenseInstance); // If we don't find one, then that should mean that the parent
          // host component also hasn't hydrated yet. We can return it
          // below since it will bail out on the isMounted check later.
        }
      }

      return targetInst;
    }

    targetNode = parentNode;
    parentNode = targetNode.parentNode;
  }

  return null;
}
/**
 * Given a DOM node, return the ReactDOMComponent or ReactDOMTextComponent
 * instance, or null if the node was not rendered by this React.
 */

function getInstanceFromNode(node) {
  var inst = node[internalInstanceKey] || node[internalContainerInstanceKey];

  if (inst) {
    if (inst.tag === HostComponent || inst.tag === HostText || inst.tag === SuspenseComponent || inst.tag === HostRoot) {
      return inst;
    } else {
      return null;
    }
  }

  return null;
}
/**
 * Given a ReactDOMComponent or ReactDOMTextComponent, return the corresponding
 * DOM node.
 */

function getNodeFromInstance(inst) {
  if (inst.tag === HostComponent || inst.tag === HostText) {
    // In Fiber this, is just the state node right now. We assume it will be
    // a host component or host text.
    return inst.stateNode;
  } // Without this first invariant, passing a non-DOM-component triggers the next
  // invariant for a missing parent, which is super confusing.


  {
    {
      throw Error( "getNodeFromInstance: Invalid argument." );
    }
  }
}
function getFiberCurrentPropsFromNode(node) {
  return node[internalPropsKey] || null;
}
function updateFiberProps(node, props) {
  node[internalPropsKey] = props;
}
function getEventListenerSet(node) {
  var elementListenerSet = node[internalEventHandlersKey];

  if (elementListenerSet === undefined) {
    elementListenerSet = node[internalEventHandlersKey] = new Set();
  }

  return elementListenerSet;
}

var loggedTypeFailures = {};
var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;

function setCurrentlyValidatingElement(element) {
  {
    if (element) {
      var owner = element._owner;
      var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
      ReactDebugCurrentFrame$1.setExtraStackFrame(stack);
    } else {
      ReactDebugCurrentFrame$1.setExtraStackFrame(null);
    }
  }
}

function checkPropTypes(typeSpecs, values, location, componentName, element) {
  {
    // $FlowFixMe This is okay but Flow doesn't know it.
    var has = Function.call.bind(Object.prototype.hasOwnProperty);

    for (var typeSpecName in typeSpecs) {
      if (has(typeSpecs, typeSpecName)) {
        var error$1 = void 0; // Prop type validation may throw. In case they do, we don't want to
        // fail the render phase where it didn't fail before. So we log it.
        // After these have been cleaned up, we'll let them throw.

        try {
          // This is intentionally an invariant that gets caught. It's the same
          // behavior as without this statement except with a better message.
          if (typeof typeSpecs[typeSpecName] !== 'function') {
            var err = Error((componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' + 'it must be a function, usually from the `prop-types` package, but received `' + typeof typeSpecs[typeSpecName] + '`.' + 'This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.');
            err.name = 'Invariant Violation';
            throw err;
          }

          error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED');
        } catch (ex) {
          error$1 = ex;
        }

        if (error$1 && !(error$1 instanceof Error)) {
          setCurrentlyValidatingElement(element);

          error('%s: type specification of %s' + ' `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', location, typeSpecName, typeof error$1);

          setCurrentlyValidatingElement(null);
        }

        if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {
          // Only monitor this failure once because there tends to be a lot of the
          // same error.
          loggedTypeFailures[error$1.message] = true;
          setCurrentlyValidatingElement(element);

          error('Failed %s type: %s', location, error$1.message);

          setCurrentlyValidatingElement(null);
        }
      }
    }
  }
}

var valueStack = [];
var fiberStack;

{
  fiberStack = [];
}

var index = -1;

function createCursor(defaultValue) {
  return {
    current: defaultValue
  };
}

function pop(cursor, fiber) {
  if (index < 0) {
    {
      error('Unexpected pop.');
    }

    return;
  }

  {
    if (fiber !== fiberStack[index]) {
      error('Unexpected Fiber popped.');
    }
  }

  cursor.current = valueStack[index];
  valueStack[index] = null;

  {
    fiberStack[index] = null;
  }

  index--;
}

function push(cursor, value, fiber) {
  index++;
  valueStack[index] = cursor.current;

  {
    fiberStack[index] = fiber;
  }

  cursor.current = value;
}

var warnedAboutMissingGetChildContext;

{
  warnedAboutMissingGetChildContext = {};
}

var emptyContextObject = {};

{
  Object.freeze(emptyContextObject);
} // A cursor to the current merged context object on the stack.


var contextStackCursor = createCursor(emptyContextObject); // A cursor to a boolean indicating whether the context has changed.

var didPerformWorkStackCursor = createCursor(false); // Keep track of the previous context object that was on the stack.
// We use this to get access to the parent context after we have already
// pushed the next context provider, and now need to merge their contexts.

var previousContext = emptyContextObject;

function getUnmaskedContext(workInProgress, Component, didPushOwnContextIfProvider) {
  {
    if (didPushOwnContextIfProvider && isContextProvider(Component)) {
      // If the fiber is a context provider itself, when we read its context
      // we may have already pushed its own child context on the stack. A context
      // provider should not "see" its own child context. Therefore we read the
      // previous (parent) context instead for a context provider.
      return previousContext;
    }

    return contextStackCursor.current;
  }
}

function cacheContext(workInProgress, unmaskedContext, maskedContext) {
  {
    var instance = workInProgress.stateNode;
    instance.__reactInternalMemoizedUnmaskedChildContext = unmaskedContext;
    instance.__reactInternalMemoizedMaskedChildContext = maskedContext;
  }
}

function getMaskedContext(workInProgress, unmaskedContext) {
  {
    var type = workInProgress.type;
    var contextTypes = type.contextTypes;

    if (!contextTypes) {
      return emptyContextObject;
    } // Avoid recreating masked context unless unmasked context has changed.
    // Failing to do this will result in unnecessary calls to componentWillReceiveProps.
    // This may trigger infinite loops if componentWillReceiveProps calls setState.


    var instance = workInProgress.stateNode;

    if (instance && instance.__reactInternalMemoizedUnmaskedChildContext === unmaskedContext) {
      return instance.__reactInternalMemoizedMaskedChildContext;
    }

    var context = {};

    for (var key in contextTypes) {
      context[key] = unmaskedContext[key];
    }

    {
      var name = getComponentName(type) || 'Unknown';
      checkPropTypes(contextTypes, context, 'context', name);
    } // Cache unmasked context so we can avoid recreating masked context unless necessary.
    // Context is created before the class component is instantiated so check for instance.


    if (instance) {
      cacheContext(workInProgress, unmaskedContext, context);
    }

    return context;
  }
}

function hasContextChanged() {
  {
    return didPerformWorkStackCursor.current;
  }
}

function isContextProvider(type) {
  {
    var childContextTypes = type.childContextTypes;
    return childContextTypes !== null && childContextTypes !== undefined;
  }
}

function popContext(fiber) {
  {
    pop(didPerformWorkStackCursor, fiber);
    pop(contextStackCursor, fiber);
  }
}

function popTopLevelContextObject(fiber) {
  {
    pop(didPerformWorkStackCursor, fiber);
    pop(contextStackCursor, fiber);
  }
}

function pushTopLevelContextObject(fiber, context, didChange) {
  {
    if (!(contextStackCursor.current === emptyContextObject)) {
      {
        throw Error( "Unexpected context found on stack. This error is likely caused by a bug in React. Please file an issue." );
      }
    }

    push(contextStackCursor, context, fiber);
    push(didPerformWorkStackCursor, didChange, fiber);
  }
}

function processChildContext(fiber, type, parentContext) {
  {
    var instance = fiber.stateNode;
    var childContextTypes = type.childContextTypes; // TODO (bvaughn) Replace this behavior with an invariant() in the future.
    // It has only been added in Fiber to match the (unintentional) behavior in Stack.

    if (typeof instance.getChildContext !== 'function') {
      {
        var componentName = getComponentName(type) || 'Unknown';

        if (!warnedAboutMissingGetChildContext[componentName]) {
          warnedAboutMissingGetChildContext[componentName] = true;

          error('%s.childContextTypes is specified but there is no getChildContext() method ' + 'on the instance. You can either define getChildContext() on %s or remove ' + 'childContextTypes from it.', componentName, componentName);
        }
      }

      return parentContext;
    }

    var childContext = instance.getChildContext();

    for (var contextKey in childContext) {
      if (!(contextKey in childContextTypes)) {
        {
          throw Error( (getComponentName(type) || 'Unknown') + ".getChildContext(): key \"" + contextKey + "\" is not defined in childContextTypes." );
        }
      }
    }

    {
      var name = getComponentName(type) || 'Unknown';
      checkPropTypes(childContextTypes, childContext, 'child context', name);
    }

    return _assign({}, parentContext, childContext);
  }
}

function pushContextProvider(workInProgress) {
  {
    var instance = workInProgress.stateNode; // We push the context as early as possible to ensure stack integrity.
    // If the instance does not exist yet, we will push null at first,
    // and replace it on the stack later when invalidating the context.

    var memoizedMergedChildContext = instance && instance.__reactInternalMemoizedMergedChildContext || emptyContextObject; // Remember the parent context so we can merge with it later.
    // Inherit the parent's did-perform-work value to avoid inadvertently blocking updates.

    previousContext = contextStackCursor.current;
    push(contextStackCursor, memoizedMergedChildContext, workInProgress);
    push(didPerformWorkStackCursor, didPerformWorkStackCursor.current, workInProgress);
    return true;
  }
}

function invalidateContextProvider(workInProgress, type, didChange) {
  {
    var instance = workInProgress.stateNode;

    if (!instance) {
      {
        throw Error( "Expected to have an instance by this point. This error is likely caused by a bug in React. Please file an issue." );
      }
    }

    if (didChange) {
      // Merge parent and own context.
      // Skip this if we're not updating due to sCU.
      // This avoids unnecessarily recomputing memoized values.
      var mergedContext = processChildContext(workInProgress, type, previousContext);
      instance.__reactInternalMemoizedMergedChildContext = mergedContext; // Replace the old (or empty) context with the new one.
      // It is important to unwind the context in the reverse order.

      pop(didPerformWorkStackCursor, workInProgress);
      pop(contextStackCursor, workInProgress); // Now push the new context and mark that it has changed.

      push(contextStackCursor, mergedContext, workInProgress);
      push(didPerformWorkStackCursor, didChange, workInProgress);
    } else {
      pop(didPerformWorkStackCursor, workInProgress);
      push(didPerformWorkStackCursor, didChange, workInProgress);
    }
  }
}

function findCurrentUnmaskedContext(fiber) {
  {
    // Currently this is only used with renderSubtreeIntoContainer; not sure if it
    // makes sense elsewhere
    if (!(isFiberMounted(fiber) && fiber.tag === ClassComponent)) {
      {
        throw Error( "Expected subtree parent to be a mounted class component. This error is likely caused by a bug in React. Please file an issue." );
      }
    }

    var node = fiber;

    do {
      switch (node.tag) {
        case HostRoot:
          return node.stateNode.context;

        case ClassComponent:
          {
            var Component = node.type;

            if (isContextProvider(Component)) {
              return node.stateNode.__reactInternalMemoizedMergedChildContext;
            }

            break;
          }
      }

      node = node.return;
    } while (node !== null);

    {
      {
        throw Error( "Found unexpected detached subtree parent. This error is likely caused by a bug in React. Please file an issue." );
      }
    }
  }
}

var LegacyRoot = 0;
var BlockingRoot = 1;
var ConcurrentRoot = 2;

var rendererID = null;
var injectedHook = null;
var hasLoggedError = false;
var isDevToolsPresent = typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined';
function injectInternals(internals) {
  if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === 'undefined') {
    // No DevTools
    return false;
  }

  var hook = __REACT_DEVTOOLS_GLOBAL_HOOK__;

  if (hook.isDisabled) {
    // This isn't a real property on the hook, but it can be set to opt out
    // of DevTools integration and associated warnings and logs.
    // https://github.com/facebook/react/issues/3877
    return true;
  }

  if (!hook.supportsFiber) {
    {
      error('The installed version of React DevTools is too old and will not work ' + 'with the current version of React. Please update React DevTools. ' + 'https://reactjs.org/link/react-devtools');
    } // DevTools exists, even though it doesn't support Fiber.


    return true;
  }

  try {
    rendererID = hook.inject(internals); // We have successfully injected, so now it is safe to set up hooks.

    injectedHook = hook;
  } catch (err) {
    // Catch all errors because it is unsafe to throw during initialization.
    {
      error('React instrumentation encountered an error: %s.', err);
    }
  } // DevTools exists


  return true;
}
function onScheduleRoot(root, children) {
  {
    if (injectedHook && typeof injectedHook.onScheduleFiberRoot === 'function') {
      try {
        injectedHook.onScheduleFiberRoot(rendererID, root, children);
      } catch (err) {
        if ( !hasLoggedError) {
          hasLoggedError = true;

          error('React instrumentation encountered an error: %s', err);
        }
      }
    }
  }
}
function onCommitRoot(root, priorityLevel) {
  if (injectedHook && typeof injectedHook.onCommitFiberRoot === 'function') {
    try {
      var didError = (root.current.flags & DidCapture) === DidCapture;

      if (enableProfilerTimer) {
        injectedHook.onCommitFiberRoot(rendererID, root, priorityLevel, didError);
      } else {
        injectedHook.onCommitFiberRoot(rendererID, root, undefined, didError);
      }
    } catch (err) {
      {
        if (!hasLoggedError) {
          hasLoggedError = true;

          error('React instrumentation encountered an error: %s', err);
        }
      }
    }
  }
}
function onCommitUnmount(fiber) {
  if (injectedHook && typeof injectedHook.onCommitFiberUnmount === 'function') {
    try {
      injectedHook.onCommitFiberUnmount(rendererID, fiber);
    } catch (err) {
      {
        if (!hasLoggedError) {
          hasLoggedError = true;

          error('React instrumentation encountered an error: %s', err);
        }
      }
    }
  }
}

var Scheduler_runWithPriority = Scheduler.unstable_runWithPriority,
    Scheduler_scheduleCallback = Scheduler.unstable_scheduleCallback,
    Scheduler_cancelCallback = Scheduler.unstable_cancelCallback,
    Scheduler_shouldYield = Scheduler.unstable_shouldYield,
    Scheduler_requestPaint = Scheduler.unstable_requestPaint,
    Scheduler_now$1 = Scheduler.unstable_now,
    Scheduler_getCurrentPriorityLevel = Scheduler.unstable_getCurrentPriorityLevel,
    Scheduler_ImmediatePriority = Scheduler.unstable_ImmediatePriority,
    Scheduler_UserBlockingPriority = Scheduler.unstable_UserBlockingPriority,
    Scheduler_NormalPriority = Scheduler.unstable_NormalPriority,
    Scheduler_LowPriority = Scheduler.unstable_LowPriority,
    Scheduler_IdlePriority = Scheduler.unstable_IdlePriority;

{
  // Provide explicit error message when production+profiling bundle of e.g.
  // react-dom is used with production (non-profiling) bundle of
  // scheduler/tracing
  if (!(tracing.__interactionsRef != null && tracing.__interactionsRef.current != null)) {
    {
      throw Error( "It is not supported to run the profiling version of a renderer (for example, `react-dom/profiling`) without also replacing the `scheduler/tracing` module with `scheduler/tracing-profiling`. Your bundler might have a setting for aliasing both modules. Learn more at https://reactjs.org/link/profiling" );
    }
  }
}

var fakeCallbackNode = {}; // Except for NoPriority, these correspond to Scheduler priorities. We use
// ascending numbers so we can compare them like numbers. They start at 90 to
// avoid clashing with Scheduler's priorities.

var ImmediatePriority$1 = 99;
var UserBlockingPriority$2 = 98;
var NormalPriority$1 = 97;
var LowPriority$1 = 96;
var IdlePriority$1 = 95; // NoPriority is the absence of priority. Also React-only.

var NoPriority$1 = 90;
var shouldYield = Scheduler_shouldYield;
var requestPaint = // Fall back gracefully if we're running an older version of Scheduler.
Scheduler_requestPaint !== undefined ? Scheduler_requestPaint : function () {};
var syncQueue = null;
var immediateQueueCallbackNode = null;
var isFlushingSyncQueue = false;
var initialTimeMs$1 = Scheduler_now$1(); // If the initial timestamp is reasonably small, use Scheduler's `now` directly.
// This will be the case for modern browsers that support `performance.now`. In
// older browsers, Scheduler falls back to `Date.now`, which returns a Unix
// timestamp. In that case, subtract the module initialization time to simulate
// the behavior of performance.now and keep our times small enough to fit
// within 32 bits.
// TODO: Consider lifting this into Scheduler.

var now = initialTimeMs$1 < 10000 ? Scheduler_now$1 : function () {
  return Scheduler_now$1() - initialTimeMs$1;
};
function getCurrentPriorityLevel() {
  switch (Scheduler_getCurrentPriorityLevel()) {
    case Scheduler_ImmediatePriority:
      return ImmediatePriority$1;

    case Scheduler_UserBlockingPriority:
      return UserBlockingPriority$2;

    case Scheduler_NormalPriority:
      return NormalPriority$1;

    case Scheduler_LowPriority:
      return LowPriority$1;

    case Scheduler_IdlePriority:
      return IdlePriority$1;

    default:
      {
        {
          throw Error( "Unknown priority level." );
        }
      }

  }
}

function reactPriorityToSchedulerPriority(reactPriorityLevel) {
  switch (reactPriorityLevel) {
    case ImmediatePriority$1:
      return Scheduler_ImmediatePriority;

    case UserBlockingPriority$2:
      return Scheduler_UserBlockingPriority;

    case NormalPriority$1:
      return Scheduler_NormalPriority;

    case LowPriority$1:
      return Scheduler_LowPriority;

    case IdlePriority$1:
      return Scheduler_IdlePriority;

    default:
      {
        {
          throw Error( "Unknown priority level." );
        }
      }

  }
}

function runWithPriority$1(reactPriorityLevel, fn) {
  var priorityLevel = reactPriorityToSchedulerPriority(reactPriorityLevel);
  return Scheduler_runWithPriority(priorityLevel, fn);
}
function scheduleCallback(reactPriorityLevel, callback, options) {
  var priorityLevel = reactPriorityToSchedulerPriority(reactPriorityLevel);
  return Scheduler_scheduleCallback(priorityLevel, callback, options);
}
function scheduleSyncCallback(callback) {
  // Push this callback into an internal queue. We'll flush these either in
  // the next tick, or earlier if something calls `flushSyncCallbackQueue`.
  if (syncQueue === null) {
    syncQueue = [callback]; // Flush the queue in the next tick, at the earliest.

    immediateQueueCallbackNode = Scheduler_scheduleCallback(Scheduler_ImmediatePriority, flushSyncCallbackQueueImpl);
  } else {
    // Push onto existing queue. Don't need to schedule a callback because
    // we already scheduled one when we created the queue.
    syncQueue.push(callback);
  }

  return fakeCallbackNode;
}
function cancelCallback(callbackNode) {
  if (callbackNode !== fakeCallbackNode) {
    Scheduler_cancelCallback(callbackNode);
  }
}
function flushSyncCallbackQueue() {
  if (immediateQueueCallbackNode !== null) {
    var node = immediateQueueCallbackNode;
    immediateQueueCallbackNode = null;
    Scheduler_cancelCallback(node);
  }

  flushSyncCallbackQueueImpl();
}

function flushSyncCallbackQueueImpl() {
  if (!isFlushingSyncQueue && syncQueue !== null) {
    // Prevent re-entrancy.
    isFlushingSyncQueue = true;
    var i = 0;

    {
      try {
        var _isSync2 = true;
        var _queue = syncQueue;
        runWithPriority$1(ImmediatePriority$1, function () {
          for (; i < _queue.length; i++) {
            var callback = _queue[i];

            do {
              callback = callback(_isSync2);
            } while (callback !== null);
          }
        });
        syncQueue = null;
      } catch (error) {
        // If something throws, leave the remaining callbacks on the queue.
        if (syncQueue !== null) {
          syncQueue = syncQueue.slice(i + 1);
        } // Resume flushing in the next tick


        Scheduler_scheduleCallback(Scheduler_ImmediatePriority, flushSyncCallbackQueue);
        throw error;
      } finally {
        isFlushingSyncQueue = false;
      }
    }
  }
}

// TODO: this is special because it gets imported during build.
var ReactVersion = '17.0.2';

var NoMode = 0;
var StrictMode = 1; // TODO: Remove BlockingMode and ConcurrentMode by reading from the root
// tag instead

var BlockingMode = 2;
var ConcurrentMode = 4;
var ProfileMode = 8;
var DebugTracingMode = 16;

var ReactCurrentBatchConfig = ReactSharedInternals.ReactCurrentBatchConfig;
var NoTransition = 0;
function requestCurrentTransition() {
  return ReactCurrentBatchConfig.transition;
}

var ReactStrictModeWarnings = {
  recordUnsafeLifecycleWarnings: function (fiber, instance) {},
  flushPendingUnsafeLifecycleWarnings: function () {},
  recordLegacyContextWarning: function (fiber, instance) {},
  flushLegacyContextWarning: function () {},
  discardPendingWarnings: function () {}
};

{
  var findStrictRoot = function (fiber) {
    var maybeStrictRoot = null;
    var node = fiber;

    while (node !== null) {
      if (node.mode & StrictMode) {
        maybeStrictRoot = node;
      }

      node = node.return;
    }

    return maybeStrictRoot;
  };

  var setToSortedString = function (set) {
    var array = [];
    set.forEach(function (value) {
      array.push(value);
    });
    return array.sort().join(', ');
  };

  var pendingComponentWillMountWarnings = [];
  var pendingUNSAFE_ComponentWillMountWarnings = [];
  var pendingComponentWillReceivePropsWarnings = [];
  var pendingUNSAFE_ComponentWillReceivePropsWarnings = [];
  var pendingComponentWillUpdateWarnings = [];
  var pendingUNSAFE_ComponentWillUpdateWarnings = []; // Tracks components we have already warned about.

  var didWarnAboutUnsafeLifecycles = new Set();

  ReactStrictModeWarnings.recordUnsafeLifecycleWarnings = function (fiber, instance) {
    // Dedup strategy: Warn once per component.
    if (didWarnAboutUnsafeLifecycles.has(fiber.type)) {
      return;
    }

    if (typeof instance.componentWillMount === 'function' && // Don't warn about react-lifecycles-compat polyfilled components.
    instance.componentWillMount.__suppressDeprecationWarning !== true) {
      pendingComponentWillMountWarnings.push(fiber);
    }

    if (fiber.mode & StrictMode && typeof instance.UNSAFE_componentWillMount === 'function') {
      pendingUNSAFE_ComponentWillMountWarnings.push(fiber);
    }

    if (typeof instance.componentWillReceiveProps === 'function' && instance.componentWillReceiveProps.__suppressDeprecationWarning !== true) {
      pendingComponentWillReceivePropsWarnings.push(fiber);
    }

    if (fiber.mode & StrictMode && typeof instance.UNSAFE_componentWillReceiveProps === 'function') {
      pendingUNSAFE_ComponentWillReceivePropsWarnings.push(fiber);
    }

    if (typeof instance.componentWillUpdate === 'function' && instance.componentWillUpdate.__suppressDeprecationWarning !== true) {
      pendingComponentWillUpdateWarnings.push(fiber);
    }

    if (fiber.mode & StrictMode && typeof instance.UNSAFE_componentWillUpdate === 'function') {
      pendingUNSAFE_ComponentWillUpdateWarnings.push(fiber);
    }
  };

  ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings = function () {
    // We do an initial pass to gather component names
    var componentWillMountUniqueNames = new Set();

    if (pendingComponentWillMountWarnings.length > 0) {
      pendingComponentWillMountWarnings.forEach(function (fiber) {
        componentWillMountUniqueNames.add(getComponentName(fiber.type) || 'Component');
        didWarnAboutUnsafeLifecycles.add(fiber.type);
      });
      pendingComponentWillMountWarnings = [];
    }

    var UNSAFE_componentWillMountUniqueNames = new Set();

    if (pendingUNSAFE_ComponentWillMountWarnings.length > 0) {
      pendingUNSAFE_ComponentWillMountWarnings.forEach(function (fiber) {
        UNSAFE_componentWillMountUniqueNames.add(getComponentName(fiber.type) || 'Component');
        didWarnAboutUnsafeLifecycles.add(fiber.type);
      });
      pendingUNSAFE_ComponentWillMountWarnings = [];
    }

    var componentWillReceivePropsUniqueNames = new Set();

    if (pendingComponentWillReceivePropsWarnings.length > 0) {
      pendingComponentWillReceivePropsWarnings.forEach(function (fiber) {
        componentWillReceivePropsUniqueNames.add(getComponentName(fiber.type) || 'Component');
        didWarnAboutUnsafeLifecycles.add(fiber.type);
      });
      pendingComponentWillReceivePropsWarnings = [];
    }

    var UNSAFE_componentWillReceivePropsUniqueNames = new Set();

    if (pendingUNSAFE_ComponentWillReceivePropsWarnings.length > 0) {
      pendingUNSAFE_ComponentWillReceivePropsWarnings.forEach(function (fiber) {
        UNSAFE_componentWillReceivePropsUniqueNames.add(getComponentName(fiber.type) || 'Component');
        didWarnAboutUnsafeLifecycles.add(fiber.type);
      });
      pendingUNSAFE_ComponentWillReceivePropsWarnings = [];
    }

    var componentWillUpdateUniqueNames = new Set();

    if (pendingComponentWillUpdateWarnings.length > 0) {
      pendingComponentWillUpdateWarnings.forEach(function (fiber) {
        componentWillUpdateUniqueNames.add(getComponentName(fiber.type) || 'Component');
        didWarnAboutUnsafeLifecycles.add(fiber.type);
      });
      pendingComponentWillUpdateWarnings = [];
    }

    var UNSAFE_componentWillUpdateUniqueNames = new Set();

    if (pendingUNSAFE_ComponentWillUpdateWarnings.length > 0) {
      pendingUNSAFE_ComponentWillUpdateWarnings.forEach(function (fiber) {
        UNSAFE_componentWillUpdateUniqueNames.add(getComponentName(fiber.type) || 'Component');
        didWarnAboutUnsafeLifecycles.add(fiber.type);
      });
      pendingUNSAFE_ComponentWillUpdateWarnings = [];
    } // Finally, we flush all the warnings
    // UNSAFE_ ones before the deprecated ones, since they'll be 'louder'


    if (UNSAFE_componentWillMountUniqueNames.size > 0) {
      var sortedNames = setToSortedString(UNSAFE_componentWillMountUniqueNames);

      error('Using UNSAFE_componentWillMount in strict mode is not recommended and may indicate bugs in your code. ' + 'See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n' + '* Move code with side effects to componentDidMount, and set initial state in the constructor.\n' + '\nPlease update the following components: %s', sortedNames);
    }

    if (UNSAFE_componentWillReceivePropsUniqueNames.size > 0) {
      var _sortedNames = setToSortedString(UNSAFE_componentWillReceivePropsUniqueNames);

      error('Using UNSAFE_componentWillReceiveProps in strict mode is not recommended ' + 'and may indicate bugs in your code. ' + 'See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n' + '* Move data fetching code or side effects to componentDidUpdate.\n' + "* If you're updating state whenever props change, " + 'refactor your code to use memoization techniques or move it to ' + 'static getDerivedStateFromProps. Learn more at: https://reactjs.org/link/derived-state\n' + '\nPlease update the following components: %s', _sortedNames);
    }

    if (UNSAFE_componentWillUpdateUniqueNames.size > 0) {
      var _sortedNames2 = setToSortedString(UNSAFE_componentWillUpdateUniqueNames);

      error('Using UNSAFE_componentWillUpdate in strict mode is not recommended ' + 'and may indicate bugs in your code. ' + 'See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n' + '* Move data fetching code or side effects to componentDidUpdate.\n' + '\nPlease update the following components: %s', _sortedNames2);
    }

    if (componentWillMountUniqueNames.size > 0) {
      var _sortedNames3 = setToSortedString(componentWillMountUniqueNames);

      warn('componentWillMount has been renamed, and is not recommended for use. ' + 'See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n' + '* Move code with side effects to componentDidMount, and set initial state in the constructor.\n' + '* Rename componentWillMount to UNSAFE_componentWillMount to suppress ' + 'this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. ' + 'To rename all deprecated lifecycles to their new names, you can run ' + '`npx react-codemod rename-unsafe-lifecycles` in your project source folder.\n' + '\nPlease update the following components: %s', _sortedNames3);
    }

    if (componentWillReceivePropsUniqueNames.size > 0) {
      var _sortedNames4 = setToSortedString(componentWillReceivePropsUniqueNames);

      warn('componentWillReceiveProps has been renamed, and is not recommended for use. ' + 'See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n' + '* Move data fetching code or side effects to componentDidUpdate.\n' + "* If you're updating state whenever props change, refactor your " + 'code to use memoization techniques or move it to ' + 'static getDerivedStateFromProps. Learn more at: https://reactjs.org/link/derived-state\n' + '* Rename componentWillReceiveProps to UNSAFE_componentWillReceiveProps to suppress ' + 'this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. ' + 'To rename all deprecated lifecycles to their new names, you can run ' + '`npx react-codemod rename-unsafe-lifecycles` in your project source folder.\n' + '\nPlease update the following components: %s', _sortedNames4);
    }

    if (componentWillUpdateUniqueNames.size > 0) {
      var _sortedNames5 = setToSortedString(componentWillUpdateUniqueNames);

      warn('componentWillUpdate has been renamed, and is not recommended for use. ' + 'See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n' + '* Move data fetching code or side effects to componentDidUpdate.\n' + '* Rename componentWillUpdate to UNSAFE_componentWillUpdate to suppress ' + 'this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. ' + 'To rename all deprecated lifecycles to their new names, you can run ' + '`npx react-codemod rename-unsafe-lifecycles` in your project source folder.\n' + '\nPlease update the following components: %s', _sortedNames5);
    }
  };

  var pendingLegacyContextWarning = new Map(); // Tracks components we have already warned about.

  var didWarnAboutLegacyContext = new Set();

  ReactStrictModeWarnings.recordLegacyContextWarning = function (fiber, instance) {
    var strictRoot = findStrictRoot(fiber);

    if (strictRoot === null) {
      error('Expected to find a StrictMode component in a strict mode tree. ' + 'This error is likely caused by a bug in React. Please file an issue.');

      return;
    } // Dedup strategy: Warn once per component.


    if (didWarnAboutLegacyContext.has(fiber.type)) {
      return;
    }

    var warningsForRoot = pendingLegacyContextWarning.get(strictRoot);

    if (fiber.type.contextTypes != null || fiber.type.childContextTypes != null || instance !== null && typeof instance.getChildContext === 'function') {
      if (warningsForRoot === undefined) {
        warningsForRoot = [];
        pendingLegacyContextWarning.set(strictRoot, warningsForRoot);
      }

      warningsForRoot.push(fiber);
    }
  };

  ReactStrictModeWarnings.flushLegacyContextWarning = function () {
    pendingLegacyContextWarning.forEach(function (fiberArray, strictRoot) {
      if (fiberArray.length === 0) {
        return;
      }

      var firstFiber = fiberArray[0];
      var uniqueNames = new Set();
      fiberArray.forEach(function (fiber) {
        uniqueNames.add(getComponentName(fiber.type) || 'Component');
        didWarnAboutLegacyContext.add(fiber.type);
      });
      var sortedNames = setToSortedString(uniqueNames);

      try {
        setCurrentFiber(firstFiber);

        error('Legacy context API has been detected within a strict-mode tree.' + '\n\nThe old API will be supported in all 16.x releases, but applications ' + 'using it should migrate to the new version.' + '\n\nPlease update the following components: %s' + '\n\nLearn more about this warning here: https://reactjs.org/link/legacy-context', sortedNames);
      } finally {
        resetCurrentFiber();
      }
    });
  };

  ReactStrictModeWarnings.discardPendingWarnings = function () {
    pendingComponentWillMountWarnings = [];
    pendingUNSAFE_ComponentWillMountWarnings = [];
    pendingComponentWillReceivePropsWarnings = [];
    pendingUNSAFE_ComponentWillReceivePropsWarnings = [];
    pendingComponentWillUpdateWarnings = [];
    pendingUNSAFE_ComponentWillUpdateWarnings = [];
    pendingLegacyContextWarning = new Map();
  };
}

function resolveDefaultProps(Component, baseProps) {
  if (Component && Component.defaultProps) {
    // Resolve default props. Taken from ReactElement
    var props = _assign({}, baseProps);

    var defaultProps = Component.defaultProps;

    for (var propName in defaultProps) {
      if (props[propName] === undefined) {
        props[propName] = defaultProps[propName];
      }
    }

    return props;
  }

  return baseProps;
}

// Max 31 bit integer. The max integer size in V8 for 32-bit systems.
// Math.pow(2, 30) - 1
// 0b111111111111111111111111111111
var MAX_SIGNED_31_BIT_INT = 1073741823;

var valueCursor = createCursor(null);
var rendererSigil;

{
  // Use this to detect multiple renderers using the same context
  rendererSigil = {};
}

var currentlyRenderingFiber = null;
var lastContextDependency = null;
var lastContextWithAllBitsObserved = null;
var isDisallowedContextReadInDEV = false;
function resetContextDependencies() {
  // This is called right before React yields execution, to ensure `readContext`
  // cannot be called outside the render phase.
  currentlyRenderingFiber = null;
  lastContextDependency = null;
  lastContextWithAllBitsObserved = null;

  {
    isDisallowedContextReadInDEV = false;
  }
}
function enterDisallowedContextReadInDEV() {
  {
    isDisallowedContextReadInDEV = true;
  }
}
function exitDisallowedContextReadInDEV() {
  {
    isDisallowedContextReadInDEV = false;
  }
}
function pushProvider(providerFiber, nextValue) {
  var context = providerFiber.type._context;

  {
    push(valueCursor, context._currentValue, providerFiber);
    context._currentValue = nextValue;

    {
      if (context._currentRenderer !== undefined && context._currentRenderer !== null && context._currentRenderer !== rendererSigil) {
        error('Detected multiple renderers concurrently rendering the ' + 'same context provider. This is currently unsupported.');
      }

      context._currentRenderer = rendererSigil;
    }
  }
}
function popProvider(providerFiber) {
  var currentValue = valueCursor.current;
  pop(valueCursor, providerFiber);
  var context = providerFiber.type._context;

  {
    context._currentValue = currentValue;
  }
}
function calculateChangedBits(context, newValue, oldValue) {
  if (objectIs(oldValue, newValue)) {
    // No change
    return 0;
  } else {
    var changedBits = typeof context._calculateChangedBits === 'function' ? context._calculateChangedBits(oldValue, newValue) : MAX_SIGNED_31_BIT_INT;

    {
      if ((changedBits & MAX_SIGNED_31_BIT_INT) !== changedBits) {
        error('calculateChangedBits: Expected the return value to be a ' + '31-bit integer. Instead received: %s', changedBits);
      }
    }

    return changedBits | 0;
  }
}
function scheduleWorkOnParentPath(parent, renderLanes) {
  // Update the child lanes of all the ancestors, including the alternates.
  var node = parent;

  while (node !== null) {
    var alternate = node.alternate;

    if (!isSubsetOfLanes(node.childLanes, renderLanes)) {
      node.childLanes = mergeLanes(node.childLanes, renderLanes);

      if (alternate !== null) {
        alternate.childLanes = mergeLanes(alternate.childLanes, renderLanes);
      }
    } else if (alternate !== null && !isSubsetOfLanes(alternate.childLanes, renderLanes)) {
      alternate.childLanes = mergeLanes(alternate.childLanes, renderLanes);
    } else {
      // Neither alternate was updated, which means the rest of the
      // ancestor path already has sufficient priority.
      break;
    }

    node = node.return;
  }
}
function propagateContextChange(workInProgress, context, changedBits, renderLanes) {
  var fiber = workInProgress.child;

  if (fiber !== null) {
    // Set the return pointer of the child to the work-in-progress fiber.
    fiber.return = workInProgress;
  }

  while (fiber !== null) {
    var nextFiber = void 0; // Visit this fiber.

    var list = fiber.dependencies;

    if (list !== null) {
      nextFiber = fiber.child;
      var dependency = list.firstContext;

      while (dependency !== null) {
        // Check if the context matches.
        if (dependency.context === context && (dependency.observedBits & changedBits) !== 0) {
          // Match! Schedule an update on this fiber.
          if (fiber.tag === ClassComponent) {
            // Schedule a force update on the work-in-progress.
            var update = createUpdate(NoTimestamp, pickArbitraryLane(renderLanes));
            update.tag = ForceUpdate; // TODO: Because we don't have a work-in-progress, this will add the
            // update to the current fiber, too, which means it will persist even if
            // this render is thrown away. Since it's a race condition, not sure it's
            // worth fixing.

            enqueueUpdate(fiber, update);
          }

          fiber.lanes = mergeLanes(fiber.lanes, renderLanes);
          var alternate = fiber.alternate;

          if (alternate !== null) {
            alternate.lanes = mergeLanes(alternate.lanes, renderLanes);
          }

          scheduleWorkOnParentPath(fiber.return, renderLanes); // Mark the updated lanes on the list, too.

          list.lanes = mergeLanes(list.lanes, renderLanes); // Since we already found a match, we can stop traversing the
          // dependency list.

          break;
        }

        dependency = dependency.next;
      }
    } else if (fiber.tag === ContextProvider) {
      // Don't scan deeper if this is a matching provider
      nextFiber = fiber.type === workInProgress.type ? null : fiber.child;
    } else {
      // Traverse down.
      nextFiber = fiber.child;
    }

    if (nextFiber !== null) {
      // Set the return pointer of the child to the work-in-progress fiber.
      nextFiber.return = fiber;
    } else {
      // No child. Traverse to next sibling.
      nextFiber = fiber;

      while (nextFiber !== null) {
        if (nextFiber === workInProgress) {
          // We're back to the root of this subtree. Exit.
          nextFiber = null;
          break;
        }

        var sibling = nextFiber.sibling;

        if (sibling !== null) {
          // Set the return pointer of the sibling to the work-in-progress fiber.
          sibling.return = nextFiber.return;
          nextFiber = sibling;
          break;
        } // No more siblings. Traverse up.


        nextFiber = nextFiber.return;
      }
    }

    fiber = nextFiber;
  }
}
function prepareToReadContext(workInProgress, renderLanes) {
  currentlyRenderingFiber = workInProgress;
  lastContextDependency = null;
  lastContextWithAllBitsObserved = null;
  var dependencies = workInProgress.dependencies;

  if (dependencies !== null) {
    var firstContext = dependencies.firstContext;

    if (firstContext !== null) {
      if (includesSomeLane(dependencies.lanes, renderLanes)) {
        // Context list has a pending update. Mark that this fiber performed work.
        markWorkInProgressReceivedUpdate();
      } // Reset the work-in-progress list


      dependencies.firstContext = null;
    }
  }
}
function readContext(context, observedBits) {
  {
    // This warning would fire if you read context inside a Hook like useMemo.
    // Unlike the class check below, it's not enforced in production for perf.
    if (isDisallowedContextReadInDEV) {
      error('Context can only be read while React is rendering. ' + 'In classes, you can read it in the render method or getDerivedStateFromProps. ' + 'In function components, you can read it directly in the function body, but not ' + 'inside Hooks like useReducer() or useMemo().');
    }
  }

  if (lastContextWithAllBitsObserved === context) ; else if (observedBits === false || observedBits === 0) ; else {
    var resolvedObservedBits; // Avoid deopting on observable arguments or heterogeneous types.

    if (typeof observedBits !== 'number' || observedBits === MAX_SIGNED_31_BIT_INT) {
      // Observe all updates.
      lastContextWithAllBitsObserved = context;
      resolvedObservedBits = MAX_SIGNED_31_BIT_INT;
    } else {
      resolvedObservedBits = observedBits;
    }

    var contextItem = {
      context: context,
      observedBits: resolvedObservedBits,
      next: null
    };

    if (lastContextDependency === null) {
      if (!(currentlyRenderingFiber !== null)) {
        {
          throw Error( "Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo()." );
        }
      } // This is the first dependency for this component. Create a new list.


      lastContextDependency = contextItem;
      currentlyRenderingFiber.dependencies = {
        lanes: NoLanes,
        firstContext: contextItem,
        responders: null
      };
    } else {
      // Append a new context item.
      lastContextDependency = lastContextDependency.next = contextItem;
    }
  }

  return  context._currentValue ;
}

var UpdateState = 0;
var ReplaceState = 1;
var ForceUpdate = 2;
var CaptureUpdate = 3; // Global state that is reset at the beginning of calling `processUpdateQueue`.
// It should only be read right after calling `processUpdateQueue`, via
// `checkHasForceUpdateAfterProcessing`.

var hasForceUpdate = false;
var didWarnUpdateInsideUpdate;
var currentlyProcessingQueue;

{
  didWarnUpdateInsideUpdate = false;
  currentlyProcessingQueue = null;
}

function initializeUpdateQueue(fiber) {
  var queue = {
    baseState: fiber.memoizedState,
    firstBaseUpdate: null,
    lastBaseUpdate: null,
    shared: {
      pending: null
    },
    effects: null
  };
  fiber.updateQueue = queue;
}
function cloneUpdateQueue(current, workInProgress) {
  // Clone the update queue from current. Unless it's already a clone.
  var queue = workInProgress.updateQueue;
  var currentQueue = current.updateQueue;

  if (queue === currentQueue) {
    var clone = {
      baseState: currentQueue.baseState,
      firstBaseUpdate: currentQueue.firstBaseUpdate,
      lastBaseUpdate: currentQueue.lastBaseUpdate,
      shared: currentQueue.shared,
      effects: currentQueue.effects
    };
    workInProgress.updateQueue = clone;
  }
}
function createUpdate(eventTime, lane) {
  var update = {
    eventTime: eventTime,
    lane: lane,
    tag: UpdateState,
    payload: null,
    callback: null,
    next: null
  };
  return update;
}
function enqueueUpdate(fiber, update) {
  var updateQueue = fiber.updateQueue;

  if (updateQueue === null) {
    // Only occurs if the fiber has been unmounted.
    return;
  }

  var sharedQueue = updateQueue.shared;
  var pending = sharedQueue.pending;

  if (pending === null) {
    // This is the first update. Create a circular list.
    update.next = update;
  } else {
    update.next = pending.next;
    pending.next = update;
  }

  sharedQueue.pending = update;

  {
    if (currentlyProcessingQueue === sharedQueue && !didWarnUpdateInsideUpdate) {
      error('An update (setState, replaceState, or forceUpdate) was scheduled ' + 'from inside an update function. Update functions should be pure, ' + 'with zero side-effects. Consider using componentDidUpdate or a ' + 'callback.');

      didWarnUpdateInsideUpdate = true;
    }
  }
}
function enqueueCapturedUpdate(workInProgress, capturedUpdate) {
  // Captured updates are updates that are thrown by a child during the render
  // phase. They should be discarded if the render is aborted. Therefore,
  // we should only put them on the work-in-progress queue, not the current one.
  var queue = workInProgress.updateQueue; // Check if the work-in-progress queue is a clone.

  var current = workInProgress.alternate;

  if (current !== null) {
    var currentQueue = current.updateQueue;

    if (queue === currentQueue) {
      // The work-in-progress queue is the same as current. This happens when
      // we bail out on a parent fiber that then captures an error thrown by
      // a child. Since we want to append the update only to the work-in
      // -progress queue, we need to clone the updates. We usually clone during
      // processUpdateQueue, but that didn't happen in this case because we
      // skipped over the parent when we bailed out.
      var newFirst = null;
      var newLast = null;
      var firstBaseUpdate = queue.firstBaseUpdate;

      if (firstBaseUpdate !== null) {
        // Loop through the updates and clone them.
        var update = firstBaseUpdate;

        do {
          var clone = {
            eventTime: update.eventTime,
            lane: update.lane,
            tag: update.tag,
            payload: update.payload,
            callback: update.callback,
            next: null
          };

          if (newLast === null) {
            newFirst = newLast = clone;
          } else {
            newLast.next = clone;
            newLast = clone;
          }

          update = update.next;
        } while (update !== null); // Append the captured update the end of the cloned list.


        if (newLast === null) {
          newFirst = newLast = capturedUpdate;
        } else {
          newLast.next = capturedUpdate;
          newLast = capturedUpdate;
        }
      } else {
        // There are no base updates.
        newFirst = newLast = capturedUpdate;
      }

      queue = {
        baseState: currentQueue.baseState,
        firstBaseUpdate: newFirst,
        lastBaseUpdate: newLast,
        shared: currentQueue.shared,
        effects: currentQueue.effects
      };
      workInProgress.updateQueue = queue;
      return;
    }
  } // Append the update to the end of the list.


  var lastBaseUpdate = queue.lastBaseUpdate;

  if (lastBaseUpdate === null) {
    queue.firstBaseUpdate = capturedUpdate;
  } else {
    lastBaseUpdate.next = capturedUpdate;
  }

  queue.lastBaseUpdate = capturedUpdate;
}

function getStateFromUpdate(workInProgress, queue, update, prevState, nextProps, instance) {
  switch (update.tag) {
    case ReplaceState:
      {
        var payload = update.payload;

        if (typeof payload === 'function') {
          // Updater function
          {
            enterDisallowedContextReadInDEV();
          }

          var nextState = payload.call(instance, prevState, nextProps);

          {
            if ( workInProgress.mode & StrictMode) {
              disableLogs();

              try {
                payload.call(instance, prevState, nextProps);
              } finally {
                reenableLogs();
              }
            }

            exitDisallowedContextReadInDEV();
          }

          return nextState;
        } // State object


        return payload;
      }

    case CaptureUpdate:
      {
        workInProgress.flags = workInProgress.flags & ~ShouldCapture | DidCapture;
      }
    // Intentional fallthrough

    case UpdateState:
      {
        var _payload = update.payload;
        var partialState;

        if (typeof _payload === 'function') {
          // Updater function
          {
            enterDisallowedContextReadInDEV();
          }

          partialState = _payload.call(instance, prevState, nextProps);

          {
            if ( workInProgress.mode & StrictMode) {
              disableLogs();

              try {
                _payload.call(instance, prevState, nextProps);
              } finally {
                reenableLogs();
              }
            }

            exitDisallowedContextReadInDEV();
          }
        } else {
          // Partial state object
          partialState = _payload;
        }

        if (partialState === null || partialState === undefined) {
          // Null and undefined are treated as no-ops.
          return prevState;
        } // Merge the partial state and the previous state.


        return _assign({}, prevState, partialState);
      }

    case ForceUpdate:
      {
        hasForceUpdate = true;
        return prevState;
      }
  }

  return prevState;
}

function processUpdateQueue(workInProgress, props, instance, renderLanes) {
  // This is always non-null on a ClassComponent or HostRoot
  var queue = workInProgress.updateQueue;
  hasForceUpdate = false;

  {
    currentlyProcessingQueue = queue.shared;
  }

  var firstBaseUpdate = queue.firstBaseUpdate;
  var lastBaseUpdate = queue.lastBaseUpdate; // Check if there are pending updates. If so, transfer them to the base queue.

  var pendingQueue = queue.shared.pending;

  if (pendingQueue !== null) {
    queue.shared.pending = null; // The pending queue is circular. Disconnect the pointer between first
    // and last so that it's non-circular.

    var lastPendingUpdate = pendingQueue;
    var firstPendingUpdate = lastPendingUpdate.next;
    lastPendingUpdate.next = null; // Append pending updates to base queue

    if (lastBaseUpdate === null) {
      firstBaseUpdate = firstPendingUpdate;
    } else {
      lastBaseUpdate.next = firstPendingUpdate;
    }

    lastBaseUpdate = lastPendingUpdate; // If there's a current queue, and it's different from the base queue, then
    // we need to transfer the updates to that queue, too. Because the base
    // queue is a singly-linked list with no cycles, we can append to both
    // lists and take advantage of structural sharing.
    // TODO: Pass `current` as argument

    var current = workInProgress.alternate;

    if (current !== null) {
      // This is always non-null on a ClassComponent or HostRoot
      var currentQueue = current.updateQueue;
      var currentLastBaseUpdate = currentQueue.lastBaseUpdate;

      if (currentLastBaseUpdate !== lastBaseUpdate) {
        if (currentLastBaseUpdate === null) {
          currentQueue.firstBaseUpdate = firstPendingUpdate;
        } else {
          currentLastBaseUpdate.next = firstPendingUpdate;
        }

        currentQueue.lastBaseUpdate = lastPendingUpdate;
      }
    }
  } // These values may change as we process the queue.


  if (firstBaseUpdate !== null) {
    // Iterate through the list of updates to compute the result.
    var newState = queue.baseState; // TODO: Don't need to accumulate this. Instead, we can remove renderLanes
    // from the original lanes.

    var newLanes = NoLanes;
    var newBaseState = null;
    var newFirstBaseUpdate = null;
    var newLastBaseUpdate = null;
    var update = firstBaseUpdate;

    do {
      var updateLane = update.lane;
      var updateEventTime = update.eventTime;

      if (!isSubsetOfLanes(renderLanes, updateLane)) {
        // Priority is insufficient. Skip this update. If this is the first
        // skipped update, the previous update/state is the new base
        // update/state.
        var clone = {
          eventTime: updateEventTime,
          lane: updateLane,
          tag: update.tag,
          payload: update.payload,
          callback: update.callback,
          next: null
        };

        if (newLastBaseUpdate === null) {
          newFirstBaseUpdate = newLastBaseUpdate = clone;
          newBaseState = newState;
        } else {
          newLastBaseUpdate = newLastBaseUpdate.next = clone;
        } // Update the remaining priority in the queue.


        newLanes = mergeLanes(newLanes, updateLane);
      } else {
        // This update does have sufficient priority.
        if (newLastBaseUpdate !== null) {
          var _clone = {
            eventTime: updateEventTime,
            // This update is going to be committed so we never want uncommit
            // it. Using NoLane works because 0 is a subset of all bitmasks, so
            // this will never be skipped by the check above.
            lane: NoLane,
            tag: update.tag,
            payload: update.payload,
            callback: update.callback,
            next: null
          };
          newLastBaseUpdate = newLastBaseUpdate.next = _clone;
        } // Process this update.


        newState = getStateFromUpdate(workInProgress, queue, update, newState, props, instance);
        var callback = update.callback;

        if (callback !== null) {
          workInProgress.flags |= Callback;
          var effects = queue.effects;

          if (effects === null) {
            queue.effects = [update];
          } else {
            effects.push(update);
          }
        }
      }

      update = update.next;

      if (update === null) {
        pendingQueue = queue.shared.pending;

        if (pendingQueue === null) {
          break;
        } else {
          // An update was scheduled from inside a reducer. Add the new
          // pending updates to the end of the list and keep processing.
          var _lastPendingUpdate = pendingQueue; // Intentionally unsound. Pending updates form a circular list, but we
          // unravel them when transferring them to the base queue.

          var _firstPendingUpdate = _lastPendingUpdate.next;
          _lastPendingUpdate.next = null;
          update = _firstPendingUpdate;
          queue.lastBaseUpdate = _lastPendingUpdate;
          queue.shared.pending = null;
        }
      }
    } while (true);

    if (newLastBaseUpdate === null) {
      newBaseState = newState;
    }

    queue.baseState = newBaseState;
    queue.firstBaseUpdate = newFirstBaseUpdate;
    queue.lastBaseUpdate = newLastBaseUpdate; // Set the remaining expiration time to be whatever is remaining in the queue.
    // This should be fine because the only two other things that contribute to
    // expiration time are props and context. We're already in the middle of the
    // begin phase by the time we start processing the queue, so we've already
    // dealt with the props. Context in components that specify
    // shouldComponentUpdate is tricky; but we'll have to account for
    // that regardless.

    markSkippedUpdateLanes(newLanes);
    workInProgress.lanes = newLanes;
    workInProgress.memoizedState = newState;
  }

  {
    currentlyProcessingQueue = null;
  }
}

function callCallback(callback, context) {
  if (!(typeof callback === 'function')) {
    {
      throw Error( "Invalid argument passed as callback. Expected a function. Instead received: " + callback );
    }
  }

  callback.call(context);
}

function resetHasForceUpdateBeforeProcessing() {
  hasForceUpdate = false;
}
function checkHasForceUpdateAfterProcessing() {
  return hasForceUpdate;
}
function commitUpdateQueue(finishedWork, finishedQueue, instance) {
  // Commit the effects
  var effects = finishedQueue.effects;
  finishedQueue.effects = null;

  if (effects !== null) {
    for (var i = 0; i < effects.length; i++) {
      var effect = effects[i];
      var callback = effect.callback;

      if (callback !== null) {
        effect.callback = null;
        callCallback(callback, instance);
      }
    }
  }
}

var fakeInternalInstance = {};
var isArray = Array.isArray; // React.Component uses a shared frozen object by default.
// We'll use it to determine whether we need to initialize legacy refs.

var emptyRefsObject = new React.Component().refs;
var didWarnAboutStateAssignmentForComponent;
var didWarnAboutUninitializedState;
var didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate;
var didWarnAboutLegacyLifecyclesAndDerivedState;
var didWarnAboutUndefinedDerivedState;
var warnOnUndefinedDerivedState;
var warnOnInvalidCallback;
var didWarnAboutDirectlyAssigningPropsToState;
var didWarnAboutContextTypeAndContextTypes;
var didWarnAboutInvalidateContextType;

{
  didWarnAboutStateAssignmentForComponent = new Set();
  didWarnAboutUninitializedState = new Set();
  didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate = new Set();
  didWarnAboutLegacyLifecyclesAndDerivedState = new Set();
  didWarnAboutDirectlyAssigningPropsToState = new Set();
  didWarnAboutUndefinedDerivedState = new Set();
  didWarnAboutContextTypeAndContextTypes = new Set();
  didWarnAboutInvalidateContextType = new Set();
  var didWarnOnInvalidCallback = new Set();

  warnOnInvalidCallback = function (callback, callerName) {
    if (callback === null || typeof callback === 'function') {
      return;
    }

    var key = callerName + '_' + callback;

    if (!didWarnOnInvalidCallback.has(key)) {
      didWarnOnInvalidCallback.add(key);

      error('%s(...): Expected the last optional `callback` argument to be a ' + 'function. Instead received: %s.', callerName, callback);
    }
  };

  warnOnUndefinedDerivedState = function (type, partialState) {
    if (partialState === undefined) {
      var componentName = getComponentName(type) || 'Component';

      if (!didWarnAboutUndefinedDerivedState.has(componentName)) {
        didWarnAboutUndefinedDerivedState.add(componentName);

        error('%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. ' + 'You have returned undefined.', componentName);
      }
    }
  }; // This is so gross but it's at least non-critical and can be removed if
  // it causes problems. This is meant to give a nicer error message for
  // ReactDOM15.unstable_renderSubtreeIntoContainer(reactDOM16Component,
  // ...)) which otherwise throws a "_processChildContext is not a function"
  // exception.


  Object.defineProperty(fakeInternalInstance, '_processChildContext', {
    enumerable: false,
    value: function () {
      {
        {
          throw Error( "_processChildContext is not available in React 16+. This likely means you have multiple copies of React and are attempting to nest a React 15 tree inside a React 16 tree using unstable_renderSubtreeIntoContainer, which isn't supported. Try to make sure you have only one copy of React (and ideally, switch to ReactDOM.createPortal)." );
        }
      }
    }
  });
  Object.freeze(fakeInternalInstance);
}

function applyDerivedStateFromProps(workInProgress, ctor, getDerivedStateFromProps, nextProps) {
  var prevState = workInProgress.memoizedState;

  {
    if ( workInProgress.mode & StrictMode) {
      disableLogs();

      try {
        // Invoke the function an extra time to help detect side-effects.
        getDerivedStateFromProps(nextProps, prevState);
      } finally {
        reenableLogs();
      }
    }
  }

  var partialState = getDerivedStateFromProps(nextProps, prevState);

  {
    warnOnUndefinedDerivedState(ctor, partialState);
  } // Merge the partial state and the previous state.


  var memoizedState = partialState === null || partialState === undefined ? prevState : _assign({}, prevState, partialState);
  workInProgress.memoizedState = memoizedState; // Once the update queue is empty, persist the derived state onto the
  // base state.

  if (workInProgress.lanes === NoLanes) {
    // Queue is always non-null for classes
    var updateQueue = workInProgress.updateQueue;
    updateQueue.baseState = memoizedState;
  }
}
var classComponentUpdater = {
  isMounted: isMounted,
  enqueueSetState: function (inst, payload, callback) {
    var fiber = get(inst);
    var eventTime = requestEventTime();
    var lane = requestUpdateLane(fiber);
    var update = createUpdate(eventTime, lane);
    update.payload = payload;

    if (callback !== undefined && callback !== null) {
      {
        warnOnInvalidCallback(callback, 'setState');
      }

      update.callback = callback;
    }

    enqueueUpdate(fiber, update);
    scheduleUpdateOnFiber(fiber, lane, eventTime);
  },
  enqueueReplaceState: function (inst, payload, callback) {
    var fiber = get(inst);
    var eventTime = requestEventTime();
    var lane = requestUpdateLane(fiber);
    var update = createUpdate(eventTime, lane);
    update.tag = ReplaceState;
    update.payload = payload;

    if (callback !== undefined && callback !== null) {
      {
        warnOnInvalidCallback(callback, 'replaceState');
      }

      update.callback = callback;
    }

    enqueueUpdate(fiber, update);
    scheduleUpdateOnFiber(fiber, lane, eventTime);
  },
  enqueueForceUpdate: function (inst, callback) {
    var fiber = get(inst);
    var eventTime = requestEventTime();
    var lane = requestUpdateLane(fiber);
    var update = createUpdate(eventTime, lane);
    update.tag = ForceUpdate;

    if (callback !== undefined && callback !== null) {
      {
        warnOnInvalidCallback(callback, 'forceUpdate');
      }

      update.callback = callback;
    }

    enqueueUpdate(fiber, update);
    scheduleUpdateOnFiber(fiber, lane, eventTime);
  }
};

function checkShouldComponentUpdate(workInProgress, ctor, oldProps, newProps, oldState, newState, nextContext) {
  var instance = workInProgress.stateNode;

  if (typeof instance.shouldComponentUpdate === 'function') {
    {
      if ( workInProgress.mode & StrictMode) {
        disableLogs();

        try {
          // Invoke the function an extra time to help detect side-effects.
          instance.shouldComponentUpdate(newProps, newState, nextContext);
        } finally {
          reenableLogs();
        }
      }
    }

    var shouldUpdate = instance.shouldComponentUpdate(newProps, newState, nextContext);

    {
      if (shouldUpdate === undefined) {
        error('%s.shouldComponentUpdate(): Returned undefined instead of a ' + 'boolean value. Make sure to return true or false.', getComponentName(ctor) || 'Component');
      }
    }

    return shouldUpdate;
  }

  if (ctor.prototype && ctor.prototype.isPureReactComponent) {
    return !shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState);
  }

  return true;
}

function checkClassInstance(workInProgress, ctor, newProps) {
  var instance = workInProgress.stateNode;

  {
    var name = getComponentName(ctor) || 'Component';
    var renderPresent = instance.render;

    if (!renderPresent) {
      if (ctor.prototype && typeof ctor.prototype.render === 'function') {
        error('%s(...): No `render` method found on the returned component ' + 'instance: did you accidentally return an object from the constructor?', name);
      } else {
        error('%s(...): No `render` method found on the returned component ' + 'instance: you may have forgotten to define `render`.', name);
      }
    }

    if (instance.getInitialState && !instance.getInitialState.isReactClassApproved && !instance.state) {
      error('getInitialState was defined on %s, a plain JavaScript class. ' + 'This is only supported for classes created using React.createClass. ' + 'Did you mean to define a state property instead?', name);
    }

    if (instance.getDefaultProps && !instance.getDefaultProps.isReactClassApproved) {
      error('getDefaultProps was defined on %s, a plain JavaScript class. ' + 'This is only supported for classes created using React.createClass. ' + 'Use a static property to define defaultProps instead.', name);
    }

    if (instance.propTypes) {
      error('propTypes was defined as an instance property on %s. Use a static ' + 'property to define propTypes instead.', name);
    }

    if (instance.contextType) {
      error('contextType was defined as an instance property on %s. Use a static ' + 'property to define contextType instead.', name);
    }

    {
      if (instance.contextTypes) {
        error('contextTypes was defined as an instance property on %s. Use a static ' + 'property to define contextTypes instead.', name);
      }

      if (ctor.contextType && ctor.contextTypes && !didWarnAboutContextTypeAndContextTypes.has(ctor)) {
        didWarnAboutContextTypeAndContextTypes.add(ctor);

        error('%s declares both contextTypes and contextType static properties. ' + 'The legacy contextTypes property will be ignored.', name);
      }
    }

    if (typeof instance.componentShouldUpdate === 'function') {
      error('%s has a method called ' + 'componentShouldUpdate(). Did you mean shouldComponentUpdate()? ' + 'The name is phrased as a question because the function is ' + 'expected to return a value.', name);
    }

    if (ctor.prototype && ctor.prototype.isPureReactComponent && typeof instance.shouldComponentUpdate !== 'undefined') {
      error('%s has a method called shouldComponentUpdate(). ' + 'shouldComponentUpdate should not be used when extending React.PureComponent. ' + 'Please extend React.Component if shouldComponentUpdate is used.', getComponentName(ctor) || 'A pure component');
    }

    if (typeof instance.componentDidUnmount === 'function') {
      error('%s has a method called ' + 'componentDidUnmount(). But there is no such lifecycle method. ' + 'Did you mean componentWillUnmount()?', name);
    }

    if (typeof instance.componentDidReceiveProps === 'function') {
      error('%s has a method called ' + 'componentDidReceiveProps(). But there is no such lifecycle method. ' + 'If you meant to update the state in response to changing props, ' + 'use componentWillReceiveProps(). If you meant to fetch data or ' + 'run side-effects or mutations after React has updated the UI, use componentDidUpdate().', name);
    }

    if (typeof instance.componentWillRecieveProps === 'function') {
      error('%s has a method called ' + 'componentWillRecieveProps(). Did you mean componentWillReceiveProps()?', name);
    }

    if (typeof instance.UNSAFE_componentWillRecieveProps === 'function') {
      error('%s has a method called ' + 'UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?', name);
    }

    var hasMutatedProps = instance.props !== newProps;

    if (instance.props !== undefined && hasMutatedProps) {
      error('%s(...): When calling super() in `%s`, make sure to pass ' + "up the same props that your component's constructor was passed.", name, name);
    }

    if (instance.defaultProps) {
      error('Setting defaultProps as an instance property on %s is not supported and will be ignored.' + ' Instead, define defaultProps as a static property on %s.', name, name);
    }

    if (typeof instance.getSnapshotBeforeUpdate === 'function' && typeof instance.componentDidUpdate !== 'function' && !didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.has(ctor)) {
      didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.add(ctor);

      error('%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). ' + 'This component defines getSnapshotBeforeUpdate() only.', getComponentName(ctor));
    }

    if (typeof instance.getDerivedStateFromProps === 'function') {
      error('%s: getDerivedStateFromProps() is defined as an instance method ' + 'and will be ignored. Instead, declare it as a static method.', name);
    }

    if (typeof instance.getDerivedStateFromError === 'function') {
      error('%s: getDerivedStateFromError() is defined as an instance method ' + 'and will be ignored. Instead, declare it as a static method.', name);
    }

    if (typeof ctor.getSnapshotBeforeUpdate === 'function') {
      error('%s: getSnapshotBeforeUpdate() is defined as a static method ' + 'and will be ignored. Instead, declare it as an instance method.', name);
    }

    var _state = instance.state;

    if (_state && (typeof _state !== 'object' || isArray(_state))) {
      error('%s.state: must be set to an object or null', name);
    }

    if (typeof instance.getChildContext === 'function' && typeof ctor.childContextTypes !== 'object') {
      error('%s.getChildContext(): childContextTypes must be defined in order to ' + 'use getChildContext().', name);
    }
  }
}

function adoptClassInstance(workInProgress, instance) {
  instance.updater = classComponentUpdater;
  workInProgress.stateNode = instance; // The instance needs access to the fiber so that it can schedule updates

  set(instance, workInProgress);

  {
    instance._reactInternalInstance = fakeInternalInstance;
  }
}

function constructClassInstance(workInProgress, ctor, props) {
  var isLegacyContextConsumer = false;
  var unmaskedContext = emptyContextObject;
  var context = emptyContextObject;
  var contextType = ctor.contextType;

  {
    if ('contextType' in ctor) {
      var isValid = // Allow null for conditional declaration
      contextType === null || contextType !== undefined && contextType.$$typeof === REACT_CONTEXT_TYPE && contextType._context === undefined; // Not a <Context.Consumer>

      if (!isValid && !didWarnAboutInvalidateContextType.has(ctor)) {
        didWarnAboutInvalidateContextType.add(ctor);
        var addendum = '';

        if (contextType === undefined) {
          addendum = ' However, it is set to undefined. ' + 'This can be caused by a typo or by mixing up named and default imports. ' + 'This can also happen due to a circular dependency, so ' + 'try moving the createContext() call to a separate file.';
        } else if (typeof contextType !== 'object') {
          addendum = ' However, it is set to a ' + typeof contextType + '.';
        } else if (contextType.$$typeof === REACT_PROVIDER_TYPE) {
          addendum = ' Did you accidentally pass the Context.Provider instead?';
        } else if (contextType._context !== undefined) {
          // <Context.Consumer>
          addendum = ' Did you accidentally pass the Context.Consumer instead?';
        } else {
          addendum = ' However, it is set to an object with keys {' + Object.keys(contextType).join(', ') + '}.';
        }

        error('%s defines an invalid contextType. ' + 'contextType should point to the Context object returned by React.createContext().%s', getComponentName(ctor) || 'Component', addendum);
      }
    }
  }

  if (typeof contextType === 'object' && contextType !== null) {
    context = readContext(contextType);
  } else {
    unmaskedContext = getUnmaskedContext(workInProgress, ctor, true);
    var contextTypes = ctor.contextTypes;
    isLegacyContextConsumer = contextTypes !== null && contextTypes !== undefined;
    context = isLegacyContextConsumer ? getMaskedContext(workInProgress, unmaskedContext) : emptyContextObject;
  } // Instantiate twice to help detect side-effects.


  {
    if ( workInProgress.mode & StrictMode) {
      disableLogs();

      try {
        new ctor(props, context); // eslint-disable-line no-new
      } finally {
        reenableLogs();
      }
    }
  }

  var instance = new ctor(props, context);
  var state = workInProgress.memoizedState = instance.state !== null && instance.state !== undefined ? instance.state : null;
  adoptClassInstance(workInProgress, instance);

  {
    if (typeof ctor.getDerivedStateFromProps === 'function' && state === null) {
      var componentName = getComponentName(ctor) || 'Component';

      if (!didWarnAboutUninitializedState.has(componentName)) {
        didWarnAboutUninitializedState.add(componentName);

        error('`%s` uses `getDerivedStateFromProps` but its initial state is ' + '%s. This is not recommended. Instead, define the initial state by ' + 'assigning an object to `this.state` in the constructor of `%s`. ' + 'This ensures that `getDerivedStateFromProps` arguments have a consistent shape.', componentName, instance.state === null ? 'null' : 'undefined', componentName);
      }
    } // If new component APIs are defined, "unsafe" lifecycles won't be called.
    // Warn about these lifecycles if they are present.
    // Don't warn about react-lifecycles-compat polyfilled methods though.


    if (typeof ctor.getDerivedStateFromProps === 'function' || typeof instance.getSnapshotBeforeUpdate === 'function') {
      var foundWillMountName = null;
      var foundWillReceivePropsName = null;
      var foundWillUpdateName = null;

      if (typeof instance.componentWillMount === 'function' && instance.componentWillMount.__suppressDeprecationWarning !== true) {
        foundWillMountName = 'componentWillMount';
      } else if (typeof instance.UNSAFE_componentWillMount === 'function') {
        foundWillMountName = 'UNSAFE_componentWillMount';
      }

      if (typeof instance.componentWillReceiveProps === 'function' && instance.componentWillReceiveProps.__suppressDeprecationWarning !== true) {
        foundWillReceivePropsName = 'componentWillReceiveProps';
      } else if (typeof instance.UNSAFE_componentWillReceiveProps === 'function') {
        foundWillReceivePropsName = 'UNSAFE_componentWillReceiveProps';
      }

      if (typeof instance.componentWillUpdate === 'function' && instance.componentWillUpdate.__suppressDeprecationWarning !== true) {
        foundWillUpdateName = 'componentWillUpdate';
      } else if (typeof instance.UNSAFE_componentWillUpdate === 'function') {
        foundWillUpdateName = 'UNSAFE_componentWillUpdate';
      }

      if (foundWillMountName !== null || foundWillReceivePropsName !== null || foundWillUpdateName !== null) {
        var _componentName = getComponentName(ctor) || 'Component';

        var newApiName = typeof ctor.getDerivedStateFromProps === 'function' ? 'getDerivedStateFromProps()' : 'getSnapshotBeforeUpdate()';

        if (!didWarnAboutLegacyLifecyclesAndDerivedState.has(_componentName)) {
          didWarnAboutLegacyLifecyclesAndDerivedState.add(_componentName);

          error('Unsafe legacy lifecycles will not be called for components using new component APIs.\n\n' + '%s uses %s but also contains the following legacy lifecycles:%s%s%s\n\n' + 'The above lifecycles should be removed. Learn more about this warning here:\n' + 'https://reactjs.org/link/unsafe-component-lifecycles', _componentName, newApiName, foundWillMountName !== null ? "\n  " + foundWillMountName : '', foundWillReceivePropsName !== null ? "\n  " + foundWillReceivePropsName : '', foundWillUpdateName !== null ? "\n  " + foundWillUpdateName : '');
        }
      }
    }
  } // Cache unmasked context so we can avoid recreating masked context unless necessary.
  // ReactFiberContext usually updates this cache but can't for newly-created instances.


  if (isLegacyContextConsumer) {
    cacheContext(workInProgress, unmaskedContext, context);
  }

  return instance;
}

function callComponentWillMount(workInProgress, instance) {
  var oldState = instance.state;

  if (typeof instance.componentWillMount === 'function') {
    instance.componentWillMount();
  }

  if (typeof instance.UNSAFE_componentWillMount === 'function') {
    instance.UNSAFE_componentWillMount();
  }

  if (oldState !== instance.state) {
    {
      error('%s.componentWillMount(): Assigning directly to this.state is ' + "deprecated (except inside a component's " + 'constructor). Use setState instead.', getComponentName(workInProgress.type) || 'Component');
    }

    classComponentUpdater.enqueueReplaceState(instance, instance.state, null);
  }
}

function callComponentWillReceiveProps(workInProgress, instance, newProps, nextContext) {
  var oldState = instance.state;

  if (typeof instance.componentWillReceiveProps === 'function') {
    instance.componentWillReceiveProps(newProps, nextContext);
  }

  if (typeof instance.UNSAFE_componentWillReceiveProps === 'function') {
    instance.UNSAFE_componentWillReceiveProps(newProps, nextContext);
  }

  if (instance.state !== oldState) {
    {
      var componentName = getComponentName(workInProgress.type) || 'Component';

      if (!didWarnAboutStateAssignmentForComponent.has(componentName)) {
        didWarnAboutStateAssignmentForComponent.add(componentName);

        error('%s.componentWillReceiveProps(): Assigning directly to ' + "this.state is deprecated (except inside a component's " + 'constructor). Use setState instead.', componentName);
      }
    }

    classComponentUpdater.enqueueReplaceState(instance, instance.state, null);
  }
} // Invokes the mount life-cycles on a previously never rendered instance.


function mountClassInstance(workInProgress, ctor, newProps, renderLanes) {
  {
    checkClassInstance(workInProgress, ctor, newProps);
  }

  var instance = workInProgress.stateNode;
  instance.props = newProps;
  instance.state = workInProgress.memoizedState;
  instance.refs = emptyRefsObject;
  initializeUpdateQueue(workInProgress);
  var contextType = ctor.contextType;

  if (typeof contextType === 'object' && contextType !== null) {
    instance.context = readContext(contextType);
  } else {
    var unmaskedContext = getUnmaskedContext(workInProgress, ctor, true);
    instance.context = getMaskedContext(workInProgress, unmaskedContext);
  }

  {
    if (instance.state === newProps) {
      var componentName = getComponentName(ctor) || 'Component';

      if (!didWarnAboutDirectlyAssigningPropsToState.has(componentName)) {
        didWarnAboutDirectlyAssigningPropsToState.add(componentName);

        error('%s: It is not recommended to assign props directly to state ' + "because updates to props won't be reflected in state. " + 'In most cases, it is better to use props directly.', componentName);
      }
    }

    if (workInProgress.mode & StrictMode) {
      ReactStrictModeWarnings.recordLegacyContextWarning(workInProgress, instance);
    }

    {
      ReactStrictModeWarnings.recordUnsafeLifecycleWarnings(workInProgress, instance);
    }
  }

  processUpdateQueue(workInProgress, newProps, instance, renderLanes);
  instance.state = workInProgress.memoizedState;
  var getDerivedStateFromProps = ctor.getDerivedStateFromProps;

  if (typeof getDerivedStateFromProps === 'function') {
    applyDerivedStateFromProps(workInProgress, ctor, getDerivedStateFromProps, newProps);
    instance.state = workInProgress.memoizedState;
  } // In order to support react-lifecycles-compat polyfilled components,
  // Unsafe lifecycles should not be invoked for components using the new APIs.


  if (typeof ctor.getDerivedStateFromProps !== 'function' && typeof instance.getSnapshotBeforeUpdate !== 'function' && (typeof instance.UNSAFE_componentWillMount === 'function' || typeof instance.componentWillMount === 'function')) {
    callComponentWillMount(workInProgress, instance); // If we had additional state updates during this life-cycle, let's
    // process them now.

    processUpdateQueue(workInProgress, newProps, instance, renderLanes);
    instance.state = workInProgress.memoizedState;
  }

  if (typeof instance.componentDidMount === 'function') {
    workInProgress.flags |= Update;
  }
}

function resumeMountClassInstance(workInProgress, ctor, newProps, renderLanes) {
  var instance = workInProgress.stateNode;
  var oldProps = workInProgress.memoizedProps;
  instance.props = oldProps;
  var oldContext = instance.context;
  var contextType = ctor.contextType;
  var nextContext = emptyContextObject;

  if (typeof contextType === 'object' && contextType !== null) {
    nextContext = readContext(contextType);
  } else {
    var nextLegacyUnmaskedContext = getUnmaskedContext(workInProgress, ctor, true);
    nextContext = getMaskedContext(workInProgress, nextLegacyUnmaskedContext);
  }

  var getDerivedStateFromProps = ctor.getDerivedStateFromProps;
  var hasNewLifecycles = typeof getDerivedStateFromProps === 'function' || typeof instance.getSnapshotBeforeUpdate === 'function'; // Note: During these life-cycles, instance.props/instance.state are what
  // ever the previously attempted to render - not the "current". However,
  // during componentDidUpdate we pass the "current" props.
  // In order to support react-lifecycles-compat polyfilled components,
  // Unsafe lifecycles should not be invoked for components using the new APIs.

  if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillReceiveProps === 'function' || typeof instance.componentWillReceiveProps === 'function')) {
    if (oldProps !== newProps || oldContext !== nextContext) {
      callComponentWillReceiveProps(workInProgress, instance, newProps, nextContext);
    }
  }

  resetHasForceUpdateBeforeProcessing();
  var oldState = workInProgress.memoizedState;
  var newState = instance.state = oldState;
  processUpdateQueue(workInProgress, newProps, instance, renderLanes);
  newState = workInProgress.memoizedState;

  if (oldProps === newProps && oldState === newState && !hasContextChanged() && !checkHasForceUpdateAfterProcessing()) {
    // If an update was already in progress, we should schedule an Update
    // effect even though we're bailing out, so that cWU/cDU are called.
    if (typeof instance.componentDidMount === 'function') {
      workInProgress.flags |= Update;
    }

    return false;
  }

  if (typeof getDerivedStateFromProps === 'function') {
    applyDerivedStateFromProps(workInProgress, ctor, getDerivedStateFromProps, newProps);
    newState = workInProgress.memoizedState;
  }

  var shouldUpdate = checkHasForceUpdateAfterProcessing() || checkShouldComponentUpdate(workInProgress, ctor, oldProps, newProps, oldState, newState, nextContext);

  if (shouldUpdate) {
    // In order to support react-lifecycles-compat polyfilled components,
    // Unsafe lifecycles should not be invoked for components using the new APIs.
    if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillMount === 'function' || typeof instance.componentWillMount === 'function')) {
      if (typeof instance.componentWillMount === 'function') {
        instance.componentWillMount();
      }

      if (typeof instance.UNSAFE_componentWillMount === 'function') {
        instance.UNSAFE_componentWillMount();
      }
    }

    if (typeof instance.componentDidMount === 'function') {
      workInProgress.flags |= Update;
    }
  } else {
    // If an update was already in progress, we should schedule an Update
    // effect even though we're bailing out, so that cWU/cDU are called.
    if (typeof instance.componentDidMount === 'function') {
      workInProgress.flags |= Update;
    } // If shouldComponentUpdate returned false, we should still update the
    // memoized state to indicate that this work can be reused.


    workInProgress.memoizedProps = newProps;
    workInProgress.memoizedState = newState;
  } // Update the existing instance's state, props, and context pointers even
  // if shouldComponentUpdate returns false.


  instance.props = newProps;
  instance.state = newState;
  instance.context = nextContext;
  return shouldUpdate;
} // Invokes the update life-cycles and returns false if it shouldn't rerender.


function updateClassInstance(current, workInProgress, ctor, newProps, renderLanes) {
  var instance = workInProgress.stateNode;
  cloneUpdateQueue(current, workInProgress);
  var unresolvedOldProps = workInProgress.memoizedProps;
  var oldProps = workInProgress.type === workInProgress.elementType ? unresolvedOldProps : resolveDefaultProps(workInProgress.type, unresolvedOldProps);
  instance.props = oldProps;
  var unresolvedNewProps = workInProgress.pendingProps;
  var oldContext = instance.context;
  var contextType = ctor.contextType;
  var nextContext = emptyContextObject;

  if (typeof contextType === 'object' && contextType !== null) {
    nextContext = readContext(contextType);
  } else {
    var nextUnmaskedContext = getUnmaskedContext(workInProgress, ctor, true);
    nextContext = getMaskedContext(workInProgress, nextUnmaskedContext);
  }

  var getDerivedStateFromProps = ctor.getDerivedStateFromProps;
  var hasNewLifecycles = typeof getDerivedStateFromProps === 'function' || typeof instance.getSnapshotBeforeUpdate === 'function'; // Note: During these life-cycles, instance.props/instance.state are what
  // ever the previously attempted to render - not the "current". However,
  // during componentDidUpdate we pass the "current" props.
  // In order to support react-lifecycles-compat polyfilled components,
  // Unsafe lifecycles should not be invoked for components using the new APIs.

  if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillReceiveProps === 'function' || typeof instance.componentWillReceiveProps === 'function')) {
    if (unresolvedOldProps !== unresolvedNewProps || oldContext !== nextContext) {
      callComponentWillReceiveProps(workInProgress, instance, newProps, nextContext);
    }
  }

  resetHasForceUpdateBeforeProcessing();
  var oldState = workInProgress.memoizedState;
  var newState = instance.state = oldState;
  processUpdateQueue(workInProgress, newProps, instance, renderLanes);
  newState = workInProgress.memoizedState;

  if (unresolvedOldProps === unresolvedNewProps && oldState === newState && !hasContextChanged() && !checkHasForceUpdateAfterProcessing()) {
    // If an update was already in progress, we should schedule an Update
    // effect even though we're bailing out, so that cWU/cDU are called.
    if (typeof instance.componentDidUpdate === 'function') {
      if (unresolvedOldProps !== current.memoizedProps || oldState !== current.memoizedState) {
        workInProgress.flags |= Update;
      }
    }

    if (typeof instance.getSnapshotBeforeUpdate === 'function') {
      if (unresolvedOldProps !== current.memoizedProps || oldState !== current.memoizedState) {
        workInProgress.flags |= Snapshot;
      }
    }

    return false;
  }

  if (typeof getDerivedStateFromProps === 'function') {
    applyDerivedStateFromProps(workInProgress, ctor, getDerivedStateFromProps, newProps);
    newState = workInProgress.memoizedState;
  }

  var shouldUpdate = checkHasForceUpdateAfterProcessing() || checkShouldComponentUpdate(workInProgress, ctor, oldProps, newProps, oldState, newState, nextContext);

  if (shouldUpdate) {
    // In order to support react-lifecycles-compat polyfilled components,
    // Unsafe lifecycles should not be invoked for components using the new APIs.
    if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillUpdate === 'function' || typeof instance.componentWillUpdate === 'function')) {
      if (typeof instance.componentWillUpdate === 'function') {
        instance.componentWillUpdate(newProps, newState, nextContext);
      }

      if (typeof instance.UNSAFE_componentWillUpdate === 'function') {
        instance.UNSAFE_componentWillUpdate(newProps, newState, nextContext);
      }
    }

    if (typeof instance.componentDidUpdate === 'function') {
      workInProgress.flags |= Update;
    }

    if (typeof instance.getSnapshotBeforeUpdate === 'function') {
      workInProgress.flags |= Snapshot;
    }
  } else {
    // If an update was already in progress, we should schedule an Update
    // effect even though we're bailing out, so that cWU/cDU are called.
    if (typeof instance.componentDidUpdate === 'function') {
      if (unresolvedOldProps !== current.memoizedProps || oldState !== current.memoizedState) {
        workInProgress.flags |= Update;
      }
    }

    if (typeof instance.getSnapshotBeforeUpdate === 'function') {
      if (unresolvedOldProps !== current.memoizedProps || oldState !== current.memoizedState) {
        workInProgress.flags |= Snapshot;
      }
    } // If shouldComponentUpdate returned false, we should still update the
    // memoized props/state to indicate that this work can be reused.


    workInProgress.memoizedProps = newProps;
    workInProgress.memoizedState = newState;
  } // Update the existing instance's state, props, and context pointers even
  // if shouldComponentUpdate returns false.


  instance.props = newProps;
  instance.state = newState;
  instance.context = nextContext;
  return shouldUpdate;
}

var didWarnAboutMaps;
var didWarnAboutGenerators;
var didWarnAboutStringRefs;
var ownerHasKeyUseWarning;
var ownerHasFunctionTypeWarning;

var warnForMissingKey = function (child, returnFiber) {};

{
  didWarnAboutMaps = false;
  didWarnAboutGenerators = false;
  didWarnAboutStringRefs = {};
  /**
   * Warn if there's no key explicitly set on dynamic arrays of children or
   * object keys are not valid. This allows us to keep track of children between
   * updates.
   */

  ownerHasKeyUseWarning = {};
  ownerHasFunctionTypeWarning = {};

  warnForMissingKey = function (child, returnFiber) {
    if (child === null || typeof child !== 'object') {
      return;
    }

    if (!child._store || child._store.validated || child.key != null) {
      return;
    }

    if (!(typeof child._store === 'object')) {
      {
        throw Error( "React Component in warnForMissingKey should have a _store. This error is likely caused by a bug in React. Please file an issue." );
      }
    }

    child._store.validated = true;
    var componentName = getComponentName(returnFiber.type) || 'Component';

    if (ownerHasKeyUseWarning[componentName]) {
      return;
    }

    ownerHasKeyUseWarning[componentName] = true;

    error('Each child in a list should have a unique ' + '"key" prop. See https://reactjs.org/link/warning-keys for ' + 'more information.');
  };
}

var isArray$1 = Array.isArray;

function coerceRef(returnFiber, current, element) {
  var mixedRef = element.ref;

  if (mixedRef !== null && typeof mixedRef !== 'function' && typeof mixedRef !== 'object') {
    {
      // TODO: Clean this up once we turn on the string ref warning for
      // everyone, because the strict mode case will no longer be relevant
      if ((returnFiber.mode & StrictMode || warnAboutStringRefs) && // We warn in ReactElement.js if owner and self are equal for string refs
      // because these cannot be automatically converted to an arrow function
      // using a codemod. Therefore, we don't have to warn about string refs again.
      !(element._owner && element._self && element._owner.stateNode !== element._self)) {
        var componentName = getComponentName(returnFiber.type) || 'Component';

        if (!didWarnAboutStringRefs[componentName]) {
          {
            error('A string ref, "%s", has been found within a strict mode tree. ' + 'String refs are a source of potential bugs and should be avoided. ' + 'We recommend using useRef() or createRef() instead. ' + 'Learn more about using refs safely here: ' + 'https://reactjs.org/link/strict-mode-string-ref', mixedRef);
          }

          didWarnAboutStringRefs[componentName] = true;
        }
      }
    }

    if (element._owner) {
      var owner = element._owner;
      var inst;

      if (owner) {
        var ownerFiber = owner;

        if (!(ownerFiber.tag === ClassComponent)) {
          {
            throw Error( "Function components cannot have string refs. We recommend using useRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref" );
          }
        }

        inst = ownerFiber.stateNode;
      }

      if (!inst) {
        {
          throw Error( "Missing owner for string ref " + mixedRef + ". This error is likely caused by a bug in React. Please file an issue." );
        }
      }

      var stringRef = '' + mixedRef; // Check if previous string ref matches new string ref

      if (current !== null && current.ref !== null && typeof current.ref === 'function' && current.ref._stringRef === stringRef) {
        return current.ref;
      }

      var ref = function (value) {
        var refs = inst.refs;

        if (refs === emptyRefsObject) {
          // This is a lazy pooled frozen object, so we need to initialize.
          refs = inst.refs = {};
        }

        if (value === null) {
          delete refs[stringRef];
        } else {
          refs[stringRef] = value;
        }
      };

      ref._stringRef = stringRef;
      return ref;
    } else {
      if (!(typeof mixedRef === 'string')) {
        {
          throw Error( "Expected ref to be a function, a string, an object returned by React.createRef(), or null." );
        }
      }

      if (!element._owner) {
        {
          throw Error( "Element ref was specified as a string (" + mixedRef + ") but no owner was set. This could happen for one of the following reasons:\n1. You may be adding a ref to a function component\n2. You may be adding a ref to a component that was not created inside a component's render method\n3. You have multiple copies of React loaded\nSee https://reactjs.org/link/refs-must-have-owner for more information." );
        }
      }
    }
  }

  return mixedRef;
}

function throwOnInvalidObjectType(returnFiber, newChild) {
  if (returnFiber.type !== 'textarea') {
    {
      {
        throw Error( "Objects are not valid as a React child (found: " + (Object.prototype.toString.call(newChild) === '[object Object]' ? 'object with keys {' + Object.keys(newChild).join(', ') + '}' : newChild) + "). If you meant to render a collection of children, use an array instead." );
      }
    }
  }
}

function warnOnFunctionType(returnFiber) {
  {
    var componentName = getComponentName(returnFiber.type) || 'Component';

    if (ownerHasFunctionTypeWarning[componentName]) {
      return;
    }

    ownerHasFunctionTypeWarning[componentName] = true;

    error('Functions are not valid as a React child. This may happen if ' + 'you return a Component instead of <Component /> from render. ' + 'Or maybe you meant to call this function rather than return it.');
  }
} // We avoid inlining this to avoid potential deopts from using try/catch.
// to be able to optimize each path individually by branching early. This needs
// a compiler or we can do it manually. Helpers that don't need this branching
// live outside of this function.


function ChildReconciler(shouldTrackSideEffects) {
  function deleteChild(returnFiber, childToDelete) {
    if (!shouldTrackSideEffects) {
      // Noop.
      return;
    } // Deletions are added in reversed order so we add it to the front.
    // At this point, the return fiber's effect list is empty except for
    // deletions, so we can just append the deletion to the list. The remaining
    // effects aren't added until the complete phase. Once we implement
    // resuming, this may not be true.


    var last = returnFiber.lastEffect;

    if (last !== null) {
      last.nextEffect = childToDelete;
      returnFiber.lastEffect = childToDelete;
    } else {
      returnFiber.firstEffect = returnFiber.lastEffect = childToDelete;
    }

    childToDelete.nextEffect = null;
    childToDelete.flags = Deletion;
  }

  function deleteRemainingChildren(returnFiber, currentFirstChild) {
    if (!shouldTrackSideEffects) {
      // Noop.
      return null;
    } // TODO: For the shouldClone case, this could be micro-optimized a bit by
    // assuming that after the first child we've already added everything.


    var childToDelete = currentFirstChild;

    while (childToDelete !== null) {
      deleteChild(returnFiber, childToDelete);
      childToDelete = childToDelete.sibling;
    }

    return null;
  }

  function mapRemainingChildren(returnFiber, currentFirstChild) {
    // Add the remaining children to a temporary map so that we can find them by
    // keys quickly. Implicit (null) keys get added to this set with their index
    // instead.
    var existingChildren = new Map();
    var existingChild = currentFirstChild;

    while (existingChild !== null) {
      if (existingChild.key !== null) {
        existingChildren.set(existingChild.key, existingChild);
      } else {
        existingChildren.set(existingChild.index, existingChild);
      }

      existingChild = existingChild.sibling;
    }

    return existingChildren;
  }

  function useFiber(fiber, pendingProps) {
    // We currently set sibling to null and index to 0 here because it is easy
    // to forget to do before returning it. E.g. for the single child case.
    var clone = createWorkInProgress(fiber, pendingProps);
    clone.index = 0;
    clone.sibling = null;
    return clone;
  }

  function placeChild(newFiber, lastPlacedIndex, newIndex) {
    newFiber.index = newIndex;

    if (!shouldTrackSideEffects) {
      // Noop.
      return lastPlacedIndex;
    }

    var current = newFiber.alternate;

    if (current !== null) {
      var oldIndex = current.index;

      if (oldIndex < lastPlacedIndex) {
        // This is a move.
        newFiber.flags = Placement;
        return lastPlacedIndex;
      } else {
        // This item can stay in place.
        return oldIndex;
      }
    } else {
      // This is an insertion.
      newFiber.flags = Placement;
      return lastPlacedIndex;
    }
  }

  function placeSingleChild(newFiber) {
    // This is simpler for the single child case. We only need to do a
    // placement for inserting new children.
    if (shouldTrackSideEffects && newFiber.alternate === null) {
      newFiber.flags = Placement;
    }

    return newFiber;
  }

  function updateTextNode(returnFiber, current, textContent, lanes) {
    if (current === null || current.tag !== HostText) {
      // Insert
      var created = createFiberFromText(textContent, returnFiber.mode, lanes);
      created.return = returnFiber;
      return created;
    } else {
      // Update
      var existing = useFiber(current, textContent);
      existing.return = returnFiber;
      return existing;
    }
  }

  function updateElement(returnFiber, current, element, lanes) {
    if (current !== null) {
      if (current.elementType === element.type || ( // Keep this check inline so it only runs on the false path:
       isCompatibleFamilyForHotReloading(current, element) )) {
        // Move based on index
        var existing = useFiber(current, element.props);
        existing.ref = coerceRef(returnFiber, current, element);
        existing.return = returnFiber;

        {
          existing._debugSource = element._source;
          existing._debugOwner = element._owner;
        }

        return existing;
      }
    } // Insert


    var created = createFiberFromElement(element, returnFiber.mode, lanes);
    created.ref = coerceRef(returnFiber, current, element);
    created.return = returnFiber;
    return created;
  }

  function updatePortal(returnFiber, current, portal, lanes) {
    if (current === null || current.tag !== HostPortal || current.stateNode.containerInfo !== portal.containerInfo || current.stateNode.implementation !== portal.implementation) {
      // Insert
      var created = createFiberFromPortal(portal, returnFiber.mode, lanes);
      created.return = returnFiber;
      return created;
    } else {
      // Update
      var existing = useFiber(current, portal.children || []);
      existing.return = returnFiber;
      return existing;
    }
  }

  function updateFragment(returnFiber, current, fragment, lanes, key) {
    if (current === null || current.tag !== Fragment) {
      // Insert
      var created = createFiberFromFragment(fragment, returnFiber.mode, lanes, key);
      created.return = returnFiber;
      return created;
    } else {
      // Update
      var existing = useFiber(current, fragment);
      existing.return = returnFiber;
      return existing;
    }
  }

  function createChild(returnFiber, newChild, lanes) {
    if (typeof newChild === 'string' || typeof newChild === 'number') {
      // Text nodes don't have keys. If the previous node is implicitly keyed
      // we can continue to replace it without aborting even if it is not a text
      // node.
      var created = createFiberFromText('' + newChild, returnFiber.mode, lanes);
      created.return = returnFiber;
      return created;
    }

    if (typeof newChild === 'object' && newChild !== null) {
      switch (newChild.$$typeof) {
        case REACT_ELEMENT_TYPE:
          {
            var _created = createFiberFromElement(newChild, returnFiber.mode, lanes);

            _created.ref = coerceRef(returnFiber, null, newChild);
            _created.return = returnFiber;
            return _created;
          }

        case REACT_PORTAL_TYPE:
          {
            var _created2 = createFiberFromPortal(newChild, returnFiber.mode, lanes);

            _created2.return = returnFiber;
            return _created2;
          }
      }

      if (isArray$1(newChild) || getIteratorFn(newChild)) {
        var _created3 = createFiberFromFragment(newChild, returnFiber.mode, lanes, null);

        _created3.return = returnFiber;
        return _created3;
      }

      throwOnInvalidObjectType(returnFiber, newChild);
    }

    {
      if (typeof newChild === 'function') {
        warnOnFunctionType(returnFiber);
      }
    }

    return null;
  }

  function updateSlot(returnFiber, oldFiber, newChild, lanes) {
    // Update the fiber if the keys match, otherwise return null.
    var key = oldFiber !== null ? oldFiber.key : null;

    if (typeof newChild === 'string' || typeof newChild === 'number') {
      // Text nodes don't have keys. If the previous node is implicitly keyed
      // we can continue to replace it without aborting even if it is not a text
      // node.
      if (key !== null) {
        return null;
      }

      return updateTextNode(returnFiber, oldFiber, '' + newChild, lanes);
    }

    if (typeof newChild === 'object' && newChild !== null) {
      switch (newChild.$$typeof) {
        case REACT_ELEMENT_TYPE:
          {
            if (newChild.key === key) {
              if (newChild.type === REACT_FRAGMENT_TYPE) {
                return updateFragment(returnFiber, oldFiber, newChild.props.children, lanes, key);
              }

              return updateElement(returnFiber, oldFiber, newChild, lanes);
            } else {
              return null;
            }
          }

        case REACT_PORTAL_TYPE:
          {
            if (newChild.key === key) {
              return updatePortal(returnFiber, oldFiber, newChild, lanes);
            } else {
              return null;
            }
          }
      }

      if (isArray$1(newChild) || getIteratorFn(newChild)) {
        if (key !== null) {
          return null;
        }

        return updateFragment(returnFiber, oldFiber, newChild, lanes, null);
      }

      throwOnInvalidObjectType(returnFiber, newChild);
    }

    {
      if (typeof newChild === 'function') {
        warnOnFunctionType(returnFiber);
      }
    }

    return null;
  }

  function updateFromMap(existingChildren, returnFiber, newIdx, newChild, lanes) {
    if (typeof newChild === 'string' || typeof newChild === 'number') {
      // Text nodes don't have keys, so we neither have to check the old nor
      // new node for the key. If both are text nodes, they match.
      var matchedFiber = existingChildren.get(newIdx) || null;
      return updateTextNode(returnFiber, matchedFiber, '' + newChild, lanes);
    }

    if (typeof newChild === 'object' && newChild !== null) {
      switch (newChild.$$typeof) {
        case REACT_ELEMENT_TYPE:
          {
            var _matchedFiber = existingChildren.get(newChild.key === null ? newIdx : newChild.key) || null;

            if (newChild.type === REACT_FRAGMENT_TYPE) {
              return updateFragment(returnFiber, _matchedFiber, newChild.props.children, lanes, newChild.key);
            }

            return updateElement(returnFiber, _matchedFiber, newChild, lanes);
          }

        case REACT_PORTAL_TYPE:
          {
            var _matchedFiber2 = existingChildren.get(newChild.key === null ? newIdx : newChild.key) || null;

            return updatePortal(returnFiber, _matchedFiber2, newChild, lanes);
          }

      }

      if (isArray$1(newChild) || getIteratorFn(newChild)) {
        var _matchedFiber3 = existingChildren.get(newIdx) || null;

        return updateFragment(returnFiber, _matchedFiber3, newChild, lanes, null);
      }

      throwOnInvalidObjectType(returnFiber, newChild);
    }

    {
      if (typeof newChild === 'function') {
        warnOnFunctionType(returnFiber);
      }
    }

    return null;
  }
  /**
   * Warns if there is a duplicate or missing key
   */


  function warnOnInvalidKey(child, knownKeys, returnFiber) {
    {
      if (typeof child !== 'object' || child === null) {
        return knownKeys;
      }

      switch (child.$$typeof) {
        case REACT_ELEMENT_TYPE:
        case REACT_PORTAL_TYPE:
          warnForMissingKey(child, returnFiber);
          var key = child.key;

          if (typeof key !== 'string') {
            break;
          }

          if (knownKeys === null) {
            knownKeys = new Set();
            knownKeys.add(key);
            break;
          }

          if (!knownKeys.has(key)) {
            knownKeys.add(key);
            break;
          }

          error('Encountered two children with the same key, `%s`. ' + 'Keys should be unique so that components maintain their identity ' + 'across updates. Non-unique keys may cause children to be ' + 'duplicated and/or omitted  the behavior is unsupported and ' + 'could change in a future version.', key);

          break;
      }
    }

    return knownKeys;
  }

  function reconcileChildrenArray(returnFiber, currentFirstChild, newChildren, lanes) {
    // This algorithm can't optimize by searching from both ends since we
    // don't have backpointers on fibers. I'm trying to see how far we can get
    // with that model. If it ends up not being worth the tradeoffs, we can
    // add it later.
    // Even with a two ended optimization, we'd want to optimize for the case
    // where there are few changes and brute force the comparison instead of
    // going for the Map. It'd like to explore hitting that path first in
    // forward-only mode and only go for the Map once we notice that we need
    // lots of look ahead. This doesn't handle reversal as well as two ended
    // search but that's unusual. Besides, for the two ended optimization to
    // work on Iterables, we'd need to copy the whole set.
    // In this first iteration, we'll just live with hitting the bad case
    // (adding everything to a Map) in for every insert/move.
    // If you change this code, also update reconcileChildrenIterator() which
    // uses the same algorithm.
    {
      // First, validate keys.
      var knownKeys = null;

      for (var i = 0; i < newChildren.length; i++) {
        var child = newChildren[i];
        knownKeys = warnOnInvalidKey(child, knownKeys, returnFiber);
      }
    }

    var resultingFirstChild = null;
    var previousNewFiber = null;
    var oldFiber = currentFirstChild;
    var lastPlacedIndex = 0;
    var newIdx = 0;
    var nextOldFiber = null;

    for (; oldFiber !== null && newIdx < newChildren.length; newIdx++) {
      if (oldFiber.index > newIdx) {
        nextOldFiber = oldFiber;
        oldFiber = null;
      } else {
        nextOldFiber = oldFiber.sibling;
      }

      var newFiber = updateSlot(returnFiber, oldFiber, newChildren[newIdx], lanes);

      if (newFiber === null) {
        // TODO: This breaks on empty slots like null children. That's
        // unfortunate because it triggers the slow path all the time. We need
        // a better way to communicate whether this was a miss or null,
        // boolean, undefined, etc.
        if (oldFiber === null) {
          oldFiber = nextOldFiber;
        }

        break;
      }

      if (shouldTrackSideEffects) {
        if (oldFiber && newFiber.alternate === null) {
          // We matched the slot, but we didn't reuse the existing fiber, so we
          // need to delete the existing child.
          deleteChild(returnFiber, oldFiber);
        }
      }

      lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);

      if (previousNewFiber === null) {
        // TODO: Move out of the loop. This only happens for the first run.
        resultingFirstChild = newFiber;
      } else {
        // TODO: Defer siblings if we're not at the right index for this slot.
        // I.e. if we had null values before, then we want to defer this
        // for each null value. However, we also don't want to call updateSlot
        // with the previous one.
        previousNewFiber.sibling = newFiber;
      }

      previousNewFiber = newFiber;
      oldFiber = nextOldFiber;
    }

    if (newIdx === newChildren.length) {
      // We've reached the end of the new children. We can delete the rest.
      deleteRemainingChildren(returnFiber, oldFiber);
      return resultingFirstChild;
    }

    if (oldFiber === null) {
      // If we don't have any more existing children we can choose a fast path
      // since the rest will all be insertions.
      for (; newIdx < newChildren.length; newIdx++) {
        var _newFiber = createChild(returnFiber, newChildren[newIdx], lanes);

        if (_newFiber === null) {
          continue;
        }

        lastPlacedIndex = placeChild(_newFiber, lastPlacedIndex, newIdx);

        if (previousNewFiber === null) {
          // TODO: Move out of the loop. This only happens for the first run.
          resultingFirstChild = _newFiber;
        } else {
          previousNewFiber.sibling = _newFiber;
        }

        previousNewFiber = _newFiber;
      }

      return resultingFirstChild;
    } // Add all children to a key map for quick lookups.


    var existingChildren = mapRemainingChildren(returnFiber, oldFiber); // Keep scanning and use the map to restore deleted items as moves.

    for (; newIdx < newChildren.length; newIdx++) {
      var _newFiber2 = updateFromMap(existingChildren, returnFiber, newIdx, newChildren[newIdx], lanes);

      if (_newFiber2 !== null) {
        if (shouldTrackSideEffects) {
          if (_newFiber2.alternate !== null) {
            // The new fiber is a work in progress, but if there exists a
            // current, that means that we reused the fiber. We need to delete
            // it from the child list so that we don't add it to the deletion
            // list.
            existingChildren.delete(_newFiber2.key === null ? newIdx : _newFiber2.key);
          }
        }

        lastPlacedIndex = placeChild(_newFiber2, lastPlacedIndex, newIdx);

        if (previousNewFiber === null) {
          resultingFirstChild = _newFiber2;
        } else {
          previousNewFiber.sibling = _newFiber2;
        }

        previousNewFiber = _newFiber2;
      }
    }

    if (shouldTrackSideEffects) {
      // Any existing children that weren't consumed above were deleted. We need
      // to add them to the deletion list.
      existingChildren.forEach(function (child) {
        return deleteChild(returnFiber, child);
      });
    }

    return resultingFirstChild;
  }

  function reconcileChildrenIterator(returnFiber, currentFirstChild, newChildrenIterable, lanes) {
    // This is the same implementation as reconcileChildrenArray(),
    // but using the iterator instead.
    var iteratorFn = getIteratorFn(newChildrenIterable);

    if (!(typeof iteratorFn === 'function')) {
      {
        throw Error( "An object is not an iterable. This error is likely caused by a bug in React. Please file an issue." );
      }
    }

    {
      // We don't support rendering Generators because it's a mutation.
      // See https://github.com/facebook/react/issues/12995
      if (typeof Symbol === 'function' && // $FlowFixMe Flow doesn't know about toStringTag
      newChildrenIterable[Symbol.toStringTag] === 'Generator') {
        if (!didWarnAboutGenerators) {
          error('Using Generators as children is unsupported and will likely yield ' + 'unexpected results because enumerating a generator mutates it. ' + 'You may convert it to an array with `Array.from()` or the ' + '`[...spread]` operator before rendering. Keep in mind ' + 'you might need to polyfill these features for older browsers.');
        }

        didWarnAboutGenerators = true;
      } // Warn about using Maps as children


      if (newChildrenIterable.entries === iteratorFn) {
        if (!didWarnAboutMaps) {
          error('Using Maps as children is not supported. ' + 'Use an array of keyed ReactElements instead.');
        }

        didWarnAboutMaps = true;
      } // First, validate keys.
      // We'll get a different iterator later for the main pass.


      var _newChildren = iteratorFn.call(newChildrenIterable);

      if (_newChildren) {
        var knownKeys = null;

        var _step = _newChildren.next();

        for (; !_step.done; _step = _newChildren.next()) {
          var child = _step.value;
          knownKeys = warnOnInvalidKey(child, knownKeys, returnFiber);
        }
      }
    }

    var newChildren = iteratorFn.call(newChildrenIterable);

    if (!(newChildren != null)) {
      {
        throw Error( "An iterable object provided no iterator." );
      }
    }

    var resultingFirstChild = null;
    var previousNewFiber = null;
    var oldFiber = currentFirstChild;
    var lastPlacedIndex = 0;
    var newIdx = 0;
    var nextOldFiber = null;
    var step = newChildren.next();

    for (; oldFiber !== null && !step.done; newIdx++, step = newChildren.next()) {
      if (oldFiber.index > newIdx) {
        nextOldFiber = oldFiber;
        oldFiber = null;
      } else {
        nextOldFiber = oldFiber.sibling;
      }

      var newFiber = updateSlot(returnFiber, oldFiber, step.value, lanes);

      if (newFiber === null) {
        // TODO: This breaks on empty slots like null children. That's
        // unfortunate because it triggers the slow path all the time. We need
        // a better way to communicate whether this was a miss or null,
        // boolean, undefined, etc.
        if (oldFiber === null) {
          oldFiber = nextOldFiber;
        }

        break;
      }

      if (shouldTrackSideEffects) {
        if (oldFiber && newFiber.alternate === null) {
          // We matched the slot, but we didn't reuse the existing fiber, so we
          // need to delete the existing child.
          deleteChild(returnFiber, oldFiber);
        }
      }

      lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);

      if (previousNewFiber === null) {
        // TODO: Move out of the loop. This only happens for the first run.
        resultingFirstChild = newFiber;
      } else {
        // TODO: Defer siblings if we're not at the right index for this slot.
        // I.e. if we had null values before, then we want to defer this
        // for each null value. However, we also don't want to call updateSlot
        // with the previous one.
        previousNewFiber.sibling = newFiber;
      }

      previousNewFiber = newFiber;
      oldFiber = nextOldFiber;
    }

    if (step.done) {
      // We've reached the end of the new children. We can delete the rest.
      deleteRemainingChildren(returnFiber, oldFiber);
      return resultingFirstChild;
    }

    if (oldFiber === null) {
      // If we don't have any more existing children we can choose a fast path
      // since the rest will all be insertions.
      for (; !step.done; newIdx++, step = newChildren.next()) {
        var _newFiber3 = createChild(returnFiber, step.value, lanes);

        if (_newFiber3 === null) {
          continue;
        }

        lastPlacedIndex = placeChild(_newFiber3, lastPlacedIndex, newIdx);

        if (previousNewFiber === null) {
          // TODO: Move out of the loop. This only happens for the first run.
          resultingFirstChild = _newFiber3;
        } else {
          previousNewFiber.sibling = _newFiber3;
        }

        previousNewFiber = _newFiber3;
      }

      return resultingFirstChild;
    } // Add all children to a key map for quick lookups.


    var existingChildren = mapRemainingChildren(returnFiber, oldFiber); // Keep scanning and use the map to restore deleted items as moves.

    for (; !step.done; newIdx++, step = newChildren.next()) {
      var _newFiber4 = updateFromMap(existingChildren, returnFiber, newIdx, step.value, lanes);

      if (_newFiber4 !== null) {
        if (shouldTrackSideEffects) {
          if (_newFiber4.alternate !== null) {
            // The new fiber is a work in progress, but if there exists a
            // current, that means that we reused the fiber. We need to delete
            // it from the child list so that we don't add it to the deletion
            // list.
            existingChildren.delete(_newFiber4.key === null ? newIdx : _newFiber4.key);
          }
        }

        lastPlacedIndex = placeChild(_newFiber4, lastPlacedIndex, newIdx);

        if (previousNewFiber === null) {
          resultingFirstChild = _newFiber4;
        } else {
          previousNewFiber.sibling = _newFiber4;
        }

        previousNewFiber = _newFiber4;
      }
    }

    if (shouldTrackSideEffects) {
      // Any existing children that weren't consumed above were deleted. We need
      // to add them to the deletion list.
      existingChildren.forEach(function (child) {
        return deleteChild(returnFiber, child);
      });
    }

    return resultingFirstChild;
  }

  function reconcileSingleTextNode(returnFiber, currentFirstChild, textContent, lanes) {
    // There's no need to check for keys on text nodes since we don't have a
    // way to define them.
    if (currentFirstChild !== null && currentFirstChild.tag === HostText) {
      // We already have an existing node so let's just update it and delete
      // the rest.
      deleteRemainingChildren(returnFiber, currentFirstChild.sibling);
      var existing = useFiber(currentFirstChild, textContent);
      existing.return = returnFiber;
      return existing;
    } // The existing first child is not a text node so we need to create one
    // and delete the existing ones.


    deleteRemainingChildren(returnFiber, currentFirstChild);
    var created = createFiberFromText(textContent, returnFiber.mode, lanes);
    created.return = returnFiber;
    return created;
  }

  function reconcileSingleElement(returnFiber, currentFirstChild, element, lanes) {
    var key = element.key;
    var child = currentFirstChild;

    while (child !== null) {
      // TODO: If key === null and child.key === null, then this only applies to
      // the first item in the list.
      if (child.key === key) {
        switch (child.tag) {
          case Fragment:
            {
              if (element.type === REACT_FRAGMENT_TYPE) {
                deleteRemainingChildren(returnFiber, child.sibling);
                var existing = useFiber(child, element.props.children);
                existing.return = returnFiber;

                {
                  existing._debugSource = element._source;
                  existing._debugOwner = element._owner;
                }

                return existing;
              }

              break;
            }

          case Block:

          // We intentionally fallthrough here if enableBlocksAPI is not on.
          // eslint-disable-next-lined no-fallthrough

          default:
            {
              if (child.elementType === element.type || ( // Keep this check inline so it only runs on the false path:
               isCompatibleFamilyForHotReloading(child, element) )) {
                deleteRemainingChildren(returnFiber, child.sibling);

                var _existing3 = useFiber(child, element.props);

                _existing3.ref = coerceRef(returnFiber, child, element);
                _existing3.return = returnFiber;

                {
                  _existing3._debugSource = element._source;
                  _existing3._debugOwner = element._owner;
                }

                return _existing3;
              }

              break;
            }
        } // Didn't match.


        deleteRemainingChildren(returnFiber, child);
        break;
      } else {
        deleteChild(returnFiber, child);
      }

      child = child.sibling;
    }

    if (element.type === REACT_FRAGMENT_TYPE) {
      var created = createFiberFromFragment(element.props.children, returnFiber.mode, lanes, element.key);
      created.return = returnFiber;
      return created;
    } else {
      var _created4 = createFiberFromElement(element, returnFiber.mode, lanes);

      _created4.ref = coerceRef(returnFiber, currentFirstChild, element);
      _created4.return = returnFiber;
      return _created4;
    }
  }

  function reconcileSinglePortal(returnFiber, currentFirstChild, portal, lanes) {
    var key = portal.key;
    var child = currentFirstChild;

    while (child !== null) {
      // TODO: If key === null and child.key === null, then this only applies to
      // the first item in the list.
      if (child.key === key) {
        if (child.tag === HostPortal && child.stateNode.containerInfo === portal.containerInfo && child.stateNode.implementation === portal.implementation) {
          deleteRemainingChildren(returnFiber, child.sibling);
          var existing = useFiber(child, portal.children || []);
          existing.return = returnFiber;
          return existing;
        } else {
          deleteRemainingChildren(returnFiber, child);
          break;
        }
      } else {
        deleteChild(returnFiber, child);
      }

      child = child.sibling;
    }

    var created = createFiberFromPortal(portal, returnFiber.mode, lanes);
    created.return = returnFiber;
    return created;
  } // This API will tag the children with the side-effect of the reconciliation
  // itself. They will be added to the side-effect list as we pass through the
  // children and the parent.


  function reconcileChildFibers(returnFiber, currentFirstChild, newChild, lanes) {
    // This function is not recursive.
    // If the top level item is an array, we treat it as a set of children,
    // not as a fragment. Nested arrays on the other hand will be treated as
    // fragment nodes. Recursion happens at the normal flow.
    // Handle top level unkeyed fragments as if they were arrays.
    // This leads to an ambiguity between <>{[...]}</> and <>...</>.
    // We treat the ambiguous cases above the same.
    var isUnkeyedTopLevelFragment = typeof newChild === 'object' && newChild !== null && newChild.type === REACT_FRAGMENT_TYPE && newChild.key === null;

    if (isUnkeyedTopLevelFragment) {
      newChild = newChild.props.children;
    } // Handle object types


    var isObject = typeof newChild === 'object' && newChild !== null;

    if (isObject) {
      switch (newChild.$$typeof) {
        case REACT_ELEMENT_TYPE:
          return placeSingleChild(reconcileSingleElement(returnFiber, currentFirstChild, newChild, lanes));

        case REACT_PORTAL_TYPE:
          return placeSingleChild(reconcileSinglePortal(returnFiber, currentFirstChild, newChild, lanes));

      }
    }

    if (typeof newChild === 'string' || typeof newChild === 'number') {
      return placeSingleChild(reconcileSingleTextNode(returnFiber, currentFirstChild, '' + newChild, lanes));
    }

    if (isArray$1(newChild)) {
      return reconcileChildrenArray(returnFiber, currentFirstChild, newChild, lanes);
    }

    if (getIteratorFn(newChild)) {
      return reconcileChildrenIterator(returnFiber, currentFirstChild, newChild, lanes);
    }

    if (isObject) {
      throwOnInvalidObjectType(returnFiber, newChild);
    }

    {
      if (typeof newChild === 'function') {
        warnOnFunctionType(returnFiber);
      }
    }

    if (typeof newChild === 'undefined' && !isUnkeyedTopLevelFragment) {
      // If the new child is undefined, and the return fiber is a composite
      // component, throw an error. If Fiber return types are disabled,
      // we already threw above.
      switch (returnFiber.tag) {
        case ClassComponent:
          {
            {
              var instance = returnFiber.stateNode;

              if (instance.render._isMockFunction) {
                // We allow auto-mocks to proceed as if they're returning null.
                break;
              }
            }
          }
        // Intentionally fall through to the next case, which handles both
        // functions and classes
        // eslint-disable-next-lined no-fallthrough

        case Block:
        case FunctionComponent:
        case ForwardRef:
        case SimpleMemoComponent:
          {
            {
              {
                throw Error( (getComponentName(returnFiber.type) || 'Component') + "(...): Nothing was returned from render. This usually means a return statement is missing. Or, to render nothing, return null." );
              }
            }
          }
      }
    } // Remaining cases are all treated as empty.


    return deleteRemainingChildren(returnFiber, currentFirstChild);
  }

  return reconcileChildFibers;
}

var reconcileChildFibers = ChildReconciler(true);
var mountChildFibers = ChildReconciler(false);
function cloneChildFibers(current, workInProgress) {
  if (!(current === null || workInProgress.child === current.child)) {
    {
      throw Error( "Resuming work not yet implemented." );
    }
  }

  if (workInProgress.child === null) {
    return;
  }

  var currentChild = workInProgress.child;
  var newChild = createWorkInProgress(currentChild, currentChild.pendingProps);
  workInProgress.child = newChild;
  newChild.return = workInProgress;

  while (currentChild.sibling !== null) {
    currentChild = currentChild.sibling;
    newChild = newChild.sibling = createWorkInProgress(currentChild, currentChild.pendingProps);
    newChild.return = workInProgress;
  }

  newChild.sibling = null;
} // Reset a workInProgress child set to prepare it for a second pass.

function resetChildFibers(workInProgress, lanes) {
  var child = workInProgress.child;

  while (child !== null) {
    resetWorkInProgress(child, lanes);
    child = child.sibling;
  }
}

var NO_CONTEXT = {};
var contextStackCursor$1 = createCursor(NO_CONTEXT);
var contextFiberStackCursor = createCursor(NO_CONTEXT);
var rootInstanceStackCursor = createCursor(NO_CONTEXT);

function requiredContext(c) {
  if (!(c !== NO_CONTEXT)) {
    {
      throw Error( "Expected host context to exist. This error is likely caused by a bug in React. Please file an issue." );
    }
  }

  return c;
}

function getRootHostContainer() {
  var rootInstance = requiredContext(rootInstanceStackCursor.current);
  return rootInstance;
}

function pushHostContainer(fiber, nextRootInstance) {
  // Push current root instance onto the stack;
  // This allows us to reset root when portals are popped.
  push(rootInstanceStackCursor, nextRootInstance, fiber); // Track the context and the Fiber that provided it.
  // This enables us to pop only Fibers that provide unique contexts.

  push(contextFiberStackCursor, fiber, fiber); // Finally, we need to push the host context to the stack.
  // However, we can't just call getRootHostContext() and push it because
  // we'd have a different number of entries on the stack depending on
  // whether getRootHostContext() throws somewhere in renderer code or not.
  // So we push an empty value first. This lets us safely unwind on errors.

  push(contextStackCursor$1, NO_CONTEXT, fiber);
  var nextRootContext = getRootHostContext(nextRootInstance); // Now that we know this function doesn't throw, replace it.

  pop(contextStackCursor$1, fiber);
  push(contextStackCursor$1, nextRootContext, fiber);
}

function popHostContainer(fiber) {
  pop(contextStackCursor$1, fiber);
  pop(contextFiberStackCursor, fiber);
  pop(rootInstanceStackCursor, fiber);
}

function getHostContext() {
  var context = requiredContext(contextStackCursor$1.current);
  return context;
}

function pushHostContext(fiber) {
  var rootInstance = requiredContext(rootInstanceStackCursor.current);
  var context = requiredContext(contextStackCursor$1.current);
  var nextContext = getChildHostContext(context, fiber.type); // Don't push this Fiber's context unless it's unique.

  if (context === nextContext) {
    return;
  } // Track the context and the Fiber that provided it.
  // This enables us to pop only Fibers that provide unique contexts.


  push(contextFiberStackCursor, fiber, fiber);
  push(contextStackCursor$1, nextContext, fiber);
}

function popHostContext(fiber) {
  // Do not pop unless this Fiber provided the current context.
  // pushHostContext() only pushes Fibers that provide unique contexts.
  if (contextFiberStackCursor.current !== fiber) {
    return;
  }

  pop(contextStackCursor$1, fiber);
  pop(contextFiberStackCursor, fiber);
}

var DefaultSuspenseContext = 0; // The Suspense Context is split into two parts. The lower bits is
// inherited deeply down the subtree. The upper bits only affect
// this immediate suspense boundary and gets reset each new
// boundary or suspense list.

var SubtreeSuspenseContextMask = 1; // Subtree Flags:
// InvisibleParentSuspenseContext indicates that one of our parent Suspense
// boundaries is not currently showing visible main content.
// Either because it is already showing a fallback or is not mounted at all.
// We can use this to determine if it is desirable to trigger a fallback at
// the parent. If not, then we might need to trigger undesirable boundaries
// and/or suspend the commit to avoid hiding the parent content.

var InvisibleParentSuspenseContext = 1; // Shallow Flags:
// ForceSuspenseFallback can be used by SuspenseList to force newly added
// items into their fallback state during one of the render passes.

var ForceSuspenseFallback = 2;
var suspenseStackCursor = createCursor(DefaultSuspenseContext);
function hasSuspenseContext(parentContext, flag) {
  return (parentContext & flag) !== 0;
}
function setDefaultShallowSuspenseContext(parentContext) {
  return parentContext & SubtreeSuspenseContextMask;
}
function setShallowSuspenseContext(parentContext, shallowContext) {
  return parentContext & SubtreeSuspenseContextMask | shallowContext;
}
function addSubtreeSuspenseContext(parentContext, subtreeContext) {
  return parentContext | subtreeContext;
}
function pushSuspenseContext(fiber, newContext) {
  push(suspenseStackCursor, newContext, fiber);
}
function popSuspenseContext(fiber) {
  pop(suspenseStackCursor, fiber);
}

function shouldCaptureSuspense(workInProgress, hasInvisibleParent) {
  // If it was the primary children that just suspended, capture and render the
  // fallback. Otherwise, don't capture and bubble to the next boundary.
  var nextState = workInProgress.memoizedState;

  if (nextState !== null) {
    if (nextState.dehydrated !== null) {
      // A dehydrated boundary always captures.
      return true;
    }

    return false;
  }

  var props = workInProgress.memoizedProps; // In order to capture, the Suspense component must have a fallback prop.

  if (props.fallback === undefined) {
    return false;
  } // Regular boundaries always capture.


  if (props.unstable_avoidThisFallback !== true) {
    return true;
  } // If it's a boundary we should avoid, then we prefer to bubble up to the
  // parent boundary if it is currently invisible.


  if (hasInvisibleParent) {
    return false;
  } // If the parent is not able to handle it, we must handle it.


  return true;
}
function findFirstSuspended(row) {
  var node = row;

  while (node !== null) {
    if (node.tag === SuspenseComponent) {
      var state = node.memoizedState;

      if (state !== null) {
        var dehydrated = state.dehydrated;

        if (dehydrated === null || isSuspenseInstancePending(dehydrated) || isSuspenseInstanceFallback(dehydrated)) {
          return node;
        }
      }
    } else if (node.tag === SuspenseListComponent && // revealOrder undefined can't be trusted because it don't
    // keep track of whether it suspended or not.
    node.memoizedProps.revealOrder !== undefined) {
      var didSuspend = (node.flags & DidCapture) !== NoFlags;

      if (didSuspend) {
        return node;
      }
    } else if (node.child !== null) {
      node.child.return = node;
      node = node.child;
      continue;
    }

    if (node === row) {
      return null;
    }

    while (node.sibling === null) {
      if (node.return === null || node.return === row) {
        return null;
      }

      node = node.return;
    }

    node.sibling.return = node.return;
    node = node.sibling;
  }

  return null;
}

var NoFlags$1 =
/*  */
0; // Represents whether effect should fire.

var HasEffect =
/* */
1; // Represents the phase in which the effect (not the clean-up) fires.

var Layout =
/*    */
2;
var Passive$1 =
/*   */
4;

// This may have been an insertion or a hydration.

var hydrationParentFiber = null;
var nextHydratableInstance = null;
var isHydrating = false;

function enterHydrationState(fiber) {

  var parentInstance = fiber.stateNode.containerInfo;
  nextHydratableInstance = getFirstHydratableChild(parentInstance);
  hydrationParentFiber = fiber;
  isHydrating = true;
  return true;
}

function deleteHydratableInstance(returnFiber, instance) {
  {
    switch (returnFiber.tag) {
      case HostRoot:
        didNotHydrateContainerInstance(returnFiber.stateNode.containerInfo, instance);
        break;

      case HostComponent:
        didNotHydrateInstance(returnFiber.type, returnFiber.memoizedProps, returnFiber.stateNode, instance);
        break;
    }
  }

  var childToDelete = createFiberFromHostInstanceForDeletion();
  childToDelete.stateNode = instance;
  childToDelete.return = returnFiber;
  childToDelete.flags = Deletion; // This might seem like it belongs on progressedFirstDeletion. However,
  // these children are not part of the reconciliation list of children.
  // Even if we abort and rereconcile the children, that will try to hydrate
  // again and the nodes are still in the host tree so these will be
  // recreated.

  if (returnFiber.lastEffect !== null) {
    returnFiber.lastEffect.nextEffect = childToDelete;
    returnFiber.lastEffect = childToDelete;
  } else {
    returnFiber.firstEffect = returnFiber.lastEffect = childToDelete;
  }
}

function insertNonHydratedInstance(returnFiber, fiber) {
  fiber.flags = fiber.flags & ~Hydrating | Placement;

  {
    switch (returnFiber.tag) {
      case HostRoot:
        {
          var parentContainer = returnFiber.stateNode.containerInfo;

          switch (fiber.tag) {
            case HostComponent:
              var type = fiber.type;
              var props = fiber.pendingProps;
              didNotFindHydratableContainerInstance(parentContainer, type);
              break;

            case HostText:
              var text = fiber.pendingProps;
              didNotFindHydratableContainerTextInstance(parentContainer, text);
              break;
          }

          break;
        }

      case HostComponent:
        {
          var parentType = returnFiber.type;
          var parentProps = returnFiber.memoizedProps;
          var parentInstance = returnFiber.stateNode;

          switch (fiber.tag) {
            case HostComponent:
              var _type = fiber.type;
              var _props = fiber.pendingProps;
              didNotFindHydratableInstance(parentType, parentProps, parentInstance, _type);
              break;

            case HostText:
              var _text = fiber.pendingProps;
              didNotFindHydratableTextInstance(parentType, parentProps, parentInstance, _text);
              break;

            case SuspenseComponent:
              didNotFindHydratableSuspenseInstance(parentType, parentProps);
              break;
          }

          break;
        }

      default:
        return;
    }
  }
}

function tryHydrate(fiber, nextInstance) {
  switch (fiber.tag) {
    case HostComponent:
      {
        var type = fiber.type;
        var props = fiber.pendingProps;
        var instance = canHydrateInstance(nextInstance, type);

        if (instance !== null) {
          fiber.stateNode = instance;
          return true;
        }

        return false;
      }

    case HostText:
      {
        var text = fiber.pendingProps;
        var textInstance = canHydrateTextInstance(nextInstance, text);

        if (textInstance !== null) {
          fiber.stateNode = textInstance;
          return true;
        }

        return false;
      }

    case SuspenseComponent:
      {

        return false;
      }

    default:
      return false;
  }
}

function tryToClaimNextHydratableInstance(fiber) {
  if (!isHydrating) {
    return;
  }

  var nextInstance = nextHydratableInstance;

  if (!nextInstance) {
    // Nothing to hydrate. Make it an insertion.
    insertNonHydratedInstance(hydrationParentFiber, fiber);
    isHydrating = false;
    hydrationParentFiber = fiber;
    return;
  }

  var firstAttemptedInstance = nextInstance;

  if (!tryHydrate(fiber, nextInstance)) {
    // If we can't hydrate this instance let's try the next one.
    // We use this as a heuristic. It's based on intuition and not data so it
    // might be flawed or unnecessary.
    nextInstance = getNextHydratableSibling(firstAttemptedInstance);

    if (!nextInstance || !tryHydrate(fiber, nextInstance)) {
      // Nothing to hydrate. Make it an insertion.
      insertNonHydratedInstance(hydrationParentFiber, fiber);
      isHydrating = false;
      hydrationParentFiber = fiber;
      return;
    } // We matched the next one, we'll now assume that the first one was
    // superfluous and we'll delete it. Since we can't eagerly delete it
    // we'll have to schedule a deletion. To do that, this node needs a dummy
    // fiber associated with it.


    deleteHydratableInstance(hydrationParentFiber, firstAttemptedInstance);
  }

  hydrationParentFiber = fiber;
  nextHydratableInstance = getFirstHydratableChild(nextInstance);
}

function prepareToHydrateHostInstance(fiber, rootContainerInstance, hostContext) {

  var instance = fiber.stateNode;
  var updatePayload = hydrateInstance(instance, fiber.type, fiber.memoizedProps, rootContainerInstance, hostContext, fiber); // TODO: Type this specific to this type of component.

  fiber.updateQueue = updatePayload; // If the update payload indicates that there is a change or if there
  // is a new ref we mark this as an update.

  if (updatePayload !== null) {
    return true;
  }

  return false;
}

function prepareToHydrateHostTextInstance(fiber) {

  var textInstance = fiber.stateNode;
  var textContent = fiber.memoizedProps;
  var shouldUpdate = hydrateTextInstance(textInstance, textContent, fiber);

  {
    if (shouldUpdate) {
      // We assume that prepareToHydrateHostTextInstance is called in a context where the
      // hydration parent is the parent host component of this host text.
      var returnFiber = hydrationParentFiber;

      if (returnFiber !== null) {
        switch (returnFiber.tag) {
          case HostRoot:
            {
              var parentContainer = returnFiber.stateNode.containerInfo;
              didNotMatchHydratedContainerTextInstance(parentContainer, textInstance, textContent);
              break;
            }

          case HostComponent:
            {
              var parentType = returnFiber.type;
              var parentProps = returnFiber.memoizedProps;
              var parentInstance = returnFiber.stateNode;
              didNotMatchHydratedTextInstance(parentType, parentProps, parentInstance, textInstance, textContent);
              break;
            }
        }
      }
    }
  }

  return shouldUpdate;
}

function skipPastDehydratedSuspenseInstance(fiber) {

  var suspenseState = fiber.memoizedState;
  var suspenseInstance = suspenseState !== null ? suspenseState.dehydrated : null;

  if (!suspenseInstance) {
    {
      throw Error( "Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue." );
    }
  }

  return getNextHydratableInstanceAfterSuspenseInstance(suspenseInstance);
}

function popToNextHostParent(fiber) {
  var parent = fiber.return;

  while (parent !== null && parent.tag !== HostComponent && parent.tag !== HostRoot && parent.tag !== SuspenseComponent) {
    parent = parent.return;
  }

  hydrationParentFiber = parent;
}

function popHydrationState(fiber) {

  if (fiber !== hydrationParentFiber) {
    // We're deeper than the current hydration context, inside an inserted
    // tree.
    return false;
  }

  if (!isHydrating) {
    // If we're not currently hydrating but we're in a hydration context, then
    // we were an insertion and now need to pop up reenter hydration of our
    // siblings.
    popToNextHostParent(fiber);
    isHydrating = true;
    return false;
  }

  var type = fiber.type; // If we have any remaining hydratable nodes, we need to delete them now.
  // We only do this deeper than head and body since they tend to have random
  // other nodes in them. We also ignore components with pure text content in
  // side of them.
  // TODO: Better heuristic.

  if (fiber.tag !== HostComponent || type !== 'head' && type !== 'body' && !shouldSetTextContent(type, fiber.memoizedProps)) {
    var nextInstance = nextHydratableInstance;

    while (nextInstance) {
      deleteHydratableInstance(fiber, nextInstance);
      nextInstance = getNextHydratableSibling(nextInstance);
    }
  }

  popToNextHostParent(fiber);

  if (fiber.tag === SuspenseComponent) {
    nextHydratableInstance = skipPastDehydratedSuspenseInstance(fiber);
  } else {
    nextHydratableInstance = hydrationParentFiber ? getNextHydratableSibling(fiber.stateNode) : null;
  }

  return true;
}

function resetHydrationState() {

  hydrationParentFiber = null;
  nextHydratableInstance = null;
  isHydrating = false;
}

function getIsHydrating() {
  return isHydrating;
}

// and should be reset before starting a new render.
// This tracks which mutable sources need to be reset after a render.

var workInProgressSources = [];
var rendererSigil$1;

{
  // Used to detect multiple renderers using the same mutable source.
  rendererSigil$1 = {};
}

function markSourceAsDirty(mutableSource) {
  workInProgressSources.push(mutableSource);
}
function resetWorkInProgressVersions() {
  for (var i = 0; i < workInProgressSources.length; i++) {
    var mutableSource = workInProgressSources[i];

    {
      mutableSource._workInProgressVersionPrimary = null;
    }
  }

  workInProgressSources.length = 0;
}
function getWorkInProgressVersion(mutableSource) {
  {
    return mutableSource._workInProgressVersionPrimary;
  }
}
function setWorkInProgressVersion(mutableSource, version) {
  {
    mutableSource._workInProgressVersionPrimary = version;
  }

  workInProgressSources.push(mutableSource);
}
function warnAboutMultipleRenderersDEV(mutableSource) {
  {
    {
      if (mutableSource._currentPrimaryRenderer == null) {
        mutableSource._currentPrimaryRenderer = rendererSigil$1;
      } else if (mutableSource._currentPrimaryRenderer !== rendererSigil$1) {
        error('Detected multiple renderers concurrently rendering the ' + 'same mutable source. This is currently unsupported.');
      }
    }
  }
} // Eager reads the version of a mutable source and stores it on the root.

var ReactCurrentDispatcher$1 = ReactSharedInternals.ReactCurrentDispatcher,
    ReactCurrentBatchConfig$1 = ReactSharedInternals.ReactCurrentBatchConfig;
var didWarnAboutMismatchedHooksForComponent;
var didWarnAboutUseOpaqueIdentifier;

{
  didWarnAboutUseOpaqueIdentifier = {};
  didWarnAboutMismatchedHooksForComponent = new Set();
}

// These are set right before calling the component.
var renderLanes = NoLanes; // The work-in-progress fiber. I've named it differently to distinguish it from
// the work-in-progress hook.

var currentlyRenderingFiber$1 = null; // Hooks are stored as a linked list on the fiber's memoizedState field. The
// current hook list is the list that belongs to the current fiber. The
// work-in-progress hook list is a new list that will be added to the
// work-in-progress fiber.

var currentHook = null;
var workInProgressHook = null; // Whether an update was scheduled at any point during the render phase. This
// does not get reset if we do another render pass; only when we're completely
// finished evaluating this component. This is an optimization so we know
// whether we need to clear render phase updates after a throw.

var didScheduleRenderPhaseUpdate = false; // Where an update was scheduled only during the current render pass. This
// gets reset after each attempt.
// TODO: Maybe there's some way to consolidate this with
// `didScheduleRenderPhaseUpdate`. Or with `numberOfReRenders`.

var didScheduleRenderPhaseUpdateDuringThisPass = false;
var RE_RENDER_LIMIT = 25; // In DEV, this is the name of the currently executing primitive hook

var currentHookNameInDev = null; // In DEV, this list ensures that hooks are called in the same order between renders.
// The list stores the order of hooks used during the initial render (mount).
// Subsequent renders (updates) reference this list.

var hookTypesDev = null;
var hookTypesUpdateIndexDev = -1; // In DEV, this tracks whether currently rendering component needs to ignore
// the dependencies for Hooks that need them (e.g. useEffect or useMemo).
// When true, such Hooks will always be "remounted". Only used during hot reload.

var ignorePreviousDependencies = false;

function mountHookTypesDev() {
  {
    var hookName = currentHookNameInDev;

    if (hookTypesDev === null) {
      hookTypesDev = [hookName];
    } else {
      hookTypesDev.push(hookName);
    }
  }
}

function updateHookTypesDev() {
  {
    var hookName = currentHookNameInDev;

    if (hookTypesDev !== null) {
      hookTypesUpdateIndexDev++;

      if (hookTypesDev[hookTypesUpdateIndexDev] !== hookName) {
        warnOnHookMismatchInDev(hookName);
      }
    }
  }
}

function checkDepsAreArrayDev(deps) {
  {
    if (deps !== undefined && deps !== null && !Array.isArray(deps)) {
      // Verify deps, but only on mount to avoid extra checks.
      // It's unlikely their type would change as usually you define them inline.
      error('%s received a final argument that is not an array (instead, received `%s`). When ' + 'specified, the final argument must be an array.', currentHookNameInDev, typeof deps);
    }
  }
}

function warnOnHookMismatchInDev(currentHookName) {
  {
    var componentName = getComponentName(currentlyRenderingFiber$1.type);

    if (!didWarnAboutMismatchedHooksForComponent.has(componentName)) {
      didWarnAboutMismatchedHooksForComponent.add(componentName);

      if (hookTypesDev !== null) {
        var table = '';
        var secondColumnStart = 30;

        for (var i = 0; i <= hookTypesUpdateIndexDev; i++) {
          var oldHookName = hookTypesDev[i];
          var newHookName = i === hookTypesUpdateIndexDev ? currentHookName : oldHookName;
          var row = i + 1 + ". " + oldHookName; // Extra space so second column lines up
          // lol @ IE not supporting String#repeat

          while (row.length < secondColumnStart) {
            row += ' ';
          }

          row += newHookName + '\n';
          table += row;
        }

        error('React has detected a change in the order of Hooks called by %s. ' + 'This will lead to bugs and errors if not fixed. ' + 'For more information, read the Rules of Hooks: https://reactjs.org/link/rules-of-hooks\n\n' + '   Previous render            Next render\n' + '   ------------------------------------------------------\n' + '%s' + '   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n', componentName, table);
      }
    }
  }
}

function throwInvalidHookError() {
  {
    {
      throw Error( "Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem." );
    }
  }
}

function areHookInputsEqual(nextDeps, prevDeps) {
  {
    if (ignorePreviousDependencies) {
      // Only true when this component is being hot reloaded.
      return false;
    }
  }

  if (prevDeps === null) {
    {
      error('%s received a final argument during this render, but not during ' + 'the previous render. Even though the final argument is optional, ' + 'its type cannot change between renders.', currentHookNameInDev);
    }

    return false;
  }

  {
    // Don't bother comparing lengths in prod because these arrays should be
    // passed inline.
    if (nextDeps.length !== prevDeps.length) {
      error('The final argument passed to %s changed size between renders. The ' + 'order and size of this array must remain constant.\n\n' + 'Previous: %s\n' + 'Incoming: %s', currentHookNameInDev, "[" + prevDeps.join(', ') + "]", "[" + nextDeps.join(', ') + "]");
    }
  }

  for (var i = 0; i < prevDeps.length && i < nextDeps.length; i++) {
    if (objectIs(nextDeps[i], prevDeps[i])) {
      continue;
    }

    return false;
  }

  return true;
}

function renderWithHooks(current, workInProgress, Component, props, secondArg, nextRenderLanes) {
  renderLanes = nextRenderLanes;
  currentlyRenderingFiber$1 = workInProgress;

  {
    hookTypesDev = current !== null ? current._debugHookTypes : null;
    hookTypesUpdateIndexDev = -1; // Used for hot reloading:

    ignorePreviousDependencies = current !== null && current.type !== workInProgress.type;
  }

  workInProgress.memoizedState = null;
  workInProgress.updateQueue = null;
  workInProgress.lanes = NoLanes; // The following should have already been reset
  // currentHook = null;
  // workInProgressHook = null;
  // didScheduleRenderPhaseUpdate = false;
  // TODO Warn if no hooks are used at all during mount, then some are used during update.
  // Currently we will identify the update render as a mount because memoizedState === null.
  // This is tricky because it's valid for certain types of components (e.g. React.lazy)
  // Using memoizedState to differentiate between mount/update only works if at least one stateful hook is used.
  // Non-stateful hooks (e.g. context) don't get added to memoizedState,
  // so memoizedState would be null during updates and mounts.

  {
    if (current !== null && current.memoizedState !== null) {
      ReactCurrentDispatcher$1.current = HooksDispatcherOnUpdateInDEV;
    } else if (hookTypesDev !== null) {
      // This dispatcher handles an edge case where a component is updating,
      // but no stateful hooks have been used.
      // We want to match the production code behavior (which will use HooksDispatcherOnMount),
      // but with the extra DEV validation to ensure hooks ordering hasn't changed.
      // This dispatcher does that.
      ReactCurrentDispatcher$1.current = HooksDispatcherOnMountWithHookTypesInDEV;
    } else {
      ReactCurrentDispatcher$1.current = HooksDispatcherOnMountInDEV;
    }
  }

  var children = Component(props, secondArg); // Check if there was a render phase update

  if (didScheduleRenderPhaseUpdateDuringThisPass) {
    // Keep rendering in a loop for as long as render phase updates continue to
    // be scheduled. Use a counter to prevent infinite loops.
    var numberOfReRenders = 0;

    do {
      didScheduleRenderPhaseUpdateDuringThisPass = false;

      if (!(numberOfReRenders < RE_RENDER_LIMIT)) {
        {
          throw Error( "Too many re-renders. React limits the number of renders to prevent an infinite loop." );
        }
      }

      numberOfReRenders += 1;

      {
        // Even when hot reloading, allow dependencies to stabilize
        // after first render to prevent infinite render phase updates.
        ignorePreviousDependencies = false;
      } // Start over from the beginning of the list


      currentHook = null;
      workInProgressHook = null;
      workInProgress.updateQueue = null;

      {
        // Also validate hook order for cascading updates.
        hookTypesUpdateIndexDev = -1;
      }

      ReactCurrentDispatcher$1.current =  HooksDispatcherOnRerenderInDEV ;
      children = Component(props, secondArg);
    } while (didScheduleRenderPhaseUpdateDuringThisPass);
  } // We can assume the previous dispatcher is always this one, since we set it
  // at the beginning of the render phase and there's no re-entrancy.


  ReactCurrentDispatcher$1.current = ContextOnlyDispatcher;

  {
    workInProgress._debugHookTypes = hookTypesDev;
  } // This check uses currentHook so that it works the same in DEV and prod bundles.
  // hookTypesDev could catch more cases (e.g. context) but only in DEV bundles.


  var didRenderTooFewHooks = currentHook !== null && currentHook.next !== null;
  renderLanes = NoLanes;
  currentlyRenderingFiber$1 = null;
  currentHook = null;
  workInProgressHook = null;

  {
    currentHookNameInDev = null;
    hookTypesDev = null;
    hookTypesUpdateIndexDev = -1;
  }

  didScheduleRenderPhaseUpdate = false;

  if (!!didRenderTooFewHooks) {
    {
      throw Error( "Rendered fewer hooks than expected. This may be caused by an accidental early return statement." );
    }
  }

  return children;
}
function bailoutHooks(current, workInProgress, lanes) {
  workInProgress.updateQueue = current.updateQueue;
  workInProgress.flags &= ~(Passive | Update);
  current.lanes = removeLanes(current.lanes, lanes);
}
function resetHooksAfterThrow() {
  // We can assume the previous dispatcher is always this one, since we set it
  // at the beginning of the render phase and there's no re-entrancy.
  ReactCurrentDispatcher$1.current = ContextOnlyDispatcher;

  if (didScheduleRenderPhaseUpdate) {
    // There were render phase updates. These are only valid for this render
    // phase, which we are now aborting. Remove the updates from the queues so
    // they do not persist to the next render. Do not remove updates from hooks
    // that weren't processed.
    //
    // Only reset the updates from the queue if it has a clone. If it does
    // not have a clone, that means it wasn't processed, and the updates were
    // scheduled before we entered the render phase.
    var hook = currentlyRenderingFiber$1.memoizedState;

    while (hook !== null) {
      var queue = hook.queue;

      if (queue !== null) {
        queue.pending = null;
      }

      hook = hook.next;
    }

    didScheduleRenderPhaseUpdate = false;
  }

  renderLanes = NoLanes;
  currentlyRenderingFiber$1 = null;
  currentHook = null;
  workInProgressHook = null;

  {
    hookTypesDev = null;
    hookTypesUpdateIndexDev = -1;
    currentHookNameInDev = null;
    isUpdatingOpaqueValueInRenderPhase = false;
  }

  didScheduleRenderPhaseUpdateDuringThisPass = false;
}

function mountWorkInProgressHook() {
  var hook = {
    memoizedState: null,
    baseState: null,
    baseQueue: null,
    queue: null,
    next: null
  };

  if (workInProgressHook === null) {
    // This is the first hook in the list
    currentlyRenderingFiber$1.memoizedState = workInProgressHook = hook;
  } else {
    // Append to the end of the list
    workInProgressHook = workInProgressHook.next = hook;
  }

  return workInProgressHook;
}

function updateWorkInProgressHook() {
  // This function is used both for updates and for re-renders triggered by a
  // render phase update. It assumes there is either a current hook we can
  // clone, or a work-in-progress hook from a previous render pass that we can
  // use as a base. When we reach the end of the base list, we must switch to
  // the dispatcher used for mounts.
  var nextCurrentHook;

  if (currentHook === null) {
    var current = currentlyRenderingFiber$1.alternate;

    if (current !== null) {
      nextCurrentHook = current.memoizedState;
    } else {
      nextCurrentHook = null;
    }
  } else {
    nextCurrentHook = currentHook.next;
  }

  var nextWorkInProgressHook;

  if (workInProgressHook === null) {
    nextWorkInProgressHook = currentlyRenderingFiber$1.memoizedState;
  } else {
    nextWorkInProgressHook = workInProgressHook.next;
  }

  if (nextWorkInProgressHook !== null) {
    // There's already a work-in-progress. Reuse it.
    workInProgressHook = nextWorkInProgressHook;
    nextWorkInProgressHook = workInProgressHook.next;
    currentHook = nextCurrentHook;
  } else {
    // Clone from the current hook.
    if (!(nextCurrentHook !== null)) {
      {
        throw Error( "Rendered more hooks than during the previous render." );
      }
    }

    currentHook = nextCurrentHook;
    var newHook = {
      memoizedState: currentHook.memoizedState,
      baseState: currentHook.baseState,
      baseQueue: currentHook.baseQueue,
      queue: currentHook.queue,
      next: null
    };

    if (workInProgressHook === null) {
      // This is the first hook in the list.
      currentlyRenderingFiber$1.memoizedState = workInProgressHook = newHook;
    } else {
      // Append to the end of the list.
      workInProgressHook = workInProgressHook.next = newHook;
    }
  }

  return workInProgressHook;
}

function createFunctionComponentUpdateQueue() {
  return {
    lastEffect: null
  };
}

function basicStateReducer(state, action) {
  // $FlowFixMe: Flow doesn't like mixed types
  return typeof action === 'function' ? action(state) : action;
}

function mountReducer(reducer, initialArg, init) {
  var hook = mountWorkInProgressHook();
  var initialState;

  if (init !== undefined) {
    initialState = init(initialArg);
  } else {
    initialState = initialArg;
  }

  hook.memoizedState = hook.baseState = initialState;
  var queue = hook.queue = {
    pending: null,
    dispatch: null,
    lastRenderedReducer: reducer,
    lastRenderedState: initialState
  };
  var dispatch = queue.dispatch = dispatchAction.bind(null, currentlyRenderingFiber$1, queue);
  return [hook.memoizedState, dispatch];
}

function updateReducer(reducer, initialArg, init) {
  var hook = updateWorkInProgressHook();
  var queue = hook.queue;

  if (!(queue !== null)) {
    {
      throw Error( "Should have a queue. This is likely a bug in React. Please file an issue." );
    }
  }

  queue.lastRenderedReducer = reducer;
  var current = currentHook; // The last rebase update that is NOT part of the base state.

  var baseQueue = current.baseQueue; // The last pending update that hasn't been processed yet.

  var pendingQueue = queue.pending;

  if (pendingQueue !== null) {
    // We have new updates that haven't been processed yet.
    // We'll add them to the base queue.
    if (baseQueue !== null) {
      // Merge the pending queue and the base queue.
      var baseFirst = baseQueue.next;
      var pendingFirst = pendingQueue.next;
      baseQueue.next = pendingFirst;
      pendingQueue.next = baseFirst;
    }

    {
      if (current.baseQueue !== baseQueue) {
        // Internal invariant that should never happen, but feasibly could in
        // the future if we implement resuming, or some form of that.
        error('Internal error: Expected work-in-progress queue to be a clone. ' + 'This is a bug in React.');
      }
    }

    current.baseQueue = baseQueue = pendingQueue;
    queue.pending = null;
  }

  if (baseQueue !== null) {
    // We have a queue to process.
    var first = baseQueue.next;
    var newState = current.baseState;
    var newBaseState = null;
    var newBaseQueueFirst = null;
    var newBaseQueueLast = null;
    var update = first;

    do {
      var updateLane = update.lane;

      if (!isSubsetOfLanes(renderLanes, updateLane)) {
        // Priority is insufficient. Skip this update. If this is the first
        // skipped update, the previous update/state is the new base
        // update/state.
        var clone = {
          lane: updateLane,
          action: update.action,
          eagerReducer: update.eagerReducer,
          eagerState: update.eagerState,
          next: null
        };

        if (newBaseQueueLast === null) {
          newBaseQueueFirst = newBaseQueueLast = clone;
          newBaseState = newState;
        } else {
          newBaseQueueLast = newBaseQueueLast.next = clone;
        } // Update the remaining priority in the queue.
        // TODO: Don't need to accumulate this. Instead, we can remove
        // renderLanes from the original lanes.


        currentlyRenderingFiber$1.lanes = mergeLanes(currentlyRenderingFiber$1.lanes, updateLane);
        markSkippedUpdateLanes(updateLane);
      } else {
        // This update does have sufficient priority.
        if (newBaseQueueLast !== null) {
          var _clone = {
            // This update is going to be committed so we never want uncommit
            // it. Using NoLane works because 0 is a subset of all bitmasks, so
            // this will never be skipped by the check above.
            lane: NoLane,
            action: update.action,
            eagerReducer: update.eagerReducer,
            eagerState: update.eagerState,
            next: null
          };
          newBaseQueueLast = newBaseQueueLast.next = _clone;
        } // Process this update.


        if (update.eagerReducer === reducer) {
          // If this update was processed eagerly, and its reducer matches the
          // current reducer, we can use the eagerly computed state.
          newState = update.eagerState;
        } else {
          var action = update.action;
          newState = reducer(newState, action);
        }
      }

      update = update.next;
    } while (update !== null && update !== first);

    if (newBaseQueueLast === null) {
      newBaseState = newState;
    } else {
      newBaseQueueLast.next = newBaseQueueFirst;
    } // Mark that the fiber performed work, but only if the new state is
    // different from the current state.


    if (!objectIs(newState, hook.memoizedState)) {
      markWorkInProgressReceivedUpdate();
    }

    hook.memoizedState = newState;
    hook.baseState = newBaseState;
    hook.baseQueue = newBaseQueueLast;
    queue.lastRenderedState = newState;
  }

  var dispatch = queue.dispatch;
  return [hook.memoizedState, dispatch];
}

function rerenderReducer(reducer, initialArg, init) {
  var hook = updateWorkInProgressHook();
  var queue = hook.queue;

  if (!(queue !== null)) {
    {
      throw Error( "Should have a queue. This is likely a bug in React. Please file an issue." );
    }
  }

  queue.lastRenderedReducer = reducer; // This is a re-render. Apply the new render phase updates to the previous
  // work-in-progress hook.

  var dispatch = queue.dispatch;
  var lastRenderPhaseUpdate = queue.pending;
  var newState = hook.memoizedState;

  if (lastRenderPhaseUpdate !== null) {
    // The queue doesn't persist past this render pass.
    queue.pending = null;
    var firstRenderPhaseUpdate = lastRenderPhaseUpdate.next;
    var update = firstRenderPhaseUpdate;

    do {
      // Process this render phase update. We don't have to check the
      // priority because it will always be the same as the current
      // render's.
      var action = update.action;
      newState = reducer(newState, action);
      update = update.next;
    } while (update !== firstRenderPhaseUpdate); // Mark that the fiber performed work, but only if the new state is
    // different from the current state.


    if (!objectIs(newState, hook.memoizedState)) {
      markWorkInProgressReceivedUpdate();
    }

    hook.memoizedState = newState; // Don't persist the state accumulated from the render phase updates to
    // the base state unless the queue is empty.
    // TODO: Not sure if this is the desired semantics, but it's what we
    // do for gDSFP. I can't remember why.

    if (hook.baseQueue === null) {
      hook.baseState = newState;
    }

    queue.lastRenderedState = newState;
  }

  return [newState, dispatch];
}

function readFromUnsubcribedMutableSource(root, source, getSnapshot) {
  {
    warnAboutMultipleRenderersDEV(source);
  }

  var getVersion = source._getVersion;
  var version = getVersion(source._source); // Is it safe for this component to read from this source during the current render?

  var isSafeToReadFromSource = false; // Check the version first.
  // If this render has already been started with a specific version,
  // we can use it alone to determine if we can safely read from the source.

  var currentRenderVersion = getWorkInProgressVersion(source);

  if (currentRenderVersion !== null) {
    // It's safe to read if the store hasn't been mutated since the last time
    // we read something.
    isSafeToReadFromSource = currentRenderVersion === version;
  } else {
    // If there's no version, then this is the first time we've read from the
    // source during the current render pass, so we need to do a bit more work.
    // What we need to determine is if there are any hooks that already
    // subscribed to the source, and if so, whether there are any pending
    // mutations that haven't been synchronized yet.
    //
    // If there are no pending mutations, then `root.mutableReadLanes` will be
    // empty, and we know we can safely read.
    //
    // If there *are* pending mutations, we may still be able to safely read
    // if the currently rendering lanes are inclusive of the pending mutation
    // lanes, since that guarantees that the value we're about to read from
    // the source is consistent with the values that we read during the most
    // recent mutation.
    isSafeToReadFromSource = isSubsetOfLanes(renderLanes, root.mutableReadLanes);

    if (isSafeToReadFromSource) {
      // If it's safe to read from this source during the current render,
      // store the version in case other components read from it.
      // A changed version number will let those components know to throw and restart the render.
      setWorkInProgressVersion(source, version);
    }
  }

  if (isSafeToReadFromSource) {
    var snapshot = getSnapshot(source._source);

    {
      if (typeof snapshot === 'function') {
        error('Mutable source should not return a function as the snapshot value. ' + 'Functions may close over mutable values and cause tearing.');
      }
    }

    return snapshot;
  } else {
    // This handles the special case of a mutable source being shared between renderers.
    // In that case, if the source is mutated between the first and second renderer,
    // The second renderer don't know that it needs to reset the WIP version during unwind,
    // (because the hook only marks sources as dirty if it's written to their WIP version).
    // That would cause this tear check to throw again and eventually be visible to the user.
    // We can avoid this infinite loop by explicitly marking the source as dirty.
    //
    // This can lead to tearing in the first renderer when it resumes,
    // but there's nothing we can do about that (short of throwing here and refusing to continue the render).
    markSourceAsDirty(source);

    {
      {
        throw Error( "Cannot read from mutable source during the current render without tearing. This is a bug in React. Please file an issue." );
      }
    }
  }
}

function useMutableSource(hook, source, getSnapshot, subscribe) {
  var root = getWorkInProgressRoot();

  if (!(root !== null)) {
    {
      throw Error( "Expected a work-in-progress root. This is a bug in React. Please file an issue." );
    }
  }

  var getVersion = source._getVersion;
  var version = getVersion(source._source);
  var dispatcher = ReactCurrentDispatcher$1.current; // eslint-disable-next-line prefer-const

  var _dispatcher$useState = dispatcher.useState(function () {
    return readFromUnsubcribedMutableSource(root, source, getSnapshot);
  }),
      currentSnapshot = _dispatcher$useState[0],
      setSnapshot = _dispatcher$useState[1];

  var snapshot = currentSnapshot; // Grab a handle to the state hook as well.
  // We use it to clear the pending update queue if we have a new source.

  var stateHook = workInProgressHook;
  var memoizedState = hook.memoizedState;
  var refs = memoizedState.refs;
  var prevGetSnapshot = refs.getSnapshot;
  var prevSource = memoizedState.source;
  var prevSubscribe = memoizedState.subscribe;
  var fiber = currentlyRenderingFiber$1;
  hook.memoizedState = {
    refs: refs,
    source: source,
    subscribe: subscribe
  }; // Sync the values needed by our subscription handler after each commit.

  dispatcher.useEffect(function () {
    refs.getSnapshot = getSnapshot; // Normally the dispatch function for a state hook never changes,
    // but this hook recreates the queue in certain cases  to avoid updates from stale sources.
    // handleChange() below needs to reference the dispatch function without re-subscribing,
    // so we use a ref to ensure that it always has the latest version.

    refs.setSnapshot = setSnapshot; // Check for a possible change between when we last rendered now.

    var maybeNewVersion = getVersion(source._source);

    if (!objectIs(version, maybeNewVersion)) {
      var maybeNewSnapshot = getSnapshot(source._source);

      {
        if (typeof maybeNewSnapshot === 'function') {
          error('Mutable source should not return a function as the snapshot value. ' + 'Functions may close over mutable values and cause tearing.');
        }
      }

      if (!objectIs(snapshot, maybeNewSnapshot)) {
        setSnapshot(maybeNewSnapshot);
        var lane = requestUpdateLane(fiber);
        markRootMutableRead(root, lane);
      } // If the source mutated between render and now,
      // there may be state updates already scheduled from the old source.
      // Entangle the updates so that they render in the same batch.


      markRootEntangled(root, root.mutableReadLanes);
    }
  }, [getSnapshot, source, subscribe]); // If we got a new source or subscribe function, re-subscribe in a passive effect.

  dispatcher.useEffect(function () {
    var handleChange = function () {
      var latestGetSnapshot = refs.getSnapshot;
      var latestSetSnapshot = refs.setSnapshot;

      try {
        latestSetSnapshot(latestGetSnapshot(source._source)); // Record a pending mutable source update with the same expiration time.

        var lane = requestUpdateLane(fiber);
        markRootMutableRead(root, lane);
      } catch (error) {
        // A selector might throw after a source mutation.
        // e.g. it might try to read from a part of the store that no longer exists.
        // In this case we should still schedule an update with React.
        // Worst case the selector will throw again and then an error boundary will handle it.
        latestSetSnapshot(function () {
          throw error;
        });
      }
    };

    var unsubscribe = subscribe(source._source, handleChange);

    {
      if (typeof unsubscribe !== 'function') {
        error('Mutable source subscribe function must return an unsubscribe function.');
      }
    }

    return unsubscribe;
  }, [source, subscribe]); // If any of the inputs to useMutableSource change, reading is potentially unsafe.
  //
  // If either the source or the subscription have changed we can't can't trust the update queue.
  // Maybe the source changed in a way that the old subscription ignored but the new one depends on.
  //
  // If the getSnapshot function changed, we also shouldn't rely on the update queue.
  // It's possible that the underlying source was mutated between the when the last "change" event fired,
  // and when the current render (with the new getSnapshot function) is processed.
  //
  // In both cases, we need to throw away pending updates (since they are no longer relevant)
  // and treat reading from the source as we do in the mount case.

  if (!objectIs(prevGetSnapshot, getSnapshot) || !objectIs(prevSource, source) || !objectIs(prevSubscribe, subscribe)) {
    // Create a new queue and setState method,
    // So if there are interleaved updates, they get pushed to the older queue.
    // When this becomes current, the previous queue and dispatch method will be discarded,
    // including any interleaving updates that occur.
    var newQueue = {
      pending: null,
      dispatch: null,
      lastRenderedReducer: basicStateReducer,
      lastRenderedState: snapshot
    };
    newQueue.dispatch = setSnapshot = dispatchAction.bind(null, currentlyRenderingFiber$1, newQueue);
    stateHook.queue = newQueue;
    stateHook.baseQueue = null;
    snapshot = readFromUnsubcribedMutableSource(root, source, getSnapshot);
    stateHook.memoizedState = stateHook.baseState = snapshot;
  }

  return snapshot;
}

function mountMutableSource(source, getSnapshot, subscribe) {
  var hook = mountWorkInProgressHook();
  hook.memoizedState = {
    refs: {
      getSnapshot: getSnapshot,
      setSnapshot: null
    },
    source: source,
    subscribe: subscribe
  };
  return useMutableSource(hook, source, getSnapshot, subscribe);
}

function updateMutableSource(source, getSnapshot, subscribe) {
  var hook = updateWorkInProgressHook();
  return useMutableSource(hook, source, getSnapshot, subscribe);
}

function mountState(initialState) {
  var hook = mountWorkInProgressHook();

  if (typeof initialState === 'function') {
    // $FlowFixMe: Flow doesn't like mixed types
    initialState = initialState();
  }

  hook.memoizedState = hook.baseState = initialState;
  var queue = hook.queue = {
    pending: null,
    dispatch: null,
    lastRenderedReducer: basicStateReducer,
    lastRenderedState: initialState
  };
  var dispatch = queue.dispatch = dispatchAction.bind(null, currentlyRenderingFiber$1, queue);
  return [hook.memoizedState, dispatch];
}

function updateState(initialState) {
  return updateReducer(basicStateReducer);
}

function rerenderState(initialState) {
  return rerenderReducer(basicStateReducer);
}

function pushEffect(tag, create, destroy, deps) {
  var effect = {
    tag: tag,
    create: create,
    destroy: destroy,
    deps: deps,
    // Circular
    next: null
  };
  var componentUpdateQueue = currentlyRenderingFiber$1.updateQueue;

  if (componentUpdateQueue === null) {
    componentUpdateQueue = createFunctionComponentUpdateQueue();
    currentlyRenderingFiber$1.updateQueue = componentUpdateQueue;
    componentUpdateQueue.lastEffect = effect.next = effect;
  } else {
    var lastEffect = componentUpdateQueue.lastEffect;

    if (lastEffect === null) {
      componentUpdateQueue.lastEffect = effect.next = effect;
    } else {
      var firstEffect = lastEffect.next;
      lastEffect.next = effect;
      effect.next = firstEffect;
      componentUpdateQueue.lastEffect = effect;
    }
  }

  return effect;
}

function mountRef(initialValue) {
  var hook = mountWorkInProgressHook();
  var ref = {
    current: initialValue
  };

  {
    Object.seal(ref);
  }

  hook.memoizedState = ref;
  return ref;
}

function updateRef(initialValue) {
  var hook = updateWorkInProgressHook();
  return hook.memoizedState;
}

function mountEffectImpl(fiberFlags, hookFlags, create, deps) {
  var hook = mountWorkInProgressHook();
  var nextDeps = deps === undefined ? null : deps;
  currentlyRenderingFiber$1.flags |= fiberFlags;
  hook.memoizedState = pushEffect(HasEffect | hookFlags, create, undefined, nextDeps);
}

function updateEffectImpl(fiberFlags, hookFlags, create, deps) {
  var hook = updateWorkInProgressHook();
  var nextDeps = deps === undefined ? null : deps;
  var destroy = undefined;

  if (currentHook !== null) {
    var prevEffect = currentHook.memoizedState;
    destroy = prevEffect.destroy;

    if (nextDeps !== null) {
      var prevDeps = prevEffect.deps;

      if (areHookInputsEqual(nextDeps, prevDeps)) {
        pushEffect(hookFlags, create, destroy, nextDeps);
        return;
      }
    }
  }

  currentlyRenderingFiber$1.flags |= fiberFlags;
  hook.memoizedState = pushEffect(HasEffect | hookFlags, create, destroy, nextDeps);
}

function mountEffect(create, deps) {
  {
    // $FlowExpectedError - jest isn't a global, and isn't recognized outside of tests
    if ('undefined' !== typeof jest) {
      warnIfNotCurrentlyActingEffectsInDEV(currentlyRenderingFiber$1);
    }
  }

  return mountEffectImpl(Update | Passive, Passive$1, create, deps);
}

function updateEffect(create, deps) {
  {
    // $FlowExpectedError - jest isn't a global, and isn't recognized outside of tests
    if ('undefined' !== typeof jest) {
      warnIfNotCurrentlyActingEffectsInDEV(currentlyRenderingFiber$1);
    }
  }

  return updateEffectImpl(Update | Passive, Passive$1, create, deps);
}

function mountLayoutEffect(create, deps) {
  return mountEffectImpl(Update, Layout, create, deps);
}

function updateLayoutEffect(create, deps) {
  return updateEffectImpl(Update, Layout, create, deps);
}

function imperativeHandleEffect(create, ref) {
  if (typeof ref === 'function') {
    var refCallback = ref;

    var _inst = create();

    refCallback(_inst);
    return function () {
      refCallback(null);
    };
  } else if (ref !== null && ref !== undefined) {
    var refObject = ref;

    {
      if (!refObject.hasOwnProperty('current')) {
        error('Expected useImperativeHandle() first argument to either be a ' + 'ref callback or React.createRef() object. Instead received: %s.', 'an object with keys {' + Object.keys(refObject).join(', ') + '}');
      }
    }

    var _inst2 = create();

    refObject.current = _inst2;
    return function () {
      refObject.current = null;
    };
  }
}

function mountImperativeHandle(ref, create, deps) {
  {
    if (typeof create !== 'function') {
      error('Expected useImperativeHandle() second argument to be a function ' + 'that creates a handle. Instead received: %s.', create !== null ? typeof create : 'null');
    }
  } // TODO: If deps are provided, should we skip comparing the ref itself?


  var effectDeps = deps !== null && deps !== undefined ? deps.concat([ref]) : null;
  return mountEffectImpl(Update, Layout, imperativeHandleEffect.bind(null, create, ref), effectDeps);
}

function updateImperativeHandle(ref, create, deps) {
  {
    if (typeof create !== 'function') {
      error('Expected useImperativeHandle() second argument to be a function ' + 'that creates a handle. Instead received: %s.', create !== null ? typeof create : 'null');
    }
  } // TODO: If deps are provided, should we skip comparing the ref itself?


  var effectDeps = deps !== null && deps !== undefined ? deps.concat([ref]) : null;
  return updateEffectImpl(Update, Layout, imperativeHandleEffect.bind(null, create, ref), effectDeps);
}

function mountDebugValue(value, formatterFn) {// This hook is normally a no-op.
  // The react-debug-hooks package injects its own implementation
  // so that e.g. DevTools can display custom hook values.
}

var updateDebugValue = mountDebugValue;

function mountCallback(callback, deps) {
  var hook = mountWorkInProgressHook();
  var nextDeps = deps === undefined ? null : deps;
  hook.memoizedState = [callback, nextDeps];
  return callback;
}

function updateCallback(callback, deps) {
  var hook = updateWorkInProgressHook();
  var nextDeps = deps === undefined ? null : deps;
  var prevState = hook.memoizedState;

  if (prevState !== null) {
    if (nextDeps !== null) {
      var prevDeps = prevState[1];

      if (areHookInputsEqual(nextDeps, prevDeps)) {
        return prevState[0];
      }
    }
  }

  hook.memoizedState = [callback, nextDeps];
  return callback;
}

function mountMemo(nextCreate, deps) {
  var hook = mountWorkInProgressHook();
  var nextDeps = deps === undefined ? null : deps;
  var nextValue = nextCreate();
  hook.memoizedState = [nextValue, nextDeps];
  return nextValue;
}

function updateMemo(nextCreate, deps) {
  var hook = updateWorkInProgressHook();
  var nextDeps = deps === undefined ? null : deps;
  var prevState = hook.memoizedState;

  if (prevState !== null) {
    // Assume these are defined. If they're not, areHookInputsEqual will warn.
    if (nextDeps !== null) {
      var prevDeps = prevState[1];

      if (areHookInputsEqual(nextDeps, prevDeps)) {
        return prevState[0];
      }
    }
  }

  var nextValue = nextCreate();
  hook.memoizedState = [nextValue, nextDeps];
  return nextValue;
}

function mountDeferredValue(value) {
  var _mountState = mountState(value),
      prevValue = _mountState[0],
      setValue = _mountState[1];

  mountEffect(function () {
    var prevTransition = ReactCurrentBatchConfig$1.transition;
    ReactCurrentBatchConfig$1.transition = 1;

    try {
      setValue(value);
    } finally {
      ReactCurrentBatchConfig$1.transition = prevTransition;
    }
  }, [value]);
  return prevValue;
}

function updateDeferredValue(value) {
  var _updateState = updateState(),
      prevValue = _updateState[0],
      setValue = _updateState[1];

  updateEffect(function () {
    var prevTransition = ReactCurrentBatchConfig$1.transition;
    ReactCurrentBatchConfig$1.transition = 1;

    try {
      setValue(value);
    } finally {
      ReactCurrentBatchConfig$1.transition = prevTransition;
    }
  }, [value]);
  return prevValue;
}

function rerenderDeferredValue(value) {
  var _rerenderState = rerenderState(),
      prevValue = _rerenderState[0],
      setValue = _rerenderState[1];

  updateEffect(function () {
    var prevTransition = ReactCurrentBatchConfig$1.transition;
    ReactCurrentBatchConfig$1.transition = 1;

    try {
      setValue(value);
    } finally {
      ReactCurrentBatchConfig$1.transition = prevTransition;
    }
  }, [value]);
  return prevValue;
}

function startTransition(setPending, callback) {
  var priorityLevel = getCurrentPriorityLevel();

  {
    runWithPriority$1(priorityLevel < UserBlockingPriority$2 ? UserBlockingPriority$2 : priorityLevel, function () {
      setPending(true);
    });
    runWithPriority$1(priorityLevel > NormalPriority$1 ? NormalPriority$1 : priorityLevel, function () {
      var prevTransition = ReactCurrentBatchConfig$1.transition;
      ReactCurrentBatchConfig$1.transition = 1;

      try {
        setPending(false);
        callback();
      } finally {
        ReactCurrentBatchConfig$1.transition = prevTransition;
      }
    });
  }
}

function mountTransition() {
  var _mountState2 = mountState(false),
      isPending = _mountState2[0],
      setPending = _mountState2[1]; // The `start` method can be stored on a ref, since `setPending`
  // never changes.


  var start = startTransition.bind(null, setPending);
  mountRef(start);
  return [start, isPending];
}

function updateTransition() {
  var _updateState2 = updateState(),
      isPending = _updateState2[0];

  var startRef = updateRef();
  var start = startRef.current;
  return [start, isPending];
}

function rerenderTransition() {
  var _rerenderState2 = rerenderState(),
      isPending = _rerenderState2[0];

  var startRef = updateRef();
  var start = startRef.current;
  return [start, isPending];
}

var isUpdatingOpaqueValueInRenderPhase = false;
function getIsUpdatingOpaqueValueInRenderPhaseInDEV() {
  {
    return isUpdatingOpaqueValueInRenderPhase;
  }
}

function warnOnOpaqueIdentifierAccessInDEV(fiber) {
  {
    // TODO: Should warn in effects and callbacks, too
    var name = getComponentName(fiber.type) || 'Unknown';

    if (getIsRendering() && !didWarnAboutUseOpaqueIdentifier[name]) {
      error('The object passed back from useOpaqueIdentifier is meant to be ' + 'passed through to attributes only. Do not read the ' + 'value directly.');

      didWarnAboutUseOpaqueIdentifier[name] = true;
    }
  }
}

function mountOpaqueIdentifier() {
  var makeId =  makeClientIdInDEV.bind(null, warnOnOpaqueIdentifierAccessInDEV.bind(null, currentlyRenderingFiber$1)) ;

  if (getIsHydrating()) {
    var didUpgrade = false;
    var fiber = currentlyRenderingFiber$1;

    var readValue = function () {
      if (!didUpgrade) {
        // Only upgrade once. This works even inside the render phase because
        // the update is added to a shared queue, which outlasts the
        // in-progress render.
        didUpgrade = true;

        {
          isUpdatingOpaqueValueInRenderPhase = true;
          setId(makeId());
          isUpdatingOpaqueValueInRenderPhase = false;
          warnOnOpaqueIdentifierAccessInDEV(fiber);
        }
      }

      {
        {
          throw Error( "The object passed back from useOpaqueIdentifier is meant to be passed through to attributes only. Do not read the value directly." );
        }
      }
    };

    var id = makeOpaqueHydratingObject(readValue);
    var setId = mountState(id)[1];

    if ((currentlyRenderingFiber$1.mode & BlockingMode) === NoMode) {
      currentlyRenderingFiber$1.flags |= Update | Passive;
      pushEffect(HasEffect | Passive$1, function () {
        setId(makeId());
      }, undefined, null);
    }

    return id;
  } else {
    var _id = makeId();

    mountState(_id);
    return _id;
  }
}

function updateOpaqueIdentifier() {
  var id = updateState()[0];
  return id;
}

function rerenderOpaqueIdentifier() {
  var id = rerenderState()[0];
  return id;
}

function dispatchAction(fiber, queue, action) {
  {
    if (typeof arguments[3] === 'function') {
      error("State updates from the useState() and useReducer() Hooks don't support the " + 'second callback argument. To execute a side effect after ' + 'rendering, declare it in the component body with useEffect().');
    }
  }

  var eventTime = requestEventTime();
  var lane = requestUpdateLane(fiber);
  var update = {
    lane: lane,
    action: action,
    eagerReducer: null,
    eagerState: null,
    next: null
  }; // Append the update to the end of the list.

  var pending = queue.pending;

  if (pending === null) {
    // This is the first update. Create a circular list.
    update.next = update;
  } else {
    update.next = pending.next;
    pending.next = update;
  }

  queue.pending = update;
  var alternate = fiber.alternate;

  if (fiber === currentlyRenderingFiber$1 || alternate !== null && alternate === currentlyRenderingFiber$1) {
    // This is a render phase update. Stash it in a lazily-created map of
    // queue -> linked list of updates. After this render pass, we'll restart
    // and apply the stashed updates on top of the work-in-progress hook.
    didScheduleRenderPhaseUpdateDuringThisPass = didScheduleRenderPhaseUpdate = true;
  } else {
    if (fiber.lanes === NoLanes && (alternate === null || alternate.lanes === NoLanes)) {
      // The queue is currently empty, which means we can eagerly compute the
      // next state before entering the render phase. If the new state is the
      // same as the current state, we may be able to bail out entirely.
      var lastRenderedReducer = queue.lastRenderedReducer;

      if (lastRenderedReducer !== null) {
        var prevDispatcher;

        {
          prevDispatcher = ReactCurrentDispatcher$1.current;
          ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
        }

        try {
          var currentState = queue.lastRenderedState;
          var eagerState = lastRenderedReducer(currentState, action); // Stash the eagerly computed state, and the reducer used to compute
          // it, on the update object. If the reducer hasn't changed by the
          // time we enter the render phase, then the eager state can be used
          // without calling the reducer again.

          update.eagerReducer = lastRenderedReducer;
          update.eagerState = eagerState;

          if (objectIs(eagerState, currentState)) {
            // Fast path. We can bail out without scheduling React to re-render.
            // It's still possible that we'll need to rebase this update later,
            // if the component re-renders for a different reason and by that
            // time the reducer has changed.
            return;
          }
        } catch (error) {// Suppress the error. It will throw again in the render phase.
        } finally {
          {
            ReactCurrentDispatcher$1.current = prevDispatcher;
          }
        }
      }
    }

    {
      // $FlowExpectedError - jest isn't a global, and isn't recognized outside of tests
      if ('undefined' !== typeof jest) {
        warnIfNotScopedWithMatchingAct(fiber);
        warnIfNotCurrentlyActingUpdatesInDev(fiber);
      }
    }

    scheduleUpdateOnFiber(fiber, lane, eventTime);
  }
}

var ContextOnlyDispatcher = {
  readContext: readContext,
  useCallback: throwInvalidHookError,
  useContext: throwInvalidHookError,
  useEffect: throwInvalidHookError,
  useImperativeHandle: throwInvalidHookError,
  useLayoutEffect: throwInvalidHookError,
  useMemo: throwInvalidHookError,
  useReducer: throwInvalidHookError,
  useRef: throwInvalidHookError,
  useState: throwInvalidHookError,
  useDebugValue: throwInvalidHookError,
  useDeferredValue: throwInvalidHookError,
  useTransition: throwInvalidHookError,
  useMutableSource: throwInvalidHookError,
  useOpaqueIdentifier: throwInvalidHookError,
  unstable_isNewReconciler: enableNewReconciler
};
var HooksDispatcherOnMountInDEV = null;
var HooksDispatcherOnMountWithHookTypesInDEV = null;
var HooksDispatcherOnUpdateInDEV = null;
var HooksDispatcherOnRerenderInDEV = null;
var InvalidNestedHooksDispatcherOnMountInDEV = null;
var InvalidNestedHooksDispatcherOnUpdateInDEV = null;
var InvalidNestedHooksDispatcherOnRerenderInDEV = null;

{
  var warnInvalidContextAccess = function () {
    error('Context can only be read while React is rendering. ' + 'In classes, you can read it in the render method or getDerivedStateFromProps. ' + 'In function components, you can read it directly in the function body, but not ' + 'inside Hooks like useReducer() or useMemo().');
  };

  var warnInvalidHookAccess = function () {
    error('Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. ' + 'You can only call Hooks at the top level of your React function. ' + 'For more information, see ' + 'https://reactjs.org/link/rules-of-hooks');
  };

  HooksDispatcherOnMountInDEV = {
    readContext: function (context, observedBits) {
      return readContext(context, observedBits);
    },
    useCallback: function (callback, deps) {
      currentHookNameInDev = 'useCallback';
      mountHookTypesDev();
      checkDepsAreArrayDev(deps);
      return mountCallback(callback, deps);
    },
    useContext: function (context, observedBits) {
      currentHookNameInDev = 'useContext';
      mountHookTypesDev();
      return readContext(context, observedBits);
    },
    useEffect: function (create, deps) {
      currentHookNameInDev = 'useEffect';
      mountHookTypesDev();
      checkDepsAreArrayDev(deps);
      return mountEffect(create, deps);
    },
    useImperativeHandle: function (ref, create, deps) {
      currentHookNameInDev = 'useImperativeHandle';
      mountHookTypesDev();
      checkDepsAreArrayDev(deps);
      return mountImperativeHandle(ref, create, deps);
    },
    useLayoutEffect: function (create, deps) {
      currentHookNameInDev = 'useLayoutEffect';
      mountHookTypesDev();
      checkDepsAreArrayDev(deps);
      return mountLayoutEffect(create, deps);
    },
    useMemo: function (create, deps) {
      currentHookNameInDev = 'useMemo';
      mountHookTypesDev();
      checkDepsAreArrayDev(deps);
      var prevDispatcher = ReactCurrentDispatcher$1.current;
      ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;

      try {
        return mountMemo(create, deps);
      } finally {
        ReactCurrentDispatcher$1.current = prevDispatcher;
      }
    },
    useReducer: function (reducer, initialArg, init) {
      currentHookNameInDev = 'useReducer';
      mountHookTypesDev();
      var prevDispatcher = ReactCurrentDispatcher$1.current;
      ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;

      try {
        return mountReducer(reducer, initialArg, init);
      } finally {
        ReactCurrentDispatcher$1.current = prevDispatcher;
      }
    },
    useRef: function (initialValue) {
      currentHookNameInDev = 'useRef';
      mountHookTypesDev();
      return mountRef(initialValue);
    },
    useState: function (initialState) {
      currentHookNameInDev = 'useState';
      mountHookTypesDev();
      var prevDispatcher = ReactCurrentDispatcher$1.current;
      ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;

      try {
        return mountState(initialState);
      } finally {
        ReactCurrentDispatcher$1.current = prevDispatcher;
      }
    },
    useDebugValue: function (value, formatterFn) {
      currentHookNameInDev = 'useDebugValue';
      mountHookTypesDev();
      return mountDebugValue();
    },
    useDeferredValue: function (value) {
      currentHookNameInDev = 'useDeferredValue';
      mountHookTypesDev();
      return mountDeferredValue(value);
    },
    useTransition: function () {
      currentHookNameInDev = 'useTransition';
      mountHookTypesDev();
      return mountTransition();
    },
    useMutableSource: function (source, getSnapshot, subscribe) {
      currentHookNameInDev = 'useMutableSource';
      mountHookTypesDev();
      return mountMutableSource(source, getSnapshot, subscribe);
    },
    useOpaqueIdentifier: function () {
      currentHookNameInDev = 'useOpaqueIdentifier';
      mountHookTypesDev();
      return mountOpaqueIdentifier();
    },
    unstable_isNewReconciler: enableNewReconciler
  };
  HooksDispatcherOnMountWithHookTypesInDEV = {
    readContext: function (context, observedBits) {
      return readContext(context, observedBits);
    },
    useCallback: function (callback, deps) {
      currentHookNameInDev = 'useCallback';
      updateHookTypesDev();
      return mountCallback(callback, deps);
    },
    useContext: function (context, observedBits) {
      currentHookNameInDev = 'useContext';
      updateHookTypesDev();
      return readContext(context, observedBits);
    },
    useEffect: function (create, deps) {
      currentHookNameInDev = 'useEffect';
      updateHookTypesDev();
      return mountEffect(create, deps);
    },
    useImperativeHandle: function (ref, create, deps) {
      currentHookNameInDev = 'useImperativeHandle';
      updateHookTypesDev();
      return mountImperativeHandle(ref, create, deps);
    },
    useLayoutEffect: function (create, deps) {
      currentHookNameInDev = 'useLayoutEffect';
      updateHookTypesDev();
      return mountLayoutEffect(create, deps);
    },
    useMemo: function (create, deps) {
      currentHookNameInDev = 'useMemo';
      updateHookTypesDev();
      var prevDispatcher = ReactCurrentDispatcher$1.current;
      ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;

      try {
        return mountMemo(create, deps);
      } finally {
        ReactCurrentDispatcher$1.current = prevDispatcher;
      }
    },
    useReducer: function (reducer, initialArg, init) {
      currentHookNameInDev = 'useReducer';
      updateHookTypesDev();
      var prevDispatcher = ReactCurrentDispatcher$1.current;
      ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;

      try {
        return mountReducer(reducer, initialArg, init);
      } finally {
        ReactCurrentDispatcher$1.current = prevDispatcher;
      }
    },
    useRef: function (initialValue) {
      currentHookNameInDev = 'useRef';
      updateHookTypesDev();
      return mountRef(initialValue);
    },
    useState: function (initialState) {
      currentHookNameInDev = 'useState';
      updateHookTypesDev();
      var prevDispatcher = ReactCurrentDispatcher$1.current;
      ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;

      try {
        return mountState(initialState);
      } finally {
        ReactCurrentDispatcher$1.current = prevDispatcher;
      }
    },
    useDebugValue: function (value, formatterFn) {
      currentHookNameInDev = 'useDebugValue';
      updateHookTypesDev();
      return mountDebugValue();
    },
    useDeferredValue: function (value) {
      currentHookNameInDev = 'useDeferredValue';
      updateHookTypesDev();
      return mountDeferredValue(value);
    },
    useTransition: function () {
      currentHookNameInDev = 'useTransition';
      updateHookTypesDev();
      return mountTransition();
    },
    useMutableSource: function (source, getSnapshot, subscribe) {
      currentHookNameInDev = 'useMutableSource';
      updateHookTypesDev();
      return mountMutableSource(source, getSnapshot, subscribe);
    },
    useOpaqueIdentifier: function () {
      currentHookNameInDev = 'useOpaqueIdentifier';
      updateHookTypesDev();
      return mountOpaqueIdentifier();
    },
    unstable_isNewReconciler: enableNewReconciler
  };
  HooksDispatcherOnUpdateInDEV = {
    readContext: function (context, observedBits) {
      return readContext(context, observedBits);
    },
    useCallback: function (callback, deps) {
      currentHookNameInDev = 'useCallback';
      updateHookTypesDev();
      return updateCallback(callback, deps);
    },
    useContext: function (context, observedBits) {
      currentHookNameInDev = 'useContext';
      updateHookTypesDev();
      return readContext(context, observedBits);
    },
    useEffect: function (create, deps) {
      currentHookNameInDev = 'useEffect';
      updateHookTypesDev();
      return updateEffect(create, deps);
    },
    useImperativeHandle: function (ref, create, deps) {
      currentHookNameInDev = 'useImperativeHandle';
      updateHookTypesDev();
      return updateImperativeHandle(ref, create, deps);
    },
    useLayoutEffect: function (create, deps) {
      currentHookNameInDev = 'useLayoutEffect';
      updateHookTypesDev();
      return updateLayoutEffect(create, deps);
    },
    useMemo: function (create, deps) {
      currentHookNameInDev = 'useMemo';
      updateHookTypesDev();
      var prevDispatcher = ReactCurrentDispatcher$1.current;
      ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;

      try {
        return updateMemo(create, deps);
      } finally {
        ReactCurrentDispatcher$1.current = prevDispatcher;
      }
    },
    useReducer: function (reducer, initialArg, init) {
      currentHookNameInDev = 'useReducer';
      updateHookTypesDev();
      var prevDispatcher = ReactCurrentDispatcher$1.current;
      ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;

      try {
        return updateReducer(reducer, initialArg, init);
      } finally {
        ReactCurrentDispatcher$1.current = prevDispatcher;
      }
    },
    useRef: function (initialValue) {
      currentHookNameInDev = 'useRef';
      updateHookTypesDev();
      return updateRef();
    },
    useState: function (initialState) {
      currentHookNameInDev = 'useState';
      updateHookTypesDev();
      var prevDispatcher = ReactCurrentDispatcher$1.current;
      ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;

      try {
        return updateState(initialState);
      } finally {
        ReactCurrentDispatcher$1.current = prevDispatcher;
      }
    },
    useDebugValue: function (value, formatterFn) {
      currentHookNameInDev = 'useDebugValue';
      updateHookTypesDev();
      return updateDebugValue();
    },
    useDeferredValue: function (value) {
      currentHookNameInDev = 'useDeferredValue';
      updateHookTypesDev();
      return updateDeferredValue(value);
    },
    useTransition: function () {
      currentHookNameInDev = 'useTransition';
      updateHookTypesDev();
      return updateTransition();
    },
    useMutableSource: function (source, getSnapshot, subscribe) {
      currentHookNameInDev = 'useMutableSource';
      updateHookTypesDev();
      return updateMutableSource(source, getSnapshot, subscribe);
    },
    useOpaqueIdentifier: function () {
      currentHookNameInDev = 'useOpaqueIdentifier';
      updateHookTypesDev();
      return updateOpaqueIdentifier();
    },
    unstable_isNewReconciler: enableNewReconciler
  };
  HooksDispatcherOnRerenderInDEV = {
    readContext: function (context, observedBits) {
      return readContext(context, observedBits);
    },
    useCallback: function (callback, deps) {
      currentHookNameInDev = 'useCallback';
      updateHookTypesDev();
      return updateCallback(callback, deps);
    },
    useContext: function (context, observedBits) {
      currentHookNameInDev = 'useContext';
      updateHookTypesDev();
      return readContext(context, observedBits);
    },
    useEffect: function (create, deps) {
      currentHookNameInDev = 'useEffect';
      updateHookTypesDev();
      return updateEffect(create, deps);
    },
    useImperativeHandle: function (ref, create, deps) {
      currentHookNameInDev = 'useImperativeHandle';
      updateHookTypesDev();
      return updateImperativeHandle(ref, create, deps);
    },
    useLayoutEffect: function (create, deps) {
      currentHookNameInDev = 'useLayoutEffect';
      updateHookTypesDev();
      return updateLayoutEffect(create, deps);
    },
    useMemo: function (create, deps) {
      currentHookNameInDev = 'useMemo';
      updateHookTypesDev();
      var prevDispatcher = ReactCurrentDispatcher$1.current;
      ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnRerenderInDEV;

      try {
        return updateMemo(create, deps);
      } finally {
        ReactCurrentDispatcher$1.current = prevDispatcher;
      }
    },
    useReducer: function (reducer, initialArg, init) {
      currentHookNameInDev = 'useReducer';
      updateHookTypesDev();
      var prevDispatcher = ReactCurrentDispatcher$1.current;
      ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnRerenderInDEV;

      try {
        return rerenderReducer(reducer, initialArg, init);
      } finally {
        ReactCurrentDispatcher$1.current = prevDispatcher;
      }
    },
    useRef: function (initialValue) {
      currentHookNameInDev = 'useRef';
      updateHookTypesDev();
      return updateRef();
    },
    useState: function (initialState) {
      currentHookNameInDev = 'useState';
      updateHookTypesDev();
      var prevDispatcher = ReactCurrentDispatcher$1.current;
      ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnRerenderInDEV;

      try {
        return rerenderState(initialState);
      } finally {
        ReactCurrentDispatcher$1.current = prevDispatcher;
      }
    },
    useDebugValue: function (value, formatterFn) {
      currentHookNameInDev = 'useDebugValue';
      updateHookTypesDev();
      return updateDebugValue();
    },
    useDeferredValue: function (value) {
      currentHookNameInDev = 'useDeferredValue';
      updateHookTypesDev();
      return rerenderDeferredValue(value);
    },
    useTransition: function () {
      currentHookNameInDev = 'useTransition';
      updateHookTypesDev();
      return rerenderTransition();
    },
    useMutableSource: function (source, getSnapshot, subscribe) {
      currentHookNameInDev = 'useMutableSource';
      updateHookTypesDev();
      return updateMutableSource(source, getSnapshot, subscribe);
    },
    useOpaqueIdentifier: function () {
      currentHookNameInDev = 'useOpaqueIdentifier';
      updateHookTypesDev();
      return rerenderOpaqueIdentifier();
    },
    unstable_isNewReconciler: enableNewReconciler
  };
  InvalidNestedHooksDispatcherOnMountInDEV = {
    readContext: function (context, observedBits) {
      warnInvalidContextAccess();
      return readContext(context, observedBits);
    },
    useCallback: function (callback, deps) {
      currentHookNameInDev = 'useCallback';
      warnInvalidHookAccess();
      mountHookTypesDev();
      return mountCallback(callback, deps);
    },
    useContext: function (context, observedBits) {
      currentHookNameInDev = 'useContext';
      warnInvalidHookAccess();
      mountHookTypesDev();
      return readContext(context, observedBits);
    },
    useEffect: function (create, deps) {
      currentHookNameInDev = 'useEffect';
      warnInvalidHookAccess();
      mountHookTypesDev();
      return mountEffect(create, deps);
    },
    useImperativeHandle: function (ref, create, deps) {
      currentHookNameInDev = 'useImperativeHandle';
      warnInvalidHookAccess();
      mountHookTypesDev();
      return mountImperativeHandle(ref, create, deps);
    },
    useLayoutEffect: function (create, deps) {
      currentHookNameInDev = 'useLayoutEffect';
      warnInvalidHookAccess();
      mountHookTypesDev();
      return mountLayoutEffect(create, deps);
    },
    useMemo: function (create, deps) {
      currentHookNameInDev = 'useMemo';
      warnInvalidHookAccess();
      mountHookTypesDev();
      var prevDispatcher = ReactCurrentDispatcher$1.current;
      ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;

      try {
        return mountMemo(create, deps);
      } finally {
        ReactCurrentDispatcher$1.current = prevDispatcher;
      }
    },
    useReducer: function (reducer, initialArg, init) {
      currentHookNameInDev = 'useReducer';
      warnInvalidHookAccess();
      mountHookTypesDev();
      var prevDispatcher = ReactCurrentDispatcher$1.current;
      ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;

      try {
        return mountReducer(reducer, initialArg, init);
      } finally {
        ReactCurrentDispatcher$1.current = prevDispatcher;
      }
    },
    useRef: function (initialValue) {
      currentHookNameInDev = 'useRef';
      warnInvalidHookAccess();
      mountHookTypesDev();
      return mountRef(initialValue);
    },
    useState: function (initialState) {
      currentHookNameInDev = 'useState';
      warnInvalidHookAccess();
      mountHookTypesDev();
      var prevDispatcher = ReactCurrentDispatcher$1.current;
      ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;

      try {
        return mountState(initialState);
      } finally {
        ReactCurrentDispatcher$1.current = prevDispatcher;
      }
    },
    useDebugValue: function (value, formatterFn) {
      currentHookNameInDev = 'useDebugValue';
      warnInvalidHookAccess();
      mountHookTypesDev();
      return mountDebugValue();
    },
    useDeferredValue: function (value) {
      currentHookNameInDev = 'useDeferredValue';
      warnInvalidHookAccess();
      mountHookTypesDev();
      return mountDeferredValue(value);
    },
    useTransition: function () {
      currentHookNameInDev = 'useTransition';
      warnInvalidHookAccess();
      mountHookTypesDev();
      return mountTransition();
    },
    useMutableSource: function (source, getSnapshot, subscribe) {
      currentHookNameInDev = 'useMutableSource';
      warnInvalidHookAccess();
      mountHookTypesDev();
      return mountMutableSource(source, getSnapshot, subscribe);
    },
    useOpaqueIdentifier: function () {
      currentHookNameInDev = 'useOpaqueIdentifier';
      warnInvalidHookAccess();
      mountHookTypesDev();
      return mountOpaqueIdentifier();
    },
    unstable_isNewReconciler: enableNewReconciler
  };
  InvalidNestedHooksDispatcherOnUpdateInDEV = {
    readContext: function (context, observedBits) {
      warnInvalidContextAccess();
      return readContext(context, observedBits);
    },
    useCallback: function (callback, deps) {
      currentHookNameInDev = 'useCallback';
      warnInvalidHookAccess();
      updateHookTypesDev();
      return updateCallback(callback, deps);
    },
    useContext: function (context, observedBits) {
      currentHookNameInDev = 'useContext';
      warnInvalidHookAccess();
      updateHookTypesDev();
      return readContext(context, observedBits);
    },
    useEffect: function (create, deps) {
      currentHookNameInDev = 'useEffect';
      warnInvalidHookAccess();
      updateHookTypesDev();
      return updateEffect(create, deps);
    },
    useImperativeHandle: function (ref, create, deps) {
      currentHookNameInDev = 'useImperativeHandle';
      warnInvalidHookAccess();
      updateHookTypesDev();
      return updateImperativeHandle(ref, create, deps);
    },
    useLayoutEffect: function (create, deps) {
      currentHookNameInDev = 'useLayoutEffect';
      warnInvalidHookAccess();
      updateHookTypesDev();
      return updateLayoutEffect(create, deps);
    },
    useMemo: function (create, deps) {
      currentHookNameInDev = 'useMemo';
      warnInvalidHookAccess();
      updateHookTypesDev();
      var prevDispatcher = ReactCurrentDispatcher$1.current;
      ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;

      try {
        return updateMemo(create, deps);
      } finally {
        ReactCurrentDispatcher$1.current = prevDispatcher;
      }
    },
    useReducer: function (reducer, initialArg, init) {
      currentHookNameInDev = 'useReducer';
      warnInvalidHookAccess();
      updateHookTypesDev();
      var prevDispatcher = ReactCurrentDispatcher$1.current;
      ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;

      try {
        return updateReducer(reducer, initialArg, init);
      } finally {
        ReactCurrentDispatcher$1.current = prevDispatcher;
      }
    },
    useRef: function (initialValue) {
      currentHookNameInDev = 'useRef';
      warnInvalidHookAccess();
      updateHookTypesDev();
      return updateRef();
    },
    useState: function (initialState) {
      currentHookNameInDev = 'useState';
      warnInvalidHookAccess();
      updateHookTypesDev();
      var prevDispatcher = ReactCurrentDispatcher$1.current;
      ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;

      try {
        return updateState(initialState);
      } finally {
        ReactCurrentDispatcher$1.current = prevDispatcher;
      }
    },
    useDebugValue: function (value, formatterFn) {
      currentHookNameInDev = 'useDebugValue';
      warnInvalidHookAccess();
      updateHookTypesDev();
      return updateDebugValue();
    },
    useDeferredValue: function (value) {
      currentHookNameInDev = 'useDeferredValue';
      warnInvalidHookAccess();
      updateHookTypesDev();
      return updateDeferredValue(value);
    },
    useTransition: function () {
      currentHookNameInDev = 'useTransition';
      warnInvalidHookAccess();
      updateHookTypesDev();
      return updateTransition();
    },
    useMutableSource: function (source, getSnapshot, subscribe) {
      currentHookNameInDev = 'useMutableSource';
      warnInvalidHookAccess();
      updateHookTypesDev();
      return updateMutableSource(source, getSnapshot, subscribe);
    },
    useOpaqueIdentifier: function () {
      currentHookNameInDev = 'useOpaqueIdentifier';
      warnInvalidHookAccess();
      updateHookTypesDev();
      return updateOpaqueIdentifier();
    },
    unstable_isNewReconciler: enableNewReconciler
  };
  InvalidNestedHooksDispatcherOnRerenderInDEV = {
    readContext: function (context, observedBits) {
      warnInvalidContextAccess();
      return readContext(context, observedBits);
    },
    useCallback: function (callback, deps) {
      currentHookNameInDev = 'useCallback';
      warnInvalidHookAccess();
      updateHookTypesDev();
      return updateCallback(callback, deps);
    },
    useContext: function (context, observedBits) {
      currentHookNameInDev = 'useContext';
      warnInvalidHookAccess();
      updateHookTypesDev();
      return readContext(context, observedBits);
    },
    useEffect: function (create, deps) {
      currentHookNameInDev = 'useEffect';
      warnInvalidHookAccess();
      updateHookTypesDev();
      return updateEffect(create, deps);
    },
    useImperativeHandle: function (ref, create, deps) {
      currentHookNameInDev = 'useImperativeHandle';
      warnInvalidHookAccess();
      updateHookTypesDev();
      return updateImperativeHandle(ref, create, deps);
    },
    useLayoutEffect: function (create, deps) {
      currentHookNameInDev = 'useLayoutEffect';
      warnInvalidHookAccess();
      updateHookTypesDev();
      return updateLayoutEffect(create, deps);
    },
    useMemo: function (create, deps) {
      currentHookNameInDev = 'useMemo';
      warnInvalidHookAccess();
      updateHookTypesDev();
      var prevDispatcher = ReactCurrentDispatcher$1.current;
      ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;

      try {
        return updateMemo(create, deps);
      } finally {
        ReactCurrentDispatcher$1.current = prevDispatcher;
      }
    },
    useReducer: function (reducer, initialArg, init) {
      currentHookNameInDev = 'useReducer';
      warnInvalidHookAccess();
      updateHookTypesDev();
      var prevDispatcher = ReactCurrentDispatcher$1.current;
      ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;

      try {
        return rerenderReducer(reducer, initialArg, init);
      } finally {
        ReactCurrentDispatcher$1.current = prevDispatcher;
      }
    },
    useRef: function (initialValue) {
      currentHookNameInDev = 'useRef';
      warnInvalidHookAccess();
      updateHookTypesDev();
      return updateRef();
    },
    useState: function (initialState) {
      currentHookNameInDev = 'useState';
      warnInvalidHookAccess();
      updateHookTypesDev();
      var prevDispatcher = ReactCurrentDispatcher$1.current;
      ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;

      try {
        return rerenderState(initialState);
      } finally {
        ReactCurrentDispatcher$1.current = prevDispatcher;
      }
    },
    useDebugValue: function (value, formatterFn) {
      currentHookNameInDev = 'useDebugValue';
      warnInvalidHookAccess();
      updateHookTypesDev();
      return updateDebugValue();
    },
    useDeferredValue: function (value) {
      currentHookNameInDev = 'useDeferredValue';
      warnInvalidHookAccess();
      updateHookTypesDev();
      return rerenderDeferredValue(value);
    },
    useTransition: function () {
      currentHookNameInDev = 'useTransition';
      warnInvalidHookAccess();
      updateHookTypesDev();
      return rerenderTransition();
    },
    useMutableSource: function (source, getSnapshot, subscribe) {
      currentHookNameInDev = 'useMutableSource';
      warnInvalidHookAccess();
      updateHookTypesDev();
      return updateMutableSource(source, getSnapshot, subscribe);
    },
    useOpaqueIdentifier: function () {
      currentHookNameInDev = 'useOpaqueIdentifier';
      warnInvalidHookAccess();
      updateHookTypesDev();
      return rerenderOpaqueIdentifier();
    },
    unstable_isNewReconciler: enableNewReconciler
  };
}

var now$1 = Scheduler.unstable_now;
var commitTime = 0;
var profilerStartTime = -1;

function getCommitTime() {
  return commitTime;
}

function recordCommitTime() {

  commitTime = now$1();
}

function startProfilerTimer(fiber) {

  profilerStartTime = now$1();

  if (fiber.actualStartTime < 0) {
    fiber.actualStartTime = now$1();
  }
}

function stopProfilerTimerIfRunning(fiber) {

  profilerStartTime = -1;
}

function stopProfilerTimerIfRunningAndRecordDelta(fiber, overrideBaseTime) {

  if (profilerStartTime >= 0) {
    var elapsedTime = now$1() - profilerStartTime;
    fiber.actualDuration += elapsedTime;

    if (overrideBaseTime) {
      fiber.selfBaseDuration = elapsedTime;
    }

    profilerStartTime = -1;
  }
}

function transferActualDuration(fiber) {
  // Transfer time spent rendering these children so we don't lose it
  // after we rerender. This is used as a helper in special cases
  // where we should count the work of multiple passes.
  var child = fiber.child;

  while (child) {
    fiber.actualDuration += child.actualDuration;
    child = child.sibling;
  }
}

var ReactCurrentOwner$1 = ReactSharedInternals.ReactCurrentOwner;
var didReceiveUpdate = false;
var didWarnAboutBadClass;
var didWarnAboutModulePatternComponent;
var didWarnAboutContextTypeOnFunctionComponent;
var didWarnAboutGetDerivedStateOnFunctionComponent;
var didWarnAboutFunctionRefs;
var didWarnAboutReassigningProps;
var didWarnAboutRevealOrder;
var didWarnAboutTailOptions;

{
  didWarnAboutBadClass = {};
  didWarnAboutModulePatternComponent = {};
  didWarnAboutContextTypeOnFunctionComponent = {};
  didWarnAboutGetDerivedStateOnFunctionComponent = {};
  didWarnAboutFunctionRefs = {};
  didWarnAboutReassigningProps = false;
  didWarnAboutRevealOrder = {};
  didWarnAboutTailOptions = {};
}

function reconcileChildren(current, workInProgress, nextChildren, renderLanes) {
  if (current === null) {
    // If this is a fresh new component that hasn't been rendered yet, we
    // won't update its child set by applying minimal side-effects. Instead,
    // we will add them all to the child before it gets rendered. That means
    // we can optimize this reconciliation pass by not tracking side-effects.
    workInProgress.child = mountChildFibers(workInProgress, null, nextChildren, renderLanes);
  } else {
    // If the current child is the same as the work in progress, it means that
    // we haven't yet started any work on these children. Therefore, we use
    // the clone algorithm to create a copy of all the current children.
    // If we had any progressed work already, that is invalid at this point so
    // let's throw it out.
    workInProgress.child = reconcileChildFibers(workInProgress, current.child, nextChildren, renderLanes);
  }
}

function forceUnmountCurrentAndReconcile(current, workInProgress, nextChildren, renderLanes) {
  // This function is fork of reconcileChildren. It's used in cases where we
  // want to reconcile without matching against the existing set. This has the
  // effect of all current children being unmounted; even if the type and key
  // are the same, the old child is unmounted and a new child is created.
  //
  // To do this, we're going to go through the reconcile algorithm twice. In
  // the first pass, we schedule a deletion for all the current children by
  // passing null.
  workInProgress.child = reconcileChildFibers(workInProgress, current.child, null, renderLanes); // In the second pass, we mount the new children. The trick here is that we
  // pass null in place of where we usually pass the current child set. This has
  // the effect of remounting all children regardless of whether their
  // identities match.

  workInProgress.child = reconcileChildFibers(workInProgress, null, nextChildren, renderLanes);
}

function updateForwardRef(current, workInProgress, Component, nextProps, renderLanes) {
  // TODO: current can be non-null here even if the component
  // hasn't yet mounted. This happens after the first render suspends.
  // We'll need to figure out if this is fine or can cause issues.
  {
    if (workInProgress.type !== workInProgress.elementType) {
      // Lazy component props can't be validated in createElement
      // because they're only guaranteed to be resolved here.
      var innerPropTypes = Component.propTypes;

      if (innerPropTypes) {
        checkPropTypes(innerPropTypes, nextProps, // Resolved props
        'prop', getComponentName(Component));
      }
    }
  }

  var render = Component.render;
  var ref = workInProgress.ref; // The rest is a fork of updateFunctionComponent

  var nextChildren;
  prepareToReadContext(workInProgress, renderLanes);

  {
    ReactCurrentOwner$1.current = workInProgress;
    setIsRendering(true);
    nextChildren = renderWithHooks(current, workInProgress, render, nextProps, ref, renderLanes);

    if ( workInProgress.mode & StrictMode) {
      disableLogs();

      try {
        nextChildren = renderWithHooks(current, workInProgress, render, nextProps, ref, renderLanes);
      } finally {
        reenableLogs();
      }
    }

    setIsRendering(false);
  }

  if (current !== null && !didReceiveUpdate) {
    bailoutHooks(current, workInProgress, renderLanes);
    return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);
  } // React DevTools reads this flag.


  workInProgress.flags |= PerformedWork;
  reconcileChildren(current, workInProgress, nextChildren, renderLanes);
  return workInProgress.child;
}

function updateMemoComponent(current, workInProgress, Component, nextProps, updateLanes, renderLanes) {
  if (current === null) {
    var type = Component.type;

    if (isSimpleFunctionComponent(type) && Component.compare === null && // SimpleMemoComponent codepath doesn't resolve outer props either.
    Component.defaultProps === undefined) {
      var resolvedType = type;

      {
        resolvedType = resolveFunctionForHotReloading(type);
      } // If this is a plain function component without default props,
      // and with only the default shallow comparison, we upgrade it
      // to a SimpleMemoComponent to allow fast path updates.


      workInProgress.tag = SimpleMemoComponent;
      workInProgress.type = resolvedType;

      {
        validateFunctionComponentInDev(workInProgress, type);
      }

      return updateSimpleMemoComponent(current, workInProgress, resolvedType, nextProps, updateLanes, renderLanes);
    }

    {
      var innerPropTypes = type.propTypes;

      if (innerPropTypes) {
        // Inner memo component props aren't currently validated in createElement.
        // We could move it there, but we'd still need this for lazy code path.
        checkPropTypes(innerPropTypes, nextProps, // Resolved props
        'prop', getComponentName(type));
      }
    }

    var child = createFiberFromTypeAndProps(Component.type, null, nextProps, workInProgress, workInProgress.mode, renderLanes);
    child.ref = workInProgress.ref;
    child.return = workInProgress;
    workInProgress.child = child;
    return child;
  }

  {
    var _type = Component.type;
    var _innerPropTypes = _type.propTypes;

    if (_innerPropTypes) {
      // Inner memo component props aren't currently validated in createElement.
      // We could move it there, but we'd still need this for lazy code path.
      checkPropTypes(_innerPropTypes, nextProps, // Resolved props
      'prop', getComponentName(_type));
    }
  }

  var currentChild = current.child; // This is always exactly one child

  if (!includesSomeLane(updateLanes, renderLanes)) {
    // This will be the props with resolved defaultProps,
    // unlike current.memoizedProps which will be the unresolved ones.
    var prevProps = currentChild.memoizedProps; // Default to shallow comparison

    var compare = Component.compare;
    compare = compare !== null ? compare : shallowEqual;

    if (compare(prevProps, nextProps) && current.ref === workInProgress.ref) {
      return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);
    }
  } // React DevTools reads this flag.


  workInProgress.flags |= PerformedWork;
  var newChild = createWorkInProgress(currentChild, nextProps);
  newChild.ref = workInProgress.ref;
  newChild.return = workInProgress;
  workInProgress.child = newChild;
  return newChild;
}

function updateSimpleMemoComponent(current, workInProgress, Component, nextProps, updateLanes, renderLanes) {
  // TODO: current can be non-null here even if the component
  // hasn't yet mounted. This happens when the inner render suspends.
  // We'll need to figure out if this is fine or can cause issues.
  {
    if (workInProgress.type !== workInProgress.elementType) {
      // Lazy component props can't be validated in createElement
      // because they're only guaranteed to be resolved here.
      var outerMemoType = workInProgress.elementType;

      if (outerMemoType.$$typeof === REACT_LAZY_TYPE) {
        // We warn when you define propTypes on lazy()
        // so let's just skip over it to find memo() outer wrapper.
        // Inner props for memo are validated later.
        var lazyComponent = outerMemoType;
        var payload = lazyComponent._payload;
        var init = lazyComponent._init;

        try {
          outerMemoType = init(payload);
        } catch (x) {
          outerMemoType = null;
        } // Inner propTypes will be validated in the function component path.


        var outerPropTypes = outerMemoType && outerMemoType.propTypes;

        if (outerPropTypes) {
          checkPropTypes(outerPropTypes, nextProps, // Resolved (SimpleMemoComponent has no defaultProps)
          'prop', getComponentName(outerMemoType));
        }
      }
    }
  }

  if (current !== null) {
    var prevProps = current.memoizedProps;

    if (shallowEqual(prevProps, nextProps) && current.ref === workInProgress.ref && ( // Prevent bailout if the implementation changed due to hot reload.
     workInProgress.type === current.type )) {
      didReceiveUpdate = false;

      if (!includesSomeLane(renderLanes, updateLanes)) {
        // The pending lanes were cleared at the beginning of beginWork. We're
        // about to bail out, but there might be other lanes that weren't
        // included in the current render. Usually, the priority level of the
        // remaining updates is accumlated during the evaluation of the
        // component (i.e. when processing the update queue). But since since
        // we're bailing out early *without* evaluating the component, we need
        // to account for it here, too. Reset to the value of the current fiber.
        // NOTE: This only applies to SimpleMemoComponent, not MemoComponent,
        // because a MemoComponent fiber does not have hooks or an update queue;
        // rather, it wraps around an inner component, which may or may not
        // contains hooks.
        // TODO: Move the reset at in beginWork out of the common path so that
        // this is no longer necessary.
        workInProgress.lanes = current.lanes;
        return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);
      } else if ((current.flags & ForceUpdateForLegacySuspense) !== NoFlags) {
        // This is a special case that only exists for legacy mode.
        // See https://github.com/facebook/react/pull/19216.
        didReceiveUpdate = true;
      }
    }
  }

  return updateFunctionComponent(current, workInProgress, Component, nextProps, renderLanes);
}

function updateOffscreenComponent(current, workInProgress, renderLanes) {
  var nextProps = workInProgress.pendingProps;
  var nextChildren = nextProps.children;
  var prevState = current !== null ? current.memoizedState : null;

  if (nextProps.mode === 'hidden' || nextProps.mode === 'unstable-defer-without-hiding') {
    if ((workInProgress.mode & ConcurrentMode) === NoMode) {
      // In legacy sync mode, don't defer the subtree. Render it now.
      // TODO: Figure out what we should do in Blocking mode.
      var nextState = {
        baseLanes: NoLanes
      };
      workInProgress.memoizedState = nextState;
      pushRenderLanes(workInProgress, renderLanes);
    } else if (!includesSomeLane(renderLanes, OffscreenLane)) {
      var nextBaseLanes;

      if (prevState !== null) {
        var prevBaseLanes = prevState.baseLanes;
        nextBaseLanes = mergeLanes(prevBaseLanes, renderLanes);
      } else {
        nextBaseLanes = renderLanes;
      } // Schedule this fiber to re-render at offscreen priority. Then bailout.


      {
        markSpawnedWork(OffscreenLane);
      }

      workInProgress.lanes = workInProgress.childLanes = laneToLanes(OffscreenLane);
      var _nextState = {
        baseLanes: nextBaseLanes
      };
      workInProgress.memoizedState = _nextState; // We're about to bail out, but we need to push this to the stack anyway
      // to avoid a push/pop misalignment.

      pushRenderLanes(workInProgress, nextBaseLanes);
      return null;
    } else {
      // Rendering at offscreen, so we can clear the base lanes.
      var _nextState2 = {
        baseLanes: NoLanes
      };
      workInProgress.memoizedState = _nextState2; // Push the lanes that were skipped when we bailed out.

      var subtreeRenderLanes = prevState !== null ? prevState.baseLanes : renderLanes;
      pushRenderLanes(workInProgress, subtreeRenderLanes);
    }
  } else {
    var _subtreeRenderLanes;

    if (prevState !== null) {
      _subtreeRenderLanes = mergeLanes(prevState.baseLanes, renderLanes); // Since we're not hidden anymore, reset the state

      workInProgress.memoizedState = null;
    } else {
      // We weren't previously hidden, and we still aren't, so there's nothing
      // special to do. Need to push to the stack regardless, though, to avoid
      // a push/pop misalignment.
      _subtreeRenderLanes = renderLanes;
    }

    pushRenderLanes(workInProgress, _subtreeRenderLanes);
  }

  reconcileChildren(current, workInProgress, nextChildren, renderLanes);
  return workInProgress.child;
} // Note: These happen to have identical begin phases, for now. We shouldn't hold
// ourselves to this constraint, though. If the behavior diverges, we should
// fork the function.


var updateLegacyHiddenComponent = updateOffscreenComponent;

function updateFragment(current, workInProgress, renderLanes) {
  var nextChildren = workInProgress.pendingProps;
  reconcileChildren(current, workInProgress, nextChildren, renderLanes);
  return workInProgress.child;
}

function updateMode(current, workInProgress, renderLanes) {
  var nextChildren = workInProgress.pendingProps.children;
  reconcileChildren(current, workInProgress, nextChildren, renderLanes);
  return workInProgress.child;
}

function updateProfiler(current, workInProgress, renderLanes) {
  {
    workInProgress.flags |= Update; // Reset effect durations for the next eventual effect phase.
    // These are reset during render to allow the DevTools commit hook a chance to read them,

    var stateNode = workInProgress.stateNode;
    stateNode.effectDuration = 0;
    stateNode.passiveEffectDuration = 0;
  }

  var nextProps = workInProgress.pendingProps;
  var nextChildren = nextProps.children;
  reconcileChildren(current, workInProgress, nextChildren, renderLanes);
  return workInProgress.child;
}

function markRef(current, workInProgress) {
  var ref = workInProgress.ref;

  if (current === null && ref !== null || current !== null && current.ref !== ref) {
    // Schedule a Ref effect
    workInProgress.flags |= Ref;
  }
}

function updateFunctionComponent(current, workInProgress, Component, nextProps, renderLanes) {
  {
    if (workInProgress.type !== workInProgress.elementType) {
      // Lazy component props can't be validated in createElement
      // because they're only guaranteed to be resolved here.
      var innerPropTypes = Component.propTypes;

      if (innerPropTypes) {
        checkPropTypes(innerPropTypes, nextProps, // Resolved props
        'prop', getComponentName(Component));
      }
    }
  }

  var context;

  {
    var unmaskedContext = getUnmaskedContext(workInProgress, Component, true);
    context = getMaskedContext(workInProgress, unmaskedContext);
  }

  var nextChildren;
  prepareToReadContext(workInProgress, renderLanes);

  {
    ReactCurrentOwner$1.current = workInProgress;
    setIsRendering(true);
    nextChildren = renderWithHooks(current, workInProgress, Component, nextProps, context, renderLanes);

    if ( workInProgress.mode & StrictMode) {
      disableLogs();

      try {
        nextChildren = renderWithHooks(current, workInProgress, Component, nextProps, context, renderLanes);
      } finally {
        reenableLogs();
      }
    }

    setIsRendering(false);
  }

  if (current !== null && !didReceiveUpdate) {
    bailoutHooks(current, workInProgress, renderLanes);
    return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);
  } // React DevTools reads this flag.


  workInProgress.flags |= PerformedWork;
  reconcileChildren(current, workInProgress, nextChildren, renderLanes);
  return workInProgress.child;
}

function updateClassComponent(current, workInProgress, Component, nextProps, renderLanes) {
  {
    if (workInProgress.type !== workInProgress.elementType) {
      // Lazy component props can't be validated in createElement
      // because they're only guaranteed to be resolved here.
      var innerPropTypes = Component.propTypes;

      if (innerPropTypes) {
        checkPropTypes(innerPropTypes, nextProps, // Resolved props
        'prop', getComponentName(Component));
      }
    }
  } // Push context providers early to prevent context stack mismatches.
  // During mounting we don't know the child context yet as the instance doesn't exist.
  // We will invalidate the child context in finishClassComponent() right after rendering.


  var hasContext;

  if (isContextProvider(Component)) {
    hasContext = true;
    pushContextProvider(workInProgress);
  } else {
    hasContext = false;
  }

  prepareToReadContext(workInProgress, renderLanes);
  var instance = workInProgress.stateNode;
  var shouldUpdate;

  if (instance === null) {
    if (current !== null) {
      // A class component without an instance only mounts if it suspended
      // inside a non-concurrent tree, in an inconsistent state. We want to
      // treat it like a new mount, even though an empty version of it already
      // committed. Disconnect the alternate pointers.
      current.alternate = null;
      workInProgress.alternate = null; // Since this is conceptually a new fiber, schedule a Placement effect

      workInProgress.flags |= Placement;
    } // In the initial pass we might need to construct the instance.


    constructClassInstance(workInProgress, Component, nextProps);
    mountClassInstance(workInProgress, Component, nextProps, renderLanes);
    shouldUpdate = true;
  } else if (current === null) {
    // In a resume, we'll already have an instance we can reuse.
    shouldUpdate = resumeMountClassInstance(workInProgress, Component, nextProps, renderLanes);
  } else {
    shouldUpdate = updateClassInstance(current, workInProgress, Component, nextProps, renderLanes);
  }

  var nextUnitOfWork = finishClassComponent(current, workInProgress, Component, shouldUpdate, hasContext, renderLanes);

  {
    var inst = workInProgress.stateNode;

    if (shouldUpdate && inst.props !== nextProps) {
      if (!didWarnAboutReassigningProps) {
        error('It looks like %s is reassigning its own `this.props` while rendering. ' + 'This is not supported and can lead to confusing bugs.', getComponentName(workInProgress.type) || 'a component');
      }

      didWarnAboutReassigningProps = true;
    }
  }

  return nextUnitOfWork;
}

function finishClassComponent(current, workInProgress, Component, shouldUpdate, hasContext, renderLanes) {
  // Refs should update even if shouldComponentUpdate returns false
  markRef(current, workInProgress);
  var didCaptureError = (workInProgress.flags & DidCapture) !== NoFlags;

  if (!shouldUpdate && !didCaptureError) {
    // Context providers should defer to sCU for rendering
    if (hasContext) {
      invalidateContextProvider(workInProgress, Component, false);
    }

    return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);
  }

  var instance = workInProgress.stateNode; // Rerender

  ReactCurrentOwner$1.current = workInProgress;
  var nextChildren;

  if (didCaptureError && typeof Component.getDerivedStateFromError !== 'function') {
    // If we captured an error, but getDerivedStateFromError is not defined,
    // unmount all the children. componentDidCatch will schedule an update to
    // re-render a fallback. This is temporary until we migrate everyone to
    // the new API.
    // TODO: Warn in a future release.
    nextChildren = null;

    {
      stopProfilerTimerIfRunning();
    }
  } else {
    {
      setIsRendering(true);
      nextChildren = instance.render();

      if ( workInProgress.mode & StrictMode) {
        disableLogs();

        try {
          instance.render();
        } finally {
          reenableLogs();
        }
      }

      setIsRendering(false);
    }
  } // React DevTools reads this flag.


  workInProgress.flags |= PerformedWork;

  if (current !== null && didCaptureError) {
    // If we're recovering from an error, reconcile without reusing any of
    // the existing children. Conceptually, the normal children and the children
    // that are shown on error are two different sets, so we shouldn't reuse
    // normal children even if their identities match.
    forceUnmountCurrentAndReconcile(current, workInProgress, nextChildren, renderLanes);
  } else {
    reconcileChildren(current, workInProgress, nextChildren, renderLanes);
  } // Memoize state using the values we just used to render.
  // TODO: Restructure so we never read values from the instance.


  workInProgress.memoizedState = instance.state; // The context might have changed so we need to recalculate it.

  if (hasContext) {
    invalidateContextProvider(workInProgress, Component, true);
  }

  return workInProgress.child;
}

function pushHostRootContext(workInProgress) {
  var root = workInProgress.stateNode;

  if (root.pendingContext) {
    pushTopLevelContextObject(workInProgress, root.pendingContext, root.pendingContext !== root.context);
  } else if (root.context) {
    // Should always be set
    pushTopLevelContextObject(workInProgress, root.context, false);
  }

  pushHostContainer(workInProgress, root.containerInfo);
}

function updateHostRoot(current, workInProgress, renderLanes) {
  pushHostRootContext(workInProgress);
  var updateQueue = workInProgress.updateQueue;

  if (!(current !== null && updateQueue !== null)) {
    {
      throw Error( "If the root does not have an updateQueue, we should have already bailed out. This error is likely caused by a bug in React. Please file an issue." );
    }
  }

  var nextProps = workInProgress.pendingProps;
  var prevState = workInProgress.memoizedState;
  var prevChildren = prevState !== null ? prevState.element : null;
  cloneUpdateQueue(current, workInProgress);
  processUpdateQueue(workInProgress, nextProps, null, renderLanes);
  var nextState = workInProgress.memoizedState; // Caution: React DevTools currently depends on this property
  // being called "element".

  var nextChildren = nextState.element;

  if (nextChildren === prevChildren) {
    resetHydrationState();
    return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);
  }

  var root = workInProgress.stateNode;

  if (root.hydrate && enterHydrationState(workInProgress)) {
    // If we don't have any current children this might be the first pass.
    // We always try to hydrate. If this isn't a hydration pass there won't
    // be any children to hydrate which is effectively the same thing as
    // not hydrating.
    {
      var mutableSourceEagerHydrationData = root.mutableSourceEagerHydrationData;

      if (mutableSourceEagerHydrationData != null) {
        for (var i = 0; i < mutableSourceEagerHydrationData.length; i += 2) {
          var mutableSource = mutableSourceEagerHydrationData[i];
          var version = mutableSourceEagerHydrationData[i + 1];
          setWorkInProgressVersion(mutableSource, version);
        }
      }
    }

    var child = mountChildFibers(workInProgress, null, nextChildren, renderLanes);
    workInProgress.child = child;
    var node = child;

    while (node) {
      // Mark each child as hydrating. This is a fast path to know whether this
      // tree is part of a hydrating tree. This is used to determine if a child
      // node has fully mounted yet, and for scheduling event replaying.
      // Conceptually this is similar to Placement in that a new subtree is
      // inserted into the React tree here. It just happens to not need DOM
      // mutations because it already exists.
      node.flags = node.flags & ~Placement | Hydrating;
      node = node.sibling;
    }
  } else {
    // Otherwise reset hydration state in case we aborted and resumed another
    // root.
    reconcileChildren(current, workInProgress, nextChildren, renderLanes);
    resetHydrationState();
  }

  return workInProgress.child;
}

function updateHostComponent(current, workInProgress, renderLanes) {
  pushHostContext(workInProgress);

  if (current === null) {
    tryToClaimNextHydratableInstance(workInProgress);
  }

  var type = workInProgress.type;
  var nextProps = workInProgress.pendingProps;
  var prevProps = current !== null ? current.memoizedProps : null;
  var nextChildren = nextProps.children;
  var isDirectTextChild = shouldSetTextContent(type, nextProps);

  if (isDirectTextChild) {
    // We special case a direct text child of a host node. This is a common
    // case. We won't handle it as a reified child. We will instead handle
    // this in the host environment that also has access to this prop. That
    // avoids allocating another HostText fiber and traversing it.
    nextChildren = null;
  } else if (prevProps !== null && shouldSetTextContent(type, prevProps)) {
    // If we're switching from a direct text child to a normal child, or to
    // empty, we need to schedule the text content to be reset.
    workInProgress.flags |= ContentReset;
  }

  markRef(current, workInProgress);
  reconcileChildren(current, workInProgress, nextChildren, renderLanes);
  return workInProgress.child;
}

function updateHostText(current, workInProgress) {
  if (current === null) {
    tryToClaimNextHydratableInstance(workInProgress);
  } // Nothing to do here. This is terminal. We'll do the completion step
  // immediately after.


  return null;
}

function mountLazyComponent(_current, workInProgress, elementType, updateLanes, renderLanes) {
  if (_current !== null) {
    // A lazy component only mounts if it suspended inside a non-
    // concurrent tree, in an inconsistent state. We want to treat it like
    // a new mount, even though an empty version of it already committed.
    // Disconnect the alternate pointers.
    _current.alternate = null;
    workInProgress.alternate = null; // Since this is conceptually a new fiber, schedule a Placement effect

    workInProgress.flags |= Placement;
  }

  var props = workInProgress.pendingProps;
  var lazyComponent = elementType;
  var payload = lazyComponent._payload;
  var init = lazyComponent._init;
  var Component = init(payload); // Store the unwrapped component in the type.

  workInProgress.type = Component;
  var resolvedTag = workInProgress.tag = resolveLazyComponentTag(Component);
  var resolvedProps = resolveDefaultProps(Component, props);
  var child;

  switch (resolvedTag) {
    case FunctionComponent:
      {
        {
          validateFunctionComponentInDev(workInProgress, Component);
          workInProgress.type = Component = resolveFunctionForHotReloading(Component);
        }

        child = updateFunctionComponent(null, workInProgress, Component, resolvedProps, renderLanes);
        return child;
      }

    case ClassComponent:
      {
        {
          workInProgress.type = Component = resolveClassForHotReloading(Component);
        }

        child = updateClassComponent(null, workInProgress, Component, resolvedProps, renderLanes);
        return child;
      }

    case ForwardRef:
      {
        {
          workInProgress.type = Component = resolveForwardRefForHotReloading(Component);
        }

        child = updateForwardRef(null, workInProgress, Component, resolvedProps, renderLanes);
        return child;
      }

    case MemoComponent:
      {
        {
          if (workInProgress.type !== workInProgress.elementType) {
            var outerPropTypes = Component.propTypes;

            if (outerPropTypes) {
              checkPropTypes(outerPropTypes, resolvedProps, // Resolved for outer only
              'prop', getComponentName(Component));
            }
          }
        }

        child = updateMemoComponent(null, workInProgress, Component, resolveDefaultProps(Component.type, resolvedProps), // The inner type can have defaults too
        updateLanes, renderLanes);
        return child;
      }
  }

  var hint = '';

  {
    if (Component !== null && typeof Component === 'object' && Component.$$typeof === REACT_LAZY_TYPE) {
      hint = ' Did you wrap a component in React.lazy() more than once?';
    }
  } // This message intentionally doesn't mention ForwardRef or MemoComponent
  // because the fact that it's a separate type of work is an
  // implementation detail.


  {
    {
      throw Error( "Element type is invalid. Received a promise that resolves to: " + Component + ". Lazy element type must resolve to a class or function." + hint );
    }
  }
}

function mountIncompleteClassComponent(_current, workInProgress, Component, nextProps, renderLanes) {
  if (_current !== null) {
    // An incomplete component only mounts if it suspended inside a non-
    // concurrent tree, in an inconsistent state. We want to treat it like
    // a new mount, even though an empty version of it already committed.
    // Disconnect the alternate pointers.
    _current.alternate = null;
    workInProgress.alternate = null; // Since this is conceptually a new fiber, schedule a Placement effect

    workInProgress.flags |= Placement;
  } // Promote the fiber to a class and try rendering again.


  workInProgress.tag = ClassComponent; // The rest of this function is a fork of `updateClassComponent`
  // Push context providers early to prevent context stack mismatches.
  // During mounting we don't know the child context yet as the instance doesn't exist.
  // We will invalidate the child context in finishClassComponent() right after rendering.

  var hasContext;

  if (isContextProvider(Component)) {
    hasContext = true;
    pushContextProvider(workInProgress);
  } else {
    hasContext = false;
  }

  prepareToReadContext(workInProgress, renderLanes);
  constructClassInstance(workInProgress, Component, nextProps);
  mountClassInstance(workInProgress, Component, nextProps, renderLanes);
  return finishClassComponent(null, workInProgress, Component, true, hasContext, renderLanes);
}

function mountIndeterminateComponent(_current, workInProgress, Component, renderLanes) {
  if (_current !== null) {
    // An indeterminate component only mounts if it suspended inside a non-
    // concurrent tree, in an inconsistent state. We want to treat it like
    // a new mount, even though an empty version of it already committed.
    // Disconnect the alternate pointers.
    _current.alternate = null;
    workInProgress.alternate = null; // Since this is conceptually a new fiber, schedule a Placement effect

    workInProgress.flags |= Placement;
  }

  var props = workInProgress.pendingProps;
  var context;

  {
    var unmaskedContext = getUnmaskedContext(workInProgress, Component, false);
    context = getMaskedContext(workInProgress, unmaskedContext);
  }

  prepareToReadContext(workInProgress, renderLanes);
  var value;

  {
    if (Component.prototype && typeof Component.prototype.render === 'function') {
      var componentName = getComponentName(Component) || 'Unknown';

      if (!didWarnAboutBadClass[componentName]) {
        error("The <%s /> component appears to have a render method, but doesn't extend React.Component. " + 'This is likely to cause errors. Change %s to extend React.Component instead.', componentName, componentName);

        didWarnAboutBadClass[componentName] = true;
      }
    }

    if (workInProgress.mode & StrictMode) {
      ReactStrictModeWarnings.recordLegacyContextWarning(workInProgress, null);
    }

    setIsRendering(true);
    ReactCurrentOwner$1.current = workInProgress;
    value = renderWithHooks(null, workInProgress, Component, props, context, renderLanes);
    setIsRendering(false);
  } // React DevTools reads this flag.


  workInProgress.flags |= PerformedWork;

  {
    // Support for module components is deprecated and is removed behind a flag.
    // Whether or not it would crash later, we want to show a good message in DEV first.
    if (typeof value === 'object' && value !== null && typeof value.render === 'function' && value.$$typeof === undefined) {
      var _componentName = getComponentName(Component) || 'Unknown';

      if (!didWarnAboutModulePatternComponent[_componentName]) {
        error('The <%s /> component appears to be a function component that returns a class instance. ' + 'Change %s to a class that extends React.Component instead. ' + "If you can't use a class try assigning the prototype on the function as a workaround. " + "`%s.prototype = React.Component.prototype`. Don't use an arrow function since it " + 'cannot be called with `new` by React.', _componentName, _componentName, _componentName);

        didWarnAboutModulePatternComponent[_componentName] = true;
      }
    }
  }

  if ( // Run these checks in production only if the flag is off.
  // Eventually we'll delete this branch altogether.
   typeof value === 'object' && value !== null && typeof value.render === 'function' && value.$$typeof === undefined) {
    {
      var _componentName2 = getComponentName(Component) || 'Unknown';

      if (!didWarnAboutModulePatternComponent[_componentName2]) {
        error('The <%s /> component appears to be a function component that returns a class instance. ' + 'Change %s to a class that extends React.Component instead. ' + "If you can't use a class try assigning the prototype on the function as a workaround. " + "`%s.prototype = React.Component.prototype`. Don't use an arrow function since it " + 'cannot be called with `new` by React.', _componentName2, _componentName2, _componentName2);

        didWarnAboutModulePatternComponent[_componentName2] = true;
      }
    } // Proceed under the assumption that this is a class instance


    workInProgress.tag = ClassComponent; // Throw out any hooks that were used.

    workInProgress.memoizedState = null;
    workInProgress.updateQueue = null; // Push context providers early to prevent context stack mismatches.
    // During mounting we don't know the child context yet as the instance doesn't exist.
    // We will invalidate the child context in finishClassComponent() right after rendering.

    var hasContext = false;

    if (isContextProvider(Component)) {
      hasContext = true;
      pushContextProvider(workInProgress);
    } else {
      hasContext = false;
    }

    workInProgress.memoizedState = value.state !== null && value.state !== undefined ? value.state : null;
    initializeUpdateQueue(workInProgress);
    var getDerivedStateFromProps = Component.getDerivedStateFromProps;

    if (typeof getDerivedStateFromProps === 'function') {
      applyDerivedStateFromProps(workInProgress, Component, getDerivedStateFromProps, props);
    }

    adoptClassInstance(workInProgress, value);
    mountClassInstance(workInProgress, Component, props, renderLanes);
    return finishClassComponent(null, workInProgress, Component, true, hasContext, renderLanes);
  } else {
    // Proceed under the assumption that this is a function component
    workInProgress.tag = FunctionComponent;

    {

      if ( workInProgress.mode & StrictMode) {
        disableLogs();

        try {
          value = renderWithHooks(null, workInProgress, Component, props, context, renderLanes);
        } finally {
          reenableLogs();
        }
      }
    }

    reconcileChildren(null, workInProgress, value, renderLanes);

    {
      validateFunctionComponentInDev(workInProgress, Component);
    }

    return workInProgress.child;
  }
}

function validateFunctionComponentInDev(workInProgress, Component) {
  {
    if (Component) {
      if (Component.childContextTypes) {
        error('%s(...): childContextTypes cannot be defined on a function component.', Component.displayName || Component.name || 'Component');
      }
    }

    if (workInProgress.ref !== null) {
      var info = '';
      var ownerName = getCurrentFiberOwnerNameInDevOrNull();

      if (ownerName) {
        info += '\n\nCheck the render method of `' + ownerName + '`.';
      }

      var warningKey = ownerName || workInProgress._debugID || '';
      var debugSource = workInProgress._debugSource;

      if (debugSource) {
        warningKey = debugSource.fileName + ':' + debugSource.lineNumber;
      }

      if (!didWarnAboutFunctionRefs[warningKey]) {
        didWarnAboutFunctionRefs[warningKey] = true;

        error('Function components cannot be given refs. ' + 'Attempts to access this ref will fail. ' + 'Did you mean to use React.forwardRef()?%s', info);
      }
    }

    if (typeof Component.getDerivedStateFromProps === 'function') {
      var _componentName3 = getComponentName(Component) || 'Unknown';

      if (!didWarnAboutGetDerivedStateOnFunctionComponent[_componentName3]) {
        error('%s: Function components do not support getDerivedStateFromProps.', _componentName3);

        didWarnAboutGetDerivedStateOnFunctionComponent[_componentName3] = true;
      }
    }

    if (typeof Component.contextType === 'object' && Component.contextType !== null) {
      var _componentName4 = getComponentName(Component) || 'Unknown';

      if (!didWarnAboutContextTypeOnFunctionComponent[_componentName4]) {
        error('%s: Function components do not support contextType.', _componentName4);

        didWarnAboutContextTypeOnFunctionComponent[_componentName4] = true;
      }
    }
  }
}

var SUSPENDED_MARKER = {
  dehydrated: null,
  retryLane: NoLane
};

function mountSuspenseOffscreenState(renderLanes) {
  return {
    baseLanes: renderLanes
  };
}

function updateSuspenseOffscreenState(prevOffscreenState, renderLanes) {
  return {
    baseLanes: mergeLanes(prevOffscreenState.baseLanes, renderLanes)
  };
} // TODO: Probably should inline this back


function shouldRemainOnFallback(suspenseContext, current, workInProgress, renderLanes) {
  // If we're already showing a fallback, there are cases where we need to
  // remain on that fallback regardless of whether the content has resolved.
  // For example, SuspenseList coordinates when nested content appears.
  if (current !== null) {
    var suspenseState = current.memoizedState;

    if (suspenseState === null) {
      // Currently showing content. Don't hide it, even if ForceSuspenseFallack
      // is true. More precise name might be "ForceRemainSuspenseFallback".
      // Note: This is a factoring smell. Can't remain on a fallback if there's
      // no fallback to remain on.
      return false;
    }
  } // Not currently showing content. Consult the Suspense context.


  return hasSuspenseContext(suspenseContext, ForceSuspenseFallback);
}

function getRemainingWorkInPrimaryTree(current, renderLanes) {
  // TODO: Should not remove render lanes that were pinged during this render
  return removeLanes(current.childLanes, renderLanes);
}

function updateSuspenseComponent(current, workInProgress, renderLanes) {
  var nextProps = workInProgress.pendingProps; // This is used by DevTools to force a boundary to suspend.

  {
    if (shouldSuspend(workInProgress)) {
      workInProgress.flags |= DidCapture;
    }
  }

  var suspenseContext = suspenseStackCursor.current;
  var showFallback = false;
  var didSuspend = (workInProgress.flags & DidCapture) !== NoFlags;

  if (didSuspend || shouldRemainOnFallback(suspenseContext, current)) {
    // Something in this boundary's subtree already suspended. Switch to
    // rendering the fallback children.
    showFallback = true;
    workInProgress.flags &= ~DidCapture;
  } else {
    // Attempting the main content
    if (current === null || current.memoizedState !== null) {
      // This is a new mount or this boundary is already showing a fallback state.
      // Mark this subtree context as having at least one invisible parent that could
      // handle the fallback state.
      // Boundaries without fallbacks or should be avoided are not considered since
      // they cannot handle preferred fallback states.
      if (nextProps.fallback !== undefined && nextProps.unstable_avoidThisFallback !== true) {
        suspenseContext = addSubtreeSuspenseContext(suspenseContext, InvisibleParentSuspenseContext);
      }
    }
  }

  suspenseContext = setDefaultShallowSuspenseContext(suspenseContext);
  pushSuspenseContext(workInProgress, suspenseContext); // OK, the next part is confusing. We're about to reconcile the Suspense
  // boundary's children. This involves some custom reconcilation logic. Two
  // main reasons this is so complicated.
  //
  // First, Legacy Mode has different semantics for backwards compatibility. The
  // primary tree will commit in an inconsistent state, so when we do the
  // second pass to render the fallback, we do some exceedingly, uh, clever
  // hacks to make that not totally break. Like transferring effects and
  // deletions from hidden tree. In Concurrent Mode, it's much simpler,
  // because we bailout on the primary tree completely and leave it in its old
  // state, no effects. Same as what we do for Offscreen (except that
  // Offscreen doesn't have the first render pass).
  //
  // Second is hydration. During hydration, the Suspense fiber has a slightly
  // different layout, where the child points to a dehydrated fragment, which
  // contains the DOM rendered by the server.
  //
  // Third, even if you set all that aside, Suspense is like error boundaries in
  // that we first we try to render one tree, and if that fails, we render again
  // and switch to a different tree. Like a try/catch block. So we have to track
  // which branch we're currently rendering. Ideally we would model this using
  // a stack.

  if (current === null) {
    // Initial mount
    // If we're currently hydrating, try to hydrate this boundary.
    // But only if this has a fallback.
    if (nextProps.fallback !== undefined) {
      tryToClaimNextHydratableInstance(workInProgress); // This could've been a dehydrated suspense component.
    }

    var nextPrimaryChildren = nextProps.children;
    var nextFallbackChildren = nextProps.fallback;

    if (showFallback) {
      var fallbackFragment = mountSuspenseFallbackChildren(workInProgress, nextPrimaryChildren, nextFallbackChildren, renderLanes);
      var primaryChildFragment = workInProgress.child;
      primaryChildFragment.memoizedState = mountSuspenseOffscreenState(renderLanes);
      workInProgress.memoizedState = SUSPENDED_MARKER;
      return fallbackFragment;
    } else if (typeof nextProps.unstable_expectedLoadTime === 'number') {
      // This is a CPU-bound tree. Skip this tree and show a placeholder to
      // unblock the surrounding content. Then immediately retry after the
      // initial commit.
      var _fallbackFragment = mountSuspenseFallbackChildren(workInProgress, nextPrimaryChildren, nextFallbackChildren, renderLanes);

      var _primaryChildFragment = workInProgress.child;
      _primaryChildFragment.memoizedState = mountSuspenseOffscreenState(renderLanes);
      workInProgress.memoizedState = SUSPENDED_MARKER; // Since nothing actually suspended, there will nothing to ping this to
      // get it started back up to attempt the next item. While in terms of
      // priority this work has the same priority as this current render, it's
      // not part of the same transition once the transition has committed. If
      // it's sync, we still want to yield so that it can be painted.
      // Conceptually, this is really the same as pinging. We can use any
      // RetryLane even if it's the one currently rendering since we're leaving
      // it behind on this node.

      workInProgress.lanes = SomeRetryLane;

      {
        markSpawnedWork(SomeRetryLane);
      }

      return _fallbackFragment;
    } else {
      return mountSuspensePrimaryChildren(workInProgress, nextPrimaryChildren, renderLanes);
    }
  } else {
    // This is an update.
    // If the current fiber has a SuspenseState, that means it's already showing
    // a fallback.
    var prevState = current.memoizedState;

    if (prevState !== null) {

      if (showFallback) {
        var _nextFallbackChildren2 = nextProps.fallback;
        var _nextPrimaryChildren2 = nextProps.children;

        var _fallbackChildFragment = updateSuspenseFallbackChildren(current, workInProgress, _nextPrimaryChildren2, _nextFallbackChildren2, renderLanes);

        var _primaryChildFragment3 = workInProgress.child;
        var prevOffscreenState = current.child.memoizedState;
        _primaryChildFragment3.memoizedState = prevOffscreenState === null ? mountSuspenseOffscreenState(renderLanes) : updateSuspenseOffscreenState(prevOffscreenState, renderLanes);
        _primaryChildFragment3.childLanes = getRemainingWorkInPrimaryTree(current, renderLanes);
        workInProgress.memoizedState = SUSPENDED_MARKER;
        return _fallbackChildFragment;
      } else {
        var _nextPrimaryChildren3 = nextProps.children;

        var _primaryChildFragment4 = updateSuspensePrimaryChildren(current, workInProgress, _nextPrimaryChildren3, renderLanes);

        workInProgress.memoizedState = null;
        return _primaryChildFragment4;
      }
    } else {
      // The current tree is not already showing a fallback.
      if (showFallback) {
        // Timed out.
        var _nextFallbackChildren3 = nextProps.fallback;
        var _nextPrimaryChildren4 = nextProps.children;

        var _fallbackChildFragment2 = updateSuspenseFallbackChildren(current, workInProgress, _nextPrimaryChildren4, _nextFallbackChildren3, renderLanes);

        var _primaryChildFragment5 = workInProgress.child;
        var _prevOffscreenState = current.child.memoizedState;
        _primaryChildFragment5.memoizedState = _prevOffscreenState === null ? mountSuspenseOffscreenState(renderLanes) : updateSuspenseOffscreenState(_prevOffscreenState, renderLanes);
        _primaryChildFragment5.childLanes = getRemainingWorkInPrimaryTree(current, renderLanes); // Skip the primary children, and continue working on the
        // fallback children.

        workInProgress.memoizedState = SUSPENDED_MARKER;
        return _fallbackChildFragment2;
      } else {
        // Still haven't timed out. Continue rendering the children, like we
        // normally do.
        var _nextPrimaryChildren5 = nextProps.children;

        var _primaryChildFragment6 = updateSuspensePrimaryChildren(current, workInProgress, _nextPrimaryChildren5, renderLanes);

        workInProgress.memoizedState = null;
        return _primaryChildFragment6;
      }
    }
  }
}

function mountSuspensePrimaryChildren(workInProgress, primaryChildren, renderLanes) {
  var mode = workInProgress.mode;
  var primaryChildProps = {
    mode: 'visible',
    children: primaryChildren
  };
  var primaryChildFragment = createFiberFromOffscreen(primaryChildProps, mode, renderLanes, null);
  primaryChildFragment.return = workInProgress;
  workInProgress.child = primaryChildFragment;
  return primaryChildFragment;
}

function mountSuspenseFallbackChildren(workInProgress, primaryChildren, fallbackChildren, renderLanes) {
  var mode = workInProgress.mode;
  var progressedPrimaryFragment = workInProgress.child;
  var primaryChildProps = {
    mode: 'hidden',
    children: primaryChildren
  };
  var primaryChildFragment;
  var fallbackChildFragment;

  if ((mode & BlockingMode) === NoMode && progressedPrimaryFragment !== null) {
    // In legacy mode, we commit the primary tree as if it successfully
    // completed, even though it's in an inconsistent state.
    primaryChildFragment = progressedPrimaryFragment;
    primaryChildFragment.childLanes = NoLanes;
    primaryChildFragment.pendingProps = primaryChildProps;

    if ( workInProgress.mode & ProfileMode) {
      // Reset the durations from the first pass so they aren't included in the
      // final amounts. This seems counterintuitive, since we're intentionally
      // not measuring part of the render phase, but this makes it match what we
      // do in Concurrent Mode.
      primaryChildFragment.actualDuration = 0;
      primaryChildFragment.actualStartTime = -1;
      primaryChildFragment.selfBaseDuration = 0;
      primaryChildFragment.treeBaseDuration = 0;
    }

    fallbackChildFragment = createFiberFromFragment(fallbackChildren, mode, renderLanes, null);
  } else {
    primaryChildFragment = createFiberFromOffscreen(primaryChildProps, mode, NoLanes, null);
    fallbackChildFragment = createFiberFromFragment(fallbackChildren, mode, renderLanes, null);
  }

  primaryChildFragment.return = workInProgress;
  fallbackChildFragment.return = workInProgress;
  primaryChildFragment.sibling = fallbackChildFragment;
  workInProgress.child = primaryChildFragment;
  return fallbackChildFragment;
}

function createWorkInProgressOffscreenFiber(current, offscreenProps) {
  // The props argument to `createWorkInProgress` is `any` typed, so we use this
  // wrapper function to constrain it.
  return createWorkInProgress(current, offscreenProps);
}

function updateSuspensePrimaryChildren(current, workInProgress, primaryChildren, renderLanes) {
  var currentPrimaryChildFragment = current.child;
  var currentFallbackChildFragment = currentPrimaryChildFragment.sibling;
  var primaryChildFragment = createWorkInProgressOffscreenFiber(currentPrimaryChildFragment, {
    mode: 'visible',
    children: primaryChildren
  });

  if ((workInProgress.mode & BlockingMode) === NoMode) {
    primaryChildFragment.lanes = renderLanes;
  }

  primaryChildFragment.return = workInProgress;
  primaryChildFragment.sibling = null;

  if (currentFallbackChildFragment !== null) {
    // Delete the fallback child fragment
    currentFallbackChildFragment.nextEffect = null;
    currentFallbackChildFragment.flags = Deletion;
    workInProgress.firstEffect = workInProgress.lastEffect = currentFallbackChildFragment;
  }

  workInProgress.child = primaryChildFragment;
  return primaryChildFragment;
}

function updateSuspenseFallbackChildren(current, workInProgress, primaryChildren, fallbackChildren, renderLanes) {
  var mode = workInProgress.mode;
  var currentPrimaryChildFragment = current.child;
  var currentFallbackChildFragment = currentPrimaryChildFragment.sibling;
  var primaryChildProps = {
    mode: 'hidden',
    children: primaryChildren
  };
  var primaryChildFragment;

  if ( // In legacy mode, we commit the primary tree as if it successfully
  // completed, even though it's in an inconsistent state.
  (mode & BlockingMode) === NoMode && // Make sure we're on the second pass, i.e. the primary child fragment was
  // already cloned. In legacy mode, the only case where this isn't true is
  // when DevTools forces us to display a fallback; we skip the first render
  // pass entirely and go straight to rendering the fallback. (In Concurrent
  // Mode, SuspenseList can also trigger this scenario, but this is a legacy-
  // only codepath.)
  workInProgress.child !== currentPrimaryChildFragment) {
    var progressedPrimaryFragment = workInProgress.child;
    primaryChildFragment = progressedPrimaryFragment;
    primaryChildFragment.childLanes = NoLanes;
    primaryChildFragment.pendingProps = primaryChildProps;

    if ( workInProgress.mode & ProfileMode) {
      // Reset the durations from the first pass so they aren't included in the
      // final amounts. This seems counterintuitive, since we're intentionally
      // not measuring part of the render phase, but this makes it match what we
      // do in Concurrent Mode.
      primaryChildFragment.actualDuration = 0;
      primaryChildFragment.actualStartTime = -1;
      primaryChildFragment.selfBaseDuration = currentPrimaryChildFragment.selfBaseDuration;
      primaryChildFragment.treeBaseDuration = currentPrimaryChildFragment.treeBaseDuration;
    } // The fallback fiber was added as a deletion effect during the first pass.
    // However, since we're going to remain on the fallback, we no longer want
    // to delete it. So we need to remove it from the list. Deletions are stored
    // on the same list as effects. We want to keep the effects from the primary
    // tree. So we copy the primary child fragment's effect list, which does not
    // include the fallback deletion effect.


    var progressedLastEffect = primaryChildFragment.lastEffect;

    if (progressedLastEffect !== null) {
      workInProgress.firstEffect = primaryChildFragment.firstEffect;
      workInProgress.lastEffect = progressedLastEffect;
      progressedLastEffect.nextEffect = null;
    } else {
      // TODO: Reset this somewhere else? Lol legacy mode is so weird.
      workInProgress.firstEffect = workInProgress.lastEffect = null;
    }
  } else {
    primaryChildFragment = createWorkInProgressOffscreenFiber(currentPrimaryChildFragment, primaryChildProps);
  }

  var fallbackChildFragment;

  if (currentFallbackChildFragment !== null) {
    fallbackChildFragment = createWorkInProgress(currentFallbackChildFragment, fallbackChildren);
  } else {
    fallbackChildFragment = createFiberFromFragment(fallbackChildren, mode, renderLanes, null); // Needs a placement effect because the parent (the Suspense boundary) already
    // mounted but this is a new fiber.

    fallbackChildFragment.flags |= Placement;
  }

  fallbackChildFragment.return = workInProgress;
  primaryChildFragment.return = workInProgress;
  primaryChildFragment.sibling = fallbackChildFragment;
  workInProgress.child = primaryChildFragment;
  return fallbackChildFragment;
}

function scheduleWorkOnFiber(fiber, renderLanes) {
  fiber.lanes = mergeLanes(fiber.lanes, renderLanes);
  var alternate = fiber.alternate;

  if (alternate !== null) {
    alternate.lanes = mergeLanes(alternate.lanes, renderLanes);
  }

  scheduleWorkOnParentPath(fiber.return, renderLanes);
}

function propagateSuspenseContextChange(workInProgress, firstChild, renderLanes) {
  // Mark any Suspense boundaries with fallbacks as having work to do.
  // If they were previously forced into fallbacks, they may now be able
  // to unblock.
  var node = firstChild;

  while (node !== null) {
    if (node.tag === SuspenseComponent) {
      var state = node.memoizedState;

      if (state !== null) {
        scheduleWorkOnFiber(node, renderLanes);
      }
    } else if (node.tag === SuspenseListComponent) {
      // If the tail is hidden there might not be an Suspense boundaries
      // to schedule work on. In this case we have to schedule it on the
      // list itself.
      // We don't have to traverse to the children of the list since
      // the list will propagate the change when it rerenders.
      scheduleWorkOnFiber(node, renderLanes);
    } else if (node.child !== null) {
      node.child.return = node;
      node = node.child;
      continue;
    }

    if (node === workInProgress) {
      return;
    }

    while (node.sibling === null) {
      if (node.return === null || node.return === workInProgress) {
        return;
      }

      node = node.return;
    }

    node.sibling.return = node.return;
    node = node.sibling;
  }
}

function findLastContentRow(firstChild) {
  // This is going to find the last row among these children that is already
  // showing content on the screen, as opposed to being in fallback state or
  // new. If a row has multiple Suspense boundaries, any of them being in the
  // fallback state, counts as the whole row being in a fallback state.
  // Note that the "rows" will be workInProgress, but any nested children
  // will still be current since we haven't rendered them yet. The mounted
  // order may not be the same as the new order. We use the new order.
  var row = firstChild;
  var lastContentRow = null;

  while (row !== null) {
    var currentRow = row.alternate; // New rows can't be content rows.

    if (currentRow !== null && findFirstSuspended(currentRow) === null) {
      lastContentRow = row;
    }

    row = row.sibling;
  }

  return lastContentRow;
}

function validateRevealOrder(revealOrder) {
  {
    if (revealOrder !== undefined && revealOrder !== 'forwards' && revealOrder !== 'backwards' && revealOrder !== 'together' && !didWarnAboutRevealOrder[revealOrder]) {
      didWarnAboutRevealOrder[revealOrder] = true;

      if (typeof revealOrder === 'string') {
        switch (revealOrder.toLowerCase()) {
          case 'together':
          case 'forwards':
          case 'backwards':
            {
              error('"%s" is not a valid value for revealOrder on <SuspenseList />. ' + 'Use lowercase "%s" instead.', revealOrder, revealOrder.toLowerCase());

              break;
            }

          case 'forward':
          case 'backward':
            {
              error('"%s" is not a valid value for revealOrder on <SuspenseList />. ' + 'React uses the -s suffix in the spelling. Use "%ss" instead.', revealOrder, revealOrder.toLowerCase());

              break;
            }

          default:
            error('"%s" is not a supported revealOrder on <SuspenseList />. ' + 'Did you mean "together", "forwards" or "backwards"?', revealOrder);

            break;
        }
      } else {
        error('%s is not a supported value for revealOrder on <SuspenseList />. ' + 'Did you mean "together", "forwards" or "backwards"?', revealOrder);
      }
    }
  }
}

function validateTailOptions(tailMode, revealOrder) {
  {
    if (tailMode !== undefined && !didWarnAboutTailOptions[tailMode]) {
      if (tailMode !== 'collapsed' && tailMode !== 'hidden') {
        didWarnAboutTailOptions[tailMode] = true;

        error('"%s" is not a supported value for tail on <SuspenseList />. ' + 'Did you mean "collapsed" or "hidden"?', tailMode);
      } else if (revealOrder !== 'forwards' && revealOrder !== 'backwards') {
        didWarnAboutTailOptions[tailMode] = true;

        error('<SuspenseList tail="%s" /> is only valid if revealOrder is ' + '"forwards" or "backwards". ' + 'Did you mean to specify revealOrder="forwards"?', tailMode);
      }
    }
  }
}

function validateSuspenseListNestedChild(childSlot, index) {
  {
    var isArray = Array.isArray(childSlot);
    var isIterable = !isArray && typeof getIteratorFn(childSlot) === 'function';

    if (isArray || isIterable) {
      var type = isArray ? 'array' : 'iterable';

      error('A nested %s was passed to row #%s in <SuspenseList />. Wrap it in ' + 'an additional SuspenseList to configure its revealOrder: ' + '<SuspenseList revealOrder=...> ... ' + '<SuspenseList revealOrder=...>{%s}</SuspenseList> ... ' + '</SuspenseList>', type, index, type);

      return false;
    }
  }

  return true;
}

function validateSuspenseListChildren(children, revealOrder) {
  {
    if ((revealOrder === 'forwards' || revealOrder === 'backwards') && children !== undefined && children !== null && children !== false) {
      if (Array.isArray(children)) {
        for (var i = 0; i < children.length; i++) {
          if (!validateSuspenseListNestedChild(children[i], i)) {
            return;
          }
        }
      } else {
        var iteratorFn = getIteratorFn(children);

        if (typeof iteratorFn === 'function') {
          var childrenIterator = iteratorFn.call(children);

          if (childrenIterator) {
            var step = childrenIterator.next();
            var _i = 0;

            for (; !step.done; step = childrenIterator.next()) {
              if (!validateSuspenseListNestedChild(step.value, _i)) {
                return;
              }

              _i++;
            }
          }
        } else {
          error('A single row was passed to a <SuspenseList revealOrder="%s" />. ' + 'This is not useful since it needs multiple rows. ' + 'Did you mean to pass multiple children or an array?', revealOrder);
        }
      }
    }
  }
}

function initSuspenseListRenderState(workInProgress, isBackwards, tail, lastContentRow, tailMode, lastEffectBeforeRendering) {
  var renderState = workInProgress.memoizedState;

  if (renderState === null) {
    workInProgress.memoizedState = {
      isBackwards: isBackwards,
      rendering: null,
      renderingStartTime: 0,
      last: lastContentRow,
      tail: tail,
      tailMode: tailMode,
      lastEffect: lastEffectBeforeRendering
    };
  } else {
    // We can reuse the existing object from previous renders.
    renderState.isBackwards = isBackwards;
    renderState.rendering = null;
    renderState.renderingStartTime = 0;
    renderState.last = lastContentRow;
    renderState.tail = tail;
    renderState.tailMode = tailMode;
    renderState.lastEffect = lastEffectBeforeRendering;
  }
} // This can end up rendering this component multiple passes.
// The first pass splits the children fibers into two sets. A head and tail.
// We first render the head. If anything is in fallback state, we do another
// pass through beginWork to rerender all children (including the tail) with
// the force suspend context. If the first render didn't have anything in
// in fallback state. Then we render each row in the tail one-by-one.
// That happens in the completeWork phase without going back to beginWork.


function updateSuspenseListComponent(current, workInProgress, renderLanes) {
  var nextProps = workInProgress.pendingProps;
  var revealOrder = nextProps.revealOrder;
  var tailMode = nextProps.tail;
  var newChildren = nextProps.children;
  validateRevealOrder(revealOrder);
  validateTailOptions(tailMode, revealOrder);
  validateSuspenseListChildren(newChildren, revealOrder);
  reconcileChildren(current, workInProgress, newChildren, renderLanes);
  var suspenseContext = suspenseStackCursor.current;
  var shouldForceFallback = hasSuspenseContext(suspenseContext, ForceSuspenseFallback);

  if (shouldForceFallback) {
    suspenseContext = setShallowSuspenseContext(suspenseContext, ForceSuspenseFallback);
    workInProgress.flags |= DidCapture;
  } else {
    var didSuspendBefore = current !== null && (current.flags & DidCapture) !== NoFlags;

    if (didSuspendBefore) {
      // If we previously forced a fallback, we need to schedule work
      // on any nested boundaries to let them know to try to render
      // again. This is the same as context updating.
      propagateSuspenseContextChange(workInProgress, workInProgress.child, renderLanes);
    }

    suspenseContext = setDefaultShallowSuspenseContext(suspenseContext);
  }

  pushSuspenseContext(workInProgress, suspenseContext);

  if ((workInProgress.mode & BlockingMode) === NoMode) {
    // In legacy mode, SuspenseList doesn't work so we just
    // use make it a noop by treating it as the default revealOrder.
    workInProgress.memoizedState = null;
  } else {
    switch (revealOrder) {
      case 'forwards':
        {
          var lastContentRow = findLastContentRow(workInProgress.child);
          var tail;

          if (lastContentRow === null) {
            // The whole list is part of the tail.
            // TODO: We could fast path by just rendering the tail now.
            tail = workInProgress.child;
            workInProgress.child = null;
          } else {
            // Disconnect the tail rows after the content row.
            // We're going to render them separately later.
            tail = lastContentRow.sibling;
            lastContentRow.sibling = null;
          }

          initSuspenseListRenderState(workInProgress, false, // isBackwards
          tail, lastContentRow, tailMode, workInProgress.lastEffect);
          break;
        }

      case 'backwards':
        {
          // We're going to find the first row that has existing content.
          // At the same time we're going to reverse the list of everything
          // we pass in the meantime. That's going to be our tail in reverse
          // order.
          var _tail = null;
          var row = workInProgress.child;
          workInProgress.child = null;

          while (row !== null) {
            var currentRow = row.alternate; // New rows can't be content rows.

            if (currentRow !== null && findFirstSuspended(currentRow) === null) {
              // This is the beginning of the main content.
              workInProgress.child = row;
              break;
            }

            var nextRow = row.sibling;
            row.sibling = _tail;
            _tail = row;
            row = nextRow;
          } // TODO: If workInProgress.child is null, we can continue on the tail immediately.


          initSuspenseListRenderState(workInProgress, true, // isBackwards
          _tail, null, // last
          tailMode, workInProgress.lastEffect);
          break;
        }

      case 'together':
        {
          initSuspenseListRenderState(workInProgress, false, // isBackwards
          null, // tail
          null, // last
          undefined, workInProgress.lastEffect);
          break;
        }

      default:
        {
          // The default reveal order is the same as not having
          // a boundary.
          workInProgress.memoizedState = null;
        }
    }
  }

  return workInProgress.child;
}

function updatePortalComponent(current, workInProgress, renderLanes) {
  pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);
  var nextChildren = workInProgress.pendingProps;

  if (current === null) {
    // Portals are special because we don't append the children during mount
    // but at commit. Therefore we need to track insertions which the normal
    // flow doesn't do during mount. This doesn't happen at the root because
    // the root always starts with a "current" with a null child.
    // TODO: Consider unifying this with how the root works.
    workInProgress.child = reconcileChildFibers(workInProgress, null, nextChildren, renderLanes);
  } else {
    reconcileChildren(current, workInProgress, nextChildren, renderLanes);
  }

  return workInProgress.child;
}

var hasWarnedAboutUsingNoValuePropOnContextProvider = false;

function updateContextProvider(current, workInProgress, renderLanes) {
  var providerType = workInProgress.type;
  var context = providerType._context;
  var newProps = workInProgress.pendingProps;
  var oldProps = workInProgress.memoizedProps;
  var newValue = newProps.value;

  {
    if (!('value' in newProps)) {
      if (!hasWarnedAboutUsingNoValuePropOnContextProvider) {
        hasWarnedAboutUsingNoValuePropOnContextProvider = true;

        error('The `value` prop is required for the `<Context.Provider>`. Did you misspell it or forget to pass it?');
      }
    }

    var providerPropTypes = workInProgress.type.propTypes;

    if (providerPropTypes) {
      checkPropTypes(providerPropTypes, newProps, 'prop', 'Context.Provider');
    }
  }

  pushProvider(workInProgress, newValue);

  if (oldProps !== null) {
    var oldValue = oldProps.value;
    var changedBits = calculateChangedBits(context, newValue, oldValue);

    if (changedBits === 0) {
      // No change. Bailout early if children are the same.
      if (oldProps.children === newProps.children && !hasContextChanged()) {
        return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);
      }
    } else {
      // The context value changed. Search for matching consumers and schedule
      // them to update.
      propagateContextChange(workInProgress, context, changedBits, renderLanes);
    }
  }

  var newChildren = newProps.children;
  reconcileChildren(current, workInProgress, newChildren, renderLanes);
  return workInProgress.child;
}

var hasWarnedAboutUsingContextAsConsumer = false;

function updateContextConsumer(current, workInProgress, renderLanes) {
  var context = workInProgress.type; // The logic below for Context differs depending on PROD or DEV mode. In
  // DEV mode, we create a separate object for Context.Consumer that acts
  // like a proxy to Context. This proxy object adds unnecessary code in PROD
  // so we use the old behaviour (Context.Consumer references Context) to
  // reduce size and overhead. The separate object references context via
  // a property called "_context", which also gives us the ability to check
  // in DEV mode if this property exists or not and warn if it does not.

  {
    if (context._context === undefined) {
      // This may be because it's a Context (rather than a Consumer).
      // Or it may be because it's older React where they're the same thing.
      // We only want to warn if we're sure it's a new React.
      if (context !== context.Consumer) {
        if (!hasWarnedAboutUsingContextAsConsumer) {
          hasWarnedAboutUsingContextAsConsumer = true;

          error('Rendering <Context> directly is not supported and will be removed in ' + 'a future major release. Did you mean to render <Context.Consumer> instead?');
        }
      }
    } else {
      context = context._context;
    }
  }

  var newProps = workInProgress.pendingProps;
  var render = newProps.children;

  {
    if (typeof render !== 'function') {
      error('A context consumer was rendered with multiple children, or a child ' + "that isn't a function. A context consumer expects a single child " + 'that is a function. If you did pass a function, make sure there ' + 'is no trailing or leading whitespace around it.');
    }
  }

  prepareToReadContext(workInProgress, renderLanes);
  var newValue = readContext(context, newProps.unstable_observedBits);
  var newChildren;

  {
    ReactCurrentOwner$1.current = workInProgress;
    setIsRendering(true);
    newChildren = render(newValue);
    setIsRendering(false);
  } // React DevTools reads this flag.


  workInProgress.flags |= PerformedWork;
  reconcileChildren(current, workInProgress, newChildren, renderLanes);
  return workInProgress.child;
}

function markWorkInProgressReceivedUpdate() {
  didReceiveUpdate = true;
}

function bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes) {
  if (current !== null) {
    // Reuse previous dependencies
    workInProgress.dependencies = current.dependencies;
  }

  {
    // Don't update "base" render times for bailouts.
    stopProfilerTimerIfRunning();
  }

  markSkippedUpdateLanes(workInProgress.lanes); // Check if the children have any pending work.

  if (!includesSomeLane(renderLanes, workInProgress.childLanes)) {
    // The children don't have any work either. We can skip them.
    // TODO: Once we add back resuming, we should check if the children are
    // a work-in-progress set. If so, we need to transfer their effects.
    return null;
  } else {
    // This fiber doesn't have work, but its subtree does. Clone the child
    // fibers and continue.
    cloneChildFibers(current, workInProgress);
    return workInProgress.child;
  }
}

function remountFiber(current, oldWorkInProgress, newWorkInProgress) {
  {
    var returnFiber = oldWorkInProgress.return;

    if (returnFiber === null) {
      throw new Error('Cannot swap the root fiber.');
    } // Disconnect from the old current.
    // It will get deleted.


    current.alternate = null;
    oldWorkInProgress.alternate = null; // Connect to the new tree.

    newWorkInProgress.index = oldWorkInProgress.index;
    newWorkInProgress.sibling = oldWorkInProgress.sibling;
    newWorkInProgress.return = oldWorkInProgress.return;
    newWorkInProgress.ref = oldWorkInProgress.ref; // Replace the child/sibling pointers above it.

    if (oldWorkInProgress === returnFiber.child) {
      returnFiber.child = newWorkInProgress;
    } else {
      var prevSibling = returnFiber.child;

      if (prevSibling === null) {
        throw new Error('Expected parent to have a child.');
      }

      while (prevSibling.sibling !== oldWorkInProgress) {
        prevSibling = prevSibling.sibling;

        if (prevSibling === null) {
          throw new Error('Expected to find the previous sibling.');
        }
      }

      prevSibling.sibling = newWorkInProgress;
    } // Delete the old fiber and place the new one.
    // Since the old fiber is disconnected, we have to schedule it manually.


    var last = returnFiber.lastEffect;

    if (last !== null) {
      last.nextEffect = current;
      returnFiber.lastEffect = current;
    } else {
      returnFiber.firstEffect = returnFiber.lastEffect = current;
    }

    current.nextEffect = null;
    current.flags = Deletion;
    newWorkInProgress.flags |= Placement; // Restart work from the new fiber.

    return newWorkInProgress;
  }
}

function beginWork(current, workInProgress, renderLanes) {
  var updateLanes = workInProgress.lanes;

  {
    if (workInProgress._debugNeedsRemount && current !== null) {
      // This will restart the begin phase with a new fiber.
      return remountFiber(current, workInProgress, createFiberFromTypeAndProps(workInProgress.type, workInProgress.key, workInProgress.pendingProps, workInProgress._debugOwner || null, workInProgress.mode, workInProgress.lanes));
    }
  }

  if (current !== null) {
    var oldProps = current.memoizedProps;
    var newProps = workInProgress.pendingProps;

    if (oldProps !== newProps || hasContextChanged() || ( // Force a re-render if the implementation changed due to hot reload:
     workInProgress.type !== current.type )) {
      // If props or context changed, mark the fiber as having performed work.
      // This may be unset if the props are determined to be equal later (memo).
      didReceiveUpdate = true;
    } else if (!includesSomeLane(renderLanes, updateLanes)) {
      didReceiveUpdate = false; // This fiber does not have any pending work. Bailout without entering
      // the begin phase. There's still some bookkeeping we that needs to be done
      // in this optimized path, mostly pushing stuff onto the stack.

      switch (workInProgress.tag) {
        case HostRoot:
          pushHostRootContext(workInProgress);
          resetHydrationState();
          break;

        case HostComponent:
          pushHostContext(workInProgress);
          break;

        case ClassComponent:
          {
            var Component = workInProgress.type;

            if (isContextProvider(Component)) {
              pushContextProvider(workInProgress);
            }

            break;
          }

        case HostPortal:
          pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);
          break;

        case ContextProvider:
          {
            var newValue = workInProgress.memoizedProps.value;
            pushProvider(workInProgress, newValue);
            break;
          }

        case Profiler:
          {
            // Profiler should only call onRender when one of its descendants actually rendered.
            var hasChildWork = includesSomeLane(renderLanes, workInProgress.childLanes);

            if (hasChildWork) {
              workInProgress.flags |= Update;
            } // Reset effect durations for the next eventual effect phase.
            // These are reset during render to allow the DevTools commit hook a chance to read them,


            var stateNode = workInProgress.stateNode;
            stateNode.effectDuration = 0;
            stateNode.passiveEffectDuration = 0;
          }

          break;

        case SuspenseComponent:
          {
            var state = workInProgress.memoizedState;

            if (state !== null) {
              // whether to retry the primary children, or to skip over it and
              // go straight to the fallback. Check the priority of the primary
              // child fragment.


              var primaryChildFragment = workInProgress.child;
              var primaryChildLanes = primaryChildFragment.childLanes;

              if (includesSomeLane(renderLanes, primaryChildLanes)) {
                // The primary children have pending work. Use the normal path
                // to attempt to render the primary children again.
                return updateSuspenseComponent(current, workInProgress, renderLanes);
              } else {
                // The primary child fragment does not have pending work marked
                // on it
                pushSuspenseContext(workInProgress, setDefaultShallowSuspenseContext(suspenseStackCursor.current)); // The primary children do not have pending work with sufficient
                // priority. Bailout.

                var child = bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);

                if (child !== null) {
                  // The fallback children have pending work. Skip over the
                  // primary children and work on the fallback.
                  return child.sibling;
                } else {
                  return null;
                }
              }
            } else {
              pushSuspenseContext(workInProgress, setDefaultShallowSuspenseContext(suspenseStackCursor.current));
            }

            break;
          }

        case SuspenseListComponent:
          {
            var didSuspendBefore = (current.flags & DidCapture) !== NoFlags;

            var _hasChildWork = includesSomeLane(renderLanes, workInProgress.childLanes);

            if (didSuspendBefore) {
              if (_hasChildWork) {
                // If something was in fallback state last time, and we have all the
                // same children then we're still in progressive loading state.
                // Something might get unblocked by state updates or retries in the
                // tree which will affect the tail. So we need to use the normal
                // path to compute the correct tail.
                return updateSuspenseListComponent(current, workInProgress, renderLanes);
              } // If none of the children had any work, that means that none of
              // them got retried so they'll still be blocked in the same way
              // as before. We can fast bail out.


              workInProgress.flags |= DidCapture;
            } // If nothing suspended before and we're rendering the same children,
            // then the tail doesn't matter. Anything new that suspends will work
            // in the "together" mode, so we can continue from the state we had.


            var renderState = workInProgress.memoizedState;

            if (renderState !== null) {
              // Reset to the "together" mode in case we've started a different
              // update in the past but didn't complete it.
              renderState.rendering = null;
              renderState.tail = null;
              renderState.lastEffect = null;
            }

            pushSuspenseContext(workInProgress, suspenseStackCursor.current);

            if (_hasChildWork) {
              break;
            } else {
              // If none of the children had any work, that means that none of
              // them got retried so they'll still be blocked in the same way
              // as before. We can fast bail out.
              return null;
            }
          }

        case OffscreenComponent:
        case LegacyHiddenComponent:
          {
            // Need to check if the tree still needs to be deferred. This is
            // almost identical to the logic used in the normal update path,
            // so we'll just enter that. The only difference is we'll bail out
            // at the next level instead of this one, because the child props
            // have not changed. Which is fine.
            // TODO: Probably should refactor `beginWork` to split the bailout
            // path from the normal path. I'm tempted to do a labeled break here
            // but I won't :)
            workInProgress.lanes = NoLanes;
            return updateOffscreenComponent(current, workInProgress, renderLanes);
          }
      }

      return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);
    } else {
      if ((current.flags & ForceUpdateForLegacySuspense) !== NoFlags) {
        // This is a special case that only exists for legacy mode.
        // See https://github.com/facebook/react/pull/19216.
        didReceiveUpdate = true;
      } else {
        // An update was scheduled on this fiber, but there are no new props
        // nor legacy context. Set this to false. If an update queue or context
        // consumer produces a changed value, it will set this to true. Otherwise,
        // the component will assume the children have not changed and bail out.
        didReceiveUpdate = false;
      }
    }
  } else {
    didReceiveUpdate = false;
  } // Before entering the begin phase, clear pending update priority.
  // TODO: This assumes that we're about to evaluate the component and process
  // the update queue. However, there's an exception: SimpleMemoComponent
  // sometimes bails out later in the begin phase. This indicates that we should
  // move this assignment out of the common path and into each branch.


  workInProgress.lanes = NoLanes;

  switch (workInProgress.tag) {
    case IndeterminateComponent:
      {
        return mountIndeterminateComponent(current, workInProgress, workInProgress.type, renderLanes);
      }

    case LazyComponent:
      {
        var elementType = workInProgress.elementType;
        return mountLazyComponent(current, workInProgress, elementType, updateLanes, renderLanes);
      }

    case FunctionComponent:
      {
        var _Component = workInProgress.type;
        var unresolvedProps = workInProgress.pendingProps;
        var resolvedProps = workInProgress.elementType === _Component ? unresolvedProps : resolveDefaultProps(_Component, unresolvedProps);
        return updateFunctionComponent(current, workInProgress, _Component, resolvedProps, renderLanes);
      }

    case ClassComponent:
      {
        var _Component2 = workInProgress.type;
        var _unresolvedProps = workInProgress.pendingProps;

        var _resolvedProps = workInProgress.elementType === _Component2 ? _unresolvedProps : resolveDefaultProps(_Component2, _unresolvedProps);

        return updateClassComponent(current, workInProgress, _Component2, _resolvedProps, renderLanes);
      }

    case HostRoot:
      return updateHostRoot(current, workInProgress, renderLanes);

    case HostComponent:
      return updateHostComponent(current, workInProgress, renderLanes);

    case HostText:
      return updateHostText(current, workInProgress);

    case SuspenseComponent:
      return updateSuspenseComponent(current, workInProgress, renderLanes);

    case HostPortal:
      return updatePortalComponent(current, workInProgress, renderLanes);

    case ForwardRef:
      {
        var type = workInProgress.type;
        var _unresolvedProps2 = workInProgress.pendingProps;

        var _resolvedProps2 = workInProgress.elementType === type ? _unresolvedProps2 : resolveDefaultProps(type, _unresolvedProps2);

        return updateForwardRef(current, workInProgress, type, _resolvedProps2, renderLanes);
      }

    case Fragment:
      return updateFragment(current, workInProgress, renderLanes);

    case Mode:
      return updateMode(current, workInProgress, renderLanes);

    case Profiler:
      return updateProfiler(current, workInProgress, renderLanes);

    case ContextProvider:
      return updateContextProvider(current, workInProgress, renderLanes);

    case ContextConsumer:
      return updateContextConsumer(current, workInProgress, renderLanes);

    case MemoComponent:
      {
        var _type2 = workInProgress.type;
        var _unresolvedProps3 = workInProgress.pendingProps; // Resolve outer props first, then resolve inner props.

        var _resolvedProps3 = resolveDefaultProps(_type2, _unresolvedProps3);

        {
          if (workInProgress.type !== workInProgress.elementType) {
            var outerPropTypes = _type2.propTypes;

            if (outerPropTypes) {
              checkPropTypes(outerPropTypes, _resolvedProps3, // Resolved for outer only
              'prop', getComponentName(_type2));
            }
          }
        }

        _resolvedProps3 = resolveDefaultProps(_type2.type, _resolvedProps3);
        return updateMemoComponent(current, workInProgress, _type2, _resolvedProps3, updateLanes, renderLanes);
      }

    case SimpleMemoComponent:
      {
        return updateSimpleMemoComponent(current, workInProgress, workInProgress.type, workInProgress.pendingProps, updateLanes, renderLanes);
      }

    case IncompleteClassComponent:
      {
        var _Component3 = workInProgress.type;
        var _unresolvedProps4 = workInProgress.pendingProps;

        var _resolvedProps4 = workInProgress.elementType === _Component3 ? _unresolvedProps4 : resolveDefaultProps(_Component3, _unresolvedProps4);

        return mountIncompleteClassComponent(current, workInProgress, _Component3, _resolvedProps4, renderLanes);
      }

    case SuspenseListComponent:
      {
        return updateSuspenseListComponent(current, workInProgress, renderLanes);
      }

    case FundamentalComponent:
      {

        break;
      }

    case ScopeComponent:
      {

        break;
      }

    case Block:
      {

        break;
      }

    case OffscreenComponent:
      {
        return updateOffscreenComponent(current, workInProgress, renderLanes);
      }

    case LegacyHiddenComponent:
      {
        return updateLegacyHiddenComponent(current, workInProgress, renderLanes);
      }
  }

  {
    {
      throw Error( "Unknown unit of work tag (" + workInProgress.tag + "). This error is likely caused by a bug in React. Please file an issue." );
    }
  }
}

function markUpdate(workInProgress) {
  // Tag the fiber with an update effect. This turns a Placement into
  // a PlacementAndUpdate.
  workInProgress.flags |= Update;
}

function markRef$1(workInProgress) {
  workInProgress.flags |= Ref;
}

var appendAllChildren;
var updateHostContainer;
var updateHostComponent$1;
var updateHostText$1;

{
  // Mutation mode
  appendAllChildren = function (parent, workInProgress, needsVisibilityToggle, isHidden) {
    // We only have the top Fiber that was created but we need recurse down its
    // children to find all the terminal nodes.
    var node = workInProgress.child;

    while (node !== null) {
      if (node.tag === HostComponent || node.tag === HostText) {
        appendInitialChild(parent, node.stateNode);
      } else if (node.tag === HostPortal) ; else if (node.child !== null) {
        node.child.return = node;
        node = node.child;
        continue;
      }

      if (node === workInProgress) {
        return;
      }

      while (node.sibling === null) {
        if (node.return === null || node.return === workInProgress) {
          return;
        }

        node = node.return;
      }

      node.sibling.return = node.return;
      node = node.sibling;
    }
  };

  updateHostContainer = function (workInProgress) {// Noop
  };

  updateHostComponent$1 = function (current, workInProgress, type, newProps, rootContainerInstance) {
    // If we have an alternate, that means this is an update and we need to
    // schedule a side-effect to do the updates.
    var oldProps = current.memoizedProps;

    if (oldProps === newProps) {
      // In mutation mode, this is sufficient for a bailout because
      // we won't touch this node even if children changed.
      return;
    } // If we get updated because one of our children updated, we don't
    // have newProps so we'll have to reuse them.
    // TODO: Split the update API as separate for the props vs. children.
    // Even better would be if children weren't special cased at all tho.


    var instance = workInProgress.stateNode;
    var currentHostContext = getHostContext(); // TODO: Experiencing an error where oldProps is null. Suggests a host
    // component is hitting the resume path. Figure out why. Possibly
    // related to `hidden`.

    var updatePayload = prepareUpdate(instance, type, oldProps, newProps, rootContainerInstance, currentHostContext); // TODO: Type this specific to this type of component.

    workInProgress.updateQueue = updatePayload; // If the update payload indicates that there is a change or if there
    // is a new ref we mark this as an update. All the work is done in commitWork.

    if (updatePayload) {
      markUpdate(workInProgress);
    }
  };

  updateHostText$1 = function (current, workInProgress, oldText, newText) {
    // If the text differs, mark it as an update. All the work in done in commitWork.
    if (oldText !== newText) {
      markUpdate(workInProgress);
    }
  };
}

function cutOffTailIfNeeded(renderState, hasRenderedATailFallback) {
  if (getIsHydrating()) {
    // If we're hydrating, we should consume as many items as we can
    // so we don't leave any behind.
    return;
  }

  switch (renderState.tailMode) {
    case 'hidden':
      {
        // Any insertions at the end of the tail list after this point
        // should be invisible. If there are already mounted boundaries
        // anything before them are not considered for collapsing.
        // Therefore we need to go through the whole tail to find if
        // there are any.
        var tailNode = renderState.tail;
        var lastTailNode = null;

        while (tailNode !== null) {
          if (tailNode.alternate !== null) {
            lastTailNode = tailNode;
          }

          tailNode = tailNode.sibling;
        } // Next we're simply going to delete all insertions after the
        // last rendered item.


        if (lastTailNode === null) {
          // All remaining items in the tail are insertions.
          renderState.tail = null;
        } else {
          // Detach the insertion after the last node that was already
          // inserted.
          lastTailNode.sibling = null;
        }

        break;
      }

    case 'collapsed':
      {
        // Any insertions at the end of the tail list after this point
        // should be invisible. If there are already mounted boundaries
        // anything before them are not considered for collapsing.
        // Therefore we need to go through the whole tail to find if
        // there are any.
        var _tailNode = renderState.tail;
        var _lastTailNode = null;

        while (_tailNode !== null) {
          if (_tailNode.alternate !== null) {
            _lastTailNode = _tailNode;
          }

          _tailNode = _tailNode.sibling;
        } // Next we're simply going to delete all insertions after the
        // last rendered item.


        if (_lastTailNode === null) {
          // All remaining items in the tail are insertions.
          if (!hasRenderedATailFallback && renderState.tail !== null) {
            // We suspended during the head. We want to show at least one
            // row at the tail. So we'll keep on and cut off the rest.
            renderState.tail.sibling = null;
          } else {
            renderState.tail = null;
          }
        } else {
          // Detach the insertion after the last node that was already
          // inserted.
          _lastTailNode.sibling = null;
        }

        break;
      }
  }
}

function completeWork(current, workInProgress, renderLanes) {
  var newProps = workInProgress.pendingProps;

  switch (workInProgress.tag) {
    case IndeterminateComponent:
    case LazyComponent:
    case SimpleMemoComponent:
    case FunctionComponent:
    case ForwardRef:
    case Fragment:
    case Mode:
    case Profiler:
    case ContextConsumer:
    case MemoComponent:
      return null;

    case ClassComponent:
      {
        var Component = workInProgress.type;

        if (isContextProvider(Component)) {
          popContext(workInProgress);
        }

        return null;
      }

    case HostRoot:
      {
        popHostContainer(workInProgress);
        popTopLevelContextObject(workInProgress);
        resetWorkInProgressVersions();
        var fiberRoot = workInProgress.stateNode;

        if (fiberRoot.pendingContext) {
          fiberRoot.context = fiberRoot.pendingContext;
          fiberRoot.pendingContext = null;
        }

        if (current === null || current.child === null) {
          // If we hydrated, pop so that we can delete any remaining children
          // that weren't hydrated.
          var wasHydrated = popHydrationState(workInProgress);

          if (wasHydrated) {
            // If we hydrated, then we'll need to schedule an update for
            // the commit side-effects on the root.
            markUpdate(workInProgress);
          } else if (!fiberRoot.hydrate) {
            // Schedule an effect to clear this container at the start of the next commit.
            // This handles the case of React rendering into a container with previous children.
            // It's also safe to do for updates too, because current.child would only be null
            // if the previous render was null (so the the container would already be empty).
            workInProgress.flags |= Snapshot;
          }
        }

        updateHostContainer(workInProgress);
        return null;
      }

    case HostComponent:
      {
        popHostContext(workInProgress);
        var rootContainerInstance = getRootHostContainer();
        var type = workInProgress.type;

        if (current !== null && workInProgress.stateNode != null) {
          updateHostComponent$1(current, workInProgress, type, newProps, rootContainerInstance);

          if (current.ref !== workInProgress.ref) {
            markRef$1(workInProgress);
          }
        } else {
          if (!newProps) {
            if (!(workInProgress.stateNode !== null)) {
              {
                throw Error( "We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue." );
              }
            } // This can happen when we abort work.


            return null;
          }

          var currentHostContext = getHostContext(); // TODO: Move createInstance to beginWork and keep it on a context
          // "stack" as the parent. Then append children as we go in beginWork
          // or completeWork depending on whether we want to add them top->down or
          // bottom->up. Top->down is faster in IE11.

          var _wasHydrated = popHydrationState(workInProgress);

          if (_wasHydrated) {
            // TODO: Move this and createInstance step into the beginPhase
            // to consolidate.
            if (prepareToHydrateHostInstance(workInProgress, rootContainerInstance, currentHostContext)) {
              // If changes to the hydrated node need to be applied at the
              // commit-phase we mark this as such.
              markUpdate(workInProgress);
            }
          } else {
            var instance = createInstance(type, newProps, rootContainerInstance, currentHostContext, workInProgress);
            appendAllChildren(instance, workInProgress, false, false);
            workInProgress.stateNode = instance; // Certain renderers require commit-time effects for initial mount.
            // (eg DOM renderer supports auto-focus for certain elements).
            // Make sure such renderers get scheduled for later work.

            if (finalizeInitialChildren(instance, type, newProps, rootContainerInstance)) {
              markUpdate(workInProgress);
            }
          }

          if (workInProgress.ref !== null) {
            // If there is a ref on a host node we need to schedule a callback
            markRef$1(workInProgress);
          }
        }

        return null;
      }

    case HostText:
      {
        var newText = newProps;

        if (current && workInProgress.stateNode != null) {
          var oldText = current.memoizedProps; // If we have an alternate, that means this is an update and we need
          // to schedule a side-effect to do the updates.

          updateHostText$1(current, workInProgress, oldText, newText);
        } else {
          if (typeof newText !== 'string') {
            if (!(workInProgress.stateNode !== null)) {
              {
                throw Error( "We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue." );
              }
            } // This can happen when we abort work.

          }

          var _rootContainerInstance = getRootHostContainer();

          var _currentHostContext = getHostContext();

          var _wasHydrated2 = popHydrationState(workInProgress);

          if (_wasHydrated2) {
            if (prepareToHydrateHostTextInstance(workInProgress)) {
              markUpdate(workInProgress);
            }
          } else {
            workInProgress.stateNode = createTextInstance(newText, _rootContainerInstance, _currentHostContext, workInProgress);
          }
        }

        return null;
      }

    case SuspenseComponent:
      {
        popSuspenseContext(workInProgress);
        var nextState = workInProgress.memoizedState;

        if ((workInProgress.flags & DidCapture) !== NoFlags) {
          // Something suspended. Re-render with the fallback children.
          workInProgress.lanes = renderLanes; // Do not reset the effect list.

          if ( (workInProgress.mode & ProfileMode) !== NoMode) {
            transferActualDuration(workInProgress);
          }

          return workInProgress;
        }

        var nextDidTimeout = nextState !== null;
        var prevDidTimeout = false;

        if (current === null) {
          if (workInProgress.memoizedProps.fallback !== undefined) {
            popHydrationState(workInProgress);
          }
        } else {
          var prevState = current.memoizedState;
          prevDidTimeout = prevState !== null;
        }

        if (nextDidTimeout && !prevDidTimeout) {
          // If this subtreee is running in blocking mode we can suspend,
          // otherwise we won't suspend.
          // TODO: This will still suspend a synchronous tree if anything
          // in the concurrent tree already suspended during this render.
          // This is a known bug.
          if ((workInProgress.mode & BlockingMode) !== NoMode) {
            // TODO: Move this back to throwException because this is too late
            // if this is a large tree which is common for initial loads. We
            // don't know if we should restart a render or not until we get
            // this marker, and this is too late.
            // If this render already had a ping or lower pri updates,
            // and this is the first time we know we're going to suspend we
            // should be able to immediately restart from within throwException.
            var hasInvisibleChildContext = current === null && workInProgress.memoizedProps.unstable_avoidThisFallback !== true;

            if (hasInvisibleChildContext || hasSuspenseContext(suspenseStackCursor.current, InvisibleParentSuspenseContext)) {
              // If this was in an invisible tree or a new render, then showing
              // this boundary is ok.
              renderDidSuspend();
            } else {
              // Otherwise, we're going to have to hide content so we should
              // suspend for longer if possible.
              renderDidSuspendDelayIfPossible();
            }
          }
        }

        {
          // TODO: Only schedule updates if these values are non equal, i.e. it changed.
          if (nextDidTimeout || prevDidTimeout) {
            // If this boundary just timed out, schedule an effect to attach a
            // retry listener to the promise. This flag is also used to hide the
            // primary children. In mutation mode, we also need the flag to
            // *unhide* children that were previously hidden, so check if this
            // is currently timed out, too.
            workInProgress.flags |= Update;
          }
        }

        return null;
      }

    case HostPortal:
      popHostContainer(workInProgress);
      updateHostContainer(workInProgress);

      if (current === null) {
        preparePortalMount(workInProgress.stateNode.containerInfo);
      }

      return null;

    case ContextProvider:
      // Pop provider fiber
      popProvider(workInProgress);
      return null;

    case IncompleteClassComponent:
      {
        // Same as class component case. I put it down here so that the tags are
        // sequential to ensure this switch is compiled to a jump table.
        var _Component = workInProgress.type;

        if (isContextProvider(_Component)) {
          popContext(workInProgress);
        }

        return null;
      }

    case SuspenseListComponent:
      {
        popSuspenseContext(workInProgress);
        var renderState = workInProgress.memoizedState;

        if (renderState === null) {
          // We're running in the default, "independent" mode.
          // We don't do anything in this mode.
          return null;
        }

        var didSuspendAlready = (workInProgress.flags & DidCapture) !== NoFlags;
        var renderedTail = renderState.rendering;

        if (renderedTail === null) {
          // We just rendered the head.
          if (!didSuspendAlready) {
            // This is the first pass. We need to figure out if anything is still
            // suspended in the rendered set.
            // If new content unsuspended, but there's still some content that
            // didn't. Then we need to do a second pass that forces everything
            // to keep showing their fallbacks.
            // We might be suspended if something in this render pass suspended, or
            // something in the previous committed pass suspended. Otherwise,
            // there's no chance so we can skip the expensive call to
            // findFirstSuspended.
            var cannotBeSuspended = renderHasNotSuspendedYet() && (current === null || (current.flags & DidCapture) === NoFlags);

            if (!cannotBeSuspended) {
              var row = workInProgress.child;

              while (row !== null) {
                var suspended = findFirstSuspended(row);

                if (suspended !== null) {
                  didSuspendAlready = true;
                  workInProgress.flags |= DidCapture;
                  cutOffTailIfNeeded(renderState, false); // If this is a newly suspended tree, it might not get committed as
                  // part of the second pass. In that case nothing will subscribe to
                  // its thennables. Instead, we'll transfer its thennables to the
                  // SuspenseList so that it can retry if they resolve.
                  // There might be multiple of these in the list but since we're
                  // going to wait for all of them anyway, it doesn't really matter
                  // which ones gets to ping. In theory we could get clever and keep
                  // track of how many dependencies remain but it gets tricky because
                  // in the meantime, we can add/remove/change items and dependencies.
                  // We might bail out of the loop before finding any but that
                  // doesn't matter since that means that the other boundaries that
                  // we did find already has their listeners attached.

                  var newThennables = suspended.updateQueue;

                  if (newThennables !== null) {
                    workInProgress.updateQueue = newThennables;
                    workInProgress.flags |= Update;
                  } // Rerender the whole list, but this time, we'll force fallbacks
                  // to stay in place.
                  // Reset the effect list before doing the second pass since that's now invalid.


                  if (renderState.lastEffect === null) {
                    workInProgress.firstEffect = null;
                  }

                  workInProgress.lastEffect = renderState.lastEffect; // Reset the child fibers to their original state.

                  resetChildFibers(workInProgress, renderLanes); // Set up the Suspense Context to force suspense and immediately
                  // rerender the children.

                  pushSuspenseContext(workInProgress, setShallowSuspenseContext(suspenseStackCursor.current, ForceSuspenseFallback));
                  return workInProgress.child;
                }

                row = row.sibling;
              }
            }

            if (renderState.tail !== null && now() > getRenderTargetTime()) {
              // We have already passed our CPU deadline but we still have rows
              // left in the tail. We'll just give up further attempts to render
              // the main content and only render fallbacks.
              workInProgress.flags |= DidCapture;
              didSuspendAlready = true;
              cutOffTailIfNeeded(renderState, false); // Since nothing actually suspended, there will nothing to ping this
              // to get it started back up to attempt the next item. While in terms
              // of priority this work has the same priority as this current render,
              // it's not part of the same transition once the transition has
              // committed. If it's sync, we still want to yield so that it can be
              // painted. Conceptually, this is really the same as pinging.
              // We can use any RetryLane even if it's the one currently rendering
              // since we're leaving it behind on this node.

              workInProgress.lanes = SomeRetryLane;

              {
                markSpawnedWork(SomeRetryLane);
              }
            }
          } else {
            cutOffTailIfNeeded(renderState, false);
          } // Next we're going to render the tail.

        } else {
          // Append the rendered row to the child list.
          if (!didSuspendAlready) {
            var _suspended = findFirstSuspended(renderedTail);

            if (_suspended !== null) {
              workInProgress.flags |= DidCapture;
              didSuspendAlready = true; // Ensure we transfer the update queue to the parent so that it doesn't
              // get lost if this row ends up dropped during a second pass.

              var _newThennables = _suspended.updateQueue;

              if (_newThennables !== null) {
                workInProgress.updateQueue = _newThennables;
                workInProgress.flags |= Update;
              }

              cutOffTailIfNeeded(renderState, true); // This might have been modified.

              if (renderState.tail === null && renderState.tailMode === 'hidden' && !renderedTail.alternate && !getIsHydrating() // We don't cut it if we're hydrating.
              ) {
                  // We need to delete the row we just rendered.
                  // Reset the effect list to what it was before we rendered this
                  // child. The nested children have already appended themselves.
                  var lastEffect = workInProgress.lastEffect = renderState.lastEffect; // Remove any effects that were appended after this point.

                  if (lastEffect !== null) {
                    lastEffect.nextEffect = null;
                  } // We're done.


                  return null;
                }
            } else if ( // The time it took to render last row is greater than the remaining
            // time we have to render. So rendering one more row would likely
            // exceed it.
            now() * 2 - renderState.renderingStartTime > getRenderTargetTime() && renderLanes !== OffscreenLane) {
              // We have now passed our CPU deadline and we'll just give up further
              // attempts to render the main content and only render fallbacks.
              // The assumption is that this is usually faster.
              workInProgress.flags |= DidCapture;
              didSuspendAlready = true;
              cutOffTailIfNeeded(renderState, false); // Since nothing actually suspended, there will nothing to ping this
              // to get it started back up to attempt the next item. While in terms
              // of priority this work has the same priority as this current render,
              // it's not part of the same transition once the transition has
              // committed. If it's sync, we still want to yield so that it can be
              // painted. Conceptually, this is really the same as pinging.
              // We can use any RetryLane even if it's the one currently rendering
              // since we're leaving it behind on this node.

              workInProgress.lanes = SomeRetryLane;

              {
                markSpawnedWork(SomeRetryLane);
              }
            }
          }

          if (renderState.isBackwards) {
            // The effect list of the backwards tail will have been added
            // to the end. This breaks the guarantee that life-cycles fire in
            // sibling order but that isn't a strong guarantee promised by React.
            // Especially since these might also just pop in during future commits.
            // Append to the beginning of the list.
            renderedTail.sibling = workInProgress.child;
            workInProgress.child = renderedTail;
          } else {
            var previousSibling = renderState.last;

            if (previousSibling !== null) {
              previousSibling.sibling = renderedTail;
            } else {
              workInProgress.child = renderedTail;
            }

            renderState.last = renderedTail;
          }
        }

        if (renderState.tail !== null) {
          // We still have tail rows to render.
          // Pop a row.
          var next = renderState.tail;
          renderState.rendering = next;
          renderState.tail = next.sibling;
          renderState.lastEffect = workInProgress.lastEffect;
          renderState.renderingStartTime = now();
          next.sibling = null; // Restore the context.
          // TODO: We can probably just avoid popping it instead and only
          // setting it the first time we go from not suspended to suspended.

          var suspenseContext = suspenseStackCursor.current;

          if (didSuspendAlready) {
            suspenseContext = setShallowSuspenseContext(suspenseContext, ForceSuspenseFallback);
          } else {
            suspenseContext = setDefaultShallowSuspenseContext(suspenseContext);
          }

          pushSuspenseContext(workInProgress, suspenseContext); // Do a pass over the next row.

          return next;
        }

        return null;
      }

    case FundamentalComponent:
      {

        break;
      }

    case ScopeComponent:
      {

        break;
      }

    case Block:

      break;

    case OffscreenComponent:
    case LegacyHiddenComponent:
      {
        popRenderLanes(workInProgress);

        if (current !== null) {
          var _nextState = workInProgress.memoizedState;
          var _prevState = current.memoizedState;
          var prevIsHidden = _prevState !== null;
          var nextIsHidden = _nextState !== null;

          if (prevIsHidden !== nextIsHidden && newProps.mode !== 'unstable-defer-without-hiding') {
            workInProgress.flags |= Update;
          }
        }

        return null;
      }
  }

  {
    {
      throw Error( "Unknown unit of work tag (" + workInProgress.tag + "). This error is likely caused by a bug in React. Please file an issue." );
    }
  }
}

function unwindWork(workInProgress, renderLanes) {
  switch (workInProgress.tag) {
    case ClassComponent:
      {
        var Component = workInProgress.type;

        if (isContextProvider(Component)) {
          popContext(workInProgress);
        }

        var flags = workInProgress.flags;

        if (flags & ShouldCapture) {
          workInProgress.flags = flags & ~ShouldCapture | DidCapture;

          if ( (workInProgress.mode & ProfileMode) !== NoMode) {
            transferActualDuration(workInProgress);
          }

          return workInProgress;
        }

        return null;
      }

    case HostRoot:
      {
        popHostContainer(workInProgress);
        popTopLevelContextObject(workInProgress);
        resetWorkInProgressVersions();
        var _flags = workInProgress.flags;

        if (!((_flags & DidCapture) === NoFlags)) {
          {
            throw Error( "The root failed to unmount after an error. This is likely a bug in React. Please file an issue." );
          }
        }

        workInProgress.flags = _flags & ~ShouldCapture | DidCapture;
        return workInProgress;
      }

    case HostComponent:
      {
        // TODO: popHydrationState
        popHostContext(workInProgress);
        return null;
      }

    case SuspenseComponent:
      {
        popSuspenseContext(workInProgress);

        var _flags2 = workInProgress.flags;

        if (_flags2 & ShouldCapture) {
          workInProgress.flags = _flags2 & ~ShouldCapture | DidCapture; // Captured a suspense effect. Re-render the boundary.

          if ( (workInProgress.mode & ProfileMode) !== NoMode) {
            transferActualDuration(workInProgress);
          }

          return workInProgress;
        }

        return null;
      }

    case SuspenseListComponent:
      {
        popSuspenseContext(workInProgress); // SuspenseList doesn't actually catch anything. It should've been
        // caught by a nested boundary. If not, it should bubble through.

        return null;
      }

    case HostPortal:
      popHostContainer(workInProgress);
      return null;

    case ContextProvider:
      popProvider(workInProgress);
      return null;

    case OffscreenComponent:
    case LegacyHiddenComponent:
      popRenderLanes(workInProgress);
      return null;

    default:
      return null;
  }
}

function unwindInterruptedWork(interruptedWork) {
  switch (interruptedWork.tag) {
    case ClassComponent:
      {
        var childContextTypes = interruptedWork.type.childContextTypes;

        if (childContextTypes !== null && childContextTypes !== undefined) {
          popContext(interruptedWork);
        }

        break;
      }

    case HostRoot:
      {
        popHostContainer(interruptedWork);
        popTopLevelContextObject(interruptedWork);
        resetWorkInProgressVersions();
        break;
      }

    case HostComponent:
      {
        popHostContext(interruptedWork);
        break;
      }

    case HostPortal:
      popHostContainer(interruptedWork);
      break;

    case SuspenseComponent:
      popSuspenseContext(interruptedWork);
      break;

    case SuspenseListComponent:
      popSuspenseContext(interruptedWork);
      break;

    case ContextProvider:
      popProvider(interruptedWork);
      break;

    case OffscreenComponent:
    case LegacyHiddenComponent:
      popRenderLanes(interruptedWork);
      break;
  }
}

function createCapturedValue(value, source) {
  // If the value is an error, call this function immediately after it is thrown
  // so the stack is accurate.
  return {
    value: value,
    source: source,
    stack: getStackByFiberInDevAndProd(source)
  };
}

// This module is forked in different environments.
// By default, return `true` to log errors to the console.
// Forks can return `false` if this isn't desirable.
function showErrorDialog(boundary, errorInfo) {
  return true;
}

function logCapturedError(boundary, errorInfo) {
  try {
    var logError = showErrorDialog(boundary, errorInfo); // Allow injected showErrorDialog() to prevent default console.error logging.
    // This enables renderers like ReactNative to better manage redbox behavior.

    if (logError === false) {
      return;
    }

    var error = errorInfo.value;

    if (true) {
      var source = errorInfo.source;
      var stack = errorInfo.stack;
      var componentStack = stack !== null ? stack : ''; // Browsers support silencing uncaught errors by calling
      // `preventDefault()` in window `error` handler.
      // We record this information as an expando on the error.

      if (error != null && error._suppressLogging) {
        if (boundary.tag === ClassComponent) {
          // The error is recoverable and was silenced.
          // Ignore it and don't print the stack addendum.
          // This is handy for testing error boundaries without noise.
          return;
        } // The error is fatal. Since the silencing might have
        // been accidental, we'll surface it anyway.
        // However, the browser would have silenced the original error
        // so we'll print it first, and then print the stack addendum.


        console['error'](error); // Don't transform to our wrapper
        // For a more detailed description of this block, see:
        // https://github.com/facebook/react/pull/13384
      }

      var componentName = source ? getComponentName(source.type) : null;
      var componentNameMessage = componentName ? "The above error occurred in the <" + componentName + "> component:" : 'The above error occurred in one of your React components:';
      var errorBoundaryMessage;
      var errorBoundaryName = getComponentName(boundary.type);

      if (errorBoundaryName) {
        errorBoundaryMessage = "React will try to recreate this component tree from scratch " + ("using the error boundary you provided, " + errorBoundaryName + ".");
      } else {
        errorBoundaryMessage = 'Consider adding an error boundary to your tree to customize error handling behavior.\n' + 'Visit https://reactjs.org/link/error-boundaries to learn more about error boundaries.';
      }

      var combinedMessage = componentNameMessage + "\n" + componentStack + "\n\n" + ("" + errorBoundaryMessage); // In development, we provide our own message with just the component stack.
      // We don't include the original error message and JS stack because the browser
      // has already printed it. Even if the application swallows the error, it is still
      // displayed by the browser thanks to the DEV-only fake event trick in ReactErrorUtils.

      console['error'](combinedMessage); // Don't transform to our wrapper
    } else {}
  } catch (e) {
    // This method must not throw, or React internal state will get messed up.
    // If console.error is overridden, or logCapturedError() shows a dialog that throws,
    // we want to report this error outside of the normal stack as a last resort.
    // https://github.com/facebook/react/issues/13188
    setTimeout(function () {
      throw e;
    });
  }
}

var PossiblyWeakMap$1 = typeof WeakMap === 'function' ? WeakMap : Map;

function createRootErrorUpdate(fiber, errorInfo, lane) {
  var update = createUpdate(NoTimestamp, lane); // Unmount the root by rendering null.

  update.tag = CaptureUpdate; // Caution: React DevTools currently depends on this property
  // being called "element".

  update.payload = {
    element: null
  };
  var error = errorInfo.value;

  update.callback = function () {
    onUncaughtError(error);
    logCapturedError(fiber, errorInfo);
  };

  return update;
}

function createClassErrorUpdate(fiber, errorInfo, lane) {
  var update = createUpdate(NoTimestamp, lane);
  update.tag = CaptureUpdate;
  var getDerivedStateFromError = fiber.type.getDerivedStateFromError;

  if (typeof getDerivedStateFromError === 'function') {
    var error$1 = errorInfo.value;

    update.payload = function () {
      logCapturedError(fiber, errorInfo);
      return getDerivedStateFromError(error$1);
    };
  }

  var inst = fiber.stateNode;

  if (inst !== null && typeof inst.componentDidCatch === 'function') {
    update.callback = function callback() {
      {
        markFailedErrorBoundaryForHotReloading(fiber);
      }

      if (typeof getDerivedStateFromError !== 'function') {
        // To preserve the preexisting retry behavior of error boundaries,
        // we keep track of which ones already failed during this batch.
        // This gets reset before we yield back to the browser.
        // TODO: Warn in strict mode if getDerivedStateFromError is
        // not defined.
        markLegacyErrorBoundaryAsFailed(this); // Only log here if componentDidCatch is the only error boundary method defined

        logCapturedError(fiber, errorInfo);
      }

      var error$1 = errorInfo.value;
      var stack = errorInfo.stack;
      this.componentDidCatch(error$1, {
        componentStack: stack !== null ? stack : ''
      });

      {
        if (typeof getDerivedStateFromError !== 'function') {
          // If componentDidCatch is the only error boundary method defined,
          // then it needs to call setState to recover from errors.
          // If no state update is scheduled then the boundary will swallow the error.
          if (!includesSomeLane(fiber.lanes, SyncLane)) {
            error('%s: Error boundaries should implement getDerivedStateFromError(). ' + 'In that method, return a state update to display an error message or fallback UI.', getComponentName(fiber.type) || 'Unknown');
          }
        }
      }
    };
  } else {
    update.callback = function () {
      markFailedErrorBoundaryForHotReloading(fiber);
    };
  }

  return update;
}

function attachPingListener(root, wakeable, lanes) {
  // Attach a listener to the promise to "ping" the root and retry. But only if
  // one does not already exist for the lanes we're currently rendering (which
  // acts like a "thread ID" here).
  var pingCache = root.pingCache;
  var threadIDs;

  if (pingCache === null) {
    pingCache = root.pingCache = new PossiblyWeakMap$1();
    threadIDs = new Set();
    pingCache.set(wakeable, threadIDs);
  } else {
    threadIDs = pingCache.get(wakeable);

    if (threadIDs === undefined) {
      threadIDs = new Set();
      pingCache.set(wakeable, threadIDs);
    }
  }

  if (!threadIDs.has(lanes)) {
    // Memoize using the thread ID to prevent redundant listeners.
    threadIDs.add(lanes);
    var ping = pingSuspendedRoot.bind(null, root, wakeable, lanes);
    wakeable.then(ping, ping);
  }
}

function throwException(root, returnFiber, sourceFiber, value, rootRenderLanes) {
  // The source fiber did not complete.
  sourceFiber.flags |= Incomplete; // Its effect list is no longer valid.

  sourceFiber.firstEffect = sourceFiber.lastEffect = null;

  if (value !== null && typeof value === 'object' && typeof value.then === 'function') {
    // This is a wakeable.
    var wakeable = value;

    if ((sourceFiber.mode & BlockingMode) === NoMode) {
      // Reset the memoizedState to what it was before we attempted
      // to render it.
      var currentSource = sourceFiber.alternate;

      if (currentSource) {
        sourceFiber.updateQueue = currentSource.updateQueue;
        sourceFiber.memoizedState = currentSource.memoizedState;
        sourceFiber.lanes = currentSource.lanes;
      } else {
        sourceFiber.updateQueue = null;
        sourceFiber.memoizedState = null;
      }
    }

    var hasInvisibleParentBoundary = hasSuspenseContext(suspenseStackCursor.current, InvisibleParentSuspenseContext); // Schedule the nearest Suspense to re-render the timed out view.

    var _workInProgress = returnFiber;

    do {
      if (_workInProgress.tag === SuspenseComponent && shouldCaptureSuspense(_workInProgress, hasInvisibleParentBoundary)) {
        // Found the nearest boundary.
        // Stash the promise on the boundary fiber. If the boundary times out, we'll
        // attach another listener to flip the boundary back to its normal state.
        var wakeables = _workInProgress.updateQueue;

        if (wakeables === null) {
          var updateQueue = new Set();
          updateQueue.add(wakeable);
          _workInProgress.updateQueue = updateQueue;
        } else {
          wakeables.add(wakeable);
        } // If the boundary is outside of blocking mode, we should *not*
        // suspend the commit. Pretend as if the suspended component rendered
        // null and keep rendering. In the commit phase, we'll schedule a
        // subsequent synchronous update to re-render the Suspense.
        //
        // Note: It doesn't matter whether the component that suspended was
        // inside a blocking mode tree. If the Suspense is outside of it, we
        // should *not* suspend the commit.


        if ((_workInProgress.mode & BlockingMode) === NoMode) {
          _workInProgress.flags |= DidCapture;
          sourceFiber.flags |= ForceUpdateForLegacySuspense; // We're going to commit this fiber even though it didn't complete.
          // But we shouldn't call any lifecycle methods or callbacks. Remove
          // all lifecycle effect tags.

          sourceFiber.flags &= ~(LifecycleEffectMask | Incomplete);

          if (sourceFiber.tag === ClassComponent) {
            var currentSourceFiber = sourceFiber.alternate;

            if (currentSourceFiber === null) {
              // This is a new mount. Change the tag so it's not mistaken for a
              // completed class component. For example, we should not call
              // componentWillUnmount if it is deleted.
              sourceFiber.tag = IncompleteClassComponent;
            } else {
              // When we try rendering again, we should not reuse the current fiber,
              // since it's known to be in an inconsistent state. Use a force update to
              // prevent a bail out.
              var update = createUpdate(NoTimestamp, SyncLane);
              update.tag = ForceUpdate;
              enqueueUpdate(sourceFiber, update);
            }
          } // The source fiber did not complete. Mark it with Sync priority to
          // indicate that it still has pending work.


          sourceFiber.lanes = mergeLanes(sourceFiber.lanes, SyncLane); // Exit without suspending.

          return;
        } // Confirmed that the boundary is in a concurrent mode tree. Continue
        // with the normal suspend path.
        //
        // After this we'll use a set of heuristics to determine whether this
        // render pass will run to completion or restart or "suspend" the commit.
        // The actual logic for this is spread out in different places.
        //
        // This first principle is that if we're going to suspend when we complete
        // a root, then we should also restart if we get an update or ping that
        // might unsuspend it, and vice versa. The only reason to suspend is
        // because you think you might want to restart before committing. However,
        // it doesn't make sense to restart only while in the period we're suspended.
        //
        // Restarting too aggressively is also not good because it starves out any
        // intermediate loading state. So we use heuristics to determine when.
        // Suspense Heuristics
        //
        // If nothing threw a Promise or all the same fallbacks are already showing,
        // then don't suspend/restart.
        //
        // If this is an initial render of a new tree of Suspense boundaries and
        // those trigger a fallback, then don't suspend/restart. We want to ensure
        // that we can show the initial loading state as quickly as possible.
        //
        // If we hit a "Delayed" case, such as when we'd switch from content back into
        // a fallback, then we should always suspend/restart. Transitions apply
        // to this case. If none is defined, JND is used instead.
        //
        // If we're already showing a fallback and it gets "retried", allowing us to show
        // another level, but there's still an inner boundary that would show a fallback,
        // then we suspend/restart for 500ms since the last time we showed a fallback
        // anywhere in the tree. This effectively throttles progressive loading into a
        // consistent train of commits. This also gives us an opportunity to restart to
        // get to the completed state slightly earlier.
        //
        // If there's ambiguity due to batching it's resolved in preference of:
        // 1) "delayed", 2) "initial render", 3) "retry".
        //
        // We want to ensure that a "busy" state doesn't get force committed. We want to
        // ensure that new initial loading states can commit as soon as possible.


        attachPingListener(root, wakeable, rootRenderLanes);
        _workInProgress.flags |= ShouldCapture;
        _workInProgress.lanes = rootRenderLanes;
        return;
      } // This boundary already captured during this render. Continue to the next
      // boundary.


      _workInProgress = _workInProgress.return;
    } while (_workInProgress !== null); // No boundary was found. Fallthrough to error mode.
    // TODO: Use invariant so the message is stripped in prod?


    value = new Error((getComponentName(sourceFiber.type) || 'A React component') + ' suspended while rendering, but no fallback UI was specified.\n' + '\n' + 'Add a <Suspense fallback=...> component higher in the tree to ' + 'provide a loading indicator or placeholder to display.');
  } // We didn't find a boundary that could handle this type of exception. Start
  // over and traverse parent path again, this time treating the exception
  // as an error.


  renderDidError();
  value = createCapturedValue(value, sourceFiber);
  var workInProgress = returnFiber;

  do {
    switch (workInProgress.tag) {
      case HostRoot:
        {
          var _errorInfo = value;
          workInProgress.flags |= ShouldCapture;
          var lane = pickArbitraryLane(rootRenderLanes);
          workInProgress.lanes = mergeLanes(workInProgress.lanes, lane);

          var _update = createRootErrorUpdate(workInProgress, _errorInfo, lane);

          enqueueCapturedUpdate(workInProgress, _update);
          return;
        }

      case ClassComponent:
        // Capture and retry
        var errorInfo = value;
        var ctor = workInProgress.type;
        var instance = workInProgress.stateNode;

        if ((workInProgress.flags & DidCapture) === NoFlags && (typeof ctor.getDerivedStateFromError === 'function' || instance !== null && typeof instance.componentDidCatch === 'function' && !isAlreadyFailedLegacyErrorBoundary(instance))) {
          workInProgress.flags |= ShouldCapture;

          var _lane = pickArbitraryLane(rootRenderLanes);

          workInProgress.lanes = mergeLanes(workInProgress.lanes, _lane); // Schedule the error boundary to re-render using updated state

          var _update2 = createClassErrorUpdate(workInProgress, errorInfo, _lane);

          enqueueCapturedUpdate(workInProgress, _update2);
          return;
        }

        break;
    }

    workInProgress = workInProgress.return;
  } while (workInProgress !== null);
}

var didWarnAboutUndefinedSnapshotBeforeUpdate = null;

{
  didWarnAboutUndefinedSnapshotBeforeUpdate = new Set();
}

var PossiblyWeakSet = typeof WeakSet === 'function' ? WeakSet : Set;

var callComponentWillUnmountWithTimer = function (current, instance) {
  instance.props = current.memoizedProps;
  instance.state = current.memoizedState;

  {
    instance.componentWillUnmount();
  }
}; // Capture errors so they don't interrupt unmounting.


function safelyCallComponentWillUnmount(current, instance) {
  {
    invokeGuardedCallback(null, callComponentWillUnmountWithTimer, null, current, instance);

    if (hasCaughtError()) {
      var unmountError = clearCaughtError();
      captureCommitPhaseError(current, unmountError);
    }
  }
}

function safelyDetachRef(current) {
  var ref = current.ref;

  if (ref !== null) {
    if (typeof ref === 'function') {
      {
        invokeGuardedCallback(null, ref, null, null);

        if (hasCaughtError()) {
          var refError = clearCaughtError();
          captureCommitPhaseError(current, refError);
        }
      }
    } else {
      ref.current = null;
    }
  }
}

function safelyCallDestroy(current, destroy) {
  {
    invokeGuardedCallback(null, destroy, null);

    if (hasCaughtError()) {
      var error = clearCaughtError();
      captureCommitPhaseError(current, error);
    }
  }
}

function commitBeforeMutationLifeCycles(current, finishedWork) {
  switch (finishedWork.tag) {
    case FunctionComponent:
    case ForwardRef:
    case SimpleMemoComponent:
    case Block:
      {
        return;
      }

    case ClassComponent:
      {
        if (finishedWork.flags & Snapshot) {
          if (current !== null) {
            var prevProps = current.memoizedProps;
            var prevState = current.memoizedState;
            var instance = finishedWork.stateNode; // We could update instance props and state here,
            // but instead we rely on them being set during last render.
            // TODO: revisit this when we implement resuming.

            {
              if (finishedWork.type === finishedWork.elementType && !didWarnAboutReassigningProps) {
                if (instance.props !== finishedWork.memoizedProps) {
                  error('Expected %s props to match memoized props before ' + 'getSnapshotBeforeUpdate. ' + 'This might either be because of a bug in React, or because ' + 'a component reassigns its own `this.props`. ' + 'Please file an issue.', getComponentName(finishedWork.type) || 'instance');
                }

                if (instance.state !== finishedWork.memoizedState) {
                  error('Expected %s state to match memoized state before ' + 'getSnapshotBeforeUpdate. ' + 'This might either be because of a bug in React, or because ' + 'a component reassigns its own `this.state`. ' + 'Please file an issue.', getComponentName(finishedWork.type) || 'instance');
                }
              }
            }

            var snapshot = instance.getSnapshotBeforeUpdate(finishedWork.elementType === finishedWork.type ? prevProps : resolveDefaultProps(finishedWork.type, prevProps), prevState);

            {
              var didWarnSet = didWarnAboutUndefinedSnapshotBeforeUpdate;

              if (snapshot === undefined && !didWarnSet.has(finishedWork.type)) {
                didWarnSet.add(finishedWork.type);

                error('%s.getSnapshotBeforeUpdate(): A snapshot value (or null) ' + 'must be returned. You have returned undefined.', getComponentName(finishedWork.type));
              }
            }

            instance.__reactInternalSnapshotBeforeUpdate = snapshot;
          }
        }

        return;
      }

    case HostRoot:
      {
        {
          if (finishedWork.flags & Snapshot) {
            var root = finishedWork.stateNode;
            clearContainer(root.containerInfo);
          }
        }

        return;
      }

    case HostComponent:
    case HostText:
    case HostPortal:
    case IncompleteClassComponent:
      // Nothing to do for these component types
      return;
  }

  {
    {
      throw Error( "This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue." );
    }
  }
}

function commitHookEffectListUnmount(tag, finishedWork) {
  var updateQueue = finishedWork.updateQueue;
  var lastEffect = updateQueue !== null ? updateQueue.lastEffect : null;

  if (lastEffect !== null) {
    var firstEffect = lastEffect.next;
    var effect = firstEffect;

    do {
      if ((effect.tag & tag) === tag) {
        // Unmount
        var destroy = effect.destroy;
        effect.destroy = undefined;

        if (destroy !== undefined) {
          destroy();
        }
      }

      effect = effect.next;
    } while (effect !== firstEffect);
  }
}

function commitHookEffectListMount(tag, finishedWork) {
  var updateQueue = finishedWork.updateQueue;
  var lastEffect = updateQueue !== null ? updateQueue.lastEffect : null;

  if (lastEffect !== null) {
    var firstEffect = lastEffect.next;
    var effect = firstEffect;

    do {
      if ((effect.tag & tag) === tag) {
        // Mount
        var create = effect.create;
        effect.destroy = create();

        {
          var destroy = effect.destroy;

          if (destroy !== undefined && typeof destroy !== 'function') {
            var addendum = void 0;

            if (destroy === null) {
              addendum = ' You returned null. If your effect does not require clean ' + 'up, return undefined (or nothing).';
            } else if (typeof destroy.then === 'function') {
              addendum = '\n\nIt looks like you wrote useEffect(async () => ...) or returned a Promise. ' + 'Instead, write the async function inside your effect ' + 'and call it immediately:\n\n' + 'useEffect(() => {\n' + '  async function fetchData() {\n' + '    // You can await here\n' + '    const response = await MyAPI.getData(someId);\n' + '    // ...\n' + '  }\n' + '  fetchData();\n' + "}, [someId]); // Or [] if effect doesn't need props or state\n\n" + 'Learn more about data fetching with Hooks: https://reactjs.org/link/hooks-data-fetching';
            } else {
              addendum = ' You returned: ' + destroy;
            }

            error('An effect function must not return anything besides a function, ' + 'which is used for clean-up.%s', addendum);
          }
        }
      }

      effect = effect.next;
    } while (effect !== firstEffect);
  }
}

function schedulePassiveEffects(finishedWork) {
  var updateQueue = finishedWork.updateQueue;
  var lastEffect = updateQueue !== null ? updateQueue.lastEffect : null;

  if (lastEffect !== null) {
    var firstEffect = lastEffect.next;
    var effect = firstEffect;

    do {
      var _effect = effect,
          next = _effect.next,
          tag = _effect.tag;

      if ((tag & Passive$1) !== NoFlags$1 && (tag & HasEffect) !== NoFlags$1) {
        enqueuePendingPassiveHookEffectUnmount(finishedWork, effect);
        enqueuePendingPassiveHookEffectMount(finishedWork, effect);
      }

      effect = next;
    } while (effect !== firstEffect);
  }
}

function commitLifeCycles(finishedRoot, current, finishedWork, committedLanes) {
  switch (finishedWork.tag) {
    case FunctionComponent:
    case ForwardRef:
    case SimpleMemoComponent:
    case Block:
      {
        // At this point layout effects have already been destroyed (during mutation phase).
        // This is done to prevent sibling component effects from interfering with each other,
        // e.g. a destroy function in one component should never override a ref set
        // by a create function in another component during the same commit.
        {
          commitHookEffectListMount(Layout | HasEffect, finishedWork);
        }

        schedulePassiveEffects(finishedWork);
        return;
      }

    case ClassComponent:
      {
        var instance = finishedWork.stateNode;

        if (finishedWork.flags & Update) {
          if (current === null) {
            // We could update instance props and state here,
            // but instead we rely on them being set during last render.
            // TODO: revisit this when we implement resuming.
            {
              if (finishedWork.type === finishedWork.elementType && !didWarnAboutReassigningProps) {
                if (instance.props !== finishedWork.memoizedProps) {
                  error('Expected %s props to match memoized props before ' + 'componentDidMount. ' + 'This might either be because of a bug in React, or because ' + 'a component reassigns its own `this.props`. ' + 'Please file an issue.', getComponentName(finishedWork.type) || 'instance');
                }

                if (instance.state !== finishedWork.memoizedState) {
                  error('Expected %s state to match memoized state before ' + 'componentDidMount. ' + 'This might either be because of a bug in React, or because ' + 'a component reassigns its own `this.state`. ' + 'Please file an issue.', getComponentName(finishedWork.type) || 'instance');
                }
              }
            }

            {
              instance.componentDidMount();
            }
          } else {
            var prevProps = finishedWork.elementType === finishedWork.type ? current.memoizedProps : resolveDefaultProps(finishedWork.type, current.memoizedProps);
            var prevState = current.memoizedState; // We could update instance props and state here,
            // but instead we rely on them being set during last render.
            // TODO: revisit this when we implement resuming.

            {
              if (finishedWork.type === finishedWork.elementType && !didWarnAboutReassigningProps) {
                if (instance.props !== finishedWork.memoizedProps) {
                  error('Expected %s props to match memoized props before ' + 'componentDidUpdate. ' + 'This might either be because of a bug in React, or because ' + 'a component reassigns its own `this.props`. ' + 'Please file an issue.', getComponentName(finishedWork.type) || 'instance');
                }

                if (instance.state !== finishedWork.memoizedState) {
                  error('Expected %s state to match memoized state before ' + 'componentDidUpdate. ' + 'This might either be because of a bug in React, or because ' + 'a component reassigns its own `this.state`. ' + 'Please file an issue.', getComponentName(finishedWork.type) || 'instance');
                }
              }
            }

            {
              instance.componentDidUpdate(prevProps, prevState, instance.__reactInternalSnapshotBeforeUpdate);
            }
          }
        } // TODO: I think this is now always non-null by the time it reaches the
        // commit phase. Consider removing the type check.


        var updateQueue = finishedWork.updateQueue;

        if (updateQueue !== null) {
          {
            if (finishedWork.type === finishedWork.elementType && !didWarnAboutReassigningProps) {
              if (instance.props !== finishedWork.memoizedProps) {
                error('Expected %s props to match memoized props before ' + 'processing the update queue. ' + 'This might either be because of a bug in React, or because ' + 'a component reassigns its own `this.props`. ' + 'Please file an issue.', getComponentName(finishedWork.type) || 'instance');
              }

              if (instance.state !== finishedWork.memoizedState) {
                error('Expected %s state to match memoized state before ' + 'processing the update queue. ' + 'This might either be because of a bug in React, or because ' + 'a component reassigns its own `this.state`. ' + 'Please file an issue.', getComponentName(finishedWork.type) || 'instance');
              }
            }
          } // We could update instance props and state here,
          // but instead we rely on them being set during last render.
          // TODO: revisit this when we implement resuming.


          commitUpdateQueue(finishedWork, updateQueue, instance);
        }

        return;
      }

    case HostRoot:
      {
        // TODO: I think this is now always non-null by the time it reaches the
        // commit phase. Consider removing the type check.
        var _updateQueue = finishedWork.updateQueue;

        if (_updateQueue !== null) {
          var _instance = null;

          if (finishedWork.child !== null) {
            switch (finishedWork.child.tag) {
              case HostComponent:
                _instance = getPublicInstance(finishedWork.child.stateNode);
                break;

              case ClassComponent:
                _instance = finishedWork.child.stateNode;
                break;
            }
          }

          commitUpdateQueue(finishedWork, _updateQueue, _instance);
        }

        return;
      }

    case HostComponent:
      {
        var _instance2 = finishedWork.stateNode; // Renderers may schedule work to be done after host components are mounted
        // (eg DOM renderer may schedule auto-focus for inputs and form controls).
        // These effects should only be committed when components are first mounted,
        // aka when there is no current/alternate.

        if (current === null && finishedWork.flags & Update) {
          var type = finishedWork.type;
          var props = finishedWork.memoizedProps;
          commitMount(_instance2, type, props);
        }

        return;
      }

    case HostText:
      {
        // We have no life-cycles associated with text.
        return;
      }

    case HostPortal:
      {
        // We have no life-cycles associated with portals.
        return;
      }

    case Profiler:
      {
        {
          var _finishedWork$memoize2 = finishedWork.memoizedProps,
              onCommit = _finishedWork$memoize2.onCommit,
              onRender = _finishedWork$memoize2.onRender;
          var effectDuration = finishedWork.stateNode.effectDuration;
          var commitTime = getCommitTime();

          if (typeof onRender === 'function') {
            {
              onRender(finishedWork.memoizedProps.id, current === null ? 'mount' : 'update', finishedWork.actualDuration, finishedWork.treeBaseDuration, finishedWork.actualStartTime, commitTime, finishedRoot.memoizedInteractions);
            }
          }
        }

        return;
      }

    case SuspenseComponent:
      {
        commitSuspenseHydrationCallbacks(finishedRoot, finishedWork);
        return;
      }

    case SuspenseListComponent:
    case IncompleteClassComponent:
    case FundamentalComponent:
    case ScopeComponent:
    case OffscreenComponent:
    case LegacyHiddenComponent:
      return;
  }

  {
    {
      throw Error( "This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue." );
    }
  }
}

function hideOrUnhideAllChildren(finishedWork, isHidden) {
  {
    // We only have the top Fiber that was inserted but we need to recurse down its
    // children to find all the terminal nodes.
    var node = finishedWork;

    while (true) {
      if (node.tag === HostComponent) {
        var instance = node.stateNode;

        if (isHidden) {
          hideInstance(instance);
        } else {
          unhideInstance(node.stateNode, node.memoizedProps);
        }
      } else if (node.tag === HostText) {
        var _instance3 = node.stateNode;

        if (isHidden) {
          hideTextInstance(_instance3);
        } else {
          unhideTextInstance(_instance3, node.memoizedProps);
        }
      } else if ((node.tag === OffscreenComponent || node.tag === LegacyHiddenComponent) && node.memoizedState !== null && node !== finishedWork) ; else if (node.child !== null) {
        node.child.return = node;
        node = node.child;
        continue;
      }

      if (node === finishedWork) {
        return;
      }

      while (node.sibling === null) {
        if (node.return === null || node.return === finishedWork) {
          return;
        }

        node = node.return;
      }

      node.sibling.return = node.return;
      node = node.sibling;
    }
  }
}

function commitAttachRef(finishedWork) {
  var ref = finishedWork.ref;

  if (ref !== null) {
    var instance = finishedWork.stateNode;
    var instanceToUse;

    switch (finishedWork.tag) {
      case HostComponent:
        instanceToUse = getPublicInstance(instance);
        break;

      default:
        instanceToUse = instance;
    } // Moved outside to ensure DCE works with this flag

    if (typeof ref === 'function') {
      ref(instanceToUse);
    } else {
      {
        if (!ref.hasOwnProperty('current')) {
          error('Unexpected ref object provided for %s. ' + 'Use either a ref-setter function or React.createRef().', getComponentName(finishedWork.type));
        }
      }

      ref.current = instanceToUse;
    }
  }
}

function commitDetachRef(current) {
  var currentRef = current.ref;

  if (currentRef !== null) {
    if (typeof currentRef === 'function') {
      currentRef(null);
    } else {
      currentRef.current = null;
    }
  }
} // User-originating errors (lifecycles and refs) should not interrupt
// deletion, so don't let them throw. Host-originating errors should
// interrupt deletion, so it's okay


function commitUnmount(finishedRoot, current, renderPriorityLevel) {
  onCommitUnmount(current);

  switch (current.tag) {
    case FunctionComponent:
    case ForwardRef:
    case MemoComponent:
    case SimpleMemoComponent:
    case Block:
      {
        var updateQueue = current.updateQueue;

        if (updateQueue !== null) {
          var lastEffect = updateQueue.lastEffect;

          if (lastEffect !== null) {
            var firstEffect = lastEffect.next;
            var effect = firstEffect;

            do {
              var _effect2 = effect,
                  destroy = _effect2.destroy,
                  tag = _effect2.tag;

              if (destroy !== undefined) {
                if ((tag & Passive$1) !== NoFlags$1) {
                  enqueuePendingPassiveHookEffectUnmount(current, effect);
                } else {
                  {
                    safelyCallDestroy(current, destroy);
                  }
                }
              }

              effect = effect.next;
            } while (effect !== firstEffect);
          }
        }

        return;
      }

    case ClassComponent:
      {
        safelyDetachRef(current);
        var instance = current.stateNode;

        if (typeof instance.componentWillUnmount === 'function') {
          safelyCallComponentWillUnmount(current, instance);
        }

        return;
      }

    case HostComponent:
      {
        safelyDetachRef(current);
        return;
      }

    case HostPortal:
      {
        // TODO: this is recursive.
        // We are also not using this parent because
        // the portal will get pushed immediately.
        {
          unmountHostComponents(finishedRoot, current);
        }

        return;
      }

    case FundamentalComponent:
      {

        return;
      }

    case DehydratedFragment:
      {

        return;
      }

    case ScopeComponent:
      {

        return;
      }
  }
}

function commitNestedUnmounts(finishedRoot, root, renderPriorityLevel) {
  // While we're inside a removed host node we don't want to call
  // removeChild on the inner nodes because they're removed by the top
  // call anyway. We also want to call componentWillUnmount on all
  // composites before this host node is removed from the tree. Therefore
  // we do an inner loop while we're still inside the host node.
  var node = root;

  while (true) {
    commitUnmount(finishedRoot, node); // Visit children because they may contain more composite or host nodes.
    // Skip portals because commitUnmount() currently visits them recursively.

    if (node.child !== null && ( // If we use mutation we drill down into portals using commitUnmount above.
    // If we don't use mutation we drill down into portals here instead.
     node.tag !== HostPortal)) {
      node.child.return = node;
      node = node.child;
      continue;
    }

    if (node === root) {
      return;
    }

    while (node.sibling === null) {
      if (node.return === null || node.return === root) {
        return;
      }

      node = node.return;
    }

    node.sibling.return = node.return;
    node = node.sibling;
  }
}

function detachFiberMutation(fiber) {
  // Cut off the return pointers to disconnect it from the tree. Ideally, we
  // should clear the child pointer of the parent alternate to let this
  // get GC:ed but we don't know which for sure which parent is the current
  // one so we'll settle for GC:ing the subtree of this child. This child
  // itself will be GC:ed when the parent updates the next time.
  // Note: we cannot null out sibling here, otherwise it can cause issues
  // with findDOMNode and how it requires the sibling field to carry out
  // traversal in a later effect. See PR #16820. We now clear the sibling
  // field after effects, see: detachFiberAfterEffects.
  //
  // Don't disconnect stateNode now; it will be detached in detachFiberAfterEffects.
  // It may be required if the current component is an error boundary,
  // and one of its descendants throws while unmounting a passive effect.
  fiber.alternate = null;
  fiber.child = null;
  fiber.dependencies = null;
  fiber.firstEffect = null;
  fiber.lastEffect = null;
  fiber.memoizedProps = null;
  fiber.memoizedState = null;
  fiber.pendingProps = null;
  fiber.return = null;
  fiber.updateQueue = null;

  {
    fiber._debugOwner = null;
  }
}

function getHostParentFiber(fiber) {
  var parent = fiber.return;

  while (parent !== null) {
    if (isHostParent(parent)) {
      return parent;
    }

    parent = parent.return;
  }

  {
    {
      throw Error( "Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue." );
    }
  }
}

function isHostParent(fiber) {
  return fiber.tag === HostComponent || fiber.tag === HostRoot || fiber.tag === HostPortal;
}

function getHostSibling(fiber) {
  // We're going to search forward into the tree until we find a sibling host
  // node. Unfortunately, if multiple insertions are done in a row we have to
  // search past them. This leads to exponential search for the next sibling.
  // TODO: Find a more efficient way to do this.
  var node = fiber;

  siblings: while (true) {
    // If we didn't find anything, let's try the next sibling.
    while (node.sibling === null) {
      if (node.return === null || isHostParent(node.return)) {
        // If we pop out of the root or hit the parent the fiber we are the
        // last sibling.
        return null;
      }

      node = node.return;
    }

    node.sibling.return = node.return;
    node = node.sibling;

    while (node.tag !== HostComponent && node.tag !== HostText && node.tag !== DehydratedFragment) {
      // If it is not host node and, we might have a host node inside it.
      // Try to search down until we find one.
      if (node.flags & Placement) {
        // If we don't have a child, try the siblings instead.
        continue siblings;
      } // If we don't have a child, try the siblings instead.
      // We also skip portals because they are not part of this host tree.


      if (node.child === null || node.tag === HostPortal) {
        continue siblings;
      } else {
        node.child.return = node;
        node = node.child;
      }
    } // Check if this host node is stable or about to be placed.


    if (!(node.flags & Placement)) {
      // Found it!
      return node.stateNode;
    }
  }
}

function commitPlacement(finishedWork) {


  var parentFiber = getHostParentFiber(finishedWork); // Note: these two variables *must* always be updated together.

  var parent;
  var isContainer;
  var parentStateNode = parentFiber.stateNode;

  switch (parentFiber.tag) {
    case HostComponent:
      parent = parentStateNode;
      isContainer = false;
      break;

    case HostRoot:
      parent = parentStateNode.containerInfo;
      isContainer = true;
      break;

    case HostPortal:
      parent = parentStateNode.containerInfo;
      isContainer = true;
      break;

    case FundamentalComponent:

    // eslint-disable-next-line-no-fallthrough

    default:
      {
        {
          throw Error( "Invalid host parent fiber. This error is likely caused by a bug in React. Please file an issue." );
        }
      }

  }

  if (parentFiber.flags & ContentReset) {
    // Reset the text content of the parent before doing any insertions
    resetTextContent(parent); // Clear ContentReset from the effect tag

    parentFiber.flags &= ~ContentReset;
  }

  var before = getHostSibling(finishedWork); // We only have the top Fiber that was inserted but we need to recurse down its
  // children to find all the terminal nodes.

  if (isContainer) {
    insertOrAppendPlacementNodeIntoContainer(finishedWork, before, parent);
  } else {
    insertOrAppendPlacementNode(finishedWork, before, parent);
  }
}

function insertOrAppendPlacementNodeIntoContainer(node, before, parent) {
  var tag = node.tag;
  var isHost = tag === HostComponent || tag === HostText;

  if (isHost || enableFundamentalAPI ) {
    var stateNode = isHost ? node.stateNode : node.stateNode.instance;

    if (before) {
      insertInContainerBefore(parent, stateNode, before);
    } else {
      appendChildToContainer(parent, stateNode);
    }
  } else if (tag === HostPortal) ; else {
    var child = node.child;

    if (child !== null) {
      insertOrAppendPlacementNodeIntoContainer(child, before, parent);
      var sibling = child.sibling;

      while (sibling !== null) {
        insertOrAppendPlacementNodeIntoContainer(sibling, before, parent);
        sibling = sibling.sibling;
      }
    }
  }
}

function insertOrAppendPlacementNode(node, before, parent) {
  var tag = node.tag;
  var isHost = tag === HostComponent || tag === HostText;

  if (isHost || enableFundamentalAPI ) {
    var stateNode = isHost ? node.stateNode : node.stateNode.instance;

    if (before) {
      insertBefore(parent, stateNode, before);
    } else {
      appendChild(parent, stateNode);
    }
  } else if (tag === HostPortal) ; else {
    var child = node.child;

    if (child !== null) {
      insertOrAppendPlacementNode(child, before, parent);
      var sibling = child.sibling;

      while (sibling !== null) {
        insertOrAppendPlacementNode(sibling, before, parent);
        sibling = sibling.sibling;
      }
    }
  }
}

function unmountHostComponents(finishedRoot, current, renderPriorityLevel) {
  // We only have the top Fiber that was deleted but we need to recurse down its
  // children to find all the terminal nodes.
  var node = current; // Each iteration, currentParent is populated with node's host parent if not
  // currentParentIsValid.

  var currentParentIsValid = false; // Note: these two variables *must* always be updated together.

  var currentParent;
  var currentParentIsContainer;

  while (true) {
    if (!currentParentIsValid) {
      var parent = node.return;

      findParent: while (true) {
        if (!(parent !== null)) {
          {
            throw Error( "Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue." );
          }
        }

        var parentStateNode = parent.stateNode;

        switch (parent.tag) {
          case HostComponent:
            currentParent = parentStateNode;
            currentParentIsContainer = false;
            break findParent;

          case HostRoot:
            currentParent = parentStateNode.containerInfo;
            currentParentIsContainer = true;
            break findParent;

          case HostPortal:
            currentParent = parentStateNode.containerInfo;
            currentParentIsContainer = true;
            break findParent;

        }

        parent = parent.return;
      }

      currentParentIsValid = true;
    }

    if (node.tag === HostComponent || node.tag === HostText) {
      commitNestedUnmounts(finishedRoot, node); // After all the children have unmounted, it is now safe to remove the
      // node from the tree.

      if (currentParentIsContainer) {
        removeChildFromContainer(currentParent, node.stateNode);
      } else {
        removeChild(currentParent, node.stateNode);
      } // Don't visit children because we already visited them.

    } else if (node.tag === HostPortal) {
      if (node.child !== null) {
        // When we go into a portal, it becomes the parent to remove from.
        // We will reassign it back when we pop the portal on the way up.
        currentParent = node.stateNode.containerInfo;
        currentParentIsContainer = true; // Visit children because portals might contain host components.

        node.child.return = node;
        node = node.child;
        continue;
      }
    } else {
      commitUnmount(finishedRoot, node); // Visit children because we may find more host components below.

      if (node.child !== null) {
        node.child.return = node;
        node = node.child;
        continue;
      }
    }

    if (node === current) {
      return;
    }

    while (node.sibling === null) {
      if (node.return === null || node.return === current) {
        return;
      }

      node = node.return;

      if (node.tag === HostPortal) {
        // When we go out of the portal, we need to restore the parent.
        // Since we don't keep a stack of them, we will search for it.
        currentParentIsValid = false;
      }
    }

    node.sibling.return = node.return;
    node = node.sibling;
  }
}

function commitDeletion(finishedRoot, current, renderPriorityLevel) {
  {
    // Recursively delete all host nodes from the parent.
    // Detach refs and call componentWillUnmount() on the whole subtree.
    unmountHostComponents(finishedRoot, current);
  }

  var alternate = current.alternate;
  detachFiberMutation(current);

  if (alternate !== null) {
    detachFiberMutation(alternate);
  }
}

function commitWork(current, finishedWork) {

  switch (finishedWork.tag) {
    case FunctionComponent:
    case ForwardRef:
    case MemoComponent:
    case SimpleMemoComponent:
    case Block:
      {
        // Layout effects are destroyed during the mutation phase so that all
        // destroy functions for all fibers are called before any create functions.
        // This prevents sibling component effects from interfering with each other,
        // e.g. a destroy function in one component should never override a ref set
        // by a create function in another component during the same commit.
        {
          commitHookEffectListUnmount(Layout | HasEffect, finishedWork);
        }

        return;
      }

    case ClassComponent:
      {
        return;
      }

    case HostComponent:
      {
        var instance = finishedWork.stateNode;

        if (instance != null) {
          // Commit the work prepared earlier.
          var newProps = finishedWork.memoizedProps; // For hydration we reuse the update path but we treat the oldProps
          // as the newProps. The updatePayload will contain the real change in
          // this case.

          var oldProps = current !== null ? current.memoizedProps : newProps;
          var type = finishedWork.type; // TODO: Type the updateQueue to be specific to host components.

          var updatePayload = finishedWork.updateQueue;
          finishedWork.updateQueue = null;

          if (updatePayload !== null) {
            commitUpdate(instance, updatePayload, type, oldProps, newProps);
          }
        }

        return;
      }

    case HostText:
      {
        if (!(finishedWork.stateNode !== null)) {
          {
            throw Error( "This should have a text node initialized. This error is likely caused by a bug in React. Please file an issue." );
          }
        }

        var textInstance = finishedWork.stateNode;
        var newText = finishedWork.memoizedProps; // For hydration we reuse the update path but we treat the oldProps
        // as the newProps. The updatePayload will contain the real change in
        // this case.

        var oldText = current !== null ? current.memoizedProps : newText;
        commitTextUpdate(textInstance, oldText, newText);
        return;
      }

    case HostRoot:
      {
        {
          var _root = finishedWork.stateNode;

          if (_root.hydrate) {
            // We've just hydrated. No need to hydrate again.
            _root.hydrate = false;
            commitHydratedContainer(_root.containerInfo);
          }
        }

        return;
      }

    case Profiler:
      {
        return;
      }

    case SuspenseComponent:
      {
        commitSuspenseComponent(finishedWork);
        attachSuspenseRetryListeners(finishedWork);
        return;
      }

    case SuspenseListComponent:
      {
        attachSuspenseRetryListeners(finishedWork);
        return;
      }

    case IncompleteClassComponent:
      {
        return;
      }

    case FundamentalComponent:
      {

        break;
      }

    case ScopeComponent:
      {

        break;
      }

    case OffscreenComponent:
    case LegacyHiddenComponent:
      {
        var newState = finishedWork.memoizedState;
        var isHidden = newState !== null;
        hideOrUnhideAllChildren(finishedWork, isHidden);
        return;
      }
  }

  {
    {
      throw Error( "This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue." );
    }
  }
}

function commitSuspenseComponent(finishedWork) {
  var newState = finishedWork.memoizedState;

  if (newState !== null) {
    markCommitTimeOfFallback();

    {
      // Hide the Offscreen component that contains the primary children. TODO:
      // Ideally, this effect would have been scheduled on the Offscreen fiber
      // itself. That's how unhiding works: the Offscreen component schedules an
      // effect on itself. However, in this case, the component didn't complete,
      // so the fiber was never added to the effect list in the normal path. We
      // could have appended it to the effect list in the Suspense component's
      // second pass, but doing it this way is less complicated. This would be
      // simpler if we got rid of the effect list and traversed the tree, like
      // we're planning to do.
      var primaryChildParent = finishedWork.child;
      hideOrUnhideAllChildren(primaryChildParent, true);
    }
  }
}

function commitSuspenseHydrationCallbacks(finishedRoot, finishedWork) {

  var newState = finishedWork.memoizedState;

  if (newState === null) {
    var current = finishedWork.alternate;

    if (current !== null) {
      var prevState = current.memoizedState;

      if (prevState !== null) {
        var suspenseInstance = prevState.dehydrated;

        if (suspenseInstance !== null) {
          commitHydratedSuspenseInstance(suspenseInstance);
        }
      }
    }
  }
}

function attachSuspenseRetryListeners(finishedWork) {
  // If this boundary just timed out, then it will have a set of wakeables.
  // For each wakeable, attach a listener so that when it resolves, React
  // attempts to re-render the boundary in the primary (pre-timeout) state.
  var wakeables = finishedWork.updateQueue;

  if (wakeables !== null) {
    finishedWork.updateQueue = null;
    var retryCache = finishedWork.stateNode;

    if (retryCache === null) {
      retryCache = finishedWork.stateNode = new PossiblyWeakSet();
    }

    wakeables.forEach(function (wakeable) {
      // Memoize using the boundary fiber to prevent redundant listeners.
      var retry = resolveRetryWakeable.bind(null, finishedWork, wakeable);

      if (!retryCache.has(wakeable)) {
        {
          if (wakeable.__reactDoNotTraceInteractions !== true) {
            retry = tracing.unstable_wrap(retry);
          }
        }

        retryCache.add(wakeable);
        wakeable.then(retry, retry);
      }
    });
  }
} // This function detects when a Suspense boundary goes from visible to hidden.
// It returns false if the boundary is already hidden.
// TODO: Use an effect tag.


function isSuspenseBoundaryBeingHidden(current, finishedWork) {
  if (current !== null) {
    var oldState = current.memoizedState;

    if (oldState === null || oldState.dehydrated !== null) {
      var newState = finishedWork.memoizedState;
      return newState !== null && newState.dehydrated === null;
    }
  }

  return false;
}

function commitResetTextContent(current) {

  resetTextContent(current.stateNode);
}

var COMPONENT_TYPE = 0;
var HAS_PSEUDO_CLASS_TYPE = 1;
var ROLE_TYPE = 2;
var TEST_NAME_TYPE = 3;
var TEXT_TYPE = 4;

if (typeof Symbol === 'function' && Symbol.for) {
  var symbolFor$1 = Symbol.for;
  COMPONENT_TYPE = symbolFor$1('selector.component');
  HAS_PSEUDO_CLASS_TYPE = symbolFor$1('selector.has_pseudo_class');
  ROLE_TYPE = symbolFor$1('selector.role');
  TEST_NAME_TYPE = symbolFor$1('selector.test_id');
  TEXT_TYPE = symbolFor$1('selector.text');
}
var commitHooks = [];
function onCommitRoot$1() {
  {
    commitHooks.forEach(function (commitHook) {
      return commitHook();
    });
  }
}

var ceil = Math.ceil;
var ReactCurrentDispatcher$2 = ReactSharedInternals.ReactCurrentDispatcher,
    ReactCurrentOwner$2 = ReactSharedInternals.ReactCurrentOwner,
    IsSomeRendererActing = ReactSharedInternals.IsSomeRendererActing;
var NoContext =
/*             */
0;
var BatchedContext =
/*               */
1;
var EventContext =
/*                 */
2;
var DiscreteEventContext =
/*         */
4;
var LegacyUnbatchedContext =
/*       */
8;
var RenderContext =
/*                */
16;
var CommitContext =
/*                */
32;
var RetryAfterError =
/*       */
64;
var RootIncomplete = 0;
var RootFatalErrored = 1;
var RootErrored = 2;
var RootSuspended = 3;
var RootSuspendedWithDelay = 4;
var RootCompleted = 5; // Describes where we are in the React execution stack

var executionContext = NoContext; // The root we're working on

var workInProgressRoot = null; // The fiber we're working on

var workInProgress = null; // The lanes we're rendering

var workInProgressRootRenderLanes = NoLanes; // Stack that allows components to change the render lanes for its subtree
// This is a superset of the lanes we started working on at the root. The only
// case where it's different from `workInProgressRootRenderLanes` is when we
// enter a subtree that is hidden and needs to be unhidden: Suspense and
// Offscreen component.
//
// Most things in the work loop should deal with workInProgressRootRenderLanes.
// Most things in begin/complete phases should deal with subtreeRenderLanes.

var subtreeRenderLanes = NoLanes;
var subtreeRenderLanesCursor = createCursor(NoLanes); // Whether to root completed, errored, suspended, etc.

var workInProgressRootExitStatus = RootIncomplete; // A fatal error, if one is thrown

var workInProgressRootFatalError = null; // "Included" lanes refer to lanes that were worked on during this render. It's
// slightly different than `renderLanes` because `renderLanes` can change as you
// enter and exit an Offscreen tree. This value is the combination of all render
// lanes for the entire render phase.

var workInProgressRootIncludedLanes = NoLanes; // The work left over by components that were visited during this render. Only
// includes unprocessed updates, not work in bailed out children.

var workInProgressRootSkippedLanes = NoLanes; // Lanes that were updated (in an interleaved event) during this render.

var workInProgressRootUpdatedLanes = NoLanes; // Lanes that were pinged (in an interleaved event) during this render.

var workInProgressRootPingedLanes = NoLanes;
var mostRecentlyUpdatedRoot = null; // The most recent time we committed a fallback. This lets us ensure a train
// model where we don't commit new loading states in too quick succession.

var globalMostRecentFallbackTime = 0;
var FALLBACK_THROTTLE_MS = 500; // The absolute time for when we should start giving up on rendering
// more and prefer CPU suspense heuristics instead.

var workInProgressRootRenderTargetTime = Infinity; // How long a render is supposed to take before we start following CPU
// suspense heuristics and opt out of rendering more content.

var RENDER_TIMEOUT_MS = 500;

function resetRenderTimer() {
  workInProgressRootRenderTargetTime = now() + RENDER_TIMEOUT_MS;
}

function getRenderTargetTime() {
  return workInProgressRootRenderTargetTime;
}
var nextEffect = null;
var hasUncaughtError = false;
var firstUncaughtError = null;
var legacyErrorBoundariesThatAlreadyFailed = null;
var rootDoesHavePassiveEffects = false;
var rootWithPendingPassiveEffects = null;
var pendingPassiveEffectsRenderPriority = NoPriority$1;
var pendingPassiveEffectsLanes = NoLanes;
var pendingPassiveHookEffectsMount = [];
var pendingPassiveHookEffectsUnmount = [];
var rootsWithPendingDiscreteUpdates = null; // Use these to prevent an infinite loop of nested updates

var NESTED_UPDATE_LIMIT = 50;
var nestedUpdateCount = 0;
var rootWithNestedUpdates = null;
var NESTED_PASSIVE_UPDATE_LIMIT = 50;
var nestedPassiveUpdateCount = 0; // Marks the need to reschedule pending interactions at these lanes
// during the commit phase. This enables them to be traced across components
// that spawn new work during render. E.g. hidden boundaries, suspended SSR
// hydration or SuspenseList.
// TODO: Can use a bitmask instead of an array

var spawnedWorkDuringRender = null; // If two updates are scheduled within the same event, we should treat their
// event times as simultaneous, even if the actual clock time has advanced
// between the first and second call.

var currentEventTime = NoTimestamp;
var currentEventWipLanes = NoLanes;
var currentEventPendingLanes = NoLanes; // Dev only flag that tracks if passive effects are currently being flushed.
// We warn about state updates for unmounted components differently in this case.

var isFlushingPassiveEffects = false;
var focusedInstanceHandle = null;
var shouldFireAfterActiveInstanceBlur = false;
function getWorkInProgressRoot() {
  return workInProgressRoot;
}
function requestEventTime() {
  if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {
    // We're inside React, so it's fine to read the actual time.
    return now();
  } // We're not inside React, so we may be in the middle of a browser event.


  if (currentEventTime !== NoTimestamp) {
    // Use the same start time for all updates until we enter React again.
    return currentEventTime;
  } // This is the first update since React yielded. Compute a new start time.


  currentEventTime = now();
  return currentEventTime;
}
function requestUpdateLane(fiber) {
  // Special cases
  var mode = fiber.mode;

  if ((mode & BlockingMode) === NoMode) {
    return SyncLane;
  } else if ((mode & ConcurrentMode) === NoMode) {
    return getCurrentPriorityLevel() === ImmediatePriority$1 ? SyncLane : SyncBatchedLane;
  } // The algorithm for assigning an update to a lane should be stable for all
  // updates at the same priority within the same event. To do this, the inputs
  // to the algorithm must be the same. For example, we use the `renderLanes`
  // to avoid choosing a lane that is already in the middle of rendering.
  //
  // However, the "included" lanes could be mutated in between updates in the
  // same event, like if you perform an update inside `flushSync`. Or any other
  // code path that might call `prepareFreshStack`.
  //
  // The trick we use is to cache the first of each of these inputs within an
  // event. Then reset the cached values once we can be sure the event is over.
  // Our heuristic for that is whenever we enter a concurrent work loop.
  //
  // We'll do the same for `currentEventPendingLanes` below.


  if (currentEventWipLanes === NoLanes) {
    currentEventWipLanes = workInProgressRootIncludedLanes;
  }

  var isTransition = requestCurrentTransition() !== NoTransition;

  if (isTransition) {
    if (currentEventPendingLanes !== NoLanes) {
      currentEventPendingLanes = mostRecentlyUpdatedRoot !== null ? mostRecentlyUpdatedRoot.pendingLanes : NoLanes;
    }

    return findTransitionLane(currentEventWipLanes, currentEventPendingLanes);
  } // TODO: Remove this dependency on the Scheduler priority.
  // To do that, we're replacing it with an update lane priority.


  var schedulerPriority = getCurrentPriorityLevel(); // The old behavior was using the priority level of the Scheduler.
  // This couples React to the Scheduler internals, so we're replacing it
  // with the currentUpdateLanePriority above. As an example of how this
  // could be problematic, if we're not inside `Scheduler.runWithPriority`,
  // then we'll get the priority of the current running Scheduler task,
  // which is probably not what we want.

  var lane;

  if ( // TODO: Temporary. We're removing the concept of discrete updates.
  (executionContext & DiscreteEventContext) !== NoContext && schedulerPriority === UserBlockingPriority$2) {
    lane = findUpdateLane(InputDiscreteLanePriority, currentEventWipLanes);
  } else {
    var schedulerLanePriority = schedulerPriorityToLanePriority(schedulerPriority);

    lane = findUpdateLane(schedulerLanePriority, currentEventWipLanes);
  }

  return lane;
}

function requestRetryLane(fiber) {
  // This is a fork of `requestUpdateLane` designed specifically for Suspense
  // "retries"  a special update that attempts to flip a Suspense boundary
  // from its placeholder state to its primary/resolved state.
  // Special cases
  var mode = fiber.mode;

  if ((mode & BlockingMode) === NoMode) {
    return SyncLane;
  } else if ((mode & ConcurrentMode) === NoMode) {
    return getCurrentPriorityLevel() === ImmediatePriority$1 ? SyncLane : SyncBatchedLane;
  } // See `requestUpdateLane` for explanation of `currentEventWipLanes`


  if (currentEventWipLanes === NoLanes) {
    currentEventWipLanes = workInProgressRootIncludedLanes;
  }

  return findRetryLane(currentEventWipLanes);
}

function scheduleUpdateOnFiber(fiber, lane, eventTime) {
  checkForNestedUpdates();
  warnAboutRenderPhaseUpdatesInDEV(fiber);
  var root = markUpdateLaneFromFiberToRoot(fiber, lane);

  if (root === null) {
    warnAboutUpdateOnUnmountedFiberInDEV(fiber);
    return null;
  } // Mark that the root has a pending update.


  markRootUpdated(root, lane, eventTime);

  if (root === workInProgressRoot) {
    // Received an update to a tree that's in the middle of rendering. Mark
    // that there was an interleaved update work on this root. Unless the
    // `deferRenderPhaseUpdateToNextBatch` flag is off and this is a render
    // phase update. In that case, we don't treat render phase updates as if
    // they were interleaved, for backwards compat reasons.
    {
      workInProgressRootUpdatedLanes = mergeLanes(workInProgressRootUpdatedLanes, lane);
    }

    if (workInProgressRootExitStatus === RootSuspendedWithDelay) {
      // The root already suspended with a delay, which means this render
      // definitely won't finish. Since we have a new update, let's mark it as
      // suspended now, right before marking the incoming update. This has the
      // effect of interrupting the current render and switching to the update.
      // TODO: Make sure this doesn't override pings that happen while we've
      // already started rendering.
      markRootSuspended$1(root, workInProgressRootRenderLanes);
    }
  } // TODO: requestUpdateLanePriority also reads the priority. Pass the
  // priority as an argument to that function and this one.


  var priorityLevel = getCurrentPriorityLevel();

  if (lane === SyncLane) {
    if ( // Check if we're inside unbatchedUpdates
    (executionContext & LegacyUnbatchedContext) !== NoContext && // Check if we're not already rendering
    (executionContext & (RenderContext | CommitContext)) === NoContext) {
      // Register pending interactions on the root to avoid losing traced interaction data.
      schedulePendingInteractions(root, lane); // This is a legacy edge case. The initial mount of a ReactDOM.render-ed
      // root inside of batchedUpdates should be synchronous, but layout updates
      // should be deferred until the end of the batch.

      performSyncWorkOnRoot(root);
    } else {
      ensureRootIsScheduled(root, eventTime);
      schedulePendingInteractions(root, lane);

      if (executionContext === NoContext) {
        // Flush the synchronous work now, unless we're already working or inside
        // a batch. This is intentionally inside scheduleUpdateOnFiber instead of
        // scheduleCallbackForFiber to preserve the ability to schedule a callback
        // without immediately flushing it. We only do this for user-initiated
        // updates, to preserve historical behavior of legacy mode.
        resetRenderTimer();
        flushSyncCallbackQueue();
      }
    }
  } else {
    // Schedule a discrete update but only if it's not Sync.
    if ((executionContext & DiscreteEventContext) !== NoContext && ( // Only updates at user-blocking priority or greater are considered
    // discrete, even inside a discrete event.
    priorityLevel === UserBlockingPriority$2 || priorityLevel === ImmediatePriority$1)) {
      // This is the result of a discrete event. Track the lowest priority
      // discrete update per root so we can flush them early, if needed.
      if (rootsWithPendingDiscreteUpdates === null) {
        rootsWithPendingDiscreteUpdates = new Set([root]);
      } else {
        rootsWithPendingDiscreteUpdates.add(root);
      }
    } // Schedule other updates after in case the callback is sync.


    ensureRootIsScheduled(root, eventTime);
    schedulePendingInteractions(root, lane);
  } // We use this when assigning a lane for a transition inside
  // `requestUpdateLane`. We assume it's the same as the root being updated,
  // since in the common case of a single root app it probably is. If it's not
  // the same root, then it's not a huge deal, we just might batch more stuff
  // together more than necessary.


  mostRecentlyUpdatedRoot = root;
} // This is split into a separate function so we can mark a fiber with pending
// work without treating it as a typical update that originates from an event;
// e.g. retrying a Suspense boundary isn't an update, but it does schedule work
// on a fiber.

function markUpdateLaneFromFiberToRoot(sourceFiber, lane) {
  // Update the source fiber's lanes
  sourceFiber.lanes = mergeLanes(sourceFiber.lanes, lane);
  var alternate = sourceFiber.alternate;

  if (alternate !== null) {
    alternate.lanes = mergeLanes(alternate.lanes, lane);
  }

  {
    if (alternate === null && (sourceFiber.flags & (Placement | Hydrating)) !== NoFlags) {
      warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber);
    }
  } // Walk the parent path to the root and update the child expiration time.


  var node = sourceFiber;
  var parent = sourceFiber.return;

  while (parent !== null) {
    parent.childLanes = mergeLanes(parent.childLanes, lane);
    alternate = parent.alternate;

    if (alternate !== null) {
      alternate.childLanes = mergeLanes(alternate.childLanes, lane);
    } else {
      {
        if ((parent.flags & (Placement | Hydrating)) !== NoFlags) {
          warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber);
        }
      }
    }

    node = parent;
    parent = parent.return;
  }

  if (node.tag === HostRoot) {
    var root = node.stateNode;
    return root;
  } else {
    return null;
  }
} // Use this function to schedule a task for a root. There's only one task per
// root; if a task was already scheduled, we'll check to make sure the priority
// of the existing task is the same as the priority of the next level that the
// root has work on. This function is called on every update, and right before
// exiting a task.


function ensureRootIsScheduled(root, currentTime) {
  var existingCallbackNode = root.callbackNode; // Check if any lanes are being starved by other work. If so, mark them as
  // expired so we know to work on those next.

  markStarvedLanesAsExpired(root, currentTime); // Determine the next lanes to work on, and their priority.

  var nextLanes = getNextLanes(root, root === workInProgressRoot ? workInProgressRootRenderLanes : NoLanes); // This returns the priority level computed during the `getNextLanes` call.

  var newCallbackPriority = returnNextLanesPriority();

  if (nextLanes === NoLanes) {
    // Special case: There's nothing to work on.
    if (existingCallbackNode !== null) {
      cancelCallback(existingCallbackNode);
      root.callbackNode = null;
      root.callbackPriority = NoLanePriority;
    }

    return;
  } // Check if there's an existing task. We may be able to reuse it.


  if (existingCallbackNode !== null) {
    var existingCallbackPriority = root.callbackPriority;

    if (existingCallbackPriority === newCallbackPriority) {
      // The priority hasn't changed. We can reuse the existing task. Exit.
      return;
    } // The priority changed. Cancel the existing callback. We'll schedule a new
    // one below.


    cancelCallback(existingCallbackNode);
  } // Schedule a new callback.


  var newCallbackNode;

  if (newCallbackPriority === SyncLanePriority) {
    // Special case: Sync React callbacks are scheduled on a special
    // internal queue
    newCallbackNode = scheduleSyncCallback(performSyncWorkOnRoot.bind(null, root));
  } else if (newCallbackPriority === SyncBatchedLanePriority) {
    newCallbackNode = scheduleCallback(ImmediatePriority$1, performSyncWorkOnRoot.bind(null, root));
  } else {
    var schedulerPriorityLevel = lanePriorityToSchedulerPriority(newCallbackPriority);
    newCallbackNode = scheduleCallback(schedulerPriorityLevel, performConcurrentWorkOnRoot.bind(null, root));
  }

  root.callbackPriority = newCallbackPriority;
  root.callbackNode = newCallbackNode;
} // This is the entry point for every concurrent task, i.e. anything that
// goes through Scheduler.


function performConcurrentWorkOnRoot(root) {
  // Since we know we're in a React event, we can clear the current
  // event time. The next update will compute a new event time.
  currentEventTime = NoTimestamp;
  currentEventWipLanes = NoLanes;
  currentEventPendingLanes = NoLanes;

  if (!((executionContext & (RenderContext | CommitContext)) === NoContext)) {
    {
      throw Error( "Should not already be working." );
    }
  } // Flush any pending passive effects before deciding which lanes to work on,
  // in case they schedule additional work.


  var originalCallbackNode = root.callbackNode;
  var didFlushPassiveEffects = flushPassiveEffects();

  if (didFlushPassiveEffects) {
    // Something in the passive effect phase may have canceled the current task.
    // Check if the task node for this root was changed.
    if (root.callbackNode !== originalCallbackNode) {
      // The current task was canceled. Exit. We don't need to call
      // `ensureRootIsScheduled` because the check above implies either that
      // there's a new task, or that there's no remaining work on this root.
      return null;
    }
  } // Determine the next expiration time to work on, using the fields stored
  // on the root.


  var lanes = getNextLanes(root, root === workInProgressRoot ? workInProgressRootRenderLanes : NoLanes);

  if (lanes === NoLanes) {
    // Defensive coding. This is never expected to happen.
    return null;
  }

  var exitStatus = renderRootConcurrent(root, lanes);

  if (includesSomeLane(workInProgressRootIncludedLanes, workInProgressRootUpdatedLanes)) {
    // The render included lanes that were updated during the render phase.
    // For example, when unhiding a hidden tree, we include all the lanes
    // that were previously skipped when the tree was hidden. That set of
    // lanes is a superset of the lanes we started rendering with.
    //
    // So we'll throw out the current work and restart.
    prepareFreshStack(root, NoLanes);
  } else if (exitStatus !== RootIncomplete) {
    if (exitStatus === RootErrored) {
      executionContext |= RetryAfterError; // If an error occurred during hydration,
      // discard server response and fall back to client side render.

      if (root.hydrate) {
        root.hydrate = false;
        clearContainer(root.containerInfo);
      } // If something threw an error, try rendering one more time. We'll render
      // synchronously to block concurrent data mutations, and we'll includes
      // all pending updates are included. If it still fails after the second
      // attempt, we'll give up and commit the resulting tree.


      lanes = getLanesToRetrySynchronouslyOnError(root);

      if (lanes !== NoLanes) {
        exitStatus = renderRootSync(root, lanes);
      }
    }

    if (exitStatus === RootFatalErrored) {
      var fatalError = workInProgressRootFatalError;
      prepareFreshStack(root, NoLanes);
      markRootSuspended$1(root, lanes);
      ensureRootIsScheduled(root, now());
      throw fatalError;
    } // We now have a consistent tree. The next step is either to commit it,
    // or, if something suspended, wait to commit it after a timeout.


    var finishedWork = root.current.alternate;
    root.finishedWork = finishedWork;
    root.finishedLanes = lanes;
    finishConcurrentRender(root, exitStatus, lanes);
  }

  ensureRootIsScheduled(root, now());

  if (root.callbackNode === originalCallbackNode) {
    // The task node scheduled for this root is the same one that's
    // currently executed. Need to return a continuation.
    return performConcurrentWorkOnRoot.bind(null, root);
  }

  return null;
}

function finishConcurrentRender(root, exitStatus, lanes) {
  switch (exitStatus) {
    case RootIncomplete:
    case RootFatalErrored:
      {
        {
          {
            throw Error( "Root did not complete. This is a bug in React." );
          }
        }
      }
    // Flow knows about invariant, so it complains if I add a break
    // statement, but eslint doesn't know about invariant, so it complains
    // if I do. eslint-disable-next-line no-fallthrough

    case RootErrored:
      {
        // We should have already attempted to retry this tree. If we reached
        // this point, it errored again. Commit it.
        commitRoot(root);
        break;
      }

    case RootSuspended:
      {
        markRootSuspended$1(root, lanes); // We have an acceptable loading state. We need to figure out if we
        // should immediately commit it or wait a bit.

        if (includesOnlyRetries(lanes) && // do not delay if we're inside an act() scope
        !shouldForceFlushFallbacksInDEV()) {
          // This render only included retries, no updates. Throttle committing
          // retries so that we don't show too many loading states too quickly.
          var msUntilTimeout = globalMostRecentFallbackTime + FALLBACK_THROTTLE_MS - now(); // Don't bother with a very short suspense time.

          if (msUntilTimeout > 10) {
            var nextLanes = getNextLanes(root, NoLanes);

            if (nextLanes !== NoLanes) {
              // There's additional work on this root.
              break;
            }

            var suspendedLanes = root.suspendedLanes;

            if (!isSubsetOfLanes(suspendedLanes, lanes)) {
              // We should prefer to render the fallback of at the last
              // suspended level. Ping the last suspended level to try
              // rendering it again.
              // FIXME: What if the suspended lanes are Idle? Should not restart.
              var eventTime = requestEventTime();
              markRootPinged(root, suspendedLanes);
              break;
            } // The render is suspended, it hasn't timed out, and there's no
            // lower priority work to do. Instead of committing the fallback
            // immediately, wait for more data to arrive.


            root.timeoutHandle = scheduleTimeout(commitRoot.bind(null, root), msUntilTimeout);
            break;
          }
        } // The work expired. Commit immediately.


        commitRoot(root);
        break;
      }

    case RootSuspendedWithDelay:
      {
        markRootSuspended$1(root, lanes);

        if (includesOnlyTransitions(lanes)) {
          // This is a transition, so we should exit without committing a
          // placeholder and without scheduling a timeout. Delay indefinitely
          // until we receive more data.
          break;
        }

        if (!shouldForceFlushFallbacksInDEV()) {
          // This is not a transition, but we did trigger an avoided state.
          // Schedule a placeholder to display after a short delay, using the Just
          // Noticeable Difference.
          // TODO: Is the JND optimization worth the added complexity? If this is
          // the only reason we track the event time, then probably not.
          // Consider removing.
          var mostRecentEventTime = getMostRecentEventTime(root, lanes);
          var eventTimeMs = mostRecentEventTime;
          var timeElapsedMs = now() - eventTimeMs;

          var _msUntilTimeout = jnd(timeElapsedMs) - timeElapsedMs; // Don't bother with a very short suspense time.


          if (_msUntilTimeout > 10) {
            // Instead of committing the fallback immediately, wait for more data
            // to arrive.
            root.timeoutHandle = scheduleTimeout(commitRoot.bind(null, root), _msUntilTimeout);
            break;
          }
        } // Commit the placeholder.


        commitRoot(root);
        break;
      }

    case RootCompleted:
      {
        // The work completed. Ready to commit.
        commitRoot(root);
        break;
      }

    default:
      {
        {
          {
            throw Error( "Unknown root exit status." );
          }
        }
      }
  }
}

function markRootSuspended$1(root, suspendedLanes) {
  // When suspending, we should always exclude lanes that were pinged or (more
  // rarely, since we try to avoid it) updated during the render phase.
  // TODO: Lol maybe there's a better way to factor this besides this
  // obnoxiously named function :)
  suspendedLanes = removeLanes(suspendedLanes, workInProgressRootPingedLanes);
  suspendedLanes = removeLanes(suspendedLanes, workInProgressRootUpdatedLanes);
  markRootSuspended(root, suspendedLanes);
} // This is the entry point for synchronous tasks that don't go
// through Scheduler


function performSyncWorkOnRoot(root) {
  if (!((executionContext & (RenderContext | CommitContext)) === NoContext)) {
    {
      throw Error( "Should not already be working." );
    }
  }

  flushPassiveEffects();
  var lanes;
  var exitStatus;

  if (root === workInProgressRoot && includesSomeLane(root.expiredLanes, workInProgressRootRenderLanes)) {
    // There's a partial tree, and at least one of its lanes has expired. Finish
    // rendering it before rendering the rest of the expired work.
    lanes = workInProgressRootRenderLanes;
    exitStatus = renderRootSync(root, lanes);

    if (includesSomeLane(workInProgressRootIncludedLanes, workInProgressRootUpdatedLanes)) {
      // The render included lanes that were updated during the render phase.
      // For example, when unhiding a hidden tree, we include all the lanes
      // that were previously skipped when the tree was hidden. That set of
      // lanes is a superset of the lanes we started rendering with.
      //
      // Note that this only happens when part of the tree is rendered
      // concurrently. If the whole tree is rendered synchronously, then there
      // are no interleaved events.
      lanes = getNextLanes(root, lanes);
      exitStatus = renderRootSync(root, lanes);
    }
  } else {
    lanes = getNextLanes(root, NoLanes);
    exitStatus = renderRootSync(root, lanes);
  }

  if (root.tag !== LegacyRoot && exitStatus === RootErrored) {
    executionContext |= RetryAfterError; // If an error occurred during hydration,
    // discard server response and fall back to client side render.

    if (root.hydrate) {
      root.hydrate = false;
      clearContainer(root.containerInfo);
    } // If something threw an error, try rendering one more time. We'll render
    // synchronously to block concurrent data mutations, and we'll includes
    // all pending updates are included. If it still fails after the second
    // attempt, we'll give up and commit the resulting tree.


    lanes = getLanesToRetrySynchronouslyOnError(root);

    if (lanes !== NoLanes) {
      exitStatus = renderRootSync(root, lanes);
    }
  }

  if (exitStatus === RootFatalErrored) {
    var fatalError = workInProgressRootFatalError;
    prepareFreshStack(root, NoLanes);
    markRootSuspended$1(root, lanes);
    ensureRootIsScheduled(root, now());
    throw fatalError;
  } // We now have a consistent tree. Because this is a sync render, we
  // will commit it even if something suspended.


  var finishedWork = root.current.alternate;
  root.finishedWork = finishedWork;
  root.finishedLanes = lanes;
  commitRoot(root); // Before exiting, make sure there's a callback scheduled for the next
  // pending level.

  ensureRootIsScheduled(root, now());
  return null;
}
function flushDiscreteUpdates() {
  // TODO: Should be able to flush inside batchedUpdates, but not inside `act`.
  // However, `act` uses `batchedUpdates`, so there's no way to distinguish
  // those two cases. Need to fix this before exposing flushDiscreteUpdates
  // as a public API.
  if ((executionContext & (BatchedContext | RenderContext | CommitContext)) !== NoContext) {
    {
      if ((executionContext & RenderContext) !== NoContext) {
        error('unstable_flushDiscreteUpdates: Cannot flush updates when React is ' + 'already rendering.');
      }
    } // We're already rendering, so we can't synchronously flush pending work.
    // This is probably a nested event dispatch triggered by a lifecycle/effect,
    // like `el.focus()`. Exit.


    return;
  }

  flushPendingDiscreteUpdates(); // If the discrete updates scheduled passive effects, flush them now so that
  // they fire before the next serial event.

  flushPassiveEffects();
}

function flushPendingDiscreteUpdates() {
  if (rootsWithPendingDiscreteUpdates !== null) {
    // For each root with pending discrete updates, schedule a callback to
    // immediately flush them.
    var roots = rootsWithPendingDiscreteUpdates;
    rootsWithPendingDiscreteUpdates = null;
    roots.forEach(function (root) {
      markDiscreteUpdatesExpired(root);
      ensureRootIsScheduled(root, now());
    });
  } // Now flush the immediate queue.


  flushSyncCallbackQueue();
}

function batchedUpdates$1(fn, a) {
  var prevExecutionContext = executionContext;
  executionContext |= BatchedContext;

  try {
    return fn(a);
  } finally {
    executionContext = prevExecutionContext;

    if (executionContext === NoContext) {
      // Flush the immediate callbacks that were scheduled during this batch
      resetRenderTimer();
      flushSyncCallbackQueue();
    }
  }
}
function batchedEventUpdates$1(fn, a) {
  var prevExecutionContext = executionContext;
  executionContext |= EventContext;

  try {
    return fn(a);
  } finally {
    executionContext = prevExecutionContext;

    if (executionContext === NoContext) {
      // Flush the immediate callbacks that were scheduled during this batch
      resetRenderTimer();
      flushSyncCallbackQueue();
    }
  }
}
function discreteUpdates$1(fn, a, b, c, d) {
  var prevExecutionContext = executionContext;
  executionContext |= DiscreteEventContext;

  {
    try {
      return runWithPriority$1(UserBlockingPriority$2, fn.bind(null, a, b, c, d));
    } finally {
      executionContext = prevExecutionContext;

      if (executionContext === NoContext) {
        // Flush the immediate callbacks that were scheduled during this batch
        resetRenderTimer();
        flushSyncCallbackQueue();
      }
    }
  }
}
function unbatchedUpdates(fn, a) {
  var prevExecutionContext = executionContext;
  executionContext &= ~BatchedContext;
  executionContext |= LegacyUnbatchedContext;

  try {
    return fn(a);
  } finally {
    executionContext = prevExecutionContext;

    if (executionContext === NoContext) {
      // Flush the immediate callbacks that were scheduled during this batch
      resetRenderTimer();
      flushSyncCallbackQueue();
    }
  }
}
function flushSync(fn, a) {
  var prevExecutionContext = executionContext;

  if ((prevExecutionContext & (RenderContext | CommitContext)) !== NoContext) {
    {
      error('flushSync was called from inside a lifecycle method. React cannot ' + 'flush when React is already rendering. Consider moving this call to ' + 'a scheduler task or micro task.');
    }

    return fn(a);
  }

  executionContext |= BatchedContext;

  {
    try {
      if (fn) {
        return runWithPriority$1(ImmediatePriority$1, fn.bind(null, a));
      } else {
        return undefined;
      }
    } finally {
      executionContext = prevExecutionContext; // Flush the immediate callbacks that were scheduled during this batch.
      // Note that this will happen even if batchedUpdates is higher up
      // the stack.

      flushSyncCallbackQueue();
    }
  }
}
function pushRenderLanes(fiber, lanes) {
  push(subtreeRenderLanesCursor, subtreeRenderLanes, fiber);
  subtreeRenderLanes = mergeLanes(subtreeRenderLanes, lanes);
  workInProgressRootIncludedLanes = mergeLanes(workInProgressRootIncludedLanes, lanes);
}
function popRenderLanes(fiber) {
  subtreeRenderLanes = subtreeRenderLanesCursor.current;
  pop(subtreeRenderLanesCursor, fiber);
}

function prepareFreshStack(root, lanes) {
  root.finishedWork = null;
  root.finishedLanes = NoLanes;
  var timeoutHandle = root.timeoutHandle;

  if (timeoutHandle !== noTimeout) {
    // The root previous suspended and scheduled a timeout to commit a fallback
    // state. Now that we have additional work, cancel the timeout.
    root.timeoutHandle = noTimeout; // $FlowFixMe Complains noTimeout is not a TimeoutID, despite the check above

    cancelTimeout(timeoutHandle);
  }

  if (workInProgress !== null) {
    var interruptedWork = workInProgress.return;

    while (interruptedWork !== null) {
      unwindInterruptedWork(interruptedWork);
      interruptedWork = interruptedWork.return;
    }
  }

  workInProgressRoot = root;
  workInProgress = createWorkInProgress(root.current, null);
  workInProgressRootRenderLanes = subtreeRenderLanes = workInProgressRootIncludedLanes = lanes;
  workInProgressRootExitStatus = RootIncomplete;
  workInProgressRootFatalError = null;
  workInProgressRootSkippedLanes = NoLanes;
  workInProgressRootUpdatedLanes = NoLanes;
  workInProgressRootPingedLanes = NoLanes;

  {
    spawnedWorkDuringRender = null;
  }

  {
    ReactStrictModeWarnings.discardPendingWarnings();
  }
}

function handleError(root, thrownValue) {
  do {
    var erroredWork = workInProgress;

    try {
      // Reset module-level state that was set during the render phase.
      resetContextDependencies();
      resetHooksAfterThrow();
      resetCurrentFiber(); // TODO: I found and added this missing line while investigating a
      // separate issue. Write a regression test using string refs.

      ReactCurrentOwner$2.current = null;

      if (erroredWork === null || erroredWork.return === null) {
        // Expected to be working on a non-root fiber. This is a fatal error
        // because there's no ancestor that can handle it; the root is
        // supposed to capture all errors that weren't caught by an error
        // boundary.
        workInProgressRootExitStatus = RootFatalErrored;
        workInProgressRootFatalError = thrownValue; // Set `workInProgress` to null. This represents advancing to the next
        // sibling, or the parent if there are no siblings. But since the root
        // has no siblings nor a parent, we set it to null. Usually this is
        // handled by `completeUnitOfWork` or `unwindWork`, but since we're
        // intentionally not calling those, we need set it here.
        // TODO: Consider calling `unwindWork` to pop the contexts.

        workInProgress = null;
        return;
      }

      if (enableProfilerTimer && erroredWork.mode & ProfileMode) {
        // Record the time spent rendering before an error was thrown. This
        // avoids inaccurate Profiler durations in the case of a
        // suspended render.
        stopProfilerTimerIfRunningAndRecordDelta(erroredWork, true);
      }

      throwException(root, erroredWork.return, erroredWork, thrownValue, workInProgressRootRenderLanes);
      completeUnitOfWork(erroredWork);
    } catch (yetAnotherThrownValue) {
      // Something in the return path also threw.
      thrownValue = yetAnotherThrownValue;

      if (workInProgress === erroredWork && erroredWork !== null) {
        // If this boundary has already errored, then we had trouble processing
        // the error. Bubble it to the next boundary.
        erroredWork = erroredWork.return;
        workInProgress = erroredWork;
      } else {
        erroredWork = workInProgress;
      }

      continue;
    } // Return to the normal work loop.


    return;
  } while (true);
}

function pushDispatcher() {
  var prevDispatcher = ReactCurrentDispatcher$2.current;
  ReactCurrentDispatcher$2.current = ContextOnlyDispatcher;

  if (prevDispatcher === null) {
    // The React isomorphic package does not include a default dispatcher.
    // Instead the first renderer will lazily attach one, in order to give
    // nicer error messages.
    return ContextOnlyDispatcher;
  } else {
    return prevDispatcher;
  }
}

function popDispatcher(prevDispatcher) {
  ReactCurrentDispatcher$2.current = prevDispatcher;
}

function pushInteractions(root) {
  {
    var prevInteractions = tracing.__interactionsRef.current;
    tracing.__interactionsRef.current = root.memoizedInteractions;
    return prevInteractions;
  }
}

function popInteractions(prevInteractions) {
  {
    tracing.__interactionsRef.current = prevInteractions;
  }
}

function markCommitTimeOfFallback() {
  globalMostRecentFallbackTime = now();
}
function markSkippedUpdateLanes(lane) {
  workInProgressRootSkippedLanes = mergeLanes(lane, workInProgressRootSkippedLanes);
}
function renderDidSuspend() {
  if (workInProgressRootExitStatus === RootIncomplete) {
    workInProgressRootExitStatus = RootSuspended;
  }
}
function renderDidSuspendDelayIfPossible() {
  if (workInProgressRootExitStatus === RootIncomplete || workInProgressRootExitStatus === RootSuspended) {
    workInProgressRootExitStatus = RootSuspendedWithDelay;
  } // Check if there are updates that we skipped tree that might have unblocked
  // this render.


  if (workInProgressRoot !== null && (includesNonIdleWork(workInProgressRootSkippedLanes) || includesNonIdleWork(workInProgressRootUpdatedLanes))) {
    // Mark the current render as suspended so that we switch to working on
    // the updates that were skipped. Usually we only suspend at the end of
    // the render phase.
    // TODO: We should probably always mark the root as suspended immediately
    // (inside this function), since by suspending at the end of the render
    // phase introduces a potential mistake where we suspend lanes that were
    // pinged or updated while we were rendering.
    markRootSuspended$1(workInProgressRoot, workInProgressRootRenderLanes);
  }
}
function renderDidError() {
  if (workInProgressRootExitStatus !== RootCompleted) {
    workInProgressRootExitStatus = RootErrored;
  }
} // Called during render to determine if anything has suspended.
// Returns false if we're not sure.

function renderHasNotSuspendedYet() {
  // If something errored or completed, we can't really be sure,
  // so those are false.
  return workInProgressRootExitStatus === RootIncomplete;
}

function renderRootSync(root, lanes) {
  var prevExecutionContext = executionContext;
  executionContext |= RenderContext;
  var prevDispatcher = pushDispatcher(); // If the root or lanes have changed, throw out the existing stack
  // and prepare a fresh one. Otherwise we'll continue where we left off.

  if (workInProgressRoot !== root || workInProgressRootRenderLanes !== lanes) {
    prepareFreshStack(root, lanes);
    startWorkOnPendingInteractions(root, lanes);
  }

  var prevInteractions = pushInteractions(root);

  do {
    try {
      workLoopSync();
      break;
    } catch (thrownValue) {
      handleError(root, thrownValue);
    }
  } while (true);

  resetContextDependencies();

  {
    popInteractions(prevInteractions);
  }

  executionContext = prevExecutionContext;
  popDispatcher(prevDispatcher);

  if (workInProgress !== null) {
    // This is a sync render, so we should have finished the whole tree.
    {
      {
        throw Error( "Cannot commit an incomplete root. This error is likely caused by a bug in React. Please file an issue." );
      }
    }
  }


  workInProgressRoot = null;
  workInProgressRootRenderLanes = NoLanes;
  return workInProgressRootExitStatus;
} // The work loop is an extremely hot path. Tell Closure not to inline it.

/** @noinline */


function workLoopSync() {
  // Already timed out, so perform work without checking if we need to yield.
  while (workInProgress !== null) {
    performUnitOfWork(workInProgress);
  }
}

function renderRootConcurrent(root, lanes) {
  var prevExecutionContext = executionContext;
  executionContext |= RenderContext;
  var prevDispatcher = pushDispatcher(); // If the root or lanes have changed, throw out the existing stack
  // and prepare a fresh one. Otherwise we'll continue where we left off.

  if (workInProgressRoot !== root || workInProgressRootRenderLanes !== lanes) {
    resetRenderTimer();
    prepareFreshStack(root, lanes);
    startWorkOnPendingInteractions(root, lanes);
  }

  var prevInteractions = pushInteractions(root);

  do {
    try {
      workLoopConcurrent();
      break;
    } catch (thrownValue) {
      handleError(root, thrownValue);
    }
  } while (true);

  resetContextDependencies();

  {
    popInteractions(prevInteractions);
  }

  popDispatcher(prevDispatcher);
  executionContext = prevExecutionContext;


  if (workInProgress !== null) {

    return RootIncomplete;
  } else {


    workInProgressRoot = null;
    workInProgressRootRenderLanes = NoLanes; // Return the final exit status.

    return workInProgressRootExitStatus;
  }
}
/** @noinline */


function workLoopConcurrent() {
  // Perform work until Scheduler asks us to yield
  while (workInProgress !== null && !shouldYield()) {
    performUnitOfWork(workInProgress);
  }
}

function performUnitOfWork(unitOfWork) {
  // The current, flushed, state of this fiber is the alternate. Ideally
  // nothing should rely on this, but relying on it here means that we don't
  // need an additional field on the work in progress.
  var current = unitOfWork.alternate;
  setCurrentFiber(unitOfWork);
  var next;

  if ( (unitOfWork.mode & ProfileMode) !== NoMode) {
    startProfilerTimer(unitOfWork);
    next = beginWork$1(current, unitOfWork, subtreeRenderLanes);
    stopProfilerTimerIfRunningAndRecordDelta(unitOfWork, true);
  } else {
    next = beginWork$1(current, unitOfWork, subtreeRenderLanes);
  }

  resetCurrentFiber();
  unitOfWork.memoizedProps = unitOfWork.pendingProps;

  if (next === null) {
    // If this doesn't spawn new work, complete the current work.
    completeUnitOfWork(unitOfWork);
  } else {
    workInProgress = next;
  }

  ReactCurrentOwner$2.current = null;
}

function completeUnitOfWork(unitOfWork) {
  // Attempt to complete the current unit of work, then move to the next
  // sibling. If there are no more siblings, return to the parent fiber.
  var completedWork = unitOfWork;

  do {
    // The current, flushed, state of this fiber is the alternate. Ideally
    // nothing should rely on this, but relying on it here means that we don't
    // need an additional field on the work in progress.
    var current = completedWork.alternate;
    var returnFiber = completedWork.return; // Check if the work completed or if something threw.

    if ((completedWork.flags & Incomplete) === NoFlags) {
      setCurrentFiber(completedWork);
      var next = void 0;

      if ( (completedWork.mode & ProfileMode) === NoMode) {
        next = completeWork(current, completedWork, subtreeRenderLanes);
      } else {
        startProfilerTimer(completedWork);
        next = completeWork(current, completedWork, subtreeRenderLanes); // Update render duration assuming we didn't error.

        stopProfilerTimerIfRunningAndRecordDelta(completedWork, false);
      }

      resetCurrentFiber();

      if (next !== null) {
        // Completing this fiber spawned new work. Work on that next.
        workInProgress = next;
        return;
      }

      resetChildLanes(completedWork);

      if (returnFiber !== null && // Do not append effects to parents if a sibling failed to complete
      (returnFiber.flags & Incomplete) === NoFlags) {
        // Append all the effects of the subtree and this fiber onto the effect
        // list of the parent. The completion order of the children affects the
        // side-effect order.
        if (returnFiber.firstEffect === null) {
          returnFiber.firstEffect = completedWork.firstEffect;
        }

        if (completedWork.lastEffect !== null) {
          if (returnFiber.lastEffect !== null) {
            returnFiber.lastEffect.nextEffect = completedWork.firstEffect;
          }

          returnFiber.lastEffect = completedWork.lastEffect;
        } // If this fiber had side-effects, we append it AFTER the children's
        // side-effects. We can perform certain side-effects earlier if needed,
        // by doing multiple passes over the effect list. We don't want to
        // schedule our own side-effect on our own list because if end up
        // reusing children we'll schedule this effect onto itself since we're
        // at the end.


        var flags = completedWork.flags; // Skip both NoWork and PerformedWork tags when creating the effect
        // list. PerformedWork effect is read by React DevTools but shouldn't be
        // committed.

        if (flags > PerformedWork) {
          if (returnFiber.lastEffect !== null) {
            returnFiber.lastEffect.nextEffect = completedWork;
          } else {
            returnFiber.firstEffect = completedWork;
          }

          returnFiber.lastEffect = completedWork;
        }
      }
    } else {
      // This fiber did not complete because something threw. Pop values off
      // the stack without entering the complete phase. If this is a boundary,
      // capture values if possible.
      var _next = unwindWork(completedWork); // Because this fiber did not complete, don't reset its expiration time.


      if (_next !== null) {
        // If completing this work spawned new work, do that next. We'll come
        // back here again.
        // Since we're restarting, remove anything that is not a host effect
        // from the effect tag.
        _next.flags &= HostEffectMask;
        workInProgress = _next;
        return;
      }

      if ( (completedWork.mode & ProfileMode) !== NoMode) {
        // Record the render duration for the fiber that errored.
        stopProfilerTimerIfRunningAndRecordDelta(completedWork, false); // Include the time spent working on failed children before continuing.

        var actualDuration = completedWork.actualDuration;
        var child = completedWork.child;

        while (child !== null) {
          actualDuration += child.actualDuration;
          child = child.sibling;
        }

        completedWork.actualDuration = actualDuration;
      }

      if (returnFiber !== null) {
        // Mark the parent fiber as incomplete and clear its effect list.
        returnFiber.firstEffect = returnFiber.lastEffect = null;
        returnFiber.flags |= Incomplete;
      }
    }

    var siblingFiber = completedWork.sibling;

    if (siblingFiber !== null) {
      // If there is more work to do in this returnFiber, do that next.
      workInProgress = siblingFiber;
      return;
    } // Otherwise, return to the parent


    completedWork = returnFiber; // Update the next thing we're working on in case something throws.

    workInProgress = completedWork;
  } while (completedWork !== null); // We've reached the root.


  if (workInProgressRootExitStatus === RootIncomplete) {
    workInProgressRootExitStatus = RootCompleted;
  }
}

function resetChildLanes(completedWork) {
  if ( // TODO: Move this check out of the hot path by moving `resetChildLanes`
  // to switch statement in `completeWork`.
  (completedWork.tag === LegacyHiddenComponent || completedWork.tag === OffscreenComponent) && completedWork.memoizedState !== null && !includesSomeLane(subtreeRenderLanes, OffscreenLane) && (completedWork.mode & ConcurrentMode) !== NoLanes) {
    // The children of this component are hidden. Don't bubble their
    // expiration times.
    return;
  }

  var newChildLanes = NoLanes; // Bubble up the earliest expiration time.

  if ( (completedWork.mode & ProfileMode) !== NoMode) {
    // In profiling mode, resetChildExpirationTime is also used to reset
    // profiler durations.
    var actualDuration = completedWork.actualDuration;
    var treeBaseDuration = completedWork.selfBaseDuration; // When a fiber is cloned, its actualDuration is reset to 0. This value will
    // only be updated if work is done on the fiber (i.e. it doesn't bailout).
    // When work is done, it should bubble to the parent's actualDuration. If
    // the fiber has not been cloned though, (meaning no work was done), then
    // this value will reflect the amount of time spent working on a previous
    // render. In that case it should not bubble. We determine whether it was
    // cloned by comparing the child pointer.

    var shouldBubbleActualDurations = completedWork.alternate === null || completedWork.child !== completedWork.alternate.child;
    var child = completedWork.child;

    while (child !== null) {
      newChildLanes = mergeLanes(newChildLanes, mergeLanes(child.lanes, child.childLanes));

      if (shouldBubbleActualDurations) {
        actualDuration += child.actualDuration;
      }

      treeBaseDuration += child.treeBaseDuration;
      child = child.sibling;
    }

    var isTimedOutSuspense = completedWork.tag === SuspenseComponent && completedWork.memoizedState !== null;

    if (isTimedOutSuspense) {
      // Don't count time spent in a timed out Suspense subtree as part of the base duration.
      var primaryChildFragment = completedWork.child;

      if (primaryChildFragment !== null) {
        treeBaseDuration -= primaryChildFragment.treeBaseDuration;
      }
    }

    completedWork.actualDuration = actualDuration;
    completedWork.treeBaseDuration = treeBaseDuration;
  } else {
    var _child = completedWork.child;

    while (_child !== null) {
      newChildLanes = mergeLanes(newChildLanes, mergeLanes(_child.lanes, _child.childLanes));
      _child = _child.sibling;
    }
  }

  completedWork.childLanes = newChildLanes;
}

function commitRoot(root) {
  var renderPriorityLevel = getCurrentPriorityLevel();
  runWithPriority$1(ImmediatePriority$1, commitRootImpl.bind(null, root, renderPriorityLevel));
  return null;
}

function commitRootImpl(root, renderPriorityLevel) {
  do {
    // `flushPassiveEffects` will call `flushSyncUpdateQueue` at the end, which
    // means `flushPassiveEffects` will sometimes result in additional
    // passive effects. So we need to keep flushing in a loop until there are
    // no more pending effects.
    // TODO: Might be better if `flushPassiveEffects` did not automatically
    // flush synchronous work at the end, to avoid factoring hazards like this.
    flushPassiveEffects();
  } while (rootWithPendingPassiveEffects !== null);

  flushRenderPhaseStrictModeWarningsInDEV();

  if (!((executionContext & (RenderContext | CommitContext)) === NoContext)) {
    {
      throw Error( "Should not already be working." );
    }
  }

  var finishedWork = root.finishedWork;
  var lanes = root.finishedLanes;

  if (finishedWork === null) {

    return null;
  }

  root.finishedWork = null;
  root.finishedLanes = NoLanes;

  if (!(finishedWork !== root.current)) {
    {
      throw Error( "Cannot commit the same tree as before. This error is likely caused by a bug in React. Please file an issue." );
    }
  } // commitRoot never returns a continuation; it always finishes synchronously.
  // So we can clear these now to allow a new callback to be scheduled.


  root.callbackNode = null; // Update the first and last pending times on this root. The new first
  // pending time is whatever is left on the root fiber.

  var remainingLanes = mergeLanes(finishedWork.lanes, finishedWork.childLanes);
  markRootFinished(root, remainingLanes); // Clear already finished discrete updates in case that a later call of
  // `flushDiscreteUpdates` starts a useless render pass which may cancels
  // a scheduled timeout.

  if (rootsWithPendingDiscreteUpdates !== null) {
    if (!hasDiscreteLanes(remainingLanes) && rootsWithPendingDiscreteUpdates.has(root)) {
      rootsWithPendingDiscreteUpdates.delete(root);
    }
  }

  if (root === workInProgressRoot) {
    // We can reset these now that they are finished.
    workInProgressRoot = null;
    workInProgress = null;
    workInProgressRootRenderLanes = NoLanes;
  } // Get the list of effects.


  var firstEffect;

  if (finishedWork.flags > PerformedWork) {
    // A fiber's effect list consists only of its children, not itself. So if
    // the root has an effect, we need to add it to the end of the list. The
    // resulting list is the set that would belong to the root's parent, if it
    // had one; that is, all the effects in the tree including the root.
    if (finishedWork.lastEffect !== null) {
      finishedWork.lastEffect.nextEffect = finishedWork;
      firstEffect = finishedWork.firstEffect;
    } else {
      firstEffect = finishedWork;
    }
  } else {
    // There is no effect on the root.
    firstEffect = finishedWork.firstEffect;
  }

  if (firstEffect !== null) {

    var prevExecutionContext = executionContext;
    executionContext |= CommitContext;
    var prevInteractions = pushInteractions(root); // Reset this to null before calling lifecycles

    ReactCurrentOwner$2.current = null; // The commit phase is broken into several sub-phases. We do a separate pass
    // of the effect list for each phase: all mutation effects come before all
    // layout effects, and so on.
    // The first phase a "before mutation" phase. We use this phase to read the
    // state of the host tree right before we mutate it. This is where
    // getSnapshotBeforeUpdate is called.

    focusedInstanceHandle = prepareForCommit(root.containerInfo);
    shouldFireAfterActiveInstanceBlur = false;
    nextEffect = firstEffect;

    do {
      {
        invokeGuardedCallback(null, commitBeforeMutationEffects, null);

        if (hasCaughtError()) {
          if (!(nextEffect !== null)) {
            {
              throw Error( "Should be working on an effect." );
            }
          }

          var error = clearCaughtError();
          captureCommitPhaseError(nextEffect, error);
          nextEffect = nextEffect.nextEffect;
        }
      }
    } while (nextEffect !== null); // We no longer need to track the active instance fiber


    focusedInstanceHandle = null;

    {
      // Mark the current commit time to be shared by all Profilers in this
      // batch. This enables them to be grouped later.
      recordCommitTime();
    } // The next phase is the mutation phase, where we mutate the host tree.


    nextEffect = firstEffect;

    do {
      {
        invokeGuardedCallback(null, commitMutationEffects, null, root, renderPriorityLevel);

        if (hasCaughtError()) {
          if (!(nextEffect !== null)) {
            {
              throw Error( "Should be working on an effect." );
            }
          }

          var _error = clearCaughtError();

          captureCommitPhaseError(nextEffect, _error);
          nextEffect = nextEffect.nextEffect;
        }
      }
    } while (nextEffect !== null);

    resetAfterCommit(root.containerInfo); // The work-in-progress tree is now the current tree. This must come after
    // the mutation phase, so that the previous tree is still current during
    // componentWillUnmount, but before the layout phase, so that the finished
    // work is current during componentDidMount/Update.

    root.current = finishedWork; // The next phase is the layout phase, where we call effects that read
    // the host tree after it's been mutated. The idiomatic use case for this is
    // layout, but class component lifecycles also fire here for legacy reasons.

    nextEffect = firstEffect;

    do {
      {
        invokeGuardedCallback(null, commitLayoutEffects, null, root, lanes);

        if (hasCaughtError()) {
          if (!(nextEffect !== null)) {
            {
              throw Error( "Should be working on an effect." );
            }
          }

          var _error2 = clearCaughtError();

          captureCommitPhaseError(nextEffect, _error2);
          nextEffect = nextEffect.nextEffect;
        }
      }
    } while (nextEffect !== null);

    nextEffect = null; // Tell Scheduler to yield at the end of the frame, so the browser has an
    // opportunity to paint.

    requestPaint();

    {
      popInteractions(prevInteractions);
    }

    executionContext = prevExecutionContext;
  } else {
    // No effects.
    root.current = finishedWork; // Measure these anyway so the flamegraph explicitly shows that there were
    // no effects.
    // TODO: Maybe there's a better way to report this.

    {
      recordCommitTime();
    }
  }

  var rootDidHavePassiveEffects = rootDoesHavePassiveEffects;

  if (rootDoesHavePassiveEffects) {
    // This commit has passive effects. Stash a reference to them. But don't
    // schedule a callback until after flushing layout work.
    rootDoesHavePassiveEffects = false;
    rootWithPendingPassiveEffects = root;
    pendingPassiveEffectsLanes = lanes;
    pendingPassiveEffectsRenderPriority = renderPriorityLevel;
  } else {
    // We are done with the effect chain at this point so let's clear the
    // nextEffect pointers to assist with GC. If we have passive effects, we'll
    // clear this in flushPassiveEffects.
    nextEffect = firstEffect;

    while (nextEffect !== null) {
      var nextNextEffect = nextEffect.nextEffect;
      nextEffect.nextEffect = null;

      if (nextEffect.flags & Deletion) {
        detachFiberAfterEffects(nextEffect);
      }

      nextEffect = nextNextEffect;
    }
  } // Read this again, since an effect might have updated it


  remainingLanes = root.pendingLanes; // Check if there's remaining work on this root

  if (remainingLanes !== NoLanes) {
    {
      if (spawnedWorkDuringRender !== null) {
        var expirationTimes = spawnedWorkDuringRender;
        spawnedWorkDuringRender = null;

        for (var i = 0; i < expirationTimes.length; i++) {
          scheduleInteractions(root, expirationTimes[i], root.memoizedInteractions);
        }
      }

      schedulePendingInteractions(root, remainingLanes);
    }
  } else {
    // If there's no remaining work, we can clear the set of already failed
    // error boundaries.
    legacyErrorBoundariesThatAlreadyFailed = null;
  }

  {
    if (!rootDidHavePassiveEffects) {
      // If there are no passive effects, then we can complete the pending interactions.
      // Otherwise, we'll wait until after the passive effects are flushed.
      // Wait to do this until after remaining work has been scheduled,
      // so that we don't prematurely signal complete for interactions when there's e.g. hidden work.
      finishPendingInteractions(root, lanes);
    }
  }

  if (remainingLanes === SyncLane) {
    // Count the number of times the root synchronously re-renders without
    // finishing. If there are too many, it indicates an infinite update loop.
    if (root === rootWithNestedUpdates) {
      nestedUpdateCount++;
    } else {
      nestedUpdateCount = 0;
      rootWithNestedUpdates = root;
    }
  } else {
    nestedUpdateCount = 0;
  }

  onCommitRoot(finishedWork.stateNode, renderPriorityLevel);

  {
    onCommitRoot$1();
  } // Always call this before exiting `commitRoot`, to ensure that any
  // additional work on this root is scheduled.


  ensureRootIsScheduled(root, now());

  if (hasUncaughtError) {
    hasUncaughtError = false;
    var _error3 = firstUncaughtError;
    firstUncaughtError = null;
    throw _error3;
  }

  if ((executionContext & LegacyUnbatchedContext) !== NoContext) {
    // a ReactDOM.render-ed root inside of batchedUpdates. The commit fired
    // synchronously, but layout updates should be deferred until the end
    // of the batch.


    return null;
  } // If layout work was scheduled, flush it now.


  flushSyncCallbackQueue();

  return null;
}

function commitBeforeMutationEffects() {
  while (nextEffect !== null) {
    var current = nextEffect.alternate;

    if (!shouldFireAfterActiveInstanceBlur && focusedInstanceHandle !== null) {
      if ((nextEffect.flags & Deletion) !== NoFlags) {
        if (doesFiberContain(nextEffect, focusedInstanceHandle)) {
          shouldFireAfterActiveInstanceBlur = true;
        }
      } else {
        // TODO: Move this out of the hot path using a dedicated effect tag.
        if (nextEffect.tag === SuspenseComponent && isSuspenseBoundaryBeingHidden(current, nextEffect) && doesFiberContain(nextEffect, focusedInstanceHandle)) {
          shouldFireAfterActiveInstanceBlur = true;
        }
      }
    }

    var flags = nextEffect.flags;

    if ((flags & Snapshot) !== NoFlags) {
      setCurrentFiber(nextEffect);
      commitBeforeMutationLifeCycles(current, nextEffect);
      resetCurrentFiber();
    }

    if ((flags & Passive) !== NoFlags) {
      // If there are passive effects, schedule a callback to flush at
      // the earliest opportunity.
      if (!rootDoesHavePassiveEffects) {
        rootDoesHavePassiveEffects = true;
        scheduleCallback(NormalPriority$1, function () {
          flushPassiveEffects();
          return null;
        });
      }
    }

    nextEffect = nextEffect.nextEffect;
  }
}

function commitMutationEffects(root, renderPriorityLevel) {
  // TODO: Should probably move the bulk of this function to commitWork.
  while (nextEffect !== null) {
    setCurrentFiber(nextEffect);
    var flags = nextEffect.flags;

    if (flags & ContentReset) {
      commitResetTextContent(nextEffect);
    }

    if (flags & Ref) {
      var current = nextEffect.alternate;

      if (current !== null) {
        commitDetachRef(current);
      }
    } // The following switch statement is only concerned about placement,
    // updates, and deletions. To avoid needing to add a case for every possible
    // bitmap value, we remove the secondary effects from the effect tag and
    // switch on that value.


    var primaryFlags = flags & (Placement | Update | Deletion | Hydrating);

    switch (primaryFlags) {
      case Placement:
        {
          commitPlacement(nextEffect); // Clear the "placement" from effect tag so that we know that this is
          // inserted, before any life-cycles like componentDidMount gets called.
          // TODO: findDOMNode doesn't rely on this any more but isMounted does
          // and isMounted is deprecated anyway so we should be able to kill this.

          nextEffect.flags &= ~Placement;
          break;
        }

      case PlacementAndUpdate:
        {
          // Placement
          commitPlacement(nextEffect); // Clear the "placement" from effect tag so that we know that this is
          // inserted, before any life-cycles like componentDidMount gets called.

          nextEffect.flags &= ~Placement; // Update

          var _current = nextEffect.alternate;
          commitWork(_current, nextEffect);
          break;
        }

      case Hydrating:
        {
          nextEffect.flags &= ~Hydrating;
          break;
        }

      case HydratingAndUpdate:
        {
          nextEffect.flags &= ~Hydrating; // Update

          var _current2 = nextEffect.alternate;
          commitWork(_current2, nextEffect);
          break;
        }

      case Update:
        {
          var _current3 = nextEffect.alternate;
          commitWork(_current3, nextEffect);
          break;
        }

      case Deletion:
        {
          commitDeletion(root, nextEffect);
          break;
        }
    }

    resetCurrentFiber();
    nextEffect = nextEffect.nextEffect;
  }
}

function commitLayoutEffects(root, committedLanes) {


  while (nextEffect !== null) {
    setCurrentFiber(nextEffect);
    var flags = nextEffect.flags;

    if (flags & (Update | Callback)) {
      var current = nextEffect.alternate;
      commitLifeCycles(root, current, nextEffect);
    }

    {
      if (flags & Ref) {
        commitAttachRef(nextEffect);
      }
    }

    resetCurrentFiber();
    nextEffect = nextEffect.nextEffect;
  }
}

function flushPassiveEffects() {
  // Returns whether passive effects were flushed.
  if (pendingPassiveEffectsRenderPriority !== NoPriority$1) {
    var priorityLevel = pendingPassiveEffectsRenderPriority > NormalPriority$1 ? NormalPriority$1 : pendingPassiveEffectsRenderPriority;
    pendingPassiveEffectsRenderPriority = NoPriority$1;

    {
      return runWithPriority$1(priorityLevel, flushPassiveEffectsImpl);
    }
  }

  return false;
}
function enqueuePendingPassiveHookEffectMount(fiber, effect) {
  pendingPassiveHookEffectsMount.push(effect, fiber);

  if (!rootDoesHavePassiveEffects) {
    rootDoesHavePassiveEffects = true;
    scheduleCallback(NormalPriority$1, function () {
      flushPassiveEffects();
      return null;
    });
  }
}
function enqueuePendingPassiveHookEffectUnmount(fiber, effect) {
  pendingPassiveHookEffectsUnmount.push(effect, fiber);

  {
    fiber.flags |= PassiveUnmountPendingDev;
    var alternate = fiber.alternate;

    if (alternate !== null) {
      alternate.flags |= PassiveUnmountPendingDev;
    }
  }

  if (!rootDoesHavePassiveEffects) {
    rootDoesHavePassiveEffects = true;
    scheduleCallback(NormalPriority$1, function () {
      flushPassiveEffects();
      return null;
    });
  }
}

function invokePassiveEffectCreate(effect) {
  var create = effect.create;
  effect.destroy = create();
}

function flushPassiveEffectsImpl() {
  if (rootWithPendingPassiveEffects === null) {
    return false;
  }

  var root = rootWithPendingPassiveEffects;
  var lanes = pendingPassiveEffectsLanes;
  rootWithPendingPassiveEffects = null;
  pendingPassiveEffectsLanes = NoLanes;

  if (!((executionContext & (RenderContext | CommitContext)) === NoContext)) {
    {
      throw Error( "Cannot flush passive effects while already rendering." );
    }
  }

  {
    isFlushingPassiveEffects = true;
  }

  var prevExecutionContext = executionContext;
  executionContext |= CommitContext;
  var prevInteractions = pushInteractions(root); // It's important that ALL pending passive effect destroy functions are called
  // before ANY passive effect create functions are called.
  // Otherwise effects in sibling components might interfere with each other.
  // e.g. a destroy function in one component may unintentionally override a ref
  // value set by a create function in another component.
  // Layout effects have the same constraint.
  // First pass: Destroy stale passive effects.

  var unmountEffects = pendingPassiveHookEffectsUnmount;
  pendingPassiveHookEffectsUnmount = [];

  for (var i = 0; i < unmountEffects.length; i += 2) {
    var _effect = unmountEffects[i];
    var fiber = unmountEffects[i + 1];
    var destroy = _effect.destroy;
    _effect.destroy = undefined;

    {
      fiber.flags &= ~PassiveUnmountPendingDev;
      var alternate = fiber.alternate;

      if (alternate !== null) {
        alternate.flags &= ~PassiveUnmountPendingDev;
      }
    }

    if (typeof destroy === 'function') {
      {
        setCurrentFiber(fiber);

        {
          invokeGuardedCallback(null, destroy, null);
        }

        if (hasCaughtError()) {
          if (!(fiber !== null)) {
            {
              throw Error( "Should be working on an effect." );
            }
          }

          var error = clearCaughtError();
          captureCommitPhaseError(fiber, error);
        }

        resetCurrentFiber();
      }
    }
  } // Second pass: Create new passive effects.


  var mountEffects = pendingPassiveHookEffectsMount;
  pendingPassiveHookEffectsMount = [];

  for (var _i = 0; _i < mountEffects.length; _i += 2) {
    var _effect2 = mountEffects[_i];
    var _fiber = mountEffects[_i + 1];

    {
      setCurrentFiber(_fiber);

      {
        invokeGuardedCallback(null, invokePassiveEffectCreate, null, _effect2);
      }

      if (hasCaughtError()) {
        if (!(_fiber !== null)) {
          {
            throw Error( "Should be working on an effect." );
          }
        }

        var _error4 = clearCaughtError();

        captureCommitPhaseError(_fiber, _error4);
      }

      resetCurrentFiber();
    }
  } // Note: This currently assumes there are no passive effects on the root fiber
  // because the root is not part of its own effect list.
  // This could change in the future.


  var effect = root.current.firstEffect;

  while (effect !== null) {
    var nextNextEffect = effect.nextEffect; // Remove nextEffect pointer to assist GC

    effect.nextEffect = null;

    if (effect.flags & Deletion) {
      detachFiberAfterEffects(effect);
    }

    effect = nextNextEffect;
  }

  {
    popInteractions(prevInteractions);
    finishPendingInteractions(root, lanes);
  }

  {
    isFlushingPassiveEffects = false;
  }

  executionContext = prevExecutionContext;
  flushSyncCallbackQueue(); // If additional passive effects were scheduled, increment a counter. If this
  // exceeds the limit, we'll fire a warning.

  nestedPassiveUpdateCount = rootWithPendingPassiveEffects === null ? 0 : nestedPassiveUpdateCount + 1;
  return true;
}

function isAlreadyFailedLegacyErrorBoundary(instance) {
  return legacyErrorBoundariesThatAlreadyFailed !== null && legacyErrorBoundariesThatAlreadyFailed.has(instance);
}
function markLegacyErrorBoundaryAsFailed(instance) {
  if (legacyErrorBoundariesThatAlreadyFailed === null) {
    legacyErrorBoundariesThatAlreadyFailed = new Set([instance]);
  } else {
    legacyErrorBoundariesThatAlreadyFailed.add(instance);
  }
}

function prepareToThrowUncaughtError(error) {
  if (!hasUncaughtError) {
    hasUncaughtError = true;
    firstUncaughtError = error;
  }
}

var onUncaughtError = prepareToThrowUncaughtError;

function captureCommitPhaseErrorOnRoot(rootFiber, sourceFiber, error) {
  var errorInfo = createCapturedValue(error, sourceFiber);
  var update = createRootErrorUpdate(rootFiber, errorInfo, SyncLane);
  enqueueUpdate(rootFiber, update);
  var eventTime = requestEventTime();
  var root = markUpdateLaneFromFiberToRoot(rootFiber, SyncLane);

  if (root !== null) {
    markRootUpdated(root, SyncLane, eventTime);
    ensureRootIsScheduled(root, eventTime);
    schedulePendingInteractions(root, SyncLane);
  }
}

function captureCommitPhaseError(sourceFiber, error) {
  if (sourceFiber.tag === HostRoot) {
    // Error was thrown at the root. There is no parent, so the root
    // itself should capture it.
    captureCommitPhaseErrorOnRoot(sourceFiber, sourceFiber, error);
    return;
  }

  var fiber = sourceFiber.return;

  while (fiber !== null) {
    if (fiber.tag === HostRoot) {
      captureCommitPhaseErrorOnRoot(fiber, sourceFiber, error);
      return;
    } else if (fiber.tag === ClassComponent) {
      var ctor = fiber.type;
      var instance = fiber.stateNode;

      if (typeof ctor.getDerivedStateFromError === 'function' || typeof instance.componentDidCatch === 'function' && !isAlreadyFailedLegacyErrorBoundary(instance)) {
        var errorInfo = createCapturedValue(error, sourceFiber);
        var update = createClassErrorUpdate(fiber, errorInfo, SyncLane);
        enqueueUpdate(fiber, update);
        var eventTime = requestEventTime();
        var root = markUpdateLaneFromFiberToRoot(fiber, SyncLane);

        if (root !== null) {
          markRootUpdated(root, SyncLane, eventTime);
          ensureRootIsScheduled(root, eventTime);
          schedulePendingInteractions(root, SyncLane);
        } else {
          // This component has already been unmounted.
          // We can't schedule any follow up work for the root because the fiber is already unmounted,
          // but we can still call the log-only boundary so the error isn't swallowed.
          //
          // TODO This is only a temporary bandaid for the old reconciler fork.
          // We can delete this special case once the new fork is merged.
          if (typeof instance.componentDidCatch === 'function' && !isAlreadyFailedLegacyErrorBoundary(instance)) {
            try {
              instance.componentDidCatch(error, errorInfo);
            } catch (errorToIgnore) {// TODO Ignore this error? Rethrow it?
              // This is kind of an edge case.
            }
          }
        }

        return;
      }
    }

    fiber = fiber.return;
  }
}
function pingSuspendedRoot(root, wakeable, pingedLanes) {
  var pingCache = root.pingCache;

  if (pingCache !== null) {
    // The wakeable resolved, so we no longer need to memoize, because it will
    // never be thrown again.
    pingCache.delete(wakeable);
  }

  var eventTime = requestEventTime();
  markRootPinged(root, pingedLanes);

  if (workInProgressRoot === root && isSubsetOfLanes(workInProgressRootRenderLanes, pingedLanes)) {
    // Received a ping at the same priority level at which we're currently
    // rendering. We might want to restart this render. This should mirror
    // the logic of whether or not a root suspends once it completes.
    // TODO: If we're rendering sync either due to Sync, Batched or expired,
    // we should probably never restart.
    // If we're suspended with delay, or if it's a retry, we'll always suspend
    // so we can always restart.
    if (workInProgressRootExitStatus === RootSuspendedWithDelay || workInProgressRootExitStatus === RootSuspended && includesOnlyRetries(workInProgressRootRenderLanes) && now() - globalMostRecentFallbackTime < FALLBACK_THROTTLE_MS) {
      // Restart from the root.
      prepareFreshStack(root, NoLanes);
    } else {
      // Even though we can't restart right now, we might get an
      // opportunity later. So we mark this render as having a ping.
      workInProgressRootPingedLanes = mergeLanes(workInProgressRootPingedLanes, pingedLanes);
    }
  }

  ensureRootIsScheduled(root, eventTime);
  schedulePendingInteractions(root, pingedLanes);
}

function retryTimedOutBoundary(boundaryFiber, retryLane) {
  // The boundary fiber (a Suspense component or SuspenseList component)
  // previously was rendered in its fallback state. One of the promises that
  // suspended it has resolved, which means at least part of the tree was
  // likely unblocked. Try rendering again, at a new expiration time.
  if (retryLane === NoLane) {
    retryLane = requestRetryLane(boundaryFiber);
  } // TODO: Special case idle priority?


  var eventTime = requestEventTime();
  var root = markUpdateLaneFromFiberToRoot(boundaryFiber, retryLane);

  if (root !== null) {
    markRootUpdated(root, retryLane, eventTime);
    ensureRootIsScheduled(root, eventTime);
    schedulePendingInteractions(root, retryLane);
  }
}
function resolveRetryWakeable(boundaryFiber, wakeable) {
  var retryLane = NoLane; // Default

  var retryCache;

  {
    retryCache = boundaryFiber.stateNode;
  }

  if (retryCache !== null) {
    // The wakeable resolved, so we no longer need to memoize, because it will
    // never be thrown again.
    retryCache.delete(wakeable);
  }

  retryTimedOutBoundary(boundaryFiber, retryLane);
} // Computes the next Just Noticeable Difference (JND) boundary.
// The theory is that a person can't tell the difference between small differences in time.
// Therefore, if we wait a bit longer than necessary that won't translate to a noticeable
// difference in the experience. However, waiting for longer might mean that we can avoid
// showing an intermediate loading state. The longer we have already waited, the harder it
// is to tell small differences in time. Therefore, the longer we've already waited,
// the longer we can wait additionally. At some point we have to give up though.
// We pick a train model where the next boundary commits at a consistent schedule.
// These particular numbers are vague estimates. We expect to adjust them based on research.

function jnd(timeElapsed) {
  return timeElapsed < 120 ? 120 : timeElapsed < 480 ? 480 : timeElapsed < 1080 ? 1080 : timeElapsed < 1920 ? 1920 : timeElapsed < 3000 ? 3000 : timeElapsed < 4320 ? 4320 : ceil(timeElapsed / 1960) * 1960;
}

function checkForNestedUpdates() {
  if (nestedUpdateCount > NESTED_UPDATE_LIMIT) {
    nestedUpdateCount = 0;
    rootWithNestedUpdates = null;

    {
      {
        throw Error( "Maximum update depth exceeded. This can happen when a component repeatedly calls setState inside componentWillUpdate or componentDidUpdate. React limits the number of nested updates to prevent infinite loops." );
      }
    }
  }

  {
    if (nestedPassiveUpdateCount > NESTED_PASSIVE_UPDATE_LIMIT) {
      nestedPassiveUpdateCount = 0;

      error('Maximum update depth exceeded. This can happen when a component ' + "calls setState inside useEffect, but useEffect either doesn't " + 'have a dependency array, or one of the dependencies changes on ' + 'every render.');
    }
  }
}

function flushRenderPhaseStrictModeWarningsInDEV() {
  {
    ReactStrictModeWarnings.flushLegacyContextWarning();

    {
      ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings();
    }
  }
}

var didWarnStateUpdateForNotYetMountedComponent = null;

function warnAboutUpdateOnNotYetMountedFiberInDEV(fiber) {
  {
    if ((executionContext & RenderContext) !== NoContext) {
      // We let the other warning about render phase updates deal with this one.
      return;
    }

    if (!(fiber.mode & (BlockingMode | ConcurrentMode))) {
      return;
    }

    var tag = fiber.tag;

    if (tag !== IndeterminateComponent && tag !== HostRoot && tag !== ClassComponent && tag !== FunctionComponent && tag !== ForwardRef && tag !== MemoComponent && tag !== SimpleMemoComponent && tag !== Block) {
      // Only warn for user-defined components, not internal ones like Suspense.
      return;
    } // We show the whole stack but dedupe on the top component's name because
    // the problematic code almost always lies inside that component.


    var componentName = getComponentName(fiber.type) || 'ReactComponent';

    if (didWarnStateUpdateForNotYetMountedComponent !== null) {
      if (didWarnStateUpdateForNotYetMountedComponent.has(componentName)) {
        return;
      }

      didWarnStateUpdateForNotYetMountedComponent.add(componentName);
    } else {
      didWarnStateUpdateForNotYetMountedComponent = new Set([componentName]);
    }

    var previousFiber = current;

    try {
      setCurrentFiber(fiber);

      error("Can't perform a React state update on a component that hasn't mounted yet. " + 'This indicates that you have a side-effect in your render function that ' + 'asynchronously later calls tries to update the component. Move this work to ' + 'useEffect instead.');
    } finally {
      if (previousFiber) {
        setCurrentFiber(fiber);
      } else {
        resetCurrentFiber();
      }
    }
  }
}

var didWarnStateUpdateForUnmountedComponent = null;

function warnAboutUpdateOnUnmountedFiberInDEV(fiber) {
  {
    var tag = fiber.tag;

    if (tag !== HostRoot && tag !== ClassComponent && tag !== FunctionComponent && tag !== ForwardRef && tag !== MemoComponent && tag !== SimpleMemoComponent && tag !== Block) {
      // Only warn for user-defined components, not internal ones like Suspense.
      return;
    } // If there are pending passive effects unmounts for this Fiber,
    // we can assume that they would have prevented this update.


    if ((fiber.flags & PassiveUnmountPendingDev) !== NoFlags) {
      return;
    } // We show the whole stack but dedupe on the top component's name because
    // the problematic code almost always lies inside that component.


    var componentName = getComponentName(fiber.type) || 'ReactComponent';

    if (didWarnStateUpdateForUnmountedComponent !== null) {
      if (didWarnStateUpdateForUnmountedComponent.has(componentName)) {
        return;
      }

      didWarnStateUpdateForUnmountedComponent.add(componentName);
    } else {
      didWarnStateUpdateForUnmountedComponent = new Set([componentName]);
    }

    if (isFlushingPassiveEffects) ; else {
      var previousFiber = current;

      try {
        setCurrentFiber(fiber);

        error("Can't perform a React state update on an unmounted component. This " + 'is a no-op, but it indicates a memory leak in your application. To ' + 'fix, cancel all subscriptions and asynchronous tasks in %s.', tag === ClassComponent ? 'the componentWillUnmount method' : 'a useEffect cleanup function');
      } finally {
        if (previousFiber) {
          setCurrentFiber(fiber);
        } else {
          resetCurrentFiber();
        }
      }
    }
  }
}

var beginWork$1;

{
  var dummyFiber = null;

  beginWork$1 = function (current, unitOfWork, lanes) {
    // If a component throws an error, we replay it again in a synchronously
    // dispatched event, so that the debugger will treat it as an uncaught
    // error See ReactErrorUtils for more information.
    // Before entering the begin phase, copy the work-in-progress onto a dummy
    // fiber. If beginWork throws, we'll use this to reset the state.
    var originalWorkInProgressCopy = assignFiberPropertiesInDEV(dummyFiber, unitOfWork);

    try {
      return beginWork(current, unitOfWork, lanes);
    } catch (originalError) {
      if (originalError !== null && typeof originalError === 'object' && typeof originalError.then === 'function') {
        // Don't replay promises. Treat everything else like an error.
        throw originalError;
      } // Keep this code in sync with handleError; any changes here must have
      // corresponding changes there.


      resetContextDependencies();
      resetHooksAfterThrow(); // Don't reset current debug fiber, since we're about to work on the
      // same fiber again.
      // Unwind the failed stack frame

      unwindInterruptedWork(unitOfWork); // Restore the original properties of the fiber.

      assignFiberPropertiesInDEV(unitOfWork, originalWorkInProgressCopy);

      if ( unitOfWork.mode & ProfileMode) {
        // Reset the profiler timer.
        startProfilerTimer(unitOfWork);
      } // Run beginWork again.


      invokeGuardedCallback(null, beginWork, null, current, unitOfWork, lanes);

      if (hasCaughtError()) {
        var replayError = clearCaughtError(); // `invokeGuardedCallback` sometimes sets an expando `_suppressLogging`.
        // Rethrow this error instead of the original one.

        throw replayError;
      } else {
        // This branch is reachable if the render phase is impure.
        throw originalError;
      }
    }
  };
}

var didWarnAboutUpdateInRender = false;
var didWarnAboutUpdateInRenderForAnotherComponent;

{
  didWarnAboutUpdateInRenderForAnotherComponent = new Set();
}

function warnAboutRenderPhaseUpdatesInDEV(fiber) {
  {
    if (isRendering && (executionContext & RenderContext) !== NoContext && !getIsUpdatingOpaqueValueInRenderPhaseInDEV()) {
      switch (fiber.tag) {
        case FunctionComponent:
        case ForwardRef:
        case SimpleMemoComponent:
          {
            var renderingComponentName = workInProgress && getComponentName(workInProgress.type) || 'Unknown'; // Dedupe by the rendering component because it's the one that needs to be fixed.

            var dedupeKey = renderingComponentName;

            if (!didWarnAboutUpdateInRenderForAnotherComponent.has(dedupeKey)) {
              didWarnAboutUpdateInRenderForAnotherComponent.add(dedupeKey);
              var setStateComponentName = getComponentName(fiber.type) || 'Unknown';

              error('Cannot update a component (`%s`) while rendering a ' + 'different component (`%s`). To locate the bad setState() call inside `%s`, ' + 'follow the stack trace as described in https://reactjs.org/link/setstate-in-render', setStateComponentName, renderingComponentName, renderingComponentName);
            }

            break;
          }

        case ClassComponent:
          {
            if (!didWarnAboutUpdateInRender) {
              error('Cannot update during an existing state transition (such as ' + 'within `render`). Render methods should be a pure ' + 'function of props and state.');

              didWarnAboutUpdateInRender = true;
            }

            break;
          }
      }
    }
  }
} // a 'shared' variable that changes when act() opens/closes in tests.


var IsThisRendererActing = {
  current: false
};
function warnIfNotScopedWithMatchingAct(fiber) {
  {
    if ( IsSomeRendererActing.current === true && IsThisRendererActing.current !== true) {
      var previousFiber = current;

      try {
        setCurrentFiber(fiber);

        error("It looks like you're using the wrong act() around your test interactions.\n" + 'Be sure to use the matching version of act() corresponding to your renderer:\n\n' + '// for react-dom:\n' + // Break up imports to avoid accidentally parsing them as dependencies.
        'import {act} fr' + "om 'react-dom/test-utils';\n" + '// ...\n' + 'act(() => ...);\n\n' + '// for react-test-renderer:\n' + // Break up imports to avoid accidentally parsing them as dependencies.
        'import TestRenderer fr' + "om react-test-renderer';\n" + 'const {act} = TestRenderer;\n' + '// ...\n' + 'act(() => ...);');
      } finally {
        if (previousFiber) {
          setCurrentFiber(fiber);
        } else {
          resetCurrentFiber();
        }
      }
    }
  }
}
function warnIfNotCurrentlyActingEffectsInDEV(fiber) {
  {
    if ( (fiber.mode & StrictMode) !== NoMode && IsSomeRendererActing.current === false && IsThisRendererActing.current === false) {
      error('An update to %s ran an effect, but was not wrapped in act(...).\n\n' + 'When testing, code that causes React state updates should be ' + 'wrapped into act(...):\n\n' + 'act(() => {\n' + '  /* fire events that update state */\n' + '});\n' + '/* assert on the output */\n\n' + "This ensures that you're testing the behavior the user would see " + 'in the browser.' + ' Learn more at https://reactjs.org/link/wrap-tests-with-act', getComponentName(fiber.type));
    }
  }
}

function warnIfNotCurrentlyActingUpdatesInDEV(fiber) {
  {
    if ( executionContext === NoContext && IsSomeRendererActing.current === false && IsThisRendererActing.current === false) {
      var previousFiber = current;

      try {
        setCurrentFiber(fiber);

        error('An update to %s inside a test was not wrapped in act(...).\n\n' + 'When testing, code that causes React state updates should be ' + 'wrapped into act(...):\n\n' + 'act(() => {\n' + '  /* fire events that update state */\n' + '});\n' + '/* assert on the output */\n\n' + "This ensures that you're testing the behavior the user would see " + 'in the browser.' + ' Learn more at https://reactjs.org/link/wrap-tests-with-act', getComponentName(fiber.type));
      } finally {
        if (previousFiber) {
          setCurrentFiber(fiber);
        } else {
          resetCurrentFiber();
        }
      }
    }
  }
}

var warnIfNotCurrentlyActingUpdatesInDev = warnIfNotCurrentlyActingUpdatesInDEV; // In tests, we want to enforce a mocked scheduler.

var didWarnAboutUnmockedScheduler = false; // TODO Before we release concurrent mode, revisit this and decide whether a mocked
// scheduler is the actual recommendation. The alternative could be a testing build,
// a new lib, or whatever; we dunno just yet. This message is for early adopters
// to get their tests right.

function warnIfUnmockedScheduler(fiber) {
  {
    if (didWarnAboutUnmockedScheduler === false && Scheduler.unstable_flushAllWithoutAsserting === undefined) {
      if (fiber.mode & BlockingMode || fiber.mode & ConcurrentMode) {
        didWarnAboutUnmockedScheduler = true;

        error('In Concurrent or Sync modes, the "scheduler" module needs to be mocked ' + 'to guarantee consistent behaviour across tests and browsers. ' + 'For example, with jest: \n' + // Break up requires to avoid accidentally parsing them as dependencies.
        "jest.mock('scheduler', () => require" + "('scheduler/unstable_mock'));\n\n" + 'For more info, visit https://reactjs.org/link/mock-scheduler');
      }
    }
  }
}

function computeThreadID(root, lane) {
  // Interaction threads are unique per root and expiration time.
  // NOTE: Intentionally unsound cast. All that matters is that it's a number
  // and it represents a batch of work. Could make a helper function instead,
  // but meh this is fine for now.
  return lane * 1000 + root.interactionThreadID;
}

function markSpawnedWork(lane) {

  if (spawnedWorkDuringRender === null) {
    spawnedWorkDuringRender = [lane];
  } else {
    spawnedWorkDuringRender.push(lane);
  }
}

function scheduleInteractions(root, lane, interactions) {

  if (interactions.size > 0) {
    var pendingInteractionMap = root.pendingInteractionMap;
    var pendingInteractions = pendingInteractionMap.get(lane);

    if (pendingInteractions != null) {
      interactions.forEach(function (interaction) {
        if (!pendingInteractions.has(interaction)) {
          // Update the pending async work count for previously unscheduled interaction.
          interaction.__count++;
        }

        pendingInteractions.add(interaction);
      });
    } else {
      pendingInteractionMap.set(lane, new Set(interactions)); // Update the pending async work count for the current interactions.

      interactions.forEach(function (interaction) {
        interaction.__count++;
      });
    }

    var subscriber = tracing.__subscriberRef.current;

    if (subscriber !== null) {
      var threadID = computeThreadID(root, lane);
      subscriber.onWorkScheduled(interactions, threadID);
    }
  }
}

function schedulePendingInteractions(root, lane) {

  scheduleInteractions(root, lane, tracing.__interactionsRef.current);
}

function startWorkOnPendingInteractions(root, lanes) {
  // we can accurately attribute time spent working on it, And so that cascading
  // work triggered during the render phase will be associated with it.


  var interactions = new Set();
  root.pendingInteractionMap.forEach(function (scheduledInteractions, scheduledLane) {
    if (includesSomeLane(lanes, scheduledLane)) {
      scheduledInteractions.forEach(function (interaction) {
        return interactions.add(interaction);
      });
    }
  }); // Store the current set of interactions on the FiberRoot for a few reasons:
  // We can re-use it in hot functions like performConcurrentWorkOnRoot()
  // without having to recalculate it. We will also use it in commitWork() to
  // pass to any Profiler onRender() hooks. This also provides DevTools with a
  // way to access it when the onCommitRoot() hook is called.

  root.memoizedInteractions = interactions;

  if (interactions.size > 0) {
    var subscriber = tracing.__subscriberRef.current;

    if (subscriber !== null) {
      var threadID = computeThreadID(root, lanes);

      try {
        subscriber.onWorkStarted(interactions, threadID);
      } catch (error) {
        // If the subscriber throws, rethrow it in a separate task
        scheduleCallback(ImmediatePriority$1, function () {
          throw error;
        });
      }
    }
  }
}

function finishPendingInteractions(root, committedLanes) {

  var remainingLanesAfterCommit = root.pendingLanes;
  var subscriber;

  try {
    subscriber = tracing.__subscriberRef.current;

    if (subscriber !== null && root.memoizedInteractions.size > 0) {
      // FIXME: More than one lane can finish in a single commit.
      var threadID = computeThreadID(root, committedLanes);
      subscriber.onWorkStopped(root.memoizedInteractions, threadID);
    }
  } catch (error) {
    // If the subscriber throws, rethrow it in a separate task
    scheduleCallback(ImmediatePriority$1, function () {
      throw error;
    });
  } finally {
    // Clear completed interactions from the pending Map.
    // Unless the render was suspended or cascading work was scheduled,
    // In which case leave pending interactions until the subsequent render.
    var pendingInteractionMap = root.pendingInteractionMap;
    pendingInteractionMap.forEach(function (scheduledInteractions, lane) {
      // Only decrement the pending interaction count if we're done.
      // If there's still work at the current priority,
      // That indicates that we are waiting for suspense data.
      if (!includesSomeLane(remainingLanesAfterCommit, lane)) {
        pendingInteractionMap.delete(lane);
        scheduledInteractions.forEach(function (interaction) {
          interaction.__count--;

          if (subscriber !== null && interaction.__count === 0) {
            try {
              subscriber.onInteractionScheduledWorkCompleted(interaction);
            } catch (error) {
              // If the subscriber throws, rethrow it in a separate task
              scheduleCallback(ImmediatePriority$1, function () {
                throw error;
              });
            }
          }
        });
      }
    });
  }
} // `act` testing API

function shouldForceFlushFallbacksInDEV() {
  // Never force flush in production. This function should get stripped out.
  return  actingUpdatesScopeDepth > 0;
}
// so we can tell if any async act() calls try to run in parallel.


var actingUpdatesScopeDepth = 0;

function detachFiberAfterEffects(fiber) {
  fiber.sibling = null;
  fiber.stateNode = null;
}

var resolveFamily = null; // $FlowFixMe Flow gets confused by a WeakSet feature check below.

var failedBoundaries = null;
var setRefreshHandler = function (handler) {
  {
    resolveFamily = handler;
  }
};
function resolveFunctionForHotReloading(type) {
  {
    if (resolveFamily === null) {
      // Hot reloading is disabled.
      return type;
    }

    var family = resolveFamily(type);

    if (family === undefined) {
      return type;
    } // Use the latest known implementation.


    return family.current;
  }
}
function resolveClassForHotReloading(type) {
  // No implementation differences.
  return resolveFunctionForHotReloading(type);
}
function resolveForwardRefForHotReloading(type) {
  {
    if (resolveFamily === null) {
      // Hot reloading is disabled.
      return type;
    }

    var family = resolveFamily(type);

    if (family === undefined) {
      // Check if we're dealing with a real forwardRef. Don't want to crash early.
      if (type !== null && type !== undefined && typeof type.render === 'function') {
        // ForwardRef is special because its resolved .type is an object,
        // but it's possible that we only have its inner render function in the map.
        // If that inner render function is different, we'll build a new forwardRef type.
        var currentRender = resolveFunctionForHotReloading(type.render);

        if (type.render !== currentRender) {
          var syntheticType = {
            $$typeof: REACT_FORWARD_REF_TYPE,
            render: currentRender
          };

          if (type.displayName !== undefined) {
            syntheticType.displayName = type.displayName;
          }

          return syntheticType;
        }
      }

      return type;
    } // Use the latest known implementation.


    return family.current;
  }
}
function isCompatibleFamilyForHotReloading(fiber, element) {
  {
    if (resolveFamily === null) {
      // Hot reloading is disabled.
      return false;
    }

    var prevType = fiber.elementType;
    var nextType = element.type; // If we got here, we know types aren't === equal.

    var needsCompareFamilies = false;
    var $$typeofNextType = typeof nextType === 'object' && nextType !== null ? nextType.$$typeof : null;

    switch (fiber.tag) {
      case ClassComponent:
        {
          if (typeof nextType === 'function') {
            needsCompareFamilies = true;
          }

          break;
        }

      case FunctionComponent:
        {
          if (typeof nextType === 'function') {
            needsCompareFamilies = true;
          } else if ($$typeofNextType === REACT_LAZY_TYPE) {
            // We don't know the inner type yet.
            // We're going to assume that the lazy inner type is stable,
            // and so it is sufficient to avoid reconciling it away.
            // We're not going to unwrap or actually use the new lazy type.
            needsCompareFamilies = true;
          }

          break;
        }

      case ForwardRef:
        {
          if ($$typeofNextType === REACT_FORWARD_REF_TYPE) {
            needsCompareFamilies = true;
          } else if ($$typeofNextType === REACT_LAZY_TYPE) {
            needsCompareFamilies = true;
          }

          break;
        }

      case MemoComponent:
      case SimpleMemoComponent:
        {
          if ($$typeofNextType === REACT_MEMO_TYPE) {
            // TODO: if it was but can no longer be simple,
            // we shouldn't set this.
            needsCompareFamilies = true;
          } else if ($$typeofNextType === REACT_LAZY_TYPE) {
            needsCompareFamilies = true;
          }

          break;
        }

      default:
        return false;
    } // Check if both types have a family and it's the same one.


    if (needsCompareFamilies) {
      // Note: memo() and forwardRef() we'll compare outer rather than inner type.
      // This means both of them need to be registered to preserve state.
      // If we unwrapped and compared the inner types for wrappers instead,
      // then we would risk falsely saying two separate memo(Foo)
      // calls are equivalent because they wrap the same Foo function.
      var prevFamily = resolveFamily(prevType);

      if (prevFamily !== undefined && prevFamily === resolveFamily(nextType)) {
        return true;
      }
    }

    return false;
  }
}
function markFailedErrorBoundaryForHotReloading(fiber) {
  {
    if (resolveFamily === null) {
      // Hot reloading is disabled.
      return;
    }

    if (typeof WeakSet !== 'function') {
      return;
    }

    if (failedBoundaries === null) {
      failedBoundaries = new WeakSet();
    }

    failedBoundaries.add(fiber);
  }
}
var scheduleRefresh = function (root, update) {
  {
    if (resolveFamily === null) {
      // Hot reloading is disabled.
      return;
    }

    var staleFamilies = update.staleFamilies,
        updatedFamilies = update.updatedFamilies;
    flushPassiveEffects();
    flushSync(function () {
      scheduleFibersWithFamiliesRecursively(root.current, updatedFamilies, staleFamilies);
    });
  }
};
var scheduleRoot = function (root, element) {
  {
    if (root.context !== emptyContextObject) {
      // Super edge case: root has a legacy _renderSubtree context
      // but we don't know the parentComponent so we can't pass it.
      // Just ignore. We'll delete this with _renderSubtree code path later.
      return;
    }

    flushPassiveEffects();
    flushSync(function () {
      updateContainer(element, root, null, null);
    });
  }
};

function scheduleFibersWithFamiliesRecursively(fiber, updatedFamilies, staleFamilies) {
  {
    var alternate = fiber.alternate,
        child = fiber.child,
        sibling = fiber.sibling,
        tag = fiber.tag,
        type = fiber.type;
    var candidateType = null;

    switch (tag) {
      case FunctionComponent:
      case SimpleMemoComponent:
      case ClassComponent:
        candidateType = type;
        break;

      case ForwardRef:
        candidateType = type.render;
        break;
    }

    if (resolveFamily === null) {
      throw new Error('Expected resolveFamily to be set during hot reload.');
    }

    var needsRender = false;
    var needsRemount = false;

    if (candidateType !== null) {
      var family = resolveFamily(candidateType);

      if (family !== undefined) {
        if (staleFamilies.has(family)) {
          needsRemount = true;
        } else if (updatedFamilies.has(family)) {
          if (tag === ClassComponent) {
            needsRemount = true;
          } else {
            needsRender = true;
          }
        }
      }
    }

    if (failedBoundaries !== null) {
      if (failedBoundaries.has(fiber) || alternate !== null && failedBoundaries.has(alternate)) {
        needsRemount = true;
      }
    }

    if (needsRemount) {
      fiber._debugNeedsRemount = true;
    }

    if (needsRemount || needsRender) {
      scheduleUpdateOnFiber(fiber, SyncLane, NoTimestamp);
    }

    if (child !== null && !needsRemount) {
      scheduleFibersWithFamiliesRecursively(child, updatedFamilies, staleFamilies);
    }

    if (sibling !== null) {
      scheduleFibersWithFamiliesRecursively(sibling, updatedFamilies, staleFamilies);
    }
  }
}

var findHostInstancesForRefresh = function (root, families) {
  {
    var hostInstances = new Set();
    var types = new Set(families.map(function (family) {
      return family.current;
    }));
    findHostInstancesForMatchingFibersRecursively(root.current, types, hostInstances);
    return hostInstances;
  }
};

function findHostInstancesForMatchingFibersRecursively(fiber, types, hostInstances) {
  {
    var child = fiber.child,
        sibling = fiber.sibling,
        tag = fiber.tag,
        type = fiber.type;
    var candidateType = null;

    switch (tag) {
      case FunctionComponent:
      case SimpleMemoComponent:
      case ClassComponent:
        candidateType = type;
        break;

      case ForwardRef:
        candidateType = type.render;
        break;
    }

    var didMatch = false;

    if (candidateType !== null) {
      if (types.has(candidateType)) {
        didMatch = true;
      }
    }

    if (didMatch) {
      // We have a match. This only drills down to the closest host components.
      // There's no need to search deeper because for the purpose of giving
      // visual feedback, "flashing" outermost parent rectangles is sufficient.
      findHostInstancesForFiberShallowly(fiber, hostInstances);
    } else {
      // If there's no match, maybe there will be one further down in the child tree.
      if (child !== null) {
        findHostInstancesForMatchingFibersRecursively(child, types, hostInstances);
      }
    }

    if (sibling !== null) {
      findHostInstancesForMatchingFibersRecursively(sibling, types, hostInstances);
    }
  }
}

function findHostInstancesForFiberShallowly(fiber, hostInstances) {
  {
    var foundHostInstances = findChildHostInstancesForFiberShallowly(fiber, hostInstances);

    if (foundHostInstances) {
      return;
    } // If we didn't find any host children, fallback to closest host parent.


    var node = fiber;

    while (true) {
      switch (node.tag) {
        case HostComponent:
          hostInstances.add(node.stateNode);
          return;

        case HostPortal:
          hostInstances.add(node.stateNode.containerInfo);
          return;

        case HostRoot:
          hostInstances.add(node.stateNode.containerInfo);
          return;
      }

      if (node.return === null) {
        throw new Error('Expected to reach root first.');
      }

      node = node.return;
    }
  }
}

function findChildHostInstancesForFiberShallowly(fiber, hostInstances) {
  {
    var node = fiber;
    var foundHostInstances = false;

    while (true) {
      if (node.tag === HostComponent) {
        // We got a match.
        foundHostInstances = true;
        hostInstances.add(node.stateNode); // There may still be more, so keep searching.
      } else if (node.child !== null) {
        node.child.return = node;
        node = node.child;
        continue;
      }

      if (node === fiber) {
        return foundHostInstances;
      }

      while (node.sibling === null) {
        if (node.return === null || node.return === fiber) {
          return foundHostInstances;
        }

        node = node.return;
      }

      node.sibling.return = node.return;
      node = node.sibling;
    }
  }

  return false;
}

var hasBadMapPolyfill;

{
  hasBadMapPolyfill = false;

  try {
    var nonExtensibleObject = Object.preventExtensions({});
    /* eslint-disable no-new */

    new Map([[nonExtensibleObject, null]]);
    new Set([nonExtensibleObject]);
    /* eslint-enable no-new */
  } catch (e) {
    // TODO: Consider warning about bad polyfills
    hasBadMapPolyfill = true;
  }
}

var debugCounter = 1;

function FiberNode(tag, pendingProps, key, mode) {
  // Instance
  this.tag = tag;
  this.key = key;
  this.elementType = null;
  this.type = null;
  this.stateNode = null; // Fiber

  this.return = null;
  this.child = null;
  this.sibling = null;
  this.index = 0;
  this.ref = null;
  this.pendingProps = pendingProps;
  this.memoizedProps = null;
  this.updateQueue = null;
  this.memoizedState = null;
  this.dependencies = null;
  this.mode = mode; // Effects

  this.flags = NoFlags;
  this.nextEffect = null;
  this.firstEffect = null;
  this.lastEffect = null;
  this.lanes = NoLanes;
  this.childLanes = NoLanes;
  this.alternate = null;

  {
    // Note: The following is done to avoid a v8 performance cliff.
    //
    // Initializing the fields below to smis and later updating them with
    // double values will cause Fibers to end up having separate shapes.
    // This behavior/bug has something to do with Object.preventExtension().
    // Fortunately this only impacts DEV builds.
    // Unfortunately it makes React unusably slow for some applications.
    // To work around this, initialize the fields below with doubles.
    //
    // Learn more about this here:
    // https://github.com/facebook/react/issues/14365
    // https://bugs.chromium.org/p/v8/issues/detail?id=8538
    this.actualDuration = Number.NaN;
    this.actualStartTime = Number.NaN;
    this.selfBaseDuration = Number.NaN;
    this.treeBaseDuration = Number.NaN; // It's okay to replace the initial doubles with smis after initialization.
    // This won't trigger the performance cliff mentioned above,
    // and it simplifies other profiler code (including DevTools).

    this.actualDuration = 0;
    this.actualStartTime = -1;
    this.selfBaseDuration = 0;
    this.treeBaseDuration = 0;
  }

  {
    // This isn't directly used but is handy for debugging internals:
    this._debugID = debugCounter++;
    this._debugSource = null;
    this._debugOwner = null;
    this._debugNeedsRemount = false;
    this._debugHookTypes = null;

    if (!hasBadMapPolyfill && typeof Object.preventExtensions === 'function') {
      Object.preventExtensions(this);
    }
  }
} // This is a constructor function, rather than a POJO constructor, still
// please ensure we do the following:
// 1) Nobody should add any instance methods on this. Instance methods can be
//    more difficult to predict when they get optimized and they are almost
//    never inlined properly in static compilers.
// 2) Nobody should rely on `instanceof Fiber` for type testing. We should
//    always know when it is a fiber.
// 3) We might want to experiment with using numeric keys since they are easier
//    to optimize in a non-JIT environment.
// 4) We can easily go from a constructor to a createFiber object literal if that
//    is faster.
// 5) It should be easy to port this to a C struct and keep a C implementation
//    compatible.


var createFiber = function (tag, pendingProps, key, mode) {
  // $FlowFixMe: the shapes are exact here but Flow doesn't like constructors
  return new FiberNode(tag, pendingProps, key, mode);
};

function shouldConstruct$1(Component) {
  var prototype = Component.prototype;
  return !!(prototype && prototype.isReactComponent);
}

function isSimpleFunctionComponent(type) {
  return typeof type === 'function' && !shouldConstruct$1(type) && type.defaultProps === undefined;
}
function resolveLazyComponentTag(Component) {
  if (typeof Component === 'function') {
    return shouldConstruct$1(Component) ? ClassComponent : FunctionComponent;
  } else if (Component !== undefined && Component !== null) {
    var $$typeof = Component.$$typeof;

    if ($$typeof === REACT_FORWARD_REF_TYPE) {
      return ForwardRef;
    }

    if ($$typeof === REACT_MEMO_TYPE) {
      return MemoComponent;
    }
  }

  return IndeterminateComponent;
} // This is used to create an alternate fiber to do work on.

function createWorkInProgress(current, pendingProps) {
  var workInProgress = current.alternate;

  if (workInProgress === null) {
    // We use a double buffering pooling technique because we know that we'll
    // only ever need at most two versions of a tree. We pool the "other" unused
    // node that we're free to reuse. This is lazily created to avoid allocating
    // extra objects for things that are never updated. It also allow us to
    // reclaim the extra memory if needed.
    workInProgress = createFiber(current.tag, pendingProps, current.key, current.mode);
    workInProgress.elementType = current.elementType;
    workInProgress.type = current.type;
    workInProgress.stateNode = current.stateNode;

    {
      // DEV-only fields
      workInProgress._debugID = current._debugID;
      workInProgress._debugSource = current._debugSource;
      workInProgress._debugOwner = current._debugOwner;
      workInProgress._debugHookTypes = current._debugHookTypes;
    }

    workInProgress.alternate = current;
    current.alternate = workInProgress;
  } else {
    workInProgress.pendingProps = pendingProps; // Needed because Blocks store data on type.

    workInProgress.type = current.type; // We already have an alternate.
    // Reset the effect tag.

    workInProgress.flags = NoFlags; // The effect list is no longer valid.

    workInProgress.nextEffect = null;
    workInProgress.firstEffect = null;
    workInProgress.lastEffect = null;

    {
      // We intentionally reset, rather than copy, actualDuration & actualStartTime.
      // This prevents time from endlessly accumulating in new commits.
      // This has the downside of resetting values for different priority renders,
      // But works for yielding (the common case) and should support resuming.
      workInProgress.actualDuration = 0;
      workInProgress.actualStartTime = -1;
    }
  }

  workInProgress.childLanes = current.childLanes;
  workInProgress.lanes = current.lanes;
  workInProgress.child = current.child;
  workInProgress.memoizedProps = current.memoizedProps;
  workInProgress.memoizedState = current.memoizedState;
  workInProgress.updateQueue = current.updateQueue; // Clone the dependencies object. This is mutated during the render phase, so
  // it cannot be shared with the current fiber.

  var currentDependencies = current.dependencies;
  workInProgress.dependencies = currentDependencies === null ? null : {
    lanes: currentDependencies.lanes,
    firstContext: currentDependencies.firstContext
  }; // These will be overridden during the parent's reconciliation

  workInProgress.sibling = current.sibling;
  workInProgress.index = current.index;
  workInProgress.ref = current.ref;

  {
    workInProgress.selfBaseDuration = current.selfBaseDuration;
    workInProgress.treeBaseDuration = current.treeBaseDuration;
  }

  {
    workInProgress._debugNeedsRemount = current._debugNeedsRemount;

    switch (workInProgress.tag) {
      case IndeterminateComponent:
      case FunctionComponent:
      case SimpleMemoComponent:
        workInProgress.type = resolveFunctionForHotReloading(current.type);
        break;

      case ClassComponent:
        workInProgress.type = resolveClassForHotReloading(current.type);
        break;

      case ForwardRef:
        workInProgress.type = resolveForwardRefForHotReloading(current.type);
        break;
    }
  }

  return workInProgress;
} // Used to reuse a Fiber for a second pass.

function resetWorkInProgress(workInProgress, renderLanes) {
  // This resets the Fiber to what createFiber or createWorkInProgress would
  // have set the values to before during the first pass. Ideally this wouldn't
  // be necessary but unfortunately many code paths reads from the workInProgress
  // when they should be reading from current and writing to workInProgress.
  // We assume pendingProps, index, key, ref, return are still untouched to
  // avoid doing another reconciliation.
  // Reset the effect tag but keep any Placement tags, since that's something
  // that child fiber is setting, not the reconciliation.
  workInProgress.flags &= Placement; // The effect list is no longer valid.

  workInProgress.nextEffect = null;
  workInProgress.firstEffect = null;
  workInProgress.lastEffect = null;
  var current = workInProgress.alternate;

  if (current === null) {
    // Reset to createFiber's initial values.
    workInProgress.childLanes = NoLanes;
    workInProgress.lanes = renderLanes;
    workInProgress.child = null;
    workInProgress.memoizedProps = null;
    workInProgress.memoizedState = null;
    workInProgress.updateQueue = null;
    workInProgress.dependencies = null;
    workInProgress.stateNode = null;

    {
      // Note: We don't reset the actualTime counts. It's useful to accumulate
      // actual time across multiple render passes.
      workInProgress.selfBaseDuration = 0;
      workInProgress.treeBaseDuration = 0;
    }
  } else {
    // Reset to the cloned values that createWorkInProgress would've.
    workInProgress.childLanes = current.childLanes;
    workInProgress.lanes = current.lanes;
    workInProgress.child = current.child;
    workInProgress.memoizedProps = current.memoizedProps;
    workInProgress.memoizedState = current.memoizedState;
    workInProgress.updateQueue = current.updateQueue; // Needed because Blocks store data on type.

    workInProgress.type = current.type; // Clone the dependencies object. This is mutated during the render phase, so
    // it cannot be shared with the current fiber.

    var currentDependencies = current.dependencies;
    workInProgress.dependencies = currentDependencies === null ? null : {
      lanes: currentDependencies.lanes,
      firstContext: currentDependencies.firstContext
    };

    {
      // Note: We don't reset the actualTime counts. It's useful to accumulate
      // actual time across multiple render passes.
      workInProgress.selfBaseDuration = current.selfBaseDuration;
      workInProgress.treeBaseDuration = current.treeBaseDuration;
    }
  }

  return workInProgress;
}
function createHostRootFiber(tag) {
  var mode;

  if (tag === ConcurrentRoot) {
    mode = ConcurrentMode | BlockingMode | StrictMode;
  } else if (tag === BlockingRoot) {
    mode = BlockingMode | StrictMode;
  } else {
    mode = NoMode;
  }

  if ( isDevToolsPresent) {
    // Always collect profile timings when DevTools are present.
    // This enables DevTools to start capturing timing at any point
    // Without some nodes in the tree having empty base times.
    mode |= ProfileMode;
  }

  return createFiber(HostRoot, null, null, mode);
}
function createFiberFromTypeAndProps(type, // React$ElementType
key, pendingProps, owner, mode, lanes) {
  var fiberTag = IndeterminateComponent; // The resolved type is set if we know what the final type will be. I.e. it's not lazy.

  var resolvedType = type;

  if (typeof type === 'function') {
    if (shouldConstruct$1(type)) {
      fiberTag = ClassComponent;

      {
        resolvedType = resolveClassForHotReloading(resolvedType);
      }
    } else {
      {
        resolvedType = resolveFunctionForHotReloading(resolvedType);
      }
    }
  } else if (typeof type === 'string') {
    fiberTag = HostComponent;
  } else {
    getTag: switch (type) {
      case REACT_FRAGMENT_TYPE:
        return createFiberFromFragment(pendingProps.children, mode, lanes, key);

      case REACT_DEBUG_TRACING_MODE_TYPE:
        fiberTag = Mode;
        mode |= DebugTracingMode;
        break;

      case REACT_STRICT_MODE_TYPE:
        fiberTag = Mode;
        mode |= StrictMode;
        break;

      case REACT_PROFILER_TYPE:
        return createFiberFromProfiler(pendingProps, mode, lanes, key);

      case REACT_SUSPENSE_TYPE:
        return createFiberFromSuspense(pendingProps, mode, lanes, key);

      case REACT_SUSPENSE_LIST_TYPE:
        return createFiberFromSuspenseList(pendingProps, mode, lanes, key);

      case REACT_OFFSCREEN_TYPE:
        return createFiberFromOffscreen(pendingProps, mode, lanes, key);

      case REACT_LEGACY_HIDDEN_TYPE:
        return createFiberFromLegacyHidden(pendingProps, mode, lanes, key);

      case REACT_SCOPE_TYPE:

      // eslint-disable-next-line no-fallthrough

      default:
        {
          if (typeof type === 'object' && type !== null) {
            switch (type.$$typeof) {
              case REACT_PROVIDER_TYPE:
                fiberTag = ContextProvider;
                break getTag;

              case REACT_CONTEXT_TYPE:
                // This is a consumer
                fiberTag = ContextConsumer;
                break getTag;

              case REACT_FORWARD_REF_TYPE:
                fiberTag = ForwardRef;

                {
                  resolvedType = resolveForwardRefForHotReloading(resolvedType);
                }

                break getTag;

              case REACT_MEMO_TYPE:
                fiberTag = MemoComponent;
                break getTag;

              case REACT_LAZY_TYPE:
                fiberTag = LazyComponent;
                resolvedType = null;
                break getTag;

              case REACT_BLOCK_TYPE:
                fiberTag = Block;
                break getTag;
            }
          }

          var info = '';

          {
            if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {
              info += ' You likely forgot to export your component from the file ' + "it's defined in, or you might have mixed up default and " + 'named imports.';
            }

            var ownerName = owner ? getComponentName(owner.type) : null;

            if (ownerName) {
              info += '\n\nCheck the render method of `' + ownerName + '`.';
            }
          }

          {
            {
              throw Error( "Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) but got: " + (type == null ? type : typeof type) + "." + info );
            }
          }
        }
    }
  }

  var fiber = createFiber(fiberTag, pendingProps, key, mode);
  fiber.elementType = type;
  fiber.type = resolvedType;
  fiber.lanes = lanes;

  {
    fiber._debugOwner = owner;
  }

  return fiber;
}
function createFiberFromElement(element, mode, lanes) {
  var owner = null;

  {
    owner = element._owner;
  }

  var type = element.type;
  var key = element.key;
  var pendingProps = element.props;
  var fiber = createFiberFromTypeAndProps(type, key, pendingProps, owner, mode, lanes);

  {
    fiber._debugSource = element._source;
    fiber._debugOwner = element._owner;
  }

  return fiber;
}
function createFiberFromFragment(elements, mode, lanes, key) {
  var fiber = createFiber(Fragment, elements, key, mode);
  fiber.lanes = lanes;
  return fiber;
}

function createFiberFromProfiler(pendingProps, mode, lanes, key) {
  {
    if (typeof pendingProps.id !== 'string') {
      error('Profiler must specify an "id" as a prop');
    }
  }

  var fiber = createFiber(Profiler, pendingProps, key, mode | ProfileMode); // TODO: The Profiler fiber shouldn't have a type. It has a tag.

  fiber.elementType = REACT_PROFILER_TYPE;
  fiber.type = REACT_PROFILER_TYPE;
  fiber.lanes = lanes;

  {
    fiber.stateNode = {
      effectDuration: 0,
      passiveEffectDuration: 0
    };
  }

  return fiber;
}

function createFiberFromSuspense(pendingProps, mode, lanes, key) {
  var fiber = createFiber(SuspenseComponent, pendingProps, key, mode); // TODO: The SuspenseComponent fiber shouldn't have a type. It has a tag.
  // This needs to be fixed in getComponentName so that it relies on the tag
  // instead.

  fiber.type = REACT_SUSPENSE_TYPE;
  fiber.elementType = REACT_SUSPENSE_TYPE;
  fiber.lanes = lanes;
  return fiber;
}
function createFiberFromSuspenseList(pendingProps, mode, lanes, key) {
  var fiber = createFiber(SuspenseListComponent, pendingProps, key, mode);

  {
    // TODO: The SuspenseListComponent fiber shouldn't have a type. It has a tag.
    // This needs to be fixed in getComponentName so that it relies on the tag
    // instead.
    fiber.type = REACT_SUSPENSE_LIST_TYPE;
  }

  fiber.elementType = REACT_SUSPENSE_LIST_TYPE;
  fiber.lanes = lanes;
  return fiber;
}
function createFiberFromOffscreen(pendingProps, mode, lanes, key) {
  var fiber = createFiber(OffscreenComponent, pendingProps, key, mode); // TODO: The OffscreenComponent fiber shouldn't have a type. It has a tag.
  // This needs to be fixed in getComponentName so that it relies on the tag
  // instead.

  {
    fiber.type = REACT_OFFSCREEN_TYPE;
  }

  fiber.elementType = REACT_OFFSCREEN_TYPE;
  fiber.lanes = lanes;
  return fiber;
}
function createFiberFromLegacyHidden(pendingProps, mode, lanes, key) {
  var fiber = createFiber(LegacyHiddenComponent, pendingProps, key, mode); // TODO: The LegacyHidden fiber shouldn't have a type. It has a tag.
  // This needs to be fixed in getComponentName so that it relies on the tag
  // instead.

  {
    fiber.type = REACT_LEGACY_HIDDEN_TYPE;
  }

  fiber.elementType = REACT_LEGACY_HIDDEN_TYPE;
  fiber.lanes = lanes;
  return fiber;
}
function createFiberFromText(content, mode, lanes) {
  var fiber = createFiber(HostText, content, null, mode);
  fiber.lanes = lanes;
  return fiber;
}
function createFiberFromHostInstanceForDeletion() {
  var fiber = createFiber(HostComponent, null, null, NoMode); // TODO: These should not need a type.

  fiber.elementType = 'DELETED';
  fiber.type = 'DELETED';
  return fiber;
}
function createFiberFromPortal(portal, mode, lanes) {
  var pendingProps = portal.children !== null ? portal.children : [];
  var fiber = createFiber(HostPortal, pendingProps, portal.key, mode);
  fiber.lanes = lanes;
  fiber.stateNode = {
    containerInfo: portal.containerInfo,
    pendingChildren: null,
    // Used by persistent updates
    implementation: portal.implementation
  };
  return fiber;
} // Used for stashing WIP properties to replay failed work in DEV.

function assignFiberPropertiesInDEV(target, source) {
  if (target === null) {
    // This Fiber's initial properties will always be overwritten.
    // We only use a Fiber to ensure the same hidden class so DEV isn't slow.
    target = createFiber(IndeterminateComponent, null, null, NoMode);
  } // This is intentionally written as a list of all properties.
  // We tried to use Object.assign() instead but this is called in
  // the hottest path, and Object.assign() was too slow:
  // https://github.com/facebook/react/issues/12502
  // This code is DEV-only so size is not a concern.


  target.tag = source.tag;
  target.key = source.key;
  target.elementType = source.elementType;
  target.type = source.type;
  target.stateNode = source.stateNode;
  target.return = source.return;
  target.child = source.child;
  target.sibling = source.sibling;
  target.index = source.index;
  target.ref = source.ref;
  target.pendingProps = source.pendingProps;
  target.memoizedProps = source.memoizedProps;
  target.updateQueue = source.updateQueue;
  target.memoizedState = source.memoizedState;
  target.dependencies = source.dependencies;
  target.mode = source.mode;
  target.flags = source.flags;
  target.nextEffect = source.nextEffect;
  target.firstEffect = source.firstEffect;
  target.lastEffect = source.lastEffect;
  target.lanes = source.lanes;
  target.childLanes = source.childLanes;
  target.alternate = source.alternate;

  {
    target.actualDuration = source.actualDuration;
    target.actualStartTime = source.actualStartTime;
    target.selfBaseDuration = source.selfBaseDuration;
    target.treeBaseDuration = source.treeBaseDuration;
  }

  target._debugID = source._debugID;
  target._debugSource = source._debugSource;
  target._debugOwner = source._debugOwner;
  target._debugNeedsRemount = source._debugNeedsRemount;
  target._debugHookTypes = source._debugHookTypes;
  return target;
}

function FiberRootNode(containerInfo, tag, hydrate) {
  this.tag = tag;
  this.containerInfo = containerInfo;
  this.pendingChildren = null;
  this.current = null;
  this.pingCache = null;
  this.finishedWork = null;
  this.timeoutHandle = noTimeout;
  this.context = null;
  this.pendingContext = null;
  this.hydrate = hydrate;
  this.callbackNode = null;
  this.callbackPriority = NoLanePriority;
  this.eventTimes = createLaneMap(NoLanes);
  this.expirationTimes = createLaneMap(NoTimestamp);
  this.pendingLanes = NoLanes;
  this.suspendedLanes = NoLanes;
  this.pingedLanes = NoLanes;
  this.expiredLanes = NoLanes;
  this.mutableReadLanes = NoLanes;
  this.finishedLanes = NoLanes;
  this.entangledLanes = NoLanes;
  this.entanglements = createLaneMap(NoLanes);

  {
    this.mutableSourceEagerHydrationData = null;
  }

  {
    this.interactionThreadID = tracing.unstable_getThreadID();
    this.memoizedInteractions = new Set();
    this.pendingInteractionMap = new Map();
  }

  {
    switch (tag) {
      case BlockingRoot:
        this._debugRootType = 'createBlockingRoot()';
        break;

      case ConcurrentRoot:
        this._debugRootType = 'createRoot()';
        break;

      case LegacyRoot:
        this._debugRootType = 'createLegacyRoot()';
        break;
    }
  }
}

function createFiberRoot(containerInfo, tag, hydrate, hydrationCallbacks) {
  var root = new FiberRootNode(containerInfo, tag, hydrate);
  // stateNode is any.


  var uninitializedFiber = createHostRootFiber(tag);
  root.current = uninitializedFiber;
  uninitializedFiber.stateNode = root;
  initializeUpdateQueue(uninitializedFiber);
  return root;
}

// This ensures that the version used for server rendering matches the one
// that is eventually read during hydration.
// If they don't match there's a potential tear and a full deopt render is required.

function registerMutableSourceForHydration(root, mutableSource) {
  var getVersion = mutableSource._getVersion;
  var version = getVersion(mutableSource._source); // TODO Clear this data once all pending hydration work is finished.
  // Retaining it forever may interfere with GC.

  if (root.mutableSourceEagerHydrationData == null) {
    root.mutableSourceEagerHydrationData = [mutableSource, version];
  } else {
    root.mutableSourceEagerHydrationData.push(mutableSource, version);
  }
}

function createPortal(children, containerInfo, // TODO: figure out the API for cross-renderer implementation.
implementation) {
  var key = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
  return {
    // This tag allow us to uniquely identify this as a React Portal
    $$typeof: REACT_PORTAL_TYPE,
    key: key == null ? null : '' + key,
    children: children,
    containerInfo: containerInfo,
    implementation: implementation
  };
}

var didWarnAboutNestedUpdates;
var didWarnAboutFindNodeInStrictMode;

{
  didWarnAboutNestedUpdates = false;
  didWarnAboutFindNodeInStrictMode = {};
}

function getContextForSubtree(parentComponent) {
  if (!parentComponent) {
    return emptyContextObject;
  }

  var fiber = get(parentComponent);
  var parentContext = findCurrentUnmaskedContext(fiber);

  if (fiber.tag === ClassComponent) {
    var Component = fiber.type;

    if (isContextProvider(Component)) {
      return processChildContext(fiber, Component, parentContext);
    }
  }

  return parentContext;
}

function findHostInstanceWithWarning(component, methodName) {
  {
    var fiber = get(component);

    if (fiber === undefined) {
      if (typeof component.render === 'function') {
        {
          {
            throw Error( "Unable to find node on an unmounted component." );
          }
        }
      } else {
        {
          {
            throw Error( "Argument appears to not be a ReactComponent. Keys: " + Object.keys(component) );
          }
        }
      }
    }

    var hostFiber = findCurrentHostFiber(fiber);

    if (hostFiber === null) {
      return null;
    }

    if (hostFiber.mode & StrictMode) {
      var componentName = getComponentName(fiber.type) || 'Component';

      if (!didWarnAboutFindNodeInStrictMode[componentName]) {
        didWarnAboutFindNodeInStrictMode[componentName] = true;
        var previousFiber = current;

        try {
          setCurrentFiber(hostFiber);

          if (fiber.mode & StrictMode) {
            error('%s is deprecated in StrictMode. ' + '%s was passed an instance of %s which is inside StrictMode. ' + 'Instead, add a ref directly to the element you want to reference. ' + 'Learn more about using refs safely here: ' + 'https://reactjs.org/link/strict-mode-find-node', methodName, methodName, componentName);
          } else {
            error('%s is deprecated in StrictMode. ' + '%s was passed an instance of %s which renders StrictMode children. ' + 'Instead, add a ref directly to the element you want to reference. ' + 'Learn more about using refs safely here: ' + 'https://reactjs.org/link/strict-mode-find-node', methodName, methodName, componentName);
          }
        } finally {
          // Ideally this should reset to previous but this shouldn't be called in
          // render and there's another warning for that anyway.
          if (previousFiber) {
            setCurrentFiber(previousFiber);
          } else {
            resetCurrentFiber();
          }
        }
      }
    }

    return hostFiber.stateNode;
  }
}

function createContainer(containerInfo, tag, hydrate, hydrationCallbacks) {
  return createFiberRoot(containerInfo, tag, hydrate);
}
function updateContainer(element, container, parentComponent, callback) {
  {
    onScheduleRoot(container, element);
  }

  var current$1 = container.current;
  var eventTime = requestEventTime();

  {
    // $FlowExpectedError - jest isn't a global, and isn't recognized outside of tests
    if ('undefined' !== typeof jest) {
      warnIfUnmockedScheduler(current$1);
      warnIfNotScopedWithMatchingAct(current$1);
    }
  }

  var lane = requestUpdateLane(current$1);

  var context = getContextForSubtree(parentComponent);

  if (container.context === null) {
    container.context = context;
  } else {
    container.pendingContext = context;
  }

  {
    if (isRendering && current !== null && !didWarnAboutNestedUpdates) {
      didWarnAboutNestedUpdates = true;

      error('Render methods should be a pure function of props and state; ' + 'triggering nested component updates from render is not allowed. ' + 'If necessary, trigger nested updates in componentDidUpdate.\n\n' + 'Check the render method of %s.', getComponentName(current.type) || 'Unknown');
    }
  }

  var update = createUpdate(eventTime, lane); // Caution: React DevTools currently depends on this property
  // being called "element".

  update.payload = {
    element: element
  };
  callback = callback === undefined ? null : callback;

  if (callback !== null) {
    {
      if (typeof callback !== 'function') {
        error('render(...): Expected the last optional `callback` argument to be a ' + 'function. Instead received: %s.', callback);
      }
    }

    update.callback = callback;
  }

  enqueueUpdate(current$1, update);
  scheduleUpdateOnFiber(current$1, lane, eventTime);
  return lane;
}
function getPublicRootInstance(container) {
  var containerFiber = container.current;

  if (!containerFiber.child) {
    return null;
  }

  switch (containerFiber.child.tag) {
    case HostComponent:
      return getPublicInstance(containerFiber.child.stateNode);

    default:
      return containerFiber.child.stateNode;
  }
}

function markRetryLaneImpl(fiber, retryLane) {
  var suspenseState = fiber.memoizedState;

  if (suspenseState !== null && suspenseState.dehydrated !== null) {
    suspenseState.retryLane = higherPriorityLane(suspenseState.retryLane, retryLane);
  }
} // Increases the priority of thennables when they resolve within this boundary.


function markRetryLaneIfNotHydrated(fiber, retryLane) {
  markRetryLaneImpl(fiber, retryLane);
  var alternate = fiber.alternate;

  if (alternate) {
    markRetryLaneImpl(alternate, retryLane);
  }
}

function attemptUserBlockingHydration$1(fiber) {
  if (fiber.tag !== SuspenseComponent) {
    // We ignore HostRoots here because we can't increase
    // their priority and they should not suspend on I/O,
    // since you have to wrap anything that might suspend in
    // Suspense.
    return;
  }

  var eventTime = requestEventTime();
  var lane = InputDiscreteHydrationLane;
  scheduleUpdateOnFiber(fiber, lane, eventTime);
  markRetryLaneIfNotHydrated(fiber, lane);
}
function attemptContinuousHydration$1(fiber) {
  if (fiber.tag !== SuspenseComponent) {
    // We ignore HostRoots here because we can't increase
    // their priority and they should not suspend on I/O,
    // since you have to wrap anything that might suspend in
    // Suspense.
    return;
  }

  var eventTime = requestEventTime();
  var lane = SelectiveHydrationLane;
  scheduleUpdateOnFiber(fiber, lane, eventTime);
  markRetryLaneIfNotHydrated(fiber, lane);
}
function attemptHydrationAtCurrentPriority$1(fiber) {
  if (fiber.tag !== SuspenseComponent) {
    // We ignore HostRoots here because we can't increase
    // their priority other than synchronously flush it.
    return;
  }

  var eventTime = requestEventTime();
  var lane = requestUpdateLane(fiber);
  scheduleUpdateOnFiber(fiber, lane, eventTime);
  markRetryLaneIfNotHydrated(fiber, lane);
}
function runWithPriority$2(priority, fn) {

  try {
    setCurrentUpdateLanePriority(priority);
    return fn();
  } finally {
  }
}
function findHostInstanceWithNoPortals(fiber) {
  var hostFiber = findCurrentHostFiberWithNoPortals(fiber);

  if (hostFiber === null) {
    return null;
  }

  if (hostFiber.tag === FundamentalComponent) {
    return hostFiber.stateNode.instance;
  }

  return hostFiber.stateNode;
}

var shouldSuspendImpl = function (fiber) {
  return false;
};

function shouldSuspend(fiber) {
  return shouldSuspendImpl(fiber);
}
var overrideHookState = null;
var overrideHookStateDeletePath = null;
var overrideHookStateRenamePath = null;
var overrideProps = null;
var overridePropsDeletePath = null;
var overridePropsRenamePath = null;
var scheduleUpdate = null;
var setSuspenseHandler = null;

{
  var copyWithDeleteImpl = function (obj, path, index) {
    var key = path[index];
    var updated = Array.isArray(obj) ? obj.slice() : _assign({}, obj);

    if (index + 1 === path.length) {
      if (Array.isArray(updated)) {
        updated.splice(key, 1);
      } else {
        delete updated[key];
      }

      return updated;
    } // $FlowFixMe number or string is fine here


    updated[key] = copyWithDeleteImpl(obj[key], path, index + 1);
    return updated;
  };

  var copyWithDelete = function (obj, path) {
    return copyWithDeleteImpl(obj, path, 0);
  };

  var copyWithRenameImpl = function (obj, oldPath, newPath, index) {
    var oldKey = oldPath[index];
    var updated = Array.isArray(obj) ? obj.slice() : _assign({}, obj);

    if (index + 1 === oldPath.length) {
      var newKey = newPath[index]; // $FlowFixMe number or string is fine here

      updated[newKey] = updated[oldKey];

      if (Array.isArray(updated)) {
        updated.splice(oldKey, 1);
      } else {
        delete updated[oldKey];
      }
    } else {
      // $FlowFixMe number or string is fine here
      updated[oldKey] = copyWithRenameImpl( // $FlowFixMe number or string is fine here
      obj[oldKey], oldPath, newPath, index + 1);
    }

    return updated;
  };

  var copyWithRename = function (obj, oldPath, newPath) {
    if (oldPath.length !== newPath.length) {
      warn('copyWithRename() expects paths of the same length');

      return;
    } else {
      for (var i = 0; i < newPath.length - 1; i++) {
        if (oldPath[i] !== newPath[i]) {
          warn('copyWithRename() expects paths to be the same except for the deepest key');

          return;
        }
      }
    }

    return copyWithRenameImpl(obj, oldPath, newPath, 0);
  };

  var copyWithSetImpl = function (obj, path, index, value) {
    if (index >= path.length) {
      return value;
    }

    var key = path[index];
    var updated = Array.isArray(obj) ? obj.slice() : _assign({}, obj); // $FlowFixMe number or string is fine here

    updated[key] = copyWithSetImpl(obj[key], path, index + 1, value);
    return updated;
  };

  var copyWithSet = function (obj, path, value) {
    return copyWithSetImpl(obj, path, 0, value);
  };

  var findHook = function (fiber, id) {
    // For now, the "id" of stateful hooks is just the stateful hook index.
    // This may change in the future with e.g. nested hooks.
    var currentHook = fiber.memoizedState;

    while (currentHook !== null && id > 0) {
      currentHook = currentHook.next;
      id--;
    }

    return currentHook;
  }; // Support DevTools editable values for useState and useReducer.


  overrideHookState = function (fiber, id, path, value) {
    var hook = findHook(fiber, id);

    if (hook !== null) {
      var newState = copyWithSet(hook.memoizedState, path, value);
      hook.memoizedState = newState;
      hook.baseState = newState; // We aren't actually adding an update to the queue,
      // because there is no update we can add for useReducer hooks that won't trigger an error.
      // (There's no appropriate action type for DevTools overrides.)
      // As a result though, React will see the scheduled update as a noop and bailout.
      // Shallow cloning props works as a workaround for now to bypass the bailout check.

      fiber.memoizedProps = _assign({}, fiber.memoizedProps);
      scheduleUpdateOnFiber(fiber, SyncLane, NoTimestamp);
    }
  };

  overrideHookStateDeletePath = function (fiber, id, path) {
    var hook = findHook(fiber, id);

    if (hook !== null) {
      var newState = copyWithDelete(hook.memoizedState, path);
      hook.memoizedState = newState;
      hook.baseState = newState; // We aren't actually adding an update to the queue,
      // because there is no update we can add for useReducer hooks that won't trigger an error.
      // (There's no appropriate action type for DevTools overrides.)
      // As a result though, React will see the scheduled update as a noop and bailout.
      // Shallow cloning props works as a workaround for now to bypass the bailout check.

      fiber.memoizedProps = _assign({}, fiber.memoizedProps);
      scheduleUpdateOnFiber(fiber, SyncLane, NoTimestamp);
    }
  };

  overrideHookStateRenamePath = function (fiber, id, oldPath, newPath) {
    var hook = findHook(fiber, id);

    if (hook !== null) {
      var newState = copyWithRename(hook.memoizedState, oldPath, newPath);
      hook.memoizedState = newState;
      hook.baseState = newState; // We aren't actually adding an update to the queue,
      // because there is no update we can add for useReducer hooks that won't trigger an error.
      // (There's no appropriate action type for DevTools overrides.)
      // As a result though, React will see the scheduled update as a noop and bailout.
      // Shallow cloning props works as a workaround for now to bypass the bailout check.

      fiber.memoizedProps = _assign({}, fiber.memoizedProps);
      scheduleUpdateOnFiber(fiber, SyncLane, NoTimestamp);
    }
  }; // Support DevTools props for function components, forwardRef, memo, host components, etc.


  overrideProps = function (fiber, path, value) {
    fiber.pendingProps = copyWithSet(fiber.memoizedProps, path, value);

    if (fiber.alternate) {
      fiber.alternate.pendingProps = fiber.pendingProps;
    }

    scheduleUpdateOnFiber(fiber, SyncLane, NoTimestamp);
  };

  overridePropsDeletePath = function (fiber, path) {
    fiber.pendingProps = copyWithDelete(fiber.memoizedProps, path);

    if (fiber.alternate) {
      fiber.alternate.pendingProps = fiber.pendingProps;
    }

    scheduleUpdateOnFiber(fiber, SyncLane, NoTimestamp);
  };

  overridePropsRenamePath = function (fiber, oldPath, newPath) {
    fiber.pendingProps = copyWithRename(fiber.memoizedProps, oldPath, newPath);

    if (fiber.alternate) {
      fiber.alternate.pendingProps = fiber.pendingProps;
    }

    scheduleUpdateOnFiber(fiber, SyncLane, NoTimestamp);
  };

  scheduleUpdate = function (fiber) {
    scheduleUpdateOnFiber(fiber, SyncLane, NoTimestamp);
  };

  setSuspenseHandler = function (newShouldSuspendImpl) {
    shouldSuspendImpl = newShouldSuspendImpl;
  };
}

function findHostInstanceByFiber(fiber) {
  var hostFiber = findCurrentHostFiber(fiber);

  if (hostFiber === null) {
    return null;
  }

  return hostFiber.stateNode;
}

function emptyFindFiberByHostInstance(instance) {
  return null;
}

function getCurrentFiberForDevTools() {
  return current;
}

function injectIntoDevTools(devToolsConfig) {
  var findFiberByHostInstance = devToolsConfig.findFiberByHostInstance;
  var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;
  return injectInternals({
    bundleType: devToolsConfig.bundleType,
    version: devToolsConfig.version,
    rendererPackageName: devToolsConfig.rendererPackageName,
    rendererConfig: devToolsConfig.rendererConfig,
    overrideHookState: overrideHookState,
    overrideHookStateDeletePath: overrideHookStateDeletePath,
    overrideHookStateRenamePath: overrideHookStateRenamePath,
    overrideProps: overrideProps,
    overridePropsDeletePath: overridePropsDeletePath,
    overridePropsRenamePath: overridePropsRenamePath,
    setSuspenseHandler: setSuspenseHandler,
    scheduleUpdate: scheduleUpdate,
    currentDispatcherRef: ReactCurrentDispatcher,
    findHostInstanceByFiber: findHostInstanceByFiber,
    findFiberByHostInstance: findFiberByHostInstance || emptyFindFiberByHostInstance,
    // React Refresh
    findHostInstancesForRefresh:  findHostInstancesForRefresh ,
    scheduleRefresh:  scheduleRefresh ,
    scheduleRoot:  scheduleRoot ,
    setRefreshHandler:  setRefreshHandler ,
    // Enables DevTools to append owner stacks to error messages in DEV mode.
    getCurrentFiber:  getCurrentFiberForDevTools 
  });
}

function ReactDOMRoot(container, options) {
  this._internalRoot = createRootImpl(container, ConcurrentRoot, options);
}

function ReactDOMBlockingRoot(container, tag, options) {
  this._internalRoot = createRootImpl(container, tag, options);
}

ReactDOMRoot.prototype.render = ReactDOMBlockingRoot.prototype.render = function (children) {
  var root = this._internalRoot;

  {
    if (typeof arguments[1] === 'function') {
      error('render(...): does not support the second callback argument. ' + 'To execute a side effect after rendering, declare it in a component body with useEffect().');
    }

    var container = root.containerInfo;

    if (container.nodeType !== COMMENT_NODE) {
      var hostInstance = findHostInstanceWithNoPortals(root.current);

      if (hostInstance) {
        if (hostInstance.parentNode !== container) {
          error('render(...): It looks like the React-rendered content of the ' + 'root container was removed without using React. This is not ' + 'supported and will cause errors. Instead, call ' + "root.unmount() to empty a root's container.");
        }
      }
    }
  }

  updateContainer(children, root, null, null);
};

ReactDOMRoot.prototype.unmount = ReactDOMBlockingRoot.prototype.unmount = function () {
  {
    if (typeof arguments[0] === 'function') {
      error('unmount(...): does not support a callback argument. ' + 'To execute a side effect after rendering, declare it in a component body with useEffect().');
    }
  }

  var root = this._internalRoot;
  var container = root.containerInfo;
  updateContainer(null, root, null, function () {
    unmarkContainerAsRoot(container);
  });
};

function createRootImpl(container, tag, options) {
  // Tag is either LegacyRoot or Concurrent Root
  var hydrate = options != null && options.hydrate === true;
  var hydrationCallbacks = options != null && options.hydrationOptions || null;
  var mutableSources = options != null && options.hydrationOptions != null && options.hydrationOptions.mutableSources || null;
  var root = createContainer(container, tag, hydrate);
  markContainerAsRoot(root.current, container);
  var containerNodeType = container.nodeType;

  {
    var rootContainerElement = container.nodeType === COMMENT_NODE ? container.parentNode : container;
    listenToAllSupportedEvents(rootContainerElement);
  }

  if (mutableSources) {
    for (var i = 0; i < mutableSources.length; i++) {
      var mutableSource = mutableSources[i];
      registerMutableSourceForHydration(root, mutableSource);
    }
  }

  return root;
}
function createLegacyRoot(container, options) {
  return new ReactDOMBlockingRoot(container, LegacyRoot, options);
}
function isValidContainer(node) {
  return !!(node && (node.nodeType === ELEMENT_NODE || node.nodeType === DOCUMENT_NODE || node.nodeType === DOCUMENT_FRAGMENT_NODE || node.nodeType === COMMENT_NODE && node.nodeValue === ' react-mount-point-unstable '));
}

var ReactCurrentOwner$3 = ReactSharedInternals.ReactCurrentOwner;
var topLevelUpdateWarnings;
var warnedAboutHydrateAPI = false;

{
  topLevelUpdateWarnings = function (container) {
    if (container._reactRootContainer && container.nodeType !== COMMENT_NODE) {
      var hostInstance = findHostInstanceWithNoPortals(container._reactRootContainer._internalRoot.current);

      if (hostInstance) {
        if (hostInstance.parentNode !== container) {
          error('render(...): It looks like the React-rendered content of this ' + 'container was removed without using React. This is not ' + 'supported and will cause errors. Instead, call ' + 'ReactDOM.unmountComponentAtNode to empty a container.');
        }
      }
    }

    var isRootRenderedBySomeReact = !!container._reactRootContainer;
    var rootEl = getReactRootElementInContainer(container);
    var hasNonRootReactChild = !!(rootEl && getInstanceFromNode(rootEl));

    if (hasNonRootReactChild && !isRootRenderedBySomeReact) {
      error('render(...): Replacing React-rendered children with a new root ' + 'component. If you intended to update the children of this node, ' + 'you should instead have the existing children update their state ' + 'and render the new components instead of calling ReactDOM.render.');
    }

    if (container.nodeType === ELEMENT_NODE && container.tagName && container.tagName.toUpperCase() === 'BODY') {
      error('render(): Rendering components directly into document.body is ' + 'discouraged, since its children are often manipulated by third-party ' + 'scripts and browser extensions. This may lead to subtle ' + 'reconciliation issues. Try rendering into a container element created ' + 'for your app.');
    }
  };
}

function getReactRootElementInContainer(container) {
  if (!container) {
    return null;
  }

  if (container.nodeType === DOCUMENT_NODE) {
    return container.documentElement;
  } else {
    return container.firstChild;
  }
}

function shouldHydrateDueToLegacyHeuristic(container) {
  var rootElement = getReactRootElementInContainer(container);
  return !!(rootElement && rootElement.nodeType === ELEMENT_NODE && rootElement.hasAttribute(ROOT_ATTRIBUTE_NAME));
}

function legacyCreateRootFromDOMContainer(container, forceHydrate) {
  var shouldHydrate = forceHydrate || shouldHydrateDueToLegacyHeuristic(container); // First clear any existing content.

  if (!shouldHydrate) {
    var warned = false;
    var rootSibling;

    while (rootSibling = container.lastChild) {
      {
        if (!warned && rootSibling.nodeType === ELEMENT_NODE && rootSibling.hasAttribute(ROOT_ATTRIBUTE_NAME)) {
          warned = true;

          error('render(): Target node has markup rendered by React, but there ' + 'are unrelated nodes as well. This is most commonly caused by ' + 'white-space inserted around server-rendered markup.');
        }
      }

      container.removeChild(rootSibling);
    }
  }

  {
    if (shouldHydrate && !forceHydrate && !warnedAboutHydrateAPI) {
      warnedAboutHydrateAPI = true;

      warn('render(): Calling ReactDOM.render() to hydrate server-rendered markup ' + 'will stop working in React v18. Replace the ReactDOM.render() call ' + 'with ReactDOM.hydrate() if you want React to attach to the server HTML.');
    }
  }

  return createLegacyRoot(container, shouldHydrate ? {
    hydrate: true
  } : undefined);
}

function warnOnInvalidCallback$1(callback, callerName) {
  {
    if (callback !== null && typeof callback !== 'function') {
      error('%s(...): Expected the last optional `callback` argument to be a ' + 'function. Instead received: %s.', callerName, callback);
    }
  }
}

function legacyRenderSubtreeIntoContainer(parentComponent, children, container, forceHydrate, callback) {
  {
    topLevelUpdateWarnings(container);
    warnOnInvalidCallback$1(callback === undefined ? null : callback, 'render');
  } // TODO: Without `any` type, Flow says "Property cannot be accessed on any
  // member of intersection type." Whyyyyyy.


  var root = container._reactRootContainer;
  var fiberRoot;

  if (!root) {
    // Initial mount
    root = container._reactRootContainer = legacyCreateRootFromDOMContainer(container, forceHydrate);
    fiberRoot = root._internalRoot;

    if (typeof callback === 'function') {
      var originalCallback = callback;

      callback = function () {
        var instance = getPublicRootInstance(fiberRoot);
        originalCallback.call(instance);
      };
    } // Initial mount should not be batched.


    unbatchedUpdates(function () {
      updateContainer(children, fiberRoot, parentComponent, callback);
    });
  } else {
    fiberRoot = root._internalRoot;

    if (typeof callback === 'function') {
      var _originalCallback = callback;

      callback = function () {
        var instance = getPublicRootInstance(fiberRoot);

        _originalCallback.call(instance);
      };
    } // Update


    updateContainer(children, fiberRoot, parentComponent, callback);
  }

  return getPublicRootInstance(fiberRoot);
}

function findDOMNode(componentOrElement) {
  {
    var owner = ReactCurrentOwner$3.current;

    if (owner !== null && owner.stateNode !== null) {
      var warnedAboutRefsInRender = owner.stateNode._warnedAboutRefsInRender;

      if (!warnedAboutRefsInRender) {
        error('%s is accessing findDOMNode inside its render(). ' + 'render() should be a pure function of props and state. It should ' + 'never access something that requires stale data from the previous ' + 'render, such as refs. Move this logic to componentDidMount and ' + 'componentDidUpdate instead.', getComponentName(owner.type) || 'A component');
      }

      owner.stateNode._warnedAboutRefsInRender = true;
    }
  }

  if (componentOrElement == null) {
    return null;
  }

  if (componentOrElement.nodeType === ELEMENT_NODE) {
    return componentOrElement;
  }

  {
    return findHostInstanceWithWarning(componentOrElement, 'findDOMNode');
  }
}
function hydrate(element, container, callback) {
  if (!isValidContainer(container)) {
    {
      throw Error( "Target container is not a DOM element." );
    }
  }

  {
    var isModernRoot = isContainerMarkedAsRoot(container) && container._reactRootContainer === undefined;

    if (isModernRoot) {
      error('You are calling ReactDOM.hydrate() on a container that was previously ' + 'passed to ReactDOM.createRoot(). This is not supported. ' + 'Did you mean to call createRoot(container, {hydrate: true}).render(element)?');
    }
  } // TODO: throw or warn if we couldn't hydrate?


  return legacyRenderSubtreeIntoContainer(null, element, container, true, callback);
}
function render(element, container, callback) {
  if (!isValidContainer(container)) {
    {
      throw Error( "Target container is not a DOM element." );
    }
  }

  {
    var isModernRoot = isContainerMarkedAsRoot(container) && container._reactRootContainer === undefined;

    if (isModernRoot) {
      error('You are calling ReactDOM.render() on a container that was previously ' + 'passed to ReactDOM.createRoot(). This is not supported. ' + 'Did you mean to call root.render(element)?');
    }
  }

  return legacyRenderSubtreeIntoContainer(null, element, container, false, callback);
}
function unstable_renderSubtreeIntoContainer(parentComponent, element, containerNode, callback) {
  if (!isValidContainer(containerNode)) {
    {
      throw Error( "Target container is not a DOM element." );
    }
  }

  if (!(parentComponent != null && has(parentComponent))) {
    {
      throw Error( "parentComponent must be a valid React Component" );
    }
  }

  return legacyRenderSubtreeIntoContainer(parentComponent, element, containerNode, false, callback);
}
function unmountComponentAtNode(container) {
  if (!isValidContainer(container)) {
    {
      throw Error( "unmountComponentAtNode(...): Target container is not a DOM element." );
    }
  }

  {
    var isModernRoot = isContainerMarkedAsRoot(container) && container._reactRootContainer === undefined;

    if (isModernRoot) {
      error('You are calling ReactDOM.unmountComponentAtNode() on a container that was previously ' + 'passed to ReactDOM.createRoot(). This is not supported. Did you mean to call root.unmount()?');
    }
  }

  if (container._reactRootContainer) {
    {
      var rootEl = getReactRootElementInContainer(container);
      var renderedByDifferentReact = rootEl && !getInstanceFromNode(rootEl);

      if (renderedByDifferentReact) {
        error("unmountComponentAtNode(): The node you're attempting to unmount " + 'was rendered by another copy of React.');
      }
    } // Unmount should not be batched.


    unbatchedUpdates(function () {
      legacyRenderSubtreeIntoContainer(null, null, container, false, function () {
        // $FlowFixMe This should probably use `delete container._reactRootContainer`
        container._reactRootContainer = null;
        unmarkContainerAsRoot(container);
      });
    }); // If you call unmountComponentAtNode twice in quick succession, you'll
    // get `true` twice. That's probably fine?

    return true;
  } else {
    {
      var _rootEl = getReactRootElementInContainer(container);

      var hasNonRootReactChild = !!(_rootEl && getInstanceFromNode(_rootEl)); // Check if the container itself is a React root node.

      var isContainerReactRoot = container.nodeType === ELEMENT_NODE && isValidContainer(container.parentNode) && !!container.parentNode._reactRootContainer;

      if (hasNonRootReactChild) {
        error("unmountComponentAtNode(): The node you're attempting to unmount " + 'was rendered by React and is not a top-level container. %s', isContainerReactRoot ? 'You may have accidentally passed in a React root node instead ' + 'of its container.' : 'Instead, have the parent component update its state and ' + 'rerender in order to remove this component.');
      }
    }

    return false;
  }
}

setAttemptUserBlockingHydration(attemptUserBlockingHydration$1);
setAttemptContinuousHydration(attemptContinuousHydration$1);
setAttemptHydrationAtCurrentPriority(attemptHydrationAtCurrentPriority$1);
setAttemptHydrationAtPriority(runWithPriority$2);
var didWarnAboutUnstableCreatePortal = false;

{
  if (typeof Map !== 'function' || // $FlowIssue Flow incorrectly thinks Map has no prototype
  Map.prototype == null || typeof Map.prototype.forEach !== 'function' || typeof Set !== 'function' || // $FlowIssue Flow incorrectly thinks Set has no prototype
  Set.prototype == null || typeof Set.prototype.clear !== 'function' || typeof Set.prototype.forEach !== 'function') {
    error('React depends on Map and Set built-in types. Make sure that you load a ' + 'polyfill in older browsers. https://reactjs.org/link/react-polyfills');
  }
}

setRestoreImplementation(restoreControlledState$3);
setBatchingImplementation(batchedUpdates$1, discreteUpdates$1, flushDiscreteUpdates, batchedEventUpdates$1);

function createPortal$1(children, container) {
  var key = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

  if (!isValidContainer(container)) {
    {
      throw Error( "Target container is not a DOM element." );
    }
  } // TODO: pass ReactDOM portal implementation as third argument
  // $FlowFixMe The Flow type is opaque but there's no way to actually create it.


  return createPortal(children, container, null, key);
}

function renderSubtreeIntoContainer(parentComponent, element, containerNode, callback) {

  return unstable_renderSubtreeIntoContainer(parentComponent, element, containerNode, callback);
}

function unstable_createPortal(children, container) {
  var key = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

  {
    if (!didWarnAboutUnstableCreatePortal) {
      didWarnAboutUnstableCreatePortal = true;

      warn('The ReactDOM.unstable_createPortal() alias has been deprecated, ' + 'and will be removed in React 18+. Update your code to use ' + 'ReactDOM.createPortal() instead. It has the exact same API, ' + 'but without the "unstable_" prefix.');
    }
  }

  return createPortal$1(children, container, key);
}

var Internals = {
  // Keep in sync with ReactTestUtils.js, and ReactTestUtilsAct.js.
  // This is an array for better minification.
  Events: [getInstanceFromNode, getNodeFromInstance, getFiberCurrentPropsFromNode, enqueueStateRestore, restoreStateIfNeeded, flushPassiveEffects, // TODO: This is related to `act`, not events. Move to separate key?
  IsThisRendererActing]
};
var foundDevTools = injectIntoDevTools({
  findFiberByHostInstance: getClosestInstanceFromNode,
  bundleType:  1 ,
  version: ReactVersion,
  rendererPackageName: 'react-dom'
});

{
  if (!foundDevTools && canUseDOM && window.top === window.self) {
    // If we're in Chrome or Firefox, provide a download link if not installed.
    if (navigator.userAgent.indexOf('Chrome') > -1 && navigator.userAgent.indexOf('Edge') === -1 || navigator.userAgent.indexOf('Firefox') > -1) {
      var protocol = window.location.protocol; // Don't warn in exotic cases like chrome-extension://.

      if (/^(https?|file):$/.test(protocol)) {
        // eslint-disable-next-line react-internal/no-production-logging
        console.info('%cDownload the React DevTools ' + 'for a better development experience: ' + 'https://reactjs.org/link/react-devtools' + (protocol === 'file:' ? '\nYou might need to use a local HTTP server (instead of file://): ' + 'https://reactjs.org/link/react-devtools-faq' : ''), 'font-weight:bold');
      }
    }
  }
}

exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = Internals;
exports.createPortal = createPortal$1;
exports.findDOMNode = findDOMNode;
exports.flushSync = flushSync;
exports.hydrate = hydrate;
exports.render = render;
exports.unmountComponentAtNode = unmountComponentAtNode;
exports.unstable_batchedUpdates = batchedUpdates$1;
exports.unstable_createPortal = unstable_createPortal;
exports.unstable_renderSubtreeIntoContainer = renderSubtreeIntoContainer;
exports.version = ReactVersion;
  })();
}


/***/ }),

/***/ "./node_modules/react-dom/index.js":
/*!*****************************************!*\
  !*** ./node_modules/react-dom/index.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


function checkDCE() {
  /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */
  if (
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === 'undefined' ||
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== 'function'
  ) {
    return;
  }
  if (true) {
    // This branch is unreachable because this function is only called
    // in production, but the condition is true only in development.
    // Therefore if the branch is still here, dead code elimination wasn't
    // properly applied.
    // Don't change the message. React DevTools relies on it. Also make sure
    // this message doesn't occur elsewhere in this function, or it will cause
    // a false positive.
    throw new Error('^_^');
  }
  try {
    // Verify that the code above has been dead code eliminated (DCE'd).
    __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
  } catch (err) {
    // DevTools shouldn't crash React, no matter what.
    // We should still report in case we break this code.
    console.error(err);
  }
}

if (false) {} else {
  module.exports = __webpack_require__(/*! ./cjs/react-dom.development.js */ "./node_modules/react-dom/cjs/react-dom.development.js");
}


/***/ }),

/***/ "./node_modules/react/cjs/react.development.js":
/*!*****************************************************!*\
  !*** ./node_modules/react/cjs/react.development.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/** @license React v17.0.2
 * react.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



if (true) {
  (function() {
'use strict';

var _assign = __webpack_require__(/*! object-assign */ "./node_modules/object-assign/index.js");

// TODO: this is special because it gets imported during build.
var ReactVersion = '17.0.2';

// ATTENTION
// When adding new symbols to this file,
// Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'
// The Symbol used to tag the ReactElement-like types. If there is no native Symbol
// nor polyfill, then a plain number is used for performance.
var REACT_ELEMENT_TYPE = 0xeac7;
var REACT_PORTAL_TYPE = 0xeaca;
exports.Fragment = 0xeacb;
exports.StrictMode = 0xeacc;
exports.Profiler = 0xead2;
var REACT_PROVIDER_TYPE = 0xeacd;
var REACT_CONTEXT_TYPE = 0xeace;
var REACT_FORWARD_REF_TYPE = 0xead0;
exports.Suspense = 0xead1;
var REACT_SUSPENSE_LIST_TYPE = 0xead8;
var REACT_MEMO_TYPE = 0xead3;
var REACT_LAZY_TYPE = 0xead4;
var REACT_BLOCK_TYPE = 0xead9;
var REACT_SERVER_BLOCK_TYPE = 0xeada;
var REACT_FUNDAMENTAL_TYPE = 0xead5;
var REACT_SCOPE_TYPE = 0xead7;
var REACT_OPAQUE_ID_TYPE = 0xeae0;
var REACT_DEBUG_TRACING_MODE_TYPE = 0xeae1;
var REACT_OFFSCREEN_TYPE = 0xeae2;
var REACT_LEGACY_HIDDEN_TYPE = 0xeae3;

if (typeof Symbol === 'function' && Symbol.for) {
  var symbolFor = Symbol.for;
  REACT_ELEMENT_TYPE = symbolFor('react.element');
  REACT_PORTAL_TYPE = symbolFor('react.portal');
  exports.Fragment = symbolFor('react.fragment');
  exports.StrictMode = symbolFor('react.strict_mode');
  exports.Profiler = symbolFor('react.profiler');
  REACT_PROVIDER_TYPE = symbolFor('react.provider');
  REACT_CONTEXT_TYPE = symbolFor('react.context');
  REACT_FORWARD_REF_TYPE = symbolFor('react.forward_ref');
  exports.Suspense = symbolFor('react.suspense');
  REACT_SUSPENSE_LIST_TYPE = symbolFor('react.suspense_list');
  REACT_MEMO_TYPE = symbolFor('react.memo');
  REACT_LAZY_TYPE = symbolFor('react.lazy');
  REACT_BLOCK_TYPE = symbolFor('react.block');
  REACT_SERVER_BLOCK_TYPE = symbolFor('react.server.block');
  REACT_FUNDAMENTAL_TYPE = symbolFor('react.fundamental');
  REACT_SCOPE_TYPE = symbolFor('react.scope');
  REACT_OPAQUE_ID_TYPE = symbolFor('react.opaque.id');
  REACT_DEBUG_TRACING_MODE_TYPE = symbolFor('react.debug_trace_mode');
  REACT_OFFSCREEN_TYPE = symbolFor('react.offscreen');
  REACT_LEGACY_HIDDEN_TYPE = symbolFor('react.legacy_hidden');
}

var MAYBE_ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
var FAUX_ITERATOR_SYMBOL = '@@iterator';
function getIteratorFn(maybeIterable) {
  if (maybeIterable === null || typeof maybeIterable !== 'object') {
    return null;
  }

  var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];

  if (typeof maybeIterator === 'function') {
    return maybeIterator;
  }

  return null;
}

/**
 * Keeps track of the current dispatcher.
 */
var ReactCurrentDispatcher = {
  /**
   * @internal
   * @type {ReactComponent}
   */
  current: null
};

/**
 * Keeps track of the current batch's configuration such as how long an update
 * should suspend for if it needs to.
 */
var ReactCurrentBatchConfig = {
  transition: 0
};

/**
 * Keeps track of the current owner.
 *
 * The current owner is the component who should own any components that are
 * currently being constructed.
 */
var ReactCurrentOwner = {
  /**
   * @internal
   * @type {ReactComponent}
   */
  current: null
};

var ReactDebugCurrentFrame = {};
var currentExtraStackFrame = null;
function setExtraStackFrame(stack) {
  {
    currentExtraStackFrame = stack;
  }
}

{
  ReactDebugCurrentFrame.setExtraStackFrame = function (stack) {
    {
      currentExtraStackFrame = stack;
    }
  }; // Stack implementation injected by the current renderer.


  ReactDebugCurrentFrame.getCurrentStack = null;

  ReactDebugCurrentFrame.getStackAddendum = function () {
    var stack = ''; // Add an extra top frame while an element is being validated

    if (currentExtraStackFrame) {
      stack += currentExtraStackFrame;
    } // Delegate to the injected renderer-specific implementation


    var impl = ReactDebugCurrentFrame.getCurrentStack;

    if (impl) {
      stack += impl() || '';
    }

    return stack;
  };
}

/**
 * Used by act() to track whether you're inside an act() scope.
 */
var IsSomeRendererActing = {
  current: false
};

var ReactSharedInternals = {
  ReactCurrentDispatcher: ReactCurrentDispatcher,
  ReactCurrentBatchConfig: ReactCurrentBatchConfig,
  ReactCurrentOwner: ReactCurrentOwner,
  IsSomeRendererActing: IsSomeRendererActing,
  // Used by renderers to avoid bundling object-assign twice in UMD bundles:
  assign: _assign
};

{
  ReactSharedInternals.ReactDebugCurrentFrame = ReactDebugCurrentFrame;
}

// by calls to these methods by a Babel plugin.
//
// In PROD (or in packages without access to React internals),
// they are left as they are instead.

function warn(format) {
  {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    printWarning('warn', format, args);
  }
}
function error(format) {
  {
    for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
      args[_key2 - 1] = arguments[_key2];
    }

    printWarning('error', format, args);
  }
}

function printWarning(level, format, args) {
  // When changing this logic, you might want to also
  // update consoleWithStackDev.www.js as well.
  {
    var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
    var stack = ReactDebugCurrentFrame.getStackAddendum();

    if (stack !== '') {
      format += '%s';
      args = args.concat([stack]);
    }

    var argsWithFormat = args.map(function (item) {
      return '' + item;
    }); // Careful: RN currently depends on this prefix

    argsWithFormat.unshift('Warning: ' + format); // We intentionally don't use spread (or .apply) directly because it
    // breaks IE9: https://github.com/facebook/react/issues/13610
    // eslint-disable-next-line react-internal/no-production-logging

    Function.prototype.apply.call(console[level], console, argsWithFormat);
  }
}

var didWarnStateUpdateForUnmountedComponent = {};

function warnNoop(publicInstance, callerName) {
  {
    var _constructor = publicInstance.constructor;
    var componentName = _constructor && (_constructor.displayName || _constructor.name) || 'ReactClass';
    var warningKey = componentName + "." + callerName;

    if (didWarnStateUpdateForUnmountedComponent[warningKey]) {
      return;
    }

    error("Can't call %s on a component that is not yet mounted. " + 'This is a no-op, but it might indicate a bug in your application. ' + 'Instead, assign to `this.state` directly or define a `state = {};` ' + 'class property with the desired state in the %s component.', callerName, componentName);

    didWarnStateUpdateForUnmountedComponent[warningKey] = true;
  }
}
/**
 * This is the abstract API for an update queue.
 */


var ReactNoopUpdateQueue = {
  /**
   * Checks whether or not this composite component is mounted.
   * @param {ReactClass} publicInstance The instance we want to test.
   * @return {boolean} True if mounted, false otherwise.
   * @protected
   * @final
   */
  isMounted: function (publicInstance) {
    return false;
  },

  /**
   * Forces an update. This should only be invoked when it is known with
   * certainty that we are **not** in a DOM transaction.
   *
   * You may want to call this when you know that some deeper aspect of the
   * component's state has changed but `setState` was not called.
   *
   * This will not invoke `shouldComponentUpdate`, but it will invoke
   * `componentWillUpdate` and `componentDidUpdate`.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @param {?function} callback Called after component is updated.
   * @param {?string} callerName name of the calling function in the public API.
   * @internal
   */
  enqueueForceUpdate: function (publicInstance, callback, callerName) {
    warnNoop(publicInstance, 'forceUpdate');
  },

  /**
   * Replaces all of the state. Always use this or `setState` to mutate state.
   * You should treat `this.state` as immutable.
   *
   * There is no guarantee that `this.state` will be immediately updated, so
   * accessing `this.state` after calling this method may return the old value.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @param {object} completeState Next state.
   * @param {?function} callback Called after component is updated.
   * @param {?string} callerName name of the calling function in the public API.
   * @internal
   */
  enqueueReplaceState: function (publicInstance, completeState, callback, callerName) {
    warnNoop(publicInstance, 'replaceState');
  },

  /**
   * Sets a subset of the state. This only exists because _pendingState is
   * internal. This provides a merging strategy that is not available to deep
   * properties which is confusing. TODO: Expose pendingState or don't use it
   * during the merge.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @param {object} partialState Next partial state to be merged with state.
   * @param {?function} callback Called after component is updated.
   * @param {?string} Name of the calling function in the public API.
   * @internal
   */
  enqueueSetState: function (publicInstance, partialState, callback, callerName) {
    warnNoop(publicInstance, 'setState');
  }
};

var emptyObject = {};

{
  Object.freeze(emptyObject);
}
/**
 * Base class helpers for the updating state of a component.
 */


function Component(props, context, updater) {
  this.props = props;
  this.context = context; // If a component has string refs, we will assign a different object later.

  this.refs = emptyObject; // We initialize the default updater but the real one gets injected by the
  // renderer.

  this.updater = updater || ReactNoopUpdateQueue;
}

Component.prototype.isReactComponent = {};
/**
 * Sets a subset of the state. Always use this to mutate
 * state. You should treat `this.state` as immutable.
 *
 * There is no guarantee that `this.state` will be immediately updated, so
 * accessing `this.state` after calling this method may return the old value.
 *
 * There is no guarantee that calls to `setState` will run synchronously,
 * as they may eventually be batched together.  You can provide an optional
 * callback that will be executed when the call to setState is actually
 * completed.
 *
 * When a function is provided to setState, it will be called at some point in
 * the future (not synchronously). It will be called with the up to date
 * component arguments (state, props, context). These values can be different
 * from this.* because your function may be called after receiveProps but before
 * shouldComponentUpdate, and this new state, props, and context will not yet be
 * assigned to this.
 *
 * @param {object|function} partialState Next partial state or function to
 *        produce next partial state to be merged with current state.
 * @param {?function} callback Called after state is updated.
 * @final
 * @protected
 */

Component.prototype.setState = function (partialState, callback) {
  if (!(typeof partialState === 'object' || typeof partialState === 'function' || partialState == null)) {
    {
      throw Error( "setState(...): takes an object of state variables to update or a function which returns an object of state variables." );
    }
  }

  this.updater.enqueueSetState(this, partialState, callback, 'setState');
};
/**
 * Forces an update. This should only be invoked when it is known with
 * certainty that we are **not** in a DOM transaction.
 *
 * You may want to call this when you know that some deeper aspect of the
 * component's state has changed but `setState` was not called.
 *
 * This will not invoke `shouldComponentUpdate`, but it will invoke
 * `componentWillUpdate` and `componentDidUpdate`.
 *
 * @param {?function} callback Called after update is complete.
 * @final
 * @protected
 */


Component.prototype.forceUpdate = function (callback) {
  this.updater.enqueueForceUpdate(this, callback, 'forceUpdate');
};
/**
 * Deprecated APIs. These APIs used to exist on classic React classes but since
 * we would like to deprecate them, we're not going to move them over to this
 * modern base class. Instead, we define a getter that warns if it's accessed.
 */


{
  var deprecatedAPIs = {
    isMounted: ['isMounted', 'Instead, make sure to clean up subscriptions and pending requests in ' + 'componentWillUnmount to prevent memory leaks.'],
    replaceState: ['replaceState', 'Refactor your code to use setState instead (see ' + 'https://github.com/facebook/react/issues/3236).']
  };

  var defineDeprecationWarning = function (methodName, info) {
    Object.defineProperty(Component.prototype, methodName, {
      get: function () {
        warn('%s(...) is deprecated in plain JavaScript React classes. %s', info[0], info[1]);

        return undefined;
      }
    });
  };

  for (var fnName in deprecatedAPIs) {
    if (deprecatedAPIs.hasOwnProperty(fnName)) {
      defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);
    }
  }
}

function ComponentDummy() {}

ComponentDummy.prototype = Component.prototype;
/**
 * Convenience component with default shallow equality check for sCU.
 */

function PureComponent(props, context, updater) {
  this.props = props;
  this.context = context; // If a component has string refs, we will assign a different object later.

  this.refs = emptyObject;
  this.updater = updater || ReactNoopUpdateQueue;
}

var pureComponentPrototype = PureComponent.prototype = new ComponentDummy();
pureComponentPrototype.constructor = PureComponent; // Avoid an extra prototype jump for these methods.

_assign(pureComponentPrototype, Component.prototype);

pureComponentPrototype.isPureReactComponent = true;

// an immutable object with a single mutable value
function createRef() {
  var refObject = {
    current: null
  };

  {
    Object.seal(refObject);
  }

  return refObject;
}

function getWrappedName(outerType, innerType, wrapperName) {
  var functionName = innerType.displayName || innerType.name || '';
  return outerType.displayName || (functionName !== '' ? wrapperName + "(" + functionName + ")" : wrapperName);
}

function getContextName(type) {
  return type.displayName || 'Context';
}

function getComponentName(type) {
  if (type == null) {
    // Host root, text node or just invalid type.
    return null;
  }

  {
    if (typeof type.tag === 'number') {
      error('Received an unexpected object in getComponentName(). ' + 'This is likely a bug in React. Please file an issue.');
    }
  }

  if (typeof type === 'function') {
    return type.displayName || type.name || null;
  }

  if (typeof type === 'string') {
    return type;
  }

  switch (type) {
    case exports.Fragment:
      return 'Fragment';

    case REACT_PORTAL_TYPE:
      return 'Portal';

    case exports.Profiler:
      return 'Profiler';

    case exports.StrictMode:
      return 'StrictMode';

    case exports.Suspense:
      return 'Suspense';

    case REACT_SUSPENSE_LIST_TYPE:
      return 'SuspenseList';
  }

  if (typeof type === 'object') {
    switch (type.$$typeof) {
      case REACT_CONTEXT_TYPE:
        var context = type;
        return getContextName(context) + '.Consumer';

      case REACT_PROVIDER_TYPE:
        var provider = type;
        return getContextName(provider._context) + '.Provider';

      case REACT_FORWARD_REF_TYPE:
        return getWrappedName(type, type.render, 'ForwardRef');

      case REACT_MEMO_TYPE:
        return getComponentName(type.type);

      case REACT_BLOCK_TYPE:
        return getComponentName(type._render);

      case REACT_LAZY_TYPE:
        {
          var lazyComponent = type;
          var payload = lazyComponent._payload;
          var init = lazyComponent._init;

          try {
            return getComponentName(init(payload));
          } catch (x) {
            return null;
          }
        }
    }
  }

  return null;
}

var hasOwnProperty = Object.prototype.hasOwnProperty;
var RESERVED_PROPS = {
  key: true,
  ref: true,
  __self: true,
  __source: true
};
var specialPropKeyWarningShown, specialPropRefWarningShown, didWarnAboutStringRefs;

{
  didWarnAboutStringRefs = {};
}

function hasValidRef(config) {
  {
    if (hasOwnProperty.call(config, 'ref')) {
      var getter = Object.getOwnPropertyDescriptor(config, 'ref').get;

      if (getter && getter.isReactWarning) {
        return false;
      }
    }
  }

  return config.ref !== undefined;
}

function hasValidKey(config) {
  {
    if (hasOwnProperty.call(config, 'key')) {
      var getter = Object.getOwnPropertyDescriptor(config, 'key').get;

      if (getter && getter.isReactWarning) {
        return false;
      }
    }
  }

  return config.key !== undefined;
}

function defineKeyPropWarningGetter(props, displayName) {
  var warnAboutAccessingKey = function () {
    {
      if (!specialPropKeyWarningShown) {
        specialPropKeyWarningShown = true;

        error('%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);
      }
    }
  };

  warnAboutAccessingKey.isReactWarning = true;
  Object.defineProperty(props, 'key', {
    get: warnAboutAccessingKey,
    configurable: true
  });
}

function defineRefPropWarningGetter(props, displayName) {
  var warnAboutAccessingRef = function () {
    {
      if (!specialPropRefWarningShown) {
        specialPropRefWarningShown = true;

        error('%s: `ref` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);
      }
    }
  };

  warnAboutAccessingRef.isReactWarning = true;
  Object.defineProperty(props, 'ref', {
    get: warnAboutAccessingRef,
    configurable: true
  });
}

function warnIfStringRefCannotBeAutoConverted(config) {
  {
    if (typeof config.ref === 'string' && ReactCurrentOwner.current && config.__self && ReactCurrentOwner.current.stateNode !== config.__self) {
      var componentName = getComponentName(ReactCurrentOwner.current.type);

      if (!didWarnAboutStringRefs[componentName]) {
        error('Component "%s" contains the string ref "%s". ' + 'Support for string refs will be removed in a future major release. ' + 'This case cannot be automatically converted to an arrow function. ' + 'We ask you to manually fix this case by using useRef() or createRef() instead. ' + 'Learn more about using refs safely here: ' + 'https://reactjs.org/link/strict-mode-string-ref', componentName, config.ref);

        didWarnAboutStringRefs[componentName] = true;
      }
    }
  }
}
/**
 * Factory method to create a new React element. This no longer adheres to
 * the class pattern, so do not use new to call it. Also, instanceof check
 * will not work. Instead test $$typeof field against Symbol.for('react.element') to check
 * if something is a React Element.
 *
 * @param {*} type
 * @param {*} props
 * @param {*} key
 * @param {string|object} ref
 * @param {*} owner
 * @param {*} self A *temporary* helper to detect places where `this` is
 * different from the `owner` when React.createElement is called, so that we
 * can warn. We want to get rid of owner and replace string `ref`s with arrow
 * functions, and as long as `this` and owner are the same, there will be no
 * change in behavior.
 * @param {*} source An annotation object (added by a transpiler or otherwise)
 * indicating filename, line number, and/or other information.
 * @internal
 */


var ReactElement = function (type, key, ref, self, source, owner, props) {
  var element = {
    // This tag allows us to uniquely identify this as a React Element
    $$typeof: REACT_ELEMENT_TYPE,
    // Built-in properties that belong on the element
    type: type,
    key: key,
    ref: ref,
    props: props,
    // Record the component responsible for creating this element.
    _owner: owner
  };

  {
    // The validation flag is currently mutative. We put it on
    // an external backing store so that we can freeze the whole object.
    // This can be replaced with a WeakMap once they are implemented in
    // commonly used development environments.
    element._store = {}; // To make comparing ReactElements easier for testing purposes, we make
    // the validation flag non-enumerable (where possible, which should
    // include every environment we run tests in), so the test framework
    // ignores it.

    Object.defineProperty(element._store, 'validated', {
      configurable: false,
      enumerable: false,
      writable: true,
      value: false
    }); // self and source are DEV only properties.

    Object.defineProperty(element, '_self', {
      configurable: false,
      enumerable: false,
      writable: false,
      value: self
    }); // Two elements created in two different places should be considered
    // equal for testing purposes and therefore we hide it from enumeration.

    Object.defineProperty(element, '_source', {
      configurable: false,
      enumerable: false,
      writable: false,
      value: source
    });

    if (Object.freeze) {
      Object.freeze(element.props);
      Object.freeze(element);
    }
  }

  return element;
};
/**
 * Create and return a new ReactElement of the given type.
 * See https://reactjs.org/docs/react-api.html#createelement
 */

function createElement(type, config, children) {
  var propName; // Reserved names are extracted

  var props = {};
  var key = null;
  var ref = null;
  var self = null;
  var source = null;

  if (config != null) {
    if (hasValidRef(config)) {
      ref = config.ref;

      {
        warnIfStringRefCannotBeAutoConverted(config);
      }
    }

    if (hasValidKey(config)) {
      key = '' + config.key;
    }

    self = config.__self === undefined ? null : config.__self;
    source = config.__source === undefined ? null : config.__source; // Remaining properties are added to a new props object

    for (propName in config) {
      if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
        props[propName] = config[propName];
      }
    }
  } // Children can be more than one argument, and those are transferred onto
  // the newly allocated props object.


  var childrenLength = arguments.length - 2;

  if (childrenLength === 1) {
    props.children = children;
  } else if (childrenLength > 1) {
    var childArray = Array(childrenLength);

    for (var i = 0; i < childrenLength; i++) {
      childArray[i] = arguments[i + 2];
    }

    {
      if (Object.freeze) {
        Object.freeze(childArray);
      }
    }

    props.children = childArray;
  } // Resolve default props


  if (type && type.defaultProps) {
    var defaultProps = type.defaultProps;

    for (propName in defaultProps) {
      if (props[propName] === undefined) {
        props[propName] = defaultProps[propName];
      }
    }
  }

  {
    if (key || ref) {
      var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;

      if (key) {
        defineKeyPropWarningGetter(props, displayName);
      }

      if (ref) {
        defineRefPropWarningGetter(props, displayName);
      }
    }
  }

  return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);
}
function cloneAndReplaceKey(oldElement, newKey) {
  var newElement = ReactElement(oldElement.type, newKey, oldElement.ref, oldElement._self, oldElement._source, oldElement._owner, oldElement.props);
  return newElement;
}
/**
 * Clone and return a new ReactElement using element as the starting point.
 * See https://reactjs.org/docs/react-api.html#cloneelement
 */

function cloneElement(element, config, children) {
  if (!!(element === null || element === undefined)) {
    {
      throw Error( "React.cloneElement(...): The argument must be a React element, but you passed " + element + "." );
    }
  }

  var propName; // Original props are copied

  var props = _assign({}, element.props); // Reserved names are extracted


  var key = element.key;
  var ref = element.ref; // Self is preserved since the owner is preserved.

  var self = element._self; // Source is preserved since cloneElement is unlikely to be targeted by a
  // transpiler, and the original source is probably a better indicator of the
  // true owner.

  var source = element._source; // Owner will be preserved, unless ref is overridden

  var owner = element._owner;

  if (config != null) {
    if (hasValidRef(config)) {
      // Silently steal the ref from the parent.
      ref = config.ref;
      owner = ReactCurrentOwner.current;
    }

    if (hasValidKey(config)) {
      key = '' + config.key;
    } // Remaining properties override existing props


    var defaultProps;

    if (element.type && element.type.defaultProps) {
      defaultProps = element.type.defaultProps;
    }

    for (propName in config) {
      if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
        if (config[propName] === undefined && defaultProps !== undefined) {
          // Resolve default props
          props[propName] = defaultProps[propName];
        } else {
          props[propName] = config[propName];
        }
      }
    }
  } // Children can be more than one argument, and those are transferred onto
  // the newly allocated props object.


  var childrenLength = arguments.length - 2;

  if (childrenLength === 1) {
    props.children = children;
  } else if (childrenLength > 1) {
    var childArray = Array(childrenLength);

    for (var i = 0; i < childrenLength; i++) {
      childArray[i] = arguments[i + 2];
    }

    props.children = childArray;
  }

  return ReactElement(element.type, key, ref, self, source, owner, props);
}
/**
 * Verifies the object is a ReactElement.
 * See https://reactjs.org/docs/react-api.html#isvalidelement
 * @param {?object} object
 * @return {boolean} True if `object` is a ReactElement.
 * @final
 */

function isValidElement(object) {
  return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
}

var SEPARATOR = '.';
var SUBSEPARATOR = ':';
/**
 * Escape and wrap key so it is safe to use as a reactid
 *
 * @param {string} key to be escaped.
 * @return {string} the escaped key.
 */

function escape(key) {
  var escapeRegex = /[=:]/g;
  var escaperLookup = {
    '=': '=0',
    ':': '=2'
  };
  var escapedString = key.replace(escapeRegex, function (match) {
    return escaperLookup[match];
  });
  return '$' + escapedString;
}
/**
 * TODO: Test that a single child and an array with one item have the same key
 * pattern.
 */


var didWarnAboutMaps = false;
var userProvidedKeyEscapeRegex = /\/+/g;

function escapeUserProvidedKey(text) {
  return text.replace(userProvidedKeyEscapeRegex, '$&/');
}
/**
 * Generate a key string that identifies a element within a set.
 *
 * @param {*} element A element that could contain a manual key.
 * @param {number} index Index that is used if a manual key is not provided.
 * @return {string}
 */


function getElementKey(element, index) {
  // Do some typechecking here since we call this blindly. We want to ensure
  // that we don't block potential future ES APIs.
  if (typeof element === 'object' && element !== null && element.key != null) {
    // Explicit key
    return escape('' + element.key);
  } // Implicit key determined by the index in the set


  return index.toString(36);
}

function mapIntoArray(children, array, escapedPrefix, nameSoFar, callback) {
  var type = typeof children;

  if (type === 'undefined' || type === 'boolean') {
    // All of the above are perceived as null.
    children = null;
  }

  var invokeCallback = false;

  if (children === null) {
    invokeCallback = true;
  } else {
    switch (type) {
      case 'string':
      case 'number':
        invokeCallback = true;
        break;

      case 'object':
        switch (children.$$typeof) {
          case REACT_ELEMENT_TYPE:
          case REACT_PORTAL_TYPE:
            invokeCallback = true;
        }

    }
  }

  if (invokeCallback) {
    var _child = children;
    var mappedChild = callback(_child); // If it's the only child, treat the name as if it was wrapped in an array
    // so that it's consistent if the number of children grows:

    var childKey = nameSoFar === '' ? SEPARATOR + getElementKey(_child, 0) : nameSoFar;

    if (Array.isArray(mappedChild)) {
      var escapedChildKey = '';

      if (childKey != null) {
        escapedChildKey = escapeUserProvidedKey(childKey) + '/';
      }

      mapIntoArray(mappedChild, array, escapedChildKey, '', function (c) {
        return c;
      });
    } else if (mappedChild != null) {
      if (isValidElement(mappedChild)) {
        mappedChild = cloneAndReplaceKey(mappedChild, // Keep both the (mapped) and old keys if they differ, just as
        // traverseAllChildren used to do for objects as children
        escapedPrefix + ( // $FlowFixMe Flow incorrectly thinks React.Portal doesn't have a key
        mappedChild.key && (!_child || _child.key !== mappedChild.key) ? // $FlowFixMe Flow incorrectly thinks existing element's key can be a number
        escapeUserProvidedKey('' + mappedChild.key) + '/' : '') + childKey);
      }

      array.push(mappedChild);
    }

    return 1;
  }

  var child;
  var nextName;
  var subtreeCount = 0; // Count of children found in the current subtree.

  var nextNamePrefix = nameSoFar === '' ? SEPARATOR : nameSoFar + SUBSEPARATOR;

  if (Array.isArray(children)) {
    for (var i = 0; i < children.length; i++) {
      child = children[i];
      nextName = nextNamePrefix + getElementKey(child, i);
      subtreeCount += mapIntoArray(child, array, escapedPrefix, nextName, callback);
    }
  } else {
    var iteratorFn = getIteratorFn(children);

    if (typeof iteratorFn === 'function') {
      var iterableChildren = children;

      {
        // Warn about using Maps as children
        if (iteratorFn === iterableChildren.entries) {
          if (!didWarnAboutMaps) {
            warn('Using Maps as children is not supported. ' + 'Use an array of keyed ReactElements instead.');
          }

          didWarnAboutMaps = true;
        }
      }

      var iterator = iteratorFn.call(iterableChildren);
      var step;
      var ii = 0;

      while (!(step = iterator.next()).done) {
        child = step.value;
        nextName = nextNamePrefix + getElementKey(child, ii++);
        subtreeCount += mapIntoArray(child, array, escapedPrefix, nextName, callback);
      }
    } else if (type === 'object') {
      var childrenString = '' + children;

      {
        {
          throw Error( "Objects are not valid as a React child (found: " + (childrenString === '[object Object]' ? 'object with keys {' + Object.keys(children).join(', ') + '}' : childrenString) + "). If you meant to render a collection of children, use an array instead." );
        }
      }
    }
  }

  return subtreeCount;
}

/**
 * Maps children that are typically specified as `props.children`.
 *
 * See https://reactjs.org/docs/react-api.html#reactchildrenmap
 *
 * The provided mapFunction(child, index) will be called for each
 * leaf child.
 *
 * @param {?*} children Children tree container.
 * @param {function(*, int)} func The map function.
 * @param {*} context Context for mapFunction.
 * @return {object} Object containing the ordered map of results.
 */
function mapChildren(children, func, context) {
  if (children == null) {
    return children;
  }

  var result = [];
  var count = 0;
  mapIntoArray(children, result, '', '', function (child) {
    return func.call(context, child, count++);
  });
  return result;
}
/**
 * Count the number of children that are typically specified as
 * `props.children`.
 *
 * See https://reactjs.org/docs/react-api.html#reactchildrencount
 *
 * @param {?*} children Children tree container.
 * @return {number} The number of children.
 */


function countChildren(children) {
  var n = 0;
  mapChildren(children, function () {
    n++; // Don't return anything
  });
  return n;
}

/**
 * Iterates through children that are typically specified as `props.children`.
 *
 * See https://reactjs.org/docs/react-api.html#reactchildrenforeach
 *
 * The provided forEachFunc(child, index) will be called for each
 * leaf child.
 *
 * @param {?*} children Children tree container.
 * @param {function(*, int)} forEachFunc
 * @param {*} forEachContext Context for forEachContext.
 */
function forEachChildren(children, forEachFunc, forEachContext) {
  mapChildren(children, function () {
    forEachFunc.apply(this, arguments); // Don't return anything.
  }, forEachContext);
}
/**
 * Flatten a children object (typically specified as `props.children`) and
 * return an array with appropriately re-keyed children.
 *
 * See https://reactjs.org/docs/react-api.html#reactchildrentoarray
 */


function toArray(children) {
  return mapChildren(children, function (child) {
    return child;
  }) || [];
}
/**
 * Returns the first child in a collection of children and verifies that there
 * is only one child in the collection.
 *
 * See https://reactjs.org/docs/react-api.html#reactchildrenonly
 *
 * The current implementation of this function assumes that a single child gets
 * passed without a wrapper, but the purpose of this helper function is to
 * abstract away the particular structure of children.
 *
 * @param {?object} children Child collection structure.
 * @return {ReactElement} The first and only `ReactElement` contained in the
 * structure.
 */


function onlyChild(children) {
  if (!isValidElement(children)) {
    {
      throw Error( "React.Children.only expected to receive a single React element child." );
    }
  }

  return children;
}

function createContext(defaultValue, calculateChangedBits) {
  if (calculateChangedBits === undefined) {
    calculateChangedBits = null;
  } else {
    {
      if (calculateChangedBits !== null && typeof calculateChangedBits !== 'function') {
        error('createContext: Expected the optional second argument to be a ' + 'function. Instead received: %s', calculateChangedBits);
      }
    }
  }

  var context = {
    $$typeof: REACT_CONTEXT_TYPE,
    _calculateChangedBits: calculateChangedBits,
    // As a workaround to support multiple concurrent renderers, we categorize
    // some renderers as primary and others as secondary. We only expect
    // there to be two concurrent renderers at most: React Native (primary) and
    // Fabric (secondary); React DOM (primary) and React ART (secondary).
    // Secondary renderers store their context values on separate fields.
    _currentValue: defaultValue,
    _currentValue2: defaultValue,
    // Used to track how many concurrent renderers this context currently
    // supports within in a single renderer. Such as parallel server rendering.
    _threadCount: 0,
    // These are circular
    Provider: null,
    Consumer: null
  };
  context.Provider = {
    $$typeof: REACT_PROVIDER_TYPE,
    _context: context
  };
  var hasWarnedAboutUsingNestedContextConsumers = false;
  var hasWarnedAboutUsingConsumerProvider = false;
  var hasWarnedAboutDisplayNameOnConsumer = false;

  {
    // A separate object, but proxies back to the original context object for
    // backwards compatibility. It has a different $$typeof, so we can properly
    // warn for the incorrect usage of Context as a Consumer.
    var Consumer = {
      $$typeof: REACT_CONTEXT_TYPE,
      _context: context,
      _calculateChangedBits: context._calculateChangedBits
    }; // $FlowFixMe: Flow complains about not setting a value, which is intentional here

    Object.defineProperties(Consumer, {
      Provider: {
        get: function () {
          if (!hasWarnedAboutUsingConsumerProvider) {
            hasWarnedAboutUsingConsumerProvider = true;

            error('Rendering <Context.Consumer.Provider> is not supported and will be removed in ' + 'a future major release. Did you mean to render <Context.Provider> instead?');
          }

          return context.Provider;
        },
        set: function (_Provider) {
          context.Provider = _Provider;
        }
      },
      _currentValue: {
        get: function () {
          return context._currentValue;
        },
        set: function (_currentValue) {
          context._currentValue = _currentValue;
        }
      },
      _currentValue2: {
        get: function () {
          return context._currentValue2;
        },
        set: function (_currentValue2) {
          context._currentValue2 = _currentValue2;
        }
      },
      _threadCount: {
        get: function () {
          return context._threadCount;
        },
        set: function (_threadCount) {
          context._threadCount = _threadCount;
        }
      },
      Consumer: {
        get: function () {
          if (!hasWarnedAboutUsingNestedContextConsumers) {
            hasWarnedAboutUsingNestedContextConsumers = true;

            error('Rendering <Context.Consumer.Consumer> is not supported and will be removed in ' + 'a future major release. Did you mean to render <Context.Consumer> instead?');
          }

          return context.Consumer;
        }
      },
      displayName: {
        get: function () {
          return context.displayName;
        },
        set: function (displayName) {
          if (!hasWarnedAboutDisplayNameOnConsumer) {
            warn('Setting `displayName` on Context.Consumer has no effect. ' + "You should set it directly on the context with Context.displayName = '%s'.", displayName);

            hasWarnedAboutDisplayNameOnConsumer = true;
          }
        }
      }
    }); // $FlowFixMe: Flow complains about missing properties because it doesn't understand defineProperty

    context.Consumer = Consumer;
  }

  {
    context._currentRenderer = null;
    context._currentRenderer2 = null;
  }

  return context;
}

var Uninitialized = -1;
var Pending = 0;
var Resolved = 1;
var Rejected = 2;

function lazyInitializer(payload) {
  if (payload._status === Uninitialized) {
    var ctor = payload._result;
    var thenable = ctor(); // Transition to the next state.

    var pending = payload;
    pending._status = Pending;
    pending._result = thenable;
    thenable.then(function (moduleObject) {
      if (payload._status === Pending) {
        var defaultExport = moduleObject.default;

        {
          if (defaultExport === undefined) {
            error('lazy: Expected the result of a dynamic import() call. ' + 'Instead received: %s\n\nYour code should look like: \n  ' + // Break up imports to avoid accidentally parsing them as dependencies.
            'const MyComponent = lazy(() => imp' + "ort('./MyComponent'))", moduleObject);
          }
        } // Transition to the next state.


        var resolved = payload;
        resolved._status = Resolved;
        resolved._result = defaultExport;
      }
    }, function (error) {
      if (payload._status === Pending) {
        // Transition to the next state.
        var rejected = payload;
        rejected._status = Rejected;
        rejected._result = error;
      }
    });
  }

  if (payload._status === Resolved) {
    return payload._result;
  } else {
    throw payload._result;
  }
}

function lazy(ctor) {
  var payload = {
    // We use these fields to store the result.
    _status: -1,
    _result: ctor
  };
  var lazyType = {
    $$typeof: REACT_LAZY_TYPE,
    _payload: payload,
    _init: lazyInitializer
  };

  {
    // In production, this would just set it on the object.
    var defaultProps;
    var propTypes; // $FlowFixMe

    Object.defineProperties(lazyType, {
      defaultProps: {
        configurable: true,
        get: function () {
          return defaultProps;
        },
        set: function (newDefaultProps) {
          error('React.lazy(...): It is not supported to assign `defaultProps` to ' + 'a lazy component import. Either specify them where the component ' + 'is defined, or create a wrapping component around it.');

          defaultProps = newDefaultProps; // Match production behavior more closely:
          // $FlowFixMe

          Object.defineProperty(lazyType, 'defaultProps', {
            enumerable: true
          });
        }
      },
      propTypes: {
        configurable: true,
        get: function () {
          return propTypes;
        },
        set: function (newPropTypes) {
          error('React.lazy(...): It is not supported to assign `propTypes` to ' + 'a lazy component import. Either specify them where the component ' + 'is defined, or create a wrapping component around it.');

          propTypes = newPropTypes; // Match production behavior more closely:
          // $FlowFixMe

          Object.defineProperty(lazyType, 'propTypes', {
            enumerable: true
          });
        }
      }
    });
  }

  return lazyType;
}

function forwardRef(render) {
  {
    if (render != null && render.$$typeof === REACT_MEMO_TYPE) {
      error('forwardRef requires a render function but received a `memo` ' + 'component. Instead of forwardRef(memo(...)), use ' + 'memo(forwardRef(...)).');
    } else if (typeof render !== 'function') {
      error('forwardRef requires a render function but was given %s.', render === null ? 'null' : typeof render);
    } else {
      if (render.length !== 0 && render.length !== 2) {
        error('forwardRef render functions accept exactly two parameters: props and ref. %s', render.length === 1 ? 'Did you forget to use the ref parameter?' : 'Any additional parameter will be undefined.');
      }
    }

    if (render != null) {
      if (render.defaultProps != null || render.propTypes != null) {
        error('forwardRef render functions do not support propTypes or defaultProps. ' + 'Did you accidentally pass a React component?');
      }
    }
  }

  var elementType = {
    $$typeof: REACT_FORWARD_REF_TYPE,
    render: render
  };

  {
    var ownName;
    Object.defineProperty(elementType, 'displayName', {
      enumerable: false,
      configurable: true,
      get: function () {
        return ownName;
      },
      set: function (name) {
        ownName = name;

        if (render.displayName == null) {
          render.displayName = name;
        }
      }
    });
  }

  return elementType;
}

// Filter certain DOM attributes (e.g. src, href) if their values are empty strings.

var enableScopeAPI = false; // Experimental Create Event Handle API.

function isValidElementType(type) {
  if (typeof type === 'string' || typeof type === 'function') {
    return true;
  } // Note: typeof might be other than 'symbol' or 'number' (e.g. if it's a polyfill).


  if (type === exports.Fragment || type === exports.Profiler || type === REACT_DEBUG_TRACING_MODE_TYPE || type === exports.StrictMode || type === exports.Suspense || type === REACT_SUSPENSE_LIST_TYPE || type === REACT_LEGACY_HIDDEN_TYPE || enableScopeAPI ) {
    return true;
  }

  if (typeof type === 'object' && type !== null) {
    if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_BLOCK_TYPE || type[0] === REACT_SERVER_BLOCK_TYPE) {
      return true;
    }
  }

  return false;
}

function memo(type, compare) {
  {
    if (!isValidElementType(type)) {
      error('memo: The first argument must be a component. Instead ' + 'received: %s', type === null ? 'null' : typeof type);
    }
  }

  var elementType = {
    $$typeof: REACT_MEMO_TYPE,
    type: type,
    compare: compare === undefined ? null : compare
  };

  {
    var ownName;
    Object.defineProperty(elementType, 'displayName', {
      enumerable: false,
      configurable: true,
      get: function () {
        return ownName;
      },
      set: function (name) {
        ownName = name;

        if (type.displayName == null) {
          type.displayName = name;
        }
      }
    });
  }

  return elementType;
}

function resolveDispatcher() {
  var dispatcher = ReactCurrentDispatcher.current;

  if (!(dispatcher !== null)) {
    {
      throw Error( "Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem." );
    }
  }

  return dispatcher;
}

function useContext(Context, unstable_observedBits) {
  var dispatcher = resolveDispatcher();

  {
    if (unstable_observedBits !== undefined) {
      error('useContext() second argument is reserved for future ' + 'use in React. Passing it is not supported. ' + 'You passed: %s.%s', unstable_observedBits, typeof unstable_observedBits === 'number' && Array.isArray(arguments[2]) ? '\n\nDid you call array.map(useContext)? ' + 'Calling Hooks inside a loop is not supported. ' + 'Learn more at https://reactjs.org/link/rules-of-hooks' : '');
    } // TODO: add a more generic warning for invalid values.


    if (Context._context !== undefined) {
      var realContext = Context._context; // Don't deduplicate because this legitimately causes bugs
      // and nobody should be using this in existing code.

      if (realContext.Consumer === Context) {
        error('Calling useContext(Context.Consumer) is not supported, may cause bugs, and will be ' + 'removed in a future major release. Did you mean to call useContext(Context) instead?');
      } else if (realContext.Provider === Context) {
        error('Calling useContext(Context.Provider) is not supported. ' + 'Did you mean to call useContext(Context) instead?');
      }
    }
  }

  return dispatcher.useContext(Context, unstable_observedBits);
}
function useState(initialState) {
  var dispatcher = resolveDispatcher();
  return dispatcher.useState(initialState);
}
function useReducer(reducer, initialArg, init) {
  var dispatcher = resolveDispatcher();
  return dispatcher.useReducer(reducer, initialArg, init);
}
function useRef(initialValue) {
  var dispatcher = resolveDispatcher();
  return dispatcher.useRef(initialValue);
}
function useEffect(create, deps) {
  var dispatcher = resolveDispatcher();
  return dispatcher.useEffect(create, deps);
}
function useLayoutEffect(create, deps) {
  var dispatcher = resolveDispatcher();
  return dispatcher.useLayoutEffect(create, deps);
}
function useCallback(callback, deps) {
  var dispatcher = resolveDispatcher();
  return dispatcher.useCallback(callback, deps);
}
function useMemo(create, deps) {
  var dispatcher = resolveDispatcher();
  return dispatcher.useMemo(create, deps);
}
function useImperativeHandle(ref, create, deps) {
  var dispatcher = resolveDispatcher();
  return dispatcher.useImperativeHandle(ref, create, deps);
}
function useDebugValue(value, formatterFn) {
  {
    var dispatcher = resolveDispatcher();
    return dispatcher.useDebugValue(value, formatterFn);
  }
}

// Helpers to patch console.logs to avoid logging during side-effect free
// replaying on render function. This currently only patches the object
// lazily which won't cover if the log function was extracted eagerly.
// We could also eagerly patch the method.
var disabledDepth = 0;
var prevLog;
var prevInfo;
var prevWarn;
var prevError;
var prevGroup;
var prevGroupCollapsed;
var prevGroupEnd;

function disabledLog() {}

disabledLog.__reactDisabledLog = true;
function disableLogs() {
  {
    if (disabledDepth === 0) {
      /* eslint-disable react-internal/no-production-logging */
      prevLog = console.log;
      prevInfo = console.info;
      prevWarn = console.warn;
      prevError = console.error;
      prevGroup = console.group;
      prevGroupCollapsed = console.groupCollapsed;
      prevGroupEnd = console.groupEnd; // https://github.com/facebook/react/issues/19099

      var props = {
        configurable: true,
        enumerable: true,
        value: disabledLog,
        writable: true
      }; // $FlowFixMe Flow thinks console is immutable.

      Object.defineProperties(console, {
        info: props,
        log: props,
        warn: props,
        error: props,
        group: props,
        groupCollapsed: props,
        groupEnd: props
      });
      /* eslint-enable react-internal/no-production-logging */
    }

    disabledDepth++;
  }
}
function reenableLogs() {
  {
    disabledDepth--;

    if (disabledDepth === 0) {
      /* eslint-disable react-internal/no-production-logging */
      var props = {
        configurable: true,
        enumerable: true,
        writable: true
      }; // $FlowFixMe Flow thinks console is immutable.

      Object.defineProperties(console, {
        log: _assign({}, props, {
          value: prevLog
        }),
        info: _assign({}, props, {
          value: prevInfo
        }),
        warn: _assign({}, props, {
          value: prevWarn
        }),
        error: _assign({}, props, {
          value: prevError
        }),
        group: _assign({}, props, {
          value: prevGroup
        }),
        groupCollapsed: _assign({}, props, {
          value: prevGroupCollapsed
        }),
        groupEnd: _assign({}, props, {
          value: prevGroupEnd
        })
      });
      /* eslint-enable react-internal/no-production-logging */
    }

    if (disabledDepth < 0) {
      error('disabledDepth fell below zero. ' + 'This is a bug in React. Please file an issue.');
    }
  }
}

var ReactCurrentDispatcher$1 = ReactSharedInternals.ReactCurrentDispatcher;
var prefix;
function describeBuiltInComponentFrame(name, source, ownerFn) {
  {
    if (prefix === undefined) {
      // Extract the VM specific prefix used by each line.
      try {
        throw Error();
      } catch (x) {
        var match = x.stack.trim().match(/\n( *(at )?)/);
        prefix = match && match[1] || '';
      }
    } // We use the prefix to ensure our stacks line up with native stack frames.


    return '\n' + prefix + name;
  }
}
var reentry = false;
var componentFrameCache;

{
  var PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map;
  componentFrameCache = new PossiblyWeakMap();
}

function describeNativeComponentFrame(fn, construct) {
  // If something asked for a stack inside a fake render, it should get ignored.
  if (!fn || reentry) {
    return '';
  }

  {
    var frame = componentFrameCache.get(fn);

    if (frame !== undefined) {
      return frame;
    }
  }

  var control;
  reentry = true;
  var previousPrepareStackTrace = Error.prepareStackTrace; // $FlowFixMe It does accept undefined.

  Error.prepareStackTrace = undefined;
  var previousDispatcher;

  {
    previousDispatcher = ReactCurrentDispatcher$1.current; // Set the dispatcher in DEV because this might be call in the render function
    // for warnings.

    ReactCurrentDispatcher$1.current = null;
    disableLogs();
  }

  try {
    // This should throw.
    if (construct) {
      // Something should be setting the props in the constructor.
      var Fake = function () {
        throw Error();
      }; // $FlowFixMe


      Object.defineProperty(Fake.prototype, 'props', {
        set: function () {
          // We use a throwing setter instead of frozen or non-writable props
          // because that won't throw in a non-strict mode function.
          throw Error();
        }
      });

      if (typeof Reflect === 'object' && Reflect.construct) {
        // We construct a different control for this case to include any extra
        // frames added by the construct call.
        try {
          Reflect.construct(Fake, []);
        } catch (x) {
          control = x;
        }

        Reflect.construct(fn, [], Fake);
      } else {
        try {
          Fake.call();
        } catch (x) {
          control = x;
        }

        fn.call(Fake.prototype);
      }
    } else {
      try {
        throw Error();
      } catch (x) {
        control = x;
      }

      fn();
    }
  } catch (sample) {
    // This is inlined manually because closure doesn't do it for us.
    if (sample && control && typeof sample.stack === 'string') {
      // This extracts the first frame from the sample that isn't also in the control.
      // Skipping one frame that we assume is the frame that calls the two.
      var sampleLines = sample.stack.split('\n');
      var controlLines = control.stack.split('\n');
      var s = sampleLines.length - 1;
      var c = controlLines.length - 1;

      while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {
        // We expect at least one stack frame to be shared.
        // Typically this will be the root most one. However, stack frames may be
        // cut off due to maximum stack limits. In this case, one maybe cut off
        // earlier than the other. We assume that the sample is longer or the same
        // and there for cut off earlier. So we should find the root most frame in
        // the sample somewhere in the control.
        c--;
      }

      for (; s >= 1 && c >= 0; s--, c--) {
        // Next we find the first one that isn't the same which should be the
        // frame that called our sample function and the control.
        if (sampleLines[s] !== controlLines[c]) {
          // In V8, the first line is describing the message but other VMs don't.
          // If we're about to return the first line, and the control is also on the same
          // line, that's a pretty good indicator that our sample threw at same line as
          // the control. I.e. before we entered the sample frame. So we ignore this result.
          // This can happen if you passed a class to function component, or non-function.
          if (s !== 1 || c !== 1) {
            do {
              s--;
              c--; // We may still have similar intermediate frames from the construct call.
              // The next one that isn't the same should be our match though.

              if (c < 0 || sampleLines[s] !== controlLines[c]) {
                // V8 adds a "new" prefix for native classes. Let's remove it to make it prettier.
                var _frame = '\n' + sampleLines[s].replace(' at new ', ' at ');

                {
                  if (typeof fn === 'function') {
                    componentFrameCache.set(fn, _frame);
                  }
                } // Return the line we found.


                return _frame;
              }
            } while (s >= 1 && c >= 0);
          }

          break;
        }
      }
    }
  } finally {
    reentry = false;

    {
      ReactCurrentDispatcher$1.current = previousDispatcher;
      reenableLogs();
    }

    Error.prepareStackTrace = previousPrepareStackTrace;
  } // Fallback to just using the name if we couldn't make it throw.


  var name = fn ? fn.displayName || fn.name : '';
  var syntheticFrame = name ? describeBuiltInComponentFrame(name) : '';

  {
    if (typeof fn === 'function') {
      componentFrameCache.set(fn, syntheticFrame);
    }
  }

  return syntheticFrame;
}
function describeFunctionComponentFrame(fn, source, ownerFn) {
  {
    return describeNativeComponentFrame(fn, false);
  }
}

function shouldConstruct(Component) {
  var prototype = Component.prototype;
  return !!(prototype && prototype.isReactComponent);
}

function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {

  if (type == null) {
    return '';
  }

  if (typeof type === 'function') {
    {
      return describeNativeComponentFrame(type, shouldConstruct(type));
    }
  }

  if (typeof type === 'string') {
    return describeBuiltInComponentFrame(type);
  }

  switch (type) {
    case exports.Suspense:
      return describeBuiltInComponentFrame('Suspense');

    case REACT_SUSPENSE_LIST_TYPE:
      return describeBuiltInComponentFrame('SuspenseList');
  }

  if (typeof type === 'object') {
    switch (type.$$typeof) {
      case REACT_FORWARD_REF_TYPE:
        return describeFunctionComponentFrame(type.render);

      case REACT_MEMO_TYPE:
        // Memo may contain any component type so we recursively resolve it.
        return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);

      case REACT_BLOCK_TYPE:
        return describeFunctionComponentFrame(type._render);

      case REACT_LAZY_TYPE:
        {
          var lazyComponent = type;
          var payload = lazyComponent._payload;
          var init = lazyComponent._init;

          try {
            // Lazy may contain any component type so we recursively resolve it.
            return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);
          } catch (x) {}
        }
    }
  }

  return '';
}

var loggedTypeFailures = {};
var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;

function setCurrentlyValidatingElement(element) {
  {
    if (element) {
      var owner = element._owner;
      var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
      ReactDebugCurrentFrame$1.setExtraStackFrame(stack);
    } else {
      ReactDebugCurrentFrame$1.setExtraStackFrame(null);
    }
  }
}

function checkPropTypes(typeSpecs, values, location, componentName, element) {
  {
    // $FlowFixMe This is okay but Flow doesn't know it.
    var has = Function.call.bind(Object.prototype.hasOwnProperty);

    for (var typeSpecName in typeSpecs) {
      if (has(typeSpecs, typeSpecName)) {
        var error$1 = void 0; // Prop type validation may throw. In case they do, we don't want to
        // fail the render phase where it didn't fail before. So we log it.
        // After these have been cleaned up, we'll let them throw.

        try {
          // This is intentionally an invariant that gets caught. It's the same
          // behavior as without this statement except with a better message.
          if (typeof typeSpecs[typeSpecName] !== 'function') {
            var err = Error((componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' + 'it must be a function, usually from the `prop-types` package, but received `' + typeof typeSpecs[typeSpecName] + '`.' + 'This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.');
            err.name = 'Invariant Violation';
            throw err;
          }

          error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED');
        } catch (ex) {
          error$1 = ex;
        }

        if (error$1 && !(error$1 instanceof Error)) {
          setCurrentlyValidatingElement(element);

          error('%s: type specification of %s' + ' `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', location, typeSpecName, typeof error$1);

          setCurrentlyValidatingElement(null);
        }

        if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {
          // Only monitor this failure once because there tends to be a lot of the
          // same error.
          loggedTypeFailures[error$1.message] = true;
          setCurrentlyValidatingElement(element);

          error('Failed %s type: %s', location, error$1.message);

          setCurrentlyValidatingElement(null);
        }
      }
    }
  }
}

function setCurrentlyValidatingElement$1(element) {
  {
    if (element) {
      var owner = element._owner;
      var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
      setExtraStackFrame(stack);
    } else {
      setExtraStackFrame(null);
    }
  }
}

var propTypesMisspellWarningShown;

{
  propTypesMisspellWarningShown = false;
}

function getDeclarationErrorAddendum() {
  if (ReactCurrentOwner.current) {
    var name = getComponentName(ReactCurrentOwner.current.type);

    if (name) {
      return '\n\nCheck the render method of `' + name + '`.';
    }
  }

  return '';
}

function getSourceInfoErrorAddendum(source) {
  if (source !== undefined) {
    var fileName = source.fileName.replace(/^.*[\\\/]/, '');
    var lineNumber = source.lineNumber;
    return '\n\nCheck your code at ' + fileName + ':' + lineNumber + '.';
  }

  return '';
}

function getSourceInfoErrorAddendumForProps(elementProps) {
  if (elementProps !== null && elementProps !== undefined) {
    return getSourceInfoErrorAddendum(elementProps.__source);
  }

  return '';
}
/**
 * Warn if there's no key explicitly set on dynamic arrays of children or
 * object keys are not valid. This allows us to keep track of children between
 * updates.
 */


var ownerHasKeyUseWarning = {};

function getCurrentComponentErrorInfo(parentType) {
  var info = getDeclarationErrorAddendum();

  if (!info) {
    var parentName = typeof parentType === 'string' ? parentType : parentType.displayName || parentType.name;

    if (parentName) {
      info = "\n\nCheck the top-level render call using <" + parentName + ">.";
    }
  }

  return info;
}
/**
 * Warn if the element doesn't have an explicit key assigned to it.
 * This element is in an array. The array could grow and shrink or be
 * reordered. All children that haven't already been validated are required to
 * have a "key" property assigned to it. Error statuses are cached so a warning
 * will only be shown once.
 *
 * @internal
 * @param {ReactElement} element Element that requires a key.
 * @param {*} parentType element's parent's type.
 */


function validateExplicitKey(element, parentType) {
  if (!element._store || element._store.validated || element.key != null) {
    return;
  }

  element._store.validated = true;
  var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);

  if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {
    return;
  }

  ownerHasKeyUseWarning[currentComponentErrorInfo] = true; // Usually the current owner is the offender, but if it accepts children as a
  // property, it may be the creator of the child that's responsible for
  // assigning it a key.

  var childOwner = '';

  if (element && element._owner && element._owner !== ReactCurrentOwner.current) {
    // Give the component that originally created this child.
    childOwner = " It was passed a child from " + getComponentName(element._owner.type) + ".";
  }

  {
    setCurrentlyValidatingElement$1(element);

    error('Each child in a list should have a unique "key" prop.' + '%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);

    setCurrentlyValidatingElement$1(null);
  }
}
/**
 * Ensure that every element either is passed in a static location, in an
 * array with an explicit keys property defined, or in an object literal
 * with valid key property.
 *
 * @internal
 * @param {ReactNode} node Statically passed child of any type.
 * @param {*} parentType node's parent's type.
 */


function validateChildKeys(node, parentType) {
  if (typeof node !== 'object') {
    return;
  }

  if (Array.isArray(node)) {
    for (var i = 0; i < node.length; i++) {
      var child = node[i];

      if (isValidElement(child)) {
        validateExplicitKey(child, parentType);
      }
    }
  } else if (isValidElement(node)) {
    // This element was passed in a valid location.
    if (node._store) {
      node._store.validated = true;
    }
  } else if (node) {
    var iteratorFn = getIteratorFn(node);

    if (typeof iteratorFn === 'function') {
      // Entry iterators used to provide implicit keys,
      // but now we print a separate warning for them later.
      if (iteratorFn !== node.entries) {
        var iterator = iteratorFn.call(node);
        var step;

        while (!(step = iterator.next()).done) {
          if (isValidElement(step.value)) {
            validateExplicitKey(step.value, parentType);
          }
        }
      }
    }
  }
}
/**
 * Given an element, validate that its props follow the propTypes definition,
 * provided by the type.
 *
 * @param {ReactElement} element
 */


function validatePropTypes(element) {
  {
    var type = element.type;

    if (type === null || type === undefined || typeof type === 'string') {
      return;
    }

    var propTypes;

    if (typeof type === 'function') {
      propTypes = type.propTypes;
    } else if (typeof type === 'object' && (type.$$typeof === REACT_FORWARD_REF_TYPE || // Note: Memo only checks outer props here.
    // Inner props are checked in the reconciler.
    type.$$typeof === REACT_MEMO_TYPE)) {
      propTypes = type.propTypes;
    } else {
      return;
    }

    if (propTypes) {
      // Intentionally inside to avoid triggering lazy initializers:
      var name = getComponentName(type);
      checkPropTypes(propTypes, element.props, 'prop', name, element);
    } else if (type.PropTypes !== undefined && !propTypesMisspellWarningShown) {
      propTypesMisspellWarningShown = true; // Intentionally inside to avoid triggering lazy initializers:

      var _name = getComponentName(type);

      error('Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?', _name || 'Unknown');
    }

    if (typeof type.getDefaultProps === 'function' && !type.getDefaultProps.isReactClassApproved) {
      error('getDefaultProps is only used on classic React.createClass ' + 'definitions. Use a static property named `defaultProps` instead.');
    }
  }
}
/**
 * Given a fragment, validate that it can only be provided with fragment props
 * @param {ReactElement} fragment
 */


function validateFragmentProps(fragment) {
  {
    var keys = Object.keys(fragment.props);

    for (var i = 0; i < keys.length; i++) {
      var key = keys[i];

      if (key !== 'children' && key !== 'key') {
        setCurrentlyValidatingElement$1(fragment);

        error('Invalid prop `%s` supplied to `React.Fragment`. ' + 'React.Fragment can only have `key` and `children` props.', key);

        setCurrentlyValidatingElement$1(null);
        break;
      }
    }

    if (fragment.ref !== null) {
      setCurrentlyValidatingElement$1(fragment);

      error('Invalid attribute `ref` supplied to `React.Fragment`.');

      setCurrentlyValidatingElement$1(null);
    }
  }
}
function createElementWithValidation(type, props, children) {
  var validType = isValidElementType(type); // We warn in this case but don't throw. We expect the element creation to
  // succeed and there will likely be errors in render.

  if (!validType) {
    var info = '';

    if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {
      info += ' You likely forgot to export your component from the file ' + "it's defined in, or you might have mixed up default and named imports.";
    }

    var sourceInfo = getSourceInfoErrorAddendumForProps(props);

    if (sourceInfo) {
      info += sourceInfo;
    } else {
      info += getDeclarationErrorAddendum();
    }

    var typeString;

    if (type === null) {
      typeString = 'null';
    } else if (Array.isArray(type)) {
      typeString = 'array';
    } else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) {
      typeString = "<" + (getComponentName(type.type) || 'Unknown') + " />";
      info = ' Did you accidentally export a JSX literal instead of a component?';
    } else {
      typeString = typeof type;
    }

    {
      error('React.createElement: type is invalid -- expected a string (for ' + 'built-in components) or a class/function (for composite ' + 'components) but got: %s.%s', typeString, info);
    }
  }

  var element = createElement.apply(this, arguments); // The result can be nullish if a mock or a custom function is used.
  // TODO: Drop this when these are no longer allowed as the type argument.

  if (element == null) {
    return element;
  } // Skip key warning if the type isn't valid since our key validation logic
  // doesn't expect a non-string/function type and can throw confusing errors.
  // We don't want exception behavior to differ between dev and prod.
  // (Rendering will throw with a helpful message and as soon as the type is
  // fixed, the key warnings will appear.)


  if (validType) {
    for (var i = 2; i < arguments.length; i++) {
      validateChildKeys(arguments[i], type);
    }
  }

  if (type === exports.Fragment) {
    validateFragmentProps(element);
  } else {
    validatePropTypes(element);
  }

  return element;
}
var didWarnAboutDeprecatedCreateFactory = false;
function createFactoryWithValidation(type) {
  var validatedFactory = createElementWithValidation.bind(null, type);
  validatedFactory.type = type;

  {
    if (!didWarnAboutDeprecatedCreateFactory) {
      didWarnAboutDeprecatedCreateFactory = true;

      warn('React.createFactory() is deprecated and will be removed in ' + 'a future major release. Consider using JSX ' + 'or use React.createElement() directly instead.');
    } // Legacy hook: remove it


    Object.defineProperty(validatedFactory, 'type', {
      enumerable: false,
      get: function () {
        warn('Factory.type is deprecated. Access the class directly ' + 'before passing it to createFactory.');

        Object.defineProperty(this, 'type', {
          value: type
        });
        return type;
      }
    });
  }

  return validatedFactory;
}
function cloneElementWithValidation(element, props, children) {
  var newElement = cloneElement.apply(this, arguments);

  for (var i = 2; i < arguments.length; i++) {
    validateChildKeys(arguments[i], newElement.type);
  }

  validatePropTypes(newElement);
  return newElement;
}

{

  try {
    var frozenObject = Object.freeze({});
    /* eslint-disable no-new */

    new Map([[frozenObject, null]]);
    new Set([frozenObject]);
    /* eslint-enable no-new */
  } catch (e) {
  }
}

var createElement$1 =  createElementWithValidation ;
var cloneElement$1 =  cloneElementWithValidation ;
var createFactory =  createFactoryWithValidation ;
var Children = {
  map: mapChildren,
  forEach: forEachChildren,
  count: countChildren,
  toArray: toArray,
  only: onlyChild
};

exports.Children = Children;
exports.Component = Component;
exports.PureComponent = PureComponent;
exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = ReactSharedInternals;
exports.cloneElement = cloneElement$1;
exports.createContext = createContext;
exports.createElement = createElement$1;
exports.createFactory = createFactory;
exports.createRef = createRef;
exports.forwardRef = forwardRef;
exports.isValidElement = isValidElement;
exports.lazy = lazy;
exports.memo = memo;
exports.useCallback = useCallback;
exports.useContext = useContext;
exports.useDebugValue = useDebugValue;
exports.useEffect = useEffect;
exports.useImperativeHandle = useImperativeHandle;
exports.useLayoutEffect = useLayoutEffect;
exports.useMemo = useMemo;
exports.useReducer = useReducer;
exports.useRef = useRef;
exports.useState = useState;
exports.version = ReactVersion;
  })();
}


/***/ }),

/***/ "./node_modules/react/index.js":
/*!*************************************!*\
  !*** ./node_modules/react/index.js ***!
  \*************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


if (false) {} else {
  module.exports = __webpack_require__(/*! ./cjs/react.development.js */ "./node_modules/react/cjs/react.development.js");
}


/***/ }),

/***/ "./node_modules/scheduler/cjs/scheduler-tracing.development.js":
/*!*********************************************************************!*\
  !*** ./node_modules/scheduler/cjs/scheduler-tracing.development.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
/** @license React v0.20.2
 * scheduler-tracing.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



if (true) {
  (function() {
'use strict';

var DEFAULT_THREAD_ID = 0; // Counters used to generate unique IDs.

var interactionIDCounter = 0;
var threadIDCounter = 0; // Set of currently traced interactions.
// Interactions "stack"
// Meaning that newly traced interactions are appended to the previously active set.
// When an interaction goes out of scope, the previous set (if any) is restored.

exports.__interactionsRef = null; // Listener(s) to notify when interactions begin and end.

exports.__subscriberRef = null;

{
  exports.__interactionsRef = {
    current: new Set()
  };
  exports.__subscriberRef = {
    current: null
  };
}
function unstable_clear(callback) {

  var prevInteractions = exports.__interactionsRef.current;
  exports.__interactionsRef.current = new Set();

  try {
    return callback();
  } finally {
    exports.__interactionsRef.current = prevInteractions;
  }
}
function unstable_getCurrent() {
  {
    return exports.__interactionsRef.current;
  }
}
function unstable_getThreadID() {
  return ++threadIDCounter;
}
function unstable_trace(name, timestamp, callback) {
  var threadID = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : DEFAULT_THREAD_ID;

  var interaction = {
    __count: 1,
    id: interactionIDCounter++,
    name: name,
    timestamp: timestamp
  };
  var prevInteractions = exports.__interactionsRef.current; // Traced interactions should stack/accumulate.
  // To do that, clone the current interactions.
  // The previous set will be restored upon completion.

  var interactions = new Set(prevInteractions);
  interactions.add(interaction);
  exports.__interactionsRef.current = interactions;
  var subscriber = exports.__subscriberRef.current;
  var returnValue;

  try {
    if (subscriber !== null) {
      subscriber.onInteractionTraced(interaction);
    }
  } finally {
    try {
      if (subscriber !== null) {
        subscriber.onWorkStarted(interactions, threadID);
      }
    } finally {
      try {
        returnValue = callback();
      } finally {
        exports.__interactionsRef.current = prevInteractions;

        try {
          if (subscriber !== null) {
            subscriber.onWorkStopped(interactions, threadID);
          }
        } finally {
          interaction.__count--; // If no async work was scheduled for this interaction,
          // Notify subscribers that it's completed.

          if (subscriber !== null && interaction.__count === 0) {
            subscriber.onInteractionScheduledWorkCompleted(interaction);
          }
        }
      }
    }
  }

  return returnValue;
}
function unstable_wrap(callback) {
  var threadID = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DEFAULT_THREAD_ID;

  var wrappedInteractions = exports.__interactionsRef.current;
  var subscriber = exports.__subscriberRef.current;

  if (subscriber !== null) {
    subscriber.onWorkScheduled(wrappedInteractions, threadID);
  } // Update the pending async work count for the current interactions.
  // Update after calling subscribers in case of error.


  wrappedInteractions.forEach(function (interaction) {
    interaction.__count++;
  });
  var hasRun = false;

  function wrapped() {
    var prevInteractions = exports.__interactionsRef.current;
    exports.__interactionsRef.current = wrappedInteractions;
    subscriber = exports.__subscriberRef.current;

    try {
      var returnValue;

      try {
        if (subscriber !== null) {
          subscriber.onWorkStarted(wrappedInteractions, threadID);
        }
      } finally {
        try {
          returnValue = callback.apply(undefined, arguments);
        } finally {
          exports.__interactionsRef.current = prevInteractions;

          if (subscriber !== null) {
            subscriber.onWorkStopped(wrappedInteractions, threadID);
          }
        }
      }

      return returnValue;
    } finally {
      if (!hasRun) {
        // We only expect a wrapped function to be executed once,
        // But in the event that it's executed more than once
        // Only decrement the outstanding interaction counts once.
        hasRun = true; // Update pending async counts for all wrapped interactions.
        // If this was the last scheduled async work for any of them,
        // Mark them as completed.

        wrappedInteractions.forEach(function (interaction) {
          interaction.__count--;

          if (subscriber !== null && interaction.__count === 0) {
            subscriber.onInteractionScheduledWorkCompleted(interaction);
          }
        });
      }
    }
  }

  wrapped.cancel = function cancel() {
    subscriber = exports.__subscriberRef.current;

    try {
      if (subscriber !== null) {
        subscriber.onWorkCanceled(wrappedInteractions, threadID);
      }
    } finally {
      // Update pending async counts for all wrapped interactions.
      // If this was the last scheduled async work for any of them,
      // Mark them as completed.
      wrappedInteractions.forEach(function (interaction) {
        interaction.__count--;

        if (subscriber && interaction.__count === 0) {
          subscriber.onInteractionScheduledWorkCompleted(interaction);
        }
      });
    }
  };

  return wrapped;
}

var subscribers = null;

{
  subscribers = new Set();
}

function unstable_subscribe(subscriber) {
  {
    subscribers.add(subscriber);

    if (subscribers.size === 1) {
      exports.__subscriberRef.current = {
        onInteractionScheduledWorkCompleted: onInteractionScheduledWorkCompleted,
        onInteractionTraced: onInteractionTraced,
        onWorkCanceled: onWorkCanceled,
        onWorkScheduled: onWorkScheduled,
        onWorkStarted: onWorkStarted,
        onWorkStopped: onWorkStopped
      };
    }
  }
}
function unstable_unsubscribe(subscriber) {
  {
    subscribers.delete(subscriber);

    if (subscribers.size === 0) {
      exports.__subscriberRef.current = null;
    }
  }
}

function onInteractionTraced(interaction) {
  var didCatchError = false;
  var caughtError = null;
  subscribers.forEach(function (subscriber) {
    try {
      subscriber.onInteractionTraced(interaction);
    } catch (error) {
      if (!didCatchError) {
        didCatchError = true;
        caughtError = error;
      }
    }
  });

  if (didCatchError) {
    throw caughtError;
  }
}

function onInteractionScheduledWorkCompleted(interaction) {
  var didCatchError = false;
  var caughtError = null;
  subscribers.forEach(function (subscriber) {
    try {
      subscriber.onInteractionScheduledWorkCompleted(interaction);
    } catch (error) {
      if (!didCatchError) {
        didCatchError = true;
        caughtError = error;
      }
    }
  });

  if (didCatchError) {
    throw caughtError;
  }
}

function onWorkScheduled(interactions, threadID) {
  var didCatchError = false;
  var caughtError = null;
  subscribers.forEach(function (subscriber) {
    try {
      subscriber.onWorkScheduled(interactions, threadID);
    } catch (error) {
      if (!didCatchError) {
        didCatchError = true;
        caughtError = error;
      }
    }
  });

  if (didCatchError) {
    throw caughtError;
  }
}

function onWorkStarted(interactions, threadID) {
  var didCatchError = false;
  var caughtError = null;
  subscribers.forEach(function (subscriber) {
    try {
      subscriber.onWorkStarted(interactions, threadID);
    } catch (error) {
      if (!didCatchError) {
        didCatchError = true;
        caughtError = error;
      }
    }
  });

  if (didCatchError) {
    throw caughtError;
  }
}

function onWorkStopped(interactions, threadID) {
  var didCatchError = false;
  var caughtError = null;
  subscribers.forEach(function (subscriber) {
    try {
      subscriber.onWorkStopped(interactions, threadID);
    } catch (error) {
      if (!didCatchError) {
        didCatchError = true;
        caughtError = error;
      }
    }
  });

  if (didCatchError) {
    throw caughtError;
  }
}

function onWorkCanceled(interactions, threadID) {
  var didCatchError = false;
  var caughtError = null;
  subscribers.forEach(function (subscriber) {
    try {
      subscriber.onWorkCanceled(interactions, threadID);
    } catch (error) {
      if (!didCatchError) {
        didCatchError = true;
        caughtError = error;
      }
    }
  });

  if (didCatchError) {
    throw caughtError;
  }
}

exports.unstable_clear = unstable_clear;
exports.unstable_getCurrent = unstable_getCurrent;
exports.unstable_getThreadID = unstable_getThreadID;
exports.unstable_subscribe = unstable_subscribe;
exports.unstable_trace = unstable_trace;
exports.unstable_unsubscribe = unstable_unsubscribe;
exports.unstable_wrap = unstable_wrap;
  })();
}


/***/ }),

/***/ "./node_modules/scheduler/cjs/scheduler.development.js":
/*!*************************************************************!*\
  !*** ./node_modules/scheduler/cjs/scheduler.development.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
/** @license React v0.20.2
 * scheduler.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



if (true) {
  (function() {
'use strict';

var enableSchedulerDebugging = false;
var enableProfiling = false;

var requestHostCallback;
var requestHostTimeout;
var cancelHostTimeout;
var requestPaint;
var hasPerformanceNow = typeof performance === 'object' && typeof performance.now === 'function';

if (hasPerformanceNow) {
  var localPerformance = performance;

  exports.unstable_now = function () {
    return localPerformance.now();
  };
} else {
  var localDate = Date;
  var initialTime = localDate.now();

  exports.unstable_now = function () {
    return localDate.now() - initialTime;
  };
}

if ( // If Scheduler runs in a non-DOM environment, it falls back to a naive
// implementation using setTimeout.
typeof window === 'undefined' || // Check if MessageChannel is supported, too.
typeof MessageChannel !== 'function') {
  // If this accidentally gets imported in a non-browser environment, e.g. JavaScriptCore,
  // fallback to a naive implementation.
  var _callback = null;
  var _timeoutID = null;

  var _flushCallback = function () {
    if (_callback !== null) {
      try {
        var currentTime = exports.unstable_now();
        var hasRemainingTime = true;

        _callback(hasRemainingTime, currentTime);

        _callback = null;
      } catch (e) {
        setTimeout(_flushCallback, 0);
        throw e;
      }
    }
  };

  requestHostCallback = function (cb) {
    if (_callback !== null) {
      // Protect against re-entrancy.
      setTimeout(requestHostCallback, 0, cb);
    } else {
      _callback = cb;
      setTimeout(_flushCallback, 0);
    }
  };

  requestHostTimeout = function (cb, ms) {
    _timeoutID = setTimeout(cb, ms);
  };

  cancelHostTimeout = function () {
    clearTimeout(_timeoutID);
  };

  exports.unstable_shouldYield = function () {
    return false;
  };

  requestPaint = exports.unstable_forceFrameRate = function () {};
} else {
  // Capture local references to native APIs, in case a polyfill overrides them.
  var _setTimeout = window.setTimeout;
  var _clearTimeout = window.clearTimeout;

  if (typeof console !== 'undefined') {
    // TODO: Scheduler no longer requires these methods to be polyfilled. But
    // maybe we want to continue warning if they don't exist, to preserve the
    // option to rely on it in the future?
    var requestAnimationFrame = window.requestAnimationFrame;
    var cancelAnimationFrame = window.cancelAnimationFrame;

    if (typeof requestAnimationFrame !== 'function') {
      // Using console['error'] to evade Babel and ESLint
      console['error']("This browser doesn't support requestAnimationFrame. " + 'Make sure that you load a ' + 'polyfill in older browsers. https://reactjs.org/link/react-polyfills');
    }

    if (typeof cancelAnimationFrame !== 'function') {
      // Using console['error'] to evade Babel and ESLint
      console['error']("This browser doesn't support cancelAnimationFrame. " + 'Make sure that you load a ' + 'polyfill in older browsers. https://reactjs.org/link/react-polyfills');
    }
  }

  var isMessageLoopRunning = false;
  var scheduledHostCallback = null;
  var taskTimeoutID = -1; // Scheduler periodically yields in case there is other work on the main
  // thread, like user events. By default, it yields multiple times per frame.
  // It does not attempt to align with frame boundaries, since most tasks don't
  // need to be frame aligned; for those that do, use requestAnimationFrame.

  var yieldInterval = 5;
  var deadline = 0; // TODO: Make this configurable

  {
    // `isInputPending` is not available. Since we have no way of knowing if
    // there's pending input, always yield at the end of the frame.
    exports.unstable_shouldYield = function () {
      return exports.unstable_now() >= deadline;
    }; // Since we yield every frame regardless, `requestPaint` has no effect.


    requestPaint = function () {};
  }

  exports.unstable_forceFrameRate = function (fps) {
    if (fps < 0 || fps > 125) {
      // Using console['error'] to evade Babel and ESLint
      console['error']('forceFrameRate takes a positive int between 0 and 125, ' + 'forcing frame rates higher than 125 fps is not supported');
      return;
    }

    if (fps > 0) {
      yieldInterval = Math.floor(1000 / fps);
    } else {
      // reset the framerate
      yieldInterval = 5;
    }
  };

  var performWorkUntilDeadline = function () {
    if (scheduledHostCallback !== null) {
      var currentTime = exports.unstable_now(); // Yield after `yieldInterval` ms, regardless of where we are in the vsync
      // cycle. This means there's always time remaining at the beginning of
      // the message event.

      deadline = currentTime + yieldInterval;
      var hasTimeRemaining = true;

      try {
        var hasMoreWork = scheduledHostCallback(hasTimeRemaining, currentTime);

        if (!hasMoreWork) {
          isMessageLoopRunning = false;
          scheduledHostCallback = null;
        } else {
          // If there's more work, schedule the next message event at the end
          // of the preceding one.
          port.postMessage(null);
        }
      } catch (error) {
        // If a scheduler task throws, exit the current browser task so the
        // error can be observed.
        port.postMessage(null);
        throw error;
      }
    } else {
      isMessageLoopRunning = false;
    } // Yielding to the browser will give it a chance to paint, so we can
  };

  var channel = new MessageChannel();
  var port = channel.port2;
  channel.port1.onmessage = performWorkUntilDeadline;

  requestHostCallback = function (callback) {
    scheduledHostCallback = callback;

    if (!isMessageLoopRunning) {
      isMessageLoopRunning = true;
      port.postMessage(null);
    }
  };

  requestHostTimeout = function (callback, ms) {
    taskTimeoutID = _setTimeout(function () {
      callback(exports.unstable_now());
    }, ms);
  };

  cancelHostTimeout = function () {
    _clearTimeout(taskTimeoutID);

    taskTimeoutID = -1;
  };
}

function push(heap, node) {
  var index = heap.length;
  heap.push(node);
  siftUp(heap, node, index);
}
function peek(heap) {
  var first = heap[0];
  return first === undefined ? null : first;
}
function pop(heap) {
  var first = heap[0];

  if (first !== undefined) {
    var last = heap.pop();

    if (last !== first) {
      heap[0] = last;
      siftDown(heap, last, 0);
    }

    return first;
  } else {
    return null;
  }
}

function siftUp(heap, node, i) {
  var index = i;

  while (true) {
    var parentIndex = index - 1 >>> 1;
    var parent = heap[parentIndex];

    if (parent !== undefined && compare(parent, node) > 0) {
      // The parent is larger. Swap positions.
      heap[parentIndex] = node;
      heap[index] = parent;
      index = parentIndex;
    } else {
      // The parent is smaller. Exit.
      return;
    }
  }
}

function siftDown(heap, node, i) {
  var index = i;
  var length = heap.length;

  while (index < length) {
    var leftIndex = (index + 1) * 2 - 1;
    var left = heap[leftIndex];
    var rightIndex = leftIndex + 1;
    var right = heap[rightIndex]; // If the left or right node is smaller, swap with the smaller of those.

    if (left !== undefined && compare(left, node) < 0) {
      if (right !== undefined && compare(right, left) < 0) {
        heap[index] = right;
        heap[rightIndex] = node;
        index = rightIndex;
      } else {
        heap[index] = left;
        heap[leftIndex] = node;
        index = leftIndex;
      }
    } else if (right !== undefined && compare(right, node) < 0) {
      heap[index] = right;
      heap[rightIndex] = node;
      index = rightIndex;
    } else {
      // Neither child is smaller. Exit.
      return;
    }
  }
}

function compare(a, b) {
  // Compare sort index first, then task id.
  var diff = a.sortIndex - b.sortIndex;
  return diff !== 0 ? diff : a.id - b.id;
}

// TODO: Use symbols?
var ImmediatePriority = 1;
var UserBlockingPriority = 2;
var NormalPriority = 3;
var LowPriority = 4;
var IdlePriority = 5;

function markTaskErrored(task, ms) {
}

/* eslint-disable no-var */
// Math.pow(2, 30) - 1
// 0b111111111111111111111111111111

var maxSigned31BitInt = 1073741823; // Times out immediately

var IMMEDIATE_PRIORITY_TIMEOUT = -1; // Eventually times out

var USER_BLOCKING_PRIORITY_TIMEOUT = 250;
var NORMAL_PRIORITY_TIMEOUT = 5000;
var LOW_PRIORITY_TIMEOUT = 10000; // Never times out

var IDLE_PRIORITY_TIMEOUT = maxSigned31BitInt; // Tasks are stored on a min heap

var taskQueue = [];
var timerQueue = []; // Incrementing id counter. Used to maintain insertion order.

var taskIdCounter = 1; // Pausing the scheduler is useful for debugging.
var currentTask = null;
var currentPriorityLevel = NormalPriority; // This is set while performing work, to prevent re-entrancy.

var isPerformingWork = false;
var isHostCallbackScheduled = false;
var isHostTimeoutScheduled = false;

function advanceTimers(currentTime) {
  // Check for tasks that are no longer delayed and add them to the queue.
  var timer = peek(timerQueue);

  while (timer !== null) {
    if (timer.callback === null) {
      // Timer was cancelled.
      pop(timerQueue);
    } else if (timer.startTime <= currentTime) {
      // Timer fired. Transfer to the task queue.
      pop(timerQueue);
      timer.sortIndex = timer.expirationTime;
      push(taskQueue, timer);
    } else {
      // Remaining timers are pending.
      return;
    }

    timer = peek(timerQueue);
  }
}

function handleTimeout(currentTime) {
  isHostTimeoutScheduled = false;
  advanceTimers(currentTime);

  if (!isHostCallbackScheduled) {
    if (peek(taskQueue) !== null) {
      isHostCallbackScheduled = true;
      requestHostCallback(flushWork);
    } else {
      var firstTimer = peek(timerQueue);

      if (firstTimer !== null) {
        requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);
      }
    }
  }
}

function flushWork(hasTimeRemaining, initialTime) {


  isHostCallbackScheduled = false;

  if (isHostTimeoutScheduled) {
    // We scheduled a timeout but it's no longer needed. Cancel it.
    isHostTimeoutScheduled = false;
    cancelHostTimeout();
  }

  isPerformingWork = true;
  var previousPriorityLevel = currentPriorityLevel;

  try {
    if (enableProfiling) {
      try {
        return workLoop(hasTimeRemaining, initialTime);
      } catch (error) {
        if (currentTask !== null) {
          var currentTime = exports.unstable_now();
          markTaskErrored(currentTask, currentTime);
          currentTask.isQueued = false;
        }

        throw error;
      }
    } else {
      // No catch in prod code path.
      return workLoop(hasTimeRemaining, initialTime);
    }
  } finally {
    currentTask = null;
    currentPriorityLevel = previousPriorityLevel;
    isPerformingWork = false;
  }
}

function workLoop(hasTimeRemaining, initialTime) {
  var currentTime = initialTime;
  advanceTimers(currentTime);
  currentTask = peek(taskQueue);

  while (currentTask !== null && !(enableSchedulerDebugging )) {
    if (currentTask.expirationTime > currentTime && (!hasTimeRemaining || exports.unstable_shouldYield())) {
      // This currentTask hasn't expired, and we've reached the deadline.
      break;
    }

    var callback = currentTask.callback;

    if (typeof callback === 'function') {
      currentTask.callback = null;
      currentPriorityLevel = currentTask.priorityLevel;
      var didUserCallbackTimeout = currentTask.expirationTime <= currentTime;

      var continuationCallback = callback(didUserCallbackTimeout);
      currentTime = exports.unstable_now();

      if (typeof continuationCallback === 'function') {
        currentTask.callback = continuationCallback;
      } else {

        if (currentTask === peek(taskQueue)) {
          pop(taskQueue);
        }
      }

      advanceTimers(currentTime);
    } else {
      pop(taskQueue);
    }

    currentTask = peek(taskQueue);
  } // Return whether there's additional work


  if (currentTask !== null) {
    return true;
  } else {
    var firstTimer = peek(timerQueue);

    if (firstTimer !== null) {
      requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);
    }

    return false;
  }
}

function unstable_runWithPriority(priorityLevel, eventHandler) {
  switch (priorityLevel) {
    case ImmediatePriority:
    case UserBlockingPriority:
    case NormalPriority:
    case LowPriority:
    case IdlePriority:
      break;

    default:
      priorityLevel = NormalPriority;
  }

  var previousPriorityLevel = currentPriorityLevel;
  currentPriorityLevel = priorityLevel;

  try {
    return eventHandler();
  } finally {
    currentPriorityLevel = previousPriorityLevel;
  }
}

function unstable_next(eventHandler) {
  var priorityLevel;

  switch (currentPriorityLevel) {
    case ImmediatePriority:
    case UserBlockingPriority:
    case NormalPriority:
      // Shift down to normal priority
      priorityLevel = NormalPriority;
      break;

    default:
      // Anything lower than normal priority should remain at the current level.
      priorityLevel = currentPriorityLevel;
      break;
  }

  var previousPriorityLevel = currentPriorityLevel;
  currentPriorityLevel = priorityLevel;

  try {
    return eventHandler();
  } finally {
    currentPriorityLevel = previousPriorityLevel;
  }
}

function unstable_wrapCallback(callback) {
  var parentPriorityLevel = currentPriorityLevel;
  return function () {
    // This is a fork of runWithPriority, inlined for performance.
    var previousPriorityLevel = currentPriorityLevel;
    currentPriorityLevel = parentPriorityLevel;

    try {
      return callback.apply(this, arguments);
    } finally {
      currentPriorityLevel = previousPriorityLevel;
    }
  };
}

function unstable_scheduleCallback(priorityLevel, callback, options) {
  var currentTime = exports.unstable_now();
  var startTime;

  if (typeof options === 'object' && options !== null) {
    var delay = options.delay;

    if (typeof delay === 'number' && delay > 0) {
      startTime = currentTime + delay;
    } else {
      startTime = currentTime;
    }
  } else {
    startTime = currentTime;
  }

  var timeout;

  switch (priorityLevel) {
    case ImmediatePriority:
      timeout = IMMEDIATE_PRIORITY_TIMEOUT;
      break;

    case UserBlockingPriority:
      timeout = USER_BLOCKING_PRIORITY_TIMEOUT;
      break;

    case IdlePriority:
      timeout = IDLE_PRIORITY_TIMEOUT;
      break;

    case LowPriority:
      timeout = LOW_PRIORITY_TIMEOUT;
      break;

    case NormalPriority:
    default:
      timeout = NORMAL_PRIORITY_TIMEOUT;
      break;
  }

  var expirationTime = startTime + timeout;
  var newTask = {
    id: taskIdCounter++,
    callback: callback,
    priorityLevel: priorityLevel,
    startTime: startTime,
    expirationTime: expirationTime,
    sortIndex: -1
  };

  if (startTime > currentTime) {
    // This is a delayed task.
    newTask.sortIndex = startTime;
    push(timerQueue, newTask);

    if (peek(taskQueue) === null && newTask === peek(timerQueue)) {
      // All tasks are delayed, and this is the task with the earliest delay.
      if (isHostTimeoutScheduled) {
        // Cancel an existing timeout.
        cancelHostTimeout();
      } else {
        isHostTimeoutScheduled = true;
      } // Schedule a timeout.


      requestHostTimeout(handleTimeout, startTime - currentTime);
    }
  } else {
    newTask.sortIndex = expirationTime;
    push(taskQueue, newTask);
    // wait until the next time we yield.


    if (!isHostCallbackScheduled && !isPerformingWork) {
      isHostCallbackScheduled = true;
      requestHostCallback(flushWork);
    }
  }

  return newTask;
}

function unstable_pauseExecution() {
}

function unstable_continueExecution() {

  if (!isHostCallbackScheduled && !isPerformingWork) {
    isHostCallbackScheduled = true;
    requestHostCallback(flushWork);
  }
}

function unstable_getFirstCallbackNode() {
  return peek(taskQueue);
}

function unstable_cancelCallback(task) {
  // remove from the queue because you can't remove arbitrary nodes from an
  // array based heap, only the first one.)


  task.callback = null;
}

function unstable_getCurrentPriorityLevel() {
  return currentPriorityLevel;
}

var unstable_requestPaint = requestPaint;
var unstable_Profiling =  null;

exports.unstable_IdlePriority = IdlePriority;
exports.unstable_ImmediatePriority = ImmediatePriority;
exports.unstable_LowPriority = LowPriority;
exports.unstable_NormalPriority = NormalPriority;
exports.unstable_Profiling = unstable_Profiling;
exports.unstable_UserBlockingPriority = UserBlockingPriority;
exports.unstable_cancelCallback = unstable_cancelCallback;
exports.unstable_continueExecution = unstable_continueExecution;
exports.unstable_getCurrentPriorityLevel = unstable_getCurrentPriorityLevel;
exports.unstable_getFirstCallbackNode = unstable_getFirstCallbackNode;
exports.unstable_next = unstable_next;
exports.unstable_pauseExecution = unstable_pauseExecution;
exports.unstable_requestPaint = unstable_requestPaint;
exports.unstable_runWithPriority = unstable_runWithPriority;
exports.unstable_scheduleCallback = unstable_scheduleCallback;
exports.unstable_wrapCallback = unstable_wrapCallback;
  })();
}


/***/ }),

/***/ "./node_modules/scheduler/index.js":
/*!*****************************************!*\
  !*** ./node_modules/scheduler/index.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


if (false) {} else {
  module.exports = __webpack_require__(/*! ./cjs/scheduler.development.js */ "./node_modules/scheduler/cjs/scheduler.development.js");
}


/***/ }),

/***/ "./node_modules/scheduler/tracing.js":
/*!*******************************************!*\
  !*** ./node_modules/scheduler/tracing.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


if (false) {} else {
  module.exports = __webpack_require__(/*! ./cjs/scheduler-tracing.development.js */ "./node_modules/scheduler/cjs/scheduler-tracing.development.js");
}


/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js":
/*!****************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js ***!
  \****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var isOldIE = function isOldIE() {
  var memo;
  return function memorize() {
    if (typeof memo === 'undefined') {
      // Test for IE <= 9 as proposed by Browserhacks
      // @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805
      // Tests for existence of standard globals is to allow style-loader
      // to operate correctly into non-standard environments
      // @see https://github.com/webpack-contrib/style-loader/issues/177
      memo = Boolean(window && document && document.all && !window.atob);
    }

    return memo;
  };
}();

var getTarget = function getTarget() {
  var memo = {};
  return function memorize(target) {
    if (typeof memo[target] === 'undefined') {
      var styleTarget = document.querySelector(target); // Special case to return head of iframe instead of iframe itself

      if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {
        try {
          // This will throw an exception if access to iframe is blocked
          // due to cross-origin restrictions
          styleTarget = styleTarget.contentDocument.head;
        } catch (e) {
          // istanbul ignore next
          styleTarget = null;
        }
      }

      memo[target] = styleTarget;
    }

    return memo[target];
  };
}();

var stylesInDom = [];

function getIndexByIdentifier(identifier) {
  var result = -1;

  for (var i = 0; i < stylesInDom.length; i++) {
    if (stylesInDom[i].identifier === identifier) {
      result = i;
      break;
    }
  }

  return result;
}

function modulesToDom(list, options) {
  var idCountMap = {};
  var identifiers = [];

  for (var i = 0; i < list.length; i++) {
    var item = list[i];
    var id = options.base ? item[0] + options.base : item[0];
    var count = idCountMap[id] || 0;
    var identifier = "".concat(id, " ").concat(count);
    idCountMap[id] = count + 1;
    var index = getIndexByIdentifier(identifier);
    var obj = {
      css: item[1],
      media: item[2],
      sourceMap: item[3]
    };

    if (index !== -1) {
      stylesInDom[index].references++;
      stylesInDom[index].updater(obj);
    } else {
      stylesInDom.push({
        identifier: identifier,
        updater: addStyle(obj, options),
        references: 1
      });
    }

    identifiers.push(identifier);
  }

  return identifiers;
}

function insertStyleElement(options) {
  var style = document.createElement('style');
  var attributes = options.attributes || {};

  if (typeof attributes.nonce === 'undefined') {
    var nonce =  true ? __webpack_require__.nc : 0;

    if (nonce) {
      attributes.nonce = nonce;
    }
  }

  Object.keys(attributes).forEach(function (key) {
    style.setAttribute(key, attributes[key]);
  });

  if (typeof options.insert === 'function') {
    options.insert(style);
  } else {
    var target = getTarget(options.insert || 'head');

    if (!target) {
      throw new Error("Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.");
    }

    target.appendChild(style);
  }

  return style;
}

function removeStyleElement(style) {
  // istanbul ignore if
  if (style.parentNode === null) {
    return false;
  }

  style.parentNode.removeChild(style);
}
/* istanbul ignore next  */


var replaceText = function replaceText() {
  var textStore = [];
  return function replace(index, replacement) {
    textStore[index] = replacement;
    return textStore.filter(Boolean).join('\n');
  };
}();

function applyToSingletonTag(style, index, remove, obj) {
  var css = remove ? '' : obj.media ? "@media ".concat(obj.media, " {").concat(obj.css, "}") : obj.css; // For old IE

  /* istanbul ignore if  */

  if (style.styleSheet) {
    style.styleSheet.cssText = replaceText(index, css);
  } else {
    var cssNode = document.createTextNode(css);
    var childNodes = style.childNodes;

    if (childNodes[index]) {
      style.removeChild(childNodes[index]);
    }

    if (childNodes.length) {
      style.insertBefore(cssNode, childNodes[index]);
    } else {
      style.appendChild(cssNode);
    }
  }
}

function applyToTag(style, options, obj) {
  var css = obj.css;
  var media = obj.media;
  var sourceMap = obj.sourceMap;

  if (media) {
    style.setAttribute('media', media);
  } else {
    style.removeAttribute('media');
  }

  if (sourceMap && typeof btoa !== 'undefined') {
    css += "\n/*# sourceMappingURL=data:application/json;base64,".concat(btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))), " */");
  } // For old IE

  /* istanbul ignore if  */


  if (style.styleSheet) {
    style.styleSheet.cssText = css;
  } else {
    while (style.firstChild) {
      style.removeChild(style.firstChild);
    }

    style.appendChild(document.createTextNode(css));
  }
}

var singleton = null;
var singletonCounter = 0;

function addStyle(obj, options) {
  var style;
  var update;
  var remove;

  if (options.singleton) {
    var styleIndex = singletonCounter++;
    style = singleton || (singleton = insertStyleElement(options));
    update = applyToSingletonTag.bind(null, style, styleIndex, false);
    remove = applyToSingletonTag.bind(null, style, styleIndex, true);
  } else {
    style = insertStyleElement(options);
    update = applyToTag.bind(null, style, options);

    remove = function remove() {
      removeStyleElement(style);
    };
  }

  update(obj);
  return function updateStyle(newObj) {
    if (newObj) {
      if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap) {
        return;
      }

      update(obj = newObj);
    } else {
      remove();
    }
  };
}

module.exports = function (list, options) {
  options = options || {}; // Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
  // tags it will allow on a page

  if (!options.singleton && typeof options.singleton !== 'boolean') {
    options.singleton = isOldIE();
  }

  list = list || [];
  var lastIdentifiers = modulesToDom(list, options);
  return function update(newList) {
    newList = newList || [];

    if (Object.prototype.toString.call(newList) !== '[object Array]') {
      return;
    }

    for (var i = 0; i < lastIdentifiers.length; i++) {
      var identifier = lastIdentifiers[i];
      var index = getIndexByIdentifier(identifier);
      stylesInDom[index].references--;
    }

    var newLastIdentifiers = modulesToDom(newList, options);

    for (var _i = 0; _i < lastIdentifiers.length; _i++) {
      var _identifier = lastIdentifiers[_i];

      var _index = getIndexByIdentifier(_identifier);

      if (stylesInDom[_index].references === 0) {
        stylesInDom[_index].updater();

        stylesInDom.splice(_index, 1);
      }
    }

    lastIdentifiers = newLastIdentifiers;
  };
};

/***/ }),

/***/ "./node_modules/use-async-effect/index.js":
/*!************************************************!*\
  !*** ./node_modules/use-async-effect/index.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var React = __webpack_require__(/*! react */ "./node_modules/react/index.js");

function useAsyncEffect(effect, destroy, inputs) {
  var hasDestroy = typeof destroy === 'function';

  React.useEffect(function () {
    var result;
    var mounted = true;
    var maybePromise = effect(function () {
      return mounted;
    });

    Promise.resolve(maybePromise).then(function (value) {
      result = value;
    });

    return function () {
      mounted = false;

      if (hasDestroy) {
        destroy(result);
      }
    };
  }, hasDestroy ? inputs : destroy);
}

module.exports = useAsyncEffect;
module.exports.useAsyncEffect = useAsyncEffect;


/***/ }),

/***/ "./src/style.css":
/*!***********************!*\
  !*** ./src/style.css ***!
  \***********************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var api = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");
            var content = __webpack_require__(/*! !!../node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[2].use[1]!../node_modules/postcss-loader/src/index.js??ruleSet[1].rules[2].use[2]!./style.css */ "./node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[2].use[1]!./node_modules/postcss-loader/src/index.js??ruleSet[1].rules[2].use[2]!./src/style.css");

            content = content.__esModule ? content.default : content;

            if (typeof content === 'string') {
              content = [[module.id, content, '']];
            }

var options = {};

options.insert = "head";
options.singleton = false;

var update = api(content, options);



module.exports = content.locals || {};

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be in strict mode.
(() => {
"use strict";
/*!**********************************!*\
  !*** ./src/quick-demo/index.tsx ***!
  \**********************************/
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var rainway_sdk__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! rainway-sdk */ "./node_modules/rainway-sdk/dist/index.js");
/* harmony import */ var rainway_sdk__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(rainway_sdk__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react-dom */ "./node_modules/react-dom/index.js");
/* harmony import */ var _style_css__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../style.css */ "./src/style.css");
/* harmony import */ var _style_css__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_style_css__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var use_async_effect__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! use-async-effect */ "./node_modules/use-async-effect/index.js");
/* harmony import */ var use_async_effect__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(use_async_effect__WEBPACK_IMPORTED_MODULE_4__);
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};





const QuickDemo = () => {
    const [runtime, setRuntime] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)();
    const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)("");
    use_async_effect__WEBPACK_IMPORTED_MODULE_4___default()((isAlive) => __awaiter(void 0, void 0, void 0, function* () {
        var _a;
        try {
            const rt = yield rainway_sdk__WEBPACK_IMPORTED_MODULE_0__.RainwayRuntime.initialize({
                apiKey: (_a = new URLSearchParams(window.location.search).get("api_key")) !== null && _a !== void 0 ? _a : "",
                externalId: "web-demo-quick",
                onRuntimeConnectionLost: (rt, error) => {
                    setRuntime(undefined);
                },
                onConnectionRequest: (rt, request) => {
                    request.accept();
                },
                onPeerMessage: () => { },
                onPeerDataChannel: () => { },
                onPeerError: (rt, peer, error) => {
                    console.warn("onPeerError", peer, error);
                },
                onPeerStateChange: (rt, peer, state) => {
                    console.log(`Peer ${peer.peerId} changed states to ${state}`);
                },
                onStreamAnnouncement: () => { },
                onStreamStop: () => { },
                logSink: () => { },
            });
            if (!isAlive())
                return;
            setRuntime(rt);
        }
        catch (e) {
            setError(e.message);
            console.log(e);
        }
    }));
    return (react__WEBPACK_IMPORTED_MODULE_1__.createElement("main", { className: "m-t-8 m-l-8 m-r-8 m-b-8" }, error ? error : runtime ? "Connected." : "Connecting"));
};
react_dom__WEBPACK_IMPORTED_MODULE_2__.render(react__WEBPACK_IMPORTED_MODULE_1__.createElement(react__WEBPACK_IMPORTED_MODULE_1__.StrictMode, null,
    react__WEBPACK_IMPORTED_MODULE_1__.createElement(QuickDemo, null)), document.getElementById("react-root"));

})();

/******/ })()
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yYWlud2F5LXNkay13ZWItZGVtby8uL3NyYy9zdHlsZS5jc3MiLCJ3ZWJwYWNrOi8vcmFpbndheS1zZGstd2ViLWRlbW8vLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvYXBpLmpzIiwid2VicGFjazovL3JhaW53YXktc2RrLXdlYi1kZW1vLy4vbm9kZV9tb2R1bGVzL29iamVjdC1hc3NpZ24vaW5kZXguanMiLCJ3ZWJwYWNrOi8vcmFpbndheS1zZGstd2ViLWRlbW8vLi9ub2RlX21vZHVsZXMvcmFpbndheS1zZGsvZGlzdC9pbmRleC5qcyIsIndlYnBhY2s6Ly9yYWlud2F5LXNkay13ZWItZGVtby8uL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vY2pzL3JlYWN0LWRvbS5kZXZlbG9wbWVudC5qcyIsIndlYnBhY2s6Ly9yYWlud2F5LXNkay13ZWItZGVtby8uL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vaW5kZXguanMiLCJ3ZWJwYWNrOi8vcmFpbndheS1zZGstd2ViLWRlbW8vLi9ub2RlX21vZHVsZXMvcmVhY3QvY2pzL3JlYWN0LmRldmVsb3BtZW50LmpzIiwid2VicGFjazovL3JhaW53YXktc2RrLXdlYi1kZW1vLy4vbm9kZV9tb2R1bGVzL3JlYWN0L2luZGV4LmpzIiwid2VicGFjazovL3JhaW53YXktc2RrLXdlYi1kZW1vLy4vbm9kZV9tb2R1bGVzL3NjaGVkdWxlci9janMvc2NoZWR1bGVyLXRyYWNpbmcuZGV2ZWxvcG1lbnQuanMiLCJ3ZWJwYWNrOi8vcmFpbndheS1zZGstd2ViLWRlbW8vLi9ub2RlX21vZHVsZXMvc2NoZWR1bGVyL2Nqcy9zY2hlZHVsZXIuZGV2ZWxvcG1lbnQuanMiLCJ3ZWJwYWNrOi8vcmFpbndheS1zZGstd2ViLWRlbW8vLi9ub2RlX21vZHVsZXMvc2NoZWR1bGVyL2luZGV4LmpzIiwid2VicGFjazovL3JhaW53YXktc2RrLXdlYi1kZW1vLy4vbm9kZV9tb2R1bGVzL3NjaGVkdWxlci90cmFjaW5nLmpzIiwid2VicGFjazovL3JhaW53YXktc2RrLXdlYi1kZW1vLy4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvaW5qZWN0U3R5bGVzSW50b1N0eWxlVGFnLmpzIiwid2VicGFjazovL3JhaW53YXktc2RrLXdlYi1kZW1vLy4vbm9kZV9tb2R1bGVzL3VzZS1hc3luYy1lZmZlY3QvaW5kZXguanMiLCJ3ZWJwYWNrOi8vcmFpbndheS1zZGstd2ViLWRlbW8vLi9zcmMvc3R5bGUuY3NzPzllZmQiLCJ3ZWJwYWNrOi8vcmFpbndheS1zZGstd2ViLWRlbW8vd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vcmFpbndheS1zZGstd2ViLWRlbW8vd2VicGFjay9ydW50aW1lL2NvbXBhdCBnZXQgZGVmYXVsdCBleHBvcnQiLCJ3ZWJwYWNrOi8vcmFpbndheS1zZGstd2ViLWRlbW8vd2VicGFjay9ydW50aW1lL2RlZmluZSBwcm9wZXJ0eSBnZXR0ZXJzIiwid2VicGFjazovL3JhaW53YXktc2RrLXdlYi1kZW1vL3dlYnBhY2svcnVudGltZS9oYXNPd25Qcm9wZXJ0eSBzaG9ydGhhbmQiLCJ3ZWJwYWNrOi8vcmFpbndheS1zZGstd2ViLWRlbW8vd2VicGFjay9ydW50aW1lL21ha2UgbmFtZXNwYWNlIG9iamVjdCIsIndlYnBhY2s6Ly9yYWlud2F5LXNkay13ZWItZGVtby8uL3NyYy9xdWljay1kZW1vL2luZGV4LnRzeCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBQTtBQUNBLGtDQUFrQyxtQkFBTyxDQUFDLHFHQUFnRDtBQUMxRjtBQUNBLDhGQUE4RixJQUFJLElBQUksNkNBQTZDLElBQUksMkJBQTJCLElBQUksSUFBSSxrQkFBa0I7QUFDNU07QUFDQSxpQ0FBaUMsZ0RBQWdELDhDQUE4QyxtREFBbUQsb0RBQW9ELHFEQUFxRCwrQkFBK0IsK0JBQStCLCtCQUErQiwrQkFBK0IsK0JBQStCLCtCQUErQiwrQkFBK0IsK0JBQStCLCtCQUErQiwrQkFBK0IsK0JBQStCLCtDQUErQyw2QkFBNkIsNkJBQTZCLDZCQUE2Qiw2QkFBNkIsNkJBQTZCLDZCQUE2Qiw2QkFBNkIsNkJBQTZCLG1EQUFtRCw4QkFBOEIsOEJBQThCLDhCQUE4Qiw4QkFBOEIsOEJBQThCLDhCQUE4Qiw4QkFBOEIsOEJBQThCLDZDQUE2QywyQkFBMkIsMkJBQTJCLDJCQUEyQiwyQkFBMkIsMkJBQTJCLDJCQUEyQiwyQkFBMkIsMkJBQTJCLGlEQUFpRCw4QkFBOEIsK0JBQStCLCtCQUErQiwrQkFBK0IsK0JBQStCLCtCQUErQiwrQkFBK0IsK0JBQStCLCtCQUErQiwrQkFBK0IsK0JBQStCLCtCQUErQiwrQkFBK0IsK0JBQStCLCtCQUErQiwrQkFBK0IsZ0NBQWdDLEdBQUcsYUFBYSxpQkFBaUIsR0FBRywrQ0FBK0MsK0JBQStCLEdBQUcsVUFBVSxnQ0FBZ0MsR0FBRyxVQUFVLGtDQUFrQyxHQUFHLFVBQVUsbUNBQW1DLEdBQUcsVUFBVSxnQ0FBZ0MsR0FBRyxVQUFVLGlDQUFpQyxHQUFHLFVBQVUsaUNBQWlDLEdBQUcsVUFBVSxrQ0FBa0MsR0FBRyxVQUFVLCtCQUErQixHQUFHLFVBQVUsZ0NBQWdDLEdBQUcsVUFBVSxrQ0FBa0MsR0FBRyxVQUFVLG1DQUFtQyxHQUFHLFVBQVUsZ0NBQWdDLEdBQUcsVUFBVSxpQ0FBaUMsR0FBRyxVQUFVLGlDQUFpQyxHQUFHLFVBQVUsa0NBQWtDLEdBQUcsVUFBVSwrQkFBK0IsR0FBRyxVQUFVLGdDQUFnQyxHQUFHLFVBQVUsa0NBQWtDLEdBQUcsVUFBVSxtQ0FBbUMsR0FBRyxVQUFVLGdDQUFnQyxHQUFHLFVBQVUsaUNBQWlDLEdBQUcsVUFBVSxpQ0FBaUMsR0FBRyxVQUFVLGtDQUFrQyxHQUFHLFdBQVcsZ0NBQWdDLEdBQUcsV0FBVyxpQ0FBaUMsR0FBRyxXQUFXLG1DQUFtQyxHQUFHLFdBQVcsb0NBQW9DLEdBQUcsV0FBVyxpQ0FBaUMsR0FBRyxXQUFXLGtDQUFrQyxHQUFHLFdBQVcsa0NBQWtDLEdBQUcsV0FBVyxtQ0FBbUMsR0FBRyxXQUFXLGdDQUFnQyxHQUFHLFdBQVcsaUNBQWlDLEdBQUcsV0FBVyxtQ0FBbUMsR0FBRyxXQUFXLG9DQUFvQyxHQUFHLFdBQVcsaUNBQWlDLEdBQUcsV0FBVyxrQ0FBa0MsR0FBRyxXQUFXLGtDQUFrQyxHQUFHLFdBQVcsbUNBQW1DLEdBQUcsV0FBVyxnQ0FBZ0MsR0FBRyxXQUFXLGlDQUFpQyxHQUFHLFdBQVcsbUNBQW1DLEdBQUcsV0FBVyxvQ0FBb0MsR0FBRyxXQUFXLGlDQUFpQyxHQUFHLFdBQVcsa0NBQWtDLEdBQUcsV0FBVyxrQ0FBa0MsR0FBRyxXQUFXLG1DQUFtQyxHQUFHLFdBQVcsZ0NBQWdDLEdBQUcsV0FBVyxpQ0FBaUMsR0FBRyxXQUFXLG1DQUFtQyxHQUFHLFdBQVcsb0NBQW9DLEdBQUcsV0FBVyxpQ0FBaUMsR0FBRyxXQUFXLGtDQUFrQyxHQUFHLFdBQVcsa0NBQWtDLEdBQUcsV0FBVyxtQ0FBbUMsR0FBRyxXQUFXLGdDQUFnQyxHQUFHLFdBQVcsaUNBQWlDLEdBQUcsV0FBVyxtQ0FBbUMsR0FBRyxXQUFXLG9DQUFvQyxHQUFHLFdBQVcsaUNBQWlDLEdBQUcsV0FBVyxrQ0FBa0MsR0FBRyxXQUFXLGtDQUFrQyxHQUFHLFdBQVcsbUNBQW1DLEdBQUcsV0FBVyxnQ0FBZ0MsR0FBRyxXQUFXLGlDQUFpQyxHQUFHLFdBQVcsbUNBQW1DLEdBQUcsV0FBVyxvQ0FBb0MsR0FBRyxXQUFXLGlDQUFpQyxHQUFHLFdBQVcsa0NBQWtDLEdBQUcsV0FBVyxrQ0FBa0MsR0FBRyxXQUFXLG1DQUFtQyxHQUFHLFdBQVcsZ0NBQWdDLEdBQUcsV0FBVyxpQ0FBaUMsR0FBRyxXQUFXLG1DQUFtQyxHQUFHLFdBQVcsb0NBQW9DLEdBQUcsV0FBVyxpQ0FBaUMsR0FBRyxXQUFXLGtDQUFrQyxHQUFHLFdBQVcsa0NBQWtDLEdBQUcsV0FBVyxtQ0FBbUMsR0FBRyxXQUFXLGdDQUFnQyxHQUFHLFdBQVcsaUNBQWlDLEdBQUcsV0FBVyxtQ0FBbUMsR0FBRyxXQUFXLG9DQUFvQyxHQUFHLFdBQVcsaUNBQWlDLEdBQUcsV0FBVyxrQ0FB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Z0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTs7QUFFQSwyQkFBMkI7QUFDM0I7O0FBRUEsZ0JBQWdCO0FBQ2hCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTs7O0FBR0Esb0JBQW9COztBQUVwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsRUFBRTtBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLEVBQUU7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsRUFBRTtBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLEVBQUU7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFFO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsRUFBRTtBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsRUFBRTs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLEVBQUU7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOztBQUVBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsRUFBRTs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFFOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLEVBQUU7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsRUFBRTtBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxXQUFXO0FBQ3RCLFdBQVcsT0FBTztBQUNsQixXQUFXLEVBQUU7QUFDYjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7O0FBR0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOzs7QUFHSDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QSxXQUFXO0FBQ1g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsRUFBRTtBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7OztBQUdIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQ0FBaUM7QUFDakM7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUEsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtB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QUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxxQkFBcUIsc0JBQXNCO0FBQzNDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGlDQUFpQzs7QUFFakM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLGdDQUFnQyxLQUFLO0FBQzNDO0FBQ0E7QUFDQSxNQUFNLGdDQUFnQyxLQUFLO0FBQzNDO0FBQ0EsNERBQTREO0FBQzVELE1BQU0sZ0NBQWdDLEtBQUs7QUFDM0M7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLDROQUE0TjtBQUM1TjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7O0FBR0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw0RUFBNEUsWUFBWTtBQUN4RjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMkhBQTJILDZCQUE2QjtBQUN4SjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrRkFBa0Y7QUFDbEY7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTywwQ0FBMEM7OztBQUdqRDtBQUNBOztBQUVBO0FBQ0E7QUFD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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFlBQVksVUFBVTtBQUN0Qjs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLDBDQUEwQztBQUMxQzs7QUFFQTtBQUNBO0FBQ0EscUJBQXFCOztBQUVyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwwQkFBMEI7QUFDMUI7QUFDQTs7QUFFQSxxQ0FBcUM7QUFDckM7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRTtBQUNuRTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0EsZ0JBQWdCOztBQUVoQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGdCQUFnQjtBQUM3QjtBQUNBO0FBQ0E7QUFDQSxPQUFPOzs7QUFHUCx1RUFBdUU7O0FBRXZFO0FBQ0EsOERBQThEO0FBQzlEOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQSxPQUFPOzs7QUFHUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsdUJBQXVCOztBQUV2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLFNBQVM7QUFDcEIsV0FBVyxFQUFFO0FBQ2IsV0FBVyxLQUFLO0FBQ2hCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsU0FBUztBQUNwQixXQUFXLEVBQUU7QUFDYixXQUFXLEtBQUs7QUFDaEI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87OztBQUdQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPO0FBQ1A7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOzs7QUFHSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7O0FBR0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOzs7QUFHSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELHNDQUFzQzs7QUFFdEMsOEJBQThCO0FBQzlCOztBQUVBO0FBQ0E7QUFDQSx1QkFBdUI7O0FBRXZCO0FBQ0Esc0NBQXNDOztBQUV0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixXQUFXO0FBQ1g7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBLHlFQUF5RTtBQUN6RTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7OztBQUdMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0NBQW9DOztBQUVwQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7O0FBR1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7OztBQUdIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNB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O0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOzs7QUFHSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7O0FBRXJDO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7O0FBR0Esc0VBQXNFO0FBQ3RFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFD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d0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMENBQTBDO0FBQzFDO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixZQUFZLE9BQU87QUFDbkI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7O0FBR0g7QUFDQSxpREFBaUQ7QUFDakQ7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBLG1DQUFtQzs7QUFFbkM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTs7O0FBR0EsK0VBQStFO0FBQy9FO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7QUFHRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsWUFBWTtBQUNaOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsWUFBWTtBQUNaOzs7QUFHQTtBQUNBO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEI7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDs7O0FBR0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDZHQUE2RztBQUM3RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLENBQUM7OztBQUdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7OztBQUdIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsVUFBVTs7QUFFVjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25COztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOzs7QUFHSCxpQkFBaUIsa0JBQWtCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyx1QkFBdUI7QUFDbEMsWUFBWTtBQUNaOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsdUJBQXVCO0FBQ2xDLFlBQVk7QUFDWjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHVCQUF1QjtBQUNsQyxXQUFXLE9BQU87QUFDbEIsWUFBWTtBQUNaOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxXQUFXO0FBQ3RCLFlBQVk7QUFDWjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxXQUFXO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPOzs7QUFHUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7O0FBR0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHVCQUF1QjtBQUNsQyxXQUFXLE9BQU87QUFDbEI7O0FBRUE7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw4RUFBOEU7QUFDOUU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7O0FBR0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CLHNCQUFzQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixZQUFZO0FBQ1o7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7O0FBR0g7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwR0FBMEc7QUFDMUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7O0FBR0QsZ1RBQWdUO0FBQ2hUO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSw4Q0FBOEMsUUFBUTtBQUN0RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FB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O0FBQ0E7QUFDQTtBQUNBLEdBQUc7OztBQUdIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7OztBQUdIOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQSx3RUFBd0U7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlJQUFpSSxtQkFBbUIsZ0JBQWdCLDhCQUE4QjtBQUNsTSxLQUFLO0FBQ0w7QUFDQTtBQUNBLElBQUk7QUFDSjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7O0FBR1A7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUssb0dBQW9HLGtDQUFrQztBQUMzSTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCLDBCQUEwQjtBQUMzQztBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyQkFBMkI7QUFDM0I7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNERBQTREO0FBQzVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLCtDQUErQztBQUMvQzs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EscURBQXFEO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7OztBQUdIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLDRCQUE0QjtBQUNqRDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRDs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbURBQW1EO0FBQ25EOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxtREFBbUQ7QUFDbkQ7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7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QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qzs7QUFFOUM7QUFDQSxhQUFhOzs7QUFHYjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQ7QUFDekQ7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQSwwdkJBQTB2Qjs7QUFFMXZCO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQzs7QUFFcEMsdURBQXVEOztBQUV2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUNBQWlDOztBQUVqQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5Qzs7QUFFekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLEdBQUc7OztBQUdIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7OztBQUdIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVEsY0FBYztBQUN0Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNEO0FBQ3REOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7O0FBR0g7QUFDQSxDQUFDO0FBQ0Q7QUFDQTs7QUFFQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLCtDQUErQztBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSywrQ0FBK0M7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBOzs7QUFHQSx5RUFBeUU7QUFDekU7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwSEFBMEg7QUFDMUg7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxtRUFBbUU7O0FBRW5FO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLENBQUM7OztBQUdELDBEQUEwRDs7QUFFMUQsb0RBQW9EO0FBQ3BEO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbURBQW1EO0FBQ25EOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFCQUFxQjtBQUNyQjtBQUNBOztBQUVBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTs7QUFFQSwwSEFBMEg7QUFDMUg7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RUFBeUU7QUFDekU7O0FBRUE7QUFDQSw4Q0FBOEM7O0FBRTlDO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUVBQW1FO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7O0FBR0w7QUFDQTs7QUFFQTtBQUNBLHdDQUF3Qzs7QUFFeEM7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOzs7QUFHSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMEJBQTBCO0FBQzFCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7O0FBRXhCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCOztBQUUzQjtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixtQkFBbUI7QUFDbkM7O0FBRUE7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxTQUFTOzs7QUFHVDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQjtBQUNuQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOERBQThEO0FBQzlELHFEQUFxRDtBQUNyRCwyREFBMkQ7QUFDM0QsMkNBQTJDO0FBQzNDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRDs7QUFFckQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSw4Q0FBOEM7O0FBRTlDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEtBQUs7OztBQUdMO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjs7QUFFMUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDJCQUEyQjs7QUFFM0I7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDhEQUE4RDs7QUFFOUQsMkRBQTJEO0FBQzNEOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7OztBQUdUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOzs7QUFHUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbURBQW1ELHlEQUF5RDtBQUM1Ryw2QkFBNkI7O0FBRTdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7O0FBR1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5Qzs7QUFFekM7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUyx5QkFBeUI7OztBQUdsQztBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOzs7QUFHSDs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTOzs7QUFHVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzQ0FBc0M7O0FBRXRDOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNklBQTZJOztBQUU3STtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNULGtFQUFrRSw0Q0FBNEM7QUFDOUc7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7OztBQUdIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlDQUFpQztBQUNqQyxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7OztBQUdEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7OztBQUdBO0FBQ0EscURBQXFEO0FBQ3JEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtJQUFrSTtBQUNsSTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOzs7QUFHQTtBQUNBO0FBQ0EsR0FBRztBQUNIOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7OztBQUdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0lBQWtJO0FBQ2xJO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOzs7QUFHQTtBQUNBO0FBQ0EsR0FBRztBQUNIOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9DQUFvQzs7QUFFcEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4SkFBOEoseUNBQXlDO0FBQ3ZNO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7O0FBR0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxQkFBcUIsd0JBQXdCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxVQUFVLGtEQUFrRDtBQUM1RDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDZCQUE2QjtBQUN6Qzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEtBQUs7OztBQUdMLHVFQUF1RTs7QUFFdkUsVUFBVSw2QkFBNkI7QUFDdkM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTzs7O0FBR1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPO0FBQ1A7OztBQUdBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsY0FBYyxhQUFhO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxVQUFVLGlDQUFpQztBQUMzQztBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFlBQVk7QUFDeEI7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOzs7QUFHTCx1RUFBdUU7O0FBRXZFLFVBQVUsWUFBWTtBQUN0Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUzs7O0FBR1Q7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxNQUFNO0FBQ25EO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7OztBQUdMOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7OztBQUdMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EseURBQXlEO0FBQ3pEOztBQUVBLDhDQUE4QztBQUM5QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDZEQUE2RDs7QUFFN0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNkRBQTZEOztBQUU3RDtBQUNBO0FBQ0EsR0FBRztBQUNIOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBOztBQUVBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsdUNBQXVDO0FBQ3ZDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsMkNBQTJDOztBQUUzQztBQUNBO0FBQ0EsR0FBRzs7O0FBR0g7QUFDQTtBQUNBLEdBQUc7QUFDSDs7O0FBR0E7QUFDQTtBQUNBLEdBQUc7OztBQUdIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLDRIQUE0SDs7QUFFNUgsb0NBQW9DO0FBQ3BDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw0QkFBNEI7O0FBRTVCLG9DQUFvQzs7QUFFcEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBOzs7QUFHQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7O0FBR1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzQ0FBc0M7QUFDdEM7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLDJDQUEyQztBQUNoRDs7O0FBR0E7QUFDQTtBQUNBOztBQUVBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDJDQUEyQzs7QUFFM0MscUNBQXFDO0FBQ3JDO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9EQUFvRDs7QUFFcEQ7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBLGlDQUFpQztBQUNqQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7O0FBRUEsbUNBQW1DOztBQUVuQzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLEdBQUcsb0NBQW9DOztBQUV2QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDZEQUE2RDs7QUFFN0Q7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRyx1QkFBdUI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBLHlLQUF5SywwQ0FBMEM7QUFDbk47QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7OztBQUdIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7O0FBR0g7QUFDQTtBQUNBOztBQUVBLDhDQUE4QztBQUM5QztBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQzs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscUVBQXFFO0FBQ3JFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxnQkFBZ0I7QUFDekIsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRDtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0dBQWdHO0FBQ2hHO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwrQkFBK0I7O0FBRS9CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7OztBQUdIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQ0FBbUM7O0FBRW5DO0FBQ0E7QUFDQTtBQUNBLCtDQUErQzs7QUFFL0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOzs7QUFHSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7OztBQUdUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPOzs7QUFHUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0Q7QUFDaEQ7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRDs7QUFFakQ7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0EseUVBQXlFOztBQUV6RTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1DQUFtQztBQUNuQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7OztBQUdIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQzs7QUFFdEM7QUFDQSxLQUFLOzs7QUFHTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLDBDQUEwQzs7QUFFMUM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7OztBQUdIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDs7O0FBR0EsZ0RBQWdEOztBQUVoRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQzs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVCQUF1Qiw0Q0FBNEM7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DOztBQUVwQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDOztBQUVoQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7O0FBRXBDO0FBQ0EsR0FBRzs7O0FBR0gsc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DOztBQUVwQztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7O0FBR0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7O0FBR0wsd0NBQXdDOztBQUV4QztBQUNBLHNDQUFzQztBQUN0QztBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7QUFHRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOzs7QUFHSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOENBQThDOztBQUU5QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVEQUF1RDtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RDtBQUN2RDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esc0RBQXNEO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0dBQWdHO0FBQ2hHOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQ7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSCwrRkFBK0Y7QUFDL0Y7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQ0FBbUM7O0FBRW5DO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHlOQUF5TixHQUFHOztBQUU1TjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixxQkFBcUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLFlBQVk7QUFDOUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyQ0FBMkM7O0FBRTNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXOzs7QUFHWDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7O0FBR0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsK0NBQStDOztBQUUvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDs7O0FBR0E7QUFDQSx1Q0FBdUM7O0FBRXZDO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRDs7QUFFbEQ7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHlDQUF5Qzs7QUFFekM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLCtCQUErQjtBQUMvQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0EsbUhBQW1IO0FBQ25IOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTs7O0FBR0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNERBQTREOztBQUU1RDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPLG9DQUFvQztBQUMzQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtREFBbUQ7QUFDbkQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOzs7QUFHQTtBQUNBLDhDQUE4QztBQUM5QztBQUNBOztBQUVBLHFIQUFxSDs7QUFFckgsK0NBQStDO0FBQy9DOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVM7QUFDVDs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUztBQUNUOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOzs7QUFHYjtBQUNBOztBQUVBLG9EQUFvRDtBQUNwRDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsZ0RBQWdEO0FBQ2hEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhDQUE4QztBQUM5Qzs7QUFFQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNkNBQTZDOztBQUU3QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQ7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBLHFFQUFxRTs7QUFFckUsZ0VBQWdFO0FBQ2hFOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFEO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsV0FBVzs7QUFFWCxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0RBQW9EOztBQUVwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0ZBQXNGOztBQUV0RjtBQUNBO0FBQ0EsbUJBQW1COzs7QUFHbkI7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFEO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7O0FBRUEsK0RBQStEOztBQUUvRDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsdUVBQXVFOztBQUV2RTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0M7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHdEQUF3RDtBQUN4RDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsUUFBUSxJQUFJO0FBQ1o7QUFDQTtBQUNBLHVEQUF1RDtBQUN2RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7OztBQUdBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBLGdIQUFnSDtBQUNoSDtBQUNBO0FBQ0E7O0FBRUEsd0NBQXdDO0FBQ3hDLEtBQUssTUFBTSxFQUtOO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBOztBQUVBO0FBQ0EsK0NBQStDOztBQUUvQyw2QkFBNkI7QUFDN0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEM7O0FBRTlDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0NBQWtDOztBQUVsQzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUhBQXFIOztBQUVySDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSw0REFBNEQ7QUFDNUQ7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7OztBQUdBLHNFQUFzRTs7QUFFdEU7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7O0FBR0E7QUFDQSxLQUFLLGtDQUFrQztBQUN2Qzs7O0FBR0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSx5RUFBeUU7O0FBRXpFOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtEO0FBQ2xEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IseU5BQXlOLHFDQUFxQyx3RkFBd0YsMkJBQTJCLHFCQUFxQixRQUFRLFlBQVk7QUFDMVosYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0Esa0RBQWtEO0FBQ2xEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnREFBZ0Q7QUFDaEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxPQUFPLDRJQUE0STtBQUNuSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzQ0FBc0M7QUFDdEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7O0FBR0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLOzs7QUFHTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBLHFEQUFxRDs7QUFFckQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSw2QkFBNkI7O0FBRTdCO0FBQ0E7O0FBRUEsNENBQTRDO0FBQzVDOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUcsK0JBQStCO0FBQ2xDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHLCtCQUErQjtBQUNsQzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCOztBQUVBLG1DQUFtQzs7QUFFbkM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsK0NBQStDO0FBQy9DOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPOztBQUVQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3Qzs7QUFFeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsd0NBQXdDOztBQUV4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9EQUFvRDtBQUNwRDtBQUNBOztBQUVBO0FBQ0EsdUNBQXVDOztBQUV2QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNB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QUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLOzs7QUFHTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7O0FBR0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsQ0FBQztBQUNELFFBQVE7QUFDUjtBQUNBO0FBQ0E7OztBQUdBO0FBQ0EsK0NBQStDO0FBQy9DOztBQUVBLCtDQUErQzs7QUFFL0MsNEdBQTRHOztBQUU1Rzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7OztBQUdIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOzs7QUFHQTtBQUNBLEdBQUc7OztBQUdIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsMENBQTBDO0FBQzFDOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkZBQTJGOztBQUUzRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7O0FBR1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUVBQW1FOzs7QUFHbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7O0FBR1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHdDQUF3QztBQUN4Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOzs7QUFHQTtBQUNBOztBQUVBLGdDQUFnQztBQUNoQzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHOzs7QUFHSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsOENBQThDO0FBQzlDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DOztBQUVuQztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLDBEQUEwRDtBQUMxRDtBQUNBO0FBQ0E7QUFDQSxtREFBbUQ7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOzs7QUFHTDtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQSxHQUFHOzs7QUFHSDtBQUNBLDRDQUE0Qzs7QUFFNUM7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDOztBQUUzQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLHdFQUF3RTs7QUFFeEU7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0Esd0NBQXdDO0FBQ3hDO0FB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Q0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBLEdBQUc7OztBQUdIOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0Qzs7QUFFQSx5Q0FBeUM7O0FBRXpDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHlDQUF5Qzs7QUFFekM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdEQUFnRDtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxpQkFBaUIsMkJBQTJCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7O0FBR0g7QUFDQTs7QUFFQSxrQkFBa0IsMEJBQTBCO0FBQzVDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBLDJDQUEyQzs7QUFFM0M7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkJBQTJCO0FBQzNCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsd0JBQXdCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7O0FBR0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qjs7QUFFekI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOzs7QUFHQTtBQUNBO0FBQ0EsS0FBSztBQUNMOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBLG1DQUFtQztBQUNuQzs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxPQUFPLDRDQUE0QztBQUNuRDs7O0FBR0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTs7QUFFQSx3Q0FBd0M7O0FBRXhDOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87OztBQUdQOztBQUVBO0FBQ0EsNkNBQTZDO0FBQzdDOztBQUVBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEdBQThHOztBQUU5Rzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7OztBQUdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsSUFBSSxrQ0FBa0MsbUNBQW1DO0FBQzFGLDREQUE0RCxjQUFjLElBQUksZ0JBQWdCLG1DQUFtQztBQUNqSSxPQUFPO0FBQ1A7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpTUFBaU0sb0RBQW9ELEVBQUU7QUFDdlA7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsOExBQThMLG9EQUFvRCxFQUFFO0FBQ3BQLE9BQU87QUFDUDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnRkFBZ0Y7O0FBRWhGLDBDQUEwQztBQUMxQztBQUNBLDBCQUEwQjtBQUMxQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsK0VBQStFO0FBQy9FO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMLDZEQUE2RDs7QUFFN0Q7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHLEVBQUU7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx5QkFBeUI7O0FBRXpCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7O0FBR0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7O0FBR0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0NBQWdDOztBQUVoQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7OztBQUdMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7OztBQUdMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQyxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EseURBQXlEO0FBQ3pEOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7O0FBRXhCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1COztBQUVuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsK0NBQStDOztBQUUvQyx1Q0FBdUM7QUFDdkM7O0FBRUEsbUNBQW1DOztBQUVuQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQ7QUFDbkQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DOztBQUVwQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFEOztBQUVyRCx1Q0FBdUM7QUFDdkM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDOztBQUV4Qzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwyRUFBMkU7O0FBRTNFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHNFQUFzRTtBQUN0RTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUVBQXVFO0FBQ3ZFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwRUFBMEU7QUFDMUU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQ7O0FBRTdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrREFBa0Q7QUFDbEQ7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEseUVBQXlFO0FBQ3pFO0FBQ0E7O0FBRUEsNkNBQTZDO0FBQzdDOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwrREFBK0Q7O0FBRS9EO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7O0FBR0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsK0RBQStEOztBQUUvRDtBQUNBLGtDQUFrQzs7QUFFbEM7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMLHFCQUFxQix3QkFBd0I7QUFDN0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsK0RBQStELE9BQU87O0FBRXRFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJOzs7QUFHSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQSxJQUFJOzs7QUFHSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQiwyQkFBMkI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1GQUFtRjs7QUFFbkY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOzs7QUFHTDtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7OztBQUdMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGlNQUFpTSxjQUFjO0FBQy9NO0FBQ0EsR0FBRzs7O0FBR0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7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QUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGdCQUFnQjtBQUMzQjtBQUNBLFdBQVcsVUFBVTtBQUNyQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsVUFBVTtBQUNyQjtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHlCQUF5Qjs7QUFFekI7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbURBQW1EOztBQUVuRDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEVBQUU7QUFDYixXQUFXLEVBQUU7QUFDYixXQUFXLEVBQUU7QUFDYixXQUFXLGNBQWM7QUFDekIsV0FBVyxFQUFFO0FBQ2IsV0FBVyxFQUFFO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEVBQUU7QUFDYjtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxFQUFFOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLEVBQUU7QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7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QUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBOztBQUVBOztBQUVBLDJCQUEyQjs7QUFFM0I7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7O0FBR0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOzs7QUFHTDtBQUNBLHlDQUF5QztBQUN6Qzs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDOztBQUV0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTs7QUFFUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7O0FBRVI7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQSxTQUFTO0FBQ1Qsd0JBQXdCO0FBQ3hCO0FBQ0EsU0FBUztBQUNULHdCQUF3QjtBQUN4QjtBQUNBLFNBQVM7QUFDVCx5QkFBeUI7QUFDekI7QUFDQSxTQUFTO0FBQ1QseUJBQXlCO0FBQ3pCO0FBQ0EsU0FBUztBQUNULGtDQUFrQztBQUNsQztBQUNBLFNBQVM7QUFDVCw0QkFBNEI7QUFDNUI7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7OztBQUdMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwwREFBMEQ7O0FBRTFEO0FBQ0E7O0FBRUE7QUFDQSwwREFBMEQ7QUFDMUQ7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7OztBQUdSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFlBQVksa0JBQWtCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCOzs7QUFHakI7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7OztBQUdIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwSEFBMEg7QUFDMUg7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxtRUFBbUU7O0FBRW5FO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxhQUFhO0FBQ3hCLFdBQVcsRUFBRTtBQUNiOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSwwREFBMEQ7QUFDMUQ7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsVUFBVTtBQUNyQixXQUFXLEVBQUU7QUFDYjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQkFBbUIsaUJBQWlCO0FBQ3BDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsYUFBYTtBQUN4Qjs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLDJDQUEyQzs7QUFFM0M7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsYUFBYTtBQUN4Qjs7O0FBR0E7QUFDQTtBQUNBOztBQUVBLG1CQUFtQixpQkFBaUI7QUFDcEM7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0M7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFEQUFxRDtBQUNyRDs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBLG1CQUFtQixzQkFBc0I7QUFDekM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7O0FBR0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlCQUFpQixzQkFBc0I7QUFDdkM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSx1Q0FBdUM7QUFDdkM7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZ0JBQWdCO0FBQ2hCLGlCQUFpQjtBQUNqQixxQkFBcUI7QUFDckIsMERBQTBEO0FBQzFELG9CQUFvQjtBQUNwQixxQkFBcUI7QUFDckIscUJBQXFCO0FBQ3JCLHFCQUFxQjtBQUNyQixpQkFBaUI7QUFDakIsa0JBQWtCO0FBQ2xCLHNCQUFzQjtBQUN0QixZQUFZO0FBQ1osWUFBWTtBQUNaLG1CQUFtQjtBQUNuQixrQkFBa0I7QUFDbEIscUJBQXFCO0FBQ3JCLGlCQUFpQjtBQUNqQiwyQkFBMkI7QUFDM0IsdUJBQXVCO0FBQ3ZCLGVBQWU7QUFDZixrQkFBa0I7QUFDbEIsY0FBYztBQUNkLGdCQUFnQjtBQUNoQixlQUFlO0FBQ2YsR0FBRztBQUNIOzs7Ozs7Ozs7Ozs7QUM1eEVhOztBQUViLElBQUksS0FBcUMsRUFBRSxFQUUxQztBQUNELEVBQUUsdUhBQXNEO0FBQ3hEOzs7Ozs7Ozs7Ozs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVhOztBQUViLElBQUksSUFBcUM7QUFDekM7QUFDQTs7QUFFQSwwQkFBMEI7O0FBRTFCO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTs7QUFFQSx5QkFBeUIsUUFBUTs7QUFFakMsdUJBQXVCOztBQUV2QjtBQUNBLEVBQUUseUJBQXlCO0FBQzNCO0FBQ0E7QUFDQSxFQUFFLHVCQUF1QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUUsaUNBQWlDOztBQUVuQztBQUNBO0FBQ0EsR0FBRztBQUNILElBQUksaUNBQWlDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQ7QUFDM0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRSxpQ0FBaUM7QUFDbkM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsT0FBTztBQUNQLFFBQVEsaUNBQWlDOztBQUV6QztBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxnQ0FBZ0M7QUFDaEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIOzs7QUFHQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQSxJQUFJLGlDQUFpQztBQUNyQzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsVUFBVSxpQ0FBaUM7O0FBRTNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQU0sK0JBQStCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBTSwrQkFBK0I7QUFDckM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHNCQUFzQjtBQUN0QiwyQkFBMkI7QUFDM0IsNEJBQTRCO0FBQzVCLDBCQUEwQjtBQUMxQixzQkFBc0I7QUFDdEIsNEJBQTRCO0FBQzVCLHFCQUFxQjtBQUNyQixHQUFHO0FBQ0g7Ozs7Ozs7Ozs7OztBQzFWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVhOztBQUViLElBQUksSUFBcUM7QUFDekM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxFQUFFLG9CQUFvQjtBQUN0QjtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7O0FBRUEsRUFBRSxvQkFBb0I7QUFDdEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsRUFBRSw0QkFBNEI7QUFDOUI7QUFDQTs7QUFFQSxpQkFBaUIsK0JBQStCO0FBQ2hELENBQUM7QUFDRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0EsOEJBQThCOztBQUU5QjtBQUNBLG1CQUFtQjs7QUFFbkI7QUFDQTtBQUNBO0FBQ0EsSUFBSSw0QkFBNEI7QUFDaEM7QUFDQSxNQUFNOzs7QUFHTjtBQUNBOztBQUVBLEVBQUUsK0JBQStCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQzs7QUFFakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxtQ0FBbUM7O0FBRW5DLG9DQUFvQzs7QUFFcEM7QUFDQTtBQUNBLGlDQUFpQzs7QUFFakMsOENBQThDOztBQUU5QztBQUNBLG9CQUFvQjs7QUFFcEIsc0JBQXNCO0FBQ3RCO0FBQ0EsMENBQTBDOztBQUUxQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBLEdBQUc7OztBQUdIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPOzs7QUFHUDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLDZCQUE2QjtBQUM3QixrQ0FBa0M7QUFDbEMsNEJBQTRCO0FBQzVCLCtCQUErQjtBQUMvQiwwQkFBMEI7QUFDMUIscUNBQXFDO0FBQ3JDLCtCQUErQjtBQUMvQixrQ0FBa0M7QUFDbEMsd0NBQXdDO0FBQ3hDLHFDQUFxQztBQUNyQyxxQkFBcUI7QUFDckIsK0JBQStCO0FBQy9CLDZCQUE2QjtBQUM3QixnQ0FBZ0M7QUFDaEMsaUNBQWlDO0FBQ2pDLDZCQUE2QjtBQUM3QixHQUFHO0FBQ0g7Ozs7Ozs7Ozs7OztBQ3JvQmE7O0FBRWIsSUFBSSxLQUFxQyxFQUFFLEVBRTFDO0FBQ0QsRUFBRSxtSUFBMEQ7QUFDNUQ7Ozs7Ozs7Ozs7OztBQ05hOztBQUViLElBQUksS0FBcUMsRUFBRSxFQUUxQztBQUNELEVBQUUsbUpBQWtFO0FBQ3BFOzs7Ozs7Ozs7Ozs7QUNOYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVEOztBQUV2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTs7QUFFQSxpQkFBaUIsd0JBQXdCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCLGlCQUFpQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0JBQWdCLEtBQXdDLEdBQUcsc0JBQWlCLEdBQUcsQ0FBSTs7QUFFbkY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0EscUVBQXFFLHFCQUFxQixhQUFhOztBQUV2Rzs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0EseURBQXlEO0FBQ3pELEdBQUc7O0FBRUg7OztBQUdBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwwQkFBMEI7QUFDMUI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIsNEJBQTRCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLG9CQUFvQiw2QkFBNkI7QUFDakQ7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEU7Ozs7Ozs7Ozs7O0FDNVFhOztBQUViLFlBQVksbUJBQU8sQ0FBQyw0Q0FBTzs7QUFFM0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0EsNkJBQTZCOzs7Ozs7Ozs7OztBQzdCN0IsVUFBVSxtQkFBTyxDQUFDLG9KQUF3RTtBQUMxRiwwQkFBMEIsbUJBQU8sQ0FBQywwVEFBMEo7O0FBRTVMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOzs7O0FBSUEsc0M7Ozs7OztVQ2xCQTtVQUNBOztVQUVBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBOztVQUVBO1VBQ0E7O1VBRUE7VUFDQTtVQUNBOzs7OztXQ3RCQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0EsZ0NBQWdDLFlBQVk7V0FDNUM7V0FDQSxFOzs7OztXQ1BBO1dBQ0E7V0FDQTtXQUNBO1dBQ0Esd0NBQXdDLHlDQUF5QztXQUNqRjtXQUNBO1dBQ0EsRTs7Ozs7V0NQQSx3Rjs7Ozs7V0NBQTtXQUNBO1dBQ0E7V0FDQSxzREFBc0Qsa0JBQWtCO1dBQ3hFO1dBQ0EsK0NBQStDLGNBQWM7V0FDN0QsRTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNONkM7QUFDYztBQUMxQjtBQUNYO0FBQ3dCO0FBRTlDLE1BQU0sU0FBUyxHQUFHLEdBQUcsRUFBRTtJQUNyQixNQUFNLENBQUMsT0FBTyxFQUFFLFVBQVUsQ0FBQyxHQUFHLCtDQUFRLEVBQThCLENBQUM7SUFDckUsTUFBTSxDQUFDLEtBQUssRUFBRSxRQUFRLENBQUMsR0FBRywrQ0FBUSxDQUFTLEVBQUUsQ0FBQyxDQUFDO0lBQy9DLHVEQUFjLENBQUMsQ0FBTyxPQUFPLEVBQUUsRUFBRTs7UUFDL0IsSUFBSTtZQUNGLE1BQU0sRUFBRSxHQUFHLE1BQU0sa0VBQXlCLENBQUM7Z0JBQ3pDLE1BQU0sRUFDSixVQUFJLGVBQWUsQ0FBQyxNQUFNLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBQyxDQUFDLEdBQUcsQ0FBQyxTQUFTLENBQUMsbUNBQUksRUFBRTtnQkFDbEUsVUFBVSxFQUFFLGdCQUFnQjtnQkFDNUIsdUJBQXVCLEVBQUUsQ0FBQyxFQUFFLEVBQUUsS0FBSyxFQUFFLEVBQUU7b0JBQ3JDLFVBQVUsQ0FBQyxTQUFTLENBQUMsQ0FBQztnQkFDeEIsQ0FBQztnQkFDRCxtQkFBbUIsRUFBRSxDQUFDLEVBQUUsRUFBRSxPQUFPLEVBQUUsRUFBRTtvQkFDbkMsT0FBTyxDQUFDLE1BQU0sRUFBRSxDQUFDO2dCQUNuQixDQUFDO2dCQUNELGFBQWEsRUFBRSxHQUFHLEVBQUUsR0FBRSxDQUFDO2dCQUN2QixpQkFBaUIsRUFBRSxHQUFHLEVBQUUsR0FBRSxDQUFDO2dCQUMzQixXQUFXLEVBQUUsQ0FBQyxFQUFFLEVBQUUsSUFBSSxFQUFFLEtBQUssRUFBRSxFQUFFO29CQUMvQixPQUFPLENBQUMsSUFBSSxDQUFDLGFBQWEsRUFBRSxJQUFJLEVBQUUsS0FBSyxDQUFDLENBQUM7Z0JBQzNDLENBQUM7Z0JBQ0QsaUJBQWlCLEVBQUUsQ0FBQyxFQUFFLEVBQUUsSUFBSSxFQUFFLEtBQUssRUFBRSxFQUFFO29CQUNyQyxPQUFPLENBQUMsR0FBRyxDQUFDLFFBQVEsSUFBSSxDQUFDLE1BQU0sc0JBQXNCLEtBQUssRUFBRSxDQUFDLENBQUM7Z0JBQ2hFLENBQUM7Z0JBQ0Qsb0JBQW9CLEVBQUUsR0FBRyxFQUFFLEdBQUUsQ0FBQztnQkFDOUIsWUFBWSxFQUFFLEdBQUcsRUFBRSxHQUFFLENBQUM7Z0JBQ3RCLE9BQU8sRUFBRSxHQUFHLEVBQUUsR0FBRSxDQUFDO2FBQ2xCLENBQUMsQ0FBQztZQUNILElBQUksQ0FBQyxPQUFPLEVBQUU7Z0JBQUUsT0FBTztZQUN2QixVQUFVLENBQUMsRUFBRSxDQUFDLENBQUM7U0FDaEI7UUFBQyxPQUFPLENBQUMsRUFBRTtZQUNWLFFBQVEsQ0FBRSxDQUFXLENBQUMsT0FBTyxDQUFDLENBQUM7WUFDL0IsT0FBTyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQztTQUNoQjtJQUNILENBQUMsRUFBQyxDQUFDO0lBQ0gsT0FBTyxDQUNMLDJEQUFNLFNBQVMsRUFBQyx5QkFBeUIsSUFDdEMsS0FBSyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsWUFBWSxDQUFDLENBQUMsQ0FBQyxhQUFhLENBQ2xELENBQ1IsQ0FBQztBQUNKLENBQUMsQ0FBQztBQUVGLDZDQUFlLENBQ2IsaURBQUMsNkNBQWdCO0lBQ2YsaURBQUMsU0FBUyxPQUFHLENBQ0ksRUFDbkIsUUFBUSxDQUFDLGNBQWMsQ0FBQyxZQUFZLENBQUMsQ0FDdEMsQ0FBQyIsImZpbGUiOiJidW5kbGUucXVpY2suZGZlMDNjNGI2NTBhZTc2MGNiNTkuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBJbXBvcnRzXG52YXIgX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fID0gcmVxdWlyZShcIi4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9hcGkuanNcIik7XG5leHBvcnRzID0gX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fKGZhbHNlKTtcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIkBpbXBvcnQgdXJsKGh0dHBzOi8vZm9udHMuZ29vZ2xlYXBpcy5jb20vY3NzMj9mYW1pbHk9SW50ZXI6d2dodEA0MDA7NTAwOzYwMDs3MDAmZmFtaWx5PVF1ZXN0cmlhbCZmYW1pbHk9UG9wcGluczp3Z2h0QDQwMDs1MDA7NjAwJmZhbWlseT1CYXJsb3c6d2dodEA0MDA7NTAwOzYwMDs3MDAmZGlzcGxheT1zd2FwKTtcIl0pO1xuLy8gTW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCI6cm9vdCB7XFxuICAtLWxvZ28tZm9udC1mYW1pbHk6IFxcXCJQb3BwaW5zXFxcIiwgc2Fucy1zZXJpZjtcXG4gIC0tYm9keS1mb250LWZhbWlseTogXFxcIkludGVyXFxcIiwgc2Fucy1zZXJpZjtcXG4gIC0taGVhZGluZy1mb250LWZhbWlseTogXFxcIlBvcHBpbnNcXFwiLCBzYW5zLXNlcmlmO1xcbiAgLS1oZWFkZXItZm9udC1mYW1pbHk6IFxcXCJRdWVzdHJpYWxcXFwiLCBzYW5zLXNlcmlmO1xcblxcbiAgLyogU2xhdGUgQmx1ZSAqL1xcbiAgLS1jbHItcHJpbWFyeS0xMDA6ICNlMGUyZjQ7XFxuICAtLWNsci1wcmltYXJ5LTIwMDogI2JmYzNlYztcXG4gIC0tY2xyLXByaW1hcnktMzAwOiAjOWZhN2UyO1xcbiAgLS1jbHItcHJpbWFyeS00MDA6ICM3ZTg5ZDg7XFxuICAtLWNsci1wcmltYXJ5LTUwMDogIzYxNmFjYjtcXG4gIC0tY2xyLXByaW1hcnktNjAwOiAjNDg1NGJiO1xcbiAgLS1jbHItcHJpbWFyeS03MDA6ICMzOTQzYTI7XFxuICAtLWNsci1wcmltYXJ5LTgwMDogIzJmMzg4NTtcXG4gIC0tY2xyLXByaW1hcnktOTAwOiAjMjQyYjY3O1xcbiAgLS1jbHItcHJpbWFyeS05NTA6ICMxOTFlNGQ7XFxuICAtLWNsci1wcmltYXJ5LTk3NTogIzBmMTIyZTtcXG4gIC0tY2xyLXByaW1hcnktOTk5OiAjMDUwNjBmO1xcblxcbiAgLyogTWFudGlzICovXFxuICAtLWNsci1ncmVlbi0xMDA6ICNmNGZiZjA7XFxuICAtLWNsci1ncmVlbi0yMDA6ICNkZmYxZDI7XFxuICAtLWNsci1ncmVlbi0zMDA6ICNiZmUyYTY7XFxuICAtLWNsci1ncmVlbi00MDA6ICNhMGQ1N2I7XFxuICAtLWNsci1ncmVlbi01MDA6ICM4Y2NjNjE7XFxuICAtLWNsci1ncmVlbi02MDA6ICM2ZmFkNDU7XFxuICAtLWNsci1ncmVlbi03MDA6ICM1YjhkMzg7XFxuICAtLWNsci1ncmVlbi04MDA6ICMzMzU3MWM7XFxuICAtLWNsci1ncmVlbi05MDA6ICMxZTJmMTI7XFxuXFxuICAvKiBEYW5kZWxpb24gKi9cXG4gIC0tY2xyLXllbGxvdy0xMDA6ICNmZmZkZjE7XFxuICAtLWNsci15ZWxsb3ctMjAwOiAjZmRmN2RiO1xcbiAgLS1jbHIteWVsbG93LTMwMDogI2ZhZWRiNztcXG4gIC0tY2xyLXllbGxvdy00MDA6ICNmN2U2OTU7XFxuICAtLWNsci15ZWxsb3ctNTAwOiAjZjlkYzVjO1xcbiAgLS1jbHIteWVsbG93LTYwMDogI2U1YzM0MztcXG4gIC0tY2xyLXllbGxvdy03MDA6ICM5ZjgwMDQ7XFxuICAtLWNsci15ZWxsb3ctODAwOiAjNTA0MTAyO1xcbiAgLS1jbHIteWVsbG93LTkwMDogIzI4MjAwMTtcXG5cXG4gIC8qIFRvbWF0byAqL1xcbiAgLS1jbHItcmVkLTEwMDogI2ZmZjVmMztcXG4gIC0tY2xyLXJlZC0yMDA6ICNmYmRlZDg7XFxuICAtLWNsci1yZWQtMzAwOiAjZjBiNWE5O1xcbiAgLS1jbHItcmVkLTQwMDogI2ZhOTI3YjtcXG4gIC0tY2xyLXJlZC01MDA6ICNmYzY5NDg7XFxuICAtLWNsci1yZWQtNjAwOiAjZTk1MDJmO1xcbiAgLS1jbHItcmVkLTcwMDogI2NiMzQxMztcXG4gIC0tY2xyLXJlZC04MDA6ICNhMzAzMDM7XFxuICAtLWNsci1yZWQtOTAwOiAjNWMxMTExO1xcblxcbiAgLyogTmV1dHJhbHMgKi9cXG4gIC0tY2xyLW5ldXRyYWwtMDogI2ZmZmZmZjtcXG4gIC0tY2xyLW5ldXRyYWwtNTA6ICNmNGY0ZjY7XFxuICAtLWNsci1uZXV0cmFsLTEwMDogI2U5ZTllYztcXG4gIC0tY2xyLW5ldXRyYWwtMjAwOiAjZDNkM2Q5O1xcbiAgLS1jbHItbmV1dHJhbC0zMDA6ICNiM2IzYmM7XFxuICAtLWNsci1uZXV0cmFsLTQwMDogIzlkOWRhOTtcXG4gIC0tY2xyLW5ldXRyYWwtNDUwOiAjODY4Njk1O1xcbiAgLS1jbHItbmV1dHJhbC01MDA6ICM2ODY4Nzc7XFxuICAtLWNsci1uZXV0cmFsLTYwMDogIzVmNWY2YztcXG4gIC0tY2xyLW5ldXRyYWwtNzAwOiAjNGM0YzU2O1xcbiAgLS1jbHItbmV1dHJhbC04MDA6ICMzOTM5NDE7XFxuICAtLWNsci1uZXV0cmFsLTg1MDogIzJjMmMzMztcXG4gIC0tY2xyLW5ldXRyYWwtOTAwOiAjMjYyNjJjO1xcbiAgLS1jbHItbmV1dHJhbC05MjU6ICMxZTFlMjM7XFxuICAtLWNsci1uZXV0cmFsLTk1MDogIzEzMTMxNjtcXG4gIC0tY2xyLW5ldXRyYWwtOTc1OiAjMDkwOTBiO1xcbiAgLS1jbHItbmV1dHJhbC05OTA6ICMwNDA0MDU7XFxuICAtLWNsci1uZXV0cmFsLTEwMDA6ICMwMDAwMDA7XFxufVxcblxcbi5zcGFjZXIge1xcbiAgZmxleC1ncm93OiAxO1xcbn1cXG5cXG4vKiogTWFyZ2luIGFuZCBQYWRkaW5nIGhlbHBlcnMgKi9cXG4ubS10LTAge1xcbiAgbWFyZ2luLXRvcDogMHB4ICFpbXBvcnRhbnQ7XFxufVxcbi5wLXQtMCB7XFxuICBwYWRkaW5nLXRvcDogMHB4ICFpbXBvcnRhbnQ7XFxufVxcbi5tLWItMCB7XFxuICBtYXJnaW4tYm90dG9tOiAwcHggIWltcG9ydGFudDtcXG59XFxuLnAtYi0wIHtcXG4gIHBhZGRpbmctYm90dG9tOiAwcHggIWltcG9ydGFudDtcXG59XFxuLm0tbC0wIHtcXG4gIG1hcmdpbi1sZWZ0OiAwcHggIWltcG9ydGFudDtcXG59XFxuLnAtbC0wIHtcXG4gIHBhZGRpbmctbGVmdDogMHB4ICFpbXBvcnRhbnQ7XFxufVxcbi5tLXItMCB7XFxuICBtYXJnaW4tcmlnaHQ6IDBweCAhaW1wb3J0YW50O1xcbn1cXG4ucC1yLTAge1xcbiAgcGFkZGluZy1yaWdodDogMHB4ICFpbXBvcnRhbnQ7XFxufVxcbi5tLXQtNCB7XFxuICBtYXJnaW4tdG9wOiA0cHggIWltcG9ydGFudDtcXG59XFxuLnAtdC00IHtcXG4gIHBhZGRpbmctdG9wOiA0cHggIWltcG9ydGFudDtcXG59XFxuLm0tYi00IHtcXG4gIG1hcmdpbi1ib3R0b206IDRweCAhaW1wb3J0YW50O1xcbn1cXG4ucC1iLTQge1xcbiAgcGFkZGluZy1ib3R0b206IDRweCAhaW1wb3J0YW50O1xcbn1cXG4ubS1sLTQge1xcbiAgbWFyZ2luLWxlZnQ6IDRweCAhaW1wb3J0YW50O1xcbn1cXG4ucC1sLTQge1xcbiAgcGFkZGluZy1sZWZ0OiA0cHggIWltcG9ydGFudDtcXG59XFxuLm0tci00IHtcXG4gIG1hcmdpbi1yaWdodDogNHB4ICFpbXBvcnRhbnQ7XFxufVxcbi5wLXItNCB7XFxuICBwYWRkaW5nLXJpZ2h0OiA0cHggIWltcG9ydGFudDtcXG59XFxuLm0tdC04IHtcXG4gIG1hcmdpbi10b3A6IDhweCAhaW1wb3J0YW50O1xcbn1cXG4ucC10LTgge1xcbiAgcGFkZGluZy10b3A6IDhweCAhaW1wb3J0YW50O1xcbn1cXG4ubS1iLTgge1xcbiAgbWFyZ2luLWJvdHRvbTogOHB4ICFpbXBvcnRhbnQ7XFxufVxcbi5wLWItOCB7XFxuICBwYWRkaW5nLWJvdHRvbTogOHB4ICFpbXBvcnRhbnQ7XFxufVxcbi5tLWwtOCB7XFxuICBtYXJnaW4tbGVmdDogOHB4ICFpbXBvcnRhbnQ7XFxufVxcbi5wLWwtOCB7XFxuICBwYWRkaW5nLWxlZnQ6IDhweCAhaW1wb3J0YW50O1xcbn1cXG4ubS1yLTgge1xcbiAgbWFyZ2luLXJpZ2h0OiA4cHggIWltcG9ydGFudDtcXG59XFxuLnAtci04IHtcXG4gIHBhZGRpbmctcmlnaHQ6IDhweCAhaW1wb3J0YW50O1xcbn1cXG4ubS10LTE2IHtcXG4gIG1hcmdpbi10b3A6IDE2cHggIWltcG9ydGFudDtcXG59XFxuLnAtdC0xNiB7XFxuICBwYWRkaW5nLXRvcDogMTZweCAhaW1wb3J0YW50O1xcbn1cXG4ubS1iLTE2IHtcXG4gIG1hcmdpbi1ib3R0b206IDE2cHggIWltcG9ydGFudDtcXG59XFxuLnAtYi0xNiB7XFxuICBwYWRkaW5nLWJvdHRvbTogMTZweCAhaW1wb3J0YW50O1xcbn1cXG4ubS1sLTE2IHtcXG4gIG1hcmdpbi1sZWZ0OiAxNnB4ICFpbXBvcnRhbnQ7XFxufVxcbi5wLWwtMTYge1xcbiAgcGFkZGluZy1sZWZ0OiAxNnB4ICFpbXBvcnRhbnQ7XFxufVxcbi5tLXItMTYge1xcbiAgbWFyZ2luLXJpZ2h0OiAxNnB4ICFpbXBvcnRhbnQ7XFxufVxcbi5wLXItMTYge1xcbiAgcGFkZGluZy1yaWdodDogMTZweCAhaW1wb3J0YW50O1xcbn1cXG4ubS10LTI0IHtcXG4gIG1hcmdpbi10b3A6IDI0cHggIWltcG9ydGFudDtcXG59XFxuLnAtdC0yNCB7XFxuICBwYWRkaW5nLXRvcDogMjRweCAhaW1wb3J0YW50O1xcbn1cXG4ubS1iLTI0IHtcXG4gIG1hcmdpbi1ib3R0b206IDI0cHggIWltcG9ydGFudDtcXG59XFxuLnAtYi0yNCB7XFxuICBwYWRkaW5nLWJvdHRvbTogMjRweCAhaW1wb3J0YW50O1xcbn1cXG4ubS1sLTI0IHtcXG4gIG1hcmdpbi1sZWZ0OiAyNHB4ICFpbXBvcnRhbnQ7XFxufVxcbi5wLWwtMjQge1xcbiAgcGFkZGluZy1sZWZ0OiAyNHB4ICFpbXBvcnRhbnQ7XFxufVxcbi5tLXItMjQge1xcbiAgbWFyZ2luLXJpZ2h0OiAyNHB4ICFpbXBvcnRhbnQ7XFxufVxcbi5wLXItMjQge1xcbiAgcGFkZGluZy1yaWdodDogMjRweCAhaW1wb3J0YW50O1xcbn1cXG4ubS10LTMyIHtcXG4gIG1hcmdpbi10b3A6IDMycHggIWltcG9ydGFudDtcXG59XFxuLnAtdC0zMiB7XFxuICBwYWRkaW5nLXRvcDogMzJweCAhaW1wb3J0YW50O1xcbn1cXG4ubS1iLTMyIHtcXG4gIG1hcmdpbi1ib3R0b206IDMycHggIWltcG9ydGFudDtcXG59XFxuLnAtYi0zMiB7XFxuICBwYWRkaW5nLWJvdHRvbTogMzJweCAhaW1wb3J0YW50O1xcbn1cXG4ubS1sLTMyIHtcXG4gIG1hcmdpbi1sZWZ0OiAzMnB4ICFpbXBvcnRhbnQ7XFxufVxcbi5wLWwtMzIge1xcbiAgcGFkZGluZy1sZWZ0OiAzMnB4ICFpbXBvcnRhbnQ7XFxufVxcbi5tLXItMzIge1xcbiAgbWFyZ2luLXJpZ2h0OiAzMnB4ICFpbXBvcnRhbnQ7XFxufVxcbi5wLXItMzIge1xcbiAgcGFkZGluZy1yaWdodDogMzJweCAhaW1wb3J0YW50O1xcbn1cXG4ubS10LTQwIHtcXG4gIG1hcmdpbi10b3A6IDQwcHggIWltcG9ydGFudDtcXG59XFxuLnAtdC00MCB7XFxuICBwYWRkaW5nLXRvcDogNDBweCAhaW1wb3J0YW50O1xcbn1cXG4ubS1iLTQwIHtcXG4gIG1hcmdpbi1ib3R0b206IDQwcHggIWltcG9ydGFudDtcXG59XFxuLnAtYi00MCB7XFxuICBwYWRkaW5nLWJvdHRvbTogNDBweCAhaW1wb3J0YW50O1xcbn1cXG4ubS1sLTQwIHtcXG4gIG1hcmdpbi1sZWZ0OiA0MHB4ICFpbXBvcnRhbnQ7XFxufVxcbi5wLWwtNDAge1xcbiAgcGFkZGluZy1sZWZ0OiA0MHB4ICFpbXBvcnRhbnQ7XFxufVxcbi5tLXItNDAge1xcbiAgbWFyZ2luLXJpZ2h0OiA0MHB4ICFpbXBvcnRhbnQ7XFxufVxcbi5wLXItNDAge1xcbiAgcGFkZGluZy1yaWdodDogNDBweCAhaW1wb3J0YW50O1xcbn1cXG4ubS10LTQ4IHtcXG4gIG1hcmdpbi10b3A6IDQ4cHggIWltcG9ydGFudDtcXG59XFxuLnAtdC00OCB7XFxuICBwYWRkaW5nLXRvcDogNDhweCAhaW1wb3J0YW50O1xcbn1cXG4ubS1iLTQ4IHtcXG4gIG1hcmdpbi1ib3R0b206IDQ4cHggIWltcG9ydGFudDtcXG59XFxuLnAtYi00OCB7XFxuICBwYWRkaW5nLWJvdHRvbTogNDhweCAhaW1wb3J0YW50O1xcbn1cXG4ubS1sLTQ4IHtcXG4gIG1hcmdpbi1sZWZ0OiA0OHB4ICFpbXBvcnRhbnQ7XFxufVxcbi5wLWwtNDgge1xcbiAgcGFkZGluZy1sZWZ0OiA0OHB4ICFpbXBvcnRhbnQ7XFxufVxcbi5tLXItNDgge1xcbiAgbWFyZ2luLXJpZ2h0OiA0OHB4ICFpbXBvcnRhbnQ7XFxufVxcbi5wLXItNDgge1xcbiAgcGFkZGluZy1yaWdodDogNDhweCAhaW1wb3J0YW50O1xcbn1cXG4ubS10LTU2IHtcXG4gIG1hcmdpbi10b3A6IDU2cHggIWltcG9ydGFudDtcXG59XFxuLnAtdC01NiB7XFxuICBwYWRkaW5nLXRvcDogNTZweCAhaW1wb3J0YW50O1xcbn1cXG4ubS1iLTU2IHtcXG4gIG1hcmdpbi1ib3R0b206IDU2cHggIWltcG9ydGFudDtcXG59XFxuLnAtYi01NiB7XFxuICBwYWRkaW5nLWJvdHRvbTogNTZweCAhaW1wb3J0YW50O1xcbn1cXG4ubS1sLTU2IHtcXG4gIG1hcmdpbi1sZWZ0OiA1NnB4ICFpbXBvcnRhbnQ7XFxufVxcbi5wLWwtNTYge1xcbiAgcGFkZGluZy1sZWZ0OiA1NnB4ICFpbXBvcnRhbnQ7XFxufVxcbi5tLXItNTYge1xcbiAgbWFyZ2luLXJpZ2h0OiA1NnB4ICFpbXBvcnRhbnQ7XFxufVxcbi5wLXItNTYge1xcbiAgcGFkZGluZy1yaWdodDogNTZweCAhaW1wb3J0YW50O1xcbn1cXG4ubS10LTY0IHtcXG4gIG1hcmdpbi10b3A6IDY0cHggIWltcG9ydGFudDtcXG59XFxuLnAtdC02NCB7XFxuICBwYWRkaW5nLXRvcDogNjRweCAhaW1wb3J0YW50O1xcbn1cXG4ubS1iLTY0IHtcXG4gIG1hcmdpbi1ib3R0b206IDY0cHggIWltcG9ydGFudDtcXG59XFxuLnAtYi02NCB7XFxuICBwYWRkaW5nLWJvdHRvbTogNjRweCAhaW1wb3J0YW50O1xcbn1cXG4ubS1sLTY0IHtcXG4gIG1hcmdpbi1sZWZ0OiA2NHB4ICFpbXBvcnRhbnQ7XFxufVxcbi5wLWwtNjQge1xcbiAgcGFkZGluZy1sZWZ0OiA2NHB4ICFpbXBvcnRhbnQ7XFxufVxcbi5tLXItNjQge1xcbiAgbWFyZ2luLXJpZ2h0OiA2NHB4ICFpbXBvcnRhbnQ7XFxufVxcbi5wLXItNjQge1xcbiAgcGFkZGluZy1yaWdodDogNjRweCAhaW1wb3J0YW50O1xcbn1cXG4ubS10LTcyIHtcXG4gIG1hcmdpbi10b3A6IDcycHggIWltcG9ydGFudDtcXG59XFxuLnAtdC03MiB7XFxuICBwYWRkaW5nLXRvcDogNzJweCAhaW1wb3J0YW50O1xcbn1cXG4ubS1iLTcyIHtcXG4gIG1hcmdpbi1ib3R0b206IDcycHggIWltcG9ydGFudDtcXG59XFxuLnAtYi03MiB7XFxuICBwYWRkaW5nLWJvdHRvbTogNzJweCAhaW1wb3J0YW50O1xcbn1cXG4ubS1sLTcyIHtcXG4gIG1hcmdpbi1sZWZ0OiA3MnB4ICFpbXBvcnRhbnQ7XFxufVxcbi5wLWwtNzIge1xcbiAgcGFkZGluZy1sZWZ0OiA3MnB4ICFpbXBvcnRhbnQ7XFxufVxcbi5tLXItNzIge1xcbiAgbWFyZ2luLXJpZ2h0OiA3MnB4ICFpbXBvcnRhbnQ7XFxufVxcbi5wLXItNzIge1xcbiAgcGFkZGluZy1yaWdodDogNzJweCAhaW1wb3J0YW50O1xcbn1cXG4ubS10LTgwIHtcXG4gIG1hcmdpbi10b3A6IDgwcHggIWltcG9ydGFudDtcXG59XFxuLnAtdC04MCB7XFxuICBwYWRkaW5nLXRvcDogODBweCAhaW1wb3J0YW50O1xcbn1cXG4ubS1iLTgwIHtcXG4gIG1hcmdpbi1ib3R0b206IDgwcHggIWltcG9ydGFudDtcXG59XFxuLnAtYi04MCB7XFxuICBwYWRkaW5nLWJvdHRvbTogODBweCAhaW1wb3J0YW50O1xcbn1cXG4ubS1sLTgwIHtcXG4gIG1hcmdpbi1sZWZ0OiA4MHB4ICFpbXBvcnRhbnQ7XFxufVxcbi5wLWwtODAge1xcbiAgcGFkZGluZy1sZWZ0OiA4MHB4ICFpbXBvcnRhbnQ7XFxufVxcbi5tLXItODAge1xcbiAgbWFyZ2luLXJpZ2h0OiA4MHB4ICFpbXBvcnRhbnQ7XFxufVxcbi5wLXItODAge1xcbiAgcGFkZGluZy1yaWdodDogODBweCAhaW1wb3J0YW50O1xcbn1cXG4ubS10LTEyMCB7XFxuICBtYXJnaW4tdG9wOiAxMjBweCAhaW1wb3J0YW50O1xcbn1cXG4ucC10LTEyMCB7XFxuICBwYWRkaW5nLXRvcDogMTIwcHggIWltcG9ydGFudDtcXG59XFxuLm0tYi0xMjAge1xcbiAgbWFyZ2luLWJvdHRvbTogMTIwcHggIWltcG9ydGFudDtcXG59XFxuLnAtYi0xMjAge1xcbiAgcGFkZGluZy1ib3R0b206IDEyMHB4ICFpbXBvcnRhbnQ7XFxufVxcbi5tLWwtMTIwIHtcXG4gIG1hcmdpbi1sZWZ0OiAxMjBweCAhaW1wb3J0YW50O1xcbn1cXG4ucC1sLTEyMCB7XFxuICBwYWRkaW5nLWxlZnQ6IDEyMHB4ICFpbXBvcnRhbnQ7XFxufVxcbi5tLXItMTIwIHtcXG4gIG1hcmdpbi1yaWdodDogMTIwcHggIWltcG9ydGFudDtcXG59XFxuLnAtci0xMjAge1xcbiAgcGFkZGluZy1yaWdodDogMTIwcHggIWltcG9ydGFudDtcXG59XFxuLm0tdC0xNjAge1xcbiAgbWFyZ2luLXRvcDogMTYwcHggIWltcG9ydGFudDtcXG59XFxuLnAtdC0xNjAge1xcbiAgcGFkZGluZy10b3A6IDE2MHB4ICFpbXBvcnRhbnQ7XFxufVxcbi5tLWItMTYwIHtcXG4gIG1hcmdpbi1ib3R0b206IDE2MHB4ICFpbXBvcnRhbnQ7XFxufVxcbi5wLWItMTYwIHtcXG4gIHBhZGRpbmctYm90dG9tOiAxNjBweCAhaW1wb3J0YW50O1xcbn1cXG4ubS1sLTE2MCB7XFxuICBtYXJnaW4tbGVmdDogMTYwcHggIWltcG9ydGFudDtcXG59XFxuLnAtbC0xNjAge1xcbiAgcGFkZGluZy1sZWZ0OiAxNjBweCAhaW1wb3J0YW50O1xcbn1cXG4ubS1yLTE2MCB7XFxuICBtYXJnaW4tcmlnaHQ6IDE2MHB4ICFpbXBvcnRhbnQ7XFxufVxcbi5wLXItMTYwIHtcXG4gIHBhZGRpbmctcmlnaHQ6IDE2MHB4ICFpbXBvcnRhbnQ7XFxufVxcblxcbioge1xcbiAgbWFyZ2luOiAwO1xcbiAgcGFkZGluZzogMDtcXG4gIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XFxufVxcblxcbmh0bWwge1xcbiAgYmFja2dyb3VuZDogIzEzMTMxNjtcXG4gIHNjcm9sbC1iZWhhdmlvcjogc21vb3RoO1xcbiAgY29sb3Itc2NoZW1lOiBkYXJrO1xcbn1cXG5cXG5ib2R5IHtcXG4gIGZvbnQtZmFtaWx5OiB2YXIoLS1ib2R5LWZvbnQtZmFtaWx5KTtcXG4gIGZvbnQtc2l6ZTogMTRweDtcXG4gIGNvbG9yOiB2YXIoLS1jbHItbmV1dHJhbC0zMDApO1xcbn1cXG5cXG5oZWFkZXIge1xcbiAgcGFkZGluZzogMjRweCAzMnB4O1xcbiAgZGlzcGxheTogZmxleDtcXG4gIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxuICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcXG4gIGJhY2tncm91bmQ6ICMwMDAwMDA7XFxuICBib3gtc2hhZG93OiAwcHggMXB4IDBweCByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMTUpO1xcbn1cXG5cXG4uaGVhZGVyLWlubmVyIHtcXG4gIGZsZXg6IDE7XFxuICBkaXNwbGF5OiBmbGV4O1xcbiAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG4gIG1heC13aWR0aDogMTEwMHB4O1xcbn1cXG5cXG4uYnVpbGQtbm90ZXMge1xcbiAgZmxleDogMTtcXG4gIGRpc3BsYXk6IGZsZXg7XFxuICBqdXN0aWZ5LWNvbnRlbnQ6IGZsZXgtZW5kO1xcbiAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG59XFxuXFxuLmJ1aWxkLW5vdGUge1xcbiAgbGluZS1oZWlnaHQ6IDE7XFxuICBkaXNwbGF5OiBmbGV4O1xcbiAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG4gIGNvbG9yOiB2YXIoLS1jbHItbmV1dHJhbC00NTApO1xcbn1cXG5cXG4uYnVpbGQtbm90ZSArIC5idWlsZC1ub3RlIHtcXG4gIG1hcmdpbi1sZWZ0OiAxNnB4O1xcbn1cXG5cXG4uYnVpbGQtbm90ZSA+IHN2ZyB7XFxuICBtYXJnaW4tcmlnaHQ6IDhweDtcXG59XFxuXFxuaDEge1xcbiAgZm9udC1mYW1pbHk6IHZhcigtLWhlYWRpbmctZm9udC1mYW1pbHkpO1xcbiAgZm9udC1zaXplOiAyMHB4O1xcbiAgZm9udC13ZWlnaHQ6IGJvbGQ7XFxuICBjb2xvcjogdmFyKC0tY2xyLW5ldXRyYWwtMCk7XFxufVxcblxcbmgyIHtcXG4gIGZvbnQtZmFtaWx5OiB2YXIoLS1oZWFkaW5nLWZvbnQtZmFtaWx5KTtcXG4gIGZvbnQtc2l6ZTogMTZweDtcXG4gIGZvbnQtd2VpZ2h0OiA2MDA7XFxuICBjb2xvcjogdmFyKC0tY2xyLW5ldXRyYWwtNTApO1xcbn1cXG5cXG5oMyB7XFxuICBmb250LWZhbWlseTogdmFyKC0taGVhZGluZy1mb250LWZhbWlseSk7XFxuICBmb250LXNpemU6IDE2cHg7XFxuICBmb250LXdlaWdodDogNTAwO1xcbiAgY29sb3I6IHZhcigtLWNsci1uZXV0cmFsLTEwMCk7XFxufVxcblxcbmJ1dHRvbiB7XFxuICBib3JkZXI6IG5vbmU7XFxuICBjb2xvcjogdmFyKC0tY2xyLW5ldXRyYWwtNTApO1xcbiAgYmFja2dyb3VuZDogbGluZWFyLWdyYWRpZW50KDkwZGVnLCAjNjE2YWNiIDAlLCAjNDg1NGJiIDEwMCUpO1xcbiAgYm9yZGVyLXJhZGl1czogNHB4O1xcbiAgZm9udC1mYW1pbHk6IHZhcigtLWJvZHktZm9udC1mYW1pbHkpO1xcbiAgZm9udC1zaXplOiAxNHB4O1xcbiAgcGFkZGluZzogMTJweCAxOHB4O1xcbiAgY3Vyc29yOiBwb2ludGVyO1xcbn1cXG5cXG5idXR0b24uc2Vjb25kYXJ5IHtcXG4gIGJvcmRlcjogMXB4IHNvbGlkIHZhcigtLWNsci1wcmltYXJ5LTUwMCk7XFxuICBiYWNrZ3JvdW5kOiB0cmFuc3BhcmVudDtcXG59XFxuXFxuYnV0dG9uOmRpc2FibGVkIHtcXG4gIGNvbG9yOiB2YXIoLS1jbHItbmV1dHJhbC00MDApO1xcbiAgYmFja2dyb3VuZDogdmFyKC0tY2xyLW5ldXRyYWwtODUwKTtcXG4gIGN1cnNvcjogaW5oZXJpdDtcXG59XFxuXFxuaW5wdXQge1xcbiAgZm9udC1zaXplOiAxNHB4O1xcbn1cXG5cXG5pbnB1dFt0eXBlPVxcXCJ0ZXh0XFxcIl0ge1xcbiAgZm9udC1mYW1pbHk6IHZhcigtLWJvZHktZm9udC1mYW1pbHkpO1xcbiAgYmFja2dyb3VuZDogdmFyKC0tY2xyLW5ldXRyYWwtOTUwKTtcXG4gIGJvcmRlcjogMXB4IHNvbGlkIHZhcigtLWNsci1uZXV0cmFsLTg1MCk7XFxuICBib3JkZXItcmFkaXVzOiA1cHg7XFxuICBwYWRkaW5nOiAxMnB4IDE2cHg7XFxufVxcblxcbi5iYWRnZSB7XFxuICBkaXNwbGF5OiBmbGV4O1xcbiAgZmxleC1kaXJlY3Rpb246IHJvdztcXG4gIGp1c3RpZnktY29udGVudDogY2VudGVyO1xcbiAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG4gIHBhZGRpbmc6IDRweCA4cHg7XFxuICBmb250LXNpemU6IDEycHg7XFxuICBmb250LXdlaWdodDogNTAwO1xcbiAgYm9yZGVyLXJhZGl1czogMjRweDtcXG4gIGJhY2tncm91bmQ6IHZhcigtLWNsci1uZXV0cmFsLTkwMCk7XFxuICBjb2xvcjogdmFyKC0tY2xyLW5ldXRyYWwtMzAwKTtcXG59XFxuXFxuLmJhZGdlLm9rIHtcXG4gIGJhY2tncm91bmQ6IHZhcigtLWNsci1wcmltYXJ5LTkwMCk7XFxuICBjb2xvcjogdmFyKC0tY2xyLXByaW1hcnktMzAwKTtcXG59XFxuXFxuLmJhY2tkcm9wIHtcXG4gIHdpZHRoOiAxMDAlO1xcbiAgaGVpZ2h0OiAxODBweDtcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gIHotaW5kZXg6IC01O1xcbiAgcG9pbnRlci1ldmVudHM6IG5vbmU7XFxuICBiYWNrZ3JvdW5kOiAjMDAwMDAwO1xcbn1cXG5cXG4uZGVtbyB7XFxuICBwYWRkaW5nOiAzMnB4O1xcbiAgbWF4LXdpZHRoOiAxMTAwcHg7XFxuICBtYXJnaW46IGF1dG87XFxufVxcblxcbi5mbGV4IHtcXG4gIGRpc3BsYXk6IGZsZXg7XFxuICBhbGlnbi1pdGVtczogY2VudGVyO1xcbn1cXG5cXG5zdmcge1xcbiAgZmxleC1zaHJpbms6IDA7XFxufVxcblxcbi5jYXJkIHtcXG4gIGJhY2tncm91bmQ6IHZhcigtLWNsci1uZXV0cmFsLTkyNSk7XFxuICBib3gtc2hhZG93OiAwcHggOHB4IDUwcHggcmdiYSgwLCAwLCAwLCAwLjI1KTtcXG4gIGJvcmRlci1yYWRpdXM6IDhweDtcXG4gIHBhZGRpbmc6IDI0cHg7XFxuICBtYXJnaW46IDI0cHggMDtcXG59XFxuXFxuLmNhcmQtdG9wIHtcXG4gIGRpc3BsYXk6IGZsZXg7XFxuICBhbGlnbi1pdGVtczogY2VudGVyO1xcbiAgbWFyZ2luLWJvdHRvbTogOHB4O1xcbn1cXG5cXG4uY2FyZC10b3AgPiAqICsgKiB7XFxuICBtYXJnaW4tbGVmdDogOHB4O1xcbn1cXG5cXG4ud2lkZ2V0LWJvZHkge1xcbiAgZGlzcGxheTogZmxleDtcXG59XFxuXFxuLnN0cmVhbS1jb2x1bW4ge1xcbiAgZmxleDogMjtcXG59XFxuXFxuLmNoYXQtY29sdW1uIHtcXG4gIGZsZXg6IDE7XFxuICBkaXNwbGF5OiBmbGV4O1xcbiAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcXG59XFxuXFxuLmNoYXQtaGlzdG9yeSB7XFxuICBmbGV4OiAxO1xcbn1cXG5cXG4uY2hhdC1ib3R0b20ge1xcbiAgZGlzcGxheTogZmxleDtcXG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxufVxcblxcbi5jaGF0LWlucHV0IHtcXG4gIGZsZXg6IDE7XFxufVxcblxcbmJ1dHRvbi5jaGF0LXNlbmQtYnV0dG9uIHtcXG4gIGN1cnNvcjogcG9pbnRlcjtcXG4gIGJhY2tncm91bmQ6IG5vbmU7XFxuICBwYWRkaW5nOiAwO1xcbiAgbWFyZ2luOiAwO1xcbiAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgcmlnaHQ6IDE2cHg7XFxuICBtYXJnaW4tdG9wOiBhdXRvO1xcbn1cXG5cXG5idXR0b24uY2hhdC1zZW5kLWJ1dHRvbjpkaXNhYmxlZCB7XFxuICBjdXJzb3I6IGluaGVyaXQ7XFxuICBmaWx0ZXI6IGdyYXlzY2FsZSgpO1xcbn1cXG5cXG4uc3RyZWFtLXdyYXBwZXIge1xcbiAgYm9yZGVyOiAxcHggc29saWQgcmdiYSgwLCAwLCAwLCAwLjQpO1xcbiAgYmFja2dyb3VuZC1pbWFnZTogLyogdXJsKFxcXCJodHRwczovL3JhaW53YXkuY29tL2ltYWdlcy9sb2dvLnN2Z1xcXCIpLCAqL1xcbiAgICBsaW5lYXItZ3JhZGllbnQoLTQ1ZGVnLCAjMTQxNjI1LCAjMjQxNjM1KTtcXG4gIGJhY2tncm91bmQtcmVwZWF0OiBuby1yZXBlYXQ7XFxuICBiYWNrZ3JvdW5kLXBvc2l0aW9uOiBjZW50ZXI7XFxuICB3aWR0aDogMTAwJTtcXG4gIGhlaWdodDogMzkzcHg7XFxufVxcblxcbmEge1xcbiAgY29sb3I6IHZhcigtLWNsci1wcmltYXJ5LTQwMCk7XFxuICBmb250LXdlaWdodDogNjAwO1xcbiAgdGV4dC1kZWNvcmF0aW9uOiBub25lO1xcbiAgdHJhbnNpdGlvbjogY29sb3IgMC4ycyBlYXNlO1xcbn1cXG5cXG5hOmhvdmVyIHtcXG4gIGNvbG9yOiB2YXIoLS1jbHItbmV1dHJhbC01MCk7XFxufVxcblwiLCBcIlwiXSk7XG4vLyBFeHBvcnRzXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHM7XG4iLCJcInVzZSBzdHJpY3RcIjtcblxuLypcbiAgTUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcbiAgQXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxuKi9cbi8vIGNzcyBiYXNlIGNvZGUsIGluamVjdGVkIGJ5IHRoZSBjc3MtbG9hZGVyXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZnVuYy1uYW1lc1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAodXNlU291cmNlTWFwKSB7XG4gIHZhciBsaXN0ID0gW107IC8vIHJldHVybiB0aGUgbGlzdCBvZiBtb2R1bGVzIGFzIGNzcyBzdHJpbmdcblxuICBsaXN0LnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICB2YXIgY29udGVudCA9IGNzc1dpdGhNYXBwaW5nVG9TdHJpbmcoaXRlbSwgdXNlU291cmNlTWFwKTtcblxuICAgICAgaWYgKGl0ZW1bMl0pIHtcbiAgICAgICAgcmV0dXJuIFwiQG1lZGlhIFwiLmNvbmNhdChpdGVtWzJdLCBcIiB7XCIpLmNvbmNhdChjb250ZW50LCBcIn1cIik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjb250ZW50O1xuICAgIH0pLmpvaW4oJycpO1xuICB9OyAvLyBpbXBvcnQgYSBsaXN0IG9mIG1vZHVsZXMgaW50byB0aGUgbGlzdFxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZnVuYy1uYW1lc1xuXG5cbiAgbGlzdC5pID0gZnVuY3Rpb24gKG1vZHVsZXMsIG1lZGlhUXVlcnksIGRlZHVwZSkge1xuICAgIGlmICh0eXBlb2YgbW9kdWxlcyA9PT0gJ3N0cmluZycpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgbW9kdWxlcyA9IFtbbnVsbCwgbW9kdWxlcywgJyddXTtcbiAgICB9XG5cbiAgICB2YXIgYWxyZWFkeUltcG9ydGVkTW9kdWxlcyA9IHt9O1xuXG4gICAgaWYgKGRlZHVwZSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBwcmVmZXItZGVzdHJ1Y3R1cmluZ1xuICAgICAgICB2YXIgaWQgPSB0aGlzW2ldWzBdO1xuXG4gICAgICAgIGlmIChpZCAhPSBudWxsKSB7XG4gICAgICAgICAgYWxyZWFkeUltcG9ydGVkTW9kdWxlc1tpZF0gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IG1vZHVsZXMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICB2YXIgaXRlbSA9IFtdLmNvbmNhdChtb2R1bGVzW19pXSk7XG5cbiAgICAgIGlmIChkZWR1cGUgJiYgYWxyZWFkeUltcG9ydGVkTW9kdWxlc1tpdGVtWzBdXSkge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29udGludWVcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChtZWRpYVF1ZXJ5KSB7XG4gICAgICAgIGlmICghaXRlbVsyXSkge1xuICAgICAgICAgIGl0ZW1bMl0gPSBtZWRpYVF1ZXJ5O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGl0ZW1bMl0gPSBcIlwiLmNvbmNhdChtZWRpYVF1ZXJ5LCBcIiBhbmQgXCIpLmNvbmNhdChpdGVtWzJdKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBsaXN0LnB1c2goaXRlbSk7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBsaXN0O1xufTtcblxuZnVuY3Rpb24gY3NzV2l0aE1hcHBpbmdUb1N0cmluZyhpdGVtLCB1c2VTb3VyY2VNYXApIHtcbiAgdmFyIGNvbnRlbnQgPSBpdGVtWzFdIHx8ICcnOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcHJlZmVyLWRlc3RydWN0dXJpbmdcblxuICB2YXIgY3NzTWFwcGluZyA9IGl0ZW1bM107XG5cbiAgaWYgKCFjc3NNYXBwaW5nKSB7XG4gICAgcmV0dXJuIGNvbnRlbnQ7XG4gIH1cblxuICBpZiAodXNlU291cmNlTWFwICYmIHR5cGVvZiBidG9hID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdmFyIHNvdXJjZU1hcHBpbmcgPSB0b0NvbW1lbnQoY3NzTWFwcGluZyk7XG4gICAgdmFyIHNvdXJjZVVSTHMgPSBjc3NNYXBwaW5nLnNvdXJjZXMubWFwKGZ1bmN0aW9uIChzb3VyY2UpIHtcbiAgICAgIHJldHVybiBcIi8qIyBzb3VyY2VVUkw9XCIuY29uY2F0KGNzc01hcHBpbmcuc291cmNlUm9vdCB8fCAnJykuY29uY2F0KHNvdXJjZSwgXCIgKi9cIik7XG4gICAgfSk7XG4gICAgcmV0dXJuIFtjb250ZW50XS5jb25jYXQoc291cmNlVVJMcykuY29uY2F0KFtzb3VyY2VNYXBwaW5nXSkuam9pbignXFxuJyk7XG4gIH1cblxuICByZXR1cm4gW2NvbnRlbnRdLmpvaW4oJ1xcbicpO1xufSAvLyBBZGFwdGVkIGZyb20gY29udmVydC1zb3VyY2UtbWFwIChNSVQpXG5cblxuZnVuY3Rpb24gdG9Db21tZW50KHNvdXJjZU1hcCkge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZcbiAgdmFyIGJhc2U2NCA9IGJ0b2EodW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KEpTT04uc3RyaW5naWZ5KHNvdXJjZU1hcCkpKSk7XG4gIHZhciBkYXRhID0gXCJzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04O2Jhc2U2NCxcIi5jb25jYXQoYmFzZTY0KTtcbiAgcmV0dXJuIFwiLyojIFwiLmNvbmNhdChkYXRhLCBcIiAqL1wiKTtcbn0iLCIvKlxub2JqZWN0LWFzc2lnblxuKGMpIFNpbmRyZSBTb3JodXNcbkBsaWNlbnNlIE1JVFxuKi9cblxuJ3VzZSBzdHJpY3QnO1xuLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMgKi9cbnZhciBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBwcm9wSXNFbnVtZXJhYmxlID0gT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcblxuZnVuY3Rpb24gdG9PYmplY3QodmFsKSB7XG5cdGlmICh2YWwgPT09IG51bGwgfHwgdmFsID09PSB1bmRlZmluZWQpIHtcblx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdPYmplY3QuYXNzaWduIGNhbm5vdCBiZSBjYWxsZWQgd2l0aCBudWxsIG9yIHVuZGVmaW5lZCcpO1xuXHR9XG5cblx0cmV0dXJuIE9iamVjdCh2YWwpO1xufVxuXG5mdW5jdGlvbiBzaG91bGRVc2VOYXRpdmUoKSB7XG5cdHRyeSB7XG5cdFx0aWYgKCFPYmplY3QuYXNzaWduKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Ly8gRGV0ZWN0IGJ1Z2d5IHByb3BlcnR5IGVudW1lcmF0aW9uIG9yZGVyIGluIG9sZGVyIFY4IHZlcnNpb25zLlxuXG5cdFx0Ly8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9NDExOFxuXHRcdHZhciB0ZXN0MSA9IG5ldyBTdHJpbmcoJ2FiYycpOyAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXctd3JhcHBlcnNcblx0XHR0ZXN0MVs1XSA9ICdkZSc7XG5cdFx0aWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRlc3QxKVswXSA9PT0gJzUnKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Ly8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MzA1NlxuXHRcdHZhciB0ZXN0MiA9IHt9O1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgMTA7IGkrKykge1xuXHRcdFx0dGVzdDJbJ18nICsgU3RyaW5nLmZyb21DaGFyQ29kZShpKV0gPSBpO1xuXHRcdH1cblx0XHR2YXIgb3JkZXIyID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGVzdDIpLm1hcChmdW5jdGlvbiAobikge1xuXHRcdFx0cmV0dXJuIHRlc3QyW25dO1xuXHRcdH0pO1xuXHRcdGlmIChvcmRlcjIuam9pbignJykgIT09ICcwMTIzNDU2Nzg5Jykge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTMwNTZcblx0XHR2YXIgdGVzdDMgPSB7fTtcblx0XHQnYWJjZGVmZ2hpamtsbW5vcHFyc3QnLnNwbGl0KCcnKS5mb3JFYWNoKGZ1bmN0aW9uIChsZXR0ZXIpIHtcblx0XHRcdHRlc3QzW2xldHRlcl0gPSBsZXR0ZXI7XG5cdFx0fSk7XG5cdFx0aWYgKE9iamVjdC5rZXlzKE9iamVjdC5hc3NpZ24oe30sIHRlc3QzKSkuam9pbignJykgIT09XG5cdFx0XHRcdCdhYmNkZWZnaGlqa2xtbm9wcXJzdCcpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSBjYXRjaCAoZXJyKSB7XG5cdFx0Ly8gV2UgZG9uJ3QgZXhwZWN0IGFueSBvZiB0aGUgYWJvdmUgdG8gdGhyb3csIGJ1dCBiZXR0ZXIgdG8gYmUgc2FmZS5cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzaG91bGRVc2VOYXRpdmUoKSA/IE9iamVjdC5hc3NpZ24gOiBmdW5jdGlvbiAodGFyZ2V0LCBzb3VyY2UpIHtcblx0dmFyIGZyb207XG5cdHZhciB0byA9IHRvT2JqZWN0KHRhcmdldCk7XG5cdHZhciBzeW1ib2xzO1xuXG5cdGZvciAodmFyIHMgPSAxOyBzIDwgYXJndW1lbnRzLmxlbmd0aDsgcysrKSB7XG5cdFx0ZnJvbSA9IE9iamVjdChhcmd1bWVudHNbc10pO1xuXG5cdFx0Zm9yICh2YXIga2V5IGluIGZyb20pIHtcblx0XHRcdGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGZyb20sIGtleSkpIHtcblx0XHRcdFx0dG9ba2V5XSA9IGZyb21ba2V5XTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG5cdFx0XHRzeW1ib2xzID0gZ2V0T3duUHJvcGVydHlTeW1ib2xzKGZyb20pO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBzeW1ib2xzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdGlmIChwcm9wSXNFbnVtZXJhYmxlLmNhbGwoZnJvbSwgc3ltYm9sc1tpXSkpIHtcblx0XHRcdFx0XHR0b1tzeW1ib2xzW2ldXSA9IGZyb21bc3ltYm9sc1tpXV07XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gdG87XG59O1xuIiwiIWZ1bmN0aW9uKEEsSSl7XCJvYmplY3RcIj09dHlwZW9mIGV4cG9ydHMmJlwib2JqZWN0XCI9PXR5cGVvZiBtb2R1bGU/bW9kdWxlLmV4cG9ydHM9SSgpOlwiZnVuY3Rpb25cIj09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZD9kZWZpbmUoW10sSSk6XCJvYmplY3RcIj09dHlwZW9mIGV4cG9ydHM/ZXhwb3J0c1tcInJhaW53YXktc2RrXCJdPUkoKTpBW1wicmFpbndheS1zZGtcIl09SSgpfShzZWxmLChmdW5jdGlvbigpe3JldHVybigoKT0+e3ZhciBBPXsxMjA6KEEsSSxnKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eShJLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLEkuQmVib3BWaWV3PUkuQmVib3BSdW50aW1lRXJyb3I9dm9pZCAwO2NvbnN0IGU9XCIwMTIzNDU2Nzg5YWJjZGVmXCIsQj1bMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwxLDIsMyw0LDUsNiw3LDgsOSwwLDAsMCwwLDAsMCwwLDEwLDExLDEyLDEzLDE0LDE1LDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwxMCwxMSwxMiwxMywxNCwxNSwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwXSxpPW5ldyBVaW50OEFycmF5KDApLHQ9W107Zm9yKGNvbnN0IEEgb2YgZSlmb3IoY29uc3QgSSBvZiBlKXQucHVzaChBK0kpO1widW5kZWZpbmVkXCI9PXR5cGVvZiBUZXh0RGVjb2RlciYmKGcuZy5UZXh0RGVjb2Rlcj1nKDcwMCkuVGV4dERlY29kZXIpO2NsYXNzIFEgZXh0ZW5kcyBFcnJvcntjb25zdHJ1Y3RvcihBKXtzdXBlcihBKSx0aGlzLm5hbWU9XCJCZWJvcFJ1bnRpbWVFcnJvclwifX1JLkJlYm9wUnVudGltZUVycm9yPVE7Y2xhc3MgQ3tzdGF0aWMgdGV4dERlY29kZXI9bmV3IFRleHREZWNvZGVyO3N0YXRpYyB3cml0ZUJ1ZmZlcj1uZXcgVWludDhBcnJheSgyNTYpO3N0YXRpYyB3cml0ZUJ1ZmZlclZpZXc9bmV3IERhdGFWaWV3KEMud3JpdGVCdWZmZXIuYnVmZmVyKTtzdGF0aWMgaW5zdGFuY2U7c3RhdGljIGdldEluc3RhbmNlKCl7cmV0dXJuIEMuaW5zdGFuY2V8fChDLmluc3RhbmNlPW5ldyBDKSxDLmluc3RhbmNlfW1pbmltdW1UZXh0RGVjb2Rlckxlbmd0aD0zMDA7YnVmZmVyO3ZpZXc7aW5kZXg7bGVuZ3RoO2NvbnN0cnVjdG9yKCl7dGhpcy5idWZmZXI9Qy53cml0ZUJ1ZmZlcix0aGlzLnZpZXc9Qy53cml0ZUJ1ZmZlclZpZXcsdGhpcy5pbmRleD0wLHRoaXMubGVuZ3RoPTB9c3RhcnRSZWFkaW5nKEEpe3RoaXMuYnVmZmVyPUEsdGhpcy52aWV3PW5ldyBEYXRhVmlldyh0aGlzLmJ1ZmZlci5idWZmZXIsdGhpcy5idWZmZXIuYnl0ZU9mZnNldCx0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoKSx0aGlzLmluZGV4PTAsdGhpcy5sZW5ndGg9QS5sZW5ndGh9c3RhcnRXcml0aW5nKCl7dGhpcy5idWZmZXI9Qy53cml0ZUJ1ZmZlcix0aGlzLnZpZXc9Qy53cml0ZUJ1ZmZlclZpZXcsdGhpcy5pbmRleD0wLHRoaXMubGVuZ3RoPTB9Z3VhcmFudGVlQnVmZmVyTGVuZ3RoKEEpe2lmKEE+dGhpcy5idWZmZXIubGVuZ3RoKXtjb25zdCBJPW5ldyBVaW50OEFycmF5KEE8PDEpO0kuc2V0KHRoaXMuYnVmZmVyKSx0aGlzLmJ1ZmZlcj1JLHRoaXMudmlldz1uZXcgRGF0YVZpZXcoSS5idWZmZXIpfX1ncm93QnkoQSl7dGhpcy5sZW5ndGgrPUEsdGhpcy5ndWFyYW50ZWVCdWZmZXJMZW5ndGgodGhpcy5sZW5ndGgpfXNraXAoQSl7dGhpcy5pbmRleCs9QX10b0FycmF5KCl7cmV0dXJuIHRoaXMuYnVmZmVyLnN1YmFycmF5KDAsdGhpcy5sZW5ndGgpfXJlYWRCeXRlKCl7cmV0dXJuIHRoaXMuYnVmZmVyW3RoaXMuaW5kZXgrK119cmVhZFVpbnQxNigpe2NvbnN0IEE9dGhpcy52aWV3LmdldFVpbnQxNih0aGlzLmluZGV4LCEwKTtyZXR1cm4gdGhpcy5pbmRleCs9MixBfXJlYWRJbnQxNigpe2NvbnN0IEE9dGhpcy52aWV3LmdldEludDE2KHRoaXMuaW5kZXgsITApO3JldHVybiB0aGlzLmluZGV4Kz0yLEF9cmVhZFVpbnQzMigpe2NvbnN0IEE9dGhpcy52aWV3LmdldFVpbnQzMih0aGlzLmluZGV4LCEwKTtyZXR1cm4gdGhpcy5pbmRleCs9NCxBfXJlYWRJbnQzMigpe2NvbnN0IEE9dGhpcy52aWV3LmdldEludDMyKHRoaXMuaW5kZXgsITApO3JldHVybiB0aGlzLmluZGV4Kz00LEF9cmVhZFVpbnQ2NCgpe2NvbnN0IEE9dGhpcy52aWV3LmdldEJpZ1VpbnQ2NCh0aGlzLmluZGV4LCEwKTtyZXR1cm4gdGhpcy5pbmRleCs9OCxBfXJlYWRJbnQ2NCgpe2NvbnN0IEE9dGhpcy52aWV3LmdldEJpZ0ludDY0KHRoaXMuaW5kZXgsITApO3JldHVybiB0aGlzLmluZGV4Kz04LEF9cmVhZEZsb2F0MzIoKXtjb25zdCBBPXRoaXMudmlldy5nZXRGbG9hdDMyKHRoaXMuaW5kZXgsITApO3JldHVybiB0aGlzLmluZGV4Kz00LEF9cmVhZEZsb2F0NjQoKXtjb25zdCBBPXRoaXMudmlldy5nZXRGbG9hdDY0KHRoaXMuaW5kZXgsITApO3JldHVybiB0aGlzLmluZGV4Kz04LEF9d3JpdGVCeXRlKEEpe2NvbnN0IEk9dGhpcy5sZW5ndGg7dGhpcy5ncm93QnkoMSksdGhpcy5idWZmZXJbSV09QX13cml0ZVVpbnQxNihBKXtjb25zdCBJPXRoaXMubGVuZ3RoO3RoaXMuZ3Jvd0J5KDIpLHRoaXMudmlldy5zZXRVaW50MTYoSSxBLCEwKX13cml0ZUludDE2KEEpe2NvbnN0IEk9dGhpcy5sZW5ndGg7dGhpcy5ncm93QnkoMiksdGhpcy52aWV3LnNldEludDE2KEksQSwhMCl9d3JpdGVVaW50MzIoQSl7Y29uc3QgST10aGlzLmxlbmd0aDt0aGlzLmdyb3dCeSg0KSx0aGlzLnZpZXcuc2V0VWludDMyKEksQSwhMCl9d3JpdGVJbnQzMihBKXtjb25zdCBJPXRoaXMubGVuZ3RoO3RoaXMuZ3Jvd0J5KDQpLHRoaXMudmlldy5zZXRJbnQzMihJLEEsITApfXdyaXRlVWludDY0KEEpe2NvbnN0IEk9dGhpcy5sZW5ndGg7dGhpcy5ncm93QnkoOCksdGhpcy52aWV3LnNldEJpZ1VpbnQ2NChJLEEsITApfXdyaXRlSW50NjQoQSl7Y29uc3QgST10aGlzLmxlbmd0aDt0aGlzLmdyb3dCeSg4KSx0aGlzLnZpZXcuc2V0QmlnSW50NjQoSSxBLCEwKX13cml0ZUZsb2F0MzIoQSl7Y29uc3QgST10aGlzLmxlbmd0aDt0aGlzLmdyb3dCeSg0KSx0aGlzLnZpZXcuc2V0RmxvYXQzMihJLEEsITApfXdyaXRlRmxvYXQ2NChBKXtjb25zdCBJPXRoaXMubGVuZ3RoO3RoaXMuZ3Jvd0J5KDgpLHRoaXMudmlldy5zZXRGbG9hdDY0KEksQSwhMCl9cmVhZEJ5dGVzKCl7Y29uc3QgQT10aGlzLnJlYWRVaW50MzIoKTtpZigwPT09QSlyZXR1cm4gaTtjb25zdCBJPXRoaXMuaW5kZXgsZz1JK0E7cmV0dXJuIHRoaXMuaW5kZXg9Zyx0aGlzLmJ1ZmZlci5zdWJhcnJheShJLGcpfXdyaXRlQnl0ZXMoQSl7Y29uc3QgST1BLmxlbmd0aDtpZih0aGlzLndyaXRlVWludDMyKEkpLDA9PT1JKXJldHVybjtjb25zdCBnPXRoaXMubGVuZ3RoO3RoaXMuZ3Jvd0J5KEkpLHRoaXMuYnVmZmVyLnNldChBLGcpfXJlYWRTdHJpbmcoKXtjb25zdCBBPXRoaXMucmVhZFVpbnQzMigpO2lmKDA9PT1BKXJldHVyblwiXCI7aWYoQT49dGhpcy5taW5pbXVtVGV4dERlY29kZXJMZW5ndGgpcmV0dXJuIEMudGV4dERlY29kZXIuZGVjb2RlKHRoaXMuYnVmZmVyLnN1YmFycmF5KHRoaXMuaW5kZXgsdGhpcy5pbmRleCs9QSkpO2NvbnN0IEk9dGhpcy5pbmRleCtBO2xldCBnLGU9XCJcIjtmb3IoO3RoaXMuaW5kZXg8STspe2NvbnN0IEE9dGhpcy5idWZmZXJbdGhpcy5pbmRleCsrXTtpZihBPDE5MilnPUE7ZWxzZXtjb25zdCBJPXRoaXMuYnVmZmVyW3RoaXMuaW5kZXgrK107aWYoQTwyMjQpZz0oMzEmQSk8PDZ8NjMmSTtlbHNle2NvbnN0IGU9dGhpcy5idWZmZXJbdGhpcy5pbmRleCsrXTtnPUE8MjQwPygxNSZBKTw8MTJ8KDYzJkkpPDw2fDYzJmU6KDcmQSk8PDE4fCg2MyZJKTw8MTJ8KDYzJmUpPDw2fDYzJnRoaXMuYnVmZmVyW3RoaXMuaW5kZXgrK119fWc8NjU1MzY/ZSs9U3RyaW5nLmZyb21DaGFyQ29kZShnKTooZy09NjU1MzYsZSs9U3RyaW5nLmZyb21DaGFyQ29kZSg1NTI5NisoZz4+MTApLDU2MzIwKygxMDIzJmcpKSl9cmV0dXJuIHRoaXMuaW5kZXg9SSxlfXdyaXRlU3RyaW5nKEEpe2NvbnN0IEk9QS5sZW5ndGg7aWYoMD09PUkpcmV0dXJuIHZvaWQgdGhpcy53cml0ZVVpbnQzMigwKTtjb25zdCBnPTQrMypJO3RoaXMuZ3VhcmFudGVlQnVmZmVyTGVuZ3RoKHRoaXMubGVuZ3RoK2cpO2xldCBlPXRoaXMubGVuZ3RoKzQ7Y29uc3QgQj1lO2xldCBpO2ZvcihsZXQgZz0wO2c8STtnKyspe2NvbnN0IEI9QS5jaGFyQ29kZUF0KGcpO2k9ZysxPT09SXx8Qjw1NTI5Nnx8Qj49NTYzMjA/QjooQjw8MTApK0EuY2hhckNvZGVBdCgrK2cpKy01NjYxMzg4OCxpPDEyOD90aGlzLmJ1ZmZlcltlKytdPWk6KGk8MjA0OD90aGlzLmJ1ZmZlcltlKytdPWk+PjYmMzF8MTkyOihpPDY1NTM2P3RoaXMuYnVmZmVyW2UrK109aT4+MTImMTV8MjI0Oih0aGlzLmJ1ZmZlcltlKytdPWk+PjE4Jjd8MjQwLHRoaXMuYnVmZmVyW2UrK109aT4+MTImNjN8MTI4KSx0aGlzLmJ1ZmZlcltlKytdPWk+PjYmNjN8MTI4KSx0aGlzLmJ1ZmZlcltlKytdPTYzJml8MTI4KX1jb25zdCB0PWUtQjt0aGlzLnZpZXcuc2V0VWludDMyKHRoaXMubGVuZ3RoLHQsITApLHRoaXMubGVuZ3RoKz00K3R9cmVhZEd1aWQoKXtjb25zdCBBPXQsST10aGlzLmJ1ZmZlcixnPXRoaXMuaW5kZXgsZT1cIi1cIjt2YXIgQj1BW0lbZyszXV07cmV0dXJuIEIrPUFbSVtnKzJdXSxCKz1BW0lbZysxXV0sQis9QVtJW2ddXSxCKz1lLEIrPUFbSVtnKzVdXSxCKz1BW0lbZys0XV0sQis9ZSxCKz1BW0lbZys3XV0sQis9QVtJW2crNl1dLEIrPWUsQis9QVtJW2crOF1dLEIrPUFbSVtnKzldXSxCKz1lLEIrPUFbSVtnKzEwXV0sQis9QVtJW2crMTFdXSxCKz1BW0lbZysxMl1dLEIrPUFbSVtnKzEzXV0sQis9QVtJW2crMTRdXSxCKz1BW0lbZysxNV1dLHRoaXMuaW5kZXgrPTE2LEJ9d3JpdGVHdWlkKEEpe2NvbnN0IEk9dGhpcy52aWV3LGc9dGhpcy5sZW5ndGg7dGhpcy5ncm93QnkoMTYpO3ZhciBlPTAsaT0wO2k9KGk9KGk9KGk9KGk9KGk9KGk9KGk9aTw8NHxCW0EuY2hhckNvZGVBdChlKyspXSk8PDR8QltBLmNoYXJDb2RlQXQoZSsrKV0pPDw0fEJbQS5jaGFyQ29kZUF0KGUrKyldKTw8NHxCW0EuY2hhckNvZGVBdChlKyspXSk8PDR8QltBLmNoYXJDb2RlQXQoZSsrKV0pPDw0fEJbQS5jaGFyQ29kZUF0KGUrKyldKTw8NHxCW0EuY2hhckNvZGVBdChlKyspXSk8PDR8QltBLmNoYXJDb2RlQXQoZSsrKV0sZSs9NDU9PT1BLmNoYXJDb2RlQXQoZSksSS5zZXRVaW50MzIoZyxpLCEwKSxpPShpPShpPShpPWk8PDR8QltBLmNoYXJDb2RlQXQoZSsrKV0pPDw0fEJbQS5jaGFyQ29kZUF0KGUrKyldKTw8NHxCW0EuY2hhckNvZGVBdChlKyspXSk8PDR8QltBLmNoYXJDb2RlQXQoZSsrKV0sZSs9NDU9PT1BLmNoYXJDb2RlQXQoZSksSS5zZXRVaW50MTYoZys0LGksITApLGk9KGk9KGk9KGk9aTw8NHxCW0EuY2hhckNvZGVBdChlKyspXSk8PDR8QltBLmNoYXJDb2RlQXQoZSsrKV0pPDw0fEJbQS5jaGFyQ29kZUF0KGUrKyldKTw8NHxCW0EuY2hhckNvZGVBdChlKyspXSxlKz00NT09PUEuY2hhckNvZGVBdChlKSxJLnNldFVpbnQxNihnKzYsaSwhMCksaT0oaT0oaT0oaT1pPDw0fEJbQS5jaGFyQ29kZUF0KGUrKyldKTw8NHxCW0EuY2hhckNvZGVBdChlKyspXSk8PDR8QltBLmNoYXJDb2RlQXQoZSsrKV0pPDw0fEJbQS5jaGFyQ29kZUF0KGUrKyldLGUrPTQ1PT09QS5jaGFyQ29kZUF0KGUpLGk9KGk9KGk9KGk9aTw8NHxCW0EuY2hhckNvZGVBdChlKyspXSk8PDR8QltBLmNoYXJDb2RlQXQoZSsrKV0pPDw0fEJbQS5jaGFyQ29kZUF0KGUrKyldKTw8NHxCW0EuY2hhckNvZGVBdChlKyspXSxJLnNldFVpbnQzMihnKzgsaSwhMSksaT0oaT0oaT0oaT0oaT0oaT0oaT0oaT1pPDw0fEJbQS5jaGFyQ29kZUF0KGUrKyldKTw8NHxCW0EuY2hhckNvZGVBdChlKyspXSk8PDR8QltBLmNoYXJDb2RlQXQoZSsrKV0pPDw0fEJbQS5jaGFyQ29kZUF0KGUrKyldKTw8NHxCW0EuY2hhckNvZGVBdChlKyspXSk8PDR8QltBLmNoYXJDb2RlQXQoZSsrKV0pPDw0fEJbQS5jaGFyQ29kZUF0KGUrKyldKTw8NHxCW0EuY2hhckNvZGVBdChlKyspXSxJLnNldFVpbnQzMihnKzEyLGksITEpfXJlYWREYXRlKCl7Y29uc3QgQT10aGlzLnJlYWRVaW50MzIoKSxJPTEwNzM3NDE4MjMmdGhpcy5yZWFkVWludDMyKCk7cmV0dXJuIG5ldyBEYXRlKDQyOTQ5Ni43Mjk2KkkrMWUtNCpBLTYyMTM1NTk2OGU1KX13cml0ZURhdGUoQSl7Y29uc3QgST1BLmdldFRpbWUoKSs2MjEzNTU5NjhlNSxnPUklNDI5NDk2LjcyOTYqMWU0fDAsZT1JLzQyOTQ5Ni43Mjk2fDEwNzM3NDE4MjQ7dGhpcy53cml0ZVVpbnQzMihnKSx0aGlzLndyaXRlVWludDMyKGUpfXJlc2VydmVNZXNzYWdlTGVuZ3RoKCl7Y29uc3QgQT10aGlzLmxlbmd0aDtyZXR1cm4gdGhpcy5ncm93QnkoNCksQX1maWxsTWVzc2FnZUxlbmd0aChBLEkpe3RoaXMudmlldy5zZXRVaW50MzIoQSxJLCEwKX1yZWFkTWVzc2FnZUxlbmd0aCgpe2NvbnN0IEE9dGhpcy52aWV3LmdldFVpbnQzMih0aGlzLmluZGV4LCEwKTtyZXR1cm4gdGhpcy5pbmRleCs9NCxBfX1JLkJlYm9wVmlldz1DfSwyOTA6ZnVuY3Rpb24oQSxJLGcpe1widXNlIHN0cmljdFwiO3ZhciBlPXRoaXMmJnRoaXMuX19hd2FpdGVyfHxmdW5jdGlvbihBLEksZyxlKXtyZXR1cm4gbmV3KGd8fChnPVByb21pc2UpKSgoZnVuY3Rpb24oQixpKXtmdW5jdGlvbiB0KEEpe3RyeXtDKGUubmV4dChBKSl9Y2F0Y2goQSl7aShBKX19ZnVuY3Rpb24gUShBKXt0cnl7QyhlLnRocm93KEEpKX1jYXRjaChBKXtpKEEpfX1mdW5jdGlvbiBDKEEpe3ZhciBJO0EuZG9uZT9CKEEudmFsdWUpOihJPUEudmFsdWUsSSBpbnN0YW5jZW9mIGc/STpuZXcgZygoZnVuY3Rpb24oQSl7QShJKX0pKSkudGhlbih0LFEpfUMoKGU9ZS5hcHBseShBLEl8fFtdKSkubmV4dCgpKX0pKX07T2JqZWN0LmRlZmluZVByb3BlcnR5KEksXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksSS5mZXRjaE5ld1BlZXJJZD1JLmdldE9yZ2FuaXphdGlvbkluZm89dm9pZCAwO2NvbnN0IEI9Zyg0NjQpLGk9Zyg5OTQpLHQ9XCJodHRwczovL2FwaS5yYWlud2F5Lm5ldHdvcmsvdjFcIjtJLmdldE9yZ2FuaXphdGlvbkluZm89ZnVuY3Rpb24oQSl7cmV0dXJuIGUodGhpcyx2b2lkIDAsdm9pZCAwLChmdW5jdGlvbiooKXt0cnl7Y29uc3QgST15aWVsZCBmZXRjaCh0K1wiL2tleXMvdmFsaWRhdGVcIix7aGVhZGVyczp7QXV0aG9yaXphdGlvbjpgQmVhcmVyICR7QX1gLEFjY2VwdDpcImFwcGxpY2F0aW9uL2pzb25cIn19KSxnPXlpZWxkIEkuanNvbigpO3JldHVybnt1bml2ZXJzZUZsYWc6Zy51bml2ZXJzZSxvcmdhbml6YXRpb25JZDpnLm9yZ19pZH19Y2F0Y2goQSl7dGhyb3cgQi5SYWlud2F5TG9nZ2luZy5lcnJvcihTdHJpbmcoQSkpLG5ldyBpLlJhaW53YXlFcnJvcihcIlRoZSBSYWlud2F5IEFQSSBrZXkgaXMgaW52YWxpZC5cIil9fSkpfSxJLmZldGNoTmV3UGVlcklkPWZ1bmN0aW9uKCl7cmV0dXJuIGUodGhpcyx2b2lkIDAsdm9pZCAwLChmdW5jdGlvbiooKXtjb25zdCBBPXlpZWxkIGZldGNoKHQrXCIvZHJ1aWQvbmV4dFwiLHtoZWFkZXJzOntBY2NlcHQ6XCJhcHBsaWNhdGlvbi9qc29uXCJ9fSk7cmV0dXJuIEJpZ0ludCh5aWVsZCBBLnRleHQoKSl9KSl9fSw0MzQ6KEEsSSk9PntcInVzZSBzdHJpY3RcIjt2YXIgZyxlO09iamVjdC5kZWZpbmVQcm9wZXJ0eShJLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLEkuQXVkaW9SZWFkeVN0YXRlPUkuVmlkZW9SZWFkeVN0YXRlPXZvaWQgMCwoZT1JLlZpZGVvUmVhZHlTdGF0ZXx8KEkuVmlkZW9SZWFkeVN0YXRlPXt9KSlbZS5EZXRhY2hlZD0wXT1cIkRldGFjaGVkXCIsZVtlLkluaXRpYWxpemluZz0xXT1cIkluaXRpYWxpemluZ1wiLGVbZS5XYWl0aW5nRm9yS2V5ZnJhbWU9Ml09XCJXYWl0aW5nRm9yS2V5ZnJhbWVcIixlW2UuUGxheWluZz0zXT1cIlBsYXlpbmdcIixlW2UuUGF1c2VkPTRdPVwiUGF1c2VkXCIsZVtlLkRpc3Bvc2VkPTVdPVwiRGlzcG9zZWRcIiwoZz1JLkF1ZGlvUmVhZHlTdGF0ZXx8KEkuQXVkaW9SZWFkeVN0YXRlPXt9KSlbZy5EZXRhY2hlZD0wXT1cIkRldGFjaGVkXCIsZ1tnLlVuaW5pdGlhbGl6ZWQ9MV09XCJVbmluaXRpYWxpemVkXCIsZ1tnLkluaXRpYWxpemluZz0yXT1cIkluaXRpYWxpemluZ1wiLGdbZy5QbGF5aW5nPTNdPVwiUGxheWluZ1wiLGdbZy5QYXVzZWQ9NF09XCJQYXVzZWRcIn0sNTI4OihBLEkpPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KEksXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksSS5pc0Rlc2t0b3BTYWZhcmk9dm9pZCAwLEkuaXNEZXNrdG9wU2FmYXJpPS9NYWNpbnRvc2g7LipTYWZhcmkvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkmJiEvQ2hyb21lfEFuZHJvaWQvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpfSw5ODc6KEEsSSk9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkoSSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxJLnJlYXNzZW1ibGU9SS5lYWNoQ2h1bms9dm9pZCAwO2xldCBnPTA7SS5lYWNoQ2h1bms9ZnVuY3Rpb24oQSxJLGU9MTZlMyl7Y29uc3QgQj1NYXRoLmNlaWwoQS5sZW5ndGgvZSksaT0rK2c7Zm9yKGxldCBnPTA7ZzxCO2crKyl7Y29uc3QgdD1nKmUsUT1NYXRoLm1pbigoZysxKSplLEEubGVuZ3RoKTtJKHtjaHVua3NJbkdyb3VwOkIsZ3JvdXBJZDppLGluZGV4OmcsZGF0YTpBLnNsaWNlKHQsUSl9KX19LEkucmVhc3NlbWJsZT1mdW5jdGlvbihBKXtsZXQgST0wO2NvbnN0IGc9QS5jaHVua3MubGVuZ3RoO2ZvcihsZXQgZT0wO2U8ZztlKyspSSs9QS5jaHVua3NbZV0uYnl0ZUxlbmd0aDtjb25zdCBlPW5ldyBVaW50OEFycmF5KEkpO2xldCBCPTA7Zm9yKGxldCBJPTA7STxnO0krKyl7Y29uc3QgZz1BLmNodW5rc1tJXTtlLnNldChnLEIpLEIrPWcuYnl0ZUxlbmd0aH1yZXR1cm4gZX19LDI0OihBLEkpPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KEksXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksSS5BY3Rpb249dm9pZCAwLEkuQWN0aW9uPWNsYXNze2NvbnN0cnVjdG9yKCl7dGhpcy5oYW5kbGVycz1bXX1hZGRIYW5kbGVyKEEpe3RoaXMuaGFuZGxlcnMucHVzaChBKX1yZW1vdmVIYW5kbGVyKEEpe3RoaXMuaGFuZGxlcnM9dGhpcy5oYW5kbGVycy5maWx0ZXIoKEk9PkkhPT1BKSl9aW52b2tlKEEpe2ZvcihsZXQgST0wO0k8dGhpcy5oYW5kbGVycy5sZW5ndGg7SSsrKXRoaXMuaGFuZGxlcnNbSV0oQSl9fX0sOTMwOihBLEkpPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KEksXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksSS5ib3VuZGluZ1JlY3RhbmdsZT12b2lkIDAsSS5ib3VuZGluZ1JlY3RhbmdsZT1mdW5jdGlvbihBKXtjb25zdCBJPUEubGVuZ3RoO2lmKDA9PT1JKXRocm93IG5ldyBFcnJvcihcImJvdW5kaW5nUmVjdGFuZ2xlKCkgb2YgMCByZWN0YW5nbGVzXCIpO2NvbnN0IGc9QVswXTtsZXR7bGVmdDplLHRvcDpCfT1nLGk9ZStnLndpZHRoLHQ9QitnLmhlaWdodDtmb3IobGV0IGc9MTtnPEk7ZysrKXtjb25zdCBJPUFbZ107ZT1NYXRoLm1pbihlLEkubGVmdCksQj1NYXRoLm1pbihCLEkudG9wKSxpPU1hdGgubWF4KGksSS5sZWZ0K0kud2lkdGgpLHQ9TWF0aC5tYXgodCxJLnRvcCtJLmhlaWdodCl9cmV0dXJue2xlZnQ6ZSx0b3A6Qix3aWR0aDppLWUsaGVpZ2h0OnQtQn19fSwxOTg6KEEsSSk9PntcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiBnKEEpe2lmKDA9PT1BLmxlbmd0aClyZXR1cm4gTmFOO2xldCBJPTA7Zm9yKGNvbnN0IGcgb2YgQSlJKz1nO3JldHVybiBJL0EubGVuZ3RofU9iamVjdC5kZWZpbmVQcm9wZXJ0eShJLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLEkubWVhbk9yWmVybz1JLm1lYW49SS5zdGFuZGFyZERldmlhdGlvbj1JLmludGVycXVhcnRpbGVSYW5nZT1JLm1lZGlhbj1JLldpbmRvd1RyYWNrPXZvaWQgMCxJLldpbmRvd1RyYWNrPWNsYXNze2NvbnN0cnVjdG9yKEEsSSl7dGhpcy5zaXplTXM9QSx0aGlzLmF2ZXJhZ2VPcGVyYXRpb249SSx0aGlzLmNhY2hlZEF2ZXJhZ2U9dm9pZCAwLHRoaXMuYnVmZmVyPVtdfWdldCB2YWx1ZXMoKXtyZXR1cm4gdGhpcy50cmltKCksdGhpcy5idWZmZXIubWFwKChBPT5BLnZhbHVlKSl9Z2V0IG1lYXN1cmVtZW50cygpe3JldHVybiB0aGlzLnRyaW0oKSx0aGlzLmJ1ZmZlcn10cmltKCl7Y29uc3QgQT1wZXJmb3JtYW5jZS5ub3coKSxJPXRoaXMuYnVmZmVyLmZpbmRJbmRleCgoST0+SS50aW1lPkEtdGhpcy5zaXplTXMpKTtJPjA/KHRoaXMuYnVmZmVyLnNwbGljZSgwLEkpLHRoaXMuY2FjaGVkQXZlcmFnZT12b2lkIDApOi0xPT09SSYmKHRoaXMuYnVmZmVyLnNwbGljZSgwLHRoaXMuYnVmZmVyLmxlbmd0aCksdGhpcy5jYWNoZWRBdmVyYWdlPXZvaWQgMCl9ZmVlZChBKXtjb25zdCBJPXBlcmZvcm1hbmNlLm5vdygpO3RoaXMuYnVmZmVyLnB1c2goe3RpbWU6SSx2YWx1ZTpBfSksdGhpcy5idWZmZXIubGVuZ3RoPj01MDAmJnRoaXMudHJpbSgpLHRoaXMuY2FjaGVkQXZlcmFnZT12b2lkIDB9YXZlcmFnZSgpe2lmKHRoaXMudHJpbSgpLHRoaXMuY2FjaGVkQXZlcmFnZSlyZXR1cm4gdGhpcy5jYWNoZWRBdmVyYWdlO2NvbnN0IEE9dGhpcy5idWZmZXIubWFwKChBPT5BLnZhbHVlKSk7cmV0dXJuIHRoaXMuY2FjaGVkQXZlcmFnZT10aGlzLmF2ZXJhZ2VPcGVyYXRpb24oQSl9fSxJLm1lZGlhbj1mdW5jdGlvbihBKXtyZXR1cm4gMD09PUEubGVuZ3RoP05hTjooQS5zb3J0KCgoQSxJKT0+QS1JKSksQVtNYXRoLmZsb29yKEEubGVuZ3RoLzIpXSl9LEkuaW50ZXJxdWFydGlsZVJhbmdlPWZ1bmN0aW9uKEEpe2lmKDA9PT1BLmxlbmd0aClyZXR1cm4gTmFOO0Euc29ydCgoKEEsSSk9PkEtSSkpO2NvbnN0IEk9TWF0aC5mbG9vciguMjUqQS5sZW5ndGgpO3JldHVybiBBW01hdGguZmxvb3IoLjc1KkEubGVuZ3RoKV0tQVtJXX0sSS5zdGFuZGFyZERldmlhdGlvbj1mdW5jdGlvbihBKXtpZigwPT09QS5sZW5ndGgpcmV0dXJuIE5hTjtjb25zdCBJPUEubGVuZ3RoLGc9QS5yZWR1Y2UoKChBLEkpPT5BK0kpLDApL0k7cmV0dXJuIE1hdGguc3FydChBLm1hcCgoQT0+TWF0aC5wb3coQS1nLDIpKSkucmVkdWNlKCgoQSxJKT0+QStJKSwwKS9JKX0sSS5tZWFuPWcsSS5tZWFuT3JaZXJvPWZ1bmN0aW9uKEEpe3JldHVybiAwPT09QS5sZW5ndGg/MDpnKEEpfX0sOTA0OmZ1bmN0aW9uKEEsSSxnKXtcInVzZSBzdHJpY3RcIjt2YXIgZT10aGlzJiZ0aGlzLl9fY3JlYXRlQmluZGluZ3x8KE9iamVjdC5jcmVhdGU/ZnVuY3Rpb24oQSxJLGcsZSl7dm9pZCAwPT09ZSYmKGU9ZyksT2JqZWN0LmRlZmluZVByb3BlcnR5KEEsZSx7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gSVtnXX19KX06ZnVuY3Rpb24oQSxJLGcsZSl7dm9pZCAwPT09ZSYmKGU9ZyksQVtlXT1JW2ddfSksQj10aGlzJiZ0aGlzLl9fZXhwb3J0U3Rhcnx8ZnVuY3Rpb24oQSxJKXtmb3IodmFyIGcgaW4gQSlcImRlZmF1bHRcIj09PWd8fE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChJLGcpfHxlKEksQSxnKX07T2JqZWN0LmRlZmluZVByb3BlcnR5KEksXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksQihnKDE2MiksSSl9LDE2MjooQSxJLGcpPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KEksXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksSS5XaW5kb3dzUG9pbnRlckZsYWdzPUkuVmlydHVhbEtleT1JLktleWJvYXJkQWN0aW9uPUkuU2Nyb2xsQXhpcz1JLk1vdXNlQnV0dG9uPUkuQnV0dG9uQWN0aW9uPUkuWElucHV0QnV0dG9ucz1JLkFyYml0cmFyeURhdGFncmFtPUkuTWVkaWFEYXRhZ3JhbT1JLkxvZ2ljRGF0YWdyYW09SS5JbnB1dERhdGFncmFtPUkuQ2h1bms9SS5SYWlud2F5SGVhZGVyPUkuR3VpZD1JLlRlbGVtZXRyeVZhbHVlVHlwZT1JLlJhaW53YXlUZWxlbWV0cnlEaW1lbnNpb249SS5SYWlud2F5VGVsZW1ldHJ5UmVjb3JkPUkuUmFpbndheVRlbGVtZXRyeVJlcXVlc3Q9SS5UZWxlbWV0cnlCYXRjaGVzS2V5VGVtcGxhdGU9SS5UZWxlbWV0cnlTZXRLZXk9SS5HYXRld2F5Rm9yd2FyZGFibGVCb2R5PUkuUGVlclNpZ25hbGluZ0luZm9ybWF0aW9uPUkuUmVqZWN0ZWRDb25uZWN0aW9uUmVxdWVzdD1JLkFjY2VwdGVkQ29ubmVjdGlvblJlcXVlc3Q9SS5Db25uZWN0aW9uUmVxdWVzdD1JLkdhdGV3YXlSZXNwb25zZUJvZHk9SS5HYXRld2F5SGVsbG89SS5HYXRld2F5UmVxdWVzdEJvZHk9SS5Jbml0Q29ubmVjdGlvblJlcXVlc3Q9SS5HYXRld2F5Qm9keT1JLkdhdGV3YXlGb3J3YXJkYWJsZT1JLkdhdGV3YXlBbGVydD1JLkdhdGV3YXlSZXNwb25zZT1JLkdhdGV3YXlSZXF1ZXN0PUkuR2F0ZXdheURhdGFncmFtPUkuR2F0ZXdheUhlYWRlcj1JLlBlbmRpbmdDb25uZWN0aW9uUmVxdWVzdD1JLlBlZXI9SS5HYXRld2F5SWRlbnRpdHk9SS5HYXRld2F5VHJ1bms9SS5QZWVySW5mb3JtYXRpb25UeXBlPUkuUGVlclRyYW5zcG9ydFR5cGU9SS5HYXRld2F5QWxlcnREZXNjcmlwdGlvbj1JLkdhdGV3YXlBbGVydExldmVsPUkuR2F0ZXdheVJlc3BvbnNlQ29udGV4dD1JLlBlZXJTZXRLZXlUZW1wbGF0ZT1JLkFjY2VwdGVkQ29ubmVjdGlvblJlcXVlc3RLZXlUZW1wbGF0ZT1JLlBlbmRpbmdDb25uZWN0aW9uUmVxdWVzdEtleVRlbXBsYXRlPUkuUGVlcktleVRlbXBsYXRlPUkuRGF0YWdyYW1DaGFubmVsPXZvaWQgMCxJLkxvZ2ljQm9keT1JLklucHV0TGV2ZWxSZXF1ZXN0PUkuSW5wdXRMZXZlbFVwZGF0ZT1JLlJlamVjdFN0cmVhbVJlcXVlc3Q9SS5QYXVzZVN0cmVhbT1JLkpvaW5TdHJlYW09SS5WaWRlb0JpdHJhdGVSZXF1ZXN0PUkuS2V5ZnJhbWVSZXF1ZXN0PUkuU3RyZWFtU3RvcHBpbmc9SS5MZWF2ZVN0cmVhbT1JLlN0cmVhbVN0YXJ0aW5nPUkuU3RyZWFtUmVxdWVzdD1JLkVycm9yUmVzcG9uc2U9SS5DbGllbnRDYXBhYmlsaXRpZXM9SS5Db2RlY1BhY2tSZXNwb25zZT1JLkNvZGVjUGFja1JlcXVlc3Q9SS5EZXZpY2VJbmZvPUkuSW5wdXRMZXZlbD1JLlZpZGVvQ29uZmlnPUkuQ2FwdHVyZU1vZGU9SS5BdWRpb0NvbmZpZz1JLkxvZ2ljRXJyb3I9SS5WaWRlb0NvbnRhaW5lcj1JLkF1ZGlvQ29udGFpbmVyPUkuQXVkaW9Db2RlYz1JLkF1ZGlvQ2hhbm5lbHM9SS5OZXR3b3JrUHJvdG9jb2w9SS5PcGVyYXRpbmdTeXN0ZW09SS5Gb3JtRmFjdG9yPUkuVmlkZW9Db2RlYz1JLlZlbmRvcj1JLlZpZGVvQ29kZWNUeXBlPUkuSW5wdXRCb2R5PUkuU2V0Q2xpcGJvYXJkVGV4dD1JLlZpZXdwb3J0UmVzaXplPUkuUGVuQWJzb2x1dGU9SS5Ub3VjaGVzQWJzb2x1dGU9SS5Mb2dpY2FsSW5wdXQ9SS5LZXlib2FyZElucHV0PUkuTW91c2VTY3JvbGw9SS5Nb3VzZUNsaWNrPUkuTW91c2VSZWxhdGl2ZT1JLk1vdXNlQWJzb2x1dGU9SS5HYW1lcGFkUnVtYmxlPUkuR2FtZXBhZFJlcG9ydD1JLlRvdWNoQWJzb2x1dGU9SS5QZW5GbGFncz1JLlBlbk1hc2s9SS5Ub3VjaE1hc2s9SS5Ub3VjaFBlblBvaW50ZXJJbmZvPXZvaWQgMCxJLk1lZGlhQm9keT1JLk1lZGlhQ2h1bms9SS5BdWRpb0RhdGE9SS5Qb2ludGVyRGF0YT1JLlZpZGVvRGF0YT1JLkRlc2t0b3BSZWN0PUkuQXVkaW9EYXRhVHlwZT1JLlZpZGVvRGF0YVR5cGU9dm9pZCAwO2NvbnN0IGU9ZygxMjApO3ZhciBCLGksdCxRLEMsRSxvLGEsbixzLHIsZCxoLGMsRCx3LHUseSxsLFMsRixSLEcsayxwLFUsbSxOLGY7SS5EYXRhZ3JhbUNoYW5uZWw9XCJuZXR3b3JrOmRhdGFncmFtc1wiLEkuUGVlcktleVRlbXBsYXRlPVwibmV0d29yazpwZWVyczp7MH1cIixJLlBlbmRpbmdDb25uZWN0aW9uUmVxdWVzdEtleVRlbXBsYXRlPVwibmV0d29yazpjb25uZWN0aW9uLnJlcXVlc3RzOnBlbmRpbmc6ezB9XCIsSS5BY2NlcHRlZENvbm5lY3Rpb25SZXF1ZXN0S2V5VGVtcGxhdGU9XCJuZXR3b3JrOmNvbm5lY3Rpb24ucmVxdWVzdHM6YWNjZXB0ZWQ6ezB9XCIsSS5QZWVyU2V0S2V5VGVtcGxhdGU9XCJuZXR3b3JrOmFjdGl2ZS5wZWVyczp7MH1cIixJLkdhdGV3YXlSZXNwb25zZUNvbnRleHQ9e2VuY29kZShBKXtjb25zdCBJPWUuQmVib3BWaWV3LmdldEluc3RhbmNlKCk7cmV0dXJuIEkuc3RhcnRXcml0aW5nKCksdGhpcy5lbmNvZGVJbnRvKEEsSSksSS50b0FycmF5KCl9LGVuY29kZUludG8oQSxnKXtjb25zdCBlPWcubGVuZ3RoO3JldHVybiBnLndyaXRlSW50NjQoQS5zb3VyY2VQZWVySWQpLGcud3JpdGVJbnQ2NChBLnRhcmdldFBlZXJJZCksSS5HYXRld2F5RGF0YWdyYW0uZW5jb2RlSW50byhBLmRhdGFncmFtLGcpLGcubGVuZ3RoLWV9LGRlY29kZShBKXtjb25zdCBJPWUuQmVib3BWaWV3LmdldEluc3RhbmNlKCk7cmV0dXJuIEkuc3RhcnRSZWFkaW5nKEEpLHRoaXMucmVhZEZyb20oSSl9LHJlYWRGcm9tKEEpe2xldCBnLGUsQjtyZXR1cm4gZz1BLnJlYWRJbnQ2NCgpLGU9QS5yZWFkSW50NjQoKSxCPUkuR2F0ZXdheURhdGFncmFtLnJlYWRGcm9tKEEpLHtzb3VyY2VQZWVySWQ6Zyx0YXJnZXRQZWVySWQ6ZSxkYXRhZ3JhbTpCfX19LChmPUkuR2F0ZXdheUFsZXJ0TGV2ZWx8fChJLkdhdGV3YXlBbGVydExldmVsPXt9KSlbZi5Vbmtub3duPTBdPVwiVW5rbm93blwiLGZbZi5XYXJuaW5nPTFdPVwiV2FybmluZ1wiLGZbZi5GYXRhbD0yXT1cIkZhdGFsXCIsKE49SS5HYXRld2F5QWxlcnREZXNjcmlwdGlvbnx8KEkuR2F0ZXdheUFsZXJ0RGVzY3JpcHRpb249e30pKVtOLkNsb3NlTm90aWZ5PTBdPVwiQ2xvc2VOb3RpZnlcIixOW04uVW5leHBlY3RlZE1lc3NhZ2U9MTBdPVwiVW5leHBlY3RlZE1lc3NhZ2VcIixOW04uUmVjb3JkT3ZlcmZsb3c9MjBdPVwiUmVjb3JkT3ZlcmZsb3dcIixOW04uVGlja2V0VmFsaWRhdGlvbkVycm9yPTMwXT1cIlRpY2tldFZhbGlkYXRpb25FcnJvclwiLE5bTi5BY2Nlc3NEZW5pZWQ9NDldPVwiQWNjZXNzRGVuaWVkXCIsTltOLkRlY29kZUVycm9yPTUwXT1cIkRlY29kZUVycm9yXCIsTltOLkRlY3J5cHRFcnJvcj01MV09XCJEZWNyeXB0RXJyb3JcIixOW04uUHJvdG9jb2xWZXJzaW9uPTcwXT1cIlByb3RvY29sVmVyc2lvblwiLE5bTi5JbnRlcm5hbEVycm9yPTgwXT1cIkludGVybmFsRXJyb3JcIixOW04uUGVlckdvbmVBd2F5PTkwXT1cIlBlZXJHb25lQXdheVwiLE5bTi5Db21taXRGYWlsdXJlPTEwMF09XCJDb21taXRGYWlsdXJlXCIsTltOLlJlc291cmNlRXhwaXJlZD0yMDBdPVwiUmVzb3VyY2VFeHBpcmVkXCIsKG09SS5QZWVyVHJhbnNwb3J0VHlwZXx8KEkuUGVlclRyYW5zcG9ydFR5cGU9e30pKVttLkludmFsaWQ9MF09XCJJbnZhbGlkXCIsbVttLlNDVFA9MV09XCJTQ1RQXCIsbVttLkdVRFA9Ml09XCJHVURQXCIsbVttLlJlc2VydmVkPTNdPVwiUmVzZXJ2ZWRcIiwoVT1JLlBlZXJJbmZvcm1hdGlvblR5cGV8fChJLlBlZXJJbmZvcm1hdGlvblR5cGU9e30pKVtVLkludmFsaWQ9MF09XCJJbnZhbGlkXCIsVVtVLk9mZmVyPTFdPVwiT2ZmZXJcIixVW1UuQW5zd2VyPTJdPVwiQW5zd2VyXCIsVVtVLkNhbmRpZGF0ZT0zXT1cIkNhbmRpZGF0ZVwiLEkuR2F0ZXdheVRydW5rPXtlbmNvZGUoQSl7Y29uc3QgST1lLkJlYm9wVmlldy5nZXRJbnN0YW5jZSgpO3JldHVybiBJLnN0YXJ0V3JpdGluZygpLHRoaXMuZW5jb2RlSW50byhBLEkpLEkudG9BcnJheSgpfSxlbmNvZGVJbnRvKEEsSSl7Y29uc3QgZz1JLmxlbmd0aDtyZXR1cm4gSS53cml0ZVN0cmluZyhBLm1hY2hpbmVJZCksSS53cml0ZURhdGUoQS5zdGFydERhdGUpLEkubGVuZ3RoLWd9LGRlY29kZShBKXtjb25zdCBJPWUuQmVib3BWaWV3LmdldEluc3RhbmNlKCk7cmV0dXJuIEkuc3RhcnRSZWFkaW5nKEEpLHRoaXMucmVhZEZyb20oSSl9LHJlYWRGcm9tKEEpe2xldCBJLGc7cmV0dXJuIEk9QS5yZWFkU3RyaW5nKCksZz1BLnJlYWREYXRlKCkse21hY2hpbmVJZDpJLHN0YXJ0RGF0ZTpnfX19LEkuR2F0ZXdheUlkZW50aXR5PXtlbmNvZGUoQSl7Y29uc3QgST1lLkJlYm9wVmlldy5nZXRJbnN0YW5jZSgpO3JldHVybiBJLnN0YXJ0V3JpdGluZygpLHRoaXMuZW5jb2RlSW50byhBLEkpLEkudG9BcnJheSgpfSxlbmNvZGVJbnRvKEEsSSl7Y29uc3QgZz1JLmxlbmd0aDtyZXR1cm4gSS53cml0ZVN0cmluZyhBLmFwaUtleSksSS53cml0ZUludDY0KEEuaWQpLEkud3JpdGVTdHJpbmcoQS5leHRlcm5hbElkKSxJLmxlbmd0aC1nfSxkZWNvZGUoQSl7Y29uc3QgST1lLkJlYm9wVmlldy5nZXRJbnN0YW5jZSgpO3JldHVybiBJLnN0YXJ0UmVhZGluZyhBKSx0aGlzLnJlYWRGcm9tKEkpfSxyZWFkRnJvbShBKXtsZXQgSSxnLGU7cmV0dXJuIEk9QS5yZWFkU3RyaW5nKCksZz1BLnJlYWRJbnQ2NCgpLGU9QS5yZWFkU3RyaW5nKCkse2FwaUtleTpJLGlkOmcsZXh0ZXJuYWxJZDplfX19LEkuUGVlcj17ZW5jb2RlKEEpe2NvbnN0IEk9ZS5CZWJvcFZpZXcuZ2V0SW5zdGFuY2UoKTtyZXR1cm4gSS5zdGFydFdyaXRpbmcoKSx0aGlzLmVuY29kZUludG8oQSxJKSxJLnRvQXJyYXkoKX0sZW5jb2RlSW50byhBLEkpe2NvbnN0IGc9SS5sZW5ndGg7cmV0dXJuIEkud3JpdGVJbnQ2NChBLmlkKSxJLndyaXRlU3RyaW5nKEEuZXh0ZXJuYWxJZCksSS53cml0ZURhdGUoQS5jb25uZWN0aW9uRGF0ZSksSS53cml0ZUludDY0KEEub3JnYW5pemF0aW9uSWQpLEkubGVuZ3RoLWd9LGRlY29kZShBKXtjb25zdCBJPWUuQmVib3BWaWV3LmdldEluc3RhbmNlKCk7cmV0dXJuIEkuc3RhcnRSZWFkaW5nKEEpLHRoaXMucmVhZEZyb20oSSl9LHJlYWRGcm9tKEEpe2xldCBJLGcsZSxCO3JldHVybiBJPUEucmVhZEludDY0KCksZz1BLnJlYWRTdHJpbmcoKSxlPUEucmVhZERhdGUoKSxCPUEucmVhZEludDY0KCkse2lkOkksZXh0ZXJuYWxJZDpnLGNvbm5lY3Rpb25EYXRlOmUsb3JnYW5pemF0aW9uSWQ6Qn19fSxJLlBlbmRpbmdDb25uZWN0aW9uUmVxdWVzdD17ZW5jb2RlKEEpe2NvbnN0IEk9ZS5CZWJvcFZpZXcuZ2V0SW5zdGFuY2UoKTtyZXR1cm4gSS5zdGFydFdyaXRpbmcoKSx0aGlzLmVuY29kZUludG8oQSxJKSxJLnRvQXJyYXkoKX0sZW5jb2RlSW50byhBLEkpe2NvbnN0IGc9SS5sZW5ndGg7cmV0dXJuIEkud3JpdGVJbnQ2NChBLnNvdXJjZVBlZXJJZCksSS53cml0ZUludDY0KEEudGFyZ2V0UGVlcklkKSxJLmxlbmd0aC1nfSxkZWNvZGUoQSl7Y29uc3QgST1lLkJlYm9wVmlldy5nZXRJbnN0YW5jZSgpO3JldHVybiBJLnN0YXJ0UmVhZGluZyhBKSx0aGlzLnJlYWRGcm9tKEkpfSxyZWFkRnJvbShBKXtsZXQgSSxnO3JldHVybiBJPUEucmVhZEludDY0KCksZz1BLnJlYWRJbnQ2NCgpLHtzb3VyY2VQZWVySWQ6SSx0YXJnZXRQZWVySWQ6Z319fSxJLkdhdGV3YXlIZWFkZXI9e2VuY29kZShBKXtjb25zdCBJPWUuQmVib3BWaWV3LmdldEluc3RhbmNlKCk7cmV0dXJuIEkuc3RhcnRXcml0aW5nKCksdGhpcy5lbmNvZGVJbnRvKEEsSSksSS50b0FycmF5KCl9LGVuY29kZUludG8oQSxJKXtjb25zdCBnPUkubGVuZ3RoO3JldHVybiBJLndyaXRlVWludDMyKEEuc3luY0tleSksSS5sZW5ndGgtZ30sZGVjb2RlKEEpe2NvbnN0IEk9ZS5CZWJvcFZpZXcuZ2V0SW5zdGFuY2UoKTtyZXR1cm4gSS5zdGFydFJlYWRpbmcoQSksdGhpcy5yZWFkRnJvbShJKX0scmVhZEZyb20oQSl7bGV0IEk7cmV0dXJuIEk9QS5yZWFkVWludDMyKCkse3N5bmNLZXk6SX19fSxJLkdhdGV3YXlEYXRhZ3JhbT17ZW5jb2RlKEEpe2NvbnN0IEk9ZS5CZWJvcFZpZXcuZ2V0SW5zdGFuY2UoKTtyZXR1cm4gSS5zdGFydFdyaXRpbmcoKSx0aGlzLmVuY29kZUludG8oQSxJKSxJLnRvQXJyYXkoKX0sZW5jb2RlSW50byhBLGcpe2NvbnN0IGU9Zy5sZW5ndGg7cmV0dXJuIEkuR2F0ZXdheUhlYWRlci5lbmNvZGVJbnRvKEEuaGVhZGVyLGcpLEkuR2F0ZXdheUJvZHkuZW5jb2RlSW50byhBLmJvZHksZyksZy5sZW5ndGgtZX0sZGVjb2RlKEEpe2NvbnN0IEk9ZS5CZWJvcFZpZXcuZ2V0SW5zdGFuY2UoKTtyZXR1cm4gSS5zdGFydFJlYWRpbmcoQSksdGhpcy5yZWFkRnJvbShJKX0scmVhZEZyb20oQSl7bGV0IGcsZTtyZXR1cm4gZz1JLkdhdGV3YXlIZWFkZXIucmVhZEZyb20oQSksZT1JLkdhdGV3YXlCb2R5LnJlYWRGcm9tKEEpLHtoZWFkZXI6Zyxib2R5OmV9fX0sSS5HYXRld2F5UmVxdWVzdD17ZGlzY3JpbWluYXRvcjoxLGVuY29kZShBKXtjb25zdCBJPWUuQmVib3BWaWV3LmdldEluc3RhbmNlKCk7cmV0dXJuIEkuc3RhcnRXcml0aW5nKCksdGhpcy5lbmNvZGVJbnRvKEEsSSksSS50b0FycmF5KCl9LGVuY29kZUludG8oQSxnKXtjb25zdCBlPWcubGVuZ3RoO3JldHVybiBJLkdhdGV3YXlSZXF1ZXN0Qm9keS5lbmNvZGVJbnRvKEEuYm9keSxnKSxnLmxlbmd0aC1lfSxkZWNvZGUoQSl7Y29uc3QgST1lLkJlYm9wVmlldy5nZXRJbnN0YW5jZSgpO3JldHVybiBJLnN0YXJ0UmVhZGluZyhBKSx0aGlzLnJlYWRGcm9tKEkpfSxyZWFkRnJvbShBKXtsZXQgZztyZXR1cm4gZz1JLkdhdGV3YXlSZXF1ZXN0Qm9keS5yZWFkRnJvbShBKSx7Ym9keTpnfX19LEkuR2F0ZXdheVJlc3BvbnNlPXtkaXNjcmltaW5hdG9yOjIsZW5jb2RlKEEpe2NvbnN0IEk9ZS5CZWJvcFZpZXcuZ2V0SW5zdGFuY2UoKTtyZXR1cm4gSS5zdGFydFdyaXRpbmcoKSx0aGlzLmVuY29kZUludG8oQSxJKSxJLnRvQXJyYXkoKX0sZW5jb2RlSW50byhBLGcpe2NvbnN0IGU9Zy5sZW5ndGg7cmV0dXJuIEkuR2F0ZXdheVJlc3BvbnNlQm9keS5lbmNvZGVJbnRvKEEuYm9keSxnKSxnLmxlbmd0aC1lfSxkZWNvZGUoQSl7Y29uc3QgST1lLkJlYm9wVmlldy5nZXRJbnN0YW5jZSgpO3JldHVybiBJLnN0YXJ0UmVhZGluZyhBKSx0aGlzLnJlYWRGcm9tKEkpfSxyZWFkRnJvbShBKXtsZXQgZztyZXR1cm4gZz1JLkdhdGV3YXlSZXNwb25zZUJvZHkucmVhZEZyb20oQSkse2JvZHk6Z319fSxJLkdhdGV3YXlBbGVydD17ZGlzY3JpbWluYXRvcjozLGVuY29kZShBKXtjb25zdCBJPWUuQmVib3BWaWV3LmdldEluc3RhbmNlKCk7cmV0dXJuIEkuc3RhcnRXcml0aW5nKCksdGhpcy5lbmNvZGVJbnRvKEEsSSksSS50b0FycmF5KCl9LGVuY29kZUludG8oQSxJKXtjb25zdCBnPUkubGVuZ3RoO3JldHVybiBJLndyaXRlVWludDMyKEEubGV2ZWwpLEkud3JpdGVVaW50MzIoQS5kZXNjcmlwdGlvbiksSS5sZW5ndGgtZ30sZGVjb2RlKEEpe2NvbnN0IEk9ZS5CZWJvcFZpZXcuZ2V0SW5zdGFuY2UoKTtyZXR1cm4gSS5zdGFydFJlYWRpbmcoQSksdGhpcy5yZWFkRnJvbShJKX0scmVhZEZyb20oQSl7bGV0IEksZztyZXR1cm4gST1BLnJlYWRVaW50MzIoKSxnPUEucmVhZFVpbnQzMigpLHtsZXZlbDpJLGRlc2NyaXB0aW9uOmd9fX0sSS5HYXRld2F5Rm9yd2FyZGFibGU9e2Rpc2NyaW1pbmF0b3I6NCxlbmNvZGUoQSl7Y29uc3QgST1lLkJlYm9wVmlldy5nZXRJbnN0YW5jZSgpO3JldHVybiBJLnN0YXJ0V3JpdGluZygpLHRoaXMuZW5jb2RlSW50byhBLEkpLEkudG9BcnJheSgpfSxlbmNvZGVJbnRvKEEsZyl7Y29uc3QgZT1nLmxlbmd0aDtyZXR1cm4gZy53cml0ZUludDY0KEEudGFyZ2V0UGVlcklkKSxJLkdhdGV3YXlGb3J3YXJkYWJsZUJvZHkuZW5jb2RlSW50byhBLmJvZHksZyksZy5sZW5ndGgtZX0sZGVjb2RlKEEpe2NvbnN0IEk9ZS5CZWJvcFZpZXcuZ2V0SW5zdGFuY2UoKTtyZXR1cm4gSS5zdGFydFJlYWRpbmcoQSksdGhpcy5yZWFkRnJvbShJKX0scmVhZEZyb20oQSl7bGV0IGcsZTtyZXR1cm4gZz1BLnJlYWRJbnQ2NCgpLGU9SS5HYXRld2F5Rm9yd2FyZGFibGVCb2R5LnJlYWRGcm9tKEEpLHt0YXJnZXRQZWVySWQ6Zyxib2R5OmV9fX0sSS5HYXRld2F5Qm9keT17ZW5jb2RlKEEpe2NvbnN0IEk9ZS5CZWJvcFZpZXcuZ2V0SW5zdGFuY2UoKTtyZXR1cm4gSS5zdGFydFdyaXRpbmcoKSx0aGlzLmVuY29kZUludG8oQSxJKSxJLnRvQXJyYXkoKX0sZW5jb2RlSW50byhBLGcpe2NvbnN0IGU9Zy5sZW5ndGgsQj1nLnJlc2VydmVNZXNzYWdlTGVuZ3RoKCksaT1nLmxlbmd0aCsxO3N3aXRjaChnLndyaXRlQnl0ZShBLmRpc2NyaW1pbmF0b3IpLEEuZGlzY3JpbWluYXRvcil7Y2FzZSAxOkkuR2F0ZXdheVJlcXVlc3QuZW5jb2RlSW50byhBLnZhbHVlLGcpO2JyZWFrO2Nhc2UgMjpJLkdhdGV3YXlSZXNwb25zZS5lbmNvZGVJbnRvKEEudmFsdWUsZyk7YnJlYWs7Y2FzZSAzOkkuR2F0ZXdheUFsZXJ0LmVuY29kZUludG8oQS52YWx1ZSxnKTticmVhaztjYXNlIDQ6SS5HYXRld2F5Rm9yd2FyZGFibGUuZW5jb2RlSW50byhBLnZhbHVlLGcpfWNvbnN0IHQ9Zy5sZW5ndGg7cmV0dXJuIGcuZmlsbE1lc3NhZ2VMZW5ndGgoQix0LWkpLGcubGVuZ3RoLWV9LGRlY29kZShBKXtjb25zdCBJPWUuQmVib3BWaWV3LmdldEluc3RhbmNlKCk7cmV0dXJuIEkuc3RhcnRSZWFkaW5nKEEpLHRoaXMucmVhZEZyb20oSSl9LHJlYWRGcm9tKEEpe2NvbnN0IGc9QS5yZWFkTWVzc2FnZUxlbmd0aCgpLEI9QS5pbmRleCsxK2c7c3dpdGNoKEEucmVhZEJ5dGUoKSl7Y2FzZSAxOnJldHVybntkaXNjcmltaW5hdG9yOjEsdmFsdWU6SS5HYXRld2F5UmVxdWVzdC5yZWFkRnJvbShBKX07Y2FzZSAyOnJldHVybntkaXNjcmltaW5hdG9yOjIsdmFsdWU6SS5HYXRld2F5UmVzcG9uc2UucmVhZEZyb20oQSl9O2Nhc2UgMzpyZXR1cm57ZGlzY3JpbWluYXRvcjozLHZhbHVlOkkuR2F0ZXdheUFsZXJ0LnJlYWRGcm9tKEEpfTtjYXNlIDQ6cmV0dXJue2Rpc2NyaW1pbmF0b3I6NCx2YWx1ZTpJLkdhdGV3YXlGb3J3YXJkYWJsZS5yZWFkRnJvbShBKX07ZGVmYXVsdDp0aHJvdyBBLmluZGV4PUIsbmV3IGUuQmVib3BSdW50aW1lRXJyb3IoXCJVbnJlY29nbml6ZWQgZGlzY3JpbWluYXRvciB3aGlsZSBkZWNvZGluZyBHYXRld2F5Qm9keVwiKX19fSxJLkluaXRDb25uZWN0aW9uUmVxdWVzdD17ZGlzY3JpbWluYXRvcjoxLGVuY29kZShBKXtjb25zdCBJPWUuQmVib3BWaWV3LmdldEluc3RhbmNlKCk7cmV0dXJuIEkuc3RhcnRXcml0aW5nKCksdGhpcy5lbmNvZGVJbnRvKEEsSSksSS50b0FycmF5KCl9LGVuY29kZUludG8oQSxJKXtjb25zdCBnPUkubGVuZ3RoO3JldHVybiBJLndyaXRlSW50NjQoQS50YXJnZXRQZWVySWQpLEkud3JpdGVVaW50MzIoQS5kZXNpcmVkVHJhbnNwb3J0KSxJLmxlbmd0aC1nfSxkZWNvZGUoQSl7Y29uc3QgST1lLkJlYm9wVmlldy5nZXRJbnN0YW5jZSgpO3JldHVybiBJLnN0YXJ0UmVhZGluZyhBKSx0aGlzLnJlYWRGcm9tKEkpfSxyZWFkRnJvbShBKXtsZXQgSSxnO3JldHVybiBJPUEucmVhZEludDY0KCksZz1BLnJlYWRVaW50MzIoKSx7dGFyZ2V0UGVlcklkOkksZGVzaXJlZFRyYW5zcG9ydDpnfX19LEkuR2F0ZXdheVJlcXVlc3RCb2R5PXtlbmNvZGUoQSl7Y29uc3QgST1lLkJlYm9wVmlldy5nZXRJbnN0YW5jZSgpO3JldHVybiBJLnN0YXJ0V3JpdGluZygpLHRoaXMuZW5jb2RlSW50byhBLEkpLEkudG9BcnJheSgpfSxlbmNvZGVJbnRvKEEsZyl7Y29uc3QgZT1nLmxlbmd0aCxCPWcucmVzZXJ2ZU1lc3NhZ2VMZW5ndGgoKSxpPWcubGVuZ3RoKzE7Zy53cml0ZUJ5dGUoQS5kaXNjcmltaW5hdG9yKSwxPT09QS5kaXNjcmltaW5hdG9yJiZJLkluaXRDb25uZWN0aW9uUmVxdWVzdC5lbmNvZGVJbnRvKEEudmFsdWUsZyk7Y29uc3QgdD1nLmxlbmd0aDtyZXR1cm4gZy5maWxsTWVzc2FnZUxlbmd0aChCLHQtaSksZy5sZW5ndGgtZX0sZGVjb2RlKEEpe2NvbnN0IEk9ZS5CZWJvcFZpZXcuZ2V0SW5zdGFuY2UoKTtyZXR1cm4gSS5zdGFydFJlYWRpbmcoQSksdGhpcy5yZWFkRnJvbShJKX0scmVhZEZyb20oQSl7Y29uc3QgZz1BLnJlYWRNZXNzYWdlTGVuZ3RoKCksQj1BLmluZGV4KzErZztpZigxPT09QS5yZWFkQnl0ZSgpKXJldHVybntkaXNjcmltaW5hdG9yOjEsdmFsdWU6SS5Jbml0Q29ubmVjdGlvblJlcXVlc3QucmVhZEZyb20oQSl9O3Rocm93IEEuaW5kZXg9QixuZXcgZS5CZWJvcFJ1bnRpbWVFcnJvcihcIlVucmVjb2duaXplZCBkaXNjcmltaW5hdG9yIHdoaWxlIGRlY29kaW5nIEdhdGV3YXlSZXF1ZXN0Qm9keVwiKX19LEkuR2F0ZXdheUhlbGxvPXtkaXNjcmltaW5hdG9yOjEsZW5jb2RlKEEpe2NvbnN0IEk9ZS5CZWJvcFZpZXcuZ2V0SW5zdGFuY2UoKTtyZXR1cm4gSS5zdGFydFdyaXRpbmcoKSx0aGlzLmVuY29kZUludG8oQSxJKSxJLnRvQXJyYXkoKX0sZW5jb2RlSW50byhBLEkpe2NvbnN0IGc9SS5sZW5ndGg7cmV0dXJuIEkubGVuZ3RoLWd9LGRlY29kZShBKXtjb25zdCBJPWUuQmVib3BWaWV3LmdldEluc3RhbmNlKCk7cmV0dXJuIEkuc3RhcnRSZWFkaW5nKEEpLHRoaXMucmVhZEZyb20oSSl9LHJlYWRGcm9tOkE9Pih7fSl9LEkuR2F0ZXdheVJlc3BvbnNlQm9keT17ZW5jb2RlKEEpe2NvbnN0IEk9ZS5CZWJvcFZpZXcuZ2V0SW5zdGFuY2UoKTtyZXR1cm4gSS5zdGFydFdyaXRpbmcoKSx0aGlzLmVuY29kZUludG8oQSxJKSxJLnRvQXJyYXkoKX0sZW5jb2RlSW50byhBLGcpe2NvbnN0IGU9Zy5sZW5ndGgsQj1nLnJlc2VydmVNZXNzYWdlTGVuZ3RoKCksaT1nLmxlbmd0aCsxO2cud3JpdGVCeXRlKEEuZGlzY3JpbWluYXRvciksMT09PUEuZGlzY3JpbWluYXRvciYmSS5HYXRld2F5SGVsbG8uZW5jb2RlSW50byhBLnZhbHVlLGcpO2NvbnN0IHQ9Zy5sZW5ndGg7cmV0dXJuIGcuZmlsbE1lc3NhZ2VMZW5ndGgoQix0LWkpLGcubGVuZ3RoLWV9LGRlY29kZShBKXtjb25zdCBJPWUuQmVib3BWaWV3LmdldEluc3RhbmNlKCk7cmV0dXJuIEkuc3RhcnRSZWFkaW5nKEEpLHRoaXMucmVhZEZyb20oSSl9LHJlYWRGcm9tKEEpe2NvbnN0IGc9QS5yZWFkTWVzc2FnZUxlbmd0aCgpLEI9QS5pbmRleCsxK2c7aWYoMT09PUEucmVhZEJ5dGUoKSlyZXR1cm57ZGlzY3JpbWluYXRvcjoxLHZhbHVlOkkuR2F0ZXdheUhlbGxvLnJlYWRGcm9tKEEpfTt0aHJvdyBBLmluZGV4PUIsbmV3IGUuQmVib3BSdW50aW1lRXJyb3IoXCJVbnJlY29nbml6ZWQgZGlzY3JpbWluYXRvciB3aGlsZSBkZWNvZGluZyBHYXRld2F5UmVzcG9uc2VCb2R5XCIpfX0sSS5Db25uZWN0aW9uUmVxdWVzdD17ZGlzY3JpbWluYXRvcjoxLGVuY29kZShBKXtjb25zdCBJPWUuQmVib3BWaWV3LmdldEluc3RhbmNlKCk7cmV0dXJuIEkuc3RhcnRXcml0aW5nKCksdGhpcy5lbmNvZGVJbnRvKEEsSSksSS50b0FycmF5KCl9LGVuY29kZUludG8oQSxJKXtjb25zdCBnPUkubGVuZ3RoO3JldHVybiBJLndyaXRlSW50NjQoQS5zb3VyY2VQZWVySWQpLEkud3JpdGVTdHJpbmcoQS5zb3VyY2VFeHRlcm5hbElkKSxJLndyaXRlVWludDMyKEEuZGVzaXJlZFRyYW5zcG9ydCksSS53cml0ZUd1aWQoQS5pZCksSS53cml0ZURhdGUoQS5leHBpcmF0aW9uRGF0ZSksSS5sZW5ndGgtZ30sZGVjb2RlKEEpe2NvbnN0IEk9ZS5CZWJvcFZpZXcuZ2V0SW5zdGFuY2UoKTtyZXR1cm4gSS5zdGFydFJlYWRpbmcoQSksdGhpcy5yZWFkRnJvbShJKX0scmVhZEZyb20oQSl7bGV0IEksZyxlLEIsaTtyZXR1cm4gST1BLnJlYWRJbnQ2NCgpLGc9QS5yZWFkU3RyaW5nKCksZT1BLnJlYWRVaW50MzIoKSxCPUEucmVhZEd1aWQoKSxpPUEucmVhZERhdGUoKSx7c291cmNlUGVlcklkOkksc291cmNlRXh0ZXJuYWxJZDpnLGRlc2lyZWRUcmFuc3BvcnQ6ZSxpZDpCLGV4cGlyYXRpb25EYXRlOml9fX0sSS5BY2NlcHRlZENvbm5lY3Rpb25SZXF1ZXN0PXtkaXNjcmltaW5hdG9yOjIsZW5jb2RlKEEpe2NvbnN0IEk9ZS5CZWJvcFZpZXcuZ2V0SW5zdGFuY2UoKTtyZXR1cm4gSS5zdGFydFdyaXRpbmcoKSx0aGlzLmVuY29kZUludG8oQSxJKSxJLnRvQXJyYXkoKX0sZW5jb2RlSW50byhBLEkpe2NvbnN0IGc9SS5sZW5ndGg7cmV0dXJuIEkud3JpdGVJbnQ2NChBLnNvdXJjZVBlZXJJZCksSS53cml0ZVN0cmluZyhBLnNvdXJjZUV4dGVybmFsSWQpLEkud3JpdGVHdWlkKEEuaWQpLEkubGVuZ3RoLWd9LGRlY29kZShBKXtjb25zdCBJPWUuQmVib3BWaWV3LmdldEluc3RhbmNlKCk7cmV0dXJuIEkuc3RhcnRSZWFkaW5nKEEpLHRoaXMucmVhZEZyb20oSSl9LHJlYWRGcm9tKEEpe2xldCBJLGcsZTtyZXR1cm4gST1BLnJlYWRJbnQ2NCgpLGc9QS5yZWFkU3RyaW5nKCksZT1BLnJlYWRHdWlkKCkse3NvdXJjZVBlZXJJZDpJLHNvdXJjZUV4dGVybmFsSWQ6ZyxpZDplfX19LEkuUmVqZWN0ZWRDb25uZWN0aW9uUmVxdWVzdD17ZGlzY3JpbWluYXRvcjozLGVuY29kZShBKXtjb25zdCBJPWUuQmVib3BWaWV3LmdldEluc3RhbmNlKCk7cmV0dXJuIEkuc3RhcnRXcml0aW5nKCksdGhpcy5lbmNvZGVJbnRvKEEsSSksSS50b0FycmF5KCl9LGVuY29kZUludG8oQSxJKXtjb25zdCBnPUkubGVuZ3RoO3JldHVybiBJLndyaXRlSW50NjQoQS5zb3VyY2VQZWVySWQpLEkud3JpdGVTdHJpbmcoQS5zb3VyY2VFeHRlcm5hbElkKSxJLndyaXRlR3VpZChBLmlkKSxJLndyaXRlU3RyaW5nKEEucmVhc29uKSxJLmxlbmd0aC1nfSxkZWNvZGUoQSl7Y29uc3QgST1lLkJlYm9wVmlldy5nZXRJbnN0YW5jZSgpO3JldHVybiBJLnN0YXJ0UmVhZGluZyhBKSx0aGlzLnJlYWRGcm9tKEkpfSxyZWFkRnJvbShBKXtsZXQgSSxnLGUsQjtyZXR1cm4gST1BLnJlYWRJbnQ2NCgpLGc9QS5yZWFkU3RyaW5nKCksZT1BLnJlYWRHdWlkKCksQj1BLnJlYWRTdHJpbmcoKSx7c291cmNlUGVlcklkOkksc291cmNlRXh0ZXJuYWxJZDpnLGlkOmUscmVhc29uOkJ9fX0sSS5QZWVyU2lnbmFsaW5nSW5mb3JtYXRpb249e2Rpc2NyaW1pbmF0b3I6NCxlbmNvZGUoQSl7Y29uc3QgST1lLkJlYm9wVmlldy5nZXRJbnN0YW5jZSgpO3JldHVybiBJLnN0YXJ0V3JpdGluZygpLHRoaXMuZW5jb2RlSW50byhBLEkpLEkudG9BcnJheSgpfSxlbmNvZGVJbnRvKEEsSSl7Y29uc3QgZz1JLmxlbmd0aDtyZXR1cm4gSS53cml0ZUd1aWQoQS5pZCksSS53cml0ZVVpbnQzMihBLnR5cGUpLEkud3JpdGVTdHJpbmcoQS5kYXRhKSxJLmxlbmd0aC1nfSxkZWNvZGUoQSl7Y29uc3QgST1lLkJlYm9wVmlldy5nZXRJbnN0YW5jZSgpO3JldHVybiBJLnN0YXJ0UmVhZGluZyhBKSx0aGlzLnJlYWRGcm9tKEkpfSxyZWFkRnJvbShBKXtsZXQgSSxnLGU7cmV0dXJuIEk9QS5yZWFkR3VpZCgpLGc9QS5yZWFkVWludDMyKCksZT1BLnJlYWRTdHJpbmcoKSx7aWQ6SSx0eXBlOmcsZGF0YTplfX19LEkuR2F0ZXdheUZvcndhcmRhYmxlQm9keT17ZW5jb2RlKEEpe2NvbnN0IEk9ZS5CZWJvcFZpZXcuZ2V0SW5zdGFuY2UoKTtyZXR1cm4gSS5zdGFydFdyaXRpbmcoKSx0aGlzLmVuY29kZUludG8oQSxJKSxJLnRvQXJyYXkoKX0sZW5jb2RlSW50byhBLGcpe2NvbnN0IGU9Zy5sZW5ndGgsQj1nLnJlc2VydmVNZXNzYWdlTGVuZ3RoKCksaT1nLmxlbmd0aCsxO3N3aXRjaChnLndyaXRlQnl0ZShBLmRpc2NyaW1pbmF0b3IpLEEuZGlzY3JpbWluYXRvcil7Y2FzZSAxOkkuQ29ubmVjdGlvblJlcXVlc3QuZW5jb2RlSW50byhBLnZhbHVlLGcpO2JyZWFrO2Nhc2UgMjpJLkFjY2VwdGVkQ29ubmVjdGlvblJlcXVlc3QuZW5jb2RlSW50byhBLnZhbHVlLGcpO2JyZWFrO2Nhc2UgMzpJLlJlamVjdGVkQ29ubmVjdGlvblJlcXVlc3QuZW5jb2RlSW50byhBLnZhbHVlLGcpO2JyZWFrO2Nhc2UgNDpJLlBlZXJTaWduYWxpbmdJbmZvcm1hdGlvbi5lbmNvZGVJbnRvKEEudmFsdWUsZyl9Y29uc3QgdD1nLmxlbmd0aDtyZXR1cm4gZy5maWxsTWVzc2FnZUxlbmd0aChCLHQtaSksZy5sZW5ndGgtZX0sZGVjb2RlKEEpe2NvbnN0IEk9ZS5CZWJvcFZpZXcuZ2V0SW5zdGFuY2UoKTtyZXR1cm4gSS5zdGFydFJlYWRpbmcoQSksdGhpcy5yZWFkRnJvbShJKX0scmVhZEZyb20oQSl7Y29uc3QgZz1BLnJlYWRNZXNzYWdlTGVuZ3RoKCksQj1BLmluZGV4KzErZztzd2l0Y2goQS5yZWFkQnl0ZSgpKXtjYXNlIDE6cmV0dXJue2Rpc2NyaW1pbmF0b3I6MSx2YWx1ZTpJLkNvbm5lY3Rpb25SZXF1ZXN0LnJlYWRGcm9tKEEpfTtjYXNlIDI6cmV0dXJue2Rpc2NyaW1pbmF0b3I6Mix2YWx1ZTpJLkFjY2VwdGVkQ29ubmVjdGlvblJlcXVlc3QucmVhZEZyb20oQSl9O2Nhc2UgMzpyZXR1cm57ZGlzY3JpbWluYXRvcjozLHZhbHVlOkkuUmVqZWN0ZWRDb25uZWN0aW9uUmVxdWVzdC5yZWFkRnJvbShBKX07Y2FzZSA0OnJldHVybntkaXNjcmltaW5hdG9yOjQsdmFsdWU6SS5QZWVyU2lnbmFsaW5nSW5mb3JtYXRpb24ucmVhZEZyb20oQSl9O2RlZmF1bHQ6dGhyb3cgQS5pbmRleD1CLG5ldyBlLkJlYm9wUnVudGltZUVycm9yKFwiVW5yZWNvZ25pemVkIGRpc2NyaW1pbmF0b3Igd2hpbGUgZGVjb2RpbmcgR2F0ZXdheUZvcndhcmRhYmxlQm9keVwiKX19fSxJLlRlbGVtZXRyeVNldEtleT1cIm5ldHdvcms6dGVsZW1ldHJ5OmJhdGNoZXNcIixJLlRlbGVtZXRyeUJhdGNoZXNLZXlUZW1wbGF0ZT1cIm5ldHdvcms6dGVsZW1ldHJ5OmJhdGNoZXM6ezB9XCIsSS5SYWlud2F5VGVsZW1ldHJ5UmVxdWVzdD17ZW5jb2RlKEEpe2NvbnN0IEk9ZS5CZWJvcFZpZXcuZ2V0SW5zdGFuY2UoKTtyZXR1cm4gSS5zdGFydFdyaXRpbmcoKSx0aGlzLmVuY29kZUludG8oQSxJKSxJLnRvQXJyYXkoKX0sZW5jb2RlSW50byhBLGcpe2NvbnN0IGU9Zy5sZW5ndGgsQj1nLnJlc2VydmVNZXNzYWdlTGVuZ3RoKCksaT1nLmxlbmd0aDtpZihudWxsIT1BLnJlY29yZHMpe2cud3JpdGVCeXRlKDEpO3tjb25zdCBlPUEucmVjb3Jkcy5sZW5ndGg7Zy53cml0ZVVpbnQzMihlKTtmb3IobGV0IEI9MDtCPGU7QisrKUkuUmFpbndheVRlbGVtZXRyeVJlY29yZC5lbmNvZGVJbnRvKEEucmVjb3Jkc1tCXSxnKX19bnVsbCE9QS5jb21tb25BdHRyaWJ1dGVzJiYoZy53cml0ZUJ5dGUoMiksSS5SYWlud2F5VGVsZW1ldHJ5UmVjb3JkLmVuY29kZUludG8oQS5jb21tb25BdHRyaWJ1dGVzLGcpKSxnLndyaXRlQnl0ZSgwKTtjb25zdCB0PWcubGVuZ3RoO3JldHVybiBnLmZpbGxNZXNzYWdlTGVuZ3RoKEIsdC1pKSxnLmxlbmd0aC1lfSxkZWNvZGUoQSl7Y29uc3QgST1lLkJlYm9wVmlldy5nZXRJbnN0YW5jZSgpO3JldHVybiBJLnN0YXJ0UmVhZGluZyhBKSx0aGlzLnJlYWRGcm9tKEkpfSxyZWFkRnJvbShBKXtsZXQgZz17fTtjb25zdCBlPUEucmVhZE1lc3NhZ2VMZW5ndGgoKSxCPUEuaW5kZXgrZTtmb3IoOzspc3dpdGNoKEEucmVhZEJ5dGUoKSl7Y2FzZSAwOnJldHVybiBnO2Nhc2UgMTp7bGV0IGU9QS5yZWFkVWludDMyKCk7Zy5yZWNvcmRzPW5ldyBBcnJheShlKTtmb3IobGV0IEI9MDtCPGU7QisrKXtsZXQgZTtlPUkuUmFpbndheVRlbGVtZXRyeVJlY29yZC5yZWFkRnJvbShBKSxnLnJlY29yZHNbQl09ZX19YnJlYWs7Y2FzZSAyOmcuY29tbW9uQXR0cmlidXRlcz1JLlJhaW53YXlUZWxlbWV0cnlSZWNvcmQucmVhZEZyb20oQSk7YnJlYWs7ZGVmYXVsdDpyZXR1cm4gQS5pbmRleD1CLGd9fX0sSS5SYWlud2F5VGVsZW1ldHJ5UmVjb3JkPXtlbmNvZGUoQSl7Y29uc3QgST1lLkJlYm9wVmlldy5nZXRJbnN0YW5jZSgpO3JldHVybiBJLnN0YXJ0V3JpdGluZygpLHRoaXMuZW5jb2RlSW50byhBLEkpLEkudG9BcnJheSgpfSxlbmNvZGVJbnRvKEEsZyl7Y29uc3QgZT1nLmxlbmd0aCxCPWcucmVzZXJ2ZU1lc3NhZ2VMZW5ndGgoKSxpPWcubGVuZ3RoO2lmKG51bGwhPUEubmFtZSYmKGcud3JpdGVCeXRlKDEpLGcud3JpdGVTdHJpbmcoQS5uYW1lKSksbnVsbCE9QS52YWx1ZSYmKGcud3JpdGVCeXRlKDIpLGcud3JpdGVTdHJpbmcoQS52YWx1ZSkpLG51bGwhPUEudGltZSYmKGcud3JpdGVCeXRlKDMpLGcud3JpdGVEYXRlKEEudGltZSkpLG51bGwhPUEudHlwZSYmKGcud3JpdGVCeXRlKDQpLGcud3JpdGVVaW50MzIoQS50eXBlKSksbnVsbCE9QS5kaW1lbnNpb25zKXtnLndyaXRlQnl0ZSg1KTt7Y29uc3QgZT1BLmRpbWVuc2lvbnMubGVuZ3RoO2cud3JpdGVVaW50MzIoZSk7Zm9yKGxldCBCPTA7QjxlO0IrKylJLlJhaW53YXlUZWxlbWV0cnlEaW1lbnNpb24uZW5jb2RlSW50byhBLmRpbWVuc2lvbnNbQl0sZyl9fWcud3JpdGVCeXRlKDApO2NvbnN0IHQ9Zy5sZW5ndGg7cmV0dXJuIGcuZmlsbE1lc3NhZ2VMZW5ndGgoQix0LWkpLGcubGVuZ3RoLWV9LGRlY29kZShBKXtjb25zdCBJPWUuQmVib3BWaWV3LmdldEluc3RhbmNlKCk7cmV0dXJuIEkuc3RhcnRSZWFkaW5nKEEpLHRoaXMucmVhZEZyb20oSSl9LHJlYWRGcm9tKEEpe2xldCBnPXt9O2NvbnN0IGU9QS5yZWFkTWVzc2FnZUxlbmd0aCgpLEI9QS5pbmRleCtlO2Zvcig7Oylzd2l0Y2goQS5yZWFkQnl0ZSgpKXtjYXNlIDA6cmV0dXJuIGc7Y2FzZSAxOmcubmFtZT1BLnJlYWRTdHJpbmcoKTticmVhaztjYXNlIDI6Zy52YWx1ZT1BLnJlYWRTdHJpbmcoKTticmVhaztjYXNlIDM6Zy50aW1lPUEucmVhZERhdGUoKTticmVhaztjYXNlIDQ6Zy50eXBlPUEucmVhZFVpbnQzMigpO2JyZWFrO2Nhc2UgNTp7bGV0IGU9QS5yZWFkVWludDMyKCk7Zy5kaW1lbnNpb25zPW5ldyBBcnJheShlKTtmb3IobGV0IEI9MDtCPGU7QisrKXtsZXQgZTtlPUkuUmFpbndheVRlbGVtZXRyeURpbWVuc2lvbi5yZWFkRnJvbShBKSxnLmRpbWVuc2lvbnNbQl09ZX19YnJlYWs7ZGVmYXVsdDpyZXR1cm4gQS5pbmRleD1CLGd9fX0sSS5SYWlud2F5VGVsZW1ldHJ5RGltZW5zaW9uPXtlbmNvZGUoQSl7Y29uc3QgST1lLkJlYm9wVmlldy5nZXRJbnN0YW5jZSgpO3JldHVybiBJLnN0YXJ0V3JpdGluZygpLHRoaXMuZW5jb2RlSW50byhBLEkpLEkudG9BcnJheSgpfSxlbmNvZGVJbnRvKEEsSSl7Y29uc3QgZz1JLmxlbmd0aDtyZXR1cm4gSS53cml0ZVN0cmluZyhBLm5hbWUpLEkud3JpdGVTdHJpbmcoQS52YWx1ZSksSS5sZW5ndGgtZ30sZGVjb2RlKEEpe2NvbnN0IEk9ZS5CZWJvcFZpZXcuZ2V0SW5zdGFuY2UoKTtyZXR1cm4gSS5zdGFydFJlYWRpbmcoQSksdGhpcy5yZWFkRnJvbShJKX0scmVhZEZyb20oQSl7bGV0IEksZztyZXR1cm4gST1BLnJlYWRTdHJpbmcoKSxnPUEucmVhZFN0cmluZygpLHtuYW1lOkksdmFsdWU6Z319fSwocD1JLlRlbGVtZXRyeVZhbHVlVHlwZXx8KEkuVGVsZW1ldHJ5VmFsdWVUeXBlPXt9KSlbcC5Eb3VibGU9MF09XCJEb3VibGVcIixwW3AuQmlnSW50PTFdPVwiQmlnSW50XCIscFtwLlZhckNoYXI9Ml09XCJWYXJDaGFyXCIscFtwLkJvb2w9M109XCJCb29sXCIsSS5HdWlkPXtlbmNvZGUoQSl7Y29uc3QgST1lLkJlYm9wVmlldy5nZXRJbnN0YW5jZSgpO3JldHVybiBJLnN0YXJ0V3JpdGluZygpLHRoaXMuZW5jb2RlSW50byhBLEkpLEkudG9BcnJheSgpfSxlbmNvZGVJbnRvKEEsSSl7Y29uc3QgZz1JLmxlbmd0aDtyZXR1cm4gSS53cml0ZUd1aWQoQS52YWx1ZSksSS5sZW5ndGgtZ30sZGVjb2RlKEEpe2NvbnN0IEk9ZS5CZWJvcFZpZXcuZ2V0SW5zdGFuY2UoKTtyZXR1cm4gSS5zdGFydFJlYWRpbmcoQSksdGhpcy5yZWFkRnJvbShJKX0scmVhZEZyb20oQSl7bGV0IEk7cmV0dXJuIEk9QS5yZWFkR3VpZCgpLHt2YWx1ZTpJfX19LEkuUmFpbndheUhlYWRlcj17ZW5jb2RlKEEpe2NvbnN0IEk9ZS5CZWJvcFZpZXcuZ2V0SW5zdGFuY2UoKTtyZXR1cm4gSS5zdGFydFdyaXRpbmcoKSx0aGlzLmVuY29kZUludG8oQSxJKSxJLnRvQXJyYXkoKX0sZW5jb2RlSW50byhBLEkpe2NvbnN0IGc9SS5sZW5ndGg7cmV0dXJuIEkud3JpdGVVaW50MzIoQS5tYWdpY051bWJlciksSS53cml0ZVVpbnQzMihBLnN5bmNLZXkpLEkud3JpdGVJbnQ2NChBLnNvdXJjZVBlZXJJZCksSS53cml0ZUludDY0KEEudGFyZ2V0UGVlcklkKSxJLmxlbmd0aC1nfSxkZWNvZGUoQSl7Y29uc3QgST1lLkJlYm9wVmlldy5nZXRJbnN0YW5jZSgpO3JldHVybiBJLnN0YXJ0UmVhZGluZyhBKSx0aGlzLnJlYWRGcm9tKEkpfSxyZWFkRnJvbShBKXtsZXQgSSxnLGUsQjtyZXR1cm4gST1BLnJlYWRVaW50MzIoKSxnPUEucmVhZFVpbnQzMigpLGU9QS5yZWFkSW50NjQoKSxCPUEucmVhZEludDY0KCkse21hZ2ljTnVtYmVyOkksc3luY0tleTpnLHNvdXJjZVBlZXJJZDplLHRhcmdldFBlZXJJZDpCfX19LEkuQ2h1bms9e2VuY29kZShBKXtjb25zdCBJPWUuQmVib3BWaWV3LmdldEluc3RhbmNlKCk7cmV0dXJuIEkuc3RhcnRXcml0aW5nKCksdGhpcy5lbmNvZGVJbnRvKEEsSSksSS50b0FycmF5KCl9LGVuY29kZUludG8oQSxJKXtjb25zdCBnPUkubGVuZ3RoO3JldHVybiBJLndyaXRlVWludDE2KEEuZ3JvdXBJZCksSS53cml0ZUJ5dGUoQS5pbmRleCksSS53cml0ZUJ5dGUoQS5jaHVua3NJbkdyb3VwKSxJLndyaXRlQnl0ZXMoQS5kYXRhKSxJLmxlbmd0aC1nfSxkZWNvZGUoQSl7Y29uc3QgST1lLkJlYm9wVmlldy5nZXRJbnN0YW5jZSgpO3JldHVybiBJLnN0YXJ0UmVhZGluZyhBKSx0aGlzLnJlYWRGcm9tKEkpfSxyZWFkRnJvbShBKXtsZXQgSSxnLGUsQjtyZXR1cm4gST1BLnJlYWRVaW50MTYoKSxnPUEucmVhZEJ5dGUoKSxlPUEucmVhZEJ5dGUoKSxCPUEucmVhZEJ5dGVzKCkse2dyb3VwSWQ6SSxpbmRleDpnLGNodW5rc0luR3JvdXA6ZSxkYXRhOkJ9fX0sSS5JbnB1dERhdGFncmFtPXtlbmNvZGUoQSl7Y29uc3QgST1lLkJlYm9wVmlldy5nZXRJbnN0YW5jZSgpO3JldHVybiBJLnN0YXJ0V3JpdGluZygpLHRoaXMuZW5jb2RlSW50byhBLEkpLEkudG9BcnJheSgpfSxlbmNvZGVJbnRvKEEsZyl7Y29uc3QgZT1nLmxlbmd0aDtyZXR1cm4gSS5SYWlud2F5SGVhZGVyLmVuY29kZUludG8oQS5oZWFkZXIsZyksSS5JbnB1dEJvZHkuZW5jb2RlSW50byhBLmJvZHksZyksZy5sZW5ndGgtZX0sZGVjb2RlKEEpe2NvbnN0IEk9ZS5CZWJvcFZpZXcuZ2V0SW5zdGFuY2UoKTtyZXR1cm4gSS5zdGFydFJlYWRpbmcoQSksdGhpcy5yZWFkRnJvbShJKX0scmVhZEZyb20oQSl7bGV0IGcsZTtyZXR1cm4gZz1JLlJhaW53YXlIZWFkZXIucmVhZEZyb20oQSksZT1JLklucHV0Qm9keS5yZWFkRnJvbShBKSx7aGVhZGVyOmcsYm9keTplfX19LEkuTG9naWNEYXRhZ3JhbT17ZW5jb2RlKEEpe2NvbnN0IEk9ZS5CZWJvcFZpZXcuZ2V0SW5zdGFuY2UoKTtyZXR1cm4gSS5zdGFydFdyaXRpbmcoKSx0aGlzLmVuY29kZUludG8oQSxJKSxJLnRvQXJyYXkoKX0sZW5jb2RlSW50byhBLGcpe2NvbnN0IGU9Zy5sZW5ndGg7cmV0dXJuIEkuUmFpbndheUhlYWRlci5lbmNvZGVJbnRvKEEuaGVhZGVyLGcpLEkuTG9naWNCb2R5LmVuY29kZUludG8oQS5ib2R5LGcpLGcubGVuZ3RoLWV9LGRlY29kZShBKXtjb25zdCBJPWUuQmVib3BWaWV3LmdldEluc3RhbmNlKCk7cmV0dXJuIEkuc3RhcnRSZWFkaW5nKEEpLHRoaXMucmVhZEZyb20oSSl9LHJlYWRGcm9tKEEpe2xldCBnLGU7cmV0dXJuIGc9SS5SYWlud2F5SGVhZGVyLnJlYWRGcm9tKEEpLGU9SS5Mb2dpY0JvZHkucmVhZEZyb20oQSkse2hlYWRlcjpnLGJvZHk6ZX19fSxJLk1lZGlhRGF0YWdyYW09e2VuY29kZShBKXtjb25zdCBJPWUuQmVib3BWaWV3LmdldEluc3RhbmNlKCk7cmV0dXJuIEkuc3RhcnRXcml0aW5nKCksdGhpcy5lbmNvZGVJbnRvKEEsSSksSS50b0FycmF5KCl9LGVuY29kZUludG8oQSxnKXtjb25zdCBlPWcubGVuZ3RoO3JldHVybiBJLlJhaW53YXlIZWFkZXIuZW5jb2RlSW50byhBLmhlYWRlcixnKSxJLk1lZGlhQm9keS5lbmNvZGVJbnRvKEEuYm9keSxnKSxnLmxlbmd0aC1lfSxkZWNvZGUoQSl7Y29uc3QgST1lLkJlYm9wVmlldy5nZXRJbnN0YW5jZSgpO3JldHVybiBJLnN0YXJ0UmVhZGluZyhBKSx0aGlzLnJlYWRGcm9tKEkpfSxyZWFkRnJvbShBKXtsZXQgZyxlO3JldHVybiBnPUkuUmFpbndheUhlYWRlci5yZWFkRnJvbShBKSxlPUkuTWVkaWFCb2R5LnJlYWRGcm9tKEEpLHtoZWFkZXI6Zyxib2R5OmV9fX0sSS5BcmJpdHJhcnlEYXRhZ3JhbT17ZW5jb2RlKEEpe2NvbnN0IEk9ZS5CZWJvcFZpZXcuZ2V0SW5zdGFuY2UoKTtyZXR1cm4gSS5zdGFydFdyaXRpbmcoKSx0aGlzLmVuY29kZUludG8oQSxJKSxJLnRvQXJyYXkoKX0sZW5jb2RlSW50byhBLGcpe2NvbnN0IGU9Zy5sZW5ndGg7cmV0dXJuIEkuUmFpbndheUhlYWRlci5lbmNvZGVJbnRvKEEuaGVhZGVyLGcpLEkuQ2h1bmsuZW5jb2RlSW50byhBLmJvZHksZyksZy5sZW5ndGgtZX0sZGVjb2RlKEEpe2NvbnN0IEk9ZS5CZWJvcFZpZXcuZ2V0SW5zdGFuY2UoKTtyZXR1cm4gSS5zdGFydFJlYWRpbmcoQSksdGhpcy5yZWFkRnJvbShJKX0scmVhZEZyb20oQSl7bGV0IGcsZTtyZXR1cm4gZz1JLlJhaW53YXlIZWFkZXIucmVhZEZyb20oQSksZT1JLkNodW5rLnJlYWRGcm9tKEEpLHtoZWFkZXI6Zyxib2R5OmV9fX0sKGs9SS5YSW5wdXRCdXR0b25zfHwoSS5YSW5wdXRCdXR0b25zPXt9KSlbay5Ob25lPTBdPVwiTm9uZVwiLGtbay5EcGFkVXA9MV09XCJEcGFkVXBcIixrW2suRHBhZERvd249Ml09XCJEcGFkRG93blwiLGtbay5EcGFkTGVmdD00XT1cIkRwYWRMZWZ0XCIsa1trLkRwYWRSaWdodD04XT1cIkRwYWRSaWdodFwiLGtbay5TdGFydD0xNl09XCJTdGFydFwiLGtbay5CYWNrPTMyXT1cIkJhY2tcIixrW2suTGVmdFN0aWNrPTY0XT1cIkxlZnRTdGlja1wiLGtbay5SaWdodFN0aWNrPTEyOF09XCJSaWdodFN0aWNrXCIsa1trLkxlZnRCdW1wZXI9MjU2XT1cIkxlZnRCdW1wZXJcIixrW2suUmlnaHRCdW1wZXI9NTEyXT1cIlJpZ2h0QnVtcGVyXCIsa1trLkd1aWRlPTEwMjRdPVwiR3VpZGVcIixrW2suQT00MDk2XT1cIkFcIixrW2suQj04MTkyXT1cIkJcIixrW2suWD0xNjM4NF09XCJYXCIsa1trLlk9MzI3NjhdPVwiWVwiLChHPUkuQnV0dG9uQWN0aW9ufHwoSS5CdXR0b25BY3Rpb249e30pKVtHLkJ1dHRvbkRvd249MF09XCJCdXR0b25Eb3duXCIsR1tHLkJ1dHRvblVwPTFdPVwiQnV0dG9uVXBcIiwoUj1JLk1vdXNlQnV0dG9ufHwoSS5Nb3VzZUJ1dHRvbj17fSkpW1IuTGVmdD0wXT1cIkxlZnRcIixSW1IuUmlnaHQ9MV09XCJSaWdodFwiLFJbUi5NaWRkbGU9Ml09XCJNaWRkbGVcIixSW1IuWDE9M109XCJYMVwiLFJbUi5YMj00XT1cIlgyXCIsKEY9SS5TY3JvbGxBeGlzfHwoSS5TY3JvbGxBeGlzPXt9KSlbRi5Ib3Jpem9udGFsPTBdPVwiSG9yaXpvbnRhbFwiLEZbRi5WZXJ0aWNhbD0xXT1cIlZlcnRpY2FsXCIsKFM9SS5LZXlib2FyZEFjdGlvbnx8KEkuS2V5Ym9hcmRBY3Rpb249e30pKVtTLktleURvd249MF09XCJLZXlEb3duXCIsU1tTLktleVVwPTFdPVwiS2V5VXBcIiwobD1JLlZpcnR1YWxLZXl8fChJLlZpcnR1YWxLZXk9e30pKVtsLk5vbmU9MF09XCJOb25lXCIsbFtsLkNhbmNlbD0xXT1cIkNhbmNlbFwiLGxbbC5CYWNrPTJdPVwiQmFja1wiLGxbbC5UYWI9M109XCJUYWJcIixsW2wuTGluZUZlZWQ9NF09XCJMaW5lRmVlZFwiLGxbbC5DbGVhcj01XT1cIkNsZWFyXCIsbFtsLkVudGVyPTZdPVwiRW50ZXJcIixsW2wuUGF1c2U9N109XCJQYXVzZVwiLGxbbC5DYXBzTG9jaz04XT1cIkNhcHNMb2NrXCIsbFtsLkhhbmd1bE1vZGU9OV09XCJIYW5ndWxNb2RlXCIsbFtsLkp1bmphTW9kZT0xMF09XCJKdW5qYU1vZGVcIixsW2wuRmluYWxNb2RlPTExXT1cIkZpbmFsTW9kZVwiLGxbbC5IYW5qYU1vZGU9MTJdPVwiSGFuamFNb2RlXCIsbFtsLkVzY2FwZT0xM109XCJFc2NhcGVcIixsW2wuSW1lQ29udmVydD0xNF09XCJJbWVDb252ZXJ0XCIsbFtsLkltZU5vbkNvbnZlcnQ9MTVdPVwiSW1lTm9uQ29udmVydFwiLGxbbC5JbWVBY2NlcHQ9MTZdPVwiSW1lQWNjZXB0XCIsbFtsLkltZU1vZGVDaGFuZ2U9MTddPVwiSW1lTW9kZUNoYW5nZVwiLGxbbC5TcGFjZT0xOF09XCJTcGFjZVwiLGxbbC5QYWdlVXA9MTldPVwiUGFnZVVwXCIsbFtsLlBhZ2VEb3duPTIwXT1cIlBhZ2VEb3duXCIsbFtsLkVuZD0yMV09XCJFbmRcIixsW2wuSG9tZT0yMl09XCJIb21lXCIsbFtsLkxlZnQ9MjNdPVwiTGVmdFwiLGxbbC5VcD0yNF09XCJVcFwiLGxbbC5SaWdodD0yNV09XCJSaWdodFwiLGxbbC5Eb3duPTI2XT1cIkRvd25cIixsW2wuU2VsZWN0PTI3XT1cIlNlbGVjdFwiLGxbbC5QcmludD0yOF09XCJQcmludFwiLGxbbC5FeGVjdXRlPTI5XT1cIkV4ZWN1dGVcIixsW2wuUHJpbnRTY3JlZW49MzBdPVwiUHJpbnRTY3JlZW5cIixsW2wuSW5zZXJ0PTMxXT1cIkluc2VydFwiLGxbbC5EZWxldGU9MzJdPVwiRGVsZXRlXCIsbFtsLkhlbHA9MzNdPVwiSGVscFwiLGxbbC5EMD0zNF09XCJEMFwiLGxbbC5EMT0zNV09XCJEMVwiLGxbbC5EMj0zNl09XCJEMlwiLGxbbC5EMz0zN109XCJEM1wiLGxbbC5END0zOF09XCJENFwiLGxbbC5ENT0zOV09XCJENVwiLGxbbC5ENj00MF09XCJENlwiLGxbbC5ENz00MV09XCJEN1wiLGxbbC5EOD00Ml09XCJEOFwiLGxbbC5EOT00M109XCJEOVwiLGxbbC5BPTQ0XT1cIkFcIixsW2wuQj00NV09XCJCXCIsbFtsLkM9NDZdPVwiQ1wiLGxbbC5EPTQ3XT1cIkRcIixsW2wuRT00OF09XCJFXCIsbFtsLkY9NDldPVwiRlwiLGxbbC5HPTUwXT1cIkdcIixsW2wuSD01MV09XCJIXCIsbFtsLkk9NTJdPVwiSVwiLGxbbC5KPTUzXT1cIkpcIixsW2wuSz01NF09XCJLXCIsbFtsLkw9NTVdPVwiTFwiLGxbbC5NPTU2XT1cIk1cIixsW2wuTj01N109XCJOXCIsbFtsLk89NThdPVwiT1wiLGxbbC5QPTU5XT1cIlBcIixsW2wuUT02MF09XCJRXCIsbFtsLlI9NjFdPVwiUlwiLGxbbC5TPTYyXT1cIlNcIixsW2wuVD02M109XCJUXCIsbFtsLlU9NjRdPVwiVVwiLGxbbC5WPTY1XT1cIlZcIixsW2wuVz02Nl09XCJXXCIsbFtsLlg9NjddPVwiWFwiLGxbbC5ZPTY4XT1cIllcIixsW2wuWj02OV09XCJaXCIsbFtsLkxXaW49NzBdPVwiTFdpblwiLGxbbC5SV2luPTcxXT1cIlJXaW5cIixsW2wuQXBwcz03Ml09XCJBcHBzXCIsbFtsLlNsZWVwPTczXT1cIlNsZWVwXCIsbFtsLk51bVBhZDA9NzRdPVwiTnVtUGFkMFwiLGxbbC5OdW1QYWQxPTc1XT1cIk51bVBhZDFcIixsW2wuTnVtUGFkMj03Nl09XCJOdW1QYWQyXCIsbFtsLk51bVBhZDM9NzddPVwiTnVtUGFkM1wiLGxbbC5OdW1QYWQ0PTc4XT1cIk51bVBhZDRcIixsW2wuTnVtUGFkNT03OV09XCJOdW1QYWQ1XCIsbFtsLk51bVBhZDY9ODBdPVwiTnVtUGFkNlwiLGxbbC5OdW1QYWQ3PTgxXT1cIk51bVBhZDdcIixsW2wuTnVtUGFkOD04Ml09XCJOdW1QYWQ4XCIsbFtsLk51bVBhZDk9ODNdPVwiTnVtUGFkOVwiLGxbbC5NdWx0aXBseT04NF09XCJNdWx0aXBseVwiLGxbbC5BZGQ9ODVdPVwiQWRkXCIsbFtsLlNlcGFyYXRvcj04Nl09XCJTZXBhcmF0b3JcIixsW2wuU3VidHJhY3Q9ODddPVwiU3VidHJhY3RcIixsW2wuRGVjaW1hbD04OF09XCJEZWNpbWFsXCIsbFtsLkRpdmlkZT04OV09XCJEaXZpZGVcIixsW2wuRjE9OTBdPVwiRjFcIixsW2wuRjI9OTFdPVwiRjJcIixsW2wuRjM9OTJdPVwiRjNcIixsW2wuRjQ9OTNdPVwiRjRcIixsW2wuRjU9OTRdPVwiRjVcIixsW2wuRjY9OTVdPVwiRjZcIixsW2wuRjc9OTZdPVwiRjdcIixsW2wuRjg9OTddPVwiRjhcIixsW2wuRjk9OThdPVwiRjlcIixsW2wuRjEwPTk5XT1cIkYxMFwiLGxbbC5GMTE9MTAwXT1cIkYxMVwiLGxbbC5GMTI9MTAxXT1cIkYxMlwiLGxbbC5GMTM9MTAyXT1cIkYxM1wiLGxbbC5GMTQ9MTAzXT1cIkYxNFwiLGxbbC5GMTU9MTA0XT1cIkYxNVwiLGxbbC5GMTY9MTA1XT1cIkYxNlwiLGxbbC5GMTc9MTA2XT1cIkYxN1wiLGxbbC5GMTg9MTA3XT1cIkYxOFwiLGxbbC5GMTk9MTA4XT1cIkYxOVwiLGxbbC5GMjA9MTA5XT1cIkYyMFwiLGxbbC5GMjE9MTEwXT1cIkYyMVwiLGxbbC5GMjI9MTExXT1cIkYyMlwiLGxbbC5GMjM9MTEyXT1cIkYyM1wiLGxbbC5GMjQ9MTEzXT1cIkYyNFwiLGxbbC5OdW1Mb2NrPTExNF09XCJOdW1Mb2NrXCIsbFtsLlNjcm9sbD0xMTVdPVwiU2Nyb2xsXCIsbFtsLkxlZnRTaGlmdD0xMTZdPVwiTGVmdFNoaWZ0XCIsbFtsLlJpZ2h0U2hpZnQ9MTE3XT1cIlJpZ2h0U2hpZnRcIixsW2wuTGVmdEN0cmw9MTE4XT1cIkxlZnRDdHJsXCIsbFtsLlJpZ2h0Q3RybD0xMTldPVwiUmlnaHRDdHJsXCIsbFtsLkxlZnRBbHQ9MTIwXT1cIkxlZnRBbHRcIixsW2wuUmlnaHRBbHQ9MTIxXT1cIlJpZ2h0QWx0XCIsbFtsLkJyb3dzZXJCYWNrPTEyMl09XCJCcm93c2VyQmFja1wiLGxbbC5Ccm93c2VyRm9yd2FyZD0xMjNdPVwiQnJvd3NlckZvcndhcmRcIixsW2wuQnJvd3NlclJlZnJlc2g9MTI0XT1cIkJyb3dzZXJSZWZyZXNoXCIsbFtsLkJyb3dzZXJTdG9wPTEyNV09XCJCcm93c2VyU3RvcFwiLGxbbC5Ccm93c2VyU2VhcmNoPTEyNl09XCJCcm93c2VyU2VhcmNoXCIsbFtsLkJyb3dzZXJGYXZvcml0ZXM9MTI3XT1cIkJyb3dzZXJGYXZvcml0ZXNcIixsW2wuQnJvd3NlckhvbWU9MTI4XT1cIkJyb3dzZXJIb21lXCIsbFtsLlZvbHVtZU11dGU9MTI5XT1cIlZvbHVtZU11dGVcIixsW2wuVm9sdW1lRG93bj0xMzBdPVwiVm9sdW1lRG93blwiLGxbbC5Wb2x1bWVVcD0xMzFdPVwiVm9sdW1lVXBcIixsW2wuTWVkaWFOZXh0VHJhY2s9MTMyXT1cIk1lZGlhTmV4dFRyYWNrXCIsbFtsLk1lZGlhUHJldmlvdXNUcmFjaz0xMzNdPVwiTWVkaWFQcmV2aW91c1RyYWNrXCIsbFtsLk1lZGlhU3RvcD0xMzRdPVwiTWVkaWFTdG9wXCIsbFtsLk1lZGlhUGxheVBhdXNlPTEzNV09XCJNZWRpYVBsYXlQYXVzZVwiLGxbbC5MYXVuY2hNYWlsPTEzNl09XCJMYXVuY2hNYWlsXCIsbFtsLlNlbGVjdE1lZGlhPTEzN109XCJTZWxlY3RNZWRpYVwiLGxbbC5MYXVuY2hBcHBsaWNhdGlvbjE9MTM4XT1cIkxhdW5jaEFwcGxpY2F0aW9uMVwiLGxbbC5MYXVuY2hBcHBsaWNhdGlvbjI9MTM5XT1cIkxhdW5jaEFwcGxpY2F0aW9uMlwiLGxbbC5PZW0xPTE0MF09XCJPZW0xXCIsbFtsLk9lbVBsdXM9MTQxXT1cIk9lbVBsdXNcIixsW2wuT2VtQ29tbWE9MTQyXT1cIk9lbUNvbW1hXCIsbFtsLk9lbU1pbnVzPTE0M109XCJPZW1NaW51c1wiLGxbbC5PZW1QZXJpb2Q9MTQ0XT1cIk9lbVBlcmlvZFwiLGxbbC5PZW0yPTE0NV09XCJPZW0yXCIsbFtsLk9lbTM9MTQ2XT1cIk9lbTNcIixsW2wuQWJudEMxPTE0N109XCJBYm50QzFcIixsW2wuQWJudEMyPTE0OF09XCJBYm50QzJcIixsW2wuT2VtND0xNDldPVwiT2VtNFwiLGxbbC5PZW01PTE1MF09XCJPZW01XCIsbFtsLk9lbTY9MTUxXT1cIk9lbTZcIixsW2wuT2VtNz0xNTJdPVwiT2VtN1wiLGxbbC5PZW04PTE1M109XCJPZW04XCIsbFtsLk9lbTEwMj0xNTRdPVwiT2VtMTAyXCIsbFtsLkltZVByb2Nlc3NlZD0xNTVdPVwiSW1lUHJvY2Vzc2VkXCIsbFtsLlN5c3RlbT0xNTZdPVwiU3lzdGVtXCIsbFtsLk9lbUF0dG49MTU3XT1cIk9lbUF0dG5cIixsW2wuT2VtRmluaXNoPTE1OF09XCJPZW1GaW5pc2hcIixsW2wuT2VtQ29weT0xNTldPVwiT2VtQ29weVwiLGxbbC5PZW1BdXRvPTE2MF09XCJPZW1BdXRvXCIsbFtsLk9lbUVubHc9MTYxXT1cIk9lbUVubHdcIixsW2wuT2VtQmFja1RhYj0xNjJdPVwiT2VtQmFja1RhYlwiLGxbbC5BdHRuPTE2M109XCJBdHRuXCIsbFtsLkNyU2VsPTE2NF09XCJDclNlbFwiLGxbbC5FeFNlbD0xNjVdPVwiRXhTZWxcIixsW2wuRXJhc2VFb2Y9MTY2XT1cIkVyYXNlRW9mXCIsbFtsLlBsYXk9MTY3XT1cIlBsYXlcIixsW2wuWm9vbT0xNjhdPVwiWm9vbVwiLGxbbC5Ob05hbWU9MTY5XT1cIk5vTmFtZVwiLGxbbC5QYTE9MTcwXT1cIlBhMVwiLGxbbC5PZW1DbGVhcj0xNzFdPVwiT2VtQ2xlYXJcIixsW2wuRGVhZENoYXJQcm9jZXNzZWQ9MTcyXT1cIkRlYWRDaGFyUHJvY2Vzc2VkXCIsKHk9SS5XaW5kb3dzUG9pbnRlckZsYWdzfHwoSS5XaW5kb3dzUG9pbnRlckZsYWdzPXt9KSlbeS5OZXc9MV09XCJOZXdcIix5W3kuSW5SYW5nZT0yXT1cIkluUmFuZ2VcIix5W3kuSW5Db250YWN0PTRdPVwiSW5Db250YWN0XCIseVt5LkZpcnN0QnV0dG9uPTE2XT1cIkZpcnN0QnV0dG9uXCIseVt5LlNlY29uZEJ1dHRvbj0zMl09XCJTZWNvbmRCdXR0b25cIix5W3kuVGhpcmRCdXR0b249NjRdPVwiVGhpcmRCdXR0b25cIix5W3kuRm91cnRoQnV0dG9uPTEyOF09XCJGb3VydGhCdXR0b25cIix5W3kuRmlmdGhCdXR0b249MjU2XT1cIkZpZnRoQnV0dG9uXCIseVt5LlByaW1hcnk9ODE5Ml09XCJQcmltYXJ5XCIseVt5LkNvbmZpZGVuY2U9MTYzODRdPVwiQ29uZmlkZW5jZVwiLHlbeS5DYW5jZWxlZD0zMjc2OF09XCJDYW5jZWxlZFwiLHlbeS5Eb3duPTY1NTM2XT1cIkRvd25cIix5W3kuVXBkYXRlPTEzMTA3Ml09XCJVcGRhdGVcIix5W3kuVXA9MjYyMTQ0XT1cIlVwXCIseVt5LldoZWVsPTUyNDI4OF09XCJXaGVlbFwiLHlbeS5IV2hlZWw9MTA0ODU3Nl09XCJIV2hlZWxcIix5W3kuQ2FwdHVyZUNoYW5nZWQ9MjA5NzE1Ml09XCJDYXB0dXJlQ2hhbmdlZFwiLHlbeS5IYXNUcmFuc2Zvcm09NDE5NDMwNF09XCJIYXNUcmFuc2Zvcm1cIixJLlRvdWNoUGVuUG9pbnRlckluZm89e2VuY29kZShBKXtjb25zdCBJPWUuQmVib3BWaWV3LmdldEluc3RhbmNlKCk7cmV0dXJuIEkuc3RhcnRXcml0aW5nKCksdGhpcy5lbmNvZGVJbnRvKEEsSSksSS50b0FycmF5KCl9LGVuY29kZUludG8oQSxJKXtjb25zdCBnPUkubGVuZ3RoO3JldHVybiBJLndyaXRlVWludDMyKEEucG9pbnRlcklkKSxJLndyaXRlVWludDMyKEEuZnJhbWVJZCksSS53cml0ZVVpbnQzMihBLnBvaW50ZXJGbGFncyksSS53cml0ZUludDMyKEEueCksSS53cml0ZUludDMyKEEueSksSS5sZW5ndGgtZ30sZGVjb2RlKEEpe2NvbnN0IEk9ZS5CZWJvcFZpZXcuZ2V0SW5zdGFuY2UoKTtyZXR1cm4gSS5zdGFydFJlYWRpbmcoQSksdGhpcy5yZWFkRnJvbShJKX0scmVhZEZyb20oQSl7bGV0IEksZyxlLEIsaTtyZXR1cm4gST1BLnJlYWRVaW50MzIoKSxnPUEucmVhZFVpbnQzMigpLGU9QS5yZWFkVWludDMyKCksQj1BLnJlYWRJbnQzMigpLGk9QS5yZWFkSW50MzIoKSx7cG9pbnRlcklkOkksZnJhbWVJZDpnLHBvaW50ZXJGbGFnczplLHg6Qix5Oml9fX0sKHU9SS5Ub3VjaE1hc2t8fChJLlRvdWNoTWFzaz17fSkpW3UuQ29udGFjdEFyZWE9MV09XCJDb250YWN0QXJlYVwiLHVbdS5PcmllbnRhdGlvbj0yXT1cIk9yaWVudGF0aW9uXCIsdVt1LlByZXNzdXJlPTRdPVwiUHJlc3N1cmVcIiwodz1JLlBlbk1hc2t8fChJLlBlbk1hc2s9e30pKVt3LlByZXNzdXJlPTFdPVwiUHJlc3N1cmVcIix3W3cuUm90YXRpb249Ml09XCJSb3RhdGlvblwiLHdbdy5UaWx0WD00XT1cIlRpbHRYXCIsd1t3LlRpbHRZPThdPVwiVGlsdFlcIiwoRD1JLlBlbkZsYWdzfHwoSS5QZW5GbGFncz17fSkpW0QuQmFycmVsPTFdPVwiQmFycmVsXCIsRFtELkludmVydGVkPTJdPVwiSW52ZXJ0ZWRcIixEW0QuRXJhc2VyPTRdPVwiRXJhc2VyXCIsSS5Ub3VjaEFic29sdXRlPXtlbmNvZGUoQSl7Y29uc3QgST1lLkJlYm9wVmlldy5nZXRJbnN0YW5jZSgpO3JldHVybiBJLnN0YXJ0V3JpdGluZygpLHRoaXMuZW5jb2RlSW50byhBLEkpLEkudG9BcnJheSgpfSxlbmNvZGVJbnRvKEEsZyl7Y29uc3QgZT1nLmxlbmd0aDtyZXR1cm4gSS5Ub3VjaFBlblBvaW50ZXJJbmZvLmVuY29kZUludG8oQS5wb2ludGVySW5mbyxnKSxnLndyaXRlVWludDMyKEEudG91Y2hNYXNrKSxnLndyaXRlSW50MzIoQS5jb250YWN0TGVmdCksZy53cml0ZUludDMyKEEuY29udGFjdFRvcCksZy53cml0ZUludDMyKEEuY29udGFjdFJpZ2h0KSxnLndyaXRlSW50MzIoQS5jb250YWN0Qm90dG9tKSxnLndyaXRlVWludDMyKEEub3JpZW50YXRpb24pLGcud3JpdGVVaW50MzIoQS5wcmVzc3VyZSksZy5sZW5ndGgtZX0sZGVjb2RlKEEpe2NvbnN0IEk9ZS5CZWJvcFZpZXcuZ2V0SW5zdGFuY2UoKTtyZXR1cm4gSS5zdGFydFJlYWRpbmcoQSksdGhpcy5yZWFkRnJvbShJKX0scmVhZEZyb20oQSl7bGV0IGcsZSxCLGksdCxRLEMsRTtyZXR1cm4gZz1JLlRvdWNoUGVuUG9pbnRlckluZm8ucmVhZEZyb20oQSksZT1BLnJlYWRVaW50MzIoKSxCPUEucmVhZEludDMyKCksaT1BLnJlYWRJbnQzMigpLHQ9QS5yZWFkSW50MzIoKSxRPUEucmVhZEludDMyKCksQz1BLnJlYWRVaW50MzIoKSxFPUEucmVhZFVpbnQzMigpLHtwb2ludGVySW5mbzpnLHRvdWNoTWFzazplLGNvbnRhY3RMZWZ0OkIsY29udGFjdFRvcDppLGNvbnRhY3RSaWdodDp0LGNvbnRhY3RCb3R0b206USxvcmllbnRhdGlvbjpDLHByZXNzdXJlOkV9fX0sSS5HYW1lcGFkUmVwb3J0PXtkaXNjcmltaW5hdG9yOjEsZW5jb2RlKEEpe2NvbnN0IEk9ZS5CZWJvcFZpZXcuZ2V0SW5zdGFuY2UoKTtyZXR1cm4gSS5zdGFydFdyaXRpbmcoKSx0aGlzLmVuY29kZUludG8oQSxJKSxJLnRvQXJyYXkoKX0sZW5jb2RlSW50byhBLEkpe2NvbnN0IGc9SS5sZW5ndGg7cmV0dXJuIEkud3JpdGVVaW50MzIoQS5idXR0b25zKSxJLndyaXRlQnl0ZShBLmxlZnRUcmlnZ2VyKSxJLndyaXRlQnl0ZShBLnJpZ2h0VHJpZ2dlciksSS53cml0ZUludDE2KEEubGVmdFRodW1iWCksSS53cml0ZUludDE2KEEubGVmdFRodW1iWSksSS53cml0ZUludDE2KEEucmlnaHRUaHVtYlgpLEkud3JpdGVJbnQxNihBLnJpZ2h0VGh1bWJZKSxJLndyaXRlQnl0ZShBLnNsb3QpLEkubGVuZ3RoLWd9LGRlY29kZShBKXtjb25zdCBJPWUuQmVib3BWaWV3LmdldEluc3RhbmNlKCk7cmV0dXJuIEkuc3RhcnRSZWFkaW5nKEEpLHRoaXMucmVhZEZyb20oSSl9LHJlYWRGcm9tKEEpe2xldCBJLGcsZSxCLGksdCxRLEM7cmV0dXJuIEk9QS5yZWFkVWludDMyKCksZz1BLnJlYWRCeXRlKCksZT1BLnJlYWRCeXRlKCksQj1BLnJlYWRJbnQxNigpLGk9QS5yZWFkSW50MTYoKSx0PUEucmVhZEludDE2KCksUT1BLnJlYWRJbnQxNigpLEM9QS5yZWFkQnl0ZSgpLHtidXR0b25zOkksbGVmdFRyaWdnZXI6ZyxyaWdodFRyaWdnZXI6ZSxsZWZ0VGh1bWJYOkIsbGVmdFRodW1iWTppLHJpZ2h0VGh1bWJYOnQscmlnaHRUaHVtYlk6USxzbG90OkN9fX0sSS5HYW1lcGFkUnVtYmxlPXtkaXNjcmltaW5hdG9yOjIsZW5jb2RlKEEpe2NvbnN0IEk9ZS5CZWJvcFZpZXcuZ2V0SW5zdGFuY2UoKTtyZXR1cm4gSS5zdGFydFdyaXRpbmcoKSx0aGlzLmVuY29kZUludG8oQSxJKSxJLnRvQXJyYXkoKX0sZW5jb2RlSW50byhBLEkpe2NvbnN0IGc9SS5sZW5ndGg7cmV0dXJuIEkud3JpdGVCeXRlKEEucG9ydCksSS53cml0ZVVpbnQxNihBLmxlZnRNb3RvclNwZWVkKSxJLndyaXRlVWludDE2KEEucmlnaHRNb3RvclNwZWVkKSxJLmxlbmd0aC1nfSxkZWNvZGUoQSl7Y29uc3QgST1lLkJlYm9wVmlldy5nZXRJbnN0YW5jZSgpO3JldHVybiBJLnN0YXJ0UmVhZGluZyhBKSx0aGlzLnJlYWRGcm9tKEkpfSxyZWFkRnJvbShBKXtsZXQgSSxnLGU7cmV0dXJuIEk9QS5yZWFkQnl0ZSgpLGc9QS5yZWFkVWludDE2KCksZT1BLnJlYWRVaW50MTYoKSx7cG9ydDpJLGxlZnRNb3RvclNwZWVkOmcscmlnaHRNb3RvclNwZWVkOmV9fX0sSS5Nb3VzZUFic29sdXRlPXtkaXNjcmltaW5hdG9yOjMsZW5jb2RlKEEpe2NvbnN0IEk9ZS5CZWJvcFZpZXcuZ2V0SW5zdGFuY2UoKTtyZXR1cm4gSS5zdGFydFdyaXRpbmcoKSx0aGlzLmVuY29kZUludG8oQSxJKSxJLnRvQXJyYXkoKX0sZW5jb2RlSW50byhBLEkpe2NvbnN0IGc9SS5sZW5ndGg7cmV0dXJuIEkud3JpdGVJbnQzMihBLngpLEkud3JpdGVJbnQzMihBLnkpLEkubGVuZ3RoLWd9LGRlY29kZShBKXtjb25zdCBJPWUuQmVib3BWaWV3LmdldEluc3RhbmNlKCk7cmV0dXJuIEkuc3RhcnRSZWFkaW5nKEEpLHRoaXMucmVhZEZyb20oSSl9LHJlYWRGcm9tKEEpe2xldCBJLGc7cmV0dXJuIEk9QS5yZWFkSW50MzIoKSxnPUEucmVhZEludDMyKCkse3g6SSx5Omd9fX0sSS5Nb3VzZVJlbGF0aXZlPXtkaXNjcmltaW5hdG9yOjQsZW5jb2RlKEEpe2NvbnN0IEk9ZS5CZWJvcFZpZXcuZ2V0SW5zdGFuY2UoKTtyZXR1cm4gSS5zdGFydFdyaXRpbmcoKSx0aGlzLmVuY29kZUludG8oQSxJKSxJLnRvQXJyYXkoKX0sZW5jb2RlSW50byhBLEkpe2NvbnN0IGc9SS5sZW5ndGg7cmV0dXJuIEkud3JpdGVJbnQzMihBLmR4KSxJLndyaXRlSW50MzIoQS5keSksSS5sZW5ndGgtZ30sZGVjb2RlKEEpe2NvbnN0IEk9ZS5CZWJvcFZpZXcuZ2V0SW5zdGFuY2UoKTtyZXR1cm4gSS5zdGFydFJlYWRpbmcoQSksdGhpcy5yZWFkRnJvbShJKX0scmVhZEZyb20oQSl7bGV0IEksZztyZXR1cm4gST1BLnJlYWRJbnQzMigpLGc9QS5yZWFkSW50MzIoKSx7ZHg6SSxkeTpnfX19LEkuTW91c2VDbGljaz17ZGlzY3JpbWluYXRvcjo1LGVuY29kZShBKXtjb25zdCBJPWUuQmVib3BWaWV3LmdldEluc3RhbmNlKCk7cmV0dXJuIEkuc3RhcnRXcml0aW5nKCksdGhpcy5lbmNvZGVJbnRvKEEsSSksSS50b0FycmF5KCl9LGVuY29kZUludG8oQSxJKXtjb25zdCBnPUkubGVuZ3RoO3JldHVybiBJLndyaXRlVWludDMyKEEuYWN0aW9uKSxJLndyaXRlVWludDMyKEEuYnV0dG9uKSxJLmxlbmd0aC1nfSxkZWNvZGUoQSl7Y29uc3QgST1lLkJlYm9wVmlldy5nZXRJbnN0YW5jZSgpO3JldHVybiBJLnN0YXJ0UmVhZGluZyhBKSx0aGlzLnJlYWRGcm9tKEkpfSxyZWFkRnJvbShBKXtsZXQgSSxnO3JldHVybiBJPUEucmVhZFVpbnQzMigpLGc9QS5yZWFkVWludDMyKCkse2FjdGlvbjpJLGJ1dHRvbjpnfX19LEkuTW91c2VTY3JvbGw9e2Rpc2NyaW1pbmF0b3I6NixlbmNvZGUoQSl7Y29uc3QgST1lLkJlYm9wVmlldy5nZXRJbnN0YW5jZSgpO3JldHVybiBJLnN0YXJ0V3JpdGluZygpLHRoaXMuZW5jb2RlSW50byhBLEkpLEkudG9BcnJheSgpfSxlbmNvZGVJbnRvKEEsSSl7Y29uc3QgZz1JLmxlbmd0aDtyZXR1cm4gSS53cml0ZVVpbnQzMihBLmF4aXMpLEkud3JpdGVJbnQzMihBLmRlbHRhKSxJLmxlbmd0aC1nfSxkZWNvZGUoQSl7Y29uc3QgST1lLkJlYm9wVmlldy5nZXRJbnN0YW5jZSgpO3JldHVybiBJLnN0YXJ0UmVhZGluZyhBKSx0aGlzLnJlYWRGcm9tKEkpfSxyZWFkRnJvbShBKXtsZXQgSSxnO3JldHVybiBJPUEucmVhZFVpbnQzMigpLGc9QS5yZWFkSW50MzIoKSx7YXhpczpJLGRlbHRhOmd9fX0sSS5LZXlib2FyZElucHV0PXtkaXNjcmltaW5hdG9yOjcsZW5jb2RlKEEpe2NvbnN0IEk9ZS5CZWJvcFZpZXcuZ2V0SW5zdGFuY2UoKTtyZXR1cm4gSS5zdGFydFdyaXRpbmcoKSx0aGlzLmVuY29kZUludG8oQSxJKSxJLnRvQXJyYXkoKX0sZW5jb2RlSW50byhBLEkpe2NvbnN0IGc9SS5sZW5ndGg7cmV0dXJuIEkud3JpdGVVaW50MzIoQS5hY3Rpb24pLEkud3JpdGVVaW50MzIoQS5rZXljb2RlKSxJLmxlbmd0aC1nfSxkZWNvZGUoQSl7Y29uc3QgST1lLkJlYm9wVmlldy5nZXRJbnN0YW5jZSgpO3JldHVybiBJLnN0YXJ0UmVhZGluZyhBKSx0aGlzLnJlYWRGcm9tKEkpfSxyZWFkRnJvbShBKXtsZXQgSSxnO3JldHVybiBJPUEucmVhZFVpbnQzMigpLGc9QS5yZWFkVWludDMyKCkse2FjdGlvbjpJLGtleWNvZGU6Z319fSxJLkxvZ2ljYWxJbnB1dD17ZGlzY3JpbWluYXRvcjo4LGVuY29kZShBKXtjb25zdCBJPWUuQmVib3BWaWV3LmdldEluc3RhbmNlKCk7cmV0dXJuIEkuc3RhcnRXcml0aW5nKCksdGhpcy5lbmNvZGVJbnRvKEEsSSksSS50b0FycmF5KCl9LGVuY29kZUludG8oQSxJKXtjb25zdCBnPUkubGVuZ3RoO3JldHVybiBJLndyaXRlU3RyaW5nKEEuaW5wdXRTdHJpbmcpLEkubGVuZ3RoLWd9LGRlY29kZShBKXtjb25zdCBJPWUuQmVib3BWaWV3LmdldEluc3RhbmNlKCk7cmV0dXJuIEkuc3RhcnRSZWFkaW5nKEEpLHRoaXMucmVhZEZyb20oSSl9LHJlYWRGcm9tKEEpe2xldCBJO3JldHVybiBJPUEucmVhZFN0cmluZygpLHtpbnB1dFN0cmluZzpJfX19LEkuVG91Y2hlc0Fic29sdXRlPXtkaXNjcmltaW5hdG9yOjksZW5jb2RlKEEpe2NvbnN0IEk9ZS5CZWJvcFZpZXcuZ2V0SW5zdGFuY2UoKTtyZXR1cm4gSS5zdGFydFdyaXRpbmcoKSx0aGlzLmVuY29kZUludG8oQSxJKSxJLnRvQXJyYXkoKX0sZW5jb2RlSW50byhBLGcpe2NvbnN0IGU9Zy5sZW5ndGg7e2NvbnN0IGU9QS50b3VjaGVzLmxlbmd0aDtnLndyaXRlVWludDMyKGUpO2ZvcihsZXQgQj0wO0I8ZTtCKyspSS5Ub3VjaEFic29sdXRlLmVuY29kZUludG8oQS50b3VjaGVzW0JdLGcpfXJldHVybiBnLmxlbmd0aC1lfSxkZWNvZGUoQSl7Y29uc3QgST1lLkJlYm9wVmlldy5nZXRJbnN0YW5jZSgpO3JldHVybiBJLnN0YXJ0UmVhZGluZyhBKSx0aGlzLnJlYWRGcm9tKEkpfSxyZWFkRnJvbShBKXtsZXQgZzt7bGV0IGU9QS5yZWFkVWludDMyKCk7Zz1uZXcgQXJyYXkoZSk7Zm9yKGxldCBCPTA7QjxlO0IrKyl7bGV0IGU7ZT1JLlRvdWNoQWJzb2x1dGUucmVhZEZyb20oQSksZ1tCXT1lfX1yZXR1cm57dG91Y2hlczpnfX19LEkuUGVuQWJzb2x1dGU9e2Rpc2NyaW1pbmF0b3I6MTAsZW5jb2RlKEEpe2NvbnN0IEk9ZS5CZWJvcFZpZXcuZ2V0SW5zdGFuY2UoKTtyZXR1cm4gSS5zdGFydFdyaXRpbmcoKSx0aGlzLmVuY29kZUludG8oQSxJKSxJLnRvQXJyYXkoKX0sZW5jb2RlSW50byhBLGcpe2NvbnN0IGU9Zy5sZW5ndGg7cmV0dXJuIEkuVG91Y2hQZW5Qb2ludGVySW5mby5lbmNvZGVJbnRvKEEucG9pbnRlckluZm8sZyksZy53cml0ZVVpbnQzMihBLnBlbkZsYWdzKSxnLndyaXRlVWludDMyKEEucGVuTWFzayksZy53cml0ZVVpbnQzMihBLnByZXNzdXJlKSxnLndyaXRlVWludDMyKEEucm90YXRpb24pLGcud3JpdGVJbnQzMihBLnRpbHRYKSxnLndyaXRlSW50MzIoQS50aWx0WSksZy5sZW5ndGgtZX0sZGVjb2RlKEEpe2NvbnN0IEk9ZS5CZWJvcFZpZXcuZ2V0SW5zdGFuY2UoKTtyZXR1cm4gSS5zdGFydFJlYWRpbmcoQSksdGhpcy5yZWFkRnJvbShJKX0scmVhZEZyb20oQSl7bGV0IGcsZSxCLGksdCxRLEM7cmV0dXJuIGc9SS5Ub3VjaFBlblBvaW50ZXJJbmZvLnJlYWRGcm9tKEEpLGU9QS5yZWFkVWludDMyKCksQj1BLnJlYWRVaW50MzIoKSxpPUEucmVhZFVpbnQzMigpLHQ9QS5yZWFkVWludDMyKCksUT1BLnJlYWRJbnQzMigpLEM9QS5yZWFkSW50MzIoKSx7cG9pbnRlckluZm86ZyxwZW5GbGFnczplLHBlbk1hc2s6QixwcmVzc3VyZTppLHJvdGF0aW9uOnQsdGlsdFg6USx0aWx0WTpDfX19LEkuVmlld3BvcnRSZXNpemU9e2Rpc2NyaW1pbmF0b3I6MTEsZW5jb2RlKEEpe2NvbnN0IEk9ZS5CZWJvcFZpZXcuZ2V0SW5zdGFuY2UoKTtyZXR1cm4gSS5zdGFydFdyaXRpbmcoKSx0aGlzLmVuY29kZUludG8oQSxJKSxJLnRvQXJyYXkoKX0sZW5jb2RlSW50byhBLEkpe2NvbnN0IGc9SS5sZW5ndGg7cmV0dXJuIEkud3JpdGVVaW50MzIoQS53aWR0aCksSS53cml0ZVVpbnQzMihBLmhlaWdodCksSS5sZW5ndGgtZ30sZGVjb2RlKEEpe2NvbnN0IEk9ZS5CZWJvcFZpZXcuZ2V0SW5zdGFuY2UoKTtyZXR1cm4gSS5zdGFydFJlYWRpbmcoQSksdGhpcy5yZWFkRnJvbShJKX0scmVhZEZyb20oQSl7bGV0IEksZztyZXR1cm4gST1BLnJlYWRVaW50MzIoKSxnPUEucmVhZFVpbnQzMigpLHt3aWR0aDpJLGhlaWdodDpnfX19LEkuU2V0Q2xpcGJvYXJkVGV4dD17ZGlzY3JpbWluYXRvcjoxMixlbmNvZGUoQSl7Y29uc3QgST1lLkJlYm9wVmlldy5nZXRJbnN0YW5jZSgpO3JldHVybiBJLnN0YXJ0V3JpdGluZygpLHRoaXMuZW5jb2RlSW50byhBLEkpLEkudG9BcnJheSgpfSxlbmNvZGVJbnRvKEEsSSl7Y29uc3QgZz1JLmxlbmd0aDtyZXR1cm4gSS53cml0ZVN0cmluZyhBLnRleHQpLEkubGVuZ3RoLWd9LGRlY29kZShBKXtjb25zdCBJPWUuQmVib3BWaWV3LmdldEluc3RhbmNlKCk7cmV0dXJuIEkuc3RhcnRSZWFkaW5nKEEpLHRoaXMucmVhZEZyb20oSSl9LHJlYWRGcm9tKEEpe2xldCBJO3JldHVybiBJPUEucmVhZFN0cmluZygpLHt0ZXh0Okl9fX0sSS5JbnB1dEJvZHk9e2VuY29kZShBKXtjb25zdCBJPWUuQmVib3BWaWV3LmdldEluc3RhbmNlKCk7cmV0dXJuIEkuc3RhcnRXcml0aW5nKCksdGhpcy5lbmNvZGVJbnRvKEEsSSksSS50b0FycmF5KCl9LGVuY29kZUludG8oQSxnKXtjb25zdCBlPWcubGVuZ3RoLEI9Zy5yZXNlcnZlTWVzc2FnZUxlbmd0aCgpLGk9Zy5sZW5ndGgrMTtzd2l0Y2goZy53cml0ZUJ5dGUoQS5kaXNjcmltaW5hdG9yKSxBLmRpc2NyaW1pbmF0b3Ipe2Nhc2UgMTpJLkdhbWVwYWRSZXBvcnQuZW5jb2RlSW50byhBLnZhbHVlLGcpO2JyZWFrO2Nhc2UgMjpJLkdhbWVwYWRSdW1ibGUuZW5jb2RlSW50byhBLnZhbHVlLGcpO2JyZWFrO2Nhc2UgMzpJLk1vdXNlQWJzb2x1dGUuZW5jb2RlSW50byhBLnZhbHVlLGcpO2JyZWFrO2Nhc2UgNDpJLk1vdXNlUmVsYXRpdmUuZW5jb2RlSW50byhBLnZhbHVlLGcpO2JyZWFrO2Nhc2UgNTpJLk1vdXNlQ2xpY2suZW5jb2RlSW50byhBLnZhbHVlLGcpO2JyZWFrO2Nhc2UgNjpJLk1vdXNlU2Nyb2xsLmVuY29kZUludG8oQS52YWx1ZSxnKTticmVhaztjYXNlIDc6SS5LZXlib2FyZElucHV0LmVuY29kZUludG8oQS52YWx1ZSxnKTticmVhaztjYXNlIDg6SS5Mb2dpY2FsSW5wdXQuZW5jb2RlSW50byhBLnZhbHVlLGcpO2JyZWFrO2Nhc2UgOTpJLlRvdWNoZXNBYnNvbHV0ZS5lbmNvZGVJbnRvKEEudmFsdWUsZyk7YnJlYWs7Y2FzZSAxMDpJLlBlbkFic29sdXRlLmVuY29kZUludG8oQS52YWx1ZSxnKTticmVhaztjYXNlIDExOkkuVmlld3BvcnRSZXNpemUuZW5jb2RlSW50byhBLnZhbHVlLGcpO2JyZWFrO2Nhc2UgMTI6SS5TZXRDbGlwYm9hcmRUZXh0LmVuY29kZUludG8oQS52YWx1ZSxnKX1jb25zdCB0PWcubGVuZ3RoO3JldHVybiBnLmZpbGxNZXNzYWdlTGVuZ3RoKEIsdC1pKSxnLmxlbmd0aC1lfSxkZWNvZGUoQSl7Y29uc3QgST1lLkJlYm9wVmlldy5nZXRJbnN0YW5jZSgpO3JldHVybiBJLnN0YXJ0UmVhZGluZyhBKSx0aGlzLnJlYWRGcm9tKEkpfSxyZWFkRnJvbShBKXtjb25zdCBnPUEucmVhZE1lc3NhZ2VMZW5ndGgoKSxCPUEuaW5kZXgrMStnO3N3aXRjaChBLnJlYWRCeXRlKCkpe2Nhc2UgMTpyZXR1cm57ZGlzY3JpbWluYXRvcjoxLHZhbHVlOkkuR2FtZXBhZFJlcG9ydC5yZWFkRnJvbShBKX07Y2FzZSAyOnJldHVybntkaXNjcmltaW5hdG9yOjIsdmFsdWU6SS5HYW1lcGFkUnVtYmxlLnJlYWRGcm9tKEEpfTtjYXNlIDM6cmV0dXJue2Rpc2NyaW1pbmF0b3I6Myx2YWx1ZTpJLk1vdXNlQWJzb2x1dGUucmVhZEZyb20oQSl9O2Nhc2UgNDpyZXR1cm57ZGlzY3JpbWluYXRvcjo0LHZhbHVlOkkuTW91c2VSZWxhdGl2ZS5yZWFkRnJvbShBKX07Y2FzZSA1OnJldHVybntkaXNjcmltaW5hdG9yOjUsdmFsdWU6SS5Nb3VzZUNsaWNrLnJlYWRGcm9tKEEpfTtjYXNlIDY6cmV0dXJue2Rpc2NyaW1pbmF0b3I6Nix2YWx1ZTpJLk1vdXNlU2Nyb2xsLnJlYWRGcm9tKEEpfTtjYXNlIDc6cmV0dXJue2Rpc2NyaW1pbmF0b3I6Nyx2YWx1ZTpJLktleWJvYXJkSW5wdXQucmVhZEZyb20oQSl9O2Nhc2UgODpyZXR1cm57ZGlzY3JpbWluYXRvcjo4LHZhbHVlOkkuTG9naWNhbElucHV0LnJlYWRGcm9tKEEpfTtjYXNlIDk6cmV0dXJue2Rpc2NyaW1pbmF0b3I6OSx2YWx1ZTpJLlRvdWNoZXNBYnNvbHV0ZS5yZWFkRnJvbShBKX07Y2FzZSAxMDpyZXR1cm57ZGlzY3JpbWluYXRvcjoxMCx2YWx1ZTpJLlBlbkFic29sdXRlLnJlYWRGcm9tKEEpfTtjYXNlIDExOnJldHVybntkaXNjcmltaW5hdG9yOjExLHZhbHVlOkkuVmlld3BvcnRSZXNpemUucmVhZEZyb20oQSl9O2Nhc2UgMTI6cmV0dXJue2Rpc2NyaW1pbmF0b3I6MTIsdmFsdWU6SS5TZXRDbGlwYm9hcmRUZXh0LnJlYWRGcm9tKEEpfTtkZWZhdWx0OnRocm93IEEuaW5kZXg9QixuZXcgZS5CZWJvcFJ1bnRpbWVFcnJvcihcIlVucmVjb2duaXplZCBkaXNjcmltaW5hdG9yIHdoaWxlIGRlY29kaW5nIElucHV0Qm9keVwiKX19fSwoYz1JLlZpZGVvQ29kZWNUeXBlfHwoSS5WaWRlb0NvZGVjVHlwZT17fSkpW2MuQmFzZWxpbmU9MV09XCJCYXNlbGluZVwiLGNbYy5NYWluPTJdPVwiTWFpblwiLGNbYy5IaWdoPTRdPVwiSGlnaFwiLGNbYy5IMjY0PTddPVwiSDI2NFwiLGNbYy5IMjY1PThdPVwiSDI2NVwiLChoPUkuVmVuZG9yfHwoSS5WZW5kb3I9e30pKVtoLlVua25vd249MF09XCJVbmtub3duXCIsaFtoLkFtZD00MDk4XT1cIkFtZFwiLGhbaC5OdmlkaWE9NDMxOF09XCJOdmlkaWFcIixoW2guSW50ZWw9MzI5MDJdPVwiSW50ZWxcIixJLlZpZGVvQ29kZWM9e2VuY29kZShBKXtjb25zdCBJPWUuQmVib3BWaWV3LmdldEluc3RhbmNlKCk7cmV0dXJuIEkuc3RhcnRXcml0aW5nKCksdGhpcy5lbmNvZGVJbnRvKEEsSSksSS50b0FycmF5KCl9LGVuY29kZUludG8oQSxJKXtjb25zdCBnPUkubGVuZ3RoO3JldHVybiBJLndyaXRlU3RyaW5nKEEuZnJpZW5kbHlOYW1lKSxJLndyaXRlVWludDMyKEEud2lkdGgpLEkud3JpdGVVaW50MzIoQS5oZWlnaHQpLEkud3JpdGVVaW50MzIoQS5yZWZyZXNoUmF0ZSksSS53cml0ZUJ5dGVzKEEuZGF0YSksSS53cml0ZVVpbnQzMihBLnR5cGUpLEkubGVuZ3RoLWd9LGRlY29kZShBKXtjb25zdCBJPWUuQmVib3BWaWV3LmdldEluc3RhbmNlKCk7cmV0dXJuIEkuc3RhcnRSZWFkaW5nKEEpLHRoaXMucmVhZEZyb20oSSl9LHJlYWRGcm9tKEEpe2xldCBJLGcsZSxCLGksdDtyZXR1cm4gST1BLnJlYWRTdHJpbmcoKSxnPUEucmVhZFVpbnQzMigpLGU9QS5yZWFkVWludDMyKCksQj1BLnJlYWRVaW50MzIoKSxpPUEucmVhZEJ5dGVzKCksdD1BLnJlYWRVaW50MzIoKSx7ZnJpZW5kbHlOYW1lOkksd2lkdGg6ZyxoZWlnaHQ6ZSxyZWZyZXNoUmF0ZTpCLGRhdGE6aSx0eXBlOnR9fX0sKGQ9SS5Gb3JtRmFjdG9yfHwoSS5Gb3JtRmFjdG9yPXt9KSlbZC5Vbmtub3duPTBdPVwiVW5rbm93blwiLGRbZC5QaG9uZT0xXT1cIlBob25lXCIsZFtkLlRhYmxldD0yXT1cIlRhYmxldFwiLGRbZC5Db21wdXRlcj0zXT1cIkNvbXB1dGVyXCIsZFtkLkNvbnNvbGU9NF09XCJDb25zb2xlXCIsZFtkLlR2PTVdPVwiVHZcIiwocj1JLk9wZXJhdGluZ1N5c3RlbXx8KEkuT3BlcmF0aW5nU3lzdGVtPXt9KSlbci5PdGhlcj0wXT1cIk90aGVyXCIscltyLklPUz0xXT1cIklPU1wiLHJbci5Udk9TPTJdPVwiVHZPU1wiLHJbci5BbmRyb2lkPTNdPVwiQW5kcm9pZFwiLHJbci5XaW5kb3dzPTRdPVwiV2luZG93c1wiLHJbci5NYWNPUz01XT1cIk1hY09TXCIscltyLkxpbnV4PTZdPVwiTGludXhcIixyW3IuUm9rdT03XT1cIlJva3VcIiwocz1JLk5ldHdvcmtQcm90b2NvbHx8KEkuTmV0d29ya1Byb3RvY29sPXt9KSlbcy5XZWJSVEM9MF09XCJXZWJSVENcIixzW3MuR2V5c2VyPTFdPVwiR2V5c2VyXCIsKG49SS5BdWRpb0NoYW5uZWxzfHwoSS5BdWRpb0NoYW5uZWxzPXt9KSlbbi5Nb25vPTBdPVwiTW9ub1wiLG5bbi5TdGVyZW89MV09XCJTdGVyZW9cIixuW24uU3Vycm91bmQ1MT0yXT1cIlN1cnJvdW5kNTFcIixuW24uU3Vycm91bmQ3MT0zXT1cIlN1cnJvdW5kNzFcIiwoYT1JLkF1ZGlvQ29kZWN8fChJLkF1ZGlvQ29kZWM9e30pKVthLk9wdXM9MF09XCJPcHVzXCIsYVthLkFhYz0xXT1cIkFhY1wiLChvPUkuQXVkaW9Db250YWluZXJ8fChJLkF1ZGlvQ29udGFpbmVyPXt9KSlbby5SYXc9MF09XCJSYXdcIixvW28uV2ViTT0xXT1cIldlYk1cIixvW28uSXNvQk1GRj0yXT1cIklzb0JNRkZcIiwoRT1JLlZpZGVvQ29udGFpbmVyfHwoSS5WaWRlb0NvbnRhaW5lcj17fSkpW0UuUmF3PTBdPVwiUmF3XCIsRVtFLklzb0JNRkY9MV09XCJJc29CTUZGXCIsKEM9SS5Mb2dpY0Vycm9yfHwoSS5Mb2dpY0Vycm9yPXt9KSlbQy5Vbmtub3duRXJyb3I9MF09XCJVbmtub3duRXJyb3JcIixDW0MuRGlzcGxheXNNaXNzaW5nPTFdPVwiRGlzcGxheXNNaXNzaW5nXCIsQ1tDLk5vQXZhaWxhYmxlRW5jb2Rlcj0yXT1cIk5vQXZhaWxhYmxlRW5jb2RlclwiLENbQy5JbnZhbGlkRW5jb2RpbmdDb25maWc9M109XCJJbnZhbGlkRW5jb2RpbmdDb25maWdcIixDW0MuTm9Db2RlY3NFeGNoYW5nZWQ9NF09XCJOb0NvZGVjc0V4Y2hhbmdlZFwiLENbQy5Ob0NhcGFiaWxpdGllcz01XT1cIk5vQ2FwYWJpbGl0aWVzXCIsQ1tDLk5vU3VjaFN0cmVhbT02XT1cIk5vU3VjaFN0cmVhbVwiLENbQy5Gb3JjZVNlZ21lbnRGYWlsZWQ9N109XCJGb3JjZVNlZ21lbnRGYWlsZWRcIixJLkF1ZGlvQ29uZmlnPXtlbmNvZGUoQSl7Y29uc3QgST1lLkJlYm9wVmlldy5nZXRJbnN0YW5jZSgpO3JldHVybiBJLnN0YXJ0V3JpdGluZygpLHRoaXMuZW5jb2RlSW50byhBLEkpLEkudG9BcnJheSgpfSxlbmNvZGVJbnRvKEEsSSl7Y29uc3QgZz1JLmxlbmd0aDtyZXR1cm4gSS53cml0ZVVpbnQzMihBLmNvZGVjKSxJLndyaXRlVWludDMyKEEuY29udGFpbmVyKSxJLmxlbmd0aC1nfSxkZWNvZGUoQSl7Y29uc3QgST1lLkJlYm9wVmlldy5nZXRJbnN0YW5jZSgpO3JldHVybiBJLnN0YXJ0UmVhZGluZyhBKSx0aGlzLnJlYWRGcm9tKEkpfSxyZWFkRnJvbShBKXtsZXQgSSxnO3JldHVybiBJPUEucmVhZFVpbnQzMigpLGc9QS5yZWFkVWludDMyKCkse2NvZGVjOkksY29udGFpbmVyOmd9fX0sKFE9SS5DYXB0dXJlTW9kZXx8KEkuQ2FwdHVyZU1vZGU9e30pKVtRLlVua25vd249MF09XCJVbmtub3duXCIsUVtRLkZ1bGxEZXNrdG9wPTFdPVwiRnVsbERlc2t0b3BcIixRW1EuQXBwSXNvbGF0aW9uPTJdPVwiQXBwSXNvbGF0aW9uXCIsUVtRLkRpcmVjdD0zXT1cIkRpcmVjdFwiLEkuVmlkZW9Db25maWc9e2VuY29kZShBKXtjb25zdCBJPWUuQmVib3BWaWV3LmdldEluc3RhbmNlKCk7cmV0dXJuIEkuc3RhcnRXcml0aW5nKCksdGhpcy5lbmNvZGVJbnRvKEEsSSksSS50b0FycmF5KCl9LGVuY29kZUludG8oQSxnKXtjb25zdCBlPWcubGVuZ3RoO3JldHVybiBJLlZpZGVvQ29kZWMuZW5jb2RlSW50byhBLmNvZGVjLGcpLGcud3JpdGVVaW50MzIoQS5jb250YWluZXIpLGcubGVuZ3RoLWV9LGRlY29kZShBKXtjb25zdCBJPWUuQmVib3BWaWV3LmdldEluc3RhbmNlKCk7cmV0dXJuIEkuc3RhcnRSZWFkaW5nKEEpLHRoaXMucmVhZEZyb20oSSl9LHJlYWRGcm9tKEEpe2xldCBnLGU7cmV0dXJuIGc9SS5WaWRlb0NvZGVjLnJlYWRGcm9tKEEpLGU9QS5yZWFkVWludDMyKCkse2NvZGVjOmcsY29udGFpbmVyOmV9fX0sKHQ9SS5JbnB1dExldmVsfHwoSS5JbnB1dExldmVsPXt9KSlbdC5Ob25lPTBdPVwiTm9uZVwiLHRbdC5HYW1lcGFkUG9ydDE9MV09XCJHYW1lcGFkUG9ydDFcIix0W3QuR2FtZXBhZFBvcnQyPTJdPVwiR2FtZXBhZFBvcnQyXCIsdFt0LkdhbWVwYWRQb3J0Mz00XT1cIkdhbWVwYWRQb3J0M1wiLHRbdC5HYW1lcGFkUG9ydDQ9OF09XCJHYW1lcGFkUG9ydDRcIix0W3QuR2FtZXBhZD0xNV09XCJHYW1lcGFkXCIsdFt0Lk1vdXNlPTE2XT1cIk1vdXNlXCIsdFt0LktleWJvYXJkPTMyXT1cIktleWJvYXJkXCIsdFt0LkNsaXBib2FyZD02NF09XCJDbGlwYm9hcmRcIix0W3QuQWxsPTYzXT1cIkFsbFwiLEkuRGV2aWNlSW5mbz17ZGlzY3JpbWluYXRvcjoxLGVuY29kZShBKXtjb25zdCBJPWUuQmVib3BWaWV3LmdldEluc3RhbmNlKCk7cmV0dXJuIEkuc3RhcnRXcml0aW5nKCksdGhpcy5lbmNvZGVJbnRvKEEsSSksSS50b0FycmF5KCl9LGVuY29kZUludG8oQSxJKXtjb25zdCBnPUkubGVuZ3RoO3JldHVybiBJLndyaXRlVWludDMyKEEuZm9ybUZhY3RvciksSS53cml0ZVN0cmluZyhBLmRldmljZU5hbWUpLEkud3JpdGVVaW50MzIoQS5kZXZpY2VPcyksSS53cml0ZVN0cmluZyhBLmRldmljZU9zVmVyc2lvbiksSS53cml0ZVN0cmluZyhBLmRldmljZU1vZGVsKSxJLndyaXRlU3RyaW5nKEEudXNlckFnZW50KSxJLndyaXRlU3RyaW5nKEEuZGV2aWNlSWQpLEkud3JpdGVCeXRlKE51bWJlcihBLmlzV2ViKSksSS5sZW5ndGgtZ30sZGVjb2RlKEEpe2NvbnN0IEk9ZS5CZWJvcFZpZXcuZ2V0SW5zdGFuY2UoKTtyZXR1cm4gSS5zdGFydFJlYWRpbmcoQSksdGhpcy5yZWFkRnJvbShJKX0scmVhZEZyb20oQSl7bGV0IEksZyxlLEIsaSx0LFEsQztyZXR1cm4gST1BLnJlYWRVaW50MzIoKSxnPUEucmVhZFN0cmluZygpLGU9QS5yZWFkVWludDMyKCksQj1BLnJlYWRTdHJpbmcoKSxpPUEucmVhZFN0cmluZygpLHQ9QS5yZWFkU3RyaW5nKCksUT1BLnJlYWRTdHJpbmcoKSxDPSEhQS5yZWFkQnl0ZSgpLHtmb3JtRmFjdG9yOkksZGV2aWNlTmFtZTpnLGRldmljZU9zOmUsZGV2aWNlT3NWZXJzaW9uOkIsZGV2aWNlTW9kZWw6aSx1c2VyQWdlbnQ6dCxkZXZpY2VJZDpRLGlzV2ViOkN9fX0sSS5Db2RlY1BhY2tSZXF1ZXN0PXtkaXNjcmltaW5hdG9yOjIsZW5jb2RlKEEpe2NvbnN0IEk9ZS5CZWJvcFZpZXcuZ2V0SW5zdGFuY2UoKTtyZXR1cm4gSS5zdGFydFdyaXRpbmcoKSx0aGlzLmVuY29kZUludG8oQSxJKSxJLnRvQXJyYXkoKX0sZW5jb2RlSW50byhBLEkpe2NvbnN0IGc9SS5sZW5ndGg7cmV0dXJuIEkubGVuZ3RoLWd9LGRlY29kZShBKXtjb25zdCBJPWUuQmVib3BWaWV3LmdldEluc3RhbmNlKCk7cmV0dXJuIEkuc3RhcnRSZWFkaW5nKEEpLHRoaXMucmVhZEZyb20oSSl9LHJlYWRGcm9tOkE9Pih7fSl9LEkuQ29kZWNQYWNrUmVzcG9uc2U9e2Rpc2NyaW1pbmF0b3I6MyxlbmNvZGUoQSl7Y29uc3QgST1lLkJlYm9wVmlldy5nZXRJbnN0YW5jZSgpO3JldHVybiBJLnN0YXJ0V3JpdGluZygpLHRoaXMuZW5jb2RlSW50byhBLEkpLEkudG9BcnJheSgpfSxlbmNvZGVJbnRvKEEsZyl7Y29uc3QgZT1nLmxlbmd0aDt7Y29uc3QgZT1BLnZpZGVvQ29kZWNzLmxlbmd0aDtnLndyaXRlVWludDMyKGUpO2ZvcihsZXQgQj0wO0I8ZTtCKyspSS5WaWRlb0NvZGVjLmVuY29kZUludG8oQS52aWRlb0NvZGVjc1tCXSxnKX1yZXR1cm4gZy5sZW5ndGgtZX0sZGVjb2RlKEEpe2NvbnN0IEk9ZS5CZWJvcFZpZXcuZ2V0SW5zdGFuY2UoKTtyZXR1cm4gSS5zdGFydFJlYWRpbmcoQSksdGhpcy5yZWFkRnJvbShJKX0scmVhZEZyb20oQSl7bGV0IGc7e2xldCBlPUEucmVhZFVpbnQzMigpO2c9bmV3IEFycmF5KGUpO2ZvcihsZXQgQj0wO0I8ZTtCKyspe2xldCBlO2U9SS5WaWRlb0NvZGVjLnJlYWRGcm9tKEEpLGdbQl09ZX19cmV0dXJue3ZpZGVvQ29kZWNzOmd9fX0sSS5DbGllbnRDYXBhYmlsaXRpZXM9e2Rpc2NyaW1pbmF0b3I6NCxlbmNvZGUoQSl7Y29uc3QgST1lLkJlYm9wVmlldy5nZXRJbnN0YW5jZSgpO3JldHVybiBJLnN0YXJ0V3JpdGluZygpLHRoaXMuZW5jb2RlSW50byhBLEkpLEkudG9BcnJheSgpfSxlbmNvZGVJbnRvKEEsZyl7Y29uc3QgZT1nLmxlbmd0aDtnLndyaXRlVWludDMyKEEucHJlZmVycmVkV2lkdGgpLGcud3JpdGVVaW50MzIoQS5wcmVmZXJyZWRIZWlnaHQpLGcud3JpdGVVaW50MzIoQS5wcmVmZXJyZWRGcHMpLGcud3JpdGVVaW50MzIoQS5wcmVmZXJyZWRBdWRpb0JpdHJhdGUpLGcud3JpdGVVaW50MzIoQS5wcmVmZXJyZWRWaWRlb0JpdHJhdGUpLGcud3JpdGVVaW50MzIoQS5wcmVmZXJyZWRBdWRpb0NoYW5uZWxzKSxJLkF1ZGlvQ29uZmlnLmVuY29kZUludG8oQS5wcmVmZXJyZWRBdWRpb0NvbmZpZyxnKSxJLlZpZGVvQ29uZmlnLmVuY29kZUludG8oQS5wcmVmZXJyZWRWaWRlb0NvbmZpZyxnKTt7Y29uc3QgST1BLnN1cHBvcnRlZEF1ZGlvQ2hhbm5lbHMubGVuZ3RoO2cud3JpdGVVaW50MzIoSSk7Zm9yKGxldCBlPTA7ZTxJO2UrKylnLndyaXRlVWludDMyKEEuc3VwcG9ydGVkQXVkaW9DaGFubmVsc1tlXSl9e2NvbnN0IGU9QS5zdXBwb3J0ZWRBdWRpb0NvbmZpZ3MubGVuZ3RoO2cud3JpdGVVaW50MzIoZSk7Zm9yKGxldCBCPTA7QjxlO0IrKylJLkF1ZGlvQ29uZmlnLmVuY29kZUludG8oQS5zdXBwb3J0ZWRBdWRpb0NvbmZpZ3NbQl0sZyl9e2NvbnN0IGU9QS5zdXBwb3J0ZWRWaWRlb0NvbmZpZ3MubGVuZ3RoO2cud3JpdGVVaW50MzIoZSk7Zm9yKGxldCBCPTA7QjxlO0IrKylJLlZpZGVvQ29uZmlnLmVuY29kZUludG8oQS5zdXBwb3J0ZWRWaWRlb0NvbmZpZ3NbQl0sZyl9cmV0dXJuIGcud3JpdGVCeXRlKE51bWJlcihBLnN1cHBvcnRzT3ZlcjEwODBQKSksZy53cml0ZUJ5dGUoTnVtYmVyKEEuc3VwcG9ydHNUZW1wb3JhbFNjYWxpbmcpKSxnLndyaXRlQnl0ZShOdW1iZXIoQS5zdXBwb3J0c0FwcElzb2xhdGlvbikpLGcubGVuZ3RoLWV9LGRlY29kZShBKXtjb25zdCBJPWUuQmVib3BWaWV3LmdldEluc3RhbmNlKCk7cmV0dXJuIEkuc3RhcnRSZWFkaW5nKEEpLHRoaXMucmVhZEZyb20oSSl9LHJlYWRGcm9tKEEpe2xldCBnLGUsQixpLHQsUSxDLEUsbyxhLG4scyxyLGQ7Zz1BLnJlYWRVaW50MzIoKSxlPUEucmVhZFVpbnQzMigpLEI9QS5yZWFkVWludDMyKCksaT1BLnJlYWRVaW50MzIoKSx0PUEucmVhZFVpbnQzMigpLFE9QS5yZWFkVWludDMyKCksQz1JLkF1ZGlvQ29uZmlnLnJlYWRGcm9tKEEpLEU9SS5WaWRlb0NvbmZpZy5yZWFkRnJvbShBKTt7bGV0IEk9QS5yZWFkVWludDMyKCk7bz1uZXcgQXJyYXkoSSk7Zm9yKGxldCBnPTA7ZzxJO2crKyl7bGV0IEk7ST1BLnJlYWRVaW50MzIoKSxvW2ddPUl9fXtsZXQgZz1BLnJlYWRVaW50MzIoKTthPW5ldyBBcnJheShnKTtmb3IobGV0IGU9MDtlPGc7ZSsrKXtsZXQgZztnPUkuQXVkaW9Db25maWcucmVhZEZyb20oQSksYVtlXT1nfX17bGV0IGc9QS5yZWFkVWludDMyKCk7bj1uZXcgQXJyYXkoZyk7Zm9yKGxldCBlPTA7ZTxnO2UrKyl7bGV0IGc7Zz1JLlZpZGVvQ29uZmlnLnJlYWRGcm9tKEEpLG5bZV09Z319cmV0dXJuIHM9ISFBLnJlYWRCeXRlKCkscj0hIUEucmVhZEJ5dGUoKSxkPSEhQS5yZWFkQnl0ZSgpLHtwcmVmZXJyZWRXaWR0aDpnLHByZWZlcnJlZEhlaWdodDplLHByZWZlcnJlZEZwczpCLHByZWZlcnJlZEF1ZGlvQml0cmF0ZTppLHByZWZlcnJlZFZpZGVvQml0cmF0ZTp0LHByZWZlcnJlZEF1ZGlvQ2hhbm5lbHM6USxwcmVmZXJyZWRBdWRpb0NvbmZpZzpDLHByZWZlcnJlZFZpZGVvQ29uZmlnOkUsc3VwcG9ydGVkQXVkaW9DaGFubmVsczpvLHN1cHBvcnRlZEF1ZGlvQ29uZmlnczphLHN1cHBvcnRlZFZpZGVvQ29uZmlnczpuLHN1cHBvcnRzT3ZlcjEwODBQOnMsc3VwcG9ydHNUZW1wb3JhbFNjYWxpbmc6cixzdXBwb3J0c0FwcElzb2xhdGlvbjpkfX19LEkuRXJyb3JSZXNwb25zZT17ZGlzY3JpbWluYXRvcjo1LGVuY29kZShBKXtjb25zdCBJPWUuQmVib3BWaWV3LmdldEluc3RhbmNlKCk7cmV0dXJuIEkuc3RhcnRXcml0aW5nKCksdGhpcy5lbmNvZGVJbnRvKEEsSSksSS50b0FycmF5KCl9LGVuY29kZUludG8oQSxJKXtjb25zdCBnPUkubGVuZ3RoO3JldHVybiBJLndyaXRlVWludDMyKEEuZXJyb3IpLEkubGVuZ3RoLWd9LGRlY29kZShBKXtjb25zdCBJPWUuQmVib3BWaWV3LmdldEluc3RhbmNlKCk7cmV0dXJuIEkuc3RhcnRSZWFkaW5nKEEpLHRoaXMucmVhZEZyb20oSSl9LHJlYWRGcm9tKEEpe2xldCBJO3JldHVybiBJPUEucmVhZFVpbnQzMigpLHtlcnJvcjpJfX19LEkuU3RyZWFtUmVxdWVzdD17ZGlzY3JpbWluYXRvcjo2LGVuY29kZShBKXtjb25zdCBJPWUuQmVib3BWaWV3LmdldEluc3RhbmNlKCk7cmV0dXJuIEkuc3RhcnRXcml0aW5nKCksdGhpcy5lbmNvZGVJbnRvKEEsSSksSS50b0FycmF5KCl9LGVuY29kZUludG8oQSxJKXtjb25zdCBnPUkubGVuZ3RoO3JldHVybiBJLndyaXRlVWludDMyKEEuaW5wdXRMZXZlbCksSS5sZW5ndGgtZ30sZGVjb2RlKEEpe2NvbnN0IEk9ZS5CZWJvcFZpZXcuZ2V0SW5zdGFuY2UoKTtyZXR1cm4gSS5zdGFydFJlYWRpbmcoQSksdGhpcy5yZWFkRnJvbShJKX0scmVhZEZyb20oQSl7bGV0IEk7cmV0dXJuIEk9QS5yZWFkVWludDMyKCkse2lucHV0TGV2ZWw6SX19fSxJLlN0cmVhbVN0YXJ0aW5nPXtkaXNjcmltaW5hdG9yOjcsZW5jb2RlKEEpe2NvbnN0IEk9ZS5CZWJvcFZpZXcuZ2V0SW5zdGFuY2UoKTtyZXR1cm4gSS5zdGFydFdyaXRpbmcoKSx0aGlzLmVuY29kZUludG8oQSxJKSxJLnRvQXJyYXkoKX0sZW5jb2RlSW50byhBLGcpe2NvbnN0IGU9Zy5sZW5ndGg7cmV0dXJuIGcud3JpdGVCeXRlKEEuc3RyZWFtSWQpLGcud3JpdGVVaW50MzIoQS5pbnB1dExldmVsKSxnLndyaXRlRmxvYXQzMihBLnRlbXBvcmFsU2NhbGVGYWN0b3IpLEkuQXVkaW9Db25maWcuZW5jb2RlSW50byhBLmNob3NlbkF1ZGlvQ29uZmlnLGcpLEkuVmlkZW9Db25maWcuZW5jb2RlSW50byhBLmNob3NlblZpZGVvQ29uZmlnLGcpLGcud3JpdGVVaW50MzIoQS5jYXB0dXJlTW9kZSksZy5sZW5ndGgtZX0sZGVjb2RlKEEpe2NvbnN0IEk9ZS5CZWJvcFZpZXcuZ2V0SW5zdGFuY2UoKTtyZXR1cm4gSS5zdGFydFJlYWRpbmcoQSksdGhpcy5yZWFkRnJvbShJKX0scmVhZEZyb20oQSl7bGV0IGcsZSxCLGksdCxRO3JldHVybiBnPUEucmVhZEJ5dGUoKSxlPUEucmVhZFVpbnQzMigpLEI9QS5yZWFkRmxvYXQzMigpLGk9SS5BdWRpb0NvbmZpZy5yZWFkRnJvbShBKSx0PUkuVmlkZW9Db25maWcucmVhZEZyb20oQSksUT1BLnJlYWRVaW50MzIoKSx7c3RyZWFtSWQ6ZyxpbnB1dExldmVsOmUsdGVtcG9yYWxTY2FsZUZhY3RvcjpCLGNob3NlbkF1ZGlvQ29uZmlnOmksY2hvc2VuVmlkZW9Db25maWc6dCxjYXB0dXJlTW9kZTpRfX19LEkuTGVhdmVTdHJlYW09e2Rpc2NyaW1pbmF0b3I6OCxlbmNvZGUoQSl7Y29uc3QgST1lLkJlYm9wVmlldy5nZXRJbnN0YW5jZSgpO3JldHVybiBJLnN0YXJ0V3JpdGluZygpLHRoaXMuZW5jb2RlSW50byhBLEkpLEkudG9BcnJheSgpfSxlbmNvZGVJbnRvKEEsSSl7Y29uc3QgZz1JLmxlbmd0aDtyZXR1cm4gSS53cml0ZUJ5dGUoQS5zdHJlYW1JZCksSS5sZW5ndGgtZ30sZGVjb2RlKEEpe2NvbnN0IEk9ZS5CZWJvcFZpZXcuZ2V0SW5zdGFuY2UoKTtyZXR1cm4gSS5zdGFydFJlYWRpbmcoQSksdGhpcy5yZWFkRnJvbShJKX0scmVhZEZyb20oQSl7bGV0IEk7cmV0dXJuIEk9QS5yZWFkQnl0ZSgpLHtzdHJlYW1JZDpJfX19LEkuU3RyZWFtU3RvcHBpbmc9e2Rpc2NyaW1pbmF0b3I6OSxlbmNvZGUoQSl7Y29uc3QgST1lLkJlYm9wVmlldy5nZXRJbnN0YW5jZSgpO3JldHVybiBJLnN0YXJ0V3JpdGluZygpLHRoaXMuZW5jb2RlSW50byhBLEkpLEkudG9BcnJheSgpfSxlbmNvZGVJbnRvKEEsSSl7Y29uc3QgZz1JLmxlbmd0aDtyZXR1cm4gSS53cml0ZUJ5dGUoQS5zdHJlYW1JZCksSS5sZW5ndGgtZ30sZGVjb2RlKEEpe2NvbnN0IEk9ZS5CZWJvcFZpZXcuZ2V0SW5zdGFuY2UoKTtyZXR1cm4gSS5zdGFydFJlYWRpbmcoQSksdGhpcy5yZWFkRnJvbShJKX0scmVhZEZyb20oQSl7bGV0IEk7cmV0dXJuIEk9QS5yZWFkQnl0ZSgpLHtzdHJlYW1JZDpJfX19LEkuS2V5ZnJhbWVSZXF1ZXN0PXtkaXNjcmltaW5hdG9yOjEwLGVuY29kZShBKXtjb25zdCBJPWUuQmVib3BWaWV3LmdldEluc3RhbmNlKCk7cmV0dXJuIEkuc3RhcnRXcml0aW5nKCksdGhpcy5lbmNvZGVJbnRvKEEsSSksSS50b0FycmF5KCl9LGVuY29kZUludG8oQSxJKXtjb25zdCBnPUkubGVuZ3RoO3JldHVybiBJLndyaXRlQnl0ZShBLnN0cmVhbUlkKSxJLmxlbmd0aC1nfSxkZWNvZGUoQSl7Y29uc3QgST1lLkJlYm9wVmlldy5nZXRJbnN0YW5jZSgpO3JldHVybiBJLnN0YXJ0UmVhZGluZyhBKSx0aGlzLnJlYWRGcm9tKEkpfSxyZWFkRnJvbShBKXtsZXQgSTtyZXR1cm4gST1BLnJlYWRCeXRlKCkse3N0cmVhbUlkOkl9fX0sSS5WaWRlb0JpdHJhdGVSZXF1ZXN0PXtkaXNjcmltaW5hdG9yOjExLGVuY29kZShBKXtjb25zdCBJPWUuQmVib3BWaWV3LmdldEluc3RhbmNlKCk7cmV0dXJuIEkuc3RhcnRXcml0aW5nKCksdGhpcy5lbmNvZGVJbnRvKEEsSSksSS50b0FycmF5KCl9LGVuY29kZUludG8oQSxJKXtjb25zdCBnPUkubGVuZ3RoO3JldHVybiBJLndyaXRlQnl0ZShBLnN0cmVhbUlkKSxJLndyaXRlVWludDMyKEEuYml0c1BlclNlY29uZCksSS5sZW5ndGgtZ30sZGVjb2RlKEEpe2NvbnN0IEk9ZS5CZWJvcFZpZXcuZ2V0SW5zdGFuY2UoKTtyZXR1cm4gSS5zdGFydFJlYWRpbmcoQSksdGhpcy5yZWFkRnJvbShJKX0scmVhZEZyb20oQSl7bGV0IEksZztyZXR1cm4gST1BLnJlYWRCeXRlKCksZz1BLnJlYWRVaW50MzIoKSx7c3RyZWFtSWQ6SSxiaXRzUGVyU2Vjb25kOmd9fX0sSS5Kb2luU3RyZWFtPXtkaXNjcmltaW5hdG9yOjEyLGVuY29kZShBKXtjb25zdCBJPWUuQmVib3BWaWV3LmdldEluc3RhbmNlKCk7cmV0dXJuIEkuc3RhcnRXcml0aW5nKCksdGhpcy5lbmNvZGVJbnRvKEEsSSksSS50b0FycmF5KCl9LGVuY29kZUludG8oQSxJKXtjb25zdCBnPUkubGVuZ3RoO3JldHVybiBJLndyaXRlQnl0ZShBLnN0cmVhbUlkKSxJLmxlbmd0aC1nfSxkZWNvZGUoQSl7Y29uc3QgST1lLkJlYm9wVmlldy5nZXRJbnN0YW5jZSgpO3JldHVybiBJLnN0YXJ0UmVhZGluZyhBKSx0aGlzLnJlYWRGcm9tKEkpfSxyZWFkRnJvbShBKXtsZXQgSTtyZXR1cm4gST1BLnJlYWRCeXRlKCkse3N0cmVhbUlkOkl9fX0sSS5QYXVzZVN0cmVhbT17ZGlzY3JpbWluYXRvcjoxMyxlbmNvZGUoQSl7Y29uc3QgST1lLkJlYm9wVmlldy5nZXRJbnN0YW5jZSgpO3JldHVybiBJLnN0YXJ0V3JpdGluZygpLHRoaXMuZW5jb2RlSW50byhBLEkpLEkudG9BcnJheSgpfSxlbmNvZGVJbnRvKEEsSSl7Y29uc3QgZz1JLmxlbmd0aDtyZXR1cm4gSS53cml0ZUJ5dGUoQS5zdHJlYW1JZCksSS5sZW5ndGgtZ30sZGVjb2RlKEEpe2NvbnN0IEk9ZS5CZWJvcFZpZXcuZ2V0SW5zdGFuY2UoKTtyZXR1cm4gSS5zdGFydFJlYWRpbmcoQSksdGhpcy5yZWFkRnJvbShJKX0scmVhZEZyb20oQSl7bGV0IEk7cmV0dXJuIEk9QS5yZWFkQnl0ZSgpLHtzdHJlYW1JZDpJfX19LEkuUmVqZWN0U3RyZWFtUmVxdWVzdD17ZGlzY3JpbWluYXRvcjoxNCxlbmNvZGUoQSl7Y29uc3QgST1lLkJlYm9wVmlldy5nZXRJbnN0YW5jZSgpO3JldHVybiBJLnN0YXJ0V3JpdGluZygpLHRoaXMuZW5jb2RlSW50byhBLEkpLEkudG9BcnJheSgpfSxlbmNvZGVJbnRvKEEsSSl7Y29uc3QgZz1JLmxlbmd0aDtyZXR1cm4gSS53cml0ZVN0cmluZyhBLnJlYXNvbiksSS5sZW5ndGgtZ30sZGVjb2RlKEEpe2NvbnN0IEk9ZS5CZWJvcFZpZXcuZ2V0SW5zdGFuY2UoKTtyZXR1cm4gSS5zdGFydFJlYWRpbmcoQSksdGhpcy5yZWFkRnJvbShJKX0scmVhZEZyb20oQSl7bGV0IEk7cmV0dXJuIEk9QS5yZWFkU3RyaW5nKCkse3JlYXNvbjpJfX19LEkuSW5wdXRMZXZlbFVwZGF0ZT17ZGlzY3JpbWluYXRvcjoxNSxlbmNvZGUoQSl7Y29uc3QgST1lLkJlYm9wVmlldy5nZXRJbnN0YW5jZSgpO3JldHVybiBJLnN0YXJ0V3JpdGluZygpLHRoaXMuZW5jb2RlSW50byhBLEkpLEkudG9BcnJheSgpfSxlbmNvZGVJbnRvKEEsSSl7Y29uc3QgZz1JLmxlbmd0aDtyZXR1cm4gSS53cml0ZUJ5dGUoQS5zdHJlYW1JZCksSS53cml0ZVVpbnQzMihBLmlucHV0TGV2ZWwpLEkubGVuZ3RoLWd9LGRlY29kZShBKXtjb25zdCBJPWUuQmVib3BWaWV3LmdldEluc3RhbmNlKCk7cmV0dXJuIEkuc3RhcnRSZWFkaW5nKEEpLHRoaXMucmVhZEZyb20oSSl9LHJlYWRGcm9tKEEpe2xldCBJLGc7cmV0dXJuIEk9QS5yZWFkQnl0ZSgpLGc9QS5yZWFkVWludDMyKCkse3N0cmVhbUlkOkksaW5wdXRMZXZlbDpnfX19LEkuSW5wdXRMZXZlbFJlcXVlc3Q9e2Rpc2NyaW1pbmF0b3I6MTYsZW5jb2RlKEEpe2NvbnN0IEk9ZS5CZWJvcFZpZXcuZ2V0SW5zdGFuY2UoKTtyZXR1cm4gSS5zdGFydFdyaXRpbmcoKSx0aGlzLmVuY29kZUludG8oQSxJKSxJLnRvQXJyYXkoKX0sZW5jb2RlSW50byhBLEkpe2NvbnN0IGc9SS5sZW5ndGg7cmV0dXJuIEkud3JpdGVCeXRlKEEuc3RyZWFtSWQpLEkud3JpdGVVaW50MzIoQS5pbnB1dExldmVsKSxJLmxlbmd0aC1nfSxkZWNvZGUoQSl7Y29uc3QgST1lLkJlYm9wVmlldy5nZXRJbnN0YW5jZSgpO3JldHVybiBJLnN0YXJ0UmVhZGluZyhBKSx0aGlzLnJlYWRGcm9tKEkpfSxyZWFkRnJvbShBKXtsZXQgSSxnO3JldHVybiBJPUEucmVhZEJ5dGUoKSxnPUEucmVhZFVpbnQzMigpLHtzdHJlYW1JZDpJLGlucHV0TGV2ZWw6Z319fSxJLkxvZ2ljQm9keT17ZW5jb2RlKEEpe2NvbnN0IEk9ZS5CZWJvcFZpZXcuZ2V0SW5zdGFuY2UoKTtyZXR1cm4gSS5zdGFydFdyaXRpbmcoKSx0aGlzLmVuY29kZUludG8oQSxJKSxJLnRvQXJyYXkoKX0sZW5jb2RlSW50byhBLGcpe2NvbnN0IGU9Zy5sZW5ndGgsQj1nLnJlc2VydmVNZXNzYWdlTGVuZ3RoKCksaT1nLmxlbmd0aCsxO3N3aXRjaChnLndyaXRlQnl0ZShBLmRpc2NyaW1pbmF0b3IpLEEuZGlzY3JpbWluYXRvcil7Y2FzZSAxOkkuRGV2aWNlSW5mby5lbmNvZGVJbnRvKEEudmFsdWUsZyk7YnJlYWs7Y2FzZSAyOkkuQ29kZWNQYWNrUmVxdWVzdC5lbmNvZGVJbnRvKEEudmFsdWUsZyk7YnJlYWs7Y2FzZSAzOkkuQ29kZWNQYWNrUmVzcG9uc2UuZW5jb2RlSW50byhBLnZhbHVlLGcpO2JyZWFrO2Nhc2UgNDpJLkNsaWVudENhcGFiaWxpdGllcy5lbmNvZGVJbnRvKEEudmFsdWUsZyk7YnJlYWs7Y2FzZSA1OkkuRXJyb3JSZXNwb25zZS5lbmNvZGVJbnRvKEEudmFsdWUsZyk7YnJlYWs7Y2FzZSA2OkkuU3RyZWFtUmVxdWVzdC5lbmNvZGVJbnRvKEEudmFsdWUsZyk7YnJlYWs7Y2FzZSA3OkkuU3RyZWFtU3RhcnRpbmcuZW5jb2RlSW50byhBLnZhbHVlLGcpO2JyZWFrO2Nhc2UgODpJLkxlYXZlU3RyZWFtLmVuY29kZUludG8oQS52YWx1ZSxnKTticmVhaztjYXNlIDk6SS5TdHJlYW1TdG9wcGluZy5lbmNvZGVJbnRvKEEudmFsdWUsZyk7YnJlYWs7Y2FzZSAxMDpJLktleWZyYW1lUmVxdWVzdC5lbmNvZGVJbnRvKEEudmFsdWUsZyk7YnJlYWs7Y2FzZSAxMTpJLlZpZGVvQml0cmF0ZVJlcXVlc3QuZW5jb2RlSW50byhBLnZhbHVlLGcpO2JyZWFrO2Nhc2UgMTI6SS5Kb2luU3RyZWFtLmVuY29kZUludG8oQS52YWx1ZSxnKTticmVhaztjYXNlIDEzOkkuUGF1c2VTdHJlYW0uZW5jb2RlSW50byhBLnZhbHVlLGcpO2JyZWFrO2Nhc2UgMTQ6SS5SZWplY3RTdHJlYW1SZXF1ZXN0LmVuY29kZUludG8oQS52YWx1ZSxnKTticmVhaztjYXNlIDE1OkkuSW5wdXRMZXZlbFVwZGF0ZS5lbmNvZGVJbnRvKEEudmFsdWUsZyk7YnJlYWs7Y2FzZSAxNjpJLklucHV0TGV2ZWxSZXF1ZXN0LmVuY29kZUludG8oQS52YWx1ZSxnKX1jb25zdCB0PWcubGVuZ3RoO3JldHVybiBnLmZpbGxNZXNzYWdlTGVuZ3RoKEIsdC1pKSxnLmxlbmd0aC1lfSxkZWNvZGUoQSl7Y29uc3QgST1lLkJlYm9wVmlldy5nZXRJbnN0YW5jZSgpO3JldHVybiBJLnN0YXJ0UmVhZGluZyhBKSx0aGlzLnJlYWRGcm9tKEkpfSxyZWFkRnJvbShBKXtjb25zdCBnPUEucmVhZE1lc3NhZ2VMZW5ndGgoKSxCPUEuaW5kZXgrMStnO3N3aXRjaChBLnJlYWRCeXRlKCkpe2Nhc2UgMTpyZXR1cm57ZGlzY3JpbWluYXRvcjoxLHZhbHVlOkkuRGV2aWNlSW5mby5yZWFkRnJvbShBKX07Y2FzZSAyOnJldHVybntkaXNjcmltaW5hdG9yOjIsdmFsdWU6SS5Db2RlY1BhY2tSZXF1ZXN0LnJlYWRGcm9tKEEpfTtjYXNlIDM6cmV0dXJue2Rpc2NyaW1pbmF0b3I6Myx2YWx1ZTpJLkNvZGVjUGFja1Jlc3BvbnNlLnJlYWRGcm9tKEEpfTtjYXNlIDQ6cmV0dXJue2Rpc2NyaW1pbmF0b3I6NCx2YWx1ZTpJLkNsaWVudENhcGFiaWxpdGllcy5yZWFkRnJvbShBKX07Y2FzZSA1OnJldHVybntkaXNjcmltaW5hdG9yOjUsdmFsdWU6SS5FcnJvclJlc3BvbnNlLnJlYWRGcm9tKEEpfTtjYXNlIDY6cmV0dXJue2Rpc2NyaW1pbmF0b3I6Nix2YWx1ZTpJLlN0cmVhbVJlcXVlc3QucmVhZEZyb20oQSl9O2Nhc2UgNzpyZXR1cm57ZGlzY3JpbWluYXRvcjo3LHZhbHVlOkkuU3RyZWFtU3RhcnRpbmcucmVhZEZyb20oQSl9O2Nhc2UgODpyZXR1cm57ZGlzY3JpbWluYXRvcjo4LHZhbHVlOkkuTGVhdmVTdHJlYW0ucmVhZEZyb20oQSl9O2Nhc2UgOTpyZXR1cm57ZGlzY3JpbWluYXRvcjo5LHZhbHVlOkkuU3RyZWFtU3RvcHBpbmcucmVhZEZyb20oQSl9O2Nhc2UgMTA6cmV0dXJue2Rpc2NyaW1pbmF0b3I6MTAsdmFsdWU6SS5LZXlmcmFtZVJlcXVlc3QucmVhZEZyb20oQSl9O2Nhc2UgMTE6cmV0dXJue2Rpc2NyaW1pbmF0b3I6MTEsdmFsdWU6SS5WaWRlb0JpdHJhdGVSZXF1ZXN0LnJlYWRGcm9tKEEpfTtjYXNlIDEyOnJldHVybntkaXNjcmltaW5hdG9yOjEyLHZhbHVlOkkuSm9pblN0cmVhbS5yZWFkRnJvbShBKX07Y2FzZSAxMzpyZXR1cm57ZGlzY3JpbWluYXRvcjoxMyx2YWx1ZTpJLlBhdXNlU3RyZWFtLnJlYWRGcm9tKEEpfTtjYXNlIDE0OnJldHVybntkaXNjcmltaW5hdG9yOjE0LHZhbHVlOkkuUmVqZWN0U3RyZWFtUmVxdWVzdC5yZWFkRnJvbShBKX07Y2FzZSAxNTpyZXR1cm57ZGlzY3JpbWluYXRvcjoxNSx2YWx1ZTpJLklucHV0TGV2ZWxVcGRhdGUucmVhZEZyb20oQSl9O2Nhc2UgMTY6cmV0dXJue2Rpc2NyaW1pbmF0b3I6MTYsdmFsdWU6SS5JbnB1dExldmVsUmVxdWVzdC5yZWFkRnJvbShBKX07ZGVmYXVsdDp0aHJvdyBBLmluZGV4PUIsbmV3IGUuQmVib3BSdW50aW1lRXJyb3IoXCJVbnJlY29nbml6ZWQgZGlzY3JpbWluYXRvciB3aGlsZSBkZWNvZGluZyBMb2dpY0JvZHlcIil9fX0sKGk9SS5WaWRlb0RhdGFUeXBlfHwoSS5WaWRlb0RhdGFUeXBlPXt9KSlbaS5NZXRhZGF0YT0wXT1cIk1ldGFkYXRhXCIsaVtpLkNsZWFuUG9pbnRGcmFtZT0xXT1cIkNsZWFuUG9pbnRGcmFtZVwiLGlbaS5GcmFtZURpZmY9Ml09XCJGcmFtZURpZmZcIiwoQj1JLkF1ZGlvRGF0YVR5cGV8fChJLkF1ZGlvRGF0YVR5cGU9e30pKVtCLk1ldGFkYXRhPTBdPVwiTWV0YWRhdGFcIixCW0IuRnJhbWU9MV09XCJGcmFtZVwiLEkuRGVza3RvcFJlY3Q9e2VuY29kZShBKXtjb25zdCBJPWUuQmVib3BWaWV3LmdldEluc3RhbmNlKCk7cmV0dXJuIEkuc3RhcnRXcml0aW5nKCksdGhpcy5lbmNvZGVJbnRvKEEsSSksSS50b0FycmF5KCl9LGVuY29kZUludG8oQSxJKXtjb25zdCBnPUkubGVuZ3RoO3JldHVybiBJLndyaXRlSW50MzIoQS5sZWZ0KSxJLndyaXRlSW50MzIoQS50b3ApLEkud3JpdGVVaW50MzIoQS53aWR0aCksSS53cml0ZVVpbnQzMihBLmhlaWdodCksSS5sZW5ndGgtZ30sZGVjb2RlKEEpe2NvbnN0IEk9ZS5CZWJvcFZpZXcuZ2V0SW5zdGFuY2UoKTtyZXR1cm4gSS5zdGFydFJlYWRpbmcoQSksdGhpcy5yZWFkRnJvbShJKX0scmVhZEZyb20oQSl7bGV0IEksZyxlLEI7cmV0dXJuIEk9QS5yZWFkSW50MzIoKSxnPUEucmVhZEludDMyKCksZT1BLnJlYWRVaW50MzIoKSxCPUEucmVhZFVpbnQzMigpLHtsZWZ0OkksdG9wOmcsd2lkdGg6ZSxoZWlnaHQ6Qn19fSxJLlZpZGVvRGF0YT17ZGlzY3JpbWluYXRvcjoxLGVuY29kZShBKXtjb25zdCBJPWUuQmVib3BWaWV3LmdldEluc3RhbmNlKCk7cmV0dXJuIEkuc3RhcnRXcml0aW5nKCksdGhpcy5lbmNvZGVJbnRvKEEsSSksSS50b0FycmF5KCl9LGVuY29kZUludG8oQSxnKXtjb25zdCBlPWcubGVuZ3RoO2cud3JpdGVCeXRlcyhBLmRhdGEpLGcud3JpdGVVaW50NjQoQS5zZWdtZW50VGltZSksZy53cml0ZVVpbnQzMihBLnR5cGUpLGcud3JpdGVCeXRlKEEuc3RyZWFtSWQpLEkuRGVza3RvcFJlY3QuZW5jb2RlSW50byhBLmRlc2t0b3BSZWN0LGcpO3tjb25zdCBlPUEubWFzay5sZW5ndGg7Zy53cml0ZVVpbnQzMihlKTtmb3IobGV0IEI9MDtCPGU7QisrKUkuRGVza3RvcFJlY3QuZW5jb2RlSW50byhBLm1hc2tbQl0sZyl9cmV0dXJuIGcubGVuZ3RoLWV9LGRlY29kZShBKXtjb25zdCBJPWUuQmVib3BWaWV3LmdldEluc3RhbmNlKCk7cmV0dXJuIEkuc3RhcnRSZWFkaW5nKEEpLHRoaXMucmVhZEZyb20oSSl9LHJlYWRGcm9tKEEpe2xldCBnLGUsQixpLHQsUTtnPUEucmVhZEJ5dGVzKCksZT1BLnJlYWRVaW50NjQoKSxCPUEucmVhZFVpbnQzMigpLGk9QS5yZWFkQnl0ZSgpLHQ9SS5EZXNrdG9wUmVjdC5yZWFkRnJvbShBKTt7bGV0IGc9QS5yZWFkVWludDMyKCk7UT1uZXcgQXJyYXkoZyk7Zm9yKGxldCBlPTA7ZTxnO2UrKyl7bGV0IGc7Zz1JLkRlc2t0b3BSZWN0LnJlYWRGcm9tKEEpLFFbZV09Z319cmV0dXJue2RhdGE6ZyxzZWdtZW50VGltZTplLHR5cGU6QixzdHJlYW1JZDppLGRlc2t0b3BSZWN0OnQsbWFzazpRfX19LEkuUG9pbnRlckRhdGE9e2Rpc2NyaW1pbmF0b3I6MixlbmNvZGUoQSl7Y29uc3QgST1lLkJlYm9wVmlldy5nZXRJbnN0YW5jZSgpO3JldHVybiBJLnN0YXJ0V3JpdGluZygpLHRoaXMuZW5jb2RlSW50byhBLEkpLEkudG9BcnJheSgpfSxlbmNvZGVJbnRvKEEsSSl7Y29uc3QgZz1JLmxlbmd0aDtyZXR1cm4gSS53cml0ZUJ5dGVzKEEuZGF0YSksSS53cml0ZVVpbnQzMihBLm1vbml0b3JXaWR0aCksSS53cml0ZVVpbnQzMihBLm1vbml0b3JIZWlnaHQpLEkud3JpdGVVaW50MzIoQS5zaGFwZVdpZHRoKSxJLndyaXRlVWludDMyKEEuc2hhcGVIZWlnaHQpLEkud3JpdGVJbnQzMihBLnNwb3RYKSxJLndyaXRlSW50MzIoQS5zcG90WSksSS53cml0ZUJ5dGUoTnVtYmVyKEEudmlzaWJsZSkpLEkud3JpdGVJbnQzMihBLnBvc2l0aW9uWCksSS53cml0ZUludDMyKEEucG9zaXRpb25ZKSxJLndyaXRlQnl0ZShBLnN0cmVhbUlkKSxJLmxlbmd0aC1nfSxkZWNvZGUoQSl7Y29uc3QgST1lLkJlYm9wVmlldy5nZXRJbnN0YW5jZSgpO3JldHVybiBJLnN0YXJ0UmVhZGluZyhBKSx0aGlzLnJlYWRGcm9tKEkpfSxyZWFkRnJvbShBKXtsZXQgSSxnLGUsQixpLHQsUSxDLEUsbyxhO3JldHVybiBJPUEucmVhZEJ5dGVzKCksZz1BLnJlYWRVaW50MzIoKSxlPUEucmVhZFVpbnQzMigpLEI9QS5yZWFkVWludDMyKCksaT1BLnJlYWRVaW50MzIoKSx0PUEucmVhZEludDMyKCksUT1BLnJlYWRJbnQzMigpLEM9ISFBLnJlYWRCeXRlKCksRT1BLnJlYWRJbnQzMigpLG89QS5yZWFkSW50MzIoKSxhPUEucmVhZEJ5dGUoKSx7ZGF0YTpJLG1vbml0b3JXaWR0aDpnLG1vbml0b3JIZWlnaHQ6ZSxzaGFwZVdpZHRoOkIsc2hhcGVIZWlnaHQ6aSxzcG90WDp0LHNwb3RZOlEsdmlzaWJsZTpDLHBvc2l0aW9uWDpFLHBvc2l0aW9uWTpvLHN0cmVhbUlkOmF9fX0sSS5BdWRpb0RhdGE9e2Rpc2NyaW1pbmF0b3I6MyxlbmNvZGUoQSl7Y29uc3QgST1lLkJlYm9wVmlldy5nZXRJbnN0YW5jZSgpO3JldHVybiBJLnN0YXJ0V3JpdGluZygpLHRoaXMuZW5jb2RlSW50byhBLEkpLEkudG9BcnJheSgpfSxlbmNvZGVJbnRvKEEsSSl7Y29uc3QgZz1JLmxlbmd0aDtyZXR1cm4gSS53cml0ZUJ5dGVzKEEuZGF0YSksSS53cml0ZVVpbnQzMihBLnR5cGUpLEkud3JpdGVCeXRlKEEuc3RyZWFtSWQpLEkubGVuZ3RoLWd9LGRlY29kZShBKXtjb25zdCBJPWUuQmVib3BWaWV3LmdldEluc3RhbmNlKCk7cmV0dXJuIEkuc3RhcnRSZWFkaW5nKEEpLHRoaXMucmVhZEZyb20oSSl9LHJlYWRGcm9tKEEpe2xldCBJLGcsZTtyZXR1cm4gST1BLnJlYWRCeXRlcygpLGc9QS5yZWFkVWludDMyKCksZT1BLnJlYWRCeXRlKCkse2RhdGE6SSx0eXBlOmcsc3RyZWFtSWQ6ZX19fSxJLk1lZGlhQ2h1bms9e2Rpc2NyaW1pbmF0b3I6NCxlbmNvZGUoQSl7Y29uc3QgST1lLkJlYm9wVmlldy5nZXRJbnN0YW5jZSgpO3JldHVybiBJLnN0YXJ0V3JpdGluZygpLHRoaXMuZW5jb2RlSW50byhBLEkpLEkudG9BcnJheSgpfSxlbmNvZGVJbnRvKEEsZyl7Y29uc3QgZT1nLmxlbmd0aDtyZXR1cm4gSS5DaHVuay5lbmNvZGVJbnRvKEEuY2h1bmssZyksZy5sZW5ndGgtZX0sZGVjb2RlKEEpe2NvbnN0IEk9ZS5CZWJvcFZpZXcuZ2V0SW5zdGFuY2UoKTtyZXR1cm4gSS5zdGFydFJlYWRpbmcoQSksdGhpcy5yZWFkRnJvbShJKX0scmVhZEZyb20oQSl7bGV0IGc7cmV0dXJuIGc9SS5DaHVuay5yZWFkRnJvbShBKSx7Y2h1bms6Z319fSxJLk1lZGlhQm9keT17ZW5jb2RlKEEpe2NvbnN0IEk9ZS5CZWJvcFZpZXcuZ2V0SW5zdGFuY2UoKTtyZXR1cm4gSS5zdGFydFdyaXRpbmcoKSx0aGlzLmVuY29kZUludG8oQSxJKSxJLnRvQXJyYXkoKX0sZW5jb2RlSW50byhBLGcpe2NvbnN0IGU9Zy5sZW5ndGgsQj1nLnJlc2VydmVNZXNzYWdlTGVuZ3RoKCksaT1nLmxlbmd0aCsxO3N3aXRjaChnLndyaXRlQnl0ZShBLmRpc2NyaW1pbmF0b3IpLEEuZGlzY3JpbWluYXRvcil7Y2FzZSAxOkkuVmlkZW9EYXRhLmVuY29kZUludG8oQS52YWx1ZSxnKTticmVhaztjYXNlIDI6SS5Qb2ludGVyRGF0YS5lbmNvZGVJbnRvKEEudmFsdWUsZyk7YnJlYWs7Y2FzZSAzOkkuQXVkaW9EYXRhLmVuY29kZUludG8oQS52YWx1ZSxnKTticmVhaztjYXNlIDQ6SS5NZWRpYUNodW5rLmVuY29kZUludG8oQS52YWx1ZSxnKX1jb25zdCB0PWcubGVuZ3RoO3JldHVybiBnLmZpbGxNZXNzYWdlTGVuZ3RoKEIsdC1pKSxnLmxlbmd0aC1lfSxkZWNvZGUoQSl7Y29uc3QgST1lLkJlYm9wVmlldy5nZXRJbnN0YW5jZSgpO3JldHVybiBJLnN0YXJ0UmVhZGluZyhBKSx0aGlzLnJlYWRGcm9tKEkpfSxyZWFkRnJvbShBKXtjb25zdCBnPUEucmVhZE1lc3NhZ2VMZW5ndGgoKSxCPUEuaW5kZXgrMStnO3N3aXRjaChBLnJlYWRCeXRlKCkpe2Nhc2UgMTpyZXR1cm57ZGlzY3JpbWluYXRvcjoxLHZhbHVlOkkuVmlkZW9EYXRhLnJlYWRGcm9tKEEpfTtjYXNlIDI6cmV0dXJue2Rpc2NyaW1pbmF0b3I6Mix2YWx1ZTpJLlBvaW50ZXJEYXRhLnJlYWRGcm9tKEEpfTtjYXNlIDM6cmV0dXJue2Rpc2NyaW1pbmF0b3I6Myx2YWx1ZTpJLkF1ZGlvRGF0YS5yZWFkRnJvbShBKX07Y2FzZSA0OnJldHVybntkaXNjcmltaW5hdG9yOjQsdmFsdWU6SS5NZWRpYUNodW5rLnJlYWRGcm9tKEEpfTtkZWZhdWx0OnRocm93IEEuaW5kZXg9QixuZXcgZS5CZWJvcFJ1bnRpbWVFcnJvcihcIlVucmVjb2duaXplZCBkaXNjcmltaW5hdG9yIHdoaWxlIGRlY29kaW5nIE1lZGlhQm9keVwiKX19fX0sMTQ6ZnVuY3Rpb24oQSxJLGcpe1widXNlIHN0cmljdFwiO3ZhciBlPXRoaXMmJnRoaXMuX19jcmVhdGVCaW5kaW5nfHwoT2JqZWN0LmNyZWF0ZT9mdW5jdGlvbihBLEksZyxlKXt2b2lkIDA9PT1lJiYoZT1nKSxPYmplY3QuZGVmaW5lUHJvcGVydHkoQSxlLHtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiBJW2ddfX0pfTpmdW5jdGlvbihBLEksZyxlKXt2b2lkIDA9PT1lJiYoZT1nKSxBW2VdPUlbZ119KSxCPXRoaXMmJnRoaXMuX19leHBvcnRTdGFyfHxmdW5jdGlvbihBLEkpe2Zvcih2YXIgZyBpbiBBKVwiZGVmYXVsdFwiPT09Z3x8T2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKEksZyl8fGUoSSxBLGcpfTtPYmplY3QuZGVmaW5lUHJvcGVydHkoSSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxJLlJhaW53YXlFcnJvcj1JLkhlbGRLZXlzPUkuSW5wdXRUeXBlPUkuUmFpbndheVN0cmVhbUZpdD1JLlJhaW53YXlTdHJlYW09SS5SYWlud2F5UnVudGltZT1JLlJhaW53YXlUcmFuc3BvcnRTdGF0dXM9SS5SYWlud2F5VHJhbnNwb3J0PUkuUlRDVHJhbnNwb3J0PUkuZnJpZW5kbHlHYW1lcGFkTmFtZT1JLlJhaW53YXlMb2dMZXZlbD1JLlJhaW53YXlMb2dnaW5nPUkuUmFpbndheUNoYW5uZWxNb2RlPUkuUmFpbndheVBlZXI9SS5SYWlud2F5UGVlclN0YXRlPXZvaWQgMDt2YXIgaT1nKDc4Myk7T2JqZWN0LmRlZmluZVByb3BlcnR5KEksXCJSYWlud2F5UGVlclN0YXRlXCIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGkuUmFpbndheVBlZXJTdGF0ZX19KTt2YXIgdD1nKDQyMCk7T2JqZWN0LmRlZmluZVByb3BlcnR5KEksXCJSYWlud2F5UGVlclwiLHtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiB0LlJhaW53YXlQZWVyfX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShJLFwiUmFpbndheUNoYW5uZWxNb2RlXCIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHQuUmFpbndheUNoYW5uZWxNb2RlfX0pO3ZhciBRPWcoNDY0KTtPYmplY3QuZGVmaW5lUHJvcGVydHkoSSxcIlJhaW53YXlMb2dnaW5nXCIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIFEuUmFpbndheUxvZ2dpbmd9fSksT2JqZWN0LmRlZmluZVByb3BlcnR5KEksXCJSYWlud2F5TG9nTGV2ZWxcIix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gUS5SYWlud2F5TG9nTGV2ZWx9fSk7dmFyIEM9Zyg5OSk7T2JqZWN0LmRlZmluZVByb3BlcnR5KEksXCJmcmllbmRseUdhbWVwYWROYW1lXCIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIEMuZnJpZW5kbHlHYW1lcGFkTmFtZX19KTt2YXIgRT1nKDE0NSk7T2JqZWN0LmRlZmluZVByb3BlcnR5KEksXCJSVENUcmFuc3BvcnRcIix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gRS5SVENUcmFuc3BvcnR9fSk7dmFyIG89Zyg5KTtPYmplY3QuZGVmaW5lUHJvcGVydHkoSSxcIlJhaW53YXlUcmFuc3BvcnRcIix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gby5SYWlud2F5VHJhbnNwb3J0fX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShJLFwiUmFpbndheVRyYW5zcG9ydFN0YXR1c1wiLHtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiBvLlJhaW53YXlUcmFuc3BvcnRTdGF0dXN9fSk7dmFyIGE9Zyg3ODMpO09iamVjdC5kZWZpbmVQcm9wZXJ0eShJLFwiUmFpbndheVJ1bnRpbWVcIix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gYS5SYWlud2F5UnVudGltZX19KTt2YXIgbj1nKDg3Nik7T2JqZWN0LmRlZmluZVByb3BlcnR5KEksXCJSYWlud2F5U3RyZWFtXCIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIG4uUmFpbndheVN0cmVhbX19KTt2YXIgcz1nKDQyNSk7T2JqZWN0LmRlZmluZVByb3BlcnR5KEksXCJSYWlud2F5U3RyZWFtRml0XCIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHMuUmFpbndheVN0cmVhbUZpdH19KTt2YXIgcj1nKDg4NCk7T2JqZWN0LmRlZmluZVByb3BlcnR5KEksXCJJbnB1dFR5cGVcIix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gci5JbnB1dFR5cGV9fSksT2JqZWN0LmRlZmluZVByb3BlcnR5KEksXCJIZWxkS2V5c1wiLHtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiByLkhlbGRLZXlzfX0pO3ZhciBkPWcoOTk0KTtPYmplY3QuZGVmaW5lUHJvcGVydHkoSSxcIlJhaW53YXlFcnJvclwiLHtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiBkLlJhaW53YXlFcnJvcn19KSxCKGcoOTA0KSxJKX0sNjU6KEEsSSk9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkoSSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxJLlJhaW53YXlDdXJzb3JQYWludGVyPXZvaWQgMCxJLlJhaW53YXlDdXJzb3JQYWludGVyPWNsYXNze2NvbnN0cnVjdG9yKEEsSSxnLGU9MTAwKXt0aGlzLmNvcnJlY3RSZW1vdGVDdXJzb3I9QSx0aGlzLnRyYW5zZm9ybVBvaW50ZXJPZmZzZXRUb1JlbW90ZT1JLHRoaXMuZ2V0Q3VycmVudEZyYW1lU2l6ZT1nLHRoaXMuY3Vyc29yU3luY0ludGVydmFsPWUsdGhpcy5jb250YWluZXI9dm9pZCAwLHRoaXMudmlkZW89dm9pZCAwLHRoaXMuY2FudmFzPXZvaWQgMCx0aGlzLmN1cnNvckRpdj12b2lkIDAsdGhpcy5jdXJzb3JJbWc9dm9pZCAwLHRoaXMuY3Vyc29yU3RhdGU9e3Zpc2libGU6ITEseDowLHk6MCxzcG90WDowLHNwb3RZOjAsZXh0ZW50V2lkdGg6MCxleHRlbnRIZWlnaHQ6MH0sdGhpcy53YW50c1JlbW90ZVBvc2l0aW9uPSEwLHRoaXMudmlkZW9SZWN0PW5ldyBET01SZWN0KDAsMCwwLDApLHRoaXMud2luZG93V2lkdGg9dm9pZCAwLHRoaXMud2luZG93SGVpZ2h0PXZvaWQgMCx0aGlzLmRyYXdEZWJ1Z0RvdD0hMSx0aGlzLmRlYnVnRG90PXZvaWQgMCx0aGlzLnNldFZpZGVvRGltZW5zaW9ucz0oKT0+e2Zvcihjb25zdCBBIG9mW3RoaXMudmlkZW8sdGhpcy5jYW52YXNdKXtpZighQSljb250aW51ZTtjb25zdCBJPUEuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7aWYoSS53aWR0aD4wJiZJLmhlaWdodD4wKXJldHVybiB0aGlzLnZpZGVvUmVjdD1JLHZvaWQgdGhpcy5hcHBseUN1cnNvckRpdlRyYW5zZm9ybSgpfX0sdGhpcy5jdXJzb3JTeW5jQ291bnRlcj10aGlzLmN1cnNvclN5bmNJbnRlcnZhbCx0aGlzLnZpZGVvUmVzaXplT2JzZXJ2ZXI9bmV3IFJlc2l6ZU9ic2VydmVyKCgoKT0+e3RoaXMuc2V0VmlkZW9EaW1lbnNpb25zKCl9KSksW1wid2Via2l0ZnVsbHNjcmVlbmNoYW5nZVwiLFwibW96ZnVsbHNjcmVlbmNoYW5nZVwiLFwiZnVsbHNjcmVlbmNoYW5nZVwiLFwiTVNGdWxsc2NyZWVuQ2hhbmdlXCJdLmZvckVhY2goKEE9Pntkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKEEsdGhpcy5zZXRWaWRlb0RpbWVuc2lvbnMsITEpfSkpLHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicmVzaXplXCIsdGhpcy5zZXRXaW5kb3dEaW1lbnNpb25zKX1kZXRhY2goKXtbXCJ3ZWJraXRmdWxsc2NyZWVuY2hhbmdlXCIsXCJtb3pmdWxsc2NyZWVuY2hhbmdlXCIsXCJmdWxsc2NyZWVuY2hhbmdlXCIsXCJNU0Z1bGxzY3JlZW5DaGFuZ2VcIl0uZm9yRWFjaCgoQT0+e2RvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoQSx0aGlzLnNldFZpZGVvRGltZW5zaW9ucywhMSl9KSksd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIix0aGlzLnNldFdpbmRvd0RpbWVuc2lvbnMpLHRoaXMudmlkZW9SZXNpemVPYnNlcnZlci5kaXNjb25uZWN0KCl9c2V0V2luZG93RGltZW5zaW9ucygpe3RoaXMud2luZG93V2lkdGg9d2luZG93LmlubmVyV2lkdGgsdGhpcy53aW5kb3dIZWlnaHQ9d2luZG93LmlubmVySGVpZ2h0fXNldENvbnRhaW5lcihBKXt0aGlzLmNvbnRhaW5lcj1BLEEuc3R5bGUub3ZlcmZsb3c9XCJoaWRkZW5cIix0aGlzLnZpZGVvJiZ0aGlzLnZpZGVvUmVzaXplT2JzZXJ2ZXIudW5vYnNlcnZlKHRoaXMudmlkZW8pLHRoaXMuY2FudmFzJiZ0aGlzLnZpZGVvUmVzaXplT2JzZXJ2ZXIudW5vYnNlcnZlKHRoaXMuY2FudmFzKSx0aGlzLmN1cnNvckRpdj12b2lkIDA7Y29uc3QgST1BLmNoaWxkTm9kZXM7Zm9yKGxldCBBPTA7QTxJLmxlbmd0aDtBKyspe2NvbnN0IGc9SVtBXTtnIGluc3RhbmNlb2YgSFRNTFZpZGVvRWxlbWVudD8odGhpcy52aWRlbz1nLHRoaXMuc2V0VmlkZW9EaW1lbnNpb25zKCksdGhpcy52aWRlb1Jlc2l6ZU9ic2VydmVyLm9ic2VydmUodGhpcy52aWRlbykpOmcgaW5zdGFuY2VvZiBIVE1MQ2FudmFzRWxlbWVudCYmKGcuY2xhc3NMaXN0LmNvbnRhaW5zKFwicmFpbndheS1jYW52YXNcIil8fGcuY2xhc3NMaXN0LmNvbnRhaW5zKFwicmFpbndheS1pc29sYXRpb24tY2FudmFzXCIpKT8odGhpcy5jYW52YXM9Zyx0aGlzLnNldFZpZGVvRGltZW5zaW9ucygpLHRoaXMudmlkZW9SZXNpemVPYnNlcnZlci5vYnNlcnZlKHRoaXMuY2FudmFzKSk6ZyBpbnN0YW5jZW9mIEhUTUxEaXZFbGVtZW50JiYoZy5jbGFzc05hbWUuaW5jbHVkZXMoXCJyYWlud2F5LWN1cnNvclwiKT90aGlzLmN1cnNvckRpdj1nOmcuY2xhc3NOYW1lLmluY2x1ZGVzKFwicmFpbndheS1kZWJ1Zy1kb3RcIikmJih0aGlzLmRlYnVnRG90PWcpKX10aGlzLmN1cnNvckRpdnx8KHRoaXMuY3Vyc29yRGl2PWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiksdGhpcy5jdXJzb3JEaXYuY2xhc3NOYW1lPVwicmFpbndheS1jdXJzb3JcIix0aGlzLmN1cnNvckRpdi5zdHlsZS5wb3NpdGlvbj1cImFic29sdXRlXCIsdGhpcy5jdXJzb3JEaXYuc3R5bGUudG9wPVwiMHB4XCIsdGhpcy5jdXJzb3JEaXYuc3R5bGUubGVmdD1cIjBweFwiLHRoaXMuY3Vyc29yRGl2LnN0eWxlLnpJbmRleD1cIjFcIix0aGlzLmN1cnNvckRpdi5zdHlsZS5wb2ludGVyRXZlbnRzPVwibm9uZVwiLHRoaXMuY3Vyc29yRGl2LnN0eWxlLndpbGxDaGFuZ2U9XCJ0cmFuc2Zvcm1cIix0aGlzLmN1cnNvckRpdi5zdHlsZS50cmFuc2Zvcm1PcmlnaW49XCJ0b3AgbGVmdFwiLHRoaXMuYXBwbHlDdXJzb3JEaXZUcmFuc2Zvcm0oKSx0aGlzLmN1cnNvckltZz1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW1nXCIpLHRoaXMuY3Vyc29yRGl2LmFwcGVuZENoaWxkKHRoaXMuY3Vyc29ySW1nKSxBLmFwcGVuZENoaWxkKHRoaXMuY3Vyc29yRGl2KSksdGhpcy5kcmF3RGVidWdEb3QmJiF0aGlzLmRlYnVnRG90JiYodGhpcy5kZWJ1Z0RvdD1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpLHRoaXMuZGVidWdEb3QuY2xhc3NOYW1lPVwicmFpbndheS1kZWJ1Zy1kb3RcIix0aGlzLmRlYnVnRG90LnN0eWxlLnBvc2l0aW9uPVwiYWJzb2x1dGVcIix0aGlzLmRlYnVnRG90LnN0eWxlLnRvcD1cIjBweFwiLHRoaXMuZGVidWdEb3Quc3R5bGUubGVmdD1cIjBweFwiLHRoaXMuZGVidWdEb3Quc3R5bGUuekluZGV4PVwiMVwiLHRoaXMuZGVidWdEb3Quc3R5bGUucG9pbnRlckV2ZW50cz1cIm5vbmVcIix0aGlzLmRlYnVnRG90LnN0eWxlLndpbGxDaGFuZ2U9XCJ0cmFuc2Zvcm1cIix0aGlzLmRlYnVnRG90LnN0eWxlLnRyYW5zZm9ybU9yaWdpbj1cInRvcCBsZWZ0XCIsdGhpcy5kZWJ1Z0RvdC5zdHlsZS53aWR0aD1cIjNweFwiLHRoaXMuZGVidWdEb3Quc3R5bGUuaGVpZ2h0PVwiM3B4XCIsdGhpcy5kZWJ1Z0RvdC5zdHlsZS5iYWNrZ3JvdW5kQ29sb3I9XCIjZmYwMDAwXCIsQS5hcHBlbmRDaGlsZCh0aGlzLmRlYnVnRG90KSl9dW5zZXRDb250YWluZXIoKXt2YXIgQSxJO3RoaXMuZGV0YWNoKCksbnVsbD09PShBPXRoaXMuY3Vyc29yRGl2KXx8dm9pZCAwPT09QXx8QS5yZW1vdmUoKSxudWxsPT09KEk9dGhpcy5kZWJ1Z0RvdCl8fHZvaWQgMD09PUl8fEkucmVtb3ZlKCksdGhpcy5jb250YWluZXI9dm9pZCAwfWNvbXB1dGVUcmFuc2Zvcm0oQSl7dmFyIEksZztjb25zdHt4OmUseTpCLHNwb3RYOmksc3BvdFk6dH09QSxRPXtsZWZ0OjAsdG9wOjAsd2lkdGg6QS5leHRlbnRXaWR0aCxoZWlnaHQ6QS5leHRlbnRIZWlnaHR9LHt3aWR0aDpDLGhlaWdodDpFfT10aGlzLnZpZGVvUmVjdCxvPXRoaXMuZ2V0Q3VycmVudEZyYW1lU2l6ZSgpLGE9by5jb2RlY1dpZHRoLG49by5jb2RlY0hlaWdodCxzPW51bGwhPT0oST1vLnN0cmVhbUJvdW5kcykmJnZvaWQgMCE9PUk/STpRLHI9bnVsbCE9PShnPW8uZnVsbERlc2t0b3BCb3VuZHMpJiZ2b2lkIDAhPT1nP2c6USx7bGVmdDpkLHRvcDpoLHdpZHRoOmMsaGVpZ2h0OkR9PXIse2xlZnQ6dyx0b3A6dSx3aWR0aDp5LGhlaWdodDpsfT1zLFM9eSphL2MsRj1sKm4vRCxSPU1hdGgubWluKEMvUyxFL0YpLEc9TWF0aC5yb3VuZChlLWktKHctZCkpLGs9TWF0aC5yb3VuZChCLXQtKHUtaCkpLHA9UiphL2MsVT1SKm4vRDtyZXR1cm5gdHJhbnNsYXRlKCR7TWF0aC5yb3VuZCgoQy1SKlMpLzIpfXB4LCR7TWF0aC5yb3VuZCgoRS1SKkYpLzIpfXB4KSBzY2FsZSgke3B9LCR7VX0pIHRyYW5zbGF0ZSgke0d9cHgsJHtrfXB4KWB9YXBwbHlDdXJzb3JEaXZUcmFuc2Zvcm0oKXt0aGlzLmN1cnNvckRpdiYmKHRoaXMuY3Vyc29yU3RhdGUudmlzaWJsZT8odGhpcy5jdXJzb3JEaXYuc3R5bGUudmlzaWJpbGl0eT1cInZpc2libGVcIix0aGlzLmN1cnNvckRpdi5zdHlsZS50cmFuc2Zvcm09dGhpcy5jb21wdXRlVHJhbnNmb3JtKHRoaXMuY3Vyc29yU3RhdGUpKTp0aGlzLmN1cnNvckRpdi5zdHlsZS52aXNpYmlsaXR5PVwiaGlkZGVuXCIpfW1vdmVEZWJ1Z0RvdFRvKEEpe3RoaXMuZGVidWdEb3QmJih0aGlzLmRlYnVnRG90LnN0eWxlLnRyYW5zZm9ybT10aGlzLmNvbXB1dGVUcmFuc2Zvcm0oQSkpfXByb2Nlc3NDdXJzb3IoQSl7aWYodGhpcy5jdXJzb3JEaXYpaWYoQS52aXNpYmxlJiYhdGhpcy5jdXJzb3JTdGF0ZS52aXNpYmxlJiYodGhpcy53YW50c1JlbW90ZVBvc2l0aW9uPSEwKSx0aGlzLmN1cnNvclN0YXRlLnZpc2libGU9QS52aXNpYmxlLHRoaXMuY3Vyc29yU3RhdGUuc3BvdFg9QS5zcG90WCx0aGlzLmN1cnNvclN0YXRlLnNwb3RZPUEuc3BvdFksdGhpcy5jdXJzb3JTdGF0ZS5leHRlbnRXaWR0aD1BLmV4dGVudFdpZHRoLHRoaXMuY3Vyc29yU3RhdGUuZXh0ZW50SGVpZ2h0PUEuZXh0ZW50SGVpZ2h0LHRoaXMuZHJhd0RlYnVnRG90JiZ0aGlzLm1vdmVEZWJ1Z0RvdFRvKEEpLHRoaXMuY3Vyc29yU3RhdGUudmlzaWJsZSl7aWYodGhpcy53YW50c1JlbW90ZVBvc2l0aW9uPyh0aGlzLmN1cnNvclN0YXRlLng9QS54LHRoaXMuY3Vyc29yU3RhdGUueT1BLnksdGhpcy53YW50c1JlbW90ZVBvc2l0aW9uPSExLHRoaXMuY3Vyc29yU3luY0NvdW50ZXI9dGhpcy5jdXJzb3JTeW5jSW50ZXJ2YWwpOjA9PS0tdGhpcy5jdXJzb3JTeW5jQ291bnRlciYmKHRoaXMuY29ycmVjdFJlbW90ZUN1cnNvcih0aGlzLmN1cnNvclN0YXRlLngsdGhpcy5jdXJzb3JTdGF0ZS55KSx0aGlzLmN1cnNvclN5bmNDb3VudGVyPXRoaXMuY3Vyc29yU3luY0ludGVydmFsKSx0aGlzLmN1cnNvckRpdi5zdHlsZS53aWR0aD1gJHtBLnNoYXBlV2lkdGh9cHhgLHRoaXMuY3Vyc29yRGl2LnN0eWxlLmhlaWdodD1gJHtBLnNoYXBlSGVpZ2h0fXB4YCxBLmhhc1BvaW50ZXJJbWFnZSYmdGhpcy5jdXJzb3JJbWcpe2NvbnN0IEk9ZnVuY3Rpb24oQSl7bGV0IEk9XCJcIjtjb25zdCBnPW5ldyBVaW50OEFycmF5KEEpLGU9Zy5ieXRlTGVuZ3RoO2ZvcihsZXQgQT0wO0E8ZTtBKyspSSs9U3RyaW5nLmZyb21DaGFyQ29kZShnW0FdKTtyZXR1cm4gd2luZG93LmJ0b2EoSSl9KEEucG9pbnRlckltYWdlKTt0aGlzLmN1cnNvckltZy5zcmM9YGRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCwke0l9YH10aGlzLmFwcGx5Q3Vyc29yRGl2VHJhbnNmb3JtKCl9ZWxzZSB0aGlzLmN1cnNvckRpdi5zdHlsZS52aXNpYmlsaXR5PVwiaGlkZGVuXCJ9dXBkYXRlKEEsSSxnKXt2YXIgZTtpZih0aGlzLmN1cnNvckRpdiYmKFwicG9pbnRlcm1vdmVcIj09PUEudHlwZXx8XCJtb3VzZW1vdmVcIj09PUEudHlwZSkpe2lmKFwibW91c2VcIiE9PShudWxsIT09KGU9QS5wb2ludGVyVHlwZSkmJnZvaWQgMCE9PWU/ZTpcIm1vdXNlXCIpKXtjb25zdCBBPXRoaXMudHJhbnNmb3JtUG9pbnRlck9mZnNldFRvUmVtb3RlKEksZyk7QSYmKHRoaXMuY3Vyc29yU3RhdGUueD1BLngsdGhpcy5jdXJzb3JTdGF0ZS55PUEueSl9ZWxzZXtjb25zdCBJPXRoaXMuY3Vyc29yU3RhdGUsZz1BLm1vdmVtZW50WCxlPUEubW92ZW1lbnRZLEI9dGhpcy5nZXRDdXJyZW50RnJhbWVTaXplKCk7aWYoQi5zdHJlYW1Cb3VuZHMpe2NvbnN0e3RvcDpBLGxlZnQ6aSxoZWlnaHQ6dCx3aWR0aDpRfT1CLnN0cmVhbUJvdW5kczt0aGlzLmN1cnNvclN0YXRlLng9TWF0aC5tYXgoaSxNYXRoLm1pbihJLngrZyxpK1EpKSx0aGlzLmN1cnNvclN0YXRlLnk9TWF0aC5tYXgoQSxNYXRoLm1pbihJLnkrZSxBK3QpKX1lbHNlIGNvbnNvbGUud2FybihcIkRvbid0IGhhdmUgc3RyZWFtQm91bmRzIGluIEN1cnNvclBhaW50ZXIudXBkYXRlP1wiKSx0aGlzLmN1cnNvclN0YXRlLng9TWF0aC5tYXgoMCxNYXRoLm1pbihJLngrZyxJLmV4dGVudFdpZHRoKSksdGhpcy5jdXJzb3JTdGF0ZS55PU1hdGgubWF4KDAsTWF0aC5taW4oSS55K2UsSS5leHRlbnRIZWlnaHQpKX10aGlzLmFwcGx5Q3Vyc29yRGl2VHJhbnNmb3JtKCl9fX19LDk5OihBLEkpPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KEksXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksSS5mcmllbmRseUdhbWVwYWROYW1lPXZvaWQgMDtjb25zdCBnPXtcIjA1NGNcIjp7XCIwMjY4XCI6XCJEdWFsU2hvY2sgM1wiLFwiMDVjNFwiOlwiRHVhbFNob2NrIDRcIixcIjA5Y2NcIjpcIkR1YWxTaG9jayA0ICgybmQgR2VuKVwifSxcIjJkYzhcIjp7NjEwMTpcIk4zMCBQcm9cIn0sXCIwOTU1XCI6e2I0MDA6XCJOVklESUEgU2hpZWxkXCJ9LDI1NjM6e1wiMDUyM1wiOlwiU2hhbldhbiBQUzMgQ29udHJvbGxlclwifSxcIjA0NWVcIjp7XCIwMmQxXCI6XCJYYm94IE9uZSBDb250cm9sbGVyXCIsXCIwMmRkXCI6XCJYYm94IE9uZSBDb250cm9sbGVyIChGaXJtd2FyZSAyMDE1KVwiLFwiMDJlM1wiOlwiWGJveCBPbmUgRWxpdGUgQ29udHJvbGxlclwiLFwiMDJlYVwiOlwiWGJveCBPbmUgUyBDb250cm9sbGVyXCIsXCIwMmZkXCI6XCJYYm94IE9uZSBTIENvbnRyb2xsZXIgKEJsdWV0b290aClcIixcIjAyOGZcIjpcIlhib3gzNjAgV2lyZWxlc3MgQ29udHJvbGxlclwiLFwiMDI4ZVwiOlwiWGJveDM2MCBDb250cm9sbGVyXCIsXCIwMjg5XCI6XCJYYm94IENvbnRyb2xsZXIgU1wiLFwiMDI4NVwiOlwiWGJveCBDb250cm9sbGVyIFNcIixcIjAyMDJcIjpcIlhib3ggQ29udHJvbGxlclwifSxcIjA0NmRcIjp7YzI5OTpcIkcyNSBSYWNpbmcgV2hlZWxcIixjMjlCOlwiRzI3IFJhY2luZyBXaGVlbFwiLGNhYTM6XCJEcml2ZUZYIFJhY2luZyBXaGVlbFwiLGMyOTU6XCJNb21vIEZvcmNlIFN0ZWVyaW5nIFdoZWVsXCIsYzI5ODpcIkRyaXZpbmcgRm9yY2UgUHJvXCJ9fTtJLmZyaWVuZGx5R2FtZXBhZE5hbWU9ZnVuY3Rpb24oQSxJKXt2YXIgZSxCLGksdDtjb25zdCBRPUEuaWQuc3BsaXQoXCIoXCIpWzBdLnRyaW0oKXx8XCJVbmtub3duIGdhbWVwYWRcIixDPUEuaWQubWF0Y2goL1xcYihbMC05YS1mXXs0fSlcXGIuKlxcYihbMC05YS1mXXs0fSlcXGIvKTtpZighQylyZXR1cm4gUTtjb25zdCBFPUNbMV0sbz1DWzJdO3JldHVybiBudWxsIT09KHQ9bnVsbCE9PShCPW51bGw9PT0oZT1udWxsPT1JP3ZvaWQgMDpJW0VdKXx8dm9pZCAwPT09ZT92b2lkIDA6ZVtvXSkmJnZvaWQgMCE9PUI/QjpudWxsPT09KGk9Z1tFXSl8fHZvaWQgMD09PWk/dm9pZCAwOmlbb10pJiZ2b2lkIDAhPT10P3Q6UX19LDMyMjooQSxJKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eShJLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLEkuUmFpbndheUdlc3R1cmVSZWNvZ25pemVyPXZvaWQgMDtjb25zdCBnPXtjbGlja0R1cmF0aW9uTXM6NjAsZHJhZ0RlbGF5TXM6MzAwLHJpZ2h0Q2xpY2tEZWxheU1zOjUwMCx0b3VjaFNsb3BSYWRpdXM6OCxkb3VibGVUYXBXaW5kb3dNczo0MDAsZG91YmxlVGFwUmFkaXVzOjEyLHNjcm9sbEdlc3R1cmVUaHJlc2hvbGRQaXhlbHM6MjAsc2Nyb2xsRXBzaWxvblBpeGVsczo1LHNjcm9sbFNlbnNpdGl2aXR5OjR9O3ZhciBlLEIsaTtmdW5jdGlvbiB0KEEpe3JldHVybiBBPT1CLmxlZnQ/MTpBPT1CLm1pZGRsZT80OkE9PUIucmlnaHQ/MjowfSFmdW5jdGlvbihBKXtBW0EuaWRsZT0wXT1cImlkbGVcIixBW0Eub25lRmluZ2VyRGVjaWRpbmc9MV09XCJvbmVGaW5nZXJEZWNpZGluZ1wiLEFbQS50d29GaW5nZXJzRGVjaWRpbmc9Ml09XCJ0d29GaW5nZXJzRGVjaWRpbmdcIixBW0EubW92aW5nPTNdPVwibW92aW5nXCIsQVtBLmRyYWdnaW5nPTRdPVwiZHJhZ2dpbmdcIixBW0EuaG9sZGluZ1JpZ2h0TW91c2VCdXR0b249NV09XCJob2xkaW5nUmlnaHRNb3VzZUJ1dHRvblwiLEFbQS56b29taW5nPTZdPVwiem9vbWluZ1wiLEFbQS5zY3JvbGxpbmc9N109XCJzY3JvbGxpbmdcIn0oZXx8KGU9e30pKSxmdW5jdGlvbihBKXtBW0EubGVmdD0wXT1cImxlZnRcIixBW0EubWlkZGxlPTFdPVwibWlkZGxlXCIsQVtBLnJpZ2h0PTJdPVwicmlnaHRcIn0oQnx8KEI9e30pKSxmdW5jdGlvbihBKXtBW0EucGl4ZWxzPTBdPVwicGl4ZWxzXCIsQVtBLmxpbmVzPTFdPVwibGluZXNcIixBW0EucGFnZXM9Ml09XCJwYWdlc1wifShpfHwoaT17fSkpLEkuUmFpbndheUdlc3R1cmVSZWNvZ25pemVyPWNsYXNze2NvbnN0cnVjdG9yKEEsSSxpPWcpe3RoaXMucmVwb3J0UG9pbnRlckV2ZW50PUEsdGhpcy5yZXBvcnRXaGVlbEV2ZW50PUksdGhpcy5wYXJhbWV0ZXJzPWksdGhpcy5zdGF0ZT1lLmlkbGUsdGhpcy5wcmltYXJ5PXZvaWQgMCx0aGlzLnNlY29uZGFyeT12b2lkIDAsdGhpcy5jZW50cm9pZFk9MCx0aGlzLmxhc3RUYXBUaW1lPW5ldyBEYXRlLHRoaXMucmlnaHRDbGlja1RpbWVyPXZvaWQgMCx0aGlzLnJpZ2h0Q2xpY2s9KCk9Pnt0aGlzLnJlcG9ydE1vdXNlRG93bihCLnJpZ2h0KSx0aGlzLnRvU3RhdGUoZS5ob2xkaW5nUmlnaHRNb3VzZUJ1dHRvbiksdGhpcy5yaWdodENsaWNrVGltZXI9dm9pZCAwfSx0aGlzLnRhcFJlbGVhc2VUaW1lcj12b2lkIDAsdGhpcy50YXBSZWxlYXNlPSgpPT57dGhpcy5yZXBvcnRNb3VzZVVwKEIubGVmdCksdGhpcy50b1N0YXRlKGUuaWRsZSksdGhpcy5yaWdodENsaWNrVGltZXI9dm9pZCAwfSx0aGlzLm9uUG9pbnRlckRvd249QT0+e2NvbnN0IEk9e3BvaW50ZXJJZDpBLnBvaW50ZXJJZCxob21lT2Zmc2V0WDpBLm9mZnNldFgsaG9tZU9mZnNldFk6QS5vZmZzZXRZLGN1cnJlbnRPZmZzZXRYOkEub2Zmc2V0WCxjdXJyZW50T2Zmc2V0WTpBLm9mZnNldFksZG93blRpbWU6bmV3IERhdGUsYXdha2U6ITF9O3ZvaWQgMD09PXRoaXMucHJpbWFyeT8odGhpcy50b1N0YXRlKGUub25lRmluZ2VyRGVjaWRpbmcpLHRoaXMucHJpbWFyeT1JLHdpbmRvdy5jbGVhclRpbWVvdXQodGhpcy5yaWdodENsaWNrVGltZXIpLHRoaXMucmlnaHRDbGlja1RpbWVyPXdpbmRvdy5zZXRUaW1lb3V0KHRoaXMucmlnaHRDbGljayx0aGlzLnBhcmFtZXRlcnMucmlnaHRDbGlja0RlbGF5TXMpKTp2b2lkIDA9PT10aGlzLnNlY29uZGFyeSYmKHRoaXMudG9TdGF0ZShlLnR3b0ZpbmdlcnNEZWNpZGluZyksdGhpcy5zZWNvbmRhcnk9SSx3aW5kb3cuY2xlYXJUaW1lb3V0KHRoaXMucmlnaHRDbGlja1RpbWVyKSl9LHRoaXMub25Qb2ludGVyVXA9QT0+e3ZhciBJO3dpbmRvdy5jbGVhclRpbWVvdXQodGhpcy5yaWdodENsaWNrVGltZXIpO2NvbnN0IGc9QS5wb2ludGVySWQ9PT0obnVsbD09PShJPXRoaXMucHJpbWFyeSl8fHZvaWQgMD09PUk/dm9pZCAwOkkucG9pbnRlcklkKTtpZih0aGlzLnN0YXRlPT09ZS5vbmVGaW5nZXJEZWNpZGluZyYmZyl7dGhpcy5sb2coXCJwb2ludGVyIHVwIGZyb20gZGVjaWRpbmcsIHRhcHBpbmdcIiksd2luZG93LmNsZWFyVGltZW91dCh0aGlzLnJpZ2h0Q2xpY2tUaW1lcik7Y29uc3QgST1PYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sQSkse29mZnNldFg6QS5vZmZzZXRYLG9mZnNldFk6QS5vZmZzZXRZLHBvaW50ZXJUeXBlOlwidG91Y2hcIix0eXBlOlwicG9pbnRlcm1vdmVcIn0pO3RoaXMucmVwb3J0UG9pbnRlckV2ZW50KEkpLHRoaXMucmVwb3J0TW91c2VEb3duKEIubGVmdCksdGhpcy5wcmltYXJ5PXZvaWQgMCx0aGlzLmxhc3RUYXBUaW1lPW5ldyBEYXRlLHRoaXMudGFwUmVsZWFzZVRpbWVyPXdpbmRvdy5zZXRUaW1lb3V0KHRoaXMudGFwUmVsZWFzZSx0aGlzLnBhcmFtZXRlcnMuY2xpY2tEdXJhdGlvbk1zKX1lbHNlIHRoaXMucHJpbWFyeSYmdGhpcy5zZWNvbmRhcnk/KHRoaXMubG9nKFwic3RvcHBpbmcgdHdvIGZpbmdlciBnZXN0dXJlXCIpLHRoaXMucHJpbWFyeT12b2lkIDAsdGhpcy5zZWNvbmRhcnk9dm9pZCAwLHRoaXMudG9TdGF0ZShlLmlkbGUpKTp0aGlzLnN0YXRlPT09ZS5tb3ZpbmcmJmc/KHRoaXMubG9nKFwic3RvcCBtb3ZpbmdcIiksdGhpcy5wcmltYXJ5PXZvaWQgMCx0aGlzLnRvU3RhdGUoZS5pZGxlKSk6dGhpcy5zdGF0ZT09PWUuZHJhZ2dpbmcmJmc/KHRoaXMubG9nKFwic3RvcCBkcmFnZ2luZ1wiKSx0aGlzLnJlcG9ydE1vdXNlVXAoQi5sZWZ0KSx0aGlzLnByaW1hcnk9dm9pZCAwLHRoaXMudG9TdGF0ZShlLmlkbGUpKTp0aGlzLnN0YXRlPT09ZS5ob2xkaW5nUmlnaHRNb3VzZUJ1dHRvbiYmZyYmKHRoaXMubG9nKFwic3RvcCByaWdodCBjbGlja1wiKSx0aGlzLnJlcG9ydE1vdXNlVXAoQi5yaWdodCksdGhpcy5wcmltYXJ5PXZvaWQgMCx0aGlzLnRvU3RhdGUoZS5pZGxlKSl9LHRoaXMub25Qb2ludGVyTW92ZT1BPT57dmFyIEksZztjb25zdCBpPUEucG9pbnRlcklkPT09KG51bGw9PT0oST10aGlzLnByaW1hcnkpfHx2b2lkIDA9PT1JP3ZvaWQgMDpJLnBvaW50ZXJJZCksdD1BLnBvaW50ZXJJZD09PShudWxsPT09KGc9dGhpcy5zZWNvbmRhcnkpfHx2b2lkIDA9PT1nP3ZvaWQgMDpnLnBvaW50ZXJJZCk7aWYodGhpcy5wcmltYXJ5JiZpPyh0aGlzLnByaW1hcnkuY3VycmVudE9mZnNldFg9QS5vZmZzZXRYLHRoaXMucHJpbWFyeS5jdXJyZW50T2Zmc2V0WT1BLm9mZnNldFkpOnRoaXMuc2Vjb25kYXJ5JiZ0JiYodGhpcy5zZWNvbmRhcnkuY3VycmVudE9mZnNldFg9QS5vZmZzZXRYLHRoaXMuc2Vjb25kYXJ5LmN1cnJlbnRPZmZzZXRZPUEub2Zmc2V0WSksdGhpcy5wcmltYXJ5JiZpJiYhdGhpcy5zZWNvbmRhcnkpdGhpcy5zdGF0ZT09PWUub25lRmluZ2VyRGVjaWRpbmcmJmZ1bmN0aW9uKEEsSSl7Y29uc3QgZz1BLmN1cnJlbnRPZmZzZXRYLUEuaG9tZU9mZnNldFgsZT1BLmN1cnJlbnRPZmZzZXRZLUEuaG9tZU9mZnNldFk7cmV0dXJuIGcqZytlKmU+SSpJfSh0aGlzLnByaW1hcnksdGhpcy5wYXJhbWV0ZXJzLnRvdWNoU2xvcFJhZGl1cyk/KHRoaXMubG9nKFwibGVmdCB0b3VjaCBzbG9wIHJhZGl1c1wiKSx3aW5kb3cuY2xlYXJUaW1lb3V0KHRoaXMucmlnaHRDbGlja1RpbWVyKSx0aGlzLnByaW1hcnkuYXdha2U9ITAsKG5ldyBEYXRlKS52YWx1ZU9mKCktdGhpcy5sYXN0VGFwVGltZS52YWx1ZU9mKCk8dGhpcy5wYXJhbWV0ZXJzLmRyYWdEZWxheU1zPyh0aGlzLnJlcG9ydE1vdXNlRG93bihCLmxlZnQpLHRoaXMudG9TdGF0ZShlLmRyYWdnaW5nKSk6dGhpcy50b1N0YXRlKGUubW92aW5nKSk6dGhpcy5zdGF0ZSE9PWUuZHJhZ2dpbmcmJnRoaXMuc3RhdGUhPT1lLm1vdmluZyYmdGhpcy5zdGF0ZSE9PWUuaG9sZGluZ1JpZ2h0TW91c2VCdXR0b258fHRoaXMucmVwb3J0UG9pbnRlckV2ZW50KEEpO2Vsc2UgaWYodGhpcy5wcmltYXJ5JiZ0aGlzLnNlY29uZGFyeSlpZih0aGlzLnN0YXRlPT09ZS50d29GaW5nZXJzRGVjaWRpbmcpe2NvbnN0IEE9dGhpcy5wcmltYXJ5LmN1cnJlbnRPZmZzZXRZLXRoaXMucHJpbWFyeS5ob21lT2Zmc2V0WSxJPXRoaXMuc2Vjb25kYXJ5LmN1cnJlbnRPZmZzZXRZLXRoaXMuc2Vjb25kYXJ5LmhvbWVPZmZzZXRZLGc9dGhpcy5wYXJhbWV0ZXJzLnNjcm9sbEdlc3R1cmVUaHJlc2hvbGRQaXhlbHM7KEE+ZyYmST5nfHxBPGcmJkk8ZykmJih0aGlzLnRvU3RhdGUoZS5zY3JvbGxpbmcpLHRoaXMuY2VudHJvaWRZPShBK0kpLzIpfWVsc2UgaWYodGhpcy5zdGF0ZT09PWUuc2Nyb2xsaW5nKXtjb25zdCBBPXRoaXMucGFyYW1ldGVycy5zY3JvbGxFcHNpbG9uUGl4ZWxzLEk9KHRoaXMucHJpbWFyeS5jdXJyZW50T2Zmc2V0WS10aGlzLnByaW1hcnkuaG9tZU9mZnNldFkrKHRoaXMuc2Vjb25kYXJ5LmN1cnJlbnRPZmZzZXRZLXRoaXMuc2Vjb25kYXJ5LmhvbWVPZmZzZXRZKSkvMjtJPnRoaXMuY2VudHJvaWRZK0E/KHRoaXMucmVwb3J0U2Nyb2xsKHRoaXMucGFyYW1ldGVycy5zY3JvbGxTZW5zaXRpdml0eSpBKSx0aGlzLmNlbnRyb2lkWT1JKTpJPHRoaXMuY2VudHJvaWRZLUEmJih0aGlzLnJlcG9ydFNjcm9sbCh0aGlzLnBhcmFtZXRlcnMuc2Nyb2xsU2Vuc2l0aXZpdHkqLUEpLHRoaXMuY2VudHJvaWRZPUkpfX19bG9nKC4uLkEpe31yZXBvcnRNb3VzZVVwKEEpe3RoaXMubG9nKFwiLS1cXHgzZSByZXBvcnQgcG9pbnRlcnVwXCIsQSk7Y29uc3QgST1uZXcgUG9pbnRlckV2ZW50KFwicG9pbnRlcnVwXCIse3BvaW50ZXJUeXBlOlwibW91c2VcIixidXR0b25zOjAsYnV0dG9uOkF9KTt0aGlzLnJlcG9ydFBvaW50ZXJFdmVudChJKX1yZXBvcnRNb3VzZURvd24oQSl7dGhpcy5sb2coXCItLVxceDNlIHJlcG9ydCBwb2ludGVyZG93blwiLEEpO2NvbnN0IEk9bmV3IFBvaW50ZXJFdmVudChcInBvaW50ZXJkb3duXCIse3BvaW50ZXJUeXBlOlwibW91c2VcIixidXR0b25zOnQoQSksYnV0dG9uOkF9KTt0aGlzLnJlcG9ydFBvaW50ZXJFdmVudChJKX1yZXBvcnRTY3JvbGwoQSl7Y29uc3QgST1uZXcgV2hlZWxFdmVudChcInN5bnRoZXRpY1doZWVsXCIse2RlbHRhWTpBLGRlbHRhTW9kZTppLnBpeGVsc30pO3RoaXMucmVwb3J0V2hlZWxFdmVudChJKX10b1N0YXRlKEEpe3RoaXMubG9nKFtcImlkbGVcIixcIm9uZUZpbmdlckRlY2lkaW5nXCIsXCJ0d29GaW5nZXJzRGVjaWRpbmdcIixcIm1vdmluZ1wiLFwiZHJhZ2dpbmdcIixcImhvbGRpbmdSaWdodE1vdXNlQnV0dG9uXCIsXCJ6b29taW5nXCIsXCJzY3JvbGxpbmdcIl1bQV0pLHRoaXMuc3RhdGU9QX1wcm9jZXNzUG9pbnRlckV2ZW50KEEpe2lmKFwidG91Y2hcIj09PUEucG9pbnRlclR5cGUpc3dpdGNoKEEudHlwZSl7Y2FzZVwicG9pbnRlcmRvd25cIjp0aGlzLm9uUG9pbnRlckRvd24oQSk7YnJlYWs7Y2FzZVwicG9pbnRlcnVwXCI6dGhpcy5vblBvaW50ZXJVcChBKTticmVhaztjYXNlXCJwb2ludGVycmF3dXBkYXRlXCI6Y2FzZVwicG9pbnRlcm1vdmVcIjp0aGlzLm9uUG9pbnRlck1vdmUoQSl9ZWxzZSB0aGlzLnJlcG9ydFBvaW50ZXJFdmVudChBKX19fSw4MjQ6KEEsSSxnKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eShJLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLEkuUmFpbndheUlucHV0TWFuYWdlcj1JLm1vdXNlQ2xpY2tGcm9tPXZvaWQgMDtjb25zdCBlPWcoOTk0KSxCPWcoOTA0KSxpPWcoNDApLHQ9ZygzMjIpLFE9Zyg2NSksQz1nKDUyOCksRT1nKDkwNCksbz1nKDg4NCk7ZnVuY3Rpb24gYShBKXtsZXQgSSxnO3N3aXRjaChBLmJ1dHRvbil7ZGVmYXVsdDpjYXNlIDA6ST0wIT0oMSZBLmJ1dHRvbnMpLGc9RS5Nb3VzZUJ1dHRvbi5MZWZ0O2JyZWFrO2Nhc2UgMTpJPTAhPSg0JkEuYnV0dG9ucyksZz1FLk1vdXNlQnV0dG9uLk1pZGRsZTticmVhaztjYXNlIDI6ST0wIT0oMiZBLmJ1dHRvbnMpLGc9RS5Nb3VzZUJ1dHRvbi5SaWdodDticmVhaztjYXNlIDM6ST0wIT0oOCZBLmJ1dHRvbnMpLGc9RS5Nb3VzZUJ1dHRvbi5YMTticmVhaztjYXNlIDQ6ST0wIT0oMTYmQS5idXR0b25zKSxnPUUuTW91c2VCdXR0b24uWDJ9cmV0dXJue2J1dHRvbjpnLGFjdGlvbjpJP0UuQnV0dG9uQWN0aW9uLkJ1dHRvbkRvd246RS5CdXR0b25BY3Rpb24uQnV0dG9uVXB9fWZ1bmN0aW9uIG4oQSl7cmV0dXJuIEEuYXhlcy5sZW5ndGg+PTQmJkEuYnV0dG9ucy5sZW5ndGg+PTE2fWZ1bmN0aW9uIHMoQSxJKXtpZihBPT09SSlyZXR1cm4hMDtpZihBLmxlbmd0aCE9PUkubGVuZ3RoKXJldHVybiExO2ZvcihsZXQgZz0wO2c8QS5sZW5ndGg7KytnKWlmKEFbZ10hPT1JW2ddKXJldHVybiExO3JldHVybiEwfUkubW91c2VDbGlja0Zyb209YSxJLlJhaW53YXlJbnB1dE1hbmFnZXI9Y2xhc3N7Y29uc3RydWN0b3IoQSxJPXt0b3VjaEdlc3R1cmVzOiExLHVubG9ja2VkTW91c2VQb2ludGVyOiExLGVtYnJhY2VNb3VzZUFjY2VsZXJhdGlvbjohMX0pe3RoaXMucmFpbndheVN0cmVhbT1BLHRoaXMub3B0aW9ucz1JLHRoaXMubGV2ZWw9Qi5JbnB1dExldmVsLk5vbmUsdGhpcy5jb250YWluZXI9dm9pZCAwLHRoaXMuaGVsZEtleXM9bmV3IFNldCx0aGlzLmFsd2F5c1JlcG9ydEdhbWVwYWRQb2xsPSEwLHRoaXMubG9ja1BvaW50ZXI9KCk9PntpZih0aGlzLm9wdGlvbnMudW5sb2NrZWRNb3VzZVBvaW50ZXIpcmV0dXJuO2lmKCF0aGlzLmNvbnRhaW5lcilyZXR1cm47aWYoIXRoaXMuY29udGFpbmVyLnJlcXVlc3RQb2ludGVyTG9jaylyZXR1cm47Y29uc3QgQT0hdGhpcy5vcHRpb25zLmVtYnJhY2VNb3VzZUFjY2VsZXJhdGlvbixJPUE/dGhpcy5jb250YWluZXIucmVxdWVzdFBvaW50ZXJMb2NrKHt1bmFkanVzdGVkTW92ZW1lbnQ6ITB9KTp0aGlzLmNvbnRhaW5lci5yZXF1ZXN0UG9pbnRlckxvY2soKTtJIGluc3RhbmNlb2YgUHJvbWlzZT9JLmNhdGNoKChJPT57dmFyIGc7XCJOb3RTdXBwb3J0ZWRFcnJvclwiPT09SS5uYW1lJiZBJiYobnVsbD09PShnPXRoaXMuY29udGFpbmVyKXx8dm9pZCAwPT09Z3x8Zy5yZXF1ZXN0UG9pbnRlckxvY2soKSl9KSk6dGhpcy5jb250YWluZXIub25wb2ludGVybG9ja2Vycm9yPSgpPT57dmFyIEk7QSYmKG51bGw9PT0oST10aGlzLmNvbnRhaW5lcil8fHZvaWQgMD09PUl8fEkucmVxdWVzdFBvaW50ZXJMb2NrKCkpfSx0aGlzLmNvbnRhaW5lci5mb2N1cygpfSx0aGlzLmZvY3VzQ29udGFpbmVyPSgpPT57dmFyIEE7cmV0dXJuIG51bGw9PT0oQT10aGlzLmNvbnRhaW5lcil8fHZvaWQgMD09PUE/dm9pZCAwOkEuZm9jdXMoKX0sdGhpcy5vblBvaW50ZXJFdmVudFdpdGhHZXN0dXJlUHJvY2Vzc2luZz1BPT57KEEucG9pbnRlclR5cGUmJlwibW91c2VcIiE9PUEucG9pbnRlclR5cGV8fGRvY3VtZW50LnBvaW50ZXJMb2NrRWxlbWVudD09PXRoaXMuY29udGFpbmVyKSYmKHRoaXMub3B0aW9ucy50b3VjaEdlc3R1cmVzJiZcInRvdWNoXCI9PT1BLnBvaW50ZXJUeXBlPyhBLnByZXZlbnREZWZhdWx0KCksdGhpcy5nZXN0dXJlUmVjb2duaXplci5wcm9jZXNzUG9pbnRlckV2ZW50KEEpKTp0aGlzLm9uUG9pbnRlckV2ZW50KEEpKX0sdGhpcy5vblBvaW50ZXJFdmVudEZyb21HZXN0dXJlUmVjb2duaXplcj1BPT57dGhpcy5vblBvaW50ZXJFdmVudChBKX0sdGhpcy5vblBvaW50ZXJFdmVudD1BPT57dGhpcy5jdXJzb3JQYWludGVyLnVwZGF0ZShBLHRoaXMucmVtZW1iZXJlZE9mZnNldFgsdGhpcy5yZW1lbWJlcmVkT2Zmc2V0WSksdGhpcy5yZXBvcnRQb2ludGVyRXZlbnQoQSl9LHRoaXMuc2Nyb2xsZWRBbW91bnQ9MCx0aGlzLm9uV2hlZWxFdmVudD1BPT57dGhpcy5zY3JvbGxlZEFtb3VudCs9LjA1KkEuZGVsdGFZLHRoaXMuc2Nyb2xsZWRBbW91bnQ+PTE/KHRoaXMuc2VuZFZlcnRpY2FsU2Nyb2xsKE1hdGguZmxvb3IodGhpcy5zY3JvbGxlZEFtb3VudCkpLHRoaXMuc2Nyb2xsZWRBbW91bnQlPTEpOnRoaXMuc2Nyb2xsZWRBbW91bnQ8PS0xJiYodGhpcy5zZW5kVmVydGljYWxTY3JvbGwoTWF0aC5jZWlsKHRoaXMuc2Nyb2xsZWRBbW91bnQpKSx0aGlzLnNjcm9sbGVkQW1vdW50JT0tMSl9LHRoaXMub25LZXlib2FyZEV2ZW50PUE9PntBLnByZXZlbnREZWZhdWx0KCk7Y29uc3QgST1pLlJhaW53YXlWaXJ0dWFsS2V5RnJvbVdlYktleUNvZGVbQS5jb2RlXSxnPVwia2V5ZG93blwiPT09QS50eXBlO0kmJihnP3RoaXMuaGVsZEtleXMuYWRkKEkpOnRoaXMuaGVsZEtleXMuZGVsZXRlKEkpLHRoaXMuc2VuZElucHV0RGF0YWdyYW0oe2Rpc2NyaW1pbmF0b3I6RS5LZXlib2FyZElucHV0LmRpc2NyaW1pbmF0b3IsdmFsdWU6e2FjdGlvbjpnP0UuS2V5Ym9hcmRBY3Rpb24uS2V5RG93bjpFLktleWJvYXJkQWN0aW9uLktleVVwLGtleWNvZGU6SX19KSl9LHRoaXMub25HYW1lcGFkQ29ubmVjdGVkRXZlbnQ9QT0+e30sdGhpcy5vbkdhbWVwYWREaXNjb25uZWN0ZWRFdmVudD1BPT57fSx0aGlzLm9uRGV2aWNlTW90aW9uPUE9Pnt9LHRoaXMub25EZXZpY2VPcmllbnRhdGlvbj1BPT57fSx0aGlzLmdhbWVwYWRDYWNoZT1uZXcgTWFwLHRoaXMucG9sbEdhbWVwYWRzPUE9PntpZihuYXZpZ2F0b3IuZ2V0R2FtZXBhZHMpe2lmKHRoaXMuY29udGFpbmVyPT09ZG9jdW1lbnQuYWN0aXZlRWxlbWVudCl7Y29uc3QgQT1bXTtmb3IoY29uc3QgSSBvZiBuYXZpZ2F0b3IuZ2V0R2FtZXBhZHMoKSl7aWYoIUl8fCFuKEkpKWNvbnRpbnVlO2NvbnN0IGc9SS5idXR0b25zLm1hcCgoQT0+QS52YWx1ZSkpLGU9dGhpcy5nYW1lcGFkQ2FjaGUuZ2V0KEkuaW5kZXgpO2UmJnMoZS5heGVzLEkuYXhlcykmJnMoZS5idXR0b25WYWx1ZXMsZyl8fChBLnB1c2godGhpcy5tYWtlR2FtZXBhZElucHV0RXZlbnQoSSkpLHRoaXMuZ2FtZXBhZENhY2hlLnNldChJLmluZGV4LHtheGVzOlsuLi5JLmF4ZXNdLGJ1dHRvblZhbHVlczpnfSkpfSh0aGlzLmFsd2F5c1JlcG9ydEdhbWVwYWRQb2xsfHxBLmxlbmd0aD4wKSYmdGhpcy5yZXBvcnRHYW1lcGFkRXZlbnRzKEEpfXRoaXMubGV2ZWwmQi5JbnB1dExldmVsLkdhbWVwYWQmJih0aGlzLmdhbWVwYWRGcmFtZUhhbmRsZT13aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRoaXMucG9sbEdhbWVwYWRzKSl9fSx0aGlzLnJlcG9ydEdhbWVwYWRFdmVudHM9QT0+e2Zvcihjb25zdCBJIG9mIEEpe2xldCBBPTA7SS5idXR0b25zLmRwYWRVcCYmKEF8PTEpLEkuYnV0dG9ucy5kcGFkRG93biYmKEF8PTIpLEkuYnV0dG9ucy5kcGFkTGVmdCYmKEF8PTQpLEkuYnV0dG9ucy5kcGFkUmlnaHQmJihBfD04KSxJLmJ1dHRvbnMuc3RhcnQmJihBfD0xNiksSS5idXR0b25zLnNlbGVjdCYmKEF8PTMyKSxJLmJ1dHRvbnMubGVmdFN0aWNrUHJlc3NlZCYmKEF8PTY0KSxJLmJ1dHRvbnMucmlnaHRTdGlja1ByZXNzZWQmJihBfD0xMjgpLEkuYnV0dG9ucy5sZWZ0U2hvdWxkZXImJihBfD0yNTYpLEkuYnV0dG9ucy5yaWdodFNob3VsZGVyJiYoQXw9NTEyKSxJLmJ1dHRvbnMuYSYmKEF8PTQwOTYpLEkuYnV0dG9ucy5iJiYoQXw9ODE5MiksSS5idXR0b25zLngmJihBfD0xNjM4NCksSS5idXR0b25zLnkmJihBfD0zMjc2OCk7Y29uc3QgZz17YnV0dG9uczpBLGxlZnRUcmlnZ2VyOk1hdGgucm91bmQoMjU1KkkuYnV0dG9ucy5sZWZ0VHJpZ2dlcikscmlnaHRUcmlnZ2VyOk1hdGgucm91bmQoMjU1KkkuYnV0dG9ucy5yaWdodFRyaWdnZXIpLGxlZnRUaHVtYlg6TWF0aC5yb3VuZCgzMjc2NypJLnN0aWNrcy5sZWZ0LngpLGxlZnRUaHVtYlk6TWF0aC5yb3VuZCgzMjc2NyotSS5zdGlja3MubGVmdC55KSxyaWdodFRodW1iWDpNYXRoLnJvdW5kKDMyNzY3Kkkuc3RpY2tzLnJpZ2h0LngpLHJpZ2h0VGh1bWJZOk1hdGgucm91bmQoMzI3NjcqLUkuc3RpY2tzLnJpZ2h0LnkpLHNsb3Q6MX07dGhpcy5zZW5kSW5wdXREYXRhZ3JhbSh7ZGlzY3JpbWluYXRvcjpFLkdhbWVwYWRSZXBvcnQuZGlzY3JpbWluYXRvcix2YWx1ZTpnfSl9fSx0aGlzLm1vdmVNb3VzZVJlbGF0aXZlWFk9KEEsSSk9Pnt0aGlzLnNlbmRNb3VzZU1vdmUoXCJyZWxhdGl2ZVwiLEEsSSl9LHRoaXMubW92ZU1vdXNlQWJzb2x1dGVYWT0oQSxJKT0+e3RoaXMuc2VuZE1vdXNlTW92ZShcImFic29sdXRlXCIsQSxJKX0sdGhpcy5wb2ludGVyRnJhbWVJZD0wLHRoaXMucmVtZW1iZXJlZE9mZnNldFg9MCx0aGlzLnJlbWVtYmVyZWRPZmZzZXRZPTAsdGhpcy50b3VjaGVzPW5ldyBNYXAsdGhpcy5yZXBvcnRQb2ludGVyRXZlbnQ9QT0+e2lmKFwidG91Y2hcIj09PUEucG9pbnRlclR5cGV8fFwicGVuXCI9PT1BLnBvaW50ZXJUeXBlKXtpZihkb2N1bWVudC5wb2ludGVyTG9ja0VsZW1lbnQ9PT10aGlzLmNvbnRhaW5lcil7Y29uc3QgST10aGlzLmNvbnRhaW5lci5jbGllbnRXaWR0aCxnPXRoaXMuY29udGFpbmVyLmNsaWVudEhlaWdodCxlPUEubW92ZW1lbnRYLEI9QS5tb3ZlbWVudFk7dGhpcy5yZW1lbWJlcmVkT2Zmc2V0WD1NYXRoLm1heCgwLE1hdGgubWluKEksdGhpcy5yZW1lbWJlcmVkT2Zmc2V0WCtlKSksdGhpcy5yZW1lbWJlcmVkT2Zmc2V0WT1NYXRoLm1heCgwLE1hdGgubWluKGcsdGhpcy5yZW1lbWJlcmVkT2Zmc2V0WStCKSl9ZWxzZSB0aGlzLnJlbWVtYmVyZWRPZmZzZXRYPUEub2Zmc2V0WCx0aGlzLnJlbWVtYmVyZWRPZmZzZXRZPUEub2Zmc2V0WTtjb25zdCBJPXRoaXMucmFpbndheVN0cmVhbS50cmFuc2Zvcm1Qb2ludGVyT2Zmc2V0VG9SZW1vdGUodGhpcy5yZW1lbWJlcmVkT2Zmc2V0WCx0aGlzLnJlbWVtYmVyZWRPZmZzZXRZKTtpZighSSlyZXR1cm47Y29uc3R7eDpnLHk6ZX09SSxpPU1hdGguY2VpbChBLndpZHRoLzIpLHQ9TWF0aC5jZWlsKEEuaGVpZ2h0LzIpLHtwb2ludGVySWQ6USxidXR0b25zOkN9PUEsRT1cInBvaW50ZXJjYW5jZWxcIj09PUEudHlwZXx8XCJwb2ludGVyb3V0XCI9PT1BLnR5cGV8fFwicG9pbnRlcmxlYXZlXCI9PT1BLnR5cGUsbz1DPjAsYT0oXCJwb2ludGVyb3ZlclwiPT09QS50eXBlP0IuV2luZG93c1BvaW50ZXJGbGFncy5OZXc6MCl8KG8/Qi5XaW5kb3dzUG9pbnRlckZsYWdzLkluQ29udGFjdDowKXwoMT09KDMmQyk/Qi5XaW5kb3dzUG9pbnRlckZsYWdzLkZpcnN0QnV0dG9uOjApfCgzPT0oMyZDKT9CLldpbmRvd3NQb2ludGVyRmxhZ3MuU2Vjb25kQnV0dG9uOjApfChBLmlzUHJpbWFyeT9CLldpbmRvd3NQb2ludGVyRmxhZ3MuUHJpbWFyeTowKXwoXCJwb2ludGVyY2FuY2VsXCI9PT1BLnR5cGU/Qi5XaW5kb3dzUG9pbnRlckZsYWdzLkNhbmNlbGVkOjApfChcInBvaW50ZXJkb3duXCI9PT1BLnR5cGU/Qi5XaW5kb3dzUG9pbnRlckZsYWdzLkRvd246XCJwb2ludGVydXBcIj09PUEudHlwZT9CLldpbmRvd3NQb2ludGVyRmxhZ3MuVXA6Qi5XaW5kb3dzUG9pbnRlckZsYWdzLlVwZGF0ZSl8KEU/bz9CLldpbmRvd3NQb2ludGVyRmxhZ3MuVXA6Qi5XaW5kb3dzUG9pbnRlckZsYWdzLlVwZGF0ZTpCLldpbmRvd3NQb2ludGVyRmxhZ3MuSW5SYW5nZSksbj17cG9pbnRlcklkOlEsZnJhbWVJZDorK3RoaXMucG9pbnRlckZyYW1lSWQscG9pbnRlckZsYWdzOmEseDpnLHk6ZX0scz1NYXRoLnJvdW5kKEEudHdpc3QpJTM2MCxyPU1hdGgucm91bmQoMTAyNCpBLnByZXNzdXJlKTtpZihcInRvdWNoXCI9PT1BLnBvaW50ZXJUeXBlKXtjb25zdCBBPXtwb2ludGVySW5mbzpuLHRvdWNoTWFzazpCLlRvdWNoTWFzay5Db250YWN0QXJlYXxCLlRvdWNoTWFzay5PcmllbnRhdGlvbnxCLlRvdWNoTWFzay5QcmVzc3VyZSxjb250YWN0TGVmdDpnLWksY29udGFjdFRvcDplLXQsY29udGFjdFJpZ2h0OmcraSxjb250YWN0Qm90dG9tOmUrdCxvcmllbnRhdGlvbjpzLHByZXNzdXJlOnJ9O3RoaXMudG91Y2hlcy5zZXQoUSxBKSx0aGlzLnNlbmRJbnB1dERhdGFncmFtKHtkaXNjcmltaW5hdG9yOkIuVG91Y2hlc0Fic29sdXRlLmRpc2NyaW1pbmF0b3IsdmFsdWU6e3RvdWNoZXM6Wy4uLnRoaXMudG91Y2hlcy52YWx1ZXMoKV19fSksRSYmdGhpcy50b3VjaGVzLmRlbGV0ZShRKX1lbHNle2NvbnN0IEk9KDImQz9CLlBlbkZsYWdzLkJhcnJlbDowKXwoMzImQz9CLlBlbkZsYWdzLkVyYXNlcjowKTt0aGlzLnNlbmRJbnB1dERhdGFncmFtKHtkaXNjcmltaW5hdG9yOkIuUGVuQWJzb2x1dGUuZGlzY3JpbWluYXRvcix2YWx1ZTp7cG9pbnRlckluZm86bixwZW5NYXNrOkIuUGVuTWFzay5QcmVzc3VyZXxCLlBlbk1hc2suUm90YXRpb258Qi5QZW5NYXNrLlRpbHRYfEIuUGVuTWFzay5UaWx0WSxwZW5GbGFnczpJLHJvdGF0aW9uOnMscHJlc3N1cmU6cix0aWx0WDpNYXRoLnJvdW5kKEEudGlsdFgpLHRpbHRZOk1hdGgucm91bmQoQS50aWx0WSl9fSl9fWVsc2UgaWYoKEEubW92ZW1lbnRYfHxBLm1vdmVtZW50WSkmJnRoaXMuc2VuZE1vdXNlTW92ZShcInJlbGF0aXZlXCIsQS5tb3ZlbWVudFgsQS5tb3ZlbWVudFkpLEEuYnV0dG9uPi0xKXtjb25zdCBJPWEoQSk7dGhpcy5zZW5kTW91c2VDbGljayhJKX19LHRoaXMuY3Vyc29yUGFpbnRlcj1uZXcgUS5SYWlud2F5Q3Vyc29yUGFpbnRlcih0aGlzLm1vdmVNb3VzZUFic29sdXRlWFksKChBLEkpPT50aGlzLnJhaW53YXlTdHJlYW0udHJhbnNmb3JtUG9pbnRlck9mZnNldFRvUmVtb3RlKEEsSSkpLCgoKT0+dGhpcy5yYWlud2F5U3RyZWFtLmN1cnJlbnRGcmFtZVNpemUpKSx0aGlzLmdlc3R1cmVSZWNvZ25pemVyPW5ldyB0LlJhaW53YXlHZXN0dXJlUmVjb2duaXplcih0aGlzLm9uUG9pbnRlckV2ZW50RnJvbUdlc3R1cmVSZWNvZ25pemVyLHRoaXMub25XaGVlbEV2ZW50KSx0aGlzLm91dGdvaW5nSW5wdXRGaWx0ZXI9KCk9PiEwfXNldENvbnRhaW5lcihBKXtpZih0aGlzLmN1cnNvclBhaW50ZXIuc2V0Q29udGFpbmVyKEEpLHRoaXMuY29udGFpbmVyKXtjb25zdCBJPXRoaXMubGV2ZWw7dGhpcy5zZXRJbnB1dExldmVsKEIuSW5wdXRMZXZlbC5Ob25lLCExKSx0aGlzLmNvbnRhaW5lcj1BLHRoaXMuc2V0SW5wdXRMZXZlbChJLCExKX1lbHNlIHRoaXMuY29udGFpbmVyPUF9dW5zZXRDb250YWluZXIoKXt0aGlzLnNldElucHV0TGV2ZWwoQi5JbnB1dExldmVsLk5vbmUsITEpLHRoaXMuY3Vyc29yUGFpbnRlci51bnNldENvbnRhaW5lcigpLHRoaXMuY29udGFpbmVyPXZvaWQgMH1zZXRJbnB1dExldmVsKEEsST0hMCxnPSEwKXt0aGlzLmFsd2F5c1JlcG9ydEdhbWVwYWRQb2xsPWc7Y29uc3QgZT1BJn50aGlzLmxldmVsLGk9dGhpcy5sZXZlbCZ+QTt0aGlzLmxldmVsPUEsZSZCLklucHV0TGV2ZWwuR2FtZXBhZCYmdGhpcy5zdGFydEdhbWVwYWQoSSksaSZCLklucHV0TGV2ZWwuR2FtZXBhZCYmdGhpcy5zdG9wR2FtZXBhZCgpLGUmQi5JbnB1dExldmVsLk1vdXNlJiZ0aGlzLnN0YXJ0TW91c2UoKSxpJkIuSW5wdXRMZXZlbC5Nb3VzZSYmdGhpcy5zdG9wTW91c2UoKSxlJkIuSW5wdXRMZXZlbC5LZXlib2FyZCYmdGhpcy5zdGFydEtleWJvYXJkKCksaSZCLklucHV0TGV2ZWwuS2V5Ym9hcmQmJnRoaXMuc3RvcEtleWJvYXJkKCl9Z2V0SW5wdXRMZXZlbCgpe3JldHVybiB0aGlzLmxldmVsfXN0YXJ0R2FtZXBhZChBKXt3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImdhbWVwYWRjb25uZWN0ZWRcIix0aGlzLm9uR2FtZXBhZENvbm5lY3RlZEV2ZW50KSx3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImdhbWVwYWRkaXNjb25uZWN0ZWRcIix0aGlzLm9uR2FtZXBhZERpc2Nvbm5lY3RlZEV2ZW50KSx0aGlzLmdhbWVwYWRGcmFtZUhhbmRsZT13aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRoaXMucG9sbEdhbWVwYWRzKSxBJiZ0aGlzLnJlcG9ydENvbm5lY3RlZEdhbWVwYWRzKCl9cmVwb3J0Q29ubmVjdGVkR2FtZXBhZHMoKXtmb3IoY29uc3QgQSBvZiBuYXZpZ2F0b3IuZ2V0R2FtZXBhZHMoKSlBJiZ0aGlzLm9uR2FtZXBhZENvbm5lY3RlZEV2ZW50KG5ldyBHYW1lcGFkRXZlbnQoXCJnYW1lcGFkY29ubmVjdGVkXCIse2dhbWVwYWQ6QX0pKX1zdG9wR2FtZXBhZCgpe3dpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwiZ2FtZXBhZGNvbm5lY3RlZFwiLHRoaXMub25HYW1lcGFkQ29ubmVjdGVkRXZlbnQpLHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwiZ2FtZXBhZGRpc2Nvbm5lY3RlZFwiLHRoaXMub25HYW1lcGFkRGlzY29ubmVjdGVkRXZlbnQpLHRoaXMuZ2FtZXBhZEZyYW1lSGFuZGxlJiZ3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy5nYW1lcGFkRnJhbWVIYW5kbGUpLHRoaXMuZ2FtZXBhZEZyYW1lSGFuZGxlPXZvaWQgMH1wb2ludGVyRXZlbnRMaXN0ZW5lcnMoQSl7aWYoIXdpbmRvdy5Qb2ludGVyRXZlbnQpdGhyb3cgbmV3IEVycm9yKFwiYnJvd3NlciBkb2VzIG5vdCBzdXBwb3J0IFBvaW50ZXJFdmVudFwiKTtBKEMuaXNEZXNrdG9wU2FmYXJpJiZuYXZpZ2F0b3IubWF4VG91Y2hQb2ludHM8MT9cIm1vdXNlbW92ZVwiOndpbmRvdy5vbnBvaW50ZXJyYXd1cGRhdGU/XCJwb2ludGVycmF3dXBkYXRlXCI6XCJwb2ludGVybW92ZVwiLHRoaXMub25Qb2ludGVyRXZlbnRXaXRoR2VzdHVyZVByb2Nlc3NpbmcpLEEoXCJwb2ludGVyZG93blwiLHRoaXMub25Qb2ludGVyRXZlbnRXaXRoR2VzdHVyZVByb2Nlc3NpbmcpLEEoXCJwb2ludGVydXBcIix0aGlzLm9uUG9pbnRlckV2ZW50V2l0aEdlc3R1cmVQcm9jZXNzaW5nKSxBKFwicG9pbnRlcm92ZXJcIix0aGlzLm9uUG9pbnRlckV2ZW50V2l0aEdlc3R1cmVQcm9jZXNzaW5nKSxBKFwicG9pbnRlcmVudGVyXCIsdGhpcy5vblBvaW50ZXJFdmVudFdpdGhHZXN0dXJlUHJvY2Vzc2luZyksQShcInBvaW50ZXJjYW5jZWxcIix0aGlzLm9uUG9pbnRlckV2ZW50V2l0aEdlc3R1cmVQcm9jZXNzaW5nKSxBKFwicG9pbnRlcm91dFwiLHRoaXMub25Qb2ludGVyRXZlbnRXaXRoR2VzdHVyZVByb2Nlc3NpbmcpLEEoXCJwb2ludGVybGVhdmVcIix0aGlzLm9uUG9pbnRlckV2ZW50V2l0aEdlc3R1cmVQcm9jZXNzaW5nKSxBKFwid2hlZWxcIix0aGlzLm9uV2hlZWxFdmVudCksQShcIm1vdXNldXBcIix0aGlzLmxvY2tQb2ludGVyKX1zdGFydE1vdXNlKCl7aWYoIXRoaXMuY29udGFpbmVyKXRocm93IG5ldyBlLlJhaW53YXlFcnJvcihcIlJhaW53YXkgdHJpZWQgdG8gYWRkIGFuIGV2ZW50IGxpc3RlbmVyIHRvIGl0cyBjb250YWluZXIgdG8gaGFuZGxlIG1vdXNlIGlucHV0LCBidXQgbm8gY29udGFpbmVyIGVsZW1lbnQgaXMgc2V0LiBUcnkgY2FsbGluZyBzZXRDb250YWluZXIoKSBmaXJzdC5cIik7dGhpcy5wb2ludGVyRXZlbnRMaXN0ZW5lcnModGhpcy5jb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lci5iaW5kKHRoaXMuY29udGFpbmVyKSl9c3RvcE1vdXNlKCl7dGhpcy5jb250YWluZXImJnRoaXMucG9pbnRlckV2ZW50TGlzdGVuZXJzKHRoaXMuY29udGFpbmVyLnJlbW92ZUV2ZW50TGlzdGVuZXIuYmluZCh0aGlzLmNvbnRhaW5lcikpfXN0YXJ0S2V5Ym9hcmQoKXtpZighdGhpcy5jb250YWluZXIpdGhyb3cgbmV3IGUuUmFpbndheUVycm9yKFwiUmFpbndheSB0cmllZCB0byBhZGQgYW4gZXZlbnQgbGlzdGVuZXIgdG8gaXRzIGNvbnRhaW5lciB0byBoYW5kbGUga2V5Ym9hcmQgaW5wdXQsIGJ1dCBubyBjb250YWluZXIgZWxlbWVudCBpcyBzZXQuIFRyeSBjYWxsaW5nIHNldENvbnRhaW5lcigpIGZpcnN0LlwiKTt0aGlzLmNvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLHRoaXMub25LZXlib2FyZEV2ZW50KSx0aGlzLmNvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKFwia2V5dXBcIix0aGlzLm9uS2V5Ym9hcmRFdmVudCksdGhpcy5jb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsdGhpcy5mb2N1c0NvbnRhaW5lciksdGhpcy5jb250YWluZXIuZm9jdXMoKX1zdG9wS2V5Ym9hcmQoKXt0aGlzLmNvbnRhaW5lciYmKHRoaXMucmVsZWFzZUtleXMoKSx0aGlzLmNvbnRhaW5lci5yZW1vdmVFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLHRoaXMub25LZXlib2FyZEV2ZW50KSx0aGlzLmNvbnRhaW5lci5yZW1vdmVFdmVudExpc3RlbmVyKFwia2V5dXBcIix0aGlzLm9uS2V5Ym9hcmRFdmVudCksdGhpcy5jb250YWluZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsdGhpcy5mb2N1c0NvbnRhaW5lcikpfXN0YXJ0RGV2aWNlTW90aW9uRXZlbnRzKCl7d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJkZXZpY2Vtb3Rpb25cIix0aGlzLm9uRGV2aWNlTW90aW9uKX1zdG9wRGV2aWNlTW90aW9uRXZlbnRzKCl7d2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJkZXZpY2Vtb3Rpb25cIix0aGlzLm9uRGV2aWNlTW90aW9uKX1zdGFydERldmljZU9yaWVudGF0aW9uRXZlbnRzKCl7d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJkZXZpY2VvcmllbnRhdGlvblwiLHRoaXMub25EZXZpY2VPcmllbnRhdGlvbil9c3RvcERldmljZU9yaWVudGF0aW9uRXZlbnRzKCl7d2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJkZXZpY2VvcmllbnRhdGlvblwiLHRoaXMub25EZXZpY2VPcmllbnRhdGlvbil9c2VuZFZlcnRpY2FsU2Nyb2xsKEEpe3RoaXMuc2VuZElucHV0RGF0YWdyYW0oe2Rpc2NyaW1pbmF0b3I6RS5Nb3VzZVNjcm9sbC5kaXNjcmltaW5hdG9yLHZhbHVlOntheGlzOkUuU2Nyb2xsQXhpcy5WZXJ0aWNhbCxkZWx0YTpBfX0pfW1ha2VHYW1lcGFkSW5wdXRFdmVudChBKXt2YXIgSSxnLGUsQixpLHQsUSxDLEUsbyxhLG4scyxyLGQsaCxjLEQsdyx1LHksbCxTLEYsUixHLGsscCxVLG0sTixmLE0sTCxILEssdixxO3JldHVybntpZDpBLmlkLGluZGV4OkEuaW5kZXgsYnV0dG9uczp7YTpudWxsIT09KGc9bnVsbD09PShJPUEuYnV0dG9uc1swXSl8fHZvaWQgMD09PUk/dm9pZCAwOkkudmFsdWUpJiZ2b2lkIDAhPT1nP2c6MCxiOm51bGwhPT0oQj1udWxsPT09KGU9QS5idXR0b25zWzFdKXx8dm9pZCAwPT09ZT92b2lkIDA6ZS52YWx1ZSkmJnZvaWQgMCE9PUI/QjowLHg6bnVsbCE9PSh0PW51bGw9PT0oaT1BLmJ1dHRvbnNbMl0pfHx2b2lkIDA9PT1pP3ZvaWQgMDppLnZhbHVlKSYmdm9pZCAwIT09dD90OjAseTpudWxsIT09KEM9bnVsbD09PShRPUEuYnV0dG9uc1szXSl8fHZvaWQgMD09PVE/dm9pZCAwOlEudmFsdWUpJiZ2b2lkIDAhPT1DP0M6MCxsZWZ0U2hvdWxkZXI6bnVsbCE9PShvPW51bGw9PT0oRT1BLmJ1dHRvbnNbNF0pfHx2b2lkIDA9PT1FP3ZvaWQgMDpFLnZhbHVlKSYmdm9pZCAwIT09bz9vOjAscmlnaHRTaG91bGRlcjpudWxsIT09KG49bnVsbD09PShhPUEuYnV0dG9uc1s1XSl8fHZvaWQgMD09PWE/dm9pZCAwOmEudmFsdWUpJiZ2b2lkIDAhPT1uP246MCxsZWZ0VHJpZ2dlcjpudWxsIT09KHI9bnVsbD09PShzPUEuYnV0dG9uc1s2XSl8fHZvaWQgMD09PXM/dm9pZCAwOnMudmFsdWUpJiZ2b2lkIDAhPT1yP3I6MCxyaWdodFRyaWdnZXI6bnVsbCE9PShoPW51bGw9PT0oZD1BLmJ1dHRvbnNbN10pfHx2b2lkIDA9PT1kP3ZvaWQgMDpkLnZhbHVlKSYmdm9pZCAwIT09aD9oOjAsc2VsZWN0Om51bGwhPT0oRD1udWxsPT09KGM9QS5idXR0b25zWzhdKXx8dm9pZCAwPT09Yz92b2lkIDA6Yy52YWx1ZSkmJnZvaWQgMCE9PUQ/RDowLHN0YXJ0Om51bGwhPT0odT1udWxsPT09KHc9QS5idXR0b25zWzldKXx8dm9pZCAwPT09dz92b2lkIDA6dy52YWx1ZSkmJnZvaWQgMCE9PXU/dTowLGxlZnRTdGlja1ByZXNzZWQ6bnVsbCE9PShsPW51bGw9PT0oeT1BLmJ1dHRvbnNbMTBdKXx8dm9pZCAwPT09eT92b2lkIDA6eS52YWx1ZSkmJnZvaWQgMCE9PWw/bDowLHJpZ2h0U3RpY2tQcmVzc2VkOm51bGwhPT0oRj1udWxsPT09KFM9QS5idXR0b25zWzExXSl8fHZvaWQgMD09PVM/dm9pZCAwOlMudmFsdWUpJiZ2b2lkIDAhPT1GP0Y6MCxkcGFkVXA6bnVsbCE9PShHPW51bGw9PT0oUj1BLmJ1dHRvbnNbMTJdKXx8dm9pZCAwPT09Uj92b2lkIDA6Ui52YWx1ZSkmJnZvaWQgMCE9PUc/RzowLGRwYWREb3duOm51bGwhPT0ocD1udWxsPT09KGs9QS5idXR0b25zWzEzXSl8fHZvaWQgMD09PWs/dm9pZCAwOmsudmFsdWUpJiZ2b2lkIDAhPT1wP3A6MCxkcGFkTGVmdDpudWxsIT09KG09bnVsbD09PShVPUEuYnV0dG9uc1sxNF0pfHx2b2lkIDA9PT1VP3ZvaWQgMDpVLnZhbHVlKSYmdm9pZCAwIT09bT9tOjAsZHBhZFJpZ2h0Om51bGwhPT0oZj1udWxsPT09KE49QS5idXR0b25zWzE1XSl8fHZvaWQgMD09PU4/dm9pZCAwOk4udmFsdWUpJiZ2b2lkIDAhPT1mP2Y6MCxob21lOm51bGwhPT0oTD1udWxsPT09KE09QS5idXR0b25zWzE2XSl8fHZvaWQgMD09PU0/dm9pZCAwOk0udmFsdWUpJiZ2b2lkIDAhPT1MP0w6MH0sc3RpY2tzOntsZWZ0Ont4Om51bGwhPT0oSD1BLmF4ZXNbMF0pJiZ2b2lkIDAhPT1IP0g6MCx5Om51bGwhPT0oSz1BLmF4ZXNbMV0pJiZ2b2lkIDAhPT1LP0s6MH0scmlnaHQ6e3g6bnVsbCE9PSh2PUEuYXhlc1syXSkmJnZvaWQgMCE9PXY/djowLHk6bnVsbCE9PShxPUEuYXhlc1szXSkmJnZvaWQgMCE9PXE/cTowfX19fWZlZWRHYW1lcGFkSW5wdXRFdmVudChBKXt0aGlzLnJlcG9ydEdhbWVwYWRFdmVudHMoQSl9c3RhdGljIHZpYnJhdGVHYW1lcGFkKEEsSSl7dmFyIGcsZTtjb25zdCBCPW5hdmlnYXRvci5nZXRHYW1lcGFkcygpW0FdO2lmKG51bGw9PUI/dm9pZCAwOkIudmlicmF0aW9uQWN0dWF0b3IpbnVsbD09PShlPShnPUIudmlicmF0aW9uQWN0dWF0b3IpLnBsYXlFZmZlY3QpfHx2b2lkIDA9PT1lfHxlLmNhbGwoZyxcImR1YWwtcnVtYmxlXCIsSSk7ZWxzZSBpZihudWxsPT1CP3ZvaWQgMDpCLmhhcHRpY0FjdHVhdG9ycyl7Y29uc3QgQT1udWxsPT1CP3ZvaWQgMDpCLmhhcHRpY0FjdHVhdG9ycztzZXRUaW1lb3V0KCgoKT0+e3ZhciBnLGUsQjtmb3IoY29uc3QgaSBvZiBBKWlmKFwicHVsc2VcImluIGkpe2NvbnN0IEE9TWF0aC5tYXgobnVsbCE9PShnPUkuc3Ryb25nTWFnbml0dWRlKSYmdm9pZCAwIT09Zz9nOjAsbnVsbCE9PShlPUkud2Vha01hZ25pdHVkZSkmJnZvaWQgMCE9PWU/ZTowKTtpLnB1bHNlKEEsbnVsbCE9PShCPUkuZHVyYXRpb24pJiZ2b2lkIDAhPT1CP0I6MCl9fSksSS5zdGFydERlbGF5KX19ZmVlZEtleWJvYXJkRXZlbnQoQSl7dGhpcy5vbktleWJvYXJkRXZlbnQoQSl9cmVsZWFzZUtleXMoKXtmb3IoY29uc3QgQSBvZiB0aGlzLmhlbGRLZXlzKXRoaXMuc2VuZElucHV0RGF0YWdyYW0oe2Rpc2NyaW1pbmF0b3I6RS5LZXlib2FyZElucHV0LmRpc2NyaW1pbmF0b3IsdmFsdWU6e2FjdGlvbjpFLktleWJvYXJkQWN0aW9uLktleVVwLGtleWNvZGU6QX19KTt0aGlzLmhlbGRLZXlzLmNsZWFyKCl9ZmVlZFBvaW50ZXJFdmVudChBKXt0aGlzLm9uUG9pbnRlckV2ZW50KEEpfWZlZWRXaGVlbEV2ZW50KEEpe3RoaXMub25XaGVlbEV2ZW50KEEpfXByb2Nlc3NDdXJzb3IoQSl7dGhpcy5jdXJzb3JQYWludGVyLnByb2Nlc3NDdXJzb3IoQSl9ZW5hYmxlR2VzdHVyZXMoKXt0aGlzLm9wdGlvbnMudG91Y2hHZXN0dXJlcz0hMH1kaXNhYmxlR2VzdHVyZXMoKXt0aGlzLm9wdGlvbnMudG91Y2hHZXN0dXJlcz0hMX1zZW5kTW91c2VNb3ZlKEEsSSxnKXtcImFic29sdXRlXCI9PT1BP3RoaXMuc2VuZElucHV0RGF0YWdyYW0oe2Rpc2NyaW1pbmF0b3I6RS5Nb3VzZUFic29sdXRlLmRpc2NyaW1pbmF0b3IsdmFsdWU6e3g6SSx5Omd9fSk6dGhpcy5zZW5kSW5wdXREYXRhZ3JhbSh7ZGlzY3JpbWluYXRvcjpFLk1vdXNlUmVsYXRpdmUuZGlzY3JpbWluYXRvcix2YWx1ZTp7ZHg6SSxkeTpnfX0pfXNlbmRNb3VzZUNsaWNrKEEpe3RoaXMuc2VuZElucHV0RGF0YWdyYW0oe2Rpc2NyaW1pbmF0b3I6RS5Nb3VzZUNsaWNrLmRpc2NyaW1pbmF0b3IsdmFsdWU6QX0pfXNlbmRJbnB1dERhdGFncmFtKEEpe2NvbnN0IEk9by50b091dGdvaW5nSW5wdXQoQSk7SSYmdGhpcy5vdXRnb2luZ0lucHV0RmlsdGVyKEksbmV3IG8uSGVsZEtleXModGhpcy5oZWxkS2V5cykpJiZ0aGlzLnJhaW53YXlTdHJlYW0uc2VuZElucHV0KEEpfWRpc3Bvc2UoKXt0aGlzLnVuc2V0Q29udGFpbmVyKCl9fX0sODg0OihBLEksZyk9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkoSSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxJLkhlbGRLZXlzPUkudG9PdXRnb2luZ0lucHV0PUkuSW5wdXRUeXBlPXZvaWQgMDtjb25zdCBlPWcoOTA0KTt2YXIgQjshZnVuY3Rpb24oQSl7QVtBLkdhbWVwYWQ9MF09XCJHYW1lcGFkXCIsQVtBLk1vdXNlQWJzb2x1dGU9MV09XCJNb3VzZUFic29sdXRlXCIsQVtBLk1vdXNlUmVsYXRpdmU9Ml09XCJNb3VzZVJlbGF0aXZlXCIsQVtBLk1vdXNlQ2xpY2s9M109XCJNb3VzZUNsaWNrXCIsQVtBLk1vdXNlU2Nyb2xsPTRdPVwiTW91c2VTY3JvbGxcIixBW0EuS2V5Ym9hcmQ9NV09XCJLZXlib2FyZFwiLEFbQS5QYXN0ZVRleHQ9Nl09XCJQYXN0ZVRleHRcIixBW0EuVG91Y2hlc0Fic29sdXRlPTddPVwiVG91Y2hlc0Fic29sdXRlXCIsQVtBLlBlbkFic29sdXRlPThdPVwiUGVuQWJzb2x1dGVcIixBW0EuVmlld3BvcnRSZXNpemU9OV09XCJWaWV3cG9ydFJlc2l6ZVwiLEFbQS5TZXRDbGlwYm9hcmRUZXh0PTEwXT1cIlNldENsaXBib2FyZFRleHRcIn0oQj1JLklucHV0VHlwZXx8KEkuSW5wdXRUeXBlPXt9KSksSS50b091dGdvaW5nSW5wdXQ9ZnVuY3Rpb24oQSl7c3dpdGNoKEEuZGlzY3JpbWluYXRvcil7Y2FzZSBlLkdhbWVwYWRSZXBvcnQuZGlzY3JpbWluYXRvcjpyZXR1cm4gT2JqZWN0LmFzc2lnbih7dHlwZTpCLkdhbWVwYWR9LEEudmFsdWUpO2Nhc2UgZS5HYW1lcGFkUnVtYmxlLmRpc2NyaW1pbmF0b3I6cmV0dXJuO2Nhc2UgZS5Nb3VzZUFic29sdXRlLmRpc2NyaW1pbmF0b3I6cmV0dXJuIE9iamVjdC5hc3NpZ24oe3R5cGU6Qi5Nb3VzZUFic29sdXRlfSxBLnZhbHVlKTtjYXNlIGUuTW91c2VSZWxhdGl2ZS5kaXNjcmltaW5hdG9yOnJldHVybiBPYmplY3QuYXNzaWduKHt0eXBlOkIuTW91c2VSZWxhdGl2ZX0sQS52YWx1ZSk7Y2FzZSBlLk1vdXNlQ2xpY2suZGlzY3JpbWluYXRvcjpyZXR1cm4gT2JqZWN0LmFzc2lnbih7dHlwZTpCLk1vdXNlQ2xpY2t9LEEudmFsdWUpO2Nhc2UgZS5Nb3VzZVNjcm9sbC5kaXNjcmltaW5hdG9yOnJldHVybiBPYmplY3QuYXNzaWduKHt0eXBlOkIuTW91c2VTY3JvbGx9LEEudmFsdWUpO2Nhc2UgZS5LZXlib2FyZElucHV0LmRpc2NyaW1pbmF0b3I6e2NvbnN0IEk9QS52YWx1ZS5rZXljb2RlO3JldHVybnt0eXBlOkIuS2V5Ym9hcmQsYWN0aW9uOkEudmFsdWUuYWN0aW9uLGtleTpJfX1jYXNlIGUuTG9naWNhbElucHV0LmRpc2NyaW1pbmF0b3I6cmV0dXJuIE9iamVjdC5hc3NpZ24oe3R5cGU6Qi5QYXN0ZVRleHR9LEEudmFsdWUpO2Nhc2UgZS5Ub3VjaGVzQWJzb2x1dGUuZGlzY3JpbWluYXRvcjpyZXR1cm4gT2JqZWN0LmFzc2lnbih7dHlwZTpCLlRvdWNoZXNBYnNvbHV0ZX0sQS52YWx1ZSk7Y2FzZSBlLlBlbkFic29sdXRlLmRpc2NyaW1pbmF0b3I6cmV0dXJuIE9iamVjdC5hc3NpZ24oe3R5cGU6Qi5QZW5BYnNvbHV0ZX0sQS52YWx1ZSk7Y2FzZSBlLlZpZXdwb3J0UmVzaXplLmRpc2NyaW1pbmF0b3I6cmV0dXJuIE9iamVjdC5hc3NpZ24oe3R5cGU6Qi5WaWV3cG9ydFJlc2l6ZX0sQS52YWx1ZSk7Y2FzZSBlLlNldENsaXBib2FyZFRleHQuZGlzY3JpbWluYXRvcjpyZXR1cm4gT2JqZWN0LmFzc2lnbih7dHlwZTpCLlNldENsaXBib2FyZFRleHR9LEEudmFsdWUpfX0sSS5IZWxkS2V5cz1jbGFzc3tjb25zdHJ1Y3RvcihBKXt0aGlzLmhlbGRLZXlzPUF9Z2V0IGtleXMoKXtyZXR1cm4gdGhpcy5oZWxkS2V5c31oYXMoQSl7cmV0dXJuIHRoaXMuaGVsZEtleXMuaGFzKEEpfWdldCBjdHJsKCl7cmV0dXJuIHRoaXMuaGVsZEtleXMuaGFzKGUuVmlydHVhbEtleS5MZWZ0Q3RybCl8fHRoaXMuaGVsZEtleXMuaGFzKGUuVmlydHVhbEtleS5SaWdodEN0cmwpfWdldCBhbHQoKXtyZXR1cm4gdGhpcy5oZWxkS2V5cy5oYXMoZS5WaXJ0dWFsS2V5LkxlZnRBbHQpfHx0aGlzLmhlbGRLZXlzLmhhcyhlLlZpcnR1YWxLZXkuUmlnaHRBbHQpfWdldCB3aW4oKXtyZXR1cm4gdGhpcy5oZWxkS2V5cy5oYXMoZS5WaXJ0dWFsS2V5LkxXaW4pfHx0aGlzLmhlbGRLZXlzLmhhcyhlLlZpcnR1YWxLZXkuUldpbil9Z2V0IHNoaWZ0KCl7cmV0dXJuIHRoaXMuaGVsZEtleXMuaGFzKGUuVmlydHVhbEtleS5MZWZ0U2hpZnQpfHx0aGlzLmhlbGRLZXlzLmhhcyhlLlZpcnR1YWxLZXkuUmlnaHRTaGlmdCl9fX0sNDA6KEEsSSxnKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eShJLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLEkuUmFpbndheVZpcnR1YWxLZXlGcm9tV2ViS2V5Q29kZT12b2lkIDA7Y29uc3QgZT1nKDkwNCk7SS5SYWlud2F5VmlydHVhbEtleUZyb21XZWJLZXlDb2RlPXtVbmlkZW50aWZpZWQ6ZS5WaXJ0dWFsS2V5Lk5vbmUsQ2FuY2VsOmUuVmlydHVhbEtleS5DYW5jZWwsQmFja3NwYWNlOmUuVmlydHVhbEtleS5CYWNrLFRhYjplLlZpcnR1YWxLZXkuVGFiLEVudGVyOmUuVmlydHVhbEtleS5FbnRlcixQYXVzZTplLlZpcnR1YWxLZXkuUGF1c2UsQ2Fwc0xvY2s6ZS5WaXJ0dWFsS2V5LkNhcHNMb2NrLEhhbmd1bE1vZGU6ZS5WaXJ0dWFsS2V5Lkhhbmd1bE1vZGUsS2FuYU1vZGU6ZS5WaXJ0dWFsS2V5Lkhhbmd1bE1vZGUsTGFuZzE6ZS5WaXJ0dWFsS2V5Lkhhbmd1bE1vZGUsSGFuamE6ZS5WaXJ0dWFsS2V5LkhhbmphTW9kZSxMYW5nMjplLlZpcnR1YWxLZXkuSGFuamFNb2RlLEVzY2FwZTplLlZpcnR1YWxLZXkuRXNjYXBlLENvbnZlcnQ6ZS5WaXJ0dWFsS2V5LkltZUNvbnZlcnQsTm9uQ29udmVydDplLlZpcnR1YWxLZXkuSW1lTm9uQ29udmVydCxTcGFjZTplLlZpcnR1YWxLZXkuU3BhY2UsXCIgXCI6ZS5WaXJ0dWFsS2V5LlNwYWNlLFNwYWNlYmFyOmUuVmlydHVhbEtleS5TcGFjZSxQYWdlVXA6ZS5WaXJ0dWFsS2V5LlBhZ2VVcCxQYWdlRG93bjplLlZpcnR1YWxLZXkuUGFnZURvd24sRW5kOmUuVmlydHVhbEtleS5FbmQsSG9tZTplLlZpcnR1YWxLZXkuSG9tZSxBcnJvd0xlZnQ6ZS5WaXJ0dWFsS2V5LkxlZnQsQXJyb3dVcDplLlZpcnR1YWxLZXkuVXAsQXJyb3dSaWdodDplLlZpcnR1YWxLZXkuUmlnaHQsQXJyb3dEb3duOmUuVmlydHVhbEtleS5Eb3duLFNlbGVjdDplLlZpcnR1YWxLZXkuU2VsZWN0LFByaW50U2NyZWVuOmUuVmlydHVhbEtleS5QcmludFNjcmVlbixJbnNlcnQ6ZS5WaXJ0dWFsS2V5Lkluc2VydCxEZWxldGU6ZS5WaXJ0dWFsS2V5LkRlbGV0ZSxIZWxwOmUuVmlydHVhbEtleS5IZWxwLERpZ2l0MDplLlZpcnR1YWxLZXkuRDAsRGlnaXQxOmUuVmlydHVhbEtleS5EMSxEaWdpdDI6ZS5WaXJ0dWFsS2V5LkQyLERpZ2l0MzplLlZpcnR1YWxLZXkuRDMsRGlnaXQ0OmUuVmlydHVhbEtleS5ENCxEaWdpdDU6ZS5WaXJ0dWFsS2V5LkQ1LERpZ2l0NjplLlZpcnR1YWxLZXkuRDYsRGlnaXQ3OmUuVmlydHVhbEtleS5ENyxEaWdpdDg6ZS5WaXJ0dWFsS2V5LkQ4LERpZ2l0OTplLlZpcnR1YWxLZXkuRDksS2V5QTplLlZpcnR1YWxLZXkuQSxLZXlCOmUuVmlydHVhbEtleS5CLEtleUM6ZS5WaXJ0dWFsS2V5LkMsS2V5RDplLlZpcnR1YWxLZXkuRCxLZXlFOmUuVmlydHVhbEtleS5FLEtleUY6ZS5WaXJ0dWFsS2V5LkYsS2V5RzplLlZpcnR1YWxLZXkuRyxLZXlIOmUuVmlydHVhbEtleS5ILEtleUk6ZS5WaXJ0dWFsS2V5LkksS2V5SjplLlZpcnR1YWxLZXkuSixLZXlLOmUuVmlydHVhbEtleS5LLEtleUw6ZS5WaXJ0dWFsS2V5LkwsS2V5TTplLlZpcnR1YWxLZXkuTSxLZXlOOmUuVmlydHVhbEtleS5OLEtleU86ZS5WaXJ0dWFsS2V5Lk8sS2V5UDplLlZpcnR1YWxLZXkuUCxLZXlROmUuVmlydHVhbEtleS5RLEtleVI6ZS5WaXJ0dWFsS2V5LlIsS2V5UzplLlZpcnR1YWxLZXkuUyxLZXlUOmUuVmlydHVhbEtleS5ULEtleVU6ZS5WaXJ0dWFsS2V5LlUsS2V5VjplLlZpcnR1YWxLZXkuVixLZXlXOmUuVmlydHVhbEtleS5XLEtleVg6ZS5WaXJ0dWFsS2V5LlgsS2V5WTplLlZpcnR1YWxLZXkuWSxLZXlaOmUuVmlydHVhbEtleS5aLE1ldGFMZWZ0OmUuVmlydHVhbEtleS5MV2luLE9TTGVmdDplLlZpcnR1YWxLZXkuTFdpbixNZXRhUmlnaHQ6ZS5WaXJ0dWFsS2V5LlJXaW4sT1NSaWdodDplLlZpcnR1YWxLZXkuUldpbixDb250ZXh0TWVudTplLlZpcnR1YWxLZXkuQXBwcyxTbGVlcDplLlZpcnR1YWxLZXkuU2xlZXAsTnVtcGFkMDplLlZpcnR1YWxLZXkuTnVtUGFkMCxOdW1wYWQxOmUuVmlydHVhbEtleS5OdW1QYWQxLE51bXBhZDI6ZS5WaXJ0dWFsS2V5Lk51bVBhZDIsTnVtcGFkMzplLlZpcnR1YWxLZXkuTnVtUGFkMyxOdW1wYWQ0OmUuVmlydHVhbEtleS5OdW1QYWQ0LE51bXBhZDU6ZS5WaXJ0dWFsS2V5Lk51bVBhZDUsTnVtcGFkNjplLlZpcnR1YWxLZXkuTnVtUGFkNixOdW1wYWQ3OmUuVmlydHVhbEtleS5OdW1QYWQ3LE51bXBhZDg6ZS5WaXJ0dWFsS2V5Lk51bVBhZDgsTnVtcGFkOTplLlZpcnR1YWxLZXkuTnVtUGFkOSxOdW1wYWRNdWx0aXBseTplLlZpcnR1YWxLZXkuTXVsdGlwbHksTnVtcGFkQWRkOmUuVmlydHVhbEtleS5BZGQsTnVtcGFkQ29tbWE6ZS5WaXJ0dWFsS2V5LlNlcGFyYXRvcixOdW1wYWRTdWJ0cmFjdDplLlZpcnR1YWxLZXkuU3VidHJhY3QsTnVtcGFkRGVjaW1hbDplLlZpcnR1YWxLZXkuRGVjaW1hbCxOdW1wYWREaXZpZGU6ZS5WaXJ0dWFsS2V5LkRpdmlkZSxGMTplLlZpcnR1YWxLZXkuRjEsRjI6ZS5WaXJ0dWFsS2V5LkYyLEYzOmUuVmlydHVhbEtleS5GMyxGNDplLlZpcnR1YWxLZXkuRjQsRjU6ZS5WaXJ0dWFsS2V5LkY1LEY2OmUuVmlydHVhbEtleS5GNixGNzplLlZpcnR1YWxLZXkuRjcsRjg6ZS5WaXJ0dWFsS2V5LkY4LEY5OmUuVmlydHVhbEtleS5GOSxGMTA6ZS5WaXJ0dWFsS2V5LkYxMCxGMTE6ZS5WaXJ0dWFsS2V5LkYxMSxGMTI6ZS5WaXJ0dWFsS2V5LkYxMixGMTM6ZS5WaXJ0dWFsS2V5LkYxMyxGMTQ6ZS5WaXJ0dWFsS2V5LkYxNCxGMTU6ZS5WaXJ0dWFsS2V5LkYxNSxGMTY6ZS5WaXJ0dWFsS2V5LkYxNixGMTc6ZS5WaXJ0dWFsS2V5LkYxNyxGMTg6ZS5WaXJ0dWFsS2V5LkYxOCxGMTk6ZS5WaXJ0dWFsS2V5LkYxOSxGMjA6ZS5WaXJ0dWFsS2V5LkYyMCxGMjE6ZS5WaXJ0dWFsS2V5LkYyMSxGMjI6ZS5WaXJ0dWFsS2V5LkYyMixGMjM6ZS5WaXJ0dWFsS2V5LkYyMyxGMjQ6ZS5WaXJ0dWFsS2V5LkYyNCxOdW1Mb2NrOmUuVmlydHVhbEtleS5OdW1Mb2NrLFNjcm9sbExvY2s6ZS5WaXJ0dWFsS2V5LlNjcm9sbCxTaGlmdExlZnQ6ZS5WaXJ0dWFsS2V5LkxlZnRTaGlmdCxTaGlmdFJpZ2h0OmUuVmlydHVhbEtleS5SaWdodFNoaWZ0LENvbnRyb2xMZWZ0OmUuVmlydHVhbEtleS5MZWZ0Q3RybCxDb250cm9sUmlnaHQ6ZS5WaXJ0dWFsS2V5LlJpZ2h0Q3RybCxBbHRMZWZ0OmUuVmlydHVhbEtleS5MZWZ0QWx0LEFsdFJpZ2h0OmUuVmlydHVhbEtleS5SaWdodEFsdCxCcm93c2VyQmFjazplLlZpcnR1YWxLZXkuQnJvd3NlckJhY2ssQnJvd3NlckZvcndhcmQ6ZS5WaXJ0dWFsS2V5LkJyb3dzZXJGb3J3YXJkLEJyb3dzZXJSZWZyZXNoOmUuVmlydHVhbEtleS5Ccm93c2VyUmVmcmVzaCxCcm93c2VyU3RvcDplLlZpcnR1YWxLZXkuQnJvd3NlclN0b3AsQnJvd3NlclNlYXJjaDplLlZpcnR1YWxLZXkuQnJvd3NlclNlYXJjaCxCcm93c2VyRmF2b3JpdGVzOmUuVmlydHVhbEtleS5Ccm93c2VyRmF2b3JpdGVzLEJyb3dzZXJIb21lOmUuVmlydHVhbEtleS5Ccm93c2VySG9tZSxBdWRpb1ZvbHVtZU11dGU6ZS5WaXJ0dWFsS2V5LlZvbHVtZU11dGUsQXVkaW9Wb2x1bWVEb3duOmUuVmlydHVhbEtleS5Wb2x1bWVEb3duLEF1ZGlvVm9sdW1lVXA6ZS5WaXJ0dWFsS2V5LlZvbHVtZVVwLE1lZGlhVHJhY2tOZXh0OmUuVmlydHVhbEtleS5NZWRpYU5leHRUcmFjayxNZWRpYVRyYWNrUHJldmlvdXM6ZS5WaXJ0dWFsS2V5Lk1lZGlhUHJldmlvdXNUcmFjayxNZWRpYVN0b3A6ZS5WaXJ0dWFsS2V5Lk1lZGlhU3RvcCxNZWRpYVBsYXlQYXVzZTplLlZpcnR1YWxLZXkuTWVkaWFQbGF5UGF1c2UsTGF1bmNoTWFpbDplLlZpcnR1YWxLZXkuTGF1bmNoTWFpbCxMYXVuY2hNZWRpYVBsYXllcjplLlZpcnR1YWxLZXkuU2VsZWN0TWVkaWEsTWVkaWFTZWxlY3Q6ZS5WaXJ0dWFsS2V5LlNlbGVjdE1lZGlhLExhdW5jaEFwcDE6ZS5WaXJ0dWFsS2V5LkxhdW5jaEFwcGxpY2F0aW9uMSxMYXVuY2hBcHAyOmUuVmlydHVhbEtleS5MYXVuY2hBcHBsaWNhdGlvbjIsU2VtaWNvbG9uOmUuVmlydHVhbEtleS5PZW0xLEVxdWFsOmUuVmlydHVhbEtleS5PZW1QbHVzLENvbW1hOmUuVmlydHVhbEtleS5PZW1Db21tYSxNaW51czplLlZpcnR1YWxLZXkuT2VtTWludXMsUGVyaW9kOmUuVmlydHVhbEtleS5PZW1QZXJpb2QsU2xhc2g6ZS5WaXJ0dWFsS2V5Lk9lbTIsQmFja3F1b3RlOmUuVmlydHVhbEtleS5PZW0zLEJyYWNrZXRMZWZ0OmUuVmlydHVhbEtleS5PZW00LEJhY2tzbGFzaDplLlZpcnR1YWxLZXkuT2VtNSxCcmFja2V0UmlnaHQ6ZS5WaXJ0dWFsS2V5Lk9lbTYsUXVvdGU6ZS5WaXJ0dWFsS2V5Lk9lbTcsSW50bEJhY2tzbGFzaDplLlZpcnR1YWxLZXkuT2VtMTAyfX0sNDY0OihBLEkpPT57XCJ1c2Ugc3RyaWN0XCI7dmFyIGc7T2JqZWN0LmRlZmluZVByb3BlcnR5KEksXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksSS5SYWlud2F5TG9nZ2luZz1JLlJhaW53YXlMb2dMZXZlbD12b2lkIDAsZnVuY3Rpb24oQSl7QVtBLlRyYWNlPTBdPVwiVHJhY2VcIixBW0EuRGVidWc9MV09XCJEZWJ1Z1wiLEFbQS5JbmZvcm1hdGlvbj0yXT1cIkluZm9ybWF0aW9uXCIsQVtBLldhcm5pbmc9M109XCJXYXJuaW5nXCIsQVtBLkVycm9yPTRdPVwiRXJyb3JcIixBW0EuQ3JpdGljYWw9NV09XCJDcml0aWNhbFwiLEFbQS5TaWxlbnQ9Nl09XCJTaWxlbnRcIn0oZz1JLlJhaW53YXlMb2dMZXZlbHx8KEkuUmFpbndheUxvZ0xldmVsPXt9KSk7Y2xhc3MgZXtzdGF0aWMgc2V0TG9nU2luayhBKXtlLl9sb2dTaW5rPUF9c3RhdGljIGxvZyhBLEkpe3ZhciBnO251bGw9PT0oZz1lLl9sb2dTaW5rKXx8dm9pZCAwPT09Z3x8Zy5jYWxsKGUsQSxJKX19SS5SYWlud2F5TG9nZ2luZz1lLGUudHJhY2U9QT0+ZS5sb2coZy5UcmFjZSxBKSxlLmRlYnVnPUE9PmUubG9nKGcuRGVidWcsQSksZS5pbmZvcm1hdGlvbj1BPT5lLmxvZyhnLkluZm9ybWF0aW9uLEEpLGUud2FybmluZz1BPT5lLmxvZyhnLldhcm5pbmcsQSksZS5lcnJvcj1BPT5lLmxvZyhnLkVycm9yLEEpLGUuY3JpdGljYWw9QT0+ZS5sb2coZy5Dcml0aWNhbCxBKX0sNTg1OmZ1bmN0aW9uKEEsSSxnKXtcInVzZSBzdHJpY3RcIjt2YXIgZT10aGlzJiZ0aGlzLl9fYXdhaXRlcnx8ZnVuY3Rpb24oQSxJLGcsZSl7cmV0dXJuIG5ldyhnfHwoZz1Qcm9taXNlKSkoKGZ1bmN0aW9uKEIsaSl7ZnVuY3Rpb24gdChBKXt0cnl7QyhlLm5leHQoQSkpfWNhdGNoKEEpe2koQSl9fWZ1bmN0aW9uIFEoQSl7dHJ5e0MoZS50aHJvdyhBKSl9Y2F0Y2goQSl7aShBKX19ZnVuY3Rpb24gQyhBKXt2YXIgSTtBLmRvbmU/QihBLnZhbHVlKTooST1BLnZhbHVlLEkgaW5zdGFuY2VvZiBnP0k6bmV3IGcoKGZ1bmN0aW9uKEEpe0EoSSl9KSkpLnRoZW4odCxRKX1DKChlPWUuYXBwbHkoQSxJfHxbXSkpLm5leHQoKSl9KSl9LEI9dGhpcyYmdGhpcy5fX2ltcG9ydERlZmF1bHR8fGZ1bmN0aW9uKEEpe3JldHVybiBBJiZBLl9fZXNNb2R1bGU/QTp7ZGVmYXVsdDpBfX07T2JqZWN0LmRlZmluZVByb3BlcnR5KEksXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksSS5BdWRpb1N0cmVhbT12b2lkIDA7Y29uc3QgaT1CKGcoNTMpKSx0PWcoOTk0KSxRPWcoNDY0KTtJLkF1ZGlvU3RyZWFtPWNsYXNze2NvbnN0cnVjdG9yKCl7dGhpcy5zYW1wbGVSYXRlSHo9NDhlMyx0aGlzLnNhbXBsZVJhdGVLaHo9NDgsdGhpcy5jaGFubmVsQ291bnQ9Mix0aGlzLmRlY29kZWRDb3VudD0wLHRoaXMudG90YWxTYW1wbGVzRGVjb2RlZD0wLHRoaXMud2FpdGluZ1RvRGVjb2RlUXVldWU9W10sdGhpcy5kZWNvZGVRdWV1ZVNpemU9MCx0aGlzLmxvZ1BlcmZvcm1hbmNlPSExLHRoaXMubWF4RGVjb2RpbmdUaW1lTXM9MCx0aGlzLnRvdGFsRGVjb2RpbmdUaW1lTXM9MCx0aGlzLnRvdGFsUXVldWVkU2l6ZT0wLHRoaXMubWF4UXVldWVkU2l6ZT0wLHRoaXMuc3RhcnRTdHJlYW1UaW1lTXM9MCx0aGlzLm91dHB1dEJ1ZmZlcnM9W10sdGhpcy5jdXJyZW50T3V0cHV0QnVmZmVyPXZvaWQgMCx0aGlzLmN1cnJlbnRCdWZmZXJSZWFkSW5kZXg9MCx0aGlzLm5leHRTdGFydFRpbWU9dm9pZCAwLHRoaXMucGxheWluZz0hMSx0aGlzLmRhdGFEdXJhdGlvbk1zPTEwLHRoaXMubWluTGF0ZW5jeU1zPTYwLHRoaXMubWF4TGF0ZW5jeU1zPTEwMCx0aGlzLnByZXZEcm9wcGVkRnJhbWVUaW1lTXM9dm9pZCAwLHRoaXMuZGVjb2RlZFNhbXBsZXNQZXJGcmFtZT0wLHRoaXMuYXVkaW9CdWZmZXJTaXplPTAsdGhpcy5hdWRpb0J1ZmZlclBvb2w9W10sdGhpcy5tYXhBdWRpb0J1ZmZlclBvb2xDb3VudD01LHRoaXMucmVzYW1wbGVkQXVkaW9CdWZmZXJTaXplPTAsdGhpcy5vbkRlY29kZT0oe3N0YXJ0VGltZXN0YW1wOkEsb3V0cHV0RGF0YTpJLHNhbXBsZXNEZWNvZGVkOmd9KT0+ey0tdGhpcy5kZWNvZGVRdWV1ZVNpemU7Y29uc3QgZT1uZXcgRmxvYXQzMkFycmF5KEkpO3RoaXMub3V0cHV0QnVmZmVycy5wdXNoKGUpO3RyeXtpZihnPjAmJigrK3RoaXMuZGVjb2RlZENvdW50LHRoaXMudG90YWxTYW1wbGVzRGVjb2RlZCs9Zyx0aGlzLmxvZ1BlcmZvcm1hbmNlJiZ0aGlzLmxvZ1BlcmZUaW1pbmcoQSksdGhpcy50b3RhbFNhbXBsZXNEZWNvZGVkPj10aGlzLmF1ZGlvQnVmZmVyU2l6ZSYmKHRoaXMubmV4dFN0YXJ0VGltZSYmdGhpcy5uZXh0U3RhcnRUaW1lPHRoaXMuYXVkaW9Db250ZXh0LmN1cnJlbnRUaW1lJiYodGhpcy5uZXh0U3RhcnRUaW1lPXZvaWQgMCksdGhpcy5uZXh0U3RhcnRUaW1lfHx0aGlzLnRvdGFsU2FtcGxlc0RlY29kZWQ+PTIqdGhpcy5hdWRpb0J1ZmZlclNpemUpKSl7Y29uc3QgQT1NYXRoLmZsb29yKHRoaXMudG90YWxTYW1wbGVzRGVjb2RlZC90aGlzLmF1ZGlvQnVmZmVyU2l6ZSk7Zm9yKGxldCBJPTA7STxBOysrSSl7Y29uc3QgQT10aGlzLm5leHRTdGFydFRpbWU/MWUzKih0aGlzLm5leHRTdGFydFRpbWUtdGhpcy5hdWRpb0NvbnRleHQuY3VycmVudFRpbWUpOjA7aWYoQT50aGlzLm1heExhdGVuY3lNcyl7bGV0IEk9MDtjb25zdCBnPURhdGUubm93KCksZT10aGlzLnByZXZEcm9wcGVkRnJhbWVUaW1lTXM/Zy10aGlzLnByZXZEcm9wcGVkRnJhbWVUaW1lTXM6dm9pZCAwLEI9MWU0O2lmKGUmJmU8QilJPXRoaXMuZHJvcERlY29kZWRTYW1wbGVzKHRoaXMudG90YWxTYW1wbGVzRGVjb2RlZCk7ZWxzZXtjb25zdCBnPUEtdGhpcy5tYXhMYXRlbmN5TXMrdGhpcy5kYXRhRHVyYXRpb25NcyxlPU1hdGguZmxvb3IodGhpcy5zYW1wbGVSYXRlS2h6KmcpO0k9dGhpcy5kcm9wRGVjb2RlZFNhbXBsZXMoZSl9dGhpcy5wcmV2RHJvcHBlZEZyYW1lVGltZU1zPWcsdGhpcy50b3RhbFNhbXBsZXNEZWNvZGVkLT1JfWlmKCEodGhpcy50b3RhbFNhbXBsZXNEZWNvZGVkPj10aGlzLmF1ZGlvQnVmZmVyU2l6ZSkpYnJlYWs7e2NvbnN0IEE9dGhpcy5jb3B5RGVjb2RlZFNhbXBsZXNUb0F1ZGlvQnVmZmVyKCk7dGhpcy5zY2hlZHVsZUJ1ZmZlckZvclBsYXliYWNrRnVuYyhBKSx0aGlzLnRvdGFsU2FtcGxlc0RlY29kZWQtPUEubGVuZ3RofX19fWNhdGNoKEEpe1EuUmFpbndheUxvZ2dpbmcud2FybmluZyhcIkNhdWdodCBleGNlcHRpb24gaW4gQXVkaW9TdHJlYW0gb25EZWNvZGU6IFwiK0ErXCIgXCIrQS5zdGFjayksdGhpcy5zdG9wKCksdGhpcy5wbGF5KCl9dGhpcy5zZW5kRGVjb2RlcldhaXRpbmdUb0RlY29kZUZyYW1lcygpfX1pbml0aWFsaXplKCl7cmV0dXJuIGUodGhpcyx2b2lkIDAsdm9pZCAwLChmdW5jdGlvbiooKXt0aGlzLm9wdXNEZWNvZGVyV29ya2VyPW5ldyBpLmRlZmF1bHQseWllbGQgdGhpcy5vcHVzRGVjb2Rlcldvcmtlci5pbml0aWFsaXplKCksdGhpcy5vcHVzRGVjb2Rlcldvcmtlci5vbkRlY29kZT10aGlzLm9uRGVjb2RlLmJpbmQodGhpcyl9KSl9ZGlzcG9zZSgpe3ZhciBBO251bGw9PT0oQT10aGlzLm9wdXNEZWNvZGVyV29ya2VyKXx8dm9pZCAwPT09QXx8QS5kaXNwb3NlKCksdGhpcy5vcHVzRGVjb2Rlcldvcmtlcj12b2lkIDB9Y29uZmlndXJlKHthdWRpb0NvbnRleHQ6QSxzYW1wbGVSYXRlSHo6SSxjaGFubmVsQ291bnQ6ZyxkYXRhRHVyYXRpb25NczplLG1pbkxhdGVuY3lNczpCLG1heExhdGVuY3lNczppfSl7aWYodGhpcy5zYW1wbGVSYXRlSHo9bnVsbCE9ST9JOnRoaXMuc2FtcGxlUmF0ZUh6LDhlMyE9dGhpcy5zYW1wbGVSYXRlSHomJjEyZTMhPXRoaXMuc2FtcGxlUmF0ZUh6JiYxNmUzIT10aGlzLnNhbXBsZVJhdGVIeiYmMjRlMyE9dGhpcy5zYW1wbGVSYXRlSHomJjQ4ZTMhPXRoaXMuc2FtcGxlUmF0ZUh6KXRocm93IG5ldyB0LlJhaW53YXlFcnJvcihgaW52YWxpZCBhdWRpbyBzYW1wbGUgcmF0ZTogJHt0aGlzLnNhbXBsZVJhdGVIen0gKG11c3QgYmUgODAwMCwgMTIwMDAsIDE2MDAwLCAyNDAwMCwgb3IgNDgwMDApYCk7aWYodGhpcy5zYW1wbGVSYXRlS2h6PXRoaXMuc2FtcGxlUmF0ZUh6LzFlMyx0aGlzLmNoYW5uZWxDb3VudD1udWxsIT1nP2c6dGhpcy5jaGFubmVsQ291bnQsMSE9dGhpcy5jaGFubmVsQ291bnQmJjIhPXRoaXMuY2hhbm5lbENvdW50JiY2IT10aGlzLmNoYW5uZWxDb3VudCl0aHJvdyBuZXcgdC5SYWlud2F5RXJyb3IoYGludmFsaWQgY2hhbm5lbCBjb3VudDogJHt0aGlzLmNoYW5uZWxDb3VudH0gKG11c3QgYmUgMSwgMiwgb3IgNilgKTtpZih0aGlzLmRhdGFEdXJhdGlvbk1zPW51bGwhPWU/ZTp0aGlzLmRhdGFEdXJhdGlvbk1zLHRoaXMubWluTGF0ZW5jeU1zPW51bGwhPUI/Qjp0aGlzLm1pbkxhdGVuY3lNcyx0aGlzLm1heExhdGVuY3lNcz1udWxsIT1pP2k6dGhpcy5tYXhMYXRlbmN5TXMsdGhpcy5kYXRhRHVyYXRpb25Nczw9MCl0aHJvdyBuZXcgdC5SYWlud2F5RXJyb3IoYGRhdGFEdXJhdGlvbk1zIG11c3QgYmUgcG9zaXRpdmUsIGJ1dCBpcyAke3RoaXMuZGF0YUR1cmF0aW9uTXN9YCk7aWYodGhpcy5kYXRhRHVyYXRpb25Ncz50aGlzLm1pbkxhdGVuY3lNcyl0aHJvdyBuZXcgdC5SYWlud2F5RXJyb3IoXCJkYXRhRHVyYXRpb25NcyBtYXkgbm90IGV4Y2VlZCBtaW5MYXRlbmN5TXNcIik7aWYodGhpcy5tYXhMYXRlbmN5TXM8PXRoaXMubWluTGF0ZW5jeU1zKXRocm93IG5ldyB0LlJhaW53YXlFcnJvcihcIm1heExhdGVuY3lNcyBtdXN0IGJlIGdyZWF0ZXIgdGhhbiBtaW5MYXRlbmN5TXNcIik7dGhpcy5kZWNvZGVkU2FtcGxlc1BlckZyYW1lPXRoaXMuZGF0YUR1cmF0aW9uTXMqdGhpcy5zYW1wbGVSYXRlS2h6LHRoaXMuY3VycmVudE91dHB1dEJ1ZmZlcj12b2lkIDAsdGhpcy5jdXJyZW50QnVmZmVyUmVhZEluZGV4PTA7Y29uc3QgQz10aGlzLnNhbXBsZVJhdGVLaHoqdGhpcy5taW5MYXRlbmN5TXM7dGhpcy5hdWRpb0J1ZmZlclNpemU9TWF0aC5mbG9vcihDLzIpLG51bGw9PUE/KHRoaXMuYXVkaW9Db250ZXh0PW5ldyh3aW5kb3cuQXVkaW9Db250ZXh0fHx3aW5kb3cud2Via2l0QXVkaW9Db250ZXh0KSh7bGF0ZW5jeUhpbnQ6XCJpbnRlcmFjdGl2ZVwiLHNhbXBsZVJhdGU6dGhpcy5zYW1wbGVSYXRlSHp9KSx0aGlzLmF1ZGlvQ29udGV4dC5jcmVhdGVCdWZmZXJTb3VyY2UoKSk6dGhpcy5hdWRpb0NvbnRleHQ9QSx0aGlzLnZvbHVtZU5vZGU9dGhpcy5hdWRpb0NvbnRleHQuY3JlYXRlR2FpbigpLHRoaXMudm9sdW1lTm9kZS5jb25uZWN0KHRoaXMuYXVkaW9Db250ZXh0LmRlc3RpbmF0aW9uKSx0aGlzLmF1ZGlvQ29udGV4dC5yZXN1bWUoKSxcInN1c3BlbmRlZFwiPT10aGlzLmF1ZGlvQ29udGV4dC5zdGF0ZSYmUS5SYWlud2F5TG9nZ2luZy5pbmZvcm1hdGlvbihcIkF1ZGlvQ29udGV4dCBpcyBzdXNwZW5kZWQuIE5vdGUsIG9uIFNhZmFyaSwgbXVzdCBiZSBjcmVhdGVkIGRpcmVjdGx5IGZyb20gdXNlciBpbnRlcmFjdGlvbiAoaS5lLiBubyAnYXdhaXQnKSkuXCIpLHRoaXMuYXVkaW9Db250ZXh0LnNhbXBsZVJhdGUhPXRoaXMuc2FtcGxlUmF0ZUh6PyhRLlJhaW53YXlMb2dnaW5nLndhcm5pbmcoXCJDb25maWd1cmVkIHNhbXBsZSByYXRlOiBcIit0aGlzLnNhbXBsZVJhdGVIeitcIiBkb2VzIG5vdCBtYXRjaCBBdWRpb0NvbnRleHQ6IFwiK3RoaXMuYXVkaW9Db250ZXh0LnNhbXBsZVJhdGUrXCIuIFJlc2FtcGxpbmcgaXMgcmVxdWlyZWQhXCIpLHRoaXMucmVzYW1wbGVkQXVkaW9CdWZmZXJTaXplPU1hdGguZmxvb3IodGhpcy5hdWRpb0NvbnRleHQuc2FtcGxlUmF0ZS8xZTMqdGhpcy5taW5MYXRlbmN5TXMvMiksdGhpcy5zY2hlZHVsZUJ1ZmZlckZvclBsYXliYWNrRnVuYz10aGlzLnJlc2FtcGxlQnVmZmVyVGhlblNjaGVkdWxlRm9yUGxheWJhY2suYmluZCh0aGlzKSk6dGhpcy5zY2hlZHVsZUJ1ZmZlckZvclBsYXliYWNrRnVuYz10aGlzLnNjaGVkdWxlQnVmZmVyRm9yUGxheWJhY2suYmluZCh0aGlzKSx0aGlzLmF1ZGlvQnVmZmVyUG9vbD1bXTtsZXQgRT0hMTt0aGlzLnBsYXlpbmcmJihFPSEwLHRoaXMuc3RvcCgpKSxFJiZ0aGlzLnBsYXkoKX1wbGF5KCl7aWYoIXRoaXMub3B1c0RlY29kZXJXb3JrZXIpdGhyb3cgbmV3IHQuUmFpbndheUVycm9yKFwicGxheSgpIGhhcyBubyBvcHVzRGVjb2RlcldvcmtlclwiKTtpZighdGhpcy5zYW1wbGVSYXRlSHopdGhyb3cgbmV3IHQuUmFpbndheUVycm9yKFwicGxheSgpIGhhcyBubyBzYW1wbGVSYXRlSHpcIik7aWYoIXRoaXMuY2hhbm5lbENvdW50KXRocm93IG5ldyB0LlJhaW53YXlFcnJvcihcInBsYXkoKSBoYXMgbm8gY2hhbm5lbENvdW50XCIpO2lmKCF0aGlzLmF1ZGlvQ29udGV4dCl0aHJvdyBuZXcgdC5SYWlud2F5RXJyb3IoXCJwbGF5KCkgaGFzIG5vIGF1ZGlvQ29udGV4dFwiKTt0aGlzLnBsYXlpbmd8fCh0aGlzLm1heERlY29kaW5nVGltZU1zPTAsdGhpcy50b3RhbERlY29kaW5nVGltZU1zPTAsdGhpcy50b3RhbFF1ZXVlZFNpemU9MCx0aGlzLm1heFF1ZXVlZFNpemU9MCx0aGlzLnN0YXJ0U3RyZWFtVGltZU1zPURhdGUubm93KCksdGhpcy5vcHVzRGVjb2Rlcldvcmtlci5zdGFydFN0cmVhbSh0aGlzLnNhbXBsZVJhdGVIeix0aGlzLmNoYW5uZWxDb3VudCx0aGlzLmRlY29kZWRTYW1wbGVzUGVyRnJhbWUpLHRoaXMucGxheWluZz0hMCl9c3RvcCgpe2lmKCF0aGlzLm9wdXNEZWNvZGVyV29ya2VyKXRocm93IG5ldyB0LlJhaW53YXlFcnJvcihcInN0b3AoKSBoYXMgbm8gb3B1c0RlY29kZXJXb3JrZXJcIik7dGhpcy53YWl0aW5nVG9EZWNvZGVRdWV1ZT1bXSx0aGlzLm91dHB1dEJ1ZmZlcnM9W10sdGhpcy5uZXh0U3RhcnRUaW1lPXZvaWQgMCx0aGlzLnRvdGFsU2FtcGxlc0RlY29kZWQ9MCx0aGlzLmN1cnJlbnRPdXRwdXRCdWZmZXI9dm9pZCAwLHRoaXMuY3VycmVudEJ1ZmZlclJlYWRJbmRleD0wLHRoaXMucHJldkRyb3BwZWRGcmFtZVRpbWVNcz12b2lkIDAsdGhpcy5vcHVzRGVjb2Rlcldvcmtlci5zdG9wU3RyZWFtKCksdGhpcy5wbGF5aW5nPSExfXB1c2hEYXRhKEEpe3RoaXMucGxheWluZyYmdGhpcy5hdWRpb0NvbnRleHQmJnRoaXMub3B1c0RlY29kZXJXb3JrZXImJigwPT10aGlzLmRlY29kZVF1ZXVlU2l6ZT8oMCE9dGhpcy53YWl0aW5nVG9EZWNvZGVRdWV1ZS5sZW5ndGgmJihRLlJhaW53YXlMb2dnaW5nLmVycm9yKFwiW0F1ZGlvU3RyZWFtXSBlbXB0eSBkZWNvZGVyIHF1ZXVlLCBidXQgd2FpdGluZyB0byBkZWNvZGUgcXVldWUgbm90IGVtcHR5IVwiKSx0aGlzLndhaXRpbmdUb0RlY29kZVF1ZXVlPVtdKSx0aGlzLnNlbmRUb0RlY29kZXIoe3N0YXJ0VGltZXN0YW1wOkRhdGUubm93KCksaW5wdXREYXRhOkF9KSk6KHRoaXMud2FpdGluZ1RvRGVjb2RlUXVldWUucHVzaCh7c3RhcnRUaW1lc3RhbXA6RGF0ZS5ub3coKSxpbnB1dERhdGE6QX0pLHRoaXMuZGVjb2RlUXVldWVTaXplPDMmJnRoaXMuc2VuZERlY29kZXJXYWl0aW5nVG9EZWNvZGVGcmFtZXMoKSkpfXNlbmREZWNvZGVyV2FpdGluZ1RvRGVjb2RlRnJhbWVzKCl7Y29uc3QgQT0odGhpcy5kZWNvZGVRdWV1ZVNpemUrdGhpcy53YWl0aW5nVG9EZWNvZGVRdWV1ZS5sZW5ndGgpKnRoaXMuZGF0YUR1cmF0aW9uTXM7aWYoQT50aGlzLm1heExhdGVuY3lNcyl7Y29uc3QgST1BLXRoaXMubWF4TGF0ZW5jeU1zLGc9TWF0aC5mbG9vcihJL3RoaXMuZGF0YUR1cmF0aW9uTXMpLGU9TWF0aC5tYXgoTWF0aC5tYXgodGhpcy53YWl0aW5nVG9EZWNvZGVRdWV1ZS5sZW5ndGgtZywzLXRoaXMuZGVjb2RlUXVldWVTaXplKSwxKSxCPXRoaXMud2FpdGluZ1RvRGVjb2RlUXVldWUubGVuZ3RoLWU7dGhpcy53YWl0aW5nVG9EZWNvZGVRdWV1ZT10aGlzLndhaXRpbmdUb0RlY29kZVF1ZXVlLnNsaWNlKEIpfWZvcig7dGhpcy5kZWNvZGVRdWV1ZVNpemU8MyYmdGhpcy53YWl0aW5nVG9EZWNvZGVRdWV1ZS5sZW5ndGg+MDspe2NvbnN0IEE9dGhpcy53YWl0aW5nVG9EZWNvZGVRdWV1ZS5zaGlmdCgpO3RoaXMuc2VuZFRvRGVjb2RlcihBKX19c2VuZFRvRGVjb2RlcihBKXsrK3RoaXMuZGVjb2RlUXVldWVTaXplLHRoaXMub3B1c0RlY29kZXJXb3JrZXIuZGVjb2RlKEEuc3RhcnRUaW1lc3RhbXAsQS5pbnB1dERhdGEpfWRyb3BEZWNvZGVkU2FtcGxlcyhBKXtsZXQgST0wO2Zvcih0aGlzLmN1cnJlbnRPdXRwdXRCdWZmZXImJihJKz10aGlzLmRyb3BDdXJyZW50T3V0cHV0QnVmZmVyU2FtcGxlcyhBKSxBLT1JKTtBPjAmJnRoaXMub3V0cHV0QnVmZmVycy5sZW5ndGg+MDspaWYoQTx0aGlzLmRlY29kZWRTYW1wbGVzUGVyRnJhbWUpe3RoaXMuY3VycmVudE91dHB1dEJ1ZmZlcj10aGlzLm91dHB1dEJ1ZmZlcnMuc2hpZnQoKSx0aGlzLmN1cnJlbnRCdWZmZXJSZWFkSW5kZXg9MDtjb25zdCBnPXRoaXMuZHJvcEN1cnJlbnRPdXRwdXRCdWZmZXJTYW1wbGVzKEEpO0krPWcsQS09Z31lbHNlIHRoaXMub3V0cHV0QnVmZmVycy5zaGlmdCgpLEkrPXRoaXMuZGVjb2RlZFNhbXBsZXNQZXJGcmFtZSxBLT10aGlzLmRlY29kZWRTYW1wbGVzUGVyRnJhbWU7cmV0dXJuIEl9ZHJvcEN1cnJlbnRPdXRwdXRCdWZmZXJTYW1wbGVzKEEpe2NvbnN0IEk9TWF0aC5mbG9vcigodGhpcy5jdXJyZW50T3V0cHV0QnVmZmVyLmxlbmd0aC10aGlzLmN1cnJlbnRCdWZmZXJSZWFkSW5kZXgpL3RoaXMuY2hhbm5lbENvdW50KSxnPU1hdGgubWluKEksQSk7cmV0dXJuIHRoaXMuY3VycmVudEJ1ZmZlclJlYWRJbmRleCs9Zyp0aGlzLmNoYW5uZWxDb3VudCx0aGlzLmN1cnJlbnRCdWZmZXJSZWFkSW5kZXg+PXRoaXMuY3VycmVudE91dHB1dEJ1ZmZlci5sZW5ndGgmJih0aGlzLmN1cnJlbnRPdXRwdXRCdWZmZXI9dm9pZCAwKSxnfWNvcHlEZWNvZGVkU2FtcGxlc1RvQXVkaW9CdWZmZXIoKXtjb25zdCBBPXRoaXMuZ2V0T3JDcmVhdGVBdWRpb0J1ZmZlcigpO2ZvcihsZXQgST0wO0k8dGhpcy5hdWRpb0J1ZmZlclNpemU7KXt0aGlzLmN1cnJlbnRPdXRwdXRCdWZmZXJ8fCh0aGlzLmN1cnJlbnRPdXRwdXRCdWZmZXI9dGhpcy5vdXRwdXRCdWZmZXJzLnNoaWZ0KCksdGhpcy5jdXJyZW50QnVmZmVyUmVhZEluZGV4PTApO2NvbnN0IGc9dGhpcy5jdXJyZW50T3V0cHV0QnVmZmVyO2lmKDE9PXRoaXMuY2hhbm5lbENvdW50KXtjb25zdCBlPUEuZ2V0Q2hhbm5lbERhdGEoMCk7Zm9yKDt0aGlzLmN1cnJlbnRCdWZmZXJSZWFkSW5kZXg8Zy5sZW5ndGgmJihlW0ldPWdbdGhpcy5jdXJyZW50QnVmZmVyUmVhZEluZGV4XSx0aGlzLmN1cnJlbnRCdWZmZXJSZWFkSW5kZXgrPXRoaXMuY2hhbm5lbENvdW50LCsrSSwhKEk+PXRoaXMuYXVkaW9CdWZmZXJTaXplKSk7KTt9ZWxzZSBpZigyPT10aGlzLmNoYW5uZWxDb3VudCl7Y29uc3QgZT1BLmdldENoYW5uZWxEYXRhKDApLEI9QS5nZXRDaGFubmVsRGF0YSgxKTtmb3IoO3RoaXMuY3VycmVudEJ1ZmZlclJlYWRJbmRleDxnLmxlbmd0aCYmKGVbSV09Z1t0aGlzLmN1cnJlbnRCdWZmZXJSZWFkSW5kZXhdLEJbSV09Z1t0aGlzLmN1cnJlbnRCdWZmZXJSZWFkSW5kZXgrMV0sdGhpcy5jdXJyZW50QnVmZmVyUmVhZEluZGV4Kz10aGlzLmNoYW5uZWxDb3VudCwrK0ksIShJPj10aGlzLmF1ZGlvQnVmZmVyU2l6ZSkpOyk7fWVsc2V7Y29uc3QgZT1BLmdldENoYW5uZWxEYXRhKDApLEI9QS5nZXRDaGFubmVsRGF0YSgxKSxpPUEuZ2V0Q2hhbm5lbERhdGEoMiksdD1BLmdldENoYW5uZWxEYXRhKDMpLFE9QS5nZXRDaGFubmVsRGF0YSg0KSxDPUEuZ2V0Q2hhbm5lbERhdGEoNSk7Zm9yKDt0aGlzLmN1cnJlbnRCdWZmZXJSZWFkSW5kZXg8Zy5sZW5ndGgmJihlW0ldPWdbdGhpcy5jdXJyZW50QnVmZmVyUmVhZEluZGV4XSxCW0ldPWdbdGhpcy5jdXJyZW50QnVmZmVyUmVhZEluZGV4KzFdLFFbSV09Z1t0aGlzLmN1cnJlbnRCdWZmZXJSZWFkSW5kZXgrMl0sQ1tJXT1nW3RoaXMuY3VycmVudEJ1ZmZlclJlYWRJbmRleCszXSxpW0ldPWdbdGhpcy5jdXJyZW50QnVmZmVyUmVhZEluZGV4KzRdLHRbSV09Z1t0aGlzLmN1cnJlbnRCdWZmZXJSZWFkSW5kZXgrNV0sdGhpcy5jdXJyZW50QnVmZmVyUmVhZEluZGV4Kz10aGlzLmNoYW5uZWxDb3VudCwrK0ksIShJPj10aGlzLmF1ZGlvQnVmZmVyU2l6ZSkpOyk7fXRoaXMuY3VycmVudEJ1ZmZlclJlYWRJbmRleD49dGhpcy5jdXJyZW50T3V0cHV0QnVmZmVyLmxlbmd0aCYmKHRoaXMuY3VycmVudE91dHB1dEJ1ZmZlcj12b2lkIDApfXJldHVybiBBfWdldE9yQ3JlYXRlQXVkaW9CdWZmZXIoKXtyZXR1cm4gMD09dGhpcy5hdWRpb0J1ZmZlclBvb2wubGVuZ3RoP3RoaXMuYXVkaW9Db250ZXh0LmNyZWF0ZUJ1ZmZlcih0aGlzLmNoYW5uZWxDb3VudCx0aGlzLmF1ZGlvQnVmZmVyU2l6ZSx0aGlzLnNhbXBsZVJhdGVIeik6dGhpcy5hdWRpb0J1ZmZlclBvb2wucG9wKCl9cmV0dXJuQXVkaW9CdWZmZXJUb1Bvb2woQSxJKXt0aGlzLmF1ZGlvQnVmZmVyUG9vbC5sZW5ndGg8dGhpcy5tYXhBdWRpb0J1ZmZlclBvb2xDb3VudCYmdGhpcy5hdWRpb0J1ZmZlclBvb2wucHVzaChBKX1sb2dQZXJmVGltaW5nKEEpe2NvbnN0IEk9RGF0ZS5ub3coKSxnPUktQTt0aGlzLnRvdGFsRGVjb2RpbmdUaW1lTXMrPWcsZz50aGlzLm1heERlY29kaW5nVGltZU1zJiYodGhpcy5tYXhEZWNvZGluZ1RpbWVNcz1nKTtjb25zdCBlPXRoaXMud2FpdGluZ1RvRGVjb2RlUXVldWUubGVuZ3RoK3RoaXMuZGVjb2RlUXVldWVTaXplO3RoaXMudG90YWxRdWV1ZWRTaXplKz1lLGU+dGhpcy5tYXhRdWV1ZWRTaXplJiYodGhpcy5tYXhRdWV1ZWRTaXplPWUpLDE1MDA9PXRoaXMuZGVjb2RlZENvdW50JiYoUS5SYWlud2F5TG9nZ2luZy5pbmZvcm1hdGlvbihcIltBdWRpb1N0cmVhbV0gQXZnIHF1ZXVlOiBcIit0aGlzLnRvdGFsUXVldWVkU2l6ZS90aGlzLmRlY29kZWRDb3VudCtcIiwgTWF4OiBcIit0aGlzLm1heFF1ZXVlZFNpemUrXCIgQXZnIEZQUzogXCIrdGhpcy5kZWNvZGVkQ291bnQvKChJLXRoaXMuc3RhcnRTdHJlYW1UaW1lTXMpLzFlMykrXCIgQXZnIGRlY29kZTogXCIrdGhpcy50b3RhbERlY29kaW5nVGltZU1zL3RoaXMuZGVjb2RlZENvdW50K1wibXMsIE1heDogXCIrdGhpcy5tYXhEZWNvZGluZ1RpbWVNcytcIm1zXCIpLHRoaXMudG90YWxEZWNvZGluZ1RpbWVNcz0wLHRoaXMubWF4RGVjb2RpbmdUaW1lTXM9MCx0aGlzLnRvdGFsUXVldWVkU2l6ZT0wLHRoaXMubWF4UXVldWVkU2l6ZT0wLHRoaXMuZGVjb2RlZENvdW50PTAsdGhpcy5zdGFydFN0cmVhbVRpbWVNcz1JKX1yZXNhbXBsZUJ1ZmZlclRoZW5TY2hlZHVsZUZvclBsYXliYWNrKEEpe2NvbnN0IEk9bmV3KHdpbmRvdy5PZmZsaW5lQXVkaW9Db250ZXh0fHx3aW5kb3cud2Via2l0T2ZmbGluZUF1ZGlvQ29udGV4dCkodGhpcy5jaGFubmVsQ291bnQsdGhpcy5yZXNhbXBsZWRBdWRpb0J1ZmZlclNpemUsdGhpcy5hdWRpb0NvbnRleHQuc2FtcGxlUmF0ZSksZz1JLmNyZWF0ZUJ1ZmZlclNvdXJjZSgpO2cuYnVmZmVyPUEsZy5jb25uZWN0KEkuZGVzdGluYXRpb24pLGcuc3RhcnQoKSxJLnN0YXJ0UmVuZGVyaW5nKCksSS5vbmNvbXBsZXRlPXRoaXMuc2NoZWR1bGVSZXNhbXBsZWRCdWZmZXJQbGF5YmFjay5iaW5kKHRoaXMsQSl9c2NoZWR1bGVSZXNhbXBsZWRCdWZmZXJQbGF5YmFjayhBLEkpe3RoaXMuc2NoZWR1bGVQbGF5YmFja1dpdGhPbkVuZGVkKEkucmVuZGVyZWRCdWZmZXIpLHRoaXMucmV0dXJuQXVkaW9CdWZmZXJUb1Bvb2woQSxJKX1zY2hlZHVsZUJ1ZmZlckZvclBsYXliYWNrKEEpe3RoaXMuc2NoZWR1bGVQbGF5YmFja1dpdGhPbkVuZGVkKEEsdGhpcy5yZXR1cm5BdWRpb0J1ZmZlclRvUG9vbC5iaW5kKHRoaXMsQSkpfXNjaGVkdWxlUGxheWJhY2tXaXRoT25FbmRlZChBLEk9bnVsbCl7Y29uc3QgZz10aGlzLmF1ZGlvQ29udGV4dC5jcmVhdGVCdWZmZXJTb3VyY2UoKTtnLmJ1ZmZlcj1BLHRoaXMubmV4dFN0YXJ0VGltZXx8KHRoaXMubmV4dFN0YXJ0VGltZT10aGlzLmF1ZGlvQ29udGV4dC5jdXJyZW50VGltZSksZy5wbGF5YmFja1JhdGUudmFsdWU9MSxnLmNvbm5lY3QodGhpcy52b2x1bWVOb2RlKSxnLnN0YXJ0KHRoaXMubmV4dFN0YXJ0VGltZSksZy5vbmVuZGVkPUksdGhpcy5uZXh0U3RhcnRUaW1lKz1BLmR1cmF0aW9ufXNldFZvbHVtZShBKXt0aGlzLnZvbHVtZU5vZGUuZ2Fpbi52YWx1ZT1BfX19LDUxNDooQSxJLGcpPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KEksXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksSS5tYWtlQ2xpZW50Q2FwYWJpbGl0aWVzPXZvaWQgMDtjb25zdCBlPWcoOTA0KSxCPWcoNjQzKSxpPWcoNjk1KTtJLm1ha2VDbGllbnRDYXBhYmlsaXRpZXM9ZnVuY3Rpb24oQSl7Y29uc3R7ZmlsdGVyZWQ6SSxwcmVmZXJyZWQ6Z309aS5maWx0ZXJDb2RlY1BhY2soQSksdD17Y29kZWM6ZS5BdWRpb0NvZGVjLk9wdXMsY29udGFpbmVyOmUuQXVkaW9Db250YWluZXIuUmF3fSxRPVwiTWVkaWFTb3VyY2VcImluIHdpbmRvdz9lLlZpZGVvQ29udGFpbmVyLklzb0JNRkY6ZS5WaWRlb0NvbnRhaW5lci5SYXcsQz0hIXdpbmRvdy5jaHJvbWU7cmV0dXJue3ByZWZlcnJlZFdpZHRoOnNjcmVlbi5hdmFpbFdpZHRoLHByZWZlcnJlZEhlaWdodDpzY3JlZW4uYXZhaWxIZWlnaHQscHJlZmVycmVkRnBzOjYwLHByZWZlcnJlZEF1ZGlvQml0cmF0ZTo5NmUzLHByZWZlcnJlZFZpZGVvQml0cmF0ZToxZTMqQi5kZWZhdWx0UmF0ZUNvbnRyb2xQYXJhbWV0ZXJzLmluaXRpYWxCaXRyYXRlS2JwcyxwcmVmZXJyZWRBdWRpb0NoYW5uZWxzOmUuQXVkaW9DaGFubmVscy5TdGVyZW8scHJlZmVycmVkQXVkaW9Db25maWc6dCxwcmVmZXJyZWRWaWRlb0NvbmZpZzp7Y29kZWM6Zyxjb250YWluZXI6UX0sc3VwcG9ydGVkQXVkaW9DaGFubmVsczpbZS5BdWRpb0NoYW5uZWxzLk1vbm8sZS5BdWRpb0NoYW5uZWxzLlN0ZXJlb10sc3VwcG9ydGVkQXVkaW9Db25maWdzOlt0XSxzdXBwb3J0ZWRWaWRlb0NvbmZpZ3M6SS5tYXAoKEE9Pih7Y29kZWM6QSxjb250YWluZXI6UX0pKSksc3VwcG9ydHNPdmVyMTA4MFA6ITEsc3VwcG9ydHNUZW1wb3JhbFNjYWxpbmc6ITAsc3VwcG9ydHNBcHBJc29sYXRpb246Q319fSw2OTU6KEEsSSxnKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eShJLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLEkuZmlsdGVyQ29kZWNQYWNrPUkudmlkZW9Db2RlY01pbWVUeXBlPXZvaWQgMDtjb25zdCBlPWcoOTA0KTtmdW5jdGlvbiBCKEEpe2NvbnN0IEk9QS5kYXRhO3JldHVybmB2aWRlby9tcDQ7IGNvZGVjcz1cImF2YzEuJHsoSVs1XTw8MTZ8SVs2XTw8OHxJWzddKS50b1N0cmluZygxNikucGFkU3RhcnQoNixcIjBcIil9XCJgfWZ1bmN0aW9uIGkoQSl7aWYoIShcIk1lZGlhU291cmNlXCJpbiB3aW5kb3cpKXJldHVybiExO2NvbnN0IEk9QS5kYXRhO2lmKEkubGVuZ3RoPDh8fDchPSgzMSZJWzRdKSlyZXR1cm4hMTtjb25zdCBnPUIoQSk7cmV0dXJuIE1lZGlhU291cmNlLmlzVHlwZVN1cHBvcnRlZChnKX1mdW5jdGlvbiB0KEEpe2NvbnN0IEk9QS5kYXRhO2lmKEkubGVuZ3RoPDh8fDchPSgzMSZJWzRdKSlyZXR1cm4gZS5WaWRlb0NvZGVjVHlwZS5CYXNlbGluZTtjb25zdCBnPUlbNV07cmV0dXJuIElbNl0sMTE2PT1nfHwxMjI9PWd8fDExMD09Z3x8MTAwPT1nP2UuVmlkZW9Db2RlY1R5cGUuSGlnaDo4OD09Z3x8Nzc9PWc/ZS5WaWRlb0NvZGVjVHlwZS5NYWluOmUuVmlkZW9Db2RlY1R5cGUuQmFzZWxpbmV9SS52aWRlb0NvZGVjTWltZVR5cGU9QixJLmZpbHRlckNvZGVjUGFjaz1mdW5jdGlvbihBKXtpZigwPT09QS5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiSG9zdCBzdXBwbGllZCBhbiBlbXB0eSBDb2RlY1BhY2tcIik7bGV0IEk9QS5maWx0ZXIoaSk7aWYoMD09PUkubGVuZ3RoJiYoY29uc29sZS53YXJuKFwiRm91bmQgbm8gYnJvd3Nlci1jb25maXJtZWQgd29ya2luZyBjb2RlYywgZmFsbGluZyBiYWNrIHRvIGJhc2VsaW5lXCIpLEk9QS5maWx0ZXIoKEE9PnQoQSk8PWUuVmlkZW9Db2RlY1R5cGUuQmFzZWxpbmUpKSksMD09PUkubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcIkhvc3Qgc3VwcGxpZWQgYW4gdW5zdXBwb3J0ZWQgQ29kZWNQYWNrXCIpO2NvbnN0IGc9SS5yZWR1Y2UoKChBLEkpPT50KEEpPnQoSSk/QTpJKSk7cmV0dXJue2ZpbHRlcmVkOkkscHJlZmVycmVkOmd9fX0sOTE5OihBLEksZyk9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkoSSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTtjb25zdCBlPWcoNDY0KTtjbGFzcyBCe2NvbnN0cnVjdG9yKEEsSSxnKXt0aGlzLmdsQ3R4PXZvaWQgMCx0aGlzLnByb2dyYW09dm9pZCAwLHRoaXMuZ2xDdHg9QSx0aGlzLnByb2dyYW09dGhpcy5nbEN0eC5jcmVhdGVQcm9ncmFtKCksdGhpcy5nbEN0eC5hdHRhY2hTaGFkZXIodGhpcy5wcm9ncmFtLEkpLHRoaXMuZ2xDdHguYXR0YWNoU2hhZGVyKHRoaXMucHJvZ3JhbSxnKSx0aGlzLmdsQ3R4LmxpbmtQcm9ncmFtKHRoaXMucHJvZ3JhbSksdGhpcy5nbEN0eC5nZXRQcm9ncmFtUGFyYW1ldGVyKHRoaXMucHJvZ3JhbSx0aGlzLmdsQ3R4LkxJTktfU1RBVFVTKXx8ZS5SYWlud2F5TG9nZ2luZy5lcnJvcihcIlNoYWRlciBsaW5rIGZhaWxlZC5cIil9c3RhdGljIGNvbXBpbGUoQSxJLGcpe2xldCBCO3JldHVybiBCPVwidmVydGV4XCI9PT1JP0EuY3JlYXRlU2hhZGVyKEEuVkVSVEVYX1NIQURFUik6QS5jcmVhdGVTaGFkZXIoQS5GUkFHTUVOVF9TSEFERVIpLEEuc2hhZGVyU291cmNlKEIsZyksQS5jb21waWxlU2hhZGVyKEIpLDA9PUEuZ2V0U2hhZGVyUGFyYW1ldGVyKEIsQS5DT01QSUxFX1NUQVRVUykmJmUuUmFpbndheUxvZ2dpbmcuZXJyb3IoXCJTaGFkZXIgY29tcGlsZSBmYWlsZWQsIGxvZzogXCIrQS5nZXRTaGFkZXJJbmZvTG9nKEIpKSxCfXN0YXRpYyBjcmVhdGUoQSxJLGcpe2NvbnN0IGU9Qi5jb21waWxlKEEsXCJ2ZXJ0ZXhcIixJKSxpPUIuY29tcGlsZShBLFwiZnJhZ21lbnRcIixnKTtyZXR1cm4gbmV3IEIoQSxlLGkpfXVzZSgpe3RoaXMuZ2xDdHgudXNlUHJvZ3JhbSh0aGlzLnByb2dyYW0pfWdldEF0dHJpYnV0ZUxvY2F0aW9uKEEpe3JldHVybiB0aGlzLmdsQ3R4LmdldEF0dHJpYkxvY2F0aW9uKHRoaXMucHJvZ3JhbSxBKX1nZXRVbmlmb3JtTG9jYXRpb24oQSl7Y29uc3QgST10aGlzLmdsQ3R4LmdldFVuaWZvcm1Mb2NhdGlvbih0aGlzLnByb2dyYW0sQSk7aWYoSSlyZXR1cm4gSX1zZXRNYXRyaXhVbmlmb3JtKEEsSSl7dGhpcy5nbEN0eC51bmlmb3JtTWF0cml4NGZ2KEEsITEsSSl9fUkuZGVmYXVsdD1CfSw3NTY6ZnVuY3Rpb24oQSxJLGcpe1widXNlIHN0cmljdFwiO3ZhciBlPXRoaXMmJnRoaXMuX19pbXBvcnREZWZhdWx0fHxmdW5jdGlvbihBKXtyZXR1cm4gQSYmQS5fX2VzTW9kdWxlP0E6e2RlZmF1bHQ6QX19O09iamVjdC5kZWZpbmVQcm9wZXJ0eShJLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLEkueXV2RnJhZ1NoYWRlclNyYz12b2lkIDA7Y29uc3QgQj1lKGcoOTE5KSk7SS55dXZGcmFnU2hhZGVyU3JjPVwiXFxuICAgIHByZWNpc2lvbiBsb3dwIGZsb2F0O1xcbiAgICBcXG4gICAgdmFyeWluZyB2ZWMyIHZUZXhDb29yZDtcXG4gICAgXFxuICAgIHVuaWZvcm0gc2FtcGxlcjJEIHlUZXh0dXJlO1xcbiAgICB1bmlmb3JtIHNhbXBsZXIyRCB1VGV4dHVyZTtcXG4gICAgdW5pZm9ybSBzYW1wbGVyMkQgdlRleHR1cmU7XFxuICAgIGNvbnN0IG1hdDMgY29udmVyc2lvbiA9IG1hdDMoXFxuICAgICAgICAxLjE2NCwgMC4wMDAsICAxLjU5NixcXG4gICAgICAgIDEuMTY0LCAtMC4zOTEsIC0wLjgxMyxcXG4gICAgICAgIDEuMTY0LCAyLjAxOCwgIDAuMDAwXFxuICAgICk7XFxuXFxuICAgIGNvbnN0IHZlYzMgb2Zmc2V0ID0gdmVjMygwLjA2MjUsIDAuNSwgMC41KTtcXG4gICAgICAgIFxcbiAgICB2b2lkIG1haW4odm9pZCkge1xcbiAgICAgICAgZmxvYXQgeSA9IHRleHR1cmUyRCh5VGV4dHVyZSwgdlRleENvb3JkKS54O1xcbiAgICAgICAgZmxvYXQgdSA9IHRleHR1cmUyRCh1VGV4dHVyZSwgdlRleENvb3JkKS54O1xcbiAgICAgICAgZmxvYXQgdiA9IHRleHR1cmUyRCh2VGV4dHVyZSwgdlRleENvb3JkKS54O1xcbiAgICAgICAgdmVjMyB5dXYgPSB2ZWMzKHksIHUsIHYpIC0gb2Zmc2V0O1xcblxcbiAgICAgICAgdmVjMyByZ2IgPSAoeXV2ICogY29udmVyc2lvbik7XFxuXFxuICAgICAgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KHJnYiwgMS4wKTtcXG4gICAgfVxcblwiO2NsYXNzIGl7Y29uc3RydWN0b3IoQSxJLGcsZSxCLGksdCxRLEMpe3RoaXMuZ2xDdHg9QSx0aGlzLnByb2dyYW09SSx0aGlzLnByb2plY3Rpb25NdHhMb2M9Zyx0aGlzLnBvc2l0aW9uQXR0cj1lLHRoaXMudGV4Q29vcmRBdHRyPUIsdGhpcy52ZXJ0ZXhCdWZmZXI9aSx0aGlzLnlUZXh0dXJlTG9jPXQsdGhpcy51VGV4dHVyZUxvYz1RLHRoaXMudlRleHR1cmVMb2M9Q31zdGF0aWMgY3JlYXRlKEEpe2NvbnN0IGc9Qi5kZWZhdWx0LmNyZWF0ZShBLFwiXFxuICAgIHByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xcblxcbiAgICB1bmlmb3JtIG1hdDQgdVByb2plY3Rpb247XFxuICAgIGF0dHJpYnV0ZSB2ZWMyIGFQb3NpdGlvbjtcXG4gICAgYXR0cmlidXRlIHZlYzIgYVRleENvb3JkO1xcblxcbiAgICB2YXJ5aW5nIHZlYzIgdlRleENvb3JkO1xcbiAgICB2b2lkIG1haW4oKXtcXG4gICAgICAgIHZUZXhDb29yZCA9IGFUZXhDb29yZDtcXG4gICAgICAgIGdsX1Bvc2l0aW9uID0gdVByb2plY3Rpb24gKiB2ZWM0KGFQb3NpdGlvbiwgMC4wLCAxLjApO1xcbiAgICB9XFxuXCIsSS55dXZGcmFnU2hhZGVyU3JjKTtnLnVzZSgpO2NvbnN0IGU9Zy5nZXRVbmlmb3JtTG9jYXRpb24oXCJ1UHJvamVjdGlvblwiKSx0PWcuZ2V0QXR0cmlidXRlTG9jYXRpb24oXCJhUG9zaXRpb25cIik7QS5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheSh0KTtjb25zdCBRPWcuZ2V0QXR0cmlidXRlTG9jYXRpb24oXCJhVGV4Q29vcmRcIik7QS5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShRKTtjb25zdCBDPUEuY3JlYXRlQnVmZmVyKCksRT1nLmdldFVuaWZvcm1Mb2NhdGlvbihcInlUZXh0dXJlXCIpLG89Zy5nZXRVbmlmb3JtTG9jYXRpb24oXCJ1VGV4dHVyZVwiKSxhPWcuZ2V0VW5pZm9ybUxvY2F0aW9uKFwidlRleHR1cmVcIik7cmV0dXJuIG5ldyBpKEEsZyxlLHQsUSxDLEUsbyxhKX1iaW5kSW5wdXRUZXh0dXJlcyhBLEksZyl7Y29uc3QgZT10aGlzLmdsQ3R4O2UudW5pZm9ybTFpKHRoaXMueVRleHR1cmVMb2MsMCksZS5hY3RpdmVUZXh0dXJlKGUuVEVYVFVSRTApLGUuYmluZFRleHR1cmUoZS5URVhUVVJFXzJELEEudGV4dHVyZUlkKSxlLnVuaWZvcm0xaSh0aGlzLnVUZXh0dXJlTG9jLDEpLGUuYWN0aXZlVGV4dHVyZShlLlRFWFRVUkUxKSxlLmJpbmRUZXh0dXJlKGUuVEVYVFVSRV8yRCxJLnRleHR1cmVJZCksZS51bmlmb3JtMWkodGhpcy52VGV4dHVyZUxvYywyKSxlLmFjdGl2ZVRleHR1cmUoZS5URVhUVVJFMiksZS5iaW5kVGV4dHVyZShlLlRFWFRVUkVfMkQsZy50ZXh0dXJlSWQpfXVzZSgpe3RoaXMucHJvZ3JhbS51c2UoKX1kcm9wKCl7dGhpcy5nbEN0eC51c2VQcm9ncmFtKDApfXVwZGF0ZShBLEksZyxlKXt0aGlzLmdsQ3R4LnZpZXdwb3J0KDAsMCxBLEkpLHRoaXMucHJvZ3JhbS5zZXRNYXRyaXhVbmlmb3JtKHRoaXMucHJvamVjdGlvbk10eExvYyxbMi9BLDAsMCwwLDAsMi8tSSwwLDAsMCwwLDEsMCwtMSwxLDAsMV0pLHRoaXMuZ2xDdHguYmluZEJ1ZmZlcih0aGlzLmdsQ3R4LkFSUkFZX0JVRkZFUix0aGlzLnZlcnRleEJ1ZmZlciksdGhpcy5nbEN0eC5idWZmZXJEYXRhKHRoaXMuZ2xDdHguQVJSQVlfQlVGRkVSLG5ldyBGbG9hdDMyQXJyYXkoWzAsMCwwLDAsQSwwLGcsMCxBLEksZyxlLEEsSSxnLGUsMCxJLDAsZSwwLDAsMCwwXSksdGhpcy5nbEN0eC5EWU5BTUlDX0RSQVcpLHRoaXMuZ2xDdHgudmVydGV4QXR0cmliUG9pbnRlcih0aGlzLnBvc2l0aW9uQXR0ciwyLHRoaXMuZ2xDdHguRkxPQVQsITEsMTYsMCksdGhpcy5nbEN0eC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHRoaXMudGV4Q29vcmRBdHRyLDIsdGhpcy5nbEN0eC5GTE9BVCwhMSwxNiw4KX1kcmF3KCl7Y29uc3QgQT10aGlzLmdsQ3R4O0EuY2xlYXIoQS5DT0xPUl9CVUZGRVJfQklUfEEuREVQVEhfQlVGRkVSX0JJVHxBLlNURU5DSUxfQlVGRkVSX0JJVCksQS5kcmF3QXJyYXlzKEEuVFJJQU5HTEVfU1RSSVAsMCw2KSxBLmJpbmRUZXh0dXJlKEEuVEVYVFVSRV8yRCxudWxsKX19SS5kZWZhdWx0PWl9LDM0NjooQSxJKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eShJLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO2NsYXNzIGd7Y29uc3RydWN0b3IoQSxJKXt0aGlzLmdsQ3R4PXZvaWQgMCx0aGlzLnRleHR1cmVJZD12b2lkIDAsdGhpcy5nbEN0eD1BLHRoaXMudGV4dHVyZUlkPUl9c3RhdGljIGNyZWF0ZShBKXtjb25zdCBJPUEuY3JlYXRlVGV4dHVyZSgpO3JldHVybiBBLmJpbmRUZXh0dXJlKEEuVEVYVFVSRV8yRCxJKSxBLnRleFBhcmFtZXRlcmkoQS5URVhUVVJFXzJELEEuVEVYVFVSRV9NQUdfRklMVEVSLEEuTkVBUkVTVCksQS50ZXhQYXJhbWV0ZXJpKEEuVEVYVFVSRV8yRCxBLlRFWFRVUkVfTUlOX0ZJTFRFUixBLk5FQVJFU1QpLEEudGV4UGFyYW1ldGVyaShBLlRFWFRVUkVfMkQsQS5URVhUVVJFX1dSQVBfUyxBLkNMQU1QX1RPX0VER0UpLEEudGV4UGFyYW1ldGVyaShBLlRFWFRVUkVfMkQsQS5URVhUVVJFX1dSQVBfVCxBLkNMQU1QX1RPX0VER0UpLEEuYmluZFRleHR1cmUoQS5URVhUVVJFXzJELG51bGwpLG5ldyBnKEEsSSl9dXBsb2FkQnVmZmVyKEEsSSxnKXtjb25zdCBlPXRoaXMuZ2xDdHg7ZS5iaW5kVGV4dHVyZShlLlRFWFRVUkVfMkQsdGhpcy50ZXh0dXJlSWQpLGUudGV4SW1hZ2UyRChlLlRFWFRVUkVfMkQsMCxlLkxVTUlOQU5DRSxJLGcsMCxlLkxVTUlOQU5DRSxlLlVOU0lHTkVEX0JZVEUsQSksZS5iaW5kVGV4dHVyZShlLlRFWFRVUkVfMkQsbnVsbCl9ZGVsZXRlKCl7bnVsbCE9dGhpcy5nbEN0eCYmMCE9dGhpcy50ZXh0dXJlSWQmJih0aGlzLmdsQ3R4LmRlbGV0ZVRleHR1cmUodGhpcy50ZXh0dXJlSWQpLHRoaXMudGV4dHVyZUlkPTApfX1JLmRlZmF1bHQ9Z30sNDI1OmZ1bmN0aW9uKEEsSSxnKXtcInVzZSBzdHJpY3RcIjt2YXIgZSxCPXRoaXMmJnRoaXMuX19hd2FpdGVyfHxmdW5jdGlvbihBLEksZyxlKXtyZXR1cm4gbmV3KGd8fChnPVByb21pc2UpKSgoZnVuY3Rpb24oQixpKXtmdW5jdGlvbiB0KEEpe3RyeXtDKGUubmV4dChBKSl9Y2F0Y2goQSl7aShBKX19ZnVuY3Rpb24gUShBKXt0cnl7QyhlLnRocm93KEEpKX1jYXRjaChBKXtpKEEpfX1mdW5jdGlvbiBDKEEpe3ZhciBJO0EuZG9uZT9CKEEudmFsdWUpOihJPUEudmFsdWUsSSBpbnN0YW5jZW9mIGc/STpuZXcgZygoZnVuY3Rpb24oQSl7QShJKX0pKSkudGhlbih0LFEpfUMoKGU9ZS5hcHBseShBLEl8fFtdKSkubmV4dCgpKX0pKX0saT10aGlzJiZ0aGlzLl9fY2xhc3NQcml2YXRlRmllbGRTZXR8fGZ1bmN0aW9uKEEsSSxnKXtpZighSS5oYXMoQSkpdGhyb3cgbmV3IFR5cGVFcnJvcihcImF0dGVtcHRlZCB0byBzZXQgcHJpdmF0ZSBmaWVsZCBvbiBub24taW5zdGFuY2VcIik7cmV0dXJuIEkuc2V0KEEsZyksZ30sdD10aGlzJiZ0aGlzLl9fY2xhc3NQcml2YXRlRmllbGRHZXR8fGZ1bmN0aW9uKEEsSSl7aWYoIUkuaGFzKEEpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJhdHRlbXB0ZWQgdG8gZ2V0IHByaXZhdGUgZmllbGQgb24gbm9uLWluc3RhbmNlXCIpO3JldHVybiBJLmdldChBKX07T2JqZWN0LmRlZmluZVByb3BlcnR5KEksXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksSS5NZWRpYU1hbmFnZXI9SS5SYWlud2F5U3RyZWFtRml0PUkuUmFpbndheVZpZGVvRm9ybWF0PUkuUmFpbndheVZpZGVvRGVjb2Rlcj12b2lkIDA7Y29uc3QgUT1nKDkwMCksQz1nKDU4NSksRT1nKDc4KSxvPWcoOTE0KSxhPWcoMTQ2KSxuPWcoOTMwKSxzPWcoOTA0KTt2YXIgcixkLGg7IWZ1bmN0aW9uKEEpe0FbQS5NU0U9MF09XCJNU0VcIixBW0EuU29mdHdhcmU9MV09XCJTb2Z0d2FyZVwifShyPUkuUmFpbndheVZpZGVvRGVjb2Rlcnx8KEkuUmFpbndheVZpZGVvRGVjb2Rlcj17fSkpLGZ1bmN0aW9uKEEpe0FbQS5Bbm5leEI9MF09XCJBbm5leEJcIixBW0EuTGVuZ3RoUHJlZml4ZWQ9MV09XCJMZW5ndGhQcmVmaXhlZFwifShkPUkuUmFpbndheVZpZGVvRm9ybWF0fHwoSS5SYWlud2F5VmlkZW9Gb3JtYXQ9e30pKSxmdW5jdGlvbihBKXtBW0EuSXNvbGF0ZWRBcHBzPTBdPVwiSXNvbGF0ZWRBcHBzXCIsQVtBLkZ1bGxEZXNrdG9wPTFdPVwiRnVsbERlc2t0b3BcIn0oaD1JLlJhaW53YXlTdHJlYW1GaXR8fChJLlJhaW53YXlTdHJlYW1GaXQ9e30pKSxJLk1lZGlhTWFuYWdlcj1jbGFzc3tjb25zdHJ1Y3RvcihBLEksZyxCKXt2YXIgbjt0aGlzLmNhcHR1cmVNb2RlPUEsdGhpcy5jaG9zZW5WaWRlb0NvbmZpZz1JLGUuc2V0KHRoaXMsdm9pZCAwKSx0aGlzLm92ZXJsYXlFbmFibGVkPSExLHRoaXMuc3RyZWFtRml0PWguSXNvbGF0ZWRBcHBzLGkodGhpcyxlLHt2aWRlbzpPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe2NvZGVjU3RyaW5nOid2aWRlby9tcDQ7IGNvZGVjcz1cImF2YzEuNDJjMDIwXCInfSx0aGlzLmF1dG9kZXRlY3RWaWRlb0NvbmZpZ3VyYXRpb24oKSksZy52aWRlbyksdmlkZW9QZXJmb3JtYW5jZTpudWxsIT09KG49Zy52aWRlb1BlcmZvcm1hbmNlKSYmdm9pZCAwIT09bj9uOnt9LGF1ZGlvOk9iamVjdC5hc3NpZ24oe30sZy5hdWRpbyl9KSx0KHRoaXMsZSkudmlkZW8uZGVjb2Rlcj09PXIuU29mdHdhcmU/dGhpcy52aWRlb1N0cmVhbT1uZXcgYS5WaWRlb1N0cmVhbVNvZnR3YXJlRGVjb2Rlcih0KHRoaXMsZSkudmlkZW8uY29kZWNTdHJpbmcsZC5MZW5ndGhQcmVmaXhlZCk6dGhpcy52aWRlb1N0cmVhbT1uZXcgUS5WaWRlb1N0cmVhbU1TRSh0KHRoaXMsZSkudmlkZW8uY29kZWNTdHJpbmcpLHRoaXMuYXVkaW9TdHJlYW09bmV3IEMuQXVkaW9TdHJlYW0sdGhpcy5hdWRpb1N0cmVhbS5jb25maWd1cmUodCh0aGlzLGUpLmF1ZGlvKSx0aGlzLnZpZGVvUGVyZm9ybWFuY2VNb25pdG9yPW5ldyBFLlZpZGVvUGVyZm9ybWFuY2VNb25pdG9yKHRoaXMudmlkZW9TdHJlYW0sdCh0aGlzLGUpLnZpZGVvUGVyZm9ybWFuY2UpLHRoaXMudmlkZW9TdGF0c092ZXJsYXk9bmV3IG8uVmlkZW9TdGF0c092ZXJsYXkodGhpcy52aWRlb1N0cmVhbSx0KHRoaXMsZSkudmlkZW8uZGVjb2Rlcj09PXIuU29mdHdhcmUsQil9Z2V0IHZpZGVvUmVhZHlTdGF0ZUNoYW5nZUV2ZW50KCl7cmV0dXJuIHRoaXMudmlkZW9TdHJlYW0ucmVhZHlTdGF0ZUNoYW5nZUV2ZW50fWdldCB2aWRlb05lZWRzUmVzdGFydEV2ZW50KCl7cmV0dXJuIHRoaXMudmlkZW9TdHJlYW0ubmVlZHNSZXN0YXJ0RXZlbnR9Z2V0IGF1ZGlvQ29udGV4dCgpe3JldHVybiB0aGlzLmF1ZGlvU3RyZWFtLmF1ZGlvQ29udGV4dH1nZXQgY3VycmVudFN0cmVhbUJvdW5kcygpe3JldHVybiB0aGlzLnN0cmVhbUJvdW5kc31nZXQgY3VycmVudEZ1bGxEZXNrdG9wQm91bmRzKCl7cmV0dXJuIHRoaXMuZnVsbERlc2t0b3BCb3VuZHN9aW5pdGlhbGl6ZSgpe3JldHVybiBCKHRoaXMsdm9pZCAwLHZvaWQgMCwoZnVuY3Rpb24qKCl7eWllbGQgdGhpcy5hdWRpb1N0cmVhbS5pbml0aWFsaXplKCksdGhpcy5hdWRpb1N0cmVhbS5wbGF5KCl9KSl9Z2V0IGNvbmZpZygpe3JldHVybiB0KHRoaXMsZSl9YXV0b2RldGVjdFZpZGVvQ29uZmlndXJhdGlvbigpe3JldHVybntkZWNvZGVyOndpbmRvdy5NZWRpYVNvdXJjZT9yLk1TRTpyLlNvZnR3YXJlfX1zZXRDb250YWluZXIoQSl7aWYodGhpcy51bnNldENvbnRhaW5lcigpLHRoaXMuY29udGFpbmVyPUEsdGhpcy5jYXB0dXJlTW9kZT09PXMuQ2FwdHVyZU1vZGUuQXBwSXNvbGF0aW9uKXtjb25zdCBBPXRoaXMuY3JlYXRlSXNvbGF0aW9uQ2FudmFzRWxlbWVudCgpO3RoaXMuc2hvd1N0cmVhbUVsZW1lbnQoQSksdCh0aGlzLGUpLnZpZGVvLmRlY29kZXI9PT1yLk1TRT90aGlzLnNldElzb2xhdGlvblNvdXJjZSh0aGlzLmNyZWF0ZVZpZGVvRWxlbWVudCgpKTp0aGlzLnNldElzb2xhdGlvblNvdXJjZSh0aGlzLmNyZWF0ZUNhbnZhc0VsZW1lbnQoKSl9ZWxzZSB0KHRoaXMsZSkudmlkZW8uZGVjb2Rlcj09PXIuTVNFP3RoaXMuc2hvd1N0cmVhbUVsZW1lbnQodGhpcy5jcmVhdGVWaWRlb0VsZW1lbnQoKSk6dGhpcy5zaG93U3RyZWFtRWxlbWVudCh0aGlzLmNyZWF0ZUNhbnZhc0VsZW1lbnQoKSk7dGhpcy5vdmVybGF5RW5hYmxlZCYmdGhpcy5jcmVhdGVBbmRTaG93U3RhdHNPdmVybGF5KCl9c2V0SXNvbGF0aW9uU291cmNlKEEpe3RoaXMuaXNvbGF0aW9uU291cmNlPUF9Y3JlYXRlQW5kU2hvd1N0YXRzT3ZlcmxheSgpe2NvbnN0IEE9dGhpcy5jcmVhdGVPdmVybGF5Q2FudmFzRWxlbWVudCgpO3RoaXMuc2hvd092ZXJsYXlFbGVtZW50KEEpLHQodGhpcyxlKS52aWRlby5kZWNvZGVyPT09ci5NU0U/dGhpcy52aWRlb1N0YXRzT3ZlcmxheS5zZXRFbGVtZW50cyh7dmlkZW86dGhpcy52aWRlb0VsZW1lbnQsY2FudmFzOkEsdXNpbmdPdXRwdXRDYW52YXM6ITF9KTp0aGlzLnZpZGVvU3RhdHNPdmVybGF5LnNldEVsZW1lbnRzKHtjYW52YXM6QSx1c2luZ091dHB1dENhbnZhczohMX0pfXVuc2V0Q29udGFpbmVyKCl7dmFyIEEsSSxnLGUsQixpLHQsUTt0aGlzLmRpc3Bvc2VWaWRlb0VsZW1lbnQoKSx0aGlzLmRpc3Bvc2VDYW52YXNFbGVtZW50KCksdGhpcy5kaXNwb3NlT3ZlcmxheUNhbnZhc0VsZW1lbnQoKSx0aGlzLmRpc3Bvc2VJc29sYXRpb25DYW52YXNFbGVtZW50KCksbnVsbD09PShJPW51bGw9PT0oQT10aGlzLmNvbnRhaW5lcil8fHZvaWQgMD09PUE/dm9pZCAwOkEucXVlcnlTZWxlY3RvcihcIi5yYWlud2F5LXZpZGVvXCIpKXx8dm9pZCAwPT09SXx8SS5yZW1vdmUoKSxudWxsPT09KGU9bnVsbD09PShnPXRoaXMuY29udGFpbmVyKXx8dm9pZCAwPT09Zz92b2lkIDA6Zy5xdWVyeVNlbGVjdG9yKFwiLnJhaW53YXktY2FudmFzXCIpKXx8dm9pZCAwPT09ZXx8ZS5yZW1vdmUoKSxudWxsPT09KGk9bnVsbD09PShCPXRoaXMuY29udGFpbmVyKXx8dm9pZCAwPT09Qj92b2lkIDA6Qi5xdWVyeVNlbGVjdG9yKFwiLnJhaW53YXktb3ZlcmxheS1jYW52YXNcIikpfHx2b2lkIDA9PT1pfHxpLnJlbW92ZSgpLG51bGw9PT0oUT1udWxsPT09KHQ9dGhpcy5jb250YWluZXIpfHx2b2lkIDA9PT10P3ZvaWQgMDp0LnF1ZXJ5U2VsZWN0b3IoXCIucmFpbndheS1pc29sYXRpb24tY2FudmFzXCIpKXx8dm9pZCAwPT09UXx8US5yZW1vdmUoKSx0aGlzLmNvbnRhaW5lcj12b2lkIDB9c2hvd092ZXJsYXlFbGVtZW50KEEpe09iamVjdC5hc3NpZ24oQS5zdHlsZSx7cG9zaXRpb246XCJhYnNvbHV0ZVwiLHRvcDpcIjBcIixib3R0b206XCIwXCIsbGVmdDpcIjBcIixyaWdodDpcIjBcIix3aWR0aDpcIjEwMCVcIixoZWlnaHQ6XCIxMDAlXCIscG9pbnRlckV2ZW50czpcIm5vbmVcIn0pfWNyZWF0ZVZpZGVvRWxlbWVudCgpe3ZhciBBLEk7bnVsbD09PShJPW51bGw9PT0oQT10aGlzLmNvbnRhaW5lcil8fHZvaWQgMD09PUE/dm9pZCAwOkEucXVlcnlTZWxlY3RvcihcIi5yYWlud2F5LXZpZGVvXCIpKXx8dm9pZCAwPT09SXx8SS5yZW1vdmUoKSx0aGlzLnZpZGVvRWxlbWVudD1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwidmlkZW9cIik7Y29uc3QgZz10aGlzLnZpZGVvRWxlbWVudDtyZXR1cm4gZy5vbmNvbnRleHRtZW51PSgpPT4hMSxnLmNsYXNzTmFtZT1cInJhaW53YXktdmlkZW9cIixnLmF1dG9wbGF5PSEwLGcubXV0ZWQ9ITAsZy5zdHlsZS5kaXNwbGF5PVwibm9uZVwiLHRoaXMuY29udGFpbmVyLmFwcGVuZENoaWxkKGcpLHRoaXMudmlkZW9TdHJlYW0uYXR0YWNoVG9FbGVtZW50KGcpLHRoaXMudmlkZW9FbGVtZW50fWRpc3Bvc2VWaWRlb0VsZW1lbnQoKXt0aGlzLnZpZGVvRWxlbWVudCYmKHRoaXMudmlkZW9TdHJlYW0uZGV0YWNoRnJvbUVsZW1lbnQoKSx0aGlzLnZpZGVvRWxlbWVudC5yZW1vdmUoKSx0aGlzLnZpZGVvRWxlbWVudD12b2lkIDApfWNyZWF0ZU92ZXJsYXlDYW52YXNFbGVtZW50KCl7dmFyIEEsSSxnO251bGw9PT0oST1udWxsPT09KEE9dGhpcy5jb250YWluZXIpfHx2b2lkIDA9PT1BP3ZvaWQgMDpBLnF1ZXJ5U2VsZWN0b3IoXCIucmFpbndheS1vdmVybGF5LWNhbnZhc1wiKSl8fHZvaWQgMD09PUl8fEkucmVtb3ZlKCksdGhpcy5jYW52YXNFbGVtZW50PWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7Y29uc3QgZT10aGlzLmNhbnZhc0VsZW1lbnQ7cmV0dXJuIGUub25jb250ZXh0bWVudT0oKT0+ITEsZS5jbGFzc05hbWU9XCJyYWlud2F5LW92ZXJsYXktY2FudmFzXCIsdGhpcy5jb250YWluZXIuYXBwZW5kQ2hpbGQoZSksbnVsbD09PShnPWUuZ2V0Q29udGV4dChcIjJkXCIpKXx8dm9pZCAwPT09Z3x8Zy5jbGVhclJlY3QoMCwwLGUud2lkdGgsZS5oZWlnaHQpLGV9ZGlzcG9zZU92ZXJsYXlDYW52YXNFbGVtZW50KCl7dmFyIEEsSTtudWxsPT09KEk9bnVsbD09PShBPXRoaXMuY29udGFpbmVyKXx8dm9pZCAwPT09QT92b2lkIDA6QS5xdWVyeVNlbGVjdG9yKFwiLnJhaW53YXktb3ZlcmxheS1jYW52YXNcIikpfHx2b2lkIDA9PT1JfHxJLnJlbW92ZSgpLHRoaXMub3ZlcmxheUNhbnZhc0VsZW1lbnQmJih0aGlzLm92ZXJsYXlDYW52YXNFbGVtZW50LnJlbW92ZSgpLHRoaXMub3ZlcmxheUNhbnZhc0VsZW1lbnQ9dm9pZCAwKX1jcmVhdGVDYW52YXNFbGVtZW50KCl7dmFyIEEsSSxnO251bGw9PT0oST1udWxsPT09KEE9dGhpcy5jb250YWluZXIpfHx2b2lkIDA9PT1BP3ZvaWQgMDpBLnF1ZXJ5U2VsZWN0b3IoXCIucmFpbndheS1jYW52YXNcIikpfHx2b2lkIDA9PT1JfHxJLnJlbW92ZSgpLHRoaXMuY2FudmFzRWxlbWVudD1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO2NvbnN0IGU9dGhpcy5jYW52YXNFbGVtZW50O3JldHVybiBlLm9uY29udGV4dG1lbnU9KCk9PiExLGUuY2xhc3NOYW1lPVwicmFpbndheS1jYW52YXNcIixlLnN0eWxlLmRpc3BsYXk9XCJub25lXCIsdGhpcy5jb250YWluZXIuYXBwZW5kQ2hpbGQoZSksdGhpcy52aWRlb1N0cmVhbSBpbnN0YW5jZW9mIGEuVmlkZW9TdHJlYW1Tb2Z0d2FyZURlY29kZXImJnRoaXMudmlkZW9TdHJlYW0uYXR0YWNoVG9DYW52YXMoZSksbnVsbD09PShnPWUuZ2V0Q29udGV4dChcIjJkXCIpKXx8dm9pZCAwPT09Z3x8Zy5jbGVhclJlY3QoMCwwLGUud2lkdGgsZS5oZWlnaHQpLGV9ZGlzcG9zZUNhbnZhc0VsZW1lbnQoKXt0aGlzLmNhbnZhc0VsZW1lbnQmJih0aGlzLnZpZGVvU3RyZWFtIGluc3RhbmNlb2YgYS5WaWRlb1N0cmVhbVNvZnR3YXJlRGVjb2RlciYmdGhpcy52aWRlb1N0cmVhbS5kZXRhY2hGcm9tQ2FudmFzKCksdGhpcy5jYW52YXNFbGVtZW50LnJlbW92ZSgpLHRoaXMuY2FudmFzRWxlbWVudD12b2lkIDApfWNyZWF0ZUlzb2xhdGlvbkNhbnZhc0VsZW1lbnQoKXt2YXIgQSxJLGc7bnVsbD09PShJPW51bGw9PT0oQT10aGlzLmNvbnRhaW5lcil8fHZvaWQgMD09PUE/dm9pZCAwOkEucXVlcnlTZWxlY3RvcihcIi5yYWlud2F5LWlzb2xhdGlvbi1jYW52YXNcIikpfHx2b2lkIDA9PT1JfHxJLnJlbW92ZSgpLHRoaXMuaXNvbGF0aW9uQ2FudmFzRWxlbWVudD1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO2NvbnN0IGU9dGhpcy5pc29sYXRpb25DYW52YXNFbGVtZW50O3JldHVybiBlLm9uY29udGV4dG1lbnU9KCk9PiExLGUuY2xhc3NOYW1lPVwicmFpbndheS1pc29sYXRpb24tY2FudmFzXCIsdGhpcy5jb250YWluZXIuYXBwZW5kQ2hpbGQoZSksbnVsbD09PShnPWUuZ2V0Q29udGV4dChcIjJkXCIpKXx8dm9pZCAwPT09Z3x8Zy5jbGVhclJlY3QoMCwwLGUud2lkdGgsZS5oZWlnaHQpLGV9ZGlzcG9zZUlzb2xhdGlvbkNhbnZhc0VsZW1lbnQoKXt0aGlzLmlzb2xhdGlvbkNhbnZhc0VsZW1lbnQmJih0aGlzLmlzb2xhdGlvbkNhbnZhc0VsZW1lbnQucmVtb3ZlKCksdGhpcy5pc29sYXRpb25DYW52YXNFbGVtZW50PXZvaWQgMCl9aGlkZVN0cmVhbUVsZW1lbnQoQSl7QS5zdHlsZS53aWR0aD1cIjBcIixBLnN0eWxlLmhlaWdodD1cIjBcIn1zaG93U3RyZWFtRWxlbWVudChBKXt0aGlzLmNvbnRhaW5lciYmKHRoaXMuc3RyZWFtRWxlbWVudD1BLEEuc3R5bGUud2lkdGg9XCIxMDAlXCIsQS5zdHlsZS5oZWlnaHQ9XCIxMDAlXCIsQS5zdHlsZS5kaXNwbGF5PVwiYmxvY2tcIixBLnN0eWxlLm9iamVjdEZpdD1cImNvbnRhaW5cIil9cGF1c2UoKXt0aGlzLnZpZGVvU3RyZWFtLnBhdXNlKCksdGhpcy5hdWRpb1N0cmVhbS5zdG9wKCl9cGxheSgpe3RoaXMudmlkZW9TdHJlYW0ucGxheSgpLHRoaXMuYXVkaW9TdHJlYW0ucGxheSgpfXJlbmRlclZpZGVvRnJhbWUoQSxJKXt0aGlzLnZpZGVvU3RyZWFtLnB1c2hEYXRhKEEsSSksdGhpcy5mdWxsRGVza3RvcEJvdW5kcz17bGVmdDpBLngsdG9wOkEueSx3aWR0aDpBLndpZHRoLGhlaWdodDpBLmhlaWdodH0sdGhpcy5jYXB0dXJlTW9kZT09PXMuQ2FwdHVyZU1vZGUuQXBwSXNvbGF0aW9uPyhBLm1hc2subGVuZ3RoPjAmJih0aGlzLm1hc2s9QS5tYXNrKSxBLndpZHRoPjAmJih0aGlzLmZyYW1lV2lkdGg9QS53aWR0aCksQS5oZWlnaHQ+MCYmKHRoaXMuZnJhbWVIZWlnaHQ9QS5oZWlnaHQpLHRoaXMucmVuZGVySXNvbGF0ZWRBcHAoKSk6dGhpcy5zdHJlYW1Cb3VuZHM9dGhpcy5mdWxsRGVza3RvcEJvdW5kc31yZW5kZXJJc29sYXRlZEFwcCgpe2lmKCF0aGlzLm1hc2spcmV0dXJuO2lmKCF0aGlzLmZyYW1lV2lkdGgpcmV0dXJuO2lmKCF0aGlzLmZyYW1lSGVpZ2h0KXJldHVybjtjb25zdCBBPXRoaXMuaXNvbGF0aW9uU291cmNlO2lmKCFBKXJldHVybjtjb25zdCBJPXRoaXMuaXNvbGF0aW9uQ2FudmFzRWxlbWVudDtpZighSSlyZXR1cm47Y29uc3QgZz1JLmdldENvbnRleHQoXCIyZFwiKTtpZighZylyZXR1cm47Y29uc3QgZT10aGlzLnN0cmVhbUZpdD09aC5Jc29sYXRlZEFwcHM/bi5ib3VuZGluZ1JlY3RhbmdsZSh0aGlzLm1hc2spOnRoaXMuZnVsbERlc2t0b3BCb3VuZHM7dGhpcy5zdHJlYW1Cb3VuZHM9ZTtjb25zdCBCPXRoaXMuY2hvc2VuVmlkZW9Db25maWcuY29kZWMud2lkdGgvdGhpcy5mcmFtZVdpZHRoLGk9dGhpcy5jaG9zZW5WaWRlb0NvbmZpZy5jb2RlYy5oZWlnaHQvdGhpcy5mcmFtZUhlaWdodDtJLndpZHRoPWUud2lkdGgqQixJLmhlaWdodD1lLmhlaWdodCppO2Zvcihjb25zdHtsZWZ0OkksdG9wOnQsd2lkdGg6USxoZWlnaHQ6Q31vZiB0aGlzLm1hc2spe2NvbnN0IEU9SSpCLG89dCppLGE9USpCLG49QyppLHM9KEktZS5sZWZ0KSpCLHI9KHQtZS50b3ApKmk7Zy5kcmF3SW1hZ2UoQSxFLG8sYSxuLHMscixhLG4pfX1wcm9jZXNzQXVkaW8oQSl7dGhpcy5hdWRpb1N0cmVhbS5wdXNoRGF0YShBKX1nZXRWaWRlb1N0YXRzKCl7cmV0dXJuIHRoaXMudmlkZW9TdHJlYW0uZ2V0U3RhdHMoKX1jb25maWd1cmVBdWRpbyhBKXtyZXR1cm4gQih0aGlzLHZvaWQgMCx2b2lkIDAsKGZ1bmN0aW9uKigpe3QodGhpcyxlKS5hdWRpbz1PYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sdCh0aGlzLGUpLmF1ZGlvKSxBKSx0aGlzLmF1ZGlvU3RyZWFtLmNvbmZpZ3VyZShBKX0pKX1lbmFibGVTdGF0c092ZXJsYXkoKXt0aGlzLm92ZXJsYXlFbmFibGVkPSEwLHRoaXMudmlkZW9TdGF0c092ZXJsYXkuZW5hYmxlKCksdGhpcy5kaXNwb3NlT3ZlcmxheUNhbnZhc0VsZW1lbnQoKSx0aGlzLmNyZWF0ZUFuZFNob3dTdGF0c092ZXJsYXkoKX1kaXNhYmxlU3RhdHNPdmVybGF5KCl7dGhpcy5kaXNwb3NlT3ZlcmxheUNhbnZhc0VsZW1lbnQoKSx0aGlzLm92ZXJsYXlFbmFibGVkPSExLHRoaXMudmlkZW9TdGF0c092ZXJsYXkuZGlzYWJsZSgpfWRpc3Bvc2UoKXt0aGlzLnBhdXNlKCksdGhpcy51bnNldENvbnRhaW5lcigpLHRoaXMuYXVkaW9TdHJlYW0uZGlzcG9zZSgpLHRoaXMudmlkZW9TdHJlYW0uZGlzcG9zZSgpfXNldFZvbHVtZShBKXt0aGlzLmF1ZGlvU3RyZWFtLnNldFZvbHVtZShBKX19LGU9bmV3IFdlYWtNYXB9LDYzMzpmdW5jdGlvbihBLEkpe1widXNlIHN0cmljdFwiO3ZhciBnLGU9dGhpcyYmdGhpcy5fX2F3YWl0ZXJ8fGZ1bmN0aW9uKEEsSSxnLGUpe3JldHVybiBuZXcoZ3x8KGc9UHJvbWlzZSkpKChmdW5jdGlvbihCLGkpe2Z1bmN0aW9uIHQoQSl7dHJ5e0MoZS5uZXh0KEEpKX1jYXRjaChBKXtpKEEpfX1mdW5jdGlvbiBRKEEpe3RyeXtDKGUudGhyb3coQSkpfWNhdGNoKEEpe2koQSl9fWZ1bmN0aW9uIEMoQSl7dmFyIEk7QS5kb25lP0IoQS52YWx1ZSk6KEk9QS52YWx1ZSxJIGluc3RhbmNlb2YgZz9JOm5ldyBnKChmdW5jdGlvbihBKXtBKEkpfSkpKS50aGVuKHQsUSl9QygoZT1lLmFwcGx5KEEsSXx8W10pKS5uZXh0KCkpfSkpfSxCPXRoaXMmJnRoaXMuX19jbGFzc1ByaXZhdGVGaWVsZEdldHx8ZnVuY3Rpb24oQSxJKXtpZighSS5oYXMoQSkpdGhyb3cgbmV3IFR5cGVFcnJvcihcImF0dGVtcHRlZCB0byBnZXQgcHJpdmF0ZSBmaWVsZCBvbiBub24taW5zdGFuY2VcIik7cmV0dXJuIEkuZ2V0KEEpfSxpPXRoaXMmJnRoaXMuX19jbGFzc1ByaXZhdGVGaWVsZFNldHx8ZnVuY3Rpb24oQSxJLGcpe2lmKCFJLmhhcyhBKSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiYXR0ZW1wdGVkIHRvIHNldCBwcml2YXRlIGZpZWxkIG9uIG5vbi1pbnN0YW5jZVwiKTtyZXR1cm4gSS5zZXQoQSxnKSxnfTtPYmplY3QuZGVmaW5lUHJvcGVydHkoSSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxJLkNpcmN1bGFyQnVmZmVyPUkuYXZlcmFnZT1JLmNyZWF0ZVNvdXJjZUJ1ZmZlcj1JLmF3YWl0TWVkaWFTb3VyY2VPcGVuPUkuY3JlYXRlTWVkaWFTb3VyY2U9SS5NZWRpYVVuc3VwcG9ydGVkRXJyb3I9dm9pZCAwO2NsYXNzIHQgZXh0ZW5kcyBFcnJvcnt9ZnVuY3Rpb24gUShBLEkpe3JldHVybiBlKHRoaXMsdm9pZCAwLHZvaWQgMCwoZnVuY3Rpb24qKCl7cmV0dXJuIG5ldyBQcm9taXNlKCgoZyxlKT0+e2xldCBCPSExO2NvbnN0IGk9KCk9PntBLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJzb3VyY2VvcGVuXCIsdCksbnVsbD09SXx8SS5yZW1vdmVIYW5kbGVyKEUpLHdpbmRvdy5jbGVhckludGVydmFsKEMpLEI9ITB9LHQ9KCk9PntpKCksZyghMCl9LFE9KCk9PntCfHxcIm9wZW5cIj09PUEucmVhZHlTdGF0ZSYmKGkoKSxnKCEwKSl9LEM9d2luZG93LnNldEludGVydmFsKFEsNTAwKTtRKCksd2luZG93LnNldFRpbWVvdXQoKCgpPT57Qnx8KGkoKSxlKG5ldyBFcnJvcihcIk1lZGlhU291cmNlIG9wZW4gdGltZWQgb3V0LlwiKSkpfSksMWU0KSxBLmFkZEV2ZW50TGlzdGVuZXIoXCJzb3VyY2VvcGVuXCIsdCk7Y29uc3QgRT0oKT0+e2koKSxnKCExKX07bnVsbD09SXx8SS5hZGRIYW5kbGVyKEUpfSkpfSkpfUkuTWVkaWFVbnN1cHBvcnRlZEVycm9yPXQsSS5jcmVhdGVNZWRpYVNvdXJjZT1mdW5jdGlvbihBLEkpe3JldHVybiBlKHRoaXMsdm9pZCAwLHZvaWQgMCwoZnVuY3Rpb24qKCl7aWYoIXdpbmRvdy5NZWRpYVNvdXJjZSl0aHJvdyBuZXcgdChcIkJyb3dzZXIgZG9lcyBub3Qgc3VwcG9ydCBNU0UuXCIpO2NvbnN0IGc9bmV3IE1lZGlhU291cmNlLGU9d2luZG93LlVSTC5jcmVhdGVPYmplY3RVUkwoZyk7aWYoQS5zcmM9dm9pZCAwLEEuc3JjPWUsQS5sb2FkKCkseWllbGQgUShnLEkpKXJldHVybiBnLmR1cmF0aW9uPU51bWJlci5QT1NJVElWRV9JTkZJTklUWSxnfSkpfSxJLmF3YWl0TWVkaWFTb3VyY2VPcGVuPVEsSS5jcmVhdGVTb3VyY2VCdWZmZXI9ZnVuY3Rpb24oQSxJKXtjb25zdCBnPUEuYWRkU291cmNlQnVmZmVyKEkpO3JldHVybiBnLm1vZGU9XCJzZXF1ZW5jZVwiLGd9LEkuYXZlcmFnZT1mdW5jdGlvbihBKXtyZXR1cm4gMD09PUEubGVuZ3RoPzA6QS5yZWR1Y2UoKChBLEkpPT5BK0kpLDApL0EubGVuZ3RofSxJLkNpcmN1bGFyQnVmZmVyPWNsYXNze2NvbnN0cnVjdG9yKEEpe3RoaXMubWF4TGVuZ3RoPUEsdGhpcy5uZXh0SW5kZXg9MCx0aGlzLmxpc3Q9QXJyYXkodGhpcy5tYXhMZW5ndGgpLGcuc2V0KHRoaXMsMCl9Z2V0IGxlbmd0aCgpe3JldHVybiBCKHRoaXMsZyl9cHVzaChBKXt0aGlzLmxpc3RbdGhpcy5uZXh0SW5kZXgrK109QSxpKHRoaXMsZyxNYXRoLm1heChCKHRoaXMsZyksdGhpcy5uZXh0SW5kZXgpKSx0aGlzLm5leHRJbmRleCU9dGhpcy5tYXhMZW5ndGh9dmFsdWVzKCl7cmV0dXJuIHRoaXMubGlzdC5zbGljZSgwLEIodGhpcyxnKSl9fSxnPW5ldyBXZWFrTWFwfSw3ODooQSxJLGcpPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KEksXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksSS5WaWRlb1BlcmZvcm1hbmNlTW9uaXRvcj12b2lkIDA7Y29uc3QgZT1nKDE5OCksQj1nKDQzNCksaT1nKDI0KSx0PXt0YXJnZXRGcmFtZXJhdGU6NjAsYnVmZmVyTGltaXRNczo1MDAsY3B1U3RhcnZhdGlvblRocmVzaG9sZDoxLGRlY29kZXJTdHJ1Z2dsaW5nVGhyZXNob2xkOjEsY2hlY2tJbnRlcnZhbDoxNTAwLHdpbmRvd01zOjUwMH07SS5WaWRlb1BlcmZvcm1hbmNlTW9uaXRvcj1jbGFzc3tjb25zdHJ1Y3RvcihBLEk9e30pe3RoaXMudmlkZW9TdHJlYW09QSx0aGlzLmRlY29kZXJTdHJ1Z2dsaW5nRXZlbnQ9bmV3IGkuQWN0aW9uLHRoaXMuY3B1U3RhcnZhdGlvbkV2ZW50PW5ldyBpLkFjdGlvbix0aGlzLmNwdVN0YXJ2YXRpb25Db3VudGVyPTAsdGhpcy5kZWNvZGVyU3RydWdnbGluZ0NvdW50ZXI9MCx0aGlzLnJlYWR5U3RhdGVDaGFuZ2VIYW5kbGVyPUE9PntBPT09Qi5WaWRlb1JlYWR5U3RhdGUuRGV0YWNoZWQ/dGhpcy5zdG9wQ2hlY2tpbmcoKTp0aGlzLmxhc3RWaWRlb1JlYWR5U3RhdGU9PT1CLlZpZGVvUmVhZHlTdGF0ZS5EZXRhY2hlZCYmdGhpcy5zdGFydENoZWNraW5nKCksdGhpcy5sYXN0VmlkZW9SZWFkeVN0YXRlPUF9LHRoaXMudmlkZW9GcmFtZU1ldGFkYXRhSGFuZGxlcj1BPT57dGhpcy5wcm9jZXNzaW5nRHVyYXRpb25UcmFjay5mZWVkKEEpfSx0aGlzLmNoZWNrUGVyZm9ybWFuY2U9KCk9PntpZih0aGlzLnZpZGVvU3RyZWFtLnJlYWR5U3RhdGU9PT1CLlZpZGVvUmVhZHlTdGF0ZS5QbGF5aW5nKXtjb25zdCBBPTEvdGhpcy5jb25maWcudGFyZ2V0RnJhbWVyYXRlLEk9MWUzKkEsZz1NYXRoLmZsb29yKHRoaXMuY29uZmlnLmJ1ZmZlckxpbWl0TXMvSSksZT10aGlzLnZpZGVvU3RyZWFtLmdldFN0YXRzKCk7KGUuZW5kT2ZCdWZmZXJlZD5lLmN1cnJlbnRUaW1lK3RoaXMuY29uZmlnLmJ1ZmZlckxpbWl0TXMvMWUzfHx0aGlzLnZpZGVvU3RyZWFtLmRhdGFRdWV1ZUxlbmd0aD5nKSYmdGhpcy52aWRlb1N0cmVhbS5yZXN0YXJ0KFwiY2hlY2tQZXJmb3JtYW5jZVwiKSx0aGlzLnZpZGVvU3RyZWFtLmRhdGFRdWV1ZUxlbmd0aD5nP3RoaXMuY3B1U3RhcnZhdGlvbkNvdW50ZXIrPTE6dGhpcy5jcHVTdGFydmF0aW9uQ291bnRlcj1NYXRoLm1heCgwLHRoaXMuY3B1U3RhcnZhdGlvbkNvdW50ZXItMSksdGhpcy5wcm9jZXNzaW5nRHVyYXRpb25UcmFjay5hdmVyYWdlKCk+QT8odGhpcy5kZWNvZGVyU3RydWdnbGluZ0NvdW50ZXIrPTEsdGhpcy5jcHVTdGFydmF0aW9uQ291bnRlcj1NYXRoLm1heCgwLHRoaXMuY3B1U3RhcnZhdGlvbkNvdW50ZXItMSkpOnRoaXMuZGVjb2RlclN0cnVnZ2xpbmdDb3VudGVyPU1hdGgubWF4KDAsdGhpcy5kZWNvZGVyU3RydWdnbGluZ0NvdW50ZXItMSksdGhpcy5jcHVTdGFydmF0aW9uQ291bnRlcix0aGlzLmNvbmZpZy5jcHVTdGFydmF0aW9uVGhyZXNob2xkLHRoaXMuZGVjb2RlclN0cnVnZ2xpbmdDb3VudGVyLHRoaXMuY29uZmlnLmRlY29kZXJTdHJ1Z2dsaW5nVGhyZXNob2xkfX0sdGhpcy5jb25maWc9T2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LHQpLEkpLHRoaXMucHJvY2Vzc2luZ0R1cmF0aW9uVHJhY2s9bmV3IGUuV2luZG93VHJhY2sodGhpcy5jb25maWcud2luZG93TXMsZS5tZWFuT3JaZXJvKSx0aGlzLnZpZGVvU3RyZWFtLnJlYWR5U3RhdGVDaGFuZ2VFdmVudC5hZGRIYW5kbGVyKHRoaXMucmVhZHlTdGF0ZUNoYW5nZUhhbmRsZXIpLHRoaXMudmlkZW9TdHJlYW0udmlkZW9GcmFtZVByb2Nlc3NpbmdEdXJhdGlvbkV2ZW50LmFkZEhhbmRsZXIodGhpcy52aWRlb0ZyYW1lTWV0YWRhdGFIYW5kbGVyKSx0aGlzLmxhc3RWaWRlb1JlYWR5U3RhdGU9dGhpcy52aWRlb1N0cmVhbS5yZWFkeVN0YXRlLHRoaXMudmlkZW9TdHJlYW0ucmVhZHlTdGF0ZSE9PUIuVmlkZW9SZWFkeVN0YXRlLkRldGFjaGVkJiZ0aGlzLnN0YXJ0Q2hlY2tpbmcoKX1kaXNwb3NlKCl7dGhpcy5zdG9wQ2hlY2tpbmcoKSx0aGlzLnZpZGVvU3RyZWFtLnJlYWR5U3RhdGVDaGFuZ2VFdmVudC5yZW1vdmVIYW5kbGVyKHRoaXMucmVhZHlTdGF0ZUNoYW5nZUhhbmRsZXIpLHRoaXMudmlkZW9TdHJlYW0udmlkZW9GcmFtZVByb2Nlc3NpbmdEdXJhdGlvbkV2ZW50LnJlbW92ZUhhbmRsZXIodGhpcy52aWRlb0ZyYW1lTWV0YWRhdGFIYW5kbGVyKX1zdGFydENoZWNraW5nKCl7dGhpcy5wcm9jZXNzaW5nRHVyYXRpb25UcmFjaz1uZXcgZS5XaW5kb3dUcmFjayh0aGlzLmNvbmZpZy53aW5kb3dNcyxlLm1lYW5Pclplcm8pLHRoaXMuY2hlY2tQZXJmb3JtYW5jZUludGVydmFsPXdpbmRvdy5zZXRJbnRlcnZhbCh0aGlzLmNoZWNrUGVyZm9ybWFuY2UsdGhpcy5jb25maWcuY2hlY2tJbnRlcnZhbCl9c3RvcENoZWNraW5nKCl7dGhpcy5jaGVja1BlcmZvcm1hbmNlSW50ZXJ2YWwmJih3aW5kb3cuY2xlYXJJbnRlcnZhbCh0aGlzLmNoZWNrUGVyZm9ybWFuY2VJbnRlcnZhbCksdGhpcy5jaGVja1BlcmZvcm1hbmNlSW50ZXJ2YWw9dm9pZCAwKX19fSw5MTQ6ZnVuY3Rpb24oQSxJLGcpe1widXNlIHN0cmljdFwiO3ZhciBlPXRoaXMmJnRoaXMuX19hd2FpdGVyfHxmdW5jdGlvbihBLEksZyxlKXtyZXR1cm4gbmV3KGd8fChnPVByb21pc2UpKSgoZnVuY3Rpb24oQixpKXtmdW5jdGlvbiB0KEEpe3RyeXtDKGUubmV4dChBKSl9Y2F0Y2goQSl7aShBKX19ZnVuY3Rpb24gUShBKXt0cnl7QyhlLnRocm93KEEpKX1jYXRjaChBKXtpKEEpfX1mdW5jdGlvbiBDKEEpe3ZhciBJO0EuZG9uZT9CKEEudmFsdWUpOihJPUEudmFsdWUsSSBpbnN0YW5jZW9mIGc/STpuZXcgZygoZnVuY3Rpb24oQSl7QShJKX0pKSkudGhlbih0LFEpfUMoKGU9ZS5hcHBseShBLEl8fFtdKSkubmV4dCgpKX0pKX07T2JqZWN0LmRlZmluZVByb3BlcnR5KEksXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksSS5WaWRlb1N0YXRzT3ZlcmxheT12b2lkIDA7Y29uc3QgQj1nKDE0NiksaT1nKDQzNCksdD1nKDE5OCksUT01ZTMsQz17ZHJvcHBlZEZyYW1lczpcIkRyb3BwZWQgZnJhbWVzXCIsdG90YWxGcmFtZXM6XCJUb3RhbCBmcmFtZXNcIixjdXJyZW50VGltZTpcIkN1cnJlbnQgdmlkZW8gdGltZVwiLGVuZE9mQnVmZmVyZWQ6XCJFbmQgb2YgdmlkZW8gYnVmZmVyXCIsZW5kT2ZTZWVrYWJsZTpcIkVuZCBvZiB2aWRlbyBzZWVrYWJsZVwiLGRhdGFJbnRlcnZhbDpcIlZpZGVvIGRhdGEgaW50ZXJ2YWxcIixkYXRhU2l6ZTpcIlZpZGVvIGZyYW1lIHNpemVcIixwcm9jZXNzaW5nRHVyYXRpb246XCJGcmFtZSBwcm9jZXNzaW5nIGR1cmF0aW9uXCJ9O0kuVmlkZW9TdGF0c092ZXJsYXk9Y2xhc3N7Y29uc3RydWN0b3IoQSxJLGcpe3RoaXMudmlkZW9TdHJlYW09QSx0aGlzLnVzaW5nT3V0cHV0Q2FudmFzPUksdGhpcy5nZXRTdGF0cz1nLHRoaXMuY29tcG9zaXRpbmdUaW1lVHJhY2s9bmV3IHQuV2luZG93VHJhY2soUSx0Lm1lYW4pLHRoaXMucHJvY2Vzc2luZ0R1cmF0aW9uVHJhY2s9bmV3IHQuV2luZG93VHJhY2soUSx0Lm1lYW4pLHRoaXMuZnJhbWVUcmFjaz1uZXcgdC5XaW5kb3dUcmFjayhRLHQubWVhbiksdGhpcy5kcmF3SW50ZXJ2YWxUcmFjaz1uZXcgdC5XaW5kb3dUcmFjayhRLHQubWVhbiksdGhpcy5kaXNwbGF5VGltZUludGVydmFsVHJhY2s9bmV3IHQuV2luZG93VHJhY2soUSx0Lm1lYW4pLHRoaXMuZnJhbWVDb3VudGVyPTAsdGhpcy50aHJvdWdocHV0PVtdLHRoaXMuZmV0Y2hTdGF0cz0oKT0+ZSh0aGlzLHZvaWQgMCx2b2lkIDAsKGZ1bmN0aW9uKigpe3RoaXMudmlkZW9TdHJlYW0ucmVhZHlTdGF0ZT09PWkuVmlkZW9SZWFkeVN0YXRlLlBsYXlpbmcmJih0aGlzLnN0YXRzPXRoaXMudmlkZW9TdHJlYW0uZ2V0U3RhdHMoKSx0aGlzLmxhc3RUcmFuc3BvcnRTdGF0cz10aGlzLnRyYW5zcG9ydFN0YXRzLHRoaXMudHJhbnNwb3J0U3RhdHM9eWllbGQgdGhpcy5nZXRTdGF0cygpLHRoaXMudGhyb3VnaHB1dD10aGlzLmdldFRocm91Z2hwdXQoKSl9KSksdGhpcy5hbmltYXRpb25GcmFtZUhhbmRsZXI9KCk9Pnt0aGlzLmZyYW1lVHJhY2suZmVlZCh0aGlzLmZyYW1lQ291bnRlciksdGhpcy5mcmFtZUNvdW50ZXI9MCx0aGlzLmFuaW1hdGlvbkZyYW1lSGFuZGxlPXdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUodGhpcy5hbmltYXRpb25GcmFtZUhhbmRsZXIpfSx0aGlzLmRyYXdTdGF0c09ubHlPbkFuaW1hdGlvbkZyYW1lPSgpPT57aWYodGhpcy5kcmF3U3RhdHNPbmx5SGFuZGxlPXdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUodGhpcy5kcmF3U3RhdHNPbmx5T25BbmltYXRpb25GcmFtZSksIXRoaXMuY2FudmFzQ29udGV4dHx8dGhpcy52aWRlb1N0cmVhbS5yZWFkeVN0YXRlIT09aS5WaWRlb1JlYWR5U3RhdGUuUGxheWluZylyZXR1cm47Y29uc3QgQT10aGlzLmNhbnZhc0NvbnRleHQ7dGhpcy51c2luZ091dHB1dENhbnZhc3x8KEEuY2FudmFzLndpZHRoIT09QS5jYW52YXMuY2xpZW50V2lkdGgmJihBLmNhbnZhcy53aWR0aD1BLmNhbnZhcy5jbGllbnRXaWR0aCksQS5jYW52YXMuaGVpZ2h0IT09QS5jYW52YXMuY2xpZW50SGVpZ2h0JiYoQS5jYW52YXMuaGVpZ2h0PUEuY2FudmFzLmNsaWVudEhlaWdodCksQS5jbGVhclJlY3QoMCwwLEEuY2FudmFzLndpZHRoLEEuY2FudmFzLmhlaWdodCkpLHRoaXMuZHJhd1N0YXRzKCl9LHRoaXMuZHJhd1N0YXRzQW5kR3JhcGhzT25WaWRlb0ZyYW1lPShbQSxJXSk9PntpZih0aGlzLmZyYW1lQ291bnRlcisrLCF0aGlzLmNhbnZhc0NvbnRleHR8fHRoaXMudmlkZW9TdHJlYW0ucmVhZHlTdGF0ZSE9PWkuVmlkZW9SZWFkeVN0YXRlLlBsYXlpbmd8fCFJKXJldHVybjtjb25zdCBnPXRoaXMuY2FudmFzQ29udGV4dDt0aGlzLnVzaW5nT3V0cHV0Q2FudmFzfHwoZy5jYW52YXMud2lkdGghPT1nLmNhbnZhcy5jbGllbnRXaWR0aCYmKGcuY2FudmFzLndpZHRoPWcuY2FudmFzLmNsaWVudFdpZHRoKSxnLmNhbnZhcy5oZWlnaHQhPT1nLmNhbnZhcy5jbGllbnRIZWlnaHQmJihnLmNhbnZhcy5oZWlnaHQ9Zy5jYW52YXMuY2xpZW50SGVpZ2h0KSxnLmNsZWFyUmVjdCgwLDAsZy5jYW52YXMud2lkdGgsZy5jYW52YXMuaGVpZ2h0KSk7Y29uc3QgZT1wZXJmb3JtYW5jZS5ub3coKTt0aGlzLmxhc3RDYW52YXNEcmF3VGltZSYmdGhpcy5kcmF3SW50ZXJ2YWxUcmFjay5mZWVkKGUtdGhpcy5sYXN0Q2FudmFzRHJhd1RpbWUpLHRoaXMubGFzdENhbnZhc0RyYXdUaW1lPWU7Y29uc3QgQj1JLmV4cGVjdGVkRGlzcGxheVRpbWU7dGhpcy5sYXN0RGlzcGxheVRpbWUmJnRoaXMuZGlzcGxheVRpbWVJbnRlcnZhbFRyYWNrLmZlZWQoQi10aGlzLmxhc3REaXNwbGF5VGltZSksdGhpcy5sYXN0RGlzcGxheVRpbWU9Qix0aGlzLmNvbXBvc2l0aW5nVGltZVRyYWNrLmZlZWQoSS5leHBlY3RlZERpc3BsYXlUaW1lLUEpLHRoaXMucHJvY2Vzc2luZ0R1cmF0aW9uVHJhY2suZmVlZChJLnByb2Nlc3NpbmdEdXJhdGlvbik7Y29uc3QgdD1nLmNhbnZhczt0LndpZHRoLHQuY2xpZW50V2lkdGgsdC5oZWlnaHQsdC5jbGllbnRIZWlnaHQsdGhpcy5kcmF3U3RhdHMoSSl9fXNldEVsZW1lbnRzKHt2aWRlbzpBLGNhbnZhczpJLHVzaW5nT3V0cHV0Q2FudmFzOmc9ITF9KXt0aGlzLnVzaW5nT3V0cHV0Q2FudmFzPWcsdGhpcy5jYW52YXM9SSx0aGlzLnZpZGVvPUEsdGhpcy5jYW52YXMmJih0aGlzLmNhbnZhc0NvbnRleHQ9dGhpcy5jYW52YXMuZ2V0Q29udGV4dChcIjJkXCIse2FscGhhOiF0aGlzLnVzaW5nT3V0cHV0Q2FudmFzfSkpfWVuYWJsZSgpe3RoaXMuYW5pbWF0aW9uRnJhbWVIYW5kbGUmJndpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLmFuaW1hdGlvbkZyYW1lSGFuZGxlKSx0aGlzLmRyYXdTdGF0c09ubHlIYW5kbGUmJndpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLmRyYXdTdGF0c09ubHlIYW5kbGUpLHRoaXMudmlkZW9TdHJlYW0gaW5zdGFuY2VvZiBCLlZpZGVvU3RyZWFtU29mdHdhcmVEZWNvZGVyfHxcInJlcXVlc3RWaWRlb0ZyYW1lQ2FsbGJhY2tcImluIEhUTUxWaWRlb0VsZW1lbnQucHJvdG90eXBlPyh0aGlzLmFuaW1hdGlvbkZyYW1lSGFuZGxlPXdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUodGhpcy5hbmltYXRpb25GcmFtZUhhbmRsZXIpLHRoaXMudmlkZW9TdHJlYW0udmlkZW9GcmFtZUV2ZW50LmFkZEhhbmRsZXIodGhpcy5kcmF3U3RhdHNBbmRHcmFwaHNPblZpZGVvRnJhbWUpKTp0aGlzLmRyYXdTdGF0c09ubHlIYW5kbGU9d2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSh0aGlzLmRyYXdTdGF0c09ubHlPbkFuaW1hdGlvbkZyYW1lKSx0aGlzLnN0YXRzSW50ZXJ2YWw9d2luZG93LnNldEludGVydmFsKHRoaXMuZmV0Y2hTdGF0cywxZTMpfWRpc2FibGUoKXt0aGlzLmFuaW1hdGlvbkZyYW1lSGFuZGxlJiZ3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy5hbmltYXRpb25GcmFtZUhhbmRsZSksdGhpcy5kcmF3U3RhdHNPbmx5SGFuZGxlJiZ3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy5kcmF3U3RhdHNPbmx5SGFuZGxlKSx0aGlzLnZpZGVvU3RyZWFtLnZpZGVvRnJhbWVFdmVudC5yZW1vdmVIYW5kbGVyKHRoaXMuZHJhd1N0YXRzQW5kR3JhcGhzT25WaWRlb0ZyYW1lKSx3aW5kb3cuY2xlYXJJbnRlcnZhbCh0aGlzLnN0YXRzSW50ZXJ2YWwpfWdldFRocm91Z2hwdXQoKXt2YXIgQTtyZXR1cm4gdGhpcy50cmFuc3BvcnRTdGF0cyYmdGhpcy5sYXN0VHJhbnNwb3J0U3RhdHM/T2JqZWN0LmVudHJpZXMobnVsbD09PShBPXRoaXMudHJhbnNwb3J0U3RhdHMpfHx2b2lkIDA9PT1BP3ZvaWQgMDpBLmNoYW5uZWxzKS5tYXAoKChbQSxJXSk9PnRoaXMubGFzdFRyYW5zcG9ydFN0YXRzP1tBLEkuYnl0ZXNTZW50LXRoaXMubGFzdFRyYW5zcG9ydFN0YXRzLmNoYW5uZWxzW0FdLmJ5dGVzU2VudCxJLmJ5dGVzUmVjZWl2ZWQtdGhpcy5sYXN0VHJhbnNwb3J0U3RhdHMuY2hhbm5lbHNbQV0uYnl0ZXNSZWNlaXZlZF06W0EsMCwwXSkpOltdfWRyYXdTdGF0cyhBKXt2YXIgSSxnO2lmKCF0aGlzLmNhbnZhc0NvbnRleHR8fHRoaXMudmlkZW9TdHJlYW0ucmVhZHlTdGF0ZSE9PWkuVmlkZW9SZWFkeVN0YXRlLlBsYXlpbmcpcmV0dXJuO2NvbnN0IGU9dGhpcy5jYW52YXNDb250ZXh0LEI9ZS5jYW52YXMsdD1CLndpZHRoL0IuY2xpZW50V2lkdGgsUT1CLmhlaWdodC9CLmNsaWVudEhlaWdodCxFPXRoaXMudGhyb3VnaHB1dDtpZih0aGlzLnN0YXRzKXtjb25zdCBpPU9iamVjdC5lbnRyaWVzKHRoaXMuc3RhdHMpLG89aS5sZW5ndGgrRS5sZW5ndGgsYT1lLm1lYXN1cmVUZXh0KFwiTVwiKS53aWR0aDtlLmZpbGxTdHlsZT1cInJnYmEoMCwgMCwgMCwgMC41KVwiO2NvbnN0IG49KG8rMikqYSsyKihhKzIqUSkrMTUqUTtlLmZpbGxSZWN0KDEwKnQsQi5oZWlnaHQtKG4rMTAqUSksMzAwKnQsbiksZS5maWxsU3R5bGU9XCJ3aGl0ZVwiLGUuZm9udD1gJHsoMTIqdCkudG9GaXhlZCgwKX1weCBzYW5zLXNlcmlmYCxlLnRleHRCYXNlbGluZT1cInRvcFwiO2xldCBzPTA7Y29uc3Qgcj1CLmhlaWdodC0obisxNSpRKSsxNSp0O0E/ZS5maWxsVGV4dChgUmVzb2x1dGlvbjogJHtBLndpZHRofXgke0EuaGVpZ2h0fWAsMTUqdCxyKTplLmZpbGxUZXh0KGBSZXNvbHV0aW9uOiAke251bGw9PT0oST10aGlzLnZpZGVvKXx8dm9pZCAwPT09ST92b2lkIDA6SS52aWRlb1dpZHRofXgke251bGw9PT0oZz10aGlzLnZpZGVvKXx8dm9pZCAwPT09Zz92b2lkIDA6Zy52aWRlb0hlaWdodH1gLDE1KnQsciksZS5maWxsVGV4dChgRWxlbWVudCBzaXplOiAke0IuY2xpZW50V2lkdGh9eCR7Qi5jbGllbnRIZWlnaHR9YCwxNSp0LHIrYSk7Zm9yKGNvbnN0W0EsSV1vZiBpKXtsZXQgZyxCPVwiXCI7XCJwcm9jZXNzaW5nRHVyYXRpb25cIj09PUE/KEI9XCJtc1wiLGc9MWUzKkkpOmc9SSxcImVuZE9mQnVmZmVyZWRcIj09PUF8fFwiZW5kT2ZTZWVrYWJsZVwiPT09QXx8XCJjdXJyZW50VGltZVwiPT09QT9CPVwic1wiOlwiZGF0YUludGVydmFsXCI9PT1BP0I9XCJtc1wiOlwiZGF0YVNpemVcIj09PUEmJihCPVwiYnl0ZXNcIiksZS5maWxsVGV4dChgJHtDW0FdfTogJHtnLnRvRml4ZWQoMil9ICR7Qn1gLDE1KnQscyooYSsyKlEpKzIqKGErMipRKStyKSxzKyt9Zm9yKGNvbnN0W0EsSSxnXW9mIEUpZS5maWxsVGV4dChgJHtBfSB0aHJvdWdocHV0IC0gdXA6ICR7KEkvMWUzKS50b0ZpeGVkKDApfSBrYi9zLCBkb3duOiAkeyhnLzFlMykudG9GaXhlZCgwKX0ga2Ivc2AsMTUqdCxzKihhKzIqUSkrMiooYSsyKlEpK3IpLHMrK319fX0sNDQxOihBLEksZyk9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkoSSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxJLlZpZGVvU3RhdHM9dm9pZCAwO2NvbnN0IGU9Zyg5OTQpLEI9Zyg2MzMpO0kuVmlkZW9TdGF0cz1jbGFzc3tjb25zdHJ1Y3Rvcigpe3RoaXMucHJvY2Vzc2luZ0R1cmF0aW9ucz1uZXcgTWFwLHRoaXMuZGF0YUludGVydmFscz1uZXcgQi5DaXJjdWxhckJ1ZmZlcig2MCksdGhpcy5kYXRhU2l6ZXM9bmV3IEIuQ2lyY3VsYXJCdWZmZXIoNjApLHRoaXMudG90YWxGcmFtZXM9MCx0aGlzLnByZXNlbnRlZEZyYW1lcz0wfXB1c2hGcmFtZU1ldGFkYXRhKEEpe3RoaXMucHJlc2VudGVkRnJhbWVzKz0xO2NvbnN0e3Byb2Nlc3NpbmdEdXJhdGlvbjpJfT1BLGc9KG5ldyBEYXRlKS5nZXRUaW1lKCk7dGhpcy5wcm9jZXNzaW5nRHVyYXRpb25zLnNldChnLEkpO2Zvcihjb25zdFtBXW9mIHRoaXMucHJvY2Vzc2luZ0R1cmF0aW9ucy5lbnRyaWVzKCkpQTxnLTFlMyYmdGhpcy5wcm9jZXNzaW5nRHVyYXRpb25zLmRlbGV0ZShBKX1yZXBvcnRGcmFtZVN1Ym1pdHRlZCgpe3RoaXMudG90YWxGcmFtZXMrPTF9cmVzZXRGcmFtZUNvdW50cygpe3RoaXMudG90YWxGcmFtZXM9MCx0aGlzLnByZXNlbnRlZEZyYW1lcz0wfXB1c2hEYXRhKEEpe3RoaXMuZGF0YVNpemVzLnB1c2goQS5ieXRlTGVuZ3RoKTtjb25zdCBJPShuZXcgRGF0ZSkuZ2V0VGltZSgpO3RoaXMubGFzdERhdGFUaW1lc3RhbXAmJnRoaXMuZGF0YUludGVydmFscy5wdXNoKEktdGhpcy5sYXN0RGF0YVRpbWVzdGFtcCksdGhpcy5sYXN0RGF0YVRpbWVzdGFtcD1JfXNldEVsZW1lbnQoQSl7dGhpcy5lbGVtZW50PUF9Z2V0UmVwb3J0KCl7aWYoIXRoaXMuZWxlbWVudCl0aHJvdyBuZXcgZS5SYWlud2F5RXJyb3IoXCJnZXRSZXBvcnQoKSBoYXMgbm8gdmlkZW8gZWxlbWVudFwiKTtjb25zdCBBPUIuYXZlcmFnZShBcnJheS5mcm9tKHRoaXMucHJvY2Vzc2luZ0R1cmF0aW9ucy52YWx1ZXMoKSkpLEk9dGhpcy5lbGVtZW50LmJ1ZmZlcmVkLGc9SS5sZW5ndGg+MD9JLmVuZChJLmxlbmd0aC0xKTowLGk9dGhpcy5lbGVtZW50LnNlZWthYmxlLHQ9aS5sZW5ndGg+MD9pLmVuZChpLmxlbmd0aC0xKTowO3JldHVybntwcm9jZXNzaW5nRHVyYXRpb246QSxkcm9wcGVkRnJhbWVzOnRoaXMudG90YWxGcmFtZXMtdGhpcy5wcmVzZW50ZWRGcmFtZXMsdG90YWxGcmFtZXM6dGhpcy50b3RhbEZyYW1lcyxkYXRhSW50ZXJ2YWw6Qi5hdmVyYWdlKHRoaXMuZGF0YUludGVydmFscy52YWx1ZXMoKSksZGF0YVNpemU6Qi5hdmVyYWdlKHRoaXMuZGF0YVNpemVzLnZhbHVlcygpKSxjdXJyZW50VGltZTp0aGlzLmVsZW1lbnQuY3VycmVudFRpbWUsZW5kT2ZCdWZmZXJlZDpnLGVuZE9mU2Vla2FibGU6dH19Y3JlYXRlUmVwb3J0KEEsSSl7cmV0dXJue3Byb2Nlc3NpbmdEdXJhdGlvbjpCLmF2ZXJhZ2UoQXJyYXkuZnJvbSh0aGlzLnByb2Nlc3NpbmdEdXJhdGlvbnMudmFsdWVzKCkpKSxkcm9wcGVkRnJhbWVzOm51bGwhPUE/QTowLHRvdGFsRnJhbWVzOm51bGwhPUk/STowLGRhdGFJbnRlcnZhbDpCLmF2ZXJhZ2UodGhpcy5kYXRhSW50ZXJ2YWxzLnZhbHVlcygpKSxkYXRhU2l6ZTpCLmF2ZXJhZ2UodGhpcy5kYXRhU2l6ZXMudmFsdWVzKCkpLGN1cnJlbnRUaW1lOjAsZW5kT2ZCdWZmZXJlZDowLGVuZE9mU2Vla2FibGU6MH19fX0sOTAwOmZ1bmN0aW9uKEEsSSxnKXtcInVzZSBzdHJpY3RcIjt2YXIgZT10aGlzJiZ0aGlzLl9fYXdhaXRlcnx8ZnVuY3Rpb24oQSxJLGcsZSl7cmV0dXJuIG5ldyhnfHwoZz1Qcm9taXNlKSkoKGZ1bmN0aW9uKEIsaSl7ZnVuY3Rpb24gdChBKXt0cnl7QyhlLm5leHQoQSkpfWNhdGNoKEEpe2koQSl9fWZ1bmN0aW9uIFEoQSl7dHJ5e0MoZS50aHJvdyhBKSl9Y2F0Y2goQSl7aShBKX19ZnVuY3Rpb24gQyhBKXt2YXIgSTtBLmRvbmU/QihBLnZhbHVlKTooST1BLnZhbHVlLEkgaW5zdGFuY2VvZiBnP0k6bmV3IGcoKGZ1bmN0aW9uKEEpe0EoSSl9KSkpLnRoZW4odCxRKX1DKChlPWUuYXBwbHkoQSxJfHxbXSkpLm5leHQoKSl9KSl9O09iamVjdC5kZWZpbmVQcm9wZXJ0eShJLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLEkuVmlkZW9TdHJlYW1NU0U9dm9pZCAwO2NvbnN0IEI9ZygyNCksaT1nKDYzMyksdD1nKDQzNCksUT1nKDQ2NCksQz1nKDQ0MSk7ZnVuY3Rpb24gRShBKXtyZXR1cm4gMTAyPT09QVs0XSYmMTE2PT09QVs1XSYmMTIxPT09QVs2XSYmMTEyPT09QVs3XX1JLlZpZGVvU3RyZWFtTVNFPWNsYXNze2NvbnN0cnVjdG9yKEEpe3RoaXMuY29kZWNTdHJpbmc9QSx0aGlzLnJlYWR5U3RhdGU9dC5WaWRlb1JlYWR5U3RhdGUuRGV0YWNoZWQsdGhpcy5uZWVkc1Jlc3RhcnRFdmVudD1uZXcgQi5BY3Rpb24sdGhpcy5zb3VyY2VPcGVuRXZlbnQ9bmV3IEIuQWN0aW9uLHRoaXMucmVhZHlTdGF0ZUNoYW5nZUV2ZW50PW5ldyBCLkFjdGlvbix0aGlzLnZpZGVvRnJhbWVFdmVudD1uZXcgQi5BY3Rpb24sdGhpcy52aWRlb0ZyYW1lUHJvY2Vzc2luZ0R1cmF0aW9uRXZlbnQ9bmV3IEIuQWN0aW9uLHRoaXMuY2FuY2VsSW5pdGlhbGl6ZUV2ZW50PW5ldyBCLkFjdGlvbix0aGlzLmRhdGFRdWV1ZT1bXSx0aGlzLnN0YXRzPW5ldyBDLlZpZGVvU3RhdHMsdGhpcy5qdXN0Q2xlYXJlZEJ1ZmZlcj0hMSx0aGlzLmxhc3RCdWZmZXJFbmQ9MCx0aGlzLmZyYW1lc0Zyb3plbkZvcj0wLHRoaXMuZW5zdXJlQnVmZmVyPSgpPT57aWYodGhpcy5yZWFkeVN0YXRlIT09dC5WaWRlb1JlYWR5U3RhdGUuUGF1c2VkJiZ0aGlzLnJlYWR5U3RhdGUhPT10LlZpZGVvUmVhZHlTdGF0ZS5EZXRhY2hlZCYmdGhpcy5lbGVtZW50JiYwPT09dGhpcy5lbGVtZW50LmJ1ZmZlcmVkLmxlbmd0aCl7aWYodGhpcy5zb3VyY2VCdWZmZXImJiF0aGlzLnNvdXJjZUJ1ZmZlci51cGRhdGluZyYmdGhpcy5zb3VyY2VCdWZmZXIudGltZXN0YW1wT2Zmc2V0PD0wKXtjb25zdCBBPXRoaXMuc291cmNlQnVmZmVyLnRpbWVzdGFtcE9mZnNldC50b0ZpeGVkKDIpO3RoaXMuc291cmNlQnVmZmVyLnRpbWVzdGFtcE9mZnNldD0xO2NvbnN0IEk9dGhpcy5zb3VyY2VCdWZmZXIudGltZXN0YW1wT2Zmc2V0LnRvRml4ZWQoMik7dGhpcy53YXJuKGBQb2tlZCB0aW1lc3RhbXBPZmZzZXQgZnJvbSAke0F9IHRvICR7SX1gKX10aGlzLnJlc3RhcnQoXCJlbnN1cmVCdWZmZXJcIil9fSx0aGlzLnZpZGVvRnJhbWVIYW5kbGVyPShBLEkpPT57KG51bGw9PUk/dm9pZCAwOkkucHJvY2Vzc2luZ0R1cmF0aW9uKSYmdGhpcy52aWRlb0ZyYW1lUHJvY2Vzc2luZ0R1cmF0aW9uRXZlbnQuaW52b2tlKEkucHJvY2Vzc2luZ0R1cmF0aW9uKSxJJiZ0aGlzLnN0YXRzLnB1c2hGcmFtZU1ldGFkYXRhKEkpLHRoaXMudmlkZW9GcmFtZUV2ZW50Lmludm9rZShbQSxJXSksdGhpcy5yZXF1ZXN0TmV4dEZyYW1lQ2FsbGJhY2soKX0sdGhpcy5mYWxsYmFja1ZpZGVvRnJhbWVIYW5kbGVyPUE9Pnt0aGlzLnZpZGVvRnJhbWVIYW5kbGVyKEEsdm9pZCAwKX0sdGhpcy5zb3VyY2VCdWZmZXJVcGRhdGVIYW5kbGVyPSgpPT57dGhpcy5zdWJtaXREYXRhKCl9LHdpbmRvdy5fX3JhaW53YXlWaWRlbz10aGlzfWluZm8oQSl7US5SYWlud2F5TG9nZ2luZy5pbmZvcm1hdGlvbihgW1ZpZGVvU3RyZWFtXSAke1N0cmluZyhBKX1gKX1kZWJ1ZyhBKXtRLlJhaW53YXlMb2dnaW5nLmRlYnVnKGBbVmlkZW9TdHJlYW1dICR7U3RyaW5nKEEpfWApfXdhcm4oQSl7US5SYWlud2F5TG9nZ2luZy53YXJuaW5nKGBbVmlkZW9TdHJlYW1dICR7U3RyaW5nKEEpfWApfWdldCBkYXRhUXVldWVMZW5ndGgoKXtyZXR1cm4gdGhpcy5kYXRhUXVldWUubGVuZ3RofWF0dGFjaFRvRWxlbWVudChBKXt0aGlzLmluZm8oXCJBdHRhY2hpbmcgdG8gZWxlbWVudDogXCIrQSksdGhpcy5jYW5jZWxJbml0aWFsaXplRXZlbnQuaW52b2tlKCksdGhpcy5lbGVtZW50PUEsdGhpcy5zdGF0cy5zZXRFbGVtZW50KHRoaXMuZWxlbWVudCksdGhpcy5zdGF0cy5yZXNldEZyYW1lQ291bnRzKCksdGhpcy5yZXN0YXJ0KFwiYXR0YWNoVG9FbGVtZW50XCIpLHRoaXMuaW5mbyhcIkF0dGFjaGVkIHRvIGVsZW1lbnQuXCIpfWRldGFjaEZyb21FbGVtZW50KCl7dGhpcy5kZXN0cm95TWVkaWEoKSx0aGlzLmVsZW1lbnQ9dm9pZCAwLHRoaXMuc2V0UmVhZHlTdGF0ZSh0LlZpZGVvUmVhZHlTdGF0ZS5EZXRhY2hlZCksdGhpcy5pbmZvKFwiRGV0YWNoZWQgZnJvbSBlbGVtZW50LlwiKX1wYXVzZSgpe3RoaXMuc2V0UmVhZHlTdGF0ZSh0LlZpZGVvUmVhZHlTdGF0ZS5QYXVzZWQpfXBsYXkoKXt0aGlzLnJlYWR5U3RhdGU9PT10LlZpZGVvUmVhZHlTdGF0ZS5QYXVzZWQmJnRoaXMucmVzdGFydChcInBsYXlcIil9cHVzaERhdGEoQSxJKXtpZih0aGlzLmRhdGFRdWV1ZS5sZW5ndGg+OClyZXR1cm4gdm9pZCB0aGlzLnJlc3RhcnQoXCJwdXNoRGF0YS5kYXRhUXVldWUgdG9vIGxvbmdcIik7Y29uc3QgZz1uZXcgVWludDhBcnJheShJKTtyZXR1cm4gdGhpcy5zdGF0cy5wdXNoRGF0YShnKSx0aGlzLnJlYWR5U3RhdGUhPT10LlZpZGVvUmVhZHlTdGF0ZS5QYXVzZWQ/RShnKSYmdGhpcy5yZWFkeVN0YXRlPT09dC5WaWRlb1JlYWR5U3RhdGUuV2FpdGluZ0ZvcktleWZyYW1lJiZ0aGlzLmVsZW1lbnQ/KHRoaXMuZGVidWcoYEdvdCByZXF1ZXN0ZWQga2V5ZnJhbWUgKCR7Zy5sZW5ndGh9IGJ5dGVzKWApLHRoaXMuZ2V0U3RhdHMoKSx0aGlzLmRhdGFRdWV1ZS5wdXNoKGcpLHRoaXMuc3VibWl0RGF0YSgpLHZvaWQgdGhpcy5pbml0aWFsaXplTWVkaWEoKSk6dm9pZCh0aGlzLnJlYWR5U3RhdGUhPT10LlZpZGVvUmVhZHlTdGF0ZS5XYWl0aW5nRm9yS2V5ZnJhbWUmJnRoaXMuZWxlbWVudD8odGhpcy5kYXRhUXVldWUucHVzaChnKSx0aGlzLnN1Ym1pdERhdGEoKSk6dGhpcy5zdGFydEVuc3VyaW5nQnVmZmVyKCkpOnZvaWQgMH1nZXRTdGF0cygpe3JldHVybiB0aGlzLnN0YXRzLmdldFJlcG9ydCgpfXNldFJlYWR5U3RhdGUoQSl7dGhpcy5pbmZvKGBSZWFkeVN0YXRlIGNoYW5nZWQ6ICR7dC5WaWRlb1JlYWR5U3RhdGVbdGhpcy5yZWFkeVN0YXRlXX0gPT4gJHt0LlZpZGVvUmVhZHlTdGF0ZVtBXX1gKSx0aGlzLnJlYWR5U3RhdGU9QSx0aGlzLnJlYWR5U3RhdGVDaGFuZ2VFdmVudC5pbnZva2UoQSl9c3VibWl0RGF0YSgpe2lmKDAhPT10aGlzLmRhdGFRdWV1ZS5sZW5ndGgpaWYodm9pZCAwIT09dGhpcy5tZWRpYVNvdXJjZSlpZih0aGlzLnNvdXJjZUJ1ZmZlcil7aWYoIXRoaXMuc291cmNlQnVmZmVyLnVwZGF0aW5nKWlmKHRoaXMuZWxlbWVudCl7aWYodGhpcy5zb3VyY2VCdWZmZXIuYnVmZmVyZWQubGVuZ3RoPj0xKXtjb25zdCBBPXRoaXMuc291cmNlQnVmZmVyLmJ1ZmZlcmVkLmVuZCh0aGlzLnNvdXJjZUJ1ZmZlci5idWZmZXJlZC5sZW5ndGgtMSk7dGhpcy5qdXN0Q2xlYXJlZEJ1ZmZlciYmKHRoaXMuZWxlbWVudC5jdXJyZW50VGltZT1BLHRoaXMuanVzdENsZWFyZWRCdWZmZXI9ITEpLEE9PT10aGlzLmxhc3RCdWZmZXJFbmQ/KHRoaXMuZnJhbWVzRnJvemVuRm9yKyssdGhpcy5kZWJ1ZyhgRnJvemVuIGZvciAke3RoaXMuZnJhbWVzRnJvemVuRm9yfSBmcmFtZXMuLi5gKSk6dGhpcy5mcmFtZXNGcm96ZW5Gb3I9MCx0aGlzLmxhc3RCdWZmZXJFbmQ9QX1pZih0aGlzLmZyYW1lc0Zyb3plbkZvcj49NClyZXR1cm4gdGhpcy5yZXN0YXJ0KFwic291cmNlQnVmZmVyIEZyb3plbkZyYW1lc1wiKSx2b2lkKHRoaXMuZnJhbWVzRnJvemVuRm9yPTApO3RyeXtjb25zdCBBPXRoaXMuZGF0YVF1ZXVlWzBdO2lmKEUoQSkmJiF0aGlzLmp1c3RDbGVhcmVkQnVmZmVyKXJldHVybiB0aGlzLmRlYnVnKFwiR290IGtleWZyYW1lLiBDbGVhcmluZyBzb3VyY2VidWZmZXIuXCIpLHRoaXMuZ2V0U3RhdHMoKSx0aGlzLnNvdXJjZUJ1ZmZlci5yZW1vdmUoMCwxLzApLHZvaWQodGhpcy5qdXN0Q2xlYXJlZEJ1ZmZlcj0hMCk7dGhpcy5kYXRhUXVldWUuc2hpZnQoKSx0aGlzLnNvdXJjZUJ1ZmZlci5hcHBlbmRCdWZmZXIoQSksdGhpcy5zdGF0cy5yZXBvcnRGcmFtZVN1Ym1pdHRlZCgpfWNhdGNoKEEpe1EuUmFpbndheUxvZ2dpbmcuZXJyb3IoU3RyaW5nKEEpKSx0aGlzLnJlc3RhcnQoXCJzdWJtaXREYXRhLCBzb3VyY2VCdWZmZXIuYXBwZW5kQnVmZmVyIGVycm9yLlwiKX19ZWxzZSB0aGlzLmRlYnVnKFwiSWRsaW5nIGJlY2F1c2UgIWVsZW1lbnRcIil9ZWxzZSB0aGlzLmRlYnVnKFwiSWRsaW5nIGJlY2F1c2UgIXNvdXJjZUJ1ZmZlclwiKTtlbHNlIHRoaXMuZGVidWcoXCJJZGxpbmcgYmVjYXVzZSBtZWRpYVNvdXJjZSA9PT0gdW5kZWZpbmVkXCIpfWluaXRpYWxpemVNZWRpYSgpe3ZhciBBLEk7cmV0dXJuIGUodGhpcyx2b2lkIDAsdm9pZCAwLChmdW5jdGlvbiooKXtpZih0aGlzLnNldFJlYWR5U3RhdGUodC5WaWRlb1JlYWR5U3RhdGUuSW5pdGlhbGl6aW5nKSx0aGlzLmNhbmNlbEluaXRpYWxpemVFdmVudC5pbnZva2UoKSx2b2lkIDAhPT10aGlzLm1lZGlhU291cmNlKXJldHVybiB0aGlzLnNldFJlYWR5U3RhdGUodC5WaWRlb1JlYWR5U3RhdGUuUGxheWluZyksdm9pZChudWxsPT09KEE9dGhpcy5lbGVtZW50KXx8dm9pZCAwPT09QXx8QS5wbGF5KCkpO2lmKCF0aGlzLmVsZW1lbnQpdGhyb3cgbmV3IEVycm9yKFwiU3RyZWFtIG5vdCBhdHRhY2hlZCB0byBlbGVtZW50LlwiKTt0cnl7Y29uc3QgQT15aWVsZCBpLmNyZWF0ZU1lZGlhU291cmNlKHRoaXMuZWxlbWVudCx0aGlzLmNhbmNlbEluaXRpYWxpemVFdmVudCk7aWYoIUEpcmV0dXJuIHZvaWQgdGhpcy5zZXRSZWFkeVN0YXRlKHQuVmlkZW9SZWFkeVN0YXRlLldhaXRpbmdGb3JLZXlmcmFtZSk7dGhpcy5tZWRpYVNvdXJjZT1BLHRoaXMuc291cmNlQnVmZmVyPWkuY3JlYXRlU291cmNlQnVmZmVyKHRoaXMubWVkaWFTb3VyY2UsdGhpcy5jb2RlY1N0cmluZyksdGhpcy5zb3VyY2VCdWZmZXIuYWRkRXZlbnRMaXN0ZW5lcihcInVwZGF0ZWVuZFwiLHRoaXMuc291cmNlQnVmZmVyVXBkYXRlSGFuZGxlciksdGhpcy5zb3VyY2VCdWZmZXIuYWRkRXZlbnRMaXN0ZW5lcihcImVycm9yXCIsKEE9PmNvbnNvbGUuZXJyb3IoXCJzb3VyY2VCdWZmZXIgZXJyb3I6XCIsQSkpKSx0aGlzLnN0YXJ0RW5zdXJpbmdCdWZmZXIoKSx0aGlzLnNldFJlYWR5U3RhdGUodC5WaWRlb1JlYWR5U3RhdGUuUGxheWluZyksdGhpcy5yZXF1ZXN0TmV4dEZyYW1lQ2FsbGJhY2soKSx0aGlzLnN1Ym1pdERhdGEoKSxudWxsPT09KEk9dGhpcy5lbGVtZW50KXx8dm9pZCAwPT09SXx8SS5wbGF5KCl9Y2F0Y2goQSl7dGhpcy5zZXRSZWFkeVN0YXRlKHQuVmlkZW9SZWFkeVN0YXRlLldhaXRpbmdGb3JLZXlmcmFtZSl9fSkpfXN0YXJ0RW5zdXJpbmdCdWZmZXIoKXt2b2lkIDA9PT10aGlzLmVuc3VyZUJ1ZmZlckludGVydmFsJiYodGhpcy5kZWJ1ZyhcIlN0YXJ0aW5nIGVuc3VyZUJ1ZmZlciBsb29wXCIpLHRoaXMuZW5zdXJlQnVmZmVySW50ZXJ2YWw9d2luZG93LnNldEludGVydmFsKHRoaXMuZW5zdXJlQnVmZmVyLDFlMykpfWRlc3Ryb3lNZWRpYSgpe3ZhciBBLEk7aWYodGhpcy5kZWJ1ZyhcImRlc3Ryb3lNZWRpYSgpIGNhbGxlZFwiKSx2b2lkIDAhPT10aGlzLm1lZGlhU291cmNlKXtpZih0aGlzLmNhbmNlbEZyYW1lQ2FsbGJhY2soKSxudWxsPT09KEE9dGhpcy5lbGVtZW50KXx8dm9pZCAwPT09QXx8QS5wYXVzZSgpLG51bGw9PT0oST10aGlzLnNvdXJjZUJ1ZmZlcil8fHZvaWQgMD09PUl8fEkucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInVwZGF0ZWVuZFwiLHRoaXMuc291cmNlQnVmZmVyVXBkYXRlSGFuZGxlciksdGhpcy5tZWRpYVNvdXJjZSl7aWYodGhpcy5zb3VyY2VCdWZmZXIpe3RyeXt0aGlzLm1lZGlhU291cmNlLnJlbW92ZVNvdXJjZUJ1ZmZlcih0aGlzLnNvdXJjZUJ1ZmZlcil9Y2F0Y2goQSl7fXRoaXMuc291cmNlQnVmZmVyPXZvaWQgMH1pZihcIm9wZW5cIj09PXRoaXMubWVkaWFTb3VyY2UucmVhZHlTdGF0ZSl0cnl7dGhpcy5tZWRpYVNvdXJjZS5lbmRPZlN0cmVhbSgpfWNhdGNoKEEpe310aGlzLm1lZGlhU291cmNlPXZvaWQgMCx0aGlzLmVsZW1lbnQmJndpbmRvdy5VUkwucmV2b2tlT2JqZWN0VVJMKHRoaXMuZWxlbWVudC5zcmMpfXdpbmRvdy5jbGVhckludGVydmFsKHRoaXMuZW5zdXJlQnVmZmVySW50ZXJ2YWwpLHRoaXMuZW5zdXJlQnVmZmVySW50ZXJ2YWw9dm9pZCAwLHRoaXMuc2V0UmVhZHlTdGF0ZSh0LlZpZGVvUmVhZHlTdGF0ZS5XYWl0aW5nRm9yS2V5ZnJhbWUpfX1yZXN0YXJ0KEE9XCJcIil7Y29uc3QgST1BP2BSZXN0YXJ0aW5nIFZpZGVvIFN0cmVhbS4uLiBSZWFzb246ICcke0F9Jy5gOlwiUmVzdGFydGluZyBWaWRlbyBTdHJlYW0uXCI7dGhpcy53YXJuKEkpLHRoaXMuZGF0YVF1ZXVlPVtdLHRoaXMuc2V0UmVhZHlTdGF0ZSh0LlZpZGVvUmVhZHlTdGF0ZS5XYWl0aW5nRm9yS2V5ZnJhbWUpLHRoaXMubmVlZHNSZXN0YXJ0RXZlbnQuaW52b2tlKCl9cmVxdWVzdE5leHRGcmFtZUNhbGxiYWNrKCl7dmFyIEEsSSxnLGU7XCJyZXF1ZXN0VmlkZW9GcmFtZUNhbGxiYWNrXCJpbiBIVE1MVmlkZW9FbGVtZW50LnByb3RvdHlwZT8odGhpcy5mcmFtZUhhbmRsZSYmKG51bGw9PT0oST1udWxsPT09KEE9dGhpcy5lbGVtZW50KXx8dm9pZCAwPT09QT92b2lkIDA6QS5jYW5jZWxWaWRlb0ZyYW1lQ2FsbGJhY2spfHx2b2lkIDA9PT1JfHxJLmNhbGwoQSx0aGlzLmZyYW1lSGFuZGxlKSx0aGlzLmZyYW1lSGFuZGxlPXZvaWQgMCksdGhpcy5mcmFtZUhhbmRsZT1udWxsPT09KGU9bnVsbD09PShnPXRoaXMuZWxlbWVudCl8fHZvaWQgMD09PWc/dm9pZCAwOmcucmVxdWVzdFZpZGVvRnJhbWVDYWxsYmFjayl8fHZvaWQgMD09PWU/dm9pZCAwOmUuY2FsbChnLHRoaXMudmlkZW9GcmFtZUhhbmRsZXIpKToodGhpcy5mcmFtZUhhbmRsZSYmKHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLmZyYW1lSGFuZGxlKSx0aGlzLmZyYW1lSGFuZGxlPXZvaWQgMCksdGhpcy5mcmFtZUhhbmRsZT13aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRoaXMuZmFsbGJhY2tWaWRlb0ZyYW1lSGFuZGxlcikpfWNhbmNlbEZyYW1lQ2FsbGJhY2soKXt2YXIgQSxJO1wicmVxdWVzdFZpZGVvRnJhbWVDYWxsYmFja1wiaW4gSFRNTFZpZGVvRWxlbWVudC5wcm90b3R5cGU/dGhpcy5mcmFtZUhhbmRsZSYmKG51bGw9PT0oST1udWxsPT09KEE9dGhpcy5lbGVtZW50KXx8dm9pZCAwPT09QT92b2lkIDA6QS5jYW5jZWxWaWRlb0ZyYW1lQ2FsbGJhY2spfHx2b2lkIDA9PT1JfHxJLmNhbGwoQSx0aGlzLmZyYW1lSGFuZGxlKSx0aGlzLmZyYW1lSGFuZGxlPXZvaWQgMCk6dGhpcy5mcmFtZUhhbmRsZSYmKHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLmZyYW1lSGFuZGxlKSx0aGlzLmZyYW1lSGFuZGxlPXZvaWQgMCl9ZGlzcG9zZSgpe3RoaXMuY2FuY2VsRnJhbWVDYWxsYmFjaygpLHRoaXMuZGVzdHJveU1lZGlhKCksd2luZG93LmNsZWFySW50ZXJ2YWwodGhpcy5lbnN1cmVCdWZmZXJJbnRlcnZhbCksdGhpcy5zZXRSZWFkeVN0YXRlKHQuVmlkZW9SZWFkeVN0YXRlLkRpc3Bvc2VkKX19fSwxNDY6ZnVuY3Rpb24oQSxJLGcpe1widXNlIHN0cmljdFwiO3ZhciBlPXRoaXMmJnRoaXMuX19pbXBvcnREZWZhdWx0fHxmdW5jdGlvbihBKXtyZXR1cm4gQSYmQS5fX2VzTW9kdWxlP0E6e2RlZmF1bHQ6QX19O09iamVjdC5kZWZpbmVQcm9wZXJ0eShJLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLEkuVmlkZW9TdHJlYW1Tb2Z0d2FyZURlY29kZXI9dm9pZCAwO2NvbnN0IEI9Zyg0MzQpLGk9ZygyNCksdD1nKDQyNSksUT1lKGcoODU5KSksQz1lKGcoNzU2KSksRT1lKGcoMzQ2KSksbz1nKDQ2NCksYT1nKDQ0MSk7SS5WaWRlb1N0cmVhbVNvZnR3YXJlRGVjb2Rlcj1jbGFzc3tjb25zdHJ1Y3RvcihBLEkpe3RoaXMuY29kZWNTdHJpbmc9QSx0aGlzLmZvcm1hdD1JLHRoaXMucmVhZHlTdGF0ZT1CLlZpZGVvUmVhZHlTdGF0ZS5EZXRhY2hlZCx0aGlzLm5lZWRzUmVzdGFydEV2ZW50PW5ldyBpLkFjdGlvbix0aGlzLnJlYWR5U3RhdGVDaGFuZ2VFdmVudD1uZXcgaS5BY3Rpb24sdGhpcy52aWRlb0ZyYW1lUHJvY2Vzc2luZ0R1cmF0aW9uRXZlbnQ9bmV3IGkuQWN0aW9uLHRoaXMudmlkZW9GcmFtZUV2ZW50PW5ldyBpLkFjdGlvbix0aGlzLmN1cnJlbnRGcmFtZUluZm89e2NvbnRhaW5zU1BTOiExLGNvbnRhaW5zUFBTOiExLGNvbnRhaW5zRnJhbWVEYXRhOiEwfSx0aGlzLnBhdXNlZD0hMSx0aGlzLnN0YXRzPW5ldyBhLlZpZGVvU3RhdHMsdGhpcy50b3RhbEZyYW1lcz0wLHRoaXMud2FpdGluZ1RvRGVjb2RlUXVldWU9W10sdGhpcy5kZWNvZGVRdWV1ZT1bXSx0aGlzLm1heERlY29kZVF1ZXVlU2l6ZT0zLHRoaXMubWF4TGF0ZW5jeUZyYW1lQ291bnQ9Nyx0aGlzLm1heENvbnNlY3V0aXZlRnJhbWVzRHJvcHM9Myx0aGlzLmZyYW1lc0Ryb3BwZWRTaW5jZUxhc3RSZW5kZXI9MCx0aGlzLnRvdGFsRnJhbWVzRHJvcHBlZD0wLHRoaXMuY2FudmFzPXZvaWQgMCx0aGlzLnNoYWRlcj12b2lkIDAsdGhpcy55VGV4dHVyZT12b2lkIDAsdGhpcy51VGV4dHVyZT12b2lkIDAsdGhpcy52VGV4dHVyZT12b2lkIDAsdGhpcy5vbkRlY29kZT0oe3dpZHRoOkEsaGVpZ2h0OkksZGF0YTpnfSk9PntpZigwPT10aGlzLmRlY29kZVF1ZXVlLmxlbmd0aClyZXR1cm4gby5SYWlud2F5TG9nZ2luZy5lcnJvcihcIltWaWRlb1N0cmVhbVNvZnR3YXJlRGVjb2Rlcl0gb25EZWNvZGUgY2FsbGVkIHdpdGggZW1wdHkgZGVjb2RlciBxdWV1ZSFcIiksdm9pZCB0aGlzLnNlbmREZWNvZGVyV2FpdGluZ1RvRGVjb2RlRnJhbWVzKCk7Kyt0aGlzLnRvdGFsRnJhbWVzO2NvbnN0IGU9dGhpcy5kZWNvZGVRdWV1ZS5zaGlmdCgpO2lmKCF0aGlzLnBhdXNlZCl7Y29uc3QgQj1EYXRlLm5vdygpO2lmKGUucHJvY2Vzc2luZ0R1cmF0aW9uPShCLWUubWVkaWFUaW1lKS8xZTMsdGhpcy52aWRlb0ZyYW1lUHJvY2Vzc2luZ0R1cmF0aW9uRXZlbnQuaW52b2tlKGUucHJvY2Vzc2luZ0R1cmF0aW9uKSx0aGlzLmRhdGFRdWV1ZUxlbmd0aD50aGlzLm1heExhdGVuY3lGcmFtZUNvdW50JiZ0aGlzLmZyYW1lc0Ryb3BwZWRTaW5jZUxhc3RSZW5kZXI8dGhpcy5tYXhDb25zZWN1dGl2ZUZyYW1lc0Ryb3BzKSsrdGhpcy5mcmFtZXNEcm9wcGVkU2luY2VMYXN0UmVuZGVyLCsrdGhpcy50b3RhbEZyYW1lc0Ryb3BwZWQ7ZWxzZXt0aGlzLmZyYW1lc0Ryb3BwZWRTaW5jZUxhc3RSZW5kZXI9MDtjb25zdCBCPWUud2lkdGgsaT1lLmhlaWdodDtlLndpZHRoPUEsZS5oZWlnaHQ9SSx0aGlzLnN0YXRzLnB1c2hGcmFtZU1ldGFkYXRhKGUpLHRoaXMucmVuZGVyRnJhbWUoQixpLGcsQSxJKSx0aGlzLnZpZGVvRnJhbWVFdmVudC5pbnZva2UoW3BlcmZvcm1hbmNlLm5vdygpLGVdKX19dGhpcy5zZW5kRGVjb2RlcldhaXRpbmdUb0RlY29kZUZyYW1lcygpfSx0aGlzLmVuc3VyZUJ1ZmZlcj0oKT0+e3RoaXMucmVhZHlTdGF0ZT09PUIuVmlkZW9SZWFkeVN0YXRlLldhaXRpbmdGb3JLZXlmcmFtZSYmMD09PXRoaXMuZGF0YVF1ZXVlTGVuZ3RoJiYoby5SYWlud2F5TG9nZ2luZy5kZWJ1ZyhcIlNlbmRpbmcgYW5vdGhlciByZXF1ZXN0IGZvciBhIGtleWZyYW1lLlwiKSx0aGlzLnJlc3RhcnQoKSl9LHRoaXMudmlkZW9Gb3JtYXQ9SSx0aGlzLmRlY29kZXJXb3JrZXI9bmV3IFEuZGVmYXVsdCx0aGlzLmRlY29kZXJXb3JrZXIuaW5pdGlhbGl6ZSgpLHRoaXMuZGVjb2Rlcldvcmtlci5vbkRlY29kZT10aGlzLm9uRGVjb2RlLmJpbmQodGhpcyksdGhpcy5lbnN1cmVCdWZmZXJJbnRlcnZhbD13aW5kb3cuc2V0SW50ZXJ2YWwodGhpcy5lbnN1cmVCdWZmZXIsMWUzKX1nZXQgZGF0YVF1ZXVlTGVuZ3RoKCl7cmV0dXJuIHRoaXMud2FpdGluZ1RvRGVjb2RlUXVldWUubGVuZ3RoK3RoaXMuZGVjb2RlUXVldWUubGVuZ3RofWNvbmZpZ3VyZShBLEksZyl7dGhpcy5tYXhEZWNvZGVRdWV1ZVNpemU9QSx0aGlzLm1heExhdGVuY3lGcmFtZUNvdW50PUksdGhpcy5tYXhDb25zZWN1dGl2ZUZyYW1lc0Ryb3BzPWd9YXR0YWNoVG9FbGVtZW50KEEpe3RoaXMuc3RhdHMucmVzZXRGcmFtZUNvdW50cygpLHRoaXMucmVhZHlTdGF0ZSE9Qi5WaWRlb1JlYWR5U3RhdGUuV2FpdGluZ0ZvcktleWZyYW1lJiZ0aGlzLnJlc3RhcnQoKX1hdHRhY2hUb0NhbnZhcyhBKXt0aGlzLnJlYWR5U3RhdGUhPUIuVmlkZW9SZWFkeVN0YXRlLldhaXRpbmdGb3JLZXlmcmFtZSYmdGhpcy5yZXN0YXJ0KCksdGhpcy5jYW52YXMmJnRoaXMuZGV0YWNoRnJvbUNhbnZhcygpLHRoaXMuY2FudmFzPUE7Y29uc3QgST1BLmdldENvbnRleHQoXCJ3ZWJnbFwiKTt0aGlzLnNoYWRlcj1DLmRlZmF1bHQuY3JlYXRlKEkpLHRoaXMueVRleHR1cmU9RS5kZWZhdWx0LmNyZWF0ZShJKSx0aGlzLnVUZXh0dXJlPUUuZGVmYXVsdC5jcmVhdGUoSSksdGhpcy52VGV4dHVyZT1FLmRlZmF1bHQuY3JlYXRlKEkpfWRldGFjaEZyb21FbGVtZW50KCl7dGhpcy5zZXRSZWFkeVN0YXRlKEIuVmlkZW9SZWFkeVN0YXRlLkRldGFjaGVkKX1kZXRhY2hGcm9tQ2FudmFzKCl7dGhpcy5kZWNvZGVyV29ya2VyLnJlbGVhc2UoKSx0aGlzLnlUZXh0dXJlJiZ0aGlzLnlUZXh0dXJlLmRlbGV0ZSgpLHRoaXMudVRleHR1cmUmJnRoaXMudVRleHR1cmUuZGVsZXRlKCksdGhpcy52VGV4dHVyZSYmdGhpcy52VGV4dHVyZS5kZWxldGUoKSx0aGlzLmNhbnZhcz12b2lkIDB9cGF1c2UoKXt0aGlzLnBhdXNlZD0hMCx0aGlzLnNldFJlYWR5U3RhdGUoQi5WaWRlb1JlYWR5U3RhdGUuUGF1c2VkKX1wbGF5KCl7dGhpcy5wYXVzZWQmJih0aGlzLnBhdXNlZD0hMSx0aGlzLnJlc3RhcnQoKSl9cmVzdGFydCgpe3RoaXMudG90YWxGcmFtZXM9MCx0aGlzLnRvdGFsRnJhbWVzRHJvcHBlZD0wLHRoaXMuZnJhbWVzRHJvcHBlZFNpbmNlTGFzdFJlbmRlcj0wLHRoaXMud2FpdGluZ1RvRGVjb2RlUXVldWU9W10sdGhpcy5zZXRSZWFkeVN0YXRlKEIuVmlkZW9SZWFkeVN0YXRlLldhaXRpbmdGb3JLZXlmcmFtZSksdGhpcy5uZWVkc1Jlc3RhcnRFdmVudC5pbnZva2UoKX1wdXNoRGF0YShBLEkpe3ZhciBnLGUsaTtpZih0aGlzLnN0YXRzLnB1c2hEYXRhKEkpLHRoaXMucGF1c2VkKXJldHVybjtjb25zdCBRPW5ldyBVaW50OEFycmF5KEkpO2xldCBDPSExO2lmKHRoaXMudmlkZW9Gb3JtYXQ9PXQuUmFpbndheVZpZGVvRm9ybWF0Lkxlbmd0aFByZWZpeGVkP0M9dGhpcy5jb252ZXJ0VG9Bbm5leGJGb3JtYXQoUSk6dGhpcy5yZWFkeVN0YXRlPT1CLlZpZGVvUmVhZHlTdGF0ZS5XYWl0aW5nRm9yS2V5ZnJhbWUmJihDPXRoaXMucGFyc2VBbm5leGJGcmFtZUluZm8oUSkpLHRoaXMucmVhZHlTdGF0ZT09Qi5WaWRlb1JlYWR5U3RhdGUuV2FpdGluZ0ZvcktleWZyYW1lKWlmKEMpdGhpcy5zZXRSZWFkeVN0YXRlKEIuVmlkZW9SZWFkeVN0YXRlLlBsYXlpbmcpO2Vsc2UgaWYoIShudWxsPT09KGc9dGhpcy5jdXJyZW50RnJhbWVJbmZvKXx8dm9pZCAwPT09Zz92b2lkIDA6Zy5jb250YWluc0ZyYW1lRGF0YSkpcmV0dXJuKChudWxsPT09KGU9dGhpcy5jdXJyZW50RnJhbWVJbmZvKXx8dm9pZCAwPT09ZT92b2lkIDA6ZS5jb250YWluc1NQUyl8fChudWxsPT09KGk9dGhpcy5jdXJyZW50RnJhbWVJbmZvKXx8dm9pZCAwPT09aT92b2lkIDA6aS5jb250YWluc1BQUykpJiZ0aGlzLmRlY29kZXJXb3JrZXIuZGVjb2RlKFEpLHRoaXMuY3VycmVudEZyYW1lSW5mby5jb250YWluc1NQUz0hMSx0aGlzLmN1cnJlbnRGcmFtZUluZm8uY29udGFpbnNQUFM9ITEsdm9pZCh0aGlzLmN1cnJlbnRGcmFtZUluZm8uY29udGFpbnNGcmFtZURhdGE9ITApO2lmKHRoaXMucmVhZHlTdGF0ZSE9Qi5WaWRlb1JlYWR5U3RhdGUuV2FpdGluZ0ZvcktleWZyYW1lJiZ0aGlzLmN1cnJlbnRGcmFtZUluZm8uY29udGFpbnNGcmFtZURhdGEpe2NvbnN0IEk9e3dpZHRoOkEud2lkdGgsaGVpZ2h0OkEuaGVpZ2h0LG1lZGlhVGltZTpEYXRlLm5vdygpLHByb2Nlc3NpbmdEdXJhdGlvbjowLGV4cGVjdGVkRGlzcGxheVRpbWU6MCxwcmVzZW50YXRpb25UaW1lOjAscHJlc2VudGVkRnJhbWVzOjB9O3RoaXMuZGVjb2RlKEksUSl9fWNvbnZlcnRUb0FubmV4YkZvcm1hdChBKXtsZXQgST0hMTt0aGlzLmN1cnJlbnRGcmFtZUluZm8uY29udGFpbnNGcmFtZURhdGE9ITE7Zm9yKGxldCBnPTA7ZzxBLmxlbmd0aDspe2NvbnN0IGU9dGhpcy5udG9obChBLGcpO0FbZ109MCxBWysrZ109MCxBWysrZ109MCxBWysrZ109MSwrK2c7Y29uc3QgQj0zMSZBW2ddO0I8PTUmJkI+PTE/KEk9NT09Qix0aGlzLmN1cnJlbnRGcmFtZUluZm8uY29udGFpbnNGcmFtZURhdGE9ITApOjc9PUI/dGhpcy5jdXJyZW50RnJhbWVJbmZvLmNvbnRhaW5zU1BTPSEwOjg9PUImJih0aGlzLmN1cnJlbnRGcmFtZUluZm8uY29udGFpbnNQUFM9ITApLGcrPWV9cmV0dXJuIEl9bnRvaGwoQSxJKXtyZXR1cm4oMjU1JkFbSV0pPDwyNHwoMjU1JkFbSSsxXSk8PDE2fCgyNTUmQVtJKzJdKTw8OHwyNTUmQVtJKzNdfXBhcnNlQW5uZXhiRnJhbWVJbmZvKEEpe2xldCBJPSExO3RoaXMuY3VycmVudEZyYW1lSW5mby5jb250YWluc0ZyYW1lRGF0YT0hMTtmb3IobGV0IGc9MDtnPEEubGVuZ3RoOylpZigwPT1BW2ddJiYwPT1BW2crMV0pe2xldCBlPTA7aWYoMT09QVtnKzJdPyhnKz0zLGU9MzEmQVtnXSk6MD09QVtnKzJdJiYxPT1BW2crM10/KGcrPTQsZT0zMSZBW2ddKTorK2csZTw9NSYmZT49MSl7aWYodGhpcy5jdXJyZW50RnJhbWVJbmZvLmNvbnRhaW5zRnJhbWVEYXRhPSEwLDU9PWUpe0k9ITA7YnJlYWt9fWVsc2UgNz09ZT90aGlzLmN1cnJlbnRGcmFtZUluZm8uY29udGFpbnNTUFM9ITA6OD09ZSYmKHRoaXMuY3VycmVudEZyYW1lSW5mby5jb250YWluc1BQUz0hMCl9ZWxzZSsrZztyZXR1cm4gSX1kZWNvZGUoQSxJKXswPT10aGlzLmRlY29kZVF1ZXVlLmxlbmd0aD8oMCE9dGhpcy53YWl0aW5nVG9EZWNvZGVRdWV1ZS5sZW5ndGgmJihvLlJhaW53YXlMb2dnaW5nLmVycm9yKFwiW1ZpZGVvU3RyZWFtU29mdHdhcmVEZWNvZGVyXSBlbXB0eSBkZWNvZGVyIHF1ZXVlLCBidXQgd2FpdGluZyB0byBkZWNvZGUgcXVldWUgbm90IGVtcHR5IVwiKSx0aGlzLndhaXRpbmdUb0RlY29kZVF1ZXVlPVtdKSx0aGlzLnNlbmRUb0RlY29kZXIoQSxJKSk6KHRoaXMud2FpdGluZ1RvRGVjb2RlUXVldWUucHVzaCh7bWV0YWRhdGE6QSxkYXRhOkl9KSx0aGlzLmRlY29kZVF1ZXVlLmxlbmd0aDx0aGlzLm1heERlY29kZVF1ZXVlU2l6ZSYmdGhpcy5zZW5kRGVjb2RlcldhaXRpbmdUb0RlY29kZUZyYW1lcygpKX1zZW5kRGVjb2RlcldhaXRpbmdUb0RlY29kZUZyYW1lcygpe2Zvcig7dGhpcy5kZWNvZGVRdWV1ZS5sZW5ndGg8dGhpcy5tYXhEZWNvZGVRdWV1ZVNpemUmJnRoaXMud2FpdGluZ1RvRGVjb2RlUXVldWUubGVuZ3RoPjA7KXtjb25zdCBBPXRoaXMud2FpdGluZ1RvRGVjb2RlUXVldWUuc2hpZnQoKTt0aGlzLnNlbmRUb0RlY29kZXIoQS5tZXRhZGF0YSxBLmRhdGEpfX1zZW5kVG9EZWNvZGVyKEEsSSl7dGhpcy5zdGF0cy5yZXBvcnRGcmFtZVN1Ym1pdHRlZCgpLHRoaXMuZGVjb2RlUXVldWUucHVzaChBKSx0aGlzLmRlY29kZXJXb3JrZXIuZGVjb2RlKEkpfXJlbmRlckZyYW1lKEEsSSxnLGUsQil7dGhpcy5jYW52YXMud2lkdGg9QSx0aGlzLmNhbnZhcy5oZWlnaHQ9STtjb25zdCBpPW5ldyBVaW50OEFycmF5KGcpLHQ9ZSpCLFE9aS5zdWJhcnJheSgwLHQpLEM9dD4+MixFPWkuc3ViYXJyYXkodCx0K0MpLG89aS5zdWJhcnJheSh0K0MsdCsyKkMpO3RoaXMueVRleHR1cmUudXBsb2FkQnVmZmVyKFEsZSxCKTtjb25zdCBhPWU+PjEsbj1CPj4xO3RoaXMudVRleHR1cmUudXBsb2FkQnVmZmVyKEUsYSxuKSx0aGlzLnZUZXh0dXJlLnVwbG9hZEJ1ZmZlcihvLGEsbiksdGhpcy5zaGFkZXIuYmluZElucHV0VGV4dHVyZXModGhpcy55VGV4dHVyZSx0aGlzLnVUZXh0dXJlLHRoaXMudlRleHR1cmUpO2NvbnN0IHM9QS9lLHI9SS9CO3RoaXMuc2hhZGVyLnVwZGF0ZShlLEIscyxyKSx0aGlzLnNoYWRlci5kcmF3KCl9Z2V0U3RhdHMoKXtyZXR1cm4gdGhpcy5zdGF0cy5jcmVhdGVSZXBvcnQodGhpcy50b3RhbEZyYW1lc0Ryb3BwZWQsdGhpcy50b3RhbEZyYW1lcyl9c2V0UmVhZHlTdGF0ZShBKXt0aGlzLnJlYWR5U3RhdGU9QSx0aGlzLnJlYWR5U3RhdGVDaGFuZ2VFdmVudC5pbnZva2UoQSl9ZGlzcG9zZSgpe28uUmFpbndheUxvZ2dpbmcuZGVidWcoXCJEaXNwb3NpbmcgVmlkZW9TdHJlYW1Tb2Z0d2FyZURlY29kZXJcIiksdGhpcy5yZWFkeVN0YXRlPUIuVmlkZW9SZWFkeVN0YXRlLkRpc3Bvc2VkLHRoaXMuZGVjb2Rlcldvcmtlci5yZWxlYXNlKCksdGhpcy5kZWNvZGVyV29ya2VyLmRpc3Bvc2UoKSx3aW5kb3cuY2xlYXJJbnRlcnZhbCh0aGlzLmVuc3VyZUJ1ZmZlckludGVydmFsKX19fSwxMDQ6ZnVuY3Rpb24oQSxJLGcpe1widXNlIHN0cmljdFwiO3ZhciBlLEI9dGhpcyYmdGhpcy5fX2F3YWl0ZXJ8fGZ1bmN0aW9uKEEsSSxnLGUpe3JldHVybiBuZXcoZ3x8KGc9UHJvbWlzZSkpKChmdW5jdGlvbihCLGkpe2Z1bmN0aW9uIHQoQSl7dHJ5e0MoZS5uZXh0KEEpKX1jYXRjaChBKXtpKEEpfX1mdW5jdGlvbiBRKEEpe3RyeXtDKGUudGhyb3coQSkpfWNhdGNoKEEpe2koQSl9fWZ1bmN0aW9uIEMoQSl7dmFyIEk7QS5kb25lP0IoQS52YWx1ZSk6KEk9QS52YWx1ZSxJIGluc3RhbmNlb2YgZz9JOm5ldyBnKChmdW5jdGlvbihBKXtBKEkpfSkpKS50aGVuKHQsUSl9QygoZT1lLmFwcGx5KEEsSXx8W10pKS5uZXh0KCkpfSkpfSxpPXRoaXMmJnRoaXMuX19jbGFzc1ByaXZhdGVGaWVsZEdldHx8ZnVuY3Rpb24oQSxJKXtpZighSS5oYXMoQSkpdGhyb3cgbmV3IFR5cGVFcnJvcihcImF0dGVtcHRlZCB0byBnZXQgcHJpdmF0ZSBmaWVsZCBvbiBub24taW5zdGFuY2VcIik7cmV0dXJuIEkuZ2V0KEEpfSx0PXRoaXMmJnRoaXMuX19jbGFzc1ByaXZhdGVGaWVsZFNldHx8ZnVuY3Rpb24oQSxJLGcpe2lmKCFJLmhhcyhBKSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiYXR0ZW1wdGVkIHRvIHNldCBwcml2YXRlIGZpZWxkIG9uIG5vbi1pbnN0YW5jZVwiKTtyZXR1cm4gSS5zZXQoQSxnKSxnfTtPYmplY3QuZGVmaW5lUHJvcGVydHkoSSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxJLkdhdGV3YXk9SS5nZXRIYW5kc2hha2VEYXRhQmFzZTY0PUkuZ2V0UGVlcklkPUkuR2F0ZXdheVN0YXR1cz12b2lkIDA7Y29uc3QgUT1nKDI5MCksQz1nKDk5NCksRT1nKDQ2NCksbz1nKDkwNCksYT1nKDI0KTt2YXIgbjtmdW5jdGlvbiBzKEEsSSxnKXtjb25zdCBlPW8uR2F0ZXdheUlkZW50aXR5LmVuY29kZSh7aWQ6QSxhcGlLZXk6SSxleHRlcm5hbElkOmd9KTtyZXR1cm4gYnRvYShTdHJpbmcuZnJvbUNoYXJDb2RlKC4uLmUpKS5yZXBsYWNlKC89KiQvLFwiXCIpLnJlcGxhY2UoL1xcKy9nLFwiLVwiKS5yZXBsYWNlKC9cXC8vZyxcIl9cIil9IWZ1bmN0aW9uKEEpe0FbQS5PcGVuPTBdPVwiT3BlblwiLEFbQS5DbG9zZWQ9MV09XCJDbG9zZWRcIn0obj1JLkdhdGV3YXlTdGF0dXN8fChJLkdhdGV3YXlTdGF0dXM9e30pKSxJLmdldFBlZXJJZD1mdW5jdGlvbihBKXt2YXIgSTtyZXR1cm4gQih0aGlzLHZvaWQgMCx2b2lkIDAsKGZ1bmN0aW9uKigpe2NvbnN0IGc9eWllbGQgUS5nZXRPcmdhbml6YXRpb25JbmZvKEEpLGU9YHJhaW53YXktaG9zdG5hbWUtJHtnLm9yZ2FuaXphdGlvbklkLnRvU3RyaW5nKDE2KS5wYWRTdGFydCg4LFwiMFwiKX0tJHtnLnVuaXZlcnNlRmxhZ31gLEI9QmlnSW50KG51bGwhPT0oST1sb2NhbFN0b3JhZ2UuZ2V0SXRlbShlKSkmJnZvaWQgMCE9PUk/STp5aWVsZCBRLmZldGNoTmV3UGVlcklkKCkpO3JldHVybiBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShlLEIudG9TdHJpbmcoKSksQn0pKX0sSS5nZXRIYW5kc2hha2VEYXRhQmFzZTY0PXMsSS5HYXRld2F5PWNsYXNze2NvbnN0cnVjdG9yKEEsSSxnLGksdCxRLEM9XCJ3c3M6Ly9nYXRld2F5LnJhaW53YXkubmV0d29ya1wiKXt0aGlzLm93blBlZXJJZD1BLHRoaXMuYXBpS2V5PUksdGhpcy5leHRlcm5hbElkPWcsdGhpcy5oYW5kbGVQZWVySW5mbz1pLHRoaXMuY29ubmVjdGlvblJlcXVlc3RIYW5kbGVyPXQsdGhpcy5hZGRBY2NlcHRlZFBlZXI9USx0aGlzLmNvbm5lY3Rpb25zPW5ldyBNYXAsdGhpcy5jb25uZWN0aW9uTG9zdEV2ZW50PW5ldyBhLkFjdGlvbixlLnNldCh0aGlzLG4uQ2xvc2VkKSx0aGlzLnN5bmNLZXk9MCx0aGlzLnBlZXJJZFRvRXh0ZXJuYWxJZD1uZXcgTWFwLHRoaXMub25NZXNzYWdlPUE9PkIodGhpcyx2b2lkIDAsdm9pZCAwLChmdW5jdGlvbiooKXt2YXIgSTtpZih2b2lkIDAhPT10aGlzLnNvY2tldCYmXCJbb2JqZWN0IEFycmF5QnVmZmVyXVwiPT09QS5kYXRhLnRvU3RyaW5nKCkpe2NvbnN0IGc9by5HYXRld2F5RGF0YWdyYW0uZGVjb2RlKG5ldyBVaW50OEFycmF5KEEuZGF0YSkpLHtoZWFkZXI6e3N5bmNLZXk6ZX0sYm9keTpCfT1nO3N3aXRjaChCLmRpc2NyaW1pbmF0b3Ipe2Nhc2Ugby5HYXRld2F5UmVxdWVzdC5kaXNjcmltaW5hdG9yOkUuUmFpbndheUxvZ2dpbmcud2FybmluZyhcImdvdCBHYXRld2F5UmVxdWVzdD8hIGkgYW0gbm90IGEgZ2F0ZXdheS4gaWdub3JpbmdcIik7YnJlYWs7Y2FzZSBvLkdhdGV3YXlSZXNwb25zZS5kaXNjcmltaW5hdG9yOntjb25zdCBBPUIudmFsdWUuYm9keS52YWx1ZTtFLlJhaW53YXlMb2dnaW5nLnRyYWNlKFwiZ290IEdhdGV3YXlIZWxsb1wiKSxudWxsPT09KEk9dGhpcy5yZXNvbHZlQ29ubmVjdFRvR2F0ZXdheVByb21pc2UpfHx2b2lkIDA9PT1JfHxJLmNhbGwodGhpcyxBKTticmVha31jYXNlIG8uR2F0ZXdheUFsZXJ0LmRpc2NyaW1pbmF0b3I6e2NvbnN0e2xldmVsOkEsZGVzY3JpcHRpb246SX09Qi52YWx1ZTtBPT09by5HYXRld2F5QWxlcnRMZXZlbC5GYXRhbD8oRS5SYWlud2F5TG9nZ2luZy5lcnJvcihcIkZhdGFsIEdhdGV3YXlBbGVydDogXCIrby5HYXRld2F5QWxlcnREZXNjcmlwdGlvbltJXSksdGhpcy5kaWUoSSxcIlRoZSBjb25uZWN0aW9uIHRvIHRoZSBSYWlud2F5IHNlcnZlciBlbmNvdW50ZXJlZCBhIGZhdGFsIGVycm9yLlwiKSk6dGhpcy5vbk5vbkZhdGFsQWxlcnQoZSxJKTticmVha31jYXNlIG8uR2F0ZXdheUZvcndhcmRhYmxlLmRpc2NyaW1pbmF0b3I6dGhpcy5vbkZvcndhcmRhYmxlKGUsQi52YWx1ZSl9fX0pKSx0aGlzLm9uQ2xvc2U9QT0+e3RoaXMuZGllKEEsXCJUaGUgY29ubmVjdGlvbiB0byB0aGUgUmFpbndheSBzZXJ2ZXIgd2FzIGNsb3NlZC5cIil9LHRoaXMub25FcnJvcj1BPT57dGhpcy5kaWUoQSxcIlRoZSBjb25uZWN0aW9uIHRvIHRoZSBSYWlud2F5IHNlcnZlciB3YXMgbG9zdC5cIil9LHdpbmRvdy5fX3JhaW53YXlHYXRld2F5PXRoaXMsdGhpcy51cmw9Q31nZXQgc3RhdHVzKCl7cmV0dXJuIGkodGhpcyxlKX1jb25uZWN0KCl7dmFyIEE7cmV0dXJuIEIodGhpcyx2b2lkIDAsdm9pZCAwLChmdW5jdGlvbiooKXtyZXR1cm4gbnVsbCE9PShBPXRoaXMuY29ubmVjdFRvR2F0ZXdheVByb21pc2UpJiZ2b2lkIDAhPT1BP0E6dGhpcy5jb25uZWN0VG9HYXRld2F5UHJvbWlzZT1uZXcgUHJvbWlzZSgoKEEsSSk9Pnt0aGlzLnJlc29sdmVDb25uZWN0VG9HYXRld2F5UHJvbWlzZT1BLHRoaXMucmVqZWN0Q29ubmVjdFRvR2F0ZXdheVByb21pc2U9SSx0aGlzLm9wZW4oKX0pKX0pKX1vcGVuKCl7cmV0dXJuIEIodGhpcyx2b2lkIDAsdm9pZCAwLChmdW5jdGlvbiooKXt0aGlzLnNvY2tldD15aWVsZCB0aGlzLm1ha2VXZWJTb2NrZXQodGhpcy51cmwpLEUuUmFpbndheUxvZ2dpbmcuZGVidWcoXCJHYXRld2F5OiBjb25uZWN0ZWQgV2ViU29ja2V0XCIpLHRoaXMuc29ja2V0LmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsdGhpcy5vbk1lc3NhZ2UpLHRoaXMuc29ja2V0LmFkZEV2ZW50TGlzdGVuZXIoXCJjbG9zZVwiLHRoaXMub25DbG9zZSksdCh0aGlzLGUsbi5PcGVuKX0pKX1tYWtlV2ViU29ja2V0KEEpe3JldHVybiBuZXcgUHJvbWlzZSgoKEksZyk9Pntjb25zdCBlPW5ldyBXZWJTb2NrZXQoQSxbXCJoYW5kc2hha2VcIixzKHRoaXMub3duUGVlcklkLHRoaXMuYXBpS2V5LHRoaXMuZXh0ZXJuYWxJZCldKTtlLmJpbmFyeVR5cGU9XCJhcnJheWJ1ZmZlclwiLGUub25vcGVuPSgpPT57SShlKX0sZS5vbmVycm9yPUE9Pnt0aGlzLm9uRXJyb3IoQSksZyhBKSx0aGlzLmNvbm5lY3RUb0dhdGV3YXlQcm9taXNlPXZvaWQgMH19KSl9ZGlzY29ubmVjdCgpe3ZhciBBO2lmKEUuUmFpbndheUxvZ2dpbmcuZGVidWcoXCJHYXRld2F5OiBjbG9zZSgpXCIpLHZvaWQgMCE9PXRoaXMuc29ja2V0KXt0aGlzLnNvY2tldC5jbG9zZSgzZTMsXCJTaWduYWxpbmcgd2Vic29ja2V0IGNsb3NlZC5cIik7Y29uc3QgQT10aGlzLnNvY2tldDt3aW5kb3cuc2V0VGltZW91dCgoKCk9PntBLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjbG9zZVwiLHRoaXMub25DbG9zZSksQS5yZW1vdmVFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLHRoaXMub25NZXNzYWdlKX0pLDApfW51bGw9PT0oQT10aGlzLnJlamVjdENvbm5lY3RUb0dhdGV3YXlQcm9taXNlKXx8dm9pZCAwPT09QXx8QS5jYWxsKHRoaXMsdm9pZCAwKSx0KHRoaXMsZSxuLkNsb3NlZCksdGhpcy5jb25uZWN0VG9HYXRld2F5UHJvbWlzZT12b2lkIDAsdGhpcy5yZXNvbHZlQ29ubmVjdFRvR2F0ZXdheVByb21pc2U9dm9pZCAwLHRoaXMucmVqZWN0Q29ubmVjdFRvR2F0ZXdheVByb21pc2U9dm9pZCAwLHRoaXMuc29ja2V0PXZvaWQgMCx0aGlzLmNvbm5lY3Rpb25zLmNsZWFyKCl9bWFrZURhdGFncmFtKEEpe3JldHVybntoZWFkZXI6e3N5bmNLZXk6Kyt0aGlzLnN5bmNLZXl9LGJvZHk6QX19bWFrZUZvcndhcmRhYmxlKEEsSSl7cmV0dXJuIHRoaXMubWFrZURhdGFncmFtKHtkaXNjcmltaW5hdG9yOm8uR2F0ZXdheUZvcndhcmRhYmxlLmRpc2NyaW1pbmF0b3IsdmFsdWU6e3RhcmdldFBlZXJJZDpBLGJvZHk6SX19KX1jb25uZWN0VG9Ib3N0KEEsSSl7Y29uc3QgZz10aGlzLmNvbm5lY3Rpb25zLmdldChBKTtpZih2b2lkIDAhPT1nKXtpZihnLm93bmVkKXRocm93IG5ldyBDLlJhaW53YXlFcnJvcihcImFscmVhZHkgY29ubmVjdGVkIGluIG90aGVyIGRpcmVjdGlvblwiKTtyZXR1cm4gZy5wcm9taXNlfWlmKHZvaWQgMD09PXRoaXMuc29ja2V0KXRocm93IG5ldyBDLlJhaW53YXlFcnJvcihcInNvY2tldCB1bmRlZmluZWQgaW4gc2VuZEluaXRDb25uZWN0aW9uUmVxdWVzdFwiKTtpZih0aGlzLnN0YXR1cyE9PW4uT3Blbil0aHJvdyBuZXcgQy5SYWlud2F5RXJyb3IoXCJzaWduYWxpbmcgY2hhbm5lbCBub3Qgb3BlbiBpbiBzZW5kSW5pdENvbm5lY3Rpb25SZXF1ZXN0XCIpO2NvbnN0IGU9dGhpcy5zb2NrZXQsQj17cGVuZGluZzohMH07cmV0dXJuIEIucHJvbWlzZT1uZXcgUHJvbWlzZSgoKGcsaSk9PntCLnJlc29sdmU9ZyxCLnJlamVjdD1pLEUuUmFpbndheUxvZ2dpbmcudHJhY2UoYEdhdGV3YXk6IEFkZGluZyAke0F9IHRvIHBlbmRpbmdDb25uZWN0aW9uc2ApO2NvbnN0IHQ9dGhpcy5tYWtlRGF0YWdyYW0oe2Rpc2NyaW1pbmF0b3I6by5HYXRld2F5UmVxdWVzdC5kaXNjcmltaW5hdG9yLHZhbHVlOntib2R5OntkaXNjcmltaW5hdG9yOm8uSW5pdENvbm5lY3Rpb25SZXF1ZXN0LmRpc2NyaW1pbmF0b3IsdmFsdWU6e2Rlc2lyZWRUcmFuc3BvcnQ6SSx0YXJnZXRQZWVySWQ6QX19fX0pO0Iuc3luY0tleT10LmhlYWRlci5zeW5jS2V5LHRoaXMuY29ubmVjdGlvbnMuc2V0KEEsQiksZS5zZW5kKG8uR2F0ZXdheURhdGFncmFtLmVuY29kZSh0KSl9KSksQi5wcm9taXNlfWNhbmNlbENvbm5lY3Rpb25BdHRlbXB0KEEpe2NvbnN0IEk9dGhpcy5jb25uZWN0aW9ucy5nZXQoQSk7dm9pZCAwIT09SSYmSS5wZW5kaW5nJiYoSS5yZXNvbHZlKHtjYW5jZWxlZDohMH0pLHRoaXMuY29ubmVjdGlvbnMuZGVsZXRlKEEpKX1kZWxldGVDb25uZWN0aW9uKEEpe3RoaXMuY29ubmVjdGlvbnMuZGVsZXRlKEEpfXNlbmRQZWVySW5mbyhBLEksZyl7aWYodm9pZCAwPT09dGhpcy5zb2NrZXQpdGhyb3cgbmV3IEMuUmFpbndheUVycm9yKFwic29ja2V0IHVuc2V0IGluIEdhdGV3YXkuc2VuZFBlZXJJbmZvXCIpO2NvbnN0IGU9dGhpcy5jb25uZWN0aW9ucy5nZXQoQSk7aWYodm9pZCAwPT09ZSl0aHJvdyBuZXcgQy5SYWlud2F5RXJyb3IoYGNhbid0IHNlbmQgcGVlciBpbmZvIHRvIHVua25vd24gcGVlcklkICR7QX1gKTtpZihlLnBlbmRpbmcpdGhyb3cgbmV3IEMuUmFpbndheUVycm9yKGBjYW4ndCBzZW5kIHBlZXIgaW5mbyB0byBwZW5kaW5nIHBlZXJJZCAke0F9YCk7Y29uc3QgQj10aGlzLm1ha2VGb3J3YXJkYWJsZShBLHtkaXNjcmltaW5hdG9yOm8uUGVlclNpZ25hbGluZ0luZm9ybWF0aW9uLmRpc2NyaW1pbmF0b3IsdmFsdWU6e2lkOmUuY29ubmVjdGlvblJlcXVlc3RJZCx0eXBlOkksZGF0YTpnfX0pLGk9by5HYXRld2F5RGF0YWdyYW0uZW5jb2RlKEIpO3RoaXMuc29ja2V0LnNlbmQoaSl9c2VuZE9mZmVyKEEsSSl7RS5SYWlud2F5TG9nZ2luZy5kZWJ1ZyhcInNlbmRpbmcgb2ZmZXI6IFwiK0kpLHRoaXMuc2VuZFBlZXJJbmZvKEEsby5QZWVySW5mb3JtYXRpb25UeXBlLk9mZmVyLEkpfXNlbmRBbnN3ZXIoQSxJKXtFLlJhaW53YXlMb2dnaW5nLmRlYnVnKFwic2VuZGluZyBvZmZlcjogXCIrSSksdGhpcy5zZW5kUGVlckluZm8oQSxvLlBlZXJJbmZvcm1hdGlvblR5cGUuQW5zd2VyLEkpfXNlbmRDYW5kaWRhdGUoQSxJKXtFLlJhaW53YXlMb2dnaW5nLmRlYnVnKFwic2VuZGluZyBjYW5kaWRhdGVcIitJLmNhbmRpZGF0ZSksdGhpcy5zZW5kUGVlckluZm8oQSxvLlBlZXJJbmZvcm1hdGlvblR5cGUuQ2FuZGlkYXRlLEkuY2FuZGlkYXRlKX1vbk5vbkZhdGFsQWxlcnQoQSxJKXtpZihJPT09by5HYXRld2F5QWxlcnREZXNjcmlwdGlvbi5QZWVyR29uZUF3YXkpZm9yKGNvbnN0W0ksZ11vZiB0aGlzLmNvbm5lY3Rpb25zLmVudHJpZXMoKSlnLnBlbmRpbmcmJmcuc3luY0tleT09PUEmJihnLnJlamVjdChcIlRoZSB0YXJnZXQgcGVlciBpcyBub3QgY29ubmVjdGVkIHRvIFJhaW53YXkuXCIpLHRoaXMuY29ubmVjdGlvbnMuZGVsZXRlKEkpKX1vbkZvcndhcmRhYmxlKEEsSSl7Y29uc3R7dGFyZ2V0UGVlcklkOmcsYm9keTplfT1JO3N3aXRjaChlLmRpc2NyaW1pbmF0b3Ipe2Nhc2Ugby5Db25uZWN0aW9uUmVxdWVzdC5kaXNjcmltaW5hdG9yOntjb25zdHtzb3VyY2VQZWVySWQ6SSxzb3VyY2VFeHRlcm5hbElkOmcsZGVzaXJlZFRyYW5zcG9ydDpCLGlkOmksZXhwaXJhdGlvbkRhdGU6dH09ZS52YWx1ZSxRPWk7dGhpcy5wZWVySWRUb0V4dGVybmFsSWQuc2V0KEksZyksdGhpcy5jb25uZWN0aW9uUmVxdWVzdEhhbmRsZXIoe3BlZXJJZDpJLGV4dGVybmFsSWQ6ZS52YWx1ZS5zb3VyY2VFeHRlcm5hbElkLGFjY2VwdDooKT0+e2lmKHZvaWQgMD09PXRoaXMuc29ja2V0KXRocm93IG5ldyBDLlJhaW53YXlFcnJvcihcIkNvdWxkbid0IHNlbmQgYWNjZXB0IG1lc3NhZ2UgYmVjYXVzZSB0aGUgY29ubmVjdGlvbiB0byBSYWlud2F5IHdhcyBsb3N0LlwiKTtjb25zdCBlPW8uR2F0ZXdheURhdGFncmFtLmVuY29kZSh7aGVhZGVyOntzeW5jS2V5OkF9LGJvZHk6e2Rpc2NyaW1pbmF0b3I6by5HYXRld2F5Rm9yd2FyZGFibGUuZGlzY3JpbWluYXRvcix2YWx1ZTp7dGFyZ2V0UGVlcklkOkksYm9keTp7ZGlzY3JpbWluYXRvcjpvLkFjY2VwdGVkQ29ubmVjdGlvblJlcXVlc3QuZGlzY3JpbWluYXRvcix2YWx1ZTp7c291cmNlUGVlcklkOnRoaXMub3duUGVlcklkLHNvdXJjZUV4dGVybmFsSWQ6dGhpcy5leHRlcm5hbElkLGlkOml9fX19fSk7dGhpcy5zb2NrZXQuc2VuZChlKSx0aGlzLmNvbm5lY3Rpb25zLnNldChJLHtwZW5kaW5nOiExLG93bmVkOiEwLGNvbm5lY3Rpb25SZXF1ZXN0SWQ6UX0pLHRoaXMuYWRkQWNjZXB0ZWRQZWVyKEksZyxRKX0scmVqZWN0Omc9PntpZih2b2lkIDA9PT10aGlzLnNvY2tldCl0aHJvdyBuZXcgQy5SYWlud2F5RXJyb3IoXCJDb3VsZG4ndCBzZW5kIHJlamVjdCBtZXNzYWdlIGJlY2F1c2UgdGhlIGNvbm5lY3Rpb24gdG8gUmFpbndheSB3YXMgbG9zdC5cIik7Y29uc3QgZT1vLkdhdGV3YXlEYXRhZ3JhbS5lbmNvZGUoe2hlYWRlcjp7c3luY0tleTpBfSxib2R5OntkaXNjcmltaW5hdG9yOm8uR2F0ZXdheUZvcndhcmRhYmxlLmRpc2NyaW1pbmF0b3IsdmFsdWU6e3RhcmdldFBlZXJJZDpJLGJvZHk6e2Rpc2NyaW1pbmF0b3I6by5SZWplY3RlZENvbm5lY3Rpb25SZXF1ZXN0LmRpc2NyaW1pbmF0b3IsdmFsdWU6e3NvdXJjZVBlZXJJZDp0aGlzLm93blBlZXJJZCxzb3VyY2VFeHRlcm5hbElkOnRoaXMuZXh0ZXJuYWxJZCxpZDppLHJlYXNvbjpnfX19fX0pO3RoaXMuc29ja2V0LnNlbmQoZSl9fSk7YnJlYWt9Y2FzZSBvLkFjY2VwdGVkQ29ubmVjdGlvblJlcXVlc3QuZGlzY3JpbWluYXRvcjp7Y29uc3R7aWQ6QSxzb3VyY2VQZWVySWQ6SSxzb3VyY2VFeHRlcm5hbElkOmd9PWUudmFsdWUsQj1BLGk9dGhpcy5jb25uZWN0aW9ucy5nZXQoSSk7aWYodm9pZCAwPT09aSlyZXR1cm4gdm9pZCBFLlJhaW53YXlMb2dnaW5nLndhcm5pbmcoXCJJZ25vcmluZyBBY2NlcHRlZENvbm5lY3Rpb25SZXF1ZXN0IGZyb20gdW5leHBlY3RlZCBob3N0bmFtZTogXCIrSSk7aWYoIWkucGVuZGluZylyZXR1cm4gdm9pZCBFLlJhaW53YXlMb2dnaW5nLndhcm5pbmcoXCJJZ25vcmluZyBBY2NlcHRlZENvbm5lY3Rpb25SZXF1ZXN0IGZyb20gYWxyZWFkeS1jb25uZWN0ZWQgaG9zdG5hbWU6IFwiK0kpO2kucmVzb2x2ZSh7Y2FuY2VsZWQ6ITEsYWNjZXB0ZWQ6ITAsY29ubmVjdGlvblJlcXVlc3RJZDpCLGhvc3RFeHRlcm5hbElkOmcsdHJhbnNwb3J0UHJvdG9jb2w6by5QZWVyVHJhbnNwb3J0VHlwZS5TQ1RQfSksdGhpcy5jb25uZWN0aW9ucy5zZXQoSSx7cGVuZGluZzohMSxvd25lZDohMSxwcm9taXNlOmkucHJvbWlzZSxjb25uZWN0aW9uUmVxdWVzdElkOkJ9KTticmVha31jYXNlIG8uUmVqZWN0ZWRDb25uZWN0aW9uUmVxdWVzdC5kaXNjcmltaW5hdG9yOntjb25zdHtpZDpBLHNvdXJjZVBlZXJJZDpJLHNvdXJjZUV4dGVybmFsSWQ6Z309ZS52YWx1ZSxCPUEsaT10aGlzLmNvbm5lY3Rpb25zLmdldChJKTtpZih2b2lkIDA9PT1pKXJldHVybiB2b2lkIEUuUmFpbndheUxvZ2dpbmcud2FybmluZyhcIklnbm9yaW5nIFJlamVjdGVkQ29ubmVjdGlvblJlcXVlc3QgZnJvbSB1bmV4cGVjdGVkIGhvc3RuYW1lOiBcIitJKTtpZighaS5wZW5kaW5nKXJldHVybiB2b2lkIEUuUmFpbndheUxvZ2dpbmcud2FybmluZyhcIklnbm9yaW5nIFJlamVjdGVkQ29ubmVjdGlvblJlcXVlc3QgZnJvbSBhbHJlYWR5LWNvbm5lY3RlZCBob3N0bmFtZTogXCIrSSk7aS5yZXNvbHZlKHtjYW5jZWxlZDohMSxhY2NlcHRlZDohMSxjb25uZWN0aW9uUmVxdWVzdElkOkIsaG9zdEV4dGVybmFsSWQ6Zyx0cmFuc3BvcnRQcm90b2NvbDpvLlBlZXJUcmFuc3BvcnRUeXBlLlNDVFAscmVhc29uOmUudmFsdWUucmVhc29ufSksdGhpcy5jb25uZWN0aW9ucy5kZWxldGUoSSk7YnJlYWt9Y2FzZSBvLlBlZXJTaWduYWxpbmdJbmZvcm1hdGlvbi5kaXNjcmltaW5hdG9yOkUuUmFpbndheUxvZ2dpbmcudHJhY2UoXCJHb3QgcGVlciBpbmZvOlxcblwiK0pTT04uc3RyaW5naWZ5KGUudmFsdWUpKSx0aGlzLmhhbmRsZVBlZXJJbmZvKGUudmFsdWUpfX1kaWUoQSxJKXt2YXIgZyxlO251bGw9PT0oZz10aGlzLnJlamVjdENvbm5lY3RUb0dhdGV3YXlQcm9taXNlKXx8dm9pZCAwPT09Z3x8Zy5jYWxsKHRoaXMsQSksdGhpcy5jb25uZWN0VG9HYXRld2F5UHJvbWlzZT12b2lkIDAsdGhpcy5yZXNvbHZlQ29ubmVjdFRvR2F0ZXdheVByb21pc2U9dm9pZCAwLHRoaXMucmVqZWN0Q29ubmVjdFRvR2F0ZXdheVByb21pc2U9dm9pZCAwO2Zvcihjb25zdCBBIG9mIHRoaXMuY29ubmVjdGlvbnMudmFsdWVzKCkpQS5wZW5kaW5nJiZBLnJlamVjdChJKTt0aGlzLmNvbm5lY3Rpb25zLmNsZWFyKCksbnVsbD09PShlPXRoaXMuY29ubmVjdGlvbkxvc3RFdmVudCl8fHZvaWQgMD09PWV8fGUuaW52b2tlKG5ldyBDLlJhaW53YXlFcnJvcihJKSl9dW5zZXRDb25uZWN0VG9HYXRld2F5UHJvbWlzZSgpe3RoaXMuY29ubmVjdFRvR2F0ZXdheVByb21pc2U9dm9pZCAwLHRoaXMucmVzb2x2ZUNvbm5lY3RUb0dhdGV3YXlQcm9taXNlPXZvaWQgMCx0aGlzLnJlamVjdENvbm5lY3RUb0dhdGV3YXlQcm9taXNlPXZvaWQgMH19LGU9bmV3IFdlYWtNYXB9LDY0MzpmdW5jdGlvbihBLEksZyl7XCJ1c2Ugc3RyaWN0XCI7dmFyIGUsQj10aGlzJiZ0aGlzLl9fYXdhaXRlcnx8ZnVuY3Rpb24oQSxJLGcsZSl7cmV0dXJuIG5ldyhnfHwoZz1Qcm9taXNlKSkoKGZ1bmN0aW9uKEIsaSl7ZnVuY3Rpb24gdChBKXt0cnl7QyhlLm5leHQoQSkpfWNhdGNoKEEpe2koQSl9fWZ1bmN0aW9uIFEoQSl7dHJ5e0MoZS50aHJvdyhBKSl9Y2F0Y2goQSl7aShBKX19ZnVuY3Rpb24gQyhBKXt2YXIgSTtBLmRvbmU/QihBLnZhbHVlKTooST1BLnZhbHVlLEkgaW5zdGFuY2VvZiBnP0k6bmV3IGcoKGZ1bmN0aW9uKEEpe0EoSSl9KSkpLnRoZW4odCxRKX1DKChlPWUuYXBwbHkoQSxJfHxbXSkpLm5leHQoKSl9KSl9O09iamVjdC5kZWZpbmVQcm9wZXJ0eShJLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLEkuUmFpbndheVJhdGVDb250cm9sbGVyPUkuZGVmYXVsdFJhdGVDb250cm9sUGFyYW1ldGVycz1JLlF1YWxpdHlBZGp1c3RtZW50PXZvaWQgMDtjb25zdCBpPWcoMTk4KSx0PWcoNDM0KSxRPWcoNDY0KSxDPWcoNjk1KTt2YXIgRTshZnVuY3Rpb24oQSl7QVtBLlVwPTBdPVwiVXBcIixBW0EuRG93bj0xXT1cIkRvd25cIn0oRT1JLlF1YWxpdHlBZGp1c3RtZW50fHwoSS5RdWFsaXR5QWRqdXN0bWVudD17fSkpLEkuZGVmYXVsdFJhdGVDb250cm9sUGFyYW1ldGVycz17YmVhdE1zOjI1MDAsd2luZG93TXM6NDUwMCxiYWRCZWF0czoyLGdvb2RCZWF0czo0LGJhY2tvZmZGYWN0b3I6MixsYXRlbmVzc1RocmVzaG9sZE1zOjIwMCxsYXRlbmVzc1Ntb290aGluZ0ZhY3RvcjouOTM3NSxiYWRMYXRlRnJhbWVSYXRpbzouNzUsaW5pdGlhbEJpdHJhdGVLYnBzOk51bWJlcihudWxsIT09KGU9bmV3IFVSTFNlYXJjaFBhcmFtcyh3aW5kb3cubG9jYXRpb24uc2VhcmNoKS5nZXQoXCJpbml0aWFsLWJpdHJhdGVcIikpJiZ2b2lkIDAhPT1lP2U6NWUzKSxxdWFsaXR5U3RlcEZhY3RvcjoxLjE4NzV9LEkuUmFpbndheVJhdGVDb250cm9sbGVyPWNsYXNze2NvbnN0cnVjdG9yKEE9SS5kZWZhdWx0UmF0ZUNvbnRyb2xQYXJhbWV0ZXJzLGcsZSxRKXt0aGlzLmNob3NlblZpZGVvQ29uZmlnPWcsdGhpcy5wZXJmb3JtYW5jZU1vbml0b3I9USx0aGlzLmJhZEJlYXRDb3VudD0wLHRoaXMuZ29vZEJlYXRDb3VudD0wLHRoaXMubGFzdEFkanVzdG1lbnQ9dm9pZCAwLHRoaXMuaGlzdG9yeT1bXSx0aGlzLmxvd2VzdERlbHRhPXZvaWQgMCx0aGlzLnNtb290aExhdGVuZXNzPTAsdGhpcy5mcmFtZXNUaGlzQmVhdD0wLHRoaXMubGF0ZUZyYW1lc1RoaXNCZWF0PTAsdGhpcy5kZWJ1Z0xhdGVuZXNzU21vb3RoaW5nPSExLHRoaXMuYmFkQ3B1UGVyZlRoaXNCZWF0PSExLHRoaXMuYmFkRGVjb2RlclBlcmZUaGlzQmVhdD0hMSx0aGlzLmJhZENwdVBlcmZIYW5kbGVyPSgpPT57dGhpcy5iYWRDcHVQZXJmVGhpc0JlYXQ9ITB9LHRoaXMuYmFkRGVjb2RlclBlcmZIYW5kbGVyPSgpPT57dGhpcy5iYWREZWNvZGVyUGVyZlRoaXNCZWF0PSEwfSx0aGlzLmhhbmRsZVZpZGVvUmVhZHlTdGF0ZT1BPT57QT09PXQuVmlkZW9SZWFkeVN0YXRlLkRldGFjaGVkfHxBPT09dC5WaWRlb1JlYWR5U3RhdGUuUGF1c2VkfHxBPT09dC5WaWRlb1JlYWR5U3RhdGUuV2FpdGluZ0ZvcktleWZyYW1lP3RoaXMuc3RvcCgpOnRoaXMuc3RhcnQoKX0sdGhpcy5jaGVjaz0oKT0+Qih0aGlzLHZvaWQgMCx2b2lkIDAsKGZ1bmN0aW9uKigpezAhPT10aGlzLmZyYW1lc1RoaXNCZWF0JiYoKHlpZWxkIHRoaXMuYmVhdElzQmFkKCkpP3RoaXMuYmFkQmVhdCgpOnRoaXMuZ29vZEJlYXQoKSx0aGlzLmZyYW1lc1RoaXNCZWF0PTAsdGhpcy5sYXRlRnJhbWVzVGhpc0JlYXQ9MCx0aGlzLmJhZENwdVBlcmZUaGlzQmVhdD0hMSx0aGlzLmJhZERlY29kZXJQZXJmVGhpc0JlYXQ9ITEpfSkpLHRoaXMub3duTWF4aW11bUticHM9MS8wLHRoaXMuY2hvc2VuVmlkZW9Db25maWdNaW1lVHlwZT1DLnZpZGVvQ29kZWNNaW1lVHlwZShnLmNvZGVjKSx0aGlzLnBhcmFtZXRlcnM9T2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LEkuZGVmYXVsdFJhdGVDb250cm9sUGFyYW1ldGVycyksQSksdGhpcy5zdWdnZXN0Qml0cmF0ZUticHM9ZSx0aGlzLmN1cnJlbnRCaXRyYXRlS2Jwcz10aGlzLnBhcmFtZXRlcnMuaW5pdGlhbEJpdHJhdGVLYnBzLHRoaXMuZnJhbWVWYXJpYW5jZU1zPW5ldyBpLldpbmRvd1RyYWNrKHRoaXMucGFyYW1ldGVycy53aW5kb3dNcyxpLnN0YW5kYXJkRGV2aWF0aW9uKX1mb3JtYXQoQSl7cmV0dXJuYFtSYXRlQ29udHJvbDogJHt0aGlzLmN1cnJlbnRCaXRyYXRlS2Jwcy50b0ZpeGVkKDApK1wia2Jwc1wifSwgKyR7dGhpcy5zbW9vdGhMYXRlbmVzcy50b0ZpeGVkKDApfW1zXSAke0F9YH1kZWJ1ZyhBKXtRLlJhaW53YXlMb2dnaW5nLmRlYnVnKHRoaXMuZm9ybWF0KEEpKX1pbmZvKEEpe1EuUmFpbndheUxvZ2dpbmcuaW5mb3JtYXRpb24odGhpcy5mb3JtYXQoQSkpfXN0YXJ0KCl7dmFyIEEsSTt0aGlzLmNoZWNrSW50ZXJ2YWx8fCh0aGlzLmluZm8oXCJTdGFydGluZyByYXRlIGNvbnRyb2whXCIpLHRoaXMuY2hlY2tJbnRlcnZhbD13aW5kb3cuc2V0SW50ZXJ2YWwodGhpcy5jaGVjayx0aGlzLnBhcmFtZXRlcnMuYmVhdE1zKSxudWxsPT09KEE9dGhpcy5wZXJmb3JtYW5jZU1vbml0b3IpfHx2b2lkIDA9PT1BfHxBLmNwdVN0YXJ2YXRpb25FdmVudC5hZGRIYW5kbGVyKHRoaXMuYmFkQ3B1UGVyZkhhbmRsZXIpLG51bGw9PT0oST10aGlzLnBlcmZvcm1hbmNlTW9uaXRvcil8fHZvaWQgMD09PUl8fEkuZGVjb2RlclN0cnVnZ2xpbmdFdmVudC5hZGRIYW5kbGVyKHRoaXMuYmFkRGVjb2RlclBlcmZIYW5kbGVyKSl9c3RvcCgpe3ZhciBBLEk7dGhpcy5jaGVja0ludGVydmFsJiYodGhpcy5pbmZvKFwiU3RvcHBpbmcgcmF0ZSBjb250cm9sIVwiKSx3aW5kb3cuY2xlYXJJbnRlcnZhbCh0aGlzLmNoZWNrSW50ZXJ2YWwpLHRoaXMuY2hlY2tJbnRlcnZhbD12b2lkIDAsbnVsbD09PShBPXRoaXMucGVyZm9ybWFuY2VNb25pdG9yKXx8dm9pZCAwPT09QXx8QS5jcHVTdGFydmF0aW9uRXZlbnQucmVtb3ZlSGFuZGxlcih0aGlzLmJhZENwdVBlcmZIYW5kbGVyKSxudWxsPT09KEk9dGhpcy5wZXJmb3JtYW5jZU1vbml0b3IpfHx2b2lkIDA9PT1JfHxJLmRlY29kZXJTdHJ1Z2dsaW5nRXZlbnQucmVtb3ZlSGFuZGxlcih0aGlzLmJhZERlY29kZXJQZXJmSGFuZGxlcikpfWZlZWRGcmFtZVRpbWVzdGFtcChBKXtjb25zdCBJPXBlcmZvcm1hbmNlLm5vdygpLUE7KHZvaWQgMD09PXRoaXMubG93ZXN0RGVsdGF8fEk8dGhpcy5sb3dlc3REZWx0YXx8TWF0aC5hYnModGhpcy5sb3dlc3REZWx0YS1JKT41ZTQpJiYodGhpcy5sb3dlc3REZWx0YT1JKTtjb25zdCBnPUktdGhpcy5sb3dlc3REZWx0YSxlPXRoaXMucGFyYW1ldGVycy5sYXRlbmVzc1Ntb290aGluZ0ZhY3RvcjtpZih0aGlzLnNtb290aExhdGVuZXNzPWUqdGhpcy5zbW9vdGhMYXRlbmVzcysoMS1lKSpnLHRoaXMuZnJhbWVzVGhpc0JlYXQrKyx0aGlzLnNtb290aExhdGVuZXNzPj10aGlzLnBhcmFtZXRlcnMubGF0ZW5lc3NUaHJlc2hvbGRNcyYmdGhpcy5sYXRlRnJhbWVzVGhpc0JlYXQrKyx0aGlzLmRlYnVnTGF0ZW5lc3NTbW9vdGhpbmcpe2NvbnN0IEE9bmV3IEFycmF5KDEwMCk7QS5maWxsKFwiLVwiKTtjb25zdCBJPWcsZT10aGlzLnNtb290aExhdGVuZXNzO0FbNTBdPVwiLlwiLEFbTWF0aC5tYXgoMCxNYXRoLm1pbihNYXRoLnJvdW5kKEkvMTArNTApLDk5KSldPVwiTFwiLEFbTWF0aC5tYXgoMCxNYXRoLm1pbihNYXRoLnJvdW5kKGUvMTArNTApLDk5KSldPVwiU1wiLHRoaXMuYmVhdElzQmFkKCkudGhlbigoZz0+US5SYWlud2F5TG9nZ2luZy5kZWJ1ZyhgJHtBLmpvaW4oXCJcIil9IEw9JHtJfSBTPSR7ZX0gYmFkPSR7Z30gbGQ9JHt0aGlzLmxvd2VzdERlbHRhfWApKSl9fWRlY29kaW5nSW5mb0F0Qml0cmF0ZShBKXtyZXR1cm4gbmF2aWdhdG9yLm1lZGlhQ2FwYWJpbGl0aWVzLmRlY29kaW5nSW5mbyh7dHlwZTpcIm1lZGlhLXNvdXJjZVwiLHZpZGVvOnt3aWR0aDp0aGlzLmNob3NlblZpZGVvQ29uZmlnLmNvZGVjLndpZHRoLGhlaWdodDp0aGlzLmNob3NlblZpZGVvQ29uZmlnLmNvZGVjLmhlaWdodCxmcmFtZXJhdGU6dGhpcy5jaG9zZW5WaWRlb0NvbmZpZy5jb2RlYy5yZWZyZXNoUmF0ZSxiaXRyYXRlOjFlMypBLGNvbnRlbnRUeXBlOkMudmlkZW9Db2RlY01pbWVUeXBlKHRoaXMuY2hvc2VuVmlkZW9Db25maWcuY29kZWMpfX0pfWNhcGFiaWxpdGllc0JhZCgpe3JldHVybiBCKHRoaXMsdm9pZCAwLHZvaWQgMCwoZnVuY3Rpb24qKCl7aWYoIShcIk1lZGlhU291cmNlXCJpbiB3aW5kb3cpKXJldHVybiExO2lmKCEoXCJtZWRpYUNhcGFiaWxpdGllc1wiaW4gbmF2aWdhdG9yKSlyZXR1cm4hMTtjb25zdCBBPXlpZWxkIHRoaXMuZGVjb2RpbmdJbmZvQXRCaXRyYXRlKHRoaXMuY3VycmVudEJpdHJhdGVLYnBzKSxJPXlpZWxkIHRoaXMuZGVjb2RpbmdJbmZvQXRCaXRyYXRlKHRoaXMuYml0cmF0ZU9uZVN0ZXBEb3duS2JwcygpKTtyZXR1cm4gSS5zbW9vdGgmJiFBLnNtb290aHx8SS5wb3dlckVmZmljaWVudCYmIUEucG93ZXJFZmZpY2llbnR9KSl9bGF0ZUZyYW1lUmF0aW9CYWQoKXtyZXR1cm4gdGhpcy5sYXRlRnJhbWVzVGhpc0JlYXQvdGhpcy5mcmFtZXNUaGlzQmVhdD49dGhpcy5wYXJhbWV0ZXJzLmJhZExhdGVGcmFtZVJhdGlvfWJlYXRJc0JhZCgpe3JldHVybiBCKHRoaXMsdm9pZCAwLHZvaWQgMCwoZnVuY3Rpb24qKCl7cmV0dXJuIHRoaXMuYmFkRGVjb2RlclBlcmZUaGlzQmVhdHx8dGhpcy5iYWRDcHVQZXJmVGhpc0JlYXR8fHRoaXMubGF0ZUZyYW1lUmF0aW9CYWQoKXx8KHlpZWxkIHRoaXMuY2FwYWJpbGl0aWVzQmFkKCkpfSkpfWJhZEJlYXQoKXtpZih0aGlzLmN1cnJlbnRCaXRyYXRlS2Jwczw9dGhpcy5sb3dlc3RTdXBwb3J0ZWRCaXRyYXRlS2JwcygpKXJldHVybiB2b2lkIHRoaXMuZGVidWcoYGNyYXNoZWQgYXQgJHt0aGlzLmN1cnJlbnRCaXRyYXRlS2Jwcy50b0ZpeGVkKDApfWticHMsIGlnbm9yaW5nIGJhZCBiZWF0YCk7dGhpcy5iYWRCZWF0Q291bnQrKyx0aGlzLmdvb2RCZWF0Q291bnQ9MCx0aGlzLmN1cnJlbnRCaXRyYXRlS2Jwcztjb25zdCBBPXRoaXMucGFyYW1ldGVycy5iYWRCZWF0cztpZih0aGlzLmRlYnVnKGBiYWQgYmVhdDogJHt0aGlzLmJhZEJlYXRDb3VudH0vJHtBfWApLHRoaXMuYmFkQmVhdENvdW50Pj10aGlzLnBhcmFtZXRlcnMuYmFkQmVhdHMpe3RoaXMuZ29vZEJlYXRDb3VudD10aGlzLmJhZEJlYXRDb3VudD0wO2NvbnN0IEE9dGhpcy5sYXN0QWRqdXN0bWVudD09PUUuVXA7dGhpcy5xdWFsaXR5RG93bigpLHRoaXMuZGVidWcoXCJ3ZW50IGRvd24gaW4gcXVhbGl0eVwiKSxBJiZ0aGlzLmN1cnJlbnRCaXRyYXRlS2Jwczx0aGlzLm93bk1heGltdW1LYnBzJiYodGhpcy5vd25NYXhpbXVtS2Jwcz10aGlzLmN1cnJlbnRCaXRyYXRlS2Jwcyx0aGlzLmluZm8oYHNldHRpbmcgYSBuZXcgbWF4aW11bSBhdCAke3RoaXMub3duTWF4aW11bUticHMudG9GaXhlZCgwKX1rYnBzYCkpfX1nb29kQmVhdCgpe2lmKHRoaXMuY3VycmVudEJpdHJhdGVLYnBzPj10aGlzLm93bk1heGltdW1LYnBzfHx0aGlzLmN1cnJlbnRCaXRyYXRlS2Jwcz49dGhpcy5oaWdoZXN0U3VwcG9ydGVkQml0cmF0ZUticHMoKSlyZXR1cm4gdGhpcy5kZWJ1ZyhgbWF4ZWQgYXQgJHt0aGlzLmN1cnJlbnRCaXRyYXRlS2Jwcy50b0ZpeGVkKDApfWticHMsIGlnbm9yaW5nIGdvb2QgYmVhdGApLHZvaWQodGhpcy5iYWRCZWF0Q291bnQ9MCk7dGhpcy5nb29kQmVhdENvdW50KyssdGhpcy5iYWRCZWF0Q291bnQ9MCx0aGlzLmN1cnJlbnRCaXRyYXRlS2Jwcztjb25zdCBBPXRoaXMucGFyYW1ldGVycy5nb29kQmVhdHM7dGhpcy5kZWJ1ZyhgZ29vZCBiZWF0OiAke3RoaXMuZ29vZEJlYXRDb3VudH0vJHtBfWApLHRoaXMuZ29vZEJlYXRDb3VudD49QSYmKHRoaXMuZ29vZEJlYXRDb3VudD10aGlzLmJhZEJlYXRDb3VudD0wLHRoaXMucXVhbGl0eVVwKCksdGhpcy5kZWJ1ZyhcIndlbnQgdXAgaW4gcXVhbGl0eVwiKSl9Yml0cmF0ZU9uZVN0ZXBVcEticHMoKXtyZXR1cm4gTWF0aC5taW4odGhpcy5oaWdoZXN0U3VwcG9ydGVkQml0cmF0ZUticHMoKSx0aGlzLmN1cnJlbnRCaXRyYXRlS2Jwcyp0aGlzLnBhcmFtZXRlcnMucXVhbGl0eVN0ZXBGYWN0b3IpfWJpdHJhdGVPbmVTdGVwRG93bkticHMoKXtyZXR1cm4gTWF0aC5tYXgodGhpcy5sb3dlc3RTdXBwb3J0ZWRCaXRyYXRlS2JwcygpLHRoaXMuY3VycmVudEJpdHJhdGVLYnBzL3RoaXMucGFyYW1ldGVycy5xdWFsaXR5U3RlcEZhY3Rvcil9cXVhbGl0eVVwKCl7dGhpcy5jdXJyZW50Qml0cmF0ZUticHM9dGhpcy5iaXRyYXRlT25lU3RlcFVwS2JwcygpLHRoaXMuc3VnZ2VzdEJpdHJhdGVLYnBzKHRoaXMuY3VycmVudEJpdHJhdGVLYnBzKSx0aGlzLmxhc3RBZGp1c3RtZW50PUUuVXAsdGhpcy5oaXN0b3J5LnB1c2goe3RpbWU6cGVyZm9ybWFuY2Uubm93KCksYml0cmF0ZTp0aGlzLmN1cnJlbnRCaXRyYXRlS2Jwc30pfXF1YWxpdHlEb3duKCl7dGhpcy5jdXJyZW50Qml0cmF0ZUticHM9dGhpcy5iaXRyYXRlT25lU3RlcERvd25LYnBzKCksdGhpcy5zdWdnZXN0Qml0cmF0ZUticHModGhpcy5jdXJyZW50Qml0cmF0ZUticHMpLHRoaXMubGFzdEFkanVzdG1lbnQ9RS5Eb3duLHRoaXMuaGlzdG9yeS5wdXNoKHt0aW1lOnBlcmZvcm1hbmNlLm5vdygpLGJpdHJhdGU6dGhpcy5jdXJyZW50Qml0cmF0ZUticHN9KSx0aGlzLmxvd2VzdERlbHRhPXZvaWQgMH1sb3dlc3RTdXBwb3J0ZWRCaXRyYXRlS2Jwcygpe3ZhciBBO3JldHVybiBOdW1iZXIobnVsbCE9PShBPW5ldyBVUkxTZWFyY2hQYXJhbXMod2luZG93LmxvY2F0aW9uLnNlYXJjaCkuZ2V0KFwibG93ZXN0LWJpdHJhdGVcIikpJiZ2b2lkIDAhPT1BP0E6NWUzKX1oaWdoZXN0U3VwcG9ydGVkQml0cmF0ZUticHMoKXt2YXIgQTtyZXR1cm4gTnVtYmVyKG51bGwhPT0oQT1uZXcgVVJMU2VhcmNoUGFyYW1zKHdpbmRvdy5sb2NhdGlvbi5zZWFyY2gpLmdldChcIm1heC1iaXRyYXRlXCIpKSYmdm9pZCAwIT09QT9BOjFlNCl9fX0sMTQ1OmZ1bmN0aW9uKEEsSSxnKXtcInVzZSBzdHJpY3RcIjt2YXIgZSxCPXRoaXMmJnRoaXMuX19hd2FpdGVyfHxmdW5jdGlvbihBLEksZyxlKXtyZXR1cm4gbmV3KGd8fChnPVByb21pc2UpKSgoZnVuY3Rpb24oQixpKXtmdW5jdGlvbiB0KEEpe3RyeXtDKGUubmV4dChBKSl9Y2F0Y2goQSl7aShBKX19ZnVuY3Rpb24gUShBKXt0cnl7QyhlLnRocm93KEEpKX1jYXRjaChBKXtpKEEpfX1mdW5jdGlvbiBDKEEpe3ZhciBJO0EuZG9uZT9CKEEudmFsdWUpOihJPUEudmFsdWUsSSBpbnN0YW5jZW9mIGc/STpuZXcgZygoZnVuY3Rpb24oQSl7QShJKX0pKSkudGhlbih0LFEpfUMoKGU9ZS5hcHBseShBLEl8fFtdKSkubmV4dCgpKX0pKX0saT10aGlzJiZ0aGlzLl9fY2xhc3NQcml2YXRlRmllbGRTZXR8fGZ1bmN0aW9uKEEsSSxnKXtpZighSS5oYXMoQSkpdGhyb3cgbmV3IFR5cGVFcnJvcihcImF0dGVtcHRlZCB0byBzZXQgcHJpdmF0ZSBmaWVsZCBvbiBub24taW5zdGFuY2VcIik7cmV0dXJuIEkuc2V0KEEsZyksZ30sdD10aGlzJiZ0aGlzLl9fY2xhc3NQcml2YXRlRmllbGRHZXR8fGZ1bmN0aW9uKEEsSSl7aWYoIUkuaGFzKEEpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJhdHRlbXB0ZWQgdG8gZ2V0IHByaXZhdGUgZmllbGQgb24gbm9uLWluc3RhbmNlXCIpO3JldHVybiBJLmdldChBKX07T2JqZWN0LmRlZmluZVByb3BlcnR5KEksXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksSS5SVENUcmFuc3BvcnQ9dm9pZCAwO2NvbnN0IFE9Zyg5OTQpLEM9Zyg5KSxFPWcoNDY0KSxvPWcoOTA0KSxhPWcoOTg3KSxuPWcoNDIwKSxzPWcoNzgzKSxyPXtpY2VTZXJ2ZXJzOlt7dXJsczpcInN0dW46c3R1bi5yYWlud2F5LmNvbTozNDc4XCJ9XX07Y2xhc3MgZCBleHRlbmRzIEMuUmFpbndheVRyYW5zcG9ydHtjb25zdHJ1Y3RvcihBLEksZyxCLHQsYSl7c3VwZXIoKSx0aGlzLm93blBlZXJJZD1BLHRoaXMudGFyZ2V0UGVlcklkPUksdGhpcy5zZW5kTG9jYWxPZmZlclNkcD1nLHRoaXMuc2VuZExvY2FsQW5zd2VyU2RwPUIsdGhpcy5zZW5kTG9jYWxJY2VDYW5kaWRhdGU9dCx0aGlzLnJlcG9ydFN0YXRlQ2hhbmdlPWEsZS5zZXQodGhpcyxDLlJhaW53YXlUcmFuc3BvcnRTdGF0dXMuRGlzY29ubmVjdGVkKSx0aGlzLnJ0Y0NvbmZpZ3VyYXRpb249cix0aGlzLmRhdGFDaGFubmVsc0NvbmZpZz17fSx0aGlzLnN5bmNLZXk9MCx0aGlzLm9uUmFpbndheU1lc3NhZ2U9KCk9Pnt9LHRoaXMub25BcHBsaWNhdGlvbk1lc3NhZ2U9KCk9Pnt9LHRoaXMub25DbG9zZT0oKT0+e30sdGhpcy5oYW5kbGVQZWVySW5mbz1BPT57dmFyIEksZyxlO2lmKEEudHlwZT09PW8uUGVlckluZm9ybWF0aW9uVHlwZS5BbnN3ZXIpRS5SYWlud2F5TG9nZ2luZy5kZWJ1ZyhcIkdvdCBBbnN3ZXIgaW4gQ1JJRCBcIitBLmlkK1wiXFxuXCIrQS5kYXRhKSxudWxsPT09KEk9dGhpcy5wZWVyQ29ubmVjdGlvbil8fHZvaWQgMD09PUl8fEkuc2V0UmVtb3RlRGVzY3JpcHRpb24oe3R5cGU6XCJhbnN3ZXJcIixzZHA6QS5kYXRhfSk7ZWxzZSBpZihBLnR5cGU9PT1vLlBlZXJJbmZvcm1hdGlvblR5cGUuT2ZmZXIpRS5SYWlud2F5TG9nZ2luZy5kZWJ1ZyhcIkdvdCBPZmZlciBpbiBDUklEIFwiK0EuaWQrXCJcXG5cIitBLmRhdGEpLG51bGw9PT0oZz10aGlzLnBlZXJDb25uZWN0aW9uKXx8dm9pZCAwPT09Z3x8Zy5zZXRSZW1vdGVEZXNjcmlwdGlvbih7dHlwZTpcIm9mZmVyXCIsc2RwOkEuZGF0YX0pLHRoaXMuc2VuZEFuc3dlcigpO2Vsc2V7aWYoQS50eXBlIT09by5QZWVySW5mb3JtYXRpb25UeXBlLkNhbmRpZGF0ZSl7Y29uc3QgST1vLlBlZXJJbmZvcm1hdGlvblR5cGVbQS50eXBlXTt0aHJvdyBuZXcgUS5SYWlud2F5RXJyb3IoYHVuZXhwZWN0ZWQgUGVlckluZm9ybWF0aW9uVHlwZSAke0l9IGluIGhhbmRsZVBlZXJJbmZvYCl9RS5SYWlud2F5TG9nZ2luZy5kZWJ1ZyhcIkdvdCBDYW5kaWRhdGUgaW4gQ1JJRCBcIitBLmlkK1wiXFxuXCIrQS5kYXRhKSxudWxsPT09KGU9dGhpcy5wZWVyQ29ubmVjdGlvbil8fHZvaWQgMD09PWV8fGUuYWRkSWNlQ2FuZGlkYXRlKG5ldyBSVENJY2VDYW5kaWRhdGUoe2NhbmRpZGF0ZTpBLmRhdGEsc2RwTWlkOlwiXCIsc2RwTUxpbmVJbmRleDowfSkpfX0sdGhpcy5oYW5kbGVMb2NhbEljZUNhbmRpZGF0ZT1BPT57QS5jYW5kaWRhdGUmJlwiMVwiPT09QS5jYW5kaWRhdGUuY2FuZGlkYXRlLnNwbGl0KFwiIFwiKVsxXSYmdGhpcy5zZW5kTG9jYWxJY2VDYW5kaWRhdGUoQS5jYW5kaWRhdGUpfSx0aGlzLmhhbmRsZUljZUNvbm5lY3Rpb25TdGF0ZUNoYW5nZT0oKT0+e2lmKCF0aGlzLnBlZXJDb25uZWN0aW9uKXJldHVybjtjb25zdCBBPXRoaXMucGVlckNvbm5lY3Rpb24uaWNlQ29ubmVjdGlvblN0YXRlO0UuUmFpbndheUxvZ2dpbmcuaW5mb3JtYXRpb24oYElDRSBjb25uZWN0aW9uIHN0YXRlIGNoYW5nZWQgdG8gJHtBfWApfSx0aGlzLmhhbmRsZUNvbm5lY3Rpb25TdGF0ZUNoYW5nZT0oKT0+e3ZhciBBO2lmKCF0aGlzLnBlZXJDb25uZWN0aW9uKXJldHVybjtjb25zdCBJPXRoaXMucGVlckNvbm5lY3Rpb24uY29ubmVjdGlvblN0YXRlO0UuUmFpbndheUxvZ2dpbmcuaW5mb3JtYXRpb24oYENvbm5lY3Rpb24gc3RhdGUgY2hhbmdlZCB0byAke0l9YCksXCJjbG9zZWRcIj09PUl8fFwiZmFpbGVkXCI9PT1JPyh0aGlzLnJlcG9ydFN0YXRlQ2hhbmdlKHMuUmFpbndheVBlZXJTdGF0ZS5GYWlsZWQpLG51bGw9PT0oQT10aGlzLm9wZW5SZWplY3QpfHx2b2lkIDA9PT1BfHxBLmNhbGwodGhpcyksdGhpcy5vbkNsb3NlKCksaSh0aGlzLGUsQy5SYWlud2F5VHJhbnNwb3J0U3RhdHVzLkRpc2Nvbm5lY3RlZCksdGhpcy5kaXNwb3NlKCkpOlwiZGlzY29ubmVjdGVkXCI9PT1JP3RoaXMucmVwb3J0U3RhdGVDaGFuZ2Uocy5SYWlud2F5UGVlclN0YXRlLkRpc2Nvbm5lY3RlZCk6XCJjb25uZWN0aW5nXCI9PT1JP3RoaXMucmVwb3J0U3RhdGVDaGFuZ2Uocy5SYWlud2F5UGVlclN0YXRlLkNvbm5lY3RpbmcpOlwiY29ubmVjdGVkXCI9PT1JP3RoaXMucmVwb3J0U3RhdGVDaGFuZ2Uocy5SYWlud2F5UGVlclN0YXRlLkNvbm5lY3RlZCk6XCJuZXdcIj09PUkmJnRoaXMucmVwb3J0U3RhdGVDaGFuZ2Uocy5SYWlud2F5UGVlclN0YXRlLk5ldyl9LHRoaXMuaGFuZGxlRGF0YUNoYW5uZWxNZXNzYWdlPUE9Pntjb25zdCBJPUEudGFyZ2V0LmxhYmVsO3RoaXMuaGFuZGxlTGFiZWxBbmREYXRhKEksbmV3IFVpbnQ4QXJyYXkoQS5kYXRhKSl9LHRoaXMuaGFuZGxlRGF0YUNoYW5uZWxDbG9zZT1BPT57Y29uc3QgST1BLnRhcmdldC5sYWJlbDtFLlJhaW53YXlMb2dnaW5nLndhcm5pbmcoXCJSVEMgY2hhbm5lbCBjbG9zZWQ6IFwiK0kpfSx0aGlzLmhhbmRsZURhdGFDaGFubmVsRXJyb3I9QT0+e2NvbnN0IEk9QS50YXJnZXQubGFiZWw7RS5SYWlud2F5TG9nZ2luZy53YXJuaW5nKFwiUlRDIGNoYW5uZWwgZXJyb3JlZDogXCIrSSl9LHRoaXMuY2h1bmtlZE1lc3NhZ2VzPW5ldyBNYXAsdGhpcy5oaWdoZXN0Q2h1bmtHcm91cD0wO2NvbnN0IG49e3Byb3RvY29sOlwic2N0cFwiLG5lZ290aWF0ZWQ6ITF9LGQ9e29yZGVyZWQ6ITEsbWF4UmV0cmFuc21pdHM6MH07dGhpcy5kYXRhQ2hhbm5lbHNDb25maWc9e1JXX0xvZ2ljOk9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7aWQ6MH0sbikse29yZGVyZWQ6ITB9KSxSV19WaWRlbzpPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe2lkOjF9LG4pLGQpLFJXX0F1ZGlvOk9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7aWQ6Mn0sbiksZCksUldfSW5wdXQ6T2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHtpZDozfSxuKSxkKX19Y3JlYXRlRGF0YUNoYW5uZWwoQSxJKXt2YXIgZyxlO2NvbnN0IEI9e3Byb3RvY29sOlwic2N0cFwiLG5lZ290aWF0ZWQ6ITF9LGk9bnVsbD09PShnPXRoaXMucGVlckNvbm5lY3Rpb24pfHx2b2lkIDA9PT1nP3ZvaWQgMDpnLmNyZWF0ZURhdGFDaGFubmVsKEEsST09PW4uUmFpbndheUNoYW5uZWxNb2RlLlJlbGlhYmxlP09iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSxCKSx7b3JkZXJlZDohMH0pOk9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSxCKSx7b3JkZXJlZDohMSxtYXhSZXRyYW5zbWl0czowfSkpO3JldHVybiBpJiYoaS5hZGRFdmVudExpc3RlbmVyKFwiY2xvc2VcIix0aGlzLmhhbmRsZURhdGFDaGFubmVsQ2xvc2UpLGkuYWRkRXZlbnRMaXN0ZW5lcihcImVycm9yXCIsdGhpcy5oYW5kbGVEYXRhQ2hhbm5lbEVycm9yKSxpLmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsdGhpcy5oYW5kbGVEYXRhQ2hhbm5lbE1lc3NhZ2UpLG51bGwhPT0oZT10aGlzLmRhdGFDaGFubmVscykmJnZvaWQgMCE9PWV8fCh0aGlzLmRhdGFDaGFubmVscz17fSksdGhpcy5kYXRhQ2hhbm5lbHNbQV09aSksaX1zZW5kTWVzc2FnZShBLEkpe3ZhciBnO2lmKCFBKXRocm93IG5ldyBRLlJhaW53YXlFcnJvcihcInNlbmRNZXNzYWdlOiBubyBsYWJlbFwiKTtpZighdGhpcy5kYXRhQ2hhbm5lbHMpdGhyb3cgbmV3IFEuUmFpbndheUVycm9yKFwic2VuZE1lc3NhZ2U6IGRhdGFDaGFubmVscyBub3QgaW5pdGlhbGl6ZWRcIik7Y29uc3QgZT1udWxsPT09KGc9dGhpcy5kYXRhQ2hhbm5lbHMpfHx2b2lkIDA9PT1nP3ZvaWQgMDpnW0FdO2lmKCFlKXRocm93IG5ldyBRLlJhaW53YXlFcnJvcihgc2VuZE1lc3NhZ2U6IGNoYW5uZWwgXCIke0F9XCIgZG9lcyBub3QgZXhpc3RgKTtpZihcIm9wZW5cIiE9PWUucmVhZHlTdGF0ZSl0aHJvdyBuZXcgUS5SYWlud2F5RXJyb3IoYHNlbmRNZXNzYWdlOiBjaGFubmVsIFwiJHtBfVwiIGlzIG5vdCBvcGVuYCk7ZS5zZW5kKEkpfWdldCBzdGF0dXMoKXtyZXR1cm4gdCh0aGlzLGUpfWdldCBtYXhNZXNzYWdlU2l6ZSgpe3ZhciBBLEksZztyZXR1cm4gbnVsbCE9PShnPW51bGw9PT0oST1udWxsPT09KEE9dGhpcy5wZWVyQ29ubmVjdGlvbil8fHZvaWQgMD09PUE/dm9pZCAwOkEuc2N0cCl8fHZvaWQgMD09PUk/dm9pZCAwOkkubWF4TWVzc2FnZVNpemUpJiZ2b2lkIDAhPT1nP2c6MjYyMTQ0fWdldFN0YXRzKCl7cmV0dXJuIEIodGhpcyx2b2lkIDAsdm9pZCAwLChmdW5jdGlvbiooKXtpZighdGhpcy5wZWVyQ29ubmVjdGlvbil0aHJvdyBuZXcgUS5SYWlud2F5RXJyb3IoXCJnZXRTdGF0cygpIGJ1dCBubyBwZWVyQ29ubmVjdGlvblwiKTtjb25zdCBBPXlpZWxkIHRoaXMucGVlckNvbm5lY3Rpb24uZ2V0U3RhdHModm9pZCAwKSxJPXtjaGFubmVsczp7fSxyYXc6QX07cmV0dXJuIEEuZm9yRWFjaCgoQT0+e1wiZGF0YS1jaGFubmVsXCI9PT1BLnR5cGUmJihJLmNoYW5uZWxzW0EubGFiZWxdPUEpfSkpLEl9KSl9Y2hlY2tIZWFkZXIoQSl7aWYoMjAzNjQzMDY3NCE9PUEubWFnaWNOdW1iZXIpdGhyb3cgbmV3IFEuUmFpbndheUVycm9yKFwiSW52YWxpZCBtYWdpY051bWJlciBpbiBjaGVja0hlYWRlci5cIik7aWYoQS50YXJnZXRQZWVySWQhPT10aGlzLm93blBlZXJJZCl0aHJvdyBuZXcgUS5SYWlud2F5RXJyb3IoXCJJbnZhbGlkIGRlc3RpbmF0aW9uIGhvc3QgbmFtZSAobm90IG91cnMpIGluIGNoZWNrSGVhZGVyLlwiKX1oYW5kbGVMYWJlbEFuZERhdGEoQSxJKXtpZihcIlJXX0xvZ2ljXCI9PT1BKXtjb25zdCBBPW8uTG9naWNEYXRhZ3JhbS5kZWNvZGUoSSk7dGhpcy5jaGVja0hlYWRlcihBLmhlYWRlciksdGhpcy5vblJhaW53YXlNZXNzYWdlKHtraW5kOlwiTG9naWNcIixib2R5OkEuYm9keX0pfWVsc2UgaWYoXCJSV19JbnB1dFwiPT09QSl7Y29uc3QgQT1vLklucHV0RGF0YWdyYW0uZGVjb2RlKEkpO3RoaXMuY2hlY2tIZWFkZXIoQS5oZWFkZXIpLHRoaXMub25SYWlud2F5TWVzc2FnZSh7a2luZDpcIklucHV0XCIsYm9keTpBLmJvZHl9KX1lbHNlIGlmKFwiUldfQXVkaW9cIj09PUF8fFwiUldfVmlkZW9cIj09QSl7Y29uc3QgZz1vLk1lZGlhRGF0YWdyYW0uZGVjb2RlKEkpO3RoaXMuY2hlY2tIZWFkZXIoZy5oZWFkZXIpLGcuYm9keS5kaXNjcmltaW5hdG9yPT09by5NZWRpYUNodW5rLmRpc2NyaW1pbmF0b3I/dGhpcy5oYW5kbGVDaHVuayhBLGcuYm9keS52YWx1ZS5jaHVuayk6dGhpcy5vblJhaW53YXlNZXNzYWdlKHtraW5kOlwiTWVkaWFcIixib2R5OmcuYm9keX0pfWVsc2UgaWYoL15SV18vLnRlc3QoQSkpRS5SYWlud2F5TG9nZ2luZy53YXJuaW5nKGBVbmtub3duIFJhaW53YXktcmVzZXJ2ZWQgUlRDIGxhYmVsPyAke0F9YCk7ZWxzZXtjb25zdCBnPW8uQXJiaXRyYXJ5RGF0YWdyYW0uZGVjb2RlKEkpO3RoaXMuY2hlY2tIZWFkZXIoZy5oZWFkZXIpLHRoaXMuaGFuZGxlQ2h1bmsoQSxnLmJvZHkpfX1nZXREYXRhZ3JhbUhlYWRlcihBKXtyZXR1cm57bWFnaWNOdW1iZXI6MjAzNjQzMDY3NCxzeW5jS2V5OkE/Kyt0aGlzLnN5bmNLZXk6MCxzb3VyY2VQZWVySWQ6dGhpcy5vd25QZWVySWQsdGFyZ2V0UGVlcklkOnRoaXMudGFyZ2V0UGVlcklkfX1zZW5kQXJiaXRyYXJ5RGF0YWdyYW0oQSxJKXthLmVhY2hDaHVuayhJLChJPT57dGhpcy5zZW5kTWVzc2FnZShBLG8uQXJiaXRyYXJ5RGF0YWdyYW0uZW5jb2RlKHtoZWFkZXI6dGhpcy5nZXREYXRhZ3JhbUhlYWRlcighMCksYm9keTpJfSkpfSkpfXNlbmRMb2dpY0RhdGFncmFtKEEpe3RoaXMuc2VuZE1lc3NhZ2UoXCJSV19Mb2dpY1wiLG8uTG9naWNEYXRhZ3JhbS5lbmNvZGUoe2hlYWRlcjp0aGlzLmdldERhdGFncmFtSGVhZGVyKCEwKSxib2R5OkF9KSl9c2VuZElucHV0RGF0YWdyYW0oQSl7dGhpcy5zZW5kTWVzc2FnZShcIlJXX0lucHV0XCIsby5JbnB1dERhdGFncmFtLmVuY29kZSh7aGVhZGVyOnRoaXMuZ2V0RGF0YWdyYW1IZWFkZXIoITEpLGJvZHk6QX0pKX1vcGVuKEEpe3JldHVybiBCKHRoaXMsdm9pZCAwLHZvaWQgMCwoZnVuY3Rpb24qKCl7eWllbGQgbmV3IFByb21pc2UoKChJLGcpPT5CKHRoaXMsdm9pZCAwLHZvaWQgMCwoZnVuY3Rpb24qKCl7dmFyIEI7dGhpcy5vcGVuUmVzb2x2ZT1JLHRoaXMub3BlblJlamVjdD1nLGkodGhpcyxlLEMuUmFpbndheVRyYW5zcG9ydFN0YXR1cy5Db25uZWN0aW5nKSx0aGlzLnBlZXJDb25uZWN0aW9uPW5ldyBSVENQZWVyQ29ubmVjdGlvbih0aGlzLnJ0Y0NvbmZpZ3VyYXRpb24pLHRoaXMucGVlckNvbm5lY3Rpb24uYWRkRXZlbnRMaXN0ZW5lcihcImljZWNvbm5lY3Rpb25zdGF0ZWNoYW5nZVwiLHRoaXMuaGFuZGxlSWNlQ29ubmVjdGlvblN0YXRlQ2hhbmdlKSx0aGlzLnBlZXJDb25uZWN0aW9uLmFkZEV2ZW50TGlzdGVuZXIoXCJjb25uZWN0aW9uc3RhdGVjaGFuZ2VcIix0aGlzLmhhbmRsZUNvbm5lY3Rpb25TdGF0ZUNoYW5nZSksdGhpcy5oYW5kbGVDb25uZWN0aW9uU3RhdGVDaGFuZ2UoKSxudWxsIT09KEI9dGhpcy5kYXRhQ2hhbm5lbHMpJiZ2b2lkIDAhPT1CfHwodGhpcy5kYXRhQ2hhbm5lbHM9e30pO2NvbnN0IHQ9T2JqZWN0LmtleXModGhpcy5kYXRhQ2hhbm5lbHNDb25maWcpLmxlbmd0aDtsZXQgUT0wO2NvbnN0IEU9KEEsZyk9Pntjb25zdCBCPSgpPT57dmFyIEE7KytRLFE9PT10JiYobnVsbD09PShBPXRoaXMucGVlckNvbm5lY3Rpb24pfHx2b2lkIDA9PT1BfHxBLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJpY2VjYW5kaWRhdGVcIix0aGlzLmhhbmRsZUxvY2FsSWNlQ2FuZGlkYXRlKSxpKHRoaXMsZSxDLlJhaW53YXlUcmFuc3BvcnRTdGF0dXMuQ29ubmVjdGVkKSxJKCkpLGcucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm9wZW5cIixCKX07Zy5hZGRFdmVudExpc3RlbmVyKFwib3BlblwiLEIpLGcuYWRkRXZlbnRMaXN0ZW5lcihcImNsb3NlXCIsdGhpcy5oYW5kbGVEYXRhQ2hhbm5lbENsb3NlKSxnLmFkZEV2ZW50TGlzdGVuZXIoXCJlcnJvclwiLHRoaXMuaGFuZGxlRGF0YUNoYW5uZWxFcnJvciksZy5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLHRoaXMuaGFuZGxlRGF0YUNoYW5uZWxNZXNzYWdlKX07aWYoXCJvZmZlclwiPT09QSlmb3IoY29uc3RbQSxJXW9mIE9iamVjdC5lbnRyaWVzKHRoaXMuZGF0YUNoYW5uZWxzQ29uZmlnKSl7Y29uc3QgZz10aGlzLnBlZXJDb25uZWN0aW9uLmNyZWF0ZURhdGFDaGFubmVsKEEsSSk7dGhpcy5kYXRhQ2hhbm5lbHNbQV09ZyxnLmJpbmFyeVR5cGU9XCJhcnJheWJ1ZmZlclwiLEUoMCxnKX1lbHNlIHRoaXMucGVlckNvbm5lY3Rpb24uYWRkRXZlbnRMaXN0ZW5lcihcImRhdGFjaGFubmVsXCIsKEE9Pnt2YXIgSTtjb25zdCBnPUEuY2hhbm5lbC5sYWJlbDtudWxsIT09KEk9dGhpcy5kYXRhQ2hhbm5lbHMpJiZ2b2lkIDAhPT1JfHwodGhpcy5kYXRhQ2hhbm5lbHM9e30pLHRoaXMuZGF0YUNoYW5uZWxzW2ddPUEuY2hhbm5lbCxFKEEuY2hhbm5lbC5sYWJlbCxBLmNoYW5uZWwpfSkpO3RoaXMucGVlckNvbm5lY3Rpb24uYWRkRXZlbnRMaXN0ZW5lcihcImljZWNhbmRpZGF0ZVwiLHRoaXMuaGFuZGxlTG9jYWxJY2VDYW5kaWRhdGUpLFwib2ZmZXJcIj09PUEmJih5aWVsZCB0aGlzLnNlbmRPZmZlcigpKX0pKSkpfSkpfXNlbmRPZmZlcigpe3JldHVybiBCKHRoaXMsdm9pZCAwLHZvaWQgMCwoZnVuY3Rpb24qKCl7aWYodm9pZCAwPT09dGhpcy5wZWVyQ29ubmVjdGlvbil0aHJvdyBuZXcgUS5SYWlud2F5RXJyb3IoXCJzZW5kT2ZmZXIoKTogbm8gcGVlciBjb25uZWN0aW9uXCIpO2NvbnN0IEE9eWllbGQgdGhpcy5wZWVyQ29ubmVjdGlvbi5jcmVhdGVPZmZlcigpO2lmKHlpZWxkIHRoaXMucGVlckNvbm5lY3Rpb24uc2V0TG9jYWxEZXNjcmlwdGlvbihBKSwhQS5zZHApdGhyb3cgbmV3IFEuUmFpbndheUVycm9yKFwiQ3JlYXRlZCBvZmZlciBjb250YWluZWQgbm8gc2RwP1wiKTt0aGlzLnNlbmRMb2NhbE9mZmVyU2RwKEEuc2RwKX0pKX1zZW5kQW5zd2VyKCl7cmV0dXJuIEIodGhpcyx2b2lkIDAsdm9pZCAwLChmdW5jdGlvbiooKXtpZih2b2lkIDA9PT10aGlzLnBlZXJDb25uZWN0aW9uKXRocm93IG5ldyBRLlJhaW53YXlFcnJvcihcInNlbmRPZmZlcigpOiBubyBwZWVyIGNvbm5lY3Rpb25cIik7Y29uc3QgQT15aWVsZCB0aGlzLnBlZXJDb25uZWN0aW9uLmNyZWF0ZUFuc3dlcigpO2lmKHlpZWxkIHRoaXMucGVlckNvbm5lY3Rpb24uc2V0TG9jYWxEZXNjcmlwdGlvbihBKSwhQS5zZHApdGhyb3cgbmV3IFEuUmFpbndheUVycm9yKFwiQ3JlYXRlZCBhbnN3ZXIgY29udGFpbmVkIG5vIHNkcD9cIik7dGhpcy5zZW5kTG9jYWxBbnN3ZXJTZHAoQS5zZHApfSkpfWNsb3NlKCl7dmFyIEE7dGhpcy5zdGF0dXMhPT1DLlJhaW53YXlUcmFuc3BvcnRTdGF0dXMuRGlzY29ubmVjdGVkJiYoRS5SYWlud2F5TG9nZ2luZy5kZWJ1ZyhcInJ0Yy10cmFuc3BvcnQgY2xvc2UoKS5cIiksbnVsbD09PShBPXRoaXMucGVlckNvbm5lY3Rpb24pfHx2b2lkIDA9PT1BfHxBLmNsb3NlKCksdGhpcy5vbkNsb3NlKCksdGhpcy5kaXNwb3NlKCkpfWRpc3Bvc2UoKXt2YXIgQSxJLGc7aWYobnVsbD09PShBPXRoaXMucGVlckNvbm5lY3Rpb24pfHx2b2lkIDA9PT1BfHxBLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJpY2Vjb25uZWN0aW9uc3RhdGVjaGFuZ2VcIix0aGlzLmhhbmRsZUljZUNvbm5lY3Rpb25TdGF0ZUNoYW5nZSksbnVsbD09PShJPXRoaXMucGVlckNvbm5lY3Rpb24pfHx2b2lkIDA9PT1JfHxJLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjb25uZWN0aW9uc3RhdGVjaGFuZ2VcIix0aGlzLmhhbmRsZUNvbm5lY3Rpb25TdGF0ZUNoYW5nZSksbnVsbD09PShnPXRoaXMucGVlckNvbm5lY3Rpb24pfHx2b2lkIDA9PT1nfHxnLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJpY2VjYW5kaWRhdGVcIix0aGlzLmhhbmRsZUxvY2FsSWNlQ2FuZGlkYXRlKSx0aGlzLmRhdGFDaGFubmVscylmb3IoY29uc3QgQSBvZiBPYmplY3QudmFsdWVzKHRoaXMuZGF0YUNoYW5uZWxzKSlBLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsdGhpcy5oYW5kbGVEYXRhQ2hhbm5lbE1lc3NhZ2UpO3RoaXMuZGF0YUNoYW5uZWxzPXZvaWQgMCx0aGlzLnBlZXJDb25uZWN0aW9uPXZvaWQgMCx0aGlzLm9wZW5SZXNvbHZlPXZvaWQgMCx0aGlzLm9wZW5SZWplY3Q9dm9pZCAwfWhhbmRsZUNodW5rKEEsSSl7SS5ncm91cElkPHRoaXMuaGlnaGVzdENodW5rR3JvdXAmJih0aGlzLmNodW5rZWRNZXNzYWdlcz1uZXcgTWFwLHRoaXMuaGlnaGVzdENodW5rR3JvdXA9MCk7bGV0IGc9dGhpcy5jaHVua2VkTWVzc2FnZXMuZ2V0KEkuZ3JvdXBJZCk7aWYoZ3x8KGc9e3JlY2VpdmVkQ2h1bmtDb3VudDowLGNodW5rczpbXX0sdGhpcy5jaHVua2VkTWVzc2FnZXMuc2V0KEkuZ3JvdXBJZCxnKSksZy5jaHVua3NbSS5pbmRleF09SS5kYXRhLGcucmVjZWl2ZWRDaHVua0NvdW50KyssZy5yZWNlaXZlZENodW5rQ291bnQ9PT1JLmNodW5rc0luR3JvdXApe3RoaXMuaGlnaGVzdENodW5rR3JvdXA9SS5ncm91cElkLHRoaXMuY2h1bmtlZE1lc3NhZ2VzLmRlbGV0ZShJLmdyb3VwSWQpO2NvbnN0IGU9YS5yZWFzc2VtYmxlKGcpOy9eUldfKExvZ2ljfElucHV0fEF1ZGlvfFZpZGVvKSQvLnRlc3QoQSk/dGhpcy5oYW5kbGVMYWJlbEFuZERhdGEoQSxlKTp0aGlzLm9uQXBwbGljYXRpb25NZXNzYWdlKEEsZSl9fX1JLlJUQ1RyYW5zcG9ydD1kLGU9bmV3IFdlYWtNYXB9LDk6KEEsSSk9PntcInVzZSBzdHJpY3RcIjt2YXIgZztPYmplY3QuZGVmaW5lUHJvcGVydHkoSSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxJLlJhaW53YXlUcmFuc3BvcnQ9SS5SYWlud2F5VHJhbnNwb3J0U3RhdHVzPXZvaWQgMCwoZz1JLlJhaW53YXlUcmFuc3BvcnRTdGF0dXN8fChJLlJhaW53YXlUcmFuc3BvcnRTdGF0dXM9e30pKVtnLkRpc2Nvbm5lY3RlZD0wXT1cIkRpc2Nvbm5lY3RlZFwiLGdbZy5Db25uZWN0aW5nPTFdPVwiQ29ubmVjdGluZ1wiLGdbZy5Db25uZWN0ZWQ9Ml09XCJDb25uZWN0ZWRcIixJLlJhaW53YXlUcmFuc3BvcnQ9Y2xhc3N7fX0sNDIwOmZ1bmN0aW9uKEEsSSxnKXtcInVzZSBzdHJpY3RcIjt2YXIgZSxCLGksdCxRPXRoaXMmJnRoaXMuX19hd2FpdGVyfHxmdW5jdGlvbihBLEksZyxlKXtyZXR1cm4gbmV3KGd8fChnPVByb21pc2UpKSgoZnVuY3Rpb24oQixpKXtmdW5jdGlvbiB0KEEpe3RyeXtDKGUubmV4dChBKSl9Y2F0Y2goQSl7aShBKX19ZnVuY3Rpb24gUShBKXt0cnl7QyhlLnRocm93KEEpKX1jYXRjaChBKXtpKEEpfX1mdW5jdGlvbiBDKEEpe3ZhciBJO0EuZG9uZT9CKEEudmFsdWUpOihJPUEudmFsdWUsSSBpbnN0YW5jZW9mIGc/STpuZXcgZygoZnVuY3Rpb24oQSl7QShJKX0pKSkudGhlbih0LFEpfUMoKGU9ZS5hcHBseShBLEl8fFtdKSkubmV4dCgpKX0pKX0sQz10aGlzJiZ0aGlzLl9fY2xhc3NQcml2YXRlRmllbGRTZXR8fGZ1bmN0aW9uKEEsSSxnKXtpZighSS5oYXMoQSkpdGhyb3cgbmV3IFR5cGVFcnJvcihcImF0dGVtcHRlZCB0byBzZXQgcHJpdmF0ZSBmaWVsZCBvbiBub24taW5zdGFuY2VcIik7cmV0dXJuIEkuc2V0KEEsZyksZ30sRT10aGlzJiZ0aGlzLl9fY2xhc3NQcml2YXRlRmllbGRHZXR8fGZ1bmN0aW9uKEEsSSl7aWYoIUkuaGFzKEEpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJhdHRlbXB0ZWQgdG8gZ2V0IHByaXZhdGUgZmllbGQgb24gbm9uLWluc3RhbmNlXCIpO3JldHVybiBJLmdldChBKX07T2JqZWN0LmRlZmluZVByb3BlcnR5KEksXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksSS5SYWlud2F5UGVlcj1JLlJhaW53YXlDaGFubmVsTW9kZT12b2lkIDA7Y29uc3Qgbz1nKDkwNCksYT1nKDgyNCksbj1nKDQ2NCkscz1nKDUxNCkscj1nKDc4MyksZD1nKDg3NiksaD1nKDk5NCk7dmFyIGM7KGM9SS5SYWlud2F5Q2hhbm5lbE1vZGV8fChJLlJhaW53YXlDaGFubmVsTW9kZT17fSkpW2MuVW5yZWxpYWJsZT0wXT1cIlVucmVsaWFibGVcIixjW2MuUmVsaWFibGU9MV09XCJSZWxpYWJsZVwiO2NsYXNzIER7Y29uc3RydWN0b3IoQSxJLGcsUSxFLG8sYSl7dGhpcy50cmFuc3BvcnQ9Zyx0aGlzLm91dGVyT25DbG9zZT1RLHRoaXMub25FcnJvcj1FLHRoaXMub25TdHJlYW1Bbm5vdW5jZW1lbnQ9byx0aGlzLm9uU3RyZWFtU3RvcD1hLGUuc2V0KHRoaXMsci5SYWlud2F5UGVlclN0YXRlLk5ldyksQi5zZXQodGhpcyxuZXcgTWFwKSxpLnNldCh0aGlzLHZvaWQgMCksdC5zZXQodGhpcyx2b2lkIDApLHRoaXMubGFzdFRpbWVzdGFtcD12b2lkIDAsQyh0aGlzLGksQSksQyh0aGlzLHQsSSksZy5vblJhaW53YXlNZXNzYWdlPXRoaXMub25NZXNzYWdlLmJpbmQodGhpcyksZy5vbkNsb3NlPXRoaXMub25DbG9zZS5iaW5kKHRoaXMpLHRoaXMucmVhZHlUb1N0cmVhbT1uZXcgUHJvbWlzZSgoKEEsSSk9Pnt0aGlzLnJlc29sdmVSZWFkeVRvU3RyZWFtPUF9KSl9Z2V0IHN0YXRlKCl7cmV0dXJuIEUodGhpcyxlKX1nZXQgZGlzY29ubmVjdGVkKCl7cmV0dXJuIHRoaXMuc3RhdGU9PT1yLlJhaW53YXlQZWVyU3RhdGUuRGlzY29ubmVjdGVkfHx0aGlzLnN0YXRlPT09ci5SYWlud2F5UGVlclN0YXRlLkZhaWxlZH1nZXQgc3RyZWFtKCl7Y29uc3QgQT1bLi4uRSh0aGlzLEIpLmVudHJpZXMoKV07aWYoMCE9PUEubGVuZ3RoKXJldHVybiBBLnNvcnQoKChBLEkpPT5BWzBdLUlbMF0pKSxBWzBdWzFdfWdldCBzdHJlYW1zKCl7cmV0dXJuIEUodGhpcyxCKX1nZXQgcGVlcklkKCl7cmV0dXJuIEUodGhpcyxpKX1nZXQgZXh0ZXJuYWxJZCgpe3JldHVybiBFKHRoaXMsdCl9b25DbG9zZSgpe3RoaXMub25QZWVyU3RhdGVDaGFuZ2Uoci5SYWlud2F5UGVlclN0YXRlLkZhaWxlZCl9b25QZWVyU3RhdGVDaGFuZ2UoQSl7Qyh0aGlzLGUsQSksQT09PXIuUmFpbndheVBlZXJTdGF0ZS5GYWlsZWQmJih0aGlzLmRpc3Bvc2UoKSx0aGlzLm91dGVyT25DbG9zZSgpKX1zZW5kRGV2aWNlSW5mb0FuZEV4Y2hhbmdlQ29kZWNzKCl7aWYodGhpcy5kaXNjb25uZWN0ZWQpdGhyb3cgbmV3IGguUmFpbndheUVycm9yKFwiQ291bGRuJ3Qgc2VuZCBkZXZpY2UgaW5mbyBhbmQgZXhjaGFuZ2UgY29kZWNzOiBwZWVyIGlzIGRpc2Nvbm5lY3RlZFwiKTt0aGlzLnNlbmREZXZpY2VJbmZvKCksdGhpcy5leGNoYW5nZUNvZGVjcygpLnRoZW4oKEE9Pnt2YXIgSSxnOzA9PT1BLmxlbmd0aD9udWxsPT09KEk9dGhpcy5yZXNvbHZlUmVhZHlUb1N0cmVhbSl8fHZvaWQgMD09PUl8fEkuY2FsbCh0aGlzLCExKToodGhpcy50cmFuc3BvcnQuc2VuZExvZ2ljRGF0YWdyYW0oe2Rpc2NyaW1pbmF0b3I6by5DbGllbnRDYXBhYmlsaXRpZXMuZGlzY3JpbWluYXRvcix2YWx1ZTpzLm1ha2VDbGllbnRDYXBhYmlsaXRpZXMoQSl9KSxudWxsPT09KGc9dGhpcy5yZXNvbHZlUmVhZHlUb1N0cmVhbSl8fHZvaWQgMD09PWd8fGcuY2FsbCh0aGlzLCEwKSl9KSl9b25NZXNzYWdlKEEpe1wiTG9naWNcIj09PUEua2luZD90aGlzLmhhbmRsZUxvZ2ljTWVzc2FnZShBLmJvZHkpOlwiSW5wdXRcIj09PUEua2luZD90aGlzLmhhbmRsZUlucHV0TWVzc2FnZShBLmJvZHkpOlwiTWVkaWFcIj09PUEua2luZCYmdGhpcy5oYW5kbGVNZWRpYU1lc3NhZ2UoQS5ib2R5KX1zZW5kRGV2aWNlSW5mbygpe2lmKHRoaXMuZGlzY29ubmVjdGVkKXRocm93IG5ldyBoLlJhaW53YXlFcnJvcihcIkNvdWxkbid0IHNlbmQgZGV2aWNlIGluZm86IHBlZXIgaXMgZGlzY29ubmVjdGVkXCIpO3RoaXMudHJhbnNwb3J0LnNlbmRMb2dpY0RhdGFncmFtKHtkaXNjcmltaW5hdG9yOm8uRGV2aWNlSW5mby5kaXNjcmltaW5hdG9yLHZhbHVlOntpc1dlYjohMCxmb3JtRmFjdG9yOm8uRm9ybUZhY3Rvci5Db21wdXRlcixkZXZpY2VOYW1lOlwiZGV2aWNlTmFtZVwiLGRldmljZUlkOlwiZGV2aWNlSWRcIixkZXZpY2VNb2RlbDpcIlwiLGRldmljZU9zOm8uT3BlcmF0aW5nU3lzdGVtLk90aGVyLGRldmljZU9zVmVyc2lvbjpcIlwiLHVzZXJBZ2VudDpuYXZpZ2F0b3IudXNlckFnZW50fX0pfXNlbmQoQSxJKXtpZihBLnN0YXJ0c1dpdGgoXCJSV19cIikpdGhyb3cgbmV3IGguUmFpbndheUVycm9yKFwiRGF0YSBjaGFubmVsIG5hbWVzIHN0YXJ0aW5nIHdpdGggUldfIGFyZSByZXNlcnZlZCBmb3IgUmFpbndheVwiKTtpZih0aGlzLmRpc2Nvbm5lY3RlZCl0aHJvdyBuZXcgaC5SYWlud2F5RXJyb3IoXCJDb3VsZG4ndCBzZW5kIG1lc3NhZ2U6IHBlZXIgaXMgZGlzY29ubmVjdGVkXCIpO2NvbnN0IGc9XCJzdHJpbmdcIj09dHlwZW9mIEk/RC50ZXh0RW5jb2Rlci5lbmNvZGUoSSk6STt0aGlzLnRyYW5zcG9ydC5zZW5kQXJiaXRyYXJ5RGF0YWdyYW0oQSxnKX1kaXNjb25uZWN0KCl7dGhpcy5kaXNwb3NlKCksdGhpcy50cmFuc3BvcnQuY2xvc2UoKX1kaXNwb3NlKCl7Zm9yKGNvbnN0IEEgb2YgRSh0aGlzLEIpLnZhbHVlcygpKUEubGVhdmUoKTtFKHRoaXMsQikuY2xlYXIoKX1yZXF1ZXN0U3RyZWFtKEEpe3JldHVybiBRKHRoaXMsdm9pZCAwLHZvaWQgMCwoZnVuY3Rpb24qKCl7aWYodGhpcy5kaXNjb25uZWN0ZWQpdGhyb3cgbmV3IGguUmFpbndheUVycm9yKFwiQ291bGRuJ3QgcmVxdWVzdCBzdHJlYW06IHBlZXIgaXMgZGlzY29ubmVjdGVkXCIpO3JldHVybiB5aWVsZCB0aGlzLnJlYWR5VG9TdHJlYW0sdGhpcy50cmFuc3BvcnQuc2VuZExvZ2ljRGF0YWdyYW0oe2Rpc2NyaW1pbmF0b3I6by5TdHJlYW1SZXF1ZXN0LmRpc2NyaW1pbmF0b3IsdmFsdWU6e2lucHV0TGV2ZWw6QX19KSxuZXcgUHJvbWlzZSgoKEEsSSk9Pnt0aGlzLnJlc29sdmVTdHJlYW09QSx0aGlzLnJlamVjdFN0cmVhbT1JfSkpfSkpfWhhbmRsZUxvZ2ljTWVzc2FnZShBKXt2YXIgSTtyZXR1cm4gUSh0aGlzLHZvaWQgMCx2b2lkIDAsKGZ1bmN0aW9uKigpe2lmKEEuZGlzY3JpbWluYXRvcj09PW8uRGV2aWNlSW5mby5kaXNjcmltaW5hdG9yKW4uUmFpbndheUxvZ2dpbmcuZGVidWcoXCJHb3QgcmVtb3RlIERldmljZUluZm86XFxuXCIrSlNPTi5zdHJpbmdpZnkoQS52YWx1ZSkpO2Vsc2UgaWYoQS5kaXNjcmltaW5hdG9yPT09by5Db2RlY1BhY2tSZXF1ZXN0LmRpc2NyaW1pbmF0b3IpdGhpcy50cmFuc3BvcnQuc2VuZExvZ2ljRGF0YWdyYW0oe2Rpc2NyaW1pbmF0b3I6by5Db2RlY1BhY2tSZXNwb25zZS5kaXNjcmltaW5hdG9yLHZhbHVlOnt2aWRlb0NvZGVjczpbXX19KTtlbHNlIGlmKEEuZGlzY3JpbWluYXRvcj09PW8uQ29kZWNQYWNrUmVzcG9uc2UuZGlzY3JpbWluYXRvciludWxsPT09KEk9dGhpcy5jb2RlY3NSZXNvbHZlKXx8dm9pZCAwPT09SXx8SS5jYWxsKHRoaXMsQS52YWx1ZS52aWRlb0NvZGVjcyk7ZWxzZSBpZihBLmRpc2NyaW1pbmF0b3I9PT1vLkNsaWVudENhcGFiaWxpdGllcy5kaXNjcmltaW5hdG9yKW4uUmFpbndheUxvZ2dpbmcuZGVidWcoXCJHb3QgcmVtb3RlIENsaWVudENhcGFiaWxpdGllczpcXG5cIitKU09OLnN0cmluZ2lmeShBLnZhbHVlKSk7ZWxzZSBpZihBLmRpc2NyaW1pbmF0b3I9PT1vLlN0cmVhbVJlcXVlc3QuZGlzY3JpbWluYXRvciluLlJhaW53YXlMb2dnaW5nLndhcm5pbmcoXCJHb3QgcmVtb3RlIFN0cmVhbVJlcXVlc3Q/XFxuXCIrSlNPTi5zdHJpbmdpZnkoQS52YWx1ZSkpO2Vsc2UgaWYoQS5kaXNjcmltaW5hdG9yPT09by5TdHJlYW1TdGFydGluZy5kaXNjcmltaW5hdG9yKWlmKHZvaWQgMD09PXRoaXMucmVzb2x2ZVN0cmVhbSl0aGlzLm9uU3RyZWFtQW5ub3VuY2VtZW50KHtpbmZvOkEudmFsdWUsam9pbjooKT0+USh0aGlzLHZvaWQgMCx2b2lkIDAsKGZ1bmN0aW9uKigpe2NvbnN0IEk9eWllbGQgdGhpcy5jcmVhdGVTdHJlYW0oQS52YWx1ZSk7cmV0dXJuIEUodGhpcyxCKS5zZXQoSS5zdHJlYW1JZCxJKSx0aGlzLnRyYW5zcG9ydC5zZW5kTG9naWNEYXRhZ3JhbSh7ZGlzY3JpbWluYXRvcjpvLkpvaW5TdHJlYW0uZGlzY3JpbWluYXRvcix2YWx1ZTp7c3RyZWFtSWQ6QS52YWx1ZS5zdHJlYW1JZH19KSxJfSkpfSk7ZWxzZXtjb25zdCBJPXlpZWxkIHRoaXMuY3JlYXRlU3RyZWFtKEEudmFsdWUpO0UodGhpcyxCKS5zZXQoSS5zdHJlYW1JZCxJKSx0aGlzLnRyYW5zcG9ydC5zZW5kTG9naWNEYXRhZ3JhbSh7ZGlzY3JpbWluYXRvcjpvLkpvaW5TdHJlYW0uZGlzY3JpbWluYXRvcix2YWx1ZTp7c3RyZWFtSWQ6QS52YWx1ZS5zdHJlYW1JZH19KSx0aGlzLnJlc29sdmVTdHJlYW0oSSksdGhpcy5yZXNvbHZlU3RyZWFtPXZvaWQgMCx0aGlzLnJlamVjdFN0cmVhbT12b2lkIDB9ZWxzZSBBLmRpc2NyaW1pbmF0b3I9PT1vLlJlamVjdFN0cmVhbVJlcXVlc3QuZGlzY3JpbWluYXRvcj92b2lkIDAhPT10aGlzLnJlamVjdFN0cmVhbT8odGhpcy5yZWplY3RTdHJlYW0oQS52YWx1ZS5yZWFzb24pLHRoaXMucmVzb2x2ZVN0cmVhbT12b2lkIDAsdGhpcy5yZWplY3RTdHJlYW09dm9pZCAwKTpuLlJhaW53YXlMb2dnaW5nLndhcm5pbmcoXCJHb3QgUmVqZWN0U3RyZWFtUmVxdWVzdCwgYnV0IGRpZG4ndCBhc2sgZm9yIGEgc3RyZWFtLlwiKTpBLmRpc2NyaW1pbmF0b3I9PT1vLkxlYXZlU3RyZWFtLmRpc2NyaW1pbmF0b3I/bi5SYWlud2F5TG9nZ2luZy53YXJuaW5nKFwiR290IHJlbW90ZSBMZWF2ZVN0cmVhbT9cXG5cIitKU09OLnN0cmluZ2lmeShBLnZhbHVlKSk6QS5kaXNjcmltaW5hdG9yPT09by5TdHJlYW1TdG9wcGluZy5kaXNjcmltaW5hdG9yJiYobi5SYWlud2F5TG9nZ2luZy5kZWJ1ZyhcIkdvdCByZW1vdGUgU3RyZWFtU3RvcHBpbmc6XFxuXCIrSlNPTi5zdHJpbmdpZnkoQS52YWx1ZSkpLHRoaXMuZGlzY2FyZFN0cmVhbShBLnZhbHVlLnN0cmVhbUlkKSl9KSl9Y3JlYXRlU3RyZWFtKEEpe3JldHVybiBkLlJhaW53YXlTdHJlYW0uY3JlYXRlQW5kSW5pdGlhbGl6ZSh0aGlzLEEuc3RyZWFtSWQsQS5pbnB1dExldmVsLEEuY2hvc2VuQXVkaW9Db25maWcsQS5jaG9zZW5WaWRlb0NvbmZpZyxBLmNhcHR1cmVNb2RlLChBPT50aGlzLnRyYW5zcG9ydC5zZW5kSW5wdXREYXRhZ3JhbShBKSksKEE9PnRoaXMudHJhbnNwb3J0LnNlbmRMb2dpY0RhdGFncmFtKEEpKSwoKCk9PnRoaXMudHJhbnNwb3J0LmdldFN0YXRzKCkpLCgoKT0+dGhpcy5kaXNjYXJkU3RyZWFtKEEuc3RyZWFtSWQpKSl9ZGlzY2FyZFN0cmVhbShBKXtjb25zdCBJPUUodGhpcyxCKS5nZXQoQSk7dm9pZCAwIT09SSYmdGhpcy5vblN0cmVhbVN0b3AoSSksRSh0aGlzLEIpLmRlbGV0ZShBKX1oYW5kbGVJbnB1dE1lc3NhZ2UoQSl7dmFyIEk7aWYoQS5kaXNjcmltaW5hdG9yPT09by5HYW1lcGFkUnVtYmxlLmRpc2NyaW1pbmF0b3Ipe2NvbnN0IEk9QS52YWx1ZS5sZWZ0TW90b3JTcGVlZCxnPUEudmFsdWUucmlnaHRNb3RvclNwZWVkO2EuUmFpbndheUlucHV0TWFuYWdlci52aWJyYXRlR2FtZXBhZChBLnZhbHVlLnBvcnQse2R1cmF0aW9uOjEwMCxzdGFydERlbGF5OjAsc3Ryb25nTWFnbml0dWRlOk1hdGgubWF4KEksZykvNjU1MzUsd2Vha01hZ25pdHVkZTowfSl9ZWxzZSBpZihBLmRpc2NyaW1pbmF0b3I9PT1vLlNldENsaXBib2FyZFRleHQuZGlzY3JpbWluYXRvcil7Y29uc3QgZz1BLnZhbHVlLnRleHQ7XCJmdW5jdGlvblwiPT10eXBlb2YobnVsbD09PShJPW51bGw9PT1uYXZpZ2F0b3J8fHZvaWQgMD09PW5hdmlnYXRvcj92b2lkIDA6bmF2aWdhdG9yLmNsaXBib2FyZCl8fHZvaWQgMD09PUk/dm9pZCAwOkkud3JpdGVUZXh0KSYmbmF2aWdhdG9yLmNsaXBib2FyZC53cml0ZVRleHQoZykudGhlbigoKCk9Pnt9KSl9ZWxzZSBuLlJhaW53YXlMb2dnaW5nLndhcm5pbmcoYElnbm9yaW5nIHVucmVjb2duaXplZCBJbnB1dCBkaXNjcmltaW5hdG9yICR7QS5kaXNjcmltaW5hdG9yfWApfWhhbmRsZU1lZGlhTWVzc2FnZShBKXtpZihBLmRpc2NyaW1pbmF0b3I9PT1vLlZpZGVvRGF0YS5kaXNjcmltaW5hdG9yKXtjb25zdHtkYXRhOkksc2VnbWVudFRpbWU6Zyx0eXBlOmUsZGVza3RvcFJlY3Q6aSxtYXNrOnQsc3RyZWFtSWQ6UX09QS52YWx1ZSxDPUUodGhpcyxCKS5nZXQoUSk7aWYoIUMpcmV0dXJuO2NvbnN0IGE9SS5idWZmZXIuc2xpY2UoSS5ieXRlT2Zmc2V0LEkuYnl0ZU9mZnNldCtJLmxlbmd0aCkscz0xZS00Kk51bWJlcihnKTtlPT09by5WaWRlb0RhdGFUeXBlLkZyYW1lRGlmZiYmdm9pZCAwIT09dGhpcy5sYXN0VGltZXN0YW1wJiZzLXRoaXMubGFzdFRpbWVzdGFtcDwzJiZuLlJhaW53YXlMb2dnaW5nLndhcm5pbmcoYERpZmZlcmVuY2UgYmV0d2VlbiBzdWNjZXNzaXZlIHRpbWVzdGFtcHMgd2FzICR7KHMtdGhpcy5sYXN0VGltZXN0YW1wKS50b0ZpeGVkKDEpfWApLGUhPT1vLlZpZGVvRGF0YVR5cGUuTWV0YWRhdGEmJih0aGlzLmxhc3RUaW1lc3RhbXA9cyksQy5yZW5kZXJWaWRlb0ZyYW1lKHt0aW1lc3RhbXA6cyx4OmkubGVmdCx5OmkudG9wLHdpZHRoOmkud2lkdGgsaGVpZ2h0OmkuaGVpZ2h0LG1hc2s6dH0sYSl9ZWxzZSBpZihBLmRpc2NyaW1pbmF0b3I9PT1vLlBvaW50ZXJEYXRhLmRpc2NyaW1pbmF0b3Ipe2NvbnN0IEk9RSh0aGlzLEIpLmdldChBLnZhbHVlLnN0cmVhbUlkKTtpZighSSlyZXR1cm47SS5wcm9jZXNzQ3Vyc29yKHt4OkEudmFsdWUucG9zaXRpb25YLHk6QS52YWx1ZS5wb3NpdGlvblksc3BvdFg6QS52YWx1ZS5zcG90WCxzcG90WTpBLnZhbHVlLnNwb3RZLHNoYXBlV2lkdGg6QS52YWx1ZS5zaGFwZVdpZHRoLHNoYXBlSGVpZ2h0OkEudmFsdWUuc2hhcGVIZWlnaHQsZXh0ZW50V2lkdGg6QS52YWx1ZS5tb25pdG9yV2lkdGgsZXh0ZW50SGVpZ2h0OkEudmFsdWUubW9uaXRvckhlaWdodCx2aXNpYmxlOkEudmFsdWUudmlzaWJsZSxoYXNQb2ludGVySW1hZ2U6QS52YWx1ZS5kYXRhLmxlbmd0aD4wLHBvaW50ZXJJbWFnZTpBLnZhbHVlLmRhdGF9KX1lbHNlIGlmKEEuZGlzY3JpbWluYXRvcj09PW8uQXVkaW9EYXRhLmRpc2NyaW1pbmF0b3Ipe2NvbnN0IEk9RSh0aGlzLEIpLmdldChBLnZhbHVlLnN0cmVhbUlkKTtpZighSSlyZXR1cm47Y29uc3R7ZGF0YTpnLHR5cGU6ZX09QS52YWx1ZSxpPWcuYnVmZmVyLnNsaWNlKGcuYnl0ZU9mZnNldCxnLmJ5dGVPZmZzZXQrZy5sZW5ndGgpO0kucHJvY2Vzc0F1ZGlvKGkpfX1leGNoYW5nZUNvZGVjcygpe3JldHVybiBRKHRoaXMsdm9pZCAwLHZvaWQgMCwoZnVuY3Rpb24qKCl7aWYodGhpcy5kaXNjb25uZWN0ZWQpdGhyb3cgbmV3IGguUmFpbndheUVycm9yKFwiQ291bGRuJ3QgZXhjaGFuZ2UgY29kZWNzOiBwZWVyIGlzIGRpc2Nvbm5lY3RlZFwiKTtjb25zdCBBPXlpZWxkIG5ldyBQcm9taXNlKChBPT57dGhpcy50cmFuc3BvcnQuc2VuZExvZ2ljRGF0YWdyYW0oe2Rpc2NyaW1pbmF0b3I6by5Db2RlY1BhY2tSZXF1ZXN0LmRpc2NyaW1pbmF0b3IsdmFsdWU6e319KSx0aGlzLmNvZGVjc1Jlc29sdmU9QX0pKTtyZXR1cm4gdGhpcy5jb2RlY3NSZXNvbHZlPXZvaWQgMCxBfSkpfWNyZWF0ZURhdGFDaGFubmVsKEEsSSl7aWYoQS5zdGFydHNXaXRoKFwiUldfXCIpKXRocm93IG5ldyBoLlJhaW53YXlFcnJvcihcIkRhdGEgY2hhbm5lbCBuYW1lcyBzdGFydGluZyB3aXRoIFJXXyBhcmUgcmVzZXJ2ZWQgZm9yIFJhaW53YXlcIik7cmV0dXJuIHZvaWQgMCE9PXRoaXMudHJhbnNwb3J0LmNyZWF0ZURhdGFDaGFubmVsKEEsSSl9fUkuUmFpbndheVBlZXI9RCxlPW5ldyBXZWFrTWFwLEI9bmV3IFdlYWtNYXAsaT1uZXcgV2Vha01hcCx0PW5ldyBXZWFrTWFwLEQudGV4dEVuY29kZXI9bmV3IFRleHRFbmNvZGVyfSw3ODM6ZnVuY3Rpb24oQSxJLGcpe1widXNlIHN0cmljdFwiO3ZhciBlLEIsaSx0LFEsQyxFPXRoaXMmJnRoaXMuX19hd2FpdGVyfHxmdW5jdGlvbihBLEksZyxlKXtyZXR1cm4gbmV3KGd8fChnPVByb21pc2UpKSgoZnVuY3Rpb24oQixpKXtmdW5jdGlvbiB0KEEpe3RyeXtDKGUubmV4dChBKSl9Y2F0Y2goQSl7aShBKX19ZnVuY3Rpb24gUShBKXt0cnl7QyhlLnRocm93KEEpKX1jYXRjaChBKXtpKEEpfX1mdW5jdGlvbiBDKEEpe3ZhciBJO0EuZG9uZT9CKEEudmFsdWUpOihJPUEudmFsdWUsSSBpbnN0YW5jZW9mIGc/STpuZXcgZygoZnVuY3Rpb24oQSl7QShJKX0pKSkudGhlbih0LFEpfUMoKGU9ZS5hcHBseShBLEl8fFtdKSkubmV4dCgpKX0pKX0sbz10aGlzJiZ0aGlzLl9fY2xhc3NQcml2YXRlRmllbGRTZXR8fGZ1bmN0aW9uKEEsSSxnKXtpZighSS5oYXMoQSkpdGhyb3cgbmV3IFR5cGVFcnJvcihcImF0dGVtcHRlZCB0byBzZXQgcHJpdmF0ZSBmaWVsZCBvbiBub24taW5zdGFuY2VcIik7cmV0dXJuIEkuc2V0KEEsZyksZ30sYT10aGlzJiZ0aGlzLl9fY2xhc3NQcml2YXRlRmllbGRHZXR8fGZ1bmN0aW9uKEEsSSl7aWYoIUkuaGFzKEEpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJhdHRlbXB0ZWQgdG8gZ2V0IHByaXZhdGUgZmllbGQgb24gbm9uLWluc3RhbmNlXCIpO3JldHVybiBJLmdldChBKX07T2JqZWN0LmRlZmluZVByb3BlcnR5KEksXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksSS5SYWlud2F5UnVudGltZT1JLlJhaW53YXlQZWVyU3RhdGU9dm9pZCAwO2NvbnN0IG49ZygxMDQpLHM9Zyg5OTQpLHI9Zyg0NjQpLGQ9ZygxNDUpLGg9Zyg5MDQpLGM9Zyg0MjApO3ZhciBEO251bGwhPT0oZT0oaT1EYXRhVmlldy5wcm90b3R5cGUpLnNldEJpZ1VpbnQ2NCkmJnZvaWQgMCE9PWV8fChpLnNldEJpZ1VpbnQ2ND1mdW5jdGlvbihBLEksZyl7Y29uc3QgZT1CaWdJbnQoNDI5NDk2NzI5NSksQj1OdW1iZXIoST4+QmlnSW50KDMyKSZlKSxpPU51bWJlcihJJmUpLFt0LFFdPWc/WzQsMF06WzAsNF07dGhpcy5zZXRVaW50MzIoQSt0LEIsZyksdGhpcy5zZXRVaW50MzIoQStRLGksZyl9KSxudWxsIT09KEI9KHQ9RGF0YVZpZXcucHJvdG90eXBlKS5nZXRCaWdVaW50NjQpJiZ2b2lkIDAhPT1CfHwodC5nZXRCaWdVaW50NjQ9ZnVuY3Rpb24oQSxJKXtjb25zdFtnLGVdPUk/WzQsMF06WzAsNF0sQj1CaWdJbnQodGhpcy5nZXRVaW50MzIoQStnLEkpKSxpPUJpZ0ludCh0aGlzLmdldFVpbnQzMihBK2UsSSkpO3JldHVybiBCPDxCaWdJbnQoMzIpfGl9KSxmdW5jdGlvbihBKXtBW0EuTmV3PTBdPVwiTmV3XCIsQVtBLkNvbm5lY3Rpbmc9MV09XCJDb25uZWN0aW5nXCIsQVtBLkNvbm5lY3RlZD0yXT1cIkNvbm5lY3RlZFwiLEFbQS5EaXNjb25uZWN0ZWQ9M109XCJEaXNjb25uZWN0ZWRcIixBW0EuRmFpbGVkPTRdPVwiRmFpbGVkXCJ9KEQ9SS5SYWlud2F5UGVlclN0YXRlfHwoSS5SYWlud2F5UGVlclN0YXRlPXt9KSk7Y2xhc3Mgd3tjb25zdHJ1Y3RvcihBLEkpe1Euc2V0KHRoaXMsdm9pZCAwKSxDLnNldCh0aGlzLG5ldyBNYXApLHRoaXMuY29ubmVjdGlvblRyYW5zcG9ydHM9bmV3IE1hcCx0aGlzLmRvY3VtZW50VmlzaWJpbGl0eUNoYW5nZUhhbmRsZXI9KCk9PntpZihkb2N1bWVudC5oaWRkZW4pZm9yKGNvbnN0IEEgb2YgdGhpcy5wZWVycy52YWx1ZXMoKSlmb3IoY29uc3QgSSBvZiBBLnN0cmVhbXMudmFsdWVzKCkpSS5yZWxlYXNlS2V5cygpLEkucGF1c2UoKTtlbHNlIGZvcihjb25zdCBBIG9mIHRoaXMucGVlcnMudmFsdWVzKCkpZm9yKGNvbnN0IEkgb2YgQS5zdHJlYW1zLnZhbHVlcygpKUkucGxheSgpfSx0aGlzLndpbmRvd0JsdXJIYW5kbGVyPSgpPT57Zm9yKGNvbnN0IEEgb2YgdGhpcy5wZWVycy52YWx1ZXMoKSlmb3IoY29uc3QgSSBvZiBBLnN0cmVhbXMudmFsdWVzKCkpSS5yZWxlYXNlS2V5cygpfSx0aGlzLmJlZm9yZVVubG9hZEhhbmRsZXI9QT0+e2NvbnN0IEk9bG9jYXRpb24uaGFzaDtyZXR1cm5bLi4udGhpcy5wZWVycy52YWx1ZXMoKV0uc29tZSgoQT0+QS5zdHJlYW1zLnNpemU+MCkpJiYoc2V0VGltZW91dCgoKCk9Pntsb2NhdGlvbi5oYXNoPVwiP2hqPVwiK35+KDk5OTkqTWF0aC5yYW5kb20oKSksbG9jYXRpb24uaGFzaD1JfSksMCksQS5wcmV2ZW50RGVmYXVsdCgpLEEucmV0dXJuVmFsdWU9XCJcIiksITF9LHdpbmRvdy5fX3JhaW53YXlSdW50aW1lPXRoaXMsbyh0aGlzLFEsQSksdGhpcy5jb25maWc9T2JqZWN0LmFzc2lnbih7ZXh0ZXJuYWxJZDpcIlwiLHByZXZlbnRVbmxvYWRpbmdQYWdlOiEwLGxvZ1Npbms6KCk9Pnt9fSxJKSx0aGlzLnNldExvZ1NpbmsodGhpcy5jb25maWcubG9nU2luayksdGhpcy5nYXRld2F5PW5ldyBuLkdhdGV3YXkoYSh0aGlzLFEpLHRoaXMuY29uZmlnLmFwaUtleSx0aGlzLmNvbmZpZy5leHRlcm5hbElkLChBPT50aGlzLmhhbmRsZVBlZXJJbmZvKEEpKSwoQT0+dGhpcy5jb25maWcub25Db25uZWN0aW9uUmVxdWVzdCh0aGlzLEEpKSwoKEEsSSxnKT0+dGhpcy5hZGRQZWVyKEEsSSxnLFwiYW5zd2VyXCIpKSksdGhpcy5nYXRld2F5LmNvbm5lY3Rpb25Mb3N0RXZlbnQuYWRkSGFuZGxlcigoQT0+e2EodGhpcyxDKS5jbGVhcigpLHRoaXMuY29uZmlnLm9uUnVudGltZUNvbm5lY3Rpb25Mb3N0KHRoaXMsQSl9KSl9Z2V0IHBlZXJzKCl7cmV0dXJuWy4uLmEodGhpcyxDKS52YWx1ZXMoKV19c3RhdGljIGluaXRpYWxpemUoQSl7cmV0dXJuIEUodGhpcyx2b2lkIDAsdm9pZCAwLChmdW5jdGlvbiooKXtpZih3LmluaXRpYWxpemVkKXRocm93IG5ldyBzLlJhaW53YXlFcnJvcihcIlJhaW53YXlSdW50aW1lIG1heSBvbmx5IGJlIGluaXRpYWxpemVkIG9uY2UuIERvbid0IHdvcnJ5OiB5b3UgY2FuIG1hbmFnZSBtdWx0aXBsZSBSYWlud2F5IGNvbm5lY3Rpb25zIGZyb20gYSBzaW5nbGUgUmFpbndheVJ1bnRpbWUgb2JqZWN0LlwiKTtjb25zdCBJPXlpZWxkIG4uZ2V0UGVlcklkKEEuYXBpS2V5KSxnPW5ldyB3KEksQSk7cmV0dXJuIHlpZWxkIGcuZ2F0ZXdheS5jb25uZWN0KCksd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJiZWZvcmV1bmxvYWRcIiwoQT0+Zy5iZWZvcmVVbmxvYWRIYW5kbGVyKEEpKSksd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJibHVyXCIsKEE9Pmcud2luZG93Qmx1ckhhbmRsZXIoKSkpLGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJ2aXNpYmlsaXR5Y2hhbmdlXCIsKEE9PmcuZG9jdW1lbnRWaXNpYmlsaXR5Q2hhbmdlSGFuZGxlcigpKSksdy5pbml0aWFsaXplZD0hMCxnfSkpfWdldFBlZXJJZCgpe3JldHVybiBhKHRoaXMsUSl9Y29ubmVjdChBKXtyZXR1cm4gRSh0aGlzLHZvaWQgMCx2b2lkIDAsKGZ1bmN0aW9uKigpe2lmKHlpZWxkIHRoaXMuZ2F0ZXdheS5jb25uZWN0KCksYSh0aGlzLEMpLmhhcyhBKSl0aHJvdyBuZXcgcy5SYWlud2F5RXJyb3IoYEFscmVhZHkgY29ubmVjdGVkIHRvICR7QX1gKTtjb25zdCBJPXlpZWxkIHRoaXMuZ2F0ZXdheS5jb25uZWN0VG9Ib3N0KEEsaC5QZWVyVHJhbnNwb3J0VHlwZS5TQ1RQKTtpZihJLmNhbmNlbGVkKXRocm93IG5ldyBzLlJhaW53YXlFcnJvcihcIlRoZSBjb25uZWN0aW9uIGF0dGVtcHQgd2FzIGNhbmNlbGVkLlwiKTtpZighSS5hY2NlcHRlZCl0aHJvdyBuZXcgcy5SYWlud2F5RXJyb3IoYFRoZSBwZWVyIGF0ICR7QX0gcmVqZWN0ZWQgdGhlIGNvbm5lY3Rpb24sIHdpdGggcmVhc29uOiAke0kucmVhc29ufWApO3JldHVybiB0aGlzLmFkZFBlZXIoQSxJLmhvc3RFeHRlcm5hbElkLEkuY29ubmVjdGlvblJlcXVlc3RJZCxcIm9mZmVyXCIpfSkpfWFkZFBlZXIoQSxJLGcsZSl7cmV0dXJuIEUodGhpcyx2b2lkIDAsdm9pZCAwLChmdW5jdGlvbiooKXtjb25zdCBCPW5ldyBkLlJUQ1RyYW5zcG9ydChhKHRoaXMsUSksQSwoST0+dGhpcy5nYXRld2F5LnNlbmRPZmZlcihBLEkpKSwoST0+dGhpcy5nYXRld2F5LnNlbmRBbnN3ZXIoQSxJKSksKEk9PnRoaXMuZ2F0ZXdheS5zZW5kQ2FuZGlkYXRlKEEsSSkpLChBPT57aS5vblBlZXJTdGF0ZUNoYW5nZShBKSx0aGlzLmNvbmZpZy5vblBlZXJTdGF0ZUNoYW5nZSh0aGlzLGksQSl9KSksaT1uZXcgYy5SYWlud2F5UGVlcihBLEksQiwoKCk9Pnt0aGlzLmdhdGV3YXkuZGVsZXRlQ29ubmVjdGlvbihBKSxhKHRoaXMsQykuZGVsZXRlKEEpfSksKEE9Pnt0aGlzLmNvbmZpZy5vblBlZXJFcnJvcih0aGlzLGksQSl9KSwoQT0+e3RoaXMuY29uZmlnLm9uU3RyZWFtQW5ub3VuY2VtZW50KHRoaXMsaSxBKX0pLChBPT57dGhpcy5jb25maWcub25TdHJlYW1TdG9wKHRoaXMsQSl9KSk7dGhpcy5jb25uZWN0aW9uVHJhbnNwb3J0cy5zZXQoZyxCKSxCLm9uQXBwbGljYXRpb25NZXNzYWdlPShBLEkpPT50aGlzLmNvbmZpZy5vblBlZXJNZXNzYWdlKHRoaXMsaSxBLEkpO3RyeXt5aWVsZCBCLm9wZW4oZSl9ZmluYWxseXt0aGlzLmNvbm5lY3Rpb25UcmFuc3BvcnRzLmRlbGV0ZShnKX1yZXR1cm4gaS5zZW5kRGV2aWNlSW5mb0FuZEV4Y2hhbmdlQ29kZWNzKCksYSh0aGlzLEMpLnNldChBLGkpLHRoaXMuY29uZmlnLm9uUGVlclN0YXRlQ2hhbmdlKHRoaXMsaSxELkNvbm5lY3RlZCksaX0pKX1jYW5jZWxDb25uZWN0aW9uQXR0ZW1wdChBKXt0aGlzLmdhdGV3YXkuY2FuY2VsQ29ubmVjdGlvbkF0dGVtcHQoQSl9aGFuZGxlUGVlckluZm8oQSl7Y29uc3QgST10aGlzLmNvbm5lY3Rpb25UcmFuc3BvcnRzLmdldChBLmlkKTt2b2lkIDAhPT1JP0kuaGFuZGxlUGVlckluZm8oQSk6QS50eXBlIT09aC5QZWVySW5mb3JtYXRpb25UeXBlLkNhbmRpZGF0ZSYmci5SYWlud2F5TG9nZ2luZy53YXJuaW5nKFwiR290IHBlZXIgaW5mbyBmb3IgdW5leHBlY3RlZCBDUklEPyBcIitBLmlkKX1nZXRNZWRpYUNhcGFiaWxpdGllcyhBKXtyZXR1cm4gbmF2aWdhdG9yLm1lZGlhQ2FwYWJpbGl0aWVzLmRlY29kaW5nSW5mbyhBKX1zZXRMb2dTaW5rKEEpe3IuUmFpbndheUxvZ2dpbmcuc2V0TG9nU2luayhBKX19SS5SYWlud2F5UnVudGltZT13LFE9bmV3IFdlYWtNYXAsQz1uZXcgV2Vha01hcCx3LmluaXRpYWxpemVkPSExfSw4NzY6ZnVuY3Rpb24oQSxJLGcpe1widXNlIHN0cmljdFwiO3ZhciBlLEI9dGhpcyYmdGhpcy5fX2F3YWl0ZXJ8fGZ1bmN0aW9uKEEsSSxnLGUpe3JldHVybiBuZXcoZ3x8KGc9UHJvbWlzZSkpKChmdW5jdGlvbihCLGkpe2Z1bmN0aW9uIHQoQSl7dHJ5e0MoZS5uZXh0KEEpKX1jYXRjaChBKXtpKEEpfX1mdW5jdGlvbiBRKEEpe3RyeXtDKGUudGhyb3coQSkpfWNhdGNoKEEpe2koQSl9fWZ1bmN0aW9uIEMoQSl7dmFyIEk7QS5kb25lP0IoQS52YWx1ZSk6KEk9QS52YWx1ZSxJIGluc3RhbmNlb2YgZz9JOm5ldyBnKChmdW5jdGlvbihBKXtBKEkpfSkpKS50aGVuKHQsUSl9QygoZT1lLmFwcGx5KEEsSXx8W10pKS5uZXh0KCkpfSkpfSxpPXRoaXMmJnRoaXMuX19jbGFzc1ByaXZhdGVGaWVsZEdldHx8ZnVuY3Rpb24oQSxJKXtpZighSS5oYXMoQSkpdGhyb3cgbmV3IFR5cGVFcnJvcihcImF0dGVtcHRlZCB0byBnZXQgcHJpdmF0ZSBmaWVsZCBvbiBub24taW5zdGFuY2VcIik7cmV0dXJuIEkuZ2V0KEEpfSx0PXRoaXMmJnRoaXMuX19jbGFzc1ByaXZhdGVGaWVsZFNldHx8ZnVuY3Rpb24oQSxJLGcpe2lmKCFJLmhhcyhBKSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiYXR0ZW1wdGVkIHRvIHNldCBwcml2YXRlIGZpZWxkIG9uIG5vbi1pbnN0YW5jZVwiKTtyZXR1cm4gSS5zZXQoQSxnKSxnfTtPYmplY3QuZGVmaW5lUHJvcGVydHkoSSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxJLlJhaW53YXlTdHJlYW09dm9pZCAwO2NvbnN0IFE9Zyg5OTQpLEM9Zyg5MDQpLEU9Zyg4MjQpLG89Zyg0MjUpLGE9Zyg2NDMpLG49Zyg0NjQpLHM9Zyg2OTUpLHI9Zyg1MjgpO2NsYXNzIGR7Y29uc3RydWN0b3IoQSxJLGcsQixpLHQsUSxuLGQsaCl7dGhpcy5ob3N0PUEsdGhpcy5zdHJlYW1JZD1JLHRoaXMuY2hvc2VuQXVkaW9Db25maWc9Qix0aGlzLmNob3NlblZpZGVvQ29uZmlnPWksdGhpcy5jYXB0dXJlTW9kZT10LHRoaXMuc2VuZElucHV0PVEsdGhpcy5zZW5kTG9naWM9bix0aGlzLnBlZXJEaXNjYXJkU3RyZWFtPWgsdGhpcy5yZXNpemVEZWJvdW5jZUhhbmRsZT12b2lkIDAsZS5zZXQodGhpcywhMSksdGhpcy5zZW5kS2V5ZnJhbWVSZXF1ZXN0PSgpPT57dGhpcy5zZW5kTG9naWMoe2Rpc2NyaW1pbmF0b3I6Qy5LZXlmcmFtZVJlcXVlc3QuZGlzY3JpbWluYXRvcix2YWx1ZTp7c3RyZWFtSWQ6dGhpcy5zdHJlYW1JZH19KX0sdGhpcy5mZWVkVmlkZW9TdGF0ZUludG9SYXRlQ29udHJvbGxlcj1BPT57dGhpcy5yYXRlQ29udHJvbGxlci5oYW5kbGVWaWRlb1JlYWR5U3RhdGUoQSl9LHRoaXMuc2V0UmVtb3RlQ2xpcGJvYXJkPSgpPT57dmFyIEE7XCJmdW5jdGlvblwiIT10eXBlb2YobnVsbD09PShBPW51bGw9PT1uYXZpZ2F0b3J8fHZvaWQgMD09PW5hdmlnYXRvcj92b2lkIDA6bmF2aWdhdG9yLmNsaXBib2FyZCl8fHZvaWQgMD09PUE/dm9pZCAwOkEucmVhZFRleHQpfHxyLmlzRGVza3RvcFNhZmFyaXx8bmF2aWdhdG9yLmNsaXBib2FyZC5yZWFkVGV4dCgpLnRoZW4oKEE9Pnt0aGlzLnNlbmRJbnB1dCh7ZGlzY3JpbWluYXRvcjpDLlNldENsaXBib2FyZFRleHQuZGlzY3JpbWluYXRvcix2YWx1ZTp7dGV4dDpBfX0pfSkpfTtjb25zdCBjPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7Yy50YWJJbmRleD0wLGMuc3R5bGUudG91Y2hBY3Rpb249XCJub25lXCIsYy5zdHlsZS51c2VyU2VsZWN0PVwibm9uZVwiLGMuc3R5bGUud2Via2l0VXNlclNlbGVjdD1cIm5vbmVcIixjLnN0eWxlLnBvc2l0aW9uPVwicmVsYXRpdmVcIixjLnN0eWxlLndpZHRoPVwiMTAwJVwiLGMuc3R5bGUuaGVpZ2h0PVwiMTAwJVwiLGMuY2xhc3NOYW1lPVwicmFpbndheS1pbm5lci1jb250YWluZXJcIixjLmFkZEV2ZW50TGlzdGVuZXIoXCJmb2N1c1wiLHRoaXMuc2V0UmVtb3RlQ2xpcGJvYXJkKSx0aGlzLmlubmVyQ29udGFpbmVyPWMsdGhpcy5pbnB1dE1hbmFnZXI9bmV3IEUuUmFpbndheUlucHV0TWFuYWdlcih0aGlzKSx0aGlzLm1lZGlhTWFuYWdlcj1uZXcgby5NZWRpYU1hbmFnZXIodCxpLHt2aWRlbzp7Y29kZWNTdHJpbmc6cy52aWRlb0NvZGVjTWltZVR5cGUoaS5jb2RlYyl9fSxkKSx0aGlzLnJhdGVDb250cm9sbGVyPW5ldyBhLlJhaW53YXlSYXRlQ29udHJvbGxlcih2b2lkIDAsaSwoQT0+dGhpcy5zZW5kTG9naWMoe2Rpc2NyaW1pbmF0b3I6Qy5WaWRlb0JpdHJhdGVSZXF1ZXN0LmRpc2NyaW1pbmF0b3IsdmFsdWU6e3N0cmVhbUlkOkksYml0c1BlclNlY29uZDoxZTMqQX19KSksdGhpcy5tZWRpYU1hbmFnZXIudmlkZW9QZXJmb3JtYW5jZU1vbml0b3IpLGMuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsKCgpPT57dGhpcy5yZXN1bWVBdWRpbygpfSkpLHRoaXMubWVkaWFNYW5hZ2VyLnNldENvbnRhaW5lcihjKSx0aGlzLm1lZGlhTWFuYWdlci52aWRlb05lZWRzUmVzdGFydEV2ZW50LmFkZEhhbmRsZXIodGhpcy5zZW5kS2V5ZnJhbWVSZXF1ZXN0KSx0aGlzLm1lZGlhTWFuYWdlci52aWRlb1JlYWR5U3RhdGVDaGFuZ2VFdmVudC5hZGRIYW5kbGVyKHRoaXMuZmVlZFZpZGVvU3RhdGVJbnRvUmF0ZUNvbnRyb2xsZXIpLHRoaXMuaW5wdXRNYW5hZ2VyLnNldENvbnRhaW5lcihjKSx0aGlzLmlucHV0TWFuYWdlci5zZXRJbnB1dExldmVsKGcpLHRoaXMuY29udGFpbmVyUmVzaXplT2JzZXJ2ZXI9bmV3IFJlc2l6ZU9ic2VydmVyKCgoKT0+e3RoaXMucmVzaXplRGVib3VuY2VIYW5kbGUmJndpbmRvdy5jbGVhclRpbWVvdXQodGhpcy5yZXNpemVEZWJvdW5jZUhhbmRsZSksdGhpcy5yZXNpemVEZWJvdW5jZUhhbmRsZT13aW5kb3cuc2V0VGltZW91dCgoKCk9Pnt0aGlzLnNlbmRJbnB1dCh7ZGlzY3JpbWluYXRvcjpDLlZpZXdwb3J0UmVzaXplLmRpc2NyaW1pbmF0b3IsdmFsdWU6e3dpZHRoOnRoaXMuaW5uZXJDb250YWluZXIuY2xpZW50V2lkdGgsaGVpZ2h0OnRoaXMuaW5uZXJDb250YWluZXIuY2xpZW50SGVpZ2h0fX0pLHRoaXMucmVzaXplRGVib3VuY2VIYW5kbGU9dm9pZCAwfSksMTAwKX0pKSx0aGlzLmNvbnRhaW5lclJlc2l6ZU9ic2VydmVyLm9ic2VydmUoYyksd2luZG93Ll9fcmFpbndheVN0cmVhbT10aGlzfWdldCBkZWFkKCl7cmV0dXJuIGkodGhpcyxlKX1nZXQgY29udGFpbmVyKCl7cmV0dXJuIHRoaXMuaW5uZXJDb250YWluZXJ9Z2V0IGlucHV0TGV2ZWwoKXtyZXR1cm4gdGhpcy5pbnB1dE1hbmFnZXIuZ2V0SW5wdXRMZXZlbCgpfWdldCBjdXJyZW50RnJhbWVTaXplKCl7Y29uc3R7Y29kZWM6QX09dGhpcy5jaG9zZW5WaWRlb0NvbmZpZztyZXR1cm57Y29kZWNXaWR0aDpBLndpZHRoLGNvZGVjSGVpZ2h0OkEuaGVpZ2h0LHN0cmVhbUJvdW5kczp0aGlzLm1lZGlhTWFuYWdlci5jdXJyZW50U3RyZWFtQm91bmRzLGZ1bGxEZXNrdG9wQm91bmRzOnRoaXMubWVkaWFNYW5hZ2VyLmN1cnJlbnRGdWxsRGVza3RvcEJvdW5kc319c3RhdGljIGNyZWF0ZUFuZEluaXRpYWxpemUoQSxJLGcsZSxpLHQsUSxDLEUsbyl7cmV0dXJuIEIodGhpcyx2b2lkIDAsdm9pZCAwLChmdW5jdGlvbiooKXtjb25zdCBCPW5ldyBkKEEsSSxnLGUsaSx0LFEsQyxFLG8pO3JldHVybiB5aWVsZCBCLm1lZGlhTWFuYWdlci5pbml0aWFsaXplKCksQn0pKX1wcm9jZXNzQXVkaW8oQSl7dGhpcy5tZWRpYU1hbmFnZXIucHJvY2Vzc0F1ZGlvKEEpfXByb2Nlc3NDdXJzb3IoQSl7dGhpcy5pbnB1dE1hbmFnZXIucHJvY2Vzc0N1cnNvcihBKX1yZW5kZXJWaWRlb0ZyYW1lKEEsSSl7dGhpcy5yYXRlQ29udHJvbGxlci5mZWVkRnJhbWVUaW1lc3RhbXAoQS50aW1lc3RhbXApLHRoaXMubWVkaWFNYW5hZ2VyLnJlbmRlclZpZGVvRnJhbWUoQSxJKX10cmFuc2Zvcm1Qb2ludGVyT2Zmc2V0VG9SZW1vdGUoQSxJKXtjb25zdCBnPXRoaXMubWVkaWFNYW5hZ2VyLmN1cnJlbnRTdHJlYW1Cb3VuZHM7aWYoIWcpcmV0dXJuO2NvbnN0IGU9dGhpcy5tZWRpYU1hbmFnZXIuY3VycmVudEZ1bGxEZXNrdG9wQm91bmRzO2lmKCFlKXJldHVybjtjb25zdHtsZWZ0OkIsdG9wOmksd2lkdGg6dCxoZWlnaHQ6UX09ZSx7bGVmdDpDLHRvcDpFLHdpZHRoOm8saGVpZ2h0OmF9PWcsbj10aGlzLmNob3NlblZpZGVvQ29uZmlnLmNvZGVjLndpZHRoLHM9dGhpcy5jaG9zZW5WaWRlb0NvbmZpZy5jb2RlYy5oZWlnaHQscj10aGlzLmlubmVyQ29udGFpbmVyLmNsaWVudFdpZHRoLGQ9dGhpcy5pbm5lckNvbnRhaW5lci5jbGllbnRIZWlnaHQsaD1vKm4vdCxjPWEqcy9RLEQ9TWF0aC5taW4oci9oLGQvYyk7cmV0dXJue3g6KEEtKHItRCpoKS8yKS8oRCpuL3QpK0MtQix5OihJLShkLUQqYykvMikvKEQqcy9RKStFLWl9fXJlbGVhc2VLZXlzKCl7dGhpcy5pbnB1dE1hbmFnZXIucmVsZWFzZUtleXMoKX1lbmFibGVWaWRlb1N0YXRzT3ZlcmxheSgpe3ZhciBBO251bGw9PT0oQT10aGlzLm1lZGlhTWFuYWdlcil8fHZvaWQgMD09PUF8fEEuZW5hYmxlU3RhdHNPdmVybGF5KCl9ZGlzYWJsZVZpZGVvU3RhdHNPdmVybGF5KCl7dmFyIEE7bnVsbD09PShBPXRoaXMubWVkaWFNYW5hZ2VyKXx8dm9pZCAwPT09QXx8QS5kaXNhYmxlU3RhdHNPdmVybGF5KCl9cmVxdWVzdEZ1bGxzY3JlZW4oQSl7dmFyIEksZyxlO2NvbnN0IEI9bnVsbD09PShJPW51bGw9PUE/dm9pZCAwOkEubG9ja0tleWJvYXJkKXx8dm9pZCAwPT09SXx8SSxpPW51bGw9PT0oZz1udWxsPT1BP3ZvaWQgMDpBLmxvY2tQb2ludGVyKXx8dm9pZCAwPT09Z3x8ZztpZih0aGlzLmlubmVyQ29udGFpbmVyLnJlcXVlc3RGdWxsc2NyZWVuP3RoaXMuaW5uZXJDb250YWluZXIucmVxdWVzdEZ1bGxzY3JlZW4oe25hdmlnYXRpb25VSTpcImhpZGVcIn0pOnRoaXMuaW5uZXJDb250YWluZXIud2Via2l0UmVxdWVzdEZ1bGxzY3JlZW4oe25hdmlnYXRpb25VSTpcImhpZGVcIn0pLEImJlwia2V5Ym9hcmRcImluIG5hdmlnYXRvcil0cnl7bmF2aWdhdG9yLmtleWJvYXJkLmxvY2soKX1jYXRjaChBKXt9aSYmKG51bGw9PT0oZT10aGlzLmlucHV0TWFuYWdlcil8fHZvaWQgMD09PWV8fGUubG9ja1BvaW50ZXIoKSl9cGxheSgpe2lmKGkodGhpcyxlKSl0aHJvdyBuZXcgUS5SYWlud2F5RXJyb3IoXCJBdHRlbXB0ZWQgdG8gcGxheSBhIGRlYWQgc3RyZWFtXCIpO3RoaXMubWVkaWFNYW5hZ2VyLnBsYXkoKSx0aGlzLnJhdGVDb250cm9sbGVyLnN0YXJ0KCl9cGF1c2UoKXtpZihpKHRoaXMsZSkpdGhyb3cgbmV3IFEuUmFpbndheUVycm9yKFwiQXR0ZW1wdGVkIHRvIHBhdXNlIGEgZGVhZCBzdHJlYW1cIik7dGhpcy5tZWRpYU1hbmFnZXIucGF1c2UoKSx0aGlzLnJhdGVDb250cm9sbGVyLnN0b3AoKX1sZWF2ZSgpe2kodGhpcyxlKT9uLlJhaW53YXlMb2dnaW5nLndhcm5pbmcoXCJBdHRlbXB0ZWQgdG8gbGVhdmUgYSBkZWFkIHN0cmVhbVwiKToodGhpcy5zZW5kTG9naWMoe2Rpc2NyaW1pbmF0b3I6Qy5MZWF2ZVN0cmVhbS5kaXNjcmltaW5hdG9yLHZhbHVlOntzdHJlYW1JZDp0aGlzLnN0cmVhbUlkfX0pLHRoaXMucGVlckRpc2NhcmRTdHJlYW0oKSx0aGlzLnJlc2l6ZURlYm91bmNlSGFuZGxlJiZjbGVhclRpbWVvdXQodGhpcy5yZXNpemVEZWJvdW5jZUhhbmRsZSksdGhpcy5pbm5lckNvbnRhaW5lci5yZW1vdmVFdmVudExpc3RlbmVyKFwiZm9jdXNcIix0aGlzLnNldFJlbW90ZUNsaXBib2FyZCksdGhpcy5jb250YWluZXJSZXNpemVPYnNlcnZlci5kaXNjb25uZWN0KCksdGhpcy5tZWRpYU1hbmFnZXIudmlkZW9OZWVkc1Jlc3RhcnRFdmVudC5yZW1vdmVIYW5kbGVyKHRoaXMuc2VuZEtleWZyYW1lUmVxdWVzdCksdGhpcy5tZWRpYU1hbmFnZXIudmlkZW9SZWFkeVN0YXRlQ2hhbmdlRXZlbnQucmVtb3ZlSGFuZGxlcih0aGlzLmZlZWRWaWRlb1N0YXRlSW50b1JhdGVDb250cm9sbGVyKSx0aGlzLmlucHV0TWFuYWdlci5kaXNwb3NlKCksdGhpcy5tZWRpYU1hbmFnZXIuZGlzcG9zZSgpLHRoaXMucmF0ZUNvbnRyb2xsZXIuc3RvcCgpLHQodGhpcyxlLCEwKSl9cmVzdW1lQXVkaW8oKXt2YXIgQSxJO251bGw9PT0oST1udWxsPT09KEE9dGhpcy5tZWRpYU1hbmFnZXIpfHx2b2lkIDA9PT1BP3ZvaWQgMDpBLmF1ZGlvQ29udGV4dCl8fHZvaWQgMD09PUl8fEkucmVzdW1lKCl9ZW5hYmxlR2VzdHVyZXMoKXt2YXIgQTtudWxsPT09KEE9dGhpcy5pbnB1dE1hbmFnZXIpfHx2b2lkIDA9PT1BfHxBLmVuYWJsZUdlc3R1cmVzKCl9ZGlzYWJsZUdlc3R1cmVzKCl7dmFyIEE7bnVsbD09PShBPXRoaXMuaW5wdXRNYW5hZ2VyKXx8dm9pZCAwPT09QXx8QS5kaXNhYmxlR2VzdHVyZXMoKX1zZXRTdHJlYW1GaXQoQSl7dGhpcy5tZWRpYU1hbmFnZXIuc3RyZWFtRml0PUF9c2V0T3V0Z29pbmdJbnB1dEZpbHRlcihBKXt0aGlzLmlucHV0TWFuYWdlci5vdXRnb2luZ0lucHV0RmlsdGVyPUF9fUkuUmFpbndheVN0cmVhbT1kLGU9bmV3IFdlYWtNYXB9LDk5NDooQSxJKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eShJLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLEkuUmFpbndheUVycm9yPXZvaWQgMDtjbGFzcyBnIGV4dGVuZHMgRXJyb3J7Y29uc3RydWN0b3IoQSl7c3VwZXIoYFJhaW53YXkgU0RLIEVycm9yOiAke0F9YCksdGhpcy5uYW1lPXRoaXMuY29uc3RydWN0b3IubmFtZSxcImZ1bmN0aW9uXCI9PXR5cGVvZiBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZT9FcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLHRoaXMuY29uc3RydWN0b3IpOnRoaXMuc3RhY2s9bmV3IEVycm9yKGBSYWlud2F5IFNESyBFcnJvcjogJHtBfWApLnN0YWNrLE9iamVjdC5zZXRQcm90b3R5cGVPZih0aGlzLGcucHJvdG90eXBlKX19SS5SYWlud2F5RXJyb3I9Z30sODU5OkE9PntzZWxmLEEuZXhwb3J0cz0oKCk9PntcInVzZSBzdHJpY3RcIjt2YXIgQT17MTE0OmZ1bmN0aW9uKEEsSSxnKXt2YXIgZT10aGlzJiZ0aGlzLl9faW1wb3J0RGVmYXVsdHx8ZnVuY3Rpb24oQSl7cmV0dXJuIEEmJkEuX19lc01vZHVsZT9BOntkZWZhdWx0OkF9fTtPYmplY3QuZGVmaW5lUHJvcGVydHkoSSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTtjb25zdCBCPWUoZygxNzApKTtjbGFzcyBpe2luaXRpYWxpemUoKXtyZXR1cm4gdGhpcy5pZD1pLnVuaXF1ZUlkQ291bnRlcisrLG5ldyBQcm9taXNlKCgoQSxJKT0+e3RoaXMud29ya2VyPW5ldyBCLmRlZmF1bHQsdGhpcy53b3JrZXIuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwoST0+e3ZhciBnO2NvbnN0IGU9SS5kYXRhO1wiZGVjb2RlclJlYWR5XCI9PT1lLnR5cGU/QSgwKTpcInBpY3R1cmVSZWFkeVwiPT09ZS50eXBlJiYobnVsbD09PShnPXRoaXMub25EZWNvZGUpfHx2b2lkIDA9PT1nfHxnLmNhbGwodGhpcyxlKSl9KSl9KSl9ZGVjb2RlKEEpe3RoaXMud29ya2VyJiZ0aGlzLndvcmtlci5wb3N0TWVzc2FnZSh7dHlwZTpcImRlY29kZVwiLGRhdGE6QS5idWZmZXIsb2Zmc2V0OkEuYnl0ZU9mZnNldCxsZW5ndGg6QS5ieXRlTGVuZ3RoLHJlbmRlclN0YXRlSWQ6dGhpcy5pZH0sW0EuYnVmZmVyXSl9cmVsZWFzZSgpe3RoaXMud29ya2VyJiZ0aGlzLndvcmtlci5wb3N0TWVzc2FnZSh7dHlwZTpcInJlbGVhc2VcIixyZW5kZXJTdGF0ZUlkOnRoaXMuaWR9KX1kaXNwb3NlKCl7dGhpcy53b3JrZXImJih0aGlzLndvcmtlci50ZXJtaW5hdGUoKSx0aGlzLndvcmtlcj12b2lkIDApfX1JLmRlZmF1bHQ9aSxpLnVuaXF1ZUlkQ291bnRlcj0xfSwxNzA6KEEsSSxnKT0+e2cucihJKSxnLmQoSSx7ZGVmYXVsdDooKT0+aX0pO3ZhciBlPWcoNjE0KSxCPWcubihlKTtmdW5jdGlvbiBpKCl7cmV0dXJuIEIoKSgnLyohIEZvciBsaWNlbnNlIGluZm9ybWF0aW9uIHBsZWFzZSBzZWUgaW5kZXgud29ya2VyLmpzLkxJQ0VOU0UudHh0ICovXFxuKCgpPT57dmFyIEE9ezcxOTpBPT57dmFyIEksZz0oST1cInVuZGVmaW5lZFwiIT10eXBlb2YgZG9jdW1lbnQmJmRvY3VtZW50LmN1cnJlbnRTY3JpcHQ/ZG9jdW1lbnQuY3VycmVudFNjcmlwdC5zcmM6dm9pZCAwLGZ1bmN0aW9uKEEpeyhBPUF8fHt9KXx8KEE9dm9pZCAwIT09QT9BOnt9KTt2YXIgZyxCPXt9O2ZvcihnIGluIEEpQS5oYXNPd25Qcm9wZXJ0eShnKSYmKEJbZ109QVtnXSk7dmFyIFEsQz1bXSxFPVwiXCI7RT1zZWxmLmxvY2F0aW9uLmhyZWYsSSYmKEU9SSksRT0wIT09RS5pbmRleE9mKFwiYmxvYjpcIik/RS5zdWJzdHIoMCxFLmxhc3RJbmRleE9mKFwiL1wiKSsxKTpcIlwiLFE9ZnVuY3Rpb24oQSl7dmFyIEk9bmV3IFhNTEh0dHBSZXF1ZXN0O3JldHVybiBJLm9wZW4oXCJHRVRcIixBLCExKSxJLnJlc3BvbnNlVHlwZT1cImFycmF5YnVmZmVyXCIsSS5zZW5kKG51bGwpLG5ldyBVaW50OEFycmF5KEkucmVzcG9uc2UpfTt2YXIgaSxELG89QS5wcmludHx8Y29uc29sZS5sb2cuYmluZChjb25zb2xlKSxhPUEucHJpbnRFcnJ8fGNvbnNvbGUud2Fybi5iaW5kKGNvbnNvbGUpO2ZvcihnIGluIEIpQi5oYXNPd25Qcm9wZXJ0eShnKSYmKEFbZ109QltnXSk7Qj1udWxsLEEuYXJndW1lbnRzJiYoQz1BLmFyZ3VtZW50cyksQS50aGlzUHJvZ3JhbSYmQS50aGlzUHJvZ3JhbSxBLnF1aXQmJkEucXVpdCxBLndhc21CaW5hcnkmJihpPUEud2FzbUJpbmFyeSksQS5ub0V4aXRSdW50aW1lJiZBLm5vRXhpdFJ1bnRpbWUsXCJvYmplY3RcIiE9dHlwZW9mIFdlYkFzc2VtYmx5JiZhKFwibm8gbmF0aXZlIHdhc20gc3VwcG9ydCBkZXRlY3RlZFwiKTt2YXIgRyxTLEYsTix3LHksUixoPW5ldyBXZWJBc3NlbWJseS5UYWJsZSh7aW5pdGlhbDoxLG1heGltdW06MSxlbGVtZW50OlwiYW55ZnVuY1wifSkscz0hMTtmdW5jdGlvbiBrKEkpe0c9SSxBLkhFQVA4PVM9bmV3IEludDhBcnJheShJKSxBLkhFQVAxNj1OPW5ldyBJbnQxNkFycmF5KEkpLEEuSEVBUDMyPXc9bmV3IEludDMyQXJyYXkoSSksQS5IRUFQVTg9Rj1uZXcgVWludDhBcnJheShJKSxBLkhFQVBVMTY9bmV3IFVpbnQxNkFycmF5KEkpLEEuSEVBUFUzMj1uZXcgVWludDMyQXJyYXkoSSksQS5IRUFQRjMyPXk9bmV3IEZsb2F0MzJBcnJheShJKSxBLkhFQVBGNjQ9Uj1uZXcgRmxvYXQ2NEFycmF5KEkpfXZhciBMPUEuSU5JVElBTF9NRU1PUll8fDE2Nzc3MjE2O2Z1bmN0aW9uIE0oSSl7Zm9yKDtJLmxlbmd0aD4wOyl7dmFyIGc9SS5zaGlmdCgpO2lmKFwiZnVuY3Rpb25cIiE9dHlwZW9mIGcpe3ZhciBCPWcuZnVuYztcIm51bWJlclwiPT10eXBlb2YgQj92b2lkIDA9PT1nLmFyZz9BLmR5bkNhbGxfdihCKTpBLmR5bkNhbGxfdmkoQixnLmFyZyk6Qih2b2lkIDA9PT1nLmFyZz9udWxsOmcuYXJnKX1lbHNlIGcoQSl9fShEPUEud2FzbU1lbW9yeT9BLndhc21NZW1vcnk6bmV3IFdlYkFzc2VtYmx5Lk1lbW9yeSh7aW5pdGlhbDpMLzY1NTM2LG1heGltdW06MzI3Njh9KSkmJihHPUQuYnVmZmVyKSxMPUcuYnl0ZUxlbmd0aCxrKEcpLHdbMjE4OF09NTI1MTc5Mjt2YXIgVT1bXSxZPVtdLEo9W10scT1bXSxLPTAsSD1udWxsLHQ9bnVsbDtmdW5jdGlvbiBjKEkpe3Rocm93IEEub25BYm9ydCYmQS5vbkFib3J0KEkpLG8oSSs9XCJcIiksYShJKSxzPSEwLEk9XCJhYm9ydChcIitJK1wiKS4gQnVpbGQgd2l0aCAtcyBBU1NFUlRJT05TPTEgZm9yIG1vcmUgaW5mby5cIixuZXcgV2ViQXNzZW1ibHkuUnVudGltZUVycm9yKEkpfWZ1bmN0aW9uIGQoQSl7cmV0dXJuIEk9QSxnPVwiZGF0YTphcHBsaWNhdGlvbi9vY3RldC1zdHJlYW07YmFzZTY0LFwiLFN0cmluZy5wcm90b3R5cGUuc3RhcnRzV2l0aD9JLnN0YXJ0c1dpdGgoZyk6MD09PUkuaW5kZXhPZihnKTt2YXIgSSxnfUEucHJlbG9hZGVkSW1hZ2VzPXt9LEEucHJlbG9hZGVkQXVkaW9zPXt9O3ZhciBuLHA9XCJUaW55SDI2NC53YXNtXCI7ZnVuY3Rpb24gZigpe3RyeXtpZihpKXJldHVybiBuZXcgVWludDhBcnJheShpKTtpZihRKXJldHVybiBRKHApO3Rocm93XCJib3RoIGFzeW5jIGFuZCBzeW5jIGZldGNoaW5nIG9mIHRoZSB3YXNtIGZhaWxlZFwifWNhdGNoKEEpe2MoQSl9fWZ1bmN0aW9uIHIoQSl7dHJ5e3JldHVybiBELmdyb3coQS1HLmJ5dGVMZW5ndGgrNjU1MzU+Pj4xNiksayhELmJ1ZmZlciksMX1jYXRjaChBKXt9fWQocCl8fChuPXAscD1BLmxvY2F0ZUZpbGU/QS5sb2NhdGVGaWxlKG4sRSk6RStuKSxZLnB1c2goe2Z1bmM6ZnVuY3Rpb24oKXt4KCl9fSk7dmFyIGU9e2E6ZnVuY3Rpb24oQSxJLGcpe0YuY29weVdpdGhpbihBLEksSStnKX0sYjpmdW5jdGlvbihBKXtBPj4+PTA7dmFyIEk9Ri5sZW5ndGgsZz0yMTQ3NDgzNjQ4O2lmKEE+ZylyZXR1cm4hMTtmb3IodmFyIEIsUT0xO1E8PTQ7USo9Mil7dmFyIEM9SSooMSsuMi9RKTtpZihDPU1hdGgubWluKEMsQSsxMDA2NjMyOTYpLHIoTWF0aC5taW4oZywoKEI9TWF0aC5tYXgoMTY3NzcyMTYsQSxDKSklNjU1MzY+MCYmKEIrPTY1NTM2LUIlNjU1MzYpLEIpKSkpcmV0dXJuITB9cmV0dXJuITF9LG1lbW9yeTpELHRhYmxlOmh9LG09ZnVuY3Rpb24oKXt2YXIgST17YTplfTtmdW5jdGlvbiBnKEksZyl7dmFyIEI9SS5leHBvcnRzO0EuYXNtPUIsZnVuY3Rpb24oSSl7aWYoSy0tLEEubW9uaXRvclJ1bkRlcGVuZGVuY2llcyYmQS5tb25pdG9yUnVuRGVwZW5kZW5jaWVzKEspLDA9PUsmJihudWxsIT09SCYmKGNsZWFySW50ZXJ2YWwoSCksSD1udWxsKSx0KSl7dmFyIGc9dDt0PW51bGwsZygpfX0oKX1mdW5jdGlvbiBCKEEpe2coQS5pbnN0YW5jZSl9ZnVuY3Rpb24gUShBKXtyZXR1cm4oaXx8XCJmdW5jdGlvblwiIT10eXBlb2YgZmV0Y2g/bmV3IFByb21pc2UoKGZ1bmN0aW9uKEEsSSl7QShmKCkpfSkpOmZldGNoKHAse2NyZWRlbnRpYWxzOlwic2FtZS1vcmlnaW5cIn0pLnRoZW4oKGZ1bmN0aW9uKEEpe2lmKCFBLm9rKXRocm93XCJmYWlsZWQgdG8gbG9hZCB3YXNtIGJpbmFyeSBmaWxlIGF0IFxcJ1wiK3ArXCJcXCdcIjtyZXR1cm4gQS5hcnJheUJ1ZmZlcigpfSkpLmNhdGNoKChmdW5jdGlvbigpe3JldHVybiBmKCl9KSkpLnRoZW4oKGZ1bmN0aW9uKEEpe3JldHVybiBXZWJBc3NlbWJseS5pbnN0YW50aWF0ZShBLEkpfSkpLnRoZW4oQSwoZnVuY3Rpb24oQSl7YShcImZhaWxlZCB0byBhc3luY2hyb25vdXNseSBwcmVwYXJlIHdhc206IFwiK0EpLGMoQSl9KSl9aWYoSysrLEEubW9uaXRvclJ1bkRlcGVuZGVuY2llcyYmQS5tb25pdG9yUnVuRGVwZW5kZW5jaWVzKEspLEEuaW5zdGFudGlhdGVXYXNtKXRyeXtyZXR1cm4gQS5pbnN0YW50aWF0ZVdhc20oSSxnKX1jYXRjaChBKXtyZXR1cm4gYShcIk1vZHVsZS5pbnN0YW50aWF0ZVdhc20gY2FsbGJhY2sgZmFpbGVkIHdpdGggZXJyb3I6IFwiK0EpLCExfXJldHVybiBmdW5jdGlvbigpe2lmKGl8fFwiZnVuY3Rpb25cIiE9dHlwZW9mIFdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlU3RyZWFtaW5nfHxkKHApfHxcImZ1bmN0aW9uXCIhPXR5cGVvZiBmZXRjaClyZXR1cm4gUShCKTtmZXRjaChwLHtjcmVkZW50aWFsczpcInNhbWUtb3JpZ2luXCJ9KS50aGVuKChmdW5jdGlvbihBKXtyZXR1cm4gV2ViQXNzZW1ibHkuaW5zdGFudGlhdGVTdHJlYW1pbmcoQSxJKS50aGVuKEIsKGZ1bmN0aW9uKEEpe2EoXCJ3YXNtIHN0cmVhbWluZyBjb21waWxlIGZhaWxlZDogXCIrQSksYShcImZhbGxpbmcgYmFjayB0byBBcnJheUJ1ZmZlciBpbnN0YW50aWF0aW9uXCIpLFEoQil9KSl9KSl9KCkse319KCk7QS5hc209bTt2YXIgVyx4PUEuX19fd2FzbV9jYWxsX2N0b3JzPWZ1bmN0aW9uKCl7cmV0dXJuKHg9QS5fX193YXNtX2NhbGxfY3RvcnM9QS5hc20uYykuYXBwbHkobnVsbCxhcmd1bWVudHMpfTtmdW5jdGlvbiBYKEkpe2Z1bmN0aW9uIGcoKXtXfHwoVz0hMCxBLmNhbGxlZFJ1bj0hMCxzfHwoTShZKSxNKEopLEEub25SdW50aW1lSW5pdGlhbGl6ZWQmJkEub25SdW50aW1lSW5pdGlhbGl6ZWQoKSxmdW5jdGlvbigpe2lmKEEucG9zdFJ1bilmb3IoXCJmdW5jdGlvblwiPT10eXBlb2YgQS5wb3N0UnVuJiYoQS5wb3N0UnVuPVtBLnBvc3RSdW5dKTtBLnBvc3RSdW4ubGVuZ3RoOylJPUEucG9zdFJ1bi5zaGlmdCgpLHEudW5zaGlmdChJKTt2YXIgSTtNKHEpfSgpKSl9ST1JfHxDLEs+MHx8KGZ1bmN0aW9uKCl7aWYoQS5wcmVSdW4pZm9yKFwiZnVuY3Rpb25cIj09dHlwZW9mIEEucHJlUnVuJiYoQS5wcmVSdW49W0EucHJlUnVuXSk7QS5wcmVSdW4ubGVuZ3RoOylJPUEucHJlUnVuLnNoaWZ0KCksVS51bnNoaWZ0KEkpO3ZhciBJO00oVSl9KCksSz4wfHwoQS5zZXRTdGF0dXM/KEEuc2V0U3RhdHVzKFwiUnVubmluZy4uLlwiKSxzZXRUaW1lb3V0KChmdW5jdGlvbigpe3NldFRpbWVvdXQoKGZ1bmN0aW9uKCl7QS5zZXRTdGF0dXMoXCJcIil9KSwxKSxnKCl9KSwxKSk6ZygpKSl9aWYoQS5faDI2NGJzZEluaXQ9ZnVuY3Rpb24oKXtyZXR1cm4oQS5faDI2NGJzZEluaXQ9QS5hc20uZCkuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxBLl9tYWxsb2M9ZnVuY3Rpb24oKXtyZXR1cm4oQS5fbWFsbG9jPUEuYXNtLmUpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sQS5fZnJlZT1mdW5jdGlvbigpe3JldHVybihBLl9mcmVlPUEuYXNtLmYpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sQS5faDI2NGJzZERlY29kZT1mdW5jdGlvbigpe3JldHVybihBLl9oMjY0YnNkRGVjb2RlPUEuYXNtLmcpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sQS5faDI2NGJzZFNodXRkb3duPWZ1bmN0aW9uKCl7cmV0dXJuKEEuX2gyNjRic2RTaHV0ZG93bj1BLmFzbS5oKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LEEuX2gyNjRic2RBbGxvYz1mdW5jdGlvbigpe3JldHVybihBLl9oMjY0YnNkQWxsb2M9QS5hc20uaSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxBLl9oMjY0YnNkRnJlZT1mdW5jdGlvbigpe3JldHVybihBLl9oMjY0YnNkRnJlZT1BLmFzbS5qKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LEEuYXNtPW0sQS5nZXRWYWx1ZT1mdW5jdGlvbihBLEksZyl7c3dpdGNoKFwiKlwiPT09KEk9SXx8XCJpOFwiKS5jaGFyQXQoSS5sZW5ndGgtMSkmJihJPVwiaTMyXCIpLEkpe2Nhc2VcImkxXCI6Y2FzZVwiaThcIjpyZXR1cm4gU1tBPj4wXTtjYXNlXCJpMTZcIjpyZXR1cm4gTltBPj4xXTtjYXNlXCJpMzJcIjpjYXNlXCJpNjRcIjpyZXR1cm4gd1tBPj4yXTtjYXNlXCJmbG9hdFwiOnJldHVybiB5W0E+PjJdO2Nhc2VcImRvdWJsZVwiOnJldHVybiBSW0E+PjNdO2RlZmF1bHQ6YyhcImludmFsaWQgdHlwZSBmb3IgZ2V0VmFsdWU6IFwiK0kpfXJldHVybiBudWxsfSxBLnRoZW49ZnVuY3Rpb24oSSl7aWYoVylJKEEpO2Vsc2V7dmFyIGc9QS5vblJ1bnRpbWVJbml0aWFsaXplZDtBLm9uUnVudGltZUluaXRpYWxpemVkPWZ1bmN0aW9uKCl7ZyYmZygpLEkoQSl9fXJldHVybiBBfSx0PWZ1bmN0aW9uIEEoKXtXfHxYKCksV3x8KHQ9QSl9LEEucnVuPVgsQS5wcmVJbml0KWZvcihcImZ1bmN0aW9uXCI9PXR5cGVvZiBBLnByZUluaXQmJihBLnByZUluaXQ9W0EucHJlSW5pdF0pO0EucHJlSW5pdC5sZW5ndGg+MDspQS5wcmVJbml0LnBvcCgpKCk7cmV0dXJuIFgoKSxBfSk7QS5leHBvcnRzPWd9LDM0MDooQSxJLGcpPT57XCJ1c2Ugc3RyaWN0XCI7Zy5yKEkpLGcuZChJLHtpbml0OigpPT5vfSk7dmFyIEI9ZnVuY3Rpb24oKXtmdW5jdGlvbiBBKEEsSSl7dGhpcy50aW55SDI2NE1vZHVsZT1BLHRoaXMub25QaWN0dXJlUmVhZHk9SSx0aGlzLnBTdG9yYWdlPXRoaXMudGlueUgyNjRNb2R1bGUuX2gyNjRic2RBbGxvYygpLHRoaXMucFdpZHRoPXRoaXMudGlueUgyNjRNb2R1bGUuX21hbGxvYyg0KSx0aGlzLnBIZWlnaHQ9dGhpcy50aW55SDI2NE1vZHVsZS5fbWFsbG9jKDQpLHRoaXMucFBpY3R1cmU9dGhpcy50aW55SDI2NE1vZHVsZS5fbWFsbG9jKDQpLHRoaXMuX2RlY0J1ZmZlcj10aGlzLnRpbnlIMjY0TW9kdWxlLl9tYWxsb2MoMTA0ODU3NiksdGhpcy50aW55SDI2NE1vZHVsZS5faDI2NGJzZEluaXQodGhpcy5wU3RvcmFnZSwwKX12YXIgST1BLnByb3RvdHlwZTtyZXR1cm4gSS5yZWxlYXNlPWZ1bmN0aW9uKCl7dmFyIEE9dGhpcy5wU3RvcmFnZTswIT09QSYmKHRoaXMudGlueUgyNjRNb2R1bGUuX2gyNjRic2RTaHV0ZG93bihBKSx0aGlzLnRpbnlIMjY0TW9kdWxlLl9oMjY0YnNkRnJlZShBKSksdGhpcy50aW55SDI2NE1vZHVsZS5fZnJlZSh0aGlzLnBXaWR0aCksdGhpcy50aW55SDI2NE1vZHVsZS5fZnJlZSh0aGlzLnBIZWlnaHQpLHRoaXMudGlueUgyNjRNb2R1bGUuX2ZyZWUodGhpcy5wUGljdHVyZSksdGhpcy5wU3RvcmFnZT0wLHRoaXMucFdpZHRoPTAsdGhpcy5wSGVpZ2h0PTB9LEkuZGVjb2RlPWZ1bmN0aW9uKEkpe2lmKEkgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlciYmKEk9bmV3IFVpbnQ4QXJyYXkoSSkpLHRoaXMudGlueUgyNjRNb2R1bGUuSEVBUFU4LnNldChJLHRoaXMuX2RlY0J1ZmZlciksdGhpcy50aW55SDI2NE1vZHVsZS5faDI2NGJzZERlY29kZSh0aGlzLnBTdG9yYWdlLHRoaXMuX2RlY0J1ZmZlcixJLmJ5dGVMZW5ndGgsdGhpcy5wUGljdHVyZSx0aGlzLnBXaWR0aCx0aGlzLnBIZWlnaHQpPT09QS5QSUNfUkRZKXt2YXIgZz10aGlzLnRpbnlIMjY0TW9kdWxlLmdldFZhbHVlKHRoaXMucFdpZHRoLFwiaTMyXCIpLEI9dGhpcy50aW55SDI2NE1vZHVsZS5nZXRWYWx1ZSh0aGlzLnBIZWlnaHQsXCJpMzJcIiksUT10aGlzLnRpbnlIMjY0TW9kdWxlLmdldFZhbHVlKHRoaXMucFBpY3R1cmUsXCJpOCpcIiksQz1uZXcgVWludDhBcnJheSh0aGlzLnRpbnlIMjY0TW9kdWxlLkhFQVBVOC5zdWJhcnJheShRLFErZypCKjMvMikpO3RoaXMub25QaWN0dXJlUmVhZHkoQyxnLEIpfX0sQX0oKTtCLlJEWT0wLEIuUElDX1JEWT0xLEIuSERSU19SRFk9MixCLkVSUk9SPTMsQi5QQVJBTV9TRVRfRVJST1I9NCxCLk1FTUFMTE9DX0VSUk9SPTU7Y29uc3QgUT1CO3ZhciBDPWcoNzE5KSxFPWcubihDKSxpPXtcIlRpbnlIMjY0Lndhc21cIjpcImRhdGE6O2Jhc2U2NCxBR0Z6YlFFQUFBQUJsd0VUWUFKL2Z3Ri9ZQVIvZjM5L0FYOWdBbjkvQUdBRGYzOS9BWDlnQVg4QVlBbC9mMzkvZjM5L2YzOEFZQUYvQVg5Z0JIOS9mMzhBWUFaL2YzOS9mMzhCZjJBSWYzOS9mMzkvZjM4QVlBTi9mMzhBWUFWL2YzOS9md0YvWUFBQVlBVi9mMzkvZndCZ0JuOS9mMzkvZndCZ0NuOS9mMzkvZjM5L2YzOEFZQUFCZjJBSGYzOS9mMzkvZndGL1lBaC9mMzkvZjM5L2Z3Ri9BaDBEQVdFQllRQURBV0VCWWdBR0FXRUdiV1Z0YjNKNUFnR0FBb0NBQWdObVpRQUFCQUFCQXdvQkJnQUZBd1VHQndBSEJnQUREZ01IQndVQ0FBSURCQUFGQlFVRkNnUUNCQWtCQndBREJnWUNBZ0VHQkFNQ0FnRUxBUUVEQXdzTkFnRUFBQUlKQ1FrUEFnVUZBQUVLQUJJTEVRZ0lCd2dJQndRQkJBZ0lCZ0VFRUFRSUFBRU1CZ2tCZndGQjBNWEFBZ3NISVFnQll3Qm1BV1FBWkFGbEFBb0JaZ0FFQVdjQVl3Rm9BR0lCYVFCaEFXb0FZQXJFcUFWbHdBSUJBbjhnQUJBUElnSkJmMHdFUUNBQVFRRVFDeG9nQVVFQU5nSUFRUUFQQ3dKQUFrQWdBa0dBZ0lDQUJFOEVRQ0FBUVFNUUMwRi9SZ1JBUVFFUEN5QUJJQUpCSFhaQkFYRkJBV28yQWdBTUFRc2dBa0dBZ0lDQUFrOEVRQ0FBUVFVUUMwRi9SZ1JBUVFFUEN5QUJJQUpCRzNaQkEzRkJBMm8yQWdBTUFRc2dBa0dBZ0lDQUFVOEVRQ0FBUVFjUUMwRi9SZ1JBUVFFUEN5QUJJQUpCR1haQkIzRkJCMm8yQWdBTUFRc2dBaEF2SWdOQkJHb2lBa0VnUmdSQUlBRkJBRFlDQUNBQVFTQVFDeHBCQVNFQ0lBQkJBUkFEUVFGSERRSWdBQkFQSVFNZ0FFRWdFQXRCZjBZTkFpQURRUUZMRFFJZ0EwRUJhd1JBSUFGQmZ6WUNBQXdDQ3lBQlFYODJBZ0JCQVE4TElBQWdBMEVGYWhBTEdpQUFJQUlRQXlJQVFYOUdCRUJCQVE4TElBRWdBRUYvSUFKMFFYOXphallDQUF0QkFDRUNDeUFDQzRnQ0FRZC9JQUFvQWdRaEJBSkFJQUFvQWd4QkEzUWlCeUFBS0FJUUlnaHJJZ0pCSUU0RVFDQUVLQUFBSWdOQkdIUWdBMEVJZEVHQWdQd0hjWElnQTBFSWRrR0EvZ054SUFOQkdIWnljaUVESUFBb0FnZ2lBa1VOQVNBRElBSjBJQVF0QUFSQkNDQUNhM1p5SVFNTUFRc2dBa0VCU0FSQURBRUxJQVF0QUFBZ0FDZ0NDQ0lGUVJocUlnWjBJUU1nQWlBRmFrRjRhaUlDUVFGSURRQURRQ0FFTFFBQklBWkJlR29pQm5RZ0EzSWhBeUFDUVFoS0lRVWdCRUVCYWlFRUlBSkJlR29oQWlBRkRRQUxDeUFBSUFFZ0NHb2lCRFlDRUNBQUlBUkJCM0UyQWdoQmZ5RUNJQVFnQjAwRWZ5QUFJQUFvQWdBZ0JFRURkbW8yQWdRZ0EwRWdJQUZyZGdWQmZ3c0xxZzBCQjM4Q1FDQUFSUTBBSUFCQmVHb2lBeUFBUVh4cUtBSUFJZ0ZCZUhFaUFHb2hCUUpBSUFGQkFYRU5BQ0FCUVFOeFJRMEJJQU1nQXlnQ0FDSUNheUlEUWNUQUFDZ0NBQ0lFU1EwQklBQWdBbW9oQUNBRFFjakFBQ2dDQUVjRVFDQUNRZjhCVFFSQUlBTW9BZ2dpQkNBQ1FRTjJJZ0pCQTNSQjNNQUFha2NhSUFRZ0F5Z0NEQ0lCUmdSQVFiVEFBRUcwd0FBb0FnQkJmaUFDZDNFMkFnQU1Bd3NnQkNBQk5nSU1JQUVnQkRZQ0NBd0NDeUFES0FJWUlRWUNRQ0FESUFNb0Fnd2lBVWNFUUNBRUlBTW9BZ2dpQWswRVFDQUNLQUlNR2dzZ0FpQUJOZ0lNSUFFZ0FqWUNDQXdCQ3dKQUlBTkJGR29pQWlnQ0FDSUVEUUFnQTBFUWFpSUNLQUlBSWdRTkFFRUFJUUVNQVFzRFFDQUNJUWNnQkNJQlFSUnFJZ0lvQWdBaUJBMEFJQUZCRUdvaEFpQUJLQUlRSWdRTkFBc2dCMEVBTmdJQUN5QUdSUTBCQWtBZ0F5QURLQUljSWdKQkFuUkI1TUlBYWlJRUtBSUFSZ1JBSUFRZ0FUWUNBQ0FCRFFGQnVNQUFRYmpBQUNnQ0FFRitJQUozY1RZQ0FBd0RDeUFHUVJCQkZDQUdLQUlRSUFOR0cyb2dBVFlDQUNBQlJRMENDeUFCSUFZMkFoZ2dBeWdDRUNJQ0JFQWdBU0FDTmdJUUlBSWdBVFlDR0FzZ0F5Z0NGQ0lDUlEwQklBRWdBallDRkNBQ0lBRTJBaGdNQVFzZ0JTZ0NCQ0lCUVFOeFFRTkhEUUJCdk1BQUlBQTJBZ0FnQlNBQlFYNXhOZ0lFSUFNZ0FFRUJjallDQkNBQUlBTnFJQUEyQWdBUEN5QUZJQU5ORFFBZ0JTZ0NCQ0lCUVFGeFJRMEFBa0FnQVVFQ2NVVUVRQ0FGUWN6QUFDZ0NBRVlFUUVITXdBQWdBellDQUVIQXdBQkJ3TUFBS0FJQUlBQnFJZ0EyQWdBZ0F5QUFRUUZ5TmdJRUlBTkJ5TUFBS0FJQVJ3MERRYnpBQUVFQU5nSUFRY2pBQUVFQU5nSUFEd3NnQlVISXdBQW9BZ0JHQkVCQnlNQUFJQU0yQWdCQnZNQUFRYnpBQUNnQ0FDQUFhaUlBTmdJQUlBTWdBRUVCY2pZQ0JDQUFJQU5xSUFBMkFnQVBDeUFCUVhoeElBQnFJUUFDUUNBQlFmOEJUUVJBSUFVb0Fnd2hBaUFGS0FJSUlnUWdBVUVEZGlJQlFRTjBRZHpBQUdvaUIwY0VRRUhFd0FBb0FnQWFDeUFDSUFSR0JFQkJ0TUFBUWJUQUFDZ0NBRUYrSUFGM2NUWUNBQXdDQ3lBQ0lBZEhCRUJCeE1BQUtBSUFHZ3NnQkNBQ05nSU1JQUlnQkRZQ0NBd0JDeUFGS0FJWUlRWUNRQ0FGSUFVb0Fnd2lBVWNFUUVIRXdBQW9BZ0FnQlNnQ0NDSUNUUVJBSUFJb0Fnd2FDeUFDSUFFMkFnd2dBU0FDTmdJSURBRUxBa0FnQlVFVWFpSUNLQUlBSWdRTkFDQUZRUkJxSWdJb0FnQWlCQTBBUVFBaEFRd0JDd05BSUFJaEJ5QUVJZ0ZCRkdvaUFpZ0NBQ0lFRFFBZ0FVRVFhaUVDSUFFb0FoQWlCQTBBQ3lBSFFRQTJBZ0FMSUFaRkRRQUNRQ0FGSUFVb0Fod2lBa0VDZEVIa3dnQnFJZ1FvQWdCR0JFQWdCQ0FCTmdJQUlBRU5BVUc0d0FCQnVNQUFLQUlBUVg0Z0FuZHhOZ0lBREFJTElBWkJFRUVVSUFZb0FoQWdCVVliYWlBQk5nSUFJQUZGRFFFTElBRWdCallDR0NBRktBSVFJZ0lFUUNBQklBSTJBaEFnQWlBQk5nSVlDeUFGS0FJVUlnSkZEUUFnQVNBQ05nSVVJQUlnQVRZQ0dBc2dBeUFBUVFGeU5nSUVJQUFnQTJvZ0FEWUNBQ0FEUWNqQUFDZ0NBRWNOQVVHOHdBQWdBRFlDQUE4TElBVWdBVUYrY1RZQ0JDQURJQUJCQVhJMkFnUWdBQ0FEYWlBQU5nSUFDeUFBUWY4QlRRUkFJQUJCQTNZaUFVRURkRUhjd0FCcUlRQUNmMEcwd0FBb0FnQWlBa0VCSUFGMElnRnhSUVJBUWJUQUFDQUJJQUp5TmdJQUlBQU1BUXNnQUNnQ0NBc2hBaUFBSUFNMkFnZ2dBaUFETmdJTUlBTWdBRFlDRENBRElBSTJBZ2dQQ3lBRFFnQTNBaEFnQXdKL1FRQWdBRUVJZGlJQlJRMEFHa0VmSUFCQi8vLy9CMHNOQUJvZ0FTQUJRWUQrUDJwQkVIWkJDSEVpQVhRaUFpQUNRWURnSDJwQkVIWkJCSEVpQW5RaUJDQUVRWUNBRDJwQkVIWkJBbkVpQkhSQkQzWWdBU0FDY2lBRWNtc2lBVUVCZENBQUlBRkJGV3AyUVFGeGNrRWNhZ3NpQWpZQ0hDQUNRUUowUWVUQ0FHb2hBUUpBQWtBQ1FFRzR3QUFvQWdBaUJFRUJJQUowSWdkeFJRUkFRYmpBQUNBRUlBZHlOZ0lBSUFFZ0F6WUNBQ0FESUFFMkFoZ01BUXNnQUVFQVFSa2dBa0VCZG1zZ0FrRWZSaHQwSVFJZ0FTZ0NBQ0VCQTBBZ0FTSUVLQUlFUVhoeElBQkdEUUlnQWtFZGRpRUJJQUpCQVhRaEFpQUVJQUZCQkhGcUlnZEJFR29vQWdBaUFRMEFDeUFISUFNMkFoQWdBeUFFTmdJWUN5QURJQU0yQWd3Z0F5QUROZ0lJREFFTElBUW9BZ2dpQUNBRE5nSU1JQVFnQXpZQ0NDQURRUUEyQWhnZ0F5QUVOZ0lNSUFNZ0FEWUNDQXRCMU1BQVFkVEFBQ2dDQUVGL2FpSUFOZ0lBSUFBTkFFSDh3d0FoQXdOQUlBTW9BZ0FpQUVFSWFpRURJQUFOQUF0QjFNQUFRWDgyQWdBTEMzUUJBbjhqQUVFUWF5SUNKQUFnQWtFQU5nSU1JQUFnQWtFTWFoQUNJUUFDZnlBQ0tBSU1JZ05CZjBZRVFFRUJJQUJGRFFFYUlBRkJnSUNBZ0hnMkFnQkJBQXdCQzBFQklBQU5BQm9nQVNBRFFRRnFRUUYySWdGQkFDQUJheUFEUVFGeEd6WUNBRUVBQ3lFQUlBSkJFR29rQUNBQUM3a0xBUlIvSUFGQm9EMXFMUUFBUVF4c0lnWkIxRHhxS0FJQUlRUWdCa0hRUEdvb0FnQWdBVUdRUEdvdEFBQWlCM1FoQlNBQ1JRUkFJQUFnQUNnQ0FDQUZiRFlDQUFzZ0JDQUhkQ0VCQWtBQ1FDQURRWnovQTNFRVFDQUFJQVpCMkR4cUtBSUFJQWQwSWdNZ0FDZ0NQR3cyQWp3Z0FDQUFLQUk0SUFGc05nSTRRUUVoQWlBQUlBQW9BaXdnQld3aUJ5QUFLQUlNSUFWc0lnUnFJZ3dnQUNnQ0lDQUJiQ0lOSUFBb0FqUWdBV3dpRGtFQmRXb2lFR3NpQmpZQ0xDQUFLQUlvSVJFZ0FDQUVJQWRySWdRZ0RVRUJkU0FPYXlJTmF5SUhOZ0lvSUFBb0FpUWhDQ0FBSUFRZ0RXb2lCRFlDSkNBQUlBQW9BaHdnQVd3aURpQUFLQUlJSUFGc0lncHFJaElnQUNnQ0VDQURiQ0lQSUFBb0FqQWdBMndpQzBFQmRXb2lFMnNpRFRZQ0hDQUFLQUlZSVFrZ0FDQUtJQTVySWdvZ0QwRUJkU0FMYXlJUGF5SU9OZ0lZSUFBb0FoUWhDeUFBSUFvZ0Qyb2lDallDRkNBQUlBVWdDMndpRHlBQUtBSUFJZ3RxSWhRZ0FDZ0NCQ0FCYkNJVklBRWdDV3dpQ1VFQmRXb2lGbXNpQlRZQ0RDQUFJQXNnRDJzaUN5QVZRUUYxSUFscklnbHJJZzgyQWdnZ0FDQUpJQXRxSWdzMkFnUWdBQ0FCSUFoc0lnZ2dBQ2dDT0NJSmF5SVZJQU1nRVd3aUVVRUJkU0FBS0FJOEloZHJJZ05ySWdFMkFqZ2dBQ0FESUJWcUlnTTJBalFnQUNBSUlBbHFJZ2dnRjBFQmRTQVJhaUlKYXlJUk5nSThJQUFnRkNBV2FpSVVJQXdnRUdvaURHdEJJR29pRUNBU0lCTnFJaEpCQVhVZ0NDQUphaUlJYXlJVGEwRUdkU0lKTmdJZ0lBQWdFQ0FUYWtFR2RTSVFOZ0lRSUFBZ0RDQVVha0VnYWlJTUlBaEJBWFVnRW1vaUNHdEJCblVpRWpZQ01DQUFJQWdnREdwQkJuVWlERFlDQUNBTVFZQUVhaUFRUVlBRWFuSkIvd2RMRFFJZ0VrR0FCR29nQ1VHQUJHcHlRZjhIU3cwQ0lBQWdCQ0FMYWtFZ2FpSU1JQU5CQVhVZ0Ntb2lFR3RCQm5VaUNEWUNOQ0FBSUFzZ0JHdEJJR29pQkNBS1FRRjFJQU5ySWdOclFRWjFJZ28yQWlRZ0FDQURJQVJxUVFaMUlnTTJBaFFnQUNBTUlCQnFRUVoxSWdRMkFnUWdCRUdBQkdvZ0EwR0FCR3B5UWY4SFN3MENJQWhCZ0FScUlBcEJnQVJxY2tIL0Iwc05BaUFBSUFjZ0QycEJJR29pQXlBQlFRRjFJQTVxSWdSclFRWjFJZ28yQWpnZ0FDQVBJQWRyUVNCcUlnY2dEa0VCZFNBQmF5SUJhMEVHZFNJT05nSW9JQUFnQVNBSGFrRUdkU0lCTmdJWUlBQWdBeUFFYWtFR2RTSUROZ0lJSUFOQmdBUnFJQUZCZ0FScWNrSC9CMHNOQWlBS1FZQUVhaUFPUVlBRWFuSkIvd2RMRFFJZ0FDQUZJQVpxUVNCcUlnRWdFVUVCZFNBTmFpSURhMEVHZFNJSE5nSThJQUFnQlNBR2EwRWdhaUlGSUExQkFYVWdFV3NpQm10QkJuVWlCRFlDTENBQUlBVWdCbXBCQm5VaUJUWUNIQ0FBSUFFZ0EycEJCblVpQURZQ0RDQUFRWUFFYWlBRlFZQUVhbkpCL3dkTERRSWdCMEdBQkdvZ0JFR0FCR3B5UWY4SFRRMEJEQUlMSUFOQjRnQnhSUVJBUVFFaEFpQUFLQUlBUVNCcVFRWjFJZ0ZCZ0FScVFmOEhTdzBDSUFBZ0FUWUNPQ0FBSUFFMkFqd2dBQ0FCTmdJMElBQWdBVFlDTUNBQUlBRTJBaXdnQUNBQk5nSW9JQUFnQVRZQ0pDQUFJQUUyQWlBZ0FDQUJOZ0ljSUFBZ0FUWUNHQ0FBSUFFMkFoUWdBQ0FCTmdJUUlBQWdBVFlDRENBQUlBRTJBZ2dnQUNBQk5nSUVJQUFnQVRZQ0FBd0JDMEVCSVFJZ0FDQUFLQUlFSUFGc0lnUWdBQ2dDR0NBQmJDSU5RUUYxYWlJRElBQW9BZ0FpQmlBQUtBSVVJQVZzSWdkcUlnVnFRU0JxUVFaMUlnRTJBakFnQUNBRklBTnJRU0JxUVFaMUlnTTJBZ3dnQUNBRVFRRjFJQTFySWdRZ0JpQUhhMnBCSUdwQkJuVWlCVFlDQkNBQUlBRTJBZ0FnQUNBQk5nSWdJQUFnQlRZQ05DQUFJQUUyQWhBZ0FDQUZOZ0lrSUFBZ0JUWUNGQ0FBSUFNMkFqd2dBQ0FHSUFRZ0IycHJRU0JxUVFaMUlnWTJBZ2dnQUNBR05nSTRJQUFnQmpZQ0tDQUFJQVkyQWhnZ0FDQUROZ0lzSUFBZ0F6WUNIQ0FEUVlBRWFpQUJRWUFFYWlBR1FZQUVhaUFGUVlBRWFuSnlja0gvQjBzTkFRdEJBQ0VDQ3lBQ0MvTUNBZ0ovQVg0Q1FDQUNSUTBBSUFBZ0Ftb2lBMEYvYWlBQk9nQUFJQUFnQVRvQUFDQUNRUU5KRFFBZ0EwRithaUFCT2dBQUlBQWdBVG9BQVNBRFFYMXFJQUU2QUFBZ0FDQUJPZ0FDSUFKQkIwa05BQ0FEUVh4cUlBRTZBQUFnQUNBQk9nQURJQUpCQ1VrTkFDQUFRUUFnQUd0QkEzRWlCR29pQXlBQlFmOEJjVUdCZ29RSWJDSUJOZ0lBSUFNZ0FpQUVhMEY4Y1NJRWFpSUNRWHhxSUFFMkFnQWdCRUVKU1EwQUlBTWdBVFlDQ0NBRElBRTJBZ1FnQWtGNGFpQUJOZ0lBSUFKQmRHb2dBVFlDQUNBRVFSbEpEUUFnQXlBQk5nSVlJQU1nQVRZQ0ZDQURJQUUyQWhBZ0F5QUJOZ0lNSUFKQmNHb2dBVFlDQUNBQ1FXeHFJQUUyQWdBZ0FrRm9haUFCTmdJQUlBSkJaR29nQVRZQ0FDQUVJQU5CQkhGQkdISWlCR3NpQWtFZ1NRMEFJQUd0SWdWQ0lJWWdCWVFoQlNBRElBUnFJUUVEUUNBQklBVTNBeGdnQVNBRk53TVFJQUVnQlRjRENDQUJJQVUzQXdBZ0FVRWdhaUVCSUFKQllHb2lBa0VmU3cwQUN3c2dBQXZ5QXdFRGZ5QUJLQUlBSWdOQi8vLy9CMGNFUUNBQktBSUVJUVFnQUNBQ0lBSkJBM0VnQWtFUVNTSUNHMEVDZENJRlFmQXBhaWdDQUVFUVFRZ2dBaHNpQW14cUlBVkJzQ2xxS0FJQWFpSUFJQU1nQUMwQUFHcEJzQzVxTFFBQU9nQUFJQUVvQWdnaEF5QUFJQVFnQUMwQUFXcEJzQzVxTFFBQU9nQUJJQUVvQWd3aEJDQUFJQU1nQUMwQUFtcEJzQzVxTFFBQU9nQUNJQUFnQkNBQUxRQURha0d3TG1vdEFBQTZBQU1nQVNnQ0ZDRURJQUFnQW1vaUFDQUJLQUlRSUFBdEFBQnFRYkF1YWkwQUFEb0FBQ0FCS0FJWUlRUWdBQ0FESUFBdEFBRnFRYkF1YWkwQUFEb0FBU0FCS0FJY0lRTWdBQ0FFSUFBdEFBSnFRYkF1YWkwQUFEb0FBaUFBSUFNZ0FDMEFBMnBCc0M1cUxRQUFPZ0FESUFFb0FpUWhBeUFBSUFKcUlnQWdBU2dDSUNBQUxRQUFha0d3TG1vdEFBQTZBQUFnQVNnQ0tDRUVJQUFnQXlBQUxRQUJha0d3TG1vdEFBQTZBQUVnQVNnQ0xDRURJQUFnQkNBQUxRQUNha0d3TG1vdEFBQTZBQUlnQUNBRElBQXRBQU5xUWJBdWFpMEFBRG9BQXlBQktBSTBJUU1nQUNBQ2FpSUFJQUVvQWpBZ0FDMEFBR3BCc0M1cUxRQUFPZ0FBSUFFb0FqZ2hBaUFBSUFNZ0FDMEFBV3BCc0M1cUxRQUFPZ0FCSUFFb0Fqd2hBU0FBSUFJZ0FDMEFBbXBCc0M1cUxRQUFPZ0FDSUFBZ0FTQUFMUUFEYWtHd0xtb3RBQUE2QUFNTEM5TVFBUXgvSXdCQmdBRnJJZ29rQUNBQUVBOGhCRUVCSVFVQ1FBSkFBbjhnQWtFQlRRUkFJQVJCQUVnTkFpQUVRUmwyUWY0QWNVR0FDR29nQkVHQWdJRGdBRThOQVJvZ0JFRVZka0grRDNGQndBaHFJQVJCZ0lDQUNFOE5BUm9nQkVFUmRrSCsvd0Z4UVpBSmFpQUVRWUNBZ0FGUERRRWFJQVJCRUhaQkFYUkJrQXBxREFFTElBSkJBMDBFUUNBRVFYOU1CRUJCQWtHaUVDQUVRWUNBZ0lBRWNSc2hCUXdEQ3lBRVFSbDJRZjRBY1VIUUNtb2dCRUdBZ0lDQUFVOE5BUm9nQkVFV2RrSCtCM0ZCa0F0cUlBUkJnSUNBRUU4TkFSb2dCRUVSZGtIKy93RnhRZEFMYWd3QkN5QUNRUWROQkVBZ0JFRWFkaUlDUVhocVFUaEpCRUFnQWtFQmRFSFFEV29NQWdzZ0JFRVZka0grRDNGQjBBNXFEQUVMSUFSQkdYWkIvZ0J4UWRBUWFpQUNRUkJORFFBYUlBUkJIWFlpQWdSQUlBSkJBWFJCMEJGcURBRUxJQVJCRjNaQi9nTnhRZUFSYWdzdkFRQWlCUTBBUVFFaEN3d0JDMEVCSVFzZ0JVRUxkaUlKSUFOTERRQkJJQ0FGUVI5eElnWnJJUUlDUUNBSlJRUkFEQUVMSUFRZ0JuUWhCQUpBSUFWQkJYWkJQM0VpREVVRVFBd0JDeUFDSUF4SkJFQWdBQ0FHRUF0QmYwWU5BeUFBRUE4aEJFRWdJUUlMSUFRZ0RIUWhCa0VCSUF4QmYycDBJUWNnQkVFZ0lBeHJkaUVFQTBBZ0NrRkFheUFJUVFKMGFrRi9RUUVnQkNBSGNSczJBZ0FnQ0VFQmFpRUlJQWRCQVhZaUJ3MEFDeUFDSUF4cklRSWdCaUVFQ3lBSUlBbEpCRUFnREVFRFNTSVBJQVZCLzY4QlMzRWhCUU5BSUFKQkQwMEVRQ0FBUVNBZ0Ftc1FDMEYvUmdSQURBVUxJQUFRRHlFRVFTQWhBZ3RCQUNFR0FrQUNRQUovQWtBZ0JFRUFTQTBBUVFFaEJpQUVRZi8vLy84RFN3MEFRUUloQmlBRVFmLy8vLzhCU3cwQVFRTWhCaUFFUWYvLy8vOEFTdzBBUVFRaEJpQUVRZi8vL3o5TERRQkJCU0VHSUFSQi8vLy9IMHNOQUVFR0lRWWdCRUgvLy84UFN3MEFRUWNoQmlBRVFmLy8vd2RMRFFCQkNDRUdJQVJCLy8vL0Ewc05BRUVKSVFZZ0JFSC8vLzhCU3cwQVFRb2hCaUFFUWYvLy93QkxEUUJCQ3lFR0lBUkIvLzgvU3cwQVFRd2hCaUFFUWYvL0gwc05BRUVOSVFZZ0JFSC8vdzlMRFFBQ2Z3SkFJQVJCLy84SFRRUkFJQVJCZ0lCOGNVR0FnQVJHRFFFTUNnc2dCVUVFSUFVYklRWWdCRUVQZENFRVFRNGhCeUFDUVhGcURBRUxJQVZCQVNBRkd5RUZJQVJCRUhRaEJFRU1JUVpCRHlFSElBSkJjR29MSVFJZ0J5QUZkQ0VISUFWRkRBRUxJQVlnQlhRaEIwRUJJUTRnQWlBR1FRRnFJZ1pySVFJZ0JDQUdkQ0VFSUFWRkRRRWdCU0VHUVFBTElRNGdBaUFHVHdSL0lBUUZJQUJCSUNBQ2F4QUxRWDlHQkVBTUJ3dEJJQ0VDSUFBUUR3c2hEU0FDSUFacklRSWdEU0FHZENFRUlBMUJJQ0FHYTNZZ0Iyb2hCd3dCQzBFQUlRVUxJQXBCUUdzZ0NFRUNkR3BCQUNBSFFRSnFJQWNnQ0NBTVJoc2dCeUFQR3lJTlFRSnFRUUYySWdacklBWWdEVUVCY1JzMkFnQkJBU0FGSUE0YklnVWdCVUVHU1NBR1FRTWdCVUYvYW5SS2NXb2hCU0FJUVFGcUlnZ2dDVWNOQUFzTFFRQWhCd0pBSUFrZ0EwOEVRRUVBSVFnTUFRc0NRQ0FDUVFoTEJFQWdBaUVGREFFTFFTQWhCU0FBUVNBZ0Ftc1FDMEYvUmcwRElBQVFEeUVFQ3dKQUFrQUNmd0pBSUFOQkJFY0VRQ0FKUVg5cUlnSkJEVXNOQXdKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBSUFKQkFXc09EUUFCQWdNRUJRWUhDQWtLQ3d3T0N5QUVRUnAyUWVBU2Fnd09DeUFFUVJwMlFhQVRhZ3dOQ3lBRVFSdDJRZUFUYWd3TUN5QUVRUnQyUVlBVWFnd0xDeUFFUVJwMlFhQVVhZ3dLQ3lBRVFScDJRZUFVYWd3SkN5QUVRUnAyUWFBVmFnd0lDeUFFUVJwMlFlQVZhZ3dIQ3lBRVFSdDJRYUFXYWd3R0N5QUVRUngyUWNBV2Fnd0ZDeUFFUVJ4MlFkQVdhZ3dFQ3lBRVFSMTJRZUFXYWd3REN5QUVRUjUyUWVnV2Fnd0NDeUFFUVFCSUJFQkJBU0VDREFRTFFSRWhBaUFKUVFOR0RRTkJFaUVDSUFSQi8vLy8vd05MRFFOQklpRUNJQWxCQWtZTkEwRWpRVE1nQkVILy8vLy9BVXNiSVFJTUF3c2dCRUViZGtHZ0Vtb2dCRUVYZGtIQUVtb2dCRUgvLy8vL0FFc2JDeTBBQUNJQ0RRRU1CQXRCRVVFQklBUkJBRWdiSVFJTElBSkJCSFloQ0NBRklBSkJEM0VpQTJzaEFpQUVJQU4wSVFRTElBbEJmMm9pQXdSQUEwQUNmeUFJQkVBZ0FrRUtUUVJBSUFCQklDQUNheEFMUVg5R0JFQU1Cd3NnQUJBUElRUkJJQ0VDQ3dKQUFuOENRQ0FJUVg5cUlnVkJCVTBFUUFKQUFrQUNRQUpBQWtBZ0JVRUJhdzRGQUFFQ0F3UUdDeUFFUVI1MlFlNFdhZ3dHQ3lBRVFSNTJRZklXYWd3RkN5QUVRUjEyUWZZV2Fnd0VDeUFFUVIxMlFmNFdhZ3dEQ3lBRVFSMTJRWVlYYWd3Q0N3Si9RZk1BSUFSQkdYWkI4QUJ4YXlBRVFZQ0FnSUFDVHcwQUdrSDBBQ0FFUWYvLy8vOEFTdzBBR2tHRkFTQUVRZi8vL3o5TERRQWFRWllCSUFSQi8vLy9IMHNOQUJwQnB3RWdCRUgvLy84UFN3MEFHa0c0QVNBRVFmLy8vd2RMRFFBYVFja0JJQVJCLy8vL0Ewc05BQnBCMmdFZ0JFSC8vLzhCU3cwQUdrRUFRZXNCSUFSQmdJQ0FBVWtiQ3lJRlFRUjJJQWhORFFJTUNBc2dCRUVmZGtIc0Ztb0xMUUFBSVFVTElBVkZCRUFNQmdzZ0NpQUhRUUowYWlBRlFRUjJJZ1pCQVdvMkFnQWdBaUFGUVE5eElnVnJJUUlnQkNBRmRDRUVJQWdnQm1zTUFRc2dDaUFIUVFKMGFrRUJOZ0lBUVFBTElRZ2dCMEVCYWlJSElBTkhEUUFMSUFFZ0NFRUNkR29nQ2tGQWF5QURRUUowYWlnQ0FEWUNBQ0FKUVg1cUlRVkJBU0FJZENFSEEwQWdBU0FLSUFVaUEwRUNkQ0lGYWlnQ0FDQUlhaUlJUVFKMGFpQUtRVUJySUFWcUtBSUFOZ0lBSUFOQmYyb2hCVUVCSUFoMElBZHlJUWNnQXcwQUN3d0JDeUFCSUFoQkFuUnFJQXBCUUdzZ0EwRUNkR29vQWdBMkFnQkJBU0FJZENFSEN5QUFRU0FnQW1zUUN3MEFJQWRCRUhRZ0NVRUVkSEloQ3dzZ0NrR0FBV29rQUNBTEM4MHVBUXQvSXdCQkVHc2lDeVFBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FDQUFRZlFCVFFSQVFiVEFBQ2dDQUNJR1FSQWdBRUVMYWtGNGNTQUFRUXRKR3lJRlFRTjJJZ0IySWdGQkEzRUVRQ0FCUVg5elFRRnhJQUJxSWdKQkEzUWlCRUhrd0FCcUtBSUFJZ0ZCQ0dvaEFBSkFJQUVvQWdnaUF5QUVRZHpBQUdvaUJFWUVRRUcwd0FBZ0JrRitJQUozY1RZQ0FBd0JDMEhFd0FBb0FnQWFJQU1nQkRZQ0RDQUVJQU0yQWdnTElBRWdBa0VEZENJQ1FRTnlOZ0lFSUFFZ0Ftb2lBU0FCS0FJRVFRRnlOZ0lFREF3TElBVkJ2TUFBS0FJQUlnaE5EUUVnQVFSQUFrQkJBaUFBZENJQ1FRQWdBbXR5SUFFZ0FIUnhJZ0JCQUNBQWEzRkJmMm9pQUNBQVFReDJRUkJ4SWdCMklnRkJCWFpCQ0hFaUFpQUFjaUFCSUFKMklnQkJBblpCQkhFaUFYSWdBQ0FCZGlJQVFRRjJRUUp4SWdGeUlBQWdBWFlpQUVFQmRrRUJjU0lCY2lBQUlBRjJhaUlDUVFOMElnTkI1TUFBYWlnQ0FDSUJLQUlJSWdBZ0EwSGN3QUJxSWdOR0JFQkJ0TUFBSUFaQmZpQUNkM0VpQmpZQ0FBd0JDMEhFd0FBb0FnQWFJQUFnQXpZQ0RDQURJQUEyQWdnTElBRkJDR29oQUNBQklBVkJBM0kyQWdRZ0FTQUZhaUlISUFKQkEzUWlBaUFGYXlJRFFRRnlOZ0lFSUFFZ0Ftb2dBellDQUNBSUJFQWdDRUVEZGlJRVFRTjBRZHpBQUdvaEFVSEl3QUFvQWdBaEFnSi9JQVpCQVNBRWRDSUVjVVVFUUVHMHdBQWdCQ0FHY2pZQ0FDQUJEQUVMSUFFb0FnZ0xJUVFnQVNBQ05nSUlJQVFnQWpZQ0RDQUNJQUUyQWd3Z0FpQUVOZ0lJQzBISXdBQWdCellDQUVHOHdBQWdBellDQUF3TUMwRzR3QUFvQWdBaUNrVU5BU0FLUVFBZ0NtdHhRWDlxSWdBZ0FFRU1ka0VRY1NJQWRpSUJRUVYyUVFoeElnSWdBSElnQVNBQ2RpSUFRUUoyUVFSeElnRnlJQUFnQVhZaUFFRUJka0VDY1NJQmNpQUFJQUYySWdCQkFYWkJBWEVpQVhJZ0FDQUJkbXBCQW5SQjVNSUFhaWdDQUNJQktBSUVRWGh4SUFWcklRTWdBU0VDQTBBQ1FDQUNLQUlRSWdCRkJFQWdBaWdDRkNJQVJRMEJDeUFBS0FJRVFYaHhJQVZySWdJZ0F5QUNJQU5KSWdJYklRTWdBQ0FCSUFJYklRRWdBQ0VDREFFTEN5QUJLQUlZSVFrZ0FTQUJLQUlNSWdSSEJFQkJ4TUFBS0FJQUlBRW9BZ2dpQUUwRVFDQUFLQUlNR2dzZ0FDQUVOZ0lNSUFRZ0FEWUNDQXdMQ3lBQlFSUnFJZ0lvQWdBaUFFVUVRQ0FCS0FJUUlnQkZEUU1nQVVFUWFpRUNDd05BSUFJaEJ5QUFJZ1JCRkdvaUFpZ0NBQ0lBRFFBZ0JFRVFhaUVDSUFRb0FoQWlBQTBBQ3lBSFFRQTJBZ0FNQ2d0QmZ5RUZJQUJCdjM5TERRQWdBRUVMYWlJQVFYaHhJUVZCdU1BQUtBSUFJZ2RGRFFCQkFDQUZheUVDQWtBQ1FBSkFBbjlCQUNBQVFRaDJJZ0JGRFFBYVFSOGdCVUgvLy84SFN3MEFHaUFBSUFCQmdQNC9ha0VRZGtFSWNTSUFkQ0lCSUFGQmdPQWZha0VRZGtFRWNTSUJkQ0lESUFOQmdJQVBha0VRZGtFQ2NTSURkRUVQZGlBQUlBRnlJQU55YXlJQVFRRjBJQVVnQUVFVmFuWkJBWEZ5UVJ4cUN5SUlRUUowUWVUQ0FHb29BZ0FpQTBVRVFFRUFJUUFNQVFzZ0JVRUFRUmtnQ0VFQmRtc2dDRUVmUmh0MElRRkJBQ0VBQTBBQ1FDQURLQUlFUVhoeElBVnJJZ1lnQWs4TkFDQURJUVFnQmlJQ0RRQkJBQ0VDSUFNaEFBd0RDeUFBSUFNb0FoUWlCaUFHSUFNZ0FVRWRka0VFY1dvb0FoQWlBMFliSUFBZ0Joc2hBQ0FCSUFOQkFFZDBJUUVnQXcwQUN3c2dBQ0FFY2tVRVFFRUNJQWgwSWdCQkFDQUFhM0lnQjNFaUFFVU5BeUFBUVFBZ0FHdHhRWDlxSWdBZ0FFRU1ka0VRY1NJQWRpSUJRUVYyUVFoeElnTWdBSElnQVNBRGRpSUFRUUoyUVFSeElnRnlJQUFnQVhZaUFFRUJka0VDY1NJQmNpQUFJQUYySWdCQkFYWkJBWEVpQVhJZ0FDQUJkbXBCQW5SQjVNSUFhaWdDQUNFQUN5QUFSUTBCQ3dOQUlBQW9BZ1JCZUhFZ0JXc2lBeUFDU1NFQklBTWdBaUFCR3lFQ0lBQWdCQ0FCR3lFRUlBQW9BaEFpQVFSL0lBRUZJQUFvQWhRTElnQU5BQXNMSUFSRkRRQWdBa0c4d0FBb0FnQWdCV3RQRFFBZ0JDZ0NHQ0VJSUFRZ0JDZ0NEQ0lCUndSQVFjVEFBQ2dDQUNBRUtBSUlJZ0JOQkVBZ0FDZ0NEQm9MSUFBZ0FUWUNEQ0FCSUFBMkFnZ01DUXNnQkVFVWFpSURLQUlBSWdCRkJFQWdCQ2dDRUNJQVJRMERJQVJCRUdvaEF3c0RRQ0FESVFZZ0FDSUJRUlJxSWdNb0FnQWlBQTBBSUFGQkVHb2hBeUFCS0FJUUlnQU5BQXNnQmtFQU5nSUFEQWdMUWJ6QUFDZ0NBQ0lCSUFWUEJFQkJ5TUFBS0FJQUlRQUNRQ0FCSUFWcklnSkJFRThFUUVHOHdBQWdBallDQUVISXdBQWdBQ0FGYWlJRE5nSUFJQU1nQWtFQmNqWUNCQ0FBSUFGcUlBSTJBZ0FnQUNBRlFRTnlOZ0lFREFFTFFjakFBRUVBTmdJQVFiekFBRUVBTmdJQUlBQWdBVUVEY2pZQ0JDQUFJQUZxSWdFZ0FTZ0NCRUVCY2pZQ0JBc2dBRUVJYWlFQURBb0xRY0RBQUNnQ0FDSUJJQVZMQkVCQndNQUFJQUVnQldzaUFUWUNBRUhNd0FCQnpNQUFLQUlBSWdBZ0JXb2lBallDQUNBQ0lBRkJBWEkyQWdRZ0FDQUZRUU55TmdJRUlBQkJDR29oQUF3S0MwRUFJUUFnQlVFdmFpSUVBbjlCak1RQUtBSUFCRUJCbE1RQUtBSUFEQUVMUVpqRUFFSi9Od0lBUVpERUFFS0FvSUNBZ0lBRU53SUFRWXpFQUNBTFFReHFRWEJ4UWRpcTFhb0ZjellDQUVHZ3hBQkJBRFlDQUVId3d3QkJBRFlDQUVHQUlBc2lBbW9pQmtFQUlBSnJJZ2R4SWdJZ0JVME5DVUhzd3dBb0FnQWlBd1JBUWVUREFDZ0NBQ0lJSUFKcUlna2dDRTBOQ2lBSklBTkxEUW9MUWZEREFDMEFBRUVFY1EwRUFrQUNRRUhNd0FBb0FnQWlBd1JBUWZUREFDRUFBMEFnQUNnQ0FDSUlJQU5OQkVBZ0NDQUFLQUlFYWlBRFN3MERDeUFBS0FJSUlnQU5BQXNMUVFBUUV5SUJRWDlHRFFVZ0FpRUdRWkRFQUNnQ0FDSUFRWDlxSWdNZ0FYRUVRQ0FDSUFGcklBRWdBMnBCQUNBQWEzRnFJUVlMSUFZZ0JVME5CU0FHUWY3Ly8vOEhTdzBGUWV6REFDZ0NBQ0lBQkVCQjVNTUFLQUlBSWdNZ0Jtb2lCeUFEVFEwR0lBY2dBRXNOQmdzZ0JoQVRJZ0FnQVVjTkFRd0hDeUFHSUFGcklBZHhJZ1pCL3YvLy93ZExEUVFnQmhBVElnRWdBQ2dDQUNBQUtBSUVha1lOQXlBQklRQUxBa0FnQlVFd2FpQUdUUTBBSUFCQmYwWU5BRUdVeEFBb0FnQWlBU0FFSUFacmFrRUFJQUZyY1NJQlFmNy8vLzhIU3dSQUlBQWhBUXdIQ3lBQkVCTkJmMGNFUUNBQklBWnFJUVlnQUNFQkRBY0xRUUFnQm1zUUV4b01CQXNnQUNJQlFYOUhEUVVNQXd0QkFDRUVEQWNMUVFBaEFRd0ZDeUFCUVg5SERRSUxRZkREQUVId3d3QW9BZ0JCQkhJMkFnQUxJQUpCL3YvLy93ZExEUUVnQWhBVElnRkJBQkFUSWdCUERRRWdBVUYvUmcwQklBQkJmMFlOQVNBQUlBRnJJZ1lnQlVFb2FrME5BUXRCNU1NQVFlVERBQ2dDQUNBR2FpSUFOZ0lBSUFCQjZNTUFLQUlBU3dSQVFlakRBQ0FBTmdJQUN3SkFBa0FDUUVITXdBQW9BZ0FpQXdSQVFmVERBQ0VBQTBBZ0FTQUFLQUlBSWdJZ0FDZ0NCQ0lFYWtZTkFpQUFLQUlJSWdBTkFBc01BZ3RCeE1BQUtBSUFJZ0JCQUNBQklBQlBHMFVFUUVIRXdBQWdBVFlDQUF0QkFDRUFRZmpEQUNBR05nSUFRZlREQUNBQk5nSUFRZFRBQUVGL05nSUFRZGpBQUVHTXhBQW9BZ0EyQWdCQmdNUUFRUUEyQWdBRFFDQUFRUU4wSWdKQjVNQUFhaUFDUWR6QUFHb2lBellDQUNBQ1FlakFBR29nQXpZQ0FDQUFRUUZxSWdCQklFY05BQXRCd01BQUlBWkJXR29pQUVGNElBRnJRUWR4UVFBZ0FVRUlha0VIY1JzaUFtc2lBellDQUVITXdBQWdBU0FDYWlJQ05nSUFJQUlnQTBFQmNqWUNCQ0FBSUFGcVFTZzJBZ1JCME1BQVFaekVBQ2dDQURZQ0FBd0NDeUFBTFFBTVFRaHhEUUFnQVNBRFRRMEFJQUlnQTBzTkFDQUFJQVFnQm1vMkFnUkJ6TUFBSUFOQmVDQURhMEVIY1VFQUlBTkJDR3BCQjNFYklnQnFJZ0UyQWdCQndNQUFRY0RBQUNnQ0FDQUdhaUlDSUFCcklnQTJBZ0FnQVNBQVFRRnlOZ0lFSUFJZ0EycEJLRFlDQkVIUXdBQkJuTVFBS0FJQU5nSUFEQUVMSUFGQnhNQUFLQUlBSWdSSkJFQkJ4TUFBSUFFMkFnQWdBU0VFQ3lBQklBWnFJUUpCOU1NQUlRQUNRQUpBQWtBQ1FBSkFBa0FEUUNBQ0lBQW9BZ0JIQkVBZ0FDZ0NDQ0lBRFFFTUFnc0xJQUF0QUF4QkNIRkZEUUVMUWZUREFDRUFBMEFnQUNnQ0FDSUNJQU5OQkVBZ0FpQUFLQUlFYWlJRUlBTkxEUU1MSUFBb0FnZ2hBQXdBQUFzQUN5QUFJQUUyQWdBZ0FDQUFLQUlFSUFacU5nSUVJQUZCZUNBQmEwRUhjVUVBSUFGQkNHcEJCM0ViYWlJSklBVkJBM0kyQWdRZ0FrRjRJQUpyUVFkeFFRQWdBa0VJYWtFSGNSdHFJZ0VnQ1dzZ0JXc2hBQ0FGSUFscUlRY2dBU0FEUmdSQVFjekFBQ0FITmdJQVFjREFBRUhBd0FBb0FnQWdBR29pQURZQ0FDQUhJQUJCQVhJMkFnUU1Bd3NnQVVISXdBQW9BZ0JHQkVCQnlNQUFJQWMyQWdCQnZNQUFRYnpBQUNnQ0FDQUFhaUlBTmdJQUlBY2dBRUVCY2pZQ0JDQUFJQWRxSUFBMkFnQU1Bd3NnQVNnQ0JDSUNRUU54UVFGR0JFQWdBa0Y0Y1NFS0FrQWdBa0gvQVUwRVFDQUJLQUlJSWdNZ0FrRURkaUlFUVFOMFFkekFBR3BIR2lBRElBRW9BZ3dpQWtZRVFFRzB3QUJCdE1BQUtBSUFRWDRnQkhkeE5nSUFEQUlMSUFNZ0FqWUNEQ0FDSUFNMkFnZ01BUXNnQVNnQ0dDRUlBa0FnQVNBQktBSU1JZ1pIQkVBZ0JDQUJLQUlJSWdKTkJFQWdBaWdDREJvTElBSWdCallDRENBR0lBSTJBZ2dNQVFzQ1FDQUJRUlJxSWdNb0FnQWlCUTBBSUFGQkVHb2lBeWdDQUNJRkRRQkJBQ0VHREFFTEEwQWdBeUVDSUFVaUJrRVVhaUlES0FJQUlnVU5BQ0FHUVJCcUlRTWdCaWdDRUNJRkRRQUxJQUpCQURZQ0FBc2dDRVVOQUFKQUlBRWdBU2dDSENJQ1FRSjBRZVRDQUdvaUF5Z0NBRVlFUUNBRElBWTJBZ0FnQmcwQlFiakFBRUc0d0FBb0FnQkJmaUFDZDNFMkFnQU1BZ3NnQ0VFUVFSUWdDQ2dDRUNBQlJodHFJQVkyQWdBZ0JrVU5BUXNnQmlBSU5nSVlJQUVvQWhBaUFnUkFJQVlnQWpZQ0VDQUNJQVkyQWhnTElBRW9BaFFpQWtVTkFDQUdJQUkyQWhRZ0FpQUdOZ0lZQ3lBQklBcHFJUUVnQUNBS2FpRUFDeUFCSUFFb0FnUkJmbkUyQWdRZ0J5QUFRUUZ5TmdJRUlBQWdCMm9nQURZQ0FDQUFRZjhCVFFSQUlBQkJBM1lpQVVFRGRFSGN3QUJxSVFBQ2YwRzB3QUFvQWdBaUFrRUJJQUYwSWdGeFJRUkFRYlRBQUNBQklBSnlOZ0lBSUFBTUFRc2dBQ2dDQ0FzaEFTQUFJQWMyQWdnZ0FTQUhOZ0lNSUFjZ0FEWUNEQ0FISUFFMkFnZ01Bd3NnQndKL1FRQWdBRUVJZGlJQlJRMEFHa0VmSUFCQi8vLy9CMHNOQUJvZ0FTQUJRWUQrUDJwQkVIWkJDSEVpQVhRaUFpQUNRWURnSDJwQkVIWkJCSEVpQW5RaUF5QURRWUNBRDJwQkVIWkJBbkVpQTNSQkQzWWdBU0FDY2lBRGNtc2lBVUVCZENBQUlBRkJGV3AyUVFGeGNrRWNhZ3NpQVRZQ0hDQUhRZ0EzQWhBZ0FVRUNkRUhrd2dCcUlRSUNRRUc0d0FBb0FnQWlBMEVCSUFGMElnUnhSUVJBUWJqQUFDQURJQVJ5TmdJQUlBSWdCellDQUF3QkN5QUFRUUJCR1NBQlFRRjJheUFCUVI5R0czUWhBeUFDS0FJQUlRRURRQ0FCSWdJb0FnUkJlSEVnQUVZTkF5QURRUjEySVFFZ0EwRUJkQ0VESUFJZ0FVRUVjV29pQkNnQ0VDSUJEUUFMSUFRZ0J6WUNFQXNnQnlBQ05nSVlJQWNnQnpZQ0RDQUhJQWMyQWdnTUFndEJ3TUFBSUFaQldHb2lBRUY0SUFGclFRZHhRUUFnQVVFSWFrRUhjUnNpQW1zaUJ6WUNBRUhNd0FBZ0FTQUNhaUlDTmdJQUlBSWdCMEVCY2pZQ0JDQUFJQUZxUVNnMkFnUkIwTUFBUVp6RUFDZ0NBRFlDQUNBRElBUkJKeUFFYTBFSGNVRUFJQVJCV1dwQkIzRWJha0ZSYWlJQUlBQWdBMEVRYWtrYklnSkJHellDQkNBQ1FmekRBQ2tDQURjQ0VDQUNRZlREQUNrQ0FEY0NDRUg4d3dBZ0FrRUlhallDQUVINHd3QWdCallDQUVIMHd3QWdBVFlDQUVHQXhBQkJBRFlDQUNBQ1FSaHFJUUFEUUNBQVFRYzJBZ1FnQUVFSWFpRUJJQUJCQkdvaEFDQUVJQUZMRFFBTElBSWdBMFlOQXlBQ0lBSW9BZ1JCZm5FMkFnUWdBeUFDSUFOcklnUkJBWEkyQWdRZ0FpQUVOZ0lBSUFSQi93Rk5CRUFnQkVFRGRpSUJRUU4wUWR6QUFHb2hBQUovUWJUQUFDZ0NBQ0lDUVFFZ0FYUWlBWEZGQkVCQnRNQUFJQUVnQW5JMkFnQWdBQXdCQ3lBQUtBSUlDeUVCSUFBZ0F6WUNDQ0FCSUFNMkFnd2dBeUFBTmdJTUlBTWdBVFlDQ0F3RUN5QURRZ0EzQWhBZ0F3Si9RUUFnQkVFSWRpSUFSUTBBR2tFZklBUkIvLy8vQjBzTkFCb2dBQ0FBUVlEK1AycEJFSFpCQ0hFaUFIUWlBU0FCUVlEZ0gycEJFSFpCQkhFaUFYUWlBaUFDUVlDQUQycEJFSFpCQW5FaUFuUkJEM1lnQUNBQmNpQUNjbXNpQUVFQmRDQUVJQUJCRldwMlFRRnhja0VjYWdzaUFEWUNIQ0FBUVFKMFFlVENBR29oQVFKQVFiakFBQ2dDQUNJQ1FRRWdBSFFpQm5GRkJFQkJ1TUFBSUFJZ0JuSTJBZ0FnQVNBRE5nSUFJQU1nQVRZQ0dBd0JDeUFFUVFCQkdTQUFRUUYyYXlBQVFSOUdHM1FoQUNBQktBSUFJUUVEUUNBQklnSW9BZ1JCZUhFZ0JFWU5CQ0FBUVIxMklRRWdBRUVCZENFQUlBSWdBVUVFY1dvaUJpZ0NFQ0lCRFFBTElBWWdBellDRUNBRElBSTJBaGdMSUFNZ0F6WUNEQ0FESUFNMkFnZ01Bd3NnQWlnQ0NDSUFJQWMyQWd3Z0FpQUhOZ0lJSUFkQkFEWUNHQ0FISUFJMkFnd2dCeUFBTmdJSUN5QUpRUWhxSVFBTUJRc2dBaWdDQ0NJQUlBTTJBZ3dnQWlBRE5nSUlJQU5CQURZQ0dDQURJQUkyQWd3Z0F5QUFOZ0lJQzBIQXdBQW9BZ0FpQUNBRlRRMEFRY0RBQUNBQUlBVnJJZ0UyQWdCQnpNQUFRY3pBQUNnQ0FDSUFJQVZxSWdJMkFnQWdBaUFCUVFGeU5nSUVJQUFnQlVFRGNqWUNCQ0FBUVFocUlRQU1Bd3RCc01BQVFUQTJBZ0JCQUNFQURBSUxBa0FnQ0VVTkFBSkFJQVFvQWh3aUFFRUNkRUhrd2dCcUlnTW9BZ0FnQkVZRVFDQURJQUUyQWdBZ0FRMEJRYmpBQUNBSFFYNGdBSGR4SWdjMkFnQU1BZ3NnQ0VFUVFSUWdDQ2dDRUNBRVJodHFJQUUyQWdBZ0FVVU5BUXNnQVNBSU5nSVlJQVFvQWhBaUFBUkFJQUVnQURZQ0VDQUFJQUUyQWhnTElBUW9BaFFpQUVVTkFDQUJJQUEyQWhRZ0FDQUJOZ0lZQ3dKQUlBSkJEMDBFUUNBRUlBSWdCV29pQUVFRGNqWUNCQ0FBSUFScUlnQWdBQ2dDQkVFQmNqWUNCQXdCQ3lBRUlBVkJBM0kyQWdRZ0JDQUZhaUlESUFKQkFYSTJBZ1FnQWlBRGFpQUNOZ0lBSUFKQi93Rk5CRUFnQWtFRGRpSUJRUU4wUWR6QUFHb2hBQUovUWJUQUFDZ0NBQ0lDUVFFZ0FYUWlBWEZGQkVCQnRNQUFJQUVnQW5JMkFnQWdBQXdCQ3lBQUtBSUlDeUVCSUFBZ0F6WUNDQ0FCSUFNMkFnd2dBeUFBTmdJTUlBTWdBVFlDQ0F3QkN5QURBbjlCQUNBQ1FRaDJJZ0JGRFFBYVFSOGdBa0gvLy84SFN3MEFHaUFBSUFCQmdQNC9ha0VRZGtFSWNTSUFkQ0lCSUFGQmdPQWZha0VRZGtFRWNTSUJkQ0lGSUFWQmdJQVBha0VRZGtFQ2NTSUZkRUVQZGlBQUlBRnlJQVZ5YXlJQVFRRjBJQUlnQUVFVmFuWkJBWEZ5UVJ4cUN5SUFOZ0ljSUFOQ0FEY0NFQ0FBUVFKMFFlVENBR29oQVFKQUFrQWdCMEVCSUFCMElnVnhSUVJBUWJqQUFDQUZJQWR5TmdJQUlBRWdBellDQUF3QkN5QUNRUUJCR1NBQVFRRjJheUFBUVI5R0czUWhBQ0FCS0FJQUlRVURRQ0FGSWdFb0FnUkJlSEVnQWtZTkFpQUFRUjEySVFVZ0FFRUJkQ0VBSUFFZ0JVRUVjV29pQmlnQ0VDSUZEUUFMSUFZZ0F6WUNFQXNnQXlBQk5nSVlJQU1nQXpZQ0RDQURJQU0yQWdnTUFRc2dBU2dDQ0NJQUlBTTJBZ3dnQVNBRE5nSUlJQU5CQURZQ0dDQURJQUUyQWd3Z0F5QUFOZ0lJQ3lBRVFRaHFJUUFNQVFzQ1FDQUpSUTBBQWtBZ0FTZ0NIQ0lBUVFKMFFlVENBR29pQWlnQ0FDQUJSZ1JBSUFJZ0JEWUNBQ0FFRFFGQnVNQUFJQXBCZmlBQWQzRTJBZ0FNQWdzZ0NVRVFRUlFnQ1NnQ0VDQUJSaHRxSUFRMkFnQWdCRVVOQVFzZ0JDQUpOZ0lZSUFFb0FoQWlBQVJBSUFRZ0FEWUNFQ0FBSUFRMkFoZ0xJQUVvQWhRaUFFVU5BQ0FFSUFBMkFoUWdBQ0FFTmdJWUN3SkFJQU5CRDAwRVFDQUJJQU1nQldvaUFFRURjallDQkNBQUlBRnFJZ0FnQUNnQ0JFRUJjallDQkF3QkN5QUJJQVZCQTNJMkFnUWdBU0FGYWlJRUlBTkJBWEkyQWdRZ0F5QUVhaUFETmdJQUlBZ0VRQ0FJUVFOMklnVkJBM1JCM01BQWFpRUFRY2pBQUNnQ0FDRUNBbjlCQVNBRmRDSUZJQVp4UlFSQVFiVEFBQ0FGSUFaeU5nSUFJQUFNQVFzZ0FDZ0NDQXNoQlNBQUlBSTJBZ2dnQlNBQ05nSU1JQUlnQURZQ0RDQUNJQVUyQWdnTFFjakFBQ0FFTmdJQVFiekFBQ0FETmdJQUN5QUJRUWhxSVFBTElBdEJFR29rQUNBQUMwUUJBWDhnQUNBQUtBSVFJQUZxSWdFMkFoQWdBQ0FCUVFkeE5nSUlRWDhoQWlBQklBQW9BZ3hCQTNSTkJIOGdBQ0FBS0FJQUlBRkJBM1pxTmdJRVFRQUZRWDhMQytVSEFRaC9JQUFnQkVFQUlBWnJJQUlnQWlBR2FrRUFTQnNpQWlBQ0lBUktHeUlDYWlBQUlBSkJBRW9iSWdrZ0JVRUFJQWRySUFNZ0F5QUhha0VBU0JzaUFDQUFJQVZLR3lJQUlBUnNhaUFKSUFCQkFFb2JJUU1nQjBFQUlBQnJJQUJCSDNWeElnbHJJQUFnQjJvaUFDQUZheUlNUVFBZ0FDQUZTaHNpRDJzaEN5QUdRUUFnQW1zaURpQUNRUjkxY1NJTmF5QUNJQVpxSWdBZ0JHdEJBQ0FBSUFSS0lnVWJJZ3BySVFBQ1FDQUNRUUJJSUFWeUloQkZCRUFnQ1FSQUEwQWdBU0FESUFBUUZTQUlhaUVCSUFsQmYyb2lDUTBBQ3dzZ0MwVU5BUU5BSUFFZ0F5QUFFQlVnQ0dvaEFTQURJQVJxSVFNZ0MwRi9haUlMRFFBTERBRUxBa0FnQ1VVTkFDQU5SUVJBQTBBZ0FDRUhJQUVoQWlBRElRVWdBQVJBQTBBZ0FpQUZMUUFBT2dBQUlBSkJBV29oQWlBRlFRRnFJUVVnQjBGL2FpSUhEUUFMQ3lBS0JFQWdBaUFGUVg5cUxRQUFJQW9RQnhvTElBRWdDR29oQVNBSlFYOXFJZ2tOQUF3Q0FBc0FDeUFCSUE1cUlRWURRQ0FCSUFNdEFBQWdEUkFISVFFZ0FDRUhJQVloQWlBRElRVWdBQVJBQTBBZ0FpQUZMUUFBT2dBQUlBSkJBV29oQWlBRlFRRnFJUVVnQjBGL2FpSUhEUUFMQ3lBS0JFQWdBaUFGUVg5cUxRQUFJQW9RQnhvTElBWWdDR29oQmlBQklBaHFJUUVnQ1VGL2FpSUpEUUFMQ3lBTFJRMEFJQTFGQkVBRFFDQUFJUWNnQVNFQ0lBTWhCU0FBQkVBRFFDQUNJQVV0QUFBNkFBQWdBa0VCYWlFQ0lBVkJBV29oQlNBSFFYOXFJZ2NOQUFzTElBb0VRQ0FDSUFWQmYyb3RBQUFnQ2hBSEdnc2dBU0FJYWlFQklBTWdCR29oQXlBTFFYOXFJZ3NOQUF3Q0FBc0FDeUFCSUE1cUlRa0RRQ0FCSUFNdEFBQWdEUkFISVFFZ0FDRUhJQWtoQWlBRElRVWdBQVJBQTBBZ0FpQUZMUUFBT2dBQUlBSkJBV29oQWlBRlFRRnFJUVVnQjBGL2FpSUhEUUFMQ3lBS0JFQWdBaUFGUVg5cUxRQUFJQW9RQnhvTElBZ2dDV29oQ1NBQklBaHFJUUVnQXlBRWFpRURJQXRCZjJvaUN3MEFDd3NDUUNBUFJRMEFJQU1nQkdzaEF5QVFSUVJBQTBBZ0FTQURJQUFRRlNBSWFpRUJJQXhCZjJvaURBMEFEQUlBQ3dBTElBMUZCRUFEUUNBRElRSWdBU0VGSUFBaEJ5QUFCRUFEUUNBRklBSXRBQUE2QUFBZ0JVRUJhaUVGSUFKQkFXb2hBaUFIUVg5cUlnY05BQXNMSUFvRVFDQUZJQUpCZjJvdEFBQWdDaEFIR2dzZ0FTQUlhaUVCSUF4QmYyb2lEQTBBREFJQUN3QUxJQUVnRG1vaENRTkFJQUVnQXkwQUFDQU5FQWNoQVNBQUlRY2dDU0VDSUFNaEJTQUFCRUFEUUNBQ0lBVXRBQUE2QUFBZ0FrRUJhaUVDSUFWQkFXb2hCU0FIUVg5cUlnY05BQXNMSUFvRVFDQUNJQVZCZjJvdEFBQWdDaEFIR2dzZ0NDQUphaUVKSUFFZ0NHb2hBU0FNUVg5cUlnd05BQXNMQy9RQ0FRTi9JQUZCQTNSQjhEWnFJZ01vQWdBaEJTQURMUUFFSVFNZ0FVRURkRUd3TldvaUFTMEFCQ0VFQWtBZ0FTZ0NBRUVFUmdSQUlBSWdCRUVCZEdvdUFRQWhBU0FGUVFSR0JFQWdBU0FDSUFOQkFYUnFMZ0VBYWtFQmFrRUJkUThMQW44Z0FDZ0N6QUVpQWdSQUlBQW9BZ1FnQWlnQ0JFWU1BUXRCQUF0RkRRRWdBU0FBS0FMTUFTQURRUUYwYWk0QkhHcEJBV3BCQVhVUEN5QUZRUVJHQkVBZ0FpQURRUUYwYWk0QkFDRUJBbjhnQUNnQ3lBRWlBZ1JBSUFBb0FnUWdBaWdDQkVZTUFRdEJBQXRGRFFFZ0FTQUFLQUxJQVNBRVFRRjBhaTRCSEdwQkFXcEJBWFVQQ3dKL0FuOGdBQ2dDeUFFaUFRUkFJQUFvQWdRZ0FTZ0NCRVlNQVF0QkFBdEZCRUJCQUNFQ1FRQU1BUXRCQVNFQ0lBQW9Bc2dCSUFSQkFYUnFMZ0VjQ3lFQkFuOGdBQ2dDekFFaUJBUkFJQUFvQWdRZ0JDZ0NCRVlNQVF0QkFBdEZEUUFnQUNnQ3pBRWdBMEVCZEdvdUFSd2hBQ0FDUlFSQUlBQVBDeUFBSUFGcVFRRnFRUUYxSVFFTElBRUxpUWNCQjM4Z0F5QUZhaUlOSUFFdUFRQWlERUVDZFdvaEF5QUVJQVpxSWc0Z0FTNEJBaUlQUVFKMWFpRUVJQUlvQWdoQkJIUWhDU0FDS0FJRVFRUjBJUW9nQUNBR1FRUjBhaUFGYWlFTEFrQWdERUVEY1VFRWRDQVBRUU54UVFKMGNrSFFPMm9vQWdBaURFRU9UUVJBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUlBeEJBV3NPRGdFQ0F3UUZCZ2NJQ1FvTERBME9BQXNnQWlnQ0FDQUxJQU1nQkNBS0lBa2dCeUFJUVJBUURBd1BDeUFDS0FJQUlBc2dBeUFFUVg1cUlBb2dDU0FISUFoQkFCQWtEQTRMSUFJb0FnQWdDeUFESUFSQmZtb2dDaUFKSUFjZ0NCQkhEQTBMSUFJb0FnQWdDeUFESUFSQmZtb2dDaUFKSUFjZ0NFRUJFQ1FNREFzZ0FpZ0NBQ0FMSUFOQmZtb2dCQ0FLSUFrZ0J5QUlRUUFRSXd3TEN5QUNLQUlBSUFzZ0EwRithaUFFUVg1cUlBb2dDU0FISUFoQkFCQWFEQW9MSUFJb0FnQWdDeUFEUVg1cUlBUkJmbW9nQ2lBSklBY2dDRUVBRUNFTUNRc2dBaWdDQUNBTElBTkJmbW9nQkVGK2FpQUtJQWtnQnlBSVFRSVFHZ3dJQ3lBQ0tBSUFJQXNnQTBGK2FpQUVJQW9nQ1NBSElBZ1FSZ3dIQ3lBQ0tBSUFJQXNnQTBGK2FpQUVRWDVxSUFvZ0NTQUhJQWhCQUJBaURBWUxJQUlvQWdBZ0N5QURRWDVxSUFSQmZtb2dDaUFKSUFjZ0NCQkZEQVVMSUFJb0FnQWdDeUFEUVg1cUlBUkJmbW9nQ2lBSklBY2dDRUVCRUNJTUJBc2dBaWdDQUNBTElBTkJmbW9nQkNBS0lBa2dCeUFJUVFFUUl3d0RDeUFDS0FJQUlBc2dBMEYrYWlBRVFYNXFJQW9nQ1NBSElBaEJBUkFhREFJTElBSW9BZ0FnQ3lBRFFYNXFJQVJCZm1vZ0NpQUpJQWNnQ0VFQkVDRU1BUXNnQWlnQ0FDQUxJQU5CZm1vZ0JFRithaUFLSUFrZ0J5QUlRUU1RR2dzZ0RVRUJkaUFCTGdFQUlnbEJBM1ZxSVFNZ0RrRUJkaUFCTGdFQ0lnRkJBM1ZxSVFRZ0FpZ0NBQ0FDS0FJRUlnb2dBaWdDQ0NJTGJFRUlkR29oQWlBQUlBWkJBblJCZUhGcUlBVkJBWFpxUVlBQ2FpRUZJQWhCQVhZaEJpQUhRUUYySVFjZ0FVRUhjU0VJSUF0QkEzUWhBQ0FLUVFOMElRRUNRQ0FKUVFkeElnbEZEUUFnQ0VVTkFDQUNJQVVnQXlBRUlBRWdBQ0FKSUFnZ0J5QUdFRWdQQ3lBSkJFQWdBaUFGSUFNZ0JDQUJJQUFnQ1NBSElBWVFTdzhMSUFnRVFDQUNJQVVnQXlBRUlBRWdBQ0FJSUFjZ0JoQktEd3NnQWlBRklBTWdCQ0FCSUFBZ0J5QUdRUWdRRENBQ0lBQWdBV3hxSUFWQlFHc2dBeUFFSUFFZ0FDQUhJQVpCQ0JBTUM4Y0JBUVIvSUFBb0FnUWhBZ0pBSUFBb0FneEJBM1FnQUNnQ0VHc2lBMEVnVGdSQUlBSW9BQUFpQVVFWWRDQUJRUWgwUVlDQS9BZHhjaUFCUVFoMlFZRCtBM0VnQVVFWWRuSnlJUUVnQUNnQ0NDSUFSUTBCSUFFZ0FIUWdBaTBBQkVFSUlBQnJkbklQQ3lBRFFRRklCRUJCQUE4TElBSXRBQUFnQUNnQ0NDSUFRUmhxSWdSMElRRWdBQ0FEYWtGNGFpSUFRUUZJRFFBRFFDQUNMUUFCSUFSQmVHb2lCSFFnQVhJaEFTQUFRUWhLSVFNZ0FrRUJhaUVDSUFCQmVHb2hBQ0FERFFBTEN5QUJDNHdFQVFkL0FrQWdBRUYvYWlJSUxRQUFJZ1VnQUMwQUFDSUdheUlFSUFSQkgzVWlCR29nQkhNZ0FpZ0NCRThOQUNBQVFYNXFMUUFBSWdRZ0JXc2lCeUFIUVI5MUlnZHFJQWR6SUFJb0FnZ2lDVThOQUNBQUxRQUJJZ2NnQm1zaUNpQUtRUjkxSWdwcUlBcHpJQWxQRFFBZ0FVRURUUVJBSUFnZ0JTQUJJQUlvQWdCcVFYOXFMUUFBSWdoQmYzTWlDU0FJUVFGcUlnZ2dCaUFGYTBFQ2RDQUhheUFFYWtFRWFrRURkU0lGSUFVZ0NFb2JJQVVnQ1VnYklnVnFRYkF1YWkwQUFEb0FBQ0FBSUFZZ0JXdEJzQzVxTFFBQU9nQUFEQUVMSUFnZ0JTQUhhaUFFUVFGMGFrRUNha0VDZGpvQUFDQUFJQVlnQjBFQmRHb2dCR3BCQW1wQkFuWTZBQUFMQWtBZ0FDQURhaUlBUVg5cUlnY3RBQUFpQXlBQUxRQUFJZ1ZySWdZZ0JrRWZkU0lHYWlBR2N5QUNLQUlFVHcwQUlBQkJmbW90QUFBaUJpQURheUlFSUFSQkgzVWlCR29nQkhNZ0FpZ0NDQ0lJVHcwQUlBQXRBQUVpQkNBRmF5SUpJQWxCSDNVaUNXb2dDWE1nQ0U4TkFDQUJRUU5OQkVBZ0J5QUJJQUlvQWdCcVFYOXFMUUFBSWdGQmYzTWlBaUFCUVFGcUlnY2dCU0FEYTBFQ2RDQUVheUFHYWtFRWFrRURkU0lCSUFFZ0Iwb2JJQUVnQWtnYklnRWdBMnBCc0M1cUxRQUFPZ0FBSUFBZ0JTQUJhMEd3TG1vdEFBQTZBQUFQQ3lBSElBTWdCR29nQmtFQmRHcEJBbXBCQW5ZNkFBQWdBQ0FGSUFSQkFYUnFJQVpxUVFKcVFRSjJPZ0FBQ3d0SEFBSkFJQUZCQkUwRVFBSkFBa0FDUUFKQUlBRkJBV3NPQkFFQ0F3VUFDeUFBS0FMSUFROExJQUFvQXN3QkR3c2dBQ2dDMEFFUEN5QUFLQUxVQVE4TFFRQWhBQXNnQUF1bEF3RUxmMEVBSUFOcklndEJBWFFoQkNBQklBSW9BZ0JxUVg5cUxRQUFJZ0ZCQVdvaENTQUJRWDl6SVFvQ1FDQUFJQU5ySWdjdEFBQWlCU0FBTFFBQUlnWnJJZ0VnQVVFZmRTSUJhaUFCY3lBQ0tBSUVJZ0ZQRFFBZ0FDQUVhaTBBQUNJTklBVnJJZ2dnQ0VFZmRTSUlhaUFJY3lBQ0tBSUlJZ2hQRFFBZ0FDQURhaTBBQUNJT0lBWnJJZ3dnREVFZmRTSU1haUFNY3lBSVR3MEFJQWNnQ2lBSklBWWdCV3RCQW5RZ0Rtc2dEV3BCQkdwQkEzVWlBU0FCSUFsS0d5QUJJQXBJR3lJQklBVnFRYkF1YWkwQUFEb0FBQ0FBSUFZZ0FXdEJzQzVxTFFBQU9nQUFJQUlvQWdRaEFRc0NRQ0FBUVFGcUlnVWdDMm9pQ3kwQUFDSUdJQUF0QUFFaUFHc2lCeUFIUVI5MUlnZHFJQWR6SUFGUERRQWdCQ0FGYWkwQUFDSUJJQVpySWdRZ0JFRWZkU0lFYWlBRWN5QUNLQUlJSWdKUERRQWdBeUFGYWkwQUFDSURJQUJySWdRZ0JFRWZkU0lFYWlBRWN5QUNUdzBBSUFzZ0NpQUpJQUFnQm10QkFuUWdBMnNnQVdwQkJHcEJBM1VpQVNBQklBbEtHeUFCSUFwSUd5SUJJQVpxUWJBdWFpMEFBRG9BQUNBRklBQWdBV3RCc0M1cUxRQUFPZ0FBQ3d0VkFRSi9RYkRFQUNnQ0FDSUJJQUJCQTJwQmZIRWlBbW9oQUFKQUlBSkJBVTVCQUNBQUlBRk5HdzBBSUFBL0FFRVFkRXNFUUNBQUVBRkZEUUVMUWJERUFDQUFOZ0lBSUFFUEMwR3d3QUJCTURZQ0FFRi9DelFCQVg4Q1FDQUJRUkJMRFFBZ0FDZ0NCQ0FCUVFKMGFpZ0NBQ0lBUlEwQUlBQW9BaFJCQWtrTkFDQUFLQUlBSVFJTElBSUxnZ1FCQTM4Z0FrR0FCRThFUUNBQUlBRWdBaEFBR2lBQUR3c2dBQ0FDYWlFREFrQWdBQ0FCYzBFRGNVVUVRQUpBSUFKQkFVZ0VRQ0FBSVFJTUFRc2dBRUVEY1VVRVFDQUFJUUlNQVFzZ0FDRUNBMEFnQWlBQkxRQUFPZ0FBSUFGQkFXb2hBU0FDUVFGcUlnSWdBMDhOQVNBQ1FRTnhEUUFMQ3dKQUlBTkJmSEVpQkVIQUFFa05BQ0FDSUFSQlFHb2lCVXNOQUFOQUlBSWdBU2dDQURZQ0FDQUNJQUVvQWdRMkFnUWdBaUFCS0FJSU5nSUlJQUlnQVNnQ0REWUNEQ0FDSUFFb0FoQTJBaEFnQWlBQktBSVVOZ0lVSUFJZ0FTZ0NHRFlDR0NBQ0lBRW9BaHcyQWh3Z0FpQUJLQUlnTmdJZ0lBSWdBU2dDSkRZQ0pDQUNJQUVvQWlnMkFpZ2dBaUFCS0FJc05nSXNJQUlnQVNnQ01EWUNNQ0FDSUFFb0FqUTJBalFnQWlBQktBSTROZ0k0SUFJZ0FTZ0NQRFlDUENBQlFVQnJJUUVnQWtGQWF5SUNJQVZORFFBTEN5QUNJQVJQRFFFRFFDQUNJQUVvQWdBMkFnQWdBVUVFYWlFQklBSkJCR29pQWlBRVNRMEFDd3dCQ3lBRFFRUkpCRUFnQUNFQ0RBRUxJQU5CZkdvaUJDQUFTUVJBSUFBaEFnd0JDeUFBSVFJRFFDQUNJQUV0QUFBNkFBQWdBaUFCTFFBQk9nQUJJQUlnQVMwQUFqb0FBaUFDSUFFdEFBTTZBQU1nQVVFRWFpRUJJQUpCQkdvaUFpQUVUUTBBQ3dzZ0FpQURTUVJBQTBBZ0FpQUJMUUFBT2dBQUlBRkJBV29oQVNBQ1FRRnFJZ0lnQTBjTkFBc0xJQUFMd1JnQklIOGpBRUhRQTJzaUJpUUFJQUVvQWdnaEZDQUJJQUVvQWdRaUNpQUNiQ0lhSUFOcUVCMGdBU2dDQUNFSklBQkJBRFlDQ0NBQVFpZzNBaFFnQUVJQU53SU1JQUJCQmpZQ0FDQURRUVIwSVFjQ1FBSkFBa0FnQkVGK2FpSUVRUVZMRFFBQ1FDQUVRUUZyRGdRQkFRRUJBQXNNQVFzZ0JrRUFOZ0lNSUFZZ0ZEWUNHQ0FHSUFvMkFoUWdCaUFGTmdJUUlBVUVRQ0FHUWRBQWFpQUdRUXhxSUFaQkVHb2dCeUFDUVFSMFFRQkJBRUVRUVJBUURnd0NDd3NnQmtIUUFHcEJBRUdBQXhBSEdpQUpJQnBCQ0hScUlBZHFJUXdnQmtJQU53TklJQVpCUUd0Q0FEY0RBQ0FHUWdBM0F6Z2dCa0lBTndNd0lBWkNBRGNES0NBR1FnQTNBeUFnQmtJQU53TVlJQVpDQURjREVFRUFJUWtDZjBFQUlBSkZEUUFhUVFBZ0FFRUFJQXByUWRnQmJHb29Bc1FCUlEwQUdpQUdJQXdnQ2tFRWRHc2lCQzBBQlNBRUxRQUVhaUFFTFFBR2FpQUVMUUFIYWlJWElBUXRBQU1nQkMwQUFpQUVMUUFCSUFRdEFBQnFhbW9pRm1vaUJTQUVMUUFMSUFRdEFBb2dCQzBBQ1NBRUxRQUlhbXBxSWhKcklBUXRBQThnQkMwQURpQUVMUUFOSUFRdEFBeHFhbW9pRTJzaUNEWUNGQ0FHSUFVZ0Vtb2dFMm9pQ1RZQ0VFRUJDeUVGQW44Q1FDQUNJQlJCZjJwSEJFQWdBQ0FLUWRnQmJHb29Bc1FCRFFFTElBVU1BUXNnQmlBTUlBcEJDSFJxSWdJdEFBVWdBaTBBQkdvZ0FpMEFCbW9nQWkwQUIyb2lIaUFDTFFBRElBSXRBQUlnQWkwQUFTQUNMUUFBYW1wcUloOXFJZ1FnQWkwQUN5QUNMUUFLSUFJdEFBa2dBaTBBQ0dwcWFpSVlheUFDTFFBUElBSXRBQTRnQWkwQURTQUNMUUFNYW1wcUlobHJJQWhxSWdnMkFoUWdCaUFFSUJocUlBbHFJQmxxSWdrMkFoQkJBU0VRSUFWQkFXb0xJUWRCQUNFRUFuOENRQ0FEUlEwQUlBQkJiR29vQWdCRkRRQWdCaUFNUVg5cUlnSWdDa0VHZENJT2FpSUVJQXBCQkhRaUMyb3RBQUFnQkMwQUFHb2dCQ0FLUVFWMElnOXFMUUFBYWlBRUlBcEJNR3dpRFdvdEFBQnFJaHNnQWlBTmFpMEFBQ0FDSUE5cUxRQUFJQUlnQzJvdEFBQWdBaTBBQUdwcWFpSWNhaUlSSUFRZ0Rtb2lBaUFMYWkwQUFDQUNMUUFBYWlBQ0lBOXFMUUFBYWlBQ0lBMXFMUUFBYWlJVmF5QUNJQTVxSWdJZ0Myb3RBQUFnQWkwQUFHb2dBaUFQYWkwQUFHb2dBaUFOYWkwQUFHb2lEMnNpQkRZQ0lDQUdJQkVnRldvZ0NXb2dEMm9pQ1RZQ0VDQUhRUUZxSVF0QkFRd0JDeUFISVF0QkFBc2hBZ0pBQWtBQ1FBSkFBa0FDUUNBRElBcEJmMnBIQkVBZ0FDZ0NuQU1OQVF0QkFDRU9JQUpCQUVjaEVTQUhEUUVNQWdzZ0JpQUVJQXhCRUdvaUJDQUtRUVowSWgxcUlnQWdDa0VFZENJTmFpMEFBQ0FBTFFBQWFpQUFJQXBCQlhRaURtb3RBQUJxSUFBZ0NrRXdiQ0lSYWkwQUFHb2lJQ0FFSUJGcUxRQUFJQVFnRG1vdEFBQWdCQ0FOYWkwQUFDQU1MUUFRYW1wcUlpRnFJaUlnQUNBZGFpSUFJQTFxTFFBQUlBQXRBQUJxSUFBZ0Rtb3RBQUJxSUFBZ0VXb3RBQUJxSWd4cklBQWdIV29pQUNBTmFpMEFBQ0FBTFFBQWFpQUFJQTVxTFFBQWFpQUFJQkZxTFFBQWFpSU5hMm9pQkRZQ0lDQUdJQXdnSW1vZ0NXb2dEV29pQ1RZQ0VDQUNRUUJISVJGQkFTRU9JQUpCQVdvaEFDQUxRUUZxSVFzQ1FDQUhEUUFnQWtVTkFDQUdJQnNnSEdvZ0ZXb2dEMm9nSVdzZ0lHc2dER3NnRFd0QkJYVWlDRFlDRkF3REN5QUhSUTBDSUFBaEFnc2dCaUFJSUFkQkEycDFJZ2cyQWhRTEFrQWdFRVVOQUNBRlJRMEFJQUlOQUNBR0lCWWdGMm9nRW1vZ0Uyb2dHV3NnR0dzZ0htc2dIMnRCQlhVaUJEWUNJRUVCSVJCQkFTRU5EQU1MSUJCQkFFY2hFQ0FGUVFCSElRMGdBa1VOQWd3QkN5QVFRUUJISVJBZ0JVRUFSeUVOSUFBaEFnc2dCaUFFSUFKQkEycDFJZ1EyQWlBTElBWUNmeUFMUVg5cUlnQkJBazBFUUFKQUFrQUNRQ0FBUVFGckRnSUJBZ0FMSUFsQkJIWU1Bd3NnQ1VFRmRnd0NDeUFKUVJWc1FRcDFEQUVMSUFsQkJuWUxJZ0EyQWhBQ1FDQUVJQWh5UlFSQUlBWWdBRFlDU0NBR0lBQTJBa3dnQmlBQU5nSkVJQVlnQURZQ1FDQUdJQUEyQWp3Z0JpQUFOZ0k0SUFZZ0FEWUNOQ0FHSUFBMkFqQWdCaUFBTmdJc0lBWWdBRFlDS0NBR0lBQTJBaVFnQmlBQU5nSWdJQVlnQURZQ0hDQUdJQUEyQWhnZ0JpQUFOZ0lVREFFTElBWWdBQ0FJYWlJRklBUnJOZ0pBSUFZZ0JTQUVRUUYxSWdKck5nSXdJQVlnQWlBRmFqWUNJQ0FHSUFRZ0JXbzJBaEFnQmlBQUlBaHJJZ1VnQkdzMkFrd2dCaUFGSUFKck5nSThJQVlnQWlBRmFqWUNMQ0FHSUFRZ0JXbzJBaHdnQmlBQUlBaEJBWFVpQjJvaUJTQUVhellDUkNBR0lBVWdBbXMyQWpRZ0JpQUNJQVZxTmdJa0lBWWdCQ0FGYWpZQ0ZDQUdJQUFnQjJzaUFDQUVhellDU0NBR0lBQWdBbXMyQWpnZ0JpQUFJQUpxTmdJb0lBWWdBQ0FFYWpZQ0dBc2dCa0hRQUdvaENDQUdRUkJxSVFCQkFDRUVBMEFnQ0NBQUlBUkJESEZxS0FJQUlnSkIvd0VnQWtIL0FVZ2JJZ0pCQUNBQ1FRQktHem9BQUNBQUlBQkJFR29nQkVFQmFpSUVRVDl4R3lFQUlBaEJBV29oQ0NBRVFZQUNSdzBBQ3lBQktBSUFJQW9nRkd3aUFFRUlkR29nR2tFR2RHb2dBMEVEZEdvaEF5QUtRUVIwSVF3Z0NrRUdkQ0VhSUFCQkJuUWhIVUVBSUFwQkEzUWlDMnNoSUNBR1FkQUNhaUVoSUFaQlFHc2hJa0VBSVFVRFFDQUdRZ0EzQTBnZ0lrSUFOd01BSUFaQ0FEY0RPQ0FHUWdBM0F6QWdCa0lBTndNb0lBWkNBRGNESUNBR1FnQTNBeGdnQmtJQU53TVFRUUFoQ0VFQUlRUkJBQ0VKSUEwRVFDQUdJQU1nSUdvaUFDMEFBeUFBTFFBQ2FpSVhJQUF0QUFFZ0FDMEFBR29pRm1vaUFpQUFMUUFGSUFBdEFBUnFJaEpySUFBdEFBY2dBQzBBQm1vaUUyc2lDRFlDRkNBR0lBSWdFbW9nRTJvaUJEWUNFRUVCSVFrTElCQUVRQ0FHSUFNZ0dtb2lBQzBBQXlBQUxRQUNhaUllSUFBdEFBRWdBQzBBQUdvaUgyb2lBaUFBTFFBRklBQXRBQVJxSWhocklBQXRBQWNnQUMwQUJtb2lHV3NnQ0dvaUNEWUNGQ0FHSUFJZ0dHb2dCR29nR1dvaUJEWUNFQ0FKUVFGcUlRa0xRUUFoQUFKL0lCRkZCRUFnQ1NFSFFRQU1BUXNnQmlBRFFYOXFJZ0FnREdvaUFpQUxhaTBBQUNBQ0xRQUFhaUliSUFBZ0Myb3RBQUFnQUMwQUFHb2lIR29pQnlBQ0lBeHFJZ0FnQzJvdEFBQWdBQzBBQUdvaUZXc2dBQ0FNYWlJQUlBdHFMUUFBSUFBdEFBQnFJZzlySWdBMkFpQWdCaUFISUJWcUlBUnFJQTlxSWdRMkFoQWdDVUVCYWlFSFFRRUxJUUlDUUNBR0FuOENRQUpBQWtBZ0RrVUVRQ0FKRFFFTUFnc2dCaUFBSUFOQkNHb2lDaUFNYWlJQUlBdHFMUUFBSUFBdEFBQnFJaU1nQ2lBTGFpMEFBQ0FETFFBSWFpSWthaUlsSUFBZ0RHb2lBQ0FMYWkwQUFDQUFMUUFBYWlJS2F5QUFJQXhxSWdBZ0Myb3RBQUFnQUMwQUFHb2lGR3RxSWdBMkFpQWdCaUFLSUNWcUlBUnFJQlJxSWdRMkFoQWdBa0VCYWlFQ0lBZEJBV29oQnlBUlFRRnpJQWxCQUVkeVJRUkFJQVlnR3lBY2FpQVZhaUFQYWlBa2F5QWpheUFLYXlBVWEwRUVkU0lJTmdJVURBTUxJQWxGRFFJTElBWWdDQ0FKUVFKcWRTSUlOZ0lVQ3lBV0lCZHFJQkpxSUJOcUlCbHJJQmhySUI1cklCOXJRUVIxSUJBZ0RTQUNSWEZ4UVFGR0RRRWFJQUpGRFFJTElBQWdBa0VDYW5VTElnQTJBaUFMSUFZQ2Z5QUhRWDlxSWdKQkFrMEVRQUpBQWtBQ1FDQUNRUUZyRGdJQkFnQUxJQVJCQTNZTUF3c2dCRUVFZGd3Q0N5QUVRUlZzUVFsMkRBRUxJQVJCQlhZTElnUTJBaEFDUUNBQUlBaHlSUVJBSUFZZ0JEWUNTQ0FHSUFRMkFrd2dCaUFFTmdKRUlBWWdCRFlDUUNBR0lBUTJBandnQmlBRU5nSTRJQVlnQkRZQ05DQUdJQVEyQWpBZ0JpQUVOZ0lzSUFZZ0JEWUNLQ0FHSUFRMkFpUWdCaUFFTmdJZ0lBWWdCRFlDSENBR0lBUTJBaGdnQmlBRU5nSVVEQUVMSUFZZ0JDQUlhaUlISUFCck5nSkFJQVlnQnlBQVFRRjFJZ0pyTmdJd0lBWWdBaUFIYWpZQ0lDQUdJQUFnQjJvMkFoQWdCaUFFSUFocklnY2dBR3MyQWt3Z0JpQUhJQUpyTmdJOElBWWdBaUFIYWpZQ0xDQUdJQUFnQjJvMkFod2dCaUFFSUFoQkFYVWlDV29pQnlBQWF6WUNSQ0FHSUFjZ0FtczJBalFnQmlBQ0lBZHFOZ0lrSUFZZ0FDQUhhallDRkNBR0lBUWdDV3NpQkNBQWF6WUNTQ0FHSUFRZ0FtczJBamdnQmlBQ0lBUnFOZ0lvSUFZZ0FDQUVhallDR0FzZ0lTQUZRUVowYWlFSVFRQWhBQ0FHUVJCcUlRUURRQ0FJSUFRZ0FFRUJkRUVNY1dvb0FnQWlBa0gvQVNBQ1FmOEJTQnNpQWtFQUlBSkJBRW9iT2dBQUlBUWdCRUVRYWlBQVFRRnFJZ0JCRDNFYklRUWdDRUVCYWlFSUlBQkJ3QUJIRFFBTElBTWdIV29oQXlBRlFRRnFJZ1ZCQWtjTkFBc0xJQUVnQmtIUUFHb1FHeUFHUWRBRGFpUUFDellBSUFJRVFDQUFJQUVRQWc4TFFRRWhBaUFCSUFCQkFSQURJZ0EyQWdBZ0FFRi9Sd1IvSUFFZ0FFRUJjellDQUVFQUJVRUJDd3ZNQXdFU2Z5QURRUUYwSVE4Z0EwRjliQ0VRUVFBZ0Eyc2lFVUVCZENFU0lBRWdBaWdDQUdwQmYyb3RBQUFpQjBFQmFpRVRRUUFnQjJzaENrRUVJUUVEUUFKQUlBQWdFV29pRkMwQUFDSUZJQUF0QUFBaUNHc2lCQ0FFUVI5MUlnUnFJQVJ6SUFJb0FnUlBEUUFnQUNBU2FpSUxMUUFBSWd3Z0JXc2lCQ0FFUVI5MUlnUnFJQVJ6SUFJb0FnZ2lCazhOQUNBQUlBTnFJaFV0QUFBaURTQUlheUlFSUFSQkgzVWlCR29nQkhNZ0JrOE5BQ0FISVFRZ0FDQVFhaTBBQUNJSklBVnJJZzRnRGtFZmRTSU9haUFPY3lBR1NRUkFJQXNnRENBS0lBY2dCU0FJYWtFQmFrRUJkaUFNUVFGMGF5QUpha0VCZFNJRUlBUWdCMG9iSUFRZ0NrZ2Jham9BQUNBQ0tBSUlJUVlnRXlFRUN5QVVJQVVDZnlBQUlBOXFMUUFBSWdzZ0NHc2lDU0FKUVI5MUlnbHFJQWx6SUFaSkJFQWdGU0FOSUFvZ0J5QUZJQWhxUVFGcVFRRjJJQTFCQVhScklBdHFRUUYxSWdZZ0JpQUhTaHNnQmlBS1NCdHFPZ0FBSUFSQkFXb2hCQXRCQUNBRWF5SUdDeUFFSUFnZ0JXdEJBblFnRFdzZ0RHcEJCR3BCQTNVaUJTQUZJQVJLR3lBRklBWklHeUlFYWtHd0xtb3RBQUE2QUFBZ0FDQUlJQVJyUWJBdWFpMEFBRG9BQUFzZ0FFRUJhaUVBSUFGQmYyb2lBUTBBQ3d2N0JnRU9meUFDS0FJSUlRb2dBaWdDQkNFUEFrQWdBVUVFVHdSQUlBOUJBblpCQW1vaEVFRUVJUUlEUUFKQUlBQkJmMm9pQlMwQUFDSUhJQUF0QUFBaUNHc2lBU0FCUVI5MUlnRnFJQUZ6SWcwZ0QwOE5BQ0FBUVg1cUlnNHRBQUFpQVNBSGF5SUVJQVJCSDNVaUJHb2dCSE1nQ2s4TkFDQUFMUUFCSWdrZ0NHc2lCQ0FFUVI5MUlnUnFJQVJ6SUFwUERRQUNRQ0FOSUJCSkJFQWdBQzBBQWlFTEFuOGdBRUY5YWlJTkxRQUFJZ1FnQjJzaUJpQUdRUjkxSWdacUlBWnpJQXBKQkVCQkF5RUdJQVVnQ1NBSElBaHFJQUZxSWdWQkFYUnFJQVJxUVFScVFRTjJPZ0FBSUE0Z0JDQUZha0VDYWtFQ2Rqb0FBQ0FFUVFOc0lRNGdCVUVFYWlFTUlBQkJmR290QUFBTUFRc2dCeUFKYWlFTVFRSWhEa0VDSVFZZ0JTRU5JQUVMSVFRZ0RTQU1JQTVxSUFSQkFYUnFJQVoyT2dBQUlBc2dDR3NpQlNBRlFSOTFJZ1ZxSUFWeklBcFBEUUVnQUNBSElBbHFJQWhxSWdVZ0MycEJBbXBCQW5ZNkFBRWdBQ0FGSUF0QkEyeHFJQUF0QUFOQkFYUnFRUVJxUVFOMk9nQUNJQUFnQVNBRlFRRjBhaUFMYWtFRWFrRURkam9BQUF3Q0N5QUZJQWNnQ1dvZ0FVRUJkR3BCQW1wQkFuWTZBQUFMSUFBZ0FTQUlhaUFKUVFGMGFrRUNha0VDZGpvQUFBc2dBQ0FEYWlFQUlBSkJmMm9pQWcwQUN3d0JDeUFCSUFJb0FnQnFRWDlxTFFBQUlnVkJBV29oRFVFQUlBVnJJUWhCQkNFQ0EwQUNRQ0FBUVg5cUlnNHRBQUFpQkNBQUxRQUFJZ2RySWdFZ0FVRWZkU0lCYWlBQmN5QVBUdzBBSUFCQmZtb2lEQzBBQUNJSklBUnJJZ0VnQVVFZmRTSUJhaUFCY3lBS1R3MEFJQUF0QUFFaUN5QUhheUlCSUFGQkgzVWlBV29nQVhNZ0NrOE5BQ0FBTFFBQ0lRWWdCU0VCSUFCQmZXb3RBQUFpRUNBRWF5SVJJQkZCSDNVaUVXb2dFWE1nQ2trRVFDQU1JQWtnQ0NBRklBUWdCMnBCQVdwQkFYWWdDVUVCZEdzZ0VHcEJBWFVpQVNBQklBVktHeUFCSUFoSUcybzZBQUFnRFNFQkN5QU9JQVFDZnlBR0lBZHJJZ3dnREVFZmRTSU1haUFNY3lBS1NRUkFJQUFnQ3lBSUlBVWdCQ0FIYWtFQmFrRUJkaUFMUVFGMGF5QUdha0VCZFNJR0lBWWdCVW9iSUFZZ0NFZ2Jham9BQVNBQlFRRnFJUUVMUVFBZ0FXc2lCZ3NnQVNBSklBdHJJQWNnQkd0QkFuUnFRUVJxUVFOMUlnUWdCQ0FCU2hzZ0JDQUdTQnNpQVdwQnNDNXFMUUFBT2dBQUlBQWdCeUFCYTBHd0xtb3RBQUE2QUFBTElBQWdBMm9oQUNBQ1FYOXFJZ0lOQUFzTEM5b0hBUTEvSXdCQndBTnJJaEVrQUNBR1FRVnFJUWtDUUFKQUlBSkJBRWdOQUNBRFFRQklEUUFnQWlBSmFpQUVTdzBBSUFNZ0IycEJCV29nQlVzTkFDQUVJUWtnQXlFS0RBRUxJQUFnRVNBQ0lBTWdCQ0FGSUFrZ0IwRUZhaUFKRUF3Z0VTRUFRUUFoQWdzQ1FDQUhSUTBBSUFBZ0NTQUtiQ0FDYW1vaEUwRVFJQVpySVJRQ1FDQUdRUUoySWhJRVFDQUpJQVpySVJVZ0V5QUpJQWhCQVhaQkFYRkJBbkpzYWtFRmFpRUNJQWNoQkFOQUlBSkJmMm90QUFBaEFDQUNRWDVxTFFBQUlRTWdBa0Y5YWkwQUFDRUZJQUpCZkdvdEFBQWhDeUFDUVh0cUxRQUFJUTBnRWlFUEEwQWdBU0FDTFFBQUlnb2dEU0FBSUF0cUlneHJJQU1nQldwQkZHeHFJQXhCQW5ScmFrRVFha0VGZFVHd0xtb3RBQUE2QUFBZ0FTQUNMUUFCSWd3Z0N5QUFJQU5xUVJSc2FpQUZJQXBxSWd0cklBdEJBblJyYWtFUWFrRUZkVUd3TG1vdEFBQTZBQUVnQVNBQ0xRQUNJaEFnQlNBQUlBcHFRUlJzYWlBRElBeHFJZ1ZySUFWQkFuUnJha0VRYWtFRmRVR3dMbW90QUFBNkFBSWdBU0FDTFFBRElnNGdBeUFLSUF4cVFSUnNhaUFBSUJCcUlnTnJJQU5CQW5ScmFrRVFha0VGZFVHd0xtb3RBQUE2QUFNZ0FVRUVhaUVCSUFKQkJHb2hBaUFBSVEwZ0NpRUxJQXdoQlNBUUlRTWdEaUVBSUE5QmYyb2lEdzBBQ3lBQklCUnFJUUVnQWlBVmFpRUNJQVJCZjJvaUJBMEFDd3dCQ3lBSFFYOXFJQlJzSUFacklBRnFRUkJxSVFFTElBZEJBbllpQkVVTkFFSEFBQ0FHYXlFUUlBbEJBWFFoQ2lBSlFRSjBJQVpySVF0QkFDQUpheUlNUVFGMElSSWdBU0FIUVFSMGF5RUNJQWtnRTJvZ0NFRUJjV3BCQW1vaUFDQUpRUVZzYWlFQkEwQWdCaUlEQkVBRFFDQUNJQUFnQ21vdEFBQWlCU0FCSUFwcUxRQUFJQUVnQ1dvdEFBQWlEaUFCSUJKcUxRQUFJZ2RxSWdocklBaEJBblJyYWlBQkxRQUFJZzBnQVNBTWFpMEFBQ0lJYWtFVWJHcEJFR3BCQlhWQnNDNXFMUUFBSUFJdEFEQnFRUUZxUVFGMk9nQXdJQUlnQUNBSmFpMEFBQ0lQSUE0Z0J5QUlha0VVYkdvZ0JTQU5haUlPYXlBT1FRSjBhMnBCRUdwQkJYVkJzQzVxTFFBQUlBSXRBQ0JxUVFGcVFRRjJPZ0FnSUFJZ0FDMEFBQ0lPSUEwZ0JTQUhha0VVYkdvZ0NDQVBhaUlOYXlBTlFRSjBhMnBCRUdwQkJYVkJzQzVxTFFBQUlBSXRBQkJxUVFGcVFRRjJPZ0FRSUFJZ0FDQU1haTBBQUNBSUlBVWdEMnBCRkd4cUlBY2dEbW9pQldzZ0JVRUNkR3RxUVJCcVFRVjFRYkF1YWkwQUFDQUNMUUFBYWtFQmFrRUJkam9BQUNBQVFRRnFJUUFnQWtFQmFpRUNJQUZCQVdvaEFTQURRWDlxSWdNTkFBc0xJQUlnRUdvaEFpQUJJQXRxSVFFZ0FDQUxhaUVBSUFSQmYyb2lCQTBBQ3dzZ0VVSEFBMm9rQUF1MUJRRUVmeUFBS0FJVUlRTWdBQ2dDRUNFRUlBQW9BZ1FoQlNBQUtBSU1JZ0lnQVNrQ0FEY0NBQ0FDSUFFcEFnZzNBZ2dnQWlBRlFRUjBJZ0JxSWdJZ0FTa0NFRGNDQUNBQ0lBRXBBaGczQWdnZ0FDQUNhaUlDSUFFcEFpQTNBZ0FnQWlBQktRSW9Od0lJSUFBZ0Ftb2lBaUFCS1FJd053SUFJQUlnQVNrQ09EY0NDQ0FBSUFKcUlnSWdBU2tDUURjQ0FDQUNJQUVwQWtnM0FnZ2dBQ0FDYWlJQ0lBRXBBbEEzQWdBZ0FpQUJLUUpZTndJSUlBQWdBbW9pQWlBQktRSmdOd0lBSUFJZ0FTa0NhRGNDQ0NBQUlBSnFJZ0lnQVNrQ2NEY0NBQ0FDSUFFcEFuZzNBZ2dnQUNBQ2FpSUNJQUVwQW9BQk53SUFJQUlnQVNrQ2lBRTNBZ2dnQUNBQ2FpSUNJQUVwQXBBQk53SUFJQUlnQVNrQ21BRTNBZ2dnQUNBQ2FpSUNJQUVwQXFBQk53SUFJQUlnQVNrQ3FBRTNBZ2dnQUNBQ2FpSUNJQUVwQXJBQk53SUFJQUlnQVNrQ3VBRTNBZ2dnQUNBQ2FpSUNJQUVwQXNBQk53SUFJQUlnQVNrQ3lBRTNBZ2dnQUNBQ2FpSUNJQUVwQXRBQk53SUFJQUlnQVNrQzJBRTNBZ2dnQUNBQ2FpSUNJQUVwQXVBQk53SUFJQUlnQVNrQzZBRTNBZ2dnQUNBQ2FpSUFJQUVwQXZBQk53SUFJQUFnQVNrQytBRTNBZ2dnQkNBQktRS0FBamNDQUNBRUlBVkJBM1FpQUdvaUJDQUJLUUtJQWpjQ0FDQUFJQVJxSWdRZ0FTa0NrQUkzQWdBZ0FDQUVhaUlFSUFFcEFwZ0NOd0lBSUFBZ0JHb2lCQ0FCS1FLZ0FqY0NBQ0FBSUFScUlnUWdBU2tDcUFJM0FnQWdBQ0FFYWlJRUlBRXBBckFDTndJQUlBQWdCR29nQVNrQ3VBSTNBZ0FnQXlBQktRTEFBamNDQUNBQUlBTnFJZ01nQVNrQ3lBSTNBZ0FnQUNBRGFpSURJQUVwQXRBQ053SUFJQUFnQTJvaUF5QUJLUUxZQWpjQ0FDQUFJQU5xSWdNZ0FTa0M0QUkzQWdBZ0FDQURhaUlESUFFcEF1Z0NOd0lBSUFBZ0Eyb2lBeUFCS1FMd0FqY0NBQ0FBSUFOcUlBRXBBdmdDTndJQUMrZ0NBUVYvQWtBZ0FDQUJFQUlpQXcwQVFRRWhBeUFCSUFFb0FnQkJBV29pQWpZQ0FDQUNRU0JMRFFBZ0FFRUVFQU1pQWtGL1JnMEFJQUVnQWpZQ0JDQUFRUVFRQXlJQ1FYOUdEUUFnQVNBQ05nSUlJQUVvQWdBRVFBTkFJQUFnQVNBRlFRSjBhaUlDSWdSQkRHb1FBaUlERFFKQkFTRURJQVFvQWd3aUJrRi9SZzBDSUFRZ0JrRUJhaUlETmdJTUlBUWdBeUFCS0FJRVFRWnFkRFlDRENBQUlBSkJqQUZxRUFJaUF3MENRUUVoQXlBQ0tBS01BU0lFUVg5R0RRSWdBaUFFUVFGcUlnUTJBb3dCSUFJZ0JDQUJLQUlJUVFScWREWUNqQUVnQUVFQkVBTWlCRUYvUmcwQ0lBSWdCRUVCUmpZQ2pBSWdCVUVCYWlJRklBRW9BZ0JKRFFBTEN5QUFRUVVRQXlJQ1FYOUdEUUFnQVNBQ1FRRnFOZ0tNQXlBQVFRVVFBeUlDUVg5R0RRQWdBU0FDUVFGcU5nS1FBeUFBUVFVUUF5SUNRWDlHRFFBZ0FTQUNRUUZxTmdLVUF5QUFRUVVRQXlJQVFYOUdEUUFnQVNBQU5nS1lBMEVBSVFNTElBTUxXd0VEZnlBQUlBQW9BZ0FpQkNBQklBQW9BZ1FpQW5BaUEwRUVkR29nQVNBRGF5SUJRUWgwYWpZQ0RDQUFJQVFnQWlBQUtBSUliQ0lDUVFoMGFpQUJRUVowYWlBRFFRTjBhaUlCTmdJUUlBQWdBU0FDUVFaMGFqWUNGQXRWQVFKL0lBRWdBa0VCYWlJRElBTWdBVWtiSVFNZ0FDQUNRUUowYWlnQ0FDRUVBMEFDUUNBQ1FRRnFJZ0lnQVU4RVFDQURJUUlNQVFzZ0FDQUNRUUowYWlnQ0FDQUVSdzBCQ3d0QkFDQUNJQUVnQWtZYkN5Y0FJQUJCQ0NBQUtBSUlJZ0JyRUFOQmYwWUVRQThMUVFBZ0FHdEJBblJCekQ5cUtBSUFHZ3Q2QVFKL0l3QkJJR3NpQWlRQUlBSWdBQ2dDRURZQ0VDQUNJQUFwQWdnM0F3Z2dBaUFBS1FJQU53TUFBa0FnQWlBQ1FSeHFFQUlpQUEwQUlBSWdBa0VjYWhBQ0lnQU5BQ0FDSUFKQkhHb1FBaUlBRFFCQkFTRUFJQUlvQWh3aUEwSC9BVXNOQUNBQklBTTJBZ0JCQUNFQUN5QUNRU0JxSkFBZ0FBdm5Cd0VTZnlNQVFZQU9heUlNSkFBZ0JrRUZhaUVKQWtBQ1FDQUNRUUJJRFFBZ0EwRUFTQTBBSUFJZ0NXb2dCRXNOQUNBRElBZHFRUVZxSUFWTERRQWdBeUVLREFFTElBQWdERUhBQ21vZ0FpQURJQVFnQlNBSklBZEJCV29nQ1JBTUlBeEJ3QXBxSVFBZ0NTRUVRUUFoQWdzQ1FDQUhRUUoySWhSRkRRQWdDVVVOQUNBRVFRRjBJUlZCQUNBRWF5SVdRUUYwSVJvZ0JFRUNkQ0FHYTBGN2FpRVhJQUFnQkNBS2JDQUNhbW9nQkdvaUFDQUVRUVZzYWlFQ0lBd2dDVUVDZENJUWFpRURJQWxCQTNRaERVRUFJQWxyUVFKMElRNGdDVUVEYkVFQ2RDRVBBMEFnQ1NFRkEwQWdBeUFOYWlBQUlCVnFMUUFBSWhFZ0FpQVZhaTBBQUNBQ0lBUnFMUUFBSWdzZ0FpQWFhaTBBQUNJU2FpSUtheUFLUVFKMGEyb2dBaTBBQUNJWUlBSWdGbW90QUFBaUUycEJGR3hxTmdJQUlBTWdFR29nQUNBRWFpMEFBQ0laSUFzZ0VpQVRha0VVYkdvZ0VTQVlhaUlLYXlBS1FRSjBhMm8yQWdBZ0F5QUFMUUFBSWdzZ0dDQVJJQkpxUVJSc2FpQVRJQmxxSWdwcklBcEJBblJyYWpZQ0FDQURJQTVxSUFBZ0Ztb3RBQUFnRXlBUklCbHFRUlJzYWlBTElCSnFJZ3BySUFwQkFuUnJhallDQUNBQVFRRnFJUUFnQTBFRWFpRURJQUpCQVdvaEFpQUZRWDlxSWdVTkFBc2dBaUFYYWlFQ0lBQWdGMm9oQUNBRElBOXFJUU1nRkVGL2FpSVVEUUFMQ3lBSEJFQkJFQ0FHYXlFUUlBWkJBblloQ2lBTUlBaEJBblJxUVFocUlRQWdERUVVYWlFQ0EwQWdDZ1JBSUFKQmJHb29BZ0FoQkNBQ1FYQnFLQUlBSVE4Z0FrRjBhaWdDQUNFTklBSkJlR29vQWdBaEJTQUNRWHhxS0FJQUlRTWdDaUVKQTBBZ0FTQUNLQUlBSWc0Z0JDQURJQTlxSWdScklBVWdEV3BCRkd4cUlBUkJBblJyYWtHQUJHcEJDblZCc0M1cUxRQUFJQUFvQWdCQkVHcEJCWFZCc0M1cUxRQUFha0VCYWtFQmRqb0FBQ0FCSUFJb0FnUWlDeUFQSUFNZ0JXcEJGR3hxSUEwZ0Rtb2lCR3NnQkVFQ2RHdHFRWUFFYWtFS2RVR3dMbW90QUFBZ0FDZ0NCRUVRYWtFRmRVR3dMbW90QUFCcVFRRnFRUUYyT2dBQklBRWdBaWdDQ0NJSUlBMGdBeUFPYWtFVWJHb2dCU0FMYWlJRWF5QUVRUUowYTJwQmdBUnFRUXAxUWJBdWFpMEFBQ0FBS0FJSVFSQnFRUVYxUWJBdWFpMEFBR3BCQVdwQkFYWTZBQUlnQVNBQ0tBSU1JZ1lnQlNBTElBNXFRUlJzYWlBRElBaHFJZ1JySUFSQkFuUnJha0dBQkdwQkNuVkJzQzVxTFFBQUlBQW9BZ3hCRUdwQkJYVkJzQzVxTFFBQWFrRUJha0VCZGpvQUF5QUJRUVJxSVFFZ0FFRVFhaUVBSUFKQkVHb2hBaUFESVFRZ0RpRVBJQXNoRFNBSUlRVWdCaUVESUFsQmYyb2lDUTBBQ3dzZ0FTQVFhaUVCSUFCQkZHb2hBQ0FDUVJScUlRSWdCMEYvYWlJSERRQUxDeUFNUVlBT2FpUUFDOUVIQVF4L0l3QkJnQTVySWc4a0FDQUdRUVZxSVFrQ1FBSkFJQUpCQUVnTkFDQURRUUJJRFFBZ0FpQUphaUFFU3cwQUlBZEJCV29pRGlBRGFpQUZTdzBBSUFRaENTQURJUW9NQVFzZ0FDQVBRY0FLYWlBQ0lBTWdCQ0FGSUFrZ0IwRUZhaUlPSUFrUURDQVBRY0FLYWlFQVFRQWhBZ3NDUUNBT1JRMEFJQVpCQW5ZaUVrVU5BQ0FKSUFacklSTWdBQ0FKSUFwc0lBSnFha0VGYWlFQ0lBOGhBQU5BSUFKQmYyb3RBQUFoQ1NBQ1FYNXFMUUFBSVFNZ0FrRjlhaTBBQUNFRklBSkJmR290QUFBaENpQUNRWHRxTFFBQUlRd2dFaUVOQTBBZ0FDQUNMUUFBSWdRZ0RDQUpJQXBxSWd0cklBTWdCV3BCRkd4cUlBdEJBblJyYWpZQ0FDQUFJQUl0QUFFaUN5QURJQWxxUVJSc0lBcHFJQVFnQldvaUNtc2dDa0VDZEd0cU5nSUVJQUFnQWkwQUFpSVFJQVFnQ1dwQkZHd2dCV29nQXlBTGFpSUZheUFGUVFKMGEybzJBZ2dnQUNBQ0xRQURJaFFnQkNBTGFrRVViQ0FEYWlBSklCQnFJZ05ySUFOQkFuUnJhallDRENBQVFSQnFJUUFnQWtFRWFpRUNJQWtoRENBRUlRb2dDeUVGSUJBaEF5QVVJUWtnRFVGL2FpSU5EUUFMSUFJZ0Uyb2hBaUFPUVg5cUlnNE5BQXNMSUFkQkFuWWlCd1JBUWNBQUlBWnJJUlFnRHlBR1FRSjBJZ1JxSWdrZ0JrRVViR29oQWlBSklBaEJBbW9nQm14QkFuUnFJUUFnQmtFRGJFRUNkQ0VGUVFBZ0Jtc2lEa0VEZENFVElBWkJBM1FoQ0FOQUlBWWhBeUFHQkVBRFFDQUJJQWdnQ1dvb0FnQWlDaUFDSUFocUtBSUFJQUlnQkdvb0FnQWlFU0FDSUJOcUtBSUFJZ3RxSWd4cklBeEJBblJyYWlBQ0tBSUFJZzBnQWlBT1FRSjBJaEJxS0FJQUlneHFRUlJzYWtHQUJHcEJDblZCc0M1cUxRQUFJQUFnQ0dvb0FnQkJFR3BCQlhWQnNDNXFMUUFBYWtFQmFrRUJkam9BTUNBQklBUWdDV29vQWdBaUVpQVJJQXNnREdwQkZHeHFJQW9nRFdvaUVXc2dFVUVDZEd0cVFZQUVha0VLZFVHd0xtb3RBQUFnQUNBRWFpZ0NBRUVRYWtFRmRVR3dMbW90QUFCcVFRRnFRUUYyT2dBZ0lBRWdDU2dDQUNJUklBMGdDaUFMYWtFVWJHb2dEQ0FTYWlJTmF5QU5RUUowYTJwQmdBUnFRUXAxUWJBdWFpMEFBQ0FBS0FJQVFSQnFRUVYxUWJBdWFpMEFBR3BCQVdwQkFYWTZBQkFnQVNBSklCQnFLQUlBSUF3Z0NpQVNha0VVYkdvZ0N5QVJhaUlLYXlBS1FRSjBhMnBCZ0FScVFRcDFRYkF1YWkwQUFDQUFJQkJxS0FJQVFSQnFRUVYxUWJBdWFpMEFBR3BCQVdwQkFYWTZBQUFnQUVFRWFpRUFJQWxCQkdvaENTQUJRUUZxSVFFZ0FrRUVhaUVDSUFOQmYyb2lBdzBBQ3dzZ0FTQVVhaUVCSUFBZ0JXb2hBQ0FDSUFWcUlRSWdCU0FKYWlFSklBZEJmMm9pQncwQUN3c2dEMEdBRG1va0FBdTBCZ0VKZnlNQVFjQURheUlOSkFBZ0JrRUZhaUVKQWtBQ1FDQUNRUUJJRFFBZ0F5QUhhaUFGU3cwQUlBTkJBRWdOQUNBQ0lBbHFJQVJMRFFBZ0JDRUpJQU1oQ2d3QkN5QUFJQTBnQWlBRElBUWdCU0FKSUFjZ0NSQU1JQTBoQUVFQUlRSUxJQWNFUUVFUUlBWnJJUkFnQ1NBR2F5RVJJQVpCQW5ZaER5QUFJQWtnQ213Z0FtcHFRUVZxSVFrRFFBSkFJQTlGRFFBZ0NVRi9haTBBQUNFQ0lBbEJmbW90QUFBaEJpQUpRWDFxTFFBQUlRTWdDVUY4YWkwQUFDRUZJQWxCZTJvdEFBQWhDaUFQSWdBaEN5QUlCRUFEUUNBQklBWWdDUzBBQUNJRUlBb2dBaUFGYWlJS2F5QURJQVpxUVJSc2FpQUtRUUowYTJwQkVHcEJCWFZCc0M1cUxRQUFha0VCYWtFQmRqb0FBQ0FCSUFJZ0NTMEFBU0lMSUFVZ0FpQUdha0VVYkdvZ0F5QUVhaUlGYXlBRlFRSjBhMnBCRUdwQkJYVkJzQzVxTFFBQWFrRUJha0VCZGpvQUFTQUJJQVFnQ1MwQUFpSU1JQU1nQWlBRWFrRVViR29nQmlBTGFpSURheUFEUVFKMGEycEJFR3BCQlhWQnNDNXFMUUFBYWtFQmFrRUJkam9BQWlBQklBc2dDUzBBQXlJT0lBWWdCQ0FMYWtFVWJHb2dBaUFNYWlJRGF5QURRUUowYTJwQkVHcEJCWFZCc0M1cUxRQUFha0VCYWtFQmRqb0FBeUFCUVFScUlRRWdDVUVFYWlFSklBSWhDaUFFSVFVZ0N5RURJQXdoQmlBT0lRSWdBRUYvYWlJQURRQU1BZ0FMQUFzRFFDQUJJQU1nQ1MwQUFDSUFJQW9nQWlBRmFpSUVheUFESUFacVFSUnNhaUFFUVFKMGEycEJFR3BCQlhWQnNDNXFMUUFBYWtFQmFrRUJkam9BQUNBQklBWWdDUzBBQVNJRUlBVWdBaUFHYWtFVWJHb2dBQ0FEYWlJRmF5QUZRUUowYTJwQkVHcEJCWFZCc0M1cUxRQUFha0VCYWtFQmRqb0FBU0FCSUFJZ0NTMEFBaUlNSUFNZ0FDQUNha0VVYkdvZ0JDQUdhaUlEYXlBRFFRSjBhMnBCRUdwQkJYVkJzQzVxTFFBQWFrRUJha0VCZGpvQUFpQUJJQUFnQ1MwQUF5SU9JQVlnQUNBRWFrRVViR29nQWlBTWFpSURheUFEUVFKMGEycEJFR3BCQlhWQnNDNXFMUUFBYWtFQmFrRUJkam9BQXlBQlFRUnFJUUVnQ1VFRWFpRUpJQUloQ2lBQUlRVWdCQ0VESUF3aEJpQU9JUUlnQzBGL2FpSUxEUUFMQ3lBQklCQnFJUUVnQ1NBUmFpRUpJQWRCZjJvaUJ3MEFDd3NnRFVIQUEyb2tBQXZHQkFFTGZ5TUFRY0FEYXlJTkpBQUNRQUpBSUFKQkFFZ05BQ0FEUVFCSURRQWdBaUFHYWlBRVN3MEFJQU1nQjJwQkJXb2dCVXNOQUNBRElRa01BUXNnQUNBTklBSWdBeUFFSUFVZ0JpQUhRUVZxSUFZUURDQU5JUUFnQmlFRVFRQWhBZ3NnQjBFQ2RpSVFCRUJCd0FBZ0Jtc2hFaUFFUVFGMElRVWdCRUVDZENBR2F5RU9RUUFnQkdzaUQwRUJkQ0VUSUFBZ0JDQUpiQ0FDYW1vZ0JHb2lBQ0FFUVFWc2FpRUNJQUFnQkNBSVFRSnFiR29oQndOQUlBWWhBeUFHQkVBRFFDQUJJQUFnQldvdEFBQWlDQ0FDSUFWcUxRQUFJQUlnQkdvdEFBQWlDaUFDSUJOcUxRQUFJZ2xxSWd0cklBdEJBblJyYWlBQ0xRQUFJZ3dnQWlBUGFpMEFBQ0lMYWtFVWJHcEJFR3BCQlhWQnNDNXFMUUFBSUFVZ0Iyb3RBQUJxUVFGcVFRRjJPZ0F3SUFFZ0FDQUVhaTBBQUNJUklBb2dDU0FMYWtFVWJHb2dDQ0FNYWlJS2F5QUtRUUowYTJwQkVHcEJCWFZCc0M1cUxRQUFJQVFnQjJvdEFBQnFRUUZxUVFGMk9nQWdJQUVnQUMwQUFDSUtJQXdnQ0NBSmFrRVViR29nQ3lBUmFpSU1heUFNUVFKMGEycEJFR3BCQlhWQnNDNXFMUUFBSUFjdEFBQnFRUUZxUVFGMk9nQVFJQUVnQUNBUGFpMEFBQ0FMSUFnZ0VXcEJGR3hxSUFrZ0Ntb2lDR3NnQ0VFQ2RHdHFRUkJxUVFWMVFiQXVhaTBBQUNBSElBOXFMUUFBYWtFQmFrRUJkam9BQUNBSFFRRnFJUWNnQUVFQmFpRUFJQUZCQVdvaEFTQUNRUUZxSVFJZ0EwRi9haUlERFFBTEN5QUJJQkpxSVFFZ0J5QU9haUVISUFJZ0Rtb2hBaUFBSUE1cUlRQWdFRUYvYWlJUURRQUxDeUFOUWNBRGFpUUFDNDhIQVF4L0lBRW9BZ2doQ3lBQktBSUVJUVlDUUFKQUFrQWdBa0VGU3cwQUlBSkJBV3NPQkFBQUFBQUJDeUFBS0FLNEdnMEFEQUVMSUFCQnhBbHFJUVFEUUNBRUlBTVFGQ0VISUFOQkRrc05BU0FEUVFGcUlRTWdCMFVOQUFzTEFrQUNRQUpBQWtBZ0FDZ0NtQWtpQ0FSQUlBQW9BcndKSVFwQkFDRURRUUFoQkFOQUlBb2dBMEhZQVd4cUtBTEVBVVVFUUVFQUlBUkJBV29pQkNBRUlBWkdJZ1ViSVFRZ0JTQUphaUVKSUFOQkFXb2lBeUFJU1EwQkN3c2dBeUFJUncwQkN3SkFBa0FnQWtGK2FpSUNRUVZMRFFBQ1FDQUNRUUZyRGdRQkFRRUJBQXNnQjBVTkFTQUFLQUs0R2tVTkFRd0RDeUFIRFFJTElBRW9BZ0JCZ0FFZ0JpQUxiRUdBQTJ3UUJ4b01BZ3NnQUNnQ3ZBa2dCaUFKYkVIWUFXeHFJUWdnQkFSQUlBUWhBd05BSUFnZ0EwRi9haUlEUWRnQmJHb2lDaUFCSUFrZ0F5QUNJQWNRRmlBS1FRRTJBc1FCSUFBZ0FDZ0N0QWxCQVdvMkFyUUpJQU1OQUFzTElBUkJBV29pQXlBR1NRUkFBMEFnQ0NBRFFkZ0JiR29pQkNnQ3hBRkZCRUFnQkNBQklBa2dBeUFDSUFjUUZpQUVRUUUyQXNRQklBQWdBQ2dDdEFsQkFXbzJBclFKQ3lBRFFRRnFJZ01nQmtjTkFBc0xBa0FnQ1VVTkFDQUdSUTBBUVFBaEJTQUpRWDlxSWd3Z0Jtd2hEU0FNUlFSQUEwQWdBQ2dDdkFrZ0RVSFlBV3hxSUFWQjJBRnNhaUlFSUFGQkFDQUZJQUlnQnhBV0lBUkJBVFlDeEFFZ0FDQUFLQUswQ1VFQmFqWUN0QWtnQlVFQmFpSUZJQVpIRFFBTUFnQUxBQXNnQ1VGK2FpRUlRUUFnQm10QjJBRnNJUTREUUNBQUtBSzhDU0FOUWRnQmJHb2dCVUhZQVd4cUlnTWdBU0FNSUFVZ0FpQUhFQllnQTBFQk5nTEVBU0FBSUFBb0FyUUpRUUZxTmdLMENTQUlJUVFEUUNBRElBNXFJZ01nQVNBRUlnb2dCU0FDSUFjUUZpQURRUUUyQXNRQklBQWdBQ2dDdEFsQkFXbzJBclFKSUFSQmYyb2hCQ0FLRFFBTElBVkJBV29pQlNBR1J3MEFDd3NnQ1VFQmFpSUZJQXRQRFFJZ0JrVU5BZ05BSUFBb0Fyd0pJQVVnQm14QjJBRnNhaUVJUVFBaEF3TkFJQWdnQTBIWUFXeHFJZ1FvQXNRQlJRUkFJQVFnQVNBRklBTWdBaUFIRUJZZ0JFRUJOZ0xFQVNBQUlBQW9BclFKUVFGcU5nSzBDUXNnQTBFQmFpSURJQVpIRFFBTElBVkJBV29pQlNBTFJ3MEFDd3dDQ3lBQktBSUFJQWNnQmlBTGJFR0FBMndRRlJvTElBQWdBQ2dDbUFraUFUWUN0QWtnQVVVTkFDQUFLQUs4Q1NFQVFRQWhBd05BSUFBZ0EwSFlBV3hxUVFFMkFnZ2dBMEVCYWlJRElBRkhEUUFMQ3dzMkFRSi9JQUFvQWlnaUFnUkFBMEFnQUNnQ0JDQUJRUUowYWlBQUtBSUFJQUZCS0d4cU5nSUFJQUZCQVdvaUFTQUNSdzBBQ3dzTDl3UUNESDhCZmtFSElRVWpBRUVnYXlJSUlRd0RRQ0FGSUFGSkJFQWdBRUVBSUFWclFTaHNhaUVLSUFVaEJnTkFJQUFnQmtFb2JHb2lBaWdDQ0NFSklBSXBBZ0FoRGlBSUlBSXBBZ3czQXhnZ0FpZ0NHQ0VOSUFJb0FoUWhDeUFNSUFJb0FpUTJBaEFnQ0NBQ0tRSWNOd01JQWtBZ0JpSURJQVZKRFFBQ1FDQUxSUVJBQTBBZ0NpQURRU2hzSWdKcUlnUW9BaFFOQWlBTlJRMENJQVFvQWhnTkFpQUFJQUpxSWdRZ0FDQURJQVZySWdOQktHeHFJZ0lwQWdBM0FnQWdCQ0FDS1FJZ053SWdJQVFnQWlrQ0dEY0NHQ0FFSUFJcEFoQTNBaEFnQkNBQ0tRSUlOd0lJSUFNZ0JVOE5BQXdEQUFzQUN5QUxRWDlxUVFGTkJFQURRQUovQWtBZ0NpQURRU2hzSWdKcUlnUW9BaFFpQjBVTkFDQUhRWDlxUVFGTERRQWdCQ2dDQ0NJSElBbEtEUVFnQUNBQ2FpSUVJQWNnQ1VnTkFSb2dCQ0VDREFVTElBQWdBbW9MSWdRZ0FDQURJQVZySWdOQktHeHFJZ0lwQWdBM0FnQWdCQ0FDS1FJZ053SWdJQVFnQWlrQ0dEY0NHQ0FFSUFJcEFoQTNBaEFnQkNBQ0tRSUlOd0lJSUFNZ0JVOE5BQXdEQUFzQUN3TkFJQW9nQTBFb2JDSUNhaUlFS0FJVUlnY0VRQ0FIUVg5cVFRSkpEUUlnQkNnQ0NDQUpUQTBDQ3lBQUlBSnFJZ1FnQUNBRElBVnJJZ05CS0d4cUlnSXBBZ0EzQWdBZ0JDQUNLUUlnTndJZ0lBUWdBaWtDR0RjQ0dDQUVJQUlwQWhBM0FoQWdCQ0FDS1FJSU53SUlJQU1nQlU4TkFBc01BUXNnQUNBRFFTaHNhaUVDQ3lBQ0lBNDNBZ0FnQUNBRFFTaHNhaUlESUFrMkFnZ2dDQ2tER0NFT0lBTWdEVFlDR0NBRElBczJBaFFnQXlBT053SU1JQU1nQ0NrRENEY0NIQ0FESUF3b0FoQTJBaVFnQmtFQmFpSUdJQUZIRFFBTEN5QUZRUUYySWdVTkFBc0xyUVVCQVg4Q1FDQUFLQUlBSWdFb0FoUkZEUUFnQVVFQU5nSVVJQUVvQWhnTkFDQUFJQUFvQWl4QmYybzJBaXdMQWtBZ0FTZ0NQRVVOQUNBQlFRQTJBandnQVVGQWF5Z0NBQTBBSUFBZ0FDZ0NMRUYvYWpZQ0xBc0NRQ0FCS0FKa1JRMEFJQUZCQURZQ1pDQUJLQUpvRFFBZ0FDQUFLQUlzUVg5cU5nSXNDd0pBSUFFb0Fvd0JSUTBBSUFGQkFEWUNqQUVnQVNnQ2tBRU5BQ0FBSUFBb0FpeEJmMm8yQWl3TEFrQWdBU2dDdEFGRkRRQWdBVUVBTmdLMEFTQUJLQUs0QVEwQUlBQWdBQ2dDTEVGL2FqWUNMQXNDUUNBQktBTGNBVVVOQUNBQlFRQTJBdHdCSUFFb0F1QUJEUUFnQUNBQUtBSXNRWDlxTmdJc0N3SkFJQUVvQW9RQ1JRMEFJQUZCQURZQ2hBSWdBU2dDaUFJTkFDQUFJQUFvQWl4QmYybzJBaXdMQWtBZ0FTZ0NyQUpGRFFBZ0FVRUFOZ0tzQWlBQktBS3dBZzBBSUFBZ0FDZ0NMRUYvYWpZQ0xBc0NRQ0FCS0FMVUFrVU5BQ0FCUVFBMkF0UUNJQUVvQXRnQ0RRQWdBQ0FBS0FJc1FYOXFOZ0lzQ3dKQUlBRW9BdndDUlEwQUlBRkJBRFlDL0FJZ0FTZ0NnQU1OQUNBQUlBQW9BaXhCZjJvMkFpd0xBa0FnQVNnQ3BBTkZEUUFnQVVFQU5nS2tBeUFCS0FLb0F3MEFJQUFnQUNnQ0xFRi9hallDTEFzQ1FDQUJLQUxNQTBVTkFDQUJRUUEyQXN3RElBRW9BdEFERFFBZ0FDQUFLQUlzUVg5cU5nSXNDd0pBSUFFb0F2UURSUTBBSUFGQkFEWUM5QU1nQVNnQytBTU5BQ0FBSUFBb0FpeEJmMm8yQWl3TEFrQWdBU2dDbkFSRkRRQWdBVUVBTmdLY0JDQUJLQUtnQkEwQUlBQWdBQ2dDTEVGL2FqWUNMQXNDUUNBQktBTEVCRVVOQUNBQlFRQTJBc1FFSUFFb0FzZ0VEUUFnQUNBQUtBSXNRWDlxTmdJc0N3SkFJQUVvQXV3RVJRMEFJQUZCQURZQzdBUWdBU2dDOEFRTkFDQUFJQUFvQWl4QmYybzJBaXdMQTBBZ0FCQmVSUTBBQ3lBQVFRQTJBakFnQUVMLy93TTNBaVFMM1E0QkNYOGdBaWdDQUNBQUtBSUlJZ0lvQWdCR0JFQWdBRUVBTmdJMElBQW9BamdpQzBVaERRSkFJQUZGQkVBZ0FpQUROZ0lNSUFKQkFEWUNGQ0FDSUEwMkFoZ2dBaUFFTmdJUUlBSWdBellDQ0NBTERRRWdBQ0FBS0FJc1FRRnFOZ0lzREFFTElBVUVRQ0FBUWdBM0FoQWdBQkFvQWtBZ0FTZ0NBRVVFUUNBQUtBSTRSUTBCQ3lBQVFnQTNBaEFMSUFBb0FnZ2lBa0VEUVFJZ0FTZ0NCQ0lCR3pZQ0ZDQUFRUUJCLy84RElBRWJOZ0lrSUFJZ0RUWUNHQ0FDUVFBMkFoQWdBa0lBTndJSUlBQkNnWUNBZ0JBM0FpZ01BUXNDUUFKQUFrQWdBU2dDQ0FSQVFRQWhDd05BSUFFZ0MwRVViR29pQ0NnQ0RDSUNRUVpMRFFJQ1FBSkFBa0FDUUFKQUFrQUNRQ0FDUVFGckRnWUFBUUlEQkFVSkN5QUFLQUlZSWdsRkRRZ2dBeUFJS0FJUWF5RU1JQUFvQWdBaENrRUFJUWdEUUFKQUlBb2dDRUVvYkdvaUFpZ0NGRUYvYWtFQlRRUkFJQUlvQWdnZ0RFWU5BUXNnQ0VFQmFpSUlJQWxIRFFFTUNnc0xJQWhCQUVnTkNDQUNRUUEyQWhRZ0FDQUFLQUlvUVg5cU5nSW9JQUlvQWhnTkJTQUFJQUFvQWl4QmYybzJBaXdnQzBFQmFpRUxEQVlMSUFBb0FoZ2lDVVVOQnlBSUtBSVVJUXdnQUNnQ0FDRUtRUUFoQ0FOQUFrQWdDaUFJUVNoc2FpSUNLQUlVUVFOR0JFQWdBaWdDQ0NBTVJnMEJDeUFJUVFGcUlnZ2dDVWNOQVF3SkN3c2dDRUVBU0EwSElBSkJBRFlDRkNBQUlBQW9BaWhCZjJvMkFpZ2dBaWdDR0EwRUlBQWdBQ2dDTEVGL2FqWUNMQ0FMUVFGcUlRc01CUXNnQUNnQ0pDSUNRZi8vQTBZTkJpQUNJQWdvQWhnaURFa05CaUFBS0FJWUlnbEZEUVlnQ0NnQ0VDRU9JQUFvQWdBaENrRUFJUUlEUUFKQUFrQWdDaUFDUVNoc2FpSUlLQUlVUVFOSERRQWdDQ2dDQ0NBTVJ3MEFJQWhCQURZQ0ZDQUFJQUFvQWloQmYybzJBaWdnQ0NnQ0dBMEJJQUFnQUNnQ0xFRi9hallDTEF3QkN5QUNRUUZxSWdJZ0NVY05BUXNMSUFsQkFTQUpRUUZMR3lFSklBTWdEbXNoRGtFQUlRZ0RRQUpBSUFvZ0NFRW9iR29pQWlnQ0ZDSVBRWDlxUVFGTkJFQWdBaWdDQ0NBT1JnMEJDeUFJUVFGcUlnZ2dDVWNOQVF3SUN3c2dDRUVBU0EwR0lBOUJBa2tOQmlBQ1FRTTJBaFFnQWlBTU5nSUlJQXRCQVdvaEN3d0VDeUFBSUFnb0Fod2lDVFlDSkNBQUtBSVlJZ3hGRFFJZ0FDZ0NBQ0VLUVFBaEFpQUpRZi8vQTBZRVFBTkFBa0FnQ2lBQ1FTaHNhaUlJS0FJVVFRTkhEUUFnQ0VFQU5nSVVJQUFnQUNnQ0tFRi9hallDS0NBSUtBSVlEUUFnQUNBQUtBSXNRWDlxTmdJc0N5QUNRUUZxSWdJZ0RFY05BQXdFQUFzQUN3TkFBa0FnQ2lBQ1FTaHNhaUlJS0FJVVFRTkhEUUFnQ0NnQ0NDQUpUUTBBSUFoQkFEWUNGQ0FBSUFBb0FpaEJmMm8yQWlnZ0NDZ0NHQTBBSUFBZ0FDZ0NMRUYvYWpZQ0xBc2dBa0VCYWlJQ0lBeEhEUUFMREFJTElBQVFLQ0FBUVFFMkFqUkJBQ0VESUF0QkFXb2hDd3dDQ3lBQUtBSWtJZ0pCLy84RFJnMERJQUlnQ0NnQ0dDSU1TUTBESUFBb0FoZ2lDa1VOQXlBQUtBSUFJUWhCQUNFQ0FrQURRQUpBSUFnZ0FrRW9iR29pQ1NnQ0ZFRURSdzBBSUFrb0FnZ2dERWNOQUNBSlFRQTJBaFFnQUNBQUtBSW9RWDlxSWdnMkFpZ2dDU2dDR0EwQ0lBQWdBQ2dDTEVGL2FqWUNMQXdDQ3lBQ1FRRnFJZ0lnQ2tjTkFBc2dBQ2dDS0NFSUN5QUlJQXBQRFFNZ0FDZ0NDQ0lDUVFNMkFoUWdBaUFFTmdJUUlBSWdERFlDQ0NBQ0lBTTJBZ3dnQWlBQUtBSTRSVFlDR0VFQklSQWdBQ0FJUVFGcU5nSW9JQUFnQUNnQ0xFRUJhallDTEFzZ0MwRUJhaUVMREFBQUN3QUxRUUFoQWlBQUtBSW9JZ2tnQUNnQ0dDSUxTUTBCSUFsRkJFQkJBQ0VKREFJTElBQW9BZ0FoREVGL0lRRURRQ0FNSUFKQktHeHFJZ29vQWhSQmYycEJBVTBFUUNBS0tBSUlJZ29nQ0NBQlFYOUdJQW9nQ0VoeUlnb2JJUWdnQWlBQklBb2JJUUVMSUFKQkFXb2lBaUFKUncwQUN5QUJRUUJJRFFFZ0RDQUJRU2hzYWlJQlFRQTJBaFFnQUNBSlFYOXFJZ2syQWlnZ0FTZ0NHQTBCSUFBZ0FDZ0NMRUYvYWpZQ0xBd0JDeUFRRFFFZ0FDZ0NHQ0VMSUFBb0FpZ2hDUXNnQ1NBTFR3MEJJQUFvQWdnaUFTQU5OZ0lZSUFGQkFqWUNGQ0FCSUFRMkFoQWdBU0FETmdJSUlBRWdBellDRENBQUlBbEJBV28yQWlnZ0FDQUFLQUlzUVFGcU5nSXNDd3NnQUNnQ0NDSUJJQWMyQWlBZ0FTQUdOZ0ljSUFFZ0JUWUNKQUpBSUFBb0FqaEZCRUFnQUNnQ0xDSUpJQUFvQWh3aUEwME5BU0FBS0FJQUlRUURRRUgvLy8vL0J5RUZRUUFoQmtFQUlRSURRQ0FFSUFKQktHeHFJZ0VvQWhnRVFDQUJJQVlnQVNnQ0VDSUJJQVZJSWdjYklRWWdBU0FGSUFjYklRVUxJQUpCQVdvaUFpQURUUTBBQ3dKQUlBWkZEUUFnQUNnQ0RDQUFLQUlRSWdKQkJIUnFJZ0VnQmlnQ0FEWUNBQ0FCSUFZb0FpUTJBZ3dnQVNBR0tBSWNOZ0lFSUFFZ0JpZ0NJRFlDQ0NBQUlBSkJBV28yQWhBZ0JrRUFOZ0lZSUFZb0FoUU5BQ0FBSUFsQmYyb2lDVFlDTEFzZ0NTQURTdzBBQ3d3QkN5QUJLQUlBSVFJZ0FDZ0NEQ0FBS0FJUUlnTkJCSFJxSWdFZ0JUWUNEQ0FCSUFJMkFnQWdBU0FITmdJSUlBRWdCallDQkNBQUlBTkJBV28yQWhBZ0FDZ0NIQ0VEQ3lBQUtBSUFJQU5CQVdvUUp3c0wxQXNDQW44QmZpTUFRWkFCYXlJRUpBQWdCRUVBTmdJTUFrQUNRQUpBSUFBb0FwQWFSUTBBSUFBb0FwUWFJQUZIRFFBZ0JDQUFRYVFhYWlrQ0FEY0RHQ0FBS1FLY0dpRUdJQVJCQURZQ0dDQUVJQVkzQXhBZ0JFRUFOZ0lnSUFRZ0JqNENGQ0FESUFBb0FwZ2FOZ0lBREFFTFFRTWhCU0FCSUFJZ0JFRVFhaUFERUdVTkFTQUFJQVFwQXhBM0Fwd2FJQUJCckJwcUlBUW9BaUEyQWdBZ0FFR2tHbW9nQkNrREdEY0NBQ0FES0FJQUlRSWdBQ0FCTmdLVUdpQUFJQUkyQXBnYUMwRUFJUVVnQUVFQU5nS1FHaUFFUVJCcUlBUkJpQUZxRUU4RVFFRURJUVVNQVFzZ0JDZ0NpQUZCZjJwQkMwc05BQ0FFUVJCcUlBUkJpQUZxSUFBZ0JFRU1haEF5SWdFRVFFRUVJUVVnQVVIdy93TkdEUUZCQXlFRkRBRUxBa0FnQkNnQ0RBUkFBa0FnQUNnQ29BbEZEUUFnQUNnQ0VFVU5BRUVESVFVZ0FDZ0N0Qm9OQXdKQUlBQW9BcVFKUlFSQUlBQkJ4QWxxSWdJaUFTQUJLQUlBSUFFb0FoeEJLR3hxSWdFMkFnZ2dBQ0FCS0FJQU5nSzRDaUFDRUNZZ0FDQUFRYmdLYWtFQUVDVU1BUXNnQUNBQVFiZ0thaUFBUWR3S2FpZ0NBQkFsQ3lBRFFRQTJBZ0FnQUVFQU5nS2NDU0FBUVFFMkFwQWFEQUlMSUFCQkFEWUNuQWtnQUVFQU5nS2tDUXNnQkNnQ2lBRkJmMm9pQVVFSFN3MEJBa0FDUUFKQUlBRkJBV3NPQndRRUJBSUVBQUVDQ3lBRVFSQnFJQVJCS0dvUVF3UkFJQVFvQWxBUUJDQUVRUUEyQWxBZ0JDZ0NmQkFFSUFSQkFEWUNmRUVESVFVTUJBc2dBQ0FFUVNocUVEY01Bd3NnQkVFUWFpQUVRU2hxRUV3RVFDQUVLQUk4RUFRZ0JFRUFOZ0k4SUFRb0FrQVFCQ0FFUVFBMkFrQWdCQ2dDUkJBRUlBUkJBRFlDUkNBRUtBSlVFQVFnQkVFQU5nSlVRUU1oQlF3REN5QUFJQVJCS0dvUU5nd0NDeUFBS0FLY0NRMEJJQUJCQVRZQ29Ba0NRQ0FBS0FLa0NRMEFJQUJDQURjQ3RBa2dCRUVRYWlBRVFTaHFFQ0FhSUFBb0FnZ2hBU0FBSUFRb0FpZ2dCQ2dDaUFGQkJVWVFOU0lDQkVBZ0FFS0Fnb0NBZ0FRM0FnUWdBRUVBTmdLMEdpQUFRZ0EzQWd4QkJVRUVJQUpCLy84RFJoc2hCUXdEQ3lBQklBQW9BZ2hHRFFBZ0FDZ0NFQ0VCSUFSQkFUWUNDQ0FBS0FJQUlnSkJIMDBFUUNBQUlBSkJBblJxS0FJVUlRVUxJQU5CQURZQ0FDQUFRUUUyQXBBYUFrQUNRQUpBSUFRb0FvZ0JRUVZIRFFBZ0JFRUlhaUFFUVJCcUlBRWdBQ2dDREJBNElBUW9BZ2h5RFFBZ0JVVU5BQ0FBUWZ3SmFpZ0NBQTBBSUFVb0FqUWdBU2dDTkVjTkFDQUZLQUk0SUFFb0FqaEhEUUFnQlNnQ1dDQUJLQUpZUmcwQkN5QUFRWUFLYWtFQU5nSUFEQUVMSUFCQnhBbHFFRmtMSUFBZ0FDZ0NDRFlDQUVFQ0lRVU1BZ3NnQUNnQ3RCb0VRRUVESVFVTUFnc2dCRUVRYWlBQVFiUVNhaUlDSUFBb0FoQWdBQ2dDRENBRVFZZ0JhaEErQkVCQkF5RUZEQUlMSUFBb0FxUUpSUVJBQWtBZ0JDZ0NpQUZCQlVZTkFDQUFRY1FKYWlBQVFjQVNhaWdDQUNBRUtBS01BVUVBUnlBQUtBSVFLQUl3RUZwRkRRQkJBeUVGREFNTElBQkJ4QWxxSWdFZ0FTZ0NBQ0FCS0FJY1FTaHNhaUlCTmdJSUlBQWdBU2dDQURZQ3VBb0xJQUJCMkFwcUlBSkIzQWNRRlNFQklBQkJBVFlDcEFrZ0FDQUVLUU9JQVRjQzBBb2dBQ2dDbEFrZ0FDZ0NEQ0FBUVpnTGFpZ0NBQ0FBS0FJUUlnSW9BalFnQWlnQ09CQS9JQUJCeEFscUlnSVFKaUFDSUFCQm5BdHFJQUJCNUFwcUtBSUFJQUJCaEF0cUtBSUFFRjhFUUVFRElRVU1BZ3NnQkVFUWFpQUFJQUJCdUFwcUlBRVFRUVJBSUFBZ0FDZ0MyQW9RUUVFRElRVU1BZ3NnQUJBelJRMEJJQUJCQVRZQ25Ba0xJQUJCdUFwcUlnRWdBQ2dDdkFrUVNTQUFFRFFnQUVHRUNtb2dBQ2dDRUNBQVFkZ0thaUFBUWRBS2FoQk5JUUlDUUNBQUtBS2tDVVVOQUNBQVFjUUphaUVESUFCQjFBcHFLQUlBQkVBZ0F5QUFRZXdNYWlBQklBQkI1QXBxS0FJQUlBSWdBQ2dDMEFwQkJVWWdBQ2dDdUFrZ0FDZ0N0QWtRS1F3QkN5QURRUUFnQVNBQVFlUUthaWdDQUNBQ0lBQW9BdEFLUVFWR0lBQW9BcmdKSUFBb0FyUUpFQ2tMSUFCQ0FEY0NvQWxCQVNFRkN5QUVRWkFCYWlRQUlBVUxxQXdCQzM4Q1FDQUJRUVJQQkVCQkFDQURheUlOUVFGMElRb0NRQ0FBSUFOcklnVXRBQUFpQmlBQUxRQUFJZ2hySWdFZ0FVRWZkU0lCYWlBQmN5QUNLQUlFSWdGUERRQWdBQ0FLYWkwQUFDSUhJQVpySWdRZ0JFRWZkU0lFYWlBRWN5QUNLQUlJSWd4UERRQWdBQ0FEYWkwQUFDSUVJQWhySWdzZ0MwRWZkU0lMYWlBTGN5QU1UdzBBSUFVZ0JDQUdhaUFIUVFGMGFrRUNha0VDZGpvQUFDQUFJQWdnQkVFQmRHb2dCMnBCQW1wQkFuWTZBQUFnQWlnQ0JDRUJDd0pBSUFCQkFXb2lCaUFOYWlJTUxRQUFJZ2dnQUMwQUFTSUhheUlFSUFSQkgzVWlCR29nQkhNZ0FVOE5BQ0FHSUFwcUxRQUFJZ1FnQ0dzaUJTQUZRUjkxSWdWcUlBVnpJQUlvQWdnaUMwOE5BQ0FESUFacUxRQUFJZ1VnQjJzaUNTQUpRUjkxSWdscUlBbHpJQXRQRFFBZ0RDQUZJQWhxSUFSQkFYUnFRUUpxUVFKMk9nQUFJQVlnQnlBRlFRRjBhaUFFYWtFQ2FrRUNkam9BQUNBQ0tBSUVJUUVMQWtBZ0FFRUNhaUlHSUExcUlnd3RBQUFpQ0NBQUxRQUNJZ2RySWdRZ0JFRWZkU0lFYWlBRWN5QUJUdzBBSUFZZ0Ntb3RBQUFpQkNBSWF5SUZJQVZCSDNVaUJXb2dCWE1nQWlnQ0NDSUxUdzBBSUFNZ0Jtb3RBQUFpQlNBSGF5SUpJQWxCSDNVaUNXb2dDWE1nQzA4TkFDQU1JQVVnQ0dvZ0JFRUJkR3BCQW1wQkFuWTZBQUFnQmlBSElBVkJBWFJxSUFScVFRSnFRUUoyT2dBQUlBSW9BZ1FoQVFzQ1FDQUFRUU5xSWdZZ0RXb2lEQzBBQUNJSUlBQXRBQU1pQjJzaUJDQUVRUjkxSWdScUlBUnpJQUZQRFFBZ0JpQUthaTBBQUNJRUlBaHJJZ1VnQlVFZmRTSUZhaUFGY3lBQ0tBSUlJZ3RQRFFBZ0F5QUdhaTBBQUNJRklBZHJJZ2tnQ1VFZmRTSUphaUFKY3lBTFR3MEFJQXdnQlNBSWFpQUVRUUYwYWtFQ2FrRUNkam9BQUNBR0lBY2dCVUVCZEdvZ0JHcEJBbXBCQW5ZNkFBQWdBaWdDQkNFQkN3SkFJQUJCQkdvaUJpQU5haUlNTFFBQUlnZ2dBQzBBQkNJSGF5SUVJQVJCSDNVaUJHb2dCSE1nQVU4TkFDQUdJQXBxTFFBQUlnUWdDR3NpQlNBRlFSOTFJZ1ZxSUFWeklBSW9BZ2dpQzA4TkFDQURJQVpxTFFBQUlnVWdCMnNpQ1NBSlFSOTFJZ2xxSUFseklBdFBEUUFnRENBRklBaHFJQVJCQVhScVFRSnFRUUoyT2dBQUlBWWdCeUFGUVFGMGFpQUVha0VDYWtFQ2Rqb0FBQ0FDS0FJRUlRRUxBa0FnQUVFRmFpSUdJQTFxSWd3dEFBQWlDQ0FBTFFBRklnZHJJZ1FnQkVFZmRTSUVhaUFFY3lBQlR3MEFJQVlnQ21vdEFBQWlCQ0FJYXlJRklBVkJIM1VpQldvZ0JYTWdBaWdDQ0NJTFR3MEFJQU1nQm1vdEFBQWlCU0FIYXlJSklBbEJIM1VpQ1dvZ0NYTWdDMDhOQUNBTUlBVWdDR29nQkVFQmRHcEJBbXBCQW5ZNkFBQWdCaUFISUFWQkFYUnFJQVJxUVFKcVFRSjJPZ0FBSUFJb0FnUWhBUXNDUUNBQVFRWnFJZ1lnRFdvaURDMEFBQ0lJSUFBdEFBWWlCMnNpQkNBRVFSOTFJZ1JxSUFSeklBRlBEUUFnQmlBS2FpMEFBQ0lFSUFocklnVWdCVUVmZFNJRmFpQUZjeUFDS0FJSUlndFBEUUFnQXlBR2FpMEFBQ0lGSUFkcklna2dDVUVmZFNJSmFpQUpjeUFMVHcwQUlBd2dCU0FJYWlBRVFRRjBha0VDYWtFQ2Rqb0FBQ0FHSUFjZ0JVRUJkR29nQkdwQkFtcEJBblk2QUFBZ0FpZ0NCQ0VCQ3lBTklBQkJCMm9pRFdvaUNDMEFBQ0lHSUFBdEFBY2lBR3NpQnlBSFFSOTFJZ2RxSUFkeklBRlBEUUVnQ2lBTmFpMEFBQ0lCSUFacklnb2dDa0VmZFNJS2FpQUtjeUFDS0FJSUlncFBEUUVnQXlBTmFpMEFBQ0lDSUFCcklnTWdBMEVmZFNJRGFpQURjeUFLVHcwQklBZ2dBaUFHYWlBQlFRRjBha0VDYWtFQ2Rqb0FBQ0FOSUFBZ0FrRUJkR29nQVdwQkFtcEJBblk2QUFBUEMwRUFJQU5ySWdkQkFYUWhCQ0FCSUFJb0FnQnFRWDlxTFFBQUlnRkJBV29oQmlBQlFYOXpJUWhCQ0NFQkEwQUNRQ0FBSUFkcUlnVXRBQUFpQ2lBQUxRQUFJZzFySWd3Z0RFRWZkU0lNYWlBTWN5QUNLQUlFVHcwQUlBQWdCR290QUFBaURDQUtheUlMSUF0QkgzVWlDMm9nQzNNZ0FpZ0NDQ0lMVHcwQUlBQWdBMm90QUFBaUNTQU5heUlPSUE1QkgzVWlEbW9nRG5NZ0MwOE5BQ0FGSUFvZ0NDQUdJQTBnQ210QkFuUWdDV3NnREdwQkJHcEJBM1VpQ2lBS0lBWktHeUFLSUFoSUd5SUtha0d3TG1vdEFBQTZBQUFnQUNBTklBcHJRYkF1YWkwQUFEb0FBQXNnQUVFQmFpRUFJQUZCZjJvaUFRMEFDd3NMNmdnQkFuOGdBVUVBUWJnSEVBY2hBa0VCSVFFQ1FBSkFJQUJCQVJBRElnTkJmMFlOQUNBQ0lBTkJBVVkyQWdBQ1FDQURRUUZIRFFBZ0FFRUlFQU1pQTBGL1JnMEJJQUlnQXpZQ0JDQURRZjhCUncwQUlBQkJFQkFESWdOQmYwWU5BU0FDSUFNMkFnZ2dBRUVRRUFNaUEwRi9SZzBCSUFJZ0F6WUNEQXNnQUVFQkVBTWlBMEYvUmcwQUlBSWdBMEVCUmpZQ0VDQURRUUZHQkVBZ0FFRUJFQU1pQTBGL1JnMEJJQUlnQTBFQlJqWUNGQXNnQUVFQkVBTWlBMEYvUmcwQUlBSWdBMEVCUmpZQ0dBSkFBa0FnQTBFQlJnUkFJQUJCQXhBRElnTkJmMFlOQXlBQ0lBTTJBaHdnQUVFQkVBTWlBMEYvUmcwRElBSWdBMEVCUmpZQ0lDQUFRUUVRQXlJRFFYOUdEUU1nQWlBRFFRRkdOZ0lrSUFOQkFVY05BU0FBUVFnUUF5SURRWDlHRFFNZ0FpQUROZ0lvSUFCQkNCQURJZ05CZjBZTkF5QUNJQU0yQWl3Z0FFRUlFQU1pQTBGL1J3MENEQU1MSUFKQkJUWUNIQXNnQWtLQ2dJQ0FJRGNDS0VFQ0lRTUxJQUlnQXpZQ01DQUFRUUVRQXlJRFFYOUdEUUFnQWlBRFFRRkdOZ0kwQWtBZ0EwRUJSdzBBSUFBZ0FrRTRhaEFDSWdFTkFTQUNLQUk0UVFWTERRSWdBQ0FDUVR4cUVBSWlBUTBCSUFJb0FqeEJCVTBOQUF3Q0MwRUJJUUVnQUVFQkVBTWlBMEYvUmcwQUlBSWdBMEVCUmpZQ1FDQURRUUZHQkVBZ0FCQVBJUUVnQUVFZ0VBc2hBeUFCUlEwQ0lBTkJmMFlOQWlBQ0lBRTJBa1FnQUJBUElRRWdBRUVnRUFzaEF5QUJSUTBDSUFOQmYwWU5BaUFDSUFFMkFraEJBU0VCSUFCQkFSQURJZ05CZjBZTkFTQUNJQU5CQVVZMkFrd0xJQUJCQVJBRElnTkJmMFlOQUNBQ0lBTkJBVVkyQWxBQ1FDQURRUUZHQkVBZ0FDQUNRZFFBYWhBY0lnRkZEUUVNQWdzZ0FrRUJOZ0pVSUFKQ21JQ0FnSUFETndMb0F5QUNRcGlBZ0lDQUF6Y0M0QU1nQWtHQmtLcUpBVFlDNEFFZ0FrR0JrS3FKQVRZQ1lBdEJBU0VCSUFCQkFSQURJZ05CZjBZTkFDQUNJQU5CQVVZMkF2QURBa0FnQTBFQlJnUkFJQUFnQWtIMEEyb1FIQ0lCUlEwQkRBSUxJQUpCQVRZQzlBTWdBa0tZZ0lDQWdBTTNBb2dISUFKQ21JQ0FnSUFETndLQUJ5QUNRWUc0dVBJQU5nS0FCU0FDUVlHNHVQSUFOZ0tBQkFzQ1FDQUNLQUpRUlFSQUlBSW9BdkFEUlEwQkMwRUJJUUVnQUVFQkVBTWlBMEYvUmcwQklBSWdBMEVCUmpZQ2tBY0xRUUVoQVNBQVFRRVFBeUlEUVg5R0RRQWdBaUFEUVFGR05nS1VCeUFBUVFFUUF5SURRWDlHRFFBZ0FpQURRUUZHTmdLWUJ3SkFJQU5CQVVZRVFDQUFRUUVRQXlJRFFYOUdEUUlnQWlBRFFRRkdOZ0tjQnlBQUlBSkJvQWRxRUFJaUFRMENJQUlvQXFBSFFSQkxEUU1nQUNBQ1FhUUhhaEFDSWdFTkFpQUNLQUtrQjBFUVN3MERJQUFnQWtHb0Iyb1FBaUlCRFFJZ0FpZ0NxQWRCRUVzTkF5QUFJQUpCckFkcUVBSWlBUTBDUVFFaEFTQUNLQUtzQjBFUVN3MENJQUFnQWtHd0Iyb1FBaUlCRFFJZ0FDQUNRYlFIYWhBQ0lnRkZEUUVNQWdzZ0FrRVFOZ0swQnlBQ1FwQ0FnSUNBQWpjQ3JBY2dBa0tCZ0lDQWdBSTNBcVFISUFKQ2dZQ0FnQ0EzQXB3SEMwRUFJUUVMSUFFUEMwRUJDMDBCQW44akFFRVFheUlESkFCQkFTRUVBa0FnQUNBRFFReHFFQUlOQUNBREtBSU1JZ0JCTDBzTkFDQUJRZEEvUVlEQUFDQUNHeUFBYWkwQUFEWUNBRUVBSVFRTElBTkJFR29rQUNBRUN6NEJBbjhDUUNBQUtBSU1RUU4wSUFBb0FoQnJJZ0ZGQkVBTUFRdEJBU0VDSUFGQkNFc05BRUVCSUFGQmYycDBJQUFRRDBFZ0lBRnJka2NQQ3lBQ0N6SUJBbjhDUUVHQWdJREFBQ0lCSUFCeERRQURRQ0FDUVFGcUlRSWdBVUVCZGlJQlJRMEJJQUFnQVhGRkRRQUxDeUFDQzRvQ0FRZC9JQUZCb0QxcUxRQUFRUXhzUWRBOGFpZ0NBQ0VDUVFFaEF5QUJRUVpQQkVCQkFDRURJQUlnQVVHUVBHb3RBQUJCZjJwMElRSUxJQUFnQUNnQ0FDSUJJQUFvQWdnaUJHc2lCU0FBS0FJRUlnWWdBQ2dDRENJSGF5SUlheUFDYkNBRGRUWUNEQ0FBSUFVZ0NHb2dBbXdnQTNVMkFnZ2dBQ0FCSUFScUlnRWdCaUFIYWlJRWF5QUNiQ0FEZFRZQ0JDQUFJQUVnQkdvZ0Ftd2dBM1UyQWdBZ0FDQUFLQUljSWdFZ0FDZ0NGQ0lFYWlJRklBQW9BaGdpQmlBQUtBSVFJZ2RxSWdocUlBSnNJQU4xTmdJUUlBQWdCQ0FCYXlJQklBY2dCbXNpQkdvZ0Ftd2dBM1UyQWhnZ0FDQUlJQVZySUFKc0lBTjFOZ0lVSUFBZ0JDQUJheUFDYkNBRGRUWUNIQXZQQ0FFVWZ5QUFJQUFvQWl3aUFpQUFLQUlNSWdacUlnVWdBQ2dDTkNJRUlBQW9BaUFpRUdvaUNtc2lFVFlDTENBQUtBSW9JUU1nQUNBR0lBSnJJZ2NnRUNBRWF5SUVheUlHTmdJb0lBQW9BaVFoQWlBQUlBUWdCMm9pQkRZQ0pDQUFJQVVnQ21vaUJUWUNJQ0FBSUFBb0Fod2lDaUFBS0FJSUlnZHFJZ2dnQUNnQ01DSU1JQUFvQWhBaUNXb2lDMnNpRURZQ0hDQUFLQUlZSVE4Z0FDQUhJQXBySWdjZ0NTQU1heUlNYXlJS05nSVlJQUFvQWhRaENTQUFJQWNnREdvaUJ6WUNGQ0FBSUFnZ0Myb2lDRFlDRUNBQUlBa2dBQ2dDQUNJTGFpSVNJQThnQUNnQ0JDSU5haUlPYXlJTU5nSU1JQUFnQ3lBSmF5SUpJQTBnRDJzaUMyc2lEellDQ0NBQUlBa2dDMm9pQ1RZQ0JDQUFJQTRnRW1vaUN6WUNBQ0FBSUFJZ0FDZ0NPQ0lOYWlJVElBTWdBQ2dDUENJT2FpSVVheUlTTmdJOElBQWdBaUFOYXlJQ0lBTWdEbXNpQTJzaURUWUNPQ0FBSUFJZ0Eyb2lEallDTkNBQUlCTWdGR29pRXpZQ01DQUJRWkE4YWkwQUFDRUNJQUZCb0QxcUxRQUFRUXhzUWRBOGFpZ0NBQ0VESUFGQkRFOEVRQ0FBSUFNZ0FrRithblFpQVNBRklBdHFJZ01nQ0NBVGFpSUNhMncyQWpBZ0FDQUxJQVZySWdVZ0NDQVRheUlJYXlBQmJEWUNJQ0FBSUFVZ0NHb2dBV3cyQWhBZ0FDQUNJQU5xSUFGc05nSUFJQUFnQkNBSmFpSURJQWNnRG1vaUFtc2dBV3cyQWpRZ0FDQUpJQVJySWdRZ0J5QU9heUlGYXlBQmJEWUNKQ0FBSUFRZ0JXb2dBV3cyQWhRZ0FDQUNJQU5xSUFGc05nSUVJQUFnQmlBUGFpSURJQW9nRFdvaUFtc2dBV3cyQWpnZ0FDQVBJQVpySWdZZ0NpQU5heUlFYXlBQmJEWUNLQ0FBSUFRZ0Jtb2dBV3cyQWhnZ0FDQUNJQU5xSUFGc05nSUlJQUFnRENBUmF5SURJQkFnRW1zaUFtc2dBV3cyQWl3Z0FDQUNJQU5xSUFGc05nSWNJQUFnRUNBU2FpSURJQXdnRVdvaUFtb2dBV3cyQWd3Z0FDQUNJQU5ySUFGc05nSThEd3NnQUVFQlFRSWdBVUY2YWtFR1NSc2lBU0FGSUF0cUloUWdDQ0FUYWlJVmF5QURiR3BCQWlBQ2F5SUNkVFlDTUNBQUlBc2dCV3NpQlNBSUlCTnJJZ2hySUFOc0lBRnFJQUoxTmdJZ0lBQWdCU0FJYWlBRGJDQUJhaUFDZFRZQ0VDQUFJQlFnRldvZ0Eyd2dBV29nQW5VMkFnQWdBQ0FFSUFscUlnVWdCeUFPYWlJSWF5QURiQ0FCYWlBQ2RUWUNOQ0FBSUFrZ0JHc2lCQ0FISUE1cklnZHJJQU5zSUFGcUlBSjFOZ0lrSUFBZ0JDQUhhaUFEYkNBQmFpQUNkVFlDRkNBQUlBVWdDR29nQTJ3Z0FXb2dBblUyQWdRZ0FDQUdJQTlxSWdRZ0NpQU5haUlGYXlBRGJDQUJhaUFDZFRZQ09DQUFJQThnQm1zaUJpQUtJQTFySWdwcklBTnNJQUZxSUFKMU5nSW9JQUFnQmlBS2FpQURiQ0FCYWlBQ2RUWUNHQ0FBSUFRZ0JXb2dBMndnQVdvZ0FuVTJBZ2dnQUNBTUlCRnJJZ1lnRUNBU2F5SUVheUFEYkNBQmFpQUNkVFlDTENBQUlBUWdCbW9nQTJ3Z0FXb2dBblUyQWh3Z0FDQVFJQkpxSWdZZ0RDQVJhaUlSYWlBRGJDQUJhaUFDZFRZQ0RDQUFJQkVnQm1zZ0Eyd2dBV29nQW5VMkFqd0x2UVVCQm44akFFRWdheUlGSkFBZ0EwRUFOZ0lBQWtBZ0FTZ0NBQ0lHUVJKTERRQkJBU0FHZENJR1FjRGZIM0ZGQkVBZ0JrRWljVVVOQVNBQ1FiUUthaWdDQUFSQUlBTkJBVFlDQUNBQ1FRQTJBclFLQ3lBQUlBVkJIR29RSUNJRURRRkI4UDhESVFRZ0FpQUZLQUljUVFKMGFpZ0NsQUVpQ0VVTkFTQUNJQWdvQWdRaUJrRUNkR29vQWhRaUIwVU5BUUpBSUFJb0FnZ2lDVUVnUmcwQUlBWWdDVVlOQUNBQktBSUFRUVZIRFFJTEFrQWdBa0dZQ21vb0FnQWlCQ0FCS0FJRUlnWkdEUUFnQkVFQUlBWWJEUUFnQTBFQk5nSUFDeUFCS0FJQUlRUUNRQUpBSUFJb0FwUUtRUVZHQkVBZ0JFRUZSdzBCREFJTElBUkJCVWNOQVFzZ0EwRUJOZ0lBQzBFQklRUWdBQ0FIS0FJTUlBVkJHR29RUFEwQklBVW9BaGdpQmlBQ1Fad0thaWdDQUVjRVFDQUNJQVkyQXB3S0lBTkJBVFlDQUFzZ0FTZ0NBRUVGUmdSQUlBQWdCeWdDRENBRlFSUnFFRHdOQWdKQUlBSW9BcFFLUVFWSEJFQWdCU2dDRkNFRURBRUxJQUpCb0FwcUtBSUFJZ1FnQlNnQ0ZDSUdSZzBBSUFOQkFUWUNBQ0FHSVFRTElBSkJvQXBxSUFRMkFnQUxBa0FnQnlnQ0VDSUVRUUZMRFFBZ0JFRUJhd1JBUVFFaEJDQUFJQWNnQVNnQ0FDQUZRUWhxRURzTkF5QUZLQUlJSWdRZ0FrR2tDbW9vQWdCSEJFQWdBaUFFTmdLa0NpQURRUUUyQWdBTElBZ29BZ2hGRFFFZ0FDQUhJQUVvQWdBZ0JVRVFhaEE2SWdRTkF5QUZLQUlRSWdBZ0FrR29DbW9vQWdCR0RRRWdBaUFBTmdLb0NpQURRUUUyQWdBTUFRc2dCeWdDR0EwQUlBQWdCeUFCS0FJQUlBZ29BZ2dnQlVFSWFoQTVJZ1FOQWlBRktBSUlJZ0FnQWtHc0Ntb29BZ0JIQkVBZ0FpQUFOZ0tzQ2lBRFFRRTJBZ0FMSUFnb0FnaEZEUUFnQlNnQ0RDSUFJQUpCc0FwcUtBSUFSZzBBSUFJZ0FEWUNzQW9nQTBFQk5nSUFDeUFDSUFFcEFnQTNBcFFLUVFBaEJBd0JDeUFEUVFFMkFnQUxJQVZCSUdva0FDQUVDMzhCQTM4Q1FBSkFBa0FnQUVIOENtb29BZ0FFUUNBQUtBS1lDU0lERFFGQkFROExRUUVoQVNBQVFhd0phaWdDQUNBQUtBS1lDVWNOQVF3Q0N5QUFLQUs4Q1NFQlFRQWhBQU5BSUFJZ0FTQUFRZGdCYkdvb0FzUUJRUUJIYWlFQ0lBQkJBV29pQUNBRFJ3MEFDMEVCSVFFZ0FpQURSZzBCQzBFQUlRRUxJQUVMU2dFRGZ5QUFRZ0EzQXFnSklBQW9BcGdKSWdFRVFDQUFLQUs4Q1NFQ1FRQWhBQU5BSUFJZ0FFSFlBV3hxSWdOQkFEWUN4QUVnQTBFQU5nSUVJQUJCQVdvaUFDQUJSdzBBQ3dzTGd3WUJESDlCQVNFR0FrQWdBQ0FCUVFKMGFpZ0NsQUVpQkVVTkFDQUFJQVFvQWdRaUNVRUNkR29pQ2tFVWFpZ0NBQ0lEUlEwQUFrQWdCQ2dDRENJRlFRSkpEUUFnQXlnQ05DSUhJQU1vQWpoc0lRZ0NRQ0FFS0FJUUlnTkJBa3NOQUFKQUFrQUNRQ0FEUVFGckRnSURBQUVMSUFWQmYyb2hDeUFFS0FJY0lRd2dCQ2dDR0NFTlFRQWhBd3dCQ3lBRUtBSVVJUWRCQUNFREEwQWdCeUFEUVFKMGFpZ0NBQ0FJVFFSQUlBVWdBMEVCYWlJRFJ3MEJEQVFMQzBFQkR3c0RRQ0FOSUFOQkFuUWlCV29vQWdBaURpQUZJQXhxS0FJQUlnVkxEUU1nQlNBSVR3MERJQTRnQjNBZ0JTQUhjRTBFUUNBRFFRRnFJZ01nQzBZTkF3d0JDd3RCQVE4TElBTkJmV3BCQWswRVFDQUVLQUlrSUFoTkRRRU1BZ3NnQTBFR1J3MEFJQVFvQWlnZ0NFa05BUXNDUUNBQUtBSUVJZ05CZ0FKR0JFQWdBQ0FFTmdJTUlBQWdBVFlDQkNBQUlBazJBZ2dnQUNBS0tBSVVJZ0UyQWhBZ0FTZ0NOQ0VDSUFFb0FqZ2hBU0FBUVFFMkFyUWFJQUJCd0FwcUlBRTJBZ0FnQUVHOENtb2dBallDQUNBQUlBRWdBbXcyQXBnSkRBRUxJQUFvQXJRYUJFQWdBRUVBTmdLMEdpQUFLQUs4Q1JBRUlBQkJBRFlDdkFrZ0FDZ0NsQWtRQkNBQUlBQW9BcGdKSWdGQjJBRnNJZ1FRQ2lJQ05nSzhDU0FBSUFGQkFuUVFDaUlETmdLVUNVSC8vd01oQmlBQ1JRMENJQU5GRFFJZ0FrRUFJQVFRQnlBQUtBSVFLQUkwSUFFUVRpQUFLQUlRSVFGQkFTRUNBa0FnQUNnQ3dBa05BQ0FCS0FJUVFRSkdEUUFDUUNBQktBSlFSUTBBSUFFb0FsUWlCQ2dDbUFkRkRRQWdCQ2dDc0FkRkRRRUxRUUFoQWdzZ0FFSEVDV29nQVNnQ09DQUJLQUkwYkNBQktBSllJQUVvQWl3Z0FTZ0NEQ0FDRUZ3aUJrVU5BUXdDQ3lBQklBTkdEUUFnQUNnQ0NDQUpSd1JBSUFKRkRRSWdBQ0FFTmdJTUlBQWdBVFlDQkNBQUlBazJBZ2dnQUNBS0tBSVVJZ0UyQWhBZ0FTZ0NOQ0VDSUFFb0FqZ2hBU0FBUVFFMkFyUWFJQUJCd0FwcUlBRTJBZ0FnQUVHOENtb2dBallDQUNBQUlBRWdBbXcyQXBnSkRBRUxJQUFnQkRZQ0RDQUFJQUUyQWdRTFFRQWhCZ3NnQmd1MkFRRURmd0pBSUFBZ0FTZ0NBQ0lEUVFKMGFpSUNLQUtVQVNJRVJRUkFJQUpCeUFBUUNpSUFOZ0tVQVNBQURRRVBDd0pBSUFNZ0FDZ0NCRWNOQUNBQktBSUVJQUFvQWdoR0RRQWdBRUdCQWpZQ0JBc2dCQ2dDRkJBRUlBSW9BcFFCUVFBMkFoUWdBaWdDbEFFb0FoZ1FCQ0FDS0FLVUFVRUFOZ0lZSUFJb0FwUUJLQUljRUFRZ0FpZ0NsQUZCQURZQ0hDQUNLQUtVQVNnQ0xCQUVJQUlvQXBRQlFRQTJBaXdMSUFJb0FwUUJJQUZCeUFBUUZSb0wxZ0VCQTM4Q1FDQUFJQUVvQWdnaUEwRUNkR29pQWlnQ0ZDSUVSUVJBSUFKQjNBQVFDaUlBTmdJVUlBQU5BUThMSUFBb0FnZ2dBMFlFUUNBQklBQW9BaEFRUWdSQUlBSW9BaFFvQWlnUUJDQUNLQUlVUVFBMkFpZ2dBaWdDRkNnQ1ZCQUVJQUlvQWhSQkFEWUNWQ0FBUVFBMkFoQWdBRUdCQWpZQ0JDQUFRaUUzQWdnTUFnc2dBU2dDS0JBRUlBRkJBRFlDS0NBQktBSlVFQVFnQVVFQU5nSlVEd3NnQkNnQ0tCQUVJQUlvQWhSQkFEWUNLQ0FDS0FJVUtBSlVFQVFnQWlnQ0ZFRUFOZ0pVQ3lBQ0tBSVVJQUZCM0FBUUZSb0wwZ0lCQTM4akFFRWdheUlFSkFBZ0JDQUJLQUlRTmdJUUlBUWdBU2tDQ0RjRENDQUVJQUVwQWdBM0F3QUNRQ0FFSUFSQkhHb1FBaUlCRFFBZ0JDQUVRUnhxRUFJaUFRMEFJQVFnQkVFY2FoQUNJZ0VOQUNBQ0tBSU1JUVpCQUNFQkEwQWdBU0lGUVFGcUlRRWdCaUFGZGcwQUN5QUVJQVZCZjJvUUEwRi9SZ1JBUVFFaEFRd0JDeUFFSUFSQkhHb1FBaUlCRFFBQ1FDQUNLQUlRSWdFRWZ5QUJCU0FDS0FJVUlRWkJBQ0VCQTBBZ0FTSUZRUUZxSVFFZ0JpQUZkZzBBQ3lBRUlBVkJmMm9RQTBGL1JnUkFRUUVoQVF3REN5QURLQUlJQkVBZ0JDQUVRUmhxRUFVaUFRMERDeUFDS0FJUUMwRUJSdzBBSUFJb0FoZ05BQ0FFSUFSQkdHb1FCU0lCRFFFZ0F5Z0NDRVVOQUNBRUlBUkJHR29RQlNJQkRRRUxJQU1vQWtRRVFDQUVJQVJCSEdvUUFpSUJEUUVMSUFBZ0JFRUJFQU1pQURZQ0FDQUFRWDlHSVFFTElBUkJJR29rQUNBQkM4WUJBUUovSXdCQklHc2lCU1FBSUFVZ0FDZ0NFRFlDRUNBRklBQXBBZ2czQXdnZ0JTQUFLUUlBTndNQUFrQWdCU0FGUVJ4cUVBSWlBQTBBSUFVZ0JVRWNhaEFDSWdBTkFDQUZJQVZCSEdvUUFpSUFEUUFnQVNnQ0RDRUdRUUFoQUFOQUlBQWlBVUVCYWlFQUlBWWdBWFlOQUFzZ0JTQUJRWDlxRUFOQmYwWUVRRUVCSVFBTUFRc2dBa0VGUmdSQUlBVWdCVUVjYWhBQ0lnQU5BUXNnQlNBRUVBVWlBQTBBSUFNRVFDQUZJQVJCQkdvUUJTSUFEUUVMUVFBaEFBc2dCVUVnYWlRQUlBQUw0UUVCQTM4akFFRWdheUlFSkFBZ0JDQUFLQUlRTmdJUUlBUWdBQ2tDQ0RjRENDQUVJQUFwQWdBM0F3QUNRQ0FFSUFSQkhHb1FBaUlBRFFBZ0JDQUVRUnhxRUFJaUFBMEFJQVFnQkVFY2FoQUNJZ0FOQUNBQktBSU1JUVpCQUNFQUEwQWdBQ0lGUVFGcUlRQWdCaUFGZGcwQUN5QUVJQVZCZjJvUUEwRi9SZ1JBUVFFaEFBd0JDeUFDUVFWR0JFQWdCQ0FFUVJ4cUVBSWlBQTBCQ3lBQktBSVVJUUpCQUNFQUEwQWdBQ0lCUVFGcUlRQWdBaUFCZGcwQUN5QUVJQUZCZjJvUUEwRi9SZ1JBUVFFaEFBd0JDeUFFSUFNUUJTRUFDeUFFUVNCcUpBQWdBQXZtQVFFRGZ5TUFRU0JySWdRa0FDQUVJQUFvQWhBMkFoQWdCQ0FBS1FJSU53TUlJQVFnQUNrQ0FEY0RBQUpBSUFRZ0JFRWNhaEFDSWdBTkFDQUVJQVJCSEdvUUFpSUFEUUFnQkNBRVFSeHFFQUlpQUEwQUlBRW9BZ3doQmtFQUlRQURRQ0FBSWdWQkFXb2hBQ0FHSUFWMkRRQUxJQVFnQlVGL2FoQURRWDlHQkVCQkFTRUFEQUVMSUFKQkJVWUVRQ0FFSUFSQkhHb1FBaUlBRFFFTElBRW9BaFFoQWtFQUlRQURRQ0FBSWdGQkFXb2hBQ0FDSUFGMkRRQUxJQVFnQVVGL2FoQURJZ0JCZjBZRVFFRUJJUUFNQVFzZ0F5QUFOZ0lBUVFBaEFBc2dCRUVnYWlRQUlBQUxrZ0VCQW44akFFRWdheUlESkFBZ0F5QUFLQUlRTmdJUUlBTWdBQ2tDQURjREFDQURJQUFwQWdnM0F3Z0NRQ0FESUFOQkhHb1FBaUlBRFFBZ0F5QURRUnhxRUFJaUFBMEFJQU1nQTBFY2FoQUNJZ0FOQUVFQUlRQURRQ0FBSWdSQkFXb2hBQ0FCSUFSMkRRQUxJQU1nQkVGL2FoQURRWDlHQkVCQkFTRUFEQUVMSUFNZ0FoQUNJUUFMSUFOQklHb2tBQ0FBQzVjQkFRSi9Jd0JCSUdzaUF5UUFJQU1nQUNnQ0VEWUNFQ0FESUFBcEFnZzNBd2dnQXlBQUtRSUFOd01BQWtBZ0F5QURRUnhxRUFJaUFBMEFJQU1nQTBFY2FoQUNJZ0FOQUNBRElBTkJIR29RQWlJQURRQkJBQ0VBQTBBZ0FDSUVRUUZxSVFBZ0FTQUVkZzBBQ3lBRElBUkJmMm9RQXlJQVFYOUdCRUJCQVNFQURBRUxJQUlnQURZQ0FFRUFJUUFMSUFOQklHb2tBQ0FBQzY4T0FRcC9Jd0JCRUdzaUJTUUFJQUZCQUVIY0J4QUhJUWNnQWlnQ05DRUdJQUlvQWpnaENBSkFJQUFnQlVFRWFoQUNJZ0VOQUNBSElBVW9BZ1FpQVRZQ0FDQUJJQVlnQ0d3aUMwOEVRRUVCSVFFTUFRc2dBQ0FGUVFScUVBSWlBUTBBSUFjZ0JTZ0NCQ0lHTmdJRUlBWkJCMHNFUUVFQklRRU1BUXRCQVNFQkFrQUNRQ0FHUVFGckRnY0NBUUlDQUFJQkFBc2dCQ2dDQUVFRlJnUkFEQUlMSUFJb0Fpd05BQXdCQ3lBQUlBVkJCR29RQWlJQkRRQWdCeUFGS0FJRUlnWTJBZ2hCQVNFQklBWWdBeWdDQUVjTkFDQUNLQUlNSVFoQkFDRUJBMEFnQVNJR1FRRnFJUUVnQ0NBR2RnMEFDMEVCSVFFZ0FDQUdRWDlxRUFNaUJrRi9SZzBBSUFaQkFDQUVLQUlBSWdoQkJVWWJEUUFnQnlBR05nSU1JQWhCQlVZRVFDQUFJQVZCQkdvUUFpSUJEUUVnQnlBRktBSUVJZ1kyQWhCQkFTRUJJQVpCLy84RFN3MEJDd0pBSUFJb0FoQWlBUVIvSUFFRklBSW9BaFFoQ0VFQUlRRURRQ0FCSWdaQkFXb2hBU0FJSUFaMkRRQUxJQUFnQmtGL2FoQURJZ0ZCZjBZRVFFRUJJUUVNQXdzZ0J5QUJOZ0lVSUFNb0FnZ0VRQ0FBSUFVUUJTSUJEUU1nQnlBRktBSUFOZ0lZQ3lBRUtBSUFRUVZHQkVCQkFTRUJJQWNvQWhRaUJpQUNLQUlVUVFGMlN3MERJQVpCQUNBSEtBSVlJZ2hCSDNVZ0NIRnJSdzBEQ3lBQ0tBSVFDMEVCUncwQUlBSW9BaGdOQUNBQUlBVVFCU0lCRFFFZ0J5QUZLQUlBTmdJY0lBTW9BZ2dFUUNBQUlBVVFCU0lCRFFJZ0J5QUZLQUlBTmdJZ0N5QUVLQUlBUVFWSERRQkJBU0VCSUFjb0Fod2lCaUFIS0FJZ0lBWWdBaWdDSUdwcUlnZ2dCaUFJU0JzTkFRc2dBeWdDUkFSQUlBQWdCVUVFYWhBQ0lnRU5BU0FISUFVb0FnUWlCallDSkVFQklRRWdCa0gvQUVzTkFRc0NRQ0FIS0FJRUlnRkJCVXNOQUFKQUlBRkJBV3NPQkFFQkFRRUFDMEVCSVFFZ0FFRUJFQU1pQmtGL1JnMEJJQWNnQmpZQ0tBSkFJQVlFUUNBQUlBVkJCR29RQWlJQkRRTkJBU0VCSUFVb0FnUWlCa0VQU3cwRElBWkJBV29oQmd3QkN5QURLQUl3SWdaQkVFc05BZ3NnQnlBR05nSXNJQWNvQWdRaEFRc0NRQ0FCUVFWTERRQUNRQ0FCUVFGckRnUUJBUUVCQUFzZ0FpZ0NEQ0VKSUFjb0Fpd2hDa0VCSVFFZ0FFRUJFQU1pQmtGL1JnMEJJQWNnQmpZQ1JDQUdSUTBBUVFBaEFRTkFJQUVpQmlBS1N3UkFRUUVoQVF3REN5QUFJQVZCQ0dvUUFpSUJEUUlnQlNnQ0NDSUJRUU5MQkVCQkFTRUJEQU1MSUFjZ0JrRU1iR29pQ0NBQk5nSklBa0FnQVVFQlRRUkFJQUFnQlVFTWFoQUNJZ0VOQkNBRktBSU1JZ0VnQ1U4RVFFRUJJUUVNQlFzZ0NDQUJRUUZxTmdKTURBRUxJQUZCQWtjTkFDQUFJQVZCREdvUUFpSUJEUU1nQ0NBRktBSU1OZ0pRQ3lBR1FRRnFJUUVnQlNnQ0NFRURSdzBBQzBFQklRRWdCa1VOQVFzQ1FDQUVLQUlFUlEwQUlBUW9BZ0FoQkNBQ0tBSXNJUWxCQVNFQklBQkJBUkFESVFJZ0JFRUZSZ1JBSUFKQmYwWU5BaUFISUFJMkFwUUNJQUJCQVJBRElnSkJmMFlOQWlBSElBSTJBcGdDSUFrTkFTQUNSUTBCREFJTElBSkJmMFlOQVNBSElBSTJBcHdDSUFKRkRRQWdDVUVCZEVFRGFpRU9RUUFoQmtFQUlRcEJBQ0VFQTBBZ0JpQU9SZ1JBUVFFaEFRd0RDeUFBSUFWQkNHb1FBaUlCRFFJZ0JTZ0NDQ0lDUVFaTEJFQkJBU0VCREFNTElBY2dCa0VVYkdvaUNDQUNOZ0tnQWdKL0lBSkJmWEZCQVVZRVFDQUFJQVZCREdvUUFpSUJEUVFnQ0NBRktBSU1RUUZxTmdLa0FpQUZLQUlJSVFJTElBSkJBa1lMQkVBZ0FDQUZRUXhxRUFJaUFRMERJQWdnQlNnQ0REWUNxQUlnQlNnQ0NDRUNDd0pBSUFKQmZXb2lBVUVEU3cwQUFrQWdBVUVCYXc0Q0FRRUFDeUFBSUFWQkRHb1FBaUlCRFFNZ0NDQUZLQUlNTmdLc0FpQUZLQUlJSVFJTElBSkJCRVlFUUNBQUlBVkJER29RQWlJQkRRTWdCU2dDRENJQklBbExCRUJCQVNFQkRBUUxJQWdnQVVGL2FrSC8vd01nQVJzMkFyQUNJQXBCQVdvaENpQUZLQUlJSVFJTElBWkJBV29oQmlBTUlBSkJCa1pxSVF3Z0JDQUNRUVZHYWlFRUlBMGdBa0YvYWtFRFNXb2hEU0FDRFFBTFFRRWhBU0FFSUFweUlBeHlRUUZMRFFFZ0JFVU5BQ0FORFFFTElBQWdCUkFGSWdFTkFDQUhJQVVvQWdBaUFUWUNNQ0FGSUFFZ0F5Z0NOR29pQWpZQ0FFRUJJUUVnQWtFelN3MEFBa0FnQXlnQ1BFVU5BQ0FBSUFWQkJHb1FBaUlCRFFFZ0J5QUZLQUlFSWdJMkFqUkJBU0VCSUFKQkFrc05BU0FDUVFGR0RRQWdBQ0FGRUFVaUFRMEJRUUVoQVNBRktBSUFJZ0pCQm1wQkRFc05BU0FISUFKQkFYUTJBamdnQUNBRkVBVWlBUTBCUVFFaEFTQUZLQUlBSWdKQkJtcEJERXNOQVNBSElBSkJBWFEyQWp3TEFrQWdBeWdDREVFQ1NRMEFJQU1vQWhCQmZXcEJBa3NOQUVFQ1FRRWdDeUFMSUFNb0FpUWlBVzRpQWlBQmJHc2JJQUpxSVFSQkFDRUNBMEFnQkNBQ0lnRkJBV29pQW5ZTkFBc2dCU0FBSUFJZ0FTQUVRWDhnQVhSQmYzTnhHeEFESWdBMkFnUkJBU0VCSUFCQmYwWU5BU0FISUFBMkFrQWdBQ0FMSUFNb0FpUWlBR3BCZjJvZ0FHNUxEUUVMUVFBaEFRc2dCVUVRYWlRQUlBRUx3UWtCRFg4Z0F5QUViQ0VGSUFFb0Fnd2lDVUVCUmdSQUlBQkJBQ0FGUVFKMEVBY2FEd3NDUUFKQUFrQUNRQ0FCS0FJUUlnWkJmV3BCQWswRVFDQUJLQUlrSUFKc0lnSWdCU0FDSUFWSkd5RUxJQVpCZm5GQkJFY05BU0FGSUF0cklBc2dBU2dDSUJzaEJ3c0NRQUpBQWtBZ0JrRUZUUVJBSUFaQkFXc09CUVlGQkFNQ0FRc2dCVVVOQmlBQktBSXNJUUpCQUNFQkEwQWdBQ0FCUVFKMElnTnFJQUlnQTJvb0FnQTJBZ0FnQVVFQmFpSUJJQVZIRFFBTERBWUxBa0FnQ1FSQUlBRW9BaFFoQWtFQUlRWU1BUXNnQlVVTkJnTkFEQUFBQ3dBTEEwQkJBQ0VFSUFZZ0JVOE5CZ05BUVFBaEJ3SkFJQUlnQkVFQ2RHb2lBeWdDQUNJQlJRMEFJQUVoQnlBRklBWk5EUUJCQUNFQlFRQWdCU0FHYXlJSElBY2dCVXNiSVFnRFFDQUFJQUVnQm1wQkFuUnFJQVEyQWdBZ0FVRUJhaUlCSUFNb0FnQWlCMDhOQVNBQklBaEhEUUFMQ3lBRVFRRnFJZ1FnQ1VsQkFDQUdJQWRxSWdZZ0JVa2JEUUFMSUFZZ0JVa05BQXNNQlFzZ0EwVU5CQ0FFUlEwRVFRRWdBU2dDSUNJSmF5RUlRUUFoQlVFQUlRSURRRUVBSVFFZ0JTRUdBMEFnQUNBQklBTnNJQUpxUVFKMGFpQUpJQWdnQmlBSFNSczJBZ0FnQmtFQmFpRUdJQUZCQVdvaUFTQUVSdzBBQ3lBRUlBVnFJUVVnQWtFQmFpSUNJQU5IRFFBTERBUUxJQVZGRFFOQkFTQUJLQUlnSWdKcklRTkJBQ0VCQTBBZ0FDQUJRUUowYWlBQ0lBTWdBU0FIU1JzMkFnQWdBVUVCYWlJQklBVkhEUUFMREFNTElBRW9BaUFoQWlBRkJFQkJBQ0VCQTBBZ0FDQUJRUUowYWtFQk5nSUFJQUZCQVdvaUFTQUZSdzBBQ3dzZ0MwVU5BaUFEUVg5cUlROGdCRUYvYWlFUUlBSkJmMm9oQmtFQklBSkJBWFFpQVdzaEJTQUJRWDlxSVFrZ0JDQUNhMEVCZGlJS0lRd2dBeUFDYTBFQmRpSU5JUVFnQ2lFSUlBMGhBVUVBSVFjRFFDQUFJQU1nQ0d3Z0FXcEJBblJxSWc0b0FnQWlFVUVCUmdSQUlBNUJBRFlDQUFzZ0VVRUJSaUVPQWtBQ1FDQUdRWDlIRFFBZ0FTQUVSdzBBUVFBaEJpQUpJUUlnQkVFQklBUkJBVW9iUVg5cUlnRWhCQXdCQ3dKQUlBWkJBVWNOQUNBQklBMUhEUUJCQUNFR0lBVWhBaUFOUVFGcUlnRWdEeUFCSUE5SUd5SUJJUTBNQVFzQ1FDQUNRWDlIRFFBZ0NDQU1SdzBBUVFBaEFpQUZJUVlnREVFQklBeEJBVW9iUVg5cUlnZ2hEQXdCQ3dKQUlBSkJBVWNOQUNBSUlBcEhEUUJCQUNFQ0lBa2hCaUFLUVFGcUlnZ2dFQ0FJSUJCSUd5SUlJUW9NQVFzZ0FpQUlhaUVJSUFFZ0Jtb2hBUXNnQnlBT2FpSUhJQXRKRFFBTERBSUxJQUVvQWh3aEJ5QUJLQUlZSVFnZ0JRUkFJQWxCZjJvaEFrRUFJUUVEUUNBQUlBRkJBblJxSUFJMkFnQWdBVUVCYWlJQklBVkhEUUFMSUFKRkRRSUxJQWxCZm1vaEFRTkFBa0FnQ0NBQklnUkJBblFpQVdvb0FnQWlCaUFEYmlJQ0lBRWdCMm9vQWdBaUFTQURiaUlGU3cwQUlBWWdBaUFEYkdzaUJpQUJJQU1nQld4cklnbExCRUFEUUNBQ1FRRnFJZ0lnQlUwTkFBd0NBQXNBQ3dOQUlBSWdBMndoQ2lBR0lRRURRQ0FBSUFFZ0NtcEJBblJxSUFRMkFnQWdBVUVCYWlJQklBbE5EUUFMSUFKQkFXb2lBaUFGVFEwQUN3c2dCRUYvYWlFQklBUU5BQXNNQVFzZ0JVVU5BRUVBSVFFRFFDQUFJQUZCQW5ScUlBRWdBMjRpQWlBSmJFRUJkaUFCSUFJZ0EyeHJhaUFKY0RZQ0FDQUJRUUZxSWdFZ0JVY05BQXNMQzhRQkFRVi9JQUFvQXFnSklRUUNRQ0FBUWJBSmFpZ0NBQ0lDUlEwQUlBSkJmMm9pQWlBQlRRUkFJQUloQVF3QkN5QUFLQUs4Q1NFRkEwQUNRQ0FGSUFKQjJBRnNhaWdDQkNBRVJ3MEFJQU5CQVdvaUF5QUFLQUlRS0FJMElnWkJDaUFHUVFwTEcwa05BQ0FDSVFFTUFnc2dBa0YvYWlJQ0lBRkxEUUFMQ3dOQUFrQWdBQ2dDdkFrZ0FVSFlBV3hxSWdJb0FnUWdCRWNOQUNBQ0tBTEVBU0lEUlEwQUlBSWdBMEYvYWpZQ3hBRWdBQ2dDbEFrZ0FDZ0NtQWtnQVJBZUlnRU5BUXNMQzcwRUFndC9BWDRqQUVIQUEyc2lCU1FBSUFNb0FnQWhCeUFCS0FLd0dpRUlJQVZCQURZQ0RDQUJRYkFKYWtFQU5nSUFJQUVnQVNnQ3FBbEJBV28yQXFnSklBVWdBeWdDTUNBQktBSU1LQUkwYWpZQ0NDQUJRY1FKYWlFTklBaEJER29oRGdKQUEwQWdBU2dDdkFraEJBSkFJQU1vQWlRTkFDQUVJQWRCMkFGc2FpZ0N4QUZGRFFCQkFTRUVEQUlMSUFNcEFqUWhEeUFES0FJOElRc2dBU2dDcUFraERDQUVJQWRCMkFGc0lnWnFJZ1FnQVNnQ0RDZ0NPRFlDR0NBRUlBczJBaEFnQkNBUE53SUlJQVFnRERZQ0JBSkFJQU1vQWdRaUJFRUNSZzBBSUFrTkFDQUVRUWRHRFFBZ0FDQUZRUXhxRUFJaUJBMENJQVVvQWd3aUJDQUJLQUtZQ1NBSGEwc0VRRUVCSVFRTUF3c2dCRVVFUUVFQUlRa01BUXNnRGtFQVFhUUJFQWNhSUFoQkFEWUNBRUVCSVFrTEFrQWdCU2dDRENJRUJFQWdCU0FFUVg5cU5nSU1EQUVMUVFBaENTQUFJQWdnQVNnQ3ZBa2dCbW9nQXlnQ0JDQURLQUlzRUZFaUJBMENDeUFCS0FLOENTQUdhaUFJSUFJZ0RTQUZRUWhxSUFjZ0FTZ0NEQ2dDUUNBRlFSQnFFRkFpQkEwQklBRW9BcndKSUFacUtBTEVBU0VMSUFBUUxpRUVJQVVvQWd3aEJnSkFJQU1vQWdSQmZtb2lERUVGU3cwQUFrQWdERUVCYXc0RUFRRUJBUUFMSUFFZ0J6WUNzQWtMSUFRZ0JuSWhCa0VCSVFRZ0FTZ0NsQWtnQVNnQ21Ba2dCeEFlSWdkRlFRQWdCaHNOQVNBS0lBdEJBVVpxSVFvZ0JnMEFDeUFCUWF3SmFpZ0NBQ0FLYWlJQUlBRW9BcGdKU3cwQUlBRWdBRFlDckFsQkFDRUVDeUFGUWNBRGFpUUFJQVFMNWdJQkIzOUJBU0VDQWtBZ0FDZ0NBQ0FCS0FJQVJ3MEFJQUFvQWdRZ0FTZ0NCRWNOQUNBQUtBSU1JQUVvQWd4SERRQWdBQ2dDRUNJRElBRW9BaEJIRFFBZ0FDZ0NMQ0FCS0FJc1J3MEFJQUFvQWpBZ0FTZ0NNRWNOQUNBQUtBSTBJQUVvQWpSSERRQWdBQ2dDT0NBQktBSTRSdzBBSUFBb0Fqd2lCU0FCS0FJOFJ3MEFJQUFvQWxBZ0FTZ0NVRWNOQUFKQUlBTkJBVXNOQUNBRFFRRnJSUVJBSUFBb0FoZ2dBU2dDR0VjTkFpQUFLQUljSUFFb0FoeEhEUUlnQUNnQ0lDQUJLQUlnUncwQ0lBQW9BaVFpQkNBQktBSWtSdzBDSUFSRkRRRWdBU2dDS0NFR0lBQW9BaWdoQjBFQUlRTURRQ0FISUFOQkFuUWlDR29vQWdBZ0JpQUlhaWdDQUVjTkF5QUVJQU5CQVdvaUEwY05BQXNNQVFzZ0FDZ0NGQ0FCS0FJVVJ3MEJDeUFGQkVBZ0FDZ0NRQ0FCS0FKQVJ3MEJJQUFvQWtRZ0FTZ0NSRWNOQVNBQUtBSklJQUVvQWtoSERRRWdBQ2dDVENBQktBSk1SdzBCQzBFQUlRSUxJQUlML3drQkJuOGpBRUVRYXlJRUpBQWdBVUVBUWR3QUVBY2hBd0pBSUFCQkNCQURJZ0ZCZjBZRVFFRUJJUUVNQVFzZ0F5QUJOZ0lBSUFCQkFSQURHaUFBUVFFUUF4b2dBRUVCRUFOQmYwWUVRRUVCSVFFTUFRc2dBRUVGRUFOQmYwWUVRRUVCSVFFTUFRc2dBRUVJRUFNaUFVRi9SZ1JBUVFFaEFRd0JDeUFESUFFMkFnUWdBQ0FEUVFocUVBSWlBUTBBSUFNb0FnaEJIMHNFUUVFQklRRU1BUXNnQUNBRVFReHFFQUlpQVEwQVFRRWhBU0FFS0FJTUlnSkJERXNOQUNBRFFRRWdBa0VFYW5RMkFnd2dBQ0FFUVF4cUVBSWlBUTBBUVFFaEFTQUVLQUlNSWdKQkFrc05BQ0FESUFJMkFoQUNRQ0FDUVFGTERRQWdBa0VCYXdSQUlBQWdCRUVNYWhBQ0lnRU5Ba0VCSVFFZ0JDZ0NEQ0lDUVF4TERRSWdBMEVCSUFKQkJHcDBOZ0lVREFFTElBQkJBUkFESWdKQmYwWU5BU0FESUFKQkFVWTJBaGdnQUNBRFFSeHFFQVVpQVEwQklBQWdBMEVnYWhBRklnRU5BU0FBSUFOQkpHb1FBaUlCRFFGQkFTRUJJQU1vQWlRaUFrSC9BVXNOQVNBQ0JFQWdBeUFDUVFKMEVBb2lBVFlDS0NBQlJRUkFRZi8vQXlFQkRBTUxJQUFnQVJBRklnRU5Ba0VCSVFJRFFDQUNJQU1vQWlSUERRSWdBa0VDZENFQklBSkJBV29oQWlBQUlBRWdBeWdDS0dvUUJTSUJSUTBBQ3d3Q0N5QURRUUEyQWlnTElBQWdBMEVzYWhBQ0lnRU5BRUVCSVFFZ0F5Z0NMRUVRU3cwQUlBQkJBUkFESWdKQmYwWU5BQ0FESUFKQkFVWTJBakFnQUNBRVFReHFFQUlpQVEwQUlBTWdCQ2dDREVFQmFqWUNOQ0FBSUFSQkRHb1FBaUlCRFFCQkFTRUJJQU1nQkNnQ0RFRUJhallDT0NBQVFRRVFBMEVCYWtFQ1NRMEFJQUJCQVJBRFFYOUdEUUFnQUVFQkVBTWlBa0YvUmcwQUlBTWdBa0VCUmlJQk5nSThBa0FnQVVVRVFDQURLQUk0SVFVZ0F5Z0NOQ0VHREFFTElBQWdBMEZBYXhBQ0lnRU5BU0FBSUFOQnhBQnFFQUlpQVEwQklBQWdBMEhJQUdvUUFpSUJEUUVnQUNBRFFjd0FhaEFDSWdFTkFVRUJJUUVnQXlnQ1FDQURLQUpFUVg5eklBTW9BalFpQmtFRGRHcEtEUUVnQXlnQ1NDQURLQUpNUVg5eklBTW9BamdpQlVFRGRHcEtEUUVMQWtBQ1FBSkFBa0FnQXlnQ0JFRjJhaUlIUVNsTERRQkI0d0FoQVVHQXBBa2hBZ0pBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBZ0IwRUJhdzRwQUFFQkN3c0xDd3NMQVFJREN3c0xDd3NMQ3dNRUJRc0xDd3NMQ3dzR0JnY0xDd3NMQ3dzTENBa0tDMEdNQXlFQlFZQ01GU0VDREFrTFFZd0RJUUZCZ05nM0lRSU1DQXRCbUFZaEFVR0FzTzhBSVFJTUJ3dEIxQXdoQVVHQTdMMEJJUUlNQmd0QmtCd2hBVUdBOEtVRElRSU1CUXRCZ0NnaEFVR0FnT0FESVFJTUJBdEJnTUFBSVFGQmdJQ0FCaUVDREFNTFFZREVBQ0VCUVlDQXNBWWhBZ3dDQzBIQXJBRWhBVUdBd0pzVUlRSU1BUXRCZ0tBQ0lRRkJnSURnSVNFQ0N5QUJJQVVnQm13aUFVOE5BUXNnQkVILy8vLy9CellDRENBREtBSXNJUUlNQVFzZ0JDQUNJQUZCZ0FOc2JpSUJRUkFnQVVFUVNSc2lBVFlDRENBREtBSXNJZ0lnQVUwTkFRc2dCQ0FDTmdJTUlBSWhBUXNnQXlBQk5nSllRUUVoQVNBQVFRRVFBeUlDUVg5R0RRQWdBeUFDUVFGR05nSlFBa0FnQWtFQlJ3MEFJQU5CdUFjUUNpSUJOZ0pVSUFGRkJFQkIvLzhESVFFTUFnc2dBQ0FCRUN3aUFRMEJJQU1vQWxRaUFpZ0NtQWRGRFFCQkFTRUJJQUlvQXJBSElBSW9BclFISWdKTERRRWdBaUFES0FJc1NRMEJJQUlnQXlnQ1dFc05BU0FESUFKQkFTQUNHellDV0FzZ0FCQWZRUUFoQVFzZ0JFRVFhaVFBSUFFTGpRUUJEbjhnQVFKL0FrQWdBQzhCSUNJSERRQWdBQzhCSEEwQVFRQU1BUXRCQWdzMkFpQWdBUUovQWtBZ0FDOEJJaUlDRFFBZ0FDOEJIZzBBUVFBTUFRdEJBZ3MyQWlnZ0FRSi9Ba0FnQUM4QktDSUREUUFnQUM4QkpBMEFRUUFNQVF0QkFnczJBakFnQVFKL0FrQWdBQzhCS2lJSURRQWdBQzhCSmcwQVFRQU1BUXRCQWdzMkFqZ2dBU0FISUFBdkFTd2lDWEpCQUVkQkFYUTJBa0FnQVNBQ0lBQXZBUzRpQkhKQkFFZEJBWFEyQWtnZ0FTQURJQUF2QVRRaUJYSkJBRWRCQVhRMkFsQWdBU0FJSUFBdkFUWWlDbkpCQUVkQkFYUTJBbGdnQVNBQUx3RXdJZzBnQ1hKQkFFZEJBWFEyQW1BZ0FTQUFMd0V5SWdzZ0JISkJBRWRCQVhRMkFtZ2dBU0FBTHdFNElnd2dCWEpCQUVkQkFYUTJBbkFnQVNBQUx3RTZJZzRnQ25KQkFFZEJBWFEyQW5oQkFpRUdJQUVnQUM4QkhpSVBCSDlCQWdVZ0FDOEJIRUVBUjBFQmRBczJBZ3dnQVNBUElBQXZBU1FpQm5KQkFFZEJBWFEyQWhRZ0FDOEJKaUVBSUFFZ0RDQU9ja0VBUjBFQmREWUNmQ0FCSUFzZ0RISkJBRWRCQVhRMkFuUWdBU0FMSUExeVFRQkhRUUYwTmdKc0lBRWdCU0FLY2tFQVIwRUJkRFlDWENBQklBUWdCWEpCQUVkQkFYUTJBbFFnQVNBRUlBbHlRUUJIUVFGME5nSk1JQUVnQXlBSWNrRUFSMEVCZERZQ1BDQUJJQUlnQTNKQkFFZEJBWFEyQWpRZ0FTQUNJQWR5UVFCSFFRRjBOZ0lzSUFFZ0FDQUdja0VBUjBFQmREWUNIQXZNQmdFTGZ5TUFRWUFPYXlJT0pBQWdCa0VGYWlFSUFrQUNRQ0FDUVFCSURRQWdBMEVBU0EwQUlBSWdDR29nQkVzTkFDQUhRUVZxSWdvZ0Eyb2dCVXNOQUNBRUlRZ2dBeUVKREFFTElBQWdEa0hBQ21vZ0FpQURJQVFnQlNBSUlBZEJCV29pQ2lBSUVBd2dEa0hBQ21vaEFFRUFJUUlMQWtBZ0NrVU5BQ0FHUVFKMkloQkZEUUFnQ0NBR2F5RVJJQUFnQ0NBSmJDQUNhbXBCQldvaEFpQU9JUUFEUUNBQ1FYOXFMUUFBSVFnZ0FrRithaTBBQUNFRElBSkJmV290QUFBaEJTQUNRWHhxTFFBQUlRUWdBa0Y3YWkwQUFDRU1JQkFoRFFOQUlBQWdBaTBBQUNJSklBd2dCQ0FJYWlJTGF5QURJQVZxUVJSc2FpQUxRUUowYTJvMkFnQWdBQ0FDTFFBQklnc2dBeUFJYWtFVWJDQUVhaUFGSUFscUlnUnJJQVJCQW5ScmFqWUNCQ0FBSUFJdEFBSWlEeUFJSUFscVFSUnNJQVZxSUFNZ0Myb2lCR3NnQkVFQ2RHdHFOZ0lJSUFBZ0FpMEFBeUlTSUFrZ0MycEJGR3dnQTJvZ0NDQVBhaUlEYXlBRFFRSjBhMm8yQWd3Z0FFRVFhaUVBSUFKQkJHb2hBaUFJSVF3Z0NTRUVJQXNoQlNBUElRTWdFaUVJSUExQmYyb2lEUTBBQ3lBQ0lCRnFJUUlnQ2tGL2FpSUtEUUFMQ3dKQUlBZEJBbllpQjBVTkFDQUdSUTBBUWNBQUlBWnJJUThnRGlBR1FRSjBhaUlJSUFaQkZHeHFJUUpCQUNBR2F5SVFRUU4wSVJJZ0JrRURkQ0VKSUFaQkEyeEJBblFoQ3dOQUlBWWhCQU5BSUFFZ0NDQUphaWdDQUNJQUlBSWdDV29vQWdBZ0FpQUdRUUowSWcxcUtBSUFJZ29nQWlBU2FpZ0NBQ0lEYWlJRmF5QUZRUUowYTJvZ0FpZ0NBQ0lNSUFJZ0VFRUNkQ0lSYWlnQ0FDSUZha0VVYkdwQmdBUnFRUXAxUWJBdWFpMEFBRG9BTUNBQklBZ2dEV29vQWdBaURTQUtJQU1nQldwQkZHeHFJQUFnREdvaUNtc2dDa0VDZEd0cVFZQUVha0VLZFVHd0xtb3RBQUE2QUNBZ0FTQUlLQUlBSWdvZ0RDQUFJQU5xUVJSc2FpQUZJQTFxSWd4cklBeEJBblJyYWtHQUJHcEJDblZCc0M1cUxRQUFPZ0FRSUFFZ0NDQVJhaWdDQUNBRklBQWdEV3BCRkd4cUlBTWdDbW9pQUdzZ0FFRUNkR3RxUVlBRWFrRUtkVUd3TG1vdEFBQTZBQUFnQ0VFRWFpRUlJQUZCQVdvaEFTQUNRUVJxSVFJZ0JFRi9haUlFRFFBTElBRWdEMm9oQVNBQ0lBdHFJUUlnQ0NBTGFpRUlJQWRCZjJvaUJ3MEFDd3NnRGtHQURtb2tBQXZsQXdFSmZ5TUFRY0FEYXlJS0pBQWdCa0VGYWlFSUFrQUNRQ0FDUVFCSURRQWdBeUFIYWlBRlN3MEFJQU5CQUVnTkFDQUNJQWhxSUFSTERRQWdCQ0VJSUFNaENRd0JDeUFBSUFvZ0FpQURJQVFnQlNBSUlBY2dDQkFNSUFvaEFFRUFJUUlMQWtBZ0IwVU5BQ0FHUVFKMklnMUZEUUJCRUNBR2F5RU9JQWdnQm1zaER5QUFJQWdnQ1d3Z0FtcHFRUVZxSVFJRFFDQUNRWDlxTFFBQUlRZ2dBa0YrYWkwQUFDRUdJQUpCZldvdEFBQWhBQ0FDUVh4cUxRQUFJUVVnQWtGN2FpMEFBQ0VKSUEwaEN3TkFJQUVnQWkwQUFDSURJQWtnQlNBSWFpSUVheUFBSUFacVFSUnNhaUFFUVFKMGEycEJFR3BCQlhWQnNDNXFMUUFBT2dBQUlBRWdBaTBBQVNJRUlBVWdCaUFJYWtFVWJHb2dBQ0FEYWlJRmF5QUZRUUowYTJwQkVHcEJCWFZCc0M1cUxRQUFPZ0FCSUFFZ0FpMEFBaUlNSUFBZ0F5QUlha0VVYkdvZ0JDQUdhaUlBYXlBQVFRSjBhMnBCRUdwQkJYVkJzQzVxTFFBQU9nQUNJQUVnQWkwQUF5SVFJQVlnQXlBRWFrRVViR29nQ0NBTWFpSUFheUFBUVFKMGEycEJFR3BCQlhWQnNDNXFMUUFBT2dBRElBRkJCR29oQVNBQ1FRUnFJUUlnQ0NFSklBTWhCU0FFSVFBZ0RDRUdJQkFoQ0NBTFFYOXFJZ3NOQUFzZ0FTQU9haUVCSUFJZ0Qyb2hBaUFIUVg5cUlnY05BQXNMSUFwQndBTnFKQUFMOVFNQkMzOGpBRUhBQTJzaUN5UUFBa0FDUUNBQ1FRQklEUUFnQTBFQVNBMEFJQUlnQm1vZ0JFc05BQ0FESUFkcVFRVnFJQVZMRFFBZ0F5RUlEQUVMSUFBZ0N5QUNJQU1nQkNBRklBWWdCMEVGYWlBR0VBd2dDeUVBSUFZaEJFRUFJUUlMQWtBZ0IwRUNkaUlNUlEwQUlBWkZEUUJCd0FBZ0Jtc2hFU0FFUVFGMElRMGdCRUVDZENBR2F5RU9RUUFnQkdzaUQwRUJkQ0VTSUFBZ0JDQUliQ0FDYW1vZ0JHb2lCeUFFUVFWc2FpRUNBMEFnQmlFQUEwQWdBU0FISUExcUxRQUFJZ01nQWlBTmFpMEFBQ0FDSUFScUxRQUFJZ2tnQWlBU2FpMEFBQ0lGYWlJSWF5QUlRUUowYTJvZ0FpMEFBQ0lLSUFJZ0Qyb3RBQUFpQ0dwQkZHeHFRUkJxUVFWMVFiQXVhaTBBQURvQU1DQUJJQVFnQjJvdEFBQWlFQ0FKSUFVZ0NHcEJGR3hxSUFNZ0Ntb2lDV3NnQ1VFQ2RHdHFRUkJxUVFWMVFiQXVhaTBBQURvQUlDQUJJQWN0QUFBaUNTQUtJQU1nQldwQkZHeHFJQWdnRUdvaUNtc2dDa0VDZEd0cVFSQnFRUVYxUWJBdWFpMEFBRG9BRUNBQklBY2dEMm90QUFBZ0NDQURJQkJxUVJSc2FpQUZJQWxxSWdOcklBTkJBblJyYWtFUWFrRUZkVUd3TG1vdEFBQTZBQUFnQjBFQmFpRUhJQUZCQVdvaEFTQUNRUUZxSVFJZ0FFRi9haUlBRFFBTElBRWdFV29oQVNBQ0lBNXFJUUlnQnlBT2FpRUhJQXhCZjJvaURBMEFDd3NnQzBIQUEyb2tBQXVxQmdFTmZ5TUFRYkFCYXlJUkpBQWdDRUVCYWlFS0FrQUNRQ0FDUVFCSURRQWdBMEVBU0EwQUlBSWdDbW9nQkVzTkFDQURJQWxxUVFGcUlBVkxEUUFnQlNFTUlBUWhDaUFESVE4TUFRc2dBQ0FSSUFJZ0F5QUVJQVVnQ2lBSlFRRnFJZ3dnQ2hBTUlBQWdCQ0FGYkdvZ0VTQUtJQXhzYWlBQ0lBTWdCQ0FGSUFvZ0RDQUtFQXdnRVNFQVFRQWhBZ3NDUUNBSlFRRjJJZ1ZGRFFBZ0NFRUJkaUlFUlEwQVFSQWdDR3NoRTBFSUlBZHJJUXRCQ0NBR2F5RU5JQXBCQVhRaURpQUlheUVVSUFBZ0Ftb2lGaUFLSUE5c2FpRUNJQUVoQUNBRklSVURRQ0FDSUE1cUxRQUFJQWRzSUFzZ0FpQUthaTBBQUNJRGJHb2hDQ0FESUFkc0lBc2dBaTBBQUd4cUlRa2dCQ0VEQTBBZ0FrRUJhaUlRSUE1cUxRQUFJUklnQUNBSklBMXNJQW9nRUdvdEFBQWlDU0FIYkNBTElBSXRBQUZzYWlJUUlBWnNha0VnYWtFR2Rqb0FBQ0FBSUFnZ0RXd2dCeUFTYkNBSklBdHNhaUlJSUFac2FrRWdha0VHZGpvQUNDQUNMUUFDSVFrZ0FrRUNhaUlDSUE1cUxRQUFJUklnQUNBTklCQnNJQUlnQ21vdEFBQWlFQ0FIYkNBSklBdHNhaUlKSUFac2FrRWdha0VHZGpvQUFTQUFJQWdnRFd3Z0J5QVNiQ0FMSUJCc2FpSUlJQVpzYWtFZ2FrRUdkam9BQ1NBQVFRSnFJUUFnQTBGL2FpSUREUUFMSUFJZ0ZHb2hBaUFBSUJOcUlRQWdGVUYvYWlJVkRRQUxJQUZCUUdzaEFDQVdJQXdnRDJvZ0NteHFJUUlEUUNBQ0lBNXFMUUFBSUFkc0lBc2dBaUFLYWkwQUFDSUJiR29oQ0NBQklBZHNJQXNnQWkwQUFHeHFJUWtnQkNFREEwQWdBa0VCYWlJQklBNXFMUUFBSVF3Z0FDQUpJQTFzSUFFZ0Ntb3RBQUFpQVNBSGJDQUxJQUl0QUFGc2FpSUpJQVpzYWtFZ2FrRUdkam9BQUNBQUlBZ2dEV3dnQnlBTWJDQUJJQXRzYWlJQklBWnNha0VnYWtFR2Rqb0FDQ0FDTFFBQ0lRZ2dBa0VDYWlJQ0lBNXFMUUFBSVF3Z0FDQUpJQTFzSUFJZ0Ntb3RBQUFpRHlBSGJDQUlJQXRzYWlJSklBWnNha0VnYWtFR2Rqb0FBU0FBSUFFZ0RXd2dCeUFNYkNBTElBOXNhaUlJSUFac2FrRWdha0VHZGpvQUNTQUFRUUpxSVFBZ0EwRi9haUlERFFBTElBSWdGR29oQWlBQUlCTnFJUUFnQlVGL2FpSUZEUUFMQ3lBUlFiQUJhaVFBQy85RUFVRi9Jd0JCc0FGcklnTWtBQ0FBS0FJSUlnUUVRQ0FBS0FJRUloOUJBM1FoRmlBRUlCOXNJZ1JCQm5RaE95QUVRUWgwSVR3Z0gwRUdkQ0U5SUI5Qk1Hd2hQaUFmUVFWMElTVWdIMEZRYkNFclFRQWdIMEVFZENJYWF5SW9RUUowSVQ4Z0tFRUJkQ0VzSUFOQkdHb2hJaUFEUVF4eUlTTURRQUpBSUFFb0FnZ2lDVUVCUmcwQUFrQUNRQUpBQWtBZ0FTZ0N5QUVpQWtVRVFFRUJJUVlNQVF0QkJTRUdJQWxCQWtjTkFFRUZRUUVnQVNnQ0JDSUpJQUlvQWdSR0d5RUdJQUVvQXN3QklnUU5BVUVBSVFRTUF3c2dBU2dDekFFaUJFVUVRRUVBSVFRTUF3c2dDVUVDUncwQklBRW9BZ1FoQ1FzZ0NTQUVLQUlFUncwQkN5QUdRUUp5SVFZTEFuOGdCa0VDY1NJdEJFQUNRQ0FCS0FJQVFRVk5CRUFnQkNnQ0FFRUdTUTBCQ3lBRFFRUTJBa0FnQTBFRU5nSklJQU5CQkRZQ09DQURRUVEyQWpCQkFRd0NDMEVDSVE5QkFpRUpBa0FnQVM4QkhBMEFJQVF2QVRBTkFFRUJJUWtnQVNnQ2RDQUVLQUo4UncwQUlBRXVBWVFCSUFRdUFhd0JheUlGSUFWQkgzVWlCV29nQlhOQkEwc05BQ0FCTGdHR0FTQUVMZ0d1QVdzaUNTQUpRUjkxSWdscUlBbHpRUU5MSVFrTElBTWdDVFlDTUFKQUlBRXZBUjROQUNBRUx3RXlEUUJCQVNFUElBRW9BblFnQkNnQ2ZFY05BQ0FCTGdHSUFTQUVMZ0d3QVdzaUJTQUZRUjkxSWdWcUlBVnpRUU5MRFFBZ0FTNEJpZ0VnQkM0QnNnRnJJZ1VnQlVFZmRTSUZhaUFGYzBFRFN5RVBDeUFESUE4MkFqaEJBaUVGUVFJaENnSkFJQUV2QVNRTkFDQUVMd0U0RFFCQkFTRUtJQUVvQW5nZ0JDZ0NnQUZIRFFBZ0FTNEJsQUVnQkM0QnZBRnJJZ2dnQ0VFZmRTSUlhaUFJYzBFRFN3MEFJQUV1QVpZQklBUXVBYjRCYXlJSUlBaEJIM1VpQ0dvZ0NITkJBMHNoQ2dzZ0F5QUtOZ0pBQWtBZ0FTOEJKZzBBSUFRdkFUb05BRUVCSVFVZ0FTZ0NlQ0FFS0FLQUFVY05BQ0FCTGdHWUFTQUVMZ0hBQVdzaUNDQUlRUjkxSWdocUlBaHpRUU5MRFFBZ0FTNEJtZ0VnQkM0QndnRnJJZ1FnQkVFZmRTSUVhaUFFYzBFRFN5RUZDeUFESUFVMkFrZ2dDU0FQY2lBS2NpQUZja0VBUnd3QkN5QURRUUEyQWtBZ0EwRUFOZ0pJSUFOQkFEWUNPQ0FEUVFBMkFqQkJBQXNoQ1FKQUFrQUNRQUpBSUFaQkJIRWlMZ1JBQWtBZ0FTZ0NBQ0lHUVFWTkJFQWdBaWdDQUVFR1NRMEJDeUFEUVFRMkFuUWdBMEVFTmdLVUFTQURRUVEyQWxRZ0EwRUVOZ0kwUVFFaENRd0NDMEVDSVE5QkFpRUVBa0FnQVM4QkhBMEFJQUl2QVNZTkFFRUJJUVFnQVNnQ2RDQUNLQUo0UncwQUlBRXVBWVFCSUFJdUFaZ0JheUlGSUFWQkgzVWlCV29nQlhOQkEwc05BQ0FCTGdHR0FTQUNMZ0dhQVdzaUJDQUVRUjkxSWdScUlBUnpRUU5MSVFRTElBTWdCRFlDTkFKQUlBRXZBU0FOQUNBQ0x3RXFEUUJCQVNFUElBRW9BblFnQWlnQ2VFY05BQ0FCTGdHTUFTQUNMZ0dnQVdzaUJTQUZRUjkxSWdWcUlBVnpRUU5MRFFBZ0FTNEJqZ0VnQWk0Qm9nRnJJZ1VnQlVFZmRTSUZhaUFGYzBFRFN5RVBDeUFESUE4MkFsUkJBaUVGUVFJaENnSkFJQUV2QVN3TkFDQUNMd0UyRFFCQkFTRUtJQUVvQW53Z0FpZ0NnQUZIRFFBZ0FTNEJwQUVnQWk0QnVBRnJJZ2dnQ0VFZmRTSUlhaUFJYzBFRFN3MEFJQUV1QWFZQklBSXVBYm9CYXlJSUlBaEJIM1VpQ0dvZ0NITkJBMHNoQ2dzZ0F5QUtOZ0owQWtBZ0FTOEJNQTBBSUFJdkFUb05BRUVCSVFVZ0FTZ0NmQ0FDS0FLQUFVY05BQ0FCTGdHc0FTQUNMZ0hBQVdzaUNDQUlRUjkxSWdocUlBaHpRUU5MRFFBZ0FTNEJyZ0VnQWk0QndnRnJJZ1VnQlVFZmRTSUZhaUFGYzBFRFN5RUZDeUFESUFVMkFwUUJJQWxGRFFKQkFTRUpEQU1MSUFOQkFEWUNkQ0FEUVFBMkFwUUJJQU5CQURZQ1ZDQURRUUEyQWpRZ0FTZ0NBQ0VHQ3lBR1FRWkpEUUVnQTBFRE5nS2dBU0FEUW9PQWdJQXdOd0trQVNBRFFRTTJBcEFCSUFOQkF6WUNjQ0FEUVFNMkFxd0JJQU5DZzRDQWdEQTNBNWdCSUFOQ2c0Q0FnREEzQTRnQklBTkNnNENBZ0RBM0E0QUJJQU5DZzRDQWdEQTNBM2dnQTBLRGdJQ0FNRGNEYUNBRFFvT0FnSUF3TndOZ0lBTkNnNENBZ0RBM0ExZ2dBMEtEZ0lDQU1EY0NUQ0FEUVFNMkFrUWdBMEVETmdJOERBSUxJQVFnRDNJZ0NuSWdCWEpCQUVjaENRc0NRQUovSUFaQkEwMEVRQ0FHUVFKMFFZdzFhaWdDQUF3QkMwRUVDMEVCUmdSQUlBRWdBMEV3YWhCRUlBTW9BcXdCSVFjZ0F5Z0NwQUVoRGlBREtBS2NBU0VRSUFNb0Fvd0JJUmtnQXlnQ2hBRWhCaUFES0FKOElSY2dBeWdDYkNFSUlBTW9BbVFoQkNBREtBSmNJUlFnQXlnQ1RDRU1JQU1vQWtRaEFpQURLQUk4SVJFZ0F5Z0NxQUVoSENBREtBS2dBU0VtSUFNb0FwZ0JJUTBnQXlnQ2tBRWhIU0FES0FLSUFTRVNJQU1vQW9BQklSVWdBeWdDZUNFYklBTW9BbkFoRXlBREtBSm9JUW9nQXlnQ1lDRVBJQU1vQWxnaEJTQURLQUpRSVNjTUFRc2dBd0ovQWtBZ0F3Si9Ba0FDUUNBQktBSUFRWDVxSWdSQkFVMEVRQ0FFUVFGckJFQWdBd0ovQWtBZ0FTOEJJQ0lFRFFBZ0FTOEJIQTBBUVFBTUFRdEJBZ3NpSnpZQ1VDQURBbjhDUUNBQkx3RWlJZ2NOQUNBQkx3RWVEUUJCQUF3QkMwRUNDeUlGTmdKWUlBTUNmd0pBSUFFdkFTZ2lCZzBBSUFFdkFTUU5BRUVBREFFTFFRSUxJZzgyQW1BZ0F3Si9Ba0FnQVM4QktpSU9EUUFnQVM4QkpnMEFRUUFNQVF0QkFnc2lDallDYUNBREFuOENRQ0FCTHdFd0loNE5BQ0FCTHdFc0RRQkJBQXdCQzBFQ0N5SWROZ0tRQVNBREFuOENRQ0FCTHdFeUloQU5BQ0FCTHdFdURRQkJBQXdCQzBFQ0N5SU5OZ0tZQVNBREFuOENRQ0FCTHdFNElnc05BQ0FCTHdFMERRQkJBQXdCQzBFQ0N5SW1OZ0tnQVNBREFuOENRQ0FCTHdFNkloZ05BQ0FCTHdFMkRRQkJBQXdCQzBFQ0N5SWNOZ0tvQVVFQ0lSdEJBaUVUQWtBZ0JDQUJMd0VzSWhkeURRQkJBU0VUSUFFdUFhUUJJQUV1QVl3QmF5SUNJQUpCSDNVaUFtb2dBbk5CQTBzTkFDQUJMZ0dtQVNBQkxnR09BV3NpQWlBQ1FSOTFJZ0pxSUFKelFRTkxEUUFnQVNnQ2ZDQUJLQUowUnlFVEN5QURJQk0yQW5BQ1FDQUhJQUV2QVM0aUlISU5BRUVCSVJzZ0FTNEJxQUVnQVM0QmtBRnJJZ0lnQWtFZmRTSUNhaUFDYzBFRFN3MEFJQUV1QWFvQklBRXVBWklCYXlJQ0lBSkJIM1VpQW1vZ0FuTkJBMHNOQUNBQktBSjhJQUVvQW5SSElSc0xJQU1nR3pZQ2VFRUNJUkpCQWlFVkFrQWdCaUFCTHdFMElobHlEUUJCQVNFVklBRXVBYlFCSUFFdUFad0JheUlDSUFKQkgzVWlBbW9nQW5OQkEwc05BQ0FCTGdHMkFTQUJMZ0dlQVdzaUFpQUNRUjkxSWdKcUlBSnpRUU5MRFFBZ0FTZ0NnQUVnQVNnQ2VFY2hGUXNnQXlBVk5nS0FBUUpBSUE0Z0FTOEJOaUloY2cwQVFRRWhFaUFCTGdHNEFTQUJMZ0dnQVdzaUFpQUNRUjkxSWdKcUlBSnpRUU5MRFFBZ0FTNEJ1Z0VnQVM0Qm9nRnJJZ0lnQWtFZmRTSUNhaUFDYzBFRFN3MEFJQUVvQW9BQklBRW9BbmhISVJJTElBTWdFallDaUFFZ0FTOEJIZzBDSUFFdkFSd0VRRUVDSVJFZ0EwRUNOZ0k4SUFFdkFTUWlDQTBHUVFBaERFRUFEQWNMUVFBaEVTQURRUUEyQWp4QkFDRU1RUUFnQVM4QkpDSUlSUTBHR2d3RkN5QURBbjhDUUNBQkx3RWdJZ0lOQUNBQkx3RWNEUUJCQUF3QkMwRUNDeUluTmdKUUlBTUNmd0pBSUFFdkFTSWlCZzBBSUFFdkFSNE5BRUVBREFFTFFRSUxJZ1UyQWxnZ0F3Si9Ba0FnQVM4QktDSU9EUUFnQVM4QkpBMEFRUUFNQVF0QkFnc2lEellDWUNBREFuOENRQ0FCTHdFcUlnZ05BQ0FCTHdFbURRQkJBQXdCQzBFQ0N5SUtOZ0pvSUFNZ0FpQUJMd0VzSWhkeVFRQkhRUUYwSWhNMkFuQWdBeUFHSUFFdkFTNGlDM0pCQUVkQkFYUWlHellDZUNBRElBNGdBUzhCTkNJZWNrRUFSMEVCZENJVk5nS0FBU0FESUFnZ0FTOEJOaUlaY2tFQVIwRUJkQ0lTTmdLSUFTQURJQUV2QVRBaUVDQVhja0VBUjBFQmRDSWROZ0tRQVNBRElBRXZBVElpSUNBTGNrRUFSMEVCZENJTk5nS1lBU0FESUFFdkFUZ2lJU0FlY2tFQVIwRUJkQ0ltTmdLZ0FTQURJQUV2QVRvaUJ5QVpja0VBUjBFQmRDSWNOZ0tvQVNBREFuOENRQ0FCTHdFZUlpUU5BQ0FCTHdFY0RRQkJBQXdCQzBFQ0N5SVJOZ0k4SUFFdkFTWUVRQ0FCTHdFa0lSZ01Bd3NnQVM4QkpDSVlEUUpCQUNFWVFRQU1Bd3NnQVM0QmhnRWhGQ0FCTGdHT0FTRUVRUUloQlNBREFuOUJBaUFCTHdFY0loRWdBUzhCSUNJdmNnMEFHa0VCSUFFdUFZd0JJQUV1QVlRQmF5SUdJQVpCSDNVaUJtb2dCbk5CQTBzTkFCb2dCQ0FVYXlJR0lBWkJIM1VpQm1vZ0JuTkJBMHNMSWljMkFsQWdBUzRCaWdFaENDQUJMZ0dTQVNFR0FrQWdBUzhCSGlJd0lBRXZBU0lpRUhJTkFFRUJJUVVnQVM0QmtBRWdBUzRCaUFGcklnSWdBa0VmZFNJQ2FpQUNjMEVEU3cwQUlBWWdDR3NpQlNBRlFSOTFJZ1ZxSUFWelFRTkxJUVVMSUFNZ0JUWUNXQ0FCTGdHV0FTRU1JQUV1QVo0QklRZEJBaUVLSUFNQ2YwRUNJQUV2QVNRaU1TQUJMd0VvSWhkeURRQWFRUUVnQVM0Qm5BRWdBUzRCbEFGcklnSWdBa0VmZFNJQ2FpQUNjMEVEU3cwQUdpQUhJQXhySWdJZ0FrRWZkU0lDYWlBQ2MwRURTd3NpRHpZQ1lDQUJMZ0dhQVNFeUlBRXVBYUlCSVFzQ1FDQUJMd0VtSWtBZ0FTOEJLaUl6Y2cwQVFRRWhDaUFCTGdHZ0FTQUJMZ0dZQVdzaUFpQUNRUjkxSWdKcUlBSnpRUU5MRFFBZ0N5QXlheUlDSUFKQkgzVWlBbW9nQW5OQkEwc2hDZ3NnQXlBS05nSm9JQUV1QWFZQklSNUJBaUViUVFJaEV3SkFJQzhnQVM4QkxDSTBjZzBBUVFFaEV5QUJMZ0drQVNBQkxnR01BV3NpQWlBQ1FSOTFJZ0pxSUFKelFRTkxEUUFnSGlBRWF5SUNJQUpCSDNVaUFtb2dBbk5CQTBzTkFDQUJLQUo4SUFFb0FuUkhJUk1MSUFNZ0V6WUNjQ0FCTGdHcUFTRU9Ba0FnRUNBQkx3RXVJaGh5RFFCQkFTRWJJQUV1QWFnQklBRXVBWkFCYXlJQ0lBSkJIM1VpQW1vZ0FuTkJBMHNOQUNBT0lBWnJJZ0lnQWtFZmRTSUNhaUFDYzBFRFN3MEFJQUVvQW53Z0FTZ0NkRWNoR3dzZ0F5QWJOZ0o0SUFFdUFiWUJJUmxCQWlFU1FRSWhGUUpBSUJjZ0FTOEJOQ0lnY2cwQVFRRWhGU0FCTGdHMEFTQUJMZ0djQVdzaUFpQUNRUjkxSWdKcUlBSnpRUU5MRFFBZ0dTQUhheUlDSUFKQkgzVWlBbW9nQW5OQkEwc05BQ0FCS0FLQUFTQUJLQUo0UnlFVkN5QURJQlUyQW9BQklBRXVBYm9CSVNFQ1FDQXpJQUV2QVRZaU5YSU5BRUVCSVJJZ0FTNEJ1QUVnQVM0Qm9BRnJJZ0lnQWtFZmRTSUNhaUFDYzBFRFN3MEFJQ0VnQzJzaUFpQUNRUjkxSWdKcUlBSnpRUU5MRFFBZ0FTZ0NnQUVnQVNnQ2VFY2hFZ3NnQXlBU05nS0lBU0FCTGdHdUFTRTJRUUloRFNBREFuOUJBaUEwSUFFdkFUQWlRWElOQUJwQkFTQUJMZ0dzQVNBQkxnR2tBV3NpQWlBQ1FSOTFJZ0pxSUFKelFRTkxEUUFhSURZZ0htc2lBaUFDUVI5MUlnSnFJQUp6UVFOTEN5SWROZ0tRQVNBQkxnR3lBU0VrQWtBZ0dDQUJMd0V5SWpkeURRQkJBU0VOSUFFdUFiQUJJQUV1QWFnQmF5SUNJQUpCSDNVaUFtb2dBbk5CQTBzTkFDQWtJQTVySWdJZ0FrRWZkU0lDYWlBQ2MwRURTeUVOQ3lBRElBMDJBcGdCSUFFdUFiNEJJU2xCQWlFY0lBTUNmMEVDSUNBZ0FTOEJPQ0k0Y2cwQUdrRUJJQUV1QWJ3QklBRXVBYlFCYXlJQ0lBSkJIM1VpQW1vZ0FuTkJBMHNOQUJvZ0tTQVpheUlDSUFKQkgzVWlBbW9nQW5OQkEwc0xJaVkyQXFBQklBRXVBY0lCSVRrQ1FDQTFJQUV2QVRvaVFuSU5BRUVCSVJ3Z0FTNEJ3QUVnQVM0QnVBRnJJZ0lnQWtFZmRTSUNhaUFDYzBFRFN3MEFJRGtnSVdzaUFpQUNRUjkxSWdKcUlBSnpRUU5MSVJ3TElBTWdIRFlDcUFGQkFpRUNJQU1DZjBFQ0lCRWdNSElOQUJwQkFTQUJMZ0dJQVNBQkxnR0VBV3NpRVNBUlFSOTFJaEZxSUJGelFRTkxEUUFhSUFnZ0ZHc2lGQ0FVUVI5MUloUnFJQlJ6UVFOTEN5SVJOZ0k4QWtBZ01DQXhjZzBBUVFFaEFpQUJMZ0dVQVNBQkxnR0lBV3NpRkNBVVFSOTFJaFJxSUJSelFRTkxEUUFnRENBSWF5SUlJQWhCSDNVaUNHb2dDSE5CQTBzTkFDQUJLQUo0SUFFb0FuUkhJUUlMSUFNZ0FqWUNSRUVDSVJRZ0F3Si9RUUlnTVNCQWNnMEFHa0VCSUFFdUFaZ0JJQUV1QVpRQmF5SUlJQWhCSDNVaUNHb2dDSE5CQTBzTkFCb2dNaUFNYXlJSUlBaEJIM1VpQ0dvZ0NITkJBMHNMSWd3MkFrd0NRQ0FRSUM5eURRQkJBU0VVSUFFdUFaQUJJQUV1QVl3QmF5SUlJQWhCSDNVaUNHb2dDSE5CQTBzTkFDQUdJQVJySWdRZ0JFRWZkU0lFYWlBRWMwRURTeUVVQ3lBRElCUTJBbHhCQWlFSVFRSWhCQUpBSUJBZ0YzSU5BRUVCSVFRZ0FTNEJuQUVnQVM0QmtBRnJJaEFnRUVFZmRTSVFhaUFRYzBFRFN3MEFJQWNnQm1zaUJpQUdRUjkxSWdacUlBWnpRUU5MRFFBZ0FTZ0NlQ0FCS0FKMFJ5RUVDeUFESUFRMkFtUUNRQ0FYSUROeURRQkJBU0VJSUFFdUFhQUJJQUV1QVp3QmF5SUdJQVpCSDNVaUJtb2dCbk5CQTBzTkFDQUxJQWRySWdZZ0JrRWZkU0lHYWlBR2MwRURTeUVJQ3lBRElBZzJBbXhCQWlFR0lBTUNmMEVDSUJnZ05ISU5BQnBCQVNBQkxnR29BU0FCTGdHa0FXc2lCeUFIUVI5MUlnZHFJQWR6UVFOTERRQWFJQTRnSG1zaUJ5QUhRUjkxSWdkcUlBZHpRUU5MQ3lJWE5nSjhBa0FnR0NBZ2NnMEFRUUVoQmlBQkxnRzBBU0FCTGdHb0FXc2lCeUFIUVI5MUlnZHFJQWR6UVFOTERRQWdHU0FPYXlJSElBZEJIM1VpQjJvZ0IzTkJBMHNOQUNBQktBS0FBU0FCS0FKOFJ5RUdDeUFESUFZMkFvUUJRUUloRUNBREFuOUJBaUFnSURWeURRQWFRUUVnQVM0QnVBRWdBUzRCdEFGcklnY2dCMEVmZFNJSGFpQUhjMEVEU3cwQUdpQWhJQmxySWdjZ0IwRWZkU0lIYWlBSGMwRURTd3NpR1RZQ2pBRUNRQ0EzSUVGeURRQkJBU0VRSUFFdUFiQUJJQUV1QWF3QmF5SUhJQWRCSDNVaUIyb2dCM05CQTBzTkFDQWtJRFpySWdjZ0IwRWZkU0lIYWlBSGMwRURTeUVRQ3lBRElCQTJBcHdCUVFJaEIwRUNJUTRDUUNBM0lEaHlEUUJCQVNFT0lBRXVBYndCSUFFdUFiQUJheUlMSUF0QkgzVWlDMm9nQzNOQkEwc05BQ0FwSUNScklnc2dDMEVmZFNJTGFpQUxjMEVEU3cwQUlBRW9Bb0FCSUFFb0FueEhJUTRMSUFNZ0RqWUNwQUVDUUNBNElFSnlEUUJCQVNFSElBRXVBY0FCSUFFdUFid0JheUlMSUF0QkgzVWlDMm9nQzNOQkEwc05BQ0E1SUNscklnY2dCMEVmZFNJSGFpQUhjMEVEU3lFSEN5QURJQWMyQXF3QkRBVUxRUUloRVNBRFFRSTJBandnQVM4QkpDRUlEQUlMUVFJTElndzJBa3hCQWlFRUlBTkJBaUFJUVFCSFFRRjBJQTRiSWdnMkFtd2dBMEVDSUFaQkFFZEJBWFFnQWhzaUZEWUNYQ0FESUFjZ0lYSkJBRWRCQVhRaUJ6WUNyQUVnQXlBUUlDQnlRUUJIUVFGMEloQTJBcHdCSUFNZ0dTQWVja0VBUjBFQmRDSVpOZ0tNQVNBRElBc2dGM0pCQUVkQkFYUWlGellDZkVFQ0lRSUNRQ0FZSUNSeURRQkJBU0VDSUFFdUFaUUJJQUV1QVlnQmF5SVlJQmhCSDNVaUdHb2dHSE5CQTBzTkFDQUJMZ0dXQVNBQkxnR0tBV3NpR0NBWVFSOTFJaGhxSUJoelFRTkxEUUFnQVNnQ2VDQUJLQUowUnlFQ0N5QURJQUkyQWtRQ1FDQUdJQTV5RFFCQkFTRUVJQUV1QVp3QklBRXVBWkFCYXlJR0lBWkJIM1VpQm1vZ0JuTkJBMHNOQUNBQkxnR2VBU0FCTGdHU0FXc2lCaUFHUVI5MUlnWnFJQVp6UVFOTERRQWdBU2dDZUNBQktBSjBSeUVFQ3lBRElBUTJBbVJCQWlFT1FRSWhCZ0pBSUFzZ0huSU5BRUVCSVFZZ0FTNEJ0QUVnQVM0QnFBRnJJZ3NnQzBFZmRTSUxhaUFMYzBFRFN3MEFJQUV1QWJZQklBRXVBYW9CYXlJTElBdEJIM1VpQzJvZ0MzTkJBMHNOQUNBQktBS0FBU0FCS0FKOFJ5RUdDeUFESUFZMkFvUUJBa0FnSUNBaGNnMEFRUUVoRGlBQkxnRzhBU0FCTGdHd0FXc2lDeUFMUVI5MUlndHFJQXR6UVFOTERRQWdBUzRCdmdFZ0FTNEJzZ0ZySWdzZ0MwRWZkU0lMYWlBTGMwRURTdzBBSUFFb0FvQUJJQUVvQW54SElRNExJQU1nRGpZQ3BBRU1BZ3NnQ0NFTVFRSUxJZ0kyQWtRZ0F5QUJMd0VtSUF4Qi8vOERjWEpCQUVkQkFYUWlERFlDVENBREFuOENRQ0FIUlFSQUlBUUVRRUVDSVJRZ0EwRUNOZ0pjSUFZTkFrRUFEQU1MUVFBaEZDQURRUUEyQWx4QkFDQUdSUTBDR2d3QkMwRUNJUlFnQTBFQ05nSmNDMEVDQ3lJRU5nSmtJQU5CQWlBT1FRQkhRUUYwSUFZYklnZzJBbXdnQXdKL0FrQWdJRVVFUUNBWEJFQkJBaUVYSUFOQkFqWUNmQ0FaRFFKQkFBd0RDMEVBSVJjZ0EwRUFOZ0o4UVFBZ0dVVU5BaG9NQVF0QkFpRVhJQU5CQWpZQ2ZBdEJBZ3NpQmpZQ2hBRWdBeUFMSUJoeVFRQkhRUUYwSWdjMkFxd0JJQU1nQ3lBUWNrRUFSMEVCZENJT05nS2tBU0FEUVFJZ0VFRUFSMEVCZENBZUd5SVFOZ0tjQVNBRElCa2dJWEpCQUVkQkFYUWlHVFlDakFFTElBa2dKM0lnQlhJZ0QzSWdDbklnRTNJZ0czSWdGWElnRW5JZ0hYSWdEWElnSm5JZ0hISWdFWElnQW5JZ0RISWdGSElnQkhJZ0NISWdGM0lnQm5JZ0dYSWdFSElnRG5JZ0IzSkZEUUVMSUFFb0Fnd2hDU0FESUFFb0FoQWlCU0FCS0FJVUlnUnFJZ1pCTXlBR1FUTklHeUlHUVFBZ0JrRUFTaHRCMEJkcUxRQUFJZ1kyQWlBZ0F5QUVJQWxxSWdKQk15QUNRVE5JR3lJQ1FRQWdBa0VBU2hzaUNFR1FGMm90QUFBaUFqWUNIQ0FESUFoQkEyeEJrQmhxSWdnMkFoZ0NRQ0F0UlEwQUlBUWdBU2dDekFFb0FoUWlCMGNFUUNBRElBUWdCMnBCQVdwQkFYWWlCeUFGYWlJTlFUTWdEVUV6U0JzaURVRUFJQTFCQUVvYlFkQVhhaTBBQURZQ0NDQURJQWNnQ1dvaUIwRXpJQWRCTTBnYklnZEJBQ0FIUVFCS0d5SUhRWkFYYWkwQUFEWUNCQ0FESUFkQkEyeEJrQmhxTmdJQURBRUxJQU1nQmpZQ0NDQURJQUkyQWdRZ0F5QUlOZ0lBQ3dKQUlDNUZEUUFnQkNBQktBTElBU2dDRkNJSFJ3UkFJQU1nQkNBSGFrRUJha0VCZGlJRUlBVnFJZ1ZCTXlBRlFUTklHeUlGUVFBZ0JVRUFTaHRCMEJkcUxRQUFOZ0lVSUFNZ0JDQUphaUlFUVRNZ0JFRXpTQnNpQkVFQUlBUkJBRW9iSWdSQmtCZHFMUUFBTmdJUUlBTWdCRUVEYkVHUUdHbzJBZ3dNQVFzZ0F5QUdOZ0lVSUFNZ0FqWUNFQ0FESUFnMkFnd0xJQUFvQWdBZ0h5QTZiQ0lVUVFoMGFpQXFRUVIwYWlFSlFRQWhBa0VESVFRZ0EwRXdhaUVHQTBBZ0JpZ0NCQ0lGQkVBZ0NTQUZJQ01nR2hBWkN5QUdLQUlNSWdVRVFDQUpRUVJxSUFVZ0lpQWFFQmtMSUFZb0FoUWlCUVJBSUFsQkNHb2dCU0FpSUJvUUdRc2dCaWdDSENJRkJFQWdDVUVNYWlBRklDSWdHaEFaQ3lBRUlRZ0NRQUpBQWtBZ0JpZ0NBQ0lFSUFZb0FnZ2lEMGNOQUNBRUlBWW9BaEJIRFFBZ0JDQUdLQUlZUncwQUlBUkZEUUlnQXlBQ1FReHNhaUlGS0FJSUlRd2dCU2dDQkNFYklBUkJCRWtOQVNBYlFRSjJRUUpxSVJCQkVDRVBJQWtoQkFOQUFrQWdCQ0FvYWlJQ0xRQUFJZ29nQkMwQUFDSU9heUlGSUFWQkgzVWlCV29nQlhNaUJ5QWJUdzBBSUFRZ0xHb2lFUzBBQUNJRklBcHJJZzBnRFVFZmRTSU5haUFOY3lBTVR3MEFJQVFnR21vaUhDMEFBQ0lTSUE1cklnMGdEVUVmZFNJTmFpQU5jeUFNVHcwQUFrQWdCeUFRU1FSQUlBUWdKV29pRnkwQUFDRVZBbjhnQkNBcmFpSU5MUUFBSWhNZ0Ntc2lCeUFIUVI5MUlnZHFJQWR6SUF4SkJFQkJBeUVkSUFJZ0VpQUtJQTVxSUFWcUlnSkJBWFJxSUJOcVFRUnFRUU4yT2dBQUlCRWdBaUFUYWtFQ2FrRUNkam9BQUNBQ1FRUnFJUkVnQkNBL2FpMEFBQ0VISUJOQkEyd01BUXNnQ2lBU2FpRVJJQVVoQjBFQ0lSMGdBaUVOUVFJTElRSWdEU0FDSUJGcUlBZEJBWFJxSUIxMk9nQUFJQlVnRG1zaUFpQUNRUjkxSWdKcUlBSnpJQXhQRFFFZ0JDQUZJQW9nRW1vZ0Rtb2lBa0VCZEdvZ0ZXcEJCR3BCQTNZNkFBQWdIQ0FDSUJWcVFRSnFRUUoyT2dBQUlCY2dBaUFWUVFOc2FpQUVJRDVxTFFBQVFRRjBha0VFYWtFRGRqb0FBQXdDQ3lBQ0lBb2dFbW9nQlVFQmRHcEJBbXBCQW5ZNkFBQUxJQVFnQlNBT2FpQVNRUUYwYWtFQ2FrRUNkam9BQUFzZ0JFRUJhaUVFSUE5QmYyb2lEdzBBQ3d3Q0N3Si9JQVFFUUNBSklBUWdBeUFDUVF4c2FpQWFFQmdnQmlnQ0NDRVBDeUFQQ3dSQUlBbEJCR29nRHlBRElBSkJER3hxSUJvUUdBc2dCaWdDRUNJRUJFQWdDVUVJYWlBRUlBTWdBa0VNYkdvZ0doQVlDeUFHS0FJWUlnUkZEUUVnQ1VFTWFpQUVJQU1nQWtFTWJHb2dHaEFZREFFTElBUWdCU2dDQUdwQmYyb3RBQUFpQWtFQmFpRUhRUUFnQW1zaERrRVFJUThnQ1NFRUEwQUNRQ0FFSUNocUloTXRBQUFpRFNBRUxRQUFJZ3BySWdVZ0JVRWZkU0lGYWlBRmN5QWJUdzBBSUFRZ0xHb2lFUzBBQUNJU0lBMXJJZ1VnQlVFZmRTSUZhaUFGY3lBTVR3MEFJQVFnR21vaUVDMEFBQ0lWSUFwcklnVWdCVUVmZFNJRmFpQUZjeUFNVHcwQUlBSWhCU0FFSUN0cUxRQUFJaHdnRFdzaUhTQWRRUjkxSWgxcUlCMXpJQXhKQkVBZ0VTQVNJQTRnQWlBS0lBMXFRUUZxUVFGMklCSkJBWFJySUJ4cVFRRjFJZ1VnQlNBQ1Noc2dCU0FPU0J0cU9nQUFJQWNoQlFzZ0V5QU5BbjhnQkNBbGFpMEFBQ0lUSUFwckloRWdFVUVmZFNJUmFpQVJjeUFNU1FSQUlCQWdGU0FPSUFJZ0NpQU5ha0VCYWtFQmRpQVZRUUYwYXlBVGFrRUJkU0lUSUJNZ0Frb2JJQk1nRGtnYmFqb0FBQ0FGUVFGcUlRVUxRUUFnQldzaUV3c2dCU0FTSUJWcklBb2dEV3RCQW5ScVFRUnFRUU4xSWhJZ0VpQUZTaHNnRWlBVFNCc2lCV3BCc0M1cUxRQUFPZ0FBSUFRZ0NpQUZhMEd3TG1vdEFBQTZBQUFMSUFSQkFXb2hCQ0FQUVg5cUlnOE5BQXNMSUFoQmYyb2hCQ0FHUVNCcUlRWWdDU0E5YWlFSlFRSWhBaUFJRFFBTElBRW9BZ3doQkNBRElBRW9BaEFpQlNBQktBSVVJZ1lnQVNnQ0dDSUNhaUlKUVRNZ0NVRXpTQnNpQ1VFQUlBbEJBRW9iUVFKMFFlQTlhaWdDQUNJSmFpSUlRVE1nQ0VFelNCc2lDRUVBSUFoQkFFb2JRZEFYYWkwQUFDSUlOZ0lnSUFNZ0JDQUphaUlIUVRNZ0IwRXpTQnNpQjBFQUlBZEJBRW9iSWcxQmtCZHFMUUFBSWdjMkFod2dBeUFOUVFOc1FaQVlhaUlOTmdJWUFrQWdMVVVOQUNBR0lBRW9Bc3dCS0FJVUlneEhCRUFnQXlBSklBSWdER29pREVFeklBeEJNMGdiSWd4QkFDQU1RUUJLRzBFQ2RFSGdQV29vQWdCcVFRRnFRUUYySWd3Z0JXb2lEMEV6SUE5Qk0wZ2JJZzlCQUNBUFFRQktHMEhRRjJvdEFBQTJBZ2dnQXlBRUlBeHFJZ3hCTXlBTVFUTklHeUlNUVFBZ0RFRUFTaHNpREVHUUYyb3RBQUEyQWdRZ0F5QU1RUU5zUVpBWWFqWUNBQXdCQ3lBRElBZzJBZ2dnQXlBSE5nSUVJQU1nRFRZQ0FBc0NRQ0F1UlEwQUlBWWdBU2dDeUFFb0FoUWlERWNFUUNBRElBVWdDU0FDSUF4cUlnWkJNeUFHUVROSUd5SUdRUUFnQmtFQVNodEJBblJCNEQxcUtBSUFha0VCYWtFQmRpSUphaUlGUVRNZ0JVRXpTQnNpQlVFQUlBVkJBRW9iUWRBWGFpMEFBRFlDRkNBRElBUWdDV29pQkVFeklBUkJNMGdiSWdSQkFDQUVRUUJLR3lJRVFaQVhhaTBBQURZQ0VDQURJQVJCQTJ4QmtCaHFOZ0lNREFFTElBTWdDRFlDRkNBRElBYzJBaEFnQXlBTk5nSU1DeUFBS0FJQUlEeHFJQlJCQm5ScUlDcEJBM1JxSWdrZ08yb2hCRUVBSVFvZ0EwRXdhaUVHUVFBaEFnTkFJQVlvQWdRaUJRUkFJQWtnQlNBaklCWVFFQ0FFSUFZb0FnUWdJeUFXRUJBTElBWW9BaVFpQlFSQUlBa2dHbW9nQlNBaklCWVFFQ0FFSUJwcUlBWW9BaVFnSXlBV0VCQUxJQVlvQWhRaUJRUkFJQWxCQkdvZ0JTQWlJQllRRUNBRVFRUnFJQVlvQWhRZ0lpQVdFQkFMSUFZb0FqUWlCUVJBSUFrZ0dtcEJCR29nQlNBaUlCWVFFQ0FFSUJwcVFRUnFJQVlvQWpRZ0lpQVdFQkFMSUFJaEJRSkFBa0FnQmlnQ0FDSUNJQVlvQWdnaUQwY05BQ0FDSUFZb0FoQkhEUUFnQWlBR0tBSVlSdzBBSUFKRkRRRWdDU0FDSUFNZ0NrRU1iR29pQWlBV0VDc2dCQ0FHS0FJQUlBSWdGaEFyREFFTEFuOGdBZ1JBSUFrZ0FpQURJQXBCREd4cUlnSWdGaEFTSUFRZ0JpZ0NBQ0FDSUJZUUVpQUdLQUlJSVE4TElBOExCRUFnQ1VFQ2FpQVBJQU1nQ2tFTWJHb2lBaUFXRUJJZ0JFRUNhaUFHS0FJSUlBSWdGaEFTQ3lBR0tBSVFJZ0lFUUNBSlFRUnFJQUlnQXlBS1FReHNhaUlDSUJZUUVpQUVRUVJxSUFZb0FoQWdBaUFXRUJJTElBWW9BaGdpQWtVTkFDQUpRUVpxSUFJZ0F5QUtRUXhzYWlJQ0lCWVFFaUFFUVFacUlBWW9BaGdnQWlBV0VCSUxJQVFnSldvaEJDQUpJQ1ZxSVFrZ0JrRkFheUVHUVFFaEFrRUNJUW9nQlVVTkFBc0xRUUFnS2tFQmFpSUVJQVFnSDBZaUJCc2hLaUFCUWRnQmFpRUJJQVFnT21vaU9pQUFLQUlJU1EwQUN3c2dBMEd3QVdva0FBdUNCUUVLZnlNQVFaQUJheUlMSkFBQ1FBSkFJQUpCQUVnTkFDQURRUUJJRFFBZ0FpQUhhaUFFU3cwQUlBTWdDR3BCQVdvZ0JVc05BQ0FGSVF3Z0F5RU9EQUVMSUFBZ0N5QUNJQU1nQkNBRklBY2dDRUVCYWlJTUlBY1FEQ0FBSUFRZ0JXeHFJQXNnQnlBTWJHb2dBaUFESUFRZ0JTQUhJQXdnQnhBTUlBc2hBQ0FISVFSQkFDRUNDd0pBSUFoQkFYWWlCVVVOQUNBSFFRRjJJZ05GRFFCQkVDQUhheUVRUVFnZ0Jtc2hDU0FFUVFGMElnMGdCMnNoRVNBQUlBSnFJaElnQkNBT2JHb2hCeUFCSVFJZ0JTRUlBMEFnQXlFQUEwQWdCeUFOYWkwQUFDRUtJQUlnQ1NBSExRQUFiQ0FFSUFkcUxRQUFJZzhnQm14cVFRTjBRU0JxUVFaMk9nQUFJQUlnQ1NBUGJDQUdJQXBzYWtFRGRFRWdha0VHZGpvQUNDQUhRUUZxSWdvZ0RXb3RBQUFoRHlBQ0lBa2dCeTBBQVd3Z0JDQUthaTBBQUNJS0lBWnNha0VEZEVFZ2FrRUdkam9BQVNBQ0lBa2dDbXdnQmlBUGJHcEJBM1JCSUdwQkJuWTZBQWtnQWtFQ2FpRUNJQWRCQW1vaEJ5QUFRWDlxSWdBTkFBc2dCeUFSYWlFSElBSWdFR29oQWlBSVFYOXFJZ2dOQUFzZ0FVRkFheUVDSUJJZ0RDQU9haUFFYkdvaEJ3TkFJQU1oQUFOQUlBY2dEV290QUFBaEFTQUNJQWtnQnkwQUFHd2dCQ0FIYWkwQUFDSUlJQVpzYWtFRGRFRWdha0VHZGpvQUFDQUNJQWdnQ1d3Z0FTQUdiR3BCQTNSQklHcEJCblk2QUFnZ0IwRUJhaUlCSUExcUxRQUFJUWdnQWlBSklBY3RBQUZzSUFFZ0JHb3RBQUFpQVNBR2JHcEJBM1JCSUdwQkJuWTZBQUVnQWlBQklBbHNJQVlnQ0d4cVFRTjBRU0JxUVFaMk9nQUpJQUpCQW1vaEFpQUhRUUpxSVFjZ0FFRi9haUlBRFFBTElBY2dFV29oQnlBQ0lCQnFJUUlnQlVGL2FpSUZEUUFMQ3lBTFFaQUJhaVFBQy8wRUFRdC9Jd0JCa0FGcklnd2tBQ0FIUVFGcUlRa0NRQUpBSUFKQkFFZ05BQ0FESUFocUlBVkxEUUFnQTBFQVNBMEFJQUlnQ1dvZ0JFc05BQ0FFSVFrZ0F5RUxEQUVMSUFBZ0RDQUNJQU1nQkNBRklBa2dDQ0FKRUF3Z0FDQUVJQVZzYWlBTUlBZ2dDV3hxSUFJZ0F5QUVJQVVnQ1NBSUlBa1FEQ0FNSVFBZ0NDRUZRUUFoQWdzQ1FDQUlRUUYySWdoRkRRQWdCMEVCZGlJRVJRMEFRUkFnQjJzaERrRUlJQVpySVFvZ0NVRUJkQ0FIYXlFUElBQWdBbW9pRVNBSklBdHNhaUVDSUFFaEF5QUlJUUFEUUNBRUlRY0RRQ0FDUVFGcUlBbHFMUUFBSVJBZ0FpQUphaTBBQUNFTklBTWdBaTBBQVNJU0lBWnNJQW9nQWkwQUFHeHFRUU4wUVNCcVFRWjJPZ0FBSUFNZ0JpQVFiQ0FLSUExc2FrRURkRUVnYWtFR2Rqb0FDQ0FDTFFBQ0lRMGdBa0VDYWlJQ0lBbHFMUUFBSVJNZ0F5QUdJQTFzSUFvZ0VteHFRUU4wUVNCcVFRWjJPZ0FCSUFNZ0JpQVRiQ0FLSUJCc2FrRURkRUVnYWtFR2Rqb0FDU0FEUVFKcUlRTWdCMEYvYWlJSERRQUxJQUlnRDJvaEFpQURJQTVxSVFNZ0FFRi9haUlBRFFBTElBRkJRR3NoQXlBUklBVWdDMm9nQ1d4cUlRSURRQ0FFSVFjRFFDQUNRUUZxSUFscUxRQUFJUUFnQWlBSmFpMEFBQ0VCSUFNZ0FpMEFBU0lGSUFac0lBb2dBaTBBQUd4cVFRTjBRU0JxUVFaMk9nQUFJQU1nQUNBR2JDQUJJQXBzYWtFRGRFRWdha0VHZGpvQUNDQUNMUUFDSVFFZ0FrRUNhaUlDSUFscUxRQUFJUXNnQXlBQklBWnNJQVVnQ214cVFRTjBRU0JxUVFaMk9nQUJJQU1nQmlBTGJDQUFJQXBzYWtFRGRFRWdha0VHZGpvQUNTQURRUUpxSVFNZ0IwRi9haUlIRFFBTElBSWdEMm9oQWlBRElBNXFJUU1nQ0VGL2FpSUlEUUFMQ3lBTVFaQUJhaVFBQzdrSEFRVi9Jd0JCRUdzaUJDUUFBa0FnQUNBQlFRQkJ5QUFRQnlJREVBSWlBUTBBUVFFaEFTQURLQUlBUWY4QlN3MEFJQUFnQTBFRWFoQUNJZ0VOQUVFQklRRWdBeWdDQkVFZlN3MEFJQUJCQVJBRERRQWdBRUVCRUFNaUFrRi9SZzBBSUFNZ0FrRUJSallDQ0NBQUlBUkJER29RQWlJQkRRQWdBeUFFS0FJTVFRRnFJZ0UyQWd3Z0FVRUlTd1JBUVFFaEFRd0JDd0pBSUFGQkFra05BQ0FBSUFOQkVHb1FBaUlCRFFFZ0F5Z0NFQ0lCUVFaTElnSUVRRUVCSVFFTUFnc2dBZzBBQWtBQ1FBSkFBa0FnQVVFQmF3NEdCQUVDQWdJREFBc2dBeUFES0FJTUlnRkJBblFRQ2lJQ05nSVVJQUpGQkVCQi8vOERJUUVNQlFzZ0FVVU5BMEVBSVFJRFFDQUFJQVJCREdvUUFpSUJEUVVnQXlnQ0ZDQUNRUUowYWlBRUtBSU1RUUZxTmdJQUlBSkJBV29pQWlBREtBSU1TUTBBQ3d3REN5QURJQU1vQWd3aUFrRUNkRUY4YWlJQkVBb2lCVFlDR0NBRElBRVFDaUlHTmdJY1FmLy9BeUVCSUFWRkRRTWdCa1VOQXlBQ1FRRkdEUUpCQUNFQ0EwQWdBQ0FFUVF4cUVBSWlBUTBFSUFKQkFuUWlCU0FES0FJWWFpQUVLQUlNTmdJQUlBQWdCRUVNYWhBQ0lnRU5CQ0FES0FJY0lBVnFJQVFvQWd3MkFnQWdBa0VCYWlJQ0lBTW9BZ3hCZjJwSkRRQUxEQUlMUVFFaEFTQUFRUUVRQXlJQ1FYOUdEUUlnQXlBQ1FRRkdOZ0lnSUFBZ0JFRU1haEFDSWdFTkFpQURJQVFvQWd4QkFXbzJBaVFNQVFzZ0FDQUVRUXhxRUFJaUFRMEJJQU1nQkNnQ0RFRUJhaUlCTmdJb0lBTWdBVUVDZEJBS0lnSTJBaXdnQWtVRVFFSC8vd01oQVF3Q0N5QUJSUTBBSUFNb0FneEJBblJCckR0cUtBSUFJUVpCQUNFQ0EwQWdBQ0FHRUFNaEJTQURLQUlzSUFKQkFuUnFJQVUyQWdCQkFTRUJJQVVnQXlnQ0RFOE5BaUFDUVFGcUlnSWdBeWdDS0VrTkFBc0xJQUFnQkVFTWFoQUNJZ0VOQUVFQklRRWdCQ2dDRENJQ1FSOUxEUUFnQXlBQ1FRRnFOZ0l3SUFBZ0JFRU1haEFDSWdFTkFFRUJJUUVnQkNnQ0RFRWZTdzBBSUFCQkFSQURCRUFNQVFzZ0FFRUNFQU5CQWtzRVFBd0JDeUFBSUFSQkNHb1FCU0lCRFFBZ0JDZ0NDRUVhYWlJQlFUTkxCRUJCQVNFQkRBRUxJQU1nQVRZQ05DQUFJQVJCQ0dvUUJTSUJEUUFnQkNnQ0NFRWFha0V6U3dSQVFRRWhBUXdCQ3lBQUlBUkJDR29RQlNJQkRRQkJBU0VCSUFRb0FnZ2lBa0VNYWtFWVN3MEFJQU1nQWpZQ09DQUFRUUVRQXlJQ1FYOUdEUUFnQXlBQ1FRRkdOZ0k4SUFCQkFSQURJZ0pCZjBZTkFDQURJQUpCQVVZMkFrQWdBRUVCRUFNaUFrRi9SZzBBSUFNZ0FrRUJSallDUkNBQUVCOUJBQ0VCQ3lBRVFSQnFKQUFnQVF2cUJRRUpmd0pBSUFJb0Fwd0NSUVJBREFFTFFRRWhCZ05BQWtBQ1FDQUNJQVZCRkd4cUtBS2dBaUlFUVFWTERRQWdCRUVCYXc0RkFBQUFBQU1CQ3lBRlFRRnFJUVVNQVFzTElBUWhCZ3NDZndKQUlBRW9BaEFpQkVFQlRRUkFJQVJCQVdzRVFDQURLQUlBUVFWR0JFQWdBRUlBTndJQUlBSW9BaFFoQlVFQUlRUU1Bd3NnQUNnQ0FDSUVJQUlvQWhRaUJVME5BaUFFSUFWcklBRW9BaFFpQjBFQmRra05BaUFBS0FJRUlBZHFEQU1MUVFBaEJRSi9RUUFnQXlnQ0FFRUZSZzBBR2lBQUtBSU1JZ2NnQUNnQ0NDQUNLQUlNVFEwQUdpQUJLQUlNSUFkcUN5RUhRUUFoQkFKL0lBRW9BaVFpQ0FSQUlBSW9BZ3dnQjJvaEJRc2dCU0FES0FJRUlncEZJQVZCQUVkeGF5SUpDd1JBSUFsQmYyb2lBeUFESUFodUlnc2dDR3hySVFNTElBZ0VRQ0FCS0FJb0lReEJBQ0VGQTBBZ0RDQUZRUUowYWlnQ0FDQUVhaUVFSUFWQkFXb2lCU0FJUncwQUN3c0NRQ0FKUlFSQVFRQWhCQXdCQ3lBRUlBdHNJUVFnQVNnQ0tDRUlRUUFoQlFOQUlBZ2dCVUVDZEdvb0FnQWdCR29oQkNBRlFRRnFJZ1VnQTAwTkFBc0xJQXBGQkVBZ0FTZ0NIQ0FFYWlFRUN5QUdSUVJBSUFJb0FpQWhBeUFCS0FJZ0lRRWdBaWdDSENFR0lBQWdCellDRENBQUlBSW9BZ3cyQWdnZ0JpQUJJQU5xSWdCQkgzVWdBSEVnQkdwcUR3c2dBRUlBTndJSVFRQVBDMEVBSVFWQkFDRUVJQU1vQWdCQkJVY0VRQ0FBS0FJTUlRVWdBQ2dDQ0NBQ0tBSU1JZ1JMQkVBZ0FTZ0NEQ0FGYWlFRkN5QUVJQVZxUVFGMElBTW9BZ1JGYXlFRUN5QUdSUVJBSUFBZ0JUWUNEQ0FBSUFJb0FndzJBZ2dnQkE4TElBQkNBRGNDQ0VFQUR3c0NRQ0FGSUFSTkRRQWdCU0FFYXlBQktBSVVJZ0ZCQVhaTkRRQWdBQ2dDQkNBQmF3d0JDeUFBS0FJRUN5RUVJQU1vQWdSRkJFQWdCQ0FGYWlBQ0tBSVlJZ0JCSDNVZ0FIRnFEd3NnQUNBRU5nSUVJQUlvQWhnaEFTQUdCRUFnQUVFQU5nSUVJQUJCQUNBQmF5QUJRUjkxY1RZQ0FFRUFEd3NnQUNBRk5nSUFJQVFnQldvZ0FVRWZkU0FCY1dvTHZBRUJDSDhnQWdSQUlBRkJmMm9oQjBFQUlBRnJRZGdCYkNFSVFRRWdBV3RCMkFGc0lRa2dBVUYvYzBIWUFXd2hDZ05BSUFBZ0JrSFlBV3hxSWdNZ0EwR29mbXBCQUNBRUd6WUN5QUVnQXdKL0lBVkZCRUFnQTBFQU5nTE1BVUVBREFFTElBTWdBeUFJYWpZQ3pBRWdBeUFKYWtFQUlBUWdCMGtiQ3pZQzBBRWdBeUFESUFwcVFRQWdCQnRCQUNBRkd6WUMxQUZCQUNBRVFRRnFJZ01nQVNBRFJpSURHeUVFSUFNZ0JXb2hCU0FHUVFGcUlnWWdBa2NOQUFzTEMzY0JBbjlCQVNFQ0FrQWdBRUVCRUFOQmYwWU5BQ0FCSUFCQkFoQUROZ0lFSUFFZ0FFRUZFQU1pQURZQ0FDQUFRWDVxUVFOSkRRQUNRQ0FBUVF4TERRQkJBU0FBZENJRFFjQThjVVVFUUNBRFFhQURjVVVOQVNBQVFRWkdEUUlnQVNnQ0JBMEJEQUlMSUFFb0FnUU5BUXRCQUNFQ0N5QUNDNUlUQVFaL0lBQWdBU2dDQUNJTk5nSUFJQUFnQUNnQ3hBRkJBV28yQXNRQklBSWdCUkFkQWtBQ1FBSkFBa0FDUUNBTlFSOUdCRUFnQUVFQU5nSVVJQUFvQXNRQlFRRkxEUUVnQUVFY2FpRUpJQUZCeUFKcUlRUkJGeUVCSUFjaEFBTkFJQWxCRURzQkFDQUFJQVFvQWdBNkFBQWdBQ0FFS0FJRU9nQUJJQUFnQkNnQ0NEb0FBaUFBSUFRb0FndzZBQU1nQUNBRUtBSVFPZ0FFSUFBZ0JDZ0NGRG9BQlNBQUlBUW9BaGc2QUFZZ0FDQUVLQUljT2dBSElBQWdCQ2dDSURvQUNDQUFJQVFvQWlRNkFBa2dBQ0FFS0FJb09nQUtJQUFnQkNnQ0xEb0FDeUFBSUFRb0FqQTZBQXdnQUNBRUtBSTBPZ0FOSUFBZ0JDZ0NPRG9BRGlBQUlBUW9Banc2QUE4Z0FTSURRWDlxSVFFZ0NVRUNhaUVKSUFCQkVHb2hBQ0FFUVVCcklRUWdBdzBBQ3lBQ0lBY1FHd3dFQ3lBQVFSeHFJUWtnRFFSQUlBa2dBU2tDa0FJM0FnQWdDU0FCS1FHK0FqY0JMaUFKSUFFcEFyZ0NOd0lvSUFrZ0FTa0NzQUkzQWlBZ0NTQUJLUUtvQWpjQ0dDQUpJQUVwQXFBQ053SVFJQWtnQVNrQ21BSTNBZ2dnQkNnQ0FDRUtBa0FnQVNnQ0NDSUxSUTBBSUFRZ0NpQUxhaUlLTmdJQUlBUWdDa0YvVEFSL0lBcEJOR29GSUFwQk5FZ05BU0FLUVV4cUN5SUtOZ0lBQ3lBQUlBbzJBaFFnQVVISUQyb2hEQ0FCUWNnQ2FpRUVBa0FDUUNBQUtBSUFRUVpOQkVBZ0NTOEJBRVVOQVVFQklRZ2dCQ0FLUVFBZ0RDZ0NBQkFHUlEwQ0RBZ0xJQUF2QVV3RVFDQUJRY2dPYWlBS0VERUxRYkEwSVFwQkR5RUlBMEFnQ0NFTElBUWdBU0FLS0FJQVFRSjBha0hJRG1vb0FnQWlDRFlDQUFKQUFrQWdDRVVFUUNBSkx3RUFSUTBCQzBFQklRZ2dCQ0FBS0FJVVFRRWdEQ2dDQUJBR1JRMEJEQW9MSUFSQi8vLy9CellDQUFzZ0NrRUVhaUVLSUF0QmYyb2hDQ0FNUVFScUlRd2dDVUVDYWlFSklBUkJRR3NoQkNBTERRQUxEQVFMSUFSQi8vLy9CellDQUFzZ0FVR0lBMm9oQkFKQUlBQXZBUjRFUUVFQklRZ2dCQ0FBS0FJVVFRQWdBVUhNRDJvb0FnQVFCa1VOQVF3SEN5QUVRZi8vL3djMkFnQUxJQUZCeUFOcUlRUUNRQ0FBTHdFZ0JFQkJBU0VJSUFRZ0FDZ0NGRUVBSUFGQjBBOXFLQUlBRUFaRkRRRU1Cd3NnQkVILy8vOEhOZ0lBQ3lBQlFZZ0VhaUVFQWtBZ0FDOEJJZ1JBUVFFaENDQUVJQUFvQWhSQkFDQUJRZFFQYWlnQ0FCQUdSUTBCREFjTElBUkIvLy8vQnpZQ0FBc2dBVUhJQkdvaEJBSkFJQUF2QVNRRVFFRUJJUWdnQkNBQUtBSVVRUUFnQVVIWUQyb29BZ0FRQmtVTkFRd0hDeUFFUWYvLy93YzJBZ0FMSUFGQmlBVnFJUVFDUUNBQUx3RW1CRUJCQVNFSUlBUWdBQ2dDRkVFQUlBRkIzQTlxS0FJQUVBWkZEUUVNQndzZ0JFSC8vLzhITmdJQUN5QUJRY2dGYWlFRUFrQWdBQzhCS0FSQVFRRWhDQ0FFSUFBb0FoUkJBQ0FCUWVBUGFpZ0NBQkFHUlEwQkRBY0xJQVJCLy8vL0J6WUNBQXNnQVVHSUJtb2hCQUpBSUFBdkFTb0VRRUVCSVFnZ0JDQUFLQUlVUVFBZ0FVSGtEMm9vQWdBUUJrVU5BUXdIQ3lBRVFmLy8vd2MyQWdBTElBRkJ5QVpxSVFRQ1FDQUFMd0VzQkVCQkFTRUlJQVFnQUNnQ0ZFRUFJQUZCNkE5cUtBSUFFQVpGRFFFTUJ3c2dCRUgvLy84SE5nSUFDeUFCUVlnSGFpRUVBa0FnQUM4QkxnUkFRUUVoQ0NBRUlBQW9BaFJCQUNBQlFld1BhaWdDQUJBR1JRMEJEQWNMSUFSQi8vLy9CellDQUFzZ0FVSElCMm9oQkFKQUlBQXZBVEFFUUVFQklRZ2dCQ0FBS0FJVVFRQWdBVUh3RDJvb0FnQVFCa1VOQVF3SEN5QUVRZi8vL3djMkFnQUxJQUZCaUFocUlRUUNRQ0FBTHdFeUJFQkJBU0VJSUFRZ0FDZ0NGRUVBSUFGQjlBOXFLQUlBRUFaRkRRRU1Cd3NnQkVILy8vOEhOZ0lBQ3lBQlFjZ0lhaUVFQWtBZ0FDOEJOQVJBUVFFaENDQUVJQUFvQWhSQkFDQUJRZmdQYWlnQ0FCQUdSUTBCREFjTElBUkIvLy8vQnpZQ0FBc2dBVUdJQ1dvaEJBSkFJQUF2QVRZRVFFRUJJUWdnQkNBQUtBSVVRUUFnQVVIOEQyb29BZ0FRQmtVTkFRd0hDeUFFUWYvLy93YzJBZ0FMSUFGQnlBbHFJUVFDUUNBQUx3RTRCRUJCQVNFSUlBUWdBQ2dDRkVFQUlBRkJnQkJxS0FJQUVBWkZEUUVNQndzZ0JFSC8vLzhITmdJQUN5QUJRWWdLYWlFRUFrQWdBQzhCT2dSQVFRRWhDQ0FFSUFBb0FoUkJBQ0FCUVlRUWFpZ0NBQkFHUlEwQkRBY0xJQVJCLy8vL0J6WUNBQXNnQVVHSUVHb2hEQ0FCUWNnS2FpRUVEQUlMSUFsQ0FEY0NBQ0FKUWdBM0FTNGdDVUlBTndJb0lBbENBRGNDSUNBSlFnQTNBaGdnQ1VJQU53SVFJQWxDQURjQ0NDQUFJQVFvQWdBMkFoUU1BZ3NnQUVLUWdNQ0FnSUtBQ0RjQkhDQUFRcENBd0lDQWdvQUlOd0ZFSUFCQ2tJREFnSUNDZ0FnM0FUd2dBRUtRZ01DQWdJS0FDRGNCTkNBQVFwQ0F3SUNBZ29BSU53RXNJQUJDa0lEQWdJQ0NnQWczQVNSQkFBOExJQUFvQWhnZ0FDZ0NGR29pQzBFeklBdEJNMGdiSWd0QkFDQUxRUUJLRzBFQ2RFSGdQV29vQWdBaENRSkFJQUF2QVU1RkJFQWdBQzhCVUVVTkFRc2dBVUdJRDJvZ0NSQXdDeUFFSUFGQmlBOXFLQUlBSWdzMkFnQUNRQUpBSUF0RkJFQWdBQzhCUEVVTkFRdEJBU0VJSUFRZ0NVRUJJQXdvQWdBUUJrVU5BUXdFQ3lBRVFmLy8vd2MyQWdBTElBUWdBU2dDakE4aUN6WUNRQ0FFUVVCcklRb0NRQUpBSUF0RkJFQWdBQzhCUGtVTkFRdEJBU0VJSUFvZ0NVRUJJQXdvQWdRUUJrVU5BUXdFQ3lBS1FmLy8vd2MyQWdBTElBUWdBU2dDa0E4aUN6WUNnQUVnQkVHQUFXb2hDZ0pBQWtBZ0MwVUVRQ0FBUVVCckx3RUFSUTBCQzBFQklRZ2dDaUFKUVFFZ0RDZ0NDQkFHUlEwQkRBUUxJQXBCLy8vL0J6WUNBQXNnQkNBQktBS1VEeUlMTmdMQUFTQUVRY0FCYWlFS0FrQUNRQ0FMUlFSQUlBQXZBVUpGRFFFTFFRRWhDQ0FLSUFsQkFTQU1LQUlNRUFaRkRRRU1CQXNnQ2tILy8vOEhOZ0lBQ3lBRUlBRW9BcGdQSWdzMkFvQUNJQVJCZ0FKcUlRb0NRQUpBSUF0RkJFQWdBQzhCUkVVTkFRdEJBU0VJSUFvZ0NVRUJJQXdvQWhBUUJrVU5BUXdFQ3lBS1FmLy8vd2MyQWdBTElBUWdBU2dDbkE4aUN6WUN3QUlnQkVIQUFtb2hDZ0pBQWtBZ0MwVUVRQ0FBTHdGR1JRMEJDMEVCSVFnZ0NpQUpRUUVnRENnQ0ZCQUdSUTBCREFRTElBcEIvLy8vQnpZQ0FBc2dCQ0FCS0FLZ0R5SUxOZ0tBQXlBRVFZQURhaUVLQWtBQ1FDQUxSUVJBSUFBdkFVaEZEUUVMUVFFaENDQUtJQWxCQVNBTUtBSVlFQVpGRFFFTUJBc2dDa0gvLy84SE5nSUFDeUFFSUFFb0FxUVBJZ3MyQXNBRElBUkJ3QU5xSVFRQ1FBSkFJQXRGQkVBZ0FDOEJTa1VOQVF0QkFTRUlJQVFnQ1VFQklBd29BaHdRQmtVTkFRd0VDeUFFUWYvLy93YzJBZ0FMSUExQkJra05BQ0FBSUFFZ0FpQUZJQVlnQnhCV0lnaEZEUUVNQWdzZ0FDQUJJQU1nQlNBQ0lBY1FWeUlJRFFFTFFRQWhDQXNnQ0F1V0hRRUhmeU1BUVJCcklnY2tBQ0FCUVFCQnFCQVFCeUVGSUFBZ0IwRUVhaEFDSVFFZ0J5Z0NCQ0VJQWtBQ1FBSkFJQU5CZm1vaUEwRUZTdzBBQWtBZ0EwRUJhdzRFQVFFQkFRQUxRUUVoQXlBQkRRSWdDRUVHYWlJR1FSOU5EUUVNQWd0QkFTRURJQUVOQVNBSVFRRnFJZ1pCSDBzTkFRc2dCU0FHTmdJQUFrQWdCa0VmUmdSQUEwQWdBQ2dDQ0FSQUlBQkJBUkFEUlEwQkRBUUxDeUFGUWNnQ2FpRUdBMEFnQnlBQVFRZ1FBeUlCTmdJRUlBRkJmMFlOQXlBR0lBRTJBZ0FnQmtFRWFpRUdJQWxCQVdvaUNVR0FBMGNOQUFzTUFRdEJBaUFHUVFaSElBWkJCa2tiSVFvQ1FBSkFJQVpCQkVrTkFDQUdRUVZMRFFBZ0FDQUhRUXhxRUFJTkFTQUhLQUlNSWdGQkEwc05BU0FGSUFFMkFyQUJJQUFnQjBFTWFoQUNEUUVnQnlnQ0RDSUJRUU5MRFFFZ0JTQUJOZ0swQVNBQUlBZEJER29RQWcwQklBY29BZ3dpQVVFRFN3MEJJQVVnQVRZQ3VBRWdBQ0FIUVF4cUVBSU5BU0FIS0FJTUlnRkJBMHNOQVNBRklBRTJBcndCQWtBZ0JFRUNTUTBBSUFaQkJVWU5BQ0FBSUFkQkRHb2dCRUVDU3lJQkVCY05BaUFIS0FJTUlnZ2dCRThOQWlBRklBZzJBc0FCSUFBZ0IwRU1haUFCRUJjTkFpQUhLQUlNSWdnZ0JFOE5BaUFGSUFnMkFzUUJJQUFnQjBFTWFpQUJFQmNOQWlBSEtBSU1JZ2dnQkU4TkFpQUZJQWcyQXNnQklBQWdCMEVNYWlBQkVCY05BaUFIS0FJTUlnRWdCRThOQWlBRklBRTJBc3dCQ3lBSElBVW9BckFCSWdGQkFrMEVmeUFCUVFKMFFmQTBhaWdDQUFWQkF3czJBZ3hCQUNFR0EwQWdBQ0FIUVFocUVBVWlBdzBDSUFVZ0JrRUNkR29pQVNBSEtBSUlPd0hRQVNBQUlBZEJDR29RQlNJRERRSWdBU0FIS0FJSU93SFNBU0FISUFjb0Fnd2lBVUYvYWpZQ0RDQUdRUUZxSVFZZ0FRMEFDeUFISUFVb0FyUUJJZ0ZCQWswRWZ5QUJRUUowUWZBMGFpZ0NBQVZCQXdzMkFneEJBQ0VHQTBBZ0FDQUhRUWhxRUFVaUF3MENJQVVnQmtFQ2RHb2lBU0FIS0FJSU93SGdBU0FBSUFkQkNHb1FCU0lERFFJZ0FTQUhLQUlJT3dIaUFTQUhJQWNvQWd3aUFVRi9hallDRENBR1FRRnFJUVlnQVEwQUN5QUhJQVVvQXJnQklnRkJBazBFZnlBQlFRSjBRZkEwYWlnQ0FBVkJBd3MyQWd4QkFDRUdBMEFnQUNBSFFRaHFFQVVpQXcwQ0lBVWdCa0VDZEdvaUFTQUhLQUlJT3dId0FTQUFJQWRCQ0dvUUJTSUREUUlnQVNBSEtBSUlPd0h5QVNBSElBY29BZ3dpQVVGL2FqWUNEQ0FHUVFGcUlRWWdBUTBBQ3lBSElBVW9BcndCSWdGQkFrMEVmeUFCUVFKMFFmQTBhaWdDQUFWQkF3czJBZ3hCQUNFR0EwQWdBQ0FIUVFocUVBVWlBdzBDSUFVZ0JrRUNkR29pQVNBSEtBSUlPd0dBQWlBQUlBZEJDR29RQlNJRERRSWdBU0FIS0FJSU93R0NBaUFISUFjb0Fnd2lBVUYvYWpZQ0RDQUdRUUZxSVFaQkFDRURJQUVOQUFzTUFRdEJBQ0VESUFwQkFrc05BQUpBQW44Q1FBSkFBa0FnQ2tFQmF3NENCQUVBQ3lBSFFRQTJBZ2dnQlNBQUVBOGlBVUVmZGpZQ0RDQUJRUUJPRFFFZ0FVRUJkQ0VHUVFBTUFnc2dCRUVDVHdSQVFRTWhBU0FHUVFOTkJFQWdCa0VDZEVIOE5Hb29BZ0FoQVFzZ0JFRUNTeUVMUVFFaEF3TkFJQUFnQjBFTWFpQUxFQmNOQlNBSEtBSU1JZ2dnQkU4TkJTQUZJQWxCQW5ScUlBZzJBcEFCSUFFaUNFRi9haUVCSUFsQkFXb2hDU0FJRFFBTEMwRURJUU1nQmtFRFRRUkFJQVpCQW5SQi9EUnFLQUlBSVFNTFFRQWhCZ05BSUFNaEFTQUFJQWRCQ0dvUUJTSUREUVFnQlNBR1FRSjBhaUlFSUFjb0FnZzdBYUFCSUFBZ0IwRUlhaEFGSWdNTkJDQUVJQWNvQWdnN0FhSUJJQUZCZjJvaEF5QUdRUUZxSVFZZ0FRMEFDMEVBSVFNTUF3c2dCU0FCUVJ4Mk5nSk1JQUZCQkhRaEJrRUJDeUVESUFVZ0JrRWZkallDRUNBRklBWkJBRWdFZnlBR1FRRjBCU0FGSUFaQkhIWTJBbEFnQTBFQmFpRURJQVpCQkhRTElnRkJIM1kyQWhRZ0JTQUJRUUJJQkg4Z0FVRUJkQVVnQlNBQlFSeDJOZ0pVSUFOQkFXb2hBeUFCUVFSMEN5SUJRUjkyTmdJWUlBVWdBVUVBU0FSL0lBRkJBWFFGSUFVZ0FVRWNkallDV0NBRFFRRnFJUU1nQVVFRWRBc2lBVUVmZGpZQ0hDQUZJQUZCQUVnRWZ5QUJRUUYwQlNBRklBRkJISFkyQWx3Z0EwRUJhaUVESUFGQkJIUUxJZ0ZCSDNZMkFpQWdCU0FCUVFCSUJIOGdBVUVCZEFVZ0JTQUJRUngyTmdKZ0lBTkJBV29oQXlBQlFRUjBDeUlCUVI5Mk5nSWtJQVVnQVVFQVNBUi9JQUZCQVhRRklBVWdBVUVjZGpZQ1pDQURRUUZxSVFNZ0FVRUVkQXNpQVVFZmRqWUNLQ0FCUVFCSUJIOGdBVUVCZEFVZ0JTQUJRUngyTmdKb0lBTkJBV29oQXlBQlFRUjBDeUVHQWtBZ0FDQURRUU5zUVFocUVBdEJmMFlOQUNBSFFRRTJBZ2dnQlNBQUVBOGlBVUVmZGpZQ0xBSi9JQUZCQUVnRVFDQUJRUUYwSVFaQkFBd0JDeUFGSUFGQkhIWTJBbXdnQVVFRWRDRUdRUUVMSVFNZ0JTQUdRUjkyTmdJd0lBVWdCa0VBU0FSL0lBWkJBWFFGSUFVZ0JrRWNkallDY0NBRFFRRnFJUU1nQmtFRWRBc2lBVUVmZGpZQ05DQUZJQUZCQUVnRWZ5QUJRUUYwQlNBRklBRkJISFkyQW5RZ0EwRUJhaUVESUFGQkJIUUxJZ0ZCSDNZMkFqZ2dCU0FCUVFCSUJIOGdBVUVCZEFVZ0JTQUJRUngyTmdKNElBTkJBV29oQXlBQlFRUjBDeUlCUVI5Mk5nSThJQVZCUUdzZ0FVRUFTQVIvSUFGQkFYUUZJQVVnQVVFY2RqWUNmQ0FEUVFGcUlRTWdBVUVFZEFzaUFVRWZkallDQUNBRklBRkJBRWdFZnlBQlFRRjBCU0FGSUFGQkhIWTJBb0FCSUFOQkFXb2hBeUFCUVFSMEN5SUJRUjkyTmdKRUlBVWdBVUVBU0FSL0lBRkJBWFFGSUFVZ0FVRWNkallDaEFFZ0EwRUJhaUVESUFGQkJIUUxJZ0ZCSDNZMkFrZ2dBVUVBU0FSL0lBRkJBWFFGSUFVZ0FVRWNkallDaUFFZ0EwRUJhaUVESUFGQkJIUUxJUVlnQUNBRFFRTnNRUWhxRUF0QmYwWU5BQ0FISUFZMkFnd2dCMEVDTmdJSURBRUxJQWNnQmpZQ0RFRUJJUU1NQVF0QkFTRURJQUFnQjBFTWFoQUNEUUFnQnlnQ0RDSUJRUU5MRFFBZ0JTQUJOZ0tNQVVFQUlRTUxJQU1OQVFKQUlBcEJBVWNFUUNBQUlBZEJCR29nQ2tVUUxTSUREUU1nQlNBSEtBSUVJZ0UyQWdRZ0FVVU5BZ3dCQ3lBRklBVW9BZ0FpQVVGNWFpSURRUUowUVhCeElnUkJVR29nQkNBRFFRdExHMEVQUVFBZ0FVRVNTeHR5TmdJRUMwRUJJUU1nQUNBSFFReHFFQVVOQVNBSEtBSU1JZ0ZCR21wQk0wc05BU0FGSUFFMkFnZ2dCVUdRQW1vaENDQUZLQUlFSVFRQ1FBSkFJQVVvQWdCQkIwa0VRRUVBSVFsQkF5RURBMEFnQXlFQklBUkJBWEVFUUNBSUlBbEJBblJxUWJnTmFpQUFJQWdnQ1VFR2RHcEJPR29nQWlBSklBZ1FEVUVRRUFraUEwRVFkallDQUNBRFFROXhEUVFnQ0NBSlFRRjBhaUFEUVFSMlFmOEJjVHNCQUNBSUlBbEJBWElpQmtFQ2RHcEJ1QTFxSUFBZ0NDQUdRUVowYWtFNGFpQUNJQVlnQ0JBTlFSQVFDU0lEUVJCMk5nSUFJQU5CRDNFTkJDQUlJQVpCQVhScUlBTkJCSFpCL3dGeE93RUFJQWdnQ1VFQ2NpSUdRUUowYWtHNERXb2dBQ0FJSUFaQkJuUnFRVGhxSUFJZ0JpQUlFQTFCRUJBSklnTkJFSFkyQWdBZ0EwRVBjUTBFSUFnZ0JrRUJkR29nQTBFRWRrSC9BWEU3QVFBZ0NDQUpRUU55SWdaQkFuUnFRYmdOYWlBQUlBZ2dCa0VHZEdwQk9Hb2dBaUFHSUFnUURVRVFFQWtpQTBFUWRqWUNBQ0FEUVE5eERRUWdCU0FHUVFGMGFpQURRUVIyUWY4QmNUc0JrQUlMSUFSQkFYWWhCQ0FCUVg5cUlRTWdDVUVFYWlFSklBRU5BQXNNQVF0QkFDRUpJQUFnQlVISURtb2dBa0VBSUFnUURVRVFFQWtpQTBFUGNRMEJJQVVnQTBFRWRrSC9BWEU3QWNBQ0lBVkJrQUpxSVFaQkF5RURBMEFnQXlFQklBUkJBWEVFUUNBR0lBbEJBblJxUWJnTmFpQUFJQVlnQ1VFR2RHcEJQR29nQWlBSklBZ1FEVUVQRUFraUEwRVBkallDQUNBRFFROXhEUU1nQmlBSlFRRjBhaUFEUVFSMlFmOEJjVHNCQUNBR0lBbEJBWElpQ2tFQ2RHcEJ1QTFxSUFBZ0JpQUtRUVowYWtFOGFpQUNJQW9nQ0JBTlFROFFDU0lEUVE5Mk5nSUFJQU5CRDNFTkF5QUdJQXBCQVhScUlBTkJCSFpCL3dGeE93RUFJQVlnQ1VFQ2NpSUtRUUowYWtHNERXb2dBQ0FHSUFwQkJuUnFRVHhxSUFJZ0NpQUlFQTFCRHhBSklnTkJEM1kyQWdBZ0EwRVBjUTBESUFZZ0NrRUJkR29nQTBFRWRrSC9BWEU3QVFBZ0JpQUpRUU55SWdwQkFuUnFRYmdOYWlBQUlBWWdDa0VHZEdwQlBHb2dBaUFLSUFnUURVRVBFQWtpQTBFUGRqWUNBQ0FEUVE5eERRTWdCU0FLUVFGMGFpQURRUVIyUWY4QmNUc0JrQUlMSUFSQkFYWWhCQ0FCUVg5cUlRTWdDVUVFYWlFSklBRU5BQXNMSUFSQkEzRUVRQ0FBSUFWQmlBOXFRWDlCQkJBSklnTkJEM0VOQVNBRklBTkJCSFpCL3dGeE93SENBaUFBSUFWQm1BOXFRWDlCQkJBSklnTkJEM0VOQVNBRklBTkJCSFpCL3dGeE93SEVBZ3RCQUNFRElBUkJBbkZGRFFBZ0FDQUZRY3dLYWlBQ1FSQWdDQkFOUVE4UUNTSUJRUTl4QkVBZ0FTRUREQUVMSUFWQmlCQnFJQUZCRDNZMkFnQWdCU0FCUVFSMlFmOEJjVHNCc0FJZ0FDQUZRWXdMYWlBQ1FSRWdDQkFOUVE4UUNTSUJRUTl4QkVBZ0FTRUREQUVMSUFWQmpCQnFJQUZCRDNZMkFnQWdCU0FCUVFSMlFmOEJjVHNCc2dJZ0FDQUZRY3dMYWlBQ1FSSWdDQkFOUVE4UUNTSUJRUTl4QkVBZ0FTRUREQUVMSUFWQmtCQnFJQUZCRDNZMkFnQWdCU0FCUVFSMlFmOEJjVHNCdEFJZ0FDQUZRWXdNYWlBQ1FSTWdDQkFOUVE4UUNTSUJRUTl4QkVBZ0FTRUREQUVMSUFWQmxCQnFJQUZCRDNZMkFnQWdCU0FCUVFSMlFmOEJjVHNCdGdJZ0FDQUZRY3dNYWlBQ1FSUWdDQkFOUVE4UUNTSUJRUTl4QkVBZ0FTRUREQUVMSUFWQm1CQnFJQUZCRDNZMkFnQWdCU0FCUVFSMlFmOEJjVHNCdUFJZ0FDQUZRWXdOYWlBQ1FSVWdDQkFOUVE4UUNTSUJRUTl4QkVBZ0FTRUREQUVMSUFWQm5CQnFJQUZCRDNZMkFnQWdCU0FCUVFSMlFmOEJjVHNCdWdJZ0FDQUZRY3dOYWlBQ1FSWWdDQkFOUVE4UUNTSUJRUTl4QkVBZ0FTRUREQUVMSUFWQm9CQnFJQUZCRDNZMkFnQWdCU0FCUVFSMlFmOEJjVHNCdkFJZ0FDQUZRWXdPYWlBQ1FSY2dDQkFOUVE4UUNTSUJRUTl4QkVBZ0FTRUREQUVMSUFWQnBCQnFJQUZCRDNZMkFnQWdCU0FCUVFSMlFmOEJjVHNCdmdJTElBQWdBQ2dDQ0NBQUtBSUVJQUFvQWdCclFRTjBhallDRUNBRERRRUxRUUFoQXdzZ0IwRVFhaVFBSUFNTHBSUUJESDhDZnlBQUtBTElBU0lIQkVBZ0FDZ0NCQ0FIS0FJRVJnd0JDMEVBQ3lFS0FrQWdCa1VOQUNBS1JRMEFRUUFnQ2tFQ0lBQW9Bc2dCS0FJQUlnZEJCa2NnQjBFR1NSdEJBa1liSVFvTEFuOGdBQ2dDekFFaUJ3UkFJQUFvQWdRZ0J5Z0NCRVlNQVF0QkFBc2hCd0pBSUFaRkRRQWdCMFVOQUVFQUlBZEJBaUFBS0FMTUFTZ0NBQ0lIUVFaSElBZEJCa2tiUVFKR0d5RUhDd0ovSUFBb0F0UUJJZ2tFUUNBQUtBSUVJQWtvQWdSR0RBRUxRUUFMSVFrQ1FDQUdSUTBBSUFsRkRRQkJBaUFBS0FMVUFTZ0NBQ0lBUVFaSElBQkJCa2tiUVFKSElRa0xJQXBCQUVjZ0IwRUFSM0VpRFNBSlFRQkhjU0VPSUFWQkFrc2hEMEVRSVFzRFFBSkFJQTlGQkVBQ1FBSkFBa0FnQlVFQmF3NENBUUlBQ3lBQkFuOGdEUVJBSUFRdEFBTWdCQzBBQWlBRUxRQUJJQVF0QUFBZ0F5MEFCQ0FETFFBRElBTXRBQUVnQXkwQUFtcHFhbXBxYW1wQkJHcEJBM1loQmlBRExRQUlJQU10QUFjZ0F5MEFCU0FETFFBR2FtcHFRUUpxUVFKMkRBRUxJQWNFUUNBRExRQUVJQU10QUFNZ0F5MEFBU0FETFFBQ2FtcHFRUUpxUVFKMklRWWdBeTBBQ0NBRExRQUhJQU10QUFVZ0F5MEFCbXBxYWtFQ2FrRUNkZ3dCQ3lBS1JRUkFRWUFCSVFaQmdBRU1BUXNnQkMwQUF5QUVMUUFDSUFRdEFBQWdCQzBBQVdwcWFrRUNha0VDZGlJR0MwSC9BWEZCZ1lLRUNHd2lBRFlBSENBQklBWkIvd0Z4UVlHQ2hBaHNJZ1kyQUJnZ0FTQUFOZ0FVSUFFZ0JqWUFFQ0FCSUFBMkFBd2dBU0FHTmdBSUlBRWdBRFlBQkNBQklBWTJBQUFDZnlBS0JFQWdCQzBBQnlBRUxRQUdJQVF0QUFVZ0JDMEFCR3BxYWlJR1FRSnFRUUoySWdBZ0IwVU5BUm9nQXkwQUNDQURMUUFISUFNdEFBWWdCaUFETFFBRmFtcHFha0VFYWtFRGRnd0JDeUFIUlFSQVFZQUJJUUJCZ0FFTUFRc2dBeTBBQkNBRExRQURJQU10QUFFZ0F5MEFBbXBxYWtFQ2FrRUNkaUVBSUFNdEFBZ2dBeTBBQnlBRExRQUZJQU10QUFacWFtcEJBbXBCQW5ZTElRWWdBU0FBUWY4QmNVR0Jnb1FJYkNJQU5nQWdJQUVnQmtIL0FYRkJnWUtFQ0d3aUJqWUFQQ0FCSUFBMkFEZ2dBU0FHTmdBMElBRWdBRFlBTUNBQklBWTJBQ3dnQVNBQU5nQW9JQUVnQmpZQUpBd0RDeUFLUlFSQVFRRVBDeUFCSUFRdEFBQTZBQUFnQVNBRUxRQUFPZ0FCSUFFZ0JDMEFBRG9BQWlBQklBUXRBQUE2QUFNZ0FTQUVMUUFBT2dBRUlBRWdCQzBBQURvQUJTQUJJQVF0QUFBNkFBWWdBU0FFTFFBQU9nQUhJQUVnQkMwQUFUb0FDQ0FCSUFRdEFBRTZBQWtnQVNBRUxRQUJPZ0FLSUFFZ0JDMEFBVG9BQ3lBQklBUXRBQUU2QUF3Z0FTQUVMUUFCT2dBTklBRWdCQzBBQVRvQURpQUJJQVF0QUFFNkFBOGdBU0FFTFFBQ09nQVFJQUVnQkMwQUFqb0FFU0FCSUFRdEFBSTZBQklnQVNBRUxRQUNPZ0FUSUFFZ0JDMEFBam9BRkNBQklBUXRBQUk2QUJVZ0FTQUVMUUFDT2dBV0lBRWdCQzBBQWpvQUZ5QUJJQVF0QUFNNkFCZ2dBU0FFTFFBRE9nQVpJQUVnQkMwQUF6b0FHaUFCSUFRdEFBTTZBQnNnQVNBRUxRQURPZ0FjSUFFZ0JDMEFBem9BSFNBQklBUXRBQU02QUI0Z0FTQUVMUUFET2dBZklBRWdCQzBBQkRvQUlDQUJJQVF0QUFRNkFDRWdBU0FFTFFBRU9nQWlJQUVnQkMwQUJEb0FJeUFCSUFRdEFBUTZBQ1FnQVNBRUxRQUVPZ0FsSUFFZ0JDMEFCRG9BSmlBQklBUXRBQVE2QUNjZ0FTQUVMUUFGT2dBb0lBRWdCQzBBQlRvQUtTQUJJQVF0QUFVNkFDb2dBU0FFTFFBRk9nQXJJQUVnQkMwQUJUb0FMQ0FCSUFRdEFBVTZBQzBnQVNBRUxRQUZPZ0F1SUFFZ0JDMEFCVG9BTHlBQklBUXRBQVk2QURBZ0FTQUVMUUFHT2dBeElBRWdCQzBBQmpvQU1pQUJJQVF0QUFZNkFETWdBU0FFTFFBR09nQTBJQUVnQkMwQUJqb0FOU0FCSUFRdEFBWTZBRFlnQVNBRUxRQUdPZ0EzSUFFZ0JDMEFCem9BT0NBQklBUXRBQWM2QURrZ0FTQUVMUUFIT2dBNklBRWdCQzBBQnpvQU95QUJJQVF0QUFjNkFEd2dBU0FFTFFBSE9nQTlJQUVnQkMwQUJ6b0FQaUFCSUFRdEFBYzZBRDhNQWdzZ0IwVUVRRUVCRHdzZ0FTQURMUUFCT2dBQUlBRWdBeTBBQVRvQUNDQUJJQU10QUFFNkFCQWdBU0FETFFBQk9nQVlJQUVnQXkwQUFUb0FJQ0FCSUFNdEFBRTZBQ2dnQVNBRExRQUJPZ0F3SUFFZ0F5MEFBVG9BT0NBQklBTXRBQUk2QUFFZ0FTQURMUUFDT2dBSklBRWdBeTBBQWpvQUVTQUJJQU10QUFJNkFCa2dBU0FETFFBQ09nQWhJQUVnQXkwQUFqb0FLU0FCSUFNdEFBSTZBREVnQVNBRExRQUNPZ0E1SUFFZ0F5MEFBem9BQWlBQklBTXRBQU02QUFvZ0FTQURMUUFET2dBU0lBRWdBeTBBQXpvQUdpQUJJQU10QUFNNkFDSWdBU0FETFFBRE9nQXFJQUVnQXkwQUF6b0FNaUFCSUFNdEFBTTZBRG9nQVNBRExRQUVPZ0FESUFFZ0F5MEFCRG9BQ3lBQklBTXRBQVE2QUJNZ0FTQURMUUFFT2dBYklBRWdBeTBBQkRvQUl5QUJJQU10QUFRNkFDc2dBU0FETFFBRU9nQXpJQUVnQXkwQUJEb0FPeUFCSUFNdEFBVTZBQVFnQVNBRExRQUZPZ0FNSUFFZ0F5MEFCVG9BRkNBQklBTXRBQVU2QUJ3Z0FTQURMUUFGT2dBa0lBRWdBeTBBQlRvQUxDQUJJQU10QUFVNkFEUWdBU0FETFFBRk9nQThJQUVnQXkwQUJqb0FCU0FCSUFNdEFBWTZBQTBnQVNBRExRQUdPZ0FWSUFFZ0F5MEFCam9BSFNBQklBTXRBQVk2QUNVZ0FTQURMUUFHT2dBdElBRWdBeTBBQmpvQU5TQUJJQU10QUFZNkFEMGdBU0FETFFBSE9nQUdJQUVnQXkwQUJ6b0FEaUFCSUFNdEFBYzZBQllnQVNBRExRQUhPZ0FlSUFFZ0F5MEFCem9BSmlBQklBTXRBQWM2QUM0Z0FTQURMUUFIT2dBMklBRWdBeTBBQnpvQVBpQUJJQU10QUFnNkFBY2dBU0FETFFBSU9nQVBJQUVnQXkwQUNEb0FGeUFCSUFNdEFBZzZBQjhnQVNBRExRQUlPZ0FuSUFFZ0F5MEFDRG9BTHlBQklBTXRBQWc2QURjZ0FTQURMUUFJT2dBL0RBRUxJQTVGQkVCQkFROExJQU10QUFVZ0F5MEFBMnNnQXkwQUJpQURMUUFDYTBFQmRHb2dBeTBBQnlBRExRQUJhMEVEYkdvZ0F5MEFDQ0lBSUFNdEFBQWlDV3RCQW5ScVFSRnNRUkJxUVFWMUlnWkJmV3doRUNBQUlBUXRBQWNpREdwQkJIUWdCQzBBQkNBRUxRQUNheUFNSUFsclFRSjBhaUFFTFFBRklBUXRBQUZyUVFGMGFpQUVMUUFHSUFRdEFBQnJRUU5zYWtFUmJFRVFha0VGZFNJUlFYMXNha0VRYWlFSlFRZ2hEQ0FCSVFBRFFDQUFJQWtnRUdvaUNFRUZkVUd3TG1vdEFBQTZBQUFnQUNBR0lBaHFJZ2hCQlhWQnNDNXFMUUFBT2dBQklBQWdCaUFJYWlJSVFRVjFRYkF1YWkwQUFEb0FBaUFBSUFZZ0NHb2lDRUVGZFVHd0xtb3RBQUE2QUFNZ0FDQUdJQWhxSWdoQkJYVkJzQzVxTFFBQU9nQUVJQUFnQmlBSWFpSUlRUVYxUWJBdWFpMEFBRG9BQlNBQUlBWWdDR29pQ0VFRmRVR3dMbW90QUFBNkFBWWdBQ0FHSUFocVFRVjFRYkF1YWkwQUFEb0FCeUFKSUJGcUlRa2dBRUVJYWlFQUlBeEJmMm9pREEwQUN3c2dBU0FDSUFzUUNDQUJJQUpCUUdzZ0MwRUJjaEFJSUFFZ0FrR0FBV29nQzBFQ2NoQUlJQUVnQWtIQUFXb2dDMEVEY2hBSUlBSkJnQUpxSVFJZ0JFRUlhaUVFSUFOQkNXb2hBeUFCUVVCcklRRWdDMEVFYWlFTElCSkJBV29pRWtFQ1J3MEFDMEVBQzZFVkFoaC9BbjRDZndOQUFuOGdBQ0lJSUJaQkEzUkJzRFZxS1FJQUloNm5FQkVpQ1NJR0JFQWdDQ2dDQkNBR0tBSUVSZ3dCQzBFQUN5RU5Ba0FnQlVVTkFDQU5SUTBBUVFBZ0RVRUNJQWtvQWdBaUJrRUdSeUFHUVFaSkcwRUNSaHNoRFFzQ2Z5QUlJQlpCQTNSQjhEWnFLUUlBSWgrbkVCRWlCeUlHQkVBZ0NDZ0NCQ0FHS0FJRVJnd0JDMEVBQ3lFUEFrQWdCVVVOQUNBUFJRMEFRUUFnRDBFQ0lBY29BZ0FpQmtFR1J5QUdRUVpKRzBFQ1Joc2hEd3RCQWlFTUlBMUJBRWNnRDBFQVIzRWlFa0VCUmdSQVFRSWhCZ0ovUVFJZ0NTZ0NBQ0lMUVFaSElBdEJCa2tiUlFSQUlBa2dIa0lnaUtkQi93RnhhaTBBVWlFR0N5QUdDd0ovUVFJZ0J5Z0NBQ0lKUVFaSElBbEJCa2tiUlFSQUlBY2dIMElnaUtkQi93RnhhaTBBVWlFTUN5QU1DeUFHSUF4Skd5RU1DeUFDSUJaQkFuUWlDV29pQmlnQ0RFVUVRQ0FHS0FKTUlnWWdCaUFNVDJvaERBc2dDQ0FXYWlBTU9nQlNBbjhnQ0NBV1FRTjBRYkE0YWlnQ0FCQVJJZ1lpQndSQUlBZ29BZ1FnQnlnQ0JFWU1BUXRCQUFzaERnSkFJQVZGRFFBZ0RrVU5BRUVBSUE1QkFpQUdLQUlBSWdaQkJrY2dCa0VHU1J0QkFrWWJJUTRMQW44Z0FDQVdRUU4wUWZBNWFpZ0NBQkFSSWdnaUJnUkFJQUFvQWdRZ0JpZ0NCRVlNQVF0QkFBc2hFUUpBSUFWRkRRQWdFVVVOQUVFQUlCRkJBaUFJS0FJQUlnaEJCa2NnQ0VFR1NSdEJBa1liSVJFTElBbEI4Q2xxS0FJQUlSY2dDVUd3S1dvb0FnQWhHQUovUVlVS0lCWjJRUUZ4SWh3RVFDQVhRUU5xSVFjZ0JDQVhhaUlJUVFKcUlRWWdDRUVCYWlFTElBUU1BUXNnRjBFRWRDQVlhaUlJUVM5cUlRY2dBU0FJYWlJSVFSOXFJUVlnQ0VFUGFpRUxJQWhCZjJvaENDQUJDeUVKSUFjZ0NXb3RBQUFoQ2lBR0xRQUFJUkFnQ3kwQUFDRVRJQWd0QUFBaEZBSkFRVE1nRm5aQkFYRUVRQ0FESUJocUlnY3RBQWdoR3lBSExRQUhJUmtnQnkwQUJpRVZJQWN0QUFVaEdpQUhMUUFFSVFZZ0J5MEFBeUVMSUFjdEFBSWhDU0FITFFBQklRZ01BUXNnQVNBWFFYOXFJaDFCQkhRZ0dHcHFJZ2N0QUFBaENDQUhMUUFISVJzZ0J5MEFCaUVaSUFjdEFBVWhGU0FITFFBRUlSb2dCeTBBQXlFR0lBY3RBQUloQ3lBSExRQUJJUWtnSEFSQUlBUWdIV29oQnd3QkN5QUhRWDlxSVFjTEFrQWdERUVIVFFSQUlBY3RBQUFoQndKQUFrQUNRQUpBQWtBQ1FBSkFBa0FnREVFQmF3NEhBUUlEQkFVR0J3QUxJQTlGQkVCQkFROExJQWhCL3dGeElBdEIvd0Z4UVJCMElBWkJHSFJ5Y2lBSlFmOEJjVUVJZEhJaEZTQUlJZ3doRFNBSklnNGhFaUFMSWc4aENpQUdJaEVoQnd3SUN5QU5SUVJBUVFFUEN5QUtRWUdDaEFoc0lSVWdFRUdCZ29RSWJDSU5RUmgySVFjZ0RVRVFkaUVLSUExQkNIWWhFaUFUUVlHQ2hBaHNJZ3hCR0hZaEVTQU1RUkIySVE4Z0RFRUlkaUVPSUJSQmdZS0VDR3dpQ0VFWWRpRUdJQWhCRUhZaEN5QUlRUWgySVFrTUJ3c0NmeUFUSUJScUlBcHFJQkJxSUFaQi93RnhhaUFMUWY4QmNXb2dDVUgvQVhGcUlBaEIvd0Z4YWtFRWFrRURkaUFTRFFBYUlCTWdGR29nQ21vZ0VHcEJBbXBCQW5ZZ0RRMEFHa0dBQVNBUFJRMEFHaUFHUWY4QmNTQUxRZjhCY1dvZ0NVSC9BWEZxSUFoQi93Rnhha0VDYWtFQ2Rnc2lDRUdCZ29RSWJDRVZJQWdpQ1NJTElnWWlEQ0lPSWc4aUVTSU5JaElpQ2lFSERBWUxJQTlGQkVCQkFROExJQVpCL3dGeElnMUJBbW9pRVNBVklBWWdEaHRCL3dGeElnZHFJQm9nQmlBT0cwSC9BWEVpQ2tFQmRHcEJBbllpRHlBWklBWWdEaHRCL3dGeElnd2dHeUFHSUE0YlFmOEJjU0lHUVFOc2FrRVdkRUdBZ0lBRWFrR0FnSUI0Y1hJZ0NpQU1haUFIUVFGMGFrRUNhaUlRUVFaMFFZRCtBM0Z5SUFZZ0Iyb2dERUVCZEdwQkFtb2lCa0VPZEVHQWdQd0hjWEloRlNBR1FRSjJJUWNnQzBIL0FYRWlCa0VDYWlJTElBaEIvd0Z4YWlBSlFmOEJjU0lKUVFGMGFrRUNkaUVJSUFrZ0VXb2dCa0VCZEdwQkFuWWlDU0VNSUFvZ0Myb2dEVUVCZEdwQkFuWWlDeUVPSUFzaERTQVBJZ1loRWlBUVFRSjJJaEVoQ2d3RkMwRUJJQkZGSUJKQkFYTnlEUVlhSUJRZ0UwRUJkR29nRUdwQkFtb2lEa0VHZEVHQS9nTnhJQW9nRTBFQ2FpSVBhaUFRUVFGMGFrRUNkbklnQ0VIL0FYRWlDa0VDYWlJTUlCUnFJQWRCQVhScVFRSjJJZ2hCR0hSeUlBOGdGRUVCZEdvZ0Iyb2lFRUVPZEVHQWdQd0hjWEloRlNBSlFmOEJjU0lSUVFKcUlna2dCa0gvQVhGcUlBdEIvd0Z4SWd0QkFYUnFRUUoySVFZZ0RrRUNkaUVOSUFrZ0NrRUJkR29nQjJwQkFuWWlDU0VQSUJGQkFYUWdDMm9nREdwQkFuWWlDeUVSSUJCQkFuWWlEQ0VTSUFnaURpRUtJQWtoQnd3RUMwRUJJQkZGSUJKQkFYTnlEUVVhSUFoQi93RnhJZ3BCQW1vaURpQUxRZjhCY1NJSUlBbEIvd0Z4SWd0QkFYUnFha0VDZGlJUFFSaDBJQlFnRTBFQmRHb2dFR3BCQW1wQkFuWnlJQTRnRkdvZ0IwRUJkR29pQ1VFR2RFR0EvZ054Y2lBTFFRSnFJZzRnQ2tFQmRHb2dCMm9pRFVFT2RFR0FnUHdIY1hJaEZTQUlRUUZxSWhBZ0JrSC9BWEVpREdwQkFYWWhCaUFNSUE1cUlBaEJBWFJxUVFKMklSRWdDVUVDZGlFTUlBMUJBblloRGlBVElCUkJBWFJxSUFkcVFRSnFRUUoySVEwZ0J5QUtha0VCYWtFQmRpSUlJUklnQ2lBTGFrRUJha0VCZGlJSklRb2dDeUFRYWtFQmRpSUxJUWNNQXd0QkFTQVJSU0FTUVFGemNnMEVHaUFUUVFKcUlnNGdDbW9nRUVFQmRHcEJCblJCZ1A0RGNTQVFJQk5xUVFGcUlnOUJEM1JCZ0lEOEIzRWdGRUVDYWlJTUlCTkJBWFJxSUJCcVFRSjJJaEpCR0hSeUlBb2dFR3BCQVdwQkFYWnljaUVWSUFoQi93RnhJZ2dnQzBIL0FYRnFJQWxCL3dGeElnbEJBWFJxUVFKcVFRSjJJUVlnQ1NBSVFRRjBhaUFIYWtFQ2FrRUNkaUVMSUE5QkFYWWhEU0FJSUF4cUlBZEJBWFJxUVFKMkloRWhDU0FVUVFGcUlnb2dCMnBCQVhZaUNDRVBJQW9nRTJwQkFYWWlEQ0VLSUE0Z0ZFRUJkR29nQjJwQkFuWWlEaUVIREFJTElBOUZCRUJCQVE4TElCb2dCaUFPRzBIL0FYRWlDaUFaSUFZZ0RodEIvd0Z4YWlBVklBWWdEaHRCL3dGeElnZEJBWFJxUVJaMElBdEIvd0Z4SWd0QkFtb2lEQ0FLYWlBR1FmOEJjU0lHUVFGMGFpSVBRUVowY2tHQWdJQUVha0dBL29ONGNTQUdRUUpxSWcwZ0NVSC9BWEVpQ1dvZ0MwRUJkR3BCQW5ZaURuSWdCeUFOYWlBS1FRRjBhaUlOUVE1MFFZQ0EvQWR4Y2lFVklBY2dDbXBCQVdwQkFYWWhCeUFOUVFKMklSRWdDU0FJUWY4QmNTSU5ha0VCYWtFQmRpRUlJQTlCQW5ZaER5QU1JQTFxSUFsQkFYUnFRUUoySVF3Z0NTQUxha0VCYWtFQmRpSUpJUTBnQmtFQmFpSUdJQXRxUVFGMklnc2hFaUFHSUFwcVFRRjJJZ1loQ2d3QkN5QU5SUVJBUVFFUEN5QUtRUWgwSUFweUlBcEJFSFJ5SUFwQkdIUnlJUlVnRUVFQ2FpSUhJQlJxSUJOQkFYUnFRUUoySVFrZ0UwRUJhaUlHSUJScVFRRjJJUWdnQmlBUWFrRUJkaUlMSVF3Z0NpQVRhaUFRUVFGMGFrRUNha0VDZGlJR0lRNGdDaUFRYWtFQmFrRUJkaUlQSVEwZ0J5QUtRUU5zYWtFQ2RpSVJJUklnQ2lFSEN5QUJJQmRCQkhRZ0dHcHFJaEFnRlRZQ01DQVFJQTFCL3dGeElCSkIvd0Z4UVFoMGNpQUtRZjhCY1VFUWRISWdCMEVZZEhJMkFpQWdFQ0FNUWY4QmNTQU9RZjhCY1VFSWRISWdEMEgvQVhGQkVIUnlJQkZCR0hSeU5nSVFJQkFnQ0VIL0FYRWdDVUgvQVhGQkNIUnlJQXRCL3dGeFFSQjBjaUFHUVJoMGNqWUNBQ0FCSUFJZ0ZrRUdkR3BCeUFKcUlCWVFDQ0FXUVFGcUloWkJFRWNOQUF0QkFBc0x4UklCRUg4Q2Z5QUFLQUxJQVNJSEJFQWdBQ2dDQkNBSEtBSUVSZ3dCQzBFQUN5RUhBa0FnQlVVTkFDQUhSUTBBUVFBZ0IwRUNJQUFvQXNnQktBSUFJZ2RCQmtjZ0IwRUdTUnRCQWtZYklRY0xBbjhnQUNnQ3pBRWlDQVJBSUFBb0FnUWdDQ2dDQkVZTUFRdEJBQXNoQ0FKQUlBVkZEUUFnQ0VVTkFFRUFJQWhCQWlBQUtBTE1BU2dDQUNJSVFRWkhJQWhCQmtrYlFRSkdHeUVJQ3dKL0lBQW9BdFFCSWdrRVFDQUFLQUlFSUFrb0FnUkdEQUVMUVFBTElRa0NRQ0FGUlEwQUlBbEZEUUJCQWlBQUtBTFVBU2dDQUNJRlFRWkhJQVZCQmtrYlFRSkhJUWtMQWtBQ1FDQUFLQUlBUVFGcVFRTnhJZ0JCQWswRVFBSkFBa0FDUUNBQVFRRnJEZ0lCQWdBTElBaEZCRUJCQVE4TFFRQWhCU0FCSVFBRFFDQUFJQU10QUFFNkFBQWdBQ0FETFFBQ09nQUJJQUFnQXkwQUF6b0FBaUFBSUFNdEFBUTZBQU1nQUNBRExRQUZPZ0FFSUFBZ0F5MEFCam9BQlNBQUlBTXRBQWM2QUFZZ0FDQURMUUFJT2dBSElBQWdBeTBBQ1RvQUNDQUFJQU10QUFvNkFBa2dBQ0FETFFBTE9nQUtJQUFnQXkwQUREb0FDeUFBSUFNdEFBMDZBQXdnQUNBRExRQU9PZ0FOSUFBZ0F5MEFEem9BRGlBQUlBTXRBQkE2QUE4Z0FFRVFhaUVBSUFWQkFXb2lCVUVRUncwQUN3d0RDeUFIUlFSQVFRRVBDMEVBSVFVZ0FTRUFBMEFnQUNBRUlBVnFJZ010QUFBNkFBQWdBQ0FETFFBQU9nQUJJQUFnQXkwQUFEb0FBaUFBSUFNdEFBQTZBQU1nQUNBRExRQUFPZ0FFSUFBZ0F5MEFBRG9BQlNBQUlBTXRBQUE2QUFZZ0FDQURMUUFBT2dBSElBQWdBeTBBQURvQUNDQUFJQU10QUFBNkFBa2dBQ0FETFFBQU9nQUtJQUFnQXkwQUFEb0FDeUFBSUFNdEFBQTZBQXdnQUNBRExRQUFPZ0FOSUFBZ0F5MEFBRG9BRGlBQUlBTXRBQUE2QUE4Z0FFRVFhaUVBSUFWQkFXb2lCVUVRUncwQUN3d0NDeUFCQW44Q1FDQUhSUTBBSUFoRkRRQWdCQzBBRHlBRExRQVFJQVF0QUE0Z0F5MEFEeUFFTFFBTklBTXRBQTRnQkMwQURDQURMUUFOSUFRdEFBc2dBeTBBRENBRUxRQUtJQU10QUFzZ0JDMEFDU0FETFFBS0lBUXRBQWdnQXkwQUNTQUVMUUFISUFNdEFBZ2dCQzBBQmlBRExRQUhJQVF0QUFVZ0F5MEFCaUFFTFFBRUlBTXRBQVVnQkMwQUF5QURMUUFFSUFRdEFBSWdBeTBBQXlBRUxRQUJJQU10QUFJZ0F5MEFBU0FFTFFBQWFtcHFhbXBxYW1wcWFtcHFhbXBxYW1wcWFtcHFhbXBxYW1wcWFtcHFha0VRYWtFRmRnd0JDeUFIQkVBZ0JDMEFEeUFFTFFBT0lBUXRBQTBnQkMwQURDQUVMUUFMSUFRdEFBb2dCQzBBQ1NBRUxRQUlJQVF0QUFjZ0JDMEFCaUFFTFFBRklBUXRBQVFnQkMwQUF5QUVMUUFDSUFRdEFBQWdCQzBBQVdwcWFtcHFhbXBxYW1wcWFtcHFha0VJYWtFRWRnd0JDMEdBQVNBSVJRMEFHaUFETFFBUUlBTXRBQThnQXkwQURpQURMUUFOSUFNdEFBd2dBeTBBQ3lBRExRQUtJQU10QUFrZ0F5MEFDQ0FETFFBSElBTXRBQVlnQXkwQUJTQURMUUFFSUFNdEFBTWdBeTBBQVNBRExRQUNhbXBxYW1wcWFtcHFhbXBxYW1wcVFRaHFRUVIyQzBHQUFoQUhHZ3dCQzBFQklRQWdCMFVOQVNBSVJRMEJJQWxGRFFFZ0JDMEFDQ0FFTFFBR2F5QUVMUUFQSWdBZ0F5MEFBQ0lGYTBFRGRHb2dCQzBBQ1NBRUxRQUZhMEVCZEdvZ0JDMEFDaUFFTFFBRWEwRURiR29nQkMwQUN5QUVMUUFEYTBFQ2RHb2dCQzBBRENBRUxRQUNhMEVGYkdvZ0JDMEFEU0FFTFFBQmEwRUdiR29nQkMwQURpQUVMUUFBYTBFSGJHcEJCV3hCSUdwQkJuVWhCeUFETFFBSklBTXRBQWRySUFNdEFBb2dBeTBBQm10QkFYUnFJQU10QUFzZ0F5MEFCV3RCQTJ4cUlBTXRBQXdnQXkwQUJHdEJBblJxSUFNdEFBMGdBeTBBQTJ0QkJXeHFJQU10QUE0Z0F5MEFBbXRCQm14cUlBTXRBQThnQXkwQUFXdEJCMnhxSUFNdEFCQWlBeUFGYTBFRGRHcEJCV3hCSUdwQkJuVWlCRUVEZENFSUlBUkJCMndoQ1NBRVFRWnNJUW9nQkVFRmJDRUxJQVJCQTJ3aERDQUVRWDFzSVEwZ0JFRjdiQ0VPSUFSQmVtd2hEeUFFUVhsc0lSQkJBQ0FFUVFGMEloRnJJUkpCQUNBRVFRSjBJaE5ySVJRZ0FDQURha0VFZEVFUWFpRVZRUUFoQlFOQUlBRWdCVUVFZENJQWFpQVZJQVZCZVdvZ0IyeHFJZ01nRUdwQkJYVWlCa0gvQVNBR1FmOEJTQnNpQmtFQUlBWkJBRW9iT2dBQUlBRWdBRUVCY21vZ0F5QVBha0VGZFNJR1FmOEJJQVpCL3dGSUd5SUdRUUFnQmtFQVNoczZBQUFnQVNBQVFRSnlhaUFESUE1cVFRVjFJZ1pCL3dFZ0JrSC9BVWdiSWdaQkFDQUdRUUJLR3pvQUFDQUJJQUJCQTNKcUlBTWdGR3BCQlhVaUJrSC9BU0FHUWY4QlNCc2lCa0VBSUFaQkFFb2JPZ0FBSUFFZ0FFRUVjbW9nQXlBTmFrRUZkU0lHUWY4QklBWkIvd0ZJR3lJR1FRQWdCa0VBU2hzNkFBQWdBU0FBUVFWeWFpQURJQkpxUVFWMUlnWkIvd0VnQmtIL0FVZ2JJZ1pCQUNBR1FRQktHem9BQUNBQklBQkJCbkpxSUFNZ0JHdEJCWFVpQmtIL0FTQUdRZjhCU0JzaUJrRUFJQVpCQUVvYk9nQUFJQUVnQUVFSGNtb2dBMEVGZFNJR1FmOEJJQVpCL3dGSUd5SUdRUUFnQmtFQVNoczZBQUFnQVNBQVFRaHlhaUFESUFScVFRVjFJZ1pCL3dFZ0JrSC9BVWdiSWdaQkFDQUdRUUJLR3pvQUFDQUJJQUJCQ1hKcUlBTWdFV3BCQlhVaUJrSC9BU0FHUWY4QlNCc2lCa0VBSUFaQkFFb2JPZ0FBSUFFZ0FFRUtjbW9nQXlBTWFrRUZkU0lHUWY4QklBWkIvd0ZJR3lJR1FRQWdCa0VBU2hzNkFBQWdBU0FBUVF0eWFpQURJQk5xUVFWMUlnWkIvd0VnQmtIL0FVZ2JJZ1pCQUNBR1FRQktHem9BQUNBQklBQkJESEpxSUFNZ0MycEJCWFVpQmtIL0FTQUdRZjhCU0JzaUJrRUFJQVpCQUVvYk9nQUFJQUVnQUVFTmNtb2dBeUFLYWtFRmRTSUdRZjhCSUFaQi93RklHeUlHUVFBZ0JrRUFTaHM2QUFBZ0FTQUFRUTV5YWlBRElBbHFRUVYxSWdaQi93RWdCa0gvQVVnYklnWkJBQ0FHUVFCS0d6b0FBQ0FCSUFCQkQzSnFJQU1nQ0dwQkJYVWlBRUgvQVNBQVFmOEJTQnNpQUVFQUlBQkJBRW9iT2dBQUlBVkJBV29pQlVFUVJ3MEFDd3RCQUNFQUlBRWdBa0VBRUFnZ0FTQUNRVUJyUVFFUUNDQUJJQUpCZ0FGcVFRSVFDQ0FCSUFKQndBRnFRUU1RQ0NBQklBSkJnQUpxUVFRUUNDQUJJQUpCd0FKcVFRVVFDQ0FCSUFKQmdBTnFRUVlRQ0NBQklBSkJ3QU5xUVFjUUNDQUJJQUpCZ0FScVFRZ1FDQ0FCSUFKQndBUnFRUWtRQ0NBQklBSkJnQVZxUVFvUUNDQUJJQUpCd0FWcVFRc1FDQ0FCSUFKQmdBWnFRUXdRQ0NBQklBSkJ3QVpxUVEwUUNDQUJJQUpCZ0FkcVFRNFFDQ0FCSUFKQndBZHFRUThRQ0FzZ0FBdkJDQUVIZndKQUlBTkZEUUFnQUNnQ0FDQURJQUFvQWdRaUJXNGlDQ0FGYkNJRVFRaDBhaUFESUFScklnZEJCSFJxSVFZZ0JVRUVkQ0VFSUFBb0FnZ2hDU0FGSUFOTElncEZCRUFnQVNBR0lBUkJmM05xSWdNdEFBQTZBQUFnQVNBR0lBUnJMUUFBT2dBQklBRWdBeTBBQWpvQUFpQUJJQU10QUFNNkFBTWdBU0FETFFBRU9nQUVJQUVnQXkwQUJUb0FCU0FCSUFNdEFBWTZBQVlnQVNBRExRQUhPZ0FISUFFZ0F5MEFDRG9BQ0NBQklBTXRBQWs2QUFrZ0FTQURMUUFLT2dBS0lBRWdBeTBBQ3pvQUN5QUJJQU10QUF3NkFBd2dBU0FETFFBTk9nQU5JQUVnQXkwQURqb0FEaUFCSUFNdEFBODZBQThnQVNBRExRQVFPZ0FRSUFFZ0F5MEFFVG9BRVNBQklBTXRBQkk2QUJJZ0FTQURMUUFUT2dBVElBRWdBeTBBRkRvQUZDQUJRUlZxSVFFTElBY0VRQ0FDSUFaQmYyb2lBeTBBQURvQUFDQUNJQU1nQkdvaUF5MEFBRG9BQVNBQ0lBTWdCR29pQXkwQUFEb0FBaUFDSUFNZ0JHb2lBeTBBQURvQUF5QUNJQU1nQkdvaUF5MEFBRG9BQkNBQ0lBTWdCR29pQXkwQUFEb0FCU0FDSUFNZ0JHb2lBeTBBQURvQUJpQUNJQU1nQkdvaUF5MEFBRG9BQnlBQ0lBTWdCR29pQXkwQUFEb0FDQ0FDSUFNZ0JHb2lBeTBBQURvQUNTQUNJQU1nQkdvaUF5MEFBRG9BQ2lBQ0lBTWdCR29pQXkwQUFEb0FDeUFDSUFNZ0JHb2lBeTBBQURvQURDQUNJQU1nQkdvaUF5MEFBRG9BRFNBQ0lBTWdCR29pQXkwQUFEb0FEaUFDSUFNZ0JHb3RBQUE2QUE4Z0FrRVFhaUVDQ3lBQUtBSUFJQVVnQ1d3aUJrRUlkR29nQ0NBRlFRTjBJZ0JzUVFOMGFpQUhRUU4wYWlFRUlBQkIrUC8vL3dkeElRQWdDa1VFUUNBQklBUWdBRUYvYzJvaUF5MEFBRG9BQUNBQklBUWdBR3N0QUFBNkFBRWdBU0FETFFBQ09nQUNJQUVnQXkwQUF6b0FBeUFCSUFNdEFBUTZBQVFnQVNBRExRQUZPZ0FGSUFFZ0F5MEFCam9BQmlBQklBTXRBQWM2QUFjZ0FTQURRUWhxSWdNdEFBQTZBQWdnQVNBR1FRWjBJQU5xSWdOQmVHb3RBQUE2QUFrZ0FTQURRWGxxTFFBQU9nQUtJQUVnQTBGNmFpMEFBRG9BQ3lBQklBTkJlMm90QUFBNkFBd2dBU0FEUVh4cUxRQUFPZ0FOSUFFZ0EwRjlhaTBBQURvQURpQUJJQU5CZm1vdEFBQTZBQThnQVNBRFFYOXFMUUFBT2dBUUlBRWdBeTBBQURvQUVRc2dCMFVOQUNBQ0lBUkJmMm9pQVMwQUFEb0FBQ0FDSUFBZ0FXb2lBUzBBQURvQUFTQUNJQUFnQVdvaUFTMEFBRG9BQWlBQ0lBQWdBV29pQVMwQUFEb0FBeUFDSUFBZ0FXb2lBUzBBQURvQUJDQUNJQUFnQVdvaUFTMEFBRG9BQlNBQ0lBQWdBV29pQVMwQUFEb0FCaUFDSUFBZ0FXb2lBUzBBQURvQUJ5QUNJQUFnQVdvZ0JpQUZhMEVHZEdvaUFTMEFBRG9BQ0NBQ0lBQWdBV29pQVMwQUFEb0FDU0FDSUFBZ0FXb2lBUzBBQURvQUNpQUNJQUFnQVdvaUFTMEFBRG9BQ3lBQ0lBQWdBV29pQVMwQUFEb0FEQ0FDSUFBZ0FXb2lBUzBBQURvQURTQUNJQUFnQVdvaUFTMEFBRG9BRGlBQ0lBQWdBV290QUFBNkFBOExDNjhCQVFGL0l3QkIwQUJySWdZa0FDQUNJQVpCSUdvZ0JpQURFRlVDUUFKQVFRSWdBQ2dDQUNJRFFRWkhJQU5CQmtrYlFRRkdCRUFnQUNBRklBRkJ5QUpxSUFaQklHb2dCaUFFRUZRaUEwVU5BUXdDQ3lBQUlBVWdBU0FHUVNCcUlBWWdCQkJUSWdNTkFRc2dBQ0FGUVlBQ2FpQUJRY2dLYWlBR1FUVnFJQVpCRUdvZ0FTZ0NqQUVnQkJCU0lnTU5BRUVBSVFNZ0FDZ0N4QUZCQVVzTkFDQUNJQVVRR3dzZ0JrSFFBR29rQUNBREM2TXFBU1IvSXdCQklHc2lFQ1FBSUJBZ0JDZ0NCQ0lJTmdJTUlCQWdCQ2dDQ0RZQ0VDQURJQWh1SWdaQkJIUWhGQ0FESUFZZ0NHeHJRUVIwSVJVQ1FBSkFBa0FDUUFKQUFrQUNRQUpBSUFBb0FnQWlCa0VEVFFSQUFrQUNRQUpBSUFaQkFtc09BZ0VDQUFzZ0FTZ0NrQUVoRXlBQUtBSUVJUTVCZnlFUEFuOGdBQ2dDeUFFaUNVVUVRRUVBSVFoQmZ3d0JDMEVBSVFoQmZ5QUpLQUlFSUE1SERRQWFRUUVoRWtGL0lBa29BZ0JCQlVzTkFCb2dDU2dDbUFFaUNFRVFkaUVISUFrb0FtZ0xJUTBnQUNnQ3pBRWlDVVVOQ0NBSktBSUVJQTVIRFFoQkFTRVdJQWtvQWdCQkJVc05DQ0FKS0FLc0FTSVJRUkIySVFvZ0NTZ0NiQ0VQREFnTElBRW9BcEFCSVJNZ0FTOEJvZ0VoRFNBQkx3R2dBU0VNSUFBb0FnUWhDMEYvSVFjQ1FDQUFLQUxNQVNJR1JRMEFJQXNnQmlnQ0JFY0VRQXdCQzBFQklSSWdCaWdDQUVFRlN3MEFJQVlvQXF3QklnbEJFSFloQ2lBR0tBSnNJUWNMSUFjZ0UwWUVRQ0FLSVFjZ0NTRUdEQWNMUVg4aER3SkFBa0FDUUNBQUtBTElBU0lJUlFSQVFRQWhCd3dCQzBFQUlRY2dDQ2dDQkNBTFJnMEJDMEVBSVFZTUFRdEJBU0VYSUFnb0FnQkJCVXNFUUVFQUlRWU1BUXNnQ0NnQ21BRWlCa0VRZGlFSElBZ29BbWdoRHdzQ1FBSkFJQUFvQXRBQklnaEZEUUFnQ0NnQ0JDQUxSdzBBSUFnb0FnQkJCVTBOQVF3R0N3SkFJQUFvQXRRQklnaEZEUUFnQ0NnQ0JDQUxSdzBBSUFnb0FnQkJCVXNOQmlBSUtBSndJUllnQ0NnQ3dBRWhDQXdIQzBFQUlRaEJmeUVXSUJJTkJpQVhSUTBHREFjTElBZ29BbXdoRmlBSUtBS3NBU0VJREFVTElBRW9BcEFCSVE4Z0FTOEJvZ0VoRFNBQkx3R2dBU0VNSUFBb0FnUWhCa0YvSVFjQ1FDQUFLQUxJQVNJS1JRUkFRUUFoQ0F3QkMwRUFJUWdnQmlBS0tBSUVSd1JBREFFTFFRRWhFU0FLS0FJQVFRVkxEUUFnQ2lnQ21BRWlDVUVRZGlFSUlBb29BbWdoQndzZ0J5QVBSZzBCQW44Q2Z3SkFBa0FnQUNnQ3pBRWlCMFVOQUNBSEtBSUVJQVpIRFFBZ0J5Z0NBRUVGU3cwQklBY29BbkFoRVNBSEtBSzhBU0VLSUFjb0Ftd2hFaUFIS0FLc0FTSUdRUkIyREFNTEFrQWdBQ2dDMUFFaUIwVU5BQ0FIS0FJRUlBWkhEUUJCQUNFR1FYOGhFaUFIS0FJQVFRVkxCRUJCZnlFUlFRQU1Bd3NnQnlnQ2NDRVJJQWNvQXNBQkRBSUxJQkVOQkF0QmZ5RVJRWDhoRWtFQUlRWkJBQXNoQ2tFQUN5RUhJQThnRWtZaUN5QVBJQkZHYWtFQlJ3UkFJQWNnQ0NBSFFSQjBRUkIxSWdzZ0NFRVFkRUVRZFNJT1NpSUlHeUlISUE0Z0N5QU9JQXNnRGtnYklBZ2JJZ2dnQ2tFUWRTSUxJQWdnQzBvYklBZEJFSFJCRUhVZ0MwZ2JJUWNnQmlBSklBWkJFSFJCRUhVaUN5QUpRUkIwUVJCMUlnbEtJZ1liSWdoQi8vOERjU0FKSUFzZ0NTQUxJQWxJR3lBR0d5SUdJQXBCRUhSQkVIVWlDU0FHSUFsS0d5QUlRUkIwUVJCMUlBbElHeUVHREFNTElBc05BaUFLUVJCMklRY2dDaUVHREFJTFFRRWhHeUFBUVlRQmFpRWNBMEFDZnlBQklCMUJBblFpSG1vaUlDSWtLQUt3QVNJR1FRSk5CRUFnQmtFQ2RFR2NOV29vQWdBTUFRdEJCQXNoSWlBQUlCNXFJZ1lnSUNnQ3dBRTJBbVFnQmlBQ0lDQW9Bc0FCRUJRaUJqWUNkQ0FHUlEwSUlDSUVRQ0FjSUIxQkJIUWlIMm9pSlNFbUlCd2dIMEVNY21vaUowRUNhaUVvSUJ3Z0gwRUljbW9pS1NFUklCd2dIMEVFY21vaUZpRVRRUUFoQmdOQUlBRWdIMm9nQmtFQ2RHb2lDQzhCMGdFaER5QUlMd0hRQVNFT0lDQW9Bc0FCSVNGQmZ5RVhBbjhnQUNBZFFRZDBJQ1FvQXJBQklpTkJCWFJxSUFaQkEzUnFJaHBCc0JscUtBSUFFQkVpQ1VVRVFFRUFJUXhCQUNFSVFRQWhDa0YvREFFTFFRQWhERUVBSVFoQkFDRUtRWDhnQ1NnQ0JDQUFLQUlFUncwQUdrRUJJUXBCZnlBSktBSUFRUVZMRFFBYUlBa2dHa0cwR1dvdEFBQWlCMEVDZEdvb0FvUUJJZ2hCRUhZaERDQUpJQWRCL0FGeGFpZ0NaQXNoRFFKQUFrQUNRQ0FBSUJwQnNCMXFLQUlBRUJFaUdFVUVRRUVBSVFrTUFRdEJBQ0VKSUJnb0FnUWdBQ2dDQkVZTkFRdEJBQ0VTUVFBaEN3d0JDMEVCSVFzZ0dDZ0NBRUVGU3dSQVFRQWhFZ3dCQ3lBWUlCcEJ0QjFxTFFBQUlnZEJBblJxS0FLRUFTSVNRUkIySVFrZ0dDQUhRZndCY1dvb0FtUWhGd3NDUUFKQUFrQUNRQUpBSUFBZ0drR3dJV29vQWdBUUVTSVpSUTBBSUJrb0FnUWdBQ2dDQkVjTkFDQVpLQUlBUVFWTkRRRU1BZ3NDUUNBQUlCcEJzQ1ZxS0FJQUVCRWlHVVVOQUNBWktBSUVJQUFvQWdSSERRQWdHU2dDQUVFRlN3MENJQmtnR2tHMEpXb3RBQUFpQjBIOEFYRnFLQUprSVJnZ0dTQUhRUUowYWlnQ2hBRWhCd3dEQzBFQUlRZEJmeUVZSUFwRkRRSWdDdzBDREFNTElCa2dHa0cwSVdvdEFBQWlCMEg4QVhGcUtBSmtJUmdnR1NBSFFRSjBhaWdDaEFFaEJ3d0JDMEVBSVFkQmZ5RVlDeUFYSUNGR0lnb2dEU0FoUmlJTGFpQVlJQ0ZHYWtFQlJ3UkFJQWtnRENBSlFSQjBRUkIxSWdzZ0RFRVFkRUVRZFNJTVNpSUpHeUlLSUF3Z0N5QU1JQXNnREVnYklBa2JJZ2tnQjBFUWRTSUxJQWtnQzBvYklBcEJFSFJCRUhVZ0MwZ2JJUXdnRWlBSUlCSkJFSFJCRUhVaUNpQUlRUkIwUVJCMUlndEtJZ2diSWdsQi8vOERjU0FMSUFvZ0N5QUtJQXRJR3lBSUd5SUlJQWRCRUhSQkVIVWlCeUFJSUFkS0d5QUpRUkIwUVJCMUlBZElHeUVJREFFTElBZ2dFaUFMR3lFSUlBd2dDU0FMR3lFTUlBc05BQ0FLRFFBZ0IwRVFkaUVNSUFjaENBc2dDQ0FPYWlJS1FSQjBRUkIxUVlCQWEwSC8vd0JMRFFvZ0RDQVBhaUlKUVJCMFFSQjFRWUFRYWtIL0gwc05DaUFqUVFOTkJFQUNmd0pBQWtBQ1FBSkFJQ05CQVdzT0F3RUNBd0FMSUNVZ0Nqc0JBQ0FtSUFrN0FRSWdGaUFLT3dFQUlCTWdDVHNCQWlBcElBbzdBUUFnRVNBSk93RUNJQ2NnQ2pzQkFDQW9EQU1MSUJ3Z0JrRUJkQ0FlYWtFQ2RDSUhhaUlJSUFrN0FRSWdDQ0FLT3dFQUlCd2dCMEVFY21vaUNDQUtPd0VBSUFoQkFtb01BZ3NnQUNBR0lCNXFRUUowYWlJSUlBbzdBWXdCSUFnZ0NUc0JoZ0VnQ0NBS093R0VBU0FJUVk0QmFnd0JDeUFBSUFZZ0htcEJBblJxSWdnZ0Nqc0JoQUVnQ0VHR0FXb0xJQWs3QVFBTElBWkJBV29pQmlBaVJ3MEFDd3NnSFVFQmFpSWRRUVJIRFFBTFFRQWhEQU5BSUJBZ0FDQU1RUUowSWdKcUtBSjBOZ0lJSUF4QkFVdEJBM1FoQ1NBTVFRTjBRUWh4SVFjQ1FDQUJJQUpxS0FLd0FTSUNRUUpOQkVBQ1FBSkFBa0FnQWtFQmF3NENBUUlBQ3lBRklBQWdERUVFZEdwQmhBRnFJQkJCQ0dvZ0ZTQVVJQWNnQ1VFSVFRZ1FEZ3dEQ3lBRklBQWdERUVFZEdvaUFrR0VBV29nRUVFSWFpQVZJQlFnQnlBSlFRaEJCQkFPSUFVZ0FrR01BV29nRUVFSWFpQVZJQlFnQnlBSlFRUnlRUWhCQkJBT0RBSUxJQVVnQUNBTVFRUjBhaUlDUVlRQmFpQVFRUWhxSUJVZ0ZDQUhJQWxCQkVFSUVBNGdCU0FDUVlnQmFpQVFRUWhxSUJVZ0ZDQUhRUVJ5SUFsQkJFRUlFQTRNQVFzZ0JTQUFJQXhCQkhScUlnaEJoQUZxSUJCQkNHb2dGU0FVSUFjZ0NVRUVRUVFRRGlBRklBaEJpQUZxSUJCQkNHb2dGU0FVSUFkQkJISWlCaUFKUVFSQkJCQU9JQVVnQ0VHTUFXb2dFRUVJYWlBVklCUWdCeUFKUVFSeUlnSkJCRUVFRUE0Z0JTQUlRWkFCYWlBUVFRaHFJQlVnRkNBR0lBSkJCRUVFRUE0TElBeEJBV29pREVFRVJ3MEFDd3dHQ3lBSUlRY2dDU0VHQzBFQklSc2dCaUFNYWlJSVFSQjBRUkIxUVlCQWEwSC8vd0JMRFFVZ0J5QU5haUlHUVJCMFFSQjFRWUFRYWtIL0gwc05CU0FDSUE4UUZDSUhSUTBGSUFBZ0Jqc0JzZ0VnQUNBSU93R3dBU0FBSUFjMkFuUWdBQ0FQTmdKa0lBQWdCellDZkNBQUlBODJBbXdnQUNBQUtBS3dBU0lHTmdLc0FTQUFJQVkyQXFnQklBQWdCallDcEFFZ0FDQUdOZ0tRQVNBQUlBWTJBb3dCSUFBZ0JqWUNpQUVnQUNBR05nS0VBU0FCS0FLVUFTRU9JQUV2QWFZQklRd2dBUzhCcEFFaEN5QUFLQUlFSVFrQ1FBSkFJQUFvQXRBQklnZEZEUUFnQnlnQ0JDQUpSdzBBUVFFaEVTQUhLQUlBUVFWTEJFQkJmeUVJUVFBaEJ3d0NDeUFIS0FKc0lRZ2dCeWdDckFFaEJ3d0JDMEYvSVFoQkFDRUhJQUFvQXN3QklncEZCRUJCQUNFUkRBRUxJQWtnQ2lnQ0JFY0VRRUVBSVJFTUFRdEJBU0VSSUFvb0FnQkJCVXNOQUNBS0tBSnNJUWdnQ2lnQ3NBRWhCd3NDUUNBSUlBNUdSUVJBSUFaQkVIWWhDQUovQWtBQ1FDQUFLQUxNQVNJTlJRMEFJQTBvQWdRZ0NVY05BQ0FOS0FJQVFRVkxEUUVnRFNnQ3ZBRWlFVUVRZGlFS0lBMG9BbkFNQWdzZ0VVVU5Bd3RCQUNFUlFRQWhDa0YvQ3lFTklBNGdEMFlpQ1NBTklBNUdha0VCUndSQUlBb2dDQ0FLUVJCMFFSQjFJZzBnQ0VFUWRFRVFkVW9pQ0JzaUNTQUdRUkIxSWdvZ0RTQUtJQW9nRFVvYklBZ2JJZ2dnQjBFUWRTSUtJQWdnQ2tvYklBbEJFSFJCRUhVZ0NrZ2JJUWdnRVNBR0lCRkJFSFJCRUhVaUNpQUdRUkIwUVJCMUlnMUtJZ1liSWdsQi8vOERjU0FOSUFvZ0RTQU5JQXBLR3lBR0d5SUdJQWRCRUhSQkVIVWlCeUFHSUFkS0d5QUpRUkIwUVJCMUlBZElHeUVHREFJTElBa05BU0FOSUE1R0JFQWdFVUgvL3dOeElBcEJFSFJ5SVFZZ0NpRUlEQUlMQ3lBSFFSQjJJUWdnQnlFR0N5QUdJQXRxSWdkQkVIUkJFSFZCZ0VCclFmLy9BRXNOQlNBSUlBeHFJZ1pCRUhSQkVIVkJnQkJxUWY4ZlN3MEZJQUlnRGhBVUlnSkZEUVVnQUNBR093SENBU0FBSUFjN0FjQUJJQUFnQWpZQ2dBRWdBQ0FDTmdKNElBQWdEallDY0NBQUlBNDJBbWdnQUNBQUtBTEFBU0lHTmdLOEFTQUFJQVkyQXJnQklBQWdCallDdEFFZ0FDQUdOZ0tnQVNBQUlBWTJBcHdCSUFBZ0JqWUNtQUVnQUVHVUFXb2lBaUFHTmdJQUlCQWdBQ2dDZERZQ0NDQUZJQUJCaEFGcUlCQkJDR29nRlNBVVFRQkJBRUVJUVJBUURpQVFJQUFvQW5nMkFnZ2dCU0FDSUJCQkNHb2dGU0FVUVFoQkFFRUlRUkFRRGd3RUMwRUFJUWhCZnlFV0N5QVBJQk5HSWdzZ0V5QVdSbXBCQVVjRVFDQUtJQWNnQ2tFUWRFRVFkU0lMSUFkQkVIUkJFSFVpRGtvaUJ4c2lDaUFPSUFzZ0RpQUxJQTVJR3lBSEd5SUhJQWhCRUhVaUN5QUhJQXRLR3lBS1FSQjBRUkIxSUF0SUd5RUhJQWtnQmlBSlFSQjBRUkIxSWdvZ0JrRVFkRUVRZFNJTFNpSUdHeUlKUWYvL0EzRWdDeUFLSUFzZ0NpQUxTQnNnQmhzaUJpQUlRUkIwUVJCMUlnZ2dCaUFJU2hzZ0NVRVFkRUVRZFNBSVNCc2hCZ3dCQ3lBTERRQWdDRUVRZGlFSElBZ2hCZ3RCQVNFYklBWWdER29pQ0VFUWRFRVFkVUdBUUd0Qi8vOEFTdzBDSUFjZ0RXb2lCa0VRZEVFUWRVR0FFR3BCL3g5TERRSWdBaUFURUJRaUIwVU5BaUFBSUFZN0FhSUJJQUFnQ0RzQm9BRWdBQ0FITmdKMElBQWdFellDWkNBQUlBYzJBbmdnQUNBVE5nSm9JQUFnQUNnQ29BRWlEellDbkFFZ0FDQVBOZ0tZQVNBQUlBODJBcFFCSUFBZ0R6WUNrQUVnQUNBUE5nS01BU0FBSUE4MkFvZ0JJQUFnRHpZQ2hBRWdBU2dDbEFFaERpQUJMd0dtQVNFTklBRXZBYVFCSVF3Q2Z3SkFBa0FDUUNBQUtBTElBU0lHQkVBZ0JpZ0NCQ0FBS0FJRVJnUkFJQVlvQWdCQkJVMEVRQ0FHS0FLNEFTSUxRUkIySVFjZ0JpZ0NjQ0FPUncwRUlBc2hDUXdEQzBGL0lSSkJBQ0VKUVFBaEIwRUFJUXRCQUNFS0lBNUJmMFlOQWd3RUMwRi9JUkpCQUNFSlFRQWhCMEVBSVF0QkFDRUtJQTVCZjBZTkFRd0RDMEYvSVJKQkFDRUpRUUFoQjBFQUlRdEJBQ0VLSUE1QmYwY05BZ3NnQ1VILy93TnhJQWRCRUhSeURBSUxJQVlvQW1naEVpQUdLQUtnQVNFS0lBY2hDUXNnRDBFUWRpRUlJQTRnRTBZaUJpQU9JQkpHYWtFQlJ3UkFJQWdnQ1NBSlFSQjBRUkIxSWdrZ0NFRVFkRUVRZFVnaUJ4c2lDQ0FKSUE5QkVIVWlCaUFKSUFZZ0NVZ2JJQWNiSWdZZ0NrRVFkU0lISUFZZ0Iwb2JJQWhCRUhSQkVIVWdCMGdiSVFjZ0R5QUxJQXRCRUhSQkVIVWlDeUFQUVJCMFFSQjFJZ2xJSWdZYklnaEIvLzhEY1NBTElBa2dDeUFKSUF0SUd5QUdHeUlHSUFwQkVIUkJFSFVpQ1NBR0lBbEtHeUFJUVJCMFFSQjFJQWxJR3d3QkN5QUlJQXBCRUhZZ0Joc2hCeUFQSUFvZ0Joc0xJQXhxSWdoQkVIUkJFSFZCZ0VCclFmLy9BRXNOQWlBSElBMXFJZ1pCRUhSQkVIVkJnQkJxUWY4ZlN3MENJQUlnRGhBVUlnSkZEUUlnQUNBR093SENBU0FBSUFnN0FjQUJJQUFnQWpZQ2dBRWdBQ0FDTmdKOElBQWdEallDY0NBQUlBNDJBbXdnQUNBQUtBTEFBU0lHTmdLOEFTQUFJQVkyQXJnQklBQWdCallDdEFFZ0FDQUdOZ0t3QVNBQUlBWTJBcXdCSUFBZ0JqWUNxQUVnQUVHa0FXb2lBaUFHTmdJQUlCQWdBQ2dDZERZQ0NDQUZJQUJCaEFGcUlCQkJDR29nRlNBVVFRQkJBRUVRUVFnUURpQVFJQUFvQW53MkFnZ2dCU0FDSUJCQkNHb2dGU0FVUVFCQkNFRVFRUWdRRGd3QkN3SkFJQVpGQkVBZ0VrVUVRRUVBSVFrTUFnc2dGa1VFUUVFQUlRa01BZ3NnQ0VILy93TnhJQWRCRUhSeUlBMXlSUVJBUVFBaENRd0NDMEVBSVFrZ0VVSC8vd054SUFwQkVIUnlJQTl5UlEwQkN5QUJMd0dpQVNFTElBRXZBYUFCSVFrQ1FBSkFBa0FDUUFKQUlBQW9BdEFCSWdaRkRRQWdCaWdDQkNBT1J3MEFJQVlvQWdCQkJVME5BUXdDQ3dKQUlBQW9BdFFCSWdaRkRRQWdCaWdDQkNBT1J3MEFJQVlvQWdCQkJVc05BaUFHS0FKd0lSY2dCaWdDd0FFaERBd0RDMEYvSVJjZ0VrVU5BaUFXRFFJTUF3c2dCaWdDYkNFWElBWW9BcXdCSVF3TUFRdEJmeUVYQ3lBUElCTkdJZ1lnRFNBVFJpSU5haUFUSUJkR2FrRUJSd1JBSUFvZ0J5QUtRUkIwUVJCMUlnb2dCMEVRZEVFUWRTSU5TaUlHR3lJSElBMGdDaUFOSUFvZ0RVZ2JJQVliSWdZZ0RFRVFkU0lLSUFZZ0Nrb2JJQWRCRUhSQkVIVWdDa2diSVFjZ0VTQUlJQkZCRUhSQkVIVWlDaUFJUVJCMFFSQjFJZzFLSWdZYklnaEIvLzhEY1NBTklBb2dEU0FLSUExSUd5QUdHeUlHSUF4QkVIUkJFSFVpQ2lBR0lBcEtHeUFJUVJCMFFSQjFJQXBJR3lFSURBRUxJQWdnRVNBTkd5RUlJQWNnQ2lBTkd5RUhJQTBOQUNBR0RRQWdERUVRZGlFSElBd2hDQXRCQVNFYklBZ2dDV29pREVFUWRFRVFkVUdBUUd0Qi8vOEFTdzBDSUFjZ0Myb2lDVUVRZEVFUWRVR0FFR3BCL3g5TERRSUxJQUlnRXhBVUlnSkZCRUJCQVNFYkRBSUxJQUFnQ1RzQndnRWdBQ0FNT3dIQUFTQUFJQUkyQW5RZ0FDQVROZ0prSUFBZ0FqWUNnQUVnQUNBQ05nSjhJQUFnQWpZQ2VDQUFJQk0yQW5BZ0FDQVROZ0pzSUFBZ0V6WUNhQ0FBSUFBb0FzQUJJZ1kyQXJ3QklBQWdCallDdUFFZ0FDQUdOZ0swQVNBQUlBWTJBckFCSUFBZ0JqWUNyQUVnQUNBR05nS29BU0FBSUFZMkFxUUJJQUFnQmpZQ29BRWdBQ0FHTmdLY0FTQUFJQVkyQXBnQklBQWdCallDbEFFZ0FDQUdOZ0tRQVNBQUlBWTJBb3dCSUFBZ0JqWUNpQUVnQUNBR05nS0VBU0FRSUFJMkFnZ2dCU0FBUVlRQmFpQVFRUWhxSUJVZ0ZFRUFRUUJCRUVFUUVBNExRUUFoR3lBQUtBTEVBVUVCU3cwQUlBQW9BZ0FFUUNBRUlBTWdCU0FCUWNnQ2FoQllEQUVMSUFRZ0JSQWJDeUFRUVNCcUpBQWdHd3VUQ3dFUGZ5QUFLQUlBSWhFZ0FTQUJJQUFvQWdRaUNuQWlBV3NpQkVFSWRHb2dBVUVFZEdvaEJTQUtRUVIwSVFzZ0FDZ0NDQ0FLYkNJQVFRWjBJUVlnQVVFRGRDRUpJQUJCQ0hRaERDQUVRUVowSVJJZ0NrRUNkRUg4Ly8vL0EzRkJBblFoRUFOQUlBVWdEa0VDZENJQVFmQXBhaWdDQUNJQklBdHNhaUFBUWJBcGFpZ0NBQ0lBYWlFRUlBSWdBVUVFZEdvZ0FHb2hBQUpBSUFNZ0RrRUdkR29pQVNnQ0FDSUhRZi8vL3dkSEJFQWdBU2dDQkNFSUlBQXRBQUVoRFNBRUlBY2dBQzBBQUdwQnNDNXFMUUFBT2dBQUlBRW9BZ2doQnlBQUxRQUNJUThnQkNBSUlBMXFRYkF1YWkwQUFEb0FBU0FCS0FJTUlRZ2dBQzBBQXlFTklBUWdCeUFQYWtHd0xtb3RBQUE2QUFJZ0JDQUlJQTFxUWJBdWFpMEFBRG9BQXlBQktBSVVJUWNnQUMwQUVTRUlJQVFnQzJvaUJDQUJLQUlRSUFBdEFCQnFRYkF1YWkwQUFEb0FBQ0FCS0FJWUlRMGdBQzBBRWlFUElBUWdCeUFJYWtHd0xtb3RBQUE2QUFFZ0FTZ0NIQ0VISUFBdEFCTWhDQ0FFSUEwZ0QycEJzQzVxTFFBQU9nQUNJQVFnQnlBSWFrR3dMbW90QUFBNkFBTWdBU2dDSkNFSElBQXRBQ0VoQ0NBRUlBdHFJZ1FnQVNnQ0lDQUFMUUFnYWtHd0xtb3RBQUE2QUFBZ0FTZ0NLQ0VOSUFBdEFDSWhEeUFFSUFjZ0NHcEJzQzVxTFFBQU9nQUJJQUVvQWl3aEJ5QUFMUUFqSVFnZ0JDQU5JQTlxUWJBdWFpMEFBRG9BQWlBRUlBY2dDR3BCc0M1cUxRQUFPZ0FESUFFb0FqUWhCeUFBTFFBeElRZ2dCQ0FMYWlJRUlBRW9BakFnQUMwQU1HcEJzQzVxTFFBQU9nQUFJQUVvQWpnaERTQUFMUUF5SVE4Z0JDQUhJQWhxUWJBdWFpMEFBRG9BQVNBQktBSThJUUVnQUMwQU15RUFJQVFnRFNBUGFrR3dMbW90QUFBNkFBSWdCQ0FBSUFGcVFiQXVhaTBBQURvQUF3d0JDeUFBS0FJUUlRRWdCQ0FBS0FJQU5nSUFJQVFnRUdvaUJDQUJOZ0lBSUFBb0FqQWhBU0FFSUJCcUlnUWdBQ2dDSURZQ0FDQUVJQkJxSUFFMkFnQUxJQTVCQVdvaURrRVFSdzBBQ3lBTUlCRnFJQkpxSUFscUloQWdCbW9oRVNBS1FRTjBRZmovLy84SGNTSUxRUUoyUVFKMElRNUJFQ0VLQTBBZ0NrRUNkRUVNY1NJQVFmQXBhaWdDQUNJQklBdHNJQUJCc0NscUtBSUFJZ0JxSUJFZ0VDQUtRUk5MSWdVYmFpRUVJQUpCd0FKQmdBSWdCUnRxSUFGQkEzUWdBR3BxSVFBQ1FDQURJQXBCQm5ScUlnRW9BZ0FpQlVILy8vOEhSd1JBSUFFb0FnUWhCaUFBTFFBQklRa2dCQ0FGSUFBdEFBQnFRYkF1YWkwQUFEb0FBQ0FCS0FJSUlRVWdBQzBBQWlFTUlBUWdCaUFKYWtHd0xtb3RBQUE2QUFFZ0FTZ0NEQ0VHSUFBdEFBTWhDU0FFSUFVZ0RHcEJzQzVxTFFBQU9nQUNJQVFnQmlBSmFrR3dMbW90QUFBNkFBTWdBU2dDRkNFRklBQXRBQWtoQmlBRUlBdHFJZ1FnQVNnQ0VDQUFMUUFJYWtHd0xtb3RBQUE2QUFBZ0FTZ0NHQ0VKSUFBdEFBb2hEQ0FFSUFVZ0JtcEJzQzVxTFFBQU9nQUJJQUVvQWh3aEJTQUFMUUFMSVFZZ0JDQUpJQXhxUWJBdWFpMEFBRG9BQWlBRUlBVWdCbXBCc0M1cUxRQUFPZ0FESUFFb0FpUWhCU0FBTFFBUklRWWdCQ0FMYWlJRUlBRW9BaUFnQUMwQUVHcEJzQzVxTFFBQU9nQUFJQUVvQWlnaENTQUFMUUFTSVF3Z0JDQUZJQVpxUWJBdWFpMEFBRG9BQVNBQktBSXNJUVVnQUMwQUV5RUdJQVFnQ1NBTWFrR3dMbW90QUFBNkFBSWdCQ0FGSUFacVFiQXVhaTBBQURvQUF5QUJLQUkwSVFVZ0FDMEFHU0VHSUFRZ0Myb2lCQ0FCS0FJd0lBQXRBQmhxUWJBdWFpMEFBRG9BQUNBQktBSTRJUWtnQUMwQUdpRU1JQVFnQlNBR2FrR3dMbW90QUFBNkFBRWdBU2dDUENFQklBQXRBQnNoQUNBRUlBa2dER3BCc0M1cUxRQUFPZ0FDSUFRZ0FDQUJha0d3TG1vdEFBQTZBQU1NQVFzZ0FDZ0NDQ0VCSUFRZ0FDZ0NBRFlDQUNBRUlBNXFJZ1FnQVRZQ0FDQUFLQUlZSVFFZ0JDQU9haUlFSUFBb0FoQTJBZ0FnQkNBT2FpQUJOZ0lBQ3lBS1FRRnFJZ3BCR0VjTkFBc0w1Z0VCQjM4Q1FDQUFLQUlBSWdWRkRRQWdBRUVCTmdJOElBQW9BamdOQUNBQUtBSWNJUVpCLy8vLy93Y2hBZ05BQTBBZ0JTQURRU2hzYWlJRUtBSVlCRUFnQkNBQklBUW9BaEFpQkNBQ1NDSUhHeUVCSUFRZ0FpQUhHeUVDQ3lBRFFRRnFJZ01nQmswTkFDQUJSUTBDSUFBb0Fnd2dBQ2dDRUNJRFFRUjBhaUlDSUFFb0FnQTJBZ0FnQWlBQktBSWtOZ0lNSUFJZ0FTZ0NIRFlDQkNBQ0lBRW9BaUEyQWdnZ0FDQURRUUZxTmdJUVFRQWhBeUFCUVFBMkFoZ2dBU2dDRkNFRVFRQWhBVUgvLy8vL0J5RUNJQVFOQUFzZ0FDQUFLQUlzUVg5cU5nSXNEQUFBQ3dBTEM5d0dBUXAvSUFCQ0FEY0NFQUpBQWtBQ1FDQURSUTBBQWtBQ1FDQUJJQUFvQWpBaUEwY0VRQ0FEUVFGcUlBQW9BaUFpQkhBaUNTQUJSZzBCSUFBb0FnQWdBQ2dDSEVFb2JHb29BZ0FoQ3dOQUFrQUNRQ0FBS0FJb0lnY0VRQ0FBS0FJQUlRaEJBQ0VEQTBBZ0NDQURRU2hzYWlJRktBSVVRWDlxUVFGTkJFQWdCU0FGS0FJTUlnVWdCRUVBSUFVZ0NVc2JhellDQ0FzZ0EwRUJhaUlESUFkSERRQUxJQWNnQUNnQ0dFa05Ba0YvSVFWQkFDRURRUUFoQkFOQUlBZ2dBMEVvYkdvaUJpZ0NGRUYvYWtFQlRRUkFJQVlvQWdnaUJpQUVJQVZCZjBZZ0JpQUVTSElpQmhzaEJDQURJQVVnQmhzaEJRc2dBMEVCYWlJRElBZEhEUUFMSUFWQkFFNE5BVUVCRHd0QkFDRUhJQUFvQWhnTkFVRUJEd3NnQ0NBRlFTaHNhaUlEUVFBMkFoUWdBQ0FIUVg5cUlnYzJBaWdnQXlnQ0dBMEFJQUFnQUNnQ0xFRi9hallDTEFzZ0FDZ0NMQ0lGSUFBb0Fod2lDRThFUUNBQUtBSTREUVlnQUNnQ0FDRU1BMEJCQUNFRVFmLy8vLzhISVFaQkFDRURBMEFnRENBRFFTaHNhaUlLS0FJWUJFQWdDaUFFSUFvb0FoQWlDaUFHU0NJTkd5RUVJQW9nQmlBTkd5RUdDeUFEUVFGcUlnTWdDRTBOQUFzQ1FDQUVSUTBBSUFBb0Fnd2dBQ2dDRUNJR1FRUjBhaUlESUFRb0FnQTJBZ0FnQXlBRUtBSWtOZ0lNSUFNZ0JDZ0NIRFlDQkNBRElBUW9BaUEyQWdnZ0FDQUdRUUZxTmdJUUlBUkJBRFlDR0NBRUtBSVVEUUFnQUNBRlFYOXFJZ1UyQWl3TElBVWdDRThOQUFzTElBQW9BZ0FpQkNBSVFTaHNhaUlESUFrMkFnd2dBMEtBZ0lDQUVEY0NFQ0FEUVFBMkFoZ2dBeUFKTmdJSUlBQWdCMEVCYWpZQ0tDQUFJQVZCQVdvMkFpd2dCQ0FJUVFGcUVDY2dDVUVCYWlBQUtBSWdJZ1J3SWdrZ0FVY05BQXNDUUNBQUtBSVFJZ2xGRFFBZ0FDZ0NBQ0lGSUFBb0Fod2lCRUVvYkdvaUNDZ0NBQ0VISUFBb0Fnd2hCa0VBSVFNRFFDQUhJQVlnQTBFRWRHb29BZ0JIQkVBZ0NTQURRUUZxSWdOSERRRU1BZ3NMSUFSRkRRQkJBQ0VEQTBBZ0N5QUZJQU5CS0d4cUlna29BZ0JIQkVBZ0JDQURRUUZxSWdOSERRRU1BZ3NMSUFrZ0J6WUNBQ0FJSUFzMkFnQUxJQUlOQlNBQUtBSXdJUU1NQWdzZ0FrRUFSdzhMSUFJTkF3c2dBU0FEUmcwQUlBQWdBU0FBS0FJZ0lnQnFRWDlxSUFCd05nSXdDMEVBRHdzRFFBd0FBQXNBQ3lBQUlBRTJBakJCQUF0MUFRTi9Ba0FnQUNnQ0FDSUJSUTBBSUFBb0FoeEJmMFlOQUFOQUlBRWdBa0VvYkNJRGFpZ0NCQkFFSUFBb0FnQWlBU0FEYWtFQU5nSUVJQUpCQVdvaUFpQUFLQUljUVFGcVNRMEFDd3NnQVJBRUlBQkJBRFlDQUNBQUtBSUVFQVFnQUVFQU5nSUVJQUFvQWd3UUJDQUFRUUEyQWd3TGd3RUJBMzhDUUNBQUtBSUFJZ1pGRFFBZ0FDZ0NIRUYvUmcwQUEwQWdCaUFIUVNoc0lnaHFLQUlFRUFRZ0FDZ0NBQ0lHSUFocVFRQTJBZ1FnQjBFQmFpSUhJQUFvQWh4QkFXcEpEUUFMQ3lBR0VBUWdBRUVBTmdJQUlBQW9BZ1FRQkNBQVFRQTJBZ1FnQUNnQ0RCQUVJQUJCQURZQ0RDQUFJQUVnQWlBRElBUWdCUkJkQzRBQ0FRSi9JQUFnQlRZQ09DQUFJQVEyQWlBZ0FFTC8vd00zQWlRZ0FFSUFOd0lzSUFBZ0EwRUJJQU5CQVVzYklnTTJBaGdnQUNBRElBSWdCUnNpQWpZQ0hDQUFRYWdGRUFvaUF6WUNBRUgvL3dNaEJBSkFJQU5GRFFCQkFDRUZJQU5CQUVHb0JSQUhJUVlnQWtGL1J3UkFJQUZCZ0FOc1FTOXlJUVZCQUNFREEwQWdCaUFEUVNoc2FpSUhJQVVRQ2lJQk5nSUVJQUZGRFFJZ0J5QUJRUUFnQVd0QkQzRnFOZ0lBSUFNZ0Fra2hBU0FEUVFGcUlRTWdBUTBBQ3lBQ1FRUjBRUkJxSVFVTElBQkJ4QUFRQ2lJQk5nSUVJQUFnQlJBS0lnSTJBZ3dnQWtVTkFDQUJSUTBBUVFBaEJDQUJRUUJCeEFBUUJ4b2dBRUlBTndJUUN5QUVDOU1CQVFkL1FRRWhBUUpBSUFBb0FqZ05BQ0FBS0FJY0lRVWdBQ2dDQUNFR1FmLy8vLzhISVFOQkFDRUJBMEFnQmlBQlFTaHNhaUlFS0FJWUJFQWdCQ0FDSUFRb0FoQWlCQ0FEU0NJSEd5RUNJQVFnQXlBSEd5RURDeUFCUVFGcUlnRWdCVTBOQUFzZ0FrVUVRRUVCRHdzZ0FDZ0NEQ0FBS0FJUUlnTkJCSFJxSWdFZ0FpZ0NBRFlDQUNBQklBSW9BaVEyQWd3Z0FTQUNLQUljTmdJRUlBRWdBaWdDSURZQ0NDQUFJQU5CQVdvMkFoQkJBQ0VCSUFKQkFEWUNHQ0FDS0FJVURRQWdBQ0FBS0FJc1FYOXFOZ0lzQ3lBQkMvVUVBUWgvSUFBb0FpZ2lCQVJBSUFBb0FnQWhCd05BSUFjZ0JVRW9iR29pQmlnQ0ZFRi9ha0VCVFFSQUlBWWdCaWdDRENJSUlBSkxCSDhnQ0NBQUtBSWdhd1VnQ0FzMkFnZ0xJQVZCQVdvaUJTQUVSdzBBQ3d0QkFDRUVBa0FnQVNnQ0FFVU5BQ0FCS0FJRUlnVkJBa3NOQUVFQUlRY2dBaUVHQTBBQ1FBSkFBa0FnQlVFQ1J3UkFJQUVnQjBFTWJHb29BZ2doQkFKQUlBVkZCRUFnQmlBRWF5SUdRWDlLRFFFZ0FDZ0NJQ0FHYWlFR0RBRUxJQVFnQm1vaUJrRUFJQUFvQWlBaUJTQUdJQVZJRzJzaEJnc2dCaUVKSUFZZ0Frc0VRQ0FHSUFBb0FpQnJJUWtMSUFBb0FoZ2lDa1VFUUVFQkR3c2dBQ2dDQUNFSVFRQWhCUU5BSUFnZ0JVRW9iR29pQkNnQ0ZDSUxRWDlxUVFGTkJFQWdCQ2dDQ0NBSlJnMERDMEVCSVFRZ0JVRUJhaUlGSUFwSERRQUxEQVVMUVFFaEJDQUFLQUlZSWdsRkRRUWdBU0FIUVF4c2FpZ0NEQ0VLSUFBb0FnQWhDRUVBSVFVRFFDQUlJQVZCS0d4cUlnUW9BaFJCQTBZRVFDQUVLQUlJSUFwR0RRTUxRUUVoQkNBRlFRRnFJZ1VnQ1VjTkFBc01CQXNnQlVFQVNBUkFRUUVQQzBFQklRUWdDMEVCU3cwQkRBTUxRUUVoQkNBRlFRQklEUUlMSUFjZ0F5SUVTUVJBQTBBZ0FDZ0NCQ0lKSUFSQkFuUnFJQWtnQkVGL2FpSUVRUUowYWlnQ0FEWUNBQ0FFSUFkTERRQUxJQUFvQWdBaENBc2dBQ2dDQkNBSFFRSjBhaUFJSUFWQktHd2lDV28yQWdBZ0IwRUJhaUlISVFRZ0J5SUZJQU5OQkVBRFFDQUFLQUlFSWdnZ0JVRUNkR29vQWdBaUNpQUFLQUlBSUFscVJ3UkFJQWdnQkVFQ2RHb2dDallDQUNBRVFRRnFJUVFMSUFWQkFXb2lCU0FEVFEwQUN3dEJBQ0VFSUFFZ0IwRU1iR29vQWdRaUJVRURTUTBBQ3dzZ0JBc0dBQ0FBRUFRTEJ3QkJ4Qm9RQ2d1NEFnRURmd05BSUFBZ0FrRUNkR29pQVVFVWFpZ0NBQ0lEQkVBZ0F5Z0NLQkFFSUFFb0FoUkJBRFlDS0NBQktBSVVLQUpVRUFRZ0FTZ0NGRUVBTmdKVUlBRW9BaFFRQkNBQlFRQTJBaFFMSUFKQkFXb2lBa0VnUncwQUMwRUFJUUlEUUNBQUlBSkJBblJxSWdGQmxBRnFLQUlBSWdNRVFDQURLQUlVRUFRZ0FTZ0NsQUZCQURZQ0ZDQUJLQUtVQVNnQ0dCQUVJQUVvQXBRQlFRQTJBaGdnQVNnQ2xBRW9BaHdRQkNBQktBS1VBVUVBTmdJY0lBRW9BcFFCS0FJc0VBUWdBU2dDbEFGQkFEWUNMQ0FCS0FLVUFSQUVJQUZCQURZQ2xBRUxJQUpCQVdvaUFrR0FBa2NOQUFzZ0FDZ0NzQm9RQkNBQVFRQTJBckFhSUFBb0Fyd0pFQVFnQUVFQU5nSzhDU0FBS0FLVUNSQUVJQUJCQURZQ2xBa2dBQ2dDdkJvaUFRUkFJQUVRQkNBQVFRQTJBcndhQ3lBQVFjUUphaEJiQzdjQkFRSi9Jd0JCRUdzaUJpUUFJQVpCQURZQ0RDQUFJQUVnQWlBR1FReHFFQ29pQjBGOWNVVUVRQU5BSUFBZ0FTQUdLQUlNSWdkcUlnRWdBaUFIYXlJQ0lBWkJER29RS2lJSFFYMXhSUTBBQ3dzZ0IwRUJSZ1JBSUFRZ0FDZ0NFQ0lCS0FJMFFRUjBOZ0lBSUFVZ0FTZ0NPRUVFZERZQ0FDQURJQUJCeEFscUlnQW9BaFFpQVNBQUtBSVFTUVIvSUFBZ0FVRUJhallDRkNBQUtBSU1JQUZCQkhScUJVRUFDeWdDQURZQ0FBc2dCa0VRYWlRQUlBY0xTUUVCZnlBQVFRQkJ4Qm9RQnlJQ1FiUUtha0VCTmdJQUlBSkNnSUtBZ0lBRU53SUVJQUJCd0JBUUNpSUNOZ0t3R2lBQ1JRUkFRUUVQQ3lBQkJFQWdBRUVCTmdMQUNRdEJBQXU2QkFFSmZ3SkFBa0FnQVVFRVNRMEFJQUF0QUFBTkFDQUFMUUFCRFFBZ0FDMEFBaUlIUVFGTERRQkJBeUVFSUFCQkEyb2hCVUVDSVFoQmZTRU1Ba0FEUUNBRklRWUNmeUFJUVFGcUlBZEIvd0Z4SWdWRkRRQWFRUUFoQnlBRlFRRkdRUUFnQ0VFQlN4c05Ba0VBQ3lFSUlBUkJmM01oRENBR1FRRnFJUVVnQmkwQUFDRUhJQVJCQVdvaUJDQUJSdzBBQ3lBRElBRTJBZ0JCQVE4TElBUWhDa0VBSVFoQkFDRUZBMEJCQVNBSUlBY2dCaTBBQUNJTFJXb2lDVUVDUmhzZ0NDQUxRUU5HR3lFSUlBcEJBV29oQ2dKQUlBdEJBVWNOQUNBSlFRSkpEUUFnQWlBS0lBeHFJQWxCZjNOcUlnRTJBZ3hCQUNBSlFYMXFJZ1lnQmlBSlN4c2hCd3dEQzBFQUlBa2dDeHNoQjBFQklBVWdDVUVDU3hzZ0JTQUxHeUVGSUFaQkFXb2hCaUFCSUFwSERRQUxJQUlnQVNBTWFpQUhheUlCTmdJTURBRUxJQUlnQVRZQ0RFRUJJUWhCQUNFSEN5QUNRUUEyQWhBZ0FrRUFOZ0lJSUFJZ0FDQUVhaUlBTmdJRUlBSWdBRFlDQUNBRElBUWdCMm9nQVdvMkFnQkJBU0VEQWtBZ0JRMEFRUUFoQXlBSVJRMEFJQUlDZnlBQ0tBSU1JZ0ZGQkVBZ0FDRUVRUUFNQVFzZ0FDRUVRUUFoQmdOQUlBRkJmMm9oQVNBRUxRQUFJUVVDZndKQUlBWkJBa2NOQUNBRlFRTkdCRUFnQVVVRVFFRUJEd3NnQkMwQUFVRURTd1JBUVFFUEMwRUFJUVlnQkVFQmFnd0NDeUFGUVFOUERRQkJBUThMSUFBZ0JUb0FBRUVBSUFaQkFXb2dCUnNoQmlBQVFRRnFJUUFnQkVFQmFnc2hCQ0FCRFFBTElBSW9BZ3dMSUFBZ0JHdHFOZ0lNQ3lBREN3TUFBUXNMN1RJWkFFR0dDQXZLQldZZ0poQUdDR1VZWlJoREVFTVFReEJERUVNUVF4QkRFRU1RSWdnaUNDSUlJZ2dpQ0NJSUlnZ2lDQ0lJSWdnaUNDSUlJZ2dpQ0NJSUlnZ0FBQUFBQUFBQUFHcEFTakFxS0FvZ2FUaHBPRWtvU1NncElDa2dDUmdKR0dnd2FEQm9NR2d3U0NCSUlFZ2dTQ0FvR0NnWUtCZ29HQWdRQ0JBSUVBZ1FaeWhuS0djb1p5aG5LR2NvWnlobktFY1lSeGhIR0VjWVJ4aEhHRWNZUnhodVlFNVlMbEFPVUc1WVRsQXVTQTVJRFVBTlFFMUlUVWd0UUMxQURUZ05PRzFRYlZCTlFFMUFMVGd0T0Ewd0RUQnJTR3RJYTBoclNHdElhMGhyU0d0SVN6aExPRXM0U3poTE9FczRTemhMT0Nzd0t6QXJNQ3N3S3pBck1Dc3dLekFMS0Fzb0N5Z0xLQXNvQ3lnTEtBc29BQUFBQUM5b0wyZ1FnRkNBTUlBUWVIQ0FVSGd3ZUJCd2NIaFFjREJ3RUdodmNHOXdUMmhQYUM5Z0wyQVBZQTlnYjJodmFFOWdUMkF2V0M5WUQxZ1BXQUFBQUFBQUFBQUFaamhHSUNZZ0JoQm1NRVlZSmhnR0NHVW9aU2dsRUNVUVpDQmtJR1FnWkNCa0dHUVlaQmhrR0VNUVF4QkRFRU1RUXhCREVFTVFReEFBQUFBQUFBQUFBR2xJU1RncE9Ba3dDQ2dJS0Vnd1NEQW9NQ2d3Q0NBSUlHZEFaMEJuUUdkQVJ5aEhLRWNvUnlnbktDY29KeWduS0FjWUJ4Z0hHQWNZQUFBQUFHMTRiWGh1Z0U2QUxvQU9nQzU0RG5oT2VDNXdUWEJOY0Exd0RYQnRjRzF3VFdoTmFDMW9MV2dOYUExb2JXaHRhRTFnVFdBdFlDMWdEV0FOWUF4WURGZ01XQXhZVEZoTVdFeFlURmdzV0N4WUxGZ3NXQXhRREZBTVVBeFFiR0JzWUd4Z2JHQk1VRXhRVEZCTVVDeFFMRkFzVUN4UURFZ01TQXhJREVocldHdFlhMWhyV0d0WWExaHJXR3RZUzBoTFNFdElTMGhMU0V0SVMwaExTQ3RJSzBnclNDdElLMGdyU0N0SUswZ0xRQXRBQzBBTFFBdEFDMEFMUUF0QWExQnJVR3RRYTFCclVHdFFhMUJyVUV0QVMwQkxRRXRBUzBCTFFFdEFTMEFyUUN0QUswQXJRQ3RBSzBBclFDdEFDemdMT0FzNEN6Z0xPQXM0Q3pnTE9BQkI0QTBMcmdrR0dFWTRKamdHRUdaSVJqQW1NQVlJSlNnbEtFVW9SU2dsSUNVZ1JTQkZJQ1VZSlJobFFHVkFSUmhGR0NVUUpSQmtPR1E0WkRoa09HUXdaREJrTUdRd1pDaGtLR1FvWkNoa0lHUWdaQ0JrSUdRWVpCaGtHR1FZUkJCRUVFUVFSQkFrQ0NRSUpBZ2tDQVFBQkFBRUFBUUFBQUFLZ0dxQVNvQXFnQXA0YW5oS2VDcDRDbkJxY0Vwd0tuQUthQ2xvS1dnSllBbGdTV2hKYUNsZ0tXQUpXQWxZYVdocGFFbGdTV0FwV0NsWUNWQUpVR2hnYUdCb1lHaGdTRmhJV0VoWVNGZ29VQ2hRS0ZBb1VBaElDRWdJU0FoSWFGaG9XR2hZYUZoSVVFaFFTRkJJVUNoSUtFZ29TQ2hJQ0VBSVFBaEFDRUFIT0FjNEJ6Z0hPQWM0QnpnSE9BYzRCekFITUFjd0J6QUhNQWN3QnpBSE1FZElSMGhIU0VkSVIwaEhTRWRJUjBnSEtBY29CeWdIS0Fjb0J5Z0hLQWNvWjFCblVHZFFaMUJuVUdkUVoxQm5VRWRBUjBCSFFFZEFSMEJIUUVkQVIwQW5RQ2RBSjBBblFDZEFKMEFuUUNkQUJ5QUhJQWNnQnlBSElBY2dCeUFISUFZSUpnZ0FBQVlBQmhBbUVFWVFBQUFHR0NZWVJoaG1HQVlnSmlCR0lHWWdCaWdtS0VZb1ppZ0dNQ1l3UmpCbU1BWTRKamhHT0dZNEJrQW1RRVpBWmtBR1NDWklSa2htU0FaUUpsQkdVR1pRQmxnbVdFWllabGdHWUNaZ1JtQm1ZQVpvSm1oR2FHWm9CbkFtY0Vad1puQUdlQ1o0Um5obWVBYUFKb0JHZ0dhQUFBQkRFQUlBQWdBaENDRUlJUWdoQ0djZ1p5QklJQ2dnUnhoSEdDY1lKeGdHSUFZZ0JpQUdJQVlZQmhnR0dBWVlCaEFHRUFZUUJoQm1HR1lZWmhobUdDWVFKaEFtRUNZUUJnZ0dDQVlJQmdnQUFHVlZSRVEwTkNNakl5TVRFeE1UQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUQ1NmRuSXlMaTRwNmVucDVlWGw1ZUdob2FHaG9hR2huWjJkbloyZG5aMjV0Ykd0cVdsbFpXRWhJU0VkSFIwZEdSa1pHUlVWRlJVUTBORFEwTkRRME16TXpNek16TXpNeU1qSXlNakl5TWpFeE1URXhNVEV4TURBd01EQXdNREE5YTJ4Y1dscFpXVmhJU0VoRlJVVkZSRVJFUkVCQVFFQkhOemMzTnpjM056WTJOalkyTmpZMk16TXpNek16TXpNeU1qSXlNakl5TWpFeE1URXhNVEV4UEZ0YVVGbEpSMGREUTBKQ1NEZzRPRFkyTmpZMU5UVTFORFEwTkRFeE1URTdXVnBLU0VoQ1FrRkJRRUJITnpjM05qWTJOalUxTlRVME5EUTBNek16TXpwZ1lWRllTRWhJU1RrNU9UazVPVGszTnpjM056YzNOelkyTmpZMk5qWTJOVFUxTlRVMU5UVTBORFEwTkRRME5ETXpNek16TXpNek1qSXlNakl5TWpJNVlHRlJWMGRIUjBnNE9EZzRPRGc0TmpZMk5qWTJOalkwTkRRME5EUTBORE16TXpNek16TXpNakl5TWpJeU1qSTFKU1VsSlNVbEpTVWxKU1VsSlNVbEtHQmlVbEZCUVVGSE56YzNOemMzTnpZMk5qWTJOalkyTXpNek16TXpNek0xSlNVbEpTVWxKU1VsSlNVbEpTVWxKQ1FrSkNRa0pDUWtKQ1FrSkNRa0pDRmdaMWRTUWtKQ1JUVTFOVFUxTlRVMkppWW1KaVltSmlZbUppWW1KaVltSkNRa0pDUWtKQ1FrSkNRa0pDUWtKQ01qSXlNakl5TWpJeU1qSXlNakl5TWhVRlpHUWpJeU1qVWxKU1VsSlNVbEpDUWtKQ1FrSkNRakl5TWpJeU1qSXlCQlFqSXpNelUxTkJRVUZCUVVGQlFRUVVRME1pSWlJaU1URXhNVEV4TVRFREV6SXlJU0VoSVFJU0lTRVJBU0lTQVFFeUloSUNRek1pSWhJU0FnSlRRek1qRWhJQ0FoTWpRek5qVXdJQ0FFR2dGd3NrQkFRRkJnY0lDUW9NRFE4UkZCWVpIQ0FrS0MweU9EOUhVRnBsY1grUW9yYkw0di8vQUVIZ0Z3c2tBZ0lDQXdNREF3UUVCQVlHQndjSUNBa0pDZ29MQ3d3TURRME9EZzhQRUJBUkVSSVNBRUhGR0F1RUFRRUFBQUVBQUFFQUFBRUFBUUVBQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUlCQVFJQkFRSUJBUUlCQWdNQkFnTUNBZ01DQWdRQ0F3UUNBd1FEQXdVREJBWURCQVlFQlFjRUJRZ0VCZ2tGQndvR0NBc0dDQTBIQ2c0SUN4QUpEQklLRFJRTER4Y05FUmtBQUFBQUFBQUFBQVVBQUFEL0FBQUFBQUFBQVA4QUFBQUFBQUFBL3dCQjFCa0xGUVVBQUFBQUFBQUFCd0FBQVA4QUFBQUFBQUFBL3dCQjlCa0xGUVVBQUFBRUFBQUFBQUFBQVA4QUFBQUFBQUFBL3dCQmxCb0xCUVVBQUFBRUFFR2tHZ3VsQVFjQUFBQUVBQUFBQWdBQUFBUUFBQUFCQUFBQS93QUFBQUFBQUFEL0FBQUFBQUFBQVA4QUFBQUFBQUFBQkFBQUFBRUFBQUFFQUFBQUF3QUFBUDhBQUFBQUFBQUEvd0FBQUFBQUFBQUVBQUFBQVFBQUFBUUFBQUFFQUFBQS93QUFBQUFBQUFEL0FBQUFBQUFBQUFRQUFBQUJBQUFBQkFBQUFBUUFBQUFFQUFBQUF3QUFBQVFBQUFBR0FBQUFBQUFBQUEwQUFBRC9BQUFBQUFBQUFQOEFBQUFBQUFBQS93QkIxQnNMRlEwQUFBQUFBQUFBRHdBQUFQOEFBQUFBQUFBQS93QkI5QnNMRlEwQUFBQUVBQUFBQ0FBQUFQOEFBQUFBQUFBQS93QkJsQndMdFFzTkFBQUFCQUFBQUFnQUFBQUFBQUFBRHdBQUFBUUFBQUFLQUFBQUJBQUFBQWtBQUFEL0FBQUFBQUFBQVA4QUFBQUFBQUFBL3dBQUFBQUFBQUFFQUFBQUNRQUFBQVFBQUFBTEFBQUEvd0FBQUFBQUFBRC9BQUFBQUFBQUFBUUFBQUFKQUFBQUJBQUFBQXdBQUFEL0FBQUFBQUFBQVA4QUFBQUFBQUFBQkFBQUFBa0FBQUFFQUFBQURBQUFBQVFBQUFBTEFBQUFCQUFBQUE0QUFBQUJBQUFBQ2dBQUFQOEFBQUFBQUFBQS93QUFBQUFBQUFEL0FBQUFBQUFBQUFFQUFBQUtBQUFBQkFBQUFBQUFBQUQvQUFBQUFBQUFBUDhBQUFBQUFBQUFBUUFBQUFvQUFBQUJBQUFBQ3dBQUFQOEFBQUFBQUFBQS93QUFBQUFBQUFBQkFBQUFDZ0FBQUFFQUFBQUxBQUFBQkFBQUFBQUFBQUFFQUFBQUFRQUFBQUVBQUFBT0FBQUEvd0FBQUFBQUFBRC9BQUFBQUFBQUFQOEFBQUFBQUFBQUFRQUFBQTRBQUFBRUFBQUFCQUFBQVA4QUFBQUFBQUFBL3dBQUFBQUFBQUFCQUFBQURnQUFBQUVBQUFBUEFBQUEvd0FBQUFBQUFBRC9BQUFBQUFBQUFBRUFBQUFPQUFBQUFRQUFBQThBQUFBRUFBQUFCQUFBQUFRQUFBQUZBQUFBQkFBQUFBSUFBQUQvQUFBQUFBQUFBUDhBQUFBQUFBQUEvd0FBQUFBQUFBQUVBQUFBQWdBQUFBUUFBQUFJQUFBQS93QUFBQUFBQUFEL0FBQUFBQUFBQUFRQUFBQUNBQUFBQkFBQUFBTUFBQUQvQUFBQUFBQUFBUDhBQUFBQUFBQUFCQUFBQUFJQUFBQUVBQUFBQXdBQUFBUUFBQUFJQUFBQUJBQUFBQWtBQUFBRUFBQUFCZ0FBQVA4QUFBQUFBQUFBL3dBQUFBQUFBQUQvQUFBQUFBQUFBQVFBQUFBR0FBQUFCQUFBQUF3QUFBRC9BQUFBQUFBQUFQOEFBQUFBQUFBQUJBQUFBQVlBQUFBRUFBQUFCd0FBQVA4QUFBQUFBQUFBL3dBQUFBQUFBQUFFQUFBQUJnQUFBQVFBQUFBSEFBQUFCQUFBQUF3QUFBQUVBQUFBRFFBQUFBRUFBQUFPQUFBQS93QUFBQUFBQUFEL0FBQUFBQUFBQVA4QUFBQUFBQUFBQVFBQUFBNEFBQUQvQUFBQUJBQUFBUDhBQUFBQUFBQUEvd0FBQUFBQUFBQUJBQUFBQ3dBQUFBRUFBQUFPQUFBQS93QUFBQUFBQUFEL0FBQUFBQUFBQUFFQUFBQUxBQUFBQVFBQUFBNEFBQUFFQUFBQUFRQUFBUDhBQUFBRUFBQUFBZ0FBQUFvQUFBRC9BQUFBQUFBQUFQOEFBQUFBQUFBQS93QUFBQUFBQUFBQ0FBQUFDZ0FBQVA4QUFBQUFBQUFBL3dBQUFBQUFBQUQvQUFBQUFBQUFBQUVBQUFBUEFBQUFBZ0FBQUFvQUFBRC9BQUFBQUFBQUFQOEFBQUFBQUFBQUFRQUFBQThBQUFBQ0FBQUFDZ0FBQUFRQUFBQUZBQUFBL3dBQUFBQUFBQUFFQUFBQUJnQUFBUDhBQUFBQUFBQUEvd0FBQUFBQUFBRC9BQUFBQUFBQUFBUUFBQUFHQUFBQS93QUFBQXdBQUFEL0FBQUFBQUFBQVA4QUFBQUFBQUFBQkFBQUFBTUFBQUFFQUFBQUJnQUFBUDhBQUFBQUFBQUEvd0FBQUFBQUFBQUVBQUFBQXdBQUFBUUFBQUFHQUFBQUJBQUFBQWtBQUFEL0FBQUFEQUFBQVA4QUFBQUNBQUFBL3dBQUFBQUFBQUQvQUFBQUFBQUFBUDhBQUFBQUFBQUEvd0FBQUFJQUFBRC9BQUFBQ0FBQUFQOEFBQUFBQUFBQS93QUFBQUFBQUFBRUFBQUFCd0FBQVA4QUFBQUNBQUFBL3dBQUFBQUFBQUQvQUFBQUFBQUFBQVFBQUFBSEFBQUEvd0FBQUFJQUFBQUVBQUFBRFFBQUFQOEFBQUFJQUFBQUF3QUFBQThBQUFEL0FBQUFBQUFBQVA4QUFBQUFBQUFBL3dBQUFBQUFBQUFEQUFBQUR3QUFBQUFBQUFBRkFBQUEvd0FBQUFBQUFBRC9BQUFBQUFBQUFBTUFBQUFQQUFBQUFRQUFBQW9BQUFEL0FBQUFBQUFBQVA4QUFBQUFBQUFBQXdBQUFBOEFBQUFCQUFBQUNnQUFBQUFBQUFBRkFBQUFCQUFBQUFBQUFBQUJBQUFBQ3dBQUFQOEFBQUFBQUFBQS93QUFBQUFBQUFEL0FBQUFBQUFBQUFFQUFBQUxBQUFBQkFBQUFBRUFBQUQvQUFBQUFBQUFBUDhBQUFBQUFBQUFBUUFBQUFzQUFBQUJBQUFBRGdBQUFQOEFBQUFBQUFBQS93QUFBQUFBQUFBQkFBQUFDd0FBQUFFQUFBQU9BQUFBQkFBQUFBRUFBQUFFQUFBQUJBQUFBQUFBQUFBSEFBQUEvd0FBQUFBQUFBRC9BQUFBQUFBQUFQOEFRZFFuQ3hVSEFBQUFBQUFBQUEwQUFBRC9BQUFBQUFBQUFQOEFRZlFuQ3hVSEFBQUFCQUFBQUFJQUFBRC9BQUFBQUFBQUFQOEFRWlFvQzlrQkJ3QUFBQVFBQUFBQ0FBQUFBQUFBQUEwQUFBQUVBQUFBQ0FBQUFBUUFBQUFEQUFBQS93QUFBQUFBQUFEL0FBQUFBQUFBQVA4QUFBQUFBQUFBQkFBQUFBTUFBQUFFQUFBQUNRQUFBUDhBQUFBQUFBQUEvd0FBQUFBQUFBQUVBQUFBQXdBQUFBUUFBQUFHQUFBQS93QUFBQUFBQUFEL0FBQUFBQUFBQUFRQUFBQURBQUFBQkFBQUFBWUFBQUFFQUFBQUNRQUFBQVFBQUFBTUFBQUFBQUFBQUFRQUFBQUFBQUFBQkFBQUFBZ0FBQUFNQUFBQUNBQUFBQXdBQUFBQUFBQUFCQUFBQUFBQUFBQUVBQUFBQ0FBQUFBd0FBQUFJQUFBQURBQkIrQ2tMQlFRQUFBQUVBRUdJS2dzbEJBQUFBQVFBQUFBSUFBQUFDQUFBQUF3QUFBQU1BQUFBQ0FBQUFBZ0FBQUFNQUFBQURBQkJzUzRMeUFZQkFnTUVCUVlIQ0FrS0N3d05EZzhRRVJJVEZCVVdGeGdaR2hzY0hSNGZJQ0VpSXlRbEppY29LU29yTEMwdUx6QXhNak0wTlRZM09EazZPenc5UGo5QVFVSkRSRVZHUjBoSlNrdE1UVTVQVUZGU1UxUlZWbGRZV1ZwYlhGMWVYMkJoWW1Oa1pXWm5hR2xxYTJ4dGJtOXdjWEp6ZEhWMmQzaDVlbnQ4Zlg1L2dJR0NnNFNGaG9lSWlZcUxqSTJPajVDUmtwT1VsWmFYbUptYW01eWRucCtnb2FLanBLV21wNmlwcXF1c3JhNnZzTEd5czdTMXRyZTR1YnE3dkwyK3Y4REJ3c1BFeGNiSHlNbkt5OHpOenMvUTBkTFQxTlhXMTlqWjJ0dmMzZDdmNE9IaTQrVGw1dWZvNmVycjdPM3U3L0R4OHZQMDlmYjMrUG42Ky96OS92Ly8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy93QUFBQUFCQUFBQUJBQUFBQVVBQUFBQ0FBQUFBd0FBQUFZQUFBQUhBQUFBQ0FBQUFBa0FBQUFNQUFBQURRQUFBQW9BQUFBTEFBQUFEZ0FBQUE4QUFBQUFBQUFBQVFBQUFBRUFRWVExQ3lFQkFBQUFBUUFBQUFFQUFBQUJBQUFBQWdBQUFBSUFBQUFCQUFBQUFnQUFBQUlBUWJRMUN3VUZBQUFBQkFCQnhEVUx5UVlIQUFBQUJBQUFBQUlBQUFBRUFBQUFBUUFBQUFRQUFBQUVBQUFBQkFBQUFBTUFBQUFFQUFBQUJnQUFBQUFBQUFBTkFBQUFCQUFBQUFnQUFBQUFBQUFBRHdBQUFBUUFBQUFLQUFBQUJBQUFBQWtBQUFBRUFBQUFEQUFBQUFRQUFBQUxBQUFBQkFBQUFBNEFBQUFBQUFBQUVRQUFBQVFBQUFBUUFBQUFBQUFBQUJNQUFBQUVBQUFBRWdBQUFBQUFBQUFWQUFBQUJBQUFBQlFBQUFBQUFBQUFGd0FBQUFRQUFBQVdBQUFBQVFBQUFBb0FBQUFCQUFBQUN3QUFBQVFBQUFBQUFBQUFCQUFBQUFFQUFBQUJBQUFBRGdBQUFBRUFBQUFQQUFBQUJBQUFBQVFBQUFBRUFBQUFCUUFBQUFRQUFBQUNBQUFBQkFBQUFBTUFBQUFFQUFBQUNBQUFBQVFBQUFBSkFBQUFCQUFBQUFZQUFBQUVBQUFBQndBQUFBUUFBQUFNQUFBQUJBQUFBQTBBQUFBQkFBQUFFZ0FBQUFFQUFBQVRBQUFBQkFBQUFCQUFBQUFFQUFBQUVRQUFBQUVBQUFBV0FBQUFBUUFBQUJjQUFBQUVBQUFBRkFBQUFBUUFBQUFWQUFBQUFRQUFBQXNBQUFBQkFBQUFEZ0FBQUFRQUFBQUJBQUFBL3dBQUFBUUFBQUFCQUFBQUR3QUFBQUlBQUFBS0FBQUFCQUFBQUFVQUFBRC9BQUFBQUFBQUFBUUFBQUFEQUFBQUJBQUFBQVlBQUFBRUFBQUFDUUFBQVA4QUFBQU1BQUFBQkFBQUFBY0FBQUQvQUFBQUFnQUFBQVFBQUFBTkFBQUEvd0FBQUFnQUFBQUJBQUFBRXdBQUFBSUFBQUFTQUFBQUJBQUFBQkVBQUFEL0FBQUFFQUFBQUFFQUFBQVhBQUFBQWdBQUFCWUFBQUFFQUFBQUZRQUFBUDhBQUFBVUFBQUFBd0FBQUE4QUFBQUJBQUFBQ2dBQUFBQUFBQUFGQUFBQUJBQUFBQUFBQUFBQkFBQUFDd0FBQUFFQUFBQU9BQUFBQkFBQUFBRUFBQUFFQUFBQUJBQUFBQUFBQUFBSEFBQUFCQUFBQUFJQUFBQUFBQUFBRFFBQUFBUUFBQUFJQUFBQUJBQUFBQU1BQUFBRUFBQUFCZ0FBQUFRQUFBQUpBQUFBQkFBQUFBd0FBQUFEQUFBQUV3QUFBQUVBQUFBU0FBQUFBQUFBQUJFQUFBQUVBQUFBRUFBQUFBTUFBQUFYQUFBQUFRQUFBQllBQUFBQUFBQUFGUUFBQUFRQUFBQVVBQUFBQVFBQUFBRUFBQUFDQUFBQUFnQUFBQU1BQUFBREFBQUFBd0FBQUFNQUFBQUFBQUFBQVFBQUFBSUFBQUFEQUFBQUJBQUFBQVVBQUFBR0FBQUFCd0FBQUFnQUFBQUpBQUFBQ2dBQUFBc0FBQUFNQUFBQURRQUFBQTRBQUFBUEFFR1dQQXN1QVFFQkFRRUJBZ0lDQWdJQ0F3TURBd01EQkFRRUJBUUVCUVVGQlFVRkJnWUdCZ1lHQndjSEJ3Y0hDQWdJQ0FCQjBEd0xSUW9BQUFBTkFBQUFFQUFBQUFzQUFBQU9BQUFBRWdBQUFBMEFBQUFRQUFBQUZBQUFBQTRBQUFBU0FBQUFGd0FBQUJBQUFBQVVBQUFBR1FBQUFCSUFBQUFYQUFBQUhRQkJvVDBMTXdFQ0F3UUZBQUVDQXdRRkFBRUNBd1FGQUFFQ0F3UUZBQUVDQXdRRkFBRUNBd1FGQUFFQ0F3UUZBQUVDQXdRRkFBRUNBd0JCNUQwTHpBSUJBQUFBQWdBQUFBTUFBQUFFQUFBQUJRQUFBQVlBQUFBSEFBQUFDQUFBQUFrQUFBQUtBQUFBQ3dBQUFBd0FBQUFOQUFBQURnQUFBQThBQUFBUUFBQUFFUUFBQUJJQUFBQVRBQUFBRkFBQUFCVUFBQUFXQUFBQUZ3QUFBQmdBQUFBWkFBQUFHZ0FBQUJzQUFBQWNBQUFBSFFBQUFCMEFBQUFlQUFBQUh3QUFBQ0FBQUFBZ0FBQUFJUUFBQUNJQUFBQWlBQUFBSXdBQUFDTUFBQUFrQUFBQUpBQUFBQ1VBQUFBbEFBQUFKUUFBQUNZQUFBQW1BQUFBSmdBQUFDY0FBQUFuQUFBQUp3QUFBQ2NBQUFBQkFBQUFBZ0FBQUFRQUFBQUlBQUFBRUFBQUFDQUFBQUJBQUFBQWdBQUFBQzhmRHdBWEd4MGVCd3NORGljckxTNFFBd1VLREJNVkdod2pKU29zQVFJRUNCRVNGQmdHQ1JZWklDRWlKQ2dtS1FBUUFRSUVDQ0FEQlFvTUR5OEhDdzBPQmdrZkl5VXFMQ0VpSkNnbkt5MHVFUklVR0JNVkdod1hHeDBlRmhrbUtRPT1cIn0sRD17fTtmdW5jdGlvbiBvKCl7dmFyIEEsST1FKCkoe2xvY2F0ZUZpbGU6ZnVuY3Rpb24oQSl7cmV0dXJuIGlbQV19fSk7cmV0dXJuKEE9SSxuZXcgUHJvbWlzZSgoZnVuY3Rpb24oSSl7QS5jYWxsZWRSdW4/SSgpOkEub25SdW50aW1lSW5pdGlhbGl6ZWQ9ZnVuY3Rpb24oKXtyZXR1cm4gSSgpfX0pKSkudGhlbigoZnVuY3Rpb24oKXtzZWxmLmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsKGZ1bmN0aW9uKEEpe3ZhciBnPUEuZGF0YSxCPWcucmVuZGVyU3RhdGVJZDtzd2l0Y2goZy50eXBlKXtjYXNlXCJkZWNvZGVcIjp2YXIgQz1EW0JdO0N8fChDPW5ldyBRKEksKGZ1bmN0aW9uKEEsSSxnKXtwb3N0TWVzc2FnZSh7dHlwZTpcInBpY3R1cmVSZWFkeVwiLHdpZHRoOkksaGVpZ2h0OmcscmVuZGVyU3RhdGVJZDpCLGRhdGE6QS5idWZmZXJ9LFtBLmJ1ZmZlcl0pfSkpLERbQl09QyksQy5kZWNvZGUobmV3IFVpbnQ4QXJyYXkoZy5kYXRhLGcub2Zmc2V0LGcubGVuZ3RoKSk7YnJlYWs7Y2FzZVwicmVsZWFzZVwiOnZhciBFPURbQl07RSYmKEUucmVsZWFzZSgpLGRlbGV0ZSBEW0JdKX19KSksc2VsZi5wb3N0TWVzc2FnZSh7dHlwZTpcImRlY29kZXJSZWFkeVwifSl9KSl9fX0sST17fTtmdW5jdGlvbiBnKEIpe3ZhciBRPUlbQl07aWYodm9pZCAwIT09USlyZXR1cm4gUS5leHBvcnRzO3ZhciBDPUlbQl09e2V4cG9ydHM6e319O3JldHVybiBBW0JdKEMsQy5leHBvcnRzLGcpLEMuZXhwb3J0c31nLm49QT0+e3ZhciBJPUEmJkEuX19lc01vZHVsZT8oKT0+QS5kZWZhdWx0OigpPT5BO3JldHVybiBnLmQoSSx7YTpJfSksSX0sZy5kPShBLEkpPT57Zm9yKHZhciBCIGluIEkpZy5vKEksQikmJiFnLm8oQSxCKSYmT2JqZWN0LmRlZmluZVByb3BlcnR5KEEsQix7ZW51bWVyYWJsZTohMCxnZXQ6SVtCXX0pfSxnLm89KEEsSSk9Pk9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChBLEkpLGcucj1BPT57XCJ1bmRlZmluZWRcIiE9dHlwZW9mIFN5bWJvbCYmU3ltYm9sLnRvU3RyaW5nVGFnJiZPYmplY3QuZGVmaW5lUHJvcGVydHkoQSxTeW1ib2wudG9TdHJpbmdUYWcse3ZhbHVlOlwiTW9kdWxlXCJ9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoQSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KX0sKCgpPT57XCJ1c2Ugc3RyaWN0XCI7ZygzNDApLmluaXQoKX0pKCl9KSgpOycsXCJXb3JrZXJcIix2b2lkIDAsdm9pZCAwKX19LDYxNDpBPT57QS5leHBvcnRzPWZ1bmN0aW9uKEEsSSxnLGUpe3ZhciBCPXNlbGZ8fHdpbmRvdzt0cnl7dHJ5e3ZhciBpO3RyeXtpPW5ldyBCLkJsb2IoW0FdKX1jYXRjaChJKXsoaT1uZXcoQi5CbG9iQnVpbGRlcnx8Qi5XZWJLaXRCbG9iQnVpbGRlcnx8Qi5Nb3pCbG9iQnVpbGRlcnx8Qi5NU0Jsb2JCdWlsZGVyKSkuYXBwZW5kKEEpLGk9aS5nZXRCbG9iKCl9dmFyIHQ9Qi5VUkx8fEIud2Via2l0VVJMLFE9dC5jcmVhdGVPYmplY3RVUkwoaSksQz1uZXcgQltJXShRLGcpO3JldHVybiB0LnJldm9rZU9iamVjdFVSTChRKSxDfWNhdGNoKGUpe3JldHVybiBuZXcgQltJXShcImRhdGE6YXBwbGljYXRpb24vamF2YXNjcmlwdCxcIi5jb25jYXQoZW5jb2RlVVJJQ29tcG9uZW50KEEpKSxnKX19Y2F0Y2goQSl7aWYoIWUpdGhyb3cgRXJyb3IoXCJJbmxpbmUgd29ya2VyIGlzIG5vdCBzdXBwb3J0ZWRcIik7cmV0dXJuIG5ldyBCW0ldKGUsZyl9fX19LEk9e307ZnVuY3Rpb24gZyhlKXt2YXIgQj1JW2VdO2lmKHZvaWQgMCE9PUIpcmV0dXJuIEIuZXhwb3J0czt2YXIgaT1JW2VdPXtleHBvcnRzOnt9fTtyZXR1cm4gQVtlXS5jYWxsKGkuZXhwb3J0cyxpLGkuZXhwb3J0cyxnKSxpLmV4cG9ydHN9cmV0dXJuIGcubj1BPT57dmFyIEk9QSYmQS5fX2VzTW9kdWxlPygpPT5BLmRlZmF1bHQ6KCk9PkE7cmV0dXJuIGcuZChJLHthOkl9KSxJfSxnLmQ9KEEsSSk9Pntmb3IodmFyIGUgaW4gSSlnLm8oSSxlKSYmIWcubyhBLGUpJiZPYmplY3QuZGVmaW5lUHJvcGVydHkoQSxlLHtlbnVtZXJhYmxlOiEwLGdldDpJW2VdfSl9LGcubz0oQSxJKT0+T2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKEEsSSksZy5yPUE9PntcInVuZGVmaW5lZFwiIT10eXBlb2YgU3ltYm9sJiZTeW1ib2wudG9TdHJpbmdUYWcmJk9iamVjdC5kZWZpbmVQcm9wZXJ0eShBLFN5bWJvbC50b1N0cmluZ1RhZyx7dmFsdWU6XCJNb2R1bGVcIn0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pfSxnKDExNCl9KSgpfSw1MzpBPT57c2VsZixBLmV4cG9ydHM9KCgpPT57XCJ1c2Ugc3RyaWN0XCI7dmFyIEE9ezExNDpmdW5jdGlvbihBLEksZyl7dmFyIGU9dGhpcyYmdGhpcy5fX2ltcG9ydERlZmF1bHR8fGZ1bmN0aW9uKEEpe3JldHVybiBBJiZBLl9fZXNNb2R1bGU/QTp7ZGVmYXVsdDpBfX07T2JqZWN0LmRlZmluZVByb3BlcnR5KEksXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7Y29uc3QgQj1lKGcoMjg5KSk7SS5kZWZhdWx0PWNsYXNze2luaXRpYWxpemUoKXtyZXR1cm4gbmV3IFByb21pc2UoKChBLEkpPT57dGhpcy53b3JrZXI9bmV3IEIuZGVmYXVsdCx0aGlzLndvcmtlci5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLChJPT57dmFyIGc7Y29uc3QgZT1JLmRhdGE7XCJkZWNvZGVyUmVhZHlcIj09PWUudHlwZT9BKDApOlwiZGVjb2RlRG9uZVwiPT09ZS50eXBlJiYobnVsbD09PShnPXRoaXMub25EZWNvZGUpfHx2b2lkIDA9PT1nfHxnLmNhbGwodGhpcyxlKSl9KSl9KSl9c3RhcnRTdHJlYW0oQSxJLGcpe3RoaXMud29ya2VyJiZ0aGlzLndvcmtlci5wb3N0TWVzc2FnZSh7dHlwZTpcInN0YXJ0U3RyZWFtXCIsc2FtcGxlUmF0ZUh6OkEsY2hhbm5lbENvdW50OkksZGVjb2RlZFNhbXBsZXNQZXJGcmFtZTpnfSl9c3RvcFN0cmVhbSgpe3RoaXMud29ya2VyJiZ0aGlzLndvcmtlci5wb3N0TWVzc2FnZSh7dHlwZTpcInN0b3BTdHJlYW1cIn0pfWRlY29kZShBLEkpe3RoaXMud29ya2VyJiZ0aGlzLndvcmtlci5wb3N0TWVzc2FnZSh7dHlwZTpcImRlY29kZVwiLHN0YXJ0VGltZXN0YW1wOkEsaW5wdXREYXRhOkl9LFtJXSl9cmVsZWFzZSgpe3RoaXMud29ya2VyJiZ0aGlzLndvcmtlci5wb3N0TWVzc2FnZSh7dHlwZTpcInJlbGVhc2VcIn0pfWRpc3Bvc2UoKXt0aGlzLndvcmtlciYmKHRoaXMud29ya2VyLnRlcm1pbmF0ZSgpLHRoaXMud29ya2VyPXZvaWQgMCl9fX0sMjg5OihBLEksZyk9PntnLnIoSSksZy5kKEkse2RlZmF1bHQ6KCk9Pml9KTt2YXIgZT1nKDYxNCksQj1nLm4oZSk7ZnVuY3Rpb24gaSgpe3JldHVybiBCKCkoJygoKT0+e3ZhciBBPXszMDU6QT0+e3ZhciBJLGc9KEk9XCJ1bmRlZmluZWRcIiE9dHlwZW9mIGRvY3VtZW50JiZkb2N1bWVudC5jdXJyZW50U2NyaXB0P2RvY3VtZW50LmN1cnJlbnRTY3JpcHQuc3JjOnZvaWQgMCxmdW5jdGlvbihBKXt2YXIgZyxCOyhBPXZvaWQgMCE9PShBPUF8fHt9KT9BOnt9KS5yZWFkeT1uZXcgUHJvbWlzZSgoZnVuY3Rpb24oQSxJKXtnPUEsQj1JfSkpO3ZhciBRLEM9e307Zm9yKFEgaW4gQSlBLmhhc093blByb3BlcnR5KFEpJiYoQ1tRXT1BW1FdKTt2YXIgRT1bXSxpPVwiLi90aGlzLnByb2dyYW1cIixEPWZ1bmN0aW9uKEEsSSl7dGhyb3cgSX0sbz1cIlwiO1widW5kZWZpbmVkXCIhPXR5cGVvZiBkb2N1bWVudCYmZG9jdW1lbnQuY3VycmVudFNjcmlwdCYmKG89ZG9jdW1lbnQuY3VycmVudFNjcmlwdC5zcmMpLEkmJihvPUkpLG89MCE9PW8uaW5kZXhPZihcImJsb2I6XCIpP28uc3Vic3RyKDAsby5sYXN0SW5kZXhPZihcIi9cIikrMSk6XCJcIjt2YXIgdyxGLEc9QS5wcmludHx8Y29uc29sZS5sb2cuYmluZChjb25zb2xlKSxSPUEucHJpbnRFcnJ8fGNvbnNvbGUud2Fybi5iaW5kKGNvbnNvbGUpO2ZvcihRIGluIEMpQy5oYXNPd25Qcm9wZXJ0eShRKSYmKEFbUV09Q1tRXSk7Qz1udWxsLEEuYXJndW1lbnRzJiYoRT1BLmFyZ3VtZW50cyksQS50aGlzUHJvZ3JhbSYmKGk9QS50aGlzUHJvZ3JhbSksQS5xdWl0JiYoRD1BLnF1aXQpLEEud2FzbUJpbmFyeSYmKHc9QS53YXNtQmluYXJ5KSxBLm5vRXhpdFJ1bnRpbWUmJihGPUEubm9FeGl0UnVudGltZSksXCJvYmplY3RcIiE9dHlwZW9mIFdlYkFzc2VtYmx5JiZuKFwibm8gbmF0aXZlIHdhc20gc3VwcG9ydCBkZXRlY3RlZFwiKTt2YXIgUz0hMTtmdW5jdGlvbiBVKEkpe3ZhciBnLEI9QVtcIl9cIitJXTtyZXR1cm4gZz1cIkNhbm5vdCBjYWxsIHVua25vd24gZnVuY3Rpb24gXCIrSStcIiwgbWFrZSBzdXJlIGl0IGlzIGV4cG9ydGVkXCIsQnx8bihcIkFzc2VydGlvbiBmYWlsZWQ6IFwiK2cpLEJ9ZnVuY3Rpb24gYShBLEksZyxCLFEpe3ZhciBDPXtzdHJpbmc6ZnVuY3Rpb24oQSl7dmFyIEk9MDtpZihudWxsIT1BJiYwIT09QSl7dmFyIGc9MSsoQS5sZW5ndGg8PDIpOyFmdW5jdGlvbihBLEksZyl7SihBLGssSSxnKX0oQSxJPVYoZyksZyl9cmV0dXJuIEl9LGFycmF5OmZ1bmN0aW9uKEEpe3ZhciBJLGcsQj1WKEEubGVuZ3RoKTtyZXR1cm4gST1BLGc9QixzLnNldChJLGcpLEJ9fSxFPVUoQSksaT1bXSxEPTA7aWYoQilmb3IodmFyIG89MDtvPEIubGVuZ3RoO28rKyl7dmFyIHc9Q1tnW29dXTt3PygwPT09RCYmKEQ9WCgpKSxpW29dPXcoQltvXSkpOmlbb109QltvXX12YXIgRj1FLmFwcGx5KG51bGwsaSk7cmV0dXJuIEY9ZnVuY3Rpb24oQSl7cmV0dXJuXCJzdHJpbmdcIj09PUk/SChBKTpcImJvb2xlYW5cIj09PUk/Qm9vbGVhbihBKTpBfShGKSwwIT09RCYmWihEKSxGfXZhciBzLGssaCxOPVwidW5kZWZpbmVkXCIhPXR5cGVvZiBUZXh0RGVjb2Rlcj9uZXcgVGV4dERlY29kZXIoXCJ1dGY4XCIpOnZvaWQgMDtmdW5jdGlvbiB5KEEsSSxnKXtmb3IodmFyIEI9SStnLFE9STtBW1FdJiYhKFE+PUIpOykrK1E7aWYoUS1JPjE2JiZBLnN1YmFycmF5JiZOKXJldHVybiBOLmRlY29kZShBLnN1YmFycmF5KEksUSkpO2Zvcih2YXIgQz1cIlwiO0k8UTspe3ZhciBFPUFbSSsrXTtpZigxMjgmRSl7dmFyIGk9NjMmQVtJKytdO2lmKDE5MiE9KDIyNCZFKSl7dmFyIEQ9NjMmQVtJKytdO2lmKChFPTIyND09KDI0MCZFKT8oMTUmRSk8PDEyfGk8PDZ8RDooNyZFKTw8MTh8aTw8MTJ8RDw8Nnw2MyZBW0krK10pPDY1NTM2KUMrPVN0cmluZy5mcm9tQ2hhckNvZGUoRSk7ZWxzZXt2YXIgbz1FLTY1NTM2O0MrPVN0cmluZy5mcm9tQ2hhckNvZGUoNTUyOTZ8bz4+MTAsNTYzMjB8MTAyMyZvKX19ZWxzZSBDKz1TdHJpbmcuZnJvbUNoYXJDb2RlKCgzMSZFKTw8NnxpKX1lbHNlIEMrPVN0cmluZy5mcm9tQ2hhckNvZGUoRSl9cmV0dXJuIEN9ZnVuY3Rpb24gSChBLEkpe3JldHVybiBBP3koayxBLEkpOlwiXCJ9ZnVuY3Rpb24gSihBLEksZyxCKXtpZighKEI+MCkpcmV0dXJuIDA7Zm9yKHZhciBRPWcsQz1nK0ItMSxFPTA7RTxBLmxlbmd0aDsrK0Upe3ZhciBpPUEuY2hhckNvZGVBdChFKTtpZihpPj01NTI5NiYmaTw9NTczNDMmJihpPTY1NTM2KygoMTAyMyZpKTw8MTApfDEwMjMmQS5jaGFyQ29kZUF0KCsrRSkpLGk8PTEyNyl7aWYoZz49QylicmVhaztJW2crK109aX1lbHNlIGlmKGk8PTIwNDcpe2lmKGcrMT49QylicmVhaztJW2crK109MTkyfGk+PjYsSVtnKytdPTEyOHw2MyZpfWVsc2UgaWYoaTw9NjU1MzUpe2lmKGcrMj49QylicmVhaztJW2crK109MjI0fGk+PjEyLElbZysrXT0xMjh8aT4+NiY2MyxJW2crK109MTI4fDYzJml9ZWxzZXtpZihnKzM+PUMpYnJlYWs7SVtnKytdPTI0MHxpPj4xOCxJW2crK109MTI4fGk+PjEyJjYzLElbZysrXT0xMjh8aT4+NiY2MyxJW2crK109MTI4fDYzJml9fXJldHVybiBJW2ddPTAsZy1RfWZ1bmN0aW9uIEwoQSl7dmFyIEk9ZnVuY3Rpb24oQSl7Zm9yKHZhciBJPTAsZz0wO2c8QS5sZW5ndGg7KytnKXt2YXIgQj1BLmNoYXJDb2RlQXQoZyk7Qj49NTUyOTYmJkI8PTU3MzQzJiYoQj02NTUzNisoKDEwMjMmQik8PDEwKXwxMDIzJkEuY2hhckNvZGVBdCgrK2cpKSxCPD0xMjc/KytJOkkrPUI8PTIwNDc/MjpCPD02NTUzNT8zOjR9cmV0dXJuIEl9KEEpKzEsZz1WKEkpO3JldHVybiBKKEEscyxnLEkpLGd9QS5JTklUSUFMX01FTU9SWTt2YXIgcSxNPVtdLEs9W10sYz1bXSxZPVtdO0sucHVzaCh7ZnVuYzpmdW5jdGlvbigpe2woKX19KTt2YXIgZD0wLFA9bnVsbCx0PW51bGw7ZnVuY3Rpb24gbihJKXtBLm9uQWJvcnQmJkEub25BYm9ydChJKSxSKEkrPVwiXCIpLFM9ITAsST1cImFib3J0KFwiK0krXCIpLiBCdWlsZCB3aXRoIC1zIEFTU0VSVElPTlM9MSBmb3IgbW9yZSBpbmZvLlwiO3ZhciBnPW5ldyBXZWJBc3NlbWJseS5SdW50aW1lRXJyb3IoSSk7dGhyb3cgQihnKSxnfUEucHJlbG9hZGVkSW1hZ2VzPXt9LEEucHJlbG9hZGVkQXVkaW9zPXt9O3ZhciByPVwiZGF0YTphcHBsaWNhdGlvbi9vY3RldC1zdHJlYW07YmFzZTY0LFwiO2Z1bmN0aW9uIGYoQSl7cmV0dXJuIEk9QSxnPXIsU3RyaW5nLnByb3RvdHlwZS5zdGFydHNXaXRoP0kuc3RhcnRzV2l0aChnKTowPT09SS5pbmRleE9mKGcpO3ZhciBJLGd9dmFyIFcsYj1cImRhdGE6YXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtO2Jhc2U2NCxBR0Z6YlFFQUFBQUJoQU1vWUFOL2YzOEJmMkFEZjM5L0FHQUVmMzkvZndCZ0FYOEJmMkFDZjM4QmYyQUZmMzkvZjM4QVlBSi9md0JnQjM5L2YzOS9mMzhBWUFaL2YzOS9mMzhBWUFGL0FHQUVmMzkvZndGL1lBVi9mMzkvZndGL1lBQUFZQWgvZjM5L2YzOS9md0JnQ1g5L2YzOS9mMzkvZndCZ0JuOS9mMzkvZndGL1lBZC9mMzkvZjM5L0FYOWdBbjUvQVg5Z0JIOS9mMzhCZldBQmZBRjhZQUo4ZkFGOFlBdC9mMzkvZjM5L2YzOS9md0JnRFg5L2YzOS9mMzkvZjM5L2YzOEFZQTUvZjM5L2YzOS9mMzkvZjM5L2Z3QmdGSDkvZjM5L2YzOS9mMzkvZjM5L2YzOS9mMzkvQUdBTWYzOS9mMzk5Zlg5L2YzOS9BR0FFZjM5OWZ3QmdBQUYvWUFoL2YzOS9mMzkvZndGL1lBdC9mMzkvZjM5L2YzOS9md0YvWUJCL2YzOS9mMzkvZjM5L2YzOS9mMzkvQVg5Z0MzOS9mMzkvZjM5L2ZYOS9BWDlnQ1g5L2YzOS9mMzk5ZndGL1lBZC9mMzkvZjM5OUFYOWdDWDkvZjM5L2YzMS9md0YvWUFaL2ZIOS9mMzhCZjJBRGZuOS9BWDlnQW54L0FYOWdBMzkrZndGK1lBSjhmd0Y4QWhNREFXRUJZUUFLQVdFQllnQUFBV0VCWXdBREE1OEJuUUVBQUFBRUFBa0VId01EQlFBREFTQU9DeWNEQkFjUEdRSUdEd1FHRXdZQ0ZoVWRCZ01GQlFFQkFnc1VHZ2dBQWd3RkNBRUJFQU1IQkFZQ0FnSUVBZ0lLSEFNQ0FnVUFBQUFCQXdRUUZCTUJCQUVPQVFJU0FnZ0ZBUUFBQWdNQ0dBUVhDQVlCQlFBREJRQUpCUUVDQ0FNQkRRRUJBUUVLQWdrSEJBUUxBQUFFQXdBRENSc1JFU1FFQVFFREJBUW1Bd0FLSlFzaEFDSVNCaDREQncwTUJBVUJjQUVGQlFVR0FRR0FBb0FDQmdrQmZ3RkI0SWZDQWdzSE5nd0JaQUlBQVdVQkFBRm1BRElCWndDZkFRRm9BSUVCQVdrQWVBRnFBSEVCYXdCc0FXd0FZZ0Z0QUlZQkFXNEFoUUVCYndDRUFRa05BUUJCQVFzRWU1RUJrZ0dRQVFxZDdnV2RBWUVDQVFoL0lBQW9BaHdpQXlBQ2RpRUhJQUFvQWlBaEJFRi9JUUlEUUNBRElRVWdCQ0FISUFFZ0FrRUJhaUlDYWkwQUFHd2lBMGtOQUFzZ0FDQUZJQU5ySWdFMkFod2dBQ0FFSUFOcklnZzJBaUFnQVVHQWdJQUVUUVJBSUFBb0FoZ2hCaUFBS0FJb0lRUWdBQ2dDRkNFSklBQW9BZ1FoQ2dOQUlBQWdBVUVJZENJSE5nSWNJQUFnQ1VFSWFpSUpOZ0lVUVFBaEF5QUdJQXBKQkVBZ0FDQUdRUUZxSWdVMkFoZ2dBQ2dDQUNBR2FpMEFBQ0VESUFVaEJnc2dBQ0FETmdJb0lBQWdDRUVJZEVHQS92Ly9CM0VnQXlBRVFRaDBja0VCZGtIL0FYRnlRZjhCY3lJSU5nSWdJQUZCZ1lBQ1NTRUZJQU1oQkNBSElRRWdCUTBBQ3dzZ0FndUNCQUVEZnlBQ1FZQUVUd1JBSUFBZ0FTQUNFQUVhSUFBUEN5QUFJQUpxSVFNQ1FDQUFJQUZ6UVFOeFJRUkFBa0FnQWtFQlNBUkFJQUFoQWd3QkN5QUFRUU54UlFSQUlBQWhBZ3dCQ3lBQUlRSURRQ0FDSUFFdEFBQTZBQUFnQVVFQmFpRUJJQUpCQVdvaUFpQURUdzBCSUFKQkEzRU5BQXNMQWtBZ0EwRjhjU0lFUWNBQVNRMEFJQUlnQkVGQWFpSUZTdzBBQTBBZ0FpQUJLQUlBTmdJQUlBSWdBU2dDQkRZQ0JDQUNJQUVvQWdnMkFnZ2dBaUFCS0FJTU5nSU1JQUlnQVNnQ0VEWUNFQ0FDSUFFb0FoUTJBaFFnQWlBQktBSVlOZ0lZSUFJZ0FTZ0NIRFlDSENBQ0lBRW9BaUEyQWlBZ0FpQUJLQUlrTmdJa0lBSWdBU2dDS0RZQ0tDQUNJQUVvQWl3MkFpd2dBaUFCS0FJd05nSXdJQUlnQVNnQ05EWUNOQ0FDSUFFb0FqZzJBamdnQWlBQktBSThOZ0k4SUFGQlFHc2hBU0FDUVVCcklnSWdCVTBOQUFzTElBSWdCRThOQVFOQUlBSWdBU2dDQURZQ0FDQUJRUVJxSVFFZ0FrRUVhaUlDSUFSSkRRQUxEQUVMSUFOQkJFa0VRQ0FBSVFJTUFRc2dBQ0FEUVFScklnUkxCRUFnQUNFQ0RBRUxJQUFoQWdOQUlBSWdBUzBBQURvQUFDQUNJQUV0QUFFNkFBRWdBaUFCTFFBQ09nQUNJQUlnQVMwQUF6b0FBeUFCUVFScUlRRWdBa0VFYWlJQ0lBUk5EUUFMQ3lBQ0lBTkpCRUFEUUNBQ0lBRXRBQUE2QUFBZ0FVRUJhaUVCSUFKQkFXb2lBaUFEUncwQUN3c2dBQXZ6QWdJQ2Z3RitBa0FnQWtVTkFDQUFJQUpxSWdOQkFXc2dBVG9BQUNBQUlBRTZBQUFnQWtFRFNRMEFJQU5CQW1zZ0FUb0FBQ0FBSUFFNkFBRWdBMEVEYXlBQk9nQUFJQUFnQVRvQUFpQUNRUWRKRFFBZ0EwRUVheUFCT2dBQUlBQWdBVG9BQXlBQ1FRbEpEUUFnQUVFQUlBQnJRUU54SWdScUlnTWdBVUgvQVhGQmdZS0VDR3dpQVRZQ0FDQURJQUlnQkd0QmZIRWlCR29pQWtFRWF5QUJOZ0lBSUFSQkNVa05BQ0FESUFFMkFnZ2dBeUFCTmdJRUlBSkJDR3NnQVRZQ0FDQUNRUXhySUFFMkFnQWdCRUVaU1EwQUlBTWdBVFlDR0NBRElBRTJBaFFnQXlBQk5nSVFJQU1nQVRZQ0RDQUNRUkJySUFFMkFnQWdBa0VVYXlBQk5nSUFJQUpCR0dzZ0FUWUNBQ0FDUVJ4cklBRTJBZ0FnQkNBRFFRUnhRUmh5SWdScklnSkJJRWtOQUNBQnJTSUZRaUNHSUFXRUlRVWdBeUFFYWlFQkEwQWdBU0FGTndNWUlBRWdCVGNERUNBQklBVTNBd2dnQVNBRk53TUFJQUZCSUdvaEFTQUNRU0JySWdKQkgwc05BQXNMSUFBTDZ3RUJDWDhnQUNnQ0lDSUVJQUFvQWh3aUFpQUJkaUlCU1NJR1JRUkFJQUFnQkNBQmF5SUVOZ0lnQ3lBQUlBRWdBaUFCYXlBR0d5SUZOZ0ljSUFWQmdJQ0FCRTBFUUNBQUtBSVlJUU1nQUNnQ0tDRUhJQUFvQWhRaENDQUFLQUlFSVFrRFFDQUFJQVZCQ0hRaUNqWUNIQ0FBSUFoQkNHb2lDRFlDRkVFQUlRRWdBeUFKU1FSQUlBQWdBMEVCYWlJQ05nSVlJQUFvQWdBZ0Eyb3RBQUFoQVNBQ0lRTUxJQUFnQVRZQ0tDQUFJQVJCQ0hSQmdQNy8vd2R4SUFFZ0IwRUlkSEpCQVhaQi93Rnhja0gvQVhNaUJEWUNJQ0FGUVlHQUFra2hBaUFCSVFjZ0NpRUZJQUlOQUFzTElBWUxyd1lCQlg4akFFRVFheUlESkFBZ0F5QUNOZ0lNUVhzaEFnSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FnQVVHN0gyc09GUUVDQ2dvR0NnTUtDZ29LQ2dvS0Nnb0tDZ29IQ0FBTEFrQUNRQUpBQWtBZ0FVR1h6Z0JyRGdvREFnMEFEUUVORFFjSURRc2dBeUFES0FJTUlnRkJCR28yQWd4QmZ5RUNJQUVvQWdBaUFVRUFTQTBNSUFFZ0FDZ0NBQ2dDQ0U0TkRDQUFJQUUyQWhRTUN3c2dBeUFES0FJTUlnRkJCR28yQWd4QmZ5RUNJQUVvQWdBaUFVRUJTQTBMSUFFZ0FDZ0NBQ2dDQ0VvTkN5QUFJQUUyQWhnTUNnc2dBeUFES0FJTUlnRkJCR28yQWd4QmZ5RUNJQUVvQWdBaUFVRUJhMEVCU3cwS0lBQWdBVFlDREF3SkN5QURJQU1vQWd3aUFVRUVhallDRENBQktBSUFJZ0ZGQkVCQmZ5RUNEQW9MSUFFZ0FDZ0NMRFlDQUVFQUlRSWdBRUVBTmdJc0RBa0xJQU1nQXlnQ0RDSUJRUVJxTmdJTUlBRW9BZ0FpQVVVRVFFRi9JUUlNQ1FzZ0FTQUFLQUlFSUFBb0FoQnROZ0lBREFjTElBQW9BZ1FoQmtFQUlRSWdBRUVvYWtFQUlBQW9BZ0FpQkNnQ0NDSUJRUVYwSUFBb0FnZ2lCU0FFS0FJRVFRSjBRZURBQUdwc2FrRTBhaEFGR2lBQlFRRk9CRUFnQVVFRGRDSUVJQUFnQmtHQUVHb2dCV3hCQW5ScUlBVkI0QUJzYW1wQjNBQnFJZ1VnQkdvaEJpQUJRUUYwSWdGQkFTQUJRUUZLR3lFRVFRQWhBUU5BSUFZZ0FVRUNkQ0lIYWtHQWdJQ1BmRFlDQUNBRklBZHFRWUNBZ0k5OE5nSUFJQUZCQVdvaUFTQUVSdzBBQ3dzZ0FFRUJOZ0k0REFjTElBTWdBeWdDRENJQlFRUnFOZ0lNSUFFb0FnQWlBVVVFUUVGL0lRSU1Cd3NnQVNBQUtBSThOZ0lBREFVTElBTWdBeWdDRENJQlFRUnFOZ0lNSUFFb0FnQWlBVVVFUUVGL0lRSU1CZ3NnQVNBQUtBSUFOZ0lBREFRTElBTWdBeWdDRENJQlFRUnFOZ0lNSUFBZ0FTZ0NBRFlDSEF3REN5QURJQU1vQWd3aUFVRUVhallDRENBQktBSUFJZ0ZGQkVCQmZ5RUNEQVFMSUFFZ0FDZ0NLRFlDQUF3Q0N5QURJQU1vQWd3aUFVRUVhallDREVGL0lRSWdBU2dDQUNJQlFRRkxEUUlnQUNBQk5nSWdEQUVMSUFNZ0F5Z0NEQ0lCUVFScU5nSU1JQUVvQWdBaUFVVUVRRUYvSVFJTUFnc2dBU0FBS0FJZ05nSUFDMEVBSVFJTElBTkJFR29rQUNBQ0M0SU5BUWQvQWtBZ0FFVU5BQ0FBUVFocklnTWdBRUVFYXlnQ0FDSUJRWGh4SWdCcUlRVUNRQ0FCUVFGeERRQWdBVUVEY1VVTkFTQURJQU1vQWdBaUFtc2lBMEd3K3dFb0FnQWlCRWtOQVNBQUlBSnFJUUFnQTBHMCt3RW9BZ0JIQkVBZ0FrSC9BVTBFUUNBREtBSUlJZ1FnQWtFRGRpSUNRUU4wUWNqN0FXcEhHaUFFSUFNb0Fnd2lBVVlFUUVHZyt3RkJvUHNCS0FJQVFYNGdBbmR4TmdJQURBTUxJQVFnQVRZQ0RDQUJJQVEyQWdnTUFnc2dBeWdDR0NFR0FrQWdBeUFES0FJTUlnRkhCRUFnQXlnQ0NDSUNJQVJQQkVBZ0FpZ0NEQm9MSUFJZ0FUWUNEQ0FCSUFJMkFnZ01BUXNDUUNBRFFSUnFJZ0lvQWdBaUJBMEFJQU5CRUdvaUFpZ0NBQ0lFRFFCQkFDRUJEQUVMQTBBZ0FpRUhJQVFpQVVFVWFpSUNLQUlBSWdRTkFDQUJRUkJxSVFJZ0FTZ0NFQ0lFRFFBTElBZEJBRFlDQUFzZ0JrVU5BUUpBSUFNZ0F5Z0NIQ0lDUVFKMFFkRDlBV29pQkNnQ0FFWUVRQ0FFSUFFMkFnQWdBUTBCUWFUN0FVR2srd0VvQWdCQmZpQUNkM0UyQWdBTUF3c2dCa0VRUVJRZ0JpZ0NFQ0FEUmh0cUlBRTJBZ0FnQVVVTkFnc2dBU0FHTmdJWUlBTW9BaEFpQWdSQUlBRWdBallDRUNBQ0lBRTJBaGdMSUFNb0FoUWlBa1VOQVNBQklBSTJBaFFnQWlBQk5nSVlEQUVMSUFVb0FnUWlBVUVEY1VFRFJ3MEFRYWo3QVNBQU5nSUFJQVVnQVVGK2NUWUNCQ0FESUFCQkFYSTJBZ1FnQUNBRGFpQUFOZ0lBRHdzZ0F5QUZUdzBBSUFVb0FnUWlBVUVCY1VVTkFBSkFJQUZCQW5GRkJFQWdCVUc0K3dFb0FnQkdCRUJCdVBzQklBTTJBZ0JCclBzQlFhejdBU2dDQUNBQWFpSUFOZ0lBSUFNZ0FFRUJjallDQkNBRFFiVDdBU2dDQUVjTkEwR28rd0ZCQURZQ0FFRzArd0ZCQURZQ0FBOExJQVZCdFBzQktBSUFSZ1JBUWJUN0FTQUROZ0lBUWFqN0FVR28rd0VvQWdBZ0FHb2lBRFlDQUNBRElBQkJBWEkyQWdRZ0FDQURhaUFBTmdJQUR3c2dBVUY0Y1NBQWFpRUFBa0FnQVVIL0FVMEVRQ0FGS0FJTUlRSWdCU2dDQ0NJRUlBRkJBM1lpQVVFRGRFSEkrd0ZxSWdkSEJFQkJzUHNCS0FJQUdnc2dBaUFFUmdSQVFhRDdBVUdnK3dFb0FnQkJmaUFCZDNFMkFnQU1BZ3NnQWlBSFJ3UkFRYkQ3QVNnQ0FCb0xJQVFnQWpZQ0RDQUNJQVEyQWdnTUFRc2dCU2dDR0NFR0FrQWdCU0FGS0FJTUlnRkhCRUFnQlNnQ0NDSUNRYkQ3QVNnQ0FFOEVRQ0FDS0FJTUdnc2dBaUFCTmdJTUlBRWdBallDQ0F3QkN3SkFJQVZCRkdvaUFpZ0NBQ0lFRFFBZ0JVRVFhaUlDS0FJQUlnUU5BRUVBSVFFTUFRc0RRQ0FDSVFjZ0JDSUJRUlJxSWdJb0FnQWlCQTBBSUFGQkVHb2hBaUFCS0FJUUlnUU5BQXNnQjBFQU5nSUFDeUFHUlEwQUFrQWdCU0FGS0FJY0lnSkJBblJCMFAwQmFpSUVLQUlBUmdSQUlBUWdBVFlDQUNBQkRRRkJwUHNCUWFUN0FTZ0NBRUYrSUFKM2NUWUNBQXdDQ3lBR1FSQkJGQ0FHS0FJUUlBVkdHMm9nQVRZQ0FDQUJSUTBCQ3lBQklBWTJBaGdnQlNnQ0VDSUNCRUFnQVNBQ05nSVFJQUlnQVRZQ0dBc2dCU2dDRkNJQ1JRMEFJQUVnQWpZQ0ZDQUNJQUUyQWhnTElBTWdBRUVCY2pZQ0JDQUFJQU5xSUFBMkFnQWdBMEcwK3dFb0FnQkhEUUZCcVBzQklBQTJBZ0FQQ3lBRklBRkJmbkUyQWdRZ0F5QUFRUUZ5TmdJRUlBQWdBMm9nQURZQ0FBc2dBRUgvQVUwRVFDQUFRUU4ySWdGQkEzUkJ5UHNCYWlFQUFuOUJvUHNCS0FJQUlnSkJBU0FCZENJQmNVVUVRRUdnK3dFZ0FTQUNjallDQUNBQURBRUxJQUFvQWdnTElRSWdBQ0FETmdJSUlBSWdBellDRENBRElBQTJBZ3dnQXlBQ05nSUlEd3RCSHlFQ0lBTkNBRGNDRUNBQVFmLy8vd2ROQkVBZ0FFRUlkaUlCSUFGQmdQNC9ha0VRZGtFSWNTSUJkQ0lDSUFKQmdPQWZha0VRZGtFRWNTSUNkQ0lFSUFSQmdJQVBha0VRZGtFQ2NTSUVkRUVQZGlBQklBSnlJQVJ5YXlJQlFRRjBJQUFnQVVFVmFuWkJBWEZ5UVJ4cUlRSUxJQU1nQWpZQ0hDQUNRUUowUWREOUFXb2hBUUpBQWtBQ1FFR2srd0VvQWdBaUJFRUJJQUowSWdkeFJRUkFRYVQ3QVNBRUlBZHlOZ0lBSUFFZ0F6WUNBQ0FESUFFMkFoZ01BUXNnQUVFQVFSa2dBa0VCZG1zZ0FrRWZSaHQwSVFJZ0FTZ0NBQ0VCQTBBZ0FTSUVLQUlFUVhoeElBQkdEUUlnQWtFZGRpRUJJQUpCQVhRaEFpQUVJQUZCQkhGcUlnZEJFR29vQWdBaUFRMEFDeUFISUFNMkFoQWdBeUFFTmdJWUN5QURJQU0yQWd3Z0F5QUROZ0lJREFFTElBUW9BZ2dpQUNBRE5nSU1JQVFnQXpZQ0NDQURRUUEyQWhnZ0F5QUVOZ0lNSUFNZ0FEWUNDQXRCd1BzQlFjRDdBU2dDQUVFQmF5SUFRWDhnQUJzMkFnQUxDNk1CQVFaL0lBQW9BZ3doQXdKQUlBRWdBQ2dDRUNJQ1RRUkFJQUloQkF3QkN5QUFLQUlJSVFVZ0FDZ0NCQ0VHQTBCQkFDRUVJQVVnQmtrRWZ5QUFJQVZCQVdvaUJUWUNDQ0FBS0FJQUlBWWdCV3RxTFFBQUJVRUFDeUFDZENBRGNpRURJQUpCRVVnaEJ5QUNRUWhxSWdRaEFpQUhEUUFMQ3lBQUlBUWdBV3MyQWhBZ0FDQURJQUYyTmdJTUlBQWdBQ2dDRkNBQmFqWUNGQ0FEUVg4Z0FYUkJmM054QzhFUUFnNS9BbjBnQWlBRWJpRVRJQUFvQWdBaEZ3SkFJQUpCQVVZRVFDQUFLQUlnSVFNZ0FDZ0NIQ0VDQWtBZ0Z3UkFJQU5CQjBvRVFDQUNJQUVxQWdCREFBQUFBRjBpRFJBZ0lBQWdBQ2dDSUVFSWF6WUNJQXNnQUNnQ0JFVU5BU0FCUXdBQWdMOURBQUNBUHlBTkd6Z0NBQXdCQ3lBRFFRaE9CRUFnQWtFQkVBa2hEU0FBSUFBb0FpQkJDR3MyQWlBTElBQW9BZ1JGRFFBZ0FVTUFBSUMvUXdBQWdEOGdEUnM0QWdBTFFRRWhDaUFIUlEwQklBY2dBU29DQURnQ0FFRUJEd3NnQUNnQ0dDSVNRUUJLSVFzQ1FDQUZSUVJBSUFVaENRd0JDeUFKUlFSQUlBVWhDUXdCQ3dKQUlCSkJBRW9OQUNBRVFRRktEUUFnRTBFQmNVVWdFa0VBUjNFTkFDQUZJUWtNQVFzZ0NTQUZJQUpCQW5RUUJCb0xJQkpCQUNBTEd5RVFBa0FnRWtFQlNBMEFJQmRGQkVBRFFBSkFJQWxGRFFBZ0RFRWZSZzBBSUFJZ0RIVWlCVUVDU0EwQVFRRWdESFFpRVVFQmRDRU9JQVZCQVhVaUJVRUJJQVZCQVVvYklROUJBQ0VOQTBCQkFDRUZBMEFnQ1NBRklBNXNJQTFxUVFKMGFpSUxJQXNxQWdCRDh3UTFQNVFpR2lBSklBVkJBWFJCQVhJZ0RIUWdEV3BCQW5ScUlnc3FBZ0JEOHdRMVA1UWlHWkk0QWdBZ0N5QWFJQm1UT0FJQUlBVkJBV29pQlNBUFJ3MEFDeUFOUVFGcUlnMGdFVWNOQUFzTElBcEJEM0ZCMERscUxRQUFJQXBCQkhWQjBEbHFMUUFBUVFKMGNpRUtJQXhCQVdvaURDQVFSdzBBREFJTEFBc0RRQUpBSUF4QkgwWWlEZzBBSUFJZ0RIVWlCVUVDU0NJUERRQkJBU0FNZENJVlFRRjBJUllnQlVFQmRTSUZRUUVnQlVFQlNoc2hFVUVBSVEwRFFFRUFJUVVEUUNBQklBVWdGbXdnRFdwQkFuUnFJZ3NnQ3lvQ0FFUHpCRFUvbENJYUlBRWdCVUVCZEVFQmNpQU1kQ0FOYWtFQ2RHb2lDeW9DQUVQekJEVS9sQ0laa2pnQ0FDQUxJQm9nR1pNNEFnQWdCVUVCYWlJRklCRkhEUUFMSUExQkFXb2lEU0FWUncwQUN5QUpSUTBBSUE0TkFDQVBEUUJCQUNFTkEwQkJBQ0VGQTBBZ0NTQUZJQlpzSUExcVFRSjBhaUlMSUFzcUFnQkQ4d1ExUDVRaUdpQUpJQVZCQVhSQkFYSWdESFFnRFdwQkFuUnFJZ3NxQWdCRDh3UTFQNVFpR1pJNEFnQWdDeUFhSUJtVE9BSUFJQVZCQVdvaUJTQVJSdzBBQ3lBTlFRRnFJZzBnRlVjTkFBc0xJQXBCRDNGQjBEbHFMUUFBSUFwQkJIVkIwRGxxTFFBQVFRSjBjaUVLSUF4QkFXb2lEQ0FRUncwQUN3c2dCQ0FRZFNFTUFrQUNRQ0FUSUJCMElnOUJBWEVOQUNBU1FYOUtEUUFnRndSQUlCSWhFUU5BSUE5QkFYVWhEZ0pBSUF4QkFVZ2lGUTBBSUE5QkFrZ2lGZzBBSUF4QkFYUWhHQ0FPUVFFZ0RrRUJTaHNoRTBFQUlRMERRRUVBSVFVRFFDQUJJQVVnR0d3Z0RXcEJBblJxSWdzZ0N5b0NBRVB6QkRVL2xDSWFJQUVnQlVFQmRFRUJjaUFNYkNBTmFrRUNkR29pQ3lvQ0FFUHpCRFUvbENJWmtqZ0NBQ0FMSUJvZ0daTTRBZ0FnQlVFQmFpSUZJQk5IRFFBTElBMUJBV29pRFNBTVJ3MEFDeUFKUlEwQUlCVU5BQ0FXRFFCQkFDRU5BMEJCQUNFRkEwQWdDU0FGSUJoc0lBMXFRUUowYWlJTElBc3FBZ0JEOHdRMVA1UWlHaUFKSUFWQkFYUkJBWElnREd3Z0RXcEJBblJxSWdzcUFnQkQ4d1ExUDVRaUdaSTRBZ0FnQ3lBYUlCbVRPQUlBSUFWQkFXb2lCU0FUUncwQUN5QU5RUUZxSWcwZ0RFY05BQXNMSUJSQkFXb2hGQ0FNUVFGMElRc2dDaUFNZENBS2NpRUtJQTlCQW5FTkF5QVJRWDlJSVFVZ0VVRUJhaUVSSUFzaERDQU9JUThnQlEwQUN3d0NDeUFKUVFCSFFRRnpJUk1nRWlFUkEwQWdEMEVCZFNFT0FrQWdERUVCU0NBVGNnMEFJQTlCQWtnTkFDQU1RUUYwSVJVZ0RrRUJJQTVCQVVvYklSWkJBQ0VOQTBCQkFDRUZBMEFnQ1NBRklCVnNJQTFxUVFKMGFpSUxJQXNxQWdCRDh3UTFQNVFpR2lBSklBVkJBWFJCQVhJZ0RHd2dEV3BCQW5ScUlnc3FBZ0JEOHdRMVA1UWlHWkk0QWdBZ0N5QWFJQm1UT0FJQUlBVkJBV29pQlNBV1J3MEFDeUFOUVFGcUlnMGdERWNOQUFzTElCUkJBV29oRkNBTVFRRjBJUXNnQ2lBTWRDQUtjaUVLSUE5QkFuRU5BaUFSUVg5SUlRVWdFVUVCYWlFUklBc2hEQ0FPSVE4Z0JRMEFDd3dCQ3lBUElRNGdEQ0VMQ3lBRVFRRkdJUVFDUUNBTFFRSklEUUFnRndSQUlBRWdEaUFRZFNBTElCQjBJQVFRUEFzZ0NVVU5BQ0FKSUE0Z0VIVWdDeUFRZENBRUVEd0xJQUFnQVNBQ0lBTWdDeUFKSUFZZ0NDQUtFQkVoQ2lBQUtBSUVSUTBBSUF0QkFrNEVRQ0FCSUE0Z0VIVWdDeUFRZENBRUVHQUxJQlFFUUVFQUlROERRQ0FPUVFGMElRNGdDaUFMSWdCQkFYVWlDM1loQmdKQUlBQkJBa2dOQUNBT1FRSklEUUFnQUVGK2NTRUVJQTVCQVhVaUFFRUJJQUJCQVVvYklRTkJBQ0VKQTBCQkFDRUZBMEFnQVNBRUlBVnNJQWxxUVFKMGFpSUFJQUFxQWdCRDh3UTFQNVFpR1NBQklBVkJBWFJCQVhJZ0Myd2dDV3BCQW5ScUlnQXFBZ0JEOHdRMVA1UWlDSkk0QWdBZ0FDQVpJQWlUT0FJQUlBVkJBV29pQlNBRFJ3MEFDeUFKUVFGcUlna2dDMGNOQUFzTElBWWdDbkloQ2lBUFFRRnFJZzhnRkVjTkFBc0xRUUFoRENBU1FRQktCRUFEUUNBS1FlQTVhaTBBQUNFS0FrQWdERUVmUmcwQUlBSWdESFVpQUVFQ1NBMEFRUUVnREhRaUJrRUJkQ0VFSUFCQkFYVWlBRUVCSUFCQkFVb2JJUU5CQUNFSkEwQkJBQ0VGQTBBZ0FTQUVJQVZzSUFscVFRSjBhaUlBSUFBcUFnQkQ4d1ExUDVRaUdTQUJJQVZCQVhSQkFYSWdESFFnQ1dwQkFuUnFJZ0FxQWdCRDh3UTFQNVFpQ0pJNEFnQWdBQ0FaSUFpVE9BSUFJQVZCQVdvaUJTQURSdzBBQ3lBSlFRRnFJZ2tnQmtjTkFBc0xJQXhCQVdvaURDQVFSdzBBQ3dzZ0N5QVFkQ0VEQWtBZ0IwVU5BQ0FDUVFGSURRQWdBcmVmdGlFSVFRQWhCUU5BSUFjZ0JVRUNkQ0lBYWlBQUlBRnFLZ0lBSUFpVU9BSUFJQVZCQVdvaUJTQUNSdzBBQ3dzZ0NrRi9JQU4wUVg5emNTRUtDeUFLQ3o4QkFYOGdBQ2dDRkVFRGRDQUFLQUljSWdCbklnRkJBM1JxSUFCQkVDQUJhM1lpQUNBQVFReDJJZ0JCQW5SQmdOa0JhaWdDQUV0cklBQnJRZmdCYXd0aEFRSi9Jd0JCRUdzaUFTUUFJQUJCQVd0QkFVMEVRQ0FCUWVqQ0FEWUNEQ0FCSUFFb0FneEJBMnBCZkhFMkFnd2dBU2dDREVHZ1BTZ0NBRUVDZEVIZ3dBQnFJQUJzUWFROUtBSUFRUVYwYW1wQnRBRnFJUUlMSUFGQkVHb2tBQ0FDQzI4QkFYOGpBRUdBQW1zaUJTUUFBa0FnQWlBRFRBMEFJQVJCZ01BRWNRMEFJQVVnQVVIL0FYRWdBaUFEYXlJQ1FZQUNJQUpCZ0FKSklnRWJFQVVhSUFGRkJFQURRQ0FBSUFWQmdBSVFFQ0FDUVlBQ2F5SUNRZjhCU3cwQUN3c2dBQ0FGSUFJUUVBc2dCVUdBQW1va0FBdnBBZ0VCZndKQUlBQWdBVVlOQUNBQklBQnJJQUpyUVFBZ0FrRUJkR3ROQkVBZ0FDQUJJQUlRQkE4TElBQWdBWE5CQTNFaEF3SkFBa0FnQUNBQlNRUkFJQU1FUUNBQUlRTU1Bd3NnQUVFRGNVVUVRQ0FBSVFNTUFnc2dBQ0VEQTBBZ0FrVU5CQ0FESUFFdEFBQTZBQUFnQVVFQmFpRUJJQUpCQVdzaEFpQURRUUZxSWdOQkEzRU5BQXNNQVFzQ1FDQUREUUFnQUNBQ2FrRURjUVJBQTBBZ0FrVU5CU0FBSUFKQkFXc2lBbW9pQXlBQklBSnFMUUFBT2dBQUlBTkJBM0VOQUFzTElBSkJBMDBOQUFOQUlBQWdBa0VFYXlJQ2FpQUJJQUpxS0FJQU5nSUFJQUpCQTBzTkFBc0xJQUpGRFFJRFFDQUFJQUpCQVdzaUFtb2dBU0FDYWkwQUFEb0FBQ0FDRFFBTERBSUxJQUpCQTAwTkFBTkFJQU1nQVNnQ0FEWUNBQ0FCUVFScUlRRWdBMEVFYWlFRElBSkJCR3NpQWtFRFN3MEFDd3NnQWtVTkFBTkFJQU1nQVMwQUFEb0FBQ0FEUVFGcUlRTWdBVUVCYWlFQklBSkJBV3NpQWcwQUN3c2dBQXRWQVFKL1FaRDRBU2dDQUNJQklBQkJBMnBCZkhFaUFtb2hBQUpBSUFKQkFVNUJBQ0FBSUFGTkd3MEFQd0JCRUhRZ0FFa0VRQ0FBRUFKRkRRRUxRWkQ0QVNBQU5nSUFJQUVQQzBHYyt3RkJNRFlDQUVGL0N4Y0FJQUF0QUFCQklIRkZCRUFnQVNBQ0lBQVFqQUVMQzg0TkFndC9BbjBqQUVFZ2F5SU5KQUFnRFNBSU5nSVlJQTBnQXpZQ0hDQUFLQUlJSWdrb0FtUWlDaUFKS0FKZ0lnc2dBQ2dDRENJUElBa29BZ2dnQmtFQmFteHFRUUYwYWk0QkFHb2hEa0YvSVF3Z0FDZ0NIQ0VSSUFBb0FoUWhFaUFBS0FJQUlSTUNRQUpBQWtBQ1FBSkFBbjhnQmtGL1JnUkFJQW9nQ3lBUFFRRjBhaTRCQUdvaUNTMEFBQ0lHSUFaQkFXcEJBWFlpQ2lBRFFRRnJJZ1lnQ1NBS2FpMEFBRW9pQXhzaUN5QUxJQXBCQUNBREd5SUtha0VCYWtFQmRpSURJQVlnQXlBSmFpMEFBRW9pQ3hzaUR5QVBJQU1nQ2lBTEd5SUtha0VCYWtFQmRpSURJQVlnQXlBSmFpMEFBRW9pQ3hzaUR5QVBJQU1nQ2lBTEd5SUtha0VCYWtFQmRpSURJQVlnQXlBSmFpMEFBRW9pQ3hzaUR5QVBJQU1nQ2lBTEd5SUtha0VCYWtFQmRTSURJQVlnQXlBSmFpMEFBRW9pQ3hzaUR5QVBJQU1nQ2lBTEd5SUxha0VCYWtFQmRTSURJQVlnQXlBSmFpMEFBRW9pRHhzaENpQURJQXNnRHhzaUN3UkFJQWtnQzJvdEFBQWhEQXRCQUNBS0lBc2dCaUFNYXlBSklBcHFMUUFBSUFaclNoc2lCa1VOQVJvZ0JpQUphaTBBQUVFQmFpRVFJQVlNQVFzZ0RpMEFBQ0VKSUFKQkEwNEVRQ0FKSUE1cUxRQUFRUXhxSUFOSURRSUxJQWtnQ1VFQmFrRUJkaUlKSUFOQkFXc2lCaUFKSUE1cUxRQUFTaUlER3lJS0lBb2dDVUVBSUFNYklnbHFRUUZxUVFGMklnTWdCaUFESUE1cUxRQUFTaUlLR3lJTElBc2dBeUFKSUFvYklnbHFRUUZxUVFGMklnTWdCaUFESUE1cUxRQUFTaUlLR3lJTElBc2dBeUFKSUFvYklnbHFRUUZxUVFGMklnTWdCaUFESUE1cUxRQUFTaUlLR3lJTElBc2dBeUFKSUFvYklnbHFRUUZxUVFGMUlnTWdCaUFESUE1cUxRQUFTaUlLR3lJTElBc2dBeUFKSUFvYklncHFRUUZxUVFGMUlnTWdCaUFESUE1cUxRQUFTaUlMR3lFSklBTWdDaUFMR3lJS0JFQWdDaUFPYWkwQUFDRU1DMEVBSUFrZ0NpQUdJQXhySUFrZ0Rtb3RBQUFnQm10S0d5SUdSUTBBR2lBR0lBNXFMUUFBUVFGcUlSQWdCZ3NoQXlBQUlBQW9BaUFnRUdzaUNUWUNJQ0FKUVg5TURRRWdBeUVHREFJTElBWkJBV3NoQTBFQklRa2dBU0FDUVFGMklnSkJBblJxSVE0Q1FDQUVRUUZIQkVBZ0FDQU5JQUVnRGlBQ0lBMUJIR29nQkVFQmFrRUJkU0lKSUFRZ0EwRUFJQTFCR0dvUUl3d0JDeUFOSUFoQkFYRWdDRUVCZEhJMkFoZ2dBQ0FOSUFFZ0RpQUNJQTFCSEdwQkFVRUJJQU5CQUNBTlFSaHFFQ01MSUEwb0FoQWhDQ0FOS0FJSXNpRVVJQTBvQWdTeUlSVWdEU2dDRkNFUUlBMG9BZ3doREFKQUlBUkJBa2dOQUNBSVFmLy9BSEZGRFFBZ0NFR0J3QUJPQkVBZ0RDQU1RUVVnQm10MWF5RU1EQUVMSUF3Z0FrRURkRUVHSUFacmRXb2lCa0VmZFNBR2NTRU1DeUFVUXdBQUFEaVVJUlFnRlVNQUFBQTRsQ0VWSUEwb0Fod2hCaUFBSUFBb0FpQWdFR3NpRURZQ0lDQUZJQUpCQW5ScVFRQWdCUnNoRVNBR0lBWWdER3RCQW0waURDQUdJQXhJR3lJTVFRQWdERUVBU2hzaURDQUdJQXhySWdaT0JFQWdBQ0FCSUFJZ0RDQUpJQVVnQXlBVklBZVVJQTBvQWhnaUFSQVJJQUFnRGlBQ0lBQW9BaUFnRUdzZ0RHb2lBRUVZYTBFQUlBQkJHRW9iUVFBZ0NCc2dCbW9nQ1NBUklBTWdGQ0FIbENBQklBbDFFQkVnQkVFQmRYUnlJUWtNQkFzZ0FDQU9JQUlnQmlBSklCRWdBeUFVSUFlVUlBMG9BaGdpRGlBSmRSQVJJUkVnQUNBQklBSWdBQ2dDSUNBUWF5QUdhaUlBUVJoclFRQWdBRUVZU2h0QkFDQUlRWUNBQVVjYklBeHFJQWtnQlNBRElCVWdCNVFnRGhBUklCRWdCRUVCZFhSeUlRa01Bd3NnQTBFQlNBUkFJQU1oQmd3QkN3TkFJQUFnQ1NBUWFpSUpOZ0lnSUFOQkFXc2lCa1VFUUNBQUlBazJBaUFNQXdzZ0FDQUpJQVlnRG1vdEFBQkJBV29pRUdzaUNUWUNJQ0FKUVg5S0RRRWdBMEVCU2lFTUlBWWhBeUFNRFFBTEN5QUdSUTBBSUFaQkNFNEVRQ0FHUVFkeFFRaHlJQVpCQTNaQkFXdDBJUVlMSUJNRVFDQUJJQUlnQmlBU0lBUWdFU0FISUFBb0FnUWdBQ2dDTEJDWUFTRUpEQUlMSUFFZ0FpQUdJQklnQkNBUklBY1FsZ0VoQ1F3QkN5QUFLQUlFUlFSQVFRQWhDUXdCQ3lBTlFYOGdCSFJCZjNNaUNTQUljU0lFTmdJWUlBUkZCRUJCQUNFSklBRkJBQ0FDUVFKMEVBVWFEQUVMQWtBZ0JRUkFJQUpCQVU0RVFDQUFLQUlvSVFOQkFDRUdBMEFnQVNBR1FRSjBJZ2hxSUFVZ0NHb3FBZ0JEQUFDQU8wTUFBSUM3SUFOQmpjemxBR3hCMythNzR3TnFJZ05CZ0lBQ2NSdVNPQUlBSUFaQkFXb2lCaUFDUncwQUN5QUFJQU0yQWlnTElBUWhDUXdCQ3lBQ1FRRklEUUFnQUNnQ0tDRURRUUFoQmdOQUlBRWdCa0VDZEdvZ0EwR056T1VBYkVIZjVydmpBMm9pQTBFVWRiSTRBZ0FnQmtFQmFpSUdJQUpIRFFBTElBQWdBellDS0FzZ0FTQUNJQWNnQUNnQ0xCQXVDeUFOUVNCcUpBQWdDUXVyQWdJRmZ3RjlJQUFvQWl3Z0Jtd2hDaUFBS0FJZ0lnc2dCVUVCZEdvdUFRQWdCbXdoQUNBSFFRRkhCRUFnQUNBS0lBZHRJZ2NnQUNBSFNCc2hBQXRCQUNBRklBZ2JJUXdnQzBFQUlBUWdDQnNpQkVFQmRHb3VBUUFpRFNBR2JDSUpRUUowSVFjZ0FpRUZJQWxCQVU0RVFDQUNRUUFnQnhBRklBZHFJUVVMUVFBZ0FDQUlHeUVKSUFRZ0RFZ0VRQ0FCSUFkcUlRZ0RRQ0FESUFSQkFuUWlBR29xQWdBZ0FFSEEyUUZxS2dJQWtrTUFBQUJDbHJ0RTd6bjYva0l1NWoraUVCKzJJUTRnQmlBTmJDRUFJQXNnQkVFQmFpSUVRUUYwYWk0QkFDSU5JQVpzSVFFRFFDQUZJQWdxQWdBZ0RwUTRBZ0FnQlVFRWFpRUZJQWhCQkdvaENDQUFRUUZxSWdBZ0FVZ05BQXNnQkNBTVJ3MEFDd3NnQWlBSlFRSjBha0VBSUFvZ0NXdEJBblFRQlJvTGd4Z0RGMzhCZlFGOEl3QkJ3QUZySWdZa0FDQUdRUUEyQW9nQlFYNGhCUUpBSUFBb0Fnd2lGVUV5YlNJUFFRTjFJaEFnQkVvTkFDQUFLQUlBSVJvZ0FDZ0NCQ0VJSUE5QkFuVWhEQ0FQUVFGMUlRc2dCQ0FWUVJsdFFRTnNJZ1VnQkNBRlNCc2hCUUpBQW44Q1FBSkFBa0FnQmdKL0FrQUNRQUpBQWtBQ1FBSkFBa0FnQWtFQlRBUkFJQVVnQUNnQ1FDSUJJQUVnQlVvYklRVU1BUXNnQVEwQkN5QUFLQUk4SWdSRkJFQWdBQ2dDQ0NBRmJDSUFRUUZJRFEwZ0EwRUFJQUJCQW5RUUJSb01EUXNnQlNBUFNnUkFJQVVoQkFOQUlBQkJBRUVBSUFNZ0JDQVBJQVFnRDBnYkVCTWlBVUVBU0FSQUlBRWhCUXdQQ3lBRElBQW9BZ2dnQVd4QkFuUnFJUU1nQkNBQmF5SUVRUUJLRFFBTERBMExJQVVnRDA0TkFVRUJJUkVnQlNBTFNnUkFJQXNoQ1F3RUN5QUVRZWdIUmdSQVFRQWhBVUhvQnlFRUlBVWhDUXdHQ3lBTUlBVWdCU0FMU0JzZ0JTQUZJQXhLR3lFSkRBTUxJQUFvQWpRaEZDQUFLQUk0SVFRZ0FDZ0NRQ0VKSUFaQmtBRnFJQUVnQWhCVFFRRWhEU0FBS0FJOElncEJBVWdFUUVFQklSRU1CQXNDUUFKQUFrQWdDa0hxQjBZTkFDQUVRZW9IUncwQUlBQW9Ba1JGRFFFTElBUkI2Z2RHQkVCQjZnY2hCRUVCSVJFTUJnc2dDa0hxQjBZTkFVRUJJUkVNQlFzZ0JFSHFCMFlOQWdzZ0FDZ0NDQ0FNYkNFUlFRRWhGd3dEQ3lBRVFlb0hSd1JBUVFFaEVVRUFJUUVnQlNFSkRBUUxJQVpCRUdzaUN5SVlKQUJCQVNFUklBVWhDVUVBSVFGQkFTRVNEQVVMSUFZZ0FDZ0NDQ0FNYkVFQ2RFRVBha0Z3Y1dzaUNpSUVKQUFnQUVFQVFRQWdDaUFNSUFrZ0NTQU1TaHNRRXhvZ0JTQUpTQ0VMUVg4aEJTQUxEUWdnQkVFUWF5SUxJaGdrQUVFQklSZEJBU0VSUVFFaEVnd0VDMEVBSVFFTElBVWdDVWdoQ2tGL0lRVWdDZzBHUWVvSElSTkJBU0VTUVFFZ0JFSHFCMFlOQVJvTFFRQWhFaUFFSVJNZ0FDZ0NDQ0FMSUFrZ0NTQUxTQnRzQzBFQmRFRVBha0Z3Y1dzaUN5SVlKQUJCQUNFS0lCTkI2Z2RISWc0TkFRdEI2Z2NoRTBFQUlRNE1BUXNnQUNBSWFpRUtJQUFvQWp4QjZnZEdCRUFnQ2hCRUdnc2dBQ0FKUWVnSGJDQUFLQUlNYlNJRVFRb2dCRUVLU2hzMkFpQWdEUVJBSUFBZ0FDZ0NNRFlDRkVHQS9RQWhCQUpBSUJOQjZBZEhEUUFnRkVITkNHc2lCVUVDU3cwQUlBVkJvQjlzUWNBK2FpRUVDeUFBSUFRMkFod0xJQUJCRUdvaEZrRUFJUVFDUUNBQlJTSVpSUVJBSUFzaEJRTkFJQW9nRmtFQUlBUkZJQVpCa0FGcUlBVWdCa0dNQVdvZ0FDZ0NMQkJEQkVCQmZTRUZEQVlMSUFVZ0JpZ0NqQUVpQ0NBQUtBSUliRUVCZEdvaEJTQUVJQWhxSWdRZ0NVZ05BQXNNQVFzZ0N5RUZBMEFDUUNBS0lCWWdHU0FFUlNBR1FaQUJhaUFGSUFaQmpBRnFJQUFvQWl3UVEwVUVRQ0FHS0FLTUFTSUlJQUFvQWdoc0lRY01BUXNnQmlBSk5nS01BU0FBS0FJSUlBbHNJZ2RCQVU0RVFDQUZRUUFnQjBFQmRCQUZHZ3NnQ1NFSUN5QUZJQWRCQVhScUlRVWdCQ0FJYWlJRUlBbElEUUFMQzBFQUlRcEJFU0VaSUExQkFYRkZEUUFnQmlnQ3BBRWdCaWdDckFGbmFrRVVRUUFnQUNnQ09FSHBCMFliYWtFUGF5QUNRUU4wU2cwQUFrQWdFMEhwQjBZRVFDQUdRWkFCYWtFTUVBWWlDRVVFUUVIcEJ5RVREQU1MSUFaQmtBRnFRUUVRQmlFSElBWkJrQUZxUVlBQ0VCWkJBbW9oQkNBR0tBS3NBV2NoQlNBR0tBS2tBU0VOREFFTFFRRWhDQ0FHUVpBQmFrRUJFQVloQnlBQ0lBWW9BcVFCSWcwZ0JpZ0NyQUZuSWdWcVFSbHJRUU4xYXlFRUN5QUdJQVlvQXBRQlFRQWdCQ0FGSUExcVFTQnJJQUlnQkdzaUFrRURkRW9pQkJzaURXczJBcFFCUVFBZ0FpQUVHeUVDUVFBZ0NDQUVHd3dCQzBFQUlRMUJBQ0VIUVFBTEloWkZJaHNnRjNFaEZ5QVlRUUVnRVNBV0cwRUNkRUVQYWtGd2NXc2lCQ0lJSkFBQ1FDQU9SUTBBSUJkRkRRQWdBRUVBUVFBZ0JDQU1JQWtnQ1NBTVNoc1FFeG9nQkNFS0N5QUFJQnBxSVFRQ1FBSkFBa0FDUUFKQUFrQWdGRUhOQ0dzT0JBQUJBUUlEQzBFTklRVU1Bd3RCRVNFRkRBSUxRUk1oQlF3QkMwRVZJUVVnRkVVTkFRc2dCaUFGTmdLQUFVRjlJUVVnQkVHY3pnQWdCa0dBQVdvUUJ3MEJDeUFHSUFBb0FqQTJBbkJCZlNFRklBUkJtTTRBSUFaQjhBQnFFQWNOQUFKL0lCWkZCRUJCQUNFT0lBaEJFR3NpQ0NRQUlBZEJBRWNNQVFzZ0NDQUFLQUlJSUF4c1FRSjBRUTlxUVhCeGF5SUlKQUFnQjBVRVFFRUFJUTVCQUF3QkN5QUdRUUEyQW1BZ0JFR2F6Z0FnQmtIZ0FHb1FCdzBCSUFRZ0FTQUNhaUFOSUFnZ0RFRUFFQmdhSUFZZ0JrR0lBV28yQWxBZ0JFRy9IeUFHUWRBQWFoQUhEUUZCQVNFT1FRRUxJUkVnQmlBWk5nSkFJQVJCbXM0QUlBWkJRR3NRQncwQUFuOGdFMEhvQjBjRVFBSkFJQk1nQUNnQ1BDSUhSZzBBSUFkQkFVZ05BQ0FBS0FKRURRQWdCRUc4SDBFQUVBY05Bd3NnQkNBQklBSWdBeUFQSUFrZ0NTQVBTaHNnQmtHUUFXb1FHQXdCQ3lBR1FmLy9BenNCaEFFZ0FDZ0NDQ0FKYkNJSFFRRk9CRUFnQTBFQUlBZEJBblFRQlJvTEFrQWdBQ2dDUEVIcEIwY05BQ0FPQkVBZ0FDZ0NSQTBCQ3lBR1FRQTJBakFnQkVHYXpnQWdCa0V3YWhBSERRSWdCQ0FHUVlRQmFrRUNJQU1nRUVFQUVCZ2FDMEVBQ3lFUEFrQWdFZzBBSUFBb0FnZ2dDV3dpRWtFQlNBMEFRUUFoQndOQUlBTWdCMEVDZEdvaUZDQVVLZ0lBSUFzZ0IwRUJkR291QVFDeVF3QUFBRGlVa2pnQ0FDQUhRUUZxSWdjZ0VrY05BQXNMSUFZZ0JrR0VBV28yQWlBZ0JFR2Z6Z0FnQmtFZ2FoQUhEUUFnQmlnQ2hBRW9BandoQ3dKQUlCRWdHM0lOQUNBRVFid2ZRUUFRQncwQklBWkJBRFlDRUNBRVFack9BQ0FHUVJCcUVBY05BVUVBSVFjZ0JDQUJJQUpxSUEwZ0NDQU1RUUFRR0JvZ0JpQUdRWWdCYWpZQ0FDQUVRYjhmSUFZUUJ3MEJRWUQzQWlBQUtBSU1iU0VGSUJWQmtBTklEUUFnQUNnQ0NDSUJRUUZJRFFBZ0NDQUJJQkJzUVFKMGFpRU5JQU1nQVNBSklCQnJiRUVDZEdvaEVnTkFRUUFoQkFOQUlCSWdBU0FFYkNBSGFrRUNkQ0lVYWlJWUlBc2dCQ0FGYkVFQ2RHb3FBZ0FpSENBY2xDSWNJQTBnRkdvcUFnQ1VRd0FBZ0Q4Z0hKTWdHQ29DQUpTU09BSUFJQVJCQVdvaUJDQVFSdzBBQ3lBSFFRRnFJZ2NnQVVjTkFBc0xBa0FnRGtVTkFBSkFJQUFvQWdnaUJVRUJTQTBBSUJWQmtBTklEUUFnQlVFQklBVkJBVW9iSVFjZ0VFRUJJQkJCQVVvYklRNUJBQ0VCQTBCQkFDRUVBMEFnQXlBRUlBVnNJQUZxUVFKMElnMXFJQWdnRFdvcUFnQTRBZ0FnQkVFQmFpSUVJQTVIRFFBTElBRkJBV29pQVNBSFJ3MEFDd3RCZ1BjQ0lBQW9BZ3h0SVFjZ0ZVR1FBMGdOQUNBRlFRRklEUUFnQXlBRklCQnNRUUowSWdGcUlRNGdBU0FJYWlFSVFRQWhBUU5BUVFBaEJBTkFJQTRnQkNBRmJDQUJha0VDZENJTmFpSVNJQXNnQkNBSGJFRUNkR29xQWdBaUhDQWNsQ0ljSUJJcUFnQ1VRd0FBZ0Q4Z0hKTWdDQ0FOYWlvQ0FKU1NPQUlBSUFSQkFXb2lCQ0FRUncwQUN5QUJRUUZxSWdFZ0JVY05BQXNMQWtBZ0YwVU5BQ0FBS0FJSUlRVWdDU0FNVGdSQUlBVWdFR3dpQVVFQlRnUkFRUUFoQkFOQUlBTWdCRUVDZENJSWFpQUlJQXBxS2dJQU9BSUFJQVJCQVdvaUJDQUJSdzBBQ3d0QmdQY0NJQUFvQWd4dElRZ2dGVUdRQTBnTkFTQUZRUUZJRFFFZ0F5QUJRUUowSWdGcUlRY2dBU0FLYWlFQlFRQWhDZ05BUVFBaEJBTkFJQWNnQkNBRmJDQUtha0VDZENJTWFpSU9JQXNnQkNBSWJFRUNkR29xQWdBaUhDQWNsQ0ljSUE0cUFnQ1VRd0FBZ0Q4Z0hKTWdBU0FNYWlvQ0FKU1NPQUlBSUFSQkFXb2lCQ0FRUncwQUN5QUtRUUZxSWdvZ0JVY05BQXNNQVF0QmdQY0NJQUFvQWd4dElRZ2dGVUdRQTBnTkFDQUZRUUZJRFFCQkFDRUJBMEJCQUNFRUEwQWdBeUFFSUFWc0lBRnFRUUowSWdkcUlnd2dDeUFFSUFoc1FRSjBhaW9DQUNJY0lCeVVJaHdnRENvQ0FKUkRBQUNBUHlBY2t5QUhJQXBxS2dJQWxKSTRBZ0FnQkVFQmFpSUVJQkJIRFFBTElBRkJBV29pQVNBRlJ3MEFDd3NDUUNBQUtBSW9JZ0ZGRFFBZ0FDZ0NDQ0VFSUFHeVF5MFZLanFVdTBUdk9mcitRaTdtUDZJUUh5RWRJQVFnQ1d3aUFVRUJTQTBBSUIyMklSeEJBQ0VFQTBBZ0F5QUVRUUowYWlJRklBVXFBZ0FnSEpRNEFnQWdCRUVCYWlJRUlBRkhEUUFMQ3lBR0tBS0lBU0VCSUFZb0Fxd0JJUU1nQUNBVE5nSThJQUFnRVVFQmN5QVdRUUJIY1RZQ1JDQUFRUUFnQVNBRGN5QUNRUUpJR3pZQ1ZDQVBJQWtnRDBFQVNCc2hCUXNMSUFaQndBRnFKQUFnQlF1b0FRQUNRQ0FCUVlBSVRnUkFJQUJFQUFBQUFBQUE0SCtpSVFBZ0FVSC9EMGdFUUNBQlFmOEhheUVCREFJTElBQkVBQUFBQUFBQTRIK2lJUUFnQVVIOUZ5QUJRZjBYU0J0Qi9nOXJJUUVNQVFzZ0FVR0JlRW9OQUNBQVJBQUFBQUFBQUJBQW9pRUFJQUZCZzNCS0JFQWdBVUgrQjJvaEFRd0JDeUFBUkFBQUFBQUFBQkFBb2lFQUlBRkJobWdnQVVHR2FFb2JRZndQYWlFQkN5QUFJQUZCL3dkcXJVSTBocitpQzlBdUFReC9Jd0JCRUdzaURDUUFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUlBQkI5QUZOQkVCQm9Qc0JLQUlBSWdWQkVDQUFRUXRxUVhoeElBQkJDMGtiSWdoQkEzWWlBbllpQVVFRGNRUkFJQUZCZjNOQkFYRWdBbW9pQTBFRGRDSUJRZEQ3QVdvb0FnQWlCRUVJYWlFQUFrQWdCQ2dDQ0NJQ0lBRkJ5UHNCYWlJQlJnUkFRYUQ3QVNBRlFYNGdBM2R4TmdJQURBRUxRYkQ3QVNnQ0FCb2dBaUFCTmdJTUlBRWdBallDQ0FzZ0JDQURRUU4wSWdGQkEzSTJBZ1FnQVNBRWFpSUJJQUVvQWdSQkFYSTJBZ1FNRFFzZ0NFR28rd0VvQWdBaUNrME5BU0FCQkVBQ1FFRUNJQUowSWdCQkFDQUFhM0lnQVNBQ2RIRWlBRUVBSUFCcmNVRUJheUlBSUFCQkRIWkJFSEVpQW5ZaUFVRUZka0VJY1NJQUlBSnlJQUVnQUhZaUFVRUNka0VFY1NJQWNpQUJJQUIySWdGQkFYWkJBbkVpQUhJZ0FTQUFkaUlCUVFGMlFRRnhJZ0J5SUFFZ0FIWnFJZ05CQTNRaUFFSFErd0ZxS0FJQUlnUW9BZ2dpQVNBQVFjajdBV29pQUVZRVFFR2crd0VnQlVGK0lBTjNjU0lGTmdJQURBRUxRYkQ3QVNnQ0FCb2dBU0FBTmdJTUlBQWdBVFlDQ0FzZ0JFRUlhaUVBSUFRZ0NFRURjallDQkNBRUlBaHFJZ0lnQTBFRGRDSUJJQWhySWdOQkFYSTJBZ1FnQVNBRWFpQUROZ0lBSUFvRVFDQUtRUU4ySWdGQkEzUkJ5UHNCYWlFSFFiVDdBU2dDQUNFRUFuOGdCVUVCSUFGMElnRnhSUVJBUWFEN0FTQUJJQVZ5TmdJQUlBY01BUXNnQnlnQ0NBc2hBU0FISUFRMkFnZ2dBU0FFTmdJTUlBUWdCellDRENBRUlBRTJBZ2dMUWJUN0FTQUNOZ0lBUWFqN0FTQUROZ0lBREEwTFFhVDdBU2dDQUNJR1JRMEJJQVpCQUNBR2EzRkJBV3NpQUNBQVFReDJRUkJ4SWdKMklnRkJCWFpCQ0hFaUFDQUNjaUFCSUFCMklnRkJBblpCQkhFaUFISWdBU0FBZGlJQlFRRjJRUUp4SWdCeUlBRWdBSFlpQVVFQmRrRUJjU0lBY2lBQklBQjJha0VDZEVIUS9RRnFLQUlBSWdFb0FnUkJlSEVnQ0dzaEJDQUJJUUlEUUFKQUlBSW9BaEFpQUVVRVFDQUNLQUlVSWdCRkRRRUxJQUFvQWdSQmVIRWdDR3NpQWlBRUlBSWdCRWtpQWhzaEJDQUFJQUVnQWhzaEFTQUFJUUlNQVFzTElBRWdDR29pQ1NBQlRRMENJQUVvQWhnaEN5QUJJQUVvQWd3aUEwY0VRQ0FCS0FJSUlnQkJzUHNCS0FJQVR3UkFJQUFvQWd3YUN5QUFJQU0yQWd3Z0F5QUFOZ0lJREF3TElBRkJGR29pQWlnQ0FDSUFSUVJBSUFFb0FoQWlBRVVOQkNBQlFSQnFJUUlMQTBBZ0FpRUhJQUFpQTBFVWFpSUNLQUlBSWdBTkFDQURRUkJxSVFJZ0F5Z0NFQ0lBRFFBTElBZEJBRFlDQUF3TEMwRi9JUWdnQUVHL2Ywc05BQ0FBUVF0cUlnQkJlSEVoQ0VHayt3RW9BZ0FpQ1VVTkFFRWZJUVZCQUNBSWF5RUVBa0FDUUFKQUFuOGdDRUgvLy84SFRRUkFJQUJCQ0hZaUFDQUFRWUQrUDJwQkVIWkJDSEVpQW5RaUFDQUFRWURnSDJwQkVIWkJCSEVpQVhRaUFDQUFRWUNBRDJwQkVIWkJBbkVpQUhSQkQzWWdBU0FDY2lBQWNtc2lBRUVCZENBSUlBQkJGV3AyUVFGeGNrRWNhaUVGQ3lBRlFRSjBRZEQ5QVdvb0FnQWlBa1VMQkVCQkFDRUFEQUVMUVFBaEFDQUlRUUJCR1NBRlFRRjJheUFGUVI5R0czUWhBUU5BQWtBZ0FpZ0NCRUY0Y1NBSWF5SUhJQVJQRFFBZ0FpRURJQWNpQkEwQVFRQWhCQ0FDSVFBTUF3c2dBQ0FDS0FJVUlnY2dCeUFDSUFGQkhYWkJCSEZxS0FJUUlnSkdHeUFBSUFjYklRQWdBVUVCZENFQklBSU5BQXNMSUFBZ0EzSkZCRUJCQWlBRmRDSUFRUUFnQUd0eUlBbHhJZ0JGRFFNZ0FFRUFJQUJyY1VFQmF5SUFJQUJCREhaQkVIRWlBbllpQVVFRmRrRUljU0lBSUFKeUlBRWdBSFlpQVVFQ2RrRUVjU0lBY2lBQklBQjJJZ0ZCQVhaQkFuRWlBSElnQVNBQWRpSUJRUUYyUVFGeElnQnlJQUVnQUhacVFRSjBRZEQ5QVdvb0FnQWhBQXNnQUVVTkFRc0RRQ0FBS0FJRVFYaHhJQWhySWdFZ0JFa2hBaUFCSUFRZ0Foc2hCQ0FBSUFNZ0Foc2hBeUFBS0FJUUlnRUVmeUFCQlNBQUtBSVVDeUlBRFFBTEN5QURSUTBBSUFSQnFQc0JLQUlBSUFoclR3MEFJQU1nQ0dvaUJpQURUUTBCSUFNb0FoZ2hCU0FESUFNb0Fnd2lBVWNFUUNBREtBSUlJZ0JCc1BzQktBSUFUd1JBSUFBb0Fnd2FDeUFBSUFFMkFnd2dBU0FBTmdJSURBb0xJQU5CRkdvaUFpZ0NBQ0lBUlFSQUlBTW9BaEFpQUVVTkJDQURRUkJxSVFJTEEwQWdBaUVISUFBaUFVRVVhaUlDS0FJQUlnQU5BQ0FCUVJCcUlRSWdBU2dDRUNJQURRQUxJQWRCQURZQ0FBd0pDeUFJUWFqN0FTZ0NBQ0lDVFFSQVFiVDdBU2dDQUNFREFrQWdBaUFJYXlJQlFSQlBCRUJCcVBzQklBRTJBZ0JCdFBzQklBTWdDR29pQURZQ0FDQUFJQUZCQVhJMkFnUWdBaUFEYWlBQk5nSUFJQU1nQ0VFRGNqWUNCQXdCQzBHMCt3RkJBRFlDQUVHbyt3RkJBRFlDQUNBRElBSkJBM0kyQWdRZ0FpQURhaUlBSUFBb0FnUkJBWEkyQWdRTElBTkJDR29oQUF3TEN5QUlRYXo3QVNnQ0FDSUdTUVJBUWF6N0FTQUdJQWhySWdFMkFnQkJ1UHNCUWJqN0FTZ0NBQ0lDSUFocUlnQTJBZ0FnQUNBQlFRRnlOZ0lFSUFJZ0NFRURjallDQkNBQ1FRaHFJUUFNQ3d0QkFDRUFJQWhCTDJvaUNRSi9RZmorQVNnQ0FBUkFRWUQvQVNnQ0FBd0JDMEdFL3dGQ2Z6Y0NBRUg4L2dGQ2dLQ0FnSUNBQkRjQ0FFSDQvZ0VnREVFTWFrRndjVUhZcXRXcUJYTTJBZ0JCalA4QlFRQTJBZ0JCM1A0QlFRQTJBZ0JCZ0NBTElnRnFJZ1ZCQUNBQmF5SUhjU0lDSUFoTkRRcEIyUDRCS0FJQUlnUUVRRUhRL2dFb0FnQWlBeUFDYWlJQklBTk5EUXNnQVNBRVN3MExDMEhjL2dFdEFBQkJCSEVOQlFKQUFrQkJ1UHNCS0FJQUlnTUVRRUhnL2dFaEFBTkFJQU1nQUNnQ0FDSUJUd1JBSUFFZ0FDZ0NCR29nQTBzTkF3c2dBQ2dDQ0NJQURRQUxDMEVBRUE4aUFVRi9SZzBHSUFJaEJVSDgvZ0VvQWdBaUEwRUJheUlBSUFGeEJFQWdBaUFCYXlBQUlBRnFRUUFnQTJ0eGFpRUZDeUFGSUFoTkRRWWdCVUgrLy8vL0Iwc05Ca0hZL2dFb0FnQWlCQVJBUWREK0FTZ0NBQ0lESUFWcUlnQWdBMDBOQnlBQUlBUkxEUWNMSUFVUUR5SUFJQUZIRFFFTUNBc2dCU0FHYXlBSGNTSUZRZjcvLy84SFN3MEZJQVVRRHlJQklBQW9BZ0FnQUNnQ0JHcEdEUVFnQVNFQUN3SkFJQWhCTUdvZ0JVME5BQ0FBUVg5R0RRQkJnUDhCS0FJQUlnRWdDU0FGYTJwQkFDQUJhM0VpQVVIKy8vLy9CMHNFUUNBQUlRRU1DQXNnQVJBUFFYOUhCRUFnQVNBRmFpRUZJQUFoQVF3SUMwRUFJQVZyRUE4YURBVUxJQUFpQVVGL1J3MEdEQVFMQUF0QkFDRUREQWNMUVFBaEFRd0ZDeUFCUVg5SERRSUxRZHorQVVIYy9nRW9BZ0JCQkhJMkFnQUxJQUpCL3YvLy93ZExEUUVnQWhBUElnRkJBQkFQSWdCUERRRWdBVUYvUmcwQklBQkJmMFlOQVNBQUlBRnJJZ1VnQ0VFb2FrME5BUXRCMFA0QlFkRCtBU2dDQUNBRmFpSUFOZ0lBUWRUK0FTZ0NBQ0FBU1FSQVFkVCtBU0FBTmdJQUN3SkFBa0FDUUVHNCt3RW9BZ0FpQndSQVFlRCtBU0VBQTBBZ0FTQUFLQUlBSWdNZ0FDZ0NCQ0lDYWtZTkFpQUFLQUlJSWdBTkFBc01BZ3RCc1BzQktBSUFJZ0JCQUNBQUlBRk5HMFVFUUVHdyt3RWdBVFlDQUF0QkFDRUFRZVQrQVNBRk5nSUFRZUQrQVNBQk5nSUFRY0Q3QVVGL05nSUFRY1Q3QVVINC9nRW9BZ0EyQWdCQjdQNEJRUUEyQWdBRFFDQUFRUU4wSWdOQjBQc0JhaUFEUWNqN0FXb2lBallDQUNBRFFkVDdBV29nQWpZQ0FDQUFRUUZxSWdCQklFY05BQXRCclBzQklBVkJLR3NpQTBGNElBRnJRUWR4UVFBZ0FVRUlha0VIY1JzaUFHc2lBallDQUVHNCt3RWdBQ0FCYWlJQU5nSUFJQUFnQWtFQmNqWUNCQ0FCSUFOcVFTZzJBZ1JCdlBzQlFZai9BU2dDQURZQ0FBd0NDeUFBTFFBTVFRaHhEUUFnQVNBSFRRMEFJQU1nQjBzTkFDQUFJQUlnQldvMkFnUkJ1UHNCSUFkQmVDQUhhMEVIY1VFQUlBZEJDR3BCQjNFYklnQnFJZ0kyQWdCQnJQc0JRYXo3QVNnQ0FDQUZhaUlCSUFCcklnQTJBZ0FnQWlBQVFRRnlOZ0lFSUFFZ0IycEJLRFlDQkVHOCt3RkJpUDhCS0FJQU5nSUFEQUVMUWJEN0FTZ0NBQ0lESUFGTEJFQkJzUHNCSUFFMkFnQWdBU0VEQ3lBQklBVnFJUUpCNFA0QklRQUNRQUpBQWtBQ1FBSkFBa0FEUUNBQ0lBQW9BZ0JIQkVBZ0FDZ0NDQ0lBRFFFTUFnc0xJQUF0QUF4QkNIRkZEUUVMUWVEK0FTRUFBMEFnQnlBQUtBSUFJZ0pQQkVBZ0FpQUFLQUlFYWlJRUlBZExEUU1MSUFBb0FnZ2hBQXdBQ3dBTElBQWdBVFlDQUNBQUlBQW9BZ1FnQldvMkFnUWdBVUY0SUFGclFRZHhRUUFnQVVFSWFrRUhjUnRxSWdrZ0NFRURjallDQkNBQ1FYZ2dBbXRCQjNGQkFDQUNRUWhxUVFkeEcyb2lCU0FKYXlBSWF5RUNJQWdnQ1dvaEJpQUZJQWRHQkVCQnVQc0JJQVkyQWdCQnJQc0JRYXo3QVNnQ0FDQUNhaUlBTmdJQUlBWWdBRUVCY2pZQ0JBd0RDeUFGUWJUN0FTZ0NBRVlFUUVHMCt3RWdCallDQUVHbyt3RkJxUHNCS0FJQUlBSnFJZ0EyQWdBZ0JpQUFRUUZ5TmdJRUlBQWdCbW9nQURZQ0FBd0RDeUFGS0FJRUlnQkJBM0ZCQVVZRVFDQUFRWGh4SVFjQ1FDQUFRZjhCVFFSQUlBVW9BZ2dpQXlBQVFRTjJJZ0JCQTNSQnlQc0Jha2NhSUFNZ0JTZ0NEQ0lCUmdSQVFhRDdBVUdnK3dFb0FnQkJmaUFBZDNFMkFnQU1BZ3NnQXlBQk5nSU1JQUVnQXpZQ0NBd0JDeUFGS0FJWUlRZ0NRQ0FGSUFVb0Fnd2lBVWNFUUNBRktBSUlJZ0FnQTA4RVFDQUFLQUlNR2dzZ0FDQUJOZ0lNSUFFZ0FEWUNDQXdCQ3dKQUlBVkJGR29pQUNnQ0FDSUVEUUFnQlVFUWFpSUFLQUlBSWdRTkFFRUFJUUVNQVFzRFFDQUFJUU1nQkNJQlFSUnFJZ0FvQWdBaUJBMEFJQUZCRUdvaEFDQUJLQUlRSWdRTkFBc2dBMEVBTmdJQUN5QUlSUTBBQWtBZ0JTQUZLQUljSWdOQkFuUkIwUDBCYWlJQUtBSUFSZ1JBSUFBZ0FUWUNBQ0FCRFFGQnBQc0JRYVQ3QVNnQ0FFRitJQU4zY1RZQ0FBd0NDeUFJUVJCQkZDQUlLQUlRSUFWR0cyb2dBVFlDQUNBQlJRMEJDeUFCSUFnMkFoZ2dCU2dDRUNJQUJFQWdBU0FBTmdJUUlBQWdBVFlDR0FzZ0JTZ0NGQ0lBUlEwQUlBRWdBRFlDRkNBQUlBRTJBaGdMSUFVZ0Iyb2hCU0FDSUFkcUlRSUxJQVVnQlNnQ0JFRitjVFlDQkNBR0lBSkJBWEkyQWdRZ0FpQUdhaUFDTmdJQUlBSkIvd0ZOQkVBZ0FrRURkaUlBUVFOMFFjajdBV29oQWdKL1FhRDdBU2dDQUNJQlFRRWdBSFFpQUhGRkJFQkJvUHNCSUFBZ0FYSTJBZ0FnQWd3QkN5QUNLQUlJQ3lFQUlBSWdCallDQ0NBQUlBWTJBZ3dnQmlBQ05nSU1JQVlnQURZQ0NBd0RDMEVmSVFBZ0FrSC8vLzhIVFFSQUlBSkJDSFlpQUNBQVFZRCtQMnBCRUhaQkNIRWlBM1FpQUNBQVFZRGdIMnBCRUhaQkJIRWlBWFFpQUNBQVFZQ0FEMnBCRUhaQkFuRWlBSFJCRDNZZ0FTQURjaUFBY21zaUFFRUJkQ0FDSUFCQkZXcDJRUUZ4Y2tFY2FpRUFDeUFHSUFBMkFod2dCa0lBTndJUUlBQkJBblJCMFAwQmFpRUVBa0JCcFBzQktBSUFJZ05CQVNBQWRDSUJjVVVFUUVHayt3RWdBU0FEY2pZQ0FDQUVJQVkyQWdBZ0JpQUVOZ0lZREFFTElBSkJBRUVaSUFCQkFYWnJJQUJCSDBZYmRDRUFJQVFvQWdBaEFRTkFJQUVpQXlnQ0JFRjRjU0FDUmcwRElBQkJIWFloQVNBQVFRRjBJUUFnQXlBQlFRUnhhaUlFS0FJUUlnRU5BQXNnQkNBR05nSVFJQVlnQXpZQ0dBc2dCaUFHTmdJTUlBWWdCallDQ0F3Q0MwR3Mrd0VnQlVFb2F5SURRWGdnQVd0QkIzRkJBQ0FCUVFocVFRZHhHeUlBYXlJQ05nSUFRYmo3QVNBQUlBRnFJZ0EyQWdBZ0FDQUNRUUZ5TmdJRUlBRWdBMnBCS0RZQ0JFRzgrd0ZCaVA4QktBSUFOZ0lBSUFjZ0JFRW5JQVJyUVFkeFFRQWdCRUVuYTBFSGNSdHFRUzlySWdBZ0FDQUhRUkJxU1JzaUFrRWJOZ0lFSUFKQjZQNEJLUUlBTndJUUlBSkI0UDRCS1FJQU53SUlRZWorQVNBQ1FRaHFOZ0lBUWVUK0FTQUZOZ0lBUWVEK0FTQUJOZ0lBUWV6K0FVRUFOZ0lBSUFKQkdHb2hBQU5BSUFCQkJ6WUNCQ0FBUVFocUlRRWdBRUVFYWlFQUlBRWdCRWtOQUFzZ0FpQUhSZzBESUFJZ0FpZ0NCRUYrY1RZQ0JDQUhJQUlnQjJzaUJFRUJjallDQkNBQ0lBUTJBZ0FnQkVIL0FVMEVRQ0FFUVFOMklnQkJBM1JCeVBzQmFpRUNBbjlCb1BzQktBSUFJZ0ZCQVNBQWRDSUFjVVVFUUVHZyt3RWdBQ0FCY2pZQ0FDQUNEQUVMSUFJb0FnZ0xJUUFnQWlBSE5nSUlJQUFnQnpZQ0RDQUhJQUkyQWd3Z0J5QUFOZ0lJREFRTFFSOGhBQ0FIUWdBM0FoQWdCRUgvLy84SFRRUkFJQVJCQ0hZaUFDQUFRWUQrUDJwQkVIWkJDSEVpQW5RaUFDQUFRWURnSDJwQkVIWkJCSEVpQVhRaUFDQUFRWUNBRDJwQkVIWkJBbkVpQUhSQkQzWWdBU0FDY2lBQWNtc2lBRUVCZENBRUlBQkJGV3AyUVFGeGNrRWNhaUVBQ3lBSElBQTJBaHdnQUVFQ2RFSFEvUUZxSVFNQ1FFR2srd0VvQWdBaUFrRUJJQUIwSWdGeFJRUkFRYVQ3QVNBQklBSnlOZ0lBSUFNZ0J6WUNBQ0FISUFNMkFoZ01BUXNnQkVFQVFSa2dBRUVCZG1zZ0FFRWZSaHQwSVFBZ0F5Z0NBQ0VCQTBBZ0FTSUNLQUlFUVhoeElBUkdEUVFnQUVFZGRpRUJJQUJCQVhRaEFDQUNJQUZCQkhGcUlnTW9BaEFpQVEwQUN5QURJQWMyQWhBZ0J5QUNOZ0lZQ3lBSElBYzJBZ3dnQnlBSE5nSUlEQU1MSUFNb0FnZ2lBQ0FHTmdJTUlBTWdCallDQ0NBR1FRQTJBaGdnQmlBRE5nSU1JQVlnQURZQ0NBc2dDVUVJYWlFQURBVUxJQUlvQWdnaUFDQUhOZ0lNSUFJZ0J6WUNDQ0FIUVFBMkFoZ2dCeUFDTmdJTUlBY2dBRFlDQ0F0QnJQc0JLQUlBSWdBZ0NFME5BRUdzK3dFZ0FDQUlheUlCTmdJQVFiajdBVUc0K3dFb0FnQWlBaUFJYWlJQU5nSUFJQUFnQVVFQmNqWUNCQ0FDSUFoQkEzSTJBZ1FnQWtFSWFpRUFEQU1MUVp6N0FVRXdOZ0lBUVFBaEFBd0NDd0pBSUFWRkRRQUNRQ0FES0FJY0lnSkJBblJCMFAwQmFpSUFLQUlBSUFOR0JFQWdBQ0FCTmdJQUlBRU5BVUdrK3dFZ0NVRitJQUozY1NJSk5nSUFEQUlMSUFWQkVFRVVJQVVvQWhBZ0EwWWJhaUFCTmdJQUlBRkZEUUVMSUFFZ0JUWUNHQ0FES0FJUUlnQUVRQ0FCSUFBMkFoQWdBQ0FCTmdJWUN5QURLQUlVSWdCRkRRQWdBU0FBTmdJVUlBQWdBVFlDR0FzQ1FDQUVRUTlOQkVBZ0F5QUVJQWhxSWdCQkEzSTJBZ1FnQUNBRGFpSUFJQUFvQWdSQkFYSTJBZ1FNQVFzZ0F5QUlRUU55TmdJRUlBWWdCRUVCY2pZQ0JDQUVJQVpxSUFRMkFnQWdCRUgvQVUwRVFDQUVRUU4ySWdCQkEzUkJ5UHNCYWlFQ0FuOUJvUHNCS0FJQUlnRkJBU0FBZENJQWNVVUVRRUdnK3dFZ0FDQUJjallDQUNBQ0RBRUxJQUlvQWdnTElRQWdBaUFHTmdJSUlBQWdCallDRENBR0lBSTJBZ3dnQmlBQU5nSUlEQUVMUVI4aEFDQUVRZi8vL3dkTkJFQWdCRUVJZGlJQUlBQkJnUDQvYWtFUWRrRUljU0lDZENJQUlBQkJnT0FmYWtFUWRrRUVjU0lCZENJQUlBQkJnSUFQYWtFUWRrRUNjU0lBZEVFUGRpQUJJQUp5SUFCeWF5SUFRUUYwSUFRZ0FFRVZhblpCQVhGeVFSeHFJUUFMSUFZZ0FEWUNIQ0FHUWdBM0FoQWdBRUVDZEVIUS9RRnFJUUlDUUFKQUlBbEJBU0FBZENJQmNVVUVRRUdrK3dFZ0FTQUpjallDQUNBQ0lBWTJBZ0FnQmlBQ05nSVlEQUVMSUFSQkFFRVpJQUJCQVhacklBQkJIMFliZENFQUlBSW9BZ0FoQ0FOQUlBZ2lBU2dDQkVGNGNTQUVSZzBDSUFCQkhYWWhBaUFBUVFGMElRQWdBU0FDUVFSeGFpSUNLQUlRSWdnTkFBc2dBaUFHTmdJUUlBWWdBVFlDR0FzZ0JpQUdOZ0lNSUFZZ0JqWUNDQXdCQ3lBQktBSUlJZ0FnQmpZQ0RDQUJJQVkyQWdnZ0JrRUFOZ0lZSUFZZ0FUWUNEQ0FHSUFBMkFnZ0xJQU5CQ0dvaEFBd0JDd0pBSUF0RkRRQUNRQ0FCS0FJY0lnSkJBblJCMFAwQmFpSUFLQUlBSUFGR0JFQWdBQ0FETmdJQUlBTU5BVUdrK3dFZ0JrRitJQUozY1RZQ0FBd0NDeUFMUVJCQkZDQUxLQUlRSUFGR0cyb2dBellDQUNBRFJRMEJDeUFESUFzMkFoZ2dBU2dDRUNJQUJFQWdBeUFBTmdJUUlBQWdBellDR0FzZ0FTZ0NGQ0lBUlEwQUlBTWdBRFlDRkNBQUlBTTJBaGdMQWtBZ0JFRVBUUVJBSUFFZ0JDQUlhaUlBUVFOeU5nSUVJQUFnQVdvaUFDQUFLQUlFUVFGeU5nSUVEQUVMSUFFZ0NFRURjallDQkNBSklBUkJBWEkyQWdRZ0JDQUphaUFFTmdJQUlBb0VRQ0FLUVFOMklnQkJBM1JCeVBzQmFpRURRYlQ3QVNnQ0FDRUNBbjlCQVNBQWRDSUFJQVZ4UlFSQVFhRDdBU0FBSUFWeU5nSUFJQU1NQVFzZ0F5Z0NDQXNoQUNBRElBSTJBZ2dnQUNBQ05nSU1JQUlnQXpZQ0RDQUNJQUEyQWdnTFFiVDdBU0FKTmdJQVFhajdBU0FFTmdJQUN5QUJRUWhxSVFBTElBeEJFR29rQUNBQUMvWUZBUXQvQWtBZ0FVRUJheUlLUVlBQ1R3UkFJQUFnQUNnQ0hDSURJQXBCR0NBS1oyc2lCbllpQWtFQmFpSUViaUlCTmdJa0lBQWdBQ2dDSUNJRklBSkJBQ0FGSUFGdUlnVkJBV29pQ0NBRWF5SUVJQVFnQ0VzYklBSWdCV3RxSWd0cklBRnNJZ0pySWdjMkFpQWdBQ0FCSUFNZ0Ftc2dDeHNpQWpZQ0hDQUNRWUNBZ0FSTkJFQWdBQ2dDR0NFRElBQW9BaWdoQkNBQUtBSVVJUVVnQUNnQ0JDRU1BMEFnQUNBQ1FRaDBJZ2cyQWh3Z0FDQUZRUWhxSWdVMkFoUkJBQ0VCSUFNZ0RFa0VRQ0FBSUFOQkFXb2lDVFlDR0NBQUtBSUFJQU5xTFFBQUlRRWdDU0VEQ3lBQUlBRTJBaWdnQUNBQklBUkJDSFJ5UVFGMlFmOEJjU0FIUVFoMFFZRCsvLzhIY1hKQi93RnpJZ2MyQWlBZ0FrR0JnQUpKSVFrZ0FTRUVJQWdoQWlBSkRRQUxDeUFMSUFaMElRZ2dBQ2dDRENFSEFrQWdCaUFBS0FJUUlnRk5CRUFnQVNFRkRBRUxJQUFvQWdnaEFpQUFLQUlFSVFRRFFFRUFJUU1nQWlBRVNRUi9JQUFnQWtFQmFpSUNOZ0lJSUFBb0FnQWdCQ0FDYTJvdEFBQUZRUUFMSUFGMElBZHlJUWNnQVVFUlNDRURJQUZCQ0dvaUJTRUJJQU1OQUFzTElBQWdCU0FHYXpZQ0VDQUFJQWNnQm5ZMkFnd2dBQ0FBS0FJVUlBWnFOZ0lVSUFkQmZ5QUdkRUYvYzNFZ0NISWlCaUFLVFEwQklBQkJBVFlDTENBS0R3c2dBQ0FBS0FJY0lnTWdBVzRpQWpZQ0pDQUFJQUFvQWlBaUJDQUJJQVFnQW00aUJFRi9jeUFCYWtFQUlBUkJBV29pQkNBQmF5SUJJQUVnQkVzYmFpSUdRWDl6YWlBQ2JDSUJheUlITmdJZ0lBQWdBaUFESUFGcklBWWJJZ0kyQWh3Z0FrR0FnSUFFU3cwQUlBQW9BaGdoQXlBQUtBSW9JUVFnQUNnQ0ZDRUZJQUFvQWdRaENnTkFJQUFnQWtFSWRDSUlOZ0ljSUFBZ0JVRUlhaUlGTmdJVVFRQWhBU0FESUFwSkJFQWdBQ0FEUVFGcUlnazJBaGdnQUNnQ0FDQURhaTBBQUNFQklBa2hBd3NnQUNBQk5nSW9JQUFnQVNBRVFRaDBja0VCZGtIL0FYRWdCMEVJZEVHQS92Ly9CM0Z5UWY4QmN5SUhOZ0lnSUFKQmdZQUNTU0VKSUFFaEJDQUlJUUlnQ1EwQUN3c2dCZ3VFQlFJS2Z3WjlJQUFvQWhnaENDQUFLQUlBSVFrZ0JVRUJUZ1JBQTBBZ0NDQUpRUUYxSWdsQkFuUnFJUWdnQjBFQmFpSUhJQVZIRFFBTEN5QUNJQVJCQVhSQmZIRnFJUWNnQUNBRlFRSjBhaWdDQ0NFTEFrQWdDVUVEVEFSQUlBc2dCeEE3REFFTElBbEJBblVpQ2tFQklBcEJBVW9iSVE1QkFDRUZJQUVnQ1VFQmRTSU5RUUZySUFac1FRSjBhaUVBSUFzb0Fpd2hERUVBSUFaQkFYUWlCbXRCQW5RaER3TkFJQWNnREM0QkFFRURkQ0lRUVFSeWFpQUFLZ0lBSWhNZ0NDQUZRUUowYWlvQ0FDSVVsQ0FCS2dJQUloRWdDQ0FGSUFwcVFRSjBhaW9DQUNJU2xKSTRBZ0FnQnlBUWFpQVVJQkdVSUJNZ0VwU1RPQUlBSUF4QkFtb2hEQ0FBSUE5cUlRQWdBU0FHUVFKMGFpRUJJQVZCQVdvaUJTQU9SdzBBQ3lBTElBY1FPeUFKUVFSSURRQWdDa0VCYWtFQmRTSUFRUUVnQUVFQlNoc2hBQ0FISUExQkFuUnFJUUZCQUNFRkEwQWdBVUVFYXlJR0tnSUFJUk1nQVVFSWF5SUJLZ0lBSVJRZ0J5QUhLZ0lFSWhFZ0NDQUZRUUowYWlvQ0FDSVNsQ0FIS2dJQUloVWdDQ0FGSUFwcVFRSjBhaW9DQUNJV2xKSTRBZ0FnQmlBUklCYVVJQlVnRXBTVE9BSUFJQUVnRXlBSUlBb2dCVUYvY3lJR2FrRUNkR29xQWdBaUVaUWdGQ0FJSUFZZ0RXcEJBblJxS2dJQUloS1VramdDQUNBSElCTWdFcFFnRkNBUmxKTTRBZ1FnQjBFSWFpRUhJQVZCQVdvaUJTQUFSdzBBQ3dzZ0JFRUNiU0VBSUFSQkFrNEVRQ0FDSUFSQkFuUWlBV29oQ0NBQklBTnFJUWRCQUNFRkEwQWdBaUFDS2dJQUloTWdCMEVFYXlJSEtnSUFJaFNVSUFoQkJHc2lDQ29DQUNJUklBTXFBZ0FpRXBTVE9BSUFJQWdnRVNBVWxDQVRJQktVa2pnQ0FDQURRUVJxSVFNZ0FrRUVhaUVDSUFWQkFXb2lCU0FBUncwQUN3c0xxUm9DSm44RGZTTUFRZEFBYXlJTUpBQWdBQ2dDQ0NFWUlBeEJBRFlDRENBTVFRQTJBZ2hCZnlFSEFrQWdBQ2dDQUNJS0tBSWtJZ2hCQUVnTkFDQUFJQW9vQWdRaUhFR0FFR29pRmlBWWJFRUNkR29nR0VIZ0FHeHFRZHdBYWlJTklBb29BZ2dpQzBFRGRDSUdhaUlVSUFacUloa2dCbW9oSnlBQUtBSVFJQVJzSVJFZ0FDZ0NHQ0VKSUFBb0FoUWhEeUFBS0FJTUlSQWdDaWdDSUNFYklBb29BaXdoQkFOQUlCRWdCQ0FPZEVjRVFDQUlJQTVLSVFZZ0RrRUJhaUVPSUFZTkFRd0NDd3NnQWtIN0NVc05BQ0FEUlEwQUlCaEJBU0FZUVFGS0d5RWRRUUFoQmtFQUlCRnJRUUowSVFRRFFDQUdRUUowSWdjZ0RFRVlhbW9nQUNBR0lCWnNRUUowYWtIY0FHb2lDRFlDQUNBTVFSQnFJQWRxSUFRZ0NHcEJnRUJyTmdJQUlBWkJBV29pQmlBZFJ3MEFDeUFCUVFBZ0FrRUJTaHRGQkVBZ0FDQVJJQTRRV3lBTVFSQnFJQU1nRVNBWUlBQW9BaEFnQ2tFUWFpQUFRZFFBYWhBNUlCRWdBQ2dDRUcwaEJ3d0JDeUFLS0FJTUlSNUJBQ0VHSUFBZ0FDZ0NORUVBUnpZQ09DQUZSUVJBSUF4QklHb2dBU0FDRUZNZ0RFRWdhaUVGQzBFQklTTUNRQ0FRUVFGSERRQWdDMEVCU0EwQUEwQWdEU0FHUVFKMGFpSUJJQUVxQWdBaUxDQU5JQVlnQzJwQkFuUnFLZ0lBSWkwZ0xDQXRYaHM0QWdBZ0JrRUJhaUlHSUF0SERRQUxDd0ovSUFVb0FoUWlDQ0FGS0FJY1p5SUVha0VnYXlJR0lBSkJBM1FpRlVnRVFFRUFJU05CQVNBR1FRRkhEUUVhSUFWQkR4QUdJZ0ZGQkVCQkFTRUdRUUVNQWdzZ0JTZ0NGQ0VJSUFFaEl5QUZLQUljWnlFRUN5QUZJQlVnQ0dzZ0JHc2dDR3BCSUdvMkFoUWdGU0VHUVFBTElTaERBQUFBQUNFc0FrQWdEdzBBSUFaQkVHb2dGVW9OQUFKOVF3QUFBQUFnQlVFQkVBWkZEUUFhSUFVZ0JVRUdFQllpQVVFRWFoQUpRUkFnQVhScUlRRWdCVUVERUFraEJDQVZJQVVvQWhRZ0JTZ0NIR2RxUVI1clRnUkFJQVZCaHoxQkFoQURJUjhMSUFGQkFXc2hKQ0FFUVFGcXNrTUFBTUE5bEFzaExDQUZLQUlVSUFVb0FoeG5ha0VnYXlFR0N5QUdRUU5xSVFZQ1FDQU9SUTBBSUFZZ0ZVb05BQ0FGUVFNUUJpRVhJQVVvQWhRZ0JTZ0NIR2RxUVIxcklRWUxJQW9nRHlBSklBMGdCaUFWVEFSL0lBVkJBeEFHQlVFQUN5QUZJQkFnRGhDZUFTQU1JQXRCQW5SQkQycEJjSEZySWlBaUV5UUFJQTVCQUVjZ0JTZ0NCRUVEZENJR0lBVW9BaFFnQlNnQ0hHZHFRU0JySWdSQkFrRUVJQmNiSWdGQkFYSnFUM0VoRmtFQUlRY0NRQ0FKSUE5TUloSU5BQ0FHSUJacklob2dBU0FFYWs4RVFDQUZJQUVRQmlFSElBVW9BaFFnQlNnQ0hHZHFRU0JySVFRTElDQWdEMEVDZEdvZ0J6WUNBQ0FQUVFGcUlnWWdDVVlOQUVFRVFRVWdGeHNoQVNBSElRZ0RRQ0FhSUFFZ0JHcFBCRUFnQlNBQkVBWWdDSE1pQ0NBSGNpRUhJQVVvQWhRZ0JTZ0NIR2RxUVNCcklRUUxJQ0FnQmtFQ2RHb2dDRFlDQUNBR1FRRnFJZ1lnQ1VjTkFBc0xRUUFoQmdKQUlCWkZEUUFnRGtFRGRFR3dPMm9pQVNBSElCZEJBblFpQkdwcUxRQUFJQUVnQkVFQ2NpQUhhbW90QUFCR0RRQWdCVUVCRUFaQkFYUWhCZ3NnRWtVRVFDQUdJQmRCQW5ScUlRRWdEa0VEZEVHd08yb2hCQ0FQSVFZRFFDQWdJQVpCQW5ScUlnY2dCQ0FCSUFjb0FnQnFhaXdBQURZQ0FDQUdRUUZxSWdZZ0NVY05BQXNMUVFJaEpTQVZJQVVvQWhRZ0JTZ0NIR2RxUVJ4clRnUkFJQVZCaWoxQkJSQURJU1VMSUJNZ0MwRUNkRUVQYWtGd2NTSUJheUlhSWdRa0FDQUtJQm9nRGlBUUVGNUJCaUVUSUFKQkJuUWhGaUFFSUFGcklpRWlKaVFBSUFVUUN5RUNBa0FnRWdSQUlCWWhCQXdCQ3lBUElRWWdGaUVFQTBBZ0d5QUdJZ0ZCQVdvaUJrRUJkR291QVFBZ0d5QUJRUUYwYWk0QkFHc2dFR3dnRG5RaUIwRURkQ0lJSUFkQk1DQUhRVEJLR3lJSElBY2dDRW9iSVNJZ0dpQUJRUUowSWlscUlTb2dCQ0VCSUJNaENFRUFJUWNEUUFKQUlBY2hFaUFCSWdRZ0NFRURkQ0FDYWt3TkFDQVNJQ29vQWdCT0RRQWdCQ0FpYXlFQklCSWdJbW9oQnlBRklBZ1FCaUVySUFVUUN5RUNRUUVoQ0NBckRRRUxDeUFoSUNscUlCSTJBZ0FnRTBFQmEwRUNJQk5CQWtvYklCTWdFa0VBU2hzaEV5QUdJQWxIRFFBTEN5QW1JQXRCQW5SQkQycEJjSEZySWdjaUFTUUFRUVVoQ0NBRUlBSkJNR3BPQkVBZ0JVR09QVUVIRUFNaENBc2dDMEVCZENFRUlCWWdCUkFMUVg5emFpRUNRUUFoQmlBZUlBa2dDU0FlU2hzaEcwRUJJQTUwSWg1QkFDQVhHeUVpSUFFZ0MwRUNkRUVQYWtGd2NTSUJheUlUSWhJa0FDQVNJQUZySWhJaUppUUFJQW9nRHlBSklDRWdHaUFJSUF4QkRHb2dERUVJYWlBQ0FuOGdEa0VDU1FSQVFRQWhBVUVBREFFTFFRQWhBVUVBSUJkRkRRQWFJQUlnRGtFRGRFRVFhazRpQVVFRGRBc2lHbXNnREVFRWFpQVRJQWNnRWlBUUlBNGdCUkNiQVNFaElBb2dEeUFKSUEwZ0J5QUZJQkFRblFFZ0hFRUNiU0FSYTBFQ2RFR0FRR3NoQWdOQUlBeEJHR29nQmtFQ2RHb29BZ0FpQ0NBSUlCRkJBblJxSUFJUURob2dCa0VCYWlJR0lCMUhEUUFMSUNZZ0N5QVFiQ0lJUVE5cVFYQnhheUlHSWdJa0FDQUNJQkFnRVd4QkFuUkJEMnBCY0hGcklnSWtBQ0FLSUE4Z0NTQUNJQUlnRVVFQ2RHcEJBQ0FRUVFKR0d5QUdJQk1nSWlBbElBd29BZ2dnRENnQ0RDQWdJQllnR21zZ0RDZ0NCQ0FGSUE0Z0lTQUFRU2hxSUFBb0FpUWdBQ2dDSUJCaEFrQWdBUVJBSUFWQkFSQUpJUUVnQ2lBUElBa2dEU0FISUJJZ0ZTQUZLQUlVYXlBRktBSWNaMnRCSUdvZ0JTQVFFRlFnQVVVTkFTQUtJQUlnQmlBT0lCQWdFU0FQSUFrZ0RTQVVJQmtnRXlBQUtBSW9JQUFvQWlRUVl3d0JDeUFLSUE4Z0NTQU5JQWNnRWlBVklBVW9BaFJySUFVb0FoeG5hMEVnYWlBRklCQVFWQXNDZnlBb1JRUkFRUUFoQmlBSVFRQktCRUFEUUNBTklBWkJBblJxUVlDQWdJOThOZ0lBSUFaQkFXb2lCaUFJUncwQUN3c2dDaUFDSUF4QkVHb2dEU0FQSUJzZ0VDQVlJQmNnRGlBQUtBSVFJQ01nQUNnQ0pCQWlJQXhCRUdvTUFRc2dDaUFDSUF4QkVHb2dEU0FQSUJzZ0VDQVlJQmNnRGlBQUtBSVFRUUFnQUNnQ0pCQWlJQXhCRUdvTElRSkJBQ0VHQWtBZ0RrVUVRQU5BSUFBZ0FDZ0NQQ0lCUVE4Z0FVRVBTaHNpQVRZQ1BDQUFJQUFvQWtBaUIwRVBJQWRCRDBvYklnYzJBa0FnREVFUWFpQUdRUUowYWlnQ0FDSUlJQWdnQnlBQklBb29BaXdnQUNvQ1NDQUFLZ0pFSUFBb0FsQWdBQ2dDVENBS0tBSThJQndnQUNnQ0pCQVpJQVpCQVdvaUJpQWRSdzBBREFJTEFBc0RRQ0FBSUFBb0Fqd2lBVUVQSUFGQkQwb2JJZ2MyQWp3Z0FDQUFLQUpBSWdGQkR5QUJRUTlLR3lJSU5nSkFJQXhCRUdvZ0JrRUNkR29vQWdBaUFTQUJJQWdnQnlBS0tBSXNJQUFxQWtnZ0FDb0NSQ0FBS0FKUUlBQW9Ba3dnQ2lnQ1BDQWNJQUFvQWlRUUdTQUJJQW9vQWl3aUIwRUNkR29pQVNBQklBQW9BandnSkNBUklBZHJJQUFxQWtRZ0xDQUFLQUpNSUI4Z0NpZ0NQQ0FjSUFBb0FpUVFHU0FHUVFGcUlnWWdIVWNOQUFzTElBQWdBQ2dDUERZQ1FDQUFLZ0pFSVMwZ0FDQXNPQUpFSUFBZ0xUZ0NTQ0FBS0FKTUlRRWdBQ0FmTmdKTUlBQWdBVFlDVUNBQUlDUTJBandnRGdSQUlBQWdIellDVUNBQUlDdzRBa2dnQUNBa05nSkFDeUFRUVFGR0JFQWdEU0FMUVFKMElnRnFJQTBnQVJBRUdnc0NRQ0FYQkVBZ0MwRUJTQTBCSUFSQkFTQUVRUUZLR3lFQlFRQWhCZ05BSUJRZ0JrRUNkQ0lFYWlJSElBY3FBZ0FpTENBRUlBMXFLZ0lBSWkwZ0xDQXRYUnM0QWdBZ0JrRUJhaUlHSUFGSERRQUxEQUVMSUJrZ0ZDQUxRUU4wSWdFUUJCb2dGQ0FOSUFFUUJCb2dDMEVCU0EwQUlCNnlRMjhTZ3pxVVF3QUFnRDhnQUNnQ05FRUtTQnNoTENBRVFRRWdCRUVCU2hzaEFVRUFJUVlEUUNBbklBWkJBblFpQkdvaUJ5QXNJQWNxQWdDU0lpMGdCQ0FOYWlvQ0FDSXVJQzBnTGwwYk9BSUFJQVpCQVdvaUJpQUJSdzBBQ3d0QkFDRUdBa0FnRDBFQVNnUkFBMEFnRFNBR1FRSjBJZ0ZxUVFBMkFnQWdBU0FaYWtHQWdJQ1BmRFlDQUNBQklCUnFRWUNBZ0k5OE5nSUFJQVpCQVdvaUJpQVBSdzBBQ3lBSklBdElCRUFnQ1NFR0EwQWdEU0FHUVFKMElnRnFRUUEyQWdBZ0FTQVpha0dBZ0lDUGZEWUNBQ0FCSUJScVFZQ0FnSTk4TmdJQUlBWkJBV29pQmlBTFJ3MEFDd3RCQUNFR0EwQWdEU0FHSUF0cVFRSjBJZ0ZxUVFBMkFnQWdBU0FaYWtHQWdJQ1BmRFlDQUNBQklCUnFRWUNBZ0k5OE5nSUFJQVpCQVdvaUJpQVBSdzBBQ3lBSklBdE9EUUVEUUNBTklBa2dDMnBCQW5RaUFXcEJBRFlDQUNBQklCbHFRWUNBZ0k5OE5nSUFJQUVnRkdwQmdJQ0FqM3cyQWdBZ0NVRUJhaUlKSUF0SERRQUxEQUVMSUFrZ0MwNE5BQ0FKSVFZRFFDQU5JQVpCQW5RaUFXcEJBRFlDQUNBQklCbHFRWUNBZ0k5OE5nSUFJQUVnRkdwQmdJQ0FqM3cyQWdBZ0JrRUJhaUlHSUF0SERRQUxBMEFnRFNBSklBdHFRUUowSWdGcVFRQTJBZ0FnQVNBWmFrR0FnSUNQZkRZQ0FDQUJJQlJxUVlDQWdJOThOZ0lBSUFsQkFXb2lDU0FMUncwQUN3c2dBQ0FGS0FJY05nSW9JQUlnQXlBUklCZ2dBQ2dDRUNBS1FSQnFJQUJCMUFCcUVEa2dBRUVBTmdJMFFYMGhCeUFWSUFVb0FoUWdCU2dDSEdkcVFTQnJUZ1JBSUFVb0Fpd0VRQ0FBUVFFMkFpd0xJQkVnQUNnQ0VHMGhCd3NMSUF4QjBBQnFKQUFnQnd2SEJRSUZmd3A5QWtBQ1FDQUZRd0FBQUFCY0RRQWdCa01BQUFBQVhBMEFJQUFnQVVZTkFTQUFJQUVnQkVFQ2RCQU9HZzhMUVFBaEMwRitJQU5CRHlBRFFROUtHeUlNYXlFTklBeEJmM01oRGtFQklBeHJJUTlCQUNBTWF5RVFJQWhCREd3aUEwR0lPMm9xQWdBZ0JwUWhGQ0FEUVlRN2Fpb0NBQ0FHbENFVklBTkJnRHRxS2dJQUlBYVVJUlpCQUNBS0lBY2dDRVliSUFvZ0JTQUdXeHNnQ2lBQ1FROGdBa0VQU2hzaUNDQU1SaHNpQWtFQlRnUkFJQWRCREd3aUEwR0lPMm9xQWdBZ0JaUWhGeUFEUVlRN2Fpb0NBQ0FGbENFWUlBTkJnRHRxS2dJQUlBV1VJUmxCQWlBTWF5RURJQUVnRDBFQ2RHb3FBZ0FoRVNBQklCQkJBblJxS2dJQUlSSWdBU0FPUVFKMGFpb0NBQ0VUSUFFZ0RVRUNkR29xQWdBaEJVRUFJUW9EUUNBQUlBcEJBblFpQjJvZ0JTQUJJQU1nQ21wQkFuUnFLZ0lBSWhxU0lCUWdCeUFKYWlvQ0FDSUZJQVdVSWdXVWxDQVJJQk9TSUJVZ0JaU1VJQklnRmlBRmxKUWdBU0FIYWlvQ0FDQUJJQW9nQ0d0QkFuUnFJZ2NxQWdBZ0dVTUFBSUEvSUFXVElnV1VsSklnR0NBRmxDQUhLZ0lFSUFkQkJHc3FBZ0NTbEpJZ0Z5QUZsQ0FIS2dJSUlBZEJDR3NxQWdDU2xKS1NrcEk0QWdBZ0V5RUZJQkloRXlBUklSSWdHaUVSSUFwQkFXb2lDaUFDUncwQUN5QUNJUXNMSUFaREFBQUFBRnNFUUNBQUlBRkdEUUVnQUNBQ1FRSjBJZ05xSUFFZ0Eyb2dCQ0FDYTBFQ2RCQU9HZzhMSUFRZ0Myc2lCMEVCU0EwQUlBQWdDMEVDZENJRWFpRURRUUlnREdzaEFpQUJJQVJxSWdFZ0RVRUNkR29xQWdBaEV5QUJJQTVCQW5ScUtnSUFJUVVnQVNBUVFRSjBhaW9DQUNFUklBRWdEMEVDZEdvcUFnQWhFa0VBSVFvRFFDQURJQXBCQW5RaUFHb2dGQ0FUSUFFZ0FpQUtha0VDZEdvcUFnQWlCcEtVSUJVZ0JTQVNrcFFnRmlBUmxDQUFJQUZxS2dJQWtwS1NPQUlBSUFVaEV5QVJJUVVnRWlFUklBWWhFaUFLUVFGcUlnb2dCMGNOQUFzTEM2QUNBUVovSUFOQkFXc2hDRUVmSUFObklnZHJJUVVDUUNBRFFRSklCRUFnQXlFRURBRUxJQU1oQkFOQUlBUWdBaUFHUVFGMElnUkJBbkpxTGdFQUlna2dDV3dnQWlBRWFpNEJBQ0lFSUFSc2FpQUZkbW9oQkNBR1FRSnFJZ1lnQ0VnTkFBc2dBMEYrY1NFR0N5QURJQVpLQkVBZ0JDQUNJQVpCQVhScUxnRUFJZ1FnQkd3Z0JYWnFJUVFMUVFBaEJVRWlJQWNnQkdkcWF5SUVRUUFnQkVFQVNoc2hCQ0FEUVFKSUJIOUJBQVZCQUNFR0EwQWdCU0FDSUFaQkFYUWlCVUVDY21vdUFRQWlCeUFIYkNBQ0lBVnFMZ0VBSWdVZ0JXeHFJQVIyYWlFRklBWkJBbW9pQmlBSVNBMEFDeUFEUVg1eEN5SUdJQU5JQkVBZ0FpQUdRUUYwYWk0QkFDSUNJQUpzSUFSMklBVnFJUVVMSUFFZ0JEWUNBQ0FBSUFVMkFnQUwwd0VCQlg4Z0FFR3dNRUVJRUFNaEFpQUFRZjR3UVFnUUF5RURJQUJCaFRGQkNCQURJUVFnQVNBQVFmNHdRUWdRQXlBQ0lBSkJCVzBpQlVGN2JHcEJBMnhxUVFGMFFaQXdhaUlDTGdFQ0lBSXVBUUFpQW1zaUJrSC8vd054UVpvemJFRVFkaUFHUVJCMVFab3piR29nQUVHRk1VRUlFQU5CRVhSQkVIVkJBWEpzSUFKcUlnQTJBZ1FnQVNBRElBVkJBMnhxUVFGMFFaQXdhaUlCTGdFQ0lBRXVBUUFpQVdzaUFrSC8vd054UVpvemJFRVFkaUFDUVJCMVFab3piR29nQkVFUmRFRVFkVUVCY213Z0FXb2dBR3MyQWdBTHhRSUJBMzhqQUVHUUFXc2lCaVFBSUFBb0FwZ1NJUWNnQmtFQU5nS0lBUUpBQWtBQ1FBSkFJQVFPQXdFQ0FBSUxJQUFnQUNnQzFCSkJBblJxUWZRU2FpZ0NBRUVCUncwQkN5QUdJQWRCRDJwQjhQLy8vd2R4UVFGMGF5SUlKQUFnQUNBQklBQW9BdFFTSUFRZ0JSQW9JQUVnQ0NBQVFjMFZhaUlCTEFBQUlBQkJ6aFZxTEFBQUlBQW9BcGdTRUNjZ0FDQUdJQVVRYmlBQUlBWWdBaUFJRUc4Z0FDQUdJQUpCQUJCRklBQkJBRFlDd0NBZ0FFRUFOZ0xJRWlBQUlBRXNBQUEyQXNRZ0RBRUxJQUFnQmlBQ1FRRVFSUXNnQUVIRUNtb2lBU0FCSUFBb0FwZ1NJZ1JCQVhScUlBQW9BcUFTSUFSclFRRjBJZ0VRRGlBQmFpQUNJQUFvQXBnU1FRRjBFQVFhSUFBZ0JpQUNJQWNRZVNBQUlBSWdCeEJ5SUFBZ0FDZ0NsQkpCQW5RZ0JtcEJCR3NvQWdBMkFvUVNJQU1nQnpZQ0FDQUdRWkFCYWlRQVFRQUw5UVlDQ244RWZpTUFRZUFBYXlFR0FuOENRQ0FCUVFCS0JFQURRQ0FHSUFKQkFuUnFJQUFnQWtFQmRHb3VBUUFpQlVFTWREWUNBQ0FFSUFWcUlRUWdBa0VCYWlJQ0lBRkhEUUFMSUFSQi94OUtCRUJCQUE4TElBRkJBV3NoQWtLQWdJQ0FCQ0VNSUFGQkFrZ0VRQ0FDSVFRTUFnc0RRQ0FHSUFJaUFFRUNkR29vQWdBaUJFR2UzLzhIYWtHOHZ2OFBTd1JBUVFBUEMwRUFJQXhCZ0lDQWdBUkJBQ0FFUVFkMGE2d2lEU0FOZmtJZ2lLZHJJZ1dzZmtJZWlLZEJmSEVpQ2tIdXhnWklEUU1hUVFBaEJFRUFRZi8vLy84QklBVWdCU0FGUVI5MUlnSnFJQUp6WnlJRlFRRnJkQ0lEUVJCMUlnaHRJZ2RCRUhRaUNVRVFkU0lDSUFOQi8vOERjV3hCRUhVZ0FpQUliR3BCQTNScklnTWdCMEVQZFVFQmFrRUJkV3dnQ1dvZ0EwRVFkU0FDYkdvZ0EwSDQvd054SUFKc1FSQjFhcXdoRGlBQlFRRjJJZ0ZCQVNBQlFRRkxHeUVKUVI4Z0JXdXRJUThEUUNBR0lBUkJBblJxSWdNb0FnQWlBaUFHSUFBZ0JFRi9jMnBCQW5ScUlnc29BZ0FpQWF3Z0RYNUNIb2hDQVh4Q0FZaW5JZ2hySWdkQmdJQ0FnSGhCLy8vLy93Y2dCMEYvU2lJSEd5QUlJQUlnQnh0QmYzTWdBaUFJSUFjYmNVRi9TaHVzSUE1K0lRd0NmZ0pBQWtBZ0JVRWZSZ1JBSUF4Q0FZTWdERUlCaDN3aURFS0FnSUNBQ0h4Qy8vLy8vdzlZRFFGQkFBOExJQXdnRDRkQ0FYeENBWWNpREVLQWdJQ0FDSHhDLy8vLy93OVlEUUZCQUE4TElBTWdERDRDQUNBQklBS3NJQTErUWg2SVFnRjhRZ0dJcHlJQ2F5SURRWUNBZ0lCNFFmLy8vLzhISUFOQmYwb2lBeHNnQWlBQklBTWJRWDl6SUFFZ0FpQURHM0ZCZjBvYnJDQU9maUlNUWdHRElBeENBWWQ4REFFTElBTWdERDRDQUNBQklBS3NJQTErUWg2SVFnRjhRZ0dJcHlJQ2F5SURRWUNBZ0lCNFFmLy8vLzhISUFOQmYwb2lBeHNnQWlBQklBTWJRWDl6SUFFZ0FpQURHM0ZCZjBvYnJDQU9maUFQaDBJQmZFSUJod3NpREVLQWdJQ0FDSHhDLy8vLy93OVdCRUJCQUE4TElBc2dERDRDQUNBRVFRRnFJZ1FnQ1VjTkFBc2dBRUVCYXlFQ0lBcXNJUXhCQUNFRUlBQWlBVUVCU2cwQUN3d0JDeUFCUVFGcklRUkNnSUNBZ0FRaERBdEJBQ0FHSUFSQkFuUnFLQUlBUVo3Zi93ZHFRYnkrL3c5TERRQWFRUUFnREVLQWdJQ0FnSUNBZ01BQVFRQWdCaWdDQUVFSGRHdXNJZ3dnREg1Q2dJQ0FnUEQvLy8vL0FJTjlRaUNIZmtJZWlLZEJmSEVpQUNBQVFlN0dCa2diQ3dzcEFRRi9Jd0JCRUdzaUFpUUFJQUlnQVRZQ0RFR1E5QUVvQWdBZ0FDQUJFSXNCSUFKQkVHb2tBQXU1QXdNQ2Z3RitBbndnQUwwaUEwSS9pS2NoQVFKQUFrQUNmQUpBSUFBQ2Z3SkFBa0FnQTBJZ2lLZEIvLy8vL3dkeElnSkJxOGFZaEFSUEJFQWdBTDFDLy8vLy8vLy8vLy8vQUlOQ2dJQ0FnSUNBZ1BqL0FGWUVRQ0FBRHdzZ0FFVHZPZnIrUWk2R1FHUkJBWE5GQkVBZ0FFUUFBQUFBQUFEZ2Y2SVBDeUFBUk5LOGV0MHJJNGJBWTBFQmN3MEJJQUJFVVRBdDFSQkpoOEJqUlEwQkRBWUxJQUpCdzl6WS9nTkpEUU1nQWtHeXhjTC9BMGtOQVFzZ0FFVCtnaXRsUnhYM1A2SWdBVUVEZEVIZzNRRnFLd01Bb0NJQW1VUUFBQUFBQUFEZ1FXTUVRQ0FBcWd3Q0MwR0FnSUNBZUF3QkN5QUJRUUZ6SUFGckN5SUJ0eUlFUkFBQTRQNUNMdWEvb3FBaUFDQUVSSFk4ZVRYdk9lbzlvaUlGb1F3QkN5QUNRWUNBd1BFRFRRMENRUUFoQVNBQUN5RUVJQUFnQkNBRUlBUWdCS0lpQUNBQUlBQWdBQ0FBUk5Da3ZuSnBOMlkrb2tUeGE5TEZRYjI3dnFDaVJDemVKYTlxVmhFL29LSkVrNzIrRm16QlpyK2dva1ErVlZWVlZWWEZQNkNpb1NJQW9rUUFBQUFBQUFBQVFDQUFvYU1nQmFHZ1JBQUFBQUFBQVBBL29DRUVJQUZGRFFBZ0JDQUJFQlFoQkFzZ0JBOExJQUJFQUFBQUFBQUE4RCtnQzdBQkFRUi9JQUFvQWd3aEJBSkFJQUFvQWhBaUJVRUJhaUlDUVNGSkJFQWdCU0VEREFFTEEwQWdBQ0FBS0FJRUlnTWdBQ2dDQ0NJQ0lBQW9BaGhxU3dSL0lBQWdBa0VCYWlJQ05nSUlJQUFvQWdBZ0F5QUNhMm9nQkRvQUFFRUFCVUYvQ3lBQUtBSXNjallDTENBRVFRaDJJUVFnQlVFUFNpRUNJQVZCQ0dzaUF5RUZJQUlOQUFzZ0EwRUJhaUVDQ3lBQUlBSTJBaEFnQUNBQklBTjBJQVJ5TmdJTUlBQWdBQ2dDRkVFQmFqWUNGQXVTQXdFQ2Z5QUFLQUljSWdRZ0EyNGhCU0FBQW44Z0FRUkFJQUFnQUNnQ0lDQUZJQUVnQTJ0c0lBUnFhallDSUNBRklBSWdBV3RzREFFTElBVWdBaUFEYTJ3Z0JHb0xJZ00yQWh3Z0EwR0FnSUFFVFFSQUlBQW9BaUFoQVFOQUFrQWdBVUVYZGlJRlFmOEJSd1JBSUFGQkgzWWhBaUFBS0FJb0lnUkJBRTRFUUVGL0lRRWdBQ0FBS0FJRUlBQW9BaGdpQXlBQUtBSUlha3NFZnlBQUlBTkJBV28yQWhnZ0FDZ0NBQ0FEYWlBQ0lBUnFPZ0FBUVFBRlFYOExJQUFvQWl4eU5nSXNDeUFBS0FJa0lnRUVRQ0FDUVFGcklRUURRRUYvSVFNZ0FDQUFLQUlFSUFBb0FoZ2lBaUFBS0FJSWFrc0VmeUFBSUFKQkFXbzJBaGdnQUNnQ0FDQUNhaUFFT2dBQVFRQWhBeUFBS0FJa0JTQUJDMEVCYXlJQk5nSWtJQUFnQUNnQ0xDQURjallDTENBQkRRQUxDeUFBSUFWQi93RnhOZ0lvSUFBb0Fod2hBeUFBS0FJZ0lRRU1BUXNnQUNBQUtBSWtRUUZxTmdJa0N5QUFJQU5CQ0hRaUF6WUNIQ0FBSUFGQkNIUkJnUDcvL3dkeElnRTJBaUFnQUNBQUtBSVVRUWhxTmdJVUlBTkJnWUNBQkVrTkFBc0xDOThGQVFwL0l3QWlEU0VWSUFBb0FnZ2hFeUFBS0FJRUlSQWdEU0FBS0FJc0loUWdDWFFpRDBFQ2RFRVBha0Z3Y1dzaURpUUFJQUFvQWlSQkFDQUpJQWdiYXlFU1FRRWdDWFFpRVVFQklBZ2JJUTBnRkNBUElBZ2JJUWdDUUFKQUlBWkJBVWNOQUNBSFFRSkhEUUFnQUNBQklBNGdBeUFFSUFVZ0VTQUtJQXNRRWlBQ0tBSUVJQkJCQW0xQkFuUnFJQTRnRDBFQ2RCQUVJUUVnRFVFQlNBMEJJQUJCUUdzaEEwRUFJUWtEUUNBRElBRWdDVUVDZEdvZ0FpZ0NBQ0FJSUFsc1FRSjBhaUFBS0FJOElCQWdFaUFORUJjZ0NVRUJhaUlKSUExSERRQUxJQTFCQVVnTkFTQUFRVUJySVFGQkFDRUpBMEFnQVNBT0lBbEJBblJxSUFJb0FnUWdDQ0FKYkVFQ2RHb2dBQ2dDUENBUUlCSWdEUkFYSUFsQkFXb2lDU0FOUncwQUN3d0JDd0pBSUFaQkFrWkJBQ0FIUVFGR0cwVUVRQ0FIUVFFZ0IwRUJTaHNoQjBFQUlRWWdEVUVCU0EwQklBQkJRR3NoRkFOQUlBQWdBU0FHSUE5c1FRSjBhaUFPSUFNZ0JpQVRiRUVDZEdvZ0JDQUZJQkVnQ2lBTEVCSWdBaUFHUVFKMGFpRVdRUUFoQ1FOQUlCUWdEaUFKUVFKMGFpQVdLQUlBSUFnZ0NXeEJBblJxSUFBb0Fqd2dFQ0FTSUEwUUZ5QUpRUUZxSWdrZ0RVY05BQXNnQmtFQmFpSUdJQWRIRFFBTERBSUxJQUlvQWdBaEJpQUFJQUVnRGlBRElBUWdCU0FSSUFvZ0N4QVNJQUFnQVNBUFFRSjBhaUFHSUJCQkFtMUJBblJxSWdFZ0F5QVRRUUowYWlBRUlBVWdFU0FLSUFzUUVrRUFJUWtnRDBFQVNnUkFBMEFnRGlBSlFRSjBJZ05xSWdRZ0JDb0NBRU1BQUFBL2xDQUJJQU5xS2dJQVF3QUFBRCtVa2pnQ0FDQUpRUUZxSWdrZ0QwY05BQXNMSUExQkFVZ05BU0FBUVVCcklRRkJBQ0VKQTBBZ0FTQU9JQWxCQW5ScUlBSW9BZ0FnQ0NBSmJFRUNkR29nQUNnQ1BDQVFJQklnRFJBWElBbEJBV29pQ1NBTlJ3MEFDd3dCQ3dOQUlBQWdBU0FHSUE5c1FRSjBhaUFPSUFNZ0JpQVRiRUVDZEdvZ0JDQUZJQkVnQ2lBTEVCSWdCa0VCYWlJR0lBZEhEUUFMQ3lBVkpBQUxteElDQ244RGZTQUFLQUlRSVJBZ0FDZ0NBQ0VNUVFFaEN5QUZLQUlBSWcwZ0FDZ0NDQ0lUS0FJNElBQW9BZ3dpRDBFQmRHb3VBUUFnQ0VFRGRHb2lDR3RCSUdzaUVTQUlRUUYxUVhCQmZDQUVRUUpHSUFsQkFFZHhJZ2diYWlBRVFRRjBRWDVCZnlBSUcyb2lDR3dnRFdvZ0NHMGlDQ0FJSUJGS0d5SUlRY0FBSUFoQndBQklHeUlJUVFST0JFQWdDRUVIY1VFQmRFSHdPbW91QVFCQkRpQUlRUU4yYTNWQkFXcEJmbkVoQ3dzZ0FDZ0NIQ0VOSUF0QkFTQUxJQWtiSUE4Z0VFZ2JJUXNDZndKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBSUF3RVFDQUFLQUlrSVJBZ0FpQURJQWtnQkNBQUtBSXNFSlVCSVFnZ0RSQUxJUkVnQzBFQlJnMEVBbjhDUUNBSkJFQWdBQ2dDTUNJQURRRWdDQ0FMYkVHQVFHdEJEblVNQWdzQ1FDQUxJQWdnQzJ3aURFR0FRR3NpRGtFT2RTSUlUQVJBSUFnaEFBd0JDeUFNUVlEQUFFZ0VRQ0FJSVFBTUFRc2dBQ2dDT0VVRVFDQUlJUUFNQVFzZ0RrR0FnSDl4SUFzaUFHNUJFSFFpRGtFTmRTQU9RUkIxYkVHQWdBSnFRUkIxSWd3Z0RFR09lMnhCZ0lBQmFrRVBkVUhWd0FCcWJFRUJkRUdBZ0lydkFXdEJFSFVnREd4QmdJQUJha0VQZGlBTWEwRVFkRUdBZ0lDQWVHdEJFSFVpRW1jaUZFR0FnSUNBQkNBT2F5SU1RUTExSUF4QkVIVnNRWUNBQW1wQkVIVWlEQ0FNUVk1N2JFR0FnQUZxUVE5MVFkWEFBR3BzUVFGMFFZQ0FpdThCYTBFUWRTQU1iRUdBZ0FGcVFROTJJQXhyUVJCMFFZQ0FnSUI0YTBFUWRTSU1aeUlPYTBFTGRDQVNJQlJCRVd0MFFSQjBRUkIxSWhKQjIydHNRWUNBQVdwQkQzVkIvRDFxSUJKc1FZQ0FBV3BCRDNacklBd2dEa0VSYTNSQkVIUkJFSFVpREVIYmEyeEJnSUFCYWtFUGRVSDhQV29nREd4QmdJQUJha0VQZG1wQkVIUkJFSFVnQkVFWGRFR0FnSUFFYTBFUWRXeEJnSUFCYWtFUGRTSU1JQVVvQWdBaURrb05BRUVBSUFnZ0RFRUFJQTVyU0JzaEFBc2dCMEVCVEEwRERBa0xJQUJCZjNOQkgzWkJBQ0FJSUF0c1FmLy9BVUdCZ0g0Z0NFR0F3QUJLR3lBTGJXb2lBRUVPZFNBQVFRQklHeUlBSUF0QkFXc2dBQ0FMU0J0cUN5RUFJQVJCQWt3TkJ5QU5JQXRCQW0waUIwRURiRUVEYWlJSUlBZEJmM05xSUFCcUlBQkJBMndpQ1NBQUlBZEtJZ3diSUFnZ0Iyc2dBR29nQ1VFRGFpQU1HeUFISUFocUVDRWdBRUVPZENJQUlBdHVJUWdNQ0FzZ0RSQUxJUkVnQzBFQlJnMEVBa0FnQkVFRFNBMEFJQWxGRFFBZ0RRSi9JQTBnQzBFQ2JTSUFRUUZxSWdkQkEyd2lBaUFBYWlJSUVGSWlBeUFDU0FSQUlBTkJBMjBNQVFzZ0F5QUhRUUYwYXdzaUNTQUNJQUJCZjNOcWFpQUpRUU5zSWdNZ0FDQUpTQ0lIR3lBQ0lBQnJJQWxxSUFOQkEyb2dCeHNnQ0JBeERBTUxRUUFnQjBFQlRDQUpHdzBCSUEwZ0MwRUJhaEFXSVFrTUFnc2dDeUFBYXlJRFFRRnFJZ2NnQUVFQmFpSUlJQUFnQzBFQmRTSUNTaUlKR3lFUElBSkJBV29pQWlBQ2JDRUNJQTBnQ1FSL0lBSWdCeUFEUVFKcWJFRUJkV3NGSUFBZ0NHeEJBWFVMSWdrZ0NTQVBhaUFDRUNFZ0FFRU9kQ0FMYmlFSURBZ0xJQTBDZnlBTklBdEJBWFVpQjBFQmFpSUFJQUJzSWdNUVVpSUNJQUFnQjJ4QkFYVklCRUFnQWtFRGRFRUJjaEE0UVFGclFRRjJJZ2xCQVdvaUFDQUpiRUVCZGd3QkN5QURJQXRCQVdvaUFDQUFRUUYwSUFNZ0FrRi9jMnBCQTNSQkFYSVFPR3RCQVhZaUNXc2lBQ0FMSUFsclFRSnFiRUVCZFdzTElnSWdBQ0FDYWlBREVERUxJQWxCRG5RZ0MyNGhDQXdHQ3lBSlJRMEZRUUFoQ1VFQUlRY0NRQ0FJUVlIQUFFZ05BQ0FBS0FJMERRQkJBU0VISUFSQkFVZ05BRUVBSVFzRFFDQURJQXRCQW5ScUlnY2dCeW9DQUl3NEFnQkJBU0VISUF0QkFXb2lDeUFFUncwQUN3c2dCRUVCU0EwQklCQWdFeWdDQ0NBUGFrRUNkR29xQWdBaUZTQVFJQTlCQW5ScUtnSUFJaFlnRnBSRGZSMlFKcElnRlNBVmxKS1JRMzBka0NhU0loV1ZJUmNnRmlBVmxTRVZBMEFnQWlBSlFRSjBJZ2hxSWdzZ0ZTQUxLZ0lBbENBWElBTWdDR29xQWdDVWtqZ0NBQ0FKUVFGcUlna2dCRWNOQUFzTUFRdEJBQ0VISUFsRkRRTUxRUUFDZjBFQUlBVW9BZ0JCRVVnTkFCcEJBQ0FBS0FJZ1FSRklEUUFhSUF3RVFDQU5JQWNRbWdFZ0J3d0JDeUFOUVFJUUJnc2dBQ2dDTkJzaEJ3d0NDeUFOSUFBZ0MwRUJhaEJSSUFCQkRuUWlBQ0FMYmlFSUlBbEZEUUlMSUFBZ0Mwa0VRRUVBSVFjZ0JFRUJTQTBCSUJBZ0V5Z0NDQ0FQYWtFQ2RHb3FBZ0FpRlNBUUlBOUJBblJxS2dJQUloWWdGcFJEZlIyUUpwSWdGU0FWbEpLUlEzMGRrQ2FTSWhXVklSY2dGaUFWbFNFVlFRQWhDUU5BSUFJZ0NVRUNkQ0lBYWlJSUlCVWdDQ29DQUpRZ0Z5QUFJQU5xS2dJQWxKSTRBZ0FnQ1VFQmFpSUpJQVJIRFFBTERBRUxJQVJCQVVnTkFVRUFJUWtEUUNBQ0lBbEJBblFpQUdvaUJ5QUhLZ0lBUS9NRU5UK1VJaFVnQUNBRGFpSUFLZ0lBUS9NRU5UK1VJaGFTT0FJQUlBQWdGaUFWa3pnQ0FDQUpRUUZxSWdrZ0JFY05BQXNNQVFzZ0RSQUxJUUFnQlNBRktBSUFJQUFnRVdzaUFHczJBZ0FNQVFzZ0RSQUxJUUFnQlNBRktBSUFJQUFnRVdzaUFHczJBZ0JCZ0lBQklRa2dDRUdBZ0FGR0RRRWdDQTBDSUFnaEJ3c2dDaUFLS0FJQVFYOGdCblJCZjNOeE5nSUFRZi8vQVNFRFFRQWhDVUVBSVFKQmdJQi9EQUlMSUFvZ0NpZ0NBRUYvSUFaMFFYOXpJQVowY1RZQ0FFSC8vd0VoQWtFQUlRZEJBQ0VEUVlDQUFRd0JDMEVBSVFjZ0NDRUpJQWhCRUhRaUJVRU5kU0FGUVJCMWJFR0FnQUpxUVJCMUlnSWdBa0dPZTJ4QmdJQUJha0VQZFVIVndBQnFiRUVCZEVHQWdJcnZBV3RCRUhVZ0FteEJnSUFCYWtFUGRpQUNhMEVRZEVHQWdJQ0FlR3RCRUhVaUEyY2lCa0dBZ0lDQUJDQUZheUlDUVExMUlBSkJFSFZzUVlDQUFtcEJFSFVpQWlBQ1FZNTdiRUdBZ0FGcVFROTFRZFhBQUdwc1FRRjBRWUNBaXU4QmEwRVFkU0FDYkVHQWdBRnFRUTkySUFKclFSQjBRWUNBZ0lCNGEwRVFkU0lDWnlJRmEwRUxkQ0FESUFaQkVXdDBRUkIwUVJCMUlnWkIyMnRzUVlDQUFXcEJEM1ZCL0QxcUlBWnNRWUNBQVdwQkQzWnJJQUlnQlVFUmEzUkJFSFJCRUhVaUJVSGJhMnhCZ0lBQmFrRVBkVUg4UFdvZ0JXeEJnSUFCYWtFUGRtcEJFSFJCRUhVZ0JFRVhkRUdBZ0lBRWEwRVFkV3hCZ0lBQmFrRVBkUXNoQkNBQklBQTJBaFFnQVNBSk5nSVFJQUVnQkRZQ0RDQUJJQUkyQWdnZ0FTQUROZ0lFSUFFZ0J6WUNBQXVaQ3dJSWZ3VjlJd0JCSUdzaURDUUFJQXdnQ2pZQ0dDQU1JQVEyQWh3Z0FDZ0NIQ0VFSUFBb0FnQWhEd0pBSUFOQkFVWUVRRUVDUVFFZ0Foc2lBMEVCSUFOQkFVc2JJUVlnQUNnQ0lDRURBa0FnRHdSQVFRQWhCU0FEUVFoT0JFQWdCQ0FCS2dJQVF3QUFBQUJkSWdVUUlDQUFJQUFvQWlCQkNHc2lBellDSUFzZ0FDZ0NCQVJBSUFGREFBQ0F2ME1BQUlBL0lBVWJPQUlBQ3lBQ1JRMEJRUUVoQ2dOQVFRQWhCU0FEUVFoT0JFQWdCQ0FDS2dJQVF3QUFBQUJkSWdVUUlDQUFJQUFvQWlCQkNHc2lBellDSUFzZ0FDZ0NCQVJBSUFKREFBQ0F2ME1BQUlBL0lBVWJPQUlBQ3lBS1FRRnFJZ29nQmtjTkFBc01BUXRCQUNFRklBTkJDRTRFUUNBRVFRRVFDU0VGSUFBZ0FDZ0NJRUVJYXlJRE5nSWdDeUFBS0FJRUJFQWdBVU1BQUlDL1F3QUFnRDhnQlJzNEFnQUxJQUpGRFFCQkFTRUtBMEJCQUNFRklBTkJDRTRFUUNBRVFRRVFDU0VGSUFBZ0FDZ0NJRUVJYXlJRE5nSWdDeUFBS0FJRUJFQWdBa01BQUlDL1F3QUFnRDhnQlJzNEFnQUxJQXBCQVdvaUNpQUdSdzBBQ3d0QkFTRUhJQWhGRFFFZ0NDQUJLZ0lBT0FJQURBRUxJQUFnRENBQklBSWdBeUFNUVJ4cUlBVWdCU0FIUVFFZ0RFRVlhaEFqSUF3b0FnaXlRd0FBQURpVUlSTWdEQ2dDQkxKREFBQUFPSlFoRlNBTUtBSVVJUXNnRENnQ0VDRU5JQXdvQWdBaEVRSkFJQU5CQWtZRVFDQU1LQUljSVE0Z0FDQUFLQUlnSUExQi8vOStjU0lTUVFCSFFRTjBJaEFnQzJwck5nSWdJQUVnQWlBTlFZREFBRW9pRFJzaEN5QUNJQUVnRFJzaERTQU9JQkJySVJCQkFDRU9Ba0FnRWtVTkFDQVBCRUFnQkNBTktnSUFJQXNxQWdTVUlBMHFBZ1FnQ3lvQ0FKU1RRd0FBQUFCZElnNFFJQXdCQ3lBRVFRRVFDU0VPQ3lBQUlBMUJBaUFRSUFVZ0JpQUhJQWhEQUFDQVB5QUpJQW9RQ2lFSElBc2dEU29DQkVFQVFRRWdEa0VCZEdzaUJHdXlsRGdDQUNBTElBMHFBZ0FnQkxLVU9BSUVJQUFvQWdSRkRRRWdBU0FWSUFFcUFnQ1VPQUlBSUFFZ0ZTQUJLZ0lFbERnQ0JDQUNJQk1nQWlvQ0FKUWlGRGdDQUNBQ0lCTWdBaW9DQkpRNEFnUWdBU0FCS2dJQUloTWdGSk00QWdBZ0FpQVRJQUlxQWdDU09BSUFJQUVnQVNvQ0JDSVRJQUlxQWdTVE9BSUVJQUlnRXlBQ0tnSUVramdDQkF3QkN5QU1LQUljSVFRZ0RDZ0NEQ0VQSUFBZ0FDZ0NJQ0FMYXlJT05nSWdJQXdvQWhnaENpQUVJQVFnRDJ0QkFtMGlDeUFFSUF0SUd5SUxRUUFnQzBFQVNoc2lDeUFFSUF0cklnUk9CRUFnQUNBQklBTWdDeUFGSUFZZ0J5QUlRd0FBZ0Q4Z0NTQUtFQW9nQUNBQ0lBTWdCQ0FBS0FJZ0lBNXJJQXRxSWdSQkdHdEJBQ0FFUVJoS0cwRUFJQTBiYWlBRlFRQWdCMEVBSUJOQkFDQUtJQVYxRUFweUlRY01BUXNnQUNBQ0lBTWdCQ0FGUVFBZ0IwRUFJQk5CQUNBS0lBVjFFQW9nQUNBQklBTWdBQ2dDSUNBT2F5QUVhaUlFUVJoclFRQWdCRUVZU2h0QkFDQU5RWUNBQVVjYklBdHFJQVVnQmlBSElBaERBQUNBUHlBSklBb1FDbkloQndzZ0FDZ0NCRVVOQUFKQUlBTkJBa1lOQUVNQUFBQUFJUlFDUUNBRFFRRklCRUJEQUFBQUFDRVREQUVMUVFBaEFFTUFBQUFBSVJNRFFDQVRJQUlnQUVFQ2RDSUVhaW9DQUNJV0lBRWdCR29xQWdDVWtpRVRJQlFnRmlBV2xKSWhGQ0FBUVFGcUlnQWdBMGNOQUFzTEFrQWdGU0FWbENBVWtpSVVJQlVnRTVRaUV5QVRraUlUa2lJV1ExSkpIVHBkUlFSQUlCUWdFNU1pRTBOU1NSMDZYVUVCY3cwQkN5QUNJQUVnQTBFQ2RCQUVHZ3dCQ3lBRFFRRklEUUZEQUFDQVB5QVdrWlVoRkVNQUFJQS9JQk9SbFNFVFFRQWhBQU5BSUFFZ0FFRUNkQ0lFYWlJRklCTWdGU0FGS2dJQWxDSVdJQUlnQkdvaUJDb0NBQ0lYazVRNEFnQWdCQ0FVSUJZZ0Y1S1VPQUlBSUFCQkFXb2lBQ0FEUncwQUN3c2dFVVVOQUNBRFFRRklEUUJCQUNFQUEwQWdBaUFBUVFKMGFpSUJJQUVxQWdDTU9BSUFJQUJCQVdvaUFDQURSdzBBQ3dzZ0RFRWdhaVFBSUFjTEVBQWdBU0FBUWNrd1FRZ1FBellDQUF0ZkFDQUFRUVJxUVFCQnBDRVFCUm9nQUVFQU5nTElJQ0FBUVlDQUJEWUNBQ0FBUVFFMkFzZ1NJQUFRZWlBQVFaUWhha0tBZ0lTQWdJREFBRGNDQUNBQVFhQWhha0tDZ0lDQXdBSTNBZ0FnQUNBQUtBS1lFa0VIZERZQ3pDQkJBQXVwQ1FFSWZ5TUFRYUFCYXlJSkpBQWdBQ0FDUVFGMVFRbHNRZUF6YWtFSUVBTWhCUUpBSUFSQkJIVWdCRUZ3Y1NBRVNHb2lDMEVBVEEwQUlBVkJFbXhCb0RKcUlRY0RRRUVBSVFVZ0NTQUdRUUowSWdocUlncEJBRFlDQUNBSlFkQUFhaUFJYWlJSUlBQWdCMEVJRUFNaUREWUNBQ0FNUVJGR0JFQURRQ0FJSUFBZ0JVRUJhaUlGUVFwR1FjSXpha0VJRUFNaUREWUNBQ0FNUVJGR0RRQUxJQW9nQlRZQ0FBc2dCa0VCYWlJR0lBdEhEUUFMUVFBaEJTQUxRUUJNRFFBRFFDQUJJQVZCRUhSQkMzVnFJUVlDUUNBSlFkQUFhaUFGUVFKMGFpZ0NBQ0lIUVFGT0JFQWdCaUFBSUFjUVpnd0JDeUFHUWdBM0FRQWdCa0lBTndFWUlBWkNBRGNCRUNBR1FnQTNBUWdMSUFWQkFXb2lCU0FMUncwQUMwRUFJUW9nQzBFQVRBMEFBMEFnQ1NBS1FRSjBJZ3hxS0FJQUlnaEJBVTRFUUNBQklBcEJFSFJCQzNWcUlnY3ZBUUFoQlVFQUlRWURRQ0FBUWVBd1FRZ1FBeUFGUVFGMGFpRUZJQVpCQVdvaUJpQUlSdzBBQ3lBSElBVTdBUUFnQnk4QkFpRUZRUUFoQmdOQUlBQkI0REJCQ0JBRElBVkJBWFJxSVFVZ0JrRUJhaUlHSUFoSERRQUxJQWNnQlRzQkFpQUhMd0VFSVFWQkFDRUdBMEFnQUVIZ01FRUlFQU1nQlVFQmRHb2hCU0FHUVFGcUlnWWdDRWNOQUFzZ0J5QUZPd0VFSUFjdkFRWWhCVUVBSVFZRFFDQUFRZUF3UVFnUUF5QUZRUUYwYWlFRklBWkJBV29pQmlBSVJ3MEFDeUFISUFVN0FRWWdCeThCQ0NFRlFRQWhCZ05BSUFCQjREQkJDQkFESUFWQkFYUnFJUVVnQmtFQmFpSUdJQWhIRFFBTElBY2dCVHNCQ0NBSEx3RUtJUVZCQUNFR0EwQWdBRUhnTUVFSUVBTWdCVUVCZEdvaEJTQUdRUUZxSWdZZ0NFY05BQXNnQnlBRk93RUtJQWN2QVF3aEJVRUFJUVlEUUNBQVFlQXdRUWdRQXlBRlFRRjBhaUVGSUFaQkFXb2lCaUFJUncwQUN5QUhJQVU3QVF3Z0J5OEJEaUVGUVFBaEJnTkFJQUJCNERCQkNCQURJQVZCQVhScUlRVWdCa0VCYWlJR0lBaEhEUUFMSUFjZ0JUc0JEaUFITHdFUUlRVkJBQ0VHQTBBZ0FFSGdNRUVJRUFNZ0JVRUJkR29oQlNBR1FRRnFJZ1lnQ0VjTkFBc2dCeUFGT3dFUUlBY3ZBUkloQlVFQUlRWURRQ0FBUWVBd1FRZ1FBeUFGUVFGMGFpRUZJQVpCQVdvaUJpQUlSdzBBQ3lBSElBVTdBUklnQnk4QkZDRUZRUUFoQmdOQUlBQkI0REJCQ0JBRElBVkJBWFJxSVFVZ0JrRUJhaUlHSUFoSERRQUxJQWNnQlRzQkZDQUhMd0VXSVFWQkFDRUdBMEFnQUVIZ01FRUlFQU1nQlVFQmRHb2hCU0FHUVFGcUlnWWdDRWNOQUFzZ0J5QUZPd0VXSUFjdkFSZ2hCVUVBSVFZRFFDQUFRZUF3UVFnUUF5QUZRUUYwYWlFRklBWkJBV29pQmlBSVJ3MEFDeUFISUFVN0FSZ2dCeThCR2lFRlFRQWhCZ05BSUFCQjREQkJDQkFESUFWQkFYUnFJUVVnQmtFQmFpSUdJQWhIRFFBTElBY2dCVHNCR2lBSEx3RWNJUVZCQUNFR0EwQWdBRUhnTUVFSUVBTWdCVUVCZEdvaEJTQUdRUUZxSWdZZ0NFY05BQXNnQnlBRk93RWNJQWN2QVI0aEJVRUFJUVlEUUNBQVFlQXdRUWdRQXlBRlFRRjBhaUVGSUFaQkFXb2lCaUFJUncwQUN5QUhJQVU3QVI0Z0NVSFFBR29nREdvaUJTQUZLQUlBSUFoQkJYUnlOZ0lBQ3lBS1FRRnFJZ29nQzBjTkFBc0xJQUFnQVNBRUlBSWdBeUFKUWRBQWFoQndJQWxCb0FGcUpBQUx4UVlCQVg4akFFRXdheUlGSkFBZ0FFSE9GV29DZndKQUlBTkZCRUFnQUNBQ1FRSjBha0hrRW1vb0FnQkZEUUVMSUFGQjVUQkJDQkFEUVFKcURBRUxJQUZCNlRCQkNCQURDeUlEUVFGeE9nQUFJQUJCelJWcUlBTkJBWFlpQWpvQUFBSkFJQVJCQWtZRVFDQUFJQUZCNEM5QkNCQURPZ0N3RlF3QkN5QUFJQUVnQWtFWWRFRVZkVUhBTDJwQkNCQURRUU4wT2dDd0ZTQUFJQUZCa0RGQkNCQURJQUF0QUxBVmFqb0FzQlVMSUFBb0FwUVNRUUpPQkVCQkFTRURBMEFnQUNBRGFrR3dGV29nQVVIZ0wwRUlFQU02QUFBZ0EwRUJhaUlESUFBb0FwUVNTQTBBQ3dzZ0FFRzRGV29nQVNBQUtBS3NGU0lDS0FJUUlBSXVBUUFnQUN3QXpSVkJBWFZzYWtFSUVBTWlBam9BQUNBRlFSQnFJQVVnQUNnQ3JCVWdBa0VZZEVFWWRSQkdJQUFvQXF3VklnSXVBUUpCQVU0RVFFRUFJUU1EUUFKQUFrQUNRQ0FCSUFJb0Fod2dCVUVRYWlBRFFRRjBhaTRCQUdwQkNCQURJZ0lPQ1FBQ0FnSUNBZ0lDQVFJTFFRQWdBVUdZTVVFSUVBTnJJUUlNQVFzZ0FVR1lNVUVJRUFOQkNHb2hBZ3NnQUNBRFFRRnFJZ05xUWJnVmFpQUNRUVJyT2dBQUlBTWdBQ2dDckJVaUFpNEJBa2dOQUFzTFFRUWhBeUFBUWM4VmFpQUFLQUtVRWtFRVJnUi9JQUZCNnpCQkNCQURCVUVFQ3pvQUFDQUFMUURORlVFQ1JnUkFBa0FDUUNBRVFRSkhEUUFnQUNnQzNCSkJBa2NOQUNBQlFjQXhRUWdRQXlJQ1FSQjBRUUZJRFFBZ0FFSEtGV29nQWlBQUx3SGdFbXBCQ1dzaUFqc0JBQXdCQ3lBQVFjb1ZhaUlDSUFGQm9ERkJDQkFESUFBb0Fvd1NRUUYyYkRzQkFDQUNJQUVnQUNnQ3pCSkJDQkFESUFJdkFRQnFJZ0k3QVFBTElBQWdBanNCNEJJZ0FFSE1GV29nQVNBQUtBTFFFa0VJRUFNNkFBQWdBRUhRRldvZ0FVSFNFRUVJRUFNaUFqb0FBRUVCSVFNQ1FDQUFLQUtVRWtFQlNBMEFJQUJCdEJWcUlBRWdBa0VZZEVFV2RVR1FFV29vQWdCQkNCQURPZ0FBSUFBb0FwUVNRUUpJRFFBRFFDQUFJQU5xUWJRVmFpQUJJQUFzQU5BVlFRSjBRWkFSYWlnQ0FFRUlFQU02QUFBZ0EwRUJhaUlESUFBb0FwUVNTQTBBQ3d0QkFDRURJQUJCMFJWcUlBUUVmMEVBQlNBQlFlSXdRUWdRQXdzNkFBQUxJQUFnQUN3QXpSVTJBdHdTSUFCQjBoVnFJQUZCZ1RGQkNCQURPZ0FBSUFWQk1Hb2tBQXZBQVFFRWZ5QUJRUUZySVFRZ0FVRUNUZ1JBSUFKQmdJQUVheUVGUVFBaEFRTkFJQUFnQVVFQ2RHb2lBeUFES0FJQUlnTkJFSFJCRUhVaUJpQUNRZi8vQTNGc1FSQjFJQVlnQWtFUWRXeHFJQU5CRDNWQkFXcEJBWFVnQW14cU5nSUFJQUlnQld4QkQzVkJBV3BCQVhVZ0Ftb2hBaUFCUVFGcUlnRWdCRWNOQUFzTElBQWdCRUVDZEdvaUFDQUFLQUlBSWdCQkVIUkJFSFVpQVNBQ1FmLy9BM0ZzUVJCMUlBRWdBa0VRZFd4cUlBQkJEM1ZCQVdwQkFYVWdBbXhxTmdJQUMzNEJBMzhnQVVFQmF5RURJQUZCQWs0RVFDQUNRWUNBQkdzaEJFRUFJUUVEUUNBQUlBRkJBWFJxSWdVZ0FpQUZMZ0VBYkVFUGRrRUJha0VCZGpzQkFDQUNJQVJzUVE5MVFRRnFRUUYxSUFKcUlRSWdBVUVCYWlJQklBTkhEUUFMQ3lBQUlBTkJBWFJxSWdBZ0FpQUFMZ0VBYkVFUGRrRUJha0VCZGpzQkFBdkpDQUlLZndGK0l3QkJ3QUpySWdRa0FFRUJJUU1nQWtFQlRnUkFRWkFKUWFBSklBSkJFRVliSVFrRFFDQUVRZUFCYWlBRklBbHFMUUFBUVFKMGFpQUJJQVZCQVhScUxnRUFJZ1pCQ0hWQkFYUkIwQTVxSWdjdUFRSWdCeTRCQUNJSGF5QUdRZjhCY1d3Z0IwRUlkR3BCQTNWQkFXcEJBWFUyQWdBZ0JVRUJhaUlGSUFKSERRQUxJQVFvQXVBQklRVUxRWUNBQkNFR0lBUkJnSUFFTmdLZ0FTQUVRUUFnQldzaUJUWUNwQUVnQWtFQmRTRUhBa0FnQWtFRVNDSUxEUUFnQlNFQkEwQWdCRUdnQVdvZ0EwRUJhaUlKUVFKMGFpSU1JQVpCQVhRZ0JFSGdBV29nQTBFRGRHb29BZ0FpRGF3aURpQUJySDVDRDRoQ0FYeENBWWluYXpZQ0FDQURRUUowSWdnZ0JFR2dBV3BxSVFvZ0JDQURRUUpQQkg4Z0NpQUVJQWhxS0FLWUFTSUZJQUZxSUFhc0lBNStRZytJUWdGOFFnR0lwMnMyQWdBZ0EwRUNSd1JBQTBBZ0JFR2dBV29nQTBFQmF5SUJRUUowYWlJSUlBTkJBblFnQkdvb0FwUUJJZ1lnQ0NnQ0FHb2dCYXdnRG41Q0Q0aENBWHhDQVlpbmF6WUNBQ0FEUVFOS0lRZ2dBU0VESUFZaEJTQUlEUUFMQ3lBRUtBS2tBUVVnQlFzZ0RXc2lCVFlDcEFFZ0J5QUpSZzBCSUF3b0FnQWhBU0FLS0FJQUlRWWdDU0VEREFBTEFBdEJnSUFFSVFZZ0JFR0FnQVEyQW1BZ0JFRUFJQVFvQXVRQmF5SUZOZ0prQWtBZ0N3MEFJQVJCNEFGcVFRUnlJUXRCQVNFRElBVWhBUU5BSUFSQjRBQnFJQU5CQVdvaUNVRUNkR29pRENBR1FRRjBJQXNnQTBFRGRHb29BZ0FpRGF3aURpQUJySDVDRDRoQ0FYeENBWWluYXpZQ0FDQURRUUowSWdnZ0JFSGdBR3BxSVFvZ0JDQURRUUpQQkg4Z0NpQUVJQWhxS0FKWUlnVWdBV29nQnF3Z0RuNUNENGhDQVh4Q0FZaW5hellDQUNBRFFRSkhCRUFEUUNBRVFlQUFhaUFEUVFGcklnRkJBblJxSWdnZ0EwRUNkQ0FFYWlnQ1ZDSUdJQWdvQWdCcUlBV3NJQTUrUWcrSVFnRjhRZ0dJcDJzMkFnQWdBMEVEU2lFSUlBRWhBeUFHSVFVZ0NBMEFDd3NnQkNnQ1pBVWdCUXNnRFdzaUJUWUNaQ0FISUFsR0RRRWdEQ2dDQUNFQklBb29BZ0FoQmlBSklRTU1BQXNBQ3lBQ1FRSk9CRUFnQjBFQklBZEJBVW9iSVFvZ0JDZ0NZQ0VHSUFRb0FxQUJJUUZCQUNFREEwQWdCQ0FEUVFKMGFrRUFJQU5CQVdvaUJVRUNkQ0lISUFSQjRBQnFhaWdDQUNJSklBWnJJZ1lnQVNBRVFhQUJhaUFIYWlnQ0FDSUhhaUlCYW1zMkFnQWdCQ0FEUVg5eklBSnFRUUowYWlBR0lBRnJOZ0lBSUFraEJpQUhJUUVnQlNJRElBcEhEUUFMQ3lBQUlBUWdBaEIzQWtBZ0FDQUNFQjBOQUVFQUlRVWdBa0VCVGdSQUEwQWdCQ0FDUVg0Z0JYUkJnSUFFYWhBcFFRQWhBd05BSUFBZ0EwRUJkR29nQkNBRFFRSjBhaWdDQUVFRWRrRUJha0VCZGpzQkFDQURRUUZxSWdNZ0FrY05BQXNnQUNBQ0VCMGhBU0FGUVE1TERRSWdCVUVCYWlFRklBRkZEUUFNQWdzQUN3TkFJQVFnQWtGK0lBVjBRWUNBQkdvUUtTQUFJQUlRSFNFQklBVkJEa3NOQVNBRlFRRnFJUVVnQVVVTkFBc0xJQVJCd0FKcUpBQUxueEVDRDM4QmZpTUFRZEFBYXlJRkpBQWdCU0FCTmdKTUlBVkJOMm9oRXlBRlFUaHFJUkZCQUNFQkFrQURRQUpBSUE1QkFFZ05BRUgvLy8vL0J5QU9heUFCU0FSQVFaejdBVUU5TmdJQVFYOGhEZ3dCQ3lBQklBNXFJUTRMSUFVb0Frd2lDaUVCQWtBQ1FBSkFJQW90QUFBaUJnUkFBMEFDUUFKQUlBWkIvd0Z4SWdaRkJFQWdBU0VHREFFTElBWkJKVWNOQVNBQklRWURRQ0FCTFFBQlFTVkhEUUVnQlNBQlFRSnFJZ2cyQWt3Z0JrRUJhaUVHSUFFdEFBSWhDU0FJSVFFZ0NVRWxSZzBBQ3dzZ0JpQUtheUVCSUFBRVFDQUFJQW9nQVJBUUN5QUJEUVlnQlNnQ1RDRUJJQVVDZndKQUlBVW9Ba3dzQUFGQk1HdEJDazhOQUNBQkxRQUNRU1JIRFFBZ0FTd0FBVUV3YXlFUVFRRWhFaUFCUVFOcURBRUxRWDhoRUNBQlFRRnFDeUlCTmdKTVFRQWhEd0pBSUFFc0FBQWlDMEVnYXlJSVFSOUxCRUFnQVNFR0RBRUxJQUVoQmtFQklBaDBJZ2xCaWRFRWNVVU5BQU5BSUFVZ0FVRUJhaUlHTmdKTUlBa2dEM0loRHlBQkxBQUJJZ3RCSUdzaUNFRWdUdzBCSUFZaEFVRUJJQWgwSWdsQmlkRUVjUTBBQ3dzQ1FDQUxRU3BHQkVBZ0JRSi9Ba0FnQml3QUFVRXdhMEVLVHcwQUlBVW9Ba3dpQVMwQUFrRWtSdzBBSUFFc0FBRkJBblFnQkdwQndBRnJRUW8yQWdBZ0FTd0FBVUVEZENBRGFrR0FBMnNvQWdBaERFRUJJUklnQVVFRGFnd0JDeUFTRFFaQkFDRVNRUUFoRENBQUJFQWdBaUFDS0FJQUlnRkJCR28yQWdBZ0FTZ0NBQ0VNQ3lBRktBSk1RUUZxQ3lJQk5nSk1JQXhCZjBvTkFVRUFJQXhySVF3Z0QwR0F3QUJ5SVE4TUFRc2dCVUhNQUdvUVRDSU1RUUJJRFFRZ0JTZ0NUQ0VCQzBGL0lRY0NRQ0FCTFFBQVFTNUhEUUFnQVMwQUFVRXFSZ1JBQWtBZ0FTd0FBa0V3YTBFS1R3MEFJQVVvQWt3aUFTMEFBMEVrUncwQUlBRXNBQUpCQW5RZ0JHcEJ3QUZyUVFvMkFnQWdBU3dBQWtFRGRDQURha0dBQTJzb0FnQWhCeUFGSUFGQkJHb2lBVFlDVEF3Q0N5QVNEUVVnQUFSL0lBSWdBaWdDQUNJQlFRUnFOZ0lBSUFFb0FnQUZRUUFMSVFjZ0JTQUZLQUpNUVFKcUlnRTJBa3dNQVFzZ0JTQUJRUUZxTmdKTUlBVkJ6QUJxRUV3aEJ5QUZLQUpNSVFFTFFRQWhCZ05BSUFZaENVRi9JUTBnQVN3QUFFSEJBR3RCT1VzTkNDQUZJQUZCQVdvaUN6WUNUQ0FCTEFBQUlRWWdDeUVCSUFZZ0NVRTZiR3BCNy9NQmFpMEFBQ0lHUVFGclFRaEpEUUFMQWtBQ1FDQUdRUk5IQkVBZ0JrVU5DaUFRUVFCT0JFQWdCQ0FRUVFKMGFpQUdOZ0lBSUFVZ0F5QVFRUU4wYWlrREFEY0RRQXdDQ3lBQVJRMElJQVZCUUdzZ0JpQUNFRXNnQlNnQ1RDRUxEQUlMSUJCQmYwb05DUXRCQUNFQklBQkZEUWNMSUE5Qi8vOTdjU0lJSUE4Z0QwR0F3QUJ4R3lFR1FRQWhEVUdVOUFFaEVDQVJJUThDUUFKQUFrQUNmd0pBQWtBQ1FBSkFBbjhDUUFKQUFrQUNRQUpBQWtBQ1FDQUxRUUZyTEFBQUlnRkJYM0VnQVNBQlFROXhRUU5HR3lBQklBa2JJZ0ZCMkFCckRpRUVGQlFVRkJRVUZCUU9GQThHRGc0T0ZBWVVGQlFVQWdVREZCUUpGQUVVRkFRQUN3SkFJQUZCd1FCckRnY09GQXNVRGc0T0FBc2dBVUhUQUVZTkNRd1RDeUFGS1FOQUlSUkJsUFFCREFVTFFRQWhBUUpBQWtBQ1FBSkFBa0FDUUFKQUlBbEIvd0Z4RGdnQUFRSURCQm9GQmhvTElBVW9Ba0FnRGpZQ0FBd1pDeUFGS0FKQUlBNDJBZ0FNR0FzZ0JTZ0NRQ0FPckRjREFBd1hDeUFGS0FKQUlBNDdBUUFNRmdzZ0JTZ0NRQ0FPT2dBQURCVUxJQVVvQWtBZ0RqWUNBQXdVQ3lBRktBSkFJQTZzTndNQURCTUxJQWRCQ0NBSFFRaExHeUVISUFaQkNISWhCa0g0QUNFQkN5QUZLUU5BSUJFZ0FVRWdjUkNKQVNFS0lBWkJDSEZGRFFNZ0JTa0RRRkFOQXlBQlFRUjJRWlQwQVdvaEVFRUNJUTBNQXdzZ0JTa0RRQ0FSRUlnQklRb2dCa0VJY1VVTkFpQUhJQkVnQ21zaUFVRUJhaUFCSUFkSUd5RUhEQUlMSUFVcEEwQWlGRUovVndSQUlBVkNBQ0FVZlNJVU53TkFRUUVoRFVHVTlBRU1BUXNnQmtHQUVIRUVRRUVCSVExQmxmUUJEQUVMUVpiMEFVR1U5QUVnQmtFQmNTSU5Hd3NoRUNBVUlCRVFod0VoQ2dzZ0JrSC8vM3R4SUFZZ0IwRi9TaHNoQmlBRktRTkFJUlFDUUNBSERRQWdGRkJGRFFCQkFDRUhJQkVoQ2d3TUN5QUhJQlJRSUJFZ0NtdHFJZ0VnQVNBSFNCc2hCd3dMQ3lBRktBSkFJZ0ZCbnZRQklBRWJJZ29nQnhDUEFTSUJJQWNnQ21vZ0FSc2hEeUFJSVFZZ0FTQUtheUFISUFFYklRY01DZ3NnQndSQUlBVW9Ba0FNQWd0QkFDRUJJQUJCSUNBTVFRQWdCaEFOREFJTElBVkJBRFlDRENBRklBVXBBMEErQWdnZ0JTQUZRUWhxTmdKQVFYOGhCeUFGUVFocUN5RUpRUUFoQVFKQUEwQWdDU2dDQUNJSVJRMEJBa0FnQlVFRWFpQUlFRTBpQ2tFQVNDSUlEUUFnQ2lBSElBRnJTdzBBSUFsQkJHb2hDU0FISUFFZ0Ntb2lBVXNOQVF3Q0N3dEJmeUVOSUFnTkN3c2dBRUVnSUF3Z0FTQUdFQTBnQVVVRVFFRUFJUUVNQVF0QkFDRUpJQVVvQWtBaEN3TkFJQXNvQWdBaUNFVU5BU0FGUVFScUlBZ1FUU0lJSUFscUlna2dBVW9OQVNBQUlBVkJCR29nQ0JBUUlBdEJCR29oQ3lBQklBbExEUUFMQ3lBQVFTQWdEQ0FCSUFaQmdNQUFjeEFOSUF3Z0FTQUJJQXhJR3lFQkRBZ0xJQUFnQlNzRFFDQU1JQWNnQmlBQlFRQVJJd0FoQVF3SEN5QUZJQVVwQTBBOEFEZEJBU0VISUJNaENpQUlJUVlNQkFzZ0JTQUJRUUZxSWdnMkFrd2dBUzBBQVNFR0lBZ2hBUXdBQ3dBTElBNGhEU0FBRFFRZ0VrVU5Ba0VCSVFFRFFDQUVJQUZCQW5ScUtBSUFJZ0FFUUNBRElBRkJBM1JxSUFBZ0FoQkxRUUVoRFNBQlFRRnFJZ0ZCQ2tjTkFRd0dDd3RCQVNFTklBRkJDazhOQkFOQUlBUWdBVUVDZEdvb0FnQU5BU0FCUVFGcUlnRkJDa2NOQUFzTUJBdEJmeUVOREFNTElBQkJJQ0FOSUE4Z0Ntc2lDU0FISUFjZ0NVZ2JJZ2hxSWdzZ0RDQUxJQXhLR3lJQklBc2dCaEFOSUFBZ0VDQU5FQkFnQUVFd0lBRWdDeUFHUVlDQUJITVFEU0FBUVRBZ0NDQUpRUUFRRFNBQUlBb2dDUkFRSUFCQklDQUJJQXNnQmtHQXdBQnpFQTBNQVFzTFFRQWhEUXNnQlVIUUFHb2tBQ0FOQzVJQkFRTjhSQUFBQUFBQUFQQS9JQUFnQUtJaUFrUUFBQUFBQUFEZ1A2SWlBNkVpQkVRQUFBQUFBQUR3UHlBRW9TQURvU0FDSUFJZ0FpQUNSSkFWeXhtZ0Fmbytva1IzVWNFV2JNRld2NkNpUkV4VlZWVlZWYVUvb0tJZ0FpQUNvaUlESUFPaUlBSWdBa1RVT0lpKzZmcW92YUpFeExHMHZaN3VJVDZnb2tTdFVweUFUMzZTdnFDaW9LSWdBQ0FCb3FHZ29BdDRBUUY5QWtBZ0FVRUJTQTBBUVFBaEF3TkFJQVFnQUNBRFFRSjBhaW9DQUNJRUlBU1VraUVFSUFOQkFXb2lBeUFCUncwQUN5QUJRUUZJRFFCREFBQ0FQeUFFUTMwZGtDYVNrWlVnQXBRaEFrRUFJUU1EUUNBQUlBSWdBQ29DQUpRNEFnQWdBRUVFYWlFQUlBTkJBV29pQXlBQlJ3MEFDd3NMOVFjRENYOEVmUUo4QWtBZ0JFRUJkQ0FCVGcwQUlBVkZEUUFnQWJJZ0JVRUNkRUhFM1FGcUtBSUFJQVJzSUFGcXNwVWlEeUFQbEVNQUFBQS9sQ0lQUTlzUHlUK1V1eEJRSVJOREFBQ0FQeUFQazBQYkQ4ay9sTHNRVUNFVVFRQWhCU0FCSUFOQkEzUk9CRUFnQTBFQ2RTRUlRUUVoQkFOQUlBUWlCVUVCYWlFRUlBVWdCU0FGYkdvZ0Eyd2dDR29nQVVnTkFBc0xJQUVnQTI0aENpQURRUUZJRFFBZ0U3WWhEeUFVdGlFUklBcEJBV3NpQ3lBRlFRRjBheUVJSUFvZ0JXc2hEQ0FLUVFOcklRa2dBa0YvU2lFTlFRQWhBZ05BSUFJZ0Ntd2hCZ0pBSUExRkJFQUNRQ0FGUlEwQVFRQWhBU0FBSUFaQkFuUnFJZ2NoQkNBTVFRRk9CRUFEUUNBRUlBVkJBblJxSWc0Z0JDb0NBQ0lRSUErVUlBNHFBZ0FpRWlBUmxKSTRBZ0FnQkNBUUlCR1VJQklnRDVTVE9BSUFJQVJCQkdvaEJDQUJRUUZxSWdFZ0RFY05BQXNMSUFoQkFFZ05BQ0FISUFoQkFuUnFJUVFnQ0NFQkEwQWdCQ0FGUVFKMGFpSUhJQVFxQWdBaUVDQVBsQ0FIS2dJQUloSWdFWlNTT0FJQUlBUWdFQ0FSbENBU0lBK1VremdDQUNBRVFRUnJJUVFnQVVFQVNpRUhJQUZCQVdzaEFTQUhEUUFMQ3lBQUlBWkJBblJxSVFZZ0MwRUJUZ1JBSUFZcUFnQWhFRUVBSVFFZ0JpRUVBMEFnQkNBUUlBK1VJQVFxQWdRaUVpQVJsSk00QWdBZ0JDQVFJQkdVSUJJZ0Q1U1NJaEE0QWdRZ0JFRUVhaUVFSUFGQkFXb2lBU0FMUncwQUN3c2dDVUVBU0EwQklBWWdDVUVDZEdvaEJDQUpJUUVEUUNBRUlBUXFBZ0FpRUNBUmxDQUVLZ0lFSWhJZ0Q1U1NPQUlFSUFRZ0VDQVBsQ0FTSUJHVWt6Z0NBQ0FFUVFScklRUWdBVUVBU2lFR0lBRkJBV3NoQVNBR0RRQUxEQUVMSUFBZ0JrRUNkR29oQmlBTFFRRk9CRUFnQmlvQ0FDRVFRUUFoQVNBR0lRUURRQ0FFSUJBZ0Q1UWdCQ29DQkNJU0lCR1VramdDQUNBRUlCSWdENVFnRUNBUmxKTWlFRGdDQkNBRVFRUnFJUVFnQVVFQmFpSUJJQXRIRFFBTEN5QUpRUUJPQkVBZ0JpQUpRUUowYWlFRUlBa2hBUU5BSUFRZ0JDb0NCQ0lRSUErVUlBUXFBZ0FpRWlBUmxKTTRBZ1FnQkNBU0lBK1VJQkFnRVpTU09BSUFJQVJCQkdzaEJDQUJRUUJLSVFjZ0FVRUJheUVCSUFjTkFBc0xJQVZGRFFCQkFDRUJJQVloQkNBTVFRRk9CRUFEUUNBRUlBVkJBblJxSWdjZ0J5b0NBQ0lRSUJHVUlBUXFBZ0FpRWlBUGxKTTRBZ0FnQkNBU0lCR1VJQkFnRDVTU09BSUFJQVJCQkdvaEJDQUJRUUZxSWdFZ0RFY05BQXNMSUFoQkFFZ05BQ0FHSUFoQkFuUnFJUVFnQ0NFQkEwQWdCQ0FGUVFKMGFpSUdJQVlxQWdBaUVDQVJsQ0FFS2dJQUloSWdENVNUT0FJQUlBUWdFaUFSbENBUUlBK1VramdDQUNBRVFRUnJJUVFnQVVFQVNpRUdJQUZCQVdzaEFTQUdEUUFMQ3lBQ1FRRnFJZ0lnQTBjTkFBc0xDOWNDQVFOL0l3QkJFR3NpQXlRQVFYOGhCUUpBQWtBZ0FVSC8vQUJNQkVBZ0FVSEFQa1lOQVNBQlFlRGRBRVlOQVF3Q0N5QUJRWUQ5QUVZTkFDQUJRWUQzQWtZTkFDQUJRY0M3QVVjTkFRc2dBa0VCYTBFQlN3MEFJQUJCQUFKL0lBTkI2TUlBTmdJTVFRQUxCSDlCQUFVZ0F5QURLQUlNUVFOcVFYeHhOZ0lNSUFNb0FneEJvRDBvQWdCQkFuUkI0TUFBYWlBQ2JFR2tQU2dDQUVFRmRHcHFRYlFCYWdzUUJTRUFRWDBoQlNBRFFlakNBRFlDQ0NBRElBTW9BZ2hCQTJwQmZIRWlCRFlDQ0NBQUlBSTJBakFnQUNBQ05nSUlJQUJCMkFBMkFnUWdBQ0FCTmdJWUlBQWdBVFlDRENBQUlBSTJBaEFnQUNBRVFkZ0FhaUlFTmdJQUlBQkIyQUJxRUVRTkFDQUFJQVJxSWdRZ0FTQUNFRndOQUVFQUlRVWdBMEVBTmdJQUlBUkJvTTRBSUFNUUJ4b2dBQ0FCUWYvL0EzRkJrQU51TmdKQUlBQkJBRFlDUENBQVFRQTJBaXdMSUFOQkVHb2tBQ0FGQytzQkFRWi9JQUFnQUNnQ0lDQUFLQUlrSWdRZ0F5QUNhMndpQTJzaUJqWUNJQ0FBSUFFRWZ5QUVJQUlnQVd0c0JTQUFLQUljSUFOckN5SUNOZ0ljSUFKQmdJQ0FCRTBFUUNBQUtBSVlJUU1nQUNnQ0tDRUVJQUFvQWhRaEJ5QUFLQUlFSVFnRFFDQUFJQUpCQ0hRaUNUWUNIQ0FBSUFkQkNHb2lCellDRkVFQUlRRWdBeUFJU1FSQUlBQWdBMEVCYWlJRk5nSVlJQUFvQWdBZ0Eyb3RBQUFoQVNBRklRTUxJQUFnQVRZQ0tDQUFJQVpCQ0hSQmdQNy8vd2R4SUFFZ0JFRUlkSEpCQVhaQi93Rnhja0gvQVhNaUJqWUNJQ0FDUVlHQUFra2hCU0FCSVFRZ0NTRUNJQVVOQUFzTEN3TUFBUXViQmdJS2Z3OTlJQVJCQkU0RVFDQUVRUU5ySVF3Z0EwRjhjU0VMSUFOQkEyc2hEU0FEUVFSSUlRNERRQ0FCSUFsQkFuUWlDbW9pQlVFTWFpRUhJQVVxQWdnaEVTQUZLZ0lFSVJZZ0JTb0NBQ0VYUXdBQUFBQWhGRU1BQUFBQUlSaERBQUFBQUNFWlF3QUFBQUFoRHlBQUlRWkJBQ0VJUXdBQUFBQWhFRU1BQUFBQUlSSkRBQUFBQUNFVFF3QUFBQUFoRlVFQUlRVWdEa1VFUUFOQUlCUWdCaW9DQUNJYUlBY3FBZ0FpRlpTU0lBWXFBZ1FpR3lBSEtnSUVJaENVa2lBR0tnSUlJaHdnQnlvQ0NDSVNsSklnQmlvQ0RDSWRJQWNxQWd3aUU1U1NJUlFnR0NBUklCcVVraUFWSUJ1VWtpQVFJQnlVa2lBU0lCMlVraUVZSUJrZ0ZpQWFsSklnRVNBYmxKSWdGU0FjbEpJZ0VDQWRsSkloR1NBUElCY2dHcFNTSUJZZ0c1U1NJQkVnSEpTU0lCVWdIWlNTSVE4Z0IwRVFhaUVISUFaQkVHb2hCaUFRSVJjZ0V5RVJJQkloRmlBSVFRUnFJZ2dnRFVnTkFBc2dEeUVRSUJraEVpQVlJUk1nQ3lFRkN5QUZRUUZ5SVFnQ2Z5QURJQVZNQkVBZ0JpRUZJQWNNQVFzZ0JrRUVhaUVGSUJRZ0Jpb0NBQ0lQSUFjcUFnQWlGWlNTSVJRZ0V5QVJJQStVa2lFVElCSWdGaUFQbEpJaEVpQVFJQmNnRDVTU0lSQWdCMEVFYWdzaEJ5QUlRUUZxSVFZQ2Z5QURJQWhNQkVBZ0JTRUlJQWNNQVFzZ0JVRUVhaUVJSUJRZ0JTb0NBQ0lQSUFjcUFnQWlGNVNTSVJRZ0V5QVZJQStVa2lFVElCSWdFU0FQbEpJaEVpQVFJQllnRDVTU0lSQWdCMEVFYWdzaEJTQURJQVpLQkVBZ0ZDQUlLZ0lBSWc4Z0JTb0NBSlNTSVJRZ0VpQVZJQStVa2lFU0lCQWdFU0FQbEpJaEVDQVRJQmNnRDVTU0lSTUxJQUlnQ21vZ0VEZ0NBQ0FDSUFwQkJISnFJQkk0QWdBZ0FpQUtRUWh5YWlBVE9BSUFJQUlnQ2tFTWNtb2dGRGdDQUNBSlFRUnFJZ2tnREVnTkFBc0xBa0FnQkNBSlRBMEFJQU5CQUVvRVFBTkFJQUVnQ1VFQ2RDSUlhaUVMUVFBaEJrTUFBQUFBSVJFRFFDQVJJQUFnQmtFQ2RDSUZhaW9DQUNBRklBdHFLZ0lBbEpJaEVTQUdRUUZxSWdZZ0EwY05BQXNnQWlBSWFpQVJPQUlBSUFsQkFXb2lDU0FFUncwQURBSUxBQXNnQWlBSlFRSjBha0VBSUFRZ0NXdEJBblFRQlJvTEM1VUNBZ04vQVgwakFDSUZJUWdnQlVHQUlHc2lCU1FBQW44Z0F3UkFJQVVnQUVHQUlCQUVHaUFEUVFGT0JFQURRQ0FGSUFaQkFuUWlCMm9nQUNBSGFpb0NBQ0FDSUFkcUtnSUFJZ21VT0FJQUlBVWdCa0YvYzBHQUNHcEJBblFpQjJvZ0NTQUFJQWRxS2dJQWxEZ0NBQ0FHUVFGcUlnWWdBMGNOQUFzTElBVWhBQXNnQUFzZ0FDQUJRWUFJSUFScklnTWdCRUVCYWhBelFRQWhBaUFFUVFCT0JFQURRRU1BQUFBQUlRa2dBaUFEYWlJR1FZQUlTQVJBQTBBZ0NTQUFJQVpCQW5ScUtnSUFJQUFnQmlBQ2EwRUNkR29xQWdDVWtpRUpJQVpCQVdvaUJrR0FDRWNOQUFzTElBRWdBa0VDZEdvaUJTQUpJQVVxQWdDU09BSUFJQUlnQkVjaEJTQUNRUUZxSVFJZ0JRMEFDd3NnQ0NRQUM5a0RBZ0YvQ1gwZ0FVRU1haUVESUFFcUFnZ2hDeUFCS2dJRUlRWWdBU29DQUNFRkFuOGdBaW9DRENFSElBSXFBZ2doQ0NBQ0tnSUVJUWtnQWlvQ0FDRUtRUUFoQVFOQUlBSWdBQ29DQUNJRUlBTXFBZ0FpREpRZ0I1SWlCemdDRENBQ0lBc2dCSlFnQ0pJaUNEZ0NDQ0FDSUFZZ0JKUWdDWklpQ1RnQ0JDQUNJQVVnQkpRZ0NwSWlDamdDQUNBQ0lBY2dBQ29DQkNJRUlBTXFBZ1FpQlpTU0lnYzRBZ3dnQWlBSUlBd2dCSlNTSWdnNEFnZ2dBaUFKSUFzZ0JKU1NJZ2s0QWdRZ0FpQUtJQVlnQkpTU0lnbzRBZ0FnQWlBSElBQXFBZ2dpQkNBREtnSUlJZ2FVa2lJSE9BSU1JQUlnQ0NBRklBU1VraUlJT0FJSUlBSWdDU0FNSUFTVWtpSUpPQUlFSUFJZ0NpQUxJQVNVa2lJS09BSUFJQUlnQnlBQUtnSU1JZ1FnQXlvQ0RDSUxsSklpQnpnQ0RDQUNJQWdnQmlBRWxKSWlDRGdDQ0NBQ0lBa2dCU0FFbEpJaUNUZ0NCQ0FDSUFvZ0RDQUVsSklpQ2pnQ0FDQURRUkJxSVFNZ0FFRVFhaUVBSUFGQkJHb2lBVUVWU0EwQUMwRUFDd1JBSUFNcUFnQWhEQ0FDSUFVZ0FDb0NBQ0lGbENBQ0tnSUFramdDQUNBQ0lBWWdCWlFnQWlvQ0JKSTRBZ1FnQWlBTElBV1VJQUlxQWdpU09BSUlJQUlnQlNBTWxDQUNLZ0lNa2pnQ0RDQURRUVJxSVFNZ0FFRUVhaUVBQ3d1b0FnSUdmd1I5SUFFcUFnQWhDaUFBUVFBZ0FrRUNkQkFGSVFRQ1FDQUJLZ0lBUXdBQUFBQmJEUUFnQWtFQUlBSkJBRW9iSVFkQkFTRUZBMEFnQXlBSFJnMEJRUUFoQWtNQUFBQUFJUWtnQXdSQUEwQWdDU0FFSUFKQkFuUnFLZ0lBSUFFZ0F5QUNhMEVDZEdvcUFnQ1VraUVKSUFKQkFXb2lBaUFEUncwQUN3c2dCQ0FEUVFKMGFpQUpJQUVnQTBFQmFpSUFRUUowYWlvQ0FKS01JQXFWSWdrNEFnQWdBd1JBSUFWQkFYWWhDRUVBSVFJRFFDQUVJQUpCQW5ScUlnWWdCaW9DQUNJTElBa2dCQ0FESUFKQmYzTnFRUUowYWlJR0tnSUFJZ3lVa2pnQ0FDQUdJQXdnQ1NBTGxKSTRBZ0FnQWtFQmFpSUNJQWhIRFFBTEN5QUZRUUZxSVFVZ0FDRURJQW9nQ2lBSklBbVVsSk1pQ2lBQktnSUFRMjhTZ3pxVVhVRUJjdzBBQ3dzTHpRZ0JDMzlCZnlFUEFrQWdBVUVBU0EwQUlBUkZEUUJCZkNFUElBRkZEUUFDZnlBQUxRQUFJZzVCZ0FGeEJFQkJnUGNDSUE1QkEzWkJBM0YwUVpBRGJnd0JDMEhBQjBIZ0F5QU9RUWh4R3lBT1FlQUFjVUhnQUVZTkFCcEJ3QllnRGtFRGRrRURjU0lIUVFOR0RRQWFRWUQzQWlBSGRFSGtBRzRMSVF0QkFTRUlJQUJCQVdvaENTQUJRUUZySWdjaENnSkFBa0FDUUFKQUFrQUNRQUpBSUE1QkEzRWlEQTREQXdBQkFnc2dBZ1JBUVFJaENFRUJJUTFCQUNFTUlBY2hDZ3dFQ3lBSFFRRnhEUVlnQkNBSFFRRjJJZ283QVFCQkFpRUlRUUFoREF3RUN5QUJRUUZNQkVBZ0JFSC8vd003QVFCQmZBOExJQWt0QUFBaURFSDhBVThFUUVFQ0lRZ2dBVUVDVEFSQUlBUkIvLzhET3dFQVFYd1BDeUFBTFFBQ1FRSjBJQXhxSVF3TElBUWdERHNCQUNBSElBaHJJZ2NnREVnTkJTQUhJQXhySVFvZ0NDQUphaUVKUVFJaENFRUFJUXdNQVFzZ0FVRUNTQTBFSUFBdEFBRWlEVUUvY1NJSVJRMEVJQWdnQzJ4QmdDMUxEUVFnQUVFQ2FpRUtJQUZCQW1zaEFVRUFJUXdDUUNBTlFjQUFjVVVFUUNBS0lRa01BUXNEUUNBQlFRRklEUVlnREVGK0lBb3RBQUFpQ1NBSlFmOEJSaUlMRzBIL0FYRWlDV29oRENBQklBbEJmM05xSVFFZ0NrRUJhaUlKSVFvZ0N3MEFDeUFCUVFCSURRVUxJQTFCZ0FGeEJFQkJBQ0VOSUFoQkFra0VRQ0FCSWdjaENnd0NDeUFJUVFGcklSRWdBU0lLSVFjRFFDQUVJQTFCQVhScUlSQWdCMEVBVEFSQUlCQkIvLzhET3dFQVFYd1BDMEVCSVFzZ0NTMEFBQ0lCUWZ3QlR3UkFJQWRCQVV3RVFDQVFRZi8vQXpzQkFFRjhEd3RCQWlFTElBa3RBQUZCQW5RZ0FXb2hBUXNnRUNBQk93RUFJQWNnQzJzaUJ5QUJTQTBHSUFrZ0Myb2hDU0FLSUF0cklBRnJJUW9nRFVFQmFpSU5JQkZIRFFBTFFRQWhEU0FLUVFCT0RRRU1CUXRCQVNFTklBSUVRQ0FISVFvZ0FTRUhEQUlMSUFFZ0NHMGlDaUFJYkNBQlJ3MEVJQWhCQWtrTkFpQUlRUUZySVF0QkFDRUhBMEFnQkNBSFFRRjBhaUFLT3dFQUlBZEJBV29pQnlBTFJ3MEFDeUFCSVFjTElBSkZEUUVMSUFRZ0NFRUJkR3BCQW1zaEMwSC8vd01oQVFKL1FYOGdCMEVCU0EwQUdpQUpMUUFBSWdKQi9BRkpCRUFnQWlFQlFRRU1BUXRCZnlBSFFRSklEUUFhSUFrdEFBRkJBblFnQW1vaEFVRUNDeUVDSUFzZ0FUc0JBQ0FCUVJCMFFSQjFJZ3RCQUVnTkFpQUhJQUpySWdjZ0MwZ05BaUFDSUFscUlRa2dEUVJBSUFnZ0Myd2dCMG9OQXlBSVFRSkpEUUlnQkNBQk93RUFRUUVoQVNBSVFRRnJJZ0pCQVVZTkFpQUVJQUpCQVhScUlRY0RRQ0FFSUFGQkFYUnFJQWN2QVFBN0FRQWdBVUVCYWlJQklBSkhEUUFMREFJTElBSWdDMm9nQ2tvTkFnd0JDeUFLUWZzSlNnMEJJQWhCQVhRZ0JHcEJBbXNnQ2pzQkFBc2dCUVJBSUFVZ0NTQUFhellDQUFzZ0NBUkFRUUFoQVFOQUlBa2dCQ0FCUVFGMGFpNEJBR29oQ1NBQlFRRnFJZ0VnQ0VjTkFBc0xJQVlFUUNBR0lBd2dBR3NnQ1dvMkFnQUxJQU1FUUNBRElBNDZBQUFMSUFnaER3c2dEd3RhQVFSL1FRRkJIeUFBWjJ0QkFYVWlBblFoQXdOQUlBQkJBQ0FFUVFGMElBTnFJQUowSWdFZ0FDQUJTU0lCRzJzaEFFRUFJQU1nQVJzZ0JHb2hCQ0FDUVFCS0lRRWdBMEVCZGlFRElBSkJBV3NoQWlBQkRRQUxJQVFMeFFRQ0NIOEVmU01BSVFjQ1FDQURRUUpIRFFBZ0JFRUJSdzBBSUFZcUFnUWhEeUFHS2dJQUlSQWdBa0VCVGdSQUlBQW9BZ1FoQXlBQUtBSUFJUUFnQlNvQ0FDRVJRUUFoQlFOQUlBTWdCVUVDZENJRWFpb0NBQ0VTSUFFZ0JVRURkQ0lIYWlBUUlBQWdCR29xQWdCRFlFS2lEWktTSWhCREFBQUFPSlE0QWdBZ0FTQUhRUVJ5YWlBUElCSkRZRUtpRFpLU0lnOURBQUFBT0pRNEFnQWdFU0FQbENFUElCRWdFSlFoRUNBRlFRRnFJZ1VnQWtjTkFBc0xJQVlnRHpnQ0JDQUdJQkE0QWdBUEN5QURRUUVnQTBFQlNoc2hDeUFDSUFSdElRa2dCeUFDUVFKMFFROXFRWEJ4YXlFS0lBVXFBZ0FoRUVFQUlRY0NRQ0FFUVFKT0JFQURRRUVBSVFVZ0JpQUhRUUowSWdocUlnd3FBZ0FoRHlBQ1FRQktCRUFnQUNBSWFpZ0NBQ0VOQTBBZ0NpQUZRUUowSWc1cUlBOGdEU0FPYWlvQ0FFTmdRcUlOa3BJaUR6Z0NBQ0FRSUErVUlROGdCVUVCYWlJRklBSkhEUUFMQ3lBTUlBODRBZ0FnQ1VFQlRnUkFJQUVnQ0dvaENFRUFJUVVEUUNBSUlBTWdCV3hCQW5ScUlBb2dCQ0FGYkVFQ2RHb3FBZ0JEQUFBQU9KUTRBZ0FnQlVFQmFpSUZJQWxIRFFBTEN5QUhRUUZxSWdjZ0MwY05BQXdDQ3dBTElBSkJBVWdoQ1FOQUlBWWdCMEVDZENJRWFpSUtLZ0lBSVE4Z0NVVUVRQ0FCSUFScUlRZ2dBQ0FFYWlnQ0FDRUVRUUFoQlFOQUlBZ2dBeUFGYkVFQ2RHb2dEeUFFSUFWQkFuUnFLZ0lBUTJCQ29nMlNraUlQUXdBQUFEaVVPQUlBSUJBZ0Q1UWhEeUFGUVFGcUlnVWdBa2NOQUFzTElBb2dEemdDQUNBSFFRRnFJZ2NnQzBjTkFBc0xDMlVBSUFBdEFBQWlBRUdBQVhFRVFDQUJJQUJCQTNaQkEzRjBRWkFEYlE4TElBQkI0QUJ4UWVBQVJnUkFJQUJCQ0hFRVFDQUJRVEp0RHdzZ0FVSGtBRzBQQ3lBQVFRTjJRUU54SWdCQkEwWUVRQ0FCUVR4c1FlZ0hiUThMSUFFZ0FIUkI1QUJ0Qy8wUkFoVi9ISDBnQUNnQ0NDRUpJd0JCSUdzaUVrRUJOZ0lBSUFCQkRHb2hERUVCSVFRRFFDQU1JQU1pQWtFQ2RDSUZRUUp5YWk4QkFDRUdJQklnQWtFQmFpSURRUUowYWlBRUlBVWdER291QVFCc0lnUTJBZ0FnQmtFQlJ3MEFDeUFKUVFBZ0NVRUFTaHNoRmlBRFFRSjBJQUJxTGdFS0lRd0RRQ0FNSVFWQkFDRURRUUVoREFKQUFrQUNRQUpBQWtBZ0FDQUNJZ2tFZnlBSlFRSjBJQUJxTGdFS0lRd2dDVUVCZEFWQkFBdEJBWFJxTGdFTVFRSnJEZ1FBQWdFREJBc2dBU0VDSUJJZ0NVRUNkR29vQWdBaUJrRUJTQTBEQTBBZ0FpQUNLZ0lBSWhnZ0Fpb0NJQ0lYa3pnQ0lDQUNJQmNnR0pJNEFnQWdBaUFDUVNScUtnSUFJaGdnQWlvQ0JDSVhramdDQkNBQ0lCY2dHSk00QWlRZ0FpQUNLZ0lJSWhzZ0Fpb0NLQ0lhSUFKQkxHb3FBZ0FpRjVKRDh3UTFQNVFpR1pNNEFpZ2dBaUFDUVF4cUtnSUFJaGdnRnlBYWswUHpCRFUvbENJWGt6Z0NMQ0FDSUJzZ0daSTRBZ2dnQWlBWElCaVNPQUlNSUFJcUFqQWhHaUFDSUFJcUFoQWlHU0FDUVRScUtnSUFJaGlUT0FJd0lBSWdHaUFDUVJScUtnSUFJaGVTT0FJMElBSWdGeUFha3pnQ0ZDQUNJQmdnR1pJNEFoQWdBaUFDS2dJWUloc2dBa0U4YWlvQ0FDSWFJQUlxQWpnaUY1TkQ4d1ExUDVRaUdaTTRBamdnQWlBQ1FSeHFLZ0lBSWhnZ0dpQVhra1B6QkRXL2xDSVhremdDUENBQ0lCY2dHSkk0QWh3Z0FpQWJJQm1TT0FJWUlBSkJRR3NoQWlBRFFRRnFJZ01nQmtjTkFBc01Bd3NnRWlBSlFRSjBhaWdDQUNFVElBVkJBVVlFUUNBQklRSWdFMEVCU0EwREEwQWdBaUFDS2dJQUlod2dBaW9DRUNJZ2tpSVlJQUlxQWdnaUlTQUNLZ0lZSWgyU0loZVRPQUlRSUFJZ0dDQVhramdDQUNBQ1FSUnFJQUlxQWdRaUdTQUNLZ0lVSWhpU0loNGdBa0VNYWlvQ0FDSWZJQUpCSEdvcUFnQWlGNUlpRzVNNEFnQWdBaUFaSUJpVElob2dJU0Fka3lJWmtqZ0NIQ0FDSUJ3Z0lKTWlHQ0FmSUJlVEloZVRPQUlZSUFJZ0dpQVpremdDRENBQ0lCZ2dGNUk0QWdnZ0FpQWVJQnVTT0FJRUlBSkJJR29oQWlBRFFRRnFJZ01nRTBjTkFBc01Bd3NnRTBFQlNBMENJQVZCQVVnTkFpQUZRUU5zSVE4Z0JVRUJkQ0VRSUJNZ0ZuUWlEVUVEYkNFVUlBMUJBWFFoRlNBQUtBSXdJUVpCQUNFTEEwQWdBU0FMSUF4c1FRTjBhaUVDUVFBaEVTQUdJZ01oQ0NBRElRUURRQ0FDS2dJQUlTUWdBaUFRUVFOMGFpSU9JQWdxQWdBaUtTQU9LZ0lFSWlxVUlBNHFBZ0FpR3lBSUtnSUVJaHFVa2lJcklBSXFBZ1FpTEpJaUlpQUVLZ0lBSWkwZ0FpQUZRUU4wYWlJSEtnSUVJaU9VSUFjcUFnQWlIQ0FFS2dJRUlobVVraUlnSUFNcUFnQWlJU0FDSUE5QkEzUnFJZ29xQWdRaUhaUWdDaW9DQUNJWUlBTXFBZ1FpRjVTU0loNlNJaCtUT0FJRUlBNGdKQ0FiSUNtVUlDb2dHcFNUSWh1U0lob2dIQ0F0bENBaklCbVVreUlaSUJnZ0laUWdIU0FYbEpNaUdKSWlGNU00QWdBZ0FpQWZJQ0tTT0FJRUlBSWdHaUFYa2pnQ0FDQUhJQ3dnSzVNaUdpQVpJQmlUSWhtVE9BSUVJQWNnSkNBYmt5SVlJQ0FnSHBNaUY1STRBZ0FnQ2lBYUlCbVNPQUlFSUFvZ0dDQVhremdDQUNBQ1FRaHFJUUlnQXlBVVFRTjBhaUVESUFnZ0ZVRURkR29oQ0NBRUlBMUJBM1JxSVFRZ0VVRUJhaUlSSUFWSERRQUxJQXRCQVdvaUN5QVRSdzBBQ3d3Q0N5QVNJQWxCQW5ScUtBSUFJZzlCQVVnTkFTQUFLQUl3SWdZZ0R5QVdkQ0lRSUFWc1FRTjBhaW9DQkNFaklBVkJBWFFoRkNBUVFRRjBJUlZCQUNFS0EwQWdBU0FLSUF4c1FRTjBhaUVDSUFZaUNDRUVJQVVoQXdOQUlBSWdCVUVEZEdvaUJ5QUNLZ0lBSUFjcUFnQWlIQ0FFS2dJQUlpQ1VJQWNxQWdRaUlTQUVLZ0lFSWhtVWt5SWRJQUlnRkVFRGRHb2lEU29DQUNJZUlBZ3FBZ0FpSDVRZ0RTb0NCQ0lZSUFncUFnUWlGNVNUSWh1U0locERBQUFBUDVTVE9BSUFJQWNnQWlvQ0JDQWdJQ0dVSUJ3Z0daU1NJaGtnSHlBWWxDQWVJQmVVa2lJWWtpSVhRd0FBQUQrVWt6Z0NCQ0FDSUJvZ0Fpb0NBSkk0QWdBZ0FpQVhJQUlxQWdTU09BSUVJQTBnSXlBWklCaVRsQ0lZSUFjcUFnQ1NPQUlBSUEwZ0J5b0NCQ0FqSUIwZ0c1T1VJaGVUT0FJRUlBY2dCeW9DQUNBWWt6Z0NBQ0FISUJjZ0J5b0NCSkk0QWdRZ0FrRUlhaUVDSUFnZ0ZVRURkR29oQ0NBRUlCQkJBM1JxSVFRZ0EwRUJheUlERFFBTElBcEJBV29pQ2lBUFJ3MEFDd3dCQ3lBU0lBbEJBblJxS0FJQUlnMUJBVWdOQUNBQUtBSXdJZzRnRFNBV2RDSVBJQVZzSWdaQkJIUnFJZ0lxQWdRaEpTQUNLZ0lBSVNZZ0RpQUdRUU4wYWlJQ0tnSUVJU2NnQWlvQ0FDRW9JQVZCQW5RaEVDQUZRUU5zSVJRZ0JVRUJkQ0VWUVFBaEJ3TkFJQVZCQVU0RVFDQUJJQWNnREd4QkEzUnFJZ0lnQlVFRGRHb2hBeUFDSUJWQkEzUnFJUWdnQWlBVVFRTjBhaUVFSUFJZ0VFRURkR29oQzBFQUlSRURRQ0FDS2dJQUlTNGdBaUFDS2dJRUlpOGdEaUFQSUJGc0lncEJCSFJxSWdZcUFnQWlNaUFJS2dJRUlpU1VJQWdxQWdBaUtTQUdLZ0lFSWhxVWtpSXFJQTRnQ2tFWWJHb2lCaW9DQUNJcklBUXFBZ1FpTEpRZ0JDb0NBQ0lpSUFZcUFnUWlHWlNTSWkyU0lqQWdEaUFLUVFOMGFpSUdLZ0lBSWlNZ0F5b0NCQ0ljbENBREtnSUFJaDBnQmlvQ0JDSVlsSklpSUNBT0lBcEJCWFJxSWdZcUFnQWlIaUFMS2dJRUloK1VJQXNxQWdBaUd5QUdLZ0lFSWhlVWtpSWhraUl4a3BJNEFnUWdBaUF1SUNrZ01wUWdKQ0FhbEpNaUdpQWlJQ3VVSUN3Z0daU1RJaG1TSWlJZ0hTQWpsQ0FjSUJpVWt5SVlJQnNnSHBRZ0h5QVhsSk1pRjVJaUhKS1NPQUlBSUFNZ0pTQWFJQm1USWgyVUlDY2dHQ0FYa3lJZWxKSWlIeUF2SUNZZ01KUWdLQ0F4bEpLU0locVNPQUlFSUFNZ0xpQW1JQ0tVSUNnZ0hKU1NraUlaSUNVZ0tpQXRreUlibENBbklDQWdJWk1pR0pTU0loZVRPQUlBSUFzZ0dpQWZremdDQkNBTElCY2dHWkk0QWdBZ0NDQWxJQjZVSUNjZ0haU1RJaG9nTHlBb0lEQ1VJQ1lnTVpTU2tpSVpramdDQkNBSUlDY2dHNVFnSlNBWWxKTWlHQ0F1SUNnZ0lwUWdKaUFjbEpLU0loZVNPQUlBSUFRZ0dTQWFremdDQkNBRUlCY2dHSk00QWdBZ0MwRUlhaUVMSUFSQkNHb2hCQ0FJUVFocUlRZ2dBMEVJYWlFRElBSkJDR29oQWlBUlFRRnFJaEVnQlVjTkFBc0xJQWRCQVdvaUJ5QU5SdzBBQ3dzZ0NVRUJheUVDSUFsQkFFb05BQXNMaEFJQkJuOGpBQ0lFSVFjZ0JDQUJJQUpzSWdoQkFuUkJEMnBCY0hGcklnVWtBQUpBSUFORkJFQWdBa0VCU0EwQklBRkJBVWdOQVVFQUlRUURRQ0FCSUFSc0lRWkJBQ0VEQTBBZ0JTQURJQVpxUVFKMGFpQUFJQUlnQTJ3Z0JHcEJBblJxS2dJQU9BSUFJQU5CQVdvaUF5QUJSdzBBQ3lBRVFRRnFJZ1FnQWtjTkFBc01BUXNnQWtFQlNBMEFJQUZCQVVnTkFDQUNRUUowUWVnNWFpRUdRUUFoQkFOQUlBWWdCRUVDZEdvb0FnQWdBV3doQ1VFQUlRTURRQ0FGSUFNZ0NXcEJBblJxSUFBZ0FpQURiQ0FFYWtFQ2RHb3FBZ0E0QWdBZ0EwRUJhaUlESUFGSERRQUxJQVJCQVdvaUJDQUNSdzBBQ3dzZ0FDQUZJQWhCQW5RUUJCb2dCeVFBQ3d3QUlBQWdBU0FDSUFNUVBndmJBd0VPZnlBRFFRRk9CRUFnQUNnQ0ZDRUlJQUFvQWhBaEJpQUFLQUlNSVFRZ0FDZ0NDQ0VKSUFBb0FnUWhCeUFBS0FJQUlRVURRQ0FCSUFwQkFuUWlDMnBCLy84QklBY2dCU0FDSUFwQkFYUnFMZ0VBUVFwMElnd2dCV3NpQlVILy93TnhRZElOYkVFUWRpQUZRUkIxUWRJTmJHb2lEV29pRGlBSGF5SUhRZi8vQTNGQml2VUFiRUVRZGlBSFFSQjFRWXIxQUd4cUlnOXFJZ1VnQ1dzaUIwSC8vd054UWF1eGZteEJFSFVnQjBFUWRVR3JzWDVzYWlBRmFpSUZRUWwxUVFGcVFRRjFJZ2xCZ0lCK0lBbEJnSUIrU2hzZ0JVSC8rLzhQU2hzN0FRQWdBU0FMUVFKeWFrSC8vd0VnQmlBRUlBd2dCR3NpQkVILy93TnhRY1kxYkVFUWRpQUVRUkIxUWNZMWJHb2lDMm9pRUNBR2F5SUdRZi8vQTNGQnFja0JiRUVRZGlBR1FSQjFRYW5KQVd4cUloRnFJZ1FnQ0dzaUJrSC8vd054UWZheGYyeEJFSFVnQmtFUWRVSDJzWDlzYWlBRWFpSUVRUWwxUVFGcVFRRjFJZ2hCZ0lCK0lBaEJnSUIrU2hzZ0JFSC8rLzhQU2hzN0FRQWdCQ0FHYWlFSUlBVWdCMm9oQ1NBUUlCRnFJUVlnRGlBUGFpRUhJQXNnREdvaEJDQU1JQTFxSVFVZ0NrRUJhaUlLSUFOSERRQUxJQUFnQ0RZQ0ZDQUFJQVkyQWhBZ0FDQUVOZ0lNSUFBZ0NUWUNDQ0FBSUFjMkFnUWdBQ0FGTmdJQUN3dG9BUUovSXdCQkVHc2lBaVFBQWtBQ1FDQUJJQUFvQWdCR0JFQWdBUkFJSUFBb0FnUWhBU0FBRUFnTUFRc2dBQ2dDQkNJRERRRWdBaUFCTmdJQVFlc0lJQUlRSGtFQUlRRUxJQUpCRUdva0FDQUJEd3NnQUNBRElBRVFQellDQkNBQ1FSQnFKQUFnQUF1akVnRVJmeU1BSWdjaEVpQUhJQUFvQXBRQ0lnZ2dBQ2dDakFJaUJHcEJBblJCRDJwQmNIRnJJZ2NrQUNBSElBQkJHR29pRXlBSVFRSjBFQVFoRENBQUtBS29BaUlIUVFScUlSQWdBQ2dDa0FJaER5QUhJUVVEUUNBQUlBd2dDRUVDZEdvZ0FpQUZJQU1nQkNBRElBUklHeUlPRUdjZ0RrRVFkQ0VOQWtBQ1FBSkFBa0FnQUNnQ2xBSWlFVUVTYXc0VEFBTURBd01EQVFNREF3TURBd01EQXdNREFnTUxJQTFCQVVnTkFpQUFLQUtZQWlJR1FSQjBRUkIxSVJSQkFDRUZBMEFnQVVILy93RWdFQ0FGUWYvL0EzRWdGR3hCRUhVaUNrRVNiR29pQkM0QkFDSUpJQXdnQlVFUWRVRUNkR29pQ0NnQ0FDSUxRZi8vQTNGc1FSQjFJQXRCRUhVZ0NXeHFJQVF1QVFJaUNTQUlLQUlFSWd0QkVIVnNhaUFMUWYvL0EzRWdDV3hCRUhWcUlBUXVBUVFpQ1NBSUtBSUlJZ3RCRUhWc2FpQUxRZi8vQTNFZ0NXeEJFSFZxSUFRdUFRWWlDU0FJS0FJTUlndEJFSFZzYWlBTFFmLy9BM0VnQ1d4QkVIVnFJQVF1QVFnaUNTQUlLQUlRSWd0QkVIVnNhaUFMUWYvL0EzRWdDV3hCRUhWcUlBUXVBUW9pQ1NBSUtBSVVJZ3RCRUhWc2FpQUxRZi8vQTNFZ0NXeEJFSFZxSUFRdUFRd2lDU0FJS0FJWUlndEJFSFZzYWlBTFFmLy9BM0VnQ1d4QkVIVnFJQVF1QVE0aUNTQUlLQUljSWd0QkVIVnNhaUFMUWYvL0EzRWdDV3hCRUhWcUlBUXVBUkFpQkNBSUtBSWdJZ2xCRUhWc2FpQUpRZi8vQTNFZ0JHeEJFSFZxSUJBZ0JpQUtRWDl6YWtFU2JHb2lCQzRCQUNJS0lBZ29Ba1FpQ1VFUWRXeHFJQWxCLy84RGNTQUtiRUVRZFdvZ0JDNEJBaUlLSUFnb0FrQWlDVUVRZFd4cUlBbEIvLzhEY1NBS2JFRVFkV29nQkM0QkJDSUtJQWdvQWp3aUNVRVFkV3hxSUFsQi8vOERjU0FLYkVFUWRXb2dCQzRCQmlJS0lBZ29BamdpQ1VFUWRXeHFJQWxCLy84RGNTQUtiRUVRZFdvZ0JDNEJDQ0lLSUFnb0FqUWlDVUVRZFd4cUlBbEIvLzhEY1NBS2JFRVFkV29nQkM0QkNpSUtJQWdvQWpBaUNVRVFkV3hxSUFsQi8vOERjU0FLYkVFUWRXb2dCQzRCRENJS0lBZ29BaXdpQ1VFUWRXeHFJQWxCLy84RGNTQUtiRUVRZFdvZ0JDNEJEaUlLSUFnb0FpZ2lDVUVRZFd4cUlBbEIvLzhEY1NBS2JFRVFkV29nQkM0QkVDSUVJQWdvQWlRaUNFRVFkV3hxSUFoQi8vOERjU0FFYkVFUWRXb2lDRUVGZFVFQmFrRUJkU0lFUVlDQWZpQUVRWUNBZmtvYklBaEIzLy8vQUVvYk93RUFJQUZCQW1vaEFTQUZJQTlxSWdVZ0RVZ05BQXNNQWd0QkFDRUlJQTFCQUV3TkFRTkFJQUZCLy84QklBY3VBUVFpQkNBTUlBaEJFSFZCQW5ScUlnVW9BbHdnQlNnQ0FHb2lCa0gvL3dOeGJFRVFkU0FHUVJCMUlBUnNhaUFITGdFR0lnUWdCU2dDV0NBRktBSUVhaUlHUVJCMWJHb2dCa0gvL3dOeElBUnNRUkIxYWlBSExnRUlJZ1FnQlNnQ1ZDQUZLQUlJYWlJR1FSQjFiR29nQmtILy93TnhJQVJzUVJCMWFpQUhMZ0VLSWdRZ0JTZ0NVQ0FGS0FJTWFpSUdRUkIxYkdvZ0JrSC8vd054SUFSc1FSQjFhaUFITGdFTUlnUWdCU2dDVENBRktBSVFhaUlHUVJCMWJHb2dCa0gvL3dOeElBUnNRUkIxYWlBSExnRU9JZ1FnQlNnQ1NDQUZLQUlVYWlJR1FSQjFiR29nQmtILy93TnhJQVJzUVJCMWFpQUhMZ0VRSWdRZ0JTZ0NSQ0FGS0FJWWFpSUdRUkIxYkdvZ0JrSC8vd054SUFSc1FSQjFhaUFITGdFU0lnUWdCU2dDUUNBRktBSWNhaUlHUVJCMWJHb2dCa0gvL3dOeElBUnNRUkIxYWlBSExnRVVJZ1FnQlNnQ1BDQUZLQUlnYWlJR1FSQjFiR29nQmtILy93TnhJQVJzUVJCMWFpQUhMZ0VXSWdRZ0JTZ0NPQ0FGS0FJa2FpSUdRUkIxYkdvZ0JrSC8vd054SUFSc1FSQjFhaUFITGdFWUlnUWdCU2dDTkNBRktBSW9haUlHUVJCMWJHb2dCa0gvL3dOeElBUnNRUkIxYWlBSExnRWFJZ1FnQlNnQ01DQUZLQUlzYWlJRlFSQjFiR29nQlVILy93TnhJQVJzUVJCMWFpSUZRUVYxUVFGcVFRRjFJZ1JCZ0lCK0lBUkJnSUIrU2hzZ0JVSGYvLzhBU2hzN0FRQWdBVUVDYWlFQklBZ2dEMm9pQ0NBTlNBMEFDd3dCQzBFQUlRZ2dEVUVBVEEwQUEwQWdBVUgvL3dFZ0J5NEJCQ0lFSUF3Z0NFRVFkVUVDZEdvaUJTZ0NqQUVnQlNnQ0FHb2lCa0gvL3dOeGJFRVFkU0FHUVJCMUlBUnNhaUFITGdFR0lnUWdCU2dDaUFFZ0JTZ0NCR29pQmtFUWRXeHFJQVpCLy84RGNTQUViRUVRZFdvZ0J5NEJDQ0lFSUFVb0FvUUJJQVVvQWdocUlnWkJFSFZzYWlBR1FmLy9BM0VnQkd4QkVIVnFJQWN1QVFvaUJDQUZLQUtBQVNBRktBSU1haUlHUVJCMWJHb2dCa0gvL3dOeElBUnNRUkIxYWlBSExnRU1JZ1FnQlNnQ2ZDQUZLQUlRYWlJR1FSQjFiR29nQmtILy93TnhJQVJzUVJCMWFpQUhMZ0VPSWdRZ0JTZ0NlQ0FGS0FJVWFpSUdRUkIxYkdvZ0JrSC8vd054SUFSc1FSQjFhaUFITGdFUUlnUWdCU2dDZENBRktBSVlhaUlHUVJCMWJHb2dCa0gvL3dOeElBUnNRUkIxYWlBSExnRVNJZ1FnQlNnQ2NDQUZLQUljYWlJR1FSQjFiR29nQmtILy93TnhJQVJzUVJCMWFpQUhMZ0VVSWdRZ0JTZ0NiQ0FGS0FJZ2FpSUdRUkIxYkdvZ0JrSC8vd054SUFSc1FSQjFhaUFITGdFV0lnUWdCU2dDYUNBRktBSWthaUlHUVJCMWJHb2dCa0gvL3dOeElBUnNRUkIxYWlBSExnRVlJZ1FnQlNnQ1pDQUZLQUlvYWlJR1FSQjFiR29nQmtILy93TnhJQVJzUVJCMWFpQUhMZ0VhSWdRZ0JTZ0NZQ0FGS0FJc2FpSUdRUkIxYkdvZ0JrSC8vd054SUFSc1FSQjFhaUFITGdFY0lnUWdCU2dDWENBRktBSXdhaUlHUVJCMWJHb2dCa0gvL3dOeElBUnNRUkIxYWlBSExnRWVJZ1FnQlNnQ1dDQUZLQUkwYWlJR1FSQjFiR29nQmtILy93TnhJQVJzUVJCMWFpQUhMZ0VnSWdRZ0JTZ0NWQ0FGS0FJNGFpSUdRUkIxYkdvZ0JrSC8vd054SUFSc1FSQjFhaUFITGdFaUlnUWdCU2dDVUNBRktBSThhaUlHUVJCMWJHb2dCa0gvL3dOeElBUnNRUkIxYWlBSExnRWtJZ1FnQlNnQ1RDQUZLQUpBYWlJR1FSQjFiR29nQmtILy93TnhJQVJzUVJCMWFpQUhMZ0VtSWdRZ0JTZ0NTQ0FGS0FKRWFpSUZRUkIxYkdvZ0JVSC8vd054SUFSc1FSQjFhaUlGUVFWMVFRRnFRUUYxSWdSQmdJQitJQVJCZ0lCK1Noc2dCVUhmLy84QVNoczdBUUFnQVVFQ2FpRUJJQWdnRDJvaUNDQU5TQTBBQ3dzZ0F5QU9heUlEUVFKT0JFQWdEQ0FNSUE1QkFuUnFJQkZCQW5RUUJCb2dBaUFPUVFGMGFpRUNJQUFvQXFnQ0lRVWdBQ2dDbEFJaENDQUFLQUtNQWlFRURBRUxDeUFUSUF3Z0RrRUNkR29nRVVFQ2RCQUVHaUFTSkFBTG1BTUJDbjhqQUNJRklRa2dCU0FBS0FLTUFpSUVRUUowUVI5cVFYQnhheUlGSkFBZ0JTQUFLUUlnTndJSUlBVWdBQ2tDR0RjQ0FDQUZRUkJxSVFvZ0FDZ0NrQUloQ3dOQUlBQWdDaUFDSUFNZ0JDQURJQVJJR3lJSEVENUJBQ0VJSUFkQkVYUWlERUVCVGdSQUEwQWdBVUgvL3dFZ0NFSC8vd054UVF4c1FSQjJJZzFCQTNSQjhBMXFJZ1l1QVFJZ0JTQUlRUkIxUVFGMGFpSUVMZ0VDYkNBR0xnRUFJQVF1QVFCc2FpQUdMZ0VFSUFRdUFRUnNhaUFHTGdFR0lBUXVBUVpzYWtFQUlBMXJRUU4wUWNnT2FpSUdMZ0VHSUFRdUFRaHNhaUFHTGdFRUlBUXVBUXBzYWlBR0xnRUNJQVF1QVF4c2FpQUdMZ0VBSUFRdUFRNXNhaUlFUVE1MVFRRnFRUUYxSWdaQmdJQitJQVpCZ0lCK1Noc2dCRUgvLy83L0Ewb2JPd0VBSUFGQkFtb2hBU0FJSUF0cUlnZ2dERWdOQUFzTElBTWdCMnNpQTBFQlRnUkFJQVVnQlNBSFFRSjBhaUlFS1FJQU53SUFJQVVnQkNrQ0NEY0NDQ0FDSUFkQkFYUnFJUUlnQUNnQ2pBSWhCQXdCQ3dzZ0FDQUZJQWRCQW5ScUlnRXBBZ0EzQWhnZ0FDQUJLUUlJTndJZ0lBa2tBQXVkQWdFQ2Z5QUFRYWdCYWlJRklBQW9BcVFDSWdSQkFYUnFJQUlnQUNnQ25BSWdCR3RCQVhRaUJCQUVHZ0pBQWtBQ1FBSkFBa0FnQUNnQ2lBSkJBV3NPQXdBQkFnTUxJQUFnQVNBRklBQW9BcHdDRUQwZ0FDQUJJQUFvQXFBQ1FRRjBhaUFDSUFScUlBTWdBQ2dDbkFKckVEME1Bd3NnQUNBQklBVWdBQ2dDbkFJUVFTQUFJQUVnQUNnQ29BSkJBWFJxSUFJZ0JHb2dBeUFBS0FLY0Ftc1FRUXdDQ3lBQUlBRWdCU0FBS0FLY0FoQkFJQUFnQVNBQUtBS2dBa0VCZEdvZ0FpQUVhaUFESUFBb0Fwd0NheEJBREFFTElBRWdCU0FBS0FLY0FrRUJkQkFFSUFBb0FxQUNRUUYwYWlBQ0lBUnFJQU1nQUNnQ25BSnJRUUYwRUFRYUN5QUZJQUlnQXlBQUtBS2tBaUlBYTBFQmRHb2dBRUVCZEJBRUdrRUFDOHdYQVF0L0l3QkJrQVZySWc4a0FDQVBJZ3BCQURZQ2pBVWdDa0lBTndPQUJTQUJLQUlFSVFnQ1FDQURSUTBBSUFoQkFVZ05BQU5BSUFBZ0NVR29JV3hxUVFBMkF0UVNJQWxCQVdvaUNTQUlSdzBBQ3dzZ0FDZ0M0RUlnQ0VnRVFDQUFRYWdoYWhBbUlRMGdBU2dDQkNFSUN3SkFJQWhCQVVjTkFDQUFLQUxnUWtFQ1J3MEFJQUVvQWd3Z0FDZ0NqQkpCNkFkc1JpRVNDd0pBQWtBZ0FDZ0MxQklOQUNBSVFRRklEUUJCQUNFSkEwQkJBaUVEUVFFaERrRzFmaUVMQWtBQ1FBSkFBa0FnQVNnQ0VDSU1EaFVEQmdZR0JnWUdCZ1lHQXdZR0JnWUdCZ1lHQmdFQUN5QU1RU2hHRFFFZ0RFRThSdzBGUVFRaEEwRURJUTRNQWd0QkJDRUREQUVMUVFRaEEwRUNJUTRMSUFBZ0NVR29JV3hxSWd3Z0F6WUNsQklnRENBT05nTFlFa0c0ZmlFTElBRW9BZ3hCQ25VaUEwRVBTdzBDUVFFZ0EzUkJnSkVDY1VVTkFpQU1JQU5CQVdvZ0FTZ0NDQkJySUExcUlRMGdDVUVCYWlJSklBRW9BZ1FpQ0VnTkFBc0xRUUloQ1FKQUlBRW9BZ0FpQTBFQ1J3UkFJQU1oQ1F3QkN5QUlRUUpIRFFBZ0FDZ0MzRUpCQVVjRVFFRUNJUWdnQUNnQzRFSkJBVWNOQVFzZ0FFRUFOZ0xZUWlBQVFRQTJBdEJDSUFCQnFEUnFJQUJCZ0JOcVFhd0NFQVFhSUFFb0FnUWhDQ0FCS0FJQUlRa0xJQUFnQ0RZQzRFSWdBQ0FKTmdMY1FrRzRmaUVMSUFFb0FnaEJ3RDVyUWNDNEFrc05BQUpBSUFKQkFVWU5BQ0FBS0FMVUVnMEFBa0FnQ0VFQlNBMEFRUUFoRGdOQVFRQWhDQ0FBSUE1QnFDRnNhaUlNS0FMWUVrRUFTZ1JBSUF4QjJCSnFJUU1EUUNBTUlBaEJBblJxUWVRU2FpQUVRUUVRQmpZQ0FDQUlRUUZxSWdnZ0F5Z0NBRWdOQUFzTElBd2dCRUVCRUFZMkF2QVNJQTVCQVdvaURpQUJLQUlFSWdoSURRQUxRUUFoQ3lBSVFRQk1EUUFEUUNBQUlBdEJxQ0ZzYWlJSlFnQTNBdlFTSUFsQi9CSnFRUUEyQWdBQ1FDQUpLQUx3RWtVTkFDQUpLQUxZRWlJRFFRRkdCRUFnQ1VIMEVtcEJBVFlDQUF3QkN5QUVJQU5CQW5SQjBEQnFLQUlBUVFnUUF5RURJQWxCMkJKcUtBSUFJZ3hCQVVnTkFDQURRUUZxSVFOQkFDRUlBMEFnQ1NBSVFRSjBha0gwRW1vZ0F5QUlka0VCY1RZQ0FDQUlRUUZxSWdnZ0RFZ05BQXNMSUF0QkFXb2lDeUFCS0FJRUlnaElEUUFMQ3lBQ0RRQWdBQ2dDMkJKQkFVZ05BQ0FBUVp3MGFpRU9RUUFoQ3dOQUFrQWdDRUVCU0EwQUlBNGdDMEVDZENJTWFpRVJRUUFoQ1NBTEJFQWdDMEVCYXlFREEwQWdBQ0FKUWFnaGJHb2lFQ0FNYWtIMEVtb29BZ0FFUUFKQUlBa05BQ0FJUVFKSERRQWdCQ0FLUVlBRmFoQWJJQkVvQWdBTkFDQUVJQXBCakFWcUVDVUxJQkFnQkNBTFFRRWdFQ0FEUVFKMGFrSDBFbW9vQWdCQkFFZEJBWFFRS0NBRUlBb2dFRUhORldvc0FBQWdFRUhPRldvc0FBQWdFQ2dDbUJJUUp5QUJLQUlFSVFnTElBbEJBV29pQ1NBSVNBMEFDd3dCQ3dOQUlBQWdDVUdvSVd4cUlnTW9BdlFTQkVBQ1FDQUpEUUFnQ0VFQ1J3MEFJQVFnQ2tHQUJXb1FHeUFSS0FJQURRQWdCQ0FLUVl3RmFoQWxDeUFESUFSQkFFRUJRUUFRS0NBRUlBb2dBMEhORldvc0FBQWdBMEhPRldvc0FBQWdBeWdDbUJJUUp5QUJLQUlFSVFnTElBbEJBV29pQ1NBSVNBMEFDd3NnQzBFQmFpSUxJQUFvQXRnU1NBMEFDd3NDUUNBSVFRSkhEUUFDUUFKQUFrQUNRQUpBQWtBZ0FnNERBQUlCQWdzZ0JDQUtRWUFGYWhBYklBQWdBQ2dDMUJKQkFuUnFRWXcwYWlnQ0FFVU5Bd3dFQ3lBQUlBQW9BdFFTUVFKMGFrSDBFbW9vQWdCQkFVWU5BUXNnQ2lBQUxnSFFRallDZ0FVZ0NpQUFMZ0hTUWpZQ2hBVU1Bd3NnQkNBS1FZQUZhaEFiSUFBZ0FDZ0MxQkpCQW5ScVFadzBhaWdDQUEwQkN5QUVJQXBCakFWcUVDVU1BUXNnQ2tFQU5nS01CUXNDUUNBQktBSUVJZ2hCQWtjTkFDQUtLQUtNQlEwQVFRSWhDQ0FBS0FMa1FrRUJSdzBBSUFCQnJDdHFRUUJCZ0FnUUJSb2dBRUVBTmdMc1FTQUFRUW82QUxBeklBQkI1QUEyQXF3eklBQkJBVFlDOERNZ0FTZ0NCQ0VJQ3dKL0lBZ2dBU2dDREd3Z0FTZ0NBQ0FCS0FJSWJFNGlFVVVFUUNBRklRd2dBRUdZRW1vTUFRc2dDaUFBS0FLWUVrRUNhaUFJYkVFQmRFRVBha0Z3Y1dzaURDSVBKQUFnQUVHWUVtb0xLQUlBSVFOQkFTRUlJQW9nRERZQ0FDQUtJQXdnQTBFQmRHcEJCR29pRGpZQ0JBSkFBa0FDUUFKQUFrQUNRQUpBQWtBZ0FrVUVRQ0FLS0FLTUJVVWhDQXdCQ3lBQUtBTGtRa1VOQUNBQktBSUVJUU1nQWtFQ1J3MEJJQU5CQWtjTkFTQUFJQUFvQXZ3elFRSjBha0djTkdvb0FnQkJBVVloQ0FzZ0FTZ0NCRUVBU2cwQkRBVUxJQU5CQVVnTkJDQUNRUUpIRFFFTUFnc2dDQVJBUVFFaENDQUFLQUxVRWlJTFFRQktRUUYwSVFNQ1FDQUxRUUZJRFFBZ0FrRUNSdzBBSUF0QkFuUWdBR3BCOEJKcUtBSUFRUUJIUVFGMElRTUxJQUFnQkNBS0tBSUFRUVJxSUFwQmlBVnFJQUlnQXhBY0lRTWdBQ0FBS0FMVUVrRUJhallDMUJJZ0F5QU5haUVOSUFFb0FnUWlDVUVDU0EwREEwQUNmMEVBSUFBb0F0UVNJQWhySWd0QkFVZ05BQm9nQWtFQ1J3UkFRUUZCQWlBQUtBTGtRaHNNQVFzZ0FDQUlRYWdoYkdvZ0MwRUNkR3BCOEJKcUtBSUFRUUJIUVFGMEN5RURJQUFnQ0VHb0lXeHFJZ3NnQkNBS0lBaEJBblJxS0FJQVFRUnFJQXBCaUFWcUlBSWdBeEFjSVFNZ0N5QUxLQUxVRWtFQmFqWUMxQklnQXlBTmFpRU5JQWhCQVdvaUNDQUJLQUlFSWdsSURRQUxEQU1MSUFKQkFrWU5BUXNnQUNBRUlBeEJCR29nQ2tHSUJXb2dBaUFBS0FMVUVrRUFTa0VCZEJBY0lRTWdBQ0FBS0FMVUVrRUJhallDMUJJZ0F5QU5haUVOSUFFb0FnUWlDVUVDU0EwQklBb29Bb2dGUVFGMElRUkJBU0VJQTBBZ0NpQUlRUUowYWlnQ0FFRUVha0VBSUFRUUJSb2dBQ0FJUWFnaGJHb2lBeUFES0FMVUVrRUJhallDMUJJZ0NFRUJhaUlJSUFFb0FnUWlDVWdOQUFzTUFRc2dBQ0FFSUF4QkJHb2dDa0dJQldwQkFnSi9RUUFnQUNnQzFCSWlBMEVCU0EwQUdpQURRUUowSUFCcVFmQVNhaWdDQUVFQVIwRUJkQXNRSENFRElBQWdBQ2dDMUJKQkFXbzJBdFFTSUFNZ0RXb2hEU0FCS0FJRUlnbEJBa2dOQUNBS0tBS0lCVUVCZENFRVFRRWhDQU5BSUFvZ0NFRUNkR29vQWdCQkJHcEJBQ0FFRUFVYUlBQWdDRUdvSVd4cUlnTWdBeWdDMUJKQkFXbzJBdFFTSUFoQkFXb2lDQ0FCS0FJRUlnbElEUUFMQ3lBSlFRSkhEUUFnQVNnQ0FFRUNSdzBBSUFCQjBNSUFhaUFNSUE0Z0NrR0FCV29nQUNnQ2pCSWdDaWdDaUFVUVpDQUtLQUtJQlNFRURBRUxJQXdnQUNnQzFFSTJBUUFnQUNBTUlBb29Bb2dGSWdSQkFYUnFLQUVBTmdMVVFnc2dCaUFCS0FJSUlBUnNJQUF1QVl3U1FlZ0hiRzBpQXpZQ0FDQVBJQU5CQVNBQktBSUFJZ3RCQWtZaUNSdEJBWFJCRDJwQmNIRnJJZzhpQXlRQUlBRW9BZ1FoQ0NBUlJRUkFJQU1nQUNnQ21CSWlCMEVDYWlBSWJFRUJkQ0lEUVE5cVFYQnhheUlNSkFBZ0NpQU1JQVVnQXhBRUlnTWdCMEVCZEdwQkJHbzJBZ1FnQ2lBRE5nSUFDeUFQSUFVZ0NSc2hEd0pBSUFzZ0NDQUlJQXRLRzBFQlNBMEFRUUFoQ1NBTUlRZ0RRQ0FBSUFsQnFDRnNha0dBRTJvZ0R5QUlRUUpxSUFRUVFpRUhBa0FnQVNnQ0FDSUxRUUpIRFFCQkFDRUlJQVlvQWdBaUJFRUJTQTBBQTBBZ0JTQUlRUUYwSWdNZ0NXcEJBWFJxSUFNZ0Qyb3ZBUUE3QVFBZ0NFRUJhaUlJSUFSSERRQUxDeUFISUExcUlRMGdDVUVCYWlJSklBc2dBU2dDQkNJSUlBZ2dDMG9iVGcwQklBb2dDVUVDZEdvb0FnQWhDQ0FLS0FLSUJTRUVEQUFMQUFzQ1FBSkFBa0FnQzBFQ1J3MEFJQWhCQVVjTkFDQVNEUUZCQUNFSUlBWW9BZ0FpQkVFQVRBMEFBMEFnQlNBSVFRSjBJZ05CQW5KcUlBTWdCV292QVFBN0FRQWdDRUVCYWlJSUlBUkhEUUFMQ3lBTklRc01BUXNnQUVHb05Hb2dEeUFNUVFKcUlBb29Bb2dGRUVJZ0RXb2hDeUFHS0FJQUlnTkJBVWdOQUVFQUlRZ0RRQ0FGSUFoQkFuUkJBbkpxSUE4Z0NFRUJkR292QVFBN0FRQWdDRUVCYWlJSUlBTkhEUUFMQzBFQUlRZ2dBU0FBS0FMRUlFRUNSZ1IvSUFBb0Fvd1NRUWhyUVh4eFFiZ0phaWdDQUNBQUtBS0VFbXdGUVFBTE5nSVVBa0FnQWtFQlJnUkFJQUFvQXVCQ0lnRkJBVWdOQVFOQUlBQWdDRUdvSVd4cVFRbzZBSWdTSUFoQkFXb2lDQ0FCUncwQUN3d0JDeUFBSUFvb0Fvd0ZOZ0xrUWdzTElBcEJrQVZxSkFBZ0N3c3hBUUYvSUFBUUpob2dBRUdvSVdvUUppRUJJQUJCMk1JQWFrRUFOZ0lBSUFCQ0FEY0MwRUlnQUVFQU5nTGtRaUFCQy93RUFRZC9JQUFvQW93U0lnUWdBRUdjSVdvb0FnQkhCRUFnQUNBRU5nS2NJU0FBUVpRaGFrS0FnSVNBZ0lEQUFEY0NBQ0FBUWFBaGFrS0NnSUNBd0FJM0FnQWdBQ0FBS0FLWUVrRUhkRFlDekNBTElBTUVRQ0FBSUFFZ0FoQjBJQUFnQUNnQ3dDQkJBV28yQXNBZ0R3c2dBQ0FBUWMwVmFpd0FBQ0lDTmdMRUlBSkFJQUpCQWtZRVFFRUFJUU1DUUNBQUtBS1VFaUlDUlEwQUlBSkJBblFnQVdwQkJHc2lDU2dDQUNJR1FRRklEUUFnQUVIUUlHb2hCeUFBS0FLY0VpRUtBMEFnQXlBQklBSWdCVUYvYzJvaUNFRUtiR29pQkM0QllpQUVMZ0ZnYWlBRUxnRmthaUFFTGdGbWFpQUVMZ0ZvYWlJRVNBUkFJQWNnQVNBSVFSQjBRUkIxUVFwc2FpSURMd0ZvT3dFSUlBY2dBeWtCWURjQkFDQUFJQUVnQ0VFQ2RHb29BZ0JCQ0hRMkFzd2dJQWtvQWdBaEJpQUVJUU1MSUFWQkFXb2lCU0FDUmcwQklBVWdDbXdnQmtnTkFBc0xJQUJCMENCcUlnUkNBRGNDQUNBQVFkZ2dha0VBT3dFQUlBQkIxQ0JxSUFNN0FRQWdBMEhNMlFCTUJFQWdBRUhXSUdwQkFEWUJBQ0FFUVFBMkFRQWdBRUdBNk13RklBTkJBU0FEUVFGS0cyNUJFSFJCRUhVZ0EwRVFkRUVRZFd4QkNuWTdBZFFnREFJTElBTkJ6dmtBU0EwQklBQkIxaUJxUVFBMkFRQWdBRUhRSUdwQkFEWUJBQ0FBUVlDQXpma0FJQU51SUFOQkVIUkJFSFZzUVE1Mk93SFVJQXdCQ3lBQVFkQWdha0lBTndJQUlBQkIyQ0JxUVFBN0FRQWdBQ0FFUVJCMFFSQjFRWUFrYkRZQ3pDQWdBQ2dDbEJJaEFnc2dBRUhhSUdvZ0FVRkFheUFBS0FLa0VrRUJkQkFFR2lBQVFaQWhhaUFCS0FLSUFUc0JBQ0FBUVpRaGFpQUNRUUowSUFGcUtRSUlOd0lBSUFCQnBDRnFJQUFvQXB3U05nSUFJQUJCb0NGcUlBSTJBZ0FMdlFFQkEzOGdBaTRCQWlJRVFRRk9CRUFnQWlnQ0dDQUVRZi8vQTNFZ0EyeEJBbTFxSVFSQkFDRURBMEFnQUNBRFFRRjBhaUFFTFFBQUlnVkJBWFpCQjNGQkNXdzdBUUFnQVNBRGFpQUNLQUlVSUFJdUFRSkJBV3NnQlVFQmNXd2dBMnBxTFFBQU9nQUFJQUFnQTBFQmNpSUdRUUYwYWlBRlFRVjJRUWxzT3dFQUlBRWdCbW9nQWlnQ0ZDQUdJQUl1QVFKQkFXc2dCVUVFZGtFQmNXeHFhaTBBQURvQUFDQUVRUUZxSVFRZ0EwRUNhaUlESUFJdUFRSklEUUFMQ3d2TEF3RUhmd0pBSUFNZ0JFd05BQ0FFUVFkT0JFQWdCQ0VHQTBBZ0FpNEJBaUFHUVFGMElnc2dBV29pQlVFRWF5NEJBR3dnQWk0QkFDQUZRUUpySWdrdUFRQnNhaUFDTGdFRUlBVkJCbXN1QVFCc2FpQUNMZ0VHSUFWQkNHc3VBUUJzYWlBQ0xnRUlJQVZCQ21zdUFRQnNhaUFDTGdFS0lBVkJER3N1QVFCc2FpRUlRUVloQndOQUlBZ2dBaUFIUVFGMElncHFMZ0VBSUFrZ0Ntc3VBUUJzYWlBQ0lBcEJBbkpxTGdFQUlBa2dCMEYvYzBFQmRHb3VBUUJzYWlFSUlBZEJBbW9pQnlBRVNBMEFDeUFBSUF0cUlBVXVBUUJCREhRZ0NHdEJDM1ZCQVdwQkFYVWlCVUdBZ0g0Z0JVR0FnSDVLR3lJRlFmLy9BU0FGUWYvL0FVZ2JPd0VBSUFaQkFXb2lCaUFEUncwQUN3d0JDeUFFSVFZRFFDQUFJQVpCQVhRaUJXb2dBU0FGYWlJRkxnRUFRUXgwSUFJdUFRSWdCVUVFYXk0QkFHd2dBaTRCQUNBRlFRSnJMZ0VBYkdvZ0FpNEJCQ0FGUVFackxnRUFiR29nQWk0QkJpQUZRUWhyTGdFQWJHb2dBaTRCQ0NBRlFRcHJMZ0VBYkdvZ0FpNEJDaUFGUVF4ckxnRUFiR3ByUVF0MVFRRnFRUUYxSWdWQmdJQitJQVZCZ0lCK1Noc2lCVUgvL3dFZ0JVSC8vd0ZJR3pzQkFDQUdRUUZxSWdZZ0EwY05BQXNMSUFCQkFDQUVRUUYwRUFVYUMwb0JBWDlCQUNBQ1FRRnFJQUpCQUVnYklnSWdBQ2dDQUNJRFNBUkFJQUFvQWdnZ0FXb2hBUU5BSUFBZ0Ftb3RBQXdnQVVZRVFDQUNEd3NnQWtFQmFpSUNJQU5JRFFBTEMwRi9DMG9CQVg5QkFDQUNRUUZxSUFKQkFFZ2JJZ0lnQUNnQ0FDSURTQVJBSUFGQkFYUkJBWEloQVFOQUlBQWdBbW90QUF3Z0FVWUVRQ0FDRHdzZ0FrRUJhaUlDSUFOSURRQUxDMEYvQzBjQkFYOUJBQ0FDUVFGcUlBSkJBRWdiSWdJZ0FDZ0NBQ0lEU0FSQUlBRkJBWFFoQVFOQUlBQWdBbW90QUF3Z0FVWUVRQ0FDRHdzZ0FrRUJhaUlDSUFOSURRQUxDMEYvQzdzQ0FBSkFJQUZCRkVzTkFBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFJQUZCQ1dzT0NnQUJBZ01FQlFZSENBa0tDeUFDSUFJb0FnQWlBVUVFYWpZQ0FDQUFJQUVvQWdBMkFnQVBDeUFDSUFJb0FnQWlBVUVFYWpZQ0FDQUFJQUUwQWdBM0F3QVBDeUFDSUFJb0FnQWlBVUVFYWpZQ0FDQUFJQUUxQWdBM0F3QVBDeUFDSUFJb0FnQkJCMnBCZUhFaUFVRUlhallDQUNBQUlBRXBBd0EzQXdBUEN5QUNJQUlvQWdBaUFVRUVhallDQUNBQUlBRXlBUUEzQXdBUEN5QUNJQUlvQWdBaUFVRUVhallDQUNBQUlBRXpBUUEzQXdBUEN5QUNJQUlvQWdBaUFVRUVhallDQUNBQUlBRXdBQUEzQXdBUEN5QUNJQUlvQWdBaUFVRUVhallDQUNBQUlBRXhBQUEzQXdBUEN5QUNJQUlvQWdCQkIycEJlSEVpQVVFSWFqWUNBQ0FBSUFFckF3QTVBd0FQQ3lBQUlBSkJBQkVHQUFzTFNnRURmeUFBS0FJQUxBQUFRVEJyUVFwSkJFQURRQ0FBS0FJQUlnRXNBQUFoQXlBQUlBRkJBV28yQWdBZ0F5QUNRUXBzYWtFd2F5RUNJQUVzQUFGQk1HdEJDa2tOQUFzTElBSUxFZ0FnQUVVRVFFRUFEd3NnQUNBQkVJNEJDL0VEQVFaL0l3QkI4QUJySWdna0FFRi9JUWNDUUFKQUFrQWdBVVVOQUNBQ1JRMEFEQUVMSUFRZ0FDZ0NERUdRQTIxdkRRRUxJQUZCQUNBQ0cwVUVRRUVBSVFJRFFDQUFRUUJCQUNBRElBQW9BZ2dnQW14QkFuUnFJQVFnQW1zUUV5SUhRUUJJSWdFTkFpQUNJQUlnQjJvaUJ5QUJHeUVCSUFjaEFpQUJJQVJJRFFBTElBQWdBVFlDU0F3QkN5QUNRUUJJRFFBQ1FDQUJMUUFBSWdkQmdBRnhCRUFnQjBFRmRrRURjU0lIUWM0SWFrSE5DQ0FIR3lFS1Flb0hJUWtNQVFzQ2Z5QUhRZUFBY1VIZ0FFWUVRRUhwQnlFSlFkRUlRZEFJSUFkQkVIRWJEQUVMUWVnSElRa2dCMEVGZGtFRGNVSE5DR29MSVFvTElBRWdBQ2dDREJBNklRc2dBUzBBQUNFTUlBRWdBaUFGSUFoQjZ3QnFJQWdnQ0VIc0FHb2dCaEEzSWdWQkFFZ0VRQ0FGSVFjTUFRc2dBU0FJS0FKc2FpRUJRWDRoQnlBRklBdHNJQVJLRFFBZ0FDQUxOZ0pBSUFBZ0NqWUNOQ0FBSUFrMkFqZ2dBRUVDUVFFZ0RFRUVjUnMyQWpBQ1FDQUZRUUZJQkVCQkFDRUhEQUVMUVFBaEFrRUFJUWNEUUNBQUlBRWdDQ0FDUVFGMGFpSUpMZ0VBSUFNZ0FDZ0NDQ0FIYkVFQ2RHb2dCQ0FIYXhBVElnWkJBRWdFUUNBR0lRY01Bd3NnQmlBSGFpRUhJQUVnQ1M0QkFHb2hBU0FDUVFGcUlnSWdCVWNOQUFzTElBQWdCellDU0NBQVFnQTNBa3dMSUFoQjhBQnFKQUFnQnd0N0FRSjhJQUFnQUtJaUFpQUNJQUtpb2lBQ1JIelZ6MW82MmVVOW9rVHJuQ3VLNXVWYXZxQ2lJQUlnQWtSOS9yRlg0eDNIUHFKRTFXSEJHYUFCS3IrZ29rU20rQkFSRVJHQlA2Q2dJUU1nQUNBQ0lBRkVBQUFBQUFBQTREK2lJQUlnQUtJaUFDQURvcUdpSUFHaElBQkVTVlZWVlZWVnhUK2lvS0VMdmdFQkFuOGpBRUVRYXlJQkpBQUNmQ0FBdlVJZ2lLZEIvLy8vL3dkeElnSkIrOE9rL3dOTkJFQkVBQUFBQUFBQThEOGdBa0dld1pyeUEwa05BUm9nQUVRQUFBQUFBQUFBQUJBdERBRUxJQUFnQUtFZ0FrR0FnTUQvQjA4TkFCb0NRQUpBQWtBQ1FDQUFJQUVRbEFGQkEzRU9Bd0FCQWdNTElBRXJBd0FnQVNzRENCQXREQU1MSUFFckF3QWdBU3NEQ0JCUG1nd0NDeUFCS3dNQUlBRXJBd2dRTFpvTUFRc2dBU3NEQUNBQkt3TUlFRThMSVFBZ0FVRVFhaVFBSUFBTCt3RUJCWDhnQWtFQmF5SURRWUFDVHdSQUlBQWdBVUVZSUFObmF5SUZkaUlDSUFKQkFXb2dBeUFGZGtFQmFoQWhRWDhnQlhSQmYzTWdBWEVoQmlBQUtBSU1JUUlDUUNBQUtBSVFJZ0VnQldvaUJFRWhTUVJBSUFFaEF3d0JDd05BUVg4aEJDQUFJQUFvQWdRaUF5QUFLQUlJSWdjZ0FDZ0NHR3BMQkg4Z0FDQUhRUUZxSWdRMkFnZ2dBQ2dDQUNBRElBUnJhaUFDT2dBQVFRQUZRWDhMSUFBb0FpeHlOZ0lzSUFKQkNIWWhBaUFCUVE5S0lRUWdBVUVJYXlJRElRRWdCQTBBQ3lBRElBVnFJUVFMSUFBZ0JEWUNFQ0FBSUFZZ0EzUWdBbkkyQWd3Z0FDQUFLQUlVSUFWcU5nSVVEd3NnQUNBQklBRkJBV29nQWhBaEN6Z0JBWDhnQUNBQUtBSWNJQUZ1SWdJMkFpUWdBQ2dDSUNBQ2JpSUFRWDl6SUFGcVFRQWdBRUVCYWlJQUlBRnJJZ0VnQUNBQlNSdHFDL29DQVFaL0lBQkNnSUNBZ0lBUU53SVlJQUJDZ0lDQWdKQUJOd0lRSUFCQ0FEY0NDQ0FBSUFJMkFnUWdBQ0FCTmdJQUlBSUVRQ0FBUVFFMkFoZ2dBUzBBQUNFRVFRRWhBd3NnQUVFQU5nSXNJQUFnQkRZQ0tDQUFRWUNBQWpZQ0hDQUFRUkUyQWhRZ0FDQUVRUUYyUWY4QWN5SUdOZ0lnQWtBZ0FpQURUUVJBSUFNaEJRd0JDeUFBSUFOQkFXb2lCVFlDR0NBQklBTnFMUUFBSVFjTElBQWdCellDS0NBQVFZQ0FnQVEyQWh3Z0FFRVpOZ0lVSUFBZ0J5QUVRUWgwY2tFQmRrSC9BWEVnQmtFSWRISkIvd0Z6SWdnMkFpQkJBQ0VESUFBQ2Z5QUNJQVZOQkVBZ0JTRUdRUUFNQVFzZ0FDQUZRUUZxSWdZMkFoZ2dBU0FGYWkwQUFBc2lCRFlDS0NBQVFZQ0FnSUI0TmdJY0lBQkJJVFlDRkNBQUlBUWdCMEVJZEhKQkFYWkIvd0Z4SUFoQkNIUnlRZjhCY3lJRk5nSWdJQUlnQmtzRVFDQUFJQVpCQVdvMkFoZ2dBU0FHYWkwQUFDRURDeUFBSUFNMkFpZ2dBQ0FESUFSQkNIUnlRUUYyUWY4QmNTQUZRUWgwY2tIL0FYTTJBaUFMMUFJQkJuOENRQ0FCSUFKT0RRQWdDRUVCSUFoQkFVb2JJUXNDUUNBR0lBaElEUUFnQVNFS0EwQUNRQ0FFSUFwQkFuUWlDV29pRENnQ0FFRUhTZzBBSUFVZ0NXb29BZ0FOQUVFQUlRa0RRQ0FIUVFFUUNTRU5JQU1nQUNnQ0NDQUpiQ0FLYWtFQ2RHb2lEaUFPS2dJQUlBMnlRd0FBQUwrU1FRRkJEU0FNS0FJQWEzU3lsRU1BQUlBNGxKSTRBZ0FnQ1VFQmFpSUpJQXRIRFFBTElBWWdDMnNoQmdzZ0NrRUJhaUlLSUFKT0RRRWdCaUFJVGcwQUN3c2dCaUFJU0EwQUEwQUNRQ0FFSUFGQkFuUWlDbW9pRENnQ0FFRUhTZzBBUVFBaENTQUZJQXBxS0FJQVFRRkhEUUFEUUNBSFFRRVFDU0VLSUFNZ0FDZ0NDQ0FKYkNBQmFrRUNkR29pRFNBTktnSUFJQXF5UXdBQUFMK1NRUUZCRFNBTUtBSUFhM1N5bEVNQUFJQTRsSkk0QWdBZ0NVRUJhaUlKSUF0SERRQUxJQVlnQzJzaEJnc2dBVUVCYWlJQklBSk9EUUVnQmlBSVRnMEFDd3NMbkFjQ0NYOEdmU01BSWdNaENpQURRYkFLYXlJRUlnTWtBQ0FEUWFBUGF5SUdJZ01rQUNBRFFlQUpheUlISkFCQkFDRURBMEFnQkNBRFFRSjBhaUFBSUFOQkEzUnFLZ0lBT0FJQUlBTkJBV29pQTBITUFrY05BQXRCQUNFREEwQWdCaUFEUVFKMGFpQUJJQU5CQTNScUtnSUFPQUlBSUFOQkFXb2lBMEhuQTBjTkFBc2dCQ0FHSUFkQnpBSkJtd0VRTTBNQUFJQS9JUXhCQUNFREEwQWdEQ0FHSUFOQkFuUnFLZ0lBSWc0Z0RwU1NJUXdnQTBFQmFpSURRY3dDUncwQUMwTUFBSUMvSVJGQkFTRUVRUUFoQTBNQUFJQy9JUTREUUFKQUlBY2dBMEVDZENJSmFpb0NBQ0lOUXdBQUFBQmVRUUZ6RFFBZ0VDQU5ROHk4akN1VUlnMGdEWlFpRFpRZ0RpQU1sRjVCQVhNTkFDQVBJQTJVSUJFZ0RKUmVCRUFnQlNFRUlBTWhCU0FSSVE0Z0RTRVJJQThoRUNBTUlROE1BUXNnQXlFRUlBMGhEaUFNSVJBTElBd2dCaUFEUWN3Q2FrRUNkR29xQWdBaURDQU1sQ0FHSUFscUtnSUFJZ3dnREpTVGtrTUFBSUEvbHlFTUlBTkJBV29pQTBHYkFVY05BQXRCQUNBRVFRRjBheUVMUVFBZ0JVRUJkR3NoQmdOQUlBY2dDRUVDZENJRWFpSUpRUUEyQWdBQ1FDQUdJQWhxSWdNZ0EwRWZkU0lEYWlBRGMwRURUd1JBSUFnZ0Myb2lBeUFEUVI5MUlnTnFJQU56UVFKTERRRUxJQUVnQkdvaEJVRUFJUU5EQUFBQUFDRU1BMEFnRENBQUlBTkJBblFpQkdvcUFnQWdCQ0FGYWlvQ0FKU1NJUXdnQTBFQmFpSURRWmdGUncwQUN5QUpJQXhEQUFDQXY1YzRBZ0FMSUFoQkFXb2lDRUcyQWtjTkFBdERBQUNBUHlFTVFRQWhBd05BSUF3Z0FTQURRUUowYWlvQ0FDSVBJQStVa2lFTUlBTkJBV29pQTBHWUJVY05BQXRCQUNFRlF3QUFnTDhoRVVNQUFBQUFJUTlCQUNFQVFRQWhBME1BQUFBQUlSQkRBQUNBdnlFT0EwQUNRQ0FISUFOQkFuUWlCR29xQWdBaURVTUFBQUFBWGtFQmN3MEFJQkFnRFVQTXZJd3JsQ0lOSUEyVUlnMlVJQTRnREpSZVFRRnpEUUFnRHlBTmxDQVJJQXlVWGdSQUlBTWhBQ0FSSVE0Z0RTRVJJQThoRUNBTUlROE1BUXNnRFNFT0lBd2hFQXNnRENBQklBTkJtQVZxUVFKMGFpb0NBQ0lNSUF5VUlBRWdCR29xQWdBaURDQU1sSk9TUXdBQWdEK1hJUXdnQTBFQmFpSURRYllDUncwQUN3SkFJQUJCQVVnTkFDQUFRYlVDVGcwQUlBY2dBRUVDZEdvaUFTb0NCQ0lPSUFGQkJHc3FBZ0FpRUpNZ0FTb0NBQ0lQSUJDVFF6TXpNeitVWGdSQVFYOGhCUXdCQ3lBUUlBNlRJQThnRHBORE16TXpQNVJlUlEwQVFRRWhCUXNnQWlBRklBQkJBWFJxTmdJQUlBb2tBQXYyQkFJRmZ3dDlJd0JCTUdzaUJDUUFJQUFvQWdBaEJrRUJJUVVEUUNBQklBVkJBblJxSUFWQkEzUWlCeUFHYWlJSUtnSUFJQWhCQkdzcUFnQWdCaUFIUVFSeWFpb0NBSkpEQUFBQVA1U1NRd0FBQUQrVU9BSUFJQVZCQVdvaUJVR0FDRWNOQUFzZ0FTQUdLZ0lFUXdBQUFEK1VJQVlxQWdDU1F3QUFBRCtVSWdrNEFnQWdBa0VDUmdSQUlBQW9BZ1FoQUVFQklRVURRQ0FCSUFWQkFuUnFJZ0lnQWlvQ0FDQUZRUU4wSWdJZ0FHb2lCaW9DQUNBR1FRUnJLZ0lBSUFBZ0FrRUVjbW9xQWdDU1F3QUFBRCtVa2tNQUFBQS9sSkk0QWdBZ0JVRUJhaUlGUVlBSVJ3MEFDeUFCSUFrZ0FDb0NCRU1BQUFBL2xDQUFLZ0lBa2tNQUFBQS9sSkk0QWdBTFFRQWhCU0FCSUFSQkVHcEJBRUVBUVFRZ0F4QTBJQVFnQkNvQ0VFTkhBNEEvbERnQ0VDQUVJQVFxQWhRaUNTQUpRMjhTQXp5VVEyOFNBenlVa3pnQ0ZDQUVJQVFxQWhnaUNTQUpRMjhTZ3p5VVEyOFNnenlVa3pnQ0dDQUVJQVFxQWh3aUNTQUpRNmFieER5VVE2YWJ4RHlVa3pnQ0hDQUVJQVFxQWlBaUNTQUpRMjhTQXoyVVEyOFNBejJVa3pnQ0lDQUVJQVJCRUdwQkJCQTJJQVFxQWd4REt2WW5QNVFpQ1NBRUtnSUlRNzJmT2orVUlncER6Y3hNUDVTU0lRMGdDaUFFS2dJRVF5aGNUeitVSWdwRHpjeE1QNVNTSVE0Z0NpQUVLZ0lBUTJabVpqK1VJZ3BEemN4TVA1U1NJUThnQ1VQTnpFdy9sQ0VRSUFwRHpjeE1QNUloRVVNQUFBQUFJUWxEQUFBQUFDRUtBMEFnQVNBRlFRSjBhaUlBSUJBZ0VwUWdEU0FMbENBT0lBeVVJQThnQ1pRZ0VTQUtsQ0FBS2dJQUloT1NrcEtTa2pnQ0FDQUxJUklnRENFTElBa2hEQ0FLSVFrZ0V5RUtJQVZCQVdvaUJVR0FDRWNOQUFzZ0JFRXdhaVFBQyswRUFnWi9BWDBnQXlBQ1FRRnFJZ01nQVNBQklBSktJZ1ViUVFKMFFZQ3hBV29vQWdBZ0FTQURJQUVnQTBvYlFRSjBhaWdDQUNBQklBSWdBU0FDU0J0QkFuUkJnTEVCYWlnQ0FDQUJJQUlnQlJ0QkFuUnFLQUlBYWhBV0lRUWdBVUVEVGdSQUEwQUNmeUFCSWdVZ0Frd0VRQ0FDSVFNQ1FDQUZRUUowSWdaQmdMRUJhaWdDQUNJSUlBWnFLQUlBSUFRZ0FrRUNkQ0FJYWlnQ0JDSUhRWDlCQUNBRUlBZFBHeUlIY1dzaUJFc0VRQU5BSUFGQkFXc2lBVUVDZEVHQXNRRnFLQUlBSUFacUtBSUFJZ2tnQkVzTkFBd0NDd0FMQTBBZ0F5SUJRUUZySVFNZ0NDQUJRUUowYWlnQ0FDSUpJQVJMRFFBTEN5QUFJQUlnQjJvZ0FXc2dCM05CRUhSQkVIVWlBallDQUNBS0lBS3lJZ29nQ3BTU0lRb2dBU0VDSUFRZ0NXc01BUXNnQlVFQ2RDSURJQUpCQVdvaUNFRUNkRUdBc1FGcUtBSUFhaWdDQUNFQkFrQWdCQ0FDUVFKMFFZQ3hBV29vQWdBZ0Eyb29BZ0FpQmtrTkFDQUJJQVJORFFBZ0FFRUFOZ0lBSUFRZ0Jtc01BUXNnQkNBQlFYOUJBQ0FCSUFSTkd5SUVjV3NoQmdOQUlBWWdBaUlCUVFGcklnSkJBblJCZ0xFQmFpZ0NBQ0FEYWlnQ0FDSUhTUTBBQ3lBQUlBUWdDR29nQVdzZ0JITkJFSFJCRUhVaUFUWUNBQ0FLSUFHeUlnb2dDcFNTSVFvZ0JpQUhhd3NoQkNBRlFRRnJJUUVnQUVFRWFpRUFJQVZCQTBvTkFBc0xJQUFnQWlBRUlBSkJBWFJCQVhJaUFVOGlBbXNnQkNBQlFYOUJBQ0FDR3lJQ2NXc2lBMEVCYWlJRlFRRjJJZ0ZySUFKelFSQjBRUkIxSWdJMkFnQWdBQ0FCSUFNZ0JVRitjVUVCYTBFQUlBRWJheUlBYTBFQUlBQnJjMEVRZEVFUWRTSUFOZ0lFSUFvZ0FySWlDaUFLbEpJZ0FMSWlDaUFLbEpJTG5RSUJCbjhnQUNBQlFRRnJJZ2hCQW5ScUtBSUFJZ2NnQjBFZmRTSUVhaUFFY3lFRUlBZEJIM1loQlFOQUlBRWdDRUVCYXlJSGF5SUdJQVFnQkNBR1NodEJBblJCZ0xFQmFpZ0NBQ0FHSUFRZ0JDQUdTQnRCQW5ScUtBSUFJQVZxSVFVZ0JDQUFJQWRCQW5ScUtBSUFJZ2tnQ1VFZmRTSUVhaUFFYzJvaEJDQUpRWDlNQkVBZ0JTQUVRUUZxSWdVZ0JpQUVJQVpJRzBFQ2RFR0FzUUZxS0FJQUlBWWdCU0FGSUFaSUcwRUNkR29vQWdCcUlRVUxJQWhCQVVvaEJpQUhJUWdnQmcwQUN5QURJQVVnQWtFQmFpSUFJQUVnQVNBQ1NpSURHMEVDZEVHQXNRRnFLQUlBSUFFZ0FDQUFJQUZJRzBFQ2RHb29BZ0FnQVNBQ0lBRWdBa2diUVFKMFFZQ3hBV29vQWdBZ0FTQUNJQU1iUVFKMGFpZ0NBR29RVVF2N0JBSUpmd045SXdCQkVHc2lCU0VISUFVa0FDQUZRZUFBYXlJSklnVWtBQ0FGSUFOQkdHb2lCa0VDZEVFUGFrRndjV3NpQ0NRQUlBWUNmMEVBSWdWQkFBMEFHZ05BSUFrZ0JVRUNkR29nQVNBRlFYOXpRUmhxUVFKMGFpb0NBRGdDQUNBRlFRRnFJZ1ZCR0VjTkFBdEJBQ0lGUVFBTkFCb0RRQ0FJSUFWQkFuUnFJQVFnQlVGL2MwRVlha0VDZEdvcUFnQ01PQUlBSUFWQkFXb2lCVUVZUncwQUMwRVlDeUlGU2dSQUlBZ2dCVUVDZEdwQkFDQUdJQVZyUVFKMEVBVWFDMEVBSVFZZ0EwRUVUZ1JBSUFOQkEyc2hDd05BSUFjZ0FDQUdRUUowSWdWcUtnSUFPQUlBSUFjZ0FDQUZRUVJ5SWd4cUtnSUFPQUlFSUFjZ0FDQUZRUWh5SWcxcUtnSUFPQUlJSUFjZ0FDQUZRUXh5SWc1cUtnSUFPQUlNSUFrZ0JTQUlhaUFIRURVZ0NDQUdRUmhxUVFKMGFpSUtJQWNxQWdBaUQ0dzRBZ0FnQWlBRmFpQVBPQUlBSUFvZ0J5b0NCQ0FQSUFFcUFnQ1VreUlRakRnQ0JDQUNJQXhxSUJBNEFnQWdDaUFIS2dJSUlCQWdBU29DQUpTVElBOGdBU29DQkpTVEloR01PQUlJSUFJZ0RXb2dFVGdDQUNBS0lBY3FBZ3dnRVNBQktnSUFsSk1nRUNBQktnSUVsSk1nRHlBQktnSUlsSk1pRDR3NEFnd2dBaUFPYWlBUE9BSUFJQVpCQkdvaUJpQUxTQTBBQ3dzZ0F5QUdTZ1JBQTBBZ0FDQUdRUUowSWdGcUtnSUFJUTlCQUNFRkEwQWdEeUFKSUFWQkFuUnFLZ0lBSUFnZ0JTQUdha0VDZEdvcUFnQ1VreUVQSUFWQkFXb2lCVUVZUncwQUN5QUlJQVpCR0dwQkFuUnFJQTg0QWdBZ0FTQUNhaUFQT0FJQUlBWkJBV29pQmlBRFJ3MEFDd3RCQUNFRkEwQWdCQ0FGUVFKMGFpQUNJQVZCZjNNZ0EycEJBblJxS2dJQU9BSUFJQVZCQVdvaUJVRVlSdzBBQ3lBSFFSQnFKQUFMNkFJQ0IzOEJmU01BUVJCcklnVWhCQ0FGSkFBZ0JVSGdBR3NpQmlRQVFRQWhCUU5BSUFZZ0JVRUNkR29nQVNBRlFYOXpRUmhxUVFKMGFpb0NBRGdDQUNBRlFRRnFJZ1ZCR0VjTkFBdEJBQ0VCSUFOQkJFNEVRQ0FEUVFOcklRY0RRQ0FFSUFBZ0FVRUNkQ0lGYWlJSUtnSUFPQUlBSUFRZ0FDQUZRUVJ5SWdscUtnSUFPQUlFSUFRZ0FDQUZRUWh5SWdwcUtnSUFPQUlJSUFRZ0FDQUZRUXh5SWd0cUtnSUFPQUlNSUFZZ0NFSGdBR3NnQkJBMUlBSWdCV29nQkNvQ0FEZ0NBQ0FDSUFscUlBUXFBZ1E0QWdBZ0FpQUthaUFFS2dJSU9BSUFJQUlnQzJvZ0JDb0NERGdDQUNBQlFRUnFJZ0VnQjBnTkFBc0xJQUVnQTBnRVFBTkFJQUZCR0dzaEJ5QUFJQUZCQW5RaUNHb3FBZ0FoREVFQUlRVURRQ0FNSUFZZ0JVRUNkR29xQWdBZ0FDQUZJQWRxUVFKMGFpb0NBSlNTSVF3Z0JVRUJhaUlGUVJoSERRQUxJQUlnQ0dvZ0REZ0NBQ0FCUVFGcUlnRWdBMGNOQUFzTElBUkJFR29rQUF1ZkdRSTFmd1Y5SXdCQjRDRnJJZ1loQXlBR0pBQWdBQ2dDQ0NJSVFRRWdDRUVCU2hzaEZVRUFJQUZySVJFZ0FDZ0NBQ0lLS0FJRUlnbEJnQkJxSVFRZ0NpZ0NJQ0VTSUFvb0FnZ2hDd05BSUFWQkFuUWlCeUFEUWRnaGFtb2dBQ0FFSUFWc1FRSjBha0hjQUdvaUV6WUNBQ0FEUWRBaGFpQUhhaUFUSUJGQkFuUnFRWUJBYXpZQ0FDQUZRUUZxSWdVZ0ZVY05BQXNnQUNBRUlBaHNRUUowYWtIY0FHb2hEQ0FBS0FJVUlRUUNRQUpBQWtBZ0FDZ0NOQ0lUUVFSS0RRQWdCQTBBSUFBb0FqaEZEUUVMSUF3Z0NFSGdBR3hxSVE0Z0JDQUFLQUlZSWdjZ0NpZ0NEQ0lGSUFVZ0Iwb2JJZ3hLSVJFZ0JpQUJJQWhzUVFKMFFROXFRWEJ4YXlJUEpBQWdCQ0FIU0FSQUlBNGdDMEVEZENJRmFpQUZhaUFGYWlFTlF3QUFBRDlEQUFEQVB5QVRHeUU0UVFBaEJnTkFJQVlnQzJ3aEZDQUVJUVVEUUNBT0lBVWdGR3BCQW5RaUZtb2lGeUFOSUJacUtnSUFJamtnRnlvQ0FDQTRreUk2SURrZ09sNGJPQUlBSUFWQkFXb2lCU0FIUncwQUN5QUdRUUZxSWdZZ0ZVY05BQXNMSUFRZ0RDQVJHeUVSSUFBb0FpZ2hCZ0pBSUFoQkFVZ05BQ0FFSUF4T0RRQkJBQ0VMQTBBZ0FTQUxiQ0VVSUFRaEJ3TkFRUUFoQlNBU0lBZEJBWFJxTGdFQUlnMGdBblFnRkdvaERDQVNJQWRCQVdvaUIwRUJkR291QVFBZ0RXc2dBblFpRFVFQVNnUkFBMEFnRHlBRklBeHFRUUowYWlBR1FZM001UUJzUWQvbXUrTURhaUlHUVJSMXNqZ0NBQ0FGUVFGcUlnVWdEVWNOQUFzTElBOGdERUVDZEdvZ0RVTUFBSUEvSUFBb0FpUVFMaUFISUJGSERRQUxJQXRCQVdvaUN5QUlSdzBBQ3dzZ0FDQUdOZ0lvSUFsQkFYWWdBV3RCQW5SQmdFQnJJUVpCQUNFRkEwQWdBMEhZSVdvZ0JVRUNkR29vQWdBaUNTQUpJQUZCQW5ScUlBWVFEaG9nQlVFQmFpSUZJQlZIRFFBTElBb2dEeUFEUWRBaGFpQU9JQVFnRVNBSUlBaEJBQ0FDSUFBb0FoQkJBQ0FBS0FJa0VDSU1BUXNDZlNBVFJRUkFJQU5CMkNGcUlBTkI4QUJxSUFnZ0FDZ0NKQkJXSUFOQmtBeHFJQU5COEFCcUlBTVFWU0FBUWRBRklBTW9BZ0JySWdJMkFqQkRBQUNBUHd3QkN5QUFLQUl3SVFKRHpjeE1Qd3NoUENBQ1FRRjBJZ1JCZ0FnZ0JFR0FDRWdiSWdkQmZ5QUhRWDlLR3lJRVFRRWdCRUVCU0JzZ0IwRUFJQWRySWdRZ0JDQUhTQnRCQVhac0lnUkJBU0FFUVFGS0d5RVpJQVlnQ1VFQ2RFRVBha0Z3Y1dzaUVpSUVKQUJCZ0FnZ0Iyc2hHa0dBQ0NBSFFRRjFheUViSUFNZ0IwRUNkQ0lOYTBIUUlXb2hGQ0FKUVFKdElSeEJnQWdnQW1zaEhTQUJJQWxxSWdoQkFuUWhIa0dBRUNBQmF5SU9RUUowSVJZZ0JDQU5RUTlxUVhCeGF5SVhKQUFnQTBIUUFXb2hEeUFLS0FJOElRdEIvdzhnQVd0QkFuUWhIMEgrRHlBQmEwRUNkQ0VnUWYwUElBRnJRUUowSVNGQi9BOGdBV3RCQW5RaElrSDdEeUFCYTBFQ2RDRWpRZm9QSUFGclFRSjBJU1JCK1E4Z0FXdEJBblFoSlVINER5QUJhMEVDZENFbVFmY1BJQUZyUVFKMElTZEI5ZzhnQVd0QkFuUWhLRUgxRHlBQmEwRUNkQ0VwUWZRUElBRnJRUUowSVNwQjh3OGdBV3RCQW5RaEswSHlEeUFCYTBFQ2RDRXNRZkVQSUFGclFRSjBJUzFCOEE4Z0FXdEJBblFoTGtIdkR5QUJhMEVDZENFdlFlNFBJQUZyUVFKMElUQkI3UThnQVd0QkFuUWhNVUhzRHlBQmEwRUNkQ0V5UWVzUElBRnJRUUowSVROQjZnOGdBV3RCQW5RaE5FSHBEeUFCYTBFQ2RDRTFRZWdQSUFGclFRSjBJVFpCQUNFS0EwQWdBMEhZSVdvZ0NrRUNkR29vQWdBaEJFRUFJUVVEUUNBRlFRSjBJZ1lnQTBId0FHcHFJQVFnQm1wQm9COXFLZ0lBT0FJQUlBVkJBV29pQlVHWUNFY05BQXNDUUNBVEJFQWdDa0VZYkNFRkRBRUxJQThnQXlBTElBbEJHQ0FBS0FJa0VEUWdBeUFES2dJQVEwY0RnRCtVT0FJQUlBTWdBeW9DQkNJNElEaER2amVHT0pTVE9BSUVJQU1nQXlvQ0NDSTRJRGhEdmplR09KUWlPQ0E0a2lJNElEaVNremdDQ0NBRElBTXFBZ3dpT0NBNFE3NDNoamlVUXdBQVFFQ1VRd0FBUUVDVWt6Z0NEQ0FESUFNcUFoQWlPQ0E0UTc0M2hqaVVRd0FBZ0VDVVF3QUFnRUNVa3pnQ0VDQURJQU1xQWhRaU9DQTRRNzQzaGppVVF3QUFvRUNVUXdBQW9FQ1VremdDRkNBRElBTXFBaGdpT0NBNFE3NDNoamlVUXdBQXdFQ1VRd0FBd0VDVWt6Z0NHQ0FESUFNcUFod2lPQ0E0UTc0M2hqaVVRd0FBNEVDVVF3QUE0RUNVa3pnQ0hDQURJQU1xQWlBaU9DQTRRNzQzaGppVVF3QUFBRUdVUXdBQUFFR1VremdDSUNBRElBTXFBaVFpT0NBNFE3NDNoamlVUXdBQUVFR1VRd0FBRUVHVWt6Z0NKQ0FESUFNcUFpZ2lPQ0E0UTc0M2hqaVVRd0FBSUVHVVF3QUFJRUdVa3pnQ0tDQURJQU1xQWl3aU9DQTRRNzQzaGppVVF3QUFNRUdVUXdBQU1FR1VremdDTENBRElBTXFBakFpT0NBNFE3NDNoamlVUXdBQVFFR1VRd0FBUUVHVWt6Z0NNQ0FESUFNcUFqUWlPQ0E0UTc0M2hqaVVRd0FBVUVHVVF3QUFVRUdVa3pnQ05DQURJQU1xQWpnaU9DQTRRNzQzaGppVVF3QUFZRUdVUXdBQVlFR1VremdDT0NBRElBTXFBandpT0NBNFE3NDNoamlVUXdBQWNFR1VRd0FBY0VHVWt6Z0NQQ0FESUFNcUFrQWlPQ0E0UTc0M2hqaVVRd0FBZ0VHVVF3QUFnRUdVa3pnQ1FDQURJQU1xQWtRaU9DQTRRNzQzaGppVVF3QUFpRUdVUXdBQWlFR1VremdDUkNBRElBTXFBa2dpT0NBNFE3NDNoamlVUXdBQWtFR1VRd0FBa0VHVWt6Z0NTQ0FESUFNcUFrd2lPQ0E0UTc0M2hqaVVRd0FBbUVHVVF3QUFtRUdVa3pnQ1RDQURJQU1xQWxBaU9DQTRRNzQzaGppVVF3QUFvRUdVUXdBQW9FR1VremdDVUNBRElBTXFBbFFpT0NBNFE3NDNoamlVUXdBQXFFR1VRd0FBcUVHVWt6Z0NWQ0FESUFNcUFsZ2lPQ0E0UTc0M2hqaVVRd0FBc0VHVVF3QUFzRUdVa3pnQ1dDQURJQU1xQWx3aU9DQTRRNzQzaGppVVF3QUF1RUdVUXdBQXVFR1VremdDWENBRElBTXFBbUFpT0NBNFE3NDNoamlVUXdBQXdFR1VRd0FBd0VHVWt6Z0NZQ0FNSUFwQkdHd2lCVUVDZEdvZ0EwRVlFRFlMSUJRZ0RDQUZRUUowYWlJM0lCY2dCeUFBS0FJa0VGb2dGQ0FYSUEwUUJCcERBQUNBUHlFNFFRQWhCVU1BQUlBL0lUc2dBa0VCVGdSQUEwQWdPQ0FQSUFVZ0dtcEJBblJxS2dJQUlqZ2dPSlNTSVRnZ095QVBJQVVnRzJwQkFuUnFLZ0lBSWprZ09aU1NJVHNnQlVFQmFpSUZJQmxIRFFBTEN5QUVJQVFnQVVFQ2RHb2dGaEFPSVFSREFBQUFBQ0U2UXdBQUFBQWhPU0FJUVFGSUloQkZCRUFnUENBN0lEZ2dPQ0E3WGhzZ09KV1JJanVVSVRoQkFDRUdRUUFoQlFOQUlBUWdCaUFPYWtFQ2RHb2dPQ0E3SURpVUlBSWdCVW9pR0JzaU9DQVBJQVZCQUNBQ0lCZ2JheUlGSUIxcUloaEJBblJxS2dJQWxEZ0NBQ0FGUVFGcUlRVWdPU0FZSUFGclFRSjBJQVJxUVlBZ2Fpb0NBQ0k1SURtVWtpRTVJQVpCQVdvaUJpQUlSdzBBQ3dzZ0F5QUVJQjlxS2dJQU9BSUFJQU1nQkNBZ2Fpb0NBRGdDQkNBRElBUWdJV29xQWdBNEFnZ2dBeUFFSUNKcUtnSUFPQUlNSUFNZ0JDQWphaW9DQURnQ0VDQURJQVFnSkdvcUFnQTRBaFFnQXlBRUlDVnFLZ0lBT0FJWUlBTWdCQ0FtYWlvQ0FEZ0NIQ0FESUFRZ0oyb3FBZ0E0QWlBZ0F5QUVJQ2hxS2dJQU9BSWtJQU1nQkNBcGFpb0NBRGdDS0NBRElBUWdLbW9xQWdBNEFpd2dBeUFFSUN0cUtnSUFPQUl3SUFNZ0JDQXNhaW9DQURnQ05DQURJQVFnTFdvcUFnQTRBamdnQXlBRUlDNXFLZ0lBT0FJOElBTWdCQ0F2YWlvQ0FEZ0NRQ0FESUFRZ01Hb3FBZ0E0QWtRZ0F5QUVJREZxS2dJQU9BSklJQU1nQkNBeWFpb0NBRGdDVENBRElBUWdNMm9xQWdBNEFsQWdBeUFFSURScUtnSUFPQUpVSUFNZ0JDQTFhaW9DQURnQ1dDQURJQVFnTm1vcUFnQTRBbHdnQkVHQVFHc2lCU0FSUVFKMGFpSUdJRGNnQmlBSUlBTWdBQ2dDSkJCWlFRQWhCZ0pBQWtBZ0VFVUVRQU5BSURvZ0JDQUdJQTVxUVFKMGFpb0NBQ0k0SURpVWtpRTZJQVpCQVdvaUJpQUlSdzBBQ3lBNUlEcER6Y3hNUHBSZURRRWdFQTBDSUFRZ0ZtcEJBQ0FlRUFVYURBSUxJRGxEQUFBQUFGNUZEUUVMSURrZ09sMUJBWE1OQUNBNVF3QUFnRCtTSURwREFBQ0FQNUtWa1NFNElBbEJBVTRFUUVNQUFJQS9JRGlUSVRsQkFDRUdBMEFnQkNBR0lBNXFRUUowYWlJUUlCQXFBZ0JEQUFDQVB5QTVJQXNnQmtFQ2RHb3FBZ0NVazVRNEFnQWdCa0VCYWlJR0lBbEhEUUFMQ3lBSklRWWdBVUVBVEEwQUEwQWdCQ0FHSUE1cVFRSjBhaUlRSURnZ0VDb0NBSlE0QWdBZ0JrRUJhaUlHSUFoSURRQUxDMEVBSVFZZ0VpQUZJQUFvQWp3aUJTQUZJQWtnQUNvQ1JJd2lPQ0E0SUFBb0Frd2lCU0FGUVFCQkFDQUFLQUlrRUJrZ0NVRUNUZ1JBQTBBZ0JrRUNkQ0lGSUFScVFZQkFheUFGSUF0cUtnSUFJQklnQ1NBR1FYOXpha0VDZENJUWFpb0NBSlFnQ3lBUWFpb0NBQ0FGSUJKcUtnSUFsSkk0QWdBZ0JrRUJhaUlHSUJ4SERRQUxDeUFLUVFGcUlnb2dGVWNOQUFzTElBQWdFMEVCYWpZQ05DQURRZUFoYWlRQUM2MEJBUUYvQWtBZ0FrRUNUUVIvSUFBTkFVRjVCVUYvQ3c4TElBQkJBRUdnUFNnQ0FFRUNkRUhnd0FCcUlBSnNRYVE5S0FJQVFRVjBha0hjQUdvUUJTSUFRWnc5TmdJQVFhQTlLQUlBSVFNZ0FFSUJOd0lRSUFBZ0FqWUNEQ0FBSUFJMkFnZ2dBQ0FETmdJRVFhZzlLQUlBSVFNZ0FFRUJOZ0ljSUFBZ0FrRUJSallDSUNBQVFRQTJBaVFnQUNBRE5nSVlJQUJCdkI5QkFCQUhHaUFBSUFFUVh5SUFOZ0lRUVFCQmZ5QUFHd3ZiQVFFR2Z3SkFJQUVnQUJDY0FTSUhTd1JBSUFFaEJnd0JDMEVCSVFZQ1FBSkFRWUNBQVNBQ2EwSGcvd0VnQVd0c1FROTJJZ1ZGQkVBZ0FTRUVRUUVoQXd3QkMwRUJJUU1EUUNBRlFRRnFJZ1ZCQVhRaUNDQUJhaUlFSUFkTEJFQWdCU0VHREFNTElBTkJBV29oQXlBRUlRRWdDRUVDYXlBQ2JFRVBkaUlGRFFBTEN5QUhJQVJySWdKQmZuRWdCR29oQVNBQ1FRRjJJQU5xSVFNTFFRQWdBMnNnQXlBSElBRWdCbW9pQWtraUJSc2hCQ0FCSUFJZ0JSc2hBd3NnQUNBRElBTWdCbW9pQUVHQWdBSWdBRUdBZ0FKSkcwR0FnQUlRTVNBRUM0VUJBUWQvSUFBb0FnZ2lCVUVCVGdSQUlBTWdBa0VCZEdwQkFXc2hCeUFBS0FKb0lRZ2dBQ2dDSUNJSkx3RUFJUVlEUUNBR1FSQjBJUW9nQVNBRVFRSjBhaUFJSUFVZ0Iyd2dCR3BxTFFBQVFVQnJJQWtnQkVFQmFpSUVRUUYwYWk0QkFDSUdJQXBCRUhWcklBSjBJQU5zYkVFQ2RUWUNBQ0FFSUFBb0FnZ2lCVWdOQUFzTEMxTUFBbjhDUUFKQUlBQkIvL3dBVEFSQUlBQkJ3RDVHRFFFZ0FFSGczUUJIRFFKQkJBOExJQUJCZ1AwQVJ3UkFRUUVnQUVHQTl3SkdEUU1hSUFCQndMc0JSdzBDUVFJUEMwRUREd3RCQmc4TFFRQUxDNFFDQVFaL0l3QWlCQ0VISUFRZ0FTQUNiQ0lJUVFKMFFROXFRWEJ4YXlJRkpBQUNRQ0FEUlFSQUlBSkJBVWdOQVNBQlFRRklEUUZCQUNFRUEwQWdBU0FFYkNFR1FRQWhBd05BSUFVZ0FpQURiQ0FFYWtFQ2RHb2dBQ0FESUFacVFRSjBhaW9DQURnQ0FDQURRUUZxSWdNZ0FVY05BQXNnQkVFQmFpSUVJQUpIRFFBTERBRUxJQUpCQVVnTkFDQUJRUUZJRFFBZ0FrRUNkRUhvT1dvaEJrRUFJUVFEUUNBR0lBUkJBblJxS0FJQUlBRnNJUWxCQUNFREEwQWdCU0FDSUFOc0lBUnFRUUowYWlBQUlBTWdDV3BCQW5ScUtnSUFPQUlBSUFOQkFXb2lBeUFCUncwQUN5QUVRUUZxSWdRZ0FrY05BQXNMSUFBZ0JTQUlRUUowRUFRYUlBY2tBQXZjR0FOTWZ3RitCWDBqQUVHZ0RHc2lGU0VVSUJVa0FDQVZRUUpCQVNBRUd5SXBJQUFvQWlBaUlTQUFLQUlJUVFGMGFrRUNheTRCQUNBaElBRkJBWFJxSWpzdUFRQWlLbXNnRDNSc1FRSjBRUTlxUVhCeGF5SWFJaFlrQUNBaElBQW9BZ2hCQVhScVFRSnJMZ0VBSUE5MFFRSjBJaHNnQTJvaEhDQVdRUkJySWp3aUZTUUFJQlZCRUdzaVBTSVZKQUFnRlVFUWF5SStJaFVrQUNBVlFSQnJJajhpRlNRQUlCVkJFR3NpTVNRQUlCUWdEallDL0FzZ0ZFRUFOZ0tFRENBVUlBbzJBdkFMSUJSQkFEWUM0QXNnRkNBQU5nTG9DeUFSS0FJQUlSVWdGQ0FUTmdLVURDQVVJQkkyQW93TUlCUWdDRFlDOUFzZ0ZDQVZOZ0tJRENBVVFRRWdEM1JCQVNBSEd5SWZRUUZLSWdjMkFwZ01JQlJCQURZQ2tBd2dGRUVCTmdMa0N5QVJJQUVnQWtnRWZ5QWFRUUFnQkJzaFFDQUlRUU5ISUFkeUlVRWdLVUVCYXlFeUlBRkJBbW9oTXlBQlFRRnFJU2dnQWtFQmF5RTBJQm9nRzJvZ0tpQVBkQ0kxUVFKMGF5SWxRUUFnTld0QkFuUWlCMm9oUWlBSElCcHFJU0pCZnlBZmRFRi9jeUVUSUFFaENFRUFJUnRCQVNFU0EwQWdGQ0FJSWhVMkF1d0xJQ0VnRlVFQmRHb2lIUzRCQUNFSElDRWdGVUVCYWlJSVFRRjBhaTRCQUNFV0lCUWdEQ0FPRUFzaU5tc2lFVUVCYXpZQ2dBd2dCeUFQZENFWElBMUJBQ0EySUFFZ0ZVWWJheUUzQW45QkFDQVFJQlZNRFFBYVFmLy9BQ0FSSUFZZ0ZVRUNkR29vQWdBZ055QVFJQlZySWcxQkF5QU5RUU5JRzIxcUlnMGdEU0FSU2hzaURVSC8vd0JLRFFBYUlBMUJBQ0FOUVFCS0d3c2hKQ0FYUVFKMElRMGdGaUFIYXlFSEFrQWdGU0FvUndSQUlCMHVBUUFnQjJzZ0QzUWdPeTRCQUNBUGRFZ05BUXNnRlNBYklCVWdHeHNnRWhzaEd3c2dCQ0FOYWlFV0FrQWdGU0FvUnlKRERRQWdHaUFBS0FJZ0loRWdLRUVCZEdvdUFRQWlGeUFSSUFGQkFYUnFMZ0VBYXlBUGRDSVNRUUowSWhscUlCb2dFa0VCZENBUklETkJBWFJxTGdFQUlCZHJJQTkwSWhGclFRSjBJaGRxSUJFZ0VtdEJBblFpRVJBRUdpQUpSUTBBSUJrZ0pXb2dGeUFsYWlBUkVBUWFDeUFXUVFBZ0JCc2hJQ0FESUExcUlTTWdCeUFQZENFWElCUWdDeUFWUVFKMElqaHFLQUlBSWhJMkF2Z0xRUUFnSEVFQUlCVWdBQ2dDREVnaUdCc2lIQ0FWSURSR0loNGJJU1pCZnlFWkFrQWdHMFVFUUNBVEloRWhEUXdCQ3lBVEloRWhEU0JCSUJKQkFFaHlSUTBBSUNFZ0cwRUJkR291QVFBZ0J5QXFhbXNnRDNRaUIwRUFJQWRCQUVvYkloa2dOV29oRFNBYklRY0RRQ0FoSUFjaUVrRUJheUlIUVFGMGFpNEJBQ0FQZENBTlNnMEFDeUFOSUJkcUlTY2dHMEVCYXlFV0lCc2dGU0FWSUJ0SUcwRUJheUVSQTBBQ1FDQVJJQllpRFVZRVFDQVJJUTBNQVFzZ0lTQU5RUUZxSWhaQkFYUnFMZ0VBSUE5MElDZElEUUVMQ3lBSElBMGdEU0FTU0JzaEVrRUFJUkZCQUNFTkEwQWdFU0FGSUFjZ0tXd2lGbW90QUFCeUlSRWdEU0FGSUJZZ01tcHFMUUFBY2lFTklBY2dFa2NoRmlBSFFRRnFJUWNnRmcwQUN3c2dKaUVjSUNNZ0dpQVlHeUVTSUNBZ1FDQVlHeUVZQW44Q1FDQUpSUTBBSUFvZ0ZVWUVRRUVBSVFjZ0hTNEJBQ0FxYXlBUGRDSUpRUUZJRFFFRFFDQWFJQWRCQW5RaUZtb2lJQ0FnS2dJQUlCWWdKV29xQWdDU1F3QUFBRCtVT0FJQUlBZEJBV29pQnlBSlJ3MEFDd3dCQ3lBS0lCVkdEUUJCQUNBYUlCbEJBblFpQjJvZ0dVRi9SaUlXR3lFZUlCUkI0QXRxSUJnZ0Z5QWtRUUYySWhnZ0h3Si9JQlVnTkVZRVFFRUFJUmtnRkVIZ0Myb2dFaUFYSUJnZ0h5QWVJQTlCQUVNQUFJQS9JQndnRVJBS0lSRkJBQ0FISUNWcUlCWWJEQUVMSUJSQjRBdHFJQklnRnlBWUlCOGdIaUFQSUNJZ0hTNEJBQ0FQZEVFQ2RHcERBQUNBUHlBY0lCRVFDaUVSSUVJZ0hTNEJBQ0FQZEVFQ2RHb2hHVUVBSUFjZ0pXb2dGaHNMSUE4Z0dVTUFBSUEvSUJ3Z0RSQUtEQUVMQWtBZ0dBUkFRUUZGQkVBZ09Db0NBQ0ZrSUFBb0FnZ2dGV3BCQW5RcUFnQWhZeUFPS0FJRUlUa2dEaWdDQUNFNklCUkIyQXRxSWtRZ0Rpa0NFRGNEQUNBVUlBNHBBZ2czQTlBTElBNG9BaGdoSXlBVVFjZ0xhaUpGSUE0b0FpdzJBZ0FnRkVIQUMyb2lSaUFPS1FJa053TUFJQlFnRGlrQ0hEY0R1QXNnRkVHQUMyb2lSeUFVUVpnTWFpSW1LQUlBTmdJQUlCUkIrQXBxSWtnZ0ZFR1FER29pSUNrREFEY0RBQ0FVUWZBS2FpSkpJQlJCaUF4cUlpY3BBd0EzQXdBZ0ZFSG9DbW9pU2lBVVFZQU1haUlyS1FNQU53TUFJQlJCNEFwcUlrc2dGRUg0QzJvaUxDa0RBRGNEQUNBVVFkZ0thaUpNSUJSQjhBdHFJaTBwQXdBM0F3QWdGRUhRQ21vaVRTQVVRZWdMYWlJdUtRTUFOd01BSUJRZ0ZDa0Q0QXMzQThnS0lEd2dFaUFYUVFKMEloWVFCQ0V2SUQwZ0dDQVdFQVFoTUNBZ1FYODJBZ0JCQUNFSElBMGdFWEloRVVNQUFBQUFJV0VnRkVIZ0Myb2dFaUFZSUJjZ0pDQWZRUUFnR2lBWlFRSjBhaUFaUVg5R0d5Sk9JQThnSGdSL1FRQUZJQ0lnSFM0QkFDQVBkRUVDZEdvTElCd2dFUkFrSVFsREFBQUFBQ0ZpSUJkQkFVZ2lUMFVFUUFOQUlHSWdMeUFIUVFKMElnMXFLZ0lBSUEwZ0Vtb3FBZ0NVa2lGaUlBZEJBV29pQnlBWFJ3MEFDMEVBSVFjRFFDQmhJREFnQjBFQ2RDSU5haW9DQUNBTklCaHFLZ0lBbEpJaFlTQUhRUUZxSWdjZ0YwY05BQXNMSUJSQnNBdHFJbEFnRGlrQ0tEY0RBQ0FVUWFnTGFpSlJJQTRwQWlBM0F3QWdGRUdnQzJvaVVpQU9LUUlZTndNQUlCUkJtQXRxSWxNZ0Rpa0NFRGNEQUNBVVFaQUxhaUpVSUE0cEFnZzNBd0FnRGlrQ0FDRmdJQlJCa0FwcUlsVWdMaWtEQURjREFDQVVRWmdLYWlKV0lDMHBBd0EzQXdBZ0ZFR2dDbW9pVnlBc0tRTUFOd01BSUJSQnFBcHFJbGdnS3lrREFEY0RBQ0FVUWJBS2FpSlpJQ2NwQXdBM0F3QWdGRUc0Q21vaVdpQWdLUU1BTndNQUlCUkJ3QXBxSWxzZ0ppZ0NBRFlDQUNBVUlHQTNBNGdMSUJRZ0ZDa0Q0QXMzQTRnS0lENGdFaUFXRUFRaFhDQS9JQmdnRmhBRUlWMGdIa1VFUUNBeElDSWdIUzRCQUNBUGRFRUNkR29nRmhBRUdnc2dGQ0FqSURwcUlsNGdPU0FqYXlKZkVBUWhEU0FPSURrMkFnUWdEaUE2TmdJQUlBNGdSQ2tEQURjQ0VDQU9JQTBwQTlBTE53SUlJQTRnSXpZQ0dDQU9JRVVvQWdBMkFpd2dEaUJHS1FNQU53SWtJQTRnRFNrRHVBczNBaHdnTGlCTktRTUFOd01BSUMwZ1RDa0RBRGNEQUNBc0lFc3BBd0EzQXdBZ0t5QktLUU1BTndNQUlDY2dTU2tEQURjREFDQWdJRWdwQXdBM0F3QWdKaUJIS0FJQU5nSUFJQTBnRFNrRHlBbzNBK0FMSUJJZ0x5QVdFQVFoRWlBWUlEQWdGaEFFSVJrZ1EwVUVRQ0FhSUFBb0FpQWlCeUFvUVFGMGFpNEJBQ0lqSUFjZ0FVRUJkR291QVFCcklBOTBJaGhCQW5ScUlCb2dHRUVCZENBSElETkJBWFJxTGdFQUlDTnJJQTkwSWdkclFRSjBhaUFISUJoclFRSjBFQVFhQ3lBTlFRRTJBcEFNUVFBaEJ5QmpJR1FnWXlCaklHUmVHME1BQUVCQWxTSmxraUZqSUdRZ1paSWlaQ0JpbENCaklHR1VraUZsUXdBQUFBQWhZU0FOUWVBTGFpQVNJQmtnRnlBa0lCOGdUaUFQSUI0RWYwRUFCU0FpSUIwdUFRQWdEM1JCQW5ScUN5QWNJQkVRSkNFUlF3QUFBQUFoWWlCUFJRUkFBMEFnWWlBdklBZEJBblFpR0dvcUFnQWdFaUFZYWlvQ0FKU1NJV0lnQjBFQmFpSUhJQmRIRFFBTFFRQWhCd05BSUdFZ01DQUhRUUowSWhocUtnSUFJQmdnR1dvcUFnQ1VraUZoSUFkQkFXb2lCeUFYUncwQUN3c2daU0JrSUdLVUlHTWdZWlNTWUVFQmMwVUVRQ0FPSUEwcEE0Z0xOd0lBSUE0Z1VDa0RBRGNDS0NBT0lGRXBBd0EzQWlBZ0RpQlNLUU1BTndJWUlBNGdVeWtEQURjQ0VDQU9JRlFwQXdBM0FnZ2dMaUJWS1FNQU53TUFJQzBnVmlrREFEY0RBQ0FzSUZjcEF3QTNBd0FnS3lCWUtRTUFOd01BSUNjZ1dTa0RBRGNEQUNBZ0lGb3BBd0EzQXdBZ0ppQmJLQUlBTmdJQUlBMGdEU2tEaUFvM0ErQUxJQklnWENBV0VBUWFJQmtnWFNBV0VBUWFJQjVGQkVBZ0lpQWRMZ0VBSUE5MFFRSjBhaUF4SUJZUUJCb0xJRjRnRFNCZkVBUWFJQWtoRVF0QkFDRUpEQUlMUVFBaENTQVVRUUEyQXBBTUlCUkI0QXRxSUJJZ0dDQVhJQ1FnSDBFQUlCb2dHVUVDZEdvZ0dVRi9SaHNnRHlBZUJIOUJBQVVnSWlBZExnRUFJQTkwUVFKMGFnc2dIQ0FOSUJGeUVDUWhFUXdCQzBFQUlRa2dGRUhnQzJvZ0VpQVhJQ1FnSDBFQUlCb2dHVUVDZEdvZ0dVRi9SaHNnRHlBZUJIOUJBQVVnSWlBZExnRUFJQTkwUVFKMGFndERBQUNBUHlBY0lBMGdFWElRQ2lFUkN5QVJDeUVISUFVZ0ZTQXBiQ0lOYWlBUk9nQUFJQVVnRFNBeWFtb2dCem9BQUNBR0lEaHFLQUlBSVFjZ0ZFRUFOZ0tZRENBSElEWWdOMnBxSVEwZ0pDQVhRUU4wU2lFU0lBSWdDRWNOQUFzZ0ZDZ0NpQXdGSUJVTE5nSUFJQlJCb0F4cUpBQUxCQUJCQUF2V0JBTVBmd1Y5QVh3Z0JpQUhTQVJBUVFFZ0EzUWlFRUVCSUJCQkFVb2JJUlFnQkVFQklBUkJBVW9iSVJjZ0EwRURSaUVZSUFOQkgwWWhHUU5BUXdBQWdEOGdBQ2dDSUNJT0lBWWlFRUVCYWlJR1FRRjBhaTRCQUNBT0lCQkJBWFFpR21vdUFRQnJJaE1nQTNRaUc3ZWZ0cFVoSVNBTElCQkJBblJxS0FJQVFRRnFJQk51SUFOMnNrTUFBQUMrbEx0RTd6bjYva0l1NWoraUVCKzJRd0FBQUQrVUlTQWdCQ0FRYkNFY1FRQWhFZ05BSUFvZ0FDZ0NDQ0lQSUJKc0lCQnFRUUowSWc1cUtnSUFJUjBnQ1NBT2Fpb0NBQ0VlSUFnZ0Rtb3FBZ0FDZlNBRVFRRkdCRUFnSFNBS0lBOGdFR3BCQW5RaUQyb3FBZ0FpSHlBZElCOWVHeUVkSUI0Z0NTQVBhaW9DQUNJZklCNGdIMTRiSVI0TElCNExJQjBnSFNBZVhodVRRd0FBQUFDWHUwVHZPZnIrUWk3bXY2SVFIeUVpQWtBZ0dRMEFJQUVnQlNBU2JFRUNkR29nQUNnQ0lDQWFhaTRCQUNBRGRFRUNkR29oRlNBQ0lCSWdIR3BxSVJaQkFDRVBBa0FnRTBFQVNnUkFJQ0VnSUNBaXRpSWRJQjJTSWgxRDh3UzFQNVFnSFNBWUd5SWRJQjBnSUY0YmxDSWRqQ0VlUVFBaEVRTkFRUUFoRGlBV0xRQUFJQkYyUVFGeFJRUkFBMEFnRlNBT0lBTjBJQkZxUVFKMGFpQWRJQjRnREVHTnpPVUFiRUhmNXJ2akEyb2lERUdBZ0FKeEd6Z0NBRUVCSVE4Z0RrRUJhaUlPSUJOSERRQUxDeUFSUVFGcUloRWdGRWNOQUFzTUFRc2dGaTBBQUNFUlFRQWhEZ05BSUE5QkFTQVJJQTUyUVFGeEd5RVBJQTVCQVdvaURpQVVSdzBBQ3dzZ0QwVU5BQ0FWSUJ0REFBQ0FQeUFORUM0TElCSkJBV29pRWlBWFJ3MEFDeUFHSUFkSERRQUxDd3U3QlFFTGZ5QUJJQUFvQVFRMkFRQWdBaUFBS0FFSU5nRUFJQUFnQVNBRlFRRjBJZ1pxS0FFQU5nRUVJQUFnQWlBR2FpZ0JBRFlCQ0VHQWdBUWdCRUVEZENJR2JTRUhJQU1vQWdRaENpQURLQUlBSVFzZ0JFRUJUZ1JBSUFkQkVIUkJFSFVpQXlBS0lBQXZBUUlpQjJ0QkVIUkJFSFZzUVE5MVFRRnFRUUYxSVEwZ0F5QUxJQUF2QVFBaUNHdEJFSFJCRUhWc1FROTFRUUZxUVFGMUlRNGdCa0VCSUFaQkFVb2JJUTlCQUNFREEwQWdBaUFEUVFGcUlnUkJBWFFpQ1dvaURFSC8vd0VnQnlBTmFpSUhRUkIwUVJCMUloQWdBU0FKYWk0QkFDSUpRUVYxYkNBTUxnRUFRUWgwYWlBSlFRdDBRWUR3QTNFZ0VHeEJFSFZxSUFnZ0Rtb2lDRUVRZEVFUWRTSU1JQUVnQTBFQmRHb2lBeTRCQkNBRExnRUFhaUFKUVFGMGFpSURRUWQxYkdvZ0EwRUpkRUdBL0FOeElBeHNRUkIxYWlJRFFRZDFRUUZxUVFGMUlnbEJnSUIrSUFsQmdJQitTaHNnQTBILy92OERTaHM3QVFBZ0JDSURJQTlIRFFBTEN5QUZJQVpLQkVBZ0NrRVFkRUVRZFNFRElBdEJFSFJCRUhVaEJBTkFJQVpCQVhRaENDQUNJQVpCQVdvaUJrRUJkQ0lIYWlJSlFmLy9BU0FCSUFkcUxnRUFJZ2RCQlhVZ0Eyd2dDUzRCQUVFSWRHb2dCMEVMZEVHQThBTnhJQU5zUVJCMWFpQUJJQWhxSWdndUFRUWdDQzRCQUdvZ0IwRUJkR29pQjBFSGRTQUViR29nQjBFSmRFR0EvQU54SUFSc1FSQjFhaUlIUVFkMVFRRnFRUUYxSWdoQmdJQitJQWhCZ0lCK1Noc2dCMEgvL3Y4RFNoczdBUUFnQlNBR1J3MEFDd3NnQUNBS093RUNJQUFnQ3pzQkFDQUZRUUZPQkVCQkFDRUdBMEFnQVNBR1FRRnFJZ1pCQVhRaUFHb2lBeUFETGdFQUlnTWdBQ0FDYWlJQUxnRUFJZ1JxSWdwQi8vOEJJQXBCLy84QlNCc2lDa0dBZ0g0Z0NrR0FnSDVLR3pzQkFDQUFJQU1nQkdzaUFFSC8vd0VnQUVILy93RklHeUlBUVlDQWZpQUFRWUNBZmtvYk93RUFJQVVnQmtjTkFBc0xDM29CQlg4Z0FVRUNUZ1JBUVFFaEF3TkFJQUFnQTBFQmRHb3VBUUFoQlNBRElRSUNRQU5BSUFVZ0FDQUNRUUZySWdaQkFYUnFMZ0VBSWdST0RRRWdBQ0FDUVFGMGFpQUVPd0VBSUFKQkFVb2hCQ0FHSVFJZ0JBMEFDMEVBSVFJTElBQWdBa0VCZEdvZ0JUc0JBQ0FEUVFGcUlnTWdBVWNOQUFzTEM0a0hBUVIvSUFBQ2Z3SkFJQUpCQVVnTkFDQUNJQUVnQWtHQU9Xb3RBQUJCNERkcVFRZ1FBeUlDYXlFRklBSkJFSFFpQWtFQlNBUkFEQUVMSUFKQkVIVWlBaUFCSUFKQmdEbHFMUUFBUWNBMmFrRUlFQU1pQW1zaEF5QUNRUkIwSWdKQkFFd05BQ0FDUVJCMUlnSWdBU0FDUVlBNWFpMEFBRUdnTldwQkNCQURJZ0pySVFRZ0FrRVFkRUVCU0EwQUlBQWdBU0FDUWYvL0EzRkJnRGxxTFFBQVFZQTBha0VJRUFNaUJqc0JBQ0FDSUFackRBRUxJQUJCQURzQkFFRUFDenNCQWlBQUFuOGdCRUVRZEVFQlRnUkFJQUFnQVNBRVFmLy9BM0ZCZ0RscUxRQUFRWUEwYWtFSUVBTWlBanNCQkNBRUlBSnJEQUVMSUFCQkFEc0JCRUVBQ3pzQkJrRUFJUVFnQUFKL0FrQWdBMEVRZENJQ1FRQk1CRUFnQUVFSWFpRUREQUVMSUFCQkNHb2hBeUFDUVJCMUlnSWdBU0FDUVlBNWFpMEFBRUdnTldwQkNCQURJZ0pySVFRZ0FrRVFkRUVCU0EwQUlBQWdBU0FDUWYvL0EzRkJnRGxxTFFBQVFZQTBha0VJRUFNaUF6c0JDQ0FDSUFOckRBRUxJQU5CQURzQkFFRUFDenNCQ2lBQUFuOGdCRUVRZEVFQlRnUkFJQUFnQVNBRVFmLy9BM0ZCZ0RscUxRQUFRWUEwYWtFSUVBTWlBanNCRENBRUlBSnJEQUVMSUFCQkFEc0JERUVBQ3pzQkRrRUFJUVJCQUNFQ0lBQUNmd0pBQWtBZ0JVRVFkQ0lEUVFGT0JFQWdBMEVRZFNJQ0lBRWdBa0dBT1dvdEFBQkJ3RFpxUVFnUUF5SURheUVDSUFOQkVIUWlBMEVBU2cwQkN5QUFRUkJxSVFVTUFRc2dBRUVRYWlFRklBTkJFSFVpQkNBQklBUkJnRGxxTFFBQVFhQTFha0VJRUFNaUEyc2hCQ0FEUVJCMFFRRklEUUFnQUNBQklBTkIvLzhEY1VHQU9Xb3RBQUJCZ0RScVFRZ1FBeUlGT3dFUUlBTWdCV3NNQVFzZ0JVRUFPd0VBUVFBTE93RVNJQUFDZnlBRVFSQjBRUUZPQkVBZ0FDQUJJQVJCLy84RGNVR0FPV290QUFCQmdEUnFRUWdRQXlJRE93RVVJQVFnQTJzTUFRc2dBRUVBT3dFVVFRQUxPd0VXUVFBaEJDQUFBbjhDUUNBQ1FSQjBJZ0pCQUV3RVFDQUFRUmhxSVFNTUFRc2dBRUVZYWlFRElBSkJFSFVpQWlBQklBSkJnRGxxTFFBQVFhQTFha0VJRUFNaUFtc2hCQ0FDUVJCMFFRRklEUUFnQUNBQklBSkIvLzhEY1VHQU9Xb3RBQUJCZ0RScVFRZ1FBeUlET3dFWUlBSWdBMnNNQVFzZ0EwRUFPd0VBUVFBTE93RWFJQVJCRUhSQkFVNEVRQ0FBSUFFZ0JFSC8vd054UVlBNWFpMEFBRUdBTkdwQkNCQURJZ0U3QVJ3Z0FDQUVJQUZyT3dFZUR3c2dBRUVBT3dFY0lBQkJBRHNCSGd1VkFRRUZmeUFFUVFGT0JFQWdBQ2dDQUNFRklBTXVBUUloQmlBRExnRUFJUWRCQUNFREEwQWdBU0FEUVFKMGFpQUNJQU5CQVhScUxnRUFRUWgwSUFWcUlnVTJBZ0FnQUNnQ0JDRUlJQUFnQlVFQ2RDSUZRZnovQTNFaUNTQUdiRUVRZFNBRlFSQjFJZ1VnQm14cU5nSUVJQUFnQ0NBRklBZHNhaUFISUFsc1FSQjFhaUlGTmdJQUlBTkJBV29pQXlBRVJ3MEFDd3NMNndRQkJIOENRQ0FBUVFCQnJBSVFCU0lEQW45QmZ5RUFBa0FnQVVIQVBrWU5BQ0FCUVlEOUFFWU5BQ0FCUWVEZEFFY05BZ3NDUUNBQ1FmLzhBRXdFUUNBQ1FjQStSZzBCSUFKQjROMEFSZzBCREFNTElBSkJnUDBBUmcwQUlBSkJnUGNDUmcwQUlBSkJ3THNCUncwQ0N5QUJRUXgyUVFWc0lBSkJESFlnQWtHQS9RQktheUFDUWNDN0FVcDFha0d4QzJvc0FBQUxOZ0trQWlBRElBSkIvLzhEY1VIb0IyNDJBcUFDSUFNZ0FVSC8vd054UWVnSGJpSUFOZ0tjQWlBRElBQkJDbXcyQW93Q0FrQWdBU0FDU0FSQVFRRWhBQ0FDSUFGQkFYUkdCRUFnQTBFQk5nS0lBa0VBSVFBTUFnc2dBMEVDTmdLSUFnd0JDeUFCSUFKS0JFQWdBMEVETmdLSUFpQUNRUUowSWdBZ0FVRURiRVlFUUNBRFFkQUxOZ0tvQWlBRFFwS0FnSUF3TndLVUFrRUFJUUFNQWdzZ0FrRURiQ0lFSUFGQkFYUkdCRUFnQTBHUUREWUNxQUlnQTBLU2dJQ0FJRGNDbEFKQkFDRUFEQUlMSUFFZ0FrRUJkRVlFUUNBRFFjQU1OZ0tvQWlBRFFwaUFnSUFRTndLVUFrRUFJUUFNQWdzZ0FTQUVSZ1JBSUFOQjRBdzJBcWdDSUFOQ3BJQ0FnQkEzQXBRQ1FRQWhBQXdDQ3lBQUlBRkdCRUFnQTBHUURUWUNxQUlnQTBLa2dJQ0FFRGNDbEFKQkFDRUFEQUlMUVg4aEFDQUNRUVpzSUFGSERRSWdBMEhBRFRZQ3FBSWdBMEtrZ0lDQUVEY0NsQUpCQUNFQURBRUxRUUFoQUNBRFFRQTJBb2dDQ3lBQklBQjBJUVVnQWtFUWRFRVFkU0VFSUFKQkQzWkJBV3BCQVhZaEJpQUJJQUJCRG5KMElBSnRRUUowSVFJRFFDQUNJZ0JCQVdvaEFpQUFRUkIxSUFSc0lBQWdCbXhxSUFCQi8vOERjU0FFYkVFUWRXb2dCVWdOQUFzZ0F5QUFOZ0tRQWtFQUlRQUxJQUFMY3dFRGZ3Si9RUUFnQUVFQVNBMEFHa0gvLy8vL0J5QUFRZjRlU2cwQUdpQUFRZjhBY1NFQlFRRWdBRUVIZGlJRGRDRUNJQUJCL3c5TUJIOGdBVUdBQVNBQmEyeEIwbjVzUVJCMUlBRnFJQU4wUVFkMUJTQUJRWUFCSUFGcmJFSFNmbXhCRUhVZ0FXb2dBa0VIZG13TElBSnFDd3ZJQVFFRWZ5QUVRUUZPQkVBRFFDQUNBbjhnQXlBR2NrVUVRQ0FCTEFBQUlnVWdBaXdBQUVFUWF5SUhJQVVnQjBvYkRBRUxJQUVnQm1vc0FBQkJCR3NpQlNBQ0xBQUFJZ2RCQ0dvaUNFb0VRQ0FISUFWQkFYUWdDR3RxREFFTElBVWdCMm9MSWdWQkFDQUZRUmgwUVJoMVFRQktHeUlGUVQ4Z0JVRVlkRUVZZFVFL1NCc2lCVG9BQUNBQUlBWkJBblJxSUFWQi93RnhJZ1ZCOFRoc1FSQjJJQVZCSFd4cUlnVkIxUTRnQlVIVkRra2JRYW9RYWhCcE5nSUFJQVpCQVdvaUJpQUVSdzBBQ3dzTDFBSUJCSDhnQUNBQlFSQjBRUkIxSWdOQkJXdzJBcHdTSUFBdUFaUVNJQU5CZ0lBVWJFRVFkV3doQkFKQUFrQUNRQ0FCSUFBb0Fvd1NSZ1JBSUFBb0FwQVNJQUpHRFFFTElBQkJnQk5xSUFOQjZBZHNJQUlRYUNFRklBQWdBallDa0JJZ0FDZ0NqQklnQVVjTkFRdEJBU0VHSUFRZ0FDZ0NtQkpHRFFFTElBQkJnakpCbVRJZ0FDZ0NsQkpCQkVZaUFodEI0REZCalRJZ0Foc2dBVUVJUmhzMkF0QVNJQVpGQkVBZ0FDQURRUlJzTmdLZ0VpQUFRY2dlUVpRdklBRkJlM0ZCQ0VZaUFoczJBcXdWSUFCQkNrRVFJQUliTmdLa0VrR1FNU0VDQWtBQ1FBSkFBa0FnQVVFTWF3NEZBQUVCQVFJQkMwR0tNU0VDREFFTFFZRXhJUUlnQVVFSVJ3MEJDeUFBSUFJMkFzd1NDeUFBUVFBMkFzUWdJQUJCQ2pvQWlCSWdBRUhrQURZQ2hCSWdBRUVCTmdMSUVpQUFRWVFLYWtFQVFZQUlFQVVhQ3lBQUlBUTJBcGdTSUFBZ0FUWUNqQklMSUFVTFJnRUNmeU1BUVJCcklnRWtBQUpBSUFCRkRRQkJtUHNCS0FJQUlnSkZCRUFnQVNBQU5nSUFRZXNJSUFFUUhnd0JDMEdZK3dFZ0FpQUFFRDgyQWdBTElBRkJFR29rQUF2a0FRRUZmd0pBSUFSQkFVZ05BRUh3Q1VIRUNTQUVRUVJHSWdVYlFhQUtRZEFKSUFVYklBTkJDRVlpQnhzaENFRUxRUU1nQlJ0QklrRU1JQVViSUFjYklRY2dBMEVRZENJRlFROTFJZ01nQUdvaENVRUFJUUFnQlVFUWRVRVNiQ0lGSUFOSUJFQURRQ0FDSUFCQkFuUnFJQU1nQlNBSklBZ2dBQ0FIYkNBQmFtb3NBQUJxSWdZZ0JTQUdTaHNnQXlBR1NCczJBZ0FnQUVFQmFpSUFJQVJIRFFBTUFnc0FDd05BSUFJZ0FFRUNkR29nQlNBRElBa2dDQ0FBSUFkc0lBRnFhaXdBQUdvaUJpQURJQVpLR3lBRklBWklHellDQUNBQVFRRnFJZ0FnQkVjTkFBc0xDOGdFQVFkL0l3QkJRR29pQkNRQUlBRkJFR29nQUVHd0ZXb2dBRUdJRW1vZ0FrRUNSaUFBS0FLVUVoQnFJQVJCSUdvZ0FFRzRGV29nQUNnQ3JCVVFkaUFCUVVCcklnVWdCRUVnYWlBQUtBS2tFaUFBS0FMSUlCQXJJQUZCSUdvaEF3SkFBa0FnQUNnQ3lCSkJBVVlFUUNBQVFRUTZBTThWREFFTElBQXNBTThWSWdoQkEwb05BQ0FBS0FLa0VpSUdRUUZPQkVCQkFDRUNBMEFnQkNBQ1FRRjBJZ2RxSUFBZ0IycEJxQkpxTGdFQUlna2dCRUVnYWlBSGFpNEJBQ0FKYXlBSWJFRUNkbW83QVFBZ0FrRUJhaUlDSUFaSERRQUxDeUFESUFRZ0JpQUFLQUxJSUJBckRBRUxJQU1nQlNBQUtBS2tFa0VCZEJBRUdnc2dBRUdvRW1vZ0JFRWdhaUFBS0FLa0VpSUNRUUYwRUFRYUlBQW9Bc0FnQkVBZ0F5QUNRZEx3QXhBcUlBVWdBQ2dDcEJKQjB2QURFQ29MSUFFQ2Z5QUFRYzBWYWkwQUFFRUNSZ1JBSUFCQnloVnFMZ0VBSUFCQnpCVnFMQUFBSUFFZ0FDZ0NqQklnQUNnQ2xCSVFiU0FBS0FLVUVpSUdRUUZPQkVBZ0FFSFFGV29zQUFCQkFuUkJ3Qk5xS0FJQUlRZEJBQ0VDQTBBZ0FTQUNRUXBzYWlJRElBY2dBQ0FDYWtHMEZXb3NBQUJCQld4cUlnVXNBQUJCQjNRN0FXQWdBeUFGTEFBQlFRZDBPd0ZpSUFNZ0JTd0FBa0VIZERzQlpDQURJQVVzQUFOQkIzUTdBV1lnQXlBRkxBQUVRUWQwT3dGb0lBSkJBV29pQWlBR1J3MEFDd3NnQUVIUkZXb3NBQUJCQVhSQitEQnFMZ0VBREFFTElBRkJBQ0FBS0FLVUVrRUNkQkFGUWVBQWFrRUFJQUFvQXBRU1FRcHNFQVVhSUFCQjBCVnFRUUE2QUFCQkFBczJBb2dCSUFSQlFHc2tBQXYzR3dFb2Z5TUFRU0JySWdRaEZpQUVKQUFnQkNBQUtBS2dFa0VCZEVFUGFrRndjV3NpRnlJRUpBQWdCQ0FBS0FLWUVpSUVJQUFvQXFBU2FrRUNkRUVQYWtGd2NXc2lFaUlLSkFBZ0NpQUFLQUtjRWtFQ2RDSUtRUTlxUVhCeGF5SVlJZ1lrQUNBR0lBcEJ6d0JxUVhCeGF5SUZKQUFnQUVIUEZXb3NBQUFoRVNBRVFRRk9CRUFnQUN3QXpSVkJBWFJCZkhGQjhEQnFJQUJCemhWcUxBQUFRUUYwYWk0QkFFRUVkQ0VNSUFCQjBoVnFMQUFBSVFZRFFDQUFJQWRCQW5ScUlnb2dBeUFIUVFGMGFpNEJBQ0lFUVE1MElnZzJBZ1FnQmtHMWlNN2RBR3hCNjhibHNBTnFJUVlDUUNBS0lBUkJBVTRFZnlBSVFZQUthd1VnQkVGL1NnMEJJQWhCZ0FweUN5SUlOZ0lFQ3lBS1FRQWdDQ0FNYWlJS2F5QUtJQVpCQUVnYk5nSUVJQVFnQm1vaEJpQUhRUUZxSWdjZ0FDZ0NtQkpJRFFBTEN5QUZJQUFwQW9RS053SUFJQVVnQUVHOENtb3BBZ0EzQWpnZ0JTQUFRYlFLYWlrQ0FEY0NNQ0FGSUFCQnJBcHFLUUlBTndJb0lBVWdBRUdrQ21vcEFnQTNBaUFnQlNBQVFad0thaWtDQURjQ0dDQUZJQUJCbEFwcUtRSUFOd0lRSUFVZ0FFR01DbW9wQWdBM0FnZ2dBQ2dDbEJKQkFVNEVRQ0FBUVFScUlSTWdBQ2dDb0JJaEVDQVJRUVJJSVNZZ0FpRVJBMEFnRmlBQklBNUJCSFJCWUhGcVFTQnFJZzBnQUNnQ3BCSkJBWFFRQkNFTVFRQWdBU0FPUVFKMGFpSUlLQUlRSWc4Z0R5QVBRUjkxSWdOcUlBTnpJZ3BuSWdaQkFXdDBJZ2xCLy84RGNVSC8vLy8vQVNBSlFSQjFJZ1J0SWdkQkVIUWlDMEVRZFNJRGJFRVFkU0FESUFSc2FrRURkR3NpQkNBSFFROTFRUUZxUVFGMWJDQUxhaUFFUVJCMUlBTnNhaUFFUWZqL0EzRWdBMnhCRUhWcUlRUUNmeUFLUWYvL0IwMEVRRUgvLy8vL0J5QUdRUTlySWdwMklnZEJnSUNBZ0hnZ0NuVWlDeUFFSUFRZ0MwZ2JJQVFnQjBvYklBcDBEQUVMSUFSQkR5QUdhM1VMSVFvZ0FDMEF6UlVoQzBHQWdBUWhCeUFBS0FJQUlnUWdEMGNFUUNBRUlBUWdCRUVmZFNJSGFpQUhjMmNpQjBFQmEzUWlCQ0FFUVJCMUlBTnNJQVJCLy84RGNTQURiRUVRZFdvaUJLd2dDYXgrUWgySXAwRjRjV3NpQ1VFUWRTQURiQ0FFYWlBSlFmLy9BM0VnQTJ4QkVIVnFJUU1nQlNBRktBSUFJZ2xCRUhSQkVIVWlGQUovSUFjZ0JtdEJIV29pQkVFUFRBUkFRZi8vLy84SFFSQWdCR3NpQkhZaUJrR0FnSUNBZUNBRWRTSUhJQU1nQXlBSFNCc2dBeUFHU2hzZ0JIUU1BUXNnQXlBRVFSQnJkVUVBSUFSQk1FZ2JDeUlIUWYvL0EzRWlBMnhCRUhVZ0ZDQUhRUkIxSWdSc2FpQUpRUTkxUVFGcVFRRjFJQWRzYWpZQ0FDQUZJQVVvQWdRaUJrRVFkRUVRZFNJSklBTnNRUkIxSUFRZ0NXeHFJQVpCRDNWQkFXcEJBWFVnQjJ4cU5nSUVJQVVnQlNnQ0NDSUdRUkIwUVJCMUlna2dBMnhCRUhVZ0JDQUpiR29nQmtFUGRVRUJha0VCZFNBSGJHbzJBZ2dnQlNBRktBSU1JZ1pCRUhSQkVIVWlDU0FEYkVFUWRTQUVJQWxzYWlBR1FROTFRUUZxUVFGMUlBZHNhallDRENBRklBVW9BaEFpQmtFUWRFRVFkU0lKSUFOc1FSQjFJQVFnQ1d4cUlBWkJEM1ZCQVdwQkFYVWdCMnhxTmdJUUlBVWdCU2dDRkNJR1FSQjBRUkIxSWdrZ0EyeEJFSFVnQkNBSmJHb2dCa0VQZFVFQmFrRUJkU0FIYkdvMkFoUWdCU0FGS0FJWUlnWkJFSFJCRUhVaUNTQURiRUVRZFNBRUlBbHNhaUFHUVE5MVFRRnFRUUYxSUFkc2FqWUNHQ0FGSUFVb0Fod2lCa0VRZEVFUWRTSUpJQU5zUVJCMUlBUWdDV3hxSUFaQkQzVkJBV3BCQVhVZ0IyeHFOZ0ljSUFVZ0JTZ0NJQ0lHUVJCMFFSQjFJZ2tnQTJ4QkVIVWdCQ0FKYkdvZ0JrRVBkVUVCYWtFQmRTQUhiR28yQWlBZ0JTQUZLQUlrSWdaQkVIUkJFSFVpQ1NBRGJFRVFkU0FFSUFsc2FpQUdRUTkxUVFGcVFRRjFJQWRzYWpZQ0pDQUZJQVVvQWlnaUJrRVFkRUVRZFNJSklBTnNRUkIxSUFRZ0NXeHFJQVpCRDNWQkFXcEJBWFVnQjJ4cU5nSW9JQVVnQlNnQ0xDSUdRUkIwUVJCMUlna2dBMnhCRUhVZ0JDQUpiR29nQmtFUGRVRUJha0VCZFNBSGJHbzJBaXdnQlNBRktBSXdJZ1pCRUhSQkVIVWlDU0FEYkVFUWRTQUVJQWxzYWlBR1FROTFRUUZxUVFGMUlBZHNhallDTUNBRklBVW9BalFpQmtFUWRFRVFkU0lKSUFOc1FSQjFJQVFnQ1d4cUlBWkJEM1ZCQVdwQkFYVWdCMnhxTmdJMElBVWdCU2dDT0NJR1FSQjBRUkIxSWdrZ0EyeEJFSFVnQkNBSmJHb2dCa0VQZFVFQmFrRUJkU0FIYkdvMkFqZ2dCU0FESUFVb0Fqd2lCa0VRZEVFUWRTSUpiRUVRZFNBRUlBbHNhaUFHUVE5MVFRRnFRUUYxSUFkc2FqWUNQQXNnRGtFS2JDQUJhaUVESUFBZ0R6WUNBQUpBQW44Q1FBSkFJQUFvQXNBZ1JRMEFJQUFvQXNRZ1FRSkhEUUFnRGtFQlN3MEFJQXRCQWtZTkFDQURRZ0EzQVdBZ0EwRUFPd0ZvSUFOQmdDQTdBV1FnQ0NBQUtBS0VFaUlHTmdJQURBRUxJQXRCQWtjRVFDQUFLQUtjRWlFSklCTU1BZ3NnQ0NnQ0FDRUdDd0pBUVFBZ0RpQW1JQTVCQWtaeEcwVUVRQ0FBS0FLZ0VpSUhJQVlnQUNnQ3BCSWlCR3ByUVFKcklRZ2dEa0VDUmdSQUlBQWdCMEVCZEdwQnhBcHFJQUlnQUNnQ25CSkJBblFRQkJvZ0FDZ0NvQkloQnlBQUtBS2tFaUVFQ3lBWElBaEJBWFJxSUFBZ0FDZ0NuQklnRG13Z0NHcEJBWFJxUWNRS2FpQU5JQWNnQ0dzZ0JCQkhJQTVGQkVBZ0FTNEJpQUVpQkNBS1FmLy9BM0ZzUVJCMUlBUWdDa0VRZFd4cVFRSjBJUW9MSUFaQmYwZ05BU0FHUVFGcUlRUWdDa0gvL3dOeElRY2dDa0VRZFNFS0lBQW9BcUFTSVFsQkFDRUlBMEFnRWlBUUlBaEJmM01pQzJwQkFuUnFJQWNnRnlBSklBdHFRUUYwYWk0QkFDSUxiRUVRZFNBS0lBdHNhallDQUNBRUlBaEdJUXNnQ0VFQmFpRUlJQXRGRFFBTERBRUxJQWRCZ0lBRVJnMEFJQVpCZjBnTkFDQUdRUUZxSVFRZ0IwSC8vd054SVFvZ0IwRVFkU0VKUVFBaENBTkFJQklnRUNBSVFYOXpha0VDZEdvaUN5QUxLQUlBSWd0QkVIUkJFSFVpRFNBS2JFRVFkU0FKSUExc2FpQUxRUTkxUVFGcVFRRjFJQWRzYWpZQ0FDQUVJQWhISVFzZ0NFRUJhaUVJSUFzTkFBc0xJQUFvQXB3U0lnbEJBVWdOQVNBUUlBWnJRUUowSUJKcVFRaHFJUWdnQXk0QmFDRUVJQU11QVdZaENpQURMZ0ZrSVFZZ0F5NEJZaUVMSUFNdUFXQWhBMEVBSVFjRFFDQVlJQWRCQW5RaURXb2dEU0FUYWlnQ0FDQUlLQUlBSWcxQkVIVWdBMndnRFVILy93TnhJQU5zUVJCMWFpQUlRUVJyS0FJQUlnMUJFSFVnQzJ4cUlBMUIvLzhEY1NBTGJFRVFkV29nQ0VFSWF5Z0NBQ0lOUVJCMUlBWnNhaUFOUWYvL0EzRWdCbXhCRUhWcUlBaEJER3NvQWdBaURVRVFkU0FLYkdvZ0RVSC8vd054SUFwc1FSQjFhaUFJUVJCcktBSUFJZzFCRUhVZ0JHeHFJQTFCLy84RGNTQUViRUVRZFdwQkFYUnFRUVJxSWcwMkFnQWdFaUFRUVFKMGFpQU5RUUYwTmdJQUlCQkJBV29oRUNBSVFRUnFJUWdnQjBFQmFpSUhJQWxIRFFBTElCZ0xJU2NnQ1VFQlNBMEFJQTlCQ25SQkVIVWhDeUFBS0FLa0VpSW9RUUYxSVNrZ0QwRVZkVUVCYWtFQmRTRXFJQVVvQWh3aEJDQUZLQUlrSVFZZ0JTZ0NMQ0VLSUFVb0FqUWhBeUFGS0FJOElRaEJBQ0VISUF3dUFSNGhEeUFNTGdFY0lRMGdEQzRCR2lFVUlBd3VBUmdoR1NBTUxnRVdJUm9nREM0QkZDRWJJQXd1QVJJaEhDQU1MZ0VRSVIwZ0RDNEJEaUVlSUF3dUFRd2hIeUFNTGdFS0lTQWdEQzRCQ0NFaElBd3VBUVloSWlBTUxnRUVJU01nREM0QkFpRWtJQXd1QVFBaEpRTkFJQWhCRUhVZ0pXd2dLV29nQ0VILy93TnhJQ1ZzUVJCMWFpQUhRUUowSWhVZ0JXb2lDQ2dDT0NJTVFSQjFJQ1JzYWlBTVFmLy9BM0VnSkd4QkVIVnFJQU5CRUhVZ0kyeHFJQU5CLy84RGNTQWpiRUVRZFdvZ0NDZ0NNQ0lEUVJCMUlDSnNhaUFEUWYvL0EzRWdJbXhCRUhWcUlBcEJFSFVnSVd4cUlBcEIvLzhEY1NBaGJFRVFkV29nQ0NnQ0tDSUtRUkIxSUNCc2FpQUtRZi8vQTNFZ0lHeEJFSFZxSUFaQkVIVWdIMnhxSUFaQi8vOERjU0FmYkVFUWRXb2dDQ2dDSUNJR1FSQjFJQjVzYWlBR1FmLy9BM0VnSG14QkVIVnFJQVJCRUhVZ0hXeHFJQVJCLy84RGNTQWRiRUVRZFdvZ0NDZ0NHQ0lFUVJCMUlCeHNhaUFFUWYvL0EzRWdIR3hCRUhWcUlRUWdCU0FIUVJCcVFRSjBhZ0ovQW44Z0tFRVFSZ1JBSUFRZ0NDZ0NGQ0lyUVJCMUlCdHNhaUFyUWYvL0EzRWdHMnhCRUhWcUlBZ29BaEFpQkVFUWRTQWFiR29nQkVILy93TnhJQnBzUVJCMWFpQUlLQUlNSWdSQkVIVWdHV3hxSUFSQi8vOERjU0FaYkVFUWRXb2dDQ2dDQ0NJRVFSQjFJQlJzYWlBRVFmLy9BM0VnRkd4QkVIVnFJQWdvQWdRaUJFRVFkU0FOYkdvZ0JFSC8vd054SUExc1FSQjFhaUFJS0FJQUlnUkJFSFVnRDJ4cUlBUkIvLzhEY1NBUGJFRVFkV29oQkFzZ0JBdEJnSUNBUUNBRVFZQ0FnRUJLR3lJRVFmLy8vejhnQkVILy8vOC9TQnRCQkhRaUJDQVZJQ2RxS0FJQUlnaHFJaFZCQUU0RVFDQVZRWUNBZ0lCNElBUWdDSEZCZjBvYkRBRUxRZi8vLy84SElCVWdCQ0FJY2tGL1Noc0xJZ2cyQWdBZ0VTQUhRUUYwYWtILy93RkJnSUIrSUFoQkVIVWdDMndnQ0NBcWJHb2dDRUgvL3dOeElBdHNRUkIxYWlJRVFRZDJRUUZxUVFGMklBUkJnUC8vZTBnYklBUkIvLzcvQTBvYk93RUFJQVloQkNBS0lRWWdBeUVLSUF3aEF5QUhRUUZxSWdjZ0NVY05BQXNMSUFVZ0JTQUpRUUowSWdScUlnTXBBZ0EzQWdBZ0JTQURLUUk0TndJNElBVWdBeWtDTURjQ01DQUZJQU1wQWlnM0FpZ2dCU0FES1FJZ053SWdJQVVnQXlrQ0dEY0NHQ0FGSUFNcEFoQTNBaEFnQlNBREtRSUlOd0lJSUJFZ0NVRUJkR29oRVNBRUlCTnFJUk1nRGtFQmFpSU9JQUFvQXBRU1NBMEFDd3NnQUVHRUNtb2lBQ0FGS1FJQU53SUFJQUFnQlNrQ09EY0NPQ0FBSUFVcEFqQTNBakFnQUNBRktRSW9Od0lvSUFBZ0JTa0NJRGNDSUNBQUlBVXBBaGczQWhnZ0FDQUZLUUlRTndJUUlBQWdCU2tDQ0RjQ0NDQVdRU0JxSkFBTGhnWUJBbjhqQUVFUWF5SUdKQUFnQmtFQU9nQVBJQUpCQ0U0RVFDQURRUUYwSUFScVFSQjBRUkIxUVFkc1FhQTVhaUVESUFKQkNHcEJCSFVpQWtFQklBSkJBVW9iSVFSQkFDRUNBMEFDUUNBRklBSkJBblJxS0FJQUlnZEJBVWdOQUNBR0lBTWdCMEVmY1NJSFFRWWdCMEVHU1J0cUxRQUFPZ0FPSUFFdUFRQkJBVTRFUUNBQklBQWdCa0VPYWtFSUVBTkJBWFJCQVdzZ0FTOEJBR3c3QVFBTElBRXVBUUpCQUVvRVFDQUJJQUFnQmtFT2FrRUlFQU5CQVhSQkFXc2dBUzhCQW13N0FRSUxJQUV1QVFSQkFVNEVRQ0FCSUFBZ0JrRU9ha0VJRUFOQkFYUkJBV3NnQVM4QkJHdzdBUVFMSUFFdUFRWkJBVTRFUUNBQklBQWdCa0VPYWtFSUVBTkJBWFJCQVdzZ0FTOEJCbXc3QVFZTElBRXVBUWhCQVU0RVFDQUJJQUFnQmtFT2FrRUlFQU5CQVhSQkFXc2dBUzhCQ0d3N0FRZ0xJQUV1QVFwQkFVNEVRQ0FCSUFBZ0JrRU9ha0VJRUFOQkFYUkJBV3NnQVM4QkNtdzdBUW9MSUFFdUFReEJBVTRFUUNBQklBQWdCa0VPYWtFSUVBTkJBWFJCQVdzZ0FTOEJER3c3QVF3TElBRXVBUTVCQVU0RVFDQUJJQUFnQmtFT2FrRUlFQU5CQVhSQkFXc2dBUzhCRG13N0FRNExJQUV1QVJCQkFVNEVRQ0FCSUFBZ0JrRU9ha0VJRUFOQkFYUkJBV3NnQVM4QkVHdzdBUkFMSUFFdUFSSkJBVTRFUUNBQklBQWdCa0VPYWtFSUVBTkJBWFJCQVdzZ0FTOEJFbXc3QVJJTElBRXVBUlJCQVU0RVFDQUJJQUFnQmtFT2FrRUlFQU5CQVhSQkFXc2dBUzhCRkd3N0FSUUxJQUV1QVJaQkFVNEVRQ0FCSUFBZ0JrRU9ha0VJRUFOQkFYUkJBV3NnQVM4QkZtdzdBUllMSUFFdUFSaEJBVTRFUUNBQklBQWdCa0VPYWtFSUVBTkJBWFJCQVdzZ0FTOEJHR3c3QVJnTElBRXVBUnBCQVU0RVFDQUJJQUFnQmtFT2FrRUlFQU5CQVhSQkFXc2dBUzhCR213N0FSb0xJQUV1QVJ4QkFVNEVRQ0FCSUFBZ0JrRU9ha0VJRUFOQkFYUkJBV3NnQVM4QkhHdzdBUndMSUFFdUFSNUJBVWdOQUNBQklBQWdCa0VPYWtFSUVBTkJBWFJCQVdzZ0FTOEJIbXc3QVI0TElBRkJJR29oQVNBQ1FRRnFJZ0lnQkVjTkFBc0xJQVpCRUdva0FBdGhBUUovSUFBUUZTSUJCRUJCbVBzQktBSUFJZ0JGQkVCQkNCQVZJZ0JCQURZQ0JDQUFJQUUyQWdCQm1Qc0JJQUEyQWdBZ0FROExBMEFnQUNJQ0tBSUVJZ0FOQUF0QkNCQVZJZ0JCQURZQ0JDQUFJQUUyQWdBZ0FpQUFOZ0lFQ3lBQkM5TURBUVovSXdCQkVHc2lCU1FBQWtBZ0FDZ0N3Q0FFUUNBQVFZZ2hhaUFBUVl3aGFpQUJJQUlRR2lBQVFmd2dha0VCTmdJQURBRUxBa0FnQUVIOElHb29BZ0JGRFFBZ0JVRUlhaUFGUVF4cUlBRWdBaEFhQWtBZ0JTZ0NEQ0lESUFCQmpDRnFLQUlBSWdSS0JFQWdBRUdJSVdvaUJ5QUhLQUlBSUFNZ0JHdDFOZ0lBREFFTElBTWdCRTROQUNBRklBVW9BZ2dnQkNBRGEzVTJBZ2dMSUFVb0FnZ2lCaUFBUVlnaGFpZ0NBQ0lEVEEwQUlBQWdBeUFEWnlJRFFRRnJkQ0lJTmdLSUlVRUFJUWRCQUNFRUlBZ2dCa0VaSUFOcklnTkJBQ0FEUVFCS0czVWlBMEVCSUFOQkFVb2JiU0lEUVFGT0JFQUNRRUVZSUFObklnUnJJZ1pGRFFBZ0EwSC9BRTBFUUNBRElBUkJHR3QwSUFOQk9DQUVhM1p5SVFNTUFRc2dBeUFFUVFocWRDQURJQVoyY2lFREMwR0FnQUpCaHVrQ0lBUkJBWEViSUFSQkFYWjJJZ1FnQTBIL0FIRkJnSURVQm14QkVIWnNRUkIySUFScVFRUjBJUVFMUVlDQUJDQUVheUFDYlNFRElBSkJBVWdOQUNBRFFRSjBJUU1EUUNBQklBZEJBWFJxSWdZZ0JpNEJBQ0lHSUFSQi9QOERjV3hCRUhZZ0JFRVFkaUFHYkdvN0FRQWdBeUFFYWlJRVFZQ0FCRW9OQVNBSFFRRnFJZ2NnQWtnTkFBc0xJQUJCQURZQy9DQUxJQVZCRUdva0FBdm1BZ0VIZnlNQUlnZ2hEU0FJSUFaQkFuUkJEMnBCY0hGcklnb2tBQ0FHUVFGT0JFQWdCMEVDYXlBR2JDRU1JQVVvQWdBaUNFRVFkRUVRZFNFTElBaEJEM1ZCQVdwQkFYVWhEa0VBSVFnRFFDQUtJQWhCQVhScVFmLy9BVUdBZ0g0Z0N5QUVJQWdnREdwQkFuUnFLQUlBSWdsQi8vOERjV3hCRUhVZ0N5QUpRUkIxYkdvZ0NTQU9iR29pQ1VFSWRpQUpRWUNBZ0h4SUd5QUpRZi8vL3dOS0d6c0JBQ0FJUVFGcUlnZ2dCa2NOQUFzZ0IwRUJheUFHYkNFTElBb2dCa0VCZEdvaENTQUZLQUlFSWdkQkVIUkJFSFVoQlNBSFFROTFRUUZxUVFGMUlReEJBQ0VJQTBBZ0NTQUlRUUYwYWtILy93RkJnSUIrSUFVZ0JDQUlJQXRxUVFKMGFpZ0NBQ0lIUWYvL0EzRnNRUkIxSUFVZ0IwRVFkV3hxSUFjZ0RHeHFJZ2RCQ0hZZ0IwR0FnSUI4U0JzZ0IwSC8vLzhEU2hzN0FRQWdDRUVCYWlJSUlBWkhEUUFMQ3lBQUlBRWdDaUFHRUJvZ0FpQURJQW9nQmtFQmRHb2dCaEFhSUEwa0FBdndGQUVmZnlNQVFVQnFJZ2NrQUNBSElBQW9BcGdTSUFBb0FxQVNha0VDZEVFUGFrRndjV3NpRHlJRUpBQWdCQ0FBS0FLZ0VrRUJkRUVQYWtGd2NXc2lEQ1FBSUFjZ0FFR1VJV29vQWdCQkJuVTJBZ2dnQnlBQVFaZ2hhaWdDQUNJV1FRWjFJaGMyQWd3Z0FDZ0N5QklFUUNBQVFmSWdha0lBTndFQUlBQkI2aUJxUWdBM0FRQWdBRUhpSUdwQ0FEY0JBQ0FBUWRvZ2FrSUFOd0VBQ3lBSFFUUnFJQWRCUEdvZ0IwRXdhaUFIUVRocUlBQkJCR29nQjBFSWFpQUFLQUtjRWlBQUtBS1VFaEJ6SUFCQm9DRnFLQUlBSVFnQ1FDQUhLQUkwSUFjb0FqaDFJQWNvQWpBZ0J5Z0NQSFZJQkVBZ0NFRUJheUVOSUFCQnBDRnFLQUlBSVFnTUFRc2dBRUdrSVdvb0FnQWhEUXNnQUVHRUlXb3ZBUUFoQ1NBQUtBTEFJQ0VFSUFBb0FzUWdJUVlnQUVIYUlHb2lCU0FBS0FLa0VrSHgrZ01RS2lBSFFSQnFJQVVnQUNnQ3BCSWlBMEVCZEJBRUdpQUVRUUVnQkVFQlNCdEJBWFFpQzBHdUNXb2dDMEd5Q1dvZ0JrRUNSaHN1QVFBaERnSkFJQUFvQXNBZ0RRQWdBQ2dDeENCQkFrWUVRQ0FBUVpBaGFpNEJBRUdBZ0FFZ0FFSFlJR292QVFBZ0FFSFdJR292QVFBZ0FFSFVJR292QVFBZ0FDOEIwQ0FnQUVIU0lHb3ZBUUJxYW1wcWF5SUVRYzBaSUFSQkVIUkJFSFZCelJsS0cwSC8vd054YkVFT2RpRUpEQUVMSUFVZ0F4QWRJZ1JCZ0lDQXdBQWdCRUdBZ0lEQUFFZ2JJZ1JCZ0lDQUFpQUVRWUNBZ0FKS0d5SUVRUU4wUWZqL0EzRWdEbXhCRUhVZ0JFRU5ka0gvL3dOeElBNXNha0VPZFNFT0lBQW9BcVFTSVFOQmdJQUJJUWtMSUFCQmdDRnFLQUlBSVJ3Z0RDQUFLQUtnRWlJRUlBTnJJQUFvQXN3Z1FRZDFRUUZxUVFGMUloTnJRUUpySWdaQkFYUWlCV29nQUNBRmFrSEVDbW9nQjBFUWFpQUVJQVpySUFNUVIwRUFJQUFvQXBnaElnVWdCU0FGUVI5MUlnTnFJQU56SWhCbklnTkJBV3QwSWdWQi8vOERjVUgvLy8vL0FTQUZRUkIxSWdwdEloRkJFSFFpRWtFUWRTSUZiRUVRZFNBRklBcHNha0VEZEdzaUNpQVJRUTkxUVFGcVFRRjFiQ0FTYWlBS1FSQjFJQVZzYWlBS1Fmai9BM0VnQld4QkVIVnFJUVVDZnlBUVFmLy9BMDBFUUVILy8vLy9CeUFEUVJCcklnTjJJZ3BCZ0lDQWdIZ2dBM1VpRUNBRklBVWdFRWdiSUFVZ0Nrb2JJQU4wREFFTElBVkJFQ0FEYTNVTElRVWdBQ2dDcEJJaUVDQUdhaUlESUFBb0FxQVNJaEZJQkVBZ0JVSC8vLy8vQXlBRlFmLy8vLzhEU0JzaUJVSC8vd054SVFZZ0JVRVFkU0VGQTBBZ0R5QURRUUowYWlBR0lBd2dBMEVCZEdvdUFRQWlDbXhCRUhVZ0JTQUtiR28yQWdBZ0EwRUJhaUlESUJGSURRQUxDeUFBS0FLVUVpSVlRUUZPQkVBZ0NDQU5iQ0lGUVlBQklBVkJnQUZLRzBFQ2RDQUFha0g4QTJzaEdTQUxRYW9KYWk0QkFDRUtJQUF1QVl3U1FZQWtiQ0VTSUE1QkVIUkJFSFVoR2lBQVFkZ2dhaThCQUNFRElBQkIxaUJxTHdFQUlRc2dBRUhVSUdvdkFRQWhCU0FBUWRJZ2FpOEJBQ0VJSUFBdkFkQWdJUVlnQUNnQ25CSWhGQU5BQWtBZ0ZFRUFUQVJBSUFsQkVIUkJFSFVoRFNBRFFSQjBRUkIxSVF3Z0MwRVFkRUVRZFNFTElBVkJFSFJCRUhVaEJTQUlRUkIwUVJCMUlRZ2dCa0VRZEVFUWRTRUdEQUVMSUFsQkVIUkJFSFVoRFNBRFFSQjBRUkIxSVF3Z0MwRVFkRUVRZFNFTElBVkJFSFJCRUhVaEJTQUlRUkIwUVJCMUlRZ2dCa0VRZEVFUWRTRUdJQVFnRTJ0QkFuUWdEMnBCQ0dvaEEwRUFJUTREUUNBUElBUkJBblJxSUFNb0FnQWlDVUVRZFNBR2JDQUpRZi8vQTNFZ0JteEJFSFZxSUFOQkJHc29BZ0FpQ1VFUWRTQUliR29nQ1VILy93TnhJQWhzUVJCMWFpQURRUWhyS0FJQUlnbEJFSFVnQld4cUlBbEIvLzhEY1NBRmJFRVFkV29nQTBFTWF5Z0NBQ0lKUVJCMUlBdHNhaUFKUWYvL0EzRWdDMnhCRUhWcUlBTkJFR3NvQWdBaUNVRVFkU0FNYkdvZ0NVSC8vd054SUF4c1FSQjFhaUFaSUJ4QnRZak8zUUJzUWV2RzViQURhaUljUVJkMlFmd0RjV29vQWdBaUNVRVFkU0FOYkdvZ0NVSC8vd054SUExc1FSQjFha0VDZEVFSWFqWUNBQ0FFUVFGcUlRUWdBMEVFYWlFRElBNUJBV29pRGlBVVJ3MEFDd3NnQUNBQUtBTE1JQ0lEUVJCMVFZOEZiQ0FEYWlBRFFmLy9BM0ZCandWc1FSQjJhaUlESUJJZ0F5QVNTQnNpQXpZQ3pDQWdBMEVIZFVFQmFrRUJkU0VUSUEwZ0dteEJEM1loQ1NBS0lBeHNRUTkySVFNZ0NpQUxiRUVQZGlFTElBVWdDbXhCRDNZaEJTQUlJQXBzUVE5MklRZ2dCaUFLYkVFUGRpRUdJQnRCQVdvaUd5QVlSdzBBQ3lBQUlBTTdBZGdnSUFBZ0N6c0IxaUFnQUNBRk93SFVJQ0FBSUFnN0FkSWdJQUFnQmpzQjBDQUxJQkZCQW5RZ0QycEJRR29pQmlBQUtRS0VDamNDQUNBR0lBQkJ2QXBxS1FJQU53STRJQVlnQUVHMENtb3BBZ0EzQWpBZ0JpQUFRYXdLYWlrQ0FEY0NLQ0FHSUFCQnBBcHFLUUlBTndJZ0lBWWdBRUdjQ21vcEFnQTNBaGdnQmlBQVFaUUthaWtDQURjQ0VDQUdJQUJCakFwcUtRSUFOd0lJSUFBb0FwZ1NJZzVCQVU0RVFDQVFRUUYxSVI0Z0YwRVFkRUVRZFNFS0lCWkJGWFZCQVdwQkFYVWhIeUFHS0FJY0lRUWdCaWdDSkNFTklBWW9BaXdoRENBR0tBSTBJUVVnQmlnQ1BDRURJQWN1QVNJaER5QUhMZ0VnSVJFZ0J5NEJIaUVTSUFjdUFSd2hGQ0FITGdFYUlSWWdCeTRCR0NFWElBY3VBUlloR0NBSExnRVVJUmtnQnk0QkVpRWFJQWN1QVJBaEd5QVFRUXRJSVNCQkFDRUlBMEFnQTBFUWRTQWJiQ0FlYWlBRFFmLy9BM0VnRzJ4QkVIVnFJQWhCQW5RZ0Jtb2lBeWdDT0NJTFFSQjFJQnBzYWlBTFFmLy9BM0VnR214QkVIVnFJQVZCRUhVZ0dXeHFJQVZCLy84RGNTQVpiRUVRZFdvZ0F5Z0NNQ0lGUVJCMUlCaHNhaUFGUWYvL0EzRWdHR3hCRUhWcUlBeEJFSFVnRjJ4cUlBeEIvLzhEY1NBWGJFRVFkV29nQXlnQ0tDSU1RUkIxSUJac2FpQU1RZi8vQTNFZ0ZteEJFSFZxSUExQkVIVWdGR3hxSUExQi8vOERjU0FVYkVFUWRXb2dBeWdDSUNJTlFSQjFJQkpzYWlBTlFmLy9BM0VnRW14QkVIVnFJQVJCRUhVZ0VXeHFJQVJCLy84RGNTQVJiRUVRZFdvZ0F5Z0NHQ0lFUVJCMUlBOXNhaUFFUWYvL0EzRWdEMnhCRUhWcUlRUWdDRUVRYWlFVlFRb2hBeUFnUlFSQUEwQWdCQ0FIUVJCcUlBTkJBWFJxTGdFQUloMGdCaUFWSUFOQmYzTnFRUUowYWlnQ0FDSWhRUkIxYkdvZ0lVSC8vd054SUIxc1FSQjFhaUVFSUFOQkFXb2lBeUFRUncwQUN3c0NmeUFHSUJWQkFuUnFJaDBvQWdBaUF5QUVRWUNBZ0VBZ0JFR0FnSUJBU2hzaUJFSC8vLzgvSUFSQi8vLy9QMGdiUVFSMElnUnFJaFZCQUU0RVFDQVZRWUNBZ0lCNElBTWdCSEZCZjBvYkRBRUxRZi8vLy84SElCVWdBeUFFY2tGL1Noc0xJUU1nSFNBRE5nSUFJQUlnQ0VFQmRHcEIvLzhCUVlDQWZpQURRUkIxSUFwc0lBTWdIMnhxSUFOQi8vOERjU0FLYkVFUWRXb2lCRUVIZGtFQmFrRUJkaUFFUVlELy8zdElHeUFFUWYvKy93TktHenNCQUNBTklRUWdEQ0VOSUFVaERDQUxJUVVnQ0VFQmFpSUlJQTVIRFFBTEN5QUFRWVFLYWlJQ0lBWWdEa0VDZEdvaUJDa0NBRGNDQUNBQ0lBUXBBamczQWpnZ0FpQUVLUUl3TndJd0lBSWdCQ2tDS0RjQ0tDQUNJQVFwQWlBM0FpQWdBaUFFS1FJWU53SVlJQUlnQkNrQ0VEY0NFQ0FDSUFRcEFnZzNBZ2dnQUNBSk93R0VJU0FBSUJ3MkFvQWhJQUVnRXpZQ0RDQUJJQk0yQWdnZ0FTQVROZ0lFSUFFZ0V6WUNBQ0FIUVVCckpBQUxnd1lCRG44Z0FTQUNRUUYwYWlFTUlBQWdBa0VCYXlJTFFRRjBhaUVKSUFKQkFrZ2hEZ0pBQTBBZ0FDNEJBQ0lGSUFFdUFRQWlDR3NoQkVFQklRTkJBQ0VHSUE1RkJFQURRQ0FGUVJCMElRY2dBQ0FEUVFGMElncHFMZ0VBSWdVZ0IwRVFkV3NnQVNBS2FpNEJBR3NpQnlBRUlBUWdCMG9pQnhzaEJDQURJQVlnQnhzaEJpQURRUUZxSWdNZ0FrY05BQXNMUVlDQUFpQU1MZ0VBSWdjZ0NTNEJBR3BySWdNZ0JDQURJQVJJSWdNYlFYOUtEUUVDUUNBQ0lBWWdBeHNpQlVVRVFDQUFJQWc3QVFBTUFRc0NRQUpBSUFJZ0JVY0VRQ0FGUVFGT0RRRkJBQ0VJREFJTElBbEJnSUIrSUFkck93RUFEQUlMUVFFaEF5QUZRUUZHRFFBRFFDQUlJQUVnQTBFQmRHb3VBUUJxSVFnZ0EwRUJhaUlESUFWSERRQUxDeUFJSUFFZ0JVRUJkQ0lQYWlJUUxnRUFRUUYxSWdwcUlRUkJnSUFDSVFZQ1FDQUNJQVZNRFFCQmdJQUNJQWRySVFZZ0JTQUxJZ05PRFFBRFFDQUdJQUVnQTBFQmRHb3VBUUJySVFZZ0EwRUJheUlESUFWS0RRQUxDeUFBSUE5cUlnZ3VBUUFnQUNBRlFRRnJRUUYwYWlJSExnRUFhaUlEUVFGMUlBTkJBWEZxSVFVQ1FDQUdJQXBySWdNZ0JFZ0VRQ0FGSUFRaUJrb05BU0FESUFVZ0F5QUZTaHNoQmd3QkN5QURJZ1lnQlVnTkFDQUVJQVVnQkNBRlNoc2hCZ3NnQnlBR0lBcHJJZ1k3QVFBZ0NDQUdJQkF2QVFCcU93RUFDeUFOUVFGcUlnMUJGRWNOQUFzZ0FDQUNFR1VnQUNBQUxnRUFJZ1lnQVM0QkFDSURJQU1nQmtnYklnUTdBUUFnQWtFQ1NDSUdSUVJBUVFFaEF3TkFJQUFnQTBFQmRDSUxhaUlGSUFVdUFRQWlCU0FCSUF0cUxnRUFJQVJCRUhSQkVIVnFJZ1JCLy84QklBUkIvLzhCU0JzaUJFR0FnSDRnQkVHQWdINUtHeUlFSUFRZ0JVZ2JJZ1E3QVFBZ0EwRUJhaUlESUFKSERRQUxDeUFKSUFrdUFRQWlBMEdBZ0FJZ0RDNEJBR3NpQkNBRElBUklHeUlFT3dFQUlBWU5BQ0FDUVFKcklRTURRQ0FBSUFOQkFYUWlBbW9pQmlBR0xnRUFJZ1lnQkVFUWRFRVFkU0FCSUFKcUxnRUNheUlDSUFJZ0Jrb2JJZ1E3QVFBZ0EwRUFTaUVDSUFOQkFXc2hBeUFDRFFBTEN3dk1BZ0VKZnlNQVFkQUFheUlGSkFBZ0JVRWdhaUFGUVVCcklBSWdBU3dBQUJCR0lBSXZBUUlpQTBFUWRFRVFkU0lIUVFGSUlndEZCRUFnQWk0QkJDRUlBMEFnQlNBRFFRRnJJZ1pCQVhScUlBRWdBMm9zQUFBaUNrRUtkQ0lFUWVZQWF5QUVRZVlBY2lBS1FSOTFjU0FLUVFCS0d5SUVRUkIxSUFoc0lBVkJRR3NnQm1vdEFBQWdDVUVRZEVFUWRXeEJDSFZxSUFSQi92OERjU0FJYkVFUWRXb2lDVHNCQUNBRFFRRktJUVFnQmlFRElBUU5BQXNMSUF0RkJFQWdBU3dBQUNBSGJDSUJJQUlvQWdocUlRUWdBaWdDRENBQlFRRjBhaUVHUVFBaEF3TkFJQUFnQTBFQmRDSUJhaUFCSUFWcUxnRUFRUTUwSUFFZ0Jtb3VBUUJ0SUFNZ0JHb3RBQUJCQjNScUlnRkJBQ0FCUVFCS0d5SUJRZi8vQVNBQlFmLy9BVWdiT3dFQUlBTkJBV29pQXlBQ0xnRUNJZ2RJRFFBTEN5QUFJQUlvQWlRZ0J4QjFJQVZCMEFCcUpBQUwyQUlCQlg4Q1FDQUNRUUZJRFFBQ1FBTkFRUUFoQTBFQUlRUURRQ0FCSUFOQkFuUnFLQUlBSWdVZ0JVRWZkU0lGYWlBRmN5SUZJQVFnQkNBRlNDSUZHeUVFSUFNZ0JpQUZHeUVHSUFOQkFXb2lBeUFDUncwQUN5QUVRUVIyUVFGcVFRRjJJZ05CZ0lBQ1R3UkFJQUVnQWtHKy93TWdBMEgrL3drZ0EwSCsvd2xJR3lJRFFRNTBRWUNBLy84QmF5QURJQVpCQVdwc1FRSjFiV3NRS1NBSFFRRnFJZ2RCQ2tjTkFRd0NDd3NnQjBFS1JnMEFJQUpCQVVnTkFVRUFJUU1EUUNBQUlBTkJBWFJxSUFFZ0EwRUNkR29vQWdCQkJIVkJBV3BCQVhZN0FRQWdBMEVCYWlJRElBSkhEUUFMREFFTElBSkJBVWdOQUVFQUlRTURRQ0FBSUFOQkFYUnFBbjlCLy84QklBRWdBMEVDZEdvaUJpZ0NBRUVFZFNJRVFmNy9BMG9OQUJwQmdJQitJQVJCLy85N1NBMEFHaUFFUVFGcVFRRjFDeUlFT3dFQUlBWWdCRUVGZERZQ0FDQURRUUZxSWdNZ0FrY05BQXNMQzRvQkFRTi9Jd0JCRUdzaUJDUUFBa0FDUUFKL1FaRDdBU2dDQUNJRkJFQWdBMEVCU0FSL1FYOEZJQVVnQUNBQklBSWdBMEVBUVFBUVRnc01BUXRCbFBzQktBSUFJZ1ZGRFFFZ0JTQUFJQUVnQWlBREVINExJZ1pCQUVvTkFRc2dCQ0FETmdJTUlBUWdBallDQ0NBRUlBRTJBZ1FnQkNBQU5nSUFRYlFJSUFRUUhnc2dCRUVRYWlRQUlBWUxreElCSG44akFFRWdheUlLSVFnZ0NpUUFJQUFvQW93U0lna2dBRUc4SUdvb0FnQkhCRUJCLy84QklBQW9BcVFTSWdaQkFXcHRJUWNnQmtFQlRnUkFBMEFnQUNBRVFRRjBha0hVSDJvZ0JTQUhhaUlGT3dFQUlBUkJBV29pQkNBR1J3MEFDd3NnQUNBSk5nSzhJQ0FBUWJRZ2FrS0FnSUNBZ0pDZUdEY0NBQXNDUUFKQUlBQW9Bc0FnUlFSQUFrQWdBQ2dDeENBTkFFRUFJUVFnQUNnQ3BCSWlCVUVBU2dSQUEwQWdBQ0FFUVFGMGFpSUdRZFFmYWlJSklBa3VBUUFpQ1NBR1FhZ1NhaTRCQUNBSmF5SUdRZi8vQTNGQjNQOEFiRUVRZGlBR1FSQjJRZHovQUd4cWFqc0JBQ0FFUVFGcUlnUWdCVWNOQUFzTElBQkIxQlZxSVFsQkFDRUVBa0FnQUNnQ2xCSWlCMEVBVEFSQVFRQWhCZ3dCQzBFQUlRWkJBQ0VGQTBBZ0FTQUVRUUowYWlnQ0VDSUxJQVVnQlNBTFNDSUxHeUVGSUFRZ0JpQUxHeUVHSUFSQkFXb2lCQ0FIUncwQUN3c2dBQ0FBS0FLY0VpSUZRUUowYWtIVUZXb2dDU0FIUVFKMFFRUnJJQVZzRUE0YUlBa2dBQ0FBS0FLY0VpSUZJQVpzUVFKMGFrRUVhaUFGUVFKMEVBUWFJQUFvQXBRU0lnbEJBVWdOQUNBQVFiUWdhaWdDQUNFRVFRQWhCUU5BSUFBZ0JDQUJJQVZCQW5ScUlnWkJFR29vQWdBZ0JHc2lCRUVRZFVHYUpHeHFJQVJCLy84RGNVR2FKR3hCRUhacUlnUTJBclFnSUFZb0FoQWlCaUFFUVJCMVFienFmbXdnQkdvZ0JFSC8vd054UWJ6cWZteEJFSFZxU0FSQUlBQWdCallDdENBZ0JpRUVDeUFGUVFGcUlnVWdDVWNOQUFzTElBQW9Bc0FnUlEwQkN5QUtJQU5CQW5SQnp3QnFRWEJ4YXlJSEpBQWdBRUdZSVdvb0FnQWlBVUVRZEVFUWRTSUZJQUJCaENGcUx3RUFJZ1JzUVJCMUlBVWdCRUVRZENJRVFSOTFiR29nQVVFUGRVRUJha0VCZFNBRVFSQjFiR29pQlVFUWRTRUVBbjhnQlVILy8vOEFURUVBSUFCQnRDQnFLQUlBSWdGQmdZQ0FCRWdiUlFSQVFRQWdBVUVRZFNJQklBRnNJQVFnQkd4QkJYUnJJZ1JCQVVnTkFSb0NRRUVZSUFSbklnRnJJZ1ZGRFFBZ0JFSC9BRTBFUUNBRUlBRkJHR3QwSUFSQk9DQUJhM1p5SVFRTUFRc2dCQ0FCUVFocWRDQUVJQVYyY2lFRUN5QUVRZjhBY1VHQWdOUUdiRUVRZGtHQWdBUnlRWUNBQWtHRzZRSWdBVUVCY1JzZ0FVRUJkblpzUVlDQWZIRU1BUXRCQUNBQlFSQjBRUkIxSWdZZ0FVRVFkV3dnQlVFUWRFRVFkU0lLSUFWQi8vOERjV3hCRUhVZ0JDQUtiR29nQlVFUGRVRUJha0VCZGlBRmJHcEJCWFJySUFZZ0FVSC8vd054YkVFUWRXb2dBVUVQZFVFQmFrRUJkU0FCYkdvaUJFRUJTQTBBR2dKQVFSZ2dCR2NpQVdzaUJVVU5BQ0FFUWY4QVRRUkFJQVFnQVVFWWEzUWdCRUU0SUFGcmRuSWhCQXdCQ3lBRUlBRkJDR3AwSUFRZ0JYWnlJUVFMUVlDQUFrR0c2UUlnQVVFQmNSc2dBVUVCZG5ZaUFTQUVRZjhBY1VHQWdOUUdiRUVRZG14QkVIWWdBV3BCQ0hRTElRRWdCMEZBYXlFS1FmOEJJUVVEUUNBRklnUkJBWFVoQlNBRElBUklEUUFMSUFCQnVDQnFLQUlBSVFZZ0EwRUJTQ0lKUlFSQVFRQWhCUU5BSUFvZ0JVRUNkR29nQUNBR1FiV0l6dDBBYkVIcnh1V3dBMm9pQmtFWWRTQUVjVUVDZEdwQjFCVnFLQUlBTmdJQUlBVkJBV29pQlNBRFJ3MEFDd3NnQUNBR05nSzRJQ0FJSUFCQjFCOXFJQUFvQXFRU0lBQW9Bc2dnRUNzZ0J5QUFRYXdnYWlrQ0FEY0NPQ0FISUFCQnBDQnFLUUlBTndJd0lBY2dBRUdjSUdvcEFnQTNBaWdnQnlBQVFaUWdhaWtDQURjQ0lDQUhJQUJCakNCcUtRSUFOd0lZSUFjZ0FFR0VJR29wQWdBM0FoQWdCeUFBUWZ3ZmFpa0NBRGNDQ0NBSElBQkI5QjlxSWdzcEFnQTNBZ0FnQ1VVRVFDQUJRUXAwUVJCMUlRd2dBQ2dDcEJJaUhrRUJkU0VmSUFGQkZYVkJBV3BCQVhVaElDQUhLQUljSVFVZ0J5Z0NKQ0VHSUFjb0Fpd2hDaUFIS0FJMElRRWdCeWdDUENFRUlBZ3VBUjRoRFNBSUxnRWNJUTRnQ0M0QkdpRVBJQWd1QVJnaEVDQUlMZ0VXSVJFZ0NDNEJGQ0VTSUFndUFSSWhFeUFJTGdFUUlSUWdDQzRCRGlFVklBZ3VBUXdoRmlBSUxnRUtJUmNnQ0M0QkNDRVlJQWd1QVFZaEdTQUlMZ0VFSVJvZ0NDNEJBaUViSUFndUFRQWhIRUVBSVFBRFFDQUVRUkIxSUJ4c0lCOXFJQVJCLy84RGNTQWNiRUVRZFdvZ0FFRUNkQ0FIYWlJRUtBSTRJZ2xCRUhVZ0cyeHFJQWxCLy84RGNTQWJiRUVRZFdvZ0FVRVFkU0FhYkdvZ0FVSC8vd054SUJwc1FSQjFhaUFFS0FJd0lnRkJFSFVnR1d4cUlBRkIvLzhEY1NBWmJFRVFkV29nQ2tFUWRTQVliR29nQ2tILy93TnhJQmhzUVJCMWFpQUVLQUlvSWdwQkVIVWdGMnhxSUFwQi8vOERjU0FYYkVFUWRXb2dCa0VRZFNBV2JHb2dCa0gvL3dOeElCWnNRUkIxYWlBRUtBSWdJZ1pCRUhVZ0ZXeHFJQVpCLy84RGNTQVZiRUVRZFdvZ0JVRVFkU0FVYkdvZ0JVSC8vd054SUJSc1FSQjFhaUFFS0FJWUlnVkJFSFVnRTJ4cUlBVkIvLzhEY1NBVGJFRVFkV29oQlFKL0FuOGdIa0VRUmdSQUlBVWdCQ2dDRkNJRlFSQjFJQkpzYWlBRlFmLy9BM0VnRW14QkVIVnFJQVFvQWhBaUJVRVFkU0FSYkdvZ0JVSC8vd054SUJGc1FSQjFhaUFFS0FJTUlnVkJFSFVnRUd4cUlBVkIvLzhEY1NBUWJFRVFkV29nQkNnQ0NDSUZRUkIxSUE5c2FpQUZRZi8vQTNFZ0QyeEJFSFZxSUFRb0FnUWlCVUVRZFNBT2JHb2dCVUgvL3dOeElBNXNRUkIxYWlBRUtBSUFJZ1ZCRUhVZ0RXeHFJQVZCLy84RGNTQU5iRUVRZFdvaEJRc2dCUXRCZ0lDQVFDQUZRWUNBZ0VCS0d5SUZRZi8vL3o4Z0JVSC8vLzgvU0J0QkJIUWlCU0FISUFCQkVHcEJBblJxSWlFb0FnQWlCR29pSFVFQVRnUkFJQjFCZ0lDQWdIZ2dCQ0FGY1VGL1Noc01BUXRCLy8vLy93Y2dIU0FFSUFWeVFYOUtHd3NoQkNBaElBUTJBZ0FnQWlBQVFRRjBhaUlGSUFVdUFRQkIvLzhCUVlDQWZpQUVRUkIxSUF4c0lBUWdJR3hxSUFSQi8vOERjU0FNYkVFUWRXb2lCVUVIZFVFQmFrRUJkU0FGUVlELy8zdElHeUFGUWYvKy93TktHMm9pQlVHQWdINGdCVUdBZ0g1S0d5SUZRZi8vQVNBRlFmLy9BVWdiT3dFQUlBWWhCU0FLSVFZZ0FTRUtJQWtoQVNBQVFRRnFJZ0FnQTBjTkFBc0xJQXNnQnlBRFFRSjBhaUlBS1FJQU53SUFJQXNnQUNrQ09EY0NPQ0FMSUFBcEFqQTNBakFnQ3lBQUtRSW9Od0lvSUFzZ0FDa0NJRGNDSUNBTElBQXBBaGczQWhnZ0N5QUFLUUlRTndJUUlBc2dBQ2tDQ0RjQ0NBd0JDeUFBUWZRZmFrRUFJQUFvQXFRU1FRSjBFQVVhQ3lBSVFTQnFKQUFMVlFFRWYwSC8vd0VnQUNnQ3BCSWlBa0VCYW0waEJDQUNRUUZPQkVBRFFDQUFJQUZCQVhScVFkUWZhaUFESUFScUlnTTdBUUFnQVVFQmFpSUJJQUpIRFFBTEN5QUFRYlFnYWtLQWdJQ0FnSkNlR0RjQ0FBdHlBQUpBSUFNRVFFRUFJUVlnQlVFQVRBMEJBMEFnQUNBQklBWnNJQUpxUVFKMGFpQURJQVFnQm14QkFuUnFLZ0lBT0FJQUlBWkJBV29pQmlBRlJ3MEFDd3dCQzBFQUlRWWdCVUVBVEEwQUEwQWdBQ0FCSUFac0lBSnFRUUowYWtFQU5nSUFJQVpCQVdvaUJpQUZSdzBBQ3dzTE53RUJmeU1BUVRCcklnSWtBRUVDRUF3YVFRRVFEQm9nQWlBQktBSUFOZ0lBSUFCQmpBSnFJQUlRaWdFaEFDQUNRVEJxSkFBZ0FBc2xBUUYvSXdCQkVHc2lBaVFBSUFJZ0FUWUNEQ0FBSUFFUWZDRUFJQUpCRUdva0FDQUFDNXNHQVExL0l3QkJnQUZySWdnaEJ5QUlKQUFDUUNBRVFRRklCRUJCZnlFRkRBRUxJQWNnQjBFSWFqWUNBRUY5SVFVZ0FDQUhFSDBOQUNBSUlBUWdCeWdDQ0VFWmJVRURiQ0lGSUFRZ0JVZ2JJZ1JCQTNSQkQycEJjSEZySWd3a0FFRUNFQXdoRUVFQkVBd2hFUUpBSUFKQkFFZ0VRRUYvSVFVTUFRc2dBZ1JBUVh3aEJTQUFLQUlFSWdwQkFYUkJBV3NnQWtvTkFRSkFJQXBCQVVnTkFDQUtRUUZySVE0Z0J5Z0NDQ0VQUVFBaENDQUJJUXNnQWlFRkEwQkJmQ0VHSUFWQkFVZ05BU0FMSUFVZ0NTQU9SeUFIUWY4QWFpQUhRUkJxUVFBZ0IwRU1haEEzSWdaQkFFZ05BU0FMSUFjb0Fnd2dEeENEQVNFTklBa0VRRUY4SVFZZ0NDQU5SdzBDQ3lBRklBY29BZ3dpQ0dzaEJTQUlJQXRxSVFzZ0RTSUlJUVlnQ1VFQmFpSUpJQXBIRFFBTEN5QUdRWDRnQmtFQVNCc2hCU0FFSUFaSURRRWdCa0VBU0EwQkN5QUFLQUlFSWdWQkFVNEVRQ0FDUVFCSElRc2dBRUdNQW1vaENDQU1RUVJxSVEwZ0FpRUpRUUFoQmdOQUlBc2dDVUVCU0hFRVFFRjlJUVVNQXdzZ0FDZ0NDQ0VLSUFkQkFEWUNFQ0FJSUFFZ0NTQU1JQVFnQmlBRlFRRnJSeUFIUVJCcUVFNGlCRUVCU0FSQUlBUWhCUXdEQ3lBUUlCRWdCaUFLU0J0QkEycEJmSEVoQ2lBSEtBSVFJZ1ZCQUNBQ0d5RU9JQUVnQldvaER3SkFJQUFvQWdnZ0Jrd0VRQ0FBSUFaQmZ4QklJZ1ZCZjBZTkFRTkFJQU1nQUNnQ0FDQUZJQXhCQVNBRVFRQkJBUkVIQUNBQUlBWWdCUkJJSWdWQmYwY05BQXNNQVFzZ0FDQUdRWDhRU2lJRlFYOUhCRUFEUUNBRElBQW9BZ0FnQlNBTVFRSWdCRUVBUVFFUkJ3QWdBQ0FHSUFVUVNpSUZRWDlIRFFBTEN5QUFJQVpCZnhCSklnVkJmMFlOQUFOQUlBTWdBQ2dDQUNBRklBMUJBaUFFUVFCQkFSRUhBQ0FBSUFZZ0JSQkpJZ1ZCZjBjTkFBc0xJQWdnQ21vaENDQUpJQTVySVFrZ0R5QUJJQUliSVFFZ0JrRUJhaUlHSUFBb0FnUWlCVWdOQUFzTFFRQWhCaUFBS0FJQUlnVkJBRW9FUUFOQUlBQWdCbW90QUF4Qi93RkdCRUFnQXlBRklBWkJBRUVBSUFSQkFFRUJFUWNBSUFBb0FnQWhCUXNnQmtFQmFpSUdJQVZJRFFBTEN5QUVJUVVMQ3lBSFFZQUJhaVFBSUFVTGdnRUJBWDhDUUNBQlFRRnJRZjRCU3dSQUlBSkZEUUVnQWtGL05nSUFRUUFQQzBFQ0VBeEJBMnBCZkhGQkFYUkJBUkFNUVFOcVFYeHhRUUYwYWtHTUFtb1FGU0lEUlFSQVFRQWhBeUFDUlEwQklBSkJlVFlDQUVFQUR3c2dBeUFBSUFFUWdBRWhBQ0FDQkVBZ0FpQUFOZ0lBQ3lBQVJRMEFJQU1RQ0VFQUlRTUxJQU1MN2dFQkJIOUJmeUVFQWtBZ0FrRUJhMEgrQVVzTkFDQUFRUUkyQWdnZ0FFRUVOZ0lFSUFBZ0FqWUNBQU5BSUFBZ0Eyb2dBMEdBQ0dvdEFBQTZBQXdnQTBFQmFpSURJQUpIRFFBTElBQVFnZ0ZGRFFBZ0FFR01BbW9oQTBFQ0VBd2hBa0VCRUF3aEJRSkFJQUFvQWdoQkFVZ0VRRUVBSVFJTUFRc2dBa0VEYWtGOGNTRUdRUUFoQWdOQUlBTWdBVUVDRURBaUJBMENJQU1nQm1vaEF5QUNRUUZxSWdJZ0FDZ0NDRWdOQUFzTElBQW9BZ1FnQWtvRVFDQUZRUU5xUVh4eElRVURRQ0FESUFGQkFSQXdJZ1FOQWlBRElBVnFJUU1nQWtFQmFpSUNJQUFvQWdSSURRQUxDMEVBSVFRTElBUUxpQUlCQTM4akFFRVFheUlESkFBQ1FFRUFRWkQ3QVNnQ0FDSUNSVUdVK3dFb0FnQWlCQnNOQUFKQUlBSUVRQ0FDRUFoQmtQc0JRUUEyQWdBTUFRc2dCRVVOQUNBRUVBaEJsUHNCUVFBMkFnQUxRWmo3QVNnQ0FDSUNSUTBBQTBBZ0FpZ0NBQkFJSUFJb0FnUWhCQ0FDRUFnZ0JDSUNEUUFMUVpqN0FVRUFOZ0lBQ3lBRFFRQTJBZ3dDUUNBQlFRRnJRUUZOQkVCQmtQc0JJQUFnQVNBRFFReHFFSmNCTmdJQURBRUxRWlQ3QVNBQUlBRWdBMEVNYWhCL05nSUFDeUFES0FJTUlnSkJmMHdFUUNBRElBSkJCMnBCQjAwRWYwSFFPeUFDUVFKMGF5Z0NBQVZCK1R3TE5nSUVJQU1nQWpZQ0FFR0dDQ0FERUI0Z0F5Z0NEQ0VDQ3lBRFFSQnFKQUFnQWd0WEFRUi9JQUFvQWdnZ0FDZ0NCR29pQWtIL0FVd0VRQ0FBS0FJQUlnTkJBRXdFUUVFQkR3c0NRQU5BSUFBZ0FXb3RBQXdpQkVIL0FVZEJBQ0FDSUFSTUd3MEJJQUZCQVdvaUFTQURTQTBBQzBFQkR3c0xRUUFMYWdFQmYwRUJJUU1DUUNBQlFRRklCRUJCZnlFRERBRUxBa0FDUUFKQUlBQXRBQUJCQTNGQkFXc09Bd0FBQVFJTFFRSWhBd3dCQzBGOElRTWdBVUVDU0EwQklBQXRBQUZCUDNFaEF3dEJmQ0FBSUFJUU9pQURiQ0lBSUFCQkdXd2dBa0VEYkVvYkR3c2dBd3NRQUNNQUlBQnJRWEJ4SWdBa0FDQUFDd1lBSUFBa0FBc0VBQ01BQzRNQkFnTi9BWDRDUUNBQVFvQ0FnSUFRVkFSQUlBQWhCUXdCQ3dOQUlBRkJBV3NpQVNBQUlBQkNDb0FpQlVJS2ZuMm5RVEJ5T2dBQUlBQkMvLy8vLzU4QlZpRUNJQVVoQUNBQ0RRQUxDeUFGcHlJQ0JFQURRQ0FCUVFGcklnRWdBaUFDUVFwdUlnTkJDbXhyUVRCeU9nQUFJQUpCQ1VzaEJDQURJUUlnQkEwQUN3c2dBUXN0QUNBQVVFVUVRQU5BSUFGQkFXc2lBU0FBcDBFSGNVRXdjam9BQUNBQVFnT0lJZ0JDQUZJTkFBc0xJQUVMTlFBZ0FGQkZCRUFEUUNBQlFRRnJJZ0VnQUtkQkQzRkJnUGdCYWkwQUFDQUNjam9BQUNBQVFnU0lJZ0JDQUZJTkFBc0xJQUVMVmdFQmZ5TUFRVEJySWdJa0FDQUFLQUlFR2lBQUtBSUFHaUFDSUFFMkFpd0NmeUFDSUFJb0Fpd2lBVUVFYWpZQ0xFRi9JQUVvQWdBaUFVVU5BQm9nQVNBQUtBSU1OZ0lBUVFBTElRRWdBa0V3YWlRQUlBRUx4d0lCQTM4akFFSFFBV3NpQXlRQUlBTWdBallDekFGQkFDRUNJQU5Cb0FGcVFRQkJLQkFGR2lBRElBTW9Bc3dCTmdMSUFRSkFRUUFnQVNBRFFjZ0JhaUFEUWRBQWFpQURRYUFCYWhBc1FRQklEUUFnQUNnQ1RFRUFUaUVDSUFBb0FnQWhCQ0FBTEFCS1FRQk1CRUFnQUNBRVFWOXhOZ0lBQ3lBRVFTQnhJUVVDZnlBQUtBSXdCRUFnQUNBQklBTkJ5QUZxSUFOQjBBQnFJQU5Cb0FGcUVDd01BUXNnQUVIUUFEWUNNQ0FBSUFOQjBBQnFOZ0lRSUFBZ0F6WUNIQ0FBSUFNMkFoUWdBQ2dDTENFRUlBQWdBellDTENBQUlBRWdBMEhJQVdvZ0EwSFFBR29nQTBHZ0FXb1FMQ0FFUlEwQUdpQUFRUUJCQUNBQUtBSWtFUUFBR2lBQVFRQTJBakFnQUNBRU5nSXNJQUJCQURZQ0hDQUFRUUEyQWhBZ0FDZ0NGQm9nQUVFQU5nSVVRUUFMR2lBQUlBQW9BZ0FnQlhJMkFnQWdBa1VOQUFzZ0EwSFFBV29rQUF1cEFRRURmd0pBSUFFZ0FpZ0NFQ0lFQkg4Z0JBVWdBaENOQVEwQklBSW9BaEFMSUFJb0FoUWlCV3RMQkVBZ0FpQUFJQUVnQWlnQ0pCRUFBQm9QQ3dKQUlBSXNBRXRCQUVnTkFDQUJJUVFEUUNBRUlnTkZEUUVnQUNBRFFRRnJJZ1JxTFFBQVFRcEhEUUFMSUFJZ0FDQURJQUlvQWlRUkFBQWdBMGtOQVNBQUlBTnFJUUFnQVNBRGF5RUJJQUlvQWhRaEJRc2dCU0FBSUFFUUJCb2dBaUFDS0FJVUlBRnFOZ0lVQ3d0WkFRRi9JQUFnQUMwQVNpSUJRUUZySUFGeU9nQktJQUFvQWdBaUFVRUljUVJBSUFBZ0FVRWdjallDQUVGL0R3c2dBRUlBTndJRUlBQWdBQ2dDTENJQk5nSWNJQUFnQVRZQ0ZDQUFJQUVnQUNnQ01HbzJBaEJCQUF1TEFnQUNRQ0FBQkg4Z0FVSC9BRTBOQVFKQVFkVDZBU2dDQUNnQ0FFVUVRQ0FCUVlCL2NVR0F2d05HRFFNTUFRc2dBVUgvRDAwRVFDQUFJQUZCUDNGQmdBRnlPZ0FCSUFBZ0FVRUdka0hBQVhJNkFBQkJBZzhMSUFGQmdMQURUMEVBSUFGQmdFQnhRWURBQTBjYlJRUkFJQUFnQVVFL2NVR0FBWEk2QUFJZ0FDQUJRUXgyUWVBQmNqb0FBQ0FBSUFGQkJuWkJQM0ZCZ0FGeU9nQUJRUU1QQ3lBQlFZQ0FCR3RCLy84L1RRUkFJQUFnQVVFL2NVR0FBWEk2QUFNZ0FDQUJRUkoyUWZBQmNqb0FBQ0FBSUFGQkJuWkJQM0ZCZ0FGeU9nQUNJQUFnQVVFTWRrRS9jVUdBQVhJNkFBRkJCQThMQzBHYyt3RkJHVFlDQUVGL0JVRUJDdzhMSUFBZ0FUb0FBRUVCQzdvQkFRRi9JQUZCQUVjaEFnSkFBa0FDUUNBQlJRMEFJQUJCQTNGRkRRQURRQ0FBTFFBQVJRMENJQUJCQVdvaEFDQUJRUUZySWdGQkFFY2hBaUFCUlEwQklBQkJBM0VOQUFzTElBSkZEUUVMQWtBZ0FDMEFBRVVOQUNBQlFRUkpEUUFEUUNBQUtBSUFJZ0pCZjNNZ0FrR0Jnb1FJYTNGQmdJR0NoSGh4RFFFZ0FFRUVhaUVBSUFGQkJHc2lBVUVEU3cwQUN3c2dBVVVOQUFOQUlBQXRBQUJGQkVBZ0FBOExJQUJCQVdvaEFDQUJRUUZySWdFTkFBc0xRUUFMQkFCQ0FBc0VBRUVBQy9vQ0FRZC9Jd0JCSUdzaUF5UUFJQU1nQUNnQ0hDSUZOZ0lRSUFBb0FoUWhCQ0FESUFJMkFod2dBeUFCTmdJWUlBTWdCQ0FGYXlJQk5nSVVJQUVnQW1vaEJVRUNJUWNnQTBFUWFpRUJBbjhDUUFKQUFuOUJBQ0FBS0FJOElBTkJFR3BCQWlBRFFReHFFQUFpQkVVTkFCcEJuUHNCSUFRMkFnQkJmd3RGQkVBRFFDQUZJQU1vQWd3aUJFWU5BaUFFUVg5TURRTWdBU0FFSUFFb0FnUWlDRXNpQmtFRGRHb2lDU0FFSUFoQkFDQUdHMnNpQ0NBSktBSUFhallDQUNBQlFReEJCQ0FHRzJvaUNTQUpLQUlBSUFock5nSUFJQVVnQkdzaEJRSi9RUUFnQUNnQ1BDQUJRUWhxSUFFZ0Joc2lBU0FISUFacklnY2dBMEVNYWhBQUlnUkZEUUFhUVp6N0FTQUVOZ0lBUVg4TFJRMEFDd3NnQlVGL1J3MEJDeUFBSUFBb0Fpd2lBVFlDSENBQUlBRTJBaFFnQUNBQklBQW9BakJxTmdJUUlBSU1BUXNnQUVFQU5nSWNJQUJDQURjREVDQUFJQUFvQWdCQklISTJBZ0JCQUNBSFFRSkdEUUFhSUFJZ0FTZ0NCR3NMSVFBZ0EwRWdhaVFBSUFBTHVBNENFSDhDZkNNQVFiQUVheUlHSkFBZ0FpQUNRUU5yUVJodElnUkJBQ0FFUVFCS0d5SU5RV2hzYWlFSVFmVGRBU2dDQUNJSklBTkJBV3NpQjJwQkFFNEVRQ0FESUFscUlRUWdEU0FIYXlFQ0EwQWdCa0hBQW1vZ0JVRURkR29nQWtFQVNBUjhSQUFBQUFBQUFBQUFCU0FDUVFKMFFZRGVBV29vQWdDM0N6a0RBQ0FDUVFGcUlRSWdCVUVCYWlJRklBUkhEUUFMQ3lBSVFSaHJJUXBCQUNFRUlBbEJBQ0FKUVFCS0d5RUZJQU5CQVVnaEN3TkFBa0FnQ3dSQVJBQUFBQUFBQUFBQUlSUU1BUXNnQkNBSGFpRU1RUUFoQWtRQUFBQUFBQUFBQUNFVUEwQWdGQ0FBSUFKQkEzUnFLd01BSUFaQndBSnFJQXdnQW10QkEzUnFLd01Bb3FBaEZDQUNRUUZxSWdJZ0EwY05BQXNMSUFZZ0JFRURkR29nRkRrREFDQUVJQVZHSVFJZ0JFRUJhaUVFSUFKRkRRQUxRUzhnQ0dzaEVFRXdJQWhySVE0Z0NFRVpheUVSSUFraEJBSkFBMEFnQmlBRVFRTjBhaXNEQUNFVVFRQWhBaUFFSVFVZ0JFRUJTQ0lIUlFSQUEwQWdCa0hnQTJvZ0FrRUNkR29DZnlBVUFuOGdGRVFBQUFBQUFBQndQcUlpRkpsRUFBQUFBQUFBNEVGakJFQWdGS29NQVF0QmdJQ0FnSGdMdHlJVVJBQUFBQUFBQUhEQm9xQWlGWmxFQUFBQUFBQUE0RUZqQkVBZ0Zhb01BUXRCZ0lDQWdIZ0xOZ0lBSUFZZ0JVRUJheUlGUVFOMGFpc0RBQ0FVb0NFVUlBSkJBV29pQWlBRVJ3MEFDd3NDZnlBVUlBb1FGQ0lVSUJSRUFBQUFBQUFBd0QraW5FUUFBQUFBQUFBZ3dLS2dJaFNaUkFBQUFBQUFBT0JCWXdSQUlCU3FEQUVMUVlDQWdJQjRDeUVMSUJRZ0M3ZWhJUlFDUUFKQUFrQUNmeUFLUVFGSUloSkZCRUFnQkVFQ2RDQUdhaUlDSUFJb0F0d0RJZ0lnQWlBT2RTSUNJQTUwYXlJRk5nTGNBeUFDSUF0cUlRc2dCU0FRZFF3QkN5QUtEUUVnQkVFQ2RDQUdhaWdDM0FOQkYzVUxJZ3hCQVVnTkFnd0JDMEVDSVF3Z0ZFUUFBQUFBQUFEZ1AyWkJBWE5GRFFCQkFDRU1EQUVMUVFBaEFrRUFJUVVnQjBVRVFBTkFJQVpCNEFOcUlBSkJBblJxSWhNb0FnQWhEMEgvLy84SElRY0Nmd0pBSUFVTkFFR0FnSUFJSVFjZ0R3MEFRUUFNQVFzZ0V5QUhJQTlyTmdJQVFRRUxJUVVnQWtFQmFpSUNJQVJIRFFBTEN3SkFJQklOQUFKQUFrQWdFUTRDQUFFQ0N5QUVRUUowSUFacUlnSWdBaWdDM0FOQi8vLy9BM0UyQXR3RERBRUxJQVJCQW5RZ0Jtb2lBaUFDS0FMY0EwSC8vLzhCY1RZQzNBTUxJQXRCQVdvaEN5QU1RUUpIRFFCRUFBQUFBQUFBOEQ4Z0ZLRWhGRUVDSVF3Z0JVVU5BQ0FVUkFBQUFBQUFBUEEvSUFvUUZLRWhGQXNnRkVRQUFBQUFBQUFBQUdFRVFFRUFJUVVDUUNBSklBUWlBazROQUFOQUlBWkI0QU5xSUFKQkFXc2lBa0VDZEdvb0FnQWdCWEloQlNBQ0lBbEtEUUFMSUFWRkRRQWdDaUVJQTBBZ0NFRVlheUVJSUFaQjRBTnFJQVJCQVdzaUJFRUNkR29vQWdCRkRRQUxEQU1MUVFFaEFnTkFJQUlpQlVFQmFpRUNJQVpCNEFOcUlBa2dCV3RCQW5ScUtBSUFSUTBBQ3lBRUlBVnFJUVVEUUNBR1FjQUNhaUFESUFScUlnZEJBM1JxSUFSQkFXb2lCQ0FOYWtFQ2RFR0EzZ0ZxS0FJQXR6a0RBRUVBSVFKRUFBQUFBQUFBQUFBaEZDQURRUUZPQkVBRFFDQVVJQUFnQWtFRGRHb3JBd0FnQmtIQUFtb2dCeUFDYTBFRGRHb3JBd0Npb0NFVUlBSkJBV29pQWlBRFJ3MEFDd3NnQmlBRVFRTjBhaUFVT1FNQUlBUWdCVWdOQUFzZ0JTRUVEQUVMQ3dKQUlCUkJHQ0FJYXhBVUloUkVBQUFBQUFBQWNFRm1RUUZ6UlFSQUlBWkI0QU5xSUFSQkFuUnFBbjhnRkFKL0lCUkVBQUFBQUFBQWNENmlJaFNaUkFBQUFBQUFBT0JCWXdSQUlCU3FEQUVMUVlDQWdJQjRDeUlDdDBRQUFBQUFBQUJ3d2FLZ0loU1pSQUFBQUFBQUFPQkJZd1JBSUJTcURBRUxRWUNBZ0lCNEN6WUNBQ0FFUVFGcUlRUU1BUXNDZnlBVW1VUUFBQUFBQUFEZ1FXTUVRQ0FVcWd3QkMwR0FnSUNBZUFzaEFpQUtJUWdMSUFaQjRBTnFJQVJCQW5ScUlBSTJBZ0FMUkFBQUFBQUFBUEEvSUFnUUZDRVVBa0FnQkVGL1RBMEFJQVFoQWdOQUlBWWdBa0VEZEdvZ0ZDQUdRZUFEYWlBQ1FRSjBhaWdDQUxlaU9RTUFJQlJFQUFBQUFBQUFjRDZpSVJRZ0FrRUFTaUVBSUFKQkFXc2hBaUFBRFFBTFFRQWhCeUFFUVFCSURRQWdDVUVBSUFsQkFFb2JJUUFnQkNFRkEwQWdBQ0FISUFBZ0Iwa2JJUU1nQkNBRmF5RUlRUUFoQWtRQUFBQUFBQUFBQUNFVUEwQWdGQ0FDUVFOMFFkRHpBV29yQXdBZ0JpQUNJQVZxUVFOMGFpc0RBS0tnSVJRZ0FpQURSeUVLSUFKQkFXb2hBaUFLRFFBTElBWkJvQUZxSUFoQkEzUnFJQlE1QXdBZ0JVRUJheUVGSUFRZ0IwY2hBaUFIUVFGcUlRY2dBZzBBQ3d0RUFBQUFBQUFBQUFBaEZDQUVRUUJPQkVBZ0JDRUNBMEFnRkNBR1FhQUJhaUFDUVFOMGFpc0RBS0FoRkNBQ1FRQktJUUFnQWtFQmF5RUNJQUFOQUFzTElBRWdGSm9nRkNBTUd6a0RBQ0FHS3dPZ0FTQVVvU0VVUVFFaEFpQUVRUUZPQkVBRFFDQVVJQVpCb0FGcUlBSkJBM1JxS3dNQW9DRVVJQUlnQkVjaEFDQUNRUUZxSVFJZ0FBMEFDd3NnQVNBVW1pQVVJQXdiT1FNSUlBWkJzQVJxSkFBZ0MwRUhjUXZNQ1FNRmZ3RitCSHdqQUVFd2F5SUVKQUFDUUFKQUFrQWdBTDBpQjBJZ2lLY2lBa0gvLy8vL0IzRWlBMEg2MUwyQUJFMEVRQ0FDUWYvL1AzRkIrOE1rUmcwQklBTkIvTEtMZ0FSTkJFQWdCMElBV1FSQUlBRWdBRVFBQUVCVSt5SDV2NkFpQUVReFkySWFZYlRRdmFBaUNEa0RBQ0FCSUFBZ0NLRkVNV05pR21HMDBMMmdPUU1JUVFFaEFnd0ZDeUFCSUFCRUFBQkFWUHNoK1QrZ0lnQkVNV05pR21HMDBEMmdJZ2c1QXdBZ0FTQUFJQWloUkRGallocGh0TkE5b0RrRENFRi9JUUlNQkFzZ0IwSUFXUVJBSUFFZ0FFUUFBRUJVK3lFSndLQWlBRVF4WTJJYVliVGd2YUFpQ0RrREFDQUJJQUFnQ0tGRU1XTmlHbUcwNEwyZ09RTUlRUUloQWd3RUN5QUJJQUJFQUFCQVZQc2hDVUNnSWdCRU1XTmlHbUcwNEQyZ0lnZzVBd0FnQVNBQUlBaWhSREZqWWhwaHRPQTlvRGtEQ0VGK0lRSU1Bd3NnQTBHN2pQR0FCRTBFUUNBRFFiejcxNEFFVFFSQUlBTkIvTExMZ0FSR0RRSWdCMElBV1FSQUlBRWdBRVFBQURCL2ZOa1N3S0FpQUVUS2xKT25rUTdwdmFBaUNEa0RBQ0FCSUFBZ0NLRkV5cFNUcDVFTzZiMmdPUU1JUVFNaEFnd0ZDeUFCSUFCRUFBQXdmM3paRWtDZ0lnQkV5cFNUcDVFTzZUMmdJZ2c1QXdBZ0FTQUFJQWloUk1xVWs2ZVJEdWs5b0RrRENFRjlJUUlNQkFzZ0EwSDd3K1NBQkVZTkFTQUhRZ0JaQkVBZ0FTQUFSQUFBUUZUN0lSbkFvQ0lBUkRGallocGh0UEM5b0NJSU9RTUFJQUVnQUNBSW9VUXhZMklhWWJUd3ZhQTVBd2hCQkNFQ0RBUUxJQUVnQUVRQUFFQlUreUVaUUtBaUFFUXhZMklhWWJUd1BhQWlDRGtEQUNBQklBQWdDS0ZFTVdOaUdtRzA4RDJnT1FNSVFYd2hBZ3dEQ3lBRFFmckQ1SWtFU3cwQkN5QUJJQUFnQUVTRHlNbHRNRi9rUDZKRUFBQUFBQUFBT0VPZ1JBQUFBQUFBQURqRG9DSUpSQUFBUUZUN0lmbS9vcUFpQ0NBSlJERmpZaHBodE5BOW9pSUxvU0lBT1FNQUlBTkJGSFlpQlNBQXZVSTBpS2RCL3c5eGEwRVJTQ0VEQW44Z0NabEVBQUFBQUFBQTRFRmpCRUFnQ2FvTUFRdEJnSUNBZ0hnTElRSUNRQ0FERFFBZ0FTQUlJQWxFQUFCZ0dtRzAwRDJpSWdDaElnb2dDVVJ6Y0FNdWlobWpPNklnQ0NBS29TQUFvYUVpQzZFaUFEa0RBQ0FGSUFDOVFqU0lwMEgvRDNGclFUSklCRUFnQ2lFSURBRUxJQUVnQ2lBSlJBQUFBQzZLR2FNN29pSUFvU0lJSUFsRXdVa2dKWnFEZXptaUlBb2dDS0VnQUtHaElndWhJZ0E1QXdBTElBRWdDQ0FBb1NBTG9Ua0RDQXdCQ3lBRFFZQ0F3UDhIVHdSQUlBRWdBQ0FBb1NJQU9RTUFJQUVnQURrRENFRUFJUUlNQVFzZ0IwTC8vLy8vLy8vL0I0TkNnSUNBZ0lDQWdMREJBSVMvSVFCQkFDRUNRUUVoQlFOQUlBUkJFR29nQWtFRGRHb0NmeUFBbVVRQUFBQUFBQURnUVdNRVFDQUFxZ3dCQzBHQWdJQ0FlQXUzSWdnNUF3QWdBQ0FJb1VRQUFBQUFBQUJ3UWFJaEFFRUJJUUlnQlVFQmNTRUdRUUFoQlNBR0RRQUxJQVFnQURrRElBSkFJQUJFQUFBQUFBQUFBQUJpQkVCQkFpRUNEQUVMUVFFaEJRTkFJQVVpQWtFQmF5RUZJQVJCRUdvZ0FrRURkR29yQXdCRUFBQUFBQUFBQUFCaERRQUxDeUFFUVJCcUlBUWdBMEVVZGtHV0NHc2dBa0VCYWhDVEFTRUNJQVFyQXdBaEFDQUhRbjlYQkVBZ0FTQUFtamtEQUNBQklBUXJBd2lhT1FNSVFRQWdBbXNoQWd3QkN5QUJJQUE1QXdBZ0FTQUVLd01JT1FNSUN5QUVRVEJxSkFBZ0FndXZBd0VFZlFKQUlBSUVRRU45SFpBbUlRWWdBMEVCU0FSQVEzMGRrQ1loQlF3Q0MwRUFJUUpEZlIyUUppRUZBMEFnQlNBQUlBSkJBblFpQkdvcUFnQWlCeUFCSUFScUtnSUFJZ2lUSWdVZ0JaU1NJUVVnQmlBSElBaVNJZ1lnQnBTU0lRWWdBa0VCYWlJQ0lBTkhEUUFMREFFTElBTkJBVWdFUUVOOUhaQW1JUVZEZlIyUUppRUdEQUVMUVFBaEFnTkFJQVlnQUNBQ1FRSjBhaW9DQUNJRklBV1VraUVHSUFKQkFXb2lBaUFEUncwQUN5QUdRMzBka0NhU0lRWkJBQ0VDUXdBQUFBQWhCUU5BSUFVZ0FTQUNRUUowYWlvQ0FDSUZJQVdVa2lFRklBSkJBV29pQWlBRFJ3MEFDeUFGUTMwZGtDYVNJUVVMQW4xREFBQUFBQ0FGa1NJSUlBaVVJZ1VnQnBFaUJ5QUhsQ0lHa2tQdmtwTWhYUTBBR2tQYkQ4ay9JQWdnQjVRZ0JTQUdRd1g0M0Q2VWtwUWdCU0FHUXlHeExUK1VraUFGSUFaRFpRbXdQWlNTbEpXVElBVWdCbDVCQVhORkRRQWFJQWdnQjVRZ0JpQUZRd1g0M0Q2VWtwUWdCaUFGUXlHeExUK1VraUFHSUFWRFpRbXdQWlNTbEpWRDJ3L0pQNUpEMncvSnY1SUxRNGY1SWthVVF3QUFBRCtTamlJRmkwTUFBQUJQWFFSQUlBV29Ed3RCZ0lDQWdIZ0w4QUVCQkg4akFDSUhJUW9nQVVFQklBRkJBVW9iSVFnZ0J5QUJRUUowUVE5cVFYQnhheUlISkFCREFBQ0FQeUFISUFFZ0FpQUZFRmVSbFNBR2xDRUdRUUFoQlFOQUlBQWdCVUVDZENJSmFpQUdJQWNnQ1dvb0FnQ3lsRGdDQUNBRlFRRnFJZ1VnQ0VjTkFBc2dBQ0FCUVg4Z0JDQUNJQU1RTDBFQklRSWdCRUVDVGdSQUlBRWdCRzRpQTBFQklBTkJBVW9iSVFoQkFDRUNRUUFoQVFOQUlBRWdBMndoQ1VFQUlRVkJBQ0VBQTBBZ0J5QUZJQWxxUVFKMGFpZ0NBQ0FBY2lFQUlBVkJBV29pQlNBSVJ3MEFDeUFBUVFCSElBRjBJQUp5SVFJZ0FVRUJhaUlCSUFSSERRQUxDeUFLSkFBZ0FndjRBUUVDZnlNQVFSQnJJZ01rQUFKQUFrQUNRQUpBSUFCQi8vd0FUQVJBSUFCQndENUdEUUVnQUVIZzNRQkdEUUVNQWdzZ0FFR0EvUUJHRFFBZ0FFR0E5d0pHRFFBZ0FFSEF1d0ZIRFFFTElBRkJBV3RCQWtrTkFRc2dBa1VOQVNBQ1FYODJBZ0FNQVFzQ2Z5QURRZWpDQURZQ0RFRUFDd1IvUVFBRklBTWdBeWdDREVFRGFrRjhjVFlDRENBREtBSU1RYUE5S0FJQVFRSjBRZURBQUdvZ0FXeEJwRDBvQWdCQkJYUnFha0cwQVdvTEVCVWlCRVVFUUVFQUlRUWdBa1VOQVNBQ1FYazJBZ0FNQVFzZ0JDQUFJQUVRTUNFQUlBSUVRQ0FDSUFBMkFnQUxJQUJGRFFBZ0JCQUlRUUFoQkFzZ0EwRVFhaVFBSUFRTGxBSUNBMzhCZlNNQUlnZ2hDaUFJSUFGQkFuUkJHMnBCY0hGcklnZ2tBRUVCSVFrZ0FDQUJRUUVnQkNBQ0lBTVFMeUFBSUFnZ0FpQUJFSmtCSVF3Z0NDQUJJQUlnQlJCWUlBY0VRQ0FCUVFFZ0FVRUJTaHNoQlVNQUFJQS9JQXlSbFNBR2xDRUdRUUFoQndOQUlBQWdCMEVDZENJTGFpQUdJQWdnQzJvb0FnQ3lsRGdDQUNBSFFRRnFJZ2NnQlVjTkFBc2dBQ0FCUVg4Z0JDQUNJQU1RTHdzZ0JFRUNUZ1JBSUFFZ0JHNGlBRUVCSUFCQkFVb2JJUUpCQUNFSlFRQWhBUU5BSUFBZ0FXd2hBMEVBSVFkQkFDRUZBMEFnQ0NBRElBZHFRUUowYWlnQ0FDQUZjaUVGSUFkQkFXb2lCeUFDUncwQUN5QUZRUUJISUFGMElBbHlJUWtnQVVFQmFpSUJJQVJIRFFBTEN5QUtKQUFnQ1F2ekJRSUlmd2Q5SXdBaUJDRUtJQVFnQTBFQ2RFRVBha0Z3Y1NJRWF5SUZJZ2NrQUNBSElBUnJJZ2trQUNBRlFRQWdBMEVCSUFOQkFVb2JJZ2hCQW5RUUJTRUhRUUFoQkFOQUlBa2dCRUVDZENJRmFpQUFJQVZxSWdZcUFnQWlERU1BQUFBQVhUWUNBQ0FHSUF5TE9BSUFJQUVnQldwQkFEWUNBQ0FFUVFGcUlnUWdDRWNOQUF0REFBQUFBQ0VNSUFOQkFYVWdBa2dFUUVFQUlRUURRQ0FNSUFBZ0JFRUNkR29xQWdDU0lRd2dCRUVCYWlJRUlBaEhEUUFMSUFLeVE4M01URCtTUXdBQWdEOGdERU45SFpBbVhrRUJjMFZCQUNBTVF3QUFnRUpkR3dSOUlBd0ZJQUJCZ0lDQS9BTTJBZ0FnQUVFRWFrRUFJQU5CQWlBRFFRSktHMEVDZEVFRWF4QUZHa01BQUlBL0M1V1VJUTlCQUNFRlF3QUFBQUFoREFOQUlBRWdCVUVDZENJRWFnSi9JQThnQUNBRWFpb0NBQ0lRbEk0aURZdERBQUFBVDEwRVFDQU5xQXdCQzBHQWdJQ0FlQXNpQmpZQ0FDQUVJQWRxSUFheUlnMGdEWkk0QWdBZ0RpQVFJQTJVa2lFT0lBSWdCbXNoQWlBTUlBMGdEWlNTSVF3Z0JVRUJhaUlGSUFoSERRQUxDd0pBSUFOQkEyb2dBa2dFUUNBSEtnSUFJUTRnQVNBQktBSUFJQUpxTmdJQUlBd2dBcklpRENBTWxKSWdEaUFNbEpJaERBd0JDeUFDUVFGSURRQWdBMEVDSUFOQkFrb2JJUXNnQUNvQ0FDRVFRUUFoQXdOQUlBeERBQUNBUDVJaUR5QUhLZ0lBa2lFTUlBNGdFSklpRFNBTmxDRU5RUUVoQkVFQUlRVURRQ0FQSUFjZ0JFRUNkQ0lHYWlvQ0FKSWlFU0FNSUF3Z0RpQUFJQVpxS2dJQWtpSU1JQXlVSWhLVUlBMGdFWlJlSWdZYklRd2dFaUFOSUFZYklRMGdCQ0FGSUFZYklRVWdCRUVCYWlJRUlBdEhEUUFMSUFBZ0JVRUNkQ0lFYWlvQ0FDRU5JQVFnQjJvaUJTQUZLZ0lBSWd4REFBQUFRSkk0QWdBZ0FTQUVhaUlFSUFRb0FnQkJBV28yQWdBZ0R5QU1raUVNSUE0Z0RaSWhEaUFEUVFGcUlnTWdBa2NOQUFzTFFRQWhCQU5BSUFFZ0JFRUNkQ0lBYWlJQ0lBSW9BZ0JCQUNBQUlBbHFLQUlBSWdCcmN5QUFhallDQUNBRVFRRnFJZ1FnQ0VjTkFBc2dDaVFBSUF3TC9BSUJCSDhnQUNnQ0hDSURJQU5CQW5ZaUFtc2hBd0pBSUFGRkJFQWdBeUVDREFFTElBQWdBQ2dDSUNBRGFqWUNJQXNnQUNBQ05nSWNJQUpCZ0lDQUJFMEVRQ0FBS0FJZ0lRRURRQUpBSUFGQkYzWWlCVUgvQVVjRVFDQUJRUjkySVFJZ0FDZ0NLQ0lCUVFCT0JFQWdBQ0FBS0FJRUlBQW9BaGdpQXlBQUtBSUlha3NFZnlBQUlBTkJBV28yQWhnZ0FDZ0NBQ0FEYWlBQklBSnFPZ0FBUVFBRlFYOExJQUFvQWl4eU5nSXNDeUFBS0FJa0lnRUVRQ0FDUVFGcklRTURRRUYvSVFJZ0FDQUFLQUlFSUFBb0FoZ2lCQ0FBS0FJSWFrc0VmeUFBSUFSQkFXbzJBaGdnQUNnQ0FDQUVhaUFET2dBQVFRQWhBaUFBS0FJa0JTQUJDMEVCYXlJQk5nSWtJQUFnQUNnQ0xDQUNjallDTENBQkRRQUxDeUFBSUFWQi93RnhOZ0lvSUFBb0Fod2hBaUFBS0FJZ0lRRU1BUXNnQUNBQUtBSWtRUUZxTmdJa0N5QUFJQUpCQ0hRaUFqWUNIQ0FBSUFGQkNIUkJnUDcvL3dkeElnRTJBaUFnQUNBQUtBSVVRUWhxTmdJVUlBSkJnWUNBQkVrTkFBc0xDL2tiQVJsL0l3QWlFQ0VtSUFoQkFDQUlRUUJLR3lJSUlBaEJCMHBCQTNRaUpHc2hGaUFBS0FJSUlSUUNRQ0FOUVFKSERRQWdBaUFCYTBHdzNRRnFMUUFBSWh3Z0Zrb0VRRUVBSVJ3TUFRc2dGaUFjYXlJSUlBaEJCMHBCQTNRaUpXc2hGZ3NnRUNBVVFRSjBRUTlxUVhCeElnaHJJaGtpRUNRQUlCQWdDR3NpR2lJUUpBQWdFQ0FJYXlJYkloQWtBQ0FOUVFOMElSY2dFQ0FJYXlJZEpBQUNRQUpBQWtBZ0FTQUNTQ0lUUlFSQUlBQkJOR29oSGlBQVFTQnFJU0FnQUNnQ01DSWlRUUZySVJFTUFRc2dEa0VEYWlFUklBVWdEbXRCQldzZ0RXd2hGU0FBS0FJZ0lpQWdBVUVCZEdvdkFRQWhFaUFCSVFnRFFDQVNRUkIwSVJBZ0d5QUlRUUowSWhocUlCY2dJQ0FJUVFGcUlnVkJBWFJxTGdFQUloSWdFRUVRZFdzaUVFRURiQ0FPZEVFRGRFRUVkU0llSUJjZ0hrb2JOZ0lBSUJnZ0hXb2dGU0FJUVg5eklBSnFiQ0FRYkNBUmRFRUdkU0FYUVFBZ0VDQU9kRUVCUmh0ck5nSUFJQVVpQ0NBQ1J3MEFDeUFBUVRScUlSNGdBRUVnYWlFZ0lBQW9BakFpSWtFQmF5RVJJQk1OQVFzZ0ZrRUFTQ0VGUVFFaEZRTkFJQlVnRVNBVmFrRUJkU0lJUVFGcUlBVWJJaFVnQ0VFQmF5QVJJQVViSWhGTURRQUxEQUVMSUFBb0FpQWlJeUFDUVFGMGFpOEJBQ0VGSUFBb0FqUWhKMEVCSVJVRFFDQVJJQlZxUVFGMUlpRWdGR3doS0NBRklSQkJBQ0VTUVFBaEV5QUNJUWdEUUNBUVFSQjBRUkIxSUNNZ0NFRUJheUlJUVFGMGFpNEJBQ0lRYXlBTmJDQW5JQWdnS0dwcUxRQUFiQ0FPZENJZlFRSjFJUmdnSDBFRVRnUi9JQjBnQ0VFQ2RHb29BZ0FnR0dvaUdFRUFJQmhCQUVvYkJTQVlDeUFESUFoQkFuUWlIMm9vQWdCcUlSZ0Nmd0pBSUJNTkFDQVlJQnNnSDJvb0FnQk9EUUJCQUNFVFFRQWdGeUFYSUJoS0d3d0JDMEVCSVJNZ0dDQUVJQjlxS0FJQUloOGdHQ0FmU0JzTElCSnFJUklnQVNBSVNBMEFDeUFWSUNGQkFXb2dFaUFXU2lJSUd5SVZJQ0ZCQVdzZ0VTQUlHeUlSVEEwQUN3dEJBQ0VJSUFFaEJRSkFJQUVnQWs0aUl3MEFJQlZCQVdzZ0ZHd2hJU0FnS0FJQUloOGdBVUVCZEdvdkFRQWhFQ0FlS0FJQUlSZ0NRQ0FWSUNKSUJFQWdGQ0FWYkNFaUlBRWlDQ0VGQTBBZ0VFRVFkQ0VSSUI4Z0NFRUJhaUlTUVFGMGFpNEJBQ0lRSUJGQkVIVnJJQTFzSWhNZ0dDQUlJQ0pxYWkwQUFHd2dEblFoRVNBVElCZ2dDQ0FoYW1vdEFBQnNJQTUwSWhSQkFuVWhFeUFVUVFST0JFQWdIU0FJUVFKMGFpZ0NBQ0FUYWlJVFFRQWdFMEVBU2hzaEV3c2dFVUVDZFNFVUlCRkJCRTRFUUNBZElBaEJBblJxS0FJQUlCUnFJaEZCQUNBUlFRQktHeUVVQ3lBWklBaEJBblFpRVdvZ0V5QURJQkZxS0FJQUloNUJBQ0FWUVFGS0cyb2lFellDQUNBUklCcHFJQjRnRkNBVGEyb2lFVUVBSUJGQkFFb2JOZ0lBSUFnZ0JTQWVRUUJLR3lFRklCSWlDQ0FDUncwQUN3d0JDeUFCSWhFaEJRTkFJQkJCRUhRaEVpQVlJQkVnSVdwcUxRQUFJQjhnRVVFQmFpSUlRUUYwYWk0QkFDSVFJQkpCRUhWcklBMXNiQ0FPZENJZVFRSjFJUlFnQkNBUlFRSjBJaE5xS0FJQUlSSWdIa0VFVGdSQUlCTWdIV29vQWdBZ0ZHb2lGRUVBSUJSQkFFb2JJUlFMSUJKQkFVNEVRQ0FUSUIxcUtBSUFJQkpxSWhKQkFDQVNRUUJLR3lFU0N5QVRJQmxxSUJRZ0F5QVRhaWdDQUNJZVFRQWdGVUVCU2h0cUloUTJBZ0FnRXlBYWFpQWVJQklnRkd0cUloSkJBQ0FTUVFCS0d6WUNBQ0FSSUFVZ0hrRUFTaHNoQlNBSUloRWdBa2NOQUFzTFFRQWhDQ0FqRFFBZ0FpRVFRUUFoRXdOQUlCb2dFRUVCYXlJUVFRSjBJaEpxS0FJQVFRRjFJQklnR1dvb0FnQnFJUU1DZndKQUlCTU5BQ0FESUJJZ0cyb29BZ0JPRFFCQkFDRVRRUUFnRnlBRElCZElHd3dCQzBFQklSTWdBeUFFSUJKcUtBSUFJaElnQXlBU1NCc0xJQWhxSVFnZ0FTQVFTQTBBQzBFUVFUQWdDQ0FXU2lJREd5RVZRU0JCd0FBZ0F4c2hGRUVBSVJNZ0FpRVFRUUFoQXdOQUlCb2dFRUVCYXlJUVFRSjBJaEZxS0FJQUlCVnNRUVoxSUJFZ0dXb29BZ0JxSVJJQ2Z3SkFJQU1OQUNBU0lCRWdHMm9vQWdCT0RRQkJBQ0FYSUJJZ0YwZ2JJUkZCQUF3QkN5QVNJQVFnRVdvb0FnQWlBeUFESUJKS0d5RVJRUUVMSVFNZ0VTQVRhaUVUSUFFZ0VFZ05BQXNnQ0NBV1RFRUZkQ0FWSUJNZ0Zrb2lBeHNpSFNBVklCUWdBeHNpRldwQkFYWWhDRUVBSVJBZ0FpRVNRUUFoRXdOQUlCb2dFa0VCYXlJU1FRSjBJaEZxS0FJQUlBaHNRUVoxSUJFZ0dXb29BZ0JxSVFNQ2Z3SkFJQk1OQUNBRElCRWdHMm9vQWdCT0RRQkJBQ0VUUVFBZ0Z5QURJQmRJR3d3QkMwRUJJUk1nQXlBRUlCRnFLQUlBSWhFZ0F5QVJTQnNMSUJCcUlSQWdBU0FTU0EwQUN5QWRJQWdnRUNBV1NpSURHeUlVSUFnZ0ZTQURHeUlWYWtFQmRpRUlRUUFoRUNBQ0lSSkJBQ0VUQTBBZ0dpQVNRUUZySWhKQkFuUWlFV29vQWdBZ0NHeEJCblVnRVNBWmFpZ0NBR29oQXdKL0FrQWdFdzBBSUFNZ0VTQWJhaWdDQUU0TkFFRUFJUk5CQUNBWElBTWdGMGdiREFFTFFRRWhFeUFESUFRZ0VXb29BZ0FpRVNBRElCRklHd3NnRUdvaEVDQUJJQkpJRFFBTElCUWdDQ0FRSUJaS0lnTWJJaFFnQ0NBVklBTWJJaFZxUVFGMklRaEJBQ0VRSUFJaEVrRUFJUk1EUUNBYUlCSkJBV3NpRWtFQ2RDSVJhaWdDQUNBSWJFRUdkU0FSSUJscUtBSUFhaUVEQW44Q1FDQVREUUFnQXlBUklCdHFLQUlBVGcwQVFRQWhFMEVBSUJjZ0F5QVhTQnNNQVF0QkFTRVRJQU1nQkNBUmFpZ0NBQ0lSSUFNZ0VVZ2JDeUFRYWlFUUlBRWdFa2dOQUFzZ0ZDQUlJQkFnRmtvaUF4c2lGQ0FJSUJVZ0F4dHFRUUYySVJGQkFDRVFJQUloRWtFQUlSTURRQ0FhSUJKQkFXc2lFa0VDZENJSWFpZ0NBQ0FSYkVFR2RTQUlJQmxxS0FJQWFpRURBbjhDUUNBVERRQWdBeUFJSUJ0cUtBSUFUZzBBUVFBaEUwRUFJQmNnQXlBWFNCc01BUXRCQVNFVElBTWdCQ0FJYWlnQ0FDSUlJQU1nQ0VnYkN5QVFhaUVRSUFFZ0VrZ05BQXNnRkNBUklCQWdGa29iSVJFZ0FpRVFRUUFoQ0VFQUlSTURRQ0FLSUJCQkFXc2lFRUVDZENJRGFpQURJQmxxS0FJQUlBTWdHbW9vQWdBZ0VXeEJCblZxSWhJZ0VrRUFJQmNnRWlBWFNCc2dFaUFESUJ0cUtBSUFUaUlTR3lBVEd5SVZJQU1nQkdvb0FnQWlBeUFESUJWS0d5SUROZ0lBSUFNZ0NHb2hDQ0FTSUJOeUlSTWdBU0FRU0EwQUN3c2dCZ0ovQWtBQ1FBSi9JQVVnQWtFQmF5SVRUZ1JBSUFJaEVTQWNJUkFnRmlBa2Fnd0JDeUFYUVFocUlRTWdBaUVTQWtBQ1FBTkFJQ0FvQWdBaUVDQVNRUUYwYWk0QkFDSVZJQkFnRXlJUlFRRjBhaTRCQUNJVGF5QVdJQWhySWhvZ0ZTQVFJQUZCQVhScUxnRUFJaEJyYmlJZGJDQUtJQkZCQW5RaUdHb2lHU2dDQUNJVWFpQVFJQlZySUIxc0lCcHFJQkFnRTJ0cUloQkJBQ0FRUVFCS0cyb2lFeUFZSUJ0cUtBSUFJaEFnQXlBRElCQklHMDRFUUNBUFFRRVFCZzBDSUJOQkNHc2hFeUFaS0FJQUlSUWdDRUVJYWlFSUN5QWNJaEJCQVU0RVFDQVJJQUZyUWJEZEFXb3RBQUFoRUFzZ0dVRUFJQmNnRXlBWFNCc2lFallDQUNBSUlCUWdIR3BySUJKcUlCQnFJUWdnRUNFY0lCRWlFa0VCYXlJVElBVktEUUFMREFFTElCeEJBRW9OQWd3REN5QVdJQ1JxQ3lFV0lCQkJBRXdFUUNBUklSSU1BZ3NnRVNFU0N5QVBJQklnQVd0QkFXb1FGaUFCYWd3QkMwRUFDeUlETmdJQVFRQWdKU0FCSUFOSUd5RUZBa0FDUUNBbFJRMEFJQUVnQTA0TkFDQUhJQTlCQVJBR05nSUFEQUVMSUFkQkFEWUNBQXNnRFVFQlNpRWJJQllnQ0dzZ0JXb2lDQ0FnS0FJQUlod2dFa0VCZEdvdUFRQWlEeUFjSUFGQkFYUnFMZ0VBSWhOcmJpRUZRUUFoQXlBQklCSklCRUFnRGtFRGRDRVpJQk1nRDJzZ0JXd2dDR29oQ0NBVElSQWdBU0VSQTBBZ0VFRVFkQ0VESUFvZ0VVRUNkR29pRHlBUEtBSUFJQndnRVVFQmFpSVJRUUYwYWk0QkFDSVFJQU5CRUhWcklBVnNhallDQUNBUklCSkhEUUFMSUJNaEVDQUJJUkVEUUNBUVFSQjBJUU1nQ2lBUlFRSjBhaUlGSUFnZ0hDQVJRUUZxSWhGQkFYUnFMZ0VBSWhBZ0EwRVFkV3NpQXlBRElBaEtHeUlESUFVb0FnQnFOZ0lBSUFnZ0Eyc2hDQ0FSSUJKSERRQUxRUVJCQXlBTlFRRktHeUVhUVFBZ0RVRURkR3NoSFVFQUlRTURRQ0FUUVJCMElSQWdDaUFCUVFKMElnOXFJaEVvQWdBZ0Eyb2hCUUpBSUJ3Z0FVRUJhaUlJUVFGMGFpNEJBQ0lUSUJCQkVIVnJJQTUwSWhaQkFrNEVRRUVBSVJVZ0VTQUZJQVVnQkNBUGFpZ0NBR3NpQlVFQUlBVkJBRW9iSWdWckloUTJBZ0FnRFNBV2JDRVFBa0FnRFVFQ1J3MEFJQlpCQWtZTkFDQUhLQUlBRFFBZ0FTQUdLQUlBU0NFVkN3SkFJQkFnRldvaUVFRURkQ0lWUVFKMVFRQWdGa0VDUmhzZ0VFRnJiR29nR1NBQUtBSTRJQUZCQVhScUxnRUFhaUFRYkNJV1FRRjFhaUlCSUJScUlpQWdFRUVFZEVnRVFDQUJJQlpCQW5WcUlRRU1BUXNnSUNBUVFSaHNUZzBBSUFFZ0ZrRURkV29oQVFzZ0N5QVBhaUlXSUJCQkFuUWdGR29nQVdvaUZFRUFJQlJCQUVvYklCQnVRUU4ySWhBMkFnQWdEU0FRYkNBUktBSUFJaFJCQTNWS0JFQWdGaUFVSUJ0MVFRTjFJaEEyQWdBTElCWWdFRUVJSUJCQkNFZ2JJaEEyQWdBZ0RDQVBhaUFSS0FJQUlBRnFJQkFnRld4TU5nSUFJQkVnRVNnQ0FDQWRJQllvQWdCc2FqWUNBQXdCQ3lBUklBVWdCU0FYYXlJQlFRQWdBVUVBU2hzaUJXczJBZ0FnQ3lBUGFrRUFOZ0lBSUF3Z0QycEJBVFlDQUFzZ0JRUi9JQXNnRDJvaUFTQUZJQnAySWhCQkNDQUJLQUlBSWdGckloRWdFQ0FSU0JzaUVDQUJhallDQUNBTUlBOXFJQkFnRjJ3aUFTQUZJQU5yVGpZQ0FDQUZJQUZyQlVFQUN5RURJQWdpQVNBU1J3MEFDeUFTSVFFTElBa2dBellDQUNBQklBSklCRUFEUUNBTElBRkJBblFpQUdvaUF5QUFJQXBxSWdRb0FnQWdHM1ZCQTNVMkFnQWdCRUVBTmdJQUlBQWdER29nQXlnQ0FFRUJTRFlDQUNBQlFRRnFJZ0VnQWtjTkFBc0xJQ1lrQUNBU0N6d0JBWDhnQUNBQUtBSWNRUTkySWdFMkFpUWdBQ2dDSUNBQmJpSUFRWDl6UVlDQUFtcEJBQ0FBUVFGcUlnQkJnSUFDYXlJQklBQWdBVWtiYWd1WEFRRUVmeUFCSUFKSUJFQWdCa0VCSUFaQkFVb2JJUWdEUUVFQUlRWWdCQ0FCUVFKMGFpSUpLQUlBSWdkQkFVNEVRQU5BSUFVZ0J4QUpJUWNnQXlBQUtBSUlJQVpzSUFGcVFRSjBhaUlLSUFvcUFnQWdCN0pEQUFBQVA1SkJBVUVPSUFrb0FnQWlCMnQwc3BSREFBQ0FPSlJEQUFBQXY1S1NPQUlBSUFaQkFXb2lCaUFJUncwQUN3c2dBVUVCYWlJQklBSkhEUUFMQ3d2eEFnSUhmd1I5SXdCQkVHc2lDU1FBSUFsQ0FEY0RDQUo5SUFRRVFFTUFtQmsrREFFTElBZEJBblFpQ0VHQTNRRnFLZ0lBSVE4Z0NFR1EzUUZxS2dJQUN5RVJJQUVnQWtnRVFDQUdRUUVnQmtFQlNoc2hDaUFGS0FJRVFRTjBRU0JxSVFzZ0IwSFVBR3dnQkVFcWJHcEJzTm9CYWlFSEEwQWdCeUFCUVJRZ0FVRVVTQnRCQVhRaUJHb2hEQ0FISUFSQkFYSnFJUTFCQUNFRUEwQUNmeUFMSUFVb0FoUnJJQVVvQWh4bmF5SUlRUTlPQkVBZ0JTQU1MUUFBUVFkMElBMHRBQUJCQm5RUVhRd0JDeUFJUVFKT0JFQWdCVUdnM1FGQkFoQURJZ1pCQVhWQkFDQUdRUUZ4YTNNTUFRdEJmeUFJUVFGSERRQWFRUUFnQlVFQkVBWnJDeUVHSUFNZ0FDZ0NDQ0FFYkNBQmFrRUNkR29pQ0NBSlFRaHFJQVJCQW5ScUlnNHFBZ0FpRWlBUElBZ3FBZ0JEQUFBUXdaZVVraUFHc2lJUWtqZ0NBQ0FPSUJJZ0VKSWdFU0FRbEpNNEFnQWdCRUVCYWlJRUlBcEhEUUFMSUFGQkFXb2lBU0FDUncwQUN3c2dDVUVRYWlRQUMyc0JBbjhDUUVHUSt3RW9BZ0FpQUFSQUlBQVFDRUdRK3dGQkFEWUNBQXdCQzBHVSt3RW9BZ0FpQUVVTkFDQUFFQWhCbFBzQlFRQTJBZ0FMUVpqN0FTZ0NBQ0lCQkVBRFFDQUJLQUlBRUFnZ0FTZ0NCQ0VBSUFFUUNDQUFJZ0VOQUF0Qm1Qc0JRUUEyQWdBTEN3dXM2QUUzQUVHQkNBdm5BUVFCQWdNRlJtRnBiR1ZrSUhSdklHTnlaV0YwWlNCUFVGVlRJR1JsWTI5a1pYSXNJR052WkdVNklDVmtJQ2NsY3ljdUFFWmhhV3hsWkNCMGJ5QmtaV052WkdVZ1QzQjFjeUJrWVhSaExDQnBibkIxZENBbGNDQWxaQ3dnYjNWMGNIVjBJQ1Z3SUNWa0xnQkRZVzRuZENCbWNtVmxJSFZ1ZEhKaFkydGxaQ0JpZFdabVpYSWdKWEF1QUFBQUFBQUFBQThJQndRTERBTUNEUW9GQmdrT0FRQUpCZ01FQlFnQkFnZTRmcHA1bW5sbVpyaCtNM01BQUFZQUFBQUVBQUFBQXdBQUFBQUJBQUFBQVFBQUFBQUFBQUFBQWY4Qi93TCtBdjREL1FBQkFBSC9BdjhDL2dQK0F3QkI4UWtMMVFFQy8vLy9BQUFCQVFBQkFBRUFBQUFBQUFFQUFBQUFBQUVBQUFBQkFBQUFBQUQvQWdFQUFRRUFBUC8vQUFBQUFBQUFBZjhBQWY4QS93SCtBdjcrQXYwQ0EvMzhBL3dFQlBzRit2c0crUVlGQ1BjQUFBRUFBQUFBQUFBQS93RUFBQUgvQUFILy93SC9BZ0gvQXY3K0F2NENBZ1A5QUFFQUFBQUFBQUFCQUFFQUFBSC9BUUFBQWdIL0F2Ly9BdjhDQXY4RC92NytBd0FCQUFBQkFBSC9BdjhDL3dJRC9nUCsvZ1FFL1FYOS9BYjhCZ1g3Q1ByNytRa0dBQU1BQndNQUFRb0FBZ1lTQ2d3RUFBSUFBQUFKQkFjRUFBTU1Cd2NBUWRBTEM1SVFLcS9WeWMvL1FBQVJBR1AvWVFFUS9xTUFKeXU5VnRuL0JnQmJBRmIvdWdBWEFJRDh3QmpZVGUzLzNQOW1BS2YvNlA5SUFVbjhDQW9sUGdBQUFBQUFBSWZIUGNsQUFJQUFodjhrQURZQkFQMUlBak1rUlVVTUFJQUFFZ0J5L3lBQmkvK2YvQnNRZXpnQUFBQUFBQUFBQUdnQ0RjajIveWNBT2dEUy82ei9lQUM0QU1YKzQvMEVCUVFWUUNNQUFBQUE1ajdHeFBQL0FBQVVBQm9BQlFEaC85WC8vUDlCQUZvQUJ3Qmovd2ovMVA5UkFpOEdOQXJIREFBQUFBQUFBQUFBNUZjRnhRTUE4di9zLy9IL0FnQVpBQ1VBR1FEdy83bi9sZit4L3pJQUpBRnZBdFlEQ0FXNEJRQUFBQUFBQUFBQWxHdG54QkVBREFBSUFBRUE5di9xLytMLzRQL3Evd01BTEFCa0FLZ0E4d0E5QVgwQnJRSEhBUUFBQUFBQUFBQUF2UUNvL1drQ1ozZDFBR0gvMHZzSWREUUEzUUNvOW5SdS9QOFJBdXJ5NVdiUS8vWUNqUENsWGJEL2lRTjE3d1pUbmYvTUE0THZaa2VWLzhjRGkvQW5PNW4vZ0FOaDhxNHVwZjhGQTgvMFhpSzUvMk1Db2ZlWUZ0TC9xUUdoK3JRTEFDRCtIL1lmNmgvWUg4SWZxQitJSDJJZk9oOEtIOWdlb0I1aUhpSWUzQjJRSFVJZDdoeVdIRG9jMkJ0eUd3b2JuQm9xR3JRWk9obThHRHdZdGhjdUY2QVdFQlorRmVnVVRoU3dFeEFUYmhMSUVSNFJkQkRHRHhZUFpBNnVEZmdNUUF5RUM4Z0tDZ3BLQ1lvSXhnY0NCejRHZUFXeUJPb0RJZ05hQXBJQnlnQUFBRGIvYnY2bS9kNzhGdnhPKzRqNnd2bisrRHI0ZHZlMjl2YjFPUFY4OU1EekNQTlM4cHp4NnZBNjhJenY0dTQ0N3BMdDhPeFE3TExyR091QzZ2RHBZT25TNkVyb3hPZEU1OGJtVE9iVzVXVGw5dVNPNUNqa3h1TnE0eExqdnVKdzRpVGkzdUdlNFdEaEtPSDI0TWJnbnVCNDRGamdQdUFvNEJiZ0N1QUM0QURnczJNQVJ6Z3JIaFVNQmdBQUFBREhwWkI4YldCVVJ6MHpLaUFYRHdnQThlSFR4N3V2cEptT2hIdHlhV0JZVUVoQU9USXNKaUVkR0JRUURBa0ZBZ0JWQ0FBQVlBZ0FBSEFJQUFBQUFBQUFCQVlZQndVQUFBSUFBQXdjS1EzODl3OHFHUTRCL2o0cDkvWWxRZndEK2dSQ0IvZ1FEaWI5SVFBQUFBQUFBQUFBRFJZbkZ3ei9KRUFiK3ZrS055c1JBUUVJQVFFRzlVbzE5L1EzVFBRSS9RTmRHL3dhSnpzRCtBSUFUUXNKK0JZcytnY29DUm9EQ2ZrVVpma0VBL2dxR2dEeElVUUNGLzQzTHY0UEEvOFZFQ242R3owbkJmVXFXQVFCL2p4QkJ2ei8rMGs0QWZjVFhoMzNBQXhqQmdRSTdXWXU4d01DRFFNQ0NldFVTTzcxTG1qcUNCSW1NQmNBOEVaVDZ3c0Y5WFVXK1BvWGRmUURBL2hmSEFUMkQwMDg4ZjhFZkFMOEF5WlVHT2NDRFNvTkh4WDhPQzcvL3lOUDh4UDVRVmozOGhRRVVUSGpGQUJMQSs4Rjl5eGMrQUg5RmtVZitsOHA5QVVuUXhEOEFRRDZlRGZjOHl4NkJPaFJCUXNEQndJQUNRcFlvQWdBQU5BSUFBQWdDUUFBQUFBQUFBd2pQRk5zaEoyMHp1UVBJRGROWlgyWHI4bmhFeXBDV1hLSm9yalI1Z3daTWtoaGVKT3N5TjhhTEVWYWNvZWZ0TTNoRFJZMVVHcUNuTFRONUE4WkxFQmFjNDZveE40VEdENVNaSGlScUw3V0ZoOHlUMmQ0bDZyTDR4VWRMVUZxZkphcnhPQWVNVXRoZVk2bHV0SGxFeGswUmwxMGo2YkEyeG9pUGt0aGRwR253dGtaSVRoR1czR1BwY1RmRlNJelNHRjFrYXZFM2hRZE1rTmFkWkNveGQwV0h6QkNYM1dTcU1UZUdDRXpUWFNHbnJUSTRCVWNSbGRxZkpXcXd0a2FJVFZBVTNXWXJjemhHeUpCWDJ5Qm02N1M0UlFhU0dOeGc1cXd5TnNpS3oxT1hYS2JzYzNsRngwMllYeUtvN1BSNVI0bU9GbDJnWjZ5eU9jVkhURS9WVytPbzhIZUd6Qk5aNFdlczhUWDZCMHZTbU44bDdERzNPMGhLajFNWFhtYnJzL2hIVFZYY0lpYXFyelE0eGdlTkZTRGxxYTZ5K1VsTUVCVWFIYWNzY25tVVFzS0NRb0pDZ252Q084SUNnbjhDQmNKN3doSUN4UUtXZ2svQ1FvSjRnamlDT0lJNGdpU0NMY0pKQWtrQ1FvSkNna0tDU1FKSkFrL0NUSUprQXpPQ2lRSkpBa0tDZUlJclFpZkNOVUlrZ2ljQ2FvSlB3bGFDVm9KV2dsYUNUOEpad2tLQ1pjTjhBdFBDSjhJNGdqaUNPSUk3d2dLQ2RVSTBneEZEQlFLV2duSENLMElud2lTQ0pJSVFnZ0FFQVVQclFnOENqd0tad2tLQ1ZvSlB3a2FDR29NckF3L0NhMEkrUW1DQ1NRSkNnbDNDSzBJQ2cyZ0RhWUtrZ2pWQ0p3Sk1nay9DWjhJTlFneUNYUUpGd2svQ1ZvSmRBbDBDWFFKbkFrL0NjTU9MUTZDQ2Q4SlB3bmlDT0lJL0FpZkNBQUl0Z3laREprS0hndVBDUmNKL0FqOENPSUlUd2kvRE9RTXdRcjJDbzhKMVFqVkNNY0lUd2cxQ0RrTHBRdEpDajhKWndreUNaSUl4d2pIQ0VJSW1ReDlERWtLRkFyaUNJVUl4d2l0Q0swSVhRaHFETzRNdEFwbkNlSUk0Z2ppQ084SWtnaENDRVVNeUF5Y0NRMEk3d2pFQ1Q4SnR3bUNDWVVJc3czU0RBb0pqQXBYQ3FvSlB3bGFDU1FKVHdoZkRjOE4zZ3Z3Qy93SW5nZXRDT0lJNGdqaUNFd05KZzBuQ0g4S09Rc3lDWFFKNGdpcUNld0pzQTZnRFo0SFpBcFJDOThKV2drL0Nad0oxUWpVQzhnTXRBcElDN1FLYWdoUENPOEl1Z2pIQ0c4T1NRN3BCN0VIWkFxTUNoUUt4QWtYQ1Q4Smh3eFZEVElKR2doSUMwZ0xKQW0zQ2NjSWR3Z0tEU1lOSGd2Y0NoY0phZ2ppQ084SVFnZ05DQmNKL0FpRkNIY0loUWcvQ1VrS2pBcU1DdmtKWndtQ0NhMEkxUWl0Q0swSUpBbDBDUzhLakFyZUM2d005Z3BJQzZvSkdnajhDQW9KTWdsTUNhMElhZ2hQQ084SXhBbnBDdWtLUEFvVUNqOEpYQTZCRHJvSUxnZUZDTUVLcGdweEN0RUpud2pwQ2xnTXBncjVDUjRMMFFtRkNGb0pyUWlGQ05TeWxJRnNZRlZTVDAwOU96azRNekV3TFNvcEtDWWtJaDhlRlF3S0F3RUEvL1gwN09uaDJjdStzSytobFloOWNtWmJVVWM4TkNzakhCUVRFZ3dMQlFDemlveVVsNVdabDZOMFExSTdYRWhrV1Z3QVFmQWJDK2NCRUFBQUFBQmpRaVFrSWlRaUlpSWlVMFVrTkNKMFprWkVSTEJtUkVRaVFWVkVWQ1IwalppTHFvUzd1TmlKaFBtb3VZdG9abVJFUkxMYXVibXE5Tmk3dTZyMHU3dmJpbWVidUxtSmRMZWJtSWlFMmJpNHFxVFpxNXVMOUttNHVhcWsyTi9haXRhUHZOcW85STJJbTZxb2l0emJpNlRieXRpSnFMcjJ1WXQwdWR1NWltUmtobVJtSWtSRVpFU295OTNhcUtlYWlHaEdwUGFyaVl1Sm05cmJpLy8rL2U0T0F3SUJBUC8rL05vakF3SUJBUC8rK3RBN0JBSUJBUC8rOXNKSENnSUJBUC84N0xkU0NBSUJBUC84NjdSYUVRSUJBUC80NEt0aEhnUUJBUC8rN0sxZkpRY0JBRUhnSFF2dURmLy8vNE1Ha2YvLy8vLy83RjBQWVAvLy8vLy93bE1aUjkzLy8vLy9va2tpUXFMLy8vL1Nma2tyT2EzLy8vL0pmVWN3T29MLy8vK21ia2s1UG1qUy8vLzdlMEUzUkdTci93QUFBQUFBQUFBQStnQURBQVlBQXdBREFBTUFCQUFEQUFNQUF3RE5BUUFBSUFBS0FCUXVaQUhRQ1FBQUVBc0FBSkFOQUFEUURRQUE4QTBBQUpBT0FBRGdEZ0FBTUE4QUFBY1hKalpGVldSMGc1T2lzc0hRMys4TkdTazNSVk5pY0grT25hdTd5OXpzRHhVaU16MU9YR3AraUppbnVjM2g4QW9WSkRJL1QxOXVmbzJkcmIzTjNlMFJGQ1V6TzA1WmEzdUdscVM0emVEd0NnOGdNME5SWUhDQmpwNnR2Y3pjN0FnVkpUTkJUMkp4Zm9xYnFMUEEwZG9NRHlJM1AwNVhiSGFEbEtlNXk5dnNFQk1nSkRoUFcyeDJpSnFydXN6YzdRc2NLenBLV1dsNGg1YWx0TVRUNHZFR0VDRXVQRXRjYTN1Sm5LbTV4OWJoQ3hNZUxEbEtXV2w1aDVpcHVzcmE2Z3dUSFM0NVIxaGtlSVNVcGJiSDJPa1JGeU11T0UxY2FudUdtS2U1ek43dERoRXROVDlMV1d0emhKZXJ2TTdkOEFrUUhTZzRSMWhuZDRtYXE3M04zdTBRRXlRd09VeFhhWGFFbHFlNXl0cnNEQkVkTmtkUlhtaCtpSldrdHNuZDdROGNMejVQWVhPQmpwdW90TUxRMys0SURoNHRQazVlYjMrUG42L0F6OS92RVI0eFBrOWNhM2VFa2FDdXZzemM2dzRUSkMwOVRGdHNlWXFhckwzTjN1NE1FaDh0UEV4YmEzdUttcXU3ek4zc0RSRWZLelZHVTJkeWc1V251Y3ZjN1JFV0l5bzZUbDF1Zll1YnFyek80UEFJRHlJeVExTmpjNE9Tb3JMQjBlRHZEUkFwUWtsV1gyK0FpWmFqdDg3aDhSRVpKVFEvUzF4bWQ0U1FvSysvMU9jVEh6RkJVMlIxaFpPaHJydkkxZVB5RWg4MFJGaG5kWDZLbGFPeHdNL2Y3eEFkTHoxTVdtcDNoWk9oc01IUjRQQVBGU015UFVsV1lXNTNnWTJ2eHRydFNRNXRDMjBMYlF0dEMyMExiUXR0QzIwTGJRdHRDMjBMa3d1VEMyMExIZ3VRREEwTW5BdndDL0FMd2d2Q0M4SUxrd3VUQzhJTG5BdElDeDRMSGd1bUNsQVByZytsQzRjTWh3eDJDL0FMSGdzeURLd01iUXNlQ3p3SytRbmNDbTBMdkExOURNSUxId3pMQzBnTGJRdHRDMjBMYlF0SUMwZ0xTQXRJQzBnTHdRcStFNzRUZGd2MURUa044QXNORE9rS1dBeFlESndMSGd2UkNld0p3UXBJQzB3Uk5SQ01Dc0VLbkF2Q0MyMExIZ3VsQzhzTGJRdHRDMjBMYlF0SUM2WUtKQTdMQzV3TDhBdndDemtMOWdyd0M1QU01d3VsQzlzTTJ3eWxDKzRNcnd0ckZKWVQ3QWtLRGNZTk9RMTlEQllNTUEybEM0d0tWd3AvQ3VrS0hndHhDdGtUTmhRSEVrd1JuQWxSQytjTGh3eGhESDhLdEFwSUN4NEw2UW9lQzR3S01neElDNU1MYlF0dEMyMExiUXVUQzVNTGt3dVRDMjBMYlF1VEM1TUxrd3RxRUljTXBRc2ZETUlMU0F0SUMyMExuQXM1QzJRTHl3dWNDOElMZlF3NUM3QU9zQTZzREI4TXBRdElDMjBMU0F1Y0MzWUw2UXJwQ2g0TFNBdElDMlFLRGcrdUQ0Y01NZ3lzREhZTDV3dVRDNU1MRFF3ZUMra0s2UXJwQ3VrS0ZBb0ZEL0FQSFEyOERSWU10QXJDQzNZTE1nd05EQjRMSGd0WENsY0tIZ3YyQ2hzVUhoT1pEQVVQY1ExaERGRUxWUTE3RFl3S0ZBcHhDclFLSGd2MkNzRUtEUkRORHRzTVdBeHRDMGdMU0F0dEMra0t0QXJwQ3JRSzZRb2VDMGdMOWdyWkU3NFQ1d3ZaRGF3TThBc05ESUFMSHd4UkM3UUt0QXEwQ2g0TDZRbzhDdFVRMVJBc0M5OEpod3d3RFRBTkF3d0REREFOOEFzZUMxY0tGQXFtQ3NFSzhBdGtDL1lLU0F1MENuOEtVUXNmREU0TVRneVFER0VNOEF2Q0M1TUxIZ3NYRVNvUGJRdElDeDRMU0FzZUN4NExTQXRJQzBnTEhndElDMjBMU0FzZUM2VUxaQXRrQzZVTHBRdndDeklNa0F4T0RQQUx3Z3VjQzV3TG5BdHRDN1FLaFJBMUVPNE1FdzF0QzVNTFNBdWxDNlVMSGd2cENyUUtIZ3NlQ3g0TDZRcndENjRQSHd6Q0MyMExiUXR0QzBnTGJRdHRDeDRMSGdzZUMra0tTQXZjQ2djUzN4RmhESEVOaHd5bEMxRUwzZ3N5RExRS2Z3cC9DbjhLdEFycENvd0tOUkN0RU0wT1NRNm1DdHdLU0F0SUM4SUxuQXR0Q3g0TGZ3cC9DdWtLU0F0M0VPSU53UW9lQ3g0TFNBdElDMGdMYlF0dEMwZ0xiUXR0QzIwTGt3dElDellVT1JQVkNHZ056UTZYRFJNTkhndnVESmNOVGd4UkM1d0p0d25CQ20wTGV3MWxEaklNZlF3ZERlY0xod3lIREtVTGtBd05ERzBMYlF0L0N1d0pnZ21sQzhJTDZRcnBDclFLNlFvZUM1d0w4QXNmREU0TVRneE9EQjhNd2d2Q0M0QUxPUXQvQ3FZSzNBckNDMmdOMlEwZERhd004QXZDQzVNTGJRdElDeDRMeXd1QUMxRUx3Z3ZDQzV3THl3c2ZEUEFMOEF2Q0MwZ0xIZ3R0QzIwTFNBdFFEMzhQd2d0OURCME5rQXpiRE5zTWx3MTREbkVOcGdxRkNKd0pGQW92Q3VITXliaTNyNTZhbVlkM2MzRnViV05pWDA5RU5ESXdMU3NnSHhzU0NnTUEvL3ZyNXRUSnhMYW5wcU9YaW54dWFGcE9URVpGT1MwaUdCVUxCZ1VFQXdDdmxLQ3dzcTJ1cExHdXhMYkd3TFpFUGtJOFNIVlZXbmFJbDQ2Z2pwc0FRZGNyQzhBQ0FXUm1aa1JFSkNKZ3BHdWV1YlM1aTJaQVFpUWlJZ0FCSU5DTGpiK1l1WnRvWUt0b3BtWm1ab1FCQUFBQUFCQVFBRkJ0VG11NWkyZGwwTlNOaTYyWmUyY2tBQUFBQUFBQUFUQUFBQUFBQUFBZ1JJZDdkM2RuUldKRVozaDJkbVpIWW9hSW5iaTJtWXVHMEtqNFM3MlBlV3NnTVNJaUlnQVJBdExyaTN1NWlXbUdZb2RvdG1TM3E0WmtSa1JHUWtJaWcwQ21aa1FrQWdFQWhxWm1SQ0lpUW9UVTlwNkxhMnRYWm1UYmZYcUpkbWVFY29lSmFhdHFNaUtrMW8yUHVaZDVaOEFpQUFBQUFBQUIwRzFLdTRiNW40bG1icHAyVjJWM1pRQUNBQ1FrUWtRallLUm1aQ1FBQWlHbmlxNW1aRlFDQW1ScmVIY2t4UmdBLy83OTlBd0RBZ0VBLy83ODRDWURBZ0VBLy83NzBUa0VBZ0VBLy83MHcwVUVBZ0VBLy92b3VGUUhBZ0VBLy83d3VsWU9BZ0VBLy83dnNsc2VCUUVBLy9qanNXUVRBZ0VBUWFBdUM3Y0IvLy8vbkFTYS8vLy8vLy9qWmc5Yy8vLy8vLy9WVXhoSTdQLy8vLytXVENFLzF2Ly8vNzU1VFNzM3VmLy8vL1dKUnlzN2kvLy8vLytEUWpKQ2E4TC8vNlowVERjMWZmLy9BQUFBQUFBQUFBQmtBQU1BS0FBREFBTUFBd0FGQUE0QURnQUtBQXNBQXdBSUFBa0FCd0FEQUZzQkFBQWdBQkFBWmlhckFYQVBBQUJ3RVFBQWNCVUFBTEFWQUFEUUZRQUEwQllBQUNBWEFBQndGd0FBQUFBQUFPQndMQThEQWdFQS91M0FoRVlYQkFELy9PS2JQUXNDQUVIZ0x3djBBZnIxNnN0SE1pb21JeUVmSFJ3Ykdoa1lGeFlWRkJNU0VSQVBEZzBNQ3dvSkNBY0dCUVFEQWdFQUFBQUFBQUFBQUZ6S3Z0aTIzNXJpbk9aNDdIcjB6UHcwQTRZTGlCTmtHV1lkU2lCQ0o2UTErZmYyOWZUcTBzckp5TVd1VWpzNE56WXVGZ3dMQ2drSEFFQUF5NVlBMThPbWZXNVNBQUFBQUVzWUFBQk9HQUFBZUFDQVFBRG9uZ29BNWdEejNjQzFBR1FBOEFBZ0FHUUF6VHdBTUFBZ3ExVUF3SUJBQU0yYVpqTUExYXVBVlNzQTRNQ2dnR0JBSUFCa0tCQUhBd0VBQVAzNjlPblV0cGFEZUc1aVZVZzhNU2dnR1JNUERRc0pDQWNHQlFRREFnRUEwdERPeThmQnQ2aU9hRW8wSlJzVURnb0dCQUlBUWVBeEMvTUIzOG0zcDVpS2ZHOWlXRTlHUGpneUxDY2pIeHNZRlJJUURnd0tDQVlFQXdJQkFMeXdtNHAzWVVNckdnb0FwWGRRUFM4akd4UU9DUVFBY1Q4QUFBQUFBSDB6R2hJUERBc0tDUWdIQmdVRUF3SUJBTVpwTFJZUERBc0tDUWdIQmdVRUF3SUJBTldpZEZNN0t5QVlFZzhNQ1FjR0JRTUNBTys3ZERzY0VBc0tDUWdIQmdVRUF3SUJBUHJsdklkV014NFREUW9JQmdVRUF3SUJBUG5yMWJtY2dHZFRRalVxSVJvVkVRMEtBUDc1Njg2a2RrMHVHeEFLQndVRUF3SUJBUC85K2UvY3Y1eDNWVGtsRnc4S0JnUUNBUC85Ky9idDM4dXptSHhpU3pjb0hSVVBBUC8rL2ZmY29tcERLaHdTREFrR0JBTUNBRUhnTXdzUjhiNnloRmRLS1E0QTM4R2RqR281SnhJQVFZQTBDNWNCZ0FEV0tnRHJnQlVBOUxoSUN3RDQxb0FxQndENDRhcFFHUVVBKyt6R2ZqWVNBd0Q2N3RPZlVpTVBCUUQ2NTh1b2dGZzFHUVlBL083WXVaUnNSeWdTQkFEOTgrSEhwb0JhT1I4TkF3RCs5dW5VdDVOdFNTd1hDZ0lBLy9ydzM4YW1nRm82SVJBR0FRRC8rL1RuMHJXU2Jrc3VHUXdGQVFELy9manUzY1NrZ0Z3OEl4SUlBd0VBLy8zNTh1WFF0Skp1VERBYkRnY0RBUUJCb0RVTGx3R0JBTTh5QU95QkZBRDF1VWdLQVBuVmdTb0dBUHJpcVZjYkJBRDc2Y0tDUGhRRUFQcnN6NkJqTHhFREFQL3cyYmFEVVNrTEFRRC8vdW5KbjJzOUZBSUJBUC81NmM2cWdGWXlGd2NCQVAvNjd0bTZsR3hHSnhJR0FRRC8vUFBpeUthQVdqZ2VEUVFCQVAvODllZlJ0Skp1VEM4WkN3UUJBUC85K08zYndxT0FYVDRsRXdnREFRRC8vdnJ4NHMyeGtXOVBNeDRQQmdJQkFFSEFOZ3VYQVlFQXl6WUE2b0VYQVBXNFNRb0ErdGVCS1FVQS9PaXRWaGdEQVAzd3lJRTREd0lBL2ZUWnBGNG1DZ0VBL2ZYaXZZUkhHd2NCQVAzMjU4dWZhVGdYQmdFQS8vanIxYk9GVlM4VEJRRUEvLzd6M2NLZmRVWWxEQUlCQVAvKytPclFxNEJWTUJZSUFnRUEvLzc2OE55OWxXdERKQkFHQWdFQS8vNzc4K1BKcG9CYU54ME5CUUlCQVAvKy9QYnExYmVUYlVrckZnb0VBZ0VBUWVBM0M1Y0JnZ0RJT2dEbmdob0E5TGhNREFENTFvSXJCZ0Q4NksxWEdBTUEvZkhMZ3pnT0FnRCs5dDJuWGlNSUFRRCsrZWpCZ2tFWEJRRUEvL3Z2MDZKakxROEVBUUQvKy9QZnVvTktJUXNEQVFELy9QWG15cDVwT1JnSUFnRUEvLzMzNjlhemhGUXNFd2NDQVFELy92cnczOFNmY0VVa0R3WUNBUUQvL3YzMTU5R3dpRjAzR3dzREFnRUEvLzc5L08vZHdwNTFUQ29TQkFNQ0FRQkJnamtMRHdJRkNRNFVHeU1zTmtGTldtaDNod0JCb0RrTHhRSCtNVU5OVWwxanhnc1NHQjhrTGY4dVFrNVhYbWpRRGhVZ0tqTkMvMTVvYlhCemR2ZzFSVkJZWDJZQUFBQUFBQUFBQVFFQkFnTURBd0lEQXdNQ0F3TURBQU1NRHpBelBEL0F3OHpQOFBQOC93RUFBQUFBQUFBQUF3QUFBQUFBQUFBQ0FBQUFBUUFBQUFjQUFBQUFBQUFBQkFBQUFBTUFBQUFHQUFBQUFRQUFBQVVBQUFBQ0FBQUFEd0FBQUFBQUFBQUlBQUFBQndBQUFBd0FBQUFEQUFBQUN3QUFBQVFBQUFBT0FBQUFBUUFBQUFrQUFBQUdBQUFBRFFBQUFBSUFBQUFLQUFBQUJRQkI4VG9MTDBES1JSdE0vMUtDV3JOaW9tdGdkUUFBblQ0QVFGNCtBTUFFUGdDQTdUNEFRSWsrQUFBQUFBREFURDhBQU0wOUFFR3hPd3ZWQXY4QS93RC9BUDhBL3dEK0FRQUIvd0QrQVAwQ0FBSC9BUDRBL1FNQUFmL3dIUUFBK0IwQUFBa2VBQUFhSGdBQUtSNEFBRG9lQUFCU0hnQUFZQjRBQUhOMVkyTmxjM01BYVc1MllXeHBaQ0JoY21kMWJXVnVkQUJpZFdabVpYSWdkRzl2SUhOdFlXeHNBR2x1ZEdWeWJtRnNJR1Z5Y205eUFHTnZjbkoxY0hSbFpDQnpkSEpsWVcwQWNtVnhkV1Z6ZENCdWIzUWdhVzF3YkdWdFpXNTBaV1FBYVc1MllXeHBaQ0J6ZEdGMFpRQnRaVzF2Y25rZ1lXeHNiMk5oZEdsdmJpQm1ZV2xzWldRQWRXNXJibTkzYmlCbGNuSnZjZ0FDQVFBWkZ3SUFmbngzYlZjcEV3a0VBZ0FBQUFDQXV3QUFlQUFBQUJVQUFBQVZBQUFBQUpwWlB3QUFBQUFBQUlBL0FBQ0FQeEFmQUFBREFBQUFDQUFBQUhnQUFBQUxBQUFBUUI4QUFEQWdBQUJnSUFBQWdBY0FBQU1BQUFCQUlnQUFZRllBQUpCWEFBQklXQUFBZ0NJQUFJZ0JBQUNnUGdBQWdEOEFBQkJCQUVHU1Bnc3BBUUFDQUFNQUJBQUZBQVlBQndBSUFBb0FEQUFPQUJBQUZBQVlBQndBSWdBb0FEQUFQQUJPQUdRQVFkVStDOUlCV2xCTFJUODRNU2dpSFJRU0NnQUFBQUFBQUFBQWJtUmFWRTVIUVRvekxTY2dHaFFNQUFBQUFBQUFkbTVuWFZaUVMwWkJPelV2S0I4WER3UUFBQUFBZm5kd2FGOVpVMDVJUWp3Mkx5Y2dHUkVNQVFBQWhuOTRjbWRoVzFWT1NFSThOaThwSXgwWEVBb0JrSW1DZkhGclpWOVlVa3hHUURrekxTY2hHZzhCbUpHS2hIdDFiMmxpWEZaUVNrTTlOekVySkJRQm9wdVVqb1YvZVhOc1ptQmFWRTFIUVRzMUxoNEJyS1dlbUkrSmczMTJjR3BrWGxkUlMwVS9PQzBVeU1qSXlNakl5TWpHd2J5M3NxMm9vNTZabElGb0FFSEF3QUFMbndRSUFBZ0FDQUFJQUJBQUVBQVFBQlVBRlFBWUFCMEFJZ0FrQUFBQUFBQUFBR29jalRoU3V4NDZDR25jT29MdFZ6dUpZN0k3QXlvRlBERGNPVHkwUG5jOEhLT2VQTkh5eFR6K2h2RThtNnNRUFFXdEtqMkV3a1k5VStaa1BSR0pnajJIbjVNOXk3S2xQZEcrdUQwNnY4dzlWSy9oUFJTSzl6ME9KUWMrMmZRU1BsOHhIejVvMXlzK2l1TTRQakJTUmo2VUgxUSt2MGRpUG83R2NENndsMzgrVWx1SFBtQVBqejZZNVpZK2VkdWVQbkR1cGo3WUc2OCsrMkMzUGhHN3Z6NUdKOGcrdDZMUVBuZ3EyVDZVdStFK0RGUHFQdDd0OGo0R2lmcyt2aEFDUHg5YUJqOGtud28vVU40T1B5c1dFejlCUlJjL0pXb2JQM09ESHovT2p5TS81bzBuUDNSOEt6OC9XaTgvR1NZelArZmVOaitaZ3pvL014TStQOFdNUVQ5MzcwUS9menBJUHlkdFN6L09oazQvNVlaUlAvRnNWRCtPT0ZjL2FlbFpQMFYvWEQvNitWNC9jMWxoUDYrZFl6L0J4bVUvejlSblB4SElhVC9Tb0dzL2JsOXRQMUFFYnovMGozQS81Z0p5UDcxZGN6OGZvWFEvdjgxMVAxZmtkait3NVhjL2w5SjRQK09yZVQ5emNuby9KeWQ3UCtmS2V6K2RYbncvTmVOOFA1eFpmVCs5d24wL2hoOStQOTV3ZmorcnQzNC96L1IrUHlZcGZ6K0dWWDgvdm5wL1A1YVpmei9Nc244L0ZNZC9QeHpYZnorQzQzOC8zZXgvUDdiemZ6K0srSDgveVB0L1A5YjlmejhILzM4L3BmOS9QK2ovZnovOS8zOC9BQUNBUCtBQkFBQ0hpQWc3Ly8vLy93VUFZQUFEQUNBQUJBQUlBQUlBQkFBRUFBRUFRZXpFQUFzR3dFRUFBSUJGQUVHQXhRQUx5VGovLzM4L2p2OS9QMnIrZnorVC9IOC9CL3AvUDhqMmZ6L1c4bjgvTU81L1A5Ym9mei9JNG44L0I5eC9QNVBVZno5cnpIOC9qOE4vUHdDNmZ6KzlyMzgveDZSL1B4Mlpmei9Bakg4L3NIOS9QK3h4Zno5MlkzOC9TMVIvUDI1RWZ6L2VNMzgvbWlKL1A2TVFmei82L1g0L25lcCtQNDNXZmovTHdYNC9WcXgrUHk2V2ZqOVRmMzQveG1kK1A0WlBmaitVTm40Lzd4eCtQNWdDZmorUDUzMC8wOHQ5UDJhdmZUOUdrbjAvZEhSOVAvRlZmVCs4Tm4wLzFSWjlQenoyZkQveTFIdy85cko4UDBtUWZEL3JiSHcvMjBoOFB4c2tmRCtwL25zL2g5aDdQN1N4ZXo4d2lucy8vR0Y3UHhjNWV6K0NEM3MvUGVWNlAwaTZlaitpam5vL1RXSjZQMGcxZWorVUIzby9NTmw1UHgycWVUOWFlbmsvNlVsNVA4Z1llVC81NW5nL2U3UjRQMDZCZUQ5elRYZy82aGg0UDdMamR6L05yWGMvT25kM1Avay9kejhLQ0hjL2JzOTJQeVdXZGo4dlhIWS9qQ0YyUHp6bWRUOUFxblUvbDIxMVAwSXdkVDlCOG5RL2xMTjBQenQwZEQ4M05IUS9oL056UHl5eWN6OG1jSE0vZGkxelB4cnFjajhVcG5JL1pHRnlQd29jY2o4RjFuRS9WNDl4UHdCSWNULy8vM0EvVmJkd1B3SnVjRDhHSkhBL1l0bHZQeFdPYno4Z1FtOC9oUFZ1UHorb2JqOVRXbTQvd0F0dVA0YThiVCtsYkcwL0hSeHRQKy9LYkQ4YmVXdy9vU1pzUDREVGF6KzdmMnMvVUN0clAwRFdhaitNZ0dvL01pcHFQelhUYVQrVGUyay9UU05wUDJUS2FEL1ljR2cvcUJab1A5VzdaejlnWUdjL1NBUm5QNCtuWmo4elNtWS9OdXhsUDVlTlpUOVhMbVUvZDg1a1AvVnRaRC9VREdRL0VxdGpQN0ZJWXordzVXSS9FSUppUDlFZFlqL3p1R0UvZDFOaFAxenRZRCtraG1BL1RoOWdQMXUzWHovTFRsOC9udVZlUDlWN1hqOXdFVjQvYnFaZFA5STZYVCthemx3L3htRmNQMW4wV3o5Umhscy9yaGRiUDNLb1dqK2RPRm8vTHNoWlB5ZFhXVCtINVZnL1QzTllQMzhBV0Q4WGpWYy9HQmxYUDRLa1ZqOVdMMVkvazdsVlB6cERWVDlMekZRL3gxUlVQNjdjVXo4QlpGTS92K3BTUCtsd1VqOS85bEUvZ250UlAvTC9VRC9QZzFBL0dnZFFQOUtKVHovNkMwOC9rSTFPUDVRT1RqOEpqMDAvN1E1TlAwR09URDhGRFV3L080dExQK0VJU3ovNWhVby9nd0pLUDM5K1NUL3UrVWcvejNSSVB5VHZSei90YUVjL0tlSkdQOXBhUmo4QTAwVS9tMHBGUDZ6QlJEOHlPRVEvTDY1RFA2SWpReitObUVJLzd3eENQOGlBUVQ4YTlFQS81V1pBUHlqWlB6L2xTajgvRzd3K1A4d3NQai8zbkQwL25RdzlQNzU3UEQ5YzZqcy9kVmc3UHdyR09qOGRNem8vclo4NVA3c0xPVDlIZHpnL1VlSTNQOXBNTnovanRqWS9heUEyUDNTSk5ULzk4VFEvQjFvMFA1UEJNeitnS0RNL01JOHlQMEwxTVQvWVdqRS84Yjh3UDQ0a01EK3ZpQzgvVmV3dVA0RlBMajh5c2kwL2FSUXRQeWQyTEQ5cjF5cy9OemdyUDR1WUtqOW4rQ2svekZjcFA3cTJLRDh5RlNnL00zTW5QNy9RSmovV0xTWS9lWW9sUDZmbUpEOWhRaVEvcVowalAzMzRJai9mVWlJL3o2d2hQMDBHSVQ5Ylh5QS8rTGNmUHlVUUh6L2laeDQvTUw4ZFB4QVdIVCtCYkJ3L2hNSWJQeG9ZR3o5RGJSby9BTUlaUDFFV0dUODJhaGcvc2IwWFA4RVFGejluWXhZL283VVZQM1lIRlQvaFdCUS81S2tUUDMvNkVqK3pTaEkvZ0pvUlArZnBFRC9vT0JBL2hJY1BQN3ZWRGorT0l3NC8vbkFOUHdxK0REK3pDZ3cvK2xZTFA5K2lDajlqN2drL2hqa0pQMG1FQ0Qrc3pnYy9yeGdIUDFSaUJqK2Jxd1UvZy9RRVB3ODlCRDg5aFFNL0Q4MENQNFlVQWoraFd3RS9ZYUlBUDQvUi96Nm5YZjQrRHVuOFBzSnorejdHL2ZrK0c0ZjRQc0VQOXo2NmwvVStCaC8wUHFpbDhqNmVLL0UrN0xEdlBwRTE3ajZRdWV3KzZEenJQcHEvNlQ2cFFlZytGY1BtUHQ5RDVUNEl4T00ra1VQaVBuekM0RDdJUU44K2VMN2RQb3c3M0Q0R3VObys1alBaUGk2djF6N2ZLZFkrK2FQVVBuMGQwejV1bHRFK3pBN1FQcGVHemo3Uy9jdytmWFRMUHBucXlUNG5ZTWcrS05YR1BwOUp4VDZLdmNNKzdERENQc2Fqd0Q0WkZyOCs1b2U5UGkzNXV6N3hhYm8rTXRxNFB2Rkp0ejR2dWJVKzdpZTBQaStXc2o3eUE3RStPWEd2UGdUZXJUNVdTcXcrTDdhcVBwQWhxVDU2aktjKzcvYWxQdTlncEQ1OHlxSStsek9oUGtDY256NTZCSjQrUkd5Y1BxSFRtajZST3BrK0ZxR1hQakFIbGo3aGJKUStLZEtTUGdzM2tUNkhtNDgrbnYrTlBsRmpqRDZpeG9vK2tTbUpQaUNNaHo1UTdvVStJbENFUHBleGdqNndFb0UrM3VaK1BxbW5lejdEWjNnK0x5ZDFQdTdsY1Q0RXBHNCtjMkZyUGp3ZWFENWkybVErNkpWaFBzOVFYajRhQzFzK3pNUlhQdVo5VkQ1ck5sRStYZTVOUHIrbFNqNlNYRWMrMmhKRVBwZklRRDdPZlQwK2dESTZQcTdtTmo1ZG1qTStqVTB3UGtJQUxUNTlzaWsrUW1RbVBwRVZJejV1eGg4KzIzWWNQdG9tR1Q1dDFoVSttSVVTUGxzMER6NjY0Z3MrdDVBSVBsUStCVDZVNndFKzhERDlQUWFLOWoxeDR1ODlNenJwUFUrUjRqM1A1OXM5dFQzVlBRT1R6ajNBNThjOThqdkJQWnlQdWozRDRyTTliRFd0UFp1SHBqMVYyWjg5bnlxWlBYNTdrajMyeTRzOUN4eUZQWWZYZkQxR2RtODlYUlJpUGRheFZEMjVUa2M5RU9zNVBlV0dMRDFBSWg4OUxMMFJQYkpYQkQyMTQrMDhZQmZUUEhaS3VEd0xmWjA4TXErQ1BQckJUenorSkJvOEtnL0pPNW1uT3pzdWZkYTUwa1p4dTZ2ZTQ3dW1qQ2U4Z1NsZHZPRmlpYnlnTUtTODdQMit2TFBLMmJ6Z2x2UzhNYkVIdlpNV0ZiMk1leUs5RStBdnZSNUVQYjJscDBxOW5RcFl2ZjVzWmIyK3puSzk2aGVBdlJ2SWhyM3RkNDI5WENlVXZXUFdtcjM5aEtHOUpqT292ZG5ncnIwUmpyVzl5anE4dmY3bXdyMnFrc205eUQzUXZWVG8xcjFLa3QyOXBEdmt2VjNrNnIxeWpQRzkzVFA0dlpyYS9yMVN3QUsrL0JJR3ZrZGxDYjR5dHd5K3VnZ1F2dDFaRTc2WXFoYSs2dm9adnRCS0hiNUhtaUMrVHVranZ1RTNKNzRBaGlxK3B0TXR2dE1nTWI2RGJUUyt0Ymszdm1VRk83NlRVRDYrT3B0QnZscmxSTDd3TGtpKytYZEx2blRBVHI1ZENGSytzMDlWdm5PV1dMNmMzRnUrS2lKZnZodG5ZcjV0cTJXK0grOW92aXd5Ykw2VWRHKytWTFp5dm1yM2RiN1ROM20ralhkOHZwYTJmNzUxZW9HK1JSbUR2cm0zaEw3UVZZYStpUE9IdnVHUWliN2FMWXUrY01xTXZxUm1qcjUwQXBDKzM1MlJ2dVE0azc2QjA1Uyt0bTJXdm9FSG1MN2lvSm0rMXptYnZsL1NuTDU1YXA2K0l3S2d2bDZab2I0bU1LTytmY2Frdm1CY3ByN084YWUreG9hcHZrY2JxNzVRcjZ5KzRFS3V2dlhWcjc2UGFMRytyZnF5dmsyTXRMNXVIYmErRUs2M3ZqQSt1YjdQemJxKzZseTh2b0xydmI2VWViKytId2ZCdmlPVXdyNmZJTVMra2F6RnZ2ZzN4NzdUd3NpK0lrM0t2dUxXeTc0VFlNMit0ZWpPdnNWdzBMNUMrTkcrTFgvVHZvTUYxYjVEaTlhK2JSRFl2ditVMmI3NUdOdStXWnpjdmgwZjNyNUdvZCsrMHlMaHZzR2o0cjRRSk9TK3ZxUGx2c3dpNTc0NG9laStBQi9xdmlTYzY3NmlHTzIrZXBUdXZxc1A4TDR6aXZHK0VnVHp2a1o5OUw3UDlmVytxbTMzdnRuaytMNVlXL3ErS05IN3ZrZEcvYjYxdXY2K09CY0F2N3ZRQUwva2lRRy9za0lDdnlYN0FyODdzd08vOW1vRXYxTWlCYjlUMlFXLzlZOEd2emhHQjc4ZC9BZS9vckVJdjhkbUNiK01Hd3EvOE04S3YvT0RDNytUTnd5LzBlb012NnlkRGI4a1VBNi9PQUlQditpekQ3OHlaUkMvR0JZUnY1ZkdFYit3ZGhLL1l5WVR2NjdWRTcrUmhCUy9EVE1WdngvaEZiL0lqaGEvQ0R3WHY5M29GNzlJbFJpL1NFRVp2OXpzR2I4RW1CcS93RUlidncvdEc3L3dsaHkvWTBBZHYyanBIYi8ra1I2L0pUb2Z2OXpoSDc4amlTQy8raThodjEvV0liOVNmQ0svMUNFanYrUEdJNzkvYXlTL3B3OGx2MXl6SmIrZFZpYS9hUGttdjcrYko3K2dQU2kvQzk4b3YvOS9LYjk5SUNxL2c4QXF2eEZnSzc4bi95dS94SjBzditnN0xiK1MyUzIvdzNZdXYza1RMNyswcnkrL2Mwc3d2N2ZtTUw5L2dURy95eHN5djVtMU1yL3FUak8vdmVjenZ4S0FOTC9vRnpXL1A2ODF2eFpHTnI5dTNEYS9SWEkzdjV3SE9MOXhuRGkveFRBNXY1YkVPYi9tVnpxL3N1bzZ2L3g4TzcvQ0RqeS9BNkE4djhFd1BiLzZ3RDIvclZBK3Y5dmZQcitEYmorL3Bmdy92MENLUUw5VEYwRy80S05CditRdlFyOWd1MEsvVTBaRHY3N1FRNytlV2tTLzl1TkV2OEpzUmI4RjlVVy92SHhHditnRFI3K0ppa2UvblJCSXZ5V1dTTDhnRzBtL2pwOUp2MjhqU3IvQnBrcS9oaWxMdjd5clM3OWpMVXkvZXE1TXZ3SXZUYi82cmsyL1lpNU92em10VHI5K0swKy9NNmxQdjFVbVVML21vbEMvNUI1UnYxQ2FVYjhvRlZLL2JZOVN2eDRKVTc4N2dsTy93L3BUdjdkeVZMOFc2bFMvMzJCVnZ4TFhWYit3VEZhL3Q4Rld2eWMyVjc4QXFsZS9RaDFZdit5UFdMLytBVm0vZUhOWnYxbmtXYitpVkZxL1VjUmF2Mll6VzcvaW9WdS93dzljdndwOVhMKzM2VnkveUZWZHZ6N0JYYjhZTEY2L1Y1WmV2L24vWHIvL2FGKy9hTkZmdnpNNVlMOWlvR0MvOHdaaHYrVnNZYjg2MG1HLzhEWml2d2liWXIrQS9tSy9XV0ZqdjVMRFk3OHNKV1MvSllaa3YzN21aTDgzUm1XL1RxVmx2OFVEWnIrYVlXYS96YjVtdjE0Ylo3OU5kMmUvbXRKbnYwUXRhTDlMaDJpL3J1Qm92Mjg1YWIrTGtXbS9CT2xwdjlrL2FyOEpsbXEvbE90cXYzdEFhNys4bEd1L1dlaHJ2MDg3YkwrZ2pXeS9TOTlzdjA4d2JiK3RnRzIvWmRCdHYzVWZici9mYlc2L29idHV2N3NJYjc4dVZXKy8rS0J2dnh2c2I3K1ZObkMvWjRCd3Y1REpjTDhQRW5HLzVsbHh2eE9oY2IrWDUzRy9jUzF5djZCeWNyOG10M0svQWZ0eXZ6SStjNys0Z0hPL2xNSnp2OFFEZEw5SlJIUy9Jb1IwdjFERGRML1NBWFcvcUQ5MXY5SjhkYjlRdVhXL0lmVjF2MFV3ZHIrOWFuYS9pS1IydjZiZGRyOFdGbmUvMlUxM3YrK0VkNzlYdTNlL0VmRjN2eDBtZUw5NlduaS9LbzU0dnl2QmVMOTk4M2kvSVNWNXZ4WldlYjljaG5tLzhyVjV2OXJrZWI4U0UzcS9ta0I2djNOdGVyK2RtWHEvRnNWNnY5L3Zlci80R1h1L1lVTjd2eHBzZTc4aWxIdS9lcnQ3dnlEaWU3OFhDSHkvWEMxOHYvQlJmTC9UZFh5L0JabDh2NGE3Zkw5VjNYeS9jLzU4djk4ZWZiK2FQbjIvbzExOXYvcDdmYitmbVgyL2tyWjl2OVBTZmI5aTduMi9Qd2wrdjJramZyL2hQSDYvcDFWK3Y3cHRmcjhiaFg2L3ladCt2OFN4ZnI4TngzNi9vdHQrdjRYdmZyKzFBbisvTWhWL3Yvd21mNzhUT0grL2RraC92eWRZZjc4a1ozKy9iblYvdndXRGY3L29qMysvR1p4L3Y1V25mNzlmc24rL2RMeC92OWZGZjcrRnpuKy9nZFovdjhqZGY3OWQ1SCsvUGVwL3YycnZmNy9qODMrL3FmZC92N3Y2Zjc4Wi9YKy94UDUvdjd2L2Y3LzYvMzgvT2Y1L1A2bjVmejlMOG44L0h1aC9QeVBiZno5WnkzOC93YmgvUDF1amZ6OG9pMzgvSjNCL1AxcFNmeisvTVg4L1dBNS9QeVhvZmo4bXYzNC9YSk4rUDhoa2ZqOXBNMzQvUWY5OVAwL0lmVCtXam4wL0ZGSjlQOHNTZlQrODBIdy81NHQ4UDAxRWZEL3YrWHMvemF4N1ArbGNlejlEQ25zLzNiUjZQN1pjZWovUkFYby9McVI1UDg1RGVUK3k0SGcvM0hwNFAwd1NlRDhFcDNjL0JEbDNQMC9JZGova1ZIWS94dDUxUC9abGRUOTE2blEvUkd4MFAyWHJjei9hWjNNL28rRnlQOEpZY2o4NXpYRS9DVDl4UHpTdWNEKzdHbkEvb0lSdlArVHJiaitLVUc0L2s3SnRQd0VTYlQvVmJtdy9FY2xyUDdjZ2F6L0pkV28vU2NocFB6a1lhVCtiWldnL2I3Qm5QN3I0Wmo5OFBtWS91SUZsUDIvQ1pEK2tBR1EvV2p4alA1RjFZajlNckdFL2p1QmdQMWtTWUQrdVFWOC9rVzVlUHdPWlhUOEl3Vncvb09aYlA4OEpXeitZS2xvLyswaFpQLzFrV0QrZmZsYy81WlZXUDlDcVZUOWp2VlEvb2MxVFA0emJVajhuNTFFL2RmQlFQM24zVHo4MC9FNC9xLzVOUDkvK1REL1UvRXMvalBoS1B3cnlTVDlTNlVnL1pkNUhQMGZSUmovN3dVVS9oTEJFUCtXY1F6OGdoMEkvT205QlB6UlZRRDhUT1Q4LzJCbytQNGo2UEQ4bTJEcy90TE02UHphTk9UK3ZaRGcvSWpvM1A1TU5OajhGM3pRL2ZLNHpQL2w3TWorQ1J6RS9HUkV3UDhMWUxqOS9uaTAvVm1Jc1AwZ2tLejlhNUNrL2tLSW9QK3RlSno5eEdTWS9KZElrUHdtSkl6OGpQaUkvZGZFZ1B3U2pIei9TVWg0LzVBQWRQejJ0R3ovaFZ4by8wd0FaUHhtb0Z6KzBUUlkvcXZFVVAvMlRFeit5TkJJL3pOTVFQMUJ4RHo5Q0RRNC9wS2NNUDN4QUN6L04xd2svbW0wSVAra0JCeis5bEFVL0dTWUVQd08yQWo5K1JBRS9IS1AvUG02Ni9ENzZ6dmsreXVEMlB1VHY4ejVSL1BBK0dnYnVQa2NONno3Z0VlZys3UlBsUG5jVDRqNkhFTjgrSkF2Y1BsZ0QyVDRxK2RVK3BPelNQczNkeno2dnpNdytVcm5KUHIranhqNytpOE0rR0hMQVBoWld2VDRBT0xvKzRCZTNQcjMxc3o2aDBiQStsYXV0UHFLRHFqN1BXYWMrSnk2a1BySUFvVDU1MFowK2hhQ2FQdDl0bHo2UE9aUStvQU9SUGhyTWpUNEZrNG8rYTFpSFBsWWNoRDdOM29BK3RqOTdQaEMvZEQ2N08yNCt5YlZuUGswdFlUNVpvbG8rL3hSVVBsR0ZUVDVqODBZK1JsOUFQZzNKT1Q3S01ETStrSllzUG5MNkpUNkNYQjgrMHJ3WVBuWWJFajUvZUFzK0FkUUVQaDFjL0QxeURlODlLYnpoUFdabzFEMU9Fc2M5Q0xxNVBiaGZyRDJFQTU4OWtxV1JQUWRHaEQwU3ltMDllZ1ZUUFpFK09EMmtkUjA5L0tvQ1BjcTl6enhXSTVvOFlRNUpQTVdudXpzOWVsYTZDVWJ4dXhMZFk3eFFpcWU4UVNUZHZPTmRDYjBqS0NTOWx2QSt2ZksyV2IzcWVuUzlHcDZIdlVMOWxMM0lXcUs5aHJhdnZWY1F2YjBXYU1xOW03M1h2Y01RNWIxcFlmSzlaYS8vdlVwOUJyNW9JUTIrK3NNVHZ1MWtHcjR1QkNHK3JLRW52bE05THI0UTF6UyswbTQ3dm9ZRVFyNFptRWkrZVNsUHZwUzRWYjVXUlZ5K3JzOWl2b2xYYWI3VzNHKytnRjkydm5qZmZMNVVyb0crZ2V1RXZqZ25pTDV5WVl1K0pKcU92a1hSa2I3TkJwVytzenFZdnU1c203NTBuWjYrUGN5aHZrRDVwTDV6SktpK3owMnJ2a2wxcnI3YW1yRytlTDYwdmh2Z3Q3NjYvN3ErU3gyK3ZzYzR3YjRsVXNTK1cybkh2bUYreXI0d2tjMit2S0hRdmdDdzA3N3h1OWEraDhYWnZyck0zTDZCMGQrKzA5UGl2cW5UNWI3NjBPaSt2Y3ZydnVyRDdyNTR1ZkcrWUt6MHZwcWM5NzRjaXZxKzMzVDl2bTB1QUw4RG9RRy9MUklEdithQkJMOHM4QVcvK2x3SHYweklDTDhlTWdxL2JKb0x2eklCRGI5c1pnNi9GOG9Qdnkwc0ViK3NqQksva09zVHY5VklGYjkycEJhL2NmNFh2OEJXR2I5aXJScS9VUUljdjRwVkhiOEpweDYveS9ZZnY4eEVJYjhKa1NLL2ZOc2p2eVFrSmIvOWFpYS9BckFudnpEektMK0VOQ3EvK25NcnY0K3hMTDgvN1MyL0J5Y3Z2K05lTUwvUWxERy95c2d5djg3Nk03L2FLalcvNkZnMnYvZUVONzhDcnppL0I5YzV2d1A5T3IveElEeS96MEk5djVwaVByOVBnRCsvNlp0QXYyaTFRYi9HekVLL0FlSkR2eGYxUkw4REJrYS94QlJIdjFZaFNMKzJLMG0vNFROS3Y5UTVTNytOUFV5L0NUOU52MFErVHI4OU8wKy84RFZRdjFvdVViOTVKRksvU2hoVHY4b0pWTC8zK0ZTL3p1VlZ2MDNRVnI5d3VGZS9ONTVZdjV5QldiK2dZbHEvUGtGYnYzVWRYTDlCOTF5L29zNWR2NVNqWHI4VWRsKy9Ja1pndjdvVFliL1ozbUcvZjZkaXY2bHRZNzlVTVdTL2Z2Smt2eWF4WmI5SmJXYS81U1pudi9qZFo3K0FrbWkvZTBScHYranphYi9Eb0dxL0RFdHJ2OER5YTcvZWwyeS9aRHB0djFEYWJiK2dkMjYvVXhKdnYyYXFiNy9aUDNDL3FkSnd2OVZpY2I5YjhIRy9PbnR5djNFRGM3LzlpSE8vM2d0MHZ4R01kTCtXQ1hXL2E0UjF2NC84ZGI4QWNuYS92ZVIydjhaVWQ3OFl3bmUvc2l4NHY1T1VlTCs3K1hpL0tGeDV2OW03ZWIvTkdIcS9Bbk42djNuS2VyOHZIM3UvSkhGN3YxakFlNy9KREh5L2RsWjh2MStkZkwrQzRYeS80Q0o5djNkaGZiOUhuWDIvVDlaOXY0NE1mcjhFUUg2L3NIQit2NUtlZnIrcHlYNi85ZkYrdjNVWGY3OHBPbisvRUZwL3Z5dDNmNzk0a1grLytLaC92NnE5ZjcrUHozKy9wZDUvdiszcWY3OW05SCsvRWZ0L3YrMytmNy9xLzM4LzVmaC9QNmJtZno4dHlYOC9mS0IvUDVWc2Z6OTVMWDgvTE9OK1A3R05majhMTFg0L1A4RjlQMUpLZlQ5SXlIdy9LRHQ4UC9laWV6KzkvM28vZ0ZGNlAwaVllVDhlMUhnL0NRVjRQeE1yZHo5R1JuWS9yRloxUDA1Y2REODRWM00vZGtkeVB4TXRjVDhjQ0hBL250aHVQNldlYlQ5QVdtdy9mZ3RyUDJ1eWFUOFpUMmcvbHVGbVAvSnBaVDgrNkdNL2kxeGlQK3JHWUQ5dEoxOC9KbjVkUHlqTFd6K0ZEbG8vVTBoWVA2TjRWaitMbjFRL0lMMVNQM2JSVUQrajNFNC92ZDVNUDl2WFNqOFR5RWcvZks5R1B5Nk9SRDlCWkVJL3pqRkFQK3oyUFQrMHN6cy9RbWc1UDYwVU56OFF1VFEvaGxVeVB5bnFMejhWZHkwL1pmd3FQelY2S0QraDhDVS94bDhqUDhESElEK3NLQjQvcVlJYlA5VFZHRDlLSWhZL0ttZ1RQNU9uRUQrazRBMC9leE1MUHpsQUNELzlaZ1UvNTRjQ1B5MUcvejViY2ZrK2w1SHpQaVNuN1Q1RnN1YytQTFBoUGt5cTJ6NjZsOVUreVh2UFByNVd5VDdmS01NK2NQSzhQcmV6dGo3N2JMQStnUjZxUHBMSW96NXphNTArYkFlWFBzV2NrRDdISzRvK3ViU0RQc2R2ZWo0aGEyMCtFVnhnUGlsRFV6NzlJRVkrSVBZNFBpYkRLejZraUI0K0xVY1JQbGYvQXo1dVkrMDl3cjNTUGRvT3VEM2VWNTA5KzVtQ1BieXNUejFsSEJvOW1RckpQQ3FuT3p6QmVOYTZMVVJ4dkZmWDQ3eE1nU2U5bEE5ZHZSVktpYjFhQnFTOWJidSt2U0pvMmIxT0MvUzk0MUVIdmkrWUZMNzMxeUcrcFJBdnZxWkJQTDVrYWttK1RZcFd2czJnWTc1UXJYQytSYTk5dmcxVGhiNmV5SXUrRFRpU3ZoS2htTDVtQTUrK3YxNmx2dGl5cTc1cC83RytLMFM0dnRpQXZyNHF0Y1MrMitES3ZxVUQwYjVGSGRlK2RTM2R2dkV6NDc1Mk1PbSt3Q0x2dm8wSzliNmI1L3ErMDF3QXZ6aEFBNy9iSFFhL20vVUl2MXJIQzcvM2tnNi9WRmdSdjFBWEZML056eGEvcklFWnY5QXNITDhhMFI2L2JXNGh2NnNFSkwrM2t5YS9kQnNwdjhlYks3K1RGQzYvdTRVd3Z5YnZNciszVURXL1ZhbzN2K1A3T2I5S1JUeS9ib1krdnplL1FMK0w3MEsvVXhkRnYzVTJSNy9hVEVtL2ExcEx2eEJmVGIreldrKy9QazFSdjVvMlU3K3pGbFcvY3UxV3Y4VzZXTCtWZmxxLzBEaGN2MkxwWGI4NGtGKy9RQzFodjJmQVlyK2NTV1MvenNobHYrczlaNy9qcUdpL3B3bHF2eWRnYTc5VXJHeS9IKzV0djNvbGI3OVlVbkMvcTNSeHYyZU1jcjkvbVhPLzU1dDB2NVdUZGI5K2dIYS9sbUozdjlRNWVMOHZCbm0vbnNkNXZ4ZCtlcitVS1h1L0RjcDd2M3BmZkwvVjZYeS9HR2w5dno3ZGZiOUFSbjYvSEtSK3Y4ejJmcjlOUG4rL25IcC92N2FyZjcrWjBYKy9RK3gvdjdUN2Y3K20vMzgvbE9OL1A1eWFmei9NSkg4L09JSitQLzJ5ZlQ4L3Qzdy9Lbzk3UC9NNmVqL1V1bmcvRVE5M1AvWTNkVC9WTlhNL0NBbHhQL0d4YmovNU1Hdy9rSVpwUHkrelpqOVR0Mk0vaEpOZ1AwNUlYVDlGMWxrL0F6NVdQeXVBVWo5bG5VNC9YcFpLUDh4clJqOXFIa0kvK2E0OVAwQWVPVDhOYlRRL01wd3ZQNGVzS2ovcm5pVS9QM1FnUDIwdEd6OWh5eFUvRFU4UVAyaTVDajlyQ3dVL0xveitQdDNVOGo3eDh1WStmK2phUHFhM3pqNklZc0krVHV1MVBpcFVxVDVSbjV3Ky9jNlBQbTNsZ2o3T3lXcytZcDlSUGpCUU56N1Q0QncrOFZVQ1BtSm96ejE4QUpvOUpQdElQUnVrdXp6emQxYTdaRDN4dkx2QVk3MW5YYWU5RkwzY3ZRUDdDTDV6ZnlPK05PYzl2cVF0V0w0bVRuSytFaUtHdm9rRms3NDB6NSsrMVh5c3ZqTU11YjRhZThXK1c4ZlJ2czN1M2I1UTcrbSt4OGIxdnBDNUFMOG1lUWEvSkNFTXY0MndFYjltSmhlL3VvRWN2NWpCSWI4VjVTYS9TdXNydjFiVE1MOWJuRFcvZzBVNnYvM05Qci84TkVPL3ZIbEh2MzJiUzcrRW1VKy9IM05UdjZFblY3OWp0bHEveGg1ZXZ6QmdZYjhQZW1TLzJHdG52d2MxYXI4ZjFXeS9xVXR2dnplWWNiOWl1bk8veWJGMXZ4WitkNy8ySG5tL0laUjZ2MVhkZTc5WitueS8rdXA5dnc2dmZyOTBSbisvRDdGL3Y4N3VmNy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9BQUFBQUFBQUFBQXBBQ2tBS1FCU0FGSUFld0NrQU1nQTNnQkIydjBBQzVnQktRQXBBQ2tBS1FCN0FIc0Fld0NrQUtRQThBQUtBUnNCSndFcEFDa0FLUUFwQUNrQUtRQXBBQ2tBZXdCN0FIc0Fld0R3QVBBQThBQUtBUW9CTVFFK0FVZ0JVQUY3QUhzQWV3QjdBSHNBZXdCN0FIc0E4QUR3QVBBQThBQXhBVEVCTVFFK0FUNEJWd0ZmQVdZQmJBSHdBUEFBOEFEd0FQQUE4QUR3QVBBQU1RRXhBVEVCTVFGWEFWY0JWd0ZmQVY4QmNnRjRBWDRCZ3dFQVFZRC9BQXU0QkNnSEJ3Y0hCd2NIQndjSEJ3Y0hCd2NIQndjSEJ3Y0hCd2NIQndjSEJ3Y0hCd2NIQndjSEJ3Y0hLQThYSEI4aUpDWW5LU29yTEMwdUx5OHhNak0wTlRZM056azZPenc5UGo4L1FVSkRSRVZHUjBjb0ZDRXBNRFU1UFVCQ1JVZEpTMHhPVUZKVlYxbGJYRjVnWW1WbmFXdHNibkJ5ZFhkNWUzeCtnQ2dYSnpNOFEwbFBVMWRiWG1Ga1ptbHJiM04yZVh4K2dZT0hpNDZSbEphWm01K2pwcW1zcnJHekl4d3hRVTVaWTJ0eWVINkVpSTJSbFptZnBhdXd0TG05d01mTjA5amM0ZVhvNy9YN0ZTRTZUMkZ3ZlltVW5hYXV0cjNEeWMvWjQrdnoreEVqUDFacWU0dVlwYkc3eGM3VzN1YnQraGtmTjB0YmFYV0FpcEthb2FpdXRMbSt5TkRYM3VYcjhQWC9FQ1JCV1c2QWtKK3R1Y1RQMmVMcTh2b0xLVXBuZ0plc3Y5SGg4ZjhKSzA5dWlxTzZ6K1AyRENkSFkzdVFwTGJHMXVUeC9Ra3NVWEdPcU1EVzYvOEhNVnAvb0wvYzl3WXpYNGFxeStvSEwxZDdtN2pVN1FZMFlZbXUwUEFGT1dxWHdPY0ZPMitleXZNRk4yZVR1K0FGUEhHaHp2Z0VRWHF2NEFSRGY3YnFBQUFBQUFBQUFBRGc0T0RnNE9EZzRLQ2dvS0M1dWJteXNxaUdQU1hnNE9EZzRPRGc0UER3OFBEUHo4L0d4cmVRUWlpZ29LQ2dvS0Nnb0xtNXVibkJ3Y0czdDZ5S1FDYnc4UER3OFBEdzhNL1B6OC9Nek16QndiU1BRaWk1dWJtNXVibTV1Y0hCd2NIQndjRzN0NnlLUVNmUHo4L1B6OC9Qejh6TXpNekp5Y204dkxDTlFpakJ3Y0hCd2NIQndjSEJ3Y0hDd3NLNHVLMkxRU2ZNek16TXpNek16TW5KeWNuR3hzYTd1NitNUWlnQVFjS0RBUXU1S1dBQXdBQWdBWUFCSUFDQUFPQUFRQUdnQVVBQW9BQUFBV0FCd0FFSUFHZ0F5QUFvQVlnQktBQ0lBT2dBU0FHb0FVZ0FxQUFJQVdnQnlBRVFBSEFBMEFBd0FaQUJNQUNRQVBBQVVBR3dBVkFBc0FBUUFYQUIwQUVZQUhnQTJBQTRBWmdCT0FDWUFQZ0FXQUc0QVZnQXVBQVlBWGdCMkFFRUFHUUF4QUFrQVlRQkpBQ0VBT1FBUkFHa0FVUUFwQUFFQVdRQnhBRU1BR3dBekFBc0FZd0JMQUNNQU93QVRBR3NBVXdBckFBTUFXd0J6QUVVQUhRQTFBQTBBWlFCTkFDVUFQUUFWQUcwQVZRQXRBQVVBWFFCMUFFY0FId0EzQUE4QVp3QlBBQ2NBUHdBWEFHOEFWd0F2QUFjQVh3QjNBRUJBR0VBd1FBaEFZRUJJUUNCQU9FQVFRR2hBVUVBb1FBQkFXRUJ3UUVKQUdrQXlRQXBBWWtCS1FDSkFPa0FTUUdwQVVrQXFRQUpBV2tCeVFFUkFIRUEwUUF4QVpFQk1RQ1JBUEVBVVFHeEFWRUFzUUFSQVhFQjBRRVpBSGtBMlFBNUFaa0JPUUNaQVBrQVdRRzVBVmtBdVFBWkFYa0IyUUVGQUdVQXhRQWxBWVVCSlFDRkFPVUFSUUdsQVVVQXBRQUZBV1VCeFFFTkFHMEF6UUF0QVkwQkxRQ05BTzBBVFFHdEFVMEFyUUFOQVcwQnpRRVZBSFVBMVFBMUFaVUJOUUNWQVBVQVZRRzFBVlVBdFFBVkFYVUIxUUVkQUgwQTNRQTlBWjBCUFFDZEFQMEFYUUc5QVYwQXZRQWRBWDBCM1FFQ0FHSUF3Z0FpQVlJQklnQ0NBT0lBUWdHaUFVSUFvZ0FDQVdJQndnRUtBR29BeWdBcUFZb0JLZ0NLQU9vQVNnR3FBVW9BcWdBS0FXb0J5Z0VTQUhJQTBnQXlBWklCTWdDU0FQSUFVZ0d5QVZJQXNnQVNBWElCMGdFYUFIb0EyZ0E2QVpvQk9nQ2FBUG9BV2dHNkFWb0F1Z0FhQVhvQjJnRUdBR1lBeGdBbUFZWUJKZ0NHQU9ZQVJnR21BVVlBcGdBR0FXWUJ4Z0VPQUc0QXpnQXVBWTRCTGdDT0FPNEFUZ0d1QVU0QXJnQU9BVzRCemdFV0FIWUExZ0EyQVpZQk5nQ1dBUFlBVmdHMkFWWUF0Z0FXQVhZQjFnRWVBSDRBM2dBK0FaNEJQZ0NlQVA0QVhnRytBVjRBdmdBZUFYNEIzZ0VEQUdNQXd3QWpBWU1CSXdDREFPTUFRd0dqQVVNQW93QURBV01Cd3dFTEFHc0F5d0FyQVlzQkt3Q0xBT3NBU3dHckFVc0Fxd0FMQVdzQnl3RVRBSE1BMHdBekFaTUJNd0NUQVBNQVV3R3pBVk1Bc3dBVEFYTUIwd0ViQUhzQTJ3QTdBWnNCT3dDYkFQc0FXd0c3QVZzQXV3QWJBWHNCMndFSEFHY0F4d0FuQVljQkp3Q0hBT2NBUndHbkFVY0Fwd0FIQVdjQnh3RVBBRzhBendBdkFZOEJMd0NQQU84QVR3R3ZBVThBcndBUEFXOEJ6d0VYQUhjQTF3QTNBWmNCTndDWEFQY0FWd0czQVZjQXR3QVhBWGNCMXdFZkFIOEEzd0EvQVo4QlB3Q2ZBUDhBWHdHL0FWOEF2d0FmQVg4QjN3RUFBSUEvQUFBQWdHUDZmeisvZFZhOGkrbC9Qd3B4MXJ4NXpYOC81ODRndlMrbWZ6ODZYbGE5cjNOL1B4UHloYjM1Tlg4L0txK2d2Ukx0Zmo4elpidTkvWmgrUHdRVDFyMjhPWDQvYzdmd3ZWWFBmVCtvcUFXK3kxbDlQN3Z2RXI0bDJYdy9YREFndm1kTmZELzFhUzIrbUxaN1AvT2JPcjYrRkhzL3dzVkh2dUpuZWovTjVsUytDYkI1UDRMK1liNDg3WGcvVFF4dnZvUWZlRCtjRDN5KzZrWjNQKzZEaEw1M1kzWS9QdnFLdmpaMWRUOTFhcEcrTUh4MFAwelVsNzV4ZUhNL2VqZWV2Z05xY2orM2s2Uys5RkJ4UDd6b3FyNVBMWEEvUVRheHZpSC9iajhCZkxlK2RzWnRQN1M1dmI1ZWcydy9GZS9EdnVjMWF6L2VHOHErSHQ1cFA4ay8wTDRTZkdnL2tscld2dFFQWnovemE5eStkSmxsUDZwejRyNEJHV1EvY1hIb3ZvMk9ZajhIWmU2K0tQcGdQeWRPOUw3bVcxOC9rQ3o2dnRlelhUOEFBQUMvRHdKY1B4dmtBcitnUmxvL2Q4SUZ2NTZCV0QvMm1naS9IYk5XUDNkdEM3OHgyMVEvMmprT3YrLzVVajhBQUJHL2JBOVJQOHEvRTcrOUcwOC9HSGtXdi9nZVRUL05LeG0vTkJsTFA4clhHNytJQ2trLzhYd2V2d3J6Umo4a0d5Ry8wZEpFUDBheUk3LzNxVUkvT2tJbXY1TjRRRC9qeWlpL3ZUNCtQeVZNSzcrUC9Ecy80OFV0dnlLeU9UOEJPREMva0Y4M1AyV2lNci96QkRVLzh3UTF2MldpTWorUVh6ZS9BVGd3UHlLeU9iL2p4UzAvai93N3Z5Vk1Leis5UGo2LzQ4b29QNU40UUw4NlFpWS85NmxDdjBheUl6L1Iwa1MvSkJzaFB3cnpSci94ZkI0L2lBcEp2OHJYR3o4MEdVdS96U3NaUC9nZVRiOFllUlkvdlJ0UHY4cS9FejlzRDFHL0FBQVJQKy81VXIvYU9RNC9NZHRVdjNkdEN6OGRzMWEvOXBvSVA1NkJXTDkzd2dVL29FWmF2eHZrQWo4UEFseS9BQUFBUDllelhiK1FMUG8rNWx0ZnZ5ZE85RDRvK21DL0IyWHVQbzJPWXI5eGNlZytBUmxrdjZwejRqNTBtV1cvODJ2Y1B0UVBaNytTV3RZK0VueG92OGsvMEQ0ZTNtbS8zaHZLUHVjMWE3OFY3OE0rWG9Oc3Y3UzV2VDUyeG0yL0FYeTNQaUgvYnI5Qk5yRStUeTF3djd6b3FqNzBVSEcvdDVPa1BnTnFjcjk2TjU0K2NYaHp2MHpVbHo0d2ZIUy9kV3FSUGpaMWRiOCsrb28rZDJOMnYrNkRoRDdxUm5lL25BOThQb1FmZUw5TkRHOCtQTzE0djRMK1lUNEpzSG0vemVaVVB1Sm5lci9DeFVjK3ZoUjd2L09iT2o2WXRudS85V2t0UG1kTmZMOWNNQ0ErSmRsOHY3dnZFajdMV1gyL3FLZ0ZQbFhQZmI5enQvQTl2RGwrdndRVDFqMzltSDYvTTJXN1BSTHRmcjhxcjZBOStUVi92eFB5aFQydmMzKy9PbDVXUFMrbWY3L256aUE5ZWMxL3Z3cHgxanlMNlgrL3YzVldQR1A2Zjc4QU1JMGtBQUNBdjc5MVZyeGorbisvQ25IV3ZJdnBmNy9uemlDOWVjMS92enBlVnIwdnBuKy9FL0tGdmE5emY3OHFyNkM5K1RWL3Z6Tmx1NzBTN1g2L0JCUFd2ZjJZZnI5enQvQzl2RGwrdjZpb0JiNVZ6MzIvdSs4U3ZzdFpmYjljTUNDK0pkbDh2L1ZwTGI1blRYeS84NXM2dnBpMmU3L0N4VWUrdmhSN3Y4M21WTDdpWjNxL2d2NWh2Z213ZWI5TkRHKytQTzE0djV3UGZMNkVIM2kvN29PRXZ1cEdkNzgrK29xK2QyTjJ2M1Zxa2I0MmRYVy9UTlNYdmpCOGRMOTZONTYrY1hoenY3ZVRwTDREYW5LL3ZPaXF2dlJRY2I5Qk5yRytUeTF3dndGOHQ3NGgvMjYvdExtOXZuYkdiYjhWNzhPK1hvTnN2OTRieXI3bk5XdS95VC9Rdmg3ZWFiK1NXdGErRW54b3YvTnIzTDdVRDJlL3FuUGl2blNaWmI5eGNlaStBUmxrdndkbDdyNk5qbUsvSjA3MHZpajZZTCtRTFBxKzVsdGZ2d0FBQUwvWHMxMi9HK1FDdnc4Q1hMOTN3Z1cvb0VaYXYvYWFDTCtlZ1ZpL2QyMEx2eDJ6VnIvYU9RNi9NZHRVdndBQUViL3YrVksveXI4VHYyd1BVYjhZZVJhL3ZSdFB2ODByR2IvNEhrMi95dGNidnpRWlM3L3hmQjYvaUFwSnZ5UWJJYjhLODBhL1JySWp2OUhTUkw4NlFpYS85NmxDditQS0tMK1RlRUMvSlV3cnY3MCtQci9qeFMyL2ovdzd2d0U0TUw4aXNqbS9aYUl5djVCZk43L3pCRFcvOHdRMXY1QmZONzlsb2pLL0lySTV2d0U0TUwrUC9EdS80OFV0djcwK1ByOGxUQ3UvazNoQXYrUEtLTC8zcVVLL09rSW12OUhTUkw5R3NpTy9Ddk5HdnlRYkliK0lDa20vOFh3ZXZ6UVpTNy9LMXh1LytCNU52ODByR2IrOUcwKy9HSGtXdjJ3UFViL0t2eE8vNy9sU3Z3QUFFYjh4MjFTLzJqa092eDJ6VnI5M2JRdS9ub0ZZdi9hYUNMK2dSbHEvZDhJRnZ3OENYTDhiNUFLLzE3TmR2d0FBQUwvbVcxKy9rQ3o2dmlqNllMOG5UdlMralk1aXZ3ZGw3cjRCR1dTL2NYSG92blNaWmIrcWMrSysxQTludi9OcjNMNFNmR2kva2xyV3ZoN2VhYi9KUDlDKzV6VnJ2OTRieXI1ZWcyeS9GZS9Edm5iR2JiKzB1YjIrSWY5dXZ3Rjh0NzVQTFhDL1FUYXh2dlJRY2IrODZLcStBMnB5djdlVHBMNXhlSE8vZWplZXZqQjhkTDlNMUplK05uVjF2M1Zxa2I1M1kzYS9QdnFLdnVwR2Q3L3VnNFMraEI5NHY1d1BmTDQ4N1hpL1RReHZ2Z213ZWIrQy9tRys0bWQ2djgzbVZMNitGSHUvd3NWSHZwaTJlNy96bXpxK1owMTh2L1ZwTGI0bDJYeS9YREFndnN0WmZiKzc3eEsrVmM5OXY2aW9CYjY4T1g2L2M3Znd2ZjJZZnI4RUU5YTlFdTErdnpObHU3MzVOWCsvS3ErZ3ZhOXpmNzhUOG9XOUw2Wi92enBlVnIxNXpYKy81ODRndll2cGY3OEtjZGE4WS9wL3Y3OTFWcndBQUlDL0FEQU5wV1A2ZjcrL2RWWThpK2wvdndweDFqeDV6WCsvNTg0Z1BTK21mNzg2WGxZOXIzTi92eFB5aFQzNU5YKy9LcStnUFJMdGZyOHpaYnM5L1poK3Z3UVQxajI4T1g2L2M3ZndQVlhQZmIrb3FBVSt5MWw5djd2dkVqNGwyWHkvWERBZ1BtZE5mTC8xYVMwK21MWjd2L09iT2o2K0ZIdS93c1ZIUHVKbmVyL041bFErQ2JCNXY0TCtZVDQ4N1hpL1RReHZQb1FmZUwrY0Qzdys2a1ozdis2RGhENTNZM2EvUHZxS1BqWjFkYjkxYXBFK01IeDB2MHpVbHo1eGVITy9lamVlUGdOcWNyKzNrNlErOUZCeHY3em9xajVQTFhDL1FUYXhQaUgvYnI4QmZMYytkc1p0djdTNXZUNWVnMnkvRmUvRFB1YzFhNy9lRzhvK0h0NXB2OGsvMEQ0U2ZHaS9rbHJXUHRRUFo3L3phOXcrZEpsbHY2cHo0ajRCR1dTL2NYSG9QbzJPWXI4SFplNCtLUHBndnlkTzlEN21XMSsva0N6NlB0ZXpYYjhBQUFBL0R3SmN2eHZrQWorZ1JscS9kOElGUDU2QldMLzJtZ2cvSGJOV3YzZHRDejh4MjFTLzJqa09QKy81VXI4QUFCRS9iQTlSdjhxL0V6KzlHMCsvR0hrV1AvZ2VUYi9OS3hrL05CbEx2OHJYR3orSUNrbS84WHdlUHdyelJyOGtHeUUvMGRKRXYwYXlJei8zcVVLL09rSW1QNU40UUwvanlpZy92VDQrdnlWTUt6K1AvRHUvNDhVdFB5S3lPYjhCT0RBL2tGODN2MldpTWovekJEVy84d1ExUDJXaU1yK1FYemMvQVRnd3Z5S3lPVC9qeFMyL2ovdzdQeVZNSzcrOVBqNC80OG9vdjVONFFEODZRaWEvOTZsQ1AwYXlJNy9SMGtRL0pCc2h2d3J6UmoveGZCNi9pQXBKUDhyWEc3ODBHVXMvelNzWnYvZ2VUVDhZZVJhL3ZSdFBQOHEvRTc5c0QxRS9BQUFSdisvNVVqL2FPUTYvTWR0VVAzZHRDNzhkczFZLzlwb0l2NTZCV0Q5M3dnVy9vRVphUHh2a0FyOFBBbHcvQUFBQXY5ZXpYVCtRTFBxKzVsdGZQeWRPOUw0byttQS9CMlh1dm8yT1lqOXhjZWkrQVJsa1A2cHo0cjUwbVdVLzgydmN2dFFQWnorU1d0YStFbnhvUDhrLzBMNGUzbWsvM2h2S3Z1YzFhejhWNzhPK1hvTnNQN1M1dmI1MnhtMC9BWHkzdmlIL2JqOUJOckcrVHkxd1A3em9xcjcwVUhFL3Q1T2t2Z05xY2o5Nk41NitjWGh6UDB6VWw3NHdmSFEvZFdxUnZqWjFkVDgrK29xK2QyTjJQKzZEaEw3cVJuYy9uQTk4dm9RZmVEOU5ERysrUE8xNFA0TCtZYjRKc0hrL3plWlV2dUpuZWovQ3hVZSt2aFI3UC9PYk9yNll0bnMvOVdrdHZtZE5mRDljTUNDK0pkbDhQN3Z2RXI3TFdYMC9xS2dGdmxYUGZUOXp0L0M5dkRsK1B3UVQxcjM5bUg0L00yVzd2Ukx0Zmo4cXI2QzkrVFYvUHhQeWhiMnZjMzgvT2w1V3ZTK21mei9uemlDOWVjMS9Qd3B4MXJ5TDZYOC92M1ZXdkdQNmZ6OEF5Rk9sQUFDQVA3OTFWanhqK244L0NuSFdQSXZwZnovbnppQTllYzEvUHpwZVZqMHZwbjgvRS9LRlBhOXpmejhxcjZBOStUVi9Qek5sdXowUzdYNC9CQlBXUGYyWWZqOXp0L0E5dkRsK1A2aW9CVDVWejMwL3UrOFNQc3RaZlQ5Y01DQStKZGw4UC9WcExUNW5UWHcvODVzNlBwaTJlei9DeFVjK3ZoUjdQODNtVkQ3aVozby9ndjVoUGdtd2VUOU5ERzgrUE8xNFA1d1BmRDZFSDNnLzdvT0VQdXBHZHo4KytvbytkMk4yUDNWcWtUNDJkWFUvVE5TWFBqQjhkRDk2TjU0K2NYaHpQN2VUcEQ0RGFuSS92T2lxUHZSUWNUOUJOckUrVHkxd1B3Rjh0ejRoLzI0L3RMbTlQbmJHYlQ4Vjc4TStYb05zUDk0YnlqN25OV3MveVQvUVBoN2VhVCtTV3RZK0VueG9QL05yM0Q3VUQyYy9xblBpUG5TWlpUOXhjZWcrQVJsa1B3ZGw3ajZOam1JL0owNzBQaWo2WUQrUUxQbys1bHRmUHdBQUFEL1hzMTAvRytRQ1B3OENYRDkzd2dVL29FWmFQL2FhQ0QrZWdWZy9kMjBMUHgyelZqL2FPUTQvTWR0VVB3QUFFVC92K1ZJL3lyOFRQMndQVVQ4WWVSWS92UnRQUDgwckdULzRIazAveXRjYlB6UVpTei94ZkI0L2lBcEpQeVFiSVQ4SzgwWS9ScklqUDlIU1JEODZRaVkvOTZsQ1ArUEtLRCtUZUVBL0pVd3JQNzArUGovanhTMC9qL3c3UHdFNE1EOGlzamsvWmFJeVA1QmZOei96QkRVLzh3UTFQNUJmTno5bG9qSS9Jckk1UHdFNE1EK1AvRHMvNDhVdFA3MCtQajhsVENzL2szaEFQK1BLS0QvM3FVSS9Pa0ltUDlIU1JEOUdzaU0vQ3ZOR1B5UWJJVCtJQ2trLzhYd2VQelFaU3ovSzF4cy8rQjVOUDgwckdUKzlHMDgvR0hrV1Ayd1BVVC9LdnhNLzcvbFNQd0FBRVQ4eDIxUS8yamtPUHgyelZqOTNiUXMvbm9GWVAvYWFDRCtnUmxvL2Q4SUZQdzhDWEQ4YjVBSS8xN05kUHdBQUFEL21XMTgva0N6NlBpajZZRDhuVHZRK2pZNWlQd2RsN2o0QkdXUS9jWEhvUG5TWlpUK3FjK0krMUE5blAvTnIzRDRTZkdnL2tscldQaDdlYVQvSlA5QSs1elZyUDk0YnlqNWVnMncvRmUvRFBuYkdiVCswdWIwK0lmOXVQd0Y4dHo1UExYQS9RVGF4UHZSUWNUKzg2S28rQTJweVA3ZVRwRDV4ZUhNL2VqZWVQakI4ZEQ5TTFKYytOblYxUDNWcWtUNTNZM1kvUHZxS1B1cEdkei91ZzRRK2hCOTRQNXdQZkQ0ODdYZy9UUXh2UGdtd2VUK0MvbUUrNG1kNlA4M21WRDYrRkhzL3dzVkhQcGkyZXovem16bytaMDE4UC9WcExUNGwyWHcvWERBZ1BzdFpmVCs3N3hJK1ZjOTlQNmlvQlQ2OE9YNC9jN2Z3UGYyWWZqOEVFOVk5RXUxK1B6Tmx1ejM1Tlg4L0txK2dQYTl6Zno4VDhvVTlMNlovUHpwZVZqMTV6WDgvNTg0Z1BZdnBmejhLY2RZOFkvcC9QNzkxVmp3QUFEQUFZQUNRQU1BQUVBQkFBSEFBb0FEUUFDQUFVQUNBQUxBQTRBQUVBRFFBWkFDVUFNUUFGQUJFQUhRQXBBRFVBQ1FBVkFDRUFMUUE1QUFJQURnQWFBQ1lBTWdBR0FCSUFIZ0FxQURZQUNnQVdBQ0lBTGdBNkFBTUFEd0FiQUNjQU13QUhBQk1BSHdBckFEY0FDd0FYQUNNQUx3QTdBQUJBREVBWVFDUkFNRUFFUUJCQUhFQW9RRFJBQ0VBVVFDQkFMRUE0UUFGQURVQVpRQ1ZBTVVBRlFCRkFIVUFwUURWQUNVQVZRQ0ZBTFVBNVFBSkFEa0FhUUNaQU1rQUdRQkpBSGtBcVFEWkFDa0FXUUNKQUxrQTZRQU5BRDBBYlFDZEFNMEFIUUJOQUgwQXJRRGRBQzBBWFFDTkFMMEE3UUFDQURJQVlnQ1NBTUlBRWdCQ0FISUFvZ0RTQUNJQVVnQ0NBTElBNGdBR0FEWUFaZ0NXQU1ZQUZnQkdBSFlBcGdEV0FDWUFWZ0NHQUxZQTVnQUtBRG9BYWdDYUFNb0FHZ0JLQUhvQXFnRGFBQ29BV2dDS0FMb0E2Z0FPQUQ0QWJnQ2VBTTRBSGdCT0FINEFyZ0RlQUM0QVhnQ09BTDRBN2dBREFETUFZd0NUQU1NQUV3QkRBSE1Bb3dEVEFDTUFVd0NEQUxNQTR3QUhBRGNBWndDWEFNY0FGd0JIQUhjQXB3RFhBQ2NBVndDSEFMY0E1d0FMQURzQWF3Q2JBTXNBR3dCTEFIc0Fxd0RiQUNzQVd3Q0xBTHNBNndBUEFEOEFid0NmQU04QUh3QlBBSDhBcndEZkFDOEFYd0NQQUw4QTd3RHdBQUFBaVlpSU93RUFBQUFGQURBQUF3QVFBQVFBQkFBRUFBRUFRWXl0QVFzR2dGUUFBSUJGQUVHaXJRRUxpUUlZQURBQVNBQmdBQWdBSUFBNEFGQUFhQUFRQUNnQVFBQllBSEFBQkFBY0FEUUFUQUJrQUF3QUpBQThBRlFBYkFBVUFDd0FSQUJjQUhRQUFRQVpBREVBU1FCaEFBa0FJUUE1QUZFQWFRQVJBQ2tBUVFCWkFIRUFCUUFkQURVQVRRQmxBQTBBSlFBOUFGVUFiUUFWQUMwQVJRQmRBSFVBQWdBYUFESUFTZ0JpQUFvQUlnQTZBRklBYWdBU0FDb0FRZ0JhQUhJQUJnQWVBRFlBVGdCbUFBNEFKZ0ErQUZZQWJnQVdBQzRBUmdCZUFIWUFBd0FiQURNQVN3QmpBQXNBSXdBN0FGTUFhd0FUQUNzQVF3QmJBSE1BQndBZkFEY0FUd0JuQUE4QUp3QS9BRmNBYndBWEFDOEFSd0JmQUhjQWVBQUFBSWlJQ0R3Q0FBQUFCUUFZQUFNQUNBQUNBQVFBQkFBQkFFRzhyd0VMQnFCV0FBQ0FSUUJCMHE4QkM0MEJEQUFZQUNRQU1BQUVBQkFBSEFBb0FEUUFDQUFVQUNBQUxBQTRBQUVBRFFBWkFDVUFNUUFGQUJFQUhRQXBBRFVBQ1FBVkFDRUFMUUE1QUFJQURnQWFBQ1lBTWdBR0FCSUFIZ0FxQURZQUNnQVdBQ0lBTGdBNkFBTUFEd0FiQUNjQU13QUhBQk1BSHdBckFEY0FDd0FYQUNNQUx3QTdBRHdBQUFDSmlJZzhBd0FBQUFVQURBQURBQVFBQkFBQkFFSDBzQUVMVGRCWEFBQ0FSUUFBQUFBQUFNQllBQUNBV3dBQVBGNEFBUFJnQUFDb1l3QUFXR1lBQUFScEFBQnNhZ0FBS0dzQUFKeHJBQURvYXdBQUlHd0FBRUJzQUFCWWJBQUFaR3dBQUFBQUFBQUJBRUdFdHdFTG9DTUJBQUFBQVFBQUFBRUFBQUFCQUFBQUFRQUFBQUVBQUFBQkFBQUFBUUFBQUFFQUFBQUJBQUFBQVFBQUFBRUFBQUFCQUFBQUFRQUFBQUVBQUFBQkFBQUFBUUFBQUFFQUFBQUJBQUFBQVFBQUFBRUFBQUFCQUFBQUFRQUFBQUVBQUFBQkFBQUFBUUFBQUFFQUFBQUJBQUFBQVFBQUFBRUFBQUFCQUFBQUFRQUFBQUVBQUFBQkFBQUFBUUFBQUFFQUFBQUJBQUFBQVFBQUFBRUFBQUFCQUFBQUFRQUFBQUVBQUFBQkFBQUFBUUFBQUFFQUFBQUJBQUFBQVFBQUFBRUFBQUFCQUFBQUFRQUFBQUVBQUFBQkFBQUFBUUFBQUFFQUFBQUJBQUFBQVFBQUFBRUFBQUFCQUFBQUFRQUFBQUVBQUFBQkFBQUFBUUFBQUFFQUFBQUJBQUFBQVFBQUFBRUFBQUFCQUFBQUFRQUFBQUVBQUFBQkFBQUFBUUFBQUFFQUFBQUJBQUFBQVFBQUFBRUFBQUFCQUFBQUFRQUFBQUVBQUFBQkFBQUFBUUFBQUFFQUFBQUJBQUFBQVFBQUFBRUFBQUFCQUFBQUFRQUFBQUVBQUFBQkFBQUFBUUFBQUFFQUFBQUJBQUFBQVFBQUFBRUFBQUFCQUFBQUFRQUFBQUVBQUFBQkFBQUFBUUFBQUFFQUFBQUJBQUFBQVFBQUFBRUFBQUFCQUFBQUFRQUFBQUVBQUFBQkFBQUFBUUFBQUFFQUFBQUJBQUFBQVFBQUFBRUFBQUFCQUFBQUFRQUFBQUVBQUFBQkFBQUFBUUFBQUFFQUFBQUJBQUFBQVFBQUFBRUFBQUFCQUFBQUFRQUFBQUVBQUFBQkFBQUFBUUFBQUFFQUFBQUJBQUFBQVFBQUFBRUFBQUFCQUFBQUFRQUFBQUVBQUFBQkFBQUFBUUFBQUFFQUFBQUJBQUFBQVFBQUFBRUFBQUFCQUFBQUFRQUFBQUVBQUFBQkFBQUFBUUFBQUFFQUFBQUJBQUFBQVFBQUFBRUFBQUFCQUFBQUFRQUFBQUVBQUFBQkFBQUFBUUFBQUFFQUFBQUJBQUFBQVFBQUFBRUFBQUFCQUFBQUFRQUFBQUVBQUFBQkFBQUFBUUFBQUFFQUFBQUJBQUFBQVFBQUFBRUFBQUFCQUFBQUFRQUFBQUVBQUFBQkFBQUFBUUFBQUFFQUFBQUJBQUFBQVFBQUFBRUFBQUFCQUFBQUFRQUFBQU1BQUFBRkFBQUFCd0FBQUFrQUFBQUxBQUFBRFFBQUFBOEFBQUFSQUFBQUV3QUFBQlVBQUFBWEFBQUFHUUFBQUJzQUFBQWRBQUFBSHdBQUFDRUFBQUFqQUFBQUpRQUFBQ2NBQUFBcEFBQUFLd0FBQUMwQUFBQXZBQUFBTVFBQUFETUFBQUExQUFBQU53QUFBRGtBQUFBN0FBQUFQUUFBQUQ4QUFBQkJBQUFBUXdBQUFFVUFBQUJIQUFBQVNRQUFBRXNBQUFCTkFBQUFUd0FBQUZFQUFBQlRBQUFBVlFBQUFGY0FBQUJaQUFBQVd3QUFBRjBBQUFCZkFBQUFZUUFBQUdNQUFBQmxBQUFBWndBQUFHa0FBQUJyQUFBQWJRQUFBRzhBQUFCeEFBQUFjd0FBQUhVQUFBQjNBQUFBZVFBQUFIc0FBQUI5QUFBQWZ3QUFBSUVBQUFDREFBQUFoUUFBQUljQUFBQ0pBQUFBaXdBQUFJMEFBQUNQQUFBQWtRQUFBSk1BQUFDVkFBQUFsd0FBQUprQUFBQ2JBQUFBblFBQUFKOEFBQUNoQUFBQW93QUFBS1VBQUFDbkFBQUFxUUFBQUtzQUFBQ3RBQUFBcndBQUFMRUFBQUN6QUFBQXRRQUFBTGNBQUFDNUFBQUF1d0FBQUwwQUFBQy9BQUFBd1FBQUFNTUFBQURGQUFBQXh3QUFBTWtBQUFETEFBQUF6UUFBQU04QUFBRFJBQUFBMHdBQUFOVUFBQURYQUFBQTJRQUFBTnNBQUFEZEFBQUEzd0FBQU9FQUFBRGpBQUFBNVFBQUFPY0FBQURwQUFBQTZ3QUFBTzBBQUFEdkFBQUE4UUFBQVBNQUFBRDFBQUFBOXdBQUFQa0FBQUQ3QUFBQS9RQUFBUDhBQUFBQkFRQUFBd0VBQUFVQkFBQUhBUUFBQ1FFQUFBc0JBQUFOQVFBQUR3RUFBQkVCQUFBVEFRQUFGUUVBQUJjQkFBQVpBUUFBR3dFQUFCMEJBQUFmQVFBQUlRRUFBQ01CQUFBbEFRQUFKd0VBQUNrQkFBQXJBUUFBTFFFQUFDOEJBQUF4QVFBQU13RUFBRFVCQUFBM0FRQUFPUUVBQURzQkFBQTlBUUFBUHdFQUFFRUJBQUJEQVFBQVJRRUFBRWNCQUFCSkFRQUFTd0VBQUUwQkFBQlBBUUFBVVFFQUFGTUJBQUJWQVFBQVZ3RUFBRmtCQUFCYkFRQUFYUUVBQUY4QkFBQU5BQUFBR1FBQUFDa0FBQUE5QUFBQVZRQUFBSEVBQUFDUkFBQUF0UUFBQU4wQUFBQUpBUUFBT1FFQUFHMEJBQUNsQVFBQTRRRUFBQ0VDQUFCbEFnQUFyUUlBQVBrQ0FBQkpBd0FBblFNQUFQVURBQUJSQkFBQXNRUUFBQlVGQUFCOUJRQUE2UVVBQUZrR0FBRE5CZ0FBUlFjQUFNRUhBQUJCQ0FBQXhRZ0FBRTBKQUFEWkNRQUFhUW9BQVAwS0FBQ1ZDd0FBTVF3QUFORU1BQUIxRFFBQUhRNEFBTWtPQUFCNUR3QUFMUkFBQU9VUUFBQ2hFUUFBWVJJQUFDVVRBQUR0RXdBQXVSUUFBSWtWQUFCZEZnQUFOUmNBQUJFWUFBRHhHQUFBMVJrQUFMMGFBQUNwR3dBQW1Sd0FBSTBkQUFDRkhnQUFnUjhBQUlFZ0FBQ0ZJUUFBalNJQUFKa2pBQUNwSkFBQXZTVUFBTlVtQUFEeEp3QUFFU2tBQURVcUFBQmRLd0FBaVN3QUFMa3RBQUR0TGdBQUpUQUFBR0V4QUFDaE1nQUE1VE1BQUMwMUFBQjVOZ0FBeVRjQUFCMDVBQUIxT2dBQTBUc0FBREU5QUFDVlBnQUEvVDhBQUdsQkFBRFpRZ0FBVFVRQUFNVkZBQUJCUndBQXdVZ0FBRVZLQUFETlN3QUFXVTBBQU9sT0FBQjlVQUFBRlZJQUFMRlRBQUJSVlFBQTlWWUFBSjFZQUFCSldnQUErVnNBQUsxZEFBQmxYd0FBSVdFQUFPRmlBQUNsWkFBQWJXWUFBRGxvQUFBSmFnQUEzV3NBQUxWdEFBQ1Jid0FBY1hFQUFGVnpBQUE5ZFFBQUtYY0FBQmw1QUFBTmV3QUFCWDBBQUFGL0FBQUJnUUFBQllNQUFBMkZBQUFaaHdBQUtZa0FBRDJMQUFCVmpRQUFjWThBQUpHUkFBQzFrd0FBM1pVQUFBbVlBQUE1bWdBQWJad0FBS1dlQUFEaG9BQUFJYU1BQUdXbEFBQ3Rwd0FBK2FrQUFFbXNBQUNkcmdBQTliQUFBRkd6QUFDeHRRQUFGYmdBQUgyNkFBRHB2QUFBV2I4QUFNM0JBQUJGeEFBQXdjWUFBRUhKQUFERnl3QUFUYzRBQU5uUUFBQnAwd0FBL2RVQUFKWFlBQUF4MndBQTBkMEFBSFhnQUFBZDR3QUF5ZVVBQUhub0FBQXQ2d0FBNWUwQUFLSHdBQUEvQUFBQWdRQUFBT2NBQUFCNUFRQUFQd0lBQUVFREFBQ0hCQUFBR1FZQUFQOEhBQUJCQ2dBQTV3d0FBUGtQQUFCL0V3QUFnUmNBQUFjY0FBQVpJUUFBdnlZQUFBRXRBQURuTXdBQWVUc0FBTDlEQUFEQlRBQUFoMVlBQUJsaEFBQi9iQUFBd1hnQUFPZUZBQUQ1a3dBQS82SUFBQUd6QUFBSHhBQUFHZFlBQUQvcEFBQ0IvUUFBNXhJQkFIa3BBUUEvUVFFQVFWb0JBSWQwQVFBWmtBRUEvNndCQUVITEFRRG42Z0VBK1FzQ0FIOHVBZ0NCVWdJQUIzZ0NBQm1mQWdDL3h3SUFBZklDQU9jZEF3QjVTd01BdjNvREFNR3JBd0NIM2dNQUdSTUVBSDlKQkFEQmdRUUE1N3NFQVBuM0JBRC9OUVVBQVhZRkFBZTRCUUFaL0FVQVAwSUdBSUdLQmdEbjFBWUFlU0VIQUQ5d0J3QkJ3UWNBaHhRSUFCbHFDQUQvd1FnQVFSd0pBT2Q0Q1FENTF3a0FmemtLQUlHZENnQUhCQXNBR1cwTEFML1lDd0FCUnd3QTU3Y01BSGtyRFFDL29RMEF3Um9PQUllV0RnQVpGUThBZjVZUEFNRWFFQURub1JBQStTc1JBUCs0RVFBQlNSSUFCOXdTQUJseUV3QS9DeFFBZ2FjVUFPZEdGUUI1NlJVQVA0OFdBRUU0RndDSDVCY0FHWlFZQVA5R0dRQkIvUmtBNTdZYUFQbHpHd0IvTkJ3QWdmZ2NBQWZBSFFBWml4NEF2MWtmQUFFc0lBRG5BU0VBZWRzaEFMKzRJZ0RCbVNNQWgzNGtBQmxuSlFCL1V5WUF3VU1uQU9jM0tBRDVMeWtBL3lzcUFBRXNLd0FITUN3QUdUZ3RBRDlFTGdDQlZDOEE1Mmd3QUhtQk1RQS9uaklBUWI4ekFJZmtOQUFaRGpZQS96czNBRUZ1T0FEbnBEa0ErZDg2QUg4ZlBBQ0JZejBBQjZ3K0FCbjVQd0MvU2tFQUFhRkNBT2Y3UXdCNVcwVUF2NzlHQU1Fb1NBQ0hsa2tBR1FsTEFIK0FUQURCL0UwQTUzMVBBUGtEVVFEL2psSUFBUjlVQUFlMFZRQVpUbGNBUCsxWUFJR1JXZ0RuT2x3QWVlbGRBRCtkWHdCQlZtRUFoeFJqQUJuWVpBRC9vR1lBUVc5b0FPZENhZ0Q1RzJ3QWYvcHRBRUVCQUFDcEFnQUFDUVVBQU1FSUFBQkJEZ0FBQ1JZQUFLa2dBQURCTGdBQUFVRUFBQ2xZQUFBSmRRQUFnWmdBQUlIREFBQUo5d0FBS1RRQkFBRjhBUURCendFQXFUQUNBQW1nQWdCQkh3TUF3YThEQUFsVEJBQ3BDZ1VBUWRnRkFJRzlCZ0FwdkFjQUNkWUlBQUVOQ2dBQll3c0FDZG9NQUNsMERnQ0JNeEFBUVJvU0FLa3FGQUFKWnhZQXdkRVlBRUZ0R3dBSlBCNEFxVUFoQU1GOUpBQUI5aWNBS2F3ckFBbWpMd0NCM1RNQWdWNDRBQWtwUFFBcFFFSUFBYWRIQU1GZ1RRQ3BjRk1BQ2RwWkFFR2dZQURCeG1jQUNWRnZBS2xDZHdCQm4zOEFnV3FJQUNtb2tRQUpYSnNBQVlxbEFBRTJzQUFKWkxzQUtSakhBSUZXMHdCQkkrQUFxWUx0QUFsNSt3REJDZ29CUVR3WkFRa1NLUUdwa0RrQndieEtBUUdiWEFFcE1HOEJDWUdDQVlHU2xnR0JhYXNCQ1F2QkFTbDgxd0VCd3U0QndlRUdBcW5nSHdJSnhEa0NRWkZVQXNGTmNBSUovNHdDcWFxcUFrRld5UUtCQitrQ0tjUUpBd21TS3dNQmQwNERBWGx5QXdtZWx3TXA3TDBEZ1dubEEwRWNEZ1NwQ2pnRUNUdGpCTUd6andSQmU3MEVDWmpzQktrUUhRWEI2MDRGQVRDQ0JTbmt0Z1VKRCswRmdiY2tCb0hrWFFZSm5aZ0dLZWpVQmdITkVnZkJVbElIcVlDVEJ3bGUxZ2RCOGhvSXdVUmhDQWxkcVFpcFF2TUlRZjArQ1lHVWpBa3BFTndKQ1hndENnSFVnQW9CTE5ZS0NZZ3RDeW53aGd1QmJPSUxRUVZBREtuQ253d0pyUUVOd2N4bERVRXF6QTBKempRT3FjQ2ZEc0VLRFE4QnRYd1BLY2p1RHdsTll4Q0JUTm9RZ2M5VEVRbmZ6eEVwaEU0U0FjalBFc0d6VXhPcFVOb1RDYWhqRkVIRDd4VEJxMzRWQ1dzUUZxa0twUlpCbER3WGdSSFhGeW1NZEJnSkRoVVpBYUc0R1FGUFh4b0pJZ2tiS1NTMkc0RmZaaHhCM2hrZHFhclFIUW5QaWg3QlZVZ2ZRVWtKSUFtMHpTQ3BvSlVod1JsaElnRXFNQ01wM0FJa0NUdlpKSUZSc3lXVEJnQUFSUTRBQUE4Y0FBQVJNd0FBVzFjQUFBMk9BQUIzM1FBQU9VMEJBR1BtQVFDVnN3SUFIOEVEQUNFZEJRQ3Ixd1lBM1FJSkFBZXpDd0RKL2c0QU0vOFNBT1hQRndBdmp4MEFNVjRrQVB0Z0xBQ3R2alVBbDZGQUFGazNUUUFEc1ZzQU5VTnNBRDhtZndCQmxwUUFTOU9zQUgwaHlBQW55ZVlBNlJZSkFkTmJMd0dGN1ZrQlR5YUpBVkZsdlFHYkR2Y0JUWXMyQXJkSmZBSjV2Y2dDbzE4Y0E5V3Vkd05mTDlzRFlXdEhCT3Z5dkFRZFhEd0ZSMFBHQlFsTFd3WnpIUHdHSldlcEIyL2hZd2h4U0N3Sk8yQURDdTN6NlFyWDFlQUxtZC9vREVQeUFnNTE5aThQZjl4d0VJR2N4aEdMTmpJVHZiSzBGR2NoVHhZcG13SVlFMEhRR2NVOHVSdVB3TDRka1FmaUg5dFZKQ0tOK0lZazkwVUxKN21kc2luamFINHNGUnB3TDU4dGlUS2hLY3MxSzU0M09WMGwwRHlIWTVaQVNRZU1STFBKc2tobGJneE5yOE9hVWJHaVgxWjc3MXhiTFptVVlCZWFDR2JaOTdwcmc4T3RjYlVaNDNlL0lsMStIU01BQUhGTkFBQ1JuQUFBL1NZQkFHVU1BZ0RwZHdNQW1hSUZBRFhXQ0FBdGNBMEE0ZVFUQUNIREhBRHR0eWdBZFpJNEFGbElUUUFwK21jQUpmaUpBRDNIdEFCUkp1b0FzUk1zQWQzU2ZBR0Y4dDRCeVZKVkFya3I0d0lWRkl3RFRRaFVCTUZ4UHdWQkxsTUd6WmVVQjVXTUNRazVkN2dLU1Zlb0RBWEs0QTVkRTJvUk1TZE5GTkd5a3hlOUprZ2JwY0IxSDZtVktDVFpuRzBwOWJsU0wyM0k1aldocGprOVlVRmNSYTJmWUU2MTdsbFlHWTVjWTJrY2ZtL2xnOVY4LzcwQUFBR29BUUNQYXdNQThaNEdBRDhqREFEQlBSVUFqN1lqQVBIOE9RRC9VVnNBQWZxTEFBOTEwUUJ4dnpJQlA1cTRBY0hjYlFJUHoxOERjWTZlQlA5N1BRWUJ0bE1JajV6OEN2RmhXQTQvcDR3U3dTWEZGNDlsTkI3eGdSUW0vL3VuTHdHY09qc1BZaUpKY1liQVdUK0tnbTNCV09PRUFRNEVBSkVoQ1FBUkxCTUFRZTRsQUVGUFJ3Q1JRNEFBRWZmZEFBRkdjd0VCa2xvQ0VRRzRBNUUxdkFWQmo2Y0lRUWJPREJHeW14S1JENW9hQVJwMkpRRk1CelNSbmxkSEVaMnNZRUdta1lFalVSWUF4WjR5QUJlNWF3Q1o5dGdBYTRtZ0FRM0UvZ0lmQVZBRklka2RDVE5zTUEvVm9xUVlwMmNJSnluOWZUeDd0ZWRiSFhjZGlhK2dMY210am5zQWllWVpBVG1XWGdJOUZ0Z0V0V04zQ2VFb3hoRWhBelFnZFVpQ09IMVhWMkMvVzY4Q2dkZ25CdmVFWGczcC9xMGJmNHZyTm9HMzVXZ1hBNXpCd1F6L0RqbHFoU0laN3BGTGdYZ3JualBoQ1ZTVml3QUFONWdBQVArbEFBQUV0UUFBWjhVQUFFWFhBQURCNmdBQS8vOEFBQUFBemtBQUFNaEFBQUM0UUFBQXFrQUFBS0pBQUFDYVFBQUFrRUFBQUl4QUFBQ2NRQUFBbGtBQUFKSkFBQUNPUUFBQW5FQUFBSlJBQUFDS1FBQUFrRUFBQUl4QUFBQ1VRQUFBbUVBQUFJNUFBQUJ3UUFBQWNFQUFBSEJBQUFCd1FBQUFjRUFBUWJEYUFRdnlBa2gvUVlGQ2dFR0FRSUErZ0VDQVFJQmNUbHhQWEU1YVQzUXBjeWh5S0lRYWhCcVJFYUVNc0FxeEN4aXpNSW8yaHphRU5ZWTRoVGVFTjRROWNrWmdTbGhMV0ZkS1dVSmJRMlE3YkRKNEtIb2xZU3RPTWxOT1ZGRllTMVpLVjBkYVNWMUtYVXB0S0hJa2RTSjFJbzhSa1JLU0U2SU1wUXF5QjcwR3ZnaXhDUmV5Tm5NL1prSmlSV05LV1VkYlNWdE9XVlpRWEVKZFFHWTdaenhvUEhVMGV5eUtJNFVmWVNaTkxUMWFYVHhwS21zcGJpMTBKbkVtY0NaOEdvUWJpQk9NRkpzT254Q2VFcW9Oc1FxN0NNQUdyd21mQ2hXeU8yNUhWa3RWVkZOYlFsaEpWMGhjUzJKSWFUcHJObk0wY2pkd09JRXpoQ2lXSVl3ZFlpTk5LaXA1WUVKc0syOG9kU3g3SUhna2R5Ri9JWVlpaXhXVEY1Z1VuaG1hR3FZVnJSQzREYmdLbGcyTER4YXlQM0pLVWxSVFhGSm5QbUJJWUVObFNXdEljVGQyTkgwMGRqUjFONGN4aVNlZElKRWRZU0ZOS0FBQVpqOEFBRXcvQUFBbVB3QUFBRDhBaG1zL0FCUXVQd0J3dlQ0QTBFdytBZ0VBUWJIZEFRc2dDQTBRRXhVWEdCb2JIQjBlSHlBZ0lTSWlJeVFrSlNVUEFBQUFDZ0FBQUFVQVFlYmRBUXZoRmVBL0FBQUFBQUFBNEw4REFBQUFCQUFBQUFRQUFBQUdBQUFBZy9taUFFUk9iZ0Q4S1JVQTBWY25BTjAwOVFCaTI4QUFQSm1WQUVHUVF3QmpVZjRBdTk2ckFMZGh4UUE2YmlRQTBrMUNBRWtHNEFBSjZpNEFISkxSQU9zZC9nQXBzUndBNkQ2bkFQVTFnZ0JFdXk0QW5PbUVBTFFtY0FCQmZsOEExcEU1QUZPRE9RQ2M5RGtBaTErRUFDajV2UUQ0SHpzQTN2K1hBQStZQlFBUkwrOEFDbHFMQUcwZmJRRFBmallBQ2NzbkFFWlB0d0NlWmo4QUxlcGZBTG9uZFFEbDY4Y0FQWHZ4QVBjNUJ3Q1NVb29BKzJ2cUFCK3hYd0FJWFkwQU1BTldBSHY4UmdEd3Eyc0FJTHpQQURiMG1nRGpxUjBBWG1HUkFBZ2I1Z0NGbVdVQW9CUmZBSTFBYUFDQTJQOEFKM05OQUFZR01RREtWaFVBeWFoekFIdmlZQUJyak1BQUdjUkhBTTFud3dBSjZOd0FXWU1xQUl0MnhBQ21ISllBUksvZEFCbFgwUUNsUGdVQUJRZi9BRE4rUHdEQ011Z0FtRS9lQUx0OU1nQW1QY01BSG12dkFKLzRYZ0ExSHpvQWYvTEtBUEdISFFCOGtDRUFhaVI4QU5WdStnQXdMWGNBRlR0REFMVVV4Z0RER1owQXJjVENBQ3hOUVFBTUFGMEFobjFHQU9OeExRQ2J4cG9BTTJJQUFMVFNmQUMwcDVjQU4xWFZBTmMrOWdDakVCZ0FUWGI4QUdTZEtnQncxNnNBWTN6NEFIcXdWd0FYRmVjQXdFbFdBRHZXMlFDbmhEZ0FKQ1BMQU5hS2R3QmFWQ01BQUIrNUFQRUtHd0FaenQ4QW56SC9BR1llYWdDWlYyRUFyUHRIQUg1LzJBQWlaYmNBTXVpSkFPYS9ZQUR2eE0wQWJEWUpBRjAvMUFBVzN0Y0FXRHZlQU42YmtnRFNJaWdBS0lib0FPSllUUURHeWpJQUNPTVdBT0I5eXdBWHdGQUE4eDJuQUJqZ1d3QXVFelFBZ3hKaUFJTklBUUQxamxzQXJiQi9BQjdwOGdCSVNrTUFFR2ZUQUtyZDJBQ3VYMElBYW1IT0FBb29wQURUbWJRQUJxYnlBRngzZndDandvTUFZVHlJQUlwemVBQ3ZqRm9BYjllOUFDMm1Zd0QwdjhzQWpZSHZBQ2JCWndCVnlrVUF5dGsyQUNpbzBnRENZWTBBRXNsM0FBUW1GQUFTUnBzQXhGbkVBTWpGUkFCTnNwRUFBQmZ6QU5SRHJRQXBTZVVBL2RVUUFBQysvQUFlbE13QWNNN3VBQk0rOVFEczhZQUFzK2ZEQU1mNEtBQ1RCWlFBd1hFK0FDNEpzd0FMUmZNQWlCS2NBS3NnZXdBdXRaOEFSNUxDQUhzeUx3QU1WVzBBY3FlUUFHdm5Id0F4eTVZQWVSWktBRUY1NGdEMDM0a0E2SlNYQU9MbWhBQ1pNWmNBaU8xckFGOWZOZ0M3L1E0QVNKcTBBR2VrYkFCeGNrSUFqVjB5QUo4VnVBQzg1UWtBalRFbEFQZDBPUUF3QlJ3QURRd0JBRXNJYUFBczdsZ0FSNnFRQUhUbkFnQzkxaVFBOTMybUFHNUljZ0NmRnU4QWpwU21BTFNSOWdEUlUxRUF6d3J5QUNDWU13RDFTMzRBc21Ob0FOMCtYd0JBWFFNQWhZbC9BRlZTS1FBM1pNQUFiZGdRQURKSU1nQmJUSFVBVG5IVUFFVlViZ0FMQ2NFQUt2VnBBQlJtMVFBbkI1MEFYUVJRQUxRNzJ3RHFkc1VBaC9rWEFFbHJmUUFkSjdvQWxta3BBTWJNckFDdEZGUUFrT0pxQUlqWmlRQXNjbEFBQktTK0FIY0hsQUR6TUhBQUFQd25BT3B4cUFCbXdra0FaT0E5QUpmZGd3Q2pQNWNBUTVUOUFBMkdqQUF4UWQ0QWtqbWRBTjF3akFBWHQrY0FDTjg3QUJVM0t3QmNnS0FBV29DVEFCQVJrZ0FQNk5nQWJJQ3ZBTnYvU3dBNGtBOEFXUmgyQUdLbEZRQmh5N3NBeDRtNUFCQkF2UURTOGdRQVNYVW5BT3UyOWdEYklyc0FDaFNxQUlrbUx3QmtnM1lBQ1RzekFBNlVHZ0JST3FvQUhhUENBSy90cmdCY0poSUFiY0pOQUMxNm5BREFWcGNBQXorREFBbnc5Z0FyUUl3QWJUR1pBRG0wQndBTUlCVUEyTU5iQVBXU3hBREdyVXNBVHNxbEFLYzN6UURtcVRZQXE1S1VBTjFDYUFBWlk5NEFkb3p2QUdpTFVnRDgyemNBcnFHckFOOFZNUUFBcnFFQURQdmFBR1JOWmdEdEJiY0FLV1V3QUZkV3Z3Qkgvem9BYXZtNUFIVys4d0Fvazk4QXE0QXdBR2FNOWdBRXl4VUEraUlHQU5ua0hRQTlzNlFBVnh1UEFEYk5DUUJPUXVrQUU3NmtBRE1qdFFEd3Fob0FUMldvQU5MQnBRQUxQdzhBVzNqTkFDUDVkZ0I3aXdRQWlSZHlBTWFtVXdCdmJ1SUE3K3NBQUp0S1dBREUycmNBcW1hNkFIYlB6d0RSQWgwQXNmRXRBSXlad1FERHJYY0Foa2phQVBkZG9BREdnUFFBclBBdkFOM3NtZ0EvWEx3QTBONXRBSkRISHdBcTI3WUFveVU2QUFDdm1nQ3RVNU1BdGxjRUFDa3R0QUJMZ0g0QTJnZW5BSGFxRGdCN1dhRUFGaElxQU55M0xRRDY1ZjBBaWR2K0FJbSsvUURrZG13QUJxbjhBRDZBY0FDRmJoVUEvWWYvQUNnK0J3Qmhaek1BS2hpR0FFMjk2Z0N6NTY4QWoyMXVBSlZuT1FBeHYxc0FoTmRJQUREZkZnREhMVU1BSldFMUFNbHd6Z0F3eTdnQXYyejlBS1FBb2dBRmJPUUFXdDJnQUNGdlJ3QmlFdElBdVZ5RUFIQmhTUUJyVnVBQW1WSUJBRkJWTndBZTFiY0FNL0hFQUJOdVh3QmRNT1FBaFM2cEFCMnl3d0NoTWpZQUNMZWtBT3F4MUFBVzl5RUFqMm5rQUNmL2R3QU1BNEFBalVBdEFFL05vQUFncFprQXM2TFRBQzlkQ2dDMCtVSUFFZHJMQUgyKzBBQ2IyOEVBcXhlOUFNcWlnUUFJYWx3QUxsVVhBQ2NBVlFCL0ZQQUE0UWVHQUJRTFpBQ1dRWTBBaDc3ZUFOcjlLZ0JySmJZQWU0azBBQVh6L2dDNXY1NEFhR3BQQUVvcXFBQlB4Rm9BTGZpOEFOZGFtQUQweDVVQURVMk5BQ0E2cGdDa1YxOEFGRCt4QUlBNGxRRE1JQUVBY2QyR0FNbmV0Z0MvWVBVQVRXVVJBQUVIYXdDTXNLd0Fzc0RRQUZGVlNBQWUrdzRBbFhMREFLTUdPd0RBUURVQUJ0eDdBT0JGekFCT0tmb0Exc3JJQU9qelFRQjhaTjRBbTJUWUFObStNUUNrbDhNQWQxalVBR25qeFFEdzJoTUF1am84QUVZWVJnQlZkVjhBMHIzMUFHNlN4Z0NzTGwwQURrVHRBQncrUWdCaHhJY0FLZjNwQU9mVzh3QWlmTW9BYjVFMUFBamd4UUQvMTQwQWJtcmlBTEQ5eGdDVENNRUFmRjEwQUd1dHNnRE5icDBBUG5KN0FNWVJhZ0QzejZrQUtYUGZBTFhKdWdDM0FGRUE0cklOQUhTNkpBRGxmV0FBZE5pS0FBMFZMQUNCR0F3QWZtYVVBQUVwRmdDZmVuWUEvZjIrQUZaRjd3RFpmallBN05rVEFJdTZ1UURFbC93QU1hZ25BUEZ1d3dDVXhUWUEyS2hXQUxTb3RRRFB6QTRBRW9rdEFHOVhOQUFzVm9rQW1jN2pBTllndVFCclhxb0FQaXFjQUJGZnpBRDlDMG9BNGZUN0FJNDdiUURpaGl3QTZkU0VBUHkwcVFEdjd0RUFMalhKQUM4NVlRQTRJVVFBRzluSUFJSDhDZ0Q3U21vQUx4ellBRk8waEFCT21Zd0FWQ0xNQUNwVjNBREF4dFlBQ3htV0FCcHd1QUJwbFdRQUpscGdBRDlTN2dCL0VROEE5TFVSQVB6TDlRQTB2QzBBTkx6dUFPaGR6QURkWG1BQVo0NmJBSkl6N3dESkY3Z0FZVmliQU9GWHZBQlJnOFlBMkQ0UUFOMXhTQUF0SE4wQXJ4aWhBQ0VzUmdCWjg5Y0EyWHFZQUo1VXdBQlBodm9BVmdiOEFPVjVyZ0NKSWpZQU9LMGlBR2VUM0FCVjZLb0FnaVk0QU1ybm13QlJEYVFBbVRPeEFLblhEZ0JwQlVnQVpiTHdBSCtJcHdDSVRKY0ErZEUyQUNHU3N3Qjdna29BbU04aEFFQ2YzQURjUjFVQTRYUTZBR2ZyUWdEK25kOEFYdFJmQUh0bnBBQzZySG9BVmZhaUFDdUlJd0JCdWxVQVdXNElBQ0VxaGdBNVI0TUFpZVBtQU9XZTFBQkorMEFBLzFicEFCd1B5Z0RGV1lvQWxQb3JBTlBCeFFBUHhjOEEyMXF1QUVmRmhnQ0ZRMklBSVlZN0FDeDVsQUFRWVljQUtreDdBSUFzR2dCRHZ4SUFpQ2FRQUhnOGlRQ294T1FBNWR0N0FNUTZ3Z0FtOU9vQTkyZUtBQTJTdndCbG95c0FQWk94QUwxOEN3Q2tVZHdBSjkxakFHbmgzUUNhbEJrQXFDbVZBR2pPS0FBSjdiUUFSSjhnQUU2WXlnQndnbU1BZm53akFBKzVNZ0NuOVk0QUZGYm5BQ0h4Q0FDMW5Tb0FiMzVOQUtVWlVRQzErYXNBZ3QvV0FKYmRZUUFXTmdJQXhEcWZBSU9pb1FCeTdXMEFPWTE2QUlLNHFRQnJNbHdBUmlkYkFBQTA3UURTQUhjQS9QUlZBQUZaVFFEZ2NZQUFRZFB6QVF0UlFQc2grVDhBQUFBQUxVUjBQZ0FBQUlDWVJ2ZzhBQUFBWUZITWVEc0FBQUNBZ3h2d09RQUFBRUFnSlhvNEFBQUFnQ0tDNHpZQUFBQUFIZk5wTlJoOEFBQXRLeUFnSURCWU1IZ0FLRzUxYkd3cEFFR3c5QUVMUVJFQUNnQVJFUkVBQUFBQUJRQUFBQUFBQUFrQUFBQUFDd0FBQUFBQUFBQUFFUUFQQ2hFUkVRTUtCd0FCQUFrTEN3QUFDUVlMQUFBTEFBWVJBQUFBRVJFUkFFR0I5UUVMSVFzQUFBQUFBQUFBQUJFQUNnb1JFUkVBQ2dBQUFnQUpDd0FBQUFrQUN3QUFDd0JCdS9VQkN3RU1BRUhIOVFFTEZRd0FBQUFBREFBQUFBQUpEQUFBQUFBQURBQUFEQUJCOWZVQkN3RU9BRUdCOWdFTEZRMEFBQUFFRFFBQUFBQUpEZ0FBQUFBQURnQUFEZ0JCci9ZQkN3RVFBRUc3OWdFTEhnOEFBQUFBRHdBQUFBQUpFQUFBQUFBQUVBQUFFQUFBRWdBQUFCSVNFZ0JCOHZZQkN3NFNBQUFBRWhJU0FBQUFBQUFBQ1FCQm8vY0JDd0VMQUVHdjl3RUxGUW9BQUFBQUNnQUFBQUFKQ3dBQUFBQUFDd0FBQ3dCQjNmY0JDd0VNQUVIcDl3RUxKd3dBQUFBQURBQUFBQUFKREFBQUFBQUFEQUFBREFBQU1ERXlNelExTmpjNE9VRkNRMFJGUmdCQmtQZ0JDd25nZzFBQUFBQUFBQVVBUWFUNEFRc0JBZ0JCdlBnQkN3NERBQUFBQkFBQUFKaC9BQUFBQkFCQjFQZ0JDd0VCQUVIaitBRUxCUXIvLy8vL0FFSFUrZ0VMQXNDRFwiO2Z1bmN0aW9uIGUoQSl7dHJ5e2lmKEE9PWImJncpcmV0dXJuIG5ldyBVaW50OEFycmF5KHcpO3ZhciBJPWZ1bmN0aW9uKEEpe2lmKGYoQSkpcmV0dXJuIGZ1bmN0aW9uKEEpe3RyeXtmb3IodmFyIEk9cChBKSxnPW5ldyBVaW50OEFycmF5KEkubGVuZ3RoKSxCPTA7QjxJLmxlbmd0aDsrK0IpZ1tCXT1JLmNoYXJDb2RlQXQoQik7cmV0dXJuIGd9Y2F0Y2goQSl7dGhyb3cgbmV3IEVycm9yKFwiQ29udmVydGluZyBiYXNlNjQgc3RyaW5nIHRvIGJ5dGVzIGZhaWxlZC5cIil9fShBLnNsaWNlKHIubGVuZ3RoKSl9KEEpO2lmKEkpcmV0dXJuIEk7dGhyb3dcImJvdGggYXN5bmMgYW5kIHN5bmMgZmV0Y2hpbmcgb2YgdGhlIHdhc20gZmFpbGVkXCJ9Y2F0Y2goQSl7bihBKX19ZnVuY3Rpb24geChJKXtmb3IoO0kubGVuZ3RoPjA7KXt2YXIgZz1JLnNoaWZ0KCk7aWYoXCJmdW5jdGlvblwiIT10eXBlb2YgZyl7dmFyIEI9Zy5mdW5jO1wibnVtYmVyXCI9PXR5cGVvZiBCP3ZvaWQgMD09PWcuYXJnP3EuZ2V0KEIpKCk6cS5nZXQoQikoZy5hcmcpOkIodm9pZCAwPT09Zy5hcmc/bnVsbDpnLmFyZyl9ZWxzZSBnKEEpfX1mKGIpfHwoVz1iLGI9QS5sb2NhdGVGaWxlP0EubG9jYXRlRmlsZShXLG8pOm8rVyk7dmFyIHY9e21hcHBpbmdzOnt9LGJ1ZmZlcnM6W251bGwsW10sW11dLHByaW50Q2hhcjpmdW5jdGlvbihBLEkpe3ZhciBnPXYuYnVmZmVyc1tBXTswPT09SXx8MTA9PT1JPygoMT09PUE/RzpSKSh5KGcsMCkpLGcubGVuZ3RoPTApOmcucHVzaChJKX0sdmFyYXJnczp2b2lkIDAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHYudmFyYXJncys9NCxoW3YudmFyYXJncy00Pj4yXX0sZ2V0U3RyOmZ1bmN0aW9uKEEpe3JldHVybiBIKEEpfSxnZXQ2NDpmdW5jdGlvbihBLEkpe3JldHVybiBBfX0scD1cImZ1bmN0aW9uXCI9PXR5cGVvZiBhdG9iP2F0b2I6ZnVuY3Rpb24oQSl7dmFyIEksZyxCLFEsQyxFLGk9XCJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvPVwiLEQ9XCJcIixvPTA7QT1BLnJlcGxhY2UoL1teQS1aYS16MC05XFxcXCtcXFxcL1xcXFw9XS9nLFwiXCIpO2Rve0k9aS5pbmRleE9mKEEuY2hhckF0KG8rKykpPDwyfChRPWkuaW5kZXhPZihBLmNoYXJBdChvKyspKSk+PjQsZz0oMTUmUSk8PDR8KEM9aS5pbmRleE9mKEEuY2hhckF0KG8rKykpKT4+MixCPSgzJkMpPDw2fChFPWkuaW5kZXhPZihBLmNoYXJBdChvKyspKSksRCs9U3RyaW5nLmZyb21DaGFyQ29kZShJKSw2NCE9PUMmJihEKz1TdHJpbmcuZnJvbUNoYXJDb2RlKGcpKSw2NCE9PUUmJihEKz1TdHJpbmcuZnJvbUNoYXJDb2RlKEIpKX13aGlsZShvPEEubGVuZ3RoKTtyZXR1cm4gRH07dmFyIFQsTz17YjpmdW5jdGlvbihBLEksZyl7ay5jb3B5V2l0aGluKEEsSSxJK2cpfSxjOmZ1bmN0aW9uKEEpe24oXCJPT01cIil9LGE6ZnVuY3Rpb24oQSxJLGcsQil7Zm9yKHZhciBRPTAsQz0wO0M8ZztDKyspe2Zvcih2YXIgRT1oW0krOCpDPj4yXSxpPWhbSSsoOCpDKzQpPj4yXSxEPTA7RDxpO0QrKyl2LnByaW50Q2hhcihBLGtbRStEXSk7USs9aX1yZXR1cm4gaFtCPj4yXT1RLDB9fSxsPShmdW5jdGlvbigpe3ZhciBJPXthOk99O2Z1bmN0aW9uIGcoSSxnKXt2YXIgQixRPUkuZXhwb3J0cztBLmFzbT1RLEI9QS5hc20uZC5idWZmZXIsQS5IRUFQOD1zPW5ldyBJbnQ4QXJyYXkoQiksQS5IRUFQMTY9bmV3IEludDE2QXJyYXkoQiksQS5IRUFQMzI9aD1uZXcgSW50MzJBcnJheShCKSxBLkhFQVBVOD1rPW5ldyBVaW50OEFycmF5KEIpLEEuSEVBUFUxNj1uZXcgVWludDE2QXJyYXkoQiksQS5IRUFQVTMyPW5ldyBVaW50MzJBcnJheShCKSxBLkhFQVBGMzI9bmV3IEZsb2F0MzJBcnJheShCKSxBLkhFQVBGNjQ9bmV3IEZsb2F0NjRBcnJheShCKSxxPUEuYXNtLmUsZnVuY3Rpb24oSSl7aWYoZC0tLEEubW9uaXRvclJ1bkRlcGVuZGVuY2llcyYmQS5tb25pdG9yUnVuRGVwZW5kZW5jaWVzKGQpLDA9PWQmJihudWxsIT09UCYmKGNsZWFySW50ZXJ2YWwoUCksUD1udWxsKSx0KSl7dmFyIGc9dDt0PW51bGwsZygpfX0oKX1mdW5jdGlvbiBRKEEpe2coQS5pbnN0YW5jZSl9ZnVuY3Rpb24gQyhBKXtyZXR1cm4od3x8XCJmdW5jdGlvblwiIT10eXBlb2YgZmV0Y2g/UHJvbWlzZS5yZXNvbHZlKCkudGhlbigoZnVuY3Rpb24oKXtyZXR1cm4gZShiKX0pKTpmZXRjaChiLHtjcmVkZW50aWFsczpcInNhbWUtb3JpZ2luXCJ9KS50aGVuKChmdW5jdGlvbihBKXtpZighQS5vayl0aHJvd1wiZmFpbGVkIHRvIGxvYWQgd2FzbSBiaW5hcnkgZmlsZSBhdCBcXCdcIitiK1wiXFwnXCI7cmV0dXJuIEEuYXJyYXlCdWZmZXIoKX0pKS5jYXRjaCgoZnVuY3Rpb24oKXtyZXR1cm4gZShiKX0pKSkudGhlbigoZnVuY3Rpb24oQSl7cmV0dXJuIFdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlKEEsSSl9KSkudGhlbihBLChmdW5jdGlvbihBKXtSKFwiZmFpbGVkIHRvIGFzeW5jaHJvbm91c2x5IHByZXBhcmUgd2FzbTogXCIrQSksbihBKX0pKX1pZihkKyssQS5tb25pdG9yUnVuRGVwZW5kZW5jaWVzJiZBLm1vbml0b3JSdW5EZXBlbmRlbmNpZXMoZCksQS5pbnN0YW50aWF0ZVdhc20pdHJ5e3JldHVybiBBLmluc3RhbnRpYXRlV2FzbShJLGcpfWNhdGNoKEEpe3JldHVybiBSKFwiTW9kdWxlLmluc3RhbnRpYXRlV2FzbSBjYWxsYmFjayBmYWlsZWQgd2l0aCBlcnJvcjogXCIrQSksITF9KHd8fFwiZnVuY3Rpb25cIiE9dHlwZW9mIFdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlU3RyZWFtaW5nfHxmKGIpfHxcImZ1bmN0aW9uXCIhPXR5cGVvZiBmZXRjaD9DKFEpOmZldGNoKGIse2NyZWRlbnRpYWxzOlwic2FtZS1vcmlnaW5cIn0pLnRoZW4oKGZ1bmN0aW9uKEEpe3JldHVybiBXZWJBc3NlbWJseS5pbnN0YW50aWF0ZVN0cmVhbWluZyhBLEkpLnRoZW4oUSwoZnVuY3Rpb24oQSl7cmV0dXJuIFIoXCJ3YXNtIHN0cmVhbWluZyBjb21waWxlIGZhaWxlZDogXCIrQSksUihcImZhbGxpbmcgYmFjayB0byBBcnJheUJ1ZmZlciBpbnN0YW50aWF0aW9uXCIpLEMoUSl9KSl9KSkpLmNhdGNoKEIpfSgpLEEuX19fd2FzbV9jYWxsX2N0b3JzPWZ1bmN0aW9uKCl7cmV0dXJuKGw9QS5fX193YXNtX2NhbGxfY3RvcnM9QS5hc20uZikuYXBwbHkobnVsbCxhcmd1bWVudHMpfSksWD0oQS5fc3RvcFN0cmVhbT1mdW5jdGlvbigpe3JldHVybihBLl9zdG9wU3RyZWFtPUEuYXNtLmcpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sQS5fc3RhcnRTdHJlYW09ZnVuY3Rpb24oKXtyZXR1cm4oQS5fc3RhcnRTdHJlYW09QS5hc20uaCkuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxBLl9kZWNvZGU9ZnVuY3Rpb24oKXtyZXR1cm4oQS5fZGVjb2RlPUEuYXNtLmkpLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sQS5fY3JlYXRlQnVmZmVyPWZ1bmN0aW9uKCl7cmV0dXJuKEEuX2NyZWF0ZUJ1ZmZlcj1BLmFzbS5qKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LEEuX2ZyZWVCdWZmZXI9ZnVuY3Rpb24oKXtyZXR1cm4oQS5fZnJlZUJ1ZmZlcj1BLmFzbS5rKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LEEuX21haW49ZnVuY3Rpb24oKXtyZXR1cm4oQS5fbWFpbj1BLmFzbS5sKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LEEuc3RhY2tTYXZlPWZ1bmN0aW9uKCl7cmV0dXJuKFg9QS5zdGFja1NhdmU9QS5hc20ubSkuYXBwbHkobnVsbCxhcmd1bWVudHMpfSksWj1BLnN0YWNrUmVzdG9yZT1mdW5jdGlvbigpe3JldHVybihaPUEuc3RhY2tSZXN0b3JlPUEuYXNtLm4pLmFwcGx5KG51bGwsYXJndW1lbnRzKX0sVj1BLnN0YWNrQWxsb2M9ZnVuY3Rpb24oKXtyZXR1cm4oVj1BLnN0YWNrQWxsb2M9QS5hc20ubykuYXBwbHkobnVsbCxhcmd1bWVudHMpfTtmdW5jdGlvbiB6KEEpe3RoaXMubmFtZT1cIkV4aXRTdGF0dXNcIix0aGlzLm1lc3NhZ2U9XCJQcm9ncmFtIHRlcm1pbmF0ZWQgd2l0aCBleGl0KFwiK0ErXCIpXCIsdGhpcy5zdGF0dXM9QX1mdW5jdGlvbiBqKEkpe2Z1bmN0aW9uIEIoKXtUfHwoVD0hMCxBLmNhbGxlZFJ1bj0hMCxTfHwoeChLKSx4KGMpLGcoQSksQS5vblJ1bnRpbWVJbml0aWFsaXplZCYmQS5vblJ1bnRpbWVJbml0aWFsaXplZCgpLHUmJmZ1bmN0aW9uKEkpe3ZhciBnLEI9QS5fbWFpbixRPShJPUl8fFtdKS5sZW5ndGgrMSxDPVYoNCooUSsxKSk7aFtDPj4yXT1MKGkpO2Zvcih2YXIgRT0xO0U8UTtFKyspaFsoQz4+MikrRV09TChJW0UtMV0pO2hbKEM+PjIpK1FdPTA7dHJ5e2c9QihRLEMpLEYmJjA9PT1nfHwoRnx8KEEub25FeGl0JiZBLm9uRXhpdChnKSxTPSEwKSxEKGcsbmV3IHooZykpKX1jYXRjaChBKXtpZihBIGluc3RhbmNlb2YgeilyZXR1cm47aWYoXCJ1bndpbmRcIj09QSlyZXR1cm4gdm9pZChGPSEwKTt2YXIgbz1BO0EmJlwib2JqZWN0XCI9PXR5cGVvZiBBJiZBLnN0YWNrJiYobz1bQSxBLnN0YWNrXSksUihcImV4Y2VwdGlvbiB0aHJvd246IFwiK28pLEQoMSxBKX19KEkpLGZ1bmN0aW9uKCl7aWYoQS5wb3N0UnVuKWZvcihcImZ1bmN0aW9uXCI9PXR5cGVvZiBBLnBvc3RSdW4mJihBLnBvc3RSdW49W0EucG9zdFJ1bl0pO0EucG9zdFJ1bi5sZW5ndGg7KUk9QS5wb3N0UnVuLnNoaWZ0KCksWS51bnNoaWZ0KEkpO3ZhciBJO3goWSl9KCkpKX1JPUl8fEUsZD4wfHwoZnVuY3Rpb24oKXtpZihBLnByZVJ1bilmb3IoXCJmdW5jdGlvblwiPT10eXBlb2YgQS5wcmVSdW4mJihBLnByZVJ1bj1bQS5wcmVSdW5dKTtBLnByZVJ1bi5sZW5ndGg7KUk9QS5wcmVSdW4uc2hpZnQoKSxNLnVuc2hpZnQoSSk7dmFyIEk7eChNKX0oKSxkPjB8fChBLnNldFN0YXR1cz8oQS5zZXRTdGF0dXMoXCJSdW5uaW5nLi4uXCIpLHNldFRpbWVvdXQoKGZ1bmN0aW9uKCl7c2V0VGltZW91dCgoZnVuY3Rpb24oKXtBLnNldFN0YXR1cyhcIlwiKX0pLDEpLEIoKX0pLDEpKTpCKCkpKX1pZihBLmN3cmFwPWZ1bmN0aW9uKEEsSSxnLEIpe3ZhciBRPShnPWd8fFtdKS5ldmVyeSgoZnVuY3Rpb24oQSl7cmV0dXJuXCJudW1iZXJcIj09PUF9KSk7cmV0dXJuXCJzdHJpbmdcIiE9PUkmJlEmJiFCP1UoQSk6ZnVuY3Rpb24oKXtyZXR1cm4gYShBLEksZyxhcmd1bWVudHMpfX0sdD1mdW5jdGlvbiBBKCl7VHx8aigpLFR8fCh0PUEpfSxBLnJ1bj1qLEEucHJlSW5pdClmb3IoXCJmdW5jdGlvblwiPT10eXBlb2YgQS5wcmVJbml0JiYoQS5wcmVJbml0PVtBLnByZUluaXRdKTtBLnByZUluaXQubGVuZ3RoPjA7KUEucHJlSW5pdC5wb3AoKSgpO3ZhciB1PSEwO3JldHVybiBBLm5vSW5pdGlhbFJ1biYmKHU9ITEpLEY9ITAsaigpLEEucmVhZHl9KTtBLmV4cG9ydHM9Z319LEk9e307ZnVuY3Rpb24gZyhCKXt2YXIgUT1JW0JdO2lmKHZvaWQgMCE9PVEpcmV0dXJuIFEuZXhwb3J0czt2YXIgQz1JW0JdPXtleHBvcnRzOnt9fTtyZXR1cm4gQVtCXShDLEMuZXhwb3J0cyxnKSxDLmV4cG9ydHN9Zy5uPUE9Pnt2YXIgST1BJiZBLl9fZXNNb2R1bGU/KCk9PkEuZGVmYXVsdDooKT0+QTtyZXR1cm4gZy5kKEkse2E6SX0pLEl9LGcuZD0oQSxJKT0+e2Zvcih2YXIgQiBpbiBJKWcubyhJLEIpJiYhZy5vKEEsQikmJk9iamVjdC5kZWZpbmVQcm9wZXJ0eShBLEIse2VudW1lcmFibGU6ITAsZ2V0OklbQl19KX0sZy5vPShBLEkpPT5PYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoQSxJKSwoKCk9PntcInVzZSBzdHJpY3RcIjt2YXIgQSxJPWcoMzA1KSxCPWcubihJKSxRPTAsQz0wLEU9MCxpPTAsRD0wLG89MDshYXN5bmMgZnVuY3Rpb24oKXtBPWF3YWl0IEIoKSgpLHNlbGYuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwoYXN5bmMgZnVuY3Rpb24oSSl7dmFyIGc9SS5kYXRhO3N3aXRjaChnLnR5cGUpe2Nhc2VcInN0YXJ0U3RyZWFtXCI6bz1nLmRlY29kZWRTYW1wbGVzUGVyRnJhbWUsRD1vKmcuY2hhbm5lbENvdW50LEEuX3N0YXJ0U3RyZWFtKGcuc2FtcGxlUmF0ZUh6LGcuY2hhbm5lbENvdW50KTticmVhaztjYXNlXCJzdG9wU3RyZWFtXCI6QS5fc3RvcFN0cmVhbSgpO2JyZWFrO2Nhc2VcImRlY29kZVwiOntjb25zdCBJPWcuc3RhcnRUaW1lc3RhbXAsQj1mdW5jdGlvbihJKXtjb25zdCBnPUkuYnl0ZUxlbmd0aDtyZXR1cm4gMCE9USYmQzxnJiYoQS5fZnJlZUJ1ZmZlcihRKSxRPTAsQz0wKSwwPT1RJiYoUT1BLl9jcmVhdGVCdWZmZXIoSS5CWVRFU19QRVJfRUxFTUVOVCpnKSxDPWcpLEEuSEVBUFU4LnNldChJLFEpLFF9KG5ldyBVaW50OEFycmF5KGcuaW5wdXREYXRhKSksdz0oMCE9RSYmaTxEJiYoQS5fZnJlZUJ1ZmZlcihFKSxFPTAsaT0wKSwwPT1FJiYoRT1BLl9jcmVhdGVCdWZmZXIoRmxvYXQzMkFycmF5LkJZVEVTX1BFUl9FTEVNRU5UKkQpLGk9RCksRSksRj1uZXcgRmxvYXQzMkFycmF5KEEuSEVBUEYzMi5idWZmZXIsdyxEKSxHPUEuX2RlY29kZShCLGcuaW5wdXREYXRhLmJ5dGVMZW5ndGgsdyxvKSxSPUYuYnVmZmVyLnNsaWNlKHcsdytEKkYuQllURVNfUEVSX0VMRU1FTlQpO3Bvc3RNZXNzYWdlKHt0eXBlOlwiZGVjb2RlRG9uZVwiLHN0YXJ0VGltZXN0YW1wOkksb3V0cHV0RGF0YTpSLHNhbXBsZXNEZWNvZGVkOkd9LFtSXSk7YnJlYWt9Y2FzZVwicmVsZWFzZVwiOjAhPVEmJihBLl9mcmVlQnVmZmVyKFEpLFE9MCxDPTApLDAhPUUmJihBLl9mcmVlQnVmZmVyKEUpLEU9MCxpPTApLEEuX3N0b3BTdHJlYW0oKX19KSkscG9zdE1lc3NhZ2Uoe3R5cGU6XCJkZWNvZGVyUmVhZHlcIn0pfSgpfSkoKX0pKCk7JyxcIldvcmtlclwiLHZvaWQgMCx2b2lkIDApfX0sNjE0OkE9PntBLmV4cG9ydHM9ZnVuY3Rpb24oQSxJLGcsZSl7dmFyIEI9c2VsZnx8d2luZG93O3RyeXt0cnl7dmFyIGk7dHJ5e2k9bmV3IEIuQmxvYihbQV0pfWNhdGNoKEkpeyhpPW5ldyhCLkJsb2JCdWlsZGVyfHxCLldlYktpdEJsb2JCdWlsZGVyfHxCLk1vekJsb2JCdWlsZGVyfHxCLk1TQmxvYkJ1aWxkZXIpKS5hcHBlbmQoQSksaT1pLmdldEJsb2IoKX12YXIgdD1CLlVSTHx8Qi53ZWJraXRVUkwsUT10LmNyZWF0ZU9iamVjdFVSTChpKSxDPW5ldyBCW0ldKFEsZyk7cmV0dXJuIHQucmV2b2tlT2JqZWN0VVJMKFEpLEN9Y2F0Y2goZSl7cmV0dXJuIG5ldyBCW0ldKFwiZGF0YTphcHBsaWNhdGlvbi9qYXZhc2NyaXB0LFwiLmNvbmNhdChlbmNvZGVVUklDb21wb25lbnQoQSkpLGcpfX1jYXRjaChBKXtpZighZSl0aHJvdyBFcnJvcihcIklubGluZSB3b3JrZXIgaXMgbm90IHN1cHBvcnRlZFwiKTtyZXR1cm4gbmV3IEJbSV0oZSxnKX19fX0sST17fTtmdW5jdGlvbiBnKGUpe3ZhciBCPUlbZV07aWYodm9pZCAwIT09QilyZXR1cm4gQi5leHBvcnRzO3ZhciBpPUlbZV09e2V4cG9ydHM6e319O3JldHVybiBBW2VdLmNhbGwoaS5leHBvcnRzLGksaS5leHBvcnRzLGcpLGkuZXhwb3J0c31yZXR1cm4gZy5uPUE9Pnt2YXIgST1BJiZBLl9fZXNNb2R1bGU/KCk9PkEuZGVmYXVsdDooKT0+QTtyZXR1cm4gZy5kKEkse2E6SX0pLEl9LGcuZD0oQSxJKT0+e2Zvcih2YXIgZSBpbiBJKWcubyhJLGUpJiYhZy5vKEEsZSkmJk9iamVjdC5kZWZpbmVQcm9wZXJ0eShBLGUse2VudW1lcmFibGU6ITAsZ2V0OklbZV19KX0sZy5vPShBLEkpPT5PYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoQSxJKSxnLnI9QT0+e1widW5kZWZpbmVkXCIhPXR5cGVvZiBTeW1ib2wmJlN5bWJvbC50b1N0cmluZ1RhZyYmT2JqZWN0LmRlZmluZVByb3BlcnR5KEEsU3ltYm9sLnRvU3RyaW5nVGFnLHt2YWx1ZTpcIk1vZHVsZVwifSksT2JqZWN0LmRlZmluZVByb3BlcnR5KEEsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSl9LGcoMTE0KX0pKCl9LDcwMDooKT0+e319LEk9e307ZnVuY3Rpb24gZyhlKXt2YXIgQj1JW2VdO2lmKHZvaWQgMCE9PUIpcmV0dXJuIEIuZXhwb3J0czt2YXIgaT1JW2VdPXtleHBvcnRzOnt9fTtyZXR1cm4gQVtlXS5jYWxsKGkuZXhwb3J0cyxpLGkuZXhwb3J0cyxnKSxpLmV4cG9ydHN9cmV0dXJuIGcuZz1mdW5jdGlvbigpe2lmKFwib2JqZWN0XCI9PXR5cGVvZiBnbG9iYWxUaGlzKXJldHVybiBnbG9iYWxUaGlzO3RyeXtyZXR1cm4gdGhpc3x8bmV3IEZ1bmN0aW9uKFwicmV0dXJuIHRoaXNcIikoKX1jYXRjaChBKXtpZihcIm9iamVjdFwiPT10eXBlb2Ygd2luZG93KXJldHVybiB3aW5kb3d9fSgpLGcoMTQpfSkoKX0pKTsiLCIvKiogQGxpY2Vuc2UgUmVhY3QgdjE3LjAuMlxuICogcmVhY3QtZG9tLmRldmVsb3BtZW50LmpzXG4gKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gIChmdW5jdGlvbigpIHtcbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcbnZhciBfYXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xudmFyIFNjaGVkdWxlciA9IHJlcXVpcmUoJ3NjaGVkdWxlcicpO1xudmFyIHRyYWNpbmcgPSByZXF1aXJlKCdzY2hlZHVsZXIvdHJhY2luZycpO1xuXG52YXIgUmVhY3RTaGFyZWRJbnRlcm5hbHMgPSBSZWFjdC5fX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRDtcblxuLy8gYnkgY2FsbHMgdG8gdGhlc2UgbWV0aG9kcyBieSBhIEJhYmVsIHBsdWdpbi5cbi8vXG4vLyBJbiBQUk9EIChvciBpbiBwYWNrYWdlcyB3aXRob3V0IGFjY2VzcyB0byBSZWFjdCBpbnRlcm5hbHMpLFxuLy8gdGhleSBhcmUgbGVmdCBhcyB0aGV5IGFyZSBpbnN0ZWFkLlxuXG5mdW5jdGlvbiB3YXJuKGZvcm1hdCkge1xuICB7XG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgcHJpbnRXYXJuaW5nKCd3YXJuJywgZm9ybWF0LCBhcmdzKTtcbiAgfVxufVxuZnVuY3Rpb24gZXJyb3IoZm9ybWF0KSB7XG4gIHtcbiAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjIgPiAxID8gX2xlbjIgLSAxIDogMCksIF9rZXkyID0gMTsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgYXJnc1tfa2V5MiAtIDFdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICB9XG5cbiAgICBwcmludFdhcm5pbmcoJ2Vycm9yJywgZm9ybWF0LCBhcmdzKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwcmludFdhcm5pbmcobGV2ZWwsIGZvcm1hdCwgYXJncykge1xuICAvLyBXaGVuIGNoYW5naW5nIHRoaXMgbG9naWMsIHlvdSBtaWdodCB3YW50IHRvIGFsc29cbiAgLy8gdXBkYXRlIGNvbnNvbGVXaXRoU3RhY2tEZXYud3d3LmpzIGFzIHdlbGwuXG4gIHtcbiAgICB2YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0RGVidWdDdXJyZW50RnJhbWU7XG4gICAgdmFyIHN0YWNrID0gUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5nZXRTdGFja0FkZGVuZHVtKCk7XG5cbiAgICBpZiAoc3RhY2sgIT09ICcnKSB7XG4gICAgICBmb3JtYXQgKz0gJyVzJztcbiAgICAgIGFyZ3MgPSBhcmdzLmNvbmNhdChbc3RhY2tdKTtcbiAgICB9XG5cbiAgICB2YXIgYXJnc1dpdGhGb3JtYXQgPSBhcmdzLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgcmV0dXJuICcnICsgaXRlbTtcbiAgICB9KTsgLy8gQ2FyZWZ1bDogUk4gY3VycmVudGx5IGRlcGVuZHMgb24gdGhpcyBwcmVmaXhcblxuICAgIGFyZ3NXaXRoRm9ybWF0LnVuc2hpZnQoJ1dhcm5pbmc6ICcgKyBmb3JtYXQpOyAvLyBXZSBpbnRlbnRpb25hbGx5IGRvbid0IHVzZSBzcHJlYWQgKG9yIC5hcHBseSkgZGlyZWN0bHkgYmVjYXVzZSBpdFxuICAgIC8vIGJyZWFrcyBJRTk6IGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTM2MTBcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nXG5cbiAgICBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuY2FsbChjb25zb2xlW2xldmVsXSwgY29uc29sZSwgYXJnc1dpdGhGb3JtYXQpO1xuICB9XG59XG5cbmlmICghUmVhY3QpIHtcbiAge1xuICAgIHRocm93IEVycm9yKCBcIlJlYWN0RE9NIHdhcyBsb2FkZWQgYmVmb3JlIFJlYWN0LiBNYWtlIHN1cmUgeW91IGxvYWQgdGhlIFJlYWN0IHBhY2thZ2UgYmVmb3JlIGxvYWRpbmcgUmVhY3RET00uXCIgKTtcbiAgfVxufVxuXG52YXIgRnVuY3Rpb25Db21wb25lbnQgPSAwO1xudmFyIENsYXNzQ29tcG9uZW50ID0gMTtcbnZhciBJbmRldGVybWluYXRlQ29tcG9uZW50ID0gMjsgLy8gQmVmb3JlIHdlIGtub3cgd2hldGhlciBpdCBpcyBmdW5jdGlvbiBvciBjbGFzc1xuXG52YXIgSG9zdFJvb3QgPSAzOyAvLyBSb290IG9mIGEgaG9zdCB0cmVlLiBDb3VsZCBiZSBuZXN0ZWQgaW5zaWRlIGFub3RoZXIgbm9kZS5cblxudmFyIEhvc3RQb3J0YWwgPSA0OyAvLyBBIHN1YnRyZWUuIENvdWxkIGJlIGFuIGVudHJ5IHBvaW50IHRvIGEgZGlmZmVyZW50IHJlbmRlcmVyLlxuXG52YXIgSG9zdENvbXBvbmVudCA9IDU7XG52YXIgSG9zdFRleHQgPSA2O1xudmFyIEZyYWdtZW50ID0gNztcbnZhciBNb2RlID0gODtcbnZhciBDb250ZXh0Q29uc3VtZXIgPSA5O1xudmFyIENvbnRleHRQcm92aWRlciA9IDEwO1xudmFyIEZvcndhcmRSZWYgPSAxMTtcbnZhciBQcm9maWxlciA9IDEyO1xudmFyIFN1c3BlbnNlQ29tcG9uZW50ID0gMTM7XG52YXIgTWVtb0NvbXBvbmVudCA9IDE0O1xudmFyIFNpbXBsZU1lbW9Db21wb25lbnQgPSAxNTtcbnZhciBMYXp5Q29tcG9uZW50ID0gMTY7XG52YXIgSW5jb21wbGV0ZUNsYXNzQ29tcG9uZW50ID0gMTc7XG52YXIgRGVoeWRyYXRlZEZyYWdtZW50ID0gMTg7XG52YXIgU3VzcGVuc2VMaXN0Q29tcG9uZW50ID0gMTk7XG52YXIgRnVuZGFtZW50YWxDb21wb25lbnQgPSAyMDtcbnZhciBTY29wZUNvbXBvbmVudCA9IDIxO1xudmFyIEJsb2NrID0gMjI7XG52YXIgT2Zmc2NyZWVuQ29tcG9uZW50ID0gMjM7XG52YXIgTGVnYWN5SGlkZGVuQ29tcG9uZW50ID0gMjQ7XG5cbi8vIEZpbHRlciBjZXJ0YWluIERPTSBhdHRyaWJ1dGVzIChlLmcuIHNyYywgaHJlZikgaWYgdGhlaXIgdmFsdWVzIGFyZSBlbXB0eSBzdHJpbmdzLlxuXG52YXIgZW5hYmxlUHJvZmlsZXJUaW1lciA9IHRydWU7IC8vIFJlY29yZCBkdXJhdGlvbnMgZm9yIGNvbW1pdCBhbmQgcGFzc2l2ZSBlZmZlY3RzIHBoYXNlcy5cblxudmFyIGVuYWJsZUZ1bmRhbWVudGFsQVBJID0gZmFsc2U7IC8vIEV4cGVyaW1lbnRhbCBTY29wZSBzdXBwb3J0LlxudmFyIGVuYWJsZU5ld1JlY29uY2lsZXIgPSBmYWxzZTsgLy8gRXJyb3JzIHRoYXQgYXJlIHRocm93biB3aGlsZSB1bm1vdW50aW5nIChvciBhZnRlciBpbiB0aGUgY2FzZSBvZiBwYXNzaXZlIGVmZmVjdHMpXG52YXIgd2FybkFib3V0U3RyaW5nUmVmcyA9IGZhbHNlO1xuXG52YXIgYWxsTmF0aXZlRXZlbnRzID0gbmV3IFNldCgpO1xuLyoqXG4gKiBNYXBwaW5nIGZyb20gcmVnaXN0cmF0aW9uIG5hbWUgdG8gZXZlbnQgbmFtZVxuICovXG5cblxudmFyIHJlZ2lzdHJhdGlvbk5hbWVEZXBlbmRlbmNpZXMgPSB7fTtcbi8qKlxuICogTWFwcGluZyBmcm9tIGxvd2VyY2FzZSByZWdpc3RyYXRpb24gbmFtZXMgdG8gdGhlIHByb3Blcmx5IGNhc2VkIHZlcnNpb24sXG4gKiB1c2VkIHRvIHdhcm4gaW4gdGhlIGNhc2Ugb2YgbWlzc2luZyBldmVudCBoYW5kbGVycy4gQXZhaWxhYmxlXG4gKiBvbmx5IGluIHRydWUuXG4gKiBAdHlwZSB7T2JqZWN0fVxuICovXG5cbnZhciBwb3NzaWJsZVJlZ2lzdHJhdGlvbk5hbWVzID0gIHt9IDsgLy8gVHJ1c3QgdGhlIGRldmVsb3BlciB0byBvbmx5IHVzZSBwb3NzaWJsZVJlZ2lzdHJhdGlvbk5hbWVzIGluIHRydWVcblxuZnVuY3Rpb24gcmVnaXN0ZXJUd29QaGFzZUV2ZW50KHJlZ2lzdHJhdGlvbk5hbWUsIGRlcGVuZGVuY2llcykge1xuICByZWdpc3RlckRpcmVjdEV2ZW50KHJlZ2lzdHJhdGlvbk5hbWUsIGRlcGVuZGVuY2llcyk7XG4gIHJlZ2lzdGVyRGlyZWN0RXZlbnQocmVnaXN0cmF0aW9uTmFtZSArICdDYXB0dXJlJywgZGVwZW5kZW5jaWVzKTtcbn1cbmZ1bmN0aW9uIHJlZ2lzdGVyRGlyZWN0RXZlbnQocmVnaXN0cmF0aW9uTmFtZSwgZGVwZW5kZW5jaWVzKSB7XG4gIHtcbiAgICBpZiAocmVnaXN0cmF0aW9uTmFtZURlcGVuZGVuY2llc1tyZWdpc3RyYXRpb25OYW1lXSkge1xuICAgICAgZXJyb3IoJ0V2ZW50UmVnaXN0cnk6IE1vcmUgdGhhbiBvbmUgcGx1Z2luIGF0dGVtcHRlZCB0byBwdWJsaXNoIHRoZSBzYW1lICcgKyAncmVnaXN0cmF0aW9uIG5hbWUsIGAlc2AuJywgcmVnaXN0cmF0aW9uTmFtZSk7XG4gICAgfVxuICB9XG5cbiAgcmVnaXN0cmF0aW9uTmFtZURlcGVuZGVuY2llc1tyZWdpc3RyYXRpb25OYW1lXSA9IGRlcGVuZGVuY2llcztcblxuICB7XG4gICAgdmFyIGxvd2VyQ2FzZWROYW1lID0gcmVnaXN0cmF0aW9uTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIHBvc3NpYmxlUmVnaXN0cmF0aW9uTmFtZXNbbG93ZXJDYXNlZE5hbWVdID0gcmVnaXN0cmF0aW9uTmFtZTtcblxuICAgIGlmIChyZWdpc3RyYXRpb25OYW1lID09PSAnb25Eb3VibGVDbGljaycpIHtcbiAgICAgIHBvc3NpYmxlUmVnaXN0cmF0aW9uTmFtZXMub25kYmxjbGljayA9IHJlZ2lzdHJhdGlvbk5hbWU7XG4gICAgfVxuICB9XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBkZXBlbmRlbmNpZXMubGVuZ3RoOyBpKyspIHtcbiAgICBhbGxOYXRpdmVFdmVudHMuYWRkKGRlcGVuZGVuY2llc1tpXSk7XG4gIH1cbn1cblxudmFyIGNhblVzZURPTSA9ICEhKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiB3aW5kb3cuZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiB3aW5kb3cuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCAhPT0gJ3VuZGVmaW5lZCcpO1xuXG4vLyBBIHJlc2VydmVkIGF0dHJpYnV0ZS5cbi8vIEl0IGlzIGhhbmRsZWQgYnkgUmVhY3Qgc2VwYXJhdGVseSBhbmQgc2hvdWxkbid0IGJlIHdyaXR0ZW4gdG8gdGhlIERPTS5cbnZhciBSRVNFUlZFRCA9IDA7IC8vIEEgc2ltcGxlIHN0cmluZyBhdHRyaWJ1dGUuXG4vLyBBdHRyaWJ1dGVzIHRoYXQgYXJlbid0IGluIHRoZSBmaWx0ZXIgYXJlIHByZXN1bWVkIHRvIGhhdmUgdGhpcyB0eXBlLlxuXG52YXIgU1RSSU5HID0gMTsgLy8gQSBzdHJpbmcgYXR0cmlidXRlIHRoYXQgYWNjZXB0cyBib29sZWFucyBpbiBSZWFjdC4gSW4gSFRNTCwgdGhlc2UgYXJlIGNhbGxlZFxuLy8gXCJlbnVtZXJhdGVkXCIgYXR0cmlidXRlcyB3aXRoIFwidHJ1ZVwiIGFuZCBcImZhbHNlXCIgYXMgcG9zc2libGUgdmFsdWVzLlxuLy8gV2hlbiB0cnVlLCBpdCBzaG91bGQgYmUgc2V0IHRvIGEgXCJ0cnVlXCIgc3RyaW5nLlxuLy8gV2hlbiBmYWxzZSwgaXQgc2hvdWxkIGJlIHNldCB0byBhIFwiZmFsc2VcIiBzdHJpbmcuXG5cbnZhciBCT09MRUFOSVNIX1NUUklORyA9IDI7IC8vIEEgcmVhbCBib29sZWFuIGF0dHJpYnV0ZS5cbi8vIFdoZW4gdHJ1ZSwgaXQgc2hvdWxkIGJlIHByZXNlbnQgKHNldCBlaXRoZXIgdG8gYW4gZW1wdHkgc3RyaW5nIG9yIGl0cyBuYW1lKS5cbi8vIFdoZW4gZmFsc2UsIGl0IHNob3VsZCBiZSBvbWl0dGVkLlxuXG52YXIgQk9PTEVBTiA9IDM7IC8vIEFuIGF0dHJpYnV0ZSB0aGF0IGNhbiBiZSB1c2VkIGFzIGEgZmxhZyBhcyB3ZWxsIGFzIHdpdGggYSB2YWx1ZS5cbi8vIFdoZW4gdHJ1ZSwgaXQgc2hvdWxkIGJlIHByZXNlbnQgKHNldCBlaXRoZXIgdG8gYW4gZW1wdHkgc3RyaW5nIG9yIGl0cyBuYW1lKS5cbi8vIFdoZW4gZmFsc2UsIGl0IHNob3VsZCBiZSBvbWl0dGVkLlxuLy8gRm9yIGFueSBvdGhlciB2YWx1ZSwgc2hvdWxkIGJlIHByZXNlbnQgd2l0aCB0aGF0IHZhbHVlLlxuXG52YXIgT1ZFUkxPQURFRF9CT09MRUFOID0gNDsgLy8gQW4gYXR0cmlidXRlIHRoYXQgbXVzdCBiZSBudW1lcmljIG9yIHBhcnNlIGFzIGEgbnVtZXJpYy5cbi8vIFdoZW4gZmFsc3ksIGl0IHNob3VsZCBiZSByZW1vdmVkLlxuXG52YXIgTlVNRVJJQyA9IDU7IC8vIEFuIGF0dHJpYnV0ZSB0aGF0IG11c3QgYmUgcG9zaXRpdmUgbnVtZXJpYyBvciBwYXJzZSBhcyBhIHBvc2l0aXZlIG51bWVyaWMuXG4vLyBXaGVuIGZhbHN5LCBpdCBzaG91bGQgYmUgcmVtb3ZlZC5cblxudmFyIFBPU0lUSVZFX05VTUVSSUMgPSA2O1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuICovXG52YXIgQVRUUklCVVRFX05BTUVfU1RBUlRfQ0hBUiA9IFwiOkEtWl9hLXpcXFxcdTAwQzAtXFxcXHUwMEQ2XFxcXHUwMEQ4LVxcXFx1MDBGNlxcXFx1MDBGOC1cXFxcdTAyRkZcXFxcdTAzNzAtXFxcXHUwMzdEXFxcXHUwMzdGLVxcXFx1MUZGRlxcXFx1MjAwQy1cXFxcdTIwMERcXFxcdTIwNzAtXFxcXHUyMThGXFxcXHUyQzAwLVxcXFx1MkZFRlxcXFx1MzAwMS1cXFxcdUQ3RkZcXFxcdUY5MDAtXFxcXHVGRENGXFxcXHVGREYwLVxcXFx1RkZGRFwiO1xuLyogZXNsaW50LWVuYWJsZSBtYXgtbGVuICovXG5cbnZhciBBVFRSSUJVVEVfTkFNRV9DSEFSID0gQVRUUklCVVRFX05BTUVfU1RBUlRfQ0hBUiArIFwiXFxcXC0uMC05XFxcXHUwMEI3XFxcXHUwMzAwLVxcXFx1MDM2RlxcXFx1MjAzRi1cXFxcdTIwNDBcIjtcbnZhciBST09UX0FUVFJJQlVURV9OQU1FID0gJ2RhdGEtcmVhY3Ryb290JztcbnZhciBWQUxJRF9BVFRSSUJVVEVfTkFNRV9SRUdFWCA9IG5ldyBSZWdFeHAoJ15bJyArIEFUVFJJQlVURV9OQU1FX1NUQVJUX0NIQVIgKyAnXVsnICsgQVRUUklCVVRFX05BTUVfQ0hBUiArICddKiQnKTtcbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgaWxsZWdhbEF0dHJpYnV0ZU5hbWVDYWNoZSA9IHt9O1xudmFyIHZhbGlkYXRlZEF0dHJpYnV0ZU5hbWVDYWNoZSA9IHt9O1xuZnVuY3Rpb24gaXNBdHRyaWJ1dGVOYW1lU2FmZShhdHRyaWJ1dGVOYW1lKSB7XG4gIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbGlkYXRlZEF0dHJpYnV0ZU5hbWVDYWNoZSwgYXR0cmlidXRlTmFtZSkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGlsbGVnYWxBdHRyaWJ1dGVOYW1lQ2FjaGUsIGF0dHJpYnV0ZU5hbWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKFZBTElEX0FUVFJJQlVURV9OQU1FX1JFR0VYLnRlc3QoYXR0cmlidXRlTmFtZSkpIHtcbiAgICB2YWxpZGF0ZWRBdHRyaWJ1dGVOYW1lQ2FjaGVbYXR0cmlidXRlTmFtZV0gPSB0cnVlO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWxsZWdhbEF0dHJpYnV0ZU5hbWVDYWNoZVthdHRyaWJ1dGVOYW1lXSA9IHRydWU7XG5cbiAge1xuICAgIGVycm9yKCdJbnZhbGlkIGF0dHJpYnV0ZSBuYW1lOiBgJXNgJywgYXR0cmlidXRlTmFtZSk7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBzaG91bGRJZ25vcmVBdHRyaWJ1dGUobmFtZSwgcHJvcGVydHlJbmZvLCBpc0N1c3RvbUNvbXBvbmVudFRhZykge1xuICBpZiAocHJvcGVydHlJbmZvICE9PSBudWxsKSB7XG4gICAgcmV0dXJuIHByb3BlcnR5SW5mby50eXBlID09PSBSRVNFUlZFRDtcbiAgfVxuXG4gIGlmIChpc0N1c3RvbUNvbXBvbmVudFRhZykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChuYW1lLmxlbmd0aCA+IDIgJiYgKG5hbWVbMF0gPT09ICdvJyB8fCBuYW1lWzBdID09PSAnTycpICYmIChuYW1lWzFdID09PSAnbicgfHwgbmFtZVsxXSA9PT0gJ04nKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gc2hvdWxkUmVtb3ZlQXR0cmlidXRlV2l0aFdhcm5pbmcobmFtZSwgdmFsdWUsIHByb3BlcnR5SW5mbywgaXNDdXN0b21Db21wb25lbnRUYWcpIHtcbiAgaWYgKHByb3BlcnR5SW5mbyAhPT0gbnVsbCAmJiBwcm9wZXJ0eUluZm8udHlwZSA9PT0gUkVTRVJWRUQpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBzd2l0Y2ggKHR5cGVvZiB2YWx1ZSkge1xuICAgIGNhc2UgJ2Z1bmN0aW9uJzogLy8gJEZsb3dJc3N1ZSBzeW1ib2wgaXMgcGVyZmVjdGx5IHZhbGlkIGhlcmVcblxuICAgIGNhc2UgJ3N5bWJvbCc6XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgICByZXR1cm4gdHJ1ZTtcblxuICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAge1xuICAgICAgICBpZiAoaXNDdXN0b21Db21wb25lbnRUYWcpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocHJvcGVydHlJbmZvICE9PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuICFwcm9wZXJ0eUluZm8uYWNjZXB0c0Jvb2xlYW5zO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBwcmVmaXggPSBuYW1lLnRvTG93ZXJDYXNlKCkuc2xpY2UoMCwgNSk7XG4gICAgICAgICAgcmV0dXJuIHByZWZpeCAhPT0gJ2RhdGEtJyAmJiBwcmVmaXggIT09ICdhcmlhLSc7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cbmZ1bmN0aW9uIHNob3VsZFJlbW92ZUF0dHJpYnV0ZShuYW1lLCB2YWx1ZSwgcHJvcGVydHlJbmZvLCBpc0N1c3RvbUNvbXBvbmVudFRhZykge1xuICBpZiAodmFsdWUgPT09IG51bGwgfHwgdHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKHNob3VsZFJlbW92ZUF0dHJpYnV0ZVdpdGhXYXJuaW5nKG5hbWUsIHZhbHVlLCBwcm9wZXJ0eUluZm8sIGlzQ3VzdG9tQ29tcG9uZW50VGFnKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKGlzQ3VzdG9tQ29tcG9uZW50VGFnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKHByb3BlcnR5SW5mbyAhPT0gbnVsbCkge1xuXG4gICAgc3dpdGNoIChwcm9wZXJ0eUluZm8udHlwZSkge1xuICAgICAgY2FzZSBCT09MRUFOOlxuICAgICAgICByZXR1cm4gIXZhbHVlO1xuXG4gICAgICBjYXNlIE9WRVJMT0FERURfQk9PTEVBTjpcbiAgICAgICAgcmV0dXJuIHZhbHVlID09PSBmYWxzZTtcblxuICAgICAgY2FzZSBOVU1FUklDOlxuICAgICAgICByZXR1cm4gaXNOYU4odmFsdWUpO1xuXG4gICAgICBjYXNlIFBPU0lUSVZFX05VTUVSSUM6XG4gICAgICAgIHJldHVybiBpc05hTih2YWx1ZSkgfHwgdmFsdWUgPCAxO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGdldFByb3BlcnR5SW5mbyhuYW1lKSB7XG4gIHJldHVybiBwcm9wZXJ0aWVzLmhhc093blByb3BlcnR5KG5hbWUpID8gcHJvcGVydGllc1tuYW1lXSA6IG51bGw7XG59XG5cbmZ1bmN0aW9uIFByb3BlcnR5SW5mb1JlY29yZChuYW1lLCB0eXBlLCBtdXN0VXNlUHJvcGVydHksIGF0dHJpYnV0ZU5hbWUsIGF0dHJpYnV0ZU5hbWVzcGFjZSwgc2FuaXRpemVVUkwsIHJlbW92ZUVtcHR5U3RyaW5nKSB7XG4gIHRoaXMuYWNjZXB0c0Jvb2xlYW5zID0gdHlwZSA9PT0gQk9PTEVBTklTSF9TVFJJTkcgfHwgdHlwZSA9PT0gQk9PTEVBTiB8fCB0eXBlID09PSBPVkVSTE9BREVEX0JPT0xFQU47XG4gIHRoaXMuYXR0cmlidXRlTmFtZSA9IGF0dHJpYnV0ZU5hbWU7XG4gIHRoaXMuYXR0cmlidXRlTmFtZXNwYWNlID0gYXR0cmlidXRlTmFtZXNwYWNlO1xuICB0aGlzLm11c3RVc2VQcm9wZXJ0eSA9IG11c3RVc2VQcm9wZXJ0eTtcbiAgdGhpcy5wcm9wZXJ0eU5hbWUgPSBuYW1lO1xuICB0aGlzLnR5cGUgPSB0eXBlO1xuICB0aGlzLnNhbml0aXplVVJMID0gc2FuaXRpemVVUkw7XG4gIHRoaXMucmVtb3ZlRW1wdHlTdHJpbmcgPSByZW1vdmVFbXB0eVN0cmluZztcbn0gLy8gV2hlbiBhZGRpbmcgYXR0cmlidXRlcyB0byB0aGlzIGxpc3QsIGJlIHN1cmUgdG8gYWxzbyBhZGQgdGhlbSB0b1xuLy8gdGhlIGBwb3NzaWJsZVN0YW5kYXJkTmFtZXNgIG1vZHVsZSB0byBlbnN1cmUgY2FzaW5nIGFuZCBpbmNvcnJlY3Rcbi8vIG5hbWUgd2FybmluZ3MuXG5cblxudmFyIHByb3BlcnRpZXMgPSB7fTsgLy8gVGhlc2UgcHJvcHMgYXJlIHJlc2VydmVkIGJ5IFJlYWN0LiBUaGV5IHNob3VsZG4ndCBiZSB3cml0dGVuIHRvIHRoZSBET00uXG5cbnZhciByZXNlcnZlZFByb3BzID0gWydjaGlsZHJlbicsICdkYW5nZXJvdXNseVNldElubmVySFRNTCcsIC8vIFRPRE86IFRoaXMgcHJldmVudHMgdGhlIGFzc2lnbm1lbnQgb2YgZGVmYXVsdFZhbHVlIHRvIHJlZ3VsYXJcbi8vIGVsZW1lbnRzIChub3QganVzdCBpbnB1dHMpLiBOb3cgdGhhdCBSZWFjdERPTUlucHV0IGFzc2lnbnMgdG8gdGhlXG4vLyBkZWZhdWx0VmFsdWUgcHJvcGVydHkgLS0gZG8gd2UgbmVlZCB0aGlzP1xuJ2RlZmF1bHRWYWx1ZScsICdkZWZhdWx0Q2hlY2tlZCcsICdpbm5lckhUTUwnLCAnc3VwcHJlc3NDb250ZW50RWRpdGFibGVXYXJuaW5nJywgJ3N1cHByZXNzSHlkcmF0aW9uV2FybmluZycsICdzdHlsZSddO1xucmVzZXJ2ZWRQcm9wcy5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gIHByb3BlcnRpZXNbbmFtZV0gPSBuZXcgUHJvcGVydHlJbmZvUmVjb3JkKG5hbWUsIFJFU0VSVkVELCBmYWxzZSwgLy8gbXVzdFVzZVByb3BlcnR5XG4gIG5hbWUsIC8vIGF0dHJpYnV0ZU5hbWVcbiAgbnVsbCwgLy8gYXR0cmlidXRlTmFtZXNwYWNlXG4gIGZhbHNlLCAvLyBzYW5pdGl6ZVVSTFxuICBmYWxzZSk7XG59KTsgLy8gQSBmZXcgUmVhY3Qgc3RyaW5nIGF0dHJpYnV0ZXMgaGF2ZSBhIGRpZmZlcmVudCBuYW1lLlxuLy8gVGhpcyBpcyBhIG1hcHBpbmcgZnJvbSBSZWFjdCBwcm9wIG5hbWVzIHRvIHRoZSBhdHRyaWJ1dGUgbmFtZXMuXG5cbltbJ2FjY2VwdENoYXJzZXQnLCAnYWNjZXB0LWNoYXJzZXQnXSwgWydjbGFzc05hbWUnLCAnY2xhc3MnXSwgWydodG1sRm9yJywgJ2ZvciddLCBbJ2h0dHBFcXVpdicsICdodHRwLWVxdWl2J11dLmZvckVhY2goZnVuY3Rpb24gKF9yZWYpIHtcbiAgdmFyIG5hbWUgPSBfcmVmWzBdLFxuICAgICAgYXR0cmlidXRlTmFtZSA9IF9yZWZbMV07XG4gIHByb3BlcnRpZXNbbmFtZV0gPSBuZXcgUHJvcGVydHlJbmZvUmVjb3JkKG5hbWUsIFNUUklORywgZmFsc2UsIC8vIG11c3RVc2VQcm9wZXJ0eVxuICBhdHRyaWJ1dGVOYW1lLCAvLyBhdHRyaWJ1dGVOYW1lXG4gIG51bGwsIC8vIGF0dHJpYnV0ZU5hbWVzcGFjZVxuICBmYWxzZSwgLy8gc2FuaXRpemVVUkxcbiAgZmFsc2UpO1xufSk7IC8vIFRoZXNlIGFyZSBcImVudW1lcmF0ZWRcIiBIVE1MIGF0dHJpYnV0ZXMgdGhhdCBhY2NlcHQgXCJ0cnVlXCIgYW5kIFwiZmFsc2VcIi5cbi8vIEluIFJlYWN0LCB3ZSBsZXQgdXNlcnMgcGFzcyBgdHJ1ZWAgYW5kIGBmYWxzZWAgZXZlbiB0aG91Z2ggdGVjaG5pY2FsbHlcbi8vIHRoZXNlIGFyZW4ndCBib29sZWFuIGF0dHJpYnV0ZXMgKHRoZXkgYXJlIGNvZXJjZWQgdG8gc3RyaW5ncykuXG5cblsnY29udGVudEVkaXRhYmxlJywgJ2RyYWdnYWJsZScsICdzcGVsbENoZWNrJywgJ3ZhbHVlJ10uZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICBwcm9wZXJ0aWVzW25hbWVdID0gbmV3IFByb3BlcnR5SW5mb1JlY29yZChuYW1lLCBCT09MRUFOSVNIX1NUUklORywgZmFsc2UsIC8vIG11c3RVc2VQcm9wZXJ0eVxuICBuYW1lLnRvTG93ZXJDYXNlKCksIC8vIGF0dHJpYnV0ZU5hbWVcbiAgbnVsbCwgLy8gYXR0cmlidXRlTmFtZXNwYWNlXG4gIGZhbHNlLCAvLyBzYW5pdGl6ZVVSTFxuICBmYWxzZSk7XG59KTsgLy8gVGhlc2UgYXJlIFwiZW51bWVyYXRlZFwiIFNWRyBhdHRyaWJ1dGVzIHRoYXQgYWNjZXB0IFwidHJ1ZVwiIGFuZCBcImZhbHNlXCIuXG4vLyBJbiBSZWFjdCwgd2UgbGV0IHVzZXJzIHBhc3MgYHRydWVgIGFuZCBgZmFsc2VgIGV2ZW4gdGhvdWdoIHRlY2huaWNhbGx5XG4vLyB0aGVzZSBhcmVuJ3QgYm9vbGVhbiBhdHRyaWJ1dGVzICh0aGV5IGFyZSBjb2VyY2VkIHRvIHN0cmluZ3MpLlxuLy8gU2luY2UgdGhlc2UgYXJlIFNWRyBhdHRyaWJ1dGVzLCB0aGVpciBhdHRyaWJ1dGUgbmFtZXMgYXJlIGNhc2Utc2Vuc2l0aXZlLlxuXG5bJ2F1dG9SZXZlcnNlJywgJ2V4dGVybmFsUmVzb3VyY2VzUmVxdWlyZWQnLCAnZm9jdXNhYmxlJywgJ3ByZXNlcnZlQWxwaGEnXS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gIHByb3BlcnRpZXNbbmFtZV0gPSBuZXcgUHJvcGVydHlJbmZvUmVjb3JkKG5hbWUsIEJPT0xFQU5JU0hfU1RSSU5HLCBmYWxzZSwgLy8gbXVzdFVzZVByb3BlcnR5XG4gIG5hbWUsIC8vIGF0dHJpYnV0ZU5hbWVcbiAgbnVsbCwgLy8gYXR0cmlidXRlTmFtZXNwYWNlXG4gIGZhbHNlLCAvLyBzYW5pdGl6ZVVSTFxuICBmYWxzZSk7XG59KTsgLy8gVGhlc2UgYXJlIEhUTUwgYm9vbGVhbiBhdHRyaWJ1dGVzLlxuXG5bJ2FsbG93RnVsbFNjcmVlbicsICdhc3luYycsIC8vIE5vdGU6IHRoZXJlIGlzIGEgc3BlY2lhbCBjYXNlIHRoYXQgcHJldmVudHMgaXQgZnJvbSBiZWluZyB3cml0dGVuIHRvIHRoZSBET01cbi8vIG9uIHRoZSBjbGllbnQgc2lkZSBiZWNhdXNlIHRoZSBicm93c2VycyBhcmUgaW5jb25zaXN0ZW50LiBJbnN0ZWFkIHdlIGNhbGwgZm9jdXMoKS5cbidhdXRvRm9jdXMnLCAnYXV0b1BsYXknLCAnY29udHJvbHMnLCAnZGVmYXVsdCcsICdkZWZlcicsICdkaXNhYmxlZCcsICdkaXNhYmxlUGljdHVyZUluUGljdHVyZScsICdkaXNhYmxlUmVtb3RlUGxheWJhY2snLCAnZm9ybU5vVmFsaWRhdGUnLCAnaGlkZGVuJywgJ2xvb3AnLCAnbm9Nb2R1bGUnLCAnbm9WYWxpZGF0ZScsICdvcGVuJywgJ3BsYXlzSW5saW5lJywgJ3JlYWRPbmx5JywgJ3JlcXVpcmVkJywgJ3JldmVyc2VkJywgJ3Njb3BlZCcsICdzZWFtbGVzcycsIC8vIE1pY3JvZGF0YVxuJ2l0ZW1TY29wZSddLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgcHJvcGVydGllc1tuYW1lXSA9IG5ldyBQcm9wZXJ0eUluZm9SZWNvcmQobmFtZSwgQk9PTEVBTiwgZmFsc2UsIC8vIG11c3RVc2VQcm9wZXJ0eVxuICBuYW1lLnRvTG93ZXJDYXNlKCksIC8vIGF0dHJpYnV0ZU5hbWVcbiAgbnVsbCwgLy8gYXR0cmlidXRlTmFtZXNwYWNlXG4gIGZhbHNlLCAvLyBzYW5pdGl6ZVVSTFxuICBmYWxzZSk7XG59KTsgLy8gVGhlc2UgYXJlIHRoZSBmZXcgUmVhY3QgcHJvcHMgdGhhdCB3ZSBzZXQgYXMgRE9NIHByb3BlcnRpZXNcbi8vIHJhdGhlciB0aGFuIGF0dHJpYnV0ZXMuIFRoZXNlIGFyZSBhbGwgYm9vbGVhbnMuXG5cblsnY2hlY2tlZCcsIC8vIE5vdGU6IGBvcHRpb24uc2VsZWN0ZWRgIGlzIG5vdCB1cGRhdGVkIGlmIGBzZWxlY3QubXVsdGlwbGVgIGlzXG4vLyBkaXNhYmxlZCB3aXRoIGByZW1vdmVBdHRyaWJ1dGVgLiBXZSBoYXZlIHNwZWNpYWwgbG9naWMgZm9yIGhhbmRsaW5nIHRoaXMuXG4nbXVsdGlwbGUnLCAnbXV0ZWQnLCAnc2VsZWN0ZWQnIC8vIE5PVEU6IGlmIHlvdSBhZGQgYSBjYW1lbENhc2VkIHByb3AgdG8gdGhpcyBsaXN0LFxuLy8geW91J2xsIG5lZWQgdG8gc2V0IGF0dHJpYnV0ZU5hbWUgdG8gbmFtZS50b0xvd2VyQ2FzZSgpXG4vLyBpbnN0ZWFkIGluIHRoZSBhc3NpZ25tZW50IGJlbG93LlxuXS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gIHByb3BlcnRpZXNbbmFtZV0gPSBuZXcgUHJvcGVydHlJbmZvUmVjb3JkKG5hbWUsIEJPT0xFQU4sIHRydWUsIC8vIG11c3RVc2VQcm9wZXJ0eVxuICBuYW1lLCAvLyBhdHRyaWJ1dGVOYW1lXG4gIG51bGwsIC8vIGF0dHJpYnV0ZU5hbWVzcGFjZVxuICBmYWxzZSwgLy8gc2FuaXRpemVVUkxcbiAgZmFsc2UpO1xufSk7IC8vIFRoZXNlIGFyZSBIVE1MIGF0dHJpYnV0ZXMgdGhhdCBhcmUgXCJvdmVybG9hZGVkIGJvb2xlYW5zXCI6IHRoZXkgYmVoYXZlIGxpa2Vcbi8vIGJvb2xlYW5zLCBidXQgY2FuIGFsc28gYWNjZXB0IGEgc3RyaW5nIHZhbHVlLlxuXG5bJ2NhcHR1cmUnLCAnZG93bmxvYWQnIC8vIE5PVEU6IGlmIHlvdSBhZGQgYSBjYW1lbENhc2VkIHByb3AgdG8gdGhpcyBsaXN0LFxuLy8geW91J2xsIG5lZWQgdG8gc2V0IGF0dHJpYnV0ZU5hbWUgdG8gbmFtZS50b0xvd2VyQ2FzZSgpXG4vLyBpbnN0ZWFkIGluIHRoZSBhc3NpZ25tZW50IGJlbG93LlxuXS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gIHByb3BlcnRpZXNbbmFtZV0gPSBuZXcgUHJvcGVydHlJbmZvUmVjb3JkKG5hbWUsIE9WRVJMT0FERURfQk9PTEVBTiwgZmFsc2UsIC8vIG11c3RVc2VQcm9wZXJ0eVxuICBuYW1lLCAvLyBhdHRyaWJ1dGVOYW1lXG4gIG51bGwsIC8vIGF0dHJpYnV0ZU5hbWVzcGFjZVxuICBmYWxzZSwgLy8gc2FuaXRpemVVUkxcbiAgZmFsc2UpO1xufSk7IC8vIFRoZXNlIGFyZSBIVE1MIGF0dHJpYnV0ZXMgdGhhdCBtdXN0IGJlIHBvc2l0aXZlIG51bWJlcnMuXG5cblsnY29scycsICdyb3dzJywgJ3NpemUnLCAnc3BhbicgLy8gTk9URTogaWYgeW91IGFkZCBhIGNhbWVsQ2FzZWQgcHJvcCB0byB0aGlzIGxpc3QsXG4vLyB5b3UnbGwgbmVlZCB0byBzZXQgYXR0cmlidXRlTmFtZSB0byBuYW1lLnRvTG93ZXJDYXNlKClcbi8vIGluc3RlYWQgaW4gdGhlIGFzc2lnbm1lbnQgYmVsb3cuXG5dLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgcHJvcGVydGllc1tuYW1lXSA9IG5ldyBQcm9wZXJ0eUluZm9SZWNvcmQobmFtZSwgUE9TSVRJVkVfTlVNRVJJQywgZmFsc2UsIC8vIG11c3RVc2VQcm9wZXJ0eVxuICBuYW1lLCAvLyBhdHRyaWJ1dGVOYW1lXG4gIG51bGwsIC8vIGF0dHJpYnV0ZU5hbWVzcGFjZVxuICBmYWxzZSwgLy8gc2FuaXRpemVVUkxcbiAgZmFsc2UpO1xufSk7IC8vIFRoZXNlIGFyZSBIVE1MIGF0dHJpYnV0ZXMgdGhhdCBtdXN0IGJlIG51bWJlcnMuXG5cblsncm93U3BhbicsICdzdGFydCddLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgcHJvcGVydGllc1tuYW1lXSA9IG5ldyBQcm9wZXJ0eUluZm9SZWNvcmQobmFtZSwgTlVNRVJJQywgZmFsc2UsIC8vIG11c3RVc2VQcm9wZXJ0eVxuICBuYW1lLnRvTG93ZXJDYXNlKCksIC8vIGF0dHJpYnV0ZU5hbWVcbiAgbnVsbCwgLy8gYXR0cmlidXRlTmFtZXNwYWNlXG4gIGZhbHNlLCAvLyBzYW5pdGl6ZVVSTFxuICBmYWxzZSk7XG59KTtcbnZhciBDQU1FTElaRSA9IC9bXFwtXFw6XShbYS16XSkvZztcblxudmFyIGNhcGl0YWxpemUgPSBmdW5jdGlvbiAodG9rZW4pIHtcbiAgcmV0dXJuIHRva2VuWzFdLnRvVXBwZXJDYXNlKCk7XG59OyAvLyBUaGlzIGlzIGEgbGlzdCBvZiBhbGwgU1ZHIGF0dHJpYnV0ZXMgdGhhdCBuZWVkIHNwZWNpYWwgY2FzaW5nLCBuYW1lc3BhY2luZyxcbi8vIG9yIGJvb2xlYW4gdmFsdWUgYXNzaWdubWVudC4gUmVndWxhciBhdHRyaWJ1dGVzIHRoYXQganVzdCBhY2NlcHQgc3RyaW5nc1xuLy8gYW5kIGhhdmUgdGhlIHNhbWUgbmFtZXMgYXJlIG9taXR0ZWQsIGp1c3QgbGlrZSBpbiB0aGUgSFRNTCBhdHRyaWJ1dGUgZmlsdGVyLlxuLy8gU29tZSBvZiB0aGVzZSBhdHRyaWJ1dGVzIGNhbiBiZSBoYXJkIHRvIGZpbmQuIFRoaXMgbGlzdCB3YXMgY3JlYXRlZCBieVxuLy8gc2NyYXBpbmcgdGhlIE1ETiBkb2N1bWVudGF0aW9uLlxuXG5cblsnYWNjZW50LWhlaWdodCcsICdhbGlnbm1lbnQtYmFzZWxpbmUnLCAnYXJhYmljLWZvcm0nLCAnYmFzZWxpbmUtc2hpZnQnLCAnY2FwLWhlaWdodCcsICdjbGlwLXBhdGgnLCAnY2xpcC1ydWxlJywgJ2NvbG9yLWludGVycG9sYXRpb24nLCAnY29sb3ItaW50ZXJwb2xhdGlvbi1maWx0ZXJzJywgJ2NvbG9yLXByb2ZpbGUnLCAnY29sb3ItcmVuZGVyaW5nJywgJ2RvbWluYW50LWJhc2VsaW5lJywgJ2VuYWJsZS1iYWNrZ3JvdW5kJywgJ2ZpbGwtb3BhY2l0eScsICdmaWxsLXJ1bGUnLCAnZmxvb2QtY29sb3InLCAnZmxvb2Qtb3BhY2l0eScsICdmb250LWZhbWlseScsICdmb250LXNpemUnLCAnZm9udC1zaXplLWFkanVzdCcsICdmb250LXN0cmV0Y2gnLCAnZm9udC1zdHlsZScsICdmb250LXZhcmlhbnQnLCAnZm9udC13ZWlnaHQnLCAnZ2x5cGgtbmFtZScsICdnbHlwaC1vcmllbnRhdGlvbi1ob3Jpem9udGFsJywgJ2dseXBoLW9yaWVudGF0aW9uLXZlcnRpY2FsJywgJ2hvcml6LWFkdi14JywgJ2hvcml6LW9yaWdpbi14JywgJ2ltYWdlLXJlbmRlcmluZycsICdsZXR0ZXItc3BhY2luZycsICdsaWdodGluZy1jb2xvcicsICdtYXJrZXItZW5kJywgJ21hcmtlci1taWQnLCAnbWFya2VyLXN0YXJ0JywgJ292ZXJsaW5lLXBvc2l0aW9uJywgJ292ZXJsaW5lLXRoaWNrbmVzcycsICdwYWludC1vcmRlcicsICdwYW5vc2UtMScsICdwb2ludGVyLWV2ZW50cycsICdyZW5kZXJpbmctaW50ZW50JywgJ3NoYXBlLXJlbmRlcmluZycsICdzdG9wLWNvbG9yJywgJ3N0b3Atb3BhY2l0eScsICdzdHJpa2V0aHJvdWdoLXBvc2l0aW9uJywgJ3N0cmlrZXRocm91Z2gtdGhpY2tuZXNzJywgJ3N0cm9rZS1kYXNoYXJyYXknLCAnc3Ryb2tlLWRhc2hvZmZzZXQnLCAnc3Ryb2tlLWxpbmVjYXAnLCAnc3Ryb2tlLWxpbmVqb2luJywgJ3N0cm9rZS1taXRlcmxpbWl0JywgJ3N0cm9rZS1vcGFjaXR5JywgJ3N0cm9rZS13aWR0aCcsICd0ZXh0LWFuY2hvcicsICd0ZXh0LWRlY29yYXRpb24nLCAndGV4dC1yZW5kZXJpbmcnLCAndW5kZXJsaW5lLXBvc2l0aW9uJywgJ3VuZGVybGluZS10aGlja25lc3MnLCAndW5pY29kZS1iaWRpJywgJ3VuaWNvZGUtcmFuZ2UnLCAndW5pdHMtcGVyLWVtJywgJ3YtYWxwaGFiZXRpYycsICd2LWhhbmdpbmcnLCAndi1pZGVvZ3JhcGhpYycsICd2LW1hdGhlbWF0aWNhbCcsICd2ZWN0b3ItZWZmZWN0JywgJ3ZlcnQtYWR2LXknLCAndmVydC1vcmlnaW4teCcsICd2ZXJ0LW9yaWdpbi15JywgJ3dvcmQtc3BhY2luZycsICd3cml0aW5nLW1vZGUnLCAneG1sbnM6eGxpbmsnLCAneC1oZWlnaHQnIC8vIE5PVEU6IGlmIHlvdSBhZGQgYSBjYW1lbENhc2VkIHByb3AgdG8gdGhpcyBsaXN0LFxuLy8geW91J2xsIG5lZWQgdG8gc2V0IGF0dHJpYnV0ZU5hbWUgdG8gbmFtZS50b0xvd2VyQ2FzZSgpXG4vLyBpbnN0ZWFkIGluIHRoZSBhc3NpZ25tZW50IGJlbG93LlxuXS5mb3JFYWNoKGZ1bmN0aW9uIChhdHRyaWJ1dGVOYW1lKSB7XG4gIHZhciBuYW1lID0gYXR0cmlidXRlTmFtZS5yZXBsYWNlKENBTUVMSVpFLCBjYXBpdGFsaXplKTtcbiAgcHJvcGVydGllc1tuYW1lXSA9IG5ldyBQcm9wZXJ0eUluZm9SZWNvcmQobmFtZSwgU1RSSU5HLCBmYWxzZSwgLy8gbXVzdFVzZVByb3BlcnR5XG4gIGF0dHJpYnV0ZU5hbWUsIG51bGwsIC8vIGF0dHJpYnV0ZU5hbWVzcGFjZVxuICBmYWxzZSwgLy8gc2FuaXRpemVVUkxcbiAgZmFsc2UpO1xufSk7IC8vIFN0cmluZyBTVkcgYXR0cmlidXRlcyB3aXRoIHRoZSB4bGluayBuYW1lc3BhY2UuXG5cblsneGxpbms6YWN0dWF0ZScsICd4bGluazphcmNyb2xlJywgJ3hsaW5rOnJvbGUnLCAneGxpbms6c2hvdycsICd4bGluazp0aXRsZScsICd4bGluazp0eXBlJyAvLyBOT1RFOiBpZiB5b3UgYWRkIGEgY2FtZWxDYXNlZCBwcm9wIHRvIHRoaXMgbGlzdCxcbi8vIHlvdSdsbCBuZWVkIHRvIHNldCBhdHRyaWJ1dGVOYW1lIHRvIG5hbWUudG9Mb3dlckNhc2UoKVxuLy8gaW5zdGVhZCBpbiB0aGUgYXNzaWdubWVudCBiZWxvdy5cbl0uZm9yRWFjaChmdW5jdGlvbiAoYXR0cmlidXRlTmFtZSkge1xuICB2YXIgbmFtZSA9IGF0dHJpYnV0ZU5hbWUucmVwbGFjZShDQU1FTElaRSwgY2FwaXRhbGl6ZSk7XG4gIHByb3BlcnRpZXNbbmFtZV0gPSBuZXcgUHJvcGVydHlJbmZvUmVjb3JkKG5hbWUsIFNUUklORywgZmFsc2UsIC8vIG11c3RVc2VQcm9wZXJ0eVxuICBhdHRyaWJ1dGVOYW1lLCAnaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycsIGZhbHNlLCAvLyBzYW5pdGl6ZVVSTFxuICBmYWxzZSk7XG59KTsgLy8gU3RyaW5nIFNWRyBhdHRyaWJ1dGVzIHdpdGggdGhlIHhtbCBuYW1lc3BhY2UuXG5cblsneG1sOmJhc2UnLCAneG1sOmxhbmcnLCAneG1sOnNwYWNlJyAvLyBOT1RFOiBpZiB5b3UgYWRkIGEgY2FtZWxDYXNlZCBwcm9wIHRvIHRoaXMgbGlzdCxcbi8vIHlvdSdsbCBuZWVkIHRvIHNldCBhdHRyaWJ1dGVOYW1lIHRvIG5hbWUudG9Mb3dlckNhc2UoKVxuLy8gaW5zdGVhZCBpbiB0aGUgYXNzaWdubWVudCBiZWxvdy5cbl0uZm9yRWFjaChmdW5jdGlvbiAoYXR0cmlidXRlTmFtZSkge1xuICB2YXIgbmFtZSA9IGF0dHJpYnV0ZU5hbWUucmVwbGFjZShDQU1FTElaRSwgY2FwaXRhbGl6ZSk7XG4gIHByb3BlcnRpZXNbbmFtZV0gPSBuZXcgUHJvcGVydHlJbmZvUmVjb3JkKG5hbWUsIFNUUklORywgZmFsc2UsIC8vIG11c3RVc2VQcm9wZXJ0eVxuICBhdHRyaWJ1dGVOYW1lLCAnaHR0cDovL3d3dy53My5vcmcvWE1MLzE5OTgvbmFtZXNwYWNlJywgZmFsc2UsIC8vIHNhbml0aXplVVJMXG4gIGZhbHNlKTtcbn0pOyAvLyBUaGVzZSBhdHRyaWJ1dGUgZXhpc3RzIGJvdGggaW4gSFRNTCBhbmQgU1ZHLlxuLy8gVGhlIGF0dHJpYnV0ZSBuYW1lIGlzIGNhc2Utc2Vuc2l0aXZlIGluIFNWRyBzbyB3ZSBjYW4ndCBqdXN0IHVzZVxuLy8gdGhlIFJlYWN0IG5hbWUgbGlrZSB3ZSBkbyBmb3IgYXR0cmlidXRlcyB0aGF0IGV4aXN0IG9ubHkgaW4gSFRNTC5cblxuWyd0YWJJbmRleCcsICdjcm9zc09yaWdpbiddLmZvckVhY2goZnVuY3Rpb24gKGF0dHJpYnV0ZU5hbWUpIHtcbiAgcHJvcGVydGllc1thdHRyaWJ1dGVOYW1lXSA9IG5ldyBQcm9wZXJ0eUluZm9SZWNvcmQoYXR0cmlidXRlTmFtZSwgU1RSSU5HLCBmYWxzZSwgLy8gbXVzdFVzZVByb3BlcnR5XG4gIGF0dHJpYnV0ZU5hbWUudG9Mb3dlckNhc2UoKSwgLy8gYXR0cmlidXRlTmFtZVxuICBudWxsLCAvLyBhdHRyaWJ1dGVOYW1lc3BhY2VcbiAgZmFsc2UsIC8vIHNhbml0aXplVVJMXG4gIGZhbHNlKTtcbn0pOyAvLyBUaGVzZSBhdHRyaWJ1dGVzIGFjY2VwdCBVUkxzLiBUaGVzZSBtdXN0IG5vdCBhbGxvdyBqYXZhc2NyaXB0OiBVUkxTLlxuLy8gVGhlc2Ugd2lsbCBhbHNvIG5lZWQgdG8gYWNjZXB0IFRydXN0ZWQgVHlwZXMgb2JqZWN0IGluIHRoZSBmdXR1cmUuXG5cbnZhciB4bGlua0hyZWYgPSAneGxpbmtIcmVmJztcbnByb3BlcnRpZXNbeGxpbmtIcmVmXSA9IG5ldyBQcm9wZXJ0eUluZm9SZWNvcmQoJ3hsaW5rSHJlZicsIFNUUklORywgZmFsc2UsIC8vIG11c3RVc2VQcm9wZXJ0eVxuJ3hsaW5rOmhyZWYnLCAnaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycsIHRydWUsIC8vIHNhbml0aXplVVJMXG5mYWxzZSk7XG5bJ3NyYycsICdocmVmJywgJ2FjdGlvbicsICdmb3JtQWN0aW9uJ10uZm9yRWFjaChmdW5jdGlvbiAoYXR0cmlidXRlTmFtZSkge1xuICBwcm9wZXJ0aWVzW2F0dHJpYnV0ZU5hbWVdID0gbmV3IFByb3BlcnR5SW5mb1JlY29yZChhdHRyaWJ1dGVOYW1lLCBTVFJJTkcsIGZhbHNlLCAvLyBtdXN0VXNlUHJvcGVydHlcbiAgYXR0cmlidXRlTmFtZS50b0xvd2VyQ2FzZSgpLCAvLyBhdHRyaWJ1dGVOYW1lXG4gIG51bGwsIC8vIGF0dHJpYnV0ZU5hbWVzcGFjZVxuICB0cnVlLCAvLyBzYW5pdGl6ZVVSTFxuICB0cnVlKTtcbn0pO1xuXG4vLyBhbmQgYW55IG5ld2xpbmUgb3IgdGFiIGFyZSBmaWx0ZXJlZCBvdXQgYXMgaWYgdGhleSdyZSBub3QgcGFydCBvZiB0aGUgVVJMLlxuLy8gaHR0cHM6Ly91cmwuc3BlYy53aGF0d2cub3JnLyN1cmwtcGFyc2luZ1xuLy8gVGFiIG9yIG5ld2xpbmUgYXJlIGRlZmluZWQgYXMgXFxyXFxuXFx0OlxuLy8gaHR0cHM6Ly9pbmZyYS5zcGVjLndoYXR3Zy5vcmcvI2FzY2lpLXRhYi1vci1uZXdsaW5lXG4vLyBBIEMwIGNvbnRyb2wgaXMgYSBjb2RlIHBvaW50IGluIHRoZSByYW5nZSBcXHUwMDAwIE5VTEwgdG8gXFx1MDAxRlxuLy8gSU5GT1JNQVRJT04gU0VQQVJBVE9SIE9ORSwgaW5jbHVzaXZlOlxuLy8gaHR0cHM6Ly9pbmZyYS5zcGVjLndoYXR3Zy5vcmcvI2MwLWNvbnRyb2wtb3Itc3BhY2VcblxuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiAqL1xuXG52YXIgaXNKYXZhU2NyaXB0UHJvdG9jb2wgPSAvXltcXHUwMDAwLVxcdTAwMUYgXSpqW1xcclxcblxcdF0qYVtcXHJcXG5cXHRdKnZbXFxyXFxuXFx0XSphW1xcclxcblxcdF0qc1tcXHJcXG5cXHRdKmNbXFxyXFxuXFx0XSpyW1xcclxcblxcdF0qaVtcXHJcXG5cXHRdKnBbXFxyXFxuXFx0XSp0W1xcclxcblxcdF0qXFw6L2k7XG52YXIgZGlkV2FybiA9IGZhbHNlO1xuXG5mdW5jdGlvbiBzYW5pdGl6ZVVSTCh1cmwpIHtcbiAge1xuICAgIGlmICghZGlkV2FybiAmJiBpc0phdmFTY3JpcHRQcm90b2NvbC50ZXN0KHVybCkpIHtcbiAgICAgIGRpZFdhcm4gPSB0cnVlO1xuXG4gICAgICBlcnJvcignQSBmdXR1cmUgdmVyc2lvbiBvZiBSZWFjdCB3aWxsIGJsb2NrIGphdmFzY3JpcHQ6IFVSTHMgYXMgYSBzZWN1cml0eSBwcmVjYXV0aW9uLiAnICsgJ1VzZSBldmVudCBoYW5kbGVycyBpbnN0ZWFkIGlmIHlvdSBjYW4uIElmIHlvdSBuZWVkIHRvIGdlbmVyYXRlIHVuc2FmZSBIVE1MIHRyeSAnICsgJ3VzaW5nIGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MIGluc3RlYWQuIFJlYWN0IHdhcyBwYXNzZWQgJXMuJywgSlNPTi5zdHJpbmdpZnkodXJsKSk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogR2V0IHRoZSB2YWx1ZSBmb3IgYSBwcm9wZXJ0eSBvbiBhIG5vZGUuIE9ubHkgdXNlZCBpbiBERVYgZm9yIFNTUiB2YWxpZGF0aW9uLlxuICogVGhlIFwiZXhwZWN0ZWRcIiBhcmd1bWVudCBpcyB1c2VkIGFzIGEgaGludCBvZiB3aGF0IHRoZSBleHBlY3RlZCB2YWx1ZSBpcy5cbiAqIFNvbWUgcHJvcGVydGllcyBoYXZlIG11bHRpcGxlIGVxdWl2YWxlbnQgdmFsdWVzLlxuICovXG5mdW5jdGlvbiBnZXRWYWx1ZUZvclByb3BlcnR5KG5vZGUsIG5hbWUsIGV4cGVjdGVkLCBwcm9wZXJ0eUluZm8pIHtcbiAge1xuICAgIGlmIChwcm9wZXJ0eUluZm8ubXVzdFVzZVByb3BlcnR5KSB7XG4gICAgICB2YXIgcHJvcGVydHlOYW1lID0gcHJvcGVydHlJbmZvLnByb3BlcnR5TmFtZTtcbiAgICAgIHJldHVybiBub2RlW3Byb3BlcnR5TmFtZV07XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICggcHJvcGVydHlJbmZvLnNhbml0aXplVVJMKSB7XG4gICAgICAgIC8vIElmIHdlIGhhdmVuJ3QgZnVsbHkgZGlzYWJsZWQgamF2YXNjcmlwdDogVVJMcywgYW5kIGlmXG4gICAgICAgIC8vIHRoZSBoeWRyYXRpb24gaXMgc3VjY2Vzc2Z1bCBvZiBhIGphdmFzY3JpcHQ6IFVSTCwgd2VcbiAgICAgICAgLy8gc3RpbGwgd2FudCB0byB3YXJuIG9uIHRoZSBjbGllbnQuXG4gICAgICAgIHNhbml0aXplVVJMKCcnICsgZXhwZWN0ZWQpO1xuICAgICAgfVxuXG4gICAgICB2YXIgYXR0cmlidXRlTmFtZSA9IHByb3BlcnR5SW5mby5hdHRyaWJ1dGVOYW1lO1xuICAgICAgdmFyIHN0cmluZ1ZhbHVlID0gbnVsbDtcblxuICAgICAgaWYgKHByb3BlcnR5SW5mby50eXBlID09PSBPVkVSTE9BREVEX0JPT0xFQU4pIHtcbiAgICAgICAgaWYgKG5vZGUuaGFzQXR0cmlidXRlKGF0dHJpYnV0ZU5hbWUpKSB7XG4gICAgICAgICAgdmFyIHZhbHVlID0gbm9kZS5nZXRBdHRyaWJ1dGUoYXR0cmlidXRlTmFtZSk7XG5cbiAgICAgICAgICBpZiAodmFsdWUgPT09ICcnKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoc2hvdWxkUmVtb3ZlQXR0cmlidXRlKG5hbWUsIGV4cGVjdGVkLCBwcm9wZXJ0eUluZm8sIGZhbHNlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh2YWx1ZSA9PT0gJycgKyBleHBlY3RlZCkge1xuICAgICAgICAgICAgcmV0dXJuIGV4cGVjdGVkO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChub2RlLmhhc0F0dHJpYnV0ZShhdHRyaWJ1dGVOYW1lKSkge1xuICAgICAgICBpZiAoc2hvdWxkUmVtb3ZlQXR0cmlidXRlKG5hbWUsIGV4cGVjdGVkLCBwcm9wZXJ0eUluZm8sIGZhbHNlKSkge1xuICAgICAgICAgIC8vIFdlIGhhZCBhbiBhdHRyaWJ1dGUgYnV0IHNob3VsZG4ndCBoYXZlIGhhZCBvbmUsIHNvIHJlYWQgaXRcbiAgICAgICAgICAvLyBmb3IgdGhlIGVycm9yIG1lc3NhZ2UuXG4gICAgICAgICAgcmV0dXJuIG5vZGUuZ2V0QXR0cmlidXRlKGF0dHJpYnV0ZU5hbWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHByb3BlcnR5SW5mby50eXBlID09PSBCT09MRUFOKSB7XG4gICAgICAgICAgLy8gSWYgdGhpcyB3YXMgYSBib29sZWFuLCBpdCBkb2Vzbid0IG1hdHRlciB3aGF0IHRoZSB2YWx1ZSBpc1xuICAgICAgICAgIC8vIHRoZSBmYWN0IHRoYXQgd2UgaGF2ZSBpdCBpcyB0aGUgc2FtZSBhcyB0aGUgZXhwZWN0ZWQuXG4gICAgICAgICAgcmV0dXJuIGV4cGVjdGVkO1xuICAgICAgICB9IC8vIEV2ZW4gaWYgdGhpcyBwcm9wZXJ0eSB1c2VzIGEgbmFtZXNwYWNlIHdlIHVzZSBnZXRBdHRyaWJ1dGVcbiAgICAgICAgLy8gYmVjYXVzZSB3ZSBhc3N1bWUgaXRzIG5hbWVzcGFjZWQgbmFtZSBpcyB0aGUgc2FtZSBhcyBvdXIgY29uZmlnLlxuICAgICAgICAvLyBUbyB1c2UgZ2V0QXR0cmlidXRlTlMgd2UgbmVlZCB0aGUgbG9jYWwgbmFtZSB3aGljaCB3ZSBkb24ndCBoYXZlXG4gICAgICAgIC8vIGluIG91ciBjb25maWcgYXRtLlxuXG5cbiAgICAgICAgc3RyaW5nVmFsdWUgPSBub2RlLmdldEF0dHJpYnV0ZShhdHRyaWJ1dGVOYW1lKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHNob3VsZFJlbW92ZUF0dHJpYnV0ZShuYW1lLCBleHBlY3RlZCwgcHJvcGVydHlJbmZvLCBmYWxzZSkpIHtcbiAgICAgICAgcmV0dXJuIHN0cmluZ1ZhbHVlID09PSBudWxsID8gZXhwZWN0ZWQgOiBzdHJpbmdWYWx1ZTtcbiAgICAgIH0gZWxzZSBpZiAoc3RyaW5nVmFsdWUgPT09ICcnICsgZXhwZWN0ZWQpIHtcbiAgICAgICAgcmV0dXJuIGV4cGVjdGVkO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHN0cmluZ1ZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuLyoqXG4gKiBHZXQgdGhlIHZhbHVlIGZvciBhIGF0dHJpYnV0ZSBvbiBhIG5vZGUuIE9ubHkgdXNlZCBpbiBERVYgZm9yIFNTUiB2YWxpZGF0aW9uLlxuICogVGhlIHRoaXJkIGFyZ3VtZW50IGlzIHVzZWQgYXMgYSBoaW50IG9mIHdoYXQgdGhlIGV4cGVjdGVkIHZhbHVlIGlzLiBTb21lXG4gKiBhdHRyaWJ1dGVzIGhhdmUgbXVsdGlwbGUgZXF1aXZhbGVudCB2YWx1ZXMuXG4gKi9cblxuZnVuY3Rpb24gZ2V0VmFsdWVGb3JBdHRyaWJ1dGUobm9kZSwgbmFtZSwgZXhwZWN0ZWQpIHtcbiAge1xuICAgIGlmICghaXNBdHRyaWJ1dGVOYW1lU2FmZShuYW1lKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gSWYgdGhlIG9iamVjdCBpcyBhbiBvcGFxdWUgcmVmZXJlbmNlIElELCBpdCdzIGV4cGVjdGVkIHRoYXRcbiAgICAvLyB0aGUgbmV4dCBwcm9wIGlzIGRpZmZlcmVudCB0aGFuIHRoZSBzZXJ2ZXIgdmFsdWUsIHNvIGp1c3QgcmV0dXJuXG4gICAgLy8gZXhwZWN0ZWRcblxuXG4gICAgaWYgKGlzT3BhcXVlSHlkcmF0aW5nT2JqZWN0KGV4cGVjdGVkKSkge1xuICAgICAgcmV0dXJuIGV4cGVjdGVkO1xuICAgIH1cblxuICAgIGlmICghbm9kZS5oYXNBdHRyaWJ1dGUobmFtZSkpIHtcbiAgICAgIHJldHVybiBleHBlY3RlZCA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgdmFsdWUgPSBub2RlLmdldEF0dHJpYnV0ZShuYW1lKTtcblxuICAgIGlmICh2YWx1ZSA9PT0gJycgKyBleHBlY3RlZCkge1xuICAgICAgcmV0dXJuIGV4cGVjdGVkO1xuICAgIH1cblxuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxufVxuLyoqXG4gKiBTZXRzIHRoZSB2YWx1ZSBmb3IgYSBwcm9wZXJ0eSBvbiBhIG5vZGUuXG4gKlxuICogQHBhcmFtIHtET01FbGVtZW50fSBub2RlXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICogQHBhcmFtIHsqfSB2YWx1ZVxuICovXG5cbmZ1bmN0aW9uIHNldFZhbHVlRm9yUHJvcGVydHkobm9kZSwgbmFtZSwgdmFsdWUsIGlzQ3VzdG9tQ29tcG9uZW50VGFnKSB7XG4gIHZhciBwcm9wZXJ0eUluZm8gPSBnZXRQcm9wZXJ0eUluZm8obmFtZSk7XG5cbiAgaWYgKHNob3VsZElnbm9yZUF0dHJpYnV0ZShuYW1lLCBwcm9wZXJ0eUluZm8sIGlzQ3VzdG9tQ29tcG9uZW50VGFnKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChzaG91bGRSZW1vdmVBdHRyaWJ1dGUobmFtZSwgdmFsdWUsIHByb3BlcnR5SW5mbywgaXNDdXN0b21Db21wb25lbnRUYWcpKSB7XG4gICAgdmFsdWUgPSBudWxsO1xuICB9IC8vIElmIHRoZSBwcm9wIGlzbid0IGluIHRoZSBzcGVjaWFsIGxpc3QsIHRyZWF0IGl0IGFzIGEgc2ltcGxlIGF0dHJpYnV0ZS5cblxuXG4gIGlmIChpc0N1c3RvbUNvbXBvbmVudFRhZyB8fCBwcm9wZXJ0eUluZm8gPT09IG51bGwpIHtcbiAgICBpZiAoaXNBdHRyaWJ1dGVOYW1lU2FmZShuYW1lKSkge1xuICAgICAgdmFyIF9hdHRyaWJ1dGVOYW1lID0gbmFtZTtcblxuICAgICAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgIG5vZGUucmVtb3ZlQXR0cmlidXRlKF9hdHRyaWJ1dGVOYW1lKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5vZGUuc2V0QXR0cmlidXRlKF9hdHRyaWJ1dGVOYW1lLCAgJycgKyB2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIG11c3RVc2VQcm9wZXJ0eSA9IHByb3BlcnR5SW5mby5tdXN0VXNlUHJvcGVydHk7XG5cbiAgaWYgKG11c3RVc2VQcm9wZXJ0eSkge1xuICAgIHZhciBwcm9wZXJ0eU5hbWUgPSBwcm9wZXJ0eUluZm8ucHJvcGVydHlOYW1lO1xuXG4gICAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgICB2YXIgdHlwZSA9IHByb3BlcnR5SW5mby50eXBlO1xuICAgICAgbm9kZVtwcm9wZXJ0eU5hbWVdID0gdHlwZSA9PT0gQk9PTEVBTiA/IGZhbHNlIDogJyc7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIENvbnRyYXJ5IHRvIGBzZXRBdHRyaWJ1dGVgLCBvYmplY3QgcHJvcGVydGllcyBhcmUgcHJvcGVybHlcbiAgICAgIC8vIGB0b1N0cmluZ2BlZCBieSBJRTgvOS5cbiAgICAgIG5vZGVbcHJvcGVydHlOYW1lXSA9IHZhbHVlO1xuICAgIH1cblxuICAgIHJldHVybjtcbiAgfSAvLyBUaGUgcmVzdCBhcmUgdHJlYXRlZCBhcyBhdHRyaWJ1dGVzIHdpdGggc3BlY2lhbCBjYXNlcy5cblxuXG4gIHZhciBhdHRyaWJ1dGVOYW1lID0gcHJvcGVydHlJbmZvLmF0dHJpYnV0ZU5hbWUsXG4gICAgICBhdHRyaWJ1dGVOYW1lc3BhY2UgPSBwcm9wZXJ0eUluZm8uYXR0cmlidXRlTmFtZXNwYWNlO1xuXG4gIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgIG5vZGUucmVtb3ZlQXR0cmlidXRlKGF0dHJpYnV0ZU5hbWUpO1xuICB9IGVsc2Uge1xuICAgIHZhciBfdHlwZSA9IHByb3BlcnR5SW5mby50eXBlO1xuICAgIHZhciBhdHRyaWJ1dGVWYWx1ZTtcblxuICAgIGlmIChfdHlwZSA9PT0gQk9PTEVBTiB8fCBfdHlwZSA9PT0gT1ZFUkxPQURFRF9CT09MRUFOICYmIHZhbHVlID09PSB0cnVlKSB7XG4gICAgICAvLyBJZiBhdHRyaWJ1dGUgdHlwZSBpcyBib29sZWFuLCB3ZSBrbm93IGZvciBzdXJlIGl0IHdvbid0IGJlIGFuIGV4ZWN1dGlvbiBzaW5rXG4gICAgICAvLyBhbmQgd2Ugd29uJ3QgcmVxdWlyZSBUcnVzdGVkIFR5cGUgaGVyZS5cbiAgICAgIGF0dHJpYnV0ZVZhbHVlID0gJyc7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGBzZXRBdHRyaWJ1dGVgIHdpdGggb2JqZWN0cyBiZWNvbWVzIG9ubHkgYFtvYmplY3RdYCBpbiBJRTgvOSxcbiAgICAgIC8vICgnJyArIHZhbHVlKSBtYWtlcyBpdCBvdXRwdXQgdGhlIGNvcnJlY3QgdG9TdHJpbmcoKS12YWx1ZS5cbiAgICAgIHtcbiAgICAgICAgYXR0cmlidXRlVmFsdWUgPSAnJyArIHZhbHVlO1xuICAgICAgfVxuXG4gICAgICBpZiAocHJvcGVydHlJbmZvLnNhbml0aXplVVJMKSB7XG4gICAgICAgIHNhbml0aXplVVJMKGF0dHJpYnV0ZVZhbHVlLnRvU3RyaW5nKCkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChhdHRyaWJ1dGVOYW1lc3BhY2UpIHtcbiAgICAgIG5vZGUuc2V0QXR0cmlidXRlTlMoYXR0cmlidXRlTmFtZXNwYWNlLCBhdHRyaWJ1dGVOYW1lLCBhdHRyaWJ1dGVWYWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5vZGUuc2V0QXR0cmlidXRlKGF0dHJpYnV0ZU5hbWUsIGF0dHJpYnV0ZVZhbHVlKTtcbiAgICB9XG4gIH1cbn1cblxuLy8gQVRURU5USU9OXG4vLyBXaGVuIGFkZGluZyBuZXcgc3ltYm9scyB0byB0aGlzIGZpbGUsXG4vLyBQbGVhc2UgY29uc2lkZXIgYWxzbyBhZGRpbmcgdG8gJ3JlYWN0LWRldnRvb2xzLXNoYXJlZC9zcmMvYmFja2VuZC9SZWFjdFN5bWJvbHMnXG4vLyBUaGUgU3ltYm9sIHVzZWQgdG8gdGFnIHRoZSBSZWFjdEVsZW1lbnQtbGlrZSB0eXBlcy4gSWYgdGhlcmUgaXMgbm8gbmF0aXZlIFN5bWJvbFxuLy8gbm9yIHBvbHlmaWxsLCB0aGVuIGEgcGxhaW4gbnVtYmVyIGlzIHVzZWQgZm9yIHBlcmZvcm1hbmNlLlxudmFyIFJFQUNUX0VMRU1FTlRfVFlQRSA9IDB4ZWFjNztcbnZhciBSRUFDVF9QT1JUQUxfVFlQRSA9IDB4ZWFjYTtcbnZhciBSRUFDVF9GUkFHTUVOVF9UWVBFID0gMHhlYWNiO1xudmFyIFJFQUNUX1NUUklDVF9NT0RFX1RZUEUgPSAweGVhY2M7XG52YXIgUkVBQ1RfUFJPRklMRVJfVFlQRSA9IDB4ZWFkMjtcbnZhciBSRUFDVF9QUk9WSURFUl9UWVBFID0gMHhlYWNkO1xudmFyIFJFQUNUX0NPTlRFWFRfVFlQRSA9IDB4ZWFjZTtcbnZhciBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFID0gMHhlYWQwO1xudmFyIFJFQUNUX1NVU1BFTlNFX1RZUEUgPSAweGVhZDE7XG52YXIgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFID0gMHhlYWQ4O1xudmFyIFJFQUNUX01FTU9fVFlQRSA9IDB4ZWFkMztcbnZhciBSRUFDVF9MQVpZX1RZUEUgPSAweGVhZDQ7XG52YXIgUkVBQ1RfQkxPQ0tfVFlQRSA9IDB4ZWFkOTtcbnZhciBSRUFDVF9TRVJWRVJfQkxPQ0tfVFlQRSA9IDB4ZWFkYTtcbnZhciBSRUFDVF9GVU5EQU1FTlRBTF9UWVBFID0gMHhlYWQ1O1xudmFyIFJFQUNUX1NDT1BFX1RZUEUgPSAweGVhZDc7XG52YXIgUkVBQ1RfT1BBUVVFX0lEX1RZUEUgPSAweGVhZTA7XG52YXIgUkVBQ1RfREVCVUdfVFJBQ0lOR19NT0RFX1RZUEUgPSAweGVhZTE7XG52YXIgUkVBQ1RfT0ZGU0NSRUVOX1RZUEUgPSAweGVhZTI7XG52YXIgUkVBQ1RfTEVHQUNZX0hJRERFTl9UWVBFID0gMHhlYWUzO1xuXG5pZiAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wuZm9yKSB7XG4gIHZhciBzeW1ib2xGb3IgPSBTeW1ib2wuZm9yO1xuICBSRUFDVF9FTEVNRU5UX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LmVsZW1lbnQnKTtcbiAgUkVBQ1RfUE9SVEFMX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LnBvcnRhbCcpO1xuICBSRUFDVF9GUkFHTUVOVF9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5mcmFnbWVudCcpO1xuICBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5zdHJpY3RfbW9kZScpO1xuICBSRUFDVF9QUk9GSUxFUl9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5wcm9maWxlcicpO1xuICBSRUFDVF9QUk9WSURFUl9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5wcm92aWRlcicpO1xuICBSRUFDVF9DT05URVhUX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LmNvbnRleHQnKTtcbiAgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSA9IHN5bWJvbEZvcigncmVhY3QuZm9yd2FyZF9yZWYnKTtcbiAgUkVBQ1RfU1VTUEVOU0VfVFlQRSA9IHN5bWJvbEZvcigncmVhY3Quc3VzcGVuc2UnKTtcbiAgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5zdXNwZW5zZV9saXN0Jyk7XG4gIFJFQUNUX01FTU9fVFlQRSA9IHN5bWJvbEZvcigncmVhY3QubWVtbycpO1xuICBSRUFDVF9MQVpZX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LmxhenknKTtcbiAgUkVBQ1RfQkxPQ0tfVFlQRSA9IHN5bWJvbEZvcigncmVhY3QuYmxvY2snKTtcbiAgUkVBQ1RfU0VSVkVSX0JMT0NLX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LnNlcnZlci5ibG9jaycpO1xuICBSRUFDVF9GVU5EQU1FTlRBTF9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5mdW5kYW1lbnRhbCcpO1xuICBSRUFDVF9TQ09QRV9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5zY29wZScpO1xuICBSRUFDVF9PUEFRVUVfSURfVFlQRSA9IHN5bWJvbEZvcigncmVhY3Qub3BhcXVlLmlkJyk7XG4gIFJFQUNUX0RFQlVHX1RSQUNJTkdfTU9ERV9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5kZWJ1Z190cmFjZV9tb2RlJyk7XG4gIFJFQUNUX09GRlNDUkVFTl9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5vZmZzY3JlZW4nKTtcbiAgUkVBQ1RfTEVHQUNZX0hJRERFTl9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5sZWdhY3lfaGlkZGVuJyk7XG59XG5cbnZhciBNQVlCRV9JVEVSQVRPUl9TWU1CT0wgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC5pdGVyYXRvcjtcbnZhciBGQVVYX0lURVJBVE9SX1NZTUJPTCA9ICdAQGl0ZXJhdG9yJztcbmZ1bmN0aW9uIGdldEl0ZXJhdG9yRm4obWF5YmVJdGVyYWJsZSkge1xuICBpZiAobWF5YmVJdGVyYWJsZSA9PT0gbnVsbCB8fCB0eXBlb2YgbWF5YmVJdGVyYWJsZSAhPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBtYXliZUl0ZXJhdG9yID0gTUFZQkVfSVRFUkFUT1JfU1lNQk9MICYmIG1heWJlSXRlcmFibGVbTUFZQkVfSVRFUkFUT1JfU1lNQk9MXSB8fCBtYXliZUl0ZXJhYmxlW0ZBVVhfSVRFUkFUT1JfU1lNQk9MXTtcblxuICBpZiAodHlwZW9mIG1heWJlSXRlcmF0b3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gbWF5YmVJdGVyYXRvcjtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG4vLyBIZWxwZXJzIHRvIHBhdGNoIGNvbnNvbGUubG9ncyB0byBhdm9pZCBsb2dnaW5nIGR1cmluZyBzaWRlLWVmZmVjdCBmcmVlXG4vLyByZXBsYXlpbmcgb24gcmVuZGVyIGZ1bmN0aW9uLiBUaGlzIGN1cnJlbnRseSBvbmx5IHBhdGNoZXMgdGhlIG9iamVjdFxuLy8gbGF6aWx5IHdoaWNoIHdvbid0IGNvdmVyIGlmIHRoZSBsb2cgZnVuY3Rpb24gd2FzIGV4dHJhY3RlZCBlYWdlcmx5LlxuLy8gV2UgY291bGQgYWxzbyBlYWdlcmx5IHBhdGNoIHRoZSBtZXRob2QuXG52YXIgZGlzYWJsZWREZXB0aCA9IDA7XG52YXIgcHJldkxvZztcbnZhciBwcmV2SW5mbztcbnZhciBwcmV2V2FybjtcbnZhciBwcmV2RXJyb3I7XG52YXIgcHJldkdyb3VwO1xudmFyIHByZXZHcm91cENvbGxhcHNlZDtcbnZhciBwcmV2R3JvdXBFbmQ7XG5cbmZ1bmN0aW9uIGRpc2FibGVkTG9nKCkge31cblxuZGlzYWJsZWRMb2cuX19yZWFjdERpc2FibGVkTG9nID0gdHJ1ZTtcbmZ1bmN0aW9uIGRpc2FibGVMb2dzKCkge1xuICB7XG4gICAgaWYgKGRpc2FibGVkRGVwdGggPT09IDApIHtcbiAgICAgIC8qIGVzbGludC1kaXNhYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgICAgcHJldkxvZyA9IGNvbnNvbGUubG9nO1xuICAgICAgcHJldkluZm8gPSBjb25zb2xlLmluZm87XG4gICAgICBwcmV2V2FybiA9IGNvbnNvbGUud2FybjtcbiAgICAgIHByZXZFcnJvciA9IGNvbnNvbGUuZXJyb3I7XG4gICAgICBwcmV2R3JvdXAgPSBjb25zb2xlLmdyb3VwO1xuICAgICAgcHJldkdyb3VwQ29sbGFwc2VkID0gY29uc29sZS5ncm91cENvbGxhcHNlZDtcbiAgICAgIHByZXZHcm91cEVuZCA9IGNvbnNvbGUuZ3JvdXBFbmQ7IC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTkwOTlcblxuICAgICAgdmFyIHByb3BzID0ge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlOiBkaXNhYmxlZExvZyxcbiAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgIH07IC8vICRGbG93Rml4TWUgRmxvdyB0aGlua3MgY29uc29sZSBpcyBpbW11dGFibGUuXG5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGNvbnNvbGUsIHtcbiAgICAgICAgaW5mbzogcHJvcHMsXG4gICAgICAgIGxvZzogcHJvcHMsXG4gICAgICAgIHdhcm46IHByb3BzLFxuICAgICAgICBlcnJvcjogcHJvcHMsXG4gICAgICAgIGdyb3VwOiBwcm9wcyxcbiAgICAgICAgZ3JvdXBDb2xsYXBzZWQ6IHByb3BzLFxuICAgICAgICBncm91cEVuZDogcHJvcHNcbiAgICAgIH0pO1xuICAgICAgLyogZXNsaW50LWVuYWJsZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmcgKi9cbiAgICB9XG5cbiAgICBkaXNhYmxlZERlcHRoKys7XG4gIH1cbn1cbmZ1bmN0aW9uIHJlZW5hYmxlTG9ncygpIHtcbiAge1xuICAgIGRpc2FibGVkRGVwdGgtLTtcblxuICAgIGlmIChkaXNhYmxlZERlcHRoID09PSAwKSB7XG4gICAgICAvKiBlc2xpbnQtZGlzYWJsZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmcgKi9cbiAgICAgIHZhciBwcm9wcyA9IHtcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgfTsgLy8gJEZsb3dGaXhNZSBGbG93IHRoaW5rcyBjb25zb2xlIGlzIGltbXV0YWJsZS5cblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoY29uc29sZSwge1xuICAgICAgICBsb2c6IF9hc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZMb2dcbiAgICAgICAgfSksXG4gICAgICAgIGluZm86IF9hc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZJbmZvXG4gICAgICAgIH0pLFxuICAgICAgICB3YXJuOiBfYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2V2FyblxuICAgICAgICB9KSxcbiAgICAgICAgZXJyb3I6IF9hc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZFcnJvclxuICAgICAgICB9KSxcbiAgICAgICAgZ3JvdXA6IF9hc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZHcm91cFxuICAgICAgICB9KSxcbiAgICAgICAgZ3JvdXBDb2xsYXBzZWQ6IF9hc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZHcm91cENvbGxhcHNlZFxuICAgICAgICB9KSxcbiAgICAgICAgZ3JvdXBFbmQ6IF9hc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZHcm91cEVuZFxuICAgICAgICB9KVxuICAgICAgfSk7XG4gICAgICAvKiBlc2xpbnQtZW5hYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgIH1cblxuICAgIGlmIChkaXNhYmxlZERlcHRoIDwgMCkge1xuICAgICAgZXJyb3IoJ2Rpc2FibGVkRGVwdGggZmVsbCBiZWxvdyB6ZXJvLiAnICsgJ1RoaXMgaXMgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0Q3VycmVudERpc3BhdGNoZXI7XG52YXIgcHJlZml4O1xuZnVuY3Rpb24gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUobmFtZSwgc291cmNlLCBvd25lckZuKSB7XG4gIHtcbiAgICBpZiAocHJlZml4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIEV4dHJhY3QgdGhlIFZNIHNwZWNpZmljIHByZWZpeCB1c2VkIGJ5IGVhY2ggbGluZS5cbiAgICAgIHRyeSB7XG4gICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgIHZhciBtYXRjaCA9IHguc3RhY2sudHJpbSgpLm1hdGNoKC9cXG4oICooYXQgKT8pLyk7XG4gICAgICAgIHByZWZpeCA9IG1hdGNoICYmIG1hdGNoWzFdIHx8ICcnO1xuICAgICAgfVxuICAgIH0gLy8gV2UgdXNlIHRoZSBwcmVmaXggdG8gZW5zdXJlIG91ciBzdGFja3MgbGluZSB1cCB3aXRoIG5hdGl2ZSBzdGFjayBmcmFtZXMuXG5cblxuICAgIHJldHVybiAnXFxuJyArIHByZWZpeCArIG5hbWU7XG4gIH1cbn1cbnZhciByZWVudHJ5ID0gZmFsc2U7XG52YXIgY29tcG9uZW50RnJhbWVDYWNoZTtcblxue1xuICB2YXIgUG9zc2libHlXZWFrTWFwID0gdHlwZW9mIFdlYWtNYXAgPT09ICdmdW5jdGlvbicgPyBXZWFrTWFwIDogTWFwO1xuICBjb21wb25lbnRGcmFtZUNhY2hlID0gbmV3IFBvc3NpYmx5V2Vha01hcCgpO1xufVxuXG5mdW5jdGlvbiBkZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lKGZuLCBjb25zdHJ1Y3QpIHtcbiAgLy8gSWYgc29tZXRoaW5nIGFza2VkIGZvciBhIHN0YWNrIGluc2lkZSBhIGZha2UgcmVuZGVyLCBpdCBzaG91bGQgZ2V0IGlnbm9yZWQuXG4gIGlmICghZm4gfHwgcmVlbnRyeSkge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIHtcbiAgICB2YXIgZnJhbWUgPSBjb21wb25lbnRGcmFtZUNhY2hlLmdldChmbik7XG5cbiAgICBpZiAoZnJhbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGZyYW1lO1xuICAgIH1cbiAgfVxuXG4gIHZhciBjb250cm9sO1xuICByZWVudHJ5ID0gdHJ1ZTtcbiAgdmFyIHByZXZpb3VzUHJlcGFyZVN0YWNrVHJhY2UgPSBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZTsgLy8gJEZsb3dGaXhNZSBJdCBkb2VzIGFjY2VwdCB1bmRlZmluZWQuXG5cbiAgRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSB1bmRlZmluZWQ7XG4gIHZhciBwcmV2aW91c0Rpc3BhdGNoZXI7XG5cbiAge1xuICAgIHByZXZpb3VzRGlzcGF0Y2hlciA9IFJlYWN0Q3VycmVudERpc3BhdGNoZXIuY3VycmVudDsgLy8gU2V0IHRoZSBkaXNwYXRjaGVyIGluIERFViBiZWNhdXNlIHRoaXMgbWlnaHQgYmUgY2FsbCBpbiB0aGUgcmVuZGVyIGZ1bmN0aW9uXG4gICAgLy8gZm9yIHdhcm5pbmdzLlxuXG4gICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlci5jdXJyZW50ID0gbnVsbDtcbiAgICBkaXNhYmxlTG9ncygpO1xuICB9XG5cbiAgdHJ5IHtcbiAgICAvLyBUaGlzIHNob3VsZCB0aHJvdy5cbiAgICBpZiAoY29uc3RydWN0KSB7XG4gICAgICAvLyBTb21ldGhpbmcgc2hvdWxkIGJlIHNldHRpbmcgdGhlIHByb3BzIGluIHRoZSBjb25zdHJ1Y3Rvci5cbiAgICAgIHZhciBGYWtlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgfTsgLy8gJEZsb3dGaXhNZVxuXG5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShGYWtlLnByb3RvdHlwZSwgJ3Byb3BzJywge1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAvLyBXZSB1c2UgYSB0aHJvd2luZyBzZXR0ZXIgaW5zdGVhZCBvZiBmcm96ZW4gb3Igbm9uLXdyaXRhYmxlIHByb3BzXG4gICAgICAgICAgLy8gYmVjYXVzZSB0aGF0IHdvbid0IHRocm93IGluIGEgbm9uLXN0cmljdCBtb2RlIGZ1bmN0aW9uLlxuICAgICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09ICdvYmplY3QnICYmIFJlZmxlY3QuY29uc3RydWN0KSB7XG4gICAgICAgIC8vIFdlIGNvbnN0cnVjdCBhIGRpZmZlcmVudCBjb250cm9sIGZvciB0aGlzIGNhc2UgdG8gaW5jbHVkZSBhbnkgZXh0cmFcbiAgICAgICAgLy8gZnJhbWVzIGFkZGVkIGJ5IHRoZSBjb25zdHJ1Y3QgY2FsbC5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBSZWZsZWN0LmNvbnN0cnVjdChGYWtlLCBbXSk7XG4gICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICBjb250cm9sID0geDtcbiAgICAgICAgfVxuXG4gICAgICAgIFJlZmxlY3QuY29uc3RydWN0KGZuLCBbXSwgRmFrZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIEZha2UuY2FsbCgpO1xuICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgY29udHJvbCA9IHg7XG4gICAgICAgIH1cblxuICAgICAgICBmbi5jYWxsKEZha2UucHJvdG90eXBlKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgY29udHJvbCA9IHg7XG4gICAgICB9XG5cbiAgICAgIGZuKCk7XG4gICAgfVxuICB9IGNhdGNoIChzYW1wbGUpIHtcbiAgICAvLyBUaGlzIGlzIGlubGluZWQgbWFudWFsbHkgYmVjYXVzZSBjbG9zdXJlIGRvZXNuJ3QgZG8gaXQgZm9yIHVzLlxuICAgIGlmIChzYW1wbGUgJiYgY29udHJvbCAmJiB0eXBlb2Ygc2FtcGxlLnN0YWNrID09PSAnc3RyaW5nJykge1xuICAgICAgLy8gVGhpcyBleHRyYWN0cyB0aGUgZmlyc3QgZnJhbWUgZnJvbSB0aGUgc2FtcGxlIHRoYXQgaXNuJ3QgYWxzbyBpbiB0aGUgY29udHJvbC5cbiAgICAgIC8vIFNraXBwaW5nIG9uZSBmcmFtZSB0aGF0IHdlIGFzc3VtZSBpcyB0aGUgZnJhbWUgdGhhdCBjYWxscyB0aGUgdHdvLlxuICAgICAgdmFyIHNhbXBsZUxpbmVzID0gc2FtcGxlLnN0YWNrLnNwbGl0KCdcXG4nKTtcbiAgICAgIHZhciBjb250cm9sTGluZXMgPSBjb250cm9sLnN0YWNrLnNwbGl0KCdcXG4nKTtcbiAgICAgIHZhciBzID0gc2FtcGxlTGluZXMubGVuZ3RoIC0gMTtcbiAgICAgIHZhciBjID0gY29udHJvbExpbmVzLmxlbmd0aCAtIDE7XG5cbiAgICAgIHdoaWxlIChzID49IDEgJiYgYyA+PSAwICYmIHNhbXBsZUxpbmVzW3NdICE9PSBjb250cm9sTGluZXNbY10pIHtcbiAgICAgICAgLy8gV2UgZXhwZWN0IGF0IGxlYXN0IG9uZSBzdGFjayBmcmFtZSB0byBiZSBzaGFyZWQuXG4gICAgICAgIC8vIFR5cGljYWxseSB0aGlzIHdpbGwgYmUgdGhlIHJvb3QgbW9zdCBvbmUuIEhvd2V2ZXIsIHN0YWNrIGZyYW1lcyBtYXkgYmVcbiAgICAgICAgLy8gY3V0IG9mZiBkdWUgdG8gbWF4aW11bSBzdGFjayBsaW1pdHMuIEluIHRoaXMgY2FzZSwgb25lIG1heWJlIGN1dCBvZmZcbiAgICAgICAgLy8gZWFybGllciB0aGFuIHRoZSBvdGhlci4gV2UgYXNzdW1lIHRoYXQgdGhlIHNhbXBsZSBpcyBsb25nZXIgb3IgdGhlIHNhbWVcbiAgICAgICAgLy8gYW5kIHRoZXJlIGZvciBjdXQgb2ZmIGVhcmxpZXIuIFNvIHdlIHNob3VsZCBmaW5kIHRoZSByb290IG1vc3QgZnJhbWUgaW5cbiAgICAgICAgLy8gdGhlIHNhbXBsZSBzb21ld2hlcmUgaW4gdGhlIGNvbnRyb2wuXG4gICAgICAgIGMtLTtcbiAgICAgIH1cblxuICAgICAgZm9yICg7IHMgPj0gMSAmJiBjID49IDA7IHMtLSwgYy0tKSB7XG4gICAgICAgIC8vIE5leHQgd2UgZmluZCB0aGUgZmlyc3Qgb25lIHRoYXQgaXNuJ3QgdGhlIHNhbWUgd2hpY2ggc2hvdWxkIGJlIHRoZVxuICAgICAgICAvLyBmcmFtZSB0aGF0IGNhbGxlZCBvdXIgc2FtcGxlIGZ1bmN0aW9uIGFuZCB0aGUgY29udHJvbC5cbiAgICAgICAgaWYgKHNhbXBsZUxpbmVzW3NdICE9PSBjb250cm9sTGluZXNbY10pIHtcbiAgICAgICAgICAvLyBJbiBWOCwgdGhlIGZpcnN0IGxpbmUgaXMgZGVzY3JpYmluZyB0aGUgbWVzc2FnZSBidXQgb3RoZXIgVk1zIGRvbid0LlxuICAgICAgICAgIC8vIElmIHdlJ3JlIGFib3V0IHRvIHJldHVybiB0aGUgZmlyc3QgbGluZSwgYW5kIHRoZSBjb250cm9sIGlzIGFsc28gb24gdGhlIHNhbWVcbiAgICAgICAgICAvLyBsaW5lLCB0aGF0J3MgYSBwcmV0dHkgZ29vZCBpbmRpY2F0b3IgdGhhdCBvdXIgc2FtcGxlIHRocmV3IGF0IHNhbWUgbGluZSBhc1xuICAgICAgICAgIC8vIHRoZSBjb250cm9sLiBJLmUuIGJlZm9yZSB3ZSBlbnRlcmVkIHRoZSBzYW1wbGUgZnJhbWUuIFNvIHdlIGlnbm9yZSB0aGlzIHJlc3VsdC5cbiAgICAgICAgICAvLyBUaGlzIGNhbiBoYXBwZW4gaWYgeW91IHBhc3NlZCBhIGNsYXNzIHRvIGZ1bmN0aW9uIGNvbXBvbmVudCwgb3Igbm9uLWZ1bmN0aW9uLlxuICAgICAgICAgIGlmIChzICE9PSAxIHx8IGMgIT09IDEpIHtcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgcy0tO1xuICAgICAgICAgICAgICBjLS07IC8vIFdlIG1heSBzdGlsbCBoYXZlIHNpbWlsYXIgaW50ZXJtZWRpYXRlIGZyYW1lcyBmcm9tIHRoZSBjb25zdHJ1Y3QgY2FsbC5cbiAgICAgICAgICAgICAgLy8gVGhlIG5leHQgb25lIHRoYXQgaXNuJ3QgdGhlIHNhbWUgc2hvdWxkIGJlIG91ciBtYXRjaCB0aG91Z2guXG5cbiAgICAgICAgICAgICAgaWYgKGMgPCAwIHx8IHNhbXBsZUxpbmVzW3NdICE9PSBjb250cm9sTGluZXNbY10pIHtcbiAgICAgICAgICAgICAgICAvLyBWOCBhZGRzIGEgXCJuZXdcIiBwcmVmaXggZm9yIG5hdGl2ZSBjbGFzc2VzLiBMZXQncyByZW1vdmUgaXQgdG8gbWFrZSBpdCBwcmV0dGllci5cbiAgICAgICAgICAgICAgICB2YXIgX2ZyYW1lID0gJ1xcbicgKyBzYW1wbGVMaW5lc1tzXS5yZXBsYWNlKCcgYXQgbmV3ICcsICcgYXQgJyk7XG5cbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudEZyYW1lQ2FjaGUuc2V0KGZuLCBfZnJhbWUpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gLy8gUmV0dXJuIHRoZSBsaW5lIHdlIGZvdW5kLlxuXG5cbiAgICAgICAgICAgICAgICByZXR1cm4gX2ZyYW1lO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IHdoaWxlIChzID49IDEgJiYgYyA+PSAwKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSBmaW5hbGx5IHtcbiAgICByZWVudHJ5ID0gZmFsc2U7XG5cbiAgICB7XG4gICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyLmN1cnJlbnQgPSBwcmV2aW91c0Rpc3BhdGNoZXI7XG4gICAgICByZWVuYWJsZUxvZ3MoKTtcbiAgICB9XG5cbiAgICBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZSA9IHByZXZpb3VzUHJlcGFyZVN0YWNrVHJhY2U7XG4gIH0gLy8gRmFsbGJhY2sgdG8ganVzdCB1c2luZyB0aGUgbmFtZSBpZiB3ZSBjb3VsZG4ndCBtYWtlIGl0IHRocm93LlxuXG5cbiAgdmFyIG5hbWUgPSBmbiA/IGZuLmRpc3BsYXlOYW1lIHx8IGZuLm5hbWUgOiAnJztcbiAgdmFyIHN5bnRoZXRpY0ZyYW1lID0gbmFtZSA/IGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKG5hbWUpIDogJyc7XG5cbiAge1xuICAgIGlmICh0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNvbXBvbmVudEZyYW1lQ2FjaGUuc2V0KGZuLCBzeW50aGV0aWNGcmFtZSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHN5bnRoZXRpY0ZyYW1lO1xufVxuXG5mdW5jdGlvbiBkZXNjcmliZUNsYXNzQ29tcG9uZW50RnJhbWUoY3Rvciwgc291cmNlLCBvd25lckZuKSB7XG4gIHtcbiAgICByZXR1cm4gZGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZShjdG9yLCB0cnVlKTtcbiAgfVxufVxuZnVuY3Rpb24gZGVzY3JpYmVGdW5jdGlvbkNvbXBvbmVudEZyYW1lKGZuLCBzb3VyY2UsIG93bmVyRm4pIHtcbiAge1xuICAgIHJldHVybiBkZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lKGZuLCBmYWxzZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc2hvdWxkQ29uc3RydWN0KENvbXBvbmVudCkge1xuICB2YXIgcHJvdG90eXBlID0gQ29tcG9uZW50LnByb3RvdHlwZTtcbiAgcmV0dXJuICEhKHByb3RvdHlwZSAmJiBwcm90b3R5cGUuaXNSZWFjdENvbXBvbmVudCk7XG59XG5cbmZ1bmN0aW9uIGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVih0eXBlLCBzb3VyY2UsIG93bmVyRm4pIHtcblxuICBpZiAodHlwZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAge1xuICAgICAgcmV0dXJuIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUodHlwZSwgc2hvdWxkQ29uc3RydWN0KHR5cGUpKTtcbiAgICB9XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKHR5cGUpO1xuICB9XG5cbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKCdTdXNwZW5zZScpO1xuXG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEU6XG4gICAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoJ1N1c3BlbnNlTGlzdCcpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0Jykge1xuICAgIHN3aXRjaCAodHlwZS4kJHR5cGVvZikge1xuICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxuICAgICAgICByZXR1cm4gZGVzY3JpYmVGdW5jdGlvbkNvbXBvbmVudEZyYW1lKHR5cGUucmVuZGVyKTtcblxuICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XG4gICAgICAgIC8vIE1lbW8gbWF5IGNvbnRhaW4gYW55IGNvbXBvbmVudCB0eXBlIHNvIHdlIHJlY3Vyc2l2ZWx5IHJlc29sdmUgaXQuXG4gICAgICAgIHJldHVybiBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYodHlwZS50eXBlLCBzb3VyY2UsIG93bmVyRm4pO1xuXG4gICAgICBjYXNlIFJFQUNUX0JMT0NLX1RZUEU6XG4gICAgICAgIHJldHVybiBkZXNjcmliZUZ1bmN0aW9uQ29tcG9uZW50RnJhbWUodHlwZS5fcmVuZGVyKTtcblxuICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgbGF6eUNvbXBvbmVudCA9IHR5cGU7XG4gICAgICAgICAgdmFyIHBheWxvYWQgPSBsYXp5Q29tcG9uZW50Ll9wYXlsb2FkO1xuICAgICAgICAgIHZhciBpbml0ID0gbGF6eUNvbXBvbmVudC5faW5pdDtcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBMYXp5IG1heSBjb250YWluIGFueSBjb21wb25lbnQgdHlwZSBzbyB3ZSByZWN1cnNpdmVseSByZXNvbHZlIGl0LlxuICAgICAgICAgICAgcmV0dXJuIGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVihpbml0KHBheWxvYWQpLCBzb3VyY2UsIG93bmVyRm4pO1xuICAgICAgICAgIH0gY2F0Y2ggKHgpIHt9XG4gICAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gJyc7XG59XG5cbmZ1bmN0aW9uIGRlc2NyaWJlRmliZXIoZmliZXIpIHtcbiAgdmFyIG93bmVyID0gIGZpYmVyLl9kZWJ1Z093bmVyID8gZmliZXIuX2RlYnVnT3duZXIudHlwZSA6IG51bGwgO1xuICB2YXIgc291cmNlID0gIGZpYmVyLl9kZWJ1Z1NvdXJjZSA7XG5cbiAgc3dpdGNoIChmaWJlci50YWcpIHtcbiAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoZmliZXIudHlwZSk7XG5cbiAgICBjYXNlIExhenlDb21wb25lbnQ6XG4gICAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoJ0xhenknKTtcblxuICAgIGNhc2UgU3VzcGVuc2VDb21wb25lbnQ6XG4gICAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoJ1N1c3BlbnNlJyk7XG5cbiAgICBjYXNlIFN1c3BlbnNlTGlzdENvbXBvbmVudDpcbiAgICAgIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSgnU3VzcGVuc2VMaXN0Jyk7XG5cbiAgICBjYXNlIEZ1bmN0aW9uQ29tcG9uZW50OlxuICAgIGNhc2UgSW5kZXRlcm1pbmF0ZUNvbXBvbmVudDpcbiAgICBjYXNlIFNpbXBsZU1lbW9Db21wb25lbnQ6XG4gICAgICByZXR1cm4gZGVzY3JpYmVGdW5jdGlvbkNvbXBvbmVudEZyYW1lKGZpYmVyLnR5cGUpO1xuXG4gICAgY2FzZSBGb3J3YXJkUmVmOlxuICAgICAgcmV0dXJuIGRlc2NyaWJlRnVuY3Rpb25Db21wb25lbnRGcmFtZShmaWJlci50eXBlLnJlbmRlcik7XG5cbiAgICBjYXNlIEJsb2NrOlxuICAgICAgcmV0dXJuIGRlc2NyaWJlRnVuY3Rpb25Db21wb25lbnRGcmFtZShmaWJlci50eXBlLl9yZW5kZXIpO1xuXG4gICAgY2FzZSBDbGFzc0NvbXBvbmVudDpcbiAgICAgIHJldHVybiBkZXNjcmliZUNsYXNzQ29tcG9uZW50RnJhbWUoZmliZXIudHlwZSk7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuICcnO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldFN0YWNrQnlGaWJlckluRGV2QW5kUHJvZCh3b3JrSW5Qcm9ncmVzcykge1xuICB0cnkge1xuICAgIHZhciBpbmZvID0gJyc7XG4gICAgdmFyIG5vZGUgPSB3b3JrSW5Qcm9ncmVzcztcblxuICAgIGRvIHtcbiAgICAgIGluZm8gKz0gZGVzY3JpYmVGaWJlcihub2RlKTtcbiAgICAgIG5vZGUgPSBub2RlLnJldHVybjtcbiAgICB9IHdoaWxlIChub2RlKTtcblxuICAgIHJldHVybiBpbmZvO1xuICB9IGNhdGNoICh4KSB7XG4gICAgcmV0dXJuICdcXG5FcnJvciBnZW5lcmF0aW5nIHN0YWNrOiAnICsgeC5tZXNzYWdlICsgJ1xcbicgKyB4LnN0YWNrO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldFdyYXBwZWROYW1lKG91dGVyVHlwZSwgaW5uZXJUeXBlLCB3cmFwcGVyTmFtZSkge1xuICB2YXIgZnVuY3Rpb25OYW1lID0gaW5uZXJUeXBlLmRpc3BsYXlOYW1lIHx8IGlubmVyVHlwZS5uYW1lIHx8ICcnO1xuICByZXR1cm4gb3V0ZXJUeXBlLmRpc3BsYXlOYW1lIHx8IChmdW5jdGlvbk5hbWUgIT09ICcnID8gd3JhcHBlck5hbWUgKyBcIihcIiArIGZ1bmN0aW9uTmFtZSArIFwiKVwiIDogd3JhcHBlck5hbWUpO1xufVxuXG5mdW5jdGlvbiBnZXRDb250ZXh0TmFtZSh0eXBlKSB7XG4gIHJldHVybiB0eXBlLmRpc3BsYXlOYW1lIHx8ICdDb250ZXh0Jztcbn1cblxuZnVuY3Rpb24gZ2V0Q29tcG9uZW50TmFtZSh0eXBlKSB7XG4gIGlmICh0eXBlID09IG51bGwpIHtcbiAgICAvLyBIb3N0IHJvb3QsIHRleHQgbm9kZSBvciBqdXN0IGludmFsaWQgdHlwZS5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHtcbiAgICBpZiAodHlwZW9mIHR5cGUudGFnID09PSAnbnVtYmVyJykge1xuICAgICAgZXJyb3IoJ1JlY2VpdmVkIGFuIHVuZXhwZWN0ZWQgb2JqZWN0IGluIGdldENvbXBvbmVudE5hbWUoKS4gJyArICdUaGlzIGlzIGxpa2VseSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIHR5cGUuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lIHx8IG51bGw7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHR5cGU7XG4gIH1cblxuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlIFJFQUNUX0ZSQUdNRU5UX1RZUEU6XG4gICAgICByZXR1cm4gJ0ZyYWdtZW50JztcblxuICAgIGNhc2UgUkVBQ1RfUE9SVEFMX1RZUEU6XG4gICAgICByZXR1cm4gJ1BvcnRhbCc7XG5cbiAgICBjYXNlIFJFQUNUX1BST0ZJTEVSX1RZUEU6XG4gICAgICByZXR1cm4gJ1Byb2ZpbGVyJztcblxuICAgIGNhc2UgUkVBQ1RfU1RSSUNUX01PREVfVFlQRTpcbiAgICAgIHJldHVybiAnU3RyaWN0TW9kZSc7XG5cbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX1RZUEU6XG4gICAgICByZXR1cm4gJ1N1c3BlbnNlJztcblxuICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFOlxuICAgICAgcmV0dXJuICdTdXNwZW5zZUxpc3QnO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0Jykge1xuICAgIHN3aXRjaCAodHlwZS4kJHR5cGVvZikge1xuICAgICAgY2FzZSBSRUFDVF9DT05URVhUX1RZUEU6XG4gICAgICAgIHZhciBjb250ZXh0ID0gdHlwZTtcbiAgICAgICAgcmV0dXJuIGdldENvbnRleHROYW1lKGNvbnRleHQpICsgJy5Db25zdW1lcic7XG5cbiAgICAgIGNhc2UgUkVBQ1RfUFJPVklERVJfVFlQRTpcbiAgICAgICAgdmFyIHByb3ZpZGVyID0gdHlwZTtcbiAgICAgICAgcmV0dXJuIGdldENvbnRleHROYW1lKHByb3ZpZGVyLl9jb250ZXh0KSArICcuUHJvdmlkZXInO1xuXG4gICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XG4gICAgICAgIHJldHVybiBnZXRXcmFwcGVkTmFtZSh0eXBlLCB0eXBlLnJlbmRlciwgJ0ZvcndhcmRSZWYnKTtcblxuICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XG4gICAgICAgIHJldHVybiBnZXRDb21wb25lbnROYW1lKHR5cGUudHlwZSk7XG5cbiAgICAgIGNhc2UgUkVBQ1RfQkxPQ0tfVFlQRTpcbiAgICAgICAgcmV0dXJuIGdldENvbXBvbmVudE5hbWUodHlwZS5fcmVuZGVyKTtcblxuICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgbGF6eUNvbXBvbmVudCA9IHR5cGU7XG4gICAgICAgICAgdmFyIHBheWxvYWQgPSBsYXp5Q29tcG9uZW50Ll9wYXlsb2FkO1xuICAgICAgICAgIHZhciBpbml0ID0gbGF6eUNvbXBvbmVudC5faW5pdDtcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50TmFtZShpbml0KHBheWxvYWQpKTtcbiAgICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxudmFyIFJlYWN0RGVidWdDdXJyZW50RnJhbWUgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdERlYnVnQ3VycmVudEZyYW1lO1xudmFyIGN1cnJlbnQgPSBudWxsO1xudmFyIGlzUmVuZGVyaW5nID0gZmFsc2U7XG5mdW5jdGlvbiBnZXRDdXJyZW50RmliZXJPd25lck5hbWVJbkRldk9yTnVsbCgpIHtcbiAge1xuICAgIGlmIChjdXJyZW50ID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgb3duZXIgPSBjdXJyZW50Ll9kZWJ1Z093bmVyO1xuXG4gICAgaWYgKG93bmVyICE9PSBudWxsICYmIHR5cGVvZiBvd25lciAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHJldHVybiBnZXRDb21wb25lbnROYW1lKG93bmVyLnR5cGUpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBnZXRDdXJyZW50RmliZXJTdGFja0luRGV2KCkge1xuICB7XG4gICAgaWYgKGN1cnJlbnQgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiAnJztcbiAgICB9IC8vIFNhZmUgYmVjYXVzZSBpZiBjdXJyZW50IGZpYmVyIGV4aXN0cywgd2UgYXJlIHJlY29uY2lsaW5nLFxuICAgIC8vIGFuZCBpdCBpcyBndWFyYW50ZWVkIHRvIGJlIHRoZSB3b3JrLWluLXByb2dyZXNzIHZlcnNpb24uXG5cblxuICAgIHJldHVybiBnZXRTdGFja0J5RmliZXJJbkRldkFuZFByb2QoY3VycmVudCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVzZXRDdXJyZW50RmliZXIoKSB7XG4gIHtcbiAgICBSZWFjdERlYnVnQ3VycmVudEZyYW1lLmdldEN1cnJlbnRTdGFjayA9IG51bGw7XG4gICAgY3VycmVudCA9IG51bGw7XG4gICAgaXNSZW5kZXJpbmcgPSBmYWxzZTtcbiAgfVxufVxuZnVuY3Rpb24gc2V0Q3VycmVudEZpYmVyKGZpYmVyKSB7XG4gIHtcbiAgICBSZWFjdERlYnVnQ3VycmVudEZyYW1lLmdldEN1cnJlbnRTdGFjayA9IGdldEN1cnJlbnRGaWJlclN0YWNrSW5EZXY7XG4gICAgY3VycmVudCA9IGZpYmVyO1xuICAgIGlzUmVuZGVyaW5nID0gZmFsc2U7XG4gIH1cbn1cbmZ1bmN0aW9uIHNldElzUmVuZGVyaW5nKHJlbmRlcmluZykge1xuICB7XG4gICAgaXNSZW5kZXJpbmcgPSByZW5kZXJpbmc7XG4gIH1cbn1cbmZ1bmN0aW9uIGdldElzUmVuZGVyaW5nKCkge1xuICB7XG4gICAgcmV0dXJuIGlzUmVuZGVyaW5nO1xuICB9XG59XG5cbi8vIEZsb3cgZG9lcyBub3QgYWxsb3cgc3RyaW5nIGNvbmNhdGVuYXRpb24gb2YgbW9zdCBub24tc3RyaW5nIHR5cGVzLiBUbyB3b3JrXG4vLyBhcm91bmQgdGhpcyBsaW1pdGF0aW9uLCB3ZSB1c2UgYW4gb3BhcXVlIHR5cGUgdGhhdCBjYW4gb25seSBiZSBvYnRhaW5lZCBieVxuLy8gcGFzc2luZyB0aGUgdmFsdWUgdGhyb3VnaCBnZXRUb1N0cmluZ1ZhbHVlIGZpcnN0LlxuZnVuY3Rpb24gdG9TdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuICcnICsgdmFsdWU7XG59XG5mdW5jdGlvbiBnZXRUb1N0cmluZ1ZhbHVlKHZhbHVlKSB7XG4gIHN3aXRjaCAodHlwZW9mIHZhbHVlKSB7XG4gICAgY2FzZSAnYm9vbGVhbic6XG4gICAgY2FzZSAnbnVtYmVyJzpcbiAgICBjYXNlICdvYmplY3QnOlxuICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgY2FzZSAndW5kZWZpbmVkJzpcbiAgICAgIHJldHVybiB2YWx1ZTtcblxuICAgIGRlZmF1bHQ6XG4gICAgICAvLyBmdW5jdGlvbiwgc3ltYm9sIGFyZSBhc3NpZ25lZCBhcyBlbXB0eSBzdHJpbmdzXG4gICAgICByZXR1cm4gJyc7XG4gIH1cbn1cblxudmFyIGhhc1JlYWRPbmx5VmFsdWUgPSB7XG4gIGJ1dHRvbjogdHJ1ZSxcbiAgY2hlY2tib3g6IHRydWUsXG4gIGltYWdlOiB0cnVlLFxuICBoaWRkZW46IHRydWUsXG4gIHJhZGlvOiB0cnVlLFxuICByZXNldDogdHJ1ZSxcbiAgc3VibWl0OiB0cnVlXG59O1xuZnVuY3Rpb24gY2hlY2tDb250cm9sbGVkVmFsdWVQcm9wcyh0YWdOYW1lLCBwcm9wcykge1xuICB7XG4gICAgaWYgKCEoaGFzUmVhZE9ubHlWYWx1ZVtwcm9wcy50eXBlXSB8fCBwcm9wcy5vbkNoYW5nZSB8fCBwcm9wcy5vbklucHV0IHx8IHByb3BzLnJlYWRPbmx5IHx8IHByb3BzLmRpc2FibGVkIHx8IHByb3BzLnZhbHVlID09IG51bGwpKSB7XG4gICAgICBlcnJvcignWW91IHByb3ZpZGVkIGEgYHZhbHVlYCBwcm9wIHRvIGEgZm9ybSBmaWVsZCB3aXRob3V0IGFuICcgKyAnYG9uQ2hhbmdlYCBoYW5kbGVyLiBUaGlzIHdpbGwgcmVuZGVyIGEgcmVhZC1vbmx5IGZpZWxkLiBJZiAnICsgJ3RoZSBmaWVsZCBzaG91bGQgYmUgbXV0YWJsZSB1c2UgYGRlZmF1bHRWYWx1ZWAuIE90aGVyd2lzZSwgJyArICdzZXQgZWl0aGVyIGBvbkNoYW5nZWAgb3IgYHJlYWRPbmx5YC4nKTtcbiAgICB9XG5cbiAgICBpZiAoIShwcm9wcy5vbkNoYW5nZSB8fCBwcm9wcy5yZWFkT25seSB8fCBwcm9wcy5kaXNhYmxlZCB8fCBwcm9wcy5jaGVja2VkID09IG51bGwpKSB7XG4gICAgICBlcnJvcignWW91IHByb3ZpZGVkIGEgYGNoZWNrZWRgIHByb3AgdG8gYSBmb3JtIGZpZWxkIHdpdGhvdXQgYW4gJyArICdgb25DaGFuZ2VgIGhhbmRsZXIuIFRoaXMgd2lsbCByZW5kZXIgYSByZWFkLW9ubHkgZmllbGQuIElmICcgKyAndGhlIGZpZWxkIHNob3VsZCBiZSBtdXRhYmxlIHVzZSBgZGVmYXVsdENoZWNrZWRgLiBPdGhlcndpc2UsICcgKyAnc2V0IGVpdGhlciBgb25DaGFuZ2VgIG9yIGByZWFkT25seWAuJyk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGlzQ2hlY2thYmxlKGVsZW0pIHtcbiAgdmFyIHR5cGUgPSBlbGVtLnR5cGU7XG4gIHZhciBub2RlTmFtZSA9IGVsZW0ubm9kZU5hbWU7XG4gIHJldHVybiBub2RlTmFtZSAmJiBub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnaW5wdXQnICYmICh0eXBlID09PSAnY2hlY2tib3gnIHx8IHR5cGUgPT09ICdyYWRpbycpO1xufVxuXG5mdW5jdGlvbiBnZXRUcmFja2VyKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUuX3ZhbHVlVHJhY2tlcjtcbn1cblxuZnVuY3Rpb24gZGV0YWNoVHJhY2tlcihub2RlKSB7XG4gIG5vZGUuX3ZhbHVlVHJhY2tlciA9IG51bGw7XG59XG5cbmZ1bmN0aW9uIGdldFZhbHVlRnJvbU5vZGUobm9kZSkge1xuICB2YXIgdmFsdWUgPSAnJztcblxuICBpZiAoIW5vZGUpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cblxuICBpZiAoaXNDaGVja2FibGUobm9kZSkpIHtcbiAgICB2YWx1ZSA9IG5vZGUuY2hlY2tlZCA/ICd0cnVlJyA6ICdmYWxzZSc7XG4gIH0gZWxzZSB7XG4gICAgdmFsdWUgPSBub2RlLnZhbHVlO1xuICB9XG5cbiAgcmV0dXJuIHZhbHVlO1xufVxuXG5mdW5jdGlvbiB0cmFja1ZhbHVlT25Ob2RlKG5vZGUpIHtcbiAgdmFyIHZhbHVlRmllbGQgPSBpc0NoZWNrYWJsZShub2RlKSA/ICdjaGVja2VkJyA6ICd2YWx1ZSc7XG4gIHZhciBkZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihub2RlLmNvbnN0cnVjdG9yLnByb3RvdHlwZSwgdmFsdWVGaWVsZCk7XG4gIHZhciBjdXJyZW50VmFsdWUgPSAnJyArIG5vZGVbdmFsdWVGaWVsZF07IC8vIGlmIHNvbWVvbmUgaGFzIGFscmVhZHkgZGVmaW5lZCBhIHZhbHVlIG9yIFNhZmFyaSwgdGhlbiBiYWlsXG4gIC8vIGFuZCBkb24ndCB0cmFjayB2YWx1ZSB3aWxsIGNhdXNlIG92ZXIgcmVwb3J0aW5nIG9mIGNoYW5nZXMsXG4gIC8vIGJ1dCBpdCdzIGJldHRlciB0aGVuIGEgaGFyZCBmYWlsdXJlXG4gIC8vIChuZWVkZWQgZm9yIGNlcnRhaW4gdGVzdHMgdGhhdCBzcHlPbiBpbnB1dCB2YWx1ZXMgYW5kIFNhZmFyaSlcblxuICBpZiAobm9kZS5oYXNPd25Qcm9wZXJ0eSh2YWx1ZUZpZWxkKSB8fCB0eXBlb2YgZGVzY3JpcHRvciA9PT0gJ3VuZGVmaW5lZCcgfHwgdHlwZW9mIGRlc2NyaXB0b3IuZ2V0ICE9PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBkZXNjcmlwdG9yLnNldCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBnZXQgPSBkZXNjcmlwdG9yLmdldCxcbiAgICAgIHNldCA9IGRlc2NyaXB0b3Iuc2V0O1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkobm9kZSwgdmFsdWVGaWVsZCwge1xuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBnZXQuY2FsbCh0aGlzKTtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICBjdXJyZW50VmFsdWUgPSAnJyArIHZhbHVlO1xuICAgICAgc2V0LmNhbGwodGhpcywgdmFsdWUpO1xuICAgIH1cbiAgfSk7IC8vIFdlIGNvdWxkJ3ZlIHBhc3NlZCB0aGlzIHRoZSBmaXJzdCB0aW1lXG4gIC8vIGJ1dCBpdCB0cmlnZ2VycyBhIGJ1ZyBpbiBJRTExIGFuZCBFZGdlIDE0LzE1LlxuICAvLyBDYWxsaW5nIGRlZmluZVByb3BlcnR5KCkgYWdhaW4gc2hvdWxkIGJlIGVxdWl2YWxlbnQuXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTE3NjhcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkobm9kZSwgdmFsdWVGaWVsZCwge1xuICAgIGVudW1lcmFibGU6IGRlc2NyaXB0b3IuZW51bWVyYWJsZVxuICB9KTtcbiAgdmFyIHRyYWNrZXIgPSB7XG4gICAgZ2V0VmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBjdXJyZW50VmFsdWU7XG4gICAgfSxcbiAgICBzZXRWYWx1ZTogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICBjdXJyZW50VmFsdWUgPSAnJyArIHZhbHVlO1xuICAgIH0sXG4gICAgc3RvcFRyYWNraW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgICBkZXRhY2hUcmFja2VyKG5vZGUpO1xuICAgICAgZGVsZXRlIG5vZGVbdmFsdWVGaWVsZF07XG4gICAgfVxuICB9O1xuICByZXR1cm4gdHJhY2tlcjtcbn1cblxuZnVuY3Rpb24gdHJhY2sobm9kZSkge1xuICBpZiAoZ2V0VHJhY2tlcihub2RlKSkge1xuICAgIHJldHVybjtcbiAgfSAvLyBUT0RPOiBPbmNlIGl0J3MganVzdCBGaWJlciB3ZSBjYW4gbW92ZSB0aGlzIHRvIG5vZGUuX3dyYXBwZXJTdGF0ZVxuXG5cbiAgbm9kZS5fdmFsdWVUcmFja2VyID0gdHJhY2tWYWx1ZU9uTm9kZShub2RlKTtcbn1cbmZ1bmN0aW9uIHVwZGF0ZVZhbHVlSWZDaGFuZ2VkKG5vZGUpIHtcbiAgaWYgKCFub2RlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIHRyYWNrZXIgPSBnZXRUcmFja2VyKG5vZGUpOyAvLyBpZiB0aGVyZSBpcyBubyB0cmFja2VyIGF0IHRoaXMgcG9pbnQgaXQncyB1bmxpa2VseVxuICAvLyB0aGF0IHRyeWluZyBhZ2FpbiB3aWxsIHN1Y2NlZWRcblxuICBpZiAoIXRyYWNrZXIpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHZhciBsYXN0VmFsdWUgPSB0cmFja2VyLmdldFZhbHVlKCk7XG4gIHZhciBuZXh0VmFsdWUgPSBnZXRWYWx1ZUZyb21Ob2RlKG5vZGUpO1xuXG4gIGlmIChuZXh0VmFsdWUgIT09IGxhc3RWYWx1ZSkge1xuICAgIHRyYWNrZXIuc2V0VmFsdWUobmV4dFZhbHVlKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gZ2V0QWN0aXZlRWxlbWVudChkb2MpIHtcbiAgZG9jID0gZG9jIHx8ICh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnID8gZG9jdW1lbnQgOiB1bmRlZmluZWQpO1xuXG4gIGlmICh0eXBlb2YgZG9jID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdHJ5IHtcbiAgICByZXR1cm4gZG9jLmFjdGl2ZUVsZW1lbnQgfHwgZG9jLmJvZHk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZG9jLmJvZHk7XG4gIH1cbn1cblxudmFyIGRpZFdhcm5WYWx1ZURlZmF1bHRWYWx1ZSA9IGZhbHNlO1xudmFyIGRpZFdhcm5DaGVja2VkRGVmYXVsdENoZWNrZWQgPSBmYWxzZTtcbnZhciBkaWRXYXJuQ29udHJvbGxlZFRvVW5jb250cm9sbGVkID0gZmFsc2U7XG52YXIgZGlkV2FyblVuY29udHJvbGxlZFRvQ29udHJvbGxlZCA9IGZhbHNlO1xuXG5mdW5jdGlvbiBpc0NvbnRyb2xsZWQocHJvcHMpIHtcbiAgdmFyIHVzZXNDaGVja2VkID0gcHJvcHMudHlwZSA9PT0gJ2NoZWNrYm94JyB8fCBwcm9wcy50eXBlID09PSAncmFkaW8nO1xuICByZXR1cm4gdXNlc0NoZWNrZWQgPyBwcm9wcy5jaGVja2VkICE9IG51bGwgOiBwcm9wcy52YWx1ZSAhPSBudWxsO1xufVxuLyoqXG4gKiBJbXBsZW1lbnRzIGFuIDxpbnB1dD4gaG9zdCBjb21wb25lbnQgdGhhdCBhbGxvd3Mgc2V0dGluZyB0aGVzZSBvcHRpb25hbFxuICogcHJvcHM6IGBjaGVja2VkYCwgYHZhbHVlYCwgYGRlZmF1bHRDaGVja2VkYCwgYW5kIGBkZWZhdWx0VmFsdWVgLlxuICpcbiAqIElmIGBjaGVja2VkYCBvciBgdmFsdWVgIGFyZSBub3Qgc3VwcGxpZWQgKG9yIG51bGwvdW5kZWZpbmVkKSwgdXNlciBhY3Rpb25zXG4gKiB0aGF0IGFmZmVjdCB0aGUgY2hlY2tlZCBzdGF0ZSBvciB2YWx1ZSB3aWxsIHRyaWdnZXIgdXBkYXRlcyB0byB0aGUgZWxlbWVudC5cbiAqXG4gKiBJZiB0aGV5IGFyZSBzdXBwbGllZCAoYW5kIG5vdCBudWxsL3VuZGVmaW5lZCksIHRoZSByZW5kZXJlZCBlbGVtZW50IHdpbGwgbm90XG4gKiB0cmlnZ2VyIHVwZGF0ZXMgdG8gdGhlIGVsZW1lbnQuIEluc3RlYWQsIHRoZSBwcm9wcyBtdXN0IGNoYW5nZSBpbiBvcmRlciBmb3JcbiAqIHRoZSByZW5kZXJlZCBlbGVtZW50IHRvIGJlIHVwZGF0ZWQuXG4gKlxuICogVGhlIHJlbmRlcmVkIGVsZW1lbnQgd2lsbCBiZSBpbml0aWFsaXplZCBhcyB1bmNoZWNrZWQgKG9yIGBkZWZhdWx0Q2hlY2tlZGApXG4gKiB3aXRoIGFuIGVtcHR5IHZhbHVlIChvciBgZGVmYXVsdFZhbHVlYCkuXG4gKlxuICogU2VlIGh0dHA6Ly93d3cudzMub3JnL1RSLzIwMTIvV0QtaHRtbDUtMjAxMjEwMjUvdGhlLWlucHV0LWVsZW1lbnQuaHRtbFxuICovXG5cblxuZnVuY3Rpb24gZ2V0SG9zdFByb3BzKGVsZW1lbnQsIHByb3BzKSB7XG4gIHZhciBub2RlID0gZWxlbWVudDtcbiAgdmFyIGNoZWNrZWQgPSBwcm9wcy5jaGVja2VkO1xuXG4gIHZhciBob3N0UHJvcHMgPSBfYXNzaWduKHt9LCBwcm9wcywge1xuICAgIGRlZmF1bHRDaGVja2VkOiB1bmRlZmluZWQsXG4gICAgZGVmYXVsdFZhbHVlOiB1bmRlZmluZWQsXG4gICAgdmFsdWU6IHVuZGVmaW5lZCxcbiAgICBjaGVja2VkOiBjaGVja2VkICE9IG51bGwgPyBjaGVja2VkIDogbm9kZS5fd3JhcHBlclN0YXRlLmluaXRpYWxDaGVja2VkXG4gIH0pO1xuXG4gIHJldHVybiBob3N0UHJvcHM7XG59XG5mdW5jdGlvbiBpbml0V3JhcHBlclN0YXRlKGVsZW1lbnQsIHByb3BzKSB7XG4gIHtcbiAgICBjaGVja0NvbnRyb2xsZWRWYWx1ZVByb3BzKCdpbnB1dCcsIHByb3BzKTtcblxuICAgIGlmIChwcm9wcy5jaGVja2VkICE9PSB1bmRlZmluZWQgJiYgcHJvcHMuZGVmYXVsdENoZWNrZWQgIT09IHVuZGVmaW5lZCAmJiAhZGlkV2FybkNoZWNrZWREZWZhdWx0Q2hlY2tlZCkge1xuICAgICAgZXJyb3IoJyVzIGNvbnRhaW5zIGFuIGlucHV0IG9mIHR5cGUgJXMgd2l0aCBib3RoIGNoZWNrZWQgYW5kIGRlZmF1bHRDaGVja2VkIHByb3BzLiAnICsgJ0lucHV0IGVsZW1lbnRzIG11c3QgYmUgZWl0aGVyIGNvbnRyb2xsZWQgb3IgdW5jb250cm9sbGVkICcgKyAnKHNwZWNpZnkgZWl0aGVyIHRoZSBjaGVja2VkIHByb3AsIG9yIHRoZSBkZWZhdWx0Q2hlY2tlZCBwcm9wLCBidXQgbm90ICcgKyAnYm90aCkuIERlY2lkZSBiZXR3ZWVuIHVzaW5nIGEgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgaW5wdXQgJyArICdlbGVtZW50IGFuZCByZW1vdmUgb25lIG9mIHRoZXNlIHByb3BzLiBNb3JlIGluZm86ICcgKyAnaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL2NvbnRyb2xsZWQtY29tcG9uZW50cycsIGdldEN1cnJlbnRGaWJlck93bmVyTmFtZUluRGV2T3JOdWxsKCkgfHwgJ0EgY29tcG9uZW50JywgcHJvcHMudHlwZSk7XG5cbiAgICAgIGRpZFdhcm5DaGVja2VkRGVmYXVsdENoZWNrZWQgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmIChwcm9wcy52YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHByb3BzLmRlZmF1bHRWYWx1ZSAhPT0gdW5kZWZpbmVkICYmICFkaWRXYXJuVmFsdWVEZWZhdWx0VmFsdWUpIHtcbiAgICAgIGVycm9yKCclcyBjb250YWlucyBhbiBpbnB1dCBvZiB0eXBlICVzIHdpdGggYm90aCB2YWx1ZSBhbmQgZGVmYXVsdFZhbHVlIHByb3BzLiAnICsgJ0lucHV0IGVsZW1lbnRzIG11c3QgYmUgZWl0aGVyIGNvbnRyb2xsZWQgb3IgdW5jb250cm9sbGVkICcgKyAnKHNwZWNpZnkgZWl0aGVyIHRoZSB2YWx1ZSBwcm9wLCBvciB0aGUgZGVmYXVsdFZhbHVlIHByb3AsIGJ1dCBub3QgJyArICdib3RoKS4gRGVjaWRlIGJldHdlZW4gdXNpbmcgYSBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCBpbnB1dCAnICsgJ2VsZW1lbnQgYW5kIHJlbW92ZSBvbmUgb2YgdGhlc2UgcHJvcHMuIE1vcmUgaW5mbzogJyArICdodHRwczovL3JlYWN0anMub3JnL2xpbmsvY29udHJvbGxlZC1jb21wb25lbnRzJywgZ2V0Q3VycmVudEZpYmVyT3duZXJOYW1lSW5EZXZPck51bGwoKSB8fCAnQSBjb21wb25lbnQnLCBwcm9wcy50eXBlKTtcblxuICAgICAgZGlkV2FyblZhbHVlRGVmYXVsdFZhbHVlID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICB2YXIgbm9kZSA9IGVsZW1lbnQ7XG4gIHZhciBkZWZhdWx0VmFsdWUgPSBwcm9wcy5kZWZhdWx0VmFsdWUgPT0gbnVsbCA/ICcnIDogcHJvcHMuZGVmYXVsdFZhbHVlO1xuICBub2RlLl93cmFwcGVyU3RhdGUgPSB7XG4gICAgaW5pdGlhbENoZWNrZWQ6IHByb3BzLmNoZWNrZWQgIT0gbnVsbCA/IHByb3BzLmNoZWNrZWQgOiBwcm9wcy5kZWZhdWx0Q2hlY2tlZCxcbiAgICBpbml0aWFsVmFsdWU6IGdldFRvU3RyaW5nVmFsdWUocHJvcHMudmFsdWUgIT0gbnVsbCA/IHByb3BzLnZhbHVlIDogZGVmYXVsdFZhbHVlKSxcbiAgICBjb250cm9sbGVkOiBpc0NvbnRyb2xsZWQocHJvcHMpXG4gIH07XG59XG5mdW5jdGlvbiB1cGRhdGVDaGVja2VkKGVsZW1lbnQsIHByb3BzKSB7XG4gIHZhciBub2RlID0gZWxlbWVudDtcbiAgdmFyIGNoZWNrZWQgPSBwcm9wcy5jaGVja2VkO1xuXG4gIGlmIChjaGVja2VkICE9IG51bGwpIHtcbiAgICBzZXRWYWx1ZUZvclByb3BlcnR5KG5vZGUsICdjaGVja2VkJywgY2hlY2tlZCwgZmFsc2UpO1xuICB9XG59XG5mdW5jdGlvbiB1cGRhdGVXcmFwcGVyKGVsZW1lbnQsIHByb3BzKSB7XG4gIHZhciBub2RlID0gZWxlbWVudDtcblxuICB7XG4gICAgdmFyIGNvbnRyb2xsZWQgPSBpc0NvbnRyb2xsZWQocHJvcHMpO1xuXG4gICAgaWYgKCFub2RlLl93cmFwcGVyU3RhdGUuY29udHJvbGxlZCAmJiBjb250cm9sbGVkICYmICFkaWRXYXJuVW5jb250cm9sbGVkVG9Db250cm9sbGVkKSB7XG4gICAgICBlcnJvcignQSBjb21wb25lbnQgaXMgY2hhbmdpbmcgYW4gdW5jb250cm9sbGVkIGlucHV0IHRvIGJlIGNvbnRyb2xsZWQuICcgKyAnVGhpcyBpcyBsaWtlbHkgY2F1c2VkIGJ5IHRoZSB2YWx1ZSBjaGFuZ2luZyBmcm9tIHVuZGVmaW5lZCB0byAnICsgJ2EgZGVmaW5lZCB2YWx1ZSwgd2hpY2ggc2hvdWxkIG5vdCBoYXBwZW4uICcgKyAnRGVjaWRlIGJldHdlZW4gdXNpbmcgYSBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCBpbnB1dCAnICsgJ2VsZW1lbnQgZm9yIHRoZSBsaWZldGltZSBvZiB0aGUgY29tcG9uZW50LiBNb3JlIGluZm86IGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9jb250cm9sbGVkLWNvbXBvbmVudHMnKTtcblxuICAgICAgZGlkV2FyblVuY29udHJvbGxlZFRvQ29udHJvbGxlZCA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKG5vZGUuX3dyYXBwZXJTdGF0ZS5jb250cm9sbGVkICYmICFjb250cm9sbGVkICYmICFkaWRXYXJuQ29udHJvbGxlZFRvVW5jb250cm9sbGVkKSB7XG4gICAgICBlcnJvcignQSBjb21wb25lbnQgaXMgY2hhbmdpbmcgYSBjb250cm9sbGVkIGlucHV0IHRvIGJlIHVuY29udHJvbGxlZC4gJyArICdUaGlzIGlzIGxpa2VseSBjYXVzZWQgYnkgdGhlIHZhbHVlIGNoYW5naW5nIGZyb20gYSBkZWZpbmVkIHRvICcgKyAndW5kZWZpbmVkLCB3aGljaCBzaG91bGQgbm90IGhhcHBlbi4gJyArICdEZWNpZGUgYmV0d2VlbiB1c2luZyBhIGNvbnRyb2xsZWQgb3IgdW5jb250cm9sbGVkIGlucHV0ICcgKyAnZWxlbWVudCBmb3IgdGhlIGxpZmV0aW1lIG9mIHRoZSBjb21wb25lbnQuIE1vcmUgaW5mbzogaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL2NvbnRyb2xsZWQtY29tcG9uZW50cycpO1xuXG4gICAgICBkaWRXYXJuQ29udHJvbGxlZFRvVW5jb250cm9sbGVkID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICB1cGRhdGVDaGVja2VkKGVsZW1lbnQsIHByb3BzKTtcbiAgdmFyIHZhbHVlID0gZ2V0VG9TdHJpbmdWYWx1ZShwcm9wcy52YWx1ZSk7XG4gIHZhciB0eXBlID0gcHJvcHMudHlwZTtcblxuICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgIGlmICh0eXBlID09PSAnbnVtYmVyJykge1xuICAgICAgaWYgKHZhbHVlID09PSAwICYmIG5vZGUudmFsdWUgPT09ICcnIHx8IC8vIFdlIGV4cGxpY2l0bHkgd2FudCB0byBjb2VyY2UgdG8gbnVtYmVyIGhlcmUgaWYgcG9zc2libGUuXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICAgIG5vZGUudmFsdWUgIT0gdmFsdWUpIHtcbiAgICAgICAgbm9kZS52YWx1ZSA9IHRvU3RyaW5nKHZhbHVlKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG5vZGUudmFsdWUgIT09IHRvU3RyaW5nKHZhbHVlKSkge1xuICAgICAgbm9kZS52YWx1ZSA9IHRvU3RyaW5nKHZhbHVlKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gJ3N1Ym1pdCcgfHwgdHlwZSA9PT0gJ3Jlc2V0Jykge1xuICAgIC8vIFN1Ym1pdC9yZXNldCBpbnB1dHMgbmVlZCB0aGUgYXR0cmlidXRlIHJlbW92ZWQgY29tcGxldGVseSB0byBhdm9pZFxuICAgIC8vIGJsYW5rLXRleHQgYnV0dG9ucy5cbiAgICBub2RlLnJlbW92ZUF0dHJpYnV0ZSgndmFsdWUnKTtcbiAgICByZXR1cm47XG4gIH1cblxuICB7XG4gICAgLy8gV2hlbiBzeW5jaW5nIHRoZSB2YWx1ZSBhdHRyaWJ1dGUsIHRoZSB2YWx1ZSBjb21lcyBmcm9tIGEgY2FzY2FkZSBvZlxuICAgIC8vIHByb3BlcnRpZXM6XG4gICAgLy8gIDEuIFRoZSB2YWx1ZSBSZWFjdCBwcm9wZXJ0eVxuICAgIC8vICAyLiBUaGUgZGVmYXVsdFZhbHVlIFJlYWN0IHByb3BlcnR5XG4gICAgLy8gIDMuIE90aGVyd2lzZSB0aGVyZSBzaG91bGQgYmUgbm8gY2hhbmdlXG4gICAgaWYgKHByb3BzLmhhc093blByb3BlcnR5KCd2YWx1ZScpKSB7XG4gICAgICBzZXREZWZhdWx0VmFsdWUobm9kZSwgcHJvcHMudHlwZSwgdmFsdWUpO1xuICAgIH0gZWxzZSBpZiAocHJvcHMuaGFzT3duUHJvcGVydHkoJ2RlZmF1bHRWYWx1ZScpKSB7XG4gICAgICBzZXREZWZhdWx0VmFsdWUobm9kZSwgcHJvcHMudHlwZSwgZ2V0VG9TdHJpbmdWYWx1ZShwcm9wcy5kZWZhdWx0VmFsdWUpKTtcbiAgICB9XG4gIH1cblxuICB7XG4gICAgLy8gV2hlbiBzeW5jaW5nIHRoZSBjaGVja2VkIGF0dHJpYnV0ZSwgaXQgb25seSBjaGFuZ2VzIHdoZW4gaXQgbmVlZHNcbiAgICAvLyB0byBiZSByZW1vdmVkLCBzdWNoIGFzIHRyYW5zaXRpb25pbmcgZnJvbSBhIGNoZWNrYm94IGludG8gYSB0ZXh0IGlucHV0XG4gICAgaWYgKHByb3BzLmNoZWNrZWQgPT0gbnVsbCAmJiBwcm9wcy5kZWZhdWx0Q2hlY2tlZCAhPSBudWxsKSB7XG4gICAgICBub2RlLmRlZmF1bHRDaGVja2VkID0gISFwcm9wcy5kZWZhdWx0Q2hlY2tlZDtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHBvc3RNb3VudFdyYXBwZXIoZWxlbWVudCwgcHJvcHMsIGlzSHlkcmF0aW5nKSB7XG4gIHZhciBub2RlID0gZWxlbWVudDsgLy8gRG8gbm90IGFzc2lnbiB2YWx1ZSBpZiBpdCBpcyBhbHJlYWR5IHNldC4gVGhpcyBwcmV2ZW50cyB1c2VyIHRleHQgaW5wdXRcbiAgLy8gZnJvbSBiZWluZyBsb3N0IGR1cmluZyBTU1IgaHlkcmF0aW9uLlxuXG4gIGlmIChwcm9wcy5oYXNPd25Qcm9wZXJ0eSgndmFsdWUnKSB8fCBwcm9wcy5oYXNPd25Qcm9wZXJ0eSgnZGVmYXVsdFZhbHVlJykpIHtcbiAgICB2YXIgdHlwZSA9IHByb3BzLnR5cGU7XG4gICAgdmFyIGlzQnV0dG9uID0gdHlwZSA9PT0gJ3N1Ym1pdCcgfHwgdHlwZSA9PT0gJ3Jlc2V0JzsgLy8gQXZvaWQgc2V0dGluZyB2YWx1ZSBhdHRyaWJ1dGUgb24gc3VibWl0L3Jlc2V0IGlucHV0cyBhcyBpdCBvdmVycmlkZXMgdGhlXG4gICAgLy8gZGVmYXVsdCB2YWx1ZSBwcm92aWRlZCBieSB0aGUgYnJvd3Nlci4gU2VlOiAjMTI4NzJcblxuICAgIGlmIChpc0J1dHRvbiAmJiAocHJvcHMudmFsdWUgPT09IHVuZGVmaW5lZCB8fCBwcm9wcy52YWx1ZSA9PT0gbnVsbCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgaW5pdGlhbFZhbHVlID0gdG9TdHJpbmcobm9kZS5fd3JhcHBlclN0YXRlLmluaXRpYWxWYWx1ZSk7IC8vIERvIG5vdCBhc3NpZ24gdmFsdWUgaWYgaXQgaXMgYWxyZWFkeSBzZXQuIFRoaXMgcHJldmVudHMgdXNlciB0ZXh0IGlucHV0XG4gICAgLy8gZnJvbSBiZWluZyBsb3N0IGR1cmluZyBTU1IgaHlkcmF0aW9uLlxuXG4gICAgaWYgKCFpc0h5ZHJhdGluZykge1xuICAgICAge1xuICAgICAgICAvLyBXaGVuIHN5bmNpbmcgdGhlIHZhbHVlIGF0dHJpYnV0ZSwgdGhlIHZhbHVlIHByb3BlcnR5IHNob3VsZCB1c2VcbiAgICAgICAgLy8gdGhlIHdyYXBwZXJTdGF0ZS5faW5pdGlhbFZhbHVlIHByb3BlcnR5LiBUaGlzIHVzZXM6XG4gICAgICAgIC8vXG4gICAgICAgIC8vICAgMS4gVGhlIHZhbHVlIFJlYWN0IHByb3BlcnR5IHdoZW4gcHJlc2VudFxuICAgICAgICAvLyAgIDIuIFRoZSBkZWZhdWx0VmFsdWUgUmVhY3QgcHJvcGVydHkgd2hlbiBwcmVzZW50XG4gICAgICAgIC8vICAgMy4gQW4gZW1wdHkgc3RyaW5nXG4gICAgICAgIGlmIChpbml0aWFsVmFsdWUgIT09IG5vZGUudmFsdWUpIHtcbiAgICAgICAgICBub2RlLnZhbHVlID0gaW5pdGlhbFZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAge1xuICAgICAgLy8gT3RoZXJ3aXNlLCB0aGUgdmFsdWUgYXR0cmlidXRlIGlzIHN5bmNocm9uaXplZCB0byB0aGUgcHJvcGVydHksXG4gICAgICAvLyBzbyB3ZSBhc3NpZ24gZGVmYXVsdFZhbHVlIHRvIHRoZSBzYW1lIHRoaW5nIGFzIHRoZSB2YWx1ZSBwcm9wZXJ0eVxuICAgICAgLy8gYXNzaWdubWVudCBzdGVwIGFib3ZlLlxuICAgICAgbm9kZS5kZWZhdWx0VmFsdWUgPSBpbml0aWFsVmFsdWU7XG4gICAgfVxuICB9IC8vIE5vcm1hbGx5LCB3ZSdkIGp1c3QgZG8gYG5vZGUuY2hlY2tlZCA9IG5vZGUuY2hlY2tlZGAgdXBvbiBpbml0aWFsIG1vdW50LCBsZXNzIHRoaXMgYnVnXG4gIC8vIHRoaXMgaXMgbmVlZGVkIHRvIHdvcmsgYXJvdW5kIGEgY2hyb21lIGJ1ZyB3aGVyZSBzZXR0aW5nIGRlZmF1bHRDaGVja2VkXG4gIC8vIHdpbGwgc29tZXRpbWVzIGluZmx1ZW5jZSB0aGUgdmFsdWUgb2YgY2hlY2tlZCAoZXZlbiBhZnRlciBkZXRhY2htZW50KS5cbiAgLy8gUmVmZXJlbmNlOiBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD02MDg0MTZcbiAgLy8gV2UgbmVlZCB0byB0ZW1wb3JhcmlseSB1bnNldCBuYW1lIHRvIGF2b2lkIGRpc3J1cHRpbmcgcmFkaW8gYnV0dG9uIGdyb3Vwcy5cblxuXG4gIHZhciBuYW1lID0gbm9kZS5uYW1lO1xuXG4gIGlmIChuYW1lICE9PSAnJykge1xuICAgIG5vZGUubmFtZSA9ICcnO1xuICB9XG5cbiAge1xuICAgIC8vIFdoZW4gc3luY2luZyB0aGUgY2hlY2tlZCBhdHRyaWJ1dGUsIGJvdGggdGhlIGNoZWNrZWQgcHJvcGVydHkgYW5kXG4gICAgLy8gYXR0cmlidXRlIGFyZSBhc3NpZ25lZCBhdCB0aGUgc2FtZSB0aW1lIHVzaW5nIGRlZmF1bHRDaGVja2VkLiBUaGlzIHVzZXM6XG4gICAgLy9cbiAgICAvLyAgIDEuIFRoZSBjaGVja2VkIFJlYWN0IHByb3BlcnR5IHdoZW4gcHJlc2VudFxuICAgIC8vICAgMi4gVGhlIGRlZmF1bHRDaGVja2VkIFJlYWN0IHByb3BlcnR5IHdoZW4gcHJlc2VudFxuICAgIC8vICAgMy4gT3RoZXJ3aXNlLCBmYWxzZVxuICAgIG5vZGUuZGVmYXVsdENoZWNrZWQgPSAhbm9kZS5kZWZhdWx0Q2hlY2tlZDtcbiAgICBub2RlLmRlZmF1bHRDaGVja2VkID0gISFub2RlLl93cmFwcGVyU3RhdGUuaW5pdGlhbENoZWNrZWQ7XG4gIH1cblxuICBpZiAobmFtZSAhPT0gJycpIHtcbiAgICBub2RlLm5hbWUgPSBuYW1lO1xuICB9XG59XG5mdW5jdGlvbiByZXN0b3JlQ29udHJvbGxlZFN0YXRlKGVsZW1lbnQsIHByb3BzKSB7XG4gIHZhciBub2RlID0gZWxlbWVudDtcbiAgdXBkYXRlV3JhcHBlcihub2RlLCBwcm9wcyk7XG4gIHVwZGF0ZU5hbWVkQ291c2lucyhub2RlLCBwcm9wcyk7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZU5hbWVkQ291c2lucyhyb290Tm9kZSwgcHJvcHMpIHtcbiAgdmFyIG5hbWUgPSBwcm9wcy5uYW1lO1xuXG4gIGlmIChwcm9wcy50eXBlID09PSAncmFkaW8nICYmIG5hbWUgIT0gbnVsbCkge1xuICAgIHZhciBxdWVyeVJvb3QgPSByb290Tm9kZTtcblxuICAgIHdoaWxlIChxdWVyeVJvb3QucGFyZW50Tm9kZSkge1xuICAgICAgcXVlcnlSb290ID0gcXVlcnlSb290LnBhcmVudE5vZGU7XG4gICAgfSAvLyBJZiBgcm9vdE5vZGUuZm9ybWAgd2FzIG5vbi1udWxsLCB0aGVuIHdlIGNvdWxkIHRyeSBgZm9ybS5lbGVtZW50c2AsXG4gICAgLy8gYnV0IHRoYXQgc29tZXRpbWVzIGJlaGF2ZXMgc3RyYW5nZWx5IGluIElFOC4gV2UgY291bGQgYWxzbyB0cnkgdXNpbmdcbiAgICAvLyBgZm9ybS5nZXRFbGVtZW50c0J5TmFtZWAsIGJ1dCB0aGF0IHdpbGwgb25seSByZXR1cm4gZGlyZWN0IGNoaWxkcmVuXG4gICAgLy8gYW5kIHdvbid0IGluY2x1ZGUgaW5wdXRzIHRoYXQgdXNlIHRoZSBIVE1MNSBgZm9ybT1gIGF0dHJpYnV0ZS4gU2luY2VcbiAgICAvLyB0aGUgaW5wdXQgbWlnaHQgbm90IGV2ZW4gYmUgaW4gYSBmb3JtLiBJdCBtaWdodCBub3QgZXZlbiBiZSBpbiB0aGVcbiAgICAvLyBkb2N1bWVudC4gTGV0J3MganVzdCB1c2UgdGhlIGxvY2FsIGBxdWVyeVNlbGVjdG9yQWxsYCB0byBlbnN1cmUgd2UgZG9uJ3RcbiAgICAvLyBtaXNzIGFueXRoaW5nLlxuXG5cbiAgICB2YXIgZ3JvdXAgPSBxdWVyeVJvb3QucXVlcnlTZWxlY3RvckFsbCgnaW5wdXRbbmFtZT0nICsgSlNPTi5zdHJpbmdpZnkoJycgKyBuYW1lKSArICddW3R5cGU9XCJyYWRpb1wiXScpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBncm91cC5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIG90aGVyTm9kZSA9IGdyb3VwW2ldO1xuXG4gICAgICBpZiAob3RoZXJOb2RlID09PSByb290Tm9kZSB8fCBvdGhlck5vZGUuZm9ybSAhPT0gcm9vdE5vZGUuZm9ybSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH0gLy8gVGhpcyB3aWxsIHRocm93IGlmIHJhZGlvIGJ1dHRvbnMgcmVuZGVyZWQgYnkgZGlmZmVyZW50IGNvcGllcyBvZiBSZWFjdFxuICAgICAgLy8gYW5kIHRoZSBzYW1lIG5hbWUgYXJlIHJlbmRlcmVkIGludG8gdGhlIHNhbWUgZm9ybSAoc2FtZSBhcyAjMTkzOSkuXG4gICAgICAvLyBUaGF0J3MgcHJvYmFibHkgb2theTsgd2UgZG9uJ3Qgc3VwcG9ydCBpdCBqdXN0IGFzIHdlIGRvbid0IHN1cHBvcnRcbiAgICAgIC8vIG1peGluZyBSZWFjdCByYWRpbyBidXR0b25zIHdpdGggbm9uLVJlYWN0IG9uZXMuXG5cblxuICAgICAgdmFyIG90aGVyUHJvcHMgPSBnZXRGaWJlckN1cnJlbnRQcm9wc0Zyb21Ob2RlKG90aGVyTm9kZSk7XG5cbiAgICAgIGlmICghb3RoZXJQcm9wcykge1xuICAgICAgICB7XG4gICAgICAgICAgdGhyb3cgRXJyb3IoIFwiUmVhY3RET01JbnB1dDogTWl4aW5nIFJlYWN0IGFuZCBub24tUmVhY3QgcmFkaW8gaW5wdXRzIHdpdGggdGhlIHNhbWUgYG5hbWVgIGlzIG5vdCBzdXBwb3J0ZWQuXCIgKTtcbiAgICAgICAgfVxuICAgICAgfSAvLyBXZSBuZWVkIHVwZGF0ZSB0aGUgdHJhY2tlZCB2YWx1ZSBvbiB0aGUgbmFtZWQgY291c2luIHNpbmNlIHRoZSB2YWx1ZVxuICAgICAgLy8gd2FzIGNoYW5nZWQgYnV0IHRoZSBpbnB1dCBzYXcgbm8gZXZlbnQgb3IgdmFsdWUgc2V0XG5cblxuICAgICAgdXBkYXRlVmFsdWVJZkNoYW5nZWQob3RoZXJOb2RlKTsgLy8gSWYgdGhpcyBpcyBhIGNvbnRyb2xsZWQgcmFkaW8gYnV0dG9uIGdyb3VwLCBmb3JjaW5nIHRoZSBpbnB1dCB0aGF0XG4gICAgICAvLyB3YXMgcHJldmlvdXNseSBjaGVja2VkIHRvIHVwZGF0ZSB3aWxsIGNhdXNlIGl0IHRvIGJlIGNvbWUgcmUtY2hlY2tlZFxuICAgICAgLy8gYXMgYXBwcm9wcmlhdGUuXG5cbiAgICAgIHVwZGF0ZVdyYXBwZXIob3RoZXJOb2RlLCBvdGhlclByb3BzKTtcbiAgICB9XG4gIH1cbn0gLy8gSW4gQ2hyb21lLCBhc3NpZ25pbmcgZGVmYXVsdFZhbHVlIHRvIGNlcnRhaW4gaW5wdXQgdHlwZXMgdHJpZ2dlcnMgaW5wdXQgdmFsaWRhdGlvbi5cbi8vIEZvciBudW1iZXIgaW5wdXRzLCB0aGUgZGlzcGxheSB2YWx1ZSBsb3NlcyB0cmFpbGluZyBkZWNpbWFsIHBvaW50cy4gRm9yIGVtYWlsIGlucHV0cyxcbi8vIENocm9tZSByYWlzZXMgXCJUaGUgc3BlY2lmaWVkIHZhbHVlIDx4PiBpcyBub3QgYSB2YWxpZCBlbWFpbCBhZGRyZXNzXCIuXG4vL1xuLy8gSGVyZSB3ZSBjaGVjayB0byBzZWUgaWYgdGhlIGRlZmF1bHRWYWx1ZSBoYXMgYWN0dWFsbHkgY2hhbmdlZCwgYXZvaWRpbmcgdGhlc2UgcHJvYmxlbXNcbi8vIHdoZW4gdGhlIHVzZXIgaXMgaW5wdXR0aW5nIHRleHRcbi8vXG4vLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzcyNTNcblxuXG5mdW5jdGlvbiBzZXREZWZhdWx0VmFsdWUobm9kZSwgdHlwZSwgdmFsdWUpIHtcbiAgaWYgKCAvLyBGb2N1c2VkIG51bWJlciBpbnB1dHMgc3luY2hyb25pemUgb24gYmx1ci4gU2VlIENoYW5nZUV2ZW50UGx1Z2luLmpzXG4gIHR5cGUgIT09ICdudW1iZXInIHx8IGdldEFjdGl2ZUVsZW1lbnQobm9kZS5vd25lckRvY3VtZW50KSAhPT0gbm9kZSkge1xuICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICBub2RlLmRlZmF1bHRWYWx1ZSA9IHRvU3RyaW5nKG5vZGUuX3dyYXBwZXJTdGF0ZS5pbml0aWFsVmFsdWUpO1xuICAgIH0gZWxzZSBpZiAobm9kZS5kZWZhdWx0VmFsdWUgIT09IHRvU3RyaW5nKHZhbHVlKSkge1xuICAgICAgbm9kZS5kZWZhdWx0VmFsdWUgPSB0b1N0cmluZyh2YWx1ZSk7XG4gICAgfVxuICB9XG59XG5cbnZhciBkaWRXYXJuU2VsZWN0ZWRTZXRPbk9wdGlvbiA9IGZhbHNlO1xudmFyIGRpZFdhcm5JbnZhbGlkQ2hpbGQgPSBmYWxzZTtcblxuZnVuY3Rpb24gZmxhdHRlbkNoaWxkcmVuKGNoaWxkcmVuKSB7XG4gIHZhciBjb250ZW50ID0gJyc7IC8vIEZsYXR0ZW4gY2hpbGRyZW4uIFdlJ2xsIHdhcm4gaWYgdGhleSBhcmUgaW52YWxpZFxuICAvLyBkdXJpbmcgdmFsaWRhdGVQcm9wcygpIHdoaWNoIHJ1bnMgZm9yIGh5ZHJhdGlvbiB0b28uXG4gIC8vIE5vdGUgdGhhdCB0aGlzIHdvdWxkIHRocm93IG9uIG5vbi1lbGVtZW50IG9iamVjdHMuXG4gIC8vIEVsZW1lbnRzIGFyZSBzdHJpbmdpZmllZCAod2hpY2ggaXMgbm9ybWFsbHkgaXJyZWxldmFudFxuICAvLyBidXQgbWF0dGVycyBmb3IgPGZidD4pLlxuXG4gIFJlYWN0LkNoaWxkcmVuLmZvckVhY2goY2hpbGRyZW4sIGZ1bmN0aW9uIChjaGlsZCkge1xuICAgIGlmIChjaGlsZCA9PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29udGVudCArPSBjaGlsZDsgLy8gTm90ZTogd2UgZG9uJ3Qgd2FybiBhYm91dCBpbnZhbGlkIGNoaWxkcmVuIGhlcmUuXG4gICAgLy8gSW5zdGVhZCwgdGhpcyBpcyBkb25lIHNlcGFyYXRlbHkgYmVsb3cgc28gdGhhdFxuICAgIC8vIGl0IGhhcHBlbnMgZHVyaW5nIHRoZSBoeWRyYXRpb24gY29kZSBwYXRoIHRvby5cbiAgfSk7XG4gIHJldHVybiBjb250ZW50O1xufVxuLyoqXG4gKiBJbXBsZW1lbnRzIGFuIDxvcHRpb24+IGhvc3QgY29tcG9uZW50IHRoYXQgd2FybnMgd2hlbiBgc2VsZWN0ZWRgIGlzIHNldC5cbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlUHJvcHMoZWxlbWVudCwgcHJvcHMpIHtcbiAge1xuICAgIC8vIFRoaXMgbWlycm9ycyB0aGUgY29kZSBwYXRoIGFib3ZlLCBidXQgcnVucyBmb3IgaHlkcmF0aW9uIHRvby5cbiAgICAvLyBXYXJuIGFib3V0IGludmFsaWQgY2hpbGRyZW4gaGVyZSBzbyB0aGF0IGNsaWVudCBhbmQgaHlkcmF0aW9uIGFyZSBjb25zaXN0ZW50LlxuICAgIC8vIFRPRE86IHRoaXMgc2VlbXMgbGlrZSBpdCBjb3VsZCBjYXVzZSBhIERFVi1vbmx5IHRocm93IGZvciBoeWRyYXRpb25cbiAgICAvLyBpZiBjaGlsZHJlbiBjb250YWlucyBhIG5vbi1lbGVtZW50IG9iamVjdC4gV2Ugc2hvdWxkIHRyeSB0byBhdm9pZCB0aGF0LlxuICAgIGlmICh0eXBlb2YgcHJvcHMuY2hpbGRyZW4gPT09ICdvYmplY3QnICYmIHByb3BzLmNoaWxkcmVuICE9PSBudWxsKSB7XG4gICAgICBSZWFjdC5DaGlsZHJlbi5mb3JFYWNoKHByb3BzLmNoaWxkcmVuLCBmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgaWYgKGNoaWxkID09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGNoaWxkID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgY2hpbGQgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBjaGlsZC50eXBlICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghZGlkV2FybkludmFsaWRDaGlsZCkge1xuICAgICAgICAgIGRpZFdhcm5JbnZhbGlkQ2hpbGQgPSB0cnVlO1xuXG4gICAgICAgICAgZXJyb3IoJ09ubHkgc3RyaW5ncyBhbmQgbnVtYmVycyBhcmUgc3VwcG9ydGVkIGFzIDxvcHRpb24+IGNoaWxkcmVuLicpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IC8vIFRPRE86IFJlbW92ZSBzdXBwb3J0IGZvciBgc2VsZWN0ZWRgIGluIDxvcHRpb24+LlxuXG5cbiAgICBpZiAocHJvcHMuc2VsZWN0ZWQgIT0gbnVsbCAmJiAhZGlkV2FyblNlbGVjdGVkU2V0T25PcHRpb24pIHtcbiAgICAgIGVycm9yKCdVc2UgdGhlIGBkZWZhdWx0VmFsdWVgIG9yIGB2YWx1ZWAgcHJvcHMgb24gPHNlbGVjdD4gaW5zdGVhZCBvZiAnICsgJ3NldHRpbmcgYHNlbGVjdGVkYCBvbiA8b3B0aW9uPi4nKTtcblxuICAgICAgZGlkV2FyblNlbGVjdGVkU2V0T25PcHRpb24gPSB0cnVlO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gcG9zdE1vdW50V3JhcHBlciQxKGVsZW1lbnQsIHByb3BzKSB7XG4gIC8vIHZhbHVlPVwiXCIgc2hvdWxkIG1ha2UgYSB2YWx1ZSBhdHRyaWJ1dGUgKCM2MjE5KVxuICBpZiAocHJvcHMudmFsdWUgIT0gbnVsbCkge1xuICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKCd2YWx1ZScsIHRvU3RyaW5nKGdldFRvU3RyaW5nVmFsdWUocHJvcHMudmFsdWUpKSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGdldEhvc3RQcm9wcyQxKGVsZW1lbnQsIHByb3BzKSB7XG4gIHZhciBob3N0UHJvcHMgPSBfYXNzaWduKHtcbiAgICBjaGlsZHJlbjogdW5kZWZpbmVkXG4gIH0sIHByb3BzKTtcblxuICB2YXIgY29udGVudCA9IGZsYXR0ZW5DaGlsZHJlbihwcm9wcy5jaGlsZHJlbik7XG5cbiAgaWYgKGNvbnRlbnQpIHtcbiAgICBob3N0UHJvcHMuY2hpbGRyZW4gPSBjb250ZW50O1xuICB9XG5cbiAgcmV0dXJuIGhvc3RQcm9wcztcbn1cblxudmFyIGRpZFdhcm5WYWx1ZURlZmF1bHRWYWx1ZSQxO1xuXG57XG4gIGRpZFdhcm5WYWx1ZURlZmF1bHRWYWx1ZSQxID0gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bSgpIHtcbiAgdmFyIG93bmVyTmFtZSA9IGdldEN1cnJlbnRGaWJlck93bmVyTmFtZUluRGV2T3JOdWxsKCk7XG5cbiAgaWYgKG93bmVyTmFtZSkge1xuICAgIHJldHVybiAnXFxuXFxuQ2hlY2sgdGhlIHJlbmRlciBtZXRob2Qgb2YgYCcgKyBvd25lck5hbWUgKyAnYC4nO1xuICB9XG5cbiAgcmV0dXJuICcnO1xufVxuXG52YXIgdmFsdWVQcm9wTmFtZXMgPSBbJ3ZhbHVlJywgJ2RlZmF1bHRWYWx1ZSddO1xuLyoqXG4gKiBWYWxpZGF0aW9uIGZ1bmN0aW9uIGZvciBgdmFsdWVgIGFuZCBgZGVmYXVsdFZhbHVlYC5cbiAqL1xuXG5mdW5jdGlvbiBjaGVja1NlbGVjdFByb3BUeXBlcyhwcm9wcykge1xuICB7XG4gICAgY2hlY2tDb250cm9sbGVkVmFsdWVQcm9wcygnc2VsZWN0JywgcHJvcHMpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZVByb3BOYW1lcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHByb3BOYW1lID0gdmFsdWVQcm9wTmFtZXNbaV07XG5cbiAgICAgIGlmIChwcm9wc1twcm9wTmFtZV0gPT0gbnVsbCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5KHByb3BzW3Byb3BOYW1lXSk7XG5cbiAgICAgIGlmIChwcm9wcy5tdWx0aXBsZSAmJiAhaXNBcnJheSkge1xuICAgICAgICBlcnJvcignVGhlIGAlc2AgcHJvcCBzdXBwbGllZCB0byA8c2VsZWN0PiBtdXN0IGJlIGFuIGFycmF5IGlmICcgKyAnYG11bHRpcGxlYCBpcyB0cnVlLiVzJywgcHJvcE5hbWUsIGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bSgpKTtcbiAgICAgIH0gZWxzZSBpZiAoIXByb3BzLm11bHRpcGxlICYmIGlzQXJyYXkpIHtcbiAgICAgICAgZXJyb3IoJ1RoZSBgJXNgIHByb3Agc3VwcGxpZWQgdG8gPHNlbGVjdD4gbXVzdCBiZSBhIHNjYWxhciAnICsgJ3ZhbHVlIGlmIGBtdWx0aXBsZWAgaXMgZmFsc2UuJXMnLCBwcm9wTmFtZSwgZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKCkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiB1cGRhdGVPcHRpb25zKG5vZGUsIG11bHRpcGxlLCBwcm9wVmFsdWUsIHNldERlZmF1bHRTZWxlY3RlZCkge1xuICB2YXIgb3B0aW9ucyA9IG5vZGUub3B0aW9ucztcblxuICBpZiAobXVsdGlwbGUpIHtcbiAgICB2YXIgc2VsZWN0ZWRWYWx1ZXMgPSBwcm9wVmFsdWU7XG4gICAgdmFyIHNlbGVjdGVkVmFsdWUgPSB7fTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2VsZWN0ZWRWYWx1ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIC8vIFByZWZpeCB0byBhdm9pZCBjaGFvcyB3aXRoIHNwZWNpYWwga2V5cy5cbiAgICAgIHNlbGVjdGVkVmFsdWVbJyQnICsgc2VsZWN0ZWRWYWx1ZXNbaV1dID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgb3B0aW9ucy5sZW5ndGg7IF9pKyspIHtcbiAgICAgIHZhciBzZWxlY3RlZCA9IHNlbGVjdGVkVmFsdWUuaGFzT3duUHJvcGVydHkoJyQnICsgb3B0aW9uc1tfaV0udmFsdWUpO1xuXG4gICAgICBpZiAob3B0aW9uc1tfaV0uc2VsZWN0ZWQgIT09IHNlbGVjdGVkKSB7XG4gICAgICAgIG9wdGlvbnNbX2ldLnNlbGVjdGVkID0gc2VsZWN0ZWQ7XG4gICAgICB9XG5cbiAgICAgIGlmIChzZWxlY3RlZCAmJiBzZXREZWZhdWx0U2VsZWN0ZWQpIHtcbiAgICAgICAgb3B0aW9uc1tfaV0uZGVmYXVsdFNlbGVjdGVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gRG8gbm90IHNldCBgc2VsZWN0LnZhbHVlYCBhcyBleGFjdCBiZWhhdmlvciBpc24ndCBjb25zaXN0ZW50IGFjcm9zcyBhbGxcbiAgICAvLyBicm93c2VycyBmb3IgYWxsIGNhc2VzLlxuICAgIHZhciBfc2VsZWN0ZWRWYWx1ZSA9IHRvU3RyaW5nKGdldFRvU3RyaW5nVmFsdWUocHJvcFZhbHVlKSk7XG5cbiAgICB2YXIgZGVmYXVsdFNlbGVjdGVkID0gbnVsbDtcblxuICAgIGZvciAodmFyIF9pMiA9IDA7IF9pMiA8IG9wdGlvbnMubGVuZ3RoOyBfaTIrKykge1xuICAgICAgaWYgKG9wdGlvbnNbX2kyXS52YWx1ZSA9PT0gX3NlbGVjdGVkVmFsdWUpIHtcbiAgICAgICAgb3B0aW9uc1tfaTJdLnNlbGVjdGVkID0gdHJ1ZTtcblxuICAgICAgICBpZiAoc2V0RGVmYXVsdFNlbGVjdGVkKSB7XG4gICAgICAgICAgb3B0aW9uc1tfaTJdLmRlZmF1bHRTZWxlY3RlZCA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChkZWZhdWx0U2VsZWN0ZWQgPT09IG51bGwgJiYgIW9wdGlvbnNbX2kyXS5kaXNhYmxlZCkge1xuICAgICAgICBkZWZhdWx0U2VsZWN0ZWQgPSBvcHRpb25zW19pMl07XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGRlZmF1bHRTZWxlY3RlZCAhPT0gbnVsbCkge1xuICAgICAgZGVmYXVsdFNlbGVjdGVkLnNlbGVjdGVkID0gdHJ1ZTtcbiAgICB9XG4gIH1cbn1cbi8qKlxuICogSW1wbGVtZW50cyBhIDxzZWxlY3Q+IGhvc3QgY29tcG9uZW50IHRoYXQgYWxsb3dzIG9wdGlvbmFsbHkgc2V0dGluZyB0aGVcbiAqIHByb3BzIGB2YWx1ZWAgYW5kIGBkZWZhdWx0VmFsdWVgLiBJZiBgbXVsdGlwbGVgIGlzIGZhbHNlLCB0aGUgcHJvcCBtdXN0IGJlIGFcbiAqIHN0cmluZ2FibGUuIElmIGBtdWx0aXBsZWAgaXMgdHJ1ZSwgdGhlIHByb3AgbXVzdCBiZSBhbiBhcnJheSBvZiBzdHJpbmdhYmxlcy5cbiAqXG4gKiBJZiBgdmFsdWVgIGlzIG5vdCBzdXBwbGllZCAob3IgbnVsbC91bmRlZmluZWQpLCB1c2VyIGFjdGlvbnMgdGhhdCBjaGFuZ2UgdGhlXG4gKiBzZWxlY3RlZCBvcHRpb24gd2lsbCB0cmlnZ2VyIHVwZGF0ZXMgdG8gdGhlIHJlbmRlcmVkIG9wdGlvbnMuXG4gKlxuICogSWYgaXQgaXMgc3VwcGxpZWQgKGFuZCBub3QgbnVsbC91bmRlZmluZWQpLCB0aGUgcmVuZGVyZWQgb3B0aW9ucyB3aWxsIG5vdFxuICogdXBkYXRlIGluIHJlc3BvbnNlIHRvIHVzZXIgYWN0aW9ucy4gSW5zdGVhZCwgdGhlIGB2YWx1ZWAgcHJvcCBtdXN0IGNoYW5nZSBpblxuICogb3JkZXIgZm9yIHRoZSByZW5kZXJlZCBvcHRpb25zIHRvIHVwZGF0ZS5cbiAqXG4gKiBJZiBgZGVmYXVsdFZhbHVlYCBpcyBwcm92aWRlZCwgYW55IG9wdGlvbnMgd2l0aCB0aGUgc3VwcGxpZWQgdmFsdWVzIHdpbGwgYmVcbiAqIHNlbGVjdGVkLlxuICovXG5cblxuZnVuY3Rpb24gZ2V0SG9zdFByb3BzJDIoZWxlbWVudCwgcHJvcHMpIHtcbiAgcmV0dXJuIF9hc3NpZ24oe30sIHByb3BzLCB7XG4gICAgdmFsdWU6IHVuZGVmaW5lZFxuICB9KTtcbn1cbmZ1bmN0aW9uIGluaXRXcmFwcGVyU3RhdGUkMShlbGVtZW50LCBwcm9wcykge1xuICB2YXIgbm9kZSA9IGVsZW1lbnQ7XG5cbiAge1xuICAgIGNoZWNrU2VsZWN0UHJvcFR5cGVzKHByb3BzKTtcbiAgfVxuXG4gIG5vZGUuX3dyYXBwZXJTdGF0ZSA9IHtcbiAgICB3YXNNdWx0aXBsZTogISFwcm9wcy5tdWx0aXBsZVxuICB9O1xuXG4gIHtcbiAgICBpZiAocHJvcHMudmFsdWUgIT09IHVuZGVmaW5lZCAmJiBwcm9wcy5kZWZhdWx0VmFsdWUgIT09IHVuZGVmaW5lZCAmJiAhZGlkV2FyblZhbHVlRGVmYXVsdFZhbHVlJDEpIHtcbiAgICAgIGVycm9yKCdTZWxlY3QgZWxlbWVudHMgbXVzdCBiZSBlaXRoZXIgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgJyArICcoc3BlY2lmeSBlaXRoZXIgdGhlIHZhbHVlIHByb3AsIG9yIHRoZSBkZWZhdWx0VmFsdWUgcHJvcCwgYnV0IG5vdCAnICsgJ2JvdGgpLiBEZWNpZGUgYmV0d2VlbiB1c2luZyBhIGNvbnRyb2xsZWQgb3IgdW5jb250cm9sbGVkIHNlbGVjdCAnICsgJ2VsZW1lbnQgYW5kIHJlbW92ZSBvbmUgb2YgdGhlc2UgcHJvcHMuIE1vcmUgaW5mbzogJyArICdodHRwczovL3JlYWN0anMub3JnL2xpbmsvY29udHJvbGxlZC1jb21wb25lbnRzJyk7XG5cbiAgICAgIGRpZFdhcm5WYWx1ZURlZmF1bHRWYWx1ZSQxID0gdHJ1ZTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHBvc3RNb3VudFdyYXBwZXIkMihlbGVtZW50LCBwcm9wcykge1xuICB2YXIgbm9kZSA9IGVsZW1lbnQ7XG4gIG5vZGUubXVsdGlwbGUgPSAhIXByb3BzLm11bHRpcGxlO1xuICB2YXIgdmFsdWUgPSBwcm9wcy52YWx1ZTtcblxuICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgIHVwZGF0ZU9wdGlvbnMobm9kZSwgISFwcm9wcy5tdWx0aXBsZSwgdmFsdWUsIGZhbHNlKTtcbiAgfSBlbHNlIGlmIChwcm9wcy5kZWZhdWx0VmFsdWUgIT0gbnVsbCkge1xuICAgIHVwZGF0ZU9wdGlvbnMobm9kZSwgISFwcm9wcy5tdWx0aXBsZSwgcHJvcHMuZGVmYXVsdFZhbHVlLCB0cnVlKTtcbiAgfVxufVxuZnVuY3Rpb24gcG9zdFVwZGF0ZVdyYXBwZXIoZWxlbWVudCwgcHJvcHMpIHtcbiAgdmFyIG5vZGUgPSBlbGVtZW50O1xuICB2YXIgd2FzTXVsdGlwbGUgPSBub2RlLl93cmFwcGVyU3RhdGUud2FzTXVsdGlwbGU7XG4gIG5vZGUuX3dyYXBwZXJTdGF0ZS53YXNNdWx0aXBsZSA9ICEhcHJvcHMubXVsdGlwbGU7XG4gIHZhciB2YWx1ZSA9IHByb3BzLnZhbHVlO1xuXG4gIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgdXBkYXRlT3B0aW9ucyhub2RlLCAhIXByb3BzLm11bHRpcGxlLCB2YWx1ZSwgZmFsc2UpO1xuICB9IGVsc2UgaWYgKHdhc011bHRpcGxlICE9PSAhIXByb3BzLm11bHRpcGxlKSB7XG4gICAgLy8gRm9yIHNpbXBsaWNpdHksIHJlYXBwbHkgYGRlZmF1bHRWYWx1ZWAgaWYgYG11bHRpcGxlYCBpcyB0b2dnbGVkLlxuICAgIGlmIChwcm9wcy5kZWZhdWx0VmFsdWUgIT0gbnVsbCkge1xuICAgICAgdXBkYXRlT3B0aW9ucyhub2RlLCAhIXByb3BzLm11bHRpcGxlLCBwcm9wcy5kZWZhdWx0VmFsdWUsIHRydWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBSZXZlcnQgdGhlIHNlbGVjdCBiYWNrIHRvIGl0cyBkZWZhdWx0IHVuc2VsZWN0ZWQgc3RhdGUuXG4gICAgICB1cGRhdGVPcHRpb25zKG5vZGUsICEhcHJvcHMubXVsdGlwbGUsIHByb3BzLm11bHRpcGxlID8gW10gOiAnJywgZmFsc2UpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gcmVzdG9yZUNvbnRyb2xsZWRTdGF0ZSQxKGVsZW1lbnQsIHByb3BzKSB7XG4gIHZhciBub2RlID0gZWxlbWVudDtcbiAgdmFyIHZhbHVlID0gcHJvcHMudmFsdWU7XG5cbiAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICB1cGRhdGVPcHRpb25zKG5vZGUsICEhcHJvcHMubXVsdGlwbGUsIHZhbHVlLCBmYWxzZSk7XG4gIH1cbn1cblxudmFyIGRpZFdhcm5WYWxEZWZhdWx0VmFsID0gZmFsc2U7XG5cbi8qKlxuICogSW1wbGVtZW50cyBhIDx0ZXh0YXJlYT4gaG9zdCBjb21wb25lbnQgdGhhdCBhbGxvd3Mgc2V0dGluZyBgdmFsdWVgLCBhbmRcbiAqIGBkZWZhdWx0VmFsdWVgLiBUaGlzIGRpZmZlcnMgZnJvbSB0aGUgdHJhZGl0aW9uYWwgRE9NIEFQSSBiZWNhdXNlIHZhbHVlIGlzXG4gKiB1c3VhbGx5IHNldCBhcyBQQ0RBVEEgY2hpbGRyZW4uXG4gKlxuICogSWYgYHZhbHVlYCBpcyBub3Qgc3VwcGxpZWQgKG9yIG51bGwvdW5kZWZpbmVkKSwgdXNlciBhY3Rpb25zIHRoYXQgYWZmZWN0IHRoZVxuICogdmFsdWUgd2lsbCB0cmlnZ2VyIHVwZGF0ZXMgdG8gdGhlIGVsZW1lbnQuXG4gKlxuICogSWYgYHZhbHVlYCBpcyBzdXBwbGllZCAoYW5kIG5vdCBudWxsL3VuZGVmaW5lZCksIHRoZSByZW5kZXJlZCBlbGVtZW50IHdpbGxcbiAqIG5vdCB0cmlnZ2VyIHVwZGF0ZXMgdG8gdGhlIGVsZW1lbnQuIEluc3RlYWQsIHRoZSBgdmFsdWVgIHByb3AgbXVzdCBjaGFuZ2UgaW5cbiAqIG9yZGVyIGZvciB0aGUgcmVuZGVyZWQgZWxlbWVudCB0byBiZSB1cGRhdGVkLlxuICpcbiAqIFRoZSByZW5kZXJlZCBlbGVtZW50IHdpbGwgYmUgaW5pdGlhbGl6ZWQgd2l0aCBhbiBlbXB0eSB2YWx1ZSwgdGhlIHByb3BcbiAqIGBkZWZhdWx0VmFsdWVgIGlmIHNwZWNpZmllZCwgb3IgdGhlIGNoaWxkcmVuIGNvbnRlbnQgKGRlcHJlY2F0ZWQpLlxuICovXG5mdW5jdGlvbiBnZXRIb3N0UHJvcHMkMyhlbGVtZW50LCBwcm9wcykge1xuICB2YXIgbm9kZSA9IGVsZW1lbnQ7XG5cbiAgaWYgKCEocHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwgPT0gbnVsbCkpIHtcbiAgICB7XG4gICAgICB0aHJvdyBFcnJvciggXCJgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxgIGRvZXMgbm90IG1ha2Ugc2Vuc2Ugb24gPHRleHRhcmVhPi5cIiApO1xuICAgIH1cbiAgfSAvLyBBbHdheXMgc2V0IGNoaWxkcmVuIHRvIHRoZSBzYW1lIHRoaW5nLiBJbiBJRTksIHRoZSBzZWxlY3Rpb24gcmFuZ2Ugd2lsbFxuICAvLyBnZXQgcmVzZXQgaWYgYHRleHRDb250ZW50YCBpcyBtdXRhdGVkLiAgV2UgY291bGQgYWRkIGEgY2hlY2sgaW4gc2V0VGV4dENvbnRlbnRcbiAgLy8gdG8gb25seSBzZXQgdGhlIHZhbHVlIGlmL3doZW4gdGhlIHZhbHVlIGRpZmZlcnMgZnJvbSB0aGUgbm9kZSB2YWx1ZSAod2hpY2ggd291bGRcbiAgLy8gY29tcGxldGVseSBzb2x2ZSB0aGlzIElFOSBidWcpLCBidXQgU2ViYXN0aWFuK1NvcGhpZSBzZWVtZWQgdG8gbGlrZSB0aGlzXG4gIC8vIHNvbHV0aW9uLiBUaGUgdmFsdWUgY2FuIGJlIGEgYm9vbGVhbiBvciBvYmplY3Qgc28gdGhhdCdzIHdoeSBpdCdzIGZvcmNlZFxuICAvLyB0byBiZSBhIHN0cmluZy5cblxuXG4gIHZhciBob3N0UHJvcHMgPSBfYXNzaWduKHt9LCBwcm9wcywge1xuICAgIHZhbHVlOiB1bmRlZmluZWQsXG4gICAgZGVmYXVsdFZhbHVlOiB1bmRlZmluZWQsXG4gICAgY2hpbGRyZW46IHRvU3RyaW5nKG5vZGUuX3dyYXBwZXJTdGF0ZS5pbml0aWFsVmFsdWUpXG4gIH0pO1xuXG4gIHJldHVybiBob3N0UHJvcHM7XG59XG5mdW5jdGlvbiBpbml0V3JhcHBlclN0YXRlJDIoZWxlbWVudCwgcHJvcHMpIHtcbiAgdmFyIG5vZGUgPSBlbGVtZW50O1xuXG4gIHtcbiAgICBjaGVja0NvbnRyb2xsZWRWYWx1ZVByb3BzKCd0ZXh0YXJlYScsIHByb3BzKTtcblxuICAgIGlmIChwcm9wcy52YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHByb3BzLmRlZmF1bHRWYWx1ZSAhPT0gdW5kZWZpbmVkICYmICFkaWRXYXJuVmFsRGVmYXVsdFZhbCkge1xuICAgICAgZXJyb3IoJyVzIGNvbnRhaW5zIGEgdGV4dGFyZWEgd2l0aCBib3RoIHZhbHVlIGFuZCBkZWZhdWx0VmFsdWUgcHJvcHMuICcgKyAnVGV4dGFyZWEgZWxlbWVudHMgbXVzdCBiZSBlaXRoZXIgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgJyArICcoc3BlY2lmeSBlaXRoZXIgdGhlIHZhbHVlIHByb3AsIG9yIHRoZSBkZWZhdWx0VmFsdWUgcHJvcCwgYnV0IG5vdCAnICsgJ2JvdGgpLiBEZWNpZGUgYmV0d2VlbiB1c2luZyBhIGNvbnRyb2xsZWQgb3IgdW5jb250cm9sbGVkIHRleHRhcmVhICcgKyAnYW5kIHJlbW92ZSBvbmUgb2YgdGhlc2UgcHJvcHMuIE1vcmUgaW5mbzogJyArICdodHRwczovL3JlYWN0anMub3JnL2xpbmsvY29udHJvbGxlZC1jb21wb25lbnRzJywgZ2V0Q3VycmVudEZpYmVyT3duZXJOYW1lSW5EZXZPck51bGwoKSB8fCAnQSBjb21wb25lbnQnKTtcblxuICAgICAgZGlkV2FyblZhbERlZmF1bHRWYWwgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHZhciBpbml0aWFsVmFsdWUgPSBwcm9wcy52YWx1ZTsgLy8gT25seSBib3RoZXIgZmV0Y2hpbmcgZGVmYXVsdCB2YWx1ZSBpZiB3ZSdyZSBnb2luZyB0byB1c2UgaXRcblxuICBpZiAoaW5pdGlhbFZhbHVlID09IG51bGwpIHtcbiAgICB2YXIgY2hpbGRyZW4gPSBwcm9wcy5jaGlsZHJlbixcbiAgICAgICAgZGVmYXVsdFZhbHVlID0gcHJvcHMuZGVmYXVsdFZhbHVlO1xuXG4gICAgaWYgKGNoaWxkcmVuICE9IG51bGwpIHtcbiAgICAgIHtcbiAgICAgICAgZXJyb3IoJ1VzZSB0aGUgYGRlZmF1bHRWYWx1ZWAgb3IgYHZhbHVlYCBwcm9wcyBpbnN0ZWFkIG9mIHNldHRpbmcgJyArICdjaGlsZHJlbiBvbiA8dGV4dGFyZWE+LicpO1xuICAgICAgfVxuXG4gICAgICB7XG4gICAgICAgIGlmICghKGRlZmF1bHRWYWx1ZSA9PSBudWxsKSkge1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKCBcIklmIHlvdSBzdXBwbHkgYGRlZmF1bHRWYWx1ZWAgb24gYSA8dGV4dGFyZWE+LCBkbyBub3QgcGFzcyBjaGlsZHJlbi5cIiApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuKSkge1xuICAgICAgICAgIGlmICghKGNoaWxkcmVuLmxlbmd0aCA8PSAxKSkge1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICB0aHJvdyBFcnJvciggXCI8dGV4dGFyZWE+IGNhbiBvbmx5IGhhdmUgYXQgbW9zdCBvbmUgY2hpbGQuXCIgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjaGlsZHJlbiA9IGNoaWxkcmVuWzBdO1xuICAgICAgICB9XG5cbiAgICAgICAgZGVmYXVsdFZhbHVlID0gY2hpbGRyZW47XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGRlZmF1bHRWYWx1ZSA9PSBudWxsKSB7XG4gICAgICBkZWZhdWx0VmFsdWUgPSAnJztcbiAgICB9XG5cbiAgICBpbml0aWFsVmFsdWUgPSBkZWZhdWx0VmFsdWU7XG4gIH1cblxuICBub2RlLl93cmFwcGVyU3RhdGUgPSB7XG4gICAgaW5pdGlhbFZhbHVlOiBnZXRUb1N0cmluZ1ZhbHVlKGluaXRpYWxWYWx1ZSlcbiAgfTtcbn1cbmZ1bmN0aW9uIHVwZGF0ZVdyYXBwZXIkMShlbGVtZW50LCBwcm9wcykge1xuICB2YXIgbm9kZSA9IGVsZW1lbnQ7XG4gIHZhciB2YWx1ZSA9IGdldFRvU3RyaW5nVmFsdWUocHJvcHMudmFsdWUpO1xuICB2YXIgZGVmYXVsdFZhbHVlID0gZ2V0VG9TdHJpbmdWYWx1ZShwcm9wcy5kZWZhdWx0VmFsdWUpO1xuXG4gIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgLy8gQ2FzdCBgdmFsdWVgIHRvIGEgc3RyaW5nIHRvIGVuc3VyZSB0aGUgdmFsdWUgaXMgc2V0IGNvcnJlY3RseS4gV2hpbGVcbiAgICAvLyBicm93c2VycyB0eXBpY2FsbHkgZG8gdGhpcyBhcyBuZWNlc3NhcnksIGpzZG9tIGRvZXNuJ3QuXG4gICAgdmFyIG5ld1ZhbHVlID0gdG9TdHJpbmcodmFsdWUpOyAvLyBUbyBhdm9pZCBzaWRlIGVmZmVjdHMgKHN1Y2ggYXMgbG9zaW5nIHRleHQgc2VsZWN0aW9uKSwgb25seSBzZXQgdmFsdWUgaWYgY2hhbmdlZFxuXG4gICAgaWYgKG5ld1ZhbHVlICE9PSBub2RlLnZhbHVlKSB7XG4gICAgICBub2RlLnZhbHVlID0gbmV3VmFsdWU7XG4gICAgfVxuXG4gICAgaWYgKHByb3BzLmRlZmF1bHRWYWx1ZSA9PSBudWxsICYmIG5vZGUuZGVmYXVsdFZhbHVlICE9PSBuZXdWYWx1ZSkge1xuICAgICAgbm9kZS5kZWZhdWx0VmFsdWUgPSBuZXdWYWx1ZTtcbiAgICB9XG4gIH1cblxuICBpZiAoZGVmYXVsdFZhbHVlICE9IG51bGwpIHtcbiAgICBub2RlLmRlZmF1bHRWYWx1ZSA9IHRvU3RyaW5nKGRlZmF1bHRWYWx1ZSk7XG4gIH1cbn1cbmZ1bmN0aW9uIHBvc3RNb3VudFdyYXBwZXIkMyhlbGVtZW50LCBwcm9wcykge1xuICB2YXIgbm9kZSA9IGVsZW1lbnQ7IC8vIFRoaXMgaXMgaW4gcG9zdE1vdW50IGJlY2F1c2Ugd2UgbmVlZCBhY2Nlc3MgdG8gdGhlIERPTSBub2RlLCB3aGljaCBpcyBub3RcbiAgLy8gYXZhaWxhYmxlIHVudGlsIGFmdGVyIHRoZSBjb21wb25lbnQgaGFzIG1vdW50ZWQuXG5cbiAgdmFyIHRleHRDb250ZW50ID0gbm9kZS50ZXh0Q29udGVudDsgLy8gT25seSBzZXQgbm9kZS52YWx1ZSBpZiB0ZXh0Q29udGVudCBpcyBlcXVhbCB0byB0aGUgZXhwZWN0ZWRcbiAgLy8gaW5pdGlhbCB2YWx1ZS4gSW4gSUUxMC9JRTExIHRoZXJlIGlzIGEgYnVnIHdoZXJlIHRoZSBwbGFjZWhvbGRlciBhdHRyaWJ1dGVcbiAgLy8gd2lsbCBwb3B1bGF0ZSB0ZXh0Q29udGVudCBhcyB3ZWxsLlxuICAvLyBodHRwczovL2RldmVsb3Blci5taWNyb3NvZnQuY29tL21pY3Jvc29mdC1lZGdlL3BsYXRmb3JtL2lzc3Vlcy8xMDE1MjUvXG5cbiAgaWYgKHRleHRDb250ZW50ID09PSBub2RlLl93cmFwcGVyU3RhdGUuaW5pdGlhbFZhbHVlKSB7XG4gICAgaWYgKHRleHRDb250ZW50ICE9PSAnJyAmJiB0ZXh0Q29udGVudCAhPT0gbnVsbCkge1xuICAgICAgbm9kZS52YWx1ZSA9IHRleHRDb250ZW50O1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gcmVzdG9yZUNvbnRyb2xsZWRTdGF0ZSQyKGVsZW1lbnQsIHByb3BzKSB7XG4gIC8vIERPTSBjb21wb25lbnQgaXMgc3RpbGwgbW91bnRlZDsgdXBkYXRlXG4gIHVwZGF0ZVdyYXBwZXIkMShlbGVtZW50LCBwcm9wcyk7XG59XG5cbnZhciBIVE1MX05BTUVTUEFDRSA9ICdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sJztcbnZhciBNQVRIX05BTUVTUEFDRSA9ICdodHRwOi8vd3d3LnczLm9yZy8xOTk4L01hdGgvTWF0aE1MJztcbnZhciBTVkdfTkFNRVNQQUNFID0gJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJztcbnZhciBOYW1lc3BhY2VzID0ge1xuICBodG1sOiBIVE1MX05BTUVTUEFDRSxcbiAgbWF0aG1sOiBNQVRIX05BTUVTUEFDRSxcbiAgc3ZnOiBTVkdfTkFNRVNQQUNFXG59OyAvLyBBc3N1bWVzIHRoZXJlIGlzIG5vIHBhcmVudCBuYW1lc3BhY2UuXG5cbmZ1bmN0aW9uIGdldEludHJpbnNpY05hbWVzcGFjZSh0eXBlKSB7XG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgJ3N2Zyc6XG4gICAgICByZXR1cm4gU1ZHX05BTUVTUEFDRTtcblxuICAgIGNhc2UgJ21hdGgnOlxuICAgICAgcmV0dXJuIE1BVEhfTkFNRVNQQUNFO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBIVE1MX05BTUVTUEFDRTtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0Q2hpbGROYW1lc3BhY2UocGFyZW50TmFtZXNwYWNlLCB0eXBlKSB7XG4gIGlmIChwYXJlbnROYW1lc3BhY2UgPT0gbnVsbCB8fCBwYXJlbnROYW1lc3BhY2UgPT09IEhUTUxfTkFNRVNQQUNFKSB7XG4gICAgLy8gTm8gKG9yIGRlZmF1bHQpIHBhcmVudCBuYW1lc3BhY2U6IHBvdGVudGlhbCBlbnRyeSBwb2ludC5cbiAgICByZXR1cm4gZ2V0SW50cmluc2ljTmFtZXNwYWNlKHR5cGUpO1xuICB9XG5cbiAgaWYgKHBhcmVudE5hbWVzcGFjZSA9PT0gU1ZHX05BTUVTUEFDRSAmJiB0eXBlID09PSAnZm9yZWlnbk9iamVjdCcpIHtcbiAgICAvLyBXZSdyZSBsZWF2aW5nIFNWRy5cbiAgICByZXR1cm4gSFRNTF9OQU1FU1BBQ0U7XG4gIH0gLy8gQnkgZGVmYXVsdCwgcGFzcyBuYW1lc3BhY2UgYmVsb3cuXG5cblxuICByZXR1cm4gcGFyZW50TmFtZXNwYWNlO1xufVxuXG4vKiBnbG9iYWxzIE1TQXBwICovXG5cbi8qKlxuICogQ3JlYXRlIGEgZnVuY3Rpb24gd2hpY2ggaGFzICd1bnNhZmUnIHByaXZpbGVnZXMgKHJlcXVpcmVkIGJ5IHdpbmRvd3M4IGFwcHMpXG4gKi9cbnZhciBjcmVhdGVNaWNyb3NvZnRVbnNhZmVMb2NhbEZ1bmN0aW9uID0gZnVuY3Rpb24gKGZ1bmMpIHtcbiAgaWYgKHR5cGVvZiBNU0FwcCAhPT0gJ3VuZGVmaW5lZCcgJiYgTVNBcHAuZXhlY1Vuc2FmZUxvY2FsRnVuY3Rpb24pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGFyZzAsIGFyZzEsIGFyZzIsIGFyZzMpIHtcbiAgICAgIE1TQXBwLmV4ZWNVbnNhZmVMb2NhbEZ1bmN0aW9uKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmMoYXJnMCwgYXJnMSwgYXJnMiwgYXJnMyk7XG4gICAgICB9KTtcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBmdW5jO1xuICB9XG59O1xuXG52YXIgcmV1c2FibGVTVkdDb250YWluZXI7XG4vKipcbiAqIFNldCB0aGUgaW5uZXJIVE1MIHByb3BlcnR5IG9mIGEgbm9kZVxuICpcbiAqIEBwYXJhbSB7RE9NRWxlbWVudH0gbm9kZVxuICogQHBhcmFtIHtzdHJpbmd9IGh0bWxcbiAqIEBpbnRlcm5hbFxuICovXG5cbnZhciBzZXRJbm5lckhUTUwgPSBjcmVhdGVNaWNyb3NvZnRVbnNhZmVMb2NhbEZ1bmN0aW9uKGZ1bmN0aW9uIChub2RlLCBodG1sKSB7XG4gIGlmIChub2RlLm5hbWVzcGFjZVVSSSA9PT0gTmFtZXNwYWNlcy5zdmcpIHtcblxuICAgIGlmICghKCdpbm5lckhUTUwnIGluIG5vZGUpKSB7XG4gICAgICAvLyBJRSBkb2VzIG5vdCBoYXZlIGlubmVySFRNTCBmb3IgU1ZHIG5vZGVzLCBzbyBpbnN0ZWFkIHdlIGluamVjdCB0aGVcbiAgICAgIC8vIG5ldyBtYXJrdXAgaW4gYSB0ZW1wIG5vZGUgYW5kIHRoZW4gbW92ZSB0aGUgY2hpbGQgbm9kZXMgYWNyb3NzIGludG9cbiAgICAgIC8vIHRoZSB0YXJnZXQgbm9kZVxuICAgICAgcmV1c2FibGVTVkdDb250YWluZXIgPSByZXVzYWJsZVNWR0NvbnRhaW5lciB8fCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIHJldXNhYmxlU1ZHQ29udGFpbmVyLmlubmVySFRNTCA9ICc8c3ZnPicgKyBodG1sLnZhbHVlT2YoKS50b1N0cmluZygpICsgJzwvc3ZnPic7XG4gICAgICB2YXIgc3ZnTm9kZSA9IHJldXNhYmxlU1ZHQ29udGFpbmVyLmZpcnN0Q2hpbGQ7XG5cbiAgICAgIHdoaWxlIChub2RlLmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgbm9kZS5yZW1vdmVDaGlsZChub2RlLmZpcnN0Q2hpbGQpO1xuICAgICAgfVxuXG4gICAgICB3aGlsZSAoc3ZnTm9kZS5maXJzdENoaWxkKSB7XG4gICAgICAgIG5vZGUuYXBwZW5kQ2hpbGQoc3ZnTm9kZS5maXJzdENoaWxkKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuXG4gIG5vZGUuaW5uZXJIVE1MID0gaHRtbDtcbn0pO1xuXG4vKipcbiAqIEhUTUwgbm9kZVR5cGUgdmFsdWVzIHRoYXQgcmVwcmVzZW50IHRoZSB0eXBlIG9mIHRoZSBub2RlXG4gKi9cbnZhciBFTEVNRU5UX05PREUgPSAxO1xudmFyIFRFWFRfTk9ERSA9IDM7XG52YXIgQ09NTUVOVF9OT0RFID0gODtcbnZhciBET0NVTUVOVF9OT0RFID0gOTtcbnZhciBET0NVTUVOVF9GUkFHTUVOVF9OT0RFID0gMTE7XG5cbi8qKlxuICogU2V0IHRoZSB0ZXh0Q29udGVudCBwcm9wZXJ0eSBvZiBhIG5vZGUuIEZvciB0ZXh0IHVwZGF0ZXMsIGl0J3MgZmFzdGVyXG4gKiB0byBzZXQgdGhlIGBub2RlVmFsdWVgIG9mIHRoZSBUZXh0IG5vZGUgZGlyZWN0bHkgaW5zdGVhZCBvZiB1c2luZ1xuICogYC50ZXh0Q29udGVudGAgd2hpY2ggd2lsbCByZW1vdmUgdGhlIGV4aXN0aW5nIG5vZGUgYW5kIGNyZWF0ZSBhIG5ldyBvbmUuXG4gKlxuICogQHBhcmFtIHtET01FbGVtZW50fSBub2RlXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dFxuICogQGludGVybmFsXG4gKi9cblxudmFyIHNldFRleHRDb250ZW50ID0gZnVuY3Rpb24gKG5vZGUsIHRleHQpIHtcbiAgaWYgKHRleHQpIHtcbiAgICB2YXIgZmlyc3RDaGlsZCA9IG5vZGUuZmlyc3RDaGlsZDtcblxuICAgIGlmIChmaXJzdENoaWxkICYmIGZpcnN0Q2hpbGQgPT09IG5vZGUubGFzdENoaWxkICYmIGZpcnN0Q2hpbGQubm9kZVR5cGUgPT09IFRFWFRfTk9ERSkge1xuICAgICAgZmlyc3RDaGlsZC5ub2RlVmFsdWUgPSB0ZXh0O1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuXG4gIG5vZGUudGV4dENvbnRlbnQgPSB0ZXh0O1xufTtcblxuLy8gTGlzdCBkZXJpdmVkIGZyb20gR2Vja28gc291cmNlIGNvZGU6XG4vLyBodHRwczovL2dpdGh1Yi5jb20vbW96aWxsYS9nZWNrby1kZXYvYmxvYi80ZTYzOGVmYzcxL2xheW91dC9zdHlsZS90ZXN0L3Byb3BlcnR5X2RhdGFiYXNlLmpzXG52YXIgc2hvcnRoYW5kVG9Mb25naGFuZCA9IHtcbiAgYW5pbWF0aW9uOiBbJ2FuaW1hdGlvbkRlbGF5JywgJ2FuaW1hdGlvbkRpcmVjdGlvbicsICdhbmltYXRpb25EdXJhdGlvbicsICdhbmltYXRpb25GaWxsTW9kZScsICdhbmltYXRpb25JdGVyYXRpb25Db3VudCcsICdhbmltYXRpb25OYW1lJywgJ2FuaW1hdGlvblBsYXlTdGF0ZScsICdhbmltYXRpb25UaW1pbmdGdW5jdGlvbiddLFxuICBiYWNrZ3JvdW5kOiBbJ2JhY2tncm91bmRBdHRhY2htZW50JywgJ2JhY2tncm91bmRDbGlwJywgJ2JhY2tncm91bmRDb2xvcicsICdiYWNrZ3JvdW5kSW1hZ2UnLCAnYmFja2dyb3VuZE9yaWdpbicsICdiYWNrZ3JvdW5kUG9zaXRpb25YJywgJ2JhY2tncm91bmRQb3NpdGlvblknLCAnYmFja2dyb3VuZFJlcGVhdCcsICdiYWNrZ3JvdW5kU2l6ZSddLFxuICBiYWNrZ3JvdW5kUG9zaXRpb246IFsnYmFja2dyb3VuZFBvc2l0aW9uWCcsICdiYWNrZ3JvdW5kUG9zaXRpb25ZJ10sXG4gIGJvcmRlcjogWydib3JkZXJCb3R0b21Db2xvcicsICdib3JkZXJCb3R0b21TdHlsZScsICdib3JkZXJCb3R0b21XaWR0aCcsICdib3JkZXJJbWFnZU91dHNldCcsICdib3JkZXJJbWFnZVJlcGVhdCcsICdib3JkZXJJbWFnZVNsaWNlJywgJ2JvcmRlckltYWdlU291cmNlJywgJ2JvcmRlckltYWdlV2lkdGgnLCAnYm9yZGVyTGVmdENvbG9yJywgJ2JvcmRlckxlZnRTdHlsZScsICdib3JkZXJMZWZ0V2lkdGgnLCAnYm9yZGVyUmlnaHRDb2xvcicsICdib3JkZXJSaWdodFN0eWxlJywgJ2JvcmRlclJpZ2h0V2lkdGgnLCAnYm9yZGVyVG9wQ29sb3InLCAnYm9yZGVyVG9wU3R5bGUnLCAnYm9yZGVyVG9wV2lkdGgnXSxcbiAgYm9yZGVyQmxvY2tFbmQ6IFsnYm9yZGVyQmxvY2tFbmRDb2xvcicsICdib3JkZXJCbG9ja0VuZFN0eWxlJywgJ2JvcmRlckJsb2NrRW5kV2lkdGgnXSxcbiAgYm9yZGVyQmxvY2tTdGFydDogWydib3JkZXJCbG9ja1N0YXJ0Q29sb3InLCAnYm9yZGVyQmxvY2tTdGFydFN0eWxlJywgJ2JvcmRlckJsb2NrU3RhcnRXaWR0aCddLFxuICBib3JkZXJCb3R0b206IFsnYm9yZGVyQm90dG9tQ29sb3InLCAnYm9yZGVyQm90dG9tU3R5bGUnLCAnYm9yZGVyQm90dG9tV2lkdGgnXSxcbiAgYm9yZGVyQ29sb3I6IFsnYm9yZGVyQm90dG9tQ29sb3InLCAnYm9yZGVyTGVmdENvbG9yJywgJ2JvcmRlclJpZ2h0Q29sb3InLCAnYm9yZGVyVG9wQ29sb3InXSxcbiAgYm9yZGVySW1hZ2U6IFsnYm9yZGVySW1hZ2VPdXRzZXQnLCAnYm9yZGVySW1hZ2VSZXBlYXQnLCAnYm9yZGVySW1hZ2VTbGljZScsICdib3JkZXJJbWFnZVNvdXJjZScsICdib3JkZXJJbWFnZVdpZHRoJ10sXG4gIGJvcmRlcklubGluZUVuZDogWydib3JkZXJJbmxpbmVFbmRDb2xvcicsICdib3JkZXJJbmxpbmVFbmRTdHlsZScsICdib3JkZXJJbmxpbmVFbmRXaWR0aCddLFxuICBib3JkZXJJbmxpbmVTdGFydDogWydib3JkZXJJbmxpbmVTdGFydENvbG9yJywgJ2JvcmRlcklubGluZVN0YXJ0U3R5bGUnLCAnYm9yZGVySW5saW5lU3RhcnRXaWR0aCddLFxuICBib3JkZXJMZWZ0OiBbJ2JvcmRlckxlZnRDb2xvcicsICdib3JkZXJMZWZ0U3R5bGUnLCAnYm9yZGVyTGVmdFdpZHRoJ10sXG4gIGJvcmRlclJhZGl1czogWydib3JkZXJCb3R0b21MZWZ0UmFkaXVzJywgJ2JvcmRlckJvdHRvbVJpZ2h0UmFkaXVzJywgJ2JvcmRlclRvcExlZnRSYWRpdXMnLCAnYm9yZGVyVG9wUmlnaHRSYWRpdXMnXSxcbiAgYm9yZGVyUmlnaHQ6IFsnYm9yZGVyUmlnaHRDb2xvcicsICdib3JkZXJSaWdodFN0eWxlJywgJ2JvcmRlclJpZ2h0V2lkdGgnXSxcbiAgYm9yZGVyU3R5bGU6IFsnYm9yZGVyQm90dG9tU3R5bGUnLCAnYm9yZGVyTGVmdFN0eWxlJywgJ2JvcmRlclJpZ2h0U3R5bGUnLCAnYm9yZGVyVG9wU3R5bGUnXSxcbiAgYm9yZGVyVG9wOiBbJ2JvcmRlclRvcENvbG9yJywgJ2JvcmRlclRvcFN0eWxlJywgJ2JvcmRlclRvcFdpZHRoJ10sXG4gIGJvcmRlcldpZHRoOiBbJ2JvcmRlckJvdHRvbVdpZHRoJywgJ2JvcmRlckxlZnRXaWR0aCcsICdib3JkZXJSaWdodFdpZHRoJywgJ2JvcmRlclRvcFdpZHRoJ10sXG4gIGNvbHVtblJ1bGU6IFsnY29sdW1uUnVsZUNvbG9yJywgJ2NvbHVtblJ1bGVTdHlsZScsICdjb2x1bW5SdWxlV2lkdGgnXSxcbiAgY29sdW1uczogWydjb2x1bW5Db3VudCcsICdjb2x1bW5XaWR0aCddLFxuICBmbGV4OiBbJ2ZsZXhCYXNpcycsICdmbGV4R3JvdycsICdmbGV4U2hyaW5rJ10sXG4gIGZsZXhGbG93OiBbJ2ZsZXhEaXJlY3Rpb24nLCAnZmxleFdyYXAnXSxcbiAgZm9udDogWydmb250RmFtaWx5JywgJ2ZvbnRGZWF0dXJlU2V0dGluZ3MnLCAnZm9udEtlcm5pbmcnLCAnZm9udExhbmd1YWdlT3ZlcnJpZGUnLCAnZm9udFNpemUnLCAnZm9udFNpemVBZGp1c3QnLCAnZm9udFN0cmV0Y2gnLCAnZm9udFN0eWxlJywgJ2ZvbnRWYXJpYW50JywgJ2ZvbnRWYXJpYW50QWx0ZXJuYXRlcycsICdmb250VmFyaWFudENhcHMnLCAnZm9udFZhcmlhbnRFYXN0QXNpYW4nLCAnZm9udFZhcmlhbnRMaWdhdHVyZXMnLCAnZm9udFZhcmlhbnROdW1lcmljJywgJ2ZvbnRWYXJpYW50UG9zaXRpb24nLCAnZm9udFdlaWdodCcsICdsaW5lSGVpZ2h0J10sXG4gIGZvbnRWYXJpYW50OiBbJ2ZvbnRWYXJpYW50QWx0ZXJuYXRlcycsICdmb250VmFyaWFudENhcHMnLCAnZm9udFZhcmlhbnRFYXN0QXNpYW4nLCAnZm9udFZhcmlhbnRMaWdhdHVyZXMnLCAnZm9udFZhcmlhbnROdW1lcmljJywgJ2ZvbnRWYXJpYW50UG9zaXRpb24nXSxcbiAgZ2FwOiBbJ2NvbHVtbkdhcCcsICdyb3dHYXAnXSxcbiAgZ3JpZDogWydncmlkQXV0b0NvbHVtbnMnLCAnZ3JpZEF1dG9GbG93JywgJ2dyaWRBdXRvUm93cycsICdncmlkVGVtcGxhdGVBcmVhcycsICdncmlkVGVtcGxhdGVDb2x1bW5zJywgJ2dyaWRUZW1wbGF0ZVJvd3MnXSxcbiAgZ3JpZEFyZWE6IFsnZ3JpZENvbHVtbkVuZCcsICdncmlkQ29sdW1uU3RhcnQnLCAnZ3JpZFJvd0VuZCcsICdncmlkUm93U3RhcnQnXSxcbiAgZ3JpZENvbHVtbjogWydncmlkQ29sdW1uRW5kJywgJ2dyaWRDb2x1bW5TdGFydCddLFxuICBncmlkQ29sdW1uR2FwOiBbJ2NvbHVtbkdhcCddLFxuICBncmlkR2FwOiBbJ2NvbHVtbkdhcCcsICdyb3dHYXAnXSxcbiAgZ3JpZFJvdzogWydncmlkUm93RW5kJywgJ2dyaWRSb3dTdGFydCddLFxuICBncmlkUm93R2FwOiBbJ3Jvd0dhcCddLFxuICBncmlkVGVtcGxhdGU6IFsnZ3JpZFRlbXBsYXRlQXJlYXMnLCAnZ3JpZFRlbXBsYXRlQ29sdW1ucycsICdncmlkVGVtcGxhdGVSb3dzJ10sXG4gIGxpc3RTdHlsZTogWydsaXN0U3R5bGVJbWFnZScsICdsaXN0U3R5bGVQb3NpdGlvbicsICdsaXN0U3R5bGVUeXBlJ10sXG4gIG1hcmdpbjogWydtYXJnaW5Cb3R0b20nLCAnbWFyZ2luTGVmdCcsICdtYXJnaW5SaWdodCcsICdtYXJnaW5Ub3AnXSxcbiAgbWFya2VyOiBbJ21hcmtlckVuZCcsICdtYXJrZXJNaWQnLCAnbWFya2VyU3RhcnQnXSxcbiAgbWFzazogWydtYXNrQ2xpcCcsICdtYXNrQ29tcG9zaXRlJywgJ21hc2tJbWFnZScsICdtYXNrTW9kZScsICdtYXNrT3JpZ2luJywgJ21hc2tQb3NpdGlvblgnLCAnbWFza1Bvc2l0aW9uWScsICdtYXNrUmVwZWF0JywgJ21hc2tTaXplJ10sXG4gIG1hc2tQb3NpdGlvbjogWydtYXNrUG9zaXRpb25YJywgJ21hc2tQb3NpdGlvblknXSxcbiAgb3V0bGluZTogWydvdXRsaW5lQ29sb3InLCAnb3V0bGluZVN0eWxlJywgJ291dGxpbmVXaWR0aCddLFxuICBvdmVyZmxvdzogWydvdmVyZmxvd1gnLCAnb3ZlcmZsb3dZJ10sXG4gIHBhZGRpbmc6IFsncGFkZGluZ0JvdHRvbScsICdwYWRkaW5nTGVmdCcsICdwYWRkaW5nUmlnaHQnLCAncGFkZGluZ1RvcCddLFxuICBwbGFjZUNvbnRlbnQ6IFsnYWxpZ25Db250ZW50JywgJ2p1c3RpZnlDb250ZW50J10sXG4gIHBsYWNlSXRlbXM6IFsnYWxpZ25JdGVtcycsICdqdXN0aWZ5SXRlbXMnXSxcbiAgcGxhY2VTZWxmOiBbJ2FsaWduU2VsZicsICdqdXN0aWZ5U2VsZiddLFxuICB0ZXh0RGVjb3JhdGlvbjogWyd0ZXh0RGVjb3JhdGlvbkNvbG9yJywgJ3RleHREZWNvcmF0aW9uTGluZScsICd0ZXh0RGVjb3JhdGlvblN0eWxlJ10sXG4gIHRleHRFbXBoYXNpczogWyd0ZXh0RW1waGFzaXNDb2xvcicsICd0ZXh0RW1waGFzaXNTdHlsZSddLFxuICB0cmFuc2l0aW9uOiBbJ3RyYW5zaXRpb25EZWxheScsICd0cmFuc2l0aW9uRHVyYXRpb24nLCAndHJhbnNpdGlvblByb3BlcnR5JywgJ3RyYW5zaXRpb25UaW1pbmdGdW5jdGlvbiddLFxuICB3b3JkV3JhcDogWydvdmVyZmxvd1dyYXAnXVxufTtcblxuLyoqXG4gKiBDU1MgcHJvcGVydGllcyB3aGljaCBhY2NlcHQgbnVtYmVycyBidXQgYXJlIG5vdCBpbiB1bml0cyBvZiBcInB4XCIuXG4gKi9cbnZhciBpc1VuaXRsZXNzTnVtYmVyID0ge1xuICBhbmltYXRpb25JdGVyYXRpb25Db3VudDogdHJ1ZSxcbiAgYm9yZGVySW1hZ2VPdXRzZXQ6IHRydWUsXG4gIGJvcmRlckltYWdlU2xpY2U6IHRydWUsXG4gIGJvcmRlckltYWdlV2lkdGg6IHRydWUsXG4gIGJveEZsZXg6IHRydWUsXG4gIGJveEZsZXhHcm91cDogdHJ1ZSxcbiAgYm94T3JkaW5hbEdyb3VwOiB0cnVlLFxuICBjb2x1bW5Db3VudDogdHJ1ZSxcbiAgY29sdW1uczogdHJ1ZSxcbiAgZmxleDogdHJ1ZSxcbiAgZmxleEdyb3c6IHRydWUsXG4gIGZsZXhQb3NpdGl2ZTogdHJ1ZSxcbiAgZmxleFNocmluazogdHJ1ZSxcbiAgZmxleE5lZ2F0aXZlOiB0cnVlLFxuICBmbGV4T3JkZXI6IHRydWUsXG4gIGdyaWRBcmVhOiB0cnVlLFxuICBncmlkUm93OiB0cnVlLFxuICBncmlkUm93RW5kOiB0cnVlLFxuICBncmlkUm93U3BhbjogdHJ1ZSxcbiAgZ3JpZFJvd1N0YXJ0OiB0cnVlLFxuICBncmlkQ29sdW1uOiB0cnVlLFxuICBncmlkQ29sdW1uRW5kOiB0cnVlLFxuICBncmlkQ29sdW1uU3BhbjogdHJ1ZSxcbiAgZ3JpZENvbHVtblN0YXJ0OiB0cnVlLFxuICBmb250V2VpZ2h0OiB0cnVlLFxuICBsaW5lQ2xhbXA6IHRydWUsXG4gIGxpbmVIZWlnaHQ6IHRydWUsXG4gIG9wYWNpdHk6IHRydWUsXG4gIG9yZGVyOiB0cnVlLFxuICBvcnBoYW5zOiB0cnVlLFxuICB0YWJTaXplOiB0cnVlLFxuICB3aWRvd3M6IHRydWUsXG4gIHpJbmRleDogdHJ1ZSxcbiAgem9vbTogdHJ1ZSxcbiAgLy8gU1ZHLXJlbGF0ZWQgcHJvcGVydGllc1xuICBmaWxsT3BhY2l0eTogdHJ1ZSxcbiAgZmxvb2RPcGFjaXR5OiB0cnVlLFxuICBzdG9wT3BhY2l0eTogdHJ1ZSxcbiAgc3Ryb2tlRGFzaGFycmF5OiB0cnVlLFxuICBzdHJva2VEYXNob2Zmc2V0OiB0cnVlLFxuICBzdHJva2VNaXRlcmxpbWl0OiB0cnVlLFxuICBzdHJva2VPcGFjaXR5OiB0cnVlLFxuICBzdHJva2VXaWR0aDogdHJ1ZVxufTtcbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHByZWZpeCB2ZW5kb3Itc3BlY2lmaWMgcHJlZml4LCBlZzogV2Via2l0XG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IHN0eWxlIG5hbWUsIGVnOiB0cmFuc2l0aW9uRHVyYXRpb25cbiAqIEByZXR1cm4ge3N0cmluZ30gc3R5bGUgbmFtZSBwcmVmaXhlZCB3aXRoIGBwcmVmaXhgLCBwcm9wZXJseSBjYW1lbENhc2VkLCBlZzpcbiAqIFdlYmtpdFRyYW5zaXRpb25EdXJhdGlvblxuICovXG5cbmZ1bmN0aW9uIHByZWZpeEtleShwcmVmaXgsIGtleSkge1xuICByZXR1cm4gcHJlZml4ICsga2V5LmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsga2V5LnN1YnN0cmluZygxKTtcbn1cbi8qKlxuICogU3VwcG9ydCBzdHlsZSBuYW1lcyB0aGF0IG1heSBjb21lIHBhc3NlZCBpbiBwcmVmaXhlZCBieSBhZGRpbmcgcGVybXV0YXRpb25zXG4gKiBvZiB2ZW5kb3IgcHJlZml4ZXMuXG4gKi9cblxuXG52YXIgcHJlZml4ZXMgPSBbJ1dlYmtpdCcsICdtcycsICdNb3onLCAnTyddOyAvLyBVc2luZyBPYmplY3Qua2V5cyBoZXJlLCBvciBlbHNlIHRoZSB2YW5pbGxhIGZvci1pbiBsb29wIG1ha2VzIElFOCBnbyBpbnRvIGFuXG4vLyBpbmZpbml0ZSBsb29wLCBiZWNhdXNlIGl0IGl0ZXJhdGVzIG92ZXIgdGhlIG5ld2x5IGFkZGVkIHByb3BzIHRvby5cblxuT2JqZWN0LmtleXMoaXNVbml0bGVzc051bWJlcikuZm9yRWFjaChmdW5jdGlvbiAocHJvcCkge1xuICBwcmVmaXhlcy5mb3JFYWNoKGZ1bmN0aW9uIChwcmVmaXgpIHtcbiAgICBpc1VuaXRsZXNzTnVtYmVyW3ByZWZpeEtleShwcmVmaXgsIHByb3ApXSA9IGlzVW5pdGxlc3NOdW1iZXJbcHJvcF07XG4gIH0pO1xufSk7XG5cbi8qKlxuICogQ29udmVydCBhIHZhbHVlIGludG8gdGhlIHByb3BlciBjc3Mgd3JpdGFibGUgdmFsdWUuIFRoZSBzdHlsZSBuYW1lIGBuYW1lYFxuICogc2hvdWxkIGJlIGxvZ2ljYWwgKG5vIGh5cGhlbnMpLCBhcyBzcGVjaWZpZWRcbiAqIGluIGBDU1NQcm9wZXJ0eS5pc1VuaXRsZXNzTnVtYmVyYC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBDU1MgcHJvcGVydHkgbmFtZSBzdWNoIGFzIGB0b3BNYXJnaW5gLlxuICogQHBhcmFtIHsqfSB2YWx1ZSBDU1MgcHJvcGVydHkgdmFsdWUgc3VjaCBhcyBgMTBweGAuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IE5vcm1hbGl6ZWQgc3R5bGUgdmFsdWUgd2l0aCBkaW1lbnNpb25zIGFwcGxpZWQuXG4gKi9cblxuZnVuY3Rpb24gZGFuZ2Vyb3VzU3R5bGVWYWx1ZShuYW1lLCB2YWx1ZSwgaXNDdXN0b21Qcm9wZXJ0eSkge1xuICAvLyBOb3RlIHRoYXQgd2UndmUgcmVtb3ZlZCBlc2NhcGVUZXh0Rm9yQnJvd3NlcigpIGNhbGxzIGhlcmUgc2luY2UgdGhlXG4gIC8vIHdob2xlIHN0cmluZyB3aWxsIGJlIGVzY2FwZWQgd2hlbiB0aGUgYXR0cmlidXRlIGlzIGluamVjdGVkIGludG9cbiAgLy8gdGhlIG1hcmt1cC4gSWYgeW91IHByb3ZpZGUgdW5zYWZlIHVzZXIgZGF0YSBoZXJlIHRoZXkgY2FuIGluamVjdFxuICAvLyBhcmJpdHJhcnkgQ1NTIHdoaWNoIG1heSBiZSBwcm9ibGVtYXRpYyAoSSBjb3VsZG4ndCByZXBybyB0aGlzKTpcbiAgLy8gaHR0cHM6Ly93d3cub3dhc3Aub3JnL2luZGV4LnBocC9YU1NfRmlsdGVyX0V2YXNpb25fQ2hlYXRfU2hlZXRcbiAgLy8gaHR0cDovL3d3dy50aGVzcGFubmVyLmNvLnVrLzIwMDcvMTEvMjYvdWx0aW1hdGUteHNzLWNzcy1pbmplY3Rpb24vXG4gIC8vIFRoaXMgaXMgbm90IGFuIFhTUyBob2xlIGJ1dCBpbnN0ZWFkIGEgcG90ZW50aWFsIENTUyBpbmplY3Rpb24gaXNzdWVcbiAgLy8gd2hpY2ggaGFzIGxlYWQgdG8gYSBncmVhdGVyIGRpc2N1c3Npb24gYWJvdXQgaG93IHdlJ3JlIGdvaW5nIHRvXG4gIC8vIHRydXN0IFVSTHMgbW92aW5nIGZvcndhcmQuIFNlZSAjMjExNTkwMVxuICB2YXIgaXNFbXB0eSA9IHZhbHVlID09IG51bGwgfHwgdHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicgfHwgdmFsdWUgPT09ICcnO1xuXG4gIGlmIChpc0VtcHR5KSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgaWYgKCFpc0N1c3RvbVByb3BlcnR5ICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgJiYgdmFsdWUgIT09IDAgJiYgIShpc1VuaXRsZXNzTnVtYmVyLmhhc093blByb3BlcnR5KG5hbWUpICYmIGlzVW5pdGxlc3NOdW1iZXJbbmFtZV0pKSB7XG4gICAgcmV0dXJuIHZhbHVlICsgJ3B4JzsgLy8gUHJlc3VtZXMgaW1wbGljaXQgJ3B4JyBzdWZmaXggZm9yIHVuaXRsZXNzIG51bWJlcnNcbiAgfVxuXG4gIHJldHVybiAoJycgKyB2YWx1ZSkudHJpbSgpO1xufVxuXG52YXIgdXBwZXJjYXNlUGF0dGVybiA9IC8oW0EtWl0pL2c7XG52YXIgbXNQYXR0ZXJuID0gL15tcy0vO1xuLyoqXG4gKiBIeXBoZW5hdGVzIGEgY2FtZWxjYXNlZCBDU1MgcHJvcGVydHkgbmFtZSwgZm9yIGV4YW1wbGU6XG4gKlxuICogICA+IGh5cGhlbmF0ZVN0eWxlTmFtZSgnYmFja2dyb3VuZENvbG9yJylcbiAqICAgPCBcImJhY2tncm91bmQtY29sb3JcIlxuICogICA+IGh5cGhlbmF0ZVN0eWxlTmFtZSgnTW96VHJhbnNpdGlvbicpXG4gKiAgIDwgXCItbW96LXRyYW5zaXRpb25cIlxuICogICA+IGh5cGhlbmF0ZVN0eWxlTmFtZSgnbXNUcmFuc2l0aW9uJylcbiAqICAgPCBcIi1tcy10cmFuc2l0aW9uXCJcbiAqXG4gKiBBcyBNb2Rlcm5penIgc3VnZ2VzdHMgKGh0dHA6Ly9tb2Rlcm5penIuY29tL2RvY3MvI3ByZWZpeGVkKSwgYW4gYG1zYCBwcmVmaXhcbiAqIGlzIGNvbnZlcnRlZCB0byBgLW1zLWAuXG4gKi9cblxuZnVuY3Rpb24gaHlwaGVuYXRlU3R5bGVOYW1lKG5hbWUpIHtcbiAgcmV0dXJuIG5hbWUucmVwbGFjZSh1cHBlcmNhc2VQYXR0ZXJuLCAnLSQxJykudG9Mb3dlckNhc2UoKS5yZXBsYWNlKG1zUGF0dGVybiwgJy1tcy0nKTtcbn1cblxudmFyIHdhcm5WYWxpZFN0eWxlID0gZnVuY3Rpb24gKCkge307XG5cbntcbiAgLy8gJ21zVHJhbnNmb3JtJyBpcyBjb3JyZWN0LCBidXQgdGhlIG90aGVyIHByZWZpeGVzIHNob3VsZCBiZSBjYXBpdGFsaXplZFxuICB2YXIgYmFkVmVuZG9yZWRTdHlsZU5hbWVQYXR0ZXJuID0gL14oPzp3ZWJraXR8bW96fG8pW0EtWl0vO1xuICB2YXIgbXNQYXR0ZXJuJDEgPSAvXi1tcy0vO1xuICB2YXIgaHlwaGVuUGF0dGVybiA9IC8tKC4pL2c7IC8vIHN0eWxlIHZhbHVlcyBzaG91bGRuJ3QgY29udGFpbiBhIHNlbWljb2xvblxuXG4gIHZhciBiYWRTdHlsZVZhbHVlV2l0aFNlbWljb2xvblBhdHRlcm4gPSAvO1xccyokLztcbiAgdmFyIHdhcm5lZFN0eWxlTmFtZXMgPSB7fTtcbiAgdmFyIHdhcm5lZFN0eWxlVmFsdWVzID0ge307XG4gIHZhciB3YXJuZWRGb3JOYU5WYWx1ZSA9IGZhbHNlO1xuICB2YXIgd2FybmVkRm9ySW5maW5pdHlWYWx1ZSA9IGZhbHNlO1xuXG4gIHZhciBjYW1lbGl6ZSA9IGZ1bmN0aW9uIChzdHJpbmcpIHtcbiAgICByZXR1cm4gc3RyaW5nLnJlcGxhY2UoaHlwaGVuUGF0dGVybiwgZnVuY3Rpb24gKF8sIGNoYXJhY3Rlcikge1xuICAgICAgcmV0dXJuIGNoYXJhY3Rlci50b1VwcGVyQ2FzZSgpO1xuICAgIH0pO1xuICB9O1xuXG4gIHZhciB3YXJuSHlwaGVuYXRlZFN0eWxlTmFtZSA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgaWYgKHdhcm5lZFN0eWxlTmFtZXMuaGFzT3duUHJvcGVydHkobmFtZSkgJiYgd2FybmVkU3R5bGVOYW1lc1tuYW1lXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHdhcm5lZFN0eWxlTmFtZXNbbmFtZV0gPSB0cnVlO1xuXG4gICAgZXJyb3IoJ1Vuc3VwcG9ydGVkIHN0eWxlIHByb3BlcnR5ICVzLiBEaWQgeW91IG1lYW4gJXM/JywgbmFtZSwgLy8gQXMgQW5kaSBTbWl0aCBzdWdnZXN0c1xuICAgIC8vIChodHRwOi8vd3d3LmFuZGlzbWl0aC5jb20vYmxvZy8yMDEyLzAyL21vZGVybml6ci1wcmVmaXhlZC8pLCBhbiBgLW1zYCBwcmVmaXhcbiAgICAvLyBpcyBjb252ZXJ0ZWQgdG8gbG93ZXJjYXNlIGBtc2AuXG4gICAgY2FtZWxpemUobmFtZS5yZXBsYWNlKG1zUGF0dGVybiQxLCAnbXMtJykpKTtcbiAgfTtcblxuICB2YXIgd2FybkJhZFZlbmRvcmVkU3R5bGVOYW1lID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICBpZiAod2FybmVkU3R5bGVOYW1lcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSAmJiB3YXJuZWRTdHlsZU5hbWVzW25hbWVdKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgd2FybmVkU3R5bGVOYW1lc1tuYW1lXSA9IHRydWU7XG5cbiAgICBlcnJvcignVW5zdXBwb3J0ZWQgdmVuZG9yLXByZWZpeGVkIHN0eWxlIHByb3BlcnR5ICVzLiBEaWQgeW91IG1lYW4gJXM/JywgbmFtZSwgbmFtZS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIG5hbWUuc2xpY2UoMSkpO1xuICB9O1xuXG4gIHZhciB3YXJuU3R5bGVWYWx1ZVdpdGhTZW1pY29sb24gPSBmdW5jdGlvbiAobmFtZSwgdmFsdWUpIHtcbiAgICBpZiAod2FybmVkU3R5bGVWYWx1ZXMuaGFzT3duUHJvcGVydHkodmFsdWUpICYmIHdhcm5lZFN0eWxlVmFsdWVzW3ZhbHVlXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHdhcm5lZFN0eWxlVmFsdWVzW3ZhbHVlXSA9IHRydWU7XG5cbiAgICBlcnJvcihcIlN0eWxlIHByb3BlcnR5IHZhbHVlcyBzaG91bGRuJ3QgY29udGFpbiBhIHNlbWljb2xvbi4gXCIgKyAnVHJ5IFwiJXM6ICVzXCIgaW5zdGVhZC4nLCBuYW1lLCB2YWx1ZS5yZXBsYWNlKGJhZFN0eWxlVmFsdWVXaXRoU2VtaWNvbG9uUGF0dGVybiwgJycpKTtcbiAgfTtcblxuICB2YXIgd2FyblN0eWxlVmFsdWVJc05hTiA9IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkge1xuICAgIGlmICh3YXJuZWRGb3JOYU5WYWx1ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHdhcm5lZEZvck5hTlZhbHVlID0gdHJ1ZTtcblxuICAgIGVycm9yKCdgTmFOYCBpcyBhbiBpbnZhbGlkIHZhbHVlIGZvciB0aGUgYCVzYCBjc3Mgc3R5bGUgcHJvcGVydHkuJywgbmFtZSk7XG4gIH07XG5cbiAgdmFyIHdhcm5TdHlsZVZhbHVlSXNJbmZpbml0eSA9IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkge1xuICAgIGlmICh3YXJuZWRGb3JJbmZpbml0eVZhbHVlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgd2FybmVkRm9ySW5maW5pdHlWYWx1ZSA9IHRydWU7XG5cbiAgICBlcnJvcignYEluZmluaXR5YCBpcyBhbiBpbnZhbGlkIHZhbHVlIGZvciB0aGUgYCVzYCBjc3Mgc3R5bGUgcHJvcGVydHkuJywgbmFtZSk7XG4gIH07XG5cbiAgd2FyblZhbGlkU3R5bGUgPSBmdW5jdGlvbiAobmFtZSwgdmFsdWUpIHtcbiAgICBpZiAobmFtZS5pbmRleE9mKCctJykgPiAtMSkge1xuICAgICAgd2Fybkh5cGhlbmF0ZWRTdHlsZU5hbWUobmFtZSk7XG4gICAgfSBlbHNlIGlmIChiYWRWZW5kb3JlZFN0eWxlTmFtZVBhdHRlcm4udGVzdChuYW1lKSkge1xuICAgICAgd2FybkJhZFZlbmRvcmVkU3R5bGVOYW1lKG5hbWUpO1xuICAgIH0gZWxzZSBpZiAoYmFkU3R5bGVWYWx1ZVdpdGhTZW1pY29sb25QYXR0ZXJuLnRlc3QodmFsdWUpKSB7XG4gICAgICB3YXJuU3R5bGVWYWx1ZVdpdGhTZW1pY29sb24obmFtZSwgdmFsdWUpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgICBpZiAoaXNOYU4odmFsdWUpKSB7XG4gICAgICAgIHdhcm5TdHlsZVZhbHVlSXNOYU4obmFtZSwgdmFsdWUpO1xuICAgICAgfSBlbHNlIGlmICghaXNGaW5pdGUodmFsdWUpKSB7XG4gICAgICAgIHdhcm5TdHlsZVZhbHVlSXNJbmZpbml0eShuYW1lLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xufVxuXG52YXIgd2FyblZhbGlkU3R5bGUkMSA9IHdhcm5WYWxpZFN0eWxlO1xuXG4vKipcbiAqIE9wZXJhdGlvbnMgZm9yIGRlYWxpbmcgd2l0aCBDU1MgcHJvcGVydGllcy5cbiAqL1xuXG4vKipcbiAqIFRoaXMgY3JlYXRlcyBhIHN0cmluZyB0aGF0IGlzIGV4cGVjdGVkIHRvIGJlIGVxdWl2YWxlbnQgdG8gdGhlIHN0eWxlXG4gKiBhdHRyaWJ1dGUgZ2VuZXJhdGVkIGJ5IHNlcnZlci1zaWRlIHJlbmRlcmluZy4gSXQgYnktcGFzc2VzIHdhcm5pbmdzIGFuZFxuICogc2VjdXJpdHkgY2hlY2tzIHNvIGl0J3Mgbm90IHNhZmUgdG8gdXNlIHRoaXMgdmFsdWUgZm9yIGFueXRoaW5nIG90aGVyIHRoYW5cbiAqIGNvbXBhcmlzb24uIEl0IGlzIG9ubHkgdXNlZCBpbiBERVYgZm9yIFNTUiB2YWxpZGF0aW9uLlxuICovXG5cbmZ1bmN0aW9uIGNyZWF0ZURhbmdlcm91c1N0cmluZ0ZvclN0eWxlcyhzdHlsZXMpIHtcbiAge1xuICAgIHZhciBzZXJpYWxpemVkID0gJyc7XG4gICAgdmFyIGRlbGltaXRlciA9ICcnO1xuXG4gICAgZm9yICh2YXIgc3R5bGVOYW1lIGluIHN0eWxlcykge1xuICAgICAgaWYgKCFzdHlsZXMuaGFzT3duUHJvcGVydHkoc3R5bGVOYW1lKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIHN0eWxlVmFsdWUgPSBzdHlsZXNbc3R5bGVOYW1lXTtcblxuICAgICAgaWYgKHN0eWxlVmFsdWUgIT0gbnVsbCkge1xuICAgICAgICB2YXIgaXNDdXN0b21Qcm9wZXJ0eSA9IHN0eWxlTmFtZS5pbmRleE9mKCctLScpID09PSAwO1xuICAgICAgICBzZXJpYWxpemVkICs9IGRlbGltaXRlciArIChpc0N1c3RvbVByb3BlcnR5ID8gc3R5bGVOYW1lIDogaHlwaGVuYXRlU3R5bGVOYW1lKHN0eWxlTmFtZSkpICsgJzonO1xuICAgICAgICBzZXJpYWxpemVkICs9IGRhbmdlcm91c1N0eWxlVmFsdWUoc3R5bGVOYW1lLCBzdHlsZVZhbHVlLCBpc0N1c3RvbVByb3BlcnR5KTtcbiAgICAgICAgZGVsaW1pdGVyID0gJzsnO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBzZXJpYWxpemVkIHx8IG51bGw7XG4gIH1cbn1cbi8qKlxuICogU2V0cyB0aGUgdmFsdWUgZm9yIG11bHRpcGxlIHN0eWxlcyBvbiBhIG5vZGUuICBJZiBhIHZhbHVlIGlzIHNwZWNpZmllZCBhc1xuICogJycgKGVtcHR5IHN0cmluZyksIHRoZSBjb3JyZXNwb25kaW5nIHN0eWxlIHByb3BlcnR5IHdpbGwgYmUgdW5zZXQuXG4gKlxuICogQHBhcmFtIHtET01FbGVtZW50fSBub2RlXG4gKiBAcGFyYW0ge29iamVjdH0gc3R5bGVzXG4gKi9cblxuZnVuY3Rpb24gc2V0VmFsdWVGb3JTdHlsZXMobm9kZSwgc3R5bGVzKSB7XG4gIHZhciBzdHlsZSA9IG5vZGUuc3R5bGU7XG5cbiAgZm9yICh2YXIgc3R5bGVOYW1lIGluIHN0eWxlcykge1xuICAgIGlmICghc3R5bGVzLmhhc093blByb3BlcnR5KHN0eWxlTmFtZSkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHZhciBpc0N1c3RvbVByb3BlcnR5ID0gc3R5bGVOYW1lLmluZGV4T2YoJy0tJykgPT09IDA7XG5cbiAgICB7XG4gICAgICBpZiAoIWlzQ3VzdG9tUHJvcGVydHkpIHtcbiAgICAgICAgd2FyblZhbGlkU3R5bGUkMShzdHlsZU5hbWUsIHN0eWxlc1tzdHlsZU5hbWVdKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgc3R5bGVWYWx1ZSA9IGRhbmdlcm91c1N0eWxlVmFsdWUoc3R5bGVOYW1lLCBzdHlsZXNbc3R5bGVOYW1lXSwgaXNDdXN0b21Qcm9wZXJ0eSk7XG5cbiAgICBpZiAoc3R5bGVOYW1lID09PSAnZmxvYXQnKSB7XG4gICAgICBzdHlsZU5hbWUgPSAnY3NzRmxvYXQnO1xuICAgIH1cblxuICAgIGlmIChpc0N1c3RvbVByb3BlcnR5KSB7XG4gICAgICBzdHlsZS5zZXRQcm9wZXJ0eShzdHlsZU5hbWUsIHN0eWxlVmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdHlsZVtzdHlsZU5hbWVdID0gc3R5bGVWYWx1ZTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNWYWx1ZUVtcHR5KHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA9PSBudWxsIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nIHx8IHZhbHVlID09PSAnJztcbn1cbi8qKlxuICogR2l2ZW4ge2NvbG9yOiAncmVkJywgb3ZlcmZsb3c6ICdoaWRkZW4nfSByZXR1cm5zIHtcbiAqICAgY29sb3I6ICdjb2xvcicsXG4gKiAgIG92ZXJmbG93WDogJ292ZXJmbG93JyxcbiAqICAgb3ZlcmZsb3dZOiAnb3ZlcmZsb3cnLFxuICogfS4gVGhpcyBjYW4gYmUgcmVhZCBhcyBcInRoZSBvdmVyZmxvd1kgcHJvcGVydHkgd2FzIHNldCBieSB0aGUgb3ZlcmZsb3dcbiAqIHNob3J0aGFuZFwiLiBUaGF0IGlzLCB0aGUgdmFsdWVzIGFyZSB0aGUgcHJvcGVydHkgdGhhdCBlYWNoIHdhcyBkZXJpdmVkIGZyb20uXG4gKi9cblxuXG5mdW5jdGlvbiBleHBhbmRTaG9ydGhhbmRNYXAoc3R5bGVzKSB7XG4gIHZhciBleHBhbmRlZCA9IHt9O1xuXG4gIGZvciAodmFyIGtleSBpbiBzdHlsZXMpIHtcbiAgICB2YXIgbG9uZ2hhbmRzID0gc2hvcnRoYW5kVG9Mb25naGFuZFtrZXldIHx8IFtrZXldO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsb25naGFuZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGV4cGFuZGVkW2xvbmdoYW5kc1tpXV0gPSBrZXk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGV4cGFuZGVkO1xufVxuLyoqXG4gKiBXaGVuIG1peGluZyBzaG9ydGhhbmQgYW5kIGxvbmdoYW5kIHByb3BlcnR5IG5hbWVzLCB3ZSB3YXJuIGR1cmluZyB1cGRhdGVzIGlmXG4gKiB3ZSBleHBlY3QgYW4gaW5jb3JyZWN0IHJlc3VsdCB0byBvY2N1ci4gSW4gcGFydGljdWxhciwgd2Ugd2FybiBmb3I6XG4gKlxuICogVXBkYXRpbmcgYSBzaG9ydGhhbmQgcHJvcGVydHkgKGxvbmdoYW5kIGdldHMgb3ZlcndyaXR0ZW4pOlxuICogICB7Zm9udDogJ2ZvbycsIGZvbnRWYXJpYW50OiAnYmFyJ30gLT4ge2ZvbnQ6ICdiYXonLCBmb250VmFyaWFudDogJ2Jhcid9XG4gKiAgIGJlY29tZXMgLnN0eWxlLmZvbnQgPSAnYmF6J1xuICogUmVtb3ZpbmcgYSBzaG9ydGhhbmQgcHJvcGVydHkgKGxvbmdoYW5kIGdldHMgbG9zdCB0b28pOlxuICogICB7Zm9udDogJ2ZvbycsIGZvbnRWYXJpYW50OiAnYmFyJ30gLT4ge2ZvbnRWYXJpYW50OiAnYmFyJ31cbiAqICAgYmVjb21lcyAuc3R5bGUuZm9udCA9ICcnXG4gKiBSZW1vdmluZyBhIGxvbmdoYW5kIHByb3BlcnR5IChzaG91bGQgcmV2ZXJ0IHRvIHNob3J0aGFuZDsgZG9lc24ndCk6XG4gKiAgIHtmb250OiAnZm9vJywgZm9udFZhcmlhbnQ6ICdiYXInfSAtPiB7Zm9udDogJ2Zvbyd9XG4gKiAgIGJlY29tZXMgLnN0eWxlLmZvbnRWYXJpYW50ID0gJydcbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlU2hvcnRoYW5kUHJvcGVydHlDb2xsaXNpb25JbkRldihzdHlsZVVwZGF0ZXMsIG5leHRTdHlsZXMpIHtcbiAge1xuICAgIGlmICghbmV4dFN0eWxlcykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBleHBhbmRlZFVwZGF0ZXMgPSBleHBhbmRTaG9ydGhhbmRNYXAoc3R5bGVVcGRhdGVzKTtcbiAgICB2YXIgZXhwYW5kZWRTdHlsZXMgPSBleHBhbmRTaG9ydGhhbmRNYXAobmV4dFN0eWxlcyk7XG4gICAgdmFyIHdhcm5lZEFib3V0ID0ge307XG5cbiAgICBmb3IgKHZhciBrZXkgaW4gZXhwYW5kZWRVcGRhdGVzKSB7XG4gICAgICB2YXIgb3JpZ2luYWxLZXkgPSBleHBhbmRlZFVwZGF0ZXNba2V5XTtcbiAgICAgIHZhciBjb3JyZWN0T3JpZ2luYWxLZXkgPSBleHBhbmRlZFN0eWxlc1trZXldO1xuXG4gICAgICBpZiAoY29ycmVjdE9yaWdpbmFsS2V5ICYmIG9yaWdpbmFsS2V5ICE9PSBjb3JyZWN0T3JpZ2luYWxLZXkpIHtcbiAgICAgICAgdmFyIHdhcm5pbmdLZXkgPSBvcmlnaW5hbEtleSArICcsJyArIGNvcnJlY3RPcmlnaW5hbEtleTtcblxuICAgICAgICBpZiAod2FybmVkQWJvdXRbd2FybmluZ0tleV0pIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHdhcm5lZEFib3V0W3dhcm5pbmdLZXldID0gdHJ1ZTtcblxuICAgICAgICBlcnJvcignJXMgYSBzdHlsZSBwcm9wZXJ0eSBkdXJpbmcgcmVyZW5kZXIgKCVzKSB3aGVuIGEgJyArICdjb25mbGljdGluZyBwcm9wZXJ0eSBpcyBzZXQgKCVzKSBjYW4gbGVhZCB0byBzdHlsaW5nIGJ1Z3MuIFRvICcgKyBcImF2b2lkIHRoaXMsIGRvbid0IG1peCBzaG9ydGhhbmQgYW5kIG5vbi1zaG9ydGhhbmQgcHJvcGVydGllcyBcIiArICdmb3IgdGhlIHNhbWUgdmFsdWU7IGluc3RlYWQsIHJlcGxhY2UgdGhlIHNob3J0aGFuZCB3aXRoICcgKyAnc2VwYXJhdGUgdmFsdWVzLicsIGlzVmFsdWVFbXB0eShzdHlsZVVwZGF0ZXNbb3JpZ2luYWxLZXldKSA/ICdSZW1vdmluZycgOiAnVXBkYXRpbmcnLCBvcmlnaW5hbEtleSwgY29ycmVjdE9yaWdpbmFsS2V5KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLy8gRm9yIEhUTUwsIGNlcnRhaW4gdGFncyBzaG91bGQgb21pdCB0aGVpciBjbG9zZSB0YWcuIFdlIGtlZXAgYSBsaXN0IGZvclxuLy8gdGhvc2Ugc3BlY2lhbC1jYXNlIHRhZ3MuXG52YXIgb21pdHRlZENsb3NlVGFncyA9IHtcbiAgYXJlYTogdHJ1ZSxcbiAgYmFzZTogdHJ1ZSxcbiAgYnI6IHRydWUsXG4gIGNvbDogdHJ1ZSxcbiAgZW1iZWQ6IHRydWUsXG4gIGhyOiB0cnVlLFxuICBpbWc6IHRydWUsXG4gIGlucHV0OiB0cnVlLFxuICBrZXlnZW46IHRydWUsXG4gIGxpbms6IHRydWUsXG4gIG1ldGE6IHRydWUsXG4gIHBhcmFtOiB0cnVlLFxuICBzb3VyY2U6IHRydWUsXG4gIHRyYWNrOiB0cnVlLFxuICB3YnI6IHRydWUgLy8gTk9URTogbWVudWl0ZW0ncyBjbG9zZSB0YWcgc2hvdWxkIGJlIG9taXR0ZWQsIGJ1dCB0aGF0IGNhdXNlcyBwcm9ibGVtcy5cblxufTtcblxuLy8gYG9taXR0ZWRDbG9zZVRhZ3NgIGV4Y2VwdCB0aGF0IGBtZW51aXRlbWAgc2hvdWxkIHN0aWxsIGhhdmUgaXRzIGNsb3NpbmcgdGFnLlxuXG52YXIgdm9pZEVsZW1lbnRUYWdzID0gX2Fzc2lnbih7XG4gIG1lbnVpdGVtOiB0cnVlXG59LCBvbWl0dGVkQ2xvc2VUYWdzKTtcblxudmFyIEhUTUwgPSAnX19odG1sJztcblxuZnVuY3Rpb24gYXNzZXJ0VmFsaWRQcm9wcyh0YWcsIHByb3BzKSB7XG4gIGlmICghcHJvcHMpIHtcbiAgICByZXR1cm47XG4gIH0gLy8gTm90ZSB0aGUgdXNlIG9mIGA9PWAgd2hpY2ggY2hlY2tzIGZvciBudWxsIG9yIHVuZGVmaW5lZC5cblxuXG4gIGlmICh2b2lkRWxlbWVudFRhZ3NbdGFnXSkge1xuICAgIGlmICghKHByb3BzLmNoaWxkcmVuID09IG51bGwgJiYgcHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwgPT0gbnVsbCkpIHtcbiAgICAgIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoIHRhZyArIFwiIGlzIGEgdm9pZCBlbGVtZW50IHRhZyBhbmQgbXVzdCBuZWl0aGVyIGhhdmUgYGNoaWxkcmVuYCBub3IgdXNlIGBkYW5nZXJvdXNseVNldElubmVySFRNTGAuXCIgKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAocHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwgIT0gbnVsbCkge1xuICAgIGlmICghKHByb3BzLmNoaWxkcmVuID09IG51bGwpKSB7XG4gICAgICB7XG4gICAgICAgIHRocm93IEVycm9yKCBcIkNhbiBvbmx5IHNldCBvbmUgb2YgYGNoaWxkcmVuYCBvciBgcHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxgLlwiICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCEodHlwZW9mIHByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MID09PSAnb2JqZWN0JyAmJiBIVE1MIGluIHByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MKSkge1xuICAgICAge1xuICAgICAgICB0aHJvdyBFcnJvciggXCJgcHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxgIG11c3QgYmUgaW4gdGhlIGZvcm0gYHtfX2h0bWw6IC4uLn1gLiBQbGVhc2UgdmlzaXQgaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL2Rhbmdlcm91c2x5LXNldC1pbm5lci1odG1sIGZvciBtb3JlIGluZm9ybWF0aW9uLlwiICk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAge1xuICAgIGlmICghcHJvcHMuc3VwcHJlc3NDb250ZW50RWRpdGFibGVXYXJuaW5nICYmIHByb3BzLmNvbnRlbnRFZGl0YWJsZSAmJiBwcm9wcy5jaGlsZHJlbiAhPSBudWxsKSB7XG4gICAgICBlcnJvcignQSBjb21wb25lbnQgaXMgYGNvbnRlbnRFZGl0YWJsZWAgYW5kIGNvbnRhaW5zIGBjaGlsZHJlbmAgbWFuYWdlZCBieSAnICsgJ1JlYWN0LiBJdCBpcyBub3cgeW91ciByZXNwb25zaWJpbGl0eSB0byBndWFyYW50ZWUgdGhhdCBub25lIG9mICcgKyAndGhvc2Ugbm9kZXMgYXJlIHVuZXhwZWN0ZWRseSBtb2RpZmllZCBvciBkdXBsaWNhdGVkLiBUaGlzIGlzICcgKyAncHJvYmFibHkgbm90IGludGVudGlvbmFsLicpO1xuICAgIH1cbiAgfVxuXG4gIGlmICghKHByb3BzLnN0eWxlID09IG51bGwgfHwgdHlwZW9mIHByb3BzLnN0eWxlID09PSAnb2JqZWN0JykpIHtcbiAgICB7XG4gICAgICB0aHJvdyBFcnJvciggXCJUaGUgYHN0eWxlYCBwcm9wIGV4cGVjdHMgYSBtYXBwaW5nIGZyb20gc3R5bGUgcHJvcGVydGllcyB0byB2YWx1ZXMsIG5vdCBhIHN0cmluZy4gRm9yIGV4YW1wbGUsIHN0eWxlPXt7bWFyZ2luUmlnaHQ6IHNwYWNpbmcgKyAnZW0nfX0gd2hlbiB1c2luZyBKU1guXCIgKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNDdXN0b21Db21wb25lbnQodGFnTmFtZSwgcHJvcHMpIHtcbiAgaWYgKHRhZ05hbWUuaW5kZXhPZignLScpID09PSAtMSkge1xuICAgIHJldHVybiB0eXBlb2YgcHJvcHMuaXMgPT09ICdzdHJpbmcnO1xuICB9XG5cbiAgc3dpdGNoICh0YWdOYW1lKSB7XG4gICAgLy8gVGhlc2UgYXJlIHJlc2VydmVkIFNWRyBhbmQgTWF0aE1MIGVsZW1lbnRzLlxuICAgIC8vIFdlIGRvbid0IG1pbmQgdGhpcyBsaXN0IHRvbyBtdWNoIGJlY2F1c2Ugd2UgZXhwZWN0IGl0IHRvIG5ldmVyIGdyb3cuXG4gICAgLy8gVGhlIGFsdGVybmF0aXZlIGlzIHRvIHRyYWNrIHRoZSBuYW1lc3BhY2UgaW4gYSBmZXcgcGxhY2VzIHdoaWNoIGlzIGNvbnZvbHV0ZWQuXG4gICAgLy8gaHR0cHM6Ly93M2MuZ2l0aHViLmlvL3dlYmNvbXBvbmVudHMvc3BlYy9jdXN0b20vI2N1c3RvbS1lbGVtZW50cy1jb3JlLWNvbmNlcHRzXG4gICAgY2FzZSAnYW5ub3RhdGlvbi14bWwnOlxuICAgIGNhc2UgJ2NvbG9yLXByb2ZpbGUnOlxuICAgIGNhc2UgJ2ZvbnQtZmFjZSc6XG4gICAgY2FzZSAnZm9udC1mYWNlLXNyYyc6XG4gICAgY2FzZSAnZm9udC1mYWNlLXVyaSc6XG4gICAgY2FzZSAnZm9udC1mYWNlLWZvcm1hdCc6XG4gICAgY2FzZSAnZm9udC1mYWNlLW5hbWUnOlxuICAgIGNhc2UgJ21pc3NpbmctZ2x5cGgnOlxuICAgICAgcmV0dXJuIGZhbHNlO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiB0cnVlO1xuICB9XG59XG5cbi8vIFdoZW4gYWRkaW5nIGF0dHJpYnV0ZXMgdG8gdGhlIEhUTUwgb3IgU1ZHIGFsbG93ZWQgYXR0cmlidXRlIGxpc3QsIGJlIHN1cmUgdG9cbi8vIGFsc28gYWRkIHRoZW0gdG8gdGhpcyBtb2R1bGUgdG8gZW5zdXJlIGNhc2luZyBhbmQgaW5jb3JyZWN0IG5hbWVcbi8vIHdhcm5pbmdzLlxudmFyIHBvc3NpYmxlU3RhbmRhcmROYW1lcyA9IHtcbiAgLy8gSFRNTFxuICBhY2NlcHQ6ICdhY2NlcHQnLFxuICBhY2NlcHRjaGFyc2V0OiAnYWNjZXB0Q2hhcnNldCcsXG4gICdhY2NlcHQtY2hhcnNldCc6ICdhY2NlcHRDaGFyc2V0JyxcbiAgYWNjZXNza2V5OiAnYWNjZXNzS2V5JyxcbiAgYWN0aW9uOiAnYWN0aW9uJyxcbiAgYWxsb3dmdWxsc2NyZWVuOiAnYWxsb3dGdWxsU2NyZWVuJyxcbiAgYWx0OiAnYWx0JyxcbiAgYXM6ICdhcycsXG4gIGFzeW5jOiAnYXN5bmMnLFxuICBhdXRvY2FwaXRhbGl6ZTogJ2F1dG9DYXBpdGFsaXplJyxcbiAgYXV0b2NvbXBsZXRlOiAnYXV0b0NvbXBsZXRlJyxcbiAgYXV0b2NvcnJlY3Q6ICdhdXRvQ29ycmVjdCcsXG4gIGF1dG9mb2N1czogJ2F1dG9Gb2N1cycsXG4gIGF1dG9wbGF5OiAnYXV0b1BsYXknLFxuICBhdXRvc2F2ZTogJ2F1dG9TYXZlJyxcbiAgY2FwdHVyZTogJ2NhcHR1cmUnLFxuICBjZWxscGFkZGluZzogJ2NlbGxQYWRkaW5nJyxcbiAgY2VsbHNwYWNpbmc6ICdjZWxsU3BhY2luZycsXG4gIGNoYWxsZW5nZTogJ2NoYWxsZW5nZScsXG4gIGNoYXJzZXQ6ICdjaGFyU2V0JyxcbiAgY2hlY2tlZDogJ2NoZWNrZWQnLFxuICBjaGlsZHJlbjogJ2NoaWxkcmVuJyxcbiAgY2l0ZTogJ2NpdGUnLFxuICBjbGFzczogJ2NsYXNzTmFtZScsXG4gIGNsYXNzaWQ6ICdjbGFzc0lEJyxcbiAgY2xhc3NuYW1lOiAnY2xhc3NOYW1lJyxcbiAgY29sczogJ2NvbHMnLFxuICBjb2xzcGFuOiAnY29sU3BhbicsXG4gIGNvbnRlbnQ6ICdjb250ZW50JyxcbiAgY29udGVudGVkaXRhYmxlOiAnY29udGVudEVkaXRhYmxlJyxcbiAgY29udGV4dG1lbnU6ICdjb250ZXh0TWVudScsXG4gIGNvbnRyb2xzOiAnY29udHJvbHMnLFxuICBjb250cm9sc2xpc3Q6ICdjb250cm9sc0xpc3QnLFxuICBjb29yZHM6ICdjb29yZHMnLFxuICBjcm9zc29yaWdpbjogJ2Nyb3NzT3JpZ2luJyxcbiAgZGFuZ2Vyb3VzbHlzZXRpbm5lcmh0bWw6ICdkYW5nZXJvdXNseVNldElubmVySFRNTCcsXG4gIGRhdGE6ICdkYXRhJyxcbiAgZGF0ZXRpbWU6ICdkYXRlVGltZScsXG4gIGRlZmF1bHQ6ICdkZWZhdWx0JyxcbiAgZGVmYXVsdGNoZWNrZWQ6ICdkZWZhdWx0Q2hlY2tlZCcsXG4gIGRlZmF1bHR2YWx1ZTogJ2RlZmF1bHRWYWx1ZScsXG4gIGRlZmVyOiAnZGVmZXInLFxuICBkaXI6ICdkaXInLFxuICBkaXNhYmxlZDogJ2Rpc2FibGVkJyxcbiAgZGlzYWJsZXBpY3R1cmVpbnBpY3R1cmU6ICdkaXNhYmxlUGljdHVyZUluUGljdHVyZScsXG4gIGRpc2FibGVyZW1vdGVwbGF5YmFjazogJ2Rpc2FibGVSZW1vdGVQbGF5YmFjaycsXG4gIGRvd25sb2FkOiAnZG93bmxvYWQnLFxuICBkcmFnZ2FibGU6ICdkcmFnZ2FibGUnLFxuICBlbmN0eXBlOiAnZW5jVHlwZScsXG4gIGVudGVya2V5aGludDogJ2VudGVyS2V5SGludCcsXG4gIGZvcjogJ2h0bWxGb3InLFxuICBmb3JtOiAnZm9ybScsXG4gIGZvcm1tZXRob2Q6ICdmb3JtTWV0aG9kJyxcbiAgZm9ybWFjdGlvbjogJ2Zvcm1BY3Rpb24nLFxuICBmb3JtZW5jdHlwZTogJ2Zvcm1FbmNUeXBlJyxcbiAgZm9ybW5vdmFsaWRhdGU6ICdmb3JtTm9WYWxpZGF0ZScsXG4gIGZvcm10YXJnZXQ6ICdmb3JtVGFyZ2V0JyxcbiAgZnJhbWVib3JkZXI6ICdmcmFtZUJvcmRlcicsXG4gIGhlYWRlcnM6ICdoZWFkZXJzJyxcbiAgaGVpZ2h0OiAnaGVpZ2h0JyxcbiAgaGlkZGVuOiAnaGlkZGVuJyxcbiAgaGlnaDogJ2hpZ2gnLFxuICBocmVmOiAnaHJlZicsXG4gIGhyZWZsYW5nOiAnaHJlZkxhbmcnLFxuICBodG1sZm9yOiAnaHRtbEZvcicsXG4gIGh0dHBlcXVpdjogJ2h0dHBFcXVpdicsXG4gICdodHRwLWVxdWl2JzogJ2h0dHBFcXVpdicsXG4gIGljb246ICdpY29uJyxcbiAgaWQ6ICdpZCcsXG4gIGlubmVyaHRtbDogJ2lubmVySFRNTCcsXG4gIGlucHV0bW9kZTogJ2lucHV0TW9kZScsXG4gIGludGVncml0eTogJ2ludGVncml0eScsXG4gIGlzOiAnaXMnLFxuICBpdGVtaWQ6ICdpdGVtSUQnLFxuICBpdGVtcHJvcDogJ2l0ZW1Qcm9wJyxcbiAgaXRlbXJlZjogJ2l0ZW1SZWYnLFxuICBpdGVtc2NvcGU6ICdpdGVtU2NvcGUnLFxuICBpdGVtdHlwZTogJ2l0ZW1UeXBlJyxcbiAga2V5cGFyYW1zOiAna2V5UGFyYW1zJyxcbiAga2V5dHlwZTogJ2tleVR5cGUnLFxuICBraW5kOiAna2luZCcsXG4gIGxhYmVsOiAnbGFiZWwnLFxuICBsYW5nOiAnbGFuZycsXG4gIGxpc3Q6ICdsaXN0JyxcbiAgbG9vcDogJ2xvb3AnLFxuICBsb3c6ICdsb3cnLFxuICBtYW5pZmVzdDogJ21hbmlmZXN0JyxcbiAgbWFyZ2lud2lkdGg6ICdtYXJnaW5XaWR0aCcsXG4gIG1hcmdpbmhlaWdodDogJ21hcmdpbkhlaWdodCcsXG4gIG1heDogJ21heCcsXG4gIG1heGxlbmd0aDogJ21heExlbmd0aCcsXG4gIG1lZGlhOiAnbWVkaWEnLFxuICBtZWRpYWdyb3VwOiAnbWVkaWFHcm91cCcsXG4gIG1ldGhvZDogJ21ldGhvZCcsXG4gIG1pbjogJ21pbicsXG4gIG1pbmxlbmd0aDogJ21pbkxlbmd0aCcsXG4gIG11bHRpcGxlOiAnbXVsdGlwbGUnLFxuICBtdXRlZDogJ211dGVkJyxcbiAgbmFtZTogJ25hbWUnLFxuICBub21vZHVsZTogJ25vTW9kdWxlJyxcbiAgbm9uY2U6ICdub25jZScsXG4gIG5vdmFsaWRhdGU6ICdub1ZhbGlkYXRlJyxcbiAgb3BlbjogJ29wZW4nLFxuICBvcHRpbXVtOiAnb3B0aW11bScsXG4gIHBhdHRlcm46ICdwYXR0ZXJuJyxcbiAgcGxhY2Vob2xkZXI6ICdwbGFjZWhvbGRlcicsXG4gIHBsYXlzaW5saW5lOiAncGxheXNJbmxpbmUnLFxuICBwb3N0ZXI6ICdwb3N0ZXInLFxuICBwcmVsb2FkOiAncHJlbG9hZCcsXG4gIHByb2ZpbGU6ICdwcm9maWxlJyxcbiAgcmFkaW9ncm91cDogJ3JhZGlvR3JvdXAnLFxuICByZWFkb25seTogJ3JlYWRPbmx5JyxcbiAgcmVmZXJyZXJwb2xpY3k6ICdyZWZlcnJlclBvbGljeScsXG4gIHJlbDogJ3JlbCcsXG4gIHJlcXVpcmVkOiAncmVxdWlyZWQnLFxuICByZXZlcnNlZDogJ3JldmVyc2VkJyxcbiAgcm9sZTogJ3JvbGUnLFxuICByb3dzOiAncm93cycsXG4gIHJvd3NwYW46ICdyb3dTcGFuJyxcbiAgc2FuZGJveDogJ3NhbmRib3gnLFxuICBzY29wZTogJ3Njb3BlJyxcbiAgc2NvcGVkOiAnc2NvcGVkJyxcbiAgc2Nyb2xsaW5nOiAnc2Nyb2xsaW5nJyxcbiAgc2VhbWxlc3M6ICdzZWFtbGVzcycsXG4gIHNlbGVjdGVkOiAnc2VsZWN0ZWQnLFxuICBzaGFwZTogJ3NoYXBlJyxcbiAgc2l6ZTogJ3NpemUnLFxuICBzaXplczogJ3NpemVzJyxcbiAgc3BhbjogJ3NwYW4nLFxuICBzcGVsbGNoZWNrOiAnc3BlbGxDaGVjaycsXG4gIHNyYzogJ3NyYycsXG4gIHNyY2RvYzogJ3NyY0RvYycsXG4gIHNyY2xhbmc6ICdzcmNMYW5nJyxcbiAgc3Jjc2V0OiAnc3JjU2V0JyxcbiAgc3RhcnQ6ICdzdGFydCcsXG4gIHN0ZXA6ICdzdGVwJyxcbiAgc3R5bGU6ICdzdHlsZScsXG4gIHN1bW1hcnk6ICdzdW1tYXJ5JyxcbiAgdGFiaW5kZXg6ICd0YWJJbmRleCcsXG4gIHRhcmdldDogJ3RhcmdldCcsXG4gIHRpdGxlOiAndGl0bGUnLFxuICB0eXBlOiAndHlwZScsXG4gIHVzZW1hcDogJ3VzZU1hcCcsXG4gIHZhbHVlOiAndmFsdWUnLFxuICB3aWR0aDogJ3dpZHRoJyxcbiAgd21vZGU6ICd3bW9kZScsXG4gIHdyYXA6ICd3cmFwJyxcbiAgLy8gU1ZHXG4gIGFib3V0OiAnYWJvdXQnLFxuICBhY2NlbnRoZWlnaHQ6ICdhY2NlbnRIZWlnaHQnLFxuICAnYWNjZW50LWhlaWdodCc6ICdhY2NlbnRIZWlnaHQnLFxuICBhY2N1bXVsYXRlOiAnYWNjdW11bGF0ZScsXG4gIGFkZGl0aXZlOiAnYWRkaXRpdmUnLFxuICBhbGlnbm1lbnRiYXNlbGluZTogJ2FsaWdubWVudEJhc2VsaW5lJyxcbiAgJ2FsaWdubWVudC1iYXNlbGluZSc6ICdhbGlnbm1lbnRCYXNlbGluZScsXG4gIGFsbG93cmVvcmRlcjogJ2FsbG93UmVvcmRlcicsXG4gIGFscGhhYmV0aWM6ICdhbHBoYWJldGljJyxcbiAgYW1wbGl0dWRlOiAnYW1wbGl0dWRlJyxcbiAgYXJhYmljZm9ybTogJ2FyYWJpY0Zvcm0nLFxuICAnYXJhYmljLWZvcm0nOiAnYXJhYmljRm9ybScsXG4gIGFzY2VudDogJ2FzY2VudCcsXG4gIGF0dHJpYnV0ZW5hbWU6ICdhdHRyaWJ1dGVOYW1lJyxcbiAgYXR0cmlidXRldHlwZTogJ2F0dHJpYnV0ZVR5cGUnLFxuICBhdXRvcmV2ZXJzZTogJ2F1dG9SZXZlcnNlJyxcbiAgYXppbXV0aDogJ2F6aW11dGgnLFxuICBiYXNlZnJlcXVlbmN5OiAnYmFzZUZyZXF1ZW5jeScsXG4gIGJhc2VsaW5lc2hpZnQ6ICdiYXNlbGluZVNoaWZ0JyxcbiAgJ2Jhc2VsaW5lLXNoaWZ0JzogJ2Jhc2VsaW5lU2hpZnQnLFxuICBiYXNlcHJvZmlsZTogJ2Jhc2VQcm9maWxlJyxcbiAgYmJveDogJ2Jib3gnLFxuICBiZWdpbjogJ2JlZ2luJyxcbiAgYmlhczogJ2JpYXMnLFxuICBieTogJ2J5JyxcbiAgY2FsY21vZGU6ICdjYWxjTW9kZScsXG4gIGNhcGhlaWdodDogJ2NhcEhlaWdodCcsXG4gICdjYXAtaGVpZ2h0JzogJ2NhcEhlaWdodCcsXG4gIGNsaXA6ICdjbGlwJyxcbiAgY2xpcHBhdGg6ICdjbGlwUGF0aCcsXG4gICdjbGlwLXBhdGgnOiAnY2xpcFBhdGgnLFxuICBjbGlwcGF0aHVuaXRzOiAnY2xpcFBhdGhVbml0cycsXG4gIGNsaXBydWxlOiAnY2xpcFJ1bGUnLFxuICAnY2xpcC1ydWxlJzogJ2NsaXBSdWxlJyxcbiAgY29sb3I6ICdjb2xvcicsXG4gIGNvbG9yaW50ZXJwb2xhdGlvbjogJ2NvbG9ySW50ZXJwb2xhdGlvbicsXG4gICdjb2xvci1pbnRlcnBvbGF0aW9uJzogJ2NvbG9ySW50ZXJwb2xhdGlvbicsXG4gIGNvbG9yaW50ZXJwb2xhdGlvbmZpbHRlcnM6ICdjb2xvckludGVycG9sYXRpb25GaWx0ZXJzJyxcbiAgJ2NvbG9yLWludGVycG9sYXRpb24tZmlsdGVycyc6ICdjb2xvckludGVycG9sYXRpb25GaWx0ZXJzJyxcbiAgY29sb3Jwcm9maWxlOiAnY29sb3JQcm9maWxlJyxcbiAgJ2NvbG9yLXByb2ZpbGUnOiAnY29sb3JQcm9maWxlJyxcbiAgY29sb3JyZW5kZXJpbmc6ICdjb2xvclJlbmRlcmluZycsXG4gICdjb2xvci1yZW5kZXJpbmcnOiAnY29sb3JSZW5kZXJpbmcnLFxuICBjb250ZW50c2NyaXB0dHlwZTogJ2NvbnRlbnRTY3JpcHRUeXBlJyxcbiAgY29udGVudHN0eWxldHlwZTogJ2NvbnRlbnRTdHlsZVR5cGUnLFxuICBjdXJzb3I6ICdjdXJzb3InLFxuICBjeDogJ2N4JyxcbiAgY3k6ICdjeScsXG4gIGQ6ICdkJyxcbiAgZGF0YXR5cGU6ICdkYXRhdHlwZScsXG4gIGRlY2VsZXJhdGU6ICdkZWNlbGVyYXRlJyxcbiAgZGVzY2VudDogJ2Rlc2NlbnQnLFxuICBkaWZmdXNlY29uc3RhbnQ6ICdkaWZmdXNlQ29uc3RhbnQnLFxuICBkaXJlY3Rpb246ICdkaXJlY3Rpb24nLFxuICBkaXNwbGF5OiAnZGlzcGxheScsXG4gIGRpdmlzb3I6ICdkaXZpc29yJyxcbiAgZG9taW5hbnRiYXNlbGluZTogJ2RvbWluYW50QmFzZWxpbmUnLFxuICAnZG9taW5hbnQtYmFzZWxpbmUnOiAnZG9taW5hbnRCYXNlbGluZScsXG4gIGR1cjogJ2R1cicsXG4gIGR4OiAnZHgnLFxuICBkeTogJ2R5JyxcbiAgZWRnZW1vZGU6ICdlZGdlTW9kZScsXG4gIGVsZXZhdGlvbjogJ2VsZXZhdGlvbicsXG4gIGVuYWJsZWJhY2tncm91bmQ6ICdlbmFibGVCYWNrZ3JvdW5kJyxcbiAgJ2VuYWJsZS1iYWNrZ3JvdW5kJzogJ2VuYWJsZUJhY2tncm91bmQnLFxuICBlbmQ6ICdlbmQnLFxuICBleHBvbmVudDogJ2V4cG9uZW50JyxcbiAgZXh0ZXJuYWxyZXNvdXJjZXNyZXF1aXJlZDogJ2V4dGVybmFsUmVzb3VyY2VzUmVxdWlyZWQnLFxuICBmaWxsOiAnZmlsbCcsXG4gIGZpbGxvcGFjaXR5OiAnZmlsbE9wYWNpdHknLFxuICAnZmlsbC1vcGFjaXR5JzogJ2ZpbGxPcGFjaXR5JyxcbiAgZmlsbHJ1bGU6ICdmaWxsUnVsZScsXG4gICdmaWxsLXJ1bGUnOiAnZmlsbFJ1bGUnLFxuICBmaWx0ZXI6ICdmaWx0ZXInLFxuICBmaWx0ZXJyZXM6ICdmaWx0ZXJSZXMnLFxuICBmaWx0ZXJ1bml0czogJ2ZpbHRlclVuaXRzJyxcbiAgZmxvb2RvcGFjaXR5OiAnZmxvb2RPcGFjaXR5JyxcbiAgJ2Zsb29kLW9wYWNpdHknOiAnZmxvb2RPcGFjaXR5JyxcbiAgZmxvb2Rjb2xvcjogJ2Zsb29kQ29sb3InLFxuICAnZmxvb2QtY29sb3InOiAnZmxvb2RDb2xvcicsXG4gIGZvY3VzYWJsZTogJ2ZvY3VzYWJsZScsXG4gIGZvbnRmYW1pbHk6ICdmb250RmFtaWx5JyxcbiAgJ2ZvbnQtZmFtaWx5JzogJ2ZvbnRGYW1pbHknLFxuICBmb250c2l6ZTogJ2ZvbnRTaXplJyxcbiAgJ2ZvbnQtc2l6ZSc6ICdmb250U2l6ZScsXG4gIGZvbnRzaXplYWRqdXN0OiAnZm9udFNpemVBZGp1c3QnLFxuICAnZm9udC1zaXplLWFkanVzdCc6ICdmb250U2l6ZUFkanVzdCcsXG4gIGZvbnRzdHJldGNoOiAnZm9udFN0cmV0Y2gnLFxuICAnZm9udC1zdHJldGNoJzogJ2ZvbnRTdHJldGNoJyxcbiAgZm9udHN0eWxlOiAnZm9udFN0eWxlJyxcbiAgJ2ZvbnQtc3R5bGUnOiAnZm9udFN0eWxlJyxcbiAgZm9udHZhcmlhbnQ6ICdmb250VmFyaWFudCcsXG4gICdmb250LXZhcmlhbnQnOiAnZm9udFZhcmlhbnQnLFxuICBmb250d2VpZ2h0OiAnZm9udFdlaWdodCcsXG4gICdmb250LXdlaWdodCc6ICdmb250V2VpZ2h0JyxcbiAgZm9ybWF0OiAnZm9ybWF0JyxcbiAgZnJvbTogJ2Zyb20nLFxuICBmeDogJ2Z4JyxcbiAgZnk6ICdmeScsXG4gIGcxOiAnZzEnLFxuICBnMjogJ2cyJyxcbiAgZ2x5cGhuYW1lOiAnZ2x5cGhOYW1lJyxcbiAgJ2dseXBoLW5hbWUnOiAnZ2x5cGhOYW1lJyxcbiAgZ2x5cGhvcmllbnRhdGlvbmhvcml6b250YWw6ICdnbHlwaE9yaWVudGF0aW9uSG9yaXpvbnRhbCcsXG4gICdnbHlwaC1vcmllbnRhdGlvbi1ob3Jpem9udGFsJzogJ2dseXBoT3JpZW50YXRpb25Ib3Jpem9udGFsJyxcbiAgZ2x5cGhvcmllbnRhdGlvbnZlcnRpY2FsOiAnZ2x5cGhPcmllbnRhdGlvblZlcnRpY2FsJyxcbiAgJ2dseXBoLW9yaWVudGF0aW9uLXZlcnRpY2FsJzogJ2dseXBoT3JpZW50YXRpb25WZXJ0aWNhbCcsXG4gIGdseXBocmVmOiAnZ2x5cGhSZWYnLFxuICBncmFkaWVudHRyYW5zZm9ybTogJ2dyYWRpZW50VHJhbnNmb3JtJyxcbiAgZ3JhZGllbnR1bml0czogJ2dyYWRpZW50VW5pdHMnLFxuICBoYW5naW5nOiAnaGFuZ2luZycsXG4gIGhvcml6YWR2eDogJ2hvcml6QWR2WCcsXG4gICdob3Jpei1hZHYteCc6ICdob3JpekFkdlgnLFxuICBob3Jpem9yaWdpbng6ICdob3Jpek9yaWdpblgnLFxuICAnaG9yaXotb3JpZ2luLXgnOiAnaG9yaXpPcmlnaW5YJyxcbiAgaWRlb2dyYXBoaWM6ICdpZGVvZ3JhcGhpYycsXG4gIGltYWdlcmVuZGVyaW5nOiAnaW1hZ2VSZW5kZXJpbmcnLFxuICAnaW1hZ2UtcmVuZGVyaW5nJzogJ2ltYWdlUmVuZGVyaW5nJyxcbiAgaW4yOiAnaW4yJyxcbiAgaW46ICdpbicsXG4gIGlubGlzdDogJ2lubGlzdCcsXG4gIGludGVyY2VwdDogJ2ludGVyY2VwdCcsXG4gIGsxOiAnazEnLFxuICBrMjogJ2syJyxcbiAgazM6ICdrMycsXG4gIGs0OiAnazQnLFxuICBrOiAnaycsXG4gIGtlcm5lbG1hdHJpeDogJ2tlcm5lbE1hdHJpeCcsXG4gIGtlcm5lbHVuaXRsZW5ndGg6ICdrZXJuZWxVbml0TGVuZ3RoJyxcbiAga2VybmluZzogJ2tlcm5pbmcnLFxuICBrZXlwb2ludHM6ICdrZXlQb2ludHMnLFxuICBrZXlzcGxpbmVzOiAna2V5U3BsaW5lcycsXG4gIGtleXRpbWVzOiAna2V5VGltZXMnLFxuICBsZW5ndGhhZGp1c3Q6ICdsZW5ndGhBZGp1c3QnLFxuICBsZXR0ZXJzcGFjaW5nOiAnbGV0dGVyU3BhY2luZycsXG4gICdsZXR0ZXItc3BhY2luZyc6ICdsZXR0ZXJTcGFjaW5nJyxcbiAgbGlnaHRpbmdjb2xvcjogJ2xpZ2h0aW5nQ29sb3InLFxuICAnbGlnaHRpbmctY29sb3InOiAnbGlnaHRpbmdDb2xvcicsXG4gIGxpbWl0aW5nY29uZWFuZ2xlOiAnbGltaXRpbmdDb25lQW5nbGUnLFxuICBsb2NhbDogJ2xvY2FsJyxcbiAgbWFya2VyZW5kOiAnbWFya2VyRW5kJyxcbiAgJ21hcmtlci1lbmQnOiAnbWFya2VyRW5kJyxcbiAgbWFya2VyaGVpZ2h0OiAnbWFya2VySGVpZ2h0JyxcbiAgbWFya2VybWlkOiAnbWFya2VyTWlkJyxcbiAgJ21hcmtlci1taWQnOiAnbWFya2VyTWlkJyxcbiAgbWFya2Vyc3RhcnQ6ICdtYXJrZXJTdGFydCcsXG4gICdtYXJrZXItc3RhcnQnOiAnbWFya2VyU3RhcnQnLFxuICBtYXJrZXJ1bml0czogJ21hcmtlclVuaXRzJyxcbiAgbWFya2Vyd2lkdGg6ICdtYXJrZXJXaWR0aCcsXG4gIG1hc2s6ICdtYXNrJyxcbiAgbWFza2NvbnRlbnR1bml0czogJ21hc2tDb250ZW50VW5pdHMnLFxuICBtYXNrdW5pdHM6ICdtYXNrVW5pdHMnLFxuICBtYXRoZW1hdGljYWw6ICdtYXRoZW1hdGljYWwnLFxuICBtb2RlOiAnbW9kZScsXG4gIG51bW9jdGF2ZXM6ICdudW1PY3RhdmVzJyxcbiAgb2Zmc2V0OiAnb2Zmc2V0JyxcbiAgb3BhY2l0eTogJ29wYWNpdHknLFxuICBvcGVyYXRvcjogJ29wZXJhdG9yJyxcbiAgb3JkZXI6ICdvcmRlcicsXG4gIG9yaWVudDogJ29yaWVudCcsXG4gIG9yaWVudGF0aW9uOiAnb3JpZW50YXRpb24nLFxuICBvcmlnaW46ICdvcmlnaW4nLFxuICBvdmVyZmxvdzogJ292ZXJmbG93JyxcbiAgb3ZlcmxpbmVwb3NpdGlvbjogJ292ZXJsaW5lUG9zaXRpb24nLFxuICAnb3ZlcmxpbmUtcG9zaXRpb24nOiAnb3ZlcmxpbmVQb3NpdGlvbicsXG4gIG92ZXJsaW5ldGhpY2tuZXNzOiAnb3ZlcmxpbmVUaGlja25lc3MnLFxuICAnb3ZlcmxpbmUtdGhpY2tuZXNzJzogJ292ZXJsaW5lVGhpY2tuZXNzJyxcbiAgcGFpbnRvcmRlcjogJ3BhaW50T3JkZXInLFxuICAncGFpbnQtb3JkZXInOiAncGFpbnRPcmRlcicsXG4gIHBhbm9zZTE6ICdwYW5vc2UxJyxcbiAgJ3Bhbm9zZS0xJzogJ3Bhbm9zZTEnLFxuICBwYXRobGVuZ3RoOiAncGF0aExlbmd0aCcsXG4gIHBhdHRlcm5jb250ZW50dW5pdHM6ICdwYXR0ZXJuQ29udGVudFVuaXRzJyxcbiAgcGF0dGVybnRyYW5zZm9ybTogJ3BhdHRlcm5UcmFuc2Zvcm0nLFxuICBwYXR0ZXJudW5pdHM6ICdwYXR0ZXJuVW5pdHMnLFxuICBwb2ludGVyZXZlbnRzOiAncG9pbnRlckV2ZW50cycsXG4gICdwb2ludGVyLWV2ZW50cyc6ICdwb2ludGVyRXZlbnRzJyxcbiAgcG9pbnRzOiAncG9pbnRzJyxcbiAgcG9pbnRzYXR4OiAncG9pbnRzQXRYJyxcbiAgcG9pbnRzYXR5OiAncG9pbnRzQXRZJyxcbiAgcG9pbnRzYXR6OiAncG9pbnRzQXRaJyxcbiAgcHJlZml4OiAncHJlZml4JyxcbiAgcHJlc2VydmVhbHBoYTogJ3ByZXNlcnZlQWxwaGEnLFxuICBwcmVzZXJ2ZWFzcGVjdHJhdGlvOiAncHJlc2VydmVBc3BlY3RSYXRpbycsXG4gIHByaW1pdGl2ZXVuaXRzOiAncHJpbWl0aXZlVW5pdHMnLFxuICBwcm9wZXJ0eTogJ3Byb3BlcnR5JyxcbiAgcjogJ3InLFxuICByYWRpdXM6ICdyYWRpdXMnLFxuICByZWZ4OiAncmVmWCcsXG4gIHJlZnk6ICdyZWZZJyxcbiAgcmVuZGVyaW5naW50ZW50OiAncmVuZGVyaW5nSW50ZW50JyxcbiAgJ3JlbmRlcmluZy1pbnRlbnQnOiAncmVuZGVyaW5nSW50ZW50JyxcbiAgcmVwZWF0Y291bnQ6ICdyZXBlYXRDb3VudCcsXG4gIHJlcGVhdGR1cjogJ3JlcGVhdER1cicsXG4gIHJlcXVpcmVkZXh0ZW5zaW9uczogJ3JlcXVpcmVkRXh0ZW5zaW9ucycsXG4gIHJlcXVpcmVkZmVhdHVyZXM6ICdyZXF1aXJlZEZlYXR1cmVzJyxcbiAgcmVzb3VyY2U6ICdyZXNvdXJjZScsXG4gIHJlc3RhcnQ6ICdyZXN0YXJ0JyxcbiAgcmVzdWx0OiAncmVzdWx0JyxcbiAgcmVzdWx0czogJ3Jlc3VsdHMnLFxuICByb3RhdGU6ICdyb3RhdGUnLFxuICByeDogJ3J4JyxcbiAgcnk6ICdyeScsXG4gIHNjYWxlOiAnc2NhbGUnLFxuICBzZWN1cml0eTogJ3NlY3VyaXR5JyxcbiAgc2VlZDogJ3NlZWQnLFxuICBzaGFwZXJlbmRlcmluZzogJ3NoYXBlUmVuZGVyaW5nJyxcbiAgJ3NoYXBlLXJlbmRlcmluZyc6ICdzaGFwZVJlbmRlcmluZycsXG4gIHNsb3BlOiAnc2xvcGUnLFxuICBzcGFjaW5nOiAnc3BhY2luZycsXG4gIHNwZWN1bGFyY29uc3RhbnQ6ICdzcGVjdWxhckNvbnN0YW50JyxcbiAgc3BlY3VsYXJleHBvbmVudDogJ3NwZWN1bGFyRXhwb25lbnQnLFxuICBzcGVlZDogJ3NwZWVkJyxcbiAgc3ByZWFkbWV0aG9kOiAnc3ByZWFkTWV0aG9kJyxcbiAgc3RhcnRvZmZzZXQ6ICdzdGFydE9mZnNldCcsXG4gIHN0ZGRldmlhdGlvbjogJ3N0ZERldmlhdGlvbicsXG4gIHN0ZW1oOiAnc3RlbWgnLFxuICBzdGVtdjogJ3N0ZW12JyxcbiAgc3RpdGNodGlsZXM6ICdzdGl0Y2hUaWxlcycsXG4gIHN0b3Bjb2xvcjogJ3N0b3BDb2xvcicsXG4gICdzdG9wLWNvbG9yJzogJ3N0b3BDb2xvcicsXG4gIHN0b3BvcGFjaXR5OiAnc3RvcE9wYWNpdHknLFxuICAnc3RvcC1vcGFjaXR5JzogJ3N0b3BPcGFjaXR5JyxcbiAgc3RyaWtldGhyb3VnaHBvc2l0aW9uOiAnc3RyaWtldGhyb3VnaFBvc2l0aW9uJyxcbiAgJ3N0cmlrZXRocm91Z2gtcG9zaXRpb24nOiAnc3RyaWtldGhyb3VnaFBvc2l0aW9uJyxcbiAgc3RyaWtldGhyb3VnaHRoaWNrbmVzczogJ3N0cmlrZXRocm91Z2hUaGlja25lc3MnLFxuICAnc3RyaWtldGhyb3VnaC10aGlja25lc3MnOiAnc3RyaWtldGhyb3VnaFRoaWNrbmVzcycsXG4gIHN0cmluZzogJ3N0cmluZycsXG4gIHN0cm9rZTogJ3N0cm9rZScsXG4gIHN0cm9rZWRhc2hhcnJheTogJ3N0cm9rZURhc2hhcnJheScsXG4gICdzdHJva2UtZGFzaGFycmF5JzogJ3N0cm9rZURhc2hhcnJheScsXG4gIHN0cm9rZWRhc2hvZmZzZXQ6ICdzdHJva2VEYXNob2Zmc2V0JyxcbiAgJ3N0cm9rZS1kYXNob2Zmc2V0JzogJ3N0cm9rZURhc2hvZmZzZXQnLFxuICBzdHJva2VsaW5lY2FwOiAnc3Ryb2tlTGluZWNhcCcsXG4gICdzdHJva2UtbGluZWNhcCc6ICdzdHJva2VMaW5lY2FwJyxcbiAgc3Ryb2tlbGluZWpvaW46ICdzdHJva2VMaW5lam9pbicsXG4gICdzdHJva2UtbGluZWpvaW4nOiAnc3Ryb2tlTGluZWpvaW4nLFxuICBzdHJva2VtaXRlcmxpbWl0OiAnc3Ryb2tlTWl0ZXJsaW1pdCcsXG4gICdzdHJva2UtbWl0ZXJsaW1pdCc6ICdzdHJva2VNaXRlcmxpbWl0JyxcbiAgc3Ryb2tld2lkdGg6ICdzdHJva2VXaWR0aCcsXG4gICdzdHJva2Utd2lkdGgnOiAnc3Ryb2tlV2lkdGgnLFxuICBzdHJva2VvcGFjaXR5OiAnc3Ryb2tlT3BhY2l0eScsXG4gICdzdHJva2Utb3BhY2l0eSc6ICdzdHJva2VPcGFjaXR5JyxcbiAgc3VwcHJlc3Njb250ZW50ZWRpdGFibGV3YXJuaW5nOiAnc3VwcHJlc3NDb250ZW50RWRpdGFibGVXYXJuaW5nJyxcbiAgc3VwcHJlc3NoeWRyYXRpb253YXJuaW5nOiAnc3VwcHJlc3NIeWRyYXRpb25XYXJuaW5nJyxcbiAgc3VyZmFjZXNjYWxlOiAnc3VyZmFjZVNjYWxlJyxcbiAgc3lzdGVtbGFuZ3VhZ2U6ICdzeXN0ZW1MYW5ndWFnZScsXG4gIHRhYmxldmFsdWVzOiAndGFibGVWYWx1ZXMnLFxuICB0YXJnZXR4OiAndGFyZ2V0WCcsXG4gIHRhcmdldHk6ICd0YXJnZXRZJyxcbiAgdGV4dGFuY2hvcjogJ3RleHRBbmNob3InLFxuICAndGV4dC1hbmNob3InOiAndGV4dEFuY2hvcicsXG4gIHRleHRkZWNvcmF0aW9uOiAndGV4dERlY29yYXRpb24nLFxuICAndGV4dC1kZWNvcmF0aW9uJzogJ3RleHREZWNvcmF0aW9uJyxcbiAgdGV4dGxlbmd0aDogJ3RleHRMZW5ndGgnLFxuICB0ZXh0cmVuZGVyaW5nOiAndGV4dFJlbmRlcmluZycsXG4gICd0ZXh0LXJlbmRlcmluZyc6ICd0ZXh0UmVuZGVyaW5nJyxcbiAgdG86ICd0bycsXG4gIHRyYW5zZm9ybTogJ3RyYW5zZm9ybScsXG4gIHR5cGVvZjogJ3R5cGVvZicsXG4gIHUxOiAndTEnLFxuICB1MjogJ3UyJyxcbiAgdW5kZXJsaW5lcG9zaXRpb246ICd1bmRlcmxpbmVQb3NpdGlvbicsXG4gICd1bmRlcmxpbmUtcG9zaXRpb24nOiAndW5kZXJsaW5lUG9zaXRpb24nLFxuICB1bmRlcmxpbmV0aGlja25lc3M6ICd1bmRlcmxpbmVUaGlja25lc3MnLFxuICAndW5kZXJsaW5lLXRoaWNrbmVzcyc6ICd1bmRlcmxpbmVUaGlja25lc3MnLFxuICB1bmljb2RlOiAndW5pY29kZScsXG4gIHVuaWNvZGViaWRpOiAndW5pY29kZUJpZGknLFxuICAndW5pY29kZS1iaWRpJzogJ3VuaWNvZGVCaWRpJyxcbiAgdW5pY29kZXJhbmdlOiAndW5pY29kZVJhbmdlJyxcbiAgJ3VuaWNvZGUtcmFuZ2UnOiAndW5pY29kZVJhbmdlJyxcbiAgdW5pdHNwZXJlbTogJ3VuaXRzUGVyRW0nLFxuICAndW5pdHMtcGVyLWVtJzogJ3VuaXRzUGVyRW0nLFxuICB1bnNlbGVjdGFibGU6ICd1bnNlbGVjdGFibGUnLFxuICB2YWxwaGFiZXRpYzogJ3ZBbHBoYWJldGljJyxcbiAgJ3YtYWxwaGFiZXRpYyc6ICd2QWxwaGFiZXRpYycsXG4gIHZhbHVlczogJ3ZhbHVlcycsXG4gIHZlY3RvcmVmZmVjdDogJ3ZlY3RvckVmZmVjdCcsXG4gICd2ZWN0b3ItZWZmZWN0JzogJ3ZlY3RvckVmZmVjdCcsXG4gIHZlcnNpb246ICd2ZXJzaW9uJyxcbiAgdmVydGFkdnk6ICd2ZXJ0QWR2WScsXG4gICd2ZXJ0LWFkdi15JzogJ3ZlcnRBZHZZJyxcbiAgdmVydG9yaWdpbng6ICd2ZXJ0T3JpZ2luWCcsXG4gICd2ZXJ0LW9yaWdpbi14JzogJ3ZlcnRPcmlnaW5YJyxcbiAgdmVydG9yaWdpbnk6ICd2ZXJ0T3JpZ2luWScsXG4gICd2ZXJ0LW9yaWdpbi15JzogJ3ZlcnRPcmlnaW5ZJyxcbiAgdmhhbmdpbmc6ICd2SGFuZ2luZycsXG4gICd2LWhhbmdpbmcnOiAndkhhbmdpbmcnLFxuICB2aWRlb2dyYXBoaWM6ICd2SWRlb2dyYXBoaWMnLFxuICAndi1pZGVvZ3JhcGhpYyc6ICd2SWRlb2dyYXBoaWMnLFxuICB2aWV3Ym94OiAndmlld0JveCcsXG4gIHZpZXd0YXJnZXQ6ICd2aWV3VGFyZ2V0JyxcbiAgdmlzaWJpbGl0eTogJ3Zpc2liaWxpdHknLFxuICB2bWF0aGVtYXRpY2FsOiAndk1hdGhlbWF0aWNhbCcsXG4gICd2LW1hdGhlbWF0aWNhbCc6ICd2TWF0aGVtYXRpY2FsJyxcbiAgdm9jYWI6ICd2b2NhYicsXG4gIHdpZHRoczogJ3dpZHRocycsXG4gIHdvcmRzcGFjaW5nOiAnd29yZFNwYWNpbmcnLFxuICAnd29yZC1zcGFjaW5nJzogJ3dvcmRTcGFjaW5nJyxcbiAgd3JpdGluZ21vZGU6ICd3cml0aW5nTW9kZScsXG4gICd3cml0aW5nLW1vZGUnOiAnd3JpdGluZ01vZGUnLFxuICB4MTogJ3gxJyxcbiAgeDI6ICd4MicsXG4gIHg6ICd4JyxcbiAgeGNoYW5uZWxzZWxlY3RvcjogJ3hDaGFubmVsU2VsZWN0b3InLFxuICB4aGVpZ2h0OiAneEhlaWdodCcsXG4gICd4LWhlaWdodCc6ICd4SGVpZ2h0JyxcbiAgeGxpbmthY3R1YXRlOiAneGxpbmtBY3R1YXRlJyxcbiAgJ3hsaW5rOmFjdHVhdGUnOiAneGxpbmtBY3R1YXRlJyxcbiAgeGxpbmthcmNyb2xlOiAneGxpbmtBcmNyb2xlJyxcbiAgJ3hsaW5rOmFyY3JvbGUnOiAneGxpbmtBcmNyb2xlJyxcbiAgeGxpbmtocmVmOiAneGxpbmtIcmVmJyxcbiAgJ3hsaW5rOmhyZWYnOiAneGxpbmtIcmVmJyxcbiAgeGxpbmtyb2xlOiAneGxpbmtSb2xlJyxcbiAgJ3hsaW5rOnJvbGUnOiAneGxpbmtSb2xlJyxcbiAgeGxpbmtzaG93OiAneGxpbmtTaG93JyxcbiAgJ3hsaW5rOnNob3cnOiAneGxpbmtTaG93JyxcbiAgeGxpbmt0aXRsZTogJ3hsaW5rVGl0bGUnLFxuICAneGxpbms6dGl0bGUnOiAneGxpbmtUaXRsZScsXG4gIHhsaW5rdHlwZTogJ3hsaW5rVHlwZScsXG4gICd4bGluazp0eXBlJzogJ3hsaW5rVHlwZScsXG4gIHhtbGJhc2U6ICd4bWxCYXNlJyxcbiAgJ3htbDpiYXNlJzogJ3htbEJhc2UnLFxuICB4bWxsYW5nOiAneG1sTGFuZycsXG4gICd4bWw6bGFuZyc6ICd4bWxMYW5nJyxcbiAgeG1sbnM6ICd4bWxucycsXG4gICd4bWw6c3BhY2UnOiAneG1sU3BhY2UnLFxuICB4bWxuc3hsaW5rOiAneG1sbnNYbGluaycsXG4gICd4bWxuczp4bGluayc6ICd4bWxuc1hsaW5rJyxcbiAgeG1sc3BhY2U6ICd4bWxTcGFjZScsXG4gIHkxOiAneTEnLFxuICB5MjogJ3kyJyxcbiAgeTogJ3knLFxuICB5Y2hhbm5lbHNlbGVjdG9yOiAneUNoYW5uZWxTZWxlY3RvcicsXG4gIHo6ICd6JyxcbiAgem9vbWFuZHBhbjogJ3pvb21BbmRQYW4nXG59O1xuXG52YXIgYXJpYVByb3BlcnRpZXMgPSB7XG4gICdhcmlhLWN1cnJlbnQnOiAwLFxuICAvLyBzdGF0ZVxuICAnYXJpYS1kZXRhaWxzJzogMCxcbiAgJ2FyaWEtZGlzYWJsZWQnOiAwLFxuICAvLyBzdGF0ZVxuICAnYXJpYS1oaWRkZW4nOiAwLFxuICAvLyBzdGF0ZVxuICAnYXJpYS1pbnZhbGlkJzogMCxcbiAgLy8gc3RhdGVcbiAgJ2FyaWEta2V5c2hvcnRjdXRzJzogMCxcbiAgJ2FyaWEtbGFiZWwnOiAwLFxuICAnYXJpYS1yb2xlZGVzY3JpcHRpb24nOiAwLFxuICAvLyBXaWRnZXQgQXR0cmlidXRlc1xuICAnYXJpYS1hdXRvY29tcGxldGUnOiAwLFxuICAnYXJpYS1jaGVja2VkJzogMCxcbiAgJ2FyaWEtZXhwYW5kZWQnOiAwLFxuICAnYXJpYS1oYXNwb3B1cCc6IDAsXG4gICdhcmlhLWxldmVsJzogMCxcbiAgJ2FyaWEtbW9kYWwnOiAwLFxuICAnYXJpYS1tdWx0aWxpbmUnOiAwLFxuICAnYXJpYS1tdWx0aXNlbGVjdGFibGUnOiAwLFxuICAnYXJpYS1vcmllbnRhdGlvbic6IDAsXG4gICdhcmlhLXBsYWNlaG9sZGVyJzogMCxcbiAgJ2FyaWEtcHJlc3NlZCc6IDAsXG4gICdhcmlhLXJlYWRvbmx5JzogMCxcbiAgJ2FyaWEtcmVxdWlyZWQnOiAwLFxuICAnYXJpYS1zZWxlY3RlZCc6IDAsXG4gICdhcmlhLXNvcnQnOiAwLFxuICAnYXJpYS12YWx1ZW1heCc6IDAsXG4gICdhcmlhLXZhbHVlbWluJzogMCxcbiAgJ2FyaWEtdmFsdWVub3cnOiAwLFxuICAnYXJpYS12YWx1ZXRleHQnOiAwLFxuICAvLyBMaXZlIFJlZ2lvbiBBdHRyaWJ1dGVzXG4gICdhcmlhLWF0b21pYyc6IDAsXG4gICdhcmlhLWJ1c3knOiAwLFxuICAnYXJpYS1saXZlJzogMCxcbiAgJ2FyaWEtcmVsZXZhbnQnOiAwLFxuICAvLyBEcmFnLWFuZC1Ecm9wIEF0dHJpYnV0ZXNcbiAgJ2FyaWEtZHJvcGVmZmVjdCc6IDAsXG4gICdhcmlhLWdyYWJiZWQnOiAwLFxuICAvLyBSZWxhdGlvbnNoaXAgQXR0cmlidXRlc1xuICAnYXJpYS1hY3RpdmVkZXNjZW5kYW50JzogMCxcbiAgJ2FyaWEtY29sY291bnQnOiAwLFxuICAnYXJpYS1jb2xpbmRleCc6IDAsXG4gICdhcmlhLWNvbHNwYW4nOiAwLFxuICAnYXJpYS1jb250cm9scyc6IDAsXG4gICdhcmlhLWRlc2NyaWJlZGJ5JzogMCxcbiAgJ2FyaWEtZXJyb3JtZXNzYWdlJzogMCxcbiAgJ2FyaWEtZmxvd3RvJzogMCxcbiAgJ2FyaWEtbGFiZWxsZWRieSc6IDAsXG4gICdhcmlhLW93bnMnOiAwLFxuICAnYXJpYS1wb3NpbnNldCc6IDAsXG4gICdhcmlhLXJvd2NvdW50JzogMCxcbiAgJ2FyaWEtcm93aW5kZXgnOiAwLFxuICAnYXJpYS1yb3dzcGFuJzogMCxcbiAgJ2FyaWEtc2V0c2l6ZSc6IDBcbn07XG5cbnZhciB3YXJuZWRQcm9wZXJ0aWVzID0ge307XG52YXIgckFSSUEgPSBuZXcgUmVnRXhwKCdeKGFyaWEpLVsnICsgQVRUUklCVVRFX05BTUVfQ0hBUiArICddKiQnKTtcbnZhciByQVJJQUNhbWVsID0gbmV3IFJlZ0V4cCgnXihhcmlhKVtBLVpdWycgKyBBVFRSSUJVVEVfTkFNRV9DSEFSICsgJ10qJCcpO1xudmFyIGhhc093blByb3BlcnR5JDEgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG5mdW5jdGlvbiB2YWxpZGF0ZVByb3BlcnR5KHRhZ05hbWUsIG5hbWUpIHtcbiAge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eSQxLmNhbGwod2FybmVkUHJvcGVydGllcywgbmFtZSkgJiYgd2FybmVkUHJvcGVydGllc1tuYW1lXSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKHJBUklBQ2FtZWwudGVzdChuYW1lKSkge1xuICAgICAgdmFyIGFyaWFOYW1lID0gJ2FyaWEtJyArIG5hbWUuc2xpY2UoNCkudG9Mb3dlckNhc2UoKTtcbiAgICAgIHZhciBjb3JyZWN0TmFtZSA9IGFyaWFQcm9wZXJ0aWVzLmhhc093blByb3BlcnR5KGFyaWFOYW1lKSA/IGFyaWFOYW1lIDogbnVsbDsgLy8gSWYgdGhpcyBpcyBhbiBhcmlhLSogYXR0cmlidXRlLCBidXQgaXMgbm90IGxpc3RlZCBpbiB0aGUga25vd24gRE9NXG4gICAgICAvLyBET00gcHJvcGVydGllcywgdGhlbiBpdCBpcyBhbiBpbnZhbGlkIGFyaWEtKiBhdHRyaWJ1dGUuXG5cbiAgICAgIGlmIChjb3JyZWN0TmFtZSA9PSBudWxsKSB7XG4gICAgICAgIGVycm9yKCdJbnZhbGlkIEFSSUEgYXR0cmlidXRlIGAlc2AuIEFSSUEgYXR0cmlidXRlcyBmb2xsb3cgdGhlIHBhdHRlcm4gYXJpYS0qIGFuZCBtdXN0IGJlIGxvd2VyY2FzZS4nLCBuYW1lKTtcblxuICAgICAgICB3YXJuZWRQcm9wZXJ0aWVzW25hbWVdID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IC8vIGFyaWEtKiBhdHRyaWJ1dGVzIHNob3VsZCBiZSBsb3dlcmNhc2U7IHN1Z2dlc3QgdGhlIGxvd2VyY2FzZSB2ZXJzaW9uLlxuXG5cbiAgICAgIGlmIChuYW1lICE9PSBjb3JyZWN0TmFtZSkge1xuICAgICAgICBlcnJvcignSW52YWxpZCBBUklBIGF0dHJpYnV0ZSBgJXNgLiBEaWQgeW91IG1lYW4gYCVzYD8nLCBuYW1lLCBjb3JyZWN0TmFtZSk7XG5cbiAgICAgICAgd2FybmVkUHJvcGVydGllc1tuYW1lXSA9IHRydWU7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChyQVJJQS50ZXN0KG5hbWUpKSB7XG4gICAgICB2YXIgbG93ZXJDYXNlZE5hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICB2YXIgc3RhbmRhcmROYW1lID0gYXJpYVByb3BlcnRpZXMuaGFzT3duUHJvcGVydHkobG93ZXJDYXNlZE5hbWUpID8gbG93ZXJDYXNlZE5hbWUgOiBudWxsOyAvLyBJZiB0aGlzIGlzIGFuIGFyaWEtKiBhdHRyaWJ1dGUsIGJ1dCBpcyBub3QgbGlzdGVkIGluIHRoZSBrbm93biBET01cbiAgICAgIC8vIERPTSBwcm9wZXJ0aWVzLCB0aGVuIGl0IGlzIGFuIGludmFsaWQgYXJpYS0qIGF0dHJpYnV0ZS5cblxuICAgICAgaWYgKHN0YW5kYXJkTmFtZSA9PSBudWxsKSB7XG4gICAgICAgIHdhcm5lZFByb3BlcnRpZXNbbmFtZV0gPSB0cnVlO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9IC8vIGFyaWEtKiBhdHRyaWJ1dGVzIHNob3VsZCBiZSBsb3dlcmNhc2U7IHN1Z2dlc3QgdGhlIGxvd2VyY2FzZSB2ZXJzaW9uLlxuXG5cbiAgICAgIGlmIChuYW1lICE9PSBzdGFuZGFyZE5hbWUpIHtcbiAgICAgICAgZXJyb3IoJ1Vua25vd24gQVJJQSBhdHRyaWJ1dGUgYCVzYC4gRGlkIHlvdSBtZWFuIGAlc2A/JywgbmFtZSwgc3RhbmRhcmROYW1lKTtcblxuICAgICAgICB3YXJuZWRQcm9wZXJ0aWVzW25hbWVdID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIHdhcm5JbnZhbGlkQVJJQVByb3BzKHR5cGUsIHByb3BzKSB7XG4gIHtcbiAgICB2YXIgaW52YWxpZFByb3BzID0gW107XG5cbiAgICBmb3IgKHZhciBrZXkgaW4gcHJvcHMpIHtcbiAgICAgIHZhciBpc1ZhbGlkID0gdmFsaWRhdGVQcm9wZXJ0eSh0eXBlLCBrZXkpO1xuXG4gICAgICBpZiAoIWlzVmFsaWQpIHtcbiAgICAgICAgaW52YWxpZFByb3BzLnB1c2goa2V5KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgdW5rbm93blByb3BTdHJpbmcgPSBpbnZhbGlkUHJvcHMubWFwKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgICByZXR1cm4gJ2AnICsgcHJvcCArICdgJztcbiAgICB9KS5qb2luKCcsICcpO1xuXG4gICAgaWYgKGludmFsaWRQcm9wcy5sZW5ndGggPT09IDEpIHtcbiAgICAgIGVycm9yKCdJbnZhbGlkIGFyaWEgcHJvcCAlcyBvbiA8JXM+IHRhZy4gJyArICdGb3IgZGV0YWlscywgc2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9pbnZhbGlkLWFyaWEtcHJvcHMnLCB1bmtub3duUHJvcFN0cmluZywgdHlwZSk7XG4gICAgfSBlbHNlIGlmIChpbnZhbGlkUHJvcHMubGVuZ3RoID4gMSkge1xuICAgICAgZXJyb3IoJ0ludmFsaWQgYXJpYSBwcm9wcyAlcyBvbiA8JXM+IHRhZy4gJyArICdGb3IgZGV0YWlscywgc2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9pbnZhbGlkLWFyaWEtcHJvcHMnLCB1bmtub3duUHJvcFN0cmluZywgdHlwZSk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlUHJvcGVydGllcyh0eXBlLCBwcm9wcykge1xuICBpZiAoaXNDdXN0b21Db21wb25lbnQodHlwZSwgcHJvcHMpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgd2FybkludmFsaWRBUklBUHJvcHModHlwZSwgcHJvcHMpO1xufVxuXG52YXIgZGlkV2FyblZhbHVlTnVsbCA9IGZhbHNlO1xuZnVuY3Rpb24gdmFsaWRhdGVQcm9wZXJ0aWVzJDEodHlwZSwgcHJvcHMpIHtcbiAge1xuICAgIGlmICh0eXBlICE9PSAnaW5wdXQnICYmIHR5cGUgIT09ICd0ZXh0YXJlYScgJiYgdHlwZSAhPT0gJ3NlbGVjdCcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAocHJvcHMgIT0gbnVsbCAmJiBwcm9wcy52YWx1ZSA9PT0gbnVsbCAmJiAhZGlkV2FyblZhbHVlTnVsbCkge1xuICAgICAgZGlkV2FyblZhbHVlTnVsbCA9IHRydWU7XG5cbiAgICAgIGlmICh0eXBlID09PSAnc2VsZWN0JyAmJiBwcm9wcy5tdWx0aXBsZSkge1xuICAgICAgICBlcnJvcignYHZhbHVlYCBwcm9wIG9uIGAlc2Agc2hvdWxkIG5vdCBiZSBudWxsLiAnICsgJ0NvbnNpZGVyIHVzaW5nIGFuIGVtcHR5IGFycmF5IHdoZW4gYG11bHRpcGxlYCBpcyBzZXQgdG8gYHRydWVgICcgKyAndG8gY2xlYXIgdGhlIGNvbXBvbmVudCBvciBgdW5kZWZpbmVkYCBmb3IgdW5jb250cm9sbGVkIGNvbXBvbmVudHMuJywgdHlwZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlcnJvcignYHZhbHVlYCBwcm9wIG9uIGAlc2Agc2hvdWxkIG5vdCBiZSBudWxsLiAnICsgJ0NvbnNpZGVyIHVzaW5nIGFuIGVtcHR5IHN0cmluZyB0byBjbGVhciB0aGUgY29tcG9uZW50IG9yIGB1bmRlZmluZWRgICcgKyAnZm9yIHVuY29udHJvbGxlZCBjb21wb25lbnRzLicsIHR5cGUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG52YXIgdmFsaWRhdGVQcm9wZXJ0eSQxID0gZnVuY3Rpb24gKCkge307XG5cbntcbiAgdmFyIHdhcm5lZFByb3BlcnRpZXMkMSA9IHt9O1xuICB2YXIgX2hhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbiAgdmFyIEVWRU5UX05BTUVfUkVHRVggPSAvXm9uLi87XG4gIHZhciBJTlZBTElEX0VWRU5UX05BTUVfUkVHRVggPSAvXm9uW15BLVpdLztcbiAgdmFyIHJBUklBJDEgPSBuZXcgUmVnRXhwKCdeKGFyaWEpLVsnICsgQVRUUklCVVRFX05BTUVfQ0hBUiArICddKiQnKTtcbiAgdmFyIHJBUklBQ2FtZWwkMSA9IG5ldyBSZWdFeHAoJ14oYXJpYSlbQS1aXVsnICsgQVRUUklCVVRFX05BTUVfQ0hBUiArICddKiQnKTtcblxuICB2YWxpZGF0ZVByb3BlcnR5JDEgPSBmdW5jdGlvbiAodGFnTmFtZSwgbmFtZSwgdmFsdWUsIGV2ZW50UmVnaXN0cnkpIHtcbiAgICBpZiAoX2hhc093blByb3BlcnR5LmNhbGwod2FybmVkUHJvcGVydGllcyQxLCBuYW1lKSAmJiB3YXJuZWRQcm9wZXJ0aWVzJDFbbmFtZV0pIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHZhciBsb3dlckNhc2VkTmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcblxuICAgIGlmIChsb3dlckNhc2VkTmFtZSA9PT0gJ29uZm9jdXNpbicgfHwgbG93ZXJDYXNlZE5hbWUgPT09ICdvbmZvY3Vzb3V0Jykge1xuICAgICAgZXJyb3IoJ1JlYWN0IHVzZXMgb25Gb2N1cyBhbmQgb25CbHVyIGluc3RlYWQgb2Ygb25Gb2N1c0luIGFuZCBvbkZvY3VzT3V0LiAnICsgJ0FsbCBSZWFjdCBldmVudHMgYXJlIG5vcm1hbGl6ZWQgdG8gYnViYmxlLCBzbyBvbkZvY3VzSW4gYW5kIG9uRm9jdXNPdXQgJyArICdhcmUgbm90IG5lZWRlZC9zdXBwb3J0ZWQgYnkgUmVhY3QuJyk7XG5cbiAgICAgIHdhcm5lZFByb3BlcnRpZXMkMVtuYW1lXSA9IHRydWU7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IC8vIFdlIGNhbid0IHJlbHkgb24gdGhlIGV2ZW50IHN5c3RlbSBiZWluZyBpbmplY3RlZCBvbiB0aGUgc2VydmVyLlxuXG5cbiAgICBpZiAoZXZlbnRSZWdpc3RyeSAhPSBudWxsKSB7XG4gICAgICB2YXIgcmVnaXN0cmF0aW9uTmFtZURlcGVuZGVuY2llcyA9IGV2ZW50UmVnaXN0cnkucmVnaXN0cmF0aW9uTmFtZURlcGVuZGVuY2llcyxcbiAgICAgICAgICBwb3NzaWJsZVJlZ2lzdHJhdGlvbk5hbWVzID0gZXZlbnRSZWdpc3RyeS5wb3NzaWJsZVJlZ2lzdHJhdGlvbk5hbWVzO1xuXG4gICAgICBpZiAocmVnaXN0cmF0aW9uTmFtZURlcGVuZGVuY2llcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIHJlZ2lzdHJhdGlvbk5hbWUgPSBwb3NzaWJsZVJlZ2lzdHJhdGlvbk5hbWVzLmhhc093blByb3BlcnR5KGxvd2VyQ2FzZWROYW1lKSA/IHBvc3NpYmxlUmVnaXN0cmF0aW9uTmFtZXNbbG93ZXJDYXNlZE5hbWVdIDogbnVsbDtcblxuICAgICAgaWYgKHJlZ2lzdHJhdGlvbk5hbWUgIT0gbnVsbCkge1xuICAgICAgICBlcnJvcignSW52YWxpZCBldmVudCBoYW5kbGVyIHByb3BlcnR5IGAlc2AuIERpZCB5b3UgbWVhbiBgJXNgPycsIG5hbWUsIHJlZ2lzdHJhdGlvbk5hbWUpO1xuXG4gICAgICAgIHdhcm5lZFByb3BlcnRpZXMkMVtuYW1lXSA9IHRydWU7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoRVZFTlRfTkFNRV9SRUdFWC50ZXN0KG5hbWUpKSB7XG4gICAgICAgIGVycm9yKCdVbmtub3duIGV2ZW50IGhhbmRsZXIgcHJvcGVydHkgYCVzYC4gSXQgd2lsbCBiZSBpZ25vcmVkLicsIG5hbWUpO1xuXG4gICAgICAgIHdhcm5lZFByb3BlcnRpZXMkMVtuYW1lXSA9IHRydWU7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoRVZFTlRfTkFNRV9SRUdFWC50ZXN0KG5hbWUpKSB7XG4gICAgICAvLyBJZiBubyBldmVudCBwbHVnaW5zIGhhdmUgYmVlbiBpbmplY3RlZCwgd2UgYXJlIGluIGEgc2VydmVyIGVudmlyb25tZW50LlxuICAgICAgLy8gU28gd2UgY2FuJ3QgdGVsbCBpZiB0aGUgZXZlbnQgbmFtZSBpcyBjb3JyZWN0IGZvciBzdXJlLCBidXQgd2UgY2FuIGZpbHRlclxuICAgICAgLy8gb3V0IGtub3duIGJhZCBvbmVzIGxpa2UgYG9uY2xpY2tgLiBXZSBjYW4ndCBzdWdnZXN0IGEgc3BlY2lmaWMgcmVwbGFjZW1lbnQgdGhvdWdoLlxuICAgICAgaWYgKElOVkFMSURfRVZFTlRfTkFNRV9SRUdFWC50ZXN0KG5hbWUpKSB7XG4gICAgICAgIGVycm9yKCdJbnZhbGlkIGV2ZW50IGhhbmRsZXIgcHJvcGVydHkgYCVzYC4gJyArICdSZWFjdCBldmVudHMgdXNlIHRoZSBjYW1lbENhc2UgbmFtaW5nIGNvbnZlbnRpb24sIGZvciBleGFtcGxlIGBvbkNsaWNrYC4nLCBuYW1lKTtcbiAgICAgIH1cblxuICAgICAgd2FybmVkUHJvcGVydGllcyQxW25hbWVdID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gLy8gTGV0IHRoZSBBUklBIGF0dHJpYnV0ZSBob29rIHZhbGlkYXRlIEFSSUEgYXR0cmlidXRlc1xuXG5cbiAgICBpZiAockFSSUEkMS50ZXN0KG5hbWUpIHx8IHJBUklBQ2FtZWwkMS50ZXN0KG5hbWUpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAobG93ZXJDYXNlZE5hbWUgPT09ICdpbm5lcmh0bWwnKSB7XG4gICAgICBlcnJvcignRGlyZWN0bHkgc2V0dGluZyBwcm9wZXJ0eSBgaW5uZXJIVE1MYCBpcyBub3QgcGVybWl0dGVkLiAnICsgJ0ZvciBtb3JlIGluZm9ybWF0aW9uLCBsb29rdXAgZG9jdW1lbnRhdGlvbiBvbiBgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxgLicpO1xuXG4gICAgICB3YXJuZWRQcm9wZXJ0aWVzJDFbbmFtZV0gPSB0cnVlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKGxvd2VyQ2FzZWROYW1lID09PSAnYXJpYScpIHtcbiAgICAgIGVycm9yKCdUaGUgYGFyaWFgIGF0dHJpYnV0ZSBpcyByZXNlcnZlZCBmb3IgZnV0dXJlIHVzZSBpbiBSZWFjdC4gJyArICdQYXNzIGluZGl2aWR1YWwgYGFyaWEtYCBhdHRyaWJ1dGVzIGluc3RlYWQuJyk7XG5cbiAgICAgIHdhcm5lZFByb3BlcnRpZXMkMVtuYW1lXSA9IHRydWU7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAobG93ZXJDYXNlZE5hbWUgPT09ICdpcycgJiYgdmFsdWUgIT09IG51bGwgJiYgdmFsdWUgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICBlcnJvcignUmVjZWl2ZWQgYSBgJXNgIGZvciBhIHN0cmluZyBhdHRyaWJ1dGUgYGlzYC4gSWYgdGhpcyBpcyBleHBlY3RlZCwgY2FzdCAnICsgJ3RoZSB2YWx1ZSB0byBhIHN0cmluZy4nLCB0eXBlb2YgdmFsdWUpO1xuXG4gICAgICB3YXJuZWRQcm9wZXJ0aWVzJDFbbmFtZV0gPSB0cnVlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgJiYgaXNOYU4odmFsdWUpKSB7XG4gICAgICBlcnJvcignUmVjZWl2ZWQgTmFOIGZvciB0aGUgYCVzYCBhdHRyaWJ1dGUuIElmIHRoaXMgaXMgZXhwZWN0ZWQsIGNhc3QgJyArICd0aGUgdmFsdWUgdG8gYSBzdHJpbmcuJywgbmFtZSk7XG5cbiAgICAgIHdhcm5lZFByb3BlcnRpZXMkMVtuYW1lXSA9IHRydWU7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICB2YXIgcHJvcGVydHlJbmZvID0gZ2V0UHJvcGVydHlJbmZvKG5hbWUpO1xuICAgIHZhciBpc1Jlc2VydmVkID0gcHJvcGVydHlJbmZvICE9PSBudWxsICYmIHByb3BlcnR5SW5mby50eXBlID09PSBSRVNFUlZFRDsgLy8gS25vd24gYXR0cmlidXRlcyBzaG91bGQgbWF0Y2ggdGhlIGNhc2luZyBzcGVjaWZpZWQgaW4gdGhlIHByb3BlcnR5IGNvbmZpZy5cblxuICAgIGlmIChwb3NzaWJsZVN0YW5kYXJkTmFtZXMuaGFzT3duUHJvcGVydHkobG93ZXJDYXNlZE5hbWUpKSB7XG4gICAgICB2YXIgc3RhbmRhcmROYW1lID0gcG9zc2libGVTdGFuZGFyZE5hbWVzW2xvd2VyQ2FzZWROYW1lXTtcblxuICAgICAgaWYgKHN0YW5kYXJkTmFtZSAhPT0gbmFtZSkge1xuICAgICAgICBlcnJvcignSW52YWxpZCBET00gcHJvcGVydHkgYCVzYC4gRGlkIHlvdSBtZWFuIGAlc2A/JywgbmFtZSwgc3RhbmRhcmROYW1lKTtcblxuICAgICAgICB3YXJuZWRQcm9wZXJ0aWVzJDFbbmFtZV0gPSB0cnVlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCFpc1Jlc2VydmVkICYmIG5hbWUgIT09IGxvd2VyQ2FzZWROYW1lKSB7XG4gICAgICAvLyBVbmtub3duIGF0dHJpYnV0ZXMgc2hvdWxkIGhhdmUgbG93ZXJjYXNlIGNhc2luZyBzaW5jZSB0aGF0J3MgaG93IHRoZXlcbiAgICAgIC8vIHdpbGwgYmUgY2FzZWQgYW55d2F5IHdpdGggc2VydmVyIHJlbmRlcmluZy5cbiAgICAgIGVycm9yKCdSZWFjdCBkb2VzIG5vdCByZWNvZ25pemUgdGhlIGAlc2AgcHJvcCBvbiBhIERPTSBlbGVtZW50LiBJZiB5b3UgJyArICdpbnRlbnRpb25hbGx5IHdhbnQgaXQgdG8gYXBwZWFyIGluIHRoZSBET00gYXMgYSBjdXN0b20gJyArICdhdHRyaWJ1dGUsIHNwZWxsIGl0IGFzIGxvd2VyY2FzZSBgJXNgIGluc3RlYWQuICcgKyAnSWYgeW91IGFjY2lkZW50YWxseSBwYXNzZWQgaXQgZnJvbSBhIHBhcmVudCBjb21wb25lbnQsIHJlbW92ZSAnICsgJ2l0IGZyb20gdGhlIERPTSBlbGVtZW50LicsIG5hbWUsIGxvd2VyQ2FzZWROYW1lKTtcblxuICAgICAgd2FybmVkUHJvcGVydGllcyQxW25hbWVdID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJyAmJiBzaG91bGRSZW1vdmVBdHRyaWJ1dGVXaXRoV2FybmluZyhuYW1lLCB2YWx1ZSwgcHJvcGVydHlJbmZvLCBmYWxzZSkpIHtcbiAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICBlcnJvcignUmVjZWl2ZWQgYCVzYCBmb3IgYSBub24tYm9vbGVhbiBhdHRyaWJ1dGUgYCVzYC5cXG5cXG4nICsgJ0lmIHlvdSB3YW50IHRvIHdyaXRlIGl0IHRvIHRoZSBET00sIHBhc3MgYSBzdHJpbmcgaW5zdGVhZDogJyArICclcz1cIiVzXCIgb3IgJXM9e3ZhbHVlLnRvU3RyaW5nKCl9LicsIHZhbHVlLCBuYW1lLCBuYW1lLCB2YWx1ZSwgbmFtZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlcnJvcignUmVjZWl2ZWQgYCVzYCBmb3IgYSBub24tYm9vbGVhbiBhdHRyaWJ1dGUgYCVzYC5cXG5cXG4nICsgJ0lmIHlvdSB3YW50IHRvIHdyaXRlIGl0IHRvIHRoZSBET00sIHBhc3MgYSBzdHJpbmcgaW5zdGVhZDogJyArICclcz1cIiVzXCIgb3IgJXM9e3ZhbHVlLnRvU3RyaW5nKCl9LlxcblxcbicgKyAnSWYgeW91IHVzZWQgdG8gY29uZGl0aW9uYWxseSBvbWl0IGl0IHdpdGggJXM9e2NvbmRpdGlvbiAmJiB2YWx1ZX0sICcgKyAncGFzcyAlcz17Y29uZGl0aW9uID8gdmFsdWUgOiB1bmRlZmluZWR9IGluc3RlYWQuJywgdmFsdWUsIG5hbWUsIG5hbWUsIHZhbHVlLCBuYW1lLCBuYW1lLCBuYW1lKTtcbiAgICAgIH1cblxuICAgICAgd2FybmVkUHJvcGVydGllcyQxW25hbWVdID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gLy8gTm93IHRoYXQgd2UndmUgdmFsaWRhdGVkIGNhc2luZywgZG8gbm90IHZhbGlkYXRlXG4gICAgLy8gZGF0YSB0eXBlcyBmb3IgcmVzZXJ2ZWQgcHJvcHNcblxuXG4gICAgaWYgKGlzUmVzZXJ2ZWQpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gLy8gV2FybiB3aGVuIGEga25vd24gYXR0cmlidXRlIGlzIGEgYmFkIHR5cGVcblxuXG4gICAgaWYgKHNob3VsZFJlbW92ZUF0dHJpYnV0ZVdpdGhXYXJuaW5nKG5hbWUsIHZhbHVlLCBwcm9wZXJ0eUluZm8sIGZhbHNlKSkge1xuICAgICAgd2FybmVkUHJvcGVydGllcyQxW25hbWVdID0gdHJ1ZTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IC8vIFdhcm4gd2hlbiBwYXNzaW5nIHRoZSBzdHJpbmdzICdmYWxzZScgb3IgJ3RydWUnIGludG8gYSBib29sZWFuIHByb3BcblxuXG4gICAgaWYgKCh2YWx1ZSA9PT0gJ2ZhbHNlJyB8fCB2YWx1ZSA9PT0gJ3RydWUnKSAmJiBwcm9wZXJ0eUluZm8gIT09IG51bGwgJiYgcHJvcGVydHlJbmZvLnR5cGUgPT09IEJPT0xFQU4pIHtcbiAgICAgIGVycm9yKCdSZWNlaXZlZCB0aGUgc3RyaW5nIGAlc2AgZm9yIHRoZSBib29sZWFuIGF0dHJpYnV0ZSBgJXNgLiAnICsgJyVzICcgKyAnRGlkIHlvdSBtZWFuICVzPXslc30/JywgdmFsdWUsIG5hbWUsIHZhbHVlID09PSAnZmFsc2UnID8gJ1RoZSBicm93c2VyIHdpbGwgaW50ZXJwcmV0IGl0IGFzIGEgdHJ1dGh5IHZhbHVlLicgOiAnQWx0aG91Z2ggdGhpcyB3b3JrcywgaXQgd2lsbCBub3Qgd29yayBhcyBleHBlY3RlZCBpZiB5b3UgcGFzcyB0aGUgc3RyaW5nIFwiZmFsc2VcIi4nLCBuYW1lLCB2YWx1ZSk7XG5cbiAgICAgIHdhcm5lZFByb3BlcnRpZXMkMVtuYW1lXSA9IHRydWU7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcbn1cblxudmFyIHdhcm5Vbmtub3duUHJvcGVydGllcyA9IGZ1bmN0aW9uICh0eXBlLCBwcm9wcywgZXZlbnRSZWdpc3RyeSkge1xuICB7XG4gICAgdmFyIHVua25vd25Qcm9wcyA9IFtdO1xuXG4gICAgZm9yICh2YXIga2V5IGluIHByb3BzKSB7XG4gICAgICB2YXIgaXNWYWxpZCA9IHZhbGlkYXRlUHJvcGVydHkkMSh0eXBlLCBrZXksIHByb3BzW2tleV0sIGV2ZW50UmVnaXN0cnkpO1xuXG4gICAgICBpZiAoIWlzVmFsaWQpIHtcbiAgICAgICAgdW5rbm93blByb3BzLnB1c2goa2V5KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgdW5rbm93blByb3BTdHJpbmcgPSB1bmtub3duUHJvcHMubWFwKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgICByZXR1cm4gJ2AnICsgcHJvcCArICdgJztcbiAgICB9KS5qb2luKCcsICcpO1xuXG4gICAgaWYgKHVua25vd25Qcm9wcy5sZW5ndGggPT09IDEpIHtcbiAgICAgIGVycm9yKCdJbnZhbGlkIHZhbHVlIGZvciBwcm9wICVzIG9uIDwlcz4gdGFnLiBFaXRoZXIgcmVtb3ZlIGl0IGZyb20gdGhlIGVsZW1lbnQsICcgKyAnb3IgcGFzcyBhIHN0cmluZyBvciBudW1iZXIgdmFsdWUgdG8ga2VlcCBpdCBpbiB0aGUgRE9NLiAnICsgJ0ZvciBkZXRhaWxzLCBzZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL2F0dHJpYnV0ZS1iZWhhdmlvciAnLCB1bmtub3duUHJvcFN0cmluZywgdHlwZSk7XG4gICAgfSBlbHNlIGlmICh1bmtub3duUHJvcHMubGVuZ3RoID4gMSkge1xuICAgICAgZXJyb3IoJ0ludmFsaWQgdmFsdWVzIGZvciBwcm9wcyAlcyBvbiA8JXM+IHRhZy4gRWl0aGVyIHJlbW92ZSB0aGVtIGZyb20gdGhlIGVsZW1lbnQsICcgKyAnb3IgcGFzcyBhIHN0cmluZyBvciBudW1iZXIgdmFsdWUgdG8ga2VlcCB0aGVtIGluIHRoZSBET00uICcgKyAnRm9yIGRldGFpbHMsIHNlZSBodHRwczovL3JlYWN0anMub3JnL2xpbmsvYXR0cmlidXRlLWJlaGF2aW9yICcsIHVua25vd25Qcm9wU3RyaW5nLCB0eXBlKTtcbiAgICB9XG4gIH1cbn07XG5cbmZ1bmN0aW9uIHZhbGlkYXRlUHJvcGVydGllcyQyKHR5cGUsIHByb3BzLCBldmVudFJlZ2lzdHJ5KSB7XG4gIGlmIChpc0N1c3RvbUNvbXBvbmVudCh0eXBlLCBwcm9wcykpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB3YXJuVW5rbm93blByb3BlcnRpZXModHlwZSwgcHJvcHMsIGV2ZW50UmVnaXN0cnkpO1xufVxuXG52YXIgSVNfRVZFTlRfSEFORExFX05PTl9NQU5BR0VEX05PREUgPSAxO1xudmFyIElTX05PTl9ERUxFR0FURUQgPSAxIDw8IDE7XG52YXIgSVNfQ0FQVFVSRV9QSEFTRSA9IDEgPDwgMjtcbnZhciBJU19SRVBMQVlFRCA9IDEgPDwgNDtcbi8vIHNldCB0byBMRUdBQ1lfRkJfU1VQUE9SVC4gTEVHQUNZX0ZCX1NVUFBPUlQgb25seSBnZXRzIHNldCB3aGVuXG4vLyB3ZSBjYWxsIHdpbGxEZWZlckxhdGVyRm9yTGVnYWN5RkJTdXBwb3J0LCB0aHVzIG5vdCBiYWlsaW5nIG91dFxuLy8gd2lsbCByZXN1bHQgaW4gZW5kbGVzcyBjeWNsZXMgbGlrZSBhbiBpbmZpbml0ZSBsb29wLlxuLy8gV2UgYWxzbyBkb24ndCB3YW50IHRvIGRlZmVyIGR1cmluZyBldmVudCByZXBsYXlpbmcuXG5cbnZhciBTSE9VTERfTk9UX1BST0NFU1NfUE9MWUZJTExfRVZFTlRfUExVR0lOUyA9IElTX0VWRU5UX0hBTkRMRV9OT05fTUFOQUdFRF9OT0RFIHwgSVNfTk9OX0RFTEVHQVRFRCB8IElTX0NBUFRVUkVfUEhBU0U7XG5cbi8qKlxuICogR2V0cyB0aGUgdGFyZ2V0IG5vZGUgZnJvbSBhIG5hdGl2ZSBicm93c2VyIGV2ZW50IGJ5IGFjY291bnRpbmcgZm9yXG4gKiBpbmNvbnNpc3RlbmNpZXMgaW4gYnJvd3NlciBET00gQVBJcy5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAcmV0dXJuIHtET01FdmVudFRhcmdldH0gVGFyZ2V0IG5vZGUuXG4gKi9cblxuZnVuY3Rpb24gZ2V0RXZlbnRUYXJnZXQobmF0aXZlRXZlbnQpIHtcbiAgLy8gRmFsbGJhY2sgdG8gbmF0aXZlRXZlbnQuc3JjRWxlbWVudCBmb3IgSUU5XG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTI1MDZcbiAgdmFyIHRhcmdldCA9IG5hdGl2ZUV2ZW50LnRhcmdldCB8fCBuYXRpdmVFdmVudC5zcmNFbGVtZW50IHx8IHdpbmRvdzsgLy8gTm9ybWFsaXplIFNWRyA8dXNlPiBlbGVtZW50IGV2ZW50cyAjNDk2M1xuXG4gIGlmICh0YXJnZXQuY29ycmVzcG9uZGluZ1VzZUVsZW1lbnQpIHtcbiAgICB0YXJnZXQgPSB0YXJnZXQuY29ycmVzcG9uZGluZ1VzZUVsZW1lbnQ7XG4gIH0gLy8gU2FmYXJpIG1heSBmaXJlIGV2ZW50cyBvbiB0ZXh0IG5vZGVzIChOb2RlLlRFWFRfTk9ERSBpcyAzKS5cbiAgLy8gQHNlZSBodHRwOi8vd3d3LnF1aXJrc21vZGUub3JnL2pzL2V2ZW50c19wcm9wZXJ0aWVzLmh0bWxcblxuXG4gIHJldHVybiB0YXJnZXQubm9kZVR5cGUgPT09IFRFWFRfTk9ERSA/IHRhcmdldC5wYXJlbnROb2RlIDogdGFyZ2V0O1xufVxuXG52YXIgcmVzdG9yZUltcGwgPSBudWxsO1xudmFyIHJlc3RvcmVUYXJnZXQgPSBudWxsO1xudmFyIHJlc3RvcmVRdWV1ZSA9IG51bGw7XG5cbmZ1bmN0aW9uIHJlc3RvcmVTdGF0ZU9mVGFyZ2V0KHRhcmdldCkge1xuICAvLyBXZSBwZXJmb3JtIHRoaXMgdHJhbnNsYXRpb24gYXQgdGhlIGVuZCBvZiB0aGUgZXZlbnQgbG9vcCBzbyB0aGF0IHdlXG4gIC8vIGFsd2F5cyByZWNlaXZlIHRoZSBjb3JyZWN0IGZpYmVyIGhlcmVcbiAgdmFyIGludGVybmFsSW5zdGFuY2UgPSBnZXRJbnN0YW5jZUZyb21Ob2RlKHRhcmdldCk7XG5cbiAgaWYgKCFpbnRlcm5hbEluc3RhbmNlKSB7XG4gICAgLy8gVW5tb3VudGVkXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKCEodHlwZW9mIHJlc3RvcmVJbXBsID09PSAnZnVuY3Rpb24nKSkge1xuICAgIHtcbiAgICAgIHRocm93IEVycm9yKCBcInNldFJlc3RvcmVJbXBsZW1lbnRhdGlvbigpIG5lZWRzIHRvIGJlIGNhbGxlZCB0byBoYW5kbGUgYSB0YXJnZXQgZm9yIGNvbnRyb2xsZWQgZXZlbnRzLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiICk7XG4gICAgfVxuICB9XG5cbiAgdmFyIHN0YXRlTm9kZSA9IGludGVybmFsSW5zdGFuY2Uuc3RhdGVOb2RlOyAvLyBHdWFyZCBhZ2FpbnN0IEZpYmVyIGJlaW5nIHVubW91bnRlZC5cblxuICBpZiAoc3RhdGVOb2RlKSB7XG4gICAgdmFyIF9wcm9wcyA9IGdldEZpYmVyQ3VycmVudFByb3BzRnJvbU5vZGUoc3RhdGVOb2RlKTtcblxuICAgIHJlc3RvcmVJbXBsKGludGVybmFsSW5zdGFuY2Uuc3RhdGVOb2RlLCBpbnRlcm5hbEluc3RhbmNlLnR5cGUsIF9wcm9wcyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc2V0UmVzdG9yZUltcGxlbWVudGF0aW9uKGltcGwpIHtcbiAgcmVzdG9yZUltcGwgPSBpbXBsO1xufVxuZnVuY3Rpb24gZW5xdWV1ZVN0YXRlUmVzdG9yZSh0YXJnZXQpIHtcbiAgaWYgKHJlc3RvcmVUYXJnZXQpIHtcbiAgICBpZiAocmVzdG9yZVF1ZXVlKSB7XG4gICAgICByZXN0b3JlUXVldWUucHVzaCh0YXJnZXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN0b3JlUXVldWUgPSBbdGFyZ2V0XTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcmVzdG9yZVRhcmdldCA9IHRhcmdldDtcbiAgfVxufVxuZnVuY3Rpb24gbmVlZHNTdGF0ZVJlc3RvcmUoKSB7XG4gIHJldHVybiByZXN0b3JlVGFyZ2V0ICE9PSBudWxsIHx8IHJlc3RvcmVRdWV1ZSAhPT0gbnVsbDtcbn1cbmZ1bmN0aW9uIHJlc3RvcmVTdGF0ZUlmTmVlZGVkKCkge1xuICBpZiAoIXJlc3RvcmVUYXJnZXQpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgdGFyZ2V0ID0gcmVzdG9yZVRhcmdldDtcbiAgdmFyIHF1ZXVlZFRhcmdldHMgPSByZXN0b3JlUXVldWU7XG4gIHJlc3RvcmVUYXJnZXQgPSBudWxsO1xuICByZXN0b3JlUXVldWUgPSBudWxsO1xuICByZXN0b3JlU3RhdGVPZlRhcmdldCh0YXJnZXQpO1xuXG4gIGlmIChxdWV1ZWRUYXJnZXRzKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBxdWV1ZWRUYXJnZXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICByZXN0b3JlU3RhdGVPZlRhcmdldChxdWV1ZWRUYXJnZXRzW2ldKTtcbiAgICB9XG4gIH1cbn1cblxuLy8gdGhlIHJlbmRlcmVyLiBTdWNoIGFzIHdoZW4gd2UncmUgZGlzcGF0Y2hpbmcgZXZlbnRzIG9yIGlmIHRoaXJkIHBhcnR5XG4vLyBsaWJyYXJpZXMgbmVlZCB0byBjYWxsIGJhdGNoZWRVcGRhdGVzLiBFdmVudHVhbGx5LCB0aGlzIEFQSSB3aWxsIGdvIGF3YXkgd2hlblxuLy8gZXZlcnl0aGluZyBpcyBiYXRjaGVkIGJ5IGRlZmF1bHQuIFdlJ2xsIHRoZW4gaGF2ZSBhIHNpbWlsYXIgQVBJIHRvIG9wdC1vdXQgb2Zcbi8vIHNjaGVkdWxlZCB3b3JrIGFuZCBpbnN0ZWFkIGRvIHN5bmNocm9ub3VzIHdvcmsuXG4vLyBEZWZhdWx0c1xuXG52YXIgYmF0Y2hlZFVwZGF0ZXNJbXBsID0gZnVuY3Rpb24gKGZuLCBib29ra2VlcGluZykge1xuICByZXR1cm4gZm4oYm9va2tlZXBpbmcpO1xufTtcblxudmFyIGRpc2NyZXRlVXBkYXRlc0ltcGwgPSBmdW5jdGlvbiAoZm4sIGEsIGIsIGMsIGQpIHtcbiAgcmV0dXJuIGZuKGEsIGIsIGMsIGQpO1xufTtcblxudmFyIGZsdXNoRGlzY3JldGVVcGRhdGVzSW1wbCA9IGZ1bmN0aW9uICgpIHt9O1xuXG52YXIgYmF0Y2hlZEV2ZW50VXBkYXRlc0ltcGwgPSBiYXRjaGVkVXBkYXRlc0ltcGw7XG52YXIgaXNJbnNpZGVFdmVudEhhbmRsZXIgPSBmYWxzZTtcbnZhciBpc0JhdGNoaW5nRXZlbnRVcGRhdGVzID0gZmFsc2U7XG5cbmZ1bmN0aW9uIGZpbmlzaEV2ZW50SGFuZGxlcigpIHtcbiAgLy8gSGVyZSB3ZSB3YWl0IHVudGlsIGFsbCB1cGRhdGVzIGhhdmUgcHJvcGFnYXRlZCwgd2hpY2ggaXMgaW1wb3J0YW50XG4gIC8vIHdoZW4gdXNpbmcgY29udHJvbGxlZCBjb21wb25lbnRzIHdpdGhpbiBsYXllcnM6XG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTY5OFxuICAvLyBUaGVuIHdlIHJlc3RvcmUgc3RhdGUgb2YgYW55IGNvbnRyb2xsZWQgY29tcG9uZW50LlxuICB2YXIgY29udHJvbGxlZENvbXBvbmVudHNIYXZlUGVuZGluZ1VwZGF0ZXMgPSBuZWVkc1N0YXRlUmVzdG9yZSgpO1xuXG4gIGlmIChjb250cm9sbGVkQ29tcG9uZW50c0hhdmVQZW5kaW5nVXBkYXRlcykge1xuICAgIC8vIElmIGEgY29udHJvbGxlZCBldmVudCB3YXMgZmlyZWQsIHdlIG1heSBuZWVkIHRvIHJlc3RvcmUgdGhlIHN0YXRlIG9mXG4gICAgLy8gdGhlIERPTSBub2RlIGJhY2sgdG8gdGhlIGNvbnRyb2xsZWQgdmFsdWUuIFRoaXMgaXMgbmVjZXNzYXJ5IHdoZW4gUmVhY3RcbiAgICAvLyBiYWlscyBvdXQgb2YgdGhlIHVwZGF0ZSB3aXRob3V0IHRvdWNoaW5nIHRoZSBET00uXG4gICAgZmx1c2hEaXNjcmV0ZVVwZGF0ZXNJbXBsKCk7XG4gICAgcmVzdG9yZVN0YXRlSWZOZWVkZWQoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBiYXRjaGVkVXBkYXRlcyhmbiwgYm9va2tlZXBpbmcpIHtcbiAgaWYgKGlzSW5zaWRlRXZlbnRIYW5kbGVyKSB7XG4gICAgLy8gSWYgd2UgYXJlIGN1cnJlbnRseSBpbnNpZGUgYW5vdGhlciBiYXRjaCwgd2UgbmVlZCB0byB3YWl0IHVudGlsIGl0XG4gICAgLy8gZnVsbHkgY29tcGxldGVzIGJlZm9yZSByZXN0b3Jpbmcgc3RhdGUuXG4gICAgcmV0dXJuIGZuKGJvb2trZWVwaW5nKTtcbiAgfVxuXG4gIGlzSW5zaWRlRXZlbnRIYW5kbGVyID0gdHJ1ZTtcblxuICB0cnkge1xuICAgIHJldHVybiBiYXRjaGVkVXBkYXRlc0ltcGwoZm4sIGJvb2trZWVwaW5nKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBpc0luc2lkZUV2ZW50SGFuZGxlciA9IGZhbHNlO1xuICAgIGZpbmlzaEV2ZW50SGFuZGxlcigpO1xuICB9XG59XG5mdW5jdGlvbiBiYXRjaGVkRXZlbnRVcGRhdGVzKGZuLCBhLCBiKSB7XG4gIGlmIChpc0JhdGNoaW5nRXZlbnRVcGRhdGVzKSB7XG4gICAgLy8gSWYgd2UgYXJlIGN1cnJlbnRseSBpbnNpZGUgYW5vdGhlciBiYXRjaCwgd2UgbmVlZCB0byB3YWl0IHVudGlsIGl0XG4gICAgLy8gZnVsbHkgY29tcGxldGVzIGJlZm9yZSByZXN0b3Jpbmcgc3RhdGUuXG4gICAgcmV0dXJuIGZuKGEsIGIpO1xuICB9XG5cbiAgaXNCYXRjaGluZ0V2ZW50VXBkYXRlcyA9IHRydWU7XG5cbiAgdHJ5IHtcbiAgICByZXR1cm4gYmF0Y2hlZEV2ZW50VXBkYXRlc0ltcGwoZm4sIGEsIGIpO1xuICB9IGZpbmFsbHkge1xuICAgIGlzQmF0Y2hpbmdFdmVudFVwZGF0ZXMgPSBmYWxzZTtcbiAgICBmaW5pc2hFdmVudEhhbmRsZXIoKTtcbiAgfVxufVxuZnVuY3Rpb24gZGlzY3JldGVVcGRhdGVzKGZuLCBhLCBiLCBjLCBkKSB7XG4gIHZhciBwcmV2SXNJbnNpZGVFdmVudEhhbmRsZXIgPSBpc0luc2lkZUV2ZW50SGFuZGxlcjtcbiAgaXNJbnNpZGVFdmVudEhhbmRsZXIgPSB0cnVlO1xuXG4gIHRyeSB7XG4gICAgcmV0dXJuIGRpc2NyZXRlVXBkYXRlc0ltcGwoZm4sIGEsIGIsIGMsIGQpO1xuICB9IGZpbmFsbHkge1xuICAgIGlzSW5zaWRlRXZlbnRIYW5kbGVyID0gcHJldklzSW5zaWRlRXZlbnRIYW5kbGVyO1xuXG4gICAgaWYgKCFpc0luc2lkZUV2ZW50SGFuZGxlcikge1xuICAgICAgZmluaXNoRXZlbnRIYW5kbGVyKCk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBmbHVzaERpc2NyZXRlVXBkYXRlc0lmTmVlZGVkKHRpbWVTdGFtcCkge1xuICB7XG4gICAgaWYgKCFpc0luc2lkZUV2ZW50SGFuZGxlcikge1xuICAgICAgZmx1c2hEaXNjcmV0ZVVwZGF0ZXNJbXBsKCk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBzZXRCYXRjaGluZ0ltcGxlbWVudGF0aW9uKF9iYXRjaGVkVXBkYXRlc0ltcGwsIF9kaXNjcmV0ZVVwZGF0ZXNJbXBsLCBfZmx1c2hEaXNjcmV0ZVVwZGF0ZXNJbXBsLCBfYmF0Y2hlZEV2ZW50VXBkYXRlc0ltcGwpIHtcbiAgYmF0Y2hlZFVwZGF0ZXNJbXBsID0gX2JhdGNoZWRVcGRhdGVzSW1wbDtcbiAgZGlzY3JldGVVcGRhdGVzSW1wbCA9IF9kaXNjcmV0ZVVwZGF0ZXNJbXBsO1xuICBmbHVzaERpc2NyZXRlVXBkYXRlc0ltcGwgPSBfZmx1c2hEaXNjcmV0ZVVwZGF0ZXNJbXBsO1xuICBiYXRjaGVkRXZlbnRVcGRhdGVzSW1wbCA9IF9iYXRjaGVkRXZlbnRVcGRhdGVzSW1wbDtcbn1cblxuZnVuY3Rpb24gaXNJbnRlcmFjdGl2ZSh0YWcpIHtcbiAgcmV0dXJuIHRhZyA9PT0gJ2J1dHRvbicgfHwgdGFnID09PSAnaW5wdXQnIHx8IHRhZyA9PT0gJ3NlbGVjdCcgfHwgdGFnID09PSAndGV4dGFyZWEnO1xufVxuXG5mdW5jdGlvbiBzaG91bGRQcmV2ZW50TW91c2VFdmVudChuYW1lLCB0eXBlLCBwcm9wcykge1xuICBzd2l0Y2ggKG5hbWUpIHtcbiAgICBjYXNlICdvbkNsaWNrJzpcbiAgICBjYXNlICdvbkNsaWNrQ2FwdHVyZSc6XG4gICAgY2FzZSAnb25Eb3VibGVDbGljayc6XG4gICAgY2FzZSAnb25Eb3VibGVDbGlja0NhcHR1cmUnOlxuICAgIGNhc2UgJ29uTW91c2VEb3duJzpcbiAgICBjYXNlICdvbk1vdXNlRG93bkNhcHR1cmUnOlxuICAgIGNhc2UgJ29uTW91c2VNb3ZlJzpcbiAgICBjYXNlICdvbk1vdXNlTW92ZUNhcHR1cmUnOlxuICAgIGNhc2UgJ29uTW91c2VVcCc6XG4gICAgY2FzZSAnb25Nb3VzZVVwQ2FwdHVyZSc6XG4gICAgY2FzZSAnb25Nb3VzZUVudGVyJzpcbiAgICAgIHJldHVybiAhIShwcm9wcy5kaXNhYmxlZCAmJiBpc0ludGVyYWN0aXZlKHR5cGUpKTtcblxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IGluc3QgVGhlIGluc3RhbmNlLCB3aGljaCBpcyB0aGUgc291cmNlIG9mIGV2ZW50cy5cbiAqIEBwYXJhbSB7c3RyaW5nfSByZWdpc3RyYXRpb25OYW1lIE5hbWUgb2YgbGlzdGVuZXIgKGUuZy4gYG9uQ2xpY2tgKS5cbiAqIEByZXR1cm4gez9mdW5jdGlvbn0gVGhlIHN0b3JlZCBjYWxsYmFjay5cbiAqL1xuXG5cbmZ1bmN0aW9uIGdldExpc3RlbmVyKGluc3QsIHJlZ2lzdHJhdGlvbk5hbWUpIHtcbiAgdmFyIHN0YXRlTm9kZSA9IGluc3Quc3RhdGVOb2RlO1xuXG4gIGlmIChzdGF0ZU5vZGUgPT09IG51bGwpIHtcbiAgICAvLyBXb3JrIGluIHByb2dyZXNzIChleDogb25sb2FkIGV2ZW50cyBpbiBpbmNyZW1lbnRhbCBtb2RlKS5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBwcm9wcyA9IGdldEZpYmVyQ3VycmVudFByb3BzRnJvbU5vZGUoc3RhdGVOb2RlKTtcblxuICBpZiAocHJvcHMgPT09IG51bGwpIHtcbiAgICAvLyBXb3JrIGluIHByb2dyZXNzLlxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIGxpc3RlbmVyID0gcHJvcHNbcmVnaXN0cmF0aW9uTmFtZV07XG5cbiAgaWYgKHNob3VsZFByZXZlbnRNb3VzZUV2ZW50KHJlZ2lzdHJhdGlvbk5hbWUsIGluc3QudHlwZSwgcHJvcHMpKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBpZiAoISghbGlzdGVuZXIgfHwgdHlwZW9mIGxpc3RlbmVyID09PSAnZnVuY3Rpb24nKSkge1xuICAgIHtcbiAgICAgIHRocm93IEVycm9yKCBcIkV4cGVjdGVkIGBcIiArIHJlZ2lzdHJhdGlvbk5hbWUgKyBcImAgbGlzdGVuZXIgdG8gYmUgYSBmdW5jdGlvbiwgaW5zdGVhZCBnb3QgYSB2YWx1ZSBvZiBgXCIgKyB0eXBlb2YgbGlzdGVuZXIgKyBcImAgdHlwZS5cIiApO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBsaXN0ZW5lcjtcbn1cblxudmFyIHBhc3NpdmVCcm93c2VyRXZlbnRzU3VwcG9ydGVkID0gZmFsc2U7IC8vIENoZWNrIGlmIGJyb3dzZXIgc3VwcG9ydCBldmVudHMgd2l0aCBwYXNzaXZlIGxpc3RlbmVyc1xuLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0V2ZW50VGFyZ2V0L2FkZEV2ZW50TGlzdGVuZXIjU2FmZWx5X2RldGVjdGluZ19vcHRpb25fc3VwcG9ydFxuXG5pZiAoY2FuVXNlRE9NKSB7XG4gIHRyeSB7XG4gICAgdmFyIG9wdGlvbnMgPSB7fTsgLy8gJEZsb3dGaXhNZTogSWdub3JlIEZsb3cgY29tcGxhaW5pbmcgYWJvdXQgbmVlZGluZyBhIHZhbHVlXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob3B0aW9ucywgJ3Bhc3NpdmUnLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcGFzc2l2ZUJyb3dzZXJFdmVudHNTdXBwb3J0ZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCd0ZXN0Jywgb3B0aW9ucywgb3B0aW9ucyk7XG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Rlc3QnLCBvcHRpb25zLCBvcHRpb25zKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHBhc3NpdmVCcm93c2VyRXZlbnRzU3VwcG9ydGVkID0gZmFsc2U7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW52b2tlR3VhcmRlZENhbGxiYWNrUHJvZChuYW1lLCBmdW5jLCBjb250ZXh0LCBhLCBiLCBjLCBkLCBlLCBmKSB7XG4gIHZhciBmdW5jQXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMyk7XG5cbiAgdHJ5IHtcbiAgICBmdW5jLmFwcGx5KGNvbnRleHQsIGZ1bmNBcmdzKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICB0aGlzLm9uRXJyb3IoZXJyb3IpO1xuICB9XG59XG5cbnZhciBpbnZva2VHdWFyZGVkQ2FsbGJhY2tJbXBsID0gaW52b2tlR3VhcmRlZENhbGxiYWNrUHJvZDtcblxue1xuICAvLyBJbiBERVYgbW9kZSwgd2Ugc3dhcCBvdXQgaW52b2tlR3VhcmRlZENhbGxiYWNrIGZvciBhIHNwZWNpYWwgdmVyc2lvblxuICAvLyB0aGF0IHBsYXlzIG1vcmUgbmljZWx5IHdpdGggdGhlIGJyb3dzZXIncyBEZXZUb29scy4gVGhlIGlkZWEgaXMgdG8gcHJlc2VydmVcbiAgLy8gXCJQYXVzZSBvbiBleGNlcHRpb25zXCIgYmVoYXZpb3IuIEJlY2F1c2UgUmVhY3Qgd3JhcHMgYWxsIHVzZXItcHJvdmlkZWRcbiAgLy8gZnVuY3Rpb25zIGluIGludm9rZUd1YXJkZWRDYWxsYmFjaywgYW5kIHRoZSBwcm9kdWN0aW9uIHZlcnNpb24gb2ZcbiAgLy8gaW52b2tlR3VhcmRlZENhbGxiYWNrIHVzZXMgYSB0cnktY2F0Y2gsIGFsbCB1c2VyIGV4Y2VwdGlvbnMgYXJlIHRyZWF0ZWRcbiAgLy8gbGlrZSBjYXVnaHQgZXhjZXB0aW9ucywgYW5kIHRoZSBEZXZUb29scyB3b24ndCBwYXVzZSB1bmxlc3MgdGhlIGRldmVsb3BlclxuICAvLyB0YWtlcyB0aGUgZXh0cmEgc3RlcCBvZiBlbmFibGluZyBwYXVzZSBvbiBjYXVnaHQgZXhjZXB0aW9ucy4gVGhpcyBpc1xuICAvLyB1bmludHVpdGl2ZSwgdGhvdWdoLCBiZWNhdXNlIGV2ZW4gdGhvdWdoIFJlYWN0IGhhcyBjYXVnaHQgdGhlIGVycm9yLCBmcm9tXG4gIC8vIHRoZSBkZXZlbG9wZXIncyBwZXJzcGVjdGl2ZSwgdGhlIGVycm9yIGlzIHVuY2F1Z2h0LlxuICAvL1xuICAvLyBUbyBwcmVzZXJ2ZSB0aGUgZXhwZWN0ZWQgXCJQYXVzZSBvbiBleGNlcHRpb25zXCIgYmVoYXZpb3IsIHdlIGRvbid0IHVzZSBhXG4gIC8vIHRyeS1jYXRjaCBpbiBERVYuIEluc3RlYWQsIHdlIHN5bmNocm9ub3VzbHkgZGlzcGF0Y2ggYSBmYWtlIGV2ZW50IHRvIGEgZmFrZVxuICAvLyBET00gbm9kZSwgYW5kIGNhbGwgdGhlIHVzZXItcHJvdmlkZWQgY2FsbGJhY2sgZnJvbSBpbnNpZGUgYW4gZXZlbnQgaGFuZGxlclxuICAvLyBmb3IgdGhhdCBmYWtlIGV2ZW50LiBJZiB0aGUgY2FsbGJhY2sgdGhyb3dzLCB0aGUgZXJyb3IgaXMgXCJjYXB0dXJlZFwiIHVzaW5nXG4gIC8vIGEgZ2xvYmFsIGV2ZW50IGhhbmRsZXIuIEJ1dCBiZWNhdXNlIHRoZSBlcnJvciBoYXBwZW5zIGluIGEgZGlmZmVyZW50XG4gIC8vIGV2ZW50IGxvb3AgY29udGV4dCwgaXQgZG9lcyBub3QgaW50ZXJydXB0IHRoZSBub3JtYWwgcHJvZ3JhbSBmbG93LlxuICAvLyBFZmZlY3RpdmVseSwgdGhpcyBnaXZlcyB1cyB0cnktY2F0Y2ggYmVoYXZpb3Igd2l0aG91dCBhY3R1YWxseSB1c2luZ1xuICAvLyB0cnktY2F0Y2guIE5lYXQhXG4gIC8vIENoZWNrIHRoYXQgdGhlIGJyb3dzZXIgc3VwcG9ydHMgdGhlIEFQSXMgd2UgbmVlZCB0byBpbXBsZW1lbnQgb3VyIHNwZWNpYWxcbiAgLy8gREVWIHZlcnNpb24gb2YgaW52b2tlR3VhcmRlZENhbGxiYWNrXG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygd2luZG93LmRpc3BhdGNoRXZlbnQgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgZG9jdW1lbnQuY3JlYXRlRXZlbnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICB2YXIgZmFrZU5vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdyZWFjdCcpO1xuXG4gICAgaW52b2tlR3VhcmRlZENhbGxiYWNrSW1wbCA9IGZ1bmN0aW9uIGludm9rZUd1YXJkZWRDYWxsYmFja0RldihuYW1lLCBmdW5jLCBjb250ZXh0LCBhLCBiLCBjLCBkLCBlLCBmKSB7XG4gICAgICAvLyBJZiBkb2N1bWVudCBkb2Vzbid0IGV4aXN0IHdlIGtub3cgZm9yIHN1cmUgd2Ugd2lsbCBjcmFzaCBpbiB0aGlzIG1ldGhvZFxuICAgICAgLy8gd2hlbiB3ZSBjYWxsIGRvY3VtZW50LmNyZWF0ZUV2ZW50KCkuIEhvd2V2ZXIgdGhpcyBjYW4gY2F1c2UgY29uZnVzaW5nXG4gICAgICAvLyBlcnJvcnM6IGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9va2luY3ViYXRvci9jcmVhdGUtcmVhY3QtYXBwL2lzc3Vlcy8zNDgyXG4gICAgICAvLyBTbyB3ZSBwcmVlbXB0aXZlbHkgdGhyb3cgd2l0aCBhIGJldHRlciBtZXNzYWdlIGluc3RlYWQuXG4gICAgICBpZiAoISh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnKSkge1xuICAgICAgICB7XG4gICAgICAgICAgdGhyb3cgRXJyb3IoIFwiVGhlIGBkb2N1bWVudGAgZ2xvYmFsIHdhcyBkZWZpbmVkIHdoZW4gUmVhY3Qgd2FzIGluaXRpYWxpemVkLCBidXQgaXMgbm90IGRlZmluZWQgYW55bW9yZS4gVGhpcyBjYW4gaGFwcGVuIGluIGEgdGVzdCBlbnZpcm9ubWVudCBpZiBhIGNvbXBvbmVudCBzY2hlZHVsZXMgYW4gdXBkYXRlIGZyb20gYW4gYXN5bmNocm9ub3VzIGNhbGxiYWNrLCBidXQgdGhlIHRlc3QgaGFzIGFscmVhZHkgZmluaXNoZWQgcnVubmluZy4gVG8gc29sdmUgdGhpcywgeW91IGNhbiBlaXRoZXIgdW5tb3VudCB0aGUgY29tcG9uZW50IGF0IHRoZSBlbmQgb2YgeW91ciB0ZXN0IChhbmQgZW5zdXJlIHRoYXQgYW55IGFzeW5jaHJvbm91cyBvcGVyYXRpb25zIGdldCBjYW5jZWxlZCBpbiBgY29tcG9uZW50V2lsbFVubW91bnRgKSwgb3IgeW91IGNhbiBjaGFuZ2UgdGhlIHRlc3QgaXRzZWxmIHRvIGJlIGFzeW5jaHJvbm91cy5cIiApO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBldnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnRXZlbnQnKTtcbiAgICAgIHZhciBkaWRDYWxsID0gZmFsc2U7IC8vIEtlZXBzIHRyYWNrIG9mIHdoZXRoZXIgdGhlIHVzZXItcHJvdmlkZWQgY2FsbGJhY2sgdGhyZXcgYW4gZXJyb3IuIFdlXG4gICAgICAvLyBzZXQgdGhpcyB0byB0cnVlIGF0IHRoZSBiZWdpbm5pbmcsIHRoZW4gc2V0IGl0IHRvIGZhbHNlIHJpZ2h0IGFmdGVyXG4gICAgICAvLyBjYWxsaW5nIHRoZSBmdW5jdGlvbi4gSWYgdGhlIGZ1bmN0aW9uIGVycm9ycywgYGRpZEVycm9yYCB3aWxsIG5ldmVyIGJlXG4gICAgICAvLyBzZXQgdG8gZmFsc2UuIFRoaXMgc3RyYXRlZ3kgd29ya3MgZXZlbiBpZiB0aGUgYnJvd3NlciBpcyBmbGFreSBhbmRcbiAgICAgIC8vIGZhaWxzIHRvIGNhbGwgb3VyIGdsb2JhbCBlcnJvciBoYW5kbGVyLCBiZWNhdXNlIGl0IGRvZXNuJ3QgcmVseSBvblxuICAgICAgLy8gdGhlIGVycm9yIGV2ZW50IGF0IGFsbC5cblxuICAgICAgdmFyIGRpZEVycm9yID0gdHJ1ZTsgLy8gS2VlcHMgdHJhY2sgb2YgdGhlIHZhbHVlIG9mIHdpbmRvdy5ldmVudCBzbyB0aGF0IHdlIGNhbiByZXNldCBpdFxuICAgICAgLy8gZHVyaW5nIHRoZSBjYWxsYmFjayB0byBsZXQgdXNlciBjb2RlIGFjY2VzcyB3aW5kb3cuZXZlbnQgaW4gdGhlXG4gICAgICAvLyBicm93c2VycyB0aGF0IHN1cHBvcnQgaXQuXG5cbiAgICAgIHZhciB3aW5kb3dFdmVudCA9IHdpbmRvdy5ldmVudDsgLy8gS2VlcHMgdHJhY2sgb2YgdGhlIGRlc2NyaXB0b3Igb2Ygd2luZG93LmV2ZW50IHRvIHJlc3RvcmUgaXQgYWZ0ZXIgZXZlbnRcbiAgICAgIC8vIGRpc3BhdGNoaW5nOiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzEzNjg4XG5cbiAgICAgIHZhciB3aW5kb3dFdmVudERlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHdpbmRvdywgJ2V2ZW50Jyk7XG5cbiAgICAgIGZ1bmN0aW9uIHJlc3RvcmVBZnRlckRpc3BhdGNoKCkge1xuICAgICAgICAvLyBXZSBpbW1lZGlhdGVseSByZW1vdmUgdGhlIGNhbGxiYWNrIGZyb20gZXZlbnQgbGlzdGVuZXJzIHNvIHRoYXRcbiAgICAgICAgLy8gbmVzdGVkIGBpbnZva2VHdWFyZGVkQ2FsbGJhY2tgIGNhbGxzIGRvIG5vdCBjbGFzaC4gT3RoZXJ3aXNlLCBhXG4gICAgICAgIC8vIG5lc3RlZCBjYWxsIHdvdWxkIHRyaWdnZXIgdGhlIGZha2UgZXZlbnQgaGFuZGxlcnMgb2YgYW55IGNhbGwgaGlnaGVyXG4gICAgICAgIC8vIGluIHRoZSBzdGFjay5cbiAgICAgICAgZmFrZU5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihldnRUeXBlLCBjYWxsQ2FsbGJhY2ssIGZhbHNlKTsgLy8gV2UgY2hlY2sgZm9yIHdpbmRvdy5oYXNPd25Qcm9wZXJ0eSgnZXZlbnQnKSB0byBwcmV2ZW50IHRoZVxuICAgICAgICAvLyB3aW5kb3cuZXZlbnQgYXNzaWdubWVudCBpbiBib3RoIElFIDw9IDEwIGFzIHRoZXkgdGhyb3cgYW4gZXJyb3JcbiAgICAgICAgLy8gXCJNZW1iZXIgbm90IGZvdW5kXCIgaW4gc3RyaWN0IG1vZGUsIGFuZCBpbiBGaXJlZm94IHdoaWNoIGRvZXMgbm90XG4gICAgICAgIC8vIHN1cHBvcnQgd2luZG93LmV2ZW50LlxuXG4gICAgICAgIGlmICh0eXBlb2Ygd2luZG93LmV2ZW50ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuaGFzT3duUHJvcGVydHkoJ2V2ZW50JykpIHtcbiAgICAgICAgICB3aW5kb3cuZXZlbnQgPSB3aW5kb3dFdmVudDtcbiAgICAgICAgfVxuICAgICAgfSAvLyBDcmVhdGUgYW4gZXZlbnQgaGFuZGxlciBmb3Igb3VyIGZha2UgZXZlbnQuIFdlIHdpbGwgc3luY2hyb25vdXNseVxuICAgICAgLy8gZGlzcGF0Y2ggb3VyIGZha2UgZXZlbnQgdXNpbmcgYGRpc3BhdGNoRXZlbnRgLiBJbnNpZGUgdGhlIGhhbmRsZXIsIHdlXG4gICAgICAvLyBjYWxsIHRoZSB1c2VyLXByb3ZpZGVkIGNhbGxiYWNrLlxuXG5cbiAgICAgIHZhciBmdW5jQXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMyk7XG5cbiAgICAgIGZ1bmN0aW9uIGNhbGxDYWxsYmFjaygpIHtcbiAgICAgICAgZGlkQ2FsbCA9IHRydWU7XG4gICAgICAgIHJlc3RvcmVBZnRlckRpc3BhdGNoKCk7XG4gICAgICAgIGZ1bmMuYXBwbHkoY29udGV4dCwgZnVuY0FyZ3MpO1xuICAgICAgICBkaWRFcnJvciA9IGZhbHNlO1xuICAgICAgfSAvLyBDcmVhdGUgYSBnbG9iYWwgZXJyb3IgZXZlbnQgaGFuZGxlci4gV2UgdXNlIHRoaXMgdG8gY2FwdHVyZSB0aGUgdmFsdWVcbiAgICAgIC8vIHRoYXQgd2FzIHRocm93bi4gSXQncyBwb3NzaWJsZSB0aGF0IHRoaXMgZXJyb3IgaGFuZGxlciB3aWxsIGZpcmUgbW9yZVxuICAgICAgLy8gdGhhbiBvbmNlOyBmb3IgZXhhbXBsZSwgaWYgbm9uLVJlYWN0IGNvZGUgYWxzbyBjYWxscyBgZGlzcGF0Y2hFdmVudGBcbiAgICAgIC8vIGFuZCBhIGhhbmRsZXIgZm9yIHRoYXQgZXZlbnQgdGhyb3dzLiBXZSBzaG91bGQgYmUgcmVzaWxpZW50IHRvIG1vc3Qgb2ZcbiAgICAgIC8vIHRob3NlIGNhc2VzLiBFdmVuIGlmIG91ciBlcnJvciBldmVudCBoYW5kbGVyIGZpcmVzIG1vcmUgdGhhbiBvbmNlLCB0aGVcbiAgICAgIC8vIGxhc3QgZXJyb3IgZXZlbnQgaXMgYWx3YXlzIHVzZWQuIElmIHRoZSBjYWxsYmFjayBhY3R1YWxseSBkb2VzIGVycm9yLFxuICAgICAgLy8gd2Uga25vdyB0aGF0IHRoZSBsYXN0IGVycm9yIGV2ZW50IGlzIHRoZSBjb3JyZWN0IG9uZSwgYmVjYXVzZSBpdCdzIG5vdFxuICAgICAgLy8gcG9zc2libGUgZm9yIGFueXRoaW5nIGVsc2UgdG8gaGF2ZSBoYXBwZW5lZCBpbiBiZXR3ZWVuIG91ciBjYWxsYmFja1xuICAgICAgLy8gZXJyb3JpbmcgYW5kIHRoZSBjb2RlIHRoYXQgZm9sbG93cyB0aGUgYGRpc3BhdGNoRXZlbnRgIGNhbGwgYmVsb3cuIElmXG4gICAgICAvLyB0aGUgY2FsbGJhY2sgZG9lc24ndCBlcnJvciwgYnV0IHRoZSBlcnJvciBldmVudCB3YXMgZmlyZWQsIHdlIGtub3cgdG9cbiAgICAgIC8vIGlnbm9yZSBpdCBiZWNhdXNlIGBkaWRFcnJvcmAgd2lsbCBiZSBmYWxzZSwgYXMgZGVzY3JpYmVkIGFib3ZlLlxuXG5cbiAgICAgIHZhciBlcnJvcjsgLy8gVXNlIHRoaXMgdG8gdHJhY2sgd2hldGhlciB0aGUgZXJyb3IgZXZlbnQgaXMgZXZlciBjYWxsZWQuXG5cbiAgICAgIHZhciBkaWRTZXRFcnJvciA9IGZhbHNlO1xuICAgICAgdmFyIGlzQ3Jvc3NPcmlnaW5FcnJvciA9IGZhbHNlO1xuXG4gICAgICBmdW5jdGlvbiBoYW5kbGVXaW5kb3dFcnJvcihldmVudCkge1xuICAgICAgICBlcnJvciA9IGV2ZW50LmVycm9yO1xuICAgICAgICBkaWRTZXRFcnJvciA9IHRydWU7XG5cbiAgICAgICAgaWYgKGVycm9yID09PSBudWxsICYmIGV2ZW50LmNvbG5vID09PSAwICYmIGV2ZW50LmxpbmVubyA9PT0gMCkge1xuICAgICAgICAgIGlzQ3Jvc3NPcmlnaW5FcnJvciA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXZlbnQuZGVmYXVsdFByZXZlbnRlZCkge1xuICAgICAgICAgIC8vIFNvbWUgb3RoZXIgZXJyb3IgaGFuZGxlciBoYXMgcHJldmVudGVkIGRlZmF1bHQuXG4gICAgICAgICAgLy8gQnJvd3NlcnMgc2lsZW5jZSB0aGUgZXJyb3IgcmVwb3J0IGlmIHRoaXMgaGFwcGVucy5cbiAgICAgICAgICAvLyBXZSdsbCByZW1lbWJlciB0aGlzIHRvIGxhdGVyIGRlY2lkZSB3aGV0aGVyIHRvIGxvZyBpdCBvciBub3QuXG4gICAgICAgICAgaWYgKGVycm9yICE9IG51bGwgJiYgdHlwZW9mIGVycm9yID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgZXJyb3IuX3N1cHByZXNzTG9nZ2luZyA9IHRydWU7XG4gICAgICAgICAgICB9IGNhdGNoIChpbm5lcikgey8vIElnbm9yZS5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gLy8gQ3JlYXRlIGEgZmFrZSBldmVudCB0eXBlLlxuXG5cbiAgICAgIHZhciBldnRUeXBlID0gXCJyZWFjdC1cIiArIChuYW1lID8gbmFtZSA6ICdpbnZva2VndWFyZGVkY2FsbGJhY2snKTsgLy8gQXR0YWNoIG91ciBldmVudCBoYW5kbGVyc1xuXG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCBoYW5kbGVXaW5kb3dFcnJvcik7XG4gICAgICBmYWtlTm9kZS5hZGRFdmVudExpc3RlbmVyKGV2dFR5cGUsIGNhbGxDYWxsYmFjaywgZmFsc2UpOyAvLyBTeW5jaHJvbm91c2x5IGRpc3BhdGNoIG91ciBmYWtlIGV2ZW50LiBJZiB0aGUgdXNlci1wcm92aWRlZCBmdW5jdGlvblxuICAgICAgLy8gZXJyb3JzLCBpdCB3aWxsIHRyaWdnZXIgb3VyIGdsb2JhbCBlcnJvciBoYW5kbGVyLlxuXG4gICAgICBldnQuaW5pdEV2ZW50KGV2dFR5cGUsIGZhbHNlLCBmYWxzZSk7XG4gICAgICBmYWtlTm9kZS5kaXNwYXRjaEV2ZW50KGV2dCk7XG5cbiAgICAgIGlmICh3aW5kb3dFdmVudERlc2NyaXB0b3IpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHdpbmRvdywgJ2V2ZW50Jywgd2luZG93RXZlbnREZXNjcmlwdG9yKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGRpZENhbGwgJiYgZGlkRXJyb3IpIHtcbiAgICAgICAgaWYgKCFkaWRTZXRFcnJvcikge1xuICAgICAgICAgIC8vIFRoZSBjYWxsYmFjayBlcnJvcmVkLCBidXQgdGhlIGVycm9yIGV2ZW50IG5ldmVyIGZpcmVkLlxuICAgICAgICAgIGVycm9yID0gbmV3IEVycm9yKCdBbiBlcnJvciB3YXMgdGhyb3duIGluc2lkZSBvbmUgb2YgeW91ciBjb21wb25lbnRzLCBidXQgUmVhY3QgJyArIFwiZG9lc24ndCBrbm93IHdoYXQgaXQgd2FzLiBUaGlzIGlzIGxpa2VseSBkdWUgdG8gYnJvd3NlciBcIiArICdmbGFraW5lc3MuIFJlYWN0IGRvZXMgaXRzIGJlc3QgdG8gcHJlc2VydmUgdGhlIFwiUGF1c2Ugb24gJyArICdleGNlcHRpb25zXCIgYmVoYXZpb3Igb2YgdGhlIERldlRvb2xzLCB3aGljaCByZXF1aXJlcyBzb21lICcgKyBcIkRFVi1tb2RlIG9ubHkgdHJpY2tzLiBJdCdzIHBvc3NpYmxlIHRoYXQgdGhlc2UgZG9uJ3Qgd29yayBpbiBcIiArICd5b3VyIGJyb3dzZXIuIFRyeSB0cmlnZ2VyaW5nIHRoZSBlcnJvciBpbiBwcm9kdWN0aW9uIG1vZGUsICcgKyAnb3Igc3dpdGNoaW5nIHRvIGEgbW9kZXJuIGJyb3dzZXIuIElmIHlvdSBzdXNwZWN0IHRoYXQgdGhpcyBpcyAnICsgJ2FjdHVhbGx5IGFuIGlzc3VlIHdpdGggUmVhY3QsIHBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzQ3Jvc3NPcmlnaW5FcnJvcikge1xuICAgICAgICAgIGVycm9yID0gbmV3IEVycm9yKFwiQSBjcm9zcy1vcmlnaW4gZXJyb3Igd2FzIHRocm93bi4gUmVhY3QgZG9lc24ndCBoYXZlIGFjY2VzcyB0byBcIiArICd0aGUgYWN0dWFsIGVycm9yIG9iamVjdCBpbiBkZXZlbG9wbWVudC4gJyArICdTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL2Nyb3Nzb3JpZ2luLWVycm9yIGZvciBtb3JlIGluZm9ybWF0aW9uLicpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5vbkVycm9yKGVycm9yKTtcbiAgICAgIH0gLy8gUmVtb3ZlIG91ciBldmVudCBsaXN0ZW5lcnNcblxuXG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignZXJyb3InLCBoYW5kbGVXaW5kb3dFcnJvcik7XG5cbiAgICAgIGlmICghZGlkQ2FsbCkge1xuICAgICAgICAvLyBTb21ldGhpbmcgd2VudCByZWFsbHkgd3JvbmcsIGFuZCBvdXIgZXZlbnQgd2FzIG5vdCBkaXNwYXRjaGVkLlxuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzE2NzM0XG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTY1ODVcbiAgICAgICAgLy8gRmFsbCBiYWNrIHRvIHRoZSBwcm9kdWN0aW9uIGltcGxlbWVudGF0aW9uLlxuICAgICAgICByZXN0b3JlQWZ0ZXJEaXNwYXRjaCgpO1xuICAgICAgICByZXR1cm4gaW52b2tlR3VhcmRlZENhbGxiYWNrUHJvZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuICAgIH07XG4gIH1cbn1cblxudmFyIGludm9rZUd1YXJkZWRDYWxsYmFja0ltcGwkMSA9IGludm9rZUd1YXJkZWRDYWxsYmFja0ltcGw7XG5cbnZhciBoYXNFcnJvciA9IGZhbHNlO1xudmFyIGNhdWdodEVycm9yID0gbnVsbDsgLy8gVXNlZCBieSBldmVudCBzeXN0ZW0gdG8gY2FwdHVyZS9yZXRocm93IHRoZSBmaXJzdCBlcnJvci5cblxudmFyIGhhc1JldGhyb3dFcnJvciA9IGZhbHNlO1xudmFyIHJldGhyb3dFcnJvciA9IG51bGw7XG52YXIgcmVwb3J0ZXIgPSB7XG4gIG9uRXJyb3I6IGZ1bmN0aW9uIChlcnJvcikge1xuICAgIGhhc0Vycm9yID0gdHJ1ZTtcbiAgICBjYXVnaHRFcnJvciA9IGVycm9yO1xuICB9XG59O1xuLyoqXG4gKiBDYWxsIGEgZnVuY3Rpb24gd2hpbGUgZ3VhcmRpbmcgYWdhaW5zdCBlcnJvcnMgdGhhdCBoYXBwZW5zIHdpdGhpbiBpdC5cbiAqIFJldHVybnMgYW4gZXJyb3IgaWYgaXQgdGhyb3dzLCBvdGhlcndpc2UgbnVsbC5cbiAqXG4gKiBJbiBwcm9kdWN0aW9uLCB0aGlzIGlzIGltcGxlbWVudGVkIHVzaW5nIGEgdHJ5LWNhdGNoLiBUaGUgcmVhc29uIHdlIGRvbid0XG4gKiB1c2UgYSB0cnktY2F0Y2ggZGlyZWN0bHkgaXMgc28gdGhhdCB3ZSBjYW4gc3dhcCBvdXQgYSBkaWZmZXJlbnRcbiAqIGltcGxlbWVudGF0aW9uIGluIERFViBtb2RlLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIG9mIHRoZSBndWFyZCB0byB1c2UgZm9yIGxvZ2dpbmcgb3IgZGVidWdnaW5nXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBpbnZva2VcbiAqIEBwYXJhbSB7Kn0gY29udGV4dCBUaGUgY29udGV4dCB0byB1c2Ugd2hlbiBjYWxsaW5nIHRoZSBmdW5jdGlvblxuICogQHBhcmFtIHsuLi4qfSBhcmdzIEFyZ3VtZW50cyBmb3IgZnVuY3Rpb25cbiAqL1xuXG5mdW5jdGlvbiBpbnZva2VHdWFyZGVkQ2FsbGJhY2sobmFtZSwgZnVuYywgY29udGV4dCwgYSwgYiwgYywgZCwgZSwgZikge1xuICBoYXNFcnJvciA9IGZhbHNlO1xuICBjYXVnaHRFcnJvciA9IG51bGw7XG4gIGludm9rZUd1YXJkZWRDYWxsYmFja0ltcGwkMS5hcHBseShyZXBvcnRlciwgYXJndW1lbnRzKTtcbn1cbi8qKlxuICogU2FtZSBhcyBpbnZva2VHdWFyZGVkQ2FsbGJhY2ssIGJ1dCBpbnN0ZWFkIG9mIHJldHVybmluZyBhbiBlcnJvciwgaXQgc3RvcmVzXG4gKiBpdCBpbiBhIGdsb2JhbCBzbyBpdCBjYW4gYmUgcmV0aHJvd24gYnkgYHJldGhyb3dDYXVnaHRFcnJvcmAgbGF0ZXIuXG4gKiBUT0RPOiBTZWUgaWYgY2F1Z2h0RXJyb3IgYW5kIHJldGhyb3dFcnJvciBjYW4gYmUgdW5pZmllZC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBvZiB0aGUgZ3VhcmQgdG8gdXNlIGZvciBsb2dnaW5nIG9yIGRlYnVnZ2luZ1xuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gaW52b2tlXG4gKiBAcGFyYW0geyp9IGNvbnRleHQgVGhlIGNvbnRleHQgdG8gdXNlIHdoZW4gY2FsbGluZyB0aGUgZnVuY3Rpb25cbiAqIEBwYXJhbSB7Li4uKn0gYXJncyBBcmd1bWVudHMgZm9yIGZ1bmN0aW9uXG4gKi9cblxuZnVuY3Rpb24gaW52b2tlR3VhcmRlZENhbGxiYWNrQW5kQ2F0Y2hGaXJzdEVycm9yKG5hbWUsIGZ1bmMsIGNvbnRleHQsIGEsIGIsIGMsIGQsIGUsIGYpIHtcbiAgaW52b2tlR3VhcmRlZENhbGxiYWNrLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgaWYgKGhhc0Vycm9yKSB7XG4gICAgdmFyIGVycm9yID0gY2xlYXJDYXVnaHRFcnJvcigpO1xuXG4gICAgaWYgKCFoYXNSZXRocm93RXJyb3IpIHtcbiAgICAgIGhhc1JldGhyb3dFcnJvciA9IHRydWU7XG4gICAgICByZXRocm93RXJyb3IgPSBlcnJvcjtcbiAgICB9XG4gIH1cbn1cbi8qKlxuICogRHVyaW5nIGV4ZWN1dGlvbiBvZiBndWFyZGVkIGZ1bmN0aW9ucyB3ZSB3aWxsIGNhcHR1cmUgdGhlIGZpcnN0IGVycm9yIHdoaWNoXG4gKiB3ZSB3aWxsIHJldGhyb3cgdG8gYmUgaGFuZGxlZCBieSB0aGUgdG9wIGxldmVsIGVycm9yIGhhbmRsZXIuXG4gKi9cblxuZnVuY3Rpb24gcmV0aHJvd0NhdWdodEVycm9yKCkge1xuICBpZiAoaGFzUmV0aHJvd0Vycm9yKSB7XG4gICAgdmFyIGVycm9yID0gcmV0aHJvd0Vycm9yO1xuICAgIGhhc1JldGhyb3dFcnJvciA9IGZhbHNlO1xuICAgIHJldGhyb3dFcnJvciA9IG51bGw7XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbn1cbmZ1bmN0aW9uIGhhc0NhdWdodEVycm9yKCkge1xuICByZXR1cm4gaGFzRXJyb3I7XG59XG5mdW5jdGlvbiBjbGVhckNhdWdodEVycm9yKCkge1xuICBpZiAoaGFzRXJyb3IpIHtcbiAgICB2YXIgZXJyb3IgPSBjYXVnaHRFcnJvcjtcbiAgICBoYXNFcnJvciA9IGZhbHNlO1xuICAgIGNhdWdodEVycm9yID0gbnVsbDtcbiAgICByZXR1cm4gZXJyb3I7XG4gIH0gZWxzZSB7XG4gICAge1xuICAgICAge1xuICAgICAgICB0aHJvdyBFcnJvciggXCJjbGVhckNhdWdodEVycm9yIHdhcyBjYWxsZWQgYnV0IG5vIGVycm9yIHdhcyBjYXB0dXJlZC4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS5cIiApO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIGBSZWFjdEluc3RhbmNlTWFwYCBtYWludGFpbnMgYSBtYXBwaW5nIGZyb20gYSBwdWJsaWMgZmFjaW5nIHN0YXRlZnVsXG4gKiBpbnN0YW5jZSAoa2V5KSBhbmQgdGhlIGludGVybmFsIHJlcHJlc2VudGF0aW9uICh2YWx1ZSkuIFRoaXMgYWxsb3dzIHB1YmxpY1xuICogbWV0aG9kcyB0byBhY2NlcHQgdGhlIHVzZXIgZmFjaW5nIGluc3RhbmNlIGFzIGFuIGFyZ3VtZW50IGFuZCBtYXAgdGhlbSBiYWNrXG4gKiB0byBpbnRlcm5hbCBtZXRob2RzLlxuICpcbiAqIE5vdGUgdGhhdCB0aGlzIG1vZHVsZSBpcyBjdXJyZW50bHkgc2hhcmVkIGFuZCBhc3N1bWVkIHRvIGJlIHN0YXRlbGVzcy5cbiAqIElmIHRoaXMgYmVjb21lcyBhbiBhY3R1YWwgTWFwLCB0aGF0IHdpbGwgYnJlYWsuXG4gKi9cbmZ1bmN0aW9uIGdldChrZXkpIHtcbiAgcmV0dXJuIGtleS5fcmVhY3RJbnRlcm5hbHM7XG59XG5mdW5jdGlvbiBoYXMoa2V5KSB7XG4gIHJldHVybiBrZXkuX3JlYWN0SW50ZXJuYWxzICE9PSB1bmRlZmluZWQ7XG59XG5mdW5jdGlvbiBzZXQoa2V5LCB2YWx1ZSkge1xuICBrZXkuX3JlYWN0SW50ZXJuYWxzID0gdmFsdWU7XG59XG5cbi8vIERvbid0IGNoYW5nZSB0aGVzZSB0d28gdmFsdWVzLiBUaGV5J3JlIHVzZWQgYnkgUmVhY3QgRGV2IFRvb2xzLlxudmFyIE5vRmxhZ3MgPVxuLyogICAgICAgICAgICAgICAgICAgICAgKi9cbjA7XG52YXIgUGVyZm9ybWVkV29yayA9XG4vKiAgICAgICAgICAgICAgICAqL1xuMTsgLy8gWW91IGNhbiBjaGFuZ2UgdGhlIHJlc3QgKGFuZCBhZGQgbW9yZSkuXG5cbnZhciBQbGFjZW1lbnQgPVxuLyogICAgICAgICAgICAgICAgICAgICovXG4yO1xudmFyIFVwZGF0ZSA9XG4vKiAgICAgICAgICAgICAgICAgICAgICAgKi9cbjQ7XG52YXIgUGxhY2VtZW50QW5kVXBkYXRlID1cbi8qICAgICAgICAgICAqL1xuNjtcbnZhciBEZWxldGlvbiA9XG4vKiAgICAgICAgICAgICAgICAgICAgICovXG44O1xudmFyIENvbnRlbnRSZXNldCA9XG4vKiAgICAgICAgICAgICAgICAgKi9cbjE2O1xudmFyIENhbGxiYWNrID1cbi8qICAgICAgICAgICAgICAgICAgICAgKi9cbjMyO1xudmFyIERpZENhcHR1cmUgPVxuLyogICAgICAgICAgICAgICAgICAgKi9cbjY0O1xudmFyIFJlZiA9XG4vKiAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbjEyODtcbnZhciBTbmFwc2hvdCA9XG4vKiAgICAgICAgICAgICAgICAgICAgICovXG4yNTY7XG52YXIgUGFzc2l2ZSA9XG4vKiAgICAgICAgICAgICAgICAgICAgICAqL1xuNTEyOyAvLyBUT0RPIChlZmZlY3RzKSBSZW1vdmUgdGhpcyBiaXQgb25jZSB0aGUgbmV3IHJlY29uY2lsZXIgaXMgc3luY2VkIHRvIHRoZSBvbGQuXG5cbnZhciBQYXNzaXZlVW5tb3VudFBlbmRpbmdEZXYgPVxuLyogICAgICovXG44MTkyO1xudmFyIEh5ZHJhdGluZyA9XG4vKiAgICAgICAgICAgICAgICAgICAgKi9cbjEwMjQ7XG52YXIgSHlkcmF0aW5nQW5kVXBkYXRlID1cbi8qICAgICAgICAgICAqL1xuMTAyODsgLy8gUGFzc2l2ZSAmIFVwZGF0ZSAmIENhbGxiYWNrICYgUmVmICYgU25hcHNob3RcblxudmFyIExpZmVjeWNsZUVmZmVjdE1hc2sgPVxuLyogICAgICAgICAgKi9cbjkzMjsgLy8gVW5pb24gb2YgYWxsIGhvc3QgZWZmZWN0c1xuXG52YXIgSG9zdEVmZmVjdE1hc2sgPVxuLyogICAgICAgICAgICAgICAqL1xuMjA0NzsgLy8gVGhlc2UgYXJlIG5vdCByZWFsbHkgc2lkZSBlZmZlY3RzLCBidXQgd2Ugc3RpbGwgcmV1c2UgdGhpcyBmaWVsZC5cblxudmFyIEluY29tcGxldGUgPVxuLyogICAgICAgICAgICAgICAgICAgKi9cbjIwNDg7XG52YXIgU2hvdWxkQ2FwdHVyZSA9XG4vKiAgICAgICAgICAgICAgICAqL1xuNDA5NjtcbnZhciBGb3JjZVVwZGF0ZUZvckxlZ2FjeVN1c3BlbnNlID1cbi8qICovXG4xNjM4NDsgLy8gU3RhdGljIHRhZ3MgZGVzY3JpYmUgYXNwZWN0cyBvZiBhIGZpYmVyIHRoYXQgYXJlIG5vdCBzcGVjaWZpYyB0byBhIHJlbmRlcixcblxudmFyIFJlYWN0Q3VycmVudE93bmVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3RDdXJyZW50T3duZXI7XG5mdW5jdGlvbiBnZXROZWFyZXN0TW91bnRlZEZpYmVyKGZpYmVyKSB7XG4gIHZhciBub2RlID0gZmliZXI7XG4gIHZhciBuZWFyZXN0TW91bnRlZCA9IGZpYmVyO1xuXG4gIGlmICghZmliZXIuYWx0ZXJuYXRlKSB7XG4gICAgLy8gSWYgdGhlcmUgaXMgbm8gYWx0ZXJuYXRlLCB0aGlzIG1pZ2h0IGJlIGEgbmV3IHRyZWUgdGhhdCBpc24ndCBpbnNlcnRlZFxuICAgIC8vIHlldC4gSWYgaXQgaXMsIHRoZW4gaXQgd2lsbCBoYXZlIGEgcGVuZGluZyBpbnNlcnRpb24gZWZmZWN0IG9uIGl0LlxuICAgIHZhciBuZXh0Tm9kZSA9IG5vZGU7XG5cbiAgICBkbyB7XG4gICAgICBub2RlID0gbmV4dE5vZGU7XG5cbiAgICAgIGlmICgobm9kZS5mbGFncyAmIChQbGFjZW1lbnQgfCBIeWRyYXRpbmcpKSAhPT0gTm9GbGFncykge1xuICAgICAgICAvLyBUaGlzIGlzIGFuIGluc2VydGlvbiBvciBpbi1wcm9ncmVzcyBoeWRyYXRpb24uIFRoZSBuZWFyZXN0IHBvc3NpYmxlXG4gICAgICAgIC8vIG1vdW50ZWQgZmliZXIgaXMgdGhlIHBhcmVudCBidXQgd2UgbmVlZCB0byBjb250aW51ZSB0byBmaWd1cmUgb3V0XG4gICAgICAgIC8vIGlmIHRoYXQgb25lIGlzIHN0aWxsIG1vdW50ZWQuXG4gICAgICAgIG5lYXJlc3RNb3VudGVkID0gbm9kZS5yZXR1cm47XG4gICAgICB9XG5cbiAgICAgIG5leHROb2RlID0gbm9kZS5yZXR1cm47XG4gICAgfSB3aGlsZSAobmV4dE5vZGUpO1xuICB9IGVsc2Uge1xuICAgIHdoaWxlIChub2RlLnJldHVybikge1xuICAgICAgbm9kZSA9IG5vZGUucmV0dXJuO1xuICAgIH1cbiAgfVxuXG4gIGlmIChub2RlLnRhZyA9PT0gSG9zdFJvb3QpIHtcbiAgICAvLyBUT0RPOiBDaGVjayBpZiB0aGlzIHdhcyBhIG5lc3RlZCBIb3N0Um9vdCB3aGVuIHVzZWQgd2l0aFxuICAgIC8vIHJlbmRlckNvbnRhaW5lckludG9TdWJ0cmVlLlxuICAgIHJldHVybiBuZWFyZXN0TW91bnRlZDtcbiAgfSAvLyBJZiB3ZSBkaWRuJ3QgaGl0IHRoZSByb290LCB0aGF0IG1lYW5zIHRoYXQgd2UncmUgaW4gYW4gZGlzY29ubmVjdGVkIHRyZWVcbiAgLy8gdGhhdCBoYXMgYmVlbiB1bm1vdW50ZWQuXG5cblxuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGdldFN1c3BlbnNlSW5zdGFuY2VGcm9tRmliZXIoZmliZXIpIHtcbiAgaWYgKGZpYmVyLnRhZyA9PT0gU3VzcGVuc2VDb21wb25lbnQpIHtcbiAgICB2YXIgc3VzcGVuc2VTdGF0ZSA9IGZpYmVyLm1lbW9pemVkU3RhdGU7XG5cbiAgICBpZiAoc3VzcGVuc2VTdGF0ZSA9PT0gbnVsbCkge1xuICAgICAgdmFyIGN1cnJlbnQgPSBmaWJlci5hbHRlcm5hdGU7XG5cbiAgICAgIGlmIChjdXJyZW50ICE9PSBudWxsKSB7XG4gICAgICAgIHN1c3BlbnNlU3RhdGUgPSBjdXJyZW50Lm1lbW9pemVkU3RhdGU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHN1c3BlbnNlU3RhdGUgIT09IG51bGwpIHtcbiAgICAgIHJldHVybiBzdXNwZW5zZVN0YXRlLmRlaHlkcmF0ZWQ7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBnZXRDb250YWluZXJGcm9tRmliZXIoZmliZXIpIHtcbiAgcmV0dXJuIGZpYmVyLnRhZyA9PT0gSG9zdFJvb3QgPyBmaWJlci5zdGF0ZU5vZGUuY29udGFpbmVySW5mbyA6IG51bGw7XG59XG5mdW5jdGlvbiBpc0ZpYmVyTW91bnRlZChmaWJlcikge1xuICByZXR1cm4gZ2V0TmVhcmVzdE1vdW50ZWRGaWJlcihmaWJlcikgPT09IGZpYmVyO1xufVxuZnVuY3Rpb24gaXNNb3VudGVkKGNvbXBvbmVudCkge1xuICB7XG4gICAgdmFyIG93bmVyID0gUmVhY3RDdXJyZW50T3duZXIuY3VycmVudDtcblxuICAgIGlmIChvd25lciAhPT0gbnVsbCAmJiBvd25lci50YWcgPT09IENsYXNzQ29tcG9uZW50KSB7XG4gICAgICB2YXIgb3duZXJGaWJlciA9IG93bmVyO1xuICAgICAgdmFyIGluc3RhbmNlID0gb3duZXJGaWJlci5zdGF0ZU5vZGU7XG5cbiAgICAgIGlmICghaW5zdGFuY2UuX3dhcm5lZEFib3V0UmVmc0luUmVuZGVyKSB7XG4gICAgICAgIGVycm9yKCclcyBpcyBhY2Nlc3NpbmcgaXNNb3VudGVkIGluc2lkZSBpdHMgcmVuZGVyKCkgZnVuY3Rpb24uICcgKyAncmVuZGVyKCkgc2hvdWxkIGJlIGEgcHVyZSBmdW5jdGlvbiBvZiBwcm9wcyBhbmQgc3RhdGUuIEl0IHNob3VsZCAnICsgJ25ldmVyIGFjY2VzcyBzb21ldGhpbmcgdGhhdCByZXF1aXJlcyBzdGFsZSBkYXRhIGZyb20gdGhlIHByZXZpb3VzICcgKyAncmVuZGVyLCBzdWNoIGFzIHJlZnMuIE1vdmUgdGhpcyBsb2dpYyB0byBjb21wb25lbnREaWRNb3VudCBhbmQgJyArICdjb21wb25lbnREaWRVcGRhdGUgaW5zdGVhZC4nLCBnZXRDb21wb25lbnROYW1lKG93bmVyRmliZXIudHlwZSkgfHwgJ0EgY29tcG9uZW50Jyk7XG4gICAgICB9XG5cbiAgICAgIGluc3RhbmNlLl93YXJuZWRBYm91dFJlZnNJblJlbmRlciA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgdmFyIGZpYmVyID0gZ2V0KGNvbXBvbmVudCk7XG5cbiAgaWYgKCFmaWJlcikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBnZXROZWFyZXN0TW91bnRlZEZpYmVyKGZpYmVyKSA9PT0gZmliZXI7XG59XG5cbmZ1bmN0aW9uIGFzc2VydElzTW91bnRlZChmaWJlcikge1xuICBpZiAoIShnZXROZWFyZXN0TW91bnRlZEZpYmVyKGZpYmVyKSA9PT0gZmliZXIpKSB7XG4gICAge1xuICAgICAgdGhyb3cgRXJyb3IoIFwiVW5hYmxlIHRvIGZpbmQgbm9kZSBvbiBhbiB1bm1vdW50ZWQgY29tcG9uZW50LlwiICk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGZpbmRDdXJyZW50RmliZXJVc2luZ1Nsb3dQYXRoKGZpYmVyKSB7XG4gIHZhciBhbHRlcm5hdGUgPSBmaWJlci5hbHRlcm5hdGU7XG5cbiAgaWYgKCFhbHRlcm5hdGUpIHtcbiAgICAvLyBJZiB0aGVyZSBpcyBubyBhbHRlcm5hdGUsIHRoZW4gd2Ugb25seSBuZWVkIHRvIGNoZWNrIGlmIGl0IGlzIG1vdW50ZWQuXG4gICAgdmFyIG5lYXJlc3RNb3VudGVkID0gZ2V0TmVhcmVzdE1vdW50ZWRGaWJlcihmaWJlcik7XG5cbiAgICBpZiAoIShuZWFyZXN0TW91bnRlZCAhPT0gbnVsbCkpIHtcbiAgICAgIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoIFwiVW5hYmxlIHRvIGZpbmQgbm9kZSBvbiBhbiB1bm1vdW50ZWQgY29tcG9uZW50LlwiICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG5lYXJlc3RNb3VudGVkICE9PSBmaWJlcikge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZpYmVyO1xuICB9IC8vIElmIHdlIGhhdmUgdHdvIHBvc3NpYmxlIGJyYW5jaGVzLCB3ZSdsbCB3YWxrIGJhY2t3YXJkcyB1cCB0byB0aGUgcm9vdFxuICAvLyB0byBzZWUgd2hhdCBwYXRoIHRoZSByb290IHBvaW50cyB0by4gT24gdGhlIHdheSB3ZSBtYXkgaGl0IG9uZSBvZiB0aGVcbiAgLy8gc3BlY2lhbCBjYXNlcyBhbmQgd2UnbGwgZGVhbCB3aXRoIHRoZW0uXG5cblxuICB2YXIgYSA9IGZpYmVyO1xuICB2YXIgYiA9IGFsdGVybmF0ZTtcblxuICB3aGlsZSAodHJ1ZSkge1xuICAgIHZhciBwYXJlbnRBID0gYS5yZXR1cm47XG5cbiAgICBpZiAocGFyZW50QSA9PT0gbnVsbCkge1xuICAgICAgLy8gV2UncmUgYXQgdGhlIHJvb3QuXG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICB2YXIgcGFyZW50QiA9IHBhcmVudEEuYWx0ZXJuYXRlO1xuXG4gICAgaWYgKHBhcmVudEIgPT09IG51bGwpIHtcbiAgICAgIC8vIFRoZXJlIGlzIG5vIGFsdGVybmF0ZS4gVGhpcyBpcyBhbiB1bnVzdWFsIGNhc2UuIEN1cnJlbnRseSwgaXQgb25seVxuICAgICAgLy8gaGFwcGVucyB3aGVuIGEgU3VzcGVuc2UgY29tcG9uZW50IGlzIGhpZGRlbi4gQW4gZXh0cmEgZnJhZ21lbnQgZmliZXJcbiAgICAgIC8vIGlzIGluc2VydGVkIGluIGJldHdlZW4gdGhlIFN1c3BlbnNlIGZpYmVyIGFuZCBpdHMgY2hpbGRyZW4uIFNraXBcbiAgICAgIC8vIG92ZXIgdGhpcyBleHRyYSBmcmFnbWVudCBmaWJlciBhbmQgcHJvY2VlZCB0byB0aGUgbmV4dCBwYXJlbnQuXG4gICAgICB2YXIgbmV4dFBhcmVudCA9IHBhcmVudEEucmV0dXJuO1xuXG4gICAgICBpZiAobmV4dFBhcmVudCAhPT0gbnVsbCkge1xuICAgICAgICBhID0gYiA9IG5leHRQYXJlbnQ7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfSAvLyBJZiB0aGVyZSdzIG5vIHBhcmVudCwgd2UncmUgYXQgdGhlIHJvb3QuXG5cblxuICAgICAgYnJlYWs7XG4gICAgfSAvLyBJZiBib3RoIGNvcGllcyBvZiB0aGUgcGFyZW50IGZpYmVyIHBvaW50IHRvIHRoZSBzYW1lIGNoaWxkLCB3ZSBjYW5cbiAgICAvLyBhc3N1bWUgdGhhdCB0aGUgY2hpbGQgaXMgY3VycmVudC4gVGhpcyBoYXBwZW5zIHdoZW4gd2UgYmFpbG91dCBvbiBsb3dcbiAgICAvLyBwcmlvcml0eTogdGhlIGJhaWxlZCBvdXQgZmliZXIncyBjaGlsZCByZXVzZXMgdGhlIGN1cnJlbnQgY2hpbGQuXG5cblxuICAgIGlmIChwYXJlbnRBLmNoaWxkID09PSBwYXJlbnRCLmNoaWxkKSB7XG4gICAgICB2YXIgY2hpbGQgPSBwYXJlbnRBLmNoaWxkO1xuXG4gICAgICB3aGlsZSAoY2hpbGQpIHtcbiAgICAgICAgaWYgKGNoaWxkID09PSBhKSB7XG4gICAgICAgICAgLy8gV2UndmUgZGV0ZXJtaW5lZCB0aGF0IEEgaXMgdGhlIGN1cnJlbnQgYnJhbmNoLlxuICAgICAgICAgIGFzc2VydElzTW91bnRlZChwYXJlbnRBKTtcbiAgICAgICAgICByZXR1cm4gZmliZXI7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY2hpbGQgPT09IGIpIHtcbiAgICAgICAgICAvLyBXZSd2ZSBkZXRlcm1pbmVkIHRoYXQgQiBpcyB0aGUgY3VycmVudCBicmFuY2guXG4gICAgICAgICAgYXNzZXJ0SXNNb3VudGVkKHBhcmVudEEpO1xuICAgICAgICAgIHJldHVybiBhbHRlcm5hdGU7XG4gICAgICAgIH1cblxuICAgICAgICBjaGlsZCA9IGNoaWxkLnNpYmxpbmc7XG4gICAgICB9IC8vIFdlIHNob3VsZCBuZXZlciBoYXZlIGFuIGFsdGVybmF0ZSBmb3IgYW55IG1vdW50aW5nIG5vZGUuIFNvIHRoZSBvbmx5XG4gICAgICAvLyB3YXkgdGhpcyBjb3VsZCBwb3NzaWJseSBoYXBwZW4gaXMgaWYgdGhpcyB3YXMgdW5tb3VudGVkLCBpZiBhdCBhbGwuXG5cblxuICAgICAge1xuICAgICAgICB7XG4gICAgICAgICAgdGhyb3cgRXJyb3IoIFwiVW5hYmxlIHRvIGZpbmQgbm9kZSBvbiBhbiB1bm1vdW50ZWQgY29tcG9uZW50LlwiICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoYS5yZXR1cm4gIT09IGIucmV0dXJuKSB7XG4gICAgICAvLyBUaGUgcmV0dXJuIHBvaW50ZXIgb2YgQSBhbmQgdGhlIHJldHVybiBwb2ludGVyIG9mIEIgcG9pbnQgdG8gZGlmZmVyZW50XG4gICAgICAvLyBmaWJlcnMuIFdlIGFzc3VtZSB0aGF0IHJldHVybiBwb2ludGVycyBuZXZlciBjcmlzcy1jcm9zcywgc28gQSBtdXN0XG4gICAgICAvLyBiZWxvbmcgdG8gdGhlIGNoaWxkIHNldCBvZiBBLnJldHVybiwgYW5kIEIgbXVzdCBiZWxvbmcgdG8gdGhlIGNoaWxkXG4gICAgICAvLyBzZXQgb2YgQi5yZXR1cm4uXG4gICAgICBhID0gcGFyZW50QTtcbiAgICAgIGIgPSBwYXJlbnRCO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUaGUgcmV0dXJuIHBvaW50ZXJzIHBvaW50IHRvIHRoZSBzYW1lIGZpYmVyLiBXZSdsbCBoYXZlIHRvIHVzZSB0aGVcbiAgICAgIC8vIGRlZmF1bHQsIHNsb3cgcGF0aDogc2NhbiB0aGUgY2hpbGQgc2V0cyBvZiBlYWNoIHBhcmVudCBhbHRlcm5hdGUgdG8gc2VlXG4gICAgICAvLyB3aGljaCBjaGlsZCBiZWxvbmdzIHRvIHdoaWNoIHNldC5cbiAgICAgIC8vXG4gICAgICAvLyBTZWFyY2ggcGFyZW50IEEncyBjaGlsZCBzZXRcbiAgICAgIHZhciBkaWRGaW5kQ2hpbGQgPSBmYWxzZTtcbiAgICAgIHZhciBfY2hpbGQgPSBwYXJlbnRBLmNoaWxkO1xuXG4gICAgICB3aGlsZSAoX2NoaWxkKSB7XG4gICAgICAgIGlmIChfY2hpbGQgPT09IGEpIHtcbiAgICAgICAgICBkaWRGaW5kQ2hpbGQgPSB0cnVlO1xuICAgICAgICAgIGEgPSBwYXJlbnRBO1xuICAgICAgICAgIGIgPSBwYXJlbnRCO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKF9jaGlsZCA9PT0gYikge1xuICAgICAgICAgIGRpZEZpbmRDaGlsZCA9IHRydWU7XG4gICAgICAgICAgYiA9IHBhcmVudEE7XG4gICAgICAgICAgYSA9IHBhcmVudEI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBfY2hpbGQgPSBfY2hpbGQuc2libGluZztcbiAgICAgIH1cblxuICAgICAgaWYgKCFkaWRGaW5kQ2hpbGQpIHtcbiAgICAgICAgLy8gU2VhcmNoIHBhcmVudCBCJ3MgY2hpbGQgc2V0XG4gICAgICAgIF9jaGlsZCA9IHBhcmVudEIuY2hpbGQ7XG5cbiAgICAgICAgd2hpbGUgKF9jaGlsZCkge1xuICAgICAgICAgIGlmIChfY2hpbGQgPT09IGEpIHtcbiAgICAgICAgICAgIGRpZEZpbmRDaGlsZCA9IHRydWU7XG4gICAgICAgICAgICBhID0gcGFyZW50QjtcbiAgICAgICAgICAgIGIgPSBwYXJlbnRBO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKF9jaGlsZCA9PT0gYikge1xuICAgICAgICAgICAgZGlkRmluZENoaWxkID0gdHJ1ZTtcbiAgICAgICAgICAgIGIgPSBwYXJlbnRCO1xuICAgICAgICAgICAgYSA9IHBhcmVudEE7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBfY2hpbGQgPSBfY2hpbGQuc2libGluZztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghZGlkRmluZENoaWxkKSB7XG4gICAgICAgICAge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoIFwiQ2hpbGQgd2FzIG5vdCBmb3VuZCBpbiBlaXRoZXIgcGFyZW50IHNldC4gVGhpcyBpbmRpY2F0ZXMgYSBidWcgaW4gUmVhY3QgcmVsYXRlZCB0byB0aGUgcmV0dXJuIHBvaW50ZXIuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCEoYS5hbHRlcm5hdGUgPT09IGIpKSB7XG4gICAgICB7XG4gICAgICAgIHRocm93IEVycm9yKCBcIlJldHVybiBmaWJlcnMgc2hvdWxkIGFsd2F5cyBiZSBlYWNoIG90aGVycycgYWx0ZXJuYXRlcy4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS5cIiApO1xuICAgICAgfVxuICAgIH1cbiAgfSAvLyBJZiB0aGUgcm9vdCBpcyBub3QgYSBob3N0IGNvbnRhaW5lciwgd2UncmUgaW4gYSBkaXNjb25uZWN0ZWQgdHJlZS4gSS5lLlxuICAvLyB1bm1vdW50ZWQuXG5cblxuICBpZiAoIShhLnRhZyA9PT0gSG9zdFJvb3QpKSB7XG4gICAge1xuICAgICAgdGhyb3cgRXJyb3IoIFwiVW5hYmxlIHRvIGZpbmQgbm9kZSBvbiBhbiB1bm1vdW50ZWQgY29tcG9uZW50LlwiICk7XG4gICAgfVxuICB9XG5cbiAgaWYgKGEuc3RhdGVOb2RlLmN1cnJlbnQgPT09IGEpIHtcbiAgICAvLyBXZSd2ZSBkZXRlcm1pbmVkIHRoYXQgQSBpcyB0aGUgY3VycmVudCBicmFuY2guXG4gICAgcmV0dXJuIGZpYmVyO1xuICB9IC8vIE90aGVyd2lzZSBCIGhhcyB0byBiZSBjdXJyZW50IGJyYW5jaC5cblxuXG4gIHJldHVybiBhbHRlcm5hdGU7XG59XG5mdW5jdGlvbiBmaW5kQ3VycmVudEhvc3RGaWJlcihwYXJlbnQpIHtcbiAgdmFyIGN1cnJlbnRQYXJlbnQgPSBmaW5kQ3VycmVudEZpYmVyVXNpbmdTbG93UGF0aChwYXJlbnQpO1xuXG4gIGlmICghY3VycmVudFBhcmVudCkge1xuICAgIHJldHVybiBudWxsO1xuICB9IC8vIE5leHQgd2UnbGwgZHJpbGwgZG93biB0aGlzIGNvbXBvbmVudCB0byBmaW5kIHRoZSBmaXJzdCBIb3N0Q29tcG9uZW50L1RleHQuXG5cblxuICB2YXIgbm9kZSA9IGN1cnJlbnRQYXJlbnQ7XG5cbiAgd2hpbGUgKHRydWUpIHtcbiAgICBpZiAobm9kZS50YWcgPT09IEhvc3RDb21wb25lbnQgfHwgbm9kZS50YWcgPT09IEhvc3RUZXh0KSB7XG4gICAgICByZXR1cm4gbm9kZTtcbiAgICB9IGVsc2UgaWYgKG5vZGUuY2hpbGQpIHtcbiAgICAgIG5vZGUuY2hpbGQucmV0dXJuID0gbm9kZTtcbiAgICAgIG5vZGUgPSBub2RlLmNoaWxkO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKG5vZGUgPT09IGN1cnJlbnRQYXJlbnQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHdoaWxlICghbm9kZS5zaWJsaW5nKSB7XG4gICAgICBpZiAoIW5vZGUucmV0dXJuIHx8IG5vZGUucmV0dXJuID09PSBjdXJyZW50UGFyZW50KSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICBub2RlID0gbm9kZS5yZXR1cm47XG4gICAgfVxuXG4gICAgbm9kZS5zaWJsaW5nLnJldHVybiA9IG5vZGUucmV0dXJuO1xuICAgIG5vZGUgPSBub2RlLnNpYmxpbmc7XG4gIH0gLy8gRmxvdyBuZWVkcyB0aGUgcmV0dXJuIG51bGwgaGVyZSwgYnV0IEVTTGludCBjb21wbGFpbnMgYWJvdXQgaXQuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnJlYWNoYWJsZVxuXG5cbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBmaW5kQ3VycmVudEhvc3RGaWJlcldpdGhOb1BvcnRhbHMocGFyZW50KSB7XG4gIHZhciBjdXJyZW50UGFyZW50ID0gZmluZEN1cnJlbnRGaWJlclVzaW5nU2xvd1BhdGgocGFyZW50KTtcblxuICBpZiAoIWN1cnJlbnRQYXJlbnQpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfSAvLyBOZXh0IHdlJ2xsIGRyaWxsIGRvd24gdGhpcyBjb21wb25lbnQgdG8gZmluZCB0aGUgZmlyc3QgSG9zdENvbXBvbmVudC9UZXh0LlxuXG5cbiAgdmFyIG5vZGUgPSBjdXJyZW50UGFyZW50O1xuXG4gIHdoaWxlICh0cnVlKSB7XG4gICAgaWYgKG5vZGUudGFnID09PSBIb3N0Q29tcG9uZW50IHx8IG5vZGUudGFnID09PSBIb3N0VGV4dCB8fCBlbmFibGVGdW5kYW1lbnRhbEFQSSApIHtcbiAgICAgIHJldHVybiBub2RlO1xuICAgIH0gZWxzZSBpZiAobm9kZS5jaGlsZCAmJiBub2RlLnRhZyAhPT0gSG9zdFBvcnRhbCkge1xuICAgICAgbm9kZS5jaGlsZC5yZXR1cm4gPSBub2RlO1xuICAgICAgbm9kZSA9IG5vZGUuY2hpbGQ7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAobm9kZSA9PT0gY3VycmVudFBhcmVudCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgd2hpbGUgKCFub2RlLnNpYmxpbmcpIHtcbiAgICAgIGlmICghbm9kZS5yZXR1cm4gfHwgbm9kZS5yZXR1cm4gPT09IGN1cnJlbnRQYXJlbnQpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIG5vZGUgPSBub2RlLnJldHVybjtcbiAgICB9XG5cbiAgICBub2RlLnNpYmxpbmcucmV0dXJuID0gbm9kZS5yZXR1cm47XG4gICAgbm9kZSA9IG5vZGUuc2libGluZztcbiAgfSAvLyBGbG93IG5lZWRzIHRoZSByZXR1cm4gbnVsbCBoZXJlLCBidXQgRVNMaW50IGNvbXBsYWlucyBhYm91dCBpdC5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVucmVhY2hhYmxlXG5cblxuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGRvZXNGaWJlckNvbnRhaW4ocGFyZW50RmliZXIsIGNoaWxkRmliZXIpIHtcbiAgdmFyIG5vZGUgPSBjaGlsZEZpYmVyO1xuICB2YXIgcGFyZW50RmliZXJBbHRlcm5hdGUgPSBwYXJlbnRGaWJlci5hbHRlcm5hdGU7XG5cbiAgd2hpbGUgKG5vZGUgIT09IG51bGwpIHtcbiAgICBpZiAobm9kZSA9PT0gcGFyZW50RmliZXIgfHwgbm9kZSA9PT0gcGFyZW50RmliZXJBbHRlcm5hdGUpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIG5vZGUgPSBub2RlLnJldHVybjtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxudmFyIGF0dGVtcHRVc2VyQmxvY2tpbmdIeWRyYXRpb247XG5mdW5jdGlvbiBzZXRBdHRlbXB0VXNlckJsb2NraW5nSHlkcmF0aW9uKGZuKSB7XG4gIGF0dGVtcHRVc2VyQmxvY2tpbmdIeWRyYXRpb24gPSBmbjtcbn1cbnZhciBhdHRlbXB0Q29udGludW91c0h5ZHJhdGlvbjtcbmZ1bmN0aW9uIHNldEF0dGVtcHRDb250aW51b3VzSHlkcmF0aW9uKGZuKSB7XG4gIGF0dGVtcHRDb250aW51b3VzSHlkcmF0aW9uID0gZm47XG59XG52YXIgYXR0ZW1wdEh5ZHJhdGlvbkF0Q3VycmVudFByaW9yaXR5O1xuZnVuY3Rpb24gc2V0QXR0ZW1wdEh5ZHJhdGlvbkF0Q3VycmVudFByaW9yaXR5KGZuKSB7XG4gIGF0dGVtcHRIeWRyYXRpb25BdEN1cnJlbnRQcmlvcml0eSA9IGZuO1xufVxudmFyIGF0dGVtcHRIeWRyYXRpb25BdFByaW9yaXR5O1xuZnVuY3Rpb24gc2V0QXR0ZW1wdEh5ZHJhdGlvbkF0UHJpb3JpdHkoZm4pIHtcbiAgYXR0ZW1wdEh5ZHJhdGlvbkF0UHJpb3JpdHkgPSBmbjtcbn0gLy8gVE9ETzogVXBncmFkZSB0aGlzIGRlZmluaXRpb24gb25jZSB3ZSdyZSBvbiBhIG5ld2VyIHZlcnNpb24gb2YgRmxvdyB0aGF0XG52YXIgaGFzU2NoZWR1bGVkUmVwbGF5QXR0ZW1wdCA9IGZhbHNlOyAvLyBUaGUgcXVldWUgb2YgZGlzY3JldGUgZXZlbnRzIHRvIGJlIHJlcGxheWVkLlxuXG52YXIgcXVldWVkRGlzY3JldGVFdmVudHMgPSBbXTsgLy8gSW5kaWNhdGVzIGlmIGFueSBjb250aW51b3VzIGV2ZW50IHRhcmdldHMgYXJlIG5vbi1udWxsIGZvciBlYXJseSBiYWlsb3V0LlxuLy8gaWYgdGhlIGxhc3QgdGFyZ2V0IHdhcyBkZWh5ZHJhdGVkLlxuXG52YXIgcXVldWVkRm9jdXMgPSBudWxsO1xudmFyIHF1ZXVlZERyYWcgPSBudWxsO1xudmFyIHF1ZXVlZE1vdXNlID0gbnVsbDsgLy8gRm9yIHBvaW50ZXIgZXZlbnRzIHRoZXJlIGNhbiBiZSBvbmUgbGF0ZXN0IGV2ZW50IHBlciBwb2ludGVySWQuXG5cbnZhciBxdWV1ZWRQb2ludGVycyA9IG5ldyBNYXAoKTtcbnZhciBxdWV1ZWRQb2ludGVyQ2FwdHVyZXMgPSBuZXcgTWFwKCk7IC8vIFdlIGNvdWxkIGNvbnNpZGVyIHJlcGxheWluZyBzZWxlY3Rpb25jaGFuZ2UgYW5kIHRvdWNobW92ZXMgdG9vLlxuXG52YXIgcXVldWVkRXhwbGljaXRIeWRyYXRpb25UYXJnZXRzID0gW107XG5mdW5jdGlvbiBoYXNRdWV1ZWREaXNjcmV0ZUV2ZW50cygpIHtcbiAgcmV0dXJuIHF1ZXVlZERpc2NyZXRlRXZlbnRzLmxlbmd0aCA+IDA7XG59XG52YXIgZGlzY3JldGVSZXBsYXlhYmxlRXZlbnRzID0gWydtb3VzZWRvd24nLCAnbW91c2V1cCcsICd0b3VjaGNhbmNlbCcsICd0b3VjaGVuZCcsICd0b3VjaHN0YXJ0JywgJ2F1eGNsaWNrJywgJ2RibGNsaWNrJywgJ3BvaW50ZXJjYW5jZWwnLCAncG9pbnRlcmRvd24nLCAncG9pbnRlcnVwJywgJ2RyYWdlbmQnLCAnZHJhZ3N0YXJ0JywgJ2Ryb3AnLCAnY29tcG9zaXRpb25lbmQnLCAnY29tcG9zaXRpb25zdGFydCcsICdrZXlkb3duJywgJ2tleXByZXNzJywgJ2tleXVwJywgJ2lucHV0JywgJ3RleHRJbnB1dCcsIC8vIEludGVudGlvbmFsbHkgY2FtZWxDYXNlXG4nY29weScsICdjdXQnLCAncGFzdGUnLCAnY2xpY2snLCAnY2hhbmdlJywgJ2NvbnRleHRtZW51JywgJ3Jlc2V0JywgJ3N1Ym1pdCddO1xuZnVuY3Rpb24gaXNSZXBsYXlhYmxlRGlzY3JldGVFdmVudChldmVudFR5cGUpIHtcbiAgcmV0dXJuIGRpc2NyZXRlUmVwbGF5YWJsZUV2ZW50cy5pbmRleE9mKGV2ZW50VHlwZSkgPiAtMTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlUXVldWVkUmVwbGF5YWJsZUV2ZW50KGJsb2NrZWRPbiwgZG9tRXZlbnROYW1lLCBldmVudFN5c3RlbUZsYWdzLCB0YXJnZXRDb250YWluZXIsIG5hdGl2ZUV2ZW50KSB7XG4gIHJldHVybiB7XG4gICAgYmxvY2tlZE9uOiBibG9ja2VkT24sXG4gICAgZG9tRXZlbnROYW1lOiBkb21FdmVudE5hbWUsXG4gICAgZXZlbnRTeXN0ZW1GbGFnczogZXZlbnRTeXN0ZW1GbGFncyB8IElTX1JFUExBWUVELFxuICAgIG5hdGl2ZUV2ZW50OiBuYXRpdmVFdmVudCxcbiAgICB0YXJnZXRDb250YWluZXJzOiBbdGFyZ2V0Q29udGFpbmVyXVxuICB9O1xufVxuXG5mdW5jdGlvbiBxdWV1ZURpc2NyZXRlRXZlbnQoYmxvY2tlZE9uLCBkb21FdmVudE5hbWUsIGV2ZW50U3lzdGVtRmxhZ3MsIHRhcmdldENvbnRhaW5lciwgbmF0aXZlRXZlbnQpIHtcbiAgdmFyIHF1ZXVlZEV2ZW50ID0gY3JlYXRlUXVldWVkUmVwbGF5YWJsZUV2ZW50KGJsb2NrZWRPbiwgZG9tRXZlbnROYW1lLCBldmVudFN5c3RlbUZsYWdzLCB0YXJnZXRDb250YWluZXIsIG5hdGl2ZUV2ZW50KTtcbiAgcXVldWVkRGlzY3JldGVFdmVudHMucHVzaChxdWV1ZWRFdmVudCk7XG59IC8vIFJlc2V0cyB0aGUgcmVwbGF5aW5nIGZvciB0aGlzIHR5cGUgb2YgY29udGludW91cyBldmVudCB0byBubyBldmVudC5cblxuZnVuY3Rpb24gY2xlYXJJZkNvbnRpbnVvdXNFdmVudChkb21FdmVudE5hbWUsIG5hdGl2ZUV2ZW50KSB7XG4gIHN3aXRjaCAoZG9tRXZlbnROYW1lKSB7XG4gICAgY2FzZSAnZm9jdXNpbic6XG4gICAgY2FzZSAnZm9jdXNvdXQnOlxuICAgICAgcXVldWVkRm9jdXMgPSBudWxsO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdkcmFnZW50ZXInOlxuICAgIGNhc2UgJ2RyYWdsZWF2ZSc6XG4gICAgICBxdWV1ZWREcmFnID0gbnVsbDtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnbW91c2VvdmVyJzpcbiAgICBjYXNlICdtb3VzZW91dCc6XG4gICAgICBxdWV1ZWRNb3VzZSA9IG51bGw7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ3BvaW50ZXJvdmVyJzpcbiAgICBjYXNlICdwb2ludGVyb3V0JzpcbiAgICAgIHtcbiAgICAgICAgdmFyIHBvaW50ZXJJZCA9IG5hdGl2ZUV2ZW50LnBvaW50ZXJJZDtcbiAgICAgICAgcXVldWVkUG9pbnRlcnMuZGVsZXRlKHBvaW50ZXJJZCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgY2FzZSAnZ290cG9pbnRlcmNhcHR1cmUnOlxuICAgIGNhc2UgJ2xvc3Rwb2ludGVyY2FwdHVyZSc6XG4gICAgICB7XG4gICAgICAgIHZhciBfcG9pbnRlcklkID0gbmF0aXZlRXZlbnQucG9pbnRlcklkO1xuICAgICAgICBxdWV1ZWRQb2ludGVyQ2FwdHVyZXMuZGVsZXRlKF9wb2ludGVySWQpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBhY2N1bXVsYXRlT3JDcmVhdGVDb250aW51b3VzUXVldWVkUmVwbGF5YWJsZUV2ZW50KGV4aXN0aW5nUXVldWVkRXZlbnQsIGJsb2NrZWRPbiwgZG9tRXZlbnROYW1lLCBldmVudFN5c3RlbUZsYWdzLCB0YXJnZXRDb250YWluZXIsIG5hdGl2ZUV2ZW50KSB7XG4gIGlmIChleGlzdGluZ1F1ZXVlZEV2ZW50ID09PSBudWxsIHx8IGV4aXN0aW5nUXVldWVkRXZlbnQubmF0aXZlRXZlbnQgIT09IG5hdGl2ZUV2ZW50KSB7XG4gICAgdmFyIHF1ZXVlZEV2ZW50ID0gY3JlYXRlUXVldWVkUmVwbGF5YWJsZUV2ZW50KGJsb2NrZWRPbiwgZG9tRXZlbnROYW1lLCBldmVudFN5c3RlbUZsYWdzLCB0YXJnZXRDb250YWluZXIsIG5hdGl2ZUV2ZW50KTtcblxuICAgIGlmIChibG9ja2VkT24gIT09IG51bGwpIHtcbiAgICAgIHZhciBfZmliZXIyID0gZ2V0SW5zdGFuY2VGcm9tTm9kZShibG9ja2VkT24pO1xuXG4gICAgICBpZiAoX2ZpYmVyMiAhPT0gbnVsbCkge1xuICAgICAgICAvLyBBdHRlbXB0IHRvIGluY3JlYXNlIHRoZSBwcmlvcml0eSBvZiB0aGlzIHRhcmdldC5cbiAgICAgICAgYXR0ZW1wdENvbnRpbnVvdXNIeWRyYXRpb24oX2ZpYmVyMik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHF1ZXVlZEV2ZW50O1xuICB9IC8vIElmIHdlIGhhdmUgYWxyZWFkeSBxdWV1ZWQgdGhpcyBleGFjdCBldmVudCwgdGhlbiBpdCdzIGJlY2F1c2VcbiAgLy8gdGhlIGRpZmZlcmVudCBldmVudCBzeXN0ZW1zIGhhdmUgZGlmZmVyZW50IERPTSBldmVudCBsaXN0ZW5lcnMuXG4gIC8vIFdlIGNhbiBhY2N1bXVsYXRlIHRoZSBmbGFncywgYW5kIHRoZSB0YXJnZXRDb250YWluZXJzLCBhbmRcbiAgLy8gc3RvcmUgYSBzaW5nbGUgZXZlbnQgdG8gYmUgcmVwbGF5ZWQuXG5cblxuICBleGlzdGluZ1F1ZXVlZEV2ZW50LmV2ZW50U3lzdGVtRmxhZ3MgfD0gZXZlbnRTeXN0ZW1GbGFncztcbiAgdmFyIHRhcmdldENvbnRhaW5lcnMgPSBleGlzdGluZ1F1ZXVlZEV2ZW50LnRhcmdldENvbnRhaW5lcnM7XG5cbiAgaWYgKHRhcmdldENvbnRhaW5lciAhPT0gbnVsbCAmJiB0YXJnZXRDb250YWluZXJzLmluZGV4T2YodGFyZ2V0Q29udGFpbmVyKSA9PT0gLTEpIHtcbiAgICB0YXJnZXRDb250YWluZXJzLnB1c2godGFyZ2V0Q29udGFpbmVyKTtcbiAgfVxuXG4gIHJldHVybiBleGlzdGluZ1F1ZXVlZEV2ZW50O1xufVxuXG5mdW5jdGlvbiBxdWV1ZUlmQ29udGludW91c0V2ZW50KGJsb2NrZWRPbiwgZG9tRXZlbnROYW1lLCBldmVudFN5c3RlbUZsYWdzLCB0YXJnZXRDb250YWluZXIsIG5hdGl2ZUV2ZW50KSB7XG4gIC8vIFRoZXNlIHNldCByZWxhdGVkVGFyZ2V0IHRvIG51bGwgYmVjYXVzZSB0aGUgcmVwbGF5ZWQgZXZlbnQgd2lsbCBiZSB0cmVhdGVkIGFzIGlmIHdlXG4gIC8vIG1vdmVkIGZyb20gb3V0c2lkZSB0aGUgd2luZG93IChubyB0YXJnZXQpIG9udG8gdGhlIHRhcmdldCBvbmNlIGl0IGh5ZHJhdGVzLlxuICAvLyBJbnN0ZWFkIG9mIG11dGF0aW5nIHdlIGNvdWxkIGNsb25lIHRoZSBldmVudC5cbiAgc3dpdGNoIChkb21FdmVudE5hbWUpIHtcbiAgICBjYXNlICdmb2N1c2luJzpcbiAgICAgIHtcbiAgICAgICAgdmFyIGZvY3VzRXZlbnQgPSBuYXRpdmVFdmVudDtcbiAgICAgICAgcXVldWVkRm9jdXMgPSBhY2N1bXVsYXRlT3JDcmVhdGVDb250aW51b3VzUXVldWVkUmVwbGF5YWJsZUV2ZW50KHF1ZXVlZEZvY3VzLCBibG9ja2VkT24sIGRvbUV2ZW50TmFtZSwgZXZlbnRTeXN0ZW1GbGFncywgdGFyZ2V0Q29udGFpbmVyLCBmb2N1c0V2ZW50KTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICBjYXNlICdkcmFnZW50ZXInOlxuICAgICAge1xuICAgICAgICB2YXIgZHJhZ0V2ZW50ID0gbmF0aXZlRXZlbnQ7XG4gICAgICAgIHF1ZXVlZERyYWcgPSBhY2N1bXVsYXRlT3JDcmVhdGVDb250aW51b3VzUXVldWVkUmVwbGF5YWJsZUV2ZW50KHF1ZXVlZERyYWcsIGJsb2NrZWRPbiwgZG9tRXZlbnROYW1lLCBldmVudFN5c3RlbUZsYWdzLCB0YXJnZXRDb250YWluZXIsIGRyYWdFdmVudCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgY2FzZSAnbW91c2VvdmVyJzpcbiAgICAgIHtcbiAgICAgICAgdmFyIG1vdXNlRXZlbnQgPSBuYXRpdmVFdmVudDtcbiAgICAgICAgcXVldWVkTW91c2UgPSBhY2N1bXVsYXRlT3JDcmVhdGVDb250aW51b3VzUXVldWVkUmVwbGF5YWJsZUV2ZW50KHF1ZXVlZE1vdXNlLCBibG9ja2VkT24sIGRvbUV2ZW50TmFtZSwgZXZlbnRTeXN0ZW1GbGFncywgdGFyZ2V0Q29udGFpbmVyLCBtb3VzZUV2ZW50KTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICBjYXNlICdwb2ludGVyb3Zlcic6XG4gICAgICB7XG4gICAgICAgIHZhciBwb2ludGVyRXZlbnQgPSBuYXRpdmVFdmVudDtcbiAgICAgICAgdmFyIHBvaW50ZXJJZCA9IHBvaW50ZXJFdmVudC5wb2ludGVySWQ7XG4gICAgICAgIHF1ZXVlZFBvaW50ZXJzLnNldChwb2ludGVySWQsIGFjY3VtdWxhdGVPckNyZWF0ZUNvbnRpbnVvdXNRdWV1ZWRSZXBsYXlhYmxlRXZlbnQocXVldWVkUG9pbnRlcnMuZ2V0KHBvaW50ZXJJZCkgfHwgbnVsbCwgYmxvY2tlZE9uLCBkb21FdmVudE5hbWUsIGV2ZW50U3lzdGVtRmxhZ3MsIHRhcmdldENvbnRhaW5lciwgcG9pbnRlckV2ZW50KSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgY2FzZSAnZ290cG9pbnRlcmNhcHR1cmUnOlxuICAgICAge1xuICAgICAgICB2YXIgX3BvaW50ZXJFdmVudCA9IG5hdGl2ZUV2ZW50O1xuICAgICAgICB2YXIgX3BvaW50ZXJJZDIgPSBfcG9pbnRlckV2ZW50LnBvaW50ZXJJZDtcbiAgICAgICAgcXVldWVkUG9pbnRlckNhcHR1cmVzLnNldChfcG9pbnRlcklkMiwgYWNjdW11bGF0ZU9yQ3JlYXRlQ29udGludW91c1F1ZXVlZFJlcGxheWFibGVFdmVudChxdWV1ZWRQb2ludGVyQ2FwdHVyZXMuZ2V0KF9wb2ludGVySWQyKSB8fCBudWxsLCBibG9ja2VkT24sIGRvbUV2ZW50TmFtZSwgZXZlbnRTeXN0ZW1GbGFncywgdGFyZ2V0Q29udGFpbmVyLCBfcG9pbnRlckV2ZW50KSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufSAvLyBDaGVjayBpZiB0aGlzIHRhcmdldCBpcyB1bmJsb2NrZWQuIFJldHVybnMgdHJ1ZSBpZiBpdCdzIHVuYmxvY2tlZC5cblxuZnVuY3Rpb24gYXR0ZW1wdEV4cGxpY2l0SHlkcmF0aW9uVGFyZ2V0KHF1ZXVlZFRhcmdldCkge1xuICAvLyBUT0RPOiBUaGlzIGZ1bmN0aW9uIHNoYXJlcyBhIGxvdCBvZiBsb2dpYyB3aXRoIGF0dGVtcHRUb0Rpc3BhdGNoRXZlbnQuXG4gIC8vIFRyeSB0byB1bmlmeSB0aGVtLiBJdCdzIGEgYml0IHRyaWNreSBzaW5jZSBpdCB3b3VsZCByZXF1aXJlIHR3byByZXR1cm5cbiAgLy8gdmFsdWVzLlxuICB2YXIgdGFyZ2V0SW5zdCA9IGdldENsb3Nlc3RJbnN0YW5jZUZyb21Ob2RlKHF1ZXVlZFRhcmdldC50YXJnZXQpO1xuXG4gIGlmICh0YXJnZXRJbnN0ICE9PSBudWxsKSB7XG4gICAgdmFyIG5lYXJlc3RNb3VudGVkID0gZ2V0TmVhcmVzdE1vdW50ZWRGaWJlcih0YXJnZXRJbnN0KTtcblxuICAgIGlmIChuZWFyZXN0TW91bnRlZCAhPT0gbnVsbCkge1xuICAgICAgdmFyIHRhZyA9IG5lYXJlc3RNb3VudGVkLnRhZztcblxuICAgICAgaWYgKHRhZyA9PT0gU3VzcGVuc2VDb21wb25lbnQpIHtcbiAgICAgICAgdmFyIGluc3RhbmNlID0gZ2V0U3VzcGVuc2VJbnN0YW5jZUZyb21GaWJlcihuZWFyZXN0TW91bnRlZCk7XG5cbiAgICAgICAgaWYgKGluc3RhbmNlICE9PSBudWxsKSB7XG4gICAgICAgICAgLy8gV2UncmUgYmxvY2tlZCBvbiBoeWRyYXRpbmcgdGhpcyBib3VuZGFyeS5cbiAgICAgICAgICAvLyBJbmNyZWFzZSBpdHMgcHJpb3JpdHkuXG4gICAgICAgICAgcXVldWVkVGFyZ2V0LmJsb2NrZWRPbiA9IGluc3RhbmNlO1xuICAgICAgICAgIGF0dGVtcHRIeWRyYXRpb25BdFByaW9yaXR5KHF1ZXVlZFRhcmdldC5sYW5lUHJpb3JpdHksIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIFNjaGVkdWxlci51bnN0YWJsZV9ydW5XaXRoUHJpb3JpdHkocXVldWVkVGFyZ2V0LnByaW9yaXR5LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIGF0dGVtcHRIeWRyYXRpb25BdEN1cnJlbnRQcmlvcml0eShuZWFyZXN0TW91bnRlZCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodGFnID09PSBIb3N0Um9vdCkge1xuICAgICAgICB2YXIgcm9vdCA9IG5lYXJlc3RNb3VudGVkLnN0YXRlTm9kZTtcblxuICAgICAgICBpZiAocm9vdC5oeWRyYXRlKSB7XG4gICAgICAgICAgcXVldWVkVGFyZ2V0LmJsb2NrZWRPbiA9IGdldENvbnRhaW5lckZyb21GaWJlcihuZWFyZXN0TW91bnRlZCk7IC8vIFdlIGRvbid0IGN1cnJlbnRseSBoYXZlIGEgd2F5IHRvIGluY3JlYXNlIHRoZSBwcmlvcml0eSBvZlxuICAgICAgICAgIC8vIGEgcm9vdCBvdGhlciB0aGFuIHN5bmMuXG5cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBxdWV1ZWRUYXJnZXQuYmxvY2tlZE9uID0gbnVsbDtcbn1cblxuZnVuY3Rpb24gYXR0ZW1wdFJlcGxheUNvbnRpbnVvdXNRdWV1ZWRFdmVudChxdWV1ZWRFdmVudCkge1xuICBpZiAocXVldWVkRXZlbnQuYmxvY2tlZE9uICE9PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIHRhcmdldENvbnRhaW5lcnMgPSBxdWV1ZWRFdmVudC50YXJnZXRDb250YWluZXJzO1xuXG4gIHdoaWxlICh0YXJnZXRDb250YWluZXJzLmxlbmd0aCA+IDApIHtcbiAgICB2YXIgdGFyZ2V0Q29udGFpbmVyID0gdGFyZ2V0Q29udGFpbmVyc1swXTtcbiAgICB2YXIgbmV4dEJsb2NrZWRPbiA9IGF0dGVtcHRUb0Rpc3BhdGNoRXZlbnQocXVldWVkRXZlbnQuZG9tRXZlbnROYW1lLCBxdWV1ZWRFdmVudC5ldmVudFN5c3RlbUZsYWdzLCB0YXJnZXRDb250YWluZXIsIHF1ZXVlZEV2ZW50Lm5hdGl2ZUV2ZW50KTtcblxuICAgIGlmIChuZXh0QmxvY2tlZE9uICE9PSBudWxsKSB7XG4gICAgICAvLyBXZSdyZSBzdGlsbCBibG9ja2VkLiBUcnkgYWdhaW4gbGF0ZXIuXG4gICAgICB2YXIgX2ZpYmVyMyA9IGdldEluc3RhbmNlRnJvbU5vZGUobmV4dEJsb2NrZWRPbik7XG5cbiAgICAgIGlmIChfZmliZXIzICE9PSBudWxsKSB7XG4gICAgICAgIGF0dGVtcHRDb250aW51b3VzSHlkcmF0aW9uKF9maWJlcjMpO1xuICAgICAgfVxuXG4gICAgICBxdWV1ZWRFdmVudC5ibG9ja2VkT24gPSBuZXh0QmxvY2tlZE9uO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gLy8gVGhpcyB0YXJnZXQgY29udGFpbmVyIHdhcyBzdWNjZXNzZnVsbHkgZGlzcGF0Y2hlZC4gVHJ5IHRoZSBuZXh0LlxuXG5cbiAgICB0YXJnZXRDb250YWluZXJzLnNoaWZ0KCk7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gYXR0ZW1wdFJlcGxheUNvbnRpbnVvdXNRdWV1ZWRFdmVudEluTWFwKHF1ZXVlZEV2ZW50LCBrZXksIG1hcCkge1xuICBpZiAoYXR0ZW1wdFJlcGxheUNvbnRpbnVvdXNRdWV1ZWRFdmVudChxdWV1ZWRFdmVudCkpIHtcbiAgICBtYXAuZGVsZXRlKGtleSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVwbGF5VW5ibG9ja2VkRXZlbnRzKCkge1xuICBoYXNTY2hlZHVsZWRSZXBsYXlBdHRlbXB0ID0gZmFsc2U7IC8vIEZpcnN0IHJlcGxheSBkaXNjcmV0ZSBldmVudHMuXG5cbiAgd2hpbGUgKHF1ZXVlZERpc2NyZXRlRXZlbnRzLmxlbmd0aCA+IDApIHtcbiAgICB2YXIgbmV4dERpc2NyZXRlRXZlbnQgPSBxdWV1ZWREaXNjcmV0ZUV2ZW50c1swXTtcblxuICAgIGlmIChuZXh0RGlzY3JldGVFdmVudC5ibG9ja2VkT24gIT09IG51bGwpIHtcbiAgICAgIC8vIFdlJ3JlIHN0aWxsIGJsb2NrZWQuXG4gICAgICAvLyBJbmNyZWFzZSB0aGUgcHJpb3JpdHkgb2YgdGhpcyBib3VuZGFyeSB0byB1bmJsb2NrXG4gICAgICAvLyB0aGUgbmV4dCBkaXNjcmV0ZSBldmVudC5cbiAgICAgIHZhciBfZmliZXI0ID0gZ2V0SW5zdGFuY2VGcm9tTm9kZShuZXh0RGlzY3JldGVFdmVudC5ibG9ja2VkT24pO1xuXG4gICAgICBpZiAoX2ZpYmVyNCAhPT0gbnVsbCkge1xuICAgICAgICBhdHRlbXB0VXNlckJsb2NraW5nSHlkcmF0aW9uKF9maWJlcjQpO1xuICAgICAgfVxuXG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICB2YXIgdGFyZ2V0Q29udGFpbmVycyA9IG5leHREaXNjcmV0ZUV2ZW50LnRhcmdldENvbnRhaW5lcnM7XG5cbiAgICB3aGlsZSAodGFyZ2V0Q29udGFpbmVycy5sZW5ndGggPiAwKSB7XG4gICAgICB2YXIgdGFyZ2V0Q29udGFpbmVyID0gdGFyZ2V0Q29udGFpbmVyc1swXTtcbiAgICAgIHZhciBuZXh0QmxvY2tlZE9uID0gYXR0ZW1wdFRvRGlzcGF0Y2hFdmVudChuZXh0RGlzY3JldGVFdmVudC5kb21FdmVudE5hbWUsIG5leHREaXNjcmV0ZUV2ZW50LmV2ZW50U3lzdGVtRmxhZ3MsIHRhcmdldENvbnRhaW5lciwgbmV4dERpc2NyZXRlRXZlbnQubmF0aXZlRXZlbnQpO1xuXG4gICAgICBpZiAobmV4dEJsb2NrZWRPbiAhPT0gbnVsbCkge1xuICAgICAgICAvLyBXZSdyZSBzdGlsbCBibG9ja2VkLiBUcnkgYWdhaW4gbGF0ZXIuXG4gICAgICAgIG5leHREaXNjcmV0ZUV2ZW50LmJsb2NrZWRPbiA9IG5leHRCbG9ja2VkT247XG4gICAgICAgIGJyZWFrO1xuICAgICAgfSAvLyBUaGlzIHRhcmdldCBjb250YWluZXIgd2FzIHN1Y2Nlc3NmdWxseSBkaXNwYXRjaGVkLiBUcnkgdGhlIG5leHQuXG5cblxuICAgICAgdGFyZ2V0Q29udGFpbmVycy5zaGlmdCgpO1xuICAgIH1cblxuICAgIGlmIChuZXh0RGlzY3JldGVFdmVudC5ibG9ja2VkT24gPT09IG51bGwpIHtcbiAgICAgIC8vIFdlJ3ZlIHN1Y2Nlc3NmdWxseSByZXBsYXllZCB0aGUgZmlyc3QgZXZlbnQuIExldCdzIHRyeSB0aGUgbmV4dCBvbmUuXG4gICAgICBxdWV1ZWREaXNjcmV0ZUV2ZW50cy5zaGlmdCgpO1xuICAgIH1cbiAgfSAvLyBOZXh0IHJlcGxheSBhbnkgY29udGludW91cyBldmVudHMuXG5cblxuICBpZiAocXVldWVkRm9jdXMgIT09IG51bGwgJiYgYXR0ZW1wdFJlcGxheUNvbnRpbnVvdXNRdWV1ZWRFdmVudChxdWV1ZWRGb2N1cykpIHtcbiAgICBxdWV1ZWRGb2N1cyA9IG51bGw7XG4gIH1cblxuICBpZiAocXVldWVkRHJhZyAhPT0gbnVsbCAmJiBhdHRlbXB0UmVwbGF5Q29udGludW91c1F1ZXVlZEV2ZW50KHF1ZXVlZERyYWcpKSB7XG4gICAgcXVldWVkRHJhZyA9IG51bGw7XG4gIH1cblxuICBpZiAocXVldWVkTW91c2UgIT09IG51bGwgJiYgYXR0ZW1wdFJlcGxheUNvbnRpbnVvdXNRdWV1ZWRFdmVudChxdWV1ZWRNb3VzZSkpIHtcbiAgICBxdWV1ZWRNb3VzZSA9IG51bGw7XG4gIH1cblxuICBxdWV1ZWRQb2ludGVycy5mb3JFYWNoKGF0dGVtcHRSZXBsYXlDb250aW51b3VzUXVldWVkRXZlbnRJbk1hcCk7XG4gIHF1ZXVlZFBvaW50ZXJDYXB0dXJlcy5mb3JFYWNoKGF0dGVtcHRSZXBsYXlDb250aW51b3VzUXVldWVkRXZlbnRJbk1hcCk7XG59XG5cbmZ1bmN0aW9uIHNjaGVkdWxlQ2FsbGJhY2tJZlVuYmxvY2tlZChxdWV1ZWRFdmVudCwgdW5ibG9ja2VkKSB7XG4gIGlmIChxdWV1ZWRFdmVudC5ibG9ja2VkT24gPT09IHVuYmxvY2tlZCkge1xuICAgIHF1ZXVlZEV2ZW50LmJsb2NrZWRPbiA9IG51bGw7XG5cbiAgICBpZiAoIWhhc1NjaGVkdWxlZFJlcGxheUF0dGVtcHQpIHtcbiAgICAgIGhhc1NjaGVkdWxlZFJlcGxheUF0dGVtcHQgPSB0cnVlOyAvLyBTY2hlZHVsZSBhIGNhbGxiYWNrIHRvIGF0dGVtcHQgcmVwbGF5aW5nIGFzIG1hbnkgZXZlbnRzIGFzIGFyZVxuICAgICAgLy8gbm93IHVuYmxvY2tlZC4gVGhpcyBmaXJzdCBtaWdodCBub3QgYWN0dWFsbHkgYmUgdW5ibG9ja2VkIHlldC5cbiAgICAgIC8vIFdlIGNvdWxkIGNoZWNrIGl0IGVhcmx5IHRvIGF2b2lkIHNjaGVkdWxpbmcgYW4gdW5uZWNlc3NhcnkgY2FsbGJhY2suXG5cbiAgICAgIFNjaGVkdWxlci51bnN0YWJsZV9zY2hlZHVsZUNhbGxiYWNrKFNjaGVkdWxlci51bnN0YWJsZV9Ob3JtYWxQcmlvcml0eSwgcmVwbGF5VW5ibG9ja2VkRXZlbnRzKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcmV0cnlJZkJsb2NrZWRPbih1bmJsb2NrZWQpIHtcbiAgLy8gTWFyayBhbnl0aGluZyB0aGF0IHdhcyBibG9ja2VkIG9uIHRoaXMgYXMgbm8gbG9uZ2VyIGJsb2NrZWRcbiAgLy8gYW5kIGVsaWdpYmxlIGZvciBhIHJlcGxheS5cbiAgaWYgKHF1ZXVlZERpc2NyZXRlRXZlbnRzLmxlbmd0aCA+IDApIHtcbiAgICBzY2hlZHVsZUNhbGxiYWNrSWZVbmJsb2NrZWQocXVldWVkRGlzY3JldGVFdmVudHNbMF0sIHVuYmxvY2tlZCk7IC8vIFRoaXMgaXMgYSBleHBvbmVudGlhbCBzZWFyY2ggZm9yIGVhY2ggYm91bmRhcnkgdGhhdCBjb21taXRzLiBJIHRoaW5rIGl0J3NcbiAgICAvLyB3b3J0aCBpdCBiZWNhdXNlIHdlIGV4cGVjdCB2ZXJ5IGZldyBkaXNjcmV0ZSBldmVudHMgdG8gcXVldWUgdXAgYW5kIG9uY2VcbiAgICAvLyB3ZSBhcmUgYWN0dWFsbHkgZnVsbHkgdW5ibG9ja2VkIGl0IHdpbGwgYmUgZmFzdCB0byByZXBsYXkgdGhlbS5cblxuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgcXVldWVkRGlzY3JldGVFdmVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBxdWV1ZWRFdmVudCA9IHF1ZXVlZERpc2NyZXRlRXZlbnRzW2ldO1xuXG4gICAgICBpZiAocXVldWVkRXZlbnQuYmxvY2tlZE9uID09PSB1bmJsb2NrZWQpIHtcbiAgICAgICAgcXVldWVkRXZlbnQuYmxvY2tlZE9uID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAocXVldWVkRm9jdXMgIT09IG51bGwpIHtcbiAgICBzY2hlZHVsZUNhbGxiYWNrSWZVbmJsb2NrZWQocXVldWVkRm9jdXMsIHVuYmxvY2tlZCk7XG4gIH1cblxuICBpZiAocXVldWVkRHJhZyAhPT0gbnVsbCkge1xuICAgIHNjaGVkdWxlQ2FsbGJhY2tJZlVuYmxvY2tlZChxdWV1ZWREcmFnLCB1bmJsb2NrZWQpO1xuICB9XG5cbiAgaWYgKHF1ZXVlZE1vdXNlICE9PSBudWxsKSB7XG4gICAgc2NoZWR1bGVDYWxsYmFja0lmVW5ibG9ja2VkKHF1ZXVlZE1vdXNlLCB1bmJsb2NrZWQpO1xuICB9XG5cbiAgdmFyIHVuYmxvY2sgPSBmdW5jdGlvbiAocXVldWVkRXZlbnQpIHtcbiAgICByZXR1cm4gc2NoZWR1bGVDYWxsYmFja0lmVW5ibG9ja2VkKHF1ZXVlZEV2ZW50LCB1bmJsb2NrZWQpO1xuICB9O1xuXG4gIHF1ZXVlZFBvaW50ZXJzLmZvckVhY2godW5ibG9jayk7XG4gIHF1ZXVlZFBvaW50ZXJDYXB0dXJlcy5mb3JFYWNoKHVuYmxvY2spO1xuXG4gIGZvciAodmFyIF9pID0gMDsgX2kgPCBxdWV1ZWRFeHBsaWNpdEh5ZHJhdGlvblRhcmdldHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgdmFyIHF1ZXVlZFRhcmdldCA9IHF1ZXVlZEV4cGxpY2l0SHlkcmF0aW9uVGFyZ2V0c1tfaV07XG5cbiAgICBpZiAocXVldWVkVGFyZ2V0LmJsb2NrZWRPbiA9PT0gdW5ibG9ja2VkKSB7XG4gICAgICBxdWV1ZWRUYXJnZXQuYmxvY2tlZE9uID0gbnVsbDtcbiAgICB9XG4gIH1cblxuICB3aGlsZSAocXVldWVkRXhwbGljaXRIeWRyYXRpb25UYXJnZXRzLmxlbmd0aCA+IDApIHtcbiAgICB2YXIgbmV4dEV4cGxpY2l0VGFyZ2V0ID0gcXVldWVkRXhwbGljaXRIeWRyYXRpb25UYXJnZXRzWzBdO1xuXG4gICAgaWYgKG5leHRFeHBsaWNpdFRhcmdldC5ibG9ja2VkT24gIT09IG51bGwpIHtcbiAgICAgIC8vIFdlJ3JlIHN0aWxsIGJsb2NrZWQuXG4gICAgICBicmVhaztcbiAgICB9IGVsc2Uge1xuICAgICAgYXR0ZW1wdEV4cGxpY2l0SHlkcmF0aW9uVGFyZ2V0KG5leHRFeHBsaWNpdFRhcmdldCk7XG5cbiAgICAgIGlmIChuZXh0RXhwbGljaXRUYXJnZXQuYmxvY2tlZE9uID09PSBudWxsKSB7XG4gICAgICAgIC8vIFdlJ3JlIHVuYmxvY2tlZC5cbiAgICAgICAgcXVldWVkRXhwbGljaXRIeWRyYXRpb25UYXJnZXRzLnNoaWZ0KCk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbnZhciBEaXNjcmV0ZUV2ZW50ID0gMDtcbnZhciBVc2VyQmxvY2tpbmdFdmVudCA9IDE7XG52YXIgQ29udGludW91c0V2ZW50ID0gMjtcblxuLyoqXG4gKiBHZW5lcmF0ZSBhIG1hcHBpbmcgb2Ygc3RhbmRhcmQgdmVuZG9yIHByZWZpeGVzIHVzaW5nIHRoZSBkZWZpbmVkIHN0eWxlIHByb3BlcnR5IGFuZCBldmVudCBuYW1lLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHlsZVByb3BcbiAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWVcbiAqIEByZXR1cm5zIHtvYmplY3R9XG4gKi9cblxuZnVuY3Rpb24gbWFrZVByZWZpeE1hcChzdHlsZVByb3AsIGV2ZW50TmFtZSkge1xuICB2YXIgcHJlZml4ZXMgPSB7fTtcbiAgcHJlZml4ZXNbc3R5bGVQcm9wLnRvTG93ZXJDYXNlKCldID0gZXZlbnROYW1lLnRvTG93ZXJDYXNlKCk7XG4gIHByZWZpeGVzWydXZWJraXQnICsgc3R5bGVQcm9wXSA9ICd3ZWJraXQnICsgZXZlbnROYW1lO1xuICBwcmVmaXhlc1snTW96JyArIHN0eWxlUHJvcF0gPSAnbW96JyArIGV2ZW50TmFtZTtcbiAgcmV0dXJuIHByZWZpeGVzO1xufVxuLyoqXG4gKiBBIGxpc3Qgb2YgZXZlbnQgbmFtZXMgdG8gYSBjb25maWd1cmFibGUgbGlzdCBvZiB2ZW5kb3IgcHJlZml4ZXMuXG4gKi9cblxuXG52YXIgdmVuZG9yUHJlZml4ZXMgPSB7XG4gIGFuaW1hdGlvbmVuZDogbWFrZVByZWZpeE1hcCgnQW5pbWF0aW9uJywgJ0FuaW1hdGlvbkVuZCcpLFxuICBhbmltYXRpb25pdGVyYXRpb246IG1ha2VQcmVmaXhNYXAoJ0FuaW1hdGlvbicsICdBbmltYXRpb25JdGVyYXRpb24nKSxcbiAgYW5pbWF0aW9uc3RhcnQ6IG1ha2VQcmVmaXhNYXAoJ0FuaW1hdGlvbicsICdBbmltYXRpb25TdGFydCcpLFxuICB0cmFuc2l0aW9uZW5kOiBtYWtlUHJlZml4TWFwKCdUcmFuc2l0aW9uJywgJ1RyYW5zaXRpb25FbmQnKVxufTtcbi8qKlxuICogRXZlbnQgbmFtZXMgdGhhdCBoYXZlIGFscmVhZHkgYmVlbiBkZXRlY3RlZCBhbmQgcHJlZml4ZWQgKGlmIGFwcGxpY2FibGUpLlxuICovXG5cbnZhciBwcmVmaXhlZEV2ZW50TmFtZXMgPSB7fTtcbi8qKlxuICogRWxlbWVudCB0byBjaGVjayBmb3IgcHJlZml4ZXMgb24uXG4gKi9cblxudmFyIHN0eWxlID0ge307XG4vKipcbiAqIEJvb3RzdHJhcCBpZiBhIERPTSBleGlzdHMuXG4gKi9cblxuaWYgKGNhblVzZURPTSkge1xuICBzdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpLnN0eWxlOyAvLyBPbiBzb21lIHBsYXRmb3JtcywgaW4gcGFydGljdWxhciBzb21lIHJlbGVhc2VzIG9mIEFuZHJvaWQgNC54LFxuICAvLyB0aGUgdW4tcHJlZml4ZWQgXCJhbmltYXRpb25cIiBhbmQgXCJ0cmFuc2l0aW9uXCIgcHJvcGVydGllcyBhcmUgZGVmaW5lZCBvbiB0aGVcbiAgLy8gc3R5bGUgb2JqZWN0IGJ1dCB0aGUgZXZlbnRzIHRoYXQgZmlyZSB3aWxsIHN0aWxsIGJlIHByZWZpeGVkLCBzbyB3ZSBuZWVkXG4gIC8vIHRvIGNoZWNrIGlmIHRoZSB1bi1wcmVmaXhlZCBldmVudHMgYXJlIHVzYWJsZSwgYW5kIGlmIG5vdCByZW1vdmUgdGhlbSBmcm9tIHRoZSBtYXAuXG5cbiAgaWYgKCEoJ0FuaW1hdGlvbkV2ZW50JyBpbiB3aW5kb3cpKSB7XG4gICAgZGVsZXRlIHZlbmRvclByZWZpeGVzLmFuaW1hdGlvbmVuZC5hbmltYXRpb247XG4gICAgZGVsZXRlIHZlbmRvclByZWZpeGVzLmFuaW1hdGlvbml0ZXJhdGlvbi5hbmltYXRpb247XG4gICAgZGVsZXRlIHZlbmRvclByZWZpeGVzLmFuaW1hdGlvbnN0YXJ0LmFuaW1hdGlvbjtcbiAgfSAvLyBTYW1lIGFzIGFib3ZlXG5cblxuICBpZiAoISgnVHJhbnNpdGlvbkV2ZW50JyBpbiB3aW5kb3cpKSB7XG4gICAgZGVsZXRlIHZlbmRvclByZWZpeGVzLnRyYW5zaXRpb25lbmQudHJhbnNpdGlvbjtcbiAgfVxufVxuLyoqXG4gKiBBdHRlbXB0cyB0byBkZXRlcm1pbmUgdGhlIGNvcnJlY3QgdmVuZG9yIHByZWZpeGVkIGV2ZW50IG5hbWUuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZVxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuXG5cbmZ1bmN0aW9uIGdldFZlbmRvclByZWZpeGVkRXZlbnROYW1lKGV2ZW50TmFtZSkge1xuICBpZiAocHJlZml4ZWRFdmVudE5hbWVzW2V2ZW50TmFtZV0pIHtcbiAgICByZXR1cm4gcHJlZml4ZWRFdmVudE5hbWVzW2V2ZW50TmFtZV07XG4gIH0gZWxzZSBpZiAoIXZlbmRvclByZWZpeGVzW2V2ZW50TmFtZV0pIHtcbiAgICByZXR1cm4gZXZlbnROYW1lO1xuICB9XG5cbiAgdmFyIHByZWZpeE1hcCA9IHZlbmRvclByZWZpeGVzW2V2ZW50TmFtZV07XG5cbiAgZm9yICh2YXIgc3R5bGVQcm9wIGluIHByZWZpeE1hcCkge1xuICAgIGlmIChwcmVmaXhNYXAuaGFzT3duUHJvcGVydHkoc3R5bGVQcm9wKSAmJiBzdHlsZVByb3AgaW4gc3R5bGUpIHtcbiAgICAgIHJldHVybiBwcmVmaXhlZEV2ZW50TmFtZXNbZXZlbnROYW1lXSA9IHByZWZpeE1hcFtzdHlsZVByb3BdO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBldmVudE5hbWU7XG59XG5cbnZhciBBTklNQVRJT05fRU5EID0gZ2V0VmVuZG9yUHJlZml4ZWRFdmVudE5hbWUoJ2FuaW1hdGlvbmVuZCcpO1xudmFyIEFOSU1BVElPTl9JVEVSQVRJT04gPSBnZXRWZW5kb3JQcmVmaXhlZEV2ZW50TmFtZSgnYW5pbWF0aW9uaXRlcmF0aW9uJyk7XG52YXIgQU5JTUFUSU9OX1NUQVJUID0gZ2V0VmVuZG9yUHJlZml4ZWRFdmVudE5hbWUoJ2FuaW1hdGlvbnN0YXJ0Jyk7XG52YXIgVFJBTlNJVElPTl9FTkQgPSBnZXRWZW5kb3JQcmVmaXhlZEV2ZW50TmFtZSgndHJhbnNpdGlvbmVuZCcpO1xuXG52YXIgdG9wTGV2ZWxFdmVudHNUb1JlYWN0TmFtZXMgPSBuZXcgTWFwKCk7XG52YXIgZXZlbnRQcmlvcml0aWVzID0gbmV3IE1hcCgpOyAvLyBXZSBzdG9yZSBtb3N0IG9mIHRoZSBldmVudHMgaW4gdGhpcyBtb2R1bGUgaW4gcGFpcnMgb2YgdHdvIHN0cmluZ3Mgc28gd2UgY2FuIHJlLXVzZVxuLy8gdGhlIGNvZGUgcmVxdWlyZWQgdG8gYXBwbHkgdGhlIHNhbWUgbG9naWMgZm9yIGV2ZW50IHByaW9yaXRpemF0aW9uIGFuZCB0aGF0IG9mIHRoZVxuLy8gU2ltcGxlRXZlbnRQbHVnaW4uIFRoaXMgY29tcGxpY2F0ZXMgdGhpbmdzIHNsaWdodGx5LCBidXQgdGhlIGFpbSBpcyB0byByZWR1Y2UgY29kZVxuLy8gZHVwbGljYXRpb24gKGZvciB3aGljaCB0aGVyZSB3b3VsZCBiZSBxdWl0ZSBhIGJpdCkuIEZvciB0aGUgZXZlbnRzIHRoYXQgYXJlIG5vdCBuZWVkZWRcbi8vIGZvciB0aGUgU2ltcGxlRXZlbnRQbHVnaW4gKG90aGVyRGlzY3JldGVFdmVudHMpIHdlIHByb2Nlc3MgdGhlbSBzZXBhcmF0ZWx5IGFzIGFuXG4vLyBhcnJheSBvZiB0b3AgbGV2ZWwgZXZlbnRzLlxuLy8gTGFzdGx5LCB3ZSBpZ25vcmUgcHJldHRpZXIgc28gd2UgY2FuIGtlZXAgdGhlIGZvcm1hdHRpbmcgc2FuZS5cbi8vIHByZXR0aWVyLWlnbm9yZVxuXG52YXIgZGlzY3JldGVFdmVudFBhaXJzRm9yU2ltcGxlRXZlbnRQbHVnaW4gPSBbJ2NhbmNlbCcsICdjYW5jZWwnLCAnY2xpY2snLCAnY2xpY2snLCAnY2xvc2UnLCAnY2xvc2UnLCAnY29udGV4dG1lbnUnLCAnY29udGV4dE1lbnUnLCAnY29weScsICdjb3B5JywgJ2N1dCcsICdjdXQnLCAnYXV4Y2xpY2snLCAnYXV4Q2xpY2snLCAnZGJsY2xpY2snLCAnZG91YmxlQ2xpY2snLCAvLyBDYXJlZnVsIVxuJ2RyYWdlbmQnLCAnZHJhZ0VuZCcsICdkcmFnc3RhcnQnLCAnZHJhZ1N0YXJ0JywgJ2Ryb3AnLCAnZHJvcCcsICdmb2N1c2luJywgJ2ZvY3VzJywgLy8gQ2FyZWZ1bCFcbidmb2N1c291dCcsICdibHVyJywgLy8gQ2FyZWZ1bCFcbidpbnB1dCcsICdpbnB1dCcsICdpbnZhbGlkJywgJ2ludmFsaWQnLCAna2V5ZG93bicsICdrZXlEb3duJywgJ2tleXByZXNzJywgJ2tleVByZXNzJywgJ2tleXVwJywgJ2tleVVwJywgJ21vdXNlZG93bicsICdtb3VzZURvd24nLCAnbW91c2V1cCcsICdtb3VzZVVwJywgJ3Bhc3RlJywgJ3Bhc3RlJywgJ3BhdXNlJywgJ3BhdXNlJywgJ3BsYXknLCAncGxheScsICdwb2ludGVyY2FuY2VsJywgJ3BvaW50ZXJDYW5jZWwnLCAncG9pbnRlcmRvd24nLCAncG9pbnRlckRvd24nLCAncG9pbnRlcnVwJywgJ3BvaW50ZXJVcCcsICdyYXRlY2hhbmdlJywgJ3JhdGVDaGFuZ2UnLCAncmVzZXQnLCAncmVzZXQnLCAnc2Vla2VkJywgJ3NlZWtlZCcsICdzdWJtaXQnLCAnc3VibWl0JywgJ3RvdWNoY2FuY2VsJywgJ3RvdWNoQ2FuY2VsJywgJ3RvdWNoZW5kJywgJ3RvdWNoRW5kJywgJ3RvdWNoc3RhcnQnLCAndG91Y2hTdGFydCcsICd2b2x1bWVjaGFuZ2UnLCAndm9sdW1lQ2hhbmdlJ107XG52YXIgb3RoZXJEaXNjcmV0ZUV2ZW50cyA9IFsnY2hhbmdlJywgJ3NlbGVjdGlvbmNoYW5nZScsICd0ZXh0SW5wdXQnLCAnY29tcG9zaXRpb25zdGFydCcsICdjb21wb3NpdGlvbmVuZCcsICdjb21wb3NpdGlvbnVwZGF0ZSddO1xuXG5cbnZhciB1c2VyQmxvY2tpbmdQYWlyc0ZvclNpbXBsZUV2ZW50UGx1Z2luID0gWydkcmFnJywgJ2RyYWcnLCAnZHJhZ2VudGVyJywgJ2RyYWdFbnRlcicsICdkcmFnZXhpdCcsICdkcmFnRXhpdCcsICdkcmFnbGVhdmUnLCAnZHJhZ0xlYXZlJywgJ2RyYWdvdmVyJywgJ2RyYWdPdmVyJywgJ21vdXNlbW92ZScsICdtb3VzZU1vdmUnLCAnbW91c2VvdXQnLCAnbW91c2VPdXQnLCAnbW91c2VvdmVyJywgJ21vdXNlT3ZlcicsICdwb2ludGVybW92ZScsICdwb2ludGVyTW92ZScsICdwb2ludGVyb3V0JywgJ3BvaW50ZXJPdXQnLCAncG9pbnRlcm92ZXInLCAncG9pbnRlck92ZXInLCAnc2Nyb2xsJywgJ3Njcm9sbCcsICd0b2dnbGUnLCAndG9nZ2xlJywgJ3RvdWNobW92ZScsICd0b3VjaE1vdmUnLCAnd2hlZWwnLCAnd2hlZWwnXTsgLy8gcHJldHRpZXItaWdub3JlXG5cbnZhciBjb250aW51b3VzUGFpcnNGb3JTaW1wbGVFdmVudFBsdWdpbiA9IFsnYWJvcnQnLCAnYWJvcnQnLCBBTklNQVRJT05fRU5ELCAnYW5pbWF0aW9uRW5kJywgQU5JTUFUSU9OX0lURVJBVElPTiwgJ2FuaW1hdGlvbkl0ZXJhdGlvbicsIEFOSU1BVElPTl9TVEFSVCwgJ2FuaW1hdGlvblN0YXJ0JywgJ2NhbnBsYXknLCAnY2FuUGxheScsICdjYW5wbGF5dGhyb3VnaCcsICdjYW5QbGF5VGhyb3VnaCcsICdkdXJhdGlvbmNoYW5nZScsICdkdXJhdGlvbkNoYW5nZScsICdlbXB0aWVkJywgJ2VtcHRpZWQnLCAnZW5jcnlwdGVkJywgJ2VuY3J5cHRlZCcsICdlbmRlZCcsICdlbmRlZCcsICdlcnJvcicsICdlcnJvcicsICdnb3Rwb2ludGVyY2FwdHVyZScsICdnb3RQb2ludGVyQ2FwdHVyZScsICdsb2FkJywgJ2xvYWQnLCAnbG9hZGVkZGF0YScsICdsb2FkZWREYXRhJywgJ2xvYWRlZG1ldGFkYXRhJywgJ2xvYWRlZE1ldGFkYXRhJywgJ2xvYWRzdGFydCcsICdsb2FkU3RhcnQnLCAnbG9zdHBvaW50ZXJjYXB0dXJlJywgJ2xvc3RQb2ludGVyQ2FwdHVyZScsICdwbGF5aW5nJywgJ3BsYXlpbmcnLCAncHJvZ3Jlc3MnLCAncHJvZ3Jlc3MnLCAnc2Vla2luZycsICdzZWVraW5nJywgJ3N0YWxsZWQnLCAnc3RhbGxlZCcsICdzdXNwZW5kJywgJ3N1c3BlbmQnLCAndGltZXVwZGF0ZScsICd0aW1lVXBkYXRlJywgVFJBTlNJVElPTl9FTkQsICd0cmFuc2l0aW9uRW5kJywgJ3dhaXRpbmcnLCAnd2FpdGluZyddO1xuLyoqXG4gKiBUdXJuc1xuICogWydhYm9ydCcsIC4uLl1cbiAqXG4gKiBpbnRvXG4gKlxuICogdG9wTGV2ZWxFdmVudHNUb1JlYWN0TmFtZXMgPSBuZXcgTWFwKFtcbiAqICAgWydhYm9ydCcsICdvbkFib3J0J10sXG4gKiBdKTtcbiAqXG4gKiBhbmQgcmVnaXN0ZXJzIHRoZW0uXG4gKi9cblxuZnVuY3Rpb24gcmVnaXN0ZXJTaW1wbGVQbHVnaW5FdmVudHNBbmRTZXRUaGVpclByaW9yaXRpZXMoZXZlbnRUeXBlcywgcHJpb3JpdHkpIHtcbiAgLy8gQXMgdGhlIGV2ZW50IHR5cGVzIGFyZSBpbiBwYWlycyBvZiB0d28sIHdlIG5lZWQgdG8gaXRlcmF0ZVxuICAvLyB0aHJvdWdoIGluIHR3b3MuIFRoZSBldmVudHMgYXJlIGluIHBhaXJzIG9mIHR3byB0byBzYXZlIGNvZGVcbiAgLy8gYW5kIGltcHJvdmUgaW5pdCBwZXJmIG9mIHByb2Nlc3NpbmcgdGhpcyBhcnJheSwgYXMgaXQgd2lsbFxuICAvLyByZXN1bHQgaW4gZmFyIGZld2VyIG9iamVjdCBhbGxvY2F0aW9ucyBhbmQgcHJvcGVydHkgYWNjZXNzZXNcbiAgLy8gaWYgd2Ugb25seSB1c2UgdGhyZWUgYXJyYXlzIHRvIHByb2Nlc3MgYWxsIHRoZSBjYXRlZ29yaWVzIG9mXG4gIC8vIGluc3RlYWQgb2YgdHVwbGVzLlxuICBmb3IgKHZhciBpID0gMDsgaSA8IGV2ZW50VHlwZXMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICB2YXIgdG9wRXZlbnQgPSBldmVudFR5cGVzW2ldO1xuICAgIHZhciBldmVudCA9IGV2ZW50VHlwZXNbaSArIDFdO1xuICAgIHZhciBjYXBpdGFsaXplZEV2ZW50ID0gZXZlbnRbMF0udG9VcHBlckNhc2UoKSArIGV2ZW50LnNsaWNlKDEpO1xuICAgIHZhciByZWFjdE5hbWUgPSAnb24nICsgY2FwaXRhbGl6ZWRFdmVudDtcbiAgICBldmVudFByaW9yaXRpZXMuc2V0KHRvcEV2ZW50LCBwcmlvcml0eSk7XG4gICAgdG9wTGV2ZWxFdmVudHNUb1JlYWN0TmFtZXMuc2V0KHRvcEV2ZW50LCByZWFjdE5hbWUpO1xuICAgIHJlZ2lzdGVyVHdvUGhhc2VFdmVudChyZWFjdE5hbWUsIFt0b3BFdmVudF0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIHNldEV2ZW50UHJpb3JpdGllcyhldmVudFR5cGVzLCBwcmlvcml0eSkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGV2ZW50VHlwZXMubGVuZ3RoOyBpKyspIHtcbiAgICBldmVudFByaW9yaXRpZXMuc2V0KGV2ZW50VHlwZXNbaV0sIHByaW9yaXR5KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRFdmVudFByaW9yaXR5Rm9yUGx1Z2luU3lzdGVtKGRvbUV2ZW50TmFtZSkge1xuICB2YXIgcHJpb3JpdHkgPSBldmVudFByaW9yaXRpZXMuZ2V0KGRvbUV2ZW50TmFtZSk7IC8vIERlZmF1bHQgdG8gYSBDb250aW51b3VzRXZlbnQuIE5vdGU6IHdlIG1pZ2h0XG4gIC8vIHdhbnQgdG8gd2FybiBpZiB3ZSBjYW4ndCBkZXRlY3QgdGhlIHByaW9yaXR5XG4gIC8vIGZvciB0aGUgZXZlbnQuXG5cbiAgcmV0dXJuIHByaW9yaXR5ID09PSB1bmRlZmluZWQgPyBDb250aW51b3VzRXZlbnQgOiBwcmlvcml0eTtcbn1cbmZ1bmN0aW9uIHJlZ2lzdGVyU2ltcGxlRXZlbnRzKCkge1xuICByZWdpc3RlclNpbXBsZVBsdWdpbkV2ZW50c0FuZFNldFRoZWlyUHJpb3JpdGllcyhkaXNjcmV0ZUV2ZW50UGFpcnNGb3JTaW1wbGVFdmVudFBsdWdpbiwgRGlzY3JldGVFdmVudCk7XG4gIHJlZ2lzdGVyU2ltcGxlUGx1Z2luRXZlbnRzQW5kU2V0VGhlaXJQcmlvcml0aWVzKHVzZXJCbG9ja2luZ1BhaXJzRm9yU2ltcGxlRXZlbnRQbHVnaW4sIFVzZXJCbG9ja2luZ0V2ZW50KTtcbiAgcmVnaXN0ZXJTaW1wbGVQbHVnaW5FdmVudHNBbmRTZXRUaGVpclByaW9yaXRpZXMoY29udGludW91c1BhaXJzRm9yU2ltcGxlRXZlbnRQbHVnaW4sIENvbnRpbnVvdXNFdmVudCk7XG4gIHNldEV2ZW50UHJpb3JpdGllcyhvdGhlckRpc2NyZXRlRXZlbnRzLCBEaXNjcmV0ZUV2ZW50KTtcbn1cblxudmFyIFNjaGVkdWxlcl9ub3cgPSBTY2hlZHVsZXIudW5zdGFibGVfbm93O1xuXG57XG4gIC8vIFByb3ZpZGUgZXhwbGljaXQgZXJyb3IgbWVzc2FnZSB3aGVuIHByb2R1Y3Rpb24rcHJvZmlsaW5nIGJ1bmRsZSBvZiBlLmcuXG4gIC8vIHJlYWN0LWRvbSBpcyB1c2VkIHdpdGggcHJvZHVjdGlvbiAobm9uLXByb2ZpbGluZykgYnVuZGxlIG9mXG4gIC8vIHNjaGVkdWxlci90cmFjaW5nXG4gIGlmICghKHRyYWNpbmcuX19pbnRlcmFjdGlvbnNSZWYgIT0gbnVsbCAmJiB0cmFjaW5nLl9faW50ZXJhY3Rpb25zUmVmLmN1cnJlbnQgIT0gbnVsbCkpIHtcbiAgICB7XG4gICAgICB0aHJvdyBFcnJvciggXCJJdCBpcyBub3Qgc3VwcG9ydGVkIHRvIHJ1biB0aGUgcHJvZmlsaW5nIHZlcnNpb24gb2YgYSByZW5kZXJlciAoZm9yIGV4YW1wbGUsIGByZWFjdC1kb20vcHJvZmlsaW5nYCkgd2l0aG91dCBhbHNvIHJlcGxhY2luZyB0aGUgYHNjaGVkdWxlci90cmFjaW5nYCBtb2R1bGUgd2l0aCBgc2NoZWR1bGVyL3RyYWNpbmctcHJvZmlsaW5nYC4gWW91ciBidW5kbGVyIG1pZ2h0IGhhdmUgYSBzZXR0aW5nIGZvciBhbGlhc2luZyBib3RoIG1vZHVsZXMuIExlYXJuIG1vcmUgYXQgaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3Byb2ZpbGluZ1wiICk7XG4gICAgfVxuICB9XG59XG4vLyBhc2NlbmRpbmcgbnVtYmVycyBzbyB3ZSBjYW4gY29tcGFyZSB0aGVtIGxpa2UgbnVtYmVycy4gVGhleSBzdGFydCBhdCA5MCB0b1xuLy8gYXZvaWQgY2xhc2hpbmcgd2l0aCBTY2hlZHVsZXIncyBwcmlvcml0aWVzLlxuXG52YXIgSW1tZWRpYXRlUHJpb3JpdHkgPSA5OTtcbnZhciBVc2VyQmxvY2tpbmdQcmlvcml0eSA9IDk4O1xudmFyIE5vcm1hbFByaW9yaXR5ID0gOTc7XG52YXIgTG93UHJpb3JpdHkgPSA5NjtcbnZhciBJZGxlUHJpb3JpdHkgPSA5NTsgLy8gTm9Qcmlvcml0eSBpcyB0aGUgYWJzZW5jZSBvZiBwcmlvcml0eS4gQWxzbyBSZWFjdC1vbmx5LlxuXG52YXIgTm9Qcmlvcml0eSA9IDkwO1xudmFyIGluaXRpYWxUaW1lTXMgPSBTY2hlZHVsZXJfbm93KCk7IC8vIElmIHRoZSBpbml0aWFsIHRpbWVzdGFtcCBpcyByZWFzb25hYmx5IHNtYWxsLCB1c2UgU2NoZWR1bGVyJ3MgYG5vd2AgZGlyZWN0bHkuXG5cbnZhciBTeW5jTGFuZVByaW9yaXR5ID0gMTU7XG52YXIgU3luY0JhdGNoZWRMYW5lUHJpb3JpdHkgPSAxNDtcbnZhciBJbnB1dERpc2NyZXRlSHlkcmF0aW9uTGFuZVByaW9yaXR5ID0gMTM7XG52YXIgSW5wdXREaXNjcmV0ZUxhbmVQcmlvcml0eSA9IDEyO1xudmFyIElucHV0Q29udGludW91c0h5ZHJhdGlvbkxhbmVQcmlvcml0eSA9IDExO1xudmFyIElucHV0Q29udGludW91c0xhbmVQcmlvcml0eSA9IDEwO1xudmFyIERlZmF1bHRIeWRyYXRpb25MYW5lUHJpb3JpdHkgPSA5O1xudmFyIERlZmF1bHRMYW5lUHJpb3JpdHkgPSA4O1xudmFyIFRyYW5zaXRpb25IeWRyYXRpb25Qcmlvcml0eSA9IDc7XG52YXIgVHJhbnNpdGlvblByaW9yaXR5ID0gNjtcbnZhciBSZXRyeUxhbmVQcmlvcml0eSA9IDU7XG52YXIgU2VsZWN0aXZlSHlkcmF0aW9uTGFuZVByaW9yaXR5ID0gNDtcbnZhciBJZGxlSHlkcmF0aW9uTGFuZVByaW9yaXR5ID0gMztcbnZhciBJZGxlTGFuZVByaW9yaXR5ID0gMjtcbnZhciBPZmZzY3JlZW5MYW5lUHJpb3JpdHkgPSAxO1xudmFyIE5vTGFuZVByaW9yaXR5ID0gMDtcbnZhciBUb3RhbExhbmVzID0gMzE7XG52YXIgTm9MYW5lcyA9XG4vKiAgICAgICAgICAgICAgICAgICAgICAgICovXG4wO1xudmFyIE5vTGFuZSA9XG4vKiAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbjA7XG52YXIgU3luY0xhbmUgPVxuLyogICAgICAgICAgICAgICAgICAgICAgICAqL1xuMTtcbnZhciBTeW5jQmF0Y2hlZExhbmUgPVxuLyogICAgICAgICAgICAgICAgICovXG4yO1xudmFyIElucHV0RGlzY3JldGVIeWRyYXRpb25MYW5lID1cbi8qICAgICAgKi9cbjQ7XG52YXIgSW5wdXREaXNjcmV0ZUxhbmVzID1cbi8qICAgICAgICAgICAgICAgICAgICAqL1xuMjQ7XG52YXIgSW5wdXRDb250aW51b3VzSHlkcmF0aW9uTGFuZSA9XG4vKiAgICAgICAgICAgKi9cbjMyO1xudmFyIElucHV0Q29udGludW91c0xhbmVzID1cbi8qICAgICAgICAgICAgICAgICAgKi9cbjE5MjtcbnZhciBEZWZhdWx0SHlkcmF0aW9uTGFuZSA9XG4vKiAgICAgICAgICAgICovXG4yNTY7XG52YXIgRGVmYXVsdExhbmVzID1cbi8qICAgICAgICAgICAgICAgICAgICovXG4zNTg0O1xudmFyIFRyYW5zaXRpb25IeWRyYXRpb25MYW5lID1cbi8qICAgICAgICAgICAgICAgICovXG40MDk2O1xudmFyIFRyYW5zaXRpb25MYW5lcyA9XG4vKiAgICAgICAgICAgICAgICAgICAgICAgKi9cbjQxODYxMTI7XG52YXIgUmV0cnlMYW5lcyA9XG4vKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuNjI5MTQ1NjA7XG52YXIgU29tZVJldHJ5TGFuZSA9XG4vKiAgICAgICAgICAgICAgICAgICovXG4zMzU1NDQzMjtcbnZhciBTZWxlY3RpdmVIeWRyYXRpb25MYW5lID1cbi8qICAgICAgICAgICovXG42NzEwODg2NDtcbnZhciBOb25JZGxlTGFuZXMgPVxuLyogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuMTM0MjE3NzI3O1xudmFyIElkbGVIeWRyYXRpb25MYW5lID1cbi8qICAgICAgICAgICAgICAgKi9cbjEzNDIxNzcyODtcbnZhciBJZGxlTGFuZXMgPVxuLyogICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG44MDUzMDYzNjg7XG52YXIgT2Zmc2NyZWVuTGFuZSA9XG4vKiAgICAgICAgICAgICAgICAgICAqL1xuMTA3Mzc0MTgyNDtcbnZhciBOb1RpbWVzdGFtcCA9IC0xO1xuZnVuY3Rpb24gc2V0Q3VycmVudFVwZGF0ZUxhbmVQcmlvcml0eShuZXdMYW5lUHJpb3JpdHkpIHtcbn0gLy8gXCJSZWdpc3RlcnNcIiB1c2VkIHRvIFwicmV0dXJuXCIgbXVsdGlwbGUgdmFsdWVzXG4vLyBVc2VkIGJ5IGdldEhpZ2hlc3RQcmlvcml0eUxhbmVzIGFuZCBnZXROZXh0TGFuZXM6XG5cbnZhciByZXR1cm5faGlnaGVzdExhbmVQcmlvcml0eSA9IERlZmF1bHRMYW5lUHJpb3JpdHk7XG5cbmZ1bmN0aW9uIGdldEhpZ2hlc3RQcmlvcml0eUxhbmVzKGxhbmVzKSB7XG4gIGlmICgoU3luY0xhbmUgJiBsYW5lcykgIT09IE5vTGFuZXMpIHtcbiAgICByZXR1cm5faGlnaGVzdExhbmVQcmlvcml0eSA9IFN5bmNMYW5lUHJpb3JpdHk7XG4gICAgcmV0dXJuIFN5bmNMYW5lO1xuICB9XG5cbiAgaWYgKChTeW5jQmF0Y2hlZExhbmUgJiBsYW5lcykgIT09IE5vTGFuZXMpIHtcbiAgICByZXR1cm5faGlnaGVzdExhbmVQcmlvcml0eSA9IFN5bmNCYXRjaGVkTGFuZVByaW9yaXR5O1xuICAgIHJldHVybiBTeW5jQmF0Y2hlZExhbmU7XG4gIH1cblxuICBpZiAoKElucHV0RGlzY3JldGVIeWRyYXRpb25MYW5lICYgbGFuZXMpICE9PSBOb0xhbmVzKSB7XG4gICAgcmV0dXJuX2hpZ2hlc3RMYW5lUHJpb3JpdHkgPSBJbnB1dERpc2NyZXRlSHlkcmF0aW9uTGFuZVByaW9yaXR5O1xuICAgIHJldHVybiBJbnB1dERpc2NyZXRlSHlkcmF0aW9uTGFuZTtcbiAgfVxuXG4gIHZhciBpbnB1dERpc2NyZXRlTGFuZXMgPSBJbnB1dERpc2NyZXRlTGFuZXMgJiBsYW5lcztcblxuICBpZiAoaW5wdXREaXNjcmV0ZUxhbmVzICE9PSBOb0xhbmVzKSB7XG4gICAgcmV0dXJuX2hpZ2hlc3RMYW5lUHJpb3JpdHkgPSBJbnB1dERpc2NyZXRlTGFuZVByaW9yaXR5O1xuICAgIHJldHVybiBpbnB1dERpc2NyZXRlTGFuZXM7XG4gIH1cblxuICBpZiAoKGxhbmVzICYgSW5wdXRDb250aW51b3VzSHlkcmF0aW9uTGFuZSkgIT09IE5vTGFuZXMpIHtcbiAgICByZXR1cm5faGlnaGVzdExhbmVQcmlvcml0eSA9IElucHV0Q29udGludW91c0h5ZHJhdGlvbkxhbmVQcmlvcml0eTtcbiAgICByZXR1cm4gSW5wdXRDb250aW51b3VzSHlkcmF0aW9uTGFuZTtcbiAgfVxuXG4gIHZhciBpbnB1dENvbnRpbnVvdXNMYW5lcyA9IElucHV0Q29udGludW91c0xhbmVzICYgbGFuZXM7XG5cbiAgaWYgKGlucHV0Q29udGludW91c0xhbmVzICE9PSBOb0xhbmVzKSB7XG4gICAgcmV0dXJuX2hpZ2hlc3RMYW5lUHJpb3JpdHkgPSBJbnB1dENvbnRpbnVvdXNMYW5lUHJpb3JpdHk7XG4gICAgcmV0dXJuIGlucHV0Q29udGludW91c0xhbmVzO1xuICB9XG5cbiAgaWYgKChsYW5lcyAmIERlZmF1bHRIeWRyYXRpb25MYW5lKSAhPT0gTm9MYW5lcykge1xuICAgIHJldHVybl9oaWdoZXN0TGFuZVByaW9yaXR5ID0gRGVmYXVsdEh5ZHJhdGlvbkxhbmVQcmlvcml0eTtcbiAgICByZXR1cm4gRGVmYXVsdEh5ZHJhdGlvbkxhbmU7XG4gIH1cblxuICB2YXIgZGVmYXVsdExhbmVzID0gRGVmYXVsdExhbmVzICYgbGFuZXM7XG5cbiAgaWYgKGRlZmF1bHRMYW5lcyAhPT0gTm9MYW5lcykge1xuICAgIHJldHVybl9oaWdoZXN0TGFuZVByaW9yaXR5ID0gRGVmYXVsdExhbmVQcmlvcml0eTtcbiAgICByZXR1cm4gZGVmYXVsdExhbmVzO1xuICB9XG5cbiAgaWYgKChsYW5lcyAmIFRyYW5zaXRpb25IeWRyYXRpb25MYW5lKSAhPT0gTm9MYW5lcykge1xuICAgIHJldHVybl9oaWdoZXN0TGFuZVByaW9yaXR5ID0gVHJhbnNpdGlvbkh5ZHJhdGlvblByaW9yaXR5O1xuICAgIHJldHVybiBUcmFuc2l0aW9uSHlkcmF0aW9uTGFuZTtcbiAgfVxuXG4gIHZhciB0cmFuc2l0aW9uTGFuZXMgPSBUcmFuc2l0aW9uTGFuZXMgJiBsYW5lcztcblxuICBpZiAodHJhbnNpdGlvbkxhbmVzICE9PSBOb0xhbmVzKSB7XG4gICAgcmV0dXJuX2hpZ2hlc3RMYW5lUHJpb3JpdHkgPSBUcmFuc2l0aW9uUHJpb3JpdHk7XG4gICAgcmV0dXJuIHRyYW5zaXRpb25MYW5lcztcbiAgfVxuXG4gIHZhciByZXRyeUxhbmVzID0gUmV0cnlMYW5lcyAmIGxhbmVzO1xuXG4gIGlmIChyZXRyeUxhbmVzICE9PSBOb0xhbmVzKSB7XG4gICAgcmV0dXJuX2hpZ2hlc3RMYW5lUHJpb3JpdHkgPSBSZXRyeUxhbmVQcmlvcml0eTtcbiAgICByZXR1cm4gcmV0cnlMYW5lcztcbiAgfVxuXG4gIGlmIChsYW5lcyAmIFNlbGVjdGl2ZUh5ZHJhdGlvbkxhbmUpIHtcbiAgICByZXR1cm5faGlnaGVzdExhbmVQcmlvcml0eSA9IFNlbGVjdGl2ZUh5ZHJhdGlvbkxhbmVQcmlvcml0eTtcbiAgICByZXR1cm4gU2VsZWN0aXZlSHlkcmF0aW9uTGFuZTtcbiAgfVxuXG4gIGlmICgobGFuZXMgJiBJZGxlSHlkcmF0aW9uTGFuZSkgIT09IE5vTGFuZXMpIHtcbiAgICByZXR1cm5faGlnaGVzdExhbmVQcmlvcml0eSA9IElkbGVIeWRyYXRpb25MYW5lUHJpb3JpdHk7XG4gICAgcmV0dXJuIElkbGVIeWRyYXRpb25MYW5lO1xuICB9XG5cbiAgdmFyIGlkbGVMYW5lcyA9IElkbGVMYW5lcyAmIGxhbmVzO1xuXG4gIGlmIChpZGxlTGFuZXMgIT09IE5vTGFuZXMpIHtcbiAgICByZXR1cm5faGlnaGVzdExhbmVQcmlvcml0eSA9IElkbGVMYW5lUHJpb3JpdHk7XG4gICAgcmV0dXJuIGlkbGVMYW5lcztcbiAgfVxuXG4gIGlmICgoT2Zmc2NyZWVuTGFuZSAmIGxhbmVzKSAhPT0gTm9MYW5lcykge1xuICAgIHJldHVybl9oaWdoZXN0TGFuZVByaW9yaXR5ID0gT2Zmc2NyZWVuTGFuZVByaW9yaXR5O1xuICAgIHJldHVybiBPZmZzY3JlZW5MYW5lO1xuICB9XG5cbiAge1xuICAgIGVycm9yKCdTaG91bGQgaGF2ZSBmb3VuZCBtYXRjaGluZyBsYW5lcy4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC4nKTtcbiAgfSAvLyBUaGlzIHNob3VsZG4ndCBiZSByZWFjaGFibGUsIGJ1dCBhcyBhIGZhbGxiYWNrLCByZXR1cm4gdGhlIGVudGlyZSBiaXRtYXNrLlxuXG5cbiAgcmV0dXJuX2hpZ2hlc3RMYW5lUHJpb3JpdHkgPSBEZWZhdWx0TGFuZVByaW9yaXR5O1xuICByZXR1cm4gbGFuZXM7XG59XG5cbmZ1bmN0aW9uIHNjaGVkdWxlclByaW9yaXR5VG9MYW5lUHJpb3JpdHkoc2NoZWR1bGVyUHJpb3JpdHlMZXZlbCkge1xuICBzd2l0Y2ggKHNjaGVkdWxlclByaW9yaXR5TGV2ZWwpIHtcbiAgICBjYXNlIEltbWVkaWF0ZVByaW9yaXR5OlxuICAgICAgcmV0dXJuIFN5bmNMYW5lUHJpb3JpdHk7XG5cbiAgICBjYXNlIFVzZXJCbG9ja2luZ1ByaW9yaXR5OlxuICAgICAgcmV0dXJuIElucHV0Q29udGludW91c0xhbmVQcmlvcml0eTtcblxuICAgIGNhc2UgTm9ybWFsUHJpb3JpdHk6XG4gICAgY2FzZSBMb3dQcmlvcml0eTpcbiAgICAgIC8vIFRPRE86IEhhbmRsZSBMb3dTY2hlZHVsZXJQcmlvcml0eSwgc29tZWhvdy4gTWF5YmUgdGhlIHNhbWUgbGFuZSBhcyBoeWRyYXRpb24uXG4gICAgICByZXR1cm4gRGVmYXVsdExhbmVQcmlvcml0eTtcblxuICAgIGNhc2UgSWRsZVByaW9yaXR5OlxuICAgICAgcmV0dXJuIElkbGVMYW5lUHJpb3JpdHk7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIE5vTGFuZVByaW9yaXR5O1xuICB9XG59XG5mdW5jdGlvbiBsYW5lUHJpb3JpdHlUb1NjaGVkdWxlclByaW9yaXR5KGxhbmVQcmlvcml0eSkge1xuICBzd2l0Y2ggKGxhbmVQcmlvcml0eSkge1xuICAgIGNhc2UgU3luY0xhbmVQcmlvcml0eTpcbiAgICBjYXNlIFN5bmNCYXRjaGVkTGFuZVByaW9yaXR5OlxuICAgICAgcmV0dXJuIEltbWVkaWF0ZVByaW9yaXR5O1xuXG4gICAgY2FzZSBJbnB1dERpc2NyZXRlSHlkcmF0aW9uTGFuZVByaW9yaXR5OlxuICAgIGNhc2UgSW5wdXREaXNjcmV0ZUxhbmVQcmlvcml0eTpcbiAgICBjYXNlIElucHV0Q29udGludW91c0h5ZHJhdGlvbkxhbmVQcmlvcml0eTpcbiAgICBjYXNlIElucHV0Q29udGludW91c0xhbmVQcmlvcml0eTpcbiAgICAgIHJldHVybiBVc2VyQmxvY2tpbmdQcmlvcml0eTtcblxuICAgIGNhc2UgRGVmYXVsdEh5ZHJhdGlvbkxhbmVQcmlvcml0eTpcbiAgICBjYXNlIERlZmF1bHRMYW5lUHJpb3JpdHk6XG4gICAgY2FzZSBUcmFuc2l0aW9uSHlkcmF0aW9uUHJpb3JpdHk6XG4gICAgY2FzZSBUcmFuc2l0aW9uUHJpb3JpdHk6XG4gICAgY2FzZSBTZWxlY3RpdmVIeWRyYXRpb25MYW5lUHJpb3JpdHk6XG4gICAgY2FzZSBSZXRyeUxhbmVQcmlvcml0eTpcbiAgICAgIHJldHVybiBOb3JtYWxQcmlvcml0eTtcblxuICAgIGNhc2UgSWRsZUh5ZHJhdGlvbkxhbmVQcmlvcml0eTpcbiAgICBjYXNlIElkbGVMYW5lUHJpb3JpdHk6XG4gICAgY2FzZSBPZmZzY3JlZW5MYW5lUHJpb3JpdHk6XG4gICAgICByZXR1cm4gSWRsZVByaW9yaXR5O1xuXG4gICAgY2FzZSBOb0xhbmVQcmlvcml0eTpcbiAgICAgIHJldHVybiBOb1ByaW9yaXR5O1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHtcbiAgICAgICAge1xuICAgICAgICAgIHRocm93IEVycm9yKCBcIkludmFsaWQgdXBkYXRlIHByaW9yaXR5OiBcIiArIGxhbmVQcmlvcml0eSArIFwiLiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LlwiICk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICB9XG59XG5mdW5jdGlvbiBnZXROZXh0TGFuZXMocm9vdCwgd2lwTGFuZXMpIHtcbiAgLy8gRWFybHkgYmFpbG91dCBpZiB0aGVyZSdzIG5vIHBlbmRpbmcgd29yayBsZWZ0LlxuICB2YXIgcGVuZGluZ0xhbmVzID0gcm9vdC5wZW5kaW5nTGFuZXM7XG5cbiAgaWYgKHBlbmRpbmdMYW5lcyA9PT0gTm9MYW5lcykge1xuICAgIHJldHVybl9oaWdoZXN0TGFuZVByaW9yaXR5ID0gTm9MYW5lUHJpb3JpdHk7XG4gICAgcmV0dXJuIE5vTGFuZXM7XG4gIH1cblxuICB2YXIgbmV4dExhbmVzID0gTm9MYW5lcztcbiAgdmFyIG5leHRMYW5lUHJpb3JpdHkgPSBOb0xhbmVQcmlvcml0eTtcbiAgdmFyIGV4cGlyZWRMYW5lcyA9IHJvb3QuZXhwaXJlZExhbmVzO1xuICB2YXIgc3VzcGVuZGVkTGFuZXMgPSByb290LnN1c3BlbmRlZExhbmVzO1xuICB2YXIgcGluZ2VkTGFuZXMgPSByb290LnBpbmdlZExhbmVzOyAvLyBDaGVjayBpZiBhbnkgd29yayBoYXMgZXhwaXJlZC5cblxuICBpZiAoZXhwaXJlZExhbmVzICE9PSBOb0xhbmVzKSB7XG4gICAgbmV4dExhbmVzID0gZXhwaXJlZExhbmVzO1xuICAgIG5leHRMYW5lUHJpb3JpdHkgPSByZXR1cm5faGlnaGVzdExhbmVQcmlvcml0eSA9IFN5bmNMYW5lUHJpb3JpdHk7XG4gIH0gZWxzZSB7XG4gICAgLy8gRG8gbm90IHdvcmsgb24gYW55IGlkbGUgd29yayB1bnRpbCBhbGwgdGhlIG5vbi1pZGxlIHdvcmsgaGFzIGZpbmlzaGVkLFxuICAgIC8vIGV2ZW4gaWYgdGhlIHdvcmsgaXMgc3VzcGVuZGVkLlxuICAgIHZhciBub25JZGxlUGVuZGluZ0xhbmVzID0gcGVuZGluZ0xhbmVzICYgTm9uSWRsZUxhbmVzO1xuXG4gICAgaWYgKG5vbklkbGVQZW5kaW5nTGFuZXMgIT09IE5vTGFuZXMpIHtcbiAgICAgIHZhciBub25JZGxlVW5ibG9ja2VkTGFuZXMgPSBub25JZGxlUGVuZGluZ0xhbmVzICYgfnN1c3BlbmRlZExhbmVzO1xuXG4gICAgICBpZiAobm9uSWRsZVVuYmxvY2tlZExhbmVzICE9PSBOb0xhbmVzKSB7XG4gICAgICAgIG5leHRMYW5lcyA9IGdldEhpZ2hlc3RQcmlvcml0eUxhbmVzKG5vbklkbGVVbmJsb2NrZWRMYW5lcyk7XG4gICAgICAgIG5leHRMYW5lUHJpb3JpdHkgPSByZXR1cm5faGlnaGVzdExhbmVQcmlvcml0eTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBub25JZGxlUGluZ2VkTGFuZXMgPSBub25JZGxlUGVuZGluZ0xhbmVzICYgcGluZ2VkTGFuZXM7XG5cbiAgICAgICAgaWYgKG5vbklkbGVQaW5nZWRMYW5lcyAhPT0gTm9MYW5lcykge1xuICAgICAgICAgIG5leHRMYW5lcyA9IGdldEhpZ2hlc3RQcmlvcml0eUxhbmVzKG5vbklkbGVQaW5nZWRMYW5lcyk7XG4gICAgICAgICAgbmV4dExhbmVQcmlvcml0eSA9IHJldHVybl9oaWdoZXN0TGFuZVByaW9yaXR5O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRoZSBvbmx5IHJlbWFpbmluZyB3b3JrIGlzIElkbGUuXG4gICAgICB2YXIgdW5ibG9ja2VkTGFuZXMgPSBwZW5kaW5nTGFuZXMgJiB+c3VzcGVuZGVkTGFuZXM7XG5cbiAgICAgIGlmICh1bmJsb2NrZWRMYW5lcyAhPT0gTm9MYW5lcykge1xuICAgICAgICBuZXh0TGFuZXMgPSBnZXRIaWdoZXN0UHJpb3JpdHlMYW5lcyh1bmJsb2NrZWRMYW5lcyk7XG4gICAgICAgIG5leHRMYW5lUHJpb3JpdHkgPSByZXR1cm5faGlnaGVzdExhbmVQcmlvcml0eTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChwaW5nZWRMYW5lcyAhPT0gTm9MYW5lcykge1xuICAgICAgICAgIG5leHRMYW5lcyA9IGdldEhpZ2hlc3RQcmlvcml0eUxhbmVzKHBpbmdlZExhbmVzKTtcbiAgICAgICAgICBuZXh0TGFuZVByaW9yaXR5ID0gcmV0dXJuX2hpZ2hlc3RMYW5lUHJpb3JpdHk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAobmV4dExhbmVzID09PSBOb0xhbmVzKSB7XG4gICAgLy8gVGhpcyBzaG91bGQgb25seSBiZSByZWFjaGFibGUgaWYgd2UncmUgc3VzcGVuZGVkXG4gICAgLy8gVE9ETzogQ29uc2lkZXIgd2FybmluZyBpbiB0aGlzIHBhdGggaWYgYSBmYWxsYmFjayB0aW1lciBpcyBub3Qgc2NoZWR1bGVkLlxuICAgIHJldHVybiBOb0xhbmVzO1xuICB9IC8vIElmIHRoZXJlIGFyZSBoaWdoZXIgcHJpb3JpdHkgbGFuZXMsIHdlJ2xsIGluY2x1ZGUgdGhlbSBldmVuIGlmIHRoZXlcbiAgLy8gYXJlIHN1c3BlbmRlZC5cblxuXG4gIG5leHRMYW5lcyA9IHBlbmRpbmdMYW5lcyAmIGdldEVxdWFsT3JIaWdoZXJQcmlvcml0eUxhbmVzKG5leHRMYW5lcyk7IC8vIElmIHdlJ3JlIGFscmVhZHkgaW4gdGhlIG1pZGRsZSBvZiBhIHJlbmRlciwgc3dpdGNoaW5nIGxhbmVzIHdpbGwgaW50ZXJydXB0XG4gIC8vIGl0IGFuZCB3ZSdsbCBsb3NlIG91ciBwcm9ncmVzcy4gV2Ugc2hvdWxkIG9ubHkgZG8gdGhpcyBpZiB0aGUgbmV3IGxhbmVzIGFyZVxuICAvLyBoaWdoZXIgcHJpb3JpdHkuXG5cbiAgaWYgKHdpcExhbmVzICE9PSBOb0xhbmVzICYmIHdpcExhbmVzICE9PSBuZXh0TGFuZXMgJiYgLy8gSWYgd2UgYWxyZWFkeSBzdXNwZW5kZWQgd2l0aCBhIGRlbGF5LCB0aGVuIGludGVycnVwdGluZyBpcyBmaW5lLiBEb24ndFxuICAvLyBib3RoZXIgd2FpdGluZyB1bnRpbCB0aGUgcm9vdCBpcyBjb21wbGV0ZS5cbiAgKHdpcExhbmVzICYgc3VzcGVuZGVkTGFuZXMpID09PSBOb0xhbmVzKSB7XG4gICAgZ2V0SGlnaGVzdFByaW9yaXR5TGFuZXMod2lwTGFuZXMpO1xuICAgIHZhciB3aXBMYW5lUHJpb3JpdHkgPSByZXR1cm5faGlnaGVzdExhbmVQcmlvcml0eTtcblxuICAgIGlmIChuZXh0TGFuZVByaW9yaXR5IDw9IHdpcExhbmVQcmlvcml0eSkge1xuICAgICAgcmV0dXJuIHdpcExhbmVzO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm5faGlnaGVzdExhbmVQcmlvcml0eSA9IG5leHRMYW5lUHJpb3JpdHk7XG4gICAgfVxuICB9IC8vIENoZWNrIGZvciBlbnRhbmdsZWQgbGFuZXMgYW5kIGFkZCB0aGVtIHRvIHRoZSBiYXRjaC5cbiAgLy9cbiAgLy8gQSBsYW5lIGlzIHNhaWQgdG8gYmUgZW50YW5nbGVkIHdpdGggYW5vdGhlciB3aGVuIGl0J3Mgbm90IGFsbG93ZWQgdG8gcmVuZGVyXG4gIC8vIGluIGEgYmF0Y2ggdGhhdCBkb2VzIG5vdCBhbHNvIGluY2x1ZGUgdGhlIG90aGVyIGxhbmUuIFR5cGljYWxseSB3ZSBkbyB0aGlzXG4gIC8vIHdoZW4gbXVsdGlwbGUgdXBkYXRlcyBoYXZlIHRoZSBzYW1lIHNvdXJjZSwgYW5kIHdlIG9ubHkgd2FudCB0byByZXNwb25kIHRvXG4gIC8vIHRoZSBtb3N0IHJlY2VudCBldmVudCBmcm9tIHRoYXQgc291cmNlLlxuICAvL1xuICAvLyBOb3RlIHRoYXQgd2UgYXBwbHkgZW50YW5nbGVtZW50cyAqYWZ0ZXIqIGNoZWNraW5nIGZvciBwYXJ0aWFsIHdvcmsgYWJvdmUuXG4gIC8vIFRoaXMgbWVhbnMgdGhhdCBpZiBhIGxhbmUgaXMgZW50YW5nbGVkIGR1cmluZyBhbiBpbnRlcmxlYXZlZCBldmVudCB3aGlsZVxuICAvLyBpdCdzIGFscmVhZHkgcmVuZGVyaW5nLCB3ZSB3b24ndCBpbnRlcnJ1cHQgaXQuIFRoaXMgaXMgaW50ZW50aW9uYWwsIHNpbmNlXG4gIC8vIGVudGFuZ2xlbWVudCBpcyB1c3VhbGx5IFwiYmVzdCBlZmZvcnRcIjogd2UnbGwgdHJ5IG91ciBiZXN0IHRvIHJlbmRlciB0aGVcbiAgLy8gbGFuZXMgaW4gdGhlIHNhbWUgYmF0Y2gsIGJ1dCBpdCdzIG5vdCB3b3J0aCB0aHJvd2luZyBvdXQgcGFydGlhbGx5XG4gIC8vIGNvbXBsZXRlZCB3b3JrIGluIG9yZGVyIHRvIGRvIGl0LlxuICAvL1xuICAvLyBGb3IgdGhvc2UgZXhjZXB0aW9ucyB3aGVyZSBlbnRhbmdsZW1lbnQgaXMgc2VtYW50aWNhbGx5IGltcG9ydGFudCwgbGlrZVxuICAvLyB1c2VNdXRhYmxlU291cmNlLCB3ZSBzaG91bGQgZW5zdXJlIHRoYXQgdGhlcmUgaXMgbm8gcGFydGlhbCB3b3JrIGF0IHRoZVxuICAvLyB0aW1lIHdlIGFwcGx5IHRoZSBlbnRhbmdsZW1lbnQuXG5cblxuICB2YXIgZW50YW5nbGVkTGFuZXMgPSByb290LmVudGFuZ2xlZExhbmVzO1xuXG4gIGlmIChlbnRhbmdsZWRMYW5lcyAhPT0gTm9MYW5lcykge1xuICAgIHZhciBlbnRhbmdsZW1lbnRzID0gcm9vdC5lbnRhbmdsZW1lbnRzO1xuICAgIHZhciBsYW5lcyA9IG5leHRMYW5lcyAmIGVudGFuZ2xlZExhbmVzO1xuXG4gICAgd2hpbGUgKGxhbmVzID4gMCkge1xuICAgICAgdmFyIGluZGV4ID0gcGlja0FyYml0cmFyeUxhbmVJbmRleChsYW5lcyk7XG4gICAgICB2YXIgbGFuZSA9IDEgPDwgaW5kZXg7XG4gICAgICBuZXh0TGFuZXMgfD0gZW50YW5nbGVtZW50c1tpbmRleF07XG4gICAgICBsYW5lcyAmPSB+bGFuZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmV4dExhbmVzO1xufVxuZnVuY3Rpb24gZ2V0TW9zdFJlY2VudEV2ZW50VGltZShyb290LCBsYW5lcykge1xuICB2YXIgZXZlbnRUaW1lcyA9IHJvb3QuZXZlbnRUaW1lcztcbiAgdmFyIG1vc3RSZWNlbnRFdmVudFRpbWUgPSBOb1RpbWVzdGFtcDtcblxuICB3aGlsZSAobGFuZXMgPiAwKSB7XG4gICAgdmFyIGluZGV4ID0gcGlja0FyYml0cmFyeUxhbmVJbmRleChsYW5lcyk7XG4gICAgdmFyIGxhbmUgPSAxIDw8IGluZGV4O1xuICAgIHZhciBldmVudFRpbWUgPSBldmVudFRpbWVzW2luZGV4XTtcblxuICAgIGlmIChldmVudFRpbWUgPiBtb3N0UmVjZW50RXZlbnRUaW1lKSB7XG4gICAgICBtb3N0UmVjZW50RXZlbnRUaW1lID0gZXZlbnRUaW1lO1xuICAgIH1cblxuICAgIGxhbmVzICY9IH5sYW5lO1xuICB9XG5cbiAgcmV0dXJuIG1vc3RSZWNlbnRFdmVudFRpbWU7XG59XG5cbmZ1bmN0aW9uIGNvbXB1dGVFeHBpcmF0aW9uVGltZShsYW5lLCBjdXJyZW50VGltZSkge1xuICAvLyBUT0RPOiBFeHBpcmF0aW9uIGhldXJpc3RpYyBpcyBjb25zdGFudCBwZXIgbGFuZSwgc28gY291bGQgdXNlIGEgbWFwLlxuICBnZXRIaWdoZXN0UHJpb3JpdHlMYW5lcyhsYW5lKTtcbiAgdmFyIHByaW9yaXR5ID0gcmV0dXJuX2hpZ2hlc3RMYW5lUHJpb3JpdHk7XG5cbiAgaWYgKHByaW9yaXR5ID49IElucHV0Q29udGludW91c0xhbmVQcmlvcml0eSkge1xuICAgIC8vIFVzZXIgaW50ZXJhY3Rpb25zIHNob3VsZCBleHBpcmUgc2xpZ2h0bHkgbW9yZSBxdWlja2x5LlxuICAgIC8vXG4gICAgLy8gTk9URTogVGhpcyBpcyBzZXQgdG8gdGhlIGNvcnJlc3BvbmRpbmcgY29uc3RhbnQgYXMgaW4gU2NoZWR1bGVyLmpzLiBXaGVuXG4gICAgLy8gd2UgbWFkZSBpdCBsYXJnZXIsIGEgcHJvZHVjdCBtZXRyaWMgaW4gd3d3IHJlZ3Jlc3NlZCwgc3VnZ2VzdGluZyB0aGVyZSdzXG4gICAgLy8gYSB1c2VyIGludGVyYWN0aW9uIHRoYXQncyBiZWluZyBzdGFydmVkIGJ5IGEgc2VyaWVzIG9mIHN5bmNocm9ub3VzXG4gICAgLy8gdXBkYXRlcy4gSWYgdGhhdCB0aGVvcnkgaXMgY29ycmVjdCwgdGhlIHByb3BlciBzb2x1dGlvbiBpcyB0byBmaXggdGhlXG4gICAgLy8gc3RhcnZhdGlvbi4gSG93ZXZlciwgdGhpcyBzY2VuYXJpbyBzdXBwb3J0cyB0aGUgaWRlYSB0aGF0IGV4cGlyYXRpb25cbiAgICAvLyB0aW1lcyBhcmUgYW4gaW1wb3J0YW50IHNhZmVndWFyZCB3aGVuIHN0YXJ2YXRpb24gZG9lcyBoYXBwZW4uXG4gICAgLy9cbiAgICAvLyBBbHNvIG5vdGUgdGhhdCwgaW4gdGhlIGNhc2Ugb2YgdXNlciBpbnB1dCBzcGVjaWZpY2FsbHksIHRoaXMgd2lsbCBzb29uIG5vXG4gICAgLy8gbG9uZ2VyIGJlIGFuIGlzc3VlIGJlY2F1c2Ugd2UgcGxhbiB0byBtYWtlIHVzZXIgaW5wdXQgc3luY2hyb25vdXMgYnlcbiAgICAvLyBkZWZhdWx0ICh1bnRpbCB5b3UgZW50ZXIgYHN0YXJ0VHJhbnNpdGlvbmAsIG9mIGNvdXJzZS4pXG4gICAgLy9cbiAgICAvLyBJZiB3ZXJlbid0IHBsYW5uaW5nIHRvIG1ha2UgdGhlc2UgdXBkYXRlcyBzeW5jaHJvbm91cyBzb29uIGFueXdheSwgSVxuICAgIC8vIHdvdWxkIHByb2JhYmx5IG1ha2UgdGhpcyBudW1iZXIgYSBjb25maWd1cmFibGUgcGFyYW1ldGVyLlxuICAgIHJldHVybiBjdXJyZW50VGltZSArIDI1MDtcbiAgfSBlbHNlIGlmIChwcmlvcml0eSA+PSBUcmFuc2l0aW9uUHJpb3JpdHkpIHtcbiAgICByZXR1cm4gY3VycmVudFRpbWUgKyA1MDAwO1xuICB9IGVsc2Uge1xuICAgIC8vIEFueXRoaW5nIGlkbGUgcHJpb3JpdHkgb3IgbG93ZXIgc2hvdWxkIG5ldmVyIGV4cGlyZS5cbiAgICByZXR1cm4gTm9UaW1lc3RhbXA7XG4gIH1cbn1cblxuZnVuY3Rpb24gbWFya1N0YXJ2ZWRMYW5lc0FzRXhwaXJlZChyb290LCBjdXJyZW50VGltZSkge1xuICAvLyBUT0RPOiBUaGlzIGdldHMgY2FsbGVkIGV2ZXJ5IHRpbWUgd2UgeWllbGQuIFdlIGNhbiBvcHRpbWl6ZSBieSBzdG9yaW5nXG4gIC8vIHRoZSBlYXJsaWVzdCBleHBpcmF0aW9uIHRpbWUgb24gdGhlIHJvb3QuIFRoZW4gdXNlIHRoYXQgdG8gcXVpY2tseSBiYWlsIG91dFxuICAvLyBvZiB0aGlzIGZ1bmN0aW9uLlxuICB2YXIgcGVuZGluZ0xhbmVzID0gcm9vdC5wZW5kaW5nTGFuZXM7XG4gIHZhciBzdXNwZW5kZWRMYW5lcyA9IHJvb3Quc3VzcGVuZGVkTGFuZXM7XG4gIHZhciBwaW5nZWRMYW5lcyA9IHJvb3QucGluZ2VkTGFuZXM7XG4gIHZhciBleHBpcmF0aW9uVGltZXMgPSByb290LmV4cGlyYXRpb25UaW1lczsgLy8gSXRlcmF0ZSB0aHJvdWdoIHRoZSBwZW5kaW5nIGxhbmVzIGFuZCBjaGVjayBpZiB3ZSd2ZSByZWFjaGVkIHRoZWlyXG4gIC8vIGV4cGlyYXRpb24gdGltZS4gSWYgc28sIHdlJ2xsIGFzc3VtZSB0aGUgdXBkYXRlIGlzIGJlaW5nIHN0YXJ2ZWQgYW5kIG1hcmtcbiAgLy8gaXQgYXMgZXhwaXJlZCB0byBmb3JjZSBpdCB0byBmaW5pc2guXG5cbiAgdmFyIGxhbmVzID0gcGVuZGluZ0xhbmVzO1xuXG4gIHdoaWxlIChsYW5lcyA+IDApIHtcbiAgICB2YXIgaW5kZXggPSBwaWNrQXJiaXRyYXJ5TGFuZUluZGV4KGxhbmVzKTtcbiAgICB2YXIgbGFuZSA9IDEgPDwgaW5kZXg7XG4gICAgdmFyIGV4cGlyYXRpb25UaW1lID0gZXhwaXJhdGlvblRpbWVzW2luZGV4XTtcblxuICAgIGlmIChleHBpcmF0aW9uVGltZSA9PT0gTm9UaW1lc3RhbXApIHtcbiAgICAgIC8vIEZvdW5kIGEgcGVuZGluZyBsYW5lIHdpdGggbm8gZXhwaXJhdGlvbiB0aW1lLiBJZiBpdCdzIG5vdCBzdXNwZW5kZWQsIG9yXG4gICAgICAvLyBpZiBpdCdzIHBpbmdlZCwgYXNzdW1lIGl0J3MgQ1BVLWJvdW5kLiBDb21wdXRlIGEgbmV3IGV4cGlyYXRpb24gdGltZVxuICAgICAgLy8gdXNpbmcgdGhlIGN1cnJlbnQgdGltZS5cbiAgICAgIGlmICgobGFuZSAmIHN1c3BlbmRlZExhbmVzKSA9PT0gTm9MYW5lcyB8fCAobGFuZSAmIHBpbmdlZExhbmVzKSAhPT0gTm9MYW5lcykge1xuICAgICAgICAvLyBBc3N1bWVzIHRpbWVzdGFtcHMgYXJlIG1vbm90b25pY2FsbHkgaW5jcmVhc2luZy5cbiAgICAgICAgZXhwaXJhdGlvblRpbWVzW2luZGV4XSA9IGNvbXB1dGVFeHBpcmF0aW9uVGltZShsYW5lLCBjdXJyZW50VGltZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChleHBpcmF0aW9uVGltZSA8PSBjdXJyZW50VGltZSkge1xuICAgICAgLy8gVGhpcyBsYW5lIGV4cGlyZWRcbiAgICAgIHJvb3QuZXhwaXJlZExhbmVzIHw9IGxhbmU7XG4gICAgfVxuXG4gICAgbGFuZXMgJj0gfmxhbmU7XG4gIH1cbn0gLy8gVGhpcyByZXR1cm5zIHRoZSBoaWdoZXN0IHByaW9yaXR5IHBlbmRpbmcgbGFuZXMgcmVnYXJkbGVzcyBvZiB3aGV0aGVyIHRoZXlcbmZ1bmN0aW9uIGdldExhbmVzVG9SZXRyeVN5bmNocm9ub3VzbHlPbkVycm9yKHJvb3QpIHtcbiAgdmFyIGV2ZXJ5dGhpbmdCdXRPZmZzY3JlZW4gPSByb290LnBlbmRpbmdMYW5lcyAmIH5PZmZzY3JlZW5MYW5lO1xuXG4gIGlmIChldmVyeXRoaW5nQnV0T2Zmc2NyZWVuICE9PSBOb0xhbmVzKSB7XG4gICAgcmV0dXJuIGV2ZXJ5dGhpbmdCdXRPZmZzY3JlZW47XG4gIH1cblxuICBpZiAoZXZlcnl0aGluZ0J1dE9mZnNjcmVlbiAmIE9mZnNjcmVlbkxhbmUpIHtcbiAgICByZXR1cm4gT2Zmc2NyZWVuTGFuZTtcbiAgfVxuXG4gIHJldHVybiBOb0xhbmVzO1xufVxuZnVuY3Rpb24gcmV0dXJuTmV4dExhbmVzUHJpb3JpdHkoKSB7XG4gIHJldHVybiByZXR1cm5faGlnaGVzdExhbmVQcmlvcml0eTtcbn1cbmZ1bmN0aW9uIGluY2x1ZGVzTm9uSWRsZVdvcmsobGFuZXMpIHtcbiAgcmV0dXJuIChsYW5lcyAmIE5vbklkbGVMYW5lcykgIT09IE5vTGFuZXM7XG59XG5mdW5jdGlvbiBpbmNsdWRlc09ubHlSZXRyaWVzKGxhbmVzKSB7XG4gIHJldHVybiAobGFuZXMgJiBSZXRyeUxhbmVzKSA9PT0gbGFuZXM7XG59XG5mdW5jdGlvbiBpbmNsdWRlc09ubHlUcmFuc2l0aW9ucyhsYW5lcykge1xuICByZXR1cm4gKGxhbmVzICYgVHJhbnNpdGlvbkxhbmVzKSA9PT0gbGFuZXM7XG59IC8vIFRvIGVuc3VyZSBjb25zaXN0ZW5jeSBhY3Jvc3MgbXVsdGlwbGUgdXBkYXRlcyBpbiB0aGUgc2FtZSBldmVudCwgdGhpcyBzaG91bGRcbi8vIGJlIGEgcHVyZSBmdW5jdGlvbiwgc28gdGhhdCBpdCBhbHdheXMgcmV0dXJucyB0aGUgc2FtZSBsYW5lIGZvciBnaXZlbiBpbnB1dHMuXG5cbmZ1bmN0aW9uIGZpbmRVcGRhdGVMYW5lKGxhbmVQcmlvcml0eSwgd2lwTGFuZXMpIHtcbiAgc3dpdGNoIChsYW5lUHJpb3JpdHkpIHtcbiAgICBjYXNlIE5vTGFuZVByaW9yaXR5OlxuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIFN5bmNMYW5lUHJpb3JpdHk6XG4gICAgICByZXR1cm4gU3luY0xhbmU7XG5cbiAgICBjYXNlIFN5bmNCYXRjaGVkTGFuZVByaW9yaXR5OlxuICAgICAgcmV0dXJuIFN5bmNCYXRjaGVkTGFuZTtcblxuICAgIGNhc2UgSW5wdXREaXNjcmV0ZUxhbmVQcmlvcml0eTpcbiAgICAgIHtcbiAgICAgICAgdmFyIF9sYW5lID0gcGlja0FyYml0cmFyeUxhbmUoSW5wdXREaXNjcmV0ZUxhbmVzICYgfndpcExhbmVzKTtcblxuICAgICAgICBpZiAoX2xhbmUgPT09IE5vTGFuZSkge1xuICAgICAgICAgIC8vIFNoaWZ0IHRvIHRoZSBuZXh0IHByaW9yaXR5IGxldmVsXG4gICAgICAgICAgcmV0dXJuIGZpbmRVcGRhdGVMYW5lKElucHV0Q29udGludW91c0xhbmVQcmlvcml0eSwgd2lwTGFuZXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIF9sYW5lO1xuICAgICAgfVxuXG4gICAgY2FzZSBJbnB1dENvbnRpbnVvdXNMYW5lUHJpb3JpdHk6XG4gICAgICB7XG4gICAgICAgIHZhciBfbGFuZTIgPSBwaWNrQXJiaXRyYXJ5TGFuZShJbnB1dENvbnRpbnVvdXNMYW5lcyAmIH53aXBMYW5lcyk7XG5cbiAgICAgICAgaWYgKF9sYW5lMiA9PT0gTm9MYW5lKSB7XG4gICAgICAgICAgLy8gU2hpZnQgdG8gdGhlIG5leHQgcHJpb3JpdHkgbGV2ZWxcbiAgICAgICAgICByZXR1cm4gZmluZFVwZGF0ZUxhbmUoRGVmYXVsdExhbmVQcmlvcml0eSwgd2lwTGFuZXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIF9sYW5lMjtcbiAgICAgIH1cblxuICAgIGNhc2UgRGVmYXVsdExhbmVQcmlvcml0eTpcbiAgICAgIHtcbiAgICAgICAgdmFyIF9sYW5lMyA9IHBpY2tBcmJpdHJhcnlMYW5lKERlZmF1bHRMYW5lcyAmIH53aXBMYW5lcyk7XG5cbiAgICAgICAgaWYgKF9sYW5lMyA9PT0gTm9MYW5lKSB7XG4gICAgICAgICAgLy8gSWYgYWxsIHRoZSBkZWZhdWx0IGxhbmVzIGFyZSBhbHJlYWR5IGJlaW5nIHdvcmtlZCBvbiwgbG9vayBmb3IgYVxuICAgICAgICAgIC8vIGxhbmUgaW4gdGhlIHRyYW5zaXRpb24gcmFuZ2UuXG4gICAgICAgICAgX2xhbmUzID0gcGlja0FyYml0cmFyeUxhbmUoVHJhbnNpdGlvbkxhbmVzICYgfndpcExhbmVzKTtcblxuICAgICAgICAgIGlmIChfbGFuZTMgPT09IE5vTGFuZSkge1xuICAgICAgICAgICAgLy8gQWxsIHRoZSB0cmFuc2l0aW9uIGxhbmVzIGFyZSB0YWtlbiwgdG9vLiBUaGlzIHNob3VsZCBiZSB2ZXJ5XG4gICAgICAgICAgICAvLyByYXJlLCBidXQgYXMgYSBsYXN0IHJlc29ydCwgcGljayBhIGRlZmF1bHQgbGFuZS4gVGhpcyB3aWxsIGhhdmVcbiAgICAgICAgICAgIC8vIHRoZSBlZmZlY3Qgb2YgaW50ZXJydXB0aW5nIHRoZSBjdXJyZW50IHdvcmstaW4tcHJvZ3Jlc3MgcmVuZGVyLlxuICAgICAgICAgICAgX2xhbmUzID0gcGlja0FyYml0cmFyeUxhbmUoRGVmYXVsdExhbmVzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gX2xhbmUzO1xuICAgICAgfVxuXG4gICAgY2FzZSBUcmFuc2l0aW9uUHJpb3JpdHk6IC8vIFNob3VsZCBiZSBoYW5kbGVkIGJ5IGZpbmRUcmFuc2l0aW9uTGFuZSBpbnN0ZWFkXG5cbiAgICBjYXNlIFJldHJ5TGFuZVByaW9yaXR5OlxuICAgICAgLy8gU2hvdWxkIGJlIGhhbmRsZWQgYnkgZmluZFJldHJ5TGFuZSBpbnN0ZWFkXG4gICAgICBicmVhaztcblxuICAgIGNhc2UgSWRsZUxhbmVQcmlvcml0eTpcbiAgICAgIHZhciBsYW5lID0gcGlja0FyYml0cmFyeUxhbmUoSWRsZUxhbmVzICYgfndpcExhbmVzKTtcblxuICAgICAgaWYgKGxhbmUgPT09IE5vTGFuZSkge1xuICAgICAgICBsYW5lID0gcGlja0FyYml0cmFyeUxhbmUoSWRsZUxhbmVzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGxhbmU7XG4gIH1cblxuICB7XG4gICAge1xuICAgICAgdGhyb3cgRXJyb3IoIFwiSW52YWxpZCB1cGRhdGUgcHJpb3JpdHk6IFwiICsgbGFuZVByaW9yaXR5ICsgXCIuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuXCIgKTtcbiAgICB9XG4gIH1cbn0gLy8gVG8gZW5zdXJlIGNvbnNpc3RlbmN5IGFjcm9zcyBtdWx0aXBsZSB1cGRhdGVzIGluIHRoZSBzYW1lIGV2ZW50LCB0aGlzIHNob3VsZFxuLy8gYmUgcHVyZSBmdW5jdGlvbiwgc28gdGhhdCBpdCBhbHdheXMgcmV0dXJucyB0aGUgc2FtZSBsYW5lIGZvciBnaXZlbiBpbnB1dHMuXG5cbmZ1bmN0aW9uIGZpbmRUcmFuc2l0aW9uTGFuZSh3aXBMYW5lcywgcGVuZGluZ0xhbmVzKSB7XG4gIC8vIEZpcnN0IGxvb2sgZm9yIGxhbmVzIHRoYXQgYXJlIGNvbXBsZXRlbHkgdW5jbGFpbWVkLCBpLmUuIGhhdmUgbm9cbiAgLy8gcGVuZGluZyB3b3JrLlxuICB2YXIgbGFuZSA9IHBpY2tBcmJpdHJhcnlMYW5lKFRyYW5zaXRpb25MYW5lcyAmIH5wZW5kaW5nTGFuZXMpO1xuXG4gIGlmIChsYW5lID09PSBOb0xhbmUpIHtcbiAgICAvLyBJZiBhbGwgbGFuZXMgaGF2ZSBwZW5kaW5nIHdvcmssIGxvb2sgZm9yIGEgbGFuZSB0aGF0IGlzbid0IGN1cnJlbnRseVxuICAgIC8vIGJlaW5nIHdvcmtlZCBvbi5cbiAgICBsYW5lID0gcGlja0FyYml0cmFyeUxhbmUoVHJhbnNpdGlvbkxhbmVzICYgfndpcExhbmVzKTtcblxuICAgIGlmIChsYW5lID09PSBOb0xhbmUpIHtcbiAgICAgIC8vIElmIGV2ZXJ5dGhpbmcgaXMgYmVpbmcgd29ya2VkIG9uLCBwaWNrIGFueSBsYW5lLiBUaGlzIGhhcyB0aGVcbiAgICAgIC8vIGVmZmVjdCBvZiBpbnRlcnJ1cHRpbmcgdGhlIGN1cnJlbnQgd29yay1pbi1wcm9ncmVzcy5cbiAgICAgIGxhbmUgPSBwaWNrQXJiaXRyYXJ5TGFuZShUcmFuc2l0aW9uTGFuZXMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBsYW5lO1xufSAvLyBUbyBlbnN1cmUgY29uc2lzdGVuY3kgYWNyb3NzIG11bHRpcGxlIHVwZGF0ZXMgaW4gdGhlIHNhbWUgZXZlbnQsIHRoaXMgc2hvdWxkXG4vLyBiZSBwdXJlIGZ1bmN0aW9uLCBzbyB0aGF0IGl0IGFsd2F5cyByZXR1cm5zIHRoZSBzYW1lIGxhbmUgZm9yIGdpdmVuIGlucHV0cy5cblxuZnVuY3Rpb24gZmluZFJldHJ5TGFuZSh3aXBMYW5lcykge1xuICAvLyBUaGlzIGlzIGEgZm9yayBvZiBgZmluZFVwZGF0ZUxhbmVgIGRlc2lnbmVkIHNwZWNpZmljYWxseSBmb3IgU3VzcGVuc2VcbiAgLy8gXCJyZXRyaWVzXCIg4oCUIGEgc3BlY2lhbCB1cGRhdGUgdGhhdCBhdHRlbXB0cyB0byBmbGlwIGEgU3VzcGVuc2UgYm91bmRhcnlcbiAgLy8gZnJvbSBpdHMgcGxhY2Vob2xkZXIgc3RhdGUgdG8gaXRzIHByaW1hcnkvcmVzb2x2ZWQgc3RhdGUuXG4gIHZhciBsYW5lID0gcGlja0FyYml0cmFyeUxhbmUoUmV0cnlMYW5lcyAmIH53aXBMYW5lcyk7XG5cbiAgaWYgKGxhbmUgPT09IE5vTGFuZSkge1xuICAgIGxhbmUgPSBwaWNrQXJiaXRyYXJ5TGFuZShSZXRyeUxhbmVzKTtcbiAgfVxuXG4gIHJldHVybiBsYW5lO1xufVxuXG5mdW5jdGlvbiBnZXRIaWdoZXN0UHJpb3JpdHlMYW5lKGxhbmVzKSB7XG4gIHJldHVybiBsYW5lcyAmIC1sYW5lcztcbn1cblxuZnVuY3Rpb24gZ2V0TG93ZXN0UHJpb3JpdHlMYW5lKGxhbmVzKSB7XG4gIC8vIFRoaXMgZmluZHMgdGhlIG1vc3Qgc2lnbmlmaWNhbnQgbm9uLXplcm8gYml0LlxuICB2YXIgaW5kZXggPSAzMSAtIGNsejMyKGxhbmVzKTtcbiAgcmV0dXJuIGluZGV4IDwgMCA/IE5vTGFuZXMgOiAxIDw8IGluZGV4O1xufVxuXG5mdW5jdGlvbiBnZXRFcXVhbE9ySGlnaGVyUHJpb3JpdHlMYW5lcyhsYW5lcykge1xuICByZXR1cm4gKGdldExvd2VzdFByaW9yaXR5TGFuZShsYW5lcykgPDwgMSkgLSAxO1xufVxuXG5mdW5jdGlvbiBwaWNrQXJiaXRyYXJ5TGFuZShsYW5lcykge1xuICAvLyBUaGlzIHdyYXBwZXIgZnVuY3Rpb24gZ2V0cyBpbmxpbmVkLiBPbmx5IGV4aXN0cyBzbyB0byBjb21tdW5pY2F0ZSB0aGF0IGl0XG4gIC8vIGRvZXNuJ3QgbWF0dGVyIHdoaWNoIGJpdCBpcyBzZWxlY3RlZDsgeW91IGNhbiBwaWNrIGFueSBiaXQgd2l0aG91dFxuICAvLyBhZmZlY3RpbmcgdGhlIGFsZ29yaXRobXMgd2hlcmUgaXRzIHVzZWQuIEhlcmUgSSdtIHVzaW5nXG4gIC8vIGdldEhpZ2hlc3RQcmlvcml0eUxhbmUgYmVjYXVzZSBpdCByZXF1aXJlcyB0aGUgZmV3ZXN0IG9wZXJhdGlvbnMuXG4gIHJldHVybiBnZXRIaWdoZXN0UHJpb3JpdHlMYW5lKGxhbmVzKTtcbn1cblxuZnVuY3Rpb24gcGlja0FyYml0cmFyeUxhbmVJbmRleChsYW5lcykge1xuICByZXR1cm4gMzEgLSBjbHozMihsYW5lcyk7XG59XG5cbmZ1bmN0aW9uIGxhbmVUb0luZGV4KGxhbmUpIHtcbiAgcmV0dXJuIHBpY2tBcmJpdHJhcnlMYW5lSW5kZXgobGFuZSk7XG59XG5cbmZ1bmN0aW9uIGluY2x1ZGVzU29tZUxhbmUoYSwgYikge1xuICByZXR1cm4gKGEgJiBiKSAhPT0gTm9MYW5lcztcbn1cbmZ1bmN0aW9uIGlzU3Vic2V0T2ZMYW5lcyhzZXQsIHN1YnNldCkge1xuICByZXR1cm4gKHNldCAmIHN1YnNldCkgPT09IHN1YnNldDtcbn1cbmZ1bmN0aW9uIG1lcmdlTGFuZXMoYSwgYikge1xuICByZXR1cm4gYSB8IGI7XG59XG5mdW5jdGlvbiByZW1vdmVMYW5lcyhzZXQsIHN1YnNldCkge1xuICByZXR1cm4gc2V0ICYgfnN1YnNldDtcbn0gLy8gU2VlbXMgcmVkdW5kYW50LCBidXQgaXQgY2hhbmdlcyB0aGUgdHlwZSBmcm9tIGEgc2luZ2xlIGxhbmUgKHVzZWQgZm9yXG4vLyB1cGRhdGVzKSB0byBhIGdyb3VwIG9mIGxhbmVzICh1c2VkIGZvciBmbHVzaGluZyB3b3JrKS5cblxuZnVuY3Rpb24gbGFuZVRvTGFuZXMobGFuZSkge1xuICByZXR1cm4gbGFuZTtcbn1cbmZ1bmN0aW9uIGhpZ2hlclByaW9yaXR5TGFuZShhLCBiKSB7XG4gIC8vIFRoaXMgd29ya3MgYmVjYXVzZSB0aGUgYml0IHJhbmdlcyBkZWNyZWFzZSBpbiBwcmlvcml0eSBhcyB5b3UgZ28gbGVmdC5cbiAgcmV0dXJuIGEgIT09IE5vTGFuZSAmJiBhIDwgYiA/IGEgOiBiO1xufVxuZnVuY3Rpb24gY3JlYXRlTGFuZU1hcChpbml0aWFsKSB7XG4gIC8vIEludGVudGlvbmFsbHkgcHVzaGluZyBvbmUgYnkgb25lLlxuICAvLyBodHRwczovL3Y4LmRldi9ibG9nL2VsZW1lbnRzLWtpbmRzI2F2b2lkLWNyZWF0aW5nLWhvbGVzXG4gIHZhciBsYW5lTWFwID0gW107XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBUb3RhbExhbmVzOyBpKyspIHtcbiAgICBsYW5lTWFwLnB1c2goaW5pdGlhbCk7XG4gIH1cblxuICByZXR1cm4gbGFuZU1hcDtcbn1cbmZ1bmN0aW9uIG1hcmtSb290VXBkYXRlZChyb290LCB1cGRhdGVMYW5lLCBldmVudFRpbWUpIHtcbiAgcm9vdC5wZW5kaW5nTGFuZXMgfD0gdXBkYXRlTGFuZTsgLy8gVE9ETzogVGhlb3JldGljYWxseSwgYW55IHVwZGF0ZSB0byBhbnkgbGFuZSBjYW4gdW5ibG9jayBhbnkgb3RoZXIgbGFuZS4gQnV0XG4gIC8vIGl0J3Mgbm90IHByYWN0aWNhbCB0byB0cnkgZXZlcnkgc2luZ2xlIHBvc3NpYmxlIGNvbWJpbmF0aW9uLiBXZSBuZWVkIGFcbiAgLy8gaGV1cmlzdGljIHRvIGRlY2lkZSB3aGljaCBsYW5lcyB0byBhdHRlbXB0IHRvIHJlbmRlciwgYW5kIGluIHdoaWNoIGJhdGNoZXMuXG4gIC8vIEZvciBub3csIHdlIHVzZSB0aGUgc2FtZSBoZXVyaXN0aWMgYXMgaW4gdGhlIG9sZCBFeHBpcmF0aW9uVGltZXMgbW9kZWw6XG4gIC8vIHJldHJ5IGFueSBsYW5lIGF0IGVxdWFsIG9yIGxvd2VyIHByaW9yaXR5LCBidXQgZG9uJ3QgdHJ5IHVwZGF0ZXMgYXQgaGlnaGVyXG4gIC8vIHByaW9yaXR5IHdpdGhvdXQgYWxzbyBpbmNsdWRpbmcgdGhlIGxvd2VyIHByaW9yaXR5IHVwZGF0ZXMuIFRoaXMgd29ya3Mgd2VsbFxuICAvLyB3aGVuIGNvbnNpZGVyaW5nIHVwZGF0ZXMgYWNyb3NzIGRpZmZlcmVudCBwcmlvcml0eSBsZXZlbHMsIGJ1dCBpc24ndFxuICAvLyBzdWZmaWNpZW50IGZvciB1cGRhdGVzIHdpdGhpbiB0aGUgc2FtZSBwcmlvcml0eSwgc2luY2Ugd2Ugd2FudCB0byB0cmVhdFxuICAvLyB0aG9zZSB1cGRhdGVzIGFzIHBhcmFsbGVsLlxuICAvLyBVbnN1c3BlbmQgYW55IHVwZGF0ZSBhdCBlcXVhbCBvciBsb3dlciBwcmlvcml0eS5cblxuICB2YXIgaGlnaGVyUHJpb3JpdHlMYW5lcyA9IHVwZGF0ZUxhbmUgLSAxOyAvLyBUdXJucyAwYjEwMDAgaW50byAwYjAxMTFcblxuICByb290LnN1c3BlbmRlZExhbmVzICY9IGhpZ2hlclByaW9yaXR5TGFuZXM7XG4gIHJvb3QucGluZ2VkTGFuZXMgJj0gaGlnaGVyUHJpb3JpdHlMYW5lcztcbiAgdmFyIGV2ZW50VGltZXMgPSByb290LmV2ZW50VGltZXM7XG4gIHZhciBpbmRleCA9IGxhbmVUb0luZGV4KHVwZGF0ZUxhbmUpOyAvLyBXZSBjYW4gYWx3YXlzIG92ZXJ3cml0ZSBhbiBleGlzdGluZyB0aW1lc3RhbXAgYmVjYXVzZSB3ZSBwcmVmZXIgdGhlIG1vc3RcbiAgLy8gcmVjZW50IGV2ZW50LCBhbmQgd2UgYXNzdW1lIHRpbWUgaXMgbW9ub3RvbmljYWxseSBpbmNyZWFzaW5nLlxuXG4gIGV2ZW50VGltZXNbaW5kZXhdID0gZXZlbnRUaW1lO1xufVxuZnVuY3Rpb24gbWFya1Jvb3RTdXNwZW5kZWQocm9vdCwgc3VzcGVuZGVkTGFuZXMpIHtcbiAgcm9vdC5zdXNwZW5kZWRMYW5lcyB8PSBzdXNwZW5kZWRMYW5lcztcbiAgcm9vdC5waW5nZWRMYW5lcyAmPSB+c3VzcGVuZGVkTGFuZXM7IC8vIFRoZSBzdXNwZW5kZWQgbGFuZXMgYXJlIG5vIGxvbmdlciBDUFUtYm91bmQuIENsZWFyIHRoZWlyIGV4cGlyYXRpb24gdGltZXMuXG5cbiAgdmFyIGV4cGlyYXRpb25UaW1lcyA9IHJvb3QuZXhwaXJhdGlvblRpbWVzO1xuICB2YXIgbGFuZXMgPSBzdXNwZW5kZWRMYW5lcztcblxuICB3aGlsZSAobGFuZXMgPiAwKSB7XG4gICAgdmFyIGluZGV4ID0gcGlja0FyYml0cmFyeUxhbmVJbmRleChsYW5lcyk7XG4gICAgdmFyIGxhbmUgPSAxIDw8IGluZGV4O1xuICAgIGV4cGlyYXRpb25UaW1lc1tpbmRleF0gPSBOb1RpbWVzdGFtcDtcbiAgICBsYW5lcyAmPSB+bGFuZTtcbiAgfVxufVxuZnVuY3Rpb24gbWFya1Jvb3RQaW5nZWQocm9vdCwgcGluZ2VkTGFuZXMsIGV2ZW50VGltZSkge1xuICByb290LnBpbmdlZExhbmVzIHw9IHJvb3Quc3VzcGVuZGVkTGFuZXMgJiBwaW5nZWRMYW5lcztcbn1cbmZ1bmN0aW9uIG1hcmtEaXNjcmV0ZVVwZGF0ZXNFeHBpcmVkKHJvb3QpIHtcbiAgcm9vdC5leHBpcmVkTGFuZXMgfD0gSW5wdXREaXNjcmV0ZUxhbmVzICYgcm9vdC5wZW5kaW5nTGFuZXM7XG59XG5mdW5jdGlvbiBoYXNEaXNjcmV0ZUxhbmVzKGxhbmVzKSB7XG4gIHJldHVybiAobGFuZXMgJiBJbnB1dERpc2NyZXRlTGFuZXMpICE9PSBOb0xhbmVzO1xufVxuZnVuY3Rpb24gbWFya1Jvb3RNdXRhYmxlUmVhZChyb290LCB1cGRhdGVMYW5lKSB7XG4gIHJvb3QubXV0YWJsZVJlYWRMYW5lcyB8PSB1cGRhdGVMYW5lICYgcm9vdC5wZW5kaW5nTGFuZXM7XG59XG5mdW5jdGlvbiBtYXJrUm9vdEZpbmlzaGVkKHJvb3QsIHJlbWFpbmluZ0xhbmVzKSB7XG4gIHZhciBub0xvbmdlclBlbmRpbmdMYW5lcyA9IHJvb3QucGVuZGluZ0xhbmVzICYgfnJlbWFpbmluZ0xhbmVzO1xuICByb290LnBlbmRpbmdMYW5lcyA9IHJlbWFpbmluZ0xhbmVzOyAvLyBMZXQncyB0cnkgZXZlcnl0aGluZyBhZ2FpblxuXG4gIHJvb3Quc3VzcGVuZGVkTGFuZXMgPSAwO1xuICByb290LnBpbmdlZExhbmVzID0gMDtcbiAgcm9vdC5leHBpcmVkTGFuZXMgJj0gcmVtYWluaW5nTGFuZXM7XG4gIHJvb3QubXV0YWJsZVJlYWRMYW5lcyAmPSByZW1haW5pbmdMYW5lcztcbiAgcm9vdC5lbnRhbmdsZWRMYW5lcyAmPSByZW1haW5pbmdMYW5lcztcbiAgdmFyIGVudGFuZ2xlbWVudHMgPSByb290LmVudGFuZ2xlbWVudHM7XG4gIHZhciBldmVudFRpbWVzID0gcm9vdC5ldmVudFRpbWVzO1xuICB2YXIgZXhwaXJhdGlvblRpbWVzID0gcm9vdC5leHBpcmF0aW9uVGltZXM7IC8vIENsZWFyIHRoZSBsYW5lcyB0aGF0IG5vIGxvbmdlciBoYXZlIHBlbmRpbmcgd29ya1xuXG4gIHZhciBsYW5lcyA9IG5vTG9uZ2VyUGVuZGluZ0xhbmVzO1xuXG4gIHdoaWxlIChsYW5lcyA+IDApIHtcbiAgICB2YXIgaW5kZXggPSBwaWNrQXJiaXRyYXJ5TGFuZUluZGV4KGxhbmVzKTtcbiAgICB2YXIgbGFuZSA9IDEgPDwgaW5kZXg7XG4gICAgZW50YW5nbGVtZW50c1tpbmRleF0gPSBOb0xhbmVzO1xuICAgIGV2ZW50VGltZXNbaW5kZXhdID0gTm9UaW1lc3RhbXA7XG4gICAgZXhwaXJhdGlvblRpbWVzW2luZGV4XSA9IE5vVGltZXN0YW1wO1xuICAgIGxhbmVzICY9IH5sYW5lO1xuICB9XG59XG5mdW5jdGlvbiBtYXJrUm9vdEVudGFuZ2xlZChyb290LCBlbnRhbmdsZWRMYW5lcykge1xuICByb290LmVudGFuZ2xlZExhbmVzIHw9IGVudGFuZ2xlZExhbmVzO1xuICB2YXIgZW50YW5nbGVtZW50cyA9IHJvb3QuZW50YW5nbGVtZW50cztcbiAgdmFyIGxhbmVzID0gZW50YW5nbGVkTGFuZXM7XG5cbiAgd2hpbGUgKGxhbmVzID4gMCkge1xuICAgIHZhciBpbmRleCA9IHBpY2tBcmJpdHJhcnlMYW5lSW5kZXgobGFuZXMpO1xuICAgIHZhciBsYW5lID0gMSA8PCBpbmRleDtcbiAgICBlbnRhbmdsZW1lbnRzW2luZGV4XSB8PSBlbnRhbmdsZWRMYW5lcztcbiAgICBsYW5lcyAmPSB+bGFuZTtcbiAgfVxufVxudmFyIGNsejMyID0gTWF0aC5jbHozMiA/IE1hdGguY2x6MzIgOiBjbHozMkZhbGxiYWNrOyAvLyBDb3VudCBsZWFkaW5nIHplcm9zLiBPbmx5IHVzZWQgb24gbGFuZXMsIHNvIGFzc3VtZSBpbnB1dCBpcyBhbiBpbnRlZ2VyLlxuLy8gQmFzZWQgb246XG4vLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9NYXRoL2NsejMyXG5cbnZhciBsb2cgPSBNYXRoLmxvZztcbnZhciBMTjIgPSBNYXRoLkxOMjtcblxuZnVuY3Rpb24gY2x6MzJGYWxsYmFjayhsYW5lcykge1xuICBpZiAobGFuZXMgPT09IDApIHtcbiAgICByZXR1cm4gMzI7XG4gIH1cblxuICByZXR1cm4gMzEgLSAobG9nKGxhbmVzKSAvIExOMiB8IDApIHwgMDtcbn1cblxuLy8gSW50ZW50aW9uYWxseSBub3QgbmFtZWQgaW1wb3J0cyBiZWNhdXNlIFJvbGx1cCB3b3VsZCB1c2UgZHluYW1pYyBkaXNwYXRjaCBmb3JcbnZhciBVc2VyQmxvY2tpbmdQcmlvcml0eSQxID0gU2NoZWR1bGVyLnVuc3RhYmxlX1VzZXJCbG9ja2luZ1ByaW9yaXR5LFxuICAgIHJ1bldpdGhQcmlvcml0eSA9IFNjaGVkdWxlci51bnN0YWJsZV9ydW5XaXRoUHJpb3JpdHk7IC8vIFRPRE86IGNhbiB3ZSBzdG9wIGV4cG9ydGluZyB0aGVzZT9cblxudmFyIF9lbmFibGVkID0gdHJ1ZTsgLy8gVGhpcyBpcyBleHBvcnRlZCBpbiBGQiBidWlsZHMgZm9yIHVzZSBieSBsZWdhY3kgRkIgbGF5ZXIgaW5mcmEuXG4vLyBXZSdkIGxpa2UgdG8gcmVtb3ZlIHRoaXMgYnV0IGl0J3Mgbm90IGNsZWFyIGlmIHRoaXMgaXMgc2FmZS5cblxuZnVuY3Rpb24gc2V0RW5hYmxlZChlbmFibGVkKSB7XG4gIF9lbmFibGVkID0gISFlbmFibGVkO1xufVxuZnVuY3Rpb24gaXNFbmFibGVkKCkge1xuICByZXR1cm4gX2VuYWJsZWQ7XG59XG5mdW5jdGlvbiBjcmVhdGVFdmVudExpc3RlbmVyV3JhcHBlcldpdGhQcmlvcml0eSh0YXJnZXRDb250YWluZXIsIGRvbUV2ZW50TmFtZSwgZXZlbnRTeXN0ZW1GbGFncykge1xuICB2YXIgZXZlbnRQcmlvcml0eSA9IGdldEV2ZW50UHJpb3JpdHlGb3JQbHVnaW5TeXN0ZW0oZG9tRXZlbnROYW1lKTtcbiAgdmFyIGxpc3RlbmVyV3JhcHBlcjtcblxuICBzd2l0Y2ggKGV2ZW50UHJpb3JpdHkpIHtcbiAgICBjYXNlIERpc2NyZXRlRXZlbnQ6XG4gICAgICBsaXN0ZW5lcldyYXBwZXIgPSBkaXNwYXRjaERpc2NyZXRlRXZlbnQ7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgVXNlckJsb2NraW5nRXZlbnQ6XG4gICAgICBsaXN0ZW5lcldyYXBwZXIgPSBkaXNwYXRjaFVzZXJCbG9ja2luZ1VwZGF0ZTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBDb250aW51b3VzRXZlbnQ6XG4gICAgZGVmYXVsdDpcbiAgICAgIGxpc3RlbmVyV3JhcHBlciA9IGRpc3BhdGNoRXZlbnQ7XG4gICAgICBicmVhaztcbiAgfVxuXG4gIHJldHVybiBsaXN0ZW5lcldyYXBwZXIuYmluZChudWxsLCBkb21FdmVudE5hbWUsIGV2ZW50U3lzdGVtRmxhZ3MsIHRhcmdldENvbnRhaW5lcik7XG59XG5cbmZ1bmN0aW9uIGRpc3BhdGNoRGlzY3JldGVFdmVudChkb21FdmVudE5hbWUsIGV2ZW50U3lzdGVtRmxhZ3MsIGNvbnRhaW5lciwgbmF0aXZlRXZlbnQpIHtcbiAge1xuICAgIGZsdXNoRGlzY3JldGVVcGRhdGVzSWZOZWVkZWQobmF0aXZlRXZlbnQudGltZVN0YW1wKTtcbiAgfVxuXG4gIGRpc2NyZXRlVXBkYXRlcyhkaXNwYXRjaEV2ZW50LCBkb21FdmVudE5hbWUsIGV2ZW50U3lzdGVtRmxhZ3MsIGNvbnRhaW5lciwgbmF0aXZlRXZlbnQpO1xufVxuXG5mdW5jdGlvbiBkaXNwYXRjaFVzZXJCbG9ja2luZ1VwZGF0ZShkb21FdmVudE5hbWUsIGV2ZW50U3lzdGVtRmxhZ3MsIGNvbnRhaW5lciwgbmF0aXZlRXZlbnQpIHtcbiAge1xuICAgIHJ1bldpdGhQcmlvcml0eShVc2VyQmxvY2tpbmdQcmlvcml0eSQxLCBkaXNwYXRjaEV2ZW50LmJpbmQobnVsbCwgZG9tRXZlbnROYW1lLCBldmVudFN5c3RlbUZsYWdzLCBjb250YWluZXIsIG5hdGl2ZUV2ZW50KSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZGlzcGF0Y2hFdmVudChkb21FdmVudE5hbWUsIGV2ZW50U3lzdGVtRmxhZ3MsIHRhcmdldENvbnRhaW5lciwgbmF0aXZlRXZlbnQpIHtcbiAgaWYgKCFfZW5hYmxlZCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBhbGxvd1JlcGxheSA9IHRydWU7XG5cbiAge1xuICAgIC8vIFRPRE86IHJlcGxheWluZyBjYXB0dXJlIHBoYXNlIGV2ZW50cyBpcyBjdXJyZW50bHkgYnJva2VuXG4gICAgLy8gYmVjYXVzZSB3ZSB1c2VkIHRvIGRvIGl0IGR1cmluZyB0b3AtbGV2ZWwgbmF0aXZlIGJ1YmJsZSBoYW5kbGVyc1xuICAgIC8vIGJ1dCBub3cgd2UgdXNlIGRpZmZlcmVudCBidWJibGUgYW5kIGNhcHR1cmUgaGFuZGxlcnMuXG4gICAgLy8gSW4gZWFnZXIgbW9kZSwgd2UgYXR0YWNoIGNhcHR1cmUgbGlzdGVuZXJzIGVhcmx5LCBzbyB3ZSBuZWVkXG4gICAgLy8gdG8gZmlsdGVyIHRoZW0gb3V0IHVudGlsIHdlIGZpeCB0aGUgbG9naWMgdG8gaGFuZGxlIHRoZW0gY29ycmVjdGx5LlxuICAgIC8vIFRoaXMgY291bGQndmUgYmVlbiBvdXRzaWRlIHRoZSBmbGFnIGJ1dCBJIHB1dCBpdCBpbnNpZGUgdG8gcmVkdWNlIHJpc2suXG4gICAgYWxsb3dSZXBsYXkgPSAoZXZlbnRTeXN0ZW1GbGFncyAmIElTX0NBUFRVUkVfUEhBU0UpID09PSAwO1xuICB9XG5cbiAgaWYgKGFsbG93UmVwbGF5ICYmIGhhc1F1ZXVlZERpc2NyZXRlRXZlbnRzKCkgJiYgaXNSZXBsYXlhYmxlRGlzY3JldGVFdmVudChkb21FdmVudE5hbWUpKSB7XG4gICAgLy8gSWYgd2UgYWxyZWFkeSBoYXZlIGEgcXVldWUgb2YgZGlzY3JldGUgZXZlbnRzLCBhbmQgdGhpcyBpcyBhbm90aGVyIGRpc2NyZXRlXG4gICAgLy8gZXZlbnQsIHRoZW4gd2UgY2FuJ3QgZGlzcGF0Y2ggaXQgcmVnYXJkbGVzcyBvZiBpdHMgdGFyZ2V0LCBzaW5jZSB0aGV5XG4gICAgLy8gbmVlZCB0byBkaXNwYXRjaCBpbiBvcmRlci5cbiAgICBxdWV1ZURpc2NyZXRlRXZlbnQobnVsbCwgLy8gRmxhZ3MgdGhhdCB3ZSdyZSBub3QgYWN0dWFsbHkgYmxvY2tlZCBvbiBhbnl0aGluZyBhcyBmYXIgYXMgd2Uga25vdy5cbiAgICBkb21FdmVudE5hbWUsIGV2ZW50U3lzdGVtRmxhZ3MsIHRhcmdldENvbnRhaW5lciwgbmF0aXZlRXZlbnQpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBibG9ja2VkT24gPSBhdHRlbXB0VG9EaXNwYXRjaEV2ZW50KGRvbUV2ZW50TmFtZSwgZXZlbnRTeXN0ZW1GbGFncywgdGFyZ2V0Q29udGFpbmVyLCBuYXRpdmVFdmVudCk7XG5cbiAgaWYgKGJsb2NrZWRPbiA9PT0gbnVsbCkge1xuICAgIC8vIFdlIHN1Y2Nlc3NmdWxseSBkaXNwYXRjaGVkIHRoaXMgZXZlbnQuXG4gICAgaWYgKGFsbG93UmVwbGF5KSB7XG4gICAgICBjbGVhcklmQ29udGludW91c0V2ZW50KGRvbUV2ZW50TmFtZSwgbmF0aXZlRXZlbnQpO1xuICAgIH1cblxuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChhbGxvd1JlcGxheSkge1xuICAgIGlmIChpc1JlcGxheWFibGVEaXNjcmV0ZUV2ZW50KGRvbUV2ZW50TmFtZSkpIHtcbiAgICAgIC8vIFRoaXMgdGhpcyB0byBiZSByZXBsYXllZCBsYXRlciBvbmNlIHRoZSB0YXJnZXQgaXMgYXZhaWxhYmxlLlxuICAgICAgcXVldWVEaXNjcmV0ZUV2ZW50KGJsb2NrZWRPbiwgZG9tRXZlbnROYW1lLCBldmVudFN5c3RlbUZsYWdzLCB0YXJnZXRDb250YWluZXIsIG5hdGl2ZUV2ZW50KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAocXVldWVJZkNvbnRpbnVvdXNFdmVudChibG9ja2VkT24sIGRvbUV2ZW50TmFtZSwgZXZlbnRTeXN0ZW1GbGFncywgdGFyZ2V0Q29udGFpbmVyLCBuYXRpdmVFdmVudCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIFdlIG5lZWQgdG8gY2xlYXIgb25seSBpZiB3ZSBkaWRuJ3QgcXVldWUgYmVjYXVzZVxuICAgIC8vIHF1ZXVlaW5nIGlzIGFjY3VtbXVsYXRpdmUuXG5cblxuICAgIGNsZWFySWZDb250aW51b3VzRXZlbnQoZG9tRXZlbnROYW1lLCBuYXRpdmVFdmVudCk7XG4gIH0gLy8gVGhpcyBpcyBub3QgcmVwbGF5YWJsZSBzbyB3ZSdsbCBpbnZva2UgaXQgYnV0IHdpdGhvdXQgYSB0YXJnZXQsXG4gIC8vIGluIGNhc2UgdGhlIGV2ZW50IHN5c3RlbSBuZWVkcyB0byB0cmFjZSBpdC5cblxuXG4gIGRpc3BhdGNoRXZlbnRGb3JQbHVnaW5FdmVudFN5c3RlbShkb21FdmVudE5hbWUsIGV2ZW50U3lzdGVtRmxhZ3MsIG5hdGl2ZUV2ZW50LCBudWxsLCB0YXJnZXRDb250YWluZXIpO1xufSAvLyBBdHRlbXB0IGRpc3BhdGNoaW5nIGFuIGV2ZW50LiBSZXR1cm5zIGEgU3VzcGVuc2VJbnN0YW5jZSBvciBDb250YWluZXIgaWYgaXQncyBibG9ja2VkLlxuXG5mdW5jdGlvbiBhdHRlbXB0VG9EaXNwYXRjaEV2ZW50KGRvbUV2ZW50TmFtZSwgZXZlbnRTeXN0ZW1GbGFncywgdGFyZ2V0Q29udGFpbmVyLCBuYXRpdmVFdmVudCkge1xuICAvLyBUT0RPOiBXYXJuIGlmIF9lbmFibGVkIGlzIGZhbHNlLlxuICB2YXIgbmF0aXZlRXZlbnRUYXJnZXQgPSBnZXRFdmVudFRhcmdldChuYXRpdmVFdmVudCk7XG4gIHZhciB0YXJnZXRJbnN0ID0gZ2V0Q2xvc2VzdEluc3RhbmNlRnJvbU5vZGUobmF0aXZlRXZlbnRUYXJnZXQpO1xuXG4gIGlmICh0YXJnZXRJbnN0ICE9PSBudWxsKSB7XG4gICAgdmFyIG5lYXJlc3RNb3VudGVkID0gZ2V0TmVhcmVzdE1vdW50ZWRGaWJlcih0YXJnZXRJbnN0KTtcblxuICAgIGlmIChuZWFyZXN0TW91bnRlZCA9PT0gbnVsbCkge1xuICAgICAgLy8gVGhpcyB0cmVlIGhhcyBiZWVuIHVubW91bnRlZCBhbHJlYWR5LiBEaXNwYXRjaCB3aXRob3V0IGEgdGFyZ2V0LlxuICAgICAgdGFyZ2V0SW5zdCA9IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciB0YWcgPSBuZWFyZXN0TW91bnRlZC50YWc7XG5cbiAgICAgIGlmICh0YWcgPT09IFN1c3BlbnNlQ29tcG9uZW50KSB7XG4gICAgICAgIHZhciBpbnN0YW5jZSA9IGdldFN1c3BlbnNlSW5zdGFuY2VGcm9tRmliZXIobmVhcmVzdE1vdW50ZWQpO1xuXG4gICAgICAgIGlmIChpbnN0YW5jZSAhPT0gbnVsbCkge1xuICAgICAgICAgIC8vIFF1ZXVlIHRoZSBldmVudCB0byBiZSByZXBsYXllZCBsYXRlci4gQWJvcnQgZGlzcGF0Y2hpbmcgc2luY2Ugd2VcbiAgICAgICAgICAvLyBkb24ndCB3YW50IHRoaXMgZXZlbnQgZGlzcGF0Y2hlZCB0d2ljZSB0aHJvdWdoIHRoZSBldmVudCBzeXN0ZW0uXG4gICAgICAgICAgLy8gVE9ETzogSWYgdGhpcyBpcyB0aGUgZmlyc3QgZGlzY3JldGUgZXZlbnQgaW4gdGhlIHF1ZXVlLiBTY2hlZHVsZSBhbiBpbmNyZWFzZWRcbiAgICAgICAgICAvLyBwcmlvcml0eSBmb3IgdGhpcyBib3VuZGFyeS5cbiAgICAgICAgICByZXR1cm4gaW5zdGFuY2U7XG4gICAgICAgIH0gLy8gVGhpcyBzaG91bGRuJ3QgaGFwcGVuLCBzb21ldGhpbmcgd2VudCB3cm9uZyBidXQgdG8gYXZvaWQgYmxvY2tpbmdcbiAgICAgICAgLy8gdGhlIHdob2xlIHN5c3RlbSwgZGlzcGF0Y2ggdGhlIGV2ZW50IHdpdGhvdXQgYSB0YXJnZXQuXG4gICAgICAgIC8vIFRPRE86IFdhcm4uXG5cblxuICAgICAgICB0YXJnZXRJbnN0ID0gbnVsbDtcbiAgICAgIH0gZWxzZSBpZiAodGFnID09PSBIb3N0Um9vdCkge1xuICAgICAgICB2YXIgcm9vdCA9IG5lYXJlc3RNb3VudGVkLnN0YXRlTm9kZTtcblxuICAgICAgICBpZiAocm9vdC5oeWRyYXRlKSB7XG4gICAgICAgICAgLy8gSWYgdGhpcyBoYXBwZW5zIGR1cmluZyBhIHJlcGxheSBzb21ldGhpbmcgd2VudCB3cm9uZyBhbmQgaXQgbWlnaHQgYmxvY2tcbiAgICAgICAgICAvLyB0aGUgd2hvbGUgc3lzdGVtLlxuICAgICAgICAgIHJldHVybiBnZXRDb250YWluZXJGcm9tRmliZXIobmVhcmVzdE1vdW50ZWQpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGFyZ2V0SW5zdCA9IG51bGw7XG4gICAgICB9IGVsc2UgaWYgKG5lYXJlc3RNb3VudGVkICE9PSB0YXJnZXRJbnN0KSB7XG4gICAgICAgIC8vIElmIHdlIGdldCBhbiBldmVudCAoZXg6IGltZyBvbmxvYWQpIGJlZm9yZSBjb21taXR0aW5nIHRoYXRcbiAgICAgICAgLy8gY29tcG9uZW50J3MgbW91bnQsIGlnbm9yZSBpdCBmb3Igbm93ICh0aGF0IGlzLCB0cmVhdCBpdCBhcyBpZiBpdCB3YXMgYW5cbiAgICAgICAgLy8gZXZlbnQgb24gYSBub24tUmVhY3QgdHJlZSkuIFdlIG1pZ2h0IGFsc28gY29uc2lkZXIgcXVldWVpbmcgZXZlbnRzIGFuZFxuICAgICAgICAvLyBkaXNwYXRjaGluZyB0aGVtIGFmdGVyIHRoZSBtb3VudC5cbiAgICAgICAgdGFyZ2V0SW5zdCA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZGlzcGF0Y2hFdmVudEZvclBsdWdpbkV2ZW50U3lzdGVtKGRvbUV2ZW50TmFtZSwgZXZlbnRTeXN0ZW1GbGFncywgbmF0aXZlRXZlbnQsIHRhcmdldEluc3QsIHRhcmdldENvbnRhaW5lcik7IC8vIFdlJ3JlIG5vdCBibG9ja2VkIG9uIGFueXRoaW5nLlxuXG4gIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBhZGRFdmVudEJ1YmJsZUxpc3RlbmVyKHRhcmdldCwgZXZlbnRUeXBlLCBsaXN0ZW5lcikge1xuICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcihldmVudFR5cGUsIGxpc3RlbmVyLCBmYWxzZSk7XG4gIHJldHVybiBsaXN0ZW5lcjtcbn1cbmZ1bmN0aW9uIGFkZEV2ZW50Q2FwdHVyZUxpc3RlbmVyKHRhcmdldCwgZXZlbnRUeXBlLCBsaXN0ZW5lcikge1xuICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcihldmVudFR5cGUsIGxpc3RlbmVyLCB0cnVlKTtcbiAgcmV0dXJuIGxpc3RlbmVyO1xufVxuZnVuY3Rpb24gYWRkRXZlbnRDYXB0dXJlTGlzdGVuZXJXaXRoUGFzc2l2ZUZsYWcodGFyZ2V0LCBldmVudFR5cGUsIGxpc3RlbmVyLCBwYXNzaXZlKSB7XG4gIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKGV2ZW50VHlwZSwgbGlzdGVuZXIsIHtcbiAgICBjYXB0dXJlOiB0cnVlLFxuICAgIHBhc3NpdmU6IHBhc3NpdmVcbiAgfSk7XG4gIHJldHVybiBsaXN0ZW5lcjtcbn1cbmZ1bmN0aW9uIGFkZEV2ZW50QnViYmxlTGlzdGVuZXJXaXRoUGFzc2l2ZUZsYWcodGFyZ2V0LCBldmVudFR5cGUsIGxpc3RlbmVyLCBwYXNzaXZlKSB7XG4gIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKGV2ZW50VHlwZSwgbGlzdGVuZXIsIHtcbiAgICBwYXNzaXZlOiBwYXNzaXZlXG4gIH0pO1xuICByZXR1cm4gbGlzdGVuZXI7XG59XG5cbi8qKlxuICogVGhlc2UgdmFyaWFibGVzIHN0b3JlIGluZm9ybWF0aW9uIGFib3V0IHRleHQgY29udGVudCBvZiBhIHRhcmdldCBub2RlLFxuICogYWxsb3dpbmcgY29tcGFyaXNvbiBvZiBjb250ZW50IGJlZm9yZSBhbmQgYWZ0ZXIgYSBnaXZlbiBldmVudC5cbiAqXG4gKiBJZGVudGlmeSB0aGUgbm9kZSB3aGVyZSBzZWxlY3Rpb24gY3VycmVudGx5IGJlZ2lucywgdGhlbiBvYnNlcnZlXG4gKiBib3RoIGl0cyB0ZXh0IGNvbnRlbnQgYW5kIGl0cyBjdXJyZW50IHBvc2l0aW9uIGluIHRoZSBET00uIFNpbmNlIHRoZVxuICogYnJvd3NlciBtYXkgbmF0aXZlbHkgcmVwbGFjZSB0aGUgdGFyZ2V0IG5vZGUgZHVyaW5nIGNvbXBvc2l0aW9uLCB3ZSBjYW5cbiAqIHVzZSBpdHMgcG9zaXRpb24gdG8gZmluZCBpdHMgcmVwbGFjZW1lbnQuXG4gKlxuICpcbiAqL1xudmFyIHJvb3QgPSBudWxsO1xudmFyIHN0YXJ0VGV4dCA9IG51bGw7XG52YXIgZmFsbGJhY2tUZXh0ID0gbnVsbDtcbmZ1bmN0aW9uIGluaXRpYWxpemUobmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgcm9vdCA9IG5hdGl2ZUV2ZW50VGFyZ2V0O1xuICBzdGFydFRleHQgPSBnZXRUZXh0KCk7XG4gIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gcmVzZXQoKSB7XG4gIHJvb3QgPSBudWxsO1xuICBzdGFydFRleHQgPSBudWxsO1xuICBmYWxsYmFja1RleHQgPSBudWxsO1xufVxuZnVuY3Rpb24gZ2V0RGF0YSgpIHtcbiAgaWYgKGZhbGxiYWNrVGV4dCkge1xuICAgIHJldHVybiBmYWxsYmFja1RleHQ7XG4gIH1cblxuICB2YXIgc3RhcnQ7XG4gIHZhciBzdGFydFZhbHVlID0gc3RhcnRUZXh0O1xuICB2YXIgc3RhcnRMZW5ndGggPSBzdGFydFZhbHVlLmxlbmd0aDtcbiAgdmFyIGVuZDtcbiAgdmFyIGVuZFZhbHVlID0gZ2V0VGV4dCgpO1xuICB2YXIgZW5kTGVuZ3RoID0gZW5kVmFsdWUubGVuZ3RoO1xuXG4gIGZvciAoc3RhcnQgPSAwOyBzdGFydCA8IHN0YXJ0TGVuZ3RoOyBzdGFydCsrKSB7XG4gICAgaWYgKHN0YXJ0VmFsdWVbc3RhcnRdICE9PSBlbmRWYWx1ZVtzdGFydF0pIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHZhciBtaW5FbmQgPSBzdGFydExlbmd0aCAtIHN0YXJ0O1xuXG4gIGZvciAoZW5kID0gMTsgZW5kIDw9IG1pbkVuZDsgZW5kKyspIHtcbiAgICBpZiAoc3RhcnRWYWx1ZVtzdGFydExlbmd0aCAtIGVuZF0gIT09IGVuZFZhbHVlW2VuZExlbmd0aCAtIGVuZF0pIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHZhciBzbGljZVRhaWwgPSBlbmQgPiAxID8gMSAtIGVuZCA6IHVuZGVmaW5lZDtcbiAgZmFsbGJhY2tUZXh0ID0gZW5kVmFsdWUuc2xpY2Uoc3RhcnQsIHNsaWNlVGFpbCk7XG4gIHJldHVybiBmYWxsYmFja1RleHQ7XG59XG5mdW5jdGlvbiBnZXRUZXh0KCkge1xuICBpZiAoJ3ZhbHVlJyBpbiByb290KSB7XG4gICAgcmV0dXJuIHJvb3QudmFsdWU7XG4gIH1cblxuICByZXR1cm4gcm9vdC50ZXh0Q29udGVudDtcbn1cblxuLyoqXG4gKiBgY2hhckNvZGVgIHJlcHJlc2VudHMgdGhlIGFjdHVhbCBcImNoYXJhY3RlciBjb2RlXCIgYW5kIGlzIHNhZmUgdG8gdXNlIHdpdGhcbiAqIGBTdHJpbmcuZnJvbUNoYXJDb2RlYC4gQXMgc3VjaCwgb25seSBrZXlzIHRoYXQgY29ycmVzcG9uZCB0byBwcmludGFibGVcbiAqIGNoYXJhY3RlcnMgcHJvZHVjZSBhIHZhbGlkIGBjaGFyQ29kZWAsIHRoZSBvbmx5IGV4Y2VwdGlvbiB0byB0aGlzIGlzIEVudGVyLlxuICogVGhlIFRhYi1rZXkgaXMgY29uc2lkZXJlZCBub24tcHJpbnRhYmxlIGFuZCBkb2VzIG5vdCBoYXZlIGEgYGNoYXJDb2RlYCxcbiAqIHByZXN1bWFibHkgYmVjYXVzZSBpdCBkb2VzIG5vdCBwcm9kdWNlIGEgdGFiLWNoYXJhY3RlciBpbiBicm93c2Vycy5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IE5vcm1hbGl6ZWQgYGNoYXJDb2RlYCBwcm9wZXJ0eS5cbiAqL1xuZnVuY3Rpb24gZ2V0RXZlbnRDaGFyQ29kZShuYXRpdmVFdmVudCkge1xuICB2YXIgY2hhckNvZGU7XG4gIHZhciBrZXlDb2RlID0gbmF0aXZlRXZlbnQua2V5Q29kZTtcblxuICBpZiAoJ2NoYXJDb2RlJyBpbiBuYXRpdmVFdmVudCkge1xuICAgIGNoYXJDb2RlID0gbmF0aXZlRXZlbnQuY2hhckNvZGU7IC8vIEZGIGRvZXMgbm90IHNldCBgY2hhckNvZGVgIGZvciB0aGUgRW50ZXIta2V5LCBjaGVjayBhZ2FpbnN0IGBrZXlDb2RlYC5cblxuICAgIGlmIChjaGFyQ29kZSA9PT0gMCAmJiBrZXlDb2RlID09PSAxMykge1xuICAgICAgY2hhckNvZGUgPSAxMztcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gSUU4IGRvZXMgbm90IGltcGxlbWVudCBgY2hhckNvZGVgLCBidXQgYGtleUNvZGVgIGhhcyB0aGUgY29ycmVjdCB2YWx1ZS5cbiAgICBjaGFyQ29kZSA9IGtleUNvZGU7XG4gIH0gLy8gSUUgYW5kIEVkZ2UgKG9uIFdpbmRvd3MpIGFuZCBDaHJvbWUgLyBTYWZhcmkgKG9uIFdpbmRvd3MgYW5kIExpbnV4KVxuICAvLyByZXBvcnQgRW50ZXIgYXMgY2hhckNvZGUgMTAgd2hlbiBjdHJsIGlzIHByZXNzZWQuXG5cblxuICBpZiAoY2hhckNvZGUgPT09IDEwKSB7XG4gICAgY2hhckNvZGUgPSAxMztcbiAgfSAvLyBTb21lIG5vbi1wcmludGFibGUga2V5cyBhcmUgcmVwb3J0ZWQgaW4gYGNoYXJDb2RlYC9ga2V5Q29kZWAsIGRpc2NhcmQgdGhlbS5cbiAgLy8gTXVzdCBub3QgZGlzY2FyZCB0aGUgKG5vbi0pcHJpbnRhYmxlIEVudGVyLWtleS5cblxuXG4gIGlmIChjaGFyQ29kZSA+PSAzMiB8fCBjaGFyQ29kZSA9PT0gMTMpIHtcbiAgICByZXR1cm4gY2hhckNvZGU7XG4gIH1cblxuICByZXR1cm4gMDtcbn1cblxuZnVuY3Rpb24gZnVuY3Rpb25UaGF0UmV0dXJuc1RydWUoKSB7XG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBmdW5jdGlvblRoYXRSZXR1cm5zRmFsc2UoKSB7XG4gIHJldHVybiBmYWxzZTtcbn0gLy8gVGhpcyBpcyBpbnRlbnRpb25hbGx5IGEgZmFjdG9yeSBzbyB0aGF0IHdlIGhhdmUgZGlmZmVyZW50IHJldHVybmVkIGNvbnN0cnVjdG9ycy5cbi8vIElmIHdlIGhhZCBhIHNpbmdsZSBjb25zdHJ1Y3RvciwgaXQgd291bGQgYmUgbWVnYW1vcnBoaWMgYW5kIGVuZ2luZXMgd291bGQgZGVvcHQuXG5cblxuZnVuY3Rpb24gY3JlYXRlU3ludGhldGljRXZlbnQoSW50ZXJmYWNlKSB7XG4gIC8qKlxuICAgKiBTeW50aGV0aWMgZXZlbnRzIGFyZSBkaXNwYXRjaGVkIGJ5IGV2ZW50IHBsdWdpbnMsIHR5cGljYWxseSBpbiByZXNwb25zZSB0byBhXG4gICAqIHRvcC1sZXZlbCBldmVudCBkZWxlZ2F0aW9uIGhhbmRsZXIuXG4gICAqXG4gICAqIFRoZXNlIHN5c3RlbXMgc2hvdWxkIGdlbmVyYWxseSB1c2UgcG9vbGluZyB0byByZWR1Y2UgdGhlIGZyZXF1ZW5jeSBvZiBnYXJiYWdlXG4gICAqIGNvbGxlY3Rpb24uIFRoZSBzeXN0ZW0gc2hvdWxkIGNoZWNrIGBpc1BlcnNpc3RlbnRgIHRvIGRldGVybWluZSB3aGV0aGVyIHRoZVxuICAgKiBldmVudCBzaG91bGQgYmUgcmVsZWFzZWQgaW50byB0aGUgcG9vbCBhZnRlciBiZWluZyBkaXNwYXRjaGVkLiBVc2VycyB0aGF0XG4gICAqIG5lZWQgYSBwZXJzaXN0ZWQgZXZlbnQgc2hvdWxkIGludm9rZSBgcGVyc2lzdGAuXG4gICAqXG4gICAqIFN5bnRoZXRpYyBldmVudHMgKGFuZCBzdWJjbGFzc2VzKSBpbXBsZW1lbnQgdGhlIERPTSBMZXZlbCAzIEV2ZW50cyBBUEkgYnlcbiAgICogbm9ybWFsaXppbmcgYnJvd3NlciBxdWlya3MuIFN1YmNsYXNzZXMgZG8gbm90IG5lY2Vzc2FyaWx5IGhhdmUgdG8gaW1wbGVtZW50IGFcbiAgICogRE9NIGludGVyZmFjZTsgY3VzdG9tIGFwcGxpY2F0aW9uLXNwZWNpZmljIGV2ZW50cyBjYW4gYWxzbyBzdWJjbGFzcyB0aGlzLlxuICAgKi9cbiAgZnVuY3Rpb24gU3ludGhldGljQmFzZUV2ZW50KHJlYWN0TmFtZSwgcmVhY3RFdmVudFR5cGUsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICAgIHRoaXMuX3JlYWN0TmFtZSA9IHJlYWN0TmFtZTtcbiAgICB0aGlzLl90YXJnZXRJbnN0ID0gdGFyZ2V0SW5zdDtcbiAgICB0aGlzLnR5cGUgPSByZWFjdEV2ZW50VHlwZTtcbiAgICB0aGlzLm5hdGl2ZUV2ZW50ID0gbmF0aXZlRXZlbnQ7XG4gICAgdGhpcy50YXJnZXQgPSBuYXRpdmVFdmVudFRhcmdldDtcbiAgICB0aGlzLmN1cnJlbnRUYXJnZXQgPSBudWxsO1xuXG4gICAgZm9yICh2YXIgX3Byb3BOYW1lIGluIEludGVyZmFjZSkge1xuICAgICAgaWYgKCFJbnRlcmZhY2UuaGFzT3duUHJvcGVydHkoX3Byb3BOYW1lKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIG5vcm1hbGl6ZSA9IEludGVyZmFjZVtfcHJvcE5hbWVdO1xuXG4gICAgICBpZiAobm9ybWFsaXplKSB7XG4gICAgICAgIHRoaXNbX3Byb3BOYW1lXSA9IG5vcm1hbGl6ZShuYXRpdmVFdmVudCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzW19wcm9wTmFtZV0gPSBuYXRpdmVFdmVudFtfcHJvcE5hbWVdO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBkZWZhdWx0UHJldmVudGVkID0gbmF0aXZlRXZlbnQuZGVmYXVsdFByZXZlbnRlZCAhPSBudWxsID8gbmF0aXZlRXZlbnQuZGVmYXVsdFByZXZlbnRlZCA6IG5hdGl2ZUV2ZW50LnJldHVyblZhbHVlID09PSBmYWxzZTtcblxuICAgIGlmIChkZWZhdWx0UHJldmVudGVkKSB7XG4gICAgICB0aGlzLmlzRGVmYXVsdFByZXZlbnRlZCA9IGZ1bmN0aW9uVGhhdFJldHVybnNUcnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmlzRGVmYXVsdFByZXZlbnRlZCA9IGZ1bmN0aW9uVGhhdFJldHVybnNGYWxzZTtcbiAgICB9XG5cbiAgICB0aGlzLmlzUHJvcGFnYXRpb25TdG9wcGVkID0gZnVuY3Rpb25UaGF0UmV0dXJuc0ZhbHNlO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgX2Fzc2lnbihTeW50aGV0aWNCYXNlRXZlbnQucHJvdG90eXBlLCB7XG4gICAgcHJldmVudERlZmF1bHQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMuZGVmYXVsdFByZXZlbnRlZCA9IHRydWU7XG4gICAgICB2YXIgZXZlbnQgPSB0aGlzLm5hdGl2ZUV2ZW50O1xuXG4gICAgICBpZiAoIWV2ZW50KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKGV2ZW50LnByZXZlbnREZWZhdWx0KSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7IC8vICRGbG93Rml4TWUgLSBmbG93IGlzIG5vdCBhd2FyZSBvZiBgdW5rbm93bmAgaW4gSUVcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGV2ZW50LnJldHVyblZhbHVlICE9PSAndW5rbm93bicpIHtcbiAgICAgICAgZXZlbnQucmV0dXJuVmFsdWUgPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5pc0RlZmF1bHRQcmV2ZW50ZWQgPSBmdW5jdGlvblRoYXRSZXR1cm5zVHJ1ZTtcbiAgICB9LFxuICAgIHN0b3BQcm9wYWdhdGlvbjogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGV2ZW50ID0gdGhpcy5uYXRpdmVFdmVudDtcblxuICAgICAgaWYgKCFldmVudCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChldmVudC5zdG9wUHJvcGFnYXRpb24pIHtcbiAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7IC8vICRGbG93Rml4TWUgLSBmbG93IGlzIG5vdCBhd2FyZSBvZiBgdW5rbm93bmAgaW4gSUVcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGV2ZW50LmNhbmNlbEJ1YmJsZSAhPT0gJ3Vua25vd24nKSB7XG4gICAgICAgIC8vIFRoZSBDaGFuZ2VFdmVudFBsdWdpbiByZWdpc3RlcnMgYSBcInByb3BlcnR5Y2hhbmdlXCIgZXZlbnQgZm9yXG4gICAgICAgIC8vIElFLiBUaGlzIGV2ZW50IGRvZXMgbm90IHN1cHBvcnQgYnViYmxpbmcgb3IgY2FuY2VsbGluZywgYW5kXG4gICAgICAgIC8vIGFueSByZWZlcmVuY2VzIHRvIGNhbmNlbEJ1YmJsZSB0aHJvdyBcIk1lbWJlciBub3QgZm91bmRcIi4gIEFcbiAgICAgICAgLy8gdHlwZW9mIGNoZWNrIG9mIFwidW5rbm93blwiIGNpcmN1bXZlbnRzIHRoaXMgaXNzdWUgKGFuZCBpcyBhbHNvXG4gICAgICAgIC8vIElFIHNwZWNpZmljKS5cbiAgICAgICAgZXZlbnQuY2FuY2VsQnViYmxlID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5pc1Byb3BhZ2F0aW9uU3RvcHBlZCA9IGZ1bmN0aW9uVGhhdFJldHVybnNUcnVlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBXZSByZWxlYXNlIGFsbCBkaXNwYXRjaGVkIGBTeW50aGV0aWNFdmVudGBzIGFmdGVyIGVhY2ggZXZlbnQgbG9vcCwgYWRkaW5nXG4gICAgICogdGhlbSBiYWNrIGludG8gdGhlIHBvb2wuIFRoaXMgYWxsb3dzIGEgd2F5IHRvIGhvbGQgb250byBhIHJlZmVyZW5jZSB0aGF0XG4gICAgICogd29uJ3QgYmUgYWRkZWQgYmFjayBpbnRvIHRoZSBwb29sLlxuICAgICAqL1xuICAgIHBlcnNpc3Q6IGZ1bmN0aW9uICgpIHsvLyBNb2Rlcm4gZXZlbnQgc3lzdGVtIGRvZXNuJ3QgdXNlIHBvb2xpbmcuXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiB0aGlzIGV2ZW50IHNob3VsZCBiZSByZWxlYXNlZCBiYWNrIGludG8gdGhlIHBvb2wuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoaXMgc2hvdWxkIG5vdCBiZSByZWxlYXNlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIGlzUGVyc2lzdGVudDogZnVuY3Rpb25UaGF0UmV0dXJuc1RydWVcbiAgfSk7XG5cbiAgcmV0dXJuIFN5bnRoZXRpY0Jhc2VFdmVudDtcbn1cbi8qKlxuICogQGludGVyZmFjZSBFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvXG4gKi9cblxuXG52YXIgRXZlbnRJbnRlcmZhY2UgPSB7XG4gIGV2ZW50UGhhc2U6IDAsXG4gIGJ1YmJsZXM6IDAsXG4gIGNhbmNlbGFibGU6IDAsXG4gIHRpbWVTdGFtcDogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgcmV0dXJuIGV2ZW50LnRpbWVTdGFtcCB8fCBEYXRlLm5vdygpO1xuICB9LFxuICBkZWZhdWx0UHJldmVudGVkOiAwLFxuICBpc1RydXN0ZWQ6IDBcbn07XG52YXIgU3ludGhldGljRXZlbnQgPSBjcmVhdGVTeW50aGV0aWNFdmVudChFdmVudEludGVyZmFjZSk7XG5cbnZhciBVSUV2ZW50SW50ZXJmYWNlID0gX2Fzc2lnbih7fSwgRXZlbnRJbnRlcmZhY2UsIHtcbiAgdmlldzogMCxcbiAgZGV0YWlsOiAwXG59KTtcblxudmFyIFN5bnRoZXRpY1VJRXZlbnQgPSBjcmVhdGVTeW50aGV0aWNFdmVudChVSUV2ZW50SW50ZXJmYWNlKTtcbnZhciBsYXN0TW92ZW1lbnRYO1xudmFyIGxhc3RNb3ZlbWVudFk7XG52YXIgbGFzdE1vdXNlRXZlbnQ7XG5cbmZ1bmN0aW9uIHVwZGF0ZU1vdXNlTW92ZW1lbnRQb2x5ZmlsbFN0YXRlKGV2ZW50KSB7XG4gIGlmIChldmVudCAhPT0gbGFzdE1vdXNlRXZlbnQpIHtcbiAgICBpZiAobGFzdE1vdXNlRXZlbnQgJiYgZXZlbnQudHlwZSA9PT0gJ21vdXNlbW92ZScpIHtcbiAgICAgIGxhc3RNb3ZlbWVudFggPSBldmVudC5zY3JlZW5YIC0gbGFzdE1vdXNlRXZlbnQuc2NyZWVuWDtcbiAgICAgIGxhc3RNb3ZlbWVudFkgPSBldmVudC5zY3JlZW5ZIC0gbGFzdE1vdXNlRXZlbnQuc2NyZWVuWTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGFzdE1vdmVtZW50WCA9IDA7XG4gICAgICBsYXN0TW92ZW1lbnRZID0gMDtcbiAgICB9XG5cbiAgICBsYXN0TW91c2VFdmVudCA9IGV2ZW50O1xuICB9XG59XG4vKipcbiAqIEBpbnRlcmZhY2UgTW91c2VFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvXG4gKi9cblxuXG52YXIgTW91c2VFdmVudEludGVyZmFjZSA9IF9hc3NpZ24oe30sIFVJRXZlbnRJbnRlcmZhY2UsIHtcbiAgc2NyZWVuWDogMCxcbiAgc2NyZWVuWTogMCxcbiAgY2xpZW50WDogMCxcbiAgY2xpZW50WTogMCxcbiAgcGFnZVg6IDAsXG4gIHBhZ2VZOiAwLFxuICBjdHJsS2V5OiAwLFxuICBzaGlmdEtleTogMCxcbiAgYWx0S2V5OiAwLFxuICBtZXRhS2V5OiAwLFxuICBnZXRNb2RpZmllclN0YXRlOiBnZXRFdmVudE1vZGlmaWVyU3RhdGUsXG4gIGJ1dHRvbjogMCxcbiAgYnV0dG9uczogMCxcbiAgcmVsYXRlZFRhcmdldDogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgaWYgKGV2ZW50LnJlbGF0ZWRUYXJnZXQgPT09IHVuZGVmaW5lZCkgcmV0dXJuIGV2ZW50LmZyb21FbGVtZW50ID09PSBldmVudC5zcmNFbGVtZW50ID8gZXZlbnQudG9FbGVtZW50IDogZXZlbnQuZnJvbUVsZW1lbnQ7XG4gICAgcmV0dXJuIGV2ZW50LnJlbGF0ZWRUYXJnZXQ7XG4gIH0sXG4gIG1vdmVtZW50WDogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgaWYgKCdtb3ZlbWVudFgnIGluIGV2ZW50KSB7XG4gICAgICByZXR1cm4gZXZlbnQubW92ZW1lbnRYO1xuICAgIH1cblxuICAgIHVwZGF0ZU1vdXNlTW92ZW1lbnRQb2x5ZmlsbFN0YXRlKGV2ZW50KTtcbiAgICByZXR1cm4gbGFzdE1vdmVtZW50WDtcbiAgfSxcbiAgbW92ZW1lbnRZOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICBpZiAoJ21vdmVtZW50WScgaW4gZXZlbnQpIHtcbiAgICAgIHJldHVybiBldmVudC5tb3ZlbWVudFk7XG4gICAgfSAvLyBEb24ndCBuZWVkIHRvIGNhbGwgdXBkYXRlTW91c2VNb3ZlbWVudFBvbHlmaWxsU3RhdGUoKSBoZXJlXG4gICAgLy8gYmVjYXVzZSBpdCdzIGd1YXJhbnRlZWQgdG8gaGF2ZSBhbHJlYWR5IHJ1biB3aGVuIG1vdmVtZW50WFxuICAgIC8vIHdhcyBjb3BpZWQuXG5cblxuICAgIHJldHVybiBsYXN0TW92ZW1lbnRZO1xuICB9XG59KTtcblxudmFyIFN5bnRoZXRpY01vdXNlRXZlbnQgPSBjcmVhdGVTeW50aGV0aWNFdmVudChNb3VzZUV2ZW50SW50ZXJmYWNlKTtcbi8qKlxuICogQGludGVyZmFjZSBEcmFnRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzL1xuICovXG5cbnZhciBEcmFnRXZlbnRJbnRlcmZhY2UgPSBfYXNzaWduKHt9LCBNb3VzZUV2ZW50SW50ZXJmYWNlLCB7XG4gIGRhdGFUcmFuc2ZlcjogMFxufSk7XG5cbnZhciBTeW50aGV0aWNEcmFnRXZlbnQgPSBjcmVhdGVTeW50aGV0aWNFdmVudChEcmFnRXZlbnRJbnRlcmZhY2UpO1xuLyoqXG4gKiBAaW50ZXJmYWNlIEZvY3VzRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzL1xuICovXG5cbnZhciBGb2N1c0V2ZW50SW50ZXJmYWNlID0gX2Fzc2lnbih7fSwgVUlFdmVudEludGVyZmFjZSwge1xuICByZWxhdGVkVGFyZ2V0OiAwXG59KTtcblxudmFyIFN5bnRoZXRpY0ZvY3VzRXZlbnQgPSBjcmVhdGVTeW50aGV0aWNFdmVudChGb2N1c0V2ZW50SW50ZXJmYWNlKTtcbi8qKlxuICogQGludGVyZmFjZSBFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9jc3MzLWFuaW1hdGlvbnMvI0FuaW1hdGlvbkV2ZW50LWludGVyZmFjZVxuICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvQW5pbWF0aW9uRXZlbnRcbiAqL1xuXG52YXIgQW5pbWF0aW9uRXZlbnRJbnRlcmZhY2UgPSBfYXNzaWduKHt9LCBFdmVudEludGVyZmFjZSwge1xuICBhbmltYXRpb25OYW1lOiAwLFxuICBlbGFwc2VkVGltZTogMCxcbiAgcHNldWRvRWxlbWVudDogMFxufSk7XG5cbnZhciBTeW50aGV0aWNBbmltYXRpb25FdmVudCA9IGNyZWF0ZVN5bnRoZXRpY0V2ZW50KEFuaW1hdGlvbkV2ZW50SW50ZXJmYWNlKTtcbi8qKlxuICogQGludGVyZmFjZSBFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9jbGlwYm9hcmQtYXBpcy9cbiAqL1xuXG52YXIgQ2xpcGJvYXJkRXZlbnRJbnRlcmZhY2UgPSBfYXNzaWduKHt9LCBFdmVudEludGVyZmFjZSwge1xuICBjbGlwYm9hcmREYXRhOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICByZXR1cm4gJ2NsaXBib2FyZERhdGEnIGluIGV2ZW50ID8gZXZlbnQuY2xpcGJvYXJkRGF0YSA6IHdpbmRvdy5jbGlwYm9hcmREYXRhO1xuICB9XG59KTtcblxudmFyIFN5bnRoZXRpY0NsaXBib2FyZEV2ZW50ID0gY3JlYXRlU3ludGhldGljRXZlbnQoQ2xpcGJvYXJkRXZlbnRJbnRlcmZhY2UpO1xuLyoqXG4gKiBAaW50ZXJmYWNlIEV2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy8jZXZlbnRzLWNvbXBvc2l0aW9uZXZlbnRzXG4gKi9cblxudmFyIENvbXBvc2l0aW9uRXZlbnRJbnRlcmZhY2UgPSBfYXNzaWduKHt9LCBFdmVudEludGVyZmFjZSwge1xuICBkYXRhOiAwXG59KTtcblxudmFyIFN5bnRoZXRpY0NvbXBvc2l0aW9uRXZlbnQgPSBjcmVhdGVTeW50aGV0aWNFdmVudChDb21wb3NpdGlvbkV2ZW50SW50ZXJmYWNlKTtcbi8qKlxuICogQGludGVyZmFjZSBFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi8yMDEzL1dELURPTS1MZXZlbC0zLUV2ZW50cy0yMDEzMTEwNVxuICogICAgICAvI2V2ZW50cy1pbnB1dGV2ZW50c1xuICovXG4vLyBIYXBwZW5zIHRvIHNoYXJlIHRoZSBzYW1lIGxpc3QgZm9yIG5vdy5cblxudmFyIFN5bnRoZXRpY0lucHV0RXZlbnQgPSBTeW50aGV0aWNDb21wb3NpdGlvbkV2ZW50O1xuLyoqXG4gKiBOb3JtYWxpemF0aW9uIG9mIGRlcHJlY2F0ZWQgSFRNTDUgYGtleWAgdmFsdWVzXG4gKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9LZXlib2FyZEV2ZW50I0tleV9uYW1lc1xuICovXG5cbnZhciBub3JtYWxpemVLZXkgPSB7XG4gIEVzYzogJ0VzY2FwZScsXG4gIFNwYWNlYmFyOiAnICcsXG4gIExlZnQ6ICdBcnJvd0xlZnQnLFxuICBVcDogJ0Fycm93VXAnLFxuICBSaWdodDogJ0Fycm93UmlnaHQnLFxuICBEb3duOiAnQXJyb3dEb3duJyxcbiAgRGVsOiAnRGVsZXRlJyxcbiAgV2luOiAnT1MnLFxuICBNZW51OiAnQ29udGV4dE1lbnUnLFxuICBBcHBzOiAnQ29udGV4dE1lbnUnLFxuICBTY3JvbGw6ICdTY3JvbGxMb2NrJyxcbiAgTW96UHJpbnRhYmxlS2V5OiAnVW5pZGVudGlmaWVkJ1xufTtcbi8qKlxuICogVHJhbnNsYXRpb24gZnJvbSBsZWdhY3kgYGtleUNvZGVgIHRvIEhUTUw1IGBrZXlgXG4gKiBPbmx5IHNwZWNpYWwga2V5cyBzdXBwb3J0ZWQsIGFsbCBvdGhlcnMgZGVwZW5kIG9uIGtleWJvYXJkIGxheW91dCBvciBicm93c2VyXG4gKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9LZXlib2FyZEV2ZW50I0tleV9uYW1lc1xuICovXG5cbnZhciB0cmFuc2xhdGVUb0tleSA9IHtcbiAgJzgnOiAnQmFja3NwYWNlJyxcbiAgJzknOiAnVGFiJyxcbiAgJzEyJzogJ0NsZWFyJyxcbiAgJzEzJzogJ0VudGVyJyxcbiAgJzE2JzogJ1NoaWZ0JyxcbiAgJzE3JzogJ0NvbnRyb2wnLFxuICAnMTgnOiAnQWx0JyxcbiAgJzE5JzogJ1BhdXNlJyxcbiAgJzIwJzogJ0NhcHNMb2NrJyxcbiAgJzI3JzogJ0VzY2FwZScsXG4gICczMic6ICcgJyxcbiAgJzMzJzogJ1BhZ2VVcCcsXG4gICczNCc6ICdQYWdlRG93bicsXG4gICczNSc6ICdFbmQnLFxuICAnMzYnOiAnSG9tZScsXG4gICczNyc6ICdBcnJvd0xlZnQnLFxuICAnMzgnOiAnQXJyb3dVcCcsXG4gICczOSc6ICdBcnJvd1JpZ2h0JyxcbiAgJzQwJzogJ0Fycm93RG93bicsXG4gICc0NSc6ICdJbnNlcnQnLFxuICAnNDYnOiAnRGVsZXRlJyxcbiAgJzExMic6ICdGMScsXG4gICcxMTMnOiAnRjInLFxuICAnMTE0JzogJ0YzJyxcbiAgJzExNSc6ICdGNCcsXG4gICcxMTYnOiAnRjUnLFxuICAnMTE3JzogJ0Y2JyxcbiAgJzExOCc6ICdGNycsXG4gICcxMTknOiAnRjgnLFxuICAnMTIwJzogJ0Y5JyxcbiAgJzEyMSc6ICdGMTAnLFxuICAnMTIyJzogJ0YxMScsXG4gICcxMjMnOiAnRjEyJyxcbiAgJzE0NCc6ICdOdW1Mb2NrJyxcbiAgJzE0NSc6ICdTY3JvbGxMb2NrJyxcbiAgJzIyNCc6ICdNZXRhJ1xufTtcbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQHJldHVybiB7c3RyaW5nfSBOb3JtYWxpemVkIGBrZXlgIHByb3BlcnR5LlxuICovXG5cbmZ1bmN0aW9uIGdldEV2ZW50S2V5KG5hdGl2ZUV2ZW50KSB7XG4gIGlmIChuYXRpdmVFdmVudC5rZXkpIHtcbiAgICAvLyBOb3JtYWxpemUgaW5jb25zaXN0ZW50IHZhbHVlcyByZXBvcnRlZCBieSBicm93c2VycyBkdWUgdG9cbiAgICAvLyBpbXBsZW1lbnRhdGlvbnMgb2YgYSB3b3JraW5nIGRyYWZ0IHNwZWNpZmljYXRpb24uXG4gICAgLy8gRmlyZUZveCBpbXBsZW1lbnRzIGBrZXlgIGJ1dCByZXR1cm5zIGBNb3pQcmludGFibGVLZXlgIGZvciBhbGxcbiAgICAvLyBwcmludGFibGUgY2hhcmFjdGVycyAobm9ybWFsaXplZCB0byBgVW5pZGVudGlmaWVkYCksIGlnbm9yZSBpdC5cbiAgICB2YXIga2V5ID0gbm9ybWFsaXplS2V5W25hdGl2ZUV2ZW50LmtleV0gfHwgbmF0aXZlRXZlbnQua2V5O1xuXG4gICAgaWYgKGtleSAhPT0gJ1VuaWRlbnRpZmllZCcpIHtcbiAgICAgIHJldHVybiBrZXk7XG4gICAgfVxuICB9IC8vIEJyb3dzZXIgZG9lcyBub3QgaW1wbGVtZW50IGBrZXlgLCBwb2x5ZmlsbCBhcyBtdWNoIG9mIGl0IGFzIHdlIGNhbi5cblxuXG4gIGlmIChuYXRpdmVFdmVudC50eXBlID09PSAna2V5cHJlc3MnKSB7XG4gICAgdmFyIGNoYXJDb2RlID0gZ2V0RXZlbnRDaGFyQ29kZShuYXRpdmVFdmVudCk7IC8vIFRoZSBlbnRlci1rZXkgaXMgdGVjaG5pY2FsbHkgYm90aCBwcmludGFibGUgYW5kIG5vbi1wcmludGFibGUgYW5kIGNhblxuICAgIC8vIHRodXMgYmUgY2FwdHVyZWQgYnkgYGtleXByZXNzYCwgbm8gb3RoZXIgbm9uLXByaW50YWJsZSBrZXkgc2hvdWxkLlxuXG4gICAgcmV0dXJuIGNoYXJDb2RlID09PSAxMyA/ICdFbnRlcicgOiBTdHJpbmcuZnJvbUNoYXJDb2RlKGNoYXJDb2RlKTtcbiAgfVxuXG4gIGlmIChuYXRpdmVFdmVudC50eXBlID09PSAna2V5ZG93bicgfHwgbmF0aXZlRXZlbnQudHlwZSA9PT0gJ2tleXVwJykge1xuICAgIC8vIFdoaWxlIHVzZXIga2V5Ym9hcmQgbGF5b3V0IGRldGVybWluZXMgdGhlIGFjdHVhbCBtZWFuaW5nIG9mIGVhY2hcbiAgICAvLyBga2V5Q29kZWAgdmFsdWUsIGFsbW9zdCBhbGwgZnVuY3Rpb24ga2V5cyBoYXZlIGEgdW5pdmVyc2FsIHZhbHVlLlxuICAgIHJldHVybiB0cmFuc2xhdGVUb0tleVtuYXRpdmVFdmVudC5rZXlDb2RlXSB8fCAnVW5pZGVudGlmaWVkJztcbiAgfVxuXG4gIHJldHVybiAnJztcbn1cbi8qKlxuICogVHJhbnNsYXRpb24gZnJvbSBtb2RpZmllciBrZXkgdG8gdGhlIGFzc29jaWF0ZWQgcHJvcGVydHkgaW4gdGhlIGV2ZW50LlxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvI2tleXMtTW9kaWZpZXJzXG4gKi9cblxuXG52YXIgbW9kaWZpZXJLZXlUb1Byb3AgPSB7XG4gIEFsdDogJ2FsdEtleScsXG4gIENvbnRyb2w6ICdjdHJsS2V5JyxcbiAgTWV0YTogJ21ldGFLZXknLFxuICBTaGlmdDogJ3NoaWZ0S2V5J1xufTsgLy8gT2xkZXIgYnJvd3NlcnMgKFNhZmFyaSA8PSAxMCwgaU9TIFNhZmFyaSA8PSAxMC4yKSBkbyBub3Qgc3VwcG9ydFxuLy8gZ2V0TW9kaWZpZXJTdGF0ZS4gSWYgZ2V0TW9kaWZpZXJTdGF0ZSBpcyBub3Qgc3VwcG9ydGVkLCB3ZSBtYXAgaXQgdG8gYSBzZXQgb2Zcbi8vIG1vZGlmaWVyIGtleXMgZXhwb3NlZCBieSB0aGUgZXZlbnQuIEluIHRoaXMgY2FzZSwgTG9jay1rZXlzIGFyZSBub3Qgc3VwcG9ydGVkLlxuXG5mdW5jdGlvbiBtb2RpZmllclN0YXRlR2V0dGVyKGtleUFyZykge1xuICB2YXIgc3ludGhldGljRXZlbnQgPSB0aGlzO1xuICB2YXIgbmF0aXZlRXZlbnQgPSBzeW50aGV0aWNFdmVudC5uYXRpdmVFdmVudDtcblxuICBpZiAobmF0aXZlRXZlbnQuZ2V0TW9kaWZpZXJTdGF0ZSkge1xuICAgIHJldHVybiBuYXRpdmVFdmVudC5nZXRNb2RpZmllclN0YXRlKGtleUFyZyk7XG4gIH1cblxuICB2YXIga2V5UHJvcCA9IG1vZGlmaWVyS2V5VG9Qcm9wW2tleUFyZ107XG4gIHJldHVybiBrZXlQcm9wID8gISFuYXRpdmVFdmVudFtrZXlQcm9wXSA6IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBnZXRFdmVudE1vZGlmaWVyU3RhdGUobmF0aXZlRXZlbnQpIHtcbiAgcmV0dXJuIG1vZGlmaWVyU3RhdGVHZXR0ZXI7XG59XG4vKipcbiAqIEBpbnRlcmZhY2UgS2V5Ym9hcmRFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvXG4gKi9cblxuXG52YXIgS2V5Ym9hcmRFdmVudEludGVyZmFjZSA9IF9hc3NpZ24oe30sIFVJRXZlbnRJbnRlcmZhY2UsIHtcbiAga2V5OiBnZXRFdmVudEtleSxcbiAgY29kZTogMCxcbiAgbG9jYXRpb246IDAsXG4gIGN0cmxLZXk6IDAsXG4gIHNoaWZ0S2V5OiAwLFxuICBhbHRLZXk6IDAsXG4gIG1ldGFLZXk6IDAsXG4gIHJlcGVhdDogMCxcbiAgbG9jYWxlOiAwLFxuICBnZXRNb2RpZmllclN0YXRlOiBnZXRFdmVudE1vZGlmaWVyU3RhdGUsXG4gIC8vIExlZ2FjeSBJbnRlcmZhY2VcbiAgY2hhckNvZGU6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIC8vIGBjaGFyQ29kZWAgaXMgdGhlIHJlc3VsdCBvZiBhIEtleVByZXNzIGV2ZW50IGFuZCByZXByZXNlbnRzIHRoZSB2YWx1ZSBvZlxuICAgIC8vIHRoZSBhY3R1YWwgcHJpbnRhYmxlIGNoYXJhY3Rlci5cbiAgICAvLyBLZXlQcmVzcyBpcyBkZXByZWNhdGVkLCBidXQgaXRzIHJlcGxhY2VtZW50IGlzIG5vdCB5ZXQgZmluYWwgYW5kIG5vdFxuICAgIC8vIGltcGxlbWVudGVkIGluIGFueSBtYWpvciBicm93c2VyLiBPbmx5IEtleVByZXNzIGhhcyBjaGFyQ29kZS5cbiAgICBpZiAoZXZlbnQudHlwZSA9PT0gJ2tleXByZXNzJykge1xuICAgICAgcmV0dXJuIGdldEV2ZW50Q2hhckNvZGUoZXZlbnQpO1xuICAgIH1cblxuICAgIHJldHVybiAwO1xuICB9LFxuICBrZXlDb2RlOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAvLyBga2V5Q29kZWAgaXMgdGhlIHJlc3VsdCBvZiBhIEtleURvd24vVXAgZXZlbnQgYW5kIHJlcHJlc2VudHMgdGhlIHZhbHVlIG9mXG4gICAgLy8gcGh5c2ljYWwga2V5Ym9hcmQga2V5LlxuICAgIC8vIFRoZSBhY3R1YWwgbWVhbmluZyBvZiB0aGUgdmFsdWUgZGVwZW5kcyBvbiB0aGUgdXNlcnMnIGtleWJvYXJkIGxheW91dFxuICAgIC8vIHdoaWNoIGNhbm5vdCBiZSBkZXRlY3RlZC4gQXNzdW1pbmcgdGhhdCBpdCBpcyBhIFVTIGtleWJvYXJkIGxheW91dFxuICAgIC8vIHByb3ZpZGVzIGEgc3VycHJpc2luZ2x5IGFjY3VyYXRlIG1hcHBpbmcgZm9yIFVTIGFuZCBFdXJvcGVhbiB1c2Vycy5cbiAgICAvLyBEdWUgdG8gdGhpcywgaXQgaXMgbGVmdCB0byB0aGUgdXNlciB0byBpbXBsZW1lbnQgYXQgdGhpcyB0aW1lLlxuICAgIGlmIChldmVudC50eXBlID09PSAna2V5ZG93bicgfHwgZXZlbnQudHlwZSA9PT0gJ2tleXVwJykge1xuICAgICAgcmV0dXJuIGV2ZW50LmtleUNvZGU7XG4gICAgfVxuXG4gICAgcmV0dXJuIDA7XG4gIH0sXG4gIHdoaWNoOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAvLyBgd2hpY2hgIGlzIGFuIGFsaWFzIGZvciBlaXRoZXIgYGtleUNvZGVgIG9yIGBjaGFyQ29kZWAgZGVwZW5kaW5nIG9uIHRoZVxuICAgIC8vIHR5cGUgb2YgdGhlIGV2ZW50LlxuICAgIGlmIChldmVudC50eXBlID09PSAna2V5cHJlc3MnKSB7XG4gICAgICByZXR1cm4gZ2V0RXZlbnRDaGFyQ29kZShldmVudCk7XG4gICAgfVxuXG4gICAgaWYgKGV2ZW50LnR5cGUgPT09ICdrZXlkb3duJyB8fCBldmVudC50eXBlID09PSAna2V5dXAnKSB7XG4gICAgICByZXR1cm4gZXZlbnQua2V5Q29kZTtcbiAgICB9XG5cbiAgICByZXR1cm4gMDtcbiAgfVxufSk7XG5cbnZhciBTeW50aGV0aWNLZXlib2FyZEV2ZW50ID0gY3JlYXRlU3ludGhldGljRXZlbnQoS2V5Ym9hcmRFdmVudEludGVyZmFjZSk7XG4vKipcbiAqIEBpbnRlcmZhY2UgUG9pbnRlckV2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL3BvaW50ZXJldmVudHMvXG4gKi9cblxudmFyIFBvaW50ZXJFdmVudEludGVyZmFjZSA9IF9hc3NpZ24oe30sIE1vdXNlRXZlbnRJbnRlcmZhY2UsIHtcbiAgcG9pbnRlcklkOiAwLFxuICB3aWR0aDogMCxcbiAgaGVpZ2h0OiAwLFxuICBwcmVzc3VyZTogMCxcbiAgdGFuZ2VudGlhbFByZXNzdXJlOiAwLFxuICB0aWx0WDogMCxcbiAgdGlsdFk6IDAsXG4gIHR3aXN0OiAwLFxuICBwb2ludGVyVHlwZTogMCxcbiAgaXNQcmltYXJ5OiAwXG59KTtcblxudmFyIFN5bnRoZXRpY1BvaW50ZXJFdmVudCA9IGNyZWF0ZVN5bnRoZXRpY0V2ZW50KFBvaW50ZXJFdmVudEludGVyZmFjZSk7XG4vKipcbiAqIEBpbnRlcmZhY2UgVG91Y2hFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi90b3VjaC1ldmVudHMvXG4gKi9cblxudmFyIFRvdWNoRXZlbnRJbnRlcmZhY2UgPSBfYXNzaWduKHt9LCBVSUV2ZW50SW50ZXJmYWNlLCB7XG4gIHRvdWNoZXM6IDAsXG4gIHRhcmdldFRvdWNoZXM6IDAsXG4gIGNoYW5nZWRUb3VjaGVzOiAwLFxuICBhbHRLZXk6IDAsXG4gIG1ldGFLZXk6IDAsXG4gIGN0cmxLZXk6IDAsXG4gIHNoaWZ0S2V5OiAwLFxuICBnZXRNb2RpZmllclN0YXRlOiBnZXRFdmVudE1vZGlmaWVyU3RhdGVcbn0pO1xuXG52YXIgU3ludGhldGljVG91Y2hFdmVudCA9IGNyZWF0ZVN5bnRoZXRpY0V2ZW50KFRvdWNoRXZlbnRJbnRlcmZhY2UpO1xuLyoqXG4gKiBAaW50ZXJmYWNlIEV2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSLzIwMDkvV0QtY3NzMy10cmFuc2l0aW9ucy0yMDA5MDMyMC8jdHJhbnNpdGlvbi1ldmVudHMtXG4gKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9UcmFuc2l0aW9uRXZlbnRcbiAqL1xuXG52YXIgVHJhbnNpdGlvbkV2ZW50SW50ZXJmYWNlID0gX2Fzc2lnbih7fSwgRXZlbnRJbnRlcmZhY2UsIHtcbiAgcHJvcGVydHlOYW1lOiAwLFxuICBlbGFwc2VkVGltZTogMCxcbiAgcHNldWRvRWxlbWVudDogMFxufSk7XG5cbnZhciBTeW50aGV0aWNUcmFuc2l0aW9uRXZlbnQgPSBjcmVhdGVTeW50aGV0aWNFdmVudChUcmFuc2l0aW9uRXZlbnRJbnRlcmZhY2UpO1xuLyoqXG4gKiBAaW50ZXJmYWNlIFdoZWVsRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzL1xuICovXG5cbnZhciBXaGVlbEV2ZW50SW50ZXJmYWNlID0gX2Fzc2lnbih7fSwgTW91c2VFdmVudEludGVyZmFjZSwge1xuICBkZWx0YVg6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHJldHVybiAnZGVsdGFYJyBpbiBldmVudCA/IGV2ZW50LmRlbHRhWCA6IC8vIEZhbGxiYWNrIHRvIGB3aGVlbERlbHRhWGAgZm9yIFdlYmtpdCBhbmQgbm9ybWFsaXplIChyaWdodCBpcyBwb3NpdGl2ZSkuXG4gICAgJ3doZWVsRGVsdGFYJyBpbiBldmVudCA/IC1ldmVudC53aGVlbERlbHRhWCA6IDA7XG4gIH0sXG4gIGRlbHRhWTogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgcmV0dXJuICdkZWx0YVknIGluIGV2ZW50ID8gZXZlbnQuZGVsdGFZIDogLy8gRmFsbGJhY2sgdG8gYHdoZWVsRGVsdGFZYCBmb3IgV2Via2l0IGFuZCBub3JtYWxpemUgKGRvd24gaXMgcG9zaXRpdmUpLlxuICAgICd3aGVlbERlbHRhWScgaW4gZXZlbnQgPyAtZXZlbnQud2hlZWxEZWx0YVkgOiAvLyBGYWxsYmFjayB0byBgd2hlZWxEZWx0YWAgZm9yIElFPDkgYW5kIG5vcm1hbGl6ZSAoZG93biBpcyBwb3NpdGl2ZSkuXG4gICAgJ3doZWVsRGVsdGEnIGluIGV2ZW50ID8gLWV2ZW50LndoZWVsRGVsdGEgOiAwO1xuICB9LFxuICBkZWx0YVo6IDAsXG4gIC8vIEJyb3dzZXJzIHdpdGhvdXQgXCJkZWx0YU1vZGVcIiBpcyByZXBvcnRpbmcgaW4gcmF3IHdoZWVsIGRlbHRhIHdoZXJlIG9uZVxuICAvLyBub3RjaCBvbiB0aGUgc2Nyb2xsIGlzIGFsd2F5cyArLy0gMTIwLCByb3VnaGx5IGVxdWl2YWxlbnQgdG8gcGl4ZWxzLlxuICAvLyBBIGdvb2QgYXBwcm94aW1hdGlvbiBvZiBET01fREVMVEFfTElORSAoMSkgaXMgNSUgb2Ygdmlld3BvcnQgc2l6ZSBvclxuICAvLyB+NDAgcGl4ZWxzLCBmb3IgRE9NX0RFTFRBX1NDUkVFTiAoMikgaXQgaXMgODcuNSUgb2Ygdmlld3BvcnQgc2l6ZS5cbiAgZGVsdGFNb2RlOiAwXG59KTtcblxudmFyIFN5bnRoZXRpY1doZWVsRXZlbnQgPSBjcmVhdGVTeW50aGV0aWNFdmVudChXaGVlbEV2ZW50SW50ZXJmYWNlKTtcblxudmFyIEVORF9LRVlDT0RFUyA9IFs5LCAxMywgMjcsIDMyXTsgLy8gVGFiLCBSZXR1cm4sIEVzYywgU3BhY2VcblxudmFyIFNUQVJUX0tFWUNPREUgPSAyMjk7XG52YXIgY2FuVXNlQ29tcG9zaXRpb25FdmVudCA9IGNhblVzZURPTSAmJiAnQ29tcG9zaXRpb25FdmVudCcgaW4gd2luZG93O1xudmFyIGRvY3VtZW50TW9kZSA9IG51bGw7XG5cbmlmIChjYW5Vc2VET00gJiYgJ2RvY3VtZW50TW9kZScgaW4gZG9jdW1lbnQpIHtcbiAgZG9jdW1lbnRNb2RlID0gZG9jdW1lbnQuZG9jdW1lbnRNb2RlO1xufSAvLyBXZWJraXQgb2ZmZXJzIGEgdmVyeSB1c2VmdWwgYHRleHRJbnB1dGAgZXZlbnQgdGhhdCBjYW4gYmUgdXNlZCB0b1xuLy8gZGlyZWN0bHkgcmVwcmVzZW50IGBiZWZvcmVJbnB1dGAuIFRoZSBJRSBgdGV4dGlucHV0YCBldmVudCBpcyBub3QgYXNcbi8vIHVzZWZ1bCwgc28gd2UgZG9uJ3QgdXNlIGl0LlxuXG5cbnZhciBjYW5Vc2VUZXh0SW5wdXRFdmVudCA9IGNhblVzZURPTSAmJiAnVGV4dEV2ZW50JyBpbiB3aW5kb3cgJiYgIWRvY3VtZW50TW9kZTsgLy8gSW4gSUU5Kywgd2UgaGF2ZSBhY2Nlc3MgdG8gY29tcG9zaXRpb24gZXZlbnRzLCBidXQgdGhlIGRhdGEgc3VwcGxpZWRcbi8vIGJ5IHRoZSBuYXRpdmUgY29tcG9zaXRpb25lbmQgZXZlbnQgbWF5IGJlIGluY29ycmVjdC4gSmFwYW5lc2UgaWRlb2dyYXBoaWNcbi8vIHNwYWNlcywgZm9yIGluc3RhbmNlIChcXHUzMDAwKSBhcmUgbm90IHJlY29yZGVkIGNvcnJlY3RseS5cblxudmFyIHVzZUZhbGxiYWNrQ29tcG9zaXRpb25EYXRhID0gY2FuVXNlRE9NICYmICghY2FuVXNlQ29tcG9zaXRpb25FdmVudCB8fCBkb2N1bWVudE1vZGUgJiYgZG9jdW1lbnRNb2RlID4gOCAmJiBkb2N1bWVudE1vZGUgPD0gMTEpO1xudmFyIFNQQUNFQkFSX0NPREUgPSAzMjtcbnZhciBTUEFDRUJBUl9DSEFSID0gU3RyaW5nLmZyb21DaGFyQ29kZShTUEFDRUJBUl9DT0RFKTtcblxuZnVuY3Rpb24gcmVnaXN0ZXJFdmVudHMoKSB7XG4gIHJlZ2lzdGVyVHdvUGhhc2VFdmVudCgnb25CZWZvcmVJbnB1dCcsIFsnY29tcG9zaXRpb25lbmQnLCAna2V5cHJlc3MnLCAndGV4dElucHV0JywgJ3Bhc3RlJ10pO1xuICByZWdpc3RlclR3b1BoYXNlRXZlbnQoJ29uQ29tcG9zaXRpb25FbmQnLCBbJ2NvbXBvc2l0aW9uZW5kJywgJ2ZvY3Vzb3V0JywgJ2tleWRvd24nLCAna2V5cHJlc3MnLCAna2V5dXAnLCAnbW91c2Vkb3duJ10pO1xuICByZWdpc3RlclR3b1BoYXNlRXZlbnQoJ29uQ29tcG9zaXRpb25TdGFydCcsIFsnY29tcG9zaXRpb25zdGFydCcsICdmb2N1c291dCcsICdrZXlkb3duJywgJ2tleXByZXNzJywgJ2tleXVwJywgJ21vdXNlZG93biddKTtcbiAgcmVnaXN0ZXJUd29QaGFzZUV2ZW50KCdvbkNvbXBvc2l0aW9uVXBkYXRlJywgWydjb21wb3NpdGlvbnVwZGF0ZScsICdmb2N1c291dCcsICdrZXlkb3duJywgJ2tleXByZXNzJywgJ2tleXVwJywgJ21vdXNlZG93biddKTtcbn0gLy8gVHJhY2sgd2hldGhlciB3ZSd2ZSBldmVyIGhhbmRsZWQgYSBrZXlwcmVzcyBvbiB0aGUgc3BhY2Uga2V5LlxuXG5cbnZhciBoYXNTcGFjZUtleXByZXNzID0gZmFsc2U7XG4vKipcbiAqIFJldHVybiB3aGV0aGVyIGEgbmF0aXZlIGtleXByZXNzIGV2ZW50IGlzIGFzc3VtZWQgdG8gYmUgYSBjb21tYW5kLlxuICogVGhpcyBpcyByZXF1aXJlZCBiZWNhdXNlIEZpcmVmb3ggZmlyZXMgYGtleXByZXNzYCBldmVudHMgZm9yIGtleSBjb21tYW5kc1xuICogKGN1dCwgY29weSwgc2VsZWN0LWFsbCwgZXRjLikgZXZlbiB0aG91Z2ggbm8gY2hhcmFjdGVyIGlzIGluc2VydGVkLlxuICovXG5cbmZ1bmN0aW9uIGlzS2V5cHJlc3NDb21tYW5kKG5hdGl2ZUV2ZW50KSB7XG4gIHJldHVybiAobmF0aXZlRXZlbnQuY3RybEtleSB8fCBuYXRpdmVFdmVudC5hbHRLZXkgfHwgbmF0aXZlRXZlbnQubWV0YUtleSkgJiYgLy8gY3RybEtleSAmJiBhbHRLZXkgaXMgZXF1aXZhbGVudCB0byBBbHRHciwgYW5kIGlzIG5vdCBhIGNvbW1hbmQuXG4gICEobmF0aXZlRXZlbnQuY3RybEtleSAmJiBuYXRpdmVFdmVudC5hbHRLZXkpO1xufVxuLyoqXG4gKiBUcmFuc2xhdGUgbmF0aXZlIHRvcCBsZXZlbCBldmVudHMgaW50byBldmVudCB0eXBlcy5cbiAqL1xuXG5cbmZ1bmN0aW9uIGdldENvbXBvc2l0aW9uRXZlbnRUeXBlKGRvbUV2ZW50TmFtZSkge1xuICBzd2l0Y2ggKGRvbUV2ZW50TmFtZSkge1xuICAgIGNhc2UgJ2NvbXBvc2l0aW9uc3RhcnQnOlxuICAgICAgcmV0dXJuICdvbkNvbXBvc2l0aW9uU3RhcnQnO1xuXG4gICAgY2FzZSAnY29tcG9zaXRpb25lbmQnOlxuICAgICAgcmV0dXJuICdvbkNvbXBvc2l0aW9uRW5kJztcblxuICAgIGNhc2UgJ2NvbXBvc2l0aW9udXBkYXRlJzpcbiAgICAgIHJldHVybiAnb25Db21wb3NpdGlvblVwZGF0ZSc7XG4gIH1cbn1cbi8qKlxuICogRG9lcyBvdXIgZmFsbGJhY2sgYmVzdC1ndWVzcyBtb2RlbCB0aGluayB0aGlzIGV2ZW50IHNpZ25pZmllcyB0aGF0XG4gKiBjb21wb3NpdGlvbiBoYXMgYmVndW4/XG4gKi9cblxuXG5mdW5jdGlvbiBpc0ZhbGxiYWNrQ29tcG9zaXRpb25TdGFydChkb21FdmVudE5hbWUsIG5hdGl2ZUV2ZW50KSB7XG4gIHJldHVybiBkb21FdmVudE5hbWUgPT09ICdrZXlkb3duJyAmJiBuYXRpdmVFdmVudC5rZXlDb2RlID09PSBTVEFSVF9LRVlDT0RFO1xufVxuLyoqXG4gKiBEb2VzIG91ciBmYWxsYmFjayBtb2RlIHRoaW5rIHRoYXQgdGhpcyBldmVudCBpcyB0aGUgZW5kIG9mIGNvbXBvc2l0aW9uP1xuICovXG5cblxuZnVuY3Rpb24gaXNGYWxsYmFja0NvbXBvc2l0aW9uRW5kKGRvbUV2ZW50TmFtZSwgbmF0aXZlRXZlbnQpIHtcbiAgc3dpdGNoIChkb21FdmVudE5hbWUpIHtcbiAgICBjYXNlICdrZXl1cCc6XG4gICAgICAvLyBDb21tYW5kIGtleXMgaW5zZXJ0IG9yIGNsZWFyIElNRSBpbnB1dC5cbiAgICAgIHJldHVybiBFTkRfS0VZQ09ERVMuaW5kZXhPZihuYXRpdmVFdmVudC5rZXlDb2RlKSAhPT0gLTE7XG5cbiAgICBjYXNlICdrZXlkb3duJzpcbiAgICAgIC8vIEV4cGVjdCBJTUUga2V5Q29kZSBvbiBlYWNoIGtleWRvd24uIElmIHdlIGdldCBhbnkgb3RoZXJcbiAgICAgIC8vIGNvZGUgd2UgbXVzdCBoYXZlIGV4aXRlZCBlYXJsaWVyLlxuICAgICAgcmV0dXJuIG5hdGl2ZUV2ZW50LmtleUNvZGUgIT09IFNUQVJUX0tFWUNPREU7XG5cbiAgICBjYXNlICdrZXlwcmVzcyc6XG4gICAgY2FzZSAnbW91c2Vkb3duJzpcbiAgICBjYXNlICdmb2N1c291dCc6XG4gICAgICAvLyBFdmVudHMgYXJlIG5vdCBwb3NzaWJsZSB3aXRob3V0IGNhbmNlbGxpbmcgSU1FLlxuICAgICAgcmV0dXJuIHRydWU7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG4vKipcbiAqIEdvb2dsZSBJbnB1dCBUb29scyBwcm92aWRlcyBjb21wb3NpdGlvbiBkYXRhIHZpYSBhIEN1c3RvbUV2ZW50LFxuICogd2l0aCB0aGUgYGRhdGFgIHByb3BlcnR5IHBvcHVsYXRlZCBpbiB0aGUgYGRldGFpbGAgb2JqZWN0LiBJZiB0aGlzXG4gKiBpcyBhdmFpbGFibGUgb24gdGhlIGV2ZW50IG9iamVjdCwgdXNlIGl0LiBJZiBub3QsIHRoaXMgaXMgYSBwbGFpblxuICogY29tcG9zaXRpb24gZXZlbnQgYW5kIHdlIGhhdmUgbm90aGluZyBzcGVjaWFsIHRvIGV4dHJhY3QuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50XG4gKiBAcmV0dXJuIHs/c3RyaW5nfVxuICovXG5cblxuZnVuY3Rpb24gZ2V0RGF0YUZyb21DdXN0b21FdmVudChuYXRpdmVFdmVudCkge1xuICB2YXIgZGV0YWlsID0gbmF0aXZlRXZlbnQuZGV0YWlsO1xuXG4gIGlmICh0eXBlb2YgZGV0YWlsID09PSAnb2JqZWN0JyAmJiAnZGF0YScgaW4gZGV0YWlsKSB7XG4gICAgcmV0dXJuIGRldGFpbC5kYXRhO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG4vKipcbiAqIENoZWNrIGlmIGEgY29tcG9zaXRpb24gZXZlbnQgd2FzIHRyaWdnZXJlZCBieSBLb3JlYW4gSU1FLlxuICogT3VyIGZhbGxiYWNrIG1vZGUgZG9lcyBub3Qgd29yayB3ZWxsIHdpdGggSUUncyBLb3JlYW4gSU1FLFxuICogc28ganVzdCB1c2UgbmF0aXZlIGNvbXBvc2l0aW9uIGV2ZW50cyB3aGVuIEtvcmVhbiBJTUUgaXMgdXNlZC5cbiAqIEFsdGhvdWdoIENvbXBvc2l0aW9uRXZlbnQubG9jYWxlIHByb3BlcnR5IGlzIGRlcHJlY2F0ZWQsXG4gKiBpdCBpcyBhdmFpbGFibGUgaW4gSUUsIHdoZXJlIG91ciBmYWxsYmFjayBtb2RlIGlzIGVuYWJsZWQuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50XG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5cblxuZnVuY3Rpb24gaXNVc2luZ0tvcmVhbklNRShuYXRpdmVFdmVudCkge1xuICByZXR1cm4gbmF0aXZlRXZlbnQubG9jYWxlID09PSAna28nO1xufSAvLyBUcmFjayB0aGUgY3VycmVudCBJTUUgY29tcG9zaXRpb24gc3RhdHVzLCBpZiBhbnkuXG5cblxudmFyIGlzQ29tcG9zaW5nID0gZmFsc2U7XG4vKipcbiAqIEByZXR1cm4gez9vYmplY3R9IEEgU3ludGhldGljQ29tcG9zaXRpb25FdmVudC5cbiAqL1xuXG5mdW5jdGlvbiBleHRyYWN0Q29tcG9zaXRpb25FdmVudChkaXNwYXRjaFF1ZXVlLCBkb21FdmVudE5hbWUsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICB2YXIgZXZlbnRUeXBlO1xuICB2YXIgZmFsbGJhY2tEYXRhO1xuXG4gIGlmIChjYW5Vc2VDb21wb3NpdGlvbkV2ZW50KSB7XG4gICAgZXZlbnRUeXBlID0gZ2V0Q29tcG9zaXRpb25FdmVudFR5cGUoZG9tRXZlbnROYW1lKTtcbiAgfSBlbHNlIGlmICghaXNDb21wb3NpbmcpIHtcbiAgICBpZiAoaXNGYWxsYmFja0NvbXBvc2l0aW9uU3RhcnQoZG9tRXZlbnROYW1lLCBuYXRpdmVFdmVudCkpIHtcbiAgICAgIGV2ZW50VHlwZSA9ICdvbkNvbXBvc2l0aW9uU3RhcnQnO1xuICAgIH1cbiAgfSBlbHNlIGlmIChpc0ZhbGxiYWNrQ29tcG9zaXRpb25FbmQoZG9tRXZlbnROYW1lLCBuYXRpdmVFdmVudCkpIHtcbiAgICBldmVudFR5cGUgPSAnb25Db21wb3NpdGlvbkVuZCc7XG4gIH1cblxuICBpZiAoIWV2ZW50VHlwZSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgaWYgKHVzZUZhbGxiYWNrQ29tcG9zaXRpb25EYXRhICYmICFpc1VzaW5nS29yZWFuSU1FKG5hdGl2ZUV2ZW50KSkge1xuICAgIC8vIFRoZSBjdXJyZW50IGNvbXBvc2l0aW9uIGlzIHN0b3JlZCBzdGF0aWNhbGx5IGFuZCBtdXN0IG5vdCBiZVxuICAgIC8vIG92ZXJ3cml0dGVuIHdoaWxlIGNvbXBvc2l0aW9uIGNvbnRpbnVlcy5cbiAgICBpZiAoIWlzQ29tcG9zaW5nICYmIGV2ZW50VHlwZSA9PT0gJ29uQ29tcG9zaXRpb25TdGFydCcpIHtcbiAgICAgIGlzQ29tcG9zaW5nID0gaW5pdGlhbGl6ZShuYXRpdmVFdmVudFRhcmdldCk7XG4gICAgfSBlbHNlIGlmIChldmVudFR5cGUgPT09ICdvbkNvbXBvc2l0aW9uRW5kJykge1xuICAgICAgaWYgKGlzQ29tcG9zaW5nKSB7XG4gICAgICAgIGZhbGxiYWNrRGF0YSA9IGdldERhdGEoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2YXIgbGlzdGVuZXJzID0gYWNjdW11bGF0ZVR3b1BoYXNlTGlzdGVuZXJzKHRhcmdldEluc3QsIGV2ZW50VHlwZSk7XG5cbiAgaWYgKGxpc3RlbmVycy5sZW5ndGggPiAwKSB7XG4gICAgdmFyIGV2ZW50ID0gbmV3IFN5bnRoZXRpY0NvbXBvc2l0aW9uRXZlbnQoZXZlbnRUeXBlLCBkb21FdmVudE5hbWUsIG51bGwsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG4gICAgZGlzcGF0Y2hRdWV1ZS5wdXNoKHtcbiAgICAgIGV2ZW50OiBldmVudCxcbiAgICAgIGxpc3RlbmVyczogbGlzdGVuZXJzXG4gICAgfSk7XG5cbiAgICBpZiAoZmFsbGJhY2tEYXRhKSB7XG4gICAgICAvLyBJbmplY3QgZGF0YSBnZW5lcmF0ZWQgZnJvbSBmYWxsYmFjayBwYXRoIGludG8gdGhlIHN5bnRoZXRpYyBldmVudC5cbiAgICAgIC8vIFRoaXMgbWF0Y2hlcyB0aGUgcHJvcGVydHkgb2YgbmF0aXZlIENvbXBvc2l0aW9uRXZlbnRJbnRlcmZhY2UuXG4gICAgICBldmVudC5kYXRhID0gZmFsbGJhY2tEYXRhO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgY3VzdG9tRGF0YSA9IGdldERhdGFGcm9tQ3VzdG9tRXZlbnQobmF0aXZlRXZlbnQpO1xuXG4gICAgICBpZiAoY3VzdG9tRGF0YSAhPT0gbnVsbCkge1xuICAgICAgICBldmVudC5kYXRhID0gY3VzdG9tRGF0YTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0TmF0aXZlQmVmb3JlSW5wdXRDaGFycyhkb21FdmVudE5hbWUsIG5hdGl2ZUV2ZW50KSB7XG4gIHN3aXRjaCAoZG9tRXZlbnROYW1lKSB7XG4gICAgY2FzZSAnY29tcG9zaXRpb25lbmQnOlxuICAgICAgcmV0dXJuIGdldERhdGFGcm9tQ3VzdG9tRXZlbnQobmF0aXZlRXZlbnQpO1xuXG4gICAgY2FzZSAna2V5cHJlc3MnOlxuICAgICAgLyoqXG4gICAgICAgKiBJZiBuYXRpdmUgYHRleHRJbnB1dGAgZXZlbnRzIGFyZSBhdmFpbGFibGUsIG91ciBnb2FsIGlzIHRvIG1ha2VcbiAgICAgICAqIHVzZSBvZiB0aGVtLiBIb3dldmVyLCB0aGVyZSBpcyBhIHNwZWNpYWwgY2FzZTogdGhlIHNwYWNlYmFyIGtleS5cbiAgICAgICAqIEluIFdlYmtpdCwgcHJldmVudGluZyBkZWZhdWx0IG9uIGEgc3BhY2ViYXIgYHRleHRJbnB1dGAgZXZlbnRcbiAgICAgICAqIGNhbmNlbHMgY2hhcmFjdGVyIGluc2VydGlvbiwgYnV0IGl0ICphbHNvKiBjYXVzZXMgdGhlIGJyb3dzZXJcbiAgICAgICAqIHRvIGZhbGwgYmFjayB0byBpdHMgZGVmYXVsdCBzcGFjZWJhciBiZWhhdmlvciBvZiBzY3JvbGxpbmcgdGhlXG4gICAgICAgKiBwYWdlLlxuICAgICAgICpcbiAgICAgICAqIFRyYWNraW5nIGF0OlxuICAgICAgICogaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTM1NTEwM1xuICAgICAgICpcbiAgICAgICAqIFRvIGF2b2lkIHRoaXMgaXNzdWUsIHVzZSB0aGUga2V5cHJlc3MgZXZlbnQgYXMgaWYgbm8gYHRleHRJbnB1dGBcbiAgICAgICAqIGV2ZW50IGlzIGF2YWlsYWJsZS5cbiAgICAgICAqL1xuICAgICAgdmFyIHdoaWNoID0gbmF0aXZlRXZlbnQud2hpY2g7XG5cbiAgICAgIGlmICh3aGljaCAhPT0gU1BBQ0VCQVJfQ09ERSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgaGFzU3BhY2VLZXlwcmVzcyA9IHRydWU7XG4gICAgICByZXR1cm4gU1BBQ0VCQVJfQ0hBUjtcblxuICAgIGNhc2UgJ3RleHRJbnB1dCc6XG4gICAgICAvLyBSZWNvcmQgdGhlIGNoYXJhY3RlcnMgdG8gYmUgYWRkZWQgdG8gdGhlIERPTS5cbiAgICAgIHZhciBjaGFycyA9IG5hdGl2ZUV2ZW50LmRhdGE7IC8vIElmIGl0J3MgYSBzcGFjZWJhciBjaGFyYWN0ZXIsIGFzc3VtZSB0aGF0IHdlIGhhdmUgYWxyZWFkeSBoYW5kbGVkXG4gICAgICAvLyBpdCBhdCB0aGUga2V5cHJlc3MgbGV2ZWwgYW5kIGJhaWwgaW1tZWRpYXRlbHkuIEFuZHJvaWQgQ2hyb21lXG4gICAgICAvLyBkb2Vzbid0IGdpdmUgdXMga2V5Y29kZXMsIHNvIHdlIG5lZWQgdG8gaWdub3JlIGl0LlxuXG4gICAgICBpZiAoY2hhcnMgPT09IFNQQUNFQkFSX0NIQVIgJiYgaGFzU3BhY2VLZXlwcmVzcykge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNoYXJzO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIC8vIEZvciBvdGhlciBuYXRpdmUgZXZlbnQgdHlwZXMsIGRvIG5vdGhpbmcuXG4gICAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuLyoqXG4gKiBGb3IgYnJvd3NlcnMgdGhhdCBkbyBub3QgcHJvdmlkZSB0aGUgYHRleHRJbnB1dGAgZXZlbnQsIGV4dHJhY3QgdGhlXG4gKiBhcHByb3ByaWF0ZSBzdHJpbmcgdG8gdXNlIGZvciBTeW50aGV0aWNJbnB1dEV2ZW50LlxuICovXG5cblxuZnVuY3Rpb24gZ2V0RmFsbGJhY2tCZWZvcmVJbnB1dENoYXJzKGRvbUV2ZW50TmFtZSwgbmF0aXZlRXZlbnQpIHtcbiAgLy8gSWYgd2UgYXJlIGN1cnJlbnRseSBjb21wb3NpbmcgKElNRSkgYW5kIHVzaW5nIGEgZmFsbGJhY2sgdG8gZG8gc28sXG4gIC8vIHRyeSB0byBleHRyYWN0IHRoZSBjb21wb3NlZCBjaGFyYWN0ZXJzIGZyb20gdGhlIGZhbGxiYWNrIG9iamVjdC5cbiAgLy8gSWYgY29tcG9zaXRpb24gZXZlbnQgaXMgYXZhaWxhYmxlLCB3ZSBleHRyYWN0IGEgc3RyaW5nIG9ubHkgYXRcbiAgLy8gY29tcG9zaXRpb25ldmVudCwgb3RoZXJ3aXNlIGV4dHJhY3QgaXQgYXQgZmFsbGJhY2sgZXZlbnRzLlxuICBpZiAoaXNDb21wb3NpbmcpIHtcbiAgICBpZiAoZG9tRXZlbnROYW1lID09PSAnY29tcG9zaXRpb25lbmQnIHx8ICFjYW5Vc2VDb21wb3NpdGlvbkV2ZW50ICYmIGlzRmFsbGJhY2tDb21wb3NpdGlvbkVuZChkb21FdmVudE5hbWUsIG5hdGl2ZUV2ZW50KSkge1xuICAgICAgdmFyIGNoYXJzID0gZ2V0RGF0YSgpO1xuICAgICAgcmVzZXQoKTtcbiAgICAgIGlzQ29tcG9zaW5nID0gZmFsc2U7XG4gICAgICByZXR1cm4gY2hhcnM7XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBzd2l0Y2ggKGRvbUV2ZW50TmFtZSkge1xuICAgIGNhc2UgJ3Bhc3RlJzpcbiAgICAgIC8vIElmIGEgcGFzdGUgZXZlbnQgb2NjdXJzIGFmdGVyIGEga2V5cHJlc3MsIHRocm93IG91dCB0aGUgaW5wdXRcbiAgICAgIC8vIGNoYXJzLiBQYXN0ZSBldmVudHMgc2hvdWxkIG5vdCBsZWFkIHRvIEJlZm9yZUlucHV0IGV2ZW50cy5cbiAgICAgIHJldHVybiBudWxsO1xuXG4gICAgY2FzZSAna2V5cHJlc3MnOlxuICAgICAgLyoqXG4gICAgICAgKiBBcyBvZiB2MjcsIEZpcmVmb3ggbWF5IGZpcmUga2V5cHJlc3MgZXZlbnRzIGV2ZW4gd2hlbiBubyBjaGFyYWN0ZXJcbiAgICAgICAqIHdpbGwgYmUgaW5zZXJ0ZWQuIEEgZmV3IHBvc3NpYmlsaXRpZXM6XG4gICAgICAgKlxuICAgICAgICogLSBgd2hpY2hgIGlzIGAwYC4gQXJyb3cga2V5cywgRXNjIGtleSwgZXRjLlxuICAgICAgICpcbiAgICAgICAqIC0gYHdoaWNoYCBpcyB0aGUgcHJlc3NlZCBrZXkgY29kZSwgYnV0IG5vIGNoYXIgaXMgYXZhaWxhYmxlLlxuICAgICAgICogICBFeDogJ0FsdEdyICsgZGAgaW4gUG9saXNoLiBUaGVyZSBpcyBubyBtb2RpZmllZCBjaGFyYWN0ZXIgZm9yXG4gICAgICAgKiAgIHRoaXMga2V5IGNvbWJpbmF0aW9uIGFuZCBubyBjaGFyYWN0ZXIgaXMgaW5zZXJ0ZWQgaW50byB0aGVcbiAgICAgICAqICAgZG9jdW1lbnQsIGJ1dCBGRiBmaXJlcyB0aGUga2V5cHJlc3MgZm9yIGNoYXIgY29kZSBgMTAwYCBhbnl3YXkuXG4gICAgICAgKiAgIE5vIGBpbnB1dGAgZXZlbnQgd2lsbCBvY2N1ci5cbiAgICAgICAqXG4gICAgICAgKiAtIGB3aGljaGAgaXMgdGhlIHByZXNzZWQga2V5IGNvZGUsIGJ1dCBhIGNvbW1hbmQgY29tYmluYXRpb24gaXNcbiAgICAgICAqICAgYmVpbmcgdXNlZC4gRXg6IGBDbWQrQ2AuIE5vIGNoYXJhY3RlciBpcyBpbnNlcnRlZCwgYW5kIG5vXG4gICAgICAgKiAgIGBpbnB1dGAgZXZlbnQgd2lsbCBvY2N1ci5cbiAgICAgICAqL1xuICAgICAgaWYgKCFpc0tleXByZXNzQ29tbWFuZChuYXRpdmVFdmVudCkpIHtcbiAgICAgICAgLy8gSUUgZmlyZXMgdGhlIGBrZXlwcmVzc2AgZXZlbnQgd2hlbiBhIHVzZXIgdHlwZXMgYW4gZW1vamkgdmlhXG4gICAgICAgIC8vIFRvdWNoIGtleWJvYXJkIG9mIFdpbmRvd3MuICBJbiBzdWNoIGEgY2FzZSwgdGhlIGBjaGFyYCBwcm9wZXJ0eVxuICAgICAgICAvLyBob2xkcyBhbiBlbW9qaSBjaGFyYWN0ZXIgbGlrZSBgXFx1RDgzRFxcdURFMEFgLiAgQmVjYXVzZSBpdHMgbGVuZ3RoXG4gICAgICAgIC8vIGlzIDIsIHRoZSBwcm9wZXJ0eSBgd2hpY2hgIGRvZXMgbm90IHJlcHJlc2VudCBhbiBlbW9qaSBjb3JyZWN0bHkuXG4gICAgICAgIC8vIEluIHN1Y2ggYSBjYXNlLCB3ZSBkaXJlY3RseSByZXR1cm4gdGhlIGBjaGFyYCBwcm9wZXJ0eSBpbnN0ZWFkIG9mXG4gICAgICAgIC8vIHVzaW5nIGB3aGljaGAuXG4gICAgICAgIGlmIChuYXRpdmVFdmVudC5jaGFyICYmIG5hdGl2ZUV2ZW50LmNoYXIubGVuZ3RoID4gMSkge1xuICAgICAgICAgIHJldHVybiBuYXRpdmVFdmVudC5jaGFyO1xuICAgICAgICB9IGVsc2UgaWYgKG5hdGl2ZUV2ZW50LndoaWNoKSB7XG4gICAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUobmF0aXZlRXZlbnQud2hpY2gpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBudWxsO1xuXG4gICAgY2FzZSAnY29tcG9zaXRpb25lbmQnOlxuICAgICAgcmV0dXJuIHVzZUZhbGxiYWNrQ29tcG9zaXRpb25EYXRhICYmICFpc1VzaW5nS29yZWFuSU1FKG5hdGl2ZUV2ZW50KSA/IG51bGwgOiBuYXRpdmVFdmVudC5kYXRhO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBudWxsO1xuICB9XG59XG4vKipcbiAqIEV4dHJhY3QgYSBTeW50aGV0aWNJbnB1dEV2ZW50IGZvciBgYmVmb3JlSW5wdXRgLCBiYXNlZCBvbiBlaXRoZXIgbmF0aXZlXG4gKiBgdGV4dElucHV0YCBvciBmYWxsYmFjayBiZWhhdmlvci5cbiAqXG4gKiBAcmV0dXJuIHs/b2JqZWN0fSBBIFN5bnRoZXRpY0lucHV0RXZlbnQuXG4gKi9cblxuXG5mdW5jdGlvbiBleHRyYWN0QmVmb3JlSW5wdXRFdmVudChkaXNwYXRjaFF1ZXVlLCBkb21FdmVudE5hbWUsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICB2YXIgY2hhcnM7XG5cbiAgaWYgKGNhblVzZVRleHRJbnB1dEV2ZW50KSB7XG4gICAgY2hhcnMgPSBnZXROYXRpdmVCZWZvcmVJbnB1dENoYXJzKGRvbUV2ZW50TmFtZSwgbmF0aXZlRXZlbnQpO1xuICB9IGVsc2Uge1xuICAgIGNoYXJzID0gZ2V0RmFsbGJhY2tCZWZvcmVJbnB1dENoYXJzKGRvbUV2ZW50TmFtZSwgbmF0aXZlRXZlbnQpO1xuICB9IC8vIElmIG5vIGNoYXJhY3RlcnMgYXJlIGJlaW5nIGluc2VydGVkLCBubyBCZWZvcmVJbnB1dCBldmVudCBzaG91bGRcbiAgLy8gYmUgZmlyZWQuXG5cblxuICBpZiAoIWNoYXJzKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgbGlzdGVuZXJzID0gYWNjdW11bGF0ZVR3b1BoYXNlTGlzdGVuZXJzKHRhcmdldEluc3QsICdvbkJlZm9yZUlucHV0Jyk7XG5cbiAgaWYgKGxpc3RlbmVycy5sZW5ndGggPiAwKSB7XG4gICAgdmFyIGV2ZW50ID0gbmV3IFN5bnRoZXRpY0lucHV0RXZlbnQoJ29uQmVmb3JlSW5wdXQnLCAnYmVmb3JlaW5wdXQnLCBudWxsLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xuICAgIGRpc3BhdGNoUXVldWUucHVzaCh7XG4gICAgICBldmVudDogZXZlbnQsXG4gICAgICBsaXN0ZW5lcnM6IGxpc3RlbmVyc1xuICAgIH0pO1xuICAgIGV2ZW50LmRhdGEgPSBjaGFycztcbiAgfVxufVxuLyoqXG4gKiBDcmVhdGUgYW4gYG9uQmVmb3JlSW5wdXRgIGV2ZW50IHRvIG1hdGNoXG4gKiBodHRwOi8vd3d3LnczLm9yZy9UUi8yMDEzL1dELURPTS1MZXZlbC0zLUV2ZW50cy0yMDEzMTEwNS8jZXZlbnRzLWlucHV0ZXZlbnRzLlxuICpcbiAqIFRoaXMgZXZlbnQgcGx1Z2luIGlzIGJhc2VkIG9uIHRoZSBuYXRpdmUgYHRleHRJbnB1dGAgZXZlbnRcbiAqIGF2YWlsYWJsZSBpbiBDaHJvbWUsIFNhZmFyaSwgT3BlcmEsIGFuZCBJRS4gVGhpcyBldmVudCBmaXJlcyBhZnRlclxuICogYG9uS2V5UHJlc3NgIGFuZCBgb25Db21wb3NpdGlvbkVuZGAsIGJ1dCBiZWZvcmUgYG9uSW5wdXRgLlxuICpcbiAqIGBiZWZvcmVJbnB1dGAgaXMgc3BlYydkIGJ1dCBub3QgaW1wbGVtZW50ZWQgaW4gYW55IGJyb3dzZXJzLCBhbmRcbiAqIHRoZSBgaW5wdXRgIGV2ZW50IGRvZXMgbm90IHByb3ZpZGUgYW55IHVzZWZ1bCBpbmZvcm1hdGlvbiBhYm91dCB3aGF0IGhhc1xuICogYWN0dWFsbHkgYmVlbiBhZGRlZCwgY29udHJhcnkgdG8gdGhlIHNwZWMuIFRodXMsIGB0ZXh0SW5wdXRgIGlzIHRoZSBiZXN0XG4gKiBhdmFpbGFibGUgZXZlbnQgdG8gaWRlbnRpZnkgdGhlIGNoYXJhY3RlcnMgdGhhdCBoYXZlIGFjdHVhbGx5IGJlZW4gaW5zZXJ0ZWRcbiAqIGludG8gdGhlIHRhcmdldCBub2RlLlxuICpcbiAqIFRoaXMgcGx1Z2luIGlzIGFsc28gcmVzcG9uc2libGUgZm9yIGVtaXR0aW5nIGBjb21wb3NpdGlvbmAgZXZlbnRzLCB0aHVzXG4gKiBhbGxvd2luZyB1cyB0byBzaGFyZSBjb21wb3NpdGlvbiBmYWxsYmFjayBjb2RlIGZvciBib3RoIGBiZWZvcmVJbnB1dGAgYW5kXG4gKiBgY29tcG9zaXRpb25gIGV2ZW50IHR5cGVzLlxuICovXG5cblxuZnVuY3Rpb24gZXh0cmFjdEV2ZW50cyhkaXNwYXRjaFF1ZXVlLCBkb21FdmVudE5hbWUsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCwgZXZlbnRTeXN0ZW1GbGFncywgdGFyZ2V0Q29udGFpbmVyKSB7XG4gIGV4dHJhY3RDb21wb3NpdGlvbkV2ZW50KGRpc3BhdGNoUXVldWUsIGRvbUV2ZW50TmFtZSwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbiAgZXh0cmFjdEJlZm9yZUlucHV0RXZlbnQoZGlzcGF0Y2hRdWV1ZSwgZG9tRXZlbnROYW1lLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xufVxuXG4vKipcbiAqIEBzZWUgaHR0cDovL3d3dy53aGF0d2cub3JnL3NwZWNzL3dlYi1hcHBzL2N1cnJlbnQtd29yay9tdWx0aXBhZ2UvdGhlLWlucHV0LWVsZW1lbnQuaHRtbCNpbnB1dC10eXBlLWF0dHItc3VtbWFyeVxuICovXG52YXIgc3VwcG9ydGVkSW5wdXRUeXBlcyA9IHtcbiAgY29sb3I6IHRydWUsXG4gIGRhdGU6IHRydWUsXG4gIGRhdGV0aW1lOiB0cnVlLFxuICAnZGF0ZXRpbWUtbG9jYWwnOiB0cnVlLFxuICBlbWFpbDogdHJ1ZSxcbiAgbW9udGg6IHRydWUsXG4gIG51bWJlcjogdHJ1ZSxcbiAgcGFzc3dvcmQ6IHRydWUsXG4gIHJhbmdlOiB0cnVlLFxuICBzZWFyY2g6IHRydWUsXG4gIHRlbDogdHJ1ZSxcbiAgdGV4dDogdHJ1ZSxcbiAgdGltZTogdHJ1ZSxcbiAgdXJsOiB0cnVlLFxuICB3ZWVrOiB0cnVlXG59O1xuXG5mdW5jdGlvbiBpc1RleHRJbnB1dEVsZW1lbnQoZWxlbSkge1xuICB2YXIgbm9kZU5hbWUgPSBlbGVtICYmIGVsZW0ubm9kZU5hbWUgJiYgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuXG4gIGlmIChub2RlTmFtZSA9PT0gJ2lucHV0Jykge1xuICAgIHJldHVybiAhIXN1cHBvcnRlZElucHV0VHlwZXNbZWxlbS50eXBlXTtcbiAgfVxuXG4gIGlmIChub2RlTmFtZSA9PT0gJ3RleHRhcmVhJykge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBhbiBldmVudCBpcyBzdXBwb3J0ZWQgaW4gdGhlIGN1cnJlbnQgZXhlY3V0aW9uIGVudmlyb25tZW50LlxuICpcbiAqIE5PVEU6IFRoaXMgd2lsbCBub3Qgd29yayBjb3JyZWN0bHkgZm9yIG5vbi1nZW5lcmljIGV2ZW50cyBzdWNoIGFzIGBjaGFuZ2VgLFxuICogYHJlc2V0YCwgYGxvYWRgLCBgZXJyb3JgLCBhbmQgYHNlbGVjdGAuXG4gKlxuICogQm9ycm93cyBmcm9tIE1vZGVybml6ci5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lU3VmZml4IEV2ZW50IG5hbWUsIGUuZy4gXCJjbGlja1wiLlxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgZXZlbnQgaXMgc3VwcG9ydGVkLlxuICogQGludGVybmFsXG4gKiBAbGljZW5zZSBNb2Rlcm5penIgMy4wLjBwcmUgKEN1c3RvbSBCdWlsZCkgfCBNSVRcbiAqL1xuXG5mdW5jdGlvbiBpc0V2ZW50U3VwcG9ydGVkKGV2ZW50TmFtZVN1ZmZpeCkge1xuICBpZiAoIWNhblVzZURPTSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBldmVudE5hbWUgPSAnb24nICsgZXZlbnROYW1lU3VmZml4O1xuICB2YXIgaXNTdXBwb3J0ZWQgPSAoZXZlbnROYW1lIGluIGRvY3VtZW50KTtcblxuICBpZiAoIWlzU3VwcG9ydGVkKSB7XG4gICAgdmFyIGVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBlbGVtZW50LnNldEF0dHJpYnV0ZShldmVudE5hbWUsICdyZXR1cm47Jyk7XG4gICAgaXNTdXBwb3J0ZWQgPSB0eXBlb2YgZWxlbWVudFtldmVudE5hbWVdID09PSAnZnVuY3Rpb24nO1xuICB9XG5cbiAgcmV0dXJuIGlzU3VwcG9ydGVkO1xufVxuXG5mdW5jdGlvbiByZWdpc3RlckV2ZW50cyQxKCkge1xuICByZWdpc3RlclR3b1BoYXNlRXZlbnQoJ29uQ2hhbmdlJywgWydjaGFuZ2UnLCAnY2xpY2snLCAnZm9jdXNpbicsICdmb2N1c291dCcsICdpbnB1dCcsICdrZXlkb3duJywgJ2tleXVwJywgJ3NlbGVjdGlvbmNoYW5nZSddKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlQW5kQWNjdW11bGF0ZUNoYW5nZUV2ZW50KGRpc3BhdGNoUXVldWUsIGluc3QsIG5hdGl2ZUV2ZW50LCB0YXJnZXQpIHtcbiAgLy8gRmxhZyB0aGlzIGV2ZW50IGxvb3AgYXMgbmVlZGluZyBzdGF0ZSByZXN0b3JlLlxuICBlbnF1ZXVlU3RhdGVSZXN0b3JlKHRhcmdldCk7XG4gIHZhciBsaXN0ZW5lcnMgPSBhY2N1bXVsYXRlVHdvUGhhc2VMaXN0ZW5lcnMoaW5zdCwgJ29uQ2hhbmdlJyk7XG5cbiAgaWYgKGxpc3RlbmVycy5sZW5ndGggPiAwKSB7XG4gICAgdmFyIGV2ZW50ID0gbmV3IFN5bnRoZXRpY0V2ZW50KCdvbkNoYW5nZScsICdjaGFuZ2UnLCBudWxsLCBuYXRpdmVFdmVudCwgdGFyZ2V0KTtcbiAgICBkaXNwYXRjaFF1ZXVlLnB1c2goe1xuICAgICAgZXZlbnQ6IGV2ZW50LFxuICAgICAgbGlzdGVuZXJzOiBsaXN0ZW5lcnNcbiAgICB9KTtcbiAgfVxufVxuLyoqXG4gKiBGb3IgSUUgc2hpbXNcbiAqL1xuXG5cbnZhciBhY3RpdmVFbGVtZW50ID0gbnVsbDtcbnZhciBhY3RpdmVFbGVtZW50SW5zdCA9IG51bGw7XG4vKipcbiAqIFNFQ1RJT046IGhhbmRsZSBgY2hhbmdlYCBldmVudFxuICovXG5cbmZ1bmN0aW9uIHNob3VsZFVzZUNoYW5nZUV2ZW50KGVsZW0pIHtcbiAgdmFyIG5vZGVOYW1lID0gZWxlbS5ub2RlTmFtZSAmJiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG4gIHJldHVybiBub2RlTmFtZSA9PT0gJ3NlbGVjdCcgfHwgbm9kZU5hbWUgPT09ICdpbnB1dCcgJiYgZWxlbS50eXBlID09PSAnZmlsZSc7XG59XG5cbmZ1bmN0aW9uIG1hbnVhbERpc3BhdGNoQ2hhbmdlRXZlbnQobmF0aXZlRXZlbnQpIHtcbiAgdmFyIGRpc3BhdGNoUXVldWUgPSBbXTtcbiAgY3JlYXRlQW5kQWNjdW11bGF0ZUNoYW5nZUV2ZW50KGRpc3BhdGNoUXVldWUsIGFjdGl2ZUVsZW1lbnRJbnN0LCBuYXRpdmVFdmVudCwgZ2V0RXZlbnRUYXJnZXQobmF0aXZlRXZlbnQpKTsgLy8gSWYgY2hhbmdlIGFuZCBwcm9wZXJ0eWNoYW5nZSBidWJibGVkLCB3ZSdkIGp1c3QgYmluZCB0byBpdCBsaWtlIGFsbCB0aGVcbiAgLy8gb3RoZXIgZXZlbnRzIGFuZCBoYXZlIGl0IGdvIHRocm91Z2ggUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLiBTaW5jZSBpdFxuICAvLyBkb2Vzbid0LCB3ZSBtYW51YWxseSBsaXN0ZW4gZm9yIHRoZSBldmVudHMgYW5kIHNvIHdlIGhhdmUgdG8gZW5xdWV1ZSBhbmRcbiAgLy8gcHJvY2VzcyB0aGUgYWJzdHJhY3QgZXZlbnQgbWFudWFsbHkuXG4gIC8vXG4gIC8vIEJhdGNoaW5nIGlzIG5lY2Vzc2FyeSBoZXJlIGluIG9yZGVyIHRvIGVuc3VyZSB0aGF0IGFsbCBldmVudCBoYW5kbGVycyBydW5cbiAgLy8gYmVmb3JlIHRoZSBuZXh0IHJlcmVuZGVyIChpbmNsdWRpbmcgZXZlbnQgaGFuZGxlcnMgYXR0YWNoZWQgdG8gYW5jZXN0b3JcbiAgLy8gZWxlbWVudHMgaW5zdGVhZCBvZiBkaXJlY3RseSBvbiB0aGUgaW5wdXQpLiBXaXRob3V0IHRoaXMsIGNvbnRyb2xsZWRcbiAgLy8gY29tcG9uZW50cyBkb24ndCB3b3JrIHByb3Blcmx5IGluIGNvbmp1bmN0aW9uIHdpdGggZXZlbnQgYnViYmxpbmcgYmVjYXVzZVxuICAvLyB0aGUgY29tcG9uZW50IGlzIHJlcmVuZGVyZWQgYW5kIHRoZSB2YWx1ZSByZXZlcnRlZCBiZWZvcmUgYWxsIHRoZSBldmVudFxuICAvLyBoYW5kbGVycyBjYW4gcnVuLiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy83MDguXG5cbiAgYmF0Y2hlZFVwZGF0ZXMocnVuRXZlbnRJbkJhdGNoLCBkaXNwYXRjaFF1ZXVlKTtcbn1cblxuZnVuY3Rpb24gcnVuRXZlbnRJbkJhdGNoKGRpc3BhdGNoUXVldWUpIHtcbiAgcHJvY2Vzc0Rpc3BhdGNoUXVldWUoZGlzcGF0Y2hRdWV1ZSwgMCk7XG59XG5cbmZ1bmN0aW9uIGdldEluc3RJZlZhbHVlQ2hhbmdlZCh0YXJnZXRJbnN0KSB7XG4gIHZhciB0YXJnZXROb2RlID0gZ2V0Tm9kZUZyb21JbnN0YW5jZSh0YXJnZXRJbnN0KTtcblxuICBpZiAodXBkYXRlVmFsdWVJZkNoYW5nZWQodGFyZ2V0Tm9kZSkpIHtcbiAgICByZXR1cm4gdGFyZ2V0SW5zdDtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRUYXJnZXRJbnN0Rm9yQ2hhbmdlRXZlbnQoZG9tRXZlbnROYW1lLCB0YXJnZXRJbnN0KSB7XG4gIGlmIChkb21FdmVudE5hbWUgPT09ICdjaGFuZ2UnKSB7XG4gICAgcmV0dXJuIHRhcmdldEluc3Q7XG4gIH1cbn1cbi8qKlxuICogU0VDVElPTjogaGFuZGxlIGBpbnB1dGAgZXZlbnRcbiAqL1xuXG5cbnZhciBpc0lucHV0RXZlbnRTdXBwb3J0ZWQgPSBmYWxzZTtcblxuaWYgKGNhblVzZURPTSkge1xuICAvLyBJRTkgY2xhaW1zIHRvIHN1cHBvcnQgdGhlIGlucHV0IGV2ZW50IGJ1dCBmYWlscyB0byB0cmlnZ2VyIGl0IHdoZW5cbiAgLy8gZGVsZXRpbmcgdGV4dCwgc28gd2UgaWdub3JlIGl0cyBpbnB1dCBldmVudHMuXG4gIGlzSW5wdXRFdmVudFN1cHBvcnRlZCA9IGlzRXZlbnRTdXBwb3J0ZWQoJ2lucHV0JykgJiYgKCFkb2N1bWVudC5kb2N1bWVudE1vZGUgfHwgZG9jdW1lbnQuZG9jdW1lbnRNb2RlID4gOSk7XG59XG4vKipcbiAqIChGb3IgSUUgPD05KSBTdGFydHMgdHJhY2tpbmcgcHJvcGVydHljaGFuZ2UgZXZlbnRzIG9uIHRoZSBwYXNzZWQtaW4gZWxlbWVudFxuICogYW5kIG92ZXJyaWRlIHRoZSB2YWx1ZSBwcm9wZXJ0eSBzbyB0aGF0IHdlIGNhbiBkaXN0aW5ndWlzaCB1c2VyIGV2ZW50cyBmcm9tXG4gKiB2YWx1ZSBjaGFuZ2VzIGluIEpTLlxuICovXG5cblxuZnVuY3Rpb24gc3RhcnRXYXRjaGluZ0ZvclZhbHVlQ2hhbmdlKHRhcmdldCwgdGFyZ2V0SW5zdCkge1xuICBhY3RpdmVFbGVtZW50ID0gdGFyZ2V0O1xuICBhY3RpdmVFbGVtZW50SW5zdCA9IHRhcmdldEluc3Q7XG4gIGFjdGl2ZUVsZW1lbnQuYXR0YWNoRXZlbnQoJ29ucHJvcGVydHljaGFuZ2UnLCBoYW5kbGVQcm9wZXJ0eUNoYW5nZSk7XG59XG4vKipcbiAqIChGb3IgSUUgPD05KSBSZW1vdmVzIHRoZSBldmVudCBsaXN0ZW5lcnMgZnJvbSB0aGUgY3VycmVudGx5LXRyYWNrZWQgZWxlbWVudCxcbiAqIGlmIGFueSBleGlzdHMuXG4gKi9cblxuXG5mdW5jdGlvbiBzdG9wV2F0Y2hpbmdGb3JWYWx1ZUNoYW5nZSgpIHtcbiAgaWYgKCFhY3RpdmVFbGVtZW50KSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgYWN0aXZlRWxlbWVudC5kZXRhY2hFdmVudCgnb25wcm9wZXJ0eWNoYW5nZScsIGhhbmRsZVByb3BlcnR5Q2hhbmdlKTtcbiAgYWN0aXZlRWxlbWVudCA9IG51bGw7XG4gIGFjdGl2ZUVsZW1lbnRJbnN0ID0gbnVsbDtcbn1cbi8qKlxuICogKEZvciBJRSA8PTkpIEhhbmRsZXMgYSBwcm9wZXJ0eWNoYW5nZSBldmVudCwgc2VuZGluZyBhIGBjaGFuZ2VgIGV2ZW50IGlmXG4gKiB0aGUgdmFsdWUgb2YgdGhlIGFjdGl2ZSBlbGVtZW50IGhhcyBjaGFuZ2VkLlxuICovXG5cblxuZnVuY3Rpb24gaGFuZGxlUHJvcGVydHlDaGFuZ2UobmF0aXZlRXZlbnQpIHtcbiAgaWYgKG5hdGl2ZUV2ZW50LnByb3BlcnR5TmFtZSAhPT0gJ3ZhbHVlJykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChnZXRJbnN0SWZWYWx1ZUNoYW5nZWQoYWN0aXZlRWxlbWVudEluc3QpKSB7XG4gICAgbWFudWFsRGlzcGF0Y2hDaGFuZ2VFdmVudChuYXRpdmVFdmVudCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaGFuZGxlRXZlbnRzRm9ySW5wdXRFdmVudFBvbHlmaWxsKGRvbUV2ZW50TmFtZSwgdGFyZ2V0LCB0YXJnZXRJbnN0KSB7XG4gIGlmIChkb21FdmVudE5hbWUgPT09ICdmb2N1c2luJykge1xuICAgIC8vIEluIElFOSwgcHJvcGVydHljaGFuZ2UgZmlyZXMgZm9yIG1vc3QgaW5wdXQgZXZlbnRzIGJ1dCBpcyBidWdneSBhbmRcbiAgICAvLyBkb2Vzbid0IGZpcmUgd2hlbiB0ZXh0IGlzIGRlbGV0ZWQsIGJ1dCBjb252ZW5pZW50bHksIHNlbGVjdGlvbmNoYW5nZVxuICAgIC8vIGFwcGVhcnMgdG8gZmlyZSBpbiBhbGwgb2YgdGhlIHJlbWFpbmluZyBjYXNlcyBzbyB3ZSBjYXRjaCB0aG9zZSBhbmRcbiAgICAvLyBmb3J3YXJkIHRoZSBldmVudCBpZiB0aGUgdmFsdWUgaGFzIGNoYW5nZWRcbiAgICAvLyBJbiBlaXRoZXIgY2FzZSwgd2UgZG9uJ3Qgd2FudCB0byBjYWxsIHRoZSBldmVudCBoYW5kbGVyIGlmIHRoZSB2YWx1ZVxuICAgIC8vIGlzIGNoYW5nZWQgZnJvbSBKUyBzbyB3ZSByZWRlZmluZSBhIHNldHRlciBmb3IgYC52YWx1ZWAgdGhhdCB1cGRhdGVzXG4gICAgLy8gb3VyIGFjdGl2ZUVsZW1lbnRWYWx1ZSB2YXJpYWJsZSwgYWxsb3dpbmcgdXMgdG8gaWdub3JlIHRob3NlIGNoYW5nZXNcbiAgICAvL1xuICAgIC8vIHN0b3BXYXRjaGluZygpIHNob3VsZCBiZSBhIG5vb3AgaGVyZSBidXQgd2UgY2FsbCBpdCBqdXN0IGluIGNhc2Ugd2VcbiAgICAvLyBtaXNzZWQgYSBibHVyIGV2ZW50IHNvbWVob3cuXG4gICAgc3RvcFdhdGNoaW5nRm9yVmFsdWVDaGFuZ2UoKTtcbiAgICBzdGFydFdhdGNoaW5nRm9yVmFsdWVDaGFuZ2UodGFyZ2V0LCB0YXJnZXRJbnN0KTtcbiAgfSBlbHNlIGlmIChkb21FdmVudE5hbWUgPT09ICdmb2N1c291dCcpIHtcbiAgICBzdG9wV2F0Y2hpbmdGb3JWYWx1ZUNoYW5nZSgpO1xuICB9XG59IC8vIEZvciBJRTggYW5kIElFOS5cblxuXG5mdW5jdGlvbiBnZXRUYXJnZXRJbnN0Rm9ySW5wdXRFdmVudFBvbHlmaWxsKGRvbUV2ZW50TmFtZSwgdGFyZ2V0SW5zdCkge1xuICBpZiAoZG9tRXZlbnROYW1lID09PSAnc2VsZWN0aW9uY2hhbmdlJyB8fCBkb21FdmVudE5hbWUgPT09ICdrZXl1cCcgfHwgZG9tRXZlbnROYW1lID09PSAna2V5ZG93bicpIHtcbiAgICAvLyBPbiB0aGUgc2VsZWN0aW9uY2hhbmdlIGV2ZW50LCB0aGUgdGFyZ2V0IGlzIGp1c3QgZG9jdW1lbnQgd2hpY2ggaXNuJ3RcbiAgICAvLyBoZWxwZnVsIGZvciB1cyBzbyBqdXN0IGNoZWNrIGFjdGl2ZUVsZW1lbnQgaW5zdGVhZC5cbiAgICAvL1xuICAgIC8vIDk5JSBvZiB0aGUgdGltZSwga2V5ZG93biBhbmQga2V5dXAgYXJlbid0IG5lY2Vzc2FyeS4gSUU4IGZhaWxzIHRvIGZpcmVcbiAgICAvLyBwcm9wZXJ0eWNoYW5nZSBvbiB0aGUgZmlyc3QgaW5wdXQgZXZlbnQgYWZ0ZXIgc2V0dGluZyBgdmFsdWVgIGZyb20gYVxuICAgIC8vIHNjcmlwdCBhbmQgZmlyZXMgb25seSBrZXlkb3duLCBrZXlwcmVzcywga2V5dXAuIENhdGNoaW5nIGtleXVwIHVzdWFsbHlcbiAgICAvLyBnZXRzIGl0IGFuZCBjYXRjaGluZyBrZXlkb3duIGxldHMgdXMgZmlyZSBhbiBldmVudCBmb3IgdGhlIGZpcnN0XG4gICAgLy8ga2V5c3Ryb2tlIGlmIHVzZXIgZG9lcyBhIGtleSByZXBlYXQgKGl0J2xsIGJlIGEgbGl0dGxlIGRlbGF5ZWQ6IHJpZ2h0XG4gICAgLy8gYmVmb3JlIHRoZSBzZWNvbmQga2V5c3Ryb2tlKS4gT3RoZXIgaW5wdXQgbWV0aG9kcyAoZS5nLiwgcGFzdGUpIHNlZW0gdG9cbiAgICAvLyBmaXJlIHNlbGVjdGlvbmNoYW5nZSBub3JtYWxseS5cbiAgICByZXR1cm4gZ2V0SW5zdElmVmFsdWVDaGFuZ2VkKGFjdGl2ZUVsZW1lbnRJbnN0KTtcbiAgfVxufVxuLyoqXG4gKiBTRUNUSU9OOiBoYW5kbGUgYGNsaWNrYCBldmVudFxuICovXG5cblxuZnVuY3Rpb24gc2hvdWxkVXNlQ2xpY2tFdmVudChlbGVtKSB7XG4gIC8vIFVzZSB0aGUgYGNsaWNrYCBldmVudCB0byBkZXRlY3QgY2hhbmdlcyB0byBjaGVja2JveCBhbmQgcmFkaW8gaW5wdXRzLlxuICAvLyBUaGlzIGFwcHJvYWNoIHdvcmtzIGFjcm9zcyBhbGwgYnJvd3NlcnMsIHdoZXJlYXMgYGNoYW5nZWAgZG9lcyBub3QgZmlyZVxuICAvLyB1bnRpbCBgYmx1cmAgaW4gSUU4LlxuICB2YXIgbm9kZU5hbWUgPSBlbGVtLm5vZGVOYW1lO1xuICByZXR1cm4gbm9kZU5hbWUgJiYgbm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ2lucHV0JyAmJiAoZWxlbS50eXBlID09PSAnY2hlY2tib3gnIHx8IGVsZW0udHlwZSA9PT0gJ3JhZGlvJyk7XG59XG5cbmZ1bmN0aW9uIGdldFRhcmdldEluc3RGb3JDbGlja0V2ZW50KGRvbUV2ZW50TmFtZSwgdGFyZ2V0SW5zdCkge1xuICBpZiAoZG9tRXZlbnROYW1lID09PSAnY2xpY2snKSB7XG4gICAgcmV0dXJuIGdldEluc3RJZlZhbHVlQ2hhbmdlZCh0YXJnZXRJbnN0KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRUYXJnZXRJbnN0Rm9ySW5wdXRPckNoYW5nZUV2ZW50KGRvbUV2ZW50TmFtZSwgdGFyZ2V0SW5zdCkge1xuICBpZiAoZG9tRXZlbnROYW1lID09PSAnaW5wdXQnIHx8IGRvbUV2ZW50TmFtZSA9PT0gJ2NoYW5nZScpIHtcbiAgICByZXR1cm4gZ2V0SW5zdElmVmFsdWVDaGFuZ2VkKHRhcmdldEluc3QpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGhhbmRsZUNvbnRyb2xsZWRJbnB1dEJsdXIobm9kZSkge1xuICB2YXIgc3RhdGUgPSBub2RlLl93cmFwcGVyU3RhdGU7XG5cbiAgaWYgKCFzdGF0ZSB8fCAhc3RhdGUuY29udHJvbGxlZCB8fCBub2RlLnR5cGUgIT09ICdudW1iZXInKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAge1xuICAgIC8vIElmIGNvbnRyb2xsZWQsIGFzc2lnbiB0aGUgdmFsdWUgYXR0cmlidXRlIHRvIHRoZSBjdXJyZW50IHZhbHVlIG9uIGJsdXJcbiAgICBzZXREZWZhdWx0VmFsdWUobm9kZSwgJ251bWJlcicsIG5vZGUudmFsdWUpO1xuICB9XG59XG4vKipcbiAqIFRoaXMgcGx1Z2luIGNyZWF0ZXMgYW4gYG9uQ2hhbmdlYCBldmVudCB0aGF0IG5vcm1hbGl6ZXMgY2hhbmdlIGV2ZW50c1xuICogYWNyb3NzIGZvcm0gZWxlbWVudHMuIFRoaXMgZXZlbnQgZmlyZXMgYXQgYSB0aW1lIHdoZW4gaXQncyBwb3NzaWJsZSB0b1xuICogY2hhbmdlIHRoZSBlbGVtZW50J3MgdmFsdWUgd2l0aG91dCBzZWVpbmcgYSBmbGlja2VyLlxuICpcbiAqIFN1cHBvcnRlZCBlbGVtZW50cyBhcmU6XG4gKiAtIGlucHV0IChzZWUgYGlzVGV4dElucHV0RWxlbWVudGApXG4gKiAtIHRleHRhcmVhXG4gKiAtIHNlbGVjdFxuICovXG5cblxuZnVuY3Rpb24gZXh0cmFjdEV2ZW50cyQxKGRpc3BhdGNoUXVldWUsIGRvbUV2ZW50TmFtZSwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0LCBldmVudFN5c3RlbUZsYWdzLCB0YXJnZXRDb250YWluZXIpIHtcbiAgdmFyIHRhcmdldE5vZGUgPSB0YXJnZXRJbnN0ID8gZ2V0Tm9kZUZyb21JbnN0YW5jZSh0YXJnZXRJbnN0KSA6IHdpbmRvdztcbiAgdmFyIGdldFRhcmdldEluc3RGdW5jLCBoYW5kbGVFdmVudEZ1bmM7XG5cbiAgaWYgKHNob3VsZFVzZUNoYW5nZUV2ZW50KHRhcmdldE5vZGUpKSB7XG4gICAgZ2V0VGFyZ2V0SW5zdEZ1bmMgPSBnZXRUYXJnZXRJbnN0Rm9yQ2hhbmdlRXZlbnQ7XG4gIH0gZWxzZSBpZiAoaXNUZXh0SW5wdXRFbGVtZW50KHRhcmdldE5vZGUpKSB7XG4gICAgaWYgKGlzSW5wdXRFdmVudFN1cHBvcnRlZCkge1xuICAgICAgZ2V0VGFyZ2V0SW5zdEZ1bmMgPSBnZXRUYXJnZXRJbnN0Rm9ySW5wdXRPckNoYW5nZUV2ZW50O1xuICAgIH0gZWxzZSB7XG4gICAgICBnZXRUYXJnZXRJbnN0RnVuYyA9IGdldFRhcmdldEluc3RGb3JJbnB1dEV2ZW50UG9seWZpbGw7XG4gICAgICBoYW5kbGVFdmVudEZ1bmMgPSBoYW5kbGVFdmVudHNGb3JJbnB1dEV2ZW50UG9seWZpbGw7XG4gICAgfVxuICB9IGVsc2UgaWYgKHNob3VsZFVzZUNsaWNrRXZlbnQodGFyZ2V0Tm9kZSkpIHtcbiAgICBnZXRUYXJnZXRJbnN0RnVuYyA9IGdldFRhcmdldEluc3RGb3JDbGlja0V2ZW50O1xuICB9XG5cbiAgaWYgKGdldFRhcmdldEluc3RGdW5jKSB7XG4gICAgdmFyIGluc3QgPSBnZXRUYXJnZXRJbnN0RnVuYyhkb21FdmVudE5hbWUsIHRhcmdldEluc3QpO1xuXG4gICAgaWYgKGluc3QpIHtcbiAgICAgIGNyZWF0ZUFuZEFjY3VtdWxhdGVDaGFuZ2VFdmVudChkaXNwYXRjaFF1ZXVlLCBpbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuXG4gIGlmIChoYW5kbGVFdmVudEZ1bmMpIHtcbiAgICBoYW5kbGVFdmVudEZ1bmMoZG9tRXZlbnROYW1lLCB0YXJnZXROb2RlLCB0YXJnZXRJbnN0KTtcbiAgfSAvLyBXaGVuIGJsdXJyaW5nLCBzZXQgdGhlIHZhbHVlIGF0dHJpYnV0ZSBmb3IgbnVtYmVyIGlucHV0c1xuXG5cbiAgaWYgKGRvbUV2ZW50TmFtZSA9PT0gJ2ZvY3Vzb3V0Jykge1xuICAgIGhhbmRsZUNvbnRyb2xsZWRJbnB1dEJsdXIodGFyZ2V0Tm9kZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVnaXN0ZXJFdmVudHMkMigpIHtcbiAgcmVnaXN0ZXJEaXJlY3RFdmVudCgnb25Nb3VzZUVudGVyJywgWydtb3VzZW91dCcsICdtb3VzZW92ZXInXSk7XG4gIHJlZ2lzdGVyRGlyZWN0RXZlbnQoJ29uTW91c2VMZWF2ZScsIFsnbW91c2VvdXQnLCAnbW91c2VvdmVyJ10pO1xuICByZWdpc3RlckRpcmVjdEV2ZW50KCdvblBvaW50ZXJFbnRlcicsIFsncG9pbnRlcm91dCcsICdwb2ludGVyb3ZlciddKTtcbiAgcmVnaXN0ZXJEaXJlY3RFdmVudCgnb25Qb2ludGVyTGVhdmUnLCBbJ3BvaW50ZXJvdXQnLCAncG9pbnRlcm92ZXInXSk7XG59XG4vKipcbiAqIEZvciBhbG1vc3QgZXZlcnkgaW50ZXJhY3Rpb24gd2UgY2FyZSBhYm91dCwgdGhlcmUgd2lsbCBiZSBib3RoIGEgdG9wLWxldmVsXG4gKiBgbW91c2VvdmVyYCBhbmQgYG1vdXNlb3V0YCBldmVudCB0aGF0IG9jY3Vycy4gT25seSB1c2UgYG1vdXNlb3V0YCBzbyB0aGF0XG4gKiB3ZSBkbyBub3QgZXh0cmFjdCBkdXBsaWNhdGUgZXZlbnRzLiBIb3dldmVyLCBtb3ZpbmcgdGhlIG1vdXNlIGludG8gdGhlXG4gKiBicm93c2VyIGZyb20gb3V0c2lkZSB3aWxsIG5vdCBmaXJlIGEgYG1vdXNlb3V0YCBldmVudC4gSW4gdGhpcyBjYXNlLCB3ZSB1c2VcbiAqIHRoZSBgbW91c2VvdmVyYCB0b3AtbGV2ZWwgZXZlbnQuXG4gKi9cblxuXG5mdW5jdGlvbiBleHRyYWN0RXZlbnRzJDIoZGlzcGF0Y2hRdWV1ZSwgZG9tRXZlbnROYW1lLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQsIGV2ZW50U3lzdGVtRmxhZ3MsIHRhcmdldENvbnRhaW5lcikge1xuICB2YXIgaXNPdmVyRXZlbnQgPSBkb21FdmVudE5hbWUgPT09ICdtb3VzZW92ZXInIHx8IGRvbUV2ZW50TmFtZSA9PT0gJ3BvaW50ZXJvdmVyJztcbiAgdmFyIGlzT3V0RXZlbnQgPSBkb21FdmVudE5hbWUgPT09ICdtb3VzZW91dCcgfHwgZG9tRXZlbnROYW1lID09PSAncG9pbnRlcm91dCc7XG5cbiAgaWYgKGlzT3ZlckV2ZW50ICYmIChldmVudFN5c3RlbUZsYWdzICYgSVNfUkVQTEFZRUQpID09PSAwKSB7XG4gICAgLy8gSWYgdGhpcyBpcyBhbiBvdmVyIGV2ZW50IHdpdGggYSB0YXJnZXQsIHdlIG1pZ2h0IGhhdmUgYWxyZWFkeSBkaXNwYXRjaGVkXG4gICAgLy8gdGhlIGV2ZW50IGluIHRoZSBvdXQgZXZlbnQgb2YgdGhlIG90aGVyIHRhcmdldC4gSWYgdGhpcyBpcyByZXBsYXllZCxcbiAgICAvLyB0aGVuIGl0J3MgYmVjYXVzZSB3ZSBjb3VsZG4ndCBkaXNwYXRjaCBhZ2FpbnN0IHRoaXMgdGFyZ2V0IHByZXZpb3VzbHlcbiAgICAvLyBzbyB3ZSBoYXZlIHRvIGRvIGl0IG5vdyBpbnN0ZWFkLlxuICAgIHZhciByZWxhdGVkID0gbmF0aXZlRXZlbnQucmVsYXRlZFRhcmdldCB8fCBuYXRpdmVFdmVudC5mcm9tRWxlbWVudDtcblxuICAgIGlmIChyZWxhdGVkKSB7XG4gICAgICAvLyBJZiB0aGUgcmVsYXRlZCBub2RlIGlzIG1hbmFnZWQgYnkgUmVhY3QsIHdlIGNhbiBhc3N1bWUgdGhhdCB3ZSBoYXZlXG4gICAgICAvLyBhbHJlYWR5IGRpc3BhdGNoZWQgdGhlIGNvcnJlc3BvbmRpbmcgZXZlbnRzIGR1cmluZyBpdHMgbW91c2VvdXQuXG4gICAgICBpZiAoZ2V0Q2xvc2VzdEluc3RhbmNlRnJvbU5vZGUocmVsYXRlZCkgfHwgaXNDb250YWluZXJNYXJrZWRBc1Jvb3QocmVsYXRlZCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmICghaXNPdXRFdmVudCAmJiAhaXNPdmVyRXZlbnQpIHtcbiAgICAvLyBNdXN0IG5vdCBiZSBhIG1vdXNlIG9yIHBvaW50ZXIgaW4gb3Igb3V0IC0gaWdub3JpbmcuXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHdpbjsgLy8gVE9ETzogd2h5IGlzIHRoaXMgbnVsbGFibGUgaW4gdGhlIHR5cGVzIGJ1dCB3ZSByZWFkIGZyb20gaXQ/XG5cbiAgaWYgKG5hdGl2ZUV2ZW50VGFyZ2V0LndpbmRvdyA9PT0gbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgICAvLyBgbmF0aXZlRXZlbnRUYXJnZXRgIGlzIHByb2JhYmx5IGEgd2luZG93IG9iamVjdC5cbiAgICB3aW4gPSBuYXRpdmVFdmVudFRhcmdldDtcbiAgfSBlbHNlIHtcbiAgICAvLyBUT0RPOiBGaWd1cmUgb3V0IHdoeSBgb3duZXJEb2N1bWVudGAgaXMgc29tZXRpbWVzIHVuZGVmaW5lZCBpbiBJRTguXG4gICAgdmFyIGRvYyA9IG5hdGl2ZUV2ZW50VGFyZ2V0Lm93bmVyRG9jdW1lbnQ7XG5cbiAgICBpZiAoZG9jKSB7XG4gICAgICB3aW4gPSBkb2MuZGVmYXVsdFZpZXcgfHwgZG9jLnBhcmVudFdpbmRvdztcbiAgICB9IGVsc2Uge1xuICAgICAgd2luID0gd2luZG93O1xuICAgIH1cbiAgfVxuXG4gIHZhciBmcm9tO1xuICB2YXIgdG87XG5cbiAgaWYgKGlzT3V0RXZlbnQpIHtcbiAgICB2YXIgX3JlbGF0ZWQgPSBuYXRpdmVFdmVudC5yZWxhdGVkVGFyZ2V0IHx8IG5hdGl2ZUV2ZW50LnRvRWxlbWVudDtcblxuICAgIGZyb20gPSB0YXJnZXRJbnN0O1xuICAgIHRvID0gX3JlbGF0ZWQgPyBnZXRDbG9zZXN0SW5zdGFuY2VGcm9tTm9kZShfcmVsYXRlZCkgOiBudWxsO1xuXG4gICAgaWYgKHRvICE9PSBudWxsKSB7XG4gICAgICB2YXIgbmVhcmVzdE1vdW50ZWQgPSBnZXROZWFyZXN0TW91bnRlZEZpYmVyKHRvKTtcblxuICAgICAgaWYgKHRvICE9PSBuZWFyZXN0TW91bnRlZCB8fCB0by50YWcgIT09IEhvc3RDb21wb25lbnQgJiYgdG8udGFnICE9PSBIb3N0VGV4dCkge1xuICAgICAgICB0byA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIE1vdmluZyB0byBhIG5vZGUgZnJvbSBvdXRzaWRlIHRoZSB3aW5kb3cuXG4gICAgZnJvbSA9IG51bGw7XG4gICAgdG8gPSB0YXJnZXRJbnN0O1xuICB9XG5cbiAgaWYgKGZyb20gPT09IHRvKSB7XG4gICAgLy8gTm90aGluZyBwZXJ0YWlucyB0byBvdXIgbWFuYWdlZCBjb21wb25lbnRzLlxuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBTeW50aGV0aWNFdmVudEN0b3IgPSBTeW50aGV0aWNNb3VzZUV2ZW50O1xuICB2YXIgbGVhdmVFdmVudFR5cGUgPSAnb25Nb3VzZUxlYXZlJztcbiAgdmFyIGVudGVyRXZlbnRUeXBlID0gJ29uTW91c2VFbnRlcic7XG4gIHZhciBldmVudFR5cGVQcmVmaXggPSAnbW91c2UnO1xuXG4gIGlmIChkb21FdmVudE5hbWUgPT09ICdwb2ludGVyb3V0JyB8fCBkb21FdmVudE5hbWUgPT09ICdwb2ludGVyb3ZlcicpIHtcbiAgICBTeW50aGV0aWNFdmVudEN0b3IgPSBTeW50aGV0aWNQb2ludGVyRXZlbnQ7XG4gICAgbGVhdmVFdmVudFR5cGUgPSAnb25Qb2ludGVyTGVhdmUnO1xuICAgIGVudGVyRXZlbnRUeXBlID0gJ29uUG9pbnRlckVudGVyJztcbiAgICBldmVudFR5cGVQcmVmaXggPSAncG9pbnRlcic7XG4gIH1cblxuICB2YXIgZnJvbU5vZGUgPSBmcm9tID09IG51bGwgPyB3aW4gOiBnZXROb2RlRnJvbUluc3RhbmNlKGZyb20pO1xuICB2YXIgdG9Ob2RlID0gdG8gPT0gbnVsbCA/IHdpbiA6IGdldE5vZGVGcm9tSW5zdGFuY2UodG8pO1xuICB2YXIgbGVhdmUgPSBuZXcgU3ludGhldGljRXZlbnRDdG9yKGxlYXZlRXZlbnRUeXBlLCBldmVudFR5cGVQcmVmaXggKyAnbGVhdmUnLCBmcm9tLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xuICBsZWF2ZS50YXJnZXQgPSBmcm9tTm9kZTtcbiAgbGVhdmUucmVsYXRlZFRhcmdldCA9IHRvTm9kZTtcbiAgdmFyIGVudGVyID0gbnVsbDsgLy8gV2Ugc2hvdWxkIG9ubHkgcHJvY2VzcyB0aGlzIG5hdGl2ZUV2ZW50IGlmIHdlIGFyZSBwcm9jZXNzaW5nXG4gIC8vIHRoZSBmaXJzdCBhbmNlc3Rvci4gTmV4dCB0aW1lLCB3ZSB3aWxsIGlnbm9yZSB0aGUgZXZlbnQuXG5cbiAgdmFyIG5hdGl2ZVRhcmdldEluc3QgPSBnZXRDbG9zZXN0SW5zdGFuY2VGcm9tTm9kZShuYXRpdmVFdmVudFRhcmdldCk7XG5cbiAgaWYgKG5hdGl2ZVRhcmdldEluc3QgPT09IHRhcmdldEluc3QpIHtcbiAgICB2YXIgZW50ZXJFdmVudCA9IG5ldyBTeW50aGV0aWNFdmVudEN0b3IoZW50ZXJFdmVudFR5cGUsIGV2ZW50VHlwZVByZWZpeCArICdlbnRlcicsIHRvLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xuICAgIGVudGVyRXZlbnQudGFyZ2V0ID0gdG9Ob2RlO1xuICAgIGVudGVyRXZlbnQucmVsYXRlZFRhcmdldCA9IGZyb21Ob2RlO1xuICAgIGVudGVyID0gZW50ZXJFdmVudDtcbiAgfVxuXG4gIGFjY3VtdWxhdGVFbnRlckxlYXZlVHdvUGhhc2VMaXN0ZW5lcnMoZGlzcGF0Y2hRdWV1ZSwgbGVhdmUsIGVudGVyLCBmcm9tLCB0byk7XG59XG5cbi8qKlxuICogaW5saW5lZCBPYmplY3QuaXMgcG9seWZpbGwgdG8gYXZvaWQgcmVxdWlyaW5nIGNvbnN1bWVycyBzaGlwIHRoZWlyIG93blxuICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvT2JqZWN0L2lzXG4gKi9cbmZ1bmN0aW9uIGlzKHgsIHkpIHtcbiAgcmV0dXJuIHggPT09IHkgJiYgKHggIT09IDAgfHwgMSAvIHggPT09IDEgLyB5KSB8fCB4ICE9PSB4ICYmIHkgIT09IHkgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1zZWxmLWNvbXBhcmVcbiAgO1xufVxuXG52YXIgb2JqZWN0SXMgPSB0eXBlb2YgT2JqZWN0LmlzID09PSAnZnVuY3Rpb24nID8gT2JqZWN0LmlzIDogaXM7XG5cbnZhciBoYXNPd25Qcm9wZXJ0eSQyID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbi8qKlxuICogUGVyZm9ybXMgZXF1YWxpdHkgYnkgaXRlcmF0aW5nIHRocm91Z2gga2V5cyBvbiBhbiBvYmplY3QgYW5kIHJldHVybmluZyBmYWxzZVxuICogd2hlbiBhbnkga2V5IGhhcyB2YWx1ZXMgd2hpY2ggYXJlIG5vdCBzdHJpY3RseSBlcXVhbCBiZXR3ZWVuIHRoZSBhcmd1bWVudHMuXG4gKiBSZXR1cm5zIHRydWUgd2hlbiB0aGUgdmFsdWVzIG9mIGFsbCBrZXlzIGFyZSBzdHJpY3RseSBlcXVhbC5cbiAqL1xuXG5mdW5jdGlvbiBzaGFsbG93RXF1YWwob2JqQSwgb2JqQikge1xuICBpZiAob2JqZWN0SXMob2JqQSwgb2JqQikpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmICh0eXBlb2Ygb2JqQSAhPT0gJ29iamVjdCcgfHwgb2JqQSA9PT0gbnVsbCB8fCB0eXBlb2Ygb2JqQiAhPT0gJ29iamVjdCcgfHwgb2JqQiA9PT0gbnVsbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBrZXlzQSA9IE9iamVjdC5rZXlzKG9iakEpO1xuICB2YXIga2V5c0IgPSBPYmplY3Qua2V5cyhvYmpCKTtcblxuICBpZiAoa2V5c0EubGVuZ3RoICE9PSBrZXlzQi5sZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gLy8gVGVzdCBmb3IgQSdzIGtleXMgZGlmZmVyZW50IGZyb20gQi5cblxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwga2V5c0EubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoIWhhc093blByb3BlcnR5JDIuY2FsbChvYmpCLCBrZXlzQVtpXSkgfHwgIW9iamVjdElzKG9iakFba2V5c0FbaV1dLCBvYmpCW2tleXNBW2ldXSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuLyoqXG4gKiBHaXZlbiBhbnkgbm9kZSByZXR1cm4gdGhlIGZpcnN0IGxlYWYgbm9kZSB3aXRob3V0IGNoaWxkcmVuLlxuICpcbiAqIEBwYXJhbSB7RE9NRWxlbWVudHxET01UZXh0Tm9kZX0gbm9kZVxuICogQHJldHVybiB7RE9NRWxlbWVudHxET01UZXh0Tm9kZX1cbiAqL1xuXG5mdW5jdGlvbiBnZXRMZWFmTm9kZShub2RlKSB7XG4gIHdoaWxlIChub2RlICYmIG5vZGUuZmlyc3RDaGlsZCkge1xuICAgIG5vZGUgPSBub2RlLmZpcnN0Q2hpbGQ7XG4gIH1cblxuICByZXR1cm4gbm9kZTtcbn1cbi8qKlxuICogR2V0IHRoZSBuZXh0IHNpYmxpbmcgd2l0aGluIGEgY29udGFpbmVyLiBUaGlzIHdpbGwgd2FsayB1cCB0aGVcbiAqIERPTSBpZiBhIG5vZGUncyBzaWJsaW5ncyBoYXZlIGJlZW4gZXhoYXVzdGVkLlxuICpcbiAqIEBwYXJhbSB7RE9NRWxlbWVudHxET01UZXh0Tm9kZX0gbm9kZVxuICogQHJldHVybiB7P0RPTUVsZW1lbnR8RE9NVGV4dE5vZGV9XG4gKi9cblxuXG5mdW5jdGlvbiBnZXRTaWJsaW5nTm9kZShub2RlKSB7XG4gIHdoaWxlIChub2RlKSB7XG4gICAgaWYgKG5vZGUubmV4dFNpYmxpbmcpIHtcbiAgICAgIHJldHVybiBub2RlLm5leHRTaWJsaW5nO1xuICAgIH1cblxuICAgIG5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gIH1cbn1cbi8qKlxuICogR2V0IG9iamVjdCBkZXNjcmliaW5nIHRoZSBub2RlcyB3aGljaCBjb250YWluIGNoYXJhY3RlcnMgYXQgb2Zmc2V0LlxuICpcbiAqIEBwYXJhbSB7RE9NRWxlbWVudHxET01UZXh0Tm9kZX0gcm9vdFxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFxuICogQHJldHVybiB7P29iamVjdH1cbiAqL1xuXG5cbmZ1bmN0aW9uIGdldE5vZGVGb3JDaGFyYWN0ZXJPZmZzZXQocm9vdCwgb2Zmc2V0KSB7XG4gIHZhciBub2RlID0gZ2V0TGVhZk5vZGUocm9vdCk7XG4gIHZhciBub2RlU3RhcnQgPSAwO1xuICB2YXIgbm9kZUVuZCA9IDA7XG5cbiAgd2hpbGUgKG5vZGUpIHtcbiAgICBpZiAobm9kZS5ub2RlVHlwZSA9PT0gVEVYVF9OT0RFKSB7XG4gICAgICBub2RlRW5kID0gbm9kZVN0YXJ0ICsgbm9kZS50ZXh0Q29udGVudC5sZW5ndGg7XG5cbiAgICAgIGlmIChub2RlU3RhcnQgPD0gb2Zmc2V0ICYmIG5vZGVFbmQgPj0gb2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbm9kZTogbm9kZSxcbiAgICAgICAgICBvZmZzZXQ6IG9mZnNldCAtIG5vZGVTdGFydFxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBub2RlU3RhcnQgPSBub2RlRW5kO1xuICAgIH1cblxuICAgIG5vZGUgPSBnZXRMZWFmTm9kZShnZXRTaWJsaW5nTm9kZShub2RlKSk7XG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR9IG91dGVyTm9kZVxuICogQHJldHVybiB7P29iamVjdH1cbiAqL1xuXG5mdW5jdGlvbiBnZXRPZmZzZXRzKG91dGVyTm9kZSkge1xuICB2YXIgb3duZXJEb2N1bWVudCA9IG91dGVyTm9kZS5vd25lckRvY3VtZW50O1xuICB2YXIgd2luID0gb3duZXJEb2N1bWVudCAmJiBvd25lckRvY3VtZW50LmRlZmF1bHRWaWV3IHx8IHdpbmRvdztcbiAgdmFyIHNlbGVjdGlvbiA9IHdpbi5nZXRTZWxlY3Rpb24gJiYgd2luLmdldFNlbGVjdGlvbigpO1xuXG4gIGlmICghc2VsZWN0aW9uIHx8IHNlbGVjdGlvbi5yYW5nZUNvdW50ID09PSAwKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgYW5jaG9yTm9kZSA9IHNlbGVjdGlvbi5hbmNob3JOb2RlLFxuICAgICAgYW5jaG9yT2Zmc2V0ID0gc2VsZWN0aW9uLmFuY2hvck9mZnNldCxcbiAgICAgIGZvY3VzTm9kZSA9IHNlbGVjdGlvbi5mb2N1c05vZGUsXG4gICAgICBmb2N1c09mZnNldCA9IHNlbGVjdGlvbi5mb2N1c09mZnNldDsgLy8gSW4gRmlyZWZveCwgYW5jaG9yTm9kZSBhbmQgZm9jdXNOb2RlIGNhbiBiZSBcImFub255bW91cyBkaXZzXCIsIGUuZy4gdGhlXG4gIC8vIHVwL2Rvd24gYnV0dG9ucyBvbiBhbiA8aW5wdXQgdHlwZT1cIm51bWJlclwiPi4gQW5vbnltb3VzIGRpdnMgZG8gbm90IHNlZW0gdG9cbiAgLy8gZXhwb3NlIHByb3BlcnRpZXMsIHRyaWdnZXJpbmcgYSBcIlBlcm1pc3Npb24gZGVuaWVkIGVycm9yXCIgaWYgYW55IG9mIGl0c1xuICAvLyBwcm9wZXJ0aWVzIGFyZSBhY2Nlc3NlZC4gVGhlIG9ubHkgc2VlbWluZ2x5IHBvc3NpYmxlIHdheSB0byBhdm9pZCBlcnJvcmluZ1xuICAvLyBpcyB0byBhY2Nlc3MgYSBwcm9wZXJ0eSB0aGF0IHR5cGljYWxseSB3b3JrcyBmb3Igbm9uLWFub255bW91cyBkaXZzIGFuZFxuICAvLyBjYXRjaCBhbnkgZXJyb3IgdGhhdCBtYXkgb3RoZXJ3aXNlIGFyaXNlLiBTZWVcbiAgLy8gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MjA4NDI3XG5cbiAgdHJ5IHtcbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtZXhwcmVzc2lvbnMgKi9cbiAgICBhbmNob3JOb2RlLm5vZGVUeXBlO1xuICAgIGZvY3VzTm9kZS5ub2RlVHlwZTtcbiAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLXVudXNlZC1leHByZXNzaW9ucyAqL1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICByZXR1cm4gZ2V0TW9kZXJuT2Zmc2V0c0Zyb21Qb2ludHMob3V0ZXJOb2RlLCBhbmNob3JOb2RlLCBhbmNob3JPZmZzZXQsIGZvY3VzTm9kZSwgZm9jdXNPZmZzZXQpO1xufVxuLyoqXG4gKiBSZXR1cm5zIHtzdGFydCwgZW5kfSB3aGVyZSBgc3RhcnRgIGlzIHRoZSBjaGFyYWN0ZXIvY29kZXBvaW50IGluZGV4IG9mXG4gKiAoYW5jaG9yTm9kZSwgYW5jaG9yT2Zmc2V0KSB3aXRoaW4gdGhlIHRleHRDb250ZW50IG9mIGBvdXRlck5vZGVgLCBhbmRcbiAqIGBlbmRgIGlzIHRoZSBpbmRleCBvZiAoZm9jdXNOb2RlLCBmb2N1c09mZnNldCkuXG4gKlxuICogUmV0dXJucyBudWxsIGlmIHlvdSBwYXNzIGluIGdhcmJhZ2UgaW5wdXQgYnV0IHdlIHNob3VsZCBwcm9iYWJseSBqdXN0IGNyYXNoLlxuICpcbiAqIEV4cG9ydGVkIG9ubHkgZm9yIHRlc3RpbmcuXG4gKi9cblxuZnVuY3Rpb24gZ2V0TW9kZXJuT2Zmc2V0c0Zyb21Qb2ludHMob3V0ZXJOb2RlLCBhbmNob3JOb2RlLCBhbmNob3JPZmZzZXQsIGZvY3VzTm9kZSwgZm9jdXNPZmZzZXQpIHtcbiAgdmFyIGxlbmd0aCA9IDA7XG4gIHZhciBzdGFydCA9IC0xO1xuICB2YXIgZW5kID0gLTE7XG4gIHZhciBpbmRleFdpdGhpbkFuY2hvciA9IDA7XG4gIHZhciBpbmRleFdpdGhpbkZvY3VzID0gMDtcbiAgdmFyIG5vZGUgPSBvdXRlck5vZGU7XG4gIHZhciBwYXJlbnROb2RlID0gbnVsbDtcblxuICBvdXRlcjogd2hpbGUgKHRydWUpIHtcbiAgICB2YXIgbmV4dCA9IG51bGw7XG5cbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgaWYgKG5vZGUgPT09IGFuY2hvck5vZGUgJiYgKGFuY2hvck9mZnNldCA9PT0gMCB8fCBub2RlLm5vZGVUeXBlID09PSBURVhUX05PREUpKSB7XG4gICAgICAgIHN0YXJ0ID0gbGVuZ3RoICsgYW5jaG9yT2Zmc2V0O1xuICAgICAgfVxuXG4gICAgICBpZiAobm9kZSA9PT0gZm9jdXNOb2RlICYmIChmb2N1c09mZnNldCA9PT0gMCB8fCBub2RlLm5vZGVUeXBlID09PSBURVhUX05PREUpKSB7XG4gICAgICAgIGVuZCA9IGxlbmd0aCArIGZvY3VzT2Zmc2V0O1xuICAgICAgfVxuXG4gICAgICBpZiAobm9kZS5ub2RlVHlwZSA9PT0gVEVYVF9OT0RFKSB7XG4gICAgICAgIGxlbmd0aCArPSBub2RlLm5vZGVWYWx1ZS5sZW5ndGg7XG4gICAgICB9XG5cbiAgICAgIGlmICgobmV4dCA9IG5vZGUuZmlyc3RDaGlsZCkgPT09IG51bGwpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9IC8vIE1vdmluZyBmcm9tIGBub2RlYCB0byBpdHMgZmlyc3QgY2hpbGQgYG5leHRgLlxuXG5cbiAgICAgIHBhcmVudE5vZGUgPSBub2RlO1xuICAgICAgbm9kZSA9IG5leHQ7XG4gICAgfVxuXG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIGlmIChub2RlID09PSBvdXRlck5vZGUpIHtcbiAgICAgICAgLy8gSWYgYG91dGVyTm9kZWAgaGFzIGNoaWxkcmVuLCB0aGlzIGlzIGFsd2F5cyB0aGUgc2Vjb25kIHRpbWUgdmlzaXRpbmdcbiAgICAgICAgLy8gaXQuIElmIGl0IGhhcyBubyBjaGlsZHJlbiwgdGhpcyBpcyBzdGlsbCB0aGUgZmlyc3QgbG9vcCwgYW5kIHRoZSBvbmx5XG4gICAgICAgIC8vIHZhbGlkIHNlbGVjdGlvbiBpcyBhbmNob3JOb2RlIGFuZCBmb2N1c05vZGUgYm90aCBlcXVhbCB0byB0aGlzIG5vZGVcbiAgICAgICAgLy8gYW5kIGJvdGggb2Zmc2V0cyAwLCBpbiB3aGljaCBjYXNlIHdlIHdpbGwgaGF2ZSBoYW5kbGVkIGFib3ZlLlxuICAgICAgICBicmVhayBvdXRlcjtcbiAgICAgIH1cblxuICAgICAgaWYgKHBhcmVudE5vZGUgPT09IGFuY2hvck5vZGUgJiYgKytpbmRleFdpdGhpbkFuY2hvciA9PT0gYW5jaG9yT2Zmc2V0KSB7XG4gICAgICAgIHN0YXJ0ID0gbGVuZ3RoO1xuICAgICAgfVxuXG4gICAgICBpZiAocGFyZW50Tm9kZSA9PT0gZm9jdXNOb2RlICYmICsraW5kZXhXaXRoaW5Gb2N1cyA9PT0gZm9jdXNPZmZzZXQpIHtcbiAgICAgICAgZW5kID0gbGVuZ3RoO1xuICAgICAgfVxuXG4gICAgICBpZiAoKG5leHQgPSBub2RlLm5leHRTaWJsaW5nKSAhPT0gbnVsbCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgbm9kZSA9IHBhcmVudE5vZGU7XG4gICAgICBwYXJlbnROb2RlID0gbm9kZS5wYXJlbnROb2RlO1xuICAgIH0gLy8gTW92aW5nIGZyb20gYG5vZGVgIHRvIGl0cyBuZXh0IHNpYmxpbmcgYG5leHRgLlxuXG5cbiAgICBub2RlID0gbmV4dDtcbiAgfVxuXG4gIGlmIChzdGFydCA9PT0gLTEgfHwgZW5kID09PSAtMSkge1xuICAgIC8vIFRoaXMgc2hvdWxkIG5ldmVyIGhhcHBlbi4gKFdvdWxkIGhhcHBlbiBpZiB0aGUgYW5jaG9yL2ZvY3VzIG5vZGVzIGFyZW4ndFxuICAgIC8vIGFjdHVhbGx5IGluc2lkZSB0aGUgcGFzc2VkLWluIG5vZGUuKVxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBzdGFydDogc3RhcnQsXG4gICAgZW5kOiBlbmRcbiAgfTtcbn1cbi8qKlxuICogSW4gbW9kZXJuIG5vbi1JRSBicm93c2Vycywgd2UgY2FuIHN1cHBvcnQgYm90aCBmb3J3YXJkIGFuZCBiYWNrd2FyZFxuICogc2VsZWN0aW9ucy5cbiAqXG4gKiBOb3RlOiBJRTEwKyBzdXBwb3J0cyB0aGUgU2VsZWN0aW9uIG9iamVjdCwgYnV0IGl0IGRvZXMgbm90IHN1cHBvcnRcbiAqIHRoZSBgZXh0ZW5kYCBtZXRob2QsIHdoaWNoIG1lYW5zIHRoYXQgZXZlbiBpbiBtb2Rlcm4gSUUsIGl0J3Mgbm90IHBvc3NpYmxlXG4gKiB0byBwcm9ncmFtbWF0aWNhbGx5IGNyZWF0ZSBhIGJhY2t3YXJkIHNlbGVjdGlvbi4gVGh1cywgZm9yIGFsbCBJRVxuICogdmVyc2lvbnMsIHdlIHVzZSB0aGUgb2xkIElFIEFQSSB0byBjcmVhdGUgb3VyIHNlbGVjdGlvbnMuXG4gKlxuICogQHBhcmFtIHtET01FbGVtZW50fERPTVRleHROb2RlfSBub2RlXG4gKiBAcGFyYW0ge29iamVjdH0gb2Zmc2V0c1xuICovXG5cbmZ1bmN0aW9uIHNldE9mZnNldHMobm9kZSwgb2Zmc2V0cykge1xuICB2YXIgZG9jID0gbm9kZS5vd25lckRvY3VtZW50IHx8IGRvY3VtZW50O1xuICB2YXIgd2luID0gZG9jICYmIGRvYy5kZWZhdWx0VmlldyB8fCB3aW5kb3c7IC8vIEVkZ2UgZmFpbHMgd2l0aCBcIk9iamVjdCBleHBlY3RlZFwiIGluIHNvbWUgc2NlbmFyaW9zLlxuICAvLyAoRm9yIGluc3RhbmNlOiBUaW55TUNFIGVkaXRvciB1c2VkIGluIGEgbGlzdCBjb21wb25lbnQgdGhhdCBzdXBwb3J0cyBwYXN0aW5nIHRvIGFkZCBtb3JlLFxuICAvLyBmYWlscyB3aGVuIHBhc3RpbmcgMTAwKyBpdGVtcylcblxuICBpZiAoIXdpbi5nZXRTZWxlY3Rpb24pIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgc2VsZWN0aW9uID0gd2luLmdldFNlbGVjdGlvbigpO1xuICB2YXIgbGVuZ3RoID0gbm9kZS50ZXh0Q29udGVudC5sZW5ndGg7XG4gIHZhciBzdGFydCA9IE1hdGgubWluKG9mZnNldHMuc3RhcnQsIGxlbmd0aCk7XG4gIHZhciBlbmQgPSBvZmZzZXRzLmVuZCA9PT0gdW5kZWZpbmVkID8gc3RhcnQgOiBNYXRoLm1pbihvZmZzZXRzLmVuZCwgbGVuZ3RoKTsgLy8gSUUgMTEgdXNlcyBtb2Rlcm4gc2VsZWN0aW9uLCBidXQgZG9lc24ndCBzdXBwb3J0IHRoZSBleHRlbmQgbWV0aG9kLlxuICAvLyBGbGlwIGJhY2t3YXJkIHNlbGVjdGlvbnMsIHNvIHdlIGNhbiBzZXQgd2l0aCBhIHNpbmdsZSByYW5nZS5cblxuICBpZiAoIXNlbGVjdGlvbi5leHRlbmQgJiYgc3RhcnQgPiBlbmQpIHtcbiAgICB2YXIgdGVtcCA9IGVuZDtcbiAgICBlbmQgPSBzdGFydDtcbiAgICBzdGFydCA9IHRlbXA7XG4gIH1cblxuICB2YXIgc3RhcnRNYXJrZXIgPSBnZXROb2RlRm9yQ2hhcmFjdGVyT2Zmc2V0KG5vZGUsIHN0YXJ0KTtcbiAgdmFyIGVuZE1hcmtlciA9IGdldE5vZGVGb3JDaGFyYWN0ZXJPZmZzZXQobm9kZSwgZW5kKTtcblxuICBpZiAoc3RhcnRNYXJrZXIgJiYgZW5kTWFya2VyKSB7XG4gICAgaWYgKHNlbGVjdGlvbi5yYW5nZUNvdW50ID09PSAxICYmIHNlbGVjdGlvbi5hbmNob3JOb2RlID09PSBzdGFydE1hcmtlci5ub2RlICYmIHNlbGVjdGlvbi5hbmNob3JPZmZzZXQgPT09IHN0YXJ0TWFya2VyLm9mZnNldCAmJiBzZWxlY3Rpb24uZm9jdXNOb2RlID09PSBlbmRNYXJrZXIubm9kZSAmJiBzZWxlY3Rpb24uZm9jdXNPZmZzZXQgPT09IGVuZE1hcmtlci5vZmZzZXQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgcmFuZ2UgPSBkb2MuY3JlYXRlUmFuZ2UoKTtcbiAgICByYW5nZS5zZXRTdGFydChzdGFydE1hcmtlci5ub2RlLCBzdGFydE1hcmtlci5vZmZzZXQpO1xuICAgIHNlbGVjdGlvbi5yZW1vdmVBbGxSYW5nZXMoKTtcblxuICAgIGlmIChzdGFydCA+IGVuZCkge1xuICAgICAgc2VsZWN0aW9uLmFkZFJhbmdlKHJhbmdlKTtcbiAgICAgIHNlbGVjdGlvbi5leHRlbmQoZW5kTWFya2VyLm5vZGUsIGVuZE1hcmtlci5vZmZzZXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByYW5nZS5zZXRFbmQoZW5kTWFya2VyLm5vZGUsIGVuZE1hcmtlci5vZmZzZXQpO1xuICAgICAgc2VsZWN0aW9uLmFkZFJhbmdlKHJhbmdlKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNUZXh0Tm9kZShub2RlKSB7XG4gIHJldHVybiBub2RlICYmIG5vZGUubm9kZVR5cGUgPT09IFRFWFRfTk9ERTtcbn1cblxuZnVuY3Rpb24gY29udGFpbnNOb2RlKG91dGVyTm9kZSwgaW5uZXJOb2RlKSB7XG4gIGlmICghb3V0ZXJOb2RlIHx8ICFpbm5lck5vZGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gZWxzZSBpZiAob3V0ZXJOb2RlID09PSBpbm5lck5vZGUpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBlbHNlIGlmIChpc1RleHROb2RlKG91dGVyTm9kZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gZWxzZSBpZiAoaXNUZXh0Tm9kZShpbm5lck5vZGUpKSB7XG4gICAgcmV0dXJuIGNvbnRhaW5zTm9kZShvdXRlck5vZGUsIGlubmVyTm9kZS5wYXJlbnROb2RlKTtcbiAgfSBlbHNlIGlmICgnY29udGFpbnMnIGluIG91dGVyTm9kZSkge1xuICAgIHJldHVybiBvdXRlck5vZGUuY29udGFpbnMoaW5uZXJOb2RlKTtcbiAgfSBlbHNlIGlmIChvdXRlck5vZGUuY29tcGFyZURvY3VtZW50UG9zaXRpb24pIHtcbiAgICByZXR1cm4gISEob3V0ZXJOb2RlLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKGlubmVyTm9kZSkgJiAxNik7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGlzSW5Eb2N1bWVudChub2RlKSB7XG4gIHJldHVybiBub2RlICYmIG5vZGUub3duZXJEb2N1bWVudCAmJiBjb250YWluc05vZGUobm9kZS5vd25lckRvY3VtZW50LmRvY3VtZW50RWxlbWVudCwgbm9kZSk7XG59XG5cbmZ1bmN0aW9uIGlzU2FtZU9yaWdpbkZyYW1lKGlmcmFtZSkge1xuICB0cnkge1xuICAgIC8vIEFjY2Vzc2luZyB0aGUgY29udGVudERvY3VtZW50IG9mIGEgSFRNTElmcmFtZUVsZW1lbnQgY2FuIGNhdXNlIHRoZSBicm93c2VyXG4gICAgLy8gdG8gdGhyb3csIGUuZy4gaWYgaXQgaGFzIGEgY3Jvc3Mtb3JpZ2luIHNyYyBhdHRyaWJ1dGUuXG4gICAgLy8gU2FmYXJpIHdpbGwgc2hvdyBhbiBlcnJvciBpbiB0aGUgY29uc29sZSB3aGVuIHRoZSBhY2Nlc3MgcmVzdWx0cyBpbiBcIkJsb2NrZWQgYSBmcmFtZSB3aXRoIG9yaWdpblwiLiBlLmc6XG4gICAgLy8gaWZyYW1lLmNvbnRlbnREb2N1bWVudC5kZWZhdWx0VmlldztcbiAgICAvLyBBIHNhZmV0eSB3YXkgaXMgdG8gYWNjZXNzIG9uZSBvZiB0aGUgY3Jvc3Mgb3JpZ2luIHByb3BlcnRpZXM6IFdpbmRvdyBvciBMb2NhdGlvblxuICAgIC8vIFdoaWNoIG1pZ2h0IHJlc3VsdCBpbiBcIlNlY3VyaXR5RXJyb3JcIiBET00gRXhjZXB0aW9uIGFuZCBpdCBpcyBjb21wYXRpYmxlIHRvIFNhZmFyaS5cbiAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9icm93c2Vycy5odG1sI2ludGVncmF0aW9uLXdpdGgtaWRsXG4gICAgcmV0dXJuIHR5cGVvZiBpZnJhbWUuY29udGVudFdpbmRvdy5sb2NhdGlvbi5ocmVmID09PSAnc3RyaW5nJztcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldEFjdGl2ZUVsZW1lbnREZWVwKCkge1xuICB2YXIgd2luID0gd2luZG93O1xuICB2YXIgZWxlbWVudCA9IGdldEFjdGl2ZUVsZW1lbnQoKTtcblxuICB3aGlsZSAoZWxlbWVudCBpbnN0YW5jZW9mIHdpbi5IVE1MSUZyYW1lRWxlbWVudCkge1xuICAgIGlmIChpc1NhbWVPcmlnaW5GcmFtZShlbGVtZW50KSkge1xuICAgICAgd2luID0gZWxlbWVudC5jb250ZW50V2luZG93O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZWxlbWVudDtcbiAgICB9XG5cbiAgICBlbGVtZW50ID0gZ2V0QWN0aXZlRWxlbWVudCh3aW4uZG9jdW1lbnQpO1xuICB9XG5cbiAgcmV0dXJuIGVsZW1lbnQ7XG59XG4vKipcbiAqIEBSZWFjdElucHV0U2VsZWN0aW9uOiBSZWFjdCBpbnB1dCBzZWxlY3Rpb24gbW9kdWxlLiBCYXNlZCBvbiBTZWxlY3Rpb24uanMsXG4gKiBidXQgbW9kaWZpZWQgdG8gYmUgc3VpdGFibGUgZm9yIHJlYWN0IGFuZCBoYXMgYSBjb3VwbGUgb2YgYnVnIGZpeGVzIChkb2Vzbid0XG4gKiBhc3N1bWUgYnV0dG9ucyBoYXZlIHJhbmdlIHNlbGVjdGlvbnMgYWxsb3dlZCkuXG4gKiBJbnB1dCBzZWxlY3Rpb24gbW9kdWxlIGZvciBSZWFjdC5cbiAqL1xuXG4vKipcbiAqIEBoYXNTZWxlY3Rpb25DYXBhYmlsaXRpZXM6IHdlIGdldCB0aGUgZWxlbWVudCB0eXBlcyB0aGF0IHN1cHBvcnQgc2VsZWN0aW9uXG4gKiBmcm9tIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvI2RvLW5vdC1hcHBseSwgbG9va2luZyBhdCBgc2VsZWN0aW9uU3RhcnRgXG4gKiBhbmQgYHNlbGVjdGlvbkVuZGAgcm93cy5cbiAqL1xuXG5cbmZ1bmN0aW9uIGhhc1NlbGVjdGlvbkNhcGFiaWxpdGllcyhlbGVtKSB7XG4gIHZhciBub2RlTmFtZSA9IGVsZW0gJiYgZWxlbS5ub2RlTmFtZSAmJiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG4gIHJldHVybiBub2RlTmFtZSAmJiAobm9kZU5hbWUgPT09ICdpbnB1dCcgJiYgKGVsZW0udHlwZSA9PT0gJ3RleHQnIHx8IGVsZW0udHlwZSA9PT0gJ3NlYXJjaCcgfHwgZWxlbS50eXBlID09PSAndGVsJyB8fCBlbGVtLnR5cGUgPT09ICd1cmwnIHx8IGVsZW0udHlwZSA9PT0gJ3Bhc3N3b3JkJykgfHwgbm9kZU5hbWUgPT09ICd0ZXh0YXJlYScgfHwgZWxlbS5jb250ZW50RWRpdGFibGUgPT09ICd0cnVlJyk7XG59XG5mdW5jdGlvbiBnZXRTZWxlY3Rpb25JbmZvcm1hdGlvbigpIHtcbiAgdmFyIGZvY3VzZWRFbGVtID0gZ2V0QWN0aXZlRWxlbWVudERlZXAoKTtcbiAgcmV0dXJuIHtcbiAgICBmb2N1c2VkRWxlbTogZm9jdXNlZEVsZW0sXG4gICAgc2VsZWN0aW9uUmFuZ2U6IGhhc1NlbGVjdGlvbkNhcGFiaWxpdGllcyhmb2N1c2VkRWxlbSkgPyBnZXRTZWxlY3Rpb24oZm9jdXNlZEVsZW0pIDogbnVsbFxuICB9O1xufVxuLyoqXG4gKiBAcmVzdG9yZVNlbGVjdGlvbjogSWYgYW55IHNlbGVjdGlvbiBpbmZvcm1hdGlvbiB3YXMgcG90ZW50aWFsbHkgbG9zdCxcbiAqIHJlc3RvcmUgaXQuIFRoaXMgaXMgdXNlZnVsIHdoZW4gcGVyZm9ybWluZyBvcGVyYXRpb25zIHRoYXQgY291bGQgcmVtb3ZlIGRvbVxuICogbm9kZXMgYW5kIHBsYWNlIHRoZW0gYmFjayBpbiwgcmVzdWx0aW5nIGluIGZvY3VzIGJlaW5nIGxvc3QuXG4gKi9cblxuZnVuY3Rpb24gcmVzdG9yZVNlbGVjdGlvbihwcmlvclNlbGVjdGlvbkluZm9ybWF0aW9uKSB7XG4gIHZhciBjdXJGb2N1c2VkRWxlbSA9IGdldEFjdGl2ZUVsZW1lbnREZWVwKCk7XG4gIHZhciBwcmlvckZvY3VzZWRFbGVtID0gcHJpb3JTZWxlY3Rpb25JbmZvcm1hdGlvbi5mb2N1c2VkRWxlbTtcbiAgdmFyIHByaW9yU2VsZWN0aW9uUmFuZ2UgPSBwcmlvclNlbGVjdGlvbkluZm9ybWF0aW9uLnNlbGVjdGlvblJhbmdlO1xuXG4gIGlmIChjdXJGb2N1c2VkRWxlbSAhPT0gcHJpb3JGb2N1c2VkRWxlbSAmJiBpc0luRG9jdW1lbnQocHJpb3JGb2N1c2VkRWxlbSkpIHtcbiAgICBpZiAocHJpb3JTZWxlY3Rpb25SYW5nZSAhPT0gbnVsbCAmJiBoYXNTZWxlY3Rpb25DYXBhYmlsaXRpZXMocHJpb3JGb2N1c2VkRWxlbSkpIHtcbiAgICAgIHNldFNlbGVjdGlvbihwcmlvckZvY3VzZWRFbGVtLCBwcmlvclNlbGVjdGlvblJhbmdlKTtcbiAgICB9IC8vIEZvY3VzaW5nIGEgbm9kZSBjYW4gY2hhbmdlIHRoZSBzY3JvbGwgcG9zaXRpb24sIHdoaWNoIGlzIHVuZGVzaXJhYmxlXG5cblxuICAgIHZhciBhbmNlc3RvcnMgPSBbXTtcbiAgICB2YXIgYW5jZXN0b3IgPSBwcmlvckZvY3VzZWRFbGVtO1xuXG4gICAgd2hpbGUgKGFuY2VzdG9yID0gYW5jZXN0b3IucGFyZW50Tm9kZSkge1xuICAgICAgaWYgKGFuY2VzdG9yLm5vZGVUeXBlID09PSBFTEVNRU5UX05PREUpIHtcbiAgICAgICAgYW5jZXN0b3JzLnB1c2goe1xuICAgICAgICAgIGVsZW1lbnQ6IGFuY2VzdG9yLFxuICAgICAgICAgIGxlZnQ6IGFuY2VzdG9yLnNjcm9sbExlZnQsXG4gICAgICAgICAgdG9wOiBhbmNlc3Rvci5zY3JvbGxUb3BcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBwcmlvckZvY3VzZWRFbGVtLmZvY3VzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBwcmlvckZvY3VzZWRFbGVtLmZvY3VzKCk7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhbmNlc3RvcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBpbmZvID0gYW5jZXN0b3JzW2ldO1xuICAgICAgaW5mby5lbGVtZW50LnNjcm9sbExlZnQgPSBpbmZvLmxlZnQ7XG4gICAgICBpbmZvLmVsZW1lbnQuc2Nyb2xsVG9wID0gaW5mby50b3A7XG4gICAgfVxuICB9XG59XG4vKipcbiAqIEBnZXRTZWxlY3Rpb246IEdldHMgdGhlIHNlbGVjdGlvbiBib3VuZHMgb2YgYSBmb2N1c2VkIHRleHRhcmVhLCBpbnB1dCBvclxuICogY29udGVudEVkaXRhYmxlIG5vZGUuXG4gKiAtQGlucHV0OiBMb29rIHVwIHNlbGVjdGlvbiBib3VuZHMgb2YgdGhpcyBpbnB1dFxuICogLUByZXR1cm4ge3N0YXJ0OiBzZWxlY3Rpb25TdGFydCwgZW5kOiBzZWxlY3Rpb25FbmR9XG4gKi9cblxuZnVuY3Rpb24gZ2V0U2VsZWN0aW9uKGlucHV0KSB7XG4gIHZhciBzZWxlY3Rpb247XG5cbiAgaWYgKCdzZWxlY3Rpb25TdGFydCcgaW4gaW5wdXQpIHtcbiAgICAvLyBNb2Rlcm4gYnJvd3NlciB3aXRoIGlucHV0IG9yIHRleHRhcmVhLlxuICAgIHNlbGVjdGlvbiA9IHtcbiAgICAgIHN0YXJ0OiBpbnB1dC5zZWxlY3Rpb25TdGFydCxcbiAgICAgIGVuZDogaW5wdXQuc2VsZWN0aW9uRW5kXG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICAvLyBDb250ZW50IGVkaXRhYmxlIG9yIG9sZCBJRSB0ZXh0YXJlYS5cbiAgICBzZWxlY3Rpb24gPSBnZXRPZmZzZXRzKGlucHV0KTtcbiAgfVxuXG4gIHJldHVybiBzZWxlY3Rpb24gfHwge1xuICAgIHN0YXJ0OiAwLFxuICAgIGVuZDogMFxuICB9O1xufVxuLyoqXG4gKiBAc2V0U2VsZWN0aW9uOiBTZXRzIHRoZSBzZWxlY3Rpb24gYm91bmRzIG9mIGEgdGV4dGFyZWEgb3IgaW5wdXQgYW5kIGZvY3VzZXNcbiAqIHRoZSBpbnB1dC5cbiAqIC1AaW5wdXQgICAgIFNldCBzZWxlY3Rpb24gYm91bmRzIG9mIHRoaXMgaW5wdXQgb3IgdGV4dGFyZWFcbiAqIC1Ab2Zmc2V0cyAgIE9iamVjdCBvZiBzYW1lIGZvcm0gdGhhdCBpcyByZXR1cm5lZCBmcm9tIGdldCpcbiAqL1xuXG5mdW5jdGlvbiBzZXRTZWxlY3Rpb24oaW5wdXQsIG9mZnNldHMpIHtcbiAgdmFyIHN0YXJ0ID0gb2Zmc2V0cy5zdGFydDtcbiAgdmFyIGVuZCA9IG9mZnNldHMuZW5kO1xuXG4gIGlmIChlbmQgPT09IHVuZGVmaW5lZCkge1xuICAgIGVuZCA9IHN0YXJ0O1xuICB9XG5cbiAgaWYgKCdzZWxlY3Rpb25TdGFydCcgaW4gaW5wdXQpIHtcbiAgICBpbnB1dC5zZWxlY3Rpb25TdGFydCA9IHN0YXJ0O1xuICAgIGlucHV0LnNlbGVjdGlvbkVuZCA9IE1hdGgubWluKGVuZCwgaW5wdXQudmFsdWUubGVuZ3RoKTtcbiAgfSBlbHNlIHtcbiAgICBzZXRPZmZzZXRzKGlucHV0LCBvZmZzZXRzKTtcbiAgfVxufVxuXG52YXIgc2tpcFNlbGVjdGlvbkNoYW5nZUV2ZW50ID0gY2FuVXNlRE9NICYmICdkb2N1bWVudE1vZGUnIGluIGRvY3VtZW50ICYmIGRvY3VtZW50LmRvY3VtZW50TW9kZSA8PSAxMTtcblxuZnVuY3Rpb24gcmVnaXN0ZXJFdmVudHMkMygpIHtcbiAgcmVnaXN0ZXJUd29QaGFzZUV2ZW50KCdvblNlbGVjdCcsIFsnZm9jdXNvdXQnLCAnY29udGV4dG1lbnUnLCAnZHJhZ2VuZCcsICdmb2N1c2luJywgJ2tleWRvd24nLCAna2V5dXAnLCAnbW91c2Vkb3duJywgJ21vdXNldXAnLCAnc2VsZWN0aW9uY2hhbmdlJ10pO1xufVxuXG52YXIgYWN0aXZlRWxlbWVudCQxID0gbnVsbDtcbnZhciBhY3RpdmVFbGVtZW50SW5zdCQxID0gbnVsbDtcbnZhciBsYXN0U2VsZWN0aW9uID0gbnVsbDtcbnZhciBtb3VzZURvd24gPSBmYWxzZTtcbi8qKlxuICogR2V0IGFuIG9iamVjdCB3aGljaCBpcyBhIHVuaXF1ZSByZXByZXNlbnRhdGlvbiBvZiB0aGUgY3VycmVudCBzZWxlY3Rpb24uXG4gKlxuICogVGhlIHJldHVybiB2YWx1ZSB3aWxsIG5vdCBiZSBjb25zaXN0ZW50IGFjcm9zcyBub2RlcyBvciBicm93c2VycywgYnV0XG4gKiB0d28gaWRlbnRpY2FsIHNlbGVjdGlvbnMgb24gdGhlIHNhbWUgbm9kZSB3aWxsIHJldHVybiBpZGVudGljYWwgb2JqZWN0cy5cbiAqL1xuXG5mdW5jdGlvbiBnZXRTZWxlY3Rpb24kMShub2RlKSB7XG4gIGlmICgnc2VsZWN0aW9uU3RhcnQnIGluIG5vZGUgJiYgaGFzU2VsZWN0aW9uQ2FwYWJpbGl0aWVzKG5vZGUpKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN0YXJ0OiBub2RlLnNlbGVjdGlvblN0YXJ0LFxuICAgICAgZW5kOiBub2RlLnNlbGVjdGlvbkVuZFxuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgdmFyIHdpbiA9IG5vZGUub3duZXJEb2N1bWVudCAmJiBub2RlLm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXcgfHwgd2luZG93O1xuICAgIHZhciBzZWxlY3Rpb24gPSB3aW4uZ2V0U2VsZWN0aW9uKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGFuY2hvck5vZGU6IHNlbGVjdGlvbi5hbmNob3JOb2RlLFxuICAgICAgYW5jaG9yT2Zmc2V0OiBzZWxlY3Rpb24uYW5jaG9yT2Zmc2V0LFxuICAgICAgZm9jdXNOb2RlOiBzZWxlY3Rpb24uZm9jdXNOb2RlLFxuICAgICAgZm9jdXNPZmZzZXQ6IHNlbGVjdGlvbi5mb2N1c09mZnNldFxuICAgIH07XG4gIH1cbn1cbi8qKlxuICogR2V0IGRvY3VtZW50IGFzc29jaWF0ZWQgd2l0aCB0aGUgZXZlbnQgdGFyZ2V0LlxuICovXG5cblxuZnVuY3Rpb24gZ2V0RXZlbnRUYXJnZXREb2N1bWVudChldmVudFRhcmdldCkge1xuICByZXR1cm4gZXZlbnRUYXJnZXQud2luZG93ID09PSBldmVudFRhcmdldCA/IGV2ZW50VGFyZ2V0LmRvY3VtZW50IDogZXZlbnRUYXJnZXQubm9kZVR5cGUgPT09IERPQ1VNRU5UX05PREUgPyBldmVudFRhcmdldCA6IGV2ZW50VGFyZ2V0Lm93bmVyRG9jdW1lbnQ7XG59XG4vKipcbiAqIFBvbGwgc2VsZWN0aW9uIHRvIHNlZSB3aGV0aGVyIGl0J3MgY2hhbmdlZC5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnRcbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudFRhcmdldFxuICogQHJldHVybiB7P1N5bnRoZXRpY0V2ZW50fVxuICovXG5cblxuZnVuY3Rpb24gY29uc3RydWN0U2VsZWN0RXZlbnQoZGlzcGF0Y2hRdWV1ZSwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIC8vIEVuc3VyZSB3ZSBoYXZlIHRoZSByaWdodCBlbGVtZW50LCBhbmQgdGhhdCB0aGUgdXNlciBpcyBub3QgZHJhZ2dpbmcgYVxuICAvLyBzZWxlY3Rpb24gKHRoaXMgbWF0Y2hlcyBuYXRpdmUgYHNlbGVjdGAgZXZlbnQgYmVoYXZpb3IpLiBJbiBIVE1MNSwgc2VsZWN0XG4gIC8vIGZpcmVzIG9ubHkgb24gaW5wdXQgYW5kIHRleHRhcmVhIHRodXMgaWYgdGhlcmUncyBubyBmb2N1c2VkIGVsZW1lbnQgd2VcbiAgLy8gd29uJ3QgZGlzcGF0Y2guXG4gIHZhciBkb2MgPSBnZXRFdmVudFRhcmdldERvY3VtZW50KG5hdGl2ZUV2ZW50VGFyZ2V0KTtcblxuICBpZiAobW91c2VEb3duIHx8IGFjdGl2ZUVsZW1lbnQkMSA9PSBudWxsIHx8IGFjdGl2ZUVsZW1lbnQkMSAhPT0gZ2V0QWN0aXZlRWxlbWVudChkb2MpKSB7XG4gICAgcmV0dXJuO1xuICB9IC8vIE9ubHkgZmlyZSB3aGVuIHNlbGVjdGlvbiBoYXMgYWN0dWFsbHkgY2hhbmdlZC5cblxuXG4gIHZhciBjdXJyZW50U2VsZWN0aW9uID0gZ2V0U2VsZWN0aW9uJDEoYWN0aXZlRWxlbWVudCQxKTtcblxuICBpZiAoIWxhc3RTZWxlY3Rpb24gfHwgIXNoYWxsb3dFcXVhbChsYXN0U2VsZWN0aW9uLCBjdXJyZW50U2VsZWN0aW9uKSkge1xuICAgIGxhc3RTZWxlY3Rpb24gPSBjdXJyZW50U2VsZWN0aW9uO1xuICAgIHZhciBsaXN0ZW5lcnMgPSBhY2N1bXVsYXRlVHdvUGhhc2VMaXN0ZW5lcnMoYWN0aXZlRWxlbWVudEluc3QkMSwgJ29uU2VsZWN0Jyk7XG5cbiAgICBpZiAobGlzdGVuZXJzLmxlbmd0aCA+IDApIHtcbiAgICAgIHZhciBldmVudCA9IG5ldyBTeW50aGV0aWNFdmVudCgnb25TZWxlY3QnLCAnc2VsZWN0JywgbnVsbCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbiAgICAgIGRpc3BhdGNoUXVldWUucHVzaCh7XG4gICAgICAgIGV2ZW50OiBldmVudCxcbiAgICAgICAgbGlzdGVuZXJzOiBsaXN0ZW5lcnNcbiAgICAgIH0pO1xuICAgICAgZXZlbnQudGFyZ2V0ID0gYWN0aXZlRWxlbWVudCQxO1xuICAgIH1cbiAgfVxufVxuLyoqXG4gKiBUaGlzIHBsdWdpbiBjcmVhdGVzIGFuIGBvblNlbGVjdGAgZXZlbnQgdGhhdCBub3JtYWxpemVzIHNlbGVjdCBldmVudHNcbiAqIGFjcm9zcyBmb3JtIGVsZW1lbnRzLlxuICpcbiAqIFN1cHBvcnRlZCBlbGVtZW50cyBhcmU6XG4gKiAtIGlucHV0IChzZWUgYGlzVGV4dElucHV0RWxlbWVudGApXG4gKiAtIHRleHRhcmVhXG4gKiAtIGNvbnRlbnRFZGl0YWJsZVxuICpcbiAqIFRoaXMgZGlmZmVycyBmcm9tIG5hdGl2ZSBicm93c2VyIGltcGxlbWVudGF0aW9ucyBpbiB0aGUgZm9sbG93aW5nIHdheXM6XG4gKiAtIEZpcmVzIG9uIGNvbnRlbnRFZGl0YWJsZSBmaWVsZHMgYXMgd2VsbCBhcyBpbnB1dHMuXG4gKiAtIEZpcmVzIGZvciBjb2xsYXBzZWQgc2VsZWN0aW9uLlxuICogLSBGaXJlcyBhZnRlciB1c2VyIGlucHV0LlxuICovXG5cblxuZnVuY3Rpb24gZXh0cmFjdEV2ZW50cyQzKGRpc3BhdGNoUXVldWUsIGRvbUV2ZW50TmFtZSwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0LCBldmVudFN5c3RlbUZsYWdzLCB0YXJnZXRDb250YWluZXIpIHtcblxuICB2YXIgdGFyZ2V0Tm9kZSA9IHRhcmdldEluc3QgPyBnZXROb2RlRnJvbUluc3RhbmNlKHRhcmdldEluc3QpIDogd2luZG93O1xuXG4gIHN3aXRjaCAoZG9tRXZlbnROYW1lKSB7XG4gICAgLy8gVHJhY2sgdGhlIGlucHV0IG5vZGUgdGhhdCBoYXMgZm9jdXMuXG4gICAgY2FzZSAnZm9jdXNpbic6XG4gICAgICBpZiAoaXNUZXh0SW5wdXRFbGVtZW50KHRhcmdldE5vZGUpIHx8IHRhcmdldE5vZGUuY29udGVudEVkaXRhYmxlID09PSAndHJ1ZScpIHtcbiAgICAgICAgYWN0aXZlRWxlbWVudCQxID0gdGFyZ2V0Tm9kZTtcbiAgICAgICAgYWN0aXZlRWxlbWVudEluc3QkMSA9IHRhcmdldEluc3Q7XG4gICAgICAgIGxhc3RTZWxlY3Rpb24gPSBudWxsO1xuICAgICAgfVxuXG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ2ZvY3Vzb3V0JzpcbiAgICAgIGFjdGl2ZUVsZW1lbnQkMSA9IG51bGw7XG4gICAgICBhY3RpdmVFbGVtZW50SW5zdCQxID0gbnVsbDtcbiAgICAgIGxhc3RTZWxlY3Rpb24gPSBudWxsO1xuICAgICAgYnJlYWs7XG4gICAgLy8gRG9uJ3QgZmlyZSB0aGUgZXZlbnQgd2hpbGUgdGhlIHVzZXIgaXMgZHJhZ2dpbmcuIFRoaXMgbWF0Y2hlcyB0aGVcbiAgICAvLyBzZW1hbnRpY3Mgb2YgdGhlIG5hdGl2ZSBzZWxlY3QgZXZlbnQuXG5cbiAgICBjYXNlICdtb3VzZWRvd24nOlxuICAgICAgbW91c2VEb3duID0gdHJ1ZTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnY29udGV4dG1lbnUnOlxuICAgIGNhc2UgJ21vdXNldXAnOlxuICAgIGNhc2UgJ2RyYWdlbmQnOlxuICAgICAgbW91c2VEb3duID0gZmFsc2U7XG4gICAgICBjb25zdHJ1Y3RTZWxlY3RFdmVudChkaXNwYXRjaFF1ZXVlLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xuICAgICAgYnJlYWs7XG4gICAgLy8gQ2hyb21lIGFuZCBJRSBmaXJlIG5vbi1zdGFuZGFyZCBldmVudCB3aGVuIHNlbGVjdGlvbiBpcyBjaGFuZ2VkIChhbmRcbiAgICAvLyBzb21ldGltZXMgd2hlbiBpdCBoYXNuJ3QpLiBJRSdzIGV2ZW50IGZpcmVzIG91dCBvZiBvcmRlciB3aXRoIHJlc3BlY3RcbiAgICAvLyB0byBrZXkgYW5kIGlucHV0IGV2ZW50cyBvbiBkZWxldGlvbiwgc28gd2UgZGlzY2FyZCBpdC5cbiAgICAvL1xuICAgIC8vIEZpcmVmb3ggZG9lc24ndCBzdXBwb3J0IHNlbGVjdGlvbmNoYW5nZSwgc28gY2hlY2sgc2VsZWN0aW9uIHN0YXR1c1xuICAgIC8vIGFmdGVyIGVhY2gga2V5IGVudHJ5LiBUaGUgc2VsZWN0aW9uIGNoYW5nZXMgYWZ0ZXIga2V5ZG93biBhbmQgYmVmb3JlXG4gICAgLy8ga2V5dXAsIGJ1dCB3ZSBjaGVjayBvbiBrZXlkb3duIGFzIHdlbGwgaW4gdGhlIGNhc2Ugb2YgaG9sZGluZyBkb3duIGFcbiAgICAvLyBrZXksIHdoZW4gbXVsdGlwbGUga2V5ZG93biBldmVudHMgYXJlIGZpcmVkIGJ1dCBvbmx5IG9uZSBrZXl1cCBpcy5cbiAgICAvLyBUaGlzIGlzIGFsc28gb3VyIGFwcHJvYWNoIGZvciBJRSBoYW5kbGluZywgZm9yIHRoZSByZWFzb24gYWJvdmUuXG5cbiAgICBjYXNlICdzZWxlY3Rpb25jaGFuZ2UnOlxuICAgICAgaWYgKHNraXBTZWxlY3Rpb25DaGFuZ2VFdmVudCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgIC8vIGZhbGxzIHRocm91Z2hcblxuICAgIGNhc2UgJ2tleWRvd24nOlxuICAgIGNhc2UgJ2tleXVwJzpcbiAgICAgIGNvbnN0cnVjdFNlbGVjdEV2ZW50KGRpc3BhdGNoUXVldWUsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZXh0cmFjdEV2ZW50cyQ0KGRpc3BhdGNoUXVldWUsIGRvbUV2ZW50TmFtZSwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0LCBldmVudFN5c3RlbUZsYWdzLCB0YXJnZXRDb250YWluZXIpIHtcbiAgdmFyIHJlYWN0TmFtZSA9IHRvcExldmVsRXZlbnRzVG9SZWFjdE5hbWVzLmdldChkb21FdmVudE5hbWUpO1xuXG4gIGlmIChyZWFjdE5hbWUgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBTeW50aGV0aWNFdmVudEN0b3IgPSBTeW50aGV0aWNFdmVudDtcbiAgdmFyIHJlYWN0RXZlbnRUeXBlID0gZG9tRXZlbnROYW1lO1xuXG4gIHN3aXRjaCAoZG9tRXZlbnROYW1lKSB7XG4gICAgY2FzZSAna2V5cHJlc3MnOlxuICAgICAgLy8gRmlyZWZveCBjcmVhdGVzIGEga2V5cHJlc3MgZXZlbnQgZm9yIGZ1bmN0aW9uIGtleXMgdG9vLiBUaGlzIHJlbW92ZXNcbiAgICAgIC8vIHRoZSB1bndhbnRlZCBrZXlwcmVzcyBldmVudHMuIEVudGVyIGlzIGhvd2V2ZXIgYm90aCBwcmludGFibGUgYW5kXG4gICAgICAvLyBub24tcHJpbnRhYmxlLiBPbmUgd291bGQgZXhwZWN0IFRhYiB0byBiZSBhcyB3ZWxsIChidXQgaXQgaXNuJ3QpLlxuICAgICAgaWYgKGdldEV2ZW50Q2hhckNvZGUobmF0aXZlRXZlbnQpID09PSAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cblxuICAgIGNhc2UgJ2tleWRvd24nOlxuICAgIGNhc2UgJ2tleXVwJzpcbiAgICAgIFN5bnRoZXRpY0V2ZW50Q3RvciA9IFN5bnRoZXRpY0tleWJvYXJkRXZlbnQ7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ2ZvY3VzaW4nOlxuICAgICAgcmVhY3RFdmVudFR5cGUgPSAnZm9jdXMnO1xuICAgICAgU3ludGhldGljRXZlbnRDdG9yID0gU3ludGhldGljRm9jdXNFdmVudDtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnZm9jdXNvdXQnOlxuICAgICAgcmVhY3RFdmVudFR5cGUgPSAnYmx1cic7XG4gICAgICBTeW50aGV0aWNFdmVudEN0b3IgPSBTeW50aGV0aWNGb2N1c0V2ZW50O1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdiZWZvcmVibHVyJzpcbiAgICBjYXNlICdhZnRlcmJsdXInOlxuICAgICAgU3ludGhldGljRXZlbnRDdG9yID0gU3ludGhldGljRm9jdXNFdmVudDtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnY2xpY2snOlxuICAgICAgLy8gRmlyZWZveCBjcmVhdGVzIGEgY2xpY2sgZXZlbnQgb24gcmlnaHQgbW91c2UgY2xpY2tzLiBUaGlzIHJlbW92ZXMgdGhlXG4gICAgICAvLyB1bndhbnRlZCBjbGljayBldmVudHMuXG4gICAgICBpZiAobmF0aXZlRXZlbnQuYnV0dG9uID09PSAyKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cblxuICAgIGNhc2UgJ2F1eGNsaWNrJzpcbiAgICBjYXNlICdkYmxjbGljayc6XG4gICAgY2FzZSAnbW91c2Vkb3duJzpcbiAgICBjYXNlICdtb3VzZW1vdmUnOlxuICAgIGNhc2UgJ21vdXNldXAnOiAvLyBUT0RPOiBEaXNhYmxlZCBlbGVtZW50cyBzaG91bGQgbm90IHJlc3BvbmQgdG8gbW91c2UgZXZlbnRzXG5cbiAgICAvKiBmYWxscyB0aHJvdWdoICovXG5cbiAgICBjYXNlICdtb3VzZW91dCc6XG4gICAgY2FzZSAnbW91c2VvdmVyJzpcbiAgICBjYXNlICdjb250ZXh0bWVudSc6XG4gICAgICBTeW50aGV0aWNFdmVudEN0b3IgPSBTeW50aGV0aWNNb3VzZUV2ZW50O1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdkcmFnJzpcbiAgICBjYXNlICdkcmFnZW5kJzpcbiAgICBjYXNlICdkcmFnZW50ZXInOlxuICAgIGNhc2UgJ2RyYWdleGl0JzpcbiAgICBjYXNlICdkcmFnbGVhdmUnOlxuICAgIGNhc2UgJ2RyYWdvdmVyJzpcbiAgICBjYXNlICdkcmFnc3RhcnQnOlxuICAgIGNhc2UgJ2Ryb3AnOlxuICAgICAgU3ludGhldGljRXZlbnRDdG9yID0gU3ludGhldGljRHJhZ0V2ZW50O1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICd0b3VjaGNhbmNlbCc6XG4gICAgY2FzZSAndG91Y2hlbmQnOlxuICAgIGNhc2UgJ3RvdWNobW92ZSc6XG4gICAgY2FzZSAndG91Y2hzdGFydCc6XG4gICAgICBTeW50aGV0aWNFdmVudEN0b3IgPSBTeW50aGV0aWNUb3VjaEV2ZW50O1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIEFOSU1BVElPTl9FTkQ6XG4gICAgY2FzZSBBTklNQVRJT05fSVRFUkFUSU9OOlxuICAgIGNhc2UgQU5JTUFUSU9OX1NUQVJUOlxuICAgICAgU3ludGhldGljRXZlbnRDdG9yID0gU3ludGhldGljQW5pbWF0aW9uRXZlbnQ7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgVFJBTlNJVElPTl9FTkQ6XG4gICAgICBTeW50aGV0aWNFdmVudEN0b3IgPSBTeW50aGV0aWNUcmFuc2l0aW9uRXZlbnQ7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ3Njcm9sbCc6XG4gICAgICBTeW50aGV0aWNFdmVudEN0b3IgPSBTeW50aGV0aWNVSUV2ZW50O1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICd3aGVlbCc6XG4gICAgICBTeW50aGV0aWNFdmVudEN0b3IgPSBTeW50aGV0aWNXaGVlbEV2ZW50O1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdjb3B5JzpcbiAgICBjYXNlICdjdXQnOlxuICAgIGNhc2UgJ3Bhc3RlJzpcbiAgICAgIFN5bnRoZXRpY0V2ZW50Q3RvciA9IFN5bnRoZXRpY0NsaXBib2FyZEV2ZW50O1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdnb3Rwb2ludGVyY2FwdHVyZSc6XG4gICAgY2FzZSAnbG9zdHBvaW50ZXJjYXB0dXJlJzpcbiAgICBjYXNlICdwb2ludGVyY2FuY2VsJzpcbiAgICBjYXNlICdwb2ludGVyZG93bic6XG4gICAgY2FzZSAncG9pbnRlcm1vdmUnOlxuICAgIGNhc2UgJ3BvaW50ZXJvdXQnOlxuICAgIGNhc2UgJ3BvaW50ZXJvdmVyJzpcbiAgICBjYXNlICdwb2ludGVydXAnOlxuICAgICAgU3ludGhldGljRXZlbnRDdG9yID0gU3ludGhldGljUG9pbnRlckV2ZW50O1xuICAgICAgYnJlYWs7XG4gIH1cblxuICB2YXIgaW5DYXB0dXJlUGhhc2UgPSAoZXZlbnRTeXN0ZW1GbGFncyAmIElTX0NBUFRVUkVfUEhBU0UpICE9PSAwO1xuXG4gIHtcbiAgICAvLyBTb21lIGV2ZW50cyBkb24ndCBidWJibGUgaW4gdGhlIGJyb3dzZXIuXG4gICAgLy8gSW4gdGhlIHBhc3QsIFJlYWN0IGhhcyBhbHdheXMgYnViYmxlZCB0aGVtLCBidXQgdGhpcyBjYW4gYmUgc3VycHJpc2luZy5cbiAgICAvLyBXZSdyZSBnb2luZyB0byB0cnkgYWxpZ25pbmcgY2xvc2VyIHRvIHRoZSBicm93c2VyIGJlaGF2aW9yIGJ5IG5vdCBidWJibGluZ1xuICAgIC8vIHRoZW0gaW4gUmVhY3QgZWl0aGVyLiBXZSdsbCBzdGFydCBieSBub3QgYnViYmxpbmcgb25TY3JvbGwsIGFuZCB0aGVuIGV4cGFuZC5cbiAgICB2YXIgYWNjdW11bGF0ZVRhcmdldE9ubHkgPSAhaW5DYXB0dXJlUGhhc2UgJiYgLy8gVE9ETzogaWRlYWxseSwgd2UnZCBldmVudHVhbGx5IGFkZCBhbGwgZXZlbnRzIGZyb21cbiAgICAvLyBub25EZWxlZ2F0ZWRFdmVudHMgbGlzdCBpbiBET01QbHVnaW5FdmVudFN5c3RlbS5cbiAgICAvLyBUaGVuIHdlIGNhbiByZW1vdmUgdGhpcyBzcGVjaWFsIGxpc3QuXG4gICAgLy8gVGhpcyBpcyBhIGJyZWFraW5nIGNoYW5nZSB0aGF0IGNhbiB3YWl0IHVudGlsIFJlYWN0IDE4LlxuICAgIGRvbUV2ZW50TmFtZSA9PT0gJ3Njcm9sbCc7XG5cbiAgICB2YXIgX2xpc3RlbmVycyA9IGFjY3VtdWxhdGVTaW5nbGVQaGFzZUxpc3RlbmVycyh0YXJnZXRJbnN0LCByZWFjdE5hbWUsIG5hdGl2ZUV2ZW50LnR5cGUsIGluQ2FwdHVyZVBoYXNlLCBhY2N1bXVsYXRlVGFyZ2V0T25seSk7XG5cbiAgICBpZiAoX2xpc3RlbmVycy5sZW5ndGggPiAwKSB7XG4gICAgICAvLyBJbnRlbnRpb25hbGx5IGNyZWF0ZSBldmVudCBsYXppbHkuXG4gICAgICB2YXIgX2V2ZW50ID0gbmV3IFN5bnRoZXRpY0V2ZW50Q3RvcihyZWFjdE5hbWUsIHJlYWN0RXZlbnRUeXBlLCBudWxsLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xuXG4gICAgICBkaXNwYXRjaFF1ZXVlLnB1c2goe1xuICAgICAgICBldmVudDogX2V2ZW50LFxuICAgICAgICBsaXN0ZW5lcnM6IF9saXN0ZW5lcnNcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxufVxuXG4vLyBUT0RPOiByZW1vdmUgdG9wLWxldmVsIHNpZGUgZWZmZWN0LlxucmVnaXN0ZXJTaW1wbGVFdmVudHMoKTtcbnJlZ2lzdGVyRXZlbnRzJDIoKTtcbnJlZ2lzdGVyRXZlbnRzJDEoKTtcbnJlZ2lzdGVyRXZlbnRzJDMoKTtcbnJlZ2lzdGVyRXZlbnRzKCk7XG5cbmZ1bmN0aW9uIGV4dHJhY3RFdmVudHMkNShkaXNwYXRjaFF1ZXVlLCBkb21FdmVudE5hbWUsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCwgZXZlbnRTeXN0ZW1GbGFncywgdGFyZ2V0Q29udGFpbmVyKSB7XG4gIC8vIFRPRE86IHdlIHNob3VsZCByZW1vdmUgdGhlIGNvbmNlcHQgb2YgYSBcIlNpbXBsZUV2ZW50UGx1Z2luXCIuXG4gIC8vIFRoaXMgaXMgdGhlIGJhc2ljIGZ1bmN0aW9uYWxpdHkgb2YgdGhlIGV2ZW50IHN5c3RlbS4gQWxsXG4gIC8vIHRoZSBvdGhlciBwbHVnaW5zIGFyZSBlc3NlbnRpYWxseSBwb2x5ZmlsbHMuIFNvIHRoZSBwbHVnaW5cbiAgLy8gc2hvdWxkIHByb2JhYmx5IGJlIGlubGluZWQgc29tZXdoZXJlIGFuZCBoYXZlIGl0cyBsb2dpY1xuICAvLyBiZSBjb3JlIHRoZSB0byBldmVudCBzeXN0ZW0uIFRoaXMgd291bGQgcG90ZW50aWFsbHkgYWxsb3dcbiAgLy8gdXMgdG8gc2hpcCBidWlsZHMgb2YgUmVhY3Qgd2l0aG91dCB0aGUgcG9seWZpbGxlZCBwbHVnaW5zIGJlbG93LlxuICBleHRyYWN0RXZlbnRzJDQoZGlzcGF0Y2hRdWV1ZSwgZG9tRXZlbnROYW1lLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQsIGV2ZW50U3lzdGVtRmxhZ3MpO1xuICB2YXIgc2hvdWxkUHJvY2Vzc1BvbHlmaWxsUGx1Z2lucyA9IChldmVudFN5c3RlbUZsYWdzICYgU0hPVUxEX05PVF9QUk9DRVNTX1BPTFlGSUxMX0VWRU5UX1BMVUdJTlMpID09PSAwOyAvLyBXZSBkb24ndCBwcm9jZXNzIHRoZXNlIGV2ZW50cyB1bmxlc3Mgd2UgYXJlIGluIHRoZVxuICAvLyBldmVudCdzIG5hdGl2ZSBcImJ1YmJsZVwiIHBoYXNlLCB3aGljaCBtZWFucyB0aGF0IHdlJ3JlXG4gIC8vIG5vdCBpbiB0aGUgY2FwdHVyZSBwaGFzZS4gVGhhdCdzIGJlY2F1c2Ugd2UgZW11bGF0ZVxuICAvLyB0aGUgY2FwdHVyZSBwaGFzZSBoZXJlIHN0aWxsLiBUaGlzIGlzIGEgdHJhZGUtb2ZmLFxuICAvLyBiZWNhdXNlIGluIGFuIGlkZWFsIHdvcmxkIHdlIHdvdWxkIG5vdCBlbXVsYXRlIGFuZCB1c2VcbiAgLy8gdGhlIHBoYXNlcyBwcm9wZXJseSwgbGlrZSB3ZSBkbyB3aXRoIHRoZSBTaW1wbGVFdmVudFxuICAvLyBwbHVnaW4uIEhvd2V2ZXIsIHRoZSBwbHVnaW5zIGJlbG93IGVpdGhlciBleHBlY3RcbiAgLy8gZW11bGF0aW9uIChFbnRlckxlYXZlKSBvciB1c2Ugc3RhdGUgbG9jYWxpemVkIHRvIHRoYXRcbiAgLy8gcGx1Z2luIChCZWZvcmVJbnB1dCwgQ2hhbmdlLCBTZWxlY3QpLiBUaGUgc3RhdGUgaW5cbiAgLy8gdGhlc2UgbW9kdWxlcyBjb21wbGljYXRlcyB0aGluZ3MsIGFzIHlvdSdsbCBlc3NlbnRpYWxseVxuICAvLyBnZXQgdGhlIGNhc2Ugd2hlcmUgdGhlIGNhcHR1cmUgcGhhc2UgZXZlbnQgbWlnaHQgY2hhbmdlXG4gIC8vIHN0YXRlLCBvbmx5IGZvciB0aGUgZm9sbG93aW5nIGJ1YmJsZSBldmVudCB0byBjb21lIGluXG4gIC8vIGxhdGVyIGFuZCBub3QgdHJpZ2dlciBhbnl0aGluZyBhcyB0aGUgc3RhdGUgbm93XG4gIC8vIGludmFsaWRhdGVzIHRoZSBoZXVyaXN0aWNzIG9mIHRoZSBldmVudCBwbHVnaW4uIFdlXG4gIC8vIGNvdWxkIGFsdGVyIGFsbCB0aGVzZSBwbHVnaW5zIHRvIHdvcmsgaW4gc3VjaCB3YXlzLCBidXRcbiAgLy8gdGhhdCBtaWdodCBjYXVzZSBvdGhlciB1bmtub3duIHNpZGUtZWZmZWN0cyB0aGF0IHdlXG4gIC8vIGNhbid0IGZvcnNlZSByaWdodCBub3cuXG5cbiAgaWYgKHNob3VsZFByb2Nlc3NQb2x5ZmlsbFBsdWdpbnMpIHtcbiAgICBleHRyYWN0RXZlbnRzJDIoZGlzcGF0Y2hRdWV1ZSwgZG9tRXZlbnROYW1lLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQsIGV2ZW50U3lzdGVtRmxhZ3MpO1xuICAgIGV4dHJhY3RFdmVudHMkMShkaXNwYXRjaFF1ZXVlLCBkb21FdmVudE5hbWUsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG4gICAgZXh0cmFjdEV2ZW50cyQzKGRpc3BhdGNoUXVldWUsIGRvbUV2ZW50TmFtZSwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbiAgICBleHRyYWN0RXZlbnRzKGRpc3BhdGNoUXVldWUsIGRvbUV2ZW50TmFtZSwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbiAgfVxufSAvLyBMaXN0IG9mIGV2ZW50cyB0aGF0IG5lZWQgdG8gYmUgaW5kaXZpZHVhbGx5IGF0dGFjaGVkIHRvIG1lZGlhIGVsZW1lbnRzLlxuXG5cbnZhciBtZWRpYUV2ZW50VHlwZXMgPSBbJ2Fib3J0JywgJ2NhbnBsYXknLCAnY2FucGxheXRocm91Z2gnLCAnZHVyYXRpb25jaGFuZ2UnLCAnZW1wdGllZCcsICdlbmNyeXB0ZWQnLCAnZW5kZWQnLCAnZXJyb3InLCAnbG9hZGVkZGF0YScsICdsb2FkZWRtZXRhZGF0YScsICdsb2Fkc3RhcnQnLCAncGF1c2UnLCAncGxheScsICdwbGF5aW5nJywgJ3Byb2dyZXNzJywgJ3JhdGVjaGFuZ2UnLCAnc2Vla2VkJywgJ3NlZWtpbmcnLCAnc3RhbGxlZCcsICdzdXNwZW5kJywgJ3RpbWV1cGRhdGUnLCAndm9sdW1lY2hhbmdlJywgJ3dhaXRpbmcnXTsgLy8gV2Ugc2hvdWxkIG5vdCBkZWxlZ2F0ZSB0aGVzZSBldmVudHMgdG8gdGhlIGNvbnRhaW5lciwgYnV0IHJhdGhlclxuLy8gc2V0IHRoZW0gb24gdGhlIGFjdHVhbCB0YXJnZXQgZWxlbWVudCBpdHNlbGYuIFRoaXMgaXMgcHJpbWFyaWx5XG4vLyBiZWNhdXNlIHRoZXNlIGV2ZW50cyBkbyBub3QgY29uc2lzdGVudGx5IGJ1YmJsZSBpbiB0aGUgRE9NLlxuXG52YXIgbm9uRGVsZWdhdGVkRXZlbnRzID0gbmV3IFNldChbJ2NhbmNlbCcsICdjbG9zZScsICdpbnZhbGlkJywgJ2xvYWQnLCAnc2Nyb2xsJywgJ3RvZ2dsZSddLmNvbmNhdChtZWRpYUV2ZW50VHlwZXMpKTtcblxuZnVuY3Rpb24gZXhlY3V0ZURpc3BhdGNoKGV2ZW50LCBsaXN0ZW5lciwgY3VycmVudFRhcmdldCkge1xuICB2YXIgdHlwZSA9IGV2ZW50LnR5cGUgfHwgJ3Vua25vd24tZXZlbnQnO1xuICBldmVudC5jdXJyZW50VGFyZ2V0ID0gY3VycmVudFRhcmdldDtcbiAgaW52b2tlR3VhcmRlZENhbGxiYWNrQW5kQ2F0Y2hGaXJzdEVycm9yKHR5cGUsIGxpc3RlbmVyLCB1bmRlZmluZWQsIGV2ZW50KTtcbiAgZXZlbnQuY3VycmVudFRhcmdldCA9IG51bGw7XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NEaXNwYXRjaFF1ZXVlSXRlbXNJbk9yZGVyKGV2ZW50LCBkaXNwYXRjaExpc3RlbmVycywgaW5DYXB0dXJlUGhhc2UpIHtcbiAgdmFyIHByZXZpb3VzSW5zdGFuY2U7XG5cbiAgaWYgKGluQ2FwdHVyZVBoYXNlKSB7XG4gICAgZm9yICh2YXIgaSA9IGRpc3BhdGNoTGlzdGVuZXJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB2YXIgX2Rpc3BhdGNoTGlzdGVuZXJzJGkgPSBkaXNwYXRjaExpc3RlbmVyc1tpXSxcbiAgICAgICAgICBpbnN0YW5jZSA9IF9kaXNwYXRjaExpc3RlbmVycyRpLmluc3RhbmNlLFxuICAgICAgICAgIGN1cnJlbnRUYXJnZXQgPSBfZGlzcGF0Y2hMaXN0ZW5lcnMkaS5jdXJyZW50VGFyZ2V0LFxuICAgICAgICAgIGxpc3RlbmVyID0gX2Rpc3BhdGNoTGlzdGVuZXJzJGkubGlzdGVuZXI7XG5cbiAgICAgIGlmIChpbnN0YW5jZSAhPT0gcHJldmlvdXNJbnN0YW5jZSAmJiBldmVudC5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgZXhlY3V0ZURpc3BhdGNoKGV2ZW50LCBsaXN0ZW5lciwgY3VycmVudFRhcmdldCk7XG4gICAgICBwcmV2aW91c0luc3RhbmNlID0gaW5zdGFuY2U7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBkaXNwYXRjaExpc3RlbmVycy5sZW5ndGg7IF9pKyspIHtcbiAgICAgIHZhciBfZGlzcGF0Y2hMaXN0ZW5lcnMkX2kgPSBkaXNwYXRjaExpc3RlbmVyc1tfaV0sXG4gICAgICAgICAgX2luc3RhbmNlID0gX2Rpc3BhdGNoTGlzdGVuZXJzJF9pLmluc3RhbmNlLFxuICAgICAgICAgIF9jdXJyZW50VGFyZ2V0ID0gX2Rpc3BhdGNoTGlzdGVuZXJzJF9pLmN1cnJlbnRUYXJnZXQsXG4gICAgICAgICAgX2xpc3RlbmVyID0gX2Rpc3BhdGNoTGlzdGVuZXJzJF9pLmxpc3RlbmVyO1xuXG4gICAgICBpZiAoX2luc3RhbmNlICE9PSBwcmV2aW91c0luc3RhbmNlICYmIGV2ZW50LmlzUHJvcGFnYXRpb25TdG9wcGVkKCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBleGVjdXRlRGlzcGF0Y2goZXZlbnQsIF9saXN0ZW5lciwgX2N1cnJlbnRUYXJnZXQpO1xuICAgICAgcHJldmlvdXNJbnN0YW5jZSA9IF9pbnN0YW5jZTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJvY2Vzc0Rpc3BhdGNoUXVldWUoZGlzcGF0Y2hRdWV1ZSwgZXZlbnRTeXN0ZW1GbGFncykge1xuICB2YXIgaW5DYXB0dXJlUGhhc2UgPSAoZXZlbnRTeXN0ZW1GbGFncyAmIElTX0NBUFRVUkVfUEhBU0UpICE9PSAwO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZGlzcGF0Y2hRdWV1ZS5sZW5ndGg7IGkrKykge1xuICAgIHZhciBfZGlzcGF0Y2hRdWV1ZSRpID0gZGlzcGF0Y2hRdWV1ZVtpXSxcbiAgICAgICAgZXZlbnQgPSBfZGlzcGF0Y2hRdWV1ZSRpLmV2ZW50LFxuICAgICAgICBsaXN0ZW5lcnMgPSBfZGlzcGF0Y2hRdWV1ZSRpLmxpc3RlbmVycztcbiAgICBwcm9jZXNzRGlzcGF0Y2hRdWV1ZUl0ZW1zSW5PcmRlcihldmVudCwgbGlzdGVuZXJzLCBpbkNhcHR1cmVQaGFzZSk7IC8vICBldmVudCBzeXN0ZW0gZG9lc24ndCB1c2UgcG9vbGluZy5cbiAgfSAvLyBUaGlzIHdvdWxkIGJlIGEgZ29vZCB0aW1lIHRvIHJldGhyb3cgaWYgYW55IG9mIHRoZSBldmVudCBoYW5kbGVycyB0aHJldy5cblxuXG4gIHJldGhyb3dDYXVnaHRFcnJvcigpO1xufVxuXG5mdW5jdGlvbiBkaXNwYXRjaEV2ZW50c0ZvclBsdWdpbnMoZG9tRXZlbnROYW1lLCBldmVudFN5c3RlbUZsYWdzLCBuYXRpdmVFdmVudCwgdGFyZ2V0SW5zdCwgdGFyZ2V0Q29udGFpbmVyKSB7XG4gIHZhciBuYXRpdmVFdmVudFRhcmdldCA9IGdldEV2ZW50VGFyZ2V0KG5hdGl2ZUV2ZW50KTtcbiAgdmFyIGRpc3BhdGNoUXVldWUgPSBbXTtcbiAgZXh0cmFjdEV2ZW50cyQ1KGRpc3BhdGNoUXVldWUsIGRvbUV2ZW50TmFtZSwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0LCBldmVudFN5c3RlbUZsYWdzKTtcbiAgcHJvY2Vzc0Rpc3BhdGNoUXVldWUoZGlzcGF0Y2hRdWV1ZSwgZXZlbnRTeXN0ZW1GbGFncyk7XG59XG5cbmZ1bmN0aW9uIGxpc3RlblRvTm9uRGVsZWdhdGVkRXZlbnQoZG9tRXZlbnROYW1lLCB0YXJnZXRFbGVtZW50KSB7XG4gIHZhciBpc0NhcHR1cmVQaGFzZUxpc3RlbmVyID0gZmFsc2U7XG4gIHZhciBsaXN0ZW5lclNldCA9IGdldEV2ZW50TGlzdGVuZXJTZXQodGFyZ2V0RWxlbWVudCk7XG4gIHZhciBsaXN0ZW5lclNldEtleSA9IGdldExpc3RlbmVyU2V0S2V5KGRvbUV2ZW50TmFtZSwgaXNDYXB0dXJlUGhhc2VMaXN0ZW5lcik7XG5cbiAgaWYgKCFsaXN0ZW5lclNldC5oYXMobGlzdGVuZXJTZXRLZXkpKSB7XG4gICAgYWRkVHJhcHBlZEV2ZW50TGlzdGVuZXIodGFyZ2V0RWxlbWVudCwgZG9tRXZlbnROYW1lLCBJU19OT05fREVMRUdBVEVELCBpc0NhcHR1cmVQaGFzZUxpc3RlbmVyKTtcbiAgICBsaXN0ZW5lclNldC5hZGQobGlzdGVuZXJTZXRLZXkpO1xuICB9XG59XG52YXIgbGlzdGVuaW5nTWFya2VyID0gJ19yZWFjdExpc3RlbmluZycgKyBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zbGljZSgyKTtcbmZ1bmN0aW9uIGxpc3RlblRvQWxsU3VwcG9ydGVkRXZlbnRzKHJvb3RDb250YWluZXJFbGVtZW50KSB7XG4gIHtcbiAgICBpZiAocm9vdENvbnRhaW5lckVsZW1lbnRbbGlzdGVuaW5nTWFya2VyXSkge1xuICAgICAgLy8gUGVyZm9ybWFuY2Ugb3B0aW1pemF0aW9uOiBkb24ndCBpdGVyYXRlIHRocm91Z2ggZXZlbnRzXG4gICAgICAvLyBmb3IgdGhlIHNhbWUgcG9ydGFsIGNvbnRhaW5lciBvciByb290IG5vZGUgbW9yZSB0aGFuIG9uY2UuXG4gICAgICAvLyBUT0RPOiBvbmNlIHdlIHJlbW92ZSB0aGUgZmxhZywgd2UgbWF5IGJlIGFibGUgdG8gYWxzb1xuICAgICAgLy8gcmVtb3ZlIHNvbWUgb2YgdGhlIGJvb2trZWVwaW5nIG1hcHMgdXNlZCBmb3IgbGF6aW5lc3MuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgcm9vdENvbnRhaW5lckVsZW1lbnRbbGlzdGVuaW5nTWFya2VyXSA9IHRydWU7XG4gICAgYWxsTmF0aXZlRXZlbnRzLmZvckVhY2goZnVuY3Rpb24gKGRvbUV2ZW50TmFtZSkge1xuICAgICAgaWYgKCFub25EZWxlZ2F0ZWRFdmVudHMuaGFzKGRvbUV2ZW50TmFtZSkpIHtcbiAgICAgICAgbGlzdGVuVG9OYXRpdmVFdmVudChkb21FdmVudE5hbWUsIGZhbHNlLCByb290Q29udGFpbmVyRWxlbWVudCwgbnVsbCk7XG4gICAgICB9XG5cbiAgICAgIGxpc3RlblRvTmF0aXZlRXZlbnQoZG9tRXZlbnROYW1lLCB0cnVlLCByb290Q29udGFpbmVyRWxlbWVudCwgbnVsbCk7XG4gICAgfSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGxpc3RlblRvTmF0aXZlRXZlbnQoZG9tRXZlbnROYW1lLCBpc0NhcHR1cmVQaGFzZUxpc3RlbmVyLCByb290Q29udGFpbmVyRWxlbWVudCwgdGFyZ2V0RWxlbWVudCkge1xuICB2YXIgZXZlbnRTeXN0ZW1GbGFncyA9IGFyZ3VtZW50cy5sZW5ndGggPiA0ICYmIGFyZ3VtZW50c1s0XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzRdIDogMDtcbiAgdmFyIHRhcmdldCA9IHJvb3RDb250YWluZXJFbGVtZW50OyAvLyBzZWxlY3Rpb25jaGFuZ2UgbmVlZHMgdG8gYmUgYXR0YWNoZWQgdG8gdGhlIGRvY3VtZW50XG4gIC8vIG90aGVyd2lzZSBpdCB3b24ndCBjYXB0dXJlIGluY29taW5nIGV2ZW50cyB0aGF0IGFyZSBvbmx5XG4gIC8vIHRyaWdnZXJlZCBvbiB0aGUgZG9jdW1lbnQgZGlyZWN0bHkuXG5cbiAgaWYgKGRvbUV2ZW50TmFtZSA9PT0gJ3NlbGVjdGlvbmNoYW5nZScgJiYgcm9vdENvbnRhaW5lckVsZW1lbnQubm9kZVR5cGUgIT09IERPQ1VNRU5UX05PREUpIHtcbiAgICB0YXJnZXQgPSByb290Q29udGFpbmVyRWxlbWVudC5vd25lckRvY3VtZW50O1xuICB9IC8vIElmIHRoZSBldmVudCBjYW4gYmUgZGVsZWdhdGVkIChvciBpcyBjYXB0dXJlIHBoYXNlKSwgd2UgY2FuXG4gIC8vIHJlZ2lzdGVyIGl0IHRvIHRoZSByb290IGNvbnRhaW5lci4gT3RoZXJ3aXNlLCB3ZSBzaG91bGRcbiAgLy8gcmVnaXN0ZXIgdGhlIGV2ZW50IHRvIHRoZSB0YXJnZXQgZWxlbWVudCBhbmQgbWFyayBpdCBhc1xuICAvLyBhIG5vbi1kZWxlZ2F0ZWQgZXZlbnQuXG5cblxuICBpZiAodGFyZ2V0RWxlbWVudCAhPT0gbnVsbCAmJiAhaXNDYXB0dXJlUGhhc2VMaXN0ZW5lciAmJiBub25EZWxlZ2F0ZWRFdmVudHMuaGFzKGRvbUV2ZW50TmFtZSkpIHtcbiAgICAvLyBGb3IgYWxsIG5vbi1kZWxlZ2F0ZWQgZXZlbnRzLCBhcGFydCBmcm9tIHNjcm9sbCwgd2UgYXR0YWNoXG4gICAgLy8gdGhlaXIgZXZlbnQgbGlzdGVuZXJzIHRvIHRoZSByZXNwZWN0aXZlIGVsZW1lbnRzIHRoYXQgdGhlaXJcbiAgICAvLyBldmVudHMgZmlyZSBvbi4gVGhhdCBtZWFucyB3ZSBjYW4gc2tpcCB0aGlzIHN0ZXAsIGFzIGV2ZW50XG4gICAgLy8gbGlzdGVuZXIgaGFzIGFscmVhZHkgYmVlbiBhZGRlZCBwcmV2aW91c2x5LiBIb3dldmVyLCB3ZVxuICAgIC8vIHNwZWNpYWwgY2FzZSB0aGUgc2Nyb2xsIGV2ZW50IGJlY2F1c2UgdGhlIHJlYWxpdHkgaXMgdGhhdCBhbnlcbiAgICAvLyBlbGVtZW50IGNhbiBzY3JvbGwuXG4gICAgLy8gVE9ETzogaWRlYWxseSwgd2UnZCBldmVudHVhbGx5IGFwcGx5IHRoZSBzYW1lIGxvZ2ljIHRvIGFsbFxuICAgIC8vIGV2ZW50cyBmcm9tIHRoZSBub25EZWxlZ2F0ZWRFdmVudHMgbGlzdC4gVGhlbiB3ZSBjYW4gcmVtb3ZlXG4gICAgLy8gdGhpcyBzcGVjaWFsIGNhc2UgYW5kIHVzZSB0aGUgc2FtZSBsb2dpYyBmb3IgYWxsIGV2ZW50cy5cbiAgICBpZiAoZG9tRXZlbnROYW1lICE9PSAnc2Nyb2xsJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGV2ZW50U3lzdGVtRmxhZ3MgfD0gSVNfTk9OX0RFTEVHQVRFRDtcbiAgICB0YXJnZXQgPSB0YXJnZXRFbGVtZW50O1xuICB9XG5cbiAgdmFyIGxpc3RlbmVyU2V0ID0gZ2V0RXZlbnRMaXN0ZW5lclNldCh0YXJnZXQpO1xuICB2YXIgbGlzdGVuZXJTZXRLZXkgPSBnZXRMaXN0ZW5lclNldEtleShkb21FdmVudE5hbWUsIGlzQ2FwdHVyZVBoYXNlTGlzdGVuZXIpOyAvLyBJZiB0aGUgbGlzdGVuZXIgZW50cnkgaXMgZW1wdHkgb3Igd2Ugc2hvdWxkIHVwZ3JhZGUsIHRoZW5cbiAgLy8gd2UgbmVlZCB0byB0cmFwIGFuIGV2ZW50IGxpc3RlbmVyIG9udG8gdGhlIHRhcmdldC5cblxuICBpZiAoIWxpc3RlbmVyU2V0LmhhcyhsaXN0ZW5lclNldEtleSkpIHtcbiAgICBpZiAoaXNDYXB0dXJlUGhhc2VMaXN0ZW5lcikge1xuICAgICAgZXZlbnRTeXN0ZW1GbGFncyB8PSBJU19DQVBUVVJFX1BIQVNFO1xuICAgIH1cblxuICAgIGFkZFRyYXBwZWRFdmVudExpc3RlbmVyKHRhcmdldCwgZG9tRXZlbnROYW1lLCBldmVudFN5c3RlbUZsYWdzLCBpc0NhcHR1cmVQaGFzZUxpc3RlbmVyKTtcbiAgICBsaXN0ZW5lclNldC5hZGQobGlzdGVuZXJTZXRLZXkpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGFkZFRyYXBwZWRFdmVudExpc3RlbmVyKHRhcmdldENvbnRhaW5lciwgZG9tRXZlbnROYW1lLCBldmVudFN5c3RlbUZsYWdzLCBpc0NhcHR1cmVQaGFzZUxpc3RlbmVyLCBpc0RlZmVycmVkTGlzdGVuZXJGb3JMZWdhY3lGQlN1cHBvcnQpIHtcbiAgdmFyIGxpc3RlbmVyID0gY3JlYXRlRXZlbnRMaXN0ZW5lcldyYXBwZXJXaXRoUHJpb3JpdHkodGFyZ2V0Q29udGFpbmVyLCBkb21FdmVudE5hbWUsIGV2ZW50U3lzdGVtRmxhZ3MpOyAvLyBJZiBwYXNzaXZlIG9wdGlvbiBpcyBub3Qgc3VwcG9ydGVkLCB0aGVuIHRoZSBldmVudCB3aWxsIGJlXG4gIC8vIGFjdGl2ZSBhbmQgbm90IHBhc3NpdmUuXG5cbiAgdmFyIGlzUGFzc2l2ZUxpc3RlbmVyID0gdW5kZWZpbmVkO1xuXG4gIGlmIChwYXNzaXZlQnJvd3NlckV2ZW50c1N1cHBvcnRlZCkge1xuICAgIC8vIEJyb3dzZXJzIGludHJvZHVjZWQgYW4gaW50ZXJ2ZW50aW9uLCBtYWtpbmcgdGhlc2UgZXZlbnRzXG4gICAgLy8gcGFzc2l2ZSBieSBkZWZhdWx0IG9uIGRvY3VtZW50LiBSZWFjdCBkb2Vzbid0IGJpbmQgdGhlbVxuICAgIC8vIHRvIGRvY3VtZW50IGFueW1vcmUsIGJ1dCBjaGFuZ2luZyB0aGlzIG5vdyB3b3VsZCB1bmRvXG4gICAgLy8gdGhlIHBlcmZvcm1hbmNlIHdpbnMgZnJvbSB0aGUgY2hhbmdlLiBTbyB3ZSBlbXVsYXRlXG4gICAgLy8gdGhlIGV4aXN0aW5nIGJlaGF2aW9yIG1hbnVhbGx5IG9uIHRoZSByb290cyBub3cuXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xOTY1MVxuICAgIGlmIChkb21FdmVudE5hbWUgPT09ICd0b3VjaHN0YXJ0JyB8fCBkb21FdmVudE5hbWUgPT09ICd0b3VjaG1vdmUnIHx8IGRvbUV2ZW50TmFtZSA9PT0gJ3doZWVsJykge1xuICAgICAgaXNQYXNzaXZlTGlzdGVuZXIgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHRhcmdldENvbnRhaW5lciA9ICB0YXJnZXRDb250YWluZXI7XG4gIHZhciB1bnN1YnNjcmliZUxpc3RlbmVyOyAvLyBXaGVuIGxlZ2FjeUZCU3VwcG9ydCBpcyBlbmFibGVkLCBpdCdzIGZvciB3aGVuIHdlXG5cblxuICBpZiAoaXNDYXB0dXJlUGhhc2VMaXN0ZW5lcikge1xuICAgIGlmIChpc1Bhc3NpdmVMaXN0ZW5lciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB1bnN1YnNjcmliZUxpc3RlbmVyID0gYWRkRXZlbnRDYXB0dXJlTGlzdGVuZXJXaXRoUGFzc2l2ZUZsYWcodGFyZ2V0Q29udGFpbmVyLCBkb21FdmVudE5hbWUsIGxpc3RlbmVyLCBpc1Bhc3NpdmVMaXN0ZW5lcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHVuc3Vic2NyaWJlTGlzdGVuZXIgPSBhZGRFdmVudENhcHR1cmVMaXN0ZW5lcih0YXJnZXRDb250YWluZXIsIGRvbUV2ZW50TmFtZSwgbGlzdGVuZXIpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoaXNQYXNzaXZlTGlzdGVuZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdW5zdWJzY3JpYmVMaXN0ZW5lciA9IGFkZEV2ZW50QnViYmxlTGlzdGVuZXJXaXRoUGFzc2l2ZUZsYWcodGFyZ2V0Q29udGFpbmVyLCBkb21FdmVudE5hbWUsIGxpc3RlbmVyLCBpc1Bhc3NpdmVMaXN0ZW5lcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHVuc3Vic2NyaWJlTGlzdGVuZXIgPSBhZGRFdmVudEJ1YmJsZUxpc3RlbmVyKHRhcmdldENvbnRhaW5lciwgZG9tRXZlbnROYW1lLCBsaXN0ZW5lcik7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGlzTWF0Y2hpbmdSb290Q29udGFpbmVyKGdyYW5kQ29udGFpbmVyLCB0YXJnZXRDb250YWluZXIpIHtcbiAgcmV0dXJuIGdyYW5kQ29udGFpbmVyID09PSB0YXJnZXRDb250YWluZXIgfHwgZ3JhbmRDb250YWluZXIubm9kZVR5cGUgPT09IENPTU1FTlRfTk9ERSAmJiBncmFuZENvbnRhaW5lci5wYXJlbnROb2RlID09PSB0YXJnZXRDb250YWluZXI7XG59XG5cbmZ1bmN0aW9uIGRpc3BhdGNoRXZlbnRGb3JQbHVnaW5FdmVudFN5c3RlbShkb21FdmVudE5hbWUsIGV2ZW50U3lzdGVtRmxhZ3MsIG5hdGl2ZUV2ZW50LCB0YXJnZXRJbnN0LCB0YXJnZXRDb250YWluZXIpIHtcbiAgdmFyIGFuY2VzdG9ySW5zdCA9IHRhcmdldEluc3Q7XG5cbiAgaWYgKChldmVudFN5c3RlbUZsYWdzICYgSVNfRVZFTlRfSEFORExFX05PTl9NQU5BR0VEX05PREUpID09PSAwICYmIChldmVudFN5c3RlbUZsYWdzICYgSVNfTk9OX0RFTEVHQVRFRCkgPT09IDApIHtcbiAgICB2YXIgdGFyZ2V0Q29udGFpbmVyTm9kZSA9IHRhcmdldENvbnRhaW5lcjsgLy8gSWYgd2UgYXJlIHVzaW5nIHRoZSBsZWdhY3kgRkIgc3VwcG9ydCBmbGFnLCB3ZVxuXG4gICAgaWYgKHRhcmdldEluc3QgIT09IG51bGwpIHtcbiAgICAgIC8vIFRoZSBiZWxvdyBsb2dpYyBhdHRlbXB0cyB0byB3b3JrIG91dCBpZiB3ZSBuZWVkIHRvIGNoYW5nZVxuICAgICAgLy8gdGhlIHRhcmdldCBmaWJlciB0byBhIGRpZmZlcmVudCBhbmNlc3Rvci4gV2UgaGFkIHNpbWlsYXIgbG9naWNcbiAgICAgIC8vIGluIHRoZSBsZWdhY3kgZXZlbnQgc3lzdGVtLCBleGNlcHQgdGhlIGJpZyBkaWZmZXJlbmNlIGJldHdlZW5cbiAgICAgIC8vIHN5c3RlbXMgaXMgdGhhdCB0aGUgbW9kZXJuIGV2ZW50IHN5c3RlbSBub3cgaGFzIGFuIGV2ZW50IGxpc3RlbmVyXG4gICAgICAvLyBhdHRhY2hlZCB0byBlYWNoIFJlYWN0IFJvb3QgYW5kIFJlYWN0IFBvcnRhbCBSb290LiBUb2dldGhlcixcbiAgICAgIC8vIHRoZSBET00gbm9kZXMgcmVwcmVzZW50aW5nIHRoZXNlIHJvb3RzIGFyZSB0aGUgXCJyb290Q29udGFpbmVyXCIuXG4gICAgICAvLyBUbyBmaWd1cmUgb3V0IHdoaWNoIGFuY2VzdG9yIGluc3RhbmNlIHdlIHNob3VsZCB1c2UsIHdlIHRyYXZlcnNlXG4gICAgICAvLyB1cCB0aGUgZmliZXIgdHJlZSBmcm9tIHRoZSB0YXJnZXQgaW5zdGFuY2UgYW5kIGF0dGVtcHQgdG8gZmluZFxuICAgICAgLy8gcm9vdCBib3VuZGFyaWVzIHRoYXQgbWF0Y2ggdGhhdCBvZiBvdXIgY3VycmVudCBcInJvb3RDb250YWluZXJcIi5cbiAgICAgIC8vIElmIHdlIGZpbmQgdGhhdCBcInJvb3RDb250YWluZXJcIiwgd2UgZmluZCB0aGUgcGFyZW50IGZpYmVyXG4gICAgICAvLyBzdWItdHJlZSBmb3IgdGhhdCByb290IGFuZCBtYWtlIHRoYXQgb3VyIGFuY2VzdG9yIGluc3RhbmNlLlxuICAgICAgdmFyIG5vZGUgPSB0YXJnZXRJbnN0O1xuXG4gICAgICBtYWluTG9vcDogd2hpbGUgKHRydWUpIHtcbiAgICAgICAgaWYgKG5vZGUgPT09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbm9kZVRhZyA9IG5vZGUudGFnO1xuXG4gICAgICAgIGlmIChub2RlVGFnID09PSBIb3N0Um9vdCB8fCBub2RlVGFnID09PSBIb3N0UG9ydGFsKSB7XG4gICAgICAgICAgdmFyIGNvbnRhaW5lciA9IG5vZGUuc3RhdGVOb2RlLmNvbnRhaW5lckluZm87XG5cbiAgICAgICAgICBpZiAoaXNNYXRjaGluZ1Jvb3RDb250YWluZXIoY29udGFpbmVyLCB0YXJnZXRDb250YWluZXJOb2RlKSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKG5vZGVUYWcgPT09IEhvc3RQb3J0YWwpIHtcbiAgICAgICAgICAgIC8vIFRoZSB0YXJnZXQgaXMgYSBwb3J0YWwsIGJ1dCBpdCdzIG5vdCB0aGUgcm9vdENvbnRhaW5lciB3ZSdyZSBsb29raW5nIGZvci5cbiAgICAgICAgICAgIC8vIE5vcm1hbGx5IHBvcnRhbHMgaGFuZGxlIHRoZWlyIG93biBldmVudHMgYWxsIHRoZSB3YXkgZG93biB0byB0aGUgcm9vdC5cbiAgICAgICAgICAgIC8vIFNvIHdlIHNob3VsZCBiZSBhYmxlIHRvIHN0b3Agbm93LiBIb3dldmVyLCB3ZSBkb24ndCBrbm93IGlmIHRoaXMgcG9ydGFsXG4gICAgICAgICAgICAvLyB3YXMgcGFydCBvZiAqb3VyKiByb290LlxuICAgICAgICAgICAgdmFyIGdyYW5kTm9kZSA9IG5vZGUucmV0dXJuO1xuXG4gICAgICAgICAgICB3aGlsZSAoZ3JhbmROb2RlICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIHZhciBncmFuZFRhZyA9IGdyYW5kTm9kZS50YWc7XG5cbiAgICAgICAgICAgICAgaWYgKGdyYW5kVGFnID09PSBIb3N0Um9vdCB8fCBncmFuZFRhZyA9PT0gSG9zdFBvcnRhbCkge1xuICAgICAgICAgICAgICAgIHZhciBncmFuZENvbnRhaW5lciA9IGdyYW5kTm9kZS5zdGF0ZU5vZGUuY29udGFpbmVySW5mbztcblxuICAgICAgICAgICAgICAgIGlmIChpc01hdGNoaW5nUm9vdENvbnRhaW5lcihncmFuZENvbnRhaW5lciwgdGFyZ2V0Q29udGFpbmVyTm9kZSkpIHtcbiAgICAgICAgICAgICAgICAgIC8vIFRoaXMgaXMgdGhlIHJvb3RDb250YWluZXIgd2UncmUgbG9va2luZyBmb3IgYW5kIHdlIGZvdW5kIGl0IGFzXG4gICAgICAgICAgICAgICAgICAvLyBhIHBhcmVudCBvZiB0aGUgUG9ydGFsLiBUaGF0IG1lYW5zIHdlIGNhbiBpZ25vcmUgaXQgYmVjYXVzZSB0aGVcbiAgICAgICAgICAgICAgICAgIC8vIFBvcnRhbCB3aWxsIGJ1YmJsZSB0aHJvdWdoIHRvIHVzLlxuICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGdyYW5kTm9kZSA9IGdyYW5kTm9kZS5yZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSAvLyBOb3cgd2UgbmVlZCB0byBmaW5kIGl0J3MgY29ycmVzcG9uZGluZyBob3N0IGZpYmVyIGluIHRoZSBvdGhlclxuICAgICAgICAgIC8vIHRyZWUuIFRvIGRvIHRoaXMgd2UgY2FuIHVzZSBnZXRDbG9zZXN0SW5zdGFuY2VGcm9tTm9kZSwgYnV0IHdlXG4gICAgICAgICAgLy8gbmVlZCB0byB2YWxpZGF0ZSB0aGF0IHRoZSBmaWJlciBpcyBhIGhvc3QgaW5zdGFuY2UsIG90aGVyd2lzZVxuICAgICAgICAgIC8vIHdlIG5lZWQgdG8gdHJhdmVyc2UgdXAgdGhyb3VnaCB0aGUgRE9NIHRpbGwgd2UgZmluZCB0aGUgY29ycmVjdFxuICAgICAgICAgIC8vIG5vZGUgdGhhdCBpcyBmcm9tIHRoZSBvdGhlciB0cmVlLlxuXG5cbiAgICAgICAgICB3aGlsZSAoY29udGFpbmVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgcGFyZW50Tm9kZSA9IGdldENsb3Nlc3RJbnN0YW5jZUZyb21Ob2RlKGNvbnRhaW5lcik7XG5cbiAgICAgICAgICAgIGlmIChwYXJlbnROb2RlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHBhcmVudFRhZyA9IHBhcmVudE5vZGUudGFnO1xuXG4gICAgICAgICAgICBpZiAocGFyZW50VGFnID09PSBIb3N0Q29tcG9uZW50IHx8IHBhcmVudFRhZyA9PT0gSG9zdFRleHQpIHtcbiAgICAgICAgICAgICAgbm9kZSA9IGFuY2VzdG9ySW5zdCA9IHBhcmVudE5vZGU7XG4gICAgICAgICAgICAgIGNvbnRpbnVlIG1haW5Mb29wO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb250YWluZXIgPSBjb250YWluZXIucGFyZW50Tm9kZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBub2RlID0gbm9kZS5yZXR1cm47XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgYmF0Y2hlZEV2ZW50VXBkYXRlcyhmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGRpc3BhdGNoRXZlbnRzRm9yUGx1Z2lucyhkb21FdmVudE5hbWUsIGV2ZW50U3lzdGVtRmxhZ3MsIG5hdGl2ZUV2ZW50LCBhbmNlc3Rvckluc3QpO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlRGlzcGF0Y2hMaXN0ZW5lcihpbnN0YW5jZSwgbGlzdGVuZXIsIGN1cnJlbnRUYXJnZXQpIHtcbiAgcmV0dXJuIHtcbiAgICBpbnN0YW5jZTogaW5zdGFuY2UsXG4gICAgbGlzdGVuZXI6IGxpc3RlbmVyLFxuICAgIGN1cnJlbnRUYXJnZXQ6IGN1cnJlbnRUYXJnZXRcbiAgfTtcbn1cblxuZnVuY3Rpb24gYWNjdW11bGF0ZVNpbmdsZVBoYXNlTGlzdGVuZXJzKHRhcmdldEZpYmVyLCByZWFjdE5hbWUsIG5hdGl2ZUV2ZW50VHlwZSwgaW5DYXB0dXJlUGhhc2UsIGFjY3VtdWxhdGVUYXJnZXRPbmx5KSB7XG4gIHZhciBjYXB0dXJlTmFtZSA9IHJlYWN0TmFtZSAhPT0gbnVsbCA/IHJlYWN0TmFtZSArICdDYXB0dXJlJyA6IG51bGw7XG4gIHZhciByZWFjdEV2ZW50TmFtZSA9IGluQ2FwdHVyZVBoYXNlID8gY2FwdHVyZU5hbWUgOiByZWFjdE5hbWU7XG4gIHZhciBsaXN0ZW5lcnMgPSBbXTtcbiAgdmFyIGluc3RhbmNlID0gdGFyZ2V0RmliZXI7XG4gIHZhciBsYXN0SG9zdENvbXBvbmVudCA9IG51bGw7IC8vIEFjY3VtdWxhdGUgYWxsIGluc3RhbmNlcyBhbmQgbGlzdGVuZXJzIHZpYSB0aGUgdGFyZ2V0IC0+IHJvb3QgcGF0aC5cblxuICB3aGlsZSAoaW5zdGFuY2UgIT09IG51bGwpIHtcbiAgICB2YXIgX2luc3RhbmNlMiA9IGluc3RhbmNlLFxuICAgICAgICBzdGF0ZU5vZGUgPSBfaW5zdGFuY2UyLnN0YXRlTm9kZSxcbiAgICAgICAgdGFnID0gX2luc3RhbmNlMi50YWc7IC8vIEhhbmRsZSBsaXN0ZW5lcnMgdGhhdCBhcmUgb24gSG9zdENvbXBvbmVudHMgKGkuZS4gPGRpdj4pXG5cbiAgICBpZiAodGFnID09PSBIb3N0Q29tcG9uZW50ICYmIHN0YXRlTm9kZSAhPT0gbnVsbCkge1xuICAgICAgbGFzdEhvc3RDb21wb25lbnQgPSBzdGF0ZU5vZGU7IC8vIGNyZWF0ZUV2ZW50SGFuZGxlIGxpc3RlbmVyc1xuXG5cbiAgICAgIGlmIChyZWFjdEV2ZW50TmFtZSAhPT0gbnVsbCkge1xuICAgICAgICB2YXIgbGlzdGVuZXIgPSBnZXRMaXN0ZW5lcihpbnN0YW5jZSwgcmVhY3RFdmVudE5hbWUpO1xuXG4gICAgICAgIGlmIChsaXN0ZW5lciAhPSBudWxsKSB7XG4gICAgICAgICAgbGlzdGVuZXJzLnB1c2goY3JlYXRlRGlzcGF0Y2hMaXN0ZW5lcihpbnN0YW5jZSwgbGlzdGVuZXIsIGxhc3RIb3N0Q29tcG9uZW50KSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IC8vIElmIHdlIGFyZSBvbmx5IGFjY3VtdWxhdGluZyBldmVudHMgZm9yIHRoZSB0YXJnZXQsIHRoZW4gd2UgZG9uJ3RcbiAgICAvLyBjb250aW51ZSB0byBwcm9wYWdhdGUgdGhyb3VnaCB0aGUgUmVhY3QgZmliZXIgdHJlZSB0byBmaW5kIG90aGVyXG4gICAgLy8gbGlzdGVuZXJzLlxuXG5cbiAgICBpZiAoYWNjdW11bGF0ZVRhcmdldE9ubHkpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGluc3RhbmNlID0gaW5zdGFuY2UucmV0dXJuO1xuICB9XG5cbiAgcmV0dXJuIGxpc3RlbmVycztcbn0gLy8gV2Ugc2hvdWxkIG9ubHkgdXNlIHRoaXMgZnVuY3Rpb24gZm9yOlxuLy8gLSBCZWZvcmVJbnB1dEV2ZW50UGx1Z2luXG4vLyAtIENoYW5nZUV2ZW50UGx1Z2luXG4vLyAtIFNlbGVjdEV2ZW50UGx1Z2luXG4vLyBUaGlzIGlzIGJlY2F1c2Ugd2Ugb25seSBwcm9jZXNzIHRoZXNlIHBsdWdpbnNcbi8vIGluIHRoZSBidWJibGUgcGhhc2UsIHNvIHdlIG5lZWQgdG8gYWNjdW11bGF0ZSB0d29cbi8vIHBoYXNlIGV2ZW50IGxpc3RlbmVycyAodmlhIGVtdWxhdGlvbikuXG5cbmZ1bmN0aW9uIGFjY3VtdWxhdGVUd29QaGFzZUxpc3RlbmVycyh0YXJnZXRGaWJlciwgcmVhY3ROYW1lKSB7XG4gIHZhciBjYXB0dXJlTmFtZSA9IHJlYWN0TmFtZSArICdDYXB0dXJlJztcbiAgdmFyIGxpc3RlbmVycyA9IFtdO1xuICB2YXIgaW5zdGFuY2UgPSB0YXJnZXRGaWJlcjsgLy8gQWNjdW11bGF0ZSBhbGwgaW5zdGFuY2VzIGFuZCBsaXN0ZW5lcnMgdmlhIHRoZSB0YXJnZXQgLT4gcm9vdCBwYXRoLlxuXG4gIHdoaWxlIChpbnN0YW5jZSAhPT0gbnVsbCkge1xuICAgIHZhciBfaW5zdGFuY2UzID0gaW5zdGFuY2UsXG4gICAgICAgIHN0YXRlTm9kZSA9IF9pbnN0YW5jZTMuc3RhdGVOb2RlLFxuICAgICAgICB0YWcgPSBfaW5zdGFuY2UzLnRhZzsgLy8gSGFuZGxlIGxpc3RlbmVycyB0aGF0IGFyZSBvbiBIb3N0Q29tcG9uZW50cyAoaS5lLiA8ZGl2PilcblxuICAgIGlmICh0YWcgPT09IEhvc3RDb21wb25lbnQgJiYgc3RhdGVOb2RlICE9PSBudWxsKSB7XG4gICAgICB2YXIgY3VycmVudFRhcmdldCA9IHN0YXRlTm9kZTtcbiAgICAgIHZhciBjYXB0dXJlTGlzdGVuZXIgPSBnZXRMaXN0ZW5lcihpbnN0YW5jZSwgY2FwdHVyZU5hbWUpO1xuXG4gICAgICBpZiAoY2FwdHVyZUxpc3RlbmVyICE9IG51bGwpIHtcbiAgICAgICAgbGlzdGVuZXJzLnVuc2hpZnQoY3JlYXRlRGlzcGF0Y2hMaXN0ZW5lcihpbnN0YW5jZSwgY2FwdHVyZUxpc3RlbmVyLCBjdXJyZW50VGFyZ2V0KSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBidWJibGVMaXN0ZW5lciA9IGdldExpc3RlbmVyKGluc3RhbmNlLCByZWFjdE5hbWUpO1xuXG4gICAgICBpZiAoYnViYmxlTGlzdGVuZXIgIT0gbnVsbCkge1xuICAgICAgICBsaXN0ZW5lcnMucHVzaChjcmVhdGVEaXNwYXRjaExpc3RlbmVyKGluc3RhbmNlLCBidWJibGVMaXN0ZW5lciwgY3VycmVudFRhcmdldCkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGluc3RhbmNlID0gaW5zdGFuY2UucmV0dXJuO1xuICB9XG5cbiAgcmV0dXJuIGxpc3RlbmVycztcbn1cblxuZnVuY3Rpb24gZ2V0UGFyZW50KGluc3QpIHtcbiAgaWYgKGluc3QgPT09IG51bGwpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGRvIHtcbiAgICBpbnN0ID0gaW5zdC5yZXR1cm47IC8vIFRPRE86IElmIHRoaXMgaXMgYSBIb3N0Um9vdCB3ZSBtaWdodCB3YW50IHRvIGJhaWwgb3V0LlxuICAgIC8vIFRoYXQgaXMgZGVwZW5kaW5nIG9uIGlmIHdlIHdhbnQgbmVzdGVkIHN1YnRyZWVzIChsYXllcnMpIHRvIGJ1YmJsZVxuICAgIC8vIGV2ZW50cyB0byB0aGVpciBwYXJlbnQuIFdlIGNvdWxkIGFsc28gZ28gdGhyb3VnaCBwYXJlbnROb2RlIG9uIHRoZVxuICAgIC8vIGhvc3Qgbm9kZSBidXQgdGhhdCB3b3VsZG4ndCB3b3JrIGZvciBSZWFjdCBOYXRpdmUgYW5kIGRvZXNuJ3QgbGV0IHVzXG4gICAgLy8gZG8gdGhlIHBvcnRhbCBmZWF0dXJlLlxuICB9IHdoaWxlIChpbnN0ICYmIGluc3QudGFnICE9PSBIb3N0Q29tcG9uZW50KTtcblxuICBpZiAoaW5zdCkge1xuICAgIHJldHVybiBpbnN0O1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG4vKipcbiAqIFJldHVybiB0aGUgbG93ZXN0IGNvbW1vbiBhbmNlc3RvciBvZiBBIGFuZCBCLCBvciBudWxsIGlmIHRoZXkgYXJlIGluXG4gKiBkaWZmZXJlbnQgdHJlZXMuXG4gKi9cblxuXG5mdW5jdGlvbiBnZXRMb3dlc3RDb21tb25BbmNlc3RvcihpbnN0QSwgaW5zdEIpIHtcbiAgdmFyIG5vZGVBID0gaW5zdEE7XG4gIHZhciBub2RlQiA9IGluc3RCO1xuICB2YXIgZGVwdGhBID0gMDtcblxuICBmb3IgKHZhciB0ZW1wQSA9IG5vZGVBOyB0ZW1wQTsgdGVtcEEgPSBnZXRQYXJlbnQodGVtcEEpKSB7XG4gICAgZGVwdGhBKys7XG4gIH1cblxuICB2YXIgZGVwdGhCID0gMDtcblxuICBmb3IgKHZhciB0ZW1wQiA9IG5vZGVCOyB0ZW1wQjsgdGVtcEIgPSBnZXRQYXJlbnQodGVtcEIpKSB7XG4gICAgZGVwdGhCKys7XG4gIH0gLy8gSWYgQSBpcyBkZWVwZXIsIGNyYXdsIHVwLlxuXG5cbiAgd2hpbGUgKGRlcHRoQSAtIGRlcHRoQiA+IDApIHtcbiAgICBub2RlQSA9IGdldFBhcmVudChub2RlQSk7XG4gICAgZGVwdGhBLS07XG4gIH0gLy8gSWYgQiBpcyBkZWVwZXIsIGNyYXdsIHVwLlxuXG5cbiAgd2hpbGUgKGRlcHRoQiAtIGRlcHRoQSA+IDApIHtcbiAgICBub2RlQiA9IGdldFBhcmVudChub2RlQik7XG4gICAgZGVwdGhCLS07XG4gIH0gLy8gV2FsayBpbiBsb2Nrc3RlcCB1bnRpbCB3ZSBmaW5kIGEgbWF0Y2guXG5cblxuICB2YXIgZGVwdGggPSBkZXB0aEE7XG5cbiAgd2hpbGUgKGRlcHRoLS0pIHtcbiAgICBpZiAobm9kZUEgPT09IG5vZGVCIHx8IG5vZGVCICE9PSBudWxsICYmIG5vZGVBID09PSBub2RlQi5hbHRlcm5hdGUpIHtcbiAgICAgIHJldHVybiBub2RlQTtcbiAgICB9XG5cbiAgICBub2RlQSA9IGdldFBhcmVudChub2RlQSk7XG4gICAgbm9kZUIgPSBnZXRQYXJlbnQobm9kZUIpO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIGFjY3VtdWxhdGVFbnRlckxlYXZlTGlzdGVuZXJzRm9yRXZlbnQoZGlzcGF0Y2hRdWV1ZSwgZXZlbnQsIHRhcmdldCwgY29tbW9uLCBpbkNhcHR1cmVQaGFzZSkge1xuICB2YXIgcmVnaXN0cmF0aW9uTmFtZSA9IGV2ZW50Ll9yZWFjdE5hbWU7XG4gIHZhciBsaXN0ZW5lcnMgPSBbXTtcbiAgdmFyIGluc3RhbmNlID0gdGFyZ2V0O1xuXG4gIHdoaWxlIChpbnN0YW5jZSAhPT0gbnVsbCkge1xuICAgIGlmIChpbnN0YW5jZSA9PT0gY29tbW9uKSB7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICB2YXIgX2luc3RhbmNlNCA9IGluc3RhbmNlLFxuICAgICAgICBhbHRlcm5hdGUgPSBfaW5zdGFuY2U0LmFsdGVybmF0ZSxcbiAgICAgICAgc3RhdGVOb2RlID0gX2luc3RhbmNlNC5zdGF0ZU5vZGUsXG4gICAgICAgIHRhZyA9IF9pbnN0YW5jZTQudGFnO1xuXG4gICAgaWYgKGFsdGVybmF0ZSAhPT0gbnVsbCAmJiBhbHRlcm5hdGUgPT09IGNvbW1vbikge1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgaWYgKHRhZyA9PT0gSG9zdENvbXBvbmVudCAmJiBzdGF0ZU5vZGUgIT09IG51bGwpIHtcbiAgICAgIHZhciBjdXJyZW50VGFyZ2V0ID0gc3RhdGVOb2RlO1xuXG4gICAgICBpZiAoaW5DYXB0dXJlUGhhc2UpIHtcbiAgICAgICAgdmFyIGNhcHR1cmVMaXN0ZW5lciA9IGdldExpc3RlbmVyKGluc3RhbmNlLCByZWdpc3RyYXRpb25OYW1lKTtcblxuICAgICAgICBpZiAoY2FwdHVyZUxpc3RlbmVyICE9IG51bGwpIHtcbiAgICAgICAgICBsaXN0ZW5lcnMudW5zaGlmdChjcmVhdGVEaXNwYXRjaExpc3RlbmVyKGluc3RhbmNlLCBjYXB0dXJlTGlzdGVuZXIsIGN1cnJlbnRUYXJnZXQpKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICghaW5DYXB0dXJlUGhhc2UpIHtcbiAgICAgICAgdmFyIGJ1YmJsZUxpc3RlbmVyID0gZ2V0TGlzdGVuZXIoaW5zdGFuY2UsIHJlZ2lzdHJhdGlvbk5hbWUpO1xuXG4gICAgICAgIGlmIChidWJibGVMaXN0ZW5lciAhPSBudWxsKSB7XG4gICAgICAgICAgbGlzdGVuZXJzLnB1c2goY3JlYXRlRGlzcGF0Y2hMaXN0ZW5lcihpbnN0YW5jZSwgYnViYmxlTGlzdGVuZXIsIGN1cnJlbnRUYXJnZXQpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGluc3RhbmNlID0gaW5zdGFuY2UucmV0dXJuO1xuICB9XG5cbiAgaWYgKGxpc3RlbmVycy5sZW5ndGggIT09IDApIHtcbiAgICBkaXNwYXRjaFF1ZXVlLnB1c2goe1xuICAgICAgZXZlbnQ6IGV2ZW50LFxuICAgICAgbGlzdGVuZXJzOiBsaXN0ZW5lcnNcbiAgICB9KTtcbiAgfVxufSAvLyBXZSBzaG91bGQgb25seSB1c2UgdGhpcyBmdW5jdGlvbiBmb3I6XG4vLyAtIEVudGVyTGVhdmVFdmVudFBsdWdpblxuLy8gVGhpcyBpcyBiZWNhdXNlIHdlIG9ubHkgcHJvY2VzcyB0aGlzIHBsdWdpblxuLy8gaW4gdGhlIGJ1YmJsZSBwaGFzZSwgc28gd2UgbmVlZCB0byBhY2N1bXVsYXRlIHR3b1xuLy8gcGhhc2UgZXZlbnQgbGlzdGVuZXJzLlxuXG5cbmZ1bmN0aW9uIGFjY3VtdWxhdGVFbnRlckxlYXZlVHdvUGhhc2VMaXN0ZW5lcnMoZGlzcGF0Y2hRdWV1ZSwgbGVhdmVFdmVudCwgZW50ZXJFdmVudCwgZnJvbSwgdG8pIHtcbiAgdmFyIGNvbW1vbiA9IGZyb20gJiYgdG8gPyBnZXRMb3dlc3RDb21tb25BbmNlc3Rvcihmcm9tLCB0bykgOiBudWxsO1xuXG4gIGlmIChmcm9tICE9PSBudWxsKSB7XG4gICAgYWNjdW11bGF0ZUVudGVyTGVhdmVMaXN0ZW5lcnNGb3JFdmVudChkaXNwYXRjaFF1ZXVlLCBsZWF2ZUV2ZW50LCBmcm9tLCBjb21tb24sIGZhbHNlKTtcbiAgfVxuXG4gIGlmICh0byAhPT0gbnVsbCAmJiBlbnRlckV2ZW50ICE9PSBudWxsKSB7XG4gICAgYWNjdW11bGF0ZUVudGVyTGVhdmVMaXN0ZW5lcnNGb3JFdmVudChkaXNwYXRjaFF1ZXVlLCBlbnRlckV2ZW50LCB0bywgY29tbW9uLCB0cnVlKTtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0TGlzdGVuZXJTZXRLZXkoZG9tRXZlbnROYW1lLCBjYXB0dXJlKSB7XG4gIHJldHVybiBkb21FdmVudE5hbWUgKyBcIl9fXCIgKyAoY2FwdHVyZSA/ICdjYXB0dXJlJyA6ICdidWJibGUnKTtcbn1cblxudmFyIGRpZFdhcm5JbnZhbGlkSHlkcmF0aW9uID0gZmFsc2U7XG52YXIgREFOR0VST1VTTFlfU0VUX0lOTkVSX0hUTUwgPSAnZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwnO1xudmFyIFNVUFBSRVNTX0NPTlRFTlRfRURJVEFCTEVfV0FSTklORyA9ICdzdXBwcmVzc0NvbnRlbnRFZGl0YWJsZVdhcm5pbmcnO1xudmFyIFNVUFBSRVNTX0hZRFJBVElPTl9XQVJOSU5HID0gJ3N1cHByZXNzSHlkcmF0aW9uV2FybmluZyc7XG52YXIgQVVUT0ZPQ1VTID0gJ2F1dG9Gb2N1cyc7XG52YXIgQ0hJTERSRU4gPSAnY2hpbGRyZW4nO1xudmFyIFNUWUxFID0gJ3N0eWxlJztcbnZhciBIVE1MJDEgPSAnX19odG1sJztcbnZhciBIVE1MX05BTUVTUEFDRSQxID0gTmFtZXNwYWNlcy5odG1sO1xudmFyIHdhcm5lZFVua25vd25UYWdzO1xudmFyIHN1cHByZXNzSHlkcmF0aW9uV2FybmluZztcbnZhciB2YWxpZGF0ZVByb3BlcnRpZXNJbkRldmVsb3BtZW50O1xudmFyIHdhcm5Gb3JUZXh0RGlmZmVyZW5jZTtcbnZhciB3YXJuRm9yUHJvcERpZmZlcmVuY2U7XG52YXIgd2FybkZvckV4dHJhQXR0cmlidXRlcztcbnZhciB3YXJuRm9ySW52YWxpZEV2ZW50TGlzdGVuZXI7XG52YXIgY2FuRGlmZlN0eWxlRm9ySHlkcmF0aW9uV2FybmluZztcbnZhciBub3JtYWxpemVNYXJrdXBGb3JUZXh0T3JBdHRyaWJ1dGU7XG52YXIgbm9ybWFsaXplSFRNTDtcblxue1xuICB3YXJuZWRVbmtub3duVGFncyA9IHtcbiAgICAvLyBUaGVyZSBhcmUgd29ya2luZyBwb2x5ZmlsbHMgZm9yIDxkaWFsb2c+LiBMZXQgcGVvcGxlIHVzZSBpdC5cbiAgICBkaWFsb2c6IHRydWUsXG4gICAgLy8gRWxlY3Ryb24gc2hpcHMgYSBjdXN0b20gPHdlYnZpZXc+IHRhZyB0byBkaXNwbGF5IGV4dGVybmFsIHdlYiBjb250ZW50IGluXG4gICAgLy8gYW4gaXNvbGF0ZWQgZnJhbWUgYW5kIHByb2Nlc3MuXG4gICAgLy8gVGhpcyB0YWcgaXMgbm90IHByZXNlbnQgaW4gbm9uIEVsZWN0cm9uIGVudmlyb25tZW50cyBzdWNoIGFzIEpTRG9tIHdoaWNoXG4gICAgLy8gaXMgb2Z0ZW4gdXNlZCBmb3IgdGVzdGluZyBwdXJwb3Nlcy5cbiAgICAvLyBAc2VlIGh0dHBzOi8vZWxlY3Ryb25qcy5vcmcvZG9jcy9hcGkvd2Vidmlldy10YWdcbiAgICB3ZWJ2aWV3OiB0cnVlXG4gIH07XG5cbiAgdmFsaWRhdGVQcm9wZXJ0aWVzSW5EZXZlbG9wbWVudCA9IGZ1bmN0aW9uICh0eXBlLCBwcm9wcykge1xuICAgIHZhbGlkYXRlUHJvcGVydGllcyh0eXBlLCBwcm9wcyk7XG4gICAgdmFsaWRhdGVQcm9wZXJ0aWVzJDEodHlwZSwgcHJvcHMpO1xuICAgIHZhbGlkYXRlUHJvcGVydGllcyQyKHR5cGUsIHByb3BzLCB7XG4gICAgICByZWdpc3RyYXRpb25OYW1lRGVwZW5kZW5jaWVzOiByZWdpc3RyYXRpb25OYW1lRGVwZW5kZW5jaWVzLFxuICAgICAgcG9zc2libGVSZWdpc3RyYXRpb25OYW1lczogcG9zc2libGVSZWdpc3RyYXRpb25OYW1lc1xuICAgIH0pO1xuICB9OyAvLyBJRSAxMSBwYXJzZXMgJiBub3JtYWxpemVzIHRoZSBzdHlsZSBhdHRyaWJ1dGUgYXMgb3Bwb3NlZCB0byBvdGhlclxuICAvLyBicm93c2Vycy4gSXQgYWRkcyBzcGFjZXMgYW5kIHNvcnRzIHRoZSBwcm9wZXJ0aWVzIGluIHNvbWVcbiAgLy8gbm9uLWFscGhhYmV0aWNhbCBvcmRlci4gSGFuZGxpbmcgdGhhdCB3b3VsZCByZXF1aXJlIHNvcnRpbmcgQ1NTXG4gIC8vIHByb3BlcnRpZXMgaW4gdGhlIGNsaWVudCAmIHNlcnZlciB2ZXJzaW9ucyBvciBhcHBseWluZ1xuICAvLyBgZXhwZWN0ZWRTdHlsZWAgdG8gYSB0ZW1wb3JhcnkgRE9NIG5vZGUgdG8gcmVhZCBpdHMgYHN0eWxlYCBhdHRyaWJ1dGVcbiAgLy8gbm9ybWFsaXplZC4gU2luY2UgaXQgb25seSBhZmZlY3RzIElFLCB3ZSdyZSBza2lwcGluZyBzdHlsZSB3YXJuaW5nc1xuICAvLyBpbiB0aGF0IGJyb3dzZXIgY29tcGxldGVseSBpbiBmYXZvciBvZiBkb2luZyBhbGwgdGhhdCB3b3JrLlxuICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xMTgwN1xuXG5cbiAgY2FuRGlmZlN0eWxlRm9ySHlkcmF0aW9uV2FybmluZyA9IGNhblVzZURPTSAmJiAhZG9jdW1lbnQuZG9jdW1lbnRNb2RlOyAvLyBIVE1MIHBhcnNpbmcgbm9ybWFsaXplcyBDUiBhbmQgQ1JMRiB0byBMRi5cbiAgLy8gSXQgYWxzbyBjYW4gdHVybiBcXHUwMDAwIGludG8gXFx1RkZGRCBpbnNpZGUgYXR0cmlidXRlcy5cbiAgLy8gaHR0cHM6Ly93d3cudzMub3JnL1RSL2h0bWw1L3NpbmdsZS1wYWdlLmh0bWwjcHJlcHJvY2Vzc2luZy10aGUtaW5wdXQtc3RyZWFtXG4gIC8vIElmIHdlIGhhdmUgYSBtaXNtYXRjaCwgaXQgbWlnaHQgYmUgY2F1c2VkIGJ5IHRoYXQuXG4gIC8vIFdlIHdpbGwgc3RpbGwgcGF0Y2ggdXAgaW4gdGhpcyBjYXNlIGJ1dCBub3QgZmlyZSB0aGUgd2FybmluZy5cblxuICB2YXIgTk9STUFMSVpFX05FV0xJTkVTX1JFR0VYID0gL1xcclxcbj8vZztcbiAgdmFyIE5PUk1BTElaRV9OVUxMX0FORF9SRVBMQUNFTUVOVF9SRUdFWCA9IC9cXHUwMDAwfFxcdUZGRkQvZztcblxuICBub3JtYWxpemVNYXJrdXBGb3JUZXh0T3JBdHRyaWJ1dGUgPSBmdW5jdGlvbiAobWFya3VwKSB7XG4gICAgdmFyIG1hcmt1cFN0cmluZyA9IHR5cGVvZiBtYXJrdXAgPT09ICdzdHJpbmcnID8gbWFya3VwIDogJycgKyBtYXJrdXA7XG4gICAgcmV0dXJuIG1hcmt1cFN0cmluZy5yZXBsYWNlKE5PUk1BTElaRV9ORVdMSU5FU19SRUdFWCwgJ1xcbicpLnJlcGxhY2UoTk9STUFMSVpFX05VTExfQU5EX1JFUExBQ0VNRU5UX1JFR0VYLCAnJyk7XG4gIH07XG5cbiAgd2FybkZvclRleHREaWZmZXJlbmNlID0gZnVuY3Rpb24gKHNlcnZlclRleHQsIGNsaWVudFRleHQpIHtcbiAgICBpZiAoZGlkV2FybkludmFsaWRIeWRyYXRpb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgbm9ybWFsaXplZENsaWVudFRleHQgPSBub3JtYWxpemVNYXJrdXBGb3JUZXh0T3JBdHRyaWJ1dGUoY2xpZW50VGV4dCk7XG4gICAgdmFyIG5vcm1hbGl6ZWRTZXJ2ZXJUZXh0ID0gbm9ybWFsaXplTWFya3VwRm9yVGV4dE9yQXR0cmlidXRlKHNlcnZlclRleHQpO1xuXG4gICAgaWYgKG5vcm1hbGl6ZWRTZXJ2ZXJUZXh0ID09PSBub3JtYWxpemVkQ2xpZW50VGV4dCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGRpZFdhcm5JbnZhbGlkSHlkcmF0aW9uID0gdHJ1ZTtcblxuICAgIGVycm9yKCdUZXh0IGNvbnRlbnQgZGlkIG5vdCBtYXRjaC4gU2VydmVyOiBcIiVzXCIgQ2xpZW50OiBcIiVzXCInLCBub3JtYWxpemVkU2VydmVyVGV4dCwgbm9ybWFsaXplZENsaWVudFRleHQpO1xuICB9O1xuXG4gIHdhcm5Gb3JQcm9wRGlmZmVyZW5jZSA9IGZ1bmN0aW9uIChwcm9wTmFtZSwgc2VydmVyVmFsdWUsIGNsaWVudFZhbHVlKSB7XG4gICAgaWYgKGRpZFdhcm5JbnZhbGlkSHlkcmF0aW9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIG5vcm1hbGl6ZWRDbGllbnRWYWx1ZSA9IG5vcm1hbGl6ZU1hcmt1cEZvclRleHRPckF0dHJpYnV0ZShjbGllbnRWYWx1ZSk7XG4gICAgdmFyIG5vcm1hbGl6ZWRTZXJ2ZXJWYWx1ZSA9IG5vcm1hbGl6ZU1hcmt1cEZvclRleHRPckF0dHJpYnV0ZShzZXJ2ZXJWYWx1ZSk7XG5cbiAgICBpZiAobm9ybWFsaXplZFNlcnZlclZhbHVlID09PSBub3JtYWxpemVkQ2xpZW50VmFsdWUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBkaWRXYXJuSW52YWxpZEh5ZHJhdGlvbiA9IHRydWU7XG5cbiAgICBlcnJvcignUHJvcCBgJXNgIGRpZCBub3QgbWF0Y2guIFNlcnZlcjogJXMgQ2xpZW50OiAlcycsIHByb3BOYW1lLCBKU09OLnN0cmluZ2lmeShub3JtYWxpemVkU2VydmVyVmFsdWUpLCBKU09OLnN0cmluZ2lmeShub3JtYWxpemVkQ2xpZW50VmFsdWUpKTtcbiAgfTtcblxuICB3YXJuRm9yRXh0cmFBdHRyaWJ1dGVzID0gZnVuY3Rpb24gKGF0dHJpYnV0ZU5hbWVzKSB7XG4gICAgaWYgKGRpZFdhcm5JbnZhbGlkSHlkcmF0aW9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZGlkV2FybkludmFsaWRIeWRyYXRpb24gPSB0cnVlO1xuICAgIHZhciBuYW1lcyA9IFtdO1xuICAgIGF0dHJpYnV0ZU5hbWVzLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgIG5hbWVzLnB1c2gobmFtZSk7XG4gICAgfSk7XG5cbiAgICBlcnJvcignRXh0cmEgYXR0cmlidXRlcyBmcm9tIHRoZSBzZXJ2ZXI6ICVzJywgbmFtZXMpO1xuICB9O1xuXG4gIHdhcm5Gb3JJbnZhbGlkRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uIChyZWdpc3RyYXRpb25OYW1lLCBsaXN0ZW5lcikge1xuICAgIGlmIChsaXN0ZW5lciA9PT0gZmFsc2UpIHtcbiAgICAgIGVycm9yKCdFeHBlY3RlZCBgJXNgIGxpc3RlbmVyIHRvIGJlIGEgZnVuY3Rpb24sIGluc3RlYWQgZ290IGBmYWxzZWAuXFxuXFxuJyArICdJZiB5b3UgdXNlZCB0byBjb25kaXRpb25hbGx5IG9taXQgaXQgd2l0aCAlcz17Y29uZGl0aW9uICYmIHZhbHVlfSwgJyArICdwYXNzICVzPXtjb25kaXRpb24gPyB2YWx1ZSA6IHVuZGVmaW5lZH0gaW5zdGVhZC4nLCByZWdpc3RyYXRpb25OYW1lLCByZWdpc3RyYXRpb25OYW1lLCByZWdpc3RyYXRpb25OYW1lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXJyb3IoJ0V4cGVjdGVkIGAlc2AgbGlzdGVuZXIgdG8gYmUgYSBmdW5jdGlvbiwgaW5zdGVhZCBnb3QgYSB2YWx1ZSBvZiBgJXNgIHR5cGUuJywgcmVnaXN0cmF0aW9uTmFtZSwgdHlwZW9mIGxpc3RlbmVyKTtcbiAgICB9XG4gIH07IC8vIFBhcnNlIHRoZSBIVE1MIGFuZCByZWFkIGl0IGJhY2sgdG8gbm9ybWFsaXplIHRoZSBIVE1MIHN0cmluZyBzbyB0aGF0IGl0XG4gIC8vIGNhbiBiZSB1c2VkIGZvciBjb21wYXJpc29uLlxuXG5cbiAgbm9ybWFsaXplSFRNTCA9IGZ1bmN0aW9uIChwYXJlbnQsIGh0bWwpIHtcbiAgICAvLyBXZSBjb3VsZCBoYXZlIGNyZWF0ZWQgYSBzZXBhcmF0ZSBkb2N1bWVudCBoZXJlIHRvIGF2b2lkXG4gICAgLy8gcmUtaW5pdGlhbGl6aW5nIGN1c3RvbSBlbGVtZW50cyBpZiB0aGV5IGV4aXN0LiBCdXQgdGhpcyBicmVha3NcbiAgICAvLyBob3cgPG5vc2NyaXB0PiBpcyBiZWluZyBoYW5kbGVkLiBTbyB3ZSB1c2UgdGhlIHNhbWUgZG9jdW1lbnQuXG4gICAgLy8gU2VlIHRoZSBkaXNjdXNzaW9uIGluIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9wdWxsLzExMTU3LlxuICAgIHZhciB0ZXN0RWxlbWVudCA9IHBhcmVudC5uYW1lc3BhY2VVUkkgPT09IEhUTUxfTkFNRVNQQUNFJDEgPyBwYXJlbnQub3duZXJEb2N1bWVudC5jcmVhdGVFbGVtZW50KHBhcmVudC50YWdOYW1lKSA6IHBhcmVudC5vd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhwYXJlbnQubmFtZXNwYWNlVVJJLCBwYXJlbnQudGFnTmFtZSk7XG4gICAgdGVzdEVsZW1lbnQuaW5uZXJIVE1MID0gaHRtbDtcbiAgICByZXR1cm4gdGVzdEVsZW1lbnQuaW5uZXJIVE1MO1xuICB9O1xufVxuXG5mdW5jdGlvbiBnZXRPd25lckRvY3VtZW50RnJvbVJvb3RDb250YWluZXIocm9vdENvbnRhaW5lckVsZW1lbnQpIHtcbiAgcmV0dXJuIHJvb3RDb250YWluZXJFbGVtZW50Lm5vZGVUeXBlID09PSBET0NVTUVOVF9OT0RFID8gcm9vdENvbnRhaW5lckVsZW1lbnQgOiByb290Q29udGFpbmVyRWxlbWVudC5vd25lckRvY3VtZW50O1xufVxuXG5mdW5jdGlvbiBub29wKCkge31cblxuZnVuY3Rpb24gdHJhcENsaWNrT25Ob25JbnRlcmFjdGl2ZUVsZW1lbnQobm9kZSkge1xuICAvLyBNb2JpbGUgU2FmYXJpIGRvZXMgbm90IGZpcmUgcHJvcGVybHkgYnViYmxlIGNsaWNrIGV2ZW50cyBvblxuICAvLyBub24taW50ZXJhY3RpdmUgZWxlbWVudHMsIHdoaWNoIG1lYW5zIGRlbGVnYXRlZCBjbGljayBsaXN0ZW5lcnMgZG8gbm90XG4gIC8vIGZpcmUuIFRoZSB3b3JrYXJvdW5kIGZvciB0aGlzIGJ1ZyBpbnZvbHZlcyBhdHRhY2hpbmcgYW4gZW1wdHkgY2xpY2tcbiAgLy8gbGlzdGVuZXIgb24gdGhlIHRhcmdldCBub2RlLlxuICAvLyBodHRwczovL3d3dy5xdWlya3Ntb2RlLm9yZy9ibG9nL2FyY2hpdmVzLzIwMTAvMDkvY2xpY2tfZXZlbnRfZGVsLmh0bWxcbiAgLy8gSnVzdCBzZXQgaXQgdXNpbmcgdGhlIG9uY2xpY2sgcHJvcGVydHkgc28gdGhhdCB3ZSBkb24ndCBoYXZlIHRvIG1hbmFnZSBhbnlcbiAgLy8gYm9va2tlZXBpbmcgZm9yIGl0LiBOb3Qgc3VyZSBpZiB3ZSBuZWVkIHRvIGNsZWFyIGl0IHdoZW4gdGhlIGxpc3RlbmVyIGlzXG4gIC8vIHJlbW92ZWQuXG4gIC8vIFRPRE86IE9ubHkgZG8gdGhpcyBmb3IgdGhlIHJlbGV2YW50IFNhZmFyaXMgbWF5YmU/XG4gIG5vZGUub25jbGljayA9IG5vb3A7XG59XG5cbmZ1bmN0aW9uIHNldEluaXRpYWxET01Qcm9wZXJ0aWVzKHRhZywgZG9tRWxlbWVudCwgcm9vdENvbnRhaW5lckVsZW1lbnQsIG5leHRQcm9wcywgaXNDdXN0b21Db21wb25lbnRUYWcpIHtcbiAgZm9yICh2YXIgcHJvcEtleSBpbiBuZXh0UHJvcHMpIHtcbiAgICBpZiAoIW5leHRQcm9wcy5oYXNPd25Qcm9wZXJ0eShwcm9wS2V5KSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgdmFyIG5leHRQcm9wID0gbmV4dFByb3BzW3Byb3BLZXldO1xuXG4gICAgaWYgKHByb3BLZXkgPT09IFNUWUxFKSB7XG4gICAgICB7XG4gICAgICAgIGlmIChuZXh0UHJvcCkge1xuICAgICAgICAgIC8vIEZyZWV6ZSB0aGUgbmV4dCBzdHlsZSBvYmplY3Qgc28gdGhhdCB3ZSBjYW4gYXNzdW1lIGl0IHdvbid0IGJlXG4gICAgICAgICAgLy8gbXV0YXRlZC4gV2UgaGF2ZSBhbHJlYWR5IHdhcm5lZCBmb3IgdGhpcyBpbiB0aGUgcGFzdC5cbiAgICAgICAgICBPYmplY3QuZnJlZXplKG5leHRQcm9wKTtcbiAgICAgICAgfVxuICAgICAgfSAvLyBSZWxpZXMgb24gYHVwZGF0ZVN0eWxlc0J5SURgIG5vdCBtdXRhdGluZyBgc3R5bGVVcGRhdGVzYC5cblxuXG4gICAgICBzZXRWYWx1ZUZvclN0eWxlcyhkb21FbGVtZW50LCBuZXh0UHJvcCk7XG4gICAgfSBlbHNlIGlmIChwcm9wS2V5ID09PSBEQU5HRVJPVVNMWV9TRVRfSU5ORVJfSFRNTCkge1xuICAgICAgdmFyIG5leHRIdG1sID0gbmV4dFByb3AgPyBuZXh0UHJvcFtIVE1MJDFdIDogdW5kZWZpbmVkO1xuXG4gICAgICBpZiAobmV4dEh0bWwgIT0gbnVsbCkge1xuICAgICAgICBzZXRJbm5lckhUTUwoZG9tRWxlbWVudCwgbmV4dEh0bWwpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocHJvcEtleSA9PT0gQ0hJTERSRU4pIHtcbiAgICAgIGlmICh0eXBlb2YgbmV4dFByb3AgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIC8vIEF2b2lkIHNldHRpbmcgaW5pdGlhbCB0ZXh0Q29udGVudCB3aGVuIHRoZSB0ZXh0IGlzIGVtcHR5LiBJbiBJRTExIHNldHRpbmdcbiAgICAgICAgLy8gdGV4dENvbnRlbnQgb24gYSA8dGV4dGFyZWE+IHdpbGwgY2F1c2UgdGhlIHBsYWNlaG9sZGVyIHRvIG5vdFxuICAgICAgICAvLyBzaG93IHdpdGhpbiB0aGUgPHRleHRhcmVhPiB1bnRpbCBpdCBoYXMgYmVlbiBmb2N1c2VkIGFuZCBibHVycmVkIGFnYWluLlxuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzY3MzEjaXNzdWVjb21tZW50LTI1NDg3NDU1M1xuICAgICAgICB2YXIgY2FuU2V0VGV4dENvbnRlbnQgPSB0YWcgIT09ICd0ZXh0YXJlYScgfHwgbmV4dFByb3AgIT09ICcnO1xuXG4gICAgICAgIGlmIChjYW5TZXRUZXh0Q29udGVudCkge1xuICAgICAgICAgIHNldFRleHRDb250ZW50KGRvbUVsZW1lbnQsIG5leHRQcm9wKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgbmV4dFByb3AgPT09ICdudW1iZXInKSB7XG4gICAgICAgIHNldFRleHRDb250ZW50KGRvbUVsZW1lbnQsICcnICsgbmV4dFByb3ApO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocHJvcEtleSA9PT0gU1VQUFJFU1NfQ09OVEVOVF9FRElUQUJMRV9XQVJOSU5HIHx8IHByb3BLZXkgPT09IFNVUFBSRVNTX0hZRFJBVElPTl9XQVJOSU5HKSA7IGVsc2UgaWYgKHByb3BLZXkgPT09IEFVVE9GT0NVUykgOyBlbHNlIGlmIChyZWdpc3RyYXRpb25OYW1lRGVwZW5kZW5jaWVzLmhhc093blByb3BlcnR5KHByb3BLZXkpKSB7XG4gICAgICBpZiAobmV4dFByb3AgIT0gbnVsbCkge1xuICAgICAgICBpZiAoIHR5cGVvZiBuZXh0UHJvcCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHdhcm5Gb3JJbnZhbGlkRXZlbnRMaXN0ZW5lcihwcm9wS2V5LCBuZXh0UHJvcCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocHJvcEtleSA9PT0gJ29uU2Nyb2xsJykge1xuICAgICAgICAgIGxpc3RlblRvTm9uRGVsZWdhdGVkRXZlbnQoJ3Njcm9sbCcsIGRvbUVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChuZXh0UHJvcCAhPSBudWxsKSB7XG4gICAgICBzZXRWYWx1ZUZvclByb3BlcnR5KGRvbUVsZW1lbnQsIHByb3BLZXksIG5leHRQcm9wLCBpc0N1c3RvbUNvbXBvbmVudFRhZyk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZURPTVByb3BlcnRpZXMoZG9tRWxlbWVudCwgdXBkYXRlUGF5bG9hZCwgd2FzQ3VzdG9tQ29tcG9uZW50VGFnLCBpc0N1c3RvbUNvbXBvbmVudFRhZykge1xuICAvLyBUT0RPOiBIYW5kbGUgd2FzQ3VzdG9tQ29tcG9uZW50VGFnXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdXBkYXRlUGF5bG9hZC5sZW5ndGg7IGkgKz0gMikge1xuICAgIHZhciBwcm9wS2V5ID0gdXBkYXRlUGF5bG9hZFtpXTtcbiAgICB2YXIgcHJvcFZhbHVlID0gdXBkYXRlUGF5bG9hZFtpICsgMV07XG5cbiAgICBpZiAocHJvcEtleSA9PT0gU1RZTEUpIHtcbiAgICAgIHNldFZhbHVlRm9yU3R5bGVzKGRvbUVsZW1lbnQsIHByb3BWYWx1ZSk7XG4gICAgfSBlbHNlIGlmIChwcm9wS2V5ID09PSBEQU5HRVJPVVNMWV9TRVRfSU5ORVJfSFRNTCkge1xuICAgICAgc2V0SW5uZXJIVE1MKGRvbUVsZW1lbnQsIHByb3BWYWx1ZSk7XG4gICAgfSBlbHNlIGlmIChwcm9wS2V5ID09PSBDSElMRFJFTikge1xuICAgICAgc2V0VGV4dENvbnRlbnQoZG9tRWxlbWVudCwgcHJvcFZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2V0VmFsdWVGb3JQcm9wZXJ0eShkb21FbGVtZW50LCBwcm9wS2V5LCBwcm9wVmFsdWUsIGlzQ3VzdG9tQ29tcG9uZW50VGFnKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlRWxlbWVudCh0eXBlLCBwcm9wcywgcm9vdENvbnRhaW5lckVsZW1lbnQsIHBhcmVudE5hbWVzcGFjZSkge1xuICB2YXIgaXNDdXN0b21Db21wb25lbnRUYWc7IC8vIFdlIGNyZWF0ZSB0YWdzIGluIHRoZSBuYW1lc3BhY2Ugb2YgdGhlaXIgcGFyZW50IGNvbnRhaW5lciwgZXhjZXB0IEhUTUxcbiAgLy8gdGFncyBnZXQgbm8gbmFtZXNwYWNlLlxuXG4gIHZhciBvd25lckRvY3VtZW50ID0gZ2V0T3duZXJEb2N1bWVudEZyb21Sb290Q29udGFpbmVyKHJvb3RDb250YWluZXJFbGVtZW50KTtcbiAgdmFyIGRvbUVsZW1lbnQ7XG4gIHZhciBuYW1lc3BhY2VVUkkgPSBwYXJlbnROYW1lc3BhY2U7XG5cbiAgaWYgKG5hbWVzcGFjZVVSSSA9PT0gSFRNTF9OQU1FU1BBQ0UkMSkge1xuICAgIG5hbWVzcGFjZVVSSSA9IGdldEludHJpbnNpY05hbWVzcGFjZSh0eXBlKTtcbiAgfVxuXG4gIGlmIChuYW1lc3BhY2VVUkkgPT09IEhUTUxfTkFNRVNQQUNFJDEpIHtcbiAgICB7XG4gICAgICBpc0N1c3RvbUNvbXBvbmVudFRhZyA9IGlzQ3VzdG9tQ29tcG9uZW50KHR5cGUsIHByb3BzKTsgLy8gU2hvdWxkIHRoaXMgY2hlY2sgYmUgZ2F0ZWQgYnkgcGFyZW50IG5hbWVzcGFjZT8gTm90IHN1cmUgd2Ugd2FudCB0b1xuICAgICAgLy8gYWxsb3cgPFNWRz4gb3IgPG1BVEg+LlxuXG4gICAgICBpZiAoIWlzQ3VzdG9tQ29tcG9uZW50VGFnICYmIHR5cGUgIT09IHR5cGUudG9Mb3dlckNhc2UoKSkge1xuICAgICAgICBlcnJvcignPCVzIC8+IGlzIHVzaW5nIGluY29ycmVjdCBjYXNpbmcuICcgKyAnVXNlIFBhc2NhbENhc2UgZm9yIFJlYWN0IGNvbXBvbmVudHMsICcgKyAnb3IgbG93ZXJjYXNlIGZvciBIVE1MIGVsZW1lbnRzLicsIHR5cGUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0eXBlID09PSAnc2NyaXB0Jykge1xuICAgICAgLy8gQ3JlYXRlIHRoZSBzY3JpcHQgdmlhIC5pbm5lckhUTUwgc28gaXRzIFwicGFyc2VyLWluc2VydGVkXCIgZmxhZyBpc1xuICAgICAgLy8gc2V0IHRvIHRydWUgYW5kIGl0IGRvZXMgbm90IGV4ZWN1dGVcbiAgICAgIHZhciBkaXYgPSBvd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuXG4gICAgICBkaXYuaW5uZXJIVE1MID0gJzxzY3JpcHQ+PCcgKyAnL3NjcmlwdD4nOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgICAvLyBUaGlzIGlzIGd1YXJhbnRlZWQgdG8geWllbGQgYSBzY3JpcHQgZWxlbWVudC5cblxuICAgICAgdmFyIGZpcnN0Q2hpbGQgPSBkaXYuZmlyc3RDaGlsZDtcbiAgICAgIGRvbUVsZW1lbnQgPSBkaXYucmVtb3ZlQ2hpbGQoZmlyc3RDaGlsZCk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgcHJvcHMuaXMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAvLyAkRmxvd0lzc3VlIGBjcmVhdGVFbGVtZW50YCBzaG91bGQgYmUgdXBkYXRlZCBmb3IgV2ViIENvbXBvbmVudHNcbiAgICAgIGRvbUVsZW1lbnQgPSBvd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodHlwZSwge1xuICAgICAgICBpczogcHJvcHMuaXNcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBTZXBhcmF0ZSBlbHNlIGJyYW5jaCBpbnN0ZWFkIG9mIHVzaW5nIGBwcm9wcy5pcyB8fCB1bmRlZmluZWRgIGFib3ZlIGJlY2F1c2Ugb2YgYSBGaXJlZm94IGJ1Zy5cbiAgICAgIC8vIFNlZSBkaXNjdXNzaW9uIGluIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9wdWxsLzY4OTZcbiAgICAgIC8vIGFuZCBkaXNjdXNzaW9uIGluIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTEyNzYyNDBcbiAgICAgIGRvbUVsZW1lbnQgPSBvd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodHlwZSk7IC8vIE5vcm1hbGx5IGF0dHJpYnV0ZXMgYXJlIGFzc2lnbmVkIGluIGBzZXRJbml0aWFsRE9NUHJvcGVydGllc2AsIGhvd2V2ZXIgdGhlIGBtdWx0aXBsZWAgYW5kIGBzaXplYFxuICAgICAgLy8gYXR0cmlidXRlcyBvbiBgc2VsZWN0YHMgbmVlZHMgdG8gYmUgYWRkZWQgYmVmb3JlIGBvcHRpb25gcyBhcmUgaW5zZXJ0ZWQuXG4gICAgICAvLyBUaGlzIHByZXZlbnRzOlxuICAgICAgLy8gLSBhIGJ1ZyB3aGVyZSB0aGUgYHNlbGVjdGAgZG9lcyBub3Qgc2Nyb2xsIHRvIHRoZSBjb3JyZWN0IG9wdGlvbiBiZWNhdXNlIHNpbmd1bGFyXG4gICAgICAvLyAgYHNlbGVjdGAgZWxlbWVudHMgYXV0b21hdGljYWxseSBwaWNrIHRoZSBmaXJzdCBpdGVtICMxMzIyMlxuICAgICAgLy8gLSBhIGJ1ZyB3aGVyZSB0aGUgYHNlbGVjdGAgc2V0IHRoZSBmaXJzdCBpdGVtIGFzIHNlbGVjdGVkIGRlc3BpdGUgdGhlIGBzaXplYCBhdHRyaWJ1dGUgIzE0MjM5XG4gICAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xMzIyMlxuICAgICAgLy8gYW5kIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTQyMzlcblxuICAgICAgaWYgKHR5cGUgPT09ICdzZWxlY3QnKSB7XG4gICAgICAgIHZhciBub2RlID0gZG9tRWxlbWVudDtcblxuICAgICAgICBpZiAocHJvcHMubXVsdGlwbGUpIHtcbiAgICAgICAgICBub2RlLm11bHRpcGxlID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIGlmIChwcm9wcy5zaXplKSB7XG4gICAgICAgICAgLy8gU2V0dGluZyBhIHNpemUgZ3JlYXRlciB0aGFuIDEgY2F1c2VzIGEgc2VsZWN0IHRvIGJlaGF2ZSBsaWtlIGBtdWx0aXBsZT10cnVlYCwgd2hlcmVcbiAgICAgICAgICAvLyBpdCBpcyBwb3NzaWJsZSB0aGF0IG5vIG9wdGlvbiBpcyBzZWxlY3RlZC5cbiAgICAgICAgICAvL1xuICAgICAgICAgIC8vIFRoaXMgaXMgb25seSBuZWNlc3Nhcnkgd2hlbiBhIHNlbGVjdCBpbiBcInNpbmdsZSBzZWxlY3Rpb24gbW9kZVwiLlxuICAgICAgICAgIG5vZGUuc2l6ZSA9IHByb3BzLnNpemU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZG9tRWxlbWVudCA9IG93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKG5hbWVzcGFjZVVSSSwgdHlwZSk7XG4gIH1cblxuICB7XG4gICAgaWYgKG5hbWVzcGFjZVVSSSA9PT0gSFRNTF9OQU1FU1BBQ0UkMSkge1xuICAgICAgaWYgKCFpc0N1c3RvbUNvbXBvbmVudFRhZyAmJiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZG9tRWxlbWVudCkgPT09ICdbb2JqZWN0IEhUTUxVbmtub3duRWxlbWVudF0nICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwod2FybmVkVW5rbm93blRhZ3MsIHR5cGUpKSB7XG4gICAgICAgIHdhcm5lZFVua25vd25UYWdzW3R5cGVdID0gdHJ1ZTtcblxuICAgICAgICBlcnJvcignVGhlIHRhZyA8JXM+IGlzIHVucmVjb2duaXplZCBpbiB0aGlzIGJyb3dzZXIuICcgKyAnSWYgeW91IG1lYW50IHRvIHJlbmRlciBhIFJlYWN0IGNvbXBvbmVudCwgc3RhcnQgaXRzIG5hbWUgd2l0aCAnICsgJ2FuIHVwcGVyY2FzZSBsZXR0ZXIuJywgdHlwZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGRvbUVsZW1lbnQ7XG59XG5mdW5jdGlvbiBjcmVhdGVUZXh0Tm9kZSh0ZXh0LCByb290Q29udGFpbmVyRWxlbWVudCkge1xuICByZXR1cm4gZ2V0T3duZXJEb2N1bWVudEZyb21Sb290Q29udGFpbmVyKHJvb3RDb250YWluZXJFbGVtZW50KS5jcmVhdGVUZXh0Tm9kZSh0ZXh0KTtcbn1cbmZ1bmN0aW9uIHNldEluaXRpYWxQcm9wZXJ0aWVzKGRvbUVsZW1lbnQsIHRhZywgcmF3UHJvcHMsIHJvb3RDb250YWluZXJFbGVtZW50KSB7XG4gIHZhciBpc0N1c3RvbUNvbXBvbmVudFRhZyA9IGlzQ3VzdG9tQ29tcG9uZW50KHRhZywgcmF3UHJvcHMpO1xuXG4gIHtcbiAgICB2YWxpZGF0ZVByb3BlcnRpZXNJbkRldmVsb3BtZW50KHRhZywgcmF3UHJvcHMpO1xuICB9IC8vIFRPRE86IE1ha2Ugc3VyZSB0aGF0IHdlIGNoZWNrIGlzTW91bnRlZCBiZWZvcmUgZmlyaW5nIGFueSBvZiB0aGVzZSBldmVudHMuXG5cblxuICB2YXIgcHJvcHM7XG5cbiAgc3dpdGNoICh0YWcpIHtcbiAgICBjYXNlICdkaWFsb2cnOlxuICAgICAgbGlzdGVuVG9Ob25EZWxlZ2F0ZWRFdmVudCgnY2FuY2VsJywgZG9tRWxlbWVudCk7XG4gICAgICBsaXN0ZW5Ub05vbkRlbGVnYXRlZEV2ZW50KCdjbG9zZScsIGRvbUVsZW1lbnQpO1xuICAgICAgcHJvcHMgPSByYXdQcm9wcztcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnaWZyYW1lJzpcbiAgICBjYXNlICdvYmplY3QnOlxuICAgIGNhc2UgJ2VtYmVkJzpcbiAgICAgIC8vIFdlIGxpc3RlbiB0byB0aGlzIGV2ZW50IGluIGNhc2UgdG8gZW5zdXJlIGVtdWxhdGVkIGJ1YmJsZVxuICAgICAgLy8gbGlzdGVuZXJzIHN0aWxsIGZpcmUgZm9yIHRoZSBsb2FkIGV2ZW50LlxuICAgICAgbGlzdGVuVG9Ob25EZWxlZ2F0ZWRFdmVudCgnbG9hZCcsIGRvbUVsZW1lbnQpO1xuICAgICAgcHJvcHMgPSByYXdQcm9wcztcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAndmlkZW8nOlxuICAgIGNhc2UgJ2F1ZGlvJzpcbiAgICAgIC8vIFdlIGxpc3RlbiB0byB0aGVzZSBldmVudHMgaW4gY2FzZSB0byBlbnN1cmUgZW11bGF0ZWQgYnViYmxlXG4gICAgICAvLyBsaXN0ZW5lcnMgc3RpbGwgZmlyZSBmb3IgYWxsIHRoZSBtZWRpYSBldmVudHMuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1lZGlhRXZlbnRUeXBlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBsaXN0ZW5Ub05vbkRlbGVnYXRlZEV2ZW50KG1lZGlhRXZlbnRUeXBlc1tpXSwgZG9tRWxlbWVudCk7XG4gICAgICB9XG5cbiAgICAgIHByb3BzID0gcmF3UHJvcHM7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ3NvdXJjZSc6XG4gICAgICAvLyBXZSBsaXN0ZW4gdG8gdGhpcyBldmVudCBpbiBjYXNlIHRvIGVuc3VyZSBlbXVsYXRlZCBidWJibGVcbiAgICAgIC8vIGxpc3RlbmVycyBzdGlsbCBmaXJlIGZvciB0aGUgZXJyb3IgZXZlbnQuXG4gICAgICBsaXN0ZW5Ub05vbkRlbGVnYXRlZEV2ZW50KCdlcnJvcicsIGRvbUVsZW1lbnQpO1xuICAgICAgcHJvcHMgPSByYXdQcm9wcztcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnaW1nJzpcbiAgICBjYXNlICdpbWFnZSc6XG4gICAgY2FzZSAnbGluayc6XG4gICAgICAvLyBXZSBsaXN0ZW4gdG8gdGhlc2UgZXZlbnRzIGluIGNhc2UgdG8gZW5zdXJlIGVtdWxhdGVkIGJ1YmJsZVxuICAgICAgLy8gbGlzdGVuZXJzIHN0aWxsIGZpcmUgZm9yIGVycm9yIGFuZCBsb2FkIGV2ZW50cy5cbiAgICAgIGxpc3RlblRvTm9uRGVsZWdhdGVkRXZlbnQoJ2Vycm9yJywgZG9tRWxlbWVudCk7XG4gICAgICBsaXN0ZW5Ub05vbkRlbGVnYXRlZEV2ZW50KCdsb2FkJywgZG9tRWxlbWVudCk7XG4gICAgICBwcm9wcyA9IHJhd1Byb3BzO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdkZXRhaWxzJzpcbiAgICAgIC8vIFdlIGxpc3RlbiB0byB0aGlzIGV2ZW50IGluIGNhc2UgdG8gZW5zdXJlIGVtdWxhdGVkIGJ1YmJsZVxuICAgICAgLy8gbGlzdGVuZXJzIHN0aWxsIGZpcmUgZm9yIHRoZSB0b2dnbGUgZXZlbnQuXG4gICAgICBsaXN0ZW5Ub05vbkRlbGVnYXRlZEV2ZW50KCd0b2dnbGUnLCBkb21FbGVtZW50KTtcbiAgICAgIHByb3BzID0gcmF3UHJvcHM7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ2lucHV0JzpcbiAgICAgIGluaXRXcmFwcGVyU3RhdGUoZG9tRWxlbWVudCwgcmF3UHJvcHMpO1xuICAgICAgcHJvcHMgPSBnZXRIb3N0UHJvcHMoZG9tRWxlbWVudCwgcmF3UHJvcHMpOyAvLyBXZSBsaXN0ZW4gdG8gdGhpcyBldmVudCBpbiBjYXNlIHRvIGVuc3VyZSBlbXVsYXRlZCBidWJibGVcbiAgICAgIC8vIGxpc3RlbmVycyBzdGlsbCBmaXJlIGZvciB0aGUgaW52YWxpZCBldmVudC5cblxuICAgICAgbGlzdGVuVG9Ob25EZWxlZ2F0ZWRFdmVudCgnaW52YWxpZCcsIGRvbUVsZW1lbnQpO1xuXG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ29wdGlvbic6XG4gICAgICB2YWxpZGF0ZVByb3BzKGRvbUVsZW1lbnQsIHJhd1Byb3BzKTtcbiAgICAgIHByb3BzID0gZ2V0SG9zdFByb3BzJDEoZG9tRWxlbWVudCwgcmF3UHJvcHMpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdzZWxlY3QnOlxuICAgICAgaW5pdFdyYXBwZXJTdGF0ZSQxKGRvbUVsZW1lbnQsIHJhd1Byb3BzKTtcbiAgICAgIHByb3BzID0gZ2V0SG9zdFByb3BzJDIoZG9tRWxlbWVudCwgcmF3UHJvcHMpOyAvLyBXZSBsaXN0ZW4gdG8gdGhpcyBldmVudCBpbiBjYXNlIHRvIGVuc3VyZSBlbXVsYXRlZCBidWJibGVcbiAgICAgIC8vIGxpc3RlbmVycyBzdGlsbCBmaXJlIGZvciB0aGUgaW52YWxpZCBldmVudC5cblxuICAgICAgbGlzdGVuVG9Ob25EZWxlZ2F0ZWRFdmVudCgnaW52YWxpZCcsIGRvbUVsZW1lbnQpO1xuXG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ3RleHRhcmVhJzpcbiAgICAgIGluaXRXcmFwcGVyU3RhdGUkMihkb21FbGVtZW50LCByYXdQcm9wcyk7XG4gICAgICBwcm9wcyA9IGdldEhvc3RQcm9wcyQzKGRvbUVsZW1lbnQsIHJhd1Byb3BzKTsgLy8gV2UgbGlzdGVuIHRvIHRoaXMgZXZlbnQgaW4gY2FzZSB0byBlbnN1cmUgZW11bGF0ZWQgYnViYmxlXG4gICAgICAvLyBsaXN0ZW5lcnMgc3RpbGwgZmlyZSBmb3IgdGhlIGludmFsaWQgZXZlbnQuXG5cbiAgICAgIGxpc3RlblRvTm9uRGVsZWdhdGVkRXZlbnQoJ2ludmFsaWQnLCBkb21FbGVtZW50KTtcblxuICAgICAgYnJlYWs7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgcHJvcHMgPSByYXdQcm9wcztcbiAgfVxuXG4gIGFzc2VydFZhbGlkUHJvcHModGFnLCBwcm9wcyk7XG4gIHNldEluaXRpYWxET01Qcm9wZXJ0aWVzKHRhZywgZG9tRWxlbWVudCwgcm9vdENvbnRhaW5lckVsZW1lbnQsIHByb3BzLCBpc0N1c3RvbUNvbXBvbmVudFRhZyk7XG5cbiAgc3dpdGNoICh0YWcpIHtcbiAgICBjYXNlICdpbnB1dCc6XG4gICAgICAvLyBUT0RPOiBNYWtlIHN1cmUgd2UgY2hlY2sgaWYgdGhpcyBpcyBzdGlsbCB1bm1vdW50ZWQgb3IgZG8gYW55IGNsZWFuXG4gICAgICAvLyB1cCBuZWNlc3Nhcnkgc2luY2Ugd2UgbmV2ZXIgc3RvcCB0cmFja2luZyBhbnltb3JlLlxuICAgICAgdHJhY2soZG9tRWxlbWVudCk7XG4gICAgICBwb3N0TW91bnRXcmFwcGVyKGRvbUVsZW1lbnQsIHJhd1Byb3BzLCBmYWxzZSk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ3RleHRhcmVhJzpcbiAgICAgIC8vIFRPRE86IE1ha2Ugc3VyZSB3ZSBjaGVjayBpZiB0aGlzIGlzIHN0aWxsIHVubW91bnRlZCBvciBkbyBhbnkgY2xlYW5cbiAgICAgIC8vIHVwIG5lY2Vzc2FyeSBzaW5jZSB3ZSBuZXZlciBzdG9wIHRyYWNraW5nIGFueW1vcmUuXG4gICAgICB0cmFjayhkb21FbGVtZW50KTtcbiAgICAgIHBvc3RNb3VudFdyYXBwZXIkMyhkb21FbGVtZW50KTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnb3B0aW9uJzpcbiAgICAgIHBvc3RNb3VudFdyYXBwZXIkMShkb21FbGVtZW50LCByYXdQcm9wcyk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ3NlbGVjdCc6XG4gICAgICBwb3N0TW91bnRXcmFwcGVyJDIoZG9tRWxlbWVudCwgcmF3UHJvcHMpO1xuICAgICAgYnJlYWs7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgaWYgKHR5cGVvZiBwcm9wcy5vbkNsaWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIFRPRE86IFRoaXMgY2FzdCBtYXkgbm90IGJlIHNvdW5kIGZvciBTVkcsIE1hdGhNTCBvciBjdXN0b20gZWxlbWVudHMuXG4gICAgICAgIHRyYXBDbGlja09uTm9uSW50ZXJhY3RpdmVFbGVtZW50KGRvbUVsZW1lbnQpO1xuICAgICAgfVxuXG4gICAgICBicmVhaztcbiAgfVxufSAvLyBDYWxjdWxhdGUgdGhlIGRpZmYgYmV0d2VlbiB0aGUgdHdvIG9iamVjdHMuXG5cbmZ1bmN0aW9uIGRpZmZQcm9wZXJ0aWVzKGRvbUVsZW1lbnQsIHRhZywgbGFzdFJhd1Byb3BzLCBuZXh0UmF3UHJvcHMsIHJvb3RDb250YWluZXJFbGVtZW50KSB7XG4gIHtcbiAgICB2YWxpZGF0ZVByb3BlcnRpZXNJbkRldmVsb3BtZW50KHRhZywgbmV4dFJhd1Byb3BzKTtcbiAgfVxuXG4gIHZhciB1cGRhdGVQYXlsb2FkID0gbnVsbDtcbiAgdmFyIGxhc3RQcm9wcztcbiAgdmFyIG5leHRQcm9wcztcblxuICBzd2l0Y2ggKHRhZykge1xuICAgIGNhc2UgJ2lucHV0JzpcbiAgICAgIGxhc3RQcm9wcyA9IGdldEhvc3RQcm9wcyhkb21FbGVtZW50LCBsYXN0UmF3UHJvcHMpO1xuICAgICAgbmV4dFByb3BzID0gZ2V0SG9zdFByb3BzKGRvbUVsZW1lbnQsIG5leHRSYXdQcm9wcyk7XG4gICAgICB1cGRhdGVQYXlsb2FkID0gW107XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ29wdGlvbic6XG4gICAgICBsYXN0UHJvcHMgPSBnZXRIb3N0UHJvcHMkMShkb21FbGVtZW50LCBsYXN0UmF3UHJvcHMpO1xuICAgICAgbmV4dFByb3BzID0gZ2V0SG9zdFByb3BzJDEoZG9tRWxlbWVudCwgbmV4dFJhd1Byb3BzKTtcbiAgICAgIHVwZGF0ZVBheWxvYWQgPSBbXTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnc2VsZWN0JzpcbiAgICAgIGxhc3RQcm9wcyA9IGdldEhvc3RQcm9wcyQyKGRvbUVsZW1lbnQsIGxhc3RSYXdQcm9wcyk7XG4gICAgICBuZXh0UHJvcHMgPSBnZXRIb3N0UHJvcHMkMihkb21FbGVtZW50LCBuZXh0UmF3UHJvcHMpO1xuICAgICAgdXBkYXRlUGF5bG9hZCA9IFtdO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICd0ZXh0YXJlYSc6XG4gICAgICBsYXN0UHJvcHMgPSBnZXRIb3N0UHJvcHMkMyhkb21FbGVtZW50LCBsYXN0UmF3UHJvcHMpO1xuICAgICAgbmV4dFByb3BzID0gZ2V0SG9zdFByb3BzJDMoZG9tRWxlbWVudCwgbmV4dFJhd1Byb3BzKTtcbiAgICAgIHVwZGF0ZVBheWxvYWQgPSBbXTtcbiAgICAgIGJyZWFrO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIGxhc3RQcm9wcyA9IGxhc3RSYXdQcm9wcztcbiAgICAgIG5leHRQcm9wcyA9IG5leHRSYXdQcm9wcztcblxuICAgICAgaWYgKHR5cGVvZiBsYXN0UHJvcHMub25DbGljayAhPT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgbmV4dFByb3BzLm9uQ2xpY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gVE9ETzogVGhpcyBjYXN0IG1heSBub3QgYmUgc291bmQgZm9yIFNWRywgTWF0aE1MIG9yIGN1c3RvbSBlbGVtZW50cy5cbiAgICAgICAgdHJhcENsaWNrT25Ob25JbnRlcmFjdGl2ZUVsZW1lbnQoZG9tRWxlbWVudCk7XG4gICAgICB9XG5cbiAgICAgIGJyZWFrO1xuICB9XG5cbiAgYXNzZXJ0VmFsaWRQcm9wcyh0YWcsIG5leHRQcm9wcyk7XG4gIHZhciBwcm9wS2V5O1xuICB2YXIgc3R5bGVOYW1lO1xuICB2YXIgc3R5bGVVcGRhdGVzID0gbnVsbDtcblxuICBmb3IgKHByb3BLZXkgaW4gbGFzdFByb3BzKSB7XG4gICAgaWYgKG5leHRQcm9wcy5oYXNPd25Qcm9wZXJ0eShwcm9wS2V5KSB8fCAhbGFzdFByb3BzLmhhc093blByb3BlcnR5KHByb3BLZXkpIHx8IGxhc3RQcm9wc1twcm9wS2V5XSA9PSBudWxsKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAocHJvcEtleSA9PT0gU1RZTEUpIHtcbiAgICAgIHZhciBsYXN0U3R5bGUgPSBsYXN0UHJvcHNbcHJvcEtleV07XG5cbiAgICAgIGZvciAoc3R5bGVOYW1lIGluIGxhc3RTdHlsZSkge1xuICAgICAgICBpZiAobGFzdFN0eWxlLmhhc093blByb3BlcnR5KHN0eWxlTmFtZSkpIHtcbiAgICAgICAgICBpZiAoIXN0eWxlVXBkYXRlcykge1xuICAgICAgICAgICAgc3R5bGVVcGRhdGVzID0ge307XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgc3R5bGVVcGRhdGVzW3N0eWxlTmFtZV0gPSAnJztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocHJvcEtleSA9PT0gREFOR0VST1VTTFlfU0VUX0lOTkVSX0hUTUwgfHwgcHJvcEtleSA9PT0gQ0hJTERSRU4pIDsgZWxzZSBpZiAocHJvcEtleSA9PT0gU1VQUFJFU1NfQ09OVEVOVF9FRElUQUJMRV9XQVJOSU5HIHx8IHByb3BLZXkgPT09IFNVUFBSRVNTX0hZRFJBVElPTl9XQVJOSU5HKSA7IGVsc2UgaWYgKHByb3BLZXkgPT09IEFVVE9GT0NVUykgOyBlbHNlIGlmIChyZWdpc3RyYXRpb25OYW1lRGVwZW5kZW5jaWVzLmhhc093blByb3BlcnR5KHByb3BLZXkpKSB7XG4gICAgICAvLyBUaGlzIGlzIGEgc3BlY2lhbCBjYXNlLiBJZiBhbnkgbGlzdGVuZXIgdXBkYXRlcyB3ZSBuZWVkIHRvIGVuc3VyZVxuICAgICAgLy8gdGhhdCB0aGUgXCJjdXJyZW50XCIgZmliZXIgcG9pbnRlciBnZXRzIHVwZGF0ZWQgc28gd2UgbmVlZCBhIGNvbW1pdFxuICAgICAgLy8gdG8gdXBkYXRlIHRoaXMgZWxlbWVudC5cbiAgICAgIGlmICghdXBkYXRlUGF5bG9hZCkge1xuICAgICAgICB1cGRhdGVQYXlsb2FkID0gW107XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEZvciBhbGwgb3RoZXIgZGVsZXRlZCBwcm9wZXJ0aWVzIHdlIGFkZCBpdCB0byB0aGUgcXVldWUuIFdlIHVzZVxuICAgICAgLy8gdGhlIGFsbG93ZWQgcHJvcGVydHkgbGlzdCBpbiB0aGUgY29tbWl0IHBoYXNlIGluc3RlYWQuXG4gICAgICAodXBkYXRlUGF5bG9hZCA9IHVwZGF0ZVBheWxvYWQgfHwgW10pLnB1c2gocHJvcEtleSwgbnVsbCk7XG4gICAgfVxuICB9XG5cbiAgZm9yIChwcm9wS2V5IGluIG5leHRQcm9wcykge1xuICAgIHZhciBuZXh0UHJvcCA9IG5leHRQcm9wc1twcm9wS2V5XTtcbiAgICB2YXIgbGFzdFByb3AgPSBsYXN0UHJvcHMgIT0gbnVsbCA/IGxhc3RQcm9wc1twcm9wS2V5XSA6IHVuZGVmaW5lZDtcblxuICAgIGlmICghbmV4dFByb3BzLmhhc093blByb3BlcnR5KHByb3BLZXkpIHx8IG5leHRQcm9wID09PSBsYXN0UHJvcCB8fCBuZXh0UHJvcCA9PSBudWxsICYmIGxhc3RQcm9wID09IG51bGwpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmIChwcm9wS2V5ID09PSBTVFlMRSkge1xuICAgICAge1xuICAgICAgICBpZiAobmV4dFByb3ApIHtcbiAgICAgICAgICAvLyBGcmVlemUgdGhlIG5leHQgc3R5bGUgb2JqZWN0IHNvIHRoYXQgd2UgY2FuIGFzc3VtZSBpdCB3b24ndCBiZVxuICAgICAgICAgIC8vIG11dGF0ZWQuIFdlIGhhdmUgYWxyZWFkeSB3YXJuZWQgZm9yIHRoaXMgaW4gdGhlIHBhc3QuXG4gICAgICAgICAgT2JqZWN0LmZyZWV6ZShuZXh0UHJvcCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGxhc3RQcm9wKSB7XG4gICAgICAgIC8vIFVuc2V0IHN0eWxlcyBvbiBgbGFzdFByb3BgIGJ1dCBub3Qgb24gYG5leHRQcm9wYC5cbiAgICAgICAgZm9yIChzdHlsZU5hbWUgaW4gbGFzdFByb3ApIHtcbiAgICAgICAgICBpZiAobGFzdFByb3AuaGFzT3duUHJvcGVydHkoc3R5bGVOYW1lKSAmJiAoIW5leHRQcm9wIHx8ICFuZXh0UHJvcC5oYXNPd25Qcm9wZXJ0eShzdHlsZU5hbWUpKSkge1xuICAgICAgICAgICAgaWYgKCFzdHlsZVVwZGF0ZXMpIHtcbiAgICAgICAgICAgICAgc3R5bGVVcGRhdGVzID0ge307XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHN0eWxlVXBkYXRlc1tzdHlsZU5hbWVdID0gJyc7XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vIFVwZGF0ZSBzdHlsZXMgdGhhdCBjaGFuZ2VkIHNpbmNlIGBsYXN0UHJvcGAuXG5cblxuICAgICAgICBmb3IgKHN0eWxlTmFtZSBpbiBuZXh0UHJvcCkge1xuICAgICAgICAgIGlmIChuZXh0UHJvcC5oYXNPd25Qcm9wZXJ0eShzdHlsZU5hbWUpICYmIGxhc3RQcm9wW3N0eWxlTmFtZV0gIT09IG5leHRQcm9wW3N0eWxlTmFtZV0pIHtcbiAgICAgICAgICAgIGlmICghc3R5bGVVcGRhdGVzKSB7XG4gICAgICAgICAgICAgIHN0eWxlVXBkYXRlcyA9IHt9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzdHlsZVVwZGF0ZXNbc3R5bGVOYW1lXSA9IG5leHRQcm9wW3N0eWxlTmFtZV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBSZWxpZXMgb24gYHVwZGF0ZVN0eWxlc0J5SURgIG5vdCBtdXRhdGluZyBgc3R5bGVVcGRhdGVzYC5cbiAgICAgICAgaWYgKCFzdHlsZVVwZGF0ZXMpIHtcbiAgICAgICAgICBpZiAoIXVwZGF0ZVBheWxvYWQpIHtcbiAgICAgICAgICAgIHVwZGF0ZVBheWxvYWQgPSBbXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB1cGRhdGVQYXlsb2FkLnB1c2gocHJvcEtleSwgc3R5bGVVcGRhdGVzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN0eWxlVXBkYXRlcyA9IG5leHRQcm9wO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocHJvcEtleSA9PT0gREFOR0VST1VTTFlfU0VUX0lOTkVSX0hUTUwpIHtcbiAgICAgIHZhciBuZXh0SHRtbCA9IG5leHRQcm9wID8gbmV4dFByb3BbSFRNTCQxXSA6IHVuZGVmaW5lZDtcbiAgICAgIHZhciBsYXN0SHRtbCA9IGxhc3RQcm9wID8gbGFzdFByb3BbSFRNTCQxXSA6IHVuZGVmaW5lZDtcblxuICAgICAgaWYgKG5leHRIdG1sICE9IG51bGwpIHtcbiAgICAgICAgaWYgKGxhc3RIdG1sICE9PSBuZXh0SHRtbCkge1xuICAgICAgICAgICh1cGRhdGVQYXlsb2FkID0gdXBkYXRlUGF5bG9hZCB8fCBbXSkucHVzaChwcm9wS2V5LCBuZXh0SHRtbCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHByb3BLZXkgPT09IENISUxEUkVOKSB7XG4gICAgICBpZiAodHlwZW9mIG5leHRQcm9wID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgbmV4dFByb3AgPT09ICdudW1iZXInKSB7XG4gICAgICAgICh1cGRhdGVQYXlsb2FkID0gdXBkYXRlUGF5bG9hZCB8fCBbXSkucHVzaChwcm9wS2V5LCAnJyArIG5leHRQcm9wKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHByb3BLZXkgPT09IFNVUFBSRVNTX0NPTlRFTlRfRURJVEFCTEVfV0FSTklORyB8fCBwcm9wS2V5ID09PSBTVVBQUkVTU19IWURSQVRJT05fV0FSTklORykgOyBlbHNlIGlmIChyZWdpc3RyYXRpb25OYW1lRGVwZW5kZW5jaWVzLmhhc093blByb3BlcnR5KHByb3BLZXkpKSB7XG4gICAgICBpZiAobmV4dFByb3AgIT0gbnVsbCkge1xuICAgICAgICAvLyBXZSBlYWdlcmx5IGxpc3RlbiB0byB0aGlzIGV2ZW4gdGhvdWdoIHdlIGhhdmVuJ3QgY29tbWl0dGVkIHlldC5cbiAgICAgICAgaWYgKCB0eXBlb2YgbmV4dFByb3AgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICB3YXJuRm9ySW52YWxpZEV2ZW50TGlzdGVuZXIocHJvcEtleSwgbmV4dFByb3ApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHByb3BLZXkgPT09ICdvblNjcm9sbCcpIHtcbiAgICAgICAgICBsaXN0ZW5Ub05vbkRlbGVnYXRlZEV2ZW50KCdzY3JvbGwnLCBkb21FbGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoIXVwZGF0ZVBheWxvYWQgJiYgbGFzdFByb3AgIT09IG5leHRQcm9wKSB7XG4gICAgICAgIC8vIFRoaXMgaXMgYSBzcGVjaWFsIGNhc2UuIElmIGFueSBsaXN0ZW5lciB1cGRhdGVzIHdlIG5lZWQgdG8gZW5zdXJlXG4gICAgICAgIC8vIHRoYXQgdGhlIFwiY3VycmVudFwiIHByb3BzIHBvaW50ZXIgZ2V0cyB1cGRhdGVkIHNvIHdlIG5lZWQgYSBjb21taXRcbiAgICAgICAgLy8gdG8gdXBkYXRlIHRoaXMgZWxlbWVudC5cbiAgICAgICAgdXBkYXRlUGF5bG9hZCA9IFtdO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodHlwZW9mIG5leHRQcm9wID09PSAnb2JqZWN0JyAmJiBuZXh0UHJvcCAhPT0gbnVsbCAmJiBuZXh0UHJvcC4kJHR5cGVvZiA9PT0gUkVBQ1RfT1BBUVVFX0lEX1RZUEUpIHtcbiAgICAgIC8vIElmIHdlIGVuY291bnRlciB1c2VPcGFxdWVSZWZlcmVuY2UncyBvcGFxdWUgb2JqZWN0LCB0aGlzIG1lYW5zIHdlIGFyZSBoeWRyYXRpbmcuXG4gICAgICAvLyBJbiB0aGlzIGNhc2UsIGNhbGwgdGhlIG9wYXF1ZSBvYmplY3QncyB0b1N0cmluZyBmdW5jdGlvbiB3aGljaCBnZW5lcmF0ZXMgYSBuZXcgY2xpZW50XG4gICAgICAvLyBJRCBzbyBjbGllbnQgYW5kIHNlcnZlciBJRHMgbWF0Y2ggYW5kIHRocm93cyB0byByZXJlbmRlci5cbiAgICAgIG5leHRQcm9wLnRvU3RyaW5nKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEZvciBhbnkgb3RoZXIgcHJvcGVydHkgd2UgYWx3YXlzIGFkZCBpdCB0byB0aGUgcXVldWUgYW5kIHRoZW4gd2VcbiAgICAgIC8vIGZpbHRlciBpdCBvdXQgdXNpbmcgdGhlIGFsbG93ZWQgcHJvcGVydHkgbGlzdCBkdXJpbmcgdGhlIGNvbW1pdC5cbiAgICAgICh1cGRhdGVQYXlsb2FkID0gdXBkYXRlUGF5bG9hZCB8fCBbXSkucHVzaChwcm9wS2V5LCBuZXh0UHJvcCk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHN0eWxlVXBkYXRlcykge1xuICAgIHtcbiAgICAgIHZhbGlkYXRlU2hvcnRoYW5kUHJvcGVydHlDb2xsaXNpb25JbkRldihzdHlsZVVwZGF0ZXMsIG5leHRQcm9wc1tTVFlMRV0pO1xuICAgIH1cblxuICAgICh1cGRhdGVQYXlsb2FkID0gdXBkYXRlUGF5bG9hZCB8fCBbXSkucHVzaChTVFlMRSwgc3R5bGVVcGRhdGVzKTtcbiAgfVxuXG4gIHJldHVybiB1cGRhdGVQYXlsb2FkO1xufSAvLyBBcHBseSB0aGUgZGlmZi5cblxuZnVuY3Rpb24gdXBkYXRlUHJvcGVydGllcyhkb21FbGVtZW50LCB1cGRhdGVQYXlsb2FkLCB0YWcsIGxhc3RSYXdQcm9wcywgbmV4dFJhd1Byb3BzKSB7XG4gIC8vIFVwZGF0ZSBjaGVja2VkICpiZWZvcmUqIG5hbWUuXG4gIC8vIEluIHRoZSBtaWRkbGUgb2YgYW4gdXBkYXRlLCBpdCBpcyBwb3NzaWJsZSB0byBoYXZlIG11bHRpcGxlIGNoZWNrZWQuXG4gIC8vIFdoZW4gYSBjaGVja2VkIHJhZGlvIHRyaWVzIHRvIGNoYW5nZSBuYW1lLCBicm93c2VyIG1ha2VzIGFub3RoZXIgcmFkaW8ncyBjaGVja2VkIGZhbHNlLlxuICBpZiAodGFnID09PSAnaW5wdXQnICYmIG5leHRSYXdQcm9wcy50eXBlID09PSAncmFkaW8nICYmIG5leHRSYXdQcm9wcy5uYW1lICE9IG51bGwpIHtcbiAgICB1cGRhdGVDaGVja2VkKGRvbUVsZW1lbnQsIG5leHRSYXdQcm9wcyk7XG4gIH1cblxuICB2YXIgd2FzQ3VzdG9tQ29tcG9uZW50VGFnID0gaXNDdXN0b21Db21wb25lbnQodGFnLCBsYXN0UmF3UHJvcHMpO1xuICB2YXIgaXNDdXN0b21Db21wb25lbnRUYWcgPSBpc0N1c3RvbUNvbXBvbmVudCh0YWcsIG5leHRSYXdQcm9wcyk7IC8vIEFwcGx5IHRoZSBkaWZmLlxuXG4gIHVwZGF0ZURPTVByb3BlcnRpZXMoZG9tRWxlbWVudCwgdXBkYXRlUGF5bG9hZCwgd2FzQ3VzdG9tQ29tcG9uZW50VGFnLCBpc0N1c3RvbUNvbXBvbmVudFRhZyk7IC8vIFRPRE86IEVuc3VyZSB0aGF0IGFuIHVwZGF0ZSBnZXRzIHNjaGVkdWxlZCBpZiBhbnkgb2YgdGhlIHNwZWNpYWwgcHJvcHNcbiAgLy8gY2hhbmdlZC5cblxuICBzd2l0Y2ggKHRhZykge1xuICAgIGNhc2UgJ2lucHV0JzpcbiAgICAgIC8vIFVwZGF0ZSB0aGUgd3JhcHBlciBhcm91bmQgaW5wdXRzICphZnRlciogdXBkYXRpbmcgcHJvcHMuIFRoaXMgaGFzIHRvXG4gICAgICAvLyBoYXBwZW4gYWZ0ZXIgYHVwZGF0ZURPTVByb3BlcnRpZXNgLiBPdGhlcndpc2UgSFRNTDUgaW5wdXQgdmFsaWRhdGlvbnNcbiAgICAgIC8vIHJhaXNlIHdhcm5pbmdzIGFuZCBwcmV2ZW50IHRoZSBuZXcgdmFsdWUgZnJvbSBiZWluZyBhc3NpZ25lZC5cbiAgICAgIHVwZGF0ZVdyYXBwZXIoZG9tRWxlbWVudCwgbmV4dFJhd1Byb3BzKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAndGV4dGFyZWEnOlxuICAgICAgdXBkYXRlV3JhcHBlciQxKGRvbUVsZW1lbnQsIG5leHRSYXdQcm9wcyk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ3NlbGVjdCc6XG4gICAgICAvLyA8c2VsZWN0PiB2YWx1ZSB1cGRhdGUgbmVlZHMgdG8gb2NjdXIgYWZ0ZXIgPG9wdGlvbj4gY2hpbGRyZW5cbiAgICAgIC8vIHJlY29uY2lsaWF0aW9uXG4gICAgICBwb3N0VXBkYXRlV3JhcHBlcihkb21FbGVtZW50LCBuZXh0UmF3UHJvcHMpO1xuICAgICAgYnJlYWs7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0UG9zc2libGVTdGFuZGFyZE5hbWUocHJvcE5hbWUpIHtcbiAge1xuICAgIHZhciBsb3dlckNhc2VkTmFtZSA9IHByb3BOYW1lLnRvTG93ZXJDYXNlKCk7XG5cbiAgICBpZiAoIXBvc3NpYmxlU3RhbmRhcmROYW1lcy5oYXNPd25Qcm9wZXJ0eShsb3dlckNhc2VkTmFtZSkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiBwb3NzaWJsZVN0YW5kYXJkTmFtZXNbbG93ZXJDYXNlZE5hbWVdIHx8IG51bGw7XG4gIH1cbn1cblxuZnVuY3Rpb24gZGlmZkh5ZHJhdGVkUHJvcGVydGllcyhkb21FbGVtZW50LCB0YWcsIHJhd1Byb3BzLCBwYXJlbnROYW1lc3BhY2UsIHJvb3RDb250YWluZXJFbGVtZW50KSB7XG4gIHZhciBpc0N1c3RvbUNvbXBvbmVudFRhZztcbiAgdmFyIGV4dHJhQXR0cmlidXRlTmFtZXM7XG5cbiAge1xuICAgIHN1cHByZXNzSHlkcmF0aW9uV2FybmluZyA9IHJhd1Byb3BzW1NVUFBSRVNTX0hZRFJBVElPTl9XQVJOSU5HXSA9PT0gdHJ1ZTtcbiAgICBpc0N1c3RvbUNvbXBvbmVudFRhZyA9IGlzQ3VzdG9tQ29tcG9uZW50KHRhZywgcmF3UHJvcHMpO1xuICAgIHZhbGlkYXRlUHJvcGVydGllc0luRGV2ZWxvcG1lbnQodGFnLCByYXdQcm9wcyk7XG4gIH0gLy8gVE9ETzogTWFrZSBzdXJlIHRoYXQgd2UgY2hlY2sgaXNNb3VudGVkIGJlZm9yZSBmaXJpbmcgYW55IG9mIHRoZXNlIGV2ZW50cy5cblxuXG4gIHN3aXRjaCAodGFnKSB7XG4gICAgY2FzZSAnZGlhbG9nJzpcbiAgICAgIGxpc3RlblRvTm9uRGVsZWdhdGVkRXZlbnQoJ2NhbmNlbCcsIGRvbUVsZW1lbnQpO1xuICAgICAgbGlzdGVuVG9Ob25EZWxlZ2F0ZWRFdmVudCgnY2xvc2UnLCBkb21FbGVtZW50KTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnaWZyYW1lJzpcbiAgICBjYXNlICdvYmplY3QnOlxuICAgIGNhc2UgJ2VtYmVkJzpcbiAgICAgIC8vIFdlIGxpc3RlbiB0byB0aGlzIGV2ZW50IGluIGNhc2UgdG8gZW5zdXJlIGVtdWxhdGVkIGJ1YmJsZVxuICAgICAgLy8gbGlzdGVuZXJzIHN0aWxsIGZpcmUgZm9yIHRoZSBsb2FkIGV2ZW50LlxuICAgICAgbGlzdGVuVG9Ob25EZWxlZ2F0ZWRFdmVudCgnbG9hZCcsIGRvbUVsZW1lbnQpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICd2aWRlbyc6XG4gICAgY2FzZSAnYXVkaW8nOlxuICAgICAgLy8gV2UgbGlzdGVuIHRvIHRoZXNlIGV2ZW50cyBpbiBjYXNlIHRvIGVuc3VyZSBlbXVsYXRlZCBidWJibGVcbiAgICAgIC8vIGxpc3RlbmVycyBzdGlsbCBmaXJlIGZvciBhbGwgdGhlIG1lZGlhIGV2ZW50cy5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWVkaWFFdmVudFR5cGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxpc3RlblRvTm9uRGVsZWdhdGVkRXZlbnQobWVkaWFFdmVudFR5cGVzW2ldLCBkb21FbGVtZW50KTtcbiAgICAgIH1cblxuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdzb3VyY2UnOlxuICAgICAgLy8gV2UgbGlzdGVuIHRvIHRoaXMgZXZlbnQgaW4gY2FzZSB0byBlbnN1cmUgZW11bGF0ZWQgYnViYmxlXG4gICAgICAvLyBsaXN0ZW5lcnMgc3RpbGwgZmlyZSBmb3IgdGhlIGVycm9yIGV2ZW50LlxuICAgICAgbGlzdGVuVG9Ob25EZWxlZ2F0ZWRFdmVudCgnZXJyb3InLCBkb21FbGVtZW50KTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnaW1nJzpcbiAgICBjYXNlICdpbWFnZSc6XG4gICAgY2FzZSAnbGluayc6XG4gICAgICAvLyBXZSBsaXN0ZW4gdG8gdGhlc2UgZXZlbnRzIGluIGNhc2UgdG8gZW5zdXJlIGVtdWxhdGVkIGJ1YmJsZVxuICAgICAgLy8gbGlzdGVuZXJzIHN0aWxsIGZpcmUgZm9yIGVycm9yIGFuZCBsb2FkIGV2ZW50cy5cbiAgICAgIGxpc3RlblRvTm9uRGVsZWdhdGVkRXZlbnQoJ2Vycm9yJywgZG9tRWxlbWVudCk7XG4gICAgICBsaXN0ZW5Ub05vbkRlbGVnYXRlZEV2ZW50KCdsb2FkJywgZG9tRWxlbWVudCk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ2RldGFpbHMnOlxuICAgICAgLy8gV2UgbGlzdGVuIHRvIHRoaXMgZXZlbnQgaW4gY2FzZSB0byBlbnN1cmUgZW11bGF0ZWQgYnViYmxlXG4gICAgICAvLyBsaXN0ZW5lcnMgc3RpbGwgZmlyZSBmb3IgdGhlIHRvZ2dsZSBldmVudC5cbiAgICAgIGxpc3RlblRvTm9uRGVsZWdhdGVkRXZlbnQoJ3RvZ2dsZScsIGRvbUVsZW1lbnQpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdpbnB1dCc6XG4gICAgICBpbml0V3JhcHBlclN0YXRlKGRvbUVsZW1lbnQsIHJhd1Byb3BzKTsgLy8gV2UgbGlzdGVuIHRvIHRoaXMgZXZlbnQgaW4gY2FzZSB0byBlbnN1cmUgZW11bGF0ZWQgYnViYmxlXG4gICAgICAvLyBsaXN0ZW5lcnMgc3RpbGwgZmlyZSBmb3IgdGhlIGludmFsaWQgZXZlbnQuXG5cbiAgICAgIGxpc3RlblRvTm9uRGVsZWdhdGVkRXZlbnQoJ2ludmFsaWQnLCBkb21FbGVtZW50KTtcblxuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdvcHRpb24nOlxuICAgICAgdmFsaWRhdGVQcm9wcyhkb21FbGVtZW50LCByYXdQcm9wcyk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ3NlbGVjdCc6XG4gICAgICBpbml0V3JhcHBlclN0YXRlJDEoZG9tRWxlbWVudCwgcmF3UHJvcHMpOyAvLyBXZSBsaXN0ZW4gdG8gdGhpcyBldmVudCBpbiBjYXNlIHRvIGVuc3VyZSBlbXVsYXRlZCBidWJibGVcbiAgICAgIC8vIGxpc3RlbmVycyBzdGlsbCBmaXJlIGZvciB0aGUgaW52YWxpZCBldmVudC5cblxuICAgICAgbGlzdGVuVG9Ob25EZWxlZ2F0ZWRFdmVudCgnaW52YWxpZCcsIGRvbUVsZW1lbnQpO1xuXG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ3RleHRhcmVhJzpcbiAgICAgIGluaXRXcmFwcGVyU3RhdGUkMihkb21FbGVtZW50LCByYXdQcm9wcyk7IC8vIFdlIGxpc3RlbiB0byB0aGlzIGV2ZW50IGluIGNhc2UgdG8gZW5zdXJlIGVtdWxhdGVkIGJ1YmJsZVxuICAgICAgLy8gbGlzdGVuZXJzIHN0aWxsIGZpcmUgZm9yIHRoZSBpbnZhbGlkIGV2ZW50LlxuXG4gICAgICBsaXN0ZW5Ub05vbkRlbGVnYXRlZEV2ZW50KCdpbnZhbGlkJywgZG9tRWxlbWVudCk7XG5cbiAgICAgIGJyZWFrO1xuICB9XG5cbiAgYXNzZXJ0VmFsaWRQcm9wcyh0YWcsIHJhd1Byb3BzKTtcblxuICB7XG4gICAgZXh0cmFBdHRyaWJ1dGVOYW1lcyA9IG5ldyBTZXQoKTtcbiAgICB2YXIgYXR0cmlidXRlcyA9IGRvbUVsZW1lbnQuYXR0cmlidXRlcztcblxuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhdHRyaWJ1dGVzLmxlbmd0aDsgX2krKykge1xuICAgICAgdmFyIG5hbWUgPSBhdHRyaWJ1dGVzW19pXS5uYW1lLnRvTG93ZXJDYXNlKCk7XG5cbiAgICAgIHN3aXRjaCAobmFtZSkge1xuICAgICAgICAvLyBCdWlsdC1pbiBTU1IgYXR0cmlidXRlIGlzIGFsbG93ZWRcbiAgICAgICAgY2FzZSAnZGF0YS1yZWFjdHJvb3QnOlxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICAvLyBDb250cm9sbGVkIGF0dHJpYnV0ZXMgYXJlIG5vdCB2YWxpZGF0ZWRcbiAgICAgICAgLy8gVE9ETzogT25seSBpZ25vcmUgdGhlbSBvbiBjb250cm9sbGVkIHRhZ3MuXG5cbiAgICAgICAgY2FzZSAndmFsdWUnOlxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ2NoZWNrZWQnOlxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ3NlbGVjdGVkJzpcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIC8vIEludGVudGlvbmFsbHkgdXNlIHRoZSBvcmlnaW5hbCBuYW1lLlxuICAgICAgICAgIC8vIFNlZSBkaXNjdXNzaW9uIGluIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9wdWxsLzEwNjc2LlxuICAgICAgICAgIGV4dHJhQXR0cmlidXRlTmFtZXMuYWRkKGF0dHJpYnV0ZXNbX2ldLm5hbWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciB1cGRhdGVQYXlsb2FkID0gbnVsbDtcblxuICBmb3IgKHZhciBwcm9wS2V5IGluIHJhd1Byb3BzKSB7XG4gICAgaWYgKCFyYXdQcm9wcy5oYXNPd25Qcm9wZXJ0eShwcm9wS2V5KSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgdmFyIG5leHRQcm9wID0gcmF3UHJvcHNbcHJvcEtleV07XG5cbiAgICBpZiAocHJvcEtleSA9PT0gQ0hJTERSRU4pIHtcbiAgICAgIC8vIEZvciB0ZXh0IGNvbnRlbnQgY2hpbGRyZW4gd2UgY29tcGFyZSBhZ2FpbnN0IHRleHRDb250ZW50LiBUaGlzXG4gICAgICAvLyBtaWdodCBtYXRjaCBhZGRpdGlvbmFsIEhUTUwgdGhhdCBpcyBoaWRkZW4gd2hlbiB3ZSByZWFkIGl0IHVzaW5nXG4gICAgICAvLyB0ZXh0Q29udGVudC4gRS5nLiBcImZvb1wiIHdpbGwgbWF0Y2ggXCJmPHNwYW4+b288L3NwYW4+XCIgYnV0IHRoYXQgc3RpbGxcbiAgICAgIC8vIHNhdGlzZmllcyBvdXIgcmVxdWlyZW1lbnQuIE91ciByZXF1aXJlbWVudCBpcyBub3QgdG8gcHJvZHVjZSBwZXJmZWN0XG4gICAgICAvLyBIVE1MIGFuZCBhdHRyaWJ1dGVzLiBJZGVhbGx5IHdlIHNob3VsZCBwcmVzZXJ2ZSBzdHJ1Y3R1cmUgYnV0IGl0J3NcbiAgICAgIC8vIG9rIG5vdCB0byBpZiB0aGUgdmlzaWJsZSBjb250ZW50IGlzIHN0aWxsIGVub3VnaCB0byBpbmRpY2F0ZSB3aGF0XG4gICAgICAvLyBldmVuIGxpc3RlbmVycyB0aGVzZSBub2RlcyBtaWdodCBiZSB3aXJlZCB1cCB0by5cbiAgICAgIC8vIFRPRE86IFdhcm4gaWYgdGhlcmUgaXMgbW9yZSB0aGFuIGEgc2luZ2xlIHRleHROb2RlIGFzIGEgY2hpbGQuXG4gICAgICAvLyBUT0RPOiBTaG91bGQgd2UgdXNlIGRvbUVsZW1lbnQuZmlyc3RDaGlsZC5ub2RlVmFsdWUgdG8gY29tcGFyZT9cbiAgICAgIGlmICh0eXBlb2YgbmV4dFByb3AgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGlmIChkb21FbGVtZW50LnRleHRDb250ZW50ICE9PSBuZXh0UHJvcCkge1xuICAgICAgICAgIGlmICggIXN1cHByZXNzSHlkcmF0aW9uV2FybmluZykge1xuICAgICAgICAgICAgd2FybkZvclRleHREaWZmZXJlbmNlKGRvbUVsZW1lbnQudGV4dENvbnRlbnQsIG5leHRQcm9wKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB1cGRhdGVQYXlsb2FkID0gW0NISUxEUkVOLCBuZXh0UHJvcF07XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIG5leHRQcm9wID09PSAnbnVtYmVyJykge1xuICAgICAgICBpZiAoZG9tRWxlbWVudC50ZXh0Q29udGVudCAhPT0gJycgKyBuZXh0UHJvcCkge1xuICAgICAgICAgIGlmICggIXN1cHByZXNzSHlkcmF0aW9uV2FybmluZykge1xuICAgICAgICAgICAgd2FybkZvclRleHREaWZmZXJlbmNlKGRvbUVsZW1lbnQudGV4dENvbnRlbnQsIG5leHRQcm9wKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB1cGRhdGVQYXlsb2FkID0gW0NISUxEUkVOLCAnJyArIG5leHRQcm9wXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocmVnaXN0cmF0aW9uTmFtZURlcGVuZGVuY2llcy5oYXNPd25Qcm9wZXJ0eShwcm9wS2V5KSkge1xuICAgICAgaWYgKG5leHRQcm9wICE9IG51bGwpIHtcbiAgICAgICAgaWYgKCB0eXBlb2YgbmV4dFByb3AgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICB3YXJuRm9ySW52YWxpZEV2ZW50TGlzdGVuZXIocHJvcEtleSwgbmV4dFByb3ApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHByb3BLZXkgPT09ICdvblNjcm9sbCcpIHtcbiAgICAgICAgICBsaXN0ZW5Ub05vbkRlbGVnYXRlZEV2ZW50KCdzY3JvbGwnLCBkb21FbGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIC8vIENvbnZpbmNlIEZsb3cgd2UndmUgY2FsY3VsYXRlZCBpdCAoaXQncyBERVYtb25seSBpbiB0aGlzIG1ldGhvZC4pXG4gICAgdHlwZW9mIGlzQ3VzdG9tQ29tcG9uZW50VGFnID09PSAnYm9vbGVhbicpIHtcbiAgICAgIC8vIFZhbGlkYXRlIHRoYXQgdGhlIHByb3BlcnRpZXMgY29ycmVzcG9uZCB0byB0aGVpciBleHBlY3RlZCB2YWx1ZXMuXG4gICAgICB2YXIgc2VydmVyVmFsdWUgPSB2b2lkIDA7XG4gICAgICB2YXIgcHJvcGVydHlJbmZvID0gZ2V0UHJvcGVydHlJbmZvKHByb3BLZXkpO1xuXG4gICAgICBpZiAoc3VwcHJlc3NIeWRyYXRpb25XYXJuaW5nKSA7IGVsc2UgaWYgKHByb3BLZXkgPT09IFNVUFBSRVNTX0NPTlRFTlRfRURJVEFCTEVfV0FSTklORyB8fCBwcm9wS2V5ID09PSBTVVBQUkVTU19IWURSQVRJT05fV0FSTklORyB8fCAvLyBDb250cm9sbGVkIGF0dHJpYnV0ZXMgYXJlIG5vdCB2YWxpZGF0ZWRcbiAgICAgIC8vIFRPRE86IE9ubHkgaWdub3JlIHRoZW0gb24gY29udHJvbGxlZCB0YWdzLlxuICAgICAgcHJvcEtleSA9PT0gJ3ZhbHVlJyB8fCBwcm9wS2V5ID09PSAnY2hlY2tlZCcgfHwgcHJvcEtleSA9PT0gJ3NlbGVjdGVkJykgOyBlbHNlIGlmIChwcm9wS2V5ID09PSBEQU5HRVJPVVNMWV9TRVRfSU5ORVJfSFRNTCkge1xuICAgICAgICB2YXIgc2VydmVySFRNTCA9IGRvbUVsZW1lbnQuaW5uZXJIVE1MO1xuICAgICAgICB2YXIgbmV4dEh0bWwgPSBuZXh0UHJvcCA/IG5leHRQcm9wW0hUTUwkMV0gOiB1bmRlZmluZWQ7XG5cbiAgICAgICAgaWYgKG5leHRIdG1sICE9IG51bGwpIHtcbiAgICAgICAgICB2YXIgZXhwZWN0ZWRIVE1MID0gbm9ybWFsaXplSFRNTChkb21FbGVtZW50LCBuZXh0SHRtbCk7XG5cbiAgICAgICAgICBpZiAoZXhwZWN0ZWRIVE1MICE9PSBzZXJ2ZXJIVE1MKSB7XG4gICAgICAgICAgICB3YXJuRm9yUHJvcERpZmZlcmVuY2UocHJvcEtleSwgc2VydmVySFRNTCwgZXhwZWN0ZWRIVE1MKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAocHJvcEtleSA9PT0gU1RZTEUpIHtcbiAgICAgICAgLy8gJEZsb3dGaXhNZSAtIFNob3VsZCBiZSBpbmZlcnJlZCBhcyBub3QgdW5kZWZpbmVkLlxuICAgICAgICBleHRyYUF0dHJpYnV0ZU5hbWVzLmRlbGV0ZShwcm9wS2V5KTtcblxuICAgICAgICBpZiAoY2FuRGlmZlN0eWxlRm9ySHlkcmF0aW9uV2FybmluZykge1xuICAgICAgICAgIHZhciBleHBlY3RlZFN0eWxlID0gY3JlYXRlRGFuZ2Vyb3VzU3RyaW5nRm9yU3R5bGVzKG5leHRQcm9wKTtcbiAgICAgICAgICBzZXJ2ZXJWYWx1ZSA9IGRvbUVsZW1lbnQuZ2V0QXR0cmlidXRlKCdzdHlsZScpO1xuXG4gICAgICAgICAgaWYgKGV4cGVjdGVkU3R5bGUgIT09IHNlcnZlclZhbHVlKSB7XG4gICAgICAgICAgICB3YXJuRm9yUHJvcERpZmZlcmVuY2UocHJvcEtleSwgc2VydmVyVmFsdWUsIGV4cGVjdGVkU3R5bGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChpc0N1c3RvbUNvbXBvbmVudFRhZykge1xuICAgICAgICAvLyAkRmxvd0ZpeE1lIC0gU2hvdWxkIGJlIGluZmVycmVkIGFzIG5vdCB1bmRlZmluZWQuXG4gICAgICAgIGV4dHJhQXR0cmlidXRlTmFtZXMuZGVsZXRlKHByb3BLZXkudG9Mb3dlckNhc2UoKSk7XG4gICAgICAgIHNlcnZlclZhbHVlID0gZ2V0VmFsdWVGb3JBdHRyaWJ1dGUoZG9tRWxlbWVudCwgcHJvcEtleSwgbmV4dFByb3ApO1xuXG4gICAgICAgIGlmIChuZXh0UHJvcCAhPT0gc2VydmVyVmFsdWUpIHtcbiAgICAgICAgICB3YXJuRm9yUHJvcERpZmZlcmVuY2UocHJvcEtleSwgc2VydmVyVmFsdWUsIG5leHRQcm9wKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICghc2hvdWxkSWdub3JlQXR0cmlidXRlKHByb3BLZXksIHByb3BlcnR5SW5mbywgaXNDdXN0b21Db21wb25lbnRUYWcpICYmICFzaG91bGRSZW1vdmVBdHRyaWJ1dGUocHJvcEtleSwgbmV4dFByb3AsIHByb3BlcnR5SW5mbywgaXNDdXN0b21Db21wb25lbnRUYWcpKSB7XG4gICAgICAgIHZhciBpc01pc21hdGNoRHVlVG9CYWRDYXNpbmcgPSBmYWxzZTtcblxuICAgICAgICBpZiAocHJvcGVydHlJbmZvICE9PSBudWxsKSB7XG4gICAgICAgICAgLy8gJEZsb3dGaXhNZSAtIFNob3VsZCBiZSBpbmZlcnJlZCBhcyBub3QgdW5kZWZpbmVkLlxuICAgICAgICAgIGV4dHJhQXR0cmlidXRlTmFtZXMuZGVsZXRlKHByb3BlcnR5SW5mby5hdHRyaWJ1dGVOYW1lKTtcbiAgICAgICAgICBzZXJ2ZXJWYWx1ZSA9IGdldFZhbHVlRm9yUHJvcGVydHkoZG9tRWxlbWVudCwgcHJvcEtleSwgbmV4dFByb3AsIHByb3BlcnR5SW5mbyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIG93bk5hbWVzcGFjZSA9IHBhcmVudE5hbWVzcGFjZTtcblxuICAgICAgICAgIGlmIChvd25OYW1lc3BhY2UgPT09IEhUTUxfTkFNRVNQQUNFJDEpIHtcbiAgICAgICAgICAgIG93bk5hbWVzcGFjZSA9IGdldEludHJpbnNpY05hbWVzcGFjZSh0YWcpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChvd25OYW1lc3BhY2UgPT09IEhUTUxfTkFNRVNQQUNFJDEpIHtcbiAgICAgICAgICAgIC8vICRGbG93Rml4TWUgLSBTaG91bGQgYmUgaW5mZXJyZWQgYXMgbm90IHVuZGVmaW5lZC5cbiAgICAgICAgICAgIGV4dHJhQXR0cmlidXRlTmFtZXMuZGVsZXRlKHByb3BLZXkudG9Mb3dlckNhc2UoKSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBzdGFuZGFyZE5hbWUgPSBnZXRQb3NzaWJsZVN0YW5kYXJkTmFtZShwcm9wS2V5KTtcblxuICAgICAgICAgICAgaWYgKHN0YW5kYXJkTmFtZSAhPT0gbnVsbCAmJiBzdGFuZGFyZE5hbWUgIT09IHByb3BLZXkpIHtcbiAgICAgICAgICAgICAgLy8gSWYgYW4gU1ZHIHByb3AgaXMgc3VwcGxpZWQgd2l0aCBiYWQgY2FzaW5nLCBpdCB3aWxsXG4gICAgICAgICAgICAgIC8vIGJlIHN1Y2Nlc3NmdWxseSBwYXJzZWQgZnJvbSBIVE1MLCBidXQgd2lsbCBwcm9kdWNlIGEgbWlzbWF0Y2hcbiAgICAgICAgICAgICAgLy8gKGFuZCB3b3VsZCBiZSBpbmNvcnJlY3RseSByZW5kZXJlZCBvbiB0aGUgY2xpZW50KS5cbiAgICAgICAgICAgICAgLy8gSG93ZXZlciwgd2UgYWxyZWFkeSB3YXJuIGFib3V0IGJhZCBjYXNpbmcgZWxzZXdoZXJlLlxuICAgICAgICAgICAgICAvLyBTbyB3ZSdsbCBza2lwIHRoZSBtaXNsZWFkaW5nIGV4dHJhIG1pc21hdGNoIHdhcm5pbmcgaW4gdGhpcyBjYXNlLlxuICAgICAgICAgICAgICBpc01pc21hdGNoRHVlVG9CYWRDYXNpbmcgPSB0cnVlOyAvLyAkRmxvd0ZpeE1lIC0gU2hvdWxkIGJlIGluZmVycmVkIGFzIG5vdCB1bmRlZmluZWQuXG5cbiAgICAgICAgICAgICAgZXh0cmFBdHRyaWJ1dGVOYW1lcy5kZWxldGUoc3RhbmRhcmROYW1lKTtcbiAgICAgICAgICAgIH0gLy8gJEZsb3dGaXhNZSAtIFNob3VsZCBiZSBpbmZlcnJlZCBhcyBub3QgdW5kZWZpbmVkLlxuXG5cbiAgICAgICAgICAgIGV4dHJhQXR0cmlidXRlTmFtZXMuZGVsZXRlKHByb3BLZXkpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHNlcnZlclZhbHVlID0gZ2V0VmFsdWVGb3JBdHRyaWJ1dGUoZG9tRWxlbWVudCwgcHJvcEtleSwgbmV4dFByb3ApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG5leHRQcm9wICE9PSBzZXJ2ZXJWYWx1ZSAmJiAhaXNNaXNtYXRjaER1ZVRvQmFkQ2FzaW5nKSB7XG4gICAgICAgICAgd2FybkZvclByb3BEaWZmZXJlbmNlKHByb3BLZXksIHNlcnZlclZhbHVlLCBuZXh0UHJvcCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB7XG4gICAgLy8gJEZsb3dGaXhNZSAtIFNob3VsZCBiZSBpbmZlcnJlZCBhcyBub3QgdW5kZWZpbmVkLlxuICAgIGlmIChleHRyYUF0dHJpYnV0ZU5hbWVzLnNpemUgPiAwICYmICFzdXBwcmVzc0h5ZHJhdGlvbldhcm5pbmcpIHtcbiAgICAgIC8vICRGbG93Rml4TWUgLSBTaG91bGQgYmUgaW5mZXJyZWQgYXMgbm90IHVuZGVmaW5lZC5cbiAgICAgIHdhcm5Gb3JFeHRyYUF0dHJpYnV0ZXMoZXh0cmFBdHRyaWJ1dGVOYW1lcyk7XG4gICAgfVxuICB9XG5cbiAgc3dpdGNoICh0YWcpIHtcbiAgICBjYXNlICdpbnB1dCc6XG4gICAgICAvLyBUT0RPOiBNYWtlIHN1cmUgd2UgY2hlY2sgaWYgdGhpcyBpcyBzdGlsbCB1bm1vdW50ZWQgb3IgZG8gYW55IGNsZWFuXG4gICAgICAvLyB1cCBuZWNlc3Nhcnkgc2luY2Ugd2UgbmV2ZXIgc3RvcCB0cmFja2luZyBhbnltb3JlLlxuICAgICAgdHJhY2soZG9tRWxlbWVudCk7XG4gICAgICBwb3N0TW91bnRXcmFwcGVyKGRvbUVsZW1lbnQsIHJhd1Byb3BzLCB0cnVlKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAndGV4dGFyZWEnOlxuICAgICAgLy8gVE9ETzogTWFrZSBzdXJlIHdlIGNoZWNrIGlmIHRoaXMgaXMgc3RpbGwgdW5tb3VudGVkIG9yIGRvIGFueSBjbGVhblxuICAgICAgLy8gdXAgbmVjZXNzYXJ5IHNpbmNlIHdlIG5ldmVyIHN0b3AgdHJhY2tpbmcgYW55bW9yZS5cbiAgICAgIHRyYWNrKGRvbUVsZW1lbnQpO1xuICAgICAgcG9zdE1vdW50V3JhcHBlciQzKGRvbUVsZW1lbnQpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdzZWxlY3QnOlxuICAgIGNhc2UgJ29wdGlvbic6XG4gICAgICAvLyBGb3IgaW5wdXQgYW5kIHRleHRhcmVhIHdlIGN1cnJlbnQgYWx3YXlzIHNldCB0aGUgdmFsdWUgcHJvcGVydHkgYXRcbiAgICAgIC8vIHBvc3QgbW91bnQgdG8gZm9yY2UgaXQgdG8gZGl2ZXJnZSBmcm9tIGF0dHJpYnV0ZXMuIEhvd2V2ZXIsIGZvclxuICAgICAgLy8gb3B0aW9uIGFuZCBzZWxlY3Qgd2UgZG9uJ3QgcXVpdGUgZG8gdGhlIHNhbWUgdGhpbmcgYW5kIHNlbGVjdFxuICAgICAgLy8gaXMgbm90IHJlc2lsaWVudCB0byB0aGUgRE9NIHN0YXRlIGNoYW5naW5nIHNvIHdlIGRvbid0IGRvIHRoYXQgaGVyZS5cbiAgICAgIC8vIFRPRE86IENvbnNpZGVyIG5vdCBkb2luZyB0aGlzIGZvciBpbnB1dCBhbmQgdGV4dGFyZWEuXG4gICAgICBicmVhaztcblxuICAgIGRlZmF1bHQ6XG4gICAgICBpZiAodHlwZW9mIHJhd1Byb3BzLm9uQ2xpY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gVE9ETzogVGhpcyBjYXN0IG1heSBub3QgYmUgc291bmQgZm9yIFNWRywgTWF0aE1MIG9yIGN1c3RvbSBlbGVtZW50cy5cbiAgICAgICAgdHJhcENsaWNrT25Ob25JbnRlcmFjdGl2ZUVsZW1lbnQoZG9tRWxlbWVudCk7XG4gICAgICB9XG5cbiAgICAgIGJyZWFrO1xuICB9XG5cbiAgcmV0dXJuIHVwZGF0ZVBheWxvYWQ7XG59XG5mdW5jdGlvbiBkaWZmSHlkcmF0ZWRUZXh0KHRleHROb2RlLCB0ZXh0KSB7XG4gIHZhciBpc0RpZmZlcmVudCA9IHRleHROb2RlLm5vZGVWYWx1ZSAhPT0gdGV4dDtcbiAgcmV0dXJuIGlzRGlmZmVyZW50O1xufVxuZnVuY3Rpb24gd2FybkZvclVubWF0Y2hlZFRleHQodGV4dE5vZGUsIHRleHQpIHtcbiAge1xuICAgIHdhcm5Gb3JUZXh0RGlmZmVyZW5jZSh0ZXh0Tm9kZS5ub2RlVmFsdWUsIHRleHQpO1xuICB9XG59XG5mdW5jdGlvbiB3YXJuRm9yRGVsZXRlZEh5ZHJhdGFibGVFbGVtZW50KHBhcmVudE5vZGUsIGNoaWxkKSB7XG4gIHtcbiAgICBpZiAoZGlkV2FybkludmFsaWRIeWRyYXRpb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBkaWRXYXJuSW52YWxpZEh5ZHJhdGlvbiA9IHRydWU7XG5cbiAgICBlcnJvcignRGlkIG5vdCBleHBlY3Qgc2VydmVyIEhUTUwgdG8gY29udGFpbiBhIDwlcz4gaW4gPCVzPi4nLCBjaGlsZC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpLCBwYXJlbnROb2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkpO1xuICB9XG59XG5mdW5jdGlvbiB3YXJuRm9yRGVsZXRlZEh5ZHJhdGFibGVUZXh0KHBhcmVudE5vZGUsIGNoaWxkKSB7XG4gIHtcbiAgICBpZiAoZGlkV2FybkludmFsaWRIeWRyYXRpb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBkaWRXYXJuSW52YWxpZEh5ZHJhdGlvbiA9IHRydWU7XG5cbiAgICBlcnJvcignRGlkIG5vdCBleHBlY3Qgc2VydmVyIEhUTUwgdG8gY29udGFpbiB0aGUgdGV4dCBub2RlIFwiJXNcIiBpbiA8JXM+LicsIGNoaWxkLm5vZGVWYWx1ZSwgcGFyZW50Tm9kZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpKTtcbiAgfVxufVxuZnVuY3Rpb24gd2FybkZvckluc2VydGVkSHlkcmF0ZWRFbGVtZW50KHBhcmVudE5vZGUsIHRhZywgcHJvcHMpIHtcbiAge1xuICAgIGlmIChkaWRXYXJuSW52YWxpZEh5ZHJhdGlvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGRpZFdhcm5JbnZhbGlkSHlkcmF0aW9uID0gdHJ1ZTtcblxuICAgIGVycm9yKCdFeHBlY3RlZCBzZXJ2ZXIgSFRNTCB0byBjb250YWluIGEgbWF0Y2hpbmcgPCVzPiBpbiA8JXM+LicsIHRhZywgcGFyZW50Tm9kZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpKTtcbiAgfVxufVxuZnVuY3Rpb24gd2FybkZvckluc2VydGVkSHlkcmF0ZWRUZXh0KHBhcmVudE5vZGUsIHRleHQpIHtcbiAge1xuICAgIGlmICh0ZXh0ID09PSAnJykge1xuICAgICAgLy8gV2UgZXhwZWN0IHRvIGluc2VydCBlbXB0eSB0ZXh0IG5vZGVzIHNpbmNlIHRoZXkncmUgbm90IHJlcHJlc2VudGVkIGluXG4gICAgICAvLyB0aGUgSFRNTC5cbiAgICAgIC8vIFRPRE86IFJlbW92ZSB0aGlzIHNwZWNpYWwgY2FzZSBpZiB3ZSBjYW4ganVzdCBhdm9pZCBpbnNlcnRpbmcgZW1wdHlcbiAgICAgIC8vIHRleHQgbm9kZXMuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGRpZFdhcm5JbnZhbGlkSHlkcmF0aW9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZGlkV2FybkludmFsaWRIeWRyYXRpb24gPSB0cnVlO1xuXG4gICAgZXJyb3IoJ0V4cGVjdGVkIHNlcnZlciBIVE1MIHRvIGNvbnRhaW4gYSBtYXRjaGluZyB0ZXh0IG5vZGUgZm9yIFwiJXNcIiBpbiA8JXM+LicsIHRleHQsIHBhcmVudE5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSk7XG4gIH1cbn1cbmZ1bmN0aW9uIHJlc3RvcmVDb250cm9sbGVkU3RhdGUkMyhkb21FbGVtZW50LCB0YWcsIHByb3BzKSB7XG4gIHN3aXRjaCAodGFnKSB7XG4gICAgY2FzZSAnaW5wdXQnOlxuICAgICAgcmVzdG9yZUNvbnRyb2xsZWRTdGF0ZShkb21FbGVtZW50LCBwcm9wcyk7XG4gICAgICByZXR1cm47XG5cbiAgICBjYXNlICd0ZXh0YXJlYSc6XG4gICAgICByZXN0b3JlQ29udHJvbGxlZFN0YXRlJDIoZG9tRWxlbWVudCwgcHJvcHMpO1xuICAgICAgcmV0dXJuO1xuXG4gICAgY2FzZSAnc2VsZWN0JzpcbiAgICAgIHJlc3RvcmVDb250cm9sbGVkU3RhdGUkMShkb21FbGVtZW50LCBwcm9wcyk7XG4gICAgICByZXR1cm47XG4gIH1cbn1cblxudmFyIHZhbGlkYXRlRE9NTmVzdGluZyA9IGZ1bmN0aW9uICgpIHt9O1xuXG52YXIgdXBkYXRlZEFuY2VzdG9ySW5mbyA9IGZ1bmN0aW9uICgpIHt9O1xuXG57XG4gIC8vIFRoaXMgdmFsaWRhdGlvbiBjb2RlIHdhcyB3cml0dGVuIGJhc2VkIG9uIHRoZSBIVE1MNSBwYXJzaW5nIHNwZWM6XG4gIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI2hhcy1hbi1lbGVtZW50LWluLXNjb3BlXG4gIC8vXG4gIC8vIE5vdGU6IHRoaXMgZG9lcyBub3QgY2F0Y2ggYWxsIGludmFsaWQgbmVzdGluZywgbm9yIGRvZXMgaXQgdHJ5IHRvIChhcyBpdCdzXG4gIC8vIG5vdCBjbGVhciB3aGF0IHByYWN0aWNhbCBiZW5lZml0IGRvaW5nIHNvIHByb3ZpZGVzKTsgaW5zdGVhZCwgd2Ugd2FybiBvbmx5XG4gIC8vIGZvciBjYXNlcyB3aGVyZSB0aGUgcGFyc2VyIHdpbGwgZ2l2ZSBhIHBhcnNlIHRyZWUgZGlmZmVyaW5nIGZyb20gd2hhdCBSZWFjdFxuICAvLyBpbnRlbmRlZC4gRm9yIGV4YW1wbGUsIDxiPjxkaXY+PC9kaXY+PC9iPiBpcyBpbnZhbGlkIGJ1dCB3ZSBkb24ndCB3YXJuXG4gIC8vIGJlY2F1c2UgaXQgc3RpbGwgcGFyc2VzIGNvcnJlY3RseTsgd2UgZG8gd2FybiBmb3Igb3RoZXIgY2FzZXMgbGlrZSBuZXN0ZWRcbiAgLy8gPHA+IHRhZ3Mgd2hlcmUgdGhlIGJlZ2lubmluZyBvZiB0aGUgc2Vjb25kIGVsZW1lbnQgaW1wbGljaXRseSBjbG9zZXMgdGhlXG4gIC8vIGZpcnN0LCBjYXVzaW5nIGEgY29uZnVzaW5nIG1lc3MuXG4gIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI3NwZWNpYWxcbiAgdmFyIHNwZWNpYWxUYWdzID0gWydhZGRyZXNzJywgJ2FwcGxldCcsICdhcmVhJywgJ2FydGljbGUnLCAnYXNpZGUnLCAnYmFzZScsICdiYXNlZm9udCcsICdiZ3NvdW5kJywgJ2Jsb2NrcXVvdGUnLCAnYm9keScsICdicicsICdidXR0b24nLCAnY2FwdGlvbicsICdjZW50ZXInLCAnY29sJywgJ2NvbGdyb3VwJywgJ2RkJywgJ2RldGFpbHMnLCAnZGlyJywgJ2RpdicsICdkbCcsICdkdCcsICdlbWJlZCcsICdmaWVsZHNldCcsICdmaWdjYXB0aW9uJywgJ2ZpZ3VyZScsICdmb290ZXInLCAnZm9ybScsICdmcmFtZScsICdmcmFtZXNldCcsICdoMScsICdoMicsICdoMycsICdoNCcsICdoNScsICdoNicsICdoZWFkJywgJ2hlYWRlcicsICdoZ3JvdXAnLCAnaHInLCAnaHRtbCcsICdpZnJhbWUnLCAnaW1nJywgJ2lucHV0JywgJ2lzaW5kZXgnLCAnbGknLCAnbGluaycsICdsaXN0aW5nJywgJ21haW4nLCAnbWFycXVlZScsICdtZW51JywgJ21lbnVpdGVtJywgJ21ldGEnLCAnbmF2JywgJ25vZW1iZWQnLCAnbm9mcmFtZXMnLCAnbm9zY3JpcHQnLCAnb2JqZWN0JywgJ29sJywgJ3AnLCAncGFyYW0nLCAncGxhaW50ZXh0JywgJ3ByZScsICdzY3JpcHQnLCAnc2VjdGlvbicsICdzZWxlY3QnLCAnc291cmNlJywgJ3N0eWxlJywgJ3N1bW1hcnknLCAndGFibGUnLCAndGJvZHknLCAndGQnLCAndGVtcGxhdGUnLCAndGV4dGFyZWEnLCAndGZvb3QnLCAndGgnLCAndGhlYWQnLCAndGl0bGUnLCAndHInLCAndHJhY2snLCAndWwnLCAnd2JyJywgJ3htcCddOyAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNoYXMtYW4tZWxlbWVudC1pbi1zY29wZVxuXG4gIHZhciBpblNjb3BlVGFncyA9IFsnYXBwbGV0JywgJ2NhcHRpb24nLCAnaHRtbCcsICd0YWJsZScsICd0ZCcsICd0aCcsICdtYXJxdWVlJywgJ29iamVjdCcsICd0ZW1wbGF0ZScsIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI2h0bWwtaW50ZWdyYXRpb24tcG9pbnRcbiAgLy8gVE9ETzogRGlzdGluZ3Vpc2ggYnkgbmFtZXNwYWNlIGhlcmUgLS0gZm9yIDx0aXRsZT4sIGluY2x1ZGluZyBpdCBoZXJlXG4gIC8vIGVycnMgb24gdGhlIHNpZGUgb2YgZmV3ZXIgd2FybmluZ3NcbiAgJ2ZvcmVpZ25PYmplY3QnLCAnZGVzYycsICd0aXRsZSddOyAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNoYXMtYW4tZWxlbWVudC1pbi1idXR0b24tc2NvcGVcblxuICB2YXIgYnV0dG9uU2NvcGVUYWdzID0gaW5TY29wZVRhZ3MuY29uY2F0KFsnYnV0dG9uJ10pOyAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNnZW5lcmF0ZS1pbXBsaWVkLWVuZC10YWdzXG5cbiAgdmFyIGltcGxpZWRFbmRUYWdzID0gWydkZCcsICdkdCcsICdsaScsICdvcHRpb24nLCAnb3B0Z3JvdXAnLCAncCcsICdycCcsICdydCddO1xuICB2YXIgZW1wdHlBbmNlc3RvckluZm8gPSB7XG4gICAgY3VycmVudDogbnVsbCxcbiAgICBmb3JtVGFnOiBudWxsLFxuICAgIGFUYWdJblNjb3BlOiBudWxsLFxuICAgIGJ1dHRvblRhZ0luU2NvcGU6IG51bGwsXG4gICAgbm9iclRhZ0luU2NvcGU6IG51bGwsXG4gICAgcFRhZ0luQnV0dG9uU2NvcGU6IG51bGwsXG4gICAgbGlzdEl0ZW1UYWdBdXRvY2xvc2luZzogbnVsbCxcbiAgICBkbEl0ZW1UYWdBdXRvY2xvc2luZzogbnVsbFxuICB9O1xuXG4gIHVwZGF0ZWRBbmNlc3RvckluZm8gPSBmdW5jdGlvbiAob2xkSW5mbywgdGFnKSB7XG4gICAgdmFyIGFuY2VzdG9ySW5mbyA9IF9hc3NpZ24oe30sIG9sZEluZm8gfHwgZW1wdHlBbmNlc3RvckluZm8pO1xuXG4gICAgdmFyIGluZm8gPSB7XG4gICAgICB0YWc6IHRhZ1xuICAgIH07XG5cbiAgICBpZiAoaW5TY29wZVRhZ3MuaW5kZXhPZih0YWcpICE9PSAtMSkge1xuICAgICAgYW5jZXN0b3JJbmZvLmFUYWdJblNjb3BlID0gbnVsbDtcbiAgICAgIGFuY2VzdG9ySW5mby5idXR0b25UYWdJblNjb3BlID0gbnVsbDtcbiAgICAgIGFuY2VzdG9ySW5mby5ub2JyVGFnSW5TY29wZSA9IG51bGw7XG4gICAgfVxuXG4gICAgaWYgKGJ1dHRvblNjb3BlVGFncy5pbmRleE9mKHRhZykgIT09IC0xKSB7XG4gICAgICBhbmNlc3RvckluZm8ucFRhZ0luQnV0dG9uU2NvcGUgPSBudWxsO1xuICAgIH0gLy8gU2VlIHJ1bGVzIGZvciAnbGknLCAnZGQnLCAnZHQnIHN0YXJ0IHRhZ3MgaW5cbiAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNwYXJzaW5nLW1haW4taW5ib2R5XG5cblxuICAgIGlmIChzcGVjaWFsVGFncy5pbmRleE9mKHRhZykgIT09IC0xICYmIHRhZyAhPT0gJ2FkZHJlc3MnICYmIHRhZyAhPT0gJ2RpdicgJiYgdGFnICE9PSAncCcpIHtcbiAgICAgIGFuY2VzdG9ySW5mby5saXN0SXRlbVRhZ0F1dG9jbG9zaW5nID0gbnVsbDtcbiAgICAgIGFuY2VzdG9ySW5mby5kbEl0ZW1UYWdBdXRvY2xvc2luZyA9IG51bGw7XG4gICAgfVxuXG4gICAgYW5jZXN0b3JJbmZvLmN1cnJlbnQgPSBpbmZvO1xuXG4gICAgaWYgKHRhZyA9PT0gJ2Zvcm0nKSB7XG4gICAgICBhbmNlc3RvckluZm8uZm9ybVRhZyA9IGluZm87XG4gICAgfVxuXG4gICAgaWYgKHRhZyA9PT0gJ2EnKSB7XG4gICAgICBhbmNlc3RvckluZm8uYVRhZ0luU2NvcGUgPSBpbmZvO1xuICAgIH1cblxuICAgIGlmICh0YWcgPT09ICdidXR0b24nKSB7XG4gICAgICBhbmNlc3RvckluZm8uYnV0dG9uVGFnSW5TY29wZSA9IGluZm87XG4gICAgfVxuXG4gICAgaWYgKHRhZyA9PT0gJ25vYnInKSB7XG4gICAgICBhbmNlc3RvckluZm8ubm9iclRhZ0luU2NvcGUgPSBpbmZvO1xuICAgIH1cblxuICAgIGlmICh0YWcgPT09ICdwJykge1xuICAgICAgYW5jZXN0b3JJbmZvLnBUYWdJbkJ1dHRvblNjb3BlID0gaW5mbztcbiAgICB9XG5cbiAgICBpZiAodGFnID09PSAnbGknKSB7XG4gICAgICBhbmNlc3RvckluZm8ubGlzdEl0ZW1UYWdBdXRvY2xvc2luZyA9IGluZm87XG4gICAgfVxuXG4gICAgaWYgKHRhZyA9PT0gJ2RkJyB8fCB0YWcgPT09ICdkdCcpIHtcbiAgICAgIGFuY2VzdG9ySW5mby5kbEl0ZW1UYWdBdXRvY2xvc2luZyA9IGluZm87XG4gICAgfVxuXG4gICAgcmV0dXJuIGFuY2VzdG9ySW5mbztcbiAgfTtcbiAgLyoqXG4gICAqIFJldHVybnMgd2hldGhlclxuICAgKi9cblxuXG4gIHZhciBpc1RhZ1ZhbGlkV2l0aFBhcmVudCA9IGZ1bmN0aW9uICh0YWcsIHBhcmVudFRhZykge1xuICAgIC8vIEZpcnN0LCBsZXQncyBjaGVjayBpZiB3ZSdyZSBpbiBhbiB1bnVzdWFsIHBhcnNpbmcgbW9kZS4uLlxuICAgIHN3aXRjaCAocGFyZW50VGFnKSB7XG4gICAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNwYXJzaW5nLW1haW4taW5zZWxlY3RcbiAgICAgIGNhc2UgJ3NlbGVjdCc6XG4gICAgICAgIHJldHVybiB0YWcgPT09ICdvcHRpb24nIHx8IHRhZyA9PT0gJ29wdGdyb3VwJyB8fCB0YWcgPT09ICcjdGV4dCc7XG5cbiAgICAgIGNhc2UgJ29wdGdyb3VwJzpcbiAgICAgICAgcmV0dXJuIHRhZyA9PT0gJ29wdGlvbicgfHwgdGFnID09PSAnI3RleHQnO1xuICAgICAgLy8gU3RyaWN0bHkgc3BlYWtpbmcsIHNlZWluZyBhbiA8b3B0aW9uPiBkb2Vzbid0IG1lYW4gd2UncmUgaW4gYSA8c2VsZWN0PlxuICAgICAgLy8gYnV0XG5cbiAgICAgIGNhc2UgJ29wdGlvbic6XG4gICAgICAgIHJldHVybiB0YWcgPT09ICcjdGV4dCc7XG4gICAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNwYXJzaW5nLW1haW4taW50ZFxuICAgICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjcGFyc2luZy1tYWluLWluY2FwdGlvblxuICAgICAgLy8gTm8gc3BlY2lhbCBiZWhhdmlvciBzaW5jZSB0aGVzZSBydWxlcyBmYWxsIGJhY2sgdG8gXCJpbiBib2R5XCIgbW9kZSBmb3JcbiAgICAgIC8vIGFsbCBleGNlcHQgc3BlY2lhbCB0YWJsZSBub2RlcyB3aGljaCBjYXVzZSBiYWQgcGFyc2luZyBiZWhhdmlvciBhbnl3YXkuXG4gICAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNwYXJzaW5nLW1haW4taW50clxuXG4gICAgICBjYXNlICd0cic6XG4gICAgICAgIHJldHVybiB0YWcgPT09ICd0aCcgfHwgdGFnID09PSAndGQnIHx8IHRhZyA9PT0gJ3N0eWxlJyB8fCB0YWcgPT09ICdzY3JpcHQnIHx8IHRhZyA9PT0gJ3RlbXBsYXRlJztcbiAgICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI3BhcnNpbmctbWFpbi1pbnRib2R5XG5cbiAgICAgIGNhc2UgJ3Rib2R5JzpcbiAgICAgIGNhc2UgJ3RoZWFkJzpcbiAgICAgIGNhc2UgJ3Rmb290JzpcbiAgICAgICAgcmV0dXJuIHRhZyA9PT0gJ3RyJyB8fCB0YWcgPT09ICdzdHlsZScgfHwgdGFnID09PSAnc2NyaXB0JyB8fCB0YWcgPT09ICd0ZW1wbGF0ZSc7XG4gICAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNwYXJzaW5nLW1haW4taW5jb2xncm91cFxuXG4gICAgICBjYXNlICdjb2xncm91cCc6XG4gICAgICAgIHJldHVybiB0YWcgPT09ICdjb2wnIHx8IHRhZyA9PT0gJ3RlbXBsYXRlJztcbiAgICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI3BhcnNpbmctbWFpbi1pbnRhYmxlXG5cbiAgICAgIGNhc2UgJ3RhYmxlJzpcbiAgICAgICAgcmV0dXJuIHRhZyA9PT0gJ2NhcHRpb24nIHx8IHRhZyA9PT0gJ2NvbGdyb3VwJyB8fCB0YWcgPT09ICd0Ym9keScgfHwgdGFnID09PSAndGZvb3QnIHx8IHRhZyA9PT0gJ3RoZWFkJyB8fCB0YWcgPT09ICdzdHlsZScgfHwgdGFnID09PSAnc2NyaXB0JyB8fCB0YWcgPT09ICd0ZW1wbGF0ZSc7XG4gICAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNwYXJzaW5nLW1haW4taW5oZWFkXG5cbiAgICAgIGNhc2UgJ2hlYWQnOlxuICAgICAgICByZXR1cm4gdGFnID09PSAnYmFzZScgfHwgdGFnID09PSAnYmFzZWZvbnQnIHx8IHRhZyA9PT0gJ2Jnc291bmQnIHx8IHRhZyA9PT0gJ2xpbmsnIHx8IHRhZyA9PT0gJ21ldGEnIHx8IHRhZyA9PT0gJ3RpdGxlJyB8fCB0YWcgPT09ICdub3NjcmlwdCcgfHwgdGFnID09PSAnbm9mcmFtZXMnIHx8IHRhZyA9PT0gJ3N0eWxlJyB8fCB0YWcgPT09ICdzY3JpcHQnIHx8IHRhZyA9PT0gJ3RlbXBsYXRlJztcbiAgICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3NlbWFudGljcy5odG1sI3RoZS1odG1sLWVsZW1lbnRcblxuICAgICAgY2FzZSAnaHRtbCc6XG4gICAgICAgIHJldHVybiB0YWcgPT09ICdoZWFkJyB8fCB0YWcgPT09ICdib2R5JyB8fCB0YWcgPT09ICdmcmFtZXNldCc7XG5cbiAgICAgIGNhc2UgJ2ZyYW1lc2V0JzpcbiAgICAgICAgcmV0dXJuIHRhZyA9PT0gJ2ZyYW1lJztcblxuICAgICAgY2FzZSAnI2RvY3VtZW50JzpcbiAgICAgICAgcmV0dXJuIHRhZyA9PT0gJ2h0bWwnO1xuICAgIH0gLy8gUHJvYmFibHkgaW4gdGhlIFwiaW4gYm9keVwiIHBhcnNpbmcgbW9kZSwgc28gd2Ugb3V0bGF3IG9ubHkgdGFnIGNvbWJvc1xuICAgIC8vIHdoZXJlIHRoZSBwYXJzaW5nIHJ1bGVzIGNhdXNlIGltcGxpY2l0IG9wZW5zIG9yIGNsb3NlcyB0byBiZSBhZGRlZC5cbiAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNwYXJzaW5nLW1haW4taW5ib2R5XG5cblxuICAgIHN3aXRjaCAodGFnKSB7XG4gICAgICBjYXNlICdoMSc6XG4gICAgICBjYXNlICdoMic6XG4gICAgICBjYXNlICdoMyc6XG4gICAgICBjYXNlICdoNCc6XG4gICAgICBjYXNlICdoNSc6XG4gICAgICBjYXNlICdoNic6XG4gICAgICAgIHJldHVybiBwYXJlbnRUYWcgIT09ICdoMScgJiYgcGFyZW50VGFnICE9PSAnaDInICYmIHBhcmVudFRhZyAhPT0gJ2gzJyAmJiBwYXJlbnRUYWcgIT09ICdoNCcgJiYgcGFyZW50VGFnICE9PSAnaDUnICYmIHBhcmVudFRhZyAhPT0gJ2g2JztcblxuICAgICAgY2FzZSAncnAnOlxuICAgICAgY2FzZSAncnQnOlxuICAgICAgICByZXR1cm4gaW1wbGllZEVuZFRhZ3MuaW5kZXhPZihwYXJlbnRUYWcpID09PSAtMTtcblxuICAgICAgY2FzZSAnYm9keSc6XG4gICAgICBjYXNlICdjYXB0aW9uJzpcbiAgICAgIGNhc2UgJ2NvbCc6XG4gICAgICBjYXNlICdjb2xncm91cCc6XG4gICAgICBjYXNlICdmcmFtZXNldCc6XG4gICAgICBjYXNlICdmcmFtZSc6XG4gICAgICBjYXNlICdoZWFkJzpcbiAgICAgIGNhc2UgJ2h0bWwnOlxuICAgICAgY2FzZSAndGJvZHknOlxuICAgICAgY2FzZSAndGQnOlxuICAgICAgY2FzZSAndGZvb3QnOlxuICAgICAgY2FzZSAndGgnOlxuICAgICAgY2FzZSAndGhlYWQnOlxuICAgICAgY2FzZSAndHInOlxuICAgICAgICAvLyBUaGVzZSB0YWdzIGFyZSBvbmx5IHZhbGlkIHdpdGggYSBmZXcgcGFyZW50cyB0aGF0IGhhdmUgc3BlY2lhbCBjaGlsZFxuICAgICAgICAvLyBwYXJzaW5nIHJ1bGVzIC0tIGlmIHdlJ3JlIGRvd24gaGVyZSwgdGhlbiBub25lIG9mIHRob3NlIG1hdGNoZWQgYW5kXG4gICAgICAgIC8vIHNvIHdlIGFsbG93IGl0IG9ubHkgaWYgd2UgZG9uJ3Qga25vdyB3aGF0IHRoZSBwYXJlbnQgaXMsIGFzIGFsbCBvdGhlclxuICAgICAgICAvLyBjYXNlcyBhcmUgaW52YWxpZC5cbiAgICAgICAgcmV0dXJuIHBhcmVudFRhZyA9PSBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9O1xuICAvKipcbiAgICogUmV0dXJucyB3aGV0aGVyXG4gICAqL1xuXG5cbiAgdmFyIGZpbmRJbnZhbGlkQW5jZXN0b3JGb3JUYWcgPSBmdW5jdGlvbiAodGFnLCBhbmNlc3RvckluZm8pIHtcbiAgICBzd2l0Y2ggKHRhZykge1xuICAgICAgY2FzZSAnYWRkcmVzcyc6XG4gICAgICBjYXNlICdhcnRpY2xlJzpcbiAgICAgIGNhc2UgJ2FzaWRlJzpcbiAgICAgIGNhc2UgJ2Jsb2NrcXVvdGUnOlxuICAgICAgY2FzZSAnY2VudGVyJzpcbiAgICAgIGNhc2UgJ2RldGFpbHMnOlxuICAgICAgY2FzZSAnZGlhbG9nJzpcbiAgICAgIGNhc2UgJ2Rpcic6XG4gICAgICBjYXNlICdkaXYnOlxuICAgICAgY2FzZSAnZGwnOlxuICAgICAgY2FzZSAnZmllbGRzZXQnOlxuICAgICAgY2FzZSAnZmlnY2FwdGlvbic6XG4gICAgICBjYXNlICdmaWd1cmUnOlxuICAgICAgY2FzZSAnZm9vdGVyJzpcbiAgICAgIGNhc2UgJ2hlYWRlcic6XG4gICAgICBjYXNlICdoZ3JvdXAnOlxuICAgICAgY2FzZSAnbWFpbic6XG4gICAgICBjYXNlICdtZW51JzpcbiAgICAgIGNhc2UgJ25hdic6XG4gICAgICBjYXNlICdvbCc6XG4gICAgICBjYXNlICdwJzpcbiAgICAgIGNhc2UgJ3NlY3Rpb24nOlxuICAgICAgY2FzZSAnc3VtbWFyeSc6XG4gICAgICBjYXNlICd1bCc6XG4gICAgICBjYXNlICdwcmUnOlxuICAgICAgY2FzZSAnbGlzdGluZyc6XG4gICAgICBjYXNlICd0YWJsZSc6XG4gICAgICBjYXNlICdocic6XG4gICAgICBjYXNlICd4bXAnOlxuICAgICAgY2FzZSAnaDEnOlxuICAgICAgY2FzZSAnaDInOlxuICAgICAgY2FzZSAnaDMnOlxuICAgICAgY2FzZSAnaDQnOlxuICAgICAgY2FzZSAnaDUnOlxuICAgICAgY2FzZSAnaDYnOlxuICAgICAgICByZXR1cm4gYW5jZXN0b3JJbmZvLnBUYWdJbkJ1dHRvblNjb3BlO1xuXG4gICAgICBjYXNlICdmb3JtJzpcbiAgICAgICAgcmV0dXJuIGFuY2VzdG9ySW5mby5mb3JtVGFnIHx8IGFuY2VzdG9ySW5mby5wVGFnSW5CdXR0b25TY29wZTtcblxuICAgICAgY2FzZSAnbGknOlxuICAgICAgICByZXR1cm4gYW5jZXN0b3JJbmZvLmxpc3RJdGVtVGFnQXV0b2Nsb3Npbmc7XG5cbiAgICAgIGNhc2UgJ2RkJzpcbiAgICAgIGNhc2UgJ2R0JzpcbiAgICAgICAgcmV0dXJuIGFuY2VzdG9ySW5mby5kbEl0ZW1UYWdBdXRvY2xvc2luZztcblxuICAgICAgY2FzZSAnYnV0dG9uJzpcbiAgICAgICAgcmV0dXJuIGFuY2VzdG9ySW5mby5idXR0b25UYWdJblNjb3BlO1xuXG4gICAgICBjYXNlICdhJzpcbiAgICAgICAgLy8gU3BlYyBzYXlzIHNvbWV0aGluZyBhYm91dCBzdG9yaW5nIGEgbGlzdCBvZiBtYXJrZXJzLCBidXQgaXQgc291bmRzXG4gICAgICAgIC8vIGVxdWl2YWxlbnQgdG8gdGhpcyBjaGVjay5cbiAgICAgICAgcmV0dXJuIGFuY2VzdG9ySW5mby5hVGFnSW5TY29wZTtcblxuICAgICAgY2FzZSAnbm9icic6XG4gICAgICAgIHJldHVybiBhbmNlc3RvckluZm8ubm9iclRhZ0luU2NvcGU7XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH07XG5cbiAgdmFyIGRpZFdhcm4kMSA9IHt9O1xuXG4gIHZhbGlkYXRlRE9NTmVzdGluZyA9IGZ1bmN0aW9uIChjaGlsZFRhZywgY2hpbGRUZXh0LCBhbmNlc3RvckluZm8pIHtcbiAgICBhbmNlc3RvckluZm8gPSBhbmNlc3RvckluZm8gfHwgZW1wdHlBbmNlc3RvckluZm87XG4gICAgdmFyIHBhcmVudEluZm8gPSBhbmNlc3RvckluZm8uY3VycmVudDtcbiAgICB2YXIgcGFyZW50VGFnID0gcGFyZW50SW5mbyAmJiBwYXJlbnRJbmZvLnRhZztcblxuICAgIGlmIChjaGlsZFRleHQgIT0gbnVsbCkge1xuICAgICAgaWYgKGNoaWxkVGFnICE9IG51bGwpIHtcbiAgICAgICAgZXJyb3IoJ3ZhbGlkYXRlRE9NTmVzdGluZzogd2hlbiBjaGlsZFRleHQgaXMgcGFzc2VkLCBjaGlsZFRhZyBzaG91bGQgYmUgbnVsbCcpO1xuICAgICAgfVxuXG4gICAgICBjaGlsZFRhZyA9ICcjdGV4dCc7XG4gICAgfVxuXG4gICAgdmFyIGludmFsaWRQYXJlbnQgPSBpc1RhZ1ZhbGlkV2l0aFBhcmVudChjaGlsZFRhZywgcGFyZW50VGFnKSA/IG51bGwgOiBwYXJlbnRJbmZvO1xuICAgIHZhciBpbnZhbGlkQW5jZXN0b3IgPSBpbnZhbGlkUGFyZW50ID8gbnVsbCA6IGZpbmRJbnZhbGlkQW5jZXN0b3JGb3JUYWcoY2hpbGRUYWcsIGFuY2VzdG9ySW5mbyk7XG4gICAgdmFyIGludmFsaWRQYXJlbnRPckFuY2VzdG9yID0gaW52YWxpZFBhcmVudCB8fCBpbnZhbGlkQW5jZXN0b3I7XG5cbiAgICBpZiAoIWludmFsaWRQYXJlbnRPckFuY2VzdG9yKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGFuY2VzdG9yVGFnID0gaW52YWxpZFBhcmVudE9yQW5jZXN0b3IudGFnO1xuICAgIHZhciB3YXJuS2V5ID0gISFpbnZhbGlkUGFyZW50ICsgJ3wnICsgY2hpbGRUYWcgKyAnfCcgKyBhbmNlc3RvclRhZztcblxuICAgIGlmIChkaWRXYXJuJDFbd2FybktleV0pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBkaWRXYXJuJDFbd2FybktleV0gPSB0cnVlO1xuICAgIHZhciB0YWdEaXNwbGF5TmFtZSA9IGNoaWxkVGFnO1xuICAgIHZhciB3aGl0ZXNwYWNlSW5mbyA9ICcnO1xuXG4gICAgaWYgKGNoaWxkVGFnID09PSAnI3RleHQnKSB7XG4gICAgICBpZiAoL1xcUy8udGVzdChjaGlsZFRleHQpKSB7XG4gICAgICAgIHRhZ0Rpc3BsYXlOYW1lID0gJ1RleHQgbm9kZXMnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGFnRGlzcGxheU5hbWUgPSAnV2hpdGVzcGFjZSB0ZXh0IG5vZGVzJztcbiAgICAgICAgd2hpdGVzcGFjZUluZm8gPSBcIiBNYWtlIHN1cmUgeW91IGRvbid0IGhhdmUgYW55IGV4dHJhIHdoaXRlc3BhY2UgYmV0d2VlbiB0YWdzIG9uIFwiICsgJ2VhY2ggbGluZSBvZiB5b3VyIHNvdXJjZSBjb2RlLic7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRhZ0Rpc3BsYXlOYW1lID0gJzwnICsgY2hpbGRUYWcgKyAnPic7XG4gICAgfVxuXG4gICAgaWYgKGludmFsaWRQYXJlbnQpIHtcbiAgICAgIHZhciBpbmZvID0gJyc7XG5cbiAgICAgIGlmIChhbmNlc3RvclRhZyA9PT0gJ3RhYmxlJyAmJiBjaGlsZFRhZyA9PT0gJ3RyJykge1xuICAgICAgICBpbmZvICs9ICcgQWRkIGEgPHRib2R5PiwgPHRoZWFkPiBvciA8dGZvb3Q+IHRvIHlvdXIgY29kZSB0byBtYXRjaCB0aGUgRE9NIHRyZWUgZ2VuZXJhdGVkIGJ5ICcgKyAndGhlIGJyb3dzZXIuJztcbiAgICAgIH1cblxuICAgICAgZXJyb3IoJ3ZhbGlkYXRlRE9NTmVzdGluZyguLi4pOiAlcyBjYW5ub3QgYXBwZWFyIGFzIGEgY2hpbGQgb2YgPCVzPi4lcyVzJywgdGFnRGlzcGxheU5hbWUsIGFuY2VzdG9yVGFnLCB3aGl0ZXNwYWNlSW5mbywgaW5mbyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVycm9yKCd2YWxpZGF0ZURPTU5lc3RpbmcoLi4uKTogJXMgY2Fubm90IGFwcGVhciBhcyBhIGRlc2NlbmRhbnQgb2YgJyArICc8JXM+LicsIHRhZ0Rpc3BsYXlOYW1lLCBhbmNlc3RvclRhZyk7XG4gICAgfVxuICB9O1xufVxuXG52YXIgU1VQUFJFU1NfSFlEUkFUSU9OX1dBUk5JTkckMTtcblxue1xuICBTVVBQUkVTU19IWURSQVRJT05fV0FSTklORyQxID0gJ3N1cHByZXNzSHlkcmF0aW9uV2FybmluZyc7XG59XG5cbnZhciBTVVNQRU5TRV9TVEFSVF9EQVRBID0gJyQnO1xudmFyIFNVU1BFTlNFX0VORF9EQVRBID0gJy8kJztcbnZhciBTVVNQRU5TRV9QRU5ESU5HX1NUQVJUX0RBVEEgPSAnJD8nO1xudmFyIFNVU1BFTlNFX0ZBTExCQUNLX1NUQVJUX0RBVEEgPSAnJCEnO1xudmFyIFNUWUxFJDEgPSAnc3R5bGUnO1xudmFyIGV2ZW50c0VuYWJsZWQgPSBudWxsO1xudmFyIHNlbGVjdGlvbkluZm9ybWF0aW9uID0gbnVsbDtcblxuZnVuY3Rpb24gc2hvdWxkQXV0b0ZvY3VzSG9zdENvbXBvbmVudCh0eXBlLCBwcm9wcykge1xuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlICdidXR0b24nOlxuICAgIGNhc2UgJ2lucHV0JzpcbiAgICBjYXNlICdzZWxlY3QnOlxuICAgIGNhc2UgJ3RleHRhcmVhJzpcbiAgICAgIHJldHVybiAhIXByb3BzLmF1dG9Gb2N1cztcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGdldFJvb3RIb3N0Q29udGV4dChyb290Q29udGFpbmVySW5zdGFuY2UpIHtcbiAgdmFyIHR5cGU7XG4gIHZhciBuYW1lc3BhY2U7XG4gIHZhciBub2RlVHlwZSA9IHJvb3RDb250YWluZXJJbnN0YW5jZS5ub2RlVHlwZTtcblxuICBzd2l0Y2ggKG5vZGVUeXBlKSB7XG4gICAgY2FzZSBET0NVTUVOVF9OT0RFOlxuICAgIGNhc2UgRE9DVU1FTlRfRlJBR01FTlRfTk9ERTpcbiAgICAgIHtcbiAgICAgICAgdHlwZSA9IG5vZGVUeXBlID09PSBET0NVTUVOVF9OT0RFID8gJyNkb2N1bWVudCcgOiAnI2ZyYWdtZW50JztcbiAgICAgICAgdmFyIHJvb3QgPSByb290Q29udGFpbmVySW5zdGFuY2UuZG9jdW1lbnRFbGVtZW50O1xuICAgICAgICBuYW1lc3BhY2UgPSByb290ID8gcm9vdC5uYW1lc3BhY2VVUkkgOiBnZXRDaGlsZE5hbWVzcGFjZShudWxsLCAnJyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgZGVmYXVsdDpcbiAgICAgIHtcbiAgICAgICAgdmFyIGNvbnRhaW5lciA9IG5vZGVUeXBlID09PSBDT01NRU5UX05PREUgPyByb290Q29udGFpbmVySW5zdGFuY2UucGFyZW50Tm9kZSA6IHJvb3RDb250YWluZXJJbnN0YW5jZTtcbiAgICAgICAgdmFyIG93bk5hbWVzcGFjZSA9IGNvbnRhaW5lci5uYW1lc3BhY2VVUkkgfHwgbnVsbDtcbiAgICAgICAgdHlwZSA9IGNvbnRhaW5lci50YWdOYW1lO1xuICAgICAgICBuYW1lc3BhY2UgPSBnZXRDaGlsZE5hbWVzcGFjZShvd25OYW1lc3BhY2UsIHR5cGUpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgfVxuXG4gIHtcbiAgICB2YXIgdmFsaWRhdGVkVGFnID0gdHlwZS50b0xvd2VyQ2FzZSgpO1xuICAgIHZhciBhbmNlc3RvckluZm8gPSB1cGRhdGVkQW5jZXN0b3JJbmZvKG51bGwsIHZhbGlkYXRlZFRhZyk7XG4gICAgcmV0dXJuIHtcbiAgICAgIG5hbWVzcGFjZTogbmFtZXNwYWNlLFxuICAgICAgYW5jZXN0b3JJbmZvOiBhbmNlc3RvckluZm9cbiAgICB9O1xuICB9XG59XG5mdW5jdGlvbiBnZXRDaGlsZEhvc3RDb250ZXh0KHBhcmVudEhvc3RDb250ZXh0LCB0eXBlLCByb290Q29udGFpbmVySW5zdGFuY2UpIHtcbiAge1xuICAgIHZhciBwYXJlbnRIb3N0Q29udGV4dERldiA9IHBhcmVudEhvc3RDb250ZXh0O1xuICAgIHZhciBuYW1lc3BhY2UgPSBnZXRDaGlsZE5hbWVzcGFjZShwYXJlbnRIb3N0Q29udGV4dERldi5uYW1lc3BhY2UsIHR5cGUpO1xuICAgIHZhciBhbmNlc3RvckluZm8gPSB1cGRhdGVkQW5jZXN0b3JJbmZvKHBhcmVudEhvc3RDb250ZXh0RGV2LmFuY2VzdG9ySW5mbywgdHlwZSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIG5hbWVzcGFjZTogbmFtZXNwYWNlLFxuICAgICAgYW5jZXN0b3JJbmZvOiBhbmNlc3RvckluZm9cbiAgICB9O1xuICB9XG59XG5mdW5jdGlvbiBnZXRQdWJsaWNJbnN0YW5jZShpbnN0YW5jZSkge1xuICByZXR1cm4gaW5zdGFuY2U7XG59XG5mdW5jdGlvbiBwcmVwYXJlRm9yQ29tbWl0KGNvbnRhaW5lckluZm8pIHtcbiAgZXZlbnRzRW5hYmxlZCA9IGlzRW5hYmxlZCgpO1xuICBzZWxlY3Rpb25JbmZvcm1hdGlvbiA9IGdldFNlbGVjdGlvbkluZm9ybWF0aW9uKCk7XG4gIHZhciBhY3RpdmVJbnN0YW5jZSA9IG51bGw7XG5cbiAgc2V0RW5hYmxlZChmYWxzZSk7XG4gIHJldHVybiBhY3RpdmVJbnN0YW5jZTtcbn1cbmZ1bmN0aW9uIHJlc2V0QWZ0ZXJDb21taXQoY29udGFpbmVySW5mbykge1xuICByZXN0b3JlU2VsZWN0aW9uKHNlbGVjdGlvbkluZm9ybWF0aW9uKTtcbiAgc2V0RW5hYmxlZChldmVudHNFbmFibGVkKTtcbiAgZXZlbnRzRW5hYmxlZCA9IG51bGw7XG4gIHNlbGVjdGlvbkluZm9ybWF0aW9uID0gbnVsbDtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUluc3RhbmNlKHR5cGUsIHByb3BzLCByb290Q29udGFpbmVySW5zdGFuY2UsIGhvc3RDb250ZXh0LCBpbnRlcm5hbEluc3RhbmNlSGFuZGxlKSB7XG4gIHZhciBwYXJlbnROYW1lc3BhY2U7XG5cbiAge1xuICAgIC8vIFRPRE86IHRha2UgbmFtZXNwYWNlIGludG8gYWNjb3VudCB3aGVuIHZhbGlkYXRpbmcuXG4gICAgdmFyIGhvc3RDb250ZXh0RGV2ID0gaG9zdENvbnRleHQ7XG4gICAgdmFsaWRhdGVET01OZXN0aW5nKHR5cGUsIG51bGwsIGhvc3RDb250ZXh0RGV2LmFuY2VzdG9ySW5mbyk7XG5cbiAgICBpZiAodHlwZW9mIHByb3BzLmNoaWxkcmVuID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgcHJvcHMuY2hpbGRyZW4gPT09ICdudW1iZXInKSB7XG4gICAgICB2YXIgc3RyaW5nID0gJycgKyBwcm9wcy5jaGlsZHJlbjtcbiAgICAgIHZhciBvd25BbmNlc3RvckluZm8gPSB1cGRhdGVkQW5jZXN0b3JJbmZvKGhvc3RDb250ZXh0RGV2LmFuY2VzdG9ySW5mbywgdHlwZSk7XG4gICAgICB2YWxpZGF0ZURPTU5lc3RpbmcobnVsbCwgc3RyaW5nLCBvd25BbmNlc3RvckluZm8pO1xuICAgIH1cblxuICAgIHBhcmVudE5hbWVzcGFjZSA9IGhvc3RDb250ZXh0RGV2Lm5hbWVzcGFjZTtcbiAgfVxuXG4gIHZhciBkb21FbGVtZW50ID0gY3JlYXRlRWxlbWVudCh0eXBlLCBwcm9wcywgcm9vdENvbnRhaW5lckluc3RhbmNlLCBwYXJlbnROYW1lc3BhY2UpO1xuICBwcmVjYWNoZUZpYmVyTm9kZShpbnRlcm5hbEluc3RhbmNlSGFuZGxlLCBkb21FbGVtZW50KTtcbiAgdXBkYXRlRmliZXJQcm9wcyhkb21FbGVtZW50LCBwcm9wcyk7XG4gIHJldHVybiBkb21FbGVtZW50O1xufVxuZnVuY3Rpb24gYXBwZW5kSW5pdGlhbENoaWxkKHBhcmVudEluc3RhbmNlLCBjaGlsZCkge1xuICBwYXJlbnRJbnN0YW5jZS5hcHBlbmRDaGlsZChjaGlsZCk7XG59XG5mdW5jdGlvbiBmaW5hbGl6ZUluaXRpYWxDaGlsZHJlbihkb21FbGVtZW50LCB0eXBlLCBwcm9wcywgcm9vdENvbnRhaW5lckluc3RhbmNlLCBob3N0Q29udGV4dCkge1xuICBzZXRJbml0aWFsUHJvcGVydGllcyhkb21FbGVtZW50LCB0eXBlLCBwcm9wcywgcm9vdENvbnRhaW5lckluc3RhbmNlKTtcbiAgcmV0dXJuIHNob3VsZEF1dG9Gb2N1c0hvc3RDb21wb25lbnQodHlwZSwgcHJvcHMpO1xufVxuZnVuY3Rpb24gcHJlcGFyZVVwZGF0ZShkb21FbGVtZW50LCB0eXBlLCBvbGRQcm9wcywgbmV3UHJvcHMsIHJvb3RDb250YWluZXJJbnN0YW5jZSwgaG9zdENvbnRleHQpIHtcbiAge1xuICAgIHZhciBob3N0Q29udGV4dERldiA9IGhvc3RDb250ZXh0O1xuXG4gICAgaWYgKHR5cGVvZiBuZXdQcm9wcy5jaGlsZHJlbiAhPT0gdHlwZW9mIG9sZFByb3BzLmNoaWxkcmVuICYmICh0eXBlb2YgbmV3UHJvcHMuY2hpbGRyZW4gPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBuZXdQcm9wcy5jaGlsZHJlbiA9PT0gJ251bWJlcicpKSB7XG4gICAgICB2YXIgc3RyaW5nID0gJycgKyBuZXdQcm9wcy5jaGlsZHJlbjtcbiAgICAgIHZhciBvd25BbmNlc3RvckluZm8gPSB1cGRhdGVkQW5jZXN0b3JJbmZvKGhvc3RDb250ZXh0RGV2LmFuY2VzdG9ySW5mbywgdHlwZSk7XG4gICAgICB2YWxpZGF0ZURPTU5lc3RpbmcobnVsbCwgc3RyaW5nLCBvd25BbmNlc3RvckluZm8pO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBkaWZmUHJvcGVydGllcyhkb21FbGVtZW50LCB0eXBlLCBvbGRQcm9wcywgbmV3UHJvcHMpO1xufVxuZnVuY3Rpb24gc2hvdWxkU2V0VGV4dENvbnRlbnQodHlwZSwgcHJvcHMpIHtcbiAgcmV0dXJuIHR5cGUgPT09ICd0ZXh0YXJlYScgfHwgdHlwZSA9PT0gJ29wdGlvbicgfHwgdHlwZSA9PT0gJ25vc2NyaXB0JyB8fCB0eXBlb2YgcHJvcHMuY2hpbGRyZW4gPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBwcm9wcy5jaGlsZHJlbiA9PT0gJ251bWJlcicgfHwgdHlwZW9mIHByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MID09PSAnb2JqZWN0JyAmJiBwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTCAhPT0gbnVsbCAmJiBwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTC5fX2h0bWwgIT0gbnVsbDtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVRleHRJbnN0YW5jZSh0ZXh0LCByb290Q29udGFpbmVySW5zdGFuY2UsIGhvc3RDb250ZXh0LCBpbnRlcm5hbEluc3RhbmNlSGFuZGxlKSB7XG4gIHtcbiAgICB2YXIgaG9zdENvbnRleHREZXYgPSBob3N0Q29udGV4dDtcbiAgICB2YWxpZGF0ZURPTU5lc3RpbmcobnVsbCwgdGV4dCwgaG9zdENvbnRleHREZXYuYW5jZXN0b3JJbmZvKTtcbiAgfVxuXG4gIHZhciB0ZXh0Tm9kZSA9IGNyZWF0ZVRleHROb2RlKHRleHQsIHJvb3RDb250YWluZXJJbnN0YW5jZSk7XG4gIHByZWNhY2hlRmliZXJOb2RlKGludGVybmFsSW5zdGFuY2VIYW5kbGUsIHRleHROb2RlKTtcbiAgcmV0dXJuIHRleHROb2RlO1xufVxuLy8gaWYgYSBjb21wb25lbnQganVzdCBpbXBvcnRzIFJlYWN0RE9NIChlLmcuIGZvciBmaW5kRE9NTm9kZSkuXG4vLyBTb21lIGVudmlyb25tZW50cyBtaWdodCBub3QgaGF2ZSBzZXRUaW1lb3V0IG9yIGNsZWFyVGltZW91dC5cblxudmFyIHNjaGVkdWxlVGltZW91dCA9IHR5cGVvZiBzZXRUaW1lb3V0ID09PSAnZnVuY3Rpb24nID8gc2V0VGltZW91dCA6IHVuZGVmaW5lZDtcbnZhciBjYW5jZWxUaW1lb3V0ID0gdHlwZW9mIGNsZWFyVGltZW91dCA9PT0gJ2Z1bmN0aW9uJyA/IGNsZWFyVGltZW91dCA6IHVuZGVmaW5lZDtcbnZhciBub1RpbWVvdXQgPSAtMTsgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLVxuZnVuY3Rpb24gY29tbWl0TW91bnQoZG9tRWxlbWVudCwgdHlwZSwgbmV3UHJvcHMsIGludGVybmFsSW5zdGFuY2VIYW5kbGUpIHtcbiAgLy8gRGVzcGl0ZSB0aGUgbmFtaW5nIHRoYXQgbWlnaHQgaW1wbHkgb3RoZXJ3aXNlLCB0aGlzIG1ldGhvZCBvbmx5XG4gIC8vIGZpcmVzIGlmIHRoZXJlIGlzIGFuIGBVcGRhdGVgIGVmZmVjdCBzY2hlZHVsZWQgZHVyaW5nIG1vdW50aW5nLlxuICAvLyBUaGlzIGhhcHBlbnMgaWYgYGZpbmFsaXplSW5pdGlhbENoaWxkcmVuYCByZXR1cm5zIGB0cnVlYCAod2hpY2ggaXRcbiAgLy8gZG9lcyB0byBpbXBsZW1lbnQgdGhlIGBhdXRvRm9jdXNgIGF0dHJpYnV0ZSBvbiB0aGUgY2xpZW50KS4gQnV0XG4gIC8vIHRoZXJlIGFyZSBhbHNvIG90aGVyIGNhc2VzIHdoZW4gdGhpcyBtaWdodCBoYXBwZW4gKHN1Y2ggYXMgcGF0Y2hpbmdcbiAgLy8gdXAgdGV4dCBjb250ZW50IGR1cmluZyBoeWRyYXRpb24gbWlzbWF0Y2gpLiBTbyB3ZSdsbCBjaGVjayB0aGlzIGFnYWluLlxuICBpZiAoc2hvdWxkQXV0b0ZvY3VzSG9zdENvbXBvbmVudCh0eXBlLCBuZXdQcm9wcykpIHtcbiAgICBkb21FbGVtZW50LmZvY3VzKCk7XG4gIH1cbn1cbmZ1bmN0aW9uIGNvbW1pdFVwZGF0ZShkb21FbGVtZW50LCB1cGRhdGVQYXlsb2FkLCB0eXBlLCBvbGRQcm9wcywgbmV3UHJvcHMsIGludGVybmFsSW5zdGFuY2VIYW5kbGUpIHtcbiAgLy8gVXBkYXRlIHRoZSBwcm9wcyBoYW5kbGUgc28gdGhhdCB3ZSBrbm93IHdoaWNoIHByb3BzIGFyZSB0aGUgb25lcyB3aXRoXG4gIC8vIHdpdGggY3VycmVudCBldmVudCBoYW5kbGVycy5cbiAgdXBkYXRlRmliZXJQcm9wcyhkb21FbGVtZW50LCBuZXdQcm9wcyk7IC8vIEFwcGx5IHRoZSBkaWZmIHRvIHRoZSBET00gbm9kZS5cblxuICB1cGRhdGVQcm9wZXJ0aWVzKGRvbUVsZW1lbnQsIHVwZGF0ZVBheWxvYWQsIHR5cGUsIG9sZFByb3BzLCBuZXdQcm9wcyk7XG59XG5mdW5jdGlvbiByZXNldFRleHRDb250ZW50KGRvbUVsZW1lbnQpIHtcbiAgc2V0VGV4dENvbnRlbnQoZG9tRWxlbWVudCwgJycpO1xufVxuZnVuY3Rpb24gY29tbWl0VGV4dFVwZGF0ZSh0ZXh0SW5zdGFuY2UsIG9sZFRleHQsIG5ld1RleHQpIHtcbiAgdGV4dEluc3RhbmNlLm5vZGVWYWx1ZSA9IG5ld1RleHQ7XG59XG5mdW5jdGlvbiBhcHBlbmRDaGlsZChwYXJlbnRJbnN0YW5jZSwgY2hpbGQpIHtcbiAgcGFyZW50SW5zdGFuY2UuYXBwZW5kQ2hpbGQoY2hpbGQpO1xufVxuZnVuY3Rpb24gYXBwZW5kQ2hpbGRUb0NvbnRhaW5lcihjb250YWluZXIsIGNoaWxkKSB7XG4gIHZhciBwYXJlbnROb2RlO1xuXG4gIGlmIChjb250YWluZXIubm9kZVR5cGUgPT09IENPTU1FTlRfTk9ERSkge1xuICAgIHBhcmVudE5vZGUgPSBjb250YWluZXIucGFyZW50Tm9kZTtcbiAgICBwYXJlbnROb2RlLmluc2VydEJlZm9yZShjaGlsZCwgY29udGFpbmVyKTtcbiAgfSBlbHNlIHtcbiAgICBwYXJlbnROb2RlID0gY29udGFpbmVyO1xuICAgIHBhcmVudE5vZGUuYXBwZW5kQ2hpbGQoY2hpbGQpO1xuICB9IC8vIFRoaXMgY29udGFpbmVyIG1pZ2h0IGJlIHVzZWQgZm9yIGEgcG9ydGFsLlxuICAvLyBJZiBzb21ldGhpbmcgaW5zaWRlIGEgcG9ydGFsIGlzIGNsaWNrZWQsIHRoYXQgY2xpY2sgc2hvdWxkIGJ1YmJsZVxuICAvLyB0aHJvdWdoIHRoZSBSZWFjdCB0cmVlLiBIb3dldmVyLCBvbiBNb2JpbGUgU2FmYXJpIHRoZSBjbGljayB3b3VsZFxuICAvLyBuZXZlciBidWJibGUgdGhyb3VnaCB0aGUgKkRPTSogdHJlZSB1bmxlc3MgYW4gYW5jZXN0b3Igd2l0aCBvbmNsaWNrXG4gIC8vIGV2ZW50IGV4aXN0cy4gU28gd2Ugd291bGRuJ3Qgc2VlIGl0IGFuZCBkaXNwYXRjaCBpdC5cbiAgLy8gVGhpcyBpcyB3aHkgd2UgZW5zdXJlIHRoYXQgbm9uIFJlYWN0IHJvb3QgY29udGFpbmVycyBoYXZlIGlubGluZSBvbmNsaWNrXG4gIC8vIGRlZmluZWQuXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTE5MThcblxuXG4gIHZhciByZWFjdFJvb3RDb250YWluZXIgPSBjb250YWluZXIuX3JlYWN0Um9vdENvbnRhaW5lcjtcblxuICBpZiAoKHJlYWN0Um9vdENvbnRhaW5lciA9PT0gbnVsbCB8fCByZWFjdFJvb3RDb250YWluZXIgPT09IHVuZGVmaW5lZCkgJiYgcGFyZW50Tm9kZS5vbmNsaWNrID09PSBudWxsKSB7XG4gICAgLy8gVE9ETzogVGhpcyBjYXN0IG1heSBub3QgYmUgc291bmQgZm9yIFNWRywgTWF0aE1MIG9yIGN1c3RvbSBlbGVtZW50cy5cbiAgICB0cmFwQ2xpY2tPbk5vbkludGVyYWN0aXZlRWxlbWVudChwYXJlbnROb2RlKTtcbiAgfVxufVxuZnVuY3Rpb24gaW5zZXJ0QmVmb3JlKHBhcmVudEluc3RhbmNlLCBjaGlsZCwgYmVmb3JlQ2hpbGQpIHtcbiAgcGFyZW50SW5zdGFuY2UuaW5zZXJ0QmVmb3JlKGNoaWxkLCBiZWZvcmVDaGlsZCk7XG59XG5mdW5jdGlvbiBpbnNlcnRJbkNvbnRhaW5lckJlZm9yZShjb250YWluZXIsIGNoaWxkLCBiZWZvcmVDaGlsZCkge1xuICBpZiAoY29udGFpbmVyLm5vZGVUeXBlID09PSBDT01NRU5UX05PREUpIHtcbiAgICBjb250YWluZXIucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoY2hpbGQsIGJlZm9yZUNoaWxkKTtcbiAgfSBlbHNlIHtcbiAgICBjb250YWluZXIuaW5zZXJ0QmVmb3JlKGNoaWxkLCBiZWZvcmVDaGlsZCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVtb3ZlQ2hpbGQocGFyZW50SW5zdGFuY2UsIGNoaWxkKSB7XG4gIHBhcmVudEluc3RhbmNlLnJlbW92ZUNoaWxkKGNoaWxkKTtcbn1cbmZ1bmN0aW9uIHJlbW92ZUNoaWxkRnJvbUNvbnRhaW5lcihjb250YWluZXIsIGNoaWxkKSB7XG4gIGlmIChjb250YWluZXIubm9kZVR5cGUgPT09IENPTU1FTlRfTk9ERSkge1xuICAgIGNvbnRhaW5lci5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGNoaWxkKTtcbiAgfSBlbHNlIHtcbiAgICBjb250YWluZXIucmVtb3ZlQ2hpbGQoY2hpbGQpO1xuICB9XG59XG5mdW5jdGlvbiBoaWRlSW5zdGFuY2UoaW5zdGFuY2UpIHtcbiAgLy8gVE9ETzogRG9lcyB0aGlzIHdvcmsgZm9yIGFsbCBlbGVtZW50IHR5cGVzPyBXaGF0IGFib3V0IE1hdGhNTD8gU2hvdWxkIHdlXG4gIC8vIHBhc3MgaG9zdCBjb250ZXh0IHRvIHRoaXMgbWV0aG9kP1xuICBpbnN0YW5jZSA9IGluc3RhbmNlO1xuICB2YXIgc3R5bGUgPSBpbnN0YW5jZS5zdHlsZTtcblxuICBpZiAodHlwZW9mIHN0eWxlLnNldFByb3BlcnR5ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgc3R5bGUuc2V0UHJvcGVydHkoJ2Rpc3BsYXknLCAnbm9uZScsICdpbXBvcnRhbnQnKTtcbiAgfSBlbHNlIHtcbiAgICBzdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICB9XG59XG5mdW5jdGlvbiBoaWRlVGV4dEluc3RhbmNlKHRleHRJbnN0YW5jZSkge1xuICB0ZXh0SW5zdGFuY2Uubm9kZVZhbHVlID0gJyc7XG59XG5mdW5jdGlvbiB1bmhpZGVJbnN0YW5jZShpbnN0YW5jZSwgcHJvcHMpIHtcbiAgaW5zdGFuY2UgPSBpbnN0YW5jZTtcbiAgdmFyIHN0eWxlUHJvcCA9IHByb3BzW1NUWUxFJDFdO1xuICB2YXIgZGlzcGxheSA9IHN0eWxlUHJvcCAhPT0gdW5kZWZpbmVkICYmIHN0eWxlUHJvcCAhPT0gbnVsbCAmJiBzdHlsZVByb3AuaGFzT3duUHJvcGVydHkoJ2Rpc3BsYXknKSA/IHN0eWxlUHJvcC5kaXNwbGF5IDogbnVsbDtcbiAgaW5zdGFuY2Uuc3R5bGUuZGlzcGxheSA9IGRhbmdlcm91c1N0eWxlVmFsdWUoJ2Rpc3BsYXknLCBkaXNwbGF5KTtcbn1cbmZ1bmN0aW9uIHVuaGlkZVRleHRJbnN0YW5jZSh0ZXh0SW5zdGFuY2UsIHRleHQpIHtcbiAgdGV4dEluc3RhbmNlLm5vZGVWYWx1ZSA9IHRleHQ7XG59XG5mdW5jdGlvbiBjbGVhckNvbnRhaW5lcihjb250YWluZXIpIHtcbiAgaWYgKGNvbnRhaW5lci5ub2RlVHlwZSA9PT0gRUxFTUVOVF9OT0RFKSB7XG4gICAgY29udGFpbmVyLnRleHRDb250ZW50ID0gJyc7XG4gIH0gZWxzZSBpZiAoY29udGFpbmVyLm5vZGVUeXBlID09PSBET0NVTUVOVF9OT0RFKSB7XG4gICAgdmFyIGJvZHkgPSBjb250YWluZXIuYm9keTtcblxuICAgIGlmIChib2R5ICE9IG51bGwpIHtcbiAgICAgIGJvZHkudGV4dENvbnRlbnQgPSAnJztcbiAgICB9XG4gIH1cbn0gLy8gLS0tLS0tLS0tLS0tLS0tLS0tLVxuZnVuY3Rpb24gY2FuSHlkcmF0ZUluc3RhbmNlKGluc3RhbmNlLCB0eXBlLCBwcm9wcykge1xuICBpZiAoaW5zdGFuY2Uubm9kZVR5cGUgIT09IEVMRU1FTlRfTk9ERSB8fCB0eXBlLnRvTG93ZXJDYXNlKCkgIT09IGluc3RhbmNlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfSAvLyBUaGlzIGhhcyBub3cgYmVlbiByZWZpbmVkIHRvIGFuIGVsZW1lbnQgbm9kZS5cblxuXG4gIHJldHVybiBpbnN0YW5jZTtcbn1cbmZ1bmN0aW9uIGNhbkh5ZHJhdGVUZXh0SW5zdGFuY2UoaW5zdGFuY2UsIHRleHQpIHtcbiAgaWYgKHRleHQgPT09ICcnIHx8IGluc3RhbmNlLm5vZGVUeXBlICE9PSBURVhUX05PREUpIHtcbiAgICAvLyBFbXB0eSBzdHJpbmdzIGFyZSBub3QgcGFyc2VkIGJ5IEhUTUwgc28gdGhlcmUgd29uJ3QgYmUgYSBjb3JyZWN0IG1hdGNoIGhlcmUuXG4gICAgcmV0dXJuIG51bGw7XG4gIH0gLy8gVGhpcyBoYXMgbm93IGJlZW4gcmVmaW5lZCB0byBhIHRleHQgbm9kZS5cblxuXG4gIHJldHVybiBpbnN0YW5jZTtcbn1cbmZ1bmN0aW9uIGlzU3VzcGVuc2VJbnN0YW5jZVBlbmRpbmcoaW5zdGFuY2UpIHtcbiAgcmV0dXJuIGluc3RhbmNlLmRhdGEgPT09IFNVU1BFTlNFX1BFTkRJTkdfU1RBUlRfREFUQTtcbn1cbmZ1bmN0aW9uIGlzU3VzcGVuc2VJbnN0YW5jZUZhbGxiYWNrKGluc3RhbmNlKSB7XG4gIHJldHVybiBpbnN0YW5jZS5kYXRhID09PSBTVVNQRU5TRV9GQUxMQkFDS19TVEFSVF9EQVRBO1xufVxuXG5mdW5jdGlvbiBnZXROZXh0SHlkcmF0YWJsZShub2RlKSB7XG4gIC8vIFNraXAgbm9uLWh5ZHJhdGFibGUgbm9kZXMuXG4gIGZvciAoOyBub2RlICE9IG51bGw7IG5vZGUgPSBub2RlLm5leHRTaWJsaW5nKSB7XG4gICAgdmFyIG5vZGVUeXBlID0gbm9kZS5ub2RlVHlwZTtcblxuICAgIGlmIChub2RlVHlwZSA9PT0gRUxFTUVOVF9OT0RFIHx8IG5vZGVUeXBlID09PSBURVhUX05PREUpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBub2RlO1xufVxuXG5mdW5jdGlvbiBnZXROZXh0SHlkcmF0YWJsZVNpYmxpbmcoaW5zdGFuY2UpIHtcbiAgcmV0dXJuIGdldE5leHRIeWRyYXRhYmxlKGluc3RhbmNlLm5leHRTaWJsaW5nKTtcbn1cbmZ1bmN0aW9uIGdldEZpcnN0SHlkcmF0YWJsZUNoaWxkKHBhcmVudEluc3RhbmNlKSB7XG4gIHJldHVybiBnZXROZXh0SHlkcmF0YWJsZShwYXJlbnRJbnN0YW5jZS5maXJzdENoaWxkKTtcbn1cbmZ1bmN0aW9uIGh5ZHJhdGVJbnN0YW5jZShpbnN0YW5jZSwgdHlwZSwgcHJvcHMsIHJvb3RDb250YWluZXJJbnN0YW5jZSwgaG9zdENvbnRleHQsIGludGVybmFsSW5zdGFuY2VIYW5kbGUpIHtcbiAgcHJlY2FjaGVGaWJlck5vZGUoaW50ZXJuYWxJbnN0YW5jZUhhbmRsZSwgaW5zdGFuY2UpOyAvLyBUT0RPOiBQb3NzaWJseSBkZWZlciB0aGlzIHVudGlsIHRoZSBjb21taXQgcGhhc2Ugd2hlcmUgYWxsIHRoZSBldmVudHNcbiAgLy8gZ2V0IGF0dGFjaGVkLlxuXG4gIHVwZGF0ZUZpYmVyUHJvcHMoaW5zdGFuY2UsIHByb3BzKTtcbiAgdmFyIHBhcmVudE5hbWVzcGFjZTtcblxuICB7XG4gICAgdmFyIGhvc3RDb250ZXh0RGV2ID0gaG9zdENvbnRleHQ7XG4gICAgcGFyZW50TmFtZXNwYWNlID0gaG9zdENvbnRleHREZXYubmFtZXNwYWNlO1xuICB9XG5cbiAgcmV0dXJuIGRpZmZIeWRyYXRlZFByb3BlcnRpZXMoaW5zdGFuY2UsIHR5cGUsIHByb3BzLCBwYXJlbnROYW1lc3BhY2UpO1xufVxuZnVuY3Rpb24gaHlkcmF0ZVRleHRJbnN0YW5jZSh0ZXh0SW5zdGFuY2UsIHRleHQsIGludGVybmFsSW5zdGFuY2VIYW5kbGUpIHtcbiAgcHJlY2FjaGVGaWJlck5vZGUoaW50ZXJuYWxJbnN0YW5jZUhhbmRsZSwgdGV4dEluc3RhbmNlKTtcbiAgcmV0dXJuIGRpZmZIeWRyYXRlZFRleHQodGV4dEluc3RhbmNlLCB0ZXh0KTtcbn1cbmZ1bmN0aW9uIGdldE5leHRIeWRyYXRhYmxlSW5zdGFuY2VBZnRlclN1c3BlbnNlSW5zdGFuY2Uoc3VzcGVuc2VJbnN0YW5jZSkge1xuICB2YXIgbm9kZSA9IHN1c3BlbnNlSW5zdGFuY2UubmV4dFNpYmxpbmc7IC8vIFNraXAgcGFzdCBhbGwgbm9kZXMgd2l0aGluIHRoaXMgc3VzcGVuc2UgYm91bmRhcnkuXG4gIC8vIFRoZXJlIG1pZ2h0IGJlIG5lc3RlZCBub2RlcyBzbyB3ZSBuZWVkIHRvIGtlZXAgdHJhY2sgb2YgaG93XG4gIC8vIGRlZXAgd2UgYXJlIGFuZCBvbmx5IGJyZWFrIG91dCB3aGVuIHdlJ3JlIGJhY2sgb24gdG9wLlxuXG4gIHZhciBkZXB0aCA9IDA7XG5cbiAgd2hpbGUgKG5vZGUpIHtcbiAgICBpZiAobm9kZS5ub2RlVHlwZSA9PT0gQ09NTUVOVF9OT0RFKSB7XG4gICAgICB2YXIgZGF0YSA9IG5vZGUuZGF0YTtcblxuICAgICAgaWYgKGRhdGEgPT09IFNVU1BFTlNFX0VORF9EQVRBKSB7XG4gICAgICAgIGlmIChkZXB0aCA9PT0gMCkge1xuICAgICAgICAgIHJldHVybiBnZXROZXh0SHlkcmF0YWJsZVNpYmxpbmcobm9kZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGVwdGgtLTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChkYXRhID09PSBTVVNQRU5TRV9TVEFSVF9EQVRBIHx8IGRhdGEgPT09IFNVU1BFTlNFX0ZBTExCQUNLX1NUQVJUX0RBVEEgfHwgZGF0YSA9PT0gU1VTUEVOU0VfUEVORElOR19TVEFSVF9EQVRBKSB7XG4gICAgICAgIGRlcHRoKys7XG4gICAgICB9XG4gICAgfVxuXG4gICAgbm9kZSA9IG5vZGUubmV4dFNpYmxpbmc7XG4gIH0gLy8gVE9ETzogV2Fybiwgd2UgZGlkbid0IGZpbmQgdGhlIGVuZCBjb21tZW50IGJvdW5kYXJ5LlxuXG5cbiAgcmV0dXJuIG51bGw7XG59IC8vIFJldHVybnMgdGhlIFN1c3BlbnNlSW5zdGFuY2UgaWYgdGhpcyBub2RlIGlzIGEgZGlyZWN0IGNoaWxkIG9mIGFcbi8vIFN1c3BlbnNlSW5zdGFuY2UuIEkuZS4gaWYgaXRzIHByZXZpb3VzIHNpYmxpbmcgaXMgYSBDb21tZW50IHdpdGhcbi8vIFNVU1BFTlNFX3hfU1RBUlRfREFUQS4gT3RoZXJ3aXNlLCBudWxsLlxuXG5mdW5jdGlvbiBnZXRQYXJlbnRTdXNwZW5zZUluc3RhbmNlKHRhcmdldEluc3RhbmNlKSB7XG4gIHZhciBub2RlID0gdGFyZ2V0SW5zdGFuY2UucHJldmlvdXNTaWJsaW5nOyAvLyBTa2lwIHBhc3QgYWxsIG5vZGVzIHdpdGhpbiB0aGlzIHN1c3BlbnNlIGJvdW5kYXJ5LlxuICAvLyBUaGVyZSBtaWdodCBiZSBuZXN0ZWQgbm9kZXMgc28gd2UgbmVlZCB0byBrZWVwIHRyYWNrIG9mIGhvd1xuICAvLyBkZWVwIHdlIGFyZSBhbmQgb25seSBicmVhayBvdXQgd2hlbiB3ZSdyZSBiYWNrIG9uIHRvcC5cblxuICB2YXIgZGVwdGggPSAwO1xuXG4gIHdoaWxlIChub2RlKSB7XG4gICAgaWYgKG5vZGUubm9kZVR5cGUgPT09IENPTU1FTlRfTk9ERSkge1xuICAgICAgdmFyIGRhdGEgPSBub2RlLmRhdGE7XG5cbiAgICAgIGlmIChkYXRhID09PSBTVVNQRU5TRV9TVEFSVF9EQVRBIHx8IGRhdGEgPT09IFNVU1BFTlNFX0ZBTExCQUNLX1NUQVJUX0RBVEEgfHwgZGF0YSA9PT0gU1VTUEVOU0VfUEVORElOR19TVEFSVF9EQVRBKSB7XG4gICAgICAgIGlmIChkZXB0aCA9PT0gMCkge1xuICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRlcHRoLS07XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoZGF0YSA9PT0gU1VTUEVOU0VfRU5EX0RBVEEpIHtcbiAgICAgICAgZGVwdGgrKztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBub2RlID0gbm9kZS5wcmV2aW91c1NpYmxpbmc7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGNvbW1pdEh5ZHJhdGVkQ29udGFpbmVyKGNvbnRhaW5lcikge1xuICAvLyBSZXRyeSBpZiBhbnkgZXZlbnQgcmVwbGF5aW5nIHdhcyBibG9ja2VkIG9uIHRoaXMuXG4gIHJldHJ5SWZCbG9ja2VkT24oY29udGFpbmVyKTtcbn1cbmZ1bmN0aW9uIGNvbW1pdEh5ZHJhdGVkU3VzcGVuc2VJbnN0YW5jZShzdXNwZW5zZUluc3RhbmNlKSB7XG4gIC8vIFJldHJ5IGlmIGFueSBldmVudCByZXBsYXlpbmcgd2FzIGJsb2NrZWQgb24gdGhpcy5cbiAgcmV0cnlJZkJsb2NrZWRPbihzdXNwZW5zZUluc3RhbmNlKTtcbn1cbmZ1bmN0aW9uIGRpZE5vdE1hdGNoSHlkcmF0ZWRDb250YWluZXJUZXh0SW5zdGFuY2UocGFyZW50Q29udGFpbmVyLCB0ZXh0SW5zdGFuY2UsIHRleHQpIHtcbiAge1xuICAgIHdhcm5Gb3JVbm1hdGNoZWRUZXh0KHRleHRJbnN0YW5jZSwgdGV4dCk7XG4gIH1cbn1cbmZ1bmN0aW9uIGRpZE5vdE1hdGNoSHlkcmF0ZWRUZXh0SW5zdGFuY2UocGFyZW50VHlwZSwgcGFyZW50UHJvcHMsIHBhcmVudEluc3RhbmNlLCB0ZXh0SW5zdGFuY2UsIHRleHQpIHtcbiAgaWYgKCBwYXJlbnRQcm9wc1tTVVBQUkVTU19IWURSQVRJT05fV0FSTklORyQxXSAhPT0gdHJ1ZSkge1xuICAgIHdhcm5Gb3JVbm1hdGNoZWRUZXh0KHRleHRJbnN0YW5jZSwgdGV4dCk7XG4gIH1cbn1cbmZ1bmN0aW9uIGRpZE5vdEh5ZHJhdGVDb250YWluZXJJbnN0YW5jZShwYXJlbnRDb250YWluZXIsIGluc3RhbmNlKSB7XG4gIHtcbiAgICBpZiAoaW5zdGFuY2Uubm9kZVR5cGUgPT09IEVMRU1FTlRfTk9ERSkge1xuICAgICAgd2FybkZvckRlbGV0ZWRIeWRyYXRhYmxlRWxlbWVudChwYXJlbnRDb250YWluZXIsIGluc3RhbmNlKTtcbiAgICB9IGVsc2UgaWYgKGluc3RhbmNlLm5vZGVUeXBlID09PSBDT01NRU5UX05PREUpIDsgZWxzZSB7XG4gICAgICB3YXJuRm9yRGVsZXRlZEh5ZHJhdGFibGVUZXh0KHBhcmVudENvbnRhaW5lciwgaW5zdGFuY2UpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gZGlkTm90SHlkcmF0ZUluc3RhbmNlKHBhcmVudFR5cGUsIHBhcmVudFByb3BzLCBwYXJlbnRJbnN0YW5jZSwgaW5zdGFuY2UpIHtcbiAgaWYgKCBwYXJlbnRQcm9wc1tTVVBQUkVTU19IWURSQVRJT05fV0FSTklORyQxXSAhPT0gdHJ1ZSkge1xuICAgIGlmIChpbnN0YW5jZS5ub2RlVHlwZSA9PT0gRUxFTUVOVF9OT0RFKSB7XG4gICAgICB3YXJuRm9yRGVsZXRlZEh5ZHJhdGFibGVFbGVtZW50KHBhcmVudEluc3RhbmNlLCBpbnN0YW5jZSk7XG4gICAgfSBlbHNlIGlmIChpbnN0YW5jZS5ub2RlVHlwZSA9PT0gQ09NTUVOVF9OT0RFKSA7IGVsc2Uge1xuICAgICAgd2FybkZvckRlbGV0ZWRIeWRyYXRhYmxlVGV4dChwYXJlbnRJbnN0YW5jZSwgaW5zdGFuY2UpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gZGlkTm90RmluZEh5ZHJhdGFibGVDb250YWluZXJJbnN0YW5jZShwYXJlbnRDb250YWluZXIsIHR5cGUsIHByb3BzKSB7XG4gIHtcbiAgICB3YXJuRm9ySW5zZXJ0ZWRIeWRyYXRlZEVsZW1lbnQocGFyZW50Q29udGFpbmVyLCB0eXBlKTtcbiAgfVxufVxuZnVuY3Rpb24gZGlkTm90RmluZEh5ZHJhdGFibGVDb250YWluZXJUZXh0SW5zdGFuY2UocGFyZW50Q29udGFpbmVyLCB0ZXh0KSB7XG4gIHtcbiAgICB3YXJuRm9ySW5zZXJ0ZWRIeWRyYXRlZFRleHQocGFyZW50Q29udGFpbmVyLCB0ZXh0KTtcbiAgfVxufVxuZnVuY3Rpb24gZGlkTm90RmluZEh5ZHJhdGFibGVJbnN0YW5jZShwYXJlbnRUeXBlLCBwYXJlbnRQcm9wcywgcGFyZW50SW5zdGFuY2UsIHR5cGUsIHByb3BzKSB7XG4gIGlmICggcGFyZW50UHJvcHNbU1VQUFJFU1NfSFlEUkFUSU9OX1dBUk5JTkckMV0gIT09IHRydWUpIHtcbiAgICB3YXJuRm9ySW5zZXJ0ZWRIeWRyYXRlZEVsZW1lbnQocGFyZW50SW5zdGFuY2UsIHR5cGUpO1xuICB9XG59XG5mdW5jdGlvbiBkaWROb3RGaW5kSHlkcmF0YWJsZVRleHRJbnN0YW5jZShwYXJlbnRUeXBlLCBwYXJlbnRQcm9wcywgcGFyZW50SW5zdGFuY2UsIHRleHQpIHtcbiAgaWYgKCBwYXJlbnRQcm9wc1tTVVBQUkVTU19IWURSQVRJT05fV0FSTklORyQxXSAhPT0gdHJ1ZSkge1xuICAgIHdhcm5Gb3JJbnNlcnRlZEh5ZHJhdGVkVGV4dChwYXJlbnRJbnN0YW5jZSwgdGV4dCk7XG4gIH1cbn1cbmZ1bmN0aW9uIGRpZE5vdEZpbmRIeWRyYXRhYmxlU3VzcGVuc2VJbnN0YW5jZShwYXJlbnRUeXBlLCBwYXJlbnRQcm9wcywgcGFyZW50SW5zdGFuY2UpIHtcbiAgaWYgKCBwYXJlbnRQcm9wc1tTVVBQUkVTU19IWURSQVRJT05fV0FSTklORyQxXSAhPT0gdHJ1ZSkgO1xufVxudmFyIGNsaWVudElkID0gMDtcbmZ1bmN0aW9uIG1ha2VDbGllbnRJZEluREVWKHdhcm5PbkFjY2Vzc0luREVWKSB7XG4gIHZhciBpZCA9ICdyOicgKyAoY2xpZW50SWQrKykudG9TdHJpbmcoMzYpO1xuICByZXR1cm4ge1xuICAgIHRvU3RyaW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgICB3YXJuT25BY2Nlc3NJbkRFVigpO1xuICAgICAgcmV0dXJuIGlkO1xuICAgIH0sXG4gICAgdmFsdWVPZjogZnVuY3Rpb24gKCkge1xuICAgICAgd2Fybk9uQWNjZXNzSW5ERVYoKTtcbiAgICAgIHJldHVybiBpZDtcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBpc09wYXF1ZUh5ZHJhdGluZ09iamVjdCh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT09IG51bGwgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZS4kJHR5cGVvZiA9PT0gUkVBQ1RfT1BBUVVFX0lEX1RZUEU7XG59XG5mdW5jdGlvbiBtYWtlT3BhcXVlSHlkcmF0aW5nT2JqZWN0KGF0dGVtcHRUb1JlYWRWYWx1ZSkge1xuICByZXR1cm4ge1xuICAgICQkdHlwZW9mOiBSRUFDVF9PUEFRVUVfSURfVFlQRSxcbiAgICB0b1N0cmluZzogYXR0ZW1wdFRvUmVhZFZhbHVlLFxuICAgIHZhbHVlT2Y6IGF0dGVtcHRUb1JlYWRWYWx1ZVxuICB9O1xufVxuZnVuY3Rpb24gcHJlcGFyZVBvcnRhbE1vdW50KHBvcnRhbEluc3RhbmNlKSB7XG4gIHtcbiAgICBsaXN0ZW5Ub0FsbFN1cHBvcnRlZEV2ZW50cyhwb3J0YWxJbnN0YW5jZSk7XG4gIH1cbn1cblxudmFyIHJhbmRvbUtleSA9IE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnNsaWNlKDIpO1xudmFyIGludGVybmFsSW5zdGFuY2VLZXkgPSAnX19yZWFjdEZpYmVyJCcgKyByYW5kb21LZXk7XG52YXIgaW50ZXJuYWxQcm9wc0tleSA9ICdfX3JlYWN0UHJvcHMkJyArIHJhbmRvbUtleTtcbnZhciBpbnRlcm5hbENvbnRhaW5lckluc3RhbmNlS2V5ID0gJ19fcmVhY3RDb250YWluZXIkJyArIHJhbmRvbUtleTtcbnZhciBpbnRlcm5hbEV2ZW50SGFuZGxlcnNLZXkgPSAnX19yZWFjdEV2ZW50cyQnICsgcmFuZG9tS2V5O1xuZnVuY3Rpb24gcHJlY2FjaGVGaWJlck5vZGUoaG9zdEluc3QsIG5vZGUpIHtcbiAgbm9kZVtpbnRlcm5hbEluc3RhbmNlS2V5XSA9IGhvc3RJbnN0O1xufVxuZnVuY3Rpb24gbWFya0NvbnRhaW5lckFzUm9vdChob3N0Um9vdCwgbm9kZSkge1xuICBub2RlW2ludGVybmFsQ29udGFpbmVySW5zdGFuY2VLZXldID0gaG9zdFJvb3Q7XG59XG5mdW5jdGlvbiB1bm1hcmtDb250YWluZXJBc1Jvb3Qobm9kZSkge1xuICBub2RlW2ludGVybmFsQ29udGFpbmVySW5zdGFuY2VLZXldID0gbnVsbDtcbn1cbmZ1bmN0aW9uIGlzQ29udGFpbmVyTWFya2VkQXNSb290KG5vZGUpIHtcbiAgcmV0dXJuICEhbm9kZVtpbnRlcm5hbENvbnRhaW5lckluc3RhbmNlS2V5XTtcbn0gLy8gR2l2ZW4gYSBET00gbm9kZSwgcmV0dXJuIHRoZSBjbG9zZXN0IEhvc3RDb21wb25lbnQgb3IgSG9zdFRleHQgZmliZXIgYW5jZXN0b3IuXG4vLyBJZiB0aGUgdGFyZ2V0IG5vZGUgaXMgcGFydCBvZiBhIGh5ZHJhdGVkIG9yIG5vdCB5ZXQgcmVuZGVyZWQgc3VidHJlZSwgdGhlblxuLy8gdGhpcyBtYXkgYWxzbyByZXR1cm4gYSBTdXNwZW5zZUNvbXBvbmVudCBvciBIb3N0Um9vdCB0byBpbmRpY2F0ZSB0aGF0LlxuLy8gQ29uY2VwdHVhbGx5IHRoZSBIb3N0Um9vdCBmaWJlciBpcyBhIGNoaWxkIG9mIHRoZSBDb250YWluZXIgbm9kZS4gU28gaWYgeW91XG4vLyBwYXNzIHRoZSBDb250YWluZXIgbm9kZSBhcyB0aGUgdGFyZ2V0Tm9kZSwgeW91IHdpbGwgbm90IGFjdHVhbGx5IGdldCB0aGVcbi8vIEhvc3RSb290IGJhY2suIFRvIGdldCB0byB0aGUgSG9zdFJvb3QsIHlvdSBuZWVkIHRvIHBhc3MgYSBjaGlsZCBvZiBpdC5cbi8vIFRoZSBzYW1lIHRoaW5nIGFwcGxpZXMgdG8gU3VzcGVuc2UgYm91bmRhcmllcy5cblxuZnVuY3Rpb24gZ2V0Q2xvc2VzdEluc3RhbmNlRnJvbU5vZGUodGFyZ2V0Tm9kZSkge1xuICB2YXIgdGFyZ2V0SW5zdCA9IHRhcmdldE5vZGVbaW50ZXJuYWxJbnN0YW5jZUtleV07XG5cbiAgaWYgKHRhcmdldEluc3QpIHtcbiAgICAvLyBEb24ndCByZXR1cm4gSG9zdFJvb3Qgb3IgU3VzcGVuc2VDb21wb25lbnQgaGVyZS5cbiAgICByZXR1cm4gdGFyZ2V0SW5zdDtcbiAgfSAvLyBJZiB0aGUgZGlyZWN0IGV2ZW50IHRhcmdldCBpc24ndCBhIFJlYWN0IG93bmVkIERPTSBub2RlLCB3ZSBuZWVkIHRvIGxvb2tcbiAgLy8gdG8gc2VlIGlmIG9uZSBvZiBpdHMgcGFyZW50cyBpcyBhIFJlYWN0IG93bmVkIERPTSBub2RlLlxuXG5cbiAgdmFyIHBhcmVudE5vZGUgPSB0YXJnZXROb2RlLnBhcmVudE5vZGU7XG5cbiAgd2hpbGUgKHBhcmVudE5vZGUpIHtcbiAgICAvLyBXZSdsbCBjaGVjayBpZiB0aGlzIGlzIGEgY29udGFpbmVyIHJvb3QgdGhhdCBjb3VsZCBpbmNsdWRlXG4gICAgLy8gUmVhY3Qgbm9kZXMgaW4gdGhlIGZ1dHVyZS4gV2UgbmVlZCB0byBjaGVjayB0aGlzIGZpcnN0IGJlY2F1c2VcbiAgICAvLyBpZiB3ZSdyZSBhIGNoaWxkIG9mIGEgZGVoeWRyYXRlZCBjb250YWluZXIsIHdlIG5lZWQgdG8gZmlyc3RcbiAgICAvLyBmaW5kIHRoYXQgaW5uZXIgY29udGFpbmVyIGJlZm9yZSBtb3Zpbmcgb24gdG8gZmluZGluZyB0aGUgcGFyZW50XG4gICAgLy8gaW5zdGFuY2UuIE5vdGUgdGhhdCB3ZSBkb24ndCBjaGVjayB0aGlzIGZpZWxkIG9uICB0aGUgdGFyZ2V0Tm9kZVxuICAgIC8vIGl0c2VsZiBiZWNhdXNlIHRoZSBmaWJlcnMgYXJlIGNvbmNlcHR1YWxseSBiZXR3ZWVuIHRoZSBjb250YWluZXJcbiAgICAvLyBub2RlIGFuZCB0aGUgZmlyc3QgY2hpbGQuIEl0IGlzbid0IHN1cnJvdW5kaW5nIHRoZSBjb250YWluZXIgbm9kZS5cbiAgICAvLyBJZiBpdCdzIG5vdCBhIGNvbnRhaW5lciwgd2UgY2hlY2sgaWYgaXQncyBhbiBpbnN0YW5jZS5cbiAgICB0YXJnZXRJbnN0ID0gcGFyZW50Tm9kZVtpbnRlcm5hbENvbnRhaW5lckluc3RhbmNlS2V5XSB8fCBwYXJlbnROb2RlW2ludGVybmFsSW5zdGFuY2VLZXldO1xuXG4gICAgaWYgKHRhcmdldEluc3QpIHtcbiAgICAgIC8vIFNpbmNlIHRoaXMgd2Fzbid0IHRoZSBkaXJlY3QgdGFyZ2V0IG9mIHRoZSBldmVudCwgd2UgbWlnaHQgaGF2ZVxuICAgICAgLy8gc3RlcHBlZCBwYXN0IGRlaHlkcmF0ZWQgRE9NIG5vZGVzIHRvIGdldCBoZXJlLiBIb3dldmVyIHRoZXkgY291bGRcbiAgICAgIC8vIGFsc28gaGF2ZSBiZWVuIG5vbi1SZWFjdCBub2Rlcy4gV2UgbmVlZCB0byBhbnN3ZXIgd2hpY2ggb25lLlxuICAgICAgLy8gSWYgd2UgdGhlIGluc3RhbmNlIGRvZXNuJ3QgaGF2ZSBhbnkgY2hpbGRyZW4sIHRoZW4gdGhlcmUgY2FuJ3QgYmVcbiAgICAgIC8vIGEgbmVzdGVkIHN1c3BlbnNlIGJvdW5kYXJ5IHdpdGhpbiBpdC4gU28gd2UgY2FuIHVzZSB0aGlzIGFzIGEgZmFzdFxuICAgICAgLy8gYmFpbG91dC4gTW9zdCBvZiB0aGUgdGltZSwgd2hlbiBwZW9wbGUgYWRkIG5vbi1SZWFjdCBjaGlsZHJlbiB0b1xuICAgICAgLy8gdGhlIHRyZWUsIGl0IGlzIHVzaW5nIGEgcmVmIHRvIGEgY2hpbGQtbGVzcyBET00gbm9kZS5cbiAgICAgIC8vIE5vcm1hbGx5IHdlJ2Qgb25seSBuZWVkIHRvIGNoZWNrIG9uZSBvZiB0aGUgZmliZXJzIGJlY2F1c2UgaWYgaXRcbiAgICAgIC8vIGhhcyBldmVyIGdvbmUgZnJvbSBoYXZpbmcgY2hpbGRyZW4gdG8gZGVsZXRpbmcgdGhlbSBvciB2aWNlIHZlcnNhXG4gICAgICAvLyBpdCB3b3VsZCBoYXZlIGRlbGV0ZWQgdGhlIGRlaHlkcmF0ZWQgYm91bmRhcnkgbmVzdGVkIGluc2lkZSBhbHJlYWR5LlxuICAgICAgLy8gSG93ZXZlciwgc2luY2UgdGhlIEhvc3RSb290IHN0YXJ0cyBvdXQgd2l0aCBhbiBhbHRlcm5hdGUgaXQgbWlnaHRcbiAgICAgIC8vIGhhdmUgb25lIG9uIHRoZSBhbHRlcm5hdGUgc28gd2UgbmVlZCB0byBjaGVjayBpbiBjYXNlIHRoaXMgd2FzIGFcbiAgICAgIC8vIHJvb3QuXG4gICAgICB2YXIgYWx0ZXJuYXRlID0gdGFyZ2V0SW5zdC5hbHRlcm5hdGU7XG5cbiAgICAgIGlmICh0YXJnZXRJbnN0LmNoaWxkICE9PSBudWxsIHx8IGFsdGVybmF0ZSAhPT0gbnVsbCAmJiBhbHRlcm5hdGUuY2hpbGQgIT09IG51bGwpIHtcbiAgICAgICAgLy8gTmV4dCB3ZSBuZWVkIHRvIGZpZ3VyZSBvdXQgaWYgdGhlIG5vZGUgdGhhdCBza2lwcGVkIHBhc3QgaXNcbiAgICAgICAgLy8gbmVzdGVkIHdpdGhpbiBhIGRlaHlkcmF0ZWQgYm91bmRhcnkgYW5kIGlmIHNvLCB3aGljaCBvbmUuXG4gICAgICAgIHZhciBzdXNwZW5zZUluc3RhbmNlID0gZ2V0UGFyZW50U3VzcGVuc2VJbnN0YW5jZSh0YXJnZXROb2RlKTtcblxuICAgICAgICB3aGlsZSAoc3VzcGVuc2VJbnN0YW5jZSAhPT0gbnVsbCkge1xuICAgICAgICAgIC8vIFdlIGZvdW5kIGEgc3VzcGVuc2UgaW5zdGFuY2UuIFRoYXQgbWVhbnMgdGhhdCB3ZSBoYXZlbid0XG4gICAgICAgICAgLy8gaHlkcmF0ZWQgaXQgeWV0LiBFdmVuIHRob3VnaCB3ZSBsZWF2ZSB0aGUgY29tbWVudHMgaW4gdGhlXG4gICAgICAgICAgLy8gRE9NIGFmdGVyIGh5ZHJhdGluZywgYW5kIHRoZXJlIGFyZSBib3VuZGFyaWVzIGluIHRoZSBET01cbiAgICAgICAgICAvLyB0aGF0IGNvdWxkIGFscmVhZHkgYmUgaHlkcmF0ZWQsIHdlIHdvdWxkbid0IGhhdmUgZm91bmQgdGhlbVxuICAgICAgICAgIC8vIHRocm91Z2ggdGhpcyBwYXNzIHNpbmNlIGlmIHRoZSB0YXJnZXQgaXMgaHlkcmF0ZWQgaXQgd291bGRcbiAgICAgICAgICAvLyBoYXZlIGhhZCBhbiBpbnRlcm5hbEluc3RhbmNlS2V5IG9uIGl0LlxuICAgICAgICAgIC8vIExldCdzIGdldCB0aGUgZmliZXIgYXNzb2NpYXRlZCB3aXRoIHRoZSBTdXNwZW5zZUNvbXBvbmVudFxuICAgICAgICAgIC8vIGFzIHRoZSBkZWVwZXN0IGluc3RhbmNlLlxuICAgICAgICAgIHZhciB0YXJnZXRTdXNwZW5zZUluc3QgPSBzdXNwZW5zZUluc3RhbmNlW2ludGVybmFsSW5zdGFuY2VLZXldO1xuXG4gICAgICAgICAgaWYgKHRhcmdldFN1c3BlbnNlSW5zdCkge1xuICAgICAgICAgICAgcmV0dXJuIHRhcmdldFN1c3BlbnNlSW5zdDtcbiAgICAgICAgICB9IC8vIElmIHdlIGRvbid0IGZpbmQgYSBGaWJlciBvbiB0aGUgY29tbWVudCwgaXQgbWlnaHQgYmUgYmVjYXVzZVxuICAgICAgICAgIC8vIHdlIGhhdmVuJ3QgZ290dGVuIHRvIGh5ZHJhdGUgaXQgeWV0LiBUaGVyZSBtaWdodCBzdGlsbCBiZSBhXG4gICAgICAgICAgLy8gcGFyZW50IGJvdW5kYXJ5IHRoYXQgaGFzbid0IGFib3ZlIHRoaXMgb25lIHNvIHdlIG5lZWQgdG8gZmluZFxuICAgICAgICAgIC8vIHRoZSBvdXRlciBtb3N0IHRoYXQgaXMga25vd24uXG5cblxuICAgICAgICAgIHN1c3BlbnNlSW5zdGFuY2UgPSBnZXRQYXJlbnRTdXNwZW5zZUluc3RhbmNlKHN1c3BlbnNlSW5zdGFuY2UpOyAvLyBJZiB3ZSBkb24ndCBmaW5kIG9uZSwgdGhlbiB0aGF0IHNob3VsZCBtZWFuIHRoYXQgdGhlIHBhcmVudFxuICAgICAgICAgIC8vIGhvc3QgY29tcG9uZW50IGFsc28gaGFzbid0IGh5ZHJhdGVkIHlldC4gV2UgY2FuIHJldHVybiBpdFxuICAgICAgICAgIC8vIGJlbG93IHNpbmNlIGl0IHdpbGwgYmFpbCBvdXQgb24gdGhlIGlzTW91bnRlZCBjaGVjayBsYXRlci5cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGFyZ2V0SW5zdDtcbiAgICB9XG5cbiAgICB0YXJnZXROb2RlID0gcGFyZW50Tm9kZTtcbiAgICBwYXJlbnROb2RlID0gdGFyZ2V0Tm9kZS5wYXJlbnROb2RlO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG4vKipcbiAqIEdpdmVuIGEgRE9NIG5vZGUsIHJldHVybiB0aGUgUmVhY3RET01Db21wb25lbnQgb3IgUmVhY3RET01UZXh0Q29tcG9uZW50XG4gKiBpbnN0YW5jZSwgb3IgbnVsbCBpZiB0aGUgbm9kZSB3YXMgbm90IHJlbmRlcmVkIGJ5IHRoaXMgUmVhY3QuXG4gKi9cblxuZnVuY3Rpb24gZ2V0SW5zdGFuY2VGcm9tTm9kZShub2RlKSB7XG4gIHZhciBpbnN0ID0gbm9kZVtpbnRlcm5hbEluc3RhbmNlS2V5XSB8fCBub2RlW2ludGVybmFsQ29udGFpbmVySW5zdGFuY2VLZXldO1xuXG4gIGlmIChpbnN0KSB7XG4gICAgaWYgKGluc3QudGFnID09PSBIb3N0Q29tcG9uZW50IHx8IGluc3QudGFnID09PSBIb3N0VGV4dCB8fCBpbnN0LnRhZyA9PT0gU3VzcGVuc2VDb21wb25lbnQgfHwgaW5zdC50YWcgPT09IEhvc3RSb290KSB7XG4gICAgICByZXR1cm4gaW5zdDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG4vKipcbiAqIEdpdmVuIGEgUmVhY3RET01Db21wb25lbnQgb3IgUmVhY3RET01UZXh0Q29tcG9uZW50LCByZXR1cm4gdGhlIGNvcnJlc3BvbmRpbmdcbiAqIERPTSBub2RlLlxuICovXG5cbmZ1bmN0aW9uIGdldE5vZGVGcm9tSW5zdGFuY2UoaW5zdCkge1xuICBpZiAoaW5zdC50YWcgPT09IEhvc3RDb21wb25lbnQgfHwgaW5zdC50YWcgPT09IEhvc3RUZXh0KSB7XG4gICAgLy8gSW4gRmliZXIgdGhpcywgaXMganVzdCB0aGUgc3RhdGUgbm9kZSByaWdodCBub3cuIFdlIGFzc3VtZSBpdCB3aWxsIGJlXG4gICAgLy8gYSBob3N0IGNvbXBvbmVudCBvciBob3N0IHRleHQuXG4gICAgcmV0dXJuIGluc3Quc3RhdGVOb2RlO1xuICB9IC8vIFdpdGhvdXQgdGhpcyBmaXJzdCBpbnZhcmlhbnQsIHBhc3NpbmcgYSBub24tRE9NLWNvbXBvbmVudCB0cmlnZ2VycyB0aGUgbmV4dFxuICAvLyBpbnZhcmlhbnQgZm9yIGEgbWlzc2luZyBwYXJlbnQsIHdoaWNoIGlzIHN1cGVyIGNvbmZ1c2luZy5cblxuXG4gIHtcbiAgICB7XG4gICAgICB0aHJvdyBFcnJvciggXCJnZXROb2RlRnJvbUluc3RhbmNlOiBJbnZhbGlkIGFyZ3VtZW50LlwiICk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBnZXRGaWJlckN1cnJlbnRQcm9wc0Zyb21Ob2RlKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGVbaW50ZXJuYWxQcm9wc0tleV0gfHwgbnVsbDtcbn1cbmZ1bmN0aW9uIHVwZGF0ZUZpYmVyUHJvcHMobm9kZSwgcHJvcHMpIHtcbiAgbm9kZVtpbnRlcm5hbFByb3BzS2V5XSA9IHByb3BzO1xufVxuZnVuY3Rpb24gZ2V0RXZlbnRMaXN0ZW5lclNldChub2RlKSB7XG4gIHZhciBlbGVtZW50TGlzdGVuZXJTZXQgPSBub2RlW2ludGVybmFsRXZlbnRIYW5kbGVyc0tleV07XG5cbiAgaWYgKGVsZW1lbnRMaXN0ZW5lclNldCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZWxlbWVudExpc3RlbmVyU2V0ID0gbm9kZVtpbnRlcm5hbEV2ZW50SGFuZGxlcnNLZXldID0gbmV3IFNldCgpO1xuICB9XG5cbiAgcmV0dXJuIGVsZW1lbnRMaXN0ZW5lclNldDtcbn1cblxudmFyIGxvZ2dlZFR5cGVGYWlsdXJlcyA9IHt9O1xudmFyIFJlYWN0RGVidWdDdXJyZW50RnJhbWUkMSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0RGVidWdDdXJyZW50RnJhbWU7XG5cbmZ1bmN0aW9uIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KGVsZW1lbnQpIHtcbiAge1xuICAgIGlmIChlbGVtZW50KSB7XG4gICAgICB2YXIgb3duZXIgPSBlbGVtZW50Ll9vd25lcjtcbiAgICAgIHZhciBzdGFjayA9IGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVihlbGVtZW50LnR5cGUsIGVsZW1lbnQuX3NvdXJjZSwgb3duZXIgPyBvd25lci50eXBlIDogbnVsbCk7XG4gICAgICBSZWFjdERlYnVnQ3VycmVudEZyYW1lJDEuc2V0RXh0cmFTdGFja0ZyYW1lKHN0YWNrKTtcbiAgICB9IGVsc2Uge1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSQxLnNldEV4dHJhU3RhY2tGcmFtZShudWxsKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY2hlY2tQcm9wVHlwZXModHlwZVNwZWNzLCB2YWx1ZXMsIGxvY2F0aW9uLCBjb21wb25lbnROYW1lLCBlbGVtZW50KSB7XG4gIHtcbiAgICAvLyAkRmxvd0ZpeE1lIFRoaXMgaXMgb2theSBidXQgRmxvdyBkb2Vzbid0IGtub3cgaXQuXG4gICAgdmFyIGhhcyA9IEZ1bmN0aW9uLmNhbGwuYmluZChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5KTtcblxuICAgIGZvciAodmFyIHR5cGVTcGVjTmFtZSBpbiB0eXBlU3BlY3MpIHtcbiAgICAgIGlmIChoYXModHlwZVNwZWNzLCB0eXBlU3BlY05hbWUpKSB7XG4gICAgICAgIHZhciBlcnJvciQxID0gdm9pZCAwOyAvLyBQcm9wIHR5cGUgdmFsaWRhdGlvbiBtYXkgdGhyb3cuIEluIGNhc2UgdGhleSBkbywgd2UgZG9uJ3Qgd2FudCB0b1xuICAgICAgICAvLyBmYWlsIHRoZSByZW5kZXIgcGhhc2Ugd2hlcmUgaXQgZGlkbid0IGZhaWwgYmVmb3JlLiBTbyB3ZSBsb2cgaXQuXG4gICAgICAgIC8vIEFmdGVyIHRoZXNlIGhhdmUgYmVlbiBjbGVhbmVkIHVwLCB3ZSdsbCBsZXQgdGhlbSB0aHJvdy5cblxuICAgICAgICB0cnkge1xuICAgICAgICAgIC8vIFRoaXMgaXMgaW50ZW50aW9uYWxseSBhbiBpbnZhcmlhbnQgdGhhdCBnZXRzIGNhdWdodC4gSXQncyB0aGUgc2FtZVxuICAgICAgICAgIC8vIGJlaGF2aW9yIGFzIHdpdGhvdXQgdGhpcyBzdGF0ZW1lbnQgZXhjZXB0IHdpdGggYSBiZXR0ZXIgbWVzc2FnZS5cbiAgICAgICAgICBpZiAodHlwZW9mIHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB2YXIgZXJyID0gRXJyb3IoKGNvbXBvbmVudE5hbWUgfHwgJ1JlYWN0IGNsYXNzJykgKyAnOiAnICsgbG9jYXRpb24gKyAnIHR5cGUgYCcgKyB0eXBlU3BlY05hbWUgKyAnYCBpcyBpbnZhbGlkOyAnICsgJ2l0IG11c3QgYmUgYSBmdW5jdGlvbiwgdXN1YWxseSBmcm9tIHRoZSBgcHJvcC10eXBlc2AgcGFja2FnZSwgYnV0IHJlY2VpdmVkIGAnICsgdHlwZW9mIHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdICsgJ2AuJyArICdUaGlzIG9mdGVuIGhhcHBlbnMgYmVjYXVzZSBvZiB0eXBvcyBzdWNoIGFzIGBQcm9wVHlwZXMuZnVuY3Rpb25gIGluc3RlYWQgb2YgYFByb3BUeXBlcy5mdW5jYC4nKTtcbiAgICAgICAgICAgIGVyci5uYW1lID0gJ0ludmFyaWFudCBWaW9sYXRpb24nO1xuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGVycm9yJDEgPSB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSh2YWx1ZXMsIHR5cGVTcGVjTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIG51bGwsICdTRUNSRVRfRE9fTk9UX1BBU1NfVEhJU19PUl9ZT1VfV0lMTF9CRV9GSVJFRCcpO1xuICAgICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICAgIGVycm9yJDEgPSBleDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlcnJvciQxICYmICEoZXJyb3IkMSBpbnN0YW5jZW9mIEVycm9yKSkge1xuICAgICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KGVsZW1lbnQpO1xuXG4gICAgICAgICAgZXJyb3IoJyVzOiB0eXBlIHNwZWNpZmljYXRpb24gb2YgJXMnICsgJyBgJXNgIGlzIGludmFsaWQ7IHRoZSB0eXBlIGNoZWNrZXIgJyArICdmdW5jdGlvbiBtdXN0IHJldHVybiBgbnVsbGAgb3IgYW4gYEVycm9yYCBidXQgcmV0dXJuZWQgYSAlcy4gJyArICdZb3UgbWF5IGhhdmUgZm9yZ290dGVuIHRvIHBhc3MgYW4gYXJndW1lbnQgdG8gdGhlIHR5cGUgY2hlY2tlciAnICsgJ2NyZWF0b3IgKGFycmF5T2YsIGluc3RhbmNlT2YsIG9iamVjdE9mLCBvbmVPZiwgb25lT2ZUeXBlLCBhbmQgJyArICdzaGFwZSBhbGwgcmVxdWlyZSBhbiBhcmd1bWVudCkuJywgY29tcG9uZW50TmFtZSB8fCAnUmVhY3QgY2xhc3MnLCBsb2NhdGlvbiwgdHlwZVNwZWNOYW1lLCB0eXBlb2YgZXJyb3IkMSk7XG5cbiAgICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChudWxsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlcnJvciQxIGluc3RhbmNlb2YgRXJyb3IgJiYgIShlcnJvciQxLm1lc3NhZ2UgaW4gbG9nZ2VkVHlwZUZhaWx1cmVzKSkge1xuICAgICAgICAgIC8vIE9ubHkgbW9uaXRvciB0aGlzIGZhaWx1cmUgb25jZSBiZWNhdXNlIHRoZXJlIHRlbmRzIHRvIGJlIGEgbG90IG9mIHRoZVxuICAgICAgICAgIC8vIHNhbWUgZXJyb3IuXG4gICAgICAgICAgbG9nZ2VkVHlwZUZhaWx1cmVzW2Vycm9yJDEubWVzc2FnZV0gPSB0cnVlO1xuICAgICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KGVsZW1lbnQpO1xuXG4gICAgICAgICAgZXJyb3IoJ0ZhaWxlZCAlcyB0eXBlOiAlcycsIGxvY2F0aW9uLCBlcnJvciQxLm1lc3NhZ2UpO1xuXG4gICAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQobnVsbCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxudmFyIHZhbHVlU3RhY2sgPSBbXTtcbnZhciBmaWJlclN0YWNrO1xuXG57XG4gIGZpYmVyU3RhY2sgPSBbXTtcbn1cblxudmFyIGluZGV4ID0gLTE7XG5cbmZ1bmN0aW9uIGNyZWF0ZUN1cnNvcihkZWZhdWx0VmFsdWUpIHtcbiAgcmV0dXJuIHtcbiAgICBjdXJyZW50OiBkZWZhdWx0VmFsdWVcbiAgfTtcbn1cblxuZnVuY3Rpb24gcG9wKGN1cnNvciwgZmliZXIpIHtcbiAgaWYgKGluZGV4IDwgMCkge1xuICAgIHtcbiAgICAgIGVycm9yKCdVbmV4cGVjdGVkIHBvcC4nKTtcbiAgICB9XG5cbiAgICByZXR1cm47XG4gIH1cblxuICB7XG4gICAgaWYgKGZpYmVyICE9PSBmaWJlclN0YWNrW2luZGV4XSkge1xuICAgICAgZXJyb3IoJ1VuZXhwZWN0ZWQgRmliZXIgcG9wcGVkLicpO1xuICAgIH1cbiAgfVxuXG4gIGN1cnNvci5jdXJyZW50ID0gdmFsdWVTdGFja1tpbmRleF07XG4gIHZhbHVlU3RhY2tbaW5kZXhdID0gbnVsbDtcblxuICB7XG4gICAgZmliZXJTdGFja1tpbmRleF0gPSBudWxsO1xuICB9XG5cbiAgaW5kZXgtLTtcbn1cblxuZnVuY3Rpb24gcHVzaChjdXJzb3IsIHZhbHVlLCBmaWJlcikge1xuICBpbmRleCsrO1xuICB2YWx1ZVN0YWNrW2luZGV4XSA9IGN1cnNvci5jdXJyZW50O1xuXG4gIHtcbiAgICBmaWJlclN0YWNrW2luZGV4XSA9IGZpYmVyO1xuICB9XG5cbiAgY3Vyc29yLmN1cnJlbnQgPSB2YWx1ZTtcbn1cblxudmFyIHdhcm5lZEFib3V0TWlzc2luZ0dldENoaWxkQ29udGV4dDtcblxue1xuICB3YXJuZWRBYm91dE1pc3NpbmdHZXRDaGlsZENvbnRleHQgPSB7fTtcbn1cblxudmFyIGVtcHR5Q29udGV4dE9iamVjdCA9IHt9O1xuXG57XG4gIE9iamVjdC5mcmVlemUoZW1wdHlDb250ZXh0T2JqZWN0KTtcbn0gLy8gQSBjdXJzb3IgdG8gdGhlIGN1cnJlbnQgbWVyZ2VkIGNvbnRleHQgb2JqZWN0IG9uIHRoZSBzdGFjay5cblxuXG52YXIgY29udGV4dFN0YWNrQ3Vyc29yID0gY3JlYXRlQ3Vyc29yKGVtcHR5Q29udGV4dE9iamVjdCk7IC8vIEEgY3Vyc29yIHRvIGEgYm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIGNvbnRleHQgaGFzIGNoYW5nZWQuXG5cbnZhciBkaWRQZXJmb3JtV29ya1N0YWNrQ3Vyc29yID0gY3JlYXRlQ3Vyc29yKGZhbHNlKTsgLy8gS2VlcCB0cmFjayBvZiB0aGUgcHJldmlvdXMgY29udGV4dCBvYmplY3QgdGhhdCB3YXMgb24gdGhlIHN0YWNrLlxuLy8gV2UgdXNlIHRoaXMgdG8gZ2V0IGFjY2VzcyB0byB0aGUgcGFyZW50IGNvbnRleHQgYWZ0ZXIgd2UgaGF2ZSBhbHJlYWR5XG4vLyBwdXNoZWQgdGhlIG5leHQgY29udGV4dCBwcm92aWRlciwgYW5kIG5vdyBuZWVkIHRvIG1lcmdlIHRoZWlyIGNvbnRleHRzLlxuXG52YXIgcHJldmlvdXNDb250ZXh0ID0gZW1wdHlDb250ZXh0T2JqZWN0O1xuXG5mdW5jdGlvbiBnZXRVbm1hc2tlZENvbnRleHQod29ya0luUHJvZ3Jlc3MsIENvbXBvbmVudCwgZGlkUHVzaE93bkNvbnRleHRJZlByb3ZpZGVyKSB7XG4gIHtcbiAgICBpZiAoZGlkUHVzaE93bkNvbnRleHRJZlByb3ZpZGVyICYmIGlzQ29udGV4dFByb3ZpZGVyKENvbXBvbmVudCkpIHtcbiAgICAgIC8vIElmIHRoZSBmaWJlciBpcyBhIGNvbnRleHQgcHJvdmlkZXIgaXRzZWxmLCB3aGVuIHdlIHJlYWQgaXRzIGNvbnRleHRcbiAgICAgIC8vIHdlIG1heSBoYXZlIGFscmVhZHkgcHVzaGVkIGl0cyBvd24gY2hpbGQgY29udGV4dCBvbiB0aGUgc3RhY2suIEEgY29udGV4dFxuICAgICAgLy8gcHJvdmlkZXIgc2hvdWxkIG5vdCBcInNlZVwiIGl0cyBvd24gY2hpbGQgY29udGV4dC4gVGhlcmVmb3JlIHdlIHJlYWQgdGhlXG4gICAgICAvLyBwcmV2aW91cyAocGFyZW50KSBjb250ZXh0IGluc3RlYWQgZm9yIGEgY29udGV4dCBwcm92aWRlci5cbiAgICAgIHJldHVybiBwcmV2aW91c0NvbnRleHQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNvbnRleHRTdGFja0N1cnNvci5jdXJyZW50O1xuICB9XG59XG5cbmZ1bmN0aW9uIGNhY2hlQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgdW5tYXNrZWRDb250ZXh0LCBtYXNrZWRDb250ZXh0KSB7XG4gIHtcbiAgICB2YXIgaW5zdGFuY2UgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG4gICAgaW5zdGFuY2UuX19yZWFjdEludGVybmFsTWVtb2l6ZWRVbm1hc2tlZENoaWxkQ29udGV4dCA9IHVubWFza2VkQ29udGV4dDtcbiAgICBpbnN0YW5jZS5fX3JlYWN0SW50ZXJuYWxNZW1vaXplZE1hc2tlZENoaWxkQ29udGV4dCA9IG1hc2tlZENvbnRleHQ7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0TWFza2VkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgdW5tYXNrZWRDb250ZXh0KSB7XG4gIHtcbiAgICB2YXIgdHlwZSA9IHdvcmtJblByb2dyZXNzLnR5cGU7XG4gICAgdmFyIGNvbnRleHRUeXBlcyA9IHR5cGUuY29udGV4dFR5cGVzO1xuXG4gICAgaWYgKCFjb250ZXh0VHlwZXMpIHtcbiAgICAgIHJldHVybiBlbXB0eUNvbnRleHRPYmplY3Q7XG4gICAgfSAvLyBBdm9pZCByZWNyZWF0aW5nIG1hc2tlZCBjb250ZXh0IHVubGVzcyB1bm1hc2tlZCBjb250ZXh0IGhhcyBjaGFuZ2VkLlxuICAgIC8vIEZhaWxpbmcgdG8gZG8gdGhpcyB3aWxsIHJlc3VsdCBpbiB1bm5lY2Vzc2FyeSBjYWxscyB0byBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzLlxuICAgIC8vIFRoaXMgbWF5IHRyaWdnZXIgaW5maW5pdGUgbG9vcHMgaWYgY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyBjYWxscyBzZXRTdGF0ZS5cblxuXG4gICAgdmFyIGluc3RhbmNlID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuXG4gICAgaWYgKGluc3RhbmNlICYmIGluc3RhbmNlLl9fcmVhY3RJbnRlcm5hbE1lbW9pemVkVW5tYXNrZWRDaGlsZENvbnRleHQgPT09IHVubWFza2VkQ29udGV4dCkge1xuICAgICAgcmV0dXJuIGluc3RhbmNlLl9fcmVhY3RJbnRlcm5hbE1lbW9pemVkTWFza2VkQ2hpbGRDb250ZXh0O1xuICAgIH1cblxuICAgIHZhciBjb250ZXh0ID0ge307XG5cbiAgICBmb3IgKHZhciBrZXkgaW4gY29udGV4dFR5cGVzKSB7XG4gICAgICBjb250ZXh0W2tleV0gPSB1bm1hc2tlZENvbnRleHRba2V5XTtcbiAgICB9XG5cbiAgICB7XG4gICAgICB2YXIgbmFtZSA9IGdldENvbXBvbmVudE5hbWUodHlwZSkgfHwgJ1Vua25vd24nO1xuICAgICAgY2hlY2tQcm9wVHlwZXMoY29udGV4dFR5cGVzLCBjb250ZXh0LCAnY29udGV4dCcsIG5hbWUpO1xuICAgIH0gLy8gQ2FjaGUgdW5tYXNrZWQgY29udGV4dCBzbyB3ZSBjYW4gYXZvaWQgcmVjcmVhdGluZyBtYXNrZWQgY29udGV4dCB1bmxlc3MgbmVjZXNzYXJ5LlxuICAgIC8vIENvbnRleHQgaXMgY3JlYXRlZCBiZWZvcmUgdGhlIGNsYXNzIGNvbXBvbmVudCBpcyBpbnN0YW50aWF0ZWQgc28gY2hlY2sgZm9yIGluc3RhbmNlLlxuXG5cbiAgICBpZiAoaW5zdGFuY2UpIHtcbiAgICAgIGNhY2hlQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgdW5tYXNrZWRDb250ZXh0LCBjb250ZXh0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gY29udGV4dDtcbiAgfVxufVxuXG5mdW5jdGlvbiBoYXNDb250ZXh0Q2hhbmdlZCgpIHtcbiAge1xuICAgIHJldHVybiBkaWRQZXJmb3JtV29ya1N0YWNrQ3Vyc29yLmN1cnJlbnQ7XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNDb250ZXh0UHJvdmlkZXIodHlwZSkge1xuICB7XG4gICAgdmFyIGNoaWxkQ29udGV4dFR5cGVzID0gdHlwZS5jaGlsZENvbnRleHRUeXBlcztcbiAgICByZXR1cm4gY2hpbGRDb250ZXh0VHlwZXMgIT09IG51bGwgJiYgY2hpbGRDb250ZXh0VHlwZXMgIT09IHVuZGVmaW5lZDtcbiAgfVxufVxuXG5mdW5jdGlvbiBwb3BDb250ZXh0KGZpYmVyKSB7XG4gIHtcbiAgICBwb3AoZGlkUGVyZm9ybVdvcmtTdGFja0N1cnNvciwgZmliZXIpO1xuICAgIHBvcChjb250ZXh0U3RhY2tDdXJzb3IsIGZpYmVyKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwb3BUb3BMZXZlbENvbnRleHRPYmplY3QoZmliZXIpIHtcbiAge1xuICAgIHBvcChkaWRQZXJmb3JtV29ya1N0YWNrQ3Vyc29yLCBmaWJlcik7XG4gICAgcG9wKGNvbnRleHRTdGFja0N1cnNvciwgZmliZXIpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHB1c2hUb3BMZXZlbENvbnRleHRPYmplY3QoZmliZXIsIGNvbnRleHQsIGRpZENoYW5nZSkge1xuICB7XG4gICAgaWYgKCEoY29udGV4dFN0YWNrQ3Vyc29yLmN1cnJlbnQgPT09IGVtcHR5Q29udGV4dE9iamVjdCkpIHtcbiAgICAgIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoIFwiVW5leHBlY3RlZCBjb250ZXh0IGZvdW5kIG9uIHN0YWNrLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcHVzaChjb250ZXh0U3RhY2tDdXJzb3IsIGNvbnRleHQsIGZpYmVyKTtcbiAgICBwdXNoKGRpZFBlcmZvcm1Xb3JrU3RhY2tDdXJzb3IsIGRpZENoYW5nZSwgZmliZXIpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NDaGlsZENvbnRleHQoZmliZXIsIHR5cGUsIHBhcmVudENvbnRleHQpIHtcbiAge1xuICAgIHZhciBpbnN0YW5jZSA9IGZpYmVyLnN0YXRlTm9kZTtcbiAgICB2YXIgY2hpbGRDb250ZXh0VHlwZXMgPSB0eXBlLmNoaWxkQ29udGV4dFR5cGVzOyAvLyBUT0RPIChidmF1Z2huKSBSZXBsYWNlIHRoaXMgYmVoYXZpb3Igd2l0aCBhbiBpbnZhcmlhbnQoKSBpbiB0aGUgZnV0dXJlLlxuICAgIC8vIEl0IGhhcyBvbmx5IGJlZW4gYWRkZWQgaW4gRmliZXIgdG8gbWF0Y2ggdGhlICh1bmludGVudGlvbmFsKSBiZWhhdmlvciBpbiBTdGFjay5cblxuICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuZ2V0Q2hpbGRDb250ZXh0ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB7XG4gICAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZSh0eXBlKSB8fCAnVW5rbm93bic7XG5cbiAgICAgICAgaWYgKCF3YXJuZWRBYm91dE1pc3NpbmdHZXRDaGlsZENvbnRleHRbY29tcG9uZW50TmFtZV0pIHtcbiAgICAgICAgICB3YXJuZWRBYm91dE1pc3NpbmdHZXRDaGlsZENvbnRleHRbY29tcG9uZW50TmFtZV0gPSB0cnVlO1xuXG4gICAgICAgICAgZXJyb3IoJyVzLmNoaWxkQ29udGV4dFR5cGVzIGlzIHNwZWNpZmllZCBidXQgdGhlcmUgaXMgbm8gZ2V0Q2hpbGRDb250ZXh0KCkgbWV0aG9kICcgKyAnb24gdGhlIGluc3RhbmNlLiBZb3UgY2FuIGVpdGhlciBkZWZpbmUgZ2V0Q2hpbGRDb250ZXh0KCkgb24gJXMgb3IgcmVtb3ZlICcgKyAnY2hpbGRDb250ZXh0VHlwZXMgZnJvbSBpdC4nLCBjb21wb25lbnROYW1lLCBjb21wb25lbnROYW1lKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcGFyZW50Q29udGV4dDtcbiAgICB9XG5cbiAgICB2YXIgY2hpbGRDb250ZXh0ID0gaW5zdGFuY2UuZ2V0Q2hpbGRDb250ZXh0KCk7XG5cbiAgICBmb3IgKHZhciBjb250ZXh0S2V5IGluIGNoaWxkQ29udGV4dCkge1xuICAgICAgaWYgKCEoY29udGV4dEtleSBpbiBjaGlsZENvbnRleHRUeXBlcykpIHtcbiAgICAgICAge1xuICAgICAgICAgIHRocm93IEVycm9yKCAoZ2V0Q29tcG9uZW50TmFtZSh0eXBlKSB8fCAnVW5rbm93bicpICsgXCIuZ2V0Q2hpbGRDb250ZXh0KCk6IGtleSBcXFwiXCIgKyBjb250ZXh0S2V5ICsgXCJcXFwiIGlzIG5vdCBkZWZpbmVkIGluIGNoaWxkQ29udGV4dFR5cGVzLlwiICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB7XG4gICAgICB2YXIgbmFtZSA9IGdldENvbXBvbmVudE5hbWUodHlwZSkgfHwgJ1Vua25vd24nO1xuICAgICAgY2hlY2tQcm9wVHlwZXMoY2hpbGRDb250ZXh0VHlwZXMsIGNoaWxkQ29udGV4dCwgJ2NoaWxkIGNvbnRleHQnLCBuYW1lKTtcbiAgICB9XG5cbiAgICByZXR1cm4gX2Fzc2lnbih7fSwgcGFyZW50Q29udGV4dCwgY2hpbGRDb250ZXh0KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwdXNoQ29udGV4dFByb3ZpZGVyKHdvcmtJblByb2dyZXNzKSB7XG4gIHtcbiAgICB2YXIgaW5zdGFuY2UgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7IC8vIFdlIHB1c2ggdGhlIGNvbnRleHQgYXMgZWFybHkgYXMgcG9zc2libGUgdG8gZW5zdXJlIHN0YWNrIGludGVncml0eS5cbiAgICAvLyBJZiB0aGUgaW5zdGFuY2UgZG9lcyBub3QgZXhpc3QgeWV0LCB3ZSB3aWxsIHB1c2ggbnVsbCBhdCBmaXJzdCxcbiAgICAvLyBhbmQgcmVwbGFjZSBpdCBvbiB0aGUgc3RhY2sgbGF0ZXIgd2hlbiBpbnZhbGlkYXRpbmcgdGhlIGNvbnRleHQuXG5cbiAgICB2YXIgbWVtb2l6ZWRNZXJnZWRDaGlsZENvbnRleHQgPSBpbnN0YW5jZSAmJiBpbnN0YW5jZS5fX3JlYWN0SW50ZXJuYWxNZW1vaXplZE1lcmdlZENoaWxkQ29udGV4dCB8fCBlbXB0eUNvbnRleHRPYmplY3Q7IC8vIFJlbWVtYmVyIHRoZSBwYXJlbnQgY29udGV4dCBzbyB3ZSBjYW4gbWVyZ2Ugd2l0aCBpdCBsYXRlci5cbiAgICAvLyBJbmhlcml0IHRoZSBwYXJlbnQncyBkaWQtcGVyZm9ybS13b3JrIHZhbHVlIHRvIGF2b2lkIGluYWR2ZXJ0ZW50bHkgYmxvY2tpbmcgdXBkYXRlcy5cblxuICAgIHByZXZpb3VzQ29udGV4dCA9IGNvbnRleHRTdGFja0N1cnNvci5jdXJyZW50O1xuICAgIHB1c2goY29udGV4dFN0YWNrQ3Vyc29yLCBtZW1vaXplZE1lcmdlZENoaWxkQ29udGV4dCwgd29ya0luUHJvZ3Jlc3MpO1xuICAgIHB1c2goZGlkUGVyZm9ybVdvcmtTdGFja0N1cnNvciwgZGlkUGVyZm9ybVdvcmtTdGFja0N1cnNvci5jdXJyZW50LCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW52YWxpZGF0ZUNvbnRleHRQcm92aWRlcih3b3JrSW5Qcm9ncmVzcywgdHlwZSwgZGlkQ2hhbmdlKSB7XG4gIHtcbiAgICB2YXIgaW5zdGFuY2UgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG5cbiAgICBpZiAoIWluc3RhbmNlKSB7XG4gICAgICB7XG4gICAgICAgIHRocm93IEVycm9yKCBcIkV4cGVjdGVkIHRvIGhhdmUgYW4gaW5zdGFuY2UgYnkgdGhpcyBwb2ludC4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS5cIiApO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChkaWRDaGFuZ2UpIHtcbiAgICAgIC8vIE1lcmdlIHBhcmVudCBhbmQgb3duIGNvbnRleHQuXG4gICAgICAvLyBTa2lwIHRoaXMgaWYgd2UncmUgbm90IHVwZGF0aW5nIGR1ZSB0byBzQ1UuXG4gICAgICAvLyBUaGlzIGF2b2lkcyB1bm5lY2Vzc2FyaWx5IHJlY29tcHV0aW5nIG1lbW9pemVkIHZhbHVlcy5cbiAgICAgIHZhciBtZXJnZWRDb250ZXh0ID0gcHJvY2Vzc0NoaWxkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgdHlwZSwgcHJldmlvdXNDb250ZXh0KTtcbiAgICAgIGluc3RhbmNlLl9fcmVhY3RJbnRlcm5hbE1lbW9pemVkTWVyZ2VkQ2hpbGRDb250ZXh0ID0gbWVyZ2VkQ29udGV4dDsgLy8gUmVwbGFjZSB0aGUgb2xkIChvciBlbXB0eSkgY29udGV4dCB3aXRoIHRoZSBuZXcgb25lLlxuICAgICAgLy8gSXQgaXMgaW1wb3J0YW50IHRvIHVud2luZCB0aGUgY29udGV4dCBpbiB0aGUgcmV2ZXJzZSBvcmRlci5cblxuICAgICAgcG9wKGRpZFBlcmZvcm1Xb3JrU3RhY2tDdXJzb3IsIHdvcmtJblByb2dyZXNzKTtcbiAgICAgIHBvcChjb250ZXh0U3RhY2tDdXJzb3IsIHdvcmtJblByb2dyZXNzKTsgLy8gTm93IHB1c2ggdGhlIG5ldyBjb250ZXh0IGFuZCBtYXJrIHRoYXQgaXQgaGFzIGNoYW5nZWQuXG5cbiAgICAgIHB1c2goY29udGV4dFN0YWNrQ3Vyc29yLCBtZXJnZWRDb250ZXh0LCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICBwdXNoKGRpZFBlcmZvcm1Xb3JrU3RhY2tDdXJzb3IsIGRpZENoYW5nZSwgd29ya0luUHJvZ3Jlc3MpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwb3AoZGlkUGVyZm9ybVdvcmtTdGFja0N1cnNvciwgd29ya0luUHJvZ3Jlc3MpO1xuICAgICAgcHVzaChkaWRQZXJmb3JtV29ya1N0YWNrQ3Vyc29yLCBkaWRDaGFuZ2UsIHdvcmtJblByb2dyZXNzKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZmluZEN1cnJlbnRVbm1hc2tlZENvbnRleHQoZmliZXIpIHtcbiAge1xuICAgIC8vIEN1cnJlbnRseSB0aGlzIGlzIG9ubHkgdXNlZCB3aXRoIHJlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyOyBub3Qgc3VyZSBpZiBpdFxuICAgIC8vIG1ha2VzIHNlbnNlIGVsc2V3aGVyZVxuICAgIGlmICghKGlzRmliZXJNb3VudGVkKGZpYmVyKSAmJiBmaWJlci50YWcgPT09IENsYXNzQ29tcG9uZW50KSkge1xuICAgICAge1xuICAgICAgICB0aHJvdyBFcnJvciggXCJFeHBlY3RlZCBzdWJ0cmVlIHBhcmVudCB0byBiZSBhIG1vdW50ZWQgY2xhc3MgY29tcG9uZW50LiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIG5vZGUgPSBmaWJlcjtcblxuICAgIGRvIHtcbiAgICAgIHN3aXRjaCAobm9kZS50YWcpIHtcbiAgICAgICAgY2FzZSBIb3N0Um9vdDpcbiAgICAgICAgICByZXR1cm4gbm9kZS5zdGF0ZU5vZGUuY29udGV4dDtcblxuICAgICAgICBjYXNlIENsYXNzQ29tcG9uZW50OlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHZhciBDb21wb25lbnQgPSBub2RlLnR5cGU7XG5cbiAgICAgICAgICAgIGlmIChpc0NvbnRleHRQcm92aWRlcihDb21wb25lbnQpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBub2RlLnN0YXRlTm9kZS5fX3JlYWN0SW50ZXJuYWxNZW1vaXplZE1lcmdlZENoaWxkQ29udGV4dDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBub2RlID0gbm9kZS5yZXR1cm47XG4gICAgfSB3aGlsZSAobm9kZSAhPT0gbnVsbCk7XG5cbiAgICB7XG4gICAgICB7XG4gICAgICAgIHRocm93IEVycm9yKCBcIkZvdW5kIHVuZXhwZWN0ZWQgZGV0YWNoZWQgc3VidHJlZSBwYXJlbnQuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCIgKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxudmFyIExlZ2FjeVJvb3QgPSAwO1xudmFyIEJsb2NraW5nUm9vdCA9IDE7XG52YXIgQ29uY3VycmVudFJvb3QgPSAyO1xuXG52YXIgcmVuZGVyZXJJRCA9IG51bGw7XG52YXIgaW5qZWN0ZWRIb29rID0gbnVsbDtcbnZhciBoYXNMb2dnZWRFcnJvciA9IGZhbHNlO1xudmFyIGlzRGV2VG9vbHNQcmVzZW50ID0gdHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyAhPT0gJ3VuZGVmaW5lZCc7XG5mdW5jdGlvbiBpbmplY3RJbnRlcm5hbHMoaW50ZXJuYWxzKSB7XG4gIGlmICh0eXBlb2YgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fID09PSAndW5kZWZpbmVkJykge1xuICAgIC8vIE5vIERldlRvb2xzXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIGhvb2sgPSBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX187XG5cbiAgaWYgKGhvb2suaXNEaXNhYmxlZCkge1xuICAgIC8vIFRoaXMgaXNuJ3QgYSByZWFsIHByb3BlcnR5IG9uIHRoZSBob29rLCBidXQgaXQgY2FuIGJlIHNldCB0byBvcHQgb3V0XG4gICAgLy8gb2YgRGV2VG9vbHMgaW50ZWdyYXRpb24gYW5kIGFzc29jaWF0ZWQgd2FybmluZ3MgYW5kIGxvZ3MuXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8zODc3XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAoIWhvb2suc3VwcG9ydHNGaWJlcikge1xuICAgIHtcbiAgICAgIGVycm9yKCdUaGUgaW5zdGFsbGVkIHZlcnNpb24gb2YgUmVhY3QgRGV2VG9vbHMgaXMgdG9vIG9sZCBhbmQgd2lsbCBub3Qgd29yayAnICsgJ3dpdGggdGhlIGN1cnJlbnQgdmVyc2lvbiBvZiBSZWFjdC4gUGxlYXNlIHVwZGF0ZSBSZWFjdCBEZXZUb29scy4gJyArICdodHRwczovL3JlYWN0anMub3JnL2xpbmsvcmVhY3QtZGV2dG9vbHMnKTtcbiAgICB9IC8vIERldlRvb2xzIGV4aXN0cywgZXZlbiB0aG91Z2ggaXQgZG9lc24ndCBzdXBwb3J0IEZpYmVyLlxuXG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHRyeSB7XG4gICAgcmVuZGVyZXJJRCA9IGhvb2suaW5qZWN0KGludGVybmFscyk7IC8vIFdlIGhhdmUgc3VjY2Vzc2Z1bGx5IGluamVjdGVkLCBzbyBub3cgaXQgaXMgc2FmZSB0byBzZXQgdXAgaG9va3MuXG5cbiAgICBpbmplY3RlZEhvb2sgPSBob29rO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICAvLyBDYXRjaCBhbGwgZXJyb3JzIGJlY2F1c2UgaXQgaXMgdW5zYWZlIHRvIHRocm93IGR1cmluZyBpbml0aWFsaXphdGlvbi5cbiAgICB7XG4gICAgICBlcnJvcignUmVhY3QgaW5zdHJ1bWVudGF0aW9uIGVuY291bnRlcmVkIGFuIGVycm9yOiAlcy4nLCBlcnIpO1xuICAgIH1cbiAgfSAvLyBEZXZUb29scyBleGlzdHNcblxuXG4gIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gb25TY2hlZHVsZVJvb3Qocm9vdCwgY2hpbGRyZW4pIHtcbiAge1xuICAgIGlmIChpbmplY3RlZEhvb2sgJiYgdHlwZW9mIGluamVjdGVkSG9vay5vblNjaGVkdWxlRmliZXJSb290ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0cnkge1xuICAgICAgICBpbmplY3RlZEhvb2sub25TY2hlZHVsZUZpYmVyUm9vdChyZW5kZXJlcklELCByb290LCBjaGlsZHJlbik7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgaWYgKCAhaGFzTG9nZ2VkRXJyb3IpIHtcbiAgICAgICAgICBoYXNMb2dnZWRFcnJvciA9IHRydWU7XG5cbiAgICAgICAgICBlcnJvcignUmVhY3QgaW5zdHJ1bWVudGF0aW9uIGVuY291bnRlcmVkIGFuIGVycm9yOiAlcycsIGVycik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIG9uQ29tbWl0Um9vdChyb290LCBwcmlvcml0eUxldmVsKSB7XG4gIGlmIChpbmplY3RlZEhvb2sgJiYgdHlwZW9mIGluamVjdGVkSG9vay5vbkNvbW1pdEZpYmVyUm9vdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHRyeSB7XG4gICAgICB2YXIgZGlkRXJyb3IgPSAocm9vdC5jdXJyZW50LmZsYWdzICYgRGlkQ2FwdHVyZSkgPT09IERpZENhcHR1cmU7XG5cbiAgICAgIGlmIChlbmFibGVQcm9maWxlclRpbWVyKSB7XG4gICAgICAgIGluamVjdGVkSG9vay5vbkNvbW1pdEZpYmVyUm9vdChyZW5kZXJlcklELCByb290LCBwcmlvcml0eUxldmVsLCBkaWRFcnJvcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbmplY3RlZEhvb2sub25Db21taXRGaWJlclJvb3QocmVuZGVyZXJJRCwgcm9vdCwgdW5kZWZpbmVkLCBkaWRFcnJvcik7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICB7XG4gICAgICAgIGlmICghaGFzTG9nZ2VkRXJyb3IpIHtcbiAgICAgICAgICBoYXNMb2dnZWRFcnJvciA9IHRydWU7XG5cbiAgICAgICAgICBlcnJvcignUmVhY3QgaW5zdHJ1bWVudGF0aW9uIGVuY291bnRlcmVkIGFuIGVycm9yOiAlcycsIGVycik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIG9uQ29tbWl0VW5tb3VudChmaWJlcikge1xuICBpZiAoaW5qZWN0ZWRIb29rICYmIHR5cGVvZiBpbmplY3RlZEhvb2sub25Db21taXRGaWJlclVubW91bnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICB0cnkge1xuICAgICAgaW5qZWN0ZWRIb29rLm9uQ29tbWl0RmliZXJVbm1vdW50KHJlbmRlcmVySUQsIGZpYmVyKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHtcbiAgICAgICAgaWYgKCFoYXNMb2dnZWRFcnJvcikge1xuICAgICAgICAgIGhhc0xvZ2dlZEVycm9yID0gdHJ1ZTtcblxuICAgICAgICAgIGVycm9yKCdSZWFjdCBpbnN0cnVtZW50YXRpb24gZW5jb3VudGVyZWQgYW4gZXJyb3I6ICVzJywgZXJyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG52YXIgU2NoZWR1bGVyX3J1bldpdGhQcmlvcml0eSA9IFNjaGVkdWxlci51bnN0YWJsZV9ydW5XaXRoUHJpb3JpdHksXG4gICAgU2NoZWR1bGVyX3NjaGVkdWxlQ2FsbGJhY2sgPSBTY2hlZHVsZXIudW5zdGFibGVfc2NoZWR1bGVDYWxsYmFjayxcbiAgICBTY2hlZHVsZXJfY2FuY2VsQ2FsbGJhY2sgPSBTY2hlZHVsZXIudW5zdGFibGVfY2FuY2VsQ2FsbGJhY2ssXG4gICAgU2NoZWR1bGVyX3Nob3VsZFlpZWxkID0gU2NoZWR1bGVyLnVuc3RhYmxlX3Nob3VsZFlpZWxkLFxuICAgIFNjaGVkdWxlcl9yZXF1ZXN0UGFpbnQgPSBTY2hlZHVsZXIudW5zdGFibGVfcmVxdWVzdFBhaW50LFxuICAgIFNjaGVkdWxlcl9ub3ckMSA9IFNjaGVkdWxlci51bnN0YWJsZV9ub3csXG4gICAgU2NoZWR1bGVyX2dldEN1cnJlbnRQcmlvcml0eUxldmVsID0gU2NoZWR1bGVyLnVuc3RhYmxlX2dldEN1cnJlbnRQcmlvcml0eUxldmVsLFxuICAgIFNjaGVkdWxlcl9JbW1lZGlhdGVQcmlvcml0eSA9IFNjaGVkdWxlci51bnN0YWJsZV9JbW1lZGlhdGVQcmlvcml0eSxcbiAgICBTY2hlZHVsZXJfVXNlckJsb2NraW5nUHJpb3JpdHkgPSBTY2hlZHVsZXIudW5zdGFibGVfVXNlckJsb2NraW5nUHJpb3JpdHksXG4gICAgU2NoZWR1bGVyX05vcm1hbFByaW9yaXR5ID0gU2NoZWR1bGVyLnVuc3RhYmxlX05vcm1hbFByaW9yaXR5LFxuICAgIFNjaGVkdWxlcl9Mb3dQcmlvcml0eSA9IFNjaGVkdWxlci51bnN0YWJsZV9Mb3dQcmlvcml0eSxcbiAgICBTY2hlZHVsZXJfSWRsZVByaW9yaXR5ID0gU2NoZWR1bGVyLnVuc3RhYmxlX0lkbGVQcmlvcml0eTtcblxue1xuICAvLyBQcm92aWRlIGV4cGxpY2l0IGVycm9yIG1lc3NhZ2Ugd2hlbiBwcm9kdWN0aW9uK3Byb2ZpbGluZyBidW5kbGUgb2YgZS5nLlxuICAvLyByZWFjdC1kb20gaXMgdXNlZCB3aXRoIHByb2R1Y3Rpb24gKG5vbi1wcm9maWxpbmcpIGJ1bmRsZSBvZlxuICAvLyBzY2hlZHVsZXIvdHJhY2luZ1xuICBpZiAoISh0cmFjaW5nLl9faW50ZXJhY3Rpb25zUmVmICE9IG51bGwgJiYgdHJhY2luZy5fX2ludGVyYWN0aW9uc1JlZi5jdXJyZW50ICE9IG51bGwpKSB7XG4gICAge1xuICAgICAgdGhyb3cgRXJyb3IoIFwiSXQgaXMgbm90IHN1cHBvcnRlZCB0byBydW4gdGhlIHByb2ZpbGluZyB2ZXJzaW9uIG9mIGEgcmVuZGVyZXIgKGZvciBleGFtcGxlLCBgcmVhY3QtZG9tL3Byb2ZpbGluZ2ApIHdpdGhvdXQgYWxzbyByZXBsYWNpbmcgdGhlIGBzY2hlZHVsZXIvdHJhY2luZ2AgbW9kdWxlIHdpdGggYHNjaGVkdWxlci90cmFjaW5nLXByb2ZpbGluZ2AuIFlvdXIgYnVuZGxlciBtaWdodCBoYXZlIGEgc2V0dGluZyBmb3IgYWxpYXNpbmcgYm90aCBtb2R1bGVzLiBMZWFybiBtb3JlIGF0IGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9wcm9maWxpbmdcIiApO1xuICAgIH1cbiAgfVxufVxuXG52YXIgZmFrZUNhbGxiYWNrTm9kZSA9IHt9OyAvLyBFeGNlcHQgZm9yIE5vUHJpb3JpdHksIHRoZXNlIGNvcnJlc3BvbmQgdG8gU2NoZWR1bGVyIHByaW9yaXRpZXMuIFdlIHVzZVxuLy8gYXNjZW5kaW5nIG51bWJlcnMgc28gd2UgY2FuIGNvbXBhcmUgdGhlbSBsaWtlIG51bWJlcnMuIFRoZXkgc3RhcnQgYXQgOTAgdG9cbi8vIGF2b2lkIGNsYXNoaW5nIHdpdGggU2NoZWR1bGVyJ3MgcHJpb3JpdGllcy5cblxudmFyIEltbWVkaWF0ZVByaW9yaXR5JDEgPSA5OTtcbnZhciBVc2VyQmxvY2tpbmdQcmlvcml0eSQyID0gOTg7XG52YXIgTm9ybWFsUHJpb3JpdHkkMSA9IDk3O1xudmFyIExvd1ByaW9yaXR5JDEgPSA5NjtcbnZhciBJZGxlUHJpb3JpdHkkMSA9IDk1OyAvLyBOb1ByaW9yaXR5IGlzIHRoZSBhYnNlbmNlIG9mIHByaW9yaXR5LiBBbHNvIFJlYWN0LW9ubHkuXG5cbnZhciBOb1ByaW9yaXR5JDEgPSA5MDtcbnZhciBzaG91bGRZaWVsZCA9IFNjaGVkdWxlcl9zaG91bGRZaWVsZDtcbnZhciByZXF1ZXN0UGFpbnQgPSAvLyBGYWxsIGJhY2sgZ3JhY2VmdWxseSBpZiB3ZSdyZSBydW5uaW5nIGFuIG9sZGVyIHZlcnNpb24gb2YgU2NoZWR1bGVyLlxuU2NoZWR1bGVyX3JlcXVlc3RQYWludCAhPT0gdW5kZWZpbmVkID8gU2NoZWR1bGVyX3JlcXVlc3RQYWludCA6IGZ1bmN0aW9uICgpIHt9O1xudmFyIHN5bmNRdWV1ZSA9IG51bGw7XG52YXIgaW1tZWRpYXRlUXVldWVDYWxsYmFja05vZGUgPSBudWxsO1xudmFyIGlzRmx1c2hpbmdTeW5jUXVldWUgPSBmYWxzZTtcbnZhciBpbml0aWFsVGltZU1zJDEgPSBTY2hlZHVsZXJfbm93JDEoKTsgLy8gSWYgdGhlIGluaXRpYWwgdGltZXN0YW1wIGlzIHJlYXNvbmFibHkgc21hbGwsIHVzZSBTY2hlZHVsZXIncyBgbm93YCBkaXJlY3RseS5cbi8vIFRoaXMgd2lsbCBiZSB0aGUgY2FzZSBmb3IgbW9kZXJuIGJyb3dzZXJzIHRoYXQgc3VwcG9ydCBgcGVyZm9ybWFuY2Uubm93YC4gSW5cbi8vIG9sZGVyIGJyb3dzZXJzLCBTY2hlZHVsZXIgZmFsbHMgYmFjayB0byBgRGF0ZS5ub3dgLCB3aGljaCByZXR1cm5zIGEgVW5peFxuLy8gdGltZXN0YW1wLiBJbiB0aGF0IGNhc2UsIHN1YnRyYWN0IHRoZSBtb2R1bGUgaW5pdGlhbGl6YXRpb24gdGltZSB0byBzaW11bGF0ZVxuLy8gdGhlIGJlaGF2aW9yIG9mIHBlcmZvcm1hbmNlLm5vdyBhbmQga2VlcCBvdXIgdGltZXMgc21hbGwgZW5vdWdoIHRvIGZpdFxuLy8gd2l0aGluIDMyIGJpdHMuXG4vLyBUT0RPOiBDb25zaWRlciBsaWZ0aW5nIHRoaXMgaW50byBTY2hlZHVsZXIuXG5cbnZhciBub3cgPSBpbml0aWFsVGltZU1zJDEgPCAxMDAwMCA/IFNjaGVkdWxlcl9ub3ckMSA6IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIFNjaGVkdWxlcl9ub3ckMSgpIC0gaW5pdGlhbFRpbWVNcyQxO1xufTtcbmZ1bmN0aW9uIGdldEN1cnJlbnRQcmlvcml0eUxldmVsKCkge1xuICBzd2l0Y2ggKFNjaGVkdWxlcl9nZXRDdXJyZW50UHJpb3JpdHlMZXZlbCgpKSB7XG4gICAgY2FzZSBTY2hlZHVsZXJfSW1tZWRpYXRlUHJpb3JpdHk6XG4gICAgICByZXR1cm4gSW1tZWRpYXRlUHJpb3JpdHkkMTtcblxuICAgIGNhc2UgU2NoZWR1bGVyX1VzZXJCbG9ja2luZ1ByaW9yaXR5OlxuICAgICAgcmV0dXJuIFVzZXJCbG9ja2luZ1ByaW9yaXR5JDI7XG5cbiAgICBjYXNlIFNjaGVkdWxlcl9Ob3JtYWxQcmlvcml0eTpcbiAgICAgIHJldHVybiBOb3JtYWxQcmlvcml0eSQxO1xuXG4gICAgY2FzZSBTY2hlZHVsZXJfTG93UHJpb3JpdHk6XG4gICAgICByZXR1cm4gTG93UHJpb3JpdHkkMTtcblxuICAgIGNhc2UgU2NoZWR1bGVyX0lkbGVQcmlvcml0eTpcbiAgICAgIHJldHVybiBJZGxlUHJpb3JpdHkkMTtcblxuICAgIGRlZmF1bHQ6XG4gICAgICB7XG4gICAgICAgIHtcbiAgICAgICAgICB0aHJvdyBFcnJvciggXCJVbmtub3duIHByaW9yaXR5IGxldmVsLlwiICk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICB9XG59XG5cbmZ1bmN0aW9uIHJlYWN0UHJpb3JpdHlUb1NjaGVkdWxlclByaW9yaXR5KHJlYWN0UHJpb3JpdHlMZXZlbCkge1xuICBzd2l0Y2ggKHJlYWN0UHJpb3JpdHlMZXZlbCkge1xuICAgIGNhc2UgSW1tZWRpYXRlUHJpb3JpdHkkMTpcbiAgICAgIHJldHVybiBTY2hlZHVsZXJfSW1tZWRpYXRlUHJpb3JpdHk7XG5cbiAgICBjYXNlIFVzZXJCbG9ja2luZ1ByaW9yaXR5JDI6XG4gICAgICByZXR1cm4gU2NoZWR1bGVyX1VzZXJCbG9ja2luZ1ByaW9yaXR5O1xuXG4gICAgY2FzZSBOb3JtYWxQcmlvcml0eSQxOlxuICAgICAgcmV0dXJuIFNjaGVkdWxlcl9Ob3JtYWxQcmlvcml0eTtcblxuICAgIGNhc2UgTG93UHJpb3JpdHkkMTpcbiAgICAgIHJldHVybiBTY2hlZHVsZXJfTG93UHJpb3JpdHk7XG5cbiAgICBjYXNlIElkbGVQcmlvcml0eSQxOlxuICAgICAgcmV0dXJuIFNjaGVkdWxlcl9JZGxlUHJpb3JpdHk7XG5cbiAgICBkZWZhdWx0OlxuICAgICAge1xuICAgICAgICB7XG4gICAgICAgICAgdGhyb3cgRXJyb3IoIFwiVW5rbm93biBwcmlvcml0eSBsZXZlbC5cIiApO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgfVxufVxuXG5mdW5jdGlvbiBydW5XaXRoUHJpb3JpdHkkMShyZWFjdFByaW9yaXR5TGV2ZWwsIGZuKSB7XG4gIHZhciBwcmlvcml0eUxldmVsID0gcmVhY3RQcmlvcml0eVRvU2NoZWR1bGVyUHJpb3JpdHkocmVhY3RQcmlvcml0eUxldmVsKTtcbiAgcmV0dXJuIFNjaGVkdWxlcl9ydW5XaXRoUHJpb3JpdHkocHJpb3JpdHlMZXZlbCwgZm4pO1xufVxuZnVuY3Rpb24gc2NoZWR1bGVDYWxsYmFjayhyZWFjdFByaW9yaXR5TGV2ZWwsIGNhbGxiYWNrLCBvcHRpb25zKSB7XG4gIHZhciBwcmlvcml0eUxldmVsID0gcmVhY3RQcmlvcml0eVRvU2NoZWR1bGVyUHJpb3JpdHkocmVhY3RQcmlvcml0eUxldmVsKTtcbiAgcmV0dXJuIFNjaGVkdWxlcl9zY2hlZHVsZUNhbGxiYWNrKHByaW9yaXR5TGV2ZWwsIGNhbGxiYWNrLCBvcHRpb25zKTtcbn1cbmZ1bmN0aW9uIHNjaGVkdWxlU3luY0NhbGxiYWNrKGNhbGxiYWNrKSB7XG4gIC8vIFB1c2ggdGhpcyBjYWxsYmFjayBpbnRvIGFuIGludGVybmFsIHF1ZXVlLiBXZSdsbCBmbHVzaCB0aGVzZSBlaXRoZXIgaW5cbiAgLy8gdGhlIG5leHQgdGljaywgb3IgZWFybGllciBpZiBzb21ldGhpbmcgY2FsbHMgYGZsdXNoU3luY0NhbGxiYWNrUXVldWVgLlxuICBpZiAoc3luY1F1ZXVlID09PSBudWxsKSB7XG4gICAgc3luY1F1ZXVlID0gW2NhbGxiYWNrXTsgLy8gRmx1c2ggdGhlIHF1ZXVlIGluIHRoZSBuZXh0IHRpY2ssIGF0IHRoZSBlYXJsaWVzdC5cblxuICAgIGltbWVkaWF0ZVF1ZXVlQ2FsbGJhY2tOb2RlID0gU2NoZWR1bGVyX3NjaGVkdWxlQ2FsbGJhY2soU2NoZWR1bGVyX0ltbWVkaWF0ZVByaW9yaXR5LCBmbHVzaFN5bmNDYWxsYmFja1F1ZXVlSW1wbCk7XG4gIH0gZWxzZSB7XG4gICAgLy8gUHVzaCBvbnRvIGV4aXN0aW5nIHF1ZXVlLiBEb24ndCBuZWVkIHRvIHNjaGVkdWxlIGEgY2FsbGJhY2sgYmVjYXVzZVxuICAgIC8vIHdlIGFscmVhZHkgc2NoZWR1bGVkIG9uZSB3aGVuIHdlIGNyZWF0ZWQgdGhlIHF1ZXVlLlxuICAgIHN5bmNRdWV1ZS5wdXNoKGNhbGxiYWNrKTtcbiAgfVxuXG4gIHJldHVybiBmYWtlQ2FsbGJhY2tOb2RlO1xufVxuZnVuY3Rpb24gY2FuY2VsQ2FsbGJhY2soY2FsbGJhY2tOb2RlKSB7XG4gIGlmIChjYWxsYmFja05vZGUgIT09IGZha2VDYWxsYmFja05vZGUpIHtcbiAgICBTY2hlZHVsZXJfY2FuY2VsQ2FsbGJhY2soY2FsbGJhY2tOb2RlKTtcbiAgfVxufVxuZnVuY3Rpb24gZmx1c2hTeW5jQ2FsbGJhY2tRdWV1ZSgpIHtcbiAgaWYgKGltbWVkaWF0ZVF1ZXVlQ2FsbGJhY2tOb2RlICE9PSBudWxsKSB7XG4gICAgdmFyIG5vZGUgPSBpbW1lZGlhdGVRdWV1ZUNhbGxiYWNrTm9kZTtcbiAgICBpbW1lZGlhdGVRdWV1ZUNhbGxiYWNrTm9kZSA9IG51bGw7XG4gICAgU2NoZWR1bGVyX2NhbmNlbENhbGxiYWNrKG5vZGUpO1xuICB9XG5cbiAgZmx1c2hTeW5jQ2FsbGJhY2tRdWV1ZUltcGwoKTtcbn1cblxuZnVuY3Rpb24gZmx1c2hTeW5jQ2FsbGJhY2tRdWV1ZUltcGwoKSB7XG4gIGlmICghaXNGbHVzaGluZ1N5bmNRdWV1ZSAmJiBzeW5jUXVldWUgIT09IG51bGwpIHtcbiAgICAvLyBQcmV2ZW50IHJlLWVudHJhbmN5LlxuICAgIGlzRmx1c2hpbmdTeW5jUXVldWUgPSB0cnVlO1xuICAgIHZhciBpID0gMDtcblxuICAgIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciBfaXNTeW5jMiA9IHRydWU7XG4gICAgICAgIHZhciBfcXVldWUgPSBzeW5jUXVldWU7XG4gICAgICAgIHJ1bldpdGhQcmlvcml0eSQxKEltbWVkaWF0ZVByaW9yaXR5JDEsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBmb3IgKDsgaSA8IF9xdWV1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGNhbGxiYWNrID0gX3F1ZXVlW2ldO1xuXG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgIGNhbGxiYWNrID0gY2FsbGJhY2soX2lzU3luYzIpO1xuICAgICAgICAgICAgfSB3aGlsZSAoY2FsbGJhY2sgIT09IG51bGwpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHN5bmNRdWV1ZSA9IG51bGw7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAvLyBJZiBzb21ldGhpbmcgdGhyb3dzLCBsZWF2ZSB0aGUgcmVtYWluaW5nIGNhbGxiYWNrcyBvbiB0aGUgcXVldWUuXG4gICAgICAgIGlmIChzeW5jUXVldWUgIT09IG51bGwpIHtcbiAgICAgICAgICBzeW5jUXVldWUgPSBzeW5jUXVldWUuc2xpY2UoaSArIDEpO1xuICAgICAgICB9IC8vIFJlc3VtZSBmbHVzaGluZyBpbiB0aGUgbmV4dCB0aWNrXG5cblxuICAgICAgICBTY2hlZHVsZXJfc2NoZWR1bGVDYWxsYmFjayhTY2hlZHVsZXJfSW1tZWRpYXRlUHJpb3JpdHksIGZsdXNoU3luY0NhbGxiYWNrUXVldWUpO1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGlzRmx1c2hpbmdTeW5jUXVldWUgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLy8gVE9ETzogdGhpcyBpcyBzcGVjaWFsIGJlY2F1c2UgaXQgZ2V0cyBpbXBvcnRlZCBkdXJpbmcgYnVpbGQuXG52YXIgUmVhY3RWZXJzaW9uID0gJzE3LjAuMic7XG5cbnZhciBOb01vZGUgPSAwO1xudmFyIFN0cmljdE1vZGUgPSAxOyAvLyBUT0RPOiBSZW1vdmUgQmxvY2tpbmdNb2RlIGFuZCBDb25jdXJyZW50TW9kZSBieSByZWFkaW5nIGZyb20gdGhlIHJvb3Rcbi8vIHRhZyBpbnN0ZWFkXG5cbnZhciBCbG9ja2luZ01vZGUgPSAyO1xudmFyIENvbmN1cnJlbnRNb2RlID0gNDtcbnZhciBQcm9maWxlTW9kZSA9IDg7XG52YXIgRGVidWdUcmFjaW5nTW9kZSA9IDE2O1xuXG52YXIgUmVhY3RDdXJyZW50QmF0Y2hDb25maWcgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdEN1cnJlbnRCYXRjaENvbmZpZztcbnZhciBOb1RyYW5zaXRpb24gPSAwO1xuZnVuY3Rpb24gcmVxdWVzdEN1cnJlbnRUcmFuc2l0aW9uKCkge1xuICByZXR1cm4gUmVhY3RDdXJyZW50QmF0Y2hDb25maWcudHJhbnNpdGlvbjtcbn1cblxudmFyIFJlYWN0U3RyaWN0TW9kZVdhcm5pbmdzID0ge1xuICByZWNvcmRVbnNhZmVMaWZlY3ljbGVXYXJuaW5nczogZnVuY3Rpb24gKGZpYmVyLCBpbnN0YW5jZSkge30sXG4gIGZsdXNoUGVuZGluZ1Vuc2FmZUxpZmVjeWNsZVdhcm5pbmdzOiBmdW5jdGlvbiAoKSB7fSxcbiAgcmVjb3JkTGVnYWN5Q29udGV4dFdhcm5pbmc6IGZ1bmN0aW9uIChmaWJlciwgaW5zdGFuY2UpIHt9LFxuICBmbHVzaExlZ2FjeUNvbnRleHRXYXJuaW5nOiBmdW5jdGlvbiAoKSB7fSxcbiAgZGlzY2FyZFBlbmRpbmdXYXJuaW5nczogZnVuY3Rpb24gKCkge31cbn07XG5cbntcbiAgdmFyIGZpbmRTdHJpY3RSb290ID0gZnVuY3Rpb24gKGZpYmVyKSB7XG4gICAgdmFyIG1heWJlU3RyaWN0Um9vdCA9IG51bGw7XG4gICAgdmFyIG5vZGUgPSBmaWJlcjtcblxuICAgIHdoaWxlIChub2RlICE9PSBudWxsKSB7XG4gICAgICBpZiAobm9kZS5tb2RlICYgU3RyaWN0TW9kZSkge1xuICAgICAgICBtYXliZVN0cmljdFJvb3QgPSBub2RlO1xuICAgICAgfVxuXG4gICAgICBub2RlID0gbm9kZS5yZXR1cm47XG4gICAgfVxuXG4gICAgcmV0dXJuIG1heWJlU3RyaWN0Um9vdDtcbiAgfTtcblxuICB2YXIgc2V0VG9Tb3J0ZWRTdHJpbmcgPSBmdW5jdGlvbiAoc2V0KSB7XG4gICAgdmFyIGFycmF5ID0gW107XG4gICAgc2V0LmZvckVhY2goZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICBhcnJheS5wdXNoKHZhbHVlKTtcbiAgICB9KTtcbiAgICByZXR1cm4gYXJyYXkuc29ydCgpLmpvaW4oJywgJyk7XG4gIH07XG5cbiAgdmFyIHBlbmRpbmdDb21wb25lbnRXaWxsTW91bnRXYXJuaW5ncyA9IFtdO1xuICB2YXIgcGVuZGluZ1VOU0FGRV9Db21wb25lbnRXaWxsTW91bnRXYXJuaW5ncyA9IFtdO1xuICB2YXIgcGVuZGluZ0NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNXYXJuaW5ncyA9IFtdO1xuICB2YXIgcGVuZGluZ1VOU0FGRV9Db21wb25lbnRXaWxsUmVjZWl2ZVByb3BzV2FybmluZ3MgPSBbXTtcbiAgdmFyIHBlbmRpbmdDb21wb25lbnRXaWxsVXBkYXRlV2FybmluZ3MgPSBbXTtcbiAgdmFyIHBlbmRpbmdVTlNBRkVfQ29tcG9uZW50V2lsbFVwZGF0ZVdhcm5pbmdzID0gW107IC8vIFRyYWNrcyBjb21wb25lbnRzIHdlIGhhdmUgYWxyZWFkeSB3YXJuZWQgYWJvdXQuXG5cbiAgdmFyIGRpZFdhcm5BYm91dFVuc2FmZUxpZmVjeWNsZXMgPSBuZXcgU2V0KCk7XG5cbiAgUmVhY3RTdHJpY3RNb2RlV2FybmluZ3MucmVjb3JkVW5zYWZlTGlmZWN5Y2xlV2FybmluZ3MgPSBmdW5jdGlvbiAoZmliZXIsIGluc3RhbmNlKSB7XG4gICAgLy8gRGVkdXAgc3RyYXRlZ3k6IFdhcm4gb25jZSBwZXIgY29tcG9uZW50LlxuICAgIGlmIChkaWRXYXJuQWJvdXRVbnNhZmVMaWZlY3ljbGVzLmhhcyhmaWJlci50eXBlKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbE1vdW50ID09PSAnZnVuY3Rpb24nICYmIC8vIERvbid0IHdhcm4gYWJvdXQgcmVhY3QtbGlmZWN5Y2xlcy1jb21wYXQgcG9seWZpbGxlZCBjb21wb25lbnRzLlxuICAgIGluc3RhbmNlLmNvbXBvbmVudFdpbGxNb3VudC5fX3N1cHByZXNzRGVwcmVjYXRpb25XYXJuaW5nICE9PSB0cnVlKSB7XG4gICAgICBwZW5kaW5nQ29tcG9uZW50V2lsbE1vdW50V2FybmluZ3MucHVzaChmaWJlcik7XG4gICAgfVxuXG4gICAgaWYgKGZpYmVyLm1vZGUgJiBTdHJpY3RNb2RlICYmIHR5cGVvZiBpbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbE1vdW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBwZW5kaW5nVU5TQUZFX0NvbXBvbmVudFdpbGxNb3VudFdhcm5pbmdzLnB1c2goZmliZXIpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyA9PT0gJ2Z1bmN0aW9uJyAmJiBpbnN0YW5jZS5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzLl9fc3VwcHJlc3NEZXByZWNhdGlvbldhcm5pbmcgIT09IHRydWUpIHtcbiAgICAgIHBlbmRpbmdDb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzV2FybmluZ3MucHVzaChmaWJlcik7XG4gICAgfVxuXG4gICAgaWYgKGZpYmVyLm1vZGUgJiBTdHJpY3RNb2RlICYmIHR5cGVvZiBpbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcGVuZGluZ1VOU0FGRV9Db21wb25lbnRXaWxsUmVjZWl2ZVByb3BzV2FybmluZ3MucHVzaChmaWJlcik7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsVXBkYXRlID09PSAnZnVuY3Rpb24nICYmIGluc3RhbmNlLmNvbXBvbmVudFdpbGxVcGRhdGUuX19zdXBwcmVzc0RlcHJlY2F0aW9uV2FybmluZyAhPT0gdHJ1ZSkge1xuICAgICAgcGVuZGluZ0NvbXBvbmVudFdpbGxVcGRhdGVXYXJuaW5ncy5wdXNoKGZpYmVyKTtcbiAgICB9XG5cbiAgICBpZiAoZmliZXIubW9kZSAmIFN0cmljdE1vZGUgJiYgdHlwZW9mIGluc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsVXBkYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBwZW5kaW5nVU5TQUZFX0NvbXBvbmVudFdpbGxVcGRhdGVXYXJuaW5ncy5wdXNoKGZpYmVyKTtcbiAgICB9XG4gIH07XG5cbiAgUmVhY3RTdHJpY3RNb2RlV2FybmluZ3MuZmx1c2hQZW5kaW5nVW5zYWZlTGlmZWN5Y2xlV2FybmluZ3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgLy8gV2UgZG8gYW4gaW5pdGlhbCBwYXNzIHRvIGdhdGhlciBjb21wb25lbnQgbmFtZXNcbiAgICB2YXIgY29tcG9uZW50V2lsbE1vdW50VW5pcXVlTmFtZXMgPSBuZXcgU2V0KCk7XG5cbiAgICBpZiAocGVuZGluZ0NvbXBvbmVudFdpbGxNb3VudFdhcm5pbmdzLmxlbmd0aCA+IDApIHtcbiAgICAgIHBlbmRpbmdDb21wb25lbnRXaWxsTW91bnRXYXJuaW5ncy5mb3JFYWNoKGZ1bmN0aW9uIChmaWJlcikge1xuICAgICAgICBjb21wb25lbnRXaWxsTW91bnRVbmlxdWVOYW1lcy5hZGQoZ2V0Q29tcG9uZW50TmFtZShmaWJlci50eXBlKSB8fCAnQ29tcG9uZW50Jyk7XG4gICAgICAgIGRpZFdhcm5BYm91dFVuc2FmZUxpZmVjeWNsZXMuYWRkKGZpYmVyLnR5cGUpO1xuICAgICAgfSk7XG4gICAgICBwZW5kaW5nQ29tcG9uZW50V2lsbE1vdW50V2FybmluZ3MgPSBbXTtcbiAgICB9XG5cbiAgICB2YXIgVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudFVuaXF1ZU5hbWVzID0gbmV3IFNldCgpO1xuXG4gICAgaWYgKHBlbmRpbmdVTlNBRkVfQ29tcG9uZW50V2lsbE1vdW50V2FybmluZ3MubGVuZ3RoID4gMCkge1xuICAgICAgcGVuZGluZ1VOU0FGRV9Db21wb25lbnRXaWxsTW91bnRXYXJuaW5ncy5mb3JFYWNoKGZ1bmN0aW9uIChmaWJlcikge1xuICAgICAgICBVTlNBRkVfY29tcG9uZW50V2lsbE1vdW50VW5pcXVlTmFtZXMuYWRkKGdldENvbXBvbmVudE5hbWUoZmliZXIudHlwZSkgfHwgJ0NvbXBvbmVudCcpO1xuICAgICAgICBkaWRXYXJuQWJvdXRVbnNhZmVMaWZlY3ljbGVzLmFkZChmaWJlci50eXBlKTtcbiAgICAgIH0pO1xuICAgICAgcGVuZGluZ1VOU0FGRV9Db21wb25lbnRXaWxsTW91bnRXYXJuaW5ncyA9IFtdO1xuICAgIH1cblxuICAgIHZhciBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzVW5pcXVlTmFtZXMgPSBuZXcgU2V0KCk7XG5cbiAgICBpZiAocGVuZGluZ0NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNXYXJuaW5ncy5sZW5ndGggPiAwKSB7XG4gICAgICBwZW5kaW5nQ29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1dhcm5pbmdzLmZvckVhY2goZnVuY3Rpb24gKGZpYmVyKSB7XG4gICAgICAgIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNVbmlxdWVOYW1lcy5hZGQoZ2V0Q29tcG9uZW50TmFtZShmaWJlci50eXBlKSB8fCAnQ29tcG9uZW50Jyk7XG4gICAgICAgIGRpZFdhcm5BYm91dFVuc2FmZUxpZmVjeWNsZXMuYWRkKGZpYmVyLnR5cGUpO1xuICAgICAgfSk7XG4gICAgICBwZW5kaW5nQ29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1dhcm5pbmdzID0gW107XG4gICAgfVxuXG4gICAgdmFyIFVOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzVW5pcXVlTmFtZXMgPSBuZXcgU2V0KCk7XG5cbiAgICBpZiAocGVuZGluZ1VOU0FGRV9Db21wb25lbnRXaWxsUmVjZWl2ZVByb3BzV2FybmluZ3MubGVuZ3RoID4gMCkge1xuICAgICAgcGVuZGluZ1VOU0FGRV9Db21wb25lbnRXaWxsUmVjZWl2ZVByb3BzV2FybmluZ3MuZm9yRWFjaChmdW5jdGlvbiAoZmliZXIpIHtcbiAgICAgICAgVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNVbmlxdWVOYW1lcy5hZGQoZ2V0Q29tcG9uZW50TmFtZShmaWJlci50eXBlKSB8fCAnQ29tcG9uZW50Jyk7XG4gICAgICAgIGRpZFdhcm5BYm91dFVuc2FmZUxpZmVjeWNsZXMuYWRkKGZpYmVyLnR5cGUpO1xuICAgICAgfSk7XG4gICAgICBwZW5kaW5nVU5TQUZFX0NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNXYXJuaW5ncyA9IFtdO1xuICAgIH1cblxuICAgIHZhciBjb21wb25lbnRXaWxsVXBkYXRlVW5pcXVlTmFtZXMgPSBuZXcgU2V0KCk7XG5cbiAgICBpZiAocGVuZGluZ0NvbXBvbmVudFdpbGxVcGRhdGVXYXJuaW5ncy5sZW5ndGggPiAwKSB7XG4gICAgICBwZW5kaW5nQ29tcG9uZW50V2lsbFVwZGF0ZVdhcm5pbmdzLmZvckVhY2goZnVuY3Rpb24gKGZpYmVyKSB7XG4gICAgICAgIGNvbXBvbmVudFdpbGxVcGRhdGVVbmlxdWVOYW1lcy5hZGQoZ2V0Q29tcG9uZW50TmFtZShmaWJlci50eXBlKSB8fCAnQ29tcG9uZW50Jyk7XG4gICAgICAgIGRpZFdhcm5BYm91dFVuc2FmZUxpZmVjeWNsZXMuYWRkKGZpYmVyLnR5cGUpO1xuICAgICAgfSk7XG4gICAgICBwZW5kaW5nQ29tcG9uZW50V2lsbFVwZGF0ZVdhcm5pbmdzID0gW107XG4gICAgfVxuXG4gICAgdmFyIFVOU0FGRV9jb21wb25lbnRXaWxsVXBkYXRlVW5pcXVlTmFtZXMgPSBuZXcgU2V0KCk7XG5cbiAgICBpZiAocGVuZGluZ1VOU0FGRV9Db21wb25lbnRXaWxsVXBkYXRlV2FybmluZ3MubGVuZ3RoID4gMCkge1xuICAgICAgcGVuZGluZ1VOU0FGRV9Db21wb25lbnRXaWxsVXBkYXRlV2FybmluZ3MuZm9yRWFjaChmdW5jdGlvbiAoZmliZXIpIHtcbiAgICAgICAgVU5TQUZFX2NvbXBvbmVudFdpbGxVcGRhdGVVbmlxdWVOYW1lcy5hZGQoZ2V0Q29tcG9uZW50TmFtZShmaWJlci50eXBlKSB8fCAnQ29tcG9uZW50Jyk7XG4gICAgICAgIGRpZFdhcm5BYm91dFVuc2FmZUxpZmVjeWNsZXMuYWRkKGZpYmVyLnR5cGUpO1xuICAgICAgfSk7XG4gICAgICBwZW5kaW5nVU5TQUZFX0NvbXBvbmVudFdpbGxVcGRhdGVXYXJuaW5ncyA9IFtdO1xuICAgIH0gLy8gRmluYWxseSwgd2UgZmx1c2ggYWxsIHRoZSB3YXJuaW5nc1xuICAgIC8vIFVOU0FGRV8gb25lcyBiZWZvcmUgdGhlIGRlcHJlY2F0ZWQgb25lcywgc2luY2UgdGhleSdsbCBiZSAnbG91ZGVyJ1xuXG5cbiAgICBpZiAoVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudFVuaXF1ZU5hbWVzLnNpemUgPiAwKSB7XG4gICAgICB2YXIgc29ydGVkTmFtZXMgPSBzZXRUb1NvcnRlZFN0cmluZyhVTlNBRkVfY29tcG9uZW50V2lsbE1vdW50VW5pcXVlTmFtZXMpO1xuXG4gICAgICBlcnJvcignVXNpbmcgVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudCBpbiBzdHJpY3QgbW9kZSBpcyBub3QgcmVjb21tZW5kZWQgYW5kIG1heSBpbmRpY2F0ZSBidWdzIGluIHlvdXIgY29kZS4gJyArICdTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3Vuc2FmZS1jb21wb25lbnQtbGlmZWN5Y2xlcyBmb3IgZGV0YWlscy5cXG5cXG4nICsgJyogTW92ZSBjb2RlIHdpdGggc2lkZSBlZmZlY3RzIHRvIGNvbXBvbmVudERpZE1vdW50LCBhbmQgc2V0IGluaXRpYWwgc3RhdGUgaW4gdGhlIGNvbnN0cnVjdG9yLlxcbicgKyAnXFxuUGxlYXNlIHVwZGF0ZSB0aGUgZm9sbG93aW5nIGNvbXBvbmVudHM6ICVzJywgc29ydGVkTmFtZXMpO1xuICAgIH1cblxuICAgIGlmIChVTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1VuaXF1ZU5hbWVzLnNpemUgPiAwKSB7XG4gICAgICB2YXIgX3NvcnRlZE5hbWVzID0gc2V0VG9Tb3J0ZWRTdHJpbmcoVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNVbmlxdWVOYW1lcyk7XG5cbiAgICAgIGVycm9yKCdVc2luZyBVTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyBpbiBzdHJpY3QgbW9kZSBpcyBub3QgcmVjb21tZW5kZWQgJyArICdhbmQgbWF5IGluZGljYXRlIGJ1Z3MgaW4geW91ciBjb2RlLiAnICsgJ1NlZSBodHRwczovL3JlYWN0anMub3JnL2xpbmsvdW5zYWZlLWNvbXBvbmVudC1saWZlY3ljbGVzIGZvciBkZXRhaWxzLlxcblxcbicgKyAnKiBNb3ZlIGRhdGEgZmV0Y2hpbmcgY29kZSBvciBzaWRlIGVmZmVjdHMgdG8gY29tcG9uZW50RGlkVXBkYXRlLlxcbicgKyBcIiogSWYgeW91J3JlIHVwZGF0aW5nIHN0YXRlIHdoZW5ldmVyIHByb3BzIGNoYW5nZSwgXCIgKyAncmVmYWN0b3IgeW91ciBjb2RlIHRvIHVzZSBtZW1vaXphdGlvbiB0ZWNobmlxdWVzIG9yIG1vdmUgaXQgdG8gJyArICdzdGF0aWMgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzLiBMZWFybiBtb3JlIGF0OiBodHRwczovL3JlYWN0anMub3JnL2xpbmsvZGVyaXZlZC1zdGF0ZVxcbicgKyAnXFxuUGxlYXNlIHVwZGF0ZSB0aGUgZm9sbG93aW5nIGNvbXBvbmVudHM6ICVzJywgX3NvcnRlZE5hbWVzKTtcbiAgICB9XG5cbiAgICBpZiAoVU5TQUZFX2NvbXBvbmVudFdpbGxVcGRhdGVVbmlxdWVOYW1lcy5zaXplID4gMCkge1xuICAgICAgdmFyIF9zb3J0ZWROYW1lczIgPSBzZXRUb1NvcnRlZFN0cmluZyhVTlNBRkVfY29tcG9uZW50V2lsbFVwZGF0ZVVuaXF1ZU5hbWVzKTtcblxuICAgICAgZXJyb3IoJ1VzaW5nIFVOU0FGRV9jb21wb25lbnRXaWxsVXBkYXRlIGluIHN0cmljdCBtb2RlIGlzIG5vdCByZWNvbW1lbmRlZCAnICsgJ2FuZCBtYXkgaW5kaWNhdGUgYnVncyBpbiB5b3VyIGNvZGUuICcgKyAnU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay91bnNhZmUtY29tcG9uZW50LWxpZmVjeWNsZXMgZm9yIGRldGFpbHMuXFxuXFxuJyArICcqIE1vdmUgZGF0YSBmZXRjaGluZyBjb2RlIG9yIHNpZGUgZWZmZWN0cyB0byBjb21wb25lbnREaWRVcGRhdGUuXFxuJyArICdcXG5QbGVhc2UgdXBkYXRlIHRoZSBmb2xsb3dpbmcgY29tcG9uZW50czogJXMnLCBfc29ydGVkTmFtZXMyKTtcbiAgICB9XG5cbiAgICBpZiAoY29tcG9uZW50V2lsbE1vdW50VW5pcXVlTmFtZXMuc2l6ZSA+IDApIHtcbiAgICAgIHZhciBfc29ydGVkTmFtZXMzID0gc2V0VG9Tb3J0ZWRTdHJpbmcoY29tcG9uZW50V2lsbE1vdW50VW5pcXVlTmFtZXMpO1xuXG4gICAgICB3YXJuKCdjb21wb25lbnRXaWxsTW91bnQgaGFzIGJlZW4gcmVuYW1lZCwgYW5kIGlzIG5vdCByZWNvbW1lbmRlZCBmb3IgdXNlLiAnICsgJ1NlZSBodHRwczovL3JlYWN0anMub3JnL2xpbmsvdW5zYWZlLWNvbXBvbmVudC1saWZlY3ljbGVzIGZvciBkZXRhaWxzLlxcblxcbicgKyAnKiBNb3ZlIGNvZGUgd2l0aCBzaWRlIGVmZmVjdHMgdG8gY29tcG9uZW50RGlkTW91bnQsIGFuZCBzZXQgaW5pdGlhbCBzdGF0ZSBpbiB0aGUgY29uc3RydWN0b3IuXFxuJyArICcqIFJlbmFtZSBjb21wb25lbnRXaWxsTW91bnQgdG8gVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudCB0byBzdXBwcmVzcyAnICsgJ3RoaXMgd2FybmluZyBpbiBub24tc3RyaWN0IG1vZGUuIEluIFJlYWN0IDE4LngsIG9ubHkgdGhlIFVOU0FGRV8gbmFtZSB3aWxsIHdvcmsuICcgKyAnVG8gcmVuYW1lIGFsbCBkZXByZWNhdGVkIGxpZmVjeWNsZXMgdG8gdGhlaXIgbmV3IG5hbWVzLCB5b3UgY2FuIHJ1biAnICsgJ2BucHggcmVhY3QtY29kZW1vZCByZW5hbWUtdW5zYWZlLWxpZmVjeWNsZXNgIGluIHlvdXIgcHJvamVjdCBzb3VyY2UgZm9sZGVyLlxcbicgKyAnXFxuUGxlYXNlIHVwZGF0ZSB0aGUgZm9sbG93aW5nIGNvbXBvbmVudHM6ICVzJywgX3NvcnRlZE5hbWVzMyk7XG4gICAgfVxuXG4gICAgaWYgKGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNVbmlxdWVOYW1lcy5zaXplID4gMCkge1xuICAgICAgdmFyIF9zb3J0ZWROYW1lczQgPSBzZXRUb1NvcnRlZFN0cmluZyhjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzVW5pcXVlTmFtZXMpO1xuXG4gICAgICB3YXJuKCdjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzIGhhcyBiZWVuIHJlbmFtZWQsIGFuZCBpcyBub3QgcmVjb21tZW5kZWQgZm9yIHVzZS4gJyArICdTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3Vuc2FmZS1jb21wb25lbnQtbGlmZWN5Y2xlcyBmb3IgZGV0YWlscy5cXG5cXG4nICsgJyogTW92ZSBkYXRhIGZldGNoaW5nIGNvZGUgb3Igc2lkZSBlZmZlY3RzIHRvIGNvbXBvbmVudERpZFVwZGF0ZS5cXG4nICsgXCIqIElmIHlvdSdyZSB1cGRhdGluZyBzdGF0ZSB3aGVuZXZlciBwcm9wcyBjaGFuZ2UsIHJlZmFjdG9yIHlvdXIgXCIgKyAnY29kZSB0byB1c2UgbWVtb2l6YXRpb24gdGVjaG5pcXVlcyBvciBtb3ZlIGl0IHRvICcgKyAnc3RhdGljIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcy4gTGVhcm4gbW9yZSBhdDogaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL2Rlcml2ZWQtc3RhdGVcXG4nICsgJyogUmVuYW1lIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgdG8gVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgdG8gc3VwcHJlc3MgJyArICd0aGlzIHdhcm5pbmcgaW4gbm9uLXN0cmljdCBtb2RlLiBJbiBSZWFjdCAxOC54LCBvbmx5IHRoZSBVTlNBRkVfIG5hbWUgd2lsbCB3b3JrLiAnICsgJ1RvIHJlbmFtZSBhbGwgZGVwcmVjYXRlZCBsaWZlY3ljbGVzIHRvIHRoZWlyIG5ldyBuYW1lcywgeW91IGNhbiBydW4gJyArICdgbnB4IHJlYWN0LWNvZGVtb2QgcmVuYW1lLXVuc2FmZS1saWZlY3ljbGVzYCBpbiB5b3VyIHByb2plY3Qgc291cmNlIGZvbGRlci5cXG4nICsgJ1xcblBsZWFzZSB1cGRhdGUgdGhlIGZvbGxvd2luZyBjb21wb25lbnRzOiAlcycsIF9zb3J0ZWROYW1lczQpO1xuICAgIH1cblxuICAgIGlmIChjb21wb25lbnRXaWxsVXBkYXRlVW5pcXVlTmFtZXMuc2l6ZSA+IDApIHtcbiAgICAgIHZhciBfc29ydGVkTmFtZXM1ID0gc2V0VG9Tb3J0ZWRTdHJpbmcoY29tcG9uZW50V2lsbFVwZGF0ZVVuaXF1ZU5hbWVzKTtcblxuICAgICAgd2FybignY29tcG9uZW50V2lsbFVwZGF0ZSBoYXMgYmVlbiByZW5hbWVkLCBhbmQgaXMgbm90IHJlY29tbWVuZGVkIGZvciB1c2UuICcgKyAnU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay91bnNhZmUtY29tcG9uZW50LWxpZmVjeWNsZXMgZm9yIGRldGFpbHMuXFxuXFxuJyArICcqIE1vdmUgZGF0YSBmZXRjaGluZyBjb2RlIG9yIHNpZGUgZWZmZWN0cyB0byBjb21wb25lbnREaWRVcGRhdGUuXFxuJyArICcqIFJlbmFtZSBjb21wb25lbnRXaWxsVXBkYXRlIHRvIFVOU0FGRV9jb21wb25lbnRXaWxsVXBkYXRlIHRvIHN1cHByZXNzICcgKyAndGhpcyB3YXJuaW5nIGluIG5vbi1zdHJpY3QgbW9kZS4gSW4gUmVhY3QgMTgueCwgb25seSB0aGUgVU5TQUZFXyBuYW1lIHdpbGwgd29yay4gJyArICdUbyByZW5hbWUgYWxsIGRlcHJlY2F0ZWQgbGlmZWN5Y2xlcyB0byB0aGVpciBuZXcgbmFtZXMsIHlvdSBjYW4gcnVuICcgKyAnYG5weCByZWFjdC1jb2RlbW9kIHJlbmFtZS11bnNhZmUtbGlmZWN5Y2xlc2AgaW4geW91ciBwcm9qZWN0IHNvdXJjZSBmb2xkZXIuXFxuJyArICdcXG5QbGVhc2UgdXBkYXRlIHRoZSBmb2xsb3dpbmcgY29tcG9uZW50czogJXMnLCBfc29ydGVkTmFtZXM1KTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIHBlbmRpbmdMZWdhY3lDb250ZXh0V2FybmluZyA9IG5ldyBNYXAoKTsgLy8gVHJhY2tzIGNvbXBvbmVudHMgd2UgaGF2ZSBhbHJlYWR5IHdhcm5lZCBhYm91dC5cblxuICB2YXIgZGlkV2FybkFib3V0TGVnYWN5Q29udGV4dCA9IG5ldyBTZXQoKTtcblxuICBSZWFjdFN0cmljdE1vZGVXYXJuaW5ncy5yZWNvcmRMZWdhY3lDb250ZXh0V2FybmluZyA9IGZ1bmN0aW9uIChmaWJlciwgaW5zdGFuY2UpIHtcbiAgICB2YXIgc3RyaWN0Um9vdCA9IGZpbmRTdHJpY3RSb290KGZpYmVyKTtcblxuICAgIGlmIChzdHJpY3RSb290ID09PSBudWxsKSB7XG4gICAgICBlcnJvcignRXhwZWN0ZWQgdG8gZmluZCBhIFN0cmljdE1vZGUgY29tcG9uZW50IGluIGEgc3RyaWN0IG1vZGUgdHJlZS4gJyArICdUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuXG4gICAgICByZXR1cm47XG4gICAgfSAvLyBEZWR1cCBzdHJhdGVneTogV2FybiBvbmNlIHBlciBjb21wb25lbnQuXG5cblxuICAgIGlmIChkaWRXYXJuQWJvdXRMZWdhY3lDb250ZXh0LmhhcyhmaWJlci50eXBlKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciB3YXJuaW5nc0ZvclJvb3QgPSBwZW5kaW5nTGVnYWN5Q29udGV4dFdhcm5pbmcuZ2V0KHN0cmljdFJvb3QpO1xuXG4gICAgaWYgKGZpYmVyLnR5cGUuY29udGV4dFR5cGVzICE9IG51bGwgfHwgZmliZXIudHlwZS5jaGlsZENvbnRleHRUeXBlcyAhPSBudWxsIHx8IGluc3RhbmNlICE9PSBudWxsICYmIHR5cGVvZiBpbnN0YW5jZS5nZXRDaGlsZENvbnRleHQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGlmICh3YXJuaW5nc0ZvclJvb3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB3YXJuaW5nc0ZvclJvb3QgPSBbXTtcbiAgICAgICAgcGVuZGluZ0xlZ2FjeUNvbnRleHRXYXJuaW5nLnNldChzdHJpY3RSb290LCB3YXJuaW5nc0ZvclJvb3QpO1xuICAgICAgfVxuXG4gICAgICB3YXJuaW5nc0ZvclJvb3QucHVzaChmaWJlcik7XG4gICAgfVxuICB9O1xuXG4gIFJlYWN0U3RyaWN0TW9kZVdhcm5pbmdzLmZsdXNoTGVnYWN5Q29udGV4dFdhcm5pbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgcGVuZGluZ0xlZ2FjeUNvbnRleHRXYXJuaW5nLmZvckVhY2goZnVuY3Rpb24gKGZpYmVyQXJyYXksIHN0cmljdFJvb3QpIHtcbiAgICAgIGlmIChmaWJlckFycmF5Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBmaXJzdEZpYmVyID0gZmliZXJBcnJheVswXTtcbiAgICAgIHZhciB1bmlxdWVOYW1lcyA9IG5ldyBTZXQoKTtcbiAgICAgIGZpYmVyQXJyYXkuZm9yRWFjaChmdW5jdGlvbiAoZmliZXIpIHtcbiAgICAgICAgdW5pcXVlTmFtZXMuYWRkKGdldENvbXBvbmVudE5hbWUoZmliZXIudHlwZSkgfHwgJ0NvbXBvbmVudCcpO1xuICAgICAgICBkaWRXYXJuQWJvdXRMZWdhY3lDb250ZXh0LmFkZChmaWJlci50eXBlKTtcbiAgICAgIH0pO1xuICAgICAgdmFyIHNvcnRlZE5hbWVzID0gc2V0VG9Tb3J0ZWRTdHJpbmcodW5pcXVlTmFtZXMpO1xuXG4gICAgICB0cnkge1xuICAgICAgICBzZXRDdXJyZW50RmliZXIoZmlyc3RGaWJlcik7XG5cbiAgICAgICAgZXJyb3IoJ0xlZ2FjeSBjb250ZXh0IEFQSSBoYXMgYmVlbiBkZXRlY3RlZCB3aXRoaW4gYSBzdHJpY3QtbW9kZSB0cmVlLicgKyAnXFxuXFxuVGhlIG9sZCBBUEkgd2lsbCBiZSBzdXBwb3J0ZWQgaW4gYWxsIDE2LnggcmVsZWFzZXMsIGJ1dCBhcHBsaWNhdGlvbnMgJyArICd1c2luZyBpdCBzaG91bGQgbWlncmF0ZSB0byB0aGUgbmV3IHZlcnNpb24uJyArICdcXG5cXG5QbGVhc2UgdXBkYXRlIHRoZSBmb2xsb3dpbmcgY29tcG9uZW50czogJXMnICsgJ1xcblxcbkxlYXJuIG1vcmUgYWJvdXQgdGhpcyB3YXJuaW5nIGhlcmU6IGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9sZWdhY3ktY29udGV4dCcsIHNvcnRlZE5hbWVzKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHJlc2V0Q3VycmVudEZpYmVyKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgUmVhY3RTdHJpY3RNb2RlV2FybmluZ3MuZGlzY2FyZFBlbmRpbmdXYXJuaW5ncyA9IGZ1bmN0aW9uICgpIHtcbiAgICBwZW5kaW5nQ29tcG9uZW50V2lsbE1vdW50V2FybmluZ3MgPSBbXTtcbiAgICBwZW5kaW5nVU5TQUZFX0NvbXBvbmVudFdpbGxNb3VudFdhcm5pbmdzID0gW107XG4gICAgcGVuZGluZ0NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNXYXJuaW5ncyA9IFtdO1xuICAgIHBlbmRpbmdVTlNBRkVfQ29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1dhcm5pbmdzID0gW107XG4gICAgcGVuZGluZ0NvbXBvbmVudFdpbGxVcGRhdGVXYXJuaW5ncyA9IFtdO1xuICAgIHBlbmRpbmdVTlNBRkVfQ29tcG9uZW50V2lsbFVwZGF0ZVdhcm5pbmdzID0gW107XG4gICAgcGVuZGluZ0xlZ2FjeUNvbnRleHRXYXJuaW5nID0gbmV3IE1hcCgpO1xuICB9O1xufVxuXG5mdW5jdGlvbiByZXNvbHZlRGVmYXVsdFByb3BzKENvbXBvbmVudCwgYmFzZVByb3BzKSB7XG4gIGlmIChDb21wb25lbnQgJiYgQ29tcG9uZW50LmRlZmF1bHRQcm9wcykge1xuICAgIC8vIFJlc29sdmUgZGVmYXVsdCBwcm9wcy4gVGFrZW4gZnJvbSBSZWFjdEVsZW1lbnRcbiAgICB2YXIgcHJvcHMgPSBfYXNzaWduKHt9LCBiYXNlUHJvcHMpO1xuXG4gICAgdmFyIGRlZmF1bHRQcm9wcyA9IENvbXBvbmVudC5kZWZhdWx0UHJvcHM7XG5cbiAgICBmb3IgKHZhciBwcm9wTmFtZSBpbiBkZWZhdWx0UHJvcHMpIHtcbiAgICAgIGlmIChwcm9wc1twcm9wTmFtZV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBwcm9wc1twcm9wTmFtZV0gPSBkZWZhdWx0UHJvcHNbcHJvcE5hbWVdO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBwcm9wcztcbiAgfVxuXG4gIHJldHVybiBiYXNlUHJvcHM7XG59XG5cbi8vIE1heCAzMSBiaXQgaW50ZWdlci4gVGhlIG1heCBpbnRlZ2VyIHNpemUgaW4gVjggZm9yIDMyLWJpdCBzeXN0ZW1zLlxuLy8gTWF0aC5wb3coMiwgMzApIC0gMVxuLy8gMGIxMTExMTExMTExMTExMTExMTExMTExMTExMTExMTFcbnZhciBNQVhfU0lHTkVEXzMxX0JJVF9JTlQgPSAxMDczNzQxODIzO1xuXG52YXIgdmFsdWVDdXJzb3IgPSBjcmVhdGVDdXJzb3IobnVsbCk7XG52YXIgcmVuZGVyZXJTaWdpbDtcblxue1xuICAvLyBVc2UgdGhpcyB0byBkZXRlY3QgbXVsdGlwbGUgcmVuZGVyZXJzIHVzaW5nIHRoZSBzYW1lIGNvbnRleHRcbiAgcmVuZGVyZXJTaWdpbCA9IHt9O1xufVxuXG52YXIgY3VycmVudGx5UmVuZGVyaW5nRmliZXIgPSBudWxsO1xudmFyIGxhc3RDb250ZXh0RGVwZW5kZW5jeSA9IG51bGw7XG52YXIgbGFzdENvbnRleHRXaXRoQWxsQml0c09ic2VydmVkID0gbnVsbDtcbnZhciBpc0Rpc2FsbG93ZWRDb250ZXh0UmVhZEluREVWID0gZmFsc2U7XG5mdW5jdGlvbiByZXNldENvbnRleHREZXBlbmRlbmNpZXMoKSB7XG4gIC8vIFRoaXMgaXMgY2FsbGVkIHJpZ2h0IGJlZm9yZSBSZWFjdCB5aWVsZHMgZXhlY3V0aW9uLCB0byBlbnN1cmUgYHJlYWRDb250ZXh0YFxuICAvLyBjYW5ub3QgYmUgY2FsbGVkIG91dHNpZGUgdGhlIHJlbmRlciBwaGFzZS5cbiAgY3VycmVudGx5UmVuZGVyaW5nRmliZXIgPSBudWxsO1xuICBsYXN0Q29udGV4dERlcGVuZGVuY3kgPSBudWxsO1xuICBsYXN0Q29udGV4dFdpdGhBbGxCaXRzT2JzZXJ2ZWQgPSBudWxsO1xuXG4gIHtcbiAgICBpc0Rpc2FsbG93ZWRDb250ZXh0UmVhZEluREVWID0gZmFsc2U7XG4gIH1cbn1cbmZ1bmN0aW9uIGVudGVyRGlzYWxsb3dlZENvbnRleHRSZWFkSW5ERVYoKSB7XG4gIHtcbiAgICBpc0Rpc2FsbG93ZWRDb250ZXh0UmVhZEluREVWID0gdHJ1ZTtcbiAgfVxufVxuZnVuY3Rpb24gZXhpdERpc2FsbG93ZWRDb250ZXh0UmVhZEluREVWKCkge1xuICB7XG4gICAgaXNEaXNhbGxvd2VkQ29udGV4dFJlYWRJbkRFViA9IGZhbHNlO1xuICB9XG59XG5mdW5jdGlvbiBwdXNoUHJvdmlkZXIocHJvdmlkZXJGaWJlciwgbmV4dFZhbHVlKSB7XG4gIHZhciBjb250ZXh0ID0gcHJvdmlkZXJGaWJlci50eXBlLl9jb250ZXh0O1xuXG4gIHtcbiAgICBwdXNoKHZhbHVlQ3Vyc29yLCBjb250ZXh0Ll9jdXJyZW50VmFsdWUsIHByb3ZpZGVyRmliZXIpO1xuICAgIGNvbnRleHQuX2N1cnJlbnRWYWx1ZSA9IG5leHRWYWx1ZTtcblxuICAgIHtcbiAgICAgIGlmIChjb250ZXh0Ll9jdXJyZW50UmVuZGVyZXIgIT09IHVuZGVmaW5lZCAmJiBjb250ZXh0Ll9jdXJyZW50UmVuZGVyZXIgIT09IG51bGwgJiYgY29udGV4dC5fY3VycmVudFJlbmRlcmVyICE9PSByZW5kZXJlclNpZ2lsKSB7XG4gICAgICAgIGVycm9yKCdEZXRlY3RlZCBtdWx0aXBsZSByZW5kZXJlcnMgY29uY3VycmVudGx5IHJlbmRlcmluZyB0aGUgJyArICdzYW1lIGNvbnRleHQgcHJvdmlkZXIuIFRoaXMgaXMgY3VycmVudGx5IHVuc3VwcG9ydGVkLicpO1xuICAgICAgfVxuXG4gICAgICBjb250ZXh0Ll9jdXJyZW50UmVuZGVyZXIgPSByZW5kZXJlclNpZ2lsO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gcG9wUHJvdmlkZXIocHJvdmlkZXJGaWJlcikge1xuICB2YXIgY3VycmVudFZhbHVlID0gdmFsdWVDdXJzb3IuY3VycmVudDtcbiAgcG9wKHZhbHVlQ3Vyc29yLCBwcm92aWRlckZpYmVyKTtcbiAgdmFyIGNvbnRleHQgPSBwcm92aWRlckZpYmVyLnR5cGUuX2NvbnRleHQ7XG5cbiAge1xuICAgIGNvbnRleHQuX2N1cnJlbnRWYWx1ZSA9IGN1cnJlbnRWYWx1ZTtcbiAgfVxufVxuZnVuY3Rpb24gY2FsY3VsYXRlQ2hhbmdlZEJpdHMoY29udGV4dCwgbmV3VmFsdWUsIG9sZFZhbHVlKSB7XG4gIGlmIChvYmplY3RJcyhvbGRWYWx1ZSwgbmV3VmFsdWUpKSB7XG4gICAgLy8gTm8gY2hhbmdlXG4gICAgcmV0dXJuIDA7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGNoYW5nZWRCaXRzID0gdHlwZW9mIGNvbnRleHQuX2NhbGN1bGF0ZUNoYW5nZWRCaXRzID09PSAnZnVuY3Rpb24nID8gY29udGV4dC5fY2FsY3VsYXRlQ2hhbmdlZEJpdHMob2xkVmFsdWUsIG5ld1ZhbHVlKSA6IE1BWF9TSUdORURfMzFfQklUX0lOVDtcblxuICAgIHtcbiAgICAgIGlmICgoY2hhbmdlZEJpdHMgJiBNQVhfU0lHTkVEXzMxX0JJVF9JTlQpICE9PSBjaGFuZ2VkQml0cykge1xuICAgICAgICBlcnJvcignY2FsY3VsYXRlQ2hhbmdlZEJpdHM6IEV4cGVjdGVkIHRoZSByZXR1cm4gdmFsdWUgdG8gYmUgYSAnICsgJzMxLWJpdCBpbnRlZ2VyLiBJbnN0ZWFkIHJlY2VpdmVkOiAlcycsIGNoYW5nZWRCaXRzKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gY2hhbmdlZEJpdHMgfCAwO1xuICB9XG59XG5mdW5jdGlvbiBzY2hlZHVsZVdvcmtPblBhcmVudFBhdGgocGFyZW50LCByZW5kZXJMYW5lcykge1xuICAvLyBVcGRhdGUgdGhlIGNoaWxkIGxhbmVzIG9mIGFsbCB0aGUgYW5jZXN0b3JzLCBpbmNsdWRpbmcgdGhlIGFsdGVybmF0ZXMuXG4gIHZhciBub2RlID0gcGFyZW50O1xuXG4gIHdoaWxlIChub2RlICE9PSBudWxsKSB7XG4gICAgdmFyIGFsdGVybmF0ZSA9IG5vZGUuYWx0ZXJuYXRlO1xuXG4gICAgaWYgKCFpc1N1YnNldE9mTGFuZXMobm9kZS5jaGlsZExhbmVzLCByZW5kZXJMYW5lcykpIHtcbiAgICAgIG5vZGUuY2hpbGRMYW5lcyA9IG1lcmdlTGFuZXMobm9kZS5jaGlsZExhbmVzLCByZW5kZXJMYW5lcyk7XG5cbiAgICAgIGlmIChhbHRlcm5hdGUgIT09IG51bGwpIHtcbiAgICAgICAgYWx0ZXJuYXRlLmNoaWxkTGFuZXMgPSBtZXJnZUxhbmVzKGFsdGVybmF0ZS5jaGlsZExhbmVzLCByZW5kZXJMYW5lcyk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChhbHRlcm5hdGUgIT09IG51bGwgJiYgIWlzU3Vic2V0T2ZMYW5lcyhhbHRlcm5hdGUuY2hpbGRMYW5lcywgcmVuZGVyTGFuZXMpKSB7XG4gICAgICBhbHRlcm5hdGUuY2hpbGRMYW5lcyA9IG1lcmdlTGFuZXMoYWx0ZXJuYXRlLmNoaWxkTGFuZXMsIHJlbmRlckxhbmVzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gTmVpdGhlciBhbHRlcm5hdGUgd2FzIHVwZGF0ZWQsIHdoaWNoIG1lYW5zIHRoZSByZXN0IG9mIHRoZVxuICAgICAgLy8gYW5jZXN0b3IgcGF0aCBhbHJlYWR5IGhhcyBzdWZmaWNpZW50IHByaW9yaXR5LlxuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgbm9kZSA9IG5vZGUucmV0dXJuO1xuICB9XG59XG5mdW5jdGlvbiBwcm9wYWdhdGVDb250ZXh0Q2hhbmdlKHdvcmtJblByb2dyZXNzLCBjb250ZXh0LCBjaGFuZ2VkQml0cywgcmVuZGVyTGFuZXMpIHtcbiAgdmFyIGZpYmVyID0gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG5cbiAgaWYgKGZpYmVyICE9PSBudWxsKSB7XG4gICAgLy8gU2V0IHRoZSByZXR1cm4gcG9pbnRlciBvZiB0aGUgY2hpbGQgdG8gdGhlIHdvcmstaW4tcHJvZ3Jlc3MgZmliZXIuXG4gICAgZmliZXIucmV0dXJuID0gd29ya0luUHJvZ3Jlc3M7XG4gIH1cblxuICB3aGlsZSAoZmliZXIgIT09IG51bGwpIHtcbiAgICB2YXIgbmV4dEZpYmVyID0gdm9pZCAwOyAvLyBWaXNpdCB0aGlzIGZpYmVyLlxuXG4gICAgdmFyIGxpc3QgPSBmaWJlci5kZXBlbmRlbmNpZXM7XG5cbiAgICBpZiAobGlzdCAhPT0gbnVsbCkge1xuICAgICAgbmV4dEZpYmVyID0gZmliZXIuY2hpbGQ7XG4gICAgICB2YXIgZGVwZW5kZW5jeSA9IGxpc3QuZmlyc3RDb250ZXh0O1xuXG4gICAgICB3aGlsZSAoZGVwZW5kZW5jeSAhPT0gbnVsbCkge1xuICAgICAgICAvLyBDaGVjayBpZiB0aGUgY29udGV4dCBtYXRjaGVzLlxuICAgICAgICBpZiAoZGVwZW5kZW5jeS5jb250ZXh0ID09PSBjb250ZXh0ICYmIChkZXBlbmRlbmN5Lm9ic2VydmVkQml0cyAmIGNoYW5nZWRCaXRzKSAhPT0gMCkge1xuICAgICAgICAgIC8vIE1hdGNoISBTY2hlZHVsZSBhbiB1cGRhdGUgb24gdGhpcyBmaWJlci5cbiAgICAgICAgICBpZiAoZmliZXIudGFnID09PSBDbGFzc0NvbXBvbmVudCkge1xuICAgICAgICAgICAgLy8gU2NoZWR1bGUgYSBmb3JjZSB1cGRhdGUgb24gdGhlIHdvcmstaW4tcHJvZ3Jlc3MuXG4gICAgICAgICAgICB2YXIgdXBkYXRlID0gY3JlYXRlVXBkYXRlKE5vVGltZXN0YW1wLCBwaWNrQXJiaXRyYXJ5TGFuZShyZW5kZXJMYW5lcykpO1xuICAgICAgICAgICAgdXBkYXRlLnRhZyA9IEZvcmNlVXBkYXRlOyAvLyBUT0RPOiBCZWNhdXNlIHdlIGRvbid0IGhhdmUgYSB3b3JrLWluLXByb2dyZXNzLCB0aGlzIHdpbGwgYWRkIHRoZVxuICAgICAgICAgICAgLy8gdXBkYXRlIHRvIHRoZSBjdXJyZW50IGZpYmVyLCB0b28sIHdoaWNoIG1lYW5zIGl0IHdpbGwgcGVyc2lzdCBldmVuIGlmXG4gICAgICAgICAgICAvLyB0aGlzIHJlbmRlciBpcyB0aHJvd24gYXdheS4gU2luY2UgaXQncyBhIHJhY2UgY29uZGl0aW9uLCBub3Qgc3VyZSBpdCdzXG4gICAgICAgICAgICAvLyB3b3J0aCBmaXhpbmcuXG5cbiAgICAgICAgICAgIGVucXVldWVVcGRhdGUoZmliZXIsIHVwZGF0ZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZmliZXIubGFuZXMgPSBtZXJnZUxhbmVzKGZpYmVyLmxhbmVzLCByZW5kZXJMYW5lcyk7XG4gICAgICAgICAgdmFyIGFsdGVybmF0ZSA9IGZpYmVyLmFsdGVybmF0ZTtcblxuICAgICAgICAgIGlmIChhbHRlcm5hdGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGFsdGVybmF0ZS5sYW5lcyA9IG1lcmdlTGFuZXMoYWx0ZXJuYXRlLmxhbmVzLCByZW5kZXJMYW5lcyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgc2NoZWR1bGVXb3JrT25QYXJlbnRQYXRoKGZpYmVyLnJldHVybiwgcmVuZGVyTGFuZXMpOyAvLyBNYXJrIHRoZSB1cGRhdGVkIGxhbmVzIG9uIHRoZSBsaXN0LCB0b28uXG5cbiAgICAgICAgICBsaXN0LmxhbmVzID0gbWVyZ2VMYW5lcyhsaXN0LmxhbmVzLCByZW5kZXJMYW5lcyk7IC8vIFNpbmNlIHdlIGFscmVhZHkgZm91bmQgYSBtYXRjaCwgd2UgY2FuIHN0b3AgdHJhdmVyc2luZyB0aGVcbiAgICAgICAgICAvLyBkZXBlbmRlbmN5IGxpc3QuXG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIGRlcGVuZGVuY3kgPSBkZXBlbmRlbmN5Lm5leHQ7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChmaWJlci50YWcgPT09IENvbnRleHRQcm92aWRlcikge1xuICAgICAgLy8gRG9uJ3Qgc2NhbiBkZWVwZXIgaWYgdGhpcyBpcyBhIG1hdGNoaW5nIHByb3ZpZGVyXG4gICAgICBuZXh0RmliZXIgPSBmaWJlci50eXBlID09PSB3b3JrSW5Qcm9ncmVzcy50eXBlID8gbnVsbCA6IGZpYmVyLmNoaWxkO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUcmF2ZXJzZSBkb3duLlxuICAgICAgbmV4dEZpYmVyID0gZmliZXIuY2hpbGQ7XG4gICAgfVxuXG4gICAgaWYgKG5leHRGaWJlciAhPT0gbnVsbCkge1xuICAgICAgLy8gU2V0IHRoZSByZXR1cm4gcG9pbnRlciBvZiB0aGUgY2hpbGQgdG8gdGhlIHdvcmstaW4tcHJvZ3Jlc3MgZmliZXIuXG4gICAgICBuZXh0RmliZXIucmV0dXJuID0gZmliZXI7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIE5vIGNoaWxkLiBUcmF2ZXJzZSB0byBuZXh0IHNpYmxpbmcuXG4gICAgICBuZXh0RmliZXIgPSBmaWJlcjtcblxuICAgICAgd2hpbGUgKG5leHRGaWJlciAhPT0gbnVsbCkge1xuICAgICAgICBpZiAobmV4dEZpYmVyID09PSB3b3JrSW5Qcm9ncmVzcykge1xuICAgICAgICAgIC8vIFdlJ3JlIGJhY2sgdG8gdGhlIHJvb3Qgb2YgdGhpcyBzdWJ0cmVlLiBFeGl0LlxuICAgICAgICAgIG5leHRGaWJlciA9IG51bGw7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc2libGluZyA9IG5leHRGaWJlci5zaWJsaW5nO1xuXG4gICAgICAgIGlmIChzaWJsaW5nICE9PSBudWxsKSB7XG4gICAgICAgICAgLy8gU2V0IHRoZSByZXR1cm4gcG9pbnRlciBvZiB0aGUgc2libGluZyB0byB0aGUgd29yay1pbi1wcm9ncmVzcyBmaWJlci5cbiAgICAgICAgICBzaWJsaW5nLnJldHVybiA9IG5leHRGaWJlci5yZXR1cm47XG4gICAgICAgICAgbmV4dEZpYmVyID0gc2libGluZztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfSAvLyBObyBtb3JlIHNpYmxpbmdzLiBUcmF2ZXJzZSB1cC5cblxuXG4gICAgICAgIG5leHRGaWJlciA9IG5leHRGaWJlci5yZXR1cm47XG4gICAgICB9XG4gICAgfVxuXG4gICAgZmliZXIgPSBuZXh0RmliZXI7XG4gIH1cbn1cbmZ1bmN0aW9uIHByZXBhcmVUb1JlYWRDb250ZXh0KHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcykge1xuICBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciA9IHdvcmtJblByb2dyZXNzO1xuICBsYXN0Q29udGV4dERlcGVuZGVuY3kgPSBudWxsO1xuICBsYXN0Q29udGV4dFdpdGhBbGxCaXRzT2JzZXJ2ZWQgPSBudWxsO1xuICB2YXIgZGVwZW5kZW5jaWVzID0gd29ya0luUHJvZ3Jlc3MuZGVwZW5kZW5jaWVzO1xuXG4gIGlmIChkZXBlbmRlbmNpZXMgIT09IG51bGwpIHtcbiAgICB2YXIgZmlyc3RDb250ZXh0ID0gZGVwZW5kZW5jaWVzLmZpcnN0Q29udGV4dDtcblxuICAgIGlmIChmaXJzdENvbnRleHQgIT09IG51bGwpIHtcbiAgICAgIGlmIChpbmNsdWRlc1NvbWVMYW5lKGRlcGVuZGVuY2llcy5sYW5lcywgcmVuZGVyTGFuZXMpKSB7XG4gICAgICAgIC8vIENvbnRleHQgbGlzdCBoYXMgYSBwZW5kaW5nIHVwZGF0ZS4gTWFyayB0aGF0IHRoaXMgZmliZXIgcGVyZm9ybWVkIHdvcmsuXG4gICAgICAgIG1hcmtXb3JrSW5Qcm9ncmVzc1JlY2VpdmVkVXBkYXRlKCk7XG4gICAgICB9IC8vIFJlc2V0IHRoZSB3b3JrLWluLXByb2dyZXNzIGxpc3RcblxuXG4gICAgICBkZXBlbmRlbmNpZXMuZmlyc3RDb250ZXh0ID0gbnVsbDtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHJlYWRDb250ZXh0KGNvbnRleHQsIG9ic2VydmVkQml0cykge1xuICB7XG4gICAgLy8gVGhpcyB3YXJuaW5nIHdvdWxkIGZpcmUgaWYgeW91IHJlYWQgY29udGV4dCBpbnNpZGUgYSBIb29rIGxpa2UgdXNlTWVtby5cbiAgICAvLyBVbmxpa2UgdGhlIGNsYXNzIGNoZWNrIGJlbG93LCBpdCdzIG5vdCBlbmZvcmNlZCBpbiBwcm9kdWN0aW9uIGZvciBwZXJmLlxuICAgIGlmIChpc0Rpc2FsbG93ZWRDb250ZXh0UmVhZEluREVWKSB7XG4gICAgICBlcnJvcignQ29udGV4dCBjYW4gb25seSBiZSByZWFkIHdoaWxlIFJlYWN0IGlzIHJlbmRlcmluZy4gJyArICdJbiBjbGFzc2VzLCB5b3UgY2FuIHJlYWQgaXQgaW4gdGhlIHJlbmRlciBtZXRob2Qgb3IgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzLiAnICsgJ0luIGZ1bmN0aW9uIGNvbXBvbmVudHMsIHlvdSBjYW4gcmVhZCBpdCBkaXJlY3RseSBpbiB0aGUgZnVuY3Rpb24gYm9keSwgYnV0IG5vdCAnICsgJ2luc2lkZSBIb29rcyBsaWtlIHVzZVJlZHVjZXIoKSBvciB1c2VNZW1vKCkuJyk7XG4gICAgfVxuICB9XG5cbiAgaWYgKGxhc3RDb250ZXh0V2l0aEFsbEJpdHNPYnNlcnZlZCA9PT0gY29udGV4dCkgOyBlbHNlIGlmIChvYnNlcnZlZEJpdHMgPT09IGZhbHNlIHx8IG9ic2VydmVkQml0cyA9PT0gMCkgOyBlbHNlIHtcbiAgICB2YXIgcmVzb2x2ZWRPYnNlcnZlZEJpdHM7IC8vIEF2b2lkIGRlb3B0aW5nIG9uIG9ic2VydmFibGUgYXJndW1lbnRzIG9yIGhldGVyb2dlbmVvdXMgdHlwZXMuXG5cbiAgICBpZiAodHlwZW9mIG9ic2VydmVkQml0cyAhPT0gJ251bWJlcicgfHwgb2JzZXJ2ZWRCaXRzID09PSBNQVhfU0lHTkVEXzMxX0JJVF9JTlQpIHtcbiAgICAgIC8vIE9ic2VydmUgYWxsIHVwZGF0ZXMuXG4gICAgICBsYXN0Q29udGV4dFdpdGhBbGxCaXRzT2JzZXJ2ZWQgPSBjb250ZXh0O1xuICAgICAgcmVzb2x2ZWRPYnNlcnZlZEJpdHMgPSBNQVhfU0lHTkVEXzMxX0JJVF9JTlQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc29sdmVkT2JzZXJ2ZWRCaXRzID0gb2JzZXJ2ZWRCaXRzO1xuICAgIH1cblxuICAgIHZhciBjb250ZXh0SXRlbSA9IHtcbiAgICAgIGNvbnRleHQ6IGNvbnRleHQsXG4gICAgICBvYnNlcnZlZEJpdHM6IHJlc29sdmVkT2JzZXJ2ZWRCaXRzLFxuICAgICAgbmV4dDogbnVsbFxuICAgIH07XG5cbiAgICBpZiAobGFzdENvbnRleHREZXBlbmRlbmN5ID09PSBudWxsKSB7XG4gICAgICBpZiAoIShjdXJyZW50bHlSZW5kZXJpbmdGaWJlciAhPT0gbnVsbCkpIHtcbiAgICAgICAge1xuICAgICAgICAgIHRocm93IEVycm9yKCBcIkNvbnRleHQgY2FuIG9ubHkgYmUgcmVhZCB3aGlsZSBSZWFjdCBpcyByZW5kZXJpbmcuIEluIGNsYXNzZXMsIHlvdSBjYW4gcmVhZCBpdCBpbiB0aGUgcmVuZGVyIG1ldGhvZCBvciBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMuIEluIGZ1bmN0aW9uIGNvbXBvbmVudHMsIHlvdSBjYW4gcmVhZCBpdCBkaXJlY3RseSBpbiB0aGUgZnVuY3Rpb24gYm9keSwgYnV0IG5vdCBpbnNpZGUgSG9va3MgbGlrZSB1c2VSZWR1Y2VyKCkgb3IgdXNlTWVtbygpLlwiICk7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gVGhpcyBpcyB0aGUgZmlyc3QgZGVwZW5kZW5jeSBmb3IgdGhpcyBjb21wb25lbnQuIENyZWF0ZSBhIG5ldyBsaXN0LlxuXG5cbiAgICAgIGxhc3RDb250ZXh0RGVwZW5kZW5jeSA9IGNvbnRleHRJdGVtO1xuICAgICAgY3VycmVudGx5UmVuZGVyaW5nRmliZXIuZGVwZW5kZW5jaWVzID0ge1xuICAgICAgICBsYW5lczogTm9MYW5lcyxcbiAgICAgICAgZmlyc3RDb250ZXh0OiBjb250ZXh0SXRlbSxcbiAgICAgICAgcmVzcG9uZGVyczogbnVsbFxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQXBwZW5kIGEgbmV3IGNvbnRleHQgaXRlbS5cbiAgICAgIGxhc3RDb250ZXh0RGVwZW5kZW5jeSA9IGxhc3RDb250ZXh0RGVwZW5kZW5jeS5uZXh0ID0gY29udGV4dEl0ZW07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuICBjb250ZXh0Ll9jdXJyZW50VmFsdWUgO1xufVxuXG52YXIgVXBkYXRlU3RhdGUgPSAwO1xudmFyIFJlcGxhY2VTdGF0ZSA9IDE7XG52YXIgRm9yY2VVcGRhdGUgPSAyO1xudmFyIENhcHR1cmVVcGRhdGUgPSAzOyAvLyBHbG9iYWwgc3RhdGUgdGhhdCBpcyByZXNldCBhdCB0aGUgYmVnaW5uaW5nIG9mIGNhbGxpbmcgYHByb2Nlc3NVcGRhdGVRdWV1ZWAuXG4vLyBJdCBzaG91bGQgb25seSBiZSByZWFkIHJpZ2h0IGFmdGVyIGNhbGxpbmcgYHByb2Nlc3NVcGRhdGVRdWV1ZWAsIHZpYVxuLy8gYGNoZWNrSGFzRm9yY2VVcGRhdGVBZnRlclByb2Nlc3NpbmdgLlxuXG52YXIgaGFzRm9yY2VVcGRhdGUgPSBmYWxzZTtcbnZhciBkaWRXYXJuVXBkYXRlSW5zaWRlVXBkYXRlO1xudmFyIGN1cnJlbnRseVByb2Nlc3NpbmdRdWV1ZTtcblxue1xuICBkaWRXYXJuVXBkYXRlSW5zaWRlVXBkYXRlID0gZmFsc2U7XG4gIGN1cnJlbnRseVByb2Nlc3NpbmdRdWV1ZSA9IG51bGw7XG59XG5cbmZ1bmN0aW9uIGluaXRpYWxpemVVcGRhdGVRdWV1ZShmaWJlcikge1xuICB2YXIgcXVldWUgPSB7XG4gICAgYmFzZVN0YXRlOiBmaWJlci5tZW1vaXplZFN0YXRlLFxuICAgIGZpcnN0QmFzZVVwZGF0ZTogbnVsbCxcbiAgICBsYXN0QmFzZVVwZGF0ZTogbnVsbCxcbiAgICBzaGFyZWQ6IHtcbiAgICAgIHBlbmRpbmc6IG51bGxcbiAgICB9LFxuICAgIGVmZmVjdHM6IG51bGxcbiAgfTtcbiAgZmliZXIudXBkYXRlUXVldWUgPSBxdWV1ZTtcbn1cbmZ1bmN0aW9uIGNsb25lVXBkYXRlUXVldWUoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpIHtcbiAgLy8gQ2xvbmUgdGhlIHVwZGF0ZSBxdWV1ZSBmcm9tIGN1cnJlbnQuIFVubGVzcyBpdCdzIGFscmVhZHkgYSBjbG9uZS5cbiAgdmFyIHF1ZXVlID0gd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWU7XG4gIHZhciBjdXJyZW50UXVldWUgPSBjdXJyZW50LnVwZGF0ZVF1ZXVlO1xuXG4gIGlmIChxdWV1ZSA9PT0gY3VycmVudFF1ZXVlKSB7XG4gICAgdmFyIGNsb25lID0ge1xuICAgICAgYmFzZVN0YXRlOiBjdXJyZW50UXVldWUuYmFzZVN0YXRlLFxuICAgICAgZmlyc3RCYXNlVXBkYXRlOiBjdXJyZW50UXVldWUuZmlyc3RCYXNlVXBkYXRlLFxuICAgICAgbGFzdEJhc2VVcGRhdGU6IGN1cnJlbnRRdWV1ZS5sYXN0QmFzZVVwZGF0ZSxcbiAgICAgIHNoYXJlZDogY3VycmVudFF1ZXVlLnNoYXJlZCxcbiAgICAgIGVmZmVjdHM6IGN1cnJlbnRRdWV1ZS5lZmZlY3RzXG4gICAgfTtcbiAgICB3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZSA9IGNsb25lO1xuICB9XG59XG5mdW5jdGlvbiBjcmVhdGVVcGRhdGUoZXZlbnRUaW1lLCBsYW5lKSB7XG4gIHZhciB1cGRhdGUgPSB7XG4gICAgZXZlbnRUaW1lOiBldmVudFRpbWUsXG4gICAgbGFuZTogbGFuZSxcbiAgICB0YWc6IFVwZGF0ZVN0YXRlLFxuICAgIHBheWxvYWQ6IG51bGwsXG4gICAgY2FsbGJhY2s6IG51bGwsXG4gICAgbmV4dDogbnVsbFxuICB9O1xuICByZXR1cm4gdXBkYXRlO1xufVxuZnVuY3Rpb24gZW5xdWV1ZVVwZGF0ZShmaWJlciwgdXBkYXRlKSB7XG4gIHZhciB1cGRhdGVRdWV1ZSA9IGZpYmVyLnVwZGF0ZVF1ZXVlO1xuXG4gIGlmICh1cGRhdGVRdWV1ZSA9PT0gbnVsbCkge1xuICAgIC8vIE9ubHkgb2NjdXJzIGlmIHRoZSBmaWJlciBoYXMgYmVlbiB1bm1vdW50ZWQuXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHNoYXJlZFF1ZXVlID0gdXBkYXRlUXVldWUuc2hhcmVkO1xuICB2YXIgcGVuZGluZyA9IHNoYXJlZFF1ZXVlLnBlbmRpbmc7XG5cbiAgaWYgKHBlbmRpbmcgPT09IG51bGwpIHtcbiAgICAvLyBUaGlzIGlzIHRoZSBmaXJzdCB1cGRhdGUuIENyZWF0ZSBhIGNpcmN1bGFyIGxpc3QuXG4gICAgdXBkYXRlLm5leHQgPSB1cGRhdGU7XG4gIH0gZWxzZSB7XG4gICAgdXBkYXRlLm5leHQgPSBwZW5kaW5nLm5leHQ7XG4gICAgcGVuZGluZy5uZXh0ID0gdXBkYXRlO1xuICB9XG5cbiAgc2hhcmVkUXVldWUucGVuZGluZyA9IHVwZGF0ZTtcblxuICB7XG4gICAgaWYgKGN1cnJlbnRseVByb2Nlc3NpbmdRdWV1ZSA9PT0gc2hhcmVkUXVldWUgJiYgIWRpZFdhcm5VcGRhdGVJbnNpZGVVcGRhdGUpIHtcbiAgICAgIGVycm9yKCdBbiB1cGRhdGUgKHNldFN0YXRlLCByZXBsYWNlU3RhdGUsIG9yIGZvcmNlVXBkYXRlKSB3YXMgc2NoZWR1bGVkICcgKyAnZnJvbSBpbnNpZGUgYW4gdXBkYXRlIGZ1bmN0aW9uLiBVcGRhdGUgZnVuY3Rpb25zIHNob3VsZCBiZSBwdXJlLCAnICsgJ3dpdGggemVybyBzaWRlLWVmZmVjdHMuIENvbnNpZGVyIHVzaW5nIGNvbXBvbmVudERpZFVwZGF0ZSBvciBhICcgKyAnY2FsbGJhY2suJyk7XG5cbiAgICAgIGRpZFdhcm5VcGRhdGVJbnNpZGVVcGRhdGUgPSB0cnVlO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gZW5xdWV1ZUNhcHR1cmVkVXBkYXRlKHdvcmtJblByb2dyZXNzLCBjYXB0dXJlZFVwZGF0ZSkge1xuICAvLyBDYXB0dXJlZCB1cGRhdGVzIGFyZSB1cGRhdGVzIHRoYXQgYXJlIHRocm93biBieSBhIGNoaWxkIGR1cmluZyB0aGUgcmVuZGVyXG4gIC8vIHBoYXNlLiBUaGV5IHNob3VsZCBiZSBkaXNjYXJkZWQgaWYgdGhlIHJlbmRlciBpcyBhYm9ydGVkLiBUaGVyZWZvcmUsXG4gIC8vIHdlIHNob3VsZCBvbmx5IHB1dCB0aGVtIG9uIHRoZSB3b3JrLWluLXByb2dyZXNzIHF1ZXVlLCBub3QgdGhlIGN1cnJlbnQgb25lLlxuICB2YXIgcXVldWUgPSB3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZTsgLy8gQ2hlY2sgaWYgdGhlIHdvcmstaW4tcHJvZ3Jlc3MgcXVldWUgaXMgYSBjbG9uZS5cblxuICB2YXIgY3VycmVudCA9IHdvcmtJblByb2dyZXNzLmFsdGVybmF0ZTtcblxuICBpZiAoY3VycmVudCAhPT0gbnVsbCkge1xuICAgIHZhciBjdXJyZW50UXVldWUgPSBjdXJyZW50LnVwZGF0ZVF1ZXVlO1xuXG4gICAgaWYgKHF1ZXVlID09PSBjdXJyZW50UXVldWUpIHtcbiAgICAgIC8vIFRoZSB3b3JrLWluLXByb2dyZXNzIHF1ZXVlIGlzIHRoZSBzYW1lIGFzIGN1cnJlbnQuIFRoaXMgaGFwcGVucyB3aGVuXG4gICAgICAvLyB3ZSBiYWlsIG91dCBvbiBhIHBhcmVudCBmaWJlciB0aGF0IHRoZW4gY2FwdHVyZXMgYW4gZXJyb3IgdGhyb3duIGJ5XG4gICAgICAvLyBhIGNoaWxkLiBTaW5jZSB3ZSB3YW50IHRvIGFwcGVuZCB0aGUgdXBkYXRlIG9ubHkgdG8gdGhlIHdvcmstaW5cbiAgICAgIC8vIC1wcm9ncmVzcyBxdWV1ZSwgd2UgbmVlZCB0byBjbG9uZSB0aGUgdXBkYXRlcy4gV2UgdXN1YWxseSBjbG9uZSBkdXJpbmdcbiAgICAgIC8vIHByb2Nlc3NVcGRhdGVRdWV1ZSwgYnV0IHRoYXQgZGlkbid0IGhhcHBlbiBpbiB0aGlzIGNhc2UgYmVjYXVzZSB3ZVxuICAgICAgLy8gc2tpcHBlZCBvdmVyIHRoZSBwYXJlbnQgd2hlbiB3ZSBiYWlsZWQgb3V0LlxuICAgICAgdmFyIG5ld0ZpcnN0ID0gbnVsbDtcbiAgICAgIHZhciBuZXdMYXN0ID0gbnVsbDtcbiAgICAgIHZhciBmaXJzdEJhc2VVcGRhdGUgPSBxdWV1ZS5maXJzdEJhc2VVcGRhdGU7XG5cbiAgICAgIGlmIChmaXJzdEJhc2VVcGRhdGUgIT09IG51bGwpIHtcbiAgICAgICAgLy8gTG9vcCB0aHJvdWdoIHRoZSB1cGRhdGVzIGFuZCBjbG9uZSB0aGVtLlxuICAgICAgICB2YXIgdXBkYXRlID0gZmlyc3RCYXNlVXBkYXRlO1xuXG4gICAgICAgIGRvIHtcbiAgICAgICAgICB2YXIgY2xvbmUgPSB7XG4gICAgICAgICAgICBldmVudFRpbWU6IHVwZGF0ZS5ldmVudFRpbWUsXG4gICAgICAgICAgICBsYW5lOiB1cGRhdGUubGFuZSxcbiAgICAgICAgICAgIHRhZzogdXBkYXRlLnRhZyxcbiAgICAgICAgICAgIHBheWxvYWQ6IHVwZGF0ZS5wYXlsb2FkLFxuICAgICAgICAgICAgY2FsbGJhY2s6IHVwZGF0ZS5jYWxsYmFjayxcbiAgICAgICAgICAgIG5leHQ6IG51bGxcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgaWYgKG5ld0xhc3QgPT09IG51bGwpIHtcbiAgICAgICAgICAgIG5ld0ZpcnN0ID0gbmV3TGFzdCA9IGNsb25lO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBuZXdMYXN0Lm5leHQgPSBjbG9uZTtcbiAgICAgICAgICAgIG5ld0xhc3QgPSBjbG9uZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB1cGRhdGUgPSB1cGRhdGUubmV4dDtcbiAgICAgICAgfSB3aGlsZSAodXBkYXRlICE9PSBudWxsKTsgLy8gQXBwZW5kIHRoZSBjYXB0dXJlZCB1cGRhdGUgdGhlIGVuZCBvZiB0aGUgY2xvbmVkIGxpc3QuXG5cblxuICAgICAgICBpZiAobmV3TGFzdCA9PT0gbnVsbCkge1xuICAgICAgICAgIG5ld0ZpcnN0ID0gbmV3TGFzdCA9IGNhcHR1cmVkVXBkYXRlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5ld0xhc3QubmV4dCA9IGNhcHR1cmVkVXBkYXRlO1xuICAgICAgICAgIG5ld0xhc3QgPSBjYXB0dXJlZFVwZGF0ZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gVGhlcmUgYXJlIG5vIGJhc2UgdXBkYXRlcy5cbiAgICAgICAgbmV3Rmlyc3QgPSBuZXdMYXN0ID0gY2FwdHVyZWRVcGRhdGU7XG4gICAgICB9XG5cbiAgICAgIHF1ZXVlID0ge1xuICAgICAgICBiYXNlU3RhdGU6IGN1cnJlbnRRdWV1ZS5iYXNlU3RhdGUsXG4gICAgICAgIGZpcnN0QmFzZVVwZGF0ZTogbmV3Rmlyc3QsXG4gICAgICAgIGxhc3RCYXNlVXBkYXRlOiBuZXdMYXN0LFxuICAgICAgICBzaGFyZWQ6IGN1cnJlbnRRdWV1ZS5zaGFyZWQsXG4gICAgICAgIGVmZmVjdHM6IGN1cnJlbnRRdWV1ZS5lZmZlY3RzXG4gICAgICB9O1xuICAgICAgd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWUgPSBxdWV1ZTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH0gLy8gQXBwZW5kIHRoZSB1cGRhdGUgdG8gdGhlIGVuZCBvZiB0aGUgbGlzdC5cblxuXG4gIHZhciBsYXN0QmFzZVVwZGF0ZSA9IHF1ZXVlLmxhc3RCYXNlVXBkYXRlO1xuXG4gIGlmIChsYXN0QmFzZVVwZGF0ZSA9PT0gbnVsbCkge1xuICAgIHF1ZXVlLmZpcnN0QmFzZVVwZGF0ZSA9IGNhcHR1cmVkVXBkYXRlO1xuICB9IGVsc2Uge1xuICAgIGxhc3RCYXNlVXBkYXRlLm5leHQgPSBjYXB0dXJlZFVwZGF0ZTtcbiAgfVxuXG4gIHF1ZXVlLmxhc3RCYXNlVXBkYXRlID0gY2FwdHVyZWRVcGRhdGU7XG59XG5cbmZ1bmN0aW9uIGdldFN0YXRlRnJvbVVwZGF0ZSh3b3JrSW5Qcm9ncmVzcywgcXVldWUsIHVwZGF0ZSwgcHJldlN0YXRlLCBuZXh0UHJvcHMsIGluc3RhbmNlKSB7XG4gIHN3aXRjaCAodXBkYXRlLnRhZykge1xuICAgIGNhc2UgUmVwbGFjZVN0YXRlOlxuICAgICAge1xuICAgICAgICB2YXIgcGF5bG9hZCA9IHVwZGF0ZS5wYXlsb2FkO1xuXG4gICAgICAgIGlmICh0eXBlb2YgcGF5bG9hZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIC8vIFVwZGF0ZXIgZnVuY3Rpb25cbiAgICAgICAgICB7XG4gICAgICAgICAgICBlbnRlckRpc2FsbG93ZWRDb250ZXh0UmVhZEluREVWKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIG5leHRTdGF0ZSA9IHBheWxvYWQuY2FsbChpbnN0YW5jZSwgcHJldlN0YXRlLCBuZXh0UHJvcHMpO1xuXG4gICAgICAgICAge1xuICAgICAgICAgICAgaWYgKCB3b3JrSW5Qcm9ncmVzcy5tb2RlICYgU3RyaWN0TW9kZSkge1xuICAgICAgICAgICAgICBkaXNhYmxlTG9ncygpO1xuXG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcGF5bG9hZC5jYWxsKGluc3RhbmNlLCBwcmV2U3RhdGUsIG5leHRQcm9wcyk7XG4gICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgcmVlbmFibGVMb2dzKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZXhpdERpc2FsbG93ZWRDb250ZXh0UmVhZEluREVWKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIG5leHRTdGF0ZTtcbiAgICAgICAgfSAvLyBTdGF0ZSBvYmplY3RcblxuXG4gICAgICAgIHJldHVybiBwYXlsb2FkO1xuICAgICAgfVxuXG4gICAgY2FzZSBDYXB0dXJlVXBkYXRlOlxuICAgICAge1xuICAgICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyA9IHdvcmtJblByb2dyZXNzLmZsYWdzICYgflNob3VsZENhcHR1cmUgfCBEaWRDYXB0dXJlO1xuICAgICAgfVxuICAgIC8vIEludGVudGlvbmFsIGZhbGx0aHJvdWdoXG5cbiAgICBjYXNlIFVwZGF0ZVN0YXRlOlxuICAgICAge1xuICAgICAgICB2YXIgX3BheWxvYWQgPSB1cGRhdGUucGF5bG9hZDtcbiAgICAgICAgdmFyIHBhcnRpYWxTdGF0ZTtcblxuICAgICAgICBpZiAodHlwZW9mIF9wYXlsb2FkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgLy8gVXBkYXRlciBmdW5jdGlvblxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGVudGVyRGlzYWxsb3dlZENvbnRleHRSZWFkSW5ERVYoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBwYXJ0aWFsU3RhdGUgPSBfcGF5bG9hZC5jYWxsKGluc3RhbmNlLCBwcmV2U3RhdGUsIG5leHRQcm9wcyk7XG5cbiAgICAgICAgICB7XG4gICAgICAgICAgICBpZiAoIHdvcmtJblByb2dyZXNzLm1vZGUgJiBTdHJpY3RNb2RlKSB7XG4gICAgICAgICAgICAgIGRpc2FibGVMb2dzKCk7XG5cbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBfcGF5bG9hZC5jYWxsKGluc3RhbmNlLCBwcmV2U3RhdGUsIG5leHRQcm9wcyk7XG4gICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgcmVlbmFibGVMb2dzKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZXhpdERpc2FsbG93ZWRDb250ZXh0UmVhZEluREVWKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIFBhcnRpYWwgc3RhdGUgb2JqZWN0XG4gICAgICAgICAgcGFydGlhbFN0YXRlID0gX3BheWxvYWQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocGFydGlhbFN0YXRlID09PSBudWxsIHx8IHBhcnRpYWxTdGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgLy8gTnVsbCBhbmQgdW5kZWZpbmVkIGFyZSB0cmVhdGVkIGFzIG5vLW9wcy5cbiAgICAgICAgICByZXR1cm4gcHJldlN0YXRlO1xuICAgICAgICB9IC8vIE1lcmdlIHRoZSBwYXJ0aWFsIHN0YXRlIGFuZCB0aGUgcHJldmlvdXMgc3RhdGUuXG5cblxuICAgICAgICByZXR1cm4gX2Fzc2lnbih7fSwgcHJldlN0YXRlLCBwYXJ0aWFsU3RhdGUpO1xuICAgICAgfVxuXG4gICAgY2FzZSBGb3JjZVVwZGF0ZTpcbiAgICAgIHtcbiAgICAgICAgaGFzRm9yY2VVcGRhdGUgPSB0cnVlO1xuICAgICAgICByZXR1cm4gcHJldlN0YXRlO1xuICAgICAgfVxuICB9XG5cbiAgcmV0dXJuIHByZXZTdGF0ZTtcbn1cblxuZnVuY3Rpb24gcHJvY2Vzc1VwZGF0ZVF1ZXVlKHdvcmtJblByb2dyZXNzLCBwcm9wcywgaW5zdGFuY2UsIHJlbmRlckxhbmVzKSB7XG4gIC8vIFRoaXMgaXMgYWx3YXlzIG5vbi1udWxsIG9uIGEgQ2xhc3NDb21wb25lbnQgb3IgSG9zdFJvb3RcbiAgdmFyIHF1ZXVlID0gd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWU7XG4gIGhhc0ZvcmNlVXBkYXRlID0gZmFsc2U7XG5cbiAge1xuICAgIGN1cnJlbnRseVByb2Nlc3NpbmdRdWV1ZSA9IHF1ZXVlLnNoYXJlZDtcbiAgfVxuXG4gIHZhciBmaXJzdEJhc2VVcGRhdGUgPSBxdWV1ZS5maXJzdEJhc2VVcGRhdGU7XG4gIHZhciBsYXN0QmFzZVVwZGF0ZSA9IHF1ZXVlLmxhc3RCYXNlVXBkYXRlOyAvLyBDaGVjayBpZiB0aGVyZSBhcmUgcGVuZGluZyB1cGRhdGVzLiBJZiBzbywgdHJhbnNmZXIgdGhlbSB0byB0aGUgYmFzZSBxdWV1ZS5cblxuICB2YXIgcGVuZGluZ1F1ZXVlID0gcXVldWUuc2hhcmVkLnBlbmRpbmc7XG5cbiAgaWYgKHBlbmRpbmdRdWV1ZSAhPT0gbnVsbCkge1xuICAgIHF1ZXVlLnNoYXJlZC5wZW5kaW5nID0gbnVsbDsgLy8gVGhlIHBlbmRpbmcgcXVldWUgaXMgY2lyY3VsYXIuIERpc2Nvbm5lY3QgdGhlIHBvaW50ZXIgYmV0d2VlbiBmaXJzdFxuICAgIC8vIGFuZCBsYXN0IHNvIHRoYXQgaXQncyBub24tY2lyY3VsYXIuXG5cbiAgICB2YXIgbGFzdFBlbmRpbmdVcGRhdGUgPSBwZW5kaW5nUXVldWU7XG4gICAgdmFyIGZpcnN0UGVuZGluZ1VwZGF0ZSA9IGxhc3RQZW5kaW5nVXBkYXRlLm5leHQ7XG4gICAgbGFzdFBlbmRpbmdVcGRhdGUubmV4dCA9IG51bGw7IC8vIEFwcGVuZCBwZW5kaW5nIHVwZGF0ZXMgdG8gYmFzZSBxdWV1ZVxuXG4gICAgaWYgKGxhc3RCYXNlVXBkYXRlID09PSBudWxsKSB7XG4gICAgICBmaXJzdEJhc2VVcGRhdGUgPSBmaXJzdFBlbmRpbmdVcGRhdGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxhc3RCYXNlVXBkYXRlLm5leHQgPSBmaXJzdFBlbmRpbmdVcGRhdGU7XG4gICAgfVxuXG4gICAgbGFzdEJhc2VVcGRhdGUgPSBsYXN0UGVuZGluZ1VwZGF0ZTsgLy8gSWYgdGhlcmUncyBhIGN1cnJlbnQgcXVldWUsIGFuZCBpdCdzIGRpZmZlcmVudCBmcm9tIHRoZSBiYXNlIHF1ZXVlLCB0aGVuXG4gICAgLy8gd2UgbmVlZCB0byB0cmFuc2ZlciB0aGUgdXBkYXRlcyB0byB0aGF0IHF1ZXVlLCB0b28uIEJlY2F1c2UgdGhlIGJhc2VcbiAgICAvLyBxdWV1ZSBpcyBhIHNpbmdseS1saW5rZWQgbGlzdCB3aXRoIG5vIGN5Y2xlcywgd2UgY2FuIGFwcGVuZCB0byBib3RoXG4gICAgLy8gbGlzdHMgYW5kIHRha2UgYWR2YW50YWdlIG9mIHN0cnVjdHVyYWwgc2hhcmluZy5cbiAgICAvLyBUT0RPOiBQYXNzIGBjdXJyZW50YCBhcyBhcmd1bWVudFxuXG4gICAgdmFyIGN1cnJlbnQgPSB3b3JrSW5Qcm9ncmVzcy5hbHRlcm5hdGU7XG5cbiAgICBpZiAoY3VycmVudCAhPT0gbnVsbCkge1xuICAgICAgLy8gVGhpcyBpcyBhbHdheXMgbm9uLW51bGwgb24gYSBDbGFzc0NvbXBvbmVudCBvciBIb3N0Um9vdFxuICAgICAgdmFyIGN1cnJlbnRRdWV1ZSA9IGN1cnJlbnQudXBkYXRlUXVldWU7XG4gICAgICB2YXIgY3VycmVudExhc3RCYXNlVXBkYXRlID0gY3VycmVudFF1ZXVlLmxhc3RCYXNlVXBkYXRlO1xuXG4gICAgICBpZiAoY3VycmVudExhc3RCYXNlVXBkYXRlICE9PSBsYXN0QmFzZVVwZGF0ZSkge1xuICAgICAgICBpZiAoY3VycmVudExhc3RCYXNlVXBkYXRlID09PSBudWxsKSB7XG4gICAgICAgICAgY3VycmVudFF1ZXVlLmZpcnN0QmFzZVVwZGF0ZSA9IGZpcnN0UGVuZGluZ1VwZGF0ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjdXJyZW50TGFzdEJhc2VVcGRhdGUubmV4dCA9IGZpcnN0UGVuZGluZ1VwZGF0ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGN1cnJlbnRRdWV1ZS5sYXN0QmFzZVVwZGF0ZSA9IGxhc3RQZW5kaW5nVXBkYXRlO1xuICAgICAgfVxuICAgIH1cbiAgfSAvLyBUaGVzZSB2YWx1ZXMgbWF5IGNoYW5nZSBhcyB3ZSBwcm9jZXNzIHRoZSBxdWV1ZS5cblxuXG4gIGlmIChmaXJzdEJhc2VVcGRhdGUgIT09IG51bGwpIHtcbiAgICAvLyBJdGVyYXRlIHRocm91Z2ggdGhlIGxpc3Qgb2YgdXBkYXRlcyB0byBjb21wdXRlIHRoZSByZXN1bHQuXG4gICAgdmFyIG5ld1N0YXRlID0gcXVldWUuYmFzZVN0YXRlOyAvLyBUT0RPOiBEb24ndCBuZWVkIHRvIGFjY3VtdWxhdGUgdGhpcy4gSW5zdGVhZCwgd2UgY2FuIHJlbW92ZSByZW5kZXJMYW5lc1xuICAgIC8vIGZyb20gdGhlIG9yaWdpbmFsIGxhbmVzLlxuXG4gICAgdmFyIG5ld0xhbmVzID0gTm9MYW5lcztcbiAgICB2YXIgbmV3QmFzZVN0YXRlID0gbnVsbDtcbiAgICB2YXIgbmV3Rmlyc3RCYXNlVXBkYXRlID0gbnVsbDtcbiAgICB2YXIgbmV3TGFzdEJhc2VVcGRhdGUgPSBudWxsO1xuICAgIHZhciB1cGRhdGUgPSBmaXJzdEJhc2VVcGRhdGU7XG5cbiAgICBkbyB7XG4gICAgICB2YXIgdXBkYXRlTGFuZSA9IHVwZGF0ZS5sYW5lO1xuICAgICAgdmFyIHVwZGF0ZUV2ZW50VGltZSA9IHVwZGF0ZS5ldmVudFRpbWU7XG5cbiAgICAgIGlmICghaXNTdWJzZXRPZkxhbmVzKHJlbmRlckxhbmVzLCB1cGRhdGVMYW5lKSkge1xuICAgICAgICAvLyBQcmlvcml0eSBpcyBpbnN1ZmZpY2llbnQuIFNraXAgdGhpcyB1cGRhdGUuIElmIHRoaXMgaXMgdGhlIGZpcnN0XG4gICAgICAgIC8vIHNraXBwZWQgdXBkYXRlLCB0aGUgcHJldmlvdXMgdXBkYXRlL3N0YXRlIGlzIHRoZSBuZXcgYmFzZVxuICAgICAgICAvLyB1cGRhdGUvc3RhdGUuXG4gICAgICAgIHZhciBjbG9uZSA9IHtcbiAgICAgICAgICBldmVudFRpbWU6IHVwZGF0ZUV2ZW50VGltZSxcbiAgICAgICAgICBsYW5lOiB1cGRhdGVMYW5lLFxuICAgICAgICAgIHRhZzogdXBkYXRlLnRhZyxcbiAgICAgICAgICBwYXlsb2FkOiB1cGRhdGUucGF5bG9hZCxcbiAgICAgICAgICBjYWxsYmFjazogdXBkYXRlLmNhbGxiYWNrLFxuICAgICAgICAgIG5leHQ6IG51bGxcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAobmV3TGFzdEJhc2VVcGRhdGUgPT09IG51bGwpIHtcbiAgICAgICAgICBuZXdGaXJzdEJhc2VVcGRhdGUgPSBuZXdMYXN0QmFzZVVwZGF0ZSA9IGNsb25lO1xuICAgICAgICAgIG5ld0Jhc2VTdGF0ZSA9IG5ld1N0YXRlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5ld0xhc3RCYXNlVXBkYXRlID0gbmV3TGFzdEJhc2VVcGRhdGUubmV4dCA9IGNsb25lO1xuICAgICAgICB9IC8vIFVwZGF0ZSB0aGUgcmVtYWluaW5nIHByaW9yaXR5IGluIHRoZSBxdWV1ZS5cblxuXG4gICAgICAgIG5ld0xhbmVzID0gbWVyZ2VMYW5lcyhuZXdMYW5lcywgdXBkYXRlTGFuZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBUaGlzIHVwZGF0ZSBkb2VzIGhhdmUgc3VmZmljaWVudCBwcmlvcml0eS5cbiAgICAgICAgaWYgKG5ld0xhc3RCYXNlVXBkYXRlICE9PSBudWxsKSB7XG4gICAgICAgICAgdmFyIF9jbG9uZSA9IHtcbiAgICAgICAgICAgIGV2ZW50VGltZTogdXBkYXRlRXZlbnRUaW1lLFxuICAgICAgICAgICAgLy8gVGhpcyB1cGRhdGUgaXMgZ29pbmcgdG8gYmUgY29tbWl0dGVkIHNvIHdlIG5ldmVyIHdhbnQgdW5jb21taXRcbiAgICAgICAgICAgIC8vIGl0LiBVc2luZyBOb0xhbmUgd29ya3MgYmVjYXVzZSAwIGlzIGEgc3Vic2V0IG9mIGFsbCBiaXRtYXNrcywgc29cbiAgICAgICAgICAgIC8vIHRoaXMgd2lsbCBuZXZlciBiZSBza2lwcGVkIGJ5IHRoZSBjaGVjayBhYm92ZS5cbiAgICAgICAgICAgIGxhbmU6IE5vTGFuZSxcbiAgICAgICAgICAgIHRhZzogdXBkYXRlLnRhZyxcbiAgICAgICAgICAgIHBheWxvYWQ6IHVwZGF0ZS5wYXlsb2FkLFxuICAgICAgICAgICAgY2FsbGJhY2s6IHVwZGF0ZS5jYWxsYmFjayxcbiAgICAgICAgICAgIG5leHQ6IG51bGxcbiAgICAgICAgICB9O1xuICAgICAgICAgIG5ld0xhc3RCYXNlVXBkYXRlID0gbmV3TGFzdEJhc2VVcGRhdGUubmV4dCA9IF9jbG9uZTtcbiAgICAgICAgfSAvLyBQcm9jZXNzIHRoaXMgdXBkYXRlLlxuXG5cbiAgICAgICAgbmV3U3RhdGUgPSBnZXRTdGF0ZUZyb21VcGRhdGUod29ya0luUHJvZ3Jlc3MsIHF1ZXVlLCB1cGRhdGUsIG5ld1N0YXRlLCBwcm9wcywgaW5zdGFuY2UpO1xuICAgICAgICB2YXIgY2FsbGJhY2sgPSB1cGRhdGUuY2FsbGJhY2s7XG5cbiAgICAgICAgaWYgKGNhbGxiYWNrICE9PSBudWxsKSB7XG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gQ2FsbGJhY2s7XG4gICAgICAgICAgdmFyIGVmZmVjdHMgPSBxdWV1ZS5lZmZlY3RzO1xuXG4gICAgICAgICAgaWYgKGVmZmVjdHMgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHF1ZXVlLmVmZmVjdHMgPSBbdXBkYXRlXTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZWZmZWN0cy5wdXNoKHVwZGF0ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHVwZGF0ZSA9IHVwZGF0ZS5uZXh0O1xuXG4gICAgICBpZiAodXBkYXRlID09PSBudWxsKSB7XG4gICAgICAgIHBlbmRpbmdRdWV1ZSA9IHF1ZXVlLnNoYXJlZC5wZW5kaW5nO1xuXG4gICAgICAgIGlmIChwZW5kaW5nUXVldWUgPT09IG51bGwpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBBbiB1cGRhdGUgd2FzIHNjaGVkdWxlZCBmcm9tIGluc2lkZSBhIHJlZHVjZXIuIEFkZCB0aGUgbmV3XG4gICAgICAgICAgLy8gcGVuZGluZyB1cGRhdGVzIHRvIHRoZSBlbmQgb2YgdGhlIGxpc3QgYW5kIGtlZXAgcHJvY2Vzc2luZy5cbiAgICAgICAgICB2YXIgX2xhc3RQZW5kaW5nVXBkYXRlID0gcGVuZGluZ1F1ZXVlOyAvLyBJbnRlbnRpb25hbGx5IHVuc291bmQuIFBlbmRpbmcgdXBkYXRlcyBmb3JtIGEgY2lyY3VsYXIgbGlzdCwgYnV0IHdlXG4gICAgICAgICAgLy8gdW5yYXZlbCB0aGVtIHdoZW4gdHJhbnNmZXJyaW5nIHRoZW0gdG8gdGhlIGJhc2UgcXVldWUuXG5cbiAgICAgICAgICB2YXIgX2ZpcnN0UGVuZGluZ1VwZGF0ZSA9IF9sYXN0UGVuZGluZ1VwZGF0ZS5uZXh0O1xuICAgICAgICAgIF9sYXN0UGVuZGluZ1VwZGF0ZS5uZXh0ID0gbnVsbDtcbiAgICAgICAgICB1cGRhdGUgPSBfZmlyc3RQZW5kaW5nVXBkYXRlO1xuICAgICAgICAgIHF1ZXVlLmxhc3RCYXNlVXBkYXRlID0gX2xhc3RQZW5kaW5nVXBkYXRlO1xuICAgICAgICAgIHF1ZXVlLnNoYXJlZC5wZW5kaW5nID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gd2hpbGUgKHRydWUpO1xuXG4gICAgaWYgKG5ld0xhc3RCYXNlVXBkYXRlID09PSBudWxsKSB7XG4gICAgICBuZXdCYXNlU3RhdGUgPSBuZXdTdGF0ZTtcbiAgICB9XG5cbiAgICBxdWV1ZS5iYXNlU3RhdGUgPSBuZXdCYXNlU3RhdGU7XG4gICAgcXVldWUuZmlyc3RCYXNlVXBkYXRlID0gbmV3Rmlyc3RCYXNlVXBkYXRlO1xuICAgIHF1ZXVlLmxhc3RCYXNlVXBkYXRlID0gbmV3TGFzdEJhc2VVcGRhdGU7IC8vIFNldCB0aGUgcmVtYWluaW5nIGV4cGlyYXRpb24gdGltZSB0byBiZSB3aGF0ZXZlciBpcyByZW1haW5pbmcgaW4gdGhlIHF1ZXVlLlxuICAgIC8vIFRoaXMgc2hvdWxkIGJlIGZpbmUgYmVjYXVzZSB0aGUgb25seSB0d28gb3RoZXIgdGhpbmdzIHRoYXQgY29udHJpYnV0ZSB0b1xuICAgIC8vIGV4cGlyYXRpb24gdGltZSBhcmUgcHJvcHMgYW5kIGNvbnRleHQuIFdlJ3JlIGFscmVhZHkgaW4gdGhlIG1pZGRsZSBvZiB0aGVcbiAgICAvLyBiZWdpbiBwaGFzZSBieSB0aGUgdGltZSB3ZSBzdGFydCBwcm9jZXNzaW5nIHRoZSBxdWV1ZSwgc28gd2UndmUgYWxyZWFkeVxuICAgIC8vIGRlYWx0IHdpdGggdGhlIHByb3BzLiBDb250ZXh0IGluIGNvbXBvbmVudHMgdGhhdCBzcGVjaWZ5XG4gICAgLy8gc2hvdWxkQ29tcG9uZW50VXBkYXRlIGlzIHRyaWNreTsgYnV0IHdlJ2xsIGhhdmUgdG8gYWNjb3VudCBmb3JcbiAgICAvLyB0aGF0IHJlZ2FyZGxlc3MuXG5cbiAgICBtYXJrU2tpcHBlZFVwZGF0ZUxhbmVzKG5ld0xhbmVzKTtcbiAgICB3b3JrSW5Qcm9ncmVzcy5sYW5lcyA9IG5ld0xhbmVzO1xuICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBuZXdTdGF0ZTtcbiAgfVxuXG4gIHtcbiAgICBjdXJyZW50bHlQcm9jZXNzaW5nUXVldWUgPSBudWxsO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNhbGxDYWxsYmFjayhjYWxsYmFjaywgY29udGV4dCkge1xuICBpZiAoISh0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpKSB7XG4gICAge1xuICAgICAgdGhyb3cgRXJyb3IoIFwiSW52YWxpZCBhcmd1bWVudCBwYXNzZWQgYXMgY2FsbGJhY2suIEV4cGVjdGVkIGEgZnVuY3Rpb24uIEluc3RlYWQgcmVjZWl2ZWQ6IFwiICsgY2FsbGJhY2sgKTtcbiAgICB9XG4gIH1cblxuICBjYWxsYmFjay5jYWxsKGNvbnRleHQpO1xufVxuXG5mdW5jdGlvbiByZXNldEhhc0ZvcmNlVXBkYXRlQmVmb3JlUHJvY2Vzc2luZygpIHtcbiAgaGFzRm9yY2VVcGRhdGUgPSBmYWxzZTtcbn1cbmZ1bmN0aW9uIGNoZWNrSGFzRm9yY2VVcGRhdGVBZnRlclByb2Nlc3NpbmcoKSB7XG4gIHJldHVybiBoYXNGb3JjZVVwZGF0ZTtcbn1cbmZ1bmN0aW9uIGNvbW1pdFVwZGF0ZVF1ZXVlKGZpbmlzaGVkV29yaywgZmluaXNoZWRRdWV1ZSwgaW5zdGFuY2UpIHtcbiAgLy8gQ29tbWl0IHRoZSBlZmZlY3RzXG4gIHZhciBlZmZlY3RzID0gZmluaXNoZWRRdWV1ZS5lZmZlY3RzO1xuICBmaW5pc2hlZFF1ZXVlLmVmZmVjdHMgPSBudWxsO1xuXG4gIGlmIChlZmZlY3RzICE9PSBudWxsKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlZmZlY3RzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZWZmZWN0ID0gZWZmZWN0c1tpXTtcbiAgICAgIHZhciBjYWxsYmFjayA9IGVmZmVjdC5jYWxsYmFjaztcblxuICAgICAgaWYgKGNhbGxiYWNrICE9PSBudWxsKSB7XG4gICAgICAgIGVmZmVjdC5jYWxsYmFjayA9IG51bGw7XG4gICAgICAgIGNhbGxDYWxsYmFjayhjYWxsYmFjaywgaW5zdGFuY2UpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG52YXIgZmFrZUludGVybmFsSW5zdGFuY2UgPSB7fTtcbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheTsgLy8gUmVhY3QuQ29tcG9uZW50IHVzZXMgYSBzaGFyZWQgZnJvemVuIG9iamVjdCBieSBkZWZhdWx0LlxuLy8gV2UnbGwgdXNlIGl0IHRvIGRldGVybWluZSB3aGV0aGVyIHdlIG5lZWQgdG8gaW5pdGlhbGl6ZSBsZWdhY3kgcmVmcy5cblxudmFyIGVtcHR5UmVmc09iamVjdCA9IG5ldyBSZWFjdC5Db21wb25lbnQoKS5yZWZzO1xudmFyIGRpZFdhcm5BYm91dFN0YXRlQXNzaWdubWVudEZvckNvbXBvbmVudDtcbnZhciBkaWRXYXJuQWJvdXRVbmluaXRpYWxpemVkU3RhdGU7XG52YXIgZGlkV2FybkFib3V0R2V0U25hcHNob3RCZWZvcmVVcGRhdGVXaXRob3V0RGlkVXBkYXRlO1xudmFyIGRpZFdhcm5BYm91dExlZ2FjeUxpZmVjeWNsZXNBbmREZXJpdmVkU3RhdGU7XG52YXIgZGlkV2FybkFib3V0VW5kZWZpbmVkRGVyaXZlZFN0YXRlO1xudmFyIHdhcm5PblVuZGVmaW5lZERlcml2ZWRTdGF0ZTtcbnZhciB3YXJuT25JbnZhbGlkQ2FsbGJhY2s7XG52YXIgZGlkV2FybkFib3V0RGlyZWN0bHlBc3NpZ25pbmdQcm9wc1RvU3RhdGU7XG52YXIgZGlkV2FybkFib3V0Q29udGV4dFR5cGVBbmRDb250ZXh0VHlwZXM7XG52YXIgZGlkV2FybkFib3V0SW52YWxpZGF0ZUNvbnRleHRUeXBlO1xuXG57XG4gIGRpZFdhcm5BYm91dFN0YXRlQXNzaWdubWVudEZvckNvbXBvbmVudCA9IG5ldyBTZXQoKTtcbiAgZGlkV2FybkFib3V0VW5pbml0aWFsaXplZFN0YXRlID0gbmV3IFNldCgpO1xuICBkaWRXYXJuQWJvdXRHZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZVdpdGhvdXREaWRVcGRhdGUgPSBuZXcgU2V0KCk7XG4gIGRpZFdhcm5BYm91dExlZ2FjeUxpZmVjeWNsZXNBbmREZXJpdmVkU3RhdGUgPSBuZXcgU2V0KCk7XG4gIGRpZFdhcm5BYm91dERpcmVjdGx5QXNzaWduaW5nUHJvcHNUb1N0YXRlID0gbmV3IFNldCgpO1xuICBkaWRXYXJuQWJvdXRVbmRlZmluZWREZXJpdmVkU3RhdGUgPSBuZXcgU2V0KCk7XG4gIGRpZFdhcm5BYm91dENvbnRleHRUeXBlQW5kQ29udGV4dFR5cGVzID0gbmV3IFNldCgpO1xuICBkaWRXYXJuQWJvdXRJbnZhbGlkYXRlQ29udGV4dFR5cGUgPSBuZXcgU2V0KCk7XG4gIHZhciBkaWRXYXJuT25JbnZhbGlkQ2FsbGJhY2sgPSBuZXcgU2V0KCk7XG5cbiAgd2Fybk9uSW52YWxpZENhbGxiYWNrID0gZnVuY3Rpb24gKGNhbGxiYWNrLCBjYWxsZXJOYW1lKSB7XG4gICAgaWYgKGNhbGxiYWNrID09PSBudWxsIHx8IHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBrZXkgPSBjYWxsZXJOYW1lICsgJ18nICsgY2FsbGJhY2s7XG5cbiAgICBpZiAoIWRpZFdhcm5PbkludmFsaWRDYWxsYmFjay5oYXMoa2V5KSkge1xuICAgICAgZGlkV2Fybk9uSW52YWxpZENhbGxiYWNrLmFkZChrZXkpO1xuXG4gICAgICBlcnJvcignJXMoLi4uKTogRXhwZWN0ZWQgdGhlIGxhc3Qgb3B0aW9uYWwgYGNhbGxiYWNrYCBhcmd1bWVudCB0byBiZSBhICcgKyAnZnVuY3Rpb24uIEluc3RlYWQgcmVjZWl2ZWQ6ICVzLicsIGNhbGxlck5hbWUsIGNhbGxiYWNrKTtcbiAgICB9XG4gIH07XG5cbiAgd2Fybk9uVW5kZWZpbmVkRGVyaXZlZFN0YXRlID0gZnVuY3Rpb24gKHR5cGUsIHBhcnRpYWxTdGF0ZSkge1xuICAgIGlmIChwYXJ0aWFsU3RhdGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lKHR5cGUpIHx8ICdDb21wb25lbnQnO1xuXG4gICAgICBpZiAoIWRpZFdhcm5BYm91dFVuZGVmaW5lZERlcml2ZWRTdGF0ZS5oYXMoY29tcG9uZW50TmFtZSkpIHtcbiAgICAgICAgZGlkV2FybkFib3V0VW5kZWZpbmVkRGVyaXZlZFN0YXRlLmFkZChjb21wb25lbnROYW1lKTtcblxuICAgICAgICBlcnJvcignJXMuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzKCk6IEEgdmFsaWQgc3RhdGUgb2JqZWN0IChvciBudWxsKSBtdXN0IGJlIHJldHVybmVkLiAnICsgJ1lvdSBoYXZlIHJldHVybmVkIHVuZGVmaW5lZC4nLCBjb21wb25lbnROYW1lKTtcbiAgICAgIH1cbiAgICB9XG4gIH07IC8vIFRoaXMgaXMgc28gZ3Jvc3MgYnV0IGl0J3MgYXQgbGVhc3Qgbm9uLWNyaXRpY2FsIGFuZCBjYW4gYmUgcmVtb3ZlZCBpZlxuICAvLyBpdCBjYXVzZXMgcHJvYmxlbXMuIFRoaXMgaXMgbWVhbnQgdG8gZ2l2ZSBhIG5pY2VyIGVycm9yIG1lc3NhZ2UgZm9yXG4gIC8vIFJlYWN0RE9NMTUudW5zdGFibGVfcmVuZGVyU3VidHJlZUludG9Db250YWluZXIocmVhY3RET00xNkNvbXBvbmVudCxcbiAgLy8gLi4uKSkgd2hpY2ggb3RoZXJ3aXNlIHRocm93cyBhIFwiX3Byb2Nlc3NDaGlsZENvbnRleHQgaXMgbm90IGEgZnVuY3Rpb25cIlxuICAvLyBleGNlcHRpb24uXG5cblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZmFrZUludGVybmFsSW5zdGFuY2UsICdfcHJvY2Vzc0NoaWxkQ29udGV4dCcsIHtcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAge1xuICAgICAgICB7XG4gICAgICAgICAgdGhyb3cgRXJyb3IoIFwiX3Byb2Nlc3NDaGlsZENvbnRleHQgaXMgbm90IGF2YWlsYWJsZSBpbiBSZWFjdCAxNisuIFRoaXMgbGlrZWx5IG1lYW5zIHlvdSBoYXZlIG11bHRpcGxlIGNvcGllcyBvZiBSZWFjdCBhbmQgYXJlIGF0dGVtcHRpbmcgdG8gbmVzdCBhIFJlYWN0IDE1IHRyZWUgaW5zaWRlIGEgUmVhY3QgMTYgdHJlZSB1c2luZyB1bnN0YWJsZV9yZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lciwgd2hpY2ggaXNuJ3Qgc3VwcG9ydGVkLiBUcnkgdG8gbWFrZSBzdXJlIHlvdSBoYXZlIG9ubHkgb25lIGNvcHkgb2YgUmVhY3QgKGFuZCBpZGVhbGx5LCBzd2l0Y2ggdG8gUmVhY3RET00uY3JlYXRlUG9ydGFsKS5cIiApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgT2JqZWN0LmZyZWV6ZShmYWtlSW50ZXJuYWxJbnN0YW5jZSk7XG59XG5cbmZ1bmN0aW9uIGFwcGx5RGVyaXZlZFN0YXRlRnJvbVByb3BzKHdvcmtJblByb2dyZXNzLCBjdG9yLCBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMsIG5leHRQcm9wcykge1xuICB2YXIgcHJldlN0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcblxuICB7XG4gICAgaWYgKCB3b3JrSW5Qcm9ncmVzcy5tb2RlICYgU3RyaWN0TW9kZSkge1xuICAgICAgZGlzYWJsZUxvZ3MoKTtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gSW52b2tlIHRoZSBmdW5jdGlvbiBhbiBleHRyYSB0aW1lIHRvIGhlbHAgZGV0ZWN0IHNpZGUtZWZmZWN0cy5cbiAgICAgICAgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzKG5leHRQcm9wcywgcHJldlN0YXRlKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHJlZW5hYmxlTG9ncygpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciBwYXJ0aWFsU3RhdGUgPSBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMobmV4dFByb3BzLCBwcmV2U3RhdGUpO1xuXG4gIHtcbiAgICB3YXJuT25VbmRlZmluZWREZXJpdmVkU3RhdGUoY3RvciwgcGFydGlhbFN0YXRlKTtcbiAgfSAvLyBNZXJnZSB0aGUgcGFydGlhbCBzdGF0ZSBhbmQgdGhlIHByZXZpb3VzIHN0YXRlLlxuXG5cbiAgdmFyIG1lbW9pemVkU3RhdGUgPSBwYXJ0aWFsU3RhdGUgPT09IG51bGwgfHwgcGFydGlhbFN0YXRlID09PSB1bmRlZmluZWQgPyBwcmV2U3RhdGUgOiBfYXNzaWduKHt9LCBwcmV2U3RhdGUsIHBhcnRpYWxTdGF0ZSk7XG4gIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBtZW1vaXplZFN0YXRlOyAvLyBPbmNlIHRoZSB1cGRhdGUgcXVldWUgaXMgZW1wdHksIHBlcnNpc3QgdGhlIGRlcml2ZWQgc3RhdGUgb250byB0aGVcbiAgLy8gYmFzZSBzdGF0ZS5cblxuICBpZiAod29ya0luUHJvZ3Jlc3MubGFuZXMgPT09IE5vTGFuZXMpIHtcbiAgICAvLyBRdWV1ZSBpcyBhbHdheXMgbm9uLW51bGwgZm9yIGNsYXNzZXNcbiAgICB2YXIgdXBkYXRlUXVldWUgPSB3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZTtcbiAgICB1cGRhdGVRdWV1ZS5iYXNlU3RhdGUgPSBtZW1vaXplZFN0YXRlO1xuICB9XG59XG52YXIgY2xhc3NDb21wb25lbnRVcGRhdGVyID0ge1xuICBpc01vdW50ZWQ6IGlzTW91bnRlZCxcbiAgZW5xdWV1ZVNldFN0YXRlOiBmdW5jdGlvbiAoaW5zdCwgcGF5bG9hZCwgY2FsbGJhY2spIHtcbiAgICB2YXIgZmliZXIgPSBnZXQoaW5zdCk7XG4gICAgdmFyIGV2ZW50VGltZSA9IHJlcXVlc3RFdmVudFRpbWUoKTtcbiAgICB2YXIgbGFuZSA9IHJlcXVlc3RVcGRhdGVMYW5lKGZpYmVyKTtcbiAgICB2YXIgdXBkYXRlID0gY3JlYXRlVXBkYXRlKGV2ZW50VGltZSwgbGFuZSk7XG4gICAgdXBkYXRlLnBheWxvYWQgPSBwYXlsb2FkO1xuXG4gICAgaWYgKGNhbGxiYWNrICE9PSB1bmRlZmluZWQgJiYgY2FsbGJhY2sgIT09IG51bGwpIHtcbiAgICAgIHtcbiAgICAgICAgd2Fybk9uSW52YWxpZENhbGxiYWNrKGNhbGxiYWNrLCAnc2V0U3RhdGUnKTtcbiAgICAgIH1cblxuICAgICAgdXBkYXRlLmNhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgfVxuXG4gICAgZW5xdWV1ZVVwZGF0ZShmaWJlciwgdXBkYXRlKTtcbiAgICBzY2hlZHVsZVVwZGF0ZU9uRmliZXIoZmliZXIsIGxhbmUsIGV2ZW50VGltZSk7XG4gIH0sXG4gIGVucXVldWVSZXBsYWNlU3RhdGU6IGZ1bmN0aW9uIChpbnN0LCBwYXlsb2FkLCBjYWxsYmFjaykge1xuICAgIHZhciBmaWJlciA9IGdldChpbnN0KTtcbiAgICB2YXIgZXZlbnRUaW1lID0gcmVxdWVzdEV2ZW50VGltZSgpO1xuICAgIHZhciBsYW5lID0gcmVxdWVzdFVwZGF0ZUxhbmUoZmliZXIpO1xuICAgIHZhciB1cGRhdGUgPSBjcmVhdGVVcGRhdGUoZXZlbnRUaW1lLCBsYW5lKTtcbiAgICB1cGRhdGUudGFnID0gUmVwbGFjZVN0YXRlO1xuICAgIHVwZGF0ZS5wYXlsb2FkID0gcGF5bG9hZDtcblxuICAgIGlmIChjYWxsYmFjayAhPT0gdW5kZWZpbmVkICYmIGNhbGxiYWNrICE9PSBudWxsKSB7XG4gICAgICB7XG4gICAgICAgIHdhcm5PbkludmFsaWRDYWxsYmFjayhjYWxsYmFjaywgJ3JlcGxhY2VTdGF0ZScpO1xuICAgICAgfVxuXG4gICAgICB1cGRhdGUuY2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICB9XG5cbiAgICBlbnF1ZXVlVXBkYXRlKGZpYmVyLCB1cGRhdGUpO1xuICAgIHNjaGVkdWxlVXBkYXRlT25GaWJlcihmaWJlciwgbGFuZSwgZXZlbnRUaW1lKTtcbiAgfSxcbiAgZW5xdWV1ZUZvcmNlVXBkYXRlOiBmdW5jdGlvbiAoaW5zdCwgY2FsbGJhY2spIHtcbiAgICB2YXIgZmliZXIgPSBnZXQoaW5zdCk7XG4gICAgdmFyIGV2ZW50VGltZSA9IHJlcXVlc3RFdmVudFRpbWUoKTtcbiAgICB2YXIgbGFuZSA9IHJlcXVlc3RVcGRhdGVMYW5lKGZpYmVyKTtcbiAgICB2YXIgdXBkYXRlID0gY3JlYXRlVXBkYXRlKGV2ZW50VGltZSwgbGFuZSk7XG4gICAgdXBkYXRlLnRhZyA9IEZvcmNlVXBkYXRlO1xuXG4gICAgaWYgKGNhbGxiYWNrICE9PSB1bmRlZmluZWQgJiYgY2FsbGJhY2sgIT09IG51bGwpIHtcbiAgICAgIHtcbiAgICAgICAgd2Fybk9uSW52YWxpZENhbGxiYWNrKGNhbGxiYWNrLCAnZm9yY2VVcGRhdGUnKTtcbiAgICAgIH1cblxuICAgICAgdXBkYXRlLmNhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgfVxuXG4gICAgZW5xdWV1ZVVwZGF0ZShmaWJlciwgdXBkYXRlKTtcbiAgICBzY2hlZHVsZVVwZGF0ZU9uRmliZXIoZmliZXIsIGxhbmUsIGV2ZW50VGltZSk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGNoZWNrU2hvdWxkQ29tcG9uZW50VXBkYXRlKHdvcmtJblByb2dyZXNzLCBjdG9yLCBvbGRQcm9wcywgbmV3UHJvcHMsIG9sZFN0YXRlLCBuZXdTdGF0ZSwgbmV4dENvbnRleHQpIHtcbiAgdmFyIGluc3RhbmNlID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuXG4gIGlmICh0eXBlb2YgaW5zdGFuY2Uuc2hvdWxkQ29tcG9uZW50VXBkYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAge1xuICAgICAgaWYgKCB3b3JrSW5Qcm9ncmVzcy5tb2RlICYgU3RyaWN0TW9kZSkge1xuICAgICAgICBkaXNhYmxlTG9ncygpO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgLy8gSW52b2tlIHRoZSBmdW5jdGlvbiBhbiBleHRyYSB0aW1lIHRvIGhlbHAgZGV0ZWN0IHNpZGUtZWZmZWN0cy5cbiAgICAgICAgICBpbnN0YW5jZS5zaG91bGRDb21wb25lbnRVcGRhdGUobmV3UHJvcHMsIG5ld1N0YXRlLCBuZXh0Q29udGV4dCk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgcmVlbmFibGVMb2dzKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgc2hvdWxkVXBkYXRlID0gaW5zdGFuY2Uuc2hvdWxkQ29tcG9uZW50VXBkYXRlKG5ld1Byb3BzLCBuZXdTdGF0ZSwgbmV4dENvbnRleHQpO1xuXG4gICAge1xuICAgICAgaWYgKHNob3VsZFVwZGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGVycm9yKCclcy5zaG91bGRDb21wb25lbnRVcGRhdGUoKTogUmV0dXJuZWQgdW5kZWZpbmVkIGluc3RlYWQgb2YgYSAnICsgJ2Jvb2xlYW4gdmFsdWUuIE1ha2Ugc3VyZSB0byByZXR1cm4gdHJ1ZSBvciBmYWxzZS4nLCBnZXRDb21wb25lbnROYW1lKGN0b3IpIHx8ICdDb21wb25lbnQnKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gc2hvdWxkVXBkYXRlO1xuICB9XG5cbiAgaWYgKGN0b3IucHJvdG90eXBlICYmIGN0b3IucHJvdG90eXBlLmlzUHVyZVJlYWN0Q29tcG9uZW50KSB7XG4gICAgcmV0dXJuICFzaGFsbG93RXF1YWwob2xkUHJvcHMsIG5ld1Byb3BzKSB8fCAhc2hhbGxvd0VxdWFsKG9sZFN0YXRlLCBuZXdTdGF0ZSk7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gY2hlY2tDbGFzc0luc3RhbmNlKHdvcmtJblByb2dyZXNzLCBjdG9yLCBuZXdQcm9wcykge1xuICB2YXIgaW5zdGFuY2UgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG5cbiAge1xuICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZShjdG9yKSB8fCAnQ29tcG9uZW50JztcbiAgICB2YXIgcmVuZGVyUHJlc2VudCA9IGluc3RhbmNlLnJlbmRlcjtcblxuICAgIGlmICghcmVuZGVyUHJlc2VudCkge1xuICAgICAgaWYgKGN0b3IucHJvdG90eXBlICYmIHR5cGVvZiBjdG9yLnByb3RvdHlwZS5yZW5kZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgZXJyb3IoJyVzKC4uLik6IE5vIGByZW5kZXJgIG1ldGhvZCBmb3VuZCBvbiB0aGUgcmV0dXJuZWQgY29tcG9uZW50ICcgKyAnaW5zdGFuY2U6IGRpZCB5b3UgYWNjaWRlbnRhbGx5IHJldHVybiBhbiBvYmplY3QgZnJvbSB0aGUgY29uc3RydWN0b3I/JywgbmFtZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlcnJvcignJXMoLi4uKTogTm8gYHJlbmRlcmAgbWV0aG9kIGZvdW5kIG9uIHRoZSByZXR1cm5lZCBjb21wb25lbnQgJyArICdpbnN0YW5jZTogeW91IG1heSBoYXZlIGZvcmdvdHRlbiB0byBkZWZpbmUgYHJlbmRlcmAuJywgbmFtZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGluc3RhbmNlLmdldEluaXRpYWxTdGF0ZSAmJiAhaW5zdGFuY2UuZ2V0SW5pdGlhbFN0YXRlLmlzUmVhY3RDbGFzc0FwcHJvdmVkICYmICFpbnN0YW5jZS5zdGF0ZSkge1xuICAgICAgZXJyb3IoJ2dldEluaXRpYWxTdGF0ZSB3YXMgZGVmaW5lZCBvbiAlcywgYSBwbGFpbiBKYXZhU2NyaXB0IGNsYXNzLiAnICsgJ1RoaXMgaXMgb25seSBzdXBwb3J0ZWQgZm9yIGNsYXNzZXMgY3JlYXRlZCB1c2luZyBSZWFjdC5jcmVhdGVDbGFzcy4gJyArICdEaWQgeW91IG1lYW4gdG8gZGVmaW5lIGEgc3RhdGUgcHJvcGVydHkgaW5zdGVhZD8nLCBuYW1lKTtcbiAgICB9XG5cbiAgICBpZiAoaW5zdGFuY2UuZ2V0RGVmYXVsdFByb3BzICYmICFpbnN0YW5jZS5nZXREZWZhdWx0UHJvcHMuaXNSZWFjdENsYXNzQXBwcm92ZWQpIHtcbiAgICAgIGVycm9yKCdnZXREZWZhdWx0UHJvcHMgd2FzIGRlZmluZWQgb24gJXMsIGEgcGxhaW4gSmF2YVNjcmlwdCBjbGFzcy4gJyArICdUaGlzIGlzIG9ubHkgc3VwcG9ydGVkIGZvciBjbGFzc2VzIGNyZWF0ZWQgdXNpbmcgUmVhY3QuY3JlYXRlQ2xhc3MuICcgKyAnVXNlIGEgc3RhdGljIHByb3BlcnR5IHRvIGRlZmluZSBkZWZhdWx0UHJvcHMgaW5zdGVhZC4nLCBuYW1lKTtcbiAgICB9XG5cbiAgICBpZiAoaW5zdGFuY2UucHJvcFR5cGVzKSB7XG4gICAgICBlcnJvcigncHJvcFR5cGVzIHdhcyBkZWZpbmVkIGFzIGFuIGluc3RhbmNlIHByb3BlcnR5IG9uICVzLiBVc2UgYSBzdGF0aWMgJyArICdwcm9wZXJ0eSB0byBkZWZpbmUgcHJvcFR5cGVzIGluc3RlYWQuJywgbmFtZSk7XG4gICAgfVxuXG4gICAgaWYgKGluc3RhbmNlLmNvbnRleHRUeXBlKSB7XG4gICAgICBlcnJvcignY29udGV4dFR5cGUgd2FzIGRlZmluZWQgYXMgYW4gaW5zdGFuY2UgcHJvcGVydHkgb24gJXMuIFVzZSBhIHN0YXRpYyAnICsgJ3Byb3BlcnR5IHRvIGRlZmluZSBjb250ZXh0VHlwZSBpbnN0ZWFkLicsIG5hbWUpO1xuICAgIH1cblxuICAgIHtcbiAgICAgIGlmIChpbnN0YW5jZS5jb250ZXh0VHlwZXMpIHtcbiAgICAgICAgZXJyb3IoJ2NvbnRleHRUeXBlcyB3YXMgZGVmaW5lZCBhcyBhbiBpbnN0YW5jZSBwcm9wZXJ0eSBvbiAlcy4gVXNlIGEgc3RhdGljICcgKyAncHJvcGVydHkgdG8gZGVmaW5lIGNvbnRleHRUeXBlcyBpbnN0ZWFkLicsIG5hbWUpO1xuICAgICAgfVxuXG4gICAgICBpZiAoY3Rvci5jb250ZXh0VHlwZSAmJiBjdG9yLmNvbnRleHRUeXBlcyAmJiAhZGlkV2FybkFib3V0Q29udGV4dFR5cGVBbmRDb250ZXh0VHlwZXMuaGFzKGN0b3IpKSB7XG4gICAgICAgIGRpZFdhcm5BYm91dENvbnRleHRUeXBlQW5kQ29udGV4dFR5cGVzLmFkZChjdG9yKTtcblxuICAgICAgICBlcnJvcignJXMgZGVjbGFyZXMgYm90aCBjb250ZXh0VHlwZXMgYW5kIGNvbnRleHRUeXBlIHN0YXRpYyBwcm9wZXJ0aWVzLiAnICsgJ1RoZSBsZWdhY3kgY29udGV4dFR5cGVzIHByb3BlcnR5IHdpbGwgYmUgaWdub3JlZC4nLCBuYW1lKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFNob3VsZFVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgZXJyb3IoJyVzIGhhcyBhIG1ldGhvZCBjYWxsZWQgJyArICdjb21wb25lbnRTaG91bGRVcGRhdGUoKS4gRGlkIHlvdSBtZWFuIHNob3VsZENvbXBvbmVudFVwZGF0ZSgpPyAnICsgJ1RoZSBuYW1lIGlzIHBocmFzZWQgYXMgYSBxdWVzdGlvbiBiZWNhdXNlIHRoZSBmdW5jdGlvbiBpcyAnICsgJ2V4cGVjdGVkIHRvIHJldHVybiBhIHZhbHVlLicsIG5hbWUpO1xuICAgIH1cblxuICAgIGlmIChjdG9yLnByb3RvdHlwZSAmJiBjdG9yLnByb3RvdHlwZS5pc1B1cmVSZWFjdENvbXBvbmVudCAmJiB0eXBlb2YgaW5zdGFuY2Uuc2hvdWxkQ29tcG9uZW50VXBkYXRlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgZXJyb3IoJyVzIGhhcyBhIG1ldGhvZCBjYWxsZWQgc2hvdWxkQ29tcG9uZW50VXBkYXRlKCkuICcgKyAnc2hvdWxkQ29tcG9uZW50VXBkYXRlIHNob3VsZCBub3QgYmUgdXNlZCB3aGVuIGV4dGVuZGluZyBSZWFjdC5QdXJlQ29tcG9uZW50LiAnICsgJ1BsZWFzZSBleHRlbmQgUmVhY3QuQ29tcG9uZW50IGlmIHNob3VsZENvbXBvbmVudFVwZGF0ZSBpcyB1c2VkLicsIGdldENvbXBvbmVudE5hbWUoY3RvcikgfHwgJ0EgcHVyZSBjb21wb25lbnQnKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudERpZFVubW91bnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGVycm9yKCclcyBoYXMgYSBtZXRob2QgY2FsbGVkICcgKyAnY29tcG9uZW50RGlkVW5tb3VudCgpLiBCdXQgdGhlcmUgaXMgbm8gc3VjaCBsaWZlY3ljbGUgbWV0aG9kLiAnICsgJ0RpZCB5b3UgbWVhbiBjb21wb25lbnRXaWxsVW5tb3VudCgpPycsIG5hbWUpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50RGlkUmVjZWl2ZVByb3BzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBlcnJvcignJXMgaGFzIGEgbWV0aG9kIGNhbGxlZCAnICsgJ2NvbXBvbmVudERpZFJlY2VpdmVQcm9wcygpLiBCdXQgdGhlcmUgaXMgbm8gc3VjaCBsaWZlY3ljbGUgbWV0aG9kLiAnICsgJ0lmIHlvdSBtZWFudCB0byB1cGRhdGUgdGhlIHN0YXRlIGluIHJlc3BvbnNlIHRvIGNoYW5naW5nIHByb3BzLCAnICsgJ3VzZSBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKCkuIElmIHlvdSBtZWFudCB0byBmZXRjaCBkYXRhIG9yICcgKyAncnVuIHNpZGUtZWZmZWN0cyBvciBtdXRhdGlvbnMgYWZ0ZXIgUmVhY3QgaGFzIHVwZGF0ZWQgdGhlIFVJLCB1c2UgY29tcG9uZW50RGlkVXBkYXRlKCkuJywgbmFtZSk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsUmVjaWV2ZVByb3BzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBlcnJvcignJXMgaGFzIGEgbWV0aG9kIGNhbGxlZCAnICsgJ2NvbXBvbmVudFdpbGxSZWNpZXZlUHJvcHMoKS4gRGlkIHlvdSBtZWFuIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMoKT8nLCBuYW1lKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGluc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsUmVjaWV2ZVByb3BzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBlcnJvcignJXMgaGFzIGEgbWV0aG9kIGNhbGxlZCAnICsgJ1VOU0FGRV9jb21wb25lbnRXaWxsUmVjaWV2ZVByb3BzKCkuIERpZCB5b3UgbWVhbiBVTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcygpPycsIG5hbWUpO1xuICAgIH1cblxuICAgIHZhciBoYXNNdXRhdGVkUHJvcHMgPSBpbnN0YW5jZS5wcm9wcyAhPT0gbmV3UHJvcHM7XG5cbiAgICBpZiAoaW5zdGFuY2UucHJvcHMgIT09IHVuZGVmaW5lZCAmJiBoYXNNdXRhdGVkUHJvcHMpIHtcbiAgICAgIGVycm9yKCclcyguLi4pOiBXaGVuIGNhbGxpbmcgc3VwZXIoKSBpbiBgJXNgLCBtYWtlIHN1cmUgdG8gcGFzcyAnICsgXCJ1cCB0aGUgc2FtZSBwcm9wcyB0aGF0IHlvdXIgY29tcG9uZW50J3MgY29uc3RydWN0b3Igd2FzIHBhc3NlZC5cIiwgbmFtZSwgbmFtZSk7XG4gICAgfVxuXG4gICAgaWYgKGluc3RhbmNlLmRlZmF1bHRQcm9wcykge1xuICAgICAgZXJyb3IoJ1NldHRpbmcgZGVmYXVsdFByb3BzIGFzIGFuIGluc3RhbmNlIHByb3BlcnR5IG9uICVzIGlzIG5vdCBzdXBwb3J0ZWQgYW5kIHdpbGwgYmUgaWdub3JlZC4nICsgJyBJbnN0ZWFkLCBkZWZpbmUgZGVmYXVsdFByb3BzIGFzIGEgc3RhdGljIHByb3BlcnR5IG9uICVzLicsIG5hbWUsIG5hbWUpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudERpZFVwZGF0ZSAhPT0gJ2Z1bmN0aW9uJyAmJiAhZGlkV2FybkFib3V0R2V0U25hcHNob3RCZWZvcmVVcGRhdGVXaXRob3V0RGlkVXBkYXRlLmhhcyhjdG9yKSkge1xuICAgICAgZGlkV2FybkFib3V0R2V0U25hcHNob3RCZWZvcmVVcGRhdGVXaXRob3V0RGlkVXBkYXRlLmFkZChjdG9yKTtcblxuICAgICAgZXJyb3IoJyVzOiBnZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSgpIHNob3VsZCBiZSB1c2VkIHdpdGggY29tcG9uZW50RGlkVXBkYXRlKCkuICcgKyAnVGhpcyBjb21wb25lbnQgZGVmaW5lcyBnZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSgpIG9ubHkuJywgZ2V0Q29tcG9uZW50TmFtZShjdG9yKSk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGVycm9yKCclczogZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzKCkgaXMgZGVmaW5lZCBhcyBhbiBpbnN0YW5jZSBtZXRob2QgJyArICdhbmQgd2lsbCBiZSBpZ25vcmVkLiBJbnN0ZWFkLCBkZWNsYXJlIGl0IGFzIGEgc3RhdGljIG1ldGhvZC4nLCBuYW1lKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGluc3RhbmNlLmdldERlcml2ZWRTdGF0ZUZyb21FcnJvciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgZXJyb3IoJyVzOiBnZXREZXJpdmVkU3RhdGVGcm9tRXJyb3IoKSBpcyBkZWZpbmVkIGFzIGFuIGluc3RhbmNlIG1ldGhvZCAnICsgJ2FuZCB3aWxsIGJlIGlnbm9yZWQuIEluc3RlYWQsIGRlY2xhcmUgaXQgYXMgYSBzdGF0aWMgbWV0aG9kLicsIG5hbWUpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgY3Rvci5nZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgZXJyb3IoJyVzOiBnZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSgpIGlzIGRlZmluZWQgYXMgYSBzdGF0aWMgbWV0aG9kICcgKyAnYW5kIHdpbGwgYmUgaWdub3JlZC4gSW5zdGVhZCwgZGVjbGFyZSBpdCBhcyBhbiBpbnN0YW5jZSBtZXRob2QuJywgbmFtZSk7XG4gICAgfVxuXG4gICAgdmFyIF9zdGF0ZSA9IGluc3RhbmNlLnN0YXRlO1xuXG4gICAgaWYgKF9zdGF0ZSAmJiAodHlwZW9mIF9zdGF0ZSAhPT0gJ29iamVjdCcgfHwgaXNBcnJheShfc3RhdGUpKSkge1xuICAgICAgZXJyb3IoJyVzLnN0YXRlOiBtdXN0IGJlIHNldCB0byBhbiBvYmplY3Qgb3IgbnVsbCcsIG5hbWUpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuZ2V0Q2hpbGRDb250ZXh0ID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBjdG9yLmNoaWxkQ29udGV4dFR5cGVzICE9PSAnb2JqZWN0Jykge1xuICAgICAgZXJyb3IoJyVzLmdldENoaWxkQ29udGV4dCgpOiBjaGlsZENvbnRleHRUeXBlcyBtdXN0IGJlIGRlZmluZWQgaW4gb3JkZXIgdG8gJyArICd1c2UgZ2V0Q2hpbGRDb250ZXh0KCkuJywgbmFtZSk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGFkb3B0Q2xhc3NJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcywgaW5zdGFuY2UpIHtcbiAgaW5zdGFuY2UudXBkYXRlciA9IGNsYXNzQ29tcG9uZW50VXBkYXRlcjtcbiAgd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlID0gaW5zdGFuY2U7IC8vIFRoZSBpbnN0YW5jZSBuZWVkcyBhY2Nlc3MgdG8gdGhlIGZpYmVyIHNvIHRoYXQgaXQgY2FuIHNjaGVkdWxlIHVwZGF0ZXNcblxuICBzZXQoaW5zdGFuY2UsIHdvcmtJblByb2dyZXNzKTtcblxuICB7XG4gICAgaW5zdGFuY2UuX3JlYWN0SW50ZXJuYWxJbnN0YW5jZSA9IGZha2VJbnRlcm5hbEluc3RhbmNlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNvbnN0cnVjdENsYXNzSW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MsIGN0b3IsIHByb3BzKSB7XG4gIHZhciBpc0xlZ2FjeUNvbnRleHRDb25zdW1lciA9IGZhbHNlO1xuICB2YXIgdW5tYXNrZWRDb250ZXh0ID0gZW1wdHlDb250ZXh0T2JqZWN0O1xuICB2YXIgY29udGV4dCA9IGVtcHR5Q29udGV4dE9iamVjdDtcbiAgdmFyIGNvbnRleHRUeXBlID0gY3Rvci5jb250ZXh0VHlwZTtcblxuICB7XG4gICAgaWYgKCdjb250ZXh0VHlwZScgaW4gY3Rvcikge1xuICAgICAgdmFyIGlzVmFsaWQgPSAvLyBBbGxvdyBudWxsIGZvciBjb25kaXRpb25hbCBkZWNsYXJhdGlvblxuICAgICAgY29udGV4dFR5cGUgPT09IG51bGwgfHwgY29udGV4dFR5cGUgIT09IHVuZGVmaW5lZCAmJiBjb250ZXh0VHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQ09OVEVYVF9UWVBFICYmIGNvbnRleHRUeXBlLl9jb250ZXh0ID09PSB1bmRlZmluZWQ7IC8vIE5vdCBhIDxDb250ZXh0LkNvbnN1bWVyPlxuXG4gICAgICBpZiAoIWlzVmFsaWQgJiYgIWRpZFdhcm5BYm91dEludmFsaWRhdGVDb250ZXh0VHlwZS5oYXMoY3RvcikpIHtcbiAgICAgICAgZGlkV2FybkFib3V0SW52YWxpZGF0ZUNvbnRleHRUeXBlLmFkZChjdG9yKTtcbiAgICAgICAgdmFyIGFkZGVuZHVtID0gJyc7XG5cbiAgICAgICAgaWYgKGNvbnRleHRUeXBlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBhZGRlbmR1bSA9ICcgSG93ZXZlciwgaXQgaXMgc2V0IHRvIHVuZGVmaW5lZC4gJyArICdUaGlzIGNhbiBiZSBjYXVzZWQgYnkgYSB0eXBvIG9yIGJ5IG1peGluZyB1cCBuYW1lZCBhbmQgZGVmYXVsdCBpbXBvcnRzLiAnICsgJ1RoaXMgY2FuIGFsc28gaGFwcGVuIGR1ZSB0byBhIGNpcmN1bGFyIGRlcGVuZGVuY3ksIHNvICcgKyAndHJ5IG1vdmluZyB0aGUgY3JlYXRlQ29udGV4dCgpIGNhbGwgdG8gYSBzZXBhcmF0ZSBmaWxlLic7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGNvbnRleHRUeXBlICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgIGFkZGVuZHVtID0gJyBIb3dldmVyLCBpdCBpcyBzZXQgdG8gYSAnICsgdHlwZW9mIGNvbnRleHRUeXBlICsgJy4nO1xuICAgICAgICB9IGVsc2UgaWYgKGNvbnRleHRUeXBlLiQkdHlwZW9mID09PSBSRUFDVF9QUk9WSURFUl9UWVBFKSB7XG4gICAgICAgICAgYWRkZW5kdW0gPSAnIERpZCB5b3UgYWNjaWRlbnRhbGx5IHBhc3MgdGhlIENvbnRleHQuUHJvdmlkZXIgaW5zdGVhZD8nO1xuICAgICAgICB9IGVsc2UgaWYgKGNvbnRleHRUeXBlLl9jb250ZXh0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAvLyA8Q29udGV4dC5Db25zdW1lcj5cbiAgICAgICAgICBhZGRlbmR1bSA9ICcgRGlkIHlvdSBhY2NpZGVudGFsbHkgcGFzcyB0aGUgQ29udGV4dC5Db25zdW1lciBpbnN0ZWFkPyc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYWRkZW5kdW0gPSAnIEhvd2V2ZXIsIGl0IGlzIHNldCB0byBhbiBvYmplY3Qgd2l0aCBrZXlzIHsnICsgT2JqZWN0LmtleXMoY29udGV4dFR5cGUpLmpvaW4oJywgJykgKyAnfS4nO1xuICAgICAgICB9XG5cbiAgICAgICAgZXJyb3IoJyVzIGRlZmluZXMgYW4gaW52YWxpZCBjb250ZXh0VHlwZS4gJyArICdjb250ZXh0VHlwZSBzaG91bGQgcG9pbnQgdG8gdGhlIENvbnRleHQgb2JqZWN0IHJldHVybmVkIGJ5IFJlYWN0LmNyZWF0ZUNvbnRleHQoKS4lcycsIGdldENvbXBvbmVudE5hbWUoY3RvcikgfHwgJ0NvbXBvbmVudCcsIGFkZGVuZHVtKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAodHlwZW9mIGNvbnRleHRUeXBlID09PSAnb2JqZWN0JyAmJiBjb250ZXh0VHlwZSAhPT0gbnVsbCkge1xuICAgIGNvbnRleHQgPSByZWFkQ29udGV4dChjb250ZXh0VHlwZSk7XG4gIH0gZWxzZSB7XG4gICAgdW5tYXNrZWRDb250ZXh0ID0gZ2V0VW5tYXNrZWRDb250ZXh0KHdvcmtJblByb2dyZXNzLCBjdG9yLCB0cnVlKTtcbiAgICB2YXIgY29udGV4dFR5cGVzID0gY3Rvci5jb250ZXh0VHlwZXM7XG4gICAgaXNMZWdhY3lDb250ZXh0Q29uc3VtZXIgPSBjb250ZXh0VHlwZXMgIT09IG51bGwgJiYgY29udGV4dFR5cGVzICE9PSB1bmRlZmluZWQ7XG4gICAgY29udGV4dCA9IGlzTGVnYWN5Q29udGV4dENvbnN1bWVyID8gZ2V0TWFza2VkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgdW5tYXNrZWRDb250ZXh0KSA6IGVtcHR5Q29udGV4dE9iamVjdDtcbiAgfSAvLyBJbnN0YW50aWF0ZSB0d2ljZSB0byBoZWxwIGRldGVjdCBzaWRlLWVmZmVjdHMuXG5cblxuICB7XG4gICAgaWYgKCB3b3JrSW5Qcm9ncmVzcy5tb2RlICYgU3RyaWN0TW9kZSkge1xuICAgICAgZGlzYWJsZUxvZ3MoKTtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgbmV3IGN0b3IocHJvcHMsIGNvbnRleHQpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ld1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgcmVlbmFibGVMb2dzKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIGluc3RhbmNlID0gbmV3IGN0b3IocHJvcHMsIGNvbnRleHQpO1xuICB2YXIgc3RhdGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0gaW5zdGFuY2Uuc3RhdGUgIT09IG51bGwgJiYgaW5zdGFuY2Uuc3RhdGUgIT09IHVuZGVmaW5lZCA/IGluc3RhbmNlLnN0YXRlIDogbnVsbDtcbiAgYWRvcHRDbGFzc0luc3RhbmNlKHdvcmtJblByb2dyZXNzLCBpbnN0YW5jZSk7XG5cbiAge1xuICAgIGlmICh0eXBlb2YgY3Rvci5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgPT09ICdmdW5jdGlvbicgJiYgc3RhdGUgPT09IG51bGwpIHtcbiAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZShjdG9yKSB8fCAnQ29tcG9uZW50JztcblxuICAgICAgaWYgKCFkaWRXYXJuQWJvdXRVbmluaXRpYWxpemVkU3RhdGUuaGFzKGNvbXBvbmVudE5hbWUpKSB7XG4gICAgICAgIGRpZFdhcm5BYm91dFVuaW5pdGlhbGl6ZWRTdGF0ZS5hZGQoY29tcG9uZW50TmFtZSk7XG5cbiAgICAgICAgZXJyb3IoJ2Alc2AgdXNlcyBgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzYCBidXQgaXRzIGluaXRpYWwgc3RhdGUgaXMgJyArICclcy4gVGhpcyBpcyBub3QgcmVjb21tZW5kZWQuIEluc3RlYWQsIGRlZmluZSB0aGUgaW5pdGlhbCBzdGF0ZSBieSAnICsgJ2Fzc2lnbmluZyBhbiBvYmplY3QgdG8gYHRoaXMuc3RhdGVgIGluIHRoZSBjb25zdHJ1Y3RvciBvZiBgJXNgLiAnICsgJ1RoaXMgZW5zdXJlcyB0aGF0IGBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHNgIGFyZ3VtZW50cyBoYXZlIGEgY29uc2lzdGVudCBzaGFwZS4nLCBjb21wb25lbnROYW1lLCBpbnN0YW5jZS5zdGF0ZSA9PT0gbnVsbCA/ICdudWxsJyA6ICd1bmRlZmluZWQnLCBjb21wb25lbnROYW1lKTtcbiAgICAgIH1cbiAgICB9IC8vIElmIG5ldyBjb21wb25lbnQgQVBJcyBhcmUgZGVmaW5lZCwgXCJ1bnNhZmVcIiBsaWZlY3ljbGVzIHdvbid0IGJlIGNhbGxlZC5cbiAgICAvLyBXYXJuIGFib3V0IHRoZXNlIGxpZmVjeWNsZXMgaWYgdGhleSBhcmUgcHJlc2VudC5cbiAgICAvLyBEb24ndCB3YXJuIGFib3V0IHJlYWN0LWxpZmVjeWNsZXMtY29tcGF0IHBvbHlmaWxsZWQgbWV0aG9kcyB0aG91Z2guXG5cblxuICAgIGlmICh0eXBlb2YgY3Rvci5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgPT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGluc3RhbmNlLmdldFNuYXBzaG90QmVmb3JlVXBkYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB2YXIgZm91bmRXaWxsTW91bnROYW1lID0gbnVsbDtcbiAgICAgIHZhciBmb3VuZFdpbGxSZWNlaXZlUHJvcHNOYW1lID0gbnVsbDtcbiAgICAgIHZhciBmb3VuZFdpbGxVcGRhdGVOYW1lID0gbnVsbDtcblxuICAgICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsTW91bnQgPT09ICdmdW5jdGlvbicgJiYgaW5zdGFuY2UuY29tcG9uZW50V2lsbE1vdW50Ll9fc3VwcHJlc3NEZXByZWNhdGlvbldhcm5pbmcgIT09IHRydWUpIHtcbiAgICAgICAgZm91bmRXaWxsTW91bnROYW1lID0gJ2NvbXBvbmVudFdpbGxNb3VudCc7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBpbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbE1vdW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGZvdW5kV2lsbE1vdW50TmFtZSA9ICdVTlNBRkVfY29tcG9uZW50V2lsbE1vdW50JztcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzID09PSAnZnVuY3Rpb24nICYmIGluc3RhbmNlLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMuX19zdXBwcmVzc0RlcHJlY2F0aW9uV2FybmluZyAhPT0gdHJ1ZSkge1xuICAgICAgICBmb3VuZFdpbGxSZWNlaXZlUHJvcHNOYW1lID0gJ2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMnO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgZm91bmRXaWxsUmVjZWl2ZVByb3BzTmFtZSA9ICdVTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyc7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbFVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJyAmJiBpbnN0YW5jZS5jb21wb25lbnRXaWxsVXBkYXRlLl9fc3VwcHJlc3NEZXByZWNhdGlvbldhcm5pbmcgIT09IHRydWUpIHtcbiAgICAgICAgZm91bmRXaWxsVXBkYXRlTmFtZSA9ICdjb21wb25lbnRXaWxsVXBkYXRlJztcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGluc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsVXBkYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGZvdW5kV2lsbFVwZGF0ZU5hbWUgPSAnVU5TQUZFX2NvbXBvbmVudFdpbGxVcGRhdGUnO1xuICAgICAgfVxuXG4gICAgICBpZiAoZm91bmRXaWxsTW91bnROYW1lICE9PSBudWxsIHx8IGZvdW5kV2lsbFJlY2VpdmVQcm9wc05hbWUgIT09IG51bGwgfHwgZm91bmRXaWxsVXBkYXRlTmFtZSAhPT0gbnVsbCkge1xuICAgICAgICB2YXIgX2NvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lKGN0b3IpIHx8ICdDb21wb25lbnQnO1xuXG4gICAgICAgIHZhciBuZXdBcGlOYW1lID0gdHlwZW9mIGN0b3IuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzID09PSAnZnVuY3Rpb24nID8gJ2dldERlcml2ZWRTdGF0ZUZyb21Qcm9wcygpJyA6ICdnZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSgpJztcblxuICAgICAgICBpZiAoIWRpZFdhcm5BYm91dExlZ2FjeUxpZmVjeWNsZXNBbmREZXJpdmVkU3RhdGUuaGFzKF9jb21wb25lbnROYW1lKSkge1xuICAgICAgICAgIGRpZFdhcm5BYm91dExlZ2FjeUxpZmVjeWNsZXNBbmREZXJpdmVkU3RhdGUuYWRkKF9jb21wb25lbnROYW1lKTtcblxuICAgICAgICAgIGVycm9yKCdVbnNhZmUgbGVnYWN5IGxpZmVjeWNsZXMgd2lsbCBub3QgYmUgY2FsbGVkIGZvciBjb21wb25lbnRzIHVzaW5nIG5ldyBjb21wb25lbnQgQVBJcy5cXG5cXG4nICsgJyVzIHVzZXMgJXMgYnV0IGFsc28gY29udGFpbnMgdGhlIGZvbGxvd2luZyBsZWdhY3kgbGlmZWN5Y2xlczolcyVzJXNcXG5cXG4nICsgJ1RoZSBhYm92ZSBsaWZlY3ljbGVzIHNob3VsZCBiZSByZW1vdmVkLiBMZWFybiBtb3JlIGFib3V0IHRoaXMgd2FybmluZyBoZXJlOlxcbicgKyAnaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3Vuc2FmZS1jb21wb25lbnQtbGlmZWN5Y2xlcycsIF9jb21wb25lbnROYW1lLCBuZXdBcGlOYW1lLCBmb3VuZFdpbGxNb3VudE5hbWUgIT09IG51bGwgPyBcIlxcbiAgXCIgKyBmb3VuZFdpbGxNb3VudE5hbWUgOiAnJywgZm91bmRXaWxsUmVjZWl2ZVByb3BzTmFtZSAhPT0gbnVsbCA/IFwiXFxuICBcIiArIGZvdW5kV2lsbFJlY2VpdmVQcm9wc05hbWUgOiAnJywgZm91bmRXaWxsVXBkYXRlTmFtZSAhPT0gbnVsbCA/IFwiXFxuICBcIiArIGZvdW5kV2lsbFVwZGF0ZU5hbWUgOiAnJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0gLy8gQ2FjaGUgdW5tYXNrZWQgY29udGV4dCBzbyB3ZSBjYW4gYXZvaWQgcmVjcmVhdGluZyBtYXNrZWQgY29udGV4dCB1bmxlc3MgbmVjZXNzYXJ5LlxuICAvLyBSZWFjdEZpYmVyQ29udGV4dCB1c3VhbGx5IHVwZGF0ZXMgdGhpcyBjYWNoZSBidXQgY2FuJ3QgZm9yIG5ld2x5LWNyZWF0ZWQgaW5zdGFuY2VzLlxuXG5cbiAgaWYgKGlzTGVnYWN5Q29udGV4dENvbnN1bWVyKSB7XG4gICAgY2FjaGVDb250ZXh0KHdvcmtJblByb2dyZXNzLCB1bm1hc2tlZENvbnRleHQsIGNvbnRleHQpO1xuICB9XG5cbiAgcmV0dXJuIGluc3RhbmNlO1xufVxuXG5mdW5jdGlvbiBjYWxsQ29tcG9uZW50V2lsbE1vdW50KHdvcmtJblByb2dyZXNzLCBpbnN0YW5jZSkge1xuICB2YXIgb2xkU3RhdGUgPSBpbnN0YW5jZS5zdGF0ZTtcblxuICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxNb3VudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGluc3RhbmNlLmNvbXBvbmVudFdpbGxNb3VudCgpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBpbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbE1vdW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudCgpO1xuICB9XG5cbiAgaWYgKG9sZFN0YXRlICE9PSBpbnN0YW5jZS5zdGF0ZSkge1xuICAgIHtcbiAgICAgIGVycm9yKCclcy5jb21wb25lbnRXaWxsTW91bnQoKTogQXNzaWduaW5nIGRpcmVjdGx5IHRvIHRoaXMuc3RhdGUgaXMgJyArIFwiZGVwcmVjYXRlZCAoZXhjZXB0IGluc2lkZSBhIGNvbXBvbmVudCdzIFwiICsgJ2NvbnN0cnVjdG9yKS4gVXNlIHNldFN0YXRlIGluc3RlYWQuJywgZ2V0Q29tcG9uZW50TmFtZSh3b3JrSW5Qcm9ncmVzcy50eXBlKSB8fCAnQ29tcG9uZW50Jyk7XG4gICAgfVxuXG4gICAgY2xhc3NDb21wb25lbnRVcGRhdGVyLmVucXVldWVSZXBsYWNlU3RhdGUoaW5zdGFuY2UsIGluc3RhbmNlLnN0YXRlLCBudWxsKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjYWxsQ29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyh3b3JrSW5Qcm9ncmVzcywgaW5zdGFuY2UsIG5ld1Byb3BzLCBuZXh0Q29udGV4dCkge1xuICB2YXIgb2xkU3RhdGUgPSBpbnN0YW5jZS5zdGF0ZTtcblxuICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBpbnN0YW5jZS5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKG5ld1Byb3BzLCBuZXh0Q29udGV4dCk7XG4gIH1cblxuICBpZiAodHlwZW9mIGluc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMobmV3UHJvcHMsIG5leHRDb250ZXh0KTtcbiAgfVxuXG4gIGlmIChpbnN0YW5jZS5zdGF0ZSAhPT0gb2xkU3RhdGUpIHtcbiAgICB7XG4gICAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWUod29ya0luUHJvZ3Jlc3MudHlwZSkgfHwgJ0NvbXBvbmVudCc7XG5cbiAgICAgIGlmICghZGlkV2FybkFib3V0U3RhdGVBc3NpZ25tZW50Rm9yQ29tcG9uZW50Lmhhcyhjb21wb25lbnROYW1lKSkge1xuICAgICAgICBkaWRXYXJuQWJvdXRTdGF0ZUFzc2lnbm1lbnRGb3JDb21wb25lbnQuYWRkKGNvbXBvbmVudE5hbWUpO1xuXG4gICAgICAgIGVycm9yKCclcy5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKCk6IEFzc2lnbmluZyBkaXJlY3RseSB0byAnICsgXCJ0aGlzLnN0YXRlIGlzIGRlcHJlY2F0ZWQgKGV4Y2VwdCBpbnNpZGUgYSBjb21wb25lbnQncyBcIiArICdjb25zdHJ1Y3RvcikuIFVzZSBzZXRTdGF0ZSBpbnN0ZWFkLicsIGNvbXBvbmVudE5hbWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNsYXNzQ29tcG9uZW50VXBkYXRlci5lbnF1ZXVlUmVwbGFjZVN0YXRlKGluc3RhbmNlLCBpbnN0YW5jZS5zdGF0ZSwgbnVsbCk7XG4gIH1cbn0gLy8gSW52b2tlcyB0aGUgbW91bnQgbGlmZS1jeWNsZXMgb24gYSBwcmV2aW91c2x5IG5ldmVyIHJlbmRlcmVkIGluc3RhbmNlLlxuXG5cbmZ1bmN0aW9uIG1vdW50Q2xhc3NJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcywgY3RvciwgbmV3UHJvcHMsIHJlbmRlckxhbmVzKSB7XG4gIHtcbiAgICBjaGVja0NsYXNzSW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MsIGN0b3IsIG5ld1Byb3BzKTtcbiAgfVxuXG4gIHZhciBpbnN0YW5jZSA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcbiAgaW5zdGFuY2UucHJvcHMgPSBuZXdQcm9wcztcbiAgaW5zdGFuY2Uuc3RhdGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuICBpbnN0YW5jZS5yZWZzID0gZW1wdHlSZWZzT2JqZWN0O1xuICBpbml0aWFsaXplVXBkYXRlUXVldWUod29ya0luUHJvZ3Jlc3MpO1xuICB2YXIgY29udGV4dFR5cGUgPSBjdG9yLmNvbnRleHRUeXBlO1xuXG4gIGlmICh0eXBlb2YgY29udGV4dFR5cGUgPT09ICdvYmplY3QnICYmIGNvbnRleHRUeXBlICE9PSBudWxsKSB7XG4gICAgaW5zdGFuY2UuY29udGV4dCA9IHJlYWRDb250ZXh0KGNvbnRleHRUeXBlKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgdW5tYXNrZWRDb250ZXh0ID0gZ2V0VW5tYXNrZWRDb250ZXh0KHdvcmtJblByb2dyZXNzLCBjdG9yLCB0cnVlKTtcbiAgICBpbnN0YW5jZS5jb250ZXh0ID0gZ2V0TWFza2VkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgdW5tYXNrZWRDb250ZXh0KTtcbiAgfVxuXG4gIHtcbiAgICBpZiAoaW5zdGFuY2Uuc3RhdGUgPT09IG5ld1Byb3BzKSB7XG4gICAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWUoY3RvcikgfHwgJ0NvbXBvbmVudCc7XG5cbiAgICAgIGlmICghZGlkV2FybkFib3V0RGlyZWN0bHlBc3NpZ25pbmdQcm9wc1RvU3RhdGUuaGFzKGNvbXBvbmVudE5hbWUpKSB7XG4gICAgICAgIGRpZFdhcm5BYm91dERpcmVjdGx5QXNzaWduaW5nUHJvcHNUb1N0YXRlLmFkZChjb21wb25lbnROYW1lKTtcblxuICAgICAgICBlcnJvcignJXM6IEl0IGlzIG5vdCByZWNvbW1lbmRlZCB0byBhc3NpZ24gcHJvcHMgZGlyZWN0bHkgdG8gc3RhdGUgJyArIFwiYmVjYXVzZSB1cGRhdGVzIHRvIHByb3BzIHdvbid0IGJlIHJlZmxlY3RlZCBpbiBzdGF0ZS4gXCIgKyAnSW4gbW9zdCBjYXNlcywgaXQgaXMgYmV0dGVyIHRvIHVzZSBwcm9wcyBkaXJlY3RseS4nLCBjb21wb25lbnROYW1lKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAod29ya0luUHJvZ3Jlc3MubW9kZSAmIFN0cmljdE1vZGUpIHtcbiAgICAgIFJlYWN0U3RyaWN0TW9kZVdhcm5pbmdzLnJlY29yZExlZ2FjeUNvbnRleHRXYXJuaW5nKHdvcmtJblByb2dyZXNzLCBpbnN0YW5jZSk7XG4gICAgfVxuXG4gICAge1xuICAgICAgUmVhY3RTdHJpY3RNb2RlV2FybmluZ3MucmVjb3JkVW5zYWZlTGlmZWN5Y2xlV2FybmluZ3Mod29ya0luUHJvZ3Jlc3MsIGluc3RhbmNlKTtcbiAgICB9XG4gIH1cblxuICBwcm9jZXNzVXBkYXRlUXVldWUod29ya0luUHJvZ3Jlc3MsIG5ld1Byb3BzLCBpbnN0YW5jZSwgcmVuZGVyTGFuZXMpO1xuICBpbnN0YW5jZS5zdGF0ZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG4gIHZhciBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgPSBjdG9yLmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcztcblxuICBpZiAodHlwZW9mIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGFwcGx5RGVyaXZlZFN0YXRlRnJvbVByb3BzKHdvcmtJblByb2dyZXNzLCBjdG9yLCBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMsIG5ld1Byb3BzKTtcbiAgICBpbnN0YW5jZS5zdGF0ZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG4gIH0gLy8gSW4gb3JkZXIgdG8gc3VwcG9ydCByZWFjdC1saWZlY3ljbGVzLWNvbXBhdCBwb2x5ZmlsbGVkIGNvbXBvbmVudHMsXG4gIC8vIFVuc2FmZSBsaWZlY3ljbGVzIHNob3VsZCBub3QgYmUgaW52b2tlZCBmb3IgY29tcG9uZW50cyB1c2luZyB0aGUgbmV3IEFQSXMuXG5cblxuICBpZiAodHlwZW9mIGN0b3IuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzICE9PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBpbnN0YW5jZS5nZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSAhPT0gJ2Z1bmN0aW9uJyAmJiAodHlwZW9mIGluc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsTW91bnQgPT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxNb3VudCA9PT0gJ2Z1bmN0aW9uJykpIHtcbiAgICBjYWxsQ29tcG9uZW50V2lsbE1vdW50KHdvcmtJblByb2dyZXNzLCBpbnN0YW5jZSk7IC8vIElmIHdlIGhhZCBhZGRpdGlvbmFsIHN0YXRlIHVwZGF0ZXMgZHVyaW5nIHRoaXMgbGlmZS1jeWNsZSwgbGV0J3NcbiAgICAvLyBwcm9jZXNzIHRoZW0gbm93LlxuXG4gICAgcHJvY2Vzc1VwZGF0ZVF1ZXVlKHdvcmtJblByb2dyZXNzLCBuZXdQcm9wcywgaW5zdGFuY2UsIHJlbmRlckxhbmVzKTtcbiAgICBpbnN0YW5jZS5zdGF0ZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG4gIH1cblxuICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudERpZE1vdW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gVXBkYXRlO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlc3VtZU1vdW50Q2xhc3NJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcywgY3RvciwgbmV3UHJvcHMsIHJlbmRlckxhbmVzKSB7XG4gIHZhciBpbnN0YW5jZSA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcbiAgdmFyIG9sZFByb3BzID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcztcbiAgaW5zdGFuY2UucHJvcHMgPSBvbGRQcm9wcztcbiAgdmFyIG9sZENvbnRleHQgPSBpbnN0YW5jZS5jb250ZXh0O1xuICB2YXIgY29udGV4dFR5cGUgPSBjdG9yLmNvbnRleHRUeXBlO1xuICB2YXIgbmV4dENvbnRleHQgPSBlbXB0eUNvbnRleHRPYmplY3Q7XG5cbiAgaWYgKHR5cGVvZiBjb250ZXh0VHlwZSA9PT0gJ29iamVjdCcgJiYgY29udGV4dFR5cGUgIT09IG51bGwpIHtcbiAgICBuZXh0Q29udGV4dCA9IHJlYWRDb250ZXh0KGNvbnRleHRUeXBlKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgbmV4dExlZ2FjeVVubWFza2VkQ29udGV4dCA9IGdldFVubWFza2VkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgY3RvciwgdHJ1ZSk7XG4gICAgbmV4dENvbnRleHQgPSBnZXRNYXNrZWRDb250ZXh0KHdvcmtJblByb2dyZXNzLCBuZXh0TGVnYWN5VW5tYXNrZWRDb250ZXh0KTtcbiAgfVxuXG4gIHZhciBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgPSBjdG9yLmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcztcbiAgdmFyIGhhc05ld0xpZmVjeWNsZXMgPSB0eXBlb2YgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzID09PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBpbnN0YW5jZS5nZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJzsgLy8gTm90ZTogRHVyaW5nIHRoZXNlIGxpZmUtY3ljbGVzLCBpbnN0YW5jZS5wcm9wcy9pbnN0YW5jZS5zdGF0ZSBhcmUgd2hhdFxuICAvLyBldmVyIHRoZSBwcmV2aW91c2x5IGF0dGVtcHRlZCB0byByZW5kZXIgLSBub3QgdGhlIFwiY3VycmVudFwiLiBIb3dldmVyLFxuICAvLyBkdXJpbmcgY29tcG9uZW50RGlkVXBkYXRlIHdlIHBhc3MgdGhlIFwiY3VycmVudFwiIHByb3BzLlxuICAvLyBJbiBvcmRlciB0byBzdXBwb3J0IHJlYWN0LWxpZmVjeWNsZXMtY29tcGF0IHBvbHlmaWxsZWQgY29tcG9uZW50cyxcbiAgLy8gVW5zYWZlIGxpZmVjeWNsZXMgc2hvdWxkIG5vdCBiZSBpbnZva2VkIGZvciBjb21wb25lbnRzIHVzaW5nIHRoZSBuZXcgQVBJcy5cblxuICBpZiAoIWhhc05ld0xpZmVjeWNsZXMgJiYgKHR5cGVvZiBpbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyA9PT0gJ2Z1bmN0aW9uJykpIHtcbiAgICBpZiAob2xkUHJvcHMgIT09IG5ld1Byb3BzIHx8IG9sZENvbnRleHQgIT09IG5leHRDb250ZXh0KSB7XG4gICAgICBjYWxsQ29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyh3b3JrSW5Qcm9ncmVzcywgaW5zdGFuY2UsIG5ld1Byb3BzLCBuZXh0Q29udGV4dCk7XG4gICAgfVxuICB9XG5cbiAgcmVzZXRIYXNGb3JjZVVwZGF0ZUJlZm9yZVByb2Nlc3NpbmcoKTtcbiAgdmFyIG9sZFN0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcbiAgdmFyIG5ld1N0YXRlID0gaW5zdGFuY2Uuc3RhdGUgPSBvbGRTdGF0ZTtcbiAgcHJvY2Vzc1VwZGF0ZVF1ZXVlKHdvcmtJblByb2dyZXNzLCBuZXdQcm9wcywgaW5zdGFuY2UsIHJlbmRlckxhbmVzKTtcbiAgbmV3U3RhdGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuXG4gIGlmIChvbGRQcm9wcyA9PT0gbmV3UHJvcHMgJiYgb2xkU3RhdGUgPT09IG5ld1N0YXRlICYmICFoYXNDb250ZXh0Q2hhbmdlZCgpICYmICFjaGVja0hhc0ZvcmNlVXBkYXRlQWZ0ZXJQcm9jZXNzaW5nKCkpIHtcbiAgICAvLyBJZiBhbiB1cGRhdGUgd2FzIGFscmVhZHkgaW4gcHJvZ3Jlc3MsIHdlIHNob3VsZCBzY2hlZHVsZSBhbiBVcGRhdGVcbiAgICAvLyBlZmZlY3QgZXZlbiB0aG91Z2ggd2UncmUgYmFpbGluZyBvdXQsIHNvIHRoYXQgY1dVL2NEVSBhcmUgY2FsbGVkLlxuICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50RGlkTW91bnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IFVwZGF0ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAodHlwZW9mIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGFwcGx5RGVyaXZlZFN0YXRlRnJvbVByb3BzKHdvcmtJblByb2dyZXNzLCBjdG9yLCBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMsIG5ld1Byb3BzKTtcbiAgICBuZXdTdGF0ZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG4gIH1cblxuICB2YXIgc2hvdWxkVXBkYXRlID0gY2hlY2tIYXNGb3JjZVVwZGF0ZUFmdGVyUHJvY2Vzc2luZygpIHx8IGNoZWNrU2hvdWxkQ29tcG9uZW50VXBkYXRlKHdvcmtJblByb2dyZXNzLCBjdG9yLCBvbGRQcm9wcywgbmV3UHJvcHMsIG9sZFN0YXRlLCBuZXdTdGF0ZSwgbmV4dENvbnRleHQpO1xuXG4gIGlmIChzaG91bGRVcGRhdGUpIHtcbiAgICAvLyBJbiBvcmRlciB0byBzdXBwb3J0IHJlYWN0LWxpZmVjeWNsZXMtY29tcGF0IHBvbHlmaWxsZWQgY29tcG9uZW50cyxcbiAgICAvLyBVbnNhZmUgbGlmZWN5Y2xlcyBzaG91bGQgbm90IGJlIGludm9rZWQgZm9yIGNvbXBvbmVudHMgdXNpbmcgdGhlIG5ldyBBUElzLlxuICAgIGlmICghaGFzTmV3TGlmZWN5Y2xlcyAmJiAodHlwZW9mIGluc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsTW91bnQgPT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxNb3VudCA9PT0gJ2Z1bmN0aW9uJykpIHtcbiAgICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbE1vdW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGluc3RhbmNlLmNvbXBvbmVudFdpbGxNb3VudCgpO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGluc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsTW91bnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudCgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50RGlkTW91bnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IFVwZGF0ZTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gSWYgYW4gdXBkYXRlIHdhcyBhbHJlYWR5IGluIHByb2dyZXNzLCB3ZSBzaG91bGQgc2NoZWR1bGUgYW4gVXBkYXRlXG4gICAgLy8gZWZmZWN0IGV2ZW4gdGhvdWdoIHdlJ3JlIGJhaWxpbmcgb3V0LCBzbyB0aGF0IGNXVS9jRFUgYXJlIGNhbGxlZC5cbiAgICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudERpZE1vdW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBVcGRhdGU7XG4gICAgfSAvLyBJZiBzaG91bGRDb21wb25lbnRVcGRhdGUgcmV0dXJuZWQgZmFsc2UsIHdlIHNob3VsZCBzdGlsbCB1cGRhdGUgdGhlXG4gICAgLy8gbWVtb2l6ZWQgc3RhdGUgdG8gaW5kaWNhdGUgdGhhdCB0aGlzIHdvcmsgY2FuIGJlIHJldXNlZC5cblxuXG4gICAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcyA9IG5ld1Byb3BzO1xuICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBuZXdTdGF0ZTtcbiAgfSAvLyBVcGRhdGUgdGhlIGV4aXN0aW5nIGluc3RhbmNlJ3Mgc3RhdGUsIHByb3BzLCBhbmQgY29udGV4dCBwb2ludGVycyBldmVuXG4gIC8vIGlmIHNob3VsZENvbXBvbmVudFVwZGF0ZSByZXR1cm5zIGZhbHNlLlxuXG5cbiAgaW5zdGFuY2UucHJvcHMgPSBuZXdQcm9wcztcbiAgaW5zdGFuY2Uuc3RhdGUgPSBuZXdTdGF0ZTtcbiAgaW5zdGFuY2UuY29udGV4dCA9IG5leHRDb250ZXh0O1xuICByZXR1cm4gc2hvdWxkVXBkYXRlO1xufSAvLyBJbnZva2VzIHRoZSB1cGRhdGUgbGlmZS1jeWNsZXMgYW5kIHJldHVybnMgZmFsc2UgaWYgaXQgc2hvdWxkbid0IHJlcmVuZGVyLlxuXG5cbmZ1bmN0aW9uIHVwZGF0ZUNsYXNzSW5zdGFuY2UoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIGN0b3IsIG5ld1Byb3BzLCByZW5kZXJMYW5lcykge1xuICB2YXIgaW5zdGFuY2UgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG4gIGNsb25lVXBkYXRlUXVldWUoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpO1xuICB2YXIgdW5yZXNvbHZlZE9sZFByb3BzID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcztcbiAgdmFyIG9sZFByb3BzID0gd29ya0luUHJvZ3Jlc3MudHlwZSA9PT0gd29ya0luUHJvZ3Jlc3MuZWxlbWVudFR5cGUgPyB1bnJlc29sdmVkT2xkUHJvcHMgOiByZXNvbHZlRGVmYXVsdFByb3BzKHdvcmtJblByb2dyZXNzLnR5cGUsIHVucmVzb2x2ZWRPbGRQcm9wcyk7XG4gIGluc3RhbmNlLnByb3BzID0gb2xkUHJvcHM7XG4gIHZhciB1bnJlc29sdmVkTmV3UHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7XG4gIHZhciBvbGRDb250ZXh0ID0gaW5zdGFuY2UuY29udGV4dDtcbiAgdmFyIGNvbnRleHRUeXBlID0gY3Rvci5jb250ZXh0VHlwZTtcbiAgdmFyIG5leHRDb250ZXh0ID0gZW1wdHlDb250ZXh0T2JqZWN0O1xuXG4gIGlmICh0eXBlb2YgY29udGV4dFR5cGUgPT09ICdvYmplY3QnICYmIGNvbnRleHRUeXBlICE9PSBudWxsKSB7XG4gICAgbmV4dENvbnRleHQgPSByZWFkQ29udGV4dChjb250ZXh0VHlwZSk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIG5leHRVbm1hc2tlZENvbnRleHQgPSBnZXRVbm1hc2tlZENvbnRleHQod29ya0luUHJvZ3Jlc3MsIGN0b3IsIHRydWUpO1xuICAgIG5leHRDb250ZXh0ID0gZ2V0TWFza2VkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgbmV4dFVubWFza2VkQ29udGV4dCk7XG4gIH1cblxuICB2YXIgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzID0gY3Rvci5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHM7XG4gIHZhciBoYXNOZXdMaWZlY3ljbGVzID0gdHlwZW9mIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgaW5zdGFuY2UuZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUgPT09ICdmdW5jdGlvbic7IC8vIE5vdGU6IER1cmluZyB0aGVzZSBsaWZlLWN5Y2xlcywgaW5zdGFuY2UucHJvcHMvaW5zdGFuY2Uuc3RhdGUgYXJlIHdoYXRcbiAgLy8gZXZlciB0aGUgcHJldmlvdXNseSBhdHRlbXB0ZWQgdG8gcmVuZGVyIC0gbm90IHRoZSBcImN1cnJlbnRcIi4gSG93ZXZlcixcbiAgLy8gZHVyaW5nIGNvbXBvbmVudERpZFVwZGF0ZSB3ZSBwYXNzIHRoZSBcImN1cnJlbnRcIiBwcm9wcy5cbiAgLy8gSW4gb3JkZXIgdG8gc3VwcG9ydCByZWFjdC1saWZlY3ljbGVzLWNvbXBhdCBwb2x5ZmlsbGVkIGNvbXBvbmVudHMsXG4gIC8vIFVuc2FmZSBsaWZlY3ljbGVzIHNob3VsZCBub3QgYmUgaW52b2tlZCBmb3IgY29tcG9uZW50cyB1c2luZyB0aGUgbmV3IEFQSXMuXG5cbiAgaWYgKCFoYXNOZXdMaWZlY3ljbGVzICYmICh0eXBlb2YgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgPT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgPT09ICdmdW5jdGlvbicpKSB7XG4gICAgaWYgKHVucmVzb2x2ZWRPbGRQcm9wcyAhPT0gdW5yZXNvbHZlZE5ld1Byb3BzIHx8IG9sZENvbnRleHQgIT09IG5leHRDb250ZXh0KSB7XG4gICAgICBjYWxsQ29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyh3b3JrSW5Qcm9ncmVzcywgaW5zdGFuY2UsIG5ld1Byb3BzLCBuZXh0Q29udGV4dCk7XG4gICAgfVxuICB9XG5cbiAgcmVzZXRIYXNGb3JjZVVwZGF0ZUJlZm9yZVByb2Nlc3NpbmcoKTtcbiAgdmFyIG9sZFN0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcbiAgdmFyIG5ld1N0YXRlID0gaW5zdGFuY2Uuc3RhdGUgPSBvbGRTdGF0ZTtcbiAgcHJvY2Vzc1VwZGF0ZVF1ZXVlKHdvcmtJblByb2dyZXNzLCBuZXdQcm9wcywgaW5zdGFuY2UsIHJlbmRlckxhbmVzKTtcbiAgbmV3U3RhdGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuXG4gIGlmICh1bnJlc29sdmVkT2xkUHJvcHMgPT09IHVucmVzb2x2ZWROZXdQcm9wcyAmJiBvbGRTdGF0ZSA9PT0gbmV3U3RhdGUgJiYgIWhhc0NvbnRleHRDaGFuZ2VkKCkgJiYgIWNoZWNrSGFzRm9yY2VVcGRhdGVBZnRlclByb2Nlc3NpbmcoKSkge1xuICAgIC8vIElmIGFuIHVwZGF0ZSB3YXMgYWxyZWFkeSBpbiBwcm9ncmVzcywgd2Ugc2hvdWxkIHNjaGVkdWxlIGFuIFVwZGF0ZVxuICAgIC8vIGVmZmVjdCBldmVuIHRob3VnaCB3ZSdyZSBiYWlsaW5nIG91dCwgc28gdGhhdCBjV1UvY0RVIGFyZSBjYWxsZWQuXG4gICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnREaWRVcGRhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGlmICh1bnJlc29sdmVkT2xkUHJvcHMgIT09IGN1cnJlbnQubWVtb2l6ZWRQcm9wcyB8fCBvbGRTdGF0ZSAhPT0gY3VycmVudC5tZW1vaXplZFN0YXRlKSB7XG4gICAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IFVwZGF0ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGluc3RhbmNlLmdldFNuYXBzaG90QmVmb3JlVXBkYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpZiAodW5yZXNvbHZlZE9sZFByb3BzICE9PSBjdXJyZW50Lm1lbW9pemVkUHJvcHMgfHwgb2xkU3RhdGUgIT09IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZSkge1xuICAgICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBTbmFwc2hvdDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAodHlwZW9mIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGFwcGx5RGVyaXZlZFN0YXRlRnJvbVByb3BzKHdvcmtJblByb2dyZXNzLCBjdG9yLCBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMsIG5ld1Byb3BzKTtcbiAgICBuZXdTdGF0ZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG4gIH1cblxuICB2YXIgc2hvdWxkVXBkYXRlID0gY2hlY2tIYXNGb3JjZVVwZGF0ZUFmdGVyUHJvY2Vzc2luZygpIHx8IGNoZWNrU2hvdWxkQ29tcG9uZW50VXBkYXRlKHdvcmtJblByb2dyZXNzLCBjdG9yLCBvbGRQcm9wcywgbmV3UHJvcHMsIG9sZFN0YXRlLCBuZXdTdGF0ZSwgbmV4dENvbnRleHQpO1xuXG4gIGlmIChzaG91bGRVcGRhdGUpIHtcbiAgICAvLyBJbiBvcmRlciB0byBzdXBwb3J0IHJlYWN0LWxpZmVjeWNsZXMtY29tcGF0IHBvbHlmaWxsZWQgY29tcG9uZW50cyxcbiAgICAvLyBVbnNhZmUgbGlmZWN5Y2xlcyBzaG91bGQgbm90IGJlIGludm9rZWQgZm9yIGNvbXBvbmVudHMgdXNpbmcgdGhlIG5ldyBBUElzLlxuICAgIGlmICghaGFzTmV3TGlmZWN5Y2xlcyAmJiAodHlwZW9mIGluc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsVXBkYXRlID09PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsVXBkYXRlID09PSAnZnVuY3Rpb24nKSkge1xuICAgICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsVXBkYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGluc3RhbmNlLmNvbXBvbmVudFdpbGxVcGRhdGUobmV3UHJvcHMsIG5ld1N0YXRlLCBuZXh0Q29udGV4dCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxVcGRhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxVcGRhdGUobmV3UHJvcHMsIG5ld1N0YXRlLCBuZXh0Q29udGV4dCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnREaWRVcGRhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IFVwZGF0ZTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGluc3RhbmNlLmdldFNuYXBzaG90QmVmb3JlVXBkYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBTbmFwc2hvdDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gSWYgYW4gdXBkYXRlIHdhcyBhbHJlYWR5IGluIHByb2dyZXNzLCB3ZSBzaG91bGQgc2NoZWR1bGUgYW4gVXBkYXRlXG4gICAgLy8gZWZmZWN0IGV2ZW4gdGhvdWdoIHdlJ3JlIGJhaWxpbmcgb3V0LCBzbyB0aGF0IGNXVS9jRFUgYXJlIGNhbGxlZC5cbiAgICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudERpZFVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaWYgKHVucmVzb2x2ZWRPbGRQcm9wcyAhPT0gY3VycmVudC5tZW1vaXplZFByb3BzIHx8IG9sZFN0YXRlICE9PSBjdXJyZW50Lm1lbW9pemVkU3RhdGUpIHtcbiAgICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gVXBkYXRlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGlmICh1bnJlc29sdmVkT2xkUHJvcHMgIT09IGN1cnJlbnQubWVtb2l6ZWRQcm9wcyB8fCBvbGRTdGF0ZSAhPT0gY3VycmVudC5tZW1vaXplZFN0YXRlKSB7XG4gICAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IFNuYXBzaG90O1xuICAgICAgfVxuICAgIH0gLy8gSWYgc2hvdWxkQ29tcG9uZW50VXBkYXRlIHJldHVybmVkIGZhbHNlLCB3ZSBzaG91bGQgc3RpbGwgdXBkYXRlIHRoZVxuICAgIC8vIG1lbW9pemVkIHByb3BzL3N0YXRlIHRvIGluZGljYXRlIHRoYXQgdGhpcyB3b3JrIGNhbiBiZSByZXVzZWQuXG5cblxuICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkUHJvcHMgPSBuZXdQcm9wcztcbiAgICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0gbmV3U3RhdGU7XG4gIH0gLy8gVXBkYXRlIHRoZSBleGlzdGluZyBpbnN0YW5jZSdzIHN0YXRlLCBwcm9wcywgYW5kIGNvbnRleHQgcG9pbnRlcnMgZXZlblxuICAvLyBpZiBzaG91bGRDb21wb25lbnRVcGRhdGUgcmV0dXJucyBmYWxzZS5cblxuXG4gIGluc3RhbmNlLnByb3BzID0gbmV3UHJvcHM7XG4gIGluc3RhbmNlLnN0YXRlID0gbmV3U3RhdGU7XG4gIGluc3RhbmNlLmNvbnRleHQgPSBuZXh0Q29udGV4dDtcbiAgcmV0dXJuIHNob3VsZFVwZGF0ZTtcbn1cblxudmFyIGRpZFdhcm5BYm91dE1hcHM7XG52YXIgZGlkV2FybkFib3V0R2VuZXJhdG9ycztcbnZhciBkaWRXYXJuQWJvdXRTdHJpbmdSZWZzO1xudmFyIG93bmVySGFzS2V5VXNlV2FybmluZztcbnZhciBvd25lckhhc0Z1bmN0aW9uVHlwZVdhcm5pbmc7XG5cbnZhciB3YXJuRm9yTWlzc2luZ0tleSA9IGZ1bmN0aW9uIChjaGlsZCwgcmV0dXJuRmliZXIpIHt9O1xuXG57XG4gIGRpZFdhcm5BYm91dE1hcHMgPSBmYWxzZTtcbiAgZGlkV2FybkFib3V0R2VuZXJhdG9ycyA9IGZhbHNlO1xuICBkaWRXYXJuQWJvdXRTdHJpbmdSZWZzID0ge307XG4gIC8qKlxuICAgKiBXYXJuIGlmIHRoZXJlJ3Mgbm8ga2V5IGV4cGxpY2l0bHkgc2V0IG9uIGR5bmFtaWMgYXJyYXlzIG9mIGNoaWxkcmVuIG9yXG4gICAqIG9iamVjdCBrZXlzIGFyZSBub3QgdmFsaWQuIFRoaXMgYWxsb3dzIHVzIHRvIGtlZXAgdHJhY2sgb2YgY2hpbGRyZW4gYmV0d2VlblxuICAgKiB1cGRhdGVzLlxuICAgKi9cblxuICBvd25lckhhc0tleVVzZVdhcm5pbmcgPSB7fTtcbiAgb3duZXJIYXNGdW5jdGlvblR5cGVXYXJuaW5nID0ge307XG5cbiAgd2FybkZvck1pc3NpbmdLZXkgPSBmdW5jdGlvbiAoY2hpbGQsIHJldHVybkZpYmVyKSB7XG4gICAgaWYgKGNoaWxkID09PSBudWxsIHx8IHR5cGVvZiBjaGlsZCAhPT0gJ29iamVjdCcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoIWNoaWxkLl9zdG9yZSB8fCBjaGlsZC5fc3RvcmUudmFsaWRhdGVkIHx8IGNoaWxkLmtleSAhPSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKCEodHlwZW9mIGNoaWxkLl9zdG9yZSA9PT0gJ29iamVjdCcpKSB7XG4gICAgICB7XG4gICAgICAgIHRocm93IEVycm9yKCBcIlJlYWN0IENvbXBvbmVudCBpbiB3YXJuRm9yTWlzc2luZ0tleSBzaG91bGQgaGF2ZSBhIF9zdG9yZS4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS5cIiApO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNoaWxkLl9zdG9yZS52YWxpZGF0ZWQgPSB0cnVlO1xuICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZShyZXR1cm5GaWJlci50eXBlKSB8fCAnQ29tcG9uZW50JztcblxuICAgIGlmIChvd25lckhhc0tleVVzZVdhcm5pbmdbY29tcG9uZW50TmFtZV0pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBvd25lckhhc0tleVVzZVdhcm5pbmdbY29tcG9uZW50TmFtZV0gPSB0cnVlO1xuXG4gICAgZXJyb3IoJ0VhY2ggY2hpbGQgaW4gYSBsaXN0IHNob3VsZCBoYXZlIGEgdW5pcXVlICcgKyAnXCJrZXlcIiBwcm9wLiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3dhcm5pbmcta2V5cyBmb3IgJyArICdtb3JlIGluZm9ybWF0aW9uLicpO1xuICB9O1xufVxuXG52YXIgaXNBcnJheSQxID0gQXJyYXkuaXNBcnJheTtcblxuZnVuY3Rpb24gY29lcmNlUmVmKHJldHVybkZpYmVyLCBjdXJyZW50LCBlbGVtZW50KSB7XG4gIHZhciBtaXhlZFJlZiA9IGVsZW1lbnQucmVmO1xuXG4gIGlmIChtaXhlZFJlZiAhPT0gbnVsbCAmJiB0eXBlb2YgbWl4ZWRSZWYgIT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIG1peGVkUmVmICE9PSAnb2JqZWN0Jykge1xuICAgIHtcbiAgICAgIC8vIFRPRE86IENsZWFuIHRoaXMgdXAgb25jZSB3ZSB0dXJuIG9uIHRoZSBzdHJpbmcgcmVmIHdhcm5pbmcgZm9yXG4gICAgICAvLyBldmVyeW9uZSwgYmVjYXVzZSB0aGUgc3RyaWN0IG1vZGUgY2FzZSB3aWxsIG5vIGxvbmdlciBiZSByZWxldmFudFxuICAgICAgaWYgKChyZXR1cm5GaWJlci5tb2RlICYgU3RyaWN0TW9kZSB8fCB3YXJuQWJvdXRTdHJpbmdSZWZzKSAmJiAvLyBXZSB3YXJuIGluIFJlYWN0RWxlbWVudC5qcyBpZiBvd25lciBhbmQgc2VsZiBhcmUgZXF1YWwgZm9yIHN0cmluZyByZWZzXG4gICAgICAvLyBiZWNhdXNlIHRoZXNlIGNhbm5vdCBiZSBhdXRvbWF0aWNhbGx5IGNvbnZlcnRlZCB0byBhbiBhcnJvdyBmdW5jdGlvblxuICAgICAgLy8gdXNpbmcgYSBjb2RlbW9kLiBUaGVyZWZvcmUsIHdlIGRvbid0IGhhdmUgdG8gd2FybiBhYm91dCBzdHJpbmcgcmVmcyBhZ2Fpbi5cbiAgICAgICEoZWxlbWVudC5fb3duZXIgJiYgZWxlbWVudC5fc2VsZiAmJiBlbGVtZW50Ll9vd25lci5zdGF0ZU5vZGUgIT09IGVsZW1lbnQuX3NlbGYpKSB7XG4gICAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZShyZXR1cm5GaWJlci50eXBlKSB8fCAnQ29tcG9uZW50JztcblxuICAgICAgICBpZiAoIWRpZFdhcm5BYm91dFN0cmluZ1JlZnNbY29tcG9uZW50TmFtZV0pIHtcbiAgICAgICAgICB7XG4gICAgICAgICAgICBlcnJvcignQSBzdHJpbmcgcmVmLCBcIiVzXCIsIGhhcyBiZWVuIGZvdW5kIHdpdGhpbiBhIHN0cmljdCBtb2RlIHRyZWUuICcgKyAnU3RyaW5nIHJlZnMgYXJlIGEgc291cmNlIG9mIHBvdGVudGlhbCBidWdzIGFuZCBzaG91bGQgYmUgYXZvaWRlZC4gJyArICdXZSByZWNvbW1lbmQgdXNpbmcgdXNlUmVmKCkgb3IgY3JlYXRlUmVmKCkgaW5zdGVhZC4gJyArICdMZWFybiBtb3JlIGFib3V0IHVzaW5nIHJlZnMgc2FmZWx5IGhlcmU6ICcgKyAnaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3N0cmljdC1tb2RlLXN0cmluZy1yZWYnLCBtaXhlZFJlZik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZGlkV2FybkFib3V0U3RyaW5nUmVmc1tjb21wb25lbnROYW1lXSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZWxlbWVudC5fb3duZXIpIHtcbiAgICAgIHZhciBvd25lciA9IGVsZW1lbnQuX293bmVyO1xuICAgICAgdmFyIGluc3Q7XG5cbiAgICAgIGlmIChvd25lcikge1xuICAgICAgICB2YXIgb3duZXJGaWJlciA9IG93bmVyO1xuXG4gICAgICAgIGlmICghKG93bmVyRmliZXIudGFnID09PSBDbGFzc0NvbXBvbmVudCkpIHtcbiAgICAgICAgICB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvciggXCJGdW5jdGlvbiBjb21wb25lbnRzIGNhbm5vdCBoYXZlIHN0cmluZyByZWZzLiBXZSByZWNvbW1lbmQgdXNpbmcgdXNlUmVmKCkgaW5zdGVhZC4gTGVhcm4gbW9yZSBhYm91dCB1c2luZyByZWZzIHNhZmVseSBoZXJlOiBodHRwczovL3JlYWN0anMub3JnL2xpbmsvc3RyaWN0LW1vZGUtc3RyaW5nLXJlZlwiICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaW5zdCA9IG93bmVyRmliZXIuc3RhdGVOb2RlO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWluc3QpIHtcbiAgICAgICAge1xuICAgICAgICAgIHRocm93IEVycm9yKCBcIk1pc3Npbmcgb3duZXIgZm9yIHN0cmluZyByZWYgXCIgKyBtaXhlZFJlZiArIFwiLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiICk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIHN0cmluZ1JlZiA9ICcnICsgbWl4ZWRSZWY7IC8vIENoZWNrIGlmIHByZXZpb3VzIHN0cmluZyByZWYgbWF0Y2hlcyBuZXcgc3RyaW5nIHJlZlxuXG4gICAgICBpZiAoY3VycmVudCAhPT0gbnVsbCAmJiBjdXJyZW50LnJlZiAhPT0gbnVsbCAmJiB0eXBlb2YgY3VycmVudC5yZWYgPT09ICdmdW5jdGlvbicgJiYgY3VycmVudC5yZWYuX3N0cmluZ1JlZiA9PT0gc3RyaW5nUmVmKSB7XG4gICAgICAgIHJldHVybiBjdXJyZW50LnJlZjtcbiAgICAgIH1cblxuICAgICAgdmFyIHJlZiA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YXIgcmVmcyA9IGluc3QucmVmcztcblxuICAgICAgICBpZiAocmVmcyA9PT0gZW1wdHlSZWZzT2JqZWN0KSB7XG4gICAgICAgICAgLy8gVGhpcyBpcyBhIGxhenkgcG9vbGVkIGZyb3plbiBvYmplY3QsIHNvIHdlIG5lZWQgdG8gaW5pdGlhbGl6ZS5cbiAgICAgICAgICByZWZzID0gaW5zdC5yZWZzID0ge307XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICBkZWxldGUgcmVmc1tzdHJpbmdSZWZdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlZnNbc3RyaW5nUmVmXSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICByZWYuX3N0cmluZ1JlZiA9IHN0cmluZ1JlZjtcbiAgICAgIHJldHVybiByZWY7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICghKHR5cGVvZiBtaXhlZFJlZiA9PT0gJ3N0cmluZycpKSB7XG4gICAgICAgIHtcbiAgICAgICAgICB0aHJvdyBFcnJvciggXCJFeHBlY3RlZCByZWYgdG8gYmUgYSBmdW5jdGlvbiwgYSBzdHJpbmcsIGFuIG9iamVjdCByZXR1cm5lZCBieSBSZWFjdC5jcmVhdGVSZWYoKSwgb3IgbnVsbC5cIiApO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICghZWxlbWVudC5fb3duZXIpIHtcbiAgICAgICAge1xuICAgICAgICAgIHRocm93IEVycm9yKCBcIkVsZW1lbnQgcmVmIHdhcyBzcGVjaWZpZWQgYXMgYSBzdHJpbmcgKFwiICsgbWl4ZWRSZWYgKyBcIikgYnV0IG5vIG93bmVyIHdhcyBzZXQuIFRoaXMgY291bGQgaGFwcGVuIGZvciBvbmUgb2YgdGhlIGZvbGxvd2luZyByZWFzb25zOlxcbjEuIFlvdSBtYXkgYmUgYWRkaW5nIGEgcmVmIHRvIGEgZnVuY3Rpb24gY29tcG9uZW50XFxuMi4gWW91IG1heSBiZSBhZGRpbmcgYSByZWYgdG8gYSBjb21wb25lbnQgdGhhdCB3YXMgbm90IGNyZWF0ZWQgaW5zaWRlIGEgY29tcG9uZW50J3MgcmVuZGVyIG1ldGhvZFxcbjMuIFlvdSBoYXZlIG11bHRpcGxlIGNvcGllcyBvZiBSZWFjdCBsb2FkZWRcXG5TZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3JlZnMtbXVzdC1oYXZlLW93bmVyIGZvciBtb3JlIGluZm9ybWF0aW9uLlwiICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbWl4ZWRSZWY7XG59XG5cbmZ1bmN0aW9uIHRocm93T25JbnZhbGlkT2JqZWN0VHlwZShyZXR1cm5GaWJlciwgbmV3Q2hpbGQpIHtcbiAgaWYgKHJldHVybkZpYmVyLnR5cGUgIT09ICd0ZXh0YXJlYScpIHtcbiAgICB7XG4gICAgICB7XG4gICAgICAgIHRocm93IEVycm9yKCBcIk9iamVjdHMgYXJlIG5vdCB2YWxpZCBhcyBhIFJlYWN0IGNoaWxkIChmb3VuZDogXCIgKyAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG5ld0NoaWxkKSA9PT0gJ1tvYmplY3QgT2JqZWN0XScgPyAnb2JqZWN0IHdpdGgga2V5cyB7JyArIE9iamVjdC5rZXlzKG5ld0NoaWxkKS5qb2luKCcsICcpICsgJ30nIDogbmV3Q2hpbGQpICsgXCIpLiBJZiB5b3UgbWVhbnQgdG8gcmVuZGVyIGEgY29sbGVjdGlvbiBvZiBjaGlsZHJlbiwgdXNlIGFuIGFycmF5IGluc3RlYWQuXCIgKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gd2Fybk9uRnVuY3Rpb25UeXBlKHJldHVybkZpYmVyKSB7XG4gIHtcbiAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWUocmV0dXJuRmliZXIudHlwZSkgfHwgJ0NvbXBvbmVudCc7XG5cbiAgICBpZiAob3duZXJIYXNGdW5jdGlvblR5cGVXYXJuaW5nW2NvbXBvbmVudE5hbWVdKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgb3duZXJIYXNGdW5jdGlvblR5cGVXYXJuaW5nW2NvbXBvbmVudE5hbWVdID0gdHJ1ZTtcblxuICAgIGVycm9yKCdGdW5jdGlvbnMgYXJlIG5vdCB2YWxpZCBhcyBhIFJlYWN0IGNoaWxkLiBUaGlzIG1heSBoYXBwZW4gaWYgJyArICd5b3UgcmV0dXJuIGEgQ29tcG9uZW50IGluc3RlYWQgb2YgPENvbXBvbmVudCAvPiBmcm9tIHJlbmRlci4gJyArICdPciBtYXliZSB5b3UgbWVhbnQgdG8gY2FsbCB0aGlzIGZ1bmN0aW9uIHJhdGhlciB0aGFuIHJldHVybiBpdC4nKTtcbiAgfVxufSAvLyBXZSBhdm9pZCBpbmxpbmluZyB0aGlzIHRvIGF2b2lkIHBvdGVudGlhbCBkZW9wdHMgZnJvbSB1c2luZyB0cnkvY2F0Y2guXG4vLyB0byBiZSBhYmxlIHRvIG9wdGltaXplIGVhY2ggcGF0aCBpbmRpdmlkdWFsbHkgYnkgYnJhbmNoaW5nIGVhcmx5LiBUaGlzIG5lZWRzXG4vLyBhIGNvbXBpbGVyIG9yIHdlIGNhbiBkbyBpdCBtYW51YWxseS4gSGVscGVycyB0aGF0IGRvbid0IG5lZWQgdGhpcyBicmFuY2hpbmdcbi8vIGxpdmUgb3V0c2lkZSBvZiB0aGlzIGZ1bmN0aW9uLlxuXG5cbmZ1bmN0aW9uIENoaWxkUmVjb25jaWxlcihzaG91bGRUcmFja1NpZGVFZmZlY3RzKSB7XG4gIGZ1bmN0aW9uIGRlbGV0ZUNoaWxkKHJldHVybkZpYmVyLCBjaGlsZFRvRGVsZXRlKSB7XG4gICAgaWYgKCFzaG91bGRUcmFja1NpZGVFZmZlY3RzKSB7XG4gICAgICAvLyBOb29wLlxuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gRGVsZXRpb25zIGFyZSBhZGRlZCBpbiByZXZlcnNlZCBvcmRlciBzbyB3ZSBhZGQgaXQgdG8gdGhlIGZyb250LlxuICAgIC8vIEF0IHRoaXMgcG9pbnQsIHRoZSByZXR1cm4gZmliZXIncyBlZmZlY3QgbGlzdCBpcyBlbXB0eSBleGNlcHQgZm9yXG4gICAgLy8gZGVsZXRpb25zLCBzbyB3ZSBjYW4ganVzdCBhcHBlbmQgdGhlIGRlbGV0aW9uIHRvIHRoZSBsaXN0LiBUaGUgcmVtYWluaW5nXG4gICAgLy8gZWZmZWN0cyBhcmVuJ3QgYWRkZWQgdW50aWwgdGhlIGNvbXBsZXRlIHBoYXNlLiBPbmNlIHdlIGltcGxlbWVudFxuICAgIC8vIHJlc3VtaW5nLCB0aGlzIG1heSBub3QgYmUgdHJ1ZS5cblxuXG4gICAgdmFyIGxhc3QgPSByZXR1cm5GaWJlci5sYXN0RWZmZWN0O1xuXG4gICAgaWYgKGxhc3QgIT09IG51bGwpIHtcbiAgICAgIGxhc3QubmV4dEVmZmVjdCA9IGNoaWxkVG9EZWxldGU7XG4gICAgICByZXR1cm5GaWJlci5sYXN0RWZmZWN0ID0gY2hpbGRUb0RlbGV0ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuRmliZXIuZmlyc3RFZmZlY3QgPSByZXR1cm5GaWJlci5sYXN0RWZmZWN0ID0gY2hpbGRUb0RlbGV0ZTtcbiAgICB9XG5cbiAgICBjaGlsZFRvRGVsZXRlLm5leHRFZmZlY3QgPSBudWxsO1xuICAgIGNoaWxkVG9EZWxldGUuZmxhZ3MgPSBEZWxldGlvbjtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRlbGV0ZVJlbWFpbmluZ0NoaWxkcmVuKHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCkge1xuICAgIGlmICghc2hvdWxkVHJhY2tTaWRlRWZmZWN0cykge1xuICAgICAgLy8gTm9vcC5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0gLy8gVE9ETzogRm9yIHRoZSBzaG91bGRDbG9uZSBjYXNlLCB0aGlzIGNvdWxkIGJlIG1pY3JvLW9wdGltaXplZCBhIGJpdCBieVxuICAgIC8vIGFzc3VtaW5nIHRoYXQgYWZ0ZXIgdGhlIGZpcnN0IGNoaWxkIHdlJ3ZlIGFscmVhZHkgYWRkZWQgZXZlcnl0aGluZy5cblxuXG4gICAgdmFyIGNoaWxkVG9EZWxldGUgPSBjdXJyZW50Rmlyc3RDaGlsZDtcblxuICAgIHdoaWxlIChjaGlsZFRvRGVsZXRlICE9PSBudWxsKSB7XG4gICAgICBkZWxldGVDaGlsZChyZXR1cm5GaWJlciwgY2hpbGRUb0RlbGV0ZSk7XG4gICAgICBjaGlsZFRvRGVsZXRlID0gY2hpbGRUb0RlbGV0ZS5zaWJsaW5nO1xuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgZnVuY3Rpb24gbWFwUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkKSB7XG4gICAgLy8gQWRkIHRoZSByZW1haW5pbmcgY2hpbGRyZW4gdG8gYSB0ZW1wb3JhcnkgbWFwIHNvIHRoYXQgd2UgY2FuIGZpbmQgdGhlbSBieVxuICAgIC8vIGtleXMgcXVpY2tseS4gSW1wbGljaXQgKG51bGwpIGtleXMgZ2V0IGFkZGVkIHRvIHRoaXMgc2V0IHdpdGggdGhlaXIgaW5kZXhcbiAgICAvLyBpbnN0ZWFkLlxuICAgIHZhciBleGlzdGluZ0NoaWxkcmVuID0gbmV3IE1hcCgpO1xuICAgIHZhciBleGlzdGluZ0NoaWxkID0gY3VycmVudEZpcnN0Q2hpbGQ7XG5cbiAgICB3aGlsZSAoZXhpc3RpbmdDaGlsZCAhPT0gbnVsbCkge1xuICAgICAgaWYgKGV4aXN0aW5nQ2hpbGQua2V5ICE9PSBudWxsKSB7XG4gICAgICAgIGV4aXN0aW5nQ2hpbGRyZW4uc2V0KGV4aXN0aW5nQ2hpbGQua2V5LCBleGlzdGluZ0NoaWxkKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGV4aXN0aW5nQ2hpbGRyZW4uc2V0KGV4aXN0aW5nQ2hpbGQuaW5kZXgsIGV4aXN0aW5nQ2hpbGQpO1xuICAgICAgfVxuXG4gICAgICBleGlzdGluZ0NoaWxkID0gZXhpc3RpbmdDaGlsZC5zaWJsaW5nO1xuICAgIH1cblxuICAgIHJldHVybiBleGlzdGluZ0NoaWxkcmVuO1xuICB9XG5cbiAgZnVuY3Rpb24gdXNlRmliZXIoZmliZXIsIHBlbmRpbmdQcm9wcykge1xuICAgIC8vIFdlIGN1cnJlbnRseSBzZXQgc2libGluZyB0byBudWxsIGFuZCBpbmRleCB0byAwIGhlcmUgYmVjYXVzZSBpdCBpcyBlYXN5XG4gICAgLy8gdG8gZm9yZ2V0IHRvIGRvIGJlZm9yZSByZXR1cm5pbmcgaXQuIEUuZy4gZm9yIHRoZSBzaW5nbGUgY2hpbGQgY2FzZS5cbiAgICB2YXIgY2xvbmUgPSBjcmVhdGVXb3JrSW5Qcm9ncmVzcyhmaWJlciwgcGVuZGluZ1Byb3BzKTtcbiAgICBjbG9uZS5pbmRleCA9IDA7XG4gICAgY2xvbmUuc2libGluZyA9IG51bGw7XG4gICAgcmV0dXJuIGNsb25lO1xuICB9XG5cbiAgZnVuY3Rpb24gcGxhY2VDaGlsZChuZXdGaWJlciwgbGFzdFBsYWNlZEluZGV4LCBuZXdJbmRleCkge1xuICAgIG5ld0ZpYmVyLmluZGV4ID0gbmV3SW5kZXg7XG5cbiAgICBpZiAoIXNob3VsZFRyYWNrU2lkZUVmZmVjdHMpIHtcbiAgICAgIC8vIE5vb3AuXG4gICAgICByZXR1cm4gbGFzdFBsYWNlZEluZGV4O1xuICAgIH1cblxuICAgIHZhciBjdXJyZW50ID0gbmV3RmliZXIuYWx0ZXJuYXRlO1xuXG4gICAgaWYgKGN1cnJlbnQgIT09IG51bGwpIHtcbiAgICAgIHZhciBvbGRJbmRleCA9IGN1cnJlbnQuaW5kZXg7XG5cbiAgICAgIGlmIChvbGRJbmRleCA8IGxhc3RQbGFjZWRJbmRleCkge1xuICAgICAgICAvLyBUaGlzIGlzIGEgbW92ZS5cbiAgICAgICAgbmV3RmliZXIuZmxhZ3MgPSBQbGFjZW1lbnQ7XG4gICAgICAgIHJldHVybiBsYXN0UGxhY2VkSW5kZXg7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBUaGlzIGl0ZW0gY2FuIHN0YXkgaW4gcGxhY2UuXG4gICAgICAgIHJldHVybiBvbGRJbmRleDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVGhpcyBpcyBhbiBpbnNlcnRpb24uXG4gICAgICBuZXdGaWJlci5mbGFncyA9IFBsYWNlbWVudDtcbiAgICAgIHJldHVybiBsYXN0UGxhY2VkSW5kZXg7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcGxhY2VTaW5nbGVDaGlsZChuZXdGaWJlcikge1xuICAgIC8vIFRoaXMgaXMgc2ltcGxlciBmb3IgdGhlIHNpbmdsZSBjaGlsZCBjYXNlLiBXZSBvbmx5IG5lZWQgdG8gZG8gYVxuICAgIC8vIHBsYWNlbWVudCBmb3IgaW5zZXJ0aW5nIG5ldyBjaGlsZHJlbi5cbiAgICBpZiAoc2hvdWxkVHJhY2tTaWRlRWZmZWN0cyAmJiBuZXdGaWJlci5hbHRlcm5hdGUgPT09IG51bGwpIHtcbiAgICAgIG5ld0ZpYmVyLmZsYWdzID0gUGxhY2VtZW50O1xuICAgIH1cblxuICAgIHJldHVybiBuZXdGaWJlcjtcbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZVRleHROb2RlKHJldHVybkZpYmVyLCBjdXJyZW50LCB0ZXh0Q29udGVudCwgbGFuZXMpIHtcbiAgICBpZiAoY3VycmVudCA9PT0gbnVsbCB8fCBjdXJyZW50LnRhZyAhPT0gSG9zdFRleHQpIHtcbiAgICAgIC8vIEluc2VydFxuICAgICAgdmFyIGNyZWF0ZWQgPSBjcmVhdGVGaWJlckZyb21UZXh0KHRleHRDb250ZW50LCByZXR1cm5GaWJlci5tb2RlLCBsYW5lcyk7XG4gICAgICBjcmVhdGVkLnJldHVybiA9IHJldHVybkZpYmVyO1xuICAgICAgcmV0dXJuIGNyZWF0ZWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFVwZGF0ZVxuICAgICAgdmFyIGV4aXN0aW5nID0gdXNlRmliZXIoY3VycmVudCwgdGV4dENvbnRlbnQpO1xuICAgICAgZXhpc3RpbmcucmV0dXJuID0gcmV0dXJuRmliZXI7XG4gICAgICByZXR1cm4gZXhpc3Rpbmc7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlRWxlbWVudChyZXR1cm5GaWJlciwgY3VycmVudCwgZWxlbWVudCwgbGFuZXMpIHtcbiAgICBpZiAoY3VycmVudCAhPT0gbnVsbCkge1xuICAgICAgaWYgKGN1cnJlbnQuZWxlbWVudFR5cGUgPT09IGVsZW1lbnQudHlwZSB8fCAoIC8vIEtlZXAgdGhpcyBjaGVjayBpbmxpbmUgc28gaXQgb25seSBydW5zIG9uIHRoZSBmYWxzZSBwYXRoOlxuICAgICAgIGlzQ29tcGF0aWJsZUZhbWlseUZvckhvdFJlbG9hZGluZyhjdXJyZW50LCBlbGVtZW50KSApKSB7XG4gICAgICAgIC8vIE1vdmUgYmFzZWQgb24gaW5kZXhcbiAgICAgICAgdmFyIGV4aXN0aW5nID0gdXNlRmliZXIoY3VycmVudCwgZWxlbWVudC5wcm9wcyk7XG4gICAgICAgIGV4aXN0aW5nLnJlZiA9IGNvZXJjZVJlZihyZXR1cm5GaWJlciwgY3VycmVudCwgZWxlbWVudCk7XG4gICAgICAgIGV4aXN0aW5nLnJldHVybiA9IHJldHVybkZpYmVyO1xuXG4gICAgICAgIHtcbiAgICAgICAgICBleGlzdGluZy5fZGVidWdTb3VyY2UgPSBlbGVtZW50Ll9zb3VyY2U7XG4gICAgICAgICAgZXhpc3RpbmcuX2RlYnVnT3duZXIgPSBlbGVtZW50Ll9vd25lcjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBleGlzdGluZztcbiAgICAgIH1cbiAgICB9IC8vIEluc2VydFxuXG5cbiAgICB2YXIgY3JlYXRlZCA9IGNyZWF0ZUZpYmVyRnJvbUVsZW1lbnQoZWxlbWVudCwgcmV0dXJuRmliZXIubW9kZSwgbGFuZXMpO1xuICAgIGNyZWF0ZWQucmVmID0gY29lcmNlUmVmKHJldHVybkZpYmVyLCBjdXJyZW50LCBlbGVtZW50KTtcbiAgICBjcmVhdGVkLnJldHVybiA9IHJldHVybkZpYmVyO1xuICAgIHJldHVybiBjcmVhdGVkO1xuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlUG9ydGFsKHJldHVybkZpYmVyLCBjdXJyZW50LCBwb3J0YWwsIGxhbmVzKSB7XG4gICAgaWYgKGN1cnJlbnQgPT09IG51bGwgfHwgY3VycmVudC50YWcgIT09IEhvc3RQb3J0YWwgfHwgY3VycmVudC5zdGF0ZU5vZGUuY29udGFpbmVySW5mbyAhPT0gcG9ydGFsLmNvbnRhaW5lckluZm8gfHwgY3VycmVudC5zdGF0ZU5vZGUuaW1wbGVtZW50YXRpb24gIT09IHBvcnRhbC5pbXBsZW1lbnRhdGlvbikge1xuICAgICAgLy8gSW5zZXJ0XG4gICAgICB2YXIgY3JlYXRlZCA9IGNyZWF0ZUZpYmVyRnJvbVBvcnRhbChwb3J0YWwsIHJldHVybkZpYmVyLm1vZGUsIGxhbmVzKTtcbiAgICAgIGNyZWF0ZWQucmV0dXJuID0gcmV0dXJuRmliZXI7XG4gICAgICByZXR1cm4gY3JlYXRlZDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVXBkYXRlXG4gICAgICB2YXIgZXhpc3RpbmcgPSB1c2VGaWJlcihjdXJyZW50LCBwb3J0YWwuY2hpbGRyZW4gfHwgW10pO1xuICAgICAgZXhpc3RpbmcucmV0dXJuID0gcmV0dXJuRmliZXI7XG4gICAgICByZXR1cm4gZXhpc3Rpbmc7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlRnJhZ21lbnQocmV0dXJuRmliZXIsIGN1cnJlbnQsIGZyYWdtZW50LCBsYW5lcywga2V5KSB7XG4gICAgaWYgKGN1cnJlbnQgPT09IG51bGwgfHwgY3VycmVudC50YWcgIT09IEZyYWdtZW50KSB7XG4gICAgICAvLyBJbnNlcnRcbiAgICAgIHZhciBjcmVhdGVkID0gY3JlYXRlRmliZXJGcm9tRnJhZ21lbnQoZnJhZ21lbnQsIHJldHVybkZpYmVyLm1vZGUsIGxhbmVzLCBrZXkpO1xuICAgICAgY3JlYXRlZC5yZXR1cm4gPSByZXR1cm5GaWJlcjtcbiAgICAgIHJldHVybiBjcmVhdGVkO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBVcGRhdGVcbiAgICAgIHZhciBleGlzdGluZyA9IHVzZUZpYmVyKGN1cnJlbnQsIGZyYWdtZW50KTtcbiAgICAgIGV4aXN0aW5nLnJldHVybiA9IHJldHVybkZpYmVyO1xuICAgICAgcmV0dXJuIGV4aXN0aW5nO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUNoaWxkKHJldHVybkZpYmVyLCBuZXdDaGlsZCwgbGFuZXMpIHtcbiAgICBpZiAodHlwZW9mIG5ld0NoaWxkID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgbmV3Q2hpbGQgPT09ICdudW1iZXInKSB7XG4gICAgICAvLyBUZXh0IG5vZGVzIGRvbid0IGhhdmUga2V5cy4gSWYgdGhlIHByZXZpb3VzIG5vZGUgaXMgaW1wbGljaXRseSBrZXllZFxuICAgICAgLy8gd2UgY2FuIGNvbnRpbnVlIHRvIHJlcGxhY2UgaXQgd2l0aG91dCBhYm9ydGluZyBldmVuIGlmIGl0IGlzIG5vdCBhIHRleHRcbiAgICAgIC8vIG5vZGUuXG4gICAgICB2YXIgY3JlYXRlZCA9IGNyZWF0ZUZpYmVyRnJvbVRleHQoJycgKyBuZXdDaGlsZCwgcmV0dXJuRmliZXIubW9kZSwgbGFuZXMpO1xuICAgICAgY3JlYXRlZC5yZXR1cm4gPSByZXR1cm5GaWJlcjtcbiAgICAgIHJldHVybiBjcmVhdGVkO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgbmV3Q2hpbGQgPT09ICdvYmplY3QnICYmIG5ld0NoaWxkICE9PSBudWxsKSB7XG4gICAgICBzd2l0Y2ggKG5ld0NoaWxkLiQkdHlwZW9mKSB7XG4gICAgICAgIGNhc2UgUkVBQ1RfRUxFTUVOVF9UWVBFOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHZhciBfY3JlYXRlZCA9IGNyZWF0ZUZpYmVyRnJvbUVsZW1lbnQobmV3Q2hpbGQsIHJldHVybkZpYmVyLm1vZGUsIGxhbmVzKTtcblxuICAgICAgICAgICAgX2NyZWF0ZWQucmVmID0gY29lcmNlUmVmKHJldHVybkZpYmVyLCBudWxsLCBuZXdDaGlsZCk7XG4gICAgICAgICAgICBfY3JlYXRlZC5yZXR1cm4gPSByZXR1cm5GaWJlcjtcbiAgICAgICAgICAgIHJldHVybiBfY3JlYXRlZDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSBSRUFDVF9QT1JUQUxfVFlQRTpcbiAgICAgICAgICB7XG4gICAgICAgICAgICB2YXIgX2NyZWF0ZWQyID0gY3JlYXRlRmliZXJGcm9tUG9ydGFsKG5ld0NoaWxkLCByZXR1cm5GaWJlci5tb2RlLCBsYW5lcyk7XG5cbiAgICAgICAgICAgIF9jcmVhdGVkMi5yZXR1cm4gPSByZXR1cm5GaWJlcjtcbiAgICAgICAgICAgIHJldHVybiBfY3JlYXRlZDI7XG4gICAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoaXNBcnJheSQxKG5ld0NoaWxkKSB8fCBnZXRJdGVyYXRvckZuKG5ld0NoaWxkKSkge1xuICAgICAgICB2YXIgX2NyZWF0ZWQzID0gY3JlYXRlRmliZXJGcm9tRnJhZ21lbnQobmV3Q2hpbGQsIHJldHVybkZpYmVyLm1vZGUsIGxhbmVzLCBudWxsKTtcblxuICAgICAgICBfY3JlYXRlZDMucmV0dXJuID0gcmV0dXJuRmliZXI7XG4gICAgICAgIHJldHVybiBfY3JlYXRlZDM7XG4gICAgICB9XG5cbiAgICAgIHRocm93T25JbnZhbGlkT2JqZWN0VHlwZShyZXR1cm5GaWJlciwgbmV3Q2hpbGQpO1xuICAgIH1cblxuICAgIHtcbiAgICAgIGlmICh0eXBlb2YgbmV3Q2hpbGQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgd2Fybk9uRnVuY3Rpb25UeXBlKHJldHVybkZpYmVyKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZVNsb3QocmV0dXJuRmliZXIsIG9sZEZpYmVyLCBuZXdDaGlsZCwgbGFuZXMpIHtcbiAgICAvLyBVcGRhdGUgdGhlIGZpYmVyIGlmIHRoZSBrZXlzIG1hdGNoLCBvdGhlcndpc2UgcmV0dXJuIG51bGwuXG4gICAgdmFyIGtleSA9IG9sZEZpYmVyICE9PSBudWxsID8gb2xkRmliZXIua2V5IDogbnVsbDtcblxuICAgIGlmICh0eXBlb2YgbmV3Q2hpbGQgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBuZXdDaGlsZCA9PT0gJ251bWJlcicpIHtcbiAgICAgIC8vIFRleHQgbm9kZXMgZG9uJ3QgaGF2ZSBrZXlzLiBJZiB0aGUgcHJldmlvdXMgbm9kZSBpcyBpbXBsaWNpdGx5IGtleWVkXG4gICAgICAvLyB3ZSBjYW4gY29udGludWUgdG8gcmVwbGFjZSBpdCB3aXRob3V0IGFib3J0aW5nIGV2ZW4gaWYgaXQgaXMgbm90IGEgdGV4dFxuICAgICAgLy8gbm9kZS5cbiAgICAgIGlmIChrZXkgIT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB1cGRhdGVUZXh0Tm9kZShyZXR1cm5GaWJlciwgb2xkRmliZXIsICcnICsgbmV3Q2hpbGQsIGxhbmVzKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIG5ld0NoaWxkID09PSAnb2JqZWN0JyAmJiBuZXdDaGlsZCAhPT0gbnVsbCkge1xuICAgICAgc3dpdGNoIChuZXdDaGlsZC4kJHR5cGVvZikge1xuICAgICAgICBjYXNlIFJFQUNUX0VMRU1FTlRfVFlQRTpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBpZiAobmV3Q2hpbGQua2V5ID09PSBrZXkpIHtcbiAgICAgICAgICAgICAgaWYgKG5ld0NoaWxkLnR5cGUgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdXBkYXRlRnJhZ21lbnQocmV0dXJuRmliZXIsIG9sZEZpYmVyLCBuZXdDaGlsZC5wcm9wcy5jaGlsZHJlbiwgbGFuZXMsIGtleSk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICByZXR1cm4gdXBkYXRlRWxlbWVudChyZXR1cm5GaWJlciwgb2xkRmliZXIsIG5ld0NoaWxkLCBsYW5lcyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSBSRUFDVF9QT1JUQUxfVFlQRTpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBpZiAobmV3Q2hpbGQua2V5ID09PSBrZXkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHVwZGF0ZVBvcnRhbChyZXR1cm5GaWJlciwgb2xkRmliZXIsIG5ld0NoaWxkLCBsYW5lcyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChpc0FycmF5JDEobmV3Q2hpbGQpIHx8IGdldEl0ZXJhdG9yRm4obmV3Q2hpbGQpKSB7XG4gICAgICAgIGlmIChrZXkgIT09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB1cGRhdGVGcmFnbWVudChyZXR1cm5GaWJlciwgb2xkRmliZXIsIG5ld0NoaWxkLCBsYW5lcywgbnVsbCk7XG4gICAgICB9XG5cbiAgICAgIHRocm93T25JbnZhbGlkT2JqZWN0VHlwZShyZXR1cm5GaWJlciwgbmV3Q2hpbGQpO1xuICAgIH1cblxuICAgIHtcbiAgICAgIGlmICh0eXBlb2YgbmV3Q2hpbGQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgd2Fybk9uRnVuY3Rpb25UeXBlKHJldHVybkZpYmVyKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZUZyb21NYXAoZXhpc3RpbmdDaGlsZHJlbiwgcmV0dXJuRmliZXIsIG5ld0lkeCwgbmV3Q2hpbGQsIGxhbmVzKSB7XG4gICAgaWYgKHR5cGVvZiBuZXdDaGlsZCA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIG5ld0NoaWxkID09PSAnbnVtYmVyJykge1xuICAgICAgLy8gVGV4dCBub2RlcyBkb24ndCBoYXZlIGtleXMsIHNvIHdlIG5laXRoZXIgaGF2ZSB0byBjaGVjayB0aGUgb2xkIG5vclxuICAgICAgLy8gbmV3IG5vZGUgZm9yIHRoZSBrZXkuIElmIGJvdGggYXJlIHRleHQgbm9kZXMsIHRoZXkgbWF0Y2guXG4gICAgICB2YXIgbWF0Y2hlZEZpYmVyID0gZXhpc3RpbmdDaGlsZHJlbi5nZXQobmV3SWR4KSB8fCBudWxsO1xuICAgICAgcmV0dXJuIHVwZGF0ZVRleHROb2RlKHJldHVybkZpYmVyLCBtYXRjaGVkRmliZXIsICcnICsgbmV3Q2hpbGQsIGxhbmVzKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIG5ld0NoaWxkID09PSAnb2JqZWN0JyAmJiBuZXdDaGlsZCAhPT0gbnVsbCkge1xuICAgICAgc3dpdGNoIChuZXdDaGlsZC4kJHR5cGVvZikge1xuICAgICAgICBjYXNlIFJFQUNUX0VMRU1FTlRfVFlQRTpcbiAgICAgICAgICB7XG4gICAgICAgICAgICB2YXIgX21hdGNoZWRGaWJlciA9IGV4aXN0aW5nQ2hpbGRyZW4uZ2V0KG5ld0NoaWxkLmtleSA9PT0gbnVsbCA/IG5ld0lkeCA6IG5ld0NoaWxkLmtleSkgfHwgbnVsbDtcblxuICAgICAgICAgICAgaWYgKG5ld0NoaWxkLnR5cGUgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEUpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHVwZGF0ZUZyYWdtZW50KHJldHVybkZpYmVyLCBfbWF0Y2hlZEZpYmVyLCBuZXdDaGlsZC5wcm9wcy5jaGlsZHJlbiwgbGFuZXMsIG5ld0NoaWxkLmtleSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB1cGRhdGVFbGVtZW50KHJldHVybkZpYmVyLCBfbWF0Y2hlZEZpYmVyLCBuZXdDaGlsZCwgbGFuZXMpO1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHZhciBfbWF0Y2hlZEZpYmVyMiA9IGV4aXN0aW5nQ2hpbGRyZW4uZ2V0KG5ld0NoaWxkLmtleSA9PT0gbnVsbCA/IG5ld0lkeCA6IG5ld0NoaWxkLmtleSkgfHwgbnVsbDtcblxuICAgICAgICAgICAgcmV0dXJuIHVwZGF0ZVBvcnRhbChyZXR1cm5GaWJlciwgX21hdGNoZWRGaWJlcjIsIG5ld0NoaWxkLCBsYW5lcyk7XG4gICAgICAgICAgfVxuXG4gICAgICB9XG5cbiAgICAgIGlmIChpc0FycmF5JDEobmV3Q2hpbGQpIHx8IGdldEl0ZXJhdG9yRm4obmV3Q2hpbGQpKSB7XG4gICAgICAgIHZhciBfbWF0Y2hlZEZpYmVyMyA9IGV4aXN0aW5nQ2hpbGRyZW4uZ2V0KG5ld0lkeCkgfHwgbnVsbDtcblxuICAgICAgICByZXR1cm4gdXBkYXRlRnJhZ21lbnQocmV0dXJuRmliZXIsIF9tYXRjaGVkRmliZXIzLCBuZXdDaGlsZCwgbGFuZXMsIG51bGwpO1xuICAgICAgfVxuXG4gICAgICB0aHJvd09uSW52YWxpZE9iamVjdFR5cGUocmV0dXJuRmliZXIsIG5ld0NoaWxkKTtcbiAgICB9XG5cbiAgICB7XG4gICAgICBpZiAodHlwZW9mIG5ld0NoaWxkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHdhcm5PbkZ1bmN0aW9uVHlwZShyZXR1cm5GaWJlcik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgLyoqXG4gICAqIFdhcm5zIGlmIHRoZXJlIGlzIGEgZHVwbGljYXRlIG9yIG1pc3Npbmcga2V5XG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gd2Fybk9uSW52YWxpZEtleShjaGlsZCwga25vd25LZXlzLCByZXR1cm5GaWJlcikge1xuICAgIHtcbiAgICAgIGlmICh0eXBlb2YgY2hpbGQgIT09ICdvYmplY3QnIHx8IGNoaWxkID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBrbm93bktleXM7XG4gICAgICB9XG5cbiAgICAgIHN3aXRjaCAoY2hpbGQuJCR0eXBlb2YpIHtcbiAgICAgICAgY2FzZSBSRUFDVF9FTEVNRU5UX1RZUEU6XG4gICAgICAgIGNhc2UgUkVBQ1RfUE9SVEFMX1RZUEU6XG4gICAgICAgICAgd2FybkZvck1pc3NpbmdLZXkoY2hpbGQsIHJldHVybkZpYmVyKTtcbiAgICAgICAgICB2YXIga2V5ID0gY2hpbGQua2V5O1xuXG4gICAgICAgICAgaWYgKHR5cGVvZiBrZXkgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoa25vd25LZXlzID09PSBudWxsKSB7XG4gICAgICAgICAgICBrbm93bktleXMgPSBuZXcgU2V0KCk7XG4gICAgICAgICAgICBrbm93bktleXMuYWRkKGtleSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoIWtub3duS2V5cy5oYXMoa2V5KSkge1xuICAgICAgICAgICAga25vd25LZXlzLmFkZChrZXkpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZXJyb3IoJ0VuY291bnRlcmVkIHR3byBjaGlsZHJlbiB3aXRoIHRoZSBzYW1lIGtleSwgYCVzYC4gJyArICdLZXlzIHNob3VsZCBiZSB1bmlxdWUgc28gdGhhdCBjb21wb25lbnRzIG1haW50YWluIHRoZWlyIGlkZW50aXR5ICcgKyAnYWNyb3NzIHVwZGF0ZXMuIE5vbi11bmlxdWUga2V5cyBtYXkgY2F1c2UgY2hpbGRyZW4gdG8gYmUgJyArICdkdXBsaWNhdGVkIGFuZC9vciBvbWl0dGVkIOKAlCB0aGUgYmVoYXZpb3IgaXMgdW5zdXBwb3J0ZWQgYW5kICcgKyAnY291bGQgY2hhbmdlIGluIGEgZnV0dXJlIHZlcnNpb24uJywga2V5KTtcblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBrbm93bktleXM7XG4gIH1cblxuICBmdW5jdGlvbiByZWNvbmNpbGVDaGlsZHJlbkFycmF5KHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCwgbmV3Q2hpbGRyZW4sIGxhbmVzKSB7XG4gICAgLy8gVGhpcyBhbGdvcml0aG0gY2FuJ3Qgb3B0aW1pemUgYnkgc2VhcmNoaW5nIGZyb20gYm90aCBlbmRzIHNpbmNlIHdlXG4gICAgLy8gZG9uJ3QgaGF2ZSBiYWNrcG9pbnRlcnMgb24gZmliZXJzLiBJJ20gdHJ5aW5nIHRvIHNlZSBob3cgZmFyIHdlIGNhbiBnZXRcbiAgICAvLyB3aXRoIHRoYXQgbW9kZWwuIElmIGl0IGVuZHMgdXAgbm90IGJlaW5nIHdvcnRoIHRoZSB0cmFkZW9mZnMsIHdlIGNhblxuICAgIC8vIGFkZCBpdCBsYXRlci5cbiAgICAvLyBFdmVuIHdpdGggYSB0d28gZW5kZWQgb3B0aW1pemF0aW9uLCB3ZSdkIHdhbnQgdG8gb3B0aW1pemUgZm9yIHRoZSBjYXNlXG4gICAgLy8gd2hlcmUgdGhlcmUgYXJlIGZldyBjaGFuZ2VzIGFuZCBicnV0ZSBmb3JjZSB0aGUgY29tcGFyaXNvbiBpbnN0ZWFkIG9mXG4gICAgLy8gZ29pbmcgZm9yIHRoZSBNYXAuIEl0J2QgbGlrZSB0byBleHBsb3JlIGhpdHRpbmcgdGhhdCBwYXRoIGZpcnN0IGluXG4gICAgLy8gZm9yd2FyZC1vbmx5IG1vZGUgYW5kIG9ubHkgZ28gZm9yIHRoZSBNYXAgb25jZSB3ZSBub3RpY2UgdGhhdCB3ZSBuZWVkXG4gICAgLy8gbG90cyBvZiBsb29rIGFoZWFkLiBUaGlzIGRvZXNuJ3QgaGFuZGxlIHJldmVyc2FsIGFzIHdlbGwgYXMgdHdvIGVuZGVkXG4gICAgLy8gc2VhcmNoIGJ1dCB0aGF0J3MgdW51c3VhbC4gQmVzaWRlcywgZm9yIHRoZSB0d28gZW5kZWQgb3B0aW1pemF0aW9uIHRvXG4gICAgLy8gd29yayBvbiBJdGVyYWJsZXMsIHdlJ2QgbmVlZCB0byBjb3B5IHRoZSB3aG9sZSBzZXQuXG4gICAgLy8gSW4gdGhpcyBmaXJzdCBpdGVyYXRpb24sIHdlJ2xsIGp1c3QgbGl2ZSB3aXRoIGhpdHRpbmcgdGhlIGJhZCBjYXNlXG4gICAgLy8gKGFkZGluZyBldmVyeXRoaW5nIHRvIGEgTWFwKSBpbiBmb3IgZXZlcnkgaW5zZXJ0L21vdmUuXG4gICAgLy8gSWYgeW91IGNoYW5nZSB0aGlzIGNvZGUsIGFsc28gdXBkYXRlIHJlY29uY2lsZUNoaWxkcmVuSXRlcmF0b3IoKSB3aGljaFxuICAgIC8vIHVzZXMgdGhlIHNhbWUgYWxnb3JpdGhtLlxuICAgIHtcbiAgICAgIC8vIEZpcnN0LCB2YWxpZGF0ZSBrZXlzLlxuICAgICAgdmFyIGtub3duS2V5cyA9IG51bGw7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmV3Q2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGNoaWxkID0gbmV3Q2hpbGRyZW5baV07XG4gICAgICAgIGtub3duS2V5cyA9IHdhcm5PbkludmFsaWRLZXkoY2hpbGQsIGtub3duS2V5cywgcmV0dXJuRmliZXIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciByZXN1bHRpbmdGaXJzdENoaWxkID0gbnVsbDtcbiAgICB2YXIgcHJldmlvdXNOZXdGaWJlciA9IG51bGw7XG4gICAgdmFyIG9sZEZpYmVyID0gY3VycmVudEZpcnN0Q2hpbGQ7XG4gICAgdmFyIGxhc3RQbGFjZWRJbmRleCA9IDA7XG4gICAgdmFyIG5ld0lkeCA9IDA7XG4gICAgdmFyIG5leHRPbGRGaWJlciA9IG51bGw7XG5cbiAgICBmb3IgKDsgb2xkRmliZXIgIT09IG51bGwgJiYgbmV3SWR4IDwgbmV3Q2hpbGRyZW4ubGVuZ3RoOyBuZXdJZHgrKykge1xuICAgICAgaWYgKG9sZEZpYmVyLmluZGV4ID4gbmV3SWR4KSB7XG4gICAgICAgIG5leHRPbGRGaWJlciA9IG9sZEZpYmVyO1xuICAgICAgICBvbGRGaWJlciA9IG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZXh0T2xkRmliZXIgPSBvbGRGaWJlci5zaWJsaW5nO1xuICAgICAgfVxuXG4gICAgICB2YXIgbmV3RmliZXIgPSB1cGRhdGVTbG90KHJldHVybkZpYmVyLCBvbGRGaWJlciwgbmV3Q2hpbGRyZW5bbmV3SWR4XSwgbGFuZXMpO1xuXG4gICAgICBpZiAobmV3RmliZXIgPT09IG51bGwpIHtcbiAgICAgICAgLy8gVE9ETzogVGhpcyBicmVha3Mgb24gZW1wdHkgc2xvdHMgbGlrZSBudWxsIGNoaWxkcmVuLiBUaGF0J3NcbiAgICAgICAgLy8gdW5mb3J0dW5hdGUgYmVjYXVzZSBpdCB0cmlnZ2VycyB0aGUgc2xvdyBwYXRoIGFsbCB0aGUgdGltZS4gV2UgbmVlZFxuICAgICAgICAvLyBhIGJldHRlciB3YXkgdG8gY29tbXVuaWNhdGUgd2hldGhlciB0aGlzIHdhcyBhIG1pc3Mgb3IgbnVsbCxcbiAgICAgICAgLy8gYm9vbGVhbiwgdW5kZWZpbmVkLCBldGMuXG4gICAgICAgIGlmIChvbGRGaWJlciA9PT0gbnVsbCkge1xuICAgICAgICAgIG9sZEZpYmVyID0gbmV4dE9sZEZpYmVyO1xuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGlmIChzaG91bGRUcmFja1NpZGVFZmZlY3RzKSB7XG4gICAgICAgIGlmIChvbGRGaWJlciAmJiBuZXdGaWJlci5hbHRlcm5hdGUgPT09IG51bGwpIHtcbiAgICAgICAgICAvLyBXZSBtYXRjaGVkIHRoZSBzbG90LCBidXQgd2UgZGlkbid0IHJldXNlIHRoZSBleGlzdGluZyBmaWJlciwgc28gd2VcbiAgICAgICAgICAvLyBuZWVkIHRvIGRlbGV0ZSB0aGUgZXhpc3RpbmcgY2hpbGQuXG4gICAgICAgICAgZGVsZXRlQ2hpbGQocmV0dXJuRmliZXIsIG9sZEZpYmVyKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBsYXN0UGxhY2VkSW5kZXggPSBwbGFjZUNoaWxkKG5ld0ZpYmVyLCBsYXN0UGxhY2VkSW5kZXgsIG5ld0lkeCk7XG5cbiAgICAgIGlmIChwcmV2aW91c05ld0ZpYmVyID09PSBudWxsKSB7XG4gICAgICAgIC8vIFRPRE86IE1vdmUgb3V0IG9mIHRoZSBsb29wLiBUaGlzIG9ubHkgaGFwcGVucyBmb3IgdGhlIGZpcnN0IHJ1bi5cbiAgICAgICAgcmVzdWx0aW5nRmlyc3RDaGlsZCA9IG5ld0ZpYmVyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gVE9ETzogRGVmZXIgc2libGluZ3MgaWYgd2UncmUgbm90IGF0IHRoZSByaWdodCBpbmRleCBmb3IgdGhpcyBzbG90LlxuICAgICAgICAvLyBJLmUuIGlmIHdlIGhhZCBudWxsIHZhbHVlcyBiZWZvcmUsIHRoZW4gd2Ugd2FudCB0byBkZWZlciB0aGlzXG4gICAgICAgIC8vIGZvciBlYWNoIG51bGwgdmFsdWUuIEhvd2V2ZXIsIHdlIGFsc28gZG9uJ3Qgd2FudCB0byBjYWxsIHVwZGF0ZVNsb3RcbiAgICAgICAgLy8gd2l0aCB0aGUgcHJldmlvdXMgb25lLlxuICAgICAgICBwcmV2aW91c05ld0ZpYmVyLnNpYmxpbmcgPSBuZXdGaWJlcjtcbiAgICAgIH1cblxuICAgICAgcHJldmlvdXNOZXdGaWJlciA9IG5ld0ZpYmVyO1xuICAgICAgb2xkRmliZXIgPSBuZXh0T2xkRmliZXI7XG4gICAgfVxuXG4gICAgaWYgKG5ld0lkeCA9PT0gbmV3Q2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAvLyBXZSd2ZSByZWFjaGVkIHRoZSBlbmQgb2YgdGhlIG5ldyBjaGlsZHJlbi4gV2UgY2FuIGRlbGV0ZSB0aGUgcmVzdC5cbiAgICAgIGRlbGV0ZVJlbWFpbmluZ0NoaWxkcmVuKHJldHVybkZpYmVyLCBvbGRGaWJlcik7XG4gICAgICByZXR1cm4gcmVzdWx0aW5nRmlyc3RDaGlsZDtcbiAgICB9XG5cbiAgICBpZiAob2xkRmliZXIgPT09IG51bGwpIHtcbiAgICAgIC8vIElmIHdlIGRvbid0IGhhdmUgYW55IG1vcmUgZXhpc3RpbmcgY2hpbGRyZW4gd2UgY2FuIGNob29zZSBhIGZhc3QgcGF0aFxuICAgICAgLy8gc2luY2UgdGhlIHJlc3Qgd2lsbCBhbGwgYmUgaW5zZXJ0aW9ucy5cbiAgICAgIGZvciAoOyBuZXdJZHggPCBuZXdDaGlsZHJlbi5sZW5ndGg7IG5ld0lkeCsrKSB7XG4gICAgICAgIHZhciBfbmV3RmliZXIgPSBjcmVhdGVDaGlsZChyZXR1cm5GaWJlciwgbmV3Q2hpbGRyZW5bbmV3SWR4XSwgbGFuZXMpO1xuXG4gICAgICAgIGlmIChfbmV3RmliZXIgPT09IG51bGwpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxhc3RQbGFjZWRJbmRleCA9IHBsYWNlQ2hpbGQoX25ld0ZpYmVyLCBsYXN0UGxhY2VkSW5kZXgsIG5ld0lkeCk7XG5cbiAgICAgICAgaWYgKHByZXZpb3VzTmV3RmliZXIgPT09IG51bGwpIHtcbiAgICAgICAgICAvLyBUT0RPOiBNb3ZlIG91dCBvZiB0aGUgbG9vcC4gVGhpcyBvbmx5IGhhcHBlbnMgZm9yIHRoZSBmaXJzdCBydW4uXG4gICAgICAgICAgcmVzdWx0aW5nRmlyc3RDaGlsZCA9IF9uZXdGaWJlcjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwcmV2aW91c05ld0ZpYmVyLnNpYmxpbmcgPSBfbmV3RmliZXI7XG4gICAgICAgIH1cblxuICAgICAgICBwcmV2aW91c05ld0ZpYmVyID0gX25ld0ZpYmVyO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0aW5nRmlyc3RDaGlsZDtcbiAgICB9IC8vIEFkZCBhbGwgY2hpbGRyZW4gdG8gYSBrZXkgbWFwIGZvciBxdWljayBsb29rdXBzLlxuXG5cbiAgICB2YXIgZXhpc3RpbmdDaGlsZHJlbiA9IG1hcFJlbWFpbmluZ0NoaWxkcmVuKHJldHVybkZpYmVyLCBvbGRGaWJlcik7IC8vIEtlZXAgc2Nhbm5pbmcgYW5kIHVzZSB0aGUgbWFwIHRvIHJlc3RvcmUgZGVsZXRlZCBpdGVtcyBhcyBtb3Zlcy5cblxuICAgIGZvciAoOyBuZXdJZHggPCBuZXdDaGlsZHJlbi5sZW5ndGg7IG5ld0lkeCsrKSB7XG4gICAgICB2YXIgX25ld0ZpYmVyMiA9IHVwZGF0ZUZyb21NYXAoZXhpc3RpbmdDaGlsZHJlbiwgcmV0dXJuRmliZXIsIG5ld0lkeCwgbmV3Q2hpbGRyZW5bbmV3SWR4XSwgbGFuZXMpO1xuXG4gICAgICBpZiAoX25ld0ZpYmVyMiAhPT0gbnVsbCkge1xuICAgICAgICBpZiAoc2hvdWxkVHJhY2tTaWRlRWZmZWN0cykge1xuICAgICAgICAgIGlmIChfbmV3RmliZXIyLmFsdGVybmF0ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gVGhlIG5ldyBmaWJlciBpcyBhIHdvcmsgaW4gcHJvZ3Jlc3MsIGJ1dCBpZiB0aGVyZSBleGlzdHMgYVxuICAgICAgICAgICAgLy8gY3VycmVudCwgdGhhdCBtZWFucyB0aGF0IHdlIHJldXNlZCB0aGUgZmliZXIuIFdlIG5lZWQgdG8gZGVsZXRlXG4gICAgICAgICAgICAvLyBpdCBmcm9tIHRoZSBjaGlsZCBsaXN0IHNvIHRoYXQgd2UgZG9uJ3QgYWRkIGl0IHRvIHRoZSBkZWxldGlvblxuICAgICAgICAgICAgLy8gbGlzdC5cbiAgICAgICAgICAgIGV4aXN0aW5nQ2hpbGRyZW4uZGVsZXRlKF9uZXdGaWJlcjIua2V5ID09PSBudWxsID8gbmV3SWR4IDogX25ld0ZpYmVyMi5rZXkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGxhc3RQbGFjZWRJbmRleCA9IHBsYWNlQ2hpbGQoX25ld0ZpYmVyMiwgbGFzdFBsYWNlZEluZGV4LCBuZXdJZHgpO1xuXG4gICAgICAgIGlmIChwcmV2aW91c05ld0ZpYmVyID09PSBudWxsKSB7XG4gICAgICAgICAgcmVzdWx0aW5nRmlyc3RDaGlsZCA9IF9uZXdGaWJlcjI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcHJldmlvdXNOZXdGaWJlci5zaWJsaW5nID0gX25ld0ZpYmVyMjtcbiAgICAgICAgfVxuXG4gICAgICAgIHByZXZpb3VzTmV3RmliZXIgPSBfbmV3RmliZXIyO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzaG91bGRUcmFja1NpZGVFZmZlY3RzKSB7XG4gICAgICAvLyBBbnkgZXhpc3RpbmcgY2hpbGRyZW4gdGhhdCB3ZXJlbid0IGNvbnN1bWVkIGFib3ZlIHdlcmUgZGVsZXRlZC4gV2UgbmVlZFxuICAgICAgLy8gdG8gYWRkIHRoZW0gdG8gdGhlIGRlbGV0aW9uIGxpc3QuXG4gICAgICBleGlzdGluZ0NoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgIHJldHVybiBkZWxldGVDaGlsZChyZXR1cm5GaWJlciwgY2hpbGQpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdGluZ0ZpcnN0Q2hpbGQ7XG4gIH1cblxuICBmdW5jdGlvbiByZWNvbmNpbGVDaGlsZHJlbkl0ZXJhdG9yKHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCwgbmV3Q2hpbGRyZW5JdGVyYWJsZSwgbGFuZXMpIHtcbiAgICAvLyBUaGlzIGlzIHRoZSBzYW1lIGltcGxlbWVudGF0aW9uIGFzIHJlY29uY2lsZUNoaWxkcmVuQXJyYXkoKSxcbiAgICAvLyBidXQgdXNpbmcgdGhlIGl0ZXJhdG9yIGluc3RlYWQuXG4gICAgdmFyIGl0ZXJhdG9yRm4gPSBnZXRJdGVyYXRvckZuKG5ld0NoaWxkcmVuSXRlcmFibGUpO1xuXG4gICAgaWYgKCEodHlwZW9mIGl0ZXJhdG9yRm4gPT09ICdmdW5jdGlvbicpKSB7XG4gICAgICB7XG4gICAgICAgIHRocm93IEVycm9yKCBcIkFuIG9iamVjdCBpcyBub3QgYW4gaXRlcmFibGUuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCIgKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB7XG4gICAgICAvLyBXZSBkb24ndCBzdXBwb3J0IHJlbmRlcmluZyBHZW5lcmF0b3JzIGJlY2F1c2UgaXQncyBhIG11dGF0aW9uLlxuICAgICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTI5OTVcbiAgICAgIGlmICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIC8vICRGbG93Rml4TWUgRmxvdyBkb2Vzbid0IGtub3cgYWJvdXQgdG9TdHJpbmdUYWdcbiAgICAgIG5ld0NoaWxkcmVuSXRlcmFibGVbU3ltYm9sLnRvU3RyaW5nVGFnXSA9PT0gJ0dlbmVyYXRvcicpIHtcbiAgICAgICAgaWYgKCFkaWRXYXJuQWJvdXRHZW5lcmF0b3JzKSB7XG4gICAgICAgICAgZXJyb3IoJ1VzaW5nIEdlbmVyYXRvcnMgYXMgY2hpbGRyZW4gaXMgdW5zdXBwb3J0ZWQgYW5kIHdpbGwgbGlrZWx5IHlpZWxkICcgKyAndW5leHBlY3RlZCByZXN1bHRzIGJlY2F1c2UgZW51bWVyYXRpbmcgYSBnZW5lcmF0b3IgbXV0YXRlcyBpdC4gJyArICdZb3UgbWF5IGNvbnZlcnQgaXQgdG8gYW4gYXJyYXkgd2l0aCBgQXJyYXkuZnJvbSgpYCBvciB0aGUgJyArICdgWy4uLnNwcmVhZF1gIG9wZXJhdG9yIGJlZm9yZSByZW5kZXJpbmcuIEtlZXAgaW4gbWluZCAnICsgJ3lvdSBtaWdodCBuZWVkIHRvIHBvbHlmaWxsIHRoZXNlIGZlYXR1cmVzIGZvciBvbGRlciBicm93c2Vycy4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGRpZFdhcm5BYm91dEdlbmVyYXRvcnMgPSB0cnVlO1xuICAgICAgfSAvLyBXYXJuIGFib3V0IHVzaW5nIE1hcHMgYXMgY2hpbGRyZW5cblxuXG4gICAgICBpZiAobmV3Q2hpbGRyZW5JdGVyYWJsZS5lbnRyaWVzID09PSBpdGVyYXRvckZuKSB7XG4gICAgICAgIGlmICghZGlkV2FybkFib3V0TWFwcykge1xuICAgICAgICAgIGVycm9yKCdVc2luZyBNYXBzIGFzIGNoaWxkcmVuIGlzIG5vdCBzdXBwb3J0ZWQuICcgKyAnVXNlIGFuIGFycmF5IG9mIGtleWVkIFJlYWN0RWxlbWVudHMgaW5zdGVhZC4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGRpZFdhcm5BYm91dE1hcHMgPSB0cnVlO1xuICAgICAgfSAvLyBGaXJzdCwgdmFsaWRhdGUga2V5cy5cbiAgICAgIC8vIFdlJ2xsIGdldCBhIGRpZmZlcmVudCBpdGVyYXRvciBsYXRlciBmb3IgdGhlIG1haW4gcGFzcy5cblxuXG4gICAgICB2YXIgX25ld0NoaWxkcmVuID0gaXRlcmF0b3JGbi5jYWxsKG5ld0NoaWxkcmVuSXRlcmFibGUpO1xuXG4gICAgICBpZiAoX25ld0NoaWxkcmVuKSB7XG4gICAgICAgIHZhciBrbm93bktleXMgPSBudWxsO1xuXG4gICAgICAgIHZhciBfc3RlcCA9IF9uZXdDaGlsZHJlbi5uZXh0KCk7XG5cbiAgICAgICAgZm9yICg7ICFfc3RlcC5kb25lOyBfc3RlcCA9IF9uZXdDaGlsZHJlbi5uZXh0KCkpIHtcbiAgICAgICAgICB2YXIgY2hpbGQgPSBfc3RlcC52YWx1ZTtcbiAgICAgICAgICBrbm93bktleXMgPSB3YXJuT25JbnZhbGlkS2V5KGNoaWxkLCBrbm93bktleXMsIHJldHVybkZpYmVyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBuZXdDaGlsZHJlbiA9IGl0ZXJhdG9yRm4uY2FsbChuZXdDaGlsZHJlbkl0ZXJhYmxlKTtcblxuICAgIGlmICghKG5ld0NoaWxkcmVuICE9IG51bGwpKSB7XG4gICAgICB7XG4gICAgICAgIHRocm93IEVycm9yKCBcIkFuIGl0ZXJhYmxlIG9iamVjdCBwcm92aWRlZCBubyBpdGVyYXRvci5cIiApO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciByZXN1bHRpbmdGaXJzdENoaWxkID0gbnVsbDtcbiAgICB2YXIgcHJldmlvdXNOZXdGaWJlciA9IG51bGw7XG4gICAgdmFyIG9sZEZpYmVyID0gY3VycmVudEZpcnN0Q2hpbGQ7XG4gICAgdmFyIGxhc3RQbGFjZWRJbmRleCA9IDA7XG4gICAgdmFyIG5ld0lkeCA9IDA7XG4gICAgdmFyIG5leHRPbGRGaWJlciA9IG51bGw7XG4gICAgdmFyIHN0ZXAgPSBuZXdDaGlsZHJlbi5uZXh0KCk7XG5cbiAgICBmb3IgKDsgb2xkRmliZXIgIT09IG51bGwgJiYgIXN0ZXAuZG9uZTsgbmV3SWR4KyssIHN0ZXAgPSBuZXdDaGlsZHJlbi5uZXh0KCkpIHtcbiAgICAgIGlmIChvbGRGaWJlci5pbmRleCA+IG5ld0lkeCkge1xuICAgICAgICBuZXh0T2xkRmliZXIgPSBvbGRGaWJlcjtcbiAgICAgICAgb2xkRmliZXIgPSBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmV4dE9sZEZpYmVyID0gb2xkRmliZXIuc2libGluZztcbiAgICAgIH1cblxuICAgICAgdmFyIG5ld0ZpYmVyID0gdXBkYXRlU2xvdChyZXR1cm5GaWJlciwgb2xkRmliZXIsIHN0ZXAudmFsdWUsIGxhbmVzKTtcblxuICAgICAgaWYgKG5ld0ZpYmVyID09PSBudWxsKSB7XG4gICAgICAgIC8vIFRPRE86IFRoaXMgYnJlYWtzIG9uIGVtcHR5IHNsb3RzIGxpa2UgbnVsbCBjaGlsZHJlbi4gVGhhdCdzXG4gICAgICAgIC8vIHVuZm9ydHVuYXRlIGJlY2F1c2UgaXQgdHJpZ2dlcnMgdGhlIHNsb3cgcGF0aCBhbGwgdGhlIHRpbWUuIFdlIG5lZWRcbiAgICAgICAgLy8gYSBiZXR0ZXIgd2F5IHRvIGNvbW11bmljYXRlIHdoZXRoZXIgdGhpcyB3YXMgYSBtaXNzIG9yIG51bGwsXG4gICAgICAgIC8vIGJvb2xlYW4sIHVuZGVmaW5lZCwgZXRjLlxuICAgICAgICBpZiAob2xkRmliZXIgPT09IG51bGwpIHtcbiAgICAgICAgICBvbGRGaWJlciA9IG5leHRPbGRGaWJlcjtcbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBpZiAoc2hvdWxkVHJhY2tTaWRlRWZmZWN0cykge1xuICAgICAgICBpZiAob2xkRmliZXIgJiYgbmV3RmliZXIuYWx0ZXJuYXRlID09PSBudWxsKSB7XG4gICAgICAgICAgLy8gV2UgbWF0Y2hlZCB0aGUgc2xvdCwgYnV0IHdlIGRpZG4ndCByZXVzZSB0aGUgZXhpc3RpbmcgZmliZXIsIHNvIHdlXG4gICAgICAgICAgLy8gbmVlZCB0byBkZWxldGUgdGhlIGV4aXN0aW5nIGNoaWxkLlxuICAgICAgICAgIGRlbGV0ZUNoaWxkKHJldHVybkZpYmVyLCBvbGRGaWJlcik7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgbGFzdFBsYWNlZEluZGV4ID0gcGxhY2VDaGlsZChuZXdGaWJlciwgbGFzdFBsYWNlZEluZGV4LCBuZXdJZHgpO1xuXG4gICAgICBpZiAocHJldmlvdXNOZXdGaWJlciA9PT0gbnVsbCkge1xuICAgICAgICAvLyBUT0RPOiBNb3ZlIG91dCBvZiB0aGUgbG9vcC4gVGhpcyBvbmx5IGhhcHBlbnMgZm9yIHRoZSBmaXJzdCBydW4uXG4gICAgICAgIHJlc3VsdGluZ0ZpcnN0Q2hpbGQgPSBuZXdGaWJlcjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFRPRE86IERlZmVyIHNpYmxpbmdzIGlmIHdlJ3JlIG5vdCBhdCB0aGUgcmlnaHQgaW5kZXggZm9yIHRoaXMgc2xvdC5cbiAgICAgICAgLy8gSS5lLiBpZiB3ZSBoYWQgbnVsbCB2YWx1ZXMgYmVmb3JlLCB0aGVuIHdlIHdhbnQgdG8gZGVmZXIgdGhpc1xuICAgICAgICAvLyBmb3IgZWFjaCBudWxsIHZhbHVlLiBIb3dldmVyLCB3ZSBhbHNvIGRvbid0IHdhbnQgdG8gY2FsbCB1cGRhdGVTbG90XG4gICAgICAgIC8vIHdpdGggdGhlIHByZXZpb3VzIG9uZS5cbiAgICAgICAgcHJldmlvdXNOZXdGaWJlci5zaWJsaW5nID0gbmV3RmliZXI7XG4gICAgICB9XG5cbiAgICAgIHByZXZpb3VzTmV3RmliZXIgPSBuZXdGaWJlcjtcbiAgICAgIG9sZEZpYmVyID0gbmV4dE9sZEZpYmVyO1xuICAgIH1cblxuICAgIGlmIChzdGVwLmRvbmUpIHtcbiAgICAgIC8vIFdlJ3ZlIHJlYWNoZWQgdGhlIGVuZCBvZiB0aGUgbmV3IGNoaWxkcmVuLiBXZSBjYW4gZGVsZXRlIHRoZSByZXN0LlxuICAgICAgZGVsZXRlUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsIG9sZEZpYmVyKTtcbiAgICAgIHJldHVybiByZXN1bHRpbmdGaXJzdENoaWxkO1xuICAgIH1cblxuICAgIGlmIChvbGRGaWJlciA9PT0gbnVsbCkge1xuICAgICAgLy8gSWYgd2UgZG9uJ3QgaGF2ZSBhbnkgbW9yZSBleGlzdGluZyBjaGlsZHJlbiB3ZSBjYW4gY2hvb3NlIGEgZmFzdCBwYXRoXG4gICAgICAvLyBzaW5jZSB0aGUgcmVzdCB3aWxsIGFsbCBiZSBpbnNlcnRpb25zLlxuICAgICAgZm9yICg7ICFzdGVwLmRvbmU7IG5ld0lkeCsrLCBzdGVwID0gbmV3Q2hpbGRyZW4ubmV4dCgpKSB7XG4gICAgICAgIHZhciBfbmV3RmliZXIzID0gY3JlYXRlQ2hpbGQocmV0dXJuRmliZXIsIHN0ZXAudmFsdWUsIGxhbmVzKTtcblxuICAgICAgICBpZiAoX25ld0ZpYmVyMyA9PT0gbnVsbCkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgbGFzdFBsYWNlZEluZGV4ID0gcGxhY2VDaGlsZChfbmV3RmliZXIzLCBsYXN0UGxhY2VkSW5kZXgsIG5ld0lkeCk7XG5cbiAgICAgICAgaWYgKHByZXZpb3VzTmV3RmliZXIgPT09IG51bGwpIHtcbiAgICAgICAgICAvLyBUT0RPOiBNb3ZlIG91dCBvZiB0aGUgbG9vcC4gVGhpcyBvbmx5IGhhcHBlbnMgZm9yIHRoZSBmaXJzdCBydW4uXG4gICAgICAgICAgcmVzdWx0aW5nRmlyc3RDaGlsZCA9IF9uZXdGaWJlcjM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcHJldmlvdXNOZXdGaWJlci5zaWJsaW5nID0gX25ld0ZpYmVyMztcbiAgICAgICAgfVxuXG4gICAgICAgIHByZXZpb3VzTmV3RmliZXIgPSBfbmV3RmliZXIzO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0aW5nRmlyc3RDaGlsZDtcbiAgICB9IC8vIEFkZCBhbGwgY2hpbGRyZW4gdG8gYSBrZXkgbWFwIGZvciBxdWljayBsb29rdXBzLlxuXG5cbiAgICB2YXIgZXhpc3RpbmdDaGlsZHJlbiA9IG1hcFJlbWFpbmluZ0NoaWxkcmVuKHJldHVybkZpYmVyLCBvbGRGaWJlcik7IC8vIEtlZXAgc2Nhbm5pbmcgYW5kIHVzZSB0aGUgbWFwIHRvIHJlc3RvcmUgZGVsZXRlZCBpdGVtcyBhcyBtb3Zlcy5cblxuICAgIGZvciAoOyAhc3RlcC5kb25lOyBuZXdJZHgrKywgc3RlcCA9IG5ld0NoaWxkcmVuLm5leHQoKSkge1xuICAgICAgdmFyIF9uZXdGaWJlcjQgPSB1cGRhdGVGcm9tTWFwKGV4aXN0aW5nQ2hpbGRyZW4sIHJldHVybkZpYmVyLCBuZXdJZHgsIHN0ZXAudmFsdWUsIGxhbmVzKTtcblxuICAgICAgaWYgKF9uZXdGaWJlcjQgIT09IG51bGwpIHtcbiAgICAgICAgaWYgKHNob3VsZFRyYWNrU2lkZUVmZmVjdHMpIHtcbiAgICAgICAgICBpZiAoX25ld0ZpYmVyNC5hbHRlcm5hdGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIFRoZSBuZXcgZmliZXIgaXMgYSB3b3JrIGluIHByb2dyZXNzLCBidXQgaWYgdGhlcmUgZXhpc3RzIGFcbiAgICAgICAgICAgIC8vIGN1cnJlbnQsIHRoYXQgbWVhbnMgdGhhdCB3ZSByZXVzZWQgdGhlIGZpYmVyLiBXZSBuZWVkIHRvIGRlbGV0ZVxuICAgICAgICAgICAgLy8gaXQgZnJvbSB0aGUgY2hpbGQgbGlzdCBzbyB0aGF0IHdlIGRvbid0IGFkZCBpdCB0byB0aGUgZGVsZXRpb25cbiAgICAgICAgICAgIC8vIGxpc3QuXG4gICAgICAgICAgICBleGlzdGluZ0NoaWxkcmVuLmRlbGV0ZShfbmV3RmliZXI0LmtleSA9PT0gbnVsbCA/IG5ld0lkeCA6IF9uZXdGaWJlcjQua2V5KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBsYXN0UGxhY2VkSW5kZXggPSBwbGFjZUNoaWxkKF9uZXdGaWJlcjQsIGxhc3RQbGFjZWRJbmRleCwgbmV3SWR4KTtcblxuICAgICAgICBpZiAocHJldmlvdXNOZXdGaWJlciA9PT0gbnVsbCkge1xuICAgICAgICAgIHJlc3VsdGluZ0ZpcnN0Q2hpbGQgPSBfbmV3RmliZXI0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHByZXZpb3VzTmV3RmliZXIuc2libGluZyA9IF9uZXdGaWJlcjQ7XG4gICAgICAgIH1cblxuICAgICAgICBwcmV2aW91c05ld0ZpYmVyID0gX25ld0ZpYmVyNDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoc2hvdWxkVHJhY2tTaWRlRWZmZWN0cykge1xuICAgICAgLy8gQW55IGV4aXN0aW5nIGNoaWxkcmVuIHRoYXQgd2VyZW4ndCBjb25zdW1lZCBhYm92ZSB3ZXJlIGRlbGV0ZWQuIFdlIG5lZWRcbiAgICAgIC8vIHRvIGFkZCB0aGVtIHRvIHRoZSBkZWxldGlvbiBsaXN0LlxuICAgICAgZXhpc3RpbmdDaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICByZXR1cm4gZGVsZXRlQ2hpbGQocmV0dXJuRmliZXIsIGNoaWxkKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHRpbmdGaXJzdENoaWxkO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVjb25jaWxlU2luZ2xlVGV4dE5vZGUocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkLCB0ZXh0Q29udGVudCwgbGFuZXMpIHtcbiAgICAvLyBUaGVyZSdzIG5vIG5lZWQgdG8gY2hlY2sgZm9yIGtleXMgb24gdGV4dCBub2RlcyBzaW5jZSB3ZSBkb24ndCBoYXZlIGFcbiAgICAvLyB3YXkgdG8gZGVmaW5lIHRoZW0uXG4gICAgaWYgKGN1cnJlbnRGaXJzdENoaWxkICE9PSBudWxsICYmIGN1cnJlbnRGaXJzdENoaWxkLnRhZyA9PT0gSG9zdFRleHQpIHtcbiAgICAgIC8vIFdlIGFscmVhZHkgaGF2ZSBhbiBleGlzdGluZyBub2RlIHNvIGxldCdzIGp1c3QgdXBkYXRlIGl0IGFuZCBkZWxldGVcbiAgICAgIC8vIHRoZSByZXN0LlxuICAgICAgZGVsZXRlUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkLnNpYmxpbmcpO1xuICAgICAgdmFyIGV4aXN0aW5nID0gdXNlRmliZXIoY3VycmVudEZpcnN0Q2hpbGQsIHRleHRDb250ZW50KTtcbiAgICAgIGV4aXN0aW5nLnJldHVybiA9IHJldHVybkZpYmVyO1xuICAgICAgcmV0dXJuIGV4aXN0aW5nO1xuICAgIH0gLy8gVGhlIGV4aXN0aW5nIGZpcnN0IGNoaWxkIGlzIG5vdCBhIHRleHQgbm9kZSBzbyB3ZSBuZWVkIHRvIGNyZWF0ZSBvbmVcbiAgICAvLyBhbmQgZGVsZXRlIHRoZSBleGlzdGluZyBvbmVzLlxuXG5cbiAgICBkZWxldGVSZW1haW5pbmdDaGlsZHJlbihyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQpO1xuICAgIHZhciBjcmVhdGVkID0gY3JlYXRlRmliZXJGcm9tVGV4dCh0ZXh0Q29udGVudCwgcmV0dXJuRmliZXIubW9kZSwgbGFuZXMpO1xuICAgIGNyZWF0ZWQucmV0dXJuID0gcmV0dXJuRmliZXI7XG4gICAgcmV0dXJuIGNyZWF0ZWQ7XG4gIH1cblxuICBmdW5jdGlvbiByZWNvbmNpbGVTaW5nbGVFbGVtZW50KHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCwgZWxlbWVudCwgbGFuZXMpIHtcbiAgICB2YXIga2V5ID0gZWxlbWVudC5rZXk7XG4gICAgdmFyIGNoaWxkID0gY3VycmVudEZpcnN0Q2hpbGQ7XG5cbiAgICB3aGlsZSAoY2hpbGQgIT09IG51bGwpIHtcbiAgICAgIC8vIFRPRE86IElmIGtleSA9PT0gbnVsbCBhbmQgY2hpbGQua2V5ID09PSBudWxsLCB0aGVuIHRoaXMgb25seSBhcHBsaWVzIHRvXG4gICAgICAvLyB0aGUgZmlyc3QgaXRlbSBpbiB0aGUgbGlzdC5cbiAgICAgIGlmIChjaGlsZC5rZXkgPT09IGtleSkge1xuICAgICAgICBzd2l0Y2ggKGNoaWxkLnRhZykge1xuICAgICAgICAgIGNhc2UgRnJhZ21lbnQ6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGlmIChlbGVtZW50LnR5cGUgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEUpIHtcbiAgICAgICAgICAgICAgICBkZWxldGVSZW1haW5pbmdDaGlsZHJlbihyZXR1cm5GaWJlciwgY2hpbGQuc2libGluZyk7XG4gICAgICAgICAgICAgICAgdmFyIGV4aXN0aW5nID0gdXNlRmliZXIoY2hpbGQsIGVsZW1lbnQucHJvcHMuY2hpbGRyZW4pO1xuICAgICAgICAgICAgICAgIGV4aXN0aW5nLnJldHVybiA9IHJldHVybkZpYmVyO1xuXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgZXhpc3RpbmcuX2RlYnVnU291cmNlID0gZWxlbWVudC5fc291cmNlO1xuICAgICAgICAgICAgICAgICAgZXhpc3RpbmcuX2RlYnVnT3duZXIgPSBlbGVtZW50Ll9vd25lcjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gZXhpc3Rpbmc7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIGNhc2UgQmxvY2s6XG5cbiAgICAgICAgICAvLyBXZSBpbnRlbnRpb25hbGx5IGZhbGx0aHJvdWdoIGhlcmUgaWYgZW5hYmxlQmxvY2tzQVBJIGlzIG5vdCBvbi5cbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVkIG5vLWZhbGx0aHJvdWdoXG5cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBpZiAoY2hpbGQuZWxlbWVudFR5cGUgPT09IGVsZW1lbnQudHlwZSB8fCAoIC8vIEtlZXAgdGhpcyBjaGVjayBpbmxpbmUgc28gaXQgb25seSBydW5zIG9uIHRoZSBmYWxzZSBwYXRoOlxuICAgICAgICAgICAgICAgaXNDb21wYXRpYmxlRmFtaWx5Rm9ySG90UmVsb2FkaW5nKGNoaWxkLCBlbGVtZW50KSApKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsIGNoaWxkLnNpYmxpbmcpO1xuXG4gICAgICAgICAgICAgICAgdmFyIF9leGlzdGluZzMgPSB1c2VGaWJlcihjaGlsZCwgZWxlbWVudC5wcm9wcyk7XG5cbiAgICAgICAgICAgICAgICBfZXhpc3RpbmczLnJlZiA9IGNvZXJjZVJlZihyZXR1cm5GaWJlciwgY2hpbGQsIGVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIF9leGlzdGluZzMucmV0dXJuID0gcmV0dXJuRmliZXI7XG5cbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICBfZXhpc3RpbmczLl9kZWJ1Z1NvdXJjZSA9IGVsZW1lbnQuX3NvdXJjZTtcbiAgICAgICAgICAgICAgICAgIF9leGlzdGluZzMuX2RlYnVnT3duZXIgPSBlbGVtZW50Ll9vd25lcjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gX2V4aXN0aW5nMztcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IC8vIERpZG4ndCBtYXRjaC5cblxuXG4gICAgICAgIGRlbGV0ZVJlbWFpbmluZ0NoaWxkcmVuKHJldHVybkZpYmVyLCBjaGlsZCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVsZXRlQ2hpbGQocmV0dXJuRmliZXIsIGNoaWxkKTtcbiAgICAgIH1cblxuICAgICAgY2hpbGQgPSBjaGlsZC5zaWJsaW5nO1xuICAgIH1cblxuICAgIGlmIChlbGVtZW50LnR5cGUgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEUpIHtcbiAgICAgIHZhciBjcmVhdGVkID0gY3JlYXRlRmliZXJGcm9tRnJhZ21lbnQoZWxlbWVudC5wcm9wcy5jaGlsZHJlbiwgcmV0dXJuRmliZXIubW9kZSwgbGFuZXMsIGVsZW1lbnQua2V5KTtcbiAgICAgIGNyZWF0ZWQucmV0dXJuID0gcmV0dXJuRmliZXI7XG4gICAgICByZXR1cm4gY3JlYXRlZDtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIF9jcmVhdGVkNCA9IGNyZWF0ZUZpYmVyRnJvbUVsZW1lbnQoZWxlbWVudCwgcmV0dXJuRmliZXIubW9kZSwgbGFuZXMpO1xuXG4gICAgICBfY3JlYXRlZDQucmVmID0gY29lcmNlUmVmKHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCwgZWxlbWVudCk7XG4gICAgICBfY3JlYXRlZDQucmV0dXJuID0gcmV0dXJuRmliZXI7XG4gICAgICByZXR1cm4gX2NyZWF0ZWQ0O1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlY29uY2lsZVNpbmdsZVBvcnRhbChyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQsIHBvcnRhbCwgbGFuZXMpIHtcbiAgICB2YXIga2V5ID0gcG9ydGFsLmtleTtcbiAgICB2YXIgY2hpbGQgPSBjdXJyZW50Rmlyc3RDaGlsZDtcblxuICAgIHdoaWxlIChjaGlsZCAhPT0gbnVsbCkge1xuICAgICAgLy8gVE9ETzogSWYga2V5ID09PSBudWxsIGFuZCBjaGlsZC5rZXkgPT09IG51bGwsIHRoZW4gdGhpcyBvbmx5IGFwcGxpZXMgdG9cbiAgICAgIC8vIHRoZSBmaXJzdCBpdGVtIGluIHRoZSBsaXN0LlxuICAgICAgaWYgKGNoaWxkLmtleSA9PT0ga2V5KSB7XG4gICAgICAgIGlmIChjaGlsZC50YWcgPT09IEhvc3RQb3J0YWwgJiYgY2hpbGQuc3RhdGVOb2RlLmNvbnRhaW5lckluZm8gPT09IHBvcnRhbC5jb250YWluZXJJbmZvICYmIGNoaWxkLnN0YXRlTm9kZS5pbXBsZW1lbnRhdGlvbiA9PT0gcG9ydGFsLmltcGxlbWVudGF0aW9uKSB7XG4gICAgICAgICAgZGVsZXRlUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsIGNoaWxkLnNpYmxpbmcpO1xuICAgICAgICAgIHZhciBleGlzdGluZyA9IHVzZUZpYmVyKGNoaWxkLCBwb3J0YWwuY2hpbGRyZW4gfHwgW10pO1xuICAgICAgICAgIGV4aXN0aW5nLnJldHVybiA9IHJldHVybkZpYmVyO1xuICAgICAgICAgIHJldHVybiBleGlzdGluZztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkZWxldGVSZW1haW5pbmdDaGlsZHJlbihyZXR1cm5GaWJlciwgY2hpbGQpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWxldGVDaGlsZChyZXR1cm5GaWJlciwgY2hpbGQpO1xuICAgICAgfVxuXG4gICAgICBjaGlsZCA9IGNoaWxkLnNpYmxpbmc7XG4gICAgfVxuXG4gICAgdmFyIGNyZWF0ZWQgPSBjcmVhdGVGaWJlckZyb21Qb3J0YWwocG9ydGFsLCByZXR1cm5GaWJlci5tb2RlLCBsYW5lcyk7XG4gICAgY3JlYXRlZC5yZXR1cm4gPSByZXR1cm5GaWJlcjtcbiAgICByZXR1cm4gY3JlYXRlZDtcbiAgfSAvLyBUaGlzIEFQSSB3aWxsIHRhZyB0aGUgY2hpbGRyZW4gd2l0aCB0aGUgc2lkZS1lZmZlY3Qgb2YgdGhlIHJlY29uY2lsaWF0aW9uXG4gIC8vIGl0c2VsZi4gVGhleSB3aWxsIGJlIGFkZGVkIHRvIHRoZSBzaWRlLWVmZmVjdCBsaXN0IGFzIHdlIHBhc3MgdGhyb3VnaCB0aGVcbiAgLy8gY2hpbGRyZW4gYW5kIHRoZSBwYXJlbnQuXG5cblxuICBmdW5jdGlvbiByZWNvbmNpbGVDaGlsZEZpYmVycyhyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQsIG5ld0NoaWxkLCBsYW5lcykge1xuICAgIC8vIFRoaXMgZnVuY3Rpb24gaXMgbm90IHJlY3Vyc2l2ZS5cbiAgICAvLyBJZiB0aGUgdG9wIGxldmVsIGl0ZW0gaXMgYW4gYXJyYXksIHdlIHRyZWF0IGl0IGFzIGEgc2V0IG9mIGNoaWxkcmVuLFxuICAgIC8vIG5vdCBhcyBhIGZyYWdtZW50LiBOZXN0ZWQgYXJyYXlzIG9uIHRoZSBvdGhlciBoYW5kIHdpbGwgYmUgdHJlYXRlZCBhc1xuICAgIC8vIGZyYWdtZW50IG5vZGVzLiBSZWN1cnNpb24gaGFwcGVucyBhdCB0aGUgbm9ybWFsIGZsb3cuXG4gICAgLy8gSGFuZGxlIHRvcCBsZXZlbCB1bmtleWVkIGZyYWdtZW50cyBhcyBpZiB0aGV5IHdlcmUgYXJyYXlzLlxuICAgIC8vIFRoaXMgbGVhZHMgdG8gYW4gYW1iaWd1aXR5IGJldHdlZW4gPD57Wy4uLl19PC8+IGFuZCA8Pi4uLjwvPi5cbiAgICAvLyBXZSB0cmVhdCB0aGUgYW1iaWd1b3VzIGNhc2VzIGFib3ZlIHRoZSBzYW1lLlxuICAgIHZhciBpc1Vua2V5ZWRUb3BMZXZlbEZyYWdtZW50ID0gdHlwZW9mIG5ld0NoaWxkID09PSAnb2JqZWN0JyAmJiBuZXdDaGlsZCAhPT0gbnVsbCAmJiBuZXdDaGlsZC50eXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFICYmIG5ld0NoaWxkLmtleSA9PT0gbnVsbDtcblxuICAgIGlmIChpc1Vua2V5ZWRUb3BMZXZlbEZyYWdtZW50KSB7XG4gICAgICBuZXdDaGlsZCA9IG5ld0NoaWxkLnByb3BzLmNoaWxkcmVuO1xuICAgIH0gLy8gSGFuZGxlIG9iamVjdCB0eXBlc1xuXG5cbiAgICB2YXIgaXNPYmplY3QgPSB0eXBlb2YgbmV3Q2hpbGQgPT09ICdvYmplY3QnICYmIG5ld0NoaWxkICE9PSBudWxsO1xuXG4gICAgaWYgKGlzT2JqZWN0KSB7XG4gICAgICBzd2l0Y2ggKG5ld0NoaWxkLiQkdHlwZW9mKSB7XG4gICAgICAgIGNhc2UgUkVBQ1RfRUxFTUVOVF9UWVBFOlxuICAgICAgICAgIHJldHVybiBwbGFjZVNpbmdsZUNoaWxkKHJlY29uY2lsZVNpbmdsZUVsZW1lbnQocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkLCBuZXdDaGlsZCwgbGFuZXMpKTtcblxuICAgICAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgICAgIHJldHVybiBwbGFjZVNpbmdsZUNoaWxkKHJlY29uY2lsZVNpbmdsZVBvcnRhbChyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQsIG5ld0NoaWxkLCBsYW5lcykpO1xuXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBuZXdDaGlsZCA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIG5ld0NoaWxkID09PSAnbnVtYmVyJykge1xuICAgICAgcmV0dXJuIHBsYWNlU2luZ2xlQ2hpbGQocmVjb25jaWxlU2luZ2xlVGV4dE5vZGUocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkLCAnJyArIG5ld0NoaWxkLCBsYW5lcykpO1xuICAgIH1cblxuICAgIGlmIChpc0FycmF5JDEobmV3Q2hpbGQpKSB7XG4gICAgICByZXR1cm4gcmVjb25jaWxlQ2hpbGRyZW5BcnJheShyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQsIG5ld0NoaWxkLCBsYW5lcyk7XG4gICAgfVxuXG4gICAgaWYgKGdldEl0ZXJhdG9yRm4obmV3Q2hpbGQpKSB7XG4gICAgICByZXR1cm4gcmVjb25jaWxlQ2hpbGRyZW5JdGVyYXRvcihyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQsIG5ld0NoaWxkLCBsYW5lcyk7XG4gICAgfVxuXG4gICAgaWYgKGlzT2JqZWN0KSB7XG4gICAgICB0aHJvd09uSW52YWxpZE9iamVjdFR5cGUocmV0dXJuRmliZXIsIG5ld0NoaWxkKTtcbiAgICB9XG5cbiAgICB7XG4gICAgICBpZiAodHlwZW9mIG5ld0NoaWxkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHdhcm5PbkZ1bmN0aW9uVHlwZShyZXR1cm5GaWJlcik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBuZXdDaGlsZCA9PT0gJ3VuZGVmaW5lZCcgJiYgIWlzVW5rZXllZFRvcExldmVsRnJhZ21lbnQpIHtcbiAgICAgIC8vIElmIHRoZSBuZXcgY2hpbGQgaXMgdW5kZWZpbmVkLCBhbmQgdGhlIHJldHVybiBmaWJlciBpcyBhIGNvbXBvc2l0ZVxuICAgICAgLy8gY29tcG9uZW50LCB0aHJvdyBhbiBlcnJvci4gSWYgRmliZXIgcmV0dXJuIHR5cGVzIGFyZSBkaXNhYmxlZCxcbiAgICAgIC8vIHdlIGFscmVhZHkgdGhyZXcgYWJvdmUuXG4gICAgICBzd2l0Y2ggKHJldHVybkZpYmVyLnRhZykge1xuICAgICAgICBjYXNlIENsYXNzQ29tcG9uZW50OlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgdmFyIGluc3RhbmNlID0gcmV0dXJuRmliZXIuc3RhdGVOb2RlO1xuXG4gICAgICAgICAgICAgIGlmIChpbnN0YW5jZS5yZW5kZXIuX2lzTW9ja0Z1bmN0aW9uKSB7XG4gICAgICAgICAgICAgICAgLy8gV2UgYWxsb3cgYXV0by1tb2NrcyB0byBwcm9jZWVkIGFzIGlmIHRoZXkncmUgcmV0dXJuaW5nIG51bGwuXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIC8vIEludGVudGlvbmFsbHkgZmFsbCB0aHJvdWdoIHRvIHRoZSBuZXh0IGNhc2UsIHdoaWNoIGhhbmRsZXMgYm90aFxuICAgICAgICAvLyBmdW5jdGlvbnMgYW5kIGNsYXNzZXNcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lZCBuby1mYWxsdGhyb3VnaFxuXG4gICAgICAgIGNhc2UgQmxvY2s6XG4gICAgICAgIGNhc2UgRnVuY3Rpb25Db21wb25lbnQ6XG4gICAgICAgIGNhc2UgRm9yd2FyZFJlZjpcbiAgICAgICAgY2FzZSBTaW1wbGVNZW1vQ29tcG9uZW50OlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKCAoZ2V0Q29tcG9uZW50TmFtZShyZXR1cm5GaWJlci50eXBlKSB8fCAnQ29tcG9uZW50JykgKyBcIiguLi4pOiBOb3RoaW5nIHdhcyByZXR1cm5lZCBmcm9tIHJlbmRlci4gVGhpcyB1c3VhbGx5IG1lYW5zIGEgcmV0dXJuIHN0YXRlbWVudCBpcyBtaXNzaW5nLiBPciwgdG8gcmVuZGVyIG5vdGhpbmcsIHJldHVybiBudWxsLlwiICk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgfSAvLyBSZW1haW5pbmcgY2FzZXMgYXJlIGFsbCB0cmVhdGVkIGFzIGVtcHR5LlxuXG5cbiAgICByZXR1cm4gZGVsZXRlUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkKTtcbiAgfVxuXG4gIHJldHVybiByZWNvbmNpbGVDaGlsZEZpYmVycztcbn1cblxudmFyIHJlY29uY2lsZUNoaWxkRmliZXJzID0gQ2hpbGRSZWNvbmNpbGVyKHRydWUpO1xudmFyIG1vdW50Q2hpbGRGaWJlcnMgPSBDaGlsZFJlY29uY2lsZXIoZmFsc2UpO1xuZnVuY3Rpb24gY2xvbmVDaGlsZEZpYmVycyhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcykge1xuICBpZiAoIShjdXJyZW50ID09PSBudWxsIHx8IHdvcmtJblByb2dyZXNzLmNoaWxkID09PSBjdXJyZW50LmNoaWxkKSkge1xuICAgIHtcbiAgICAgIHRocm93IEVycm9yKCBcIlJlc3VtaW5nIHdvcmsgbm90IHlldCBpbXBsZW1lbnRlZC5cIiApO1xuICAgIH1cbiAgfVxuXG4gIGlmICh3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9PT0gbnVsbCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBjdXJyZW50Q2hpbGQgPSB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbiAgdmFyIG5ld0NoaWxkID0gY3JlYXRlV29ya0luUHJvZ3Jlc3MoY3VycmVudENoaWxkLCBjdXJyZW50Q2hpbGQucGVuZGluZ1Byb3BzKTtcbiAgd29ya0luUHJvZ3Jlc3MuY2hpbGQgPSBuZXdDaGlsZDtcbiAgbmV3Q2hpbGQucmV0dXJuID0gd29ya0luUHJvZ3Jlc3M7XG5cbiAgd2hpbGUgKGN1cnJlbnRDaGlsZC5zaWJsaW5nICE9PSBudWxsKSB7XG4gICAgY3VycmVudENoaWxkID0gY3VycmVudENoaWxkLnNpYmxpbmc7XG4gICAgbmV3Q2hpbGQgPSBuZXdDaGlsZC5zaWJsaW5nID0gY3JlYXRlV29ya0luUHJvZ3Jlc3MoY3VycmVudENoaWxkLCBjdXJyZW50Q2hpbGQucGVuZGluZ1Byb3BzKTtcbiAgICBuZXdDaGlsZC5yZXR1cm4gPSB3b3JrSW5Qcm9ncmVzcztcbiAgfVxuXG4gIG5ld0NoaWxkLnNpYmxpbmcgPSBudWxsO1xufSAvLyBSZXNldCBhIHdvcmtJblByb2dyZXNzIGNoaWxkIHNldCB0byBwcmVwYXJlIGl0IGZvciBhIHNlY29uZCBwYXNzLlxuXG5mdW5jdGlvbiByZXNldENoaWxkRmliZXJzKHdvcmtJblByb2dyZXNzLCBsYW5lcykge1xuICB2YXIgY2hpbGQgPSB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcblxuICB3aGlsZSAoY2hpbGQgIT09IG51bGwpIHtcbiAgICByZXNldFdvcmtJblByb2dyZXNzKGNoaWxkLCBsYW5lcyk7XG4gICAgY2hpbGQgPSBjaGlsZC5zaWJsaW5nO1xuICB9XG59XG5cbnZhciBOT19DT05URVhUID0ge307XG52YXIgY29udGV4dFN0YWNrQ3Vyc29yJDEgPSBjcmVhdGVDdXJzb3IoTk9fQ09OVEVYVCk7XG52YXIgY29udGV4dEZpYmVyU3RhY2tDdXJzb3IgPSBjcmVhdGVDdXJzb3IoTk9fQ09OVEVYVCk7XG52YXIgcm9vdEluc3RhbmNlU3RhY2tDdXJzb3IgPSBjcmVhdGVDdXJzb3IoTk9fQ09OVEVYVCk7XG5cbmZ1bmN0aW9uIHJlcXVpcmVkQ29udGV4dChjKSB7XG4gIGlmICghKGMgIT09IE5PX0NPTlRFWFQpKSB7XG4gICAge1xuICAgICAgdGhyb3cgRXJyb3IoIFwiRXhwZWN0ZWQgaG9zdCBjb250ZXh0IHRvIGV4aXN0LiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiICk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGM7XG59XG5cbmZ1bmN0aW9uIGdldFJvb3RIb3N0Q29udGFpbmVyKCkge1xuICB2YXIgcm9vdEluc3RhbmNlID0gcmVxdWlyZWRDb250ZXh0KHJvb3RJbnN0YW5jZVN0YWNrQ3Vyc29yLmN1cnJlbnQpO1xuICByZXR1cm4gcm9vdEluc3RhbmNlO1xufVxuXG5mdW5jdGlvbiBwdXNoSG9zdENvbnRhaW5lcihmaWJlciwgbmV4dFJvb3RJbnN0YW5jZSkge1xuICAvLyBQdXNoIGN1cnJlbnQgcm9vdCBpbnN0YW5jZSBvbnRvIHRoZSBzdGFjaztcbiAgLy8gVGhpcyBhbGxvd3MgdXMgdG8gcmVzZXQgcm9vdCB3aGVuIHBvcnRhbHMgYXJlIHBvcHBlZC5cbiAgcHVzaChyb290SW5zdGFuY2VTdGFja0N1cnNvciwgbmV4dFJvb3RJbnN0YW5jZSwgZmliZXIpOyAvLyBUcmFjayB0aGUgY29udGV4dCBhbmQgdGhlIEZpYmVyIHRoYXQgcHJvdmlkZWQgaXQuXG4gIC8vIFRoaXMgZW5hYmxlcyB1cyB0byBwb3Agb25seSBGaWJlcnMgdGhhdCBwcm92aWRlIHVuaXF1ZSBjb250ZXh0cy5cblxuICBwdXNoKGNvbnRleHRGaWJlclN0YWNrQ3Vyc29yLCBmaWJlciwgZmliZXIpOyAvLyBGaW5hbGx5LCB3ZSBuZWVkIHRvIHB1c2ggdGhlIGhvc3QgY29udGV4dCB0byB0aGUgc3RhY2suXG4gIC8vIEhvd2V2ZXIsIHdlIGNhbid0IGp1c3QgY2FsbCBnZXRSb290SG9zdENvbnRleHQoKSBhbmQgcHVzaCBpdCBiZWNhdXNlXG4gIC8vIHdlJ2QgaGF2ZSBhIGRpZmZlcmVudCBudW1iZXIgb2YgZW50cmllcyBvbiB0aGUgc3RhY2sgZGVwZW5kaW5nIG9uXG4gIC8vIHdoZXRoZXIgZ2V0Um9vdEhvc3RDb250ZXh0KCkgdGhyb3dzIHNvbWV3aGVyZSBpbiByZW5kZXJlciBjb2RlIG9yIG5vdC5cbiAgLy8gU28gd2UgcHVzaCBhbiBlbXB0eSB2YWx1ZSBmaXJzdC4gVGhpcyBsZXRzIHVzIHNhZmVseSB1bndpbmQgb24gZXJyb3JzLlxuXG4gIHB1c2goY29udGV4dFN0YWNrQ3Vyc29yJDEsIE5PX0NPTlRFWFQsIGZpYmVyKTtcbiAgdmFyIG5leHRSb290Q29udGV4dCA9IGdldFJvb3RIb3N0Q29udGV4dChuZXh0Um9vdEluc3RhbmNlKTsgLy8gTm93IHRoYXQgd2Uga25vdyB0aGlzIGZ1bmN0aW9uIGRvZXNuJ3QgdGhyb3csIHJlcGxhY2UgaXQuXG5cbiAgcG9wKGNvbnRleHRTdGFja0N1cnNvciQxLCBmaWJlcik7XG4gIHB1c2goY29udGV4dFN0YWNrQ3Vyc29yJDEsIG5leHRSb290Q29udGV4dCwgZmliZXIpO1xufVxuXG5mdW5jdGlvbiBwb3BIb3N0Q29udGFpbmVyKGZpYmVyKSB7XG4gIHBvcChjb250ZXh0U3RhY2tDdXJzb3IkMSwgZmliZXIpO1xuICBwb3AoY29udGV4dEZpYmVyU3RhY2tDdXJzb3IsIGZpYmVyKTtcbiAgcG9wKHJvb3RJbnN0YW5jZVN0YWNrQ3Vyc29yLCBmaWJlcik7XG59XG5cbmZ1bmN0aW9uIGdldEhvc3RDb250ZXh0KCkge1xuICB2YXIgY29udGV4dCA9IHJlcXVpcmVkQ29udGV4dChjb250ZXh0U3RhY2tDdXJzb3IkMS5jdXJyZW50KTtcbiAgcmV0dXJuIGNvbnRleHQ7XG59XG5cbmZ1bmN0aW9uIHB1c2hIb3N0Q29udGV4dChmaWJlcikge1xuICB2YXIgcm9vdEluc3RhbmNlID0gcmVxdWlyZWRDb250ZXh0KHJvb3RJbnN0YW5jZVN0YWNrQ3Vyc29yLmN1cnJlbnQpO1xuICB2YXIgY29udGV4dCA9IHJlcXVpcmVkQ29udGV4dChjb250ZXh0U3RhY2tDdXJzb3IkMS5jdXJyZW50KTtcbiAgdmFyIG5leHRDb250ZXh0ID0gZ2V0Q2hpbGRIb3N0Q29udGV4dChjb250ZXh0LCBmaWJlci50eXBlKTsgLy8gRG9uJ3QgcHVzaCB0aGlzIEZpYmVyJ3MgY29udGV4dCB1bmxlc3MgaXQncyB1bmlxdWUuXG5cbiAgaWYgKGNvbnRleHQgPT09IG5leHRDb250ZXh0KSB7XG4gICAgcmV0dXJuO1xuICB9IC8vIFRyYWNrIHRoZSBjb250ZXh0IGFuZCB0aGUgRmliZXIgdGhhdCBwcm92aWRlZCBpdC5cbiAgLy8gVGhpcyBlbmFibGVzIHVzIHRvIHBvcCBvbmx5IEZpYmVycyB0aGF0IHByb3ZpZGUgdW5pcXVlIGNvbnRleHRzLlxuXG5cbiAgcHVzaChjb250ZXh0RmliZXJTdGFja0N1cnNvciwgZmliZXIsIGZpYmVyKTtcbiAgcHVzaChjb250ZXh0U3RhY2tDdXJzb3IkMSwgbmV4dENvbnRleHQsIGZpYmVyKTtcbn1cblxuZnVuY3Rpb24gcG9wSG9zdENvbnRleHQoZmliZXIpIHtcbiAgLy8gRG8gbm90IHBvcCB1bmxlc3MgdGhpcyBGaWJlciBwcm92aWRlZCB0aGUgY3VycmVudCBjb250ZXh0LlxuICAvLyBwdXNoSG9zdENvbnRleHQoKSBvbmx5IHB1c2hlcyBGaWJlcnMgdGhhdCBwcm92aWRlIHVuaXF1ZSBjb250ZXh0cy5cbiAgaWYgKGNvbnRleHRGaWJlclN0YWNrQ3Vyc29yLmN1cnJlbnQgIT09IGZpYmVyKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgcG9wKGNvbnRleHRTdGFja0N1cnNvciQxLCBmaWJlcik7XG4gIHBvcChjb250ZXh0RmliZXJTdGFja0N1cnNvciwgZmliZXIpO1xufVxuXG52YXIgRGVmYXVsdFN1c3BlbnNlQ29udGV4dCA9IDA7IC8vIFRoZSBTdXNwZW5zZSBDb250ZXh0IGlzIHNwbGl0IGludG8gdHdvIHBhcnRzLiBUaGUgbG93ZXIgYml0cyBpc1xuLy8gaW5oZXJpdGVkIGRlZXBseSBkb3duIHRoZSBzdWJ0cmVlLiBUaGUgdXBwZXIgYml0cyBvbmx5IGFmZmVjdFxuLy8gdGhpcyBpbW1lZGlhdGUgc3VzcGVuc2UgYm91bmRhcnkgYW5kIGdldHMgcmVzZXQgZWFjaCBuZXdcbi8vIGJvdW5kYXJ5IG9yIHN1c3BlbnNlIGxpc3QuXG5cbnZhciBTdWJ0cmVlU3VzcGVuc2VDb250ZXh0TWFzayA9IDE7IC8vIFN1YnRyZWUgRmxhZ3M6XG4vLyBJbnZpc2libGVQYXJlbnRTdXNwZW5zZUNvbnRleHQgaW5kaWNhdGVzIHRoYXQgb25lIG9mIG91ciBwYXJlbnQgU3VzcGVuc2Vcbi8vIGJvdW5kYXJpZXMgaXMgbm90IGN1cnJlbnRseSBzaG93aW5nIHZpc2libGUgbWFpbiBjb250ZW50LlxuLy8gRWl0aGVyIGJlY2F1c2UgaXQgaXMgYWxyZWFkeSBzaG93aW5nIGEgZmFsbGJhY2sgb3IgaXMgbm90IG1vdW50ZWQgYXQgYWxsLlxuLy8gV2UgY2FuIHVzZSB0aGlzIHRvIGRldGVybWluZSBpZiBpdCBpcyBkZXNpcmFibGUgdG8gdHJpZ2dlciBhIGZhbGxiYWNrIGF0XG4vLyB0aGUgcGFyZW50LiBJZiBub3QsIHRoZW4gd2UgbWlnaHQgbmVlZCB0byB0cmlnZ2VyIHVuZGVzaXJhYmxlIGJvdW5kYXJpZXNcbi8vIGFuZC9vciBzdXNwZW5kIHRoZSBjb21taXQgdG8gYXZvaWQgaGlkaW5nIHRoZSBwYXJlbnQgY29udGVudC5cblxudmFyIEludmlzaWJsZVBhcmVudFN1c3BlbnNlQ29udGV4dCA9IDE7IC8vIFNoYWxsb3cgRmxhZ3M6XG4vLyBGb3JjZVN1c3BlbnNlRmFsbGJhY2sgY2FuIGJlIHVzZWQgYnkgU3VzcGVuc2VMaXN0IHRvIGZvcmNlIG5ld2x5IGFkZGVkXG4vLyBpdGVtcyBpbnRvIHRoZWlyIGZhbGxiYWNrIHN0YXRlIGR1cmluZyBvbmUgb2YgdGhlIHJlbmRlciBwYXNzZXMuXG5cbnZhciBGb3JjZVN1c3BlbnNlRmFsbGJhY2sgPSAyO1xudmFyIHN1c3BlbnNlU3RhY2tDdXJzb3IgPSBjcmVhdGVDdXJzb3IoRGVmYXVsdFN1c3BlbnNlQ29udGV4dCk7XG5mdW5jdGlvbiBoYXNTdXNwZW5zZUNvbnRleHQocGFyZW50Q29udGV4dCwgZmxhZykge1xuICByZXR1cm4gKHBhcmVudENvbnRleHQgJiBmbGFnKSAhPT0gMDtcbn1cbmZ1bmN0aW9uIHNldERlZmF1bHRTaGFsbG93U3VzcGVuc2VDb250ZXh0KHBhcmVudENvbnRleHQpIHtcbiAgcmV0dXJuIHBhcmVudENvbnRleHQgJiBTdWJ0cmVlU3VzcGVuc2VDb250ZXh0TWFzaztcbn1cbmZ1bmN0aW9uIHNldFNoYWxsb3dTdXNwZW5zZUNvbnRleHQocGFyZW50Q29udGV4dCwgc2hhbGxvd0NvbnRleHQpIHtcbiAgcmV0dXJuIHBhcmVudENvbnRleHQgJiBTdWJ0cmVlU3VzcGVuc2VDb250ZXh0TWFzayB8IHNoYWxsb3dDb250ZXh0O1xufVxuZnVuY3Rpb24gYWRkU3VidHJlZVN1c3BlbnNlQ29udGV4dChwYXJlbnRDb250ZXh0LCBzdWJ0cmVlQ29udGV4dCkge1xuICByZXR1cm4gcGFyZW50Q29udGV4dCB8IHN1YnRyZWVDb250ZXh0O1xufVxuZnVuY3Rpb24gcHVzaFN1c3BlbnNlQ29udGV4dChmaWJlciwgbmV3Q29udGV4dCkge1xuICBwdXNoKHN1c3BlbnNlU3RhY2tDdXJzb3IsIG5ld0NvbnRleHQsIGZpYmVyKTtcbn1cbmZ1bmN0aW9uIHBvcFN1c3BlbnNlQ29udGV4dChmaWJlcikge1xuICBwb3Aoc3VzcGVuc2VTdGFja0N1cnNvciwgZmliZXIpO1xufVxuXG5mdW5jdGlvbiBzaG91bGRDYXB0dXJlU3VzcGVuc2Uod29ya0luUHJvZ3Jlc3MsIGhhc0ludmlzaWJsZVBhcmVudCkge1xuICAvLyBJZiBpdCB3YXMgdGhlIHByaW1hcnkgY2hpbGRyZW4gdGhhdCBqdXN0IHN1c3BlbmRlZCwgY2FwdHVyZSBhbmQgcmVuZGVyIHRoZVxuICAvLyBmYWxsYmFjay4gT3RoZXJ3aXNlLCBkb24ndCBjYXB0dXJlIGFuZCBidWJibGUgdG8gdGhlIG5leHQgYm91bmRhcnkuXG4gIHZhciBuZXh0U3RhdGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuXG4gIGlmIChuZXh0U3RhdGUgIT09IG51bGwpIHtcbiAgICBpZiAobmV4dFN0YXRlLmRlaHlkcmF0ZWQgIT09IG51bGwpIHtcbiAgICAgIC8vIEEgZGVoeWRyYXRlZCBib3VuZGFyeSBhbHdheXMgY2FwdHVyZXMuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgcHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFByb3BzOyAvLyBJbiBvcmRlciB0byBjYXB0dXJlLCB0aGUgU3VzcGVuc2UgY29tcG9uZW50IG11c3QgaGF2ZSBhIGZhbGxiYWNrIHByb3AuXG5cbiAgaWYgKHByb3BzLmZhbGxiYWNrID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gLy8gUmVndWxhciBib3VuZGFyaWVzIGFsd2F5cyBjYXB0dXJlLlxuXG5cbiAgaWYgKHByb3BzLnVuc3RhYmxlX2F2b2lkVGhpc0ZhbGxiYWNrICE9PSB0cnVlKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gLy8gSWYgaXQncyBhIGJvdW5kYXJ5IHdlIHNob3VsZCBhdm9pZCwgdGhlbiB3ZSBwcmVmZXIgdG8gYnViYmxlIHVwIHRvIHRoZVxuICAvLyBwYXJlbnQgYm91bmRhcnkgaWYgaXQgaXMgY3VycmVudGx5IGludmlzaWJsZS5cblxuXG4gIGlmIChoYXNJbnZpc2libGVQYXJlbnQpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gLy8gSWYgdGhlIHBhcmVudCBpcyBub3QgYWJsZSB0byBoYW5kbGUgaXQsIHdlIG11c3QgaGFuZGxlIGl0LlxuXG5cbiAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBmaW5kRmlyc3RTdXNwZW5kZWQocm93KSB7XG4gIHZhciBub2RlID0gcm93O1xuXG4gIHdoaWxlIChub2RlICE9PSBudWxsKSB7XG4gICAgaWYgKG5vZGUudGFnID09PSBTdXNwZW5zZUNvbXBvbmVudCkge1xuICAgICAgdmFyIHN0YXRlID0gbm9kZS5tZW1vaXplZFN0YXRlO1xuXG4gICAgICBpZiAoc3RhdGUgIT09IG51bGwpIHtcbiAgICAgICAgdmFyIGRlaHlkcmF0ZWQgPSBzdGF0ZS5kZWh5ZHJhdGVkO1xuXG4gICAgICAgIGlmIChkZWh5ZHJhdGVkID09PSBudWxsIHx8IGlzU3VzcGVuc2VJbnN0YW5jZVBlbmRpbmcoZGVoeWRyYXRlZCkgfHwgaXNTdXNwZW5zZUluc3RhbmNlRmFsbGJhY2soZGVoeWRyYXRlZCkpIHtcbiAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobm9kZS50YWcgPT09IFN1c3BlbnNlTGlzdENvbXBvbmVudCAmJiAvLyByZXZlYWxPcmRlciB1bmRlZmluZWQgY2FuJ3QgYmUgdHJ1c3RlZCBiZWNhdXNlIGl0IGRvbid0XG4gICAgLy8ga2VlcCB0cmFjayBvZiB3aGV0aGVyIGl0IHN1c3BlbmRlZCBvciBub3QuXG4gICAgbm9kZS5tZW1vaXplZFByb3BzLnJldmVhbE9yZGVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHZhciBkaWRTdXNwZW5kID0gKG5vZGUuZmxhZ3MgJiBEaWRDYXB0dXJlKSAhPT0gTm9GbGFncztcblxuICAgICAgaWYgKGRpZFN1c3BlbmQpIHtcbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChub2RlLmNoaWxkICE9PSBudWxsKSB7XG4gICAgICBub2RlLmNoaWxkLnJldHVybiA9IG5vZGU7XG4gICAgICBub2RlID0gbm9kZS5jaGlsZDtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmIChub2RlID09PSByb3cpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHdoaWxlIChub2RlLnNpYmxpbmcgPT09IG51bGwpIHtcbiAgICAgIGlmIChub2RlLnJldHVybiA9PT0gbnVsbCB8fCBub2RlLnJldHVybiA9PT0gcm93KSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICBub2RlID0gbm9kZS5yZXR1cm47XG4gICAgfVxuXG4gICAgbm9kZS5zaWJsaW5nLnJldHVybiA9IG5vZGUucmV0dXJuO1xuICAgIG5vZGUgPSBub2RlLnNpYmxpbmc7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxudmFyIE5vRmxhZ3MkMSA9XG4vKiAgKi9cbjA7IC8vIFJlcHJlc2VudHMgd2hldGhlciBlZmZlY3Qgc2hvdWxkIGZpcmUuXG5cbnZhciBIYXNFZmZlY3QgPVxuLyogKi9cbjE7IC8vIFJlcHJlc2VudHMgdGhlIHBoYXNlIGluIHdoaWNoIHRoZSBlZmZlY3QgKG5vdCB0aGUgY2xlYW4tdXApIGZpcmVzLlxuXG52YXIgTGF5b3V0ID1cbi8qICAgICovXG4yO1xudmFyIFBhc3NpdmUkMSA9XG4vKiAgICovXG40O1xuXG4vLyBUaGlzIG1heSBoYXZlIGJlZW4gYW4gaW5zZXJ0aW9uIG9yIGEgaHlkcmF0aW9uLlxuXG52YXIgaHlkcmF0aW9uUGFyZW50RmliZXIgPSBudWxsO1xudmFyIG5leHRIeWRyYXRhYmxlSW5zdGFuY2UgPSBudWxsO1xudmFyIGlzSHlkcmF0aW5nID0gZmFsc2U7XG5cbmZ1bmN0aW9uIGVudGVySHlkcmF0aW9uU3RhdGUoZmliZXIpIHtcblxuICB2YXIgcGFyZW50SW5zdGFuY2UgPSBmaWJlci5zdGF0ZU5vZGUuY29udGFpbmVySW5mbztcbiAgbmV4dEh5ZHJhdGFibGVJbnN0YW5jZSA9IGdldEZpcnN0SHlkcmF0YWJsZUNoaWxkKHBhcmVudEluc3RhbmNlKTtcbiAgaHlkcmF0aW9uUGFyZW50RmliZXIgPSBmaWJlcjtcbiAgaXNIeWRyYXRpbmcgPSB0cnVlO1xuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gZGVsZXRlSHlkcmF0YWJsZUluc3RhbmNlKHJldHVybkZpYmVyLCBpbnN0YW5jZSkge1xuICB7XG4gICAgc3dpdGNoIChyZXR1cm5GaWJlci50YWcpIHtcbiAgICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgICAgIGRpZE5vdEh5ZHJhdGVDb250YWluZXJJbnN0YW5jZShyZXR1cm5GaWJlci5zdGF0ZU5vZGUuY29udGFpbmVySW5mbywgaW5zdGFuY2UpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAgICBkaWROb3RIeWRyYXRlSW5zdGFuY2UocmV0dXJuRmliZXIudHlwZSwgcmV0dXJuRmliZXIubWVtb2l6ZWRQcm9wcywgcmV0dXJuRmliZXIuc3RhdGVOb2RlLCBpbnN0YW5jZSk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHZhciBjaGlsZFRvRGVsZXRlID0gY3JlYXRlRmliZXJGcm9tSG9zdEluc3RhbmNlRm9yRGVsZXRpb24oKTtcbiAgY2hpbGRUb0RlbGV0ZS5zdGF0ZU5vZGUgPSBpbnN0YW5jZTtcbiAgY2hpbGRUb0RlbGV0ZS5yZXR1cm4gPSByZXR1cm5GaWJlcjtcbiAgY2hpbGRUb0RlbGV0ZS5mbGFncyA9IERlbGV0aW9uOyAvLyBUaGlzIG1pZ2h0IHNlZW0gbGlrZSBpdCBiZWxvbmdzIG9uIHByb2dyZXNzZWRGaXJzdERlbGV0aW9uLiBIb3dldmVyLFxuICAvLyB0aGVzZSBjaGlsZHJlbiBhcmUgbm90IHBhcnQgb2YgdGhlIHJlY29uY2lsaWF0aW9uIGxpc3Qgb2YgY2hpbGRyZW4uXG4gIC8vIEV2ZW4gaWYgd2UgYWJvcnQgYW5kIHJlcmVjb25jaWxlIHRoZSBjaGlsZHJlbiwgdGhhdCB3aWxsIHRyeSB0byBoeWRyYXRlXG4gIC8vIGFnYWluIGFuZCB0aGUgbm9kZXMgYXJlIHN0aWxsIGluIHRoZSBob3N0IHRyZWUgc28gdGhlc2Ugd2lsbCBiZVxuICAvLyByZWNyZWF0ZWQuXG5cbiAgaWYgKHJldHVybkZpYmVyLmxhc3RFZmZlY3QgIT09IG51bGwpIHtcbiAgICByZXR1cm5GaWJlci5sYXN0RWZmZWN0Lm5leHRFZmZlY3QgPSBjaGlsZFRvRGVsZXRlO1xuICAgIHJldHVybkZpYmVyLmxhc3RFZmZlY3QgPSBjaGlsZFRvRGVsZXRlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybkZpYmVyLmZpcnN0RWZmZWN0ID0gcmV0dXJuRmliZXIubGFzdEVmZmVjdCA9IGNoaWxkVG9EZWxldGU7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5zZXJ0Tm9uSHlkcmF0ZWRJbnN0YW5jZShyZXR1cm5GaWJlciwgZmliZXIpIHtcbiAgZmliZXIuZmxhZ3MgPSBmaWJlci5mbGFncyAmIH5IeWRyYXRpbmcgfCBQbGFjZW1lbnQ7XG5cbiAge1xuICAgIHN3aXRjaCAocmV0dXJuRmliZXIudGFnKSB7XG4gICAgICBjYXNlIEhvc3RSb290OlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIHBhcmVudENvbnRhaW5lciA9IHJldHVybkZpYmVyLnN0YXRlTm9kZS5jb250YWluZXJJbmZvO1xuXG4gICAgICAgICAgc3dpdGNoIChmaWJlci50YWcpIHtcbiAgICAgICAgICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgICAgICAgICAgdmFyIHR5cGUgPSBmaWJlci50eXBlO1xuICAgICAgICAgICAgICB2YXIgcHJvcHMgPSBmaWJlci5wZW5kaW5nUHJvcHM7XG4gICAgICAgICAgICAgIGRpZE5vdEZpbmRIeWRyYXRhYmxlQ29udGFpbmVySW5zdGFuY2UocGFyZW50Q29udGFpbmVyLCB0eXBlKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgSG9zdFRleHQ6XG4gICAgICAgICAgICAgIHZhciB0ZXh0ID0gZmliZXIucGVuZGluZ1Byb3BzO1xuICAgICAgICAgICAgICBkaWROb3RGaW5kSHlkcmF0YWJsZUNvbnRhaW5lclRleHRJbnN0YW5jZShwYXJlbnRDb250YWluZXIsIHRleHQpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgcGFyZW50VHlwZSA9IHJldHVybkZpYmVyLnR5cGU7XG4gICAgICAgICAgdmFyIHBhcmVudFByb3BzID0gcmV0dXJuRmliZXIubWVtb2l6ZWRQcm9wcztcbiAgICAgICAgICB2YXIgcGFyZW50SW5zdGFuY2UgPSByZXR1cm5GaWJlci5zdGF0ZU5vZGU7XG5cbiAgICAgICAgICBzd2l0Y2ggKGZpYmVyLnRhZykge1xuICAgICAgICAgICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAgICAgICAgICB2YXIgX3R5cGUgPSBmaWJlci50eXBlO1xuICAgICAgICAgICAgICB2YXIgX3Byb3BzID0gZmliZXIucGVuZGluZ1Byb3BzO1xuICAgICAgICAgICAgICBkaWROb3RGaW5kSHlkcmF0YWJsZUluc3RhbmNlKHBhcmVudFR5cGUsIHBhcmVudFByb3BzLCBwYXJlbnRJbnN0YW5jZSwgX3R5cGUpO1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSBIb3N0VGV4dDpcbiAgICAgICAgICAgICAgdmFyIF90ZXh0ID0gZmliZXIucGVuZGluZ1Byb3BzO1xuICAgICAgICAgICAgICBkaWROb3RGaW5kSHlkcmF0YWJsZVRleHRJbnN0YW5jZShwYXJlbnRUeXBlLCBwYXJlbnRQcm9wcywgcGFyZW50SW5zdGFuY2UsIF90ZXh0KTtcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgU3VzcGVuc2VDb21wb25lbnQ6XG4gICAgICAgICAgICAgIGRpZE5vdEZpbmRIeWRyYXRhYmxlU3VzcGVuc2VJbnN0YW5jZShwYXJlbnRUeXBlLCBwYXJlbnRQcm9wcyk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gdHJ5SHlkcmF0ZShmaWJlciwgbmV4dEluc3RhbmNlKSB7XG4gIHN3aXRjaCAoZmliZXIudGFnKSB7XG4gICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAge1xuICAgICAgICB2YXIgdHlwZSA9IGZpYmVyLnR5cGU7XG4gICAgICAgIHZhciBwcm9wcyA9IGZpYmVyLnBlbmRpbmdQcm9wcztcbiAgICAgICAgdmFyIGluc3RhbmNlID0gY2FuSHlkcmF0ZUluc3RhbmNlKG5leHRJbnN0YW5jZSwgdHlwZSk7XG5cbiAgICAgICAgaWYgKGluc3RhbmNlICE9PSBudWxsKSB7XG4gICAgICAgICAgZmliZXIuc3RhdGVOb2RlID0gaW5zdGFuY2U7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICBjYXNlIEhvc3RUZXh0OlxuICAgICAge1xuICAgICAgICB2YXIgdGV4dCA9IGZpYmVyLnBlbmRpbmdQcm9wcztcbiAgICAgICAgdmFyIHRleHRJbnN0YW5jZSA9IGNhbkh5ZHJhdGVUZXh0SW5zdGFuY2UobmV4dEluc3RhbmNlLCB0ZXh0KTtcblxuICAgICAgICBpZiAodGV4dEluc3RhbmNlICE9PSBudWxsKSB7XG4gICAgICAgICAgZmliZXIuc3RhdGVOb2RlID0gdGV4dEluc3RhbmNlO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgY2FzZSBTdXNwZW5zZUNvbXBvbmVudDpcbiAgICAgIHtcblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbmZ1bmN0aW9uIHRyeVRvQ2xhaW1OZXh0SHlkcmF0YWJsZUluc3RhbmNlKGZpYmVyKSB7XG4gIGlmICghaXNIeWRyYXRpbmcpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgbmV4dEluc3RhbmNlID0gbmV4dEh5ZHJhdGFibGVJbnN0YW5jZTtcblxuICBpZiAoIW5leHRJbnN0YW5jZSkge1xuICAgIC8vIE5vdGhpbmcgdG8gaHlkcmF0ZS4gTWFrZSBpdCBhbiBpbnNlcnRpb24uXG4gICAgaW5zZXJ0Tm9uSHlkcmF0ZWRJbnN0YW5jZShoeWRyYXRpb25QYXJlbnRGaWJlciwgZmliZXIpO1xuICAgIGlzSHlkcmF0aW5nID0gZmFsc2U7XG4gICAgaHlkcmF0aW9uUGFyZW50RmliZXIgPSBmaWJlcjtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgZmlyc3RBdHRlbXB0ZWRJbnN0YW5jZSA9IG5leHRJbnN0YW5jZTtcblxuICBpZiAoIXRyeUh5ZHJhdGUoZmliZXIsIG5leHRJbnN0YW5jZSkpIHtcbiAgICAvLyBJZiB3ZSBjYW4ndCBoeWRyYXRlIHRoaXMgaW5zdGFuY2UgbGV0J3MgdHJ5IHRoZSBuZXh0IG9uZS5cbiAgICAvLyBXZSB1c2UgdGhpcyBhcyBhIGhldXJpc3RpYy4gSXQncyBiYXNlZCBvbiBpbnR1aXRpb24gYW5kIG5vdCBkYXRhIHNvIGl0XG4gICAgLy8gbWlnaHQgYmUgZmxhd2VkIG9yIHVubmVjZXNzYXJ5LlxuICAgIG5leHRJbnN0YW5jZSA9IGdldE5leHRIeWRyYXRhYmxlU2libGluZyhmaXJzdEF0dGVtcHRlZEluc3RhbmNlKTtcblxuICAgIGlmICghbmV4dEluc3RhbmNlIHx8ICF0cnlIeWRyYXRlKGZpYmVyLCBuZXh0SW5zdGFuY2UpKSB7XG4gICAgICAvLyBOb3RoaW5nIHRvIGh5ZHJhdGUuIE1ha2UgaXQgYW4gaW5zZXJ0aW9uLlxuICAgICAgaW5zZXJ0Tm9uSHlkcmF0ZWRJbnN0YW5jZShoeWRyYXRpb25QYXJlbnRGaWJlciwgZmliZXIpO1xuICAgICAgaXNIeWRyYXRpbmcgPSBmYWxzZTtcbiAgICAgIGh5ZHJhdGlvblBhcmVudEZpYmVyID0gZmliZXI7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBXZSBtYXRjaGVkIHRoZSBuZXh0IG9uZSwgd2UnbGwgbm93IGFzc3VtZSB0aGF0IHRoZSBmaXJzdCBvbmUgd2FzXG4gICAgLy8gc3VwZXJmbHVvdXMgYW5kIHdlJ2xsIGRlbGV0ZSBpdC4gU2luY2Ugd2UgY2FuJ3QgZWFnZXJseSBkZWxldGUgaXRcbiAgICAvLyB3ZSdsbCBoYXZlIHRvIHNjaGVkdWxlIGEgZGVsZXRpb24uIFRvIGRvIHRoYXQsIHRoaXMgbm9kZSBuZWVkcyBhIGR1bW15XG4gICAgLy8gZmliZXIgYXNzb2NpYXRlZCB3aXRoIGl0LlxuXG5cbiAgICBkZWxldGVIeWRyYXRhYmxlSW5zdGFuY2UoaHlkcmF0aW9uUGFyZW50RmliZXIsIGZpcnN0QXR0ZW1wdGVkSW5zdGFuY2UpO1xuICB9XG5cbiAgaHlkcmF0aW9uUGFyZW50RmliZXIgPSBmaWJlcjtcbiAgbmV4dEh5ZHJhdGFibGVJbnN0YW5jZSA9IGdldEZpcnN0SHlkcmF0YWJsZUNoaWxkKG5leHRJbnN0YW5jZSk7XG59XG5cbmZ1bmN0aW9uIHByZXBhcmVUb0h5ZHJhdGVIb3N0SW5zdGFuY2UoZmliZXIsIHJvb3RDb250YWluZXJJbnN0YW5jZSwgaG9zdENvbnRleHQpIHtcblxuICB2YXIgaW5zdGFuY2UgPSBmaWJlci5zdGF0ZU5vZGU7XG4gIHZhciB1cGRhdGVQYXlsb2FkID0gaHlkcmF0ZUluc3RhbmNlKGluc3RhbmNlLCBmaWJlci50eXBlLCBmaWJlci5tZW1vaXplZFByb3BzLCByb290Q29udGFpbmVySW5zdGFuY2UsIGhvc3RDb250ZXh0LCBmaWJlcik7IC8vIFRPRE86IFR5cGUgdGhpcyBzcGVjaWZpYyB0byB0aGlzIHR5cGUgb2YgY29tcG9uZW50LlxuXG4gIGZpYmVyLnVwZGF0ZVF1ZXVlID0gdXBkYXRlUGF5bG9hZDsgLy8gSWYgdGhlIHVwZGF0ZSBwYXlsb2FkIGluZGljYXRlcyB0aGF0IHRoZXJlIGlzIGEgY2hhbmdlIG9yIGlmIHRoZXJlXG4gIC8vIGlzIGEgbmV3IHJlZiB3ZSBtYXJrIHRoaXMgYXMgYW4gdXBkYXRlLlxuXG4gIGlmICh1cGRhdGVQYXlsb2FkICE9PSBudWxsKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIHByZXBhcmVUb0h5ZHJhdGVIb3N0VGV4dEluc3RhbmNlKGZpYmVyKSB7XG5cbiAgdmFyIHRleHRJbnN0YW5jZSA9IGZpYmVyLnN0YXRlTm9kZTtcbiAgdmFyIHRleHRDb250ZW50ID0gZmliZXIubWVtb2l6ZWRQcm9wcztcbiAgdmFyIHNob3VsZFVwZGF0ZSA9IGh5ZHJhdGVUZXh0SW5zdGFuY2UodGV4dEluc3RhbmNlLCB0ZXh0Q29udGVudCwgZmliZXIpO1xuXG4gIHtcbiAgICBpZiAoc2hvdWxkVXBkYXRlKSB7XG4gICAgICAvLyBXZSBhc3N1bWUgdGhhdCBwcmVwYXJlVG9IeWRyYXRlSG9zdFRleHRJbnN0YW5jZSBpcyBjYWxsZWQgaW4gYSBjb250ZXh0IHdoZXJlIHRoZVxuICAgICAgLy8gaHlkcmF0aW9uIHBhcmVudCBpcyB0aGUgcGFyZW50IGhvc3QgY29tcG9uZW50IG9mIHRoaXMgaG9zdCB0ZXh0LlxuICAgICAgdmFyIHJldHVybkZpYmVyID0gaHlkcmF0aW9uUGFyZW50RmliZXI7XG5cbiAgICAgIGlmIChyZXR1cm5GaWJlciAhPT0gbnVsbCkge1xuICAgICAgICBzd2l0Y2ggKHJldHVybkZpYmVyLnRhZykge1xuICAgICAgICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHZhciBwYXJlbnRDb250YWluZXIgPSByZXR1cm5GaWJlci5zdGF0ZU5vZGUuY29udGFpbmVySW5mbztcbiAgICAgICAgICAgICAgZGlkTm90TWF0Y2hIeWRyYXRlZENvbnRhaW5lclRleHRJbnN0YW5jZShwYXJlbnRDb250YWluZXIsIHRleHRJbnN0YW5jZSwgdGV4dENvbnRlbnQpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgdmFyIHBhcmVudFR5cGUgPSByZXR1cm5GaWJlci50eXBlO1xuICAgICAgICAgICAgICB2YXIgcGFyZW50UHJvcHMgPSByZXR1cm5GaWJlci5tZW1vaXplZFByb3BzO1xuICAgICAgICAgICAgICB2YXIgcGFyZW50SW5zdGFuY2UgPSByZXR1cm5GaWJlci5zdGF0ZU5vZGU7XG4gICAgICAgICAgICAgIGRpZE5vdE1hdGNoSHlkcmF0ZWRUZXh0SW5zdGFuY2UocGFyZW50VHlwZSwgcGFyZW50UHJvcHMsIHBhcmVudEluc3RhbmNlLCB0ZXh0SW5zdGFuY2UsIHRleHRDb250ZW50KTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gc2hvdWxkVXBkYXRlO1xufVxuXG5mdW5jdGlvbiBza2lwUGFzdERlaHlkcmF0ZWRTdXNwZW5zZUluc3RhbmNlKGZpYmVyKSB7XG5cbiAgdmFyIHN1c3BlbnNlU3RhdGUgPSBmaWJlci5tZW1vaXplZFN0YXRlO1xuICB2YXIgc3VzcGVuc2VJbnN0YW5jZSA9IHN1c3BlbnNlU3RhdGUgIT09IG51bGwgPyBzdXNwZW5zZVN0YXRlLmRlaHlkcmF0ZWQgOiBudWxsO1xuXG4gIGlmICghc3VzcGVuc2VJbnN0YW5jZSkge1xuICAgIHtcbiAgICAgIHRocm93IEVycm9yKCBcIkV4cGVjdGVkIHRvIGhhdmUgYSBoeWRyYXRlZCBzdXNwZW5zZSBpbnN0YW5jZS4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS5cIiApO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBnZXROZXh0SHlkcmF0YWJsZUluc3RhbmNlQWZ0ZXJTdXNwZW5zZUluc3RhbmNlKHN1c3BlbnNlSW5zdGFuY2UpO1xufVxuXG5mdW5jdGlvbiBwb3BUb05leHRIb3N0UGFyZW50KGZpYmVyKSB7XG4gIHZhciBwYXJlbnQgPSBmaWJlci5yZXR1cm47XG5cbiAgd2hpbGUgKHBhcmVudCAhPT0gbnVsbCAmJiBwYXJlbnQudGFnICE9PSBIb3N0Q29tcG9uZW50ICYmIHBhcmVudC50YWcgIT09IEhvc3RSb290ICYmIHBhcmVudC50YWcgIT09IFN1c3BlbnNlQ29tcG9uZW50KSB7XG4gICAgcGFyZW50ID0gcGFyZW50LnJldHVybjtcbiAgfVxuXG4gIGh5ZHJhdGlvblBhcmVudEZpYmVyID0gcGFyZW50O1xufVxuXG5mdW5jdGlvbiBwb3BIeWRyYXRpb25TdGF0ZShmaWJlcikge1xuXG4gIGlmIChmaWJlciAhPT0gaHlkcmF0aW9uUGFyZW50RmliZXIpIHtcbiAgICAvLyBXZSdyZSBkZWVwZXIgdGhhbiB0aGUgY3VycmVudCBoeWRyYXRpb24gY29udGV4dCwgaW5zaWRlIGFuIGluc2VydGVkXG4gICAgLy8gdHJlZS5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoIWlzSHlkcmF0aW5nKSB7XG4gICAgLy8gSWYgd2UncmUgbm90IGN1cnJlbnRseSBoeWRyYXRpbmcgYnV0IHdlJ3JlIGluIGEgaHlkcmF0aW9uIGNvbnRleHQsIHRoZW5cbiAgICAvLyB3ZSB3ZXJlIGFuIGluc2VydGlvbiBhbmQgbm93IG5lZWQgdG8gcG9wIHVwIHJlZW50ZXIgaHlkcmF0aW9uIG9mIG91clxuICAgIC8vIHNpYmxpbmdzLlxuICAgIHBvcFRvTmV4dEhvc3RQYXJlbnQoZmliZXIpO1xuICAgIGlzSHlkcmF0aW5nID0gdHJ1ZTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgdHlwZSA9IGZpYmVyLnR5cGU7IC8vIElmIHdlIGhhdmUgYW55IHJlbWFpbmluZyBoeWRyYXRhYmxlIG5vZGVzLCB3ZSBuZWVkIHRvIGRlbGV0ZSB0aGVtIG5vdy5cbiAgLy8gV2Ugb25seSBkbyB0aGlzIGRlZXBlciB0aGFuIGhlYWQgYW5kIGJvZHkgc2luY2UgdGhleSB0ZW5kIHRvIGhhdmUgcmFuZG9tXG4gIC8vIG90aGVyIG5vZGVzIGluIHRoZW0uIFdlIGFsc28gaWdub3JlIGNvbXBvbmVudHMgd2l0aCBwdXJlIHRleHQgY29udGVudCBpblxuICAvLyBzaWRlIG9mIHRoZW0uXG4gIC8vIFRPRE86IEJldHRlciBoZXVyaXN0aWMuXG5cbiAgaWYgKGZpYmVyLnRhZyAhPT0gSG9zdENvbXBvbmVudCB8fCB0eXBlICE9PSAnaGVhZCcgJiYgdHlwZSAhPT0gJ2JvZHknICYmICFzaG91bGRTZXRUZXh0Q29udGVudCh0eXBlLCBmaWJlci5tZW1vaXplZFByb3BzKSkge1xuICAgIHZhciBuZXh0SW5zdGFuY2UgPSBuZXh0SHlkcmF0YWJsZUluc3RhbmNlO1xuXG4gICAgd2hpbGUgKG5leHRJbnN0YW5jZSkge1xuICAgICAgZGVsZXRlSHlkcmF0YWJsZUluc3RhbmNlKGZpYmVyLCBuZXh0SW5zdGFuY2UpO1xuICAgICAgbmV4dEluc3RhbmNlID0gZ2V0TmV4dEh5ZHJhdGFibGVTaWJsaW5nKG5leHRJbnN0YW5jZSk7XG4gICAgfVxuICB9XG5cbiAgcG9wVG9OZXh0SG9zdFBhcmVudChmaWJlcik7XG5cbiAgaWYgKGZpYmVyLnRhZyA9PT0gU3VzcGVuc2VDb21wb25lbnQpIHtcbiAgICBuZXh0SHlkcmF0YWJsZUluc3RhbmNlID0gc2tpcFBhc3REZWh5ZHJhdGVkU3VzcGVuc2VJbnN0YW5jZShmaWJlcik7XG4gIH0gZWxzZSB7XG4gICAgbmV4dEh5ZHJhdGFibGVJbnN0YW5jZSA9IGh5ZHJhdGlvblBhcmVudEZpYmVyID8gZ2V0TmV4dEh5ZHJhdGFibGVTaWJsaW5nKGZpYmVyLnN0YXRlTm9kZSkgOiBudWxsO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIHJlc2V0SHlkcmF0aW9uU3RhdGUoKSB7XG5cbiAgaHlkcmF0aW9uUGFyZW50RmliZXIgPSBudWxsO1xuICBuZXh0SHlkcmF0YWJsZUluc3RhbmNlID0gbnVsbDtcbiAgaXNIeWRyYXRpbmcgPSBmYWxzZTtcbn1cblxuZnVuY3Rpb24gZ2V0SXNIeWRyYXRpbmcoKSB7XG4gIHJldHVybiBpc0h5ZHJhdGluZztcbn1cblxuLy8gYW5kIHNob3VsZCBiZSByZXNldCBiZWZvcmUgc3RhcnRpbmcgYSBuZXcgcmVuZGVyLlxuLy8gVGhpcyB0cmFja3Mgd2hpY2ggbXV0YWJsZSBzb3VyY2VzIG5lZWQgdG8gYmUgcmVzZXQgYWZ0ZXIgYSByZW5kZXIuXG5cbnZhciB3b3JrSW5Qcm9ncmVzc1NvdXJjZXMgPSBbXTtcbnZhciByZW5kZXJlclNpZ2lsJDE7XG5cbntcbiAgLy8gVXNlZCB0byBkZXRlY3QgbXVsdGlwbGUgcmVuZGVyZXJzIHVzaW5nIHRoZSBzYW1lIG11dGFibGUgc291cmNlLlxuICByZW5kZXJlclNpZ2lsJDEgPSB7fTtcbn1cblxuZnVuY3Rpb24gbWFya1NvdXJjZUFzRGlydHkobXV0YWJsZVNvdXJjZSkge1xuICB3b3JrSW5Qcm9ncmVzc1NvdXJjZXMucHVzaChtdXRhYmxlU291cmNlKTtcbn1cbmZ1bmN0aW9uIHJlc2V0V29ya0luUHJvZ3Jlc3NWZXJzaW9ucygpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB3b3JrSW5Qcm9ncmVzc1NvdXJjZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgbXV0YWJsZVNvdXJjZSA9IHdvcmtJblByb2dyZXNzU291cmNlc1tpXTtcblxuICAgIHtcbiAgICAgIG11dGFibGVTb3VyY2UuX3dvcmtJblByb2dyZXNzVmVyc2lvblByaW1hcnkgPSBudWxsO1xuICAgIH1cbiAgfVxuXG4gIHdvcmtJblByb2dyZXNzU291cmNlcy5sZW5ndGggPSAwO1xufVxuZnVuY3Rpb24gZ2V0V29ya0luUHJvZ3Jlc3NWZXJzaW9uKG11dGFibGVTb3VyY2UpIHtcbiAge1xuICAgIHJldHVybiBtdXRhYmxlU291cmNlLl93b3JrSW5Qcm9ncmVzc1ZlcnNpb25QcmltYXJ5O1xuICB9XG59XG5mdW5jdGlvbiBzZXRXb3JrSW5Qcm9ncmVzc1ZlcnNpb24obXV0YWJsZVNvdXJjZSwgdmVyc2lvbikge1xuICB7XG4gICAgbXV0YWJsZVNvdXJjZS5fd29ya0luUHJvZ3Jlc3NWZXJzaW9uUHJpbWFyeSA9IHZlcnNpb247XG4gIH1cblxuICB3b3JrSW5Qcm9ncmVzc1NvdXJjZXMucHVzaChtdXRhYmxlU291cmNlKTtcbn1cbmZ1bmN0aW9uIHdhcm5BYm91dE11bHRpcGxlUmVuZGVyZXJzREVWKG11dGFibGVTb3VyY2UpIHtcbiAge1xuICAgIHtcbiAgICAgIGlmIChtdXRhYmxlU291cmNlLl9jdXJyZW50UHJpbWFyeVJlbmRlcmVyID09IG51bGwpIHtcbiAgICAgICAgbXV0YWJsZVNvdXJjZS5fY3VycmVudFByaW1hcnlSZW5kZXJlciA9IHJlbmRlcmVyU2lnaWwkMTtcbiAgICAgIH0gZWxzZSBpZiAobXV0YWJsZVNvdXJjZS5fY3VycmVudFByaW1hcnlSZW5kZXJlciAhPT0gcmVuZGVyZXJTaWdpbCQxKSB7XG4gICAgICAgIGVycm9yKCdEZXRlY3RlZCBtdWx0aXBsZSByZW5kZXJlcnMgY29uY3VycmVudGx5IHJlbmRlcmluZyB0aGUgJyArICdzYW1lIG11dGFibGUgc291cmNlLiBUaGlzIGlzIGN1cnJlbnRseSB1bnN1cHBvcnRlZC4nKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn0gLy8gRWFnZXIgcmVhZHMgdGhlIHZlcnNpb24gb2YgYSBtdXRhYmxlIHNvdXJjZSBhbmQgc3RvcmVzIGl0IG9uIHRoZSByb290LlxuXG52YXIgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3RDdXJyZW50RGlzcGF0Y2hlcixcbiAgICBSZWFjdEN1cnJlbnRCYXRjaENvbmZpZyQxID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3RDdXJyZW50QmF0Y2hDb25maWc7XG52YXIgZGlkV2FybkFib3V0TWlzbWF0Y2hlZEhvb2tzRm9yQ29tcG9uZW50O1xudmFyIGRpZFdhcm5BYm91dFVzZU9wYXF1ZUlkZW50aWZpZXI7XG5cbntcbiAgZGlkV2FybkFib3V0VXNlT3BhcXVlSWRlbnRpZmllciA9IHt9O1xuICBkaWRXYXJuQWJvdXRNaXNtYXRjaGVkSG9va3NGb3JDb21wb25lbnQgPSBuZXcgU2V0KCk7XG59XG5cbi8vIFRoZXNlIGFyZSBzZXQgcmlnaHQgYmVmb3JlIGNhbGxpbmcgdGhlIGNvbXBvbmVudC5cbnZhciByZW5kZXJMYW5lcyA9IE5vTGFuZXM7IC8vIFRoZSB3b3JrLWluLXByb2dyZXNzIGZpYmVyLiBJJ3ZlIG5hbWVkIGl0IGRpZmZlcmVudGx5IHRvIGRpc3Rpbmd1aXNoIGl0IGZyb21cbi8vIHRoZSB3b3JrLWluLXByb2dyZXNzIGhvb2suXG5cbnZhciBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxID0gbnVsbDsgLy8gSG9va3MgYXJlIHN0b3JlZCBhcyBhIGxpbmtlZCBsaXN0IG9uIHRoZSBmaWJlcidzIG1lbW9pemVkU3RhdGUgZmllbGQuIFRoZVxuLy8gY3VycmVudCBob29rIGxpc3QgaXMgdGhlIGxpc3QgdGhhdCBiZWxvbmdzIHRvIHRoZSBjdXJyZW50IGZpYmVyLiBUaGVcbi8vIHdvcmstaW4tcHJvZ3Jlc3MgaG9vayBsaXN0IGlzIGEgbmV3IGxpc3QgdGhhdCB3aWxsIGJlIGFkZGVkIHRvIHRoZVxuLy8gd29yay1pbi1wcm9ncmVzcyBmaWJlci5cblxudmFyIGN1cnJlbnRIb29rID0gbnVsbDtcbnZhciB3b3JrSW5Qcm9ncmVzc0hvb2sgPSBudWxsOyAvLyBXaGV0aGVyIGFuIHVwZGF0ZSB3YXMgc2NoZWR1bGVkIGF0IGFueSBwb2ludCBkdXJpbmcgdGhlIHJlbmRlciBwaGFzZS4gVGhpc1xuLy8gZG9lcyBub3QgZ2V0IHJlc2V0IGlmIHdlIGRvIGFub3RoZXIgcmVuZGVyIHBhc3M7IG9ubHkgd2hlbiB3ZSdyZSBjb21wbGV0ZWx5XG4vLyBmaW5pc2hlZCBldmFsdWF0aW5nIHRoaXMgY29tcG9uZW50LiBUaGlzIGlzIGFuIG9wdGltaXphdGlvbiBzbyB3ZSBrbm93XG4vLyB3aGV0aGVyIHdlIG5lZWQgdG8gY2xlYXIgcmVuZGVyIHBoYXNlIHVwZGF0ZXMgYWZ0ZXIgYSB0aHJvdy5cblxudmFyIGRpZFNjaGVkdWxlUmVuZGVyUGhhc2VVcGRhdGUgPSBmYWxzZTsgLy8gV2hlcmUgYW4gdXBkYXRlIHdhcyBzY2hlZHVsZWQgb25seSBkdXJpbmcgdGhlIGN1cnJlbnQgcmVuZGVyIHBhc3MuIFRoaXNcbi8vIGdldHMgcmVzZXQgYWZ0ZXIgZWFjaCBhdHRlbXB0LlxuLy8gVE9ETzogTWF5YmUgdGhlcmUncyBzb21lIHdheSB0byBjb25zb2xpZGF0ZSB0aGlzIHdpdGhcbi8vIGBkaWRTY2hlZHVsZVJlbmRlclBoYXNlVXBkYXRlYC4gT3Igd2l0aCBgbnVtYmVyT2ZSZVJlbmRlcnNgLlxuXG52YXIgZGlkU2NoZWR1bGVSZW5kZXJQaGFzZVVwZGF0ZUR1cmluZ1RoaXNQYXNzID0gZmFsc2U7XG52YXIgUkVfUkVOREVSX0xJTUlUID0gMjU7IC8vIEluIERFViwgdGhpcyBpcyB0aGUgbmFtZSBvZiB0aGUgY3VycmVudGx5IGV4ZWN1dGluZyBwcmltaXRpdmUgaG9va1xuXG52YXIgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBudWxsOyAvLyBJbiBERVYsIHRoaXMgbGlzdCBlbnN1cmVzIHRoYXQgaG9va3MgYXJlIGNhbGxlZCBpbiB0aGUgc2FtZSBvcmRlciBiZXR3ZWVuIHJlbmRlcnMuXG4vLyBUaGUgbGlzdCBzdG9yZXMgdGhlIG9yZGVyIG9mIGhvb2tzIHVzZWQgZHVyaW5nIHRoZSBpbml0aWFsIHJlbmRlciAobW91bnQpLlxuLy8gU3Vic2VxdWVudCByZW5kZXJzICh1cGRhdGVzKSByZWZlcmVuY2UgdGhpcyBsaXN0LlxuXG52YXIgaG9va1R5cGVzRGV2ID0gbnVsbDtcbnZhciBob29rVHlwZXNVcGRhdGVJbmRleERldiA9IC0xOyAvLyBJbiBERVYsIHRoaXMgdHJhY2tzIHdoZXRoZXIgY3VycmVudGx5IHJlbmRlcmluZyBjb21wb25lbnQgbmVlZHMgdG8gaWdub3JlXG4vLyB0aGUgZGVwZW5kZW5jaWVzIGZvciBIb29rcyB0aGF0IG5lZWQgdGhlbSAoZS5nLiB1c2VFZmZlY3Qgb3IgdXNlTWVtbykuXG4vLyBXaGVuIHRydWUsIHN1Y2ggSG9va3Mgd2lsbCBhbHdheXMgYmUgXCJyZW1vdW50ZWRcIi4gT25seSB1c2VkIGR1cmluZyBob3QgcmVsb2FkLlxuXG52YXIgaWdub3JlUHJldmlvdXNEZXBlbmRlbmNpZXMgPSBmYWxzZTtcblxuZnVuY3Rpb24gbW91bnRIb29rVHlwZXNEZXYoKSB7XG4gIHtcbiAgICB2YXIgaG9va05hbWUgPSBjdXJyZW50SG9va05hbWVJbkRldjtcblxuICAgIGlmIChob29rVHlwZXNEZXYgPT09IG51bGwpIHtcbiAgICAgIGhvb2tUeXBlc0RldiA9IFtob29rTmFtZV07XG4gICAgfSBlbHNlIHtcbiAgICAgIGhvb2tUeXBlc0Rldi5wdXNoKGhvb2tOYW1lKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gdXBkYXRlSG9va1R5cGVzRGV2KCkge1xuICB7XG4gICAgdmFyIGhvb2tOYW1lID0gY3VycmVudEhvb2tOYW1lSW5EZXY7XG5cbiAgICBpZiAoaG9va1R5cGVzRGV2ICE9PSBudWxsKSB7XG4gICAgICBob29rVHlwZXNVcGRhdGVJbmRleERldisrO1xuXG4gICAgICBpZiAoaG9va1R5cGVzRGV2W2hvb2tUeXBlc1VwZGF0ZUluZGV4RGV2XSAhPT0gaG9va05hbWUpIHtcbiAgICAgICAgd2Fybk9uSG9va01pc21hdGNoSW5EZXYoaG9va05hbWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjaGVja0RlcHNBcmVBcnJheURldihkZXBzKSB7XG4gIHtcbiAgICBpZiAoZGVwcyAhPT0gdW5kZWZpbmVkICYmIGRlcHMgIT09IG51bGwgJiYgIUFycmF5LmlzQXJyYXkoZGVwcykpIHtcbiAgICAgIC8vIFZlcmlmeSBkZXBzLCBidXQgb25seSBvbiBtb3VudCB0byBhdm9pZCBleHRyYSBjaGVja3MuXG4gICAgICAvLyBJdCdzIHVubGlrZWx5IHRoZWlyIHR5cGUgd291bGQgY2hhbmdlIGFzIHVzdWFsbHkgeW91IGRlZmluZSB0aGVtIGlubGluZS5cbiAgICAgIGVycm9yKCclcyByZWNlaXZlZCBhIGZpbmFsIGFyZ3VtZW50IHRoYXQgaXMgbm90IGFuIGFycmF5IChpbnN0ZWFkLCByZWNlaXZlZCBgJXNgKS4gV2hlbiAnICsgJ3NwZWNpZmllZCwgdGhlIGZpbmFsIGFyZ3VtZW50IG11c3QgYmUgYW4gYXJyYXkuJywgY3VycmVudEhvb2tOYW1lSW5EZXYsIHR5cGVvZiBkZXBzKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gd2Fybk9uSG9va01pc21hdGNoSW5EZXYoY3VycmVudEhvb2tOYW1lKSB7XG4gIHtcbiAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWUoY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMS50eXBlKTtcblxuICAgIGlmICghZGlkV2FybkFib3V0TWlzbWF0Y2hlZEhvb2tzRm9yQ29tcG9uZW50Lmhhcyhjb21wb25lbnROYW1lKSkge1xuICAgICAgZGlkV2FybkFib3V0TWlzbWF0Y2hlZEhvb2tzRm9yQ29tcG9uZW50LmFkZChjb21wb25lbnROYW1lKTtcblxuICAgICAgaWYgKGhvb2tUeXBlc0RldiAhPT0gbnVsbCkge1xuICAgICAgICB2YXIgdGFibGUgPSAnJztcbiAgICAgICAgdmFyIHNlY29uZENvbHVtblN0YXJ0ID0gMzA7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPD0gaG9va1R5cGVzVXBkYXRlSW5kZXhEZXY7IGkrKykge1xuICAgICAgICAgIHZhciBvbGRIb29rTmFtZSA9IGhvb2tUeXBlc0RldltpXTtcbiAgICAgICAgICB2YXIgbmV3SG9va05hbWUgPSBpID09PSBob29rVHlwZXNVcGRhdGVJbmRleERldiA/IGN1cnJlbnRIb29rTmFtZSA6IG9sZEhvb2tOYW1lO1xuICAgICAgICAgIHZhciByb3cgPSBpICsgMSArIFwiLiBcIiArIG9sZEhvb2tOYW1lOyAvLyBFeHRyYSBzcGFjZSBzbyBzZWNvbmQgY29sdW1uIGxpbmVzIHVwXG4gICAgICAgICAgLy8gbG9sIEAgSUUgbm90IHN1cHBvcnRpbmcgU3RyaW5nI3JlcGVhdFxuXG4gICAgICAgICAgd2hpbGUgKHJvdy5sZW5ndGggPCBzZWNvbmRDb2x1bW5TdGFydCkge1xuICAgICAgICAgICAgcm93ICs9ICcgJztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByb3cgKz0gbmV3SG9va05hbWUgKyAnXFxuJztcbiAgICAgICAgICB0YWJsZSArPSByb3c7XG4gICAgICAgIH1cblxuICAgICAgICBlcnJvcignUmVhY3QgaGFzIGRldGVjdGVkIGEgY2hhbmdlIGluIHRoZSBvcmRlciBvZiBIb29rcyBjYWxsZWQgYnkgJXMuICcgKyAnVGhpcyB3aWxsIGxlYWQgdG8gYnVncyBhbmQgZXJyb3JzIGlmIG5vdCBmaXhlZC4gJyArICdGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVhZCB0aGUgUnVsZXMgb2YgSG9va3M6IGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9ydWxlcy1vZi1ob29rc1xcblxcbicgKyAnICAgUHJldmlvdXMgcmVuZGVyICAgICAgICAgICAgTmV4dCByZW5kZXJcXG4nICsgJyAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcbicgKyAnJXMnICsgJyAgIF5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXlxcbicsIGNvbXBvbmVudE5hbWUsIHRhYmxlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gdGhyb3dJbnZhbGlkSG9va0Vycm9yKCkge1xuICB7XG4gICAge1xuICAgICAgdGhyb3cgRXJyb3IoIFwiSW52YWxpZCBob29rIGNhbGwuIEhvb2tzIGNhbiBvbmx5IGJlIGNhbGxlZCBpbnNpZGUgb2YgdGhlIGJvZHkgb2YgYSBmdW5jdGlvbiBjb21wb25lbnQuIFRoaXMgY291bGQgaGFwcGVuIGZvciBvbmUgb2YgdGhlIGZvbGxvd2luZyByZWFzb25zOlxcbjEuIFlvdSBtaWdodCBoYXZlIG1pc21hdGNoaW5nIHZlcnNpb25zIG9mIFJlYWN0IGFuZCB0aGUgcmVuZGVyZXIgKHN1Y2ggYXMgUmVhY3QgRE9NKVxcbjIuIFlvdSBtaWdodCBiZSBicmVha2luZyB0aGUgUnVsZXMgb2YgSG9va3NcXG4zLiBZb3UgbWlnaHQgaGF2ZSBtb3JlIHRoYW4gb25lIGNvcHkgb2YgUmVhY3QgaW4gdGhlIHNhbWUgYXBwXFxuU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9pbnZhbGlkLWhvb2stY2FsbCBmb3IgdGlwcyBhYm91dCBob3cgdG8gZGVidWcgYW5kIGZpeCB0aGlzIHByb2JsZW0uXCIgKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gYXJlSG9va0lucHV0c0VxdWFsKG5leHREZXBzLCBwcmV2RGVwcykge1xuICB7XG4gICAgaWYgKGlnbm9yZVByZXZpb3VzRGVwZW5kZW5jaWVzKSB7XG4gICAgICAvLyBPbmx5IHRydWUgd2hlbiB0aGlzIGNvbXBvbmVudCBpcyBiZWluZyBob3QgcmVsb2FkZWQuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgaWYgKHByZXZEZXBzID09PSBudWxsKSB7XG4gICAge1xuICAgICAgZXJyb3IoJyVzIHJlY2VpdmVkIGEgZmluYWwgYXJndW1lbnQgZHVyaW5nIHRoaXMgcmVuZGVyLCBidXQgbm90IGR1cmluZyAnICsgJ3RoZSBwcmV2aW91cyByZW5kZXIuIEV2ZW4gdGhvdWdoIHRoZSBmaW5hbCBhcmd1bWVudCBpcyBvcHRpb25hbCwgJyArICdpdHMgdHlwZSBjYW5ub3QgY2hhbmdlIGJldHdlZW4gcmVuZGVycy4nLCBjdXJyZW50SG9va05hbWVJbkRldik7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAge1xuICAgIC8vIERvbid0IGJvdGhlciBjb21wYXJpbmcgbGVuZ3RocyBpbiBwcm9kIGJlY2F1c2UgdGhlc2UgYXJyYXlzIHNob3VsZCBiZVxuICAgIC8vIHBhc3NlZCBpbmxpbmUuXG4gICAgaWYgKG5leHREZXBzLmxlbmd0aCAhPT0gcHJldkRlcHMubGVuZ3RoKSB7XG4gICAgICBlcnJvcignVGhlIGZpbmFsIGFyZ3VtZW50IHBhc3NlZCB0byAlcyBjaGFuZ2VkIHNpemUgYmV0d2VlbiByZW5kZXJzLiBUaGUgJyArICdvcmRlciBhbmQgc2l6ZSBvZiB0aGlzIGFycmF5IG11c3QgcmVtYWluIGNvbnN0YW50LlxcblxcbicgKyAnUHJldmlvdXM6ICVzXFxuJyArICdJbmNvbWluZzogJXMnLCBjdXJyZW50SG9va05hbWVJbkRldiwgXCJbXCIgKyBwcmV2RGVwcy5qb2luKCcsICcpICsgXCJdXCIsIFwiW1wiICsgbmV4dERlcHMuam9pbignLCAnKSArIFwiXVwiKTtcbiAgICB9XG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHByZXZEZXBzLmxlbmd0aCAmJiBpIDwgbmV4dERlcHMubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAob2JqZWN0SXMobmV4dERlcHNbaV0sIHByZXZEZXBzW2ldKSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIHJlbmRlcldpdGhIb29rcyhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgQ29tcG9uZW50LCBwcm9wcywgc2Vjb25kQXJnLCBuZXh0UmVuZGVyTGFuZXMpIHtcbiAgcmVuZGVyTGFuZXMgPSBuZXh0UmVuZGVyTGFuZXM7XG4gIGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEgPSB3b3JrSW5Qcm9ncmVzcztcblxuICB7XG4gICAgaG9va1R5cGVzRGV2ID0gY3VycmVudCAhPT0gbnVsbCA/IGN1cnJlbnQuX2RlYnVnSG9va1R5cGVzIDogbnVsbDtcbiAgICBob29rVHlwZXNVcGRhdGVJbmRleERldiA9IC0xOyAvLyBVc2VkIGZvciBob3QgcmVsb2FkaW5nOlxuXG4gICAgaWdub3JlUHJldmlvdXNEZXBlbmRlbmNpZXMgPSBjdXJyZW50ICE9PSBudWxsICYmIGN1cnJlbnQudHlwZSAhPT0gd29ya0luUHJvZ3Jlc3MudHlwZTtcbiAgfVxuXG4gIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBudWxsO1xuICB3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZSA9IG51bGw7XG4gIHdvcmtJblByb2dyZXNzLmxhbmVzID0gTm9MYW5lczsgLy8gVGhlIGZvbGxvd2luZyBzaG91bGQgaGF2ZSBhbHJlYWR5IGJlZW4gcmVzZXRcbiAgLy8gY3VycmVudEhvb2sgPSBudWxsO1xuICAvLyB3b3JrSW5Qcm9ncmVzc0hvb2sgPSBudWxsO1xuICAvLyBkaWRTY2hlZHVsZVJlbmRlclBoYXNlVXBkYXRlID0gZmFsc2U7XG4gIC8vIFRPRE8gV2FybiBpZiBubyBob29rcyBhcmUgdXNlZCBhdCBhbGwgZHVyaW5nIG1vdW50LCB0aGVuIHNvbWUgYXJlIHVzZWQgZHVyaW5nIHVwZGF0ZS5cbiAgLy8gQ3VycmVudGx5IHdlIHdpbGwgaWRlbnRpZnkgdGhlIHVwZGF0ZSByZW5kZXIgYXMgYSBtb3VudCBiZWNhdXNlIG1lbW9pemVkU3RhdGUgPT09IG51bGwuXG4gIC8vIFRoaXMgaXMgdHJpY2t5IGJlY2F1c2UgaXQncyB2YWxpZCBmb3IgY2VydGFpbiB0eXBlcyBvZiBjb21wb25lbnRzIChlLmcuIFJlYWN0LmxhenkpXG4gIC8vIFVzaW5nIG1lbW9pemVkU3RhdGUgdG8gZGlmZmVyZW50aWF0ZSBiZXR3ZWVuIG1vdW50L3VwZGF0ZSBvbmx5IHdvcmtzIGlmIGF0IGxlYXN0IG9uZSBzdGF0ZWZ1bCBob29rIGlzIHVzZWQuXG4gIC8vIE5vbi1zdGF0ZWZ1bCBob29rcyAoZS5nLiBjb250ZXh0KSBkb24ndCBnZXQgYWRkZWQgdG8gbWVtb2l6ZWRTdGF0ZSxcbiAgLy8gc28gbWVtb2l6ZWRTdGF0ZSB3b3VsZCBiZSBudWxsIGR1cmluZyB1cGRhdGVzIGFuZCBtb3VudHMuXG5cbiAge1xuICAgIGlmIChjdXJyZW50ICE9PSBudWxsICYmIGN1cnJlbnQubWVtb2l6ZWRTdGF0ZSAhPT0gbnVsbCkge1xuICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSBIb29rc0Rpc3BhdGNoZXJPblVwZGF0ZUluREVWO1xuICAgIH0gZWxzZSBpZiAoaG9va1R5cGVzRGV2ICE9PSBudWxsKSB7XG4gICAgICAvLyBUaGlzIGRpc3BhdGNoZXIgaGFuZGxlcyBhbiBlZGdlIGNhc2Ugd2hlcmUgYSBjb21wb25lbnQgaXMgdXBkYXRpbmcsXG4gICAgICAvLyBidXQgbm8gc3RhdGVmdWwgaG9va3MgaGF2ZSBiZWVuIHVzZWQuXG4gICAgICAvLyBXZSB3YW50IHRvIG1hdGNoIHRoZSBwcm9kdWN0aW9uIGNvZGUgYmVoYXZpb3IgKHdoaWNoIHdpbGwgdXNlIEhvb2tzRGlzcGF0Y2hlck9uTW91bnQpLFxuICAgICAgLy8gYnV0IHdpdGggdGhlIGV4dHJhIERFViB2YWxpZGF0aW9uIHRvIGVuc3VyZSBob29rcyBvcmRlcmluZyBoYXNuJ3QgY2hhbmdlZC5cbiAgICAgIC8vIFRoaXMgZGlzcGF0Y2hlciBkb2VzIHRoYXQuXG4gICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudCA9IEhvb2tzRGlzcGF0Y2hlck9uTW91bnRXaXRoSG9va1R5cGVzSW5ERVY7XG4gICAgfSBlbHNlIHtcbiAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gSG9va3NEaXNwYXRjaGVyT25Nb3VudEluREVWO1xuICAgIH1cbiAgfVxuXG4gIHZhciBjaGlsZHJlbiA9IENvbXBvbmVudChwcm9wcywgc2Vjb25kQXJnKTsgLy8gQ2hlY2sgaWYgdGhlcmUgd2FzIGEgcmVuZGVyIHBoYXNlIHVwZGF0ZVxuXG4gIGlmIChkaWRTY2hlZHVsZVJlbmRlclBoYXNlVXBkYXRlRHVyaW5nVGhpc1Bhc3MpIHtcbiAgICAvLyBLZWVwIHJlbmRlcmluZyBpbiBhIGxvb3AgZm9yIGFzIGxvbmcgYXMgcmVuZGVyIHBoYXNlIHVwZGF0ZXMgY29udGludWUgdG9cbiAgICAvLyBiZSBzY2hlZHVsZWQuIFVzZSBhIGNvdW50ZXIgdG8gcHJldmVudCBpbmZpbml0ZSBsb29wcy5cbiAgICB2YXIgbnVtYmVyT2ZSZVJlbmRlcnMgPSAwO1xuXG4gICAgZG8ge1xuICAgICAgZGlkU2NoZWR1bGVSZW5kZXJQaGFzZVVwZGF0ZUR1cmluZ1RoaXNQYXNzID0gZmFsc2U7XG5cbiAgICAgIGlmICghKG51bWJlck9mUmVSZW5kZXJzIDwgUkVfUkVOREVSX0xJTUlUKSkge1xuICAgICAgICB7XG4gICAgICAgICAgdGhyb3cgRXJyb3IoIFwiVG9vIG1hbnkgcmUtcmVuZGVycy4gUmVhY3QgbGltaXRzIHRoZSBudW1iZXIgb2YgcmVuZGVycyB0byBwcmV2ZW50IGFuIGluZmluaXRlIGxvb3AuXCIgKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBudW1iZXJPZlJlUmVuZGVycyArPSAxO1xuXG4gICAgICB7XG4gICAgICAgIC8vIEV2ZW4gd2hlbiBob3QgcmVsb2FkaW5nLCBhbGxvdyBkZXBlbmRlbmNpZXMgdG8gc3RhYmlsaXplXG4gICAgICAgIC8vIGFmdGVyIGZpcnN0IHJlbmRlciB0byBwcmV2ZW50IGluZmluaXRlIHJlbmRlciBwaGFzZSB1cGRhdGVzLlxuICAgICAgICBpZ25vcmVQcmV2aW91c0RlcGVuZGVuY2llcyA9IGZhbHNlO1xuICAgICAgfSAvLyBTdGFydCBvdmVyIGZyb20gdGhlIGJlZ2lubmluZyBvZiB0aGUgbGlzdFxuXG5cbiAgICAgIGN1cnJlbnRIb29rID0gbnVsbDtcbiAgICAgIHdvcmtJblByb2dyZXNzSG9vayA9IG51bGw7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZSA9IG51bGw7XG5cbiAgICAgIHtcbiAgICAgICAgLy8gQWxzbyB2YWxpZGF0ZSBob29rIG9yZGVyIGZvciBjYXNjYWRpbmcgdXBkYXRlcy5cbiAgICAgICAgaG9va1R5cGVzVXBkYXRlSW5kZXhEZXYgPSAtMTtcbiAgICAgIH1cblxuICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSAgSG9va3NEaXNwYXRjaGVyT25SZXJlbmRlckluREVWIDtcbiAgICAgIGNoaWxkcmVuID0gQ29tcG9uZW50KHByb3BzLCBzZWNvbmRBcmcpO1xuICAgIH0gd2hpbGUgKGRpZFNjaGVkdWxlUmVuZGVyUGhhc2VVcGRhdGVEdXJpbmdUaGlzUGFzcyk7XG4gIH0gLy8gV2UgY2FuIGFzc3VtZSB0aGUgcHJldmlvdXMgZGlzcGF0Y2hlciBpcyBhbHdheXMgdGhpcyBvbmUsIHNpbmNlIHdlIHNldCBpdFxuICAvLyBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZSByZW5kZXIgcGhhc2UgYW5kIHRoZXJlJ3Mgbm8gcmUtZW50cmFuY3kuXG5cblxuICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudCA9IENvbnRleHRPbmx5RGlzcGF0Y2hlcjtcblxuICB7XG4gICAgd29ya0luUHJvZ3Jlc3MuX2RlYnVnSG9va1R5cGVzID0gaG9va1R5cGVzRGV2O1xuICB9IC8vIFRoaXMgY2hlY2sgdXNlcyBjdXJyZW50SG9vayBzbyB0aGF0IGl0IHdvcmtzIHRoZSBzYW1lIGluIERFViBhbmQgcHJvZCBidW5kbGVzLlxuICAvLyBob29rVHlwZXNEZXYgY291bGQgY2F0Y2ggbW9yZSBjYXNlcyAoZS5nLiBjb250ZXh0KSBidXQgb25seSBpbiBERVYgYnVuZGxlcy5cblxuXG4gIHZhciBkaWRSZW5kZXJUb29GZXdIb29rcyA9IGN1cnJlbnRIb29rICE9PSBudWxsICYmIGN1cnJlbnRIb29rLm5leHQgIT09IG51bGw7XG4gIHJlbmRlckxhbmVzID0gTm9MYW5lcztcbiAgY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMSA9IG51bGw7XG4gIGN1cnJlbnRIb29rID0gbnVsbDtcbiAgd29ya0luUHJvZ3Jlc3NIb29rID0gbnVsbDtcblxuICB7XG4gICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBudWxsO1xuICAgIGhvb2tUeXBlc0RldiA9IG51bGw7XG4gICAgaG9va1R5cGVzVXBkYXRlSW5kZXhEZXYgPSAtMTtcbiAgfVxuXG4gIGRpZFNjaGVkdWxlUmVuZGVyUGhhc2VVcGRhdGUgPSBmYWxzZTtcblxuICBpZiAoISFkaWRSZW5kZXJUb29GZXdIb29rcykge1xuICAgIHtcbiAgICAgIHRocm93IEVycm9yKCBcIlJlbmRlcmVkIGZld2VyIGhvb2tzIHRoYW4gZXhwZWN0ZWQuIFRoaXMgbWF5IGJlIGNhdXNlZCBieSBhbiBhY2NpZGVudGFsIGVhcmx5IHJldHVybiBzdGF0ZW1lbnQuXCIgKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gY2hpbGRyZW47XG59XG5mdW5jdGlvbiBiYWlsb3V0SG9va3MoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIGxhbmVzKSB7XG4gIHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlID0gY3VycmVudC51cGRhdGVRdWV1ZTtcbiAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgJj0gfihQYXNzaXZlIHwgVXBkYXRlKTtcbiAgY3VycmVudC5sYW5lcyA9IHJlbW92ZUxhbmVzKGN1cnJlbnQubGFuZXMsIGxhbmVzKTtcbn1cbmZ1bmN0aW9uIHJlc2V0SG9va3NBZnRlclRocm93KCkge1xuICAvLyBXZSBjYW4gYXNzdW1lIHRoZSBwcmV2aW91cyBkaXNwYXRjaGVyIGlzIGFsd2F5cyB0aGlzIG9uZSwgc2luY2Ugd2Ugc2V0IGl0XG4gIC8vIGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlIHJlbmRlciBwaGFzZSBhbmQgdGhlcmUncyBubyByZS1lbnRyYW5jeS5cbiAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSBDb250ZXh0T25seURpc3BhdGNoZXI7XG5cbiAgaWYgKGRpZFNjaGVkdWxlUmVuZGVyUGhhc2VVcGRhdGUpIHtcbiAgICAvLyBUaGVyZSB3ZXJlIHJlbmRlciBwaGFzZSB1cGRhdGVzLiBUaGVzZSBhcmUgb25seSB2YWxpZCBmb3IgdGhpcyByZW5kZXJcbiAgICAvLyBwaGFzZSwgd2hpY2ggd2UgYXJlIG5vdyBhYm9ydGluZy4gUmVtb3ZlIHRoZSB1cGRhdGVzIGZyb20gdGhlIHF1ZXVlcyBzb1xuICAgIC8vIHRoZXkgZG8gbm90IHBlcnNpc3QgdG8gdGhlIG5leHQgcmVuZGVyLiBEbyBub3QgcmVtb3ZlIHVwZGF0ZXMgZnJvbSBob29rc1xuICAgIC8vIHRoYXQgd2VyZW4ndCBwcm9jZXNzZWQuXG4gICAgLy9cbiAgICAvLyBPbmx5IHJlc2V0IHRoZSB1cGRhdGVzIGZyb20gdGhlIHF1ZXVlIGlmIGl0IGhhcyBhIGNsb25lLiBJZiBpdCBkb2VzXG4gICAgLy8gbm90IGhhdmUgYSBjbG9uZSwgdGhhdCBtZWFucyBpdCB3YXNuJ3QgcHJvY2Vzc2VkLCBhbmQgdGhlIHVwZGF0ZXMgd2VyZVxuICAgIC8vIHNjaGVkdWxlZCBiZWZvcmUgd2UgZW50ZXJlZCB0aGUgcmVuZGVyIHBoYXNlLlxuICAgIHZhciBob29rID0gY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMS5tZW1vaXplZFN0YXRlO1xuXG4gICAgd2hpbGUgKGhvb2sgIT09IG51bGwpIHtcbiAgICAgIHZhciBxdWV1ZSA9IGhvb2sucXVldWU7XG5cbiAgICAgIGlmIChxdWV1ZSAhPT0gbnVsbCkge1xuICAgICAgICBxdWV1ZS5wZW5kaW5nID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgaG9vayA9IGhvb2submV4dDtcbiAgICB9XG5cbiAgICBkaWRTY2hlZHVsZVJlbmRlclBoYXNlVXBkYXRlID0gZmFsc2U7XG4gIH1cblxuICByZW5kZXJMYW5lcyA9IE5vTGFuZXM7XG4gIGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEgPSBudWxsO1xuICBjdXJyZW50SG9vayA9IG51bGw7XG4gIHdvcmtJblByb2dyZXNzSG9vayA9IG51bGw7XG5cbiAge1xuICAgIGhvb2tUeXBlc0RldiA9IG51bGw7XG4gICAgaG9va1R5cGVzVXBkYXRlSW5kZXhEZXYgPSAtMTtcbiAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IG51bGw7XG4gICAgaXNVcGRhdGluZ09wYXF1ZVZhbHVlSW5SZW5kZXJQaGFzZSA9IGZhbHNlO1xuICB9XG5cbiAgZGlkU2NoZWR1bGVSZW5kZXJQaGFzZVVwZGF0ZUR1cmluZ1RoaXNQYXNzID0gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIG1vdW50V29ya0luUHJvZ3Jlc3NIb29rKCkge1xuICB2YXIgaG9vayA9IHtcbiAgICBtZW1vaXplZFN0YXRlOiBudWxsLFxuICAgIGJhc2VTdGF0ZTogbnVsbCxcbiAgICBiYXNlUXVldWU6IG51bGwsXG4gICAgcXVldWU6IG51bGwsXG4gICAgbmV4dDogbnVsbFxuICB9O1xuXG4gIGlmICh3b3JrSW5Qcm9ncmVzc0hvb2sgPT09IG51bGwpIHtcbiAgICAvLyBUaGlzIGlzIHRoZSBmaXJzdCBob29rIGluIHRoZSBsaXN0XG4gICAgY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMS5tZW1vaXplZFN0YXRlID0gd29ya0luUHJvZ3Jlc3NIb29rID0gaG9vaztcbiAgfSBlbHNlIHtcbiAgICAvLyBBcHBlbmQgdG8gdGhlIGVuZCBvZiB0aGUgbGlzdFxuICAgIHdvcmtJblByb2dyZXNzSG9vayA9IHdvcmtJblByb2dyZXNzSG9vay5uZXh0ID0gaG9vaztcbiAgfVxuXG4gIHJldHVybiB3b3JrSW5Qcm9ncmVzc0hvb2s7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZVdvcmtJblByb2dyZXNzSG9vaygpIHtcbiAgLy8gVGhpcyBmdW5jdGlvbiBpcyB1c2VkIGJvdGggZm9yIHVwZGF0ZXMgYW5kIGZvciByZS1yZW5kZXJzIHRyaWdnZXJlZCBieSBhXG4gIC8vIHJlbmRlciBwaGFzZSB1cGRhdGUuIEl0IGFzc3VtZXMgdGhlcmUgaXMgZWl0aGVyIGEgY3VycmVudCBob29rIHdlIGNhblxuICAvLyBjbG9uZSwgb3IgYSB3b3JrLWluLXByb2dyZXNzIGhvb2sgZnJvbSBhIHByZXZpb3VzIHJlbmRlciBwYXNzIHRoYXQgd2UgY2FuXG4gIC8vIHVzZSBhcyBhIGJhc2UuIFdoZW4gd2UgcmVhY2ggdGhlIGVuZCBvZiB0aGUgYmFzZSBsaXN0LCB3ZSBtdXN0IHN3aXRjaCB0b1xuICAvLyB0aGUgZGlzcGF0Y2hlciB1c2VkIGZvciBtb3VudHMuXG4gIHZhciBuZXh0Q3VycmVudEhvb2s7XG5cbiAgaWYgKGN1cnJlbnRIb29rID09PSBudWxsKSB7XG4gICAgdmFyIGN1cnJlbnQgPSBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLmFsdGVybmF0ZTtcblxuICAgIGlmIChjdXJyZW50ICE9PSBudWxsKSB7XG4gICAgICBuZXh0Q3VycmVudEhvb2sgPSBjdXJyZW50Lm1lbW9pemVkU3RhdGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5leHRDdXJyZW50SG9vayA9IG51bGw7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIG5leHRDdXJyZW50SG9vayA9IGN1cnJlbnRIb29rLm5leHQ7XG4gIH1cblxuICB2YXIgbmV4dFdvcmtJblByb2dyZXNzSG9vaztcblxuICBpZiAod29ya0luUHJvZ3Jlc3NIb29rID09PSBudWxsKSB7XG4gICAgbmV4dFdvcmtJblByb2dyZXNzSG9vayA9IGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEubWVtb2l6ZWRTdGF0ZTtcbiAgfSBlbHNlIHtcbiAgICBuZXh0V29ya0luUHJvZ3Jlc3NIb29rID0gd29ya0luUHJvZ3Jlc3NIb29rLm5leHQ7XG4gIH1cblxuICBpZiAobmV4dFdvcmtJblByb2dyZXNzSG9vayAhPT0gbnVsbCkge1xuICAgIC8vIFRoZXJlJ3MgYWxyZWFkeSBhIHdvcmstaW4tcHJvZ3Jlc3MuIFJldXNlIGl0LlxuICAgIHdvcmtJblByb2dyZXNzSG9vayA9IG5leHRXb3JrSW5Qcm9ncmVzc0hvb2s7XG4gICAgbmV4dFdvcmtJblByb2dyZXNzSG9vayA9IHdvcmtJblByb2dyZXNzSG9vay5uZXh0O1xuICAgIGN1cnJlbnRIb29rID0gbmV4dEN1cnJlbnRIb29rO1xuICB9IGVsc2Uge1xuICAgIC8vIENsb25lIGZyb20gdGhlIGN1cnJlbnQgaG9vay5cbiAgICBpZiAoIShuZXh0Q3VycmVudEhvb2sgIT09IG51bGwpKSB7XG4gICAgICB7XG4gICAgICAgIHRocm93IEVycm9yKCBcIlJlbmRlcmVkIG1vcmUgaG9va3MgdGhhbiBkdXJpbmcgdGhlIHByZXZpb3VzIHJlbmRlci5cIiApO1xuICAgICAgfVxuICAgIH1cblxuICAgIGN1cnJlbnRIb29rID0gbmV4dEN1cnJlbnRIb29rO1xuICAgIHZhciBuZXdIb29rID0ge1xuICAgICAgbWVtb2l6ZWRTdGF0ZTogY3VycmVudEhvb2subWVtb2l6ZWRTdGF0ZSxcbiAgICAgIGJhc2VTdGF0ZTogY3VycmVudEhvb2suYmFzZVN0YXRlLFxuICAgICAgYmFzZVF1ZXVlOiBjdXJyZW50SG9vay5iYXNlUXVldWUsXG4gICAgICBxdWV1ZTogY3VycmVudEhvb2sucXVldWUsXG4gICAgICBuZXh0OiBudWxsXG4gICAgfTtcblxuICAgIGlmICh3b3JrSW5Qcm9ncmVzc0hvb2sgPT09IG51bGwpIHtcbiAgICAgIC8vIFRoaXMgaXMgdGhlIGZpcnN0IGhvb2sgaW4gdGhlIGxpc3QuXG4gICAgICBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLm1lbW9pemVkU3RhdGUgPSB3b3JrSW5Qcm9ncmVzc0hvb2sgPSBuZXdIb29rO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBBcHBlbmQgdG8gdGhlIGVuZCBvZiB0aGUgbGlzdC5cbiAgICAgIHdvcmtJblByb2dyZXNzSG9vayA9IHdvcmtJblByb2dyZXNzSG9vay5uZXh0ID0gbmV3SG9vaztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gd29ya0luUHJvZ3Jlc3NIb29rO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVGdW5jdGlvbkNvbXBvbmVudFVwZGF0ZVF1ZXVlKCkge1xuICByZXR1cm4ge1xuICAgIGxhc3RFZmZlY3Q6IG51bGxcbiAgfTtcbn1cblxuZnVuY3Rpb24gYmFzaWNTdGF0ZVJlZHVjZXIoc3RhdGUsIGFjdGlvbikge1xuICAvLyAkRmxvd0ZpeE1lOiBGbG93IGRvZXNuJ3QgbGlrZSBtaXhlZCB0eXBlc1xuICByZXR1cm4gdHlwZW9mIGFjdGlvbiA9PT0gJ2Z1bmN0aW9uJyA/IGFjdGlvbihzdGF0ZSkgOiBhY3Rpb247XG59XG5cbmZ1bmN0aW9uIG1vdW50UmVkdWNlcihyZWR1Y2VyLCBpbml0aWFsQXJnLCBpbml0KSB7XG4gIHZhciBob29rID0gbW91bnRXb3JrSW5Qcm9ncmVzc0hvb2soKTtcbiAgdmFyIGluaXRpYWxTdGF0ZTtcblxuICBpZiAoaW5pdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgaW5pdGlhbFN0YXRlID0gaW5pdChpbml0aWFsQXJnKTtcbiAgfSBlbHNlIHtcbiAgICBpbml0aWFsU3RhdGUgPSBpbml0aWFsQXJnO1xuICB9XG5cbiAgaG9vay5tZW1vaXplZFN0YXRlID0gaG9vay5iYXNlU3RhdGUgPSBpbml0aWFsU3RhdGU7XG4gIHZhciBxdWV1ZSA9IGhvb2sucXVldWUgPSB7XG4gICAgcGVuZGluZzogbnVsbCxcbiAgICBkaXNwYXRjaDogbnVsbCxcbiAgICBsYXN0UmVuZGVyZWRSZWR1Y2VyOiByZWR1Y2VyLFxuICAgIGxhc3RSZW5kZXJlZFN0YXRlOiBpbml0aWFsU3RhdGVcbiAgfTtcbiAgdmFyIGRpc3BhdGNoID0gcXVldWUuZGlzcGF0Y2ggPSBkaXNwYXRjaEFjdGlvbi5iaW5kKG51bGwsIGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEsIHF1ZXVlKTtcbiAgcmV0dXJuIFtob29rLm1lbW9pemVkU3RhdGUsIGRpc3BhdGNoXTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlUmVkdWNlcihyZWR1Y2VyLCBpbml0aWFsQXJnLCBpbml0KSB7XG4gIHZhciBob29rID0gdXBkYXRlV29ya0luUHJvZ3Jlc3NIb29rKCk7XG4gIHZhciBxdWV1ZSA9IGhvb2sucXVldWU7XG5cbiAgaWYgKCEocXVldWUgIT09IG51bGwpKSB7XG4gICAge1xuICAgICAgdGhyb3cgRXJyb3IoIFwiU2hvdWxkIGhhdmUgYSBxdWV1ZS4gVGhpcyBpcyBsaWtlbHkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiICk7XG4gICAgfVxuICB9XG5cbiAgcXVldWUubGFzdFJlbmRlcmVkUmVkdWNlciA9IHJlZHVjZXI7XG4gIHZhciBjdXJyZW50ID0gY3VycmVudEhvb2s7IC8vIFRoZSBsYXN0IHJlYmFzZSB1cGRhdGUgdGhhdCBpcyBOT1QgcGFydCBvZiB0aGUgYmFzZSBzdGF0ZS5cblxuICB2YXIgYmFzZVF1ZXVlID0gY3VycmVudC5iYXNlUXVldWU7IC8vIFRoZSBsYXN0IHBlbmRpbmcgdXBkYXRlIHRoYXQgaGFzbid0IGJlZW4gcHJvY2Vzc2VkIHlldC5cblxuICB2YXIgcGVuZGluZ1F1ZXVlID0gcXVldWUucGVuZGluZztcblxuICBpZiAocGVuZGluZ1F1ZXVlICE9PSBudWxsKSB7XG4gICAgLy8gV2UgaGF2ZSBuZXcgdXBkYXRlcyB0aGF0IGhhdmVuJ3QgYmVlbiBwcm9jZXNzZWQgeWV0LlxuICAgIC8vIFdlJ2xsIGFkZCB0aGVtIHRvIHRoZSBiYXNlIHF1ZXVlLlxuICAgIGlmIChiYXNlUXVldWUgIT09IG51bGwpIHtcbiAgICAgIC8vIE1lcmdlIHRoZSBwZW5kaW5nIHF1ZXVlIGFuZCB0aGUgYmFzZSBxdWV1ZS5cbiAgICAgIHZhciBiYXNlRmlyc3QgPSBiYXNlUXVldWUubmV4dDtcbiAgICAgIHZhciBwZW5kaW5nRmlyc3QgPSBwZW5kaW5nUXVldWUubmV4dDtcbiAgICAgIGJhc2VRdWV1ZS5uZXh0ID0gcGVuZGluZ0ZpcnN0O1xuICAgICAgcGVuZGluZ1F1ZXVlLm5leHQgPSBiYXNlRmlyc3Q7XG4gICAgfVxuXG4gICAge1xuICAgICAgaWYgKGN1cnJlbnQuYmFzZVF1ZXVlICE9PSBiYXNlUXVldWUpIHtcbiAgICAgICAgLy8gSW50ZXJuYWwgaW52YXJpYW50IHRoYXQgc2hvdWxkIG5ldmVyIGhhcHBlbiwgYnV0IGZlYXNpYmx5IGNvdWxkIGluXG4gICAgICAgIC8vIHRoZSBmdXR1cmUgaWYgd2UgaW1wbGVtZW50IHJlc3VtaW5nLCBvciBzb21lIGZvcm0gb2YgdGhhdC5cbiAgICAgICAgZXJyb3IoJ0ludGVybmFsIGVycm9yOiBFeHBlY3RlZCB3b3JrLWluLXByb2dyZXNzIHF1ZXVlIHRvIGJlIGEgY2xvbmUuICcgKyAnVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC4nKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjdXJyZW50LmJhc2VRdWV1ZSA9IGJhc2VRdWV1ZSA9IHBlbmRpbmdRdWV1ZTtcbiAgICBxdWV1ZS5wZW5kaW5nID0gbnVsbDtcbiAgfVxuXG4gIGlmIChiYXNlUXVldWUgIT09IG51bGwpIHtcbiAgICAvLyBXZSBoYXZlIGEgcXVldWUgdG8gcHJvY2Vzcy5cbiAgICB2YXIgZmlyc3QgPSBiYXNlUXVldWUubmV4dDtcbiAgICB2YXIgbmV3U3RhdGUgPSBjdXJyZW50LmJhc2VTdGF0ZTtcbiAgICB2YXIgbmV3QmFzZVN0YXRlID0gbnVsbDtcbiAgICB2YXIgbmV3QmFzZVF1ZXVlRmlyc3QgPSBudWxsO1xuICAgIHZhciBuZXdCYXNlUXVldWVMYXN0ID0gbnVsbDtcbiAgICB2YXIgdXBkYXRlID0gZmlyc3Q7XG5cbiAgICBkbyB7XG4gICAgICB2YXIgdXBkYXRlTGFuZSA9IHVwZGF0ZS5sYW5lO1xuXG4gICAgICBpZiAoIWlzU3Vic2V0T2ZMYW5lcyhyZW5kZXJMYW5lcywgdXBkYXRlTGFuZSkpIHtcbiAgICAgICAgLy8gUHJpb3JpdHkgaXMgaW5zdWZmaWNpZW50LiBTa2lwIHRoaXMgdXBkYXRlLiBJZiB0aGlzIGlzIHRoZSBmaXJzdFxuICAgICAgICAvLyBza2lwcGVkIHVwZGF0ZSwgdGhlIHByZXZpb3VzIHVwZGF0ZS9zdGF0ZSBpcyB0aGUgbmV3IGJhc2VcbiAgICAgICAgLy8gdXBkYXRlL3N0YXRlLlxuICAgICAgICB2YXIgY2xvbmUgPSB7XG4gICAgICAgICAgbGFuZTogdXBkYXRlTGFuZSxcbiAgICAgICAgICBhY3Rpb246IHVwZGF0ZS5hY3Rpb24sXG4gICAgICAgICAgZWFnZXJSZWR1Y2VyOiB1cGRhdGUuZWFnZXJSZWR1Y2VyLFxuICAgICAgICAgIGVhZ2VyU3RhdGU6IHVwZGF0ZS5lYWdlclN0YXRlLFxuICAgICAgICAgIG5leHQ6IG51bGxcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAobmV3QmFzZVF1ZXVlTGFzdCA9PT0gbnVsbCkge1xuICAgICAgICAgIG5ld0Jhc2VRdWV1ZUZpcnN0ID0gbmV3QmFzZVF1ZXVlTGFzdCA9IGNsb25lO1xuICAgICAgICAgIG5ld0Jhc2VTdGF0ZSA9IG5ld1N0YXRlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5ld0Jhc2VRdWV1ZUxhc3QgPSBuZXdCYXNlUXVldWVMYXN0Lm5leHQgPSBjbG9uZTtcbiAgICAgICAgfSAvLyBVcGRhdGUgdGhlIHJlbWFpbmluZyBwcmlvcml0eSBpbiB0aGUgcXVldWUuXG4gICAgICAgIC8vIFRPRE86IERvbid0IG5lZWQgdG8gYWNjdW11bGF0ZSB0aGlzLiBJbnN0ZWFkLCB3ZSBjYW4gcmVtb3ZlXG4gICAgICAgIC8vIHJlbmRlckxhbmVzIGZyb20gdGhlIG9yaWdpbmFsIGxhbmVzLlxuXG5cbiAgICAgICAgY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMS5sYW5lcyA9IG1lcmdlTGFuZXMoY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMS5sYW5lcywgdXBkYXRlTGFuZSk7XG4gICAgICAgIG1hcmtTa2lwcGVkVXBkYXRlTGFuZXModXBkYXRlTGFuZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBUaGlzIHVwZGF0ZSBkb2VzIGhhdmUgc3VmZmljaWVudCBwcmlvcml0eS5cbiAgICAgICAgaWYgKG5ld0Jhc2VRdWV1ZUxhc3QgIT09IG51bGwpIHtcbiAgICAgICAgICB2YXIgX2Nsb25lID0ge1xuICAgICAgICAgICAgLy8gVGhpcyB1cGRhdGUgaXMgZ29pbmcgdG8gYmUgY29tbWl0dGVkIHNvIHdlIG5ldmVyIHdhbnQgdW5jb21taXRcbiAgICAgICAgICAgIC8vIGl0LiBVc2luZyBOb0xhbmUgd29ya3MgYmVjYXVzZSAwIGlzIGEgc3Vic2V0IG9mIGFsbCBiaXRtYXNrcywgc29cbiAgICAgICAgICAgIC8vIHRoaXMgd2lsbCBuZXZlciBiZSBza2lwcGVkIGJ5IHRoZSBjaGVjayBhYm92ZS5cbiAgICAgICAgICAgIGxhbmU6IE5vTGFuZSxcbiAgICAgICAgICAgIGFjdGlvbjogdXBkYXRlLmFjdGlvbixcbiAgICAgICAgICAgIGVhZ2VyUmVkdWNlcjogdXBkYXRlLmVhZ2VyUmVkdWNlcixcbiAgICAgICAgICAgIGVhZ2VyU3RhdGU6IHVwZGF0ZS5lYWdlclN0YXRlLFxuICAgICAgICAgICAgbmV4dDogbnVsbFxuICAgICAgICAgIH07XG4gICAgICAgICAgbmV3QmFzZVF1ZXVlTGFzdCA9IG5ld0Jhc2VRdWV1ZUxhc3QubmV4dCA9IF9jbG9uZTtcbiAgICAgICAgfSAvLyBQcm9jZXNzIHRoaXMgdXBkYXRlLlxuXG5cbiAgICAgICAgaWYgKHVwZGF0ZS5lYWdlclJlZHVjZXIgPT09IHJlZHVjZXIpIHtcbiAgICAgICAgICAvLyBJZiB0aGlzIHVwZGF0ZSB3YXMgcHJvY2Vzc2VkIGVhZ2VybHksIGFuZCBpdHMgcmVkdWNlciBtYXRjaGVzIHRoZVxuICAgICAgICAgIC8vIGN1cnJlbnQgcmVkdWNlciwgd2UgY2FuIHVzZSB0aGUgZWFnZXJseSBjb21wdXRlZCBzdGF0ZS5cbiAgICAgICAgICBuZXdTdGF0ZSA9IHVwZGF0ZS5lYWdlclN0YXRlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBhY3Rpb24gPSB1cGRhdGUuYWN0aW9uO1xuICAgICAgICAgIG5ld1N0YXRlID0gcmVkdWNlcihuZXdTdGF0ZSwgYWN0aW9uKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB1cGRhdGUgPSB1cGRhdGUubmV4dDtcbiAgICB9IHdoaWxlICh1cGRhdGUgIT09IG51bGwgJiYgdXBkYXRlICE9PSBmaXJzdCk7XG5cbiAgICBpZiAobmV3QmFzZVF1ZXVlTGFzdCA9PT0gbnVsbCkge1xuICAgICAgbmV3QmFzZVN0YXRlID0gbmV3U3RhdGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5ld0Jhc2VRdWV1ZUxhc3QubmV4dCA9IG5ld0Jhc2VRdWV1ZUZpcnN0O1xuICAgIH0gLy8gTWFyayB0aGF0IHRoZSBmaWJlciBwZXJmb3JtZWQgd29yaywgYnV0IG9ubHkgaWYgdGhlIG5ldyBzdGF0ZSBpc1xuICAgIC8vIGRpZmZlcmVudCBmcm9tIHRoZSBjdXJyZW50IHN0YXRlLlxuXG5cbiAgICBpZiAoIW9iamVjdElzKG5ld1N0YXRlLCBob29rLm1lbW9pemVkU3RhdGUpKSB7XG4gICAgICBtYXJrV29ya0luUHJvZ3Jlc3NSZWNlaXZlZFVwZGF0ZSgpO1xuICAgIH1cblxuICAgIGhvb2subWVtb2l6ZWRTdGF0ZSA9IG5ld1N0YXRlO1xuICAgIGhvb2suYmFzZVN0YXRlID0gbmV3QmFzZVN0YXRlO1xuICAgIGhvb2suYmFzZVF1ZXVlID0gbmV3QmFzZVF1ZXVlTGFzdDtcbiAgICBxdWV1ZS5sYXN0UmVuZGVyZWRTdGF0ZSA9IG5ld1N0YXRlO1xuICB9XG5cbiAgdmFyIGRpc3BhdGNoID0gcXVldWUuZGlzcGF0Y2g7XG4gIHJldHVybiBbaG9vay5tZW1vaXplZFN0YXRlLCBkaXNwYXRjaF07XG59XG5cbmZ1bmN0aW9uIHJlcmVuZGVyUmVkdWNlcihyZWR1Y2VyLCBpbml0aWFsQXJnLCBpbml0KSB7XG4gIHZhciBob29rID0gdXBkYXRlV29ya0luUHJvZ3Jlc3NIb29rKCk7XG4gIHZhciBxdWV1ZSA9IGhvb2sucXVldWU7XG5cbiAgaWYgKCEocXVldWUgIT09IG51bGwpKSB7XG4gICAge1xuICAgICAgdGhyb3cgRXJyb3IoIFwiU2hvdWxkIGhhdmUgYSBxdWV1ZS4gVGhpcyBpcyBsaWtlbHkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiICk7XG4gICAgfVxuICB9XG5cbiAgcXVldWUubGFzdFJlbmRlcmVkUmVkdWNlciA9IHJlZHVjZXI7IC8vIFRoaXMgaXMgYSByZS1yZW5kZXIuIEFwcGx5IHRoZSBuZXcgcmVuZGVyIHBoYXNlIHVwZGF0ZXMgdG8gdGhlIHByZXZpb3VzXG4gIC8vIHdvcmstaW4tcHJvZ3Jlc3MgaG9vay5cblxuICB2YXIgZGlzcGF0Y2ggPSBxdWV1ZS5kaXNwYXRjaDtcbiAgdmFyIGxhc3RSZW5kZXJQaGFzZVVwZGF0ZSA9IHF1ZXVlLnBlbmRpbmc7XG4gIHZhciBuZXdTdGF0ZSA9IGhvb2subWVtb2l6ZWRTdGF0ZTtcblxuICBpZiAobGFzdFJlbmRlclBoYXNlVXBkYXRlICE9PSBudWxsKSB7XG4gICAgLy8gVGhlIHF1ZXVlIGRvZXNuJ3QgcGVyc2lzdCBwYXN0IHRoaXMgcmVuZGVyIHBhc3MuXG4gICAgcXVldWUucGVuZGluZyA9IG51bGw7XG4gICAgdmFyIGZpcnN0UmVuZGVyUGhhc2VVcGRhdGUgPSBsYXN0UmVuZGVyUGhhc2VVcGRhdGUubmV4dDtcbiAgICB2YXIgdXBkYXRlID0gZmlyc3RSZW5kZXJQaGFzZVVwZGF0ZTtcblxuICAgIGRvIHtcbiAgICAgIC8vIFByb2Nlc3MgdGhpcyByZW5kZXIgcGhhc2UgdXBkYXRlLiBXZSBkb24ndCBoYXZlIHRvIGNoZWNrIHRoZVxuICAgICAgLy8gcHJpb3JpdHkgYmVjYXVzZSBpdCB3aWxsIGFsd2F5cyBiZSB0aGUgc2FtZSBhcyB0aGUgY3VycmVudFxuICAgICAgLy8gcmVuZGVyJ3MuXG4gICAgICB2YXIgYWN0aW9uID0gdXBkYXRlLmFjdGlvbjtcbiAgICAgIG5ld1N0YXRlID0gcmVkdWNlcihuZXdTdGF0ZSwgYWN0aW9uKTtcbiAgICAgIHVwZGF0ZSA9IHVwZGF0ZS5uZXh0O1xuICAgIH0gd2hpbGUgKHVwZGF0ZSAhPT0gZmlyc3RSZW5kZXJQaGFzZVVwZGF0ZSk7IC8vIE1hcmsgdGhhdCB0aGUgZmliZXIgcGVyZm9ybWVkIHdvcmssIGJ1dCBvbmx5IGlmIHRoZSBuZXcgc3RhdGUgaXNcbiAgICAvLyBkaWZmZXJlbnQgZnJvbSB0aGUgY3VycmVudCBzdGF0ZS5cblxuXG4gICAgaWYgKCFvYmplY3RJcyhuZXdTdGF0ZSwgaG9vay5tZW1vaXplZFN0YXRlKSkge1xuICAgICAgbWFya1dvcmtJblByb2dyZXNzUmVjZWl2ZWRVcGRhdGUoKTtcbiAgICB9XG5cbiAgICBob29rLm1lbW9pemVkU3RhdGUgPSBuZXdTdGF0ZTsgLy8gRG9uJ3QgcGVyc2lzdCB0aGUgc3RhdGUgYWNjdW11bGF0ZWQgZnJvbSB0aGUgcmVuZGVyIHBoYXNlIHVwZGF0ZXMgdG9cbiAgICAvLyB0aGUgYmFzZSBzdGF0ZSB1bmxlc3MgdGhlIHF1ZXVlIGlzIGVtcHR5LlxuICAgIC8vIFRPRE86IE5vdCBzdXJlIGlmIHRoaXMgaXMgdGhlIGRlc2lyZWQgc2VtYW50aWNzLCBidXQgaXQncyB3aGF0IHdlXG4gICAgLy8gZG8gZm9yIGdEU0ZQLiBJIGNhbid0IHJlbWVtYmVyIHdoeS5cblxuICAgIGlmIChob29rLmJhc2VRdWV1ZSA9PT0gbnVsbCkge1xuICAgICAgaG9vay5iYXNlU3RhdGUgPSBuZXdTdGF0ZTtcbiAgICB9XG5cbiAgICBxdWV1ZS5sYXN0UmVuZGVyZWRTdGF0ZSA9IG5ld1N0YXRlO1xuICB9XG5cbiAgcmV0dXJuIFtuZXdTdGF0ZSwgZGlzcGF0Y2hdO1xufVxuXG5mdW5jdGlvbiByZWFkRnJvbVVuc3ViY3JpYmVkTXV0YWJsZVNvdXJjZShyb290LCBzb3VyY2UsIGdldFNuYXBzaG90KSB7XG4gIHtcbiAgICB3YXJuQWJvdXRNdWx0aXBsZVJlbmRlcmVyc0RFVihzb3VyY2UpO1xuICB9XG5cbiAgdmFyIGdldFZlcnNpb24gPSBzb3VyY2UuX2dldFZlcnNpb247XG4gIHZhciB2ZXJzaW9uID0gZ2V0VmVyc2lvbihzb3VyY2UuX3NvdXJjZSk7IC8vIElzIGl0IHNhZmUgZm9yIHRoaXMgY29tcG9uZW50IHRvIHJlYWQgZnJvbSB0aGlzIHNvdXJjZSBkdXJpbmcgdGhlIGN1cnJlbnQgcmVuZGVyP1xuXG4gIHZhciBpc1NhZmVUb1JlYWRGcm9tU291cmNlID0gZmFsc2U7IC8vIENoZWNrIHRoZSB2ZXJzaW9uIGZpcnN0LlxuICAvLyBJZiB0aGlzIHJlbmRlciBoYXMgYWxyZWFkeSBiZWVuIHN0YXJ0ZWQgd2l0aCBhIHNwZWNpZmljIHZlcnNpb24sXG4gIC8vIHdlIGNhbiB1c2UgaXQgYWxvbmUgdG8gZGV0ZXJtaW5lIGlmIHdlIGNhbiBzYWZlbHkgcmVhZCBmcm9tIHRoZSBzb3VyY2UuXG5cbiAgdmFyIGN1cnJlbnRSZW5kZXJWZXJzaW9uID0gZ2V0V29ya0luUHJvZ3Jlc3NWZXJzaW9uKHNvdXJjZSk7XG5cbiAgaWYgKGN1cnJlbnRSZW5kZXJWZXJzaW9uICE9PSBudWxsKSB7XG4gICAgLy8gSXQncyBzYWZlIHRvIHJlYWQgaWYgdGhlIHN0b3JlIGhhc24ndCBiZWVuIG11dGF0ZWQgc2luY2UgdGhlIGxhc3QgdGltZVxuICAgIC8vIHdlIHJlYWQgc29tZXRoaW5nLlxuICAgIGlzU2FmZVRvUmVhZEZyb21Tb3VyY2UgPSBjdXJyZW50UmVuZGVyVmVyc2lvbiA9PT0gdmVyc2lvbjtcbiAgfSBlbHNlIHtcbiAgICAvLyBJZiB0aGVyZSdzIG5vIHZlcnNpb24sIHRoZW4gdGhpcyBpcyB0aGUgZmlyc3QgdGltZSB3ZSd2ZSByZWFkIGZyb20gdGhlXG4gICAgLy8gc291cmNlIGR1cmluZyB0aGUgY3VycmVudCByZW5kZXIgcGFzcywgc28gd2UgbmVlZCB0byBkbyBhIGJpdCBtb3JlIHdvcmsuXG4gICAgLy8gV2hhdCB3ZSBuZWVkIHRvIGRldGVybWluZSBpcyBpZiB0aGVyZSBhcmUgYW55IGhvb2tzIHRoYXQgYWxyZWFkeVxuICAgIC8vIHN1YnNjcmliZWQgdG8gdGhlIHNvdXJjZSwgYW5kIGlmIHNvLCB3aGV0aGVyIHRoZXJlIGFyZSBhbnkgcGVuZGluZ1xuICAgIC8vIG11dGF0aW9ucyB0aGF0IGhhdmVuJ3QgYmVlbiBzeW5jaHJvbml6ZWQgeWV0LlxuICAgIC8vXG4gICAgLy8gSWYgdGhlcmUgYXJlIG5vIHBlbmRpbmcgbXV0YXRpb25zLCB0aGVuIGByb290Lm11dGFibGVSZWFkTGFuZXNgIHdpbGwgYmVcbiAgICAvLyBlbXB0eSwgYW5kIHdlIGtub3cgd2UgY2FuIHNhZmVseSByZWFkLlxuICAgIC8vXG4gICAgLy8gSWYgdGhlcmUgKmFyZSogcGVuZGluZyBtdXRhdGlvbnMsIHdlIG1heSBzdGlsbCBiZSBhYmxlIHRvIHNhZmVseSByZWFkXG4gICAgLy8gaWYgdGhlIGN1cnJlbnRseSByZW5kZXJpbmcgbGFuZXMgYXJlIGluY2x1c2l2ZSBvZiB0aGUgcGVuZGluZyBtdXRhdGlvblxuICAgIC8vIGxhbmVzLCBzaW5jZSB0aGF0IGd1YXJhbnRlZXMgdGhhdCB0aGUgdmFsdWUgd2UncmUgYWJvdXQgdG8gcmVhZCBmcm9tXG4gICAgLy8gdGhlIHNvdXJjZSBpcyBjb25zaXN0ZW50IHdpdGggdGhlIHZhbHVlcyB0aGF0IHdlIHJlYWQgZHVyaW5nIHRoZSBtb3N0XG4gICAgLy8gcmVjZW50IG11dGF0aW9uLlxuICAgIGlzU2FmZVRvUmVhZEZyb21Tb3VyY2UgPSBpc1N1YnNldE9mTGFuZXMocmVuZGVyTGFuZXMsIHJvb3QubXV0YWJsZVJlYWRMYW5lcyk7XG5cbiAgICBpZiAoaXNTYWZlVG9SZWFkRnJvbVNvdXJjZSkge1xuICAgICAgLy8gSWYgaXQncyBzYWZlIHRvIHJlYWQgZnJvbSB0aGlzIHNvdXJjZSBkdXJpbmcgdGhlIGN1cnJlbnQgcmVuZGVyLFxuICAgICAgLy8gc3RvcmUgdGhlIHZlcnNpb24gaW4gY2FzZSBvdGhlciBjb21wb25lbnRzIHJlYWQgZnJvbSBpdC5cbiAgICAgIC8vIEEgY2hhbmdlZCB2ZXJzaW9uIG51bWJlciB3aWxsIGxldCB0aG9zZSBjb21wb25lbnRzIGtub3cgdG8gdGhyb3cgYW5kIHJlc3RhcnQgdGhlIHJlbmRlci5cbiAgICAgIHNldFdvcmtJblByb2dyZXNzVmVyc2lvbihzb3VyY2UsIHZlcnNpb24pO1xuICAgIH1cbiAgfVxuXG4gIGlmIChpc1NhZmVUb1JlYWRGcm9tU291cmNlKSB7XG4gICAgdmFyIHNuYXBzaG90ID0gZ2V0U25hcHNob3Qoc291cmNlLl9zb3VyY2UpO1xuXG4gICAge1xuICAgICAgaWYgKHR5cGVvZiBzbmFwc2hvdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBlcnJvcignTXV0YWJsZSBzb3VyY2Ugc2hvdWxkIG5vdCByZXR1cm4gYSBmdW5jdGlvbiBhcyB0aGUgc25hcHNob3QgdmFsdWUuICcgKyAnRnVuY3Rpb25zIG1heSBjbG9zZSBvdmVyIG11dGFibGUgdmFsdWVzIGFuZCBjYXVzZSB0ZWFyaW5nLicpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBzbmFwc2hvdDtcbiAgfSBlbHNlIHtcbiAgICAvLyBUaGlzIGhhbmRsZXMgdGhlIHNwZWNpYWwgY2FzZSBvZiBhIG11dGFibGUgc291cmNlIGJlaW5nIHNoYXJlZCBiZXR3ZWVuIHJlbmRlcmVycy5cbiAgICAvLyBJbiB0aGF0IGNhc2UsIGlmIHRoZSBzb3VyY2UgaXMgbXV0YXRlZCBiZXR3ZWVuIHRoZSBmaXJzdCBhbmQgc2Vjb25kIHJlbmRlcmVyLFxuICAgIC8vIFRoZSBzZWNvbmQgcmVuZGVyZXIgZG9uJ3Qga25vdyB0aGF0IGl0IG5lZWRzIHRvIHJlc2V0IHRoZSBXSVAgdmVyc2lvbiBkdXJpbmcgdW53aW5kLFxuICAgIC8vIChiZWNhdXNlIHRoZSBob29rIG9ubHkgbWFya3Mgc291cmNlcyBhcyBkaXJ0eSBpZiBpdCdzIHdyaXR0ZW4gdG8gdGhlaXIgV0lQIHZlcnNpb24pLlxuICAgIC8vIFRoYXQgd291bGQgY2F1c2UgdGhpcyB0ZWFyIGNoZWNrIHRvIHRocm93IGFnYWluIGFuZCBldmVudHVhbGx5IGJlIHZpc2libGUgdG8gdGhlIHVzZXIuXG4gICAgLy8gV2UgY2FuIGF2b2lkIHRoaXMgaW5maW5pdGUgbG9vcCBieSBleHBsaWNpdGx5IG1hcmtpbmcgdGhlIHNvdXJjZSBhcyBkaXJ0eS5cbiAgICAvL1xuICAgIC8vIFRoaXMgY2FuIGxlYWQgdG8gdGVhcmluZyBpbiB0aGUgZmlyc3QgcmVuZGVyZXIgd2hlbiBpdCByZXN1bWVzLFxuICAgIC8vIGJ1dCB0aGVyZSdzIG5vdGhpbmcgd2UgY2FuIGRvIGFib3V0IHRoYXQgKHNob3J0IG9mIHRocm93aW5nIGhlcmUgYW5kIHJlZnVzaW5nIHRvIGNvbnRpbnVlIHRoZSByZW5kZXIpLlxuICAgIG1hcmtTb3VyY2VBc0RpcnR5KHNvdXJjZSk7XG5cbiAgICB7XG4gICAgICB7XG4gICAgICAgIHRocm93IEVycm9yKCBcIkNhbm5vdCByZWFkIGZyb20gbXV0YWJsZSBzb3VyY2UgZHVyaW5nIHRoZSBjdXJyZW50IHJlbmRlciB3aXRob3V0IHRlYXJpbmcuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiICk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHVzZU11dGFibGVTb3VyY2UoaG9vaywgc291cmNlLCBnZXRTbmFwc2hvdCwgc3Vic2NyaWJlKSB7XG4gIHZhciByb290ID0gZ2V0V29ya0luUHJvZ3Jlc3NSb290KCk7XG5cbiAgaWYgKCEocm9vdCAhPT0gbnVsbCkpIHtcbiAgICB7XG4gICAgICB0aHJvdyBFcnJvciggXCJFeHBlY3RlZCBhIHdvcmstaW4tcHJvZ3Jlc3Mgcm9vdC4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCIgKTtcbiAgICB9XG4gIH1cblxuICB2YXIgZ2V0VmVyc2lvbiA9IHNvdXJjZS5fZ2V0VmVyc2lvbjtcbiAgdmFyIHZlcnNpb24gPSBnZXRWZXJzaW9uKHNvdXJjZS5fc291cmNlKTtcbiAgdmFyIGRpc3BhdGNoZXIgPSBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudDsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHByZWZlci1jb25zdFxuXG4gIHZhciBfZGlzcGF0Y2hlciR1c2VTdGF0ZSA9IGRpc3BhdGNoZXIudXNlU3RhdGUoZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiByZWFkRnJvbVVuc3ViY3JpYmVkTXV0YWJsZVNvdXJjZShyb290LCBzb3VyY2UsIGdldFNuYXBzaG90KTtcbiAgfSksXG4gICAgICBjdXJyZW50U25hcHNob3QgPSBfZGlzcGF0Y2hlciR1c2VTdGF0ZVswXSxcbiAgICAgIHNldFNuYXBzaG90ID0gX2Rpc3BhdGNoZXIkdXNlU3RhdGVbMV07XG5cbiAgdmFyIHNuYXBzaG90ID0gY3VycmVudFNuYXBzaG90OyAvLyBHcmFiIGEgaGFuZGxlIHRvIHRoZSBzdGF0ZSBob29rIGFzIHdlbGwuXG4gIC8vIFdlIHVzZSBpdCB0byBjbGVhciB0aGUgcGVuZGluZyB1cGRhdGUgcXVldWUgaWYgd2UgaGF2ZSBhIG5ldyBzb3VyY2UuXG5cbiAgdmFyIHN0YXRlSG9vayA9IHdvcmtJblByb2dyZXNzSG9vaztcbiAgdmFyIG1lbW9pemVkU3RhdGUgPSBob29rLm1lbW9pemVkU3RhdGU7XG4gIHZhciByZWZzID0gbWVtb2l6ZWRTdGF0ZS5yZWZzO1xuICB2YXIgcHJldkdldFNuYXBzaG90ID0gcmVmcy5nZXRTbmFwc2hvdDtcbiAgdmFyIHByZXZTb3VyY2UgPSBtZW1vaXplZFN0YXRlLnNvdXJjZTtcbiAgdmFyIHByZXZTdWJzY3JpYmUgPSBtZW1vaXplZFN0YXRlLnN1YnNjcmliZTtcbiAgdmFyIGZpYmVyID0gY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMTtcbiAgaG9vay5tZW1vaXplZFN0YXRlID0ge1xuICAgIHJlZnM6IHJlZnMsXG4gICAgc291cmNlOiBzb3VyY2UsXG4gICAgc3Vic2NyaWJlOiBzdWJzY3JpYmVcbiAgfTsgLy8gU3luYyB0aGUgdmFsdWVzIG5lZWRlZCBieSBvdXIgc3Vic2NyaXB0aW9uIGhhbmRsZXIgYWZ0ZXIgZWFjaCBjb21taXQuXG5cbiAgZGlzcGF0Y2hlci51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIHJlZnMuZ2V0U25hcHNob3QgPSBnZXRTbmFwc2hvdDsgLy8gTm9ybWFsbHkgdGhlIGRpc3BhdGNoIGZ1bmN0aW9uIGZvciBhIHN0YXRlIGhvb2sgbmV2ZXIgY2hhbmdlcyxcbiAgICAvLyBidXQgdGhpcyBob29rIHJlY3JlYXRlcyB0aGUgcXVldWUgaW4gY2VydGFpbiBjYXNlcyAgdG8gYXZvaWQgdXBkYXRlcyBmcm9tIHN0YWxlIHNvdXJjZXMuXG4gICAgLy8gaGFuZGxlQ2hhbmdlKCkgYmVsb3cgbmVlZHMgdG8gcmVmZXJlbmNlIHRoZSBkaXNwYXRjaCBmdW5jdGlvbiB3aXRob3V0IHJlLXN1YnNjcmliaW5nLFxuICAgIC8vIHNvIHdlIHVzZSBhIHJlZiB0byBlbnN1cmUgdGhhdCBpdCBhbHdheXMgaGFzIHRoZSBsYXRlc3QgdmVyc2lvbi5cblxuICAgIHJlZnMuc2V0U25hcHNob3QgPSBzZXRTbmFwc2hvdDsgLy8gQ2hlY2sgZm9yIGEgcG9zc2libGUgY2hhbmdlIGJldHdlZW4gd2hlbiB3ZSBsYXN0IHJlbmRlcmVkIG5vdy5cblxuICAgIHZhciBtYXliZU5ld1ZlcnNpb24gPSBnZXRWZXJzaW9uKHNvdXJjZS5fc291cmNlKTtcblxuICAgIGlmICghb2JqZWN0SXModmVyc2lvbiwgbWF5YmVOZXdWZXJzaW9uKSkge1xuICAgICAgdmFyIG1heWJlTmV3U25hcHNob3QgPSBnZXRTbmFwc2hvdChzb3VyY2UuX3NvdXJjZSk7XG5cbiAgICAgIHtcbiAgICAgICAgaWYgKHR5cGVvZiBtYXliZU5ld1NuYXBzaG90ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgZXJyb3IoJ011dGFibGUgc291cmNlIHNob3VsZCBub3QgcmV0dXJuIGEgZnVuY3Rpb24gYXMgdGhlIHNuYXBzaG90IHZhbHVlLiAnICsgJ0Z1bmN0aW9ucyBtYXkgY2xvc2Ugb3ZlciBtdXRhYmxlIHZhbHVlcyBhbmQgY2F1c2UgdGVhcmluZy4nKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoIW9iamVjdElzKHNuYXBzaG90LCBtYXliZU5ld1NuYXBzaG90KSkge1xuICAgICAgICBzZXRTbmFwc2hvdChtYXliZU5ld1NuYXBzaG90KTtcbiAgICAgICAgdmFyIGxhbmUgPSByZXF1ZXN0VXBkYXRlTGFuZShmaWJlcik7XG4gICAgICAgIG1hcmtSb290TXV0YWJsZVJlYWQocm9vdCwgbGFuZSk7XG4gICAgICB9IC8vIElmIHRoZSBzb3VyY2UgbXV0YXRlZCBiZXR3ZWVuIHJlbmRlciBhbmQgbm93LFxuICAgICAgLy8gdGhlcmUgbWF5IGJlIHN0YXRlIHVwZGF0ZXMgYWxyZWFkeSBzY2hlZHVsZWQgZnJvbSB0aGUgb2xkIHNvdXJjZS5cbiAgICAgIC8vIEVudGFuZ2xlIHRoZSB1cGRhdGVzIHNvIHRoYXQgdGhleSByZW5kZXIgaW4gdGhlIHNhbWUgYmF0Y2guXG5cblxuICAgICAgbWFya1Jvb3RFbnRhbmdsZWQocm9vdCwgcm9vdC5tdXRhYmxlUmVhZExhbmVzKTtcbiAgICB9XG4gIH0sIFtnZXRTbmFwc2hvdCwgc291cmNlLCBzdWJzY3JpYmVdKTsgLy8gSWYgd2UgZ290IGEgbmV3IHNvdXJjZSBvciBzdWJzY3JpYmUgZnVuY3Rpb24sIHJlLXN1YnNjcmliZSBpbiBhIHBhc3NpdmUgZWZmZWN0LlxuXG4gIGRpc3BhdGNoZXIudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgaGFuZGxlQ2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGxhdGVzdEdldFNuYXBzaG90ID0gcmVmcy5nZXRTbmFwc2hvdDtcbiAgICAgIHZhciBsYXRlc3RTZXRTbmFwc2hvdCA9IHJlZnMuc2V0U25hcHNob3Q7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGxhdGVzdFNldFNuYXBzaG90KGxhdGVzdEdldFNuYXBzaG90KHNvdXJjZS5fc291cmNlKSk7IC8vIFJlY29yZCBhIHBlbmRpbmcgbXV0YWJsZSBzb3VyY2UgdXBkYXRlIHdpdGggdGhlIHNhbWUgZXhwaXJhdGlvbiB0aW1lLlxuXG4gICAgICAgIHZhciBsYW5lID0gcmVxdWVzdFVwZGF0ZUxhbmUoZmliZXIpO1xuICAgICAgICBtYXJrUm9vdE11dGFibGVSZWFkKHJvb3QsIGxhbmUpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgLy8gQSBzZWxlY3RvciBtaWdodCB0aHJvdyBhZnRlciBhIHNvdXJjZSBtdXRhdGlvbi5cbiAgICAgICAgLy8gZS5nLiBpdCBtaWdodCB0cnkgdG8gcmVhZCBmcm9tIGEgcGFydCBvZiB0aGUgc3RvcmUgdGhhdCBubyBsb25nZXIgZXhpc3RzLlxuICAgICAgICAvLyBJbiB0aGlzIGNhc2Ugd2Ugc2hvdWxkIHN0aWxsIHNjaGVkdWxlIGFuIHVwZGF0ZSB3aXRoIFJlYWN0LlxuICAgICAgICAvLyBXb3JzdCBjYXNlIHRoZSBzZWxlY3RvciB3aWxsIHRocm93IGFnYWluIGFuZCB0aGVuIGFuIGVycm9yIGJvdW5kYXJ5IHdpbGwgaGFuZGxlIGl0LlxuICAgICAgICBsYXRlc3RTZXRTbmFwc2hvdChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgdW5zdWJzY3JpYmUgPSBzdWJzY3JpYmUoc291cmNlLl9zb3VyY2UsIGhhbmRsZUNoYW5nZSk7XG5cbiAgICB7XG4gICAgICBpZiAodHlwZW9mIHVuc3Vic2NyaWJlICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGVycm9yKCdNdXRhYmxlIHNvdXJjZSBzdWJzY3JpYmUgZnVuY3Rpb24gbXVzdCByZXR1cm4gYW4gdW5zdWJzY3JpYmUgZnVuY3Rpb24uJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHVuc3Vic2NyaWJlO1xuICB9LCBbc291cmNlLCBzdWJzY3JpYmVdKTsgLy8gSWYgYW55IG9mIHRoZSBpbnB1dHMgdG8gdXNlTXV0YWJsZVNvdXJjZSBjaGFuZ2UsIHJlYWRpbmcgaXMgcG90ZW50aWFsbHkgdW5zYWZlLlxuICAvL1xuICAvLyBJZiBlaXRoZXIgdGhlIHNvdXJjZSBvciB0aGUgc3Vic2NyaXB0aW9uIGhhdmUgY2hhbmdlZCB3ZSBjYW4ndCBjYW4ndCB0cnVzdCB0aGUgdXBkYXRlIHF1ZXVlLlxuICAvLyBNYXliZSB0aGUgc291cmNlIGNoYW5nZWQgaW4gYSB3YXkgdGhhdCB0aGUgb2xkIHN1YnNjcmlwdGlvbiBpZ25vcmVkIGJ1dCB0aGUgbmV3IG9uZSBkZXBlbmRzIG9uLlxuICAvL1xuICAvLyBJZiB0aGUgZ2V0U25hcHNob3QgZnVuY3Rpb24gY2hhbmdlZCwgd2UgYWxzbyBzaG91bGRuJ3QgcmVseSBvbiB0aGUgdXBkYXRlIHF1ZXVlLlxuICAvLyBJdCdzIHBvc3NpYmxlIHRoYXQgdGhlIHVuZGVybHlpbmcgc291cmNlIHdhcyBtdXRhdGVkIGJldHdlZW4gdGhlIHdoZW4gdGhlIGxhc3QgXCJjaGFuZ2VcIiBldmVudCBmaXJlZCxcbiAgLy8gYW5kIHdoZW4gdGhlIGN1cnJlbnQgcmVuZGVyICh3aXRoIHRoZSBuZXcgZ2V0U25hcHNob3QgZnVuY3Rpb24pIGlzIHByb2Nlc3NlZC5cbiAgLy9cbiAgLy8gSW4gYm90aCBjYXNlcywgd2UgbmVlZCB0byB0aHJvdyBhd2F5IHBlbmRpbmcgdXBkYXRlcyAoc2luY2UgdGhleSBhcmUgbm8gbG9uZ2VyIHJlbGV2YW50KVxuICAvLyBhbmQgdHJlYXQgcmVhZGluZyBmcm9tIHRoZSBzb3VyY2UgYXMgd2UgZG8gaW4gdGhlIG1vdW50IGNhc2UuXG5cbiAgaWYgKCFvYmplY3RJcyhwcmV2R2V0U25hcHNob3QsIGdldFNuYXBzaG90KSB8fCAhb2JqZWN0SXMocHJldlNvdXJjZSwgc291cmNlKSB8fCAhb2JqZWN0SXMocHJldlN1YnNjcmliZSwgc3Vic2NyaWJlKSkge1xuICAgIC8vIENyZWF0ZSBhIG5ldyBxdWV1ZSBhbmQgc2V0U3RhdGUgbWV0aG9kLFxuICAgIC8vIFNvIGlmIHRoZXJlIGFyZSBpbnRlcmxlYXZlZCB1cGRhdGVzLCB0aGV5IGdldCBwdXNoZWQgdG8gdGhlIG9sZGVyIHF1ZXVlLlxuICAgIC8vIFdoZW4gdGhpcyBiZWNvbWVzIGN1cnJlbnQsIHRoZSBwcmV2aW91cyBxdWV1ZSBhbmQgZGlzcGF0Y2ggbWV0aG9kIHdpbGwgYmUgZGlzY2FyZGVkLFxuICAgIC8vIGluY2x1ZGluZyBhbnkgaW50ZXJsZWF2aW5nIHVwZGF0ZXMgdGhhdCBvY2N1ci5cbiAgICB2YXIgbmV3UXVldWUgPSB7XG4gICAgICBwZW5kaW5nOiBudWxsLFxuICAgICAgZGlzcGF0Y2g6IG51bGwsXG4gICAgICBsYXN0UmVuZGVyZWRSZWR1Y2VyOiBiYXNpY1N0YXRlUmVkdWNlcixcbiAgICAgIGxhc3RSZW5kZXJlZFN0YXRlOiBzbmFwc2hvdFxuICAgIH07XG4gICAgbmV3UXVldWUuZGlzcGF0Y2ggPSBzZXRTbmFwc2hvdCA9IGRpc3BhdGNoQWN0aW9uLmJpbmQobnVsbCwgY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMSwgbmV3UXVldWUpO1xuICAgIHN0YXRlSG9vay5xdWV1ZSA9IG5ld1F1ZXVlO1xuICAgIHN0YXRlSG9vay5iYXNlUXVldWUgPSBudWxsO1xuICAgIHNuYXBzaG90ID0gcmVhZEZyb21VbnN1YmNyaWJlZE11dGFibGVTb3VyY2Uocm9vdCwgc291cmNlLCBnZXRTbmFwc2hvdCk7XG4gICAgc3RhdGVIb29rLm1lbW9pemVkU3RhdGUgPSBzdGF0ZUhvb2suYmFzZVN0YXRlID0gc25hcHNob3Q7XG4gIH1cblxuICByZXR1cm4gc25hcHNob3Q7XG59XG5cbmZ1bmN0aW9uIG1vdW50TXV0YWJsZVNvdXJjZShzb3VyY2UsIGdldFNuYXBzaG90LCBzdWJzY3JpYmUpIHtcbiAgdmFyIGhvb2sgPSBtb3VudFdvcmtJblByb2dyZXNzSG9vaygpO1xuICBob29rLm1lbW9pemVkU3RhdGUgPSB7XG4gICAgcmVmczoge1xuICAgICAgZ2V0U25hcHNob3Q6IGdldFNuYXBzaG90LFxuICAgICAgc2V0U25hcHNob3Q6IG51bGxcbiAgICB9LFxuICAgIHNvdXJjZTogc291cmNlLFxuICAgIHN1YnNjcmliZTogc3Vic2NyaWJlXG4gIH07XG4gIHJldHVybiB1c2VNdXRhYmxlU291cmNlKGhvb2ssIHNvdXJjZSwgZ2V0U25hcHNob3QsIHN1YnNjcmliZSk7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZU11dGFibGVTb3VyY2Uoc291cmNlLCBnZXRTbmFwc2hvdCwgc3Vic2NyaWJlKSB7XG4gIHZhciBob29rID0gdXBkYXRlV29ya0luUHJvZ3Jlc3NIb29rKCk7XG4gIHJldHVybiB1c2VNdXRhYmxlU291cmNlKGhvb2ssIHNvdXJjZSwgZ2V0U25hcHNob3QsIHN1YnNjcmliZSk7XG59XG5cbmZ1bmN0aW9uIG1vdW50U3RhdGUoaW5pdGlhbFN0YXRlKSB7XG4gIHZhciBob29rID0gbW91bnRXb3JrSW5Qcm9ncmVzc0hvb2soKTtcblxuICBpZiAodHlwZW9mIGluaXRpYWxTdGF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIC8vICRGbG93Rml4TWU6IEZsb3cgZG9lc24ndCBsaWtlIG1peGVkIHR5cGVzXG4gICAgaW5pdGlhbFN0YXRlID0gaW5pdGlhbFN0YXRlKCk7XG4gIH1cblxuICBob29rLm1lbW9pemVkU3RhdGUgPSBob29rLmJhc2VTdGF0ZSA9IGluaXRpYWxTdGF0ZTtcbiAgdmFyIHF1ZXVlID0gaG9vay5xdWV1ZSA9IHtcbiAgICBwZW5kaW5nOiBudWxsLFxuICAgIGRpc3BhdGNoOiBudWxsLFxuICAgIGxhc3RSZW5kZXJlZFJlZHVjZXI6IGJhc2ljU3RhdGVSZWR1Y2VyLFxuICAgIGxhc3RSZW5kZXJlZFN0YXRlOiBpbml0aWFsU3RhdGVcbiAgfTtcbiAgdmFyIGRpc3BhdGNoID0gcXVldWUuZGlzcGF0Y2ggPSBkaXNwYXRjaEFjdGlvbi5iaW5kKG51bGwsIGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEsIHF1ZXVlKTtcbiAgcmV0dXJuIFtob29rLm1lbW9pemVkU3RhdGUsIGRpc3BhdGNoXTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlU3RhdGUoaW5pdGlhbFN0YXRlKSB7XG4gIHJldHVybiB1cGRhdGVSZWR1Y2VyKGJhc2ljU3RhdGVSZWR1Y2VyKTtcbn1cblxuZnVuY3Rpb24gcmVyZW5kZXJTdGF0ZShpbml0aWFsU3RhdGUpIHtcbiAgcmV0dXJuIHJlcmVuZGVyUmVkdWNlcihiYXNpY1N0YXRlUmVkdWNlcik7XG59XG5cbmZ1bmN0aW9uIHB1c2hFZmZlY3QodGFnLCBjcmVhdGUsIGRlc3Ryb3ksIGRlcHMpIHtcbiAgdmFyIGVmZmVjdCA9IHtcbiAgICB0YWc6IHRhZyxcbiAgICBjcmVhdGU6IGNyZWF0ZSxcbiAgICBkZXN0cm95OiBkZXN0cm95LFxuICAgIGRlcHM6IGRlcHMsXG4gICAgLy8gQ2lyY3VsYXJcbiAgICBuZXh0OiBudWxsXG4gIH07XG4gIHZhciBjb21wb25lbnRVcGRhdGVRdWV1ZSA9IGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEudXBkYXRlUXVldWU7XG5cbiAgaWYgKGNvbXBvbmVudFVwZGF0ZVF1ZXVlID09PSBudWxsKSB7XG4gICAgY29tcG9uZW50VXBkYXRlUXVldWUgPSBjcmVhdGVGdW5jdGlvbkNvbXBvbmVudFVwZGF0ZVF1ZXVlKCk7XG4gICAgY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMS51cGRhdGVRdWV1ZSA9IGNvbXBvbmVudFVwZGF0ZVF1ZXVlO1xuICAgIGNvbXBvbmVudFVwZGF0ZVF1ZXVlLmxhc3RFZmZlY3QgPSBlZmZlY3QubmV4dCA9IGVmZmVjdDtcbiAgfSBlbHNlIHtcbiAgICB2YXIgbGFzdEVmZmVjdCA9IGNvbXBvbmVudFVwZGF0ZVF1ZXVlLmxhc3RFZmZlY3Q7XG5cbiAgICBpZiAobGFzdEVmZmVjdCA9PT0gbnVsbCkge1xuICAgICAgY29tcG9uZW50VXBkYXRlUXVldWUubGFzdEVmZmVjdCA9IGVmZmVjdC5uZXh0ID0gZWZmZWN0O1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgZmlyc3RFZmZlY3QgPSBsYXN0RWZmZWN0Lm5leHQ7XG4gICAgICBsYXN0RWZmZWN0Lm5leHQgPSBlZmZlY3Q7XG4gICAgICBlZmZlY3QubmV4dCA9IGZpcnN0RWZmZWN0O1xuICAgICAgY29tcG9uZW50VXBkYXRlUXVldWUubGFzdEVmZmVjdCA9IGVmZmVjdDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZWZmZWN0O1xufVxuXG5mdW5jdGlvbiBtb3VudFJlZihpbml0aWFsVmFsdWUpIHtcbiAgdmFyIGhvb2sgPSBtb3VudFdvcmtJblByb2dyZXNzSG9vaygpO1xuICB2YXIgcmVmID0ge1xuICAgIGN1cnJlbnQ6IGluaXRpYWxWYWx1ZVxuICB9O1xuXG4gIHtcbiAgICBPYmplY3Quc2VhbChyZWYpO1xuICB9XG5cbiAgaG9vay5tZW1vaXplZFN0YXRlID0gcmVmO1xuICByZXR1cm4gcmVmO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVSZWYoaW5pdGlhbFZhbHVlKSB7XG4gIHZhciBob29rID0gdXBkYXRlV29ya0luUHJvZ3Jlc3NIb29rKCk7XG4gIHJldHVybiBob29rLm1lbW9pemVkU3RhdGU7XG59XG5cbmZ1bmN0aW9uIG1vdW50RWZmZWN0SW1wbChmaWJlckZsYWdzLCBob29rRmxhZ3MsIGNyZWF0ZSwgZGVwcykge1xuICB2YXIgaG9vayA9IG1vdW50V29ya0luUHJvZ3Jlc3NIb29rKCk7XG4gIHZhciBuZXh0RGVwcyA9IGRlcHMgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBkZXBzO1xuICBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLmZsYWdzIHw9IGZpYmVyRmxhZ3M7XG4gIGhvb2subWVtb2l6ZWRTdGF0ZSA9IHB1c2hFZmZlY3QoSGFzRWZmZWN0IHwgaG9va0ZsYWdzLCBjcmVhdGUsIHVuZGVmaW5lZCwgbmV4dERlcHMpO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVFZmZlY3RJbXBsKGZpYmVyRmxhZ3MsIGhvb2tGbGFncywgY3JlYXRlLCBkZXBzKSB7XG4gIHZhciBob29rID0gdXBkYXRlV29ya0luUHJvZ3Jlc3NIb29rKCk7XG4gIHZhciBuZXh0RGVwcyA9IGRlcHMgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBkZXBzO1xuICB2YXIgZGVzdHJveSA9IHVuZGVmaW5lZDtcblxuICBpZiAoY3VycmVudEhvb2sgIT09IG51bGwpIHtcbiAgICB2YXIgcHJldkVmZmVjdCA9IGN1cnJlbnRIb29rLm1lbW9pemVkU3RhdGU7XG4gICAgZGVzdHJveSA9IHByZXZFZmZlY3QuZGVzdHJveTtcblxuICAgIGlmIChuZXh0RGVwcyAhPT0gbnVsbCkge1xuICAgICAgdmFyIHByZXZEZXBzID0gcHJldkVmZmVjdC5kZXBzO1xuXG4gICAgICBpZiAoYXJlSG9va0lucHV0c0VxdWFsKG5leHREZXBzLCBwcmV2RGVwcykpIHtcbiAgICAgICAgcHVzaEVmZmVjdChob29rRmxhZ3MsIGNyZWF0ZSwgZGVzdHJveSwgbmV4dERlcHMpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMS5mbGFncyB8PSBmaWJlckZsYWdzO1xuICBob29rLm1lbW9pemVkU3RhdGUgPSBwdXNoRWZmZWN0KEhhc0VmZmVjdCB8IGhvb2tGbGFncywgY3JlYXRlLCBkZXN0cm95LCBuZXh0RGVwcyk7XG59XG5cbmZ1bmN0aW9uIG1vdW50RWZmZWN0KGNyZWF0ZSwgZGVwcykge1xuICB7XG4gICAgLy8gJEZsb3dFeHBlY3RlZEVycm9yIC0gamVzdCBpc24ndCBhIGdsb2JhbCwgYW5kIGlzbid0IHJlY29nbml6ZWQgb3V0c2lkZSBvZiB0ZXN0c1xuICAgIGlmICgndW5kZWZpbmVkJyAhPT0gdHlwZW9mIGplc3QpIHtcbiAgICAgIHdhcm5JZk5vdEN1cnJlbnRseUFjdGluZ0VmZmVjdHNJbkRFVihjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbW91bnRFZmZlY3RJbXBsKFVwZGF0ZSB8IFBhc3NpdmUsIFBhc3NpdmUkMSwgY3JlYXRlLCBkZXBzKTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlRWZmZWN0KGNyZWF0ZSwgZGVwcykge1xuICB7XG4gICAgLy8gJEZsb3dFeHBlY3RlZEVycm9yIC0gamVzdCBpc24ndCBhIGdsb2JhbCwgYW5kIGlzbid0IHJlY29nbml6ZWQgb3V0c2lkZSBvZiB0ZXN0c1xuICAgIGlmICgndW5kZWZpbmVkJyAhPT0gdHlwZW9mIGplc3QpIHtcbiAgICAgIHdhcm5JZk5vdEN1cnJlbnRseUFjdGluZ0VmZmVjdHNJbkRFVihjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdXBkYXRlRWZmZWN0SW1wbChVcGRhdGUgfCBQYXNzaXZlLCBQYXNzaXZlJDEsIGNyZWF0ZSwgZGVwcyk7XG59XG5cbmZ1bmN0aW9uIG1vdW50TGF5b3V0RWZmZWN0KGNyZWF0ZSwgZGVwcykge1xuICByZXR1cm4gbW91bnRFZmZlY3RJbXBsKFVwZGF0ZSwgTGF5b3V0LCBjcmVhdGUsIGRlcHMpO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVMYXlvdXRFZmZlY3QoY3JlYXRlLCBkZXBzKSB7XG4gIHJldHVybiB1cGRhdGVFZmZlY3RJbXBsKFVwZGF0ZSwgTGF5b3V0LCBjcmVhdGUsIGRlcHMpO1xufVxuXG5mdW5jdGlvbiBpbXBlcmF0aXZlSGFuZGxlRWZmZWN0KGNyZWF0ZSwgcmVmKSB7XG4gIGlmICh0eXBlb2YgcmVmID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdmFyIHJlZkNhbGxiYWNrID0gcmVmO1xuXG4gICAgdmFyIF9pbnN0ID0gY3JlYXRlKCk7XG5cbiAgICByZWZDYWxsYmFjayhfaW5zdCk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJlZkNhbGxiYWNrKG51bGwpO1xuICAgIH07XG4gIH0gZWxzZSBpZiAocmVmICE9PSBudWxsICYmIHJlZiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdmFyIHJlZk9iamVjdCA9IHJlZjtcblxuICAgIHtcbiAgICAgIGlmICghcmVmT2JqZWN0Lmhhc093blByb3BlcnR5KCdjdXJyZW50JykpIHtcbiAgICAgICAgZXJyb3IoJ0V4cGVjdGVkIHVzZUltcGVyYXRpdmVIYW5kbGUoKSBmaXJzdCBhcmd1bWVudCB0byBlaXRoZXIgYmUgYSAnICsgJ3JlZiBjYWxsYmFjayBvciBSZWFjdC5jcmVhdGVSZWYoKSBvYmplY3QuIEluc3RlYWQgcmVjZWl2ZWQ6ICVzLicsICdhbiBvYmplY3Qgd2l0aCBrZXlzIHsnICsgT2JqZWN0LmtleXMocmVmT2JqZWN0KS5qb2luKCcsICcpICsgJ30nKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgX2luc3QyID0gY3JlYXRlKCk7XG5cbiAgICByZWZPYmplY3QuY3VycmVudCA9IF9pbnN0MjtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgcmVmT2JqZWN0LmN1cnJlbnQgPSBudWxsO1xuICAgIH07XG4gIH1cbn1cblxuZnVuY3Rpb24gbW91bnRJbXBlcmF0aXZlSGFuZGxlKHJlZiwgY3JlYXRlLCBkZXBzKSB7XG4gIHtcbiAgICBpZiAodHlwZW9mIGNyZWF0ZSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgZXJyb3IoJ0V4cGVjdGVkIHVzZUltcGVyYXRpdmVIYW5kbGUoKSBzZWNvbmQgYXJndW1lbnQgdG8gYmUgYSBmdW5jdGlvbiAnICsgJ3RoYXQgY3JlYXRlcyBhIGhhbmRsZS4gSW5zdGVhZCByZWNlaXZlZDogJXMuJywgY3JlYXRlICE9PSBudWxsID8gdHlwZW9mIGNyZWF0ZSA6ICdudWxsJyk7XG4gICAgfVxuICB9IC8vIFRPRE86IElmIGRlcHMgYXJlIHByb3ZpZGVkLCBzaG91bGQgd2Ugc2tpcCBjb21wYXJpbmcgdGhlIHJlZiBpdHNlbGY/XG5cblxuICB2YXIgZWZmZWN0RGVwcyA9IGRlcHMgIT09IG51bGwgJiYgZGVwcyAhPT0gdW5kZWZpbmVkID8gZGVwcy5jb25jYXQoW3JlZl0pIDogbnVsbDtcbiAgcmV0dXJuIG1vdW50RWZmZWN0SW1wbChVcGRhdGUsIExheW91dCwgaW1wZXJhdGl2ZUhhbmRsZUVmZmVjdC5iaW5kKG51bGwsIGNyZWF0ZSwgcmVmKSwgZWZmZWN0RGVwcyk7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUltcGVyYXRpdmVIYW5kbGUocmVmLCBjcmVhdGUsIGRlcHMpIHtcbiAge1xuICAgIGlmICh0eXBlb2YgY3JlYXRlICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICBlcnJvcignRXhwZWN0ZWQgdXNlSW1wZXJhdGl2ZUhhbmRsZSgpIHNlY29uZCBhcmd1bWVudCB0byBiZSBhIGZ1bmN0aW9uICcgKyAndGhhdCBjcmVhdGVzIGEgaGFuZGxlLiBJbnN0ZWFkIHJlY2VpdmVkOiAlcy4nLCBjcmVhdGUgIT09IG51bGwgPyB0eXBlb2YgY3JlYXRlIDogJ251bGwnKTtcbiAgICB9XG4gIH0gLy8gVE9ETzogSWYgZGVwcyBhcmUgcHJvdmlkZWQsIHNob3VsZCB3ZSBza2lwIGNvbXBhcmluZyB0aGUgcmVmIGl0c2VsZj9cblxuXG4gIHZhciBlZmZlY3REZXBzID0gZGVwcyAhPT0gbnVsbCAmJiBkZXBzICE9PSB1bmRlZmluZWQgPyBkZXBzLmNvbmNhdChbcmVmXSkgOiBudWxsO1xuICByZXR1cm4gdXBkYXRlRWZmZWN0SW1wbChVcGRhdGUsIExheW91dCwgaW1wZXJhdGl2ZUhhbmRsZUVmZmVjdC5iaW5kKG51bGwsIGNyZWF0ZSwgcmVmKSwgZWZmZWN0RGVwcyk7XG59XG5cbmZ1bmN0aW9uIG1vdW50RGVidWdWYWx1ZSh2YWx1ZSwgZm9ybWF0dGVyRm4pIHsvLyBUaGlzIGhvb2sgaXMgbm9ybWFsbHkgYSBuby1vcC5cbiAgLy8gVGhlIHJlYWN0LWRlYnVnLWhvb2tzIHBhY2thZ2UgaW5qZWN0cyBpdHMgb3duIGltcGxlbWVudGF0aW9uXG4gIC8vIHNvIHRoYXQgZS5nLiBEZXZUb29scyBjYW4gZGlzcGxheSBjdXN0b20gaG9vayB2YWx1ZXMuXG59XG5cbnZhciB1cGRhdGVEZWJ1Z1ZhbHVlID0gbW91bnREZWJ1Z1ZhbHVlO1xuXG5mdW5jdGlvbiBtb3VudENhbGxiYWNrKGNhbGxiYWNrLCBkZXBzKSB7XG4gIHZhciBob29rID0gbW91bnRXb3JrSW5Qcm9ncmVzc0hvb2soKTtcbiAgdmFyIG5leHREZXBzID0gZGVwcyA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGRlcHM7XG4gIGhvb2subWVtb2l6ZWRTdGF0ZSA9IFtjYWxsYmFjaywgbmV4dERlcHNdO1xuICByZXR1cm4gY2FsbGJhY2s7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUNhbGxiYWNrKGNhbGxiYWNrLCBkZXBzKSB7XG4gIHZhciBob29rID0gdXBkYXRlV29ya0luUHJvZ3Jlc3NIb29rKCk7XG4gIHZhciBuZXh0RGVwcyA9IGRlcHMgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBkZXBzO1xuICB2YXIgcHJldlN0YXRlID0gaG9vay5tZW1vaXplZFN0YXRlO1xuXG4gIGlmIChwcmV2U3RhdGUgIT09IG51bGwpIHtcbiAgICBpZiAobmV4dERlcHMgIT09IG51bGwpIHtcbiAgICAgIHZhciBwcmV2RGVwcyA9IHByZXZTdGF0ZVsxXTtcblxuICAgICAgaWYgKGFyZUhvb2tJbnB1dHNFcXVhbChuZXh0RGVwcywgcHJldkRlcHMpKSB7XG4gICAgICAgIHJldHVybiBwcmV2U3RhdGVbMF07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaG9vay5tZW1vaXplZFN0YXRlID0gW2NhbGxiYWNrLCBuZXh0RGVwc107XG4gIHJldHVybiBjYWxsYmFjaztcbn1cblxuZnVuY3Rpb24gbW91bnRNZW1vKG5leHRDcmVhdGUsIGRlcHMpIHtcbiAgdmFyIGhvb2sgPSBtb3VudFdvcmtJblByb2dyZXNzSG9vaygpO1xuICB2YXIgbmV4dERlcHMgPSBkZXBzID09PSB1bmRlZmluZWQgPyBudWxsIDogZGVwcztcbiAgdmFyIG5leHRWYWx1ZSA9IG5leHRDcmVhdGUoKTtcbiAgaG9vay5tZW1vaXplZFN0YXRlID0gW25leHRWYWx1ZSwgbmV4dERlcHNdO1xuICByZXR1cm4gbmV4dFZhbHVlO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVNZW1vKG5leHRDcmVhdGUsIGRlcHMpIHtcbiAgdmFyIGhvb2sgPSB1cGRhdGVXb3JrSW5Qcm9ncmVzc0hvb2soKTtcbiAgdmFyIG5leHREZXBzID0gZGVwcyA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGRlcHM7XG4gIHZhciBwcmV2U3RhdGUgPSBob29rLm1lbW9pemVkU3RhdGU7XG5cbiAgaWYgKHByZXZTdGF0ZSAhPT0gbnVsbCkge1xuICAgIC8vIEFzc3VtZSB0aGVzZSBhcmUgZGVmaW5lZC4gSWYgdGhleSdyZSBub3QsIGFyZUhvb2tJbnB1dHNFcXVhbCB3aWxsIHdhcm4uXG4gICAgaWYgKG5leHREZXBzICE9PSBudWxsKSB7XG4gICAgICB2YXIgcHJldkRlcHMgPSBwcmV2U3RhdGVbMV07XG5cbiAgICAgIGlmIChhcmVIb29rSW5wdXRzRXF1YWwobmV4dERlcHMsIHByZXZEZXBzKSkge1xuICAgICAgICByZXR1cm4gcHJldlN0YXRlWzBdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciBuZXh0VmFsdWUgPSBuZXh0Q3JlYXRlKCk7XG4gIGhvb2subWVtb2l6ZWRTdGF0ZSA9IFtuZXh0VmFsdWUsIG5leHREZXBzXTtcbiAgcmV0dXJuIG5leHRWYWx1ZTtcbn1cblxuZnVuY3Rpb24gbW91bnREZWZlcnJlZFZhbHVlKHZhbHVlKSB7XG4gIHZhciBfbW91bnRTdGF0ZSA9IG1vdW50U3RhdGUodmFsdWUpLFxuICAgICAgcHJldlZhbHVlID0gX21vdW50U3RhdGVbMF0sXG4gICAgICBzZXRWYWx1ZSA9IF9tb3VudFN0YXRlWzFdO1xuXG4gIG1vdW50RWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcHJldlRyYW5zaXRpb24gPSBSZWFjdEN1cnJlbnRCYXRjaENvbmZpZyQxLnRyYW5zaXRpb247XG4gICAgUmVhY3RDdXJyZW50QmF0Y2hDb25maWckMS50cmFuc2l0aW9uID0gMTtcblxuICAgIHRyeSB7XG4gICAgICBzZXRWYWx1ZSh2YWx1ZSk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIFJlYWN0Q3VycmVudEJhdGNoQ29uZmlnJDEudHJhbnNpdGlvbiA9IHByZXZUcmFuc2l0aW9uO1xuICAgIH1cbiAgfSwgW3ZhbHVlXSk7XG4gIHJldHVybiBwcmV2VmFsdWU7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZURlZmVycmVkVmFsdWUodmFsdWUpIHtcbiAgdmFyIF91cGRhdGVTdGF0ZSA9IHVwZGF0ZVN0YXRlKCksXG4gICAgICBwcmV2VmFsdWUgPSBfdXBkYXRlU3RhdGVbMF0sXG4gICAgICBzZXRWYWx1ZSA9IF91cGRhdGVTdGF0ZVsxXTtcblxuICB1cGRhdGVFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIHZhciBwcmV2VHJhbnNpdGlvbiA9IFJlYWN0Q3VycmVudEJhdGNoQ29uZmlnJDEudHJhbnNpdGlvbjtcbiAgICBSZWFjdEN1cnJlbnRCYXRjaENvbmZpZyQxLnRyYW5zaXRpb24gPSAxO1xuXG4gICAgdHJ5IHtcbiAgICAgIHNldFZhbHVlKHZhbHVlKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgUmVhY3RDdXJyZW50QmF0Y2hDb25maWckMS50cmFuc2l0aW9uID0gcHJldlRyYW5zaXRpb247XG4gICAgfVxuICB9LCBbdmFsdWVdKTtcbiAgcmV0dXJuIHByZXZWYWx1ZTtcbn1cblxuZnVuY3Rpb24gcmVyZW5kZXJEZWZlcnJlZFZhbHVlKHZhbHVlKSB7XG4gIHZhciBfcmVyZW5kZXJTdGF0ZSA9IHJlcmVuZGVyU3RhdGUoKSxcbiAgICAgIHByZXZWYWx1ZSA9IF9yZXJlbmRlclN0YXRlWzBdLFxuICAgICAgc2V0VmFsdWUgPSBfcmVyZW5kZXJTdGF0ZVsxXTtcblxuICB1cGRhdGVFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIHZhciBwcmV2VHJhbnNpdGlvbiA9IFJlYWN0Q3VycmVudEJhdGNoQ29uZmlnJDEudHJhbnNpdGlvbjtcbiAgICBSZWFjdEN1cnJlbnRCYXRjaENvbmZpZyQxLnRyYW5zaXRpb24gPSAxO1xuXG4gICAgdHJ5IHtcbiAgICAgIHNldFZhbHVlKHZhbHVlKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgUmVhY3RDdXJyZW50QmF0Y2hDb25maWckMS50cmFuc2l0aW9uID0gcHJldlRyYW5zaXRpb247XG4gICAgfVxuICB9LCBbdmFsdWVdKTtcbiAgcmV0dXJuIHByZXZWYWx1ZTtcbn1cblxuZnVuY3Rpb24gc3RhcnRUcmFuc2l0aW9uKHNldFBlbmRpbmcsIGNhbGxiYWNrKSB7XG4gIHZhciBwcmlvcml0eUxldmVsID0gZ2V0Q3VycmVudFByaW9yaXR5TGV2ZWwoKTtcblxuICB7XG4gICAgcnVuV2l0aFByaW9yaXR5JDEocHJpb3JpdHlMZXZlbCA8IFVzZXJCbG9ja2luZ1ByaW9yaXR5JDIgPyBVc2VyQmxvY2tpbmdQcmlvcml0eSQyIDogcHJpb3JpdHlMZXZlbCwgZnVuY3Rpb24gKCkge1xuICAgICAgc2V0UGVuZGluZyh0cnVlKTtcbiAgICB9KTtcbiAgICBydW5XaXRoUHJpb3JpdHkkMShwcmlvcml0eUxldmVsID4gTm9ybWFsUHJpb3JpdHkkMSA/IE5vcm1hbFByaW9yaXR5JDEgOiBwcmlvcml0eUxldmVsLCBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgcHJldlRyYW5zaXRpb24gPSBSZWFjdEN1cnJlbnRCYXRjaENvbmZpZyQxLnRyYW5zaXRpb247XG4gICAgICBSZWFjdEN1cnJlbnRCYXRjaENvbmZpZyQxLnRyYW5zaXRpb24gPSAxO1xuXG4gICAgICB0cnkge1xuICAgICAgICBzZXRQZW5kaW5nKGZhbHNlKTtcbiAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIFJlYWN0Q3VycmVudEJhdGNoQ29uZmlnJDEudHJhbnNpdGlvbiA9IHByZXZUcmFuc2l0aW9uO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1vdW50VHJhbnNpdGlvbigpIHtcbiAgdmFyIF9tb3VudFN0YXRlMiA9IG1vdW50U3RhdGUoZmFsc2UpLFxuICAgICAgaXNQZW5kaW5nID0gX21vdW50U3RhdGUyWzBdLFxuICAgICAgc2V0UGVuZGluZyA9IF9tb3VudFN0YXRlMlsxXTsgLy8gVGhlIGBzdGFydGAgbWV0aG9kIGNhbiBiZSBzdG9yZWQgb24gYSByZWYsIHNpbmNlIGBzZXRQZW5kaW5nYFxuICAvLyBuZXZlciBjaGFuZ2VzLlxuXG5cbiAgdmFyIHN0YXJ0ID0gc3RhcnRUcmFuc2l0aW9uLmJpbmQobnVsbCwgc2V0UGVuZGluZyk7XG4gIG1vdW50UmVmKHN0YXJ0KTtcbiAgcmV0dXJuIFtzdGFydCwgaXNQZW5kaW5nXTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlVHJhbnNpdGlvbigpIHtcbiAgdmFyIF91cGRhdGVTdGF0ZTIgPSB1cGRhdGVTdGF0ZSgpLFxuICAgICAgaXNQZW5kaW5nID0gX3VwZGF0ZVN0YXRlMlswXTtcblxuICB2YXIgc3RhcnRSZWYgPSB1cGRhdGVSZWYoKTtcbiAgdmFyIHN0YXJ0ID0gc3RhcnRSZWYuY3VycmVudDtcbiAgcmV0dXJuIFtzdGFydCwgaXNQZW5kaW5nXTtcbn1cblxuZnVuY3Rpb24gcmVyZW5kZXJUcmFuc2l0aW9uKCkge1xuICB2YXIgX3JlcmVuZGVyU3RhdGUyID0gcmVyZW5kZXJTdGF0ZSgpLFxuICAgICAgaXNQZW5kaW5nID0gX3JlcmVuZGVyU3RhdGUyWzBdO1xuXG4gIHZhciBzdGFydFJlZiA9IHVwZGF0ZVJlZigpO1xuICB2YXIgc3RhcnQgPSBzdGFydFJlZi5jdXJyZW50O1xuICByZXR1cm4gW3N0YXJ0LCBpc1BlbmRpbmddO1xufVxuXG52YXIgaXNVcGRhdGluZ09wYXF1ZVZhbHVlSW5SZW5kZXJQaGFzZSA9IGZhbHNlO1xuZnVuY3Rpb24gZ2V0SXNVcGRhdGluZ09wYXF1ZVZhbHVlSW5SZW5kZXJQaGFzZUluREVWKCkge1xuICB7XG4gICAgcmV0dXJuIGlzVXBkYXRpbmdPcGFxdWVWYWx1ZUluUmVuZGVyUGhhc2U7XG4gIH1cbn1cblxuZnVuY3Rpb24gd2Fybk9uT3BhcXVlSWRlbnRpZmllckFjY2Vzc0luREVWKGZpYmVyKSB7XG4gIHtcbiAgICAvLyBUT0RPOiBTaG91bGQgd2FybiBpbiBlZmZlY3RzIGFuZCBjYWxsYmFja3MsIHRvb1xuICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZShmaWJlci50eXBlKSB8fCAnVW5rbm93bic7XG5cbiAgICBpZiAoZ2V0SXNSZW5kZXJpbmcoKSAmJiAhZGlkV2FybkFib3V0VXNlT3BhcXVlSWRlbnRpZmllcltuYW1lXSkge1xuICAgICAgZXJyb3IoJ1RoZSBvYmplY3QgcGFzc2VkIGJhY2sgZnJvbSB1c2VPcGFxdWVJZGVudGlmaWVyIGlzIG1lYW50IHRvIGJlICcgKyAncGFzc2VkIHRocm91Z2ggdG8gYXR0cmlidXRlcyBvbmx5LiBEbyBub3QgcmVhZCB0aGUgJyArICd2YWx1ZSBkaXJlY3RseS4nKTtcblxuICAgICAgZGlkV2FybkFib3V0VXNlT3BhcXVlSWRlbnRpZmllcltuYW1lXSA9IHRydWU7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIG1vdW50T3BhcXVlSWRlbnRpZmllcigpIHtcbiAgdmFyIG1ha2VJZCA9ICBtYWtlQ2xpZW50SWRJbkRFVi5iaW5kKG51bGwsIHdhcm5Pbk9wYXF1ZUlkZW50aWZpZXJBY2Nlc3NJbkRFVi5iaW5kKG51bGwsIGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEpKSA7XG5cbiAgaWYgKGdldElzSHlkcmF0aW5nKCkpIHtcbiAgICB2YXIgZGlkVXBncmFkZSA9IGZhbHNlO1xuICAgIHZhciBmaWJlciA9IGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDE7XG5cbiAgICB2YXIgcmVhZFZhbHVlID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKCFkaWRVcGdyYWRlKSB7XG4gICAgICAgIC8vIE9ubHkgdXBncmFkZSBvbmNlLiBUaGlzIHdvcmtzIGV2ZW4gaW5zaWRlIHRoZSByZW5kZXIgcGhhc2UgYmVjYXVzZVxuICAgICAgICAvLyB0aGUgdXBkYXRlIGlzIGFkZGVkIHRvIGEgc2hhcmVkIHF1ZXVlLCB3aGljaCBvdXRsYXN0cyB0aGVcbiAgICAgICAgLy8gaW4tcHJvZ3Jlc3MgcmVuZGVyLlxuICAgICAgICBkaWRVcGdyYWRlID0gdHJ1ZTtcblxuICAgICAgICB7XG4gICAgICAgICAgaXNVcGRhdGluZ09wYXF1ZVZhbHVlSW5SZW5kZXJQaGFzZSA9IHRydWU7XG4gICAgICAgICAgc2V0SWQobWFrZUlkKCkpO1xuICAgICAgICAgIGlzVXBkYXRpbmdPcGFxdWVWYWx1ZUluUmVuZGVyUGhhc2UgPSBmYWxzZTtcbiAgICAgICAgICB3YXJuT25PcGFxdWVJZGVudGlmaWVyQWNjZXNzSW5ERVYoZmliZXIpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHtcbiAgICAgICAge1xuICAgICAgICAgIHRocm93IEVycm9yKCBcIlRoZSBvYmplY3QgcGFzc2VkIGJhY2sgZnJvbSB1c2VPcGFxdWVJZGVudGlmaWVyIGlzIG1lYW50IHRvIGJlIHBhc3NlZCB0aHJvdWdoIHRvIGF0dHJpYnV0ZXMgb25seS4gRG8gbm90IHJlYWQgdGhlIHZhbHVlIGRpcmVjdGx5LlwiICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIGlkID0gbWFrZU9wYXF1ZUh5ZHJhdGluZ09iamVjdChyZWFkVmFsdWUpO1xuICAgIHZhciBzZXRJZCA9IG1vdW50U3RhdGUoaWQpWzFdO1xuXG4gICAgaWYgKChjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLm1vZGUgJiBCbG9ja2luZ01vZGUpID09PSBOb01vZGUpIHtcbiAgICAgIGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEuZmxhZ3MgfD0gVXBkYXRlIHwgUGFzc2l2ZTtcbiAgICAgIHB1c2hFZmZlY3QoSGFzRWZmZWN0IHwgUGFzc2l2ZSQxLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHNldElkKG1ha2VJZCgpKTtcbiAgICAgIH0sIHVuZGVmaW5lZCwgbnVsbCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGlkO1xuICB9IGVsc2Uge1xuICAgIHZhciBfaWQgPSBtYWtlSWQoKTtcblxuICAgIG1vdW50U3RhdGUoX2lkKTtcbiAgICByZXR1cm4gX2lkO1xuICB9XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZU9wYXF1ZUlkZW50aWZpZXIoKSB7XG4gIHZhciBpZCA9IHVwZGF0ZVN0YXRlKClbMF07XG4gIHJldHVybiBpZDtcbn1cblxuZnVuY3Rpb24gcmVyZW5kZXJPcGFxdWVJZGVudGlmaWVyKCkge1xuICB2YXIgaWQgPSByZXJlbmRlclN0YXRlKClbMF07XG4gIHJldHVybiBpZDtcbn1cblxuZnVuY3Rpb24gZGlzcGF0Y2hBY3Rpb24oZmliZXIsIHF1ZXVlLCBhY3Rpb24pIHtcbiAge1xuICAgIGlmICh0eXBlb2YgYXJndW1lbnRzWzNdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBlcnJvcihcIlN0YXRlIHVwZGF0ZXMgZnJvbSB0aGUgdXNlU3RhdGUoKSBhbmQgdXNlUmVkdWNlcigpIEhvb2tzIGRvbid0IHN1cHBvcnQgdGhlIFwiICsgJ3NlY29uZCBjYWxsYmFjayBhcmd1bWVudC4gVG8gZXhlY3V0ZSBhIHNpZGUgZWZmZWN0IGFmdGVyICcgKyAncmVuZGVyaW5nLCBkZWNsYXJlIGl0IGluIHRoZSBjb21wb25lbnQgYm9keSB3aXRoIHVzZUVmZmVjdCgpLicpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBldmVudFRpbWUgPSByZXF1ZXN0RXZlbnRUaW1lKCk7XG4gIHZhciBsYW5lID0gcmVxdWVzdFVwZGF0ZUxhbmUoZmliZXIpO1xuICB2YXIgdXBkYXRlID0ge1xuICAgIGxhbmU6IGxhbmUsXG4gICAgYWN0aW9uOiBhY3Rpb24sXG4gICAgZWFnZXJSZWR1Y2VyOiBudWxsLFxuICAgIGVhZ2VyU3RhdGU6IG51bGwsXG4gICAgbmV4dDogbnVsbFxuICB9OyAvLyBBcHBlbmQgdGhlIHVwZGF0ZSB0byB0aGUgZW5kIG9mIHRoZSBsaXN0LlxuXG4gIHZhciBwZW5kaW5nID0gcXVldWUucGVuZGluZztcblxuICBpZiAocGVuZGluZyA9PT0gbnVsbCkge1xuICAgIC8vIFRoaXMgaXMgdGhlIGZpcnN0IHVwZGF0ZS4gQ3JlYXRlIGEgY2lyY3VsYXIgbGlzdC5cbiAgICB1cGRhdGUubmV4dCA9IHVwZGF0ZTtcbiAgfSBlbHNlIHtcbiAgICB1cGRhdGUubmV4dCA9IHBlbmRpbmcubmV4dDtcbiAgICBwZW5kaW5nLm5leHQgPSB1cGRhdGU7XG4gIH1cblxuICBxdWV1ZS5wZW5kaW5nID0gdXBkYXRlO1xuICB2YXIgYWx0ZXJuYXRlID0gZmliZXIuYWx0ZXJuYXRlO1xuXG4gIGlmIChmaWJlciA9PT0gY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMSB8fCBhbHRlcm5hdGUgIT09IG51bGwgJiYgYWx0ZXJuYXRlID09PSBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxKSB7XG4gICAgLy8gVGhpcyBpcyBhIHJlbmRlciBwaGFzZSB1cGRhdGUuIFN0YXNoIGl0IGluIGEgbGF6aWx5LWNyZWF0ZWQgbWFwIG9mXG4gICAgLy8gcXVldWUgLT4gbGlua2VkIGxpc3Qgb2YgdXBkYXRlcy4gQWZ0ZXIgdGhpcyByZW5kZXIgcGFzcywgd2UnbGwgcmVzdGFydFxuICAgIC8vIGFuZCBhcHBseSB0aGUgc3Rhc2hlZCB1cGRhdGVzIG9uIHRvcCBvZiB0aGUgd29yay1pbi1wcm9ncmVzcyBob29rLlxuICAgIGRpZFNjaGVkdWxlUmVuZGVyUGhhc2VVcGRhdGVEdXJpbmdUaGlzUGFzcyA9IGRpZFNjaGVkdWxlUmVuZGVyUGhhc2VVcGRhdGUgPSB0cnVlO1xuICB9IGVsc2Uge1xuICAgIGlmIChmaWJlci5sYW5lcyA9PT0gTm9MYW5lcyAmJiAoYWx0ZXJuYXRlID09PSBudWxsIHx8IGFsdGVybmF0ZS5sYW5lcyA9PT0gTm9MYW5lcykpIHtcbiAgICAgIC8vIFRoZSBxdWV1ZSBpcyBjdXJyZW50bHkgZW1wdHksIHdoaWNoIG1lYW5zIHdlIGNhbiBlYWdlcmx5IGNvbXB1dGUgdGhlXG4gICAgICAvLyBuZXh0IHN0YXRlIGJlZm9yZSBlbnRlcmluZyB0aGUgcmVuZGVyIHBoYXNlLiBJZiB0aGUgbmV3IHN0YXRlIGlzIHRoZVxuICAgICAgLy8gc2FtZSBhcyB0aGUgY3VycmVudCBzdGF0ZSwgd2UgbWF5IGJlIGFibGUgdG8gYmFpbCBvdXQgZW50aXJlbHkuXG4gICAgICB2YXIgbGFzdFJlbmRlcmVkUmVkdWNlciA9IHF1ZXVlLmxhc3RSZW5kZXJlZFJlZHVjZXI7XG5cbiAgICAgIGlmIChsYXN0UmVuZGVyZWRSZWR1Y2VyICE9PSBudWxsKSB7XG4gICAgICAgIHZhciBwcmV2RGlzcGF0Y2hlcjtcblxuICAgICAgICB7XG4gICAgICAgICAgcHJldkRpc3BhdGNoZXIgPSBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudDtcbiAgICAgICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudCA9IEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPblVwZGF0ZUluREVWO1xuICAgICAgICB9XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB2YXIgY3VycmVudFN0YXRlID0gcXVldWUubGFzdFJlbmRlcmVkU3RhdGU7XG4gICAgICAgICAgdmFyIGVhZ2VyU3RhdGUgPSBsYXN0UmVuZGVyZWRSZWR1Y2VyKGN1cnJlbnRTdGF0ZSwgYWN0aW9uKTsgLy8gU3Rhc2ggdGhlIGVhZ2VybHkgY29tcHV0ZWQgc3RhdGUsIGFuZCB0aGUgcmVkdWNlciB1c2VkIHRvIGNvbXB1dGVcbiAgICAgICAgICAvLyBpdCwgb24gdGhlIHVwZGF0ZSBvYmplY3QuIElmIHRoZSByZWR1Y2VyIGhhc24ndCBjaGFuZ2VkIGJ5IHRoZVxuICAgICAgICAgIC8vIHRpbWUgd2UgZW50ZXIgdGhlIHJlbmRlciBwaGFzZSwgdGhlbiB0aGUgZWFnZXIgc3RhdGUgY2FuIGJlIHVzZWRcbiAgICAgICAgICAvLyB3aXRob3V0IGNhbGxpbmcgdGhlIHJlZHVjZXIgYWdhaW4uXG5cbiAgICAgICAgICB1cGRhdGUuZWFnZXJSZWR1Y2VyID0gbGFzdFJlbmRlcmVkUmVkdWNlcjtcbiAgICAgICAgICB1cGRhdGUuZWFnZXJTdGF0ZSA9IGVhZ2VyU3RhdGU7XG5cbiAgICAgICAgICBpZiAob2JqZWN0SXMoZWFnZXJTdGF0ZSwgY3VycmVudFN0YXRlKSkge1xuICAgICAgICAgICAgLy8gRmFzdCBwYXRoLiBXZSBjYW4gYmFpbCBvdXQgd2l0aG91dCBzY2hlZHVsaW5nIFJlYWN0IHRvIHJlLXJlbmRlci5cbiAgICAgICAgICAgIC8vIEl0J3Mgc3RpbGwgcG9zc2libGUgdGhhdCB3ZSdsbCBuZWVkIHRvIHJlYmFzZSB0aGlzIHVwZGF0ZSBsYXRlcixcbiAgICAgICAgICAgIC8vIGlmIHRoZSBjb21wb25lbnQgcmUtcmVuZGVycyBmb3IgYSBkaWZmZXJlbnQgcmVhc29uIGFuZCBieSB0aGF0XG4gICAgICAgICAgICAvLyB0aW1lIHRoZSByZWR1Y2VyIGhhcyBjaGFuZ2VkLlxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHsvLyBTdXBwcmVzcyB0aGUgZXJyb3IuIEl0IHdpbGwgdGhyb3cgYWdhaW4gaW4gdGhlIHJlbmRlciBwaGFzZS5cbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICB7XG4gICAgICAgICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudCA9IHByZXZEaXNwYXRjaGVyO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHtcbiAgICAgIC8vICRGbG93RXhwZWN0ZWRFcnJvciAtIGplc3QgaXNuJ3QgYSBnbG9iYWwsIGFuZCBpc24ndCByZWNvZ25pemVkIG91dHNpZGUgb2YgdGVzdHNcbiAgICAgIGlmICgndW5kZWZpbmVkJyAhPT0gdHlwZW9mIGplc3QpIHtcbiAgICAgICAgd2FybklmTm90U2NvcGVkV2l0aE1hdGNoaW5nQWN0KGZpYmVyKTtcbiAgICAgICAgd2FybklmTm90Q3VycmVudGx5QWN0aW5nVXBkYXRlc0luRGV2KGZpYmVyKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzY2hlZHVsZVVwZGF0ZU9uRmliZXIoZmliZXIsIGxhbmUsIGV2ZW50VGltZSk7XG4gIH1cbn1cblxudmFyIENvbnRleHRPbmx5RGlzcGF0Y2hlciA9IHtcbiAgcmVhZENvbnRleHQ6IHJlYWRDb250ZXh0LFxuICB1c2VDYWxsYmFjazogdGhyb3dJbnZhbGlkSG9va0Vycm9yLFxuICB1c2VDb250ZXh0OiB0aHJvd0ludmFsaWRIb29rRXJyb3IsXG4gIHVzZUVmZmVjdDogdGhyb3dJbnZhbGlkSG9va0Vycm9yLFxuICB1c2VJbXBlcmF0aXZlSGFuZGxlOiB0aHJvd0ludmFsaWRIb29rRXJyb3IsXG4gIHVzZUxheW91dEVmZmVjdDogdGhyb3dJbnZhbGlkSG9va0Vycm9yLFxuICB1c2VNZW1vOiB0aHJvd0ludmFsaWRIb29rRXJyb3IsXG4gIHVzZVJlZHVjZXI6IHRocm93SW52YWxpZEhvb2tFcnJvcixcbiAgdXNlUmVmOiB0aHJvd0ludmFsaWRIb29rRXJyb3IsXG4gIHVzZVN0YXRlOiB0aHJvd0ludmFsaWRIb29rRXJyb3IsXG4gIHVzZURlYnVnVmFsdWU6IHRocm93SW52YWxpZEhvb2tFcnJvcixcbiAgdXNlRGVmZXJyZWRWYWx1ZTogdGhyb3dJbnZhbGlkSG9va0Vycm9yLFxuICB1c2VUcmFuc2l0aW9uOiB0aHJvd0ludmFsaWRIb29rRXJyb3IsXG4gIHVzZU11dGFibGVTb3VyY2U6IHRocm93SW52YWxpZEhvb2tFcnJvcixcbiAgdXNlT3BhcXVlSWRlbnRpZmllcjogdGhyb3dJbnZhbGlkSG9va0Vycm9yLFxuICB1bnN0YWJsZV9pc05ld1JlY29uY2lsZXI6IGVuYWJsZU5ld1JlY29uY2lsZXJcbn07XG52YXIgSG9va3NEaXNwYXRjaGVyT25Nb3VudEluREVWID0gbnVsbDtcbnZhciBIb29rc0Rpc3BhdGNoZXJPbk1vdW50V2l0aEhvb2tUeXBlc0luREVWID0gbnVsbDtcbnZhciBIb29rc0Rpc3BhdGNoZXJPblVwZGF0ZUluREVWID0gbnVsbDtcbnZhciBIb29rc0Rpc3BhdGNoZXJPblJlcmVuZGVySW5ERVYgPSBudWxsO1xudmFyIEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPbk1vdW50SW5ERVYgPSBudWxsO1xudmFyIEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPblVwZGF0ZUluREVWID0gbnVsbDtcbnZhciBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25SZXJlbmRlckluREVWID0gbnVsbDtcblxue1xuICB2YXIgd2FybkludmFsaWRDb250ZXh0QWNjZXNzID0gZnVuY3Rpb24gKCkge1xuICAgIGVycm9yKCdDb250ZXh0IGNhbiBvbmx5IGJlIHJlYWQgd2hpbGUgUmVhY3QgaXMgcmVuZGVyaW5nLiAnICsgJ0luIGNsYXNzZXMsIHlvdSBjYW4gcmVhZCBpdCBpbiB0aGUgcmVuZGVyIG1ldGhvZCBvciBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMuICcgKyAnSW4gZnVuY3Rpb24gY29tcG9uZW50cywgeW91IGNhbiByZWFkIGl0IGRpcmVjdGx5IGluIHRoZSBmdW5jdGlvbiBib2R5LCBidXQgbm90ICcgKyAnaW5zaWRlIEhvb2tzIGxpa2UgdXNlUmVkdWNlcigpIG9yIHVzZU1lbW8oKS4nKTtcbiAgfTtcblxuICB2YXIgd2FybkludmFsaWRIb29rQWNjZXNzID0gZnVuY3Rpb24gKCkge1xuICAgIGVycm9yKCdEbyBub3QgY2FsbCBIb29rcyBpbnNpZGUgdXNlRWZmZWN0KC4uLiksIHVzZU1lbW8oLi4uKSwgb3Igb3RoZXIgYnVpbHQtaW4gSG9va3MuICcgKyAnWW91IGNhbiBvbmx5IGNhbGwgSG9va3MgYXQgdGhlIHRvcCBsZXZlbCBvZiB5b3VyIFJlYWN0IGZ1bmN0aW9uLiAnICsgJ0ZvciBtb3JlIGluZm9ybWF0aW9uLCBzZWUgJyArICdodHRwczovL3JlYWN0anMub3JnL2xpbmsvcnVsZXMtb2YtaG9va3MnKTtcbiAgfTtcblxuICBIb29rc0Rpc3BhdGNoZXJPbk1vdW50SW5ERVYgPSB7XG4gICAgcmVhZENvbnRleHQ6IGZ1bmN0aW9uIChjb250ZXh0LCBvYnNlcnZlZEJpdHMpIHtcbiAgICAgIHJldHVybiByZWFkQ29udGV4dChjb250ZXh0LCBvYnNlcnZlZEJpdHMpO1xuICAgIH0sXG4gICAgdXNlQ2FsbGJhY2s6IGZ1bmN0aW9uIChjYWxsYmFjaywgZGVwcykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlQ2FsbGJhY2snO1xuICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgIGNoZWNrRGVwc0FyZUFycmF5RGV2KGRlcHMpO1xuICAgICAgcmV0dXJuIG1vdW50Q2FsbGJhY2soY2FsbGJhY2ssIGRlcHMpO1xuICAgIH0sXG4gICAgdXNlQ29udGV4dDogZnVuY3Rpb24gKGNvbnRleHQsIG9ic2VydmVkQml0cykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlQ29udGV4dCc7XG4gICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHJlYWRDb250ZXh0KGNvbnRleHQsIG9ic2VydmVkQml0cyk7XG4gICAgfSxcbiAgICB1c2VFZmZlY3Q6IGZ1bmN0aW9uIChjcmVhdGUsIGRlcHMpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUVmZmVjdCc7XG4gICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgY2hlY2tEZXBzQXJlQXJyYXlEZXYoZGVwcyk7XG4gICAgICByZXR1cm4gbW91bnRFZmZlY3QoY3JlYXRlLCBkZXBzKTtcbiAgICB9LFxuICAgIHVzZUltcGVyYXRpdmVIYW5kbGU6IGZ1bmN0aW9uIChyZWYsIGNyZWF0ZSwgZGVwcykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlSW1wZXJhdGl2ZUhhbmRsZSc7XG4gICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgY2hlY2tEZXBzQXJlQXJyYXlEZXYoZGVwcyk7XG4gICAgICByZXR1cm4gbW91bnRJbXBlcmF0aXZlSGFuZGxlKHJlZiwgY3JlYXRlLCBkZXBzKTtcbiAgICB9LFxuICAgIHVzZUxheW91dEVmZmVjdDogZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlTGF5b3V0RWZmZWN0JztcbiAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICBjaGVja0RlcHNBcmVBcnJheURldihkZXBzKTtcbiAgICAgIHJldHVybiBtb3VudExheW91dEVmZmVjdChjcmVhdGUsIGRlcHMpO1xuICAgIH0sXG4gICAgdXNlTWVtbzogZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlTWVtbyc7XG4gICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgY2hlY2tEZXBzQXJlQXJyYXlEZXYoZGVwcyk7XG4gICAgICB2YXIgcHJldkRpc3BhdGNoZXIgPSBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudDtcbiAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uTW91bnRJbkRFVjtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIG1vdW50TWVtbyhjcmVhdGUsIGRlcHMpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSBwcmV2RGlzcGF0Y2hlcjtcbiAgICAgIH1cbiAgICB9LFxuICAgIHVzZVJlZHVjZXI6IGZ1bmN0aW9uIChyZWR1Y2VyLCBpbml0aWFsQXJnLCBpbml0KSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VSZWR1Y2VyJztcbiAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICB2YXIgcHJldkRpc3BhdGNoZXIgPSBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudDtcbiAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uTW91bnRJbkRFVjtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIG1vdW50UmVkdWNlcihyZWR1Y2VyLCBpbml0aWFsQXJnLCBpbml0KTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gcHJldkRpc3BhdGNoZXI7XG4gICAgICB9XG4gICAgfSxcbiAgICB1c2VSZWY6IGZ1bmN0aW9uIChpbml0aWFsVmFsdWUpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZVJlZic7XG4gICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIG1vdW50UmVmKGluaXRpYWxWYWx1ZSk7XG4gICAgfSxcbiAgICB1c2VTdGF0ZTogZnVuY3Rpb24gKGluaXRpYWxTdGF0ZSkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlU3RhdGUnO1xuICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgIHZhciBwcmV2RGlzcGF0Y2hlciA9IFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50O1xuICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25Nb3VudEluREVWO1xuXG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gbW91bnRTdGF0ZShpbml0aWFsU3RhdGUpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSBwcmV2RGlzcGF0Y2hlcjtcbiAgICAgIH1cbiAgICB9LFxuICAgIHVzZURlYnVnVmFsdWU6IGZ1bmN0aW9uICh2YWx1ZSwgZm9ybWF0dGVyRm4pIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZURlYnVnVmFsdWUnO1xuICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiBtb3VudERlYnVnVmFsdWUoKTtcbiAgICB9LFxuICAgIHVzZURlZmVycmVkVmFsdWU6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlRGVmZXJyZWRWYWx1ZSc7XG4gICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIG1vdW50RGVmZXJyZWRWYWx1ZSh2YWx1ZSk7XG4gICAgfSxcbiAgICB1c2VUcmFuc2l0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VUcmFuc2l0aW9uJztcbiAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gbW91bnRUcmFuc2l0aW9uKCk7XG4gICAgfSxcbiAgICB1c2VNdXRhYmxlU291cmNlOiBmdW5jdGlvbiAoc291cmNlLCBnZXRTbmFwc2hvdCwgc3Vic2NyaWJlKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VNdXRhYmxlU291cmNlJztcbiAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gbW91bnRNdXRhYmxlU291cmNlKHNvdXJjZSwgZ2V0U25hcHNob3QsIHN1YnNjcmliZSk7XG4gICAgfSxcbiAgICB1c2VPcGFxdWVJZGVudGlmaWVyOiBmdW5jdGlvbiAoKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VPcGFxdWVJZGVudGlmaWVyJztcbiAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gbW91bnRPcGFxdWVJZGVudGlmaWVyKCk7XG4gICAgfSxcbiAgICB1bnN0YWJsZV9pc05ld1JlY29uY2lsZXI6IGVuYWJsZU5ld1JlY29uY2lsZXJcbiAgfTtcbiAgSG9va3NEaXNwYXRjaGVyT25Nb3VudFdpdGhIb29rVHlwZXNJbkRFViA9IHtcbiAgICByZWFkQ29udGV4dDogZnVuY3Rpb24gKGNvbnRleHQsIG9ic2VydmVkQml0cykge1xuICAgICAgcmV0dXJuIHJlYWRDb250ZXh0KGNvbnRleHQsIG9ic2VydmVkQml0cyk7XG4gICAgfSxcbiAgICB1c2VDYWxsYmFjazogZnVuY3Rpb24gKGNhbGxiYWNrLCBkZXBzKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VDYWxsYmFjayc7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiBtb3VudENhbGxiYWNrKGNhbGxiYWNrLCBkZXBzKTtcbiAgICB9LFxuICAgIHVzZUNvbnRleHQ6IGZ1bmN0aW9uIChjb250ZXh0LCBvYnNlcnZlZEJpdHMpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUNvbnRleHQnO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gcmVhZENvbnRleHQoY29udGV4dCwgb2JzZXJ2ZWRCaXRzKTtcbiAgICB9LFxuICAgIHVzZUVmZmVjdDogZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlRWZmZWN0JztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIG1vdW50RWZmZWN0KGNyZWF0ZSwgZGVwcyk7XG4gICAgfSxcbiAgICB1c2VJbXBlcmF0aXZlSGFuZGxlOiBmdW5jdGlvbiAocmVmLCBjcmVhdGUsIGRlcHMpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUltcGVyYXRpdmVIYW5kbGUnO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gbW91bnRJbXBlcmF0aXZlSGFuZGxlKHJlZiwgY3JlYXRlLCBkZXBzKTtcbiAgICB9LFxuICAgIHVzZUxheW91dEVmZmVjdDogZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlTGF5b3V0RWZmZWN0JztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIG1vdW50TGF5b3V0RWZmZWN0KGNyZWF0ZSwgZGVwcyk7XG4gICAgfSxcbiAgICB1c2VNZW1vOiBmdW5jdGlvbiAoY3JlYXRlLCBkZXBzKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VNZW1vJztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgdmFyIHByZXZEaXNwYXRjaGVyID0gUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQ7XG4gICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudCA9IEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPbk1vdW50SW5ERVY7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBtb3VudE1lbW8oY3JlYXRlLCBkZXBzKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gcHJldkRpc3BhdGNoZXI7XG4gICAgICB9XG4gICAgfSxcbiAgICB1c2VSZWR1Y2VyOiBmdW5jdGlvbiAocmVkdWNlciwgaW5pdGlhbEFyZywgaW5pdCkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlUmVkdWNlcic7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHZhciBwcmV2RGlzcGF0Y2hlciA9IFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50O1xuICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25Nb3VudEluREVWO1xuXG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gbW91bnRSZWR1Y2VyKHJlZHVjZXIsIGluaXRpYWxBcmcsIGluaXQpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSBwcmV2RGlzcGF0Y2hlcjtcbiAgICAgIH1cbiAgICB9LFxuICAgIHVzZVJlZjogZnVuY3Rpb24gKGluaXRpYWxWYWx1ZSkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlUmVmJztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIG1vdW50UmVmKGluaXRpYWxWYWx1ZSk7XG4gICAgfSxcbiAgICB1c2VTdGF0ZTogZnVuY3Rpb24gKGluaXRpYWxTdGF0ZSkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlU3RhdGUnO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICB2YXIgcHJldkRpc3BhdGNoZXIgPSBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudDtcbiAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uTW91bnRJbkRFVjtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIG1vdW50U3RhdGUoaW5pdGlhbFN0YXRlKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gcHJldkRpc3BhdGNoZXI7XG4gICAgICB9XG4gICAgfSxcbiAgICB1c2VEZWJ1Z1ZhbHVlOiBmdW5jdGlvbiAodmFsdWUsIGZvcm1hdHRlckZuKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VEZWJ1Z1ZhbHVlJztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIG1vdW50RGVidWdWYWx1ZSgpO1xuICAgIH0sXG4gICAgdXNlRGVmZXJyZWRWYWx1ZTogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VEZWZlcnJlZFZhbHVlJztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIG1vdW50RGVmZXJyZWRWYWx1ZSh2YWx1ZSk7XG4gICAgfSxcbiAgICB1c2VUcmFuc2l0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VUcmFuc2l0aW9uJztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIG1vdW50VHJhbnNpdGlvbigpO1xuICAgIH0sXG4gICAgdXNlTXV0YWJsZVNvdXJjZTogZnVuY3Rpb24gKHNvdXJjZSwgZ2V0U25hcHNob3QsIHN1YnNjcmliZSkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlTXV0YWJsZVNvdXJjZSc7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiBtb3VudE11dGFibGVTb3VyY2Uoc291cmNlLCBnZXRTbmFwc2hvdCwgc3Vic2NyaWJlKTtcbiAgICB9LFxuICAgIHVzZU9wYXF1ZUlkZW50aWZpZXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZU9wYXF1ZUlkZW50aWZpZXInO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gbW91bnRPcGFxdWVJZGVudGlmaWVyKCk7XG4gICAgfSxcbiAgICB1bnN0YWJsZV9pc05ld1JlY29uY2lsZXI6IGVuYWJsZU5ld1JlY29uY2lsZXJcbiAgfTtcbiAgSG9va3NEaXNwYXRjaGVyT25VcGRhdGVJbkRFViA9IHtcbiAgICByZWFkQ29udGV4dDogZnVuY3Rpb24gKGNvbnRleHQsIG9ic2VydmVkQml0cykge1xuICAgICAgcmV0dXJuIHJlYWRDb250ZXh0KGNvbnRleHQsIG9ic2VydmVkQml0cyk7XG4gICAgfSxcbiAgICB1c2VDYWxsYmFjazogZnVuY3Rpb24gKGNhbGxiYWNrLCBkZXBzKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VDYWxsYmFjayc7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiB1cGRhdGVDYWxsYmFjayhjYWxsYmFjaywgZGVwcyk7XG4gICAgfSxcbiAgICB1c2VDb250ZXh0OiBmdW5jdGlvbiAoY29udGV4dCwgb2JzZXJ2ZWRCaXRzKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VDb250ZXh0JztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHJlYWRDb250ZXh0KGNvbnRleHQsIG9ic2VydmVkQml0cyk7XG4gICAgfSxcbiAgICB1c2VFZmZlY3Q6IGZ1bmN0aW9uIChjcmVhdGUsIGRlcHMpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUVmZmVjdCc7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiB1cGRhdGVFZmZlY3QoY3JlYXRlLCBkZXBzKTtcbiAgICB9LFxuICAgIHVzZUltcGVyYXRpdmVIYW5kbGU6IGZ1bmN0aW9uIChyZWYsIGNyZWF0ZSwgZGVwcykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlSW1wZXJhdGl2ZUhhbmRsZSc7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiB1cGRhdGVJbXBlcmF0aXZlSGFuZGxlKHJlZiwgY3JlYXRlLCBkZXBzKTtcbiAgICB9LFxuICAgIHVzZUxheW91dEVmZmVjdDogZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlTGF5b3V0RWZmZWN0JztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHVwZGF0ZUxheW91dEVmZmVjdChjcmVhdGUsIGRlcHMpO1xuICAgIH0sXG4gICAgdXNlTWVtbzogZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlTWVtbyc7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHZhciBwcmV2RGlzcGF0Y2hlciA9IFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50O1xuICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25VcGRhdGVJbkRFVjtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIHVwZGF0ZU1lbW8oY3JlYXRlLCBkZXBzKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gcHJldkRpc3BhdGNoZXI7XG4gICAgICB9XG4gICAgfSxcbiAgICB1c2VSZWR1Y2VyOiBmdW5jdGlvbiAocmVkdWNlciwgaW5pdGlhbEFyZywgaW5pdCkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlUmVkdWNlcic7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHZhciBwcmV2RGlzcGF0Y2hlciA9IFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50O1xuICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25VcGRhdGVJbkRFVjtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIHVwZGF0ZVJlZHVjZXIocmVkdWNlciwgaW5pdGlhbEFyZywgaW5pdCk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudCA9IHByZXZEaXNwYXRjaGVyO1xuICAgICAgfVxuICAgIH0sXG4gICAgdXNlUmVmOiBmdW5jdGlvbiAoaW5pdGlhbFZhbHVlKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VSZWYnO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gdXBkYXRlUmVmKCk7XG4gICAgfSxcbiAgICB1c2VTdGF0ZTogZnVuY3Rpb24gKGluaXRpYWxTdGF0ZSkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlU3RhdGUnO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICB2YXIgcHJldkRpc3BhdGNoZXIgPSBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudDtcbiAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uVXBkYXRlSW5ERVY7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiB1cGRhdGVTdGF0ZShpbml0aWFsU3RhdGUpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSBwcmV2RGlzcGF0Y2hlcjtcbiAgICAgIH1cbiAgICB9LFxuICAgIHVzZURlYnVnVmFsdWU6IGZ1bmN0aW9uICh2YWx1ZSwgZm9ybWF0dGVyRm4pIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZURlYnVnVmFsdWUnO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gdXBkYXRlRGVidWdWYWx1ZSgpO1xuICAgIH0sXG4gICAgdXNlRGVmZXJyZWRWYWx1ZTogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VEZWZlcnJlZFZhbHVlJztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHVwZGF0ZURlZmVycmVkVmFsdWUodmFsdWUpO1xuICAgIH0sXG4gICAgdXNlVHJhbnNpdGlvbjogZnVuY3Rpb24gKCkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlVHJhbnNpdGlvbic7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiB1cGRhdGVUcmFuc2l0aW9uKCk7XG4gICAgfSxcbiAgICB1c2VNdXRhYmxlU291cmNlOiBmdW5jdGlvbiAoc291cmNlLCBnZXRTbmFwc2hvdCwgc3Vic2NyaWJlKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VNdXRhYmxlU291cmNlJztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHVwZGF0ZU11dGFibGVTb3VyY2Uoc291cmNlLCBnZXRTbmFwc2hvdCwgc3Vic2NyaWJlKTtcbiAgICB9LFxuICAgIHVzZU9wYXF1ZUlkZW50aWZpZXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZU9wYXF1ZUlkZW50aWZpZXInO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gdXBkYXRlT3BhcXVlSWRlbnRpZmllcigpO1xuICAgIH0sXG4gICAgdW5zdGFibGVfaXNOZXdSZWNvbmNpbGVyOiBlbmFibGVOZXdSZWNvbmNpbGVyXG4gIH07XG4gIEhvb2tzRGlzcGF0Y2hlck9uUmVyZW5kZXJJbkRFViA9IHtcbiAgICByZWFkQ29udGV4dDogZnVuY3Rpb24gKGNvbnRleHQsIG9ic2VydmVkQml0cykge1xuICAgICAgcmV0dXJuIHJlYWRDb250ZXh0KGNvbnRleHQsIG9ic2VydmVkQml0cyk7XG4gICAgfSxcbiAgICB1c2VDYWxsYmFjazogZnVuY3Rpb24gKGNhbGxiYWNrLCBkZXBzKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VDYWxsYmFjayc7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiB1cGRhdGVDYWxsYmFjayhjYWxsYmFjaywgZGVwcyk7XG4gICAgfSxcbiAgICB1c2VDb250ZXh0OiBmdW5jdGlvbiAoY29udGV4dCwgb2JzZXJ2ZWRCaXRzKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VDb250ZXh0JztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHJlYWRDb250ZXh0KGNvbnRleHQsIG9ic2VydmVkQml0cyk7XG4gICAgfSxcbiAgICB1c2VFZmZlY3Q6IGZ1bmN0aW9uIChjcmVhdGUsIGRlcHMpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUVmZmVjdCc7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiB1cGRhdGVFZmZlY3QoY3JlYXRlLCBkZXBzKTtcbiAgICB9LFxuICAgIHVzZUltcGVyYXRpdmVIYW5kbGU6IGZ1bmN0aW9uIChyZWYsIGNyZWF0ZSwgZGVwcykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlSW1wZXJhdGl2ZUhhbmRsZSc7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiB1cGRhdGVJbXBlcmF0aXZlSGFuZGxlKHJlZiwgY3JlYXRlLCBkZXBzKTtcbiAgICB9LFxuICAgIHVzZUxheW91dEVmZmVjdDogZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlTGF5b3V0RWZmZWN0JztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHVwZGF0ZUxheW91dEVmZmVjdChjcmVhdGUsIGRlcHMpO1xuICAgIH0sXG4gICAgdXNlTWVtbzogZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlTWVtbyc7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHZhciBwcmV2RGlzcGF0Y2hlciA9IFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50O1xuICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25SZXJlbmRlckluREVWO1xuXG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gdXBkYXRlTWVtbyhjcmVhdGUsIGRlcHMpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSBwcmV2RGlzcGF0Y2hlcjtcbiAgICAgIH1cbiAgICB9LFxuICAgIHVzZVJlZHVjZXI6IGZ1bmN0aW9uIChyZWR1Y2VyLCBpbml0aWFsQXJnLCBpbml0KSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VSZWR1Y2VyJztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgdmFyIHByZXZEaXNwYXRjaGVyID0gUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQ7XG4gICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudCA9IEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPblJlcmVuZGVySW5ERVY7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiByZXJlbmRlclJlZHVjZXIocmVkdWNlciwgaW5pdGlhbEFyZywgaW5pdCk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudCA9IHByZXZEaXNwYXRjaGVyO1xuICAgICAgfVxuICAgIH0sXG4gICAgdXNlUmVmOiBmdW5jdGlvbiAoaW5pdGlhbFZhbHVlKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VSZWYnO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gdXBkYXRlUmVmKCk7XG4gICAgfSxcbiAgICB1c2VTdGF0ZTogZnVuY3Rpb24gKGluaXRpYWxTdGF0ZSkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlU3RhdGUnO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICB2YXIgcHJldkRpc3BhdGNoZXIgPSBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudDtcbiAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uUmVyZW5kZXJJbkRFVjtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIHJlcmVuZGVyU3RhdGUoaW5pdGlhbFN0YXRlKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gcHJldkRpc3BhdGNoZXI7XG4gICAgICB9XG4gICAgfSxcbiAgICB1c2VEZWJ1Z1ZhbHVlOiBmdW5jdGlvbiAodmFsdWUsIGZvcm1hdHRlckZuKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VEZWJ1Z1ZhbHVlJztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHVwZGF0ZURlYnVnVmFsdWUoKTtcbiAgICB9LFxuICAgIHVzZURlZmVycmVkVmFsdWU6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlRGVmZXJyZWRWYWx1ZSc7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiByZXJlbmRlckRlZmVycmVkVmFsdWUodmFsdWUpO1xuICAgIH0sXG4gICAgdXNlVHJhbnNpdGlvbjogZnVuY3Rpb24gKCkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlVHJhbnNpdGlvbic7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiByZXJlbmRlclRyYW5zaXRpb24oKTtcbiAgICB9LFxuICAgIHVzZU11dGFibGVTb3VyY2U6IGZ1bmN0aW9uIChzb3VyY2UsIGdldFNuYXBzaG90LCBzdWJzY3JpYmUpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZU11dGFibGVTb3VyY2UnO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gdXBkYXRlTXV0YWJsZVNvdXJjZShzb3VyY2UsIGdldFNuYXBzaG90LCBzdWJzY3JpYmUpO1xuICAgIH0sXG4gICAgdXNlT3BhcXVlSWRlbnRpZmllcjogZnVuY3Rpb24gKCkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlT3BhcXVlSWRlbnRpZmllcic7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiByZXJlbmRlck9wYXF1ZUlkZW50aWZpZXIoKTtcbiAgICB9LFxuICAgIHVuc3RhYmxlX2lzTmV3UmVjb25jaWxlcjogZW5hYmxlTmV3UmVjb25jaWxlclxuICB9O1xuICBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25Nb3VudEluREVWID0ge1xuICAgIHJlYWRDb250ZXh0OiBmdW5jdGlvbiAoY29udGV4dCwgb2JzZXJ2ZWRCaXRzKSB7XG4gICAgICB3YXJuSW52YWxpZENvbnRleHRBY2Nlc3MoKTtcbiAgICAgIHJldHVybiByZWFkQ29udGV4dChjb250ZXh0LCBvYnNlcnZlZEJpdHMpO1xuICAgIH0sXG4gICAgdXNlQ2FsbGJhY2s6IGZ1bmN0aW9uIChjYWxsYmFjaywgZGVwcykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlQ2FsbGJhY2snO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIG1vdW50Q2FsbGJhY2soY2FsbGJhY2ssIGRlcHMpO1xuICAgIH0sXG4gICAgdXNlQ29udGV4dDogZnVuY3Rpb24gKGNvbnRleHQsIG9ic2VydmVkQml0cykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlQ29udGV4dCc7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gcmVhZENvbnRleHQoY29udGV4dCwgb2JzZXJ2ZWRCaXRzKTtcbiAgICB9LFxuICAgIHVzZUVmZmVjdDogZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlRWZmZWN0JztcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiBtb3VudEVmZmVjdChjcmVhdGUsIGRlcHMpO1xuICAgIH0sXG4gICAgdXNlSW1wZXJhdGl2ZUhhbmRsZTogZnVuY3Rpb24gKHJlZiwgY3JlYXRlLCBkZXBzKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VJbXBlcmF0aXZlSGFuZGxlJztcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiBtb3VudEltcGVyYXRpdmVIYW5kbGUocmVmLCBjcmVhdGUsIGRlcHMpO1xuICAgIH0sXG4gICAgdXNlTGF5b3V0RWZmZWN0OiBmdW5jdGlvbiAoY3JlYXRlLCBkZXBzKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VMYXlvdXRFZmZlY3QnO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIG1vdW50TGF5b3V0RWZmZWN0KGNyZWF0ZSwgZGVwcyk7XG4gICAgfSxcbiAgICB1c2VNZW1vOiBmdW5jdGlvbiAoY3JlYXRlLCBkZXBzKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VNZW1vJztcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgIHZhciBwcmV2RGlzcGF0Y2hlciA9IFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50O1xuICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25Nb3VudEluREVWO1xuXG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gbW91bnRNZW1vKGNyZWF0ZSwgZGVwcyk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudCA9IHByZXZEaXNwYXRjaGVyO1xuICAgICAgfVxuICAgIH0sXG4gICAgdXNlUmVkdWNlcjogZnVuY3Rpb24gKHJlZHVjZXIsIGluaXRpYWxBcmcsIGluaXQpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZVJlZHVjZXInO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgdmFyIHByZXZEaXNwYXRjaGVyID0gUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQ7XG4gICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudCA9IEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPbk1vdW50SW5ERVY7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBtb3VudFJlZHVjZXIocmVkdWNlciwgaW5pdGlhbEFyZywgaW5pdCk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudCA9IHByZXZEaXNwYXRjaGVyO1xuICAgICAgfVxuICAgIH0sXG4gICAgdXNlUmVmOiBmdW5jdGlvbiAoaW5pdGlhbFZhbHVlKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VSZWYnO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIG1vdW50UmVmKGluaXRpYWxWYWx1ZSk7XG4gICAgfSxcbiAgICB1c2VTdGF0ZTogZnVuY3Rpb24gKGluaXRpYWxTdGF0ZSkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlU3RhdGUnO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgdmFyIHByZXZEaXNwYXRjaGVyID0gUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQ7XG4gICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudCA9IEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPbk1vdW50SW5ERVY7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBtb3VudFN0YXRlKGluaXRpYWxTdGF0ZSk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudCA9IHByZXZEaXNwYXRjaGVyO1xuICAgICAgfVxuICAgIH0sXG4gICAgdXNlRGVidWdWYWx1ZTogZnVuY3Rpb24gKHZhbHVlLCBmb3JtYXR0ZXJGbikge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlRGVidWdWYWx1ZSc7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gbW91bnREZWJ1Z1ZhbHVlKCk7XG4gICAgfSxcbiAgICB1c2VEZWZlcnJlZFZhbHVlOiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZURlZmVycmVkVmFsdWUnO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIG1vdW50RGVmZXJyZWRWYWx1ZSh2YWx1ZSk7XG4gICAgfSxcbiAgICB1c2VUcmFuc2l0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VUcmFuc2l0aW9uJztcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiBtb3VudFRyYW5zaXRpb24oKTtcbiAgICB9LFxuICAgIHVzZU11dGFibGVTb3VyY2U6IGZ1bmN0aW9uIChzb3VyY2UsIGdldFNuYXBzaG90LCBzdWJzY3JpYmUpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZU11dGFibGVTb3VyY2UnO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIG1vdW50TXV0YWJsZVNvdXJjZShzb3VyY2UsIGdldFNuYXBzaG90LCBzdWJzY3JpYmUpO1xuICAgIH0sXG4gICAgdXNlT3BhcXVlSWRlbnRpZmllcjogZnVuY3Rpb24gKCkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlT3BhcXVlSWRlbnRpZmllcic7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gbW91bnRPcGFxdWVJZGVudGlmaWVyKCk7XG4gICAgfSxcbiAgICB1bnN0YWJsZV9pc05ld1JlY29uY2lsZXI6IGVuYWJsZU5ld1JlY29uY2lsZXJcbiAgfTtcbiAgSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uVXBkYXRlSW5ERVYgPSB7XG4gICAgcmVhZENvbnRleHQ6IGZ1bmN0aW9uIChjb250ZXh0LCBvYnNlcnZlZEJpdHMpIHtcbiAgICAgIHdhcm5JbnZhbGlkQ29udGV4dEFjY2VzcygpO1xuICAgICAgcmV0dXJuIHJlYWRDb250ZXh0KGNvbnRleHQsIG9ic2VydmVkQml0cyk7XG4gICAgfSxcbiAgICB1c2VDYWxsYmFjazogZnVuY3Rpb24gKGNhbGxiYWNrLCBkZXBzKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VDYWxsYmFjayc7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHVwZGF0ZUNhbGxiYWNrKGNhbGxiYWNrLCBkZXBzKTtcbiAgICB9LFxuICAgIHVzZUNvbnRleHQ6IGZ1bmN0aW9uIChjb250ZXh0LCBvYnNlcnZlZEJpdHMpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUNvbnRleHQnO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiByZWFkQ29udGV4dChjb250ZXh0LCBvYnNlcnZlZEJpdHMpO1xuICAgIH0sXG4gICAgdXNlRWZmZWN0OiBmdW5jdGlvbiAoY3JlYXRlLCBkZXBzKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VFZmZlY3QnO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiB1cGRhdGVFZmZlY3QoY3JlYXRlLCBkZXBzKTtcbiAgICB9LFxuICAgIHVzZUltcGVyYXRpdmVIYW5kbGU6IGZ1bmN0aW9uIChyZWYsIGNyZWF0ZSwgZGVwcykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlSW1wZXJhdGl2ZUhhbmRsZSc7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHVwZGF0ZUltcGVyYXRpdmVIYW5kbGUocmVmLCBjcmVhdGUsIGRlcHMpO1xuICAgIH0sXG4gICAgdXNlTGF5b3V0RWZmZWN0OiBmdW5jdGlvbiAoY3JlYXRlLCBkZXBzKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VMYXlvdXRFZmZlY3QnO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiB1cGRhdGVMYXlvdXRFZmZlY3QoY3JlYXRlLCBkZXBzKTtcbiAgICB9LFxuICAgIHVzZU1lbW86IGZ1bmN0aW9uIChjcmVhdGUsIGRlcHMpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZU1lbW8nO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHZhciBwcmV2RGlzcGF0Y2hlciA9IFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50O1xuICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25VcGRhdGVJbkRFVjtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIHVwZGF0ZU1lbW8oY3JlYXRlLCBkZXBzKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gcHJldkRpc3BhdGNoZXI7XG4gICAgICB9XG4gICAgfSxcbiAgICB1c2VSZWR1Y2VyOiBmdW5jdGlvbiAocmVkdWNlciwgaW5pdGlhbEFyZywgaW5pdCkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlUmVkdWNlcic7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgdmFyIHByZXZEaXNwYXRjaGVyID0gUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQ7XG4gICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudCA9IEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPblVwZGF0ZUluREVWO1xuXG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gdXBkYXRlUmVkdWNlcihyZWR1Y2VyLCBpbml0aWFsQXJnLCBpbml0KTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gcHJldkRpc3BhdGNoZXI7XG4gICAgICB9XG4gICAgfSxcbiAgICB1c2VSZWY6IGZ1bmN0aW9uIChpbml0aWFsVmFsdWUpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZVJlZic7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHVwZGF0ZVJlZigpO1xuICAgIH0sXG4gICAgdXNlU3RhdGU6IGZ1bmN0aW9uIChpbml0aWFsU3RhdGUpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZVN0YXRlJztcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICB2YXIgcHJldkRpc3BhdGNoZXIgPSBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudDtcbiAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uVXBkYXRlSW5ERVY7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiB1cGRhdGVTdGF0ZShpbml0aWFsU3RhdGUpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSBwcmV2RGlzcGF0Y2hlcjtcbiAgICAgIH1cbiAgICB9LFxuICAgIHVzZURlYnVnVmFsdWU6IGZ1bmN0aW9uICh2YWx1ZSwgZm9ybWF0dGVyRm4pIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZURlYnVnVmFsdWUnO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiB1cGRhdGVEZWJ1Z1ZhbHVlKCk7XG4gICAgfSxcbiAgICB1c2VEZWZlcnJlZFZhbHVlOiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZURlZmVycmVkVmFsdWUnO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiB1cGRhdGVEZWZlcnJlZFZhbHVlKHZhbHVlKTtcbiAgICB9LFxuICAgIHVzZVRyYW5zaXRpb246IGZ1bmN0aW9uICgpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZVRyYW5zaXRpb24nO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiB1cGRhdGVUcmFuc2l0aW9uKCk7XG4gICAgfSxcbiAgICB1c2VNdXRhYmxlU291cmNlOiBmdW5jdGlvbiAoc291cmNlLCBnZXRTbmFwc2hvdCwgc3Vic2NyaWJlKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VNdXRhYmxlU291cmNlJztcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gdXBkYXRlTXV0YWJsZVNvdXJjZShzb3VyY2UsIGdldFNuYXBzaG90LCBzdWJzY3JpYmUpO1xuICAgIH0sXG4gICAgdXNlT3BhcXVlSWRlbnRpZmllcjogZnVuY3Rpb24gKCkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlT3BhcXVlSWRlbnRpZmllcic7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHVwZGF0ZU9wYXF1ZUlkZW50aWZpZXIoKTtcbiAgICB9LFxuICAgIHVuc3RhYmxlX2lzTmV3UmVjb25jaWxlcjogZW5hYmxlTmV3UmVjb25jaWxlclxuICB9O1xuICBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25SZXJlbmRlckluREVWID0ge1xuICAgIHJlYWRDb250ZXh0OiBmdW5jdGlvbiAoY29udGV4dCwgb2JzZXJ2ZWRCaXRzKSB7XG4gICAgICB3YXJuSW52YWxpZENvbnRleHRBY2Nlc3MoKTtcbiAgICAgIHJldHVybiByZWFkQ29udGV4dChjb250ZXh0LCBvYnNlcnZlZEJpdHMpO1xuICAgIH0sXG4gICAgdXNlQ2FsbGJhY2s6IGZ1bmN0aW9uIChjYWxsYmFjaywgZGVwcykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlQ2FsbGJhY2snO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiB1cGRhdGVDYWxsYmFjayhjYWxsYmFjaywgZGVwcyk7XG4gICAgfSxcbiAgICB1c2VDb250ZXh0OiBmdW5jdGlvbiAoY29udGV4dCwgb2JzZXJ2ZWRCaXRzKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VDb250ZXh0JztcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gcmVhZENvbnRleHQoY29udGV4dCwgb2JzZXJ2ZWRCaXRzKTtcbiAgICB9LFxuICAgIHVzZUVmZmVjdDogZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlRWZmZWN0JztcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gdXBkYXRlRWZmZWN0KGNyZWF0ZSwgZGVwcyk7XG4gICAgfSxcbiAgICB1c2VJbXBlcmF0aXZlSGFuZGxlOiBmdW5jdGlvbiAocmVmLCBjcmVhdGUsIGRlcHMpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUltcGVyYXRpdmVIYW5kbGUnO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiB1cGRhdGVJbXBlcmF0aXZlSGFuZGxlKHJlZiwgY3JlYXRlLCBkZXBzKTtcbiAgICB9LFxuICAgIHVzZUxheW91dEVmZmVjdDogZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlTGF5b3V0RWZmZWN0JztcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gdXBkYXRlTGF5b3V0RWZmZWN0KGNyZWF0ZSwgZGVwcyk7XG4gICAgfSxcbiAgICB1c2VNZW1vOiBmdW5jdGlvbiAoY3JlYXRlLCBkZXBzKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VNZW1vJztcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICB2YXIgcHJldkRpc3BhdGNoZXIgPSBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudDtcbiAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uVXBkYXRlSW5ERVY7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiB1cGRhdGVNZW1vKGNyZWF0ZSwgZGVwcyk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudCA9IHByZXZEaXNwYXRjaGVyO1xuICAgICAgfVxuICAgIH0sXG4gICAgdXNlUmVkdWNlcjogZnVuY3Rpb24gKHJlZHVjZXIsIGluaXRpYWxBcmcsIGluaXQpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZVJlZHVjZXInO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHZhciBwcmV2RGlzcGF0Y2hlciA9IFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50O1xuICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25VcGRhdGVJbkRFVjtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIHJlcmVuZGVyUmVkdWNlcihyZWR1Y2VyLCBpbml0aWFsQXJnLCBpbml0KTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gcHJldkRpc3BhdGNoZXI7XG4gICAgICB9XG4gICAgfSxcbiAgICB1c2VSZWY6IGZ1bmN0aW9uIChpbml0aWFsVmFsdWUpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZVJlZic7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHVwZGF0ZVJlZigpO1xuICAgIH0sXG4gICAgdXNlU3RhdGU6IGZ1bmN0aW9uIChpbml0aWFsU3RhdGUpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZVN0YXRlJztcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICB2YXIgcHJldkRpc3BhdGNoZXIgPSBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudDtcbiAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uVXBkYXRlSW5ERVY7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiByZXJlbmRlclN0YXRlKGluaXRpYWxTdGF0ZSk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudCA9IHByZXZEaXNwYXRjaGVyO1xuICAgICAgfVxuICAgIH0sXG4gICAgdXNlRGVidWdWYWx1ZTogZnVuY3Rpb24gKHZhbHVlLCBmb3JtYXR0ZXJGbikge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlRGVidWdWYWx1ZSc7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHVwZGF0ZURlYnVnVmFsdWUoKTtcbiAgICB9LFxuICAgIHVzZURlZmVycmVkVmFsdWU6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlRGVmZXJyZWRWYWx1ZSc7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHJlcmVuZGVyRGVmZXJyZWRWYWx1ZSh2YWx1ZSk7XG4gICAgfSxcbiAgICB1c2VUcmFuc2l0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VUcmFuc2l0aW9uJztcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gcmVyZW5kZXJUcmFuc2l0aW9uKCk7XG4gICAgfSxcbiAgICB1c2VNdXRhYmxlU291cmNlOiBmdW5jdGlvbiAoc291cmNlLCBnZXRTbmFwc2hvdCwgc3Vic2NyaWJlKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VNdXRhYmxlU291cmNlJztcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gdXBkYXRlTXV0YWJsZVNvdXJjZShzb3VyY2UsIGdldFNuYXBzaG90LCBzdWJzY3JpYmUpO1xuICAgIH0sXG4gICAgdXNlT3BhcXVlSWRlbnRpZmllcjogZnVuY3Rpb24gKCkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlT3BhcXVlSWRlbnRpZmllcic7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHJlcmVuZGVyT3BhcXVlSWRlbnRpZmllcigpO1xuICAgIH0sXG4gICAgdW5zdGFibGVfaXNOZXdSZWNvbmNpbGVyOiBlbmFibGVOZXdSZWNvbmNpbGVyXG4gIH07XG59XG5cbnZhciBub3ckMSA9IFNjaGVkdWxlci51bnN0YWJsZV9ub3c7XG52YXIgY29tbWl0VGltZSA9IDA7XG52YXIgcHJvZmlsZXJTdGFydFRpbWUgPSAtMTtcblxuZnVuY3Rpb24gZ2V0Q29tbWl0VGltZSgpIHtcbiAgcmV0dXJuIGNvbW1pdFRpbWU7XG59XG5cbmZ1bmN0aW9uIHJlY29yZENvbW1pdFRpbWUoKSB7XG5cbiAgY29tbWl0VGltZSA9IG5vdyQxKCk7XG59XG5cbmZ1bmN0aW9uIHN0YXJ0UHJvZmlsZXJUaW1lcihmaWJlcikge1xuXG4gIHByb2ZpbGVyU3RhcnRUaW1lID0gbm93JDEoKTtcblxuICBpZiAoZmliZXIuYWN0dWFsU3RhcnRUaW1lIDwgMCkge1xuICAgIGZpYmVyLmFjdHVhbFN0YXJ0VGltZSA9IG5vdyQxKCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc3RvcFByb2ZpbGVyVGltZXJJZlJ1bm5pbmcoZmliZXIpIHtcblxuICBwcm9maWxlclN0YXJ0VGltZSA9IC0xO1xufVxuXG5mdW5jdGlvbiBzdG9wUHJvZmlsZXJUaW1lcklmUnVubmluZ0FuZFJlY29yZERlbHRhKGZpYmVyLCBvdmVycmlkZUJhc2VUaW1lKSB7XG5cbiAgaWYgKHByb2ZpbGVyU3RhcnRUaW1lID49IDApIHtcbiAgICB2YXIgZWxhcHNlZFRpbWUgPSBub3ckMSgpIC0gcHJvZmlsZXJTdGFydFRpbWU7XG4gICAgZmliZXIuYWN0dWFsRHVyYXRpb24gKz0gZWxhcHNlZFRpbWU7XG5cbiAgICBpZiAob3ZlcnJpZGVCYXNlVGltZSkge1xuICAgICAgZmliZXIuc2VsZkJhc2VEdXJhdGlvbiA9IGVsYXBzZWRUaW1lO1xuICAgIH1cblxuICAgIHByb2ZpbGVyU3RhcnRUaW1lID0gLTE7XG4gIH1cbn1cblxuZnVuY3Rpb24gdHJhbnNmZXJBY3R1YWxEdXJhdGlvbihmaWJlcikge1xuICAvLyBUcmFuc2ZlciB0aW1lIHNwZW50IHJlbmRlcmluZyB0aGVzZSBjaGlsZHJlbiBzbyB3ZSBkb24ndCBsb3NlIGl0XG4gIC8vIGFmdGVyIHdlIHJlcmVuZGVyLiBUaGlzIGlzIHVzZWQgYXMgYSBoZWxwZXIgaW4gc3BlY2lhbCBjYXNlc1xuICAvLyB3aGVyZSB3ZSBzaG91bGQgY291bnQgdGhlIHdvcmsgb2YgbXVsdGlwbGUgcGFzc2VzLlxuICB2YXIgY2hpbGQgPSBmaWJlci5jaGlsZDtcblxuICB3aGlsZSAoY2hpbGQpIHtcbiAgICBmaWJlci5hY3R1YWxEdXJhdGlvbiArPSBjaGlsZC5hY3R1YWxEdXJhdGlvbjtcbiAgICBjaGlsZCA9IGNoaWxkLnNpYmxpbmc7XG4gIH1cbn1cblxudmFyIFJlYWN0Q3VycmVudE93bmVyJDEgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdEN1cnJlbnRPd25lcjtcbnZhciBkaWRSZWNlaXZlVXBkYXRlID0gZmFsc2U7XG52YXIgZGlkV2FybkFib3V0QmFkQ2xhc3M7XG52YXIgZGlkV2FybkFib3V0TW9kdWxlUGF0dGVybkNvbXBvbmVudDtcbnZhciBkaWRXYXJuQWJvdXRDb250ZXh0VHlwZU9uRnVuY3Rpb25Db21wb25lbnQ7XG52YXIgZGlkV2FybkFib3V0R2V0RGVyaXZlZFN0YXRlT25GdW5jdGlvbkNvbXBvbmVudDtcbnZhciBkaWRXYXJuQWJvdXRGdW5jdGlvblJlZnM7XG52YXIgZGlkV2FybkFib3V0UmVhc3NpZ25pbmdQcm9wcztcbnZhciBkaWRXYXJuQWJvdXRSZXZlYWxPcmRlcjtcbnZhciBkaWRXYXJuQWJvdXRUYWlsT3B0aW9ucztcblxue1xuICBkaWRXYXJuQWJvdXRCYWRDbGFzcyA9IHt9O1xuICBkaWRXYXJuQWJvdXRNb2R1bGVQYXR0ZXJuQ29tcG9uZW50ID0ge307XG4gIGRpZFdhcm5BYm91dENvbnRleHRUeXBlT25GdW5jdGlvbkNvbXBvbmVudCA9IHt9O1xuICBkaWRXYXJuQWJvdXRHZXREZXJpdmVkU3RhdGVPbkZ1bmN0aW9uQ29tcG9uZW50ID0ge307XG4gIGRpZFdhcm5BYm91dEZ1bmN0aW9uUmVmcyA9IHt9O1xuICBkaWRXYXJuQWJvdXRSZWFzc2lnbmluZ1Byb3BzID0gZmFsc2U7XG4gIGRpZFdhcm5BYm91dFJldmVhbE9yZGVyID0ge307XG4gIGRpZFdhcm5BYm91dFRhaWxPcHRpb25zID0ge307XG59XG5cbmZ1bmN0aW9uIHJlY29uY2lsZUNoaWxkcmVuKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBuZXh0Q2hpbGRyZW4sIHJlbmRlckxhbmVzKSB7XG4gIGlmIChjdXJyZW50ID09PSBudWxsKSB7XG4gICAgLy8gSWYgdGhpcyBpcyBhIGZyZXNoIG5ldyBjb21wb25lbnQgdGhhdCBoYXNuJ3QgYmVlbiByZW5kZXJlZCB5ZXQsIHdlXG4gICAgLy8gd29uJ3QgdXBkYXRlIGl0cyBjaGlsZCBzZXQgYnkgYXBwbHlpbmcgbWluaW1hbCBzaWRlLWVmZmVjdHMuIEluc3RlYWQsXG4gICAgLy8gd2Ugd2lsbCBhZGQgdGhlbSBhbGwgdG8gdGhlIGNoaWxkIGJlZm9yZSBpdCBnZXRzIHJlbmRlcmVkLiBUaGF0IG1lYW5zXG4gICAgLy8gd2UgY2FuIG9wdGltaXplIHRoaXMgcmVjb25jaWxpYXRpb24gcGFzcyBieSBub3QgdHJhY2tpbmcgc2lkZS1lZmZlY3RzLlxuICAgIHdvcmtJblByb2dyZXNzLmNoaWxkID0gbW91bnRDaGlsZEZpYmVycyh3b3JrSW5Qcm9ncmVzcywgbnVsbCwgbmV4dENoaWxkcmVuLCByZW5kZXJMYW5lcyk7XG4gIH0gZWxzZSB7XG4gICAgLy8gSWYgdGhlIGN1cnJlbnQgY2hpbGQgaXMgdGhlIHNhbWUgYXMgdGhlIHdvcmsgaW4gcHJvZ3Jlc3MsIGl0IG1lYW5zIHRoYXRcbiAgICAvLyB3ZSBoYXZlbid0IHlldCBzdGFydGVkIGFueSB3b3JrIG9uIHRoZXNlIGNoaWxkcmVuLiBUaGVyZWZvcmUsIHdlIHVzZVxuICAgIC8vIHRoZSBjbG9uZSBhbGdvcml0aG0gdG8gY3JlYXRlIGEgY29weSBvZiBhbGwgdGhlIGN1cnJlbnQgY2hpbGRyZW4uXG4gICAgLy8gSWYgd2UgaGFkIGFueSBwcm9ncmVzc2VkIHdvcmsgYWxyZWFkeSwgdGhhdCBpcyBpbnZhbGlkIGF0IHRoaXMgcG9pbnQgc29cbiAgICAvLyBsZXQncyB0aHJvdyBpdCBvdXQuXG4gICAgd29ya0luUHJvZ3Jlc3MuY2hpbGQgPSByZWNvbmNpbGVDaGlsZEZpYmVycyh3b3JrSW5Qcm9ncmVzcywgY3VycmVudC5jaGlsZCwgbmV4dENoaWxkcmVuLCByZW5kZXJMYW5lcyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZm9yY2VVbm1vdW50Q3VycmVudEFuZFJlY29uY2lsZShjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbmV4dENoaWxkcmVuLCByZW5kZXJMYW5lcykge1xuICAvLyBUaGlzIGZ1bmN0aW9uIGlzIGZvcmsgb2YgcmVjb25jaWxlQ2hpbGRyZW4uIEl0J3MgdXNlZCBpbiBjYXNlcyB3aGVyZSB3ZVxuICAvLyB3YW50IHRvIHJlY29uY2lsZSB3aXRob3V0IG1hdGNoaW5nIGFnYWluc3QgdGhlIGV4aXN0aW5nIHNldC4gVGhpcyBoYXMgdGhlXG4gIC8vIGVmZmVjdCBvZiBhbGwgY3VycmVudCBjaGlsZHJlbiBiZWluZyB1bm1vdW50ZWQ7IGV2ZW4gaWYgdGhlIHR5cGUgYW5kIGtleVxuICAvLyBhcmUgdGhlIHNhbWUsIHRoZSBvbGQgY2hpbGQgaXMgdW5tb3VudGVkIGFuZCBhIG5ldyBjaGlsZCBpcyBjcmVhdGVkLlxuICAvL1xuICAvLyBUbyBkbyB0aGlzLCB3ZSdyZSBnb2luZyB0byBnbyB0aHJvdWdoIHRoZSByZWNvbmNpbGUgYWxnb3JpdGhtIHR3aWNlLiBJblxuICAvLyB0aGUgZmlyc3QgcGFzcywgd2Ugc2NoZWR1bGUgYSBkZWxldGlvbiBmb3IgYWxsIHRoZSBjdXJyZW50IGNoaWxkcmVuIGJ5XG4gIC8vIHBhc3NpbmcgbnVsbC5cbiAgd29ya0luUHJvZ3Jlc3MuY2hpbGQgPSByZWNvbmNpbGVDaGlsZEZpYmVycyh3b3JrSW5Qcm9ncmVzcywgY3VycmVudC5jaGlsZCwgbnVsbCwgcmVuZGVyTGFuZXMpOyAvLyBJbiB0aGUgc2Vjb25kIHBhc3MsIHdlIG1vdW50IHRoZSBuZXcgY2hpbGRyZW4uIFRoZSB0cmljayBoZXJlIGlzIHRoYXQgd2VcbiAgLy8gcGFzcyBudWxsIGluIHBsYWNlIG9mIHdoZXJlIHdlIHVzdWFsbHkgcGFzcyB0aGUgY3VycmVudCBjaGlsZCBzZXQuIFRoaXMgaGFzXG4gIC8vIHRoZSBlZmZlY3Qgb2YgcmVtb3VudGluZyBhbGwgY2hpbGRyZW4gcmVnYXJkbGVzcyBvZiB3aGV0aGVyIHRoZWlyXG4gIC8vIGlkZW50aXRpZXMgbWF0Y2guXG5cbiAgd29ya0luUHJvZ3Jlc3MuY2hpbGQgPSByZWNvbmNpbGVDaGlsZEZpYmVycyh3b3JrSW5Qcm9ncmVzcywgbnVsbCwgbmV4dENoaWxkcmVuLCByZW5kZXJMYW5lcyk7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUZvcndhcmRSZWYoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIENvbXBvbmVudCwgbmV4dFByb3BzLCByZW5kZXJMYW5lcykge1xuICAvLyBUT0RPOiBjdXJyZW50IGNhbiBiZSBub24tbnVsbCBoZXJlIGV2ZW4gaWYgdGhlIGNvbXBvbmVudFxuICAvLyBoYXNuJ3QgeWV0IG1vdW50ZWQuIFRoaXMgaGFwcGVucyBhZnRlciB0aGUgZmlyc3QgcmVuZGVyIHN1c3BlbmRzLlxuICAvLyBXZSdsbCBuZWVkIHRvIGZpZ3VyZSBvdXQgaWYgdGhpcyBpcyBmaW5lIG9yIGNhbiBjYXVzZSBpc3N1ZXMuXG4gIHtcbiAgICBpZiAod29ya0luUHJvZ3Jlc3MudHlwZSAhPT0gd29ya0luUHJvZ3Jlc3MuZWxlbWVudFR5cGUpIHtcbiAgICAgIC8vIExhenkgY29tcG9uZW50IHByb3BzIGNhbid0IGJlIHZhbGlkYXRlZCBpbiBjcmVhdGVFbGVtZW50XG4gICAgICAvLyBiZWNhdXNlIHRoZXkncmUgb25seSBndWFyYW50ZWVkIHRvIGJlIHJlc29sdmVkIGhlcmUuXG4gICAgICB2YXIgaW5uZXJQcm9wVHlwZXMgPSBDb21wb25lbnQucHJvcFR5cGVzO1xuXG4gICAgICBpZiAoaW5uZXJQcm9wVHlwZXMpIHtcbiAgICAgICAgY2hlY2tQcm9wVHlwZXMoaW5uZXJQcm9wVHlwZXMsIG5leHRQcm9wcywgLy8gUmVzb2x2ZWQgcHJvcHNcbiAgICAgICAgJ3Byb3AnLCBnZXRDb21wb25lbnROYW1lKENvbXBvbmVudCkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciByZW5kZXIgPSBDb21wb25lbnQucmVuZGVyO1xuICB2YXIgcmVmID0gd29ya0luUHJvZ3Jlc3MucmVmOyAvLyBUaGUgcmVzdCBpcyBhIGZvcmsgb2YgdXBkYXRlRnVuY3Rpb25Db21wb25lbnRcblxuICB2YXIgbmV4dENoaWxkcmVuO1xuICBwcmVwYXJlVG9SZWFkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpO1xuXG4gIHtcbiAgICBSZWFjdEN1cnJlbnRPd25lciQxLmN1cnJlbnQgPSB3b3JrSW5Qcm9ncmVzcztcbiAgICBzZXRJc1JlbmRlcmluZyh0cnVlKTtcbiAgICBuZXh0Q2hpbGRyZW4gPSByZW5kZXJXaXRoSG9va3MoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlciwgbmV4dFByb3BzLCByZWYsIHJlbmRlckxhbmVzKTtcblxuICAgIGlmICggd29ya0luUHJvZ3Jlc3MubW9kZSAmIFN0cmljdE1vZGUpIHtcbiAgICAgIGRpc2FibGVMb2dzKCk7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIG5leHRDaGlsZHJlbiA9IHJlbmRlcldpdGhIb29rcyhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyLCBuZXh0UHJvcHMsIHJlZiwgcmVuZGVyTGFuZXMpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgcmVlbmFibGVMb2dzKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgc2V0SXNSZW5kZXJpbmcoZmFsc2UpO1xuICB9XG5cbiAgaWYgKGN1cnJlbnQgIT09IG51bGwgJiYgIWRpZFJlY2VpdmVVcGRhdGUpIHtcbiAgICBiYWlsb3V0SG9va3MoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKTtcbiAgICByZXR1cm4gYmFpbG91dE9uQWxyZWFkeUZpbmlzaGVkV29yayhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpO1xuICB9IC8vIFJlYWN0IERldlRvb2xzIHJlYWRzIHRoaXMgZmxhZy5cblxuXG4gIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IFBlcmZvcm1lZFdvcms7XG4gIHJlY29uY2lsZUNoaWxkcmVuKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBuZXh0Q2hpbGRyZW4sIHJlbmRlckxhbmVzKTtcbiAgcmV0dXJuIHdvcmtJblByb2dyZXNzLmNoaWxkO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVNZW1vQ29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQsIG5leHRQcm9wcywgdXBkYXRlTGFuZXMsIHJlbmRlckxhbmVzKSB7XG4gIGlmIChjdXJyZW50ID09PSBudWxsKSB7XG4gICAgdmFyIHR5cGUgPSBDb21wb25lbnQudHlwZTtcblxuICAgIGlmIChpc1NpbXBsZUZ1bmN0aW9uQ29tcG9uZW50KHR5cGUpICYmIENvbXBvbmVudC5jb21wYXJlID09PSBudWxsICYmIC8vIFNpbXBsZU1lbW9Db21wb25lbnQgY29kZXBhdGggZG9lc24ndCByZXNvbHZlIG91dGVyIHByb3BzIGVpdGhlci5cbiAgICBDb21wb25lbnQuZGVmYXVsdFByb3BzID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHZhciByZXNvbHZlZFR5cGUgPSB0eXBlO1xuXG4gICAgICB7XG4gICAgICAgIHJlc29sdmVkVHlwZSA9IHJlc29sdmVGdW5jdGlvbkZvckhvdFJlbG9hZGluZyh0eXBlKTtcbiAgICAgIH0gLy8gSWYgdGhpcyBpcyBhIHBsYWluIGZ1bmN0aW9uIGNvbXBvbmVudCB3aXRob3V0IGRlZmF1bHQgcHJvcHMsXG4gICAgICAvLyBhbmQgd2l0aCBvbmx5IHRoZSBkZWZhdWx0IHNoYWxsb3cgY29tcGFyaXNvbiwgd2UgdXBncmFkZSBpdFxuICAgICAgLy8gdG8gYSBTaW1wbGVNZW1vQ29tcG9uZW50IHRvIGFsbG93IGZhc3QgcGF0aCB1cGRhdGVzLlxuXG5cbiAgICAgIHdvcmtJblByb2dyZXNzLnRhZyA9IFNpbXBsZU1lbW9Db21wb25lbnQ7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy50eXBlID0gcmVzb2x2ZWRUeXBlO1xuXG4gICAgICB7XG4gICAgICAgIHZhbGlkYXRlRnVuY3Rpb25Db21wb25lbnRJbkRldih3b3JrSW5Qcm9ncmVzcywgdHlwZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB1cGRhdGVTaW1wbGVNZW1vQ29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZXNvbHZlZFR5cGUsIG5leHRQcm9wcywgdXBkYXRlTGFuZXMsIHJlbmRlckxhbmVzKTtcbiAgICB9XG5cbiAgICB7XG4gICAgICB2YXIgaW5uZXJQcm9wVHlwZXMgPSB0eXBlLnByb3BUeXBlcztcblxuICAgICAgaWYgKGlubmVyUHJvcFR5cGVzKSB7XG4gICAgICAgIC8vIElubmVyIG1lbW8gY29tcG9uZW50IHByb3BzIGFyZW4ndCBjdXJyZW50bHkgdmFsaWRhdGVkIGluIGNyZWF0ZUVsZW1lbnQuXG4gICAgICAgIC8vIFdlIGNvdWxkIG1vdmUgaXQgdGhlcmUsIGJ1dCB3ZSdkIHN0aWxsIG5lZWQgdGhpcyBmb3IgbGF6eSBjb2RlIHBhdGguXG4gICAgICAgIGNoZWNrUHJvcFR5cGVzKGlubmVyUHJvcFR5cGVzLCBuZXh0UHJvcHMsIC8vIFJlc29sdmVkIHByb3BzXG4gICAgICAgICdwcm9wJywgZ2V0Q29tcG9uZW50TmFtZSh0eXBlKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGNoaWxkID0gY3JlYXRlRmliZXJGcm9tVHlwZUFuZFByb3BzKENvbXBvbmVudC50eXBlLCBudWxsLCBuZXh0UHJvcHMsIHdvcmtJblByb2dyZXNzLCB3b3JrSW5Qcm9ncmVzcy5tb2RlLCByZW5kZXJMYW5lcyk7XG4gICAgY2hpbGQucmVmID0gd29ya0luUHJvZ3Jlc3MucmVmO1xuICAgIGNoaWxkLnJldHVybiA9IHdvcmtJblByb2dyZXNzO1xuICAgIHdvcmtJblByb2dyZXNzLmNoaWxkID0gY2hpbGQ7XG4gICAgcmV0dXJuIGNoaWxkO1xuICB9XG5cbiAge1xuICAgIHZhciBfdHlwZSA9IENvbXBvbmVudC50eXBlO1xuICAgIHZhciBfaW5uZXJQcm9wVHlwZXMgPSBfdHlwZS5wcm9wVHlwZXM7XG5cbiAgICBpZiAoX2lubmVyUHJvcFR5cGVzKSB7XG4gICAgICAvLyBJbm5lciBtZW1vIGNvbXBvbmVudCBwcm9wcyBhcmVuJ3QgY3VycmVudGx5IHZhbGlkYXRlZCBpbiBjcmVhdGVFbGVtZW50LlxuICAgICAgLy8gV2UgY291bGQgbW92ZSBpdCB0aGVyZSwgYnV0IHdlJ2Qgc3RpbGwgbmVlZCB0aGlzIGZvciBsYXp5IGNvZGUgcGF0aC5cbiAgICAgIGNoZWNrUHJvcFR5cGVzKF9pbm5lclByb3BUeXBlcywgbmV4dFByb3BzLCAvLyBSZXNvbHZlZCBwcm9wc1xuICAgICAgJ3Byb3AnLCBnZXRDb21wb25lbnROYW1lKF90eXBlKSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIGN1cnJlbnRDaGlsZCA9IGN1cnJlbnQuY2hpbGQ7IC8vIFRoaXMgaXMgYWx3YXlzIGV4YWN0bHkgb25lIGNoaWxkXG5cbiAgaWYgKCFpbmNsdWRlc1NvbWVMYW5lKHVwZGF0ZUxhbmVzLCByZW5kZXJMYW5lcykpIHtcbiAgICAvLyBUaGlzIHdpbGwgYmUgdGhlIHByb3BzIHdpdGggcmVzb2x2ZWQgZGVmYXVsdFByb3BzLFxuICAgIC8vIHVubGlrZSBjdXJyZW50Lm1lbW9pemVkUHJvcHMgd2hpY2ggd2lsbCBiZSB0aGUgdW5yZXNvbHZlZCBvbmVzLlxuICAgIHZhciBwcmV2UHJvcHMgPSBjdXJyZW50Q2hpbGQubWVtb2l6ZWRQcm9wczsgLy8gRGVmYXVsdCB0byBzaGFsbG93IGNvbXBhcmlzb25cblxuICAgIHZhciBjb21wYXJlID0gQ29tcG9uZW50LmNvbXBhcmU7XG4gICAgY29tcGFyZSA9IGNvbXBhcmUgIT09IG51bGwgPyBjb21wYXJlIDogc2hhbGxvd0VxdWFsO1xuXG4gICAgaWYgKGNvbXBhcmUocHJldlByb3BzLCBuZXh0UHJvcHMpICYmIGN1cnJlbnQucmVmID09PSB3b3JrSW5Qcm9ncmVzcy5yZWYpIHtcbiAgICAgIHJldHVybiBiYWlsb3V0T25BbHJlYWR5RmluaXNoZWRXb3JrKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcyk7XG4gICAgfVxuICB9IC8vIFJlYWN0IERldlRvb2xzIHJlYWRzIHRoaXMgZmxhZy5cblxuXG4gIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IFBlcmZvcm1lZFdvcms7XG4gIHZhciBuZXdDaGlsZCA9IGNyZWF0ZVdvcmtJblByb2dyZXNzKGN1cnJlbnRDaGlsZCwgbmV4dFByb3BzKTtcbiAgbmV3Q2hpbGQucmVmID0gd29ya0luUHJvZ3Jlc3MucmVmO1xuICBuZXdDaGlsZC5yZXR1cm4gPSB3b3JrSW5Qcm9ncmVzcztcbiAgd29ya0luUHJvZ3Jlc3MuY2hpbGQgPSBuZXdDaGlsZDtcbiAgcmV0dXJuIG5ld0NoaWxkO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVTaW1wbGVNZW1vQ29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQsIG5leHRQcm9wcywgdXBkYXRlTGFuZXMsIHJlbmRlckxhbmVzKSB7XG4gIC8vIFRPRE86IGN1cnJlbnQgY2FuIGJlIG5vbi1udWxsIGhlcmUgZXZlbiBpZiB0aGUgY29tcG9uZW50XG4gIC8vIGhhc24ndCB5ZXQgbW91bnRlZC4gVGhpcyBoYXBwZW5zIHdoZW4gdGhlIGlubmVyIHJlbmRlciBzdXNwZW5kcy5cbiAgLy8gV2UnbGwgbmVlZCB0byBmaWd1cmUgb3V0IGlmIHRoaXMgaXMgZmluZSBvciBjYW4gY2F1c2UgaXNzdWVzLlxuICB7XG4gICAgaWYgKHdvcmtJblByb2dyZXNzLnR5cGUgIT09IHdvcmtJblByb2dyZXNzLmVsZW1lbnRUeXBlKSB7XG4gICAgICAvLyBMYXp5IGNvbXBvbmVudCBwcm9wcyBjYW4ndCBiZSB2YWxpZGF0ZWQgaW4gY3JlYXRlRWxlbWVudFxuICAgICAgLy8gYmVjYXVzZSB0aGV5J3JlIG9ubHkgZ3VhcmFudGVlZCB0byBiZSByZXNvbHZlZCBoZXJlLlxuICAgICAgdmFyIG91dGVyTWVtb1R5cGUgPSB3b3JrSW5Qcm9ncmVzcy5lbGVtZW50VHlwZTtcblxuICAgICAgaWYgKG91dGVyTWVtb1R5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0xBWllfVFlQRSkge1xuICAgICAgICAvLyBXZSB3YXJuIHdoZW4geW91IGRlZmluZSBwcm9wVHlwZXMgb24gbGF6eSgpXG4gICAgICAgIC8vIHNvIGxldCdzIGp1c3Qgc2tpcCBvdmVyIGl0IHRvIGZpbmQgbWVtbygpIG91dGVyIHdyYXBwZXIuXG4gICAgICAgIC8vIElubmVyIHByb3BzIGZvciBtZW1vIGFyZSB2YWxpZGF0ZWQgbGF0ZXIuXG4gICAgICAgIHZhciBsYXp5Q29tcG9uZW50ID0gb3V0ZXJNZW1vVHlwZTtcbiAgICAgICAgdmFyIHBheWxvYWQgPSBsYXp5Q29tcG9uZW50Ll9wYXlsb2FkO1xuICAgICAgICB2YXIgaW5pdCA9IGxhenlDb21wb25lbnQuX2luaXQ7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBvdXRlck1lbW9UeXBlID0gaW5pdChwYXlsb2FkKTtcbiAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgIG91dGVyTWVtb1R5cGUgPSBudWxsO1xuICAgICAgICB9IC8vIElubmVyIHByb3BUeXBlcyB3aWxsIGJlIHZhbGlkYXRlZCBpbiB0aGUgZnVuY3Rpb24gY29tcG9uZW50IHBhdGguXG5cblxuICAgICAgICB2YXIgb3V0ZXJQcm9wVHlwZXMgPSBvdXRlck1lbW9UeXBlICYmIG91dGVyTWVtb1R5cGUucHJvcFR5cGVzO1xuXG4gICAgICAgIGlmIChvdXRlclByb3BUeXBlcykge1xuICAgICAgICAgIGNoZWNrUHJvcFR5cGVzKG91dGVyUHJvcFR5cGVzLCBuZXh0UHJvcHMsIC8vIFJlc29sdmVkIChTaW1wbGVNZW1vQ29tcG9uZW50IGhhcyBubyBkZWZhdWx0UHJvcHMpXG4gICAgICAgICAgJ3Byb3AnLCBnZXRDb21wb25lbnROYW1lKG91dGVyTWVtb1R5cGUpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChjdXJyZW50ICE9PSBudWxsKSB7XG4gICAgdmFyIHByZXZQcm9wcyA9IGN1cnJlbnQubWVtb2l6ZWRQcm9wcztcblxuICAgIGlmIChzaGFsbG93RXF1YWwocHJldlByb3BzLCBuZXh0UHJvcHMpICYmIGN1cnJlbnQucmVmID09PSB3b3JrSW5Qcm9ncmVzcy5yZWYgJiYgKCAvLyBQcmV2ZW50IGJhaWxvdXQgaWYgdGhlIGltcGxlbWVudGF0aW9uIGNoYW5nZWQgZHVlIHRvIGhvdCByZWxvYWQuXG4gICAgIHdvcmtJblByb2dyZXNzLnR5cGUgPT09IGN1cnJlbnQudHlwZSApKSB7XG4gICAgICBkaWRSZWNlaXZlVXBkYXRlID0gZmFsc2U7XG5cbiAgICAgIGlmICghaW5jbHVkZXNTb21lTGFuZShyZW5kZXJMYW5lcywgdXBkYXRlTGFuZXMpKSB7XG4gICAgICAgIC8vIFRoZSBwZW5kaW5nIGxhbmVzIHdlcmUgY2xlYXJlZCBhdCB0aGUgYmVnaW5uaW5nIG9mIGJlZ2luV29yay4gV2UncmVcbiAgICAgICAgLy8gYWJvdXQgdG8gYmFpbCBvdXQsIGJ1dCB0aGVyZSBtaWdodCBiZSBvdGhlciBsYW5lcyB0aGF0IHdlcmVuJ3RcbiAgICAgICAgLy8gaW5jbHVkZWQgaW4gdGhlIGN1cnJlbnQgcmVuZGVyLiBVc3VhbGx5LCB0aGUgcHJpb3JpdHkgbGV2ZWwgb2YgdGhlXG4gICAgICAgIC8vIHJlbWFpbmluZyB1cGRhdGVzIGlzIGFjY3VtbGF0ZWQgZHVyaW5nIHRoZSBldmFsdWF0aW9uIG9mIHRoZVxuICAgICAgICAvLyBjb21wb25lbnQgKGkuZS4gd2hlbiBwcm9jZXNzaW5nIHRoZSB1cGRhdGUgcXVldWUpLiBCdXQgc2luY2Ugc2luY2VcbiAgICAgICAgLy8gd2UncmUgYmFpbGluZyBvdXQgZWFybHkgKndpdGhvdXQqIGV2YWx1YXRpbmcgdGhlIGNvbXBvbmVudCwgd2UgbmVlZFxuICAgICAgICAvLyB0byBhY2NvdW50IGZvciBpdCBoZXJlLCB0b28uIFJlc2V0IHRvIHRoZSB2YWx1ZSBvZiB0aGUgY3VycmVudCBmaWJlci5cbiAgICAgICAgLy8gTk9URTogVGhpcyBvbmx5IGFwcGxpZXMgdG8gU2ltcGxlTWVtb0NvbXBvbmVudCwgbm90IE1lbW9Db21wb25lbnQsXG4gICAgICAgIC8vIGJlY2F1c2UgYSBNZW1vQ29tcG9uZW50IGZpYmVyIGRvZXMgbm90IGhhdmUgaG9va3Mgb3IgYW4gdXBkYXRlIHF1ZXVlO1xuICAgICAgICAvLyByYXRoZXIsIGl0IHdyYXBzIGFyb3VuZCBhbiBpbm5lciBjb21wb25lbnQsIHdoaWNoIG1heSBvciBtYXkgbm90XG4gICAgICAgIC8vIGNvbnRhaW5zIGhvb2tzLlxuICAgICAgICAvLyBUT0RPOiBNb3ZlIHRoZSByZXNldCBhdCBpbiBiZWdpbldvcmsgb3V0IG9mIHRoZSBjb21tb24gcGF0aCBzbyB0aGF0XG4gICAgICAgIC8vIHRoaXMgaXMgbm8gbG9uZ2VyIG5lY2Vzc2FyeS5cbiAgICAgICAgd29ya0luUHJvZ3Jlc3MubGFuZXMgPSBjdXJyZW50LmxhbmVzO1xuICAgICAgICByZXR1cm4gYmFpbG91dE9uQWxyZWFkeUZpbmlzaGVkV29yayhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpO1xuICAgICAgfSBlbHNlIGlmICgoY3VycmVudC5mbGFncyAmIEZvcmNlVXBkYXRlRm9yTGVnYWN5U3VzcGVuc2UpICE9PSBOb0ZsYWdzKSB7XG4gICAgICAgIC8vIFRoaXMgaXMgYSBzcGVjaWFsIGNhc2UgdGhhdCBvbmx5IGV4aXN0cyBmb3IgbGVnYWN5IG1vZGUuXG4gICAgICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvcHVsbC8xOTIxNi5cbiAgICAgICAgZGlkUmVjZWl2ZVVwZGF0ZSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHVwZGF0ZUZ1bmN0aW9uQ29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQsIG5leHRQcm9wcywgcmVuZGVyTGFuZXMpO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVPZmZzY3JlZW5Db21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKSB7XG4gIHZhciBuZXh0UHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7XG4gIHZhciBuZXh0Q2hpbGRyZW4gPSBuZXh0UHJvcHMuY2hpbGRyZW47XG4gIHZhciBwcmV2U3RhdGUgPSBjdXJyZW50ICE9PSBudWxsID8gY3VycmVudC5tZW1vaXplZFN0YXRlIDogbnVsbDtcblxuICBpZiAobmV4dFByb3BzLm1vZGUgPT09ICdoaWRkZW4nIHx8IG5leHRQcm9wcy5tb2RlID09PSAndW5zdGFibGUtZGVmZXItd2l0aG91dC1oaWRpbmcnKSB7XG4gICAgaWYgKCh3b3JrSW5Qcm9ncmVzcy5tb2RlICYgQ29uY3VycmVudE1vZGUpID09PSBOb01vZGUpIHtcbiAgICAgIC8vIEluIGxlZ2FjeSBzeW5jIG1vZGUsIGRvbid0IGRlZmVyIHRoZSBzdWJ0cmVlLiBSZW5kZXIgaXQgbm93LlxuICAgICAgLy8gVE9ETzogRmlndXJlIG91dCB3aGF0IHdlIHNob3VsZCBkbyBpbiBCbG9ja2luZyBtb2RlLlxuICAgICAgdmFyIG5leHRTdGF0ZSA9IHtcbiAgICAgICAgYmFzZUxhbmVzOiBOb0xhbmVzXG4gICAgICB9O1xuICAgICAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IG5leHRTdGF0ZTtcbiAgICAgIHB1c2hSZW5kZXJMYW5lcyh3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpO1xuICAgIH0gZWxzZSBpZiAoIWluY2x1ZGVzU29tZUxhbmUocmVuZGVyTGFuZXMsIE9mZnNjcmVlbkxhbmUpKSB7XG4gICAgICB2YXIgbmV4dEJhc2VMYW5lcztcblxuICAgICAgaWYgKHByZXZTdGF0ZSAhPT0gbnVsbCkge1xuICAgICAgICB2YXIgcHJldkJhc2VMYW5lcyA9IHByZXZTdGF0ZS5iYXNlTGFuZXM7XG4gICAgICAgIG5leHRCYXNlTGFuZXMgPSBtZXJnZUxhbmVzKHByZXZCYXNlTGFuZXMsIHJlbmRlckxhbmVzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5leHRCYXNlTGFuZXMgPSByZW5kZXJMYW5lcztcbiAgICAgIH0gLy8gU2NoZWR1bGUgdGhpcyBmaWJlciB0byByZS1yZW5kZXIgYXQgb2Zmc2NyZWVuIHByaW9yaXR5LiBUaGVuIGJhaWxvdXQuXG5cblxuICAgICAge1xuICAgICAgICBtYXJrU3Bhd25lZFdvcmsoT2Zmc2NyZWVuTGFuZSk7XG4gICAgICB9XG5cbiAgICAgIHdvcmtJblByb2dyZXNzLmxhbmVzID0gd29ya0luUHJvZ3Jlc3MuY2hpbGRMYW5lcyA9IGxhbmVUb0xhbmVzKE9mZnNjcmVlbkxhbmUpO1xuICAgICAgdmFyIF9uZXh0U3RhdGUgPSB7XG4gICAgICAgIGJhc2VMYW5lczogbmV4dEJhc2VMYW5lc1xuICAgICAgfTtcbiAgICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBfbmV4dFN0YXRlOyAvLyBXZSdyZSBhYm91dCB0byBiYWlsIG91dCwgYnV0IHdlIG5lZWQgdG8gcHVzaCB0aGlzIHRvIHRoZSBzdGFjayBhbnl3YXlcbiAgICAgIC8vIHRvIGF2b2lkIGEgcHVzaC9wb3AgbWlzYWxpZ25tZW50LlxuXG4gICAgICBwdXNoUmVuZGVyTGFuZXMod29ya0luUHJvZ3Jlc3MsIG5leHRCYXNlTGFuZXMpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFJlbmRlcmluZyBhdCBvZmZzY3JlZW4sIHNvIHdlIGNhbiBjbGVhciB0aGUgYmFzZSBsYW5lcy5cbiAgICAgIHZhciBfbmV4dFN0YXRlMiA9IHtcbiAgICAgICAgYmFzZUxhbmVzOiBOb0xhbmVzXG4gICAgICB9O1xuICAgICAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IF9uZXh0U3RhdGUyOyAvLyBQdXNoIHRoZSBsYW5lcyB0aGF0IHdlcmUgc2tpcHBlZCB3aGVuIHdlIGJhaWxlZCBvdXQuXG5cbiAgICAgIHZhciBzdWJ0cmVlUmVuZGVyTGFuZXMgPSBwcmV2U3RhdGUgIT09IG51bGwgPyBwcmV2U3RhdGUuYmFzZUxhbmVzIDogcmVuZGVyTGFuZXM7XG4gICAgICBwdXNoUmVuZGVyTGFuZXMod29ya0luUHJvZ3Jlc3MsIHN1YnRyZWVSZW5kZXJMYW5lcyk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBfc3VidHJlZVJlbmRlckxhbmVzO1xuXG4gICAgaWYgKHByZXZTdGF0ZSAhPT0gbnVsbCkge1xuICAgICAgX3N1YnRyZWVSZW5kZXJMYW5lcyA9IG1lcmdlTGFuZXMocHJldlN0YXRlLmJhc2VMYW5lcywgcmVuZGVyTGFuZXMpOyAvLyBTaW5jZSB3ZSdyZSBub3QgaGlkZGVuIGFueW1vcmUsIHJlc2V0IHRoZSBzdGF0ZVxuXG4gICAgICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gV2Ugd2VyZW4ndCBwcmV2aW91c2x5IGhpZGRlbiwgYW5kIHdlIHN0aWxsIGFyZW4ndCwgc28gdGhlcmUncyBub3RoaW5nXG4gICAgICAvLyBzcGVjaWFsIHRvIGRvLiBOZWVkIHRvIHB1c2ggdG8gdGhlIHN0YWNrIHJlZ2FyZGxlc3MsIHRob3VnaCwgdG8gYXZvaWRcbiAgICAgIC8vIGEgcHVzaC9wb3AgbWlzYWxpZ25tZW50LlxuICAgICAgX3N1YnRyZWVSZW5kZXJMYW5lcyA9IHJlbmRlckxhbmVzO1xuICAgIH1cblxuICAgIHB1c2hSZW5kZXJMYW5lcyh3b3JrSW5Qcm9ncmVzcywgX3N1YnRyZWVSZW5kZXJMYW5lcyk7XG4gIH1cblxuICByZWNvbmNpbGVDaGlsZHJlbihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbmV4dENoaWxkcmVuLCByZW5kZXJMYW5lcyk7XG4gIHJldHVybiB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbn0gLy8gTm90ZTogVGhlc2UgaGFwcGVuIHRvIGhhdmUgaWRlbnRpY2FsIGJlZ2luIHBoYXNlcywgZm9yIG5vdy4gV2Ugc2hvdWxkbid0IGhvbGRcbi8vIG91cnNlbHZlcyB0byB0aGlzIGNvbnN0cmFpbnQsIHRob3VnaC4gSWYgdGhlIGJlaGF2aW9yIGRpdmVyZ2VzLCB3ZSBzaG91bGRcbi8vIGZvcmsgdGhlIGZ1bmN0aW9uLlxuXG5cbnZhciB1cGRhdGVMZWdhY3lIaWRkZW5Db21wb25lbnQgPSB1cGRhdGVPZmZzY3JlZW5Db21wb25lbnQ7XG5cbmZ1bmN0aW9uIHVwZGF0ZUZyYWdtZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcykge1xuICB2YXIgbmV4dENoaWxkcmVuID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO1xuICByZWNvbmNpbGVDaGlsZHJlbihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbmV4dENoaWxkcmVuLCByZW5kZXJMYW5lcyk7XG4gIHJldHVybiB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbn1cblxuZnVuY3Rpb24gdXBkYXRlTW9kZShjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpIHtcbiAgdmFyIG5leHRDaGlsZHJlbiA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcy5jaGlsZHJlbjtcbiAgcmVjb25jaWxlQ2hpbGRyZW4oY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG5leHRDaGlsZHJlbiwgcmVuZGVyTGFuZXMpO1xuICByZXR1cm4gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZVByb2ZpbGVyKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcykge1xuICB7XG4gICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gVXBkYXRlOyAvLyBSZXNldCBlZmZlY3QgZHVyYXRpb25zIGZvciB0aGUgbmV4dCBldmVudHVhbCBlZmZlY3QgcGhhc2UuXG4gICAgLy8gVGhlc2UgYXJlIHJlc2V0IGR1cmluZyByZW5kZXIgdG8gYWxsb3cgdGhlIERldlRvb2xzIGNvbW1pdCBob29rIGEgY2hhbmNlIHRvIHJlYWQgdGhlbSxcblxuICAgIHZhciBzdGF0ZU5vZGUgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG4gICAgc3RhdGVOb2RlLmVmZmVjdER1cmF0aW9uID0gMDtcbiAgICBzdGF0ZU5vZGUucGFzc2l2ZUVmZmVjdER1cmF0aW9uID0gMDtcbiAgfVxuXG4gIHZhciBuZXh0UHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7XG4gIHZhciBuZXh0Q2hpbGRyZW4gPSBuZXh0UHJvcHMuY2hpbGRyZW47XG4gIHJlY29uY2lsZUNoaWxkcmVuKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBuZXh0Q2hpbGRyZW4sIHJlbmRlckxhbmVzKTtcbiAgcmV0dXJuIHdvcmtJblByb2dyZXNzLmNoaWxkO1xufVxuXG5mdW5jdGlvbiBtYXJrUmVmKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKSB7XG4gIHZhciByZWYgPSB3b3JrSW5Qcm9ncmVzcy5yZWY7XG5cbiAgaWYgKGN1cnJlbnQgPT09IG51bGwgJiYgcmVmICE9PSBudWxsIHx8IGN1cnJlbnQgIT09IG51bGwgJiYgY3VycmVudC5yZWYgIT09IHJlZikge1xuICAgIC8vIFNjaGVkdWxlIGEgUmVmIGVmZmVjdFxuICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IFJlZjtcbiAgfVxufVxuXG5mdW5jdGlvbiB1cGRhdGVGdW5jdGlvbkNvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgQ29tcG9uZW50LCBuZXh0UHJvcHMsIHJlbmRlckxhbmVzKSB7XG4gIHtcbiAgICBpZiAod29ya0luUHJvZ3Jlc3MudHlwZSAhPT0gd29ya0luUHJvZ3Jlc3MuZWxlbWVudFR5cGUpIHtcbiAgICAgIC8vIExhenkgY29tcG9uZW50IHByb3BzIGNhbid0IGJlIHZhbGlkYXRlZCBpbiBjcmVhdGVFbGVtZW50XG4gICAgICAvLyBiZWNhdXNlIHRoZXkncmUgb25seSBndWFyYW50ZWVkIHRvIGJlIHJlc29sdmVkIGhlcmUuXG4gICAgICB2YXIgaW5uZXJQcm9wVHlwZXMgPSBDb21wb25lbnQucHJvcFR5cGVzO1xuXG4gICAgICBpZiAoaW5uZXJQcm9wVHlwZXMpIHtcbiAgICAgICAgY2hlY2tQcm9wVHlwZXMoaW5uZXJQcm9wVHlwZXMsIG5leHRQcm9wcywgLy8gUmVzb2x2ZWQgcHJvcHNcbiAgICAgICAgJ3Byb3AnLCBnZXRDb21wb25lbnROYW1lKENvbXBvbmVudCkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciBjb250ZXh0O1xuXG4gIHtcbiAgICB2YXIgdW5tYXNrZWRDb250ZXh0ID0gZ2V0VW5tYXNrZWRDb250ZXh0KHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQsIHRydWUpO1xuICAgIGNvbnRleHQgPSBnZXRNYXNrZWRDb250ZXh0KHdvcmtJblByb2dyZXNzLCB1bm1hc2tlZENvbnRleHQpO1xuICB9XG5cbiAgdmFyIG5leHRDaGlsZHJlbjtcbiAgcHJlcGFyZVRvUmVhZENvbnRleHQod29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKTtcblxuICB7XG4gICAgUmVhY3RDdXJyZW50T3duZXIkMS5jdXJyZW50ID0gd29ya0luUHJvZ3Jlc3M7XG4gICAgc2V0SXNSZW5kZXJpbmcodHJ1ZSk7XG4gICAgbmV4dENoaWxkcmVuID0gcmVuZGVyV2l0aEhvb2tzKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQsIG5leHRQcm9wcywgY29udGV4dCwgcmVuZGVyTGFuZXMpO1xuXG4gICAgaWYgKCB3b3JrSW5Qcm9ncmVzcy5tb2RlICYgU3RyaWN0TW9kZSkge1xuICAgICAgZGlzYWJsZUxvZ3MoKTtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgbmV4dENoaWxkcmVuID0gcmVuZGVyV2l0aEhvb2tzKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQsIG5leHRQcm9wcywgY29udGV4dCwgcmVuZGVyTGFuZXMpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgcmVlbmFibGVMb2dzKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgc2V0SXNSZW5kZXJpbmcoZmFsc2UpO1xuICB9XG5cbiAgaWYgKGN1cnJlbnQgIT09IG51bGwgJiYgIWRpZFJlY2VpdmVVcGRhdGUpIHtcbiAgICBiYWlsb3V0SG9va3MoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKTtcbiAgICByZXR1cm4gYmFpbG91dE9uQWxyZWFkeUZpbmlzaGVkV29yayhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpO1xuICB9IC8vIFJlYWN0IERldlRvb2xzIHJlYWRzIHRoaXMgZmxhZy5cblxuXG4gIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IFBlcmZvcm1lZFdvcms7XG4gIHJlY29uY2lsZUNoaWxkcmVuKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBuZXh0Q2hpbGRyZW4sIHJlbmRlckxhbmVzKTtcbiAgcmV0dXJuIHdvcmtJblByb2dyZXNzLmNoaWxkO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVDbGFzc0NvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgQ29tcG9uZW50LCBuZXh0UHJvcHMsIHJlbmRlckxhbmVzKSB7XG4gIHtcbiAgICBpZiAod29ya0luUHJvZ3Jlc3MudHlwZSAhPT0gd29ya0luUHJvZ3Jlc3MuZWxlbWVudFR5cGUpIHtcbiAgICAgIC8vIExhenkgY29tcG9uZW50IHByb3BzIGNhbid0IGJlIHZhbGlkYXRlZCBpbiBjcmVhdGVFbGVtZW50XG4gICAgICAvLyBiZWNhdXNlIHRoZXkncmUgb25seSBndWFyYW50ZWVkIHRvIGJlIHJlc29sdmVkIGhlcmUuXG4gICAgICB2YXIgaW5uZXJQcm9wVHlwZXMgPSBDb21wb25lbnQucHJvcFR5cGVzO1xuXG4gICAgICBpZiAoaW5uZXJQcm9wVHlwZXMpIHtcbiAgICAgICAgY2hlY2tQcm9wVHlwZXMoaW5uZXJQcm9wVHlwZXMsIG5leHRQcm9wcywgLy8gUmVzb2x2ZWQgcHJvcHNcbiAgICAgICAgJ3Byb3AnLCBnZXRDb21wb25lbnROYW1lKENvbXBvbmVudCkpO1xuICAgICAgfVxuICAgIH1cbiAgfSAvLyBQdXNoIGNvbnRleHQgcHJvdmlkZXJzIGVhcmx5IHRvIHByZXZlbnQgY29udGV4dCBzdGFjayBtaXNtYXRjaGVzLlxuICAvLyBEdXJpbmcgbW91bnRpbmcgd2UgZG9uJ3Qga25vdyB0aGUgY2hpbGQgY29udGV4dCB5ZXQgYXMgdGhlIGluc3RhbmNlIGRvZXNuJ3QgZXhpc3QuXG4gIC8vIFdlIHdpbGwgaW52YWxpZGF0ZSB0aGUgY2hpbGQgY29udGV4dCBpbiBmaW5pc2hDbGFzc0NvbXBvbmVudCgpIHJpZ2h0IGFmdGVyIHJlbmRlcmluZy5cblxuXG4gIHZhciBoYXNDb250ZXh0O1xuXG4gIGlmIChpc0NvbnRleHRQcm92aWRlcihDb21wb25lbnQpKSB7XG4gICAgaGFzQ29udGV4dCA9IHRydWU7XG4gICAgcHVzaENvbnRleHRQcm92aWRlcih3b3JrSW5Qcm9ncmVzcyk7XG4gIH0gZWxzZSB7XG4gICAgaGFzQ29udGV4dCA9IGZhbHNlO1xuICB9XG5cbiAgcHJlcGFyZVRvUmVhZENvbnRleHQod29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKTtcbiAgdmFyIGluc3RhbmNlID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuICB2YXIgc2hvdWxkVXBkYXRlO1xuXG4gIGlmIChpbnN0YW5jZSA9PT0gbnVsbCkge1xuICAgIGlmIChjdXJyZW50ICE9PSBudWxsKSB7XG4gICAgICAvLyBBIGNsYXNzIGNvbXBvbmVudCB3aXRob3V0IGFuIGluc3RhbmNlIG9ubHkgbW91bnRzIGlmIGl0IHN1c3BlbmRlZFxuICAgICAgLy8gaW5zaWRlIGEgbm9uLWNvbmN1cnJlbnQgdHJlZSwgaW4gYW4gaW5jb25zaXN0ZW50IHN0YXRlLiBXZSB3YW50IHRvXG4gICAgICAvLyB0cmVhdCBpdCBsaWtlIGEgbmV3IG1vdW50LCBldmVuIHRob3VnaCBhbiBlbXB0eSB2ZXJzaW9uIG9mIGl0IGFscmVhZHlcbiAgICAgIC8vIGNvbW1pdHRlZC4gRGlzY29ubmVjdCB0aGUgYWx0ZXJuYXRlIHBvaW50ZXJzLlxuICAgICAgY3VycmVudC5hbHRlcm5hdGUgPSBudWxsO1xuICAgICAgd29ya0luUHJvZ3Jlc3MuYWx0ZXJuYXRlID0gbnVsbDsgLy8gU2luY2UgdGhpcyBpcyBjb25jZXB0dWFsbHkgYSBuZXcgZmliZXIsIHNjaGVkdWxlIGEgUGxhY2VtZW50IGVmZmVjdFxuXG4gICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBQbGFjZW1lbnQ7XG4gICAgfSAvLyBJbiB0aGUgaW5pdGlhbCBwYXNzIHdlIG1pZ2h0IG5lZWQgdG8gY29uc3RydWN0IHRoZSBpbnN0YW5jZS5cblxuXG4gICAgY29uc3RydWN0Q2xhc3NJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcywgQ29tcG9uZW50LCBuZXh0UHJvcHMpO1xuICAgIG1vdW50Q2xhc3NJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcywgQ29tcG9uZW50LCBuZXh0UHJvcHMsIHJlbmRlckxhbmVzKTtcbiAgICBzaG91bGRVcGRhdGUgPSB0cnVlO1xuICB9IGVsc2UgaWYgKGN1cnJlbnQgPT09IG51bGwpIHtcbiAgICAvLyBJbiBhIHJlc3VtZSwgd2UnbGwgYWxyZWFkeSBoYXZlIGFuIGluc3RhbmNlIHdlIGNhbiByZXVzZS5cbiAgICBzaG91bGRVcGRhdGUgPSByZXN1bWVNb3VudENsYXNzSW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MsIENvbXBvbmVudCwgbmV4dFByb3BzLCByZW5kZXJMYW5lcyk7XG4gIH0gZWxzZSB7XG4gICAgc2hvdWxkVXBkYXRlID0gdXBkYXRlQ2xhc3NJbnN0YW5jZShjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgQ29tcG9uZW50LCBuZXh0UHJvcHMsIHJlbmRlckxhbmVzKTtcbiAgfVxuXG4gIHZhciBuZXh0VW5pdE9mV29yayA9IGZpbmlzaENsYXNzQ29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQsIHNob3VsZFVwZGF0ZSwgaGFzQ29udGV4dCwgcmVuZGVyTGFuZXMpO1xuXG4gIHtcbiAgICB2YXIgaW5zdCA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcblxuICAgIGlmIChzaG91bGRVcGRhdGUgJiYgaW5zdC5wcm9wcyAhPT0gbmV4dFByb3BzKSB7XG4gICAgICBpZiAoIWRpZFdhcm5BYm91dFJlYXNzaWduaW5nUHJvcHMpIHtcbiAgICAgICAgZXJyb3IoJ0l0IGxvb2tzIGxpa2UgJXMgaXMgcmVhc3NpZ25pbmcgaXRzIG93biBgdGhpcy5wcm9wc2Agd2hpbGUgcmVuZGVyaW5nLiAnICsgJ1RoaXMgaXMgbm90IHN1cHBvcnRlZCBhbmQgY2FuIGxlYWQgdG8gY29uZnVzaW5nIGJ1Z3MuJywgZ2V0Q29tcG9uZW50TmFtZSh3b3JrSW5Qcm9ncmVzcy50eXBlKSB8fCAnYSBjb21wb25lbnQnKTtcbiAgICAgIH1cblxuICAgICAgZGlkV2FybkFib3V0UmVhc3NpZ25pbmdQcm9wcyA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5leHRVbml0T2ZXb3JrO1xufVxuXG5mdW5jdGlvbiBmaW5pc2hDbGFzc0NvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgQ29tcG9uZW50LCBzaG91bGRVcGRhdGUsIGhhc0NvbnRleHQsIHJlbmRlckxhbmVzKSB7XG4gIC8vIFJlZnMgc2hvdWxkIHVwZGF0ZSBldmVuIGlmIHNob3VsZENvbXBvbmVudFVwZGF0ZSByZXR1cm5zIGZhbHNlXG4gIG1hcmtSZWYoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpO1xuICB2YXIgZGlkQ2FwdHVyZUVycm9yID0gKHdvcmtJblByb2dyZXNzLmZsYWdzICYgRGlkQ2FwdHVyZSkgIT09IE5vRmxhZ3M7XG5cbiAgaWYgKCFzaG91bGRVcGRhdGUgJiYgIWRpZENhcHR1cmVFcnJvcikge1xuICAgIC8vIENvbnRleHQgcHJvdmlkZXJzIHNob3VsZCBkZWZlciB0byBzQ1UgZm9yIHJlbmRlcmluZ1xuICAgIGlmIChoYXNDb250ZXh0KSB7XG4gICAgICBpbnZhbGlkYXRlQ29udGV4dFByb3ZpZGVyKHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQsIGZhbHNlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYmFpbG91dE9uQWxyZWFkeUZpbmlzaGVkV29yayhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpO1xuICB9XG5cbiAgdmFyIGluc3RhbmNlID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlOyAvLyBSZXJlbmRlclxuXG4gIFJlYWN0Q3VycmVudE93bmVyJDEuY3VycmVudCA9IHdvcmtJblByb2dyZXNzO1xuICB2YXIgbmV4dENoaWxkcmVuO1xuXG4gIGlmIChkaWRDYXB0dXJlRXJyb3IgJiYgdHlwZW9mIENvbXBvbmVudC5nZXREZXJpdmVkU3RhdGVGcm9tRXJyb3IgIT09ICdmdW5jdGlvbicpIHtcbiAgICAvLyBJZiB3ZSBjYXB0dXJlZCBhbiBlcnJvciwgYnV0IGdldERlcml2ZWRTdGF0ZUZyb21FcnJvciBpcyBub3QgZGVmaW5lZCxcbiAgICAvLyB1bm1vdW50IGFsbCB0aGUgY2hpbGRyZW4uIGNvbXBvbmVudERpZENhdGNoIHdpbGwgc2NoZWR1bGUgYW4gdXBkYXRlIHRvXG4gICAgLy8gcmUtcmVuZGVyIGEgZmFsbGJhY2suIFRoaXMgaXMgdGVtcG9yYXJ5IHVudGlsIHdlIG1pZ3JhdGUgZXZlcnlvbmUgdG9cbiAgICAvLyB0aGUgbmV3IEFQSS5cbiAgICAvLyBUT0RPOiBXYXJuIGluIGEgZnV0dXJlIHJlbGVhc2UuXG4gICAgbmV4dENoaWxkcmVuID0gbnVsbDtcblxuICAgIHtcbiAgICAgIHN0b3BQcm9maWxlclRpbWVySWZSdW5uaW5nKCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHtcbiAgICAgIHNldElzUmVuZGVyaW5nKHRydWUpO1xuICAgICAgbmV4dENoaWxkcmVuID0gaW5zdGFuY2UucmVuZGVyKCk7XG5cbiAgICAgIGlmICggd29ya0luUHJvZ3Jlc3MubW9kZSAmIFN0cmljdE1vZGUpIHtcbiAgICAgICAgZGlzYWJsZUxvZ3MoKTtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgIGluc3RhbmNlLnJlbmRlcigpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIHJlZW5hYmxlTG9ncygpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHNldElzUmVuZGVyaW5nKGZhbHNlKTtcbiAgICB9XG4gIH0gLy8gUmVhY3QgRGV2VG9vbHMgcmVhZHMgdGhpcyBmbGFnLlxuXG5cbiAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gUGVyZm9ybWVkV29yaztcblxuICBpZiAoY3VycmVudCAhPT0gbnVsbCAmJiBkaWRDYXB0dXJlRXJyb3IpIHtcbiAgICAvLyBJZiB3ZSdyZSByZWNvdmVyaW5nIGZyb20gYW4gZXJyb3IsIHJlY29uY2lsZSB3aXRob3V0IHJldXNpbmcgYW55IG9mXG4gICAgLy8gdGhlIGV4aXN0aW5nIGNoaWxkcmVuLiBDb25jZXB0dWFsbHksIHRoZSBub3JtYWwgY2hpbGRyZW4gYW5kIHRoZSBjaGlsZHJlblxuICAgIC8vIHRoYXQgYXJlIHNob3duIG9uIGVycm9yIGFyZSB0d28gZGlmZmVyZW50IHNldHMsIHNvIHdlIHNob3VsZG4ndCByZXVzZVxuICAgIC8vIG5vcm1hbCBjaGlsZHJlbiBldmVuIGlmIHRoZWlyIGlkZW50aXRpZXMgbWF0Y2guXG4gICAgZm9yY2VVbm1vdW50Q3VycmVudEFuZFJlY29uY2lsZShjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbmV4dENoaWxkcmVuLCByZW5kZXJMYW5lcyk7XG4gIH0gZWxzZSB7XG4gICAgcmVjb25jaWxlQ2hpbGRyZW4oY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG5leHRDaGlsZHJlbiwgcmVuZGVyTGFuZXMpO1xuICB9IC8vIE1lbW9pemUgc3RhdGUgdXNpbmcgdGhlIHZhbHVlcyB3ZSBqdXN0IHVzZWQgdG8gcmVuZGVyLlxuICAvLyBUT0RPOiBSZXN0cnVjdHVyZSBzbyB3ZSBuZXZlciByZWFkIHZhbHVlcyBmcm9tIHRoZSBpbnN0YW5jZS5cblxuXG4gIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBpbnN0YW5jZS5zdGF0ZTsgLy8gVGhlIGNvbnRleHQgbWlnaHQgaGF2ZSBjaGFuZ2VkIHNvIHdlIG5lZWQgdG8gcmVjYWxjdWxhdGUgaXQuXG5cbiAgaWYgKGhhc0NvbnRleHQpIHtcbiAgICBpbnZhbGlkYXRlQ29udGV4dFByb3ZpZGVyKHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQsIHRydWUpO1xuICB9XG5cbiAgcmV0dXJuIHdvcmtJblByb2dyZXNzLmNoaWxkO1xufVxuXG5mdW5jdGlvbiBwdXNoSG9zdFJvb3RDb250ZXh0KHdvcmtJblByb2dyZXNzKSB7XG4gIHZhciByb290ID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuXG4gIGlmIChyb290LnBlbmRpbmdDb250ZXh0KSB7XG4gICAgcHVzaFRvcExldmVsQ29udGV4dE9iamVjdCh3b3JrSW5Qcm9ncmVzcywgcm9vdC5wZW5kaW5nQ29udGV4dCwgcm9vdC5wZW5kaW5nQ29udGV4dCAhPT0gcm9vdC5jb250ZXh0KTtcbiAgfSBlbHNlIGlmIChyb290LmNvbnRleHQpIHtcbiAgICAvLyBTaG91bGQgYWx3YXlzIGJlIHNldFxuICAgIHB1c2hUb3BMZXZlbENvbnRleHRPYmplY3Qod29ya0luUHJvZ3Jlc3MsIHJvb3QuY29udGV4dCwgZmFsc2UpO1xuICB9XG5cbiAgcHVzaEhvc3RDb250YWluZXIod29ya0luUHJvZ3Jlc3MsIHJvb3QuY29udGFpbmVySW5mbyk7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUhvc3RSb290KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcykge1xuICBwdXNoSG9zdFJvb3RDb250ZXh0KHdvcmtJblByb2dyZXNzKTtcbiAgdmFyIHVwZGF0ZVF1ZXVlID0gd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWU7XG5cbiAgaWYgKCEoY3VycmVudCAhPT0gbnVsbCAmJiB1cGRhdGVRdWV1ZSAhPT0gbnVsbCkpIHtcbiAgICB7XG4gICAgICB0aHJvdyBFcnJvciggXCJJZiB0aGUgcm9vdCBkb2VzIG5vdCBoYXZlIGFuIHVwZGF0ZVF1ZXVlLCB3ZSBzaG91bGQgaGF2ZSBhbHJlYWR5IGJhaWxlZCBvdXQuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCIgKTtcbiAgICB9XG4gIH1cblxuICB2YXIgbmV4dFByb3BzID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO1xuICB2YXIgcHJldlN0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcbiAgdmFyIHByZXZDaGlsZHJlbiA9IHByZXZTdGF0ZSAhPT0gbnVsbCA/IHByZXZTdGF0ZS5lbGVtZW50IDogbnVsbDtcbiAgY2xvbmVVcGRhdGVRdWV1ZShjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcyk7XG4gIHByb2Nlc3NVcGRhdGVRdWV1ZSh3b3JrSW5Qcm9ncmVzcywgbmV4dFByb3BzLCBudWxsLCByZW5kZXJMYW5lcyk7XG4gIHZhciBuZXh0U3RhdGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlOyAvLyBDYXV0aW9uOiBSZWFjdCBEZXZUb29scyBjdXJyZW50bHkgZGVwZW5kcyBvbiB0aGlzIHByb3BlcnR5XG4gIC8vIGJlaW5nIGNhbGxlZCBcImVsZW1lbnRcIi5cblxuICB2YXIgbmV4dENoaWxkcmVuID0gbmV4dFN0YXRlLmVsZW1lbnQ7XG5cbiAgaWYgKG5leHRDaGlsZHJlbiA9PT0gcHJldkNoaWxkcmVuKSB7XG4gICAgcmVzZXRIeWRyYXRpb25TdGF0ZSgpO1xuICAgIHJldHVybiBiYWlsb3V0T25BbHJlYWR5RmluaXNoZWRXb3JrKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcyk7XG4gIH1cblxuICB2YXIgcm9vdCA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcblxuICBpZiAocm9vdC5oeWRyYXRlICYmIGVudGVySHlkcmF0aW9uU3RhdGUod29ya0luUHJvZ3Jlc3MpKSB7XG4gICAgLy8gSWYgd2UgZG9uJ3QgaGF2ZSBhbnkgY3VycmVudCBjaGlsZHJlbiB0aGlzIG1pZ2h0IGJlIHRoZSBmaXJzdCBwYXNzLlxuICAgIC8vIFdlIGFsd2F5cyB0cnkgdG8gaHlkcmF0ZS4gSWYgdGhpcyBpc24ndCBhIGh5ZHJhdGlvbiBwYXNzIHRoZXJlIHdvbid0XG4gICAgLy8gYmUgYW55IGNoaWxkcmVuIHRvIGh5ZHJhdGUgd2hpY2ggaXMgZWZmZWN0aXZlbHkgdGhlIHNhbWUgdGhpbmcgYXNcbiAgICAvLyBub3QgaHlkcmF0aW5nLlxuICAgIHtcbiAgICAgIHZhciBtdXRhYmxlU291cmNlRWFnZXJIeWRyYXRpb25EYXRhID0gcm9vdC5tdXRhYmxlU291cmNlRWFnZXJIeWRyYXRpb25EYXRhO1xuXG4gICAgICBpZiAobXV0YWJsZVNvdXJjZUVhZ2VySHlkcmF0aW9uRGF0YSAhPSBudWxsKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbXV0YWJsZVNvdXJjZUVhZ2VySHlkcmF0aW9uRGF0YS5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgICAgIHZhciBtdXRhYmxlU291cmNlID0gbXV0YWJsZVNvdXJjZUVhZ2VySHlkcmF0aW9uRGF0YVtpXTtcbiAgICAgICAgICB2YXIgdmVyc2lvbiA9IG11dGFibGVTb3VyY2VFYWdlckh5ZHJhdGlvbkRhdGFbaSArIDFdO1xuICAgICAgICAgIHNldFdvcmtJblByb2dyZXNzVmVyc2lvbihtdXRhYmxlU291cmNlLCB2ZXJzaW9uKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBjaGlsZCA9IG1vdW50Q2hpbGRGaWJlcnMod29ya0luUHJvZ3Jlc3MsIG51bGwsIG5leHRDaGlsZHJlbiwgcmVuZGVyTGFuZXMpO1xuICAgIHdvcmtJblByb2dyZXNzLmNoaWxkID0gY2hpbGQ7XG4gICAgdmFyIG5vZGUgPSBjaGlsZDtcblxuICAgIHdoaWxlIChub2RlKSB7XG4gICAgICAvLyBNYXJrIGVhY2ggY2hpbGQgYXMgaHlkcmF0aW5nLiBUaGlzIGlzIGEgZmFzdCBwYXRoIHRvIGtub3cgd2hldGhlciB0aGlzXG4gICAgICAvLyB0cmVlIGlzIHBhcnQgb2YgYSBoeWRyYXRpbmcgdHJlZS4gVGhpcyBpcyB1c2VkIHRvIGRldGVybWluZSBpZiBhIGNoaWxkXG4gICAgICAvLyBub2RlIGhhcyBmdWxseSBtb3VudGVkIHlldCwgYW5kIGZvciBzY2hlZHVsaW5nIGV2ZW50IHJlcGxheWluZy5cbiAgICAgIC8vIENvbmNlcHR1YWxseSB0aGlzIGlzIHNpbWlsYXIgdG8gUGxhY2VtZW50IGluIHRoYXQgYSBuZXcgc3VidHJlZSBpc1xuICAgICAgLy8gaW5zZXJ0ZWQgaW50byB0aGUgUmVhY3QgdHJlZSBoZXJlLiBJdCBqdXN0IGhhcHBlbnMgdG8gbm90IG5lZWQgRE9NXG4gICAgICAvLyBtdXRhdGlvbnMgYmVjYXVzZSBpdCBhbHJlYWR5IGV4aXN0cy5cbiAgICAgIG5vZGUuZmxhZ3MgPSBub2RlLmZsYWdzICYgflBsYWNlbWVudCB8IEh5ZHJhdGluZztcbiAgICAgIG5vZGUgPSBub2RlLnNpYmxpbmc7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIE90aGVyd2lzZSByZXNldCBoeWRyYXRpb24gc3RhdGUgaW4gY2FzZSB3ZSBhYm9ydGVkIGFuZCByZXN1bWVkIGFub3RoZXJcbiAgICAvLyByb290LlxuICAgIHJlY29uY2lsZUNoaWxkcmVuKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBuZXh0Q2hpbGRyZW4sIHJlbmRlckxhbmVzKTtcbiAgICByZXNldEh5ZHJhdGlvblN0YXRlKCk7XG4gIH1cblxuICByZXR1cm4gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUhvc3RDb21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKSB7XG4gIHB1c2hIb3N0Q29udGV4dCh3b3JrSW5Qcm9ncmVzcyk7XG5cbiAgaWYgKGN1cnJlbnQgPT09IG51bGwpIHtcbiAgICB0cnlUb0NsYWltTmV4dEh5ZHJhdGFibGVJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcyk7XG4gIH1cblxuICB2YXIgdHlwZSA9IHdvcmtJblByb2dyZXNzLnR5cGU7XG4gIHZhciBuZXh0UHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7XG4gIHZhciBwcmV2UHJvcHMgPSBjdXJyZW50ICE9PSBudWxsID8gY3VycmVudC5tZW1vaXplZFByb3BzIDogbnVsbDtcbiAgdmFyIG5leHRDaGlsZHJlbiA9IG5leHRQcm9wcy5jaGlsZHJlbjtcbiAgdmFyIGlzRGlyZWN0VGV4dENoaWxkID0gc2hvdWxkU2V0VGV4dENvbnRlbnQodHlwZSwgbmV4dFByb3BzKTtcblxuICBpZiAoaXNEaXJlY3RUZXh0Q2hpbGQpIHtcbiAgICAvLyBXZSBzcGVjaWFsIGNhc2UgYSBkaXJlY3QgdGV4dCBjaGlsZCBvZiBhIGhvc3Qgbm9kZS4gVGhpcyBpcyBhIGNvbW1vblxuICAgIC8vIGNhc2UuIFdlIHdvbid0IGhhbmRsZSBpdCBhcyBhIHJlaWZpZWQgY2hpbGQuIFdlIHdpbGwgaW5zdGVhZCBoYW5kbGVcbiAgICAvLyB0aGlzIGluIHRoZSBob3N0IGVudmlyb25tZW50IHRoYXQgYWxzbyBoYXMgYWNjZXNzIHRvIHRoaXMgcHJvcC4gVGhhdFxuICAgIC8vIGF2b2lkcyBhbGxvY2F0aW5nIGFub3RoZXIgSG9zdFRleHQgZmliZXIgYW5kIHRyYXZlcnNpbmcgaXQuXG4gICAgbmV4dENoaWxkcmVuID0gbnVsbDtcbiAgfSBlbHNlIGlmIChwcmV2UHJvcHMgIT09IG51bGwgJiYgc2hvdWxkU2V0VGV4dENvbnRlbnQodHlwZSwgcHJldlByb3BzKSkge1xuICAgIC8vIElmIHdlJ3JlIHN3aXRjaGluZyBmcm9tIGEgZGlyZWN0IHRleHQgY2hpbGQgdG8gYSBub3JtYWwgY2hpbGQsIG9yIHRvXG4gICAgLy8gZW1wdHksIHdlIG5lZWQgdG8gc2NoZWR1bGUgdGhlIHRleHQgY29udGVudCB0byBiZSByZXNldC5cbiAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBDb250ZW50UmVzZXQ7XG4gIH1cblxuICBtYXJrUmVmKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKTtcbiAgcmVjb25jaWxlQ2hpbGRyZW4oY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG5leHRDaGlsZHJlbiwgcmVuZGVyTGFuZXMpO1xuICByZXR1cm4gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUhvc3RUZXh0KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKSB7XG4gIGlmIChjdXJyZW50ID09PSBudWxsKSB7XG4gICAgdHJ5VG9DbGFpbU5leHRIeWRyYXRhYmxlSW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MpO1xuICB9IC8vIE5vdGhpbmcgdG8gZG8gaGVyZS4gVGhpcyBpcyB0ZXJtaW5hbC4gV2UnbGwgZG8gdGhlIGNvbXBsZXRpb24gc3RlcFxuICAvLyBpbW1lZGlhdGVseSBhZnRlci5cblxuXG4gIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBtb3VudExhenlDb21wb25lbnQoX2N1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBlbGVtZW50VHlwZSwgdXBkYXRlTGFuZXMsIHJlbmRlckxhbmVzKSB7XG4gIGlmIChfY3VycmVudCAhPT0gbnVsbCkge1xuICAgIC8vIEEgbGF6eSBjb21wb25lbnQgb25seSBtb3VudHMgaWYgaXQgc3VzcGVuZGVkIGluc2lkZSBhIG5vbi1cbiAgICAvLyBjb25jdXJyZW50IHRyZWUsIGluIGFuIGluY29uc2lzdGVudCBzdGF0ZS4gV2Ugd2FudCB0byB0cmVhdCBpdCBsaWtlXG4gICAgLy8gYSBuZXcgbW91bnQsIGV2ZW4gdGhvdWdoIGFuIGVtcHR5IHZlcnNpb24gb2YgaXQgYWxyZWFkeSBjb21taXR0ZWQuXG4gICAgLy8gRGlzY29ubmVjdCB0aGUgYWx0ZXJuYXRlIHBvaW50ZXJzLlxuICAgIF9jdXJyZW50LmFsdGVybmF0ZSA9IG51bGw7XG4gICAgd29ya0luUHJvZ3Jlc3MuYWx0ZXJuYXRlID0gbnVsbDsgLy8gU2luY2UgdGhpcyBpcyBjb25jZXB0dWFsbHkgYSBuZXcgZmliZXIsIHNjaGVkdWxlIGEgUGxhY2VtZW50IGVmZmVjdFxuXG4gICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gUGxhY2VtZW50O1xuICB9XG5cbiAgdmFyIHByb3BzID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO1xuICB2YXIgbGF6eUNvbXBvbmVudCA9IGVsZW1lbnRUeXBlO1xuICB2YXIgcGF5bG9hZCA9IGxhenlDb21wb25lbnQuX3BheWxvYWQ7XG4gIHZhciBpbml0ID0gbGF6eUNvbXBvbmVudC5faW5pdDtcbiAgdmFyIENvbXBvbmVudCA9IGluaXQocGF5bG9hZCk7IC8vIFN0b3JlIHRoZSB1bndyYXBwZWQgY29tcG9uZW50IGluIHRoZSB0eXBlLlxuXG4gIHdvcmtJblByb2dyZXNzLnR5cGUgPSBDb21wb25lbnQ7XG4gIHZhciByZXNvbHZlZFRhZyA9IHdvcmtJblByb2dyZXNzLnRhZyA9IHJlc29sdmVMYXp5Q29tcG9uZW50VGFnKENvbXBvbmVudCk7XG4gIHZhciByZXNvbHZlZFByb3BzID0gcmVzb2x2ZURlZmF1bHRQcm9wcyhDb21wb25lbnQsIHByb3BzKTtcbiAgdmFyIGNoaWxkO1xuXG4gIHN3aXRjaCAocmVzb2x2ZWRUYWcpIHtcbiAgICBjYXNlIEZ1bmN0aW9uQ29tcG9uZW50OlxuICAgICAge1xuICAgICAgICB7XG4gICAgICAgICAgdmFsaWRhdGVGdW5jdGlvbkNvbXBvbmVudEluRGV2KHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQpO1xuICAgICAgICAgIHdvcmtJblByb2dyZXNzLnR5cGUgPSBDb21wb25lbnQgPSByZXNvbHZlRnVuY3Rpb25Gb3JIb3RSZWxvYWRpbmcoQ29tcG9uZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNoaWxkID0gdXBkYXRlRnVuY3Rpb25Db21wb25lbnQobnVsbCwgd29ya0luUHJvZ3Jlc3MsIENvbXBvbmVudCwgcmVzb2x2ZWRQcm9wcywgcmVuZGVyTGFuZXMpO1xuICAgICAgICByZXR1cm4gY2hpbGQ7XG4gICAgICB9XG5cbiAgICBjYXNlIENsYXNzQ29tcG9uZW50OlxuICAgICAge1xuICAgICAgICB7XG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MudHlwZSA9IENvbXBvbmVudCA9IHJlc29sdmVDbGFzc0ZvckhvdFJlbG9hZGluZyhDb21wb25lbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgY2hpbGQgPSB1cGRhdGVDbGFzc0NvbXBvbmVudChudWxsLCB3b3JrSW5Qcm9ncmVzcywgQ29tcG9uZW50LCByZXNvbHZlZFByb3BzLCByZW5kZXJMYW5lcyk7XG4gICAgICAgIHJldHVybiBjaGlsZDtcbiAgICAgIH1cblxuICAgIGNhc2UgRm9yd2FyZFJlZjpcbiAgICAgIHtcbiAgICAgICAge1xuICAgICAgICAgIHdvcmtJblByb2dyZXNzLnR5cGUgPSBDb21wb25lbnQgPSByZXNvbHZlRm9yd2FyZFJlZkZvckhvdFJlbG9hZGluZyhDb21wb25lbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgY2hpbGQgPSB1cGRhdGVGb3J3YXJkUmVmKG51bGwsIHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQsIHJlc29sdmVkUHJvcHMsIHJlbmRlckxhbmVzKTtcbiAgICAgICAgcmV0dXJuIGNoaWxkO1xuICAgICAgfVxuXG4gICAgY2FzZSBNZW1vQ29tcG9uZW50OlxuICAgICAge1xuICAgICAgICB7XG4gICAgICAgICAgaWYgKHdvcmtJblByb2dyZXNzLnR5cGUgIT09IHdvcmtJblByb2dyZXNzLmVsZW1lbnRUeXBlKSB7XG4gICAgICAgICAgICB2YXIgb3V0ZXJQcm9wVHlwZXMgPSBDb21wb25lbnQucHJvcFR5cGVzO1xuXG4gICAgICAgICAgICBpZiAob3V0ZXJQcm9wVHlwZXMpIHtcbiAgICAgICAgICAgICAgY2hlY2tQcm9wVHlwZXMob3V0ZXJQcm9wVHlwZXMsIHJlc29sdmVkUHJvcHMsIC8vIFJlc29sdmVkIGZvciBvdXRlciBvbmx5XG4gICAgICAgICAgICAgICdwcm9wJywgZ2V0Q29tcG9uZW50TmFtZShDb21wb25lbnQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjaGlsZCA9IHVwZGF0ZU1lbW9Db21wb25lbnQobnVsbCwgd29ya0luUHJvZ3Jlc3MsIENvbXBvbmVudCwgcmVzb2x2ZURlZmF1bHRQcm9wcyhDb21wb25lbnQudHlwZSwgcmVzb2x2ZWRQcm9wcyksIC8vIFRoZSBpbm5lciB0eXBlIGNhbiBoYXZlIGRlZmF1bHRzIHRvb1xuICAgICAgICB1cGRhdGVMYW5lcywgcmVuZGVyTGFuZXMpO1xuICAgICAgICByZXR1cm4gY2hpbGQ7XG4gICAgICB9XG4gIH1cblxuICB2YXIgaGludCA9ICcnO1xuXG4gIHtcbiAgICBpZiAoQ29tcG9uZW50ICE9PSBudWxsICYmIHR5cGVvZiBDb21wb25lbnQgPT09ICdvYmplY3QnICYmIENvbXBvbmVudC4kJHR5cGVvZiA9PT0gUkVBQ1RfTEFaWV9UWVBFKSB7XG4gICAgICBoaW50ID0gJyBEaWQgeW91IHdyYXAgYSBjb21wb25lbnQgaW4gUmVhY3QubGF6eSgpIG1vcmUgdGhhbiBvbmNlPyc7XG4gICAgfVxuICB9IC8vIFRoaXMgbWVzc2FnZSBpbnRlbnRpb25hbGx5IGRvZXNuJ3QgbWVudGlvbiBGb3J3YXJkUmVmIG9yIE1lbW9Db21wb25lbnRcbiAgLy8gYmVjYXVzZSB0aGUgZmFjdCB0aGF0IGl0J3MgYSBzZXBhcmF0ZSB0eXBlIG9mIHdvcmsgaXMgYW5cbiAgLy8gaW1wbGVtZW50YXRpb24gZGV0YWlsLlxuXG5cbiAge1xuICAgIHtcbiAgICAgIHRocm93IEVycm9yKCBcIkVsZW1lbnQgdHlwZSBpcyBpbnZhbGlkLiBSZWNlaXZlZCBhIHByb21pc2UgdGhhdCByZXNvbHZlcyB0bzogXCIgKyBDb21wb25lbnQgKyBcIi4gTGF6eSBlbGVtZW50IHR5cGUgbXVzdCByZXNvbHZlIHRvIGEgY2xhc3Mgb3IgZnVuY3Rpb24uXCIgKyBoaW50ICk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIG1vdW50SW5jb21wbGV0ZUNsYXNzQ29tcG9uZW50KF9jdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgQ29tcG9uZW50LCBuZXh0UHJvcHMsIHJlbmRlckxhbmVzKSB7XG4gIGlmIChfY3VycmVudCAhPT0gbnVsbCkge1xuICAgIC8vIEFuIGluY29tcGxldGUgY29tcG9uZW50IG9ubHkgbW91bnRzIGlmIGl0IHN1c3BlbmRlZCBpbnNpZGUgYSBub24tXG4gICAgLy8gY29uY3VycmVudCB0cmVlLCBpbiBhbiBpbmNvbnNpc3RlbnQgc3RhdGUuIFdlIHdhbnQgdG8gdHJlYXQgaXQgbGlrZVxuICAgIC8vIGEgbmV3IG1vdW50LCBldmVuIHRob3VnaCBhbiBlbXB0eSB2ZXJzaW9uIG9mIGl0IGFscmVhZHkgY29tbWl0dGVkLlxuICAgIC8vIERpc2Nvbm5lY3QgdGhlIGFsdGVybmF0ZSBwb2ludGVycy5cbiAgICBfY3VycmVudC5hbHRlcm5hdGUgPSBudWxsO1xuICAgIHdvcmtJblByb2dyZXNzLmFsdGVybmF0ZSA9IG51bGw7IC8vIFNpbmNlIHRoaXMgaXMgY29uY2VwdHVhbGx5IGEgbmV3IGZpYmVyLCBzY2hlZHVsZSBhIFBsYWNlbWVudCBlZmZlY3RcblxuICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IFBsYWNlbWVudDtcbiAgfSAvLyBQcm9tb3RlIHRoZSBmaWJlciB0byBhIGNsYXNzIGFuZCB0cnkgcmVuZGVyaW5nIGFnYWluLlxuXG5cbiAgd29ya0luUHJvZ3Jlc3MudGFnID0gQ2xhc3NDb21wb25lbnQ7IC8vIFRoZSByZXN0IG9mIHRoaXMgZnVuY3Rpb24gaXMgYSBmb3JrIG9mIGB1cGRhdGVDbGFzc0NvbXBvbmVudGBcbiAgLy8gUHVzaCBjb250ZXh0IHByb3ZpZGVycyBlYXJseSB0byBwcmV2ZW50IGNvbnRleHQgc3RhY2sgbWlzbWF0Y2hlcy5cbiAgLy8gRHVyaW5nIG1vdW50aW5nIHdlIGRvbid0IGtub3cgdGhlIGNoaWxkIGNvbnRleHQgeWV0IGFzIHRoZSBpbnN0YW5jZSBkb2Vzbid0IGV4aXN0LlxuICAvLyBXZSB3aWxsIGludmFsaWRhdGUgdGhlIGNoaWxkIGNvbnRleHQgaW4gZmluaXNoQ2xhc3NDb21wb25lbnQoKSByaWdodCBhZnRlciByZW5kZXJpbmcuXG5cbiAgdmFyIGhhc0NvbnRleHQ7XG5cbiAgaWYgKGlzQ29udGV4dFByb3ZpZGVyKENvbXBvbmVudCkpIHtcbiAgICBoYXNDb250ZXh0ID0gdHJ1ZTtcbiAgICBwdXNoQ29udGV4dFByb3ZpZGVyKHdvcmtJblByb2dyZXNzKTtcbiAgfSBlbHNlIHtcbiAgICBoYXNDb250ZXh0ID0gZmFsc2U7XG4gIH1cblxuICBwcmVwYXJlVG9SZWFkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpO1xuICBjb25zdHJ1Y3RDbGFzc0luc3RhbmNlKHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQsIG5leHRQcm9wcyk7XG4gIG1vdW50Q2xhc3NJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcywgQ29tcG9uZW50LCBuZXh0UHJvcHMsIHJlbmRlckxhbmVzKTtcbiAgcmV0dXJuIGZpbmlzaENsYXNzQ29tcG9uZW50KG51bGwsIHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQsIHRydWUsIGhhc0NvbnRleHQsIHJlbmRlckxhbmVzKTtcbn1cblxuZnVuY3Rpb24gbW91bnRJbmRldGVybWluYXRlQ29tcG9uZW50KF9jdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgQ29tcG9uZW50LCByZW5kZXJMYW5lcykge1xuICBpZiAoX2N1cnJlbnQgIT09IG51bGwpIHtcbiAgICAvLyBBbiBpbmRldGVybWluYXRlIGNvbXBvbmVudCBvbmx5IG1vdW50cyBpZiBpdCBzdXNwZW5kZWQgaW5zaWRlIGEgbm9uLVxuICAgIC8vIGNvbmN1cnJlbnQgdHJlZSwgaW4gYW4gaW5jb25zaXN0ZW50IHN0YXRlLiBXZSB3YW50IHRvIHRyZWF0IGl0IGxpa2VcbiAgICAvLyBhIG5ldyBtb3VudCwgZXZlbiB0aG91Z2ggYW4gZW1wdHkgdmVyc2lvbiBvZiBpdCBhbHJlYWR5IGNvbW1pdHRlZC5cbiAgICAvLyBEaXNjb25uZWN0IHRoZSBhbHRlcm5hdGUgcG9pbnRlcnMuXG4gICAgX2N1cnJlbnQuYWx0ZXJuYXRlID0gbnVsbDtcbiAgICB3b3JrSW5Qcm9ncmVzcy5hbHRlcm5hdGUgPSBudWxsOyAvLyBTaW5jZSB0aGlzIGlzIGNvbmNlcHR1YWxseSBhIG5ldyBmaWJlciwgc2NoZWR1bGUgYSBQbGFjZW1lbnQgZWZmZWN0XG5cbiAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBQbGFjZW1lbnQ7XG4gIH1cblxuICB2YXIgcHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7XG4gIHZhciBjb250ZXh0O1xuXG4gIHtcbiAgICB2YXIgdW5tYXNrZWRDb250ZXh0ID0gZ2V0VW5tYXNrZWRDb250ZXh0KHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQsIGZhbHNlKTtcbiAgICBjb250ZXh0ID0gZ2V0TWFza2VkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgdW5tYXNrZWRDb250ZXh0KTtcbiAgfVxuXG4gIHByZXBhcmVUb1JlYWRDb250ZXh0KHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcyk7XG4gIHZhciB2YWx1ZTtcblxuICB7XG4gICAgaWYgKENvbXBvbmVudC5wcm90b3R5cGUgJiYgdHlwZW9mIENvbXBvbmVudC5wcm90b3R5cGUucmVuZGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWUoQ29tcG9uZW50KSB8fCAnVW5rbm93bic7XG5cbiAgICAgIGlmICghZGlkV2FybkFib3V0QmFkQ2xhc3NbY29tcG9uZW50TmFtZV0pIHtcbiAgICAgICAgZXJyb3IoXCJUaGUgPCVzIC8+IGNvbXBvbmVudCBhcHBlYXJzIHRvIGhhdmUgYSByZW5kZXIgbWV0aG9kLCBidXQgZG9lc24ndCBleHRlbmQgUmVhY3QuQ29tcG9uZW50LiBcIiArICdUaGlzIGlzIGxpa2VseSB0byBjYXVzZSBlcnJvcnMuIENoYW5nZSAlcyB0byBleHRlbmQgUmVhY3QuQ29tcG9uZW50IGluc3RlYWQuJywgY29tcG9uZW50TmFtZSwgY29tcG9uZW50TmFtZSk7XG5cbiAgICAgICAgZGlkV2FybkFib3V0QmFkQ2xhc3NbY29tcG9uZW50TmFtZV0gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh3b3JrSW5Qcm9ncmVzcy5tb2RlICYgU3RyaWN0TW9kZSkge1xuICAgICAgUmVhY3RTdHJpY3RNb2RlV2FybmluZ3MucmVjb3JkTGVnYWN5Q29udGV4dFdhcm5pbmcod29ya0luUHJvZ3Jlc3MsIG51bGwpO1xuICAgIH1cblxuICAgIHNldElzUmVuZGVyaW5nKHRydWUpO1xuICAgIFJlYWN0Q3VycmVudE93bmVyJDEuY3VycmVudCA9IHdvcmtJblByb2dyZXNzO1xuICAgIHZhbHVlID0gcmVuZGVyV2l0aEhvb2tzKG51bGwsIHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQsIHByb3BzLCBjb250ZXh0LCByZW5kZXJMYW5lcyk7XG4gICAgc2V0SXNSZW5kZXJpbmcoZmFsc2UpO1xuICB9IC8vIFJlYWN0IERldlRvb2xzIHJlYWRzIHRoaXMgZmxhZy5cblxuXG4gIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IFBlcmZvcm1lZFdvcms7XG5cbiAge1xuICAgIC8vIFN1cHBvcnQgZm9yIG1vZHVsZSBjb21wb25lbnRzIGlzIGRlcHJlY2F0ZWQgYW5kIGlzIHJlbW92ZWQgYmVoaW5kIGEgZmxhZy5cbiAgICAvLyBXaGV0aGVyIG9yIG5vdCBpdCB3b3VsZCBjcmFzaCBsYXRlciwgd2Ugd2FudCB0byBzaG93IGEgZ29vZCBtZXNzYWdlIGluIERFViBmaXJzdC5cbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAhPT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUucmVuZGVyID09PSAnZnVuY3Rpb24nICYmIHZhbHVlLiQkdHlwZW9mID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHZhciBfY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWUoQ29tcG9uZW50KSB8fCAnVW5rbm93bic7XG5cbiAgICAgIGlmICghZGlkV2FybkFib3V0TW9kdWxlUGF0dGVybkNvbXBvbmVudFtfY29tcG9uZW50TmFtZV0pIHtcbiAgICAgICAgZXJyb3IoJ1RoZSA8JXMgLz4gY29tcG9uZW50IGFwcGVhcnMgdG8gYmUgYSBmdW5jdGlvbiBjb21wb25lbnQgdGhhdCByZXR1cm5zIGEgY2xhc3MgaW5zdGFuY2UuICcgKyAnQ2hhbmdlICVzIHRvIGEgY2xhc3MgdGhhdCBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCBpbnN0ZWFkLiAnICsgXCJJZiB5b3UgY2FuJ3QgdXNlIGEgY2xhc3MgdHJ5IGFzc2lnbmluZyB0aGUgcHJvdG90eXBlIG9uIHRoZSBmdW5jdGlvbiBhcyBhIHdvcmthcm91bmQuIFwiICsgXCJgJXMucHJvdG90eXBlID0gUmVhY3QuQ29tcG9uZW50LnByb3RvdHlwZWAuIERvbid0IHVzZSBhbiBhcnJvdyBmdW5jdGlvbiBzaW5jZSBpdCBcIiArICdjYW5ub3QgYmUgY2FsbGVkIHdpdGggYG5ld2AgYnkgUmVhY3QuJywgX2NvbXBvbmVudE5hbWUsIF9jb21wb25lbnROYW1lLCBfY29tcG9uZW50TmFtZSk7XG5cbiAgICAgICAgZGlkV2FybkFib3V0TW9kdWxlUGF0dGVybkNvbXBvbmVudFtfY29tcG9uZW50TmFtZV0gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmICggLy8gUnVuIHRoZXNlIGNoZWNrcyBpbiBwcm9kdWN0aW9uIG9ubHkgaWYgdGhlIGZsYWcgaXMgb2ZmLlxuICAvLyBFdmVudHVhbGx5IHdlJ2xsIGRlbGV0ZSB0aGlzIGJyYW5jaCBhbHRvZ2V0aGVyLlxuICAgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAhPT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUucmVuZGVyID09PSAnZnVuY3Rpb24nICYmIHZhbHVlLiQkdHlwZW9mID09PSB1bmRlZmluZWQpIHtcbiAgICB7XG4gICAgICB2YXIgX2NvbXBvbmVudE5hbWUyID0gZ2V0Q29tcG9uZW50TmFtZShDb21wb25lbnQpIHx8ICdVbmtub3duJztcblxuICAgICAgaWYgKCFkaWRXYXJuQWJvdXRNb2R1bGVQYXR0ZXJuQ29tcG9uZW50W19jb21wb25lbnROYW1lMl0pIHtcbiAgICAgICAgZXJyb3IoJ1RoZSA8JXMgLz4gY29tcG9uZW50IGFwcGVhcnMgdG8gYmUgYSBmdW5jdGlvbiBjb21wb25lbnQgdGhhdCByZXR1cm5zIGEgY2xhc3MgaW5zdGFuY2UuICcgKyAnQ2hhbmdlICVzIHRvIGEgY2xhc3MgdGhhdCBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCBpbnN0ZWFkLiAnICsgXCJJZiB5b3UgY2FuJ3QgdXNlIGEgY2xhc3MgdHJ5IGFzc2lnbmluZyB0aGUgcHJvdG90eXBlIG9uIHRoZSBmdW5jdGlvbiBhcyBhIHdvcmthcm91bmQuIFwiICsgXCJgJXMucHJvdG90eXBlID0gUmVhY3QuQ29tcG9uZW50LnByb3RvdHlwZWAuIERvbid0IHVzZSBhbiBhcnJvdyBmdW5jdGlvbiBzaW5jZSBpdCBcIiArICdjYW5ub3QgYmUgY2FsbGVkIHdpdGggYG5ld2AgYnkgUmVhY3QuJywgX2NvbXBvbmVudE5hbWUyLCBfY29tcG9uZW50TmFtZTIsIF9jb21wb25lbnROYW1lMik7XG5cbiAgICAgICAgZGlkV2FybkFib3V0TW9kdWxlUGF0dGVybkNvbXBvbmVudFtfY29tcG9uZW50TmFtZTJdID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IC8vIFByb2NlZWQgdW5kZXIgdGhlIGFzc3VtcHRpb24gdGhhdCB0aGlzIGlzIGEgY2xhc3MgaW5zdGFuY2VcblxuXG4gICAgd29ya0luUHJvZ3Jlc3MudGFnID0gQ2xhc3NDb21wb25lbnQ7IC8vIFRocm93IG91dCBhbnkgaG9va3MgdGhhdCB3ZXJlIHVzZWQuXG5cbiAgICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0gbnVsbDtcbiAgICB3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZSA9IG51bGw7IC8vIFB1c2ggY29udGV4dCBwcm92aWRlcnMgZWFybHkgdG8gcHJldmVudCBjb250ZXh0IHN0YWNrIG1pc21hdGNoZXMuXG4gICAgLy8gRHVyaW5nIG1vdW50aW5nIHdlIGRvbid0IGtub3cgdGhlIGNoaWxkIGNvbnRleHQgeWV0IGFzIHRoZSBpbnN0YW5jZSBkb2Vzbid0IGV4aXN0LlxuICAgIC8vIFdlIHdpbGwgaW52YWxpZGF0ZSB0aGUgY2hpbGQgY29udGV4dCBpbiBmaW5pc2hDbGFzc0NvbXBvbmVudCgpIHJpZ2h0IGFmdGVyIHJlbmRlcmluZy5cblxuICAgIHZhciBoYXNDb250ZXh0ID0gZmFsc2U7XG5cbiAgICBpZiAoaXNDb250ZXh0UHJvdmlkZXIoQ29tcG9uZW50KSkge1xuICAgICAgaGFzQ29udGV4dCA9IHRydWU7XG4gICAgICBwdXNoQ29udGV4dFByb3ZpZGVyKHdvcmtJblByb2dyZXNzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaGFzQ29udGV4dCA9IGZhbHNlO1xuICAgIH1cblxuICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSB2YWx1ZS5zdGF0ZSAhPT0gbnVsbCAmJiB2YWx1ZS5zdGF0ZSAhPT0gdW5kZWZpbmVkID8gdmFsdWUuc3RhdGUgOiBudWxsO1xuICAgIGluaXRpYWxpemVVcGRhdGVRdWV1ZSh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgdmFyIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyA9IENvbXBvbmVudC5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHM7XG5cbiAgICBpZiAodHlwZW9mIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgYXBwbHlEZXJpdmVkU3RhdGVGcm9tUHJvcHMod29ya0luUHJvZ3Jlc3MsIENvbXBvbmVudCwgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzLCBwcm9wcyk7XG4gICAgfVxuXG4gICAgYWRvcHRDbGFzc0luc3RhbmNlKHdvcmtJblByb2dyZXNzLCB2YWx1ZSk7XG4gICAgbW91bnRDbGFzc0luc3RhbmNlKHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQsIHByb3BzLCByZW5kZXJMYW5lcyk7XG4gICAgcmV0dXJuIGZpbmlzaENsYXNzQ29tcG9uZW50KG51bGwsIHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQsIHRydWUsIGhhc0NvbnRleHQsIHJlbmRlckxhbmVzKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBQcm9jZWVkIHVuZGVyIHRoZSBhc3N1bXB0aW9uIHRoYXQgdGhpcyBpcyBhIGZ1bmN0aW9uIGNvbXBvbmVudFxuICAgIHdvcmtJblByb2dyZXNzLnRhZyA9IEZ1bmN0aW9uQ29tcG9uZW50O1xuXG4gICAge1xuXG4gICAgICBpZiAoIHdvcmtJblByb2dyZXNzLm1vZGUgJiBTdHJpY3RNb2RlKSB7XG4gICAgICAgIGRpc2FibGVMb2dzKCk7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB2YWx1ZSA9IHJlbmRlcldpdGhIb29rcyhudWxsLCB3b3JrSW5Qcm9ncmVzcywgQ29tcG9uZW50LCBwcm9wcywgY29udGV4dCwgcmVuZGVyTGFuZXMpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIHJlZW5hYmxlTG9ncygpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmVjb25jaWxlQ2hpbGRyZW4obnVsbCwgd29ya0luUHJvZ3Jlc3MsIHZhbHVlLCByZW5kZXJMYW5lcyk7XG5cbiAgICB7XG4gICAgICB2YWxpZGF0ZUZ1bmN0aW9uQ29tcG9uZW50SW5EZXYod29ya0luUHJvZ3Jlc3MsIENvbXBvbmVudCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHdvcmtJblByb2dyZXNzLmNoaWxkO1xuICB9XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlRnVuY3Rpb25Db21wb25lbnRJbkRldih3b3JrSW5Qcm9ncmVzcywgQ29tcG9uZW50KSB7XG4gIHtcbiAgICBpZiAoQ29tcG9uZW50KSB7XG4gICAgICBpZiAoQ29tcG9uZW50LmNoaWxkQ29udGV4dFR5cGVzKSB7XG4gICAgICAgIGVycm9yKCclcyguLi4pOiBjaGlsZENvbnRleHRUeXBlcyBjYW5ub3QgYmUgZGVmaW5lZCBvbiBhIGZ1bmN0aW9uIGNvbXBvbmVudC4nLCBDb21wb25lbnQuZGlzcGxheU5hbWUgfHwgQ29tcG9uZW50Lm5hbWUgfHwgJ0NvbXBvbmVudCcpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh3b3JrSW5Qcm9ncmVzcy5yZWYgIT09IG51bGwpIHtcbiAgICAgIHZhciBpbmZvID0gJyc7XG4gICAgICB2YXIgb3duZXJOYW1lID0gZ2V0Q3VycmVudEZpYmVyT3duZXJOYW1lSW5EZXZPck51bGwoKTtcblxuICAgICAgaWYgKG93bmVyTmFtZSkge1xuICAgICAgICBpbmZvICs9ICdcXG5cXG5DaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBgJyArIG93bmVyTmFtZSArICdgLic7XG4gICAgICB9XG5cbiAgICAgIHZhciB3YXJuaW5nS2V5ID0gb3duZXJOYW1lIHx8IHdvcmtJblByb2dyZXNzLl9kZWJ1Z0lEIHx8ICcnO1xuICAgICAgdmFyIGRlYnVnU291cmNlID0gd29ya0luUHJvZ3Jlc3MuX2RlYnVnU291cmNlO1xuXG4gICAgICBpZiAoZGVidWdTb3VyY2UpIHtcbiAgICAgICAgd2FybmluZ0tleSA9IGRlYnVnU291cmNlLmZpbGVOYW1lICsgJzonICsgZGVidWdTb3VyY2UubGluZU51bWJlcjtcbiAgICAgIH1cblxuICAgICAgaWYgKCFkaWRXYXJuQWJvdXRGdW5jdGlvblJlZnNbd2FybmluZ0tleV0pIHtcbiAgICAgICAgZGlkV2FybkFib3V0RnVuY3Rpb25SZWZzW3dhcm5pbmdLZXldID0gdHJ1ZTtcblxuICAgICAgICBlcnJvcignRnVuY3Rpb24gY29tcG9uZW50cyBjYW5ub3QgYmUgZ2l2ZW4gcmVmcy4gJyArICdBdHRlbXB0cyB0byBhY2Nlc3MgdGhpcyByZWYgd2lsbCBmYWlsLiAnICsgJ0RpZCB5b3UgbWVhbiB0byB1c2UgUmVhY3QuZm9yd2FyZFJlZigpPyVzJywgaW5mbyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBDb21wb25lbnQuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB2YXIgX2NvbXBvbmVudE5hbWUzID0gZ2V0Q29tcG9uZW50TmFtZShDb21wb25lbnQpIHx8ICdVbmtub3duJztcblxuICAgICAgaWYgKCFkaWRXYXJuQWJvdXRHZXREZXJpdmVkU3RhdGVPbkZ1bmN0aW9uQ29tcG9uZW50W19jb21wb25lbnROYW1lM10pIHtcbiAgICAgICAgZXJyb3IoJyVzOiBGdW5jdGlvbiBjb21wb25lbnRzIGRvIG5vdCBzdXBwb3J0IGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcy4nLCBfY29tcG9uZW50TmFtZTMpO1xuXG4gICAgICAgIGRpZFdhcm5BYm91dEdldERlcml2ZWRTdGF0ZU9uRnVuY3Rpb25Db21wb25lbnRbX2NvbXBvbmVudE5hbWUzXSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBDb21wb25lbnQuY29udGV4dFR5cGUgPT09ICdvYmplY3QnICYmIENvbXBvbmVudC5jb250ZXh0VHlwZSAhPT0gbnVsbCkge1xuICAgICAgdmFyIF9jb21wb25lbnROYW1lNCA9IGdldENvbXBvbmVudE5hbWUoQ29tcG9uZW50KSB8fCAnVW5rbm93bic7XG5cbiAgICAgIGlmICghZGlkV2FybkFib3V0Q29udGV4dFR5cGVPbkZ1bmN0aW9uQ29tcG9uZW50W19jb21wb25lbnROYW1lNF0pIHtcbiAgICAgICAgZXJyb3IoJyVzOiBGdW5jdGlvbiBjb21wb25lbnRzIGRvIG5vdCBzdXBwb3J0IGNvbnRleHRUeXBlLicsIF9jb21wb25lbnROYW1lNCk7XG5cbiAgICAgICAgZGlkV2FybkFib3V0Q29udGV4dFR5cGVPbkZ1bmN0aW9uQ29tcG9uZW50W19jb21wb25lbnROYW1lNF0gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG52YXIgU1VTUEVOREVEX01BUktFUiA9IHtcbiAgZGVoeWRyYXRlZDogbnVsbCxcbiAgcmV0cnlMYW5lOiBOb0xhbmVcbn07XG5cbmZ1bmN0aW9uIG1vdW50U3VzcGVuc2VPZmZzY3JlZW5TdGF0ZShyZW5kZXJMYW5lcykge1xuICByZXR1cm4ge1xuICAgIGJhc2VMYW5lczogcmVuZGVyTGFuZXNcbiAgfTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlU3VzcGVuc2VPZmZzY3JlZW5TdGF0ZShwcmV2T2Zmc2NyZWVuU3RhdGUsIHJlbmRlckxhbmVzKSB7XG4gIHJldHVybiB7XG4gICAgYmFzZUxhbmVzOiBtZXJnZUxhbmVzKHByZXZPZmZzY3JlZW5TdGF0ZS5iYXNlTGFuZXMsIHJlbmRlckxhbmVzKVxuICB9O1xufSAvLyBUT0RPOiBQcm9iYWJseSBzaG91bGQgaW5saW5lIHRoaXMgYmFja1xuXG5cbmZ1bmN0aW9uIHNob3VsZFJlbWFpbk9uRmFsbGJhY2soc3VzcGVuc2VDb250ZXh0LCBjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpIHtcbiAgLy8gSWYgd2UncmUgYWxyZWFkeSBzaG93aW5nIGEgZmFsbGJhY2ssIHRoZXJlIGFyZSBjYXNlcyB3aGVyZSB3ZSBuZWVkIHRvXG4gIC8vIHJlbWFpbiBvbiB0aGF0IGZhbGxiYWNrIHJlZ2FyZGxlc3Mgb2Ygd2hldGhlciB0aGUgY29udGVudCBoYXMgcmVzb2x2ZWQuXG4gIC8vIEZvciBleGFtcGxlLCBTdXNwZW5zZUxpc3QgY29vcmRpbmF0ZXMgd2hlbiBuZXN0ZWQgY29udGVudCBhcHBlYXJzLlxuICBpZiAoY3VycmVudCAhPT0gbnVsbCkge1xuICAgIHZhciBzdXNwZW5zZVN0YXRlID0gY3VycmVudC5tZW1vaXplZFN0YXRlO1xuXG4gICAgaWYgKHN1c3BlbnNlU3RhdGUgPT09IG51bGwpIHtcbiAgICAgIC8vIEN1cnJlbnRseSBzaG93aW5nIGNvbnRlbnQuIERvbid0IGhpZGUgaXQsIGV2ZW4gaWYgRm9yY2VTdXNwZW5zZUZhbGxhY2tcbiAgICAgIC8vIGlzIHRydWUuIE1vcmUgcHJlY2lzZSBuYW1lIG1pZ2h0IGJlIFwiRm9yY2VSZW1haW5TdXNwZW5zZUZhbGxiYWNrXCIuXG4gICAgICAvLyBOb3RlOiBUaGlzIGlzIGEgZmFjdG9yaW5nIHNtZWxsLiBDYW4ndCByZW1haW4gb24gYSBmYWxsYmFjayBpZiB0aGVyZSdzXG4gICAgICAvLyBubyBmYWxsYmFjayB0byByZW1haW4gb24uXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9IC8vIE5vdCBjdXJyZW50bHkgc2hvd2luZyBjb250ZW50LiBDb25zdWx0IHRoZSBTdXNwZW5zZSBjb250ZXh0LlxuXG5cbiAgcmV0dXJuIGhhc1N1c3BlbnNlQ29udGV4dChzdXNwZW5zZUNvbnRleHQsIEZvcmNlU3VzcGVuc2VGYWxsYmFjayk7XG59XG5cbmZ1bmN0aW9uIGdldFJlbWFpbmluZ1dvcmtJblByaW1hcnlUcmVlKGN1cnJlbnQsIHJlbmRlckxhbmVzKSB7XG4gIC8vIFRPRE86IFNob3VsZCBub3QgcmVtb3ZlIHJlbmRlciBsYW5lcyB0aGF0IHdlcmUgcGluZ2VkIGR1cmluZyB0aGlzIHJlbmRlclxuICByZXR1cm4gcmVtb3ZlTGFuZXMoY3VycmVudC5jaGlsZExhbmVzLCByZW5kZXJMYW5lcyk7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZVN1c3BlbnNlQ29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcykge1xuICB2YXIgbmV4dFByb3BzID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzOyAvLyBUaGlzIGlzIHVzZWQgYnkgRGV2VG9vbHMgdG8gZm9yY2UgYSBib3VuZGFyeSB0byBzdXNwZW5kLlxuXG4gIHtcbiAgICBpZiAoc2hvdWxkU3VzcGVuZCh3b3JrSW5Qcm9ncmVzcykpIHtcbiAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IERpZENhcHR1cmU7XG4gICAgfVxuICB9XG5cbiAgdmFyIHN1c3BlbnNlQ29udGV4dCA9IHN1c3BlbnNlU3RhY2tDdXJzb3IuY3VycmVudDtcbiAgdmFyIHNob3dGYWxsYmFjayA9IGZhbHNlO1xuICB2YXIgZGlkU3VzcGVuZCA9ICh3b3JrSW5Qcm9ncmVzcy5mbGFncyAmIERpZENhcHR1cmUpICE9PSBOb0ZsYWdzO1xuXG4gIGlmIChkaWRTdXNwZW5kIHx8IHNob3VsZFJlbWFpbk9uRmFsbGJhY2soc3VzcGVuc2VDb250ZXh0LCBjdXJyZW50KSkge1xuICAgIC8vIFNvbWV0aGluZyBpbiB0aGlzIGJvdW5kYXJ5J3Mgc3VidHJlZSBhbHJlYWR5IHN1c3BlbmRlZC4gU3dpdGNoIHRvXG4gICAgLy8gcmVuZGVyaW5nIHRoZSBmYWxsYmFjayBjaGlsZHJlbi5cbiAgICBzaG93RmFsbGJhY2sgPSB0cnVlO1xuICAgIHdvcmtJblByb2dyZXNzLmZsYWdzICY9IH5EaWRDYXB0dXJlO1xuICB9IGVsc2Uge1xuICAgIC8vIEF0dGVtcHRpbmcgdGhlIG1haW4gY29udGVudFxuICAgIGlmIChjdXJyZW50ID09PSBudWxsIHx8IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZSAhPT0gbnVsbCkge1xuICAgICAgLy8gVGhpcyBpcyBhIG5ldyBtb3VudCBvciB0aGlzIGJvdW5kYXJ5IGlzIGFscmVhZHkgc2hvd2luZyBhIGZhbGxiYWNrIHN0YXRlLlxuICAgICAgLy8gTWFyayB0aGlzIHN1YnRyZWUgY29udGV4dCBhcyBoYXZpbmcgYXQgbGVhc3Qgb25lIGludmlzaWJsZSBwYXJlbnQgdGhhdCBjb3VsZFxuICAgICAgLy8gaGFuZGxlIHRoZSBmYWxsYmFjayBzdGF0ZS5cbiAgICAgIC8vIEJvdW5kYXJpZXMgd2l0aG91dCBmYWxsYmFja3Mgb3Igc2hvdWxkIGJlIGF2b2lkZWQgYXJlIG5vdCBjb25zaWRlcmVkIHNpbmNlXG4gICAgICAvLyB0aGV5IGNhbm5vdCBoYW5kbGUgcHJlZmVycmVkIGZhbGxiYWNrIHN0YXRlcy5cbiAgICAgIGlmIChuZXh0UHJvcHMuZmFsbGJhY2sgIT09IHVuZGVmaW5lZCAmJiBuZXh0UHJvcHMudW5zdGFibGVfYXZvaWRUaGlzRmFsbGJhY2sgIT09IHRydWUpIHtcbiAgICAgICAgc3VzcGVuc2VDb250ZXh0ID0gYWRkU3VidHJlZVN1c3BlbnNlQ29udGV4dChzdXNwZW5zZUNvbnRleHQsIEludmlzaWJsZVBhcmVudFN1c3BlbnNlQ29udGV4dCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgc3VzcGVuc2VDb250ZXh0ID0gc2V0RGVmYXVsdFNoYWxsb3dTdXNwZW5zZUNvbnRleHQoc3VzcGVuc2VDb250ZXh0KTtcbiAgcHVzaFN1c3BlbnNlQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgc3VzcGVuc2VDb250ZXh0KTsgLy8gT0ssIHRoZSBuZXh0IHBhcnQgaXMgY29uZnVzaW5nLiBXZSdyZSBhYm91dCB0byByZWNvbmNpbGUgdGhlIFN1c3BlbnNlXG4gIC8vIGJvdW5kYXJ5J3MgY2hpbGRyZW4uIFRoaXMgaW52b2x2ZXMgc29tZSBjdXN0b20gcmVjb25jaWxhdGlvbiBsb2dpYy4gVHdvXG4gIC8vIG1haW4gcmVhc29ucyB0aGlzIGlzIHNvIGNvbXBsaWNhdGVkLlxuICAvL1xuICAvLyBGaXJzdCwgTGVnYWN5IE1vZGUgaGFzIGRpZmZlcmVudCBzZW1hbnRpY3MgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LiBUaGVcbiAgLy8gcHJpbWFyeSB0cmVlIHdpbGwgY29tbWl0IGluIGFuIGluY29uc2lzdGVudCBzdGF0ZSwgc28gd2hlbiB3ZSBkbyB0aGVcbiAgLy8gc2Vjb25kIHBhc3MgdG8gcmVuZGVyIHRoZSBmYWxsYmFjaywgd2UgZG8gc29tZSBleGNlZWRpbmdseSwgdWgsIGNsZXZlclxuICAvLyBoYWNrcyB0byBtYWtlIHRoYXQgbm90IHRvdGFsbHkgYnJlYWsuIExpa2UgdHJhbnNmZXJyaW5nIGVmZmVjdHMgYW5kXG4gIC8vIGRlbGV0aW9ucyBmcm9tIGhpZGRlbiB0cmVlLiBJbiBDb25jdXJyZW50IE1vZGUsIGl0J3MgbXVjaCBzaW1wbGVyLFxuICAvLyBiZWNhdXNlIHdlIGJhaWxvdXQgb24gdGhlIHByaW1hcnkgdHJlZSBjb21wbGV0ZWx5IGFuZCBsZWF2ZSBpdCBpbiBpdHMgb2xkXG4gIC8vIHN0YXRlLCBubyBlZmZlY3RzLiBTYW1lIGFzIHdoYXQgd2UgZG8gZm9yIE9mZnNjcmVlbiAoZXhjZXB0IHRoYXRcbiAgLy8gT2Zmc2NyZWVuIGRvZXNuJ3QgaGF2ZSB0aGUgZmlyc3QgcmVuZGVyIHBhc3MpLlxuICAvL1xuICAvLyBTZWNvbmQgaXMgaHlkcmF0aW9uLiBEdXJpbmcgaHlkcmF0aW9uLCB0aGUgU3VzcGVuc2UgZmliZXIgaGFzIGEgc2xpZ2h0bHlcbiAgLy8gZGlmZmVyZW50IGxheW91dCwgd2hlcmUgdGhlIGNoaWxkIHBvaW50cyB0byBhIGRlaHlkcmF0ZWQgZnJhZ21lbnQsIHdoaWNoXG4gIC8vIGNvbnRhaW5zIHRoZSBET00gcmVuZGVyZWQgYnkgdGhlIHNlcnZlci5cbiAgLy9cbiAgLy8gVGhpcmQsIGV2ZW4gaWYgeW91IHNldCBhbGwgdGhhdCBhc2lkZSwgU3VzcGVuc2UgaXMgbGlrZSBlcnJvciBib3VuZGFyaWVzIGluXG4gIC8vIHRoYXQgd2UgZmlyc3Qgd2UgdHJ5IHRvIHJlbmRlciBvbmUgdHJlZSwgYW5kIGlmIHRoYXQgZmFpbHMsIHdlIHJlbmRlciBhZ2FpblxuICAvLyBhbmQgc3dpdGNoIHRvIGEgZGlmZmVyZW50IHRyZWUuIExpa2UgYSB0cnkvY2F0Y2ggYmxvY2suIFNvIHdlIGhhdmUgdG8gdHJhY2tcbiAgLy8gd2hpY2ggYnJhbmNoIHdlJ3JlIGN1cnJlbnRseSByZW5kZXJpbmcuIElkZWFsbHkgd2Ugd291bGQgbW9kZWwgdGhpcyB1c2luZ1xuICAvLyBhIHN0YWNrLlxuXG4gIGlmIChjdXJyZW50ID09PSBudWxsKSB7XG4gICAgLy8gSW5pdGlhbCBtb3VudFxuICAgIC8vIElmIHdlJ3JlIGN1cnJlbnRseSBoeWRyYXRpbmcsIHRyeSB0byBoeWRyYXRlIHRoaXMgYm91bmRhcnkuXG4gICAgLy8gQnV0IG9ubHkgaWYgdGhpcyBoYXMgYSBmYWxsYmFjay5cbiAgICBpZiAobmV4dFByb3BzLmZhbGxiYWNrICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRyeVRvQ2xhaW1OZXh0SHlkcmF0YWJsZUluc3RhbmNlKHdvcmtJblByb2dyZXNzKTsgLy8gVGhpcyBjb3VsZCd2ZSBiZWVuIGEgZGVoeWRyYXRlZCBzdXNwZW5zZSBjb21wb25lbnQuXG4gICAgfVxuXG4gICAgdmFyIG5leHRQcmltYXJ5Q2hpbGRyZW4gPSBuZXh0UHJvcHMuY2hpbGRyZW47XG4gICAgdmFyIG5leHRGYWxsYmFja0NoaWxkcmVuID0gbmV4dFByb3BzLmZhbGxiYWNrO1xuXG4gICAgaWYgKHNob3dGYWxsYmFjaykge1xuICAgICAgdmFyIGZhbGxiYWNrRnJhZ21lbnQgPSBtb3VudFN1c3BlbnNlRmFsbGJhY2tDaGlsZHJlbih3b3JrSW5Qcm9ncmVzcywgbmV4dFByaW1hcnlDaGlsZHJlbiwgbmV4dEZhbGxiYWNrQ2hpbGRyZW4sIHJlbmRlckxhbmVzKTtcbiAgICAgIHZhciBwcmltYXJ5Q2hpbGRGcmFnbWVudCA9IHdvcmtJblByb2dyZXNzLmNoaWxkO1xuICAgICAgcHJpbWFyeUNoaWxkRnJhZ21lbnQubWVtb2l6ZWRTdGF0ZSA9IG1vdW50U3VzcGVuc2VPZmZzY3JlZW5TdGF0ZShyZW5kZXJMYW5lcyk7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0gU1VTUEVOREVEX01BUktFUjtcbiAgICAgIHJldHVybiBmYWxsYmFja0ZyYWdtZW50O1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIG5leHRQcm9wcy51bnN0YWJsZV9leHBlY3RlZExvYWRUaW1lID09PSAnbnVtYmVyJykge1xuICAgICAgLy8gVGhpcyBpcyBhIENQVS1ib3VuZCB0cmVlLiBTa2lwIHRoaXMgdHJlZSBhbmQgc2hvdyBhIHBsYWNlaG9sZGVyIHRvXG4gICAgICAvLyB1bmJsb2NrIHRoZSBzdXJyb3VuZGluZyBjb250ZW50LiBUaGVuIGltbWVkaWF0ZWx5IHJldHJ5IGFmdGVyIHRoZVxuICAgICAgLy8gaW5pdGlhbCBjb21taXQuXG4gICAgICB2YXIgX2ZhbGxiYWNrRnJhZ21lbnQgPSBtb3VudFN1c3BlbnNlRmFsbGJhY2tDaGlsZHJlbih3b3JrSW5Qcm9ncmVzcywgbmV4dFByaW1hcnlDaGlsZHJlbiwgbmV4dEZhbGxiYWNrQ2hpbGRyZW4sIHJlbmRlckxhbmVzKTtcblxuICAgICAgdmFyIF9wcmltYXJ5Q2hpbGRGcmFnbWVudCA9IHdvcmtJblByb2dyZXNzLmNoaWxkO1xuICAgICAgX3ByaW1hcnlDaGlsZEZyYWdtZW50Lm1lbW9pemVkU3RhdGUgPSBtb3VudFN1c3BlbnNlT2Zmc2NyZWVuU3RhdGUocmVuZGVyTGFuZXMpO1xuICAgICAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IFNVU1BFTkRFRF9NQVJLRVI7IC8vIFNpbmNlIG5vdGhpbmcgYWN0dWFsbHkgc3VzcGVuZGVkLCB0aGVyZSB3aWxsIG5vdGhpbmcgdG8gcGluZyB0aGlzIHRvXG4gICAgICAvLyBnZXQgaXQgc3RhcnRlZCBiYWNrIHVwIHRvIGF0dGVtcHQgdGhlIG5leHQgaXRlbS4gV2hpbGUgaW4gdGVybXMgb2ZcbiAgICAgIC8vIHByaW9yaXR5IHRoaXMgd29yayBoYXMgdGhlIHNhbWUgcHJpb3JpdHkgYXMgdGhpcyBjdXJyZW50IHJlbmRlciwgaXQnc1xuICAgICAgLy8gbm90IHBhcnQgb2YgdGhlIHNhbWUgdHJhbnNpdGlvbiBvbmNlIHRoZSB0cmFuc2l0aW9uIGhhcyBjb21taXR0ZWQuIElmXG4gICAgICAvLyBpdCdzIHN5bmMsIHdlIHN0aWxsIHdhbnQgdG8geWllbGQgc28gdGhhdCBpdCBjYW4gYmUgcGFpbnRlZC5cbiAgICAgIC8vIENvbmNlcHR1YWxseSwgdGhpcyBpcyByZWFsbHkgdGhlIHNhbWUgYXMgcGluZ2luZy4gV2UgY2FuIHVzZSBhbnlcbiAgICAgIC8vIFJldHJ5TGFuZSBldmVuIGlmIGl0J3MgdGhlIG9uZSBjdXJyZW50bHkgcmVuZGVyaW5nIHNpbmNlIHdlJ3JlIGxlYXZpbmdcbiAgICAgIC8vIGl0IGJlaGluZCBvbiB0aGlzIG5vZGUuXG5cbiAgICAgIHdvcmtJblByb2dyZXNzLmxhbmVzID0gU29tZVJldHJ5TGFuZTtcblxuICAgICAge1xuICAgICAgICBtYXJrU3Bhd25lZFdvcmsoU29tZVJldHJ5TGFuZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBfZmFsbGJhY2tGcmFnbWVudDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG1vdW50U3VzcGVuc2VQcmltYXJ5Q2hpbGRyZW4od29ya0luUHJvZ3Jlc3MsIG5leHRQcmltYXJ5Q2hpbGRyZW4sIHJlbmRlckxhbmVzKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gVGhpcyBpcyBhbiB1cGRhdGUuXG4gICAgLy8gSWYgdGhlIGN1cnJlbnQgZmliZXIgaGFzIGEgU3VzcGVuc2VTdGF0ZSwgdGhhdCBtZWFucyBpdCdzIGFscmVhZHkgc2hvd2luZ1xuICAgIC8vIGEgZmFsbGJhY2suXG4gICAgdmFyIHByZXZTdGF0ZSA9IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZTtcblxuICAgIGlmIChwcmV2U3RhdGUgIT09IG51bGwpIHtcblxuICAgICAgaWYgKHNob3dGYWxsYmFjaykge1xuICAgICAgICB2YXIgX25leHRGYWxsYmFja0NoaWxkcmVuMiA9IG5leHRQcm9wcy5mYWxsYmFjaztcbiAgICAgICAgdmFyIF9uZXh0UHJpbWFyeUNoaWxkcmVuMiA9IG5leHRQcm9wcy5jaGlsZHJlbjtcblxuICAgICAgICB2YXIgX2ZhbGxiYWNrQ2hpbGRGcmFnbWVudCA9IHVwZGF0ZVN1c3BlbnNlRmFsbGJhY2tDaGlsZHJlbihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgX25leHRQcmltYXJ5Q2hpbGRyZW4yLCBfbmV4dEZhbGxiYWNrQ2hpbGRyZW4yLCByZW5kZXJMYW5lcyk7XG5cbiAgICAgICAgdmFyIF9wcmltYXJ5Q2hpbGRGcmFnbWVudDMgPSB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbiAgICAgICAgdmFyIHByZXZPZmZzY3JlZW5TdGF0ZSA9IGN1cnJlbnQuY2hpbGQubWVtb2l6ZWRTdGF0ZTtcbiAgICAgICAgX3ByaW1hcnlDaGlsZEZyYWdtZW50My5tZW1vaXplZFN0YXRlID0gcHJldk9mZnNjcmVlblN0YXRlID09PSBudWxsID8gbW91bnRTdXNwZW5zZU9mZnNjcmVlblN0YXRlKHJlbmRlckxhbmVzKSA6IHVwZGF0ZVN1c3BlbnNlT2Zmc2NyZWVuU3RhdGUocHJldk9mZnNjcmVlblN0YXRlLCByZW5kZXJMYW5lcyk7XG4gICAgICAgIF9wcmltYXJ5Q2hpbGRGcmFnbWVudDMuY2hpbGRMYW5lcyA9IGdldFJlbWFpbmluZ1dvcmtJblByaW1hcnlUcmVlKGN1cnJlbnQsIHJlbmRlckxhbmVzKTtcbiAgICAgICAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IFNVU1BFTkRFRF9NQVJLRVI7XG4gICAgICAgIHJldHVybiBfZmFsbGJhY2tDaGlsZEZyYWdtZW50O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIF9uZXh0UHJpbWFyeUNoaWxkcmVuMyA9IG5leHRQcm9wcy5jaGlsZHJlbjtcblxuICAgICAgICB2YXIgX3ByaW1hcnlDaGlsZEZyYWdtZW50NCA9IHVwZGF0ZVN1c3BlbnNlUHJpbWFyeUNoaWxkcmVuKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBfbmV4dFByaW1hcnlDaGlsZHJlbjMsIHJlbmRlckxhbmVzKTtcblxuICAgICAgICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIF9wcmltYXJ5Q2hpbGRGcmFnbWVudDQ7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRoZSBjdXJyZW50IHRyZWUgaXMgbm90IGFscmVhZHkgc2hvd2luZyBhIGZhbGxiYWNrLlxuICAgICAgaWYgKHNob3dGYWxsYmFjaykge1xuICAgICAgICAvLyBUaW1lZCBvdXQuXG4gICAgICAgIHZhciBfbmV4dEZhbGxiYWNrQ2hpbGRyZW4zID0gbmV4dFByb3BzLmZhbGxiYWNrO1xuICAgICAgICB2YXIgX25leHRQcmltYXJ5Q2hpbGRyZW40ID0gbmV4dFByb3BzLmNoaWxkcmVuO1xuXG4gICAgICAgIHZhciBfZmFsbGJhY2tDaGlsZEZyYWdtZW50MiA9IHVwZGF0ZVN1c3BlbnNlRmFsbGJhY2tDaGlsZHJlbihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgX25leHRQcmltYXJ5Q2hpbGRyZW40LCBfbmV4dEZhbGxiYWNrQ2hpbGRyZW4zLCByZW5kZXJMYW5lcyk7XG5cbiAgICAgICAgdmFyIF9wcmltYXJ5Q2hpbGRGcmFnbWVudDUgPSB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbiAgICAgICAgdmFyIF9wcmV2T2Zmc2NyZWVuU3RhdGUgPSBjdXJyZW50LmNoaWxkLm1lbW9pemVkU3RhdGU7XG4gICAgICAgIF9wcmltYXJ5Q2hpbGRGcmFnbWVudDUubWVtb2l6ZWRTdGF0ZSA9IF9wcmV2T2Zmc2NyZWVuU3RhdGUgPT09IG51bGwgPyBtb3VudFN1c3BlbnNlT2Zmc2NyZWVuU3RhdGUocmVuZGVyTGFuZXMpIDogdXBkYXRlU3VzcGVuc2VPZmZzY3JlZW5TdGF0ZShfcHJldk9mZnNjcmVlblN0YXRlLCByZW5kZXJMYW5lcyk7XG4gICAgICAgIF9wcmltYXJ5Q2hpbGRGcmFnbWVudDUuY2hpbGRMYW5lcyA9IGdldFJlbWFpbmluZ1dvcmtJblByaW1hcnlUcmVlKGN1cnJlbnQsIHJlbmRlckxhbmVzKTsgLy8gU2tpcCB0aGUgcHJpbWFyeSBjaGlsZHJlbiwgYW5kIGNvbnRpbnVlIHdvcmtpbmcgb24gdGhlXG4gICAgICAgIC8vIGZhbGxiYWNrIGNoaWxkcmVuLlxuXG4gICAgICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBTVVNQRU5ERURfTUFSS0VSO1xuICAgICAgICByZXR1cm4gX2ZhbGxiYWNrQ2hpbGRGcmFnbWVudDI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBTdGlsbCBoYXZlbid0IHRpbWVkIG91dC4gQ29udGludWUgcmVuZGVyaW5nIHRoZSBjaGlsZHJlbiwgbGlrZSB3ZVxuICAgICAgICAvLyBub3JtYWxseSBkby5cbiAgICAgICAgdmFyIF9uZXh0UHJpbWFyeUNoaWxkcmVuNSA9IG5leHRQcm9wcy5jaGlsZHJlbjtcblxuICAgICAgICB2YXIgX3ByaW1hcnlDaGlsZEZyYWdtZW50NiA9IHVwZGF0ZVN1c3BlbnNlUHJpbWFyeUNoaWxkcmVuKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBfbmV4dFByaW1hcnlDaGlsZHJlbjUsIHJlbmRlckxhbmVzKTtcblxuICAgICAgICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIF9wcmltYXJ5Q2hpbGRGcmFnbWVudDY7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIG1vdW50U3VzcGVuc2VQcmltYXJ5Q2hpbGRyZW4od29ya0luUHJvZ3Jlc3MsIHByaW1hcnlDaGlsZHJlbiwgcmVuZGVyTGFuZXMpIHtcbiAgdmFyIG1vZGUgPSB3b3JrSW5Qcm9ncmVzcy5tb2RlO1xuICB2YXIgcHJpbWFyeUNoaWxkUHJvcHMgPSB7XG4gICAgbW9kZTogJ3Zpc2libGUnLFxuICAgIGNoaWxkcmVuOiBwcmltYXJ5Q2hpbGRyZW5cbiAgfTtcbiAgdmFyIHByaW1hcnlDaGlsZEZyYWdtZW50ID0gY3JlYXRlRmliZXJGcm9tT2Zmc2NyZWVuKHByaW1hcnlDaGlsZFByb3BzLCBtb2RlLCByZW5kZXJMYW5lcywgbnVsbCk7XG4gIHByaW1hcnlDaGlsZEZyYWdtZW50LnJldHVybiA9IHdvcmtJblByb2dyZXNzO1xuICB3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IHByaW1hcnlDaGlsZEZyYWdtZW50O1xuICByZXR1cm4gcHJpbWFyeUNoaWxkRnJhZ21lbnQ7XG59XG5cbmZ1bmN0aW9uIG1vdW50U3VzcGVuc2VGYWxsYmFja0NoaWxkcmVuKHdvcmtJblByb2dyZXNzLCBwcmltYXJ5Q2hpbGRyZW4sIGZhbGxiYWNrQ2hpbGRyZW4sIHJlbmRlckxhbmVzKSB7XG4gIHZhciBtb2RlID0gd29ya0luUHJvZ3Jlc3MubW9kZTtcbiAgdmFyIHByb2dyZXNzZWRQcmltYXJ5RnJhZ21lbnQgPSB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbiAgdmFyIHByaW1hcnlDaGlsZFByb3BzID0ge1xuICAgIG1vZGU6ICdoaWRkZW4nLFxuICAgIGNoaWxkcmVuOiBwcmltYXJ5Q2hpbGRyZW5cbiAgfTtcbiAgdmFyIHByaW1hcnlDaGlsZEZyYWdtZW50O1xuICB2YXIgZmFsbGJhY2tDaGlsZEZyYWdtZW50O1xuXG4gIGlmICgobW9kZSAmIEJsb2NraW5nTW9kZSkgPT09IE5vTW9kZSAmJiBwcm9ncmVzc2VkUHJpbWFyeUZyYWdtZW50ICE9PSBudWxsKSB7XG4gICAgLy8gSW4gbGVnYWN5IG1vZGUsIHdlIGNvbW1pdCB0aGUgcHJpbWFyeSB0cmVlIGFzIGlmIGl0IHN1Y2Nlc3NmdWxseVxuICAgIC8vIGNvbXBsZXRlZCwgZXZlbiB0aG91Z2ggaXQncyBpbiBhbiBpbmNvbnNpc3RlbnQgc3RhdGUuXG4gICAgcHJpbWFyeUNoaWxkRnJhZ21lbnQgPSBwcm9ncmVzc2VkUHJpbWFyeUZyYWdtZW50O1xuICAgIHByaW1hcnlDaGlsZEZyYWdtZW50LmNoaWxkTGFuZXMgPSBOb0xhbmVzO1xuICAgIHByaW1hcnlDaGlsZEZyYWdtZW50LnBlbmRpbmdQcm9wcyA9IHByaW1hcnlDaGlsZFByb3BzO1xuXG4gICAgaWYgKCB3b3JrSW5Qcm9ncmVzcy5tb2RlICYgUHJvZmlsZU1vZGUpIHtcbiAgICAgIC8vIFJlc2V0IHRoZSBkdXJhdGlvbnMgZnJvbSB0aGUgZmlyc3QgcGFzcyBzbyB0aGV5IGFyZW4ndCBpbmNsdWRlZCBpbiB0aGVcbiAgICAgIC8vIGZpbmFsIGFtb3VudHMuIFRoaXMgc2VlbXMgY291bnRlcmludHVpdGl2ZSwgc2luY2Ugd2UncmUgaW50ZW50aW9uYWxseVxuICAgICAgLy8gbm90IG1lYXN1cmluZyBwYXJ0IG9mIHRoZSByZW5kZXIgcGhhc2UsIGJ1dCB0aGlzIG1ha2VzIGl0IG1hdGNoIHdoYXQgd2VcbiAgICAgIC8vIGRvIGluIENvbmN1cnJlbnQgTW9kZS5cbiAgICAgIHByaW1hcnlDaGlsZEZyYWdtZW50LmFjdHVhbER1cmF0aW9uID0gMDtcbiAgICAgIHByaW1hcnlDaGlsZEZyYWdtZW50LmFjdHVhbFN0YXJ0VGltZSA9IC0xO1xuICAgICAgcHJpbWFyeUNoaWxkRnJhZ21lbnQuc2VsZkJhc2VEdXJhdGlvbiA9IDA7XG4gICAgICBwcmltYXJ5Q2hpbGRGcmFnbWVudC50cmVlQmFzZUR1cmF0aW9uID0gMDtcbiAgICB9XG5cbiAgICBmYWxsYmFja0NoaWxkRnJhZ21lbnQgPSBjcmVhdGVGaWJlckZyb21GcmFnbWVudChmYWxsYmFja0NoaWxkcmVuLCBtb2RlLCByZW5kZXJMYW5lcywgbnVsbCk7XG4gIH0gZWxzZSB7XG4gICAgcHJpbWFyeUNoaWxkRnJhZ21lbnQgPSBjcmVhdGVGaWJlckZyb21PZmZzY3JlZW4ocHJpbWFyeUNoaWxkUHJvcHMsIG1vZGUsIE5vTGFuZXMsIG51bGwpO1xuICAgIGZhbGxiYWNrQ2hpbGRGcmFnbWVudCA9IGNyZWF0ZUZpYmVyRnJvbUZyYWdtZW50KGZhbGxiYWNrQ2hpbGRyZW4sIG1vZGUsIHJlbmRlckxhbmVzLCBudWxsKTtcbiAgfVxuXG4gIHByaW1hcnlDaGlsZEZyYWdtZW50LnJldHVybiA9IHdvcmtJblByb2dyZXNzO1xuICBmYWxsYmFja0NoaWxkRnJhZ21lbnQucmV0dXJuID0gd29ya0luUHJvZ3Jlc3M7XG4gIHByaW1hcnlDaGlsZEZyYWdtZW50LnNpYmxpbmcgPSBmYWxsYmFja0NoaWxkRnJhZ21lbnQ7XG4gIHdvcmtJblByb2dyZXNzLmNoaWxkID0gcHJpbWFyeUNoaWxkRnJhZ21lbnQ7XG4gIHJldHVybiBmYWxsYmFja0NoaWxkRnJhZ21lbnQ7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVdvcmtJblByb2dyZXNzT2Zmc2NyZWVuRmliZXIoY3VycmVudCwgb2Zmc2NyZWVuUHJvcHMpIHtcbiAgLy8gVGhlIHByb3BzIGFyZ3VtZW50IHRvIGBjcmVhdGVXb3JrSW5Qcm9ncmVzc2AgaXMgYGFueWAgdHlwZWQsIHNvIHdlIHVzZSB0aGlzXG4gIC8vIHdyYXBwZXIgZnVuY3Rpb24gdG8gY29uc3RyYWluIGl0LlxuICByZXR1cm4gY3JlYXRlV29ya0luUHJvZ3Jlc3MoY3VycmVudCwgb2Zmc2NyZWVuUHJvcHMpO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVTdXNwZW5zZVByaW1hcnlDaGlsZHJlbihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcHJpbWFyeUNoaWxkcmVuLCByZW5kZXJMYW5lcykge1xuICB2YXIgY3VycmVudFByaW1hcnlDaGlsZEZyYWdtZW50ID0gY3VycmVudC5jaGlsZDtcbiAgdmFyIGN1cnJlbnRGYWxsYmFja0NoaWxkRnJhZ21lbnQgPSBjdXJyZW50UHJpbWFyeUNoaWxkRnJhZ21lbnQuc2libGluZztcbiAgdmFyIHByaW1hcnlDaGlsZEZyYWdtZW50ID0gY3JlYXRlV29ya0luUHJvZ3Jlc3NPZmZzY3JlZW5GaWJlcihjdXJyZW50UHJpbWFyeUNoaWxkRnJhZ21lbnQsIHtcbiAgICBtb2RlOiAndmlzaWJsZScsXG4gICAgY2hpbGRyZW46IHByaW1hcnlDaGlsZHJlblxuICB9KTtcblxuICBpZiAoKHdvcmtJblByb2dyZXNzLm1vZGUgJiBCbG9ja2luZ01vZGUpID09PSBOb01vZGUpIHtcbiAgICBwcmltYXJ5Q2hpbGRGcmFnbWVudC5sYW5lcyA9IHJlbmRlckxhbmVzO1xuICB9XG5cbiAgcHJpbWFyeUNoaWxkRnJhZ21lbnQucmV0dXJuID0gd29ya0luUHJvZ3Jlc3M7XG4gIHByaW1hcnlDaGlsZEZyYWdtZW50LnNpYmxpbmcgPSBudWxsO1xuXG4gIGlmIChjdXJyZW50RmFsbGJhY2tDaGlsZEZyYWdtZW50ICE9PSBudWxsKSB7XG4gICAgLy8gRGVsZXRlIHRoZSBmYWxsYmFjayBjaGlsZCBmcmFnbWVudFxuICAgIGN1cnJlbnRGYWxsYmFja0NoaWxkRnJhZ21lbnQubmV4dEVmZmVjdCA9IG51bGw7XG4gICAgY3VycmVudEZhbGxiYWNrQ2hpbGRGcmFnbWVudC5mbGFncyA9IERlbGV0aW9uO1xuICAgIHdvcmtJblByb2dyZXNzLmZpcnN0RWZmZWN0ID0gd29ya0luUHJvZ3Jlc3MubGFzdEVmZmVjdCA9IGN1cnJlbnRGYWxsYmFja0NoaWxkRnJhZ21lbnQ7XG4gIH1cblxuICB3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IHByaW1hcnlDaGlsZEZyYWdtZW50O1xuICByZXR1cm4gcHJpbWFyeUNoaWxkRnJhZ21lbnQ7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZVN1c3BlbnNlRmFsbGJhY2tDaGlsZHJlbihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcHJpbWFyeUNoaWxkcmVuLCBmYWxsYmFja0NoaWxkcmVuLCByZW5kZXJMYW5lcykge1xuICB2YXIgbW9kZSA9IHdvcmtJblByb2dyZXNzLm1vZGU7XG4gIHZhciBjdXJyZW50UHJpbWFyeUNoaWxkRnJhZ21lbnQgPSBjdXJyZW50LmNoaWxkO1xuICB2YXIgY3VycmVudEZhbGxiYWNrQ2hpbGRGcmFnbWVudCA9IGN1cnJlbnRQcmltYXJ5Q2hpbGRGcmFnbWVudC5zaWJsaW5nO1xuICB2YXIgcHJpbWFyeUNoaWxkUHJvcHMgPSB7XG4gICAgbW9kZTogJ2hpZGRlbicsXG4gICAgY2hpbGRyZW46IHByaW1hcnlDaGlsZHJlblxuICB9O1xuICB2YXIgcHJpbWFyeUNoaWxkRnJhZ21lbnQ7XG5cbiAgaWYgKCAvLyBJbiBsZWdhY3kgbW9kZSwgd2UgY29tbWl0IHRoZSBwcmltYXJ5IHRyZWUgYXMgaWYgaXQgc3VjY2Vzc2Z1bGx5XG4gIC8vIGNvbXBsZXRlZCwgZXZlbiB0aG91Z2ggaXQncyBpbiBhbiBpbmNvbnNpc3RlbnQgc3RhdGUuXG4gIChtb2RlICYgQmxvY2tpbmdNb2RlKSA9PT0gTm9Nb2RlICYmIC8vIE1ha2Ugc3VyZSB3ZSdyZSBvbiB0aGUgc2Vjb25kIHBhc3MsIGkuZS4gdGhlIHByaW1hcnkgY2hpbGQgZnJhZ21lbnQgd2FzXG4gIC8vIGFscmVhZHkgY2xvbmVkLiBJbiBsZWdhY3kgbW9kZSwgdGhlIG9ubHkgY2FzZSB3aGVyZSB0aGlzIGlzbid0IHRydWUgaXNcbiAgLy8gd2hlbiBEZXZUb29scyBmb3JjZXMgdXMgdG8gZGlzcGxheSBhIGZhbGxiYWNrOyB3ZSBza2lwIHRoZSBmaXJzdCByZW5kZXJcbiAgLy8gcGFzcyBlbnRpcmVseSBhbmQgZ28gc3RyYWlnaHQgdG8gcmVuZGVyaW5nIHRoZSBmYWxsYmFjay4gKEluIENvbmN1cnJlbnRcbiAgLy8gTW9kZSwgU3VzcGVuc2VMaXN0IGNhbiBhbHNvIHRyaWdnZXIgdGhpcyBzY2VuYXJpbywgYnV0IHRoaXMgaXMgYSBsZWdhY3ktXG4gIC8vIG9ubHkgY29kZXBhdGguKVxuICB3b3JrSW5Qcm9ncmVzcy5jaGlsZCAhPT0gY3VycmVudFByaW1hcnlDaGlsZEZyYWdtZW50KSB7XG4gICAgdmFyIHByb2dyZXNzZWRQcmltYXJ5RnJhZ21lbnQgPSB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbiAgICBwcmltYXJ5Q2hpbGRGcmFnbWVudCA9IHByb2dyZXNzZWRQcmltYXJ5RnJhZ21lbnQ7XG4gICAgcHJpbWFyeUNoaWxkRnJhZ21lbnQuY2hpbGRMYW5lcyA9IE5vTGFuZXM7XG4gICAgcHJpbWFyeUNoaWxkRnJhZ21lbnQucGVuZGluZ1Byb3BzID0gcHJpbWFyeUNoaWxkUHJvcHM7XG5cbiAgICBpZiAoIHdvcmtJblByb2dyZXNzLm1vZGUgJiBQcm9maWxlTW9kZSkge1xuICAgICAgLy8gUmVzZXQgdGhlIGR1cmF0aW9ucyBmcm9tIHRoZSBmaXJzdCBwYXNzIHNvIHRoZXkgYXJlbid0IGluY2x1ZGVkIGluIHRoZVxuICAgICAgLy8gZmluYWwgYW1vdW50cy4gVGhpcyBzZWVtcyBjb3VudGVyaW50dWl0aXZlLCBzaW5jZSB3ZSdyZSBpbnRlbnRpb25hbGx5XG4gICAgICAvLyBub3QgbWVhc3VyaW5nIHBhcnQgb2YgdGhlIHJlbmRlciBwaGFzZSwgYnV0IHRoaXMgbWFrZXMgaXQgbWF0Y2ggd2hhdCB3ZVxuICAgICAgLy8gZG8gaW4gQ29uY3VycmVudCBNb2RlLlxuICAgICAgcHJpbWFyeUNoaWxkRnJhZ21lbnQuYWN0dWFsRHVyYXRpb24gPSAwO1xuICAgICAgcHJpbWFyeUNoaWxkRnJhZ21lbnQuYWN0dWFsU3RhcnRUaW1lID0gLTE7XG4gICAgICBwcmltYXJ5Q2hpbGRGcmFnbWVudC5zZWxmQmFzZUR1cmF0aW9uID0gY3VycmVudFByaW1hcnlDaGlsZEZyYWdtZW50LnNlbGZCYXNlRHVyYXRpb247XG4gICAgICBwcmltYXJ5Q2hpbGRGcmFnbWVudC50cmVlQmFzZUR1cmF0aW9uID0gY3VycmVudFByaW1hcnlDaGlsZEZyYWdtZW50LnRyZWVCYXNlRHVyYXRpb247XG4gICAgfSAvLyBUaGUgZmFsbGJhY2sgZmliZXIgd2FzIGFkZGVkIGFzIGEgZGVsZXRpb24gZWZmZWN0IGR1cmluZyB0aGUgZmlyc3QgcGFzcy5cbiAgICAvLyBIb3dldmVyLCBzaW5jZSB3ZSdyZSBnb2luZyB0byByZW1haW4gb24gdGhlIGZhbGxiYWNrLCB3ZSBubyBsb25nZXIgd2FudFxuICAgIC8vIHRvIGRlbGV0ZSBpdC4gU28gd2UgbmVlZCB0byByZW1vdmUgaXQgZnJvbSB0aGUgbGlzdC4gRGVsZXRpb25zIGFyZSBzdG9yZWRcbiAgICAvLyBvbiB0aGUgc2FtZSBsaXN0IGFzIGVmZmVjdHMuIFdlIHdhbnQgdG8ga2VlcCB0aGUgZWZmZWN0cyBmcm9tIHRoZSBwcmltYXJ5XG4gICAgLy8gdHJlZS4gU28gd2UgY29weSB0aGUgcHJpbWFyeSBjaGlsZCBmcmFnbWVudCdzIGVmZmVjdCBsaXN0LCB3aGljaCBkb2VzIG5vdFxuICAgIC8vIGluY2x1ZGUgdGhlIGZhbGxiYWNrIGRlbGV0aW9uIGVmZmVjdC5cblxuXG4gICAgdmFyIHByb2dyZXNzZWRMYXN0RWZmZWN0ID0gcHJpbWFyeUNoaWxkRnJhZ21lbnQubGFzdEVmZmVjdDtcblxuICAgIGlmIChwcm9ncmVzc2VkTGFzdEVmZmVjdCAhPT0gbnVsbCkge1xuICAgICAgd29ya0luUHJvZ3Jlc3MuZmlyc3RFZmZlY3QgPSBwcmltYXJ5Q2hpbGRGcmFnbWVudC5maXJzdEVmZmVjdDtcbiAgICAgIHdvcmtJblByb2dyZXNzLmxhc3RFZmZlY3QgPSBwcm9ncmVzc2VkTGFzdEVmZmVjdDtcbiAgICAgIHByb2dyZXNzZWRMYXN0RWZmZWN0Lm5leHRFZmZlY3QgPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUT0RPOiBSZXNldCB0aGlzIHNvbWV3aGVyZSBlbHNlPyBMb2wgbGVnYWN5IG1vZGUgaXMgc28gd2VpcmQuXG4gICAgICB3b3JrSW5Qcm9ncmVzcy5maXJzdEVmZmVjdCA9IHdvcmtJblByb2dyZXNzLmxhc3RFZmZlY3QgPSBudWxsO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBwcmltYXJ5Q2hpbGRGcmFnbWVudCA9IGNyZWF0ZVdvcmtJblByb2dyZXNzT2Zmc2NyZWVuRmliZXIoY3VycmVudFByaW1hcnlDaGlsZEZyYWdtZW50LCBwcmltYXJ5Q2hpbGRQcm9wcyk7XG4gIH1cblxuICB2YXIgZmFsbGJhY2tDaGlsZEZyYWdtZW50O1xuXG4gIGlmIChjdXJyZW50RmFsbGJhY2tDaGlsZEZyYWdtZW50ICE9PSBudWxsKSB7XG4gICAgZmFsbGJhY2tDaGlsZEZyYWdtZW50ID0gY3JlYXRlV29ya0luUHJvZ3Jlc3MoY3VycmVudEZhbGxiYWNrQ2hpbGRGcmFnbWVudCwgZmFsbGJhY2tDaGlsZHJlbik7XG4gIH0gZWxzZSB7XG4gICAgZmFsbGJhY2tDaGlsZEZyYWdtZW50ID0gY3JlYXRlRmliZXJGcm9tRnJhZ21lbnQoZmFsbGJhY2tDaGlsZHJlbiwgbW9kZSwgcmVuZGVyTGFuZXMsIG51bGwpOyAvLyBOZWVkcyBhIHBsYWNlbWVudCBlZmZlY3QgYmVjYXVzZSB0aGUgcGFyZW50ICh0aGUgU3VzcGVuc2UgYm91bmRhcnkpIGFscmVhZHlcbiAgICAvLyBtb3VudGVkIGJ1dCB0aGlzIGlzIGEgbmV3IGZpYmVyLlxuXG4gICAgZmFsbGJhY2tDaGlsZEZyYWdtZW50LmZsYWdzIHw9IFBsYWNlbWVudDtcbiAgfVxuXG4gIGZhbGxiYWNrQ2hpbGRGcmFnbWVudC5yZXR1cm4gPSB3b3JrSW5Qcm9ncmVzcztcbiAgcHJpbWFyeUNoaWxkRnJhZ21lbnQucmV0dXJuID0gd29ya0luUHJvZ3Jlc3M7XG4gIHByaW1hcnlDaGlsZEZyYWdtZW50LnNpYmxpbmcgPSBmYWxsYmFja0NoaWxkRnJhZ21lbnQ7XG4gIHdvcmtJblByb2dyZXNzLmNoaWxkID0gcHJpbWFyeUNoaWxkRnJhZ21lbnQ7XG4gIHJldHVybiBmYWxsYmFja0NoaWxkRnJhZ21lbnQ7XG59XG5cbmZ1bmN0aW9uIHNjaGVkdWxlV29ya09uRmliZXIoZmliZXIsIHJlbmRlckxhbmVzKSB7XG4gIGZpYmVyLmxhbmVzID0gbWVyZ2VMYW5lcyhmaWJlci5sYW5lcywgcmVuZGVyTGFuZXMpO1xuICB2YXIgYWx0ZXJuYXRlID0gZmliZXIuYWx0ZXJuYXRlO1xuXG4gIGlmIChhbHRlcm5hdGUgIT09IG51bGwpIHtcbiAgICBhbHRlcm5hdGUubGFuZXMgPSBtZXJnZUxhbmVzKGFsdGVybmF0ZS5sYW5lcywgcmVuZGVyTGFuZXMpO1xuICB9XG5cbiAgc2NoZWR1bGVXb3JrT25QYXJlbnRQYXRoKGZpYmVyLnJldHVybiwgcmVuZGVyTGFuZXMpO1xufVxuXG5mdW5jdGlvbiBwcm9wYWdhdGVTdXNwZW5zZUNvbnRleHRDaGFuZ2Uod29ya0luUHJvZ3Jlc3MsIGZpcnN0Q2hpbGQsIHJlbmRlckxhbmVzKSB7XG4gIC8vIE1hcmsgYW55IFN1c3BlbnNlIGJvdW5kYXJpZXMgd2l0aCBmYWxsYmFja3MgYXMgaGF2aW5nIHdvcmsgdG8gZG8uXG4gIC8vIElmIHRoZXkgd2VyZSBwcmV2aW91c2x5IGZvcmNlZCBpbnRvIGZhbGxiYWNrcywgdGhleSBtYXkgbm93IGJlIGFibGVcbiAgLy8gdG8gdW5ibG9jay5cbiAgdmFyIG5vZGUgPSBmaXJzdENoaWxkO1xuXG4gIHdoaWxlIChub2RlICE9PSBudWxsKSB7XG4gICAgaWYgKG5vZGUudGFnID09PSBTdXNwZW5zZUNvbXBvbmVudCkge1xuICAgICAgdmFyIHN0YXRlID0gbm9kZS5tZW1vaXplZFN0YXRlO1xuXG4gICAgICBpZiAoc3RhdGUgIT09IG51bGwpIHtcbiAgICAgICAgc2NoZWR1bGVXb3JrT25GaWJlcihub2RlLCByZW5kZXJMYW5lcyk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChub2RlLnRhZyA9PT0gU3VzcGVuc2VMaXN0Q29tcG9uZW50KSB7XG4gICAgICAvLyBJZiB0aGUgdGFpbCBpcyBoaWRkZW4gdGhlcmUgbWlnaHQgbm90IGJlIGFuIFN1c3BlbnNlIGJvdW5kYXJpZXNcbiAgICAgIC8vIHRvIHNjaGVkdWxlIHdvcmsgb24uIEluIHRoaXMgY2FzZSB3ZSBoYXZlIHRvIHNjaGVkdWxlIGl0IG9uIHRoZVxuICAgICAgLy8gbGlzdCBpdHNlbGYuXG4gICAgICAvLyBXZSBkb24ndCBoYXZlIHRvIHRyYXZlcnNlIHRvIHRoZSBjaGlsZHJlbiBvZiB0aGUgbGlzdCBzaW5jZVxuICAgICAgLy8gdGhlIGxpc3Qgd2lsbCBwcm9wYWdhdGUgdGhlIGNoYW5nZSB3aGVuIGl0IHJlcmVuZGVycy5cbiAgICAgIHNjaGVkdWxlV29ya09uRmliZXIobm9kZSwgcmVuZGVyTGFuZXMpO1xuICAgIH0gZWxzZSBpZiAobm9kZS5jaGlsZCAhPT0gbnVsbCkge1xuICAgICAgbm9kZS5jaGlsZC5yZXR1cm4gPSBub2RlO1xuICAgICAgbm9kZSA9IG5vZGUuY2hpbGQ7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAobm9kZSA9PT0gd29ya0luUHJvZ3Jlc3MpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB3aGlsZSAobm9kZS5zaWJsaW5nID09PSBudWxsKSB7XG4gICAgICBpZiAobm9kZS5yZXR1cm4gPT09IG51bGwgfHwgbm9kZS5yZXR1cm4gPT09IHdvcmtJblByb2dyZXNzKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgbm9kZSA9IG5vZGUucmV0dXJuO1xuICAgIH1cblxuICAgIG5vZGUuc2libGluZy5yZXR1cm4gPSBub2RlLnJldHVybjtcbiAgICBub2RlID0gbm9kZS5zaWJsaW5nO1xuICB9XG59XG5cbmZ1bmN0aW9uIGZpbmRMYXN0Q29udGVudFJvdyhmaXJzdENoaWxkKSB7XG4gIC8vIFRoaXMgaXMgZ29pbmcgdG8gZmluZCB0aGUgbGFzdCByb3cgYW1vbmcgdGhlc2UgY2hpbGRyZW4gdGhhdCBpcyBhbHJlYWR5XG4gIC8vIHNob3dpbmcgY29udGVudCBvbiB0aGUgc2NyZWVuLCBhcyBvcHBvc2VkIHRvIGJlaW5nIGluIGZhbGxiYWNrIHN0YXRlIG9yXG4gIC8vIG5ldy4gSWYgYSByb3cgaGFzIG11bHRpcGxlIFN1c3BlbnNlIGJvdW5kYXJpZXMsIGFueSBvZiB0aGVtIGJlaW5nIGluIHRoZVxuICAvLyBmYWxsYmFjayBzdGF0ZSwgY291bnRzIGFzIHRoZSB3aG9sZSByb3cgYmVpbmcgaW4gYSBmYWxsYmFjayBzdGF0ZS5cbiAgLy8gTm90ZSB0aGF0IHRoZSBcInJvd3NcIiB3aWxsIGJlIHdvcmtJblByb2dyZXNzLCBidXQgYW55IG5lc3RlZCBjaGlsZHJlblxuICAvLyB3aWxsIHN0aWxsIGJlIGN1cnJlbnQgc2luY2Ugd2UgaGF2ZW4ndCByZW5kZXJlZCB0aGVtIHlldC4gVGhlIG1vdW50ZWRcbiAgLy8gb3JkZXIgbWF5IG5vdCBiZSB0aGUgc2FtZSBhcyB0aGUgbmV3IG9yZGVyLiBXZSB1c2UgdGhlIG5ldyBvcmRlci5cbiAgdmFyIHJvdyA9IGZpcnN0Q2hpbGQ7XG4gIHZhciBsYXN0Q29udGVudFJvdyA9IG51bGw7XG5cbiAgd2hpbGUgKHJvdyAhPT0gbnVsbCkge1xuICAgIHZhciBjdXJyZW50Um93ID0gcm93LmFsdGVybmF0ZTsgLy8gTmV3IHJvd3MgY2FuJ3QgYmUgY29udGVudCByb3dzLlxuXG4gICAgaWYgKGN1cnJlbnRSb3cgIT09IG51bGwgJiYgZmluZEZpcnN0U3VzcGVuZGVkKGN1cnJlbnRSb3cpID09PSBudWxsKSB7XG4gICAgICBsYXN0Q29udGVudFJvdyA9IHJvdztcbiAgICB9XG5cbiAgICByb3cgPSByb3cuc2libGluZztcbiAgfVxuXG4gIHJldHVybiBsYXN0Q29udGVudFJvdztcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVSZXZlYWxPcmRlcihyZXZlYWxPcmRlcikge1xuICB7XG4gICAgaWYgKHJldmVhbE9yZGVyICE9PSB1bmRlZmluZWQgJiYgcmV2ZWFsT3JkZXIgIT09ICdmb3J3YXJkcycgJiYgcmV2ZWFsT3JkZXIgIT09ICdiYWNrd2FyZHMnICYmIHJldmVhbE9yZGVyICE9PSAndG9nZXRoZXInICYmICFkaWRXYXJuQWJvdXRSZXZlYWxPcmRlcltyZXZlYWxPcmRlcl0pIHtcbiAgICAgIGRpZFdhcm5BYm91dFJldmVhbE9yZGVyW3JldmVhbE9yZGVyXSA9IHRydWU7XG5cbiAgICAgIGlmICh0eXBlb2YgcmV2ZWFsT3JkZXIgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHN3aXRjaCAocmV2ZWFsT3JkZXIudG9Mb3dlckNhc2UoKSkge1xuICAgICAgICAgIGNhc2UgJ3RvZ2V0aGVyJzpcbiAgICAgICAgICBjYXNlICdmb3J3YXJkcyc6XG4gICAgICAgICAgY2FzZSAnYmFja3dhcmRzJzpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgZXJyb3IoJ1wiJXNcIiBpcyBub3QgYSB2YWxpZCB2YWx1ZSBmb3IgcmV2ZWFsT3JkZXIgb24gPFN1c3BlbnNlTGlzdCAvPi4gJyArICdVc2UgbG93ZXJjYXNlIFwiJXNcIiBpbnN0ZWFkLicsIHJldmVhbE9yZGVyLCByZXZlYWxPcmRlci50b0xvd2VyQ2FzZSgpKTtcblxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIGNhc2UgJ2ZvcndhcmQnOlxuICAgICAgICAgIGNhc2UgJ2JhY2t3YXJkJzpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgZXJyb3IoJ1wiJXNcIiBpcyBub3QgYSB2YWxpZCB2YWx1ZSBmb3IgcmV2ZWFsT3JkZXIgb24gPFN1c3BlbnNlTGlzdCAvPi4gJyArICdSZWFjdCB1c2VzIHRoZSAtcyBzdWZmaXggaW4gdGhlIHNwZWxsaW5nLiBVc2UgXCIlc3NcIiBpbnN0ZWFkLicsIHJldmVhbE9yZGVyLCByZXZlYWxPcmRlci50b0xvd2VyQ2FzZSgpKTtcblxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBlcnJvcignXCIlc1wiIGlzIG5vdCBhIHN1cHBvcnRlZCByZXZlYWxPcmRlciBvbiA8U3VzcGVuc2VMaXN0IC8+LiAnICsgJ0RpZCB5b3UgbWVhbiBcInRvZ2V0aGVyXCIsIFwiZm9yd2FyZHNcIiBvciBcImJhY2t3YXJkc1wiPycsIHJldmVhbE9yZGVyKTtcblxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVycm9yKCclcyBpcyBub3QgYSBzdXBwb3J0ZWQgdmFsdWUgZm9yIHJldmVhbE9yZGVyIG9uIDxTdXNwZW5zZUxpc3QgLz4uICcgKyAnRGlkIHlvdSBtZWFuIFwidG9nZXRoZXJcIiwgXCJmb3J3YXJkc1wiIG9yIFwiYmFja3dhcmRzXCI/JywgcmV2ZWFsT3JkZXIpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZVRhaWxPcHRpb25zKHRhaWxNb2RlLCByZXZlYWxPcmRlcikge1xuICB7XG4gICAgaWYgKHRhaWxNb2RlICE9PSB1bmRlZmluZWQgJiYgIWRpZFdhcm5BYm91dFRhaWxPcHRpb25zW3RhaWxNb2RlXSkge1xuICAgICAgaWYgKHRhaWxNb2RlICE9PSAnY29sbGFwc2VkJyAmJiB0YWlsTW9kZSAhPT0gJ2hpZGRlbicpIHtcbiAgICAgICAgZGlkV2FybkFib3V0VGFpbE9wdGlvbnNbdGFpbE1vZGVdID0gdHJ1ZTtcblxuICAgICAgICBlcnJvcignXCIlc1wiIGlzIG5vdCBhIHN1cHBvcnRlZCB2YWx1ZSBmb3IgdGFpbCBvbiA8U3VzcGVuc2VMaXN0IC8+LiAnICsgJ0RpZCB5b3UgbWVhbiBcImNvbGxhcHNlZFwiIG9yIFwiaGlkZGVuXCI/JywgdGFpbE1vZGUpO1xuICAgICAgfSBlbHNlIGlmIChyZXZlYWxPcmRlciAhPT0gJ2ZvcndhcmRzJyAmJiByZXZlYWxPcmRlciAhPT0gJ2JhY2t3YXJkcycpIHtcbiAgICAgICAgZGlkV2FybkFib3V0VGFpbE9wdGlvbnNbdGFpbE1vZGVdID0gdHJ1ZTtcblxuICAgICAgICBlcnJvcignPFN1c3BlbnNlTGlzdCB0YWlsPVwiJXNcIiAvPiBpcyBvbmx5IHZhbGlkIGlmIHJldmVhbE9yZGVyIGlzICcgKyAnXCJmb3J3YXJkc1wiIG9yIFwiYmFja3dhcmRzXCIuICcgKyAnRGlkIHlvdSBtZWFuIHRvIHNwZWNpZnkgcmV2ZWFsT3JkZXI9XCJmb3J3YXJkc1wiPycsIHRhaWxNb2RlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVTdXNwZW5zZUxpc3ROZXN0ZWRDaGlsZChjaGlsZFNsb3QsIGluZGV4KSB7XG4gIHtcbiAgICB2YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkoY2hpbGRTbG90KTtcbiAgICB2YXIgaXNJdGVyYWJsZSA9ICFpc0FycmF5ICYmIHR5cGVvZiBnZXRJdGVyYXRvckZuKGNoaWxkU2xvdCkgPT09ICdmdW5jdGlvbic7XG5cbiAgICBpZiAoaXNBcnJheSB8fCBpc0l0ZXJhYmxlKSB7XG4gICAgICB2YXIgdHlwZSA9IGlzQXJyYXkgPyAnYXJyYXknIDogJ2l0ZXJhYmxlJztcblxuICAgICAgZXJyb3IoJ0EgbmVzdGVkICVzIHdhcyBwYXNzZWQgdG8gcm93ICMlcyBpbiA8U3VzcGVuc2VMaXN0IC8+LiBXcmFwIGl0IGluICcgKyAnYW4gYWRkaXRpb25hbCBTdXNwZW5zZUxpc3QgdG8gY29uZmlndXJlIGl0cyByZXZlYWxPcmRlcjogJyArICc8U3VzcGVuc2VMaXN0IHJldmVhbE9yZGVyPS4uLj4gLi4uICcgKyAnPFN1c3BlbnNlTGlzdCByZXZlYWxPcmRlcj0uLi4+eyVzfTwvU3VzcGVuc2VMaXN0PiAuLi4gJyArICc8L1N1c3BlbnNlTGlzdD4nLCB0eXBlLCBpbmRleCwgdHlwZSk7XG5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVTdXNwZW5zZUxpc3RDaGlsZHJlbihjaGlsZHJlbiwgcmV2ZWFsT3JkZXIpIHtcbiAge1xuICAgIGlmICgocmV2ZWFsT3JkZXIgPT09ICdmb3J3YXJkcycgfHwgcmV2ZWFsT3JkZXIgPT09ICdiYWNrd2FyZHMnKSAmJiBjaGlsZHJlbiAhPT0gdW5kZWZpbmVkICYmIGNoaWxkcmVuICE9PSBudWxsICYmIGNoaWxkcmVuICE9PSBmYWxzZSkge1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZiAoIXZhbGlkYXRlU3VzcGVuc2VMaXN0TmVzdGVkQ2hpbGQoY2hpbGRyZW5baV0sIGkpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4oY2hpbGRyZW4pO1xuXG4gICAgICAgIGlmICh0eXBlb2YgaXRlcmF0b3JGbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHZhciBjaGlsZHJlbkl0ZXJhdG9yID0gaXRlcmF0b3JGbi5jYWxsKGNoaWxkcmVuKTtcblxuICAgICAgICAgIGlmIChjaGlsZHJlbkl0ZXJhdG9yKSB7XG4gICAgICAgICAgICB2YXIgc3RlcCA9IGNoaWxkcmVuSXRlcmF0b3IubmV4dCgpO1xuICAgICAgICAgICAgdmFyIF9pID0gMDtcblxuICAgICAgICAgICAgZm9yICg7ICFzdGVwLmRvbmU7IHN0ZXAgPSBjaGlsZHJlbkl0ZXJhdG9yLm5leHQoKSkge1xuICAgICAgICAgICAgICBpZiAoIXZhbGlkYXRlU3VzcGVuc2VMaXN0TmVzdGVkQ2hpbGQoc3RlcC52YWx1ZSwgX2kpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgX2krKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZXJyb3IoJ0Egc2luZ2xlIHJvdyB3YXMgcGFzc2VkIHRvIGEgPFN1c3BlbnNlTGlzdCByZXZlYWxPcmRlcj1cIiVzXCIgLz4uICcgKyAnVGhpcyBpcyBub3QgdXNlZnVsIHNpbmNlIGl0IG5lZWRzIG11bHRpcGxlIHJvd3MuICcgKyAnRGlkIHlvdSBtZWFuIHRvIHBhc3MgbXVsdGlwbGUgY2hpbGRyZW4gb3IgYW4gYXJyYXk/JywgcmV2ZWFsT3JkZXIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGluaXRTdXNwZW5zZUxpc3RSZW5kZXJTdGF0ZSh3b3JrSW5Qcm9ncmVzcywgaXNCYWNrd2FyZHMsIHRhaWwsIGxhc3RDb250ZW50Um93LCB0YWlsTW9kZSwgbGFzdEVmZmVjdEJlZm9yZVJlbmRlcmluZykge1xuICB2YXIgcmVuZGVyU3RhdGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuXG4gIGlmIChyZW5kZXJTdGF0ZSA9PT0gbnVsbCkge1xuICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSB7XG4gICAgICBpc0JhY2t3YXJkczogaXNCYWNrd2FyZHMsXG4gICAgICByZW5kZXJpbmc6IG51bGwsXG4gICAgICByZW5kZXJpbmdTdGFydFRpbWU6IDAsXG4gICAgICBsYXN0OiBsYXN0Q29udGVudFJvdyxcbiAgICAgIHRhaWw6IHRhaWwsXG4gICAgICB0YWlsTW9kZTogdGFpbE1vZGUsXG4gICAgICBsYXN0RWZmZWN0OiBsYXN0RWZmZWN0QmVmb3JlUmVuZGVyaW5nXG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICAvLyBXZSBjYW4gcmV1c2UgdGhlIGV4aXN0aW5nIG9iamVjdCBmcm9tIHByZXZpb3VzIHJlbmRlcnMuXG4gICAgcmVuZGVyU3RhdGUuaXNCYWNrd2FyZHMgPSBpc0JhY2t3YXJkcztcbiAgICByZW5kZXJTdGF0ZS5yZW5kZXJpbmcgPSBudWxsO1xuICAgIHJlbmRlclN0YXRlLnJlbmRlcmluZ1N0YXJ0VGltZSA9IDA7XG4gICAgcmVuZGVyU3RhdGUubGFzdCA9IGxhc3RDb250ZW50Um93O1xuICAgIHJlbmRlclN0YXRlLnRhaWwgPSB0YWlsO1xuICAgIHJlbmRlclN0YXRlLnRhaWxNb2RlID0gdGFpbE1vZGU7XG4gICAgcmVuZGVyU3RhdGUubGFzdEVmZmVjdCA9IGxhc3RFZmZlY3RCZWZvcmVSZW5kZXJpbmc7XG4gIH1cbn0gLy8gVGhpcyBjYW4gZW5kIHVwIHJlbmRlcmluZyB0aGlzIGNvbXBvbmVudCBtdWx0aXBsZSBwYXNzZXMuXG4vLyBUaGUgZmlyc3QgcGFzcyBzcGxpdHMgdGhlIGNoaWxkcmVuIGZpYmVycyBpbnRvIHR3byBzZXRzLiBBIGhlYWQgYW5kIHRhaWwuXG4vLyBXZSBmaXJzdCByZW5kZXIgdGhlIGhlYWQuIElmIGFueXRoaW5nIGlzIGluIGZhbGxiYWNrIHN0YXRlLCB3ZSBkbyBhbm90aGVyXG4vLyBwYXNzIHRocm91Z2ggYmVnaW5Xb3JrIHRvIHJlcmVuZGVyIGFsbCBjaGlsZHJlbiAoaW5jbHVkaW5nIHRoZSB0YWlsKSB3aXRoXG4vLyB0aGUgZm9yY2Ugc3VzcGVuZCBjb250ZXh0LiBJZiB0aGUgZmlyc3QgcmVuZGVyIGRpZG4ndCBoYXZlIGFueXRoaW5nIGluXG4vLyBpbiBmYWxsYmFjayBzdGF0ZS4gVGhlbiB3ZSByZW5kZXIgZWFjaCByb3cgaW4gdGhlIHRhaWwgb25lLWJ5LW9uZS5cbi8vIFRoYXQgaGFwcGVucyBpbiB0aGUgY29tcGxldGVXb3JrIHBoYXNlIHdpdGhvdXQgZ29pbmcgYmFjayB0byBiZWdpbldvcmsuXG5cblxuZnVuY3Rpb24gdXBkYXRlU3VzcGVuc2VMaXN0Q29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcykge1xuICB2YXIgbmV4dFByb3BzID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO1xuICB2YXIgcmV2ZWFsT3JkZXIgPSBuZXh0UHJvcHMucmV2ZWFsT3JkZXI7XG4gIHZhciB0YWlsTW9kZSA9IG5leHRQcm9wcy50YWlsO1xuICB2YXIgbmV3Q2hpbGRyZW4gPSBuZXh0UHJvcHMuY2hpbGRyZW47XG4gIHZhbGlkYXRlUmV2ZWFsT3JkZXIocmV2ZWFsT3JkZXIpO1xuICB2YWxpZGF0ZVRhaWxPcHRpb25zKHRhaWxNb2RlLCByZXZlYWxPcmRlcik7XG4gIHZhbGlkYXRlU3VzcGVuc2VMaXN0Q2hpbGRyZW4obmV3Q2hpbGRyZW4sIHJldmVhbE9yZGVyKTtcbiAgcmVjb25jaWxlQ2hpbGRyZW4oY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG5ld0NoaWxkcmVuLCByZW5kZXJMYW5lcyk7XG4gIHZhciBzdXNwZW5zZUNvbnRleHQgPSBzdXNwZW5zZVN0YWNrQ3Vyc29yLmN1cnJlbnQ7XG4gIHZhciBzaG91bGRGb3JjZUZhbGxiYWNrID0gaGFzU3VzcGVuc2VDb250ZXh0KHN1c3BlbnNlQ29udGV4dCwgRm9yY2VTdXNwZW5zZUZhbGxiYWNrKTtcblxuICBpZiAoc2hvdWxkRm9yY2VGYWxsYmFjaykge1xuICAgIHN1c3BlbnNlQ29udGV4dCA9IHNldFNoYWxsb3dTdXNwZW5zZUNvbnRleHQoc3VzcGVuc2VDb250ZXh0LCBGb3JjZVN1c3BlbnNlRmFsbGJhY2spO1xuICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IERpZENhcHR1cmU7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGRpZFN1c3BlbmRCZWZvcmUgPSBjdXJyZW50ICE9PSBudWxsICYmIChjdXJyZW50LmZsYWdzICYgRGlkQ2FwdHVyZSkgIT09IE5vRmxhZ3M7XG5cbiAgICBpZiAoZGlkU3VzcGVuZEJlZm9yZSkge1xuICAgICAgLy8gSWYgd2UgcHJldmlvdXNseSBmb3JjZWQgYSBmYWxsYmFjaywgd2UgbmVlZCB0byBzY2hlZHVsZSB3b3JrXG4gICAgICAvLyBvbiBhbnkgbmVzdGVkIGJvdW5kYXJpZXMgdG8gbGV0IHRoZW0ga25vdyB0byB0cnkgdG8gcmVuZGVyXG4gICAgICAvLyBhZ2Fpbi4gVGhpcyBpcyB0aGUgc2FtZSBhcyBjb250ZXh0IHVwZGF0aW5nLlxuICAgICAgcHJvcGFnYXRlU3VzcGVuc2VDb250ZXh0Q2hhbmdlKHdvcmtJblByb2dyZXNzLCB3b3JrSW5Qcm9ncmVzcy5jaGlsZCwgcmVuZGVyTGFuZXMpO1xuICAgIH1cblxuICAgIHN1c3BlbnNlQ29udGV4dCA9IHNldERlZmF1bHRTaGFsbG93U3VzcGVuc2VDb250ZXh0KHN1c3BlbnNlQ29udGV4dCk7XG4gIH1cblxuICBwdXNoU3VzcGVuc2VDb250ZXh0KHdvcmtJblByb2dyZXNzLCBzdXNwZW5zZUNvbnRleHQpO1xuXG4gIGlmICgod29ya0luUHJvZ3Jlc3MubW9kZSAmIEJsb2NraW5nTW9kZSkgPT09IE5vTW9kZSkge1xuICAgIC8vIEluIGxlZ2FjeSBtb2RlLCBTdXNwZW5zZUxpc3QgZG9lc24ndCB3b3JrIHNvIHdlIGp1c3RcbiAgICAvLyB1c2UgbWFrZSBpdCBhIG5vb3AgYnkgdHJlYXRpbmcgaXQgYXMgdGhlIGRlZmF1bHQgcmV2ZWFsT3JkZXIuXG4gICAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IG51bGw7XG4gIH0gZWxzZSB7XG4gICAgc3dpdGNoIChyZXZlYWxPcmRlcikge1xuICAgICAgY2FzZSAnZm9yd2FyZHMnOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIGxhc3RDb250ZW50Um93ID0gZmluZExhc3RDb250ZW50Um93KHdvcmtJblByb2dyZXNzLmNoaWxkKTtcbiAgICAgICAgICB2YXIgdGFpbDtcblxuICAgICAgICAgIGlmIChsYXN0Q29udGVudFJvdyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gVGhlIHdob2xlIGxpc3QgaXMgcGFydCBvZiB0aGUgdGFpbC5cbiAgICAgICAgICAgIC8vIFRPRE86IFdlIGNvdWxkIGZhc3QgcGF0aCBieSBqdXN0IHJlbmRlcmluZyB0aGUgdGFpbCBub3cuXG4gICAgICAgICAgICB0YWlsID0gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IG51bGw7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIERpc2Nvbm5lY3QgdGhlIHRhaWwgcm93cyBhZnRlciB0aGUgY29udGVudCByb3cuXG4gICAgICAgICAgICAvLyBXZSdyZSBnb2luZyB0byByZW5kZXIgdGhlbSBzZXBhcmF0ZWx5IGxhdGVyLlxuICAgICAgICAgICAgdGFpbCA9IGxhc3RDb250ZW50Um93LnNpYmxpbmc7XG4gICAgICAgICAgICBsYXN0Q29udGVudFJvdy5zaWJsaW5nID0gbnVsbDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpbml0U3VzcGVuc2VMaXN0UmVuZGVyU3RhdGUod29ya0luUHJvZ3Jlc3MsIGZhbHNlLCAvLyBpc0JhY2t3YXJkc1xuICAgICAgICAgIHRhaWwsIGxhc3RDb250ZW50Um93LCB0YWlsTW9kZSwgd29ya0luUHJvZ3Jlc3MubGFzdEVmZmVjdCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSAnYmFja3dhcmRzJzpcbiAgICAgICAge1xuICAgICAgICAgIC8vIFdlJ3JlIGdvaW5nIHRvIGZpbmQgdGhlIGZpcnN0IHJvdyB0aGF0IGhhcyBleGlzdGluZyBjb250ZW50LlxuICAgICAgICAgIC8vIEF0IHRoZSBzYW1lIHRpbWUgd2UncmUgZ29pbmcgdG8gcmV2ZXJzZSB0aGUgbGlzdCBvZiBldmVyeXRoaW5nXG4gICAgICAgICAgLy8gd2UgcGFzcyBpbiB0aGUgbWVhbnRpbWUuIFRoYXQncyBnb2luZyB0byBiZSBvdXIgdGFpbCBpbiByZXZlcnNlXG4gICAgICAgICAgLy8gb3JkZXIuXG4gICAgICAgICAgdmFyIF90YWlsID0gbnVsbDtcbiAgICAgICAgICB2YXIgcm93ID0gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MuY2hpbGQgPSBudWxsO1xuXG4gICAgICAgICAgd2hpbGUgKHJvdyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIGN1cnJlbnRSb3cgPSByb3cuYWx0ZXJuYXRlOyAvLyBOZXcgcm93cyBjYW4ndCBiZSBjb250ZW50IHJvd3MuXG5cbiAgICAgICAgICAgIGlmIChjdXJyZW50Um93ICE9PSBudWxsICYmIGZpbmRGaXJzdFN1c3BlbmRlZChjdXJyZW50Um93KSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAvLyBUaGlzIGlzIHRoZSBiZWdpbm5pbmcgb2YgdGhlIG1haW4gY29udGVudC5cbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MuY2hpbGQgPSByb3c7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgbmV4dFJvdyA9IHJvdy5zaWJsaW5nO1xuICAgICAgICAgICAgcm93LnNpYmxpbmcgPSBfdGFpbDtcbiAgICAgICAgICAgIF90YWlsID0gcm93O1xuICAgICAgICAgICAgcm93ID0gbmV4dFJvdztcbiAgICAgICAgICB9IC8vIFRPRE86IElmIHdvcmtJblByb2dyZXNzLmNoaWxkIGlzIG51bGwsIHdlIGNhbiBjb250aW51ZSBvbiB0aGUgdGFpbCBpbW1lZGlhdGVseS5cblxuXG4gICAgICAgICAgaW5pdFN1c3BlbnNlTGlzdFJlbmRlclN0YXRlKHdvcmtJblByb2dyZXNzLCB0cnVlLCAvLyBpc0JhY2t3YXJkc1xuICAgICAgICAgIF90YWlsLCBudWxsLCAvLyBsYXN0XG4gICAgICAgICAgdGFpbE1vZGUsIHdvcmtJblByb2dyZXNzLmxhc3RFZmZlY3QpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgJ3RvZ2V0aGVyJzpcbiAgICAgICAge1xuICAgICAgICAgIGluaXRTdXNwZW5zZUxpc3RSZW5kZXJTdGF0ZSh3b3JrSW5Qcm9ncmVzcywgZmFsc2UsIC8vIGlzQmFja3dhcmRzXG4gICAgICAgICAgbnVsbCwgLy8gdGFpbFxuICAgICAgICAgIG51bGwsIC8vIGxhc3RcbiAgICAgICAgICB1bmRlZmluZWQsIHdvcmtJblByb2dyZXNzLmxhc3RFZmZlY3QpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHtcbiAgICAgICAgICAvLyBUaGUgZGVmYXVsdCByZXZlYWwgb3JkZXIgaXMgdGhlIHNhbWUgYXMgbm90IGhhdmluZ1xuICAgICAgICAgIC8vIGEgYm91bmRhcnkuXG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZVBvcnRhbENvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpIHtcbiAgcHVzaEhvc3RDb250YWluZXIod29ya0luUHJvZ3Jlc3MsIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZS5jb250YWluZXJJbmZvKTtcbiAgdmFyIG5leHRDaGlsZHJlbiA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcztcblxuICBpZiAoY3VycmVudCA9PT0gbnVsbCkge1xuICAgIC8vIFBvcnRhbHMgYXJlIHNwZWNpYWwgYmVjYXVzZSB3ZSBkb24ndCBhcHBlbmQgdGhlIGNoaWxkcmVuIGR1cmluZyBtb3VudFxuICAgIC8vIGJ1dCBhdCBjb21taXQuIFRoZXJlZm9yZSB3ZSBuZWVkIHRvIHRyYWNrIGluc2VydGlvbnMgd2hpY2ggdGhlIG5vcm1hbFxuICAgIC8vIGZsb3cgZG9lc24ndCBkbyBkdXJpbmcgbW91bnQuIFRoaXMgZG9lc24ndCBoYXBwZW4gYXQgdGhlIHJvb3QgYmVjYXVzZVxuICAgIC8vIHRoZSByb290IGFsd2F5cyBzdGFydHMgd2l0aCBhIFwiY3VycmVudFwiIHdpdGggYSBudWxsIGNoaWxkLlxuICAgIC8vIFRPRE86IENvbnNpZGVyIHVuaWZ5aW5nIHRoaXMgd2l0aCBob3cgdGhlIHJvb3Qgd29ya3MuXG4gICAgd29ya0luUHJvZ3Jlc3MuY2hpbGQgPSByZWNvbmNpbGVDaGlsZEZpYmVycyh3b3JrSW5Qcm9ncmVzcywgbnVsbCwgbmV4dENoaWxkcmVuLCByZW5kZXJMYW5lcyk7XG4gIH0gZWxzZSB7XG4gICAgcmVjb25jaWxlQ2hpbGRyZW4oY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG5leHRDaGlsZHJlbiwgcmVuZGVyTGFuZXMpO1xuICB9XG5cbiAgcmV0dXJuIHdvcmtJblByb2dyZXNzLmNoaWxkO1xufVxuXG52YXIgaGFzV2FybmVkQWJvdXRVc2luZ05vVmFsdWVQcm9wT25Db250ZXh0UHJvdmlkZXIgPSBmYWxzZTtcblxuZnVuY3Rpb24gdXBkYXRlQ29udGV4dFByb3ZpZGVyKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcykge1xuICB2YXIgcHJvdmlkZXJUeXBlID0gd29ya0luUHJvZ3Jlc3MudHlwZTtcbiAgdmFyIGNvbnRleHQgPSBwcm92aWRlclR5cGUuX2NvbnRleHQ7XG4gIHZhciBuZXdQcm9wcyA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcztcbiAgdmFyIG9sZFByb3BzID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcztcbiAgdmFyIG5ld1ZhbHVlID0gbmV3UHJvcHMudmFsdWU7XG5cbiAge1xuICAgIGlmICghKCd2YWx1ZScgaW4gbmV3UHJvcHMpKSB7XG4gICAgICBpZiAoIWhhc1dhcm5lZEFib3V0VXNpbmdOb1ZhbHVlUHJvcE9uQ29udGV4dFByb3ZpZGVyKSB7XG4gICAgICAgIGhhc1dhcm5lZEFib3V0VXNpbmdOb1ZhbHVlUHJvcE9uQ29udGV4dFByb3ZpZGVyID0gdHJ1ZTtcblxuICAgICAgICBlcnJvcignVGhlIGB2YWx1ZWAgcHJvcCBpcyByZXF1aXJlZCBmb3IgdGhlIGA8Q29udGV4dC5Qcm92aWRlcj5gLiBEaWQgeW91IG1pc3NwZWxsIGl0IG9yIGZvcmdldCB0byBwYXNzIGl0PycpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBwcm92aWRlclByb3BUeXBlcyA9IHdvcmtJblByb2dyZXNzLnR5cGUucHJvcFR5cGVzO1xuXG4gICAgaWYgKHByb3ZpZGVyUHJvcFR5cGVzKSB7XG4gICAgICBjaGVja1Byb3BUeXBlcyhwcm92aWRlclByb3BUeXBlcywgbmV3UHJvcHMsICdwcm9wJywgJ0NvbnRleHQuUHJvdmlkZXInKTtcbiAgICB9XG4gIH1cblxuICBwdXNoUHJvdmlkZXIod29ya0luUHJvZ3Jlc3MsIG5ld1ZhbHVlKTtcblxuICBpZiAob2xkUHJvcHMgIT09IG51bGwpIHtcbiAgICB2YXIgb2xkVmFsdWUgPSBvbGRQcm9wcy52YWx1ZTtcbiAgICB2YXIgY2hhbmdlZEJpdHMgPSBjYWxjdWxhdGVDaGFuZ2VkQml0cyhjb250ZXh0LCBuZXdWYWx1ZSwgb2xkVmFsdWUpO1xuXG4gICAgaWYgKGNoYW5nZWRCaXRzID09PSAwKSB7XG4gICAgICAvLyBObyBjaGFuZ2UuIEJhaWxvdXQgZWFybHkgaWYgY2hpbGRyZW4gYXJlIHRoZSBzYW1lLlxuICAgICAgaWYgKG9sZFByb3BzLmNoaWxkcmVuID09PSBuZXdQcm9wcy5jaGlsZHJlbiAmJiAhaGFzQ29udGV4dENoYW5nZWQoKSkge1xuICAgICAgICByZXR1cm4gYmFpbG91dE9uQWxyZWFkeUZpbmlzaGVkV29yayhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUaGUgY29udGV4dCB2YWx1ZSBjaGFuZ2VkLiBTZWFyY2ggZm9yIG1hdGNoaW5nIGNvbnN1bWVycyBhbmQgc2NoZWR1bGVcbiAgICAgIC8vIHRoZW0gdG8gdXBkYXRlLlxuICAgICAgcHJvcGFnYXRlQ29udGV4dENoYW5nZSh3b3JrSW5Qcm9ncmVzcywgY29udGV4dCwgY2hhbmdlZEJpdHMsIHJlbmRlckxhbmVzKTtcbiAgICB9XG4gIH1cblxuICB2YXIgbmV3Q2hpbGRyZW4gPSBuZXdQcm9wcy5jaGlsZHJlbjtcbiAgcmVjb25jaWxlQ2hpbGRyZW4oY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG5ld0NoaWxkcmVuLCByZW5kZXJMYW5lcyk7XG4gIHJldHVybiB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbn1cblxudmFyIGhhc1dhcm5lZEFib3V0VXNpbmdDb250ZXh0QXNDb25zdW1lciA9IGZhbHNlO1xuXG5mdW5jdGlvbiB1cGRhdGVDb250ZXh0Q29uc3VtZXIoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKSB7XG4gIHZhciBjb250ZXh0ID0gd29ya0luUHJvZ3Jlc3MudHlwZTsgLy8gVGhlIGxvZ2ljIGJlbG93IGZvciBDb250ZXh0IGRpZmZlcnMgZGVwZW5kaW5nIG9uIFBST0Qgb3IgREVWIG1vZGUuIEluXG4gIC8vIERFViBtb2RlLCB3ZSBjcmVhdGUgYSBzZXBhcmF0ZSBvYmplY3QgZm9yIENvbnRleHQuQ29uc3VtZXIgdGhhdCBhY3RzXG4gIC8vIGxpa2UgYSBwcm94eSB0byBDb250ZXh0LiBUaGlzIHByb3h5IG9iamVjdCBhZGRzIHVubmVjZXNzYXJ5IGNvZGUgaW4gUFJPRFxuICAvLyBzbyB3ZSB1c2UgdGhlIG9sZCBiZWhhdmlvdXIgKENvbnRleHQuQ29uc3VtZXIgcmVmZXJlbmNlcyBDb250ZXh0KSB0b1xuICAvLyByZWR1Y2Ugc2l6ZSBhbmQgb3ZlcmhlYWQuIFRoZSBzZXBhcmF0ZSBvYmplY3QgcmVmZXJlbmNlcyBjb250ZXh0IHZpYVxuICAvLyBhIHByb3BlcnR5IGNhbGxlZCBcIl9jb250ZXh0XCIsIHdoaWNoIGFsc28gZ2l2ZXMgdXMgdGhlIGFiaWxpdHkgdG8gY2hlY2tcbiAgLy8gaW4gREVWIG1vZGUgaWYgdGhpcyBwcm9wZXJ0eSBleGlzdHMgb3Igbm90IGFuZCB3YXJuIGlmIGl0IGRvZXMgbm90LlxuXG4gIHtcbiAgICBpZiAoY29udGV4dC5fY29udGV4dCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBUaGlzIG1heSBiZSBiZWNhdXNlIGl0J3MgYSBDb250ZXh0IChyYXRoZXIgdGhhbiBhIENvbnN1bWVyKS5cbiAgICAgIC8vIE9yIGl0IG1heSBiZSBiZWNhdXNlIGl0J3Mgb2xkZXIgUmVhY3Qgd2hlcmUgdGhleSdyZSB0aGUgc2FtZSB0aGluZy5cbiAgICAgIC8vIFdlIG9ubHkgd2FudCB0byB3YXJuIGlmIHdlJ3JlIHN1cmUgaXQncyBhIG5ldyBSZWFjdC5cbiAgICAgIGlmIChjb250ZXh0ICE9PSBjb250ZXh0LkNvbnN1bWVyKSB7XG4gICAgICAgIGlmICghaGFzV2FybmVkQWJvdXRVc2luZ0NvbnRleHRBc0NvbnN1bWVyKSB7XG4gICAgICAgICAgaGFzV2FybmVkQWJvdXRVc2luZ0NvbnRleHRBc0NvbnN1bWVyID0gdHJ1ZTtcblxuICAgICAgICAgIGVycm9yKCdSZW5kZXJpbmcgPENvbnRleHQ+IGRpcmVjdGx5IGlzIG5vdCBzdXBwb3J0ZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiAnICsgJ2EgZnV0dXJlIG1ham9yIHJlbGVhc2UuIERpZCB5b3UgbWVhbiB0byByZW5kZXIgPENvbnRleHQuQ29uc3VtZXI+IGluc3RlYWQ/Jyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29udGV4dCA9IGNvbnRleHQuX2NvbnRleHQ7XG4gICAgfVxuICB9XG5cbiAgdmFyIG5ld1Byb3BzID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO1xuICB2YXIgcmVuZGVyID0gbmV3UHJvcHMuY2hpbGRyZW47XG5cbiAge1xuICAgIGlmICh0eXBlb2YgcmVuZGVyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICBlcnJvcignQSBjb250ZXh0IGNvbnN1bWVyIHdhcyByZW5kZXJlZCB3aXRoIG11bHRpcGxlIGNoaWxkcmVuLCBvciBhIGNoaWxkICcgKyBcInRoYXQgaXNuJ3QgYSBmdW5jdGlvbi4gQSBjb250ZXh0IGNvbnN1bWVyIGV4cGVjdHMgYSBzaW5nbGUgY2hpbGQgXCIgKyAndGhhdCBpcyBhIGZ1bmN0aW9uLiBJZiB5b3UgZGlkIHBhc3MgYSBmdW5jdGlvbiwgbWFrZSBzdXJlIHRoZXJlICcgKyAnaXMgbm8gdHJhaWxpbmcgb3IgbGVhZGluZyB3aGl0ZXNwYWNlIGFyb3VuZCBpdC4nKTtcbiAgICB9XG4gIH1cblxuICBwcmVwYXJlVG9SZWFkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpO1xuICB2YXIgbmV3VmFsdWUgPSByZWFkQ29udGV4dChjb250ZXh0LCBuZXdQcm9wcy51bnN0YWJsZV9vYnNlcnZlZEJpdHMpO1xuICB2YXIgbmV3Q2hpbGRyZW47XG5cbiAge1xuICAgIFJlYWN0Q3VycmVudE93bmVyJDEuY3VycmVudCA9IHdvcmtJblByb2dyZXNzO1xuICAgIHNldElzUmVuZGVyaW5nKHRydWUpO1xuICAgIG5ld0NoaWxkcmVuID0gcmVuZGVyKG5ld1ZhbHVlKTtcbiAgICBzZXRJc1JlbmRlcmluZyhmYWxzZSk7XG4gIH0gLy8gUmVhY3QgRGV2VG9vbHMgcmVhZHMgdGhpcyBmbGFnLlxuXG5cbiAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gUGVyZm9ybWVkV29yaztcbiAgcmVjb25jaWxlQ2hpbGRyZW4oY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG5ld0NoaWxkcmVuLCByZW5kZXJMYW5lcyk7XG4gIHJldHVybiB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbn1cblxuZnVuY3Rpb24gbWFya1dvcmtJblByb2dyZXNzUmVjZWl2ZWRVcGRhdGUoKSB7XG4gIGRpZFJlY2VpdmVVcGRhdGUgPSB0cnVlO1xufVxuXG5mdW5jdGlvbiBiYWlsb3V0T25BbHJlYWR5RmluaXNoZWRXb3JrKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcykge1xuICBpZiAoY3VycmVudCAhPT0gbnVsbCkge1xuICAgIC8vIFJldXNlIHByZXZpb3VzIGRlcGVuZGVuY2llc1xuICAgIHdvcmtJblByb2dyZXNzLmRlcGVuZGVuY2llcyA9IGN1cnJlbnQuZGVwZW5kZW5jaWVzO1xuICB9XG5cbiAge1xuICAgIC8vIERvbid0IHVwZGF0ZSBcImJhc2VcIiByZW5kZXIgdGltZXMgZm9yIGJhaWxvdXRzLlxuICAgIHN0b3BQcm9maWxlclRpbWVySWZSdW5uaW5nKCk7XG4gIH1cblxuICBtYXJrU2tpcHBlZFVwZGF0ZUxhbmVzKHdvcmtJblByb2dyZXNzLmxhbmVzKTsgLy8gQ2hlY2sgaWYgdGhlIGNoaWxkcmVuIGhhdmUgYW55IHBlbmRpbmcgd29yay5cblxuICBpZiAoIWluY2x1ZGVzU29tZUxhbmUocmVuZGVyTGFuZXMsIHdvcmtJblByb2dyZXNzLmNoaWxkTGFuZXMpKSB7XG4gICAgLy8gVGhlIGNoaWxkcmVuIGRvbid0IGhhdmUgYW55IHdvcmsgZWl0aGVyLiBXZSBjYW4gc2tpcCB0aGVtLlxuICAgIC8vIFRPRE86IE9uY2Ugd2UgYWRkIGJhY2sgcmVzdW1pbmcsIHdlIHNob3VsZCBjaGVjayBpZiB0aGUgY2hpbGRyZW4gYXJlXG4gICAgLy8gYSB3b3JrLWluLXByb2dyZXNzIHNldC4gSWYgc28sIHdlIG5lZWQgdG8gdHJhbnNmZXIgdGhlaXIgZWZmZWN0cy5cbiAgICByZXR1cm4gbnVsbDtcbiAgfSBlbHNlIHtcbiAgICAvLyBUaGlzIGZpYmVyIGRvZXNuJ3QgaGF2ZSB3b3JrLCBidXQgaXRzIHN1YnRyZWUgZG9lcy4gQ2xvbmUgdGhlIGNoaWxkXG4gICAgLy8gZmliZXJzIGFuZCBjb250aW51ZS5cbiAgICBjbG9uZUNoaWxkRmliZXJzKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKTtcbiAgICByZXR1cm4gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVtb3VudEZpYmVyKGN1cnJlbnQsIG9sZFdvcmtJblByb2dyZXNzLCBuZXdXb3JrSW5Qcm9ncmVzcykge1xuICB7XG4gICAgdmFyIHJldHVybkZpYmVyID0gb2xkV29ya0luUHJvZ3Jlc3MucmV0dXJuO1xuXG4gICAgaWYgKHJldHVybkZpYmVyID09PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBzd2FwIHRoZSByb290IGZpYmVyLicpO1xuICAgIH0gLy8gRGlzY29ubmVjdCBmcm9tIHRoZSBvbGQgY3VycmVudC5cbiAgICAvLyBJdCB3aWxsIGdldCBkZWxldGVkLlxuXG5cbiAgICBjdXJyZW50LmFsdGVybmF0ZSA9IG51bGw7XG4gICAgb2xkV29ya0luUHJvZ3Jlc3MuYWx0ZXJuYXRlID0gbnVsbDsgLy8gQ29ubmVjdCB0byB0aGUgbmV3IHRyZWUuXG5cbiAgICBuZXdXb3JrSW5Qcm9ncmVzcy5pbmRleCA9IG9sZFdvcmtJblByb2dyZXNzLmluZGV4O1xuICAgIG5ld1dvcmtJblByb2dyZXNzLnNpYmxpbmcgPSBvbGRXb3JrSW5Qcm9ncmVzcy5zaWJsaW5nO1xuICAgIG5ld1dvcmtJblByb2dyZXNzLnJldHVybiA9IG9sZFdvcmtJblByb2dyZXNzLnJldHVybjtcbiAgICBuZXdXb3JrSW5Qcm9ncmVzcy5yZWYgPSBvbGRXb3JrSW5Qcm9ncmVzcy5yZWY7IC8vIFJlcGxhY2UgdGhlIGNoaWxkL3NpYmxpbmcgcG9pbnRlcnMgYWJvdmUgaXQuXG5cbiAgICBpZiAob2xkV29ya0luUHJvZ3Jlc3MgPT09IHJldHVybkZpYmVyLmNoaWxkKSB7XG4gICAgICByZXR1cm5GaWJlci5jaGlsZCA9IG5ld1dvcmtJblByb2dyZXNzO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgcHJldlNpYmxpbmcgPSByZXR1cm5GaWJlci5jaGlsZDtcblxuICAgICAgaWYgKHByZXZTaWJsaW5nID09PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgcGFyZW50IHRvIGhhdmUgYSBjaGlsZC4nKTtcbiAgICAgIH1cblxuICAgICAgd2hpbGUgKHByZXZTaWJsaW5nLnNpYmxpbmcgIT09IG9sZFdvcmtJblByb2dyZXNzKSB7XG4gICAgICAgIHByZXZTaWJsaW5nID0gcHJldlNpYmxpbmcuc2libGluZztcblxuICAgICAgICBpZiAocHJldlNpYmxpbmcgPT09IG51bGwpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIHRvIGZpbmQgdGhlIHByZXZpb3VzIHNpYmxpbmcuJyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcHJldlNpYmxpbmcuc2libGluZyA9IG5ld1dvcmtJblByb2dyZXNzO1xuICAgIH0gLy8gRGVsZXRlIHRoZSBvbGQgZmliZXIgYW5kIHBsYWNlIHRoZSBuZXcgb25lLlxuICAgIC8vIFNpbmNlIHRoZSBvbGQgZmliZXIgaXMgZGlzY29ubmVjdGVkLCB3ZSBoYXZlIHRvIHNjaGVkdWxlIGl0IG1hbnVhbGx5LlxuXG5cbiAgICB2YXIgbGFzdCA9IHJldHVybkZpYmVyLmxhc3RFZmZlY3Q7XG5cbiAgICBpZiAobGFzdCAhPT0gbnVsbCkge1xuICAgICAgbGFzdC5uZXh0RWZmZWN0ID0gY3VycmVudDtcbiAgICAgIHJldHVybkZpYmVyLmxhc3RFZmZlY3QgPSBjdXJyZW50O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm5GaWJlci5maXJzdEVmZmVjdCA9IHJldHVybkZpYmVyLmxhc3RFZmZlY3QgPSBjdXJyZW50O1xuICAgIH1cblxuICAgIGN1cnJlbnQubmV4dEVmZmVjdCA9IG51bGw7XG4gICAgY3VycmVudC5mbGFncyA9IERlbGV0aW9uO1xuICAgIG5ld1dvcmtJblByb2dyZXNzLmZsYWdzIHw9IFBsYWNlbWVudDsgLy8gUmVzdGFydCB3b3JrIGZyb20gdGhlIG5ldyBmaWJlci5cblxuICAgIHJldHVybiBuZXdXb3JrSW5Qcm9ncmVzcztcbiAgfVxufVxuXG5mdW5jdGlvbiBiZWdpbldvcmsoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKSB7XG4gIHZhciB1cGRhdGVMYW5lcyA9IHdvcmtJblByb2dyZXNzLmxhbmVzO1xuXG4gIHtcbiAgICBpZiAod29ya0luUHJvZ3Jlc3MuX2RlYnVnTmVlZHNSZW1vdW50ICYmIGN1cnJlbnQgIT09IG51bGwpIHtcbiAgICAgIC8vIFRoaXMgd2lsbCByZXN0YXJ0IHRoZSBiZWdpbiBwaGFzZSB3aXRoIGEgbmV3IGZpYmVyLlxuICAgICAgcmV0dXJuIHJlbW91bnRGaWJlcihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgY3JlYXRlRmliZXJGcm9tVHlwZUFuZFByb3BzKHdvcmtJblByb2dyZXNzLnR5cGUsIHdvcmtJblByb2dyZXNzLmtleSwgd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzLCB3b3JrSW5Qcm9ncmVzcy5fZGVidWdPd25lciB8fCBudWxsLCB3b3JrSW5Qcm9ncmVzcy5tb2RlLCB3b3JrSW5Qcm9ncmVzcy5sYW5lcykpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChjdXJyZW50ICE9PSBudWxsKSB7XG4gICAgdmFyIG9sZFByb3BzID0gY3VycmVudC5tZW1vaXplZFByb3BzO1xuICAgIHZhciBuZXdQcm9wcyA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcztcblxuICAgIGlmIChvbGRQcm9wcyAhPT0gbmV3UHJvcHMgfHwgaGFzQ29udGV4dENoYW5nZWQoKSB8fCAoIC8vIEZvcmNlIGEgcmUtcmVuZGVyIGlmIHRoZSBpbXBsZW1lbnRhdGlvbiBjaGFuZ2VkIGR1ZSB0byBob3QgcmVsb2FkOlxuICAgICB3b3JrSW5Qcm9ncmVzcy50eXBlICE9PSBjdXJyZW50LnR5cGUgKSkge1xuICAgICAgLy8gSWYgcHJvcHMgb3IgY29udGV4dCBjaGFuZ2VkLCBtYXJrIHRoZSBmaWJlciBhcyBoYXZpbmcgcGVyZm9ybWVkIHdvcmsuXG4gICAgICAvLyBUaGlzIG1heSBiZSB1bnNldCBpZiB0aGUgcHJvcHMgYXJlIGRldGVybWluZWQgdG8gYmUgZXF1YWwgbGF0ZXIgKG1lbW8pLlxuICAgICAgZGlkUmVjZWl2ZVVwZGF0ZSA9IHRydWU7XG4gICAgfSBlbHNlIGlmICghaW5jbHVkZXNTb21lTGFuZShyZW5kZXJMYW5lcywgdXBkYXRlTGFuZXMpKSB7XG4gICAgICBkaWRSZWNlaXZlVXBkYXRlID0gZmFsc2U7IC8vIFRoaXMgZmliZXIgZG9lcyBub3QgaGF2ZSBhbnkgcGVuZGluZyB3b3JrLiBCYWlsb3V0IHdpdGhvdXQgZW50ZXJpbmdcbiAgICAgIC8vIHRoZSBiZWdpbiBwaGFzZS4gVGhlcmUncyBzdGlsbCBzb21lIGJvb2trZWVwaW5nIHdlIHRoYXQgbmVlZHMgdG8gYmUgZG9uZVxuICAgICAgLy8gaW4gdGhpcyBvcHRpbWl6ZWQgcGF0aCwgbW9zdGx5IHB1c2hpbmcgc3R1ZmYgb250byB0aGUgc3RhY2suXG5cbiAgICAgIHN3aXRjaCAod29ya0luUHJvZ3Jlc3MudGFnKSB7XG4gICAgICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgICAgICAgcHVzaEhvc3RSb290Q29udGV4dCh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgcmVzZXRIeWRyYXRpb25TdGF0ZSgpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgICAgICBwdXNoSG9zdENvbnRleHQod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG4gICAgICAgICAge1xuICAgICAgICAgICAgdmFyIENvbXBvbmVudCA9IHdvcmtJblByb2dyZXNzLnR5cGU7XG5cbiAgICAgICAgICAgIGlmIChpc0NvbnRleHRQcm92aWRlcihDb21wb25lbnQpKSB7XG4gICAgICAgICAgICAgIHB1c2hDb250ZXh0UHJvdmlkZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSBIb3N0UG9ydGFsOlxuICAgICAgICAgIHB1c2hIb3N0Q29udGFpbmVyKHdvcmtJblByb2dyZXNzLCB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUuY29udGFpbmVySW5mbyk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBDb250ZXh0UHJvdmlkZXI6XG4gICAgICAgICAge1xuICAgICAgICAgICAgdmFyIG5ld1ZhbHVlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcy52YWx1ZTtcbiAgICAgICAgICAgIHB1c2hQcm92aWRlcih3b3JrSW5Qcm9ncmVzcywgbmV3VmFsdWUpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgUHJvZmlsZXI6XG4gICAgICAgICAge1xuICAgICAgICAgICAgLy8gUHJvZmlsZXIgc2hvdWxkIG9ubHkgY2FsbCBvblJlbmRlciB3aGVuIG9uZSBvZiBpdHMgZGVzY2VuZGFudHMgYWN0dWFsbHkgcmVuZGVyZWQuXG4gICAgICAgICAgICB2YXIgaGFzQ2hpbGRXb3JrID0gaW5jbHVkZXNTb21lTGFuZShyZW5kZXJMYW5lcywgd29ya0luUHJvZ3Jlc3MuY2hpbGRMYW5lcyk7XG5cbiAgICAgICAgICAgIGlmIChoYXNDaGlsZFdvcmspIHtcbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gVXBkYXRlO1xuICAgICAgICAgICAgfSAvLyBSZXNldCBlZmZlY3QgZHVyYXRpb25zIGZvciB0aGUgbmV4dCBldmVudHVhbCBlZmZlY3QgcGhhc2UuXG4gICAgICAgICAgICAvLyBUaGVzZSBhcmUgcmVzZXQgZHVyaW5nIHJlbmRlciB0byBhbGxvdyB0aGUgRGV2VG9vbHMgY29tbWl0IGhvb2sgYSBjaGFuY2UgdG8gcmVhZCB0aGVtLFxuXG5cbiAgICAgICAgICAgIHZhciBzdGF0ZU5vZGUgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG4gICAgICAgICAgICBzdGF0ZU5vZGUuZWZmZWN0RHVyYXRpb24gPSAwO1xuICAgICAgICAgICAgc3RhdGVOb2RlLnBhc3NpdmVFZmZlY3REdXJhdGlvbiA9IDA7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBTdXNwZW5zZUNvbXBvbmVudDpcbiAgICAgICAgICB7XG4gICAgICAgICAgICB2YXIgc3RhdGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuXG4gICAgICAgICAgICBpZiAoc3RhdGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgLy8gd2hldGhlciB0byByZXRyeSB0aGUgcHJpbWFyeSBjaGlsZHJlbiwgb3IgdG8gc2tpcCBvdmVyIGl0IGFuZFxuICAgICAgICAgICAgICAvLyBnbyBzdHJhaWdodCB0byB0aGUgZmFsbGJhY2suIENoZWNrIHRoZSBwcmlvcml0eSBvZiB0aGUgcHJpbWFyeVxuICAgICAgICAgICAgICAvLyBjaGlsZCBmcmFnbWVudC5cblxuXG4gICAgICAgICAgICAgIHZhciBwcmltYXJ5Q2hpbGRGcmFnbWVudCA9IHdvcmtJblByb2dyZXNzLmNoaWxkO1xuICAgICAgICAgICAgICB2YXIgcHJpbWFyeUNoaWxkTGFuZXMgPSBwcmltYXJ5Q2hpbGRGcmFnbWVudC5jaGlsZExhbmVzO1xuXG4gICAgICAgICAgICAgIGlmIChpbmNsdWRlc1NvbWVMYW5lKHJlbmRlckxhbmVzLCBwcmltYXJ5Q2hpbGRMYW5lcykpIHtcbiAgICAgICAgICAgICAgICAvLyBUaGUgcHJpbWFyeSBjaGlsZHJlbiBoYXZlIHBlbmRpbmcgd29yay4gVXNlIHRoZSBub3JtYWwgcGF0aFxuICAgICAgICAgICAgICAgIC8vIHRvIGF0dGVtcHQgdG8gcmVuZGVyIHRoZSBwcmltYXJ5IGNoaWxkcmVuIGFnYWluLlxuICAgICAgICAgICAgICAgIHJldHVybiB1cGRhdGVTdXNwZW5zZUNvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFRoZSBwcmltYXJ5IGNoaWxkIGZyYWdtZW50IGRvZXMgbm90IGhhdmUgcGVuZGluZyB3b3JrIG1hcmtlZFxuICAgICAgICAgICAgICAgIC8vIG9uIGl0XG4gICAgICAgICAgICAgICAgcHVzaFN1c3BlbnNlQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgc2V0RGVmYXVsdFNoYWxsb3dTdXNwZW5zZUNvbnRleHQoc3VzcGVuc2VTdGFja0N1cnNvci5jdXJyZW50KSk7IC8vIFRoZSBwcmltYXJ5IGNoaWxkcmVuIGRvIG5vdCBoYXZlIHBlbmRpbmcgd29yayB3aXRoIHN1ZmZpY2llbnRcbiAgICAgICAgICAgICAgICAvLyBwcmlvcml0eS4gQmFpbG91dC5cblxuICAgICAgICAgICAgICAgIHZhciBjaGlsZCA9IGJhaWxvdXRPbkFscmVhZHlGaW5pc2hlZFdvcmsoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKTtcblxuICAgICAgICAgICAgICAgIGlmIChjaGlsZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgLy8gVGhlIGZhbGxiYWNrIGNoaWxkcmVuIGhhdmUgcGVuZGluZyB3b3JrLiBTa2lwIG92ZXIgdGhlXG4gICAgICAgICAgICAgICAgICAvLyBwcmltYXJ5IGNoaWxkcmVuIGFuZCB3b3JrIG9uIHRoZSBmYWxsYmFjay5cbiAgICAgICAgICAgICAgICAgIHJldHVybiBjaGlsZC5zaWJsaW5nO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHB1c2hTdXNwZW5zZUNvbnRleHQod29ya0luUHJvZ3Jlc3MsIHNldERlZmF1bHRTaGFsbG93U3VzcGVuc2VDb250ZXh0KHN1c3BlbnNlU3RhY2tDdXJzb3IuY3VycmVudCkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSBTdXNwZW5zZUxpc3RDb21wb25lbnQ6XG4gICAgICAgICAge1xuICAgICAgICAgICAgdmFyIGRpZFN1c3BlbmRCZWZvcmUgPSAoY3VycmVudC5mbGFncyAmIERpZENhcHR1cmUpICE9PSBOb0ZsYWdzO1xuXG4gICAgICAgICAgICB2YXIgX2hhc0NoaWxkV29yayA9IGluY2x1ZGVzU29tZUxhbmUocmVuZGVyTGFuZXMsIHdvcmtJblByb2dyZXNzLmNoaWxkTGFuZXMpO1xuXG4gICAgICAgICAgICBpZiAoZGlkU3VzcGVuZEJlZm9yZSkge1xuICAgICAgICAgICAgICBpZiAoX2hhc0NoaWxkV29yaykge1xuICAgICAgICAgICAgICAgIC8vIElmIHNvbWV0aGluZyB3YXMgaW4gZmFsbGJhY2sgc3RhdGUgbGFzdCB0aW1lLCBhbmQgd2UgaGF2ZSBhbGwgdGhlXG4gICAgICAgICAgICAgICAgLy8gc2FtZSBjaGlsZHJlbiB0aGVuIHdlJ3JlIHN0aWxsIGluIHByb2dyZXNzaXZlIGxvYWRpbmcgc3RhdGUuXG4gICAgICAgICAgICAgICAgLy8gU29tZXRoaW5nIG1pZ2h0IGdldCB1bmJsb2NrZWQgYnkgc3RhdGUgdXBkYXRlcyBvciByZXRyaWVzIGluIHRoZVxuICAgICAgICAgICAgICAgIC8vIHRyZWUgd2hpY2ggd2lsbCBhZmZlY3QgdGhlIHRhaWwuIFNvIHdlIG5lZWQgdG8gdXNlIHRoZSBub3JtYWxcbiAgICAgICAgICAgICAgICAvLyBwYXRoIHRvIGNvbXB1dGUgdGhlIGNvcnJlY3QgdGFpbC5cbiAgICAgICAgICAgICAgICByZXR1cm4gdXBkYXRlU3VzcGVuc2VMaXN0Q29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcyk7XG4gICAgICAgICAgICAgIH0gLy8gSWYgbm9uZSBvZiB0aGUgY2hpbGRyZW4gaGFkIGFueSB3b3JrLCB0aGF0IG1lYW5zIHRoYXQgbm9uZSBvZlxuICAgICAgICAgICAgICAvLyB0aGVtIGdvdCByZXRyaWVkIHNvIHRoZXknbGwgc3RpbGwgYmUgYmxvY2tlZCBpbiB0aGUgc2FtZSB3YXlcbiAgICAgICAgICAgICAgLy8gYXMgYmVmb3JlLiBXZSBjYW4gZmFzdCBiYWlsIG91dC5cblxuXG4gICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IERpZENhcHR1cmU7XG4gICAgICAgICAgICB9IC8vIElmIG5vdGhpbmcgc3VzcGVuZGVkIGJlZm9yZSBhbmQgd2UncmUgcmVuZGVyaW5nIHRoZSBzYW1lIGNoaWxkcmVuLFxuICAgICAgICAgICAgLy8gdGhlbiB0aGUgdGFpbCBkb2Vzbid0IG1hdHRlci4gQW55dGhpbmcgbmV3IHRoYXQgc3VzcGVuZHMgd2lsbCB3b3JrXG4gICAgICAgICAgICAvLyBpbiB0aGUgXCJ0b2dldGhlclwiIG1vZGUsIHNvIHdlIGNhbiBjb250aW51ZSBmcm9tIHRoZSBzdGF0ZSB3ZSBoYWQuXG5cblxuICAgICAgICAgICAgdmFyIHJlbmRlclN0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcblxuICAgICAgICAgICAgaWYgKHJlbmRlclN0YXRlICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIC8vIFJlc2V0IHRvIHRoZSBcInRvZ2V0aGVyXCIgbW9kZSBpbiBjYXNlIHdlJ3ZlIHN0YXJ0ZWQgYSBkaWZmZXJlbnRcbiAgICAgICAgICAgICAgLy8gdXBkYXRlIGluIHRoZSBwYXN0IGJ1dCBkaWRuJ3QgY29tcGxldGUgaXQuXG4gICAgICAgICAgICAgIHJlbmRlclN0YXRlLnJlbmRlcmluZyA9IG51bGw7XG4gICAgICAgICAgICAgIHJlbmRlclN0YXRlLnRhaWwgPSBudWxsO1xuICAgICAgICAgICAgICByZW5kZXJTdGF0ZS5sYXN0RWZmZWN0ID0gbnVsbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcHVzaFN1c3BlbnNlQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgc3VzcGVuc2VTdGFja0N1cnNvci5jdXJyZW50KTtcblxuICAgICAgICAgICAgaWYgKF9oYXNDaGlsZFdvcmspIHtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBJZiBub25lIG9mIHRoZSBjaGlsZHJlbiBoYWQgYW55IHdvcmssIHRoYXQgbWVhbnMgdGhhdCBub25lIG9mXG4gICAgICAgICAgICAgIC8vIHRoZW0gZ290IHJldHJpZWQgc28gdGhleSdsbCBzdGlsbCBiZSBibG9ja2VkIGluIHRoZSBzYW1lIHdheVxuICAgICAgICAgICAgICAvLyBhcyBiZWZvcmUuIFdlIGNhbiBmYXN0IGJhaWwgb3V0LlxuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSBPZmZzY3JlZW5Db21wb25lbnQ6XG4gICAgICAgIGNhc2UgTGVnYWN5SGlkZGVuQ29tcG9uZW50OlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIC8vIE5lZWQgdG8gY2hlY2sgaWYgdGhlIHRyZWUgc3RpbGwgbmVlZHMgdG8gYmUgZGVmZXJyZWQuIFRoaXMgaXNcbiAgICAgICAgICAgIC8vIGFsbW9zdCBpZGVudGljYWwgdG8gdGhlIGxvZ2ljIHVzZWQgaW4gdGhlIG5vcm1hbCB1cGRhdGUgcGF0aCxcbiAgICAgICAgICAgIC8vIHNvIHdlJ2xsIGp1c3QgZW50ZXIgdGhhdC4gVGhlIG9ubHkgZGlmZmVyZW5jZSBpcyB3ZSdsbCBiYWlsIG91dFxuICAgICAgICAgICAgLy8gYXQgdGhlIG5leHQgbGV2ZWwgaW5zdGVhZCBvZiB0aGlzIG9uZSwgYmVjYXVzZSB0aGUgY2hpbGQgcHJvcHNcbiAgICAgICAgICAgIC8vIGhhdmUgbm90IGNoYW5nZWQuIFdoaWNoIGlzIGZpbmUuXG4gICAgICAgICAgICAvLyBUT0RPOiBQcm9iYWJseSBzaG91bGQgcmVmYWN0b3IgYGJlZ2luV29ya2AgdG8gc3BsaXQgdGhlIGJhaWxvdXRcbiAgICAgICAgICAgIC8vIHBhdGggZnJvbSB0aGUgbm9ybWFsIHBhdGguIEknbSB0ZW1wdGVkIHRvIGRvIGEgbGFiZWxlZCBicmVhayBoZXJlXG4gICAgICAgICAgICAvLyBidXQgSSB3b24ndCA6KVxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MubGFuZXMgPSBOb0xhbmVzO1xuICAgICAgICAgICAgcmV0dXJuIHVwZGF0ZU9mZnNjcmVlbkNvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpO1xuICAgICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGJhaWxvdXRPbkFscmVhZHlGaW5pc2hlZFdvcmsoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKChjdXJyZW50LmZsYWdzICYgRm9yY2VVcGRhdGVGb3JMZWdhY3lTdXNwZW5zZSkgIT09IE5vRmxhZ3MpIHtcbiAgICAgICAgLy8gVGhpcyBpcyBhIHNwZWNpYWwgY2FzZSB0aGF0IG9ubHkgZXhpc3RzIGZvciBsZWdhY3kgbW9kZS5cbiAgICAgICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9wdWxsLzE5MjE2LlxuICAgICAgICBkaWRSZWNlaXZlVXBkYXRlID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEFuIHVwZGF0ZSB3YXMgc2NoZWR1bGVkIG9uIHRoaXMgZmliZXIsIGJ1dCB0aGVyZSBhcmUgbm8gbmV3IHByb3BzXG4gICAgICAgIC8vIG5vciBsZWdhY3kgY29udGV4dC4gU2V0IHRoaXMgdG8gZmFsc2UuIElmIGFuIHVwZGF0ZSBxdWV1ZSBvciBjb250ZXh0XG4gICAgICAgIC8vIGNvbnN1bWVyIHByb2R1Y2VzIGEgY2hhbmdlZCB2YWx1ZSwgaXQgd2lsbCBzZXQgdGhpcyB0byB0cnVlLiBPdGhlcndpc2UsXG4gICAgICAgIC8vIHRoZSBjb21wb25lbnQgd2lsbCBhc3N1bWUgdGhlIGNoaWxkcmVuIGhhdmUgbm90IGNoYW5nZWQgYW5kIGJhaWwgb3V0LlxuICAgICAgICBkaWRSZWNlaXZlVXBkYXRlID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGRpZFJlY2VpdmVVcGRhdGUgPSBmYWxzZTtcbiAgfSAvLyBCZWZvcmUgZW50ZXJpbmcgdGhlIGJlZ2luIHBoYXNlLCBjbGVhciBwZW5kaW5nIHVwZGF0ZSBwcmlvcml0eS5cbiAgLy8gVE9ETzogVGhpcyBhc3N1bWVzIHRoYXQgd2UncmUgYWJvdXQgdG8gZXZhbHVhdGUgdGhlIGNvbXBvbmVudCBhbmQgcHJvY2Vzc1xuICAvLyB0aGUgdXBkYXRlIHF1ZXVlLiBIb3dldmVyLCB0aGVyZSdzIGFuIGV4Y2VwdGlvbjogU2ltcGxlTWVtb0NvbXBvbmVudFxuICAvLyBzb21ldGltZXMgYmFpbHMgb3V0IGxhdGVyIGluIHRoZSBiZWdpbiBwaGFzZS4gVGhpcyBpbmRpY2F0ZXMgdGhhdCB3ZSBzaG91bGRcbiAgLy8gbW92ZSB0aGlzIGFzc2lnbm1lbnQgb3V0IG9mIHRoZSBjb21tb24gcGF0aCBhbmQgaW50byBlYWNoIGJyYW5jaC5cblxuXG4gIHdvcmtJblByb2dyZXNzLmxhbmVzID0gTm9MYW5lcztcblxuICBzd2l0Y2ggKHdvcmtJblByb2dyZXNzLnRhZykge1xuICAgIGNhc2UgSW5kZXRlcm1pbmF0ZUNvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgcmV0dXJuIG1vdW50SW5kZXRlcm1pbmF0ZUNvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgd29ya0luUHJvZ3Jlc3MudHlwZSwgcmVuZGVyTGFuZXMpO1xuICAgICAgfVxuXG4gICAgY2FzZSBMYXp5Q29tcG9uZW50OlxuICAgICAge1xuICAgICAgICB2YXIgZWxlbWVudFR5cGUgPSB3b3JrSW5Qcm9ncmVzcy5lbGVtZW50VHlwZTtcbiAgICAgICAgcmV0dXJuIG1vdW50TGF6eUNvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgZWxlbWVudFR5cGUsIHVwZGF0ZUxhbmVzLCByZW5kZXJMYW5lcyk7XG4gICAgICB9XG5cbiAgICBjYXNlIEZ1bmN0aW9uQ29tcG9uZW50OlxuICAgICAge1xuICAgICAgICB2YXIgX0NvbXBvbmVudCA9IHdvcmtJblByb2dyZXNzLnR5cGU7XG4gICAgICAgIHZhciB1bnJlc29sdmVkUHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7XG4gICAgICAgIHZhciByZXNvbHZlZFByb3BzID0gd29ya0luUHJvZ3Jlc3MuZWxlbWVudFR5cGUgPT09IF9Db21wb25lbnQgPyB1bnJlc29sdmVkUHJvcHMgOiByZXNvbHZlRGVmYXVsdFByb3BzKF9Db21wb25lbnQsIHVucmVzb2x2ZWRQcm9wcyk7XG4gICAgICAgIHJldHVybiB1cGRhdGVGdW5jdGlvbkNvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgX0NvbXBvbmVudCwgcmVzb2x2ZWRQcm9wcywgcmVuZGVyTGFuZXMpO1xuICAgICAgfVxuXG4gICAgY2FzZSBDbGFzc0NvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgdmFyIF9Db21wb25lbnQyID0gd29ya0luUHJvZ3Jlc3MudHlwZTtcbiAgICAgICAgdmFyIF91bnJlc29sdmVkUHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7XG5cbiAgICAgICAgdmFyIF9yZXNvbHZlZFByb3BzID0gd29ya0luUHJvZ3Jlc3MuZWxlbWVudFR5cGUgPT09IF9Db21wb25lbnQyID8gX3VucmVzb2x2ZWRQcm9wcyA6IHJlc29sdmVEZWZhdWx0UHJvcHMoX0NvbXBvbmVudDIsIF91bnJlc29sdmVkUHJvcHMpO1xuXG4gICAgICAgIHJldHVybiB1cGRhdGVDbGFzc0NvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgX0NvbXBvbmVudDIsIF9yZXNvbHZlZFByb3BzLCByZW5kZXJMYW5lcyk7XG4gICAgICB9XG5cbiAgICBjYXNlIEhvc3RSb290OlxuICAgICAgcmV0dXJuIHVwZGF0ZUhvc3RSb290KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcyk7XG5cbiAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICByZXR1cm4gdXBkYXRlSG9zdENvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpO1xuXG4gICAgY2FzZSBIb3N0VGV4dDpcbiAgICAgIHJldHVybiB1cGRhdGVIb3N0VGV4dChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcyk7XG5cbiAgICBjYXNlIFN1c3BlbnNlQ29tcG9uZW50OlxuICAgICAgcmV0dXJuIHVwZGF0ZVN1c3BlbnNlQ29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcyk7XG5cbiAgICBjYXNlIEhvc3RQb3J0YWw6XG4gICAgICByZXR1cm4gdXBkYXRlUG9ydGFsQ29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcyk7XG5cbiAgICBjYXNlIEZvcndhcmRSZWY6XG4gICAgICB7XG4gICAgICAgIHZhciB0eXBlID0gd29ya0luUHJvZ3Jlc3MudHlwZTtcbiAgICAgICAgdmFyIF91bnJlc29sdmVkUHJvcHMyID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO1xuXG4gICAgICAgIHZhciBfcmVzb2x2ZWRQcm9wczIgPSB3b3JrSW5Qcm9ncmVzcy5lbGVtZW50VHlwZSA9PT0gdHlwZSA/IF91bnJlc29sdmVkUHJvcHMyIDogcmVzb2x2ZURlZmF1bHRQcm9wcyh0eXBlLCBfdW5yZXNvbHZlZFByb3BzMik7XG5cbiAgICAgICAgcmV0dXJuIHVwZGF0ZUZvcndhcmRSZWYoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHR5cGUsIF9yZXNvbHZlZFByb3BzMiwgcmVuZGVyTGFuZXMpO1xuICAgICAgfVxuXG4gICAgY2FzZSBGcmFnbWVudDpcbiAgICAgIHJldHVybiB1cGRhdGVGcmFnbWVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpO1xuXG4gICAgY2FzZSBNb2RlOlxuICAgICAgcmV0dXJuIHVwZGF0ZU1vZGUoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKTtcblxuICAgIGNhc2UgUHJvZmlsZXI6XG4gICAgICByZXR1cm4gdXBkYXRlUHJvZmlsZXIoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKTtcblxuICAgIGNhc2UgQ29udGV4dFByb3ZpZGVyOlxuICAgICAgcmV0dXJuIHVwZGF0ZUNvbnRleHRQcm92aWRlcihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpO1xuXG4gICAgY2FzZSBDb250ZXh0Q29uc3VtZXI6XG4gICAgICByZXR1cm4gdXBkYXRlQ29udGV4dENvbnN1bWVyKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcyk7XG5cbiAgICBjYXNlIE1lbW9Db21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIHZhciBfdHlwZTIgPSB3b3JrSW5Qcm9ncmVzcy50eXBlO1xuICAgICAgICB2YXIgX3VucmVzb2x2ZWRQcm9wczMgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7IC8vIFJlc29sdmUgb3V0ZXIgcHJvcHMgZmlyc3QsIHRoZW4gcmVzb2x2ZSBpbm5lciBwcm9wcy5cblxuICAgICAgICB2YXIgX3Jlc29sdmVkUHJvcHMzID0gcmVzb2x2ZURlZmF1bHRQcm9wcyhfdHlwZTIsIF91bnJlc29sdmVkUHJvcHMzKTtcblxuICAgICAgICB7XG4gICAgICAgICAgaWYgKHdvcmtJblByb2dyZXNzLnR5cGUgIT09IHdvcmtJblByb2dyZXNzLmVsZW1lbnRUeXBlKSB7XG4gICAgICAgICAgICB2YXIgb3V0ZXJQcm9wVHlwZXMgPSBfdHlwZTIucHJvcFR5cGVzO1xuXG4gICAgICAgICAgICBpZiAob3V0ZXJQcm9wVHlwZXMpIHtcbiAgICAgICAgICAgICAgY2hlY2tQcm9wVHlwZXMob3V0ZXJQcm9wVHlwZXMsIF9yZXNvbHZlZFByb3BzMywgLy8gUmVzb2x2ZWQgZm9yIG91dGVyIG9ubHlcbiAgICAgICAgICAgICAgJ3Byb3AnLCBnZXRDb21wb25lbnROYW1lKF90eXBlMikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIF9yZXNvbHZlZFByb3BzMyA9IHJlc29sdmVEZWZhdWx0UHJvcHMoX3R5cGUyLnR5cGUsIF9yZXNvbHZlZFByb3BzMyk7XG4gICAgICAgIHJldHVybiB1cGRhdGVNZW1vQ29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBfdHlwZTIsIF9yZXNvbHZlZFByb3BzMywgdXBkYXRlTGFuZXMsIHJlbmRlckxhbmVzKTtcbiAgICAgIH1cblxuICAgIGNhc2UgU2ltcGxlTWVtb0NvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgcmV0dXJuIHVwZGF0ZVNpbXBsZU1lbW9Db21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHdvcmtJblByb2dyZXNzLnR5cGUsIHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcywgdXBkYXRlTGFuZXMsIHJlbmRlckxhbmVzKTtcbiAgICAgIH1cblxuICAgIGNhc2UgSW5jb21wbGV0ZUNsYXNzQ29tcG9uZW50OlxuICAgICAge1xuICAgICAgICB2YXIgX0NvbXBvbmVudDMgPSB3b3JrSW5Qcm9ncmVzcy50eXBlO1xuICAgICAgICB2YXIgX3VucmVzb2x2ZWRQcm9wczQgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7XG5cbiAgICAgICAgdmFyIF9yZXNvbHZlZFByb3BzNCA9IHdvcmtJblByb2dyZXNzLmVsZW1lbnRUeXBlID09PSBfQ29tcG9uZW50MyA/IF91bnJlc29sdmVkUHJvcHM0IDogcmVzb2x2ZURlZmF1bHRQcm9wcyhfQ29tcG9uZW50MywgX3VucmVzb2x2ZWRQcm9wczQpO1xuXG4gICAgICAgIHJldHVybiBtb3VudEluY29tcGxldGVDbGFzc0NvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgX0NvbXBvbmVudDMsIF9yZXNvbHZlZFByb3BzNCwgcmVuZGVyTGFuZXMpO1xuICAgICAgfVxuXG4gICAgY2FzZSBTdXNwZW5zZUxpc3RDb21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIHJldHVybiB1cGRhdGVTdXNwZW5zZUxpc3RDb21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKTtcbiAgICAgIH1cblxuICAgIGNhc2UgRnVuZGFtZW50YWxDb21wb25lbnQ6XG4gICAgICB7XG5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICBjYXNlIFNjb3BlQ29tcG9uZW50OlxuICAgICAge1xuXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgY2FzZSBCbG9jazpcbiAgICAgIHtcblxuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgIGNhc2UgT2Zmc2NyZWVuQ29tcG9uZW50OlxuICAgICAge1xuICAgICAgICByZXR1cm4gdXBkYXRlT2Zmc2NyZWVuQ29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcyk7XG4gICAgICB9XG5cbiAgICBjYXNlIExlZ2FjeUhpZGRlbkNvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgcmV0dXJuIHVwZGF0ZUxlZ2FjeUhpZGRlbkNvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpO1xuICAgICAgfVxuICB9XG5cbiAge1xuICAgIHtcbiAgICAgIHRocm93IEVycm9yKCBcIlVua25vd24gdW5pdCBvZiB3b3JrIHRhZyAoXCIgKyB3b3JrSW5Qcm9ncmVzcy50YWcgKyBcIikuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCIgKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gbWFya1VwZGF0ZSh3b3JrSW5Qcm9ncmVzcykge1xuICAvLyBUYWcgdGhlIGZpYmVyIHdpdGggYW4gdXBkYXRlIGVmZmVjdC4gVGhpcyB0dXJucyBhIFBsYWNlbWVudCBpbnRvXG4gIC8vIGEgUGxhY2VtZW50QW5kVXBkYXRlLlxuICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBVcGRhdGU7XG59XG5cbmZ1bmN0aW9uIG1hcmtSZWYkMSh3b3JrSW5Qcm9ncmVzcykge1xuICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBSZWY7XG59XG5cbnZhciBhcHBlbmRBbGxDaGlsZHJlbjtcbnZhciB1cGRhdGVIb3N0Q29udGFpbmVyO1xudmFyIHVwZGF0ZUhvc3RDb21wb25lbnQkMTtcbnZhciB1cGRhdGVIb3N0VGV4dCQxO1xuXG57XG4gIC8vIE11dGF0aW9uIG1vZGVcbiAgYXBwZW5kQWxsQ2hpbGRyZW4gPSBmdW5jdGlvbiAocGFyZW50LCB3b3JrSW5Qcm9ncmVzcywgbmVlZHNWaXNpYmlsaXR5VG9nZ2xlLCBpc0hpZGRlbikge1xuICAgIC8vIFdlIG9ubHkgaGF2ZSB0aGUgdG9wIEZpYmVyIHRoYXQgd2FzIGNyZWF0ZWQgYnV0IHdlIG5lZWQgcmVjdXJzZSBkb3duIGl0c1xuICAgIC8vIGNoaWxkcmVuIHRvIGZpbmQgYWxsIHRoZSB0ZXJtaW5hbCBub2Rlcy5cbiAgICB2YXIgbm9kZSA9IHdvcmtJblByb2dyZXNzLmNoaWxkO1xuXG4gICAgd2hpbGUgKG5vZGUgIT09IG51bGwpIHtcbiAgICAgIGlmIChub2RlLnRhZyA9PT0gSG9zdENvbXBvbmVudCB8fCBub2RlLnRhZyA9PT0gSG9zdFRleHQpIHtcbiAgICAgICAgYXBwZW5kSW5pdGlhbENoaWxkKHBhcmVudCwgbm9kZS5zdGF0ZU5vZGUpO1xuICAgICAgfSBlbHNlIGlmIChub2RlLnRhZyA9PT0gSG9zdFBvcnRhbCkgOyBlbHNlIGlmIChub2RlLmNoaWxkICE9PSBudWxsKSB7XG4gICAgICAgIG5vZGUuY2hpbGQucmV0dXJuID0gbm9kZTtcbiAgICAgICAgbm9kZSA9IG5vZGUuY2hpbGQ7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAobm9kZSA9PT0gd29ya0luUHJvZ3Jlc3MpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB3aGlsZSAobm9kZS5zaWJsaW5nID09PSBudWxsKSB7XG4gICAgICAgIGlmIChub2RlLnJldHVybiA9PT0gbnVsbCB8fCBub2RlLnJldHVybiA9PT0gd29ya0luUHJvZ3Jlc3MpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBub2RlID0gbm9kZS5yZXR1cm47XG4gICAgICB9XG5cbiAgICAgIG5vZGUuc2libGluZy5yZXR1cm4gPSBub2RlLnJldHVybjtcbiAgICAgIG5vZGUgPSBub2RlLnNpYmxpbmc7XG4gICAgfVxuICB9O1xuXG4gIHVwZGF0ZUhvc3RDb250YWluZXIgPSBmdW5jdGlvbiAod29ya0luUHJvZ3Jlc3MpIHsvLyBOb29wXG4gIH07XG5cbiAgdXBkYXRlSG9zdENvbXBvbmVudCQxID0gZnVuY3Rpb24gKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCB0eXBlLCBuZXdQcm9wcywgcm9vdENvbnRhaW5lckluc3RhbmNlKSB7XG4gICAgLy8gSWYgd2UgaGF2ZSBhbiBhbHRlcm5hdGUsIHRoYXQgbWVhbnMgdGhpcyBpcyBhbiB1cGRhdGUgYW5kIHdlIG5lZWQgdG9cbiAgICAvLyBzY2hlZHVsZSBhIHNpZGUtZWZmZWN0IHRvIGRvIHRoZSB1cGRhdGVzLlxuICAgIHZhciBvbGRQcm9wcyA9IGN1cnJlbnQubWVtb2l6ZWRQcm9wcztcblxuICAgIGlmIChvbGRQcm9wcyA9PT0gbmV3UHJvcHMpIHtcbiAgICAgIC8vIEluIG11dGF0aW9uIG1vZGUsIHRoaXMgaXMgc3VmZmljaWVudCBmb3IgYSBiYWlsb3V0IGJlY2F1c2VcbiAgICAgIC8vIHdlIHdvbid0IHRvdWNoIHRoaXMgbm9kZSBldmVuIGlmIGNoaWxkcmVuIGNoYW5nZWQuXG4gICAgICByZXR1cm47XG4gICAgfSAvLyBJZiB3ZSBnZXQgdXBkYXRlZCBiZWNhdXNlIG9uZSBvZiBvdXIgY2hpbGRyZW4gdXBkYXRlZCwgd2UgZG9uJ3RcbiAgICAvLyBoYXZlIG5ld1Byb3BzIHNvIHdlJ2xsIGhhdmUgdG8gcmV1c2UgdGhlbS5cbiAgICAvLyBUT0RPOiBTcGxpdCB0aGUgdXBkYXRlIEFQSSBhcyBzZXBhcmF0ZSBmb3IgdGhlIHByb3BzIHZzLiBjaGlsZHJlbi5cbiAgICAvLyBFdmVuIGJldHRlciB3b3VsZCBiZSBpZiBjaGlsZHJlbiB3ZXJlbid0IHNwZWNpYWwgY2FzZWQgYXQgYWxsIHRoby5cblxuXG4gICAgdmFyIGluc3RhbmNlID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuICAgIHZhciBjdXJyZW50SG9zdENvbnRleHQgPSBnZXRIb3N0Q29udGV4dCgpOyAvLyBUT0RPOiBFeHBlcmllbmNpbmcgYW4gZXJyb3Igd2hlcmUgb2xkUHJvcHMgaXMgbnVsbC4gU3VnZ2VzdHMgYSBob3N0XG4gICAgLy8gY29tcG9uZW50IGlzIGhpdHRpbmcgdGhlIHJlc3VtZSBwYXRoLiBGaWd1cmUgb3V0IHdoeS4gUG9zc2libHlcbiAgICAvLyByZWxhdGVkIHRvIGBoaWRkZW5gLlxuXG4gICAgdmFyIHVwZGF0ZVBheWxvYWQgPSBwcmVwYXJlVXBkYXRlKGluc3RhbmNlLCB0eXBlLCBvbGRQcm9wcywgbmV3UHJvcHMsIHJvb3RDb250YWluZXJJbnN0YW5jZSwgY3VycmVudEhvc3RDb250ZXh0KTsgLy8gVE9ETzogVHlwZSB0aGlzIHNwZWNpZmljIHRvIHRoaXMgdHlwZSBvZiBjb21wb25lbnQuXG5cbiAgICB3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZSA9IHVwZGF0ZVBheWxvYWQ7IC8vIElmIHRoZSB1cGRhdGUgcGF5bG9hZCBpbmRpY2F0ZXMgdGhhdCB0aGVyZSBpcyBhIGNoYW5nZSBvciBpZiB0aGVyZVxuICAgIC8vIGlzIGEgbmV3IHJlZiB3ZSBtYXJrIHRoaXMgYXMgYW4gdXBkYXRlLiBBbGwgdGhlIHdvcmsgaXMgZG9uZSBpbiBjb21taXRXb3JrLlxuXG4gICAgaWYgKHVwZGF0ZVBheWxvYWQpIHtcbiAgICAgIG1hcmtVcGRhdGUod29ya0luUHJvZ3Jlc3MpO1xuICAgIH1cbiAgfTtcblxuICB1cGRhdGVIb3N0VGV4dCQxID0gZnVuY3Rpb24gKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBvbGRUZXh0LCBuZXdUZXh0KSB7XG4gICAgLy8gSWYgdGhlIHRleHQgZGlmZmVycywgbWFyayBpdCBhcyBhbiB1cGRhdGUuIEFsbCB0aGUgd29yayBpbiBkb25lIGluIGNvbW1pdFdvcmsuXG4gICAgaWYgKG9sZFRleHQgIT09IG5ld1RleHQpIHtcbiAgICAgIG1hcmtVcGRhdGUod29ya0luUHJvZ3Jlc3MpO1xuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gY3V0T2ZmVGFpbElmTmVlZGVkKHJlbmRlclN0YXRlLCBoYXNSZW5kZXJlZEFUYWlsRmFsbGJhY2spIHtcbiAgaWYgKGdldElzSHlkcmF0aW5nKCkpIHtcbiAgICAvLyBJZiB3ZSdyZSBoeWRyYXRpbmcsIHdlIHNob3VsZCBjb25zdW1lIGFzIG1hbnkgaXRlbXMgYXMgd2UgY2FuXG4gICAgLy8gc28gd2UgZG9uJ3QgbGVhdmUgYW55IGJlaGluZC5cbiAgICByZXR1cm47XG4gIH1cblxuICBzd2l0Y2ggKHJlbmRlclN0YXRlLnRhaWxNb2RlKSB7XG4gICAgY2FzZSAnaGlkZGVuJzpcbiAgICAgIHtcbiAgICAgICAgLy8gQW55IGluc2VydGlvbnMgYXQgdGhlIGVuZCBvZiB0aGUgdGFpbCBsaXN0IGFmdGVyIHRoaXMgcG9pbnRcbiAgICAgICAgLy8gc2hvdWxkIGJlIGludmlzaWJsZS4gSWYgdGhlcmUgYXJlIGFscmVhZHkgbW91bnRlZCBib3VuZGFyaWVzXG4gICAgICAgIC8vIGFueXRoaW5nIGJlZm9yZSB0aGVtIGFyZSBub3QgY29uc2lkZXJlZCBmb3IgY29sbGFwc2luZy5cbiAgICAgICAgLy8gVGhlcmVmb3JlIHdlIG5lZWQgdG8gZ28gdGhyb3VnaCB0aGUgd2hvbGUgdGFpbCB0byBmaW5kIGlmXG4gICAgICAgIC8vIHRoZXJlIGFyZSBhbnkuXG4gICAgICAgIHZhciB0YWlsTm9kZSA9IHJlbmRlclN0YXRlLnRhaWw7XG4gICAgICAgIHZhciBsYXN0VGFpbE5vZGUgPSBudWxsO1xuXG4gICAgICAgIHdoaWxlICh0YWlsTm9kZSAhPT0gbnVsbCkge1xuICAgICAgICAgIGlmICh0YWlsTm9kZS5hbHRlcm5hdGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGxhc3RUYWlsTm9kZSA9IHRhaWxOb2RlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRhaWxOb2RlID0gdGFpbE5vZGUuc2libGluZztcbiAgICAgICAgfSAvLyBOZXh0IHdlJ3JlIHNpbXBseSBnb2luZyB0byBkZWxldGUgYWxsIGluc2VydGlvbnMgYWZ0ZXIgdGhlXG4gICAgICAgIC8vIGxhc3QgcmVuZGVyZWQgaXRlbS5cblxuXG4gICAgICAgIGlmIChsYXN0VGFpbE5vZGUgPT09IG51bGwpIHtcbiAgICAgICAgICAvLyBBbGwgcmVtYWluaW5nIGl0ZW1zIGluIHRoZSB0YWlsIGFyZSBpbnNlcnRpb25zLlxuICAgICAgICAgIHJlbmRlclN0YXRlLnRhaWwgPSBudWxsO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIERldGFjaCB0aGUgaW5zZXJ0aW9uIGFmdGVyIHRoZSBsYXN0IG5vZGUgdGhhdCB3YXMgYWxyZWFkeVxuICAgICAgICAgIC8vIGluc2VydGVkLlxuICAgICAgICAgIGxhc3RUYWlsTm9kZS5zaWJsaW5nID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgY2FzZSAnY29sbGFwc2VkJzpcbiAgICAgIHtcbiAgICAgICAgLy8gQW55IGluc2VydGlvbnMgYXQgdGhlIGVuZCBvZiB0aGUgdGFpbCBsaXN0IGFmdGVyIHRoaXMgcG9pbnRcbiAgICAgICAgLy8gc2hvdWxkIGJlIGludmlzaWJsZS4gSWYgdGhlcmUgYXJlIGFscmVhZHkgbW91bnRlZCBib3VuZGFyaWVzXG4gICAgICAgIC8vIGFueXRoaW5nIGJlZm9yZSB0aGVtIGFyZSBub3QgY29uc2lkZXJlZCBmb3IgY29sbGFwc2luZy5cbiAgICAgICAgLy8gVGhlcmVmb3JlIHdlIG5lZWQgdG8gZ28gdGhyb3VnaCB0aGUgd2hvbGUgdGFpbCB0byBmaW5kIGlmXG4gICAgICAgIC8vIHRoZXJlIGFyZSBhbnkuXG4gICAgICAgIHZhciBfdGFpbE5vZGUgPSByZW5kZXJTdGF0ZS50YWlsO1xuICAgICAgICB2YXIgX2xhc3RUYWlsTm9kZSA9IG51bGw7XG5cbiAgICAgICAgd2hpbGUgKF90YWlsTm9kZSAhPT0gbnVsbCkge1xuICAgICAgICAgIGlmIChfdGFpbE5vZGUuYWx0ZXJuYXRlICE9PSBudWxsKSB7XG4gICAgICAgICAgICBfbGFzdFRhaWxOb2RlID0gX3RhaWxOb2RlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIF90YWlsTm9kZSA9IF90YWlsTm9kZS5zaWJsaW5nO1xuICAgICAgICB9IC8vIE5leHQgd2UncmUgc2ltcGx5IGdvaW5nIHRvIGRlbGV0ZSBhbGwgaW5zZXJ0aW9ucyBhZnRlciB0aGVcbiAgICAgICAgLy8gbGFzdCByZW5kZXJlZCBpdGVtLlxuXG5cbiAgICAgICAgaWYgKF9sYXN0VGFpbE5vZGUgPT09IG51bGwpIHtcbiAgICAgICAgICAvLyBBbGwgcmVtYWluaW5nIGl0ZW1zIGluIHRoZSB0YWlsIGFyZSBpbnNlcnRpb25zLlxuICAgICAgICAgIGlmICghaGFzUmVuZGVyZWRBVGFpbEZhbGxiYWNrICYmIHJlbmRlclN0YXRlLnRhaWwgIT09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIFdlIHN1c3BlbmRlZCBkdXJpbmcgdGhlIGhlYWQuIFdlIHdhbnQgdG8gc2hvdyBhdCBsZWFzdCBvbmVcbiAgICAgICAgICAgIC8vIHJvdyBhdCB0aGUgdGFpbC4gU28gd2UnbGwga2VlcCBvbiBhbmQgY3V0IG9mZiB0aGUgcmVzdC5cbiAgICAgICAgICAgIHJlbmRlclN0YXRlLnRhaWwuc2libGluZyA9IG51bGw7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlbmRlclN0YXRlLnRhaWwgPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBEZXRhY2ggdGhlIGluc2VydGlvbiBhZnRlciB0aGUgbGFzdCBub2RlIHRoYXQgd2FzIGFscmVhZHlcbiAgICAgICAgICAvLyBpbnNlcnRlZC5cbiAgICAgICAgICBfbGFzdFRhaWxOb2RlLnNpYmxpbmcgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY29tcGxldGVXb3JrKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcykge1xuICB2YXIgbmV3UHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7XG5cbiAgc3dpdGNoICh3b3JrSW5Qcm9ncmVzcy50YWcpIHtcbiAgICBjYXNlIEluZGV0ZXJtaW5hdGVDb21wb25lbnQ6XG4gICAgY2FzZSBMYXp5Q29tcG9uZW50OlxuICAgIGNhc2UgU2ltcGxlTWVtb0NvbXBvbmVudDpcbiAgICBjYXNlIEZ1bmN0aW9uQ29tcG9uZW50OlxuICAgIGNhc2UgRm9yd2FyZFJlZjpcbiAgICBjYXNlIEZyYWdtZW50OlxuICAgIGNhc2UgTW9kZTpcbiAgICBjYXNlIFByb2ZpbGVyOlxuICAgIGNhc2UgQ29udGV4dENvbnN1bWVyOlxuICAgIGNhc2UgTWVtb0NvbXBvbmVudDpcbiAgICAgIHJldHVybiBudWxsO1xuXG4gICAgY2FzZSBDbGFzc0NvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgdmFyIENvbXBvbmVudCA9IHdvcmtJblByb2dyZXNzLnR5cGU7XG5cbiAgICAgICAgaWYgKGlzQ29udGV4dFByb3ZpZGVyKENvbXBvbmVudCkpIHtcbiAgICAgICAgICBwb3BDb250ZXh0KHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgY2FzZSBIb3N0Um9vdDpcbiAgICAgIHtcbiAgICAgICAgcG9wSG9zdENvbnRhaW5lcih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgIHBvcFRvcExldmVsQ29udGV4dE9iamVjdCh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgIHJlc2V0V29ya0luUHJvZ3Jlc3NWZXJzaW9ucygpO1xuICAgICAgICB2YXIgZmliZXJSb290ID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuXG4gICAgICAgIGlmIChmaWJlclJvb3QucGVuZGluZ0NvbnRleHQpIHtcbiAgICAgICAgICBmaWJlclJvb3QuY29udGV4dCA9IGZpYmVyUm9vdC5wZW5kaW5nQ29udGV4dDtcbiAgICAgICAgICBmaWJlclJvb3QucGVuZGluZ0NvbnRleHQgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGN1cnJlbnQgPT09IG51bGwgfHwgY3VycmVudC5jaGlsZCA9PT0gbnVsbCkge1xuICAgICAgICAgIC8vIElmIHdlIGh5ZHJhdGVkLCBwb3Agc28gdGhhdCB3ZSBjYW4gZGVsZXRlIGFueSByZW1haW5pbmcgY2hpbGRyZW5cbiAgICAgICAgICAvLyB0aGF0IHdlcmVuJ3QgaHlkcmF0ZWQuXG4gICAgICAgICAgdmFyIHdhc0h5ZHJhdGVkID0gcG9wSHlkcmF0aW9uU3RhdGUod29ya0luUHJvZ3Jlc3MpO1xuXG4gICAgICAgICAgaWYgKHdhc0h5ZHJhdGVkKSB7XG4gICAgICAgICAgICAvLyBJZiB3ZSBoeWRyYXRlZCwgdGhlbiB3ZSdsbCBuZWVkIHRvIHNjaGVkdWxlIGFuIHVwZGF0ZSBmb3JcbiAgICAgICAgICAgIC8vIHRoZSBjb21taXQgc2lkZS1lZmZlY3RzIG9uIHRoZSByb290LlxuICAgICAgICAgICAgbWFya1VwZGF0ZSh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgfSBlbHNlIGlmICghZmliZXJSb290Lmh5ZHJhdGUpIHtcbiAgICAgICAgICAgIC8vIFNjaGVkdWxlIGFuIGVmZmVjdCB0byBjbGVhciB0aGlzIGNvbnRhaW5lciBhdCB0aGUgc3RhcnQgb2YgdGhlIG5leHQgY29tbWl0LlxuICAgICAgICAgICAgLy8gVGhpcyBoYW5kbGVzIHRoZSBjYXNlIG9mIFJlYWN0IHJlbmRlcmluZyBpbnRvIGEgY29udGFpbmVyIHdpdGggcHJldmlvdXMgY2hpbGRyZW4uXG4gICAgICAgICAgICAvLyBJdCdzIGFsc28gc2FmZSB0byBkbyBmb3IgdXBkYXRlcyB0b28sIGJlY2F1c2UgY3VycmVudC5jaGlsZCB3b3VsZCBvbmx5IGJlIG51bGxcbiAgICAgICAgICAgIC8vIGlmIHRoZSBwcmV2aW91cyByZW5kZXIgd2FzIG51bGwgKHNvIHRoZSB0aGUgY29udGFpbmVyIHdvdWxkIGFscmVhZHkgYmUgZW1wdHkpLlxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gU25hcHNob3Q7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdXBkYXRlSG9zdENvbnRhaW5lcih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAge1xuICAgICAgICBwb3BIb3N0Q29udGV4dCh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgIHZhciByb290Q29udGFpbmVySW5zdGFuY2UgPSBnZXRSb290SG9zdENvbnRhaW5lcigpO1xuICAgICAgICB2YXIgdHlwZSA9IHdvcmtJblByb2dyZXNzLnR5cGU7XG5cbiAgICAgICAgaWYgKGN1cnJlbnQgIT09IG51bGwgJiYgd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlICE9IG51bGwpIHtcbiAgICAgICAgICB1cGRhdGVIb3N0Q29tcG9uZW50JDEoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHR5cGUsIG5ld1Byb3BzLCByb290Q29udGFpbmVySW5zdGFuY2UpO1xuXG4gICAgICAgICAgaWYgKGN1cnJlbnQucmVmICE9PSB3b3JrSW5Qcm9ncmVzcy5yZWYpIHtcbiAgICAgICAgICAgIG1hcmtSZWYkMSh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICghbmV3UHJvcHMpIHtcbiAgICAgICAgICAgIGlmICghKHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSAhPT0gbnVsbCkpIHtcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKCBcIldlIG11c3QgaGF2ZSBuZXcgcHJvcHMgZm9yIG5ldyBtb3VudHMuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCIgKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSAvLyBUaGlzIGNhbiBoYXBwZW4gd2hlbiB3ZSBhYm9ydCB3b3JrLlxuXG5cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBjdXJyZW50SG9zdENvbnRleHQgPSBnZXRIb3N0Q29udGV4dCgpOyAvLyBUT0RPOiBNb3ZlIGNyZWF0ZUluc3RhbmNlIHRvIGJlZ2luV29yayBhbmQga2VlcCBpdCBvbiBhIGNvbnRleHRcbiAgICAgICAgICAvLyBcInN0YWNrXCIgYXMgdGhlIHBhcmVudC4gVGhlbiBhcHBlbmQgY2hpbGRyZW4gYXMgd2UgZ28gaW4gYmVnaW5Xb3JrXG4gICAgICAgICAgLy8gb3IgY29tcGxldGVXb3JrIGRlcGVuZGluZyBvbiB3aGV0aGVyIHdlIHdhbnQgdG8gYWRkIHRoZW0gdG9wLT5kb3duIG9yXG4gICAgICAgICAgLy8gYm90dG9tLT51cC4gVG9wLT5kb3duIGlzIGZhc3RlciBpbiBJRTExLlxuXG4gICAgICAgICAgdmFyIF93YXNIeWRyYXRlZCA9IHBvcEh5ZHJhdGlvblN0YXRlKHdvcmtJblByb2dyZXNzKTtcblxuICAgICAgICAgIGlmIChfd2FzSHlkcmF0ZWQpIHtcbiAgICAgICAgICAgIC8vIFRPRE86IE1vdmUgdGhpcyBhbmQgY3JlYXRlSW5zdGFuY2Ugc3RlcCBpbnRvIHRoZSBiZWdpblBoYXNlXG4gICAgICAgICAgICAvLyB0byBjb25zb2xpZGF0ZS5cbiAgICAgICAgICAgIGlmIChwcmVwYXJlVG9IeWRyYXRlSG9zdEluc3RhbmNlKHdvcmtJblByb2dyZXNzLCByb290Q29udGFpbmVySW5zdGFuY2UsIGN1cnJlbnRIb3N0Q29udGV4dCkpIHtcbiAgICAgICAgICAgICAgLy8gSWYgY2hhbmdlcyB0byB0aGUgaHlkcmF0ZWQgbm9kZSBuZWVkIHRvIGJlIGFwcGxpZWQgYXQgdGhlXG4gICAgICAgICAgICAgIC8vIGNvbW1pdC1waGFzZSB3ZSBtYXJrIHRoaXMgYXMgc3VjaC5cbiAgICAgICAgICAgICAgbWFya1VwZGF0ZSh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBpbnN0YW5jZSA9IGNyZWF0ZUluc3RhbmNlKHR5cGUsIG5ld1Byb3BzLCByb290Q29udGFpbmVySW5zdGFuY2UsIGN1cnJlbnRIb3N0Q29udGV4dCwgd29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgICAgYXBwZW5kQWxsQ2hpbGRyZW4oaW5zdGFuY2UsIHdvcmtJblByb2dyZXNzLCBmYWxzZSwgZmFsc2UpO1xuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlID0gaW5zdGFuY2U7IC8vIENlcnRhaW4gcmVuZGVyZXJzIHJlcXVpcmUgY29tbWl0LXRpbWUgZWZmZWN0cyBmb3IgaW5pdGlhbCBtb3VudC5cbiAgICAgICAgICAgIC8vIChlZyBET00gcmVuZGVyZXIgc3VwcG9ydHMgYXV0by1mb2N1cyBmb3IgY2VydGFpbiBlbGVtZW50cykuXG4gICAgICAgICAgICAvLyBNYWtlIHN1cmUgc3VjaCByZW5kZXJlcnMgZ2V0IHNjaGVkdWxlZCBmb3IgbGF0ZXIgd29yay5cblxuICAgICAgICAgICAgaWYgKGZpbmFsaXplSW5pdGlhbENoaWxkcmVuKGluc3RhbmNlLCB0eXBlLCBuZXdQcm9wcywgcm9vdENvbnRhaW5lckluc3RhbmNlKSkge1xuICAgICAgICAgICAgICBtYXJrVXBkYXRlKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAod29ya0luUHJvZ3Jlc3MucmVmICE9PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBJZiB0aGVyZSBpcyBhIHJlZiBvbiBhIGhvc3Qgbm9kZSB3ZSBuZWVkIHRvIHNjaGVkdWxlIGEgY2FsbGJhY2tcbiAgICAgICAgICAgIG1hcmtSZWYkMSh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICBjYXNlIEhvc3RUZXh0OlxuICAgICAge1xuICAgICAgICB2YXIgbmV3VGV4dCA9IG5ld1Byb3BzO1xuXG4gICAgICAgIGlmIChjdXJyZW50ICYmIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSAhPSBudWxsKSB7XG4gICAgICAgICAgdmFyIG9sZFRleHQgPSBjdXJyZW50Lm1lbW9pemVkUHJvcHM7IC8vIElmIHdlIGhhdmUgYW4gYWx0ZXJuYXRlLCB0aGF0IG1lYW5zIHRoaXMgaXMgYW4gdXBkYXRlIGFuZCB3ZSBuZWVkXG4gICAgICAgICAgLy8gdG8gc2NoZWR1bGUgYSBzaWRlLWVmZmVjdCB0byBkbyB0aGUgdXBkYXRlcy5cblxuICAgICAgICAgIHVwZGF0ZUhvc3RUZXh0JDEoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG9sZFRleHQsIG5ld1RleHQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICh0eXBlb2YgbmV3VGV4dCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGlmICghKHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSAhPT0gbnVsbCkpIHtcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKCBcIldlIG11c3QgaGF2ZSBuZXcgcHJvcHMgZm9yIG5ldyBtb3VudHMuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCIgKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSAvLyBUaGlzIGNhbiBoYXBwZW4gd2hlbiB3ZSBhYm9ydCB3b3JrLlxuXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIF9yb290Q29udGFpbmVySW5zdGFuY2UgPSBnZXRSb290SG9zdENvbnRhaW5lcigpO1xuXG4gICAgICAgICAgdmFyIF9jdXJyZW50SG9zdENvbnRleHQgPSBnZXRIb3N0Q29udGV4dCgpO1xuXG4gICAgICAgICAgdmFyIF93YXNIeWRyYXRlZDIgPSBwb3BIeWRyYXRpb25TdGF0ZSh3b3JrSW5Qcm9ncmVzcyk7XG5cbiAgICAgICAgICBpZiAoX3dhc0h5ZHJhdGVkMikge1xuICAgICAgICAgICAgaWYgKHByZXBhcmVUb0h5ZHJhdGVIb3N0VGV4dEluc3RhbmNlKHdvcmtJblByb2dyZXNzKSkge1xuICAgICAgICAgICAgICBtYXJrVXBkYXRlKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlID0gY3JlYXRlVGV4dEluc3RhbmNlKG5ld1RleHQsIF9yb290Q29udGFpbmVySW5zdGFuY2UsIF9jdXJyZW50SG9zdENvbnRleHQsIHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgIGNhc2UgU3VzcGVuc2VDb21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIHBvcFN1c3BlbnNlQ29udGV4dCh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgIHZhciBuZXh0U3RhdGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuXG4gICAgICAgIGlmICgod29ya0luUHJvZ3Jlc3MuZmxhZ3MgJiBEaWRDYXB0dXJlKSAhPT0gTm9GbGFncykge1xuICAgICAgICAgIC8vIFNvbWV0aGluZyBzdXNwZW5kZWQuIFJlLXJlbmRlciB3aXRoIHRoZSBmYWxsYmFjayBjaGlsZHJlbi5cbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5sYW5lcyA9IHJlbmRlckxhbmVzOyAvLyBEbyBub3QgcmVzZXQgdGhlIGVmZmVjdCBsaXN0LlxuXG4gICAgICAgICAgaWYgKCAod29ya0luUHJvZ3Jlc3MubW9kZSAmIFByb2ZpbGVNb2RlKSAhPT0gTm9Nb2RlKSB7XG4gICAgICAgICAgICB0cmFuc2ZlckFjdHVhbER1cmF0aW9uKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gd29ya0luUHJvZ3Jlc3M7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbmV4dERpZFRpbWVvdXQgPSBuZXh0U3RhdGUgIT09IG51bGw7XG4gICAgICAgIHZhciBwcmV2RGlkVGltZW91dCA9IGZhbHNlO1xuXG4gICAgICAgIGlmIChjdXJyZW50ID09PSBudWxsKSB7XG4gICAgICAgICAgaWYgKHdvcmtJblByb2dyZXNzLm1lbW9pemVkUHJvcHMuZmFsbGJhY2sgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcG9wSHlkcmF0aW9uU3RhdGUod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgcHJldlN0YXRlID0gY3VycmVudC5tZW1vaXplZFN0YXRlO1xuICAgICAgICAgIHByZXZEaWRUaW1lb3V0ID0gcHJldlN0YXRlICE9PSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG5leHREaWRUaW1lb3V0ICYmICFwcmV2RGlkVGltZW91dCkge1xuICAgICAgICAgIC8vIElmIHRoaXMgc3VidHJlZWUgaXMgcnVubmluZyBpbiBibG9ja2luZyBtb2RlIHdlIGNhbiBzdXNwZW5kLFxuICAgICAgICAgIC8vIG90aGVyd2lzZSB3ZSB3b24ndCBzdXNwZW5kLlxuICAgICAgICAgIC8vIFRPRE86IFRoaXMgd2lsbCBzdGlsbCBzdXNwZW5kIGEgc3luY2hyb25vdXMgdHJlZSBpZiBhbnl0aGluZ1xuICAgICAgICAgIC8vIGluIHRoZSBjb25jdXJyZW50IHRyZWUgYWxyZWFkeSBzdXNwZW5kZWQgZHVyaW5nIHRoaXMgcmVuZGVyLlxuICAgICAgICAgIC8vIFRoaXMgaXMgYSBrbm93biBidWcuXG4gICAgICAgICAgaWYgKCh3b3JrSW5Qcm9ncmVzcy5tb2RlICYgQmxvY2tpbmdNb2RlKSAhPT0gTm9Nb2RlKSB7XG4gICAgICAgICAgICAvLyBUT0RPOiBNb3ZlIHRoaXMgYmFjayB0byB0aHJvd0V4Y2VwdGlvbiBiZWNhdXNlIHRoaXMgaXMgdG9vIGxhdGVcbiAgICAgICAgICAgIC8vIGlmIHRoaXMgaXMgYSBsYXJnZSB0cmVlIHdoaWNoIGlzIGNvbW1vbiBmb3IgaW5pdGlhbCBsb2Fkcy4gV2VcbiAgICAgICAgICAgIC8vIGRvbid0IGtub3cgaWYgd2Ugc2hvdWxkIHJlc3RhcnQgYSByZW5kZXIgb3Igbm90IHVudGlsIHdlIGdldFxuICAgICAgICAgICAgLy8gdGhpcyBtYXJrZXIsIGFuZCB0aGlzIGlzIHRvbyBsYXRlLlxuICAgICAgICAgICAgLy8gSWYgdGhpcyByZW5kZXIgYWxyZWFkeSBoYWQgYSBwaW5nIG9yIGxvd2VyIHByaSB1cGRhdGVzLFxuICAgICAgICAgICAgLy8gYW5kIHRoaXMgaXMgdGhlIGZpcnN0IHRpbWUgd2Uga25vdyB3ZSdyZSBnb2luZyB0byBzdXNwZW5kIHdlXG4gICAgICAgICAgICAvLyBzaG91bGQgYmUgYWJsZSB0byBpbW1lZGlhdGVseSByZXN0YXJ0IGZyb20gd2l0aGluIHRocm93RXhjZXB0aW9uLlxuICAgICAgICAgICAgdmFyIGhhc0ludmlzaWJsZUNoaWxkQ29udGV4dCA9IGN1cnJlbnQgPT09IG51bGwgJiYgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcy51bnN0YWJsZV9hdm9pZFRoaXNGYWxsYmFjayAhPT0gdHJ1ZTtcblxuICAgICAgICAgICAgaWYgKGhhc0ludmlzaWJsZUNoaWxkQ29udGV4dCB8fCBoYXNTdXNwZW5zZUNvbnRleHQoc3VzcGVuc2VTdGFja0N1cnNvci5jdXJyZW50LCBJbnZpc2libGVQYXJlbnRTdXNwZW5zZUNvbnRleHQpKSB7XG4gICAgICAgICAgICAgIC8vIElmIHRoaXMgd2FzIGluIGFuIGludmlzaWJsZSB0cmVlIG9yIGEgbmV3IHJlbmRlciwgdGhlbiBzaG93aW5nXG4gICAgICAgICAgICAgIC8vIHRoaXMgYm91bmRhcnkgaXMgb2suXG4gICAgICAgICAgICAgIHJlbmRlckRpZFN1c3BlbmQoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIE90aGVyd2lzZSwgd2UncmUgZ29pbmcgdG8gaGF2ZSB0byBoaWRlIGNvbnRlbnQgc28gd2Ugc2hvdWxkXG4gICAgICAgICAgICAgIC8vIHN1c3BlbmQgZm9yIGxvbmdlciBpZiBwb3NzaWJsZS5cbiAgICAgICAgICAgICAgcmVuZGVyRGlkU3VzcGVuZERlbGF5SWZQb3NzaWJsZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHtcbiAgICAgICAgICAvLyBUT0RPOiBPbmx5IHNjaGVkdWxlIHVwZGF0ZXMgaWYgdGhlc2UgdmFsdWVzIGFyZSBub24gZXF1YWwsIGkuZS4gaXQgY2hhbmdlZC5cbiAgICAgICAgICBpZiAobmV4dERpZFRpbWVvdXQgfHwgcHJldkRpZFRpbWVvdXQpIHtcbiAgICAgICAgICAgIC8vIElmIHRoaXMgYm91bmRhcnkganVzdCB0aW1lZCBvdXQsIHNjaGVkdWxlIGFuIGVmZmVjdCB0byBhdHRhY2ggYVxuICAgICAgICAgICAgLy8gcmV0cnkgbGlzdGVuZXIgdG8gdGhlIHByb21pc2UuIFRoaXMgZmxhZyBpcyBhbHNvIHVzZWQgdG8gaGlkZSB0aGVcbiAgICAgICAgICAgIC8vIHByaW1hcnkgY2hpbGRyZW4uIEluIG11dGF0aW9uIG1vZGUsIHdlIGFsc28gbmVlZCB0aGUgZmxhZyB0b1xuICAgICAgICAgICAgLy8gKnVuaGlkZSogY2hpbGRyZW4gdGhhdCB3ZXJlIHByZXZpb3VzbHkgaGlkZGVuLCBzbyBjaGVjayBpZiB0aGlzXG4gICAgICAgICAgICAvLyBpcyBjdXJyZW50bHkgdGltZWQgb3V0LCB0b28uXG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBVcGRhdGU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICBjYXNlIEhvc3RQb3J0YWw6XG4gICAgICBwb3BIb3N0Q29udGFpbmVyKHdvcmtJblByb2dyZXNzKTtcbiAgICAgIHVwZGF0ZUhvc3RDb250YWluZXIod29ya0luUHJvZ3Jlc3MpO1xuXG4gICAgICBpZiAoY3VycmVudCA9PT0gbnVsbCkge1xuICAgICAgICBwcmVwYXJlUG9ydGFsTW91bnQod29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlLmNvbnRhaW5lckluZm8pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbnVsbDtcblxuICAgIGNhc2UgQ29udGV4dFByb3ZpZGVyOlxuICAgICAgLy8gUG9wIHByb3ZpZGVyIGZpYmVyXG4gICAgICBwb3BQcm92aWRlcih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICByZXR1cm4gbnVsbDtcblxuICAgIGNhc2UgSW5jb21wbGV0ZUNsYXNzQ29tcG9uZW50OlxuICAgICAge1xuICAgICAgICAvLyBTYW1lIGFzIGNsYXNzIGNvbXBvbmVudCBjYXNlLiBJIHB1dCBpdCBkb3duIGhlcmUgc28gdGhhdCB0aGUgdGFncyBhcmVcbiAgICAgICAgLy8gc2VxdWVudGlhbCB0byBlbnN1cmUgdGhpcyBzd2l0Y2ggaXMgY29tcGlsZWQgdG8gYSBqdW1wIHRhYmxlLlxuICAgICAgICB2YXIgX0NvbXBvbmVudCA9IHdvcmtJblByb2dyZXNzLnR5cGU7XG5cbiAgICAgICAgaWYgKGlzQ29udGV4dFByb3ZpZGVyKF9Db21wb25lbnQpKSB7XG4gICAgICAgICAgcG9wQ29udGV4dCh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgIGNhc2UgU3VzcGVuc2VMaXN0Q29tcG9uZW50OlxuICAgICAge1xuICAgICAgICBwb3BTdXNwZW5zZUNvbnRleHQod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICB2YXIgcmVuZGVyU3RhdGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuXG4gICAgICAgIGlmIChyZW5kZXJTdGF0ZSA9PT0gbnVsbCkge1xuICAgICAgICAgIC8vIFdlJ3JlIHJ1bm5pbmcgaW4gdGhlIGRlZmF1bHQsIFwiaW5kZXBlbmRlbnRcIiBtb2RlLlxuICAgICAgICAgIC8vIFdlIGRvbid0IGRvIGFueXRoaW5nIGluIHRoaXMgbW9kZS5cbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBkaWRTdXNwZW5kQWxyZWFkeSA9ICh3b3JrSW5Qcm9ncmVzcy5mbGFncyAmIERpZENhcHR1cmUpICE9PSBOb0ZsYWdzO1xuICAgICAgICB2YXIgcmVuZGVyZWRUYWlsID0gcmVuZGVyU3RhdGUucmVuZGVyaW5nO1xuXG4gICAgICAgIGlmIChyZW5kZXJlZFRhaWwgPT09IG51bGwpIHtcbiAgICAgICAgICAvLyBXZSBqdXN0IHJlbmRlcmVkIHRoZSBoZWFkLlxuICAgICAgICAgIGlmICghZGlkU3VzcGVuZEFscmVhZHkpIHtcbiAgICAgICAgICAgIC8vIFRoaXMgaXMgdGhlIGZpcnN0IHBhc3MuIFdlIG5lZWQgdG8gZmlndXJlIG91dCBpZiBhbnl0aGluZyBpcyBzdGlsbFxuICAgICAgICAgICAgLy8gc3VzcGVuZGVkIGluIHRoZSByZW5kZXJlZCBzZXQuXG4gICAgICAgICAgICAvLyBJZiBuZXcgY29udGVudCB1bnN1c3BlbmRlZCwgYnV0IHRoZXJlJ3Mgc3RpbGwgc29tZSBjb250ZW50IHRoYXRcbiAgICAgICAgICAgIC8vIGRpZG4ndC4gVGhlbiB3ZSBuZWVkIHRvIGRvIGEgc2Vjb25kIHBhc3MgdGhhdCBmb3JjZXMgZXZlcnl0aGluZ1xuICAgICAgICAgICAgLy8gdG8ga2VlcCBzaG93aW5nIHRoZWlyIGZhbGxiYWNrcy5cbiAgICAgICAgICAgIC8vIFdlIG1pZ2h0IGJlIHN1c3BlbmRlZCBpZiBzb21ldGhpbmcgaW4gdGhpcyByZW5kZXIgcGFzcyBzdXNwZW5kZWQsIG9yXG4gICAgICAgICAgICAvLyBzb21ldGhpbmcgaW4gdGhlIHByZXZpb3VzIGNvbW1pdHRlZCBwYXNzIHN1c3BlbmRlZC4gT3RoZXJ3aXNlLFxuICAgICAgICAgICAgLy8gdGhlcmUncyBubyBjaGFuY2Ugc28gd2UgY2FuIHNraXAgdGhlIGV4cGVuc2l2ZSBjYWxsIHRvXG4gICAgICAgICAgICAvLyBmaW5kRmlyc3RTdXNwZW5kZWQuXG4gICAgICAgICAgICB2YXIgY2Fubm90QmVTdXNwZW5kZWQgPSByZW5kZXJIYXNOb3RTdXNwZW5kZWRZZXQoKSAmJiAoY3VycmVudCA9PT0gbnVsbCB8fCAoY3VycmVudC5mbGFncyAmIERpZENhcHR1cmUpID09PSBOb0ZsYWdzKTtcblxuICAgICAgICAgICAgaWYgKCFjYW5ub3RCZVN1c3BlbmRlZCkge1xuICAgICAgICAgICAgICB2YXIgcm93ID0gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG5cbiAgICAgICAgICAgICAgd2hpbGUgKHJvdyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHZhciBzdXNwZW5kZWQgPSBmaW5kRmlyc3RTdXNwZW5kZWQocm93KTtcblxuICAgICAgICAgICAgICAgIGlmIChzdXNwZW5kZWQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgIGRpZFN1c3BlbmRBbHJlYWR5ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IERpZENhcHR1cmU7XG4gICAgICAgICAgICAgICAgICBjdXRPZmZUYWlsSWZOZWVkZWQocmVuZGVyU3RhdGUsIGZhbHNlKTsgLy8gSWYgdGhpcyBpcyBhIG5ld2x5IHN1c3BlbmRlZCB0cmVlLCBpdCBtaWdodCBub3QgZ2V0IGNvbW1pdHRlZCBhc1xuICAgICAgICAgICAgICAgICAgLy8gcGFydCBvZiB0aGUgc2Vjb25kIHBhc3MuIEluIHRoYXQgY2FzZSBub3RoaW5nIHdpbGwgc3Vic2NyaWJlIHRvXG4gICAgICAgICAgICAgICAgICAvLyBpdHMgdGhlbm5hYmxlcy4gSW5zdGVhZCwgd2UnbGwgdHJhbnNmZXIgaXRzIHRoZW5uYWJsZXMgdG8gdGhlXG4gICAgICAgICAgICAgICAgICAvLyBTdXNwZW5zZUxpc3Qgc28gdGhhdCBpdCBjYW4gcmV0cnkgaWYgdGhleSByZXNvbHZlLlxuICAgICAgICAgICAgICAgICAgLy8gVGhlcmUgbWlnaHQgYmUgbXVsdGlwbGUgb2YgdGhlc2UgaW4gdGhlIGxpc3QgYnV0IHNpbmNlIHdlJ3JlXG4gICAgICAgICAgICAgICAgICAvLyBnb2luZyB0byB3YWl0IGZvciBhbGwgb2YgdGhlbSBhbnl3YXksIGl0IGRvZXNuJ3QgcmVhbGx5IG1hdHRlclxuICAgICAgICAgICAgICAgICAgLy8gd2hpY2ggb25lcyBnZXRzIHRvIHBpbmcuIEluIHRoZW9yeSB3ZSBjb3VsZCBnZXQgY2xldmVyIGFuZCBrZWVwXG4gICAgICAgICAgICAgICAgICAvLyB0cmFjayBvZiBob3cgbWFueSBkZXBlbmRlbmNpZXMgcmVtYWluIGJ1dCBpdCBnZXRzIHRyaWNreSBiZWNhdXNlXG4gICAgICAgICAgICAgICAgICAvLyBpbiB0aGUgbWVhbnRpbWUsIHdlIGNhbiBhZGQvcmVtb3ZlL2NoYW5nZSBpdGVtcyBhbmQgZGVwZW5kZW5jaWVzLlxuICAgICAgICAgICAgICAgICAgLy8gV2UgbWlnaHQgYmFpbCBvdXQgb2YgdGhlIGxvb3AgYmVmb3JlIGZpbmRpbmcgYW55IGJ1dCB0aGF0XG4gICAgICAgICAgICAgICAgICAvLyBkb2Vzbid0IG1hdHRlciBzaW5jZSB0aGF0IG1lYW5zIHRoYXQgdGhlIG90aGVyIGJvdW5kYXJpZXMgdGhhdFxuICAgICAgICAgICAgICAgICAgLy8gd2UgZGlkIGZpbmQgYWxyZWFkeSBoYXMgdGhlaXIgbGlzdGVuZXJzIGF0dGFjaGVkLlxuXG4gICAgICAgICAgICAgICAgICB2YXIgbmV3VGhlbm5hYmxlcyA9IHN1c3BlbmRlZC51cGRhdGVRdWV1ZTtcblxuICAgICAgICAgICAgICAgICAgaWYgKG5ld1RoZW5uYWJsZXMgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWUgPSBuZXdUaGVubmFibGVzO1xuICAgICAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBVcGRhdGU7XG4gICAgICAgICAgICAgICAgICB9IC8vIFJlcmVuZGVyIHRoZSB3aG9sZSBsaXN0LCBidXQgdGhpcyB0aW1lLCB3ZSdsbCBmb3JjZSBmYWxsYmFja3NcbiAgICAgICAgICAgICAgICAgIC8vIHRvIHN0YXkgaW4gcGxhY2UuXG4gICAgICAgICAgICAgICAgICAvLyBSZXNldCB0aGUgZWZmZWN0IGxpc3QgYmVmb3JlIGRvaW5nIHRoZSBzZWNvbmQgcGFzcyBzaW5jZSB0aGF0J3Mgbm93IGludmFsaWQuXG5cblxuICAgICAgICAgICAgICAgICAgaWYgKHJlbmRlclN0YXRlLmxhc3RFZmZlY3QgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MuZmlyc3RFZmZlY3QgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5sYXN0RWZmZWN0ID0gcmVuZGVyU3RhdGUubGFzdEVmZmVjdDsgLy8gUmVzZXQgdGhlIGNoaWxkIGZpYmVycyB0byB0aGVpciBvcmlnaW5hbCBzdGF0ZS5cblxuICAgICAgICAgICAgICAgICAgcmVzZXRDaGlsZEZpYmVycyh3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpOyAvLyBTZXQgdXAgdGhlIFN1c3BlbnNlIENvbnRleHQgdG8gZm9yY2Ugc3VzcGVuc2UgYW5kIGltbWVkaWF0ZWx5XG4gICAgICAgICAgICAgICAgICAvLyByZXJlbmRlciB0aGUgY2hpbGRyZW4uXG5cbiAgICAgICAgICAgICAgICAgIHB1c2hTdXNwZW5zZUNvbnRleHQod29ya0luUHJvZ3Jlc3MsIHNldFNoYWxsb3dTdXNwZW5zZUNvbnRleHQoc3VzcGVuc2VTdGFja0N1cnNvci5jdXJyZW50LCBGb3JjZVN1c3BlbnNlRmFsbGJhY2spKTtcbiAgICAgICAgICAgICAgICAgIHJldHVybiB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByb3cgPSByb3cuc2libGluZztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocmVuZGVyU3RhdGUudGFpbCAhPT0gbnVsbCAmJiBub3coKSA+IGdldFJlbmRlclRhcmdldFRpbWUoKSkge1xuICAgICAgICAgICAgICAvLyBXZSBoYXZlIGFscmVhZHkgcGFzc2VkIG91ciBDUFUgZGVhZGxpbmUgYnV0IHdlIHN0aWxsIGhhdmUgcm93c1xuICAgICAgICAgICAgICAvLyBsZWZ0IGluIHRoZSB0YWlsLiBXZSdsbCBqdXN0IGdpdmUgdXAgZnVydGhlciBhdHRlbXB0cyB0byByZW5kZXJcbiAgICAgICAgICAgICAgLy8gdGhlIG1haW4gY29udGVudCBhbmQgb25seSByZW5kZXIgZmFsbGJhY2tzLlxuICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBEaWRDYXB0dXJlO1xuICAgICAgICAgICAgICBkaWRTdXNwZW5kQWxyZWFkeSA9IHRydWU7XG4gICAgICAgICAgICAgIGN1dE9mZlRhaWxJZk5lZWRlZChyZW5kZXJTdGF0ZSwgZmFsc2UpOyAvLyBTaW5jZSBub3RoaW5nIGFjdHVhbGx5IHN1c3BlbmRlZCwgdGhlcmUgd2lsbCBub3RoaW5nIHRvIHBpbmcgdGhpc1xuICAgICAgICAgICAgICAvLyB0byBnZXQgaXQgc3RhcnRlZCBiYWNrIHVwIHRvIGF0dGVtcHQgdGhlIG5leHQgaXRlbS4gV2hpbGUgaW4gdGVybXNcbiAgICAgICAgICAgICAgLy8gb2YgcHJpb3JpdHkgdGhpcyB3b3JrIGhhcyB0aGUgc2FtZSBwcmlvcml0eSBhcyB0aGlzIGN1cnJlbnQgcmVuZGVyLFxuICAgICAgICAgICAgICAvLyBpdCdzIG5vdCBwYXJ0IG9mIHRoZSBzYW1lIHRyYW5zaXRpb24gb25jZSB0aGUgdHJhbnNpdGlvbiBoYXNcbiAgICAgICAgICAgICAgLy8gY29tbWl0dGVkLiBJZiBpdCdzIHN5bmMsIHdlIHN0aWxsIHdhbnQgdG8geWllbGQgc28gdGhhdCBpdCBjYW4gYmVcbiAgICAgICAgICAgICAgLy8gcGFpbnRlZC4gQ29uY2VwdHVhbGx5LCB0aGlzIGlzIHJlYWxseSB0aGUgc2FtZSBhcyBwaW5naW5nLlxuICAgICAgICAgICAgICAvLyBXZSBjYW4gdXNlIGFueSBSZXRyeUxhbmUgZXZlbiBpZiBpdCdzIHRoZSBvbmUgY3VycmVudGx5IHJlbmRlcmluZ1xuICAgICAgICAgICAgICAvLyBzaW5jZSB3ZSdyZSBsZWF2aW5nIGl0IGJlaGluZCBvbiB0aGlzIG5vZGUuXG5cbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MubGFuZXMgPSBTb21lUmV0cnlMYW5lO1xuXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBtYXJrU3Bhd25lZFdvcmsoU29tZVJldHJ5TGFuZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY3V0T2ZmVGFpbElmTmVlZGVkKHJlbmRlclN0YXRlLCBmYWxzZSk7XG4gICAgICAgICAgfSAvLyBOZXh0IHdlJ3JlIGdvaW5nIHRvIHJlbmRlciB0aGUgdGFpbC5cblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIEFwcGVuZCB0aGUgcmVuZGVyZWQgcm93IHRvIHRoZSBjaGlsZCBsaXN0LlxuICAgICAgICAgIGlmICghZGlkU3VzcGVuZEFscmVhZHkpIHtcbiAgICAgICAgICAgIHZhciBfc3VzcGVuZGVkID0gZmluZEZpcnN0U3VzcGVuZGVkKHJlbmRlcmVkVGFpbCk7XG5cbiAgICAgICAgICAgIGlmIChfc3VzcGVuZGVkICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IERpZENhcHR1cmU7XG4gICAgICAgICAgICAgIGRpZFN1c3BlbmRBbHJlYWR5ID0gdHJ1ZTsgLy8gRW5zdXJlIHdlIHRyYW5zZmVyIHRoZSB1cGRhdGUgcXVldWUgdG8gdGhlIHBhcmVudCBzbyB0aGF0IGl0IGRvZXNuJ3RcbiAgICAgICAgICAgICAgLy8gZ2V0IGxvc3QgaWYgdGhpcyByb3cgZW5kcyB1cCBkcm9wcGVkIGR1cmluZyBhIHNlY29uZCBwYXNzLlxuXG4gICAgICAgICAgICAgIHZhciBfbmV3VGhlbm5hYmxlcyA9IF9zdXNwZW5kZWQudXBkYXRlUXVldWU7XG5cbiAgICAgICAgICAgICAgaWYgKF9uZXdUaGVubmFibGVzICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWUgPSBfbmV3VGhlbm5hYmxlcztcbiAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBVcGRhdGU7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBjdXRPZmZUYWlsSWZOZWVkZWQocmVuZGVyU3RhdGUsIHRydWUpOyAvLyBUaGlzIG1pZ2h0IGhhdmUgYmVlbiBtb2RpZmllZC5cblxuICAgICAgICAgICAgICBpZiAocmVuZGVyU3RhdGUudGFpbCA9PT0gbnVsbCAmJiByZW5kZXJTdGF0ZS50YWlsTW9kZSA9PT0gJ2hpZGRlbicgJiYgIXJlbmRlcmVkVGFpbC5hbHRlcm5hdGUgJiYgIWdldElzSHlkcmF0aW5nKCkgLy8gV2UgZG9uJ3QgY3V0IGl0IGlmIHdlJ3JlIGh5ZHJhdGluZy5cbiAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAvLyBXZSBuZWVkIHRvIGRlbGV0ZSB0aGUgcm93IHdlIGp1c3QgcmVuZGVyZWQuXG4gICAgICAgICAgICAgICAgICAvLyBSZXNldCB0aGUgZWZmZWN0IGxpc3QgdG8gd2hhdCBpdCB3YXMgYmVmb3JlIHdlIHJlbmRlcmVkIHRoaXNcbiAgICAgICAgICAgICAgICAgIC8vIGNoaWxkLiBUaGUgbmVzdGVkIGNoaWxkcmVuIGhhdmUgYWxyZWFkeSBhcHBlbmRlZCB0aGVtc2VsdmVzLlxuICAgICAgICAgICAgICAgICAgdmFyIGxhc3RFZmZlY3QgPSB3b3JrSW5Qcm9ncmVzcy5sYXN0RWZmZWN0ID0gcmVuZGVyU3RhdGUubGFzdEVmZmVjdDsgLy8gUmVtb3ZlIGFueSBlZmZlY3RzIHRoYXQgd2VyZSBhcHBlbmRlZCBhZnRlciB0aGlzIHBvaW50LlxuXG4gICAgICAgICAgICAgICAgICBpZiAobGFzdEVmZmVjdCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBsYXN0RWZmZWN0Lm5leHRFZmZlY3QgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgfSAvLyBXZSdyZSBkb25lLlxuXG5cbiAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIC8vIFRoZSB0aW1lIGl0IHRvb2sgdG8gcmVuZGVyIGxhc3Qgcm93IGlzIGdyZWF0ZXIgdGhhbiB0aGUgcmVtYWluaW5nXG4gICAgICAgICAgICAvLyB0aW1lIHdlIGhhdmUgdG8gcmVuZGVyLiBTbyByZW5kZXJpbmcgb25lIG1vcmUgcm93IHdvdWxkIGxpa2VseVxuICAgICAgICAgICAgLy8gZXhjZWVkIGl0LlxuICAgICAgICAgICAgbm93KCkgKiAyIC0gcmVuZGVyU3RhdGUucmVuZGVyaW5nU3RhcnRUaW1lID4gZ2V0UmVuZGVyVGFyZ2V0VGltZSgpICYmIHJlbmRlckxhbmVzICE9PSBPZmZzY3JlZW5MYW5lKSB7XG4gICAgICAgICAgICAgIC8vIFdlIGhhdmUgbm93IHBhc3NlZCBvdXIgQ1BVIGRlYWRsaW5lIGFuZCB3ZSdsbCBqdXN0IGdpdmUgdXAgZnVydGhlclxuICAgICAgICAgICAgICAvLyBhdHRlbXB0cyB0byByZW5kZXIgdGhlIG1haW4gY29udGVudCBhbmQgb25seSByZW5kZXIgZmFsbGJhY2tzLlxuICAgICAgICAgICAgICAvLyBUaGUgYXNzdW1wdGlvbiBpcyB0aGF0IHRoaXMgaXMgdXN1YWxseSBmYXN0ZXIuXG4gICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IERpZENhcHR1cmU7XG4gICAgICAgICAgICAgIGRpZFN1c3BlbmRBbHJlYWR5ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgY3V0T2ZmVGFpbElmTmVlZGVkKHJlbmRlclN0YXRlLCBmYWxzZSk7IC8vIFNpbmNlIG5vdGhpbmcgYWN0dWFsbHkgc3VzcGVuZGVkLCB0aGVyZSB3aWxsIG5vdGhpbmcgdG8gcGluZyB0aGlzXG4gICAgICAgICAgICAgIC8vIHRvIGdldCBpdCBzdGFydGVkIGJhY2sgdXAgdG8gYXR0ZW1wdCB0aGUgbmV4dCBpdGVtLiBXaGlsZSBpbiB0ZXJtc1xuICAgICAgICAgICAgICAvLyBvZiBwcmlvcml0eSB0aGlzIHdvcmsgaGFzIHRoZSBzYW1lIHByaW9yaXR5IGFzIHRoaXMgY3VycmVudCByZW5kZXIsXG4gICAgICAgICAgICAgIC8vIGl0J3Mgbm90IHBhcnQgb2YgdGhlIHNhbWUgdHJhbnNpdGlvbiBvbmNlIHRoZSB0cmFuc2l0aW9uIGhhc1xuICAgICAgICAgICAgICAvLyBjb21taXR0ZWQuIElmIGl0J3Mgc3luYywgd2Ugc3RpbGwgd2FudCB0byB5aWVsZCBzbyB0aGF0IGl0IGNhbiBiZVxuICAgICAgICAgICAgICAvLyBwYWludGVkLiBDb25jZXB0dWFsbHksIHRoaXMgaXMgcmVhbGx5IHRoZSBzYW1lIGFzIHBpbmdpbmcuXG4gICAgICAgICAgICAgIC8vIFdlIGNhbiB1c2UgYW55IFJldHJ5TGFuZSBldmVuIGlmIGl0J3MgdGhlIG9uZSBjdXJyZW50bHkgcmVuZGVyaW5nXG4gICAgICAgICAgICAgIC8vIHNpbmNlIHdlJ3JlIGxlYXZpbmcgaXQgYmVoaW5kIG9uIHRoaXMgbm9kZS5cblxuICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5sYW5lcyA9IFNvbWVSZXRyeUxhbmU7XG5cbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG1hcmtTcGF3bmVkV29yayhTb21lUmV0cnlMYW5lKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChyZW5kZXJTdGF0ZS5pc0JhY2t3YXJkcykge1xuICAgICAgICAgICAgLy8gVGhlIGVmZmVjdCBsaXN0IG9mIHRoZSBiYWNrd2FyZHMgdGFpbCB3aWxsIGhhdmUgYmVlbiBhZGRlZFxuICAgICAgICAgICAgLy8gdG8gdGhlIGVuZC4gVGhpcyBicmVha3MgdGhlIGd1YXJhbnRlZSB0aGF0IGxpZmUtY3ljbGVzIGZpcmUgaW5cbiAgICAgICAgICAgIC8vIHNpYmxpbmcgb3JkZXIgYnV0IHRoYXQgaXNuJ3QgYSBzdHJvbmcgZ3VhcmFudGVlIHByb21pc2VkIGJ5IFJlYWN0LlxuICAgICAgICAgICAgLy8gRXNwZWNpYWxseSBzaW5jZSB0aGVzZSBtaWdodCBhbHNvIGp1c3QgcG9wIGluIGR1cmluZyBmdXR1cmUgY29tbWl0cy5cbiAgICAgICAgICAgIC8vIEFwcGVuZCB0byB0aGUgYmVnaW5uaW5nIG9mIHRoZSBsaXN0LlxuICAgICAgICAgICAgcmVuZGVyZWRUYWlsLnNpYmxpbmcgPSB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLmNoaWxkID0gcmVuZGVyZWRUYWlsO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgcHJldmlvdXNTaWJsaW5nID0gcmVuZGVyU3RhdGUubGFzdDtcblxuICAgICAgICAgICAgaWYgKHByZXZpb3VzU2libGluZyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICBwcmV2aW91c1NpYmxpbmcuc2libGluZyA9IHJlbmRlcmVkVGFpbDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLmNoaWxkID0gcmVuZGVyZWRUYWlsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZW5kZXJTdGF0ZS5sYXN0ID0gcmVuZGVyZWRUYWlsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyZW5kZXJTdGF0ZS50YWlsICE9PSBudWxsKSB7XG4gICAgICAgICAgLy8gV2Ugc3RpbGwgaGF2ZSB0YWlsIHJvd3MgdG8gcmVuZGVyLlxuICAgICAgICAgIC8vIFBvcCBhIHJvdy5cbiAgICAgICAgICB2YXIgbmV4dCA9IHJlbmRlclN0YXRlLnRhaWw7XG4gICAgICAgICAgcmVuZGVyU3RhdGUucmVuZGVyaW5nID0gbmV4dDtcbiAgICAgICAgICByZW5kZXJTdGF0ZS50YWlsID0gbmV4dC5zaWJsaW5nO1xuICAgICAgICAgIHJlbmRlclN0YXRlLmxhc3RFZmZlY3QgPSB3b3JrSW5Qcm9ncmVzcy5sYXN0RWZmZWN0O1xuICAgICAgICAgIHJlbmRlclN0YXRlLnJlbmRlcmluZ1N0YXJ0VGltZSA9IG5vdygpO1xuICAgICAgICAgIG5leHQuc2libGluZyA9IG51bGw7IC8vIFJlc3RvcmUgdGhlIGNvbnRleHQuXG4gICAgICAgICAgLy8gVE9ETzogV2UgY2FuIHByb2JhYmx5IGp1c3QgYXZvaWQgcG9wcGluZyBpdCBpbnN0ZWFkIGFuZCBvbmx5XG4gICAgICAgICAgLy8gc2V0dGluZyBpdCB0aGUgZmlyc3QgdGltZSB3ZSBnbyBmcm9tIG5vdCBzdXNwZW5kZWQgdG8gc3VzcGVuZGVkLlxuXG4gICAgICAgICAgdmFyIHN1c3BlbnNlQ29udGV4dCA9IHN1c3BlbnNlU3RhY2tDdXJzb3IuY3VycmVudDtcblxuICAgICAgICAgIGlmIChkaWRTdXNwZW5kQWxyZWFkeSkge1xuICAgICAgICAgICAgc3VzcGVuc2VDb250ZXh0ID0gc2V0U2hhbGxvd1N1c3BlbnNlQ29udGV4dChzdXNwZW5zZUNvbnRleHQsIEZvcmNlU3VzcGVuc2VGYWxsYmFjayk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN1c3BlbnNlQ29udGV4dCA9IHNldERlZmF1bHRTaGFsbG93U3VzcGVuc2VDb250ZXh0KHN1c3BlbnNlQ29udGV4dCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcHVzaFN1c3BlbnNlQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgc3VzcGVuc2VDb250ZXh0KTsgLy8gRG8gYSBwYXNzIG92ZXIgdGhlIG5leHQgcm93LlxuXG4gICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgIGNhc2UgRnVuZGFtZW50YWxDb21wb25lbnQ6XG4gICAgICB7XG5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICBjYXNlIFNjb3BlQ29tcG9uZW50OlxuICAgICAge1xuXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgY2FzZSBCbG9jazpcblxuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIE9mZnNjcmVlbkNvbXBvbmVudDpcbiAgICBjYXNlIExlZ2FjeUhpZGRlbkNvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgcG9wUmVuZGVyTGFuZXMod29ya0luUHJvZ3Jlc3MpO1xuXG4gICAgICAgIGlmIChjdXJyZW50ICE9PSBudWxsKSB7XG4gICAgICAgICAgdmFyIF9uZXh0U3RhdGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuICAgICAgICAgIHZhciBfcHJldlN0YXRlID0gY3VycmVudC5tZW1vaXplZFN0YXRlO1xuICAgICAgICAgIHZhciBwcmV2SXNIaWRkZW4gPSBfcHJldlN0YXRlICE9PSBudWxsO1xuICAgICAgICAgIHZhciBuZXh0SXNIaWRkZW4gPSBfbmV4dFN0YXRlICE9PSBudWxsO1xuXG4gICAgICAgICAgaWYgKHByZXZJc0hpZGRlbiAhPT0gbmV4dElzSGlkZGVuICYmIG5ld1Byb3BzLm1vZGUgIT09ICd1bnN0YWJsZS1kZWZlci13aXRob3V0LWhpZGluZycpIHtcbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IFVwZGF0ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgfVxuXG4gIHtcbiAgICB7XG4gICAgICB0aHJvdyBFcnJvciggXCJVbmtub3duIHVuaXQgb2Ygd29yayB0YWcgKFwiICsgd29ya0luUHJvZ3Jlc3MudGFnICsgXCIpLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiICk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHVud2luZFdvcmsod29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKSB7XG4gIHN3aXRjaCAod29ya0luUHJvZ3Jlc3MudGFnKSB7XG4gICAgY2FzZSBDbGFzc0NvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgdmFyIENvbXBvbmVudCA9IHdvcmtJblByb2dyZXNzLnR5cGU7XG5cbiAgICAgICAgaWYgKGlzQ29udGV4dFByb3ZpZGVyKENvbXBvbmVudCkpIHtcbiAgICAgICAgICBwb3BDb250ZXh0KHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBmbGFncyA9IHdvcmtJblByb2dyZXNzLmZsYWdzO1xuXG4gICAgICAgIGlmIChmbGFncyAmIFNob3VsZENhcHR1cmUpIHtcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyA9IGZsYWdzICYgflNob3VsZENhcHR1cmUgfCBEaWRDYXB0dXJlO1xuXG4gICAgICAgICAgaWYgKCAod29ya0luUHJvZ3Jlc3MubW9kZSAmIFByb2ZpbGVNb2RlKSAhPT0gTm9Nb2RlKSB7XG4gICAgICAgICAgICB0cmFuc2ZlckFjdHVhbER1cmF0aW9uKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gd29ya0luUHJvZ3Jlc3M7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgICB7XG4gICAgICAgIHBvcEhvc3RDb250YWluZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICBwb3BUb3BMZXZlbENvbnRleHRPYmplY3Qod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICByZXNldFdvcmtJblByb2dyZXNzVmVyc2lvbnMoKTtcbiAgICAgICAgdmFyIF9mbGFncyA9IHdvcmtJblByb2dyZXNzLmZsYWdzO1xuXG4gICAgICAgIGlmICghKChfZmxhZ3MgJiBEaWRDYXB0dXJlKSA9PT0gTm9GbGFncykpIHtcbiAgICAgICAgICB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvciggXCJUaGUgcm9vdCBmYWlsZWQgdG8gdW5tb3VudCBhZnRlciBhbiBlcnJvci4gVGhpcyBpcyBsaWtlbHkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgPSBfZmxhZ3MgJiB+U2hvdWxkQ2FwdHVyZSB8IERpZENhcHR1cmU7XG4gICAgICAgIHJldHVybiB3b3JrSW5Qcm9ncmVzcztcbiAgICAgIH1cblxuICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgLy8gVE9ETzogcG9wSHlkcmF0aW9uU3RhdGVcbiAgICAgICAgcG9wSG9zdENvbnRleHQod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgIGNhc2UgU3VzcGVuc2VDb21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIHBvcFN1c3BlbnNlQ29udGV4dCh3b3JrSW5Qcm9ncmVzcyk7XG5cbiAgICAgICAgdmFyIF9mbGFnczIgPSB3b3JrSW5Qcm9ncmVzcy5mbGFncztcblxuICAgICAgICBpZiAoX2ZsYWdzMiAmIFNob3VsZENhcHR1cmUpIHtcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyA9IF9mbGFnczIgJiB+U2hvdWxkQ2FwdHVyZSB8IERpZENhcHR1cmU7IC8vIENhcHR1cmVkIGEgc3VzcGVuc2UgZWZmZWN0LiBSZS1yZW5kZXIgdGhlIGJvdW5kYXJ5LlxuXG4gICAgICAgICAgaWYgKCAod29ya0luUHJvZ3Jlc3MubW9kZSAmIFByb2ZpbGVNb2RlKSAhPT0gTm9Nb2RlKSB7XG4gICAgICAgICAgICB0cmFuc2ZlckFjdHVhbER1cmF0aW9uKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gd29ya0luUHJvZ3Jlc3M7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgIGNhc2UgU3VzcGVuc2VMaXN0Q29tcG9uZW50OlxuICAgICAge1xuICAgICAgICBwb3BTdXNwZW5zZUNvbnRleHQod29ya0luUHJvZ3Jlc3MpOyAvLyBTdXNwZW5zZUxpc3QgZG9lc24ndCBhY3R1YWxseSBjYXRjaCBhbnl0aGluZy4gSXQgc2hvdWxkJ3ZlIGJlZW5cbiAgICAgICAgLy8gY2F1Z2h0IGJ5IGEgbmVzdGVkIGJvdW5kYXJ5LiBJZiBub3QsIGl0IHNob3VsZCBidWJibGUgdGhyb3VnaC5cblxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgIGNhc2UgSG9zdFBvcnRhbDpcbiAgICAgIHBvcEhvc3RDb250YWluZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgcmV0dXJuIG51bGw7XG5cbiAgICBjYXNlIENvbnRleHRQcm92aWRlcjpcbiAgICAgIHBvcFByb3ZpZGVyKHdvcmtJblByb2dyZXNzKTtcbiAgICAgIHJldHVybiBudWxsO1xuXG4gICAgY2FzZSBPZmZzY3JlZW5Db21wb25lbnQ6XG4gICAgY2FzZSBMZWdhY3lIaWRkZW5Db21wb25lbnQ6XG4gICAgICBwb3BSZW5kZXJMYW5lcyh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICByZXR1cm4gbnVsbDtcblxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG5mdW5jdGlvbiB1bndpbmRJbnRlcnJ1cHRlZFdvcmsoaW50ZXJydXB0ZWRXb3JrKSB7XG4gIHN3aXRjaCAoaW50ZXJydXB0ZWRXb3JrLnRhZykge1xuICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIHZhciBjaGlsZENvbnRleHRUeXBlcyA9IGludGVycnVwdGVkV29yay50eXBlLmNoaWxkQ29udGV4dFR5cGVzO1xuXG4gICAgICAgIGlmIChjaGlsZENvbnRleHRUeXBlcyAhPT0gbnVsbCAmJiBjaGlsZENvbnRleHRUeXBlcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcG9wQ29udGV4dChpbnRlcnJ1cHRlZFdvcmspO1xuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICBjYXNlIEhvc3RSb290OlxuICAgICAge1xuICAgICAgICBwb3BIb3N0Q29udGFpbmVyKGludGVycnVwdGVkV29yayk7XG4gICAgICAgIHBvcFRvcExldmVsQ29udGV4dE9iamVjdChpbnRlcnJ1cHRlZFdvcmspO1xuICAgICAgICByZXNldFdvcmtJblByb2dyZXNzVmVyc2lvbnMoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIHBvcEhvc3RDb250ZXh0KGludGVycnVwdGVkV29yayk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgY2FzZSBIb3N0UG9ydGFsOlxuICAgICAgcG9wSG9zdENvbnRhaW5lcihpbnRlcnJ1cHRlZFdvcmspO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIFN1c3BlbnNlQ29tcG9uZW50OlxuICAgICAgcG9wU3VzcGVuc2VDb250ZXh0KGludGVycnVwdGVkV29yayk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgU3VzcGVuc2VMaXN0Q29tcG9uZW50OlxuICAgICAgcG9wU3VzcGVuc2VDb250ZXh0KGludGVycnVwdGVkV29yayk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgQ29udGV4dFByb3ZpZGVyOlxuICAgICAgcG9wUHJvdmlkZXIoaW50ZXJydXB0ZWRXb3JrKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBPZmZzY3JlZW5Db21wb25lbnQ6XG4gICAgY2FzZSBMZWdhY3lIaWRkZW5Db21wb25lbnQ6XG4gICAgICBwb3BSZW5kZXJMYW5lcyhpbnRlcnJ1cHRlZFdvcmspO1xuICAgICAgYnJlYWs7XG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlQ2FwdHVyZWRWYWx1ZSh2YWx1ZSwgc291cmNlKSB7XG4gIC8vIElmIHRoZSB2YWx1ZSBpcyBhbiBlcnJvciwgY2FsbCB0aGlzIGZ1bmN0aW9uIGltbWVkaWF0ZWx5IGFmdGVyIGl0IGlzIHRocm93blxuICAvLyBzbyB0aGUgc3RhY2sgaXMgYWNjdXJhdGUuXG4gIHJldHVybiB7XG4gICAgdmFsdWU6IHZhbHVlLFxuICAgIHNvdXJjZTogc291cmNlLFxuICAgIHN0YWNrOiBnZXRTdGFja0J5RmliZXJJbkRldkFuZFByb2Qoc291cmNlKVxuICB9O1xufVxuXG4vLyBUaGlzIG1vZHVsZSBpcyBmb3JrZWQgaW4gZGlmZmVyZW50IGVudmlyb25tZW50cy5cbi8vIEJ5IGRlZmF1bHQsIHJldHVybiBgdHJ1ZWAgdG8gbG9nIGVycm9ycyB0byB0aGUgY29uc29sZS5cbi8vIEZvcmtzIGNhbiByZXR1cm4gYGZhbHNlYCBpZiB0aGlzIGlzbid0IGRlc2lyYWJsZS5cbmZ1bmN0aW9uIHNob3dFcnJvckRpYWxvZyhib3VuZGFyeSwgZXJyb3JJbmZvKSB7XG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBsb2dDYXB0dXJlZEVycm9yKGJvdW5kYXJ5LCBlcnJvckluZm8pIHtcbiAgdHJ5IHtcbiAgICB2YXIgbG9nRXJyb3IgPSBzaG93RXJyb3JEaWFsb2coYm91bmRhcnksIGVycm9ySW5mbyk7IC8vIEFsbG93IGluamVjdGVkIHNob3dFcnJvckRpYWxvZygpIHRvIHByZXZlbnQgZGVmYXVsdCBjb25zb2xlLmVycm9yIGxvZ2dpbmcuXG4gICAgLy8gVGhpcyBlbmFibGVzIHJlbmRlcmVycyBsaWtlIFJlYWN0TmF0aXZlIHRvIGJldHRlciBtYW5hZ2UgcmVkYm94IGJlaGF2aW9yLlxuXG4gICAgaWYgKGxvZ0Vycm9yID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBlcnJvciA9IGVycm9ySW5mby52YWx1ZTtcblxuICAgIGlmICh0cnVlKSB7XG4gICAgICB2YXIgc291cmNlID0gZXJyb3JJbmZvLnNvdXJjZTtcbiAgICAgIHZhciBzdGFjayA9IGVycm9ySW5mby5zdGFjaztcbiAgICAgIHZhciBjb21wb25lbnRTdGFjayA9IHN0YWNrICE9PSBudWxsID8gc3RhY2sgOiAnJzsgLy8gQnJvd3NlcnMgc3VwcG9ydCBzaWxlbmNpbmcgdW5jYXVnaHQgZXJyb3JzIGJ5IGNhbGxpbmdcbiAgICAgIC8vIGBwcmV2ZW50RGVmYXVsdCgpYCBpbiB3aW5kb3cgYGVycm9yYCBoYW5kbGVyLlxuICAgICAgLy8gV2UgcmVjb3JkIHRoaXMgaW5mb3JtYXRpb24gYXMgYW4gZXhwYW5kbyBvbiB0aGUgZXJyb3IuXG5cbiAgICAgIGlmIChlcnJvciAhPSBudWxsICYmIGVycm9yLl9zdXBwcmVzc0xvZ2dpbmcpIHtcbiAgICAgICAgaWYgKGJvdW5kYXJ5LnRhZyA9PT0gQ2xhc3NDb21wb25lbnQpIHtcbiAgICAgICAgICAvLyBUaGUgZXJyb3IgaXMgcmVjb3ZlcmFibGUgYW5kIHdhcyBzaWxlbmNlZC5cbiAgICAgICAgICAvLyBJZ25vcmUgaXQgYW5kIGRvbid0IHByaW50IHRoZSBzdGFjayBhZGRlbmR1bS5cbiAgICAgICAgICAvLyBUaGlzIGlzIGhhbmR5IGZvciB0ZXN0aW5nIGVycm9yIGJvdW5kYXJpZXMgd2l0aG91dCBub2lzZS5cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gLy8gVGhlIGVycm9yIGlzIGZhdGFsLiBTaW5jZSB0aGUgc2lsZW5jaW5nIG1pZ2h0IGhhdmVcbiAgICAgICAgLy8gYmVlbiBhY2NpZGVudGFsLCB3ZSdsbCBzdXJmYWNlIGl0IGFueXdheS5cbiAgICAgICAgLy8gSG93ZXZlciwgdGhlIGJyb3dzZXIgd291bGQgaGF2ZSBzaWxlbmNlZCB0aGUgb3JpZ2luYWwgZXJyb3JcbiAgICAgICAgLy8gc28gd2UnbGwgcHJpbnQgaXQgZmlyc3QsIGFuZCB0aGVuIHByaW50IHRoZSBzdGFjayBhZGRlbmR1bS5cblxuXG4gICAgICAgIGNvbnNvbGVbJ2Vycm9yJ10oZXJyb3IpOyAvLyBEb24ndCB0cmFuc2Zvcm0gdG8gb3VyIHdyYXBwZXJcbiAgICAgICAgLy8gRm9yIGEgbW9yZSBkZXRhaWxlZCBkZXNjcmlwdGlvbiBvZiB0aGlzIGJsb2NrLCBzZWU6XG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9wdWxsLzEzMzg0XG4gICAgICB9XG5cbiAgICAgIHZhciBjb21wb25lbnROYW1lID0gc291cmNlID8gZ2V0Q29tcG9uZW50TmFtZShzb3VyY2UudHlwZSkgOiBudWxsO1xuICAgICAgdmFyIGNvbXBvbmVudE5hbWVNZXNzYWdlID0gY29tcG9uZW50TmFtZSA/IFwiVGhlIGFib3ZlIGVycm9yIG9jY3VycmVkIGluIHRoZSA8XCIgKyBjb21wb25lbnROYW1lICsgXCI+IGNvbXBvbmVudDpcIiA6ICdUaGUgYWJvdmUgZXJyb3Igb2NjdXJyZWQgaW4gb25lIG9mIHlvdXIgUmVhY3QgY29tcG9uZW50czonO1xuICAgICAgdmFyIGVycm9yQm91bmRhcnlNZXNzYWdlO1xuICAgICAgdmFyIGVycm9yQm91bmRhcnlOYW1lID0gZ2V0Q29tcG9uZW50TmFtZShib3VuZGFyeS50eXBlKTtcblxuICAgICAgaWYgKGVycm9yQm91bmRhcnlOYW1lKSB7XG4gICAgICAgIGVycm9yQm91bmRhcnlNZXNzYWdlID0gXCJSZWFjdCB3aWxsIHRyeSB0byByZWNyZWF0ZSB0aGlzIGNvbXBvbmVudCB0cmVlIGZyb20gc2NyYXRjaCBcIiArIChcInVzaW5nIHRoZSBlcnJvciBib3VuZGFyeSB5b3UgcHJvdmlkZWQsIFwiICsgZXJyb3JCb3VuZGFyeU5hbWUgKyBcIi5cIik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlcnJvckJvdW5kYXJ5TWVzc2FnZSA9ICdDb25zaWRlciBhZGRpbmcgYW4gZXJyb3IgYm91bmRhcnkgdG8geW91ciB0cmVlIHRvIGN1c3RvbWl6ZSBlcnJvciBoYW5kbGluZyBiZWhhdmlvci5cXG4nICsgJ1Zpc2l0IGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9lcnJvci1ib3VuZGFyaWVzIHRvIGxlYXJuIG1vcmUgYWJvdXQgZXJyb3IgYm91bmRhcmllcy4nO1xuICAgICAgfVxuXG4gICAgICB2YXIgY29tYmluZWRNZXNzYWdlID0gY29tcG9uZW50TmFtZU1lc3NhZ2UgKyBcIlxcblwiICsgY29tcG9uZW50U3RhY2sgKyBcIlxcblxcblwiICsgKFwiXCIgKyBlcnJvckJvdW5kYXJ5TWVzc2FnZSk7IC8vIEluIGRldmVsb3BtZW50LCB3ZSBwcm92aWRlIG91ciBvd24gbWVzc2FnZSB3aXRoIGp1c3QgdGhlIGNvbXBvbmVudCBzdGFjay5cbiAgICAgIC8vIFdlIGRvbid0IGluY2x1ZGUgdGhlIG9yaWdpbmFsIGVycm9yIG1lc3NhZ2UgYW5kIEpTIHN0YWNrIGJlY2F1c2UgdGhlIGJyb3dzZXJcbiAgICAgIC8vIGhhcyBhbHJlYWR5IHByaW50ZWQgaXQuIEV2ZW4gaWYgdGhlIGFwcGxpY2F0aW9uIHN3YWxsb3dzIHRoZSBlcnJvciwgaXQgaXMgc3RpbGxcbiAgICAgIC8vIGRpc3BsYXllZCBieSB0aGUgYnJvd3NlciB0aGFua3MgdG8gdGhlIERFVi1vbmx5IGZha2UgZXZlbnQgdHJpY2sgaW4gUmVhY3RFcnJvclV0aWxzLlxuXG4gICAgICBjb25zb2xlWydlcnJvciddKGNvbWJpbmVkTWVzc2FnZSk7IC8vIERvbid0IHRyYW5zZm9ybSB0byBvdXIgd3JhcHBlclxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBJbiBwcm9kdWN0aW9uLCB3ZSBwcmludCB0aGUgZXJyb3IgZGlyZWN0bHkuXG4gICAgICAvLyBUaGlzIHdpbGwgaW5jbHVkZSB0aGUgbWVzc2FnZSwgdGhlIEpTIHN0YWNrLCBhbmQgYW55dGhpbmcgdGhlIGJyb3dzZXIgd2FudHMgdG8gc2hvdy5cbiAgICAgIC8vIFdlIHBhc3MgdGhlIGVycm9yIG9iamVjdCBpbnN0ZWFkIG9mIGN1c3RvbSBtZXNzYWdlIHNvIHRoYXQgdGhlIGJyb3dzZXIgZGlzcGxheXMgdGhlIGVycm9yIG5hdGl2ZWx5LlxuICAgICAgY29uc29sZVsnZXJyb3InXShlcnJvcik7IC8vIERvbid0IHRyYW5zZm9ybSB0byBvdXIgd3JhcHBlclxuICAgIH1cbiAgfSBjYXRjaCAoZSkge1xuICAgIC8vIFRoaXMgbWV0aG9kIG11c3Qgbm90IHRocm93LCBvciBSZWFjdCBpbnRlcm5hbCBzdGF0ZSB3aWxsIGdldCBtZXNzZWQgdXAuXG4gICAgLy8gSWYgY29uc29sZS5lcnJvciBpcyBvdmVycmlkZGVuLCBvciBsb2dDYXB0dXJlZEVycm9yKCkgc2hvd3MgYSBkaWFsb2cgdGhhdCB0aHJvd3MsXG4gICAgLy8gd2Ugd2FudCB0byByZXBvcnQgdGhpcyBlcnJvciBvdXRzaWRlIG9mIHRoZSBub3JtYWwgc3RhY2sgYXMgYSBsYXN0IHJlc29ydC5cbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzEzMTg4XG4gICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICB0aHJvdyBlO1xuICAgIH0pO1xuICB9XG59XG5cbnZhciBQb3NzaWJseVdlYWtNYXAkMSA9IHR5cGVvZiBXZWFrTWFwID09PSAnZnVuY3Rpb24nID8gV2Vha01hcCA6IE1hcDtcblxuZnVuY3Rpb24gY3JlYXRlUm9vdEVycm9yVXBkYXRlKGZpYmVyLCBlcnJvckluZm8sIGxhbmUpIHtcbiAgdmFyIHVwZGF0ZSA9IGNyZWF0ZVVwZGF0ZShOb1RpbWVzdGFtcCwgbGFuZSk7IC8vIFVubW91bnQgdGhlIHJvb3QgYnkgcmVuZGVyaW5nIG51bGwuXG5cbiAgdXBkYXRlLnRhZyA9IENhcHR1cmVVcGRhdGU7IC8vIENhdXRpb246IFJlYWN0IERldlRvb2xzIGN1cnJlbnRseSBkZXBlbmRzIG9uIHRoaXMgcHJvcGVydHlcbiAgLy8gYmVpbmcgY2FsbGVkIFwiZWxlbWVudFwiLlxuXG4gIHVwZGF0ZS5wYXlsb2FkID0ge1xuICAgIGVsZW1lbnQ6IG51bGxcbiAgfTtcbiAgdmFyIGVycm9yID0gZXJyb3JJbmZvLnZhbHVlO1xuXG4gIHVwZGF0ZS5jYWxsYmFjayA9IGZ1bmN0aW9uICgpIHtcbiAgICBvblVuY2F1Z2h0RXJyb3IoZXJyb3IpO1xuICAgIGxvZ0NhcHR1cmVkRXJyb3IoZmliZXIsIGVycm9ySW5mbyk7XG4gIH07XG5cbiAgcmV0dXJuIHVwZGF0ZTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlQ2xhc3NFcnJvclVwZGF0ZShmaWJlciwgZXJyb3JJbmZvLCBsYW5lKSB7XG4gIHZhciB1cGRhdGUgPSBjcmVhdGVVcGRhdGUoTm9UaW1lc3RhbXAsIGxhbmUpO1xuICB1cGRhdGUudGFnID0gQ2FwdHVyZVVwZGF0ZTtcbiAgdmFyIGdldERlcml2ZWRTdGF0ZUZyb21FcnJvciA9IGZpYmVyLnR5cGUuZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yO1xuXG4gIGlmICh0eXBlb2YgZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdmFyIGVycm9yJDEgPSBlcnJvckluZm8udmFsdWU7XG5cbiAgICB1cGRhdGUucGF5bG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGxvZ0NhcHR1cmVkRXJyb3IoZmliZXIsIGVycm9ySW5mbyk7XG4gICAgICByZXR1cm4gZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yKGVycm9yJDEpO1xuICAgIH07XG4gIH1cblxuICB2YXIgaW5zdCA9IGZpYmVyLnN0YXRlTm9kZTtcblxuICBpZiAoaW5zdCAhPT0gbnVsbCAmJiB0eXBlb2YgaW5zdC5jb21wb25lbnREaWRDYXRjaCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHVwZGF0ZS5jYWxsYmFjayA9IGZ1bmN0aW9uIGNhbGxiYWNrKCkge1xuICAgICAge1xuICAgICAgICBtYXJrRmFpbGVkRXJyb3JCb3VuZGFyeUZvckhvdFJlbG9hZGluZyhmaWJlcik7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIFRvIHByZXNlcnZlIHRoZSBwcmVleGlzdGluZyByZXRyeSBiZWhhdmlvciBvZiBlcnJvciBib3VuZGFyaWVzLFxuICAgICAgICAvLyB3ZSBrZWVwIHRyYWNrIG9mIHdoaWNoIG9uZXMgYWxyZWFkeSBmYWlsZWQgZHVyaW5nIHRoaXMgYmF0Y2guXG4gICAgICAgIC8vIFRoaXMgZ2V0cyByZXNldCBiZWZvcmUgd2UgeWllbGQgYmFjayB0byB0aGUgYnJvd3Nlci5cbiAgICAgICAgLy8gVE9ETzogV2FybiBpbiBzdHJpY3QgbW9kZSBpZiBnZXREZXJpdmVkU3RhdGVGcm9tRXJyb3IgaXNcbiAgICAgICAgLy8gbm90IGRlZmluZWQuXG4gICAgICAgIG1hcmtMZWdhY3lFcnJvckJvdW5kYXJ5QXNGYWlsZWQodGhpcyk7IC8vIE9ubHkgbG9nIGhlcmUgaWYgY29tcG9uZW50RGlkQ2F0Y2ggaXMgdGhlIG9ubHkgZXJyb3IgYm91bmRhcnkgbWV0aG9kIGRlZmluZWRcblxuICAgICAgICBsb2dDYXB0dXJlZEVycm9yKGZpYmVyLCBlcnJvckluZm8pO1xuICAgICAgfVxuXG4gICAgICB2YXIgZXJyb3IkMSA9IGVycm9ySW5mby52YWx1ZTtcbiAgICAgIHZhciBzdGFjayA9IGVycm9ySW5mby5zdGFjaztcbiAgICAgIHRoaXMuY29tcG9uZW50RGlkQ2F0Y2goZXJyb3IkMSwge1xuICAgICAgICBjb21wb25lbnRTdGFjazogc3RhY2sgIT09IG51bGwgPyBzdGFjayA6ICcnXG4gICAgICB9KTtcblxuICAgICAge1xuICAgICAgICBpZiAodHlwZW9mIGdldERlcml2ZWRTdGF0ZUZyb21FcnJvciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIC8vIElmIGNvbXBvbmVudERpZENhdGNoIGlzIHRoZSBvbmx5IGVycm9yIGJvdW5kYXJ5IG1ldGhvZCBkZWZpbmVkLFxuICAgICAgICAgIC8vIHRoZW4gaXQgbmVlZHMgdG8gY2FsbCBzZXRTdGF0ZSB0byByZWNvdmVyIGZyb20gZXJyb3JzLlxuICAgICAgICAgIC8vIElmIG5vIHN0YXRlIHVwZGF0ZSBpcyBzY2hlZHVsZWQgdGhlbiB0aGUgYm91bmRhcnkgd2lsbCBzd2FsbG93IHRoZSBlcnJvci5cbiAgICAgICAgICBpZiAoIWluY2x1ZGVzU29tZUxhbmUoZmliZXIubGFuZXMsIFN5bmNMYW5lKSkge1xuICAgICAgICAgICAgZXJyb3IoJyVzOiBFcnJvciBib3VuZGFyaWVzIHNob3VsZCBpbXBsZW1lbnQgZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yKCkuICcgKyAnSW4gdGhhdCBtZXRob2QsIHJldHVybiBhIHN0YXRlIHVwZGF0ZSB0byBkaXNwbGF5IGFuIGVycm9yIG1lc3NhZ2Ugb3IgZmFsbGJhY2sgVUkuJywgZ2V0Q29tcG9uZW50TmFtZShmaWJlci50eXBlKSB8fCAnVW5rbm93bicpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgdXBkYXRlLmNhbGxiYWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgbWFya0ZhaWxlZEVycm9yQm91bmRhcnlGb3JIb3RSZWxvYWRpbmcoZmliZXIpO1xuICAgIH07XG4gIH1cblxuICByZXR1cm4gdXBkYXRlO1xufVxuXG5mdW5jdGlvbiBhdHRhY2hQaW5nTGlzdGVuZXIocm9vdCwgd2FrZWFibGUsIGxhbmVzKSB7XG4gIC8vIEF0dGFjaCBhIGxpc3RlbmVyIHRvIHRoZSBwcm9taXNlIHRvIFwicGluZ1wiIHRoZSByb290IGFuZCByZXRyeS4gQnV0IG9ubHkgaWZcbiAgLy8gb25lIGRvZXMgbm90IGFscmVhZHkgZXhpc3QgZm9yIHRoZSBsYW5lcyB3ZSdyZSBjdXJyZW50bHkgcmVuZGVyaW5nICh3aGljaFxuICAvLyBhY3RzIGxpa2UgYSBcInRocmVhZCBJRFwiIGhlcmUpLlxuICB2YXIgcGluZ0NhY2hlID0gcm9vdC5waW5nQ2FjaGU7XG4gIHZhciB0aHJlYWRJRHM7XG5cbiAgaWYgKHBpbmdDYWNoZSA9PT0gbnVsbCkge1xuICAgIHBpbmdDYWNoZSA9IHJvb3QucGluZ0NhY2hlID0gbmV3IFBvc3NpYmx5V2Vha01hcCQxKCk7XG4gICAgdGhyZWFkSURzID0gbmV3IFNldCgpO1xuICAgIHBpbmdDYWNoZS5zZXQod2FrZWFibGUsIHRocmVhZElEcyk7XG4gIH0gZWxzZSB7XG4gICAgdGhyZWFkSURzID0gcGluZ0NhY2hlLmdldCh3YWtlYWJsZSk7XG5cbiAgICBpZiAodGhyZWFkSURzID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocmVhZElEcyA9IG5ldyBTZXQoKTtcbiAgICAgIHBpbmdDYWNoZS5zZXQod2FrZWFibGUsIHRocmVhZElEcyk7XG4gICAgfVxuICB9XG5cbiAgaWYgKCF0aHJlYWRJRHMuaGFzKGxhbmVzKSkge1xuICAgIC8vIE1lbW9pemUgdXNpbmcgdGhlIHRocmVhZCBJRCB0byBwcmV2ZW50IHJlZHVuZGFudCBsaXN0ZW5lcnMuXG4gICAgdGhyZWFkSURzLmFkZChsYW5lcyk7XG4gICAgdmFyIHBpbmcgPSBwaW5nU3VzcGVuZGVkUm9vdC5iaW5kKG51bGwsIHJvb3QsIHdha2VhYmxlLCBsYW5lcyk7XG4gICAgd2FrZWFibGUudGhlbihwaW5nLCBwaW5nKTtcbiAgfVxufVxuXG5mdW5jdGlvbiB0aHJvd0V4Y2VwdGlvbihyb290LCByZXR1cm5GaWJlciwgc291cmNlRmliZXIsIHZhbHVlLCByb290UmVuZGVyTGFuZXMpIHtcbiAgLy8gVGhlIHNvdXJjZSBmaWJlciBkaWQgbm90IGNvbXBsZXRlLlxuICBzb3VyY2VGaWJlci5mbGFncyB8PSBJbmNvbXBsZXRlOyAvLyBJdHMgZWZmZWN0IGxpc3QgaXMgbm8gbG9uZ2VyIHZhbGlkLlxuXG4gIHNvdXJjZUZpYmVyLmZpcnN0RWZmZWN0ID0gc291cmNlRmliZXIubGFzdEVmZmVjdCA9IG51bGw7XG5cbiAgaWYgKHZhbHVlICE9PSBudWxsICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIHZhbHVlLnRoZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAvLyBUaGlzIGlzIGEgd2FrZWFibGUuXG4gICAgdmFyIHdha2VhYmxlID0gdmFsdWU7XG5cbiAgICBpZiAoKHNvdXJjZUZpYmVyLm1vZGUgJiBCbG9ja2luZ01vZGUpID09PSBOb01vZGUpIHtcbiAgICAgIC8vIFJlc2V0IHRoZSBtZW1vaXplZFN0YXRlIHRvIHdoYXQgaXQgd2FzIGJlZm9yZSB3ZSBhdHRlbXB0ZWRcbiAgICAgIC8vIHRvIHJlbmRlciBpdC5cbiAgICAgIHZhciBjdXJyZW50U291cmNlID0gc291cmNlRmliZXIuYWx0ZXJuYXRlO1xuXG4gICAgICBpZiAoY3VycmVudFNvdXJjZSkge1xuICAgICAgICBzb3VyY2VGaWJlci51cGRhdGVRdWV1ZSA9IGN1cnJlbnRTb3VyY2UudXBkYXRlUXVldWU7XG4gICAgICAgIHNvdXJjZUZpYmVyLm1lbW9pemVkU3RhdGUgPSBjdXJyZW50U291cmNlLm1lbW9pemVkU3RhdGU7XG4gICAgICAgIHNvdXJjZUZpYmVyLmxhbmVzID0gY3VycmVudFNvdXJjZS5sYW5lcztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNvdXJjZUZpYmVyLnVwZGF0ZVF1ZXVlID0gbnVsbDtcbiAgICAgICAgc291cmNlRmliZXIubWVtb2l6ZWRTdGF0ZSA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGhhc0ludmlzaWJsZVBhcmVudEJvdW5kYXJ5ID0gaGFzU3VzcGVuc2VDb250ZXh0KHN1c3BlbnNlU3RhY2tDdXJzb3IuY3VycmVudCwgSW52aXNpYmxlUGFyZW50U3VzcGVuc2VDb250ZXh0KTsgLy8gU2NoZWR1bGUgdGhlIG5lYXJlc3QgU3VzcGVuc2UgdG8gcmUtcmVuZGVyIHRoZSB0aW1lZCBvdXQgdmlldy5cblxuICAgIHZhciBfd29ya0luUHJvZ3Jlc3MgPSByZXR1cm5GaWJlcjtcblxuICAgIGRvIHtcbiAgICAgIGlmIChfd29ya0luUHJvZ3Jlc3MudGFnID09PSBTdXNwZW5zZUNvbXBvbmVudCAmJiBzaG91bGRDYXB0dXJlU3VzcGVuc2UoX3dvcmtJblByb2dyZXNzLCBoYXNJbnZpc2libGVQYXJlbnRCb3VuZGFyeSkpIHtcbiAgICAgICAgLy8gRm91bmQgdGhlIG5lYXJlc3QgYm91bmRhcnkuXG4gICAgICAgIC8vIFN0YXNoIHRoZSBwcm9taXNlIG9uIHRoZSBib3VuZGFyeSBmaWJlci4gSWYgdGhlIGJvdW5kYXJ5IHRpbWVzIG91dCwgd2UnbGxcbiAgICAgICAgLy8gYXR0YWNoIGFub3RoZXIgbGlzdGVuZXIgdG8gZmxpcCB0aGUgYm91bmRhcnkgYmFjayB0byBpdHMgbm9ybWFsIHN0YXRlLlxuICAgICAgICB2YXIgd2FrZWFibGVzID0gX3dvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlO1xuXG4gICAgICAgIGlmICh3YWtlYWJsZXMgPT09IG51bGwpIHtcbiAgICAgICAgICB2YXIgdXBkYXRlUXVldWUgPSBuZXcgU2V0KCk7XG4gICAgICAgICAgdXBkYXRlUXVldWUuYWRkKHdha2VhYmxlKTtcbiAgICAgICAgICBfd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWUgPSB1cGRhdGVRdWV1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB3YWtlYWJsZXMuYWRkKHdha2VhYmxlKTtcbiAgICAgICAgfSAvLyBJZiB0aGUgYm91bmRhcnkgaXMgb3V0c2lkZSBvZiBibG9ja2luZyBtb2RlLCB3ZSBzaG91bGQgKm5vdCpcbiAgICAgICAgLy8gc3VzcGVuZCB0aGUgY29tbWl0LiBQcmV0ZW5kIGFzIGlmIHRoZSBzdXNwZW5kZWQgY29tcG9uZW50IHJlbmRlcmVkXG4gICAgICAgIC8vIG51bGwgYW5kIGtlZXAgcmVuZGVyaW5nLiBJbiB0aGUgY29tbWl0IHBoYXNlLCB3ZSdsbCBzY2hlZHVsZSBhXG4gICAgICAgIC8vIHN1YnNlcXVlbnQgc3luY2hyb25vdXMgdXBkYXRlIHRvIHJlLXJlbmRlciB0aGUgU3VzcGVuc2UuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIE5vdGU6IEl0IGRvZXNuJ3QgbWF0dGVyIHdoZXRoZXIgdGhlIGNvbXBvbmVudCB0aGF0IHN1c3BlbmRlZCB3YXNcbiAgICAgICAgLy8gaW5zaWRlIGEgYmxvY2tpbmcgbW9kZSB0cmVlLiBJZiB0aGUgU3VzcGVuc2UgaXMgb3V0c2lkZSBvZiBpdCwgd2VcbiAgICAgICAgLy8gc2hvdWxkICpub3QqIHN1c3BlbmQgdGhlIGNvbW1pdC5cblxuXG4gICAgICAgIGlmICgoX3dvcmtJblByb2dyZXNzLm1vZGUgJiBCbG9ja2luZ01vZGUpID09PSBOb01vZGUpIHtcbiAgICAgICAgICBfd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gRGlkQ2FwdHVyZTtcbiAgICAgICAgICBzb3VyY2VGaWJlci5mbGFncyB8PSBGb3JjZVVwZGF0ZUZvckxlZ2FjeVN1c3BlbnNlOyAvLyBXZSdyZSBnb2luZyB0byBjb21taXQgdGhpcyBmaWJlciBldmVuIHRob3VnaCBpdCBkaWRuJ3QgY29tcGxldGUuXG4gICAgICAgICAgLy8gQnV0IHdlIHNob3VsZG4ndCBjYWxsIGFueSBsaWZlY3ljbGUgbWV0aG9kcyBvciBjYWxsYmFja3MuIFJlbW92ZVxuICAgICAgICAgIC8vIGFsbCBsaWZlY3ljbGUgZWZmZWN0IHRhZ3MuXG5cbiAgICAgICAgICBzb3VyY2VGaWJlci5mbGFncyAmPSB+KExpZmVjeWNsZUVmZmVjdE1hc2sgfCBJbmNvbXBsZXRlKTtcblxuICAgICAgICAgIGlmIChzb3VyY2VGaWJlci50YWcgPT09IENsYXNzQ29tcG9uZW50KSB7XG4gICAgICAgICAgICB2YXIgY3VycmVudFNvdXJjZUZpYmVyID0gc291cmNlRmliZXIuYWx0ZXJuYXRlO1xuXG4gICAgICAgICAgICBpZiAoY3VycmVudFNvdXJjZUZpYmVyID09PSBudWxsKSB7XG4gICAgICAgICAgICAgIC8vIFRoaXMgaXMgYSBuZXcgbW91bnQuIENoYW5nZSB0aGUgdGFnIHNvIGl0J3Mgbm90IG1pc3Rha2VuIGZvciBhXG4gICAgICAgICAgICAgIC8vIGNvbXBsZXRlZCBjbGFzcyBjb21wb25lbnQuIEZvciBleGFtcGxlLCB3ZSBzaG91bGQgbm90IGNhbGxcbiAgICAgICAgICAgICAgLy8gY29tcG9uZW50V2lsbFVubW91bnQgaWYgaXQgaXMgZGVsZXRlZC5cbiAgICAgICAgICAgICAgc291cmNlRmliZXIudGFnID0gSW5jb21wbGV0ZUNsYXNzQ29tcG9uZW50O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gV2hlbiB3ZSB0cnkgcmVuZGVyaW5nIGFnYWluLCB3ZSBzaG91bGQgbm90IHJldXNlIHRoZSBjdXJyZW50IGZpYmVyLFxuICAgICAgICAgICAgICAvLyBzaW5jZSBpdCdzIGtub3duIHRvIGJlIGluIGFuIGluY29uc2lzdGVudCBzdGF0ZS4gVXNlIGEgZm9yY2UgdXBkYXRlIHRvXG4gICAgICAgICAgICAgIC8vIHByZXZlbnQgYSBiYWlsIG91dC5cbiAgICAgICAgICAgICAgdmFyIHVwZGF0ZSA9IGNyZWF0ZVVwZGF0ZShOb1RpbWVzdGFtcCwgU3luY0xhbmUpO1xuICAgICAgICAgICAgICB1cGRhdGUudGFnID0gRm9yY2VVcGRhdGU7XG4gICAgICAgICAgICAgIGVucXVldWVVcGRhdGUoc291cmNlRmliZXIsIHVwZGF0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSAvLyBUaGUgc291cmNlIGZpYmVyIGRpZCBub3QgY29tcGxldGUuIE1hcmsgaXQgd2l0aCBTeW5jIHByaW9yaXR5IHRvXG4gICAgICAgICAgLy8gaW5kaWNhdGUgdGhhdCBpdCBzdGlsbCBoYXMgcGVuZGluZyB3b3JrLlxuXG5cbiAgICAgICAgICBzb3VyY2VGaWJlci5sYW5lcyA9IG1lcmdlTGFuZXMoc291cmNlRmliZXIubGFuZXMsIFN5bmNMYW5lKTsgLy8gRXhpdCB3aXRob3V0IHN1c3BlbmRpbmcuXG5cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gLy8gQ29uZmlybWVkIHRoYXQgdGhlIGJvdW5kYXJ5IGlzIGluIGEgY29uY3VycmVudCBtb2RlIHRyZWUuIENvbnRpbnVlXG4gICAgICAgIC8vIHdpdGggdGhlIG5vcm1hbCBzdXNwZW5kIHBhdGguXG4gICAgICAgIC8vXG4gICAgICAgIC8vIEFmdGVyIHRoaXMgd2UnbGwgdXNlIGEgc2V0IG9mIGhldXJpc3RpY3MgdG8gZGV0ZXJtaW5lIHdoZXRoZXIgdGhpc1xuICAgICAgICAvLyByZW5kZXIgcGFzcyB3aWxsIHJ1biB0byBjb21wbGV0aW9uIG9yIHJlc3RhcnQgb3IgXCJzdXNwZW5kXCIgdGhlIGNvbW1pdC5cbiAgICAgICAgLy8gVGhlIGFjdHVhbCBsb2dpYyBmb3IgdGhpcyBpcyBzcHJlYWQgb3V0IGluIGRpZmZlcmVudCBwbGFjZXMuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIFRoaXMgZmlyc3QgcHJpbmNpcGxlIGlzIHRoYXQgaWYgd2UncmUgZ29pbmcgdG8gc3VzcGVuZCB3aGVuIHdlIGNvbXBsZXRlXG4gICAgICAgIC8vIGEgcm9vdCwgdGhlbiB3ZSBzaG91bGQgYWxzbyByZXN0YXJ0IGlmIHdlIGdldCBhbiB1cGRhdGUgb3IgcGluZyB0aGF0XG4gICAgICAgIC8vIG1pZ2h0IHVuc3VzcGVuZCBpdCwgYW5kIHZpY2UgdmVyc2EuIFRoZSBvbmx5IHJlYXNvbiB0byBzdXNwZW5kIGlzXG4gICAgICAgIC8vIGJlY2F1c2UgeW91IHRoaW5rIHlvdSBtaWdodCB3YW50IHRvIHJlc3RhcnQgYmVmb3JlIGNvbW1pdHRpbmcuIEhvd2V2ZXIsXG4gICAgICAgIC8vIGl0IGRvZXNuJ3QgbWFrZSBzZW5zZSB0byByZXN0YXJ0IG9ubHkgd2hpbGUgaW4gdGhlIHBlcmlvZCB3ZSdyZSBzdXNwZW5kZWQuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIFJlc3RhcnRpbmcgdG9vIGFnZ3Jlc3NpdmVseSBpcyBhbHNvIG5vdCBnb29kIGJlY2F1c2UgaXQgc3RhcnZlcyBvdXQgYW55XG4gICAgICAgIC8vIGludGVybWVkaWF0ZSBsb2FkaW5nIHN0YXRlLiBTbyB3ZSB1c2UgaGV1cmlzdGljcyB0byBkZXRlcm1pbmUgd2hlbi5cbiAgICAgICAgLy8gU3VzcGVuc2UgSGV1cmlzdGljc1xuICAgICAgICAvL1xuICAgICAgICAvLyBJZiBub3RoaW5nIHRocmV3IGEgUHJvbWlzZSBvciBhbGwgdGhlIHNhbWUgZmFsbGJhY2tzIGFyZSBhbHJlYWR5IHNob3dpbmcsXG4gICAgICAgIC8vIHRoZW4gZG9uJ3Qgc3VzcGVuZC9yZXN0YXJ0LlxuICAgICAgICAvL1xuICAgICAgICAvLyBJZiB0aGlzIGlzIGFuIGluaXRpYWwgcmVuZGVyIG9mIGEgbmV3IHRyZWUgb2YgU3VzcGVuc2UgYm91bmRhcmllcyBhbmRcbiAgICAgICAgLy8gdGhvc2UgdHJpZ2dlciBhIGZhbGxiYWNrLCB0aGVuIGRvbid0IHN1c3BlbmQvcmVzdGFydC4gV2Ugd2FudCB0byBlbnN1cmVcbiAgICAgICAgLy8gdGhhdCB3ZSBjYW4gc2hvdyB0aGUgaW5pdGlhbCBsb2FkaW5nIHN0YXRlIGFzIHF1aWNrbHkgYXMgcG9zc2libGUuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIElmIHdlIGhpdCBhIFwiRGVsYXllZFwiIGNhc2UsIHN1Y2ggYXMgd2hlbiB3ZSdkIHN3aXRjaCBmcm9tIGNvbnRlbnQgYmFjayBpbnRvXG4gICAgICAgIC8vIGEgZmFsbGJhY2ssIHRoZW4gd2Ugc2hvdWxkIGFsd2F5cyBzdXNwZW5kL3Jlc3RhcnQuIFRyYW5zaXRpb25zIGFwcGx5XG4gICAgICAgIC8vIHRvIHRoaXMgY2FzZS4gSWYgbm9uZSBpcyBkZWZpbmVkLCBKTkQgaXMgdXNlZCBpbnN0ZWFkLlxuICAgICAgICAvL1xuICAgICAgICAvLyBJZiB3ZSdyZSBhbHJlYWR5IHNob3dpbmcgYSBmYWxsYmFjayBhbmQgaXQgZ2V0cyBcInJldHJpZWRcIiwgYWxsb3dpbmcgdXMgdG8gc2hvd1xuICAgICAgICAvLyBhbm90aGVyIGxldmVsLCBidXQgdGhlcmUncyBzdGlsbCBhbiBpbm5lciBib3VuZGFyeSB0aGF0IHdvdWxkIHNob3cgYSBmYWxsYmFjayxcbiAgICAgICAgLy8gdGhlbiB3ZSBzdXNwZW5kL3Jlc3RhcnQgZm9yIDUwMG1zIHNpbmNlIHRoZSBsYXN0IHRpbWUgd2Ugc2hvd2VkIGEgZmFsbGJhY2tcbiAgICAgICAgLy8gYW55d2hlcmUgaW4gdGhlIHRyZWUuIFRoaXMgZWZmZWN0aXZlbHkgdGhyb3R0bGVzIHByb2dyZXNzaXZlIGxvYWRpbmcgaW50byBhXG4gICAgICAgIC8vIGNvbnNpc3RlbnQgdHJhaW4gb2YgY29tbWl0cy4gVGhpcyBhbHNvIGdpdmVzIHVzIGFuIG9wcG9ydHVuaXR5IHRvIHJlc3RhcnQgdG9cbiAgICAgICAgLy8gZ2V0IHRvIHRoZSBjb21wbGV0ZWQgc3RhdGUgc2xpZ2h0bHkgZWFybGllci5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gSWYgdGhlcmUncyBhbWJpZ3VpdHkgZHVlIHRvIGJhdGNoaW5nIGl0J3MgcmVzb2x2ZWQgaW4gcHJlZmVyZW5jZSBvZjpcbiAgICAgICAgLy8gMSkgXCJkZWxheWVkXCIsIDIpIFwiaW5pdGlhbCByZW5kZXJcIiwgMykgXCJyZXRyeVwiLlxuICAgICAgICAvL1xuICAgICAgICAvLyBXZSB3YW50IHRvIGVuc3VyZSB0aGF0IGEgXCJidXN5XCIgc3RhdGUgZG9lc24ndCBnZXQgZm9yY2UgY29tbWl0dGVkLiBXZSB3YW50IHRvXG4gICAgICAgIC8vIGVuc3VyZSB0aGF0IG5ldyBpbml0aWFsIGxvYWRpbmcgc3RhdGVzIGNhbiBjb21taXQgYXMgc29vbiBhcyBwb3NzaWJsZS5cblxuXG4gICAgICAgIGF0dGFjaFBpbmdMaXN0ZW5lcihyb290LCB3YWtlYWJsZSwgcm9vdFJlbmRlckxhbmVzKTtcbiAgICAgICAgX3dvcmtJblByb2dyZXNzLmZsYWdzIHw9IFNob3VsZENhcHR1cmU7XG4gICAgICAgIF93b3JrSW5Qcm9ncmVzcy5sYW5lcyA9IHJvb3RSZW5kZXJMYW5lcztcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSAvLyBUaGlzIGJvdW5kYXJ5IGFscmVhZHkgY2FwdHVyZWQgZHVyaW5nIHRoaXMgcmVuZGVyLiBDb250aW51ZSB0byB0aGUgbmV4dFxuICAgICAgLy8gYm91bmRhcnkuXG5cblxuICAgICAgX3dvcmtJblByb2dyZXNzID0gX3dvcmtJblByb2dyZXNzLnJldHVybjtcbiAgICB9IHdoaWxlIChfd29ya0luUHJvZ3Jlc3MgIT09IG51bGwpOyAvLyBObyBib3VuZGFyeSB3YXMgZm91bmQuIEZhbGx0aHJvdWdoIHRvIGVycm9yIG1vZGUuXG4gICAgLy8gVE9ETzogVXNlIGludmFyaWFudCBzbyB0aGUgbWVzc2FnZSBpcyBzdHJpcHBlZCBpbiBwcm9kP1xuXG5cbiAgICB2YWx1ZSA9IG5ldyBFcnJvcigoZ2V0Q29tcG9uZW50TmFtZShzb3VyY2VGaWJlci50eXBlKSB8fCAnQSBSZWFjdCBjb21wb25lbnQnKSArICcgc3VzcGVuZGVkIHdoaWxlIHJlbmRlcmluZywgYnV0IG5vIGZhbGxiYWNrIFVJIHdhcyBzcGVjaWZpZWQuXFxuJyArICdcXG4nICsgJ0FkZCBhIDxTdXNwZW5zZSBmYWxsYmFjaz0uLi4+IGNvbXBvbmVudCBoaWdoZXIgaW4gdGhlIHRyZWUgdG8gJyArICdwcm92aWRlIGEgbG9hZGluZyBpbmRpY2F0b3Igb3IgcGxhY2Vob2xkZXIgdG8gZGlzcGxheS4nKTtcbiAgfSAvLyBXZSBkaWRuJ3QgZmluZCBhIGJvdW5kYXJ5IHRoYXQgY291bGQgaGFuZGxlIHRoaXMgdHlwZSBvZiBleGNlcHRpb24uIFN0YXJ0XG4gIC8vIG92ZXIgYW5kIHRyYXZlcnNlIHBhcmVudCBwYXRoIGFnYWluLCB0aGlzIHRpbWUgdHJlYXRpbmcgdGhlIGV4Y2VwdGlvblxuICAvLyBhcyBhbiBlcnJvci5cblxuXG4gIHJlbmRlckRpZEVycm9yKCk7XG4gIHZhbHVlID0gY3JlYXRlQ2FwdHVyZWRWYWx1ZSh2YWx1ZSwgc291cmNlRmliZXIpO1xuICB2YXIgd29ya0luUHJvZ3Jlc3MgPSByZXR1cm5GaWJlcjtcblxuICBkbyB7XG4gICAgc3dpdGNoICh3b3JrSW5Qcm9ncmVzcy50YWcpIHtcbiAgICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgX2Vycm9ySW5mbyA9IHZhbHVlO1xuICAgICAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IFNob3VsZENhcHR1cmU7XG4gICAgICAgICAgdmFyIGxhbmUgPSBwaWNrQXJiaXRyYXJ5TGFuZShyb290UmVuZGVyTGFuZXMpO1xuICAgICAgICAgIHdvcmtJblByb2dyZXNzLmxhbmVzID0gbWVyZ2VMYW5lcyh3b3JrSW5Qcm9ncmVzcy5sYW5lcywgbGFuZSk7XG5cbiAgICAgICAgICB2YXIgX3VwZGF0ZSA9IGNyZWF0ZVJvb3RFcnJvclVwZGF0ZSh3b3JrSW5Qcm9ncmVzcywgX2Vycm9ySW5mbywgbGFuZSk7XG5cbiAgICAgICAgICBlbnF1ZXVlQ2FwdHVyZWRVcGRhdGUod29ya0luUHJvZ3Jlc3MsIF91cGRhdGUpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIENsYXNzQ29tcG9uZW50OlxuICAgICAgICAvLyBDYXB0dXJlIGFuZCByZXRyeVxuICAgICAgICB2YXIgZXJyb3JJbmZvID0gdmFsdWU7XG4gICAgICAgIHZhciBjdG9yID0gd29ya0luUHJvZ3Jlc3MudHlwZTtcbiAgICAgICAgdmFyIGluc3RhbmNlID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuXG4gICAgICAgIGlmICgod29ya0luUHJvZ3Jlc3MuZmxhZ3MgJiBEaWRDYXB0dXJlKSA9PT0gTm9GbGFncyAmJiAodHlwZW9mIGN0b3IuZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yID09PSAnZnVuY3Rpb24nIHx8IGluc3RhbmNlICE9PSBudWxsICYmIHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnREaWRDYXRjaCA9PT0gJ2Z1bmN0aW9uJyAmJiAhaXNBbHJlYWR5RmFpbGVkTGVnYWN5RXJyb3JCb3VuZGFyeShpbnN0YW5jZSkpKSB7XG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gU2hvdWxkQ2FwdHVyZTtcblxuICAgICAgICAgIHZhciBfbGFuZSA9IHBpY2tBcmJpdHJhcnlMYW5lKHJvb3RSZW5kZXJMYW5lcyk7XG5cbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5sYW5lcyA9IG1lcmdlTGFuZXMod29ya0luUHJvZ3Jlc3MubGFuZXMsIF9sYW5lKTsgLy8gU2NoZWR1bGUgdGhlIGVycm9yIGJvdW5kYXJ5IHRvIHJlLXJlbmRlciB1c2luZyB1cGRhdGVkIHN0YXRlXG5cbiAgICAgICAgICB2YXIgX3VwZGF0ZTIgPSBjcmVhdGVDbGFzc0Vycm9yVXBkYXRlKHdvcmtJblByb2dyZXNzLCBlcnJvckluZm8sIF9sYW5lKTtcblxuICAgICAgICAgIGVucXVldWVDYXB0dXJlZFVwZGF0ZSh3b3JrSW5Qcm9ncmVzcywgX3VwZGF0ZTIpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHdvcmtJblByb2dyZXNzID0gd29ya0luUHJvZ3Jlc3MucmV0dXJuO1xuICB9IHdoaWxlICh3b3JrSW5Qcm9ncmVzcyAhPT0gbnVsbCk7XG59XG5cbnZhciBkaWRXYXJuQWJvdXRVbmRlZmluZWRTbmFwc2hvdEJlZm9yZVVwZGF0ZSA9IG51bGw7XG5cbntcbiAgZGlkV2FybkFib3V0VW5kZWZpbmVkU25hcHNob3RCZWZvcmVVcGRhdGUgPSBuZXcgU2V0KCk7XG59XG5cbnZhciBQb3NzaWJseVdlYWtTZXQgPSB0eXBlb2YgV2Vha1NldCA9PT0gJ2Z1bmN0aW9uJyA/IFdlYWtTZXQgOiBTZXQ7XG5cbnZhciBjYWxsQ29tcG9uZW50V2lsbFVubW91bnRXaXRoVGltZXIgPSBmdW5jdGlvbiAoY3VycmVudCwgaW5zdGFuY2UpIHtcbiAgaW5zdGFuY2UucHJvcHMgPSBjdXJyZW50Lm1lbW9pemVkUHJvcHM7XG4gIGluc3RhbmNlLnN0YXRlID0gY3VycmVudC5tZW1vaXplZFN0YXRlO1xuXG4gIHtcbiAgICBpbnN0YW5jZS5jb21wb25lbnRXaWxsVW5tb3VudCgpO1xuICB9XG59OyAvLyBDYXB0dXJlIGVycm9ycyBzbyB0aGV5IGRvbid0IGludGVycnVwdCB1bm1vdW50aW5nLlxuXG5cbmZ1bmN0aW9uIHNhZmVseUNhbGxDb21wb25lbnRXaWxsVW5tb3VudChjdXJyZW50LCBpbnN0YW5jZSkge1xuICB7XG4gICAgaW52b2tlR3VhcmRlZENhbGxiYWNrKG51bGwsIGNhbGxDb21wb25lbnRXaWxsVW5tb3VudFdpdGhUaW1lciwgbnVsbCwgY3VycmVudCwgaW5zdGFuY2UpO1xuXG4gICAgaWYgKGhhc0NhdWdodEVycm9yKCkpIHtcbiAgICAgIHZhciB1bm1vdW50RXJyb3IgPSBjbGVhckNhdWdodEVycm9yKCk7XG4gICAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihjdXJyZW50LCB1bm1vdW50RXJyb3IpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBzYWZlbHlEZXRhY2hSZWYoY3VycmVudCkge1xuICB2YXIgcmVmID0gY3VycmVudC5yZWY7XG5cbiAgaWYgKHJlZiAhPT0gbnVsbCkge1xuICAgIGlmICh0eXBlb2YgcmVmID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB7XG4gICAgICAgIGludm9rZUd1YXJkZWRDYWxsYmFjayhudWxsLCByZWYsIG51bGwsIG51bGwpO1xuXG4gICAgICAgIGlmIChoYXNDYXVnaHRFcnJvcigpKSB7XG4gICAgICAgICAgdmFyIHJlZkVycm9yID0gY2xlYXJDYXVnaHRFcnJvcigpO1xuICAgICAgICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKGN1cnJlbnQsIHJlZkVycm9yKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZWYuY3VycmVudCA9IG51bGw7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHNhZmVseUNhbGxEZXN0cm95KGN1cnJlbnQsIGRlc3Ryb3kpIHtcbiAge1xuICAgIGludm9rZUd1YXJkZWRDYWxsYmFjayhudWxsLCBkZXN0cm95LCBudWxsKTtcblxuICAgIGlmIChoYXNDYXVnaHRFcnJvcigpKSB7XG4gICAgICB2YXIgZXJyb3IgPSBjbGVhckNhdWdodEVycm9yKCk7XG4gICAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihjdXJyZW50LCBlcnJvcik7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNvbW1pdEJlZm9yZU11dGF0aW9uTGlmZUN5Y2xlcyhjdXJyZW50LCBmaW5pc2hlZFdvcmspIHtcbiAgc3dpdGNoIChmaW5pc2hlZFdvcmsudGFnKSB7XG4gICAgY2FzZSBGdW5jdGlvbkNvbXBvbmVudDpcbiAgICBjYXNlIEZvcndhcmRSZWY6XG4gICAgY2FzZSBTaW1wbGVNZW1vQ29tcG9uZW50OlxuICAgIGNhc2UgQmxvY2s6XG4gICAgICB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIGlmIChmaW5pc2hlZFdvcmsuZmxhZ3MgJiBTbmFwc2hvdCkge1xuICAgICAgICAgIGlmIChjdXJyZW50ICE9PSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgcHJldlByb3BzID0gY3VycmVudC5tZW1vaXplZFByb3BzO1xuICAgICAgICAgICAgdmFyIHByZXZTdGF0ZSA9IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZTtcbiAgICAgICAgICAgIHZhciBpbnN0YW5jZSA9IGZpbmlzaGVkV29yay5zdGF0ZU5vZGU7IC8vIFdlIGNvdWxkIHVwZGF0ZSBpbnN0YW5jZSBwcm9wcyBhbmQgc3RhdGUgaGVyZSxcbiAgICAgICAgICAgIC8vIGJ1dCBpbnN0ZWFkIHdlIHJlbHkgb24gdGhlbSBiZWluZyBzZXQgZHVyaW5nIGxhc3QgcmVuZGVyLlxuICAgICAgICAgICAgLy8gVE9ETzogcmV2aXNpdCB0aGlzIHdoZW4gd2UgaW1wbGVtZW50IHJlc3VtaW5nLlxuXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGlmIChmaW5pc2hlZFdvcmsudHlwZSA9PT0gZmluaXNoZWRXb3JrLmVsZW1lbnRUeXBlICYmICFkaWRXYXJuQWJvdXRSZWFzc2lnbmluZ1Byb3BzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGluc3RhbmNlLnByb3BzICE9PSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRQcm9wcykge1xuICAgICAgICAgICAgICAgICAgZXJyb3IoJ0V4cGVjdGVkICVzIHByb3BzIHRvIG1hdGNoIG1lbW9pemVkIHByb3BzIGJlZm9yZSAnICsgJ2dldFNuYXBzaG90QmVmb3JlVXBkYXRlLiAnICsgJ1RoaXMgbWlnaHQgZWl0aGVyIGJlIGJlY2F1c2Ugb2YgYSBidWcgaW4gUmVhY3QsIG9yIGJlY2F1c2UgJyArICdhIGNvbXBvbmVudCByZWFzc2lnbnMgaXRzIG93biBgdGhpcy5wcm9wc2AuICcgKyAnUGxlYXNlIGZpbGUgYW4gaXNzdWUuJywgZ2V0Q29tcG9uZW50TmFtZShmaW5pc2hlZFdvcmsudHlwZSkgfHwgJ2luc3RhbmNlJyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGluc3RhbmNlLnN0YXRlICE9PSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRTdGF0ZSkge1xuICAgICAgICAgICAgICAgICAgZXJyb3IoJ0V4cGVjdGVkICVzIHN0YXRlIHRvIG1hdGNoIG1lbW9pemVkIHN0YXRlIGJlZm9yZSAnICsgJ2dldFNuYXBzaG90QmVmb3JlVXBkYXRlLiAnICsgJ1RoaXMgbWlnaHQgZWl0aGVyIGJlIGJlY2F1c2Ugb2YgYSBidWcgaW4gUmVhY3QsIG9yIGJlY2F1c2UgJyArICdhIGNvbXBvbmVudCByZWFzc2lnbnMgaXRzIG93biBgdGhpcy5zdGF0ZWAuICcgKyAnUGxlYXNlIGZpbGUgYW4gaXNzdWUuJywgZ2V0Q29tcG9uZW50TmFtZShmaW5pc2hlZFdvcmsudHlwZSkgfHwgJ2luc3RhbmNlJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBzbmFwc2hvdCA9IGluc3RhbmNlLmdldFNuYXBzaG90QmVmb3JlVXBkYXRlKGZpbmlzaGVkV29yay5lbGVtZW50VHlwZSA9PT0gZmluaXNoZWRXb3JrLnR5cGUgPyBwcmV2UHJvcHMgOiByZXNvbHZlRGVmYXVsdFByb3BzKGZpbmlzaGVkV29yay50eXBlLCBwcmV2UHJvcHMpLCBwcmV2U3RhdGUpO1xuXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHZhciBkaWRXYXJuU2V0ID0gZGlkV2FybkFib3V0VW5kZWZpbmVkU25hcHNob3RCZWZvcmVVcGRhdGU7XG5cbiAgICAgICAgICAgICAgaWYgKHNuYXBzaG90ID09PSB1bmRlZmluZWQgJiYgIWRpZFdhcm5TZXQuaGFzKGZpbmlzaGVkV29yay50eXBlKSkge1xuICAgICAgICAgICAgICAgIGRpZFdhcm5TZXQuYWRkKGZpbmlzaGVkV29yay50eXBlKTtcblxuICAgICAgICAgICAgICAgIGVycm9yKCclcy5nZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSgpOiBBIHNuYXBzaG90IHZhbHVlIChvciBudWxsKSAnICsgJ211c3QgYmUgcmV0dXJuZWQuIFlvdSBoYXZlIHJldHVybmVkIHVuZGVmaW5lZC4nLCBnZXRDb21wb25lbnROYW1lKGZpbmlzaGVkV29yay50eXBlKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaW5zdGFuY2UuX19yZWFjdEludGVybmFsU25hcHNob3RCZWZvcmVVcGRhdGUgPSBzbmFwc2hvdDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICBjYXNlIEhvc3RSb290OlxuICAgICAge1xuICAgICAgICB7XG4gICAgICAgICAgaWYgKGZpbmlzaGVkV29yay5mbGFncyAmIFNuYXBzaG90KSB7XG4gICAgICAgICAgICB2YXIgcm9vdCA9IGZpbmlzaGVkV29yay5zdGF0ZU5vZGU7XG4gICAgICAgICAgICBjbGVhckNvbnRhaW5lcihyb290LmNvbnRhaW5lckluZm8pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICBjYXNlIEhvc3RUZXh0OlxuICAgIGNhc2UgSG9zdFBvcnRhbDpcbiAgICBjYXNlIEluY29tcGxldGVDbGFzc0NvbXBvbmVudDpcbiAgICAgIC8vIE5vdGhpbmcgdG8gZG8gZm9yIHRoZXNlIGNvbXBvbmVudCB0eXBlc1xuICAgICAgcmV0dXJuO1xuICB9XG5cbiAge1xuICAgIHtcbiAgICAgIHRocm93IEVycm9yKCBcIlRoaXMgdW5pdCBvZiB3b3JrIHRhZyBzaG91bGQgbm90IGhhdmUgc2lkZS1lZmZlY3RzLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiICk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNvbW1pdEhvb2tFZmZlY3RMaXN0VW5tb3VudCh0YWcsIGZpbmlzaGVkV29yaykge1xuICB2YXIgdXBkYXRlUXVldWUgPSBmaW5pc2hlZFdvcmsudXBkYXRlUXVldWU7XG4gIHZhciBsYXN0RWZmZWN0ID0gdXBkYXRlUXVldWUgIT09IG51bGwgPyB1cGRhdGVRdWV1ZS5sYXN0RWZmZWN0IDogbnVsbDtcblxuICBpZiAobGFzdEVmZmVjdCAhPT0gbnVsbCkge1xuICAgIHZhciBmaXJzdEVmZmVjdCA9IGxhc3RFZmZlY3QubmV4dDtcbiAgICB2YXIgZWZmZWN0ID0gZmlyc3RFZmZlY3Q7XG5cbiAgICBkbyB7XG4gICAgICBpZiAoKGVmZmVjdC50YWcgJiB0YWcpID09PSB0YWcpIHtcbiAgICAgICAgLy8gVW5tb3VudFxuICAgICAgICB2YXIgZGVzdHJveSA9IGVmZmVjdC5kZXN0cm95O1xuICAgICAgICBlZmZlY3QuZGVzdHJveSA9IHVuZGVmaW5lZDtcblxuICAgICAgICBpZiAoZGVzdHJveSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgZGVzdHJveSgpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGVmZmVjdCA9IGVmZmVjdC5uZXh0O1xuICAgIH0gd2hpbGUgKGVmZmVjdCAhPT0gZmlyc3RFZmZlY3QpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNvbW1pdEhvb2tFZmZlY3RMaXN0TW91bnQodGFnLCBmaW5pc2hlZFdvcmspIHtcbiAgdmFyIHVwZGF0ZVF1ZXVlID0gZmluaXNoZWRXb3JrLnVwZGF0ZVF1ZXVlO1xuICB2YXIgbGFzdEVmZmVjdCA9IHVwZGF0ZVF1ZXVlICE9PSBudWxsID8gdXBkYXRlUXVldWUubGFzdEVmZmVjdCA6IG51bGw7XG5cbiAgaWYgKGxhc3RFZmZlY3QgIT09IG51bGwpIHtcbiAgICB2YXIgZmlyc3RFZmZlY3QgPSBsYXN0RWZmZWN0Lm5leHQ7XG4gICAgdmFyIGVmZmVjdCA9IGZpcnN0RWZmZWN0O1xuXG4gICAgZG8ge1xuICAgICAgaWYgKChlZmZlY3QudGFnICYgdGFnKSA9PT0gdGFnKSB7XG4gICAgICAgIC8vIE1vdW50XG4gICAgICAgIHZhciBjcmVhdGUgPSBlZmZlY3QuY3JlYXRlO1xuICAgICAgICBlZmZlY3QuZGVzdHJveSA9IGNyZWF0ZSgpO1xuXG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgZGVzdHJveSA9IGVmZmVjdC5kZXN0cm95O1xuXG4gICAgICAgICAgaWYgKGRlc3Ryb3kgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgZGVzdHJveSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdmFyIGFkZGVuZHVtID0gdm9pZCAwO1xuXG4gICAgICAgICAgICBpZiAoZGVzdHJveSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICBhZGRlbmR1bSA9ICcgWW91IHJldHVybmVkIG51bGwuIElmIHlvdXIgZWZmZWN0IGRvZXMgbm90IHJlcXVpcmUgY2xlYW4gJyArICd1cCwgcmV0dXJuIHVuZGVmaW5lZCAob3Igbm90aGluZykuJztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGRlc3Ryb3kudGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICBhZGRlbmR1bSA9ICdcXG5cXG5JdCBsb29rcyBsaWtlIHlvdSB3cm90ZSB1c2VFZmZlY3QoYXN5bmMgKCkgPT4gLi4uKSBvciByZXR1cm5lZCBhIFByb21pc2UuICcgKyAnSW5zdGVhZCwgd3JpdGUgdGhlIGFzeW5jIGZ1bmN0aW9uIGluc2lkZSB5b3VyIGVmZmVjdCAnICsgJ2FuZCBjYWxsIGl0IGltbWVkaWF0ZWx5OlxcblxcbicgKyAndXNlRWZmZWN0KCgpID0+IHtcXG4nICsgJyAgYXN5bmMgZnVuY3Rpb24gZmV0Y2hEYXRhKCkge1xcbicgKyAnICAgIC8vIFlvdSBjYW4gYXdhaXQgaGVyZVxcbicgKyAnICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgTXlBUEkuZ2V0RGF0YShzb21lSWQpO1xcbicgKyAnICAgIC8vIC4uLlxcbicgKyAnICB9XFxuJyArICcgIGZldGNoRGF0YSgpO1xcbicgKyBcIn0sIFtzb21lSWRdKTsgLy8gT3IgW10gaWYgZWZmZWN0IGRvZXNuJ3QgbmVlZCBwcm9wcyBvciBzdGF0ZVxcblxcblwiICsgJ0xlYXJuIG1vcmUgYWJvdXQgZGF0YSBmZXRjaGluZyB3aXRoIEhvb2tzOiBodHRwczovL3JlYWN0anMub3JnL2xpbmsvaG9va3MtZGF0YS1mZXRjaGluZyc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBhZGRlbmR1bSA9ICcgWW91IHJldHVybmVkOiAnICsgZGVzdHJveTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZXJyb3IoJ0FuIGVmZmVjdCBmdW5jdGlvbiBtdXN0IG5vdCByZXR1cm4gYW55dGhpbmcgYmVzaWRlcyBhIGZ1bmN0aW9uLCAnICsgJ3doaWNoIGlzIHVzZWQgZm9yIGNsZWFuLXVwLiVzJywgYWRkZW5kdW0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBlZmZlY3QgPSBlZmZlY3QubmV4dDtcbiAgICB9IHdoaWxlIChlZmZlY3QgIT09IGZpcnN0RWZmZWN0KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzY2hlZHVsZVBhc3NpdmVFZmZlY3RzKGZpbmlzaGVkV29yaykge1xuICB2YXIgdXBkYXRlUXVldWUgPSBmaW5pc2hlZFdvcmsudXBkYXRlUXVldWU7XG4gIHZhciBsYXN0RWZmZWN0ID0gdXBkYXRlUXVldWUgIT09IG51bGwgPyB1cGRhdGVRdWV1ZS5sYXN0RWZmZWN0IDogbnVsbDtcblxuICBpZiAobGFzdEVmZmVjdCAhPT0gbnVsbCkge1xuICAgIHZhciBmaXJzdEVmZmVjdCA9IGxhc3RFZmZlY3QubmV4dDtcbiAgICB2YXIgZWZmZWN0ID0gZmlyc3RFZmZlY3Q7XG5cbiAgICBkbyB7XG4gICAgICB2YXIgX2VmZmVjdCA9IGVmZmVjdCxcbiAgICAgICAgICBuZXh0ID0gX2VmZmVjdC5uZXh0LFxuICAgICAgICAgIHRhZyA9IF9lZmZlY3QudGFnO1xuXG4gICAgICBpZiAoKHRhZyAmIFBhc3NpdmUkMSkgIT09IE5vRmxhZ3MkMSAmJiAodGFnICYgSGFzRWZmZWN0KSAhPT0gTm9GbGFncyQxKSB7XG4gICAgICAgIGVucXVldWVQZW5kaW5nUGFzc2l2ZUhvb2tFZmZlY3RVbm1vdW50KGZpbmlzaGVkV29yaywgZWZmZWN0KTtcbiAgICAgICAgZW5xdWV1ZVBlbmRpbmdQYXNzaXZlSG9va0VmZmVjdE1vdW50KGZpbmlzaGVkV29yaywgZWZmZWN0KTtcbiAgICAgIH1cblxuICAgICAgZWZmZWN0ID0gbmV4dDtcbiAgICB9IHdoaWxlIChlZmZlY3QgIT09IGZpcnN0RWZmZWN0KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjb21taXRMaWZlQ3ljbGVzKGZpbmlzaGVkUm9vdCwgY3VycmVudCwgZmluaXNoZWRXb3JrLCBjb21taXR0ZWRMYW5lcykge1xuICBzd2l0Y2ggKGZpbmlzaGVkV29yay50YWcpIHtcbiAgICBjYXNlIEZ1bmN0aW9uQ29tcG9uZW50OlxuICAgIGNhc2UgRm9yd2FyZFJlZjpcbiAgICBjYXNlIFNpbXBsZU1lbW9Db21wb25lbnQ6XG4gICAgY2FzZSBCbG9jazpcbiAgICAgIHtcbiAgICAgICAgLy8gQXQgdGhpcyBwb2ludCBsYXlvdXQgZWZmZWN0cyBoYXZlIGFscmVhZHkgYmVlbiBkZXN0cm95ZWQgKGR1cmluZyBtdXRhdGlvbiBwaGFzZSkuXG4gICAgICAgIC8vIFRoaXMgaXMgZG9uZSB0byBwcmV2ZW50IHNpYmxpbmcgY29tcG9uZW50IGVmZmVjdHMgZnJvbSBpbnRlcmZlcmluZyB3aXRoIGVhY2ggb3RoZXIsXG4gICAgICAgIC8vIGUuZy4gYSBkZXN0cm95IGZ1bmN0aW9uIGluIG9uZSBjb21wb25lbnQgc2hvdWxkIG5ldmVyIG92ZXJyaWRlIGEgcmVmIHNldFxuICAgICAgICAvLyBieSBhIGNyZWF0ZSBmdW5jdGlvbiBpbiBhbm90aGVyIGNvbXBvbmVudCBkdXJpbmcgdGhlIHNhbWUgY29tbWl0LlxuICAgICAgICB7XG4gICAgICAgICAgY29tbWl0SG9va0VmZmVjdExpc3RNb3VudChMYXlvdXQgfCBIYXNFZmZlY3QsIGZpbmlzaGVkV29yayk7XG4gICAgICAgIH1cblxuICAgICAgICBzY2hlZHVsZVBhc3NpdmVFZmZlY3RzKGZpbmlzaGVkV29yayk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIHZhciBpbnN0YW5jZSA9IGZpbmlzaGVkV29yay5zdGF0ZU5vZGU7XG5cbiAgICAgICAgaWYgKGZpbmlzaGVkV29yay5mbGFncyAmIFVwZGF0ZSkge1xuICAgICAgICAgIGlmIChjdXJyZW50ID09PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBXZSBjb3VsZCB1cGRhdGUgaW5zdGFuY2UgcHJvcHMgYW5kIHN0YXRlIGhlcmUsXG4gICAgICAgICAgICAvLyBidXQgaW5zdGVhZCB3ZSByZWx5IG9uIHRoZW0gYmVpbmcgc2V0IGR1cmluZyBsYXN0IHJlbmRlci5cbiAgICAgICAgICAgIC8vIFRPRE86IHJldmlzaXQgdGhpcyB3aGVuIHdlIGltcGxlbWVudCByZXN1bWluZy5cbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgaWYgKGZpbmlzaGVkV29yay50eXBlID09PSBmaW5pc2hlZFdvcmsuZWxlbWVudFR5cGUgJiYgIWRpZFdhcm5BYm91dFJlYXNzaWduaW5nUHJvcHMpIHtcbiAgICAgICAgICAgICAgICBpZiAoaW5zdGFuY2UucHJvcHMgIT09IGZpbmlzaGVkV29yay5tZW1vaXplZFByb3BzKSB7XG4gICAgICAgICAgICAgICAgICBlcnJvcignRXhwZWN0ZWQgJXMgcHJvcHMgdG8gbWF0Y2ggbWVtb2l6ZWQgcHJvcHMgYmVmb3JlICcgKyAnY29tcG9uZW50RGlkTW91bnQuICcgKyAnVGhpcyBtaWdodCBlaXRoZXIgYmUgYmVjYXVzZSBvZiBhIGJ1ZyBpbiBSZWFjdCwgb3IgYmVjYXVzZSAnICsgJ2EgY29tcG9uZW50IHJlYXNzaWducyBpdHMgb3duIGB0aGlzLnByb3BzYC4gJyArICdQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nLCBnZXRDb21wb25lbnROYW1lKGZpbmlzaGVkV29yay50eXBlKSB8fCAnaW5zdGFuY2UnKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoaW5zdGFuY2Uuc3RhdGUgIT09IGZpbmlzaGVkV29yay5tZW1vaXplZFN0YXRlKSB7XG4gICAgICAgICAgICAgICAgICBlcnJvcignRXhwZWN0ZWQgJXMgc3RhdGUgdG8gbWF0Y2ggbWVtb2l6ZWQgc3RhdGUgYmVmb3JlICcgKyAnY29tcG9uZW50RGlkTW91bnQuICcgKyAnVGhpcyBtaWdodCBlaXRoZXIgYmUgYmVjYXVzZSBvZiBhIGJ1ZyBpbiBSZWFjdCwgb3IgYmVjYXVzZSAnICsgJ2EgY29tcG9uZW50IHJlYXNzaWducyBpdHMgb3duIGB0aGlzLnN0YXRlYC4gJyArICdQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nLCBnZXRDb21wb25lbnROYW1lKGZpbmlzaGVkV29yay50eXBlKSB8fCAnaW5zdGFuY2UnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBpbnN0YW5jZS5jb21wb25lbnREaWRNb3VudCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgcHJldlByb3BzID0gZmluaXNoZWRXb3JrLmVsZW1lbnRUeXBlID09PSBmaW5pc2hlZFdvcmsudHlwZSA/IGN1cnJlbnQubWVtb2l6ZWRQcm9wcyA6IHJlc29sdmVEZWZhdWx0UHJvcHMoZmluaXNoZWRXb3JrLnR5cGUsIGN1cnJlbnQubWVtb2l6ZWRQcm9wcyk7XG4gICAgICAgICAgICB2YXIgcHJldlN0YXRlID0gY3VycmVudC5tZW1vaXplZFN0YXRlOyAvLyBXZSBjb3VsZCB1cGRhdGUgaW5zdGFuY2UgcHJvcHMgYW5kIHN0YXRlIGhlcmUsXG4gICAgICAgICAgICAvLyBidXQgaW5zdGVhZCB3ZSByZWx5IG9uIHRoZW0gYmVpbmcgc2V0IGR1cmluZyBsYXN0IHJlbmRlci5cbiAgICAgICAgICAgIC8vIFRPRE86IHJldmlzaXQgdGhpcyB3aGVuIHdlIGltcGxlbWVudCByZXN1bWluZy5cblxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBpZiAoZmluaXNoZWRXb3JrLnR5cGUgPT09IGZpbmlzaGVkV29yay5lbGVtZW50VHlwZSAmJiAhZGlkV2FybkFib3V0UmVhc3NpZ25pbmdQcm9wcykge1xuICAgICAgICAgICAgICAgIGlmIChpbnN0YW5jZS5wcm9wcyAhPT0gZmluaXNoZWRXb3JrLm1lbW9pemVkUHJvcHMpIHtcbiAgICAgICAgICAgICAgICAgIGVycm9yKCdFeHBlY3RlZCAlcyBwcm9wcyB0byBtYXRjaCBtZW1vaXplZCBwcm9wcyBiZWZvcmUgJyArICdjb21wb25lbnREaWRVcGRhdGUuICcgKyAnVGhpcyBtaWdodCBlaXRoZXIgYmUgYmVjYXVzZSBvZiBhIGJ1ZyBpbiBSZWFjdCwgb3IgYmVjYXVzZSAnICsgJ2EgY29tcG9uZW50IHJlYXNzaWducyBpdHMgb3duIGB0aGlzLnByb3BzYC4gJyArICdQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nLCBnZXRDb21wb25lbnROYW1lKGZpbmlzaGVkV29yay50eXBlKSB8fCAnaW5zdGFuY2UnKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoaW5zdGFuY2Uuc3RhdGUgIT09IGZpbmlzaGVkV29yay5tZW1vaXplZFN0YXRlKSB7XG4gICAgICAgICAgICAgICAgICBlcnJvcignRXhwZWN0ZWQgJXMgc3RhdGUgdG8gbWF0Y2ggbWVtb2l6ZWQgc3RhdGUgYmVmb3JlICcgKyAnY29tcG9uZW50RGlkVXBkYXRlLiAnICsgJ1RoaXMgbWlnaHQgZWl0aGVyIGJlIGJlY2F1c2Ugb2YgYSBidWcgaW4gUmVhY3QsIG9yIGJlY2F1c2UgJyArICdhIGNvbXBvbmVudCByZWFzc2lnbnMgaXRzIG93biBgdGhpcy5zdGF0ZWAuICcgKyAnUGxlYXNlIGZpbGUgYW4gaXNzdWUuJywgZ2V0Q29tcG9uZW50TmFtZShmaW5pc2hlZFdvcmsudHlwZSkgfHwgJ2luc3RhbmNlJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgaW5zdGFuY2UuY29tcG9uZW50RGlkVXBkYXRlKHByZXZQcm9wcywgcHJldlN0YXRlLCBpbnN0YW5jZS5fX3JlYWN0SW50ZXJuYWxTbmFwc2hvdEJlZm9yZVVwZGF0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vIFRPRE86IEkgdGhpbmsgdGhpcyBpcyBub3cgYWx3YXlzIG5vbi1udWxsIGJ5IHRoZSB0aW1lIGl0IHJlYWNoZXMgdGhlXG4gICAgICAgIC8vIGNvbW1pdCBwaGFzZS4gQ29uc2lkZXIgcmVtb3ZpbmcgdGhlIHR5cGUgY2hlY2suXG5cblxuICAgICAgICB2YXIgdXBkYXRlUXVldWUgPSBmaW5pc2hlZFdvcmsudXBkYXRlUXVldWU7XG5cbiAgICAgICAgaWYgKHVwZGF0ZVF1ZXVlICE9PSBudWxsKSB7XG4gICAgICAgICAge1xuICAgICAgICAgICAgaWYgKGZpbmlzaGVkV29yay50eXBlID09PSBmaW5pc2hlZFdvcmsuZWxlbWVudFR5cGUgJiYgIWRpZFdhcm5BYm91dFJlYXNzaWduaW5nUHJvcHMpIHtcbiAgICAgICAgICAgICAgaWYgKGluc3RhbmNlLnByb3BzICE9PSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRQcm9wcykge1xuICAgICAgICAgICAgICAgIGVycm9yKCdFeHBlY3RlZCAlcyBwcm9wcyB0byBtYXRjaCBtZW1vaXplZCBwcm9wcyBiZWZvcmUgJyArICdwcm9jZXNzaW5nIHRoZSB1cGRhdGUgcXVldWUuICcgKyAnVGhpcyBtaWdodCBlaXRoZXIgYmUgYmVjYXVzZSBvZiBhIGJ1ZyBpbiBSZWFjdCwgb3IgYmVjYXVzZSAnICsgJ2EgY29tcG9uZW50IHJlYXNzaWducyBpdHMgb3duIGB0aGlzLnByb3BzYC4gJyArICdQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nLCBnZXRDb21wb25lbnROYW1lKGZpbmlzaGVkV29yay50eXBlKSB8fCAnaW5zdGFuY2UnKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmIChpbnN0YW5jZS5zdGF0ZSAhPT0gZmluaXNoZWRXb3JrLm1lbW9pemVkU3RhdGUpIHtcbiAgICAgICAgICAgICAgICBlcnJvcignRXhwZWN0ZWQgJXMgc3RhdGUgdG8gbWF0Y2ggbWVtb2l6ZWQgc3RhdGUgYmVmb3JlICcgKyAncHJvY2Vzc2luZyB0aGUgdXBkYXRlIHF1ZXVlLiAnICsgJ1RoaXMgbWlnaHQgZWl0aGVyIGJlIGJlY2F1c2Ugb2YgYSBidWcgaW4gUmVhY3QsIG9yIGJlY2F1c2UgJyArICdhIGNvbXBvbmVudCByZWFzc2lnbnMgaXRzIG93biBgdGhpcy5zdGF0ZWAuICcgKyAnUGxlYXNlIGZpbGUgYW4gaXNzdWUuJywgZ2V0Q29tcG9uZW50TmFtZShmaW5pc2hlZFdvcmsudHlwZSkgfHwgJ2luc3RhbmNlJyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IC8vIFdlIGNvdWxkIHVwZGF0ZSBpbnN0YW5jZSBwcm9wcyBhbmQgc3RhdGUgaGVyZSxcbiAgICAgICAgICAvLyBidXQgaW5zdGVhZCB3ZSByZWx5IG9uIHRoZW0gYmVpbmcgc2V0IGR1cmluZyBsYXN0IHJlbmRlci5cbiAgICAgICAgICAvLyBUT0RPOiByZXZpc2l0IHRoaXMgd2hlbiB3ZSBpbXBsZW1lbnQgcmVzdW1pbmcuXG5cblxuICAgICAgICAgIGNvbW1pdFVwZGF0ZVF1ZXVlKGZpbmlzaGVkV29yaywgdXBkYXRlUXVldWUsIGluc3RhbmNlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgICB7XG4gICAgICAgIC8vIFRPRE86IEkgdGhpbmsgdGhpcyBpcyBub3cgYWx3YXlzIG5vbi1udWxsIGJ5IHRoZSB0aW1lIGl0IHJlYWNoZXMgdGhlXG4gICAgICAgIC8vIGNvbW1pdCBwaGFzZS4gQ29uc2lkZXIgcmVtb3ZpbmcgdGhlIHR5cGUgY2hlY2suXG4gICAgICAgIHZhciBfdXBkYXRlUXVldWUgPSBmaW5pc2hlZFdvcmsudXBkYXRlUXVldWU7XG5cbiAgICAgICAgaWYgKF91cGRhdGVRdWV1ZSAhPT0gbnVsbCkge1xuICAgICAgICAgIHZhciBfaW5zdGFuY2UgPSBudWxsO1xuXG4gICAgICAgICAgaWYgKGZpbmlzaGVkV29yay5jaGlsZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgc3dpdGNoIChmaW5pc2hlZFdvcmsuY2hpbGQudGFnKSB7XG4gICAgICAgICAgICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgICAgICAgICAgICBfaW5zdGFuY2UgPSBnZXRQdWJsaWNJbnN0YW5jZShmaW5pc2hlZFdvcmsuY2hpbGQuc3RhdGVOb2RlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICBjYXNlIENsYXNzQ29tcG9uZW50OlxuICAgICAgICAgICAgICAgIF9pbnN0YW5jZSA9IGZpbmlzaGVkV29yay5jaGlsZC5zdGF0ZU5vZGU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29tbWl0VXBkYXRlUXVldWUoZmluaXNoZWRXb3JrLCBfdXBkYXRlUXVldWUsIF9pbnN0YW5jZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIHZhciBfaW5zdGFuY2UyID0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZTsgLy8gUmVuZGVyZXJzIG1heSBzY2hlZHVsZSB3b3JrIHRvIGJlIGRvbmUgYWZ0ZXIgaG9zdCBjb21wb25lbnRzIGFyZSBtb3VudGVkXG4gICAgICAgIC8vIChlZyBET00gcmVuZGVyZXIgbWF5IHNjaGVkdWxlIGF1dG8tZm9jdXMgZm9yIGlucHV0cyBhbmQgZm9ybSBjb250cm9scykuXG4gICAgICAgIC8vIFRoZXNlIGVmZmVjdHMgc2hvdWxkIG9ubHkgYmUgY29tbWl0dGVkIHdoZW4gY29tcG9uZW50cyBhcmUgZmlyc3QgbW91bnRlZCxcbiAgICAgICAgLy8gYWthIHdoZW4gdGhlcmUgaXMgbm8gY3VycmVudC9hbHRlcm5hdGUuXG5cbiAgICAgICAgaWYgKGN1cnJlbnQgPT09IG51bGwgJiYgZmluaXNoZWRXb3JrLmZsYWdzICYgVXBkYXRlKSB7XG4gICAgICAgICAgdmFyIHR5cGUgPSBmaW5pc2hlZFdvcmsudHlwZTtcbiAgICAgICAgICB2YXIgcHJvcHMgPSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRQcm9wcztcbiAgICAgICAgICBjb21taXRNb3VudChfaW5zdGFuY2UyLCB0eXBlLCBwcm9wcyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICBjYXNlIEhvc3RUZXh0OlxuICAgICAge1xuICAgICAgICAvLyBXZSBoYXZlIG5vIGxpZmUtY3ljbGVzIGFzc29jaWF0ZWQgd2l0aCB0ZXh0LlxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICBjYXNlIEhvc3RQb3J0YWw6XG4gICAgICB7XG4gICAgICAgIC8vIFdlIGhhdmUgbm8gbGlmZS1jeWNsZXMgYXNzb2NpYXRlZCB3aXRoIHBvcnRhbHMuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgIGNhc2UgUHJvZmlsZXI6XG4gICAgICB7XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgX2ZpbmlzaGVkV29yayRtZW1vaXplMiA9IGZpbmlzaGVkV29yay5tZW1vaXplZFByb3BzLFxuICAgICAgICAgICAgICBvbkNvbW1pdCA9IF9maW5pc2hlZFdvcmskbWVtb2l6ZTIub25Db21taXQsXG4gICAgICAgICAgICAgIG9uUmVuZGVyID0gX2ZpbmlzaGVkV29yayRtZW1vaXplMi5vblJlbmRlcjtcbiAgICAgICAgICB2YXIgZWZmZWN0RHVyYXRpb24gPSBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlLmVmZmVjdER1cmF0aW9uO1xuICAgICAgICAgIHZhciBjb21taXRUaW1lID0gZ2V0Q29tbWl0VGltZSgpO1xuXG4gICAgICAgICAgaWYgKHR5cGVvZiBvblJlbmRlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBvblJlbmRlcihmaW5pc2hlZFdvcmsubWVtb2l6ZWRQcm9wcy5pZCwgY3VycmVudCA9PT0gbnVsbCA/ICdtb3VudCcgOiAndXBkYXRlJywgZmluaXNoZWRXb3JrLmFjdHVhbER1cmF0aW9uLCBmaW5pc2hlZFdvcmsudHJlZUJhc2VEdXJhdGlvbiwgZmluaXNoZWRXb3JrLmFjdHVhbFN0YXJ0VGltZSwgY29tbWl0VGltZSwgZmluaXNoZWRSb290Lm1lbW9pemVkSW50ZXJhY3Rpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICBjYXNlIFN1c3BlbnNlQ29tcG9uZW50OlxuICAgICAge1xuICAgICAgICBjb21taXRTdXNwZW5zZUh5ZHJhdGlvbkNhbGxiYWNrcyhmaW5pc2hlZFJvb3QsIGZpbmlzaGVkV29yayk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgIGNhc2UgU3VzcGVuc2VMaXN0Q29tcG9uZW50OlxuICAgIGNhc2UgSW5jb21wbGV0ZUNsYXNzQ29tcG9uZW50OlxuICAgIGNhc2UgRnVuZGFtZW50YWxDb21wb25lbnQ6XG4gICAgY2FzZSBTY29wZUNvbXBvbmVudDpcbiAgICBjYXNlIE9mZnNjcmVlbkNvbXBvbmVudDpcbiAgICBjYXNlIExlZ2FjeUhpZGRlbkNvbXBvbmVudDpcbiAgICAgIHJldHVybjtcbiAgfVxuXG4gIHtcbiAgICB7XG4gICAgICB0aHJvdyBFcnJvciggXCJUaGlzIHVuaXQgb2Ygd29yayB0YWcgc2hvdWxkIG5vdCBoYXZlIHNpZGUtZWZmZWN0cy4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS5cIiApO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBoaWRlT3JVbmhpZGVBbGxDaGlsZHJlbihmaW5pc2hlZFdvcmssIGlzSGlkZGVuKSB7XG4gIHtcbiAgICAvLyBXZSBvbmx5IGhhdmUgdGhlIHRvcCBGaWJlciB0aGF0IHdhcyBpbnNlcnRlZCBidXQgd2UgbmVlZCB0byByZWN1cnNlIGRvd24gaXRzXG4gICAgLy8gY2hpbGRyZW4gdG8gZmluZCBhbGwgdGhlIHRlcm1pbmFsIG5vZGVzLlxuICAgIHZhciBub2RlID0gZmluaXNoZWRXb3JrO1xuXG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIGlmIChub2RlLnRhZyA9PT0gSG9zdENvbXBvbmVudCkge1xuICAgICAgICB2YXIgaW5zdGFuY2UgPSBub2RlLnN0YXRlTm9kZTtcblxuICAgICAgICBpZiAoaXNIaWRkZW4pIHtcbiAgICAgICAgICBoaWRlSW5zdGFuY2UoaW5zdGFuY2UpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHVuaGlkZUluc3RhbmNlKG5vZGUuc3RhdGVOb2RlLCBub2RlLm1lbW9pemVkUHJvcHMpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKG5vZGUudGFnID09PSBIb3N0VGV4dCkge1xuICAgICAgICB2YXIgX2luc3RhbmNlMyA9IG5vZGUuc3RhdGVOb2RlO1xuXG4gICAgICAgIGlmIChpc0hpZGRlbikge1xuICAgICAgICAgIGhpZGVUZXh0SW5zdGFuY2UoX2luc3RhbmNlMyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdW5oaWRlVGV4dEluc3RhbmNlKF9pbnN0YW5jZTMsIG5vZGUubWVtb2l6ZWRQcm9wcyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoKG5vZGUudGFnID09PSBPZmZzY3JlZW5Db21wb25lbnQgfHwgbm9kZS50YWcgPT09IExlZ2FjeUhpZGRlbkNvbXBvbmVudCkgJiYgbm9kZS5tZW1vaXplZFN0YXRlICE9PSBudWxsICYmIG5vZGUgIT09IGZpbmlzaGVkV29yaykgOyBlbHNlIGlmIChub2RlLmNoaWxkICE9PSBudWxsKSB7XG4gICAgICAgIG5vZGUuY2hpbGQucmV0dXJuID0gbm9kZTtcbiAgICAgICAgbm9kZSA9IG5vZGUuY2hpbGQ7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAobm9kZSA9PT0gZmluaXNoZWRXb3JrKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgd2hpbGUgKG5vZGUuc2libGluZyA9PT0gbnVsbCkge1xuICAgICAgICBpZiAobm9kZS5yZXR1cm4gPT09IG51bGwgfHwgbm9kZS5yZXR1cm4gPT09IGZpbmlzaGVkV29yaykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIG5vZGUgPSBub2RlLnJldHVybjtcbiAgICAgIH1cblxuICAgICAgbm9kZS5zaWJsaW5nLnJldHVybiA9IG5vZGUucmV0dXJuO1xuICAgICAgbm9kZSA9IG5vZGUuc2libGluZztcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY29tbWl0QXR0YWNoUmVmKGZpbmlzaGVkV29yaykge1xuICB2YXIgcmVmID0gZmluaXNoZWRXb3JrLnJlZjtcblxuICBpZiAocmVmICE9PSBudWxsKSB7XG4gICAgdmFyIGluc3RhbmNlID0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZTtcbiAgICB2YXIgaW5zdGFuY2VUb1VzZTtcblxuICAgIHN3aXRjaCAoZmluaXNoZWRXb3JrLnRhZykge1xuICAgICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAgICBpbnN0YW5jZVRvVXNlID0gZ2V0UHVibGljSW5zdGFuY2UoaW5zdGFuY2UpO1xuICAgICAgICBicmVhaztcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaW5zdGFuY2VUb1VzZSA9IGluc3RhbmNlO1xuICAgIH0gLy8gTW92ZWQgb3V0c2lkZSB0byBlbnN1cmUgRENFIHdvcmtzIHdpdGggdGhpcyBmbGFnXG5cbiAgICBpZiAodHlwZW9mIHJlZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmVmKGluc3RhbmNlVG9Vc2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICB7XG4gICAgICAgIGlmICghcmVmLmhhc093blByb3BlcnR5KCdjdXJyZW50JykpIHtcbiAgICAgICAgICBlcnJvcignVW5leHBlY3RlZCByZWYgb2JqZWN0IHByb3ZpZGVkIGZvciAlcy4gJyArICdVc2UgZWl0aGVyIGEgcmVmLXNldHRlciBmdW5jdGlvbiBvciBSZWFjdC5jcmVhdGVSZWYoKS4nLCBnZXRDb21wb25lbnROYW1lKGZpbmlzaGVkV29yay50eXBlKSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmVmLmN1cnJlbnQgPSBpbnN0YW5jZVRvVXNlO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjb21taXREZXRhY2hSZWYoY3VycmVudCkge1xuICB2YXIgY3VycmVudFJlZiA9IGN1cnJlbnQucmVmO1xuXG4gIGlmIChjdXJyZW50UmVmICE9PSBudWxsKSB7XG4gICAgaWYgKHR5cGVvZiBjdXJyZW50UmVmID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjdXJyZW50UmVmKG51bGwpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjdXJyZW50UmVmLmN1cnJlbnQgPSBudWxsO1xuICAgIH1cbiAgfVxufSAvLyBVc2VyLW9yaWdpbmF0aW5nIGVycm9ycyAobGlmZWN5Y2xlcyBhbmQgcmVmcykgc2hvdWxkIG5vdCBpbnRlcnJ1cHRcbi8vIGRlbGV0aW9uLCBzbyBkb24ndCBsZXQgdGhlbSB0aHJvdy4gSG9zdC1vcmlnaW5hdGluZyBlcnJvcnMgc2hvdWxkXG4vLyBpbnRlcnJ1cHQgZGVsZXRpb24sIHNvIGl0J3Mgb2theVxuXG5cbmZ1bmN0aW9uIGNvbW1pdFVubW91bnQoZmluaXNoZWRSb290LCBjdXJyZW50LCByZW5kZXJQcmlvcml0eUxldmVsKSB7XG4gIG9uQ29tbWl0VW5tb3VudChjdXJyZW50KTtcblxuICBzd2l0Y2ggKGN1cnJlbnQudGFnKSB7XG4gICAgY2FzZSBGdW5jdGlvbkNvbXBvbmVudDpcbiAgICBjYXNlIEZvcndhcmRSZWY6XG4gICAgY2FzZSBNZW1vQ29tcG9uZW50OlxuICAgIGNhc2UgU2ltcGxlTWVtb0NvbXBvbmVudDpcbiAgICBjYXNlIEJsb2NrOlxuICAgICAge1xuICAgICAgICB2YXIgdXBkYXRlUXVldWUgPSBjdXJyZW50LnVwZGF0ZVF1ZXVlO1xuXG4gICAgICAgIGlmICh1cGRhdGVRdWV1ZSAhPT0gbnVsbCkge1xuICAgICAgICAgIHZhciBsYXN0RWZmZWN0ID0gdXBkYXRlUXVldWUubGFzdEVmZmVjdDtcblxuICAgICAgICAgIGlmIChsYXN0RWZmZWN0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgZmlyc3RFZmZlY3QgPSBsYXN0RWZmZWN0Lm5leHQ7XG4gICAgICAgICAgICB2YXIgZWZmZWN0ID0gZmlyc3RFZmZlY3Q7XG5cbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgdmFyIF9lZmZlY3QyID0gZWZmZWN0LFxuICAgICAgICAgICAgICAgICAgZGVzdHJveSA9IF9lZmZlY3QyLmRlc3Ryb3ksXG4gICAgICAgICAgICAgICAgICB0YWcgPSBfZWZmZWN0Mi50YWc7XG5cbiAgICAgICAgICAgICAgaWYgKGRlc3Ryb3kgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGlmICgodGFnICYgUGFzc2l2ZSQxKSAhPT0gTm9GbGFncyQxKSB7XG4gICAgICAgICAgICAgICAgICBlbnF1ZXVlUGVuZGluZ1Bhc3NpdmVIb29rRWZmZWN0VW5tb3VudChjdXJyZW50LCBlZmZlY3QpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHNhZmVseUNhbGxEZXN0cm95KGN1cnJlbnQsIGRlc3Ryb3kpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGVmZmVjdCA9IGVmZmVjdC5uZXh0O1xuICAgICAgICAgICAgfSB3aGlsZSAoZWZmZWN0ICE9PSBmaXJzdEVmZmVjdCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgY2FzZSBDbGFzc0NvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgc2FmZWx5RGV0YWNoUmVmKGN1cnJlbnQpO1xuICAgICAgICB2YXIgaW5zdGFuY2UgPSBjdXJyZW50LnN0YXRlTm9kZTtcblxuICAgICAgICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxVbm1vdW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgc2FmZWx5Q2FsbENvbXBvbmVudFdpbGxVbm1vdW50KGN1cnJlbnQsIGluc3RhbmNlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgc2FmZWx5RGV0YWNoUmVmKGN1cnJlbnQpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICBjYXNlIEhvc3RQb3J0YWw6XG4gICAgICB7XG4gICAgICAgIC8vIFRPRE86IHRoaXMgaXMgcmVjdXJzaXZlLlxuICAgICAgICAvLyBXZSBhcmUgYWxzbyBub3QgdXNpbmcgdGhpcyBwYXJlbnQgYmVjYXVzZVxuICAgICAgICAvLyB0aGUgcG9ydGFsIHdpbGwgZ2V0IHB1c2hlZCBpbW1lZGlhdGVseS5cbiAgICAgICAge1xuICAgICAgICAgIHVubW91bnRIb3N0Q29tcG9uZW50cyhmaW5pc2hlZFJvb3QsIGN1cnJlbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgY2FzZSBGdW5kYW1lbnRhbENvbXBvbmVudDpcbiAgICAgIHtcblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICBjYXNlIERlaHlkcmF0ZWRGcmFnbWVudDpcbiAgICAgIHtcblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICBjYXNlIFNjb3BlQ29tcG9uZW50OlxuICAgICAge1xuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjb21taXROZXN0ZWRVbm1vdW50cyhmaW5pc2hlZFJvb3QsIHJvb3QsIHJlbmRlclByaW9yaXR5TGV2ZWwpIHtcbiAgLy8gV2hpbGUgd2UncmUgaW5zaWRlIGEgcmVtb3ZlZCBob3N0IG5vZGUgd2UgZG9uJ3Qgd2FudCB0byBjYWxsXG4gIC8vIHJlbW92ZUNoaWxkIG9uIHRoZSBpbm5lciBub2RlcyBiZWNhdXNlIHRoZXkncmUgcmVtb3ZlZCBieSB0aGUgdG9wXG4gIC8vIGNhbGwgYW55d2F5LiBXZSBhbHNvIHdhbnQgdG8gY2FsbCBjb21wb25lbnRXaWxsVW5tb3VudCBvbiBhbGxcbiAgLy8gY29tcG9zaXRlcyBiZWZvcmUgdGhpcyBob3N0IG5vZGUgaXMgcmVtb3ZlZCBmcm9tIHRoZSB0cmVlLiBUaGVyZWZvcmVcbiAgLy8gd2UgZG8gYW4gaW5uZXIgbG9vcCB3aGlsZSB3ZSdyZSBzdGlsbCBpbnNpZGUgdGhlIGhvc3Qgbm9kZS5cbiAgdmFyIG5vZGUgPSByb290O1xuXG4gIHdoaWxlICh0cnVlKSB7XG4gICAgY29tbWl0VW5tb3VudChmaW5pc2hlZFJvb3QsIG5vZGUpOyAvLyBWaXNpdCBjaGlsZHJlbiBiZWNhdXNlIHRoZXkgbWF5IGNvbnRhaW4gbW9yZSBjb21wb3NpdGUgb3IgaG9zdCBub2Rlcy5cbiAgICAvLyBTa2lwIHBvcnRhbHMgYmVjYXVzZSBjb21taXRVbm1vdW50KCkgY3VycmVudGx5IHZpc2l0cyB0aGVtIHJlY3Vyc2l2ZWx5LlxuXG4gICAgaWYgKG5vZGUuY2hpbGQgIT09IG51bGwgJiYgKCAvLyBJZiB3ZSB1c2UgbXV0YXRpb24gd2UgZHJpbGwgZG93biBpbnRvIHBvcnRhbHMgdXNpbmcgY29tbWl0VW5tb3VudCBhYm92ZS5cbiAgICAvLyBJZiB3ZSBkb24ndCB1c2UgbXV0YXRpb24gd2UgZHJpbGwgZG93biBpbnRvIHBvcnRhbHMgaGVyZSBpbnN0ZWFkLlxuICAgICBub2RlLnRhZyAhPT0gSG9zdFBvcnRhbCkpIHtcbiAgICAgIG5vZGUuY2hpbGQucmV0dXJuID0gbm9kZTtcbiAgICAgIG5vZGUgPSBub2RlLmNoaWxkO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKG5vZGUgPT09IHJvb3QpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB3aGlsZSAobm9kZS5zaWJsaW5nID09PSBudWxsKSB7XG4gICAgICBpZiAobm9kZS5yZXR1cm4gPT09IG51bGwgfHwgbm9kZS5yZXR1cm4gPT09IHJvb3QpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBub2RlID0gbm9kZS5yZXR1cm47XG4gICAgfVxuXG4gICAgbm9kZS5zaWJsaW5nLnJldHVybiA9IG5vZGUucmV0dXJuO1xuICAgIG5vZGUgPSBub2RlLnNpYmxpbmc7XG4gIH1cbn1cblxuZnVuY3Rpb24gZGV0YWNoRmliZXJNdXRhdGlvbihmaWJlcikge1xuICAvLyBDdXQgb2ZmIHRoZSByZXR1cm4gcG9pbnRlcnMgdG8gZGlzY29ubmVjdCBpdCBmcm9tIHRoZSB0cmVlLiBJZGVhbGx5LCB3ZVxuICAvLyBzaG91bGQgY2xlYXIgdGhlIGNoaWxkIHBvaW50ZXIgb2YgdGhlIHBhcmVudCBhbHRlcm5hdGUgdG8gbGV0IHRoaXNcbiAgLy8gZ2V0IEdDOmVkIGJ1dCB3ZSBkb24ndCBrbm93IHdoaWNoIGZvciBzdXJlIHdoaWNoIHBhcmVudCBpcyB0aGUgY3VycmVudFxuICAvLyBvbmUgc28gd2UnbGwgc2V0dGxlIGZvciBHQzppbmcgdGhlIHN1YnRyZWUgb2YgdGhpcyBjaGlsZC4gVGhpcyBjaGlsZFxuICAvLyBpdHNlbGYgd2lsbCBiZSBHQzplZCB3aGVuIHRoZSBwYXJlbnQgdXBkYXRlcyB0aGUgbmV4dCB0aW1lLlxuICAvLyBOb3RlOiB3ZSBjYW5ub3QgbnVsbCBvdXQgc2libGluZyBoZXJlLCBvdGhlcndpc2UgaXQgY2FuIGNhdXNlIGlzc3Vlc1xuICAvLyB3aXRoIGZpbmRET01Ob2RlIGFuZCBob3cgaXQgcmVxdWlyZXMgdGhlIHNpYmxpbmcgZmllbGQgdG8gY2Fycnkgb3V0XG4gIC8vIHRyYXZlcnNhbCBpbiBhIGxhdGVyIGVmZmVjdC4gU2VlIFBSICMxNjgyMC4gV2Ugbm93IGNsZWFyIHRoZSBzaWJsaW5nXG4gIC8vIGZpZWxkIGFmdGVyIGVmZmVjdHMsIHNlZTogZGV0YWNoRmliZXJBZnRlckVmZmVjdHMuXG4gIC8vXG4gIC8vIERvbid0IGRpc2Nvbm5lY3Qgc3RhdGVOb2RlIG5vdzsgaXQgd2lsbCBiZSBkZXRhY2hlZCBpbiBkZXRhY2hGaWJlckFmdGVyRWZmZWN0cy5cbiAgLy8gSXQgbWF5IGJlIHJlcXVpcmVkIGlmIHRoZSBjdXJyZW50IGNvbXBvbmVudCBpcyBhbiBlcnJvciBib3VuZGFyeSxcbiAgLy8gYW5kIG9uZSBvZiBpdHMgZGVzY2VuZGFudHMgdGhyb3dzIHdoaWxlIHVubW91bnRpbmcgYSBwYXNzaXZlIGVmZmVjdC5cbiAgZmliZXIuYWx0ZXJuYXRlID0gbnVsbDtcbiAgZmliZXIuY2hpbGQgPSBudWxsO1xuICBmaWJlci5kZXBlbmRlbmNpZXMgPSBudWxsO1xuICBmaWJlci5maXJzdEVmZmVjdCA9IG51bGw7XG4gIGZpYmVyLmxhc3RFZmZlY3QgPSBudWxsO1xuICBmaWJlci5tZW1vaXplZFByb3BzID0gbnVsbDtcbiAgZmliZXIubWVtb2l6ZWRTdGF0ZSA9IG51bGw7XG4gIGZpYmVyLnBlbmRpbmdQcm9wcyA9IG51bGw7XG4gIGZpYmVyLnJldHVybiA9IG51bGw7XG4gIGZpYmVyLnVwZGF0ZVF1ZXVlID0gbnVsbDtcblxuICB7XG4gICAgZmliZXIuX2RlYnVnT3duZXIgPSBudWxsO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldEhvc3RQYXJlbnRGaWJlcihmaWJlcikge1xuICB2YXIgcGFyZW50ID0gZmliZXIucmV0dXJuO1xuXG4gIHdoaWxlIChwYXJlbnQgIT09IG51bGwpIHtcbiAgICBpZiAoaXNIb3N0UGFyZW50KHBhcmVudCkpIHtcbiAgICAgIHJldHVybiBwYXJlbnQ7XG4gICAgfVxuXG4gICAgcGFyZW50ID0gcGFyZW50LnJldHVybjtcbiAgfVxuXG4gIHtcbiAgICB7XG4gICAgICB0aHJvdyBFcnJvciggXCJFeHBlY3RlZCB0byBmaW5kIGEgaG9zdCBwYXJlbnQuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCIgKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNIb3N0UGFyZW50KGZpYmVyKSB7XG4gIHJldHVybiBmaWJlci50YWcgPT09IEhvc3RDb21wb25lbnQgfHwgZmliZXIudGFnID09PSBIb3N0Um9vdCB8fCBmaWJlci50YWcgPT09IEhvc3RQb3J0YWw7XG59XG5cbmZ1bmN0aW9uIGdldEhvc3RTaWJsaW5nKGZpYmVyKSB7XG4gIC8vIFdlJ3JlIGdvaW5nIHRvIHNlYXJjaCBmb3J3YXJkIGludG8gdGhlIHRyZWUgdW50aWwgd2UgZmluZCBhIHNpYmxpbmcgaG9zdFxuICAvLyBub2RlLiBVbmZvcnR1bmF0ZWx5LCBpZiBtdWx0aXBsZSBpbnNlcnRpb25zIGFyZSBkb25lIGluIGEgcm93IHdlIGhhdmUgdG9cbiAgLy8gc2VhcmNoIHBhc3QgdGhlbS4gVGhpcyBsZWFkcyB0byBleHBvbmVudGlhbCBzZWFyY2ggZm9yIHRoZSBuZXh0IHNpYmxpbmcuXG4gIC8vIFRPRE86IEZpbmQgYSBtb3JlIGVmZmljaWVudCB3YXkgdG8gZG8gdGhpcy5cbiAgdmFyIG5vZGUgPSBmaWJlcjtcblxuICBzaWJsaW5nczogd2hpbGUgKHRydWUpIHtcbiAgICAvLyBJZiB3ZSBkaWRuJ3QgZmluZCBhbnl0aGluZywgbGV0J3MgdHJ5IHRoZSBuZXh0IHNpYmxpbmcuXG4gICAgd2hpbGUgKG5vZGUuc2libGluZyA9PT0gbnVsbCkge1xuICAgICAgaWYgKG5vZGUucmV0dXJuID09PSBudWxsIHx8IGlzSG9zdFBhcmVudChub2RlLnJldHVybikpIHtcbiAgICAgICAgLy8gSWYgd2UgcG9wIG91dCBvZiB0aGUgcm9vdCBvciBoaXQgdGhlIHBhcmVudCB0aGUgZmliZXIgd2UgYXJlIHRoZVxuICAgICAgICAvLyBsYXN0IHNpYmxpbmcuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICBub2RlID0gbm9kZS5yZXR1cm47XG4gICAgfVxuXG4gICAgbm9kZS5zaWJsaW5nLnJldHVybiA9IG5vZGUucmV0dXJuO1xuICAgIG5vZGUgPSBub2RlLnNpYmxpbmc7XG5cbiAgICB3aGlsZSAobm9kZS50YWcgIT09IEhvc3RDb21wb25lbnQgJiYgbm9kZS50YWcgIT09IEhvc3RUZXh0ICYmIG5vZGUudGFnICE9PSBEZWh5ZHJhdGVkRnJhZ21lbnQpIHtcbiAgICAgIC8vIElmIGl0IGlzIG5vdCBob3N0IG5vZGUgYW5kLCB3ZSBtaWdodCBoYXZlIGEgaG9zdCBub2RlIGluc2lkZSBpdC5cbiAgICAgIC8vIFRyeSB0byBzZWFyY2ggZG93biB1bnRpbCB3ZSBmaW5kIG9uZS5cbiAgICAgIGlmIChub2RlLmZsYWdzICYgUGxhY2VtZW50KSB7XG4gICAgICAgIC8vIElmIHdlIGRvbid0IGhhdmUgYSBjaGlsZCwgdHJ5IHRoZSBzaWJsaW5ncyBpbnN0ZWFkLlxuICAgICAgICBjb250aW51ZSBzaWJsaW5ncztcbiAgICAgIH0gLy8gSWYgd2UgZG9uJ3QgaGF2ZSBhIGNoaWxkLCB0cnkgdGhlIHNpYmxpbmdzIGluc3RlYWQuXG4gICAgICAvLyBXZSBhbHNvIHNraXAgcG9ydGFscyBiZWNhdXNlIHRoZXkgYXJlIG5vdCBwYXJ0IG9mIHRoaXMgaG9zdCB0cmVlLlxuXG5cbiAgICAgIGlmIChub2RlLmNoaWxkID09PSBudWxsIHx8IG5vZGUudGFnID09PSBIb3N0UG9ydGFsKSB7XG4gICAgICAgIGNvbnRpbnVlIHNpYmxpbmdzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbm9kZS5jaGlsZC5yZXR1cm4gPSBub2RlO1xuICAgICAgICBub2RlID0gbm9kZS5jaGlsZDtcbiAgICAgIH1cbiAgICB9IC8vIENoZWNrIGlmIHRoaXMgaG9zdCBub2RlIGlzIHN0YWJsZSBvciBhYm91dCB0byBiZSBwbGFjZWQuXG5cblxuICAgIGlmICghKG5vZGUuZmxhZ3MgJiBQbGFjZW1lbnQpKSB7XG4gICAgICAvLyBGb3VuZCBpdCFcbiAgICAgIHJldHVybiBub2RlLnN0YXRlTm9kZTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY29tbWl0UGxhY2VtZW50KGZpbmlzaGVkV29yaykge1xuXG5cbiAgdmFyIHBhcmVudEZpYmVyID0gZ2V0SG9zdFBhcmVudEZpYmVyKGZpbmlzaGVkV29yayk7IC8vIE5vdGU6IHRoZXNlIHR3byB2YXJpYWJsZXMgKm11c3QqIGFsd2F5cyBiZSB1cGRhdGVkIHRvZ2V0aGVyLlxuXG4gIHZhciBwYXJlbnQ7XG4gIHZhciBpc0NvbnRhaW5lcjtcbiAgdmFyIHBhcmVudFN0YXRlTm9kZSA9IHBhcmVudEZpYmVyLnN0YXRlTm9kZTtcblxuICBzd2l0Y2ggKHBhcmVudEZpYmVyLnRhZykge1xuICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgIHBhcmVudCA9IHBhcmVudFN0YXRlTm9kZTtcbiAgICAgIGlzQ29udGFpbmVyID0gZmFsc2U7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgICBwYXJlbnQgPSBwYXJlbnRTdGF0ZU5vZGUuY29udGFpbmVySW5mbztcbiAgICAgIGlzQ29udGFpbmVyID0gdHJ1ZTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBIb3N0UG9ydGFsOlxuICAgICAgcGFyZW50ID0gcGFyZW50U3RhdGVOb2RlLmNvbnRhaW5lckluZm87XG4gICAgICBpc0NvbnRhaW5lciA9IHRydWU7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgRnVuZGFtZW50YWxDb21wb25lbnQ6XG5cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUtbm8tZmFsbHRocm91Z2hcblxuICAgIGRlZmF1bHQ6XG4gICAgICB7XG4gICAgICAgIHtcbiAgICAgICAgICB0aHJvdyBFcnJvciggXCJJbnZhbGlkIGhvc3QgcGFyZW50IGZpYmVyLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiICk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICB9XG5cbiAgaWYgKHBhcmVudEZpYmVyLmZsYWdzICYgQ29udGVudFJlc2V0KSB7XG4gICAgLy8gUmVzZXQgdGhlIHRleHQgY29udGVudCBvZiB0aGUgcGFyZW50IGJlZm9yZSBkb2luZyBhbnkgaW5zZXJ0aW9uc1xuICAgIHJlc2V0VGV4dENvbnRlbnQocGFyZW50KTsgLy8gQ2xlYXIgQ29udGVudFJlc2V0IGZyb20gdGhlIGVmZmVjdCB0YWdcblxuICAgIHBhcmVudEZpYmVyLmZsYWdzICY9IH5Db250ZW50UmVzZXQ7XG4gIH1cblxuICB2YXIgYmVmb3JlID0gZ2V0SG9zdFNpYmxpbmcoZmluaXNoZWRXb3JrKTsgLy8gV2Ugb25seSBoYXZlIHRoZSB0b3AgRmliZXIgdGhhdCB3YXMgaW5zZXJ0ZWQgYnV0IHdlIG5lZWQgdG8gcmVjdXJzZSBkb3duIGl0c1xuICAvLyBjaGlsZHJlbiB0byBmaW5kIGFsbCB0aGUgdGVybWluYWwgbm9kZXMuXG5cbiAgaWYgKGlzQ29udGFpbmVyKSB7XG4gICAgaW5zZXJ0T3JBcHBlbmRQbGFjZW1lbnROb2RlSW50b0NvbnRhaW5lcihmaW5pc2hlZFdvcmssIGJlZm9yZSwgcGFyZW50KTtcbiAgfSBlbHNlIHtcbiAgICBpbnNlcnRPckFwcGVuZFBsYWNlbWVudE5vZGUoZmluaXNoZWRXb3JrLCBiZWZvcmUsIHBhcmVudCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5zZXJ0T3JBcHBlbmRQbGFjZW1lbnROb2RlSW50b0NvbnRhaW5lcihub2RlLCBiZWZvcmUsIHBhcmVudCkge1xuICB2YXIgdGFnID0gbm9kZS50YWc7XG4gIHZhciBpc0hvc3QgPSB0YWcgPT09IEhvc3RDb21wb25lbnQgfHwgdGFnID09PSBIb3N0VGV4dDtcblxuICBpZiAoaXNIb3N0IHx8IGVuYWJsZUZ1bmRhbWVudGFsQVBJICkge1xuICAgIHZhciBzdGF0ZU5vZGUgPSBpc0hvc3QgPyBub2RlLnN0YXRlTm9kZSA6IG5vZGUuc3RhdGVOb2RlLmluc3RhbmNlO1xuXG4gICAgaWYgKGJlZm9yZSkge1xuICAgICAgaW5zZXJ0SW5Db250YWluZXJCZWZvcmUocGFyZW50LCBzdGF0ZU5vZGUsIGJlZm9yZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFwcGVuZENoaWxkVG9Db250YWluZXIocGFyZW50LCBzdGF0ZU5vZGUpO1xuICAgIH1cbiAgfSBlbHNlIGlmICh0YWcgPT09IEhvc3RQb3J0YWwpIDsgZWxzZSB7XG4gICAgdmFyIGNoaWxkID0gbm9kZS5jaGlsZDtcblxuICAgIGlmIChjaGlsZCAhPT0gbnVsbCkge1xuICAgICAgaW5zZXJ0T3JBcHBlbmRQbGFjZW1lbnROb2RlSW50b0NvbnRhaW5lcihjaGlsZCwgYmVmb3JlLCBwYXJlbnQpO1xuICAgICAgdmFyIHNpYmxpbmcgPSBjaGlsZC5zaWJsaW5nO1xuXG4gICAgICB3aGlsZSAoc2libGluZyAhPT0gbnVsbCkge1xuICAgICAgICBpbnNlcnRPckFwcGVuZFBsYWNlbWVudE5vZGVJbnRvQ29udGFpbmVyKHNpYmxpbmcsIGJlZm9yZSwgcGFyZW50KTtcbiAgICAgICAgc2libGluZyA9IHNpYmxpbmcuc2libGluZztcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5zZXJ0T3JBcHBlbmRQbGFjZW1lbnROb2RlKG5vZGUsIGJlZm9yZSwgcGFyZW50KSB7XG4gIHZhciB0YWcgPSBub2RlLnRhZztcbiAgdmFyIGlzSG9zdCA9IHRhZyA9PT0gSG9zdENvbXBvbmVudCB8fCB0YWcgPT09IEhvc3RUZXh0O1xuXG4gIGlmIChpc0hvc3QgfHwgZW5hYmxlRnVuZGFtZW50YWxBUEkgKSB7XG4gICAgdmFyIHN0YXRlTm9kZSA9IGlzSG9zdCA/IG5vZGUuc3RhdGVOb2RlIDogbm9kZS5zdGF0ZU5vZGUuaW5zdGFuY2U7XG5cbiAgICBpZiAoYmVmb3JlKSB7XG4gICAgICBpbnNlcnRCZWZvcmUocGFyZW50LCBzdGF0ZU5vZGUsIGJlZm9yZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFwcGVuZENoaWxkKHBhcmVudCwgc3RhdGVOb2RlKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAodGFnID09PSBIb3N0UG9ydGFsKSA7IGVsc2Uge1xuICAgIHZhciBjaGlsZCA9IG5vZGUuY2hpbGQ7XG5cbiAgICBpZiAoY2hpbGQgIT09IG51bGwpIHtcbiAgICAgIGluc2VydE9yQXBwZW5kUGxhY2VtZW50Tm9kZShjaGlsZCwgYmVmb3JlLCBwYXJlbnQpO1xuICAgICAgdmFyIHNpYmxpbmcgPSBjaGlsZC5zaWJsaW5nO1xuXG4gICAgICB3aGlsZSAoc2libGluZyAhPT0gbnVsbCkge1xuICAgICAgICBpbnNlcnRPckFwcGVuZFBsYWNlbWVudE5vZGUoc2libGluZywgYmVmb3JlLCBwYXJlbnQpO1xuICAgICAgICBzaWJsaW5nID0gc2libGluZy5zaWJsaW5nO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiB1bm1vdW50SG9zdENvbXBvbmVudHMoZmluaXNoZWRSb290LCBjdXJyZW50LCByZW5kZXJQcmlvcml0eUxldmVsKSB7XG4gIC8vIFdlIG9ubHkgaGF2ZSB0aGUgdG9wIEZpYmVyIHRoYXQgd2FzIGRlbGV0ZWQgYnV0IHdlIG5lZWQgdG8gcmVjdXJzZSBkb3duIGl0c1xuICAvLyBjaGlsZHJlbiB0byBmaW5kIGFsbCB0aGUgdGVybWluYWwgbm9kZXMuXG4gIHZhciBub2RlID0gY3VycmVudDsgLy8gRWFjaCBpdGVyYXRpb24sIGN1cnJlbnRQYXJlbnQgaXMgcG9wdWxhdGVkIHdpdGggbm9kZSdzIGhvc3QgcGFyZW50IGlmIG5vdFxuICAvLyBjdXJyZW50UGFyZW50SXNWYWxpZC5cblxuICB2YXIgY3VycmVudFBhcmVudElzVmFsaWQgPSBmYWxzZTsgLy8gTm90ZTogdGhlc2UgdHdvIHZhcmlhYmxlcyAqbXVzdCogYWx3YXlzIGJlIHVwZGF0ZWQgdG9nZXRoZXIuXG5cbiAgdmFyIGN1cnJlbnRQYXJlbnQ7XG4gIHZhciBjdXJyZW50UGFyZW50SXNDb250YWluZXI7XG5cbiAgd2hpbGUgKHRydWUpIHtcbiAgICBpZiAoIWN1cnJlbnRQYXJlbnRJc1ZhbGlkKSB7XG4gICAgICB2YXIgcGFyZW50ID0gbm9kZS5yZXR1cm47XG5cbiAgICAgIGZpbmRQYXJlbnQ6IHdoaWxlICh0cnVlKSB7XG4gICAgICAgIGlmICghKHBhcmVudCAhPT0gbnVsbCkpIHtcbiAgICAgICAgICB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvciggXCJFeHBlY3RlZCB0byBmaW5kIGEgaG9zdCBwYXJlbnQuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCIgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcGFyZW50U3RhdGVOb2RlID0gcGFyZW50LnN0YXRlTm9kZTtcblxuICAgICAgICBzd2l0Y2ggKHBhcmVudC50YWcpIHtcbiAgICAgICAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICAgICAgICBjdXJyZW50UGFyZW50ID0gcGFyZW50U3RhdGVOb2RlO1xuICAgICAgICAgICAgY3VycmVudFBhcmVudElzQ29udGFpbmVyID0gZmFsc2U7XG4gICAgICAgICAgICBicmVhayBmaW5kUGFyZW50O1xuXG4gICAgICAgICAgY2FzZSBIb3N0Um9vdDpcbiAgICAgICAgICAgIGN1cnJlbnRQYXJlbnQgPSBwYXJlbnRTdGF0ZU5vZGUuY29udGFpbmVySW5mbztcbiAgICAgICAgICAgIGN1cnJlbnRQYXJlbnRJc0NvbnRhaW5lciA9IHRydWU7XG4gICAgICAgICAgICBicmVhayBmaW5kUGFyZW50O1xuXG4gICAgICAgICAgY2FzZSBIb3N0UG9ydGFsOlxuICAgICAgICAgICAgY3VycmVudFBhcmVudCA9IHBhcmVudFN0YXRlTm9kZS5jb250YWluZXJJbmZvO1xuICAgICAgICAgICAgY3VycmVudFBhcmVudElzQ29udGFpbmVyID0gdHJ1ZTtcbiAgICAgICAgICAgIGJyZWFrIGZpbmRQYXJlbnQ7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHBhcmVudCA9IHBhcmVudC5yZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGN1cnJlbnRQYXJlbnRJc1ZhbGlkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAobm9kZS50YWcgPT09IEhvc3RDb21wb25lbnQgfHwgbm9kZS50YWcgPT09IEhvc3RUZXh0KSB7XG4gICAgICBjb21taXROZXN0ZWRVbm1vdW50cyhmaW5pc2hlZFJvb3QsIG5vZGUpOyAvLyBBZnRlciBhbGwgdGhlIGNoaWxkcmVuIGhhdmUgdW5tb3VudGVkLCBpdCBpcyBub3cgc2FmZSB0byByZW1vdmUgdGhlXG4gICAgICAvLyBub2RlIGZyb20gdGhlIHRyZWUuXG5cbiAgICAgIGlmIChjdXJyZW50UGFyZW50SXNDb250YWluZXIpIHtcbiAgICAgICAgcmVtb3ZlQ2hpbGRGcm9tQ29udGFpbmVyKGN1cnJlbnRQYXJlbnQsIG5vZGUuc3RhdGVOb2RlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlbW92ZUNoaWxkKGN1cnJlbnRQYXJlbnQsIG5vZGUuc3RhdGVOb2RlKTtcbiAgICAgIH0gLy8gRG9uJ3QgdmlzaXQgY2hpbGRyZW4gYmVjYXVzZSB3ZSBhbHJlYWR5IHZpc2l0ZWQgdGhlbS5cblxuICAgIH0gZWxzZSBpZiAobm9kZS50YWcgPT09IEhvc3RQb3J0YWwpIHtcbiAgICAgIGlmIChub2RlLmNoaWxkICE9PSBudWxsKSB7XG4gICAgICAgIC8vIFdoZW4gd2UgZ28gaW50byBhIHBvcnRhbCwgaXQgYmVjb21lcyB0aGUgcGFyZW50IHRvIHJlbW92ZSBmcm9tLlxuICAgICAgICAvLyBXZSB3aWxsIHJlYXNzaWduIGl0IGJhY2sgd2hlbiB3ZSBwb3AgdGhlIHBvcnRhbCBvbiB0aGUgd2F5IHVwLlxuICAgICAgICBjdXJyZW50UGFyZW50ID0gbm9kZS5zdGF0ZU5vZGUuY29udGFpbmVySW5mbztcbiAgICAgICAgY3VycmVudFBhcmVudElzQ29udGFpbmVyID0gdHJ1ZTsgLy8gVmlzaXQgY2hpbGRyZW4gYmVjYXVzZSBwb3J0YWxzIG1pZ2h0IGNvbnRhaW4gaG9zdCBjb21wb25lbnRzLlxuXG4gICAgICAgIG5vZGUuY2hpbGQucmV0dXJuID0gbm9kZTtcbiAgICAgICAgbm9kZSA9IG5vZGUuY2hpbGQ7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb21taXRVbm1vdW50KGZpbmlzaGVkUm9vdCwgbm9kZSk7IC8vIFZpc2l0IGNoaWxkcmVuIGJlY2F1c2Ugd2UgbWF5IGZpbmQgbW9yZSBob3N0IGNvbXBvbmVudHMgYmVsb3cuXG5cbiAgICAgIGlmIChub2RlLmNoaWxkICE9PSBudWxsKSB7XG4gICAgICAgIG5vZGUuY2hpbGQucmV0dXJuID0gbm9kZTtcbiAgICAgICAgbm9kZSA9IG5vZGUuY2hpbGQ7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChub2RlID09PSBjdXJyZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgd2hpbGUgKG5vZGUuc2libGluZyA9PT0gbnVsbCkge1xuICAgICAgaWYgKG5vZGUucmV0dXJuID09PSBudWxsIHx8IG5vZGUucmV0dXJuID09PSBjdXJyZW50KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgbm9kZSA9IG5vZGUucmV0dXJuO1xuXG4gICAgICBpZiAobm9kZS50YWcgPT09IEhvc3RQb3J0YWwpIHtcbiAgICAgICAgLy8gV2hlbiB3ZSBnbyBvdXQgb2YgdGhlIHBvcnRhbCwgd2UgbmVlZCB0byByZXN0b3JlIHRoZSBwYXJlbnQuXG4gICAgICAgIC8vIFNpbmNlIHdlIGRvbid0IGtlZXAgYSBzdGFjayBvZiB0aGVtLCB3ZSB3aWxsIHNlYXJjaCBmb3IgaXQuXG4gICAgICAgIGN1cnJlbnRQYXJlbnRJc1ZhbGlkID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgbm9kZS5zaWJsaW5nLnJldHVybiA9IG5vZGUucmV0dXJuO1xuICAgIG5vZGUgPSBub2RlLnNpYmxpbmc7XG4gIH1cbn1cblxuZnVuY3Rpb24gY29tbWl0RGVsZXRpb24oZmluaXNoZWRSb290LCBjdXJyZW50LCByZW5kZXJQcmlvcml0eUxldmVsKSB7XG4gIHtcbiAgICAvLyBSZWN1cnNpdmVseSBkZWxldGUgYWxsIGhvc3Qgbm9kZXMgZnJvbSB0aGUgcGFyZW50LlxuICAgIC8vIERldGFjaCByZWZzIGFuZCBjYWxsIGNvbXBvbmVudFdpbGxVbm1vdW50KCkgb24gdGhlIHdob2xlIHN1YnRyZWUuXG4gICAgdW5tb3VudEhvc3RDb21wb25lbnRzKGZpbmlzaGVkUm9vdCwgY3VycmVudCk7XG4gIH1cblxuICB2YXIgYWx0ZXJuYXRlID0gY3VycmVudC5hbHRlcm5hdGU7XG4gIGRldGFjaEZpYmVyTXV0YXRpb24oY3VycmVudCk7XG5cbiAgaWYgKGFsdGVybmF0ZSAhPT0gbnVsbCkge1xuICAgIGRldGFjaEZpYmVyTXV0YXRpb24oYWx0ZXJuYXRlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjb21taXRXb3JrKGN1cnJlbnQsIGZpbmlzaGVkV29yaykge1xuXG4gIHN3aXRjaCAoZmluaXNoZWRXb3JrLnRhZykge1xuICAgIGNhc2UgRnVuY3Rpb25Db21wb25lbnQ6XG4gICAgY2FzZSBGb3J3YXJkUmVmOlxuICAgIGNhc2UgTWVtb0NvbXBvbmVudDpcbiAgICBjYXNlIFNpbXBsZU1lbW9Db21wb25lbnQ6XG4gICAgY2FzZSBCbG9jazpcbiAgICAgIHtcbiAgICAgICAgLy8gTGF5b3V0IGVmZmVjdHMgYXJlIGRlc3Ryb3llZCBkdXJpbmcgdGhlIG11dGF0aW9uIHBoYXNlIHNvIHRoYXQgYWxsXG4gICAgICAgIC8vIGRlc3Ryb3kgZnVuY3Rpb25zIGZvciBhbGwgZmliZXJzIGFyZSBjYWxsZWQgYmVmb3JlIGFueSBjcmVhdGUgZnVuY3Rpb25zLlxuICAgICAgICAvLyBUaGlzIHByZXZlbnRzIHNpYmxpbmcgY29tcG9uZW50IGVmZmVjdHMgZnJvbSBpbnRlcmZlcmluZyB3aXRoIGVhY2ggb3RoZXIsXG4gICAgICAgIC8vIGUuZy4gYSBkZXN0cm95IGZ1bmN0aW9uIGluIG9uZSBjb21wb25lbnQgc2hvdWxkIG5ldmVyIG92ZXJyaWRlIGEgcmVmIHNldFxuICAgICAgICAvLyBieSBhIGNyZWF0ZSBmdW5jdGlvbiBpbiBhbm90aGVyIGNvbXBvbmVudCBkdXJpbmcgdGhlIHNhbWUgY29tbWl0LlxuICAgICAgICB7XG4gICAgICAgICAgY29tbWl0SG9va0VmZmVjdExpc3RVbm1vdW50KExheW91dCB8IEhhc0VmZmVjdCwgZmluaXNoZWRXb3JrKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgdmFyIGluc3RhbmNlID0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZTtcblxuICAgICAgICBpZiAoaW5zdGFuY2UgIT0gbnVsbCkge1xuICAgICAgICAgIC8vIENvbW1pdCB0aGUgd29yayBwcmVwYXJlZCBlYXJsaWVyLlxuICAgICAgICAgIHZhciBuZXdQcm9wcyA9IGZpbmlzaGVkV29yay5tZW1vaXplZFByb3BzOyAvLyBGb3IgaHlkcmF0aW9uIHdlIHJldXNlIHRoZSB1cGRhdGUgcGF0aCBidXQgd2UgdHJlYXQgdGhlIG9sZFByb3BzXG4gICAgICAgICAgLy8gYXMgdGhlIG5ld1Byb3BzLiBUaGUgdXBkYXRlUGF5bG9hZCB3aWxsIGNvbnRhaW4gdGhlIHJlYWwgY2hhbmdlIGluXG4gICAgICAgICAgLy8gdGhpcyBjYXNlLlxuXG4gICAgICAgICAgdmFyIG9sZFByb3BzID0gY3VycmVudCAhPT0gbnVsbCA/IGN1cnJlbnQubWVtb2l6ZWRQcm9wcyA6IG5ld1Byb3BzO1xuICAgICAgICAgIHZhciB0eXBlID0gZmluaXNoZWRXb3JrLnR5cGU7IC8vIFRPRE86IFR5cGUgdGhlIHVwZGF0ZVF1ZXVlIHRvIGJlIHNwZWNpZmljIHRvIGhvc3QgY29tcG9uZW50cy5cblxuICAgICAgICAgIHZhciB1cGRhdGVQYXlsb2FkID0gZmluaXNoZWRXb3JrLnVwZGF0ZVF1ZXVlO1xuICAgICAgICAgIGZpbmlzaGVkV29yay51cGRhdGVRdWV1ZSA9IG51bGw7XG5cbiAgICAgICAgICBpZiAodXBkYXRlUGF5bG9hZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgY29tbWl0VXBkYXRlKGluc3RhbmNlLCB1cGRhdGVQYXlsb2FkLCB0eXBlLCBvbGRQcm9wcywgbmV3UHJvcHMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgIGNhc2UgSG9zdFRleHQ6XG4gICAgICB7XG4gICAgICAgIGlmICghKGZpbmlzaGVkV29yay5zdGF0ZU5vZGUgIT09IG51bGwpKSB7XG4gICAgICAgICAge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoIFwiVGhpcyBzaG91bGQgaGF2ZSBhIHRleHQgbm9kZSBpbml0aWFsaXplZC4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS5cIiApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB0ZXh0SW5zdGFuY2UgPSBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlO1xuICAgICAgICB2YXIgbmV3VGV4dCA9IGZpbmlzaGVkV29yay5tZW1vaXplZFByb3BzOyAvLyBGb3IgaHlkcmF0aW9uIHdlIHJldXNlIHRoZSB1cGRhdGUgcGF0aCBidXQgd2UgdHJlYXQgdGhlIG9sZFByb3BzXG4gICAgICAgIC8vIGFzIHRoZSBuZXdQcm9wcy4gVGhlIHVwZGF0ZVBheWxvYWQgd2lsbCBjb250YWluIHRoZSByZWFsIGNoYW5nZSBpblxuICAgICAgICAvLyB0aGlzIGNhc2UuXG5cbiAgICAgICAgdmFyIG9sZFRleHQgPSBjdXJyZW50ICE9PSBudWxsID8gY3VycmVudC5tZW1vaXplZFByb3BzIDogbmV3VGV4dDtcbiAgICAgICAgY29tbWl0VGV4dFVwZGF0ZSh0ZXh0SW5zdGFuY2UsIG9sZFRleHQsIG5ld1RleHQpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICBjYXNlIEhvc3RSb290OlxuICAgICAge1xuICAgICAgICB7XG4gICAgICAgICAgdmFyIF9yb290ID0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZTtcblxuICAgICAgICAgIGlmIChfcm9vdC5oeWRyYXRlKSB7XG4gICAgICAgICAgICAvLyBXZSd2ZSBqdXN0IGh5ZHJhdGVkLiBObyBuZWVkIHRvIGh5ZHJhdGUgYWdhaW4uXG4gICAgICAgICAgICBfcm9vdC5oeWRyYXRlID0gZmFsc2U7XG4gICAgICAgICAgICBjb21taXRIeWRyYXRlZENvbnRhaW5lcihfcm9vdC5jb250YWluZXJJbmZvKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICBjYXNlIFByb2ZpbGVyOlxuICAgICAge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICBjYXNlIFN1c3BlbnNlQ29tcG9uZW50OlxuICAgICAge1xuICAgICAgICBjb21taXRTdXNwZW5zZUNvbXBvbmVudChmaW5pc2hlZFdvcmspO1xuICAgICAgICBhdHRhY2hTdXNwZW5zZVJldHJ5TGlzdGVuZXJzKGZpbmlzaGVkV29yayk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgIGNhc2UgU3VzcGVuc2VMaXN0Q29tcG9uZW50OlxuICAgICAge1xuICAgICAgICBhdHRhY2hTdXNwZW5zZVJldHJ5TGlzdGVuZXJzKGZpbmlzaGVkV29yayk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgIGNhc2UgSW5jb21wbGV0ZUNsYXNzQ29tcG9uZW50OlxuICAgICAge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICBjYXNlIEZ1bmRhbWVudGFsQ29tcG9uZW50OlxuICAgICAge1xuXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgY2FzZSBTY29wZUNvbXBvbmVudDpcbiAgICAgIHtcblxuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgIGNhc2UgT2Zmc2NyZWVuQ29tcG9uZW50OlxuICAgIGNhc2UgTGVnYWN5SGlkZGVuQ29tcG9uZW50OlxuICAgICAge1xuICAgICAgICB2YXIgbmV3U3RhdGUgPSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRTdGF0ZTtcbiAgICAgICAgdmFyIGlzSGlkZGVuID0gbmV3U3RhdGUgIT09IG51bGw7XG4gICAgICAgIGhpZGVPclVuaGlkZUFsbENoaWxkcmVuKGZpbmlzaGVkV29yaywgaXNIaWRkZW4pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gIH1cblxuICB7XG4gICAge1xuICAgICAgdGhyb3cgRXJyb3IoIFwiVGhpcyB1bml0IG9mIHdvcmsgdGFnIHNob3VsZCBub3QgaGF2ZSBzaWRlLWVmZmVjdHMuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCIgKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY29tbWl0U3VzcGVuc2VDb21wb25lbnQoZmluaXNoZWRXb3JrKSB7XG4gIHZhciBuZXdTdGF0ZSA9IGZpbmlzaGVkV29yay5tZW1vaXplZFN0YXRlO1xuXG4gIGlmIChuZXdTdGF0ZSAhPT0gbnVsbCkge1xuICAgIG1hcmtDb21taXRUaW1lT2ZGYWxsYmFjaygpO1xuXG4gICAge1xuICAgICAgLy8gSGlkZSB0aGUgT2Zmc2NyZWVuIGNvbXBvbmVudCB0aGF0IGNvbnRhaW5zIHRoZSBwcmltYXJ5IGNoaWxkcmVuLiBUT0RPOlxuICAgICAgLy8gSWRlYWxseSwgdGhpcyBlZmZlY3Qgd291bGQgaGF2ZSBiZWVuIHNjaGVkdWxlZCBvbiB0aGUgT2Zmc2NyZWVuIGZpYmVyXG4gICAgICAvLyBpdHNlbGYuIFRoYXQncyBob3cgdW5oaWRpbmcgd29ya3M6IHRoZSBPZmZzY3JlZW4gY29tcG9uZW50IHNjaGVkdWxlcyBhblxuICAgICAgLy8gZWZmZWN0IG9uIGl0c2VsZi4gSG93ZXZlciwgaW4gdGhpcyBjYXNlLCB0aGUgY29tcG9uZW50IGRpZG4ndCBjb21wbGV0ZSxcbiAgICAgIC8vIHNvIHRoZSBmaWJlciB3YXMgbmV2ZXIgYWRkZWQgdG8gdGhlIGVmZmVjdCBsaXN0IGluIHRoZSBub3JtYWwgcGF0aC4gV2VcbiAgICAgIC8vIGNvdWxkIGhhdmUgYXBwZW5kZWQgaXQgdG8gdGhlIGVmZmVjdCBsaXN0IGluIHRoZSBTdXNwZW5zZSBjb21wb25lbnQnc1xuICAgICAgLy8gc2Vjb25kIHBhc3MsIGJ1dCBkb2luZyBpdCB0aGlzIHdheSBpcyBsZXNzIGNvbXBsaWNhdGVkLiBUaGlzIHdvdWxkIGJlXG4gICAgICAvLyBzaW1wbGVyIGlmIHdlIGdvdCByaWQgb2YgdGhlIGVmZmVjdCBsaXN0IGFuZCB0cmF2ZXJzZWQgdGhlIHRyZWUsIGxpa2VcbiAgICAgIC8vIHdlJ3JlIHBsYW5uaW5nIHRvIGRvLlxuICAgICAgdmFyIHByaW1hcnlDaGlsZFBhcmVudCA9IGZpbmlzaGVkV29yay5jaGlsZDtcbiAgICAgIGhpZGVPclVuaGlkZUFsbENoaWxkcmVuKHByaW1hcnlDaGlsZFBhcmVudCwgdHJ1ZSk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNvbW1pdFN1c3BlbnNlSHlkcmF0aW9uQ2FsbGJhY2tzKGZpbmlzaGVkUm9vdCwgZmluaXNoZWRXb3JrKSB7XG5cbiAgdmFyIG5ld1N0YXRlID0gZmluaXNoZWRXb3JrLm1lbW9pemVkU3RhdGU7XG5cbiAgaWYgKG5ld1N0YXRlID09PSBudWxsKSB7XG4gICAgdmFyIGN1cnJlbnQgPSBmaW5pc2hlZFdvcmsuYWx0ZXJuYXRlO1xuXG4gICAgaWYgKGN1cnJlbnQgIT09IG51bGwpIHtcbiAgICAgIHZhciBwcmV2U3RhdGUgPSBjdXJyZW50Lm1lbW9pemVkU3RhdGU7XG5cbiAgICAgIGlmIChwcmV2U3RhdGUgIT09IG51bGwpIHtcbiAgICAgICAgdmFyIHN1c3BlbnNlSW5zdGFuY2UgPSBwcmV2U3RhdGUuZGVoeWRyYXRlZDtcblxuICAgICAgICBpZiAoc3VzcGVuc2VJbnN0YW5jZSAhPT0gbnVsbCkge1xuICAgICAgICAgIGNvbW1pdEh5ZHJhdGVkU3VzcGVuc2VJbnN0YW5jZShzdXNwZW5zZUluc3RhbmNlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBhdHRhY2hTdXNwZW5zZVJldHJ5TGlzdGVuZXJzKGZpbmlzaGVkV29yaykge1xuICAvLyBJZiB0aGlzIGJvdW5kYXJ5IGp1c3QgdGltZWQgb3V0LCB0aGVuIGl0IHdpbGwgaGF2ZSBhIHNldCBvZiB3YWtlYWJsZXMuXG4gIC8vIEZvciBlYWNoIHdha2VhYmxlLCBhdHRhY2ggYSBsaXN0ZW5lciBzbyB0aGF0IHdoZW4gaXQgcmVzb2x2ZXMsIFJlYWN0XG4gIC8vIGF0dGVtcHRzIHRvIHJlLXJlbmRlciB0aGUgYm91bmRhcnkgaW4gdGhlIHByaW1hcnkgKHByZS10aW1lb3V0KSBzdGF0ZS5cbiAgdmFyIHdha2VhYmxlcyA9IGZpbmlzaGVkV29yay51cGRhdGVRdWV1ZTtcblxuICBpZiAod2FrZWFibGVzICE9PSBudWxsKSB7XG4gICAgZmluaXNoZWRXb3JrLnVwZGF0ZVF1ZXVlID0gbnVsbDtcbiAgICB2YXIgcmV0cnlDYWNoZSA9IGZpbmlzaGVkV29yay5zdGF0ZU5vZGU7XG5cbiAgICBpZiAocmV0cnlDYWNoZSA9PT0gbnVsbCkge1xuICAgICAgcmV0cnlDYWNoZSA9IGZpbmlzaGVkV29yay5zdGF0ZU5vZGUgPSBuZXcgUG9zc2libHlXZWFrU2V0KCk7XG4gICAgfVxuXG4gICAgd2FrZWFibGVzLmZvckVhY2goZnVuY3Rpb24gKHdha2VhYmxlKSB7XG4gICAgICAvLyBNZW1vaXplIHVzaW5nIHRoZSBib3VuZGFyeSBmaWJlciB0byBwcmV2ZW50IHJlZHVuZGFudCBsaXN0ZW5lcnMuXG4gICAgICB2YXIgcmV0cnkgPSByZXNvbHZlUmV0cnlXYWtlYWJsZS5iaW5kKG51bGwsIGZpbmlzaGVkV29yaywgd2FrZWFibGUpO1xuXG4gICAgICBpZiAoIXJldHJ5Q2FjaGUuaGFzKHdha2VhYmxlKSkge1xuICAgICAgICB7XG4gICAgICAgICAgaWYgKHdha2VhYmxlLl9fcmVhY3REb05vdFRyYWNlSW50ZXJhY3Rpb25zICE9PSB0cnVlKSB7XG4gICAgICAgICAgICByZXRyeSA9IHRyYWNpbmcudW5zdGFibGVfd3JhcChyZXRyeSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0cnlDYWNoZS5hZGQod2FrZWFibGUpO1xuICAgICAgICB3YWtlYWJsZS50aGVuKHJldHJ5LCByZXRyeSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn0gLy8gVGhpcyBmdW5jdGlvbiBkZXRlY3RzIHdoZW4gYSBTdXNwZW5zZSBib3VuZGFyeSBnb2VzIGZyb20gdmlzaWJsZSB0byBoaWRkZW4uXG4vLyBJdCByZXR1cm5zIGZhbHNlIGlmIHRoZSBib3VuZGFyeSBpcyBhbHJlYWR5IGhpZGRlbi5cbi8vIFRPRE86IFVzZSBhbiBlZmZlY3QgdGFnLlxuXG5cbmZ1bmN0aW9uIGlzU3VzcGVuc2VCb3VuZGFyeUJlaW5nSGlkZGVuKGN1cnJlbnQsIGZpbmlzaGVkV29yaykge1xuICBpZiAoY3VycmVudCAhPT0gbnVsbCkge1xuICAgIHZhciBvbGRTdGF0ZSA9IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZTtcblxuICAgIGlmIChvbGRTdGF0ZSA9PT0gbnVsbCB8fCBvbGRTdGF0ZS5kZWh5ZHJhdGVkICE9PSBudWxsKSB7XG4gICAgICB2YXIgbmV3U3RhdGUgPSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRTdGF0ZTtcbiAgICAgIHJldHVybiBuZXdTdGF0ZSAhPT0gbnVsbCAmJiBuZXdTdGF0ZS5kZWh5ZHJhdGVkID09PSBudWxsO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gY29tbWl0UmVzZXRUZXh0Q29udGVudChjdXJyZW50KSB7XG5cbiAgcmVzZXRUZXh0Q29udGVudChjdXJyZW50LnN0YXRlTm9kZSk7XG59XG5cbnZhciBDT01QT05FTlRfVFlQRSA9IDA7XG52YXIgSEFTX1BTRVVET19DTEFTU19UWVBFID0gMTtcbnZhciBST0xFX1RZUEUgPSAyO1xudmFyIFRFU1RfTkFNRV9UWVBFID0gMztcbnZhciBURVhUX1RZUEUgPSA0O1xuXG5pZiAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wuZm9yKSB7XG4gIHZhciBzeW1ib2xGb3IkMSA9IFN5bWJvbC5mb3I7XG4gIENPTVBPTkVOVF9UWVBFID0gc3ltYm9sRm9yJDEoJ3NlbGVjdG9yLmNvbXBvbmVudCcpO1xuICBIQVNfUFNFVURPX0NMQVNTX1RZUEUgPSBzeW1ib2xGb3IkMSgnc2VsZWN0b3IuaGFzX3BzZXVkb19jbGFzcycpO1xuICBST0xFX1RZUEUgPSBzeW1ib2xGb3IkMSgnc2VsZWN0b3Iucm9sZScpO1xuICBURVNUX05BTUVfVFlQRSA9IHN5bWJvbEZvciQxKCdzZWxlY3Rvci50ZXN0X2lkJyk7XG4gIFRFWFRfVFlQRSA9IHN5bWJvbEZvciQxKCdzZWxlY3Rvci50ZXh0Jyk7XG59XG52YXIgY29tbWl0SG9va3MgPSBbXTtcbmZ1bmN0aW9uIG9uQ29tbWl0Um9vdCQxKCkge1xuICB7XG4gICAgY29tbWl0SG9va3MuZm9yRWFjaChmdW5jdGlvbiAoY29tbWl0SG9vaykge1xuICAgICAgcmV0dXJuIGNvbW1pdEhvb2soKTtcbiAgICB9KTtcbiAgfVxufVxuXG52YXIgY2VpbCA9IE1hdGguY2VpbDtcbnZhciBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDIgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdEN1cnJlbnREaXNwYXRjaGVyLFxuICAgIFJlYWN0Q3VycmVudE93bmVyJDIgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdEN1cnJlbnRPd25lcixcbiAgICBJc1NvbWVSZW5kZXJlckFjdGluZyA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLklzU29tZVJlbmRlcmVyQWN0aW5nO1xudmFyIE5vQ29udGV4dCA9XG4vKiAgICAgICAgICAgICAqL1xuMDtcbnZhciBCYXRjaGVkQ29udGV4dCA9XG4vKiAgICAgICAgICAgICAgICovXG4xO1xudmFyIEV2ZW50Q29udGV4dCA9XG4vKiAgICAgICAgICAgICAgICAgKi9cbjI7XG52YXIgRGlzY3JldGVFdmVudENvbnRleHQgPVxuLyogICAgICAgICAqL1xuNDtcbnZhciBMZWdhY3lVbmJhdGNoZWRDb250ZXh0ID1cbi8qICAgICAgICovXG44O1xudmFyIFJlbmRlckNvbnRleHQgPVxuLyogICAgICAgICAgICAgICAgKi9cbjE2O1xudmFyIENvbW1pdENvbnRleHQgPVxuLyogICAgICAgICAgICAgICAgKi9cbjMyO1xudmFyIFJldHJ5QWZ0ZXJFcnJvciA9XG4vKiAgICAgICAqL1xuNjQ7XG52YXIgUm9vdEluY29tcGxldGUgPSAwO1xudmFyIFJvb3RGYXRhbEVycm9yZWQgPSAxO1xudmFyIFJvb3RFcnJvcmVkID0gMjtcbnZhciBSb290U3VzcGVuZGVkID0gMztcbnZhciBSb290U3VzcGVuZGVkV2l0aERlbGF5ID0gNDtcbnZhciBSb290Q29tcGxldGVkID0gNTsgLy8gRGVzY3JpYmVzIHdoZXJlIHdlIGFyZSBpbiB0aGUgUmVhY3QgZXhlY3V0aW9uIHN0YWNrXG5cbnZhciBleGVjdXRpb25Db250ZXh0ID0gTm9Db250ZXh0OyAvLyBUaGUgcm9vdCB3ZSdyZSB3b3JraW5nIG9uXG5cbnZhciB3b3JrSW5Qcm9ncmVzc1Jvb3QgPSBudWxsOyAvLyBUaGUgZmliZXIgd2UncmUgd29ya2luZyBvblxuXG52YXIgd29ya0luUHJvZ3Jlc3MgPSBudWxsOyAvLyBUaGUgbGFuZXMgd2UncmUgcmVuZGVyaW5nXG5cbnZhciB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyA9IE5vTGFuZXM7IC8vIFN0YWNrIHRoYXQgYWxsb3dzIGNvbXBvbmVudHMgdG8gY2hhbmdlIHRoZSByZW5kZXIgbGFuZXMgZm9yIGl0cyBzdWJ0cmVlXG4vLyBUaGlzIGlzIGEgc3VwZXJzZXQgb2YgdGhlIGxhbmVzIHdlIHN0YXJ0ZWQgd29ya2luZyBvbiBhdCB0aGUgcm9vdC4gVGhlIG9ubHlcbi8vIGNhc2Ugd2hlcmUgaXQncyBkaWZmZXJlbnQgZnJvbSBgd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXNgIGlzIHdoZW4gd2Vcbi8vIGVudGVyIGEgc3VidHJlZSB0aGF0IGlzIGhpZGRlbiBhbmQgbmVlZHMgdG8gYmUgdW5oaWRkZW46IFN1c3BlbnNlIGFuZFxuLy8gT2Zmc2NyZWVuIGNvbXBvbmVudC5cbi8vXG4vLyBNb3N0IHRoaW5ncyBpbiB0aGUgd29yayBsb29wIHNob3VsZCBkZWFsIHdpdGggd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMuXG4vLyBNb3N0IHRoaW5ncyBpbiBiZWdpbi9jb21wbGV0ZSBwaGFzZXMgc2hvdWxkIGRlYWwgd2l0aCBzdWJ0cmVlUmVuZGVyTGFuZXMuXG5cbnZhciBzdWJ0cmVlUmVuZGVyTGFuZXMgPSBOb0xhbmVzO1xudmFyIHN1YnRyZWVSZW5kZXJMYW5lc0N1cnNvciA9IGNyZWF0ZUN1cnNvcihOb0xhbmVzKTsgLy8gV2hldGhlciB0byByb290IGNvbXBsZXRlZCwgZXJyb3JlZCwgc3VzcGVuZGVkLCBldGMuXG5cbnZhciB3b3JrSW5Qcm9ncmVzc1Jvb3RFeGl0U3RhdHVzID0gUm9vdEluY29tcGxldGU7IC8vIEEgZmF0YWwgZXJyb3IsIGlmIG9uZSBpcyB0aHJvd25cblxudmFyIHdvcmtJblByb2dyZXNzUm9vdEZhdGFsRXJyb3IgPSBudWxsOyAvLyBcIkluY2x1ZGVkXCIgbGFuZXMgcmVmZXIgdG8gbGFuZXMgdGhhdCB3ZXJlIHdvcmtlZCBvbiBkdXJpbmcgdGhpcyByZW5kZXIuIEl0J3Ncbi8vIHNsaWdodGx5IGRpZmZlcmVudCB0aGFuIGByZW5kZXJMYW5lc2AgYmVjYXVzZSBgcmVuZGVyTGFuZXNgIGNhbiBjaGFuZ2UgYXMgeW91XG4vLyBlbnRlciBhbmQgZXhpdCBhbiBPZmZzY3JlZW4gdHJlZS4gVGhpcyB2YWx1ZSBpcyB0aGUgY29tYmluYXRpb24gb2YgYWxsIHJlbmRlclxuLy8gbGFuZXMgZm9yIHRoZSBlbnRpcmUgcmVuZGVyIHBoYXNlLlxuXG52YXIgd29ya0luUHJvZ3Jlc3NSb290SW5jbHVkZWRMYW5lcyA9IE5vTGFuZXM7IC8vIFRoZSB3b3JrIGxlZnQgb3ZlciBieSBjb21wb25lbnRzIHRoYXQgd2VyZSB2aXNpdGVkIGR1cmluZyB0aGlzIHJlbmRlci4gT25seVxuLy8gaW5jbHVkZXMgdW5wcm9jZXNzZWQgdXBkYXRlcywgbm90IHdvcmsgaW4gYmFpbGVkIG91dCBjaGlsZHJlbi5cblxudmFyIHdvcmtJblByb2dyZXNzUm9vdFNraXBwZWRMYW5lcyA9IE5vTGFuZXM7IC8vIExhbmVzIHRoYXQgd2VyZSB1cGRhdGVkIChpbiBhbiBpbnRlcmxlYXZlZCBldmVudCkgZHVyaW5nIHRoaXMgcmVuZGVyLlxuXG52YXIgd29ya0luUHJvZ3Jlc3NSb290VXBkYXRlZExhbmVzID0gTm9MYW5lczsgLy8gTGFuZXMgdGhhdCB3ZXJlIHBpbmdlZCAoaW4gYW4gaW50ZXJsZWF2ZWQgZXZlbnQpIGR1cmluZyB0aGlzIHJlbmRlci5cblxudmFyIHdvcmtJblByb2dyZXNzUm9vdFBpbmdlZExhbmVzID0gTm9MYW5lcztcbnZhciBtb3N0UmVjZW50bHlVcGRhdGVkUm9vdCA9IG51bGw7IC8vIFRoZSBtb3N0IHJlY2VudCB0aW1lIHdlIGNvbW1pdHRlZCBhIGZhbGxiYWNrLiBUaGlzIGxldHMgdXMgZW5zdXJlIGEgdHJhaW5cbi8vIG1vZGVsIHdoZXJlIHdlIGRvbid0IGNvbW1pdCBuZXcgbG9hZGluZyBzdGF0ZXMgaW4gdG9vIHF1aWNrIHN1Y2Nlc3Npb24uXG5cbnZhciBnbG9iYWxNb3N0UmVjZW50RmFsbGJhY2tUaW1lID0gMDtcbnZhciBGQUxMQkFDS19USFJPVFRMRV9NUyA9IDUwMDsgLy8gVGhlIGFic29sdXRlIHRpbWUgZm9yIHdoZW4gd2Ugc2hvdWxkIHN0YXJ0IGdpdmluZyB1cCBvbiByZW5kZXJpbmdcbi8vIG1vcmUgYW5kIHByZWZlciBDUFUgc3VzcGVuc2UgaGV1cmlzdGljcyBpbnN0ZWFkLlxuXG52YXIgd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyVGFyZ2V0VGltZSA9IEluZmluaXR5OyAvLyBIb3cgbG9uZyBhIHJlbmRlciBpcyBzdXBwb3NlZCB0byB0YWtlIGJlZm9yZSB3ZSBzdGFydCBmb2xsb3dpbmcgQ1BVXG4vLyBzdXNwZW5zZSBoZXVyaXN0aWNzIGFuZCBvcHQgb3V0IG9mIHJlbmRlcmluZyBtb3JlIGNvbnRlbnQuXG5cbnZhciBSRU5ERVJfVElNRU9VVF9NUyA9IDUwMDtcblxuZnVuY3Rpb24gcmVzZXRSZW5kZXJUaW1lcigpIHtcbiAgd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyVGFyZ2V0VGltZSA9IG5vdygpICsgUkVOREVSX1RJTUVPVVRfTVM7XG59XG5cbmZ1bmN0aW9uIGdldFJlbmRlclRhcmdldFRpbWUoKSB7XG4gIHJldHVybiB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJUYXJnZXRUaW1lO1xufVxudmFyIG5leHRFZmZlY3QgPSBudWxsO1xudmFyIGhhc1VuY2F1Z2h0RXJyb3IgPSBmYWxzZTtcbnZhciBmaXJzdFVuY2F1Z2h0RXJyb3IgPSBudWxsO1xudmFyIGxlZ2FjeUVycm9yQm91bmRhcmllc1RoYXRBbHJlYWR5RmFpbGVkID0gbnVsbDtcbnZhciByb290RG9lc0hhdmVQYXNzaXZlRWZmZWN0cyA9IGZhbHNlO1xudmFyIHJvb3RXaXRoUGVuZGluZ1Bhc3NpdmVFZmZlY3RzID0gbnVsbDtcbnZhciBwZW5kaW5nUGFzc2l2ZUVmZmVjdHNSZW5kZXJQcmlvcml0eSA9IE5vUHJpb3JpdHkkMTtcbnZhciBwZW5kaW5nUGFzc2l2ZUVmZmVjdHNMYW5lcyA9IE5vTGFuZXM7XG52YXIgcGVuZGluZ1Bhc3NpdmVIb29rRWZmZWN0c01vdW50ID0gW107XG52YXIgcGVuZGluZ1Bhc3NpdmVIb29rRWZmZWN0c1VubW91bnQgPSBbXTtcbnZhciByb290c1dpdGhQZW5kaW5nRGlzY3JldGVVcGRhdGVzID0gbnVsbDsgLy8gVXNlIHRoZXNlIHRvIHByZXZlbnQgYW4gaW5maW5pdGUgbG9vcCBvZiBuZXN0ZWQgdXBkYXRlc1xuXG52YXIgTkVTVEVEX1VQREFURV9MSU1JVCA9IDUwO1xudmFyIG5lc3RlZFVwZGF0ZUNvdW50ID0gMDtcbnZhciByb290V2l0aE5lc3RlZFVwZGF0ZXMgPSBudWxsO1xudmFyIE5FU1RFRF9QQVNTSVZFX1VQREFURV9MSU1JVCA9IDUwO1xudmFyIG5lc3RlZFBhc3NpdmVVcGRhdGVDb3VudCA9IDA7IC8vIE1hcmtzIHRoZSBuZWVkIHRvIHJlc2NoZWR1bGUgcGVuZGluZyBpbnRlcmFjdGlvbnMgYXQgdGhlc2UgbGFuZXNcbi8vIGR1cmluZyB0aGUgY29tbWl0IHBoYXNlLiBUaGlzIGVuYWJsZXMgdGhlbSB0byBiZSB0cmFjZWQgYWNyb3NzIGNvbXBvbmVudHNcbi8vIHRoYXQgc3Bhd24gbmV3IHdvcmsgZHVyaW5nIHJlbmRlci4gRS5nLiBoaWRkZW4gYm91bmRhcmllcywgc3VzcGVuZGVkIFNTUlxuLy8gaHlkcmF0aW9uIG9yIFN1c3BlbnNlTGlzdC5cbi8vIFRPRE86IENhbiB1c2UgYSBiaXRtYXNrIGluc3RlYWQgb2YgYW4gYXJyYXlcblxudmFyIHNwYXduZWRXb3JrRHVyaW5nUmVuZGVyID0gbnVsbDsgLy8gSWYgdHdvIHVwZGF0ZXMgYXJlIHNjaGVkdWxlZCB3aXRoaW4gdGhlIHNhbWUgZXZlbnQsIHdlIHNob3VsZCB0cmVhdCB0aGVpclxuLy8gZXZlbnQgdGltZXMgYXMgc2ltdWx0YW5lb3VzLCBldmVuIGlmIHRoZSBhY3R1YWwgY2xvY2sgdGltZSBoYXMgYWR2YW5jZWRcbi8vIGJldHdlZW4gdGhlIGZpcnN0IGFuZCBzZWNvbmQgY2FsbC5cblxudmFyIGN1cnJlbnRFdmVudFRpbWUgPSBOb1RpbWVzdGFtcDtcbnZhciBjdXJyZW50RXZlbnRXaXBMYW5lcyA9IE5vTGFuZXM7XG52YXIgY3VycmVudEV2ZW50UGVuZGluZ0xhbmVzID0gTm9MYW5lczsgLy8gRGV2IG9ubHkgZmxhZyB0aGF0IHRyYWNrcyBpZiBwYXNzaXZlIGVmZmVjdHMgYXJlIGN1cnJlbnRseSBiZWluZyBmbHVzaGVkLlxuLy8gV2Ugd2FybiBhYm91dCBzdGF0ZSB1cGRhdGVzIGZvciB1bm1vdW50ZWQgY29tcG9uZW50cyBkaWZmZXJlbnRseSBpbiB0aGlzIGNhc2UuXG5cbnZhciBpc0ZsdXNoaW5nUGFzc2l2ZUVmZmVjdHMgPSBmYWxzZTtcbnZhciBmb2N1c2VkSW5zdGFuY2VIYW5kbGUgPSBudWxsO1xudmFyIHNob3VsZEZpcmVBZnRlckFjdGl2ZUluc3RhbmNlQmx1ciA9IGZhbHNlO1xuZnVuY3Rpb24gZ2V0V29ya0luUHJvZ3Jlc3NSb290KCkge1xuICByZXR1cm4gd29ya0luUHJvZ3Jlc3NSb290O1xufVxuZnVuY3Rpb24gcmVxdWVzdEV2ZW50VGltZSgpIHtcbiAgaWYgKChleGVjdXRpb25Db250ZXh0ICYgKFJlbmRlckNvbnRleHQgfCBDb21taXRDb250ZXh0KSkgIT09IE5vQ29udGV4dCkge1xuICAgIC8vIFdlJ3JlIGluc2lkZSBSZWFjdCwgc28gaXQncyBmaW5lIHRvIHJlYWQgdGhlIGFjdHVhbCB0aW1lLlxuICAgIHJldHVybiBub3coKTtcbiAgfSAvLyBXZSdyZSBub3QgaW5zaWRlIFJlYWN0LCBzbyB3ZSBtYXkgYmUgaW4gdGhlIG1pZGRsZSBvZiBhIGJyb3dzZXIgZXZlbnQuXG5cblxuICBpZiAoY3VycmVudEV2ZW50VGltZSAhPT0gTm9UaW1lc3RhbXApIHtcbiAgICAvLyBVc2UgdGhlIHNhbWUgc3RhcnQgdGltZSBmb3IgYWxsIHVwZGF0ZXMgdW50aWwgd2UgZW50ZXIgUmVhY3QgYWdhaW4uXG4gICAgcmV0dXJuIGN1cnJlbnRFdmVudFRpbWU7XG4gIH0gLy8gVGhpcyBpcyB0aGUgZmlyc3QgdXBkYXRlIHNpbmNlIFJlYWN0IHlpZWxkZWQuIENvbXB1dGUgYSBuZXcgc3RhcnQgdGltZS5cblxuXG4gIGN1cnJlbnRFdmVudFRpbWUgPSBub3coKTtcbiAgcmV0dXJuIGN1cnJlbnRFdmVudFRpbWU7XG59XG5mdW5jdGlvbiByZXF1ZXN0VXBkYXRlTGFuZShmaWJlcikge1xuICAvLyBTcGVjaWFsIGNhc2VzXG4gIHZhciBtb2RlID0gZmliZXIubW9kZTtcblxuICBpZiAoKG1vZGUgJiBCbG9ja2luZ01vZGUpID09PSBOb01vZGUpIHtcbiAgICByZXR1cm4gU3luY0xhbmU7XG4gIH0gZWxzZSBpZiAoKG1vZGUgJiBDb25jdXJyZW50TW9kZSkgPT09IE5vTW9kZSkge1xuICAgIHJldHVybiBnZXRDdXJyZW50UHJpb3JpdHlMZXZlbCgpID09PSBJbW1lZGlhdGVQcmlvcml0eSQxID8gU3luY0xhbmUgOiBTeW5jQmF0Y2hlZExhbmU7XG4gIH0gLy8gVGhlIGFsZ29yaXRobSBmb3IgYXNzaWduaW5nIGFuIHVwZGF0ZSB0byBhIGxhbmUgc2hvdWxkIGJlIHN0YWJsZSBmb3IgYWxsXG4gIC8vIHVwZGF0ZXMgYXQgdGhlIHNhbWUgcHJpb3JpdHkgd2l0aGluIHRoZSBzYW1lIGV2ZW50LiBUbyBkbyB0aGlzLCB0aGUgaW5wdXRzXG4gIC8vIHRvIHRoZSBhbGdvcml0aG0gbXVzdCBiZSB0aGUgc2FtZS4gRm9yIGV4YW1wbGUsIHdlIHVzZSB0aGUgYHJlbmRlckxhbmVzYFxuICAvLyB0byBhdm9pZCBjaG9vc2luZyBhIGxhbmUgdGhhdCBpcyBhbHJlYWR5IGluIHRoZSBtaWRkbGUgb2YgcmVuZGVyaW5nLlxuICAvL1xuICAvLyBIb3dldmVyLCB0aGUgXCJpbmNsdWRlZFwiIGxhbmVzIGNvdWxkIGJlIG11dGF0ZWQgaW4gYmV0d2VlbiB1cGRhdGVzIGluIHRoZVxuICAvLyBzYW1lIGV2ZW50LCBsaWtlIGlmIHlvdSBwZXJmb3JtIGFuIHVwZGF0ZSBpbnNpZGUgYGZsdXNoU3luY2AuIE9yIGFueSBvdGhlclxuICAvLyBjb2RlIHBhdGggdGhhdCBtaWdodCBjYWxsIGBwcmVwYXJlRnJlc2hTdGFja2AuXG4gIC8vXG4gIC8vIFRoZSB0cmljayB3ZSB1c2UgaXMgdG8gY2FjaGUgdGhlIGZpcnN0IG9mIGVhY2ggb2YgdGhlc2UgaW5wdXRzIHdpdGhpbiBhblxuICAvLyBldmVudC4gVGhlbiByZXNldCB0aGUgY2FjaGVkIHZhbHVlcyBvbmNlIHdlIGNhbiBiZSBzdXJlIHRoZSBldmVudCBpcyBvdmVyLlxuICAvLyBPdXIgaGV1cmlzdGljIGZvciB0aGF0IGlzIHdoZW5ldmVyIHdlIGVudGVyIGEgY29uY3VycmVudCB3b3JrIGxvb3AuXG4gIC8vXG4gIC8vIFdlJ2xsIGRvIHRoZSBzYW1lIGZvciBgY3VycmVudEV2ZW50UGVuZGluZ0xhbmVzYCBiZWxvdy5cblxuXG4gIGlmIChjdXJyZW50RXZlbnRXaXBMYW5lcyA9PT0gTm9MYW5lcykge1xuICAgIGN1cnJlbnRFdmVudFdpcExhbmVzID0gd29ya0luUHJvZ3Jlc3NSb290SW5jbHVkZWRMYW5lcztcbiAgfVxuXG4gIHZhciBpc1RyYW5zaXRpb24gPSByZXF1ZXN0Q3VycmVudFRyYW5zaXRpb24oKSAhPT0gTm9UcmFuc2l0aW9uO1xuXG4gIGlmIChpc1RyYW5zaXRpb24pIHtcbiAgICBpZiAoY3VycmVudEV2ZW50UGVuZGluZ0xhbmVzICE9PSBOb0xhbmVzKSB7XG4gICAgICBjdXJyZW50RXZlbnRQZW5kaW5nTGFuZXMgPSBtb3N0UmVjZW50bHlVcGRhdGVkUm9vdCAhPT0gbnVsbCA/IG1vc3RSZWNlbnRseVVwZGF0ZWRSb290LnBlbmRpbmdMYW5lcyA6IE5vTGFuZXM7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZpbmRUcmFuc2l0aW9uTGFuZShjdXJyZW50RXZlbnRXaXBMYW5lcywgY3VycmVudEV2ZW50UGVuZGluZ0xhbmVzKTtcbiAgfSAvLyBUT0RPOiBSZW1vdmUgdGhpcyBkZXBlbmRlbmN5IG9uIHRoZSBTY2hlZHVsZXIgcHJpb3JpdHkuXG4gIC8vIFRvIGRvIHRoYXQsIHdlJ3JlIHJlcGxhY2luZyBpdCB3aXRoIGFuIHVwZGF0ZSBsYW5lIHByaW9yaXR5LlxuXG5cbiAgdmFyIHNjaGVkdWxlclByaW9yaXR5ID0gZ2V0Q3VycmVudFByaW9yaXR5TGV2ZWwoKTsgLy8gVGhlIG9sZCBiZWhhdmlvciB3YXMgdXNpbmcgdGhlIHByaW9yaXR5IGxldmVsIG9mIHRoZSBTY2hlZHVsZXIuXG4gIC8vIFRoaXMgY291cGxlcyBSZWFjdCB0byB0aGUgU2NoZWR1bGVyIGludGVybmFscywgc28gd2UncmUgcmVwbGFjaW5nIGl0XG4gIC8vIHdpdGggdGhlIGN1cnJlbnRVcGRhdGVMYW5lUHJpb3JpdHkgYWJvdmUuIEFzIGFuIGV4YW1wbGUgb2YgaG93IHRoaXNcbiAgLy8gY291bGQgYmUgcHJvYmxlbWF0aWMsIGlmIHdlJ3JlIG5vdCBpbnNpZGUgYFNjaGVkdWxlci5ydW5XaXRoUHJpb3JpdHlgLFxuICAvLyB0aGVuIHdlJ2xsIGdldCB0aGUgcHJpb3JpdHkgb2YgdGhlIGN1cnJlbnQgcnVubmluZyBTY2hlZHVsZXIgdGFzayxcbiAgLy8gd2hpY2ggaXMgcHJvYmFibHkgbm90IHdoYXQgd2Ugd2FudC5cblxuICB2YXIgbGFuZTtcblxuICBpZiAoIC8vIFRPRE86IFRlbXBvcmFyeS4gV2UncmUgcmVtb3ZpbmcgdGhlIGNvbmNlcHQgb2YgZGlzY3JldGUgdXBkYXRlcy5cbiAgKGV4ZWN1dGlvbkNvbnRleHQgJiBEaXNjcmV0ZUV2ZW50Q29udGV4dCkgIT09IE5vQ29udGV4dCAmJiBzY2hlZHVsZXJQcmlvcml0eSA9PT0gVXNlckJsb2NraW5nUHJpb3JpdHkkMikge1xuICAgIGxhbmUgPSBmaW5kVXBkYXRlTGFuZShJbnB1dERpc2NyZXRlTGFuZVByaW9yaXR5LCBjdXJyZW50RXZlbnRXaXBMYW5lcyk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIHNjaGVkdWxlckxhbmVQcmlvcml0eSA9IHNjaGVkdWxlclByaW9yaXR5VG9MYW5lUHJpb3JpdHkoc2NoZWR1bGVyUHJpb3JpdHkpO1xuXG4gICAgbGFuZSA9IGZpbmRVcGRhdGVMYW5lKHNjaGVkdWxlckxhbmVQcmlvcml0eSwgY3VycmVudEV2ZW50V2lwTGFuZXMpO1xuICB9XG5cbiAgcmV0dXJuIGxhbmU7XG59XG5cbmZ1bmN0aW9uIHJlcXVlc3RSZXRyeUxhbmUoZmliZXIpIHtcbiAgLy8gVGhpcyBpcyBhIGZvcmsgb2YgYHJlcXVlc3RVcGRhdGVMYW5lYCBkZXNpZ25lZCBzcGVjaWZpY2FsbHkgZm9yIFN1c3BlbnNlXG4gIC8vIFwicmV0cmllc1wiIOKAlCBhIHNwZWNpYWwgdXBkYXRlIHRoYXQgYXR0ZW1wdHMgdG8gZmxpcCBhIFN1c3BlbnNlIGJvdW5kYXJ5XG4gIC8vIGZyb20gaXRzIHBsYWNlaG9sZGVyIHN0YXRlIHRvIGl0cyBwcmltYXJ5L3Jlc29sdmVkIHN0YXRlLlxuICAvLyBTcGVjaWFsIGNhc2VzXG4gIHZhciBtb2RlID0gZmliZXIubW9kZTtcblxuICBpZiAoKG1vZGUgJiBCbG9ja2luZ01vZGUpID09PSBOb01vZGUpIHtcbiAgICByZXR1cm4gU3luY0xhbmU7XG4gIH0gZWxzZSBpZiAoKG1vZGUgJiBDb25jdXJyZW50TW9kZSkgPT09IE5vTW9kZSkge1xuICAgIHJldHVybiBnZXRDdXJyZW50UHJpb3JpdHlMZXZlbCgpID09PSBJbW1lZGlhdGVQcmlvcml0eSQxID8gU3luY0xhbmUgOiBTeW5jQmF0Y2hlZExhbmU7XG4gIH0gLy8gU2VlIGByZXF1ZXN0VXBkYXRlTGFuZWAgZm9yIGV4cGxhbmF0aW9uIG9mIGBjdXJyZW50RXZlbnRXaXBMYW5lc2BcblxuXG4gIGlmIChjdXJyZW50RXZlbnRXaXBMYW5lcyA9PT0gTm9MYW5lcykge1xuICAgIGN1cnJlbnRFdmVudFdpcExhbmVzID0gd29ya0luUHJvZ3Jlc3NSb290SW5jbHVkZWRMYW5lcztcbiAgfVxuXG4gIHJldHVybiBmaW5kUmV0cnlMYW5lKGN1cnJlbnRFdmVudFdpcExhbmVzKTtcbn1cblxuZnVuY3Rpb24gc2NoZWR1bGVVcGRhdGVPbkZpYmVyKGZpYmVyLCBsYW5lLCBldmVudFRpbWUpIHtcbiAgY2hlY2tGb3JOZXN0ZWRVcGRhdGVzKCk7XG4gIHdhcm5BYm91dFJlbmRlclBoYXNlVXBkYXRlc0luREVWKGZpYmVyKTtcbiAgdmFyIHJvb3QgPSBtYXJrVXBkYXRlTGFuZUZyb21GaWJlclRvUm9vdChmaWJlciwgbGFuZSk7XG5cbiAgaWYgKHJvb3QgPT09IG51bGwpIHtcbiAgICB3YXJuQWJvdXRVcGRhdGVPblVubW91bnRlZEZpYmVySW5ERVYoZmliZXIpO1xuICAgIHJldHVybiBudWxsO1xuICB9IC8vIE1hcmsgdGhhdCB0aGUgcm9vdCBoYXMgYSBwZW5kaW5nIHVwZGF0ZS5cblxuXG4gIG1hcmtSb290VXBkYXRlZChyb290LCBsYW5lLCBldmVudFRpbWUpO1xuXG4gIGlmIChyb290ID09PSB3b3JrSW5Qcm9ncmVzc1Jvb3QpIHtcbiAgICAvLyBSZWNlaXZlZCBhbiB1cGRhdGUgdG8gYSB0cmVlIHRoYXQncyBpbiB0aGUgbWlkZGxlIG9mIHJlbmRlcmluZy4gTWFya1xuICAgIC8vIHRoYXQgdGhlcmUgd2FzIGFuIGludGVybGVhdmVkIHVwZGF0ZSB3b3JrIG9uIHRoaXMgcm9vdC4gVW5sZXNzIHRoZVxuICAgIC8vIGBkZWZlclJlbmRlclBoYXNlVXBkYXRlVG9OZXh0QmF0Y2hgIGZsYWcgaXMgb2ZmIGFuZCB0aGlzIGlzIGEgcmVuZGVyXG4gICAgLy8gcGhhc2UgdXBkYXRlLiBJbiB0aGF0IGNhc2UsIHdlIGRvbid0IHRyZWF0IHJlbmRlciBwaGFzZSB1cGRhdGVzIGFzIGlmXG4gICAgLy8gdGhleSB3ZXJlIGludGVybGVhdmVkLCBmb3IgYmFja3dhcmRzIGNvbXBhdCByZWFzb25zLlxuICAgIHtcbiAgICAgIHdvcmtJblByb2dyZXNzUm9vdFVwZGF0ZWRMYW5lcyA9IG1lcmdlTGFuZXMod29ya0luUHJvZ3Jlc3NSb290VXBkYXRlZExhbmVzLCBsYW5lKTtcbiAgICB9XG5cbiAgICBpZiAod29ya0luUHJvZ3Jlc3NSb290RXhpdFN0YXR1cyA9PT0gUm9vdFN1c3BlbmRlZFdpdGhEZWxheSkge1xuICAgICAgLy8gVGhlIHJvb3QgYWxyZWFkeSBzdXNwZW5kZWQgd2l0aCBhIGRlbGF5LCB3aGljaCBtZWFucyB0aGlzIHJlbmRlclxuICAgICAgLy8gZGVmaW5pdGVseSB3b24ndCBmaW5pc2guIFNpbmNlIHdlIGhhdmUgYSBuZXcgdXBkYXRlLCBsZXQncyBtYXJrIGl0IGFzXG4gICAgICAvLyBzdXNwZW5kZWQgbm93LCByaWdodCBiZWZvcmUgbWFya2luZyB0aGUgaW5jb21pbmcgdXBkYXRlLiBUaGlzIGhhcyB0aGVcbiAgICAgIC8vIGVmZmVjdCBvZiBpbnRlcnJ1cHRpbmcgdGhlIGN1cnJlbnQgcmVuZGVyIGFuZCBzd2l0Y2hpbmcgdG8gdGhlIHVwZGF0ZS5cbiAgICAgIC8vIFRPRE86IE1ha2Ugc3VyZSB0aGlzIGRvZXNuJ3Qgb3ZlcnJpZGUgcGluZ3MgdGhhdCBoYXBwZW4gd2hpbGUgd2UndmVcbiAgICAgIC8vIGFscmVhZHkgc3RhcnRlZCByZW5kZXJpbmcuXG4gICAgICBtYXJrUm9vdFN1c3BlbmRlZCQxKHJvb3QsIHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzKTtcbiAgICB9XG4gIH0gLy8gVE9ETzogcmVxdWVzdFVwZGF0ZUxhbmVQcmlvcml0eSBhbHNvIHJlYWRzIHRoZSBwcmlvcml0eS4gUGFzcyB0aGVcbiAgLy8gcHJpb3JpdHkgYXMgYW4gYXJndW1lbnQgdG8gdGhhdCBmdW5jdGlvbiBhbmQgdGhpcyBvbmUuXG5cblxuICB2YXIgcHJpb3JpdHlMZXZlbCA9IGdldEN1cnJlbnRQcmlvcml0eUxldmVsKCk7XG5cbiAgaWYgKGxhbmUgPT09IFN5bmNMYW5lKSB7XG4gICAgaWYgKCAvLyBDaGVjayBpZiB3ZSdyZSBpbnNpZGUgdW5iYXRjaGVkVXBkYXRlc1xuICAgIChleGVjdXRpb25Db250ZXh0ICYgTGVnYWN5VW5iYXRjaGVkQ29udGV4dCkgIT09IE5vQ29udGV4dCAmJiAvLyBDaGVjayBpZiB3ZSdyZSBub3QgYWxyZWFkeSByZW5kZXJpbmdcbiAgICAoZXhlY3V0aW9uQ29udGV4dCAmIChSZW5kZXJDb250ZXh0IHwgQ29tbWl0Q29udGV4dCkpID09PSBOb0NvbnRleHQpIHtcbiAgICAgIC8vIFJlZ2lzdGVyIHBlbmRpbmcgaW50ZXJhY3Rpb25zIG9uIHRoZSByb290IHRvIGF2b2lkIGxvc2luZyB0cmFjZWQgaW50ZXJhY3Rpb24gZGF0YS5cbiAgICAgIHNjaGVkdWxlUGVuZGluZ0ludGVyYWN0aW9ucyhyb290LCBsYW5lKTsgLy8gVGhpcyBpcyBhIGxlZ2FjeSBlZGdlIGNhc2UuIFRoZSBpbml0aWFsIG1vdW50IG9mIGEgUmVhY3RET00ucmVuZGVyLWVkXG4gICAgICAvLyByb290IGluc2lkZSBvZiBiYXRjaGVkVXBkYXRlcyBzaG91bGQgYmUgc3luY2hyb25vdXMsIGJ1dCBsYXlvdXQgdXBkYXRlc1xuICAgICAgLy8gc2hvdWxkIGJlIGRlZmVycmVkIHVudGlsIHRoZSBlbmQgb2YgdGhlIGJhdGNoLlxuXG4gICAgICBwZXJmb3JtU3luY1dvcmtPblJvb3Qocm9vdCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVuc3VyZVJvb3RJc1NjaGVkdWxlZChyb290LCBldmVudFRpbWUpO1xuICAgICAgc2NoZWR1bGVQZW5kaW5nSW50ZXJhY3Rpb25zKHJvb3QsIGxhbmUpO1xuXG4gICAgICBpZiAoZXhlY3V0aW9uQ29udGV4dCA9PT0gTm9Db250ZXh0KSB7XG4gICAgICAgIC8vIEZsdXNoIHRoZSBzeW5jaHJvbm91cyB3b3JrIG5vdywgdW5sZXNzIHdlJ3JlIGFscmVhZHkgd29ya2luZyBvciBpbnNpZGVcbiAgICAgICAgLy8gYSBiYXRjaC4gVGhpcyBpcyBpbnRlbnRpb25hbGx5IGluc2lkZSBzY2hlZHVsZVVwZGF0ZU9uRmliZXIgaW5zdGVhZCBvZlxuICAgICAgICAvLyBzY2hlZHVsZUNhbGxiYWNrRm9yRmliZXIgdG8gcHJlc2VydmUgdGhlIGFiaWxpdHkgdG8gc2NoZWR1bGUgYSBjYWxsYmFja1xuICAgICAgICAvLyB3aXRob3V0IGltbWVkaWF0ZWx5IGZsdXNoaW5nIGl0LiBXZSBvbmx5IGRvIHRoaXMgZm9yIHVzZXItaW5pdGlhdGVkXG4gICAgICAgIC8vIHVwZGF0ZXMsIHRvIHByZXNlcnZlIGhpc3RvcmljYWwgYmVoYXZpb3Igb2YgbGVnYWN5IG1vZGUuXG4gICAgICAgIHJlc2V0UmVuZGVyVGltZXIoKTtcbiAgICAgICAgZmx1c2hTeW5jQ2FsbGJhY2tRdWV1ZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBTY2hlZHVsZSBhIGRpc2NyZXRlIHVwZGF0ZSBidXQgb25seSBpZiBpdCdzIG5vdCBTeW5jLlxuICAgIGlmICgoZXhlY3V0aW9uQ29udGV4dCAmIERpc2NyZXRlRXZlbnRDb250ZXh0KSAhPT0gTm9Db250ZXh0ICYmICggLy8gT25seSB1cGRhdGVzIGF0IHVzZXItYmxvY2tpbmcgcHJpb3JpdHkgb3IgZ3JlYXRlciBhcmUgY29uc2lkZXJlZFxuICAgIC8vIGRpc2NyZXRlLCBldmVuIGluc2lkZSBhIGRpc2NyZXRlIGV2ZW50LlxuICAgIHByaW9yaXR5TGV2ZWwgPT09IFVzZXJCbG9ja2luZ1ByaW9yaXR5JDIgfHwgcHJpb3JpdHlMZXZlbCA9PT0gSW1tZWRpYXRlUHJpb3JpdHkkMSkpIHtcbiAgICAgIC8vIFRoaXMgaXMgdGhlIHJlc3VsdCBvZiBhIGRpc2NyZXRlIGV2ZW50LiBUcmFjayB0aGUgbG93ZXN0IHByaW9yaXR5XG4gICAgICAvLyBkaXNjcmV0ZSB1cGRhdGUgcGVyIHJvb3Qgc28gd2UgY2FuIGZsdXNoIHRoZW0gZWFybHksIGlmIG5lZWRlZC5cbiAgICAgIGlmIChyb290c1dpdGhQZW5kaW5nRGlzY3JldGVVcGRhdGVzID09PSBudWxsKSB7XG4gICAgICAgIHJvb3RzV2l0aFBlbmRpbmdEaXNjcmV0ZVVwZGF0ZXMgPSBuZXcgU2V0KFtyb290XSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByb290c1dpdGhQZW5kaW5nRGlzY3JldGVVcGRhdGVzLmFkZChyb290KTtcbiAgICAgIH1cbiAgICB9IC8vIFNjaGVkdWxlIG90aGVyIHVwZGF0ZXMgYWZ0ZXIgaW4gY2FzZSB0aGUgY2FsbGJhY2sgaXMgc3luYy5cblxuXG4gICAgZW5zdXJlUm9vdElzU2NoZWR1bGVkKHJvb3QsIGV2ZW50VGltZSk7XG4gICAgc2NoZWR1bGVQZW5kaW5nSW50ZXJhY3Rpb25zKHJvb3QsIGxhbmUpO1xuICB9IC8vIFdlIHVzZSB0aGlzIHdoZW4gYXNzaWduaW5nIGEgbGFuZSBmb3IgYSB0cmFuc2l0aW9uIGluc2lkZVxuICAvLyBgcmVxdWVzdFVwZGF0ZUxhbmVgLiBXZSBhc3N1bWUgaXQncyB0aGUgc2FtZSBhcyB0aGUgcm9vdCBiZWluZyB1cGRhdGVkLFxuICAvLyBzaW5jZSBpbiB0aGUgY29tbW9uIGNhc2Ugb2YgYSBzaW5nbGUgcm9vdCBhcHAgaXQgcHJvYmFibHkgaXMuIElmIGl0J3Mgbm90XG4gIC8vIHRoZSBzYW1lIHJvb3QsIHRoZW4gaXQncyBub3QgYSBodWdlIGRlYWwsIHdlIGp1c3QgbWlnaHQgYmF0Y2ggbW9yZSBzdHVmZlxuICAvLyB0b2dldGhlciBtb3JlIHRoYW4gbmVjZXNzYXJ5LlxuXG5cbiAgbW9zdFJlY2VudGx5VXBkYXRlZFJvb3QgPSByb290O1xufSAvLyBUaGlzIGlzIHNwbGl0IGludG8gYSBzZXBhcmF0ZSBmdW5jdGlvbiBzbyB3ZSBjYW4gbWFyayBhIGZpYmVyIHdpdGggcGVuZGluZ1xuLy8gd29yayB3aXRob3V0IHRyZWF0aW5nIGl0IGFzIGEgdHlwaWNhbCB1cGRhdGUgdGhhdCBvcmlnaW5hdGVzIGZyb20gYW4gZXZlbnQ7XG4vLyBlLmcuIHJldHJ5aW5nIGEgU3VzcGVuc2UgYm91bmRhcnkgaXNuJ3QgYW4gdXBkYXRlLCBidXQgaXQgZG9lcyBzY2hlZHVsZSB3b3JrXG4vLyBvbiBhIGZpYmVyLlxuXG5mdW5jdGlvbiBtYXJrVXBkYXRlTGFuZUZyb21GaWJlclRvUm9vdChzb3VyY2VGaWJlciwgbGFuZSkge1xuICAvLyBVcGRhdGUgdGhlIHNvdXJjZSBmaWJlcidzIGxhbmVzXG4gIHNvdXJjZUZpYmVyLmxhbmVzID0gbWVyZ2VMYW5lcyhzb3VyY2VGaWJlci5sYW5lcywgbGFuZSk7XG4gIHZhciBhbHRlcm5hdGUgPSBzb3VyY2VGaWJlci5hbHRlcm5hdGU7XG5cbiAgaWYgKGFsdGVybmF0ZSAhPT0gbnVsbCkge1xuICAgIGFsdGVybmF0ZS5sYW5lcyA9IG1lcmdlTGFuZXMoYWx0ZXJuYXRlLmxhbmVzLCBsYW5lKTtcbiAgfVxuXG4gIHtcbiAgICBpZiAoYWx0ZXJuYXRlID09PSBudWxsICYmIChzb3VyY2VGaWJlci5mbGFncyAmIChQbGFjZW1lbnQgfCBIeWRyYXRpbmcpKSAhPT0gTm9GbGFncykge1xuICAgICAgd2FybkFib3V0VXBkYXRlT25Ob3RZZXRNb3VudGVkRmliZXJJbkRFVihzb3VyY2VGaWJlcik7XG4gICAgfVxuICB9IC8vIFdhbGsgdGhlIHBhcmVudCBwYXRoIHRvIHRoZSByb290IGFuZCB1cGRhdGUgdGhlIGNoaWxkIGV4cGlyYXRpb24gdGltZS5cblxuXG4gIHZhciBub2RlID0gc291cmNlRmliZXI7XG4gIHZhciBwYXJlbnQgPSBzb3VyY2VGaWJlci5yZXR1cm47XG5cbiAgd2hpbGUgKHBhcmVudCAhPT0gbnVsbCkge1xuICAgIHBhcmVudC5jaGlsZExhbmVzID0gbWVyZ2VMYW5lcyhwYXJlbnQuY2hpbGRMYW5lcywgbGFuZSk7XG4gICAgYWx0ZXJuYXRlID0gcGFyZW50LmFsdGVybmF0ZTtcblxuICAgIGlmIChhbHRlcm5hdGUgIT09IG51bGwpIHtcbiAgICAgIGFsdGVybmF0ZS5jaGlsZExhbmVzID0gbWVyZ2VMYW5lcyhhbHRlcm5hdGUuY2hpbGRMYW5lcywgbGFuZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHtcbiAgICAgICAgaWYgKChwYXJlbnQuZmxhZ3MgJiAoUGxhY2VtZW50IHwgSHlkcmF0aW5nKSkgIT09IE5vRmxhZ3MpIHtcbiAgICAgICAgICB3YXJuQWJvdXRVcGRhdGVPbk5vdFlldE1vdW50ZWRGaWJlckluREVWKHNvdXJjZUZpYmVyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIG5vZGUgPSBwYXJlbnQ7XG4gICAgcGFyZW50ID0gcGFyZW50LnJldHVybjtcbiAgfVxuXG4gIGlmIChub2RlLnRhZyA9PT0gSG9zdFJvb3QpIHtcbiAgICB2YXIgcm9vdCA9IG5vZGUuc3RhdGVOb2RlO1xuICAgIHJldHVybiByb290O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBudWxsO1xuICB9XG59IC8vIFVzZSB0aGlzIGZ1bmN0aW9uIHRvIHNjaGVkdWxlIGEgdGFzayBmb3IgYSByb290LiBUaGVyZSdzIG9ubHkgb25lIHRhc2sgcGVyXG4vLyByb290OyBpZiBhIHRhc2sgd2FzIGFscmVhZHkgc2NoZWR1bGVkLCB3ZSdsbCBjaGVjayB0byBtYWtlIHN1cmUgdGhlIHByaW9yaXR5XG4vLyBvZiB0aGUgZXhpc3RpbmcgdGFzayBpcyB0aGUgc2FtZSBhcyB0aGUgcHJpb3JpdHkgb2YgdGhlIG5leHQgbGV2ZWwgdGhhdCB0aGVcbi8vIHJvb3QgaGFzIHdvcmsgb24uIFRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIG9uIGV2ZXJ5IHVwZGF0ZSwgYW5kIHJpZ2h0IGJlZm9yZVxuLy8gZXhpdGluZyBhIHRhc2suXG5cblxuZnVuY3Rpb24gZW5zdXJlUm9vdElzU2NoZWR1bGVkKHJvb3QsIGN1cnJlbnRUaW1lKSB7XG4gIHZhciBleGlzdGluZ0NhbGxiYWNrTm9kZSA9IHJvb3QuY2FsbGJhY2tOb2RlOyAvLyBDaGVjayBpZiBhbnkgbGFuZXMgYXJlIGJlaW5nIHN0YXJ2ZWQgYnkgb3RoZXIgd29yay4gSWYgc28sIG1hcmsgdGhlbSBhc1xuICAvLyBleHBpcmVkIHNvIHdlIGtub3cgdG8gd29yayBvbiB0aG9zZSBuZXh0LlxuXG4gIG1hcmtTdGFydmVkTGFuZXNBc0V4cGlyZWQocm9vdCwgY3VycmVudFRpbWUpOyAvLyBEZXRlcm1pbmUgdGhlIG5leHQgbGFuZXMgdG8gd29yayBvbiwgYW5kIHRoZWlyIHByaW9yaXR5LlxuXG4gIHZhciBuZXh0TGFuZXMgPSBnZXROZXh0TGFuZXMocm9vdCwgcm9vdCA9PT0gd29ya0luUHJvZ3Jlc3NSb290ID8gd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMgOiBOb0xhbmVzKTsgLy8gVGhpcyByZXR1cm5zIHRoZSBwcmlvcml0eSBsZXZlbCBjb21wdXRlZCBkdXJpbmcgdGhlIGBnZXROZXh0TGFuZXNgIGNhbGwuXG5cbiAgdmFyIG5ld0NhbGxiYWNrUHJpb3JpdHkgPSByZXR1cm5OZXh0TGFuZXNQcmlvcml0eSgpO1xuXG4gIGlmIChuZXh0TGFuZXMgPT09IE5vTGFuZXMpIHtcbiAgICAvLyBTcGVjaWFsIGNhc2U6IFRoZXJlJ3Mgbm90aGluZyB0byB3b3JrIG9uLlxuICAgIGlmIChleGlzdGluZ0NhbGxiYWNrTm9kZSAhPT0gbnVsbCkge1xuICAgICAgY2FuY2VsQ2FsbGJhY2soZXhpc3RpbmdDYWxsYmFja05vZGUpO1xuICAgICAgcm9vdC5jYWxsYmFja05vZGUgPSBudWxsO1xuICAgICAgcm9vdC5jYWxsYmFja1ByaW9yaXR5ID0gTm9MYW5lUHJpb3JpdHk7XG4gICAgfVxuXG4gICAgcmV0dXJuO1xuICB9IC8vIENoZWNrIGlmIHRoZXJlJ3MgYW4gZXhpc3RpbmcgdGFzay4gV2UgbWF5IGJlIGFibGUgdG8gcmV1c2UgaXQuXG5cblxuICBpZiAoZXhpc3RpbmdDYWxsYmFja05vZGUgIT09IG51bGwpIHtcbiAgICB2YXIgZXhpc3RpbmdDYWxsYmFja1ByaW9yaXR5ID0gcm9vdC5jYWxsYmFja1ByaW9yaXR5O1xuXG4gICAgaWYgKGV4aXN0aW5nQ2FsbGJhY2tQcmlvcml0eSA9PT0gbmV3Q2FsbGJhY2tQcmlvcml0eSkge1xuICAgICAgLy8gVGhlIHByaW9yaXR5IGhhc24ndCBjaGFuZ2VkLiBXZSBjYW4gcmV1c2UgdGhlIGV4aXN0aW5nIHRhc2suIEV4aXQuXG4gICAgICByZXR1cm47XG4gICAgfSAvLyBUaGUgcHJpb3JpdHkgY2hhbmdlZC4gQ2FuY2VsIHRoZSBleGlzdGluZyBjYWxsYmFjay4gV2UnbGwgc2NoZWR1bGUgYSBuZXdcbiAgICAvLyBvbmUgYmVsb3cuXG5cblxuICAgIGNhbmNlbENhbGxiYWNrKGV4aXN0aW5nQ2FsbGJhY2tOb2RlKTtcbiAgfSAvLyBTY2hlZHVsZSBhIG5ldyBjYWxsYmFjay5cblxuXG4gIHZhciBuZXdDYWxsYmFja05vZGU7XG5cbiAgaWYgKG5ld0NhbGxiYWNrUHJpb3JpdHkgPT09IFN5bmNMYW5lUHJpb3JpdHkpIHtcbiAgICAvLyBTcGVjaWFsIGNhc2U6IFN5bmMgUmVhY3QgY2FsbGJhY2tzIGFyZSBzY2hlZHVsZWQgb24gYSBzcGVjaWFsXG4gICAgLy8gaW50ZXJuYWwgcXVldWVcbiAgICBuZXdDYWxsYmFja05vZGUgPSBzY2hlZHVsZVN5bmNDYWxsYmFjayhwZXJmb3JtU3luY1dvcmtPblJvb3QuYmluZChudWxsLCByb290KSk7XG4gIH0gZWxzZSBpZiAobmV3Q2FsbGJhY2tQcmlvcml0eSA9PT0gU3luY0JhdGNoZWRMYW5lUHJpb3JpdHkpIHtcbiAgICBuZXdDYWxsYmFja05vZGUgPSBzY2hlZHVsZUNhbGxiYWNrKEltbWVkaWF0ZVByaW9yaXR5JDEsIHBlcmZvcm1TeW5jV29ya09uUm9vdC5iaW5kKG51bGwsIHJvb3QpKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgc2NoZWR1bGVyUHJpb3JpdHlMZXZlbCA9IGxhbmVQcmlvcml0eVRvU2NoZWR1bGVyUHJpb3JpdHkobmV3Q2FsbGJhY2tQcmlvcml0eSk7XG4gICAgbmV3Q2FsbGJhY2tOb2RlID0gc2NoZWR1bGVDYWxsYmFjayhzY2hlZHVsZXJQcmlvcml0eUxldmVsLCBwZXJmb3JtQ29uY3VycmVudFdvcmtPblJvb3QuYmluZChudWxsLCByb290KSk7XG4gIH1cblxuICByb290LmNhbGxiYWNrUHJpb3JpdHkgPSBuZXdDYWxsYmFja1ByaW9yaXR5O1xuICByb290LmNhbGxiYWNrTm9kZSA9IG5ld0NhbGxiYWNrTm9kZTtcbn0gLy8gVGhpcyBpcyB0aGUgZW50cnkgcG9pbnQgZm9yIGV2ZXJ5IGNvbmN1cnJlbnQgdGFzaywgaS5lLiBhbnl0aGluZyB0aGF0XG4vLyBnb2VzIHRocm91Z2ggU2NoZWR1bGVyLlxuXG5cbmZ1bmN0aW9uIHBlcmZvcm1Db25jdXJyZW50V29ya09uUm9vdChyb290KSB7XG4gIC8vIFNpbmNlIHdlIGtub3cgd2UncmUgaW4gYSBSZWFjdCBldmVudCwgd2UgY2FuIGNsZWFyIHRoZSBjdXJyZW50XG4gIC8vIGV2ZW50IHRpbWUuIFRoZSBuZXh0IHVwZGF0ZSB3aWxsIGNvbXB1dGUgYSBuZXcgZXZlbnQgdGltZS5cbiAgY3VycmVudEV2ZW50VGltZSA9IE5vVGltZXN0YW1wO1xuICBjdXJyZW50RXZlbnRXaXBMYW5lcyA9IE5vTGFuZXM7XG4gIGN1cnJlbnRFdmVudFBlbmRpbmdMYW5lcyA9IE5vTGFuZXM7XG5cbiAgaWYgKCEoKGV4ZWN1dGlvbkNvbnRleHQgJiAoUmVuZGVyQ29udGV4dCB8IENvbW1pdENvbnRleHQpKSA9PT0gTm9Db250ZXh0KSkge1xuICAgIHtcbiAgICAgIHRocm93IEVycm9yKCBcIlNob3VsZCBub3QgYWxyZWFkeSBiZSB3b3JraW5nLlwiICk7XG4gICAgfVxuICB9IC8vIEZsdXNoIGFueSBwZW5kaW5nIHBhc3NpdmUgZWZmZWN0cyBiZWZvcmUgZGVjaWRpbmcgd2hpY2ggbGFuZXMgdG8gd29yayBvbixcbiAgLy8gaW4gY2FzZSB0aGV5IHNjaGVkdWxlIGFkZGl0aW9uYWwgd29yay5cblxuXG4gIHZhciBvcmlnaW5hbENhbGxiYWNrTm9kZSA9IHJvb3QuY2FsbGJhY2tOb2RlO1xuICB2YXIgZGlkRmx1c2hQYXNzaXZlRWZmZWN0cyA9IGZsdXNoUGFzc2l2ZUVmZmVjdHMoKTtcblxuICBpZiAoZGlkRmx1c2hQYXNzaXZlRWZmZWN0cykge1xuICAgIC8vIFNvbWV0aGluZyBpbiB0aGUgcGFzc2l2ZSBlZmZlY3QgcGhhc2UgbWF5IGhhdmUgY2FuY2VsZWQgdGhlIGN1cnJlbnQgdGFzay5cbiAgICAvLyBDaGVjayBpZiB0aGUgdGFzayBub2RlIGZvciB0aGlzIHJvb3Qgd2FzIGNoYW5nZWQuXG4gICAgaWYgKHJvb3QuY2FsbGJhY2tOb2RlICE9PSBvcmlnaW5hbENhbGxiYWNrTm9kZSkge1xuICAgICAgLy8gVGhlIGN1cnJlbnQgdGFzayB3YXMgY2FuY2VsZWQuIEV4aXQuIFdlIGRvbid0IG5lZWQgdG8gY2FsbFxuICAgICAgLy8gYGVuc3VyZVJvb3RJc1NjaGVkdWxlZGAgYmVjYXVzZSB0aGUgY2hlY2sgYWJvdmUgaW1wbGllcyBlaXRoZXIgdGhhdFxuICAgICAgLy8gdGhlcmUncyBhIG5ldyB0YXNrLCBvciB0aGF0IHRoZXJlJ3Mgbm8gcmVtYWluaW5nIHdvcmsgb24gdGhpcyByb290LlxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9IC8vIERldGVybWluZSB0aGUgbmV4dCBleHBpcmF0aW9uIHRpbWUgdG8gd29yayBvbiwgdXNpbmcgdGhlIGZpZWxkcyBzdG9yZWRcbiAgLy8gb24gdGhlIHJvb3QuXG5cblxuICB2YXIgbGFuZXMgPSBnZXROZXh0TGFuZXMocm9vdCwgcm9vdCA9PT0gd29ya0luUHJvZ3Jlc3NSb290ID8gd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMgOiBOb0xhbmVzKTtcblxuICBpZiAobGFuZXMgPT09IE5vTGFuZXMpIHtcbiAgICAvLyBEZWZlbnNpdmUgY29kaW5nLiBUaGlzIGlzIG5ldmVyIGV4cGVjdGVkIHRvIGhhcHBlbi5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBleGl0U3RhdHVzID0gcmVuZGVyUm9vdENvbmN1cnJlbnQocm9vdCwgbGFuZXMpO1xuXG4gIGlmIChpbmNsdWRlc1NvbWVMYW5lKHdvcmtJblByb2dyZXNzUm9vdEluY2x1ZGVkTGFuZXMsIHdvcmtJblByb2dyZXNzUm9vdFVwZGF0ZWRMYW5lcykpIHtcbiAgICAvLyBUaGUgcmVuZGVyIGluY2x1ZGVkIGxhbmVzIHRoYXQgd2VyZSB1cGRhdGVkIGR1cmluZyB0aGUgcmVuZGVyIHBoYXNlLlxuICAgIC8vIEZvciBleGFtcGxlLCB3aGVuIHVuaGlkaW5nIGEgaGlkZGVuIHRyZWUsIHdlIGluY2x1ZGUgYWxsIHRoZSBsYW5lc1xuICAgIC8vIHRoYXQgd2VyZSBwcmV2aW91c2x5IHNraXBwZWQgd2hlbiB0aGUgdHJlZSB3YXMgaGlkZGVuLiBUaGF0IHNldCBvZlxuICAgIC8vIGxhbmVzIGlzIGEgc3VwZXJzZXQgb2YgdGhlIGxhbmVzIHdlIHN0YXJ0ZWQgcmVuZGVyaW5nIHdpdGguXG4gICAgLy9cbiAgICAvLyBTbyB3ZSdsbCB0aHJvdyBvdXQgdGhlIGN1cnJlbnQgd29yayBhbmQgcmVzdGFydC5cbiAgICBwcmVwYXJlRnJlc2hTdGFjayhyb290LCBOb0xhbmVzKTtcbiAgfSBlbHNlIGlmIChleGl0U3RhdHVzICE9PSBSb290SW5jb21wbGV0ZSkge1xuICAgIGlmIChleGl0U3RhdHVzID09PSBSb290RXJyb3JlZCkge1xuICAgICAgZXhlY3V0aW9uQ29udGV4dCB8PSBSZXRyeUFmdGVyRXJyb3I7IC8vIElmIGFuIGVycm9yIG9jY3VycmVkIGR1cmluZyBoeWRyYXRpb24sXG4gICAgICAvLyBkaXNjYXJkIHNlcnZlciByZXNwb25zZSBhbmQgZmFsbCBiYWNrIHRvIGNsaWVudCBzaWRlIHJlbmRlci5cblxuICAgICAgaWYgKHJvb3QuaHlkcmF0ZSkge1xuICAgICAgICByb290Lmh5ZHJhdGUgPSBmYWxzZTtcbiAgICAgICAgY2xlYXJDb250YWluZXIocm9vdC5jb250YWluZXJJbmZvKTtcbiAgICAgIH0gLy8gSWYgc29tZXRoaW5nIHRocmV3IGFuIGVycm9yLCB0cnkgcmVuZGVyaW5nIG9uZSBtb3JlIHRpbWUuIFdlJ2xsIHJlbmRlclxuICAgICAgLy8gc3luY2hyb25vdXNseSB0byBibG9jayBjb25jdXJyZW50IGRhdGEgbXV0YXRpb25zLCBhbmQgd2UnbGwgaW5jbHVkZXNcbiAgICAgIC8vIGFsbCBwZW5kaW5nIHVwZGF0ZXMgYXJlIGluY2x1ZGVkLiBJZiBpdCBzdGlsbCBmYWlscyBhZnRlciB0aGUgc2Vjb25kXG4gICAgICAvLyBhdHRlbXB0LCB3ZSdsbCBnaXZlIHVwIGFuZCBjb21taXQgdGhlIHJlc3VsdGluZyB0cmVlLlxuXG5cbiAgICAgIGxhbmVzID0gZ2V0TGFuZXNUb1JldHJ5U3luY2hyb25vdXNseU9uRXJyb3Iocm9vdCk7XG5cbiAgICAgIGlmIChsYW5lcyAhPT0gTm9MYW5lcykge1xuICAgICAgICBleGl0U3RhdHVzID0gcmVuZGVyUm9vdFN5bmMocm9vdCwgbGFuZXMpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChleGl0U3RhdHVzID09PSBSb290RmF0YWxFcnJvcmVkKSB7XG4gICAgICB2YXIgZmF0YWxFcnJvciA9IHdvcmtJblByb2dyZXNzUm9vdEZhdGFsRXJyb3I7XG4gICAgICBwcmVwYXJlRnJlc2hTdGFjayhyb290LCBOb0xhbmVzKTtcbiAgICAgIG1hcmtSb290U3VzcGVuZGVkJDEocm9vdCwgbGFuZXMpO1xuICAgICAgZW5zdXJlUm9vdElzU2NoZWR1bGVkKHJvb3QsIG5vdygpKTtcbiAgICAgIHRocm93IGZhdGFsRXJyb3I7XG4gICAgfSAvLyBXZSBub3cgaGF2ZSBhIGNvbnNpc3RlbnQgdHJlZS4gVGhlIG5leHQgc3RlcCBpcyBlaXRoZXIgdG8gY29tbWl0IGl0LFxuICAgIC8vIG9yLCBpZiBzb21ldGhpbmcgc3VzcGVuZGVkLCB3YWl0IHRvIGNvbW1pdCBpdCBhZnRlciBhIHRpbWVvdXQuXG5cblxuICAgIHZhciBmaW5pc2hlZFdvcmsgPSByb290LmN1cnJlbnQuYWx0ZXJuYXRlO1xuICAgIHJvb3QuZmluaXNoZWRXb3JrID0gZmluaXNoZWRXb3JrO1xuICAgIHJvb3QuZmluaXNoZWRMYW5lcyA9IGxhbmVzO1xuICAgIGZpbmlzaENvbmN1cnJlbnRSZW5kZXIocm9vdCwgZXhpdFN0YXR1cywgbGFuZXMpO1xuICB9XG5cbiAgZW5zdXJlUm9vdElzU2NoZWR1bGVkKHJvb3QsIG5vdygpKTtcblxuICBpZiAocm9vdC5jYWxsYmFja05vZGUgPT09IG9yaWdpbmFsQ2FsbGJhY2tOb2RlKSB7XG4gICAgLy8gVGhlIHRhc2sgbm9kZSBzY2hlZHVsZWQgZm9yIHRoaXMgcm9vdCBpcyB0aGUgc2FtZSBvbmUgdGhhdCdzXG4gICAgLy8gY3VycmVudGx5IGV4ZWN1dGVkLiBOZWVkIHRvIHJldHVybiBhIGNvbnRpbnVhdGlvbi5cbiAgICByZXR1cm4gcGVyZm9ybUNvbmN1cnJlbnRXb3JrT25Sb290LmJpbmQobnVsbCwgcm9vdCk7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gZmluaXNoQ29uY3VycmVudFJlbmRlcihyb290LCBleGl0U3RhdHVzLCBsYW5lcykge1xuICBzd2l0Y2ggKGV4aXRTdGF0dXMpIHtcbiAgICBjYXNlIFJvb3RJbmNvbXBsZXRlOlxuICAgIGNhc2UgUm9vdEZhdGFsRXJyb3JlZDpcbiAgICAgIHtcbiAgICAgICAge1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKCBcIlJvb3QgZGlkIG5vdCBjb21wbGV0ZS4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC5cIiApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIC8vIEZsb3cga25vd3MgYWJvdXQgaW52YXJpYW50LCBzbyBpdCBjb21wbGFpbnMgaWYgSSBhZGQgYSBicmVha1xuICAgIC8vIHN0YXRlbWVudCwgYnV0IGVzbGludCBkb2Vzbid0IGtub3cgYWJvdXQgaW52YXJpYW50LCBzbyBpdCBjb21wbGFpbnNcbiAgICAvLyBpZiBJIGRvLiBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZmFsbHRocm91Z2hcblxuICAgIGNhc2UgUm9vdEVycm9yZWQ6XG4gICAgICB7XG4gICAgICAgIC8vIFdlIHNob3VsZCBoYXZlIGFscmVhZHkgYXR0ZW1wdGVkIHRvIHJldHJ5IHRoaXMgdHJlZS4gSWYgd2UgcmVhY2hlZFxuICAgICAgICAvLyB0aGlzIHBvaW50LCBpdCBlcnJvcmVkIGFnYWluLiBDb21taXQgaXQuXG4gICAgICAgIGNvbW1pdFJvb3Qocm9vdCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgY2FzZSBSb290U3VzcGVuZGVkOlxuICAgICAge1xuICAgICAgICBtYXJrUm9vdFN1c3BlbmRlZCQxKHJvb3QsIGxhbmVzKTsgLy8gV2UgaGF2ZSBhbiBhY2NlcHRhYmxlIGxvYWRpbmcgc3RhdGUuIFdlIG5lZWQgdG8gZmlndXJlIG91dCBpZiB3ZVxuICAgICAgICAvLyBzaG91bGQgaW1tZWRpYXRlbHkgY29tbWl0IGl0IG9yIHdhaXQgYSBiaXQuXG5cbiAgICAgICAgaWYgKGluY2x1ZGVzT25seVJldHJpZXMobGFuZXMpICYmIC8vIGRvIG5vdCBkZWxheSBpZiB3ZSdyZSBpbnNpZGUgYW4gYWN0KCkgc2NvcGVcbiAgICAgICAgIXNob3VsZEZvcmNlRmx1c2hGYWxsYmFja3NJbkRFVigpKSB7XG4gICAgICAgICAgLy8gVGhpcyByZW5kZXIgb25seSBpbmNsdWRlZCByZXRyaWVzLCBubyB1cGRhdGVzLiBUaHJvdHRsZSBjb21taXR0aW5nXG4gICAgICAgICAgLy8gcmV0cmllcyBzbyB0aGF0IHdlIGRvbid0IHNob3cgdG9vIG1hbnkgbG9hZGluZyBzdGF0ZXMgdG9vIHF1aWNrbHkuXG4gICAgICAgICAgdmFyIG1zVW50aWxUaW1lb3V0ID0gZ2xvYmFsTW9zdFJlY2VudEZhbGxiYWNrVGltZSArIEZBTExCQUNLX1RIUk9UVExFX01TIC0gbm93KCk7IC8vIERvbid0IGJvdGhlciB3aXRoIGEgdmVyeSBzaG9ydCBzdXNwZW5zZSB0aW1lLlxuXG4gICAgICAgICAgaWYgKG1zVW50aWxUaW1lb3V0ID4gMTApIHtcbiAgICAgICAgICAgIHZhciBuZXh0TGFuZXMgPSBnZXROZXh0TGFuZXMocm9vdCwgTm9MYW5lcyk7XG5cbiAgICAgICAgICAgIGlmIChuZXh0TGFuZXMgIT09IE5vTGFuZXMpIHtcbiAgICAgICAgICAgICAgLy8gVGhlcmUncyBhZGRpdGlvbmFsIHdvcmsgb24gdGhpcyByb290LlxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHN1c3BlbmRlZExhbmVzID0gcm9vdC5zdXNwZW5kZWRMYW5lcztcblxuICAgICAgICAgICAgaWYgKCFpc1N1YnNldE9mTGFuZXMoc3VzcGVuZGVkTGFuZXMsIGxhbmVzKSkge1xuICAgICAgICAgICAgICAvLyBXZSBzaG91bGQgcHJlZmVyIHRvIHJlbmRlciB0aGUgZmFsbGJhY2sgb2YgYXQgdGhlIGxhc3RcbiAgICAgICAgICAgICAgLy8gc3VzcGVuZGVkIGxldmVsLiBQaW5nIHRoZSBsYXN0IHN1c3BlbmRlZCBsZXZlbCB0byB0cnlcbiAgICAgICAgICAgICAgLy8gcmVuZGVyaW5nIGl0IGFnYWluLlxuICAgICAgICAgICAgICAvLyBGSVhNRTogV2hhdCBpZiB0aGUgc3VzcGVuZGVkIGxhbmVzIGFyZSBJZGxlPyBTaG91bGQgbm90IHJlc3RhcnQuXG4gICAgICAgICAgICAgIHZhciBldmVudFRpbWUgPSByZXF1ZXN0RXZlbnRUaW1lKCk7XG4gICAgICAgICAgICAgIG1hcmtSb290UGluZ2VkKHJvb3QsIHN1c3BlbmRlZExhbmVzKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9IC8vIFRoZSByZW5kZXIgaXMgc3VzcGVuZGVkLCBpdCBoYXNuJ3QgdGltZWQgb3V0LCBhbmQgdGhlcmUncyBub1xuICAgICAgICAgICAgLy8gbG93ZXIgcHJpb3JpdHkgd29yayB0byBkby4gSW5zdGVhZCBvZiBjb21taXR0aW5nIHRoZSBmYWxsYmFja1xuICAgICAgICAgICAgLy8gaW1tZWRpYXRlbHksIHdhaXQgZm9yIG1vcmUgZGF0YSB0byBhcnJpdmUuXG5cblxuICAgICAgICAgICAgcm9vdC50aW1lb3V0SGFuZGxlID0gc2NoZWR1bGVUaW1lb3V0KGNvbW1pdFJvb3QuYmluZChudWxsLCByb290KSwgbXNVbnRpbFRpbWVvdXQpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vIFRoZSB3b3JrIGV4cGlyZWQuIENvbW1pdCBpbW1lZGlhdGVseS5cblxuXG4gICAgICAgIGNvbW1pdFJvb3Qocm9vdCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgY2FzZSBSb290U3VzcGVuZGVkV2l0aERlbGF5OlxuICAgICAge1xuICAgICAgICBtYXJrUm9vdFN1c3BlbmRlZCQxKHJvb3QsIGxhbmVzKTtcblxuICAgICAgICBpZiAoaW5jbHVkZXNPbmx5VHJhbnNpdGlvbnMobGFuZXMpKSB7XG4gICAgICAgICAgLy8gVGhpcyBpcyBhIHRyYW5zaXRpb24sIHNvIHdlIHNob3VsZCBleGl0IHdpdGhvdXQgY29tbWl0dGluZyBhXG4gICAgICAgICAgLy8gcGxhY2Vob2xkZXIgYW5kIHdpdGhvdXQgc2NoZWR1bGluZyBhIHRpbWVvdXQuIERlbGF5IGluZGVmaW5pdGVseVxuICAgICAgICAgIC8vIHVudGlsIHdlIHJlY2VpdmUgbW9yZSBkYXRhLlxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFzaG91bGRGb3JjZUZsdXNoRmFsbGJhY2tzSW5ERVYoKSkge1xuICAgICAgICAgIC8vIFRoaXMgaXMgbm90IGEgdHJhbnNpdGlvbiwgYnV0IHdlIGRpZCB0cmlnZ2VyIGFuIGF2b2lkZWQgc3RhdGUuXG4gICAgICAgICAgLy8gU2NoZWR1bGUgYSBwbGFjZWhvbGRlciB0byBkaXNwbGF5IGFmdGVyIGEgc2hvcnQgZGVsYXksIHVzaW5nIHRoZSBKdXN0XG4gICAgICAgICAgLy8gTm90aWNlYWJsZSBEaWZmZXJlbmNlLlxuICAgICAgICAgIC8vIFRPRE86IElzIHRoZSBKTkQgb3B0aW1pemF0aW9uIHdvcnRoIHRoZSBhZGRlZCBjb21wbGV4aXR5PyBJZiB0aGlzIGlzXG4gICAgICAgICAgLy8gdGhlIG9ubHkgcmVhc29uIHdlIHRyYWNrIHRoZSBldmVudCB0aW1lLCB0aGVuIHByb2JhYmx5IG5vdC5cbiAgICAgICAgICAvLyBDb25zaWRlciByZW1vdmluZy5cbiAgICAgICAgICB2YXIgbW9zdFJlY2VudEV2ZW50VGltZSA9IGdldE1vc3RSZWNlbnRFdmVudFRpbWUocm9vdCwgbGFuZXMpO1xuICAgICAgICAgIHZhciBldmVudFRpbWVNcyA9IG1vc3RSZWNlbnRFdmVudFRpbWU7XG4gICAgICAgICAgdmFyIHRpbWVFbGFwc2VkTXMgPSBub3coKSAtIGV2ZW50VGltZU1zO1xuXG4gICAgICAgICAgdmFyIF9tc1VudGlsVGltZW91dCA9IGpuZCh0aW1lRWxhcHNlZE1zKSAtIHRpbWVFbGFwc2VkTXM7IC8vIERvbid0IGJvdGhlciB3aXRoIGEgdmVyeSBzaG9ydCBzdXNwZW5zZSB0aW1lLlxuXG5cbiAgICAgICAgICBpZiAoX21zVW50aWxUaW1lb3V0ID4gMTApIHtcbiAgICAgICAgICAgIC8vIEluc3RlYWQgb2YgY29tbWl0dGluZyB0aGUgZmFsbGJhY2sgaW1tZWRpYXRlbHksIHdhaXQgZm9yIG1vcmUgZGF0YVxuICAgICAgICAgICAgLy8gdG8gYXJyaXZlLlxuICAgICAgICAgICAgcm9vdC50aW1lb3V0SGFuZGxlID0gc2NoZWR1bGVUaW1lb3V0KGNvbW1pdFJvb3QuYmluZChudWxsLCByb290KSwgX21zVW50aWxUaW1lb3V0KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfSAvLyBDb21taXQgdGhlIHBsYWNlaG9sZGVyLlxuXG5cbiAgICAgICAgY29tbWl0Um9vdChyb290KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICBjYXNlIFJvb3RDb21wbGV0ZWQ6XG4gICAgICB7XG4gICAgICAgIC8vIFRoZSB3b3JrIGNvbXBsZXRlZC4gUmVhZHkgdG8gY29tbWl0LlxuICAgICAgICBjb21taXRSb290KHJvb3QpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgIGRlZmF1bHQ6XG4gICAgICB7XG4gICAgICAgIHtcbiAgICAgICAgICB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvciggXCJVbmtub3duIHJvb3QgZXhpdCBzdGF0dXMuXCIgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBtYXJrUm9vdFN1c3BlbmRlZCQxKHJvb3QsIHN1c3BlbmRlZExhbmVzKSB7XG4gIC8vIFdoZW4gc3VzcGVuZGluZywgd2Ugc2hvdWxkIGFsd2F5cyBleGNsdWRlIGxhbmVzIHRoYXQgd2VyZSBwaW5nZWQgb3IgKG1vcmVcbiAgLy8gcmFyZWx5LCBzaW5jZSB3ZSB0cnkgdG8gYXZvaWQgaXQpIHVwZGF0ZWQgZHVyaW5nIHRoZSByZW5kZXIgcGhhc2UuXG4gIC8vIFRPRE86IExvbCBtYXliZSB0aGVyZSdzIGEgYmV0dGVyIHdheSB0byBmYWN0b3IgdGhpcyBiZXNpZGVzIHRoaXNcbiAgLy8gb2Jub3hpb3VzbHkgbmFtZWQgZnVuY3Rpb24gOilcbiAgc3VzcGVuZGVkTGFuZXMgPSByZW1vdmVMYW5lcyhzdXNwZW5kZWRMYW5lcywgd29ya0luUHJvZ3Jlc3NSb290UGluZ2VkTGFuZXMpO1xuICBzdXNwZW5kZWRMYW5lcyA9IHJlbW92ZUxhbmVzKHN1c3BlbmRlZExhbmVzLCB3b3JrSW5Qcm9ncmVzc1Jvb3RVcGRhdGVkTGFuZXMpO1xuICBtYXJrUm9vdFN1c3BlbmRlZChyb290LCBzdXNwZW5kZWRMYW5lcyk7XG59IC8vIFRoaXMgaXMgdGhlIGVudHJ5IHBvaW50IGZvciBzeW5jaHJvbm91cyB0YXNrcyB0aGF0IGRvbid0IGdvXG4vLyB0aHJvdWdoIFNjaGVkdWxlclxuXG5cbmZ1bmN0aW9uIHBlcmZvcm1TeW5jV29ya09uUm9vdChyb290KSB7XG4gIGlmICghKChleGVjdXRpb25Db250ZXh0ICYgKFJlbmRlckNvbnRleHQgfCBDb21taXRDb250ZXh0KSkgPT09IE5vQ29udGV4dCkpIHtcbiAgICB7XG4gICAgICB0aHJvdyBFcnJvciggXCJTaG91bGQgbm90IGFscmVhZHkgYmUgd29ya2luZy5cIiApO1xuICAgIH1cbiAgfVxuXG4gIGZsdXNoUGFzc2l2ZUVmZmVjdHMoKTtcbiAgdmFyIGxhbmVzO1xuICB2YXIgZXhpdFN0YXR1cztcblxuICBpZiAocm9vdCA9PT0gd29ya0luUHJvZ3Jlc3NSb290ICYmIGluY2x1ZGVzU29tZUxhbmUocm9vdC5leHBpcmVkTGFuZXMsIHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzKSkge1xuICAgIC8vIFRoZXJlJ3MgYSBwYXJ0aWFsIHRyZWUsIGFuZCBhdCBsZWFzdCBvbmUgb2YgaXRzIGxhbmVzIGhhcyBleHBpcmVkLiBGaW5pc2hcbiAgICAvLyByZW5kZXJpbmcgaXQgYmVmb3JlIHJlbmRlcmluZyB0aGUgcmVzdCBvZiB0aGUgZXhwaXJlZCB3b3JrLlxuICAgIGxhbmVzID0gd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXM7XG4gICAgZXhpdFN0YXR1cyA9IHJlbmRlclJvb3RTeW5jKHJvb3QsIGxhbmVzKTtcblxuICAgIGlmIChpbmNsdWRlc1NvbWVMYW5lKHdvcmtJblByb2dyZXNzUm9vdEluY2x1ZGVkTGFuZXMsIHdvcmtJblByb2dyZXNzUm9vdFVwZGF0ZWRMYW5lcykpIHtcbiAgICAgIC8vIFRoZSByZW5kZXIgaW5jbHVkZWQgbGFuZXMgdGhhdCB3ZXJlIHVwZGF0ZWQgZHVyaW5nIHRoZSByZW5kZXIgcGhhc2UuXG4gICAgICAvLyBGb3IgZXhhbXBsZSwgd2hlbiB1bmhpZGluZyBhIGhpZGRlbiB0cmVlLCB3ZSBpbmNsdWRlIGFsbCB0aGUgbGFuZXNcbiAgICAgIC8vIHRoYXQgd2VyZSBwcmV2aW91c2x5IHNraXBwZWQgd2hlbiB0aGUgdHJlZSB3YXMgaGlkZGVuLiBUaGF0IHNldCBvZlxuICAgICAgLy8gbGFuZXMgaXMgYSBzdXBlcnNldCBvZiB0aGUgbGFuZXMgd2Ugc3RhcnRlZCByZW5kZXJpbmcgd2l0aC5cbiAgICAgIC8vXG4gICAgICAvLyBOb3RlIHRoYXQgdGhpcyBvbmx5IGhhcHBlbnMgd2hlbiBwYXJ0IG9mIHRoZSB0cmVlIGlzIHJlbmRlcmVkXG4gICAgICAvLyBjb25jdXJyZW50bHkuIElmIHRoZSB3aG9sZSB0cmVlIGlzIHJlbmRlcmVkIHN5bmNocm9ub3VzbHksIHRoZW4gdGhlcmVcbiAgICAgIC8vIGFyZSBubyBpbnRlcmxlYXZlZCBldmVudHMuXG4gICAgICBsYW5lcyA9IGdldE5leHRMYW5lcyhyb290LCBsYW5lcyk7XG4gICAgICBleGl0U3RhdHVzID0gcmVuZGVyUm9vdFN5bmMocm9vdCwgbGFuZXMpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBsYW5lcyA9IGdldE5leHRMYW5lcyhyb290LCBOb0xhbmVzKTtcbiAgICBleGl0U3RhdHVzID0gcmVuZGVyUm9vdFN5bmMocm9vdCwgbGFuZXMpO1xuICB9XG5cbiAgaWYgKHJvb3QudGFnICE9PSBMZWdhY3lSb290ICYmIGV4aXRTdGF0dXMgPT09IFJvb3RFcnJvcmVkKSB7XG4gICAgZXhlY3V0aW9uQ29udGV4dCB8PSBSZXRyeUFmdGVyRXJyb3I7IC8vIElmIGFuIGVycm9yIG9jY3VycmVkIGR1cmluZyBoeWRyYXRpb24sXG4gICAgLy8gZGlzY2FyZCBzZXJ2ZXIgcmVzcG9uc2UgYW5kIGZhbGwgYmFjayB0byBjbGllbnQgc2lkZSByZW5kZXIuXG5cbiAgICBpZiAocm9vdC5oeWRyYXRlKSB7XG4gICAgICByb290Lmh5ZHJhdGUgPSBmYWxzZTtcbiAgICAgIGNsZWFyQ29udGFpbmVyKHJvb3QuY29udGFpbmVySW5mbyk7XG4gICAgfSAvLyBJZiBzb21ldGhpbmcgdGhyZXcgYW4gZXJyb3IsIHRyeSByZW5kZXJpbmcgb25lIG1vcmUgdGltZS4gV2UnbGwgcmVuZGVyXG4gICAgLy8gc3luY2hyb25vdXNseSB0byBibG9jayBjb25jdXJyZW50IGRhdGEgbXV0YXRpb25zLCBhbmQgd2UnbGwgaW5jbHVkZXNcbiAgICAvLyBhbGwgcGVuZGluZyB1cGRhdGVzIGFyZSBpbmNsdWRlZC4gSWYgaXQgc3RpbGwgZmFpbHMgYWZ0ZXIgdGhlIHNlY29uZFxuICAgIC8vIGF0dGVtcHQsIHdlJ2xsIGdpdmUgdXAgYW5kIGNvbW1pdCB0aGUgcmVzdWx0aW5nIHRyZWUuXG5cblxuICAgIGxhbmVzID0gZ2V0TGFuZXNUb1JldHJ5U3luY2hyb25vdXNseU9uRXJyb3Iocm9vdCk7XG5cbiAgICBpZiAobGFuZXMgIT09IE5vTGFuZXMpIHtcbiAgICAgIGV4aXRTdGF0dXMgPSByZW5kZXJSb290U3luYyhyb290LCBsYW5lcyk7XG4gICAgfVxuICB9XG5cbiAgaWYgKGV4aXRTdGF0dXMgPT09IFJvb3RGYXRhbEVycm9yZWQpIHtcbiAgICB2YXIgZmF0YWxFcnJvciA9IHdvcmtJblByb2dyZXNzUm9vdEZhdGFsRXJyb3I7XG4gICAgcHJlcGFyZUZyZXNoU3RhY2socm9vdCwgTm9MYW5lcyk7XG4gICAgbWFya1Jvb3RTdXNwZW5kZWQkMShyb290LCBsYW5lcyk7XG4gICAgZW5zdXJlUm9vdElzU2NoZWR1bGVkKHJvb3QsIG5vdygpKTtcbiAgICB0aHJvdyBmYXRhbEVycm9yO1xuICB9IC8vIFdlIG5vdyBoYXZlIGEgY29uc2lzdGVudCB0cmVlLiBCZWNhdXNlIHRoaXMgaXMgYSBzeW5jIHJlbmRlciwgd2VcbiAgLy8gd2lsbCBjb21taXQgaXQgZXZlbiBpZiBzb21ldGhpbmcgc3VzcGVuZGVkLlxuXG5cbiAgdmFyIGZpbmlzaGVkV29yayA9IHJvb3QuY3VycmVudC5hbHRlcm5hdGU7XG4gIHJvb3QuZmluaXNoZWRXb3JrID0gZmluaXNoZWRXb3JrO1xuICByb290LmZpbmlzaGVkTGFuZXMgPSBsYW5lcztcbiAgY29tbWl0Um9vdChyb290KTsgLy8gQmVmb3JlIGV4aXRpbmcsIG1ha2Ugc3VyZSB0aGVyZSdzIGEgY2FsbGJhY2sgc2NoZWR1bGVkIGZvciB0aGUgbmV4dFxuICAvLyBwZW5kaW5nIGxldmVsLlxuXG4gIGVuc3VyZVJvb3RJc1NjaGVkdWxlZChyb290LCBub3coKSk7XG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gZmx1c2hEaXNjcmV0ZVVwZGF0ZXMoKSB7XG4gIC8vIFRPRE86IFNob3VsZCBiZSBhYmxlIHRvIGZsdXNoIGluc2lkZSBiYXRjaGVkVXBkYXRlcywgYnV0IG5vdCBpbnNpZGUgYGFjdGAuXG4gIC8vIEhvd2V2ZXIsIGBhY3RgIHVzZXMgYGJhdGNoZWRVcGRhdGVzYCwgc28gdGhlcmUncyBubyB3YXkgdG8gZGlzdGluZ3Vpc2hcbiAgLy8gdGhvc2UgdHdvIGNhc2VzLiBOZWVkIHRvIGZpeCB0aGlzIGJlZm9yZSBleHBvc2luZyBmbHVzaERpc2NyZXRlVXBkYXRlc1xuICAvLyBhcyBhIHB1YmxpYyBBUEkuXG4gIGlmICgoZXhlY3V0aW9uQ29udGV4dCAmIChCYXRjaGVkQ29udGV4dCB8IFJlbmRlckNvbnRleHQgfCBDb21taXRDb250ZXh0KSkgIT09IE5vQ29udGV4dCkge1xuICAgIHtcbiAgICAgIGlmICgoZXhlY3V0aW9uQ29udGV4dCAmIFJlbmRlckNvbnRleHQpICE9PSBOb0NvbnRleHQpIHtcbiAgICAgICAgZXJyb3IoJ3Vuc3RhYmxlX2ZsdXNoRGlzY3JldGVVcGRhdGVzOiBDYW5ub3QgZmx1c2ggdXBkYXRlcyB3aGVuIFJlYWN0IGlzICcgKyAnYWxyZWFkeSByZW5kZXJpbmcuJyk7XG4gICAgICB9XG4gICAgfSAvLyBXZSdyZSBhbHJlYWR5IHJlbmRlcmluZywgc28gd2UgY2FuJ3Qgc3luY2hyb25vdXNseSBmbHVzaCBwZW5kaW5nIHdvcmsuXG4gICAgLy8gVGhpcyBpcyBwcm9iYWJseSBhIG5lc3RlZCBldmVudCBkaXNwYXRjaCB0cmlnZ2VyZWQgYnkgYSBsaWZlY3ljbGUvZWZmZWN0LFxuICAgIC8vIGxpa2UgYGVsLmZvY3VzKClgLiBFeGl0LlxuXG5cbiAgICByZXR1cm47XG4gIH1cblxuICBmbHVzaFBlbmRpbmdEaXNjcmV0ZVVwZGF0ZXMoKTsgLy8gSWYgdGhlIGRpc2NyZXRlIHVwZGF0ZXMgc2NoZWR1bGVkIHBhc3NpdmUgZWZmZWN0cywgZmx1c2ggdGhlbSBub3cgc28gdGhhdFxuICAvLyB0aGV5IGZpcmUgYmVmb3JlIHRoZSBuZXh0IHNlcmlhbCBldmVudC5cblxuICBmbHVzaFBhc3NpdmVFZmZlY3RzKCk7XG59XG5cbmZ1bmN0aW9uIGZsdXNoUGVuZGluZ0Rpc2NyZXRlVXBkYXRlcygpIHtcbiAgaWYgKHJvb3RzV2l0aFBlbmRpbmdEaXNjcmV0ZVVwZGF0ZXMgIT09IG51bGwpIHtcbiAgICAvLyBGb3IgZWFjaCByb290IHdpdGggcGVuZGluZyBkaXNjcmV0ZSB1cGRhdGVzLCBzY2hlZHVsZSBhIGNhbGxiYWNrIHRvXG4gICAgLy8gaW1tZWRpYXRlbHkgZmx1c2ggdGhlbS5cbiAgICB2YXIgcm9vdHMgPSByb290c1dpdGhQZW5kaW5nRGlzY3JldGVVcGRhdGVzO1xuICAgIHJvb3RzV2l0aFBlbmRpbmdEaXNjcmV0ZVVwZGF0ZXMgPSBudWxsO1xuICAgIHJvb3RzLmZvckVhY2goZnVuY3Rpb24gKHJvb3QpIHtcbiAgICAgIG1hcmtEaXNjcmV0ZVVwZGF0ZXNFeHBpcmVkKHJvb3QpO1xuICAgICAgZW5zdXJlUm9vdElzU2NoZWR1bGVkKHJvb3QsIG5vdygpKTtcbiAgICB9KTtcbiAgfSAvLyBOb3cgZmx1c2ggdGhlIGltbWVkaWF0ZSBxdWV1ZS5cblxuXG4gIGZsdXNoU3luY0NhbGxiYWNrUXVldWUoKTtcbn1cblxuZnVuY3Rpb24gYmF0Y2hlZFVwZGF0ZXMkMShmbiwgYSkge1xuICB2YXIgcHJldkV4ZWN1dGlvbkNvbnRleHQgPSBleGVjdXRpb25Db250ZXh0O1xuICBleGVjdXRpb25Db250ZXh0IHw9IEJhdGNoZWRDb250ZXh0O1xuXG4gIHRyeSB7XG4gICAgcmV0dXJuIGZuKGEpO1xuICB9IGZpbmFsbHkge1xuICAgIGV4ZWN1dGlvbkNvbnRleHQgPSBwcmV2RXhlY3V0aW9uQ29udGV4dDtcblxuICAgIGlmIChleGVjdXRpb25Db250ZXh0ID09PSBOb0NvbnRleHQpIHtcbiAgICAgIC8vIEZsdXNoIHRoZSBpbW1lZGlhdGUgY2FsbGJhY2tzIHRoYXQgd2VyZSBzY2hlZHVsZWQgZHVyaW5nIHRoaXMgYmF0Y2hcbiAgICAgIHJlc2V0UmVuZGVyVGltZXIoKTtcbiAgICAgIGZsdXNoU3luY0NhbGxiYWNrUXVldWUoKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGJhdGNoZWRFdmVudFVwZGF0ZXMkMShmbiwgYSkge1xuICB2YXIgcHJldkV4ZWN1dGlvbkNvbnRleHQgPSBleGVjdXRpb25Db250ZXh0O1xuICBleGVjdXRpb25Db250ZXh0IHw9IEV2ZW50Q29udGV4dDtcblxuICB0cnkge1xuICAgIHJldHVybiBmbihhKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBleGVjdXRpb25Db250ZXh0ID0gcHJldkV4ZWN1dGlvbkNvbnRleHQ7XG5cbiAgICBpZiAoZXhlY3V0aW9uQ29udGV4dCA9PT0gTm9Db250ZXh0KSB7XG4gICAgICAvLyBGbHVzaCB0aGUgaW1tZWRpYXRlIGNhbGxiYWNrcyB0aGF0IHdlcmUgc2NoZWR1bGVkIGR1cmluZyB0aGlzIGJhdGNoXG4gICAgICByZXNldFJlbmRlclRpbWVyKCk7XG4gICAgICBmbHVzaFN5bmNDYWxsYmFja1F1ZXVlKCk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBkaXNjcmV0ZVVwZGF0ZXMkMShmbiwgYSwgYiwgYywgZCkge1xuICB2YXIgcHJldkV4ZWN1dGlvbkNvbnRleHQgPSBleGVjdXRpb25Db250ZXh0O1xuICBleGVjdXRpb25Db250ZXh0IHw9IERpc2NyZXRlRXZlbnRDb250ZXh0O1xuXG4gIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIHJ1bldpdGhQcmlvcml0eSQxKFVzZXJCbG9ja2luZ1ByaW9yaXR5JDIsIGZuLmJpbmQobnVsbCwgYSwgYiwgYywgZCkpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBleGVjdXRpb25Db250ZXh0ID0gcHJldkV4ZWN1dGlvbkNvbnRleHQ7XG5cbiAgICAgIGlmIChleGVjdXRpb25Db250ZXh0ID09PSBOb0NvbnRleHQpIHtcbiAgICAgICAgLy8gRmx1c2ggdGhlIGltbWVkaWF0ZSBjYWxsYmFja3MgdGhhdCB3ZXJlIHNjaGVkdWxlZCBkdXJpbmcgdGhpcyBiYXRjaFxuICAgICAgICByZXNldFJlbmRlclRpbWVyKCk7XG4gICAgICAgIGZsdXNoU3luY0NhbGxiYWNrUXVldWUoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHVuYmF0Y2hlZFVwZGF0ZXMoZm4sIGEpIHtcbiAgdmFyIHByZXZFeGVjdXRpb25Db250ZXh0ID0gZXhlY3V0aW9uQ29udGV4dDtcbiAgZXhlY3V0aW9uQ29udGV4dCAmPSB+QmF0Y2hlZENvbnRleHQ7XG4gIGV4ZWN1dGlvbkNvbnRleHQgfD0gTGVnYWN5VW5iYXRjaGVkQ29udGV4dDtcblxuICB0cnkge1xuICAgIHJldHVybiBmbihhKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBleGVjdXRpb25Db250ZXh0ID0gcHJldkV4ZWN1dGlvbkNvbnRleHQ7XG5cbiAgICBpZiAoZXhlY3V0aW9uQ29udGV4dCA9PT0gTm9Db250ZXh0KSB7XG4gICAgICAvLyBGbHVzaCB0aGUgaW1tZWRpYXRlIGNhbGxiYWNrcyB0aGF0IHdlcmUgc2NoZWR1bGVkIGR1cmluZyB0aGlzIGJhdGNoXG4gICAgICByZXNldFJlbmRlclRpbWVyKCk7XG4gICAgICBmbHVzaFN5bmNDYWxsYmFja1F1ZXVlKCk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBmbHVzaFN5bmMoZm4sIGEpIHtcbiAgdmFyIHByZXZFeGVjdXRpb25Db250ZXh0ID0gZXhlY3V0aW9uQ29udGV4dDtcblxuICBpZiAoKHByZXZFeGVjdXRpb25Db250ZXh0ICYgKFJlbmRlckNvbnRleHQgfCBDb21taXRDb250ZXh0KSkgIT09IE5vQ29udGV4dCkge1xuICAgIHtcbiAgICAgIGVycm9yKCdmbHVzaFN5bmMgd2FzIGNhbGxlZCBmcm9tIGluc2lkZSBhIGxpZmVjeWNsZSBtZXRob2QuIFJlYWN0IGNhbm5vdCAnICsgJ2ZsdXNoIHdoZW4gUmVhY3QgaXMgYWxyZWFkeSByZW5kZXJpbmcuIENvbnNpZGVyIG1vdmluZyB0aGlzIGNhbGwgdG8gJyArICdhIHNjaGVkdWxlciB0YXNrIG9yIG1pY3JvIHRhc2suJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZuKGEpO1xuICB9XG5cbiAgZXhlY3V0aW9uQ29udGV4dCB8PSBCYXRjaGVkQ29udGV4dDtcblxuICB7XG4gICAgdHJ5IHtcbiAgICAgIGlmIChmbikge1xuICAgICAgICByZXR1cm4gcnVuV2l0aFByaW9yaXR5JDEoSW1tZWRpYXRlUHJpb3JpdHkkMSwgZm4uYmluZChudWxsLCBhKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgIH0gZmluYWxseSB7XG4gICAgICBleGVjdXRpb25Db250ZXh0ID0gcHJldkV4ZWN1dGlvbkNvbnRleHQ7IC8vIEZsdXNoIHRoZSBpbW1lZGlhdGUgY2FsbGJhY2tzIHRoYXQgd2VyZSBzY2hlZHVsZWQgZHVyaW5nIHRoaXMgYmF0Y2guXG4gICAgICAvLyBOb3RlIHRoYXQgdGhpcyB3aWxsIGhhcHBlbiBldmVuIGlmIGJhdGNoZWRVcGRhdGVzIGlzIGhpZ2hlciB1cFxuICAgICAgLy8gdGhlIHN0YWNrLlxuXG4gICAgICBmbHVzaFN5bmNDYWxsYmFja1F1ZXVlKCk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBwdXNoUmVuZGVyTGFuZXMoZmliZXIsIGxhbmVzKSB7XG4gIHB1c2goc3VidHJlZVJlbmRlckxhbmVzQ3Vyc29yLCBzdWJ0cmVlUmVuZGVyTGFuZXMsIGZpYmVyKTtcbiAgc3VidHJlZVJlbmRlckxhbmVzID0gbWVyZ2VMYW5lcyhzdWJ0cmVlUmVuZGVyTGFuZXMsIGxhbmVzKTtcbiAgd29ya0luUHJvZ3Jlc3NSb290SW5jbHVkZWRMYW5lcyA9IG1lcmdlTGFuZXMod29ya0luUHJvZ3Jlc3NSb290SW5jbHVkZWRMYW5lcywgbGFuZXMpO1xufVxuZnVuY3Rpb24gcG9wUmVuZGVyTGFuZXMoZmliZXIpIHtcbiAgc3VidHJlZVJlbmRlckxhbmVzID0gc3VidHJlZVJlbmRlckxhbmVzQ3Vyc29yLmN1cnJlbnQ7XG4gIHBvcChzdWJ0cmVlUmVuZGVyTGFuZXNDdXJzb3IsIGZpYmVyKTtcbn1cblxuZnVuY3Rpb24gcHJlcGFyZUZyZXNoU3RhY2socm9vdCwgbGFuZXMpIHtcbiAgcm9vdC5maW5pc2hlZFdvcmsgPSBudWxsO1xuICByb290LmZpbmlzaGVkTGFuZXMgPSBOb0xhbmVzO1xuICB2YXIgdGltZW91dEhhbmRsZSA9IHJvb3QudGltZW91dEhhbmRsZTtcblxuICBpZiAodGltZW91dEhhbmRsZSAhPT0gbm9UaW1lb3V0KSB7XG4gICAgLy8gVGhlIHJvb3QgcHJldmlvdXMgc3VzcGVuZGVkIGFuZCBzY2hlZHVsZWQgYSB0aW1lb3V0IHRvIGNvbW1pdCBhIGZhbGxiYWNrXG4gICAgLy8gc3RhdGUuIE5vdyB0aGF0IHdlIGhhdmUgYWRkaXRpb25hbCB3b3JrLCBjYW5jZWwgdGhlIHRpbWVvdXQuXG4gICAgcm9vdC50aW1lb3V0SGFuZGxlID0gbm9UaW1lb3V0OyAvLyAkRmxvd0ZpeE1lIENvbXBsYWlucyBub1RpbWVvdXQgaXMgbm90IGEgVGltZW91dElELCBkZXNwaXRlIHRoZSBjaGVjayBhYm92ZVxuXG4gICAgY2FuY2VsVGltZW91dCh0aW1lb3V0SGFuZGxlKTtcbiAgfVxuXG4gIGlmICh3b3JrSW5Qcm9ncmVzcyAhPT0gbnVsbCkge1xuICAgIHZhciBpbnRlcnJ1cHRlZFdvcmsgPSB3b3JrSW5Qcm9ncmVzcy5yZXR1cm47XG5cbiAgICB3aGlsZSAoaW50ZXJydXB0ZWRXb3JrICE9PSBudWxsKSB7XG4gICAgICB1bndpbmRJbnRlcnJ1cHRlZFdvcmsoaW50ZXJydXB0ZWRXb3JrKTtcbiAgICAgIGludGVycnVwdGVkV29yayA9IGludGVycnVwdGVkV29yay5yZXR1cm47XG4gICAgfVxuICB9XG5cbiAgd29ya0luUHJvZ3Jlc3NSb290ID0gcm9vdDtcbiAgd29ya0luUHJvZ3Jlc3MgPSBjcmVhdGVXb3JrSW5Qcm9ncmVzcyhyb290LmN1cnJlbnQsIG51bGwpO1xuICB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyA9IHN1YnRyZWVSZW5kZXJMYW5lcyA9IHdvcmtJblByb2dyZXNzUm9vdEluY2x1ZGVkTGFuZXMgPSBsYW5lcztcbiAgd29ya0luUHJvZ3Jlc3NSb290RXhpdFN0YXR1cyA9IFJvb3RJbmNvbXBsZXRlO1xuICB3b3JrSW5Qcm9ncmVzc1Jvb3RGYXRhbEVycm9yID0gbnVsbDtcbiAgd29ya0luUHJvZ3Jlc3NSb290U2tpcHBlZExhbmVzID0gTm9MYW5lcztcbiAgd29ya0luUHJvZ3Jlc3NSb290VXBkYXRlZExhbmVzID0gTm9MYW5lcztcbiAgd29ya0luUHJvZ3Jlc3NSb290UGluZ2VkTGFuZXMgPSBOb0xhbmVzO1xuXG4gIHtcbiAgICBzcGF3bmVkV29ya0R1cmluZ1JlbmRlciA9IG51bGw7XG4gIH1cblxuICB7XG4gICAgUmVhY3RTdHJpY3RNb2RlV2FybmluZ3MuZGlzY2FyZFBlbmRpbmdXYXJuaW5ncygpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGhhbmRsZUVycm9yKHJvb3QsIHRocm93blZhbHVlKSB7XG4gIGRvIHtcbiAgICB2YXIgZXJyb3JlZFdvcmsgPSB3b3JrSW5Qcm9ncmVzcztcblxuICAgIHRyeSB7XG4gICAgICAvLyBSZXNldCBtb2R1bGUtbGV2ZWwgc3RhdGUgdGhhdCB3YXMgc2V0IGR1cmluZyB0aGUgcmVuZGVyIHBoYXNlLlxuICAgICAgcmVzZXRDb250ZXh0RGVwZW5kZW5jaWVzKCk7XG4gICAgICByZXNldEhvb2tzQWZ0ZXJUaHJvdygpO1xuICAgICAgcmVzZXRDdXJyZW50RmliZXIoKTsgLy8gVE9ETzogSSBmb3VuZCBhbmQgYWRkZWQgdGhpcyBtaXNzaW5nIGxpbmUgd2hpbGUgaW52ZXN0aWdhdGluZyBhXG4gICAgICAvLyBzZXBhcmF0ZSBpc3N1ZS4gV3JpdGUgYSByZWdyZXNzaW9uIHRlc3QgdXNpbmcgc3RyaW5nIHJlZnMuXG5cbiAgICAgIFJlYWN0Q3VycmVudE93bmVyJDIuY3VycmVudCA9IG51bGw7XG5cbiAgICAgIGlmIChlcnJvcmVkV29yayA9PT0gbnVsbCB8fCBlcnJvcmVkV29yay5yZXR1cm4gPT09IG51bGwpIHtcbiAgICAgICAgLy8gRXhwZWN0ZWQgdG8gYmUgd29ya2luZyBvbiBhIG5vbi1yb290IGZpYmVyLiBUaGlzIGlzIGEgZmF0YWwgZXJyb3JcbiAgICAgICAgLy8gYmVjYXVzZSB0aGVyZSdzIG5vIGFuY2VzdG9yIHRoYXQgY2FuIGhhbmRsZSBpdDsgdGhlIHJvb3QgaXNcbiAgICAgICAgLy8gc3VwcG9zZWQgdG8gY2FwdHVyZSBhbGwgZXJyb3JzIHRoYXQgd2VyZW4ndCBjYXVnaHQgYnkgYW4gZXJyb3JcbiAgICAgICAgLy8gYm91bmRhcnkuXG4gICAgICAgIHdvcmtJblByb2dyZXNzUm9vdEV4aXRTdGF0dXMgPSBSb290RmF0YWxFcnJvcmVkO1xuICAgICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RGYXRhbEVycm9yID0gdGhyb3duVmFsdWU7IC8vIFNldCBgd29ya0luUHJvZ3Jlc3NgIHRvIG51bGwuIFRoaXMgcmVwcmVzZW50cyBhZHZhbmNpbmcgdG8gdGhlIG5leHRcbiAgICAgICAgLy8gc2libGluZywgb3IgdGhlIHBhcmVudCBpZiB0aGVyZSBhcmUgbm8gc2libGluZ3MuIEJ1dCBzaW5jZSB0aGUgcm9vdFxuICAgICAgICAvLyBoYXMgbm8gc2libGluZ3Mgbm9yIGEgcGFyZW50LCB3ZSBzZXQgaXQgdG8gbnVsbC4gVXN1YWxseSB0aGlzIGlzXG4gICAgICAgIC8vIGhhbmRsZWQgYnkgYGNvbXBsZXRlVW5pdE9mV29ya2Agb3IgYHVud2luZFdvcmtgLCBidXQgc2luY2Ugd2UncmVcbiAgICAgICAgLy8gaW50ZW50aW9uYWxseSBub3QgY2FsbGluZyB0aG9zZSwgd2UgbmVlZCBzZXQgaXQgaGVyZS5cbiAgICAgICAgLy8gVE9ETzogQ29uc2lkZXIgY2FsbGluZyBgdW53aW5kV29ya2AgdG8gcG9wIHRoZSBjb250ZXh0cy5cblxuICAgICAgICB3b3JrSW5Qcm9ncmVzcyA9IG51bGw7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKGVuYWJsZVByb2ZpbGVyVGltZXIgJiYgZXJyb3JlZFdvcmsubW9kZSAmIFByb2ZpbGVNb2RlKSB7XG4gICAgICAgIC8vIFJlY29yZCB0aGUgdGltZSBzcGVudCByZW5kZXJpbmcgYmVmb3JlIGFuIGVycm9yIHdhcyB0aHJvd24uIFRoaXNcbiAgICAgICAgLy8gYXZvaWRzIGluYWNjdXJhdGUgUHJvZmlsZXIgZHVyYXRpb25zIGluIHRoZSBjYXNlIG9mIGFcbiAgICAgICAgLy8gc3VzcGVuZGVkIHJlbmRlci5cbiAgICAgICAgc3RvcFByb2ZpbGVyVGltZXJJZlJ1bm5pbmdBbmRSZWNvcmREZWx0YShlcnJvcmVkV29yaywgdHJ1ZSk7XG4gICAgICB9XG5cbiAgICAgIHRocm93RXhjZXB0aW9uKHJvb3QsIGVycm9yZWRXb3JrLnJldHVybiwgZXJyb3JlZFdvcmssIHRocm93blZhbHVlLCB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyk7XG4gICAgICBjb21wbGV0ZVVuaXRPZldvcmsoZXJyb3JlZFdvcmspO1xuICAgIH0gY2F0Y2ggKHlldEFub3RoZXJUaHJvd25WYWx1ZSkge1xuICAgICAgLy8gU29tZXRoaW5nIGluIHRoZSByZXR1cm4gcGF0aCBhbHNvIHRocmV3LlxuICAgICAgdGhyb3duVmFsdWUgPSB5ZXRBbm90aGVyVGhyb3duVmFsdWU7XG5cbiAgICAgIGlmICh3b3JrSW5Qcm9ncmVzcyA9PT0gZXJyb3JlZFdvcmsgJiYgZXJyb3JlZFdvcmsgIT09IG51bGwpIHtcbiAgICAgICAgLy8gSWYgdGhpcyBib3VuZGFyeSBoYXMgYWxyZWFkeSBlcnJvcmVkLCB0aGVuIHdlIGhhZCB0cm91YmxlIHByb2Nlc3NpbmdcbiAgICAgICAgLy8gdGhlIGVycm9yLiBCdWJibGUgaXQgdG8gdGhlIG5leHQgYm91bmRhcnkuXG4gICAgICAgIGVycm9yZWRXb3JrID0gZXJyb3JlZFdvcmsucmV0dXJuO1xuICAgICAgICB3b3JrSW5Qcm9ncmVzcyA9IGVycm9yZWRXb3JrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZXJyb3JlZFdvcmsgPSB3b3JrSW5Qcm9ncmVzcztcbiAgICAgIH1cblxuICAgICAgY29udGludWU7XG4gICAgfSAvLyBSZXR1cm4gdG8gdGhlIG5vcm1hbCB3b3JrIGxvb3AuXG5cblxuICAgIHJldHVybjtcbiAgfSB3aGlsZSAodHJ1ZSk7XG59XG5cbmZ1bmN0aW9uIHB1c2hEaXNwYXRjaGVyKCkge1xuICB2YXIgcHJldkRpc3BhdGNoZXIgPSBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDIuY3VycmVudDtcbiAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQyLmN1cnJlbnQgPSBDb250ZXh0T25seURpc3BhdGNoZXI7XG5cbiAgaWYgKHByZXZEaXNwYXRjaGVyID09PSBudWxsKSB7XG4gICAgLy8gVGhlIFJlYWN0IGlzb21vcnBoaWMgcGFja2FnZSBkb2VzIG5vdCBpbmNsdWRlIGEgZGVmYXVsdCBkaXNwYXRjaGVyLlxuICAgIC8vIEluc3RlYWQgdGhlIGZpcnN0IHJlbmRlcmVyIHdpbGwgbGF6aWx5IGF0dGFjaCBvbmUsIGluIG9yZGVyIHRvIGdpdmVcbiAgICAvLyBuaWNlciBlcnJvciBtZXNzYWdlcy5cbiAgICByZXR1cm4gQ29udGV4dE9ubHlEaXNwYXRjaGVyO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBwcmV2RGlzcGF0Y2hlcjtcbiAgfVxufVxuXG5mdW5jdGlvbiBwb3BEaXNwYXRjaGVyKHByZXZEaXNwYXRjaGVyKSB7XG4gIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMi5jdXJyZW50ID0gcHJldkRpc3BhdGNoZXI7XG59XG5cbmZ1bmN0aW9uIHB1c2hJbnRlcmFjdGlvbnMocm9vdCkge1xuICB7XG4gICAgdmFyIHByZXZJbnRlcmFjdGlvbnMgPSB0cmFjaW5nLl9faW50ZXJhY3Rpb25zUmVmLmN1cnJlbnQ7XG4gICAgdHJhY2luZy5fX2ludGVyYWN0aW9uc1JlZi5jdXJyZW50ID0gcm9vdC5tZW1vaXplZEludGVyYWN0aW9ucztcbiAgICByZXR1cm4gcHJldkludGVyYWN0aW9ucztcbiAgfVxufVxuXG5mdW5jdGlvbiBwb3BJbnRlcmFjdGlvbnMocHJldkludGVyYWN0aW9ucykge1xuICB7XG4gICAgdHJhY2luZy5fX2ludGVyYWN0aW9uc1JlZi5jdXJyZW50ID0gcHJldkludGVyYWN0aW9ucztcbiAgfVxufVxuXG5mdW5jdGlvbiBtYXJrQ29tbWl0VGltZU9mRmFsbGJhY2soKSB7XG4gIGdsb2JhbE1vc3RSZWNlbnRGYWxsYmFja1RpbWUgPSBub3coKTtcbn1cbmZ1bmN0aW9uIG1hcmtTa2lwcGVkVXBkYXRlTGFuZXMobGFuZSkge1xuICB3b3JrSW5Qcm9ncmVzc1Jvb3RTa2lwcGVkTGFuZXMgPSBtZXJnZUxhbmVzKGxhbmUsIHdvcmtJblByb2dyZXNzUm9vdFNraXBwZWRMYW5lcyk7XG59XG5mdW5jdGlvbiByZW5kZXJEaWRTdXNwZW5kKCkge1xuICBpZiAod29ya0luUHJvZ3Jlc3NSb290RXhpdFN0YXR1cyA9PT0gUm9vdEluY29tcGxldGUpIHtcbiAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RFeGl0U3RhdHVzID0gUm9vdFN1c3BlbmRlZDtcbiAgfVxufVxuZnVuY3Rpb24gcmVuZGVyRGlkU3VzcGVuZERlbGF5SWZQb3NzaWJsZSgpIHtcbiAgaWYgKHdvcmtJblByb2dyZXNzUm9vdEV4aXRTdGF0dXMgPT09IFJvb3RJbmNvbXBsZXRlIHx8IHdvcmtJblByb2dyZXNzUm9vdEV4aXRTdGF0dXMgPT09IFJvb3RTdXNwZW5kZWQpIHtcbiAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RFeGl0U3RhdHVzID0gUm9vdFN1c3BlbmRlZFdpdGhEZWxheTtcbiAgfSAvLyBDaGVjayBpZiB0aGVyZSBhcmUgdXBkYXRlcyB0aGF0IHdlIHNraXBwZWQgdHJlZSB0aGF0IG1pZ2h0IGhhdmUgdW5ibG9ja2VkXG4gIC8vIHRoaXMgcmVuZGVyLlxuXG5cbiAgaWYgKHdvcmtJblByb2dyZXNzUm9vdCAhPT0gbnVsbCAmJiAoaW5jbHVkZXNOb25JZGxlV29yayh3b3JrSW5Qcm9ncmVzc1Jvb3RTa2lwcGVkTGFuZXMpIHx8IGluY2x1ZGVzTm9uSWRsZVdvcmsod29ya0luUHJvZ3Jlc3NSb290VXBkYXRlZExhbmVzKSkpIHtcbiAgICAvLyBNYXJrIHRoZSBjdXJyZW50IHJlbmRlciBhcyBzdXNwZW5kZWQgc28gdGhhdCB3ZSBzd2l0Y2ggdG8gd29ya2luZyBvblxuICAgIC8vIHRoZSB1cGRhdGVzIHRoYXQgd2VyZSBza2lwcGVkLiBVc3VhbGx5IHdlIG9ubHkgc3VzcGVuZCBhdCB0aGUgZW5kIG9mXG4gICAgLy8gdGhlIHJlbmRlciBwaGFzZS5cbiAgICAvLyBUT0RPOiBXZSBzaG91bGQgcHJvYmFibHkgYWx3YXlzIG1hcmsgdGhlIHJvb3QgYXMgc3VzcGVuZGVkIGltbWVkaWF0ZWx5XG4gICAgLy8gKGluc2lkZSB0aGlzIGZ1bmN0aW9uKSwgc2luY2UgYnkgc3VzcGVuZGluZyBhdCB0aGUgZW5kIG9mIHRoZSByZW5kZXJcbiAgICAvLyBwaGFzZSBpbnRyb2R1Y2VzIGEgcG90ZW50aWFsIG1pc3Rha2Ugd2hlcmUgd2Ugc3VzcGVuZCBsYW5lcyB0aGF0IHdlcmVcbiAgICAvLyBwaW5nZWQgb3IgdXBkYXRlZCB3aGlsZSB3ZSB3ZXJlIHJlbmRlcmluZy5cbiAgICBtYXJrUm9vdFN1c3BlbmRlZCQxKHdvcmtJblByb2dyZXNzUm9vdCwgd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMpO1xuICB9XG59XG5mdW5jdGlvbiByZW5kZXJEaWRFcnJvcigpIHtcbiAgaWYgKHdvcmtJblByb2dyZXNzUm9vdEV4aXRTdGF0dXMgIT09IFJvb3RDb21wbGV0ZWQpIHtcbiAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RFeGl0U3RhdHVzID0gUm9vdEVycm9yZWQ7XG4gIH1cbn0gLy8gQ2FsbGVkIGR1cmluZyByZW5kZXIgdG8gZGV0ZXJtaW5lIGlmIGFueXRoaW5nIGhhcyBzdXNwZW5kZWQuXG4vLyBSZXR1cm5zIGZhbHNlIGlmIHdlJ3JlIG5vdCBzdXJlLlxuXG5mdW5jdGlvbiByZW5kZXJIYXNOb3RTdXNwZW5kZWRZZXQoKSB7XG4gIC8vIElmIHNvbWV0aGluZyBlcnJvcmVkIG9yIGNvbXBsZXRlZCwgd2UgY2FuJ3QgcmVhbGx5IGJlIHN1cmUsXG4gIC8vIHNvIHRob3NlIGFyZSBmYWxzZS5cbiAgcmV0dXJuIHdvcmtJblByb2dyZXNzUm9vdEV4aXRTdGF0dXMgPT09IFJvb3RJbmNvbXBsZXRlO1xufVxuXG5mdW5jdGlvbiByZW5kZXJSb290U3luYyhyb290LCBsYW5lcykge1xuICB2YXIgcHJldkV4ZWN1dGlvbkNvbnRleHQgPSBleGVjdXRpb25Db250ZXh0O1xuICBleGVjdXRpb25Db250ZXh0IHw9IFJlbmRlckNvbnRleHQ7XG4gIHZhciBwcmV2RGlzcGF0Y2hlciA9IHB1c2hEaXNwYXRjaGVyKCk7IC8vIElmIHRoZSByb290IG9yIGxhbmVzIGhhdmUgY2hhbmdlZCwgdGhyb3cgb3V0IHRoZSBleGlzdGluZyBzdGFja1xuICAvLyBhbmQgcHJlcGFyZSBhIGZyZXNoIG9uZS4gT3RoZXJ3aXNlIHdlJ2xsIGNvbnRpbnVlIHdoZXJlIHdlIGxlZnQgb2ZmLlxuXG4gIGlmICh3b3JrSW5Qcm9ncmVzc1Jvb3QgIT09IHJvb3QgfHwgd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMgIT09IGxhbmVzKSB7XG4gICAgcHJlcGFyZUZyZXNoU3RhY2socm9vdCwgbGFuZXMpO1xuICAgIHN0YXJ0V29ya09uUGVuZGluZ0ludGVyYWN0aW9ucyhyb290LCBsYW5lcyk7XG4gIH1cblxuICB2YXIgcHJldkludGVyYWN0aW9ucyA9IHB1c2hJbnRlcmFjdGlvbnMocm9vdCk7XG5cbiAgZG8ge1xuICAgIHRyeSB7XG4gICAgICB3b3JrTG9vcFN5bmMoKTtcbiAgICAgIGJyZWFrO1xuICAgIH0gY2F0Y2ggKHRocm93blZhbHVlKSB7XG4gICAgICBoYW5kbGVFcnJvcihyb290LCB0aHJvd25WYWx1ZSk7XG4gICAgfVxuICB9IHdoaWxlICh0cnVlKTtcblxuICByZXNldENvbnRleHREZXBlbmRlbmNpZXMoKTtcblxuICB7XG4gICAgcG9wSW50ZXJhY3Rpb25zKHByZXZJbnRlcmFjdGlvbnMpO1xuICB9XG5cbiAgZXhlY3V0aW9uQ29udGV4dCA9IHByZXZFeGVjdXRpb25Db250ZXh0O1xuICBwb3BEaXNwYXRjaGVyKHByZXZEaXNwYXRjaGVyKTtcblxuICBpZiAod29ya0luUHJvZ3Jlc3MgIT09IG51bGwpIHtcbiAgICAvLyBUaGlzIGlzIGEgc3luYyByZW5kZXIsIHNvIHdlIHNob3VsZCBoYXZlIGZpbmlzaGVkIHRoZSB3aG9sZSB0cmVlLlxuICAgIHtcbiAgICAgIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoIFwiQ2Fubm90IGNvbW1pdCBhbiBpbmNvbXBsZXRlIHJvb3QuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCIgKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuXG4gIHdvcmtJblByb2dyZXNzUm9vdCA9IG51bGw7XG4gIHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzID0gTm9MYW5lcztcbiAgcmV0dXJuIHdvcmtJblByb2dyZXNzUm9vdEV4aXRTdGF0dXM7XG59IC8vIFRoZSB3b3JrIGxvb3AgaXMgYW4gZXh0cmVtZWx5IGhvdCBwYXRoLiBUZWxsIENsb3N1cmUgbm90IHRvIGlubGluZSBpdC5cblxuLyoqIEBub2lubGluZSAqL1xuXG5cbmZ1bmN0aW9uIHdvcmtMb29wU3luYygpIHtcbiAgLy8gQWxyZWFkeSB0aW1lZCBvdXQsIHNvIHBlcmZvcm0gd29yayB3aXRob3V0IGNoZWNraW5nIGlmIHdlIG5lZWQgdG8geWllbGQuXG4gIHdoaWxlICh3b3JrSW5Qcm9ncmVzcyAhPT0gbnVsbCkge1xuICAgIHBlcmZvcm1Vbml0T2ZXb3JrKHdvcmtJblByb2dyZXNzKTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZW5kZXJSb290Q29uY3VycmVudChyb290LCBsYW5lcykge1xuICB2YXIgcHJldkV4ZWN1dGlvbkNvbnRleHQgPSBleGVjdXRpb25Db250ZXh0O1xuICBleGVjdXRpb25Db250ZXh0IHw9IFJlbmRlckNvbnRleHQ7XG4gIHZhciBwcmV2RGlzcGF0Y2hlciA9IHB1c2hEaXNwYXRjaGVyKCk7IC8vIElmIHRoZSByb290IG9yIGxhbmVzIGhhdmUgY2hhbmdlZCwgdGhyb3cgb3V0IHRoZSBleGlzdGluZyBzdGFja1xuICAvLyBhbmQgcHJlcGFyZSBhIGZyZXNoIG9uZS4gT3RoZXJ3aXNlIHdlJ2xsIGNvbnRpbnVlIHdoZXJlIHdlIGxlZnQgb2ZmLlxuXG4gIGlmICh3b3JrSW5Qcm9ncmVzc1Jvb3QgIT09IHJvb3QgfHwgd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMgIT09IGxhbmVzKSB7XG4gICAgcmVzZXRSZW5kZXJUaW1lcigpO1xuICAgIHByZXBhcmVGcmVzaFN0YWNrKHJvb3QsIGxhbmVzKTtcbiAgICBzdGFydFdvcmtPblBlbmRpbmdJbnRlcmFjdGlvbnMocm9vdCwgbGFuZXMpO1xuICB9XG5cbiAgdmFyIHByZXZJbnRlcmFjdGlvbnMgPSBwdXNoSW50ZXJhY3Rpb25zKHJvb3QpO1xuXG4gIGRvIHtcbiAgICB0cnkge1xuICAgICAgd29ya0xvb3BDb25jdXJyZW50KCk7XG4gICAgICBicmVhaztcbiAgICB9IGNhdGNoICh0aHJvd25WYWx1ZSkge1xuICAgICAgaGFuZGxlRXJyb3Iocm9vdCwgdGhyb3duVmFsdWUpO1xuICAgIH1cbiAgfSB3aGlsZSAodHJ1ZSk7XG5cbiAgcmVzZXRDb250ZXh0RGVwZW5kZW5jaWVzKCk7XG5cbiAge1xuICAgIHBvcEludGVyYWN0aW9ucyhwcmV2SW50ZXJhY3Rpb25zKTtcbiAgfVxuXG4gIHBvcERpc3BhdGNoZXIocHJldkRpc3BhdGNoZXIpO1xuICBleGVjdXRpb25Db250ZXh0ID0gcHJldkV4ZWN1dGlvbkNvbnRleHQ7XG5cblxuICBpZiAod29ya0luUHJvZ3Jlc3MgIT09IG51bGwpIHtcblxuICAgIHJldHVybiBSb290SW5jb21wbGV0ZTtcbiAgfSBlbHNlIHtcblxuXG4gICAgd29ya0luUHJvZ3Jlc3NSb290ID0gbnVsbDtcbiAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyA9IE5vTGFuZXM7IC8vIFJldHVybiB0aGUgZmluYWwgZXhpdCBzdGF0dXMuXG5cbiAgICByZXR1cm4gd29ya0luUHJvZ3Jlc3NSb290RXhpdFN0YXR1cztcbiAgfVxufVxuLyoqIEBub2lubGluZSAqL1xuXG5cbmZ1bmN0aW9uIHdvcmtMb29wQ29uY3VycmVudCgpIHtcbiAgLy8gUGVyZm9ybSB3b3JrIHVudGlsIFNjaGVkdWxlciBhc2tzIHVzIHRvIHlpZWxkXG4gIHdoaWxlICh3b3JrSW5Qcm9ncmVzcyAhPT0gbnVsbCAmJiAhc2hvdWxkWWllbGQoKSkge1xuICAgIHBlcmZvcm1Vbml0T2ZXb3JrKHdvcmtJblByb2dyZXNzKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwZXJmb3JtVW5pdE9mV29yayh1bml0T2ZXb3JrKSB7XG4gIC8vIFRoZSBjdXJyZW50LCBmbHVzaGVkLCBzdGF0ZSBvZiB0aGlzIGZpYmVyIGlzIHRoZSBhbHRlcm5hdGUuIElkZWFsbHlcbiAgLy8gbm90aGluZyBzaG91bGQgcmVseSBvbiB0aGlzLCBidXQgcmVseWluZyBvbiBpdCBoZXJlIG1lYW5zIHRoYXQgd2UgZG9uJ3RcbiAgLy8gbmVlZCBhbiBhZGRpdGlvbmFsIGZpZWxkIG9uIHRoZSB3b3JrIGluIHByb2dyZXNzLlxuICB2YXIgY3VycmVudCA9IHVuaXRPZldvcmsuYWx0ZXJuYXRlO1xuICBzZXRDdXJyZW50RmliZXIodW5pdE9mV29yayk7XG4gIHZhciBuZXh0O1xuXG4gIGlmICggKHVuaXRPZldvcmsubW9kZSAmIFByb2ZpbGVNb2RlKSAhPT0gTm9Nb2RlKSB7XG4gICAgc3RhcnRQcm9maWxlclRpbWVyKHVuaXRPZldvcmspO1xuICAgIG5leHQgPSBiZWdpbldvcmskMShjdXJyZW50LCB1bml0T2ZXb3JrLCBzdWJ0cmVlUmVuZGVyTGFuZXMpO1xuICAgIHN0b3BQcm9maWxlclRpbWVySWZSdW5uaW5nQW5kUmVjb3JkRGVsdGEodW5pdE9mV29yaywgdHJ1ZSk7XG4gIH0gZWxzZSB7XG4gICAgbmV4dCA9IGJlZ2luV29yayQxKGN1cnJlbnQsIHVuaXRPZldvcmssIHN1YnRyZWVSZW5kZXJMYW5lcyk7XG4gIH1cblxuICByZXNldEN1cnJlbnRGaWJlcigpO1xuICB1bml0T2ZXb3JrLm1lbW9pemVkUHJvcHMgPSB1bml0T2ZXb3JrLnBlbmRpbmdQcm9wcztcblxuICBpZiAobmV4dCA9PT0gbnVsbCkge1xuICAgIC8vIElmIHRoaXMgZG9lc24ndCBzcGF3biBuZXcgd29yaywgY29tcGxldGUgdGhlIGN1cnJlbnQgd29yay5cbiAgICBjb21wbGV0ZVVuaXRPZldvcmsodW5pdE9mV29yayk7XG4gIH0gZWxzZSB7XG4gICAgd29ya0luUHJvZ3Jlc3MgPSBuZXh0O1xuICB9XG5cbiAgUmVhY3RDdXJyZW50T3duZXIkMi5jdXJyZW50ID0gbnVsbDtcbn1cblxuZnVuY3Rpb24gY29tcGxldGVVbml0T2ZXb3JrKHVuaXRPZldvcmspIHtcbiAgLy8gQXR0ZW1wdCB0byBjb21wbGV0ZSB0aGUgY3VycmVudCB1bml0IG9mIHdvcmssIHRoZW4gbW92ZSB0byB0aGUgbmV4dFxuICAvLyBzaWJsaW5nLiBJZiB0aGVyZSBhcmUgbm8gbW9yZSBzaWJsaW5ncywgcmV0dXJuIHRvIHRoZSBwYXJlbnQgZmliZXIuXG4gIHZhciBjb21wbGV0ZWRXb3JrID0gdW5pdE9mV29yaztcblxuICBkbyB7XG4gICAgLy8gVGhlIGN1cnJlbnQsIGZsdXNoZWQsIHN0YXRlIG9mIHRoaXMgZmliZXIgaXMgdGhlIGFsdGVybmF0ZS4gSWRlYWxseVxuICAgIC8vIG5vdGhpbmcgc2hvdWxkIHJlbHkgb24gdGhpcywgYnV0IHJlbHlpbmcgb24gaXQgaGVyZSBtZWFucyB0aGF0IHdlIGRvbid0XG4gICAgLy8gbmVlZCBhbiBhZGRpdGlvbmFsIGZpZWxkIG9uIHRoZSB3b3JrIGluIHByb2dyZXNzLlxuICAgIHZhciBjdXJyZW50ID0gY29tcGxldGVkV29yay5hbHRlcm5hdGU7XG4gICAgdmFyIHJldHVybkZpYmVyID0gY29tcGxldGVkV29yay5yZXR1cm47IC8vIENoZWNrIGlmIHRoZSB3b3JrIGNvbXBsZXRlZCBvciBpZiBzb21ldGhpbmcgdGhyZXcuXG5cbiAgICBpZiAoKGNvbXBsZXRlZFdvcmsuZmxhZ3MgJiBJbmNvbXBsZXRlKSA9PT0gTm9GbGFncykge1xuICAgICAgc2V0Q3VycmVudEZpYmVyKGNvbXBsZXRlZFdvcmspO1xuICAgICAgdmFyIG5leHQgPSB2b2lkIDA7XG5cbiAgICAgIGlmICggKGNvbXBsZXRlZFdvcmsubW9kZSAmIFByb2ZpbGVNb2RlKSA9PT0gTm9Nb2RlKSB7XG4gICAgICAgIG5leHQgPSBjb21wbGV0ZVdvcmsoY3VycmVudCwgY29tcGxldGVkV29yaywgc3VidHJlZVJlbmRlckxhbmVzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXJ0UHJvZmlsZXJUaW1lcihjb21wbGV0ZWRXb3JrKTtcbiAgICAgICAgbmV4dCA9IGNvbXBsZXRlV29yayhjdXJyZW50LCBjb21wbGV0ZWRXb3JrLCBzdWJ0cmVlUmVuZGVyTGFuZXMpOyAvLyBVcGRhdGUgcmVuZGVyIGR1cmF0aW9uIGFzc3VtaW5nIHdlIGRpZG4ndCBlcnJvci5cblxuICAgICAgICBzdG9wUHJvZmlsZXJUaW1lcklmUnVubmluZ0FuZFJlY29yZERlbHRhKGNvbXBsZXRlZFdvcmssIGZhbHNlKTtcbiAgICAgIH1cblxuICAgICAgcmVzZXRDdXJyZW50RmliZXIoKTtcblxuICAgICAgaWYgKG5leHQgIT09IG51bGwpIHtcbiAgICAgICAgLy8gQ29tcGxldGluZyB0aGlzIGZpYmVyIHNwYXduZWQgbmV3IHdvcmsuIFdvcmsgb24gdGhhdCBuZXh0LlxuICAgICAgICB3b3JrSW5Qcm9ncmVzcyA9IG5leHQ7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgcmVzZXRDaGlsZExhbmVzKGNvbXBsZXRlZFdvcmspO1xuXG4gICAgICBpZiAocmV0dXJuRmliZXIgIT09IG51bGwgJiYgLy8gRG8gbm90IGFwcGVuZCBlZmZlY3RzIHRvIHBhcmVudHMgaWYgYSBzaWJsaW5nIGZhaWxlZCB0byBjb21wbGV0ZVxuICAgICAgKHJldHVybkZpYmVyLmZsYWdzICYgSW5jb21wbGV0ZSkgPT09IE5vRmxhZ3MpIHtcbiAgICAgICAgLy8gQXBwZW5kIGFsbCB0aGUgZWZmZWN0cyBvZiB0aGUgc3VidHJlZSBhbmQgdGhpcyBmaWJlciBvbnRvIHRoZSBlZmZlY3RcbiAgICAgICAgLy8gbGlzdCBvZiB0aGUgcGFyZW50LiBUaGUgY29tcGxldGlvbiBvcmRlciBvZiB0aGUgY2hpbGRyZW4gYWZmZWN0cyB0aGVcbiAgICAgICAgLy8gc2lkZS1lZmZlY3Qgb3JkZXIuXG4gICAgICAgIGlmIChyZXR1cm5GaWJlci5maXJzdEVmZmVjdCA9PT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybkZpYmVyLmZpcnN0RWZmZWN0ID0gY29tcGxldGVkV29yay5maXJzdEVmZmVjdDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjb21wbGV0ZWRXb3JrLmxhc3RFZmZlY3QgIT09IG51bGwpIHtcbiAgICAgICAgICBpZiAocmV0dXJuRmliZXIubGFzdEVmZmVjdCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuRmliZXIubGFzdEVmZmVjdC5uZXh0RWZmZWN0ID0gY29tcGxldGVkV29yay5maXJzdEVmZmVjdDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm5GaWJlci5sYXN0RWZmZWN0ID0gY29tcGxldGVkV29yay5sYXN0RWZmZWN0O1xuICAgICAgICB9IC8vIElmIHRoaXMgZmliZXIgaGFkIHNpZGUtZWZmZWN0cywgd2UgYXBwZW5kIGl0IEFGVEVSIHRoZSBjaGlsZHJlbidzXG4gICAgICAgIC8vIHNpZGUtZWZmZWN0cy4gV2UgY2FuIHBlcmZvcm0gY2VydGFpbiBzaWRlLWVmZmVjdHMgZWFybGllciBpZiBuZWVkZWQsXG4gICAgICAgIC8vIGJ5IGRvaW5nIG11bHRpcGxlIHBhc3NlcyBvdmVyIHRoZSBlZmZlY3QgbGlzdC4gV2UgZG9uJ3Qgd2FudCB0b1xuICAgICAgICAvLyBzY2hlZHVsZSBvdXIgb3duIHNpZGUtZWZmZWN0IG9uIG91ciBvd24gbGlzdCBiZWNhdXNlIGlmIGVuZCB1cFxuICAgICAgICAvLyByZXVzaW5nIGNoaWxkcmVuIHdlJ2xsIHNjaGVkdWxlIHRoaXMgZWZmZWN0IG9udG8gaXRzZWxmIHNpbmNlIHdlJ3JlXG4gICAgICAgIC8vIGF0IHRoZSBlbmQuXG5cblxuICAgICAgICB2YXIgZmxhZ3MgPSBjb21wbGV0ZWRXb3JrLmZsYWdzOyAvLyBTa2lwIGJvdGggTm9Xb3JrIGFuZCBQZXJmb3JtZWRXb3JrIHRhZ3Mgd2hlbiBjcmVhdGluZyB0aGUgZWZmZWN0XG4gICAgICAgIC8vIGxpc3QuIFBlcmZvcm1lZFdvcmsgZWZmZWN0IGlzIHJlYWQgYnkgUmVhY3QgRGV2VG9vbHMgYnV0IHNob3VsZG4ndCBiZVxuICAgICAgICAvLyBjb21taXR0ZWQuXG5cbiAgICAgICAgaWYgKGZsYWdzID4gUGVyZm9ybWVkV29yaykge1xuICAgICAgICAgIGlmIChyZXR1cm5GaWJlci5sYXN0RWZmZWN0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm5GaWJlci5sYXN0RWZmZWN0Lm5leHRFZmZlY3QgPSBjb21wbGV0ZWRXb3JrO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm5GaWJlci5maXJzdEVmZmVjdCA9IGNvbXBsZXRlZFdvcms7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuRmliZXIubGFzdEVmZmVjdCA9IGNvbXBsZXRlZFdvcms7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVGhpcyBmaWJlciBkaWQgbm90IGNvbXBsZXRlIGJlY2F1c2Ugc29tZXRoaW5nIHRocmV3LiBQb3AgdmFsdWVzIG9mZlxuICAgICAgLy8gdGhlIHN0YWNrIHdpdGhvdXQgZW50ZXJpbmcgdGhlIGNvbXBsZXRlIHBoYXNlLiBJZiB0aGlzIGlzIGEgYm91bmRhcnksXG4gICAgICAvLyBjYXB0dXJlIHZhbHVlcyBpZiBwb3NzaWJsZS5cbiAgICAgIHZhciBfbmV4dCA9IHVud2luZFdvcmsoY29tcGxldGVkV29yayk7IC8vIEJlY2F1c2UgdGhpcyBmaWJlciBkaWQgbm90IGNvbXBsZXRlLCBkb24ndCByZXNldCBpdHMgZXhwaXJhdGlvbiB0aW1lLlxuXG5cbiAgICAgIGlmIChfbmV4dCAhPT0gbnVsbCkge1xuICAgICAgICAvLyBJZiBjb21wbGV0aW5nIHRoaXMgd29yayBzcGF3bmVkIG5ldyB3b3JrLCBkbyB0aGF0IG5leHQuIFdlJ2xsIGNvbWVcbiAgICAgICAgLy8gYmFjayBoZXJlIGFnYWluLlxuICAgICAgICAvLyBTaW5jZSB3ZSdyZSByZXN0YXJ0aW5nLCByZW1vdmUgYW55dGhpbmcgdGhhdCBpcyBub3QgYSBob3N0IGVmZmVjdFxuICAgICAgICAvLyBmcm9tIHRoZSBlZmZlY3QgdGFnLlxuICAgICAgICBfbmV4dC5mbGFncyAmPSBIb3N0RWZmZWN0TWFzaztcbiAgICAgICAgd29ya0luUHJvZ3Jlc3MgPSBfbmV4dDtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoIChjb21wbGV0ZWRXb3JrLm1vZGUgJiBQcm9maWxlTW9kZSkgIT09IE5vTW9kZSkge1xuICAgICAgICAvLyBSZWNvcmQgdGhlIHJlbmRlciBkdXJhdGlvbiBmb3IgdGhlIGZpYmVyIHRoYXQgZXJyb3JlZC5cbiAgICAgICAgc3RvcFByb2ZpbGVyVGltZXJJZlJ1bm5pbmdBbmRSZWNvcmREZWx0YShjb21wbGV0ZWRXb3JrLCBmYWxzZSk7IC8vIEluY2x1ZGUgdGhlIHRpbWUgc3BlbnQgd29ya2luZyBvbiBmYWlsZWQgY2hpbGRyZW4gYmVmb3JlIGNvbnRpbnVpbmcuXG5cbiAgICAgICAgdmFyIGFjdHVhbER1cmF0aW9uID0gY29tcGxldGVkV29yay5hY3R1YWxEdXJhdGlvbjtcbiAgICAgICAgdmFyIGNoaWxkID0gY29tcGxldGVkV29yay5jaGlsZDtcblxuICAgICAgICB3aGlsZSAoY2hpbGQgIT09IG51bGwpIHtcbiAgICAgICAgICBhY3R1YWxEdXJhdGlvbiArPSBjaGlsZC5hY3R1YWxEdXJhdGlvbjtcbiAgICAgICAgICBjaGlsZCA9IGNoaWxkLnNpYmxpbmc7XG4gICAgICAgIH1cblxuICAgICAgICBjb21wbGV0ZWRXb3JrLmFjdHVhbER1cmF0aW9uID0gYWN0dWFsRHVyYXRpb247XG4gICAgICB9XG5cbiAgICAgIGlmIChyZXR1cm5GaWJlciAhPT0gbnVsbCkge1xuICAgICAgICAvLyBNYXJrIHRoZSBwYXJlbnQgZmliZXIgYXMgaW5jb21wbGV0ZSBhbmQgY2xlYXIgaXRzIGVmZmVjdCBsaXN0LlxuICAgICAgICByZXR1cm5GaWJlci5maXJzdEVmZmVjdCA9IHJldHVybkZpYmVyLmxhc3RFZmZlY3QgPSBudWxsO1xuICAgICAgICByZXR1cm5GaWJlci5mbGFncyB8PSBJbmNvbXBsZXRlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBzaWJsaW5nRmliZXIgPSBjb21wbGV0ZWRXb3JrLnNpYmxpbmc7XG5cbiAgICBpZiAoc2libGluZ0ZpYmVyICE9PSBudWxsKSB7XG4gICAgICAvLyBJZiB0aGVyZSBpcyBtb3JlIHdvcmsgdG8gZG8gaW4gdGhpcyByZXR1cm5GaWJlciwgZG8gdGhhdCBuZXh0LlxuICAgICAgd29ya0luUHJvZ3Jlc3MgPSBzaWJsaW5nRmliZXI7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBPdGhlcndpc2UsIHJldHVybiB0byB0aGUgcGFyZW50XG5cblxuICAgIGNvbXBsZXRlZFdvcmsgPSByZXR1cm5GaWJlcjsgLy8gVXBkYXRlIHRoZSBuZXh0IHRoaW5nIHdlJ3JlIHdvcmtpbmcgb24gaW4gY2FzZSBzb21ldGhpbmcgdGhyb3dzLlxuXG4gICAgd29ya0luUHJvZ3Jlc3MgPSBjb21wbGV0ZWRXb3JrO1xuICB9IHdoaWxlIChjb21wbGV0ZWRXb3JrICE9PSBudWxsKTsgLy8gV2UndmUgcmVhY2hlZCB0aGUgcm9vdC5cblxuXG4gIGlmICh3b3JrSW5Qcm9ncmVzc1Jvb3RFeGl0U3RhdHVzID09PSBSb290SW5jb21wbGV0ZSkge1xuICAgIHdvcmtJblByb2dyZXNzUm9vdEV4aXRTdGF0dXMgPSBSb290Q29tcGxldGVkO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlc2V0Q2hpbGRMYW5lcyhjb21wbGV0ZWRXb3JrKSB7XG4gIGlmICggLy8gVE9ETzogTW92ZSB0aGlzIGNoZWNrIG91dCBvZiB0aGUgaG90IHBhdGggYnkgbW92aW5nIGByZXNldENoaWxkTGFuZXNgXG4gIC8vIHRvIHN3aXRjaCBzdGF0ZW1lbnQgaW4gYGNvbXBsZXRlV29ya2AuXG4gIChjb21wbGV0ZWRXb3JrLnRhZyA9PT0gTGVnYWN5SGlkZGVuQ29tcG9uZW50IHx8IGNvbXBsZXRlZFdvcmsudGFnID09PSBPZmZzY3JlZW5Db21wb25lbnQpICYmIGNvbXBsZXRlZFdvcmsubWVtb2l6ZWRTdGF0ZSAhPT0gbnVsbCAmJiAhaW5jbHVkZXNTb21lTGFuZShzdWJ0cmVlUmVuZGVyTGFuZXMsIE9mZnNjcmVlbkxhbmUpICYmIChjb21wbGV0ZWRXb3JrLm1vZGUgJiBDb25jdXJyZW50TW9kZSkgIT09IE5vTGFuZXMpIHtcbiAgICAvLyBUaGUgY2hpbGRyZW4gb2YgdGhpcyBjb21wb25lbnQgYXJlIGhpZGRlbi4gRG9uJ3QgYnViYmxlIHRoZWlyXG4gICAgLy8gZXhwaXJhdGlvbiB0aW1lcy5cbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgbmV3Q2hpbGRMYW5lcyA9IE5vTGFuZXM7IC8vIEJ1YmJsZSB1cCB0aGUgZWFybGllc3QgZXhwaXJhdGlvbiB0aW1lLlxuXG4gIGlmICggKGNvbXBsZXRlZFdvcmsubW9kZSAmIFByb2ZpbGVNb2RlKSAhPT0gTm9Nb2RlKSB7XG4gICAgLy8gSW4gcHJvZmlsaW5nIG1vZGUsIHJlc2V0Q2hpbGRFeHBpcmF0aW9uVGltZSBpcyBhbHNvIHVzZWQgdG8gcmVzZXRcbiAgICAvLyBwcm9maWxlciBkdXJhdGlvbnMuXG4gICAgdmFyIGFjdHVhbER1cmF0aW9uID0gY29tcGxldGVkV29yay5hY3R1YWxEdXJhdGlvbjtcbiAgICB2YXIgdHJlZUJhc2VEdXJhdGlvbiA9IGNvbXBsZXRlZFdvcmsuc2VsZkJhc2VEdXJhdGlvbjsgLy8gV2hlbiBhIGZpYmVyIGlzIGNsb25lZCwgaXRzIGFjdHVhbER1cmF0aW9uIGlzIHJlc2V0IHRvIDAuIFRoaXMgdmFsdWUgd2lsbFxuICAgIC8vIG9ubHkgYmUgdXBkYXRlZCBpZiB3b3JrIGlzIGRvbmUgb24gdGhlIGZpYmVyIChpLmUuIGl0IGRvZXNuJ3QgYmFpbG91dCkuXG4gICAgLy8gV2hlbiB3b3JrIGlzIGRvbmUsIGl0IHNob3VsZCBidWJibGUgdG8gdGhlIHBhcmVudCdzIGFjdHVhbER1cmF0aW9uLiBJZlxuICAgIC8vIHRoZSBmaWJlciBoYXMgbm90IGJlZW4gY2xvbmVkIHRob3VnaCwgKG1lYW5pbmcgbm8gd29yayB3YXMgZG9uZSksIHRoZW5cbiAgICAvLyB0aGlzIHZhbHVlIHdpbGwgcmVmbGVjdCB0aGUgYW1vdW50IG9mIHRpbWUgc3BlbnQgd29ya2luZyBvbiBhIHByZXZpb3VzXG4gICAgLy8gcmVuZGVyLiBJbiB0aGF0IGNhc2UgaXQgc2hvdWxkIG5vdCBidWJibGUuIFdlIGRldGVybWluZSB3aGV0aGVyIGl0IHdhc1xuICAgIC8vIGNsb25lZCBieSBjb21wYXJpbmcgdGhlIGNoaWxkIHBvaW50ZXIuXG5cbiAgICB2YXIgc2hvdWxkQnViYmxlQWN0dWFsRHVyYXRpb25zID0gY29tcGxldGVkV29yay5hbHRlcm5hdGUgPT09IG51bGwgfHwgY29tcGxldGVkV29yay5jaGlsZCAhPT0gY29tcGxldGVkV29yay5hbHRlcm5hdGUuY2hpbGQ7XG4gICAgdmFyIGNoaWxkID0gY29tcGxldGVkV29yay5jaGlsZDtcblxuICAgIHdoaWxlIChjaGlsZCAhPT0gbnVsbCkge1xuICAgICAgbmV3Q2hpbGRMYW5lcyA9IG1lcmdlTGFuZXMobmV3Q2hpbGRMYW5lcywgbWVyZ2VMYW5lcyhjaGlsZC5sYW5lcywgY2hpbGQuY2hpbGRMYW5lcykpO1xuXG4gICAgICBpZiAoc2hvdWxkQnViYmxlQWN0dWFsRHVyYXRpb25zKSB7XG4gICAgICAgIGFjdHVhbER1cmF0aW9uICs9IGNoaWxkLmFjdHVhbER1cmF0aW9uO1xuICAgICAgfVxuXG4gICAgICB0cmVlQmFzZUR1cmF0aW9uICs9IGNoaWxkLnRyZWVCYXNlRHVyYXRpb247XG4gICAgICBjaGlsZCA9IGNoaWxkLnNpYmxpbmc7XG4gICAgfVxuXG4gICAgdmFyIGlzVGltZWRPdXRTdXNwZW5zZSA9IGNvbXBsZXRlZFdvcmsudGFnID09PSBTdXNwZW5zZUNvbXBvbmVudCAmJiBjb21wbGV0ZWRXb3JrLm1lbW9pemVkU3RhdGUgIT09IG51bGw7XG5cbiAgICBpZiAoaXNUaW1lZE91dFN1c3BlbnNlKSB7XG4gICAgICAvLyBEb24ndCBjb3VudCB0aW1lIHNwZW50IGluIGEgdGltZWQgb3V0IFN1c3BlbnNlIHN1YnRyZWUgYXMgcGFydCBvZiB0aGUgYmFzZSBkdXJhdGlvbi5cbiAgICAgIHZhciBwcmltYXJ5Q2hpbGRGcmFnbWVudCA9IGNvbXBsZXRlZFdvcmsuY2hpbGQ7XG5cbiAgICAgIGlmIChwcmltYXJ5Q2hpbGRGcmFnbWVudCAhPT0gbnVsbCkge1xuICAgICAgICB0cmVlQmFzZUR1cmF0aW9uIC09IHByaW1hcnlDaGlsZEZyYWdtZW50LnRyZWVCYXNlRHVyYXRpb247XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29tcGxldGVkV29yay5hY3R1YWxEdXJhdGlvbiA9IGFjdHVhbER1cmF0aW9uO1xuICAgIGNvbXBsZXRlZFdvcmsudHJlZUJhc2VEdXJhdGlvbiA9IHRyZWVCYXNlRHVyYXRpb247XG4gIH0gZWxzZSB7XG4gICAgdmFyIF9jaGlsZCA9IGNvbXBsZXRlZFdvcmsuY2hpbGQ7XG5cbiAgICB3aGlsZSAoX2NoaWxkICE9PSBudWxsKSB7XG4gICAgICBuZXdDaGlsZExhbmVzID0gbWVyZ2VMYW5lcyhuZXdDaGlsZExhbmVzLCBtZXJnZUxhbmVzKF9jaGlsZC5sYW5lcywgX2NoaWxkLmNoaWxkTGFuZXMpKTtcbiAgICAgIF9jaGlsZCA9IF9jaGlsZC5zaWJsaW5nO1xuICAgIH1cbiAgfVxuXG4gIGNvbXBsZXRlZFdvcmsuY2hpbGRMYW5lcyA9IG5ld0NoaWxkTGFuZXM7XG59XG5cbmZ1bmN0aW9uIGNvbW1pdFJvb3Qocm9vdCkge1xuICB2YXIgcmVuZGVyUHJpb3JpdHlMZXZlbCA9IGdldEN1cnJlbnRQcmlvcml0eUxldmVsKCk7XG4gIHJ1bldpdGhQcmlvcml0eSQxKEltbWVkaWF0ZVByaW9yaXR5JDEsIGNvbW1pdFJvb3RJbXBsLmJpbmQobnVsbCwgcm9vdCwgcmVuZGVyUHJpb3JpdHlMZXZlbCkpO1xuICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gY29tbWl0Um9vdEltcGwocm9vdCwgcmVuZGVyUHJpb3JpdHlMZXZlbCkge1xuICBkbyB7XG4gICAgLy8gYGZsdXNoUGFzc2l2ZUVmZmVjdHNgIHdpbGwgY2FsbCBgZmx1c2hTeW5jVXBkYXRlUXVldWVgIGF0IHRoZSBlbmQsIHdoaWNoXG4gICAgLy8gbWVhbnMgYGZsdXNoUGFzc2l2ZUVmZmVjdHNgIHdpbGwgc29tZXRpbWVzIHJlc3VsdCBpbiBhZGRpdGlvbmFsXG4gICAgLy8gcGFzc2l2ZSBlZmZlY3RzLiBTbyB3ZSBuZWVkIHRvIGtlZXAgZmx1c2hpbmcgaW4gYSBsb29wIHVudGlsIHRoZXJlIGFyZVxuICAgIC8vIG5vIG1vcmUgcGVuZGluZyBlZmZlY3RzLlxuICAgIC8vIFRPRE86IE1pZ2h0IGJlIGJldHRlciBpZiBgZmx1c2hQYXNzaXZlRWZmZWN0c2AgZGlkIG5vdCBhdXRvbWF0aWNhbGx5XG4gICAgLy8gZmx1c2ggc3luY2hyb25vdXMgd29yayBhdCB0aGUgZW5kLCB0byBhdm9pZCBmYWN0b3JpbmcgaGF6YXJkcyBsaWtlIHRoaXMuXG4gICAgZmx1c2hQYXNzaXZlRWZmZWN0cygpO1xuICB9IHdoaWxlIChyb290V2l0aFBlbmRpbmdQYXNzaXZlRWZmZWN0cyAhPT0gbnVsbCk7XG5cbiAgZmx1c2hSZW5kZXJQaGFzZVN0cmljdE1vZGVXYXJuaW5nc0luREVWKCk7XG5cbiAgaWYgKCEoKGV4ZWN1dGlvbkNvbnRleHQgJiAoUmVuZGVyQ29udGV4dCB8IENvbW1pdENvbnRleHQpKSA9PT0gTm9Db250ZXh0KSkge1xuICAgIHtcbiAgICAgIHRocm93IEVycm9yKCBcIlNob3VsZCBub3QgYWxyZWFkeSBiZSB3b3JraW5nLlwiICk7XG4gICAgfVxuICB9XG5cbiAgdmFyIGZpbmlzaGVkV29yayA9IHJvb3QuZmluaXNoZWRXb3JrO1xuICB2YXIgbGFuZXMgPSByb290LmZpbmlzaGVkTGFuZXM7XG5cbiAgaWYgKGZpbmlzaGVkV29yayA9PT0gbnVsbCkge1xuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICByb290LmZpbmlzaGVkV29yayA9IG51bGw7XG4gIHJvb3QuZmluaXNoZWRMYW5lcyA9IE5vTGFuZXM7XG5cbiAgaWYgKCEoZmluaXNoZWRXb3JrICE9PSByb290LmN1cnJlbnQpKSB7XG4gICAge1xuICAgICAgdGhyb3cgRXJyb3IoIFwiQ2Fubm90IGNvbW1pdCB0aGUgc2FtZSB0cmVlIGFzIGJlZm9yZS4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS5cIiApO1xuICAgIH1cbiAgfSAvLyBjb21taXRSb290IG5ldmVyIHJldHVybnMgYSBjb250aW51YXRpb247IGl0IGFsd2F5cyBmaW5pc2hlcyBzeW5jaHJvbm91c2x5LlxuICAvLyBTbyB3ZSBjYW4gY2xlYXIgdGhlc2Ugbm93IHRvIGFsbG93IGEgbmV3IGNhbGxiYWNrIHRvIGJlIHNjaGVkdWxlZC5cblxuXG4gIHJvb3QuY2FsbGJhY2tOb2RlID0gbnVsbDsgLy8gVXBkYXRlIHRoZSBmaXJzdCBhbmQgbGFzdCBwZW5kaW5nIHRpbWVzIG9uIHRoaXMgcm9vdC4gVGhlIG5ldyBmaXJzdFxuICAvLyBwZW5kaW5nIHRpbWUgaXMgd2hhdGV2ZXIgaXMgbGVmdCBvbiB0aGUgcm9vdCBmaWJlci5cblxuICB2YXIgcmVtYWluaW5nTGFuZXMgPSBtZXJnZUxhbmVzKGZpbmlzaGVkV29yay5sYW5lcywgZmluaXNoZWRXb3JrLmNoaWxkTGFuZXMpO1xuICBtYXJrUm9vdEZpbmlzaGVkKHJvb3QsIHJlbWFpbmluZ0xhbmVzKTsgLy8gQ2xlYXIgYWxyZWFkeSBmaW5pc2hlZCBkaXNjcmV0ZSB1cGRhdGVzIGluIGNhc2UgdGhhdCBhIGxhdGVyIGNhbGwgb2ZcbiAgLy8gYGZsdXNoRGlzY3JldGVVcGRhdGVzYCBzdGFydHMgYSB1c2VsZXNzIHJlbmRlciBwYXNzIHdoaWNoIG1heSBjYW5jZWxzXG4gIC8vIGEgc2NoZWR1bGVkIHRpbWVvdXQuXG5cbiAgaWYgKHJvb3RzV2l0aFBlbmRpbmdEaXNjcmV0ZVVwZGF0ZXMgIT09IG51bGwpIHtcbiAgICBpZiAoIWhhc0Rpc2NyZXRlTGFuZXMocmVtYWluaW5nTGFuZXMpICYmIHJvb3RzV2l0aFBlbmRpbmdEaXNjcmV0ZVVwZGF0ZXMuaGFzKHJvb3QpKSB7XG4gICAgICByb290c1dpdGhQZW5kaW5nRGlzY3JldGVVcGRhdGVzLmRlbGV0ZShyb290KTtcbiAgICB9XG4gIH1cblxuICBpZiAocm9vdCA9PT0gd29ya0luUHJvZ3Jlc3NSb290KSB7XG4gICAgLy8gV2UgY2FuIHJlc2V0IHRoZXNlIG5vdyB0aGF0IHRoZXkgYXJlIGZpbmlzaGVkLlxuICAgIHdvcmtJblByb2dyZXNzUm9vdCA9IG51bGw7XG4gICAgd29ya0luUHJvZ3Jlc3MgPSBudWxsO1xuICAgIHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzID0gTm9MYW5lcztcbiAgfSAvLyBHZXQgdGhlIGxpc3Qgb2YgZWZmZWN0cy5cblxuXG4gIHZhciBmaXJzdEVmZmVjdDtcblxuICBpZiAoZmluaXNoZWRXb3JrLmZsYWdzID4gUGVyZm9ybWVkV29yaykge1xuICAgIC8vIEEgZmliZXIncyBlZmZlY3QgbGlzdCBjb25zaXN0cyBvbmx5IG9mIGl0cyBjaGlsZHJlbiwgbm90IGl0c2VsZi4gU28gaWZcbiAgICAvLyB0aGUgcm9vdCBoYXMgYW4gZWZmZWN0LCB3ZSBuZWVkIHRvIGFkZCBpdCB0byB0aGUgZW5kIG9mIHRoZSBsaXN0LiBUaGVcbiAgICAvLyByZXN1bHRpbmcgbGlzdCBpcyB0aGUgc2V0IHRoYXQgd291bGQgYmVsb25nIHRvIHRoZSByb290J3MgcGFyZW50LCBpZiBpdFxuICAgIC8vIGhhZCBvbmU7IHRoYXQgaXMsIGFsbCB0aGUgZWZmZWN0cyBpbiB0aGUgdHJlZSBpbmNsdWRpbmcgdGhlIHJvb3QuXG4gICAgaWYgKGZpbmlzaGVkV29yay5sYXN0RWZmZWN0ICE9PSBudWxsKSB7XG4gICAgICBmaW5pc2hlZFdvcmsubGFzdEVmZmVjdC5uZXh0RWZmZWN0ID0gZmluaXNoZWRXb3JrO1xuICAgICAgZmlyc3RFZmZlY3QgPSBmaW5pc2hlZFdvcmsuZmlyc3RFZmZlY3Q7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZpcnN0RWZmZWN0ID0gZmluaXNoZWRXb3JrO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBUaGVyZSBpcyBubyBlZmZlY3Qgb24gdGhlIHJvb3QuXG4gICAgZmlyc3RFZmZlY3QgPSBmaW5pc2hlZFdvcmsuZmlyc3RFZmZlY3Q7XG4gIH1cblxuICBpZiAoZmlyc3RFZmZlY3QgIT09IG51bGwpIHtcblxuICAgIHZhciBwcmV2RXhlY3V0aW9uQ29udGV4dCA9IGV4ZWN1dGlvbkNvbnRleHQ7XG4gICAgZXhlY3V0aW9uQ29udGV4dCB8PSBDb21taXRDb250ZXh0O1xuICAgIHZhciBwcmV2SW50ZXJhY3Rpb25zID0gcHVzaEludGVyYWN0aW9ucyhyb290KTsgLy8gUmVzZXQgdGhpcyB0byBudWxsIGJlZm9yZSBjYWxsaW5nIGxpZmVjeWNsZXNcblxuICAgIFJlYWN0Q3VycmVudE93bmVyJDIuY3VycmVudCA9IG51bGw7IC8vIFRoZSBjb21taXQgcGhhc2UgaXMgYnJva2VuIGludG8gc2V2ZXJhbCBzdWItcGhhc2VzLiBXZSBkbyBhIHNlcGFyYXRlIHBhc3NcbiAgICAvLyBvZiB0aGUgZWZmZWN0IGxpc3QgZm9yIGVhY2ggcGhhc2U6IGFsbCBtdXRhdGlvbiBlZmZlY3RzIGNvbWUgYmVmb3JlIGFsbFxuICAgIC8vIGxheW91dCBlZmZlY3RzLCBhbmQgc28gb24uXG4gICAgLy8gVGhlIGZpcnN0IHBoYXNlIGEgXCJiZWZvcmUgbXV0YXRpb25cIiBwaGFzZS4gV2UgdXNlIHRoaXMgcGhhc2UgdG8gcmVhZCB0aGVcbiAgICAvLyBzdGF0ZSBvZiB0aGUgaG9zdCB0cmVlIHJpZ2h0IGJlZm9yZSB3ZSBtdXRhdGUgaXQuIFRoaXMgaXMgd2hlcmVcbiAgICAvLyBnZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSBpcyBjYWxsZWQuXG5cbiAgICBmb2N1c2VkSW5zdGFuY2VIYW5kbGUgPSBwcmVwYXJlRm9yQ29tbWl0KHJvb3QuY29udGFpbmVySW5mbyk7XG4gICAgc2hvdWxkRmlyZUFmdGVyQWN0aXZlSW5zdGFuY2VCbHVyID0gZmFsc2U7XG4gICAgbmV4dEVmZmVjdCA9IGZpcnN0RWZmZWN0O1xuXG4gICAgZG8ge1xuICAgICAge1xuICAgICAgICBpbnZva2VHdWFyZGVkQ2FsbGJhY2sobnVsbCwgY29tbWl0QmVmb3JlTXV0YXRpb25FZmZlY3RzLCBudWxsKTtcblxuICAgICAgICBpZiAoaGFzQ2F1Z2h0RXJyb3IoKSkge1xuICAgICAgICAgIGlmICghKG5leHRFZmZlY3QgIT09IG51bGwpKSB7XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHRocm93IEVycm9yKCBcIlNob3VsZCBiZSB3b3JraW5nIG9uIGFuIGVmZmVjdC5cIiApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBlcnJvciA9IGNsZWFyQ2F1Z2h0RXJyb3IoKTtcbiAgICAgICAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihuZXh0RWZmZWN0LCBlcnJvcik7XG4gICAgICAgICAgbmV4dEVmZmVjdCA9IG5leHRFZmZlY3QubmV4dEVmZmVjdDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gd2hpbGUgKG5leHRFZmZlY3QgIT09IG51bGwpOyAvLyBXZSBubyBsb25nZXIgbmVlZCB0byB0cmFjayB0aGUgYWN0aXZlIGluc3RhbmNlIGZpYmVyXG5cblxuICAgIGZvY3VzZWRJbnN0YW5jZUhhbmRsZSA9IG51bGw7XG5cbiAgICB7XG4gICAgICAvLyBNYXJrIHRoZSBjdXJyZW50IGNvbW1pdCB0aW1lIHRvIGJlIHNoYXJlZCBieSBhbGwgUHJvZmlsZXJzIGluIHRoaXNcbiAgICAgIC8vIGJhdGNoLiBUaGlzIGVuYWJsZXMgdGhlbSB0byBiZSBncm91cGVkIGxhdGVyLlxuICAgICAgcmVjb3JkQ29tbWl0VGltZSgpO1xuICAgIH0gLy8gVGhlIG5leHQgcGhhc2UgaXMgdGhlIG11dGF0aW9uIHBoYXNlLCB3aGVyZSB3ZSBtdXRhdGUgdGhlIGhvc3QgdHJlZS5cblxuXG4gICAgbmV4dEVmZmVjdCA9IGZpcnN0RWZmZWN0O1xuXG4gICAgZG8ge1xuICAgICAge1xuICAgICAgICBpbnZva2VHdWFyZGVkQ2FsbGJhY2sobnVsbCwgY29tbWl0TXV0YXRpb25FZmZlY3RzLCBudWxsLCByb290LCByZW5kZXJQcmlvcml0eUxldmVsKTtcblxuICAgICAgICBpZiAoaGFzQ2F1Z2h0RXJyb3IoKSkge1xuICAgICAgICAgIGlmICghKG5leHRFZmZlY3QgIT09IG51bGwpKSB7XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHRocm93IEVycm9yKCBcIlNob3VsZCBiZSB3b3JraW5nIG9uIGFuIGVmZmVjdC5cIiApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBfZXJyb3IgPSBjbGVhckNhdWdodEVycm9yKCk7XG5cbiAgICAgICAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihuZXh0RWZmZWN0LCBfZXJyb3IpO1xuICAgICAgICAgIG5leHRFZmZlY3QgPSBuZXh0RWZmZWN0Lm5leHRFZmZlY3Q7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IHdoaWxlIChuZXh0RWZmZWN0ICE9PSBudWxsKTtcblxuICAgIHJlc2V0QWZ0ZXJDb21taXQocm9vdC5jb250YWluZXJJbmZvKTsgLy8gVGhlIHdvcmstaW4tcHJvZ3Jlc3MgdHJlZSBpcyBub3cgdGhlIGN1cnJlbnQgdHJlZS4gVGhpcyBtdXN0IGNvbWUgYWZ0ZXJcbiAgICAvLyB0aGUgbXV0YXRpb24gcGhhc2UsIHNvIHRoYXQgdGhlIHByZXZpb3VzIHRyZWUgaXMgc3RpbGwgY3VycmVudCBkdXJpbmdcbiAgICAvLyBjb21wb25lbnRXaWxsVW5tb3VudCwgYnV0IGJlZm9yZSB0aGUgbGF5b3V0IHBoYXNlLCBzbyB0aGF0IHRoZSBmaW5pc2hlZFxuICAgIC8vIHdvcmsgaXMgY3VycmVudCBkdXJpbmcgY29tcG9uZW50RGlkTW91bnQvVXBkYXRlLlxuXG4gICAgcm9vdC5jdXJyZW50ID0gZmluaXNoZWRXb3JrOyAvLyBUaGUgbmV4dCBwaGFzZSBpcyB0aGUgbGF5b3V0IHBoYXNlLCB3aGVyZSB3ZSBjYWxsIGVmZmVjdHMgdGhhdCByZWFkXG4gICAgLy8gdGhlIGhvc3QgdHJlZSBhZnRlciBpdCdzIGJlZW4gbXV0YXRlZC4gVGhlIGlkaW9tYXRpYyB1c2UgY2FzZSBmb3IgdGhpcyBpc1xuICAgIC8vIGxheW91dCwgYnV0IGNsYXNzIGNvbXBvbmVudCBsaWZlY3ljbGVzIGFsc28gZmlyZSBoZXJlIGZvciBsZWdhY3kgcmVhc29ucy5cblxuICAgIG5leHRFZmZlY3QgPSBmaXJzdEVmZmVjdDtcblxuICAgIGRvIHtcbiAgICAgIHtcbiAgICAgICAgaW52b2tlR3VhcmRlZENhbGxiYWNrKG51bGwsIGNvbW1pdExheW91dEVmZmVjdHMsIG51bGwsIHJvb3QsIGxhbmVzKTtcblxuICAgICAgICBpZiAoaGFzQ2F1Z2h0RXJyb3IoKSkge1xuICAgICAgICAgIGlmICghKG5leHRFZmZlY3QgIT09IG51bGwpKSB7XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHRocm93IEVycm9yKCBcIlNob3VsZCBiZSB3b3JraW5nIG9uIGFuIGVmZmVjdC5cIiApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBfZXJyb3IyID0gY2xlYXJDYXVnaHRFcnJvcigpO1xuXG4gICAgICAgICAgY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IobmV4dEVmZmVjdCwgX2Vycm9yMik7XG4gICAgICAgICAgbmV4dEVmZmVjdCA9IG5leHRFZmZlY3QubmV4dEVmZmVjdDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gd2hpbGUgKG5leHRFZmZlY3QgIT09IG51bGwpO1xuXG4gICAgbmV4dEVmZmVjdCA9IG51bGw7IC8vIFRlbGwgU2NoZWR1bGVyIHRvIHlpZWxkIGF0IHRoZSBlbmQgb2YgdGhlIGZyYW1lLCBzbyB0aGUgYnJvd3NlciBoYXMgYW5cbiAgICAvLyBvcHBvcnR1bml0eSB0byBwYWludC5cblxuICAgIHJlcXVlc3RQYWludCgpO1xuXG4gICAge1xuICAgICAgcG9wSW50ZXJhY3Rpb25zKHByZXZJbnRlcmFjdGlvbnMpO1xuICAgIH1cblxuICAgIGV4ZWN1dGlvbkNvbnRleHQgPSBwcmV2RXhlY3V0aW9uQ29udGV4dDtcbiAgfSBlbHNlIHtcbiAgICAvLyBObyBlZmZlY3RzLlxuICAgIHJvb3QuY3VycmVudCA9IGZpbmlzaGVkV29yazsgLy8gTWVhc3VyZSB0aGVzZSBhbnl3YXkgc28gdGhlIGZsYW1lZ3JhcGggZXhwbGljaXRseSBzaG93cyB0aGF0IHRoZXJlIHdlcmVcbiAgICAvLyBubyBlZmZlY3RzLlxuICAgIC8vIFRPRE86IE1heWJlIHRoZXJlJ3MgYSBiZXR0ZXIgd2F5IHRvIHJlcG9ydCB0aGlzLlxuXG4gICAge1xuICAgICAgcmVjb3JkQ29tbWl0VGltZSgpO1xuICAgIH1cbiAgfVxuXG4gIHZhciByb290RGlkSGF2ZVBhc3NpdmVFZmZlY3RzID0gcm9vdERvZXNIYXZlUGFzc2l2ZUVmZmVjdHM7XG5cbiAgaWYgKHJvb3REb2VzSGF2ZVBhc3NpdmVFZmZlY3RzKSB7XG4gICAgLy8gVGhpcyBjb21taXQgaGFzIHBhc3NpdmUgZWZmZWN0cy4gU3Rhc2ggYSByZWZlcmVuY2UgdG8gdGhlbS4gQnV0IGRvbid0XG4gICAgLy8gc2NoZWR1bGUgYSBjYWxsYmFjayB1bnRpbCBhZnRlciBmbHVzaGluZyBsYXlvdXQgd29yay5cbiAgICByb290RG9lc0hhdmVQYXNzaXZlRWZmZWN0cyA9IGZhbHNlO1xuICAgIHJvb3RXaXRoUGVuZGluZ1Bhc3NpdmVFZmZlY3RzID0gcm9vdDtcbiAgICBwZW5kaW5nUGFzc2l2ZUVmZmVjdHNMYW5lcyA9IGxhbmVzO1xuICAgIHBlbmRpbmdQYXNzaXZlRWZmZWN0c1JlbmRlclByaW9yaXR5ID0gcmVuZGVyUHJpb3JpdHlMZXZlbDtcbiAgfSBlbHNlIHtcbiAgICAvLyBXZSBhcmUgZG9uZSB3aXRoIHRoZSBlZmZlY3QgY2hhaW4gYXQgdGhpcyBwb2ludCBzbyBsZXQncyBjbGVhciB0aGVcbiAgICAvLyBuZXh0RWZmZWN0IHBvaW50ZXJzIHRvIGFzc2lzdCB3aXRoIEdDLiBJZiB3ZSBoYXZlIHBhc3NpdmUgZWZmZWN0cywgd2UnbGxcbiAgICAvLyBjbGVhciB0aGlzIGluIGZsdXNoUGFzc2l2ZUVmZmVjdHMuXG4gICAgbmV4dEVmZmVjdCA9IGZpcnN0RWZmZWN0O1xuXG4gICAgd2hpbGUgKG5leHRFZmZlY3QgIT09IG51bGwpIHtcbiAgICAgIHZhciBuZXh0TmV4dEVmZmVjdCA9IG5leHRFZmZlY3QubmV4dEVmZmVjdDtcbiAgICAgIG5leHRFZmZlY3QubmV4dEVmZmVjdCA9IG51bGw7XG5cbiAgICAgIGlmIChuZXh0RWZmZWN0LmZsYWdzICYgRGVsZXRpb24pIHtcbiAgICAgICAgZGV0YWNoRmliZXJBZnRlckVmZmVjdHMobmV4dEVmZmVjdCk7XG4gICAgICB9XG5cbiAgICAgIG5leHRFZmZlY3QgPSBuZXh0TmV4dEVmZmVjdDtcbiAgICB9XG4gIH0gLy8gUmVhZCB0aGlzIGFnYWluLCBzaW5jZSBhbiBlZmZlY3QgbWlnaHQgaGF2ZSB1cGRhdGVkIGl0XG5cblxuICByZW1haW5pbmdMYW5lcyA9IHJvb3QucGVuZGluZ0xhbmVzOyAvLyBDaGVjayBpZiB0aGVyZSdzIHJlbWFpbmluZyB3b3JrIG9uIHRoaXMgcm9vdFxuXG4gIGlmIChyZW1haW5pbmdMYW5lcyAhPT0gTm9MYW5lcykge1xuICAgIHtcbiAgICAgIGlmIChzcGF3bmVkV29ya0R1cmluZ1JlbmRlciAhPT0gbnVsbCkge1xuICAgICAgICB2YXIgZXhwaXJhdGlvblRpbWVzID0gc3Bhd25lZFdvcmtEdXJpbmdSZW5kZXI7XG4gICAgICAgIHNwYXduZWRXb3JrRHVyaW5nUmVuZGVyID0gbnVsbDtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGV4cGlyYXRpb25UaW1lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHNjaGVkdWxlSW50ZXJhY3Rpb25zKHJvb3QsIGV4cGlyYXRpb25UaW1lc1tpXSwgcm9vdC5tZW1vaXplZEludGVyYWN0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgc2NoZWR1bGVQZW5kaW5nSW50ZXJhY3Rpb25zKHJvb3QsIHJlbWFpbmluZ0xhbmVzKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gSWYgdGhlcmUncyBubyByZW1haW5pbmcgd29yaywgd2UgY2FuIGNsZWFyIHRoZSBzZXQgb2YgYWxyZWFkeSBmYWlsZWRcbiAgICAvLyBlcnJvciBib3VuZGFyaWVzLlxuICAgIGxlZ2FjeUVycm9yQm91bmRhcmllc1RoYXRBbHJlYWR5RmFpbGVkID0gbnVsbDtcbiAgfVxuXG4gIHtcbiAgICBpZiAoIXJvb3REaWRIYXZlUGFzc2l2ZUVmZmVjdHMpIHtcbiAgICAgIC8vIElmIHRoZXJlIGFyZSBubyBwYXNzaXZlIGVmZmVjdHMsIHRoZW4gd2UgY2FuIGNvbXBsZXRlIHRoZSBwZW5kaW5nIGludGVyYWN0aW9ucy5cbiAgICAgIC8vIE90aGVyd2lzZSwgd2UnbGwgd2FpdCB1bnRpbCBhZnRlciB0aGUgcGFzc2l2ZSBlZmZlY3RzIGFyZSBmbHVzaGVkLlxuICAgICAgLy8gV2FpdCB0byBkbyB0aGlzIHVudGlsIGFmdGVyIHJlbWFpbmluZyB3b3JrIGhhcyBiZWVuIHNjaGVkdWxlZCxcbiAgICAgIC8vIHNvIHRoYXQgd2UgZG9uJ3QgcHJlbWF0dXJlbHkgc2lnbmFsIGNvbXBsZXRlIGZvciBpbnRlcmFjdGlvbnMgd2hlbiB0aGVyZSdzIGUuZy4gaGlkZGVuIHdvcmsuXG4gICAgICBmaW5pc2hQZW5kaW5nSW50ZXJhY3Rpb25zKHJvb3QsIGxhbmVzKTtcbiAgICB9XG4gIH1cblxuICBpZiAocmVtYWluaW5nTGFuZXMgPT09IFN5bmNMYW5lKSB7XG4gICAgLy8gQ291bnQgdGhlIG51bWJlciBvZiB0aW1lcyB0aGUgcm9vdCBzeW5jaHJvbm91c2x5IHJlLXJlbmRlcnMgd2l0aG91dFxuICAgIC8vIGZpbmlzaGluZy4gSWYgdGhlcmUgYXJlIHRvbyBtYW55LCBpdCBpbmRpY2F0ZXMgYW4gaW5maW5pdGUgdXBkYXRlIGxvb3AuXG4gICAgaWYgKHJvb3QgPT09IHJvb3RXaXRoTmVzdGVkVXBkYXRlcykge1xuICAgICAgbmVzdGVkVXBkYXRlQ291bnQrKztcbiAgICB9IGVsc2Uge1xuICAgICAgbmVzdGVkVXBkYXRlQ291bnQgPSAwO1xuICAgICAgcm9vdFdpdGhOZXN0ZWRVcGRhdGVzID0gcm9vdDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgbmVzdGVkVXBkYXRlQ291bnQgPSAwO1xuICB9XG5cbiAgb25Db21taXRSb290KGZpbmlzaGVkV29yay5zdGF0ZU5vZGUsIHJlbmRlclByaW9yaXR5TGV2ZWwpO1xuXG4gIHtcbiAgICBvbkNvbW1pdFJvb3QkMSgpO1xuICB9IC8vIEFsd2F5cyBjYWxsIHRoaXMgYmVmb3JlIGV4aXRpbmcgYGNvbW1pdFJvb3RgLCB0byBlbnN1cmUgdGhhdCBhbnlcbiAgLy8gYWRkaXRpb25hbCB3b3JrIG9uIHRoaXMgcm9vdCBpcyBzY2hlZHVsZWQuXG5cblxuICBlbnN1cmVSb290SXNTY2hlZHVsZWQocm9vdCwgbm93KCkpO1xuXG4gIGlmIChoYXNVbmNhdWdodEVycm9yKSB7XG4gICAgaGFzVW5jYXVnaHRFcnJvciA9IGZhbHNlO1xuICAgIHZhciBfZXJyb3IzID0gZmlyc3RVbmNhdWdodEVycm9yO1xuICAgIGZpcnN0VW5jYXVnaHRFcnJvciA9IG51bGw7XG4gICAgdGhyb3cgX2Vycm9yMztcbiAgfVxuXG4gIGlmICgoZXhlY3V0aW9uQ29udGV4dCAmIExlZ2FjeVVuYmF0Y2hlZENvbnRleHQpICE9PSBOb0NvbnRleHQpIHtcbiAgICAvLyBhIFJlYWN0RE9NLnJlbmRlci1lZCByb290IGluc2lkZSBvZiBiYXRjaGVkVXBkYXRlcy4gVGhlIGNvbW1pdCBmaXJlZFxuICAgIC8vIHN5bmNocm9ub3VzbHksIGJ1dCBsYXlvdXQgdXBkYXRlcyBzaG91bGQgYmUgZGVmZXJyZWQgdW50aWwgdGhlIGVuZFxuICAgIC8vIG9mIHRoZSBiYXRjaC5cblxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH0gLy8gSWYgbGF5b3V0IHdvcmsgd2FzIHNjaGVkdWxlZCwgZmx1c2ggaXQgbm93LlxuXG5cbiAgZmx1c2hTeW5jQ2FsbGJhY2tRdWV1ZSgpO1xuXG4gIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBjb21taXRCZWZvcmVNdXRhdGlvbkVmZmVjdHMoKSB7XG4gIHdoaWxlIChuZXh0RWZmZWN0ICE9PSBudWxsKSB7XG4gICAgdmFyIGN1cnJlbnQgPSBuZXh0RWZmZWN0LmFsdGVybmF0ZTtcblxuICAgIGlmICghc2hvdWxkRmlyZUFmdGVyQWN0aXZlSW5zdGFuY2VCbHVyICYmIGZvY3VzZWRJbnN0YW5jZUhhbmRsZSAhPT0gbnVsbCkge1xuICAgICAgaWYgKChuZXh0RWZmZWN0LmZsYWdzICYgRGVsZXRpb24pICE9PSBOb0ZsYWdzKSB7XG4gICAgICAgIGlmIChkb2VzRmliZXJDb250YWluKG5leHRFZmZlY3QsIGZvY3VzZWRJbnN0YW5jZUhhbmRsZSkpIHtcbiAgICAgICAgICBzaG91bGRGaXJlQWZ0ZXJBY3RpdmVJbnN0YW5jZUJsdXIgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBUT0RPOiBNb3ZlIHRoaXMgb3V0IG9mIHRoZSBob3QgcGF0aCB1c2luZyBhIGRlZGljYXRlZCBlZmZlY3QgdGFnLlxuICAgICAgICBpZiAobmV4dEVmZmVjdC50YWcgPT09IFN1c3BlbnNlQ29tcG9uZW50ICYmIGlzU3VzcGVuc2VCb3VuZGFyeUJlaW5nSGlkZGVuKGN1cnJlbnQsIG5leHRFZmZlY3QpICYmIGRvZXNGaWJlckNvbnRhaW4obmV4dEVmZmVjdCwgZm9jdXNlZEluc3RhbmNlSGFuZGxlKSkge1xuICAgICAgICAgIHNob3VsZEZpcmVBZnRlckFjdGl2ZUluc3RhbmNlQmx1ciA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgZmxhZ3MgPSBuZXh0RWZmZWN0LmZsYWdzO1xuXG4gICAgaWYgKChmbGFncyAmIFNuYXBzaG90KSAhPT0gTm9GbGFncykge1xuICAgICAgc2V0Q3VycmVudEZpYmVyKG5leHRFZmZlY3QpO1xuICAgICAgY29tbWl0QmVmb3JlTXV0YXRpb25MaWZlQ3ljbGVzKGN1cnJlbnQsIG5leHRFZmZlY3QpO1xuICAgICAgcmVzZXRDdXJyZW50RmliZXIoKTtcbiAgICB9XG5cbiAgICBpZiAoKGZsYWdzICYgUGFzc2l2ZSkgIT09IE5vRmxhZ3MpIHtcbiAgICAgIC8vIElmIHRoZXJlIGFyZSBwYXNzaXZlIGVmZmVjdHMsIHNjaGVkdWxlIGEgY2FsbGJhY2sgdG8gZmx1c2ggYXRcbiAgICAgIC8vIHRoZSBlYXJsaWVzdCBvcHBvcnR1bml0eS5cbiAgICAgIGlmICghcm9vdERvZXNIYXZlUGFzc2l2ZUVmZmVjdHMpIHtcbiAgICAgICAgcm9vdERvZXNIYXZlUGFzc2l2ZUVmZmVjdHMgPSB0cnVlO1xuICAgICAgICBzY2hlZHVsZUNhbGxiYWNrKE5vcm1hbFByaW9yaXR5JDEsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBmbHVzaFBhc3NpdmVFZmZlY3RzKCk7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIG5leHRFZmZlY3QgPSBuZXh0RWZmZWN0Lm5leHRFZmZlY3Q7XG4gIH1cbn1cblxuZnVuY3Rpb24gY29tbWl0TXV0YXRpb25FZmZlY3RzKHJvb3QsIHJlbmRlclByaW9yaXR5TGV2ZWwpIHtcbiAgLy8gVE9ETzogU2hvdWxkIHByb2JhYmx5IG1vdmUgdGhlIGJ1bGsgb2YgdGhpcyBmdW5jdGlvbiB0byBjb21taXRXb3JrLlxuICB3aGlsZSAobmV4dEVmZmVjdCAhPT0gbnVsbCkge1xuICAgIHNldEN1cnJlbnRGaWJlcihuZXh0RWZmZWN0KTtcbiAgICB2YXIgZmxhZ3MgPSBuZXh0RWZmZWN0LmZsYWdzO1xuXG4gICAgaWYgKGZsYWdzICYgQ29udGVudFJlc2V0KSB7XG4gICAgICBjb21taXRSZXNldFRleHRDb250ZW50KG5leHRFZmZlY3QpO1xuICAgIH1cblxuICAgIGlmIChmbGFncyAmIFJlZikge1xuICAgICAgdmFyIGN1cnJlbnQgPSBuZXh0RWZmZWN0LmFsdGVybmF0ZTtcblxuICAgICAgaWYgKGN1cnJlbnQgIT09IG51bGwpIHtcbiAgICAgICAgY29tbWl0RGV0YWNoUmVmKGN1cnJlbnQpO1xuICAgICAgfVxuICAgIH0gLy8gVGhlIGZvbGxvd2luZyBzd2l0Y2ggc3RhdGVtZW50IGlzIG9ubHkgY29uY2VybmVkIGFib3V0IHBsYWNlbWVudCxcbiAgICAvLyB1cGRhdGVzLCBhbmQgZGVsZXRpb25zLiBUbyBhdm9pZCBuZWVkaW5nIHRvIGFkZCBhIGNhc2UgZm9yIGV2ZXJ5IHBvc3NpYmxlXG4gICAgLy8gYml0bWFwIHZhbHVlLCB3ZSByZW1vdmUgdGhlIHNlY29uZGFyeSBlZmZlY3RzIGZyb20gdGhlIGVmZmVjdCB0YWcgYW5kXG4gICAgLy8gc3dpdGNoIG9uIHRoYXQgdmFsdWUuXG5cblxuICAgIHZhciBwcmltYXJ5RmxhZ3MgPSBmbGFncyAmIChQbGFjZW1lbnQgfCBVcGRhdGUgfCBEZWxldGlvbiB8IEh5ZHJhdGluZyk7XG5cbiAgICBzd2l0Y2ggKHByaW1hcnlGbGFncykge1xuICAgICAgY2FzZSBQbGFjZW1lbnQ6XG4gICAgICAgIHtcbiAgICAgICAgICBjb21taXRQbGFjZW1lbnQobmV4dEVmZmVjdCk7IC8vIENsZWFyIHRoZSBcInBsYWNlbWVudFwiIGZyb20gZWZmZWN0IHRhZyBzbyB0aGF0IHdlIGtub3cgdGhhdCB0aGlzIGlzXG4gICAgICAgICAgLy8gaW5zZXJ0ZWQsIGJlZm9yZSBhbnkgbGlmZS1jeWNsZXMgbGlrZSBjb21wb25lbnREaWRNb3VudCBnZXRzIGNhbGxlZC5cbiAgICAgICAgICAvLyBUT0RPOiBmaW5kRE9NTm9kZSBkb2Vzbid0IHJlbHkgb24gdGhpcyBhbnkgbW9yZSBidXQgaXNNb3VudGVkIGRvZXNcbiAgICAgICAgICAvLyBhbmQgaXNNb3VudGVkIGlzIGRlcHJlY2F0ZWQgYW55d2F5IHNvIHdlIHNob3VsZCBiZSBhYmxlIHRvIGtpbGwgdGhpcy5cblxuICAgICAgICAgIG5leHRFZmZlY3QuZmxhZ3MgJj0gflBsYWNlbWVudDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIFBsYWNlbWVudEFuZFVwZGF0ZTpcbiAgICAgICAge1xuICAgICAgICAgIC8vIFBsYWNlbWVudFxuICAgICAgICAgIGNvbW1pdFBsYWNlbWVudChuZXh0RWZmZWN0KTsgLy8gQ2xlYXIgdGhlIFwicGxhY2VtZW50XCIgZnJvbSBlZmZlY3QgdGFnIHNvIHRoYXQgd2Uga25vdyB0aGF0IHRoaXMgaXNcbiAgICAgICAgICAvLyBpbnNlcnRlZCwgYmVmb3JlIGFueSBsaWZlLWN5Y2xlcyBsaWtlIGNvbXBvbmVudERpZE1vdW50IGdldHMgY2FsbGVkLlxuXG4gICAgICAgICAgbmV4dEVmZmVjdC5mbGFncyAmPSB+UGxhY2VtZW50OyAvLyBVcGRhdGVcblxuICAgICAgICAgIHZhciBfY3VycmVudCA9IG5leHRFZmZlY3QuYWx0ZXJuYXRlO1xuICAgICAgICAgIGNvbW1pdFdvcmsoX2N1cnJlbnQsIG5leHRFZmZlY3QpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgSHlkcmF0aW5nOlxuICAgICAgICB7XG4gICAgICAgICAgbmV4dEVmZmVjdC5mbGFncyAmPSB+SHlkcmF0aW5nO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgSHlkcmF0aW5nQW5kVXBkYXRlOlxuICAgICAgICB7XG4gICAgICAgICAgbmV4dEVmZmVjdC5mbGFncyAmPSB+SHlkcmF0aW5nOyAvLyBVcGRhdGVcblxuICAgICAgICAgIHZhciBfY3VycmVudDIgPSBuZXh0RWZmZWN0LmFsdGVybmF0ZTtcbiAgICAgICAgICBjb21taXRXb3JrKF9jdXJyZW50MiwgbmV4dEVmZmVjdCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBVcGRhdGU6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgX2N1cnJlbnQzID0gbmV4dEVmZmVjdC5hbHRlcm5hdGU7XG4gICAgICAgICAgY29tbWl0V29yayhfY3VycmVudDMsIG5leHRFZmZlY3QpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgRGVsZXRpb246XG4gICAgICAgIHtcbiAgICAgICAgICBjb21taXREZWxldGlvbihyb290LCBuZXh0RWZmZWN0KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJlc2V0Q3VycmVudEZpYmVyKCk7XG4gICAgbmV4dEVmZmVjdCA9IG5leHRFZmZlY3QubmV4dEVmZmVjdDtcbiAgfVxufVxuXG5mdW5jdGlvbiBjb21taXRMYXlvdXRFZmZlY3RzKHJvb3QsIGNvbW1pdHRlZExhbmVzKSB7XG5cblxuICB3aGlsZSAobmV4dEVmZmVjdCAhPT0gbnVsbCkge1xuICAgIHNldEN1cnJlbnRGaWJlcihuZXh0RWZmZWN0KTtcbiAgICB2YXIgZmxhZ3MgPSBuZXh0RWZmZWN0LmZsYWdzO1xuXG4gICAgaWYgKGZsYWdzICYgKFVwZGF0ZSB8IENhbGxiYWNrKSkge1xuICAgICAgdmFyIGN1cnJlbnQgPSBuZXh0RWZmZWN0LmFsdGVybmF0ZTtcbiAgICAgIGNvbW1pdExpZmVDeWNsZXMocm9vdCwgY3VycmVudCwgbmV4dEVmZmVjdCk7XG4gICAgfVxuXG4gICAge1xuICAgICAgaWYgKGZsYWdzICYgUmVmKSB7XG4gICAgICAgIGNvbW1pdEF0dGFjaFJlZihuZXh0RWZmZWN0KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXNldEN1cnJlbnRGaWJlcigpO1xuICAgIG5leHRFZmZlY3QgPSBuZXh0RWZmZWN0Lm5leHRFZmZlY3Q7XG4gIH1cbn1cblxuZnVuY3Rpb24gZmx1c2hQYXNzaXZlRWZmZWN0cygpIHtcbiAgLy8gUmV0dXJucyB3aGV0aGVyIHBhc3NpdmUgZWZmZWN0cyB3ZXJlIGZsdXNoZWQuXG4gIGlmIChwZW5kaW5nUGFzc2l2ZUVmZmVjdHNSZW5kZXJQcmlvcml0eSAhPT0gTm9Qcmlvcml0eSQxKSB7XG4gICAgdmFyIHByaW9yaXR5TGV2ZWwgPSBwZW5kaW5nUGFzc2l2ZUVmZmVjdHNSZW5kZXJQcmlvcml0eSA+IE5vcm1hbFByaW9yaXR5JDEgPyBOb3JtYWxQcmlvcml0eSQxIDogcGVuZGluZ1Bhc3NpdmVFZmZlY3RzUmVuZGVyUHJpb3JpdHk7XG4gICAgcGVuZGluZ1Bhc3NpdmVFZmZlY3RzUmVuZGVyUHJpb3JpdHkgPSBOb1ByaW9yaXR5JDE7XG5cbiAgICB7XG4gICAgICByZXR1cm4gcnVuV2l0aFByaW9yaXR5JDEocHJpb3JpdHlMZXZlbCwgZmx1c2hQYXNzaXZlRWZmZWN0c0ltcGwpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGVucXVldWVQZW5kaW5nUGFzc2l2ZUhvb2tFZmZlY3RNb3VudChmaWJlciwgZWZmZWN0KSB7XG4gIHBlbmRpbmdQYXNzaXZlSG9va0VmZmVjdHNNb3VudC5wdXNoKGVmZmVjdCwgZmliZXIpO1xuXG4gIGlmICghcm9vdERvZXNIYXZlUGFzc2l2ZUVmZmVjdHMpIHtcbiAgICByb290RG9lc0hhdmVQYXNzaXZlRWZmZWN0cyA9IHRydWU7XG4gICAgc2NoZWR1bGVDYWxsYmFjayhOb3JtYWxQcmlvcml0eSQxLCBmdW5jdGlvbiAoKSB7XG4gICAgICBmbHVzaFBhc3NpdmVFZmZlY3RzKCk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9KTtcbiAgfVxufVxuZnVuY3Rpb24gZW5xdWV1ZVBlbmRpbmdQYXNzaXZlSG9va0VmZmVjdFVubW91bnQoZmliZXIsIGVmZmVjdCkge1xuICBwZW5kaW5nUGFzc2l2ZUhvb2tFZmZlY3RzVW5tb3VudC5wdXNoKGVmZmVjdCwgZmliZXIpO1xuXG4gIHtcbiAgICBmaWJlci5mbGFncyB8PSBQYXNzaXZlVW5tb3VudFBlbmRpbmdEZXY7XG4gICAgdmFyIGFsdGVybmF0ZSA9IGZpYmVyLmFsdGVybmF0ZTtcblxuICAgIGlmIChhbHRlcm5hdGUgIT09IG51bGwpIHtcbiAgICAgIGFsdGVybmF0ZS5mbGFncyB8PSBQYXNzaXZlVW5tb3VudFBlbmRpbmdEZXY7XG4gICAgfVxuICB9XG5cbiAgaWYgKCFyb290RG9lc0hhdmVQYXNzaXZlRWZmZWN0cykge1xuICAgIHJvb3REb2VzSGF2ZVBhc3NpdmVFZmZlY3RzID0gdHJ1ZTtcbiAgICBzY2hlZHVsZUNhbGxiYWNrKE5vcm1hbFByaW9yaXR5JDEsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGZsdXNoUGFzc2l2ZUVmZmVjdHMoKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGludm9rZVBhc3NpdmVFZmZlY3RDcmVhdGUoZWZmZWN0KSB7XG4gIHZhciBjcmVhdGUgPSBlZmZlY3QuY3JlYXRlO1xuICBlZmZlY3QuZGVzdHJveSA9IGNyZWF0ZSgpO1xufVxuXG5mdW5jdGlvbiBmbHVzaFBhc3NpdmVFZmZlY3RzSW1wbCgpIHtcbiAgaWYgKHJvb3RXaXRoUGVuZGluZ1Bhc3NpdmVFZmZlY3RzID09PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIHJvb3QgPSByb290V2l0aFBlbmRpbmdQYXNzaXZlRWZmZWN0cztcbiAgdmFyIGxhbmVzID0gcGVuZGluZ1Bhc3NpdmVFZmZlY3RzTGFuZXM7XG4gIHJvb3RXaXRoUGVuZGluZ1Bhc3NpdmVFZmZlY3RzID0gbnVsbDtcbiAgcGVuZGluZ1Bhc3NpdmVFZmZlY3RzTGFuZXMgPSBOb0xhbmVzO1xuXG4gIGlmICghKChleGVjdXRpb25Db250ZXh0ICYgKFJlbmRlckNvbnRleHQgfCBDb21taXRDb250ZXh0KSkgPT09IE5vQ29udGV4dCkpIHtcbiAgICB7XG4gICAgICB0aHJvdyBFcnJvciggXCJDYW5ub3QgZmx1c2ggcGFzc2l2ZSBlZmZlY3RzIHdoaWxlIGFscmVhZHkgcmVuZGVyaW5nLlwiICk7XG4gICAgfVxuICB9XG5cbiAge1xuICAgIGlzRmx1c2hpbmdQYXNzaXZlRWZmZWN0cyA9IHRydWU7XG4gIH1cblxuICB2YXIgcHJldkV4ZWN1dGlvbkNvbnRleHQgPSBleGVjdXRpb25Db250ZXh0O1xuICBleGVjdXRpb25Db250ZXh0IHw9IENvbW1pdENvbnRleHQ7XG4gIHZhciBwcmV2SW50ZXJhY3Rpb25zID0gcHVzaEludGVyYWN0aW9ucyhyb290KTsgLy8gSXQncyBpbXBvcnRhbnQgdGhhdCBBTEwgcGVuZGluZyBwYXNzaXZlIGVmZmVjdCBkZXN0cm95IGZ1bmN0aW9ucyBhcmUgY2FsbGVkXG4gIC8vIGJlZm9yZSBBTlkgcGFzc2l2ZSBlZmZlY3QgY3JlYXRlIGZ1bmN0aW9ucyBhcmUgY2FsbGVkLlxuICAvLyBPdGhlcndpc2UgZWZmZWN0cyBpbiBzaWJsaW5nIGNvbXBvbmVudHMgbWlnaHQgaW50ZXJmZXJlIHdpdGggZWFjaCBvdGhlci5cbiAgLy8gZS5nLiBhIGRlc3Ryb3kgZnVuY3Rpb24gaW4gb25lIGNvbXBvbmVudCBtYXkgdW5pbnRlbnRpb25hbGx5IG92ZXJyaWRlIGEgcmVmXG4gIC8vIHZhbHVlIHNldCBieSBhIGNyZWF0ZSBmdW5jdGlvbiBpbiBhbm90aGVyIGNvbXBvbmVudC5cbiAgLy8gTGF5b3V0IGVmZmVjdHMgaGF2ZSB0aGUgc2FtZSBjb25zdHJhaW50LlxuICAvLyBGaXJzdCBwYXNzOiBEZXN0cm95IHN0YWxlIHBhc3NpdmUgZWZmZWN0cy5cblxuICB2YXIgdW5tb3VudEVmZmVjdHMgPSBwZW5kaW5nUGFzc2l2ZUhvb2tFZmZlY3RzVW5tb3VudDtcbiAgcGVuZGluZ1Bhc3NpdmVIb29rRWZmZWN0c1VubW91bnQgPSBbXTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHVubW91bnRFZmZlY3RzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgdmFyIF9lZmZlY3QgPSB1bm1vdW50RWZmZWN0c1tpXTtcbiAgICB2YXIgZmliZXIgPSB1bm1vdW50RWZmZWN0c1tpICsgMV07XG4gICAgdmFyIGRlc3Ryb3kgPSBfZWZmZWN0LmRlc3Ryb3k7XG4gICAgX2VmZmVjdC5kZXN0cm95ID0gdW5kZWZpbmVkO1xuXG4gICAge1xuICAgICAgZmliZXIuZmxhZ3MgJj0gflBhc3NpdmVVbm1vdW50UGVuZGluZ0RldjtcbiAgICAgIHZhciBhbHRlcm5hdGUgPSBmaWJlci5hbHRlcm5hdGU7XG5cbiAgICAgIGlmIChhbHRlcm5hdGUgIT09IG51bGwpIHtcbiAgICAgICAgYWx0ZXJuYXRlLmZsYWdzICY9IH5QYXNzaXZlVW5tb3VudFBlbmRpbmdEZXY7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBkZXN0cm95ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB7XG4gICAgICAgIHNldEN1cnJlbnRGaWJlcihmaWJlcik7XG5cbiAgICAgICAge1xuICAgICAgICAgIGludm9rZUd1YXJkZWRDYWxsYmFjayhudWxsLCBkZXN0cm95LCBudWxsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChoYXNDYXVnaHRFcnJvcigpKSB7XG4gICAgICAgICAgaWYgKCEoZmliZXIgIT09IG51bGwpKSB7XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHRocm93IEVycm9yKCBcIlNob3VsZCBiZSB3b3JraW5nIG9uIGFuIGVmZmVjdC5cIiApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBlcnJvciA9IGNsZWFyQ2F1Z2h0RXJyb3IoKTtcbiAgICAgICAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihmaWJlciwgZXJyb3IpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVzZXRDdXJyZW50RmliZXIoKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gLy8gU2Vjb25kIHBhc3M6IENyZWF0ZSBuZXcgcGFzc2l2ZSBlZmZlY3RzLlxuXG5cbiAgdmFyIG1vdW50RWZmZWN0cyA9IHBlbmRpbmdQYXNzaXZlSG9va0VmZmVjdHNNb3VudDtcbiAgcGVuZGluZ1Bhc3NpdmVIb29rRWZmZWN0c01vdW50ID0gW107XG5cbiAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IG1vdW50RWZmZWN0cy5sZW5ndGg7IF9pICs9IDIpIHtcbiAgICB2YXIgX2VmZmVjdDIgPSBtb3VudEVmZmVjdHNbX2ldO1xuICAgIHZhciBfZmliZXIgPSBtb3VudEVmZmVjdHNbX2kgKyAxXTtcblxuICAgIHtcbiAgICAgIHNldEN1cnJlbnRGaWJlcihfZmliZXIpO1xuXG4gICAgICB7XG4gICAgICAgIGludm9rZUd1YXJkZWRDYWxsYmFjayhudWxsLCBpbnZva2VQYXNzaXZlRWZmZWN0Q3JlYXRlLCBudWxsLCBfZWZmZWN0Mik7XG4gICAgICB9XG5cbiAgICAgIGlmIChoYXNDYXVnaHRFcnJvcigpKSB7XG4gICAgICAgIGlmICghKF9maWJlciAhPT0gbnVsbCkpIHtcbiAgICAgICAgICB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvciggXCJTaG91bGQgYmUgd29ya2luZyBvbiBhbiBlZmZlY3QuXCIgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgX2Vycm9yNCA9IGNsZWFyQ2F1Z2h0RXJyb3IoKTtcblxuICAgICAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihfZmliZXIsIF9lcnJvcjQpO1xuICAgICAgfVxuXG4gICAgICByZXNldEN1cnJlbnRGaWJlcigpO1xuICAgIH1cbiAgfSAvLyBOb3RlOiBUaGlzIGN1cnJlbnRseSBhc3N1bWVzIHRoZXJlIGFyZSBubyBwYXNzaXZlIGVmZmVjdHMgb24gdGhlIHJvb3QgZmliZXJcbiAgLy8gYmVjYXVzZSB0aGUgcm9vdCBpcyBub3QgcGFydCBvZiBpdHMgb3duIGVmZmVjdCBsaXN0LlxuICAvLyBUaGlzIGNvdWxkIGNoYW5nZSBpbiB0aGUgZnV0dXJlLlxuXG5cbiAgdmFyIGVmZmVjdCA9IHJvb3QuY3VycmVudC5maXJzdEVmZmVjdDtcblxuICB3aGlsZSAoZWZmZWN0ICE9PSBudWxsKSB7XG4gICAgdmFyIG5leHROZXh0RWZmZWN0ID0gZWZmZWN0Lm5leHRFZmZlY3Q7IC8vIFJlbW92ZSBuZXh0RWZmZWN0IHBvaW50ZXIgdG8gYXNzaXN0IEdDXG5cbiAgICBlZmZlY3QubmV4dEVmZmVjdCA9IG51bGw7XG5cbiAgICBpZiAoZWZmZWN0LmZsYWdzICYgRGVsZXRpb24pIHtcbiAgICAgIGRldGFjaEZpYmVyQWZ0ZXJFZmZlY3RzKGVmZmVjdCk7XG4gICAgfVxuXG4gICAgZWZmZWN0ID0gbmV4dE5leHRFZmZlY3Q7XG4gIH1cblxuICB7XG4gICAgcG9wSW50ZXJhY3Rpb25zKHByZXZJbnRlcmFjdGlvbnMpO1xuICAgIGZpbmlzaFBlbmRpbmdJbnRlcmFjdGlvbnMocm9vdCwgbGFuZXMpO1xuICB9XG5cbiAge1xuICAgIGlzRmx1c2hpbmdQYXNzaXZlRWZmZWN0cyA9IGZhbHNlO1xuICB9XG5cbiAgZXhlY3V0aW9uQ29udGV4dCA9IHByZXZFeGVjdXRpb25Db250ZXh0O1xuICBmbHVzaFN5bmNDYWxsYmFja1F1ZXVlKCk7IC8vIElmIGFkZGl0aW9uYWwgcGFzc2l2ZSBlZmZlY3RzIHdlcmUgc2NoZWR1bGVkLCBpbmNyZW1lbnQgYSBjb3VudGVyLiBJZiB0aGlzXG4gIC8vIGV4Y2VlZHMgdGhlIGxpbWl0LCB3ZSdsbCBmaXJlIGEgd2FybmluZy5cblxuICBuZXN0ZWRQYXNzaXZlVXBkYXRlQ291bnQgPSByb290V2l0aFBlbmRpbmdQYXNzaXZlRWZmZWN0cyA9PT0gbnVsbCA/IDAgOiBuZXN0ZWRQYXNzaXZlVXBkYXRlQ291bnQgKyAxO1xuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gaXNBbHJlYWR5RmFpbGVkTGVnYWN5RXJyb3JCb3VuZGFyeShpbnN0YW5jZSkge1xuICByZXR1cm4gbGVnYWN5RXJyb3JCb3VuZGFyaWVzVGhhdEFscmVhZHlGYWlsZWQgIT09IG51bGwgJiYgbGVnYWN5RXJyb3JCb3VuZGFyaWVzVGhhdEFscmVhZHlGYWlsZWQuaGFzKGluc3RhbmNlKTtcbn1cbmZ1bmN0aW9uIG1hcmtMZWdhY3lFcnJvckJvdW5kYXJ5QXNGYWlsZWQoaW5zdGFuY2UpIHtcbiAgaWYgKGxlZ2FjeUVycm9yQm91bmRhcmllc1RoYXRBbHJlYWR5RmFpbGVkID09PSBudWxsKSB7XG4gICAgbGVnYWN5RXJyb3JCb3VuZGFyaWVzVGhhdEFscmVhZHlGYWlsZWQgPSBuZXcgU2V0KFtpbnN0YW5jZV0pO1xuICB9IGVsc2Uge1xuICAgIGxlZ2FjeUVycm9yQm91bmRhcmllc1RoYXRBbHJlYWR5RmFpbGVkLmFkZChpbnN0YW5jZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJlcGFyZVRvVGhyb3dVbmNhdWdodEVycm9yKGVycm9yKSB7XG4gIGlmICghaGFzVW5jYXVnaHRFcnJvcikge1xuICAgIGhhc1VuY2F1Z2h0RXJyb3IgPSB0cnVlO1xuICAgIGZpcnN0VW5jYXVnaHRFcnJvciA9IGVycm9yO1xuICB9XG59XG5cbnZhciBvblVuY2F1Z2h0RXJyb3IgPSBwcmVwYXJlVG9UaHJvd1VuY2F1Z2h0RXJyb3I7XG5cbmZ1bmN0aW9uIGNhcHR1cmVDb21taXRQaGFzZUVycm9yT25Sb290KHJvb3RGaWJlciwgc291cmNlRmliZXIsIGVycm9yKSB7XG4gIHZhciBlcnJvckluZm8gPSBjcmVhdGVDYXB0dXJlZFZhbHVlKGVycm9yLCBzb3VyY2VGaWJlcik7XG4gIHZhciB1cGRhdGUgPSBjcmVhdGVSb290RXJyb3JVcGRhdGUocm9vdEZpYmVyLCBlcnJvckluZm8sIFN5bmNMYW5lKTtcbiAgZW5xdWV1ZVVwZGF0ZShyb290RmliZXIsIHVwZGF0ZSk7XG4gIHZhciBldmVudFRpbWUgPSByZXF1ZXN0RXZlbnRUaW1lKCk7XG4gIHZhciByb290ID0gbWFya1VwZGF0ZUxhbmVGcm9tRmliZXJUb1Jvb3Qocm9vdEZpYmVyLCBTeW5jTGFuZSk7XG5cbiAgaWYgKHJvb3QgIT09IG51bGwpIHtcbiAgICBtYXJrUm9vdFVwZGF0ZWQocm9vdCwgU3luY0xhbmUsIGV2ZW50VGltZSk7XG4gICAgZW5zdXJlUm9vdElzU2NoZWR1bGVkKHJvb3QsIGV2ZW50VGltZSk7XG4gICAgc2NoZWR1bGVQZW5kaW5nSW50ZXJhY3Rpb25zKHJvb3QsIFN5bmNMYW5lKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihzb3VyY2VGaWJlciwgZXJyb3IpIHtcbiAgaWYgKHNvdXJjZUZpYmVyLnRhZyA9PT0gSG9zdFJvb3QpIHtcbiAgICAvLyBFcnJvciB3YXMgdGhyb3duIGF0IHRoZSByb290LiBUaGVyZSBpcyBubyBwYXJlbnQsIHNvIHRoZSByb290XG4gICAgLy8gaXRzZWxmIHNob3VsZCBjYXB0dXJlIGl0LlxuICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yT25Sb290KHNvdXJjZUZpYmVyLCBzb3VyY2VGaWJlciwgZXJyb3IpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBmaWJlciA9IHNvdXJjZUZpYmVyLnJldHVybjtcblxuICB3aGlsZSAoZmliZXIgIT09IG51bGwpIHtcbiAgICBpZiAoZmliZXIudGFnID09PSBIb3N0Um9vdCkge1xuICAgICAgY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3JPblJvb3QoZmliZXIsIHNvdXJjZUZpYmVyLCBlcnJvcik7XG4gICAgICByZXR1cm47XG4gICAgfSBlbHNlIGlmIChmaWJlci50YWcgPT09IENsYXNzQ29tcG9uZW50KSB7XG4gICAgICB2YXIgY3RvciA9IGZpYmVyLnR5cGU7XG4gICAgICB2YXIgaW5zdGFuY2UgPSBmaWJlci5zdGF0ZU5vZGU7XG5cbiAgICAgIGlmICh0eXBlb2YgY3Rvci5nZXREZXJpdmVkU3RhdGVGcm9tRXJyb3IgPT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudERpZENhdGNoID09PSAnZnVuY3Rpb24nICYmICFpc0FscmVhZHlGYWlsZWRMZWdhY3lFcnJvckJvdW5kYXJ5KGluc3RhbmNlKSkge1xuICAgICAgICB2YXIgZXJyb3JJbmZvID0gY3JlYXRlQ2FwdHVyZWRWYWx1ZShlcnJvciwgc291cmNlRmliZXIpO1xuICAgICAgICB2YXIgdXBkYXRlID0gY3JlYXRlQ2xhc3NFcnJvclVwZGF0ZShmaWJlciwgZXJyb3JJbmZvLCBTeW5jTGFuZSk7XG4gICAgICAgIGVucXVldWVVcGRhdGUoZmliZXIsIHVwZGF0ZSk7XG4gICAgICAgIHZhciBldmVudFRpbWUgPSByZXF1ZXN0RXZlbnRUaW1lKCk7XG4gICAgICAgIHZhciByb290ID0gbWFya1VwZGF0ZUxhbmVGcm9tRmliZXJUb1Jvb3QoZmliZXIsIFN5bmNMYW5lKTtcblxuICAgICAgICBpZiAocm9vdCAhPT0gbnVsbCkge1xuICAgICAgICAgIG1hcmtSb290VXBkYXRlZChyb290LCBTeW5jTGFuZSwgZXZlbnRUaW1lKTtcbiAgICAgICAgICBlbnN1cmVSb290SXNTY2hlZHVsZWQocm9vdCwgZXZlbnRUaW1lKTtcbiAgICAgICAgICBzY2hlZHVsZVBlbmRpbmdJbnRlcmFjdGlvbnMocm9vdCwgU3luY0xhbmUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIFRoaXMgY29tcG9uZW50IGhhcyBhbHJlYWR5IGJlZW4gdW5tb3VudGVkLlxuICAgICAgICAgIC8vIFdlIGNhbid0IHNjaGVkdWxlIGFueSBmb2xsb3cgdXAgd29yayBmb3IgdGhlIHJvb3QgYmVjYXVzZSB0aGUgZmliZXIgaXMgYWxyZWFkeSB1bm1vdW50ZWQsXG4gICAgICAgICAgLy8gYnV0IHdlIGNhbiBzdGlsbCBjYWxsIHRoZSBsb2ctb25seSBib3VuZGFyeSBzbyB0aGUgZXJyb3IgaXNuJ3Qgc3dhbGxvd2VkLlxuICAgICAgICAgIC8vXG4gICAgICAgICAgLy8gVE9ETyBUaGlzIGlzIG9ubHkgYSB0ZW1wb3JhcnkgYmFuZGFpZCBmb3IgdGhlIG9sZCByZWNvbmNpbGVyIGZvcmsuXG4gICAgICAgICAgLy8gV2UgY2FuIGRlbGV0ZSB0aGlzIHNwZWNpYWwgY2FzZSBvbmNlIHRoZSBuZXcgZm9yayBpcyBtZXJnZWQuXG4gICAgICAgICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnREaWRDYXRjaCA9PT0gJ2Z1bmN0aW9uJyAmJiAhaXNBbHJlYWR5RmFpbGVkTGVnYWN5RXJyb3JCb3VuZGFyeShpbnN0YW5jZSkpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGluc3RhbmNlLmNvbXBvbmVudERpZENhdGNoKGVycm9yLCBlcnJvckluZm8pO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3JUb0lnbm9yZSkgey8vIFRPRE8gSWdub3JlIHRoaXMgZXJyb3I/IFJldGhyb3cgaXQ/XG4gICAgICAgICAgICAgIC8vIFRoaXMgaXMga2luZCBvZiBhbiBlZGdlIGNhc2UuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZpYmVyID0gZmliZXIucmV0dXJuO1xuICB9XG59XG5mdW5jdGlvbiBwaW5nU3VzcGVuZGVkUm9vdChyb290LCB3YWtlYWJsZSwgcGluZ2VkTGFuZXMpIHtcbiAgdmFyIHBpbmdDYWNoZSA9IHJvb3QucGluZ0NhY2hlO1xuXG4gIGlmIChwaW5nQ2FjaGUgIT09IG51bGwpIHtcbiAgICAvLyBUaGUgd2FrZWFibGUgcmVzb2x2ZWQsIHNvIHdlIG5vIGxvbmdlciBuZWVkIHRvIG1lbW9pemUsIGJlY2F1c2UgaXQgd2lsbFxuICAgIC8vIG5ldmVyIGJlIHRocm93biBhZ2Fpbi5cbiAgICBwaW5nQ2FjaGUuZGVsZXRlKHdha2VhYmxlKTtcbiAgfVxuXG4gIHZhciBldmVudFRpbWUgPSByZXF1ZXN0RXZlbnRUaW1lKCk7XG4gIG1hcmtSb290UGluZ2VkKHJvb3QsIHBpbmdlZExhbmVzKTtcblxuICBpZiAod29ya0luUHJvZ3Jlc3NSb290ID09PSByb290ICYmIGlzU3Vic2V0T2ZMYW5lcyh3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcywgcGluZ2VkTGFuZXMpKSB7XG4gICAgLy8gUmVjZWl2ZWQgYSBwaW5nIGF0IHRoZSBzYW1lIHByaW9yaXR5IGxldmVsIGF0IHdoaWNoIHdlJ3JlIGN1cnJlbnRseVxuICAgIC8vIHJlbmRlcmluZy4gV2UgbWlnaHQgd2FudCB0byByZXN0YXJ0IHRoaXMgcmVuZGVyLiBUaGlzIHNob3VsZCBtaXJyb3JcbiAgICAvLyB0aGUgbG9naWMgb2Ygd2hldGhlciBvciBub3QgYSByb290IHN1c3BlbmRzIG9uY2UgaXQgY29tcGxldGVzLlxuICAgIC8vIFRPRE86IElmIHdlJ3JlIHJlbmRlcmluZyBzeW5jIGVpdGhlciBkdWUgdG8gU3luYywgQmF0Y2hlZCBvciBleHBpcmVkLFxuICAgIC8vIHdlIHNob3VsZCBwcm9iYWJseSBuZXZlciByZXN0YXJ0LlxuICAgIC8vIElmIHdlJ3JlIHN1c3BlbmRlZCB3aXRoIGRlbGF5LCBvciBpZiBpdCdzIGEgcmV0cnksIHdlJ2xsIGFsd2F5cyBzdXNwZW5kXG4gICAgLy8gc28gd2UgY2FuIGFsd2F5cyByZXN0YXJ0LlxuICAgIGlmICh3b3JrSW5Qcm9ncmVzc1Jvb3RFeGl0U3RhdHVzID09PSBSb290U3VzcGVuZGVkV2l0aERlbGF5IHx8IHdvcmtJblByb2dyZXNzUm9vdEV4aXRTdGF0dXMgPT09IFJvb3RTdXNwZW5kZWQgJiYgaW5jbHVkZXNPbmx5UmV0cmllcyh3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcykgJiYgbm93KCkgLSBnbG9iYWxNb3N0UmVjZW50RmFsbGJhY2tUaW1lIDwgRkFMTEJBQ0tfVEhST1RUTEVfTVMpIHtcbiAgICAgIC8vIFJlc3RhcnQgZnJvbSB0aGUgcm9vdC5cbiAgICAgIHByZXBhcmVGcmVzaFN0YWNrKHJvb3QsIE5vTGFuZXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBFdmVuIHRob3VnaCB3ZSBjYW4ndCByZXN0YXJ0IHJpZ2h0IG5vdywgd2UgbWlnaHQgZ2V0IGFuXG4gICAgICAvLyBvcHBvcnR1bml0eSBsYXRlci4gU28gd2UgbWFyayB0aGlzIHJlbmRlciBhcyBoYXZpbmcgYSBwaW5nLlxuICAgICAgd29ya0luUHJvZ3Jlc3NSb290UGluZ2VkTGFuZXMgPSBtZXJnZUxhbmVzKHdvcmtJblByb2dyZXNzUm9vdFBpbmdlZExhbmVzLCBwaW5nZWRMYW5lcyk7XG4gICAgfVxuICB9XG5cbiAgZW5zdXJlUm9vdElzU2NoZWR1bGVkKHJvb3QsIGV2ZW50VGltZSk7XG4gIHNjaGVkdWxlUGVuZGluZ0ludGVyYWN0aW9ucyhyb290LCBwaW5nZWRMYW5lcyk7XG59XG5cbmZ1bmN0aW9uIHJldHJ5VGltZWRPdXRCb3VuZGFyeShib3VuZGFyeUZpYmVyLCByZXRyeUxhbmUpIHtcbiAgLy8gVGhlIGJvdW5kYXJ5IGZpYmVyIChhIFN1c3BlbnNlIGNvbXBvbmVudCBvciBTdXNwZW5zZUxpc3QgY29tcG9uZW50KVxuICAvLyBwcmV2aW91c2x5IHdhcyByZW5kZXJlZCBpbiBpdHMgZmFsbGJhY2sgc3RhdGUuIE9uZSBvZiB0aGUgcHJvbWlzZXMgdGhhdFxuICAvLyBzdXNwZW5kZWQgaXQgaGFzIHJlc29sdmVkLCB3aGljaCBtZWFucyBhdCBsZWFzdCBwYXJ0IG9mIHRoZSB0cmVlIHdhc1xuICAvLyBsaWtlbHkgdW5ibG9ja2VkLiBUcnkgcmVuZGVyaW5nIGFnYWluLCBhdCBhIG5ldyBleHBpcmF0aW9uIHRpbWUuXG4gIGlmIChyZXRyeUxhbmUgPT09IE5vTGFuZSkge1xuICAgIHJldHJ5TGFuZSA9IHJlcXVlc3RSZXRyeUxhbmUoYm91bmRhcnlGaWJlcik7XG4gIH0gLy8gVE9ETzogU3BlY2lhbCBjYXNlIGlkbGUgcHJpb3JpdHk/XG5cblxuICB2YXIgZXZlbnRUaW1lID0gcmVxdWVzdEV2ZW50VGltZSgpO1xuICB2YXIgcm9vdCA9IG1hcmtVcGRhdGVMYW5lRnJvbUZpYmVyVG9Sb290KGJvdW5kYXJ5RmliZXIsIHJldHJ5TGFuZSk7XG5cbiAgaWYgKHJvb3QgIT09IG51bGwpIHtcbiAgICBtYXJrUm9vdFVwZGF0ZWQocm9vdCwgcmV0cnlMYW5lLCBldmVudFRpbWUpO1xuICAgIGVuc3VyZVJvb3RJc1NjaGVkdWxlZChyb290LCBldmVudFRpbWUpO1xuICAgIHNjaGVkdWxlUGVuZGluZ0ludGVyYWN0aW9ucyhyb290LCByZXRyeUxhbmUpO1xuICB9XG59XG5mdW5jdGlvbiByZXNvbHZlUmV0cnlXYWtlYWJsZShib3VuZGFyeUZpYmVyLCB3YWtlYWJsZSkge1xuICB2YXIgcmV0cnlMYW5lID0gTm9MYW5lOyAvLyBEZWZhdWx0XG5cbiAgdmFyIHJldHJ5Q2FjaGU7XG5cbiAge1xuICAgIHJldHJ5Q2FjaGUgPSBib3VuZGFyeUZpYmVyLnN0YXRlTm9kZTtcbiAgfVxuXG4gIGlmIChyZXRyeUNhY2hlICE9PSBudWxsKSB7XG4gICAgLy8gVGhlIHdha2VhYmxlIHJlc29sdmVkLCBzbyB3ZSBubyBsb25nZXIgbmVlZCB0byBtZW1vaXplLCBiZWNhdXNlIGl0IHdpbGxcbiAgICAvLyBuZXZlciBiZSB0aHJvd24gYWdhaW4uXG4gICAgcmV0cnlDYWNoZS5kZWxldGUod2FrZWFibGUpO1xuICB9XG5cbiAgcmV0cnlUaW1lZE91dEJvdW5kYXJ5KGJvdW5kYXJ5RmliZXIsIHJldHJ5TGFuZSk7XG59IC8vIENvbXB1dGVzIHRoZSBuZXh0IEp1c3QgTm90aWNlYWJsZSBEaWZmZXJlbmNlIChKTkQpIGJvdW5kYXJ5LlxuLy8gVGhlIHRoZW9yeSBpcyB0aGF0IGEgcGVyc29uIGNhbid0IHRlbGwgdGhlIGRpZmZlcmVuY2UgYmV0d2VlbiBzbWFsbCBkaWZmZXJlbmNlcyBpbiB0aW1lLlxuLy8gVGhlcmVmb3JlLCBpZiB3ZSB3YWl0IGEgYml0IGxvbmdlciB0aGFuIG5lY2Vzc2FyeSB0aGF0IHdvbid0IHRyYW5zbGF0ZSB0byBhIG5vdGljZWFibGVcbi8vIGRpZmZlcmVuY2UgaW4gdGhlIGV4cGVyaWVuY2UuIEhvd2V2ZXIsIHdhaXRpbmcgZm9yIGxvbmdlciBtaWdodCBtZWFuIHRoYXQgd2UgY2FuIGF2b2lkXG4vLyBzaG93aW5nIGFuIGludGVybWVkaWF0ZSBsb2FkaW5nIHN0YXRlLiBUaGUgbG9uZ2VyIHdlIGhhdmUgYWxyZWFkeSB3YWl0ZWQsIHRoZSBoYXJkZXIgaXRcbi8vIGlzIHRvIHRlbGwgc21hbGwgZGlmZmVyZW5jZXMgaW4gdGltZS4gVGhlcmVmb3JlLCB0aGUgbG9uZ2VyIHdlJ3ZlIGFscmVhZHkgd2FpdGVkLFxuLy8gdGhlIGxvbmdlciB3ZSBjYW4gd2FpdCBhZGRpdGlvbmFsbHkuIEF0IHNvbWUgcG9pbnQgd2UgaGF2ZSB0byBnaXZlIHVwIHRob3VnaC5cbi8vIFdlIHBpY2sgYSB0cmFpbiBtb2RlbCB3aGVyZSB0aGUgbmV4dCBib3VuZGFyeSBjb21taXRzIGF0IGEgY29uc2lzdGVudCBzY2hlZHVsZS5cbi8vIFRoZXNlIHBhcnRpY3VsYXIgbnVtYmVycyBhcmUgdmFndWUgZXN0aW1hdGVzLiBXZSBleHBlY3QgdG8gYWRqdXN0IHRoZW0gYmFzZWQgb24gcmVzZWFyY2guXG5cbmZ1bmN0aW9uIGpuZCh0aW1lRWxhcHNlZCkge1xuICByZXR1cm4gdGltZUVsYXBzZWQgPCAxMjAgPyAxMjAgOiB0aW1lRWxhcHNlZCA8IDQ4MCA/IDQ4MCA6IHRpbWVFbGFwc2VkIDwgMTA4MCA/IDEwODAgOiB0aW1lRWxhcHNlZCA8IDE5MjAgPyAxOTIwIDogdGltZUVsYXBzZWQgPCAzMDAwID8gMzAwMCA6IHRpbWVFbGFwc2VkIDwgNDMyMCA/IDQzMjAgOiBjZWlsKHRpbWVFbGFwc2VkIC8gMTk2MCkgKiAxOTYwO1xufVxuXG5mdW5jdGlvbiBjaGVja0Zvck5lc3RlZFVwZGF0ZXMoKSB7XG4gIGlmIChuZXN0ZWRVcGRhdGVDb3VudCA+IE5FU1RFRF9VUERBVEVfTElNSVQpIHtcbiAgICBuZXN0ZWRVcGRhdGVDb3VudCA9IDA7XG4gICAgcm9vdFdpdGhOZXN0ZWRVcGRhdGVzID0gbnVsbDtcblxuICAgIHtcbiAgICAgIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoIFwiTWF4aW11bSB1cGRhdGUgZGVwdGggZXhjZWVkZWQuIFRoaXMgY2FuIGhhcHBlbiB3aGVuIGEgY29tcG9uZW50IHJlcGVhdGVkbHkgY2FsbHMgc2V0U3RhdGUgaW5zaWRlIGNvbXBvbmVudFdpbGxVcGRhdGUgb3IgY29tcG9uZW50RGlkVXBkYXRlLiBSZWFjdCBsaW1pdHMgdGhlIG51bWJlciBvZiBuZXN0ZWQgdXBkYXRlcyB0byBwcmV2ZW50IGluZmluaXRlIGxvb3BzLlwiICk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAge1xuICAgIGlmIChuZXN0ZWRQYXNzaXZlVXBkYXRlQ291bnQgPiBORVNURURfUEFTU0lWRV9VUERBVEVfTElNSVQpIHtcbiAgICAgIG5lc3RlZFBhc3NpdmVVcGRhdGVDb3VudCA9IDA7XG5cbiAgICAgIGVycm9yKCdNYXhpbXVtIHVwZGF0ZSBkZXB0aCBleGNlZWRlZC4gVGhpcyBjYW4gaGFwcGVuIHdoZW4gYSBjb21wb25lbnQgJyArIFwiY2FsbHMgc2V0U3RhdGUgaW5zaWRlIHVzZUVmZmVjdCwgYnV0IHVzZUVmZmVjdCBlaXRoZXIgZG9lc24ndCBcIiArICdoYXZlIGEgZGVwZW5kZW5jeSBhcnJheSwgb3Igb25lIG9mIHRoZSBkZXBlbmRlbmNpZXMgY2hhbmdlcyBvbiAnICsgJ2V2ZXJ5IHJlbmRlci4nKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZmx1c2hSZW5kZXJQaGFzZVN0cmljdE1vZGVXYXJuaW5nc0luREVWKCkge1xuICB7XG4gICAgUmVhY3RTdHJpY3RNb2RlV2FybmluZ3MuZmx1c2hMZWdhY3lDb250ZXh0V2FybmluZygpO1xuXG4gICAge1xuICAgICAgUmVhY3RTdHJpY3RNb2RlV2FybmluZ3MuZmx1c2hQZW5kaW5nVW5zYWZlTGlmZWN5Y2xlV2FybmluZ3MoKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIGRpZFdhcm5TdGF0ZVVwZGF0ZUZvck5vdFlldE1vdW50ZWRDb21wb25lbnQgPSBudWxsO1xuXG5mdW5jdGlvbiB3YXJuQWJvdXRVcGRhdGVPbk5vdFlldE1vdW50ZWRGaWJlckluREVWKGZpYmVyKSB7XG4gIHtcbiAgICBpZiAoKGV4ZWN1dGlvbkNvbnRleHQgJiBSZW5kZXJDb250ZXh0KSAhPT0gTm9Db250ZXh0KSB7XG4gICAgICAvLyBXZSBsZXQgdGhlIG90aGVyIHdhcm5pbmcgYWJvdXQgcmVuZGVyIHBoYXNlIHVwZGF0ZXMgZGVhbCB3aXRoIHRoaXMgb25lLlxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICghKGZpYmVyLm1vZGUgJiAoQmxvY2tpbmdNb2RlIHwgQ29uY3VycmVudE1vZGUpKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciB0YWcgPSBmaWJlci50YWc7XG5cbiAgICBpZiAodGFnICE9PSBJbmRldGVybWluYXRlQ29tcG9uZW50ICYmIHRhZyAhPT0gSG9zdFJvb3QgJiYgdGFnICE9PSBDbGFzc0NvbXBvbmVudCAmJiB0YWcgIT09IEZ1bmN0aW9uQ29tcG9uZW50ICYmIHRhZyAhPT0gRm9yd2FyZFJlZiAmJiB0YWcgIT09IE1lbW9Db21wb25lbnQgJiYgdGFnICE9PSBTaW1wbGVNZW1vQ29tcG9uZW50ICYmIHRhZyAhPT0gQmxvY2spIHtcbiAgICAgIC8vIE9ubHkgd2FybiBmb3IgdXNlci1kZWZpbmVkIGNvbXBvbmVudHMsIG5vdCBpbnRlcm5hbCBvbmVzIGxpa2UgU3VzcGVuc2UuXG4gICAgICByZXR1cm47XG4gICAgfSAvLyBXZSBzaG93IHRoZSB3aG9sZSBzdGFjayBidXQgZGVkdXBlIG9uIHRoZSB0b3AgY29tcG9uZW50J3MgbmFtZSBiZWNhdXNlXG4gICAgLy8gdGhlIHByb2JsZW1hdGljIGNvZGUgYWxtb3N0IGFsd2F5cyBsaWVzIGluc2lkZSB0aGF0IGNvbXBvbmVudC5cblxuXG4gICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lKGZpYmVyLnR5cGUpIHx8ICdSZWFjdENvbXBvbmVudCc7XG5cbiAgICBpZiAoZGlkV2FyblN0YXRlVXBkYXRlRm9yTm90WWV0TW91bnRlZENvbXBvbmVudCAhPT0gbnVsbCkge1xuICAgICAgaWYgKGRpZFdhcm5TdGF0ZVVwZGF0ZUZvck5vdFlldE1vdW50ZWRDb21wb25lbnQuaGFzKGNvbXBvbmVudE5hbWUpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgZGlkV2FyblN0YXRlVXBkYXRlRm9yTm90WWV0TW91bnRlZENvbXBvbmVudC5hZGQoY29tcG9uZW50TmFtZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRpZFdhcm5TdGF0ZVVwZGF0ZUZvck5vdFlldE1vdW50ZWRDb21wb25lbnQgPSBuZXcgU2V0KFtjb21wb25lbnROYW1lXSk7XG4gICAgfVxuXG4gICAgdmFyIHByZXZpb3VzRmliZXIgPSBjdXJyZW50O1xuXG4gICAgdHJ5IHtcbiAgICAgIHNldEN1cnJlbnRGaWJlcihmaWJlcik7XG5cbiAgICAgIGVycm9yKFwiQ2FuJ3QgcGVyZm9ybSBhIFJlYWN0IHN0YXRlIHVwZGF0ZSBvbiBhIGNvbXBvbmVudCB0aGF0IGhhc24ndCBtb3VudGVkIHlldC4gXCIgKyAnVGhpcyBpbmRpY2F0ZXMgdGhhdCB5b3UgaGF2ZSBhIHNpZGUtZWZmZWN0IGluIHlvdXIgcmVuZGVyIGZ1bmN0aW9uIHRoYXQgJyArICdhc3luY2hyb25vdXNseSBsYXRlciBjYWxscyB0cmllcyB0byB1cGRhdGUgdGhlIGNvbXBvbmVudC4gTW92ZSB0aGlzIHdvcmsgdG8gJyArICd1c2VFZmZlY3QgaW5zdGVhZC4nKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgaWYgKHByZXZpb3VzRmliZXIpIHtcbiAgICAgICAgc2V0Q3VycmVudEZpYmVyKGZpYmVyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc2V0Q3VycmVudEZpYmVyKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbnZhciBkaWRXYXJuU3RhdGVVcGRhdGVGb3JVbm1vdW50ZWRDb21wb25lbnQgPSBudWxsO1xuXG5mdW5jdGlvbiB3YXJuQWJvdXRVcGRhdGVPblVubW91bnRlZEZpYmVySW5ERVYoZmliZXIpIHtcbiAge1xuICAgIHZhciB0YWcgPSBmaWJlci50YWc7XG5cbiAgICBpZiAodGFnICE9PSBIb3N0Um9vdCAmJiB0YWcgIT09IENsYXNzQ29tcG9uZW50ICYmIHRhZyAhPT0gRnVuY3Rpb25Db21wb25lbnQgJiYgdGFnICE9PSBGb3J3YXJkUmVmICYmIHRhZyAhPT0gTWVtb0NvbXBvbmVudCAmJiB0YWcgIT09IFNpbXBsZU1lbW9Db21wb25lbnQgJiYgdGFnICE9PSBCbG9jaykge1xuICAgICAgLy8gT25seSB3YXJuIGZvciB1c2VyLWRlZmluZWQgY29tcG9uZW50cywgbm90IGludGVybmFsIG9uZXMgbGlrZSBTdXNwZW5zZS5cbiAgICAgIHJldHVybjtcbiAgICB9IC8vIElmIHRoZXJlIGFyZSBwZW5kaW5nIHBhc3NpdmUgZWZmZWN0cyB1bm1vdW50cyBmb3IgdGhpcyBGaWJlcixcbiAgICAvLyB3ZSBjYW4gYXNzdW1lIHRoYXQgdGhleSB3b3VsZCBoYXZlIHByZXZlbnRlZCB0aGlzIHVwZGF0ZS5cblxuXG4gICAgaWYgKChmaWJlci5mbGFncyAmIFBhc3NpdmVVbm1vdW50UGVuZGluZ0RldikgIT09IE5vRmxhZ3MpIHtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIFdlIHNob3cgdGhlIHdob2xlIHN0YWNrIGJ1dCBkZWR1cGUgb24gdGhlIHRvcCBjb21wb25lbnQncyBuYW1lIGJlY2F1c2VcbiAgICAvLyB0aGUgcHJvYmxlbWF0aWMgY29kZSBhbG1vc3QgYWx3YXlzIGxpZXMgaW5zaWRlIHRoYXQgY29tcG9uZW50LlxuXG5cbiAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWUoZmliZXIudHlwZSkgfHwgJ1JlYWN0Q29tcG9uZW50JztcblxuICAgIGlmIChkaWRXYXJuU3RhdGVVcGRhdGVGb3JVbm1vdW50ZWRDb21wb25lbnQgIT09IG51bGwpIHtcbiAgICAgIGlmIChkaWRXYXJuU3RhdGVVcGRhdGVGb3JVbm1vdW50ZWRDb21wb25lbnQuaGFzKGNvbXBvbmVudE5hbWUpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgZGlkV2FyblN0YXRlVXBkYXRlRm9yVW5tb3VudGVkQ29tcG9uZW50LmFkZChjb21wb25lbnROYW1lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGlkV2FyblN0YXRlVXBkYXRlRm9yVW5tb3VudGVkQ29tcG9uZW50ID0gbmV3IFNldChbY29tcG9uZW50TmFtZV0pO1xuICAgIH1cblxuICAgIGlmIChpc0ZsdXNoaW5nUGFzc2l2ZUVmZmVjdHMpIDsgZWxzZSB7XG4gICAgICB2YXIgcHJldmlvdXNGaWJlciA9IGN1cnJlbnQ7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHNldEN1cnJlbnRGaWJlcihmaWJlcik7XG5cbiAgICAgICAgZXJyb3IoXCJDYW4ndCBwZXJmb3JtIGEgUmVhY3Qgc3RhdGUgdXBkYXRlIG9uIGFuIHVubW91bnRlZCBjb21wb25lbnQuIFRoaXMgXCIgKyAnaXMgYSBuby1vcCwgYnV0IGl0IGluZGljYXRlcyBhIG1lbW9yeSBsZWFrIGluIHlvdXIgYXBwbGljYXRpb24uIFRvICcgKyAnZml4LCBjYW5jZWwgYWxsIHN1YnNjcmlwdGlvbnMgYW5kIGFzeW5jaHJvbm91cyB0YXNrcyBpbiAlcy4nLCB0YWcgPT09IENsYXNzQ29tcG9uZW50ID8gJ3RoZSBjb21wb25lbnRXaWxsVW5tb3VudCBtZXRob2QnIDogJ2EgdXNlRWZmZWN0IGNsZWFudXAgZnVuY3Rpb24nKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGlmIChwcmV2aW91c0ZpYmVyKSB7XG4gICAgICAgICAgc2V0Q3VycmVudEZpYmVyKGZpYmVyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXNldEN1cnJlbnRGaWJlcigpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbnZhciBiZWdpbldvcmskMTtcblxue1xuICB2YXIgZHVtbXlGaWJlciA9IG51bGw7XG5cbiAgYmVnaW5Xb3JrJDEgPSBmdW5jdGlvbiAoY3VycmVudCwgdW5pdE9mV29yaywgbGFuZXMpIHtcbiAgICAvLyBJZiBhIGNvbXBvbmVudCB0aHJvd3MgYW4gZXJyb3IsIHdlIHJlcGxheSBpdCBhZ2FpbiBpbiBhIHN5bmNocm9ub3VzbHlcbiAgICAvLyBkaXNwYXRjaGVkIGV2ZW50LCBzbyB0aGF0IHRoZSBkZWJ1Z2dlciB3aWxsIHRyZWF0IGl0IGFzIGFuIHVuY2F1Z2h0XG4gICAgLy8gZXJyb3IgU2VlIFJlYWN0RXJyb3JVdGlscyBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAgICAvLyBCZWZvcmUgZW50ZXJpbmcgdGhlIGJlZ2luIHBoYXNlLCBjb3B5IHRoZSB3b3JrLWluLXByb2dyZXNzIG9udG8gYSBkdW1teVxuICAgIC8vIGZpYmVyLiBJZiBiZWdpbldvcmsgdGhyb3dzLCB3ZSdsbCB1c2UgdGhpcyB0byByZXNldCB0aGUgc3RhdGUuXG4gICAgdmFyIG9yaWdpbmFsV29ya0luUHJvZ3Jlc3NDb3B5ID0gYXNzaWduRmliZXJQcm9wZXJ0aWVzSW5ERVYoZHVtbXlGaWJlciwgdW5pdE9mV29yayk7XG5cbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGJlZ2luV29yayhjdXJyZW50LCB1bml0T2ZXb3JrLCBsYW5lcyk7XG4gICAgfSBjYXRjaCAob3JpZ2luYWxFcnJvcikge1xuICAgICAgaWYgKG9yaWdpbmFsRXJyb3IgIT09IG51bGwgJiYgdHlwZW9mIG9yaWdpbmFsRXJyb3IgPT09ICdvYmplY3QnICYmIHR5cGVvZiBvcmlnaW5hbEVycm9yLnRoZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gRG9uJ3QgcmVwbGF5IHByb21pc2VzLiBUcmVhdCBldmVyeXRoaW5nIGVsc2UgbGlrZSBhbiBlcnJvci5cbiAgICAgICAgdGhyb3cgb3JpZ2luYWxFcnJvcjtcbiAgICAgIH0gLy8gS2VlcCB0aGlzIGNvZGUgaW4gc3luYyB3aXRoIGhhbmRsZUVycm9yOyBhbnkgY2hhbmdlcyBoZXJlIG11c3QgaGF2ZVxuICAgICAgLy8gY29ycmVzcG9uZGluZyBjaGFuZ2VzIHRoZXJlLlxuXG5cbiAgICAgIHJlc2V0Q29udGV4dERlcGVuZGVuY2llcygpO1xuICAgICAgcmVzZXRIb29rc0FmdGVyVGhyb3coKTsgLy8gRG9uJ3QgcmVzZXQgY3VycmVudCBkZWJ1ZyBmaWJlciwgc2luY2Ugd2UncmUgYWJvdXQgdG8gd29yayBvbiB0aGVcbiAgICAgIC8vIHNhbWUgZmliZXIgYWdhaW4uXG4gICAgICAvLyBVbndpbmQgdGhlIGZhaWxlZCBzdGFjayBmcmFtZVxuXG4gICAgICB1bndpbmRJbnRlcnJ1cHRlZFdvcmsodW5pdE9mV29yayk7IC8vIFJlc3RvcmUgdGhlIG9yaWdpbmFsIHByb3BlcnRpZXMgb2YgdGhlIGZpYmVyLlxuXG4gICAgICBhc3NpZ25GaWJlclByb3BlcnRpZXNJbkRFVih1bml0T2ZXb3JrLCBvcmlnaW5hbFdvcmtJblByb2dyZXNzQ29weSk7XG5cbiAgICAgIGlmICggdW5pdE9mV29yay5tb2RlICYgUHJvZmlsZU1vZGUpIHtcbiAgICAgICAgLy8gUmVzZXQgdGhlIHByb2ZpbGVyIHRpbWVyLlxuICAgICAgICBzdGFydFByb2ZpbGVyVGltZXIodW5pdE9mV29yayk7XG4gICAgICB9IC8vIFJ1biBiZWdpbldvcmsgYWdhaW4uXG5cblxuICAgICAgaW52b2tlR3VhcmRlZENhbGxiYWNrKG51bGwsIGJlZ2luV29yaywgbnVsbCwgY3VycmVudCwgdW5pdE9mV29yaywgbGFuZXMpO1xuXG4gICAgICBpZiAoaGFzQ2F1Z2h0RXJyb3IoKSkge1xuICAgICAgICB2YXIgcmVwbGF5RXJyb3IgPSBjbGVhckNhdWdodEVycm9yKCk7IC8vIGBpbnZva2VHdWFyZGVkQ2FsbGJhY2tgIHNvbWV0aW1lcyBzZXRzIGFuIGV4cGFuZG8gYF9zdXBwcmVzc0xvZ2dpbmdgLlxuICAgICAgICAvLyBSZXRocm93IHRoaXMgZXJyb3IgaW5zdGVhZCBvZiB0aGUgb3JpZ2luYWwgb25lLlxuXG4gICAgICAgIHRocm93IHJlcGxheUVycm9yO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gVGhpcyBicmFuY2ggaXMgcmVhY2hhYmxlIGlmIHRoZSByZW5kZXIgcGhhc2UgaXMgaW1wdXJlLlxuICAgICAgICB0aHJvdyBvcmlnaW5hbEVycm9yO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbn1cblxudmFyIGRpZFdhcm5BYm91dFVwZGF0ZUluUmVuZGVyID0gZmFsc2U7XG52YXIgZGlkV2FybkFib3V0VXBkYXRlSW5SZW5kZXJGb3JBbm90aGVyQ29tcG9uZW50O1xuXG57XG4gIGRpZFdhcm5BYm91dFVwZGF0ZUluUmVuZGVyRm9yQW5vdGhlckNvbXBvbmVudCA9IG5ldyBTZXQoKTtcbn1cblxuZnVuY3Rpb24gd2FybkFib3V0UmVuZGVyUGhhc2VVcGRhdGVzSW5ERVYoZmliZXIpIHtcbiAge1xuICAgIGlmIChpc1JlbmRlcmluZyAmJiAoZXhlY3V0aW9uQ29udGV4dCAmIFJlbmRlckNvbnRleHQpICE9PSBOb0NvbnRleHQgJiYgIWdldElzVXBkYXRpbmdPcGFxdWVWYWx1ZUluUmVuZGVyUGhhc2VJbkRFVigpKSB7XG4gICAgICBzd2l0Y2ggKGZpYmVyLnRhZykge1xuICAgICAgICBjYXNlIEZ1bmN0aW9uQ29tcG9uZW50OlxuICAgICAgICBjYXNlIEZvcndhcmRSZWY6XG4gICAgICAgIGNhc2UgU2ltcGxlTWVtb0NvbXBvbmVudDpcbiAgICAgICAgICB7XG4gICAgICAgICAgICB2YXIgcmVuZGVyaW5nQ29tcG9uZW50TmFtZSA9IHdvcmtJblByb2dyZXNzICYmIGdldENvbXBvbmVudE5hbWUod29ya0luUHJvZ3Jlc3MudHlwZSkgfHwgJ1Vua25vd24nOyAvLyBEZWR1cGUgYnkgdGhlIHJlbmRlcmluZyBjb21wb25lbnQgYmVjYXVzZSBpdCdzIHRoZSBvbmUgdGhhdCBuZWVkcyB0byBiZSBmaXhlZC5cblxuICAgICAgICAgICAgdmFyIGRlZHVwZUtleSA9IHJlbmRlcmluZ0NvbXBvbmVudE5hbWU7XG5cbiAgICAgICAgICAgIGlmICghZGlkV2FybkFib3V0VXBkYXRlSW5SZW5kZXJGb3JBbm90aGVyQ29tcG9uZW50LmhhcyhkZWR1cGVLZXkpKSB7XG4gICAgICAgICAgICAgIGRpZFdhcm5BYm91dFVwZGF0ZUluUmVuZGVyRm9yQW5vdGhlckNvbXBvbmVudC5hZGQoZGVkdXBlS2V5KTtcbiAgICAgICAgICAgICAgdmFyIHNldFN0YXRlQ29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWUoZmliZXIudHlwZSkgfHwgJ1Vua25vd24nO1xuXG4gICAgICAgICAgICAgIGVycm9yKCdDYW5ub3QgdXBkYXRlIGEgY29tcG9uZW50IChgJXNgKSB3aGlsZSByZW5kZXJpbmcgYSAnICsgJ2RpZmZlcmVudCBjb21wb25lbnQgKGAlc2ApLiBUbyBsb2NhdGUgdGhlIGJhZCBzZXRTdGF0ZSgpIGNhbGwgaW5zaWRlIGAlc2AsICcgKyAnZm9sbG93IHRoZSBzdGFjayB0cmFjZSBhcyBkZXNjcmliZWQgaW4gaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3NldHN0YXRlLWluLXJlbmRlcicsIHNldFN0YXRlQ29tcG9uZW50TmFtZSwgcmVuZGVyaW5nQ29tcG9uZW50TmFtZSwgcmVuZGVyaW5nQ29tcG9uZW50TmFtZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlIENsYXNzQ29tcG9uZW50OlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlmICghZGlkV2FybkFib3V0VXBkYXRlSW5SZW5kZXIpIHtcbiAgICAgICAgICAgICAgZXJyb3IoJ0Nhbm5vdCB1cGRhdGUgZHVyaW5nIGFuIGV4aXN0aW5nIHN0YXRlIHRyYW5zaXRpb24gKHN1Y2ggYXMgJyArICd3aXRoaW4gYHJlbmRlcmApLiBSZW5kZXIgbWV0aG9kcyBzaG91bGQgYmUgYSBwdXJlICcgKyAnZnVuY3Rpb24gb2YgcHJvcHMgYW5kIHN0YXRlLicpO1xuXG4gICAgICAgICAgICAgIGRpZFdhcm5BYm91dFVwZGF0ZUluUmVuZGVyID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufSAvLyBhICdzaGFyZWQnIHZhcmlhYmxlIHRoYXQgY2hhbmdlcyB3aGVuIGFjdCgpIG9wZW5zL2Nsb3NlcyBpbiB0ZXN0cy5cblxuXG52YXIgSXNUaGlzUmVuZGVyZXJBY3RpbmcgPSB7XG4gIGN1cnJlbnQ6IGZhbHNlXG59O1xuZnVuY3Rpb24gd2FybklmTm90U2NvcGVkV2l0aE1hdGNoaW5nQWN0KGZpYmVyKSB7XG4gIHtcbiAgICBpZiAoIElzU29tZVJlbmRlcmVyQWN0aW5nLmN1cnJlbnQgPT09IHRydWUgJiYgSXNUaGlzUmVuZGVyZXJBY3RpbmcuY3VycmVudCAhPT0gdHJ1ZSkge1xuICAgICAgdmFyIHByZXZpb3VzRmliZXIgPSBjdXJyZW50O1xuXG4gICAgICB0cnkge1xuICAgICAgICBzZXRDdXJyZW50RmliZXIoZmliZXIpO1xuXG4gICAgICAgIGVycm9yKFwiSXQgbG9va3MgbGlrZSB5b3UncmUgdXNpbmcgdGhlIHdyb25nIGFjdCgpIGFyb3VuZCB5b3VyIHRlc3QgaW50ZXJhY3Rpb25zLlxcblwiICsgJ0JlIHN1cmUgdG8gdXNlIHRoZSBtYXRjaGluZyB2ZXJzaW9uIG9mIGFjdCgpIGNvcnJlc3BvbmRpbmcgdG8geW91ciByZW5kZXJlcjpcXG5cXG4nICsgJy8vIGZvciByZWFjdC1kb206XFxuJyArIC8vIEJyZWFrIHVwIGltcG9ydHMgdG8gYXZvaWQgYWNjaWRlbnRhbGx5IHBhcnNpbmcgdGhlbSBhcyBkZXBlbmRlbmNpZXMuXG4gICAgICAgICdpbXBvcnQge2FjdH0gZnInICsgXCJvbSAncmVhY3QtZG9tL3Rlc3QtdXRpbHMnO1xcblwiICsgJy8vIC4uLlxcbicgKyAnYWN0KCgpID0+IC4uLik7XFxuXFxuJyArICcvLyBmb3IgcmVhY3QtdGVzdC1yZW5kZXJlcjpcXG4nICsgLy8gQnJlYWsgdXAgaW1wb3J0cyB0byBhdm9pZCBhY2NpZGVudGFsbHkgcGFyc2luZyB0aGVtIGFzIGRlcGVuZGVuY2llcy5cbiAgICAgICAgJ2ltcG9ydCBUZXN0UmVuZGVyZXIgZnInICsgXCJvbSByZWFjdC10ZXN0LXJlbmRlcmVyJztcXG5cIiArICdjb25zdCB7YWN0fSA9IFRlc3RSZW5kZXJlcjtcXG4nICsgJy8vIC4uLlxcbicgKyAnYWN0KCgpID0+IC4uLik7Jyk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBpZiAocHJldmlvdXNGaWJlcikge1xuICAgICAgICAgIHNldEN1cnJlbnRGaWJlcihmaWJlcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzZXRDdXJyZW50RmliZXIoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gd2FybklmTm90Q3VycmVudGx5QWN0aW5nRWZmZWN0c0luREVWKGZpYmVyKSB7XG4gIHtcbiAgICBpZiAoIChmaWJlci5tb2RlICYgU3RyaWN0TW9kZSkgIT09IE5vTW9kZSAmJiBJc1NvbWVSZW5kZXJlckFjdGluZy5jdXJyZW50ID09PSBmYWxzZSAmJiBJc1RoaXNSZW5kZXJlckFjdGluZy5jdXJyZW50ID09PSBmYWxzZSkge1xuICAgICAgZXJyb3IoJ0FuIHVwZGF0ZSB0byAlcyByYW4gYW4gZWZmZWN0LCBidXQgd2FzIG5vdCB3cmFwcGVkIGluIGFjdCguLi4pLlxcblxcbicgKyAnV2hlbiB0ZXN0aW5nLCBjb2RlIHRoYXQgY2F1c2VzIFJlYWN0IHN0YXRlIHVwZGF0ZXMgc2hvdWxkIGJlICcgKyAnd3JhcHBlZCBpbnRvIGFjdCguLi4pOlxcblxcbicgKyAnYWN0KCgpID0+IHtcXG4nICsgJyAgLyogZmlyZSBldmVudHMgdGhhdCB1cGRhdGUgc3RhdGUgKi9cXG4nICsgJ30pO1xcbicgKyAnLyogYXNzZXJ0IG9uIHRoZSBvdXRwdXQgKi9cXG5cXG4nICsgXCJUaGlzIGVuc3VyZXMgdGhhdCB5b3UncmUgdGVzdGluZyB0aGUgYmVoYXZpb3IgdGhlIHVzZXIgd291bGQgc2VlIFwiICsgJ2luIHRoZSBicm93c2VyLicgKyAnIExlYXJuIG1vcmUgYXQgaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3dyYXAtdGVzdHMtd2l0aC1hY3QnLCBnZXRDb21wb25lbnROYW1lKGZpYmVyLnR5cGUpKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gd2FybklmTm90Q3VycmVudGx5QWN0aW5nVXBkYXRlc0luREVWKGZpYmVyKSB7XG4gIHtcbiAgICBpZiAoIGV4ZWN1dGlvbkNvbnRleHQgPT09IE5vQ29udGV4dCAmJiBJc1NvbWVSZW5kZXJlckFjdGluZy5jdXJyZW50ID09PSBmYWxzZSAmJiBJc1RoaXNSZW5kZXJlckFjdGluZy5jdXJyZW50ID09PSBmYWxzZSkge1xuICAgICAgdmFyIHByZXZpb3VzRmliZXIgPSBjdXJyZW50O1xuXG4gICAgICB0cnkge1xuICAgICAgICBzZXRDdXJyZW50RmliZXIoZmliZXIpO1xuXG4gICAgICAgIGVycm9yKCdBbiB1cGRhdGUgdG8gJXMgaW5zaWRlIGEgdGVzdCB3YXMgbm90IHdyYXBwZWQgaW4gYWN0KC4uLikuXFxuXFxuJyArICdXaGVuIHRlc3RpbmcsIGNvZGUgdGhhdCBjYXVzZXMgUmVhY3Qgc3RhdGUgdXBkYXRlcyBzaG91bGQgYmUgJyArICd3cmFwcGVkIGludG8gYWN0KC4uLik6XFxuXFxuJyArICdhY3QoKCkgPT4ge1xcbicgKyAnICAvKiBmaXJlIGV2ZW50cyB0aGF0IHVwZGF0ZSBzdGF0ZSAqL1xcbicgKyAnfSk7XFxuJyArICcvKiBhc3NlcnQgb24gdGhlIG91dHB1dCAqL1xcblxcbicgKyBcIlRoaXMgZW5zdXJlcyB0aGF0IHlvdSdyZSB0ZXN0aW5nIHRoZSBiZWhhdmlvciB0aGUgdXNlciB3b3VsZCBzZWUgXCIgKyAnaW4gdGhlIGJyb3dzZXIuJyArICcgTGVhcm4gbW9yZSBhdCBodHRwczovL3JlYWN0anMub3JnL2xpbmsvd3JhcC10ZXN0cy13aXRoLWFjdCcsIGdldENvbXBvbmVudE5hbWUoZmliZXIudHlwZSkpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgaWYgKHByZXZpb3VzRmliZXIpIHtcbiAgICAgICAgICBzZXRDdXJyZW50RmliZXIoZmliZXIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc2V0Q3VycmVudEZpYmVyKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxudmFyIHdhcm5JZk5vdEN1cnJlbnRseUFjdGluZ1VwZGF0ZXNJbkRldiA9IHdhcm5JZk5vdEN1cnJlbnRseUFjdGluZ1VwZGF0ZXNJbkRFVjsgLy8gSW4gdGVzdHMsIHdlIHdhbnQgdG8gZW5mb3JjZSBhIG1vY2tlZCBzY2hlZHVsZXIuXG5cbnZhciBkaWRXYXJuQWJvdXRVbm1vY2tlZFNjaGVkdWxlciA9IGZhbHNlOyAvLyBUT0RPIEJlZm9yZSB3ZSByZWxlYXNlIGNvbmN1cnJlbnQgbW9kZSwgcmV2aXNpdCB0aGlzIGFuZCBkZWNpZGUgd2hldGhlciBhIG1vY2tlZFxuLy8gc2NoZWR1bGVyIGlzIHRoZSBhY3R1YWwgcmVjb21tZW5kYXRpb24uIFRoZSBhbHRlcm5hdGl2ZSBjb3VsZCBiZSBhIHRlc3RpbmcgYnVpbGQsXG4vLyBhIG5ldyBsaWIsIG9yIHdoYXRldmVyOyB3ZSBkdW5ubyBqdXN0IHlldC4gVGhpcyBtZXNzYWdlIGlzIGZvciBlYXJseSBhZG9wdGVyc1xuLy8gdG8gZ2V0IHRoZWlyIHRlc3RzIHJpZ2h0LlxuXG5mdW5jdGlvbiB3YXJuSWZVbm1vY2tlZFNjaGVkdWxlcihmaWJlcikge1xuICB7XG4gICAgaWYgKGRpZFdhcm5BYm91dFVubW9ja2VkU2NoZWR1bGVyID09PSBmYWxzZSAmJiBTY2hlZHVsZXIudW5zdGFibGVfZmx1c2hBbGxXaXRob3V0QXNzZXJ0aW5nID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmIChmaWJlci5tb2RlICYgQmxvY2tpbmdNb2RlIHx8IGZpYmVyLm1vZGUgJiBDb25jdXJyZW50TW9kZSkge1xuICAgICAgICBkaWRXYXJuQWJvdXRVbm1vY2tlZFNjaGVkdWxlciA9IHRydWU7XG5cbiAgICAgICAgZXJyb3IoJ0luIENvbmN1cnJlbnQgb3IgU3luYyBtb2RlcywgdGhlIFwic2NoZWR1bGVyXCIgbW9kdWxlIG5lZWRzIHRvIGJlIG1vY2tlZCAnICsgJ3RvIGd1YXJhbnRlZSBjb25zaXN0ZW50IGJlaGF2aW91ciBhY3Jvc3MgdGVzdHMgYW5kIGJyb3dzZXJzLiAnICsgJ0ZvciBleGFtcGxlLCB3aXRoIGplc3Q6IFxcbicgKyAvLyBCcmVhayB1cCByZXF1aXJlcyB0byBhdm9pZCBhY2NpZGVudGFsbHkgcGFyc2luZyB0aGVtIGFzIGRlcGVuZGVuY2llcy5cbiAgICAgICAgXCJqZXN0Lm1vY2soJ3NjaGVkdWxlcicsICgpID0+IHJlcXVpcmVcIiArIFwiKCdzY2hlZHVsZXIvdW5zdGFibGVfbW9jaycpKTtcXG5cXG5cIiArICdGb3IgbW9yZSBpbmZvLCB2aXNpdCBodHRwczovL3JlYWN0anMub3JnL2xpbmsvbW9jay1zY2hlZHVsZXInKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY29tcHV0ZVRocmVhZElEKHJvb3QsIGxhbmUpIHtcbiAgLy8gSW50ZXJhY3Rpb24gdGhyZWFkcyBhcmUgdW5pcXVlIHBlciByb290IGFuZCBleHBpcmF0aW9uIHRpbWUuXG4gIC8vIE5PVEU6IEludGVudGlvbmFsbHkgdW5zb3VuZCBjYXN0LiBBbGwgdGhhdCBtYXR0ZXJzIGlzIHRoYXQgaXQncyBhIG51bWJlclxuICAvLyBhbmQgaXQgcmVwcmVzZW50cyBhIGJhdGNoIG9mIHdvcmsuIENvdWxkIG1ha2UgYSBoZWxwZXIgZnVuY3Rpb24gaW5zdGVhZCxcbiAgLy8gYnV0IG1laCB0aGlzIGlzIGZpbmUgZm9yIG5vdy5cbiAgcmV0dXJuIGxhbmUgKiAxMDAwICsgcm9vdC5pbnRlcmFjdGlvblRocmVhZElEO1xufVxuXG5mdW5jdGlvbiBtYXJrU3Bhd25lZFdvcmsobGFuZSkge1xuXG4gIGlmIChzcGF3bmVkV29ya0R1cmluZ1JlbmRlciA9PT0gbnVsbCkge1xuICAgIHNwYXduZWRXb3JrRHVyaW5nUmVuZGVyID0gW2xhbmVdO1xuICB9IGVsc2Uge1xuICAgIHNwYXduZWRXb3JrRHVyaW5nUmVuZGVyLnB1c2gobGFuZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc2NoZWR1bGVJbnRlcmFjdGlvbnMocm9vdCwgbGFuZSwgaW50ZXJhY3Rpb25zKSB7XG5cbiAgaWYgKGludGVyYWN0aW9ucy5zaXplID4gMCkge1xuICAgIHZhciBwZW5kaW5nSW50ZXJhY3Rpb25NYXAgPSByb290LnBlbmRpbmdJbnRlcmFjdGlvbk1hcDtcbiAgICB2YXIgcGVuZGluZ0ludGVyYWN0aW9ucyA9IHBlbmRpbmdJbnRlcmFjdGlvbk1hcC5nZXQobGFuZSk7XG5cbiAgICBpZiAocGVuZGluZ0ludGVyYWN0aW9ucyAhPSBudWxsKSB7XG4gICAgICBpbnRlcmFjdGlvbnMuZm9yRWFjaChmdW5jdGlvbiAoaW50ZXJhY3Rpb24pIHtcbiAgICAgICAgaWYgKCFwZW5kaW5nSW50ZXJhY3Rpb25zLmhhcyhpbnRlcmFjdGlvbikpIHtcbiAgICAgICAgICAvLyBVcGRhdGUgdGhlIHBlbmRpbmcgYXN5bmMgd29yayBjb3VudCBmb3IgcHJldmlvdXNseSB1bnNjaGVkdWxlZCBpbnRlcmFjdGlvbi5cbiAgICAgICAgICBpbnRlcmFjdGlvbi5fX2NvdW50Kys7XG4gICAgICAgIH1cblxuICAgICAgICBwZW5kaW5nSW50ZXJhY3Rpb25zLmFkZChpbnRlcmFjdGlvbik7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcGVuZGluZ0ludGVyYWN0aW9uTWFwLnNldChsYW5lLCBuZXcgU2V0KGludGVyYWN0aW9ucykpOyAvLyBVcGRhdGUgdGhlIHBlbmRpbmcgYXN5bmMgd29yayBjb3VudCBmb3IgdGhlIGN1cnJlbnQgaW50ZXJhY3Rpb25zLlxuXG4gICAgICBpbnRlcmFjdGlvbnMuZm9yRWFjaChmdW5jdGlvbiAoaW50ZXJhY3Rpb24pIHtcbiAgICAgICAgaW50ZXJhY3Rpb24uX19jb3VudCsrO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgdmFyIHN1YnNjcmliZXIgPSB0cmFjaW5nLl9fc3Vic2NyaWJlclJlZi5jdXJyZW50O1xuXG4gICAgaWYgKHN1YnNjcmliZXIgIT09IG51bGwpIHtcbiAgICAgIHZhciB0aHJlYWRJRCA9IGNvbXB1dGVUaHJlYWRJRChyb290LCBsYW5lKTtcbiAgICAgIHN1YnNjcmliZXIub25Xb3JrU2NoZWR1bGVkKGludGVyYWN0aW9ucywgdGhyZWFkSUQpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBzY2hlZHVsZVBlbmRpbmdJbnRlcmFjdGlvbnMocm9vdCwgbGFuZSkge1xuXG4gIHNjaGVkdWxlSW50ZXJhY3Rpb25zKHJvb3QsIGxhbmUsIHRyYWNpbmcuX19pbnRlcmFjdGlvbnNSZWYuY3VycmVudCk7XG59XG5cbmZ1bmN0aW9uIHN0YXJ0V29ya09uUGVuZGluZ0ludGVyYWN0aW9ucyhyb290LCBsYW5lcykge1xuICAvLyB3ZSBjYW4gYWNjdXJhdGVseSBhdHRyaWJ1dGUgdGltZSBzcGVudCB3b3JraW5nIG9uIGl0LCBBbmQgc28gdGhhdCBjYXNjYWRpbmdcbiAgLy8gd29yayB0cmlnZ2VyZWQgZHVyaW5nIHRoZSByZW5kZXIgcGhhc2Ugd2lsbCBiZSBhc3NvY2lhdGVkIHdpdGggaXQuXG5cblxuICB2YXIgaW50ZXJhY3Rpb25zID0gbmV3IFNldCgpO1xuICByb290LnBlbmRpbmdJbnRlcmFjdGlvbk1hcC5mb3JFYWNoKGZ1bmN0aW9uIChzY2hlZHVsZWRJbnRlcmFjdGlvbnMsIHNjaGVkdWxlZExhbmUpIHtcbiAgICBpZiAoaW5jbHVkZXNTb21lTGFuZShsYW5lcywgc2NoZWR1bGVkTGFuZSkpIHtcbiAgICAgIHNjaGVkdWxlZEludGVyYWN0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChpbnRlcmFjdGlvbikge1xuICAgICAgICByZXR1cm4gaW50ZXJhY3Rpb25zLmFkZChpbnRlcmFjdGlvbik7XG4gICAgICB9KTtcbiAgICB9XG4gIH0pOyAvLyBTdG9yZSB0aGUgY3VycmVudCBzZXQgb2YgaW50ZXJhY3Rpb25zIG9uIHRoZSBGaWJlclJvb3QgZm9yIGEgZmV3IHJlYXNvbnM6XG4gIC8vIFdlIGNhbiByZS11c2UgaXQgaW4gaG90IGZ1bmN0aW9ucyBsaWtlIHBlcmZvcm1Db25jdXJyZW50V29ya09uUm9vdCgpXG4gIC8vIHdpdGhvdXQgaGF2aW5nIHRvIHJlY2FsY3VsYXRlIGl0LiBXZSB3aWxsIGFsc28gdXNlIGl0IGluIGNvbW1pdFdvcmsoKSB0b1xuICAvLyBwYXNzIHRvIGFueSBQcm9maWxlciBvblJlbmRlcigpIGhvb2tzLiBUaGlzIGFsc28gcHJvdmlkZXMgRGV2VG9vbHMgd2l0aCBhXG4gIC8vIHdheSB0byBhY2Nlc3MgaXQgd2hlbiB0aGUgb25Db21taXRSb290KCkgaG9vayBpcyBjYWxsZWQuXG5cbiAgcm9vdC5tZW1vaXplZEludGVyYWN0aW9ucyA9IGludGVyYWN0aW9ucztcblxuICBpZiAoaW50ZXJhY3Rpb25zLnNpemUgPiAwKSB7XG4gICAgdmFyIHN1YnNjcmliZXIgPSB0cmFjaW5nLl9fc3Vic2NyaWJlclJlZi5jdXJyZW50O1xuXG4gICAgaWYgKHN1YnNjcmliZXIgIT09IG51bGwpIHtcbiAgICAgIHZhciB0aHJlYWRJRCA9IGNvbXB1dGVUaHJlYWRJRChyb290LCBsYW5lcyk7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHN1YnNjcmliZXIub25Xb3JrU3RhcnRlZChpbnRlcmFjdGlvbnMsIHRocmVhZElEKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIC8vIElmIHRoZSBzdWJzY3JpYmVyIHRocm93cywgcmV0aHJvdyBpdCBpbiBhIHNlcGFyYXRlIHRhc2tcbiAgICAgICAgc2NoZWR1bGVDYWxsYmFjayhJbW1lZGlhdGVQcmlvcml0eSQxLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBmaW5pc2hQZW5kaW5nSW50ZXJhY3Rpb25zKHJvb3QsIGNvbW1pdHRlZExhbmVzKSB7XG5cbiAgdmFyIHJlbWFpbmluZ0xhbmVzQWZ0ZXJDb21taXQgPSByb290LnBlbmRpbmdMYW5lcztcbiAgdmFyIHN1YnNjcmliZXI7XG5cbiAgdHJ5IHtcbiAgICBzdWJzY3JpYmVyID0gdHJhY2luZy5fX3N1YnNjcmliZXJSZWYuY3VycmVudDtcblxuICAgIGlmIChzdWJzY3JpYmVyICE9PSBudWxsICYmIHJvb3QubWVtb2l6ZWRJbnRlcmFjdGlvbnMuc2l6ZSA+IDApIHtcbiAgICAgIC8vIEZJWE1FOiBNb3JlIHRoYW4gb25lIGxhbmUgY2FuIGZpbmlzaCBpbiBhIHNpbmdsZSBjb21taXQuXG4gICAgICB2YXIgdGhyZWFkSUQgPSBjb21wdXRlVGhyZWFkSUQocm9vdCwgY29tbWl0dGVkTGFuZXMpO1xuICAgICAgc3Vic2NyaWJlci5vbldvcmtTdG9wcGVkKHJvb3QubWVtb2l6ZWRJbnRlcmFjdGlvbnMsIHRocmVhZElEKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgLy8gSWYgdGhlIHN1YnNjcmliZXIgdGhyb3dzLCByZXRocm93IGl0IGluIGEgc2VwYXJhdGUgdGFza1xuICAgIHNjaGVkdWxlQ2FsbGJhY2soSW1tZWRpYXRlUHJpb3JpdHkkMSwgZnVuY3Rpb24gKCkge1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfSk7XG4gIH0gZmluYWxseSB7XG4gICAgLy8gQ2xlYXIgY29tcGxldGVkIGludGVyYWN0aW9ucyBmcm9tIHRoZSBwZW5kaW5nIE1hcC5cbiAgICAvLyBVbmxlc3MgdGhlIHJlbmRlciB3YXMgc3VzcGVuZGVkIG9yIGNhc2NhZGluZyB3b3JrIHdhcyBzY2hlZHVsZWQsXG4gICAgLy8gSW4gd2hpY2ggY2FzZeKAkyBsZWF2ZSBwZW5kaW5nIGludGVyYWN0aW9ucyB1bnRpbCB0aGUgc3Vic2VxdWVudCByZW5kZXIuXG4gICAgdmFyIHBlbmRpbmdJbnRlcmFjdGlvbk1hcCA9IHJvb3QucGVuZGluZ0ludGVyYWN0aW9uTWFwO1xuICAgIHBlbmRpbmdJbnRlcmFjdGlvbk1hcC5mb3JFYWNoKGZ1bmN0aW9uIChzY2hlZHVsZWRJbnRlcmFjdGlvbnMsIGxhbmUpIHtcbiAgICAgIC8vIE9ubHkgZGVjcmVtZW50IHRoZSBwZW5kaW5nIGludGVyYWN0aW9uIGNvdW50IGlmIHdlJ3JlIGRvbmUuXG4gICAgICAvLyBJZiB0aGVyZSdzIHN0aWxsIHdvcmsgYXQgdGhlIGN1cnJlbnQgcHJpb3JpdHksXG4gICAgICAvLyBUaGF0IGluZGljYXRlcyB0aGF0IHdlIGFyZSB3YWl0aW5nIGZvciBzdXNwZW5zZSBkYXRhLlxuICAgICAgaWYgKCFpbmNsdWRlc1NvbWVMYW5lKHJlbWFpbmluZ0xhbmVzQWZ0ZXJDb21taXQsIGxhbmUpKSB7XG4gICAgICAgIHBlbmRpbmdJbnRlcmFjdGlvbk1hcC5kZWxldGUobGFuZSk7XG4gICAgICAgIHNjaGVkdWxlZEludGVyYWN0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChpbnRlcmFjdGlvbikge1xuICAgICAgICAgIGludGVyYWN0aW9uLl9fY291bnQtLTtcblxuICAgICAgICAgIGlmIChzdWJzY3JpYmVyICE9PSBudWxsICYmIGludGVyYWN0aW9uLl9fY291bnQgPT09IDApIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHN1YnNjcmliZXIub25JbnRlcmFjdGlvblNjaGVkdWxlZFdvcmtDb21wbGV0ZWQoaW50ZXJhY3Rpb24pO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgLy8gSWYgdGhlIHN1YnNjcmliZXIgdGhyb3dzLCByZXRocm93IGl0IGluIGEgc2VwYXJhdGUgdGFza1xuICAgICAgICAgICAgICBzY2hlZHVsZUNhbGxiYWNrKEltbWVkaWF0ZVByaW9yaXR5JDEsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufSAvLyBgYWN0YCB0ZXN0aW5nIEFQSVxuXG5mdW5jdGlvbiBzaG91bGRGb3JjZUZsdXNoRmFsbGJhY2tzSW5ERVYoKSB7XG4gIC8vIE5ldmVyIGZvcmNlIGZsdXNoIGluIHByb2R1Y3Rpb24uIFRoaXMgZnVuY3Rpb24gc2hvdWxkIGdldCBzdHJpcHBlZCBvdXQuXG4gIHJldHVybiAgYWN0aW5nVXBkYXRlc1Njb3BlRGVwdGggPiAwO1xufVxuLy8gc28gd2UgY2FuIHRlbGwgaWYgYW55IGFzeW5jIGFjdCgpIGNhbGxzIHRyeSB0byBydW4gaW4gcGFyYWxsZWwuXG5cblxudmFyIGFjdGluZ1VwZGF0ZXNTY29wZURlcHRoID0gMDtcblxuZnVuY3Rpb24gZGV0YWNoRmliZXJBZnRlckVmZmVjdHMoZmliZXIpIHtcbiAgZmliZXIuc2libGluZyA9IG51bGw7XG4gIGZpYmVyLnN0YXRlTm9kZSA9IG51bGw7XG59XG5cbnZhciByZXNvbHZlRmFtaWx5ID0gbnVsbDsgLy8gJEZsb3dGaXhNZSBGbG93IGdldHMgY29uZnVzZWQgYnkgYSBXZWFrU2V0IGZlYXR1cmUgY2hlY2sgYmVsb3cuXG5cbnZhciBmYWlsZWRCb3VuZGFyaWVzID0gbnVsbDtcbnZhciBzZXRSZWZyZXNoSGFuZGxlciA9IGZ1bmN0aW9uIChoYW5kbGVyKSB7XG4gIHtcbiAgICByZXNvbHZlRmFtaWx5ID0gaGFuZGxlcjtcbiAgfVxufTtcbmZ1bmN0aW9uIHJlc29sdmVGdW5jdGlvbkZvckhvdFJlbG9hZGluZyh0eXBlKSB7XG4gIHtcbiAgICBpZiAocmVzb2x2ZUZhbWlseSA9PT0gbnVsbCkge1xuICAgICAgLy8gSG90IHJlbG9hZGluZyBpcyBkaXNhYmxlZC5cbiAgICAgIHJldHVybiB0eXBlO1xuICAgIH1cblxuICAgIHZhciBmYW1pbHkgPSByZXNvbHZlRmFtaWx5KHR5cGUpO1xuXG4gICAgaWYgKGZhbWlseSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gdHlwZTtcbiAgICB9IC8vIFVzZSB0aGUgbGF0ZXN0IGtub3duIGltcGxlbWVudGF0aW9uLlxuXG5cbiAgICByZXR1cm4gZmFtaWx5LmN1cnJlbnQ7XG4gIH1cbn1cbmZ1bmN0aW9uIHJlc29sdmVDbGFzc0ZvckhvdFJlbG9hZGluZyh0eXBlKSB7XG4gIC8vIE5vIGltcGxlbWVudGF0aW9uIGRpZmZlcmVuY2VzLlxuICByZXR1cm4gcmVzb2x2ZUZ1bmN0aW9uRm9ySG90UmVsb2FkaW5nKHR5cGUpO1xufVxuZnVuY3Rpb24gcmVzb2x2ZUZvcndhcmRSZWZGb3JIb3RSZWxvYWRpbmcodHlwZSkge1xuICB7XG4gICAgaWYgKHJlc29sdmVGYW1pbHkgPT09IG51bGwpIHtcbiAgICAgIC8vIEhvdCByZWxvYWRpbmcgaXMgZGlzYWJsZWQuXG4gICAgICByZXR1cm4gdHlwZTtcbiAgICB9XG5cbiAgICB2YXIgZmFtaWx5ID0gcmVzb2x2ZUZhbWlseSh0eXBlKTtcblxuICAgIGlmIChmYW1pbHkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gQ2hlY2sgaWYgd2UncmUgZGVhbGluZyB3aXRoIGEgcmVhbCBmb3J3YXJkUmVmLiBEb24ndCB3YW50IHRvIGNyYXNoIGVhcmx5LlxuICAgICAgaWYgKHR5cGUgIT09IG51bGwgJiYgdHlwZSAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiB0eXBlLnJlbmRlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyBGb3J3YXJkUmVmIGlzIHNwZWNpYWwgYmVjYXVzZSBpdHMgcmVzb2x2ZWQgLnR5cGUgaXMgYW4gb2JqZWN0LFxuICAgICAgICAvLyBidXQgaXQncyBwb3NzaWJsZSB0aGF0IHdlIG9ubHkgaGF2ZSBpdHMgaW5uZXIgcmVuZGVyIGZ1bmN0aW9uIGluIHRoZSBtYXAuXG4gICAgICAgIC8vIElmIHRoYXQgaW5uZXIgcmVuZGVyIGZ1bmN0aW9uIGlzIGRpZmZlcmVudCwgd2UnbGwgYnVpbGQgYSBuZXcgZm9yd2FyZFJlZiB0eXBlLlxuICAgICAgICB2YXIgY3VycmVudFJlbmRlciA9IHJlc29sdmVGdW5jdGlvbkZvckhvdFJlbG9hZGluZyh0eXBlLnJlbmRlcik7XG5cbiAgICAgICAgaWYgKHR5cGUucmVuZGVyICE9PSBjdXJyZW50UmVuZGVyKSB7XG4gICAgICAgICAgdmFyIHN5bnRoZXRpY1R5cGUgPSB7XG4gICAgICAgICAgICAkJHR5cGVvZjogUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSxcbiAgICAgICAgICAgIHJlbmRlcjogY3VycmVudFJlbmRlclxuICAgICAgICAgIH07XG5cbiAgICAgICAgICBpZiAodHlwZS5kaXNwbGF5TmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBzeW50aGV0aWNUeXBlLmRpc3BsYXlOYW1lID0gdHlwZS5kaXNwbGF5TmFtZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gc3ludGhldGljVHlwZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHlwZTtcbiAgICB9IC8vIFVzZSB0aGUgbGF0ZXN0IGtub3duIGltcGxlbWVudGF0aW9uLlxuXG5cbiAgICByZXR1cm4gZmFtaWx5LmN1cnJlbnQ7XG4gIH1cbn1cbmZ1bmN0aW9uIGlzQ29tcGF0aWJsZUZhbWlseUZvckhvdFJlbG9hZGluZyhmaWJlciwgZWxlbWVudCkge1xuICB7XG4gICAgaWYgKHJlc29sdmVGYW1pbHkgPT09IG51bGwpIHtcbiAgICAgIC8vIEhvdCByZWxvYWRpbmcgaXMgZGlzYWJsZWQuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIHByZXZUeXBlID0gZmliZXIuZWxlbWVudFR5cGU7XG4gICAgdmFyIG5leHRUeXBlID0gZWxlbWVudC50eXBlOyAvLyBJZiB3ZSBnb3QgaGVyZSwgd2Uga25vdyB0eXBlcyBhcmVuJ3QgPT09IGVxdWFsLlxuXG4gICAgdmFyIG5lZWRzQ29tcGFyZUZhbWlsaWVzID0gZmFsc2U7XG4gICAgdmFyICQkdHlwZW9mTmV4dFR5cGUgPSB0eXBlb2YgbmV4dFR5cGUgPT09ICdvYmplY3QnICYmIG5leHRUeXBlICE9PSBudWxsID8gbmV4dFR5cGUuJCR0eXBlb2YgOiBudWxsO1xuXG4gICAgc3dpdGNoIChmaWJlci50YWcpIHtcbiAgICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG4gICAgICAgIHtcbiAgICAgICAgICBpZiAodHlwZW9mIG5leHRUeXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBuZWVkc0NvbXBhcmVGYW1pbGllcyA9IHRydWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBGdW5jdGlvbkNvbXBvbmVudDpcbiAgICAgICAge1xuICAgICAgICAgIGlmICh0eXBlb2YgbmV4dFR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIG5lZWRzQ29tcGFyZUZhbWlsaWVzID0gdHJ1ZTtcbiAgICAgICAgICB9IGVsc2UgaWYgKCQkdHlwZW9mTmV4dFR5cGUgPT09IFJFQUNUX0xBWllfVFlQRSkge1xuICAgICAgICAgICAgLy8gV2UgZG9uJ3Qga25vdyB0aGUgaW5uZXIgdHlwZSB5ZXQuXG4gICAgICAgICAgICAvLyBXZSdyZSBnb2luZyB0byBhc3N1bWUgdGhhdCB0aGUgbGF6eSBpbm5lciB0eXBlIGlzIHN0YWJsZSxcbiAgICAgICAgICAgIC8vIGFuZCBzbyBpdCBpcyBzdWZmaWNpZW50IHRvIGF2b2lkIHJlY29uY2lsaW5nIGl0IGF3YXkuXG4gICAgICAgICAgICAvLyBXZSdyZSBub3QgZ29pbmcgdG8gdW53cmFwIG9yIGFjdHVhbGx5IHVzZSB0aGUgbmV3IGxhenkgdHlwZS5cbiAgICAgICAgICAgIG5lZWRzQ29tcGFyZUZhbWlsaWVzID0gdHJ1ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIEZvcndhcmRSZWY6XG4gICAgICAgIHtcbiAgICAgICAgICBpZiAoJCR0eXBlb2ZOZXh0VHlwZSA9PT0gUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSkge1xuICAgICAgICAgICAgbmVlZHNDb21wYXJlRmFtaWxpZXMgPSB0cnVlO1xuICAgICAgICAgIH0gZWxzZSBpZiAoJCR0eXBlb2ZOZXh0VHlwZSA9PT0gUkVBQ1RfTEFaWV9UWVBFKSB7XG4gICAgICAgICAgICBuZWVkc0NvbXBhcmVGYW1pbGllcyA9IHRydWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBNZW1vQ29tcG9uZW50OlxuICAgICAgY2FzZSBTaW1wbGVNZW1vQ29tcG9uZW50OlxuICAgICAgICB7XG4gICAgICAgICAgaWYgKCQkdHlwZW9mTmV4dFR5cGUgPT09IFJFQUNUX01FTU9fVFlQRSkge1xuICAgICAgICAgICAgLy8gVE9ETzogaWYgaXQgd2FzIGJ1dCBjYW4gbm8gbG9uZ2VyIGJlIHNpbXBsZSxcbiAgICAgICAgICAgIC8vIHdlIHNob3VsZG4ndCBzZXQgdGhpcy5cbiAgICAgICAgICAgIG5lZWRzQ29tcGFyZUZhbWlsaWVzID0gdHJ1ZTtcbiAgICAgICAgICB9IGVsc2UgaWYgKCQkdHlwZW9mTmV4dFR5cGUgPT09IFJFQUNUX0xBWllfVFlQRSkge1xuICAgICAgICAgICAgbmVlZHNDb21wYXJlRmFtaWxpZXMgPSB0cnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IC8vIENoZWNrIGlmIGJvdGggdHlwZXMgaGF2ZSBhIGZhbWlseSBhbmQgaXQncyB0aGUgc2FtZSBvbmUuXG5cblxuICAgIGlmIChuZWVkc0NvbXBhcmVGYW1pbGllcykge1xuICAgICAgLy8gTm90ZTogbWVtbygpIGFuZCBmb3J3YXJkUmVmKCkgd2UnbGwgY29tcGFyZSBvdXRlciByYXRoZXIgdGhhbiBpbm5lciB0eXBlLlxuICAgICAgLy8gVGhpcyBtZWFucyBib3RoIG9mIHRoZW0gbmVlZCB0byBiZSByZWdpc3RlcmVkIHRvIHByZXNlcnZlIHN0YXRlLlxuICAgICAgLy8gSWYgd2UgdW53cmFwcGVkIGFuZCBjb21wYXJlZCB0aGUgaW5uZXIgdHlwZXMgZm9yIHdyYXBwZXJzIGluc3RlYWQsXG4gICAgICAvLyB0aGVuIHdlIHdvdWxkIHJpc2sgZmFsc2VseSBzYXlpbmcgdHdvIHNlcGFyYXRlIG1lbW8oRm9vKVxuICAgICAgLy8gY2FsbHMgYXJlIGVxdWl2YWxlbnQgYmVjYXVzZSB0aGV5IHdyYXAgdGhlIHNhbWUgRm9vIGZ1bmN0aW9uLlxuICAgICAgdmFyIHByZXZGYW1pbHkgPSByZXNvbHZlRmFtaWx5KHByZXZUeXBlKTtcblxuICAgICAgaWYgKHByZXZGYW1pbHkgIT09IHVuZGVmaW5lZCAmJiBwcmV2RmFtaWx5ID09PSByZXNvbHZlRmFtaWx5KG5leHRUeXBlKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cbmZ1bmN0aW9uIG1hcmtGYWlsZWRFcnJvckJvdW5kYXJ5Rm9ySG90UmVsb2FkaW5nKGZpYmVyKSB7XG4gIHtcbiAgICBpZiAocmVzb2x2ZUZhbWlseSA9PT0gbnVsbCkge1xuICAgICAgLy8gSG90IHJlbG9hZGluZyBpcyBkaXNhYmxlZC5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIFdlYWtTZXQgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoZmFpbGVkQm91bmRhcmllcyA9PT0gbnVsbCkge1xuICAgICAgZmFpbGVkQm91bmRhcmllcyA9IG5ldyBXZWFrU2V0KCk7XG4gICAgfVxuXG4gICAgZmFpbGVkQm91bmRhcmllcy5hZGQoZmliZXIpO1xuICB9XG59XG52YXIgc2NoZWR1bGVSZWZyZXNoID0gZnVuY3Rpb24gKHJvb3QsIHVwZGF0ZSkge1xuICB7XG4gICAgaWYgKHJlc29sdmVGYW1pbHkgPT09IG51bGwpIHtcbiAgICAgIC8vIEhvdCByZWxvYWRpbmcgaXMgZGlzYWJsZWQuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHN0YWxlRmFtaWxpZXMgPSB1cGRhdGUuc3RhbGVGYW1pbGllcyxcbiAgICAgICAgdXBkYXRlZEZhbWlsaWVzID0gdXBkYXRlLnVwZGF0ZWRGYW1pbGllcztcbiAgICBmbHVzaFBhc3NpdmVFZmZlY3RzKCk7XG4gICAgZmx1c2hTeW5jKGZ1bmN0aW9uICgpIHtcbiAgICAgIHNjaGVkdWxlRmliZXJzV2l0aEZhbWlsaWVzUmVjdXJzaXZlbHkocm9vdC5jdXJyZW50LCB1cGRhdGVkRmFtaWxpZXMsIHN0YWxlRmFtaWxpZXMpO1xuICAgIH0pO1xuICB9XG59O1xudmFyIHNjaGVkdWxlUm9vdCA9IGZ1bmN0aW9uIChyb290LCBlbGVtZW50KSB7XG4gIHtcbiAgICBpZiAocm9vdC5jb250ZXh0ICE9PSBlbXB0eUNvbnRleHRPYmplY3QpIHtcbiAgICAgIC8vIFN1cGVyIGVkZ2UgY2FzZTogcm9vdCBoYXMgYSBsZWdhY3kgX3JlbmRlclN1YnRyZWUgY29udGV4dFxuICAgICAgLy8gYnV0IHdlIGRvbid0IGtub3cgdGhlIHBhcmVudENvbXBvbmVudCBzbyB3ZSBjYW4ndCBwYXNzIGl0LlxuICAgICAgLy8gSnVzdCBpZ25vcmUuIFdlJ2xsIGRlbGV0ZSB0aGlzIHdpdGggX3JlbmRlclN1YnRyZWUgY29kZSBwYXRoIGxhdGVyLlxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGZsdXNoUGFzc2l2ZUVmZmVjdHMoKTtcbiAgICBmbHVzaFN5bmMoZnVuY3Rpb24gKCkge1xuICAgICAgdXBkYXRlQ29udGFpbmVyKGVsZW1lbnQsIHJvb3QsIG51bGwsIG51bGwpO1xuICAgIH0pO1xuICB9XG59O1xuXG5mdW5jdGlvbiBzY2hlZHVsZUZpYmVyc1dpdGhGYW1pbGllc1JlY3Vyc2l2ZWx5KGZpYmVyLCB1cGRhdGVkRmFtaWxpZXMsIHN0YWxlRmFtaWxpZXMpIHtcbiAge1xuICAgIHZhciBhbHRlcm5hdGUgPSBmaWJlci5hbHRlcm5hdGUsXG4gICAgICAgIGNoaWxkID0gZmliZXIuY2hpbGQsXG4gICAgICAgIHNpYmxpbmcgPSBmaWJlci5zaWJsaW5nLFxuICAgICAgICB0YWcgPSBmaWJlci50YWcsXG4gICAgICAgIHR5cGUgPSBmaWJlci50eXBlO1xuICAgIHZhciBjYW5kaWRhdGVUeXBlID0gbnVsbDtcblxuICAgIHN3aXRjaCAodGFnKSB7XG4gICAgICBjYXNlIEZ1bmN0aW9uQ29tcG9uZW50OlxuICAgICAgY2FzZSBTaW1wbGVNZW1vQ29tcG9uZW50OlxuICAgICAgY2FzZSBDbGFzc0NvbXBvbmVudDpcbiAgICAgICAgY2FuZGlkYXRlVHlwZSA9IHR5cGU7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIEZvcndhcmRSZWY6XG4gICAgICAgIGNhbmRpZGF0ZVR5cGUgPSB0eXBlLnJlbmRlcjtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgaWYgKHJlc29sdmVGYW1pbHkgPT09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgcmVzb2x2ZUZhbWlseSB0byBiZSBzZXQgZHVyaW5nIGhvdCByZWxvYWQuJyk7XG4gICAgfVxuXG4gICAgdmFyIG5lZWRzUmVuZGVyID0gZmFsc2U7XG4gICAgdmFyIG5lZWRzUmVtb3VudCA9IGZhbHNlO1xuXG4gICAgaWYgKGNhbmRpZGF0ZVR5cGUgIT09IG51bGwpIHtcbiAgICAgIHZhciBmYW1pbHkgPSByZXNvbHZlRmFtaWx5KGNhbmRpZGF0ZVR5cGUpO1xuXG4gICAgICBpZiAoZmFtaWx5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKHN0YWxlRmFtaWxpZXMuaGFzKGZhbWlseSkpIHtcbiAgICAgICAgICBuZWVkc1JlbW91bnQgPSB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYgKHVwZGF0ZWRGYW1pbGllcy5oYXMoZmFtaWx5KSkge1xuICAgICAgICAgIGlmICh0YWcgPT09IENsYXNzQ29tcG9uZW50KSB7XG4gICAgICAgICAgICBuZWVkc1JlbW91bnQgPSB0cnVlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBuZWVkc1JlbmRlciA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGZhaWxlZEJvdW5kYXJpZXMgIT09IG51bGwpIHtcbiAgICAgIGlmIChmYWlsZWRCb3VuZGFyaWVzLmhhcyhmaWJlcikgfHwgYWx0ZXJuYXRlICE9PSBudWxsICYmIGZhaWxlZEJvdW5kYXJpZXMuaGFzKGFsdGVybmF0ZSkpIHtcbiAgICAgICAgbmVlZHNSZW1vdW50ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAobmVlZHNSZW1vdW50KSB7XG4gICAgICBmaWJlci5fZGVidWdOZWVkc1JlbW91bnQgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmIChuZWVkc1JlbW91bnQgfHwgbmVlZHNSZW5kZXIpIHtcbiAgICAgIHNjaGVkdWxlVXBkYXRlT25GaWJlcihmaWJlciwgU3luY0xhbmUsIE5vVGltZXN0YW1wKTtcbiAgICB9XG5cbiAgICBpZiAoY2hpbGQgIT09IG51bGwgJiYgIW5lZWRzUmVtb3VudCkge1xuICAgICAgc2NoZWR1bGVGaWJlcnNXaXRoRmFtaWxpZXNSZWN1cnNpdmVseShjaGlsZCwgdXBkYXRlZEZhbWlsaWVzLCBzdGFsZUZhbWlsaWVzKTtcbiAgICB9XG5cbiAgICBpZiAoc2libGluZyAhPT0gbnVsbCkge1xuICAgICAgc2NoZWR1bGVGaWJlcnNXaXRoRmFtaWxpZXNSZWN1cnNpdmVseShzaWJsaW5nLCB1cGRhdGVkRmFtaWxpZXMsIHN0YWxlRmFtaWxpZXMpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgZmluZEhvc3RJbnN0YW5jZXNGb3JSZWZyZXNoID0gZnVuY3Rpb24gKHJvb3QsIGZhbWlsaWVzKSB7XG4gIHtcbiAgICB2YXIgaG9zdEluc3RhbmNlcyA9IG5ldyBTZXQoKTtcbiAgICB2YXIgdHlwZXMgPSBuZXcgU2V0KGZhbWlsaWVzLm1hcChmdW5jdGlvbiAoZmFtaWx5KSB7XG4gICAgICByZXR1cm4gZmFtaWx5LmN1cnJlbnQ7XG4gICAgfSkpO1xuICAgIGZpbmRIb3N0SW5zdGFuY2VzRm9yTWF0Y2hpbmdGaWJlcnNSZWN1cnNpdmVseShyb290LmN1cnJlbnQsIHR5cGVzLCBob3N0SW5zdGFuY2VzKTtcbiAgICByZXR1cm4gaG9zdEluc3RhbmNlcztcbiAgfVxufTtcblxuZnVuY3Rpb24gZmluZEhvc3RJbnN0YW5jZXNGb3JNYXRjaGluZ0ZpYmVyc1JlY3Vyc2l2ZWx5KGZpYmVyLCB0eXBlcywgaG9zdEluc3RhbmNlcykge1xuICB7XG4gICAgdmFyIGNoaWxkID0gZmliZXIuY2hpbGQsXG4gICAgICAgIHNpYmxpbmcgPSBmaWJlci5zaWJsaW5nLFxuICAgICAgICB0YWcgPSBmaWJlci50YWcsXG4gICAgICAgIHR5cGUgPSBmaWJlci50eXBlO1xuICAgIHZhciBjYW5kaWRhdGVUeXBlID0gbnVsbDtcblxuICAgIHN3aXRjaCAodGFnKSB7XG4gICAgICBjYXNlIEZ1bmN0aW9uQ29tcG9uZW50OlxuICAgICAgY2FzZSBTaW1wbGVNZW1vQ29tcG9uZW50OlxuICAgICAgY2FzZSBDbGFzc0NvbXBvbmVudDpcbiAgICAgICAgY2FuZGlkYXRlVHlwZSA9IHR5cGU7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIEZvcndhcmRSZWY6XG4gICAgICAgIGNhbmRpZGF0ZVR5cGUgPSB0eXBlLnJlbmRlcjtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgdmFyIGRpZE1hdGNoID0gZmFsc2U7XG5cbiAgICBpZiAoY2FuZGlkYXRlVHlwZSAhPT0gbnVsbCkge1xuICAgICAgaWYgKHR5cGVzLmhhcyhjYW5kaWRhdGVUeXBlKSkge1xuICAgICAgICBkaWRNYXRjaCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGRpZE1hdGNoKSB7XG4gICAgICAvLyBXZSBoYXZlIGEgbWF0Y2guIFRoaXMgb25seSBkcmlsbHMgZG93biB0byB0aGUgY2xvc2VzdCBob3N0IGNvbXBvbmVudHMuXG4gICAgICAvLyBUaGVyZSdzIG5vIG5lZWQgdG8gc2VhcmNoIGRlZXBlciBiZWNhdXNlIGZvciB0aGUgcHVycG9zZSBvZiBnaXZpbmdcbiAgICAgIC8vIHZpc3VhbCBmZWVkYmFjaywgXCJmbGFzaGluZ1wiIG91dGVybW9zdCBwYXJlbnQgcmVjdGFuZ2xlcyBpcyBzdWZmaWNpZW50LlxuICAgICAgZmluZEhvc3RJbnN0YW5jZXNGb3JGaWJlclNoYWxsb3dseShmaWJlciwgaG9zdEluc3RhbmNlcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIElmIHRoZXJlJ3Mgbm8gbWF0Y2gsIG1heWJlIHRoZXJlIHdpbGwgYmUgb25lIGZ1cnRoZXIgZG93biBpbiB0aGUgY2hpbGQgdHJlZS5cbiAgICAgIGlmIChjaGlsZCAhPT0gbnVsbCkge1xuICAgICAgICBmaW5kSG9zdEluc3RhbmNlc0Zvck1hdGNoaW5nRmliZXJzUmVjdXJzaXZlbHkoY2hpbGQsIHR5cGVzLCBob3N0SW5zdGFuY2VzKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoc2libGluZyAhPT0gbnVsbCkge1xuICAgICAgZmluZEhvc3RJbnN0YW5jZXNGb3JNYXRjaGluZ0ZpYmVyc1JlY3Vyc2l2ZWx5KHNpYmxpbmcsIHR5cGVzLCBob3N0SW5zdGFuY2VzKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZmluZEhvc3RJbnN0YW5jZXNGb3JGaWJlclNoYWxsb3dseShmaWJlciwgaG9zdEluc3RhbmNlcykge1xuICB7XG4gICAgdmFyIGZvdW5kSG9zdEluc3RhbmNlcyA9IGZpbmRDaGlsZEhvc3RJbnN0YW5jZXNGb3JGaWJlclNoYWxsb3dseShmaWJlciwgaG9zdEluc3RhbmNlcyk7XG5cbiAgICBpZiAoZm91bmRIb3N0SW5zdGFuY2VzKSB7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBJZiB3ZSBkaWRuJ3QgZmluZCBhbnkgaG9zdCBjaGlsZHJlbiwgZmFsbGJhY2sgdG8gY2xvc2VzdCBob3N0IHBhcmVudC5cblxuXG4gICAgdmFyIG5vZGUgPSBmaWJlcjtcblxuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICBzd2l0Y2ggKG5vZGUudGFnKSB7XG4gICAgICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgICAgICBob3N0SW5zdGFuY2VzLmFkZChub2RlLnN0YXRlTm9kZSk7XG4gICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgIGNhc2UgSG9zdFBvcnRhbDpcbiAgICAgICAgICBob3N0SW5zdGFuY2VzLmFkZChub2RlLnN0YXRlTm9kZS5jb250YWluZXJJbmZvKTtcbiAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgY2FzZSBIb3N0Um9vdDpcbiAgICAgICAgICBob3N0SW5zdGFuY2VzLmFkZChub2RlLnN0YXRlTm9kZS5jb250YWluZXJJbmZvKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChub2RlLnJldHVybiA9PT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIHRvIHJlYWNoIHJvb3QgZmlyc3QuJyk7XG4gICAgICB9XG5cbiAgICAgIG5vZGUgPSBub2RlLnJldHVybjtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZmluZENoaWxkSG9zdEluc3RhbmNlc0ZvckZpYmVyU2hhbGxvd2x5KGZpYmVyLCBob3N0SW5zdGFuY2VzKSB7XG4gIHtcbiAgICB2YXIgbm9kZSA9IGZpYmVyO1xuICAgIHZhciBmb3VuZEhvc3RJbnN0YW5jZXMgPSBmYWxzZTtcblxuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICBpZiAobm9kZS50YWcgPT09IEhvc3RDb21wb25lbnQpIHtcbiAgICAgICAgLy8gV2UgZ290IGEgbWF0Y2guXG4gICAgICAgIGZvdW5kSG9zdEluc3RhbmNlcyA9IHRydWU7XG4gICAgICAgIGhvc3RJbnN0YW5jZXMuYWRkKG5vZGUuc3RhdGVOb2RlKTsgLy8gVGhlcmUgbWF5IHN0aWxsIGJlIG1vcmUsIHNvIGtlZXAgc2VhcmNoaW5nLlxuICAgICAgfSBlbHNlIGlmIChub2RlLmNoaWxkICE9PSBudWxsKSB7XG4gICAgICAgIG5vZGUuY2hpbGQucmV0dXJuID0gbm9kZTtcbiAgICAgICAgbm9kZSA9IG5vZGUuY2hpbGQ7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAobm9kZSA9PT0gZmliZXIpIHtcbiAgICAgICAgcmV0dXJuIGZvdW5kSG9zdEluc3RhbmNlcztcbiAgICAgIH1cblxuICAgICAgd2hpbGUgKG5vZGUuc2libGluZyA9PT0gbnVsbCkge1xuICAgICAgICBpZiAobm9kZS5yZXR1cm4gPT09IG51bGwgfHwgbm9kZS5yZXR1cm4gPT09IGZpYmVyKSB7XG4gICAgICAgICAgcmV0dXJuIGZvdW5kSG9zdEluc3RhbmNlcztcbiAgICAgICAgfVxuXG4gICAgICAgIG5vZGUgPSBub2RlLnJldHVybjtcbiAgICAgIH1cblxuICAgICAgbm9kZS5zaWJsaW5nLnJldHVybiA9IG5vZGUucmV0dXJuO1xuICAgICAgbm9kZSA9IG5vZGUuc2libGluZztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbnZhciBoYXNCYWRNYXBQb2x5ZmlsbDtcblxue1xuICBoYXNCYWRNYXBQb2x5ZmlsbCA9IGZhbHNlO1xuXG4gIHRyeSB7XG4gICAgdmFyIG5vbkV4dGVuc2libGVPYmplY3QgPSBPYmplY3QucHJldmVudEV4dGVuc2lvbnMoe30pO1xuICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLW5ldyAqL1xuXG4gICAgbmV3IE1hcChbW25vbkV4dGVuc2libGVPYmplY3QsIG51bGxdXSk7XG4gICAgbmV3IFNldChbbm9uRXh0ZW5zaWJsZU9iamVjdF0pO1xuICAgIC8qIGVzbGludC1lbmFibGUgbm8tbmV3ICovXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAvLyBUT0RPOiBDb25zaWRlciB3YXJuaW5nIGFib3V0IGJhZCBwb2x5ZmlsbHNcbiAgICBoYXNCYWRNYXBQb2x5ZmlsbCA9IHRydWU7XG4gIH1cbn1cblxudmFyIGRlYnVnQ291bnRlciA9IDE7XG5cbmZ1bmN0aW9uIEZpYmVyTm9kZSh0YWcsIHBlbmRpbmdQcm9wcywga2V5LCBtb2RlKSB7XG4gIC8vIEluc3RhbmNlXG4gIHRoaXMudGFnID0gdGFnO1xuICB0aGlzLmtleSA9IGtleTtcbiAgdGhpcy5lbGVtZW50VHlwZSA9IG51bGw7XG4gIHRoaXMudHlwZSA9IG51bGw7XG4gIHRoaXMuc3RhdGVOb2RlID0gbnVsbDsgLy8gRmliZXJcblxuICB0aGlzLnJldHVybiA9IG51bGw7XG4gIHRoaXMuY2hpbGQgPSBudWxsO1xuICB0aGlzLnNpYmxpbmcgPSBudWxsO1xuICB0aGlzLmluZGV4ID0gMDtcbiAgdGhpcy5yZWYgPSBudWxsO1xuICB0aGlzLnBlbmRpbmdQcm9wcyA9IHBlbmRpbmdQcm9wcztcbiAgdGhpcy5tZW1vaXplZFByb3BzID0gbnVsbDtcbiAgdGhpcy51cGRhdGVRdWV1ZSA9IG51bGw7XG4gIHRoaXMubWVtb2l6ZWRTdGF0ZSA9IG51bGw7XG4gIHRoaXMuZGVwZW5kZW5jaWVzID0gbnVsbDtcbiAgdGhpcy5tb2RlID0gbW9kZTsgLy8gRWZmZWN0c1xuXG4gIHRoaXMuZmxhZ3MgPSBOb0ZsYWdzO1xuICB0aGlzLm5leHRFZmZlY3QgPSBudWxsO1xuICB0aGlzLmZpcnN0RWZmZWN0ID0gbnVsbDtcbiAgdGhpcy5sYXN0RWZmZWN0ID0gbnVsbDtcbiAgdGhpcy5sYW5lcyA9IE5vTGFuZXM7XG4gIHRoaXMuY2hpbGRMYW5lcyA9IE5vTGFuZXM7XG4gIHRoaXMuYWx0ZXJuYXRlID0gbnVsbDtcblxuICB7XG4gICAgLy8gTm90ZTogVGhlIGZvbGxvd2luZyBpcyBkb25lIHRvIGF2b2lkIGEgdjggcGVyZm9ybWFuY2UgY2xpZmYuXG4gICAgLy9cbiAgICAvLyBJbml0aWFsaXppbmcgdGhlIGZpZWxkcyBiZWxvdyB0byBzbWlzIGFuZCBsYXRlciB1cGRhdGluZyB0aGVtIHdpdGhcbiAgICAvLyBkb3VibGUgdmFsdWVzIHdpbGwgY2F1c2UgRmliZXJzIHRvIGVuZCB1cCBoYXZpbmcgc2VwYXJhdGUgc2hhcGVzLlxuICAgIC8vIFRoaXMgYmVoYXZpb3IvYnVnIGhhcyBzb21ldGhpbmcgdG8gZG8gd2l0aCBPYmplY3QucHJldmVudEV4dGVuc2lvbigpLlxuICAgIC8vIEZvcnR1bmF0ZWx5IHRoaXMgb25seSBpbXBhY3RzIERFViBidWlsZHMuXG4gICAgLy8gVW5mb3J0dW5hdGVseSBpdCBtYWtlcyBSZWFjdCB1bnVzYWJseSBzbG93IGZvciBzb21lIGFwcGxpY2F0aW9ucy5cbiAgICAvLyBUbyB3b3JrIGFyb3VuZCB0aGlzLCBpbml0aWFsaXplIHRoZSBmaWVsZHMgYmVsb3cgd2l0aCBkb3VibGVzLlxuICAgIC8vXG4gICAgLy8gTGVhcm4gbW9yZSBhYm91dCB0aGlzIGhlcmU6XG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xNDM2NVxuICAgIC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTg1MzhcbiAgICB0aGlzLmFjdHVhbER1cmF0aW9uID0gTnVtYmVyLk5hTjtcbiAgICB0aGlzLmFjdHVhbFN0YXJ0VGltZSA9IE51bWJlci5OYU47XG4gICAgdGhpcy5zZWxmQmFzZUR1cmF0aW9uID0gTnVtYmVyLk5hTjtcbiAgICB0aGlzLnRyZWVCYXNlRHVyYXRpb24gPSBOdW1iZXIuTmFOOyAvLyBJdCdzIG9rYXkgdG8gcmVwbGFjZSB0aGUgaW5pdGlhbCBkb3VibGVzIHdpdGggc21pcyBhZnRlciBpbml0aWFsaXphdGlvbi5cbiAgICAvLyBUaGlzIHdvbid0IHRyaWdnZXIgdGhlIHBlcmZvcm1hbmNlIGNsaWZmIG1lbnRpb25lZCBhYm92ZSxcbiAgICAvLyBhbmQgaXQgc2ltcGxpZmllcyBvdGhlciBwcm9maWxlciBjb2RlIChpbmNsdWRpbmcgRGV2VG9vbHMpLlxuXG4gICAgdGhpcy5hY3R1YWxEdXJhdGlvbiA9IDA7XG4gICAgdGhpcy5hY3R1YWxTdGFydFRpbWUgPSAtMTtcbiAgICB0aGlzLnNlbGZCYXNlRHVyYXRpb24gPSAwO1xuICAgIHRoaXMudHJlZUJhc2VEdXJhdGlvbiA9IDA7XG4gIH1cblxuICB7XG4gICAgLy8gVGhpcyBpc24ndCBkaXJlY3RseSB1c2VkIGJ1dCBpcyBoYW5keSBmb3IgZGVidWdnaW5nIGludGVybmFsczpcbiAgICB0aGlzLl9kZWJ1Z0lEID0gZGVidWdDb3VudGVyKys7XG4gICAgdGhpcy5fZGVidWdTb3VyY2UgPSBudWxsO1xuICAgIHRoaXMuX2RlYnVnT3duZXIgPSBudWxsO1xuICAgIHRoaXMuX2RlYnVnTmVlZHNSZW1vdW50ID0gZmFsc2U7XG4gICAgdGhpcy5fZGVidWdIb29rVHlwZXMgPSBudWxsO1xuXG4gICAgaWYgKCFoYXNCYWRNYXBQb2x5ZmlsbCAmJiB0eXBlb2YgT2JqZWN0LnByZXZlbnRFeHRlbnNpb25zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBPYmplY3QucHJldmVudEV4dGVuc2lvbnModGhpcyk7XG4gICAgfVxuICB9XG59IC8vIFRoaXMgaXMgYSBjb25zdHJ1Y3RvciBmdW5jdGlvbiwgcmF0aGVyIHRoYW4gYSBQT0pPIGNvbnN0cnVjdG9yLCBzdGlsbFxuLy8gcGxlYXNlIGVuc3VyZSB3ZSBkbyB0aGUgZm9sbG93aW5nOlxuLy8gMSkgTm9ib2R5IHNob3VsZCBhZGQgYW55IGluc3RhbmNlIG1ldGhvZHMgb24gdGhpcy4gSW5zdGFuY2UgbWV0aG9kcyBjYW4gYmVcbi8vICAgIG1vcmUgZGlmZmljdWx0IHRvIHByZWRpY3Qgd2hlbiB0aGV5IGdldCBvcHRpbWl6ZWQgYW5kIHRoZXkgYXJlIGFsbW9zdFxuLy8gICAgbmV2ZXIgaW5saW5lZCBwcm9wZXJseSBpbiBzdGF0aWMgY29tcGlsZXJzLlxuLy8gMikgTm9ib2R5IHNob3VsZCByZWx5IG9uIGBpbnN0YW5jZW9mIEZpYmVyYCBmb3IgdHlwZSB0ZXN0aW5nLiBXZSBzaG91bGRcbi8vICAgIGFsd2F5cyBrbm93IHdoZW4gaXQgaXMgYSBmaWJlci5cbi8vIDMpIFdlIG1pZ2h0IHdhbnQgdG8gZXhwZXJpbWVudCB3aXRoIHVzaW5nIG51bWVyaWMga2V5cyBzaW5jZSB0aGV5IGFyZSBlYXNpZXJcbi8vICAgIHRvIG9wdGltaXplIGluIGEgbm9uLUpJVCBlbnZpcm9ubWVudC5cbi8vIDQpIFdlIGNhbiBlYXNpbHkgZ28gZnJvbSBhIGNvbnN0cnVjdG9yIHRvIGEgY3JlYXRlRmliZXIgb2JqZWN0IGxpdGVyYWwgaWYgdGhhdFxuLy8gICAgaXMgZmFzdGVyLlxuLy8gNSkgSXQgc2hvdWxkIGJlIGVhc3kgdG8gcG9ydCB0aGlzIHRvIGEgQyBzdHJ1Y3QgYW5kIGtlZXAgYSBDIGltcGxlbWVudGF0aW9uXG4vLyAgICBjb21wYXRpYmxlLlxuXG5cbnZhciBjcmVhdGVGaWJlciA9IGZ1bmN0aW9uICh0YWcsIHBlbmRpbmdQcm9wcywga2V5LCBtb2RlKSB7XG4gIC8vICRGbG93Rml4TWU6IHRoZSBzaGFwZXMgYXJlIGV4YWN0IGhlcmUgYnV0IEZsb3cgZG9lc24ndCBsaWtlIGNvbnN0cnVjdG9yc1xuICByZXR1cm4gbmV3IEZpYmVyTm9kZSh0YWcsIHBlbmRpbmdQcm9wcywga2V5LCBtb2RlKTtcbn07XG5cbmZ1bmN0aW9uIHNob3VsZENvbnN0cnVjdCQxKENvbXBvbmVudCkge1xuICB2YXIgcHJvdG90eXBlID0gQ29tcG9uZW50LnByb3RvdHlwZTtcbiAgcmV0dXJuICEhKHByb3RvdHlwZSAmJiBwcm90b3R5cGUuaXNSZWFjdENvbXBvbmVudCk7XG59XG5cbmZ1bmN0aW9uIGlzU2ltcGxlRnVuY3Rpb25Db21wb25lbnQodHlwZSkge1xuICByZXR1cm4gdHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicgJiYgIXNob3VsZENvbnN0cnVjdCQxKHR5cGUpICYmIHR5cGUuZGVmYXVsdFByb3BzID09PSB1bmRlZmluZWQ7XG59XG5mdW5jdGlvbiByZXNvbHZlTGF6eUNvbXBvbmVudFRhZyhDb21wb25lbnQpIHtcbiAgaWYgKHR5cGVvZiBDb21wb25lbnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gc2hvdWxkQ29uc3RydWN0JDEoQ29tcG9uZW50KSA/IENsYXNzQ29tcG9uZW50IDogRnVuY3Rpb25Db21wb25lbnQ7XG4gIH0gZWxzZSBpZiAoQ29tcG9uZW50ICE9PSB1bmRlZmluZWQgJiYgQ29tcG9uZW50ICE9PSBudWxsKSB7XG4gICAgdmFyICQkdHlwZW9mID0gQ29tcG9uZW50LiQkdHlwZW9mO1xuXG4gICAgaWYgKCQkdHlwZW9mID09PSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFKSB7XG4gICAgICByZXR1cm4gRm9yd2FyZFJlZjtcbiAgICB9XG5cbiAgICBpZiAoJCR0eXBlb2YgPT09IFJFQUNUX01FTU9fVFlQRSkge1xuICAgICAgcmV0dXJuIE1lbW9Db21wb25lbnQ7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIEluZGV0ZXJtaW5hdGVDb21wb25lbnQ7XG59IC8vIFRoaXMgaXMgdXNlZCB0byBjcmVhdGUgYW4gYWx0ZXJuYXRlIGZpYmVyIHRvIGRvIHdvcmsgb24uXG5cbmZ1bmN0aW9uIGNyZWF0ZVdvcmtJblByb2dyZXNzKGN1cnJlbnQsIHBlbmRpbmdQcm9wcykge1xuICB2YXIgd29ya0luUHJvZ3Jlc3MgPSBjdXJyZW50LmFsdGVybmF0ZTtcblxuICBpZiAod29ya0luUHJvZ3Jlc3MgPT09IG51bGwpIHtcbiAgICAvLyBXZSB1c2UgYSBkb3VibGUgYnVmZmVyaW5nIHBvb2xpbmcgdGVjaG5pcXVlIGJlY2F1c2Ugd2Uga25vdyB0aGF0IHdlJ2xsXG4gICAgLy8gb25seSBldmVyIG5lZWQgYXQgbW9zdCB0d28gdmVyc2lvbnMgb2YgYSB0cmVlLiBXZSBwb29sIHRoZSBcIm90aGVyXCIgdW51c2VkXG4gICAgLy8gbm9kZSB0aGF0IHdlJ3JlIGZyZWUgdG8gcmV1c2UuIFRoaXMgaXMgbGF6aWx5IGNyZWF0ZWQgdG8gYXZvaWQgYWxsb2NhdGluZ1xuICAgIC8vIGV4dHJhIG9iamVjdHMgZm9yIHRoaW5ncyB0aGF0IGFyZSBuZXZlciB1cGRhdGVkLiBJdCBhbHNvIGFsbG93IHVzIHRvXG4gICAgLy8gcmVjbGFpbSB0aGUgZXh0cmEgbWVtb3J5IGlmIG5lZWRlZC5cbiAgICB3b3JrSW5Qcm9ncmVzcyA9IGNyZWF0ZUZpYmVyKGN1cnJlbnQudGFnLCBwZW5kaW5nUHJvcHMsIGN1cnJlbnQua2V5LCBjdXJyZW50Lm1vZGUpO1xuICAgIHdvcmtJblByb2dyZXNzLmVsZW1lbnRUeXBlID0gY3VycmVudC5lbGVtZW50VHlwZTtcbiAgICB3b3JrSW5Qcm9ncmVzcy50eXBlID0gY3VycmVudC50eXBlO1xuICAgIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSA9IGN1cnJlbnQuc3RhdGVOb2RlO1xuXG4gICAge1xuICAgICAgLy8gREVWLW9ubHkgZmllbGRzXG4gICAgICB3b3JrSW5Qcm9ncmVzcy5fZGVidWdJRCA9IGN1cnJlbnQuX2RlYnVnSUQ7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5fZGVidWdTb3VyY2UgPSBjdXJyZW50Ll9kZWJ1Z1NvdXJjZTtcbiAgICAgIHdvcmtJblByb2dyZXNzLl9kZWJ1Z093bmVyID0gY3VycmVudC5fZGVidWdPd25lcjtcbiAgICAgIHdvcmtJblByb2dyZXNzLl9kZWJ1Z0hvb2tUeXBlcyA9IGN1cnJlbnQuX2RlYnVnSG9va1R5cGVzO1xuICAgIH1cblxuICAgIHdvcmtJblByb2dyZXNzLmFsdGVybmF0ZSA9IGN1cnJlbnQ7XG4gICAgY3VycmVudC5hbHRlcm5hdGUgPSB3b3JrSW5Qcm9ncmVzcztcbiAgfSBlbHNlIHtcbiAgICB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHMgPSBwZW5kaW5nUHJvcHM7IC8vIE5lZWRlZCBiZWNhdXNlIEJsb2NrcyBzdG9yZSBkYXRhIG9uIHR5cGUuXG5cbiAgICB3b3JrSW5Qcm9ncmVzcy50eXBlID0gY3VycmVudC50eXBlOyAvLyBXZSBhbHJlYWR5IGhhdmUgYW4gYWx0ZXJuYXRlLlxuICAgIC8vIFJlc2V0IHRoZSBlZmZlY3QgdGFnLlxuXG4gICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgPSBOb0ZsYWdzOyAvLyBUaGUgZWZmZWN0IGxpc3QgaXMgbm8gbG9uZ2VyIHZhbGlkLlxuXG4gICAgd29ya0luUHJvZ3Jlc3MubmV4dEVmZmVjdCA9IG51bGw7XG4gICAgd29ya0luUHJvZ3Jlc3MuZmlyc3RFZmZlY3QgPSBudWxsO1xuICAgIHdvcmtJblByb2dyZXNzLmxhc3RFZmZlY3QgPSBudWxsO1xuXG4gICAge1xuICAgICAgLy8gV2UgaW50ZW50aW9uYWxseSByZXNldCwgcmF0aGVyIHRoYW4gY29weSwgYWN0dWFsRHVyYXRpb24gJiBhY3R1YWxTdGFydFRpbWUuXG4gICAgICAvLyBUaGlzIHByZXZlbnRzIHRpbWUgZnJvbSBlbmRsZXNzbHkgYWNjdW11bGF0aW5nIGluIG5ldyBjb21taXRzLlxuICAgICAgLy8gVGhpcyBoYXMgdGhlIGRvd25zaWRlIG9mIHJlc2V0dGluZyB2YWx1ZXMgZm9yIGRpZmZlcmVudCBwcmlvcml0eSByZW5kZXJzLFxuICAgICAgLy8gQnV0IHdvcmtzIGZvciB5aWVsZGluZyAodGhlIGNvbW1vbiBjYXNlKSBhbmQgc2hvdWxkIHN1cHBvcnQgcmVzdW1pbmcuXG4gICAgICB3b3JrSW5Qcm9ncmVzcy5hY3R1YWxEdXJhdGlvbiA9IDA7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5hY3R1YWxTdGFydFRpbWUgPSAtMTtcbiAgICB9XG4gIH1cblxuICB3b3JrSW5Qcm9ncmVzcy5jaGlsZExhbmVzID0gY3VycmVudC5jaGlsZExhbmVzO1xuICB3b3JrSW5Qcm9ncmVzcy5sYW5lcyA9IGN1cnJlbnQubGFuZXM7XG4gIHdvcmtJblByb2dyZXNzLmNoaWxkID0gY3VycmVudC5jaGlsZDtcbiAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcyA9IGN1cnJlbnQubWVtb2l6ZWRQcm9wcztcbiAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZTtcbiAgd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWUgPSBjdXJyZW50LnVwZGF0ZVF1ZXVlOyAvLyBDbG9uZSB0aGUgZGVwZW5kZW5jaWVzIG9iamVjdC4gVGhpcyBpcyBtdXRhdGVkIGR1cmluZyB0aGUgcmVuZGVyIHBoYXNlLCBzb1xuICAvLyBpdCBjYW5ub3QgYmUgc2hhcmVkIHdpdGggdGhlIGN1cnJlbnQgZmliZXIuXG5cbiAgdmFyIGN1cnJlbnREZXBlbmRlbmNpZXMgPSBjdXJyZW50LmRlcGVuZGVuY2llcztcbiAgd29ya0luUHJvZ3Jlc3MuZGVwZW5kZW5jaWVzID0gY3VycmVudERlcGVuZGVuY2llcyA9PT0gbnVsbCA/IG51bGwgOiB7XG4gICAgbGFuZXM6IGN1cnJlbnREZXBlbmRlbmNpZXMubGFuZXMsXG4gICAgZmlyc3RDb250ZXh0OiBjdXJyZW50RGVwZW5kZW5jaWVzLmZpcnN0Q29udGV4dFxuICB9OyAvLyBUaGVzZSB3aWxsIGJlIG92ZXJyaWRkZW4gZHVyaW5nIHRoZSBwYXJlbnQncyByZWNvbmNpbGlhdGlvblxuXG4gIHdvcmtJblByb2dyZXNzLnNpYmxpbmcgPSBjdXJyZW50LnNpYmxpbmc7XG4gIHdvcmtJblByb2dyZXNzLmluZGV4ID0gY3VycmVudC5pbmRleDtcbiAgd29ya0luUHJvZ3Jlc3MucmVmID0gY3VycmVudC5yZWY7XG5cbiAge1xuICAgIHdvcmtJblByb2dyZXNzLnNlbGZCYXNlRHVyYXRpb24gPSBjdXJyZW50LnNlbGZCYXNlRHVyYXRpb247XG4gICAgd29ya0luUHJvZ3Jlc3MudHJlZUJhc2VEdXJhdGlvbiA9IGN1cnJlbnQudHJlZUJhc2VEdXJhdGlvbjtcbiAgfVxuXG4gIHtcbiAgICB3b3JrSW5Qcm9ncmVzcy5fZGVidWdOZWVkc1JlbW91bnQgPSBjdXJyZW50Ll9kZWJ1Z05lZWRzUmVtb3VudDtcblxuICAgIHN3aXRjaCAod29ya0luUHJvZ3Jlc3MudGFnKSB7XG4gICAgICBjYXNlIEluZGV0ZXJtaW5hdGVDb21wb25lbnQ6XG4gICAgICBjYXNlIEZ1bmN0aW9uQ29tcG9uZW50OlxuICAgICAgY2FzZSBTaW1wbGVNZW1vQ29tcG9uZW50OlxuICAgICAgICB3b3JrSW5Qcm9ncmVzcy50eXBlID0gcmVzb2x2ZUZ1bmN0aW9uRm9ySG90UmVsb2FkaW5nKGN1cnJlbnQudHlwZSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIENsYXNzQ29tcG9uZW50OlxuICAgICAgICB3b3JrSW5Qcm9ncmVzcy50eXBlID0gcmVzb2x2ZUNsYXNzRm9ySG90UmVsb2FkaW5nKGN1cnJlbnQudHlwZSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIEZvcndhcmRSZWY6XG4gICAgICAgIHdvcmtJblByb2dyZXNzLnR5cGUgPSByZXNvbHZlRm9yd2FyZFJlZkZvckhvdFJlbG9hZGluZyhjdXJyZW50LnR5cGUpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gd29ya0luUHJvZ3Jlc3M7XG59IC8vIFVzZWQgdG8gcmV1c2UgYSBGaWJlciBmb3IgYSBzZWNvbmQgcGFzcy5cblxuZnVuY3Rpb24gcmVzZXRXb3JrSW5Qcm9ncmVzcyh3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpIHtcbiAgLy8gVGhpcyByZXNldHMgdGhlIEZpYmVyIHRvIHdoYXQgY3JlYXRlRmliZXIgb3IgY3JlYXRlV29ya0luUHJvZ3Jlc3Mgd291bGRcbiAgLy8gaGF2ZSBzZXQgdGhlIHZhbHVlcyB0byBiZWZvcmUgZHVyaW5nIHRoZSBmaXJzdCBwYXNzLiBJZGVhbGx5IHRoaXMgd291bGRuJ3RcbiAgLy8gYmUgbmVjZXNzYXJ5IGJ1dCB1bmZvcnR1bmF0ZWx5IG1hbnkgY29kZSBwYXRocyByZWFkcyBmcm9tIHRoZSB3b3JrSW5Qcm9ncmVzc1xuICAvLyB3aGVuIHRoZXkgc2hvdWxkIGJlIHJlYWRpbmcgZnJvbSBjdXJyZW50IGFuZCB3cml0aW5nIHRvIHdvcmtJblByb2dyZXNzLlxuICAvLyBXZSBhc3N1bWUgcGVuZGluZ1Byb3BzLCBpbmRleCwga2V5LCByZWYsIHJldHVybiBhcmUgc3RpbGwgdW50b3VjaGVkIHRvXG4gIC8vIGF2b2lkIGRvaW5nIGFub3RoZXIgcmVjb25jaWxpYXRpb24uXG4gIC8vIFJlc2V0IHRoZSBlZmZlY3QgdGFnIGJ1dCBrZWVwIGFueSBQbGFjZW1lbnQgdGFncywgc2luY2UgdGhhdCdzIHNvbWV0aGluZ1xuICAvLyB0aGF0IGNoaWxkIGZpYmVyIGlzIHNldHRpbmcsIG5vdCB0aGUgcmVjb25jaWxpYXRpb24uXG4gIHdvcmtJblByb2dyZXNzLmZsYWdzICY9IFBsYWNlbWVudDsgLy8gVGhlIGVmZmVjdCBsaXN0IGlzIG5vIGxvbmdlciB2YWxpZC5cblxuICB3b3JrSW5Qcm9ncmVzcy5uZXh0RWZmZWN0ID0gbnVsbDtcbiAgd29ya0luUHJvZ3Jlc3MuZmlyc3RFZmZlY3QgPSBudWxsO1xuICB3b3JrSW5Qcm9ncmVzcy5sYXN0RWZmZWN0ID0gbnVsbDtcbiAgdmFyIGN1cnJlbnQgPSB3b3JrSW5Qcm9ncmVzcy5hbHRlcm5hdGU7XG5cbiAgaWYgKGN1cnJlbnQgPT09IG51bGwpIHtcbiAgICAvLyBSZXNldCB0byBjcmVhdGVGaWJlcidzIGluaXRpYWwgdmFsdWVzLlxuICAgIHdvcmtJblByb2dyZXNzLmNoaWxkTGFuZXMgPSBOb0xhbmVzO1xuICAgIHdvcmtJblByb2dyZXNzLmxhbmVzID0gcmVuZGVyTGFuZXM7XG4gICAgd29ya0luUHJvZ3Jlc3MuY2hpbGQgPSBudWxsO1xuICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkUHJvcHMgPSBudWxsO1xuICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBudWxsO1xuICAgIHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlID0gbnVsbDtcbiAgICB3b3JrSW5Qcm9ncmVzcy5kZXBlbmRlbmNpZXMgPSBudWxsO1xuICAgIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSA9IG51bGw7XG5cbiAgICB7XG4gICAgICAvLyBOb3RlOiBXZSBkb24ndCByZXNldCB0aGUgYWN0dWFsVGltZSBjb3VudHMuIEl0J3MgdXNlZnVsIHRvIGFjY3VtdWxhdGVcbiAgICAgIC8vIGFjdHVhbCB0aW1lIGFjcm9zcyBtdWx0aXBsZSByZW5kZXIgcGFzc2VzLlxuICAgICAgd29ya0luUHJvZ3Jlc3Muc2VsZkJhc2VEdXJhdGlvbiA9IDA7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy50cmVlQmFzZUR1cmF0aW9uID0gMDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gUmVzZXQgdG8gdGhlIGNsb25lZCB2YWx1ZXMgdGhhdCBjcmVhdGVXb3JrSW5Qcm9ncmVzcyB3b3VsZCd2ZS5cbiAgICB3b3JrSW5Qcm9ncmVzcy5jaGlsZExhbmVzID0gY3VycmVudC5jaGlsZExhbmVzO1xuICAgIHdvcmtJblByb2dyZXNzLmxhbmVzID0gY3VycmVudC5sYW5lcztcbiAgICB3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IGN1cnJlbnQuY2hpbGQ7XG4gICAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcyA9IGN1cnJlbnQubWVtb2l6ZWRQcm9wcztcbiAgICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0gY3VycmVudC5tZW1vaXplZFN0YXRlO1xuICAgIHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlID0gY3VycmVudC51cGRhdGVRdWV1ZTsgLy8gTmVlZGVkIGJlY2F1c2UgQmxvY2tzIHN0b3JlIGRhdGEgb24gdHlwZS5cblxuICAgIHdvcmtJblByb2dyZXNzLnR5cGUgPSBjdXJyZW50LnR5cGU7IC8vIENsb25lIHRoZSBkZXBlbmRlbmNpZXMgb2JqZWN0LiBUaGlzIGlzIG11dGF0ZWQgZHVyaW5nIHRoZSByZW5kZXIgcGhhc2UsIHNvXG4gICAgLy8gaXQgY2Fubm90IGJlIHNoYXJlZCB3aXRoIHRoZSBjdXJyZW50IGZpYmVyLlxuXG4gICAgdmFyIGN1cnJlbnREZXBlbmRlbmNpZXMgPSBjdXJyZW50LmRlcGVuZGVuY2llcztcbiAgICB3b3JrSW5Qcm9ncmVzcy5kZXBlbmRlbmNpZXMgPSBjdXJyZW50RGVwZW5kZW5jaWVzID09PSBudWxsID8gbnVsbCA6IHtcbiAgICAgIGxhbmVzOiBjdXJyZW50RGVwZW5kZW5jaWVzLmxhbmVzLFxuICAgICAgZmlyc3RDb250ZXh0OiBjdXJyZW50RGVwZW5kZW5jaWVzLmZpcnN0Q29udGV4dFxuICAgIH07XG5cbiAgICB7XG4gICAgICAvLyBOb3RlOiBXZSBkb24ndCByZXNldCB0aGUgYWN0dWFsVGltZSBjb3VudHMuIEl0J3MgdXNlZnVsIHRvIGFjY3VtdWxhdGVcbiAgICAgIC8vIGFjdHVhbCB0aW1lIGFjcm9zcyBtdWx0aXBsZSByZW5kZXIgcGFzc2VzLlxuICAgICAgd29ya0luUHJvZ3Jlc3Muc2VsZkJhc2VEdXJhdGlvbiA9IGN1cnJlbnQuc2VsZkJhc2VEdXJhdGlvbjtcbiAgICAgIHdvcmtJblByb2dyZXNzLnRyZWVCYXNlRHVyYXRpb24gPSBjdXJyZW50LnRyZWVCYXNlRHVyYXRpb247XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHdvcmtJblByb2dyZXNzO1xufVxuZnVuY3Rpb24gY3JlYXRlSG9zdFJvb3RGaWJlcih0YWcpIHtcbiAgdmFyIG1vZGU7XG5cbiAgaWYgKHRhZyA9PT0gQ29uY3VycmVudFJvb3QpIHtcbiAgICBtb2RlID0gQ29uY3VycmVudE1vZGUgfCBCbG9ja2luZ01vZGUgfCBTdHJpY3RNb2RlO1xuICB9IGVsc2UgaWYgKHRhZyA9PT0gQmxvY2tpbmdSb290KSB7XG4gICAgbW9kZSA9IEJsb2NraW5nTW9kZSB8IFN0cmljdE1vZGU7XG4gIH0gZWxzZSB7XG4gICAgbW9kZSA9IE5vTW9kZTtcbiAgfVxuXG4gIGlmICggaXNEZXZUb29sc1ByZXNlbnQpIHtcbiAgICAvLyBBbHdheXMgY29sbGVjdCBwcm9maWxlIHRpbWluZ3Mgd2hlbiBEZXZUb29scyBhcmUgcHJlc2VudC5cbiAgICAvLyBUaGlzIGVuYWJsZXMgRGV2VG9vbHMgdG8gc3RhcnQgY2FwdHVyaW5nIHRpbWluZyBhdCBhbnkgcG9pbnTigJNcbiAgICAvLyBXaXRob3V0IHNvbWUgbm9kZXMgaW4gdGhlIHRyZWUgaGF2aW5nIGVtcHR5IGJhc2UgdGltZXMuXG4gICAgbW9kZSB8PSBQcm9maWxlTW9kZTtcbiAgfVxuXG4gIHJldHVybiBjcmVhdGVGaWJlcihIb3N0Um9vdCwgbnVsbCwgbnVsbCwgbW9kZSk7XG59XG5mdW5jdGlvbiBjcmVhdGVGaWJlckZyb21UeXBlQW5kUHJvcHModHlwZSwgLy8gUmVhY3QkRWxlbWVudFR5cGVcbmtleSwgcGVuZGluZ1Byb3BzLCBvd25lciwgbW9kZSwgbGFuZXMpIHtcbiAgdmFyIGZpYmVyVGFnID0gSW5kZXRlcm1pbmF0ZUNvbXBvbmVudDsgLy8gVGhlIHJlc29sdmVkIHR5cGUgaXMgc2V0IGlmIHdlIGtub3cgd2hhdCB0aGUgZmluYWwgdHlwZSB3aWxsIGJlLiBJLmUuIGl0J3Mgbm90IGxhenkuXG5cbiAgdmFyIHJlc29sdmVkVHlwZSA9IHR5cGU7XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgaWYgKHNob3VsZENvbnN0cnVjdCQxKHR5cGUpKSB7XG4gICAgICBmaWJlclRhZyA9IENsYXNzQ29tcG9uZW50O1xuXG4gICAgICB7XG4gICAgICAgIHJlc29sdmVkVHlwZSA9IHJlc29sdmVDbGFzc0ZvckhvdFJlbG9hZGluZyhyZXNvbHZlZFR5cGUpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB7XG4gICAgICAgIHJlc29sdmVkVHlwZSA9IHJlc29sdmVGdW5jdGlvbkZvckhvdFJlbG9hZGluZyhyZXNvbHZlZFR5cGUpO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICBmaWJlclRhZyA9IEhvc3RDb21wb25lbnQ7XG4gIH0gZWxzZSB7XG4gICAgZ2V0VGFnOiBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2UgUkVBQ1RfRlJBR01FTlRfVFlQRTpcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUZpYmVyRnJvbUZyYWdtZW50KHBlbmRpbmdQcm9wcy5jaGlsZHJlbiwgbW9kZSwgbGFuZXMsIGtleSk7XG5cbiAgICAgIGNhc2UgUkVBQ1RfREVCVUdfVFJBQ0lOR19NT0RFX1RZUEU6XG4gICAgICAgIGZpYmVyVGFnID0gTW9kZTtcbiAgICAgICAgbW9kZSB8PSBEZWJ1Z1RyYWNpbmdNb2RlO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFOlxuICAgICAgICBmaWJlclRhZyA9IE1vZGU7XG4gICAgICAgIG1vZGUgfD0gU3RyaWN0TW9kZTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgUkVBQ1RfUFJPRklMRVJfVFlQRTpcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUZpYmVyRnJvbVByb2ZpbGVyKHBlbmRpbmdQcm9wcywgbW9kZSwgbGFuZXMsIGtleSk7XG5cbiAgICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfVFlQRTpcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUZpYmVyRnJvbVN1c3BlbnNlKHBlbmRpbmdQcm9wcywgbW9kZSwgbGFuZXMsIGtleSk7XG5cbiAgICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFOlxuICAgICAgICByZXR1cm4gY3JlYXRlRmliZXJGcm9tU3VzcGVuc2VMaXN0KHBlbmRpbmdQcm9wcywgbW9kZSwgbGFuZXMsIGtleSk7XG5cbiAgICAgIGNhc2UgUkVBQ1RfT0ZGU0NSRUVOX1RZUEU6XG4gICAgICAgIHJldHVybiBjcmVhdGVGaWJlckZyb21PZmZzY3JlZW4ocGVuZGluZ1Byb3BzLCBtb2RlLCBsYW5lcywga2V5KTtcblxuICAgICAgY2FzZSBSRUFDVF9MRUdBQ1lfSElEREVOX1RZUEU6XG4gICAgICAgIHJldHVybiBjcmVhdGVGaWJlckZyb21MZWdhY3lIaWRkZW4ocGVuZGluZ1Byb3BzLCBtb2RlLCBsYW5lcywga2V5KTtcblxuICAgICAgY2FzZSBSRUFDVF9TQ09QRV9UWVBFOlxuXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZmFsbHRocm91Z2hcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAge1xuICAgICAgICAgIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgdHlwZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgc3dpdGNoICh0eXBlLiQkdHlwZW9mKSB7XG4gICAgICAgICAgICAgIGNhc2UgUkVBQ1RfUFJPVklERVJfVFlQRTpcbiAgICAgICAgICAgICAgICBmaWJlclRhZyA9IENvbnRleHRQcm92aWRlcjtcbiAgICAgICAgICAgICAgICBicmVhayBnZXRUYWc7XG5cbiAgICAgICAgICAgICAgY2FzZSBSRUFDVF9DT05URVhUX1RZUEU6XG4gICAgICAgICAgICAgICAgLy8gVGhpcyBpcyBhIGNvbnN1bWVyXG4gICAgICAgICAgICAgICAgZmliZXJUYWcgPSBDb250ZXh0Q29uc3VtZXI7XG4gICAgICAgICAgICAgICAgYnJlYWsgZ2V0VGFnO1xuXG4gICAgICAgICAgICAgIGNhc2UgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTpcbiAgICAgICAgICAgICAgICBmaWJlclRhZyA9IEZvcndhcmRSZWY7XG5cbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICByZXNvbHZlZFR5cGUgPSByZXNvbHZlRm9yd2FyZFJlZkZvckhvdFJlbG9hZGluZyhyZXNvbHZlZFR5cGUpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGJyZWFrIGdldFRhZztcblxuICAgICAgICAgICAgICBjYXNlIFJFQUNUX01FTU9fVFlQRTpcbiAgICAgICAgICAgICAgICBmaWJlclRhZyA9IE1lbW9Db21wb25lbnQ7XG4gICAgICAgICAgICAgICAgYnJlYWsgZ2V0VGFnO1xuXG4gICAgICAgICAgICAgIGNhc2UgUkVBQ1RfTEFaWV9UWVBFOlxuICAgICAgICAgICAgICAgIGZpYmVyVGFnID0gTGF6eUNvbXBvbmVudDtcbiAgICAgICAgICAgICAgICByZXNvbHZlZFR5cGUgPSBudWxsO1xuICAgICAgICAgICAgICAgIGJyZWFrIGdldFRhZztcblxuICAgICAgICAgICAgICBjYXNlIFJFQUNUX0JMT0NLX1RZUEU6XG4gICAgICAgICAgICAgICAgZmliZXJUYWcgPSBCbG9jaztcbiAgICAgICAgICAgICAgICBicmVhayBnZXRUYWc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIGluZm8gPSAnJztcblxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlmICh0eXBlID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmIHR5cGUgIT09IG51bGwgJiYgT2JqZWN0LmtleXModHlwZSkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgIGluZm8gKz0gJyBZb3UgbGlrZWx5IGZvcmdvdCB0byBleHBvcnQgeW91ciBjb21wb25lbnQgZnJvbSB0aGUgZmlsZSAnICsgXCJpdCdzIGRlZmluZWQgaW4sIG9yIHlvdSBtaWdodCBoYXZlIG1peGVkIHVwIGRlZmF1bHQgYW5kIFwiICsgJ25hbWVkIGltcG9ydHMuJztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIG93bmVyTmFtZSA9IG93bmVyID8gZ2V0Q29tcG9uZW50TmFtZShvd25lci50eXBlKSA6IG51bGw7XG5cbiAgICAgICAgICAgIGlmIChvd25lck5hbWUpIHtcbiAgICAgICAgICAgICAgaW5mbyArPSAnXFxuXFxuQ2hlY2sgdGhlIHJlbmRlciBtZXRob2Qgb2YgYCcgKyBvd25lck5hbWUgKyAnYC4nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoIFwiRWxlbWVudCB0eXBlIGlzIGludmFsaWQ6IGV4cGVjdGVkIGEgc3RyaW5nIChmb3IgYnVpbHQtaW4gY29tcG9uZW50cykgb3IgYSBjbGFzcy9mdW5jdGlvbiAoZm9yIGNvbXBvc2l0ZSBjb21wb25lbnRzKSBidXQgZ290OiBcIiArICh0eXBlID09IG51bGwgPyB0eXBlIDogdHlwZW9mIHR5cGUpICsgXCIuXCIgKyBpbmZvICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIGZpYmVyID0gY3JlYXRlRmliZXIoZmliZXJUYWcsIHBlbmRpbmdQcm9wcywga2V5LCBtb2RlKTtcbiAgZmliZXIuZWxlbWVudFR5cGUgPSB0eXBlO1xuICBmaWJlci50eXBlID0gcmVzb2x2ZWRUeXBlO1xuICBmaWJlci5sYW5lcyA9IGxhbmVzO1xuXG4gIHtcbiAgICBmaWJlci5fZGVidWdPd25lciA9IG93bmVyO1xuICB9XG5cbiAgcmV0dXJuIGZpYmVyO1xufVxuZnVuY3Rpb24gY3JlYXRlRmliZXJGcm9tRWxlbWVudChlbGVtZW50LCBtb2RlLCBsYW5lcykge1xuICB2YXIgb3duZXIgPSBudWxsO1xuXG4gIHtcbiAgICBvd25lciA9IGVsZW1lbnQuX293bmVyO1xuICB9XG5cbiAgdmFyIHR5cGUgPSBlbGVtZW50LnR5cGU7XG4gIHZhciBrZXkgPSBlbGVtZW50LmtleTtcbiAgdmFyIHBlbmRpbmdQcm9wcyA9IGVsZW1lbnQucHJvcHM7XG4gIHZhciBmaWJlciA9IGNyZWF0ZUZpYmVyRnJvbVR5cGVBbmRQcm9wcyh0eXBlLCBrZXksIHBlbmRpbmdQcm9wcywgb3duZXIsIG1vZGUsIGxhbmVzKTtcblxuICB7XG4gICAgZmliZXIuX2RlYnVnU291cmNlID0gZWxlbWVudC5fc291cmNlO1xuICAgIGZpYmVyLl9kZWJ1Z093bmVyID0gZWxlbWVudC5fb3duZXI7XG4gIH1cblxuICByZXR1cm4gZmliZXI7XG59XG5mdW5jdGlvbiBjcmVhdGVGaWJlckZyb21GcmFnbWVudChlbGVtZW50cywgbW9kZSwgbGFuZXMsIGtleSkge1xuICB2YXIgZmliZXIgPSBjcmVhdGVGaWJlcihGcmFnbWVudCwgZWxlbWVudHMsIGtleSwgbW9kZSk7XG4gIGZpYmVyLmxhbmVzID0gbGFuZXM7XG4gIHJldHVybiBmaWJlcjtcbn1cblxuZnVuY3Rpb24gY3JlYXRlRmliZXJGcm9tUHJvZmlsZXIocGVuZGluZ1Byb3BzLCBtb2RlLCBsYW5lcywga2V5KSB7XG4gIHtcbiAgICBpZiAodHlwZW9mIHBlbmRpbmdQcm9wcy5pZCAhPT0gJ3N0cmluZycpIHtcbiAgICAgIGVycm9yKCdQcm9maWxlciBtdXN0IHNwZWNpZnkgYW4gXCJpZFwiIGFzIGEgcHJvcCcpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBmaWJlciA9IGNyZWF0ZUZpYmVyKFByb2ZpbGVyLCBwZW5kaW5nUHJvcHMsIGtleSwgbW9kZSB8IFByb2ZpbGVNb2RlKTsgLy8gVE9ETzogVGhlIFByb2ZpbGVyIGZpYmVyIHNob3VsZG4ndCBoYXZlIGEgdHlwZS4gSXQgaGFzIGEgdGFnLlxuXG4gIGZpYmVyLmVsZW1lbnRUeXBlID0gUkVBQ1RfUFJPRklMRVJfVFlQRTtcbiAgZmliZXIudHlwZSA9IFJFQUNUX1BST0ZJTEVSX1RZUEU7XG4gIGZpYmVyLmxhbmVzID0gbGFuZXM7XG5cbiAge1xuICAgIGZpYmVyLnN0YXRlTm9kZSA9IHtcbiAgICAgIGVmZmVjdER1cmF0aW9uOiAwLFxuICAgICAgcGFzc2l2ZUVmZmVjdER1cmF0aW9uOiAwXG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBmaWJlcjtcbn1cblxuZnVuY3Rpb24gY3JlYXRlRmliZXJGcm9tU3VzcGVuc2UocGVuZGluZ1Byb3BzLCBtb2RlLCBsYW5lcywga2V5KSB7XG4gIHZhciBmaWJlciA9IGNyZWF0ZUZpYmVyKFN1c3BlbnNlQ29tcG9uZW50LCBwZW5kaW5nUHJvcHMsIGtleSwgbW9kZSk7IC8vIFRPRE86IFRoZSBTdXNwZW5zZUNvbXBvbmVudCBmaWJlciBzaG91bGRuJ3QgaGF2ZSBhIHR5cGUuIEl0IGhhcyBhIHRhZy5cbiAgLy8gVGhpcyBuZWVkcyB0byBiZSBmaXhlZCBpbiBnZXRDb21wb25lbnROYW1lIHNvIHRoYXQgaXQgcmVsaWVzIG9uIHRoZSB0YWdcbiAgLy8gaW5zdGVhZC5cblxuICBmaWJlci50eXBlID0gUkVBQ1RfU1VTUEVOU0VfVFlQRTtcbiAgZmliZXIuZWxlbWVudFR5cGUgPSBSRUFDVF9TVVNQRU5TRV9UWVBFO1xuICBmaWJlci5sYW5lcyA9IGxhbmVzO1xuICByZXR1cm4gZmliZXI7XG59XG5mdW5jdGlvbiBjcmVhdGVGaWJlckZyb21TdXNwZW5zZUxpc3QocGVuZGluZ1Byb3BzLCBtb2RlLCBsYW5lcywga2V5KSB7XG4gIHZhciBmaWJlciA9IGNyZWF0ZUZpYmVyKFN1c3BlbnNlTGlzdENvbXBvbmVudCwgcGVuZGluZ1Byb3BzLCBrZXksIG1vZGUpO1xuXG4gIHtcbiAgICAvLyBUT0RPOiBUaGUgU3VzcGVuc2VMaXN0Q29tcG9uZW50IGZpYmVyIHNob3VsZG4ndCBoYXZlIGEgdHlwZS4gSXQgaGFzIGEgdGFnLlxuICAgIC8vIFRoaXMgbmVlZHMgdG8gYmUgZml4ZWQgaW4gZ2V0Q29tcG9uZW50TmFtZSBzbyB0aGF0IGl0IHJlbGllcyBvbiB0aGUgdGFnXG4gICAgLy8gaW5zdGVhZC5cbiAgICBmaWJlci50eXBlID0gUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFO1xuICB9XG5cbiAgZmliZXIuZWxlbWVudFR5cGUgPSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEU7XG4gIGZpYmVyLmxhbmVzID0gbGFuZXM7XG4gIHJldHVybiBmaWJlcjtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUZpYmVyRnJvbU9mZnNjcmVlbihwZW5kaW5nUHJvcHMsIG1vZGUsIGxhbmVzLCBrZXkpIHtcbiAgdmFyIGZpYmVyID0gY3JlYXRlRmliZXIoT2Zmc2NyZWVuQ29tcG9uZW50LCBwZW5kaW5nUHJvcHMsIGtleSwgbW9kZSk7IC8vIFRPRE86IFRoZSBPZmZzY3JlZW5Db21wb25lbnQgZmliZXIgc2hvdWxkbid0IGhhdmUgYSB0eXBlLiBJdCBoYXMgYSB0YWcuXG4gIC8vIFRoaXMgbmVlZHMgdG8gYmUgZml4ZWQgaW4gZ2V0Q29tcG9uZW50TmFtZSBzbyB0aGF0IGl0IHJlbGllcyBvbiB0aGUgdGFnXG4gIC8vIGluc3RlYWQuXG5cbiAge1xuICAgIGZpYmVyLnR5cGUgPSBSRUFDVF9PRkZTQ1JFRU5fVFlQRTtcbiAgfVxuXG4gIGZpYmVyLmVsZW1lbnRUeXBlID0gUkVBQ1RfT0ZGU0NSRUVOX1RZUEU7XG4gIGZpYmVyLmxhbmVzID0gbGFuZXM7XG4gIHJldHVybiBmaWJlcjtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUZpYmVyRnJvbUxlZ2FjeUhpZGRlbihwZW5kaW5nUHJvcHMsIG1vZGUsIGxhbmVzLCBrZXkpIHtcbiAgdmFyIGZpYmVyID0gY3JlYXRlRmliZXIoTGVnYWN5SGlkZGVuQ29tcG9uZW50LCBwZW5kaW5nUHJvcHMsIGtleSwgbW9kZSk7IC8vIFRPRE86IFRoZSBMZWdhY3lIaWRkZW4gZmliZXIgc2hvdWxkbid0IGhhdmUgYSB0eXBlLiBJdCBoYXMgYSB0YWcuXG4gIC8vIFRoaXMgbmVlZHMgdG8gYmUgZml4ZWQgaW4gZ2V0Q29tcG9uZW50TmFtZSBzbyB0aGF0IGl0IHJlbGllcyBvbiB0aGUgdGFnXG4gIC8vIGluc3RlYWQuXG5cbiAge1xuICAgIGZpYmVyLnR5cGUgPSBSRUFDVF9MRUdBQ1lfSElEREVOX1RZUEU7XG4gIH1cblxuICBmaWJlci5lbGVtZW50VHlwZSA9IFJFQUNUX0xFR0FDWV9ISURERU5fVFlQRTtcbiAgZmliZXIubGFuZXMgPSBsYW5lcztcbiAgcmV0dXJuIGZpYmVyO1xufVxuZnVuY3Rpb24gY3JlYXRlRmliZXJGcm9tVGV4dChjb250ZW50LCBtb2RlLCBsYW5lcykge1xuICB2YXIgZmliZXIgPSBjcmVhdGVGaWJlcihIb3N0VGV4dCwgY29udGVudCwgbnVsbCwgbW9kZSk7XG4gIGZpYmVyLmxhbmVzID0gbGFuZXM7XG4gIHJldHVybiBmaWJlcjtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUZpYmVyRnJvbUhvc3RJbnN0YW5jZUZvckRlbGV0aW9uKCkge1xuICB2YXIgZmliZXIgPSBjcmVhdGVGaWJlcihIb3N0Q29tcG9uZW50LCBudWxsLCBudWxsLCBOb01vZGUpOyAvLyBUT0RPOiBUaGVzZSBzaG91bGQgbm90IG5lZWQgYSB0eXBlLlxuXG4gIGZpYmVyLmVsZW1lbnRUeXBlID0gJ0RFTEVURUQnO1xuICBmaWJlci50eXBlID0gJ0RFTEVURUQnO1xuICByZXR1cm4gZmliZXI7XG59XG5mdW5jdGlvbiBjcmVhdGVGaWJlckZyb21Qb3J0YWwocG9ydGFsLCBtb2RlLCBsYW5lcykge1xuICB2YXIgcGVuZGluZ1Byb3BzID0gcG9ydGFsLmNoaWxkcmVuICE9PSBudWxsID8gcG9ydGFsLmNoaWxkcmVuIDogW107XG4gIHZhciBmaWJlciA9IGNyZWF0ZUZpYmVyKEhvc3RQb3J0YWwsIHBlbmRpbmdQcm9wcywgcG9ydGFsLmtleSwgbW9kZSk7XG4gIGZpYmVyLmxhbmVzID0gbGFuZXM7XG4gIGZpYmVyLnN0YXRlTm9kZSA9IHtcbiAgICBjb250YWluZXJJbmZvOiBwb3J0YWwuY29udGFpbmVySW5mbyxcbiAgICBwZW5kaW5nQ2hpbGRyZW46IG51bGwsXG4gICAgLy8gVXNlZCBieSBwZXJzaXN0ZW50IHVwZGF0ZXNcbiAgICBpbXBsZW1lbnRhdGlvbjogcG9ydGFsLmltcGxlbWVudGF0aW9uXG4gIH07XG4gIHJldHVybiBmaWJlcjtcbn0gLy8gVXNlZCBmb3Igc3Rhc2hpbmcgV0lQIHByb3BlcnRpZXMgdG8gcmVwbGF5IGZhaWxlZCB3b3JrIGluIERFVi5cblxuZnVuY3Rpb24gYXNzaWduRmliZXJQcm9wZXJ0aWVzSW5ERVYodGFyZ2V0LCBzb3VyY2UpIHtcbiAgaWYgKHRhcmdldCA9PT0gbnVsbCkge1xuICAgIC8vIFRoaXMgRmliZXIncyBpbml0aWFsIHByb3BlcnRpZXMgd2lsbCBhbHdheXMgYmUgb3ZlcndyaXR0ZW4uXG4gICAgLy8gV2Ugb25seSB1c2UgYSBGaWJlciB0byBlbnN1cmUgdGhlIHNhbWUgaGlkZGVuIGNsYXNzIHNvIERFViBpc24ndCBzbG93LlxuICAgIHRhcmdldCA9IGNyZWF0ZUZpYmVyKEluZGV0ZXJtaW5hdGVDb21wb25lbnQsIG51bGwsIG51bGwsIE5vTW9kZSk7XG4gIH0gLy8gVGhpcyBpcyBpbnRlbnRpb25hbGx5IHdyaXR0ZW4gYXMgYSBsaXN0IG9mIGFsbCBwcm9wZXJ0aWVzLlxuICAvLyBXZSB0cmllZCB0byB1c2UgT2JqZWN0LmFzc2lnbigpIGluc3RlYWQgYnV0IHRoaXMgaXMgY2FsbGVkIGluXG4gIC8vIHRoZSBob3R0ZXN0IHBhdGgsIGFuZCBPYmplY3QuYXNzaWduKCkgd2FzIHRvbyBzbG93OlxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzEyNTAyXG4gIC8vIFRoaXMgY29kZSBpcyBERVYtb25seSBzbyBzaXplIGlzIG5vdCBhIGNvbmNlcm4uXG5cblxuICB0YXJnZXQudGFnID0gc291cmNlLnRhZztcbiAgdGFyZ2V0LmtleSA9IHNvdXJjZS5rZXk7XG4gIHRhcmdldC5lbGVtZW50VHlwZSA9IHNvdXJjZS5lbGVtZW50VHlwZTtcbiAgdGFyZ2V0LnR5cGUgPSBzb3VyY2UudHlwZTtcbiAgdGFyZ2V0LnN0YXRlTm9kZSA9IHNvdXJjZS5zdGF0ZU5vZGU7XG4gIHRhcmdldC5yZXR1cm4gPSBzb3VyY2UucmV0dXJuO1xuICB0YXJnZXQuY2hpbGQgPSBzb3VyY2UuY2hpbGQ7XG4gIHRhcmdldC5zaWJsaW5nID0gc291cmNlLnNpYmxpbmc7XG4gIHRhcmdldC5pbmRleCA9IHNvdXJjZS5pbmRleDtcbiAgdGFyZ2V0LnJlZiA9IHNvdXJjZS5yZWY7XG4gIHRhcmdldC5wZW5kaW5nUHJvcHMgPSBzb3VyY2UucGVuZGluZ1Byb3BzO1xuICB0YXJnZXQubWVtb2l6ZWRQcm9wcyA9IHNvdXJjZS5tZW1vaXplZFByb3BzO1xuICB0YXJnZXQudXBkYXRlUXVldWUgPSBzb3VyY2UudXBkYXRlUXVldWU7XG4gIHRhcmdldC5tZW1vaXplZFN0YXRlID0gc291cmNlLm1lbW9pemVkU3RhdGU7XG4gIHRhcmdldC5kZXBlbmRlbmNpZXMgPSBzb3VyY2UuZGVwZW5kZW5jaWVzO1xuICB0YXJnZXQubW9kZSA9IHNvdXJjZS5tb2RlO1xuICB0YXJnZXQuZmxhZ3MgPSBzb3VyY2UuZmxhZ3M7XG4gIHRhcmdldC5uZXh0RWZmZWN0ID0gc291cmNlLm5leHRFZmZlY3Q7XG4gIHRhcmdldC5maXJzdEVmZmVjdCA9IHNvdXJjZS5maXJzdEVmZmVjdDtcbiAgdGFyZ2V0Lmxhc3RFZmZlY3QgPSBzb3VyY2UubGFzdEVmZmVjdDtcbiAgdGFyZ2V0LmxhbmVzID0gc291cmNlLmxhbmVzO1xuICB0YXJnZXQuY2hpbGRMYW5lcyA9IHNvdXJjZS5jaGlsZExhbmVzO1xuICB0YXJnZXQuYWx0ZXJuYXRlID0gc291cmNlLmFsdGVybmF0ZTtcblxuICB7XG4gICAgdGFyZ2V0LmFjdHVhbER1cmF0aW9uID0gc291cmNlLmFjdHVhbER1cmF0aW9uO1xuICAgIHRhcmdldC5hY3R1YWxTdGFydFRpbWUgPSBzb3VyY2UuYWN0dWFsU3RhcnRUaW1lO1xuICAgIHRhcmdldC5zZWxmQmFzZUR1cmF0aW9uID0gc291cmNlLnNlbGZCYXNlRHVyYXRpb247XG4gICAgdGFyZ2V0LnRyZWVCYXNlRHVyYXRpb24gPSBzb3VyY2UudHJlZUJhc2VEdXJhdGlvbjtcbiAgfVxuXG4gIHRhcmdldC5fZGVidWdJRCA9IHNvdXJjZS5fZGVidWdJRDtcbiAgdGFyZ2V0Ll9kZWJ1Z1NvdXJjZSA9IHNvdXJjZS5fZGVidWdTb3VyY2U7XG4gIHRhcmdldC5fZGVidWdPd25lciA9IHNvdXJjZS5fZGVidWdPd25lcjtcbiAgdGFyZ2V0Ll9kZWJ1Z05lZWRzUmVtb3VudCA9IHNvdXJjZS5fZGVidWdOZWVkc1JlbW91bnQ7XG4gIHRhcmdldC5fZGVidWdIb29rVHlwZXMgPSBzb3VyY2UuX2RlYnVnSG9va1R5cGVzO1xuICByZXR1cm4gdGFyZ2V0O1xufVxuXG5mdW5jdGlvbiBGaWJlclJvb3ROb2RlKGNvbnRhaW5lckluZm8sIHRhZywgaHlkcmF0ZSkge1xuICB0aGlzLnRhZyA9IHRhZztcbiAgdGhpcy5jb250YWluZXJJbmZvID0gY29udGFpbmVySW5mbztcbiAgdGhpcy5wZW5kaW5nQ2hpbGRyZW4gPSBudWxsO1xuICB0aGlzLmN1cnJlbnQgPSBudWxsO1xuICB0aGlzLnBpbmdDYWNoZSA9IG51bGw7XG4gIHRoaXMuZmluaXNoZWRXb3JrID0gbnVsbDtcbiAgdGhpcy50aW1lb3V0SGFuZGxlID0gbm9UaW1lb3V0O1xuICB0aGlzLmNvbnRleHQgPSBudWxsO1xuICB0aGlzLnBlbmRpbmdDb250ZXh0ID0gbnVsbDtcbiAgdGhpcy5oeWRyYXRlID0gaHlkcmF0ZTtcbiAgdGhpcy5jYWxsYmFja05vZGUgPSBudWxsO1xuICB0aGlzLmNhbGxiYWNrUHJpb3JpdHkgPSBOb0xhbmVQcmlvcml0eTtcbiAgdGhpcy5ldmVudFRpbWVzID0gY3JlYXRlTGFuZU1hcChOb0xhbmVzKTtcbiAgdGhpcy5leHBpcmF0aW9uVGltZXMgPSBjcmVhdGVMYW5lTWFwKE5vVGltZXN0YW1wKTtcbiAgdGhpcy5wZW5kaW5nTGFuZXMgPSBOb0xhbmVzO1xuICB0aGlzLnN1c3BlbmRlZExhbmVzID0gTm9MYW5lcztcbiAgdGhpcy5waW5nZWRMYW5lcyA9IE5vTGFuZXM7XG4gIHRoaXMuZXhwaXJlZExhbmVzID0gTm9MYW5lcztcbiAgdGhpcy5tdXRhYmxlUmVhZExhbmVzID0gTm9MYW5lcztcbiAgdGhpcy5maW5pc2hlZExhbmVzID0gTm9MYW5lcztcbiAgdGhpcy5lbnRhbmdsZWRMYW5lcyA9IE5vTGFuZXM7XG4gIHRoaXMuZW50YW5nbGVtZW50cyA9IGNyZWF0ZUxhbmVNYXAoTm9MYW5lcyk7XG5cbiAge1xuICAgIHRoaXMubXV0YWJsZVNvdXJjZUVhZ2VySHlkcmF0aW9uRGF0YSA9IG51bGw7XG4gIH1cblxuICB7XG4gICAgdGhpcy5pbnRlcmFjdGlvblRocmVhZElEID0gdHJhY2luZy51bnN0YWJsZV9nZXRUaHJlYWRJRCgpO1xuICAgIHRoaXMubWVtb2l6ZWRJbnRlcmFjdGlvbnMgPSBuZXcgU2V0KCk7XG4gICAgdGhpcy5wZW5kaW5nSW50ZXJhY3Rpb25NYXAgPSBuZXcgTWFwKCk7XG4gIH1cblxuICB7XG4gICAgc3dpdGNoICh0YWcpIHtcbiAgICAgIGNhc2UgQmxvY2tpbmdSb290OlxuICAgICAgICB0aGlzLl9kZWJ1Z1Jvb3RUeXBlID0gJ2NyZWF0ZUJsb2NraW5nUm9vdCgpJztcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgQ29uY3VycmVudFJvb3Q6XG4gICAgICAgIHRoaXMuX2RlYnVnUm9vdFR5cGUgPSAnY3JlYXRlUm9vdCgpJztcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgTGVnYWN5Um9vdDpcbiAgICAgICAgdGhpcy5fZGVidWdSb290VHlwZSA9ICdjcmVhdGVMZWdhY3lSb290KCknO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlRmliZXJSb290KGNvbnRhaW5lckluZm8sIHRhZywgaHlkcmF0ZSwgaHlkcmF0aW9uQ2FsbGJhY2tzKSB7XG4gIHZhciByb290ID0gbmV3IEZpYmVyUm9vdE5vZGUoY29udGFpbmVySW5mbywgdGFnLCBoeWRyYXRlKTtcbiAgLy8gc3RhdGVOb2RlIGlzIGFueS5cblxuXG4gIHZhciB1bmluaXRpYWxpemVkRmliZXIgPSBjcmVhdGVIb3N0Um9vdEZpYmVyKHRhZyk7XG4gIHJvb3QuY3VycmVudCA9IHVuaW5pdGlhbGl6ZWRGaWJlcjtcbiAgdW5pbml0aWFsaXplZEZpYmVyLnN0YXRlTm9kZSA9IHJvb3Q7XG4gIGluaXRpYWxpemVVcGRhdGVRdWV1ZSh1bmluaXRpYWxpemVkRmliZXIpO1xuICByZXR1cm4gcm9vdDtcbn1cblxuLy8gVGhpcyBlbnN1cmVzIHRoYXQgdGhlIHZlcnNpb24gdXNlZCBmb3Igc2VydmVyIHJlbmRlcmluZyBtYXRjaGVzIHRoZSBvbmVcbi8vIHRoYXQgaXMgZXZlbnR1YWxseSByZWFkIGR1cmluZyBoeWRyYXRpb24uXG4vLyBJZiB0aGV5IGRvbid0IG1hdGNoIHRoZXJlJ3MgYSBwb3RlbnRpYWwgdGVhciBhbmQgYSBmdWxsIGRlb3B0IHJlbmRlciBpcyByZXF1aXJlZC5cblxuZnVuY3Rpb24gcmVnaXN0ZXJNdXRhYmxlU291cmNlRm9ySHlkcmF0aW9uKHJvb3QsIG11dGFibGVTb3VyY2UpIHtcbiAgdmFyIGdldFZlcnNpb24gPSBtdXRhYmxlU291cmNlLl9nZXRWZXJzaW9uO1xuICB2YXIgdmVyc2lvbiA9IGdldFZlcnNpb24obXV0YWJsZVNvdXJjZS5fc291cmNlKTsgLy8gVE9ETyBDbGVhciB0aGlzIGRhdGEgb25jZSBhbGwgcGVuZGluZyBoeWRyYXRpb24gd29yayBpcyBmaW5pc2hlZC5cbiAgLy8gUmV0YWluaW5nIGl0IGZvcmV2ZXIgbWF5IGludGVyZmVyZSB3aXRoIEdDLlxuXG4gIGlmIChyb290Lm11dGFibGVTb3VyY2VFYWdlckh5ZHJhdGlvbkRhdGEgPT0gbnVsbCkge1xuICAgIHJvb3QubXV0YWJsZVNvdXJjZUVhZ2VySHlkcmF0aW9uRGF0YSA9IFttdXRhYmxlU291cmNlLCB2ZXJzaW9uXTtcbiAgfSBlbHNlIHtcbiAgICByb290Lm11dGFibGVTb3VyY2VFYWdlckh5ZHJhdGlvbkRhdGEucHVzaChtdXRhYmxlU291cmNlLCB2ZXJzaW9uKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVQb3J0YWwoY2hpbGRyZW4sIGNvbnRhaW5lckluZm8sIC8vIFRPRE86IGZpZ3VyZSBvdXQgdGhlIEFQSSBmb3IgY3Jvc3MtcmVuZGVyZXIgaW1wbGVtZW50YXRpb24uXG5pbXBsZW1lbnRhdGlvbikge1xuICB2YXIga2V5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiBudWxsO1xuICByZXR1cm4ge1xuICAgIC8vIFRoaXMgdGFnIGFsbG93IHVzIHRvIHVuaXF1ZWx5IGlkZW50aWZ5IHRoaXMgYXMgYSBSZWFjdCBQb3J0YWxcbiAgICAkJHR5cGVvZjogUkVBQ1RfUE9SVEFMX1RZUEUsXG4gICAga2V5OiBrZXkgPT0gbnVsbCA/IG51bGwgOiAnJyArIGtleSxcbiAgICBjaGlsZHJlbjogY2hpbGRyZW4sXG4gICAgY29udGFpbmVySW5mbzogY29udGFpbmVySW5mbyxcbiAgICBpbXBsZW1lbnRhdGlvbjogaW1wbGVtZW50YXRpb25cbiAgfTtcbn1cblxudmFyIGRpZFdhcm5BYm91dE5lc3RlZFVwZGF0ZXM7XG52YXIgZGlkV2FybkFib3V0RmluZE5vZGVJblN0cmljdE1vZGU7XG5cbntcbiAgZGlkV2FybkFib3V0TmVzdGVkVXBkYXRlcyA9IGZhbHNlO1xuICBkaWRXYXJuQWJvdXRGaW5kTm9kZUluU3RyaWN0TW9kZSA9IHt9O1xufVxuXG5mdW5jdGlvbiBnZXRDb250ZXh0Rm9yU3VidHJlZShwYXJlbnRDb21wb25lbnQpIHtcbiAgaWYgKCFwYXJlbnRDb21wb25lbnQpIHtcbiAgICByZXR1cm4gZW1wdHlDb250ZXh0T2JqZWN0O1xuICB9XG5cbiAgdmFyIGZpYmVyID0gZ2V0KHBhcmVudENvbXBvbmVudCk7XG4gIHZhciBwYXJlbnRDb250ZXh0ID0gZmluZEN1cnJlbnRVbm1hc2tlZENvbnRleHQoZmliZXIpO1xuXG4gIGlmIChmaWJlci50YWcgPT09IENsYXNzQ29tcG9uZW50KSB7XG4gICAgdmFyIENvbXBvbmVudCA9IGZpYmVyLnR5cGU7XG5cbiAgICBpZiAoaXNDb250ZXh0UHJvdmlkZXIoQ29tcG9uZW50KSkge1xuICAgICAgcmV0dXJuIHByb2Nlc3NDaGlsZENvbnRleHQoZmliZXIsIENvbXBvbmVudCwgcGFyZW50Q29udGV4dCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHBhcmVudENvbnRleHQ7XG59XG5cbmZ1bmN0aW9uIGZpbmRIb3N0SW5zdGFuY2VXaXRoV2FybmluZyhjb21wb25lbnQsIG1ldGhvZE5hbWUpIHtcbiAge1xuICAgIHZhciBmaWJlciA9IGdldChjb21wb25lbnQpO1xuXG4gICAgaWYgKGZpYmVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmICh0eXBlb2YgY29tcG9uZW50LnJlbmRlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB7XG4gICAgICAgICAge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoIFwiVW5hYmxlIHRvIGZpbmQgbm9kZSBvbiBhbiB1bm1vdW50ZWQgY29tcG9uZW50LlwiICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB7XG4gICAgICAgICAge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoIFwiQXJndW1lbnQgYXBwZWFycyB0byBub3QgYmUgYSBSZWFjdENvbXBvbmVudC4gS2V5czogXCIgKyBPYmplY3Qua2V5cyhjb21wb25lbnQpICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGhvc3RGaWJlciA9IGZpbmRDdXJyZW50SG9zdEZpYmVyKGZpYmVyKTtcblxuICAgIGlmIChob3N0RmliZXIgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGlmIChob3N0RmliZXIubW9kZSAmIFN0cmljdE1vZGUpIHtcbiAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZShmaWJlci50eXBlKSB8fCAnQ29tcG9uZW50JztcblxuICAgICAgaWYgKCFkaWRXYXJuQWJvdXRGaW5kTm9kZUluU3RyaWN0TW9kZVtjb21wb25lbnROYW1lXSkge1xuICAgICAgICBkaWRXYXJuQWJvdXRGaW5kTm9kZUluU3RyaWN0TW9kZVtjb21wb25lbnROYW1lXSA9IHRydWU7XG4gICAgICAgIHZhciBwcmV2aW91c0ZpYmVyID0gY3VycmVudDtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgIHNldEN1cnJlbnRGaWJlcihob3N0RmliZXIpO1xuXG4gICAgICAgICAgaWYgKGZpYmVyLm1vZGUgJiBTdHJpY3RNb2RlKSB7XG4gICAgICAgICAgICBlcnJvcignJXMgaXMgZGVwcmVjYXRlZCBpbiBTdHJpY3RNb2RlLiAnICsgJyVzIHdhcyBwYXNzZWQgYW4gaW5zdGFuY2Ugb2YgJXMgd2hpY2ggaXMgaW5zaWRlIFN0cmljdE1vZGUuICcgKyAnSW5zdGVhZCwgYWRkIGEgcmVmIGRpcmVjdGx5IHRvIHRoZSBlbGVtZW50IHlvdSB3YW50IHRvIHJlZmVyZW5jZS4gJyArICdMZWFybiBtb3JlIGFib3V0IHVzaW5nIHJlZnMgc2FmZWx5IGhlcmU6ICcgKyAnaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3N0cmljdC1tb2RlLWZpbmQtbm9kZScsIG1ldGhvZE5hbWUsIG1ldGhvZE5hbWUsIGNvbXBvbmVudE5hbWUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlcnJvcignJXMgaXMgZGVwcmVjYXRlZCBpbiBTdHJpY3RNb2RlLiAnICsgJyVzIHdhcyBwYXNzZWQgYW4gaW5zdGFuY2Ugb2YgJXMgd2hpY2ggcmVuZGVycyBTdHJpY3RNb2RlIGNoaWxkcmVuLiAnICsgJ0luc3RlYWQsIGFkZCBhIHJlZiBkaXJlY3RseSB0byB0aGUgZWxlbWVudCB5b3Ugd2FudCB0byByZWZlcmVuY2UuICcgKyAnTGVhcm4gbW9yZSBhYm91dCB1c2luZyByZWZzIHNhZmVseSBoZXJlOiAnICsgJ2h0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zdHJpY3QtbW9kZS1maW5kLW5vZGUnLCBtZXRob2ROYW1lLCBtZXRob2ROYW1lLCBjb21wb25lbnROYW1lKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgLy8gSWRlYWxseSB0aGlzIHNob3VsZCByZXNldCB0byBwcmV2aW91cyBidXQgdGhpcyBzaG91bGRuJ3QgYmUgY2FsbGVkIGluXG4gICAgICAgICAgLy8gcmVuZGVyIGFuZCB0aGVyZSdzIGFub3RoZXIgd2FybmluZyBmb3IgdGhhdCBhbnl3YXkuXG4gICAgICAgICAgaWYgKHByZXZpb3VzRmliZXIpIHtcbiAgICAgICAgICAgIHNldEN1cnJlbnRGaWJlcihwcmV2aW91c0ZpYmVyKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzZXRDdXJyZW50RmliZXIoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gaG9zdEZpYmVyLnN0YXRlTm9kZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVDb250YWluZXIoY29udGFpbmVySW5mbywgdGFnLCBoeWRyYXRlLCBoeWRyYXRpb25DYWxsYmFja3MpIHtcbiAgcmV0dXJuIGNyZWF0ZUZpYmVyUm9vdChjb250YWluZXJJbmZvLCB0YWcsIGh5ZHJhdGUpO1xufVxuZnVuY3Rpb24gdXBkYXRlQ29udGFpbmVyKGVsZW1lbnQsIGNvbnRhaW5lciwgcGFyZW50Q29tcG9uZW50LCBjYWxsYmFjaykge1xuICB7XG4gICAgb25TY2hlZHVsZVJvb3QoY29udGFpbmVyLCBlbGVtZW50KTtcbiAgfVxuXG4gIHZhciBjdXJyZW50JDEgPSBjb250YWluZXIuY3VycmVudDtcbiAgdmFyIGV2ZW50VGltZSA9IHJlcXVlc3RFdmVudFRpbWUoKTtcblxuICB7XG4gICAgLy8gJEZsb3dFeHBlY3RlZEVycm9yIC0gamVzdCBpc24ndCBhIGdsb2JhbCwgYW5kIGlzbid0IHJlY29nbml6ZWQgb3V0c2lkZSBvZiB0ZXN0c1xuICAgIGlmICgndW5kZWZpbmVkJyAhPT0gdHlwZW9mIGplc3QpIHtcbiAgICAgIHdhcm5JZlVubW9ja2VkU2NoZWR1bGVyKGN1cnJlbnQkMSk7XG4gICAgICB3YXJuSWZOb3RTY29wZWRXaXRoTWF0Y2hpbmdBY3QoY3VycmVudCQxKTtcbiAgICB9XG4gIH1cblxuICB2YXIgbGFuZSA9IHJlcXVlc3RVcGRhdGVMYW5lKGN1cnJlbnQkMSk7XG5cbiAgdmFyIGNvbnRleHQgPSBnZXRDb250ZXh0Rm9yU3VidHJlZShwYXJlbnRDb21wb25lbnQpO1xuXG4gIGlmIChjb250YWluZXIuY29udGV4dCA9PT0gbnVsbCkge1xuICAgIGNvbnRhaW5lci5jb250ZXh0ID0gY29udGV4dDtcbiAgfSBlbHNlIHtcbiAgICBjb250YWluZXIucGVuZGluZ0NvbnRleHQgPSBjb250ZXh0O1xuICB9XG5cbiAge1xuICAgIGlmIChpc1JlbmRlcmluZyAmJiBjdXJyZW50ICE9PSBudWxsICYmICFkaWRXYXJuQWJvdXROZXN0ZWRVcGRhdGVzKSB7XG4gICAgICBkaWRXYXJuQWJvdXROZXN0ZWRVcGRhdGVzID0gdHJ1ZTtcblxuICAgICAgZXJyb3IoJ1JlbmRlciBtZXRob2RzIHNob3VsZCBiZSBhIHB1cmUgZnVuY3Rpb24gb2YgcHJvcHMgYW5kIHN0YXRlOyAnICsgJ3RyaWdnZXJpbmcgbmVzdGVkIGNvbXBvbmVudCB1cGRhdGVzIGZyb20gcmVuZGVyIGlzIG5vdCBhbGxvd2VkLiAnICsgJ0lmIG5lY2Vzc2FyeSwgdHJpZ2dlciBuZXN0ZWQgdXBkYXRlcyBpbiBjb21wb25lbnREaWRVcGRhdGUuXFxuXFxuJyArICdDaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiAlcy4nLCBnZXRDb21wb25lbnROYW1lKGN1cnJlbnQudHlwZSkgfHwgJ1Vua25vd24nKTtcbiAgICB9XG4gIH1cblxuICB2YXIgdXBkYXRlID0gY3JlYXRlVXBkYXRlKGV2ZW50VGltZSwgbGFuZSk7IC8vIENhdXRpb246IFJlYWN0IERldlRvb2xzIGN1cnJlbnRseSBkZXBlbmRzIG9uIHRoaXMgcHJvcGVydHlcbiAgLy8gYmVpbmcgY2FsbGVkIFwiZWxlbWVudFwiLlxuXG4gIHVwZGF0ZS5wYXlsb2FkID0ge1xuICAgIGVsZW1lbnQ6IGVsZW1lbnRcbiAgfTtcbiAgY2FsbGJhY2sgPSBjYWxsYmFjayA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGNhbGxiYWNrO1xuXG4gIGlmIChjYWxsYmFjayAhPT0gbnVsbCkge1xuICAgIHtcbiAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgZXJyb3IoJ3JlbmRlciguLi4pOiBFeHBlY3RlZCB0aGUgbGFzdCBvcHRpb25hbCBgY2FsbGJhY2tgIGFyZ3VtZW50IHRvIGJlIGEgJyArICdmdW5jdGlvbi4gSW5zdGVhZCByZWNlaXZlZDogJXMuJywgY2FsbGJhY2spO1xuICAgICAgfVxuICAgIH1cblxuICAgIHVwZGF0ZS5jYWxsYmFjayA9IGNhbGxiYWNrO1xuICB9XG5cbiAgZW5xdWV1ZVVwZGF0ZShjdXJyZW50JDEsIHVwZGF0ZSk7XG4gIHNjaGVkdWxlVXBkYXRlT25GaWJlcihjdXJyZW50JDEsIGxhbmUsIGV2ZW50VGltZSk7XG4gIHJldHVybiBsYW5lO1xufVxuZnVuY3Rpb24gZ2V0UHVibGljUm9vdEluc3RhbmNlKGNvbnRhaW5lcikge1xuICB2YXIgY29udGFpbmVyRmliZXIgPSBjb250YWluZXIuY3VycmVudDtcblxuICBpZiAoIWNvbnRhaW5lckZpYmVyLmNoaWxkKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBzd2l0Y2ggKGNvbnRhaW5lckZpYmVyLmNoaWxkLnRhZykge1xuICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgIHJldHVybiBnZXRQdWJsaWNJbnN0YW5jZShjb250YWluZXJGaWJlci5jaGlsZC5zdGF0ZU5vZGUpO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBjb250YWluZXJGaWJlci5jaGlsZC5zdGF0ZU5vZGU7XG4gIH1cbn1cblxuZnVuY3Rpb24gbWFya1JldHJ5TGFuZUltcGwoZmliZXIsIHJldHJ5TGFuZSkge1xuICB2YXIgc3VzcGVuc2VTdGF0ZSA9IGZpYmVyLm1lbW9pemVkU3RhdGU7XG5cbiAgaWYgKHN1c3BlbnNlU3RhdGUgIT09IG51bGwgJiYgc3VzcGVuc2VTdGF0ZS5kZWh5ZHJhdGVkICE9PSBudWxsKSB7XG4gICAgc3VzcGVuc2VTdGF0ZS5yZXRyeUxhbmUgPSBoaWdoZXJQcmlvcml0eUxhbmUoc3VzcGVuc2VTdGF0ZS5yZXRyeUxhbmUsIHJldHJ5TGFuZSk7XG4gIH1cbn0gLy8gSW5jcmVhc2VzIHRoZSBwcmlvcml0eSBvZiB0aGVubmFibGVzIHdoZW4gdGhleSByZXNvbHZlIHdpdGhpbiB0aGlzIGJvdW5kYXJ5LlxuXG5cbmZ1bmN0aW9uIG1hcmtSZXRyeUxhbmVJZk5vdEh5ZHJhdGVkKGZpYmVyLCByZXRyeUxhbmUpIHtcbiAgbWFya1JldHJ5TGFuZUltcGwoZmliZXIsIHJldHJ5TGFuZSk7XG4gIHZhciBhbHRlcm5hdGUgPSBmaWJlci5hbHRlcm5hdGU7XG5cbiAgaWYgKGFsdGVybmF0ZSkge1xuICAgIG1hcmtSZXRyeUxhbmVJbXBsKGFsdGVybmF0ZSwgcmV0cnlMYW5lKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBhdHRlbXB0VXNlckJsb2NraW5nSHlkcmF0aW9uJDEoZmliZXIpIHtcbiAgaWYgKGZpYmVyLnRhZyAhPT0gU3VzcGVuc2VDb21wb25lbnQpIHtcbiAgICAvLyBXZSBpZ25vcmUgSG9zdFJvb3RzIGhlcmUgYmVjYXVzZSB3ZSBjYW4ndCBpbmNyZWFzZVxuICAgIC8vIHRoZWlyIHByaW9yaXR5IGFuZCB0aGV5IHNob3VsZCBub3Qgc3VzcGVuZCBvbiBJL08sXG4gICAgLy8gc2luY2UgeW91IGhhdmUgdG8gd3JhcCBhbnl0aGluZyB0aGF0IG1pZ2h0IHN1c3BlbmQgaW5cbiAgICAvLyBTdXNwZW5zZS5cbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgZXZlbnRUaW1lID0gcmVxdWVzdEV2ZW50VGltZSgpO1xuICB2YXIgbGFuZSA9IElucHV0RGlzY3JldGVIeWRyYXRpb25MYW5lO1xuICBzY2hlZHVsZVVwZGF0ZU9uRmliZXIoZmliZXIsIGxhbmUsIGV2ZW50VGltZSk7XG4gIG1hcmtSZXRyeUxhbmVJZk5vdEh5ZHJhdGVkKGZpYmVyLCBsYW5lKTtcbn1cbmZ1bmN0aW9uIGF0dGVtcHRDb250aW51b3VzSHlkcmF0aW9uJDEoZmliZXIpIHtcbiAgaWYgKGZpYmVyLnRhZyAhPT0gU3VzcGVuc2VDb21wb25lbnQpIHtcbiAgICAvLyBXZSBpZ25vcmUgSG9zdFJvb3RzIGhlcmUgYmVjYXVzZSB3ZSBjYW4ndCBpbmNyZWFzZVxuICAgIC8vIHRoZWlyIHByaW9yaXR5IGFuZCB0aGV5IHNob3VsZCBub3Qgc3VzcGVuZCBvbiBJL08sXG4gICAgLy8gc2luY2UgeW91IGhhdmUgdG8gd3JhcCBhbnl0aGluZyB0aGF0IG1pZ2h0IHN1c3BlbmQgaW5cbiAgICAvLyBTdXNwZW5zZS5cbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgZXZlbnRUaW1lID0gcmVxdWVzdEV2ZW50VGltZSgpO1xuICB2YXIgbGFuZSA9IFNlbGVjdGl2ZUh5ZHJhdGlvbkxhbmU7XG4gIHNjaGVkdWxlVXBkYXRlT25GaWJlcihmaWJlciwgbGFuZSwgZXZlbnRUaW1lKTtcbiAgbWFya1JldHJ5TGFuZUlmTm90SHlkcmF0ZWQoZmliZXIsIGxhbmUpO1xufVxuZnVuY3Rpb24gYXR0ZW1wdEh5ZHJhdGlvbkF0Q3VycmVudFByaW9yaXR5JDEoZmliZXIpIHtcbiAgaWYgKGZpYmVyLnRhZyAhPT0gU3VzcGVuc2VDb21wb25lbnQpIHtcbiAgICAvLyBXZSBpZ25vcmUgSG9zdFJvb3RzIGhlcmUgYmVjYXVzZSB3ZSBjYW4ndCBpbmNyZWFzZVxuICAgIC8vIHRoZWlyIHByaW9yaXR5IG90aGVyIHRoYW4gc3luY2hyb25vdXNseSBmbHVzaCBpdC5cbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgZXZlbnRUaW1lID0gcmVxdWVzdEV2ZW50VGltZSgpO1xuICB2YXIgbGFuZSA9IHJlcXVlc3RVcGRhdGVMYW5lKGZpYmVyKTtcbiAgc2NoZWR1bGVVcGRhdGVPbkZpYmVyKGZpYmVyLCBsYW5lLCBldmVudFRpbWUpO1xuICBtYXJrUmV0cnlMYW5lSWZOb3RIeWRyYXRlZChmaWJlciwgbGFuZSk7XG59XG5mdW5jdGlvbiBydW5XaXRoUHJpb3JpdHkkMihwcmlvcml0eSwgZm4pIHtcblxuICB0cnkge1xuICAgIHNldEN1cnJlbnRVcGRhdGVMYW5lUHJpb3JpdHkocHJpb3JpdHkpO1xuICAgIHJldHVybiBmbigpO1xuICB9IGZpbmFsbHkge1xuICB9XG59XG5mdW5jdGlvbiBmaW5kSG9zdEluc3RhbmNlV2l0aE5vUG9ydGFscyhmaWJlcikge1xuICB2YXIgaG9zdEZpYmVyID0gZmluZEN1cnJlbnRIb3N0RmliZXJXaXRoTm9Qb3J0YWxzKGZpYmVyKTtcblxuICBpZiAoaG9zdEZpYmVyID09PSBudWxsKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBpZiAoaG9zdEZpYmVyLnRhZyA9PT0gRnVuZGFtZW50YWxDb21wb25lbnQpIHtcbiAgICByZXR1cm4gaG9zdEZpYmVyLnN0YXRlTm9kZS5pbnN0YW5jZTtcbiAgfVxuXG4gIHJldHVybiBob3N0RmliZXIuc3RhdGVOb2RlO1xufVxuXG52YXIgc2hvdWxkU3VzcGVuZEltcGwgPSBmdW5jdGlvbiAoZmliZXIpIHtcbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuZnVuY3Rpb24gc2hvdWxkU3VzcGVuZChmaWJlcikge1xuICByZXR1cm4gc2hvdWxkU3VzcGVuZEltcGwoZmliZXIpO1xufVxudmFyIG92ZXJyaWRlSG9va1N0YXRlID0gbnVsbDtcbnZhciBvdmVycmlkZUhvb2tTdGF0ZURlbGV0ZVBhdGggPSBudWxsO1xudmFyIG92ZXJyaWRlSG9va1N0YXRlUmVuYW1lUGF0aCA9IG51bGw7XG52YXIgb3ZlcnJpZGVQcm9wcyA9IG51bGw7XG52YXIgb3ZlcnJpZGVQcm9wc0RlbGV0ZVBhdGggPSBudWxsO1xudmFyIG92ZXJyaWRlUHJvcHNSZW5hbWVQYXRoID0gbnVsbDtcbnZhciBzY2hlZHVsZVVwZGF0ZSA9IG51bGw7XG52YXIgc2V0U3VzcGVuc2VIYW5kbGVyID0gbnVsbDtcblxue1xuICB2YXIgY29weVdpdGhEZWxldGVJbXBsID0gZnVuY3Rpb24gKG9iaiwgcGF0aCwgaW5kZXgpIHtcbiAgICB2YXIga2V5ID0gcGF0aFtpbmRleF07XG4gICAgdmFyIHVwZGF0ZWQgPSBBcnJheS5pc0FycmF5KG9iaikgPyBvYmouc2xpY2UoKSA6IF9hc3NpZ24oe30sIG9iaik7XG5cbiAgICBpZiAoaW5kZXggKyAxID09PSBwYXRoLmxlbmd0aCkge1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkodXBkYXRlZCkpIHtcbiAgICAgICAgdXBkYXRlZC5zcGxpY2Uoa2V5LCAxKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlbGV0ZSB1cGRhdGVkW2tleV07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB1cGRhdGVkO1xuICAgIH0gLy8gJEZsb3dGaXhNZSBudW1iZXIgb3Igc3RyaW5nIGlzIGZpbmUgaGVyZVxuXG5cbiAgICB1cGRhdGVkW2tleV0gPSBjb3B5V2l0aERlbGV0ZUltcGwob2JqW2tleV0sIHBhdGgsIGluZGV4ICsgMSk7XG4gICAgcmV0dXJuIHVwZGF0ZWQ7XG4gIH07XG5cbiAgdmFyIGNvcHlXaXRoRGVsZXRlID0gZnVuY3Rpb24gKG9iaiwgcGF0aCkge1xuICAgIHJldHVybiBjb3B5V2l0aERlbGV0ZUltcGwob2JqLCBwYXRoLCAwKTtcbiAgfTtcblxuICB2YXIgY29weVdpdGhSZW5hbWVJbXBsID0gZnVuY3Rpb24gKG9iaiwgb2xkUGF0aCwgbmV3UGF0aCwgaW5kZXgpIHtcbiAgICB2YXIgb2xkS2V5ID0gb2xkUGF0aFtpbmRleF07XG4gICAgdmFyIHVwZGF0ZWQgPSBBcnJheS5pc0FycmF5KG9iaikgPyBvYmouc2xpY2UoKSA6IF9hc3NpZ24oe30sIG9iaik7XG5cbiAgICBpZiAoaW5kZXggKyAxID09PSBvbGRQYXRoLmxlbmd0aCkge1xuICAgICAgdmFyIG5ld0tleSA9IG5ld1BhdGhbaW5kZXhdOyAvLyAkRmxvd0ZpeE1lIG51bWJlciBvciBzdHJpbmcgaXMgZmluZSBoZXJlXG5cbiAgICAgIHVwZGF0ZWRbbmV3S2V5XSA9IHVwZGF0ZWRbb2xkS2V5XTtcblxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkodXBkYXRlZCkpIHtcbiAgICAgICAgdXBkYXRlZC5zcGxpY2Uob2xkS2V5LCAxKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlbGV0ZSB1cGRhdGVkW29sZEtleV07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vICRGbG93Rml4TWUgbnVtYmVyIG9yIHN0cmluZyBpcyBmaW5lIGhlcmVcbiAgICAgIHVwZGF0ZWRbb2xkS2V5XSA9IGNvcHlXaXRoUmVuYW1lSW1wbCggLy8gJEZsb3dGaXhNZSBudW1iZXIgb3Igc3RyaW5nIGlzIGZpbmUgaGVyZVxuICAgICAgb2JqW29sZEtleV0sIG9sZFBhdGgsIG5ld1BhdGgsIGluZGV4ICsgMSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHVwZGF0ZWQ7XG4gIH07XG5cbiAgdmFyIGNvcHlXaXRoUmVuYW1lID0gZnVuY3Rpb24gKG9iaiwgb2xkUGF0aCwgbmV3UGF0aCkge1xuICAgIGlmIChvbGRQYXRoLmxlbmd0aCAhPT0gbmV3UGF0aC5sZW5ndGgpIHtcbiAgICAgIHdhcm4oJ2NvcHlXaXRoUmVuYW1lKCkgZXhwZWN0cyBwYXRocyBvZiB0aGUgc2FtZSBsZW5ndGgnKTtcblxuICAgICAgcmV0dXJuO1xuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5ld1BhdGgubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgIGlmIChvbGRQYXRoW2ldICE9PSBuZXdQYXRoW2ldKSB7XG4gICAgICAgICAgd2FybignY29weVdpdGhSZW5hbWUoKSBleHBlY3RzIHBhdGhzIHRvIGJlIHRoZSBzYW1lIGV4Y2VwdCBmb3IgdGhlIGRlZXBlc3Qga2V5Jyk7XG5cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gY29weVdpdGhSZW5hbWVJbXBsKG9iaiwgb2xkUGF0aCwgbmV3UGF0aCwgMCk7XG4gIH07XG5cbiAgdmFyIGNvcHlXaXRoU2V0SW1wbCA9IGZ1bmN0aW9uIChvYmosIHBhdGgsIGluZGV4LCB2YWx1ZSkge1xuICAgIGlmIChpbmRleCA+PSBwYXRoLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIHZhciBrZXkgPSBwYXRoW2luZGV4XTtcbiAgICB2YXIgdXBkYXRlZCA9IEFycmF5LmlzQXJyYXkob2JqKSA/IG9iai5zbGljZSgpIDogX2Fzc2lnbih7fSwgb2JqKTsgLy8gJEZsb3dGaXhNZSBudW1iZXIgb3Igc3RyaW5nIGlzIGZpbmUgaGVyZVxuXG4gICAgdXBkYXRlZFtrZXldID0gY29weVdpdGhTZXRJbXBsKG9ialtrZXldLCBwYXRoLCBpbmRleCArIDEsIHZhbHVlKTtcbiAgICByZXR1cm4gdXBkYXRlZDtcbiAgfTtcblxuICB2YXIgY29weVdpdGhTZXQgPSBmdW5jdGlvbiAob2JqLCBwYXRoLCB2YWx1ZSkge1xuICAgIHJldHVybiBjb3B5V2l0aFNldEltcGwob2JqLCBwYXRoLCAwLCB2YWx1ZSk7XG4gIH07XG5cbiAgdmFyIGZpbmRIb29rID0gZnVuY3Rpb24gKGZpYmVyLCBpZCkge1xuICAgIC8vIEZvciBub3csIHRoZSBcImlkXCIgb2Ygc3RhdGVmdWwgaG9va3MgaXMganVzdCB0aGUgc3RhdGVmdWwgaG9vayBpbmRleC5cbiAgICAvLyBUaGlzIG1heSBjaGFuZ2UgaW4gdGhlIGZ1dHVyZSB3aXRoIGUuZy4gbmVzdGVkIGhvb2tzLlxuICAgIHZhciBjdXJyZW50SG9vayA9IGZpYmVyLm1lbW9pemVkU3RhdGU7XG5cbiAgICB3aGlsZSAoY3VycmVudEhvb2sgIT09IG51bGwgJiYgaWQgPiAwKSB7XG4gICAgICBjdXJyZW50SG9vayA9IGN1cnJlbnRIb29rLm5leHQ7XG4gICAgICBpZC0tO1xuICAgIH1cblxuICAgIHJldHVybiBjdXJyZW50SG9vaztcbiAgfTsgLy8gU3VwcG9ydCBEZXZUb29scyBlZGl0YWJsZSB2YWx1ZXMgZm9yIHVzZVN0YXRlIGFuZCB1c2VSZWR1Y2VyLlxuXG5cbiAgb3ZlcnJpZGVIb29rU3RhdGUgPSBmdW5jdGlvbiAoZmliZXIsIGlkLCBwYXRoLCB2YWx1ZSkge1xuICAgIHZhciBob29rID0gZmluZEhvb2soZmliZXIsIGlkKTtcblxuICAgIGlmIChob29rICE9PSBudWxsKSB7XG4gICAgICB2YXIgbmV3U3RhdGUgPSBjb3B5V2l0aFNldChob29rLm1lbW9pemVkU3RhdGUsIHBhdGgsIHZhbHVlKTtcbiAgICAgIGhvb2subWVtb2l6ZWRTdGF0ZSA9IG5ld1N0YXRlO1xuICAgICAgaG9vay5iYXNlU3RhdGUgPSBuZXdTdGF0ZTsgLy8gV2UgYXJlbid0IGFjdHVhbGx5IGFkZGluZyBhbiB1cGRhdGUgdG8gdGhlIHF1ZXVlLFxuICAgICAgLy8gYmVjYXVzZSB0aGVyZSBpcyBubyB1cGRhdGUgd2UgY2FuIGFkZCBmb3IgdXNlUmVkdWNlciBob29rcyB0aGF0IHdvbid0IHRyaWdnZXIgYW4gZXJyb3IuXG4gICAgICAvLyAoVGhlcmUncyBubyBhcHByb3ByaWF0ZSBhY3Rpb24gdHlwZSBmb3IgRGV2VG9vbHMgb3ZlcnJpZGVzLilcbiAgICAgIC8vIEFzIGEgcmVzdWx0IHRob3VnaCwgUmVhY3Qgd2lsbCBzZWUgdGhlIHNjaGVkdWxlZCB1cGRhdGUgYXMgYSBub29wIGFuZCBiYWlsb3V0LlxuICAgICAgLy8gU2hhbGxvdyBjbG9uaW5nIHByb3BzIHdvcmtzIGFzIGEgd29ya2Fyb3VuZCBmb3Igbm93IHRvIGJ5cGFzcyB0aGUgYmFpbG91dCBjaGVjay5cblxuICAgICAgZmliZXIubWVtb2l6ZWRQcm9wcyA9IF9hc3NpZ24oe30sIGZpYmVyLm1lbW9pemVkUHJvcHMpO1xuICAgICAgc2NoZWR1bGVVcGRhdGVPbkZpYmVyKGZpYmVyLCBTeW5jTGFuZSwgTm9UaW1lc3RhbXApO1xuICAgIH1cbiAgfTtcblxuICBvdmVycmlkZUhvb2tTdGF0ZURlbGV0ZVBhdGggPSBmdW5jdGlvbiAoZmliZXIsIGlkLCBwYXRoKSB7XG4gICAgdmFyIGhvb2sgPSBmaW5kSG9vayhmaWJlciwgaWQpO1xuXG4gICAgaWYgKGhvb2sgIT09IG51bGwpIHtcbiAgICAgIHZhciBuZXdTdGF0ZSA9IGNvcHlXaXRoRGVsZXRlKGhvb2subWVtb2l6ZWRTdGF0ZSwgcGF0aCk7XG4gICAgICBob29rLm1lbW9pemVkU3RhdGUgPSBuZXdTdGF0ZTtcbiAgICAgIGhvb2suYmFzZVN0YXRlID0gbmV3U3RhdGU7IC8vIFdlIGFyZW4ndCBhY3R1YWxseSBhZGRpbmcgYW4gdXBkYXRlIHRvIHRoZSBxdWV1ZSxcbiAgICAgIC8vIGJlY2F1c2UgdGhlcmUgaXMgbm8gdXBkYXRlIHdlIGNhbiBhZGQgZm9yIHVzZVJlZHVjZXIgaG9va3MgdGhhdCB3b24ndCB0cmlnZ2VyIGFuIGVycm9yLlxuICAgICAgLy8gKFRoZXJlJ3Mgbm8gYXBwcm9wcmlhdGUgYWN0aW9uIHR5cGUgZm9yIERldlRvb2xzIG92ZXJyaWRlcy4pXG4gICAgICAvLyBBcyBhIHJlc3VsdCB0aG91Z2gsIFJlYWN0IHdpbGwgc2VlIHRoZSBzY2hlZHVsZWQgdXBkYXRlIGFzIGEgbm9vcCBhbmQgYmFpbG91dC5cbiAgICAgIC8vIFNoYWxsb3cgY2xvbmluZyBwcm9wcyB3b3JrcyBhcyBhIHdvcmthcm91bmQgZm9yIG5vdyB0byBieXBhc3MgdGhlIGJhaWxvdXQgY2hlY2suXG5cbiAgICAgIGZpYmVyLm1lbW9pemVkUHJvcHMgPSBfYXNzaWduKHt9LCBmaWJlci5tZW1vaXplZFByb3BzKTtcbiAgICAgIHNjaGVkdWxlVXBkYXRlT25GaWJlcihmaWJlciwgU3luY0xhbmUsIE5vVGltZXN0YW1wKTtcbiAgICB9XG4gIH07XG5cbiAgb3ZlcnJpZGVIb29rU3RhdGVSZW5hbWVQYXRoID0gZnVuY3Rpb24gKGZpYmVyLCBpZCwgb2xkUGF0aCwgbmV3UGF0aCkge1xuICAgIHZhciBob29rID0gZmluZEhvb2soZmliZXIsIGlkKTtcblxuICAgIGlmIChob29rICE9PSBudWxsKSB7XG4gICAgICB2YXIgbmV3U3RhdGUgPSBjb3B5V2l0aFJlbmFtZShob29rLm1lbW9pemVkU3RhdGUsIG9sZFBhdGgsIG5ld1BhdGgpO1xuICAgICAgaG9vay5tZW1vaXplZFN0YXRlID0gbmV3U3RhdGU7XG4gICAgICBob29rLmJhc2VTdGF0ZSA9IG5ld1N0YXRlOyAvLyBXZSBhcmVuJ3QgYWN0dWFsbHkgYWRkaW5nIGFuIHVwZGF0ZSB0byB0aGUgcXVldWUsXG4gICAgICAvLyBiZWNhdXNlIHRoZXJlIGlzIG5vIHVwZGF0ZSB3ZSBjYW4gYWRkIGZvciB1c2VSZWR1Y2VyIGhvb2tzIHRoYXQgd29uJ3QgdHJpZ2dlciBhbiBlcnJvci5cbiAgICAgIC8vIChUaGVyZSdzIG5vIGFwcHJvcHJpYXRlIGFjdGlvbiB0eXBlIGZvciBEZXZUb29scyBvdmVycmlkZXMuKVxuICAgICAgLy8gQXMgYSByZXN1bHQgdGhvdWdoLCBSZWFjdCB3aWxsIHNlZSB0aGUgc2NoZWR1bGVkIHVwZGF0ZSBhcyBhIG5vb3AgYW5kIGJhaWxvdXQuXG4gICAgICAvLyBTaGFsbG93IGNsb25pbmcgcHJvcHMgd29ya3MgYXMgYSB3b3JrYXJvdW5kIGZvciBub3cgdG8gYnlwYXNzIHRoZSBiYWlsb3V0IGNoZWNrLlxuXG4gICAgICBmaWJlci5tZW1vaXplZFByb3BzID0gX2Fzc2lnbih7fSwgZmliZXIubWVtb2l6ZWRQcm9wcyk7XG4gICAgICBzY2hlZHVsZVVwZGF0ZU9uRmliZXIoZmliZXIsIFN5bmNMYW5lLCBOb1RpbWVzdGFtcCk7XG4gICAgfVxuICB9OyAvLyBTdXBwb3J0IERldlRvb2xzIHByb3BzIGZvciBmdW5jdGlvbiBjb21wb25lbnRzLCBmb3J3YXJkUmVmLCBtZW1vLCBob3N0IGNvbXBvbmVudHMsIGV0Yy5cblxuXG4gIG92ZXJyaWRlUHJvcHMgPSBmdW5jdGlvbiAoZmliZXIsIHBhdGgsIHZhbHVlKSB7XG4gICAgZmliZXIucGVuZGluZ1Byb3BzID0gY29weVdpdGhTZXQoZmliZXIubWVtb2l6ZWRQcm9wcywgcGF0aCwgdmFsdWUpO1xuXG4gICAgaWYgKGZpYmVyLmFsdGVybmF0ZSkge1xuICAgICAgZmliZXIuYWx0ZXJuYXRlLnBlbmRpbmdQcm9wcyA9IGZpYmVyLnBlbmRpbmdQcm9wcztcbiAgICB9XG5cbiAgICBzY2hlZHVsZVVwZGF0ZU9uRmliZXIoZmliZXIsIFN5bmNMYW5lLCBOb1RpbWVzdGFtcCk7XG4gIH07XG5cbiAgb3ZlcnJpZGVQcm9wc0RlbGV0ZVBhdGggPSBmdW5jdGlvbiAoZmliZXIsIHBhdGgpIHtcbiAgICBmaWJlci5wZW5kaW5nUHJvcHMgPSBjb3B5V2l0aERlbGV0ZShmaWJlci5tZW1vaXplZFByb3BzLCBwYXRoKTtcblxuICAgIGlmIChmaWJlci5hbHRlcm5hdGUpIHtcbiAgICAgIGZpYmVyLmFsdGVybmF0ZS5wZW5kaW5nUHJvcHMgPSBmaWJlci5wZW5kaW5nUHJvcHM7XG4gICAgfVxuXG4gICAgc2NoZWR1bGVVcGRhdGVPbkZpYmVyKGZpYmVyLCBTeW5jTGFuZSwgTm9UaW1lc3RhbXApO1xuICB9O1xuXG4gIG92ZXJyaWRlUHJvcHNSZW5hbWVQYXRoID0gZnVuY3Rpb24gKGZpYmVyLCBvbGRQYXRoLCBuZXdQYXRoKSB7XG4gICAgZmliZXIucGVuZGluZ1Byb3BzID0gY29weVdpdGhSZW5hbWUoZmliZXIubWVtb2l6ZWRQcm9wcywgb2xkUGF0aCwgbmV3UGF0aCk7XG5cbiAgICBpZiAoZmliZXIuYWx0ZXJuYXRlKSB7XG4gICAgICBmaWJlci5hbHRlcm5hdGUucGVuZGluZ1Byb3BzID0gZmliZXIucGVuZGluZ1Byb3BzO1xuICAgIH1cblxuICAgIHNjaGVkdWxlVXBkYXRlT25GaWJlcihmaWJlciwgU3luY0xhbmUsIE5vVGltZXN0YW1wKTtcbiAgfTtcblxuICBzY2hlZHVsZVVwZGF0ZSA9IGZ1bmN0aW9uIChmaWJlcikge1xuICAgIHNjaGVkdWxlVXBkYXRlT25GaWJlcihmaWJlciwgU3luY0xhbmUsIE5vVGltZXN0YW1wKTtcbiAgfTtcblxuICBzZXRTdXNwZW5zZUhhbmRsZXIgPSBmdW5jdGlvbiAobmV3U2hvdWxkU3VzcGVuZEltcGwpIHtcbiAgICBzaG91bGRTdXNwZW5kSW1wbCA9IG5ld1Nob3VsZFN1c3BlbmRJbXBsO1xuICB9O1xufVxuXG5mdW5jdGlvbiBmaW5kSG9zdEluc3RhbmNlQnlGaWJlcihmaWJlcikge1xuICB2YXIgaG9zdEZpYmVyID0gZmluZEN1cnJlbnRIb3N0RmliZXIoZmliZXIpO1xuXG4gIGlmIChob3N0RmliZXIgPT09IG51bGwpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHJldHVybiBob3N0RmliZXIuc3RhdGVOb2RlO1xufVxuXG5mdW5jdGlvbiBlbXB0eUZpbmRGaWJlckJ5SG9zdEluc3RhbmNlKGluc3RhbmNlKSB7XG4gIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBnZXRDdXJyZW50RmliZXJGb3JEZXZUb29scygpIHtcbiAgcmV0dXJuIGN1cnJlbnQ7XG59XG5cbmZ1bmN0aW9uIGluamVjdEludG9EZXZUb29scyhkZXZUb29sc0NvbmZpZykge1xuICB2YXIgZmluZEZpYmVyQnlIb3N0SW5zdGFuY2UgPSBkZXZUb29sc0NvbmZpZy5maW5kRmliZXJCeUhvc3RJbnN0YW5jZTtcbiAgdmFyIFJlYWN0Q3VycmVudERpc3BhdGNoZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdEN1cnJlbnREaXNwYXRjaGVyO1xuICByZXR1cm4gaW5qZWN0SW50ZXJuYWxzKHtcbiAgICBidW5kbGVUeXBlOiBkZXZUb29sc0NvbmZpZy5idW5kbGVUeXBlLFxuICAgIHZlcnNpb246IGRldlRvb2xzQ29uZmlnLnZlcnNpb24sXG4gICAgcmVuZGVyZXJQYWNrYWdlTmFtZTogZGV2VG9vbHNDb25maWcucmVuZGVyZXJQYWNrYWdlTmFtZSxcbiAgICByZW5kZXJlckNvbmZpZzogZGV2VG9vbHNDb25maWcucmVuZGVyZXJDb25maWcsXG4gICAgb3ZlcnJpZGVIb29rU3RhdGU6IG92ZXJyaWRlSG9va1N0YXRlLFxuICAgIG92ZXJyaWRlSG9va1N0YXRlRGVsZXRlUGF0aDogb3ZlcnJpZGVIb29rU3RhdGVEZWxldGVQYXRoLFxuICAgIG92ZXJyaWRlSG9va1N0YXRlUmVuYW1lUGF0aDogb3ZlcnJpZGVIb29rU3RhdGVSZW5hbWVQYXRoLFxuICAgIG92ZXJyaWRlUHJvcHM6IG92ZXJyaWRlUHJvcHMsXG4gICAgb3ZlcnJpZGVQcm9wc0RlbGV0ZVBhdGg6IG92ZXJyaWRlUHJvcHNEZWxldGVQYXRoLFxuICAgIG92ZXJyaWRlUHJvcHNSZW5hbWVQYXRoOiBvdmVycmlkZVByb3BzUmVuYW1lUGF0aCxcbiAgICBzZXRTdXNwZW5zZUhhbmRsZXI6IHNldFN1c3BlbnNlSGFuZGxlcixcbiAgICBzY2hlZHVsZVVwZGF0ZTogc2NoZWR1bGVVcGRhdGUsXG4gICAgY3VycmVudERpc3BhdGNoZXJSZWY6IFJlYWN0Q3VycmVudERpc3BhdGNoZXIsXG4gICAgZmluZEhvc3RJbnN0YW5jZUJ5RmliZXI6IGZpbmRIb3N0SW5zdGFuY2VCeUZpYmVyLFxuICAgIGZpbmRGaWJlckJ5SG9zdEluc3RhbmNlOiBmaW5kRmliZXJCeUhvc3RJbnN0YW5jZSB8fCBlbXB0eUZpbmRGaWJlckJ5SG9zdEluc3RhbmNlLFxuICAgIC8vIFJlYWN0IFJlZnJlc2hcbiAgICBmaW5kSG9zdEluc3RhbmNlc0ZvclJlZnJlc2g6ICBmaW5kSG9zdEluc3RhbmNlc0ZvclJlZnJlc2ggLFxuICAgIHNjaGVkdWxlUmVmcmVzaDogIHNjaGVkdWxlUmVmcmVzaCAsXG4gICAgc2NoZWR1bGVSb290OiAgc2NoZWR1bGVSb290ICxcbiAgICBzZXRSZWZyZXNoSGFuZGxlcjogIHNldFJlZnJlc2hIYW5kbGVyICxcbiAgICAvLyBFbmFibGVzIERldlRvb2xzIHRvIGFwcGVuZCBvd25lciBzdGFja3MgdG8gZXJyb3IgbWVzc2FnZXMgaW4gREVWIG1vZGUuXG4gICAgZ2V0Q3VycmVudEZpYmVyOiAgZ2V0Q3VycmVudEZpYmVyRm9yRGV2VG9vbHMgXG4gIH0pO1xufVxuXG5mdW5jdGlvbiBSZWFjdERPTVJvb3QoY29udGFpbmVyLCBvcHRpb25zKSB7XG4gIHRoaXMuX2ludGVybmFsUm9vdCA9IGNyZWF0ZVJvb3RJbXBsKGNvbnRhaW5lciwgQ29uY3VycmVudFJvb3QsIG9wdGlvbnMpO1xufVxuXG5mdW5jdGlvbiBSZWFjdERPTUJsb2NraW5nUm9vdChjb250YWluZXIsIHRhZywgb3B0aW9ucykge1xuICB0aGlzLl9pbnRlcm5hbFJvb3QgPSBjcmVhdGVSb290SW1wbChjb250YWluZXIsIHRhZywgb3B0aW9ucyk7XG59XG5cblJlYWN0RE9NUm9vdC5wcm90b3R5cGUucmVuZGVyID0gUmVhY3RET01CbG9ja2luZ1Jvb3QucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIChjaGlsZHJlbikge1xuICB2YXIgcm9vdCA9IHRoaXMuX2ludGVybmFsUm9vdDtcblxuICB7XG4gICAgaWYgKHR5cGVvZiBhcmd1bWVudHNbMV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGVycm9yKCdyZW5kZXIoLi4uKTogZG9lcyBub3Qgc3VwcG9ydCB0aGUgc2Vjb25kIGNhbGxiYWNrIGFyZ3VtZW50LiAnICsgJ1RvIGV4ZWN1dGUgYSBzaWRlIGVmZmVjdCBhZnRlciByZW5kZXJpbmcsIGRlY2xhcmUgaXQgaW4gYSBjb21wb25lbnQgYm9keSB3aXRoIHVzZUVmZmVjdCgpLicpO1xuICAgIH1cblxuICAgIHZhciBjb250YWluZXIgPSByb290LmNvbnRhaW5lckluZm87XG5cbiAgICBpZiAoY29udGFpbmVyLm5vZGVUeXBlICE9PSBDT01NRU5UX05PREUpIHtcbiAgICAgIHZhciBob3N0SW5zdGFuY2UgPSBmaW5kSG9zdEluc3RhbmNlV2l0aE5vUG9ydGFscyhyb290LmN1cnJlbnQpO1xuXG4gICAgICBpZiAoaG9zdEluc3RhbmNlKSB7XG4gICAgICAgIGlmIChob3N0SW5zdGFuY2UucGFyZW50Tm9kZSAhPT0gY29udGFpbmVyKSB7XG4gICAgICAgICAgZXJyb3IoJ3JlbmRlciguLi4pOiBJdCBsb29rcyBsaWtlIHRoZSBSZWFjdC1yZW5kZXJlZCBjb250ZW50IG9mIHRoZSAnICsgJ3Jvb3QgY29udGFpbmVyIHdhcyByZW1vdmVkIHdpdGhvdXQgdXNpbmcgUmVhY3QuIFRoaXMgaXMgbm90ICcgKyAnc3VwcG9ydGVkIGFuZCB3aWxsIGNhdXNlIGVycm9ycy4gSW5zdGVhZCwgY2FsbCAnICsgXCJyb290LnVubW91bnQoKSB0byBlbXB0eSBhIHJvb3QncyBjb250YWluZXIuXCIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdXBkYXRlQ29udGFpbmVyKGNoaWxkcmVuLCByb290LCBudWxsLCBudWxsKTtcbn07XG5cblJlYWN0RE9NUm9vdC5wcm90b3R5cGUudW5tb3VudCA9IFJlYWN0RE9NQmxvY2tpbmdSb290LnByb3RvdHlwZS51bm1vdW50ID0gZnVuY3Rpb24gKCkge1xuICB7XG4gICAgaWYgKHR5cGVvZiBhcmd1bWVudHNbMF0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGVycm9yKCd1bm1vdW50KC4uLik6IGRvZXMgbm90IHN1cHBvcnQgYSBjYWxsYmFjayBhcmd1bWVudC4gJyArICdUbyBleGVjdXRlIGEgc2lkZSBlZmZlY3QgYWZ0ZXIgcmVuZGVyaW5nLCBkZWNsYXJlIGl0IGluIGEgY29tcG9uZW50IGJvZHkgd2l0aCB1c2VFZmZlY3QoKS4nKTtcbiAgICB9XG4gIH1cblxuICB2YXIgcm9vdCA9IHRoaXMuX2ludGVybmFsUm9vdDtcbiAgdmFyIGNvbnRhaW5lciA9IHJvb3QuY29udGFpbmVySW5mbztcbiAgdXBkYXRlQ29udGFpbmVyKG51bGwsIHJvb3QsIG51bGwsIGZ1bmN0aW9uICgpIHtcbiAgICB1bm1hcmtDb250YWluZXJBc1Jvb3QoY29udGFpbmVyKTtcbiAgfSk7XG59O1xuXG5mdW5jdGlvbiBjcmVhdGVSb290SW1wbChjb250YWluZXIsIHRhZywgb3B0aW9ucykge1xuICAvLyBUYWcgaXMgZWl0aGVyIExlZ2FjeVJvb3Qgb3IgQ29uY3VycmVudCBSb290XG4gIHZhciBoeWRyYXRlID0gb3B0aW9ucyAhPSBudWxsICYmIG9wdGlvbnMuaHlkcmF0ZSA9PT0gdHJ1ZTtcbiAgdmFyIGh5ZHJhdGlvbkNhbGxiYWNrcyA9IG9wdGlvbnMgIT0gbnVsbCAmJiBvcHRpb25zLmh5ZHJhdGlvbk9wdGlvbnMgfHwgbnVsbDtcbiAgdmFyIG11dGFibGVTb3VyY2VzID0gb3B0aW9ucyAhPSBudWxsICYmIG9wdGlvbnMuaHlkcmF0aW9uT3B0aW9ucyAhPSBudWxsICYmIG9wdGlvbnMuaHlkcmF0aW9uT3B0aW9ucy5tdXRhYmxlU291cmNlcyB8fCBudWxsO1xuICB2YXIgcm9vdCA9IGNyZWF0ZUNvbnRhaW5lcihjb250YWluZXIsIHRhZywgaHlkcmF0ZSk7XG4gIG1hcmtDb250YWluZXJBc1Jvb3Qocm9vdC5jdXJyZW50LCBjb250YWluZXIpO1xuICB2YXIgY29udGFpbmVyTm9kZVR5cGUgPSBjb250YWluZXIubm9kZVR5cGU7XG5cbiAge1xuICAgIHZhciByb290Q29udGFpbmVyRWxlbWVudCA9IGNvbnRhaW5lci5ub2RlVHlwZSA9PT0gQ09NTUVOVF9OT0RFID8gY29udGFpbmVyLnBhcmVudE5vZGUgOiBjb250YWluZXI7XG4gICAgbGlzdGVuVG9BbGxTdXBwb3J0ZWRFdmVudHMocm9vdENvbnRhaW5lckVsZW1lbnQpO1xuICB9XG5cbiAgaWYgKG11dGFibGVTb3VyY2VzKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtdXRhYmxlU291cmNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIG11dGFibGVTb3VyY2UgPSBtdXRhYmxlU291cmNlc1tpXTtcbiAgICAgIHJlZ2lzdGVyTXV0YWJsZVNvdXJjZUZvckh5ZHJhdGlvbihyb290LCBtdXRhYmxlU291cmNlKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcm9vdDtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUxlZ2FjeVJvb3QoY29udGFpbmVyLCBvcHRpb25zKSB7XG4gIHJldHVybiBuZXcgUmVhY3RET01CbG9ja2luZ1Jvb3QoY29udGFpbmVyLCBMZWdhY3lSb290LCBvcHRpb25zKTtcbn1cbmZ1bmN0aW9uIGlzVmFsaWRDb250YWluZXIobm9kZSkge1xuICByZXR1cm4gISEobm9kZSAmJiAobm9kZS5ub2RlVHlwZSA9PT0gRUxFTUVOVF9OT0RFIHx8IG5vZGUubm9kZVR5cGUgPT09IERPQ1VNRU5UX05PREUgfHwgbm9kZS5ub2RlVHlwZSA9PT0gRE9DVU1FTlRfRlJBR01FTlRfTk9ERSB8fCBub2RlLm5vZGVUeXBlID09PSBDT01NRU5UX05PREUgJiYgbm9kZS5ub2RlVmFsdWUgPT09ICcgcmVhY3QtbW91bnQtcG9pbnQtdW5zdGFibGUgJykpO1xufVxuXG52YXIgUmVhY3RDdXJyZW50T3duZXIkMyA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0Q3VycmVudE93bmVyO1xudmFyIHRvcExldmVsVXBkYXRlV2FybmluZ3M7XG52YXIgd2FybmVkQWJvdXRIeWRyYXRlQVBJID0gZmFsc2U7XG5cbntcbiAgdG9wTGV2ZWxVcGRhdGVXYXJuaW5ncyA9IGZ1bmN0aW9uIChjb250YWluZXIpIHtcbiAgICBpZiAoY29udGFpbmVyLl9yZWFjdFJvb3RDb250YWluZXIgJiYgY29udGFpbmVyLm5vZGVUeXBlICE9PSBDT01NRU5UX05PREUpIHtcbiAgICAgIHZhciBob3N0SW5zdGFuY2UgPSBmaW5kSG9zdEluc3RhbmNlV2l0aE5vUG9ydGFscyhjb250YWluZXIuX3JlYWN0Um9vdENvbnRhaW5lci5faW50ZXJuYWxSb290LmN1cnJlbnQpO1xuXG4gICAgICBpZiAoaG9zdEluc3RhbmNlKSB7XG4gICAgICAgIGlmIChob3N0SW5zdGFuY2UucGFyZW50Tm9kZSAhPT0gY29udGFpbmVyKSB7XG4gICAgICAgICAgZXJyb3IoJ3JlbmRlciguLi4pOiBJdCBsb29rcyBsaWtlIHRoZSBSZWFjdC1yZW5kZXJlZCBjb250ZW50IG9mIHRoaXMgJyArICdjb250YWluZXIgd2FzIHJlbW92ZWQgd2l0aG91dCB1c2luZyBSZWFjdC4gVGhpcyBpcyBub3QgJyArICdzdXBwb3J0ZWQgYW5kIHdpbGwgY2F1c2UgZXJyb3JzLiBJbnN0ZWFkLCBjYWxsICcgKyAnUmVhY3RET00udW5tb3VudENvbXBvbmVudEF0Tm9kZSB0byBlbXB0eSBhIGNvbnRhaW5lci4nKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBpc1Jvb3RSZW5kZXJlZEJ5U29tZVJlYWN0ID0gISFjb250YWluZXIuX3JlYWN0Um9vdENvbnRhaW5lcjtcbiAgICB2YXIgcm9vdEVsID0gZ2V0UmVhY3RSb290RWxlbWVudEluQ29udGFpbmVyKGNvbnRhaW5lcik7XG4gICAgdmFyIGhhc05vblJvb3RSZWFjdENoaWxkID0gISEocm9vdEVsICYmIGdldEluc3RhbmNlRnJvbU5vZGUocm9vdEVsKSk7XG5cbiAgICBpZiAoaGFzTm9uUm9vdFJlYWN0Q2hpbGQgJiYgIWlzUm9vdFJlbmRlcmVkQnlTb21lUmVhY3QpIHtcbiAgICAgIGVycm9yKCdyZW5kZXIoLi4uKTogUmVwbGFjaW5nIFJlYWN0LXJlbmRlcmVkIGNoaWxkcmVuIHdpdGggYSBuZXcgcm9vdCAnICsgJ2NvbXBvbmVudC4gSWYgeW91IGludGVuZGVkIHRvIHVwZGF0ZSB0aGUgY2hpbGRyZW4gb2YgdGhpcyBub2RlLCAnICsgJ3lvdSBzaG91bGQgaW5zdGVhZCBoYXZlIHRoZSBleGlzdGluZyBjaGlsZHJlbiB1cGRhdGUgdGhlaXIgc3RhdGUgJyArICdhbmQgcmVuZGVyIHRoZSBuZXcgY29tcG9uZW50cyBpbnN0ZWFkIG9mIGNhbGxpbmcgUmVhY3RET00ucmVuZGVyLicpO1xuICAgIH1cblxuICAgIGlmIChjb250YWluZXIubm9kZVR5cGUgPT09IEVMRU1FTlRfTk9ERSAmJiBjb250YWluZXIudGFnTmFtZSAmJiBjb250YWluZXIudGFnTmFtZS50b1VwcGVyQ2FzZSgpID09PSAnQk9EWScpIHtcbiAgICAgIGVycm9yKCdyZW5kZXIoKTogUmVuZGVyaW5nIGNvbXBvbmVudHMgZGlyZWN0bHkgaW50byBkb2N1bWVudC5ib2R5IGlzICcgKyAnZGlzY291cmFnZWQsIHNpbmNlIGl0cyBjaGlsZHJlbiBhcmUgb2Z0ZW4gbWFuaXB1bGF0ZWQgYnkgdGhpcmQtcGFydHkgJyArICdzY3JpcHRzIGFuZCBicm93c2VyIGV4dGVuc2lvbnMuIFRoaXMgbWF5IGxlYWQgdG8gc3VidGxlICcgKyAncmVjb25jaWxpYXRpb24gaXNzdWVzLiBUcnkgcmVuZGVyaW5nIGludG8gYSBjb250YWluZXIgZWxlbWVudCBjcmVhdGVkICcgKyAnZm9yIHlvdXIgYXBwLicpO1xuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0UmVhY3RSb290RWxlbWVudEluQ29udGFpbmVyKGNvbnRhaW5lcikge1xuICBpZiAoIWNvbnRhaW5lcikge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgaWYgKGNvbnRhaW5lci5ub2RlVHlwZSA9PT0gRE9DVU1FTlRfTk9ERSkge1xuICAgIHJldHVybiBjb250YWluZXIuZG9jdW1lbnRFbGVtZW50O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBjb250YWluZXIuZmlyc3RDaGlsZDtcbiAgfVxufVxuXG5mdW5jdGlvbiBzaG91bGRIeWRyYXRlRHVlVG9MZWdhY3lIZXVyaXN0aWMoY29udGFpbmVyKSB7XG4gIHZhciByb290RWxlbWVudCA9IGdldFJlYWN0Um9vdEVsZW1lbnRJbkNvbnRhaW5lcihjb250YWluZXIpO1xuICByZXR1cm4gISEocm9vdEVsZW1lbnQgJiYgcm9vdEVsZW1lbnQubm9kZVR5cGUgPT09IEVMRU1FTlRfTk9ERSAmJiByb290RWxlbWVudC5oYXNBdHRyaWJ1dGUoUk9PVF9BVFRSSUJVVEVfTkFNRSkpO1xufVxuXG5mdW5jdGlvbiBsZWdhY3lDcmVhdGVSb290RnJvbURPTUNvbnRhaW5lcihjb250YWluZXIsIGZvcmNlSHlkcmF0ZSkge1xuICB2YXIgc2hvdWxkSHlkcmF0ZSA9IGZvcmNlSHlkcmF0ZSB8fCBzaG91bGRIeWRyYXRlRHVlVG9MZWdhY3lIZXVyaXN0aWMoY29udGFpbmVyKTsgLy8gRmlyc3QgY2xlYXIgYW55IGV4aXN0aW5nIGNvbnRlbnQuXG5cbiAgaWYgKCFzaG91bGRIeWRyYXRlKSB7XG4gICAgdmFyIHdhcm5lZCA9IGZhbHNlO1xuICAgIHZhciByb290U2libGluZztcblxuICAgIHdoaWxlIChyb290U2libGluZyA9IGNvbnRhaW5lci5sYXN0Q2hpbGQpIHtcbiAgICAgIHtcbiAgICAgICAgaWYgKCF3YXJuZWQgJiYgcm9vdFNpYmxpbmcubm9kZVR5cGUgPT09IEVMRU1FTlRfTk9ERSAmJiByb290U2libGluZy5oYXNBdHRyaWJ1dGUoUk9PVF9BVFRSSUJVVEVfTkFNRSkpIHtcbiAgICAgICAgICB3YXJuZWQgPSB0cnVlO1xuXG4gICAgICAgICAgZXJyb3IoJ3JlbmRlcigpOiBUYXJnZXQgbm9kZSBoYXMgbWFya3VwIHJlbmRlcmVkIGJ5IFJlYWN0LCBidXQgdGhlcmUgJyArICdhcmUgdW5yZWxhdGVkIG5vZGVzIGFzIHdlbGwuIFRoaXMgaXMgbW9zdCBjb21tb25seSBjYXVzZWQgYnkgJyArICd3aGl0ZS1zcGFjZSBpbnNlcnRlZCBhcm91bmQgc2VydmVyLXJlbmRlcmVkIG1hcmt1cC4nKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjb250YWluZXIucmVtb3ZlQ2hpbGQocm9vdFNpYmxpbmcpO1xuICAgIH1cbiAgfVxuXG4gIHtcbiAgICBpZiAoc2hvdWxkSHlkcmF0ZSAmJiAhZm9yY2VIeWRyYXRlICYmICF3YXJuZWRBYm91dEh5ZHJhdGVBUEkpIHtcbiAgICAgIHdhcm5lZEFib3V0SHlkcmF0ZUFQSSA9IHRydWU7XG5cbiAgICAgIHdhcm4oJ3JlbmRlcigpOiBDYWxsaW5nIFJlYWN0RE9NLnJlbmRlcigpIHRvIGh5ZHJhdGUgc2VydmVyLXJlbmRlcmVkIG1hcmt1cCAnICsgJ3dpbGwgc3RvcCB3b3JraW5nIGluIFJlYWN0IHYxOC4gUmVwbGFjZSB0aGUgUmVhY3RET00ucmVuZGVyKCkgY2FsbCAnICsgJ3dpdGggUmVhY3RET00uaHlkcmF0ZSgpIGlmIHlvdSB3YW50IFJlYWN0IHRvIGF0dGFjaCB0byB0aGUgc2VydmVyIEhUTUwuJyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGNyZWF0ZUxlZ2FjeVJvb3QoY29udGFpbmVyLCBzaG91bGRIeWRyYXRlID8ge1xuICAgIGh5ZHJhdGU6IHRydWVcbiAgfSA6IHVuZGVmaW5lZCk7XG59XG5cbmZ1bmN0aW9uIHdhcm5PbkludmFsaWRDYWxsYmFjayQxKGNhbGxiYWNrLCBjYWxsZXJOYW1lKSB7XG4gIHtcbiAgICBpZiAoY2FsbGJhY2sgIT09IG51bGwgJiYgdHlwZW9mIGNhbGxiYWNrICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICBlcnJvcignJXMoLi4uKTogRXhwZWN0ZWQgdGhlIGxhc3Qgb3B0aW9uYWwgYGNhbGxiYWNrYCBhcmd1bWVudCB0byBiZSBhICcgKyAnZnVuY3Rpb24uIEluc3RlYWQgcmVjZWl2ZWQ6ICVzLicsIGNhbGxlck5hbWUsIGNhbGxiYWNrKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gbGVnYWN5UmVuZGVyU3VidHJlZUludG9Db250YWluZXIocGFyZW50Q29tcG9uZW50LCBjaGlsZHJlbiwgY29udGFpbmVyLCBmb3JjZUh5ZHJhdGUsIGNhbGxiYWNrKSB7XG4gIHtcbiAgICB0b3BMZXZlbFVwZGF0ZVdhcm5pbmdzKGNvbnRhaW5lcik7XG4gICAgd2Fybk9uSW52YWxpZENhbGxiYWNrJDEoY2FsbGJhY2sgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBjYWxsYmFjaywgJ3JlbmRlcicpO1xuICB9IC8vIFRPRE86IFdpdGhvdXQgYGFueWAgdHlwZSwgRmxvdyBzYXlzIFwiUHJvcGVydHkgY2Fubm90IGJlIGFjY2Vzc2VkIG9uIGFueVxuICAvLyBtZW1iZXIgb2YgaW50ZXJzZWN0aW9uIHR5cGUuXCIgV2h5eXl5eXkuXG5cblxuICB2YXIgcm9vdCA9IGNvbnRhaW5lci5fcmVhY3RSb290Q29udGFpbmVyO1xuICB2YXIgZmliZXJSb290O1xuXG4gIGlmICghcm9vdCkge1xuICAgIC8vIEluaXRpYWwgbW91bnRcbiAgICByb290ID0gY29udGFpbmVyLl9yZWFjdFJvb3RDb250YWluZXIgPSBsZWdhY3lDcmVhdGVSb290RnJvbURPTUNvbnRhaW5lcihjb250YWluZXIsIGZvcmNlSHlkcmF0ZSk7XG4gICAgZmliZXJSb290ID0gcm9vdC5faW50ZXJuYWxSb290O1xuXG4gICAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdmFyIG9yaWdpbmFsQ2FsbGJhY2sgPSBjYWxsYmFjaztcblxuICAgICAgY2FsbGJhY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBpbnN0YW5jZSA9IGdldFB1YmxpY1Jvb3RJbnN0YW5jZShmaWJlclJvb3QpO1xuICAgICAgICBvcmlnaW5hbENhbGxiYWNrLmNhbGwoaW5zdGFuY2UpO1xuICAgICAgfTtcbiAgICB9IC8vIEluaXRpYWwgbW91bnQgc2hvdWxkIG5vdCBiZSBiYXRjaGVkLlxuXG5cbiAgICB1bmJhdGNoZWRVcGRhdGVzKGZ1bmN0aW9uICgpIHtcbiAgICAgIHVwZGF0ZUNvbnRhaW5lcihjaGlsZHJlbiwgZmliZXJSb290LCBwYXJlbnRDb21wb25lbnQsIGNhbGxiYWNrKTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBmaWJlclJvb3QgPSByb290Ll9pbnRlcm5hbFJvb3Q7XG5cbiAgICBpZiAodHlwZW9mIGNhbGxiYWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB2YXIgX29yaWdpbmFsQ2FsbGJhY2sgPSBjYWxsYmFjaztcblxuICAgICAgY2FsbGJhY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBpbnN0YW5jZSA9IGdldFB1YmxpY1Jvb3RJbnN0YW5jZShmaWJlclJvb3QpO1xuXG4gICAgICAgIF9vcmlnaW5hbENhbGxiYWNrLmNhbGwoaW5zdGFuY2UpO1xuICAgICAgfTtcbiAgICB9IC8vIFVwZGF0ZVxuXG5cbiAgICB1cGRhdGVDb250YWluZXIoY2hpbGRyZW4sIGZpYmVyUm9vdCwgcGFyZW50Q29tcG9uZW50LCBjYWxsYmFjayk7XG4gIH1cblxuICByZXR1cm4gZ2V0UHVibGljUm9vdEluc3RhbmNlKGZpYmVyUm9vdCk7XG59XG5cbmZ1bmN0aW9uIGZpbmRET01Ob2RlKGNvbXBvbmVudE9yRWxlbWVudCkge1xuICB7XG4gICAgdmFyIG93bmVyID0gUmVhY3RDdXJyZW50T3duZXIkMy5jdXJyZW50O1xuXG4gICAgaWYgKG93bmVyICE9PSBudWxsICYmIG93bmVyLnN0YXRlTm9kZSAhPT0gbnVsbCkge1xuICAgICAgdmFyIHdhcm5lZEFib3V0UmVmc0luUmVuZGVyID0gb3duZXIuc3RhdGVOb2RlLl93YXJuZWRBYm91dFJlZnNJblJlbmRlcjtcblxuICAgICAgaWYgKCF3YXJuZWRBYm91dFJlZnNJblJlbmRlcikge1xuICAgICAgICBlcnJvcignJXMgaXMgYWNjZXNzaW5nIGZpbmRET01Ob2RlIGluc2lkZSBpdHMgcmVuZGVyKCkuICcgKyAncmVuZGVyKCkgc2hvdWxkIGJlIGEgcHVyZSBmdW5jdGlvbiBvZiBwcm9wcyBhbmQgc3RhdGUuIEl0IHNob3VsZCAnICsgJ25ldmVyIGFjY2VzcyBzb21ldGhpbmcgdGhhdCByZXF1aXJlcyBzdGFsZSBkYXRhIGZyb20gdGhlIHByZXZpb3VzICcgKyAncmVuZGVyLCBzdWNoIGFzIHJlZnMuIE1vdmUgdGhpcyBsb2dpYyB0byBjb21wb25lbnREaWRNb3VudCBhbmQgJyArICdjb21wb25lbnREaWRVcGRhdGUgaW5zdGVhZC4nLCBnZXRDb21wb25lbnROYW1lKG93bmVyLnR5cGUpIHx8ICdBIGNvbXBvbmVudCcpO1xuICAgICAgfVxuXG4gICAgICBvd25lci5zdGF0ZU5vZGUuX3dhcm5lZEFib3V0UmVmc0luUmVuZGVyID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICBpZiAoY29tcG9uZW50T3JFbGVtZW50ID09IG51bGwpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGlmIChjb21wb25lbnRPckVsZW1lbnQubm9kZVR5cGUgPT09IEVMRU1FTlRfTk9ERSkge1xuICAgIHJldHVybiBjb21wb25lbnRPckVsZW1lbnQ7XG4gIH1cblxuICB7XG4gICAgcmV0dXJuIGZpbmRIb3N0SW5zdGFuY2VXaXRoV2FybmluZyhjb21wb25lbnRPckVsZW1lbnQsICdmaW5kRE9NTm9kZScpO1xuICB9XG59XG5mdW5jdGlvbiBoeWRyYXRlKGVsZW1lbnQsIGNvbnRhaW5lciwgY2FsbGJhY2spIHtcbiAgaWYgKCFpc1ZhbGlkQ29udGFpbmVyKGNvbnRhaW5lcikpIHtcbiAgICB7XG4gICAgICB0aHJvdyBFcnJvciggXCJUYXJnZXQgY29udGFpbmVyIGlzIG5vdCBhIERPTSBlbGVtZW50LlwiICk7XG4gICAgfVxuICB9XG5cbiAge1xuICAgIHZhciBpc01vZGVyblJvb3QgPSBpc0NvbnRhaW5lck1hcmtlZEFzUm9vdChjb250YWluZXIpICYmIGNvbnRhaW5lci5fcmVhY3RSb290Q29udGFpbmVyID09PSB1bmRlZmluZWQ7XG5cbiAgICBpZiAoaXNNb2Rlcm5Sb290KSB7XG4gICAgICBlcnJvcignWW91IGFyZSBjYWxsaW5nIFJlYWN0RE9NLmh5ZHJhdGUoKSBvbiBhIGNvbnRhaW5lciB0aGF0IHdhcyBwcmV2aW91c2x5ICcgKyAncGFzc2VkIHRvIFJlYWN0RE9NLmNyZWF0ZVJvb3QoKS4gVGhpcyBpcyBub3Qgc3VwcG9ydGVkLiAnICsgJ0RpZCB5b3UgbWVhbiB0byBjYWxsIGNyZWF0ZVJvb3QoY29udGFpbmVyLCB7aHlkcmF0ZTogdHJ1ZX0pLnJlbmRlcihlbGVtZW50KT8nKTtcbiAgICB9XG4gIH0gLy8gVE9ETzogdGhyb3cgb3Igd2FybiBpZiB3ZSBjb3VsZG4ndCBoeWRyYXRlP1xuXG5cbiAgcmV0dXJuIGxlZ2FjeVJlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyKG51bGwsIGVsZW1lbnQsIGNvbnRhaW5lciwgdHJ1ZSwgY2FsbGJhY2spO1xufVxuZnVuY3Rpb24gcmVuZGVyKGVsZW1lbnQsIGNvbnRhaW5lciwgY2FsbGJhY2spIHtcbiAgaWYgKCFpc1ZhbGlkQ29udGFpbmVyKGNvbnRhaW5lcikpIHtcbiAgICB7XG4gICAgICB0aHJvdyBFcnJvciggXCJUYXJnZXQgY29udGFpbmVyIGlzIG5vdCBhIERPTSBlbGVtZW50LlwiICk7XG4gICAgfVxuICB9XG5cbiAge1xuICAgIHZhciBpc01vZGVyblJvb3QgPSBpc0NvbnRhaW5lck1hcmtlZEFzUm9vdChjb250YWluZXIpICYmIGNvbnRhaW5lci5fcmVhY3RSb290Q29udGFpbmVyID09PSB1bmRlZmluZWQ7XG5cbiAgICBpZiAoaXNNb2Rlcm5Sb290KSB7XG4gICAgICBlcnJvcignWW91IGFyZSBjYWxsaW5nIFJlYWN0RE9NLnJlbmRlcigpIG9uIGEgY29udGFpbmVyIHRoYXQgd2FzIHByZXZpb3VzbHkgJyArICdwYXNzZWQgdG8gUmVhY3RET00uY3JlYXRlUm9vdCgpLiBUaGlzIGlzIG5vdCBzdXBwb3J0ZWQuICcgKyAnRGlkIHlvdSBtZWFuIHRvIGNhbGwgcm9vdC5yZW5kZXIoZWxlbWVudCk/Jyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGxlZ2FjeVJlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyKG51bGwsIGVsZW1lbnQsIGNvbnRhaW5lciwgZmFsc2UsIGNhbGxiYWNrKTtcbn1cbmZ1bmN0aW9uIHVuc3RhYmxlX3JlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyKHBhcmVudENvbXBvbmVudCwgZWxlbWVudCwgY29udGFpbmVyTm9kZSwgY2FsbGJhY2spIHtcbiAgaWYgKCFpc1ZhbGlkQ29udGFpbmVyKGNvbnRhaW5lck5vZGUpKSB7XG4gICAge1xuICAgICAgdGhyb3cgRXJyb3IoIFwiVGFyZ2V0IGNvbnRhaW5lciBpcyBub3QgYSBET00gZWxlbWVudC5cIiApO1xuICAgIH1cbiAgfVxuXG4gIGlmICghKHBhcmVudENvbXBvbmVudCAhPSBudWxsICYmIGhhcyhwYXJlbnRDb21wb25lbnQpKSkge1xuICAgIHtcbiAgICAgIHRocm93IEVycm9yKCBcInBhcmVudENvbXBvbmVudCBtdXN0IGJlIGEgdmFsaWQgUmVhY3QgQ29tcG9uZW50XCIgKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbGVnYWN5UmVuZGVyU3VidHJlZUludG9Db250YWluZXIocGFyZW50Q29tcG9uZW50LCBlbGVtZW50LCBjb250YWluZXJOb2RlLCBmYWxzZSwgY2FsbGJhY2spO1xufVxuZnVuY3Rpb24gdW5tb3VudENvbXBvbmVudEF0Tm9kZShjb250YWluZXIpIHtcbiAgaWYgKCFpc1ZhbGlkQ29udGFpbmVyKGNvbnRhaW5lcikpIHtcbiAgICB7XG4gICAgICB0aHJvdyBFcnJvciggXCJ1bm1vdW50Q29tcG9uZW50QXROb2RlKC4uLik6IFRhcmdldCBjb250YWluZXIgaXMgbm90IGEgRE9NIGVsZW1lbnQuXCIgKTtcbiAgICB9XG4gIH1cblxuICB7XG4gICAgdmFyIGlzTW9kZXJuUm9vdCA9IGlzQ29udGFpbmVyTWFya2VkQXNSb290KGNvbnRhaW5lcikgJiYgY29udGFpbmVyLl9yZWFjdFJvb3RDb250YWluZXIgPT09IHVuZGVmaW5lZDtcblxuICAgIGlmIChpc01vZGVyblJvb3QpIHtcbiAgICAgIGVycm9yKCdZb3UgYXJlIGNhbGxpbmcgUmVhY3RET00udW5tb3VudENvbXBvbmVudEF0Tm9kZSgpIG9uIGEgY29udGFpbmVyIHRoYXQgd2FzIHByZXZpb3VzbHkgJyArICdwYXNzZWQgdG8gUmVhY3RET00uY3JlYXRlUm9vdCgpLiBUaGlzIGlzIG5vdCBzdXBwb3J0ZWQuIERpZCB5b3UgbWVhbiB0byBjYWxsIHJvb3QudW5tb3VudCgpPycpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChjb250YWluZXIuX3JlYWN0Um9vdENvbnRhaW5lcikge1xuICAgIHtcbiAgICAgIHZhciByb290RWwgPSBnZXRSZWFjdFJvb3RFbGVtZW50SW5Db250YWluZXIoY29udGFpbmVyKTtcbiAgICAgIHZhciByZW5kZXJlZEJ5RGlmZmVyZW50UmVhY3QgPSByb290RWwgJiYgIWdldEluc3RhbmNlRnJvbU5vZGUocm9vdEVsKTtcblxuICAgICAgaWYgKHJlbmRlcmVkQnlEaWZmZXJlbnRSZWFjdCkge1xuICAgICAgICBlcnJvcihcInVubW91bnRDb21wb25lbnRBdE5vZGUoKTogVGhlIG5vZGUgeW91J3JlIGF0dGVtcHRpbmcgdG8gdW5tb3VudCBcIiArICd3YXMgcmVuZGVyZWQgYnkgYW5vdGhlciBjb3B5IG9mIFJlYWN0LicpO1xuICAgICAgfVxuICAgIH0gLy8gVW5tb3VudCBzaG91bGQgbm90IGJlIGJhdGNoZWQuXG5cblxuICAgIHVuYmF0Y2hlZFVwZGF0ZXMoZnVuY3Rpb24gKCkge1xuICAgICAgbGVnYWN5UmVuZGVyU3VidHJlZUludG9Db250YWluZXIobnVsbCwgbnVsbCwgY29udGFpbmVyLCBmYWxzZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyAkRmxvd0ZpeE1lIFRoaXMgc2hvdWxkIHByb2JhYmx5IHVzZSBgZGVsZXRlIGNvbnRhaW5lci5fcmVhY3RSb290Q29udGFpbmVyYFxuICAgICAgICBjb250YWluZXIuX3JlYWN0Um9vdENvbnRhaW5lciA9IG51bGw7XG4gICAgICAgIHVubWFya0NvbnRhaW5lckFzUm9vdChjb250YWluZXIpO1xuICAgICAgfSk7XG4gICAgfSk7IC8vIElmIHlvdSBjYWxsIHVubW91bnRDb21wb25lbnRBdE5vZGUgdHdpY2UgaW4gcXVpY2sgc3VjY2Vzc2lvbiwgeW91J2xsXG4gICAgLy8gZ2V0IGB0cnVlYCB0d2ljZS4gVGhhdCdzIHByb2JhYmx5IGZpbmU/XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBlbHNlIHtcbiAgICB7XG4gICAgICB2YXIgX3Jvb3RFbCA9IGdldFJlYWN0Um9vdEVsZW1lbnRJbkNvbnRhaW5lcihjb250YWluZXIpO1xuXG4gICAgICB2YXIgaGFzTm9uUm9vdFJlYWN0Q2hpbGQgPSAhIShfcm9vdEVsICYmIGdldEluc3RhbmNlRnJvbU5vZGUoX3Jvb3RFbCkpOyAvLyBDaGVjayBpZiB0aGUgY29udGFpbmVyIGl0c2VsZiBpcyBhIFJlYWN0IHJvb3Qgbm9kZS5cblxuICAgICAgdmFyIGlzQ29udGFpbmVyUmVhY3RSb290ID0gY29udGFpbmVyLm5vZGVUeXBlID09PSBFTEVNRU5UX05PREUgJiYgaXNWYWxpZENvbnRhaW5lcihjb250YWluZXIucGFyZW50Tm9kZSkgJiYgISFjb250YWluZXIucGFyZW50Tm9kZS5fcmVhY3RSb290Q29udGFpbmVyO1xuXG4gICAgICBpZiAoaGFzTm9uUm9vdFJlYWN0Q2hpbGQpIHtcbiAgICAgICAgZXJyb3IoXCJ1bm1vdW50Q29tcG9uZW50QXROb2RlKCk6IFRoZSBub2RlIHlvdSdyZSBhdHRlbXB0aW5nIHRvIHVubW91bnQgXCIgKyAnd2FzIHJlbmRlcmVkIGJ5IFJlYWN0IGFuZCBpcyBub3QgYSB0b3AtbGV2ZWwgY29udGFpbmVyLiAlcycsIGlzQ29udGFpbmVyUmVhY3RSb290ID8gJ1lvdSBtYXkgaGF2ZSBhY2NpZGVudGFsbHkgcGFzc2VkIGluIGEgUmVhY3Qgcm9vdCBub2RlIGluc3RlYWQgJyArICdvZiBpdHMgY29udGFpbmVyLicgOiAnSW5zdGVhZCwgaGF2ZSB0aGUgcGFyZW50IGNvbXBvbmVudCB1cGRhdGUgaXRzIHN0YXRlIGFuZCAnICsgJ3JlcmVuZGVyIGluIG9yZGVyIHRvIHJlbW92ZSB0aGlzIGNvbXBvbmVudC4nKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuc2V0QXR0ZW1wdFVzZXJCbG9ja2luZ0h5ZHJhdGlvbihhdHRlbXB0VXNlckJsb2NraW5nSHlkcmF0aW9uJDEpO1xuc2V0QXR0ZW1wdENvbnRpbnVvdXNIeWRyYXRpb24oYXR0ZW1wdENvbnRpbnVvdXNIeWRyYXRpb24kMSk7XG5zZXRBdHRlbXB0SHlkcmF0aW9uQXRDdXJyZW50UHJpb3JpdHkoYXR0ZW1wdEh5ZHJhdGlvbkF0Q3VycmVudFByaW9yaXR5JDEpO1xuc2V0QXR0ZW1wdEh5ZHJhdGlvbkF0UHJpb3JpdHkocnVuV2l0aFByaW9yaXR5JDIpO1xudmFyIGRpZFdhcm5BYm91dFVuc3RhYmxlQ3JlYXRlUG9ydGFsID0gZmFsc2U7XG5cbntcbiAgaWYgKHR5cGVvZiBNYXAgIT09ICdmdW5jdGlvbicgfHwgLy8gJEZsb3dJc3N1ZSBGbG93IGluY29ycmVjdGx5IHRoaW5rcyBNYXAgaGFzIG5vIHByb3RvdHlwZVxuICBNYXAucHJvdG90eXBlID09IG51bGwgfHwgdHlwZW9mIE1hcC5wcm90b3R5cGUuZm9yRWFjaCAhPT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgU2V0ICE9PSAnZnVuY3Rpb24nIHx8IC8vICRGbG93SXNzdWUgRmxvdyBpbmNvcnJlY3RseSB0aGlua3MgU2V0IGhhcyBubyBwcm90b3R5cGVcbiAgU2V0LnByb3RvdHlwZSA9PSBudWxsIHx8IHR5cGVvZiBTZXQucHJvdG90eXBlLmNsZWFyICE9PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBTZXQucHJvdG90eXBlLmZvckVhY2ggIT09ICdmdW5jdGlvbicpIHtcbiAgICBlcnJvcignUmVhY3QgZGVwZW5kcyBvbiBNYXAgYW5kIFNldCBidWlsdC1pbiB0eXBlcy4gTWFrZSBzdXJlIHRoYXQgeW91IGxvYWQgYSAnICsgJ3BvbHlmaWxsIGluIG9sZGVyIGJyb3dzZXJzLiBodHRwczovL3JlYWN0anMub3JnL2xpbmsvcmVhY3QtcG9seWZpbGxzJyk7XG4gIH1cbn1cblxuc2V0UmVzdG9yZUltcGxlbWVudGF0aW9uKHJlc3RvcmVDb250cm9sbGVkU3RhdGUkMyk7XG5zZXRCYXRjaGluZ0ltcGxlbWVudGF0aW9uKGJhdGNoZWRVcGRhdGVzJDEsIGRpc2NyZXRlVXBkYXRlcyQxLCBmbHVzaERpc2NyZXRlVXBkYXRlcywgYmF0Y2hlZEV2ZW50VXBkYXRlcyQxKTtcblxuZnVuY3Rpb24gY3JlYXRlUG9ydGFsJDEoY2hpbGRyZW4sIGNvbnRhaW5lcikge1xuICB2YXIga2V5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBudWxsO1xuXG4gIGlmICghaXNWYWxpZENvbnRhaW5lcihjb250YWluZXIpKSB7XG4gICAge1xuICAgICAgdGhyb3cgRXJyb3IoIFwiVGFyZ2V0IGNvbnRhaW5lciBpcyBub3QgYSBET00gZWxlbWVudC5cIiApO1xuICAgIH1cbiAgfSAvLyBUT0RPOiBwYXNzIFJlYWN0RE9NIHBvcnRhbCBpbXBsZW1lbnRhdGlvbiBhcyB0aGlyZCBhcmd1bWVudFxuICAvLyAkRmxvd0ZpeE1lIFRoZSBGbG93IHR5cGUgaXMgb3BhcXVlIGJ1dCB0aGVyZSdzIG5vIHdheSB0byBhY3R1YWxseSBjcmVhdGUgaXQuXG5cblxuICByZXR1cm4gY3JlYXRlUG9ydGFsKGNoaWxkcmVuLCBjb250YWluZXIsIG51bGwsIGtleSk7XG59XG5cbmZ1bmN0aW9uIHJlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyKHBhcmVudENvbXBvbmVudCwgZWxlbWVudCwgY29udGFpbmVyTm9kZSwgY2FsbGJhY2spIHtcblxuICByZXR1cm4gdW5zdGFibGVfcmVuZGVyU3VidHJlZUludG9Db250YWluZXIocGFyZW50Q29tcG9uZW50LCBlbGVtZW50LCBjb250YWluZXJOb2RlLCBjYWxsYmFjayk7XG59XG5cbmZ1bmN0aW9uIHVuc3RhYmxlX2NyZWF0ZVBvcnRhbChjaGlsZHJlbiwgY29udGFpbmVyKSB7XG4gIHZhciBrZXkgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IG51bGw7XG5cbiAge1xuICAgIGlmICghZGlkV2FybkFib3V0VW5zdGFibGVDcmVhdGVQb3J0YWwpIHtcbiAgICAgIGRpZFdhcm5BYm91dFVuc3RhYmxlQ3JlYXRlUG9ydGFsID0gdHJ1ZTtcblxuICAgICAgd2FybignVGhlIFJlYWN0RE9NLnVuc3RhYmxlX2NyZWF0ZVBvcnRhbCgpIGFsaWFzIGhhcyBiZWVuIGRlcHJlY2F0ZWQsICcgKyAnYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiBSZWFjdCAxOCsuIFVwZGF0ZSB5b3VyIGNvZGUgdG8gdXNlICcgKyAnUmVhY3RET00uY3JlYXRlUG9ydGFsKCkgaW5zdGVhZC4gSXQgaGFzIHRoZSBleGFjdCBzYW1lIEFQSSwgJyArICdidXQgd2l0aG91dCB0aGUgXCJ1bnN0YWJsZV9cIiBwcmVmaXguJyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGNyZWF0ZVBvcnRhbCQxKGNoaWxkcmVuLCBjb250YWluZXIsIGtleSk7XG59XG5cbnZhciBJbnRlcm5hbHMgPSB7XG4gIC8vIEtlZXAgaW4gc3luYyB3aXRoIFJlYWN0VGVzdFV0aWxzLmpzLCBhbmQgUmVhY3RUZXN0VXRpbHNBY3QuanMuXG4gIC8vIFRoaXMgaXMgYW4gYXJyYXkgZm9yIGJldHRlciBtaW5pZmljYXRpb24uXG4gIEV2ZW50czogW2dldEluc3RhbmNlRnJvbU5vZGUsIGdldE5vZGVGcm9tSW5zdGFuY2UsIGdldEZpYmVyQ3VycmVudFByb3BzRnJvbU5vZGUsIGVucXVldWVTdGF0ZVJlc3RvcmUsIHJlc3RvcmVTdGF0ZUlmTmVlZGVkLCBmbHVzaFBhc3NpdmVFZmZlY3RzLCAvLyBUT0RPOiBUaGlzIGlzIHJlbGF0ZWQgdG8gYGFjdGAsIG5vdCBldmVudHMuIE1vdmUgdG8gc2VwYXJhdGUga2V5P1xuICBJc1RoaXNSZW5kZXJlckFjdGluZ11cbn07XG52YXIgZm91bmREZXZUb29scyA9IGluamVjdEludG9EZXZUb29scyh7XG4gIGZpbmRGaWJlckJ5SG9zdEluc3RhbmNlOiBnZXRDbG9zZXN0SW5zdGFuY2VGcm9tTm9kZSxcbiAgYnVuZGxlVHlwZTogIDEgLFxuICB2ZXJzaW9uOiBSZWFjdFZlcnNpb24sXG4gIHJlbmRlcmVyUGFja2FnZU5hbWU6ICdyZWFjdC1kb20nXG59KTtcblxue1xuICBpZiAoIWZvdW5kRGV2VG9vbHMgJiYgY2FuVXNlRE9NICYmIHdpbmRvdy50b3AgPT09IHdpbmRvdy5zZWxmKSB7XG4gICAgLy8gSWYgd2UncmUgaW4gQ2hyb21lIG9yIEZpcmVmb3gsIHByb3ZpZGUgYSBkb3dubG9hZCBsaW5rIGlmIG5vdCBpbnN0YWxsZWQuXG4gICAgaWYgKG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZignQ2hyb21lJykgPiAtMSAmJiBuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoJ0VkZ2UnKSA9PT0gLTEgfHwgbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCdGaXJlZm94JykgPiAtMSkge1xuICAgICAgdmFyIHByb3RvY29sID0gd2luZG93LmxvY2F0aW9uLnByb3RvY29sOyAvLyBEb24ndCB3YXJuIGluIGV4b3RpYyBjYXNlcyBsaWtlIGNocm9tZS1leHRlbnNpb246Ly8uXG5cbiAgICAgIGlmICgvXihodHRwcz98ZmlsZSk6JC8udGVzdChwcm90b2NvbCkpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZ1xuICAgICAgICBjb25zb2xlLmluZm8oJyVjRG93bmxvYWQgdGhlIFJlYWN0IERldlRvb2xzICcgKyAnZm9yIGEgYmV0dGVyIGRldmVsb3BtZW50IGV4cGVyaWVuY2U6ICcgKyAnaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3JlYWN0LWRldnRvb2xzJyArIChwcm90b2NvbCA9PT0gJ2ZpbGU6JyA/ICdcXG5Zb3UgbWlnaHQgbmVlZCB0byB1c2UgYSBsb2NhbCBIVFRQIHNlcnZlciAoaW5zdGVhZCBvZiBmaWxlOi8vKTogJyArICdodHRwczovL3JlYWN0anMub3JnL2xpbmsvcmVhY3QtZGV2dG9vbHMtZmFxJyA6ICcnKSwgJ2ZvbnQtd2VpZ2h0OmJvbGQnKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0cy5fX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRCA9IEludGVybmFscztcbmV4cG9ydHMuY3JlYXRlUG9ydGFsID0gY3JlYXRlUG9ydGFsJDE7XG5leHBvcnRzLmZpbmRET01Ob2RlID0gZmluZERPTU5vZGU7XG5leHBvcnRzLmZsdXNoU3luYyA9IGZsdXNoU3luYztcbmV4cG9ydHMuaHlkcmF0ZSA9IGh5ZHJhdGU7XG5leHBvcnRzLnJlbmRlciA9IHJlbmRlcjtcbmV4cG9ydHMudW5tb3VudENvbXBvbmVudEF0Tm9kZSA9IHVubW91bnRDb21wb25lbnRBdE5vZGU7XG5leHBvcnRzLnVuc3RhYmxlX2JhdGNoZWRVcGRhdGVzID0gYmF0Y2hlZFVwZGF0ZXMkMTtcbmV4cG9ydHMudW5zdGFibGVfY3JlYXRlUG9ydGFsID0gdW5zdGFibGVfY3JlYXRlUG9ydGFsO1xuZXhwb3J0cy51bnN0YWJsZV9yZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lciA9IHJlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyO1xuZXhwb3J0cy52ZXJzaW9uID0gUmVhY3RWZXJzaW9uO1xuICB9KSgpO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBjaGVja0RDRSgpIHtcbiAgLyogZ2xvYmFsIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyAqL1xuICBpZiAoXG4gICAgdHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyA9PT0gJ3VuZGVmaW5lZCcgfHxcbiAgICB0eXBlb2YgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fLmNoZWNrRENFICE9PSAnZnVuY3Rpb24nXG4gICkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIC8vIFRoaXMgYnJhbmNoIGlzIHVucmVhY2hhYmxlIGJlY2F1c2UgdGhpcyBmdW5jdGlvbiBpcyBvbmx5IGNhbGxlZFxuICAgIC8vIGluIHByb2R1Y3Rpb24sIGJ1dCB0aGUgY29uZGl0aW9uIGlzIHRydWUgb25seSBpbiBkZXZlbG9wbWVudC5cbiAgICAvLyBUaGVyZWZvcmUgaWYgdGhlIGJyYW5jaCBpcyBzdGlsbCBoZXJlLCBkZWFkIGNvZGUgZWxpbWluYXRpb24gd2Fzbid0XG4gICAgLy8gcHJvcGVybHkgYXBwbGllZC5cbiAgICAvLyBEb24ndCBjaGFuZ2UgdGhlIG1lc3NhZ2UuIFJlYWN0IERldlRvb2xzIHJlbGllcyBvbiBpdC4gQWxzbyBtYWtlIHN1cmVcbiAgICAvLyB0aGlzIG1lc3NhZ2UgZG9lc24ndCBvY2N1ciBlbHNld2hlcmUgaW4gdGhpcyBmdW5jdGlvbiwgb3IgaXQgd2lsbCBjYXVzZVxuICAgIC8vIGEgZmFsc2UgcG9zaXRpdmUuXG4gICAgdGhyb3cgbmV3IEVycm9yKCdeX14nKTtcbiAgfVxuICB0cnkge1xuICAgIC8vIFZlcmlmeSB0aGF0IHRoZSBjb2RlIGFib3ZlIGhhcyBiZWVuIGRlYWQgY29kZSBlbGltaW5hdGVkIChEQ0UnZCkuXG4gICAgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fLmNoZWNrRENFKGNoZWNrRENFKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgLy8gRGV2VG9vbHMgc2hvdWxkbid0IGNyYXNoIFJlYWN0LCBubyBtYXR0ZXIgd2hhdC5cbiAgICAvLyBXZSBzaG91bGQgc3RpbGwgcmVwb3J0IGluIGNhc2Ugd2UgYnJlYWsgdGhpcyBjb2RlLlxuICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcbiAgfVxufVxuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJykge1xuICAvLyBEQ0UgY2hlY2sgc2hvdWxkIGhhcHBlbiBiZWZvcmUgUmVhY3RET00gYnVuZGxlIGV4ZWN1dGVzIHNvIHRoYXRcbiAgLy8gRGV2VG9vbHMgY2FuIHJlcG9ydCBiYWQgbWluaWZpY2F0aW9uIGR1cmluZyBpbmplY3Rpb24uXG4gIGNoZWNrRENFKCk7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtZG9tLnByb2R1Y3Rpb24ubWluLmpzJyk7XG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LWRvbS5kZXZlbG9wbWVudC5qcycpO1xufVxuIiwiLyoqIEBsaWNlbnNlIFJlYWN0IHYxNy4wLjJcbiAqIHJlYWN0LmRldmVsb3BtZW50LmpzXG4gKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gIChmdW5jdGlvbigpIHtcbid1c2Ugc3RyaWN0JztcblxudmFyIF9hc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG5cbi8vIFRPRE86IHRoaXMgaXMgc3BlY2lhbCBiZWNhdXNlIGl0IGdldHMgaW1wb3J0ZWQgZHVyaW5nIGJ1aWxkLlxudmFyIFJlYWN0VmVyc2lvbiA9ICcxNy4wLjInO1xuXG4vLyBBVFRFTlRJT05cbi8vIFdoZW4gYWRkaW5nIG5ldyBzeW1ib2xzIHRvIHRoaXMgZmlsZSxcbi8vIFBsZWFzZSBjb25zaWRlciBhbHNvIGFkZGluZyB0byAncmVhY3QtZGV2dG9vbHMtc2hhcmVkL3NyYy9iYWNrZW5kL1JlYWN0U3ltYm9scydcbi8vIFRoZSBTeW1ib2wgdXNlZCB0byB0YWcgdGhlIFJlYWN0RWxlbWVudC1saWtlIHR5cGVzLiBJZiB0aGVyZSBpcyBubyBuYXRpdmUgU3ltYm9sXG4vLyBub3IgcG9seWZpbGwsIHRoZW4gYSBwbGFpbiBudW1iZXIgaXMgdXNlZCBmb3IgcGVyZm9ybWFuY2UuXG52YXIgUkVBQ1RfRUxFTUVOVF9UWVBFID0gMHhlYWM3O1xudmFyIFJFQUNUX1BPUlRBTF9UWVBFID0gMHhlYWNhO1xuZXhwb3J0cy5GcmFnbWVudCA9IDB4ZWFjYjtcbmV4cG9ydHMuU3RyaWN0TW9kZSA9IDB4ZWFjYztcbmV4cG9ydHMuUHJvZmlsZXIgPSAweGVhZDI7XG52YXIgUkVBQ1RfUFJPVklERVJfVFlQRSA9IDB4ZWFjZDtcbnZhciBSRUFDVF9DT05URVhUX1RZUEUgPSAweGVhY2U7XG52YXIgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSA9IDB4ZWFkMDtcbmV4cG9ydHMuU3VzcGVuc2UgPSAweGVhZDE7XG52YXIgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFID0gMHhlYWQ4O1xudmFyIFJFQUNUX01FTU9fVFlQRSA9IDB4ZWFkMztcbnZhciBSRUFDVF9MQVpZX1RZUEUgPSAweGVhZDQ7XG52YXIgUkVBQ1RfQkxPQ0tfVFlQRSA9IDB4ZWFkOTtcbnZhciBSRUFDVF9TRVJWRVJfQkxPQ0tfVFlQRSA9IDB4ZWFkYTtcbnZhciBSRUFDVF9GVU5EQU1FTlRBTF9UWVBFID0gMHhlYWQ1O1xudmFyIFJFQUNUX1NDT1BFX1RZUEUgPSAweGVhZDc7XG52YXIgUkVBQ1RfT1BBUVVFX0lEX1RZUEUgPSAweGVhZTA7XG52YXIgUkVBQ1RfREVCVUdfVFJBQ0lOR19NT0RFX1RZUEUgPSAweGVhZTE7XG52YXIgUkVBQ1RfT0ZGU0NSRUVOX1RZUEUgPSAweGVhZTI7XG52YXIgUkVBQ1RfTEVHQUNZX0hJRERFTl9UWVBFID0gMHhlYWUzO1xuXG5pZiAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wuZm9yKSB7XG4gIHZhciBzeW1ib2xGb3IgPSBTeW1ib2wuZm9yO1xuICBSRUFDVF9FTEVNRU5UX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LmVsZW1lbnQnKTtcbiAgUkVBQ1RfUE9SVEFMX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LnBvcnRhbCcpO1xuICBleHBvcnRzLkZyYWdtZW50ID0gc3ltYm9sRm9yKCdyZWFjdC5mcmFnbWVudCcpO1xuICBleHBvcnRzLlN0cmljdE1vZGUgPSBzeW1ib2xGb3IoJ3JlYWN0LnN0cmljdF9tb2RlJyk7XG4gIGV4cG9ydHMuUHJvZmlsZXIgPSBzeW1ib2xGb3IoJ3JlYWN0LnByb2ZpbGVyJyk7XG4gIFJFQUNUX1BST1ZJREVSX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LnByb3ZpZGVyJyk7XG4gIFJFQUNUX0NPTlRFWFRfVFlQRSA9IHN5bWJvbEZvcigncmVhY3QuY29udGV4dCcpO1xuICBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5mb3J3YXJkX3JlZicpO1xuICBleHBvcnRzLlN1c3BlbnNlID0gc3ltYm9sRm9yKCdyZWFjdC5zdXNwZW5zZScpO1xuICBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LnN1c3BlbnNlX2xpc3QnKTtcbiAgUkVBQ1RfTUVNT19UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5tZW1vJyk7XG4gIFJFQUNUX0xBWllfVFlQRSA9IHN5bWJvbEZvcigncmVhY3QubGF6eScpO1xuICBSRUFDVF9CTE9DS19UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5ibG9jaycpO1xuICBSRUFDVF9TRVJWRVJfQkxPQ0tfVFlQRSA9IHN5bWJvbEZvcigncmVhY3Quc2VydmVyLmJsb2NrJyk7XG4gIFJFQUNUX0ZVTkRBTUVOVEFMX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LmZ1bmRhbWVudGFsJyk7XG4gIFJFQUNUX1NDT1BFX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LnNjb3BlJyk7XG4gIFJFQUNUX09QQVFVRV9JRF9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5vcGFxdWUuaWQnKTtcbiAgUkVBQ1RfREVCVUdfVFJBQ0lOR19NT0RFX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LmRlYnVnX3RyYWNlX21vZGUnKTtcbiAgUkVBQ1RfT0ZGU0NSRUVOX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0Lm9mZnNjcmVlbicpO1xuICBSRUFDVF9MRUdBQ1lfSElEREVOX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LmxlZ2FjeV9oaWRkZW4nKTtcbn1cblxudmFyIE1BWUJFX0lURVJBVE9SX1NZTUJPTCA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLml0ZXJhdG9yO1xudmFyIEZBVVhfSVRFUkFUT1JfU1lNQk9MID0gJ0BAaXRlcmF0b3InO1xuZnVuY3Rpb24gZ2V0SXRlcmF0b3JGbihtYXliZUl0ZXJhYmxlKSB7XG4gIGlmIChtYXliZUl0ZXJhYmxlID09PSBudWxsIHx8IHR5cGVvZiBtYXliZUl0ZXJhYmxlICE9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIG1heWJlSXRlcmF0b3IgPSBNQVlCRV9JVEVSQVRPUl9TWU1CT0wgJiYgbWF5YmVJdGVyYWJsZVtNQVlCRV9JVEVSQVRPUl9TWU1CT0xdIHx8IG1heWJlSXRlcmFibGVbRkFVWF9JVEVSQVRPUl9TWU1CT0xdO1xuXG4gIGlmICh0eXBlb2YgbWF5YmVJdGVyYXRvciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBtYXliZUl0ZXJhdG9yO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbi8qKlxuICogS2VlcHMgdHJhY2sgb2YgdGhlIGN1cnJlbnQgZGlzcGF0Y2hlci5cbiAqL1xudmFyIFJlYWN0Q3VycmVudERpc3BhdGNoZXIgPSB7XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICogQHR5cGUge1JlYWN0Q29tcG9uZW50fVxuICAgKi9cbiAgY3VycmVudDogbnVsbFxufTtcblxuLyoqXG4gKiBLZWVwcyB0cmFjayBvZiB0aGUgY3VycmVudCBiYXRjaCdzIGNvbmZpZ3VyYXRpb24gc3VjaCBhcyBob3cgbG9uZyBhbiB1cGRhdGVcbiAqIHNob3VsZCBzdXNwZW5kIGZvciBpZiBpdCBuZWVkcyB0by5cbiAqL1xudmFyIFJlYWN0Q3VycmVudEJhdGNoQ29uZmlnID0ge1xuICB0cmFuc2l0aW9uOiAwXG59O1xuXG4vKipcbiAqIEtlZXBzIHRyYWNrIG9mIHRoZSBjdXJyZW50IG93bmVyLlxuICpcbiAqIFRoZSBjdXJyZW50IG93bmVyIGlzIHRoZSBjb21wb25lbnQgd2hvIHNob3VsZCBvd24gYW55IGNvbXBvbmVudHMgdGhhdCBhcmVcbiAqIGN1cnJlbnRseSBiZWluZyBjb25zdHJ1Y3RlZC5cbiAqL1xudmFyIFJlYWN0Q3VycmVudE93bmVyID0ge1xuICAvKipcbiAgICogQGludGVybmFsXG4gICAqIEB0eXBlIHtSZWFjdENvbXBvbmVudH1cbiAgICovXG4gIGN1cnJlbnQ6IG51bGxcbn07XG5cbnZhciBSZWFjdERlYnVnQ3VycmVudEZyYW1lID0ge307XG52YXIgY3VycmVudEV4dHJhU3RhY2tGcmFtZSA9IG51bGw7XG5mdW5jdGlvbiBzZXRFeHRyYVN0YWNrRnJhbWUoc3RhY2spIHtcbiAge1xuICAgIGN1cnJlbnRFeHRyYVN0YWNrRnJhbWUgPSBzdGFjaztcbiAgfVxufVxuXG57XG4gIFJlYWN0RGVidWdDdXJyZW50RnJhbWUuc2V0RXh0cmFTdGFja0ZyYW1lID0gZnVuY3Rpb24gKHN0YWNrKSB7XG4gICAge1xuICAgICAgY3VycmVudEV4dHJhU3RhY2tGcmFtZSA9IHN0YWNrO1xuICAgIH1cbiAgfTsgLy8gU3RhY2sgaW1wbGVtZW50YXRpb24gaW5qZWN0ZWQgYnkgdGhlIGN1cnJlbnQgcmVuZGVyZXIuXG5cblxuICBSZWFjdERlYnVnQ3VycmVudEZyYW1lLmdldEN1cnJlbnRTdGFjayA9IG51bGw7XG5cbiAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5nZXRTdGFja0FkZGVuZHVtID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBzdGFjayA9ICcnOyAvLyBBZGQgYW4gZXh0cmEgdG9wIGZyYW1lIHdoaWxlIGFuIGVsZW1lbnQgaXMgYmVpbmcgdmFsaWRhdGVkXG5cbiAgICBpZiAoY3VycmVudEV4dHJhU3RhY2tGcmFtZSkge1xuICAgICAgc3RhY2sgKz0gY3VycmVudEV4dHJhU3RhY2tGcmFtZTtcbiAgICB9IC8vIERlbGVnYXRlIHRvIHRoZSBpbmplY3RlZCByZW5kZXJlci1zcGVjaWZpYyBpbXBsZW1lbnRhdGlvblxuXG5cbiAgICB2YXIgaW1wbCA9IFJlYWN0RGVidWdDdXJyZW50RnJhbWUuZ2V0Q3VycmVudFN0YWNrO1xuXG4gICAgaWYgKGltcGwpIHtcbiAgICAgIHN0YWNrICs9IGltcGwoKSB8fCAnJztcbiAgICB9XG5cbiAgICByZXR1cm4gc3RhY2s7XG4gIH07XG59XG5cbi8qKlxuICogVXNlZCBieSBhY3QoKSB0byB0cmFjayB3aGV0aGVyIHlvdSdyZSBpbnNpZGUgYW4gYWN0KCkgc2NvcGUuXG4gKi9cbnZhciBJc1NvbWVSZW5kZXJlckFjdGluZyA9IHtcbiAgY3VycmVudDogZmFsc2Vcbn07XG5cbnZhciBSZWFjdFNoYXJlZEludGVybmFscyA9IHtcbiAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlcjogUmVhY3RDdXJyZW50RGlzcGF0Y2hlcixcbiAgUmVhY3RDdXJyZW50QmF0Y2hDb25maWc6IFJlYWN0Q3VycmVudEJhdGNoQ29uZmlnLFxuICBSZWFjdEN1cnJlbnRPd25lcjogUmVhY3RDdXJyZW50T3duZXIsXG4gIElzU29tZVJlbmRlcmVyQWN0aW5nOiBJc1NvbWVSZW5kZXJlckFjdGluZyxcbiAgLy8gVXNlZCBieSByZW5kZXJlcnMgdG8gYXZvaWQgYnVuZGxpbmcgb2JqZWN0LWFzc2lnbiB0d2ljZSBpbiBVTUQgYnVuZGxlczpcbiAgYXNzaWduOiBfYXNzaWduXG59O1xuXG57XG4gIFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0RGVidWdDdXJyZW50RnJhbWUgPSBSZWFjdERlYnVnQ3VycmVudEZyYW1lO1xufVxuXG4vLyBieSBjYWxscyB0byB0aGVzZSBtZXRob2RzIGJ5IGEgQmFiZWwgcGx1Z2luLlxuLy9cbi8vIEluIFBST0QgKG9yIGluIHBhY2thZ2VzIHdpdGhvdXQgYWNjZXNzIHRvIFJlYWN0IGludGVybmFscyksXG4vLyB0aGV5IGFyZSBsZWZ0IGFzIHRoZXkgYXJlIGluc3RlYWQuXG5cbmZ1bmN0aW9uIHdhcm4oZm9ybWF0KSB7XG4gIHtcbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICBwcmludFdhcm5pbmcoJ3dhcm4nLCBmb3JtYXQsIGFyZ3MpO1xuICB9XG59XG5mdW5jdGlvbiBlcnJvcihmb3JtYXQpIHtcbiAge1xuICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMiA+IDEgPyBfbGVuMiAtIDEgOiAwKSwgX2tleTIgPSAxOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICBhcmdzW19rZXkyIC0gMV0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgIH1cblxuICAgIHByaW50V2FybmluZygnZXJyb3InLCBmb3JtYXQsIGFyZ3MpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHByaW50V2FybmluZyhsZXZlbCwgZm9ybWF0LCBhcmdzKSB7XG4gIC8vIFdoZW4gY2hhbmdpbmcgdGhpcyBsb2dpYywgeW91IG1pZ2h0IHdhbnQgdG8gYWxzb1xuICAvLyB1cGRhdGUgY29uc29sZVdpdGhTdGFja0Rldi53d3cuanMgYXMgd2VsbC5cbiAge1xuICAgIHZhciBSZWFjdERlYnVnQ3VycmVudEZyYW1lID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZTtcbiAgICB2YXIgc3RhY2sgPSBSZWFjdERlYnVnQ3VycmVudEZyYW1lLmdldFN0YWNrQWRkZW5kdW0oKTtcblxuICAgIGlmIChzdGFjayAhPT0gJycpIHtcbiAgICAgIGZvcm1hdCArPSAnJXMnO1xuICAgICAgYXJncyA9IGFyZ3MuY29uY2F0KFtzdGFja10pO1xuICAgIH1cblxuICAgIHZhciBhcmdzV2l0aEZvcm1hdCA9IGFyZ3MubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICByZXR1cm4gJycgKyBpdGVtO1xuICAgIH0pOyAvLyBDYXJlZnVsOiBSTiBjdXJyZW50bHkgZGVwZW5kcyBvbiB0aGlzIHByZWZpeFxuXG4gICAgYXJnc1dpdGhGb3JtYXQudW5zaGlmdCgnV2FybmluZzogJyArIGZvcm1hdCk7IC8vIFdlIGludGVudGlvbmFsbHkgZG9uJ3QgdXNlIHNwcmVhZCAob3IgLmFwcGx5KSBkaXJlY3RseSBiZWNhdXNlIGl0XG4gICAgLy8gYnJlYWtzIElFOTogaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xMzYxMFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmdcblxuICAgIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5jYWxsKGNvbnNvbGVbbGV2ZWxdLCBjb25zb2xlLCBhcmdzV2l0aEZvcm1hdCk7XG4gIH1cbn1cblxudmFyIGRpZFdhcm5TdGF0ZVVwZGF0ZUZvclVubW91bnRlZENvbXBvbmVudCA9IHt9O1xuXG5mdW5jdGlvbiB3YXJuTm9vcChwdWJsaWNJbnN0YW5jZSwgY2FsbGVyTmFtZSkge1xuICB7XG4gICAgdmFyIF9jb25zdHJ1Y3RvciA9IHB1YmxpY0luc3RhbmNlLmNvbnN0cnVjdG9yO1xuICAgIHZhciBjb21wb25lbnROYW1lID0gX2NvbnN0cnVjdG9yICYmIChfY29uc3RydWN0b3IuZGlzcGxheU5hbWUgfHwgX2NvbnN0cnVjdG9yLm5hbWUpIHx8ICdSZWFjdENsYXNzJztcbiAgICB2YXIgd2FybmluZ0tleSA9IGNvbXBvbmVudE5hbWUgKyBcIi5cIiArIGNhbGxlck5hbWU7XG5cbiAgICBpZiAoZGlkV2FyblN0YXRlVXBkYXRlRm9yVW5tb3VudGVkQ29tcG9uZW50W3dhcm5pbmdLZXldKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZXJyb3IoXCJDYW4ndCBjYWxsICVzIG9uIGEgY29tcG9uZW50IHRoYXQgaXMgbm90IHlldCBtb3VudGVkLiBcIiArICdUaGlzIGlzIGEgbm8tb3AsIGJ1dCBpdCBtaWdodCBpbmRpY2F0ZSBhIGJ1ZyBpbiB5b3VyIGFwcGxpY2F0aW9uLiAnICsgJ0luc3RlYWQsIGFzc2lnbiB0byBgdGhpcy5zdGF0ZWAgZGlyZWN0bHkgb3IgZGVmaW5lIGEgYHN0YXRlID0ge307YCAnICsgJ2NsYXNzIHByb3BlcnR5IHdpdGggdGhlIGRlc2lyZWQgc3RhdGUgaW4gdGhlICVzIGNvbXBvbmVudC4nLCBjYWxsZXJOYW1lLCBjb21wb25lbnROYW1lKTtcblxuICAgIGRpZFdhcm5TdGF0ZVVwZGF0ZUZvclVubW91bnRlZENvbXBvbmVudFt3YXJuaW5nS2V5XSA9IHRydWU7XG4gIH1cbn1cbi8qKlxuICogVGhpcyBpcyB0aGUgYWJzdHJhY3QgQVBJIGZvciBhbiB1cGRhdGUgcXVldWUuXG4gKi9cblxuXG52YXIgUmVhY3ROb29wVXBkYXRlUXVldWUgPSB7XG4gIC8qKlxuICAgKiBDaGVja3Mgd2hldGhlciBvciBub3QgdGhpcyBjb21wb3NpdGUgY29tcG9uZW50IGlzIG1vdW50ZWQuXG4gICAqIEBwYXJhbSB7UmVhY3RDbGFzc30gcHVibGljSW5zdGFuY2UgVGhlIGluc3RhbmNlIHdlIHdhbnQgdG8gdGVzdC5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBtb3VudGVkLCBmYWxzZSBvdGhlcndpc2UuXG4gICAqIEBwcm90ZWN0ZWRcbiAgICogQGZpbmFsXG4gICAqL1xuICBpc01vdW50ZWQ6IGZ1bmN0aW9uIChwdWJsaWNJbnN0YW5jZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSxcblxuICAvKipcbiAgICogRm9yY2VzIGFuIHVwZGF0ZS4gVGhpcyBzaG91bGQgb25seSBiZSBpbnZva2VkIHdoZW4gaXQgaXMga25vd24gd2l0aFxuICAgKiBjZXJ0YWludHkgdGhhdCB3ZSBhcmUgKipub3QqKiBpbiBhIERPTSB0cmFuc2FjdGlvbi5cbiAgICpcbiAgICogWW91IG1heSB3YW50IHRvIGNhbGwgdGhpcyB3aGVuIHlvdSBrbm93IHRoYXQgc29tZSBkZWVwZXIgYXNwZWN0IG9mIHRoZVxuICAgKiBjb21wb25lbnQncyBzdGF0ZSBoYXMgY2hhbmdlZCBidXQgYHNldFN0YXRlYCB3YXMgbm90IGNhbGxlZC5cbiAgICpcbiAgICogVGhpcyB3aWxsIG5vdCBpbnZva2UgYHNob3VsZENvbXBvbmVudFVwZGF0ZWAsIGJ1dCBpdCB3aWxsIGludm9rZVxuICAgKiBgY29tcG9uZW50V2lsbFVwZGF0ZWAgYW5kIGBjb21wb25lbnREaWRVcGRhdGVgLlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0Q2xhc3N9IHB1YmxpY0luc3RhbmNlIFRoZSBpbnN0YW5jZSB0aGF0IHNob3VsZCByZXJlbmRlci5cbiAgICogQHBhcmFtIHs/ZnVuY3Rpb259IGNhbGxiYWNrIENhbGxlZCBhZnRlciBjb21wb25lbnQgaXMgdXBkYXRlZC5cbiAgICogQHBhcmFtIHs/c3RyaW5nfSBjYWxsZXJOYW1lIG5hbWUgb2YgdGhlIGNhbGxpbmcgZnVuY3Rpb24gaW4gdGhlIHB1YmxpYyBBUEkuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZW5xdWV1ZUZvcmNlVXBkYXRlOiBmdW5jdGlvbiAocHVibGljSW5zdGFuY2UsIGNhbGxiYWNrLCBjYWxsZXJOYW1lKSB7XG4gICAgd2Fybk5vb3AocHVibGljSW5zdGFuY2UsICdmb3JjZVVwZGF0ZScpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXBsYWNlcyBhbGwgb2YgdGhlIHN0YXRlLiBBbHdheXMgdXNlIHRoaXMgb3IgYHNldFN0YXRlYCB0byBtdXRhdGUgc3RhdGUuXG4gICAqIFlvdSBzaG91bGQgdHJlYXQgYHRoaXMuc3RhdGVgIGFzIGltbXV0YWJsZS5cbiAgICpcbiAgICogVGhlcmUgaXMgbm8gZ3VhcmFudGVlIHRoYXQgYHRoaXMuc3RhdGVgIHdpbGwgYmUgaW1tZWRpYXRlbHkgdXBkYXRlZCwgc29cbiAgICogYWNjZXNzaW5nIGB0aGlzLnN0YXRlYCBhZnRlciBjYWxsaW5nIHRoaXMgbWV0aG9kIG1heSByZXR1cm4gdGhlIG9sZCB2YWx1ZS5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdENsYXNzfSBwdWJsaWNJbnN0YW5jZSBUaGUgaW5zdGFuY2UgdGhhdCBzaG91bGQgcmVyZW5kZXIuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBjb21wbGV0ZVN0YXRlIE5leHQgc3RhdGUuXG4gICAqIEBwYXJhbSB7P2Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsZWQgYWZ0ZXIgY29tcG9uZW50IGlzIHVwZGF0ZWQuXG4gICAqIEBwYXJhbSB7P3N0cmluZ30gY2FsbGVyTmFtZSBuYW1lIG9mIHRoZSBjYWxsaW5nIGZ1bmN0aW9uIGluIHRoZSBwdWJsaWMgQVBJLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGVucXVldWVSZXBsYWNlU3RhdGU6IGZ1bmN0aW9uIChwdWJsaWNJbnN0YW5jZSwgY29tcGxldGVTdGF0ZSwgY2FsbGJhY2ssIGNhbGxlck5hbWUpIHtcbiAgICB3YXJuTm9vcChwdWJsaWNJbnN0YW5jZSwgJ3JlcGxhY2VTdGF0ZScpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBTZXRzIGEgc3Vic2V0IG9mIHRoZSBzdGF0ZS4gVGhpcyBvbmx5IGV4aXN0cyBiZWNhdXNlIF9wZW5kaW5nU3RhdGUgaXNcbiAgICogaW50ZXJuYWwuIFRoaXMgcHJvdmlkZXMgYSBtZXJnaW5nIHN0cmF0ZWd5IHRoYXQgaXMgbm90IGF2YWlsYWJsZSB0byBkZWVwXG4gICAqIHByb3BlcnRpZXMgd2hpY2ggaXMgY29uZnVzaW5nLiBUT0RPOiBFeHBvc2UgcGVuZGluZ1N0YXRlIG9yIGRvbid0IHVzZSBpdFxuICAgKiBkdXJpbmcgdGhlIG1lcmdlLlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0Q2xhc3N9IHB1YmxpY0luc3RhbmNlIFRoZSBpbnN0YW5jZSB0aGF0IHNob3VsZCByZXJlbmRlci5cbiAgICogQHBhcmFtIHtvYmplY3R9IHBhcnRpYWxTdGF0ZSBOZXh0IHBhcnRpYWwgc3RhdGUgdG8gYmUgbWVyZ2VkIHdpdGggc3RhdGUuXG4gICAqIEBwYXJhbSB7P2Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsZWQgYWZ0ZXIgY29tcG9uZW50IGlzIHVwZGF0ZWQuXG4gICAqIEBwYXJhbSB7P3N0cmluZ30gTmFtZSBvZiB0aGUgY2FsbGluZyBmdW5jdGlvbiBpbiB0aGUgcHVibGljIEFQSS5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBlbnF1ZXVlU2V0U3RhdGU6IGZ1bmN0aW9uIChwdWJsaWNJbnN0YW5jZSwgcGFydGlhbFN0YXRlLCBjYWxsYmFjaywgY2FsbGVyTmFtZSkge1xuICAgIHdhcm5Ob29wKHB1YmxpY0luc3RhbmNlLCAnc2V0U3RhdGUnKTtcbiAgfVxufTtcblxudmFyIGVtcHR5T2JqZWN0ID0ge307XG5cbntcbiAgT2JqZWN0LmZyZWV6ZShlbXB0eU9iamVjdCk7XG59XG4vKipcbiAqIEJhc2UgY2xhc3MgaGVscGVycyBmb3IgdGhlIHVwZGF0aW5nIHN0YXRlIG9mIGEgY29tcG9uZW50LlxuICovXG5cblxuZnVuY3Rpb24gQ29tcG9uZW50KHByb3BzLCBjb250ZXh0LCB1cGRhdGVyKSB7XG4gIHRoaXMucHJvcHMgPSBwcm9wcztcbiAgdGhpcy5jb250ZXh0ID0gY29udGV4dDsgLy8gSWYgYSBjb21wb25lbnQgaGFzIHN0cmluZyByZWZzLCB3ZSB3aWxsIGFzc2lnbiBhIGRpZmZlcmVudCBvYmplY3QgbGF0ZXIuXG5cbiAgdGhpcy5yZWZzID0gZW1wdHlPYmplY3Q7IC8vIFdlIGluaXRpYWxpemUgdGhlIGRlZmF1bHQgdXBkYXRlciBidXQgdGhlIHJlYWwgb25lIGdldHMgaW5qZWN0ZWQgYnkgdGhlXG4gIC8vIHJlbmRlcmVyLlxuXG4gIHRoaXMudXBkYXRlciA9IHVwZGF0ZXIgfHwgUmVhY3ROb29wVXBkYXRlUXVldWU7XG59XG5cbkNvbXBvbmVudC5wcm90b3R5cGUuaXNSZWFjdENvbXBvbmVudCA9IHt9O1xuLyoqXG4gKiBTZXRzIGEgc3Vic2V0IG9mIHRoZSBzdGF0ZS4gQWx3YXlzIHVzZSB0aGlzIHRvIG11dGF0ZVxuICogc3RhdGUuIFlvdSBzaG91bGQgdHJlYXQgYHRoaXMuc3RhdGVgIGFzIGltbXV0YWJsZS5cbiAqXG4gKiBUaGVyZSBpcyBubyBndWFyYW50ZWUgdGhhdCBgdGhpcy5zdGF0ZWAgd2lsbCBiZSBpbW1lZGlhdGVseSB1cGRhdGVkLCBzb1xuICogYWNjZXNzaW5nIGB0aGlzLnN0YXRlYCBhZnRlciBjYWxsaW5nIHRoaXMgbWV0aG9kIG1heSByZXR1cm4gdGhlIG9sZCB2YWx1ZS5cbiAqXG4gKiBUaGVyZSBpcyBubyBndWFyYW50ZWUgdGhhdCBjYWxscyB0byBgc2V0U3RhdGVgIHdpbGwgcnVuIHN5bmNocm9ub3VzbHksXG4gKiBhcyB0aGV5IG1heSBldmVudHVhbGx5IGJlIGJhdGNoZWQgdG9nZXRoZXIuICBZb3UgY2FuIHByb3ZpZGUgYW4gb3B0aW9uYWxcbiAqIGNhbGxiYWNrIHRoYXQgd2lsbCBiZSBleGVjdXRlZCB3aGVuIHRoZSBjYWxsIHRvIHNldFN0YXRlIGlzIGFjdHVhbGx5XG4gKiBjb21wbGV0ZWQuXG4gKlxuICogV2hlbiBhIGZ1bmN0aW9uIGlzIHByb3ZpZGVkIHRvIHNldFN0YXRlLCBpdCB3aWxsIGJlIGNhbGxlZCBhdCBzb21lIHBvaW50IGluXG4gKiB0aGUgZnV0dXJlIChub3Qgc3luY2hyb25vdXNseSkuIEl0IHdpbGwgYmUgY2FsbGVkIHdpdGggdGhlIHVwIHRvIGRhdGVcbiAqIGNvbXBvbmVudCBhcmd1bWVudHMgKHN0YXRlLCBwcm9wcywgY29udGV4dCkuIFRoZXNlIHZhbHVlcyBjYW4gYmUgZGlmZmVyZW50XG4gKiBmcm9tIHRoaXMuKiBiZWNhdXNlIHlvdXIgZnVuY3Rpb24gbWF5IGJlIGNhbGxlZCBhZnRlciByZWNlaXZlUHJvcHMgYnV0IGJlZm9yZVxuICogc2hvdWxkQ29tcG9uZW50VXBkYXRlLCBhbmQgdGhpcyBuZXcgc3RhdGUsIHByb3BzLCBhbmQgY29udGV4dCB3aWxsIG5vdCB5ZXQgYmVcbiAqIGFzc2lnbmVkIHRvIHRoaXMuXG4gKlxuICogQHBhcmFtIHtvYmplY3R8ZnVuY3Rpb259IHBhcnRpYWxTdGF0ZSBOZXh0IHBhcnRpYWwgc3RhdGUgb3IgZnVuY3Rpb24gdG9cbiAqICAgICAgICBwcm9kdWNlIG5leHQgcGFydGlhbCBzdGF0ZSB0byBiZSBtZXJnZWQgd2l0aCBjdXJyZW50IHN0YXRlLlxuICogQHBhcmFtIHs/ZnVuY3Rpb259IGNhbGxiYWNrIENhbGxlZCBhZnRlciBzdGF0ZSBpcyB1cGRhdGVkLlxuICogQGZpbmFsXG4gKiBAcHJvdGVjdGVkXG4gKi9cblxuQ29tcG9uZW50LnByb3RvdHlwZS5zZXRTdGF0ZSA9IGZ1bmN0aW9uIChwYXJ0aWFsU3RhdGUsIGNhbGxiYWNrKSB7XG4gIGlmICghKHR5cGVvZiBwYXJ0aWFsU3RhdGUgPT09ICdvYmplY3QnIHx8IHR5cGVvZiBwYXJ0aWFsU3RhdGUgPT09ICdmdW5jdGlvbicgfHwgcGFydGlhbFN0YXRlID09IG51bGwpKSB7XG4gICAge1xuICAgICAgdGhyb3cgRXJyb3IoIFwic2V0U3RhdGUoLi4uKTogdGFrZXMgYW4gb2JqZWN0IG9mIHN0YXRlIHZhcmlhYmxlcyB0byB1cGRhdGUgb3IgYSBmdW5jdGlvbiB3aGljaCByZXR1cm5zIGFuIG9iamVjdCBvZiBzdGF0ZSB2YXJpYWJsZXMuXCIgKTtcbiAgICB9XG4gIH1cblxuICB0aGlzLnVwZGF0ZXIuZW5xdWV1ZVNldFN0YXRlKHRoaXMsIHBhcnRpYWxTdGF0ZSwgY2FsbGJhY2ssICdzZXRTdGF0ZScpO1xufTtcbi8qKlxuICogRm9yY2VzIGFuIHVwZGF0ZS4gVGhpcyBzaG91bGQgb25seSBiZSBpbnZva2VkIHdoZW4gaXQgaXMga25vd24gd2l0aFxuICogY2VydGFpbnR5IHRoYXQgd2UgYXJlICoqbm90KiogaW4gYSBET00gdHJhbnNhY3Rpb24uXG4gKlxuICogWW91IG1heSB3YW50IHRvIGNhbGwgdGhpcyB3aGVuIHlvdSBrbm93IHRoYXQgc29tZSBkZWVwZXIgYXNwZWN0IG9mIHRoZVxuICogY29tcG9uZW50J3Mgc3RhdGUgaGFzIGNoYW5nZWQgYnV0IGBzZXRTdGF0ZWAgd2FzIG5vdCBjYWxsZWQuXG4gKlxuICogVGhpcyB3aWxsIG5vdCBpbnZva2UgYHNob3VsZENvbXBvbmVudFVwZGF0ZWAsIGJ1dCBpdCB3aWxsIGludm9rZVxuICogYGNvbXBvbmVudFdpbGxVcGRhdGVgIGFuZCBgY29tcG9uZW50RGlkVXBkYXRlYC5cbiAqXG4gKiBAcGFyYW0gez9mdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGVkIGFmdGVyIHVwZGF0ZSBpcyBjb21wbGV0ZS5cbiAqIEBmaW5hbFxuICogQHByb3RlY3RlZFxuICovXG5cblxuQ29tcG9uZW50LnByb3RvdHlwZS5mb3JjZVVwZGF0ZSA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICB0aGlzLnVwZGF0ZXIuZW5xdWV1ZUZvcmNlVXBkYXRlKHRoaXMsIGNhbGxiYWNrLCAnZm9yY2VVcGRhdGUnKTtcbn07XG4vKipcbiAqIERlcHJlY2F0ZWQgQVBJcy4gVGhlc2UgQVBJcyB1c2VkIHRvIGV4aXN0IG9uIGNsYXNzaWMgUmVhY3QgY2xhc3NlcyBidXQgc2luY2VcbiAqIHdlIHdvdWxkIGxpa2UgdG8gZGVwcmVjYXRlIHRoZW0sIHdlJ3JlIG5vdCBnb2luZyB0byBtb3ZlIHRoZW0gb3ZlciB0byB0aGlzXG4gKiBtb2Rlcm4gYmFzZSBjbGFzcy4gSW5zdGVhZCwgd2UgZGVmaW5lIGEgZ2V0dGVyIHRoYXQgd2FybnMgaWYgaXQncyBhY2Nlc3NlZC5cbiAqL1xuXG5cbntcbiAgdmFyIGRlcHJlY2F0ZWRBUElzID0ge1xuICAgIGlzTW91bnRlZDogWydpc01vdW50ZWQnLCAnSW5zdGVhZCwgbWFrZSBzdXJlIHRvIGNsZWFuIHVwIHN1YnNjcmlwdGlvbnMgYW5kIHBlbmRpbmcgcmVxdWVzdHMgaW4gJyArICdjb21wb25lbnRXaWxsVW5tb3VudCB0byBwcmV2ZW50IG1lbW9yeSBsZWFrcy4nXSxcbiAgICByZXBsYWNlU3RhdGU6IFsncmVwbGFjZVN0YXRlJywgJ1JlZmFjdG9yIHlvdXIgY29kZSB0byB1c2Ugc2V0U3RhdGUgaW5zdGVhZCAoc2VlICcgKyAnaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8zMjM2KS4nXVxuICB9O1xuXG4gIHZhciBkZWZpbmVEZXByZWNhdGlvbldhcm5pbmcgPSBmdW5jdGlvbiAobWV0aG9kTmFtZSwgaW5mbykge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb21wb25lbnQucHJvdG90eXBlLCBtZXRob2ROYW1lLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgd2FybignJXMoLi4uKSBpcyBkZXByZWNhdGVkIGluIHBsYWluIEphdmFTY3JpcHQgUmVhY3QgY2xhc3Nlcy4gJXMnLCBpbmZvWzBdLCBpbmZvWzFdKTtcblxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuXG4gIGZvciAodmFyIGZuTmFtZSBpbiBkZXByZWNhdGVkQVBJcykge1xuICAgIGlmIChkZXByZWNhdGVkQVBJcy5oYXNPd25Qcm9wZXJ0eShmbk5hbWUpKSB7XG4gICAgICBkZWZpbmVEZXByZWNhdGlvbldhcm5pbmcoZm5OYW1lLCBkZXByZWNhdGVkQVBJc1tmbk5hbWVdKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gQ29tcG9uZW50RHVtbXkoKSB7fVxuXG5Db21wb25lbnREdW1teS5wcm90b3R5cGUgPSBDb21wb25lbnQucHJvdG90eXBlO1xuLyoqXG4gKiBDb252ZW5pZW5jZSBjb21wb25lbnQgd2l0aCBkZWZhdWx0IHNoYWxsb3cgZXF1YWxpdHkgY2hlY2sgZm9yIHNDVS5cbiAqL1xuXG5mdW5jdGlvbiBQdXJlQ29tcG9uZW50KHByb3BzLCBjb250ZXh0LCB1cGRhdGVyKSB7XG4gIHRoaXMucHJvcHMgPSBwcm9wcztcbiAgdGhpcy5jb250ZXh0ID0gY29udGV4dDsgLy8gSWYgYSBjb21wb25lbnQgaGFzIHN0cmluZyByZWZzLCB3ZSB3aWxsIGFzc2lnbiBhIGRpZmZlcmVudCBvYmplY3QgbGF0ZXIuXG5cbiAgdGhpcy5yZWZzID0gZW1wdHlPYmplY3Q7XG4gIHRoaXMudXBkYXRlciA9IHVwZGF0ZXIgfHwgUmVhY3ROb29wVXBkYXRlUXVldWU7XG59XG5cbnZhciBwdXJlQ29tcG9uZW50UHJvdG90eXBlID0gUHVyZUNvbXBvbmVudC5wcm90b3R5cGUgPSBuZXcgQ29tcG9uZW50RHVtbXkoKTtcbnB1cmVDb21wb25lbnRQcm90b3R5cGUuY29uc3RydWN0b3IgPSBQdXJlQ29tcG9uZW50OyAvLyBBdm9pZCBhbiBleHRyYSBwcm90b3R5cGUganVtcCBmb3IgdGhlc2UgbWV0aG9kcy5cblxuX2Fzc2lnbihwdXJlQ29tcG9uZW50UHJvdG90eXBlLCBDb21wb25lbnQucHJvdG90eXBlKTtcblxucHVyZUNvbXBvbmVudFByb3RvdHlwZS5pc1B1cmVSZWFjdENvbXBvbmVudCA9IHRydWU7XG5cbi8vIGFuIGltbXV0YWJsZSBvYmplY3Qgd2l0aCBhIHNpbmdsZSBtdXRhYmxlIHZhbHVlXG5mdW5jdGlvbiBjcmVhdGVSZWYoKSB7XG4gIHZhciByZWZPYmplY3QgPSB7XG4gICAgY3VycmVudDogbnVsbFxuICB9O1xuXG4gIHtcbiAgICBPYmplY3Quc2VhbChyZWZPYmplY3QpO1xuICB9XG5cbiAgcmV0dXJuIHJlZk9iamVjdDtcbn1cblxuZnVuY3Rpb24gZ2V0V3JhcHBlZE5hbWUob3V0ZXJUeXBlLCBpbm5lclR5cGUsIHdyYXBwZXJOYW1lKSB7XG4gIHZhciBmdW5jdGlvbk5hbWUgPSBpbm5lclR5cGUuZGlzcGxheU5hbWUgfHwgaW5uZXJUeXBlLm5hbWUgfHwgJyc7XG4gIHJldHVybiBvdXRlclR5cGUuZGlzcGxheU5hbWUgfHwgKGZ1bmN0aW9uTmFtZSAhPT0gJycgPyB3cmFwcGVyTmFtZSArIFwiKFwiICsgZnVuY3Rpb25OYW1lICsgXCIpXCIgOiB3cmFwcGVyTmFtZSk7XG59XG5cbmZ1bmN0aW9uIGdldENvbnRleHROYW1lKHR5cGUpIHtcbiAgcmV0dXJuIHR5cGUuZGlzcGxheU5hbWUgfHwgJ0NvbnRleHQnO1xufVxuXG5mdW5jdGlvbiBnZXRDb21wb25lbnROYW1lKHR5cGUpIHtcbiAgaWYgKHR5cGUgPT0gbnVsbCkge1xuICAgIC8vIEhvc3Qgcm9vdCwgdGV4dCBub2RlIG9yIGp1c3QgaW52YWxpZCB0eXBlLlxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAge1xuICAgIGlmICh0eXBlb2YgdHlwZS50YWcgPT09ICdudW1iZXInKSB7XG4gICAgICBlcnJvcignUmVjZWl2ZWQgYW4gdW5leHBlY3RlZCBvYmplY3QgaW4gZ2V0Q29tcG9uZW50TmFtZSgpLiAnICsgJ1RoaXMgaXMgbGlrZWx5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICB9XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gdHlwZS5kaXNwbGF5TmFtZSB8fCB0eXBlLm5hbWUgfHwgbnVsbDtcbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gdHlwZTtcbiAgfVxuXG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgZXhwb3J0cy5GcmFnbWVudDpcbiAgICAgIHJldHVybiAnRnJhZ21lbnQnO1xuXG4gICAgY2FzZSBSRUFDVF9QT1JUQUxfVFlQRTpcbiAgICAgIHJldHVybiAnUG9ydGFsJztcblxuICAgIGNhc2UgZXhwb3J0cy5Qcm9maWxlcjpcbiAgICAgIHJldHVybiAnUHJvZmlsZXInO1xuXG4gICAgY2FzZSBleHBvcnRzLlN0cmljdE1vZGU6XG4gICAgICByZXR1cm4gJ1N0cmljdE1vZGUnO1xuXG4gICAgY2FzZSBleHBvcnRzLlN1c3BlbnNlOlxuICAgICAgcmV0dXJuICdTdXNwZW5zZSc7XG5cbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTpcbiAgICAgIHJldHVybiAnU3VzcGVuc2VMaXN0JztcbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICBzd2l0Y2ggKHR5cGUuJCR0eXBlb2YpIHtcbiAgICAgIGNhc2UgUkVBQ1RfQ09OVEVYVF9UWVBFOlxuICAgICAgICB2YXIgY29udGV4dCA9IHR5cGU7XG4gICAgICAgIHJldHVybiBnZXRDb250ZXh0TmFtZShjb250ZXh0KSArICcuQ29uc3VtZXInO1xuXG4gICAgICBjYXNlIFJFQUNUX1BST1ZJREVSX1RZUEU6XG4gICAgICAgIHZhciBwcm92aWRlciA9IHR5cGU7XG4gICAgICAgIHJldHVybiBnZXRDb250ZXh0TmFtZShwcm92aWRlci5fY29udGV4dCkgKyAnLlByb3ZpZGVyJztcblxuICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxuICAgICAgICByZXR1cm4gZ2V0V3JhcHBlZE5hbWUodHlwZSwgdHlwZS5yZW5kZXIsICdGb3J3YXJkUmVmJyk7XG5cbiAgICAgIGNhc2UgUkVBQ1RfTUVNT19UWVBFOlxuICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50TmFtZSh0eXBlLnR5cGUpO1xuXG4gICAgICBjYXNlIFJFQUNUX0JMT0NLX1RZUEU6XG4gICAgICAgIHJldHVybiBnZXRDb21wb25lbnROYW1lKHR5cGUuX3JlbmRlcik7XG5cbiAgICAgIGNhc2UgUkVBQ1RfTEFaWV9UWVBFOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIGxhenlDb21wb25lbnQgPSB0eXBlO1xuICAgICAgICAgIHZhciBwYXlsb2FkID0gbGF6eUNvbXBvbmVudC5fcGF5bG9hZDtcbiAgICAgICAgICB2YXIgaW5pdCA9IGxhenlDb21wb25lbnQuX2luaXQ7XG5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGdldENvbXBvbmVudE5hbWUoaW5pdChwYXlsb2FkKSk7XG4gICAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgUkVTRVJWRURfUFJPUFMgPSB7XG4gIGtleTogdHJ1ZSxcbiAgcmVmOiB0cnVlLFxuICBfX3NlbGY6IHRydWUsXG4gIF9fc291cmNlOiB0cnVlXG59O1xudmFyIHNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duLCBzcGVjaWFsUHJvcFJlZldhcm5pbmdTaG93biwgZGlkV2FybkFib3V0U3RyaW5nUmVmcztcblxue1xuICBkaWRXYXJuQWJvdXRTdHJpbmdSZWZzID0ge307XG59XG5cbmZ1bmN0aW9uIGhhc1ZhbGlkUmVmKGNvbmZpZykge1xuICB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCAncmVmJykpIHtcbiAgICAgIHZhciBnZXR0ZXIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGNvbmZpZywgJ3JlZicpLmdldDtcblxuICAgICAgaWYgKGdldHRlciAmJiBnZXR0ZXIuaXNSZWFjdFdhcm5pbmcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjb25maWcucmVmICE9PSB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIGhhc1ZhbGlkS2V5KGNvbmZpZykge1xuICB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCAna2V5JykpIHtcbiAgICAgIHZhciBnZXR0ZXIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGNvbmZpZywgJ2tleScpLmdldDtcblxuICAgICAgaWYgKGdldHRlciAmJiBnZXR0ZXIuaXNSZWFjdFdhcm5pbmcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjb25maWcua2V5ICE9PSB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIGRlZmluZUtleVByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSkge1xuICB2YXIgd2FybkFib3V0QWNjZXNzaW5nS2V5ID0gZnVuY3Rpb24gKCkge1xuICAgIHtcbiAgICAgIGlmICghc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd24pIHtcbiAgICAgICAgc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd24gPSB0cnVlO1xuXG4gICAgICAgIGVycm9yKCclczogYGtleWAgaXMgbm90IGEgcHJvcC4gVHJ5aW5nIHRvIGFjY2VzcyBpdCB3aWxsIHJlc3VsdCAnICsgJ2luIGB1bmRlZmluZWRgIGJlaW5nIHJldHVybmVkLiBJZiB5b3UgbmVlZCB0byBhY2Nlc3MgdGhlIHNhbWUgJyArICd2YWx1ZSB3aXRoaW4gdGhlIGNoaWxkIGNvbXBvbmVudCwgeW91IHNob3VsZCBwYXNzIGl0IGFzIGEgZGlmZmVyZW50ICcgKyAncHJvcC4gKGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zcGVjaWFsLXByb3BzKScsIGRpc3BsYXlOYW1lKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgd2FybkFib3V0QWNjZXNzaW5nS2V5LmlzUmVhY3RXYXJuaW5nID0gdHJ1ZTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3BzLCAna2V5Jywge1xuICAgIGdldDogd2FybkFib3V0QWNjZXNzaW5nS2V5LFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbn1cblxuZnVuY3Rpb24gZGVmaW5lUmVmUHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKSB7XG4gIHZhciB3YXJuQWJvdXRBY2Nlc3NpbmdSZWYgPSBmdW5jdGlvbiAoKSB7XG4gICAge1xuICAgICAgaWYgKCFzcGVjaWFsUHJvcFJlZldhcm5pbmdTaG93bikge1xuICAgICAgICBzcGVjaWFsUHJvcFJlZldhcm5pbmdTaG93biA9IHRydWU7XG5cbiAgICAgICAgZXJyb3IoJyVzOiBgcmVmYCBpcyBub3QgYSBwcm9wLiBUcnlpbmcgdG8gYWNjZXNzIGl0IHdpbGwgcmVzdWx0ICcgKyAnaW4gYHVuZGVmaW5lZGAgYmVpbmcgcmV0dXJuZWQuIElmIHlvdSBuZWVkIHRvIGFjY2VzcyB0aGUgc2FtZSAnICsgJ3ZhbHVlIHdpdGhpbiB0aGUgY2hpbGQgY29tcG9uZW50LCB5b3Ugc2hvdWxkIHBhc3MgaXQgYXMgYSBkaWZmZXJlbnQgJyArICdwcm9wLiAoaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3NwZWNpYWwtcHJvcHMpJywgZGlzcGxheU5hbWUpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICB3YXJuQWJvdXRBY2Nlc3NpbmdSZWYuaXNSZWFjdFdhcm5pbmcgPSB0cnVlO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvcHMsICdyZWYnLCB7XG4gICAgZ2V0OiB3YXJuQWJvdXRBY2Nlc3NpbmdSZWYsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xufVxuXG5mdW5jdGlvbiB3YXJuSWZTdHJpbmdSZWZDYW5ub3RCZUF1dG9Db252ZXJ0ZWQoY29uZmlnKSB7XG4gIHtcbiAgICBpZiAodHlwZW9mIGNvbmZpZy5yZWYgPT09ICdzdHJpbmcnICYmIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQgJiYgY29uZmlnLl9fc2VsZiAmJiBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LnN0YXRlTm9kZSAhPT0gY29uZmlnLl9fc2VsZikge1xuICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lKFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQudHlwZSk7XG5cbiAgICAgIGlmICghZGlkV2FybkFib3V0U3RyaW5nUmVmc1tjb21wb25lbnROYW1lXSkge1xuICAgICAgICBlcnJvcignQ29tcG9uZW50IFwiJXNcIiBjb250YWlucyB0aGUgc3RyaW5nIHJlZiBcIiVzXCIuICcgKyAnU3VwcG9ydCBmb3Igc3RyaW5nIHJlZnMgd2lsbCBiZSByZW1vdmVkIGluIGEgZnV0dXJlIG1ham9yIHJlbGVhc2UuICcgKyAnVGhpcyBjYXNlIGNhbm5vdCBiZSBhdXRvbWF0aWNhbGx5IGNvbnZlcnRlZCB0byBhbiBhcnJvdyBmdW5jdGlvbi4gJyArICdXZSBhc2sgeW91IHRvIG1hbnVhbGx5IGZpeCB0aGlzIGNhc2UgYnkgdXNpbmcgdXNlUmVmKCkgb3IgY3JlYXRlUmVmKCkgaW5zdGVhZC4gJyArICdMZWFybiBtb3JlIGFib3V0IHVzaW5nIHJlZnMgc2FmZWx5IGhlcmU6ICcgKyAnaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3N0cmljdC1tb2RlLXN0cmluZy1yZWYnLCBjb21wb25lbnROYW1lLCBjb25maWcucmVmKTtcblxuICAgICAgICBkaWRXYXJuQWJvdXRTdHJpbmdSZWZzW2NvbXBvbmVudE5hbWVdID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbi8qKlxuICogRmFjdG9yeSBtZXRob2QgdG8gY3JlYXRlIGEgbmV3IFJlYWN0IGVsZW1lbnQuIFRoaXMgbm8gbG9uZ2VyIGFkaGVyZXMgdG9cbiAqIHRoZSBjbGFzcyBwYXR0ZXJuLCBzbyBkbyBub3QgdXNlIG5ldyB0byBjYWxsIGl0LiBBbHNvLCBpbnN0YW5jZW9mIGNoZWNrXG4gKiB3aWxsIG5vdCB3b3JrLiBJbnN0ZWFkIHRlc3QgJCR0eXBlb2YgZmllbGQgYWdhaW5zdCBTeW1ib2wuZm9yKCdyZWFjdC5lbGVtZW50JykgdG8gY2hlY2tcbiAqIGlmIHNvbWV0aGluZyBpcyBhIFJlYWN0IEVsZW1lbnQuXG4gKlxuICogQHBhcmFtIHsqfSB0eXBlXG4gKiBAcGFyYW0geyp9IHByb3BzXG4gKiBAcGFyYW0geyp9IGtleVxuICogQHBhcmFtIHtzdHJpbmd8b2JqZWN0fSByZWZcbiAqIEBwYXJhbSB7Kn0gb3duZXJcbiAqIEBwYXJhbSB7Kn0gc2VsZiBBICp0ZW1wb3JhcnkqIGhlbHBlciB0byBkZXRlY3QgcGxhY2VzIHdoZXJlIGB0aGlzYCBpc1xuICogZGlmZmVyZW50IGZyb20gdGhlIGBvd25lcmAgd2hlbiBSZWFjdC5jcmVhdGVFbGVtZW50IGlzIGNhbGxlZCwgc28gdGhhdCB3ZVxuICogY2FuIHdhcm4uIFdlIHdhbnQgdG8gZ2V0IHJpZCBvZiBvd25lciBhbmQgcmVwbGFjZSBzdHJpbmcgYHJlZmBzIHdpdGggYXJyb3dcbiAqIGZ1bmN0aW9ucywgYW5kIGFzIGxvbmcgYXMgYHRoaXNgIGFuZCBvd25lciBhcmUgdGhlIHNhbWUsIHRoZXJlIHdpbGwgYmUgbm9cbiAqIGNoYW5nZSBpbiBiZWhhdmlvci5cbiAqIEBwYXJhbSB7Kn0gc291cmNlIEFuIGFubm90YXRpb24gb2JqZWN0IChhZGRlZCBieSBhIHRyYW5zcGlsZXIgb3Igb3RoZXJ3aXNlKVxuICogaW5kaWNhdGluZyBmaWxlbmFtZSwgbGluZSBudW1iZXIsIGFuZC9vciBvdGhlciBpbmZvcm1hdGlvbi5cbiAqIEBpbnRlcm5hbFxuICovXG5cblxudmFyIFJlYWN0RWxlbWVudCA9IGZ1bmN0aW9uICh0eXBlLCBrZXksIHJlZiwgc2VsZiwgc291cmNlLCBvd25lciwgcHJvcHMpIHtcbiAgdmFyIGVsZW1lbnQgPSB7XG4gICAgLy8gVGhpcyB0YWcgYWxsb3dzIHVzIHRvIHVuaXF1ZWx5IGlkZW50aWZ5IHRoaXMgYXMgYSBSZWFjdCBFbGVtZW50XG4gICAgJCR0eXBlb2Y6IFJFQUNUX0VMRU1FTlRfVFlQRSxcbiAgICAvLyBCdWlsdC1pbiBwcm9wZXJ0aWVzIHRoYXQgYmVsb25nIG9uIHRoZSBlbGVtZW50XG4gICAgdHlwZTogdHlwZSxcbiAgICBrZXk6IGtleSxcbiAgICByZWY6IHJlZixcbiAgICBwcm9wczogcHJvcHMsXG4gICAgLy8gUmVjb3JkIHRoZSBjb21wb25lbnQgcmVzcG9uc2libGUgZm9yIGNyZWF0aW5nIHRoaXMgZWxlbWVudC5cbiAgICBfb3duZXI6IG93bmVyXG4gIH07XG5cbiAge1xuICAgIC8vIFRoZSB2YWxpZGF0aW9uIGZsYWcgaXMgY3VycmVudGx5IG11dGF0aXZlLiBXZSBwdXQgaXQgb25cbiAgICAvLyBhbiBleHRlcm5hbCBiYWNraW5nIHN0b3JlIHNvIHRoYXQgd2UgY2FuIGZyZWV6ZSB0aGUgd2hvbGUgb2JqZWN0LlxuICAgIC8vIFRoaXMgY2FuIGJlIHJlcGxhY2VkIHdpdGggYSBXZWFrTWFwIG9uY2UgdGhleSBhcmUgaW1wbGVtZW50ZWQgaW5cbiAgICAvLyBjb21tb25seSB1c2VkIGRldmVsb3BtZW50IGVudmlyb25tZW50cy5cbiAgICBlbGVtZW50Ll9zdG9yZSA9IHt9OyAvLyBUbyBtYWtlIGNvbXBhcmluZyBSZWFjdEVsZW1lbnRzIGVhc2llciBmb3IgdGVzdGluZyBwdXJwb3Nlcywgd2UgbWFrZVxuICAgIC8vIHRoZSB2YWxpZGF0aW9uIGZsYWcgbm9uLWVudW1lcmFibGUgKHdoZXJlIHBvc3NpYmxlLCB3aGljaCBzaG91bGRcbiAgICAvLyBpbmNsdWRlIGV2ZXJ5IGVudmlyb25tZW50IHdlIHJ1biB0ZXN0cyBpbiksIHNvIHRoZSB0ZXN0IGZyYW1ld29ya1xuICAgIC8vIGlnbm9yZXMgaXQuXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudC5fc3RvcmUsICd2YWxpZGF0ZWQnLCB7XG4gICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIHZhbHVlOiBmYWxzZVxuICAgIH0pOyAvLyBzZWxmIGFuZCBzb3VyY2UgYXJlIERFViBvbmx5IHByb3BlcnRpZXMuXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudCwgJ19zZWxmJywge1xuICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgdmFsdWU6IHNlbGZcbiAgICB9KTsgLy8gVHdvIGVsZW1lbnRzIGNyZWF0ZWQgaW4gdHdvIGRpZmZlcmVudCBwbGFjZXMgc2hvdWxkIGJlIGNvbnNpZGVyZWRcbiAgICAvLyBlcXVhbCBmb3IgdGVzdGluZyBwdXJwb3NlcyBhbmQgdGhlcmVmb3JlIHdlIGhpZGUgaXQgZnJvbSBlbnVtZXJhdGlvbi5cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50LCAnX3NvdXJjZScsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgIHZhbHVlOiBzb3VyY2VcbiAgICB9KTtcblxuICAgIGlmIChPYmplY3QuZnJlZXplKSB7XG4gICAgICBPYmplY3QuZnJlZXplKGVsZW1lbnQucHJvcHMpO1xuICAgICAgT2JqZWN0LmZyZWV6ZShlbGVtZW50KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZWxlbWVudDtcbn07XG4vKipcbiAqIENyZWF0ZSBhbmQgcmV0dXJuIGEgbmV3IFJlYWN0RWxlbWVudCBvZiB0aGUgZ2l2ZW4gdHlwZS5cbiAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtYXBpLmh0bWwjY3JlYXRlZWxlbWVudFxuICovXG5cbmZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnQodHlwZSwgY29uZmlnLCBjaGlsZHJlbikge1xuICB2YXIgcHJvcE5hbWU7IC8vIFJlc2VydmVkIG5hbWVzIGFyZSBleHRyYWN0ZWRcblxuICB2YXIgcHJvcHMgPSB7fTtcbiAgdmFyIGtleSA9IG51bGw7XG4gIHZhciByZWYgPSBudWxsO1xuICB2YXIgc2VsZiA9IG51bGw7XG4gIHZhciBzb3VyY2UgPSBudWxsO1xuXG4gIGlmIChjb25maWcgIT0gbnVsbCkge1xuICAgIGlmIChoYXNWYWxpZFJlZihjb25maWcpKSB7XG4gICAgICByZWYgPSBjb25maWcucmVmO1xuXG4gICAgICB7XG4gICAgICAgIHdhcm5JZlN0cmluZ1JlZkNhbm5vdEJlQXV0b0NvbnZlcnRlZChjb25maWcpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChoYXNWYWxpZEtleShjb25maWcpKSB7XG4gICAgICBrZXkgPSAnJyArIGNvbmZpZy5rZXk7XG4gICAgfVxuXG4gICAgc2VsZiA9IGNvbmZpZy5fX3NlbGYgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBjb25maWcuX19zZWxmO1xuICAgIHNvdXJjZSA9IGNvbmZpZy5fX3NvdXJjZSA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGNvbmZpZy5fX3NvdXJjZTsgLy8gUmVtYWluaW5nIHByb3BlcnRpZXMgYXJlIGFkZGVkIHRvIGEgbmV3IHByb3BzIG9iamVjdFxuXG4gICAgZm9yIChwcm9wTmFtZSBpbiBjb25maWcpIHtcbiAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgcHJvcE5hbWUpICYmICFSRVNFUlZFRF9QUk9QUy5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkpIHtcbiAgICAgICAgcHJvcHNbcHJvcE5hbWVdID0gY29uZmlnW3Byb3BOYW1lXTtcbiAgICAgIH1cbiAgICB9XG4gIH0gLy8gQ2hpbGRyZW4gY2FuIGJlIG1vcmUgdGhhbiBvbmUgYXJndW1lbnQsIGFuZCB0aG9zZSBhcmUgdHJhbnNmZXJyZWQgb250b1xuICAvLyB0aGUgbmV3bHkgYWxsb2NhdGVkIHByb3BzIG9iamVjdC5cblxuXG4gIHZhciBjaGlsZHJlbkxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGggLSAyO1xuXG4gIGlmIChjaGlsZHJlbkxlbmd0aCA9PT0gMSkge1xuICAgIHByb3BzLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gIH0gZWxzZSBpZiAoY2hpbGRyZW5MZW5ndGggPiAxKSB7XG4gICAgdmFyIGNoaWxkQXJyYXkgPSBBcnJheShjaGlsZHJlbkxlbmd0aCk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuTGVuZ3RoOyBpKyspIHtcbiAgICAgIGNoaWxkQXJyYXlbaV0gPSBhcmd1bWVudHNbaSArIDJdO1xuICAgIH1cblxuICAgIHtcbiAgICAgIGlmIChPYmplY3QuZnJlZXplKSB7XG4gICAgICAgIE9iamVjdC5mcmVlemUoY2hpbGRBcnJheSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcHJvcHMuY2hpbGRyZW4gPSBjaGlsZEFycmF5O1xuICB9IC8vIFJlc29sdmUgZGVmYXVsdCBwcm9wc1xuXG5cbiAgaWYgKHR5cGUgJiYgdHlwZS5kZWZhdWx0UHJvcHMpIHtcbiAgICB2YXIgZGVmYXVsdFByb3BzID0gdHlwZS5kZWZhdWx0UHJvcHM7XG5cbiAgICBmb3IgKHByb3BOYW1lIGluIGRlZmF1bHRQcm9wcykge1xuICAgICAgaWYgKHByb3BzW3Byb3BOYW1lXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHByb3BzW3Byb3BOYW1lXSA9IGRlZmF1bHRQcm9wc1twcm9wTmFtZV07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAge1xuICAgIGlmIChrZXkgfHwgcmVmKSB7XG4gICAgICB2YXIgZGlzcGxheU5hbWUgPSB0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJyA/IHR5cGUuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lIHx8ICdVbmtub3duJyA6IHR5cGU7XG5cbiAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgZGVmaW5lS2V5UHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHJlZikge1xuICAgICAgICBkZWZpbmVSZWZQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBSZWFjdEVsZW1lbnQodHlwZSwga2V5LCByZWYsIHNlbGYsIHNvdXJjZSwgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCwgcHJvcHMpO1xufVxuZnVuY3Rpb24gY2xvbmVBbmRSZXBsYWNlS2V5KG9sZEVsZW1lbnQsIG5ld0tleSkge1xuICB2YXIgbmV3RWxlbWVudCA9IFJlYWN0RWxlbWVudChvbGRFbGVtZW50LnR5cGUsIG5ld0tleSwgb2xkRWxlbWVudC5yZWYsIG9sZEVsZW1lbnQuX3NlbGYsIG9sZEVsZW1lbnQuX3NvdXJjZSwgb2xkRWxlbWVudC5fb3duZXIsIG9sZEVsZW1lbnQucHJvcHMpO1xuICByZXR1cm4gbmV3RWxlbWVudDtcbn1cbi8qKlxuICogQ2xvbmUgYW5kIHJldHVybiBhIG5ldyBSZWFjdEVsZW1lbnQgdXNpbmcgZWxlbWVudCBhcyB0aGUgc3RhcnRpbmcgcG9pbnQuXG4gKiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3JlYWN0LWFwaS5odG1sI2Nsb25lZWxlbWVudFxuICovXG5cbmZ1bmN0aW9uIGNsb25lRWxlbWVudChlbGVtZW50LCBjb25maWcsIGNoaWxkcmVuKSB7XG4gIGlmICghIShlbGVtZW50ID09PSBudWxsIHx8IGVsZW1lbnQgPT09IHVuZGVmaW5lZCkpIHtcbiAgICB7XG4gICAgICB0aHJvdyBFcnJvciggXCJSZWFjdC5jbG9uZUVsZW1lbnQoLi4uKTogVGhlIGFyZ3VtZW50IG11c3QgYmUgYSBSZWFjdCBlbGVtZW50LCBidXQgeW91IHBhc3NlZCBcIiArIGVsZW1lbnQgKyBcIi5cIiApO1xuICAgIH1cbiAgfVxuXG4gIHZhciBwcm9wTmFtZTsgLy8gT3JpZ2luYWwgcHJvcHMgYXJlIGNvcGllZFxuXG4gIHZhciBwcm9wcyA9IF9hc3NpZ24oe30sIGVsZW1lbnQucHJvcHMpOyAvLyBSZXNlcnZlZCBuYW1lcyBhcmUgZXh0cmFjdGVkXG5cblxuICB2YXIga2V5ID0gZWxlbWVudC5rZXk7XG4gIHZhciByZWYgPSBlbGVtZW50LnJlZjsgLy8gU2VsZiBpcyBwcmVzZXJ2ZWQgc2luY2UgdGhlIG93bmVyIGlzIHByZXNlcnZlZC5cblxuICB2YXIgc2VsZiA9IGVsZW1lbnQuX3NlbGY7IC8vIFNvdXJjZSBpcyBwcmVzZXJ2ZWQgc2luY2UgY2xvbmVFbGVtZW50IGlzIHVubGlrZWx5IHRvIGJlIHRhcmdldGVkIGJ5IGFcbiAgLy8gdHJhbnNwaWxlciwgYW5kIHRoZSBvcmlnaW5hbCBzb3VyY2UgaXMgcHJvYmFibHkgYSBiZXR0ZXIgaW5kaWNhdG9yIG9mIHRoZVxuICAvLyB0cnVlIG93bmVyLlxuXG4gIHZhciBzb3VyY2UgPSBlbGVtZW50Ll9zb3VyY2U7IC8vIE93bmVyIHdpbGwgYmUgcHJlc2VydmVkLCB1bmxlc3MgcmVmIGlzIG92ZXJyaWRkZW5cblxuICB2YXIgb3duZXIgPSBlbGVtZW50Ll9vd25lcjtcblxuICBpZiAoY29uZmlnICE9IG51bGwpIHtcbiAgICBpZiAoaGFzVmFsaWRSZWYoY29uZmlnKSkge1xuICAgICAgLy8gU2lsZW50bHkgc3RlYWwgdGhlIHJlZiBmcm9tIHRoZSBwYXJlbnQuXG4gICAgICByZWYgPSBjb25maWcucmVmO1xuICAgICAgb3duZXIgPSBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50O1xuICAgIH1cblxuICAgIGlmIChoYXNWYWxpZEtleShjb25maWcpKSB7XG4gICAgICBrZXkgPSAnJyArIGNvbmZpZy5rZXk7XG4gICAgfSAvLyBSZW1haW5pbmcgcHJvcGVydGllcyBvdmVycmlkZSBleGlzdGluZyBwcm9wc1xuXG5cbiAgICB2YXIgZGVmYXVsdFByb3BzO1xuXG4gICAgaWYgKGVsZW1lbnQudHlwZSAmJiBlbGVtZW50LnR5cGUuZGVmYXVsdFByb3BzKSB7XG4gICAgICBkZWZhdWx0UHJvcHMgPSBlbGVtZW50LnR5cGUuZGVmYXVsdFByb3BzO1xuICAgIH1cblxuICAgIGZvciAocHJvcE5hbWUgaW4gY29uZmlnKSB7XG4gICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsIHByb3BOYW1lKSAmJiAhUkVTRVJWRURfUFJPUFMuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICAgIGlmIChjb25maWdbcHJvcE5hbWVdID09PSB1bmRlZmluZWQgJiYgZGVmYXVsdFByb3BzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAvLyBSZXNvbHZlIGRlZmF1bHQgcHJvcHNcbiAgICAgICAgICBwcm9wc1twcm9wTmFtZV0gPSBkZWZhdWx0UHJvcHNbcHJvcE5hbWVdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHByb3BzW3Byb3BOYW1lXSA9IGNvbmZpZ1twcm9wTmFtZV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0gLy8gQ2hpbGRyZW4gY2FuIGJlIG1vcmUgdGhhbiBvbmUgYXJndW1lbnQsIGFuZCB0aG9zZSBhcmUgdHJhbnNmZXJyZWQgb250b1xuICAvLyB0aGUgbmV3bHkgYWxsb2NhdGVkIHByb3BzIG9iamVjdC5cblxuXG4gIHZhciBjaGlsZHJlbkxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGggLSAyO1xuXG4gIGlmIChjaGlsZHJlbkxlbmd0aCA9PT0gMSkge1xuICAgIHByb3BzLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gIH0gZWxzZSBpZiAoY2hpbGRyZW5MZW5ndGggPiAxKSB7XG4gICAgdmFyIGNoaWxkQXJyYXkgPSBBcnJheShjaGlsZHJlbkxlbmd0aCk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuTGVuZ3RoOyBpKyspIHtcbiAgICAgIGNoaWxkQXJyYXlbaV0gPSBhcmd1bWVudHNbaSArIDJdO1xuICAgIH1cblxuICAgIHByb3BzLmNoaWxkcmVuID0gY2hpbGRBcnJheTtcbiAgfVxuXG4gIHJldHVybiBSZWFjdEVsZW1lbnQoZWxlbWVudC50eXBlLCBrZXksIHJlZiwgc2VsZiwgc291cmNlLCBvd25lciwgcHJvcHMpO1xufVxuLyoqXG4gKiBWZXJpZmllcyB0aGUgb2JqZWN0IGlzIGEgUmVhY3RFbGVtZW50LlxuICogU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1hcGkuaHRtbCNpc3ZhbGlkZWxlbWVudFxuICogQHBhcmFtIHs/b2JqZWN0fSBvYmplY3RcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgYG9iamVjdGAgaXMgYSBSZWFjdEVsZW1lbnQuXG4gKiBAZmluYWxcbiAqL1xuXG5mdW5jdGlvbiBpc1ZhbGlkRWxlbWVudChvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnICYmIG9iamVjdCAhPT0gbnVsbCAmJiBvYmplY3QuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRTtcbn1cblxudmFyIFNFUEFSQVRPUiA9ICcuJztcbnZhciBTVUJTRVBBUkFUT1IgPSAnOic7XG4vKipcbiAqIEVzY2FwZSBhbmQgd3JhcCBrZXkgc28gaXQgaXMgc2FmZSB0byB1c2UgYXMgYSByZWFjdGlkXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSB0byBiZSBlc2NhcGVkLlxuICogQHJldHVybiB7c3RyaW5nfSB0aGUgZXNjYXBlZCBrZXkuXG4gKi9cblxuZnVuY3Rpb24gZXNjYXBlKGtleSkge1xuICB2YXIgZXNjYXBlUmVnZXggPSAvWz06XS9nO1xuICB2YXIgZXNjYXBlckxvb2t1cCA9IHtcbiAgICAnPSc6ICc9MCcsXG4gICAgJzonOiAnPTInXG4gIH07XG4gIHZhciBlc2NhcGVkU3RyaW5nID0ga2V5LnJlcGxhY2UoZXNjYXBlUmVnZXgsIGZ1bmN0aW9uIChtYXRjaCkge1xuICAgIHJldHVybiBlc2NhcGVyTG9va3VwW21hdGNoXTtcbiAgfSk7XG4gIHJldHVybiAnJCcgKyBlc2NhcGVkU3RyaW5nO1xufVxuLyoqXG4gKiBUT0RPOiBUZXN0IHRoYXQgYSBzaW5nbGUgY2hpbGQgYW5kIGFuIGFycmF5IHdpdGggb25lIGl0ZW0gaGF2ZSB0aGUgc2FtZSBrZXlcbiAqIHBhdHRlcm4uXG4gKi9cblxuXG52YXIgZGlkV2FybkFib3V0TWFwcyA9IGZhbHNlO1xudmFyIHVzZXJQcm92aWRlZEtleUVzY2FwZVJlZ2V4ID0gL1xcLysvZztcblxuZnVuY3Rpb24gZXNjYXBlVXNlclByb3ZpZGVkS2V5KHRleHQpIHtcbiAgcmV0dXJuIHRleHQucmVwbGFjZSh1c2VyUHJvdmlkZWRLZXlFc2NhcGVSZWdleCwgJyQmLycpO1xufVxuLyoqXG4gKiBHZW5lcmF0ZSBhIGtleSBzdHJpbmcgdGhhdCBpZGVudGlmaWVzIGEgZWxlbWVudCB3aXRoaW4gYSBzZXQuXG4gKlxuICogQHBhcmFtIHsqfSBlbGVtZW50IEEgZWxlbWVudCB0aGF0IGNvdWxkIGNvbnRhaW4gYSBtYW51YWwga2V5LlxuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IEluZGV4IHRoYXQgaXMgdXNlZCBpZiBhIG1hbnVhbCBrZXkgaXMgbm90IHByb3ZpZGVkLlxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5cblxuZnVuY3Rpb24gZ2V0RWxlbWVudEtleShlbGVtZW50LCBpbmRleCkge1xuICAvLyBEbyBzb21lIHR5cGVjaGVja2luZyBoZXJlIHNpbmNlIHdlIGNhbGwgdGhpcyBibGluZGx5LiBXZSB3YW50IHRvIGVuc3VyZVxuICAvLyB0aGF0IHdlIGRvbid0IGJsb2NrIHBvdGVudGlhbCBmdXR1cmUgRVMgQVBJcy5cbiAgaWYgKHR5cGVvZiBlbGVtZW50ID09PSAnb2JqZWN0JyAmJiBlbGVtZW50ICE9PSBudWxsICYmIGVsZW1lbnQua2V5ICE9IG51bGwpIHtcbiAgICAvLyBFeHBsaWNpdCBrZXlcbiAgICByZXR1cm4gZXNjYXBlKCcnICsgZWxlbWVudC5rZXkpO1xuICB9IC8vIEltcGxpY2l0IGtleSBkZXRlcm1pbmVkIGJ5IHRoZSBpbmRleCBpbiB0aGUgc2V0XG5cblxuICByZXR1cm4gaW5kZXgudG9TdHJpbmcoMzYpO1xufVxuXG5mdW5jdGlvbiBtYXBJbnRvQXJyYXkoY2hpbGRyZW4sIGFycmF5LCBlc2NhcGVkUHJlZml4LCBuYW1lU29GYXIsIGNhbGxiYWNrKSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIGNoaWxkcmVuO1xuXG4gIGlmICh0eXBlID09PSAndW5kZWZpbmVkJyB8fCB0eXBlID09PSAnYm9vbGVhbicpIHtcbiAgICAvLyBBbGwgb2YgdGhlIGFib3ZlIGFyZSBwZXJjZWl2ZWQgYXMgbnVsbC5cbiAgICBjaGlsZHJlbiA9IG51bGw7XG4gIH1cblxuICB2YXIgaW52b2tlQ2FsbGJhY2sgPSBmYWxzZTtcblxuICBpZiAoY2hpbGRyZW4gPT09IG51bGwpIHtcbiAgICBpbnZva2VDYWxsYmFjayA9IHRydWU7XG4gIH0gZWxzZSB7XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgaW52b2tlQ2FsbGJhY2sgPSB0cnVlO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgc3dpdGNoIChjaGlsZHJlbi4kJHR5cGVvZikge1xuICAgICAgICAgIGNhc2UgUkVBQ1RfRUxFTUVOVF9UWVBFOlxuICAgICAgICAgIGNhc2UgUkVBQ1RfUE9SVEFMX1RZUEU6XG4gICAgICAgICAgICBpbnZva2VDYWxsYmFjayA9IHRydWU7XG4gICAgICAgIH1cblxuICAgIH1cbiAgfVxuXG4gIGlmIChpbnZva2VDYWxsYmFjaykge1xuICAgIHZhciBfY2hpbGQgPSBjaGlsZHJlbjtcbiAgICB2YXIgbWFwcGVkQ2hpbGQgPSBjYWxsYmFjayhfY2hpbGQpOyAvLyBJZiBpdCdzIHRoZSBvbmx5IGNoaWxkLCB0cmVhdCB0aGUgbmFtZSBhcyBpZiBpdCB3YXMgd3JhcHBlZCBpbiBhbiBhcnJheVxuICAgIC8vIHNvIHRoYXQgaXQncyBjb25zaXN0ZW50IGlmIHRoZSBudW1iZXIgb2YgY2hpbGRyZW4gZ3Jvd3M6XG5cbiAgICB2YXIgY2hpbGRLZXkgPSBuYW1lU29GYXIgPT09ICcnID8gU0VQQVJBVE9SICsgZ2V0RWxlbWVudEtleShfY2hpbGQsIDApIDogbmFtZVNvRmFyO1xuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkobWFwcGVkQ2hpbGQpKSB7XG4gICAgICB2YXIgZXNjYXBlZENoaWxkS2V5ID0gJyc7XG5cbiAgICAgIGlmIChjaGlsZEtleSAhPSBudWxsKSB7XG4gICAgICAgIGVzY2FwZWRDaGlsZEtleSA9IGVzY2FwZVVzZXJQcm92aWRlZEtleShjaGlsZEtleSkgKyAnLyc7XG4gICAgICB9XG5cbiAgICAgIG1hcEludG9BcnJheShtYXBwZWRDaGlsZCwgYXJyYXksIGVzY2FwZWRDaGlsZEtleSwgJycsIGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIHJldHVybiBjO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChtYXBwZWRDaGlsZCAhPSBudWxsKSB7XG4gICAgICBpZiAoaXNWYWxpZEVsZW1lbnQobWFwcGVkQ2hpbGQpKSB7XG4gICAgICAgIG1hcHBlZENoaWxkID0gY2xvbmVBbmRSZXBsYWNlS2V5KG1hcHBlZENoaWxkLCAvLyBLZWVwIGJvdGggdGhlIChtYXBwZWQpIGFuZCBvbGQga2V5cyBpZiB0aGV5IGRpZmZlciwganVzdCBhc1xuICAgICAgICAvLyB0cmF2ZXJzZUFsbENoaWxkcmVuIHVzZWQgdG8gZG8gZm9yIG9iamVjdHMgYXMgY2hpbGRyZW5cbiAgICAgICAgZXNjYXBlZFByZWZpeCArICggLy8gJEZsb3dGaXhNZSBGbG93IGluY29ycmVjdGx5IHRoaW5rcyBSZWFjdC5Qb3J0YWwgZG9lc24ndCBoYXZlIGEga2V5XG4gICAgICAgIG1hcHBlZENoaWxkLmtleSAmJiAoIV9jaGlsZCB8fCBfY2hpbGQua2V5ICE9PSBtYXBwZWRDaGlsZC5rZXkpID8gLy8gJEZsb3dGaXhNZSBGbG93IGluY29ycmVjdGx5IHRoaW5rcyBleGlzdGluZyBlbGVtZW50J3Mga2V5IGNhbiBiZSBhIG51bWJlclxuICAgICAgICBlc2NhcGVVc2VyUHJvdmlkZWRLZXkoJycgKyBtYXBwZWRDaGlsZC5rZXkpICsgJy8nIDogJycpICsgY2hpbGRLZXkpO1xuICAgICAgfVxuXG4gICAgICBhcnJheS5wdXNoKG1hcHBlZENoaWxkKTtcbiAgICB9XG5cbiAgICByZXR1cm4gMTtcbiAgfVxuXG4gIHZhciBjaGlsZDtcbiAgdmFyIG5leHROYW1lO1xuICB2YXIgc3VidHJlZUNvdW50ID0gMDsgLy8gQ291bnQgb2YgY2hpbGRyZW4gZm91bmQgaW4gdGhlIGN1cnJlbnQgc3VidHJlZS5cblxuICB2YXIgbmV4dE5hbWVQcmVmaXggPSBuYW1lU29GYXIgPT09ICcnID8gU0VQQVJBVE9SIDogbmFtZVNvRmFyICsgU1VCU0VQQVJBVE9SO1xuXG4gIGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuKSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNoaWxkID0gY2hpbGRyZW5baV07XG4gICAgICBuZXh0TmFtZSA9IG5leHROYW1lUHJlZml4ICsgZ2V0RWxlbWVudEtleShjaGlsZCwgaSk7XG4gICAgICBzdWJ0cmVlQ291bnQgKz0gbWFwSW50b0FycmF5KGNoaWxkLCBhcnJheSwgZXNjYXBlZFByZWZpeCwgbmV4dE5hbWUsIGNhbGxiYWNrKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIGl0ZXJhdG9yRm4gPSBnZXRJdGVyYXRvckZuKGNoaWxkcmVuKTtcblxuICAgIGlmICh0eXBlb2YgaXRlcmF0b3JGbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdmFyIGl0ZXJhYmxlQ2hpbGRyZW4gPSBjaGlsZHJlbjtcblxuICAgICAge1xuICAgICAgICAvLyBXYXJuIGFib3V0IHVzaW5nIE1hcHMgYXMgY2hpbGRyZW5cbiAgICAgICAgaWYgKGl0ZXJhdG9yRm4gPT09IGl0ZXJhYmxlQ2hpbGRyZW4uZW50cmllcykge1xuICAgICAgICAgIGlmICghZGlkV2FybkFib3V0TWFwcykge1xuICAgICAgICAgICAgd2FybignVXNpbmcgTWFwcyBhcyBjaGlsZHJlbiBpcyBub3Qgc3VwcG9ydGVkLiAnICsgJ1VzZSBhbiBhcnJheSBvZiBrZXllZCBSZWFjdEVsZW1lbnRzIGluc3RlYWQuJyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZGlkV2FybkFib3V0TWFwcyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIGl0ZXJhdG9yID0gaXRlcmF0b3JGbi5jYWxsKGl0ZXJhYmxlQ2hpbGRyZW4pO1xuICAgICAgdmFyIHN0ZXA7XG4gICAgICB2YXIgaWkgPSAwO1xuXG4gICAgICB3aGlsZSAoIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lKSB7XG4gICAgICAgIGNoaWxkID0gc3RlcC52YWx1ZTtcbiAgICAgICAgbmV4dE5hbWUgPSBuZXh0TmFtZVByZWZpeCArIGdldEVsZW1lbnRLZXkoY2hpbGQsIGlpKyspO1xuICAgICAgICBzdWJ0cmVlQ291bnQgKz0gbWFwSW50b0FycmF5KGNoaWxkLCBhcnJheSwgZXNjYXBlZFByZWZpeCwgbmV4dE5hbWUsIGNhbGxiYWNrKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgICB2YXIgY2hpbGRyZW5TdHJpbmcgPSAnJyArIGNoaWxkcmVuO1xuXG4gICAgICB7XG4gICAgICAgIHtcbiAgICAgICAgICB0aHJvdyBFcnJvciggXCJPYmplY3RzIGFyZSBub3QgdmFsaWQgYXMgYSBSZWFjdCBjaGlsZCAoZm91bmQ6IFwiICsgKGNoaWxkcmVuU3RyaW5nID09PSAnW29iamVjdCBPYmplY3RdJyA/ICdvYmplY3Qgd2l0aCBrZXlzIHsnICsgT2JqZWN0LmtleXMoY2hpbGRyZW4pLmpvaW4oJywgJykgKyAnfScgOiBjaGlsZHJlblN0cmluZykgKyBcIikuIElmIHlvdSBtZWFudCB0byByZW5kZXIgYSBjb2xsZWN0aW9uIG9mIGNoaWxkcmVuLCB1c2UgYW4gYXJyYXkgaW5zdGVhZC5cIiApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHN1YnRyZWVDb3VudDtcbn1cblxuLyoqXG4gKiBNYXBzIGNoaWxkcmVuIHRoYXQgYXJlIHR5cGljYWxseSBzcGVjaWZpZWQgYXMgYHByb3BzLmNoaWxkcmVuYC5cbiAqXG4gKiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3JlYWN0LWFwaS5odG1sI3JlYWN0Y2hpbGRyZW5tYXBcbiAqXG4gKiBUaGUgcHJvdmlkZWQgbWFwRnVuY3Rpb24oY2hpbGQsIGluZGV4KSB3aWxsIGJlIGNhbGxlZCBmb3IgZWFjaFxuICogbGVhZiBjaGlsZC5cbiAqXG4gKiBAcGFyYW0gez8qfSBjaGlsZHJlbiBDaGlsZHJlbiB0cmVlIGNvbnRhaW5lci5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oKiwgaW50KX0gZnVuYyBUaGUgbWFwIGZ1bmN0aW9uLlxuICogQHBhcmFtIHsqfSBjb250ZXh0IENvbnRleHQgZm9yIG1hcEZ1bmN0aW9uLlxuICogQHJldHVybiB7b2JqZWN0fSBPYmplY3QgY29udGFpbmluZyB0aGUgb3JkZXJlZCBtYXAgb2YgcmVzdWx0cy5cbiAqL1xuZnVuY3Rpb24gbWFwQ2hpbGRyZW4oY2hpbGRyZW4sIGZ1bmMsIGNvbnRleHQpIHtcbiAgaWYgKGNoaWxkcmVuID09IG51bGwpIHtcbiAgICByZXR1cm4gY2hpbGRyZW47XG4gIH1cblxuICB2YXIgcmVzdWx0ID0gW107XG4gIHZhciBjb3VudCA9IDA7XG4gIG1hcEludG9BcnJheShjaGlsZHJlbiwgcmVzdWx0LCAnJywgJycsIGZ1bmN0aW9uIChjaGlsZCkge1xuICAgIHJldHVybiBmdW5jLmNhbGwoY29udGV4dCwgY2hpbGQsIGNvdW50KyspO1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qKlxuICogQ291bnQgdGhlIG51bWJlciBvZiBjaGlsZHJlbiB0aGF0IGFyZSB0eXBpY2FsbHkgc3BlY2lmaWVkIGFzXG4gKiBgcHJvcHMuY2hpbGRyZW5gLlxuICpcbiAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtYXBpLmh0bWwjcmVhY3RjaGlsZHJlbmNvdW50XG4gKlxuICogQHBhcmFtIHs/Kn0gY2hpbGRyZW4gQ2hpbGRyZW4gdHJlZSBjb250YWluZXIuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBudW1iZXIgb2YgY2hpbGRyZW4uXG4gKi9cblxuXG5mdW5jdGlvbiBjb3VudENoaWxkcmVuKGNoaWxkcmVuKSB7XG4gIHZhciBuID0gMDtcbiAgbWFwQ2hpbGRyZW4oY2hpbGRyZW4sIGZ1bmN0aW9uICgpIHtcbiAgICBuKys7IC8vIERvbid0IHJldHVybiBhbnl0aGluZ1xuICB9KTtcbiAgcmV0dXJuIG47XG59XG5cbi8qKlxuICogSXRlcmF0ZXMgdGhyb3VnaCBjaGlsZHJlbiB0aGF0IGFyZSB0eXBpY2FsbHkgc3BlY2lmaWVkIGFzIGBwcm9wcy5jaGlsZHJlbmAuXG4gKlxuICogU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1hcGkuaHRtbCNyZWFjdGNoaWxkcmVuZm9yZWFjaFxuICpcbiAqIFRoZSBwcm92aWRlZCBmb3JFYWNoRnVuYyhjaGlsZCwgaW5kZXgpIHdpbGwgYmUgY2FsbGVkIGZvciBlYWNoXG4gKiBsZWFmIGNoaWxkLlxuICpcbiAqIEBwYXJhbSB7Pyp9IGNoaWxkcmVuIENoaWxkcmVuIHRyZWUgY29udGFpbmVyLlxuICogQHBhcmFtIHtmdW5jdGlvbigqLCBpbnQpfSBmb3JFYWNoRnVuY1xuICogQHBhcmFtIHsqfSBmb3JFYWNoQ29udGV4dCBDb250ZXh0IGZvciBmb3JFYWNoQ29udGV4dC5cbiAqL1xuZnVuY3Rpb24gZm9yRWFjaENoaWxkcmVuKGNoaWxkcmVuLCBmb3JFYWNoRnVuYywgZm9yRWFjaENvbnRleHQpIHtcbiAgbWFwQ2hpbGRyZW4oY2hpbGRyZW4sIGZ1bmN0aW9uICgpIHtcbiAgICBmb3JFYWNoRnVuYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyAvLyBEb24ndCByZXR1cm4gYW55dGhpbmcuXG4gIH0sIGZvckVhY2hDb250ZXh0KTtcbn1cbi8qKlxuICogRmxhdHRlbiBhIGNoaWxkcmVuIG9iamVjdCAodHlwaWNhbGx5IHNwZWNpZmllZCBhcyBgcHJvcHMuY2hpbGRyZW5gKSBhbmRcbiAqIHJldHVybiBhbiBhcnJheSB3aXRoIGFwcHJvcHJpYXRlbHkgcmUta2V5ZWQgY2hpbGRyZW4uXG4gKlxuICogU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1hcGkuaHRtbCNyZWFjdGNoaWxkcmVudG9hcnJheVxuICovXG5cblxuZnVuY3Rpb24gdG9BcnJheShjaGlsZHJlbikge1xuICByZXR1cm4gbWFwQ2hpbGRyZW4oY2hpbGRyZW4sIGZ1bmN0aW9uIChjaGlsZCkge1xuICAgIHJldHVybiBjaGlsZDtcbiAgfSkgfHwgW107XG59XG4vKipcbiAqIFJldHVybnMgdGhlIGZpcnN0IGNoaWxkIGluIGEgY29sbGVjdGlvbiBvZiBjaGlsZHJlbiBhbmQgdmVyaWZpZXMgdGhhdCB0aGVyZVxuICogaXMgb25seSBvbmUgY2hpbGQgaW4gdGhlIGNvbGxlY3Rpb24uXG4gKlxuICogU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1hcGkuaHRtbCNyZWFjdGNoaWxkcmVub25seVxuICpcbiAqIFRoZSBjdXJyZW50IGltcGxlbWVudGF0aW9uIG9mIHRoaXMgZnVuY3Rpb24gYXNzdW1lcyB0aGF0IGEgc2luZ2xlIGNoaWxkIGdldHNcbiAqIHBhc3NlZCB3aXRob3V0IGEgd3JhcHBlciwgYnV0IHRoZSBwdXJwb3NlIG9mIHRoaXMgaGVscGVyIGZ1bmN0aW9uIGlzIHRvXG4gKiBhYnN0cmFjdCBhd2F5IHRoZSBwYXJ0aWN1bGFyIHN0cnVjdHVyZSBvZiBjaGlsZHJlbi5cbiAqXG4gKiBAcGFyYW0gez9vYmplY3R9IGNoaWxkcmVuIENoaWxkIGNvbGxlY3Rpb24gc3RydWN0dXJlLlxuICogQHJldHVybiB7UmVhY3RFbGVtZW50fSBUaGUgZmlyc3QgYW5kIG9ubHkgYFJlYWN0RWxlbWVudGAgY29udGFpbmVkIGluIHRoZVxuICogc3RydWN0dXJlLlxuICovXG5cblxuZnVuY3Rpb24gb25seUNoaWxkKGNoaWxkcmVuKSB7XG4gIGlmICghaXNWYWxpZEVsZW1lbnQoY2hpbGRyZW4pKSB7XG4gICAge1xuICAgICAgdGhyb3cgRXJyb3IoIFwiUmVhY3QuQ2hpbGRyZW4ub25seSBleHBlY3RlZCB0byByZWNlaXZlIGEgc2luZ2xlIFJlYWN0IGVsZW1lbnQgY2hpbGQuXCIgKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gY2hpbGRyZW47XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUNvbnRleHQoZGVmYXVsdFZhbHVlLCBjYWxjdWxhdGVDaGFuZ2VkQml0cykge1xuICBpZiAoY2FsY3VsYXRlQ2hhbmdlZEJpdHMgPT09IHVuZGVmaW5lZCkge1xuICAgIGNhbGN1bGF0ZUNoYW5nZWRCaXRzID0gbnVsbDtcbiAgfSBlbHNlIHtcbiAgICB7XG4gICAgICBpZiAoY2FsY3VsYXRlQ2hhbmdlZEJpdHMgIT09IG51bGwgJiYgdHlwZW9mIGNhbGN1bGF0ZUNoYW5nZWRCaXRzICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGVycm9yKCdjcmVhdGVDb250ZXh0OiBFeHBlY3RlZCB0aGUgb3B0aW9uYWwgc2Vjb25kIGFyZ3VtZW50IHRvIGJlIGEgJyArICdmdW5jdGlvbi4gSW5zdGVhZCByZWNlaXZlZDogJXMnLCBjYWxjdWxhdGVDaGFuZ2VkQml0cyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIGNvbnRleHQgPSB7XG4gICAgJCR0eXBlb2Y6IFJFQUNUX0NPTlRFWFRfVFlQRSxcbiAgICBfY2FsY3VsYXRlQ2hhbmdlZEJpdHM6IGNhbGN1bGF0ZUNoYW5nZWRCaXRzLFxuICAgIC8vIEFzIGEgd29ya2Fyb3VuZCB0byBzdXBwb3J0IG11bHRpcGxlIGNvbmN1cnJlbnQgcmVuZGVyZXJzLCB3ZSBjYXRlZ29yaXplXG4gICAgLy8gc29tZSByZW5kZXJlcnMgYXMgcHJpbWFyeSBhbmQgb3RoZXJzIGFzIHNlY29uZGFyeS4gV2Ugb25seSBleHBlY3RcbiAgICAvLyB0aGVyZSB0byBiZSB0d28gY29uY3VycmVudCByZW5kZXJlcnMgYXQgbW9zdDogUmVhY3QgTmF0aXZlIChwcmltYXJ5KSBhbmRcbiAgICAvLyBGYWJyaWMgKHNlY29uZGFyeSk7IFJlYWN0IERPTSAocHJpbWFyeSkgYW5kIFJlYWN0IEFSVCAoc2Vjb25kYXJ5KS5cbiAgICAvLyBTZWNvbmRhcnkgcmVuZGVyZXJzIHN0b3JlIHRoZWlyIGNvbnRleHQgdmFsdWVzIG9uIHNlcGFyYXRlIGZpZWxkcy5cbiAgICBfY3VycmVudFZhbHVlOiBkZWZhdWx0VmFsdWUsXG4gICAgX2N1cnJlbnRWYWx1ZTI6IGRlZmF1bHRWYWx1ZSxcbiAgICAvLyBVc2VkIHRvIHRyYWNrIGhvdyBtYW55IGNvbmN1cnJlbnQgcmVuZGVyZXJzIHRoaXMgY29udGV4dCBjdXJyZW50bHlcbiAgICAvLyBzdXBwb3J0cyB3aXRoaW4gaW4gYSBzaW5nbGUgcmVuZGVyZXIuIFN1Y2ggYXMgcGFyYWxsZWwgc2VydmVyIHJlbmRlcmluZy5cbiAgICBfdGhyZWFkQ291bnQ6IDAsXG4gICAgLy8gVGhlc2UgYXJlIGNpcmN1bGFyXG4gICAgUHJvdmlkZXI6IG51bGwsXG4gICAgQ29uc3VtZXI6IG51bGxcbiAgfTtcbiAgY29udGV4dC5Qcm92aWRlciA9IHtcbiAgICAkJHR5cGVvZjogUkVBQ1RfUFJPVklERVJfVFlQRSxcbiAgICBfY29udGV4dDogY29udGV4dFxuICB9O1xuICB2YXIgaGFzV2FybmVkQWJvdXRVc2luZ05lc3RlZENvbnRleHRDb25zdW1lcnMgPSBmYWxzZTtcbiAgdmFyIGhhc1dhcm5lZEFib3V0VXNpbmdDb25zdW1lclByb3ZpZGVyID0gZmFsc2U7XG4gIHZhciBoYXNXYXJuZWRBYm91dERpc3BsYXlOYW1lT25Db25zdW1lciA9IGZhbHNlO1xuXG4gIHtcbiAgICAvLyBBIHNlcGFyYXRlIG9iamVjdCwgYnV0IHByb3hpZXMgYmFjayB0byB0aGUgb3JpZ2luYWwgY29udGV4dCBvYmplY3QgZm9yXG4gICAgLy8gYmFja3dhcmRzIGNvbXBhdGliaWxpdHkuIEl0IGhhcyBhIGRpZmZlcmVudCAkJHR5cGVvZiwgc28gd2UgY2FuIHByb3Blcmx5XG4gICAgLy8gd2FybiBmb3IgdGhlIGluY29ycmVjdCB1c2FnZSBvZiBDb250ZXh0IGFzIGEgQ29uc3VtZXIuXG4gICAgdmFyIENvbnN1bWVyID0ge1xuICAgICAgJCR0eXBlb2Y6IFJFQUNUX0NPTlRFWFRfVFlQRSxcbiAgICAgIF9jb250ZXh0OiBjb250ZXh0LFxuICAgICAgX2NhbGN1bGF0ZUNoYW5nZWRCaXRzOiBjb250ZXh0Ll9jYWxjdWxhdGVDaGFuZ2VkQml0c1xuICAgIH07IC8vICRGbG93Rml4TWU6IEZsb3cgY29tcGxhaW5zIGFib3V0IG5vdCBzZXR0aW5nIGEgdmFsdWUsIHdoaWNoIGlzIGludGVudGlvbmFsIGhlcmVcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKENvbnN1bWVyLCB7XG4gICAgICBQcm92aWRlcjoge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAoIWhhc1dhcm5lZEFib3V0VXNpbmdDb25zdW1lclByb3ZpZGVyKSB7XG4gICAgICAgICAgICBoYXNXYXJuZWRBYm91dFVzaW5nQ29uc3VtZXJQcm92aWRlciA9IHRydWU7XG5cbiAgICAgICAgICAgIGVycm9yKCdSZW5kZXJpbmcgPENvbnRleHQuQ29uc3VtZXIuUHJvdmlkZXI+IGlzIG5vdCBzdXBwb3J0ZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiAnICsgJ2EgZnV0dXJlIG1ham9yIHJlbGVhc2UuIERpZCB5b3UgbWVhbiB0byByZW5kZXIgPENvbnRleHQuUHJvdmlkZXI+IGluc3RlYWQ/Jyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGNvbnRleHQuUHJvdmlkZXI7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKF9Qcm92aWRlcikge1xuICAgICAgICAgIGNvbnRleHQuUHJvdmlkZXIgPSBfUHJvdmlkZXI7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBfY3VycmVudFZhbHVlOiB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBjb250ZXh0Ll9jdXJyZW50VmFsdWU7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKF9jdXJyZW50VmFsdWUpIHtcbiAgICAgICAgICBjb250ZXh0Ll9jdXJyZW50VmFsdWUgPSBfY3VycmVudFZhbHVlO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgX2N1cnJlbnRWYWx1ZTI6IHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIGNvbnRleHQuX2N1cnJlbnRWYWx1ZTI7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKF9jdXJyZW50VmFsdWUyKSB7XG4gICAgICAgICAgY29udGV4dC5fY3VycmVudFZhbHVlMiA9IF9jdXJyZW50VmFsdWUyO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgX3RocmVhZENvdW50OiB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBjb250ZXh0Ll90aHJlYWRDb3VudDtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAoX3RocmVhZENvdW50KSB7XG4gICAgICAgICAgY29udGV4dC5fdGhyZWFkQ291bnQgPSBfdGhyZWFkQ291bnQ7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBDb25zdW1lcjoge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAoIWhhc1dhcm5lZEFib3V0VXNpbmdOZXN0ZWRDb250ZXh0Q29uc3VtZXJzKSB7XG4gICAgICAgICAgICBoYXNXYXJuZWRBYm91dFVzaW5nTmVzdGVkQ29udGV4dENvbnN1bWVycyA9IHRydWU7XG5cbiAgICAgICAgICAgIGVycm9yKCdSZW5kZXJpbmcgPENvbnRleHQuQ29uc3VtZXIuQ29uc3VtZXI+IGlzIG5vdCBzdXBwb3J0ZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiAnICsgJ2EgZnV0dXJlIG1ham9yIHJlbGVhc2UuIERpZCB5b3UgbWVhbiB0byByZW5kZXIgPENvbnRleHQuQ29uc3VtZXI+IGluc3RlYWQ/Jyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGNvbnRleHQuQ29uc3VtZXI7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBkaXNwbGF5TmFtZToge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gY29udGV4dC5kaXNwbGF5TmFtZTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAoZGlzcGxheU5hbWUpIHtcbiAgICAgICAgICBpZiAoIWhhc1dhcm5lZEFib3V0RGlzcGxheU5hbWVPbkNvbnN1bWVyKSB7XG4gICAgICAgICAgICB3YXJuKCdTZXR0aW5nIGBkaXNwbGF5TmFtZWAgb24gQ29udGV4dC5Db25zdW1lciBoYXMgbm8gZWZmZWN0LiAnICsgXCJZb3Ugc2hvdWxkIHNldCBpdCBkaXJlY3RseSBvbiB0aGUgY29udGV4dCB3aXRoIENvbnRleHQuZGlzcGxheU5hbWUgPSAnJXMnLlwiLCBkaXNwbGF5TmFtZSk7XG5cbiAgICAgICAgICAgIGhhc1dhcm5lZEFib3V0RGlzcGxheU5hbWVPbkNvbnN1bWVyID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTsgLy8gJEZsb3dGaXhNZTogRmxvdyBjb21wbGFpbnMgYWJvdXQgbWlzc2luZyBwcm9wZXJ0aWVzIGJlY2F1c2UgaXQgZG9lc24ndCB1bmRlcnN0YW5kIGRlZmluZVByb3BlcnR5XG5cbiAgICBjb250ZXh0LkNvbnN1bWVyID0gQ29uc3VtZXI7XG4gIH1cblxuICB7XG4gICAgY29udGV4dC5fY3VycmVudFJlbmRlcmVyID0gbnVsbDtcbiAgICBjb250ZXh0Ll9jdXJyZW50UmVuZGVyZXIyID0gbnVsbDtcbiAgfVxuXG4gIHJldHVybiBjb250ZXh0O1xufVxuXG52YXIgVW5pbml0aWFsaXplZCA9IC0xO1xudmFyIFBlbmRpbmcgPSAwO1xudmFyIFJlc29sdmVkID0gMTtcbnZhciBSZWplY3RlZCA9IDI7XG5cbmZ1bmN0aW9uIGxhenlJbml0aWFsaXplcihwYXlsb2FkKSB7XG4gIGlmIChwYXlsb2FkLl9zdGF0dXMgPT09IFVuaW5pdGlhbGl6ZWQpIHtcbiAgICB2YXIgY3RvciA9IHBheWxvYWQuX3Jlc3VsdDtcbiAgICB2YXIgdGhlbmFibGUgPSBjdG9yKCk7IC8vIFRyYW5zaXRpb24gdG8gdGhlIG5leHQgc3RhdGUuXG5cbiAgICB2YXIgcGVuZGluZyA9IHBheWxvYWQ7XG4gICAgcGVuZGluZy5fc3RhdHVzID0gUGVuZGluZztcbiAgICBwZW5kaW5nLl9yZXN1bHQgPSB0aGVuYWJsZTtcbiAgICB0aGVuYWJsZS50aGVuKGZ1bmN0aW9uIChtb2R1bGVPYmplY3QpIHtcbiAgICAgIGlmIChwYXlsb2FkLl9zdGF0dXMgPT09IFBlbmRpbmcpIHtcbiAgICAgICAgdmFyIGRlZmF1bHRFeHBvcnQgPSBtb2R1bGVPYmplY3QuZGVmYXVsdDtcblxuICAgICAgICB7XG4gICAgICAgICAgaWYgKGRlZmF1bHRFeHBvcnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZXJyb3IoJ2xhenk6IEV4cGVjdGVkIHRoZSByZXN1bHQgb2YgYSBkeW5hbWljIGltcG9ydCgpIGNhbGwuICcgKyAnSW5zdGVhZCByZWNlaXZlZDogJXNcXG5cXG5Zb3VyIGNvZGUgc2hvdWxkIGxvb2sgbGlrZTogXFxuICAnICsgLy8gQnJlYWsgdXAgaW1wb3J0cyB0byBhdm9pZCBhY2NpZGVudGFsbHkgcGFyc2luZyB0aGVtIGFzIGRlcGVuZGVuY2llcy5cbiAgICAgICAgICAgICdjb25zdCBNeUNvbXBvbmVudCA9IGxhenkoKCkgPT4gaW1wJyArIFwib3J0KCcuL015Q29tcG9uZW50JykpXCIsIG1vZHVsZU9iamVjdCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vIFRyYW5zaXRpb24gdG8gdGhlIG5leHQgc3RhdGUuXG5cblxuICAgICAgICB2YXIgcmVzb2x2ZWQgPSBwYXlsb2FkO1xuICAgICAgICByZXNvbHZlZC5fc3RhdHVzID0gUmVzb2x2ZWQ7XG4gICAgICAgIHJlc29sdmVkLl9yZXN1bHQgPSBkZWZhdWx0RXhwb3J0O1xuICAgICAgfVxuICAgIH0sIGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgaWYgKHBheWxvYWQuX3N0YXR1cyA9PT0gUGVuZGluZykge1xuICAgICAgICAvLyBUcmFuc2l0aW9uIHRvIHRoZSBuZXh0IHN0YXRlLlxuICAgICAgICB2YXIgcmVqZWN0ZWQgPSBwYXlsb2FkO1xuICAgICAgICByZWplY3RlZC5fc3RhdHVzID0gUmVqZWN0ZWQ7XG4gICAgICAgIHJlamVjdGVkLl9yZXN1bHQgPSBlcnJvcjtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGlmIChwYXlsb2FkLl9zdGF0dXMgPT09IFJlc29sdmVkKSB7XG4gICAgcmV0dXJuIHBheWxvYWQuX3Jlc3VsdDtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBwYXlsb2FkLl9yZXN1bHQ7XG4gIH1cbn1cblxuZnVuY3Rpb24gbGF6eShjdG9yKSB7XG4gIHZhciBwYXlsb2FkID0ge1xuICAgIC8vIFdlIHVzZSB0aGVzZSBmaWVsZHMgdG8gc3RvcmUgdGhlIHJlc3VsdC5cbiAgICBfc3RhdHVzOiAtMSxcbiAgICBfcmVzdWx0OiBjdG9yXG4gIH07XG4gIHZhciBsYXp5VHlwZSA9IHtcbiAgICAkJHR5cGVvZjogUkVBQ1RfTEFaWV9UWVBFLFxuICAgIF9wYXlsb2FkOiBwYXlsb2FkLFxuICAgIF9pbml0OiBsYXp5SW5pdGlhbGl6ZXJcbiAgfTtcblxuICB7XG4gICAgLy8gSW4gcHJvZHVjdGlvbiwgdGhpcyB3b3VsZCBqdXN0IHNldCBpdCBvbiB0aGUgb2JqZWN0LlxuICAgIHZhciBkZWZhdWx0UHJvcHM7XG4gICAgdmFyIHByb3BUeXBlczsgLy8gJEZsb3dGaXhNZVxuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMobGF6eVR5cGUsIHtcbiAgICAgIGRlZmF1bHRQcm9wczoge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBkZWZhdWx0UHJvcHM7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKG5ld0RlZmF1bHRQcm9wcykge1xuICAgICAgICAgIGVycm9yKCdSZWFjdC5sYXp5KC4uLik6IEl0IGlzIG5vdCBzdXBwb3J0ZWQgdG8gYXNzaWduIGBkZWZhdWx0UHJvcHNgIHRvICcgKyAnYSBsYXp5IGNvbXBvbmVudCBpbXBvcnQuIEVpdGhlciBzcGVjaWZ5IHRoZW0gd2hlcmUgdGhlIGNvbXBvbmVudCAnICsgJ2lzIGRlZmluZWQsIG9yIGNyZWF0ZSBhIHdyYXBwaW5nIGNvbXBvbmVudCBhcm91bmQgaXQuJyk7XG5cbiAgICAgICAgICBkZWZhdWx0UHJvcHMgPSBuZXdEZWZhdWx0UHJvcHM7IC8vIE1hdGNoIHByb2R1Y3Rpb24gYmVoYXZpb3IgbW9yZSBjbG9zZWx5OlxuICAgICAgICAgIC8vICRGbG93Rml4TWVcblxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShsYXp5VHlwZSwgJ2RlZmF1bHRQcm9wcycsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHByb3BUeXBlczoge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBwcm9wVHlwZXM7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKG5ld1Byb3BUeXBlcykge1xuICAgICAgICAgIGVycm9yKCdSZWFjdC5sYXp5KC4uLik6IEl0IGlzIG5vdCBzdXBwb3J0ZWQgdG8gYXNzaWduIGBwcm9wVHlwZXNgIHRvICcgKyAnYSBsYXp5IGNvbXBvbmVudCBpbXBvcnQuIEVpdGhlciBzcGVjaWZ5IHRoZW0gd2hlcmUgdGhlIGNvbXBvbmVudCAnICsgJ2lzIGRlZmluZWQsIG9yIGNyZWF0ZSBhIHdyYXBwaW5nIGNvbXBvbmVudCBhcm91bmQgaXQuJyk7XG5cbiAgICAgICAgICBwcm9wVHlwZXMgPSBuZXdQcm9wVHlwZXM7IC8vIE1hdGNoIHByb2R1Y3Rpb24gYmVoYXZpb3IgbW9yZSBjbG9zZWx5OlxuICAgICAgICAgIC8vICRGbG93Rml4TWVcblxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShsYXp5VHlwZSwgJ3Byb3BUeXBlcycsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIGxhenlUeXBlO1xufVxuXG5mdW5jdGlvbiBmb3J3YXJkUmVmKHJlbmRlcikge1xuICB7XG4gICAgaWYgKHJlbmRlciAhPSBudWxsICYmIHJlbmRlci4kJHR5cGVvZiA9PT0gUkVBQ1RfTUVNT19UWVBFKSB7XG4gICAgICBlcnJvcignZm9yd2FyZFJlZiByZXF1aXJlcyBhIHJlbmRlciBmdW5jdGlvbiBidXQgcmVjZWl2ZWQgYSBgbWVtb2AgJyArICdjb21wb25lbnQuIEluc3RlYWQgb2YgZm9yd2FyZFJlZihtZW1vKC4uLikpLCB1c2UgJyArICdtZW1vKGZvcndhcmRSZWYoLi4uKSkuJyk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgcmVuZGVyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICBlcnJvcignZm9yd2FyZFJlZiByZXF1aXJlcyBhIHJlbmRlciBmdW5jdGlvbiBidXQgd2FzIGdpdmVuICVzLicsIHJlbmRlciA9PT0gbnVsbCA/ICdudWxsJyA6IHR5cGVvZiByZW5kZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAocmVuZGVyLmxlbmd0aCAhPT0gMCAmJiByZW5kZXIubGVuZ3RoICE9PSAyKSB7XG4gICAgICAgIGVycm9yKCdmb3J3YXJkUmVmIHJlbmRlciBmdW5jdGlvbnMgYWNjZXB0IGV4YWN0bHkgdHdvIHBhcmFtZXRlcnM6IHByb3BzIGFuZCByZWYuICVzJywgcmVuZGVyLmxlbmd0aCA9PT0gMSA/ICdEaWQgeW91IGZvcmdldCB0byB1c2UgdGhlIHJlZiBwYXJhbWV0ZXI/JyA6ICdBbnkgYWRkaXRpb25hbCBwYXJhbWV0ZXIgd2lsbCBiZSB1bmRlZmluZWQuJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHJlbmRlciAhPSBudWxsKSB7XG4gICAgICBpZiAocmVuZGVyLmRlZmF1bHRQcm9wcyAhPSBudWxsIHx8IHJlbmRlci5wcm9wVHlwZXMgIT0gbnVsbCkge1xuICAgICAgICBlcnJvcignZm9yd2FyZFJlZiByZW5kZXIgZnVuY3Rpb25zIGRvIG5vdCBzdXBwb3J0IHByb3BUeXBlcyBvciBkZWZhdWx0UHJvcHMuICcgKyAnRGlkIHlvdSBhY2NpZGVudGFsbHkgcGFzcyBhIFJlYWN0IGNvbXBvbmVudD8nKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2YXIgZWxlbWVudFR5cGUgPSB7XG4gICAgJCR0eXBlb2Y6IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUsXG4gICAgcmVuZGVyOiByZW5kZXJcbiAgfTtcblxuICB7XG4gICAgdmFyIG93bk5hbWU7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVsZW1lbnRUeXBlLCAnZGlzcGxheU5hbWUnLCB7XG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gb3duTmFtZTtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIG93bk5hbWUgPSBuYW1lO1xuXG4gICAgICAgIGlmIChyZW5kZXIuZGlzcGxheU5hbWUgPT0gbnVsbCkge1xuICAgICAgICAgIHJlbmRlci5kaXNwbGF5TmFtZSA9IG5hbWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiBlbGVtZW50VHlwZTtcbn1cblxuLy8gRmlsdGVyIGNlcnRhaW4gRE9NIGF0dHJpYnV0ZXMgKGUuZy4gc3JjLCBocmVmKSBpZiB0aGVpciB2YWx1ZXMgYXJlIGVtcHR5IHN0cmluZ3MuXG5cbnZhciBlbmFibGVTY29wZUFQSSA9IGZhbHNlOyAvLyBFeHBlcmltZW50YWwgQ3JlYXRlIEV2ZW50IEhhbmRsZSBBUEkuXG5cbmZ1bmN0aW9uIGlzVmFsaWRFbGVtZW50VHlwZSh0eXBlKSB7XG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSAvLyBOb3RlOiB0eXBlb2YgbWlnaHQgYmUgb3RoZXIgdGhhbiAnc3ltYm9sJyBvciAnbnVtYmVyJyAoZS5nLiBpZiBpdCdzIGEgcG9seWZpbGwpLlxuXG5cbiAgaWYgKHR5cGUgPT09IGV4cG9ydHMuRnJhZ21lbnQgfHwgdHlwZSA9PT0gZXhwb3J0cy5Qcm9maWxlciB8fCB0eXBlID09PSBSRUFDVF9ERUJVR19UUkFDSU5HX01PREVfVFlQRSB8fCB0eXBlID09PSBleHBvcnRzLlN0cmljdE1vZGUgfHwgdHlwZSA9PT0gZXhwb3J0cy5TdXNwZW5zZSB8fCB0eXBlID09PSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfTEVHQUNZX0hJRERFTl9UWVBFIHx8IGVuYWJsZVNjb3BlQVBJICkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JyAmJiB0eXBlICE9PSBudWxsKSB7XG4gICAgaWYgKHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0xBWllfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9NRU1PX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfUFJPVklERVJfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9DT05URVhUX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9GVU5EQU1FTlRBTF9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0JMT0NLX1RZUEUgfHwgdHlwZVswXSA9PT0gUkVBQ1RfU0VSVkVSX0JMT0NLX1RZUEUpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gbWVtbyh0eXBlLCBjb21wYXJlKSB7XG4gIHtcbiAgICBpZiAoIWlzVmFsaWRFbGVtZW50VHlwZSh0eXBlKSkge1xuICAgICAgZXJyb3IoJ21lbW86IFRoZSBmaXJzdCBhcmd1bWVudCBtdXN0IGJlIGEgY29tcG9uZW50LiBJbnN0ZWFkICcgKyAncmVjZWl2ZWQ6ICVzJywgdHlwZSA9PT0gbnVsbCA/ICdudWxsJyA6IHR5cGVvZiB0eXBlKTtcbiAgICB9XG4gIH1cblxuICB2YXIgZWxlbWVudFR5cGUgPSB7XG4gICAgJCR0eXBlb2Y6IFJFQUNUX01FTU9fVFlQRSxcbiAgICB0eXBlOiB0eXBlLFxuICAgIGNvbXBhcmU6IGNvbXBhcmUgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBjb21wYXJlXG4gIH07XG5cbiAge1xuICAgIHZhciBvd25OYW1lO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50VHlwZSwgJ2Rpc3BsYXlOYW1lJywge1xuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG93bk5hbWU7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICBvd25OYW1lID0gbmFtZTtcblxuICAgICAgICBpZiAodHlwZS5kaXNwbGF5TmFtZSA9PSBudWxsKSB7XG4gICAgICAgICAgdHlwZS5kaXNwbGF5TmFtZSA9IG5hbWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiBlbGVtZW50VHlwZTtcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZURpc3BhdGNoZXIoKSB7XG4gIHZhciBkaXNwYXRjaGVyID0gUmVhY3RDdXJyZW50RGlzcGF0Y2hlci5jdXJyZW50O1xuXG4gIGlmICghKGRpc3BhdGNoZXIgIT09IG51bGwpKSB7XG4gICAge1xuICAgICAgdGhyb3cgRXJyb3IoIFwiSW52YWxpZCBob29rIGNhbGwuIEhvb2tzIGNhbiBvbmx5IGJlIGNhbGxlZCBpbnNpZGUgb2YgdGhlIGJvZHkgb2YgYSBmdW5jdGlvbiBjb21wb25lbnQuIFRoaXMgY291bGQgaGFwcGVuIGZvciBvbmUgb2YgdGhlIGZvbGxvd2luZyByZWFzb25zOlxcbjEuIFlvdSBtaWdodCBoYXZlIG1pc21hdGNoaW5nIHZlcnNpb25zIG9mIFJlYWN0IGFuZCB0aGUgcmVuZGVyZXIgKHN1Y2ggYXMgUmVhY3QgRE9NKVxcbjIuIFlvdSBtaWdodCBiZSBicmVha2luZyB0aGUgUnVsZXMgb2YgSG9va3NcXG4zLiBZb3UgbWlnaHQgaGF2ZSBtb3JlIHRoYW4gb25lIGNvcHkgb2YgUmVhY3QgaW4gdGhlIHNhbWUgYXBwXFxuU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9pbnZhbGlkLWhvb2stY2FsbCBmb3IgdGlwcyBhYm91dCBob3cgdG8gZGVidWcgYW5kIGZpeCB0aGlzIHByb2JsZW0uXCIgKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZGlzcGF0Y2hlcjtcbn1cblxuZnVuY3Rpb24gdXNlQ29udGV4dChDb250ZXh0LCB1bnN0YWJsZV9vYnNlcnZlZEJpdHMpIHtcbiAgdmFyIGRpc3BhdGNoZXIgPSByZXNvbHZlRGlzcGF0Y2hlcigpO1xuXG4gIHtcbiAgICBpZiAodW5zdGFibGVfb2JzZXJ2ZWRCaXRzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGVycm9yKCd1c2VDb250ZXh0KCkgc2Vjb25kIGFyZ3VtZW50IGlzIHJlc2VydmVkIGZvciBmdXR1cmUgJyArICd1c2UgaW4gUmVhY3QuIFBhc3NpbmcgaXQgaXMgbm90IHN1cHBvcnRlZC4gJyArICdZb3UgcGFzc2VkOiAlcy4lcycsIHVuc3RhYmxlX29ic2VydmVkQml0cywgdHlwZW9mIHVuc3RhYmxlX29ic2VydmVkQml0cyA9PT0gJ251bWJlcicgJiYgQXJyYXkuaXNBcnJheShhcmd1bWVudHNbMl0pID8gJ1xcblxcbkRpZCB5b3UgY2FsbCBhcnJheS5tYXAodXNlQ29udGV4dCk/ICcgKyAnQ2FsbGluZyBIb29rcyBpbnNpZGUgYSBsb29wIGlzIG5vdCBzdXBwb3J0ZWQuICcgKyAnTGVhcm4gbW9yZSBhdCBodHRwczovL3JlYWN0anMub3JnL2xpbmsvcnVsZXMtb2YtaG9va3MnIDogJycpO1xuICAgIH0gLy8gVE9ETzogYWRkIGEgbW9yZSBnZW5lcmljIHdhcm5pbmcgZm9yIGludmFsaWQgdmFsdWVzLlxuXG5cbiAgICBpZiAoQ29udGV4dC5fY29udGV4dCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB2YXIgcmVhbENvbnRleHQgPSBDb250ZXh0Ll9jb250ZXh0OyAvLyBEb24ndCBkZWR1cGxpY2F0ZSBiZWNhdXNlIHRoaXMgbGVnaXRpbWF0ZWx5IGNhdXNlcyBidWdzXG4gICAgICAvLyBhbmQgbm9ib2R5IHNob3VsZCBiZSB1c2luZyB0aGlzIGluIGV4aXN0aW5nIGNvZGUuXG5cbiAgICAgIGlmIChyZWFsQ29udGV4dC5Db25zdW1lciA9PT0gQ29udGV4dCkge1xuICAgICAgICBlcnJvcignQ2FsbGluZyB1c2VDb250ZXh0KENvbnRleHQuQ29uc3VtZXIpIGlzIG5vdCBzdXBwb3J0ZWQsIG1heSBjYXVzZSBidWdzLCBhbmQgd2lsbCBiZSAnICsgJ3JlbW92ZWQgaW4gYSBmdXR1cmUgbWFqb3IgcmVsZWFzZS4gRGlkIHlvdSBtZWFuIHRvIGNhbGwgdXNlQ29udGV4dChDb250ZXh0KSBpbnN0ZWFkPycpO1xuICAgICAgfSBlbHNlIGlmIChyZWFsQ29udGV4dC5Qcm92aWRlciA9PT0gQ29udGV4dCkge1xuICAgICAgICBlcnJvcignQ2FsbGluZyB1c2VDb250ZXh0KENvbnRleHQuUHJvdmlkZXIpIGlzIG5vdCBzdXBwb3J0ZWQuICcgKyAnRGlkIHlvdSBtZWFuIHRvIGNhbGwgdXNlQ29udGV4dChDb250ZXh0KSBpbnN0ZWFkPycpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBkaXNwYXRjaGVyLnVzZUNvbnRleHQoQ29udGV4dCwgdW5zdGFibGVfb2JzZXJ2ZWRCaXRzKTtcbn1cbmZ1bmN0aW9uIHVzZVN0YXRlKGluaXRpYWxTdGF0ZSkge1xuICB2YXIgZGlzcGF0Y2hlciA9IHJlc29sdmVEaXNwYXRjaGVyKCk7XG4gIHJldHVybiBkaXNwYXRjaGVyLnVzZVN0YXRlKGluaXRpYWxTdGF0ZSk7XG59XG5mdW5jdGlvbiB1c2VSZWR1Y2VyKHJlZHVjZXIsIGluaXRpYWxBcmcsIGluaXQpIHtcbiAgdmFyIGRpc3BhdGNoZXIgPSByZXNvbHZlRGlzcGF0Y2hlcigpO1xuICByZXR1cm4gZGlzcGF0Y2hlci51c2VSZWR1Y2VyKHJlZHVjZXIsIGluaXRpYWxBcmcsIGluaXQpO1xufVxuZnVuY3Rpb24gdXNlUmVmKGluaXRpYWxWYWx1ZSkge1xuICB2YXIgZGlzcGF0Y2hlciA9IHJlc29sdmVEaXNwYXRjaGVyKCk7XG4gIHJldHVybiBkaXNwYXRjaGVyLnVzZVJlZihpbml0aWFsVmFsdWUpO1xufVxuZnVuY3Rpb24gdXNlRWZmZWN0KGNyZWF0ZSwgZGVwcykge1xuICB2YXIgZGlzcGF0Y2hlciA9IHJlc29sdmVEaXNwYXRjaGVyKCk7XG4gIHJldHVybiBkaXNwYXRjaGVyLnVzZUVmZmVjdChjcmVhdGUsIGRlcHMpO1xufVxuZnVuY3Rpb24gdXNlTGF5b3V0RWZmZWN0KGNyZWF0ZSwgZGVwcykge1xuICB2YXIgZGlzcGF0Y2hlciA9IHJlc29sdmVEaXNwYXRjaGVyKCk7XG4gIHJldHVybiBkaXNwYXRjaGVyLnVzZUxheW91dEVmZmVjdChjcmVhdGUsIGRlcHMpO1xufVxuZnVuY3Rpb24gdXNlQ2FsbGJhY2soY2FsbGJhY2ssIGRlcHMpIHtcbiAgdmFyIGRpc3BhdGNoZXIgPSByZXNvbHZlRGlzcGF0Y2hlcigpO1xuICByZXR1cm4gZGlzcGF0Y2hlci51c2VDYWxsYmFjayhjYWxsYmFjaywgZGVwcyk7XG59XG5mdW5jdGlvbiB1c2VNZW1vKGNyZWF0ZSwgZGVwcykge1xuICB2YXIgZGlzcGF0Y2hlciA9IHJlc29sdmVEaXNwYXRjaGVyKCk7XG4gIHJldHVybiBkaXNwYXRjaGVyLnVzZU1lbW8oY3JlYXRlLCBkZXBzKTtcbn1cbmZ1bmN0aW9uIHVzZUltcGVyYXRpdmVIYW5kbGUocmVmLCBjcmVhdGUsIGRlcHMpIHtcbiAgdmFyIGRpc3BhdGNoZXIgPSByZXNvbHZlRGlzcGF0Y2hlcigpO1xuICByZXR1cm4gZGlzcGF0Y2hlci51c2VJbXBlcmF0aXZlSGFuZGxlKHJlZiwgY3JlYXRlLCBkZXBzKTtcbn1cbmZ1bmN0aW9uIHVzZURlYnVnVmFsdWUodmFsdWUsIGZvcm1hdHRlckZuKSB7XG4gIHtcbiAgICB2YXIgZGlzcGF0Y2hlciA9IHJlc29sdmVEaXNwYXRjaGVyKCk7XG4gICAgcmV0dXJuIGRpc3BhdGNoZXIudXNlRGVidWdWYWx1ZSh2YWx1ZSwgZm9ybWF0dGVyRm4pO1xuICB9XG59XG5cbi8vIEhlbHBlcnMgdG8gcGF0Y2ggY29uc29sZS5sb2dzIHRvIGF2b2lkIGxvZ2dpbmcgZHVyaW5nIHNpZGUtZWZmZWN0IGZyZWVcbi8vIHJlcGxheWluZyBvbiByZW5kZXIgZnVuY3Rpb24uIFRoaXMgY3VycmVudGx5IG9ubHkgcGF0Y2hlcyB0aGUgb2JqZWN0XG4vLyBsYXppbHkgd2hpY2ggd29uJ3QgY292ZXIgaWYgdGhlIGxvZyBmdW5jdGlvbiB3YXMgZXh0cmFjdGVkIGVhZ2VybHkuXG4vLyBXZSBjb3VsZCBhbHNvIGVhZ2VybHkgcGF0Y2ggdGhlIG1ldGhvZC5cbnZhciBkaXNhYmxlZERlcHRoID0gMDtcbnZhciBwcmV2TG9nO1xudmFyIHByZXZJbmZvO1xudmFyIHByZXZXYXJuO1xudmFyIHByZXZFcnJvcjtcbnZhciBwcmV2R3JvdXA7XG52YXIgcHJldkdyb3VwQ29sbGFwc2VkO1xudmFyIHByZXZHcm91cEVuZDtcblxuZnVuY3Rpb24gZGlzYWJsZWRMb2coKSB7fVxuXG5kaXNhYmxlZExvZy5fX3JlYWN0RGlzYWJsZWRMb2cgPSB0cnVlO1xuZnVuY3Rpb24gZGlzYWJsZUxvZ3MoKSB7XG4gIHtcbiAgICBpZiAoZGlzYWJsZWREZXB0aCA9PT0gMCkge1xuICAgICAgLyogZXNsaW50LWRpc2FibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgICBwcmV2TG9nID0gY29uc29sZS5sb2c7XG4gICAgICBwcmV2SW5mbyA9IGNvbnNvbGUuaW5mbztcbiAgICAgIHByZXZXYXJuID0gY29uc29sZS53YXJuO1xuICAgICAgcHJldkVycm9yID0gY29uc29sZS5lcnJvcjtcbiAgICAgIHByZXZHcm91cCA9IGNvbnNvbGUuZ3JvdXA7XG4gICAgICBwcmV2R3JvdXBDb2xsYXBzZWQgPSBjb25zb2xlLmdyb3VwQ29sbGFwc2VkO1xuICAgICAgcHJldkdyb3VwRW5kID0gY29uc29sZS5ncm91cEVuZDsgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xOTA5OVxuXG4gICAgICB2YXIgcHJvcHMgPSB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IGRpc2FibGVkTG9nLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgfTsgLy8gJEZsb3dGaXhNZSBGbG93IHRoaW5rcyBjb25zb2xlIGlzIGltbXV0YWJsZS5cblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoY29uc29sZSwge1xuICAgICAgICBpbmZvOiBwcm9wcyxcbiAgICAgICAgbG9nOiBwcm9wcyxcbiAgICAgICAgd2FybjogcHJvcHMsXG4gICAgICAgIGVycm9yOiBwcm9wcyxcbiAgICAgICAgZ3JvdXA6IHByb3BzLFxuICAgICAgICBncm91cENvbGxhcHNlZDogcHJvcHMsXG4gICAgICAgIGdyb3VwRW5kOiBwcm9wc1xuICAgICAgfSk7XG4gICAgICAvKiBlc2xpbnQtZW5hYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgIH1cblxuICAgIGRpc2FibGVkRGVwdGgrKztcbiAgfVxufVxuZnVuY3Rpb24gcmVlbmFibGVMb2dzKCkge1xuICB7XG4gICAgZGlzYWJsZWREZXB0aC0tO1xuXG4gICAgaWYgKGRpc2FibGVkRGVwdGggPT09IDApIHtcbiAgICAgIC8qIGVzbGludC1kaXNhYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgICAgdmFyIHByb3BzID0ge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICB9OyAvLyAkRmxvd0ZpeE1lIEZsb3cgdGhpbmtzIGNvbnNvbGUgaXMgaW1tdXRhYmxlLlxuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhjb25zb2xlLCB7XG4gICAgICAgIGxvZzogX2Fzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkxvZ1xuICAgICAgICB9KSxcbiAgICAgICAgaW5mbzogX2Fzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkluZm9cbiAgICAgICAgfSksXG4gICAgICAgIHdhcm46IF9hc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZXYXJuXG4gICAgICAgIH0pLFxuICAgICAgICBlcnJvcjogX2Fzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkVycm9yXG4gICAgICAgIH0pLFxuICAgICAgICBncm91cDogX2Fzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkdyb3VwXG4gICAgICAgIH0pLFxuICAgICAgICBncm91cENvbGxhcHNlZDogX2Fzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkdyb3VwQ29sbGFwc2VkXG4gICAgICAgIH0pLFxuICAgICAgICBncm91cEVuZDogX2Fzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkdyb3VwRW5kXG4gICAgICAgIH0pXG4gICAgICB9KTtcbiAgICAgIC8qIGVzbGludC1lbmFibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgfVxuXG4gICAgaWYgKGRpc2FibGVkRGVwdGggPCAwKSB7XG4gICAgICBlcnJvcignZGlzYWJsZWREZXB0aCBmZWxsIGJlbG93IHplcm8uICcgKyAnVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gICAgfVxuICB9XG59XG5cbnZhciBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdEN1cnJlbnREaXNwYXRjaGVyO1xudmFyIHByZWZpeDtcbmZ1bmN0aW9uIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKG5hbWUsIHNvdXJjZSwgb3duZXJGbikge1xuICB7XG4gICAgaWYgKHByZWZpeCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBFeHRyYWN0IHRoZSBWTSBzcGVjaWZpYyBwcmVmaXggdXNlZCBieSBlYWNoIGxpbmUuXG4gICAgICB0cnkge1xuICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICB2YXIgbWF0Y2ggPSB4LnN0YWNrLnRyaW0oKS5tYXRjaCgvXFxuKCAqKGF0ICk/KS8pO1xuICAgICAgICBwcmVmaXggPSBtYXRjaCAmJiBtYXRjaFsxXSB8fCAnJztcbiAgICAgIH1cbiAgICB9IC8vIFdlIHVzZSB0aGUgcHJlZml4IHRvIGVuc3VyZSBvdXIgc3RhY2tzIGxpbmUgdXAgd2l0aCBuYXRpdmUgc3RhY2sgZnJhbWVzLlxuXG5cbiAgICByZXR1cm4gJ1xcbicgKyBwcmVmaXggKyBuYW1lO1xuICB9XG59XG52YXIgcmVlbnRyeSA9IGZhbHNlO1xudmFyIGNvbXBvbmVudEZyYW1lQ2FjaGU7XG5cbntcbiAgdmFyIFBvc3NpYmx5V2Vha01hcCA9IHR5cGVvZiBXZWFrTWFwID09PSAnZnVuY3Rpb24nID8gV2Vha01hcCA6IE1hcDtcbiAgY29tcG9uZW50RnJhbWVDYWNoZSA9IG5ldyBQb3NzaWJseVdlYWtNYXAoKTtcbn1cblxuZnVuY3Rpb24gZGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZShmbiwgY29uc3RydWN0KSB7XG4gIC8vIElmIHNvbWV0aGluZyBhc2tlZCBmb3IgYSBzdGFjayBpbnNpZGUgYSBmYWtlIHJlbmRlciwgaXQgc2hvdWxkIGdldCBpZ25vcmVkLlxuICBpZiAoIWZuIHx8IHJlZW50cnkpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICB7XG4gICAgdmFyIGZyYW1lID0gY29tcG9uZW50RnJhbWVDYWNoZS5nZXQoZm4pO1xuXG4gICAgaWYgKGZyYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBmcmFtZTtcbiAgICB9XG4gIH1cblxuICB2YXIgY29udHJvbDtcbiAgcmVlbnRyeSA9IHRydWU7XG4gIHZhciBwcmV2aW91c1ByZXBhcmVTdGFja1RyYWNlID0gRXJyb3IucHJlcGFyZVN0YWNrVHJhY2U7IC8vICRGbG93Rml4TWUgSXQgZG9lcyBhY2NlcHQgdW5kZWZpbmVkLlxuXG4gIEVycm9yLnByZXBhcmVTdGFja1RyYWNlID0gdW5kZWZpbmVkO1xuICB2YXIgcHJldmlvdXNEaXNwYXRjaGVyO1xuXG4gIHtcbiAgICBwcmV2aW91c0Rpc3BhdGNoZXIgPSBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudDsgLy8gU2V0IHRoZSBkaXNwYXRjaGVyIGluIERFViBiZWNhdXNlIHRoaXMgbWlnaHQgYmUgY2FsbCBpbiB0aGUgcmVuZGVyIGZ1bmN0aW9uXG4gICAgLy8gZm9yIHdhcm5pbmdzLlxuXG4gICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSBudWxsO1xuICAgIGRpc2FibGVMb2dzKCk7XG4gIH1cblxuICB0cnkge1xuICAgIC8vIFRoaXMgc2hvdWxkIHRocm93LlxuICAgIGlmIChjb25zdHJ1Y3QpIHtcbiAgICAgIC8vIFNvbWV0aGluZyBzaG91bGQgYmUgc2V0dGluZyB0aGUgcHJvcHMgaW4gdGhlIGNvbnN0cnVjdG9yLlxuICAgICAgdmFyIEZha2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICB9OyAvLyAkRmxvd0ZpeE1lXG5cblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZha2UucHJvdG90eXBlLCAncHJvcHMnLCB7XG4gICAgICAgIHNldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIC8vIFdlIHVzZSBhIHRocm93aW5nIHNldHRlciBpbnN0ZWFkIG9mIGZyb3plbiBvciBub24td3JpdGFibGUgcHJvcHNcbiAgICAgICAgICAvLyBiZWNhdXNlIHRoYXQgd29uJ3QgdGhyb3cgaW4gYSBub24tc3RyaWN0IG1vZGUgZnVuY3Rpb24uXG4gICAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gJ29iamVjdCcgJiYgUmVmbGVjdC5jb25zdHJ1Y3QpIHtcbiAgICAgICAgLy8gV2UgY29uc3RydWN0IGEgZGlmZmVyZW50IGNvbnRyb2wgZm9yIHRoaXMgY2FzZSB0byBpbmNsdWRlIGFueSBleHRyYVxuICAgICAgICAvLyBmcmFtZXMgYWRkZWQgYnkgdGhlIGNvbnN0cnVjdCBjYWxsLlxuICAgICAgICB0cnkge1xuICAgICAgICAgIFJlZmxlY3QuY29uc3RydWN0KEZha2UsIFtdKTtcbiAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgIGNvbnRyb2wgPSB4O1xuICAgICAgICB9XG5cbiAgICAgICAgUmVmbGVjdC5jb25zdHJ1Y3QoZm4sIFtdLCBGYWtlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgRmFrZS5jYWxsKCk7XG4gICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICBjb250cm9sID0geDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZuLmNhbGwoRmFrZS5wcm90b3R5cGUpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0cnkge1xuICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICBjb250cm9sID0geDtcbiAgICAgIH1cblxuICAgICAgZm4oKTtcbiAgICB9XG4gIH0gY2F0Y2ggKHNhbXBsZSkge1xuICAgIC8vIFRoaXMgaXMgaW5saW5lZCBtYW51YWxseSBiZWNhdXNlIGNsb3N1cmUgZG9lc24ndCBkbyBpdCBmb3IgdXMuXG4gICAgaWYgKHNhbXBsZSAmJiBjb250cm9sICYmIHR5cGVvZiBzYW1wbGUuc3RhY2sgPT09ICdzdHJpbmcnKSB7XG4gICAgICAvLyBUaGlzIGV4dHJhY3RzIHRoZSBmaXJzdCBmcmFtZSBmcm9tIHRoZSBzYW1wbGUgdGhhdCBpc24ndCBhbHNvIGluIHRoZSBjb250cm9sLlxuICAgICAgLy8gU2tpcHBpbmcgb25lIGZyYW1lIHRoYXQgd2UgYXNzdW1lIGlzIHRoZSBmcmFtZSB0aGF0IGNhbGxzIHRoZSB0d28uXG4gICAgICB2YXIgc2FtcGxlTGluZXMgPSBzYW1wbGUuc3RhY2suc3BsaXQoJ1xcbicpO1xuICAgICAgdmFyIGNvbnRyb2xMaW5lcyA9IGNvbnRyb2wuc3RhY2suc3BsaXQoJ1xcbicpO1xuICAgICAgdmFyIHMgPSBzYW1wbGVMaW5lcy5sZW5ndGggLSAxO1xuICAgICAgdmFyIGMgPSBjb250cm9sTGluZXMubGVuZ3RoIC0gMTtcblxuICAgICAgd2hpbGUgKHMgPj0gMSAmJiBjID49IDAgJiYgc2FtcGxlTGluZXNbc10gIT09IGNvbnRyb2xMaW5lc1tjXSkge1xuICAgICAgICAvLyBXZSBleHBlY3QgYXQgbGVhc3Qgb25lIHN0YWNrIGZyYW1lIHRvIGJlIHNoYXJlZC5cbiAgICAgICAgLy8gVHlwaWNhbGx5IHRoaXMgd2lsbCBiZSB0aGUgcm9vdCBtb3N0IG9uZS4gSG93ZXZlciwgc3RhY2sgZnJhbWVzIG1heSBiZVxuICAgICAgICAvLyBjdXQgb2ZmIGR1ZSB0byBtYXhpbXVtIHN0YWNrIGxpbWl0cy4gSW4gdGhpcyBjYXNlLCBvbmUgbWF5YmUgY3V0IG9mZlxuICAgICAgICAvLyBlYXJsaWVyIHRoYW4gdGhlIG90aGVyLiBXZSBhc3N1bWUgdGhhdCB0aGUgc2FtcGxlIGlzIGxvbmdlciBvciB0aGUgc2FtZVxuICAgICAgICAvLyBhbmQgdGhlcmUgZm9yIGN1dCBvZmYgZWFybGllci4gU28gd2Ugc2hvdWxkIGZpbmQgdGhlIHJvb3QgbW9zdCBmcmFtZSBpblxuICAgICAgICAvLyB0aGUgc2FtcGxlIHNvbWV3aGVyZSBpbiB0aGUgY29udHJvbC5cbiAgICAgICAgYy0tO1xuICAgICAgfVxuXG4gICAgICBmb3IgKDsgcyA+PSAxICYmIGMgPj0gMDsgcy0tLCBjLS0pIHtcbiAgICAgICAgLy8gTmV4dCB3ZSBmaW5kIHRoZSBmaXJzdCBvbmUgdGhhdCBpc24ndCB0aGUgc2FtZSB3aGljaCBzaG91bGQgYmUgdGhlXG4gICAgICAgIC8vIGZyYW1lIHRoYXQgY2FsbGVkIG91ciBzYW1wbGUgZnVuY3Rpb24gYW5kIHRoZSBjb250cm9sLlxuICAgICAgICBpZiAoc2FtcGxlTGluZXNbc10gIT09IGNvbnRyb2xMaW5lc1tjXSkge1xuICAgICAgICAgIC8vIEluIFY4LCB0aGUgZmlyc3QgbGluZSBpcyBkZXNjcmliaW5nIHRoZSBtZXNzYWdlIGJ1dCBvdGhlciBWTXMgZG9uJ3QuXG4gICAgICAgICAgLy8gSWYgd2UncmUgYWJvdXQgdG8gcmV0dXJuIHRoZSBmaXJzdCBsaW5lLCBhbmQgdGhlIGNvbnRyb2wgaXMgYWxzbyBvbiB0aGUgc2FtZVxuICAgICAgICAgIC8vIGxpbmUsIHRoYXQncyBhIHByZXR0eSBnb29kIGluZGljYXRvciB0aGF0IG91ciBzYW1wbGUgdGhyZXcgYXQgc2FtZSBsaW5lIGFzXG4gICAgICAgICAgLy8gdGhlIGNvbnRyb2wuIEkuZS4gYmVmb3JlIHdlIGVudGVyZWQgdGhlIHNhbXBsZSBmcmFtZS4gU28gd2UgaWdub3JlIHRoaXMgcmVzdWx0LlxuICAgICAgICAgIC8vIFRoaXMgY2FuIGhhcHBlbiBpZiB5b3UgcGFzc2VkIGEgY2xhc3MgdG8gZnVuY3Rpb24gY29tcG9uZW50LCBvciBub24tZnVuY3Rpb24uXG4gICAgICAgICAgaWYgKHMgIT09IDEgfHwgYyAhPT0gMSkge1xuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICBzLS07XG4gICAgICAgICAgICAgIGMtLTsgLy8gV2UgbWF5IHN0aWxsIGhhdmUgc2ltaWxhciBpbnRlcm1lZGlhdGUgZnJhbWVzIGZyb20gdGhlIGNvbnN0cnVjdCBjYWxsLlxuICAgICAgICAgICAgICAvLyBUaGUgbmV4dCBvbmUgdGhhdCBpc24ndCB0aGUgc2FtZSBzaG91bGQgYmUgb3VyIG1hdGNoIHRob3VnaC5cblxuICAgICAgICAgICAgICBpZiAoYyA8IDAgfHwgc2FtcGxlTGluZXNbc10gIT09IGNvbnRyb2xMaW5lc1tjXSkge1xuICAgICAgICAgICAgICAgIC8vIFY4IGFkZHMgYSBcIm5ld1wiIHByZWZpeCBmb3IgbmF0aXZlIGNsYXNzZXMuIExldCdzIHJlbW92ZSBpdCB0byBtYWtlIGl0IHByZXR0aWVyLlxuICAgICAgICAgICAgICAgIHZhciBfZnJhbWUgPSAnXFxuJyArIHNhbXBsZUxpbmVzW3NdLnJlcGxhY2UoJyBhdCBuZXcgJywgJyBhdCAnKTtcblxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50RnJhbWVDYWNoZS5zZXQoZm4sIF9mcmFtZSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSAvLyBSZXR1cm4gdGhlIGxpbmUgd2UgZm91bmQuXG5cblxuICAgICAgICAgICAgICAgIHJldHVybiBfZnJhbWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gd2hpbGUgKHMgPj0gMSAmJiBjID49IDApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9IGZpbmFsbHkge1xuICAgIHJlZW50cnkgPSBmYWxzZTtcblxuICAgIHtcbiAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gcHJldmlvdXNEaXNwYXRjaGVyO1xuICAgICAgcmVlbmFibGVMb2dzKCk7XG4gICAgfVxuXG4gICAgRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSBwcmV2aW91c1ByZXBhcmVTdGFja1RyYWNlO1xuICB9IC8vIEZhbGxiYWNrIHRvIGp1c3QgdXNpbmcgdGhlIG5hbWUgaWYgd2UgY291bGRuJ3QgbWFrZSBpdCB0aHJvdy5cblxuXG4gIHZhciBuYW1lID0gZm4gPyBmbi5kaXNwbGF5TmFtZSB8fCBmbi5uYW1lIDogJyc7XG4gIHZhciBzeW50aGV0aWNGcmFtZSA9IG5hbWUgPyBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZShuYW1lKSA6ICcnO1xuXG4gIHtcbiAgICBpZiAodHlwZW9mIGZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjb21wb25lbnRGcmFtZUNhY2hlLnNldChmbiwgc3ludGhldGljRnJhbWUpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzeW50aGV0aWNGcmFtZTtcbn1cbmZ1bmN0aW9uIGRlc2NyaWJlRnVuY3Rpb25Db21wb25lbnRGcmFtZShmbiwgc291cmNlLCBvd25lckZuKSB7XG4gIHtcbiAgICByZXR1cm4gZGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZShmbiwgZmFsc2UpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHNob3VsZENvbnN0cnVjdChDb21wb25lbnQpIHtcbiAgdmFyIHByb3RvdHlwZSA9IENvbXBvbmVudC5wcm90b3R5cGU7XG4gIHJldHVybiAhIShwcm90b3R5cGUgJiYgcHJvdG90eXBlLmlzUmVhY3RDb21wb25lbnQpO1xufVxuXG5mdW5jdGlvbiBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYodHlwZSwgc291cmNlLCBvd25lckZuKSB7XG5cbiAgaWYgKHR5cGUgPT0gbnVsbCkge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHtcbiAgICAgIHJldHVybiBkZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lKHR5cGUsIHNob3VsZENvbnN0cnVjdCh0eXBlKSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSh0eXBlKTtcbiAgfVxuXG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgZXhwb3J0cy5TdXNwZW5zZTpcbiAgICAgIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSgnU3VzcGVuc2UnKTtcblxuICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFOlxuICAgICAgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKCdTdXNwZW5zZUxpc3QnKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICBzd2l0Y2ggKHR5cGUuJCR0eXBlb2YpIHtcbiAgICAgIGNhc2UgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTpcbiAgICAgICAgcmV0dXJuIGRlc2NyaWJlRnVuY3Rpb25Db21wb25lbnRGcmFtZSh0eXBlLnJlbmRlcik7XG5cbiAgICAgIGNhc2UgUkVBQ1RfTUVNT19UWVBFOlxuICAgICAgICAvLyBNZW1vIG1heSBjb250YWluIGFueSBjb21wb25lbnQgdHlwZSBzbyB3ZSByZWN1cnNpdmVseSByZXNvbHZlIGl0LlxuICAgICAgICByZXR1cm4gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKHR5cGUudHlwZSwgc291cmNlLCBvd25lckZuKTtcblxuICAgICAgY2FzZSBSRUFDVF9CTE9DS19UWVBFOlxuICAgICAgICByZXR1cm4gZGVzY3JpYmVGdW5jdGlvbkNvbXBvbmVudEZyYW1lKHR5cGUuX3JlbmRlcik7XG5cbiAgICAgIGNhc2UgUkVBQ1RfTEFaWV9UWVBFOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIGxhenlDb21wb25lbnQgPSB0eXBlO1xuICAgICAgICAgIHZhciBwYXlsb2FkID0gbGF6eUNvbXBvbmVudC5fcGF5bG9hZDtcbiAgICAgICAgICB2YXIgaW5pdCA9IGxhenlDb21wb25lbnQuX2luaXQ7XG5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gTGF6eSBtYXkgY29udGFpbiBhbnkgY29tcG9uZW50IHR5cGUgc28gd2UgcmVjdXJzaXZlbHkgcmVzb2x2ZSBpdC5cbiAgICAgICAgICAgIHJldHVybiBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYoaW5pdChwYXlsb2FkKSwgc291cmNlLCBvd25lckZuKTtcbiAgICAgICAgICB9IGNhdGNoICh4KSB7fVxuICAgICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuICcnO1xufVxuXG52YXIgbG9nZ2VkVHlwZUZhaWx1cmVzID0ge307XG52YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSQxID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZTtcblxuZnVuY3Rpb24gc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZWxlbWVudCkge1xuICB7XG4gICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgIHZhciBvd25lciA9IGVsZW1lbnQuX293bmVyO1xuICAgICAgdmFyIHN0YWNrID0gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKGVsZW1lbnQudHlwZSwgZWxlbWVudC5fc291cmNlLCBvd25lciA/IG93bmVyLnR5cGUgOiBudWxsKTtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWUkMS5zZXRFeHRyYVN0YWNrRnJhbWUoc3RhY2spO1xuICAgIH0gZWxzZSB7XG4gICAgICBSZWFjdERlYnVnQ3VycmVudEZyYW1lJDEuc2V0RXh0cmFTdGFja0ZyYW1lKG51bGwpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjaGVja1Byb3BUeXBlcyh0eXBlU3BlY3MsIHZhbHVlcywgbG9jYXRpb24sIGNvbXBvbmVudE5hbWUsIGVsZW1lbnQpIHtcbiAge1xuICAgIC8vICRGbG93Rml4TWUgVGhpcyBpcyBva2F5IGJ1dCBGbG93IGRvZXNuJ3Qga25vdyBpdC5cbiAgICB2YXIgaGFzID0gRnVuY3Rpb24uY2FsbC5iaW5kKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkpO1xuXG4gICAgZm9yICh2YXIgdHlwZVNwZWNOYW1lIGluIHR5cGVTcGVjcykge1xuICAgICAgaWYgKGhhcyh0eXBlU3BlY3MsIHR5cGVTcGVjTmFtZSkpIHtcbiAgICAgICAgdmFyIGVycm9yJDEgPSB2b2lkIDA7IC8vIFByb3AgdHlwZSB2YWxpZGF0aW9uIG1heSB0aHJvdy4gSW4gY2FzZSB0aGV5IGRvLCB3ZSBkb24ndCB3YW50IHRvXG4gICAgICAgIC8vIGZhaWwgdGhlIHJlbmRlciBwaGFzZSB3aGVyZSBpdCBkaWRuJ3QgZmFpbCBiZWZvcmUuIFNvIHdlIGxvZyBpdC5cbiAgICAgICAgLy8gQWZ0ZXIgdGhlc2UgaGF2ZSBiZWVuIGNsZWFuZWQgdXAsIHdlJ2xsIGxldCB0aGVtIHRocm93LlxuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgLy8gVGhpcyBpcyBpbnRlbnRpb25hbGx5IGFuIGludmFyaWFudCB0aGF0IGdldHMgY2F1Z2h0LiBJdCdzIHRoZSBzYW1lXG4gICAgICAgICAgLy8gYmVoYXZpb3IgYXMgd2l0aG91dCB0aGlzIHN0YXRlbWVudCBleGNlcHQgd2l0aCBhIGJldHRlciBtZXNzYWdlLlxuICAgICAgICAgIGlmICh0eXBlb2YgdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHZhciBlcnIgPSBFcnJvcigoY29tcG9uZW50TmFtZSB8fCAnUmVhY3QgY2xhc3MnKSArICc6ICcgKyBsb2NhdGlvbiArICcgdHlwZSBgJyArIHR5cGVTcGVjTmFtZSArICdgIGlzIGludmFsaWQ7ICcgKyAnaXQgbXVzdCBiZSBhIGZ1bmN0aW9uLCB1c3VhbGx5IGZyb20gdGhlIGBwcm9wLXR5cGVzYCBwYWNrYWdlLCBidXQgcmVjZWl2ZWQgYCcgKyB0eXBlb2YgdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0gKyAnYC4nICsgJ1RoaXMgb2Z0ZW4gaGFwcGVucyBiZWNhdXNlIG9mIHR5cG9zIHN1Y2ggYXMgYFByb3BUeXBlcy5mdW5jdGlvbmAgaW5zdGVhZCBvZiBgUHJvcFR5cGVzLmZ1bmNgLicpO1xuICAgICAgICAgICAgZXJyLm5hbWUgPSAnSW52YXJpYW50IFZpb2xhdGlvbic7XG4gICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZXJyb3IkMSA9IHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdKHZhbHVlcywgdHlwZVNwZWNOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgbnVsbCwgJ1NFQ1JFVF9ET19OT1RfUEFTU19USElTX09SX1lPVV9XSUxMX0JFX0ZJUkVEJyk7XG4gICAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgZXJyb3IkMSA9IGV4O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVycm9yJDEgJiYgIShlcnJvciQxIGluc3RhbmNlb2YgRXJyb3IpKSB7XG4gICAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZWxlbWVudCk7XG5cbiAgICAgICAgICBlcnJvcignJXM6IHR5cGUgc3BlY2lmaWNhdGlvbiBvZiAlcycgKyAnIGAlc2AgaXMgaW52YWxpZDsgdGhlIHR5cGUgY2hlY2tlciAnICsgJ2Z1bmN0aW9uIG11c3QgcmV0dXJuIGBudWxsYCBvciBhbiBgRXJyb3JgIGJ1dCByZXR1cm5lZCBhICVzLiAnICsgJ1lvdSBtYXkgaGF2ZSBmb3Jnb3R0ZW4gdG8gcGFzcyBhbiBhcmd1bWVudCB0byB0aGUgdHlwZSBjaGVja2VyICcgKyAnY3JlYXRvciAoYXJyYXlPZiwgaW5zdGFuY2VPZiwgb2JqZWN0T2YsIG9uZU9mLCBvbmVPZlR5cGUsIGFuZCAnICsgJ3NoYXBlIGFsbCByZXF1aXJlIGFuIGFyZ3VtZW50KS4nLCBjb21wb25lbnROYW1lIHx8ICdSZWFjdCBjbGFzcycsIGxvY2F0aW9uLCB0eXBlU3BlY05hbWUsIHR5cGVvZiBlcnJvciQxKTtcblxuICAgICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KG51bGwpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVycm9yJDEgaW5zdGFuY2VvZiBFcnJvciAmJiAhKGVycm9yJDEubWVzc2FnZSBpbiBsb2dnZWRUeXBlRmFpbHVyZXMpKSB7XG4gICAgICAgICAgLy8gT25seSBtb25pdG9yIHRoaXMgZmFpbHVyZSBvbmNlIGJlY2F1c2UgdGhlcmUgdGVuZHMgdG8gYmUgYSBsb3Qgb2YgdGhlXG4gICAgICAgICAgLy8gc2FtZSBlcnJvci5cbiAgICAgICAgICBsb2dnZWRUeXBlRmFpbHVyZXNbZXJyb3IkMS5tZXNzYWdlXSA9IHRydWU7XG4gICAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZWxlbWVudCk7XG5cbiAgICAgICAgICBlcnJvcignRmFpbGVkICVzIHR5cGU6ICVzJywgbG9jYXRpb24sIGVycm9yJDEubWVzc2FnZSk7XG5cbiAgICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChudWxsKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKGVsZW1lbnQpIHtcbiAge1xuICAgIGlmIChlbGVtZW50KSB7XG4gICAgICB2YXIgb3duZXIgPSBlbGVtZW50Ll9vd25lcjtcbiAgICAgIHZhciBzdGFjayA9IGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVihlbGVtZW50LnR5cGUsIGVsZW1lbnQuX3NvdXJjZSwgb3duZXIgPyBvd25lci50eXBlIDogbnVsbCk7XG4gICAgICBzZXRFeHRyYVN0YWNrRnJhbWUoc3RhY2spO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZXRFeHRyYVN0YWNrRnJhbWUobnVsbCk7XG4gICAgfVxuICB9XG59XG5cbnZhciBwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93bjtcblxue1xuICBwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93biA9IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKSB7XG4gIGlmIChSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50KSB7XG4gICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lKFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQudHlwZSk7XG5cbiAgICBpZiAobmFtZSkge1xuICAgICAgcmV0dXJuICdcXG5cXG5DaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBgJyArIG5hbWUgKyAnYC4nO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiAnJztcbn1cblxuZnVuY3Rpb24gZ2V0U291cmNlSW5mb0Vycm9yQWRkZW5kdW0oc291cmNlKSB7XG4gIGlmIChzb3VyY2UgIT09IHVuZGVmaW5lZCkge1xuICAgIHZhciBmaWxlTmFtZSA9IHNvdXJjZS5maWxlTmFtZS5yZXBsYWNlKC9eLipbXFxcXFxcL10vLCAnJyk7XG4gICAgdmFyIGxpbmVOdW1iZXIgPSBzb3VyY2UubGluZU51bWJlcjtcbiAgICByZXR1cm4gJ1xcblxcbkNoZWNrIHlvdXIgY29kZSBhdCAnICsgZmlsZU5hbWUgKyAnOicgKyBsaW5lTnVtYmVyICsgJy4nO1xuICB9XG5cbiAgcmV0dXJuICcnO1xufVxuXG5mdW5jdGlvbiBnZXRTb3VyY2VJbmZvRXJyb3JBZGRlbmR1bUZvclByb3BzKGVsZW1lbnRQcm9wcykge1xuICBpZiAoZWxlbWVudFByb3BzICE9PSBudWxsICYmIGVsZW1lbnRQcm9wcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIGdldFNvdXJjZUluZm9FcnJvckFkZGVuZHVtKGVsZW1lbnRQcm9wcy5fX3NvdXJjZSk7XG4gIH1cblxuICByZXR1cm4gJyc7XG59XG4vKipcbiAqIFdhcm4gaWYgdGhlcmUncyBubyBrZXkgZXhwbGljaXRseSBzZXQgb24gZHluYW1pYyBhcnJheXMgb2YgY2hpbGRyZW4gb3JcbiAqIG9iamVjdCBrZXlzIGFyZSBub3QgdmFsaWQuIFRoaXMgYWxsb3dzIHVzIHRvIGtlZXAgdHJhY2sgb2YgY2hpbGRyZW4gYmV0d2VlblxuICogdXBkYXRlcy5cbiAqL1xuXG5cbnZhciBvd25lckhhc0tleVVzZVdhcm5pbmcgPSB7fTtcblxuZnVuY3Rpb24gZ2V0Q3VycmVudENvbXBvbmVudEVycm9ySW5mbyhwYXJlbnRUeXBlKSB7XG4gIHZhciBpbmZvID0gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKCk7XG5cbiAgaWYgKCFpbmZvKSB7XG4gICAgdmFyIHBhcmVudE5hbWUgPSB0eXBlb2YgcGFyZW50VHlwZSA9PT0gJ3N0cmluZycgPyBwYXJlbnRUeXBlIDogcGFyZW50VHlwZS5kaXNwbGF5TmFtZSB8fCBwYXJlbnRUeXBlLm5hbWU7XG5cbiAgICBpZiAocGFyZW50TmFtZSkge1xuICAgICAgaW5mbyA9IFwiXFxuXFxuQ2hlY2sgdGhlIHRvcC1sZXZlbCByZW5kZXIgY2FsbCB1c2luZyA8XCIgKyBwYXJlbnROYW1lICsgXCI+LlwiO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBpbmZvO1xufVxuLyoqXG4gKiBXYXJuIGlmIHRoZSBlbGVtZW50IGRvZXNuJ3QgaGF2ZSBhbiBleHBsaWNpdCBrZXkgYXNzaWduZWQgdG8gaXQuXG4gKiBUaGlzIGVsZW1lbnQgaXMgaW4gYW4gYXJyYXkuIFRoZSBhcnJheSBjb3VsZCBncm93IGFuZCBzaHJpbmsgb3IgYmVcbiAqIHJlb3JkZXJlZC4gQWxsIGNoaWxkcmVuIHRoYXQgaGF2ZW4ndCBhbHJlYWR5IGJlZW4gdmFsaWRhdGVkIGFyZSByZXF1aXJlZCB0b1xuICogaGF2ZSBhIFwia2V5XCIgcHJvcGVydHkgYXNzaWduZWQgdG8gaXQuIEVycm9yIHN0YXR1c2VzIGFyZSBjYWNoZWQgc28gYSB3YXJuaW5nXG4gKiB3aWxsIG9ubHkgYmUgc2hvd24gb25jZS5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBlbGVtZW50IEVsZW1lbnQgdGhhdCByZXF1aXJlcyBhIGtleS5cbiAqIEBwYXJhbSB7Kn0gcGFyZW50VHlwZSBlbGVtZW50J3MgcGFyZW50J3MgdHlwZS5cbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlRXhwbGljaXRLZXkoZWxlbWVudCwgcGFyZW50VHlwZSkge1xuICBpZiAoIWVsZW1lbnQuX3N0b3JlIHx8IGVsZW1lbnQuX3N0b3JlLnZhbGlkYXRlZCB8fCBlbGVtZW50LmtleSAhPSBudWxsKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgZWxlbWVudC5fc3RvcmUudmFsaWRhdGVkID0gdHJ1ZTtcbiAgdmFyIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8gPSBnZXRDdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvKHBhcmVudFR5cGUpO1xuXG4gIGlmIChvd25lckhhc0tleVVzZVdhcm5pbmdbY3VycmVudENvbXBvbmVudEVycm9ySW5mb10pIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBvd25lckhhc0tleVVzZVdhcm5pbmdbY3VycmVudENvbXBvbmVudEVycm9ySW5mb10gPSB0cnVlOyAvLyBVc3VhbGx5IHRoZSBjdXJyZW50IG93bmVyIGlzIHRoZSBvZmZlbmRlciwgYnV0IGlmIGl0IGFjY2VwdHMgY2hpbGRyZW4gYXMgYVxuICAvLyBwcm9wZXJ0eSwgaXQgbWF5IGJlIHRoZSBjcmVhdG9yIG9mIHRoZSBjaGlsZCB0aGF0J3MgcmVzcG9uc2libGUgZm9yXG4gIC8vIGFzc2lnbmluZyBpdCBhIGtleS5cblxuICB2YXIgY2hpbGRPd25lciA9ICcnO1xuXG4gIGlmIChlbGVtZW50ICYmIGVsZW1lbnQuX293bmVyICYmIGVsZW1lbnQuX293bmVyICE9PSBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50KSB7XG4gICAgLy8gR2l2ZSB0aGUgY29tcG9uZW50IHRoYXQgb3JpZ2luYWxseSBjcmVhdGVkIHRoaXMgY2hpbGQuXG4gICAgY2hpbGRPd25lciA9IFwiIEl0IHdhcyBwYXNzZWQgYSBjaGlsZCBmcm9tIFwiICsgZ2V0Q29tcG9uZW50TmFtZShlbGVtZW50Ll9vd25lci50eXBlKSArIFwiLlwiO1xuICB9XG5cbiAge1xuICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEoZWxlbWVudCk7XG5cbiAgICBlcnJvcignRWFjaCBjaGlsZCBpbiBhIGxpc3Qgc2hvdWxkIGhhdmUgYSB1bmlxdWUgXCJrZXlcIiBwcm9wLicgKyAnJXMlcyBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3dhcm5pbmcta2V5cyBmb3IgbW9yZSBpbmZvcm1hdGlvbi4nLCBjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvLCBjaGlsZE93bmVyKTtcblxuICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEobnVsbCk7XG4gIH1cbn1cbi8qKlxuICogRW5zdXJlIHRoYXQgZXZlcnkgZWxlbWVudCBlaXRoZXIgaXMgcGFzc2VkIGluIGEgc3RhdGljIGxvY2F0aW9uLCBpbiBhblxuICogYXJyYXkgd2l0aCBhbiBleHBsaWNpdCBrZXlzIHByb3BlcnR5IGRlZmluZWQsIG9yIGluIGFuIG9iamVjdCBsaXRlcmFsXG4gKiB3aXRoIHZhbGlkIGtleSBwcm9wZXJ0eS5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqIEBwYXJhbSB7UmVhY3ROb2RlfSBub2RlIFN0YXRpY2FsbHkgcGFzc2VkIGNoaWxkIG9mIGFueSB0eXBlLlxuICogQHBhcmFtIHsqfSBwYXJlbnRUeXBlIG5vZGUncyBwYXJlbnQncyB0eXBlLlxuICovXG5cblxuZnVuY3Rpb24gdmFsaWRhdGVDaGlsZEtleXMobm9kZSwgcGFyZW50VHlwZSkge1xuICBpZiAodHlwZW9mIG5vZGUgIT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkobm9kZSkpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGUubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjaGlsZCA9IG5vZGVbaV07XG5cbiAgICAgIGlmIChpc1ZhbGlkRWxlbWVudChjaGlsZCkpIHtcbiAgICAgICAgdmFsaWRhdGVFeHBsaWNpdEtleShjaGlsZCwgcGFyZW50VHlwZSk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzVmFsaWRFbGVtZW50KG5vZGUpKSB7XG4gICAgLy8gVGhpcyBlbGVtZW50IHdhcyBwYXNzZWQgaW4gYSB2YWxpZCBsb2NhdGlvbi5cbiAgICBpZiAobm9kZS5fc3RvcmUpIHtcbiAgICAgIG5vZGUuX3N0b3JlLnZhbGlkYXRlZCA9IHRydWU7XG4gICAgfVxuICB9IGVsc2UgaWYgKG5vZGUpIHtcbiAgICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4obm9kZSk7XG5cbiAgICBpZiAodHlwZW9mIGl0ZXJhdG9yRm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIC8vIEVudHJ5IGl0ZXJhdG9ycyB1c2VkIHRvIHByb3ZpZGUgaW1wbGljaXQga2V5cyxcbiAgICAgIC8vIGJ1dCBub3cgd2UgcHJpbnQgYSBzZXBhcmF0ZSB3YXJuaW5nIGZvciB0aGVtIGxhdGVyLlxuICAgICAgaWYgKGl0ZXJhdG9yRm4gIT09IG5vZGUuZW50cmllcykge1xuICAgICAgICB2YXIgaXRlcmF0b3IgPSBpdGVyYXRvckZuLmNhbGwobm9kZSk7XG4gICAgICAgIHZhciBzdGVwO1xuXG4gICAgICAgIHdoaWxlICghKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgICAgICBpZiAoaXNWYWxpZEVsZW1lbnQoc3RlcC52YWx1ZSkpIHtcbiAgICAgICAgICAgIHZhbGlkYXRlRXhwbGljaXRLZXkoc3RlcC52YWx1ZSwgcGFyZW50VHlwZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG4vKipcbiAqIEdpdmVuIGFuIGVsZW1lbnQsIHZhbGlkYXRlIHRoYXQgaXRzIHByb3BzIGZvbGxvdyB0aGUgcHJvcFR5cGVzIGRlZmluaXRpb24sXG4gKiBwcm92aWRlZCBieSB0aGUgdHlwZS5cbiAqXG4gKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gZWxlbWVudFxuICovXG5cblxuZnVuY3Rpb24gdmFsaWRhdGVQcm9wVHlwZXMoZWxlbWVudCkge1xuICB7XG4gICAgdmFyIHR5cGUgPSBlbGVtZW50LnR5cGU7XG5cbiAgICBpZiAodHlwZSA9PT0gbnVsbCB8fCB0eXBlID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHByb3BUeXBlcztcblxuICAgIGlmICh0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcHJvcFR5cGVzID0gdHlwZS5wcm9wVHlwZXM7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgKHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgfHwgLy8gTm90ZTogTWVtbyBvbmx5IGNoZWNrcyBvdXRlciBwcm9wcyBoZXJlLlxuICAgIC8vIElubmVyIHByb3BzIGFyZSBjaGVja2VkIGluIHRoZSByZWNvbmNpbGVyLlxuICAgIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX01FTU9fVFlQRSkpIHtcbiAgICAgIHByb3BUeXBlcyA9IHR5cGUucHJvcFR5cGVzO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHByb3BUeXBlcykge1xuICAgICAgLy8gSW50ZW50aW9uYWxseSBpbnNpZGUgdG8gYXZvaWQgdHJpZ2dlcmluZyBsYXp5IGluaXRpYWxpemVyczpcbiAgICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZSh0eXBlKTtcbiAgICAgIGNoZWNrUHJvcFR5cGVzKHByb3BUeXBlcywgZWxlbWVudC5wcm9wcywgJ3Byb3AnLCBuYW1lLCBlbGVtZW50KTtcbiAgICB9IGVsc2UgaWYgKHR5cGUuUHJvcFR5cGVzICE9PSB1bmRlZmluZWQgJiYgIXByb3BUeXBlc01pc3NwZWxsV2FybmluZ1Nob3duKSB7XG4gICAgICBwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93biA9IHRydWU7IC8vIEludGVudGlvbmFsbHkgaW5zaWRlIHRvIGF2b2lkIHRyaWdnZXJpbmcgbGF6eSBpbml0aWFsaXplcnM6XG5cbiAgICAgIHZhciBfbmFtZSA9IGdldENvbXBvbmVudE5hbWUodHlwZSk7XG5cbiAgICAgIGVycm9yKCdDb21wb25lbnQgJXMgZGVjbGFyZWQgYFByb3BUeXBlc2AgaW5zdGVhZCBvZiBgcHJvcFR5cGVzYC4gRGlkIHlvdSBtaXNzcGVsbCB0aGUgcHJvcGVydHkgYXNzaWdubWVudD8nLCBfbmFtZSB8fCAnVW5rbm93bicpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdHlwZS5nZXREZWZhdWx0UHJvcHMgPT09ICdmdW5jdGlvbicgJiYgIXR5cGUuZ2V0RGVmYXVsdFByb3BzLmlzUmVhY3RDbGFzc0FwcHJvdmVkKSB7XG4gICAgICBlcnJvcignZ2V0RGVmYXVsdFByb3BzIGlzIG9ubHkgdXNlZCBvbiBjbGFzc2ljIFJlYWN0LmNyZWF0ZUNsYXNzICcgKyAnZGVmaW5pdGlvbnMuIFVzZSBhIHN0YXRpYyBwcm9wZXJ0eSBuYW1lZCBgZGVmYXVsdFByb3BzYCBpbnN0ZWFkLicpO1xuICAgIH1cbiAgfVxufVxuLyoqXG4gKiBHaXZlbiBhIGZyYWdtZW50LCB2YWxpZGF0ZSB0aGF0IGl0IGNhbiBvbmx5IGJlIHByb3ZpZGVkIHdpdGggZnJhZ21lbnQgcHJvcHNcbiAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBmcmFnbWVudFxuICovXG5cblxuZnVuY3Rpb24gdmFsaWRhdGVGcmFnbWVudFByb3BzKGZyYWdtZW50KSB7XG4gIHtcbiAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGZyYWdtZW50LnByb3BzKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGtleSA9IGtleXNbaV07XG5cbiAgICAgIGlmIChrZXkgIT09ICdjaGlsZHJlbicgJiYga2V5ICE9PSAna2V5Jykge1xuICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKGZyYWdtZW50KTtcblxuICAgICAgICBlcnJvcignSW52YWxpZCBwcm9wIGAlc2Agc3VwcGxpZWQgdG8gYFJlYWN0LkZyYWdtZW50YC4gJyArICdSZWFjdC5GcmFnbWVudCBjYW4gb25seSBoYXZlIGBrZXlgIGFuZCBgY2hpbGRyZW5gIHByb3BzLicsIGtleSk7XG5cbiAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShudWxsKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGZyYWdtZW50LnJlZiAhPT0gbnVsbCkge1xuICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShmcmFnbWVudCk7XG5cbiAgICAgIGVycm9yKCdJbnZhbGlkIGF0dHJpYnV0ZSBgcmVmYCBzdXBwbGllZCB0byBgUmVhY3QuRnJhZ21lbnRgLicpO1xuXG4gICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKG51bGwpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gY3JlYXRlRWxlbWVudFdpdGhWYWxpZGF0aW9uKHR5cGUsIHByb3BzLCBjaGlsZHJlbikge1xuICB2YXIgdmFsaWRUeXBlID0gaXNWYWxpZEVsZW1lbnRUeXBlKHR5cGUpOyAvLyBXZSB3YXJuIGluIHRoaXMgY2FzZSBidXQgZG9uJ3QgdGhyb3cuIFdlIGV4cGVjdCB0aGUgZWxlbWVudCBjcmVhdGlvbiB0b1xuICAvLyBzdWNjZWVkIGFuZCB0aGVyZSB3aWxsIGxpa2VseSBiZSBlcnJvcnMgaW4gcmVuZGVyLlxuXG4gIGlmICghdmFsaWRUeXBlKSB7XG4gICAgdmFyIGluZm8gPSAnJztcblxuICAgIGlmICh0eXBlID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmIHR5cGUgIT09IG51bGwgJiYgT2JqZWN0LmtleXModHlwZSkubGVuZ3RoID09PSAwKSB7XG4gICAgICBpbmZvICs9ICcgWW91IGxpa2VseSBmb3Jnb3QgdG8gZXhwb3J0IHlvdXIgY29tcG9uZW50IGZyb20gdGhlIGZpbGUgJyArIFwiaXQncyBkZWZpbmVkIGluLCBvciB5b3UgbWlnaHQgaGF2ZSBtaXhlZCB1cCBkZWZhdWx0IGFuZCBuYW1lZCBpbXBvcnRzLlwiO1xuICAgIH1cblxuICAgIHZhciBzb3VyY2VJbmZvID0gZ2V0U291cmNlSW5mb0Vycm9yQWRkZW5kdW1Gb3JQcm9wcyhwcm9wcyk7XG5cbiAgICBpZiAoc291cmNlSW5mbykge1xuICAgICAgaW5mbyArPSBzb3VyY2VJbmZvO1xuICAgIH0gZWxzZSB7XG4gICAgICBpbmZvICs9IGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bSgpO1xuICAgIH1cblxuICAgIHZhciB0eXBlU3RyaW5nO1xuXG4gICAgaWYgKHR5cGUgPT09IG51bGwpIHtcbiAgICAgIHR5cGVTdHJpbmcgPSAnbnVsbCc7XG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHR5cGUpKSB7XG4gICAgICB0eXBlU3RyaW5nID0gJ2FycmF5JztcbiAgICB9IGVsc2UgaWYgKHR5cGUgIT09IHVuZGVmaW5lZCAmJiB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEUpIHtcbiAgICAgIHR5cGVTdHJpbmcgPSBcIjxcIiArIChnZXRDb21wb25lbnROYW1lKHR5cGUudHlwZSkgfHwgJ1Vua25vd24nKSArIFwiIC8+XCI7XG4gICAgICBpbmZvID0gJyBEaWQgeW91IGFjY2lkZW50YWxseSBleHBvcnQgYSBKU1ggbGl0ZXJhbCBpbnN0ZWFkIG9mIGEgY29tcG9uZW50Pyc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHR5cGVTdHJpbmcgPSB0eXBlb2YgdHlwZTtcbiAgICB9XG5cbiAgICB7XG4gICAgICBlcnJvcignUmVhY3QuY3JlYXRlRWxlbWVudDogdHlwZSBpcyBpbnZhbGlkIC0tIGV4cGVjdGVkIGEgc3RyaW5nIChmb3IgJyArICdidWlsdC1pbiBjb21wb25lbnRzKSBvciBhIGNsYXNzL2Z1bmN0aW9uIChmb3IgY29tcG9zaXRlICcgKyAnY29tcG9uZW50cykgYnV0IGdvdDogJXMuJXMnLCB0eXBlU3RyaW5nLCBpbmZvKTtcbiAgICB9XG4gIH1cblxuICB2YXIgZWxlbWVudCA9IGNyZWF0ZUVsZW1lbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgLy8gVGhlIHJlc3VsdCBjYW4gYmUgbnVsbGlzaCBpZiBhIG1vY2sgb3IgYSBjdXN0b20gZnVuY3Rpb24gaXMgdXNlZC5cbiAgLy8gVE9ETzogRHJvcCB0aGlzIHdoZW4gdGhlc2UgYXJlIG5vIGxvbmdlciBhbGxvd2VkIGFzIHRoZSB0eXBlIGFyZ3VtZW50LlxuXG4gIGlmIChlbGVtZW50ID09IG51bGwpIHtcbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfSAvLyBTa2lwIGtleSB3YXJuaW5nIGlmIHRoZSB0eXBlIGlzbid0IHZhbGlkIHNpbmNlIG91ciBrZXkgdmFsaWRhdGlvbiBsb2dpY1xuICAvLyBkb2Vzbid0IGV4cGVjdCBhIG5vbi1zdHJpbmcvZnVuY3Rpb24gdHlwZSBhbmQgY2FuIHRocm93IGNvbmZ1c2luZyBlcnJvcnMuXG4gIC8vIFdlIGRvbid0IHdhbnQgZXhjZXB0aW9uIGJlaGF2aW9yIHRvIGRpZmZlciBiZXR3ZWVuIGRldiBhbmQgcHJvZC5cbiAgLy8gKFJlbmRlcmluZyB3aWxsIHRocm93IHdpdGggYSBoZWxwZnVsIG1lc3NhZ2UgYW5kIGFzIHNvb24gYXMgdGhlIHR5cGUgaXNcbiAgLy8gZml4ZWQsIHRoZSBrZXkgd2FybmluZ3Mgd2lsbCBhcHBlYXIuKVxuXG5cbiAgaWYgKHZhbGlkVHlwZSkge1xuICAgIGZvciAodmFyIGkgPSAyOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YWxpZGF0ZUNoaWxkS2V5cyhhcmd1bWVudHNbaV0sIHR5cGUpO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0eXBlID09PSBleHBvcnRzLkZyYWdtZW50KSB7XG4gICAgdmFsaWRhdGVGcmFnbWVudFByb3BzKGVsZW1lbnQpO1xuICB9IGVsc2Uge1xuICAgIHZhbGlkYXRlUHJvcFR5cGVzKGVsZW1lbnQpO1xuICB9XG5cbiAgcmV0dXJuIGVsZW1lbnQ7XG59XG52YXIgZGlkV2FybkFib3V0RGVwcmVjYXRlZENyZWF0ZUZhY3RvcnkgPSBmYWxzZTtcbmZ1bmN0aW9uIGNyZWF0ZUZhY3RvcnlXaXRoVmFsaWRhdGlvbih0eXBlKSB7XG4gIHZhciB2YWxpZGF0ZWRGYWN0b3J5ID0gY3JlYXRlRWxlbWVudFdpdGhWYWxpZGF0aW9uLmJpbmQobnVsbCwgdHlwZSk7XG4gIHZhbGlkYXRlZEZhY3RvcnkudHlwZSA9IHR5cGU7XG5cbiAge1xuICAgIGlmICghZGlkV2FybkFib3V0RGVwcmVjYXRlZENyZWF0ZUZhY3RvcnkpIHtcbiAgICAgIGRpZFdhcm5BYm91dERlcHJlY2F0ZWRDcmVhdGVGYWN0b3J5ID0gdHJ1ZTtcblxuICAgICAgd2FybignUmVhY3QuY3JlYXRlRmFjdG9yeSgpIGlzIGRlcHJlY2F0ZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiAnICsgJ2EgZnV0dXJlIG1ham9yIHJlbGVhc2UuIENvbnNpZGVyIHVzaW5nIEpTWCAnICsgJ29yIHVzZSBSZWFjdC5jcmVhdGVFbGVtZW50KCkgZGlyZWN0bHkgaW5zdGVhZC4nKTtcbiAgICB9IC8vIExlZ2FjeSBob29rOiByZW1vdmUgaXRcblxuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHZhbGlkYXRlZEZhY3RvcnksICd0eXBlJywge1xuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgd2FybignRmFjdG9yeS50eXBlIGlzIGRlcHJlY2F0ZWQuIEFjY2VzcyB0aGUgY2xhc3MgZGlyZWN0bHkgJyArICdiZWZvcmUgcGFzc2luZyBpdCB0byBjcmVhdGVGYWN0b3J5LicpO1xuXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAndHlwZScsIHtcbiAgICAgICAgICB2YWx1ZTogdHlwZVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHR5cGU7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gdmFsaWRhdGVkRmFjdG9yeTtcbn1cbmZ1bmN0aW9uIGNsb25lRWxlbWVudFdpdGhWYWxpZGF0aW9uKGVsZW1lbnQsIHByb3BzLCBjaGlsZHJlbikge1xuICB2YXIgbmV3RWxlbWVudCA9IGNsb25lRWxlbWVudC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gIGZvciAodmFyIGkgPSAyOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFsaWRhdGVDaGlsZEtleXMoYXJndW1lbnRzW2ldLCBuZXdFbGVtZW50LnR5cGUpO1xuICB9XG5cbiAgdmFsaWRhdGVQcm9wVHlwZXMobmV3RWxlbWVudCk7XG4gIHJldHVybiBuZXdFbGVtZW50O1xufVxuXG57XG5cbiAgdHJ5IHtcbiAgICB2YXIgZnJvemVuT2JqZWN0ID0gT2JqZWN0LmZyZWV6ZSh7fSk7XG4gICAgLyogZXNsaW50LWRpc2FibGUgbm8tbmV3ICovXG5cbiAgICBuZXcgTWFwKFtbZnJvemVuT2JqZWN0LCBudWxsXV0pO1xuICAgIG5ldyBTZXQoW2Zyb3plbk9iamVjdF0pO1xuICAgIC8qIGVzbGludC1lbmFibGUgbm8tbmV3ICovXG4gIH0gY2F0Y2ggKGUpIHtcbiAgfVxufVxuXG52YXIgY3JlYXRlRWxlbWVudCQxID0gIGNyZWF0ZUVsZW1lbnRXaXRoVmFsaWRhdGlvbiA7XG52YXIgY2xvbmVFbGVtZW50JDEgPSAgY2xvbmVFbGVtZW50V2l0aFZhbGlkYXRpb24gO1xudmFyIGNyZWF0ZUZhY3RvcnkgPSAgY3JlYXRlRmFjdG9yeVdpdGhWYWxpZGF0aW9uIDtcbnZhciBDaGlsZHJlbiA9IHtcbiAgbWFwOiBtYXBDaGlsZHJlbixcbiAgZm9yRWFjaDogZm9yRWFjaENoaWxkcmVuLFxuICBjb3VudDogY291bnRDaGlsZHJlbixcbiAgdG9BcnJheTogdG9BcnJheSxcbiAgb25seTogb25seUNoaWxkXG59O1xuXG5leHBvcnRzLkNoaWxkcmVuID0gQ2hpbGRyZW47XG5leHBvcnRzLkNvbXBvbmVudCA9IENvbXBvbmVudDtcbmV4cG9ydHMuUHVyZUNvbXBvbmVudCA9IFB1cmVDb21wb25lbnQ7XG5leHBvcnRzLl9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEID0gUmVhY3RTaGFyZWRJbnRlcm5hbHM7XG5leHBvcnRzLmNsb25lRWxlbWVudCA9IGNsb25lRWxlbWVudCQxO1xuZXhwb3J0cy5jcmVhdGVDb250ZXh0ID0gY3JlYXRlQ29udGV4dDtcbmV4cG9ydHMuY3JlYXRlRWxlbWVudCA9IGNyZWF0ZUVsZW1lbnQkMTtcbmV4cG9ydHMuY3JlYXRlRmFjdG9yeSA9IGNyZWF0ZUZhY3Rvcnk7XG5leHBvcnRzLmNyZWF0ZVJlZiA9IGNyZWF0ZVJlZjtcbmV4cG9ydHMuZm9yd2FyZFJlZiA9IGZvcndhcmRSZWY7XG5leHBvcnRzLmlzVmFsaWRFbGVtZW50ID0gaXNWYWxpZEVsZW1lbnQ7XG5leHBvcnRzLmxhenkgPSBsYXp5O1xuZXhwb3J0cy5tZW1vID0gbWVtbztcbmV4cG9ydHMudXNlQ2FsbGJhY2sgPSB1c2VDYWxsYmFjaztcbmV4cG9ydHMudXNlQ29udGV4dCA9IHVzZUNvbnRleHQ7XG5leHBvcnRzLnVzZURlYnVnVmFsdWUgPSB1c2VEZWJ1Z1ZhbHVlO1xuZXhwb3J0cy51c2VFZmZlY3QgPSB1c2VFZmZlY3Q7XG5leHBvcnRzLnVzZUltcGVyYXRpdmVIYW5kbGUgPSB1c2VJbXBlcmF0aXZlSGFuZGxlO1xuZXhwb3J0cy51c2VMYXlvdXRFZmZlY3QgPSB1c2VMYXlvdXRFZmZlY3Q7XG5leHBvcnRzLnVzZU1lbW8gPSB1c2VNZW1vO1xuZXhwb3J0cy51c2VSZWR1Y2VyID0gdXNlUmVkdWNlcjtcbmV4cG9ydHMudXNlUmVmID0gdXNlUmVmO1xuZXhwb3J0cy51c2VTdGF0ZSA9IHVzZVN0YXRlO1xuZXhwb3J0cy52ZXJzaW9uID0gUmVhY3RWZXJzaW9uO1xuICB9KSgpO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJykge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LnByb2R1Y3Rpb24ubWluLmpzJyk7XG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LmRldmVsb3BtZW50LmpzJyk7XG59XG4iLCIvKiogQGxpY2Vuc2UgUmVhY3QgdjAuMjAuMlxuICogc2NoZWR1bGVyLXRyYWNpbmcuZGV2ZWxvcG1lbnQuanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgKGZ1bmN0aW9uKCkge1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgREVGQVVMVF9USFJFQURfSUQgPSAwOyAvLyBDb3VudGVycyB1c2VkIHRvIGdlbmVyYXRlIHVuaXF1ZSBJRHMuXG5cbnZhciBpbnRlcmFjdGlvbklEQ291bnRlciA9IDA7XG52YXIgdGhyZWFkSURDb3VudGVyID0gMDsgLy8gU2V0IG9mIGN1cnJlbnRseSB0cmFjZWQgaW50ZXJhY3Rpb25zLlxuLy8gSW50ZXJhY3Rpb25zIFwic3RhY2tcIuKAk1xuLy8gTWVhbmluZyB0aGF0IG5ld2x5IHRyYWNlZCBpbnRlcmFjdGlvbnMgYXJlIGFwcGVuZGVkIHRvIHRoZSBwcmV2aW91c2x5IGFjdGl2ZSBzZXQuXG4vLyBXaGVuIGFuIGludGVyYWN0aW9uIGdvZXMgb3V0IG9mIHNjb3BlLCB0aGUgcHJldmlvdXMgc2V0IChpZiBhbnkpIGlzIHJlc3RvcmVkLlxuXG5leHBvcnRzLl9faW50ZXJhY3Rpb25zUmVmID0gbnVsbDsgLy8gTGlzdGVuZXIocykgdG8gbm90aWZ5IHdoZW4gaW50ZXJhY3Rpb25zIGJlZ2luIGFuZCBlbmQuXG5cbmV4cG9ydHMuX19zdWJzY3JpYmVyUmVmID0gbnVsbDtcblxue1xuICBleHBvcnRzLl9faW50ZXJhY3Rpb25zUmVmID0ge1xuICAgIGN1cnJlbnQ6IG5ldyBTZXQoKVxuICB9O1xuICBleHBvcnRzLl9fc3Vic2NyaWJlclJlZiA9IHtcbiAgICBjdXJyZW50OiBudWxsXG4gIH07XG59XG5mdW5jdGlvbiB1bnN0YWJsZV9jbGVhcihjYWxsYmFjaykge1xuXG4gIHZhciBwcmV2SW50ZXJhY3Rpb25zID0gZXhwb3J0cy5fX2ludGVyYWN0aW9uc1JlZi5jdXJyZW50O1xuICBleHBvcnRzLl9faW50ZXJhY3Rpb25zUmVmLmN1cnJlbnQgPSBuZXcgU2V0KCk7XG5cbiAgdHJ5IHtcbiAgICByZXR1cm4gY2FsbGJhY2soKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBleHBvcnRzLl9faW50ZXJhY3Rpb25zUmVmLmN1cnJlbnQgPSBwcmV2SW50ZXJhY3Rpb25zO1xuICB9XG59XG5mdW5jdGlvbiB1bnN0YWJsZV9nZXRDdXJyZW50KCkge1xuICB7XG4gICAgcmV0dXJuIGV4cG9ydHMuX19pbnRlcmFjdGlvbnNSZWYuY3VycmVudDtcbiAgfVxufVxuZnVuY3Rpb24gdW5zdGFibGVfZ2V0VGhyZWFkSUQoKSB7XG4gIHJldHVybiArK3RocmVhZElEQ291bnRlcjtcbn1cbmZ1bmN0aW9uIHVuc3RhYmxlX3RyYWNlKG5hbWUsIHRpbWVzdGFtcCwgY2FsbGJhY2spIHtcbiAgdmFyIHRocmVhZElEID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiBERUZBVUxUX1RIUkVBRF9JRDtcblxuICB2YXIgaW50ZXJhY3Rpb24gPSB7XG4gICAgX19jb3VudDogMSxcbiAgICBpZDogaW50ZXJhY3Rpb25JRENvdW50ZXIrKyxcbiAgICBuYW1lOiBuYW1lLFxuICAgIHRpbWVzdGFtcDogdGltZXN0YW1wXG4gIH07XG4gIHZhciBwcmV2SW50ZXJhY3Rpb25zID0gZXhwb3J0cy5fX2ludGVyYWN0aW9uc1JlZi5jdXJyZW50OyAvLyBUcmFjZWQgaW50ZXJhY3Rpb25zIHNob3VsZCBzdGFjay9hY2N1bXVsYXRlLlxuICAvLyBUbyBkbyB0aGF0LCBjbG9uZSB0aGUgY3VycmVudCBpbnRlcmFjdGlvbnMuXG4gIC8vIFRoZSBwcmV2aW91cyBzZXQgd2lsbCBiZSByZXN0b3JlZCB1cG9uIGNvbXBsZXRpb24uXG5cbiAgdmFyIGludGVyYWN0aW9ucyA9IG5ldyBTZXQocHJldkludGVyYWN0aW9ucyk7XG4gIGludGVyYWN0aW9ucy5hZGQoaW50ZXJhY3Rpb24pO1xuICBleHBvcnRzLl9faW50ZXJhY3Rpb25zUmVmLmN1cnJlbnQgPSBpbnRlcmFjdGlvbnM7XG4gIHZhciBzdWJzY3JpYmVyID0gZXhwb3J0cy5fX3N1YnNjcmliZXJSZWYuY3VycmVudDtcbiAgdmFyIHJldHVyblZhbHVlO1xuXG4gIHRyeSB7XG4gICAgaWYgKHN1YnNjcmliZXIgIT09IG51bGwpIHtcbiAgICAgIHN1YnNjcmliZXIub25JbnRlcmFjdGlvblRyYWNlZChpbnRlcmFjdGlvbik7XG4gICAgfVxuICB9IGZpbmFsbHkge1xuICAgIHRyeSB7XG4gICAgICBpZiAoc3Vic2NyaWJlciAhPT0gbnVsbCkge1xuICAgICAgICBzdWJzY3JpYmVyLm9uV29ya1N0YXJ0ZWQoaW50ZXJhY3Rpb25zLCB0aHJlYWRJRCk7XG4gICAgICB9XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVyblZhbHVlID0gY2FsbGJhY2soKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGV4cG9ydHMuX19pbnRlcmFjdGlvbnNSZWYuY3VycmVudCA9IHByZXZJbnRlcmFjdGlvbnM7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpZiAoc3Vic2NyaWJlciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgc3Vic2NyaWJlci5vbldvcmtTdG9wcGVkKGludGVyYWN0aW9ucywgdGhyZWFkSUQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBpbnRlcmFjdGlvbi5fX2NvdW50LS07IC8vIElmIG5vIGFzeW5jIHdvcmsgd2FzIHNjaGVkdWxlZCBmb3IgdGhpcyBpbnRlcmFjdGlvbixcbiAgICAgICAgICAvLyBOb3RpZnkgc3Vic2NyaWJlcnMgdGhhdCBpdCdzIGNvbXBsZXRlZC5cblxuICAgICAgICAgIGlmIChzdWJzY3JpYmVyICE9PSBudWxsICYmIGludGVyYWN0aW9uLl9fY291bnQgPT09IDApIHtcbiAgICAgICAgICAgIHN1YnNjcmliZXIub25JbnRlcmFjdGlvblNjaGVkdWxlZFdvcmtDb21wbGV0ZWQoaW50ZXJhY3Rpb24pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXR1cm5WYWx1ZTtcbn1cbmZ1bmN0aW9uIHVuc3RhYmxlX3dyYXAoY2FsbGJhY2spIHtcbiAgdmFyIHRocmVhZElEID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBERUZBVUxUX1RIUkVBRF9JRDtcblxuICB2YXIgd3JhcHBlZEludGVyYWN0aW9ucyA9IGV4cG9ydHMuX19pbnRlcmFjdGlvbnNSZWYuY3VycmVudDtcbiAgdmFyIHN1YnNjcmliZXIgPSBleHBvcnRzLl9fc3Vic2NyaWJlclJlZi5jdXJyZW50O1xuXG4gIGlmIChzdWJzY3JpYmVyICE9PSBudWxsKSB7XG4gICAgc3Vic2NyaWJlci5vbldvcmtTY2hlZHVsZWQod3JhcHBlZEludGVyYWN0aW9ucywgdGhyZWFkSUQpO1xuICB9IC8vIFVwZGF0ZSB0aGUgcGVuZGluZyBhc3luYyB3b3JrIGNvdW50IGZvciB0aGUgY3VycmVudCBpbnRlcmFjdGlvbnMuXG4gIC8vIFVwZGF0ZSBhZnRlciBjYWxsaW5nIHN1YnNjcmliZXJzIGluIGNhc2Ugb2YgZXJyb3IuXG5cblxuICB3cmFwcGVkSW50ZXJhY3Rpb25zLmZvckVhY2goZnVuY3Rpb24gKGludGVyYWN0aW9uKSB7XG4gICAgaW50ZXJhY3Rpb24uX19jb3VudCsrO1xuICB9KTtcbiAgdmFyIGhhc1J1biA9IGZhbHNlO1xuXG4gIGZ1bmN0aW9uIHdyYXBwZWQoKSB7XG4gICAgdmFyIHByZXZJbnRlcmFjdGlvbnMgPSBleHBvcnRzLl9faW50ZXJhY3Rpb25zUmVmLmN1cnJlbnQ7XG4gICAgZXhwb3J0cy5fX2ludGVyYWN0aW9uc1JlZi5jdXJyZW50ID0gd3JhcHBlZEludGVyYWN0aW9ucztcbiAgICBzdWJzY3JpYmVyID0gZXhwb3J0cy5fX3N1YnNjcmliZXJSZWYuY3VycmVudDtcblxuICAgIHRyeSB7XG4gICAgICB2YXIgcmV0dXJuVmFsdWU7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGlmIChzdWJzY3JpYmVyICE9PSBudWxsKSB7XG4gICAgICAgICAgc3Vic2NyaWJlci5vbldvcmtTdGFydGVkKHdyYXBwZWRJbnRlcmFjdGlvbnMsIHRocmVhZElEKTtcbiAgICAgICAgfVxuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm5WYWx1ZSA9IGNhbGxiYWNrLmFwcGx5KHVuZGVmaW5lZCwgYXJndW1lbnRzKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBleHBvcnRzLl9faW50ZXJhY3Rpb25zUmVmLmN1cnJlbnQgPSBwcmV2SW50ZXJhY3Rpb25zO1xuXG4gICAgICAgICAgaWYgKHN1YnNjcmliZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHN1YnNjcmliZXIub25Xb3JrU3RvcHBlZCh3cmFwcGVkSW50ZXJhY3Rpb25zLCB0aHJlYWRJRCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXR1cm5WYWx1ZTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgaWYgKCFoYXNSdW4pIHtcbiAgICAgICAgLy8gV2Ugb25seSBleHBlY3QgYSB3cmFwcGVkIGZ1bmN0aW9uIHRvIGJlIGV4ZWN1dGVkIG9uY2UsXG4gICAgICAgIC8vIEJ1dCBpbiB0aGUgZXZlbnQgdGhhdCBpdCdzIGV4ZWN1dGVkIG1vcmUgdGhhbiBvbmNl4oCTXG4gICAgICAgIC8vIE9ubHkgZGVjcmVtZW50IHRoZSBvdXRzdGFuZGluZyBpbnRlcmFjdGlvbiBjb3VudHMgb25jZS5cbiAgICAgICAgaGFzUnVuID0gdHJ1ZTsgLy8gVXBkYXRlIHBlbmRpbmcgYXN5bmMgY291bnRzIGZvciBhbGwgd3JhcHBlZCBpbnRlcmFjdGlvbnMuXG4gICAgICAgIC8vIElmIHRoaXMgd2FzIHRoZSBsYXN0IHNjaGVkdWxlZCBhc3luYyB3b3JrIGZvciBhbnkgb2YgdGhlbSxcbiAgICAgICAgLy8gTWFyayB0aGVtIGFzIGNvbXBsZXRlZC5cblxuICAgICAgICB3cmFwcGVkSW50ZXJhY3Rpb25zLmZvckVhY2goZnVuY3Rpb24gKGludGVyYWN0aW9uKSB7XG4gICAgICAgICAgaW50ZXJhY3Rpb24uX19jb3VudC0tO1xuXG4gICAgICAgICAgaWYgKHN1YnNjcmliZXIgIT09IG51bGwgJiYgaW50ZXJhY3Rpb24uX19jb3VudCA9PT0gMCkge1xuICAgICAgICAgICAgc3Vic2NyaWJlci5vbkludGVyYWN0aW9uU2NoZWR1bGVkV29ya0NvbXBsZXRlZChpbnRlcmFjdGlvbik7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB3cmFwcGVkLmNhbmNlbCA9IGZ1bmN0aW9uIGNhbmNlbCgpIHtcbiAgICBzdWJzY3JpYmVyID0gZXhwb3J0cy5fX3N1YnNjcmliZXJSZWYuY3VycmVudDtcblxuICAgIHRyeSB7XG4gICAgICBpZiAoc3Vic2NyaWJlciAhPT0gbnVsbCkge1xuICAgICAgICBzdWJzY3JpYmVyLm9uV29ya0NhbmNlbGVkKHdyYXBwZWRJbnRlcmFjdGlvbnMsIHRocmVhZElEKTtcbiAgICAgIH1cbiAgICB9IGZpbmFsbHkge1xuICAgICAgLy8gVXBkYXRlIHBlbmRpbmcgYXN5bmMgY291bnRzIGZvciBhbGwgd3JhcHBlZCBpbnRlcmFjdGlvbnMuXG4gICAgICAvLyBJZiB0aGlzIHdhcyB0aGUgbGFzdCBzY2hlZHVsZWQgYXN5bmMgd29yayBmb3IgYW55IG9mIHRoZW0sXG4gICAgICAvLyBNYXJrIHRoZW0gYXMgY29tcGxldGVkLlxuICAgICAgd3JhcHBlZEludGVyYWN0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChpbnRlcmFjdGlvbikge1xuICAgICAgICBpbnRlcmFjdGlvbi5fX2NvdW50LS07XG5cbiAgICAgICAgaWYgKHN1YnNjcmliZXIgJiYgaW50ZXJhY3Rpb24uX19jb3VudCA9PT0gMCkge1xuICAgICAgICAgIHN1YnNjcmliZXIub25JbnRlcmFjdGlvblNjaGVkdWxlZFdvcmtDb21wbGV0ZWQoaW50ZXJhY3Rpb24pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIHdyYXBwZWQ7XG59XG5cbnZhciBzdWJzY3JpYmVycyA9IG51bGw7XG5cbntcbiAgc3Vic2NyaWJlcnMgPSBuZXcgU2V0KCk7XG59XG5cbmZ1bmN0aW9uIHVuc3RhYmxlX3N1YnNjcmliZShzdWJzY3JpYmVyKSB7XG4gIHtcbiAgICBzdWJzY3JpYmVycy5hZGQoc3Vic2NyaWJlcik7XG5cbiAgICBpZiAoc3Vic2NyaWJlcnMuc2l6ZSA9PT0gMSkge1xuICAgICAgZXhwb3J0cy5fX3N1YnNjcmliZXJSZWYuY3VycmVudCA9IHtcbiAgICAgICAgb25JbnRlcmFjdGlvblNjaGVkdWxlZFdvcmtDb21wbGV0ZWQ6IG9uSW50ZXJhY3Rpb25TY2hlZHVsZWRXb3JrQ29tcGxldGVkLFxuICAgICAgICBvbkludGVyYWN0aW9uVHJhY2VkOiBvbkludGVyYWN0aW9uVHJhY2VkLFxuICAgICAgICBvbldvcmtDYW5jZWxlZDogb25Xb3JrQ2FuY2VsZWQsXG4gICAgICAgIG9uV29ya1NjaGVkdWxlZDogb25Xb3JrU2NoZWR1bGVkLFxuICAgICAgICBvbldvcmtTdGFydGVkOiBvbldvcmtTdGFydGVkLFxuICAgICAgICBvbldvcmtTdG9wcGVkOiBvbldvcmtTdG9wcGVkXG4gICAgICB9O1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gdW5zdGFibGVfdW5zdWJzY3JpYmUoc3Vic2NyaWJlcikge1xuICB7XG4gICAgc3Vic2NyaWJlcnMuZGVsZXRlKHN1YnNjcmliZXIpO1xuXG4gICAgaWYgKHN1YnNjcmliZXJzLnNpemUgPT09IDApIHtcbiAgICAgIGV4cG9ydHMuX19zdWJzY3JpYmVyUmVmLmN1cnJlbnQgPSBudWxsO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBvbkludGVyYWN0aW9uVHJhY2VkKGludGVyYWN0aW9uKSB7XG4gIHZhciBkaWRDYXRjaEVycm9yID0gZmFsc2U7XG4gIHZhciBjYXVnaHRFcnJvciA9IG51bGw7XG4gIHN1YnNjcmliZXJzLmZvckVhY2goZnVuY3Rpb24gKHN1YnNjcmliZXIpIHtcbiAgICB0cnkge1xuICAgICAgc3Vic2NyaWJlci5vbkludGVyYWN0aW9uVHJhY2VkKGludGVyYWN0aW9uKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKCFkaWRDYXRjaEVycm9yKSB7XG4gICAgICAgIGRpZENhdGNoRXJyb3IgPSB0cnVlO1xuICAgICAgICBjYXVnaHRFcnJvciA9IGVycm9yO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG5cbiAgaWYgKGRpZENhdGNoRXJyb3IpIHtcbiAgICB0aHJvdyBjYXVnaHRFcnJvcjtcbiAgfVxufVxuXG5mdW5jdGlvbiBvbkludGVyYWN0aW9uU2NoZWR1bGVkV29ya0NvbXBsZXRlZChpbnRlcmFjdGlvbikge1xuICB2YXIgZGlkQ2F0Y2hFcnJvciA9IGZhbHNlO1xuICB2YXIgY2F1Z2h0RXJyb3IgPSBudWxsO1xuICBzdWJzY3JpYmVycy5mb3JFYWNoKGZ1bmN0aW9uIChzdWJzY3JpYmVyKSB7XG4gICAgdHJ5IHtcbiAgICAgIHN1YnNjcmliZXIub25JbnRlcmFjdGlvblNjaGVkdWxlZFdvcmtDb21wbGV0ZWQoaW50ZXJhY3Rpb24pO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpZiAoIWRpZENhdGNoRXJyb3IpIHtcbiAgICAgICAgZGlkQ2F0Y2hFcnJvciA9IHRydWU7XG4gICAgICAgIGNhdWdodEVycm9yID0gZXJyb3I7XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICBpZiAoZGlkQ2F0Y2hFcnJvcikge1xuICAgIHRocm93IGNhdWdodEVycm9yO1xuICB9XG59XG5cbmZ1bmN0aW9uIG9uV29ya1NjaGVkdWxlZChpbnRlcmFjdGlvbnMsIHRocmVhZElEKSB7XG4gIHZhciBkaWRDYXRjaEVycm9yID0gZmFsc2U7XG4gIHZhciBjYXVnaHRFcnJvciA9IG51bGw7XG4gIHN1YnNjcmliZXJzLmZvckVhY2goZnVuY3Rpb24gKHN1YnNjcmliZXIpIHtcbiAgICB0cnkge1xuICAgICAgc3Vic2NyaWJlci5vbldvcmtTY2hlZHVsZWQoaW50ZXJhY3Rpb25zLCB0aHJlYWRJRCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmICghZGlkQ2F0Y2hFcnJvcikge1xuICAgICAgICBkaWRDYXRjaEVycm9yID0gdHJ1ZTtcbiAgICAgICAgY2F1Z2h0RXJyb3IgPSBlcnJvcjtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIGlmIChkaWRDYXRjaEVycm9yKSB7XG4gICAgdGhyb3cgY2F1Z2h0RXJyb3I7XG4gIH1cbn1cblxuZnVuY3Rpb24gb25Xb3JrU3RhcnRlZChpbnRlcmFjdGlvbnMsIHRocmVhZElEKSB7XG4gIHZhciBkaWRDYXRjaEVycm9yID0gZmFsc2U7XG4gIHZhciBjYXVnaHRFcnJvciA9IG51bGw7XG4gIHN1YnNjcmliZXJzLmZvckVhY2goZnVuY3Rpb24gKHN1YnNjcmliZXIpIHtcbiAgICB0cnkge1xuICAgICAgc3Vic2NyaWJlci5vbldvcmtTdGFydGVkKGludGVyYWN0aW9ucywgdGhyZWFkSUQpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpZiAoIWRpZENhdGNoRXJyb3IpIHtcbiAgICAgICAgZGlkQ2F0Y2hFcnJvciA9IHRydWU7XG4gICAgICAgIGNhdWdodEVycm9yID0gZXJyb3I7XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICBpZiAoZGlkQ2F0Y2hFcnJvcikge1xuICAgIHRocm93IGNhdWdodEVycm9yO1xuICB9XG59XG5cbmZ1bmN0aW9uIG9uV29ya1N0b3BwZWQoaW50ZXJhY3Rpb25zLCB0aHJlYWRJRCkge1xuICB2YXIgZGlkQ2F0Y2hFcnJvciA9IGZhbHNlO1xuICB2YXIgY2F1Z2h0RXJyb3IgPSBudWxsO1xuICBzdWJzY3JpYmVycy5mb3JFYWNoKGZ1bmN0aW9uIChzdWJzY3JpYmVyKSB7XG4gICAgdHJ5IHtcbiAgICAgIHN1YnNjcmliZXIub25Xb3JrU3RvcHBlZChpbnRlcmFjdGlvbnMsIHRocmVhZElEKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKCFkaWRDYXRjaEVycm9yKSB7XG4gICAgICAgIGRpZENhdGNoRXJyb3IgPSB0cnVlO1xuICAgICAgICBjYXVnaHRFcnJvciA9IGVycm9yO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG5cbiAgaWYgKGRpZENhdGNoRXJyb3IpIHtcbiAgICB0aHJvdyBjYXVnaHRFcnJvcjtcbiAgfVxufVxuXG5mdW5jdGlvbiBvbldvcmtDYW5jZWxlZChpbnRlcmFjdGlvbnMsIHRocmVhZElEKSB7XG4gIHZhciBkaWRDYXRjaEVycm9yID0gZmFsc2U7XG4gIHZhciBjYXVnaHRFcnJvciA9IG51bGw7XG4gIHN1YnNjcmliZXJzLmZvckVhY2goZnVuY3Rpb24gKHN1YnNjcmliZXIpIHtcbiAgICB0cnkge1xuICAgICAgc3Vic2NyaWJlci5vbldvcmtDYW5jZWxlZChpbnRlcmFjdGlvbnMsIHRocmVhZElEKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKCFkaWRDYXRjaEVycm9yKSB7XG4gICAgICAgIGRpZENhdGNoRXJyb3IgPSB0cnVlO1xuICAgICAgICBjYXVnaHRFcnJvciA9IGVycm9yO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG5cbiAgaWYgKGRpZENhdGNoRXJyb3IpIHtcbiAgICB0aHJvdyBjYXVnaHRFcnJvcjtcbiAgfVxufVxuXG5leHBvcnRzLnVuc3RhYmxlX2NsZWFyID0gdW5zdGFibGVfY2xlYXI7XG5leHBvcnRzLnVuc3RhYmxlX2dldEN1cnJlbnQgPSB1bnN0YWJsZV9nZXRDdXJyZW50O1xuZXhwb3J0cy51bnN0YWJsZV9nZXRUaHJlYWRJRCA9IHVuc3RhYmxlX2dldFRocmVhZElEO1xuZXhwb3J0cy51bnN0YWJsZV9zdWJzY3JpYmUgPSB1bnN0YWJsZV9zdWJzY3JpYmU7XG5leHBvcnRzLnVuc3RhYmxlX3RyYWNlID0gdW5zdGFibGVfdHJhY2U7XG5leHBvcnRzLnVuc3RhYmxlX3Vuc3Vic2NyaWJlID0gdW5zdGFibGVfdW5zdWJzY3JpYmU7XG5leHBvcnRzLnVuc3RhYmxlX3dyYXAgPSB1bnN0YWJsZV93cmFwO1xuICB9KSgpO1xufVxuIiwiLyoqIEBsaWNlbnNlIFJlYWN0IHYwLjIwLjJcbiAqIHNjaGVkdWxlci5kZXZlbG9wbWVudC5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAoZnVuY3Rpb24oKSB7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBlbmFibGVTY2hlZHVsZXJEZWJ1Z2dpbmcgPSBmYWxzZTtcbnZhciBlbmFibGVQcm9maWxpbmcgPSBmYWxzZTtcblxudmFyIHJlcXVlc3RIb3N0Q2FsbGJhY2s7XG52YXIgcmVxdWVzdEhvc3RUaW1lb3V0O1xudmFyIGNhbmNlbEhvc3RUaW1lb3V0O1xudmFyIHJlcXVlc3RQYWludDtcbnZhciBoYXNQZXJmb3JtYW5jZU5vdyA9IHR5cGVvZiBwZXJmb3JtYW5jZSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIHBlcmZvcm1hbmNlLm5vdyA9PT0gJ2Z1bmN0aW9uJztcblxuaWYgKGhhc1BlcmZvcm1hbmNlTm93KSB7XG4gIHZhciBsb2NhbFBlcmZvcm1hbmNlID0gcGVyZm9ybWFuY2U7XG5cbiAgZXhwb3J0cy51bnN0YWJsZV9ub3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGxvY2FsUGVyZm9ybWFuY2Uubm93KCk7XG4gIH07XG59IGVsc2Uge1xuICB2YXIgbG9jYWxEYXRlID0gRGF0ZTtcbiAgdmFyIGluaXRpYWxUaW1lID0gbG9jYWxEYXRlLm5vdygpO1xuXG4gIGV4cG9ydHMudW5zdGFibGVfbm93ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBsb2NhbERhdGUubm93KCkgLSBpbml0aWFsVGltZTtcbiAgfTtcbn1cblxuaWYgKCAvLyBJZiBTY2hlZHVsZXIgcnVucyBpbiBhIG5vbi1ET00gZW52aXJvbm1lbnQsIGl0IGZhbGxzIGJhY2sgdG8gYSBuYWl2ZVxuLy8gaW1wbGVtZW50YXRpb24gdXNpbmcgc2V0VGltZW91dC5cbnR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnIHx8IC8vIENoZWNrIGlmIE1lc3NhZ2VDaGFubmVsIGlzIHN1cHBvcnRlZCwgdG9vLlxudHlwZW9mIE1lc3NhZ2VDaGFubmVsICE9PSAnZnVuY3Rpb24nKSB7XG4gIC8vIElmIHRoaXMgYWNjaWRlbnRhbGx5IGdldHMgaW1wb3J0ZWQgaW4gYSBub24tYnJvd3NlciBlbnZpcm9ubWVudCwgZS5nLiBKYXZhU2NyaXB0Q29yZSxcbiAgLy8gZmFsbGJhY2sgdG8gYSBuYWl2ZSBpbXBsZW1lbnRhdGlvbi5cbiAgdmFyIF9jYWxsYmFjayA9IG51bGw7XG4gIHZhciBfdGltZW91dElEID0gbnVsbDtcblxuICB2YXIgX2ZsdXNoQ2FsbGJhY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKF9jYWxsYmFjayAhPT0gbnVsbCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIGN1cnJlbnRUaW1lID0gZXhwb3J0cy51bnN0YWJsZV9ub3coKTtcbiAgICAgICAgdmFyIGhhc1JlbWFpbmluZ1RpbWUgPSB0cnVlO1xuXG4gICAgICAgIF9jYWxsYmFjayhoYXNSZW1haW5pbmdUaW1lLCBjdXJyZW50VGltZSk7XG5cbiAgICAgICAgX2NhbGxiYWNrID0gbnVsbDtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgc2V0VGltZW91dChfZmx1c2hDYWxsYmFjaywgMCk7XG4gICAgICAgIHRocm93IGU7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIHJlcXVlc3RIb3N0Q2FsbGJhY2sgPSBmdW5jdGlvbiAoY2IpIHtcbiAgICBpZiAoX2NhbGxiYWNrICE9PSBudWxsKSB7XG4gICAgICAvLyBQcm90ZWN0IGFnYWluc3QgcmUtZW50cmFuY3kuXG4gICAgICBzZXRUaW1lb3V0KHJlcXVlc3RIb3N0Q2FsbGJhY2ssIDAsIGNiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgX2NhbGxiYWNrID0gY2I7XG4gICAgICBzZXRUaW1lb3V0KF9mbHVzaENhbGxiYWNrLCAwKTtcbiAgICB9XG4gIH07XG5cbiAgcmVxdWVzdEhvc3RUaW1lb3V0ID0gZnVuY3Rpb24gKGNiLCBtcykge1xuICAgIF90aW1lb3V0SUQgPSBzZXRUaW1lb3V0KGNiLCBtcyk7XG4gIH07XG5cbiAgY2FuY2VsSG9zdFRpbWVvdXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgY2xlYXJUaW1lb3V0KF90aW1lb3V0SUQpO1xuICB9O1xuXG4gIGV4cG9ydHMudW5zdGFibGVfc2hvdWxkWWllbGQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuXG4gIHJlcXVlc3RQYWludCA9IGV4cG9ydHMudW5zdGFibGVfZm9yY2VGcmFtZVJhdGUgPSBmdW5jdGlvbiAoKSB7fTtcbn0gZWxzZSB7XG4gIC8vIENhcHR1cmUgbG9jYWwgcmVmZXJlbmNlcyB0byBuYXRpdmUgQVBJcywgaW4gY2FzZSBhIHBvbHlmaWxsIG92ZXJyaWRlcyB0aGVtLlxuICB2YXIgX3NldFRpbWVvdXQgPSB3aW5kb3cuc2V0VGltZW91dDtcbiAgdmFyIF9jbGVhclRpbWVvdXQgPSB3aW5kb3cuY2xlYXJUaW1lb3V0O1xuXG4gIGlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAvLyBUT0RPOiBTY2hlZHVsZXIgbm8gbG9uZ2VyIHJlcXVpcmVzIHRoZXNlIG1ldGhvZHMgdG8gYmUgcG9seWZpbGxlZC4gQnV0XG4gICAgLy8gbWF5YmUgd2Ugd2FudCB0byBjb250aW51ZSB3YXJuaW5nIGlmIHRoZXkgZG9uJ3QgZXhpc3QsIHRvIHByZXNlcnZlIHRoZVxuICAgIC8vIG9wdGlvbiB0byByZWx5IG9uIGl0IGluIHRoZSBmdXR1cmU/XG4gICAgdmFyIHJlcXVlc3RBbmltYXRpb25GcmFtZSA9IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWU7XG4gICAgdmFyIGNhbmNlbEFuaW1hdGlvbkZyYW1lID0gd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lO1xuXG4gICAgaWYgKHR5cGVvZiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIC8vIFVzaW5nIGNvbnNvbGVbJ2Vycm9yJ10gdG8gZXZhZGUgQmFiZWwgYW5kIEVTTGludFxuICAgICAgY29uc29sZVsnZXJyb3InXShcIlRoaXMgYnJvd3NlciBkb2Vzbid0IHN1cHBvcnQgcmVxdWVzdEFuaW1hdGlvbkZyYW1lLiBcIiArICdNYWtlIHN1cmUgdGhhdCB5b3UgbG9hZCBhICcgKyAncG9seWZpbGwgaW4gb2xkZXIgYnJvd3NlcnMuIGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9yZWFjdC1wb2x5ZmlsbHMnKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGNhbmNlbEFuaW1hdGlvbkZyYW1lICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAvLyBVc2luZyBjb25zb2xlWydlcnJvciddIHRvIGV2YWRlIEJhYmVsIGFuZCBFU0xpbnRcbiAgICAgIGNvbnNvbGVbJ2Vycm9yJ10oXCJUaGlzIGJyb3dzZXIgZG9lc24ndCBzdXBwb3J0IGNhbmNlbEFuaW1hdGlvbkZyYW1lLiBcIiArICdNYWtlIHN1cmUgdGhhdCB5b3UgbG9hZCBhICcgKyAncG9seWZpbGwgaW4gb2xkZXIgYnJvd3NlcnMuIGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9yZWFjdC1wb2x5ZmlsbHMnKTtcbiAgICB9XG4gIH1cblxuICB2YXIgaXNNZXNzYWdlTG9vcFJ1bm5pbmcgPSBmYWxzZTtcbiAgdmFyIHNjaGVkdWxlZEhvc3RDYWxsYmFjayA9IG51bGw7XG4gIHZhciB0YXNrVGltZW91dElEID0gLTE7IC8vIFNjaGVkdWxlciBwZXJpb2RpY2FsbHkgeWllbGRzIGluIGNhc2UgdGhlcmUgaXMgb3RoZXIgd29yayBvbiB0aGUgbWFpblxuICAvLyB0aHJlYWQsIGxpa2UgdXNlciBldmVudHMuIEJ5IGRlZmF1bHQsIGl0IHlpZWxkcyBtdWx0aXBsZSB0aW1lcyBwZXIgZnJhbWUuXG4gIC8vIEl0IGRvZXMgbm90IGF0dGVtcHQgdG8gYWxpZ24gd2l0aCBmcmFtZSBib3VuZGFyaWVzLCBzaW5jZSBtb3N0IHRhc2tzIGRvbid0XG4gIC8vIG5lZWQgdG8gYmUgZnJhbWUgYWxpZ25lZDsgZm9yIHRob3NlIHRoYXQgZG8sIHVzZSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUuXG5cbiAgdmFyIHlpZWxkSW50ZXJ2YWwgPSA1O1xuICB2YXIgZGVhZGxpbmUgPSAwOyAvLyBUT0RPOiBNYWtlIHRoaXMgY29uZmlndXJhYmxlXG5cbiAge1xuICAgIC8vIGBpc0lucHV0UGVuZGluZ2AgaXMgbm90IGF2YWlsYWJsZS4gU2luY2Ugd2UgaGF2ZSBubyB3YXkgb2Yga25vd2luZyBpZlxuICAgIC8vIHRoZXJlJ3MgcGVuZGluZyBpbnB1dCwgYWx3YXlzIHlpZWxkIGF0IHRoZSBlbmQgb2YgdGhlIGZyYW1lLlxuICAgIGV4cG9ydHMudW5zdGFibGVfc2hvdWxkWWllbGQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gZXhwb3J0cy51bnN0YWJsZV9ub3coKSA+PSBkZWFkbGluZTtcbiAgICB9OyAvLyBTaW5jZSB3ZSB5aWVsZCBldmVyeSBmcmFtZSByZWdhcmRsZXNzLCBgcmVxdWVzdFBhaW50YCBoYXMgbm8gZWZmZWN0LlxuXG5cbiAgICByZXF1ZXN0UGFpbnQgPSBmdW5jdGlvbiAoKSB7fTtcbiAgfVxuXG4gIGV4cG9ydHMudW5zdGFibGVfZm9yY2VGcmFtZVJhdGUgPSBmdW5jdGlvbiAoZnBzKSB7XG4gICAgaWYgKGZwcyA8IDAgfHwgZnBzID4gMTI1KSB7XG4gICAgICAvLyBVc2luZyBjb25zb2xlWydlcnJvciddIHRvIGV2YWRlIEJhYmVsIGFuZCBFU0xpbnRcbiAgICAgIGNvbnNvbGVbJ2Vycm9yJ10oJ2ZvcmNlRnJhbWVSYXRlIHRha2VzIGEgcG9zaXRpdmUgaW50IGJldHdlZW4gMCBhbmQgMTI1LCAnICsgJ2ZvcmNpbmcgZnJhbWUgcmF0ZXMgaGlnaGVyIHRoYW4gMTI1IGZwcyBpcyBub3Qgc3VwcG9ydGVkJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGZwcyA+IDApIHtcbiAgICAgIHlpZWxkSW50ZXJ2YWwgPSBNYXRoLmZsb29yKDEwMDAgLyBmcHMpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyByZXNldCB0aGUgZnJhbWVyYXRlXG4gICAgICB5aWVsZEludGVydmFsID0gNTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIHBlcmZvcm1Xb3JrVW50aWxEZWFkbGluZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoc2NoZWR1bGVkSG9zdENhbGxiYWNrICE9PSBudWxsKSB7XG4gICAgICB2YXIgY3VycmVudFRpbWUgPSBleHBvcnRzLnVuc3RhYmxlX25vdygpOyAvLyBZaWVsZCBhZnRlciBgeWllbGRJbnRlcnZhbGAgbXMsIHJlZ2FyZGxlc3Mgb2Ygd2hlcmUgd2UgYXJlIGluIHRoZSB2c3luY1xuICAgICAgLy8gY3ljbGUuIFRoaXMgbWVhbnMgdGhlcmUncyBhbHdheXMgdGltZSByZW1haW5pbmcgYXQgdGhlIGJlZ2lubmluZyBvZlxuICAgICAgLy8gdGhlIG1lc3NhZ2UgZXZlbnQuXG5cbiAgICAgIGRlYWRsaW5lID0gY3VycmVudFRpbWUgKyB5aWVsZEludGVydmFsO1xuICAgICAgdmFyIGhhc1RpbWVSZW1haW5pbmcgPSB0cnVlO1xuXG4gICAgICB0cnkge1xuICAgICAgICB2YXIgaGFzTW9yZVdvcmsgPSBzY2hlZHVsZWRIb3N0Q2FsbGJhY2soaGFzVGltZVJlbWFpbmluZywgY3VycmVudFRpbWUpO1xuXG4gICAgICAgIGlmICghaGFzTW9yZVdvcmspIHtcbiAgICAgICAgICBpc01lc3NhZ2VMb29wUnVubmluZyA9IGZhbHNlO1xuICAgICAgICAgIHNjaGVkdWxlZEhvc3RDYWxsYmFjayA9IG51bGw7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gSWYgdGhlcmUncyBtb3JlIHdvcmssIHNjaGVkdWxlIHRoZSBuZXh0IG1lc3NhZ2UgZXZlbnQgYXQgdGhlIGVuZFxuICAgICAgICAgIC8vIG9mIHRoZSBwcmVjZWRpbmcgb25lLlxuICAgICAgICAgIHBvcnQucG9zdE1lc3NhZ2UobnVsbCk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIC8vIElmIGEgc2NoZWR1bGVyIHRhc2sgdGhyb3dzLCBleGl0IHRoZSBjdXJyZW50IGJyb3dzZXIgdGFzayBzbyB0aGVcbiAgICAgICAgLy8gZXJyb3IgY2FuIGJlIG9ic2VydmVkLlxuICAgICAgICBwb3J0LnBvc3RNZXNzYWdlKG51bGwpO1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaXNNZXNzYWdlTG9vcFJ1bm5pbmcgPSBmYWxzZTtcbiAgICB9IC8vIFlpZWxkaW5nIHRvIHRoZSBicm93c2VyIHdpbGwgZ2l2ZSBpdCBhIGNoYW5jZSB0byBwYWludCwgc28gd2UgY2FuXG4gIH07XG5cbiAgdmFyIGNoYW5uZWwgPSBuZXcgTWVzc2FnZUNoYW5uZWwoKTtcbiAgdmFyIHBvcnQgPSBjaGFubmVsLnBvcnQyO1xuICBjaGFubmVsLnBvcnQxLm9ubWVzc2FnZSA9IHBlcmZvcm1Xb3JrVW50aWxEZWFkbGluZTtcblxuICByZXF1ZXN0SG9zdENhbGxiYWNrID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgc2NoZWR1bGVkSG9zdENhbGxiYWNrID0gY2FsbGJhY2s7XG5cbiAgICBpZiAoIWlzTWVzc2FnZUxvb3BSdW5uaW5nKSB7XG4gICAgICBpc01lc3NhZ2VMb29wUnVubmluZyA9IHRydWU7XG4gICAgICBwb3J0LnBvc3RNZXNzYWdlKG51bGwpO1xuICAgIH1cbiAgfTtcblxuICByZXF1ZXN0SG9zdFRpbWVvdXQgPSBmdW5jdGlvbiAoY2FsbGJhY2ssIG1zKSB7XG4gICAgdGFza1RpbWVvdXRJRCA9IF9zZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIGNhbGxiYWNrKGV4cG9ydHMudW5zdGFibGVfbm93KCkpO1xuICAgIH0sIG1zKTtcbiAgfTtcblxuICBjYW5jZWxIb3N0VGltZW91dCA9IGZ1bmN0aW9uICgpIHtcbiAgICBfY2xlYXJUaW1lb3V0KHRhc2tUaW1lb3V0SUQpO1xuXG4gICAgdGFza1RpbWVvdXRJRCA9IC0xO1xuICB9O1xufVxuXG5mdW5jdGlvbiBwdXNoKGhlYXAsIG5vZGUpIHtcbiAgdmFyIGluZGV4ID0gaGVhcC5sZW5ndGg7XG4gIGhlYXAucHVzaChub2RlKTtcbiAgc2lmdFVwKGhlYXAsIG5vZGUsIGluZGV4KTtcbn1cbmZ1bmN0aW9uIHBlZWsoaGVhcCkge1xuICB2YXIgZmlyc3QgPSBoZWFwWzBdO1xuICByZXR1cm4gZmlyc3QgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBmaXJzdDtcbn1cbmZ1bmN0aW9uIHBvcChoZWFwKSB7XG4gIHZhciBmaXJzdCA9IGhlYXBbMF07XG5cbiAgaWYgKGZpcnN0ICE9PSB1bmRlZmluZWQpIHtcbiAgICB2YXIgbGFzdCA9IGhlYXAucG9wKCk7XG5cbiAgICBpZiAobGFzdCAhPT0gZmlyc3QpIHtcbiAgICAgIGhlYXBbMF0gPSBsYXN0O1xuICAgICAgc2lmdERvd24oaGVhcCwgbGFzdCwgMCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZpcnN0O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbmZ1bmN0aW9uIHNpZnRVcChoZWFwLCBub2RlLCBpKSB7XG4gIHZhciBpbmRleCA9IGk7XG5cbiAgd2hpbGUgKHRydWUpIHtcbiAgICB2YXIgcGFyZW50SW5kZXggPSBpbmRleCAtIDEgPj4+IDE7XG4gICAgdmFyIHBhcmVudCA9IGhlYXBbcGFyZW50SW5kZXhdO1xuXG4gICAgaWYgKHBhcmVudCAhPT0gdW5kZWZpbmVkICYmIGNvbXBhcmUocGFyZW50LCBub2RlKSA+IDApIHtcbiAgICAgIC8vIFRoZSBwYXJlbnQgaXMgbGFyZ2VyLiBTd2FwIHBvc2l0aW9ucy5cbiAgICAgIGhlYXBbcGFyZW50SW5kZXhdID0gbm9kZTtcbiAgICAgIGhlYXBbaW5kZXhdID0gcGFyZW50O1xuICAgICAgaW5kZXggPSBwYXJlbnRJbmRleDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVGhlIHBhcmVudCBpcyBzbWFsbGVyLiBFeGl0LlxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBzaWZ0RG93bihoZWFwLCBub2RlLCBpKSB7XG4gIHZhciBpbmRleCA9IGk7XG4gIHZhciBsZW5ndGggPSBoZWFwLmxlbmd0aDtcblxuICB3aGlsZSAoaW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgbGVmdEluZGV4ID0gKGluZGV4ICsgMSkgKiAyIC0gMTtcbiAgICB2YXIgbGVmdCA9IGhlYXBbbGVmdEluZGV4XTtcbiAgICB2YXIgcmlnaHRJbmRleCA9IGxlZnRJbmRleCArIDE7XG4gICAgdmFyIHJpZ2h0ID0gaGVhcFtyaWdodEluZGV4XTsgLy8gSWYgdGhlIGxlZnQgb3IgcmlnaHQgbm9kZSBpcyBzbWFsbGVyLCBzd2FwIHdpdGggdGhlIHNtYWxsZXIgb2YgdGhvc2UuXG5cbiAgICBpZiAobGVmdCAhPT0gdW5kZWZpbmVkICYmIGNvbXBhcmUobGVmdCwgbm9kZSkgPCAwKSB7XG4gICAgICBpZiAocmlnaHQgIT09IHVuZGVmaW5lZCAmJiBjb21wYXJlKHJpZ2h0LCBsZWZ0KSA8IDApIHtcbiAgICAgICAgaGVhcFtpbmRleF0gPSByaWdodDtcbiAgICAgICAgaGVhcFtyaWdodEluZGV4XSA9IG5vZGU7XG4gICAgICAgIGluZGV4ID0gcmlnaHRJbmRleDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGhlYXBbaW5kZXhdID0gbGVmdDtcbiAgICAgICAgaGVhcFtsZWZ0SW5kZXhdID0gbm9kZTtcbiAgICAgICAgaW5kZXggPSBsZWZ0SW5kZXg7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChyaWdodCAhPT0gdW5kZWZpbmVkICYmIGNvbXBhcmUocmlnaHQsIG5vZGUpIDwgMCkge1xuICAgICAgaGVhcFtpbmRleF0gPSByaWdodDtcbiAgICAgIGhlYXBbcmlnaHRJbmRleF0gPSBub2RlO1xuICAgICAgaW5kZXggPSByaWdodEluZGV4O1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBOZWl0aGVyIGNoaWxkIGlzIHNtYWxsZXIuIEV4aXQuXG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNvbXBhcmUoYSwgYikge1xuICAvLyBDb21wYXJlIHNvcnQgaW5kZXggZmlyc3QsIHRoZW4gdGFzayBpZC5cbiAgdmFyIGRpZmYgPSBhLnNvcnRJbmRleCAtIGIuc29ydEluZGV4O1xuICByZXR1cm4gZGlmZiAhPT0gMCA/IGRpZmYgOiBhLmlkIC0gYi5pZDtcbn1cblxuLy8gVE9ETzogVXNlIHN5bWJvbHM/XG52YXIgSW1tZWRpYXRlUHJpb3JpdHkgPSAxO1xudmFyIFVzZXJCbG9ja2luZ1ByaW9yaXR5ID0gMjtcbnZhciBOb3JtYWxQcmlvcml0eSA9IDM7XG52YXIgTG93UHJpb3JpdHkgPSA0O1xudmFyIElkbGVQcmlvcml0eSA9IDU7XG5cbmZ1bmN0aW9uIG1hcmtUYXNrRXJyb3JlZCh0YXNrLCBtcykge1xufVxuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby12YXIgKi9cbi8vIE1hdGgucG93KDIsIDMwKSAtIDFcbi8vIDBiMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExXG5cbnZhciBtYXhTaWduZWQzMUJpdEludCA9IDEwNzM3NDE4MjM7IC8vIFRpbWVzIG91dCBpbW1lZGlhdGVseVxuXG52YXIgSU1NRURJQVRFX1BSSU9SSVRZX1RJTUVPVVQgPSAtMTsgLy8gRXZlbnR1YWxseSB0aW1lcyBvdXRcblxudmFyIFVTRVJfQkxPQ0tJTkdfUFJJT1JJVFlfVElNRU9VVCA9IDI1MDtcbnZhciBOT1JNQUxfUFJJT1JJVFlfVElNRU9VVCA9IDUwMDA7XG52YXIgTE9XX1BSSU9SSVRZX1RJTUVPVVQgPSAxMDAwMDsgLy8gTmV2ZXIgdGltZXMgb3V0XG5cbnZhciBJRExFX1BSSU9SSVRZX1RJTUVPVVQgPSBtYXhTaWduZWQzMUJpdEludDsgLy8gVGFza3MgYXJlIHN0b3JlZCBvbiBhIG1pbiBoZWFwXG5cbnZhciB0YXNrUXVldWUgPSBbXTtcbnZhciB0aW1lclF1ZXVlID0gW107IC8vIEluY3JlbWVudGluZyBpZCBjb3VudGVyLiBVc2VkIHRvIG1haW50YWluIGluc2VydGlvbiBvcmRlci5cblxudmFyIHRhc2tJZENvdW50ZXIgPSAxOyAvLyBQYXVzaW5nIHRoZSBzY2hlZHVsZXIgaXMgdXNlZnVsIGZvciBkZWJ1Z2dpbmcuXG52YXIgY3VycmVudFRhc2sgPSBudWxsO1xudmFyIGN1cnJlbnRQcmlvcml0eUxldmVsID0gTm9ybWFsUHJpb3JpdHk7IC8vIFRoaXMgaXMgc2V0IHdoaWxlIHBlcmZvcm1pbmcgd29yaywgdG8gcHJldmVudCByZS1lbnRyYW5jeS5cblxudmFyIGlzUGVyZm9ybWluZ1dvcmsgPSBmYWxzZTtcbnZhciBpc0hvc3RDYWxsYmFja1NjaGVkdWxlZCA9IGZhbHNlO1xudmFyIGlzSG9zdFRpbWVvdXRTY2hlZHVsZWQgPSBmYWxzZTtcblxuZnVuY3Rpb24gYWR2YW5jZVRpbWVycyhjdXJyZW50VGltZSkge1xuICAvLyBDaGVjayBmb3IgdGFza3MgdGhhdCBhcmUgbm8gbG9uZ2VyIGRlbGF5ZWQgYW5kIGFkZCB0aGVtIHRvIHRoZSBxdWV1ZS5cbiAgdmFyIHRpbWVyID0gcGVlayh0aW1lclF1ZXVlKTtcblxuICB3aGlsZSAodGltZXIgIT09IG51bGwpIHtcbiAgICBpZiAodGltZXIuY2FsbGJhY2sgPT09IG51bGwpIHtcbiAgICAgIC8vIFRpbWVyIHdhcyBjYW5jZWxsZWQuXG4gICAgICBwb3AodGltZXJRdWV1ZSk7XG4gICAgfSBlbHNlIGlmICh0aW1lci5zdGFydFRpbWUgPD0gY3VycmVudFRpbWUpIHtcbiAgICAgIC8vIFRpbWVyIGZpcmVkLiBUcmFuc2ZlciB0byB0aGUgdGFzayBxdWV1ZS5cbiAgICAgIHBvcCh0aW1lclF1ZXVlKTtcbiAgICAgIHRpbWVyLnNvcnRJbmRleCA9IHRpbWVyLmV4cGlyYXRpb25UaW1lO1xuICAgICAgcHVzaCh0YXNrUXVldWUsIHRpbWVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gUmVtYWluaW5nIHRpbWVycyBhcmUgcGVuZGluZy5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aW1lciA9IHBlZWsodGltZXJRdWV1ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaGFuZGxlVGltZW91dChjdXJyZW50VGltZSkge1xuICBpc0hvc3RUaW1lb3V0U2NoZWR1bGVkID0gZmFsc2U7XG4gIGFkdmFuY2VUaW1lcnMoY3VycmVudFRpbWUpO1xuXG4gIGlmICghaXNIb3N0Q2FsbGJhY2tTY2hlZHVsZWQpIHtcbiAgICBpZiAocGVlayh0YXNrUXVldWUpICE9PSBudWxsKSB7XG4gICAgICBpc0hvc3RDYWxsYmFja1NjaGVkdWxlZCA9IHRydWU7XG4gICAgICByZXF1ZXN0SG9zdENhbGxiYWNrKGZsdXNoV29yayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBmaXJzdFRpbWVyID0gcGVlayh0aW1lclF1ZXVlKTtcblxuICAgICAgaWYgKGZpcnN0VGltZXIgIT09IG51bGwpIHtcbiAgICAgICAgcmVxdWVzdEhvc3RUaW1lb3V0KGhhbmRsZVRpbWVvdXQsIGZpcnN0VGltZXIuc3RhcnRUaW1lIC0gY3VycmVudFRpbWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBmbHVzaFdvcmsoaGFzVGltZVJlbWFpbmluZywgaW5pdGlhbFRpbWUpIHtcblxuXG4gIGlzSG9zdENhbGxiYWNrU2NoZWR1bGVkID0gZmFsc2U7XG5cbiAgaWYgKGlzSG9zdFRpbWVvdXRTY2hlZHVsZWQpIHtcbiAgICAvLyBXZSBzY2hlZHVsZWQgYSB0aW1lb3V0IGJ1dCBpdCdzIG5vIGxvbmdlciBuZWVkZWQuIENhbmNlbCBpdC5cbiAgICBpc0hvc3RUaW1lb3V0U2NoZWR1bGVkID0gZmFsc2U7XG4gICAgY2FuY2VsSG9zdFRpbWVvdXQoKTtcbiAgfVxuXG4gIGlzUGVyZm9ybWluZ1dvcmsgPSB0cnVlO1xuICB2YXIgcHJldmlvdXNQcmlvcml0eUxldmVsID0gY3VycmVudFByaW9yaXR5TGV2ZWw7XG5cbiAgdHJ5IHtcbiAgICBpZiAoZW5hYmxlUHJvZmlsaW5nKSB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gd29ya0xvb3AoaGFzVGltZVJlbWFpbmluZywgaW5pdGlhbFRpbWUpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgaWYgKGN1cnJlbnRUYXNrICE9PSBudWxsKSB7XG4gICAgICAgICAgdmFyIGN1cnJlbnRUaW1lID0gZXhwb3J0cy51bnN0YWJsZV9ub3coKTtcbiAgICAgICAgICBtYXJrVGFza0Vycm9yZWQoY3VycmVudFRhc2ssIGN1cnJlbnRUaW1lKTtcbiAgICAgICAgICBjdXJyZW50VGFzay5pc1F1ZXVlZCA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIE5vIGNhdGNoIGluIHByb2QgY29kZSBwYXRoLlxuICAgICAgcmV0dXJuIHdvcmtMb29wKGhhc1RpbWVSZW1haW5pbmcsIGluaXRpYWxUaW1lKTtcbiAgICB9XG4gIH0gZmluYWxseSB7XG4gICAgY3VycmVudFRhc2sgPSBudWxsO1xuICAgIGN1cnJlbnRQcmlvcml0eUxldmVsID0gcHJldmlvdXNQcmlvcml0eUxldmVsO1xuICAgIGlzUGVyZm9ybWluZ1dvcmsgPSBmYWxzZTtcbiAgfVxufVxuXG5mdW5jdGlvbiB3b3JrTG9vcChoYXNUaW1lUmVtYWluaW5nLCBpbml0aWFsVGltZSkge1xuICB2YXIgY3VycmVudFRpbWUgPSBpbml0aWFsVGltZTtcbiAgYWR2YW5jZVRpbWVycyhjdXJyZW50VGltZSk7XG4gIGN1cnJlbnRUYXNrID0gcGVlayh0YXNrUXVldWUpO1xuXG4gIHdoaWxlIChjdXJyZW50VGFzayAhPT0gbnVsbCAmJiAhKGVuYWJsZVNjaGVkdWxlckRlYnVnZ2luZyApKSB7XG4gICAgaWYgKGN1cnJlbnRUYXNrLmV4cGlyYXRpb25UaW1lID4gY3VycmVudFRpbWUgJiYgKCFoYXNUaW1lUmVtYWluaW5nIHx8IGV4cG9ydHMudW5zdGFibGVfc2hvdWxkWWllbGQoKSkpIHtcbiAgICAgIC8vIFRoaXMgY3VycmVudFRhc2sgaGFzbid0IGV4cGlyZWQsIGFuZCB3ZSd2ZSByZWFjaGVkIHRoZSBkZWFkbGluZS5cbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHZhciBjYWxsYmFjayA9IGN1cnJlbnRUYXNrLmNhbGxiYWNrO1xuXG4gICAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY3VycmVudFRhc2suY2FsbGJhY2sgPSBudWxsO1xuICAgICAgY3VycmVudFByaW9yaXR5TGV2ZWwgPSBjdXJyZW50VGFzay5wcmlvcml0eUxldmVsO1xuICAgICAgdmFyIGRpZFVzZXJDYWxsYmFja1RpbWVvdXQgPSBjdXJyZW50VGFzay5leHBpcmF0aW9uVGltZSA8PSBjdXJyZW50VGltZTtcblxuICAgICAgdmFyIGNvbnRpbnVhdGlvbkNhbGxiYWNrID0gY2FsbGJhY2soZGlkVXNlckNhbGxiYWNrVGltZW91dCk7XG4gICAgICBjdXJyZW50VGltZSA9IGV4cG9ydHMudW5zdGFibGVfbm93KCk7XG5cbiAgICAgIGlmICh0eXBlb2YgY29udGludWF0aW9uQ2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgY3VycmVudFRhc2suY2FsbGJhY2sgPSBjb250aW51YXRpb25DYWxsYmFjaztcbiAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgaWYgKGN1cnJlbnRUYXNrID09PSBwZWVrKHRhc2tRdWV1ZSkpIHtcbiAgICAgICAgICBwb3AodGFza1F1ZXVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBhZHZhbmNlVGltZXJzKGN1cnJlbnRUaW1lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcG9wKHRhc2tRdWV1ZSk7XG4gICAgfVxuXG4gICAgY3VycmVudFRhc2sgPSBwZWVrKHRhc2tRdWV1ZSk7XG4gIH0gLy8gUmV0dXJuIHdoZXRoZXIgdGhlcmUncyBhZGRpdGlvbmFsIHdvcmtcblxuXG4gIGlmIChjdXJyZW50VGFzayAhPT0gbnVsbCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9IGVsc2Uge1xuICAgIHZhciBmaXJzdFRpbWVyID0gcGVlayh0aW1lclF1ZXVlKTtcblxuICAgIGlmIChmaXJzdFRpbWVyICE9PSBudWxsKSB7XG4gICAgICByZXF1ZXN0SG9zdFRpbWVvdXQoaGFuZGxlVGltZW91dCwgZmlyc3RUaW1lci5zdGFydFRpbWUgLSBjdXJyZW50VGltZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbmZ1bmN0aW9uIHVuc3RhYmxlX3J1bldpdGhQcmlvcml0eShwcmlvcml0eUxldmVsLCBldmVudEhhbmRsZXIpIHtcbiAgc3dpdGNoIChwcmlvcml0eUxldmVsKSB7XG4gICAgY2FzZSBJbW1lZGlhdGVQcmlvcml0eTpcbiAgICBjYXNlIFVzZXJCbG9ja2luZ1ByaW9yaXR5OlxuICAgIGNhc2UgTm9ybWFsUHJpb3JpdHk6XG4gICAgY2FzZSBMb3dQcmlvcml0eTpcbiAgICBjYXNlIElkbGVQcmlvcml0eTpcbiAgICAgIGJyZWFrO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHByaW9yaXR5TGV2ZWwgPSBOb3JtYWxQcmlvcml0eTtcbiAgfVxuXG4gIHZhciBwcmV2aW91c1ByaW9yaXR5TGV2ZWwgPSBjdXJyZW50UHJpb3JpdHlMZXZlbDtcbiAgY3VycmVudFByaW9yaXR5TGV2ZWwgPSBwcmlvcml0eUxldmVsO1xuXG4gIHRyeSB7XG4gICAgcmV0dXJuIGV2ZW50SGFuZGxlcigpO1xuICB9IGZpbmFsbHkge1xuICAgIGN1cnJlbnRQcmlvcml0eUxldmVsID0gcHJldmlvdXNQcmlvcml0eUxldmVsO1xuICB9XG59XG5cbmZ1bmN0aW9uIHVuc3RhYmxlX25leHQoZXZlbnRIYW5kbGVyKSB7XG4gIHZhciBwcmlvcml0eUxldmVsO1xuXG4gIHN3aXRjaCAoY3VycmVudFByaW9yaXR5TGV2ZWwpIHtcbiAgICBjYXNlIEltbWVkaWF0ZVByaW9yaXR5OlxuICAgIGNhc2UgVXNlckJsb2NraW5nUHJpb3JpdHk6XG4gICAgY2FzZSBOb3JtYWxQcmlvcml0eTpcbiAgICAgIC8vIFNoaWZ0IGRvd24gdG8gbm9ybWFsIHByaW9yaXR5XG4gICAgICBwcmlvcml0eUxldmVsID0gTm9ybWFsUHJpb3JpdHk7XG4gICAgICBicmVhaztcblxuICAgIGRlZmF1bHQ6XG4gICAgICAvLyBBbnl0aGluZyBsb3dlciB0aGFuIG5vcm1hbCBwcmlvcml0eSBzaG91bGQgcmVtYWluIGF0IHRoZSBjdXJyZW50IGxldmVsLlxuICAgICAgcHJpb3JpdHlMZXZlbCA9IGN1cnJlbnRQcmlvcml0eUxldmVsO1xuICAgICAgYnJlYWs7XG4gIH1cblxuICB2YXIgcHJldmlvdXNQcmlvcml0eUxldmVsID0gY3VycmVudFByaW9yaXR5TGV2ZWw7XG4gIGN1cnJlbnRQcmlvcml0eUxldmVsID0gcHJpb3JpdHlMZXZlbDtcblxuICB0cnkge1xuICAgIHJldHVybiBldmVudEhhbmRsZXIoKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBjdXJyZW50UHJpb3JpdHlMZXZlbCA9IHByZXZpb3VzUHJpb3JpdHlMZXZlbDtcbiAgfVxufVxuXG5mdW5jdGlvbiB1bnN0YWJsZV93cmFwQ2FsbGJhY2soY2FsbGJhY2spIHtcbiAgdmFyIHBhcmVudFByaW9yaXR5TGV2ZWwgPSBjdXJyZW50UHJpb3JpdHlMZXZlbDtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAvLyBUaGlzIGlzIGEgZm9yayBvZiBydW5XaXRoUHJpb3JpdHksIGlubGluZWQgZm9yIHBlcmZvcm1hbmNlLlxuICAgIHZhciBwcmV2aW91c1ByaW9yaXR5TGV2ZWwgPSBjdXJyZW50UHJpb3JpdHlMZXZlbDtcbiAgICBjdXJyZW50UHJpb3JpdHlMZXZlbCA9IHBhcmVudFByaW9yaXR5TGV2ZWw7XG5cbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGNhbGxiYWNrLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGN1cnJlbnRQcmlvcml0eUxldmVsID0gcHJldmlvdXNQcmlvcml0eUxldmVsO1xuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gdW5zdGFibGVfc2NoZWR1bGVDYWxsYmFjayhwcmlvcml0eUxldmVsLCBjYWxsYmFjaywgb3B0aW9ucykge1xuICB2YXIgY3VycmVudFRpbWUgPSBleHBvcnRzLnVuc3RhYmxlX25vdygpO1xuICB2YXIgc3RhcnRUaW1lO1xuXG4gIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ29iamVjdCcgJiYgb3B0aW9ucyAhPT0gbnVsbCkge1xuICAgIHZhciBkZWxheSA9IG9wdGlvbnMuZGVsYXk7XG5cbiAgICBpZiAodHlwZW9mIGRlbGF5ID09PSAnbnVtYmVyJyAmJiBkZWxheSA+IDApIHtcbiAgICAgIHN0YXJ0VGltZSA9IGN1cnJlbnRUaW1lICsgZGVsYXk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXJ0VGltZSA9IGN1cnJlbnRUaW1lO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBzdGFydFRpbWUgPSBjdXJyZW50VGltZTtcbiAgfVxuXG4gIHZhciB0aW1lb3V0O1xuXG4gIHN3aXRjaCAocHJpb3JpdHlMZXZlbCkge1xuICAgIGNhc2UgSW1tZWRpYXRlUHJpb3JpdHk6XG4gICAgICB0aW1lb3V0ID0gSU1NRURJQVRFX1BSSU9SSVRZX1RJTUVPVVQ7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgVXNlckJsb2NraW5nUHJpb3JpdHk6XG4gICAgICB0aW1lb3V0ID0gVVNFUl9CTE9DS0lOR19QUklPUklUWV9USU1FT1VUO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIElkbGVQcmlvcml0eTpcbiAgICAgIHRpbWVvdXQgPSBJRExFX1BSSU9SSVRZX1RJTUVPVVQ7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgTG93UHJpb3JpdHk6XG4gICAgICB0aW1lb3V0ID0gTE9XX1BSSU9SSVRZX1RJTUVPVVQ7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgTm9ybWFsUHJpb3JpdHk6XG4gICAgZGVmYXVsdDpcbiAgICAgIHRpbWVvdXQgPSBOT1JNQUxfUFJJT1JJVFlfVElNRU9VVDtcbiAgICAgIGJyZWFrO1xuICB9XG5cbiAgdmFyIGV4cGlyYXRpb25UaW1lID0gc3RhcnRUaW1lICsgdGltZW91dDtcbiAgdmFyIG5ld1Rhc2sgPSB7XG4gICAgaWQ6IHRhc2tJZENvdW50ZXIrKyxcbiAgICBjYWxsYmFjazogY2FsbGJhY2ssXG4gICAgcHJpb3JpdHlMZXZlbDogcHJpb3JpdHlMZXZlbCxcbiAgICBzdGFydFRpbWU6IHN0YXJ0VGltZSxcbiAgICBleHBpcmF0aW9uVGltZTogZXhwaXJhdGlvblRpbWUsXG4gICAgc29ydEluZGV4OiAtMVxuICB9O1xuXG4gIGlmIChzdGFydFRpbWUgPiBjdXJyZW50VGltZSkge1xuICAgIC8vIFRoaXMgaXMgYSBkZWxheWVkIHRhc2suXG4gICAgbmV3VGFzay5zb3J0SW5kZXggPSBzdGFydFRpbWU7XG4gICAgcHVzaCh0aW1lclF1ZXVlLCBuZXdUYXNrKTtcblxuICAgIGlmIChwZWVrKHRhc2tRdWV1ZSkgPT09IG51bGwgJiYgbmV3VGFzayA9PT0gcGVlayh0aW1lclF1ZXVlKSkge1xuICAgICAgLy8gQWxsIHRhc2tzIGFyZSBkZWxheWVkLCBhbmQgdGhpcyBpcyB0aGUgdGFzayB3aXRoIHRoZSBlYXJsaWVzdCBkZWxheS5cbiAgICAgIGlmIChpc0hvc3RUaW1lb3V0U2NoZWR1bGVkKSB7XG4gICAgICAgIC8vIENhbmNlbCBhbiBleGlzdGluZyB0aW1lb3V0LlxuICAgICAgICBjYW5jZWxIb3N0VGltZW91dCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaXNIb3N0VGltZW91dFNjaGVkdWxlZCA9IHRydWU7XG4gICAgICB9IC8vIFNjaGVkdWxlIGEgdGltZW91dC5cblxuXG4gICAgICByZXF1ZXN0SG9zdFRpbWVvdXQoaGFuZGxlVGltZW91dCwgc3RhcnRUaW1lIC0gY3VycmVudFRpbWUpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBuZXdUYXNrLnNvcnRJbmRleCA9IGV4cGlyYXRpb25UaW1lO1xuICAgIHB1c2godGFza1F1ZXVlLCBuZXdUYXNrKTtcbiAgICAvLyB3YWl0IHVudGlsIHRoZSBuZXh0IHRpbWUgd2UgeWllbGQuXG5cblxuICAgIGlmICghaXNIb3N0Q2FsbGJhY2tTY2hlZHVsZWQgJiYgIWlzUGVyZm9ybWluZ1dvcmspIHtcbiAgICAgIGlzSG9zdENhbGxiYWNrU2NoZWR1bGVkID0gdHJ1ZTtcbiAgICAgIHJlcXVlc3RIb3N0Q2FsbGJhY2soZmx1c2hXb3JrKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmV3VGFzaztcbn1cblxuZnVuY3Rpb24gdW5zdGFibGVfcGF1c2VFeGVjdXRpb24oKSB7XG59XG5cbmZ1bmN0aW9uIHVuc3RhYmxlX2NvbnRpbnVlRXhlY3V0aW9uKCkge1xuXG4gIGlmICghaXNIb3N0Q2FsbGJhY2tTY2hlZHVsZWQgJiYgIWlzUGVyZm9ybWluZ1dvcmspIHtcbiAgICBpc0hvc3RDYWxsYmFja1NjaGVkdWxlZCA9IHRydWU7XG4gICAgcmVxdWVzdEhvc3RDYWxsYmFjayhmbHVzaFdvcmspO1xuICB9XG59XG5cbmZ1bmN0aW9uIHVuc3RhYmxlX2dldEZpcnN0Q2FsbGJhY2tOb2RlKCkge1xuICByZXR1cm4gcGVlayh0YXNrUXVldWUpO1xufVxuXG5mdW5jdGlvbiB1bnN0YWJsZV9jYW5jZWxDYWxsYmFjayh0YXNrKSB7XG4gIC8vIHJlbW92ZSBmcm9tIHRoZSBxdWV1ZSBiZWNhdXNlIHlvdSBjYW4ndCByZW1vdmUgYXJiaXRyYXJ5IG5vZGVzIGZyb20gYW5cbiAgLy8gYXJyYXkgYmFzZWQgaGVhcCwgb25seSB0aGUgZmlyc3Qgb25lLilcblxuXG4gIHRhc2suY2FsbGJhY2sgPSBudWxsO1xufVxuXG5mdW5jdGlvbiB1bnN0YWJsZV9nZXRDdXJyZW50UHJpb3JpdHlMZXZlbCgpIHtcbiAgcmV0dXJuIGN1cnJlbnRQcmlvcml0eUxldmVsO1xufVxuXG52YXIgdW5zdGFibGVfcmVxdWVzdFBhaW50ID0gcmVxdWVzdFBhaW50O1xudmFyIHVuc3RhYmxlX1Byb2ZpbGluZyA9ICBudWxsO1xuXG5leHBvcnRzLnVuc3RhYmxlX0lkbGVQcmlvcml0eSA9IElkbGVQcmlvcml0eTtcbmV4cG9ydHMudW5zdGFibGVfSW1tZWRpYXRlUHJpb3JpdHkgPSBJbW1lZGlhdGVQcmlvcml0eTtcbmV4cG9ydHMudW5zdGFibGVfTG93UHJpb3JpdHkgPSBMb3dQcmlvcml0eTtcbmV4cG9ydHMudW5zdGFibGVfTm9ybWFsUHJpb3JpdHkgPSBOb3JtYWxQcmlvcml0eTtcbmV4cG9ydHMudW5zdGFibGVfUHJvZmlsaW5nID0gdW5zdGFibGVfUHJvZmlsaW5nO1xuZXhwb3J0cy51bnN0YWJsZV9Vc2VyQmxvY2tpbmdQcmlvcml0eSA9IFVzZXJCbG9ja2luZ1ByaW9yaXR5O1xuZXhwb3J0cy51bnN0YWJsZV9jYW5jZWxDYWxsYmFjayA9IHVuc3RhYmxlX2NhbmNlbENhbGxiYWNrO1xuZXhwb3J0cy51bnN0YWJsZV9jb250aW51ZUV4ZWN1dGlvbiA9IHVuc3RhYmxlX2NvbnRpbnVlRXhlY3V0aW9uO1xuZXhwb3J0cy51bnN0YWJsZV9nZXRDdXJyZW50UHJpb3JpdHlMZXZlbCA9IHVuc3RhYmxlX2dldEN1cnJlbnRQcmlvcml0eUxldmVsO1xuZXhwb3J0cy51bnN0YWJsZV9nZXRGaXJzdENhbGxiYWNrTm9kZSA9IHVuc3RhYmxlX2dldEZpcnN0Q2FsbGJhY2tOb2RlO1xuZXhwb3J0cy51bnN0YWJsZV9uZXh0ID0gdW5zdGFibGVfbmV4dDtcbmV4cG9ydHMudW5zdGFibGVfcGF1c2VFeGVjdXRpb24gPSB1bnN0YWJsZV9wYXVzZUV4ZWN1dGlvbjtcbmV4cG9ydHMudW5zdGFibGVfcmVxdWVzdFBhaW50ID0gdW5zdGFibGVfcmVxdWVzdFBhaW50O1xuZXhwb3J0cy51bnN0YWJsZV9ydW5XaXRoUHJpb3JpdHkgPSB1bnN0YWJsZV9ydW5XaXRoUHJpb3JpdHk7XG5leHBvcnRzLnVuc3RhYmxlX3NjaGVkdWxlQ2FsbGJhY2sgPSB1bnN0YWJsZV9zY2hlZHVsZUNhbGxiYWNrO1xuZXhwb3J0cy51bnN0YWJsZV93cmFwQ2FsbGJhY2sgPSB1bnN0YWJsZV93cmFwQ2FsbGJhY2s7XG4gIH0pKCk7XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvc2NoZWR1bGVyLnByb2R1Y3Rpb24ubWluLmpzJyk7XG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3NjaGVkdWxlci5kZXZlbG9wbWVudC5qcycpO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJykge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3NjaGVkdWxlci10cmFjaW5nLnByb2R1Y3Rpb24ubWluLmpzJyk7XG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3NjaGVkdWxlci10cmFjaW5nLmRldmVsb3BtZW50LmpzJyk7XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIGlzT2xkSUUgPSBmdW5jdGlvbiBpc09sZElFKCkge1xuICB2YXIgbWVtbztcbiAgcmV0dXJuIGZ1bmN0aW9uIG1lbW9yaXplKCkge1xuICAgIGlmICh0eXBlb2YgbWVtbyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIC8vIFRlc3QgZm9yIElFIDw9IDkgYXMgcHJvcG9zZWQgYnkgQnJvd3NlcmhhY2tzXG4gICAgICAvLyBAc2VlIGh0dHA6Ly9icm93c2VyaGFja3MuY29tLyNoYWNrLWU3MWQ4NjkyZjY1MzM0MTczZmVlNzE1YzIyMmNiODA1XG4gICAgICAvLyBUZXN0cyBmb3IgZXhpc3RlbmNlIG9mIHN0YW5kYXJkIGdsb2JhbHMgaXMgdG8gYWxsb3cgc3R5bGUtbG9hZGVyXG4gICAgICAvLyB0byBvcGVyYXRlIGNvcnJlY3RseSBpbnRvIG5vbi1zdGFuZGFyZCBlbnZpcm9ubWVudHNcbiAgICAgIC8vIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3dlYnBhY2stY29udHJpYi9zdHlsZS1sb2FkZXIvaXNzdWVzLzE3N1xuICAgICAgbWVtbyA9IEJvb2xlYW4od2luZG93ICYmIGRvY3VtZW50ICYmIGRvY3VtZW50LmFsbCAmJiAhd2luZG93LmF0b2IpO1xuICAgIH1cblxuICAgIHJldHVybiBtZW1vO1xuICB9O1xufSgpO1xuXG52YXIgZ2V0VGFyZ2V0ID0gZnVuY3Rpb24gZ2V0VGFyZ2V0KCkge1xuICB2YXIgbWVtbyA9IHt9O1xuICByZXR1cm4gZnVuY3Rpb24gbWVtb3JpemUodGFyZ2V0KSB7XG4gICAgaWYgKHR5cGVvZiBtZW1vW3RhcmdldF0gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB2YXIgc3R5bGVUYXJnZXQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHRhcmdldCk7IC8vIFNwZWNpYWwgY2FzZSB0byByZXR1cm4gaGVhZCBvZiBpZnJhbWUgaW5zdGVhZCBvZiBpZnJhbWUgaXRzZWxmXG5cbiAgICAgIGlmICh3aW5kb3cuSFRNTElGcmFtZUVsZW1lbnQgJiYgc3R5bGVUYXJnZXQgaW5zdGFuY2VvZiB3aW5kb3cuSFRNTElGcmFtZUVsZW1lbnQpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyBUaGlzIHdpbGwgdGhyb3cgYW4gZXhjZXB0aW9uIGlmIGFjY2VzcyB0byBpZnJhbWUgaXMgYmxvY2tlZFxuICAgICAgICAgIC8vIGR1ZSB0byBjcm9zcy1vcmlnaW4gcmVzdHJpY3Rpb25zXG4gICAgICAgICAgc3R5bGVUYXJnZXQgPSBzdHlsZVRhcmdldC5jb250ZW50RG9jdW1lbnQuaGVhZDtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIC8vIGlzdGFuYnVsIGlnbm9yZSBuZXh0XG4gICAgICAgICAgc3R5bGVUYXJnZXQgPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIG1lbW9bdGFyZ2V0XSA9IHN0eWxlVGFyZ2V0O1xuICAgIH1cblxuICAgIHJldHVybiBtZW1vW3RhcmdldF07XG4gIH07XG59KCk7XG5cbnZhciBzdHlsZXNJbkRvbSA9IFtdO1xuXG5mdW5jdGlvbiBnZXRJbmRleEJ5SWRlbnRpZmllcihpZGVudGlmaWVyKSB7XG4gIHZhciByZXN1bHQgPSAtMTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0eWxlc0luRG9tLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKHN0eWxlc0luRG9tW2ldLmlkZW50aWZpZXIgPT09IGlkZW50aWZpZXIpIHtcbiAgICAgIHJlc3VsdCA9IGk7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBtb2R1bGVzVG9Eb20obGlzdCwgb3B0aW9ucykge1xuICB2YXIgaWRDb3VudE1hcCA9IHt9O1xuICB2YXIgaWRlbnRpZmllcnMgPSBbXTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgaXRlbSA9IGxpc3RbaV07XG4gICAgdmFyIGlkID0gb3B0aW9ucy5iYXNlID8gaXRlbVswXSArIG9wdGlvbnMuYmFzZSA6IGl0ZW1bMF07XG4gICAgdmFyIGNvdW50ID0gaWRDb3VudE1hcFtpZF0gfHwgMDtcbiAgICB2YXIgaWRlbnRpZmllciA9IFwiXCIuY29uY2F0KGlkLCBcIiBcIikuY29uY2F0KGNvdW50KTtcbiAgICBpZENvdW50TWFwW2lkXSA9IGNvdW50ICsgMTtcbiAgICB2YXIgaW5kZXggPSBnZXRJbmRleEJ5SWRlbnRpZmllcihpZGVudGlmaWVyKTtcbiAgICB2YXIgb2JqID0ge1xuICAgICAgY3NzOiBpdGVtWzFdLFxuICAgICAgbWVkaWE6IGl0ZW1bMl0sXG4gICAgICBzb3VyY2VNYXA6IGl0ZW1bM11cbiAgICB9O1xuXG4gICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgc3R5bGVzSW5Eb21baW5kZXhdLnJlZmVyZW5jZXMrKztcbiAgICAgIHN0eWxlc0luRG9tW2luZGV4XS51cGRhdGVyKG9iaik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0eWxlc0luRG9tLnB1c2goe1xuICAgICAgICBpZGVudGlmaWVyOiBpZGVudGlmaWVyLFxuICAgICAgICB1cGRhdGVyOiBhZGRTdHlsZShvYmosIG9wdGlvbnMpLFxuICAgICAgICByZWZlcmVuY2VzOiAxXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZGVudGlmaWVycy5wdXNoKGlkZW50aWZpZXIpO1xuICB9XG5cbiAgcmV0dXJuIGlkZW50aWZpZXJzO1xufVxuXG5mdW5jdGlvbiBpbnNlcnRTdHlsZUVsZW1lbnQob3B0aW9ucykge1xuICB2YXIgc3R5bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHlsZScpO1xuICB2YXIgYXR0cmlidXRlcyA9IG9wdGlvbnMuYXR0cmlidXRlcyB8fCB7fTtcblxuICBpZiAodHlwZW9mIGF0dHJpYnV0ZXMubm9uY2UgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgdmFyIG5vbmNlID0gdHlwZW9mIF9fd2VicGFja19ub25jZV9fICE9PSAndW5kZWZpbmVkJyA/IF9fd2VicGFja19ub25jZV9fIDogbnVsbDtcblxuICAgIGlmIChub25jZSkge1xuICAgICAgYXR0cmlidXRlcy5ub25jZSA9IG5vbmNlO1xuICAgIH1cbiAgfVxuXG4gIE9iamVjdC5rZXlzKGF0dHJpYnV0ZXMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgIHN0eWxlLnNldEF0dHJpYnV0ZShrZXksIGF0dHJpYnV0ZXNba2V5XSk7XG4gIH0pO1xuXG4gIGlmICh0eXBlb2Ygb3B0aW9ucy5pbnNlcnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICBvcHRpb25zLmluc2VydChzdHlsZSk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIHRhcmdldCA9IGdldFRhcmdldChvcHRpb25zLmluc2VydCB8fCAnaGVhZCcpO1xuXG4gICAgaWYgKCF0YXJnZXQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvdWxkbid0IGZpbmQgYSBzdHlsZSB0YXJnZXQuIFRoaXMgcHJvYmFibHkgbWVhbnMgdGhhdCB0aGUgdmFsdWUgZm9yIHRoZSAnaW5zZXJ0JyBwYXJhbWV0ZXIgaXMgaW52YWxpZC5cIik7XG4gICAgfVxuXG4gICAgdGFyZ2V0LmFwcGVuZENoaWxkKHN0eWxlKTtcbiAgfVxuXG4gIHJldHVybiBzdHlsZTtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlU3R5bGVFbGVtZW50KHN0eWxlKSB7XG4gIC8vIGlzdGFuYnVsIGlnbm9yZSBpZlxuICBpZiAoc3R5bGUucGFyZW50Tm9kZSA9PT0gbnVsbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHN0eWxlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc3R5bGUpO1xufVxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgICovXG5cblxudmFyIHJlcGxhY2VUZXh0ID0gZnVuY3Rpb24gcmVwbGFjZVRleHQoKSB7XG4gIHZhciB0ZXh0U3RvcmUgPSBbXTtcbiAgcmV0dXJuIGZ1bmN0aW9uIHJlcGxhY2UoaW5kZXgsIHJlcGxhY2VtZW50KSB7XG4gICAgdGV4dFN0b3JlW2luZGV4XSA9IHJlcGxhY2VtZW50O1xuICAgIHJldHVybiB0ZXh0U3RvcmUuZmlsdGVyKEJvb2xlYW4pLmpvaW4oJ1xcbicpO1xuICB9O1xufSgpO1xuXG5mdW5jdGlvbiBhcHBseVRvU2luZ2xldG9uVGFnKHN0eWxlLCBpbmRleCwgcmVtb3ZlLCBvYmopIHtcbiAgdmFyIGNzcyA9IHJlbW92ZSA/ICcnIDogb2JqLm1lZGlhID8gXCJAbWVkaWEgXCIuY29uY2F0KG9iai5tZWRpYSwgXCIge1wiKS5jb25jYXQob2JqLmNzcywgXCJ9XCIpIDogb2JqLmNzczsgLy8gRm9yIG9sZCBJRVxuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAgKi9cblxuICBpZiAoc3R5bGUuc3R5bGVTaGVldCkge1xuICAgIHN0eWxlLnN0eWxlU2hlZXQuY3NzVGV4dCA9IHJlcGxhY2VUZXh0KGluZGV4LCBjc3MpO1xuICB9IGVsc2Uge1xuICAgIHZhciBjc3NOb2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKTtcbiAgICB2YXIgY2hpbGROb2RlcyA9IHN0eWxlLmNoaWxkTm9kZXM7XG5cbiAgICBpZiAoY2hpbGROb2Rlc1tpbmRleF0pIHtcbiAgICAgIHN0eWxlLnJlbW92ZUNoaWxkKGNoaWxkTm9kZXNbaW5kZXhdKTtcbiAgICB9XG5cbiAgICBpZiAoY2hpbGROb2Rlcy5sZW5ndGgpIHtcbiAgICAgIHN0eWxlLmluc2VydEJlZm9yZShjc3NOb2RlLCBjaGlsZE5vZGVzW2luZGV4XSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0eWxlLmFwcGVuZENoaWxkKGNzc05vZGUpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBhcHBseVRvVGFnKHN0eWxlLCBvcHRpb25zLCBvYmopIHtcbiAgdmFyIGNzcyA9IG9iai5jc3M7XG4gIHZhciBtZWRpYSA9IG9iai5tZWRpYTtcbiAgdmFyIHNvdXJjZU1hcCA9IG9iai5zb3VyY2VNYXA7XG5cbiAgaWYgKG1lZGlhKSB7XG4gICAgc3R5bGUuc2V0QXR0cmlidXRlKCdtZWRpYScsIG1lZGlhKTtcbiAgfSBlbHNlIHtcbiAgICBzdHlsZS5yZW1vdmVBdHRyaWJ1dGUoJ21lZGlhJyk7XG4gIH1cblxuICBpZiAoc291cmNlTWFwICYmIHR5cGVvZiBidG9hICE9PSAndW5kZWZpbmVkJykge1xuICAgIGNzcyArPSBcIlxcbi8qIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsXCIuY29uY2F0KGJ0b2EodW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KEpTT04uc3RyaW5naWZ5KHNvdXJjZU1hcCkpKSksIFwiICovXCIpO1xuICB9IC8vIEZvciBvbGQgSUVcblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgICovXG5cblxuICBpZiAoc3R5bGUuc3R5bGVTaGVldCkge1xuICAgIHN0eWxlLnN0eWxlU2hlZXQuY3NzVGV4dCA9IGNzcztcbiAgfSBlbHNlIHtcbiAgICB3aGlsZSAoc3R5bGUuZmlyc3RDaGlsZCkge1xuICAgICAgc3R5bGUucmVtb3ZlQ2hpbGQoc3R5bGUuZmlyc3RDaGlsZCk7XG4gICAgfVxuXG4gICAgc3R5bGUuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKSk7XG4gIH1cbn1cblxudmFyIHNpbmdsZXRvbiA9IG51bGw7XG52YXIgc2luZ2xldG9uQ291bnRlciA9IDA7XG5cbmZ1bmN0aW9uIGFkZFN0eWxlKG9iaiwgb3B0aW9ucykge1xuICB2YXIgc3R5bGU7XG4gIHZhciB1cGRhdGU7XG4gIHZhciByZW1vdmU7XG5cbiAgaWYgKG9wdGlvbnMuc2luZ2xldG9uKSB7XG4gICAgdmFyIHN0eWxlSW5kZXggPSBzaW5nbGV0b25Db3VudGVyKys7XG4gICAgc3R5bGUgPSBzaW5nbGV0b24gfHwgKHNpbmdsZXRvbiA9IGluc2VydFN0eWxlRWxlbWVudChvcHRpb25zKSk7XG4gICAgdXBkYXRlID0gYXBwbHlUb1NpbmdsZXRvblRhZy5iaW5kKG51bGwsIHN0eWxlLCBzdHlsZUluZGV4LCBmYWxzZSk7XG4gICAgcmVtb3ZlID0gYXBwbHlUb1NpbmdsZXRvblRhZy5iaW5kKG51bGwsIHN0eWxlLCBzdHlsZUluZGV4LCB0cnVlKTtcbiAgfSBlbHNlIHtcbiAgICBzdHlsZSA9IGluc2VydFN0eWxlRWxlbWVudChvcHRpb25zKTtcbiAgICB1cGRhdGUgPSBhcHBseVRvVGFnLmJpbmQobnVsbCwgc3R5bGUsIG9wdGlvbnMpO1xuXG4gICAgcmVtb3ZlID0gZnVuY3Rpb24gcmVtb3ZlKCkge1xuICAgICAgcmVtb3ZlU3R5bGVFbGVtZW50KHN0eWxlKTtcbiAgICB9O1xuICB9XG5cbiAgdXBkYXRlKG9iaik7XG4gIHJldHVybiBmdW5jdGlvbiB1cGRhdGVTdHlsZShuZXdPYmopIHtcbiAgICBpZiAobmV3T2JqKSB7XG4gICAgICBpZiAobmV3T2JqLmNzcyA9PT0gb2JqLmNzcyAmJiBuZXdPYmoubWVkaWEgPT09IG9iai5tZWRpYSAmJiBuZXdPYmouc291cmNlTWFwID09PSBvYmouc291cmNlTWFwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdXBkYXRlKG9iaiA9IG5ld09iaik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlbW92ZSgpO1xuICAgIH1cbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAobGlzdCwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTsgLy8gRm9yY2Ugc2luZ2xlLXRhZyBzb2x1dGlvbiBvbiBJRTYtOSwgd2hpY2ggaGFzIGEgaGFyZCBsaW1pdCBvbiB0aGUgIyBvZiA8c3R5bGU+XG4gIC8vIHRhZ3MgaXQgd2lsbCBhbGxvdyBvbiBhIHBhZ2VcblxuICBpZiAoIW9wdGlvbnMuc2luZ2xldG9uICYmIHR5cGVvZiBvcHRpb25zLnNpbmdsZXRvbiAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgb3B0aW9ucy5zaW5nbGV0b24gPSBpc09sZElFKCk7XG4gIH1cblxuICBsaXN0ID0gbGlzdCB8fCBbXTtcbiAgdmFyIGxhc3RJZGVudGlmaWVycyA9IG1vZHVsZXNUb0RvbShsaXN0LCBvcHRpb25zKTtcbiAgcmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZShuZXdMaXN0KSB7XG4gICAgbmV3TGlzdCA9IG5ld0xpc3QgfHwgW107XG5cbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG5ld0xpc3QpICE9PSAnW29iamVjdCBBcnJheV0nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsYXN0SWRlbnRpZmllcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBpZGVudGlmaWVyID0gbGFzdElkZW50aWZpZXJzW2ldO1xuICAgICAgdmFyIGluZGV4ID0gZ2V0SW5kZXhCeUlkZW50aWZpZXIoaWRlbnRpZmllcik7XG4gICAgICBzdHlsZXNJbkRvbVtpbmRleF0ucmVmZXJlbmNlcy0tO1xuICAgIH1cblxuICAgIHZhciBuZXdMYXN0SWRlbnRpZmllcnMgPSBtb2R1bGVzVG9Eb20obmV3TGlzdCwgb3B0aW9ucyk7XG5cbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgbGFzdElkZW50aWZpZXJzLmxlbmd0aDsgX2krKykge1xuICAgICAgdmFyIF9pZGVudGlmaWVyID0gbGFzdElkZW50aWZpZXJzW19pXTtcblxuICAgICAgdmFyIF9pbmRleCA9IGdldEluZGV4QnlJZGVudGlmaWVyKF9pZGVudGlmaWVyKTtcblxuICAgICAgaWYgKHN0eWxlc0luRG9tW19pbmRleF0ucmVmZXJlbmNlcyA9PT0gMCkge1xuICAgICAgICBzdHlsZXNJbkRvbVtfaW5kZXhdLnVwZGF0ZXIoKTtcblxuICAgICAgICBzdHlsZXNJbkRvbS5zcGxpY2UoX2luZGV4LCAxKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBsYXN0SWRlbnRpZmllcnMgPSBuZXdMYXN0SWRlbnRpZmllcnM7XG4gIH07XG59OyIsIid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxuZnVuY3Rpb24gdXNlQXN5bmNFZmZlY3QoZWZmZWN0LCBkZXN0cm95LCBpbnB1dHMpIHtcbiAgdmFyIGhhc0Rlc3Ryb3kgPSB0eXBlb2YgZGVzdHJveSA9PT0gJ2Z1bmN0aW9uJztcblxuICBSZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIHZhciByZXN1bHQ7XG4gICAgdmFyIG1vdW50ZWQgPSB0cnVlO1xuICAgIHZhciBtYXliZVByb21pc2UgPSBlZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIG1vdW50ZWQ7XG4gICAgfSk7XG5cbiAgICBQcm9taXNlLnJlc29sdmUobWF5YmVQcm9taXNlKS50aGVuKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgcmVzdWx0ID0gdmFsdWU7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgbW91bnRlZCA9IGZhbHNlO1xuXG4gICAgICBpZiAoaGFzRGVzdHJveSkge1xuICAgICAgICBkZXN0cm95KHJlc3VsdCk7XG4gICAgICB9XG4gICAgfTtcbiAgfSwgaGFzRGVzdHJveSA/IGlucHV0cyA6IGRlc3Ryb3kpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHVzZUFzeW5jRWZmZWN0O1xubW9kdWxlLmV4cG9ydHMudXNlQXN5bmNFZmZlY3QgPSB1c2VBc3luY0VmZmVjdDtcbiIsInZhciBhcGkgPSByZXF1aXJlKFwiIS4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL2luamVjdFN0eWxlc0ludG9TdHlsZVRhZy5qc1wiKTtcbiAgICAgICAgICAgIHZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9janMuanM/P3J1bGVTZXRbMV0ucnVsZXNbMl0udXNlWzFdIS4uL25vZGVfbW9kdWxlcy9wb3N0Y3NzLWxvYWRlci9zcmMvaW5kZXguanM/P3J1bGVTZXRbMV0ucnVsZXNbMl0udXNlWzJdIS4vc3R5bGUuY3NzXCIpO1xuXG4gICAgICAgICAgICBjb250ZW50ID0gY29udGVudC5fX2VzTW9kdWxlID8gY29udGVudC5kZWZhdWx0IDogY29udGVudDtcblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG4gICAgICAgICAgICB9XG5cbnZhciBvcHRpb25zID0ge307XG5cbm9wdGlvbnMuaW5zZXJ0ID0gXCJoZWFkXCI7XG5vcHRpb25zLnNpbmdsZXRvbiA9IGZhbHNlO1xuXG52YXIgdXBkYXRlID0gYXBpKGNvbnRlbnQsIG9wdGlvbnMpO1xuXG5cblxubW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2FscyB8fCB7fTsiLCIvLyBUaGUgbW9kdWxlIGNhY2hlXG52YXIgX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fID0ge307XG5cbi8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG5mdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuXHR2YXIgY2FjaGVkTW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXTtcblx0aWYgKGNhY2hlZE1vZHVsZSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0cmV0dXJuIGNhY2hlZE1vZHVsZS5leHBvcnRzO1xuXHR9XG5cdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG5cdHZhciBtb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdID0ge1xuXHRcdGlkOiBtb2R1bGVJZCxcblx0XHQvLyBubyBtb2R1bGUubG9hZGVkIG5lZWRlZFxuXHRcdGV4cG9ydHM6IHt9XG5cdH07XG5cblx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG5cdF9fd2VicGFja19tb2R1bGVzX19bbW9kdWxlSWRdKG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG5cdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG5cdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbn1cblxuIiwiLy8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbl9fd2VicGFja19yZXF1aXJlX18ubiA9IChtb2R1bGUpID0+IHtcblx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG5cdFx0KCkgPT4gKG1vZHVsZVsnZGVmYXVsdCddKSA6XG5cdFx0KCkgPT4gKG1vZHVsZSk7XG5cdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsIHsgYTogZ2V0dGVyIH0pO1xuXHRyZXR1cm4gZ2V0dGVyO1xufTsiLCIvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9ucyBmb3IgaGFybW9ueSBleHBvcnRzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSAoZXhwb3J0cywgZGVmaW5pdGlvbikgPT4ge1xuXHRmb3IodmFyIGtleSBpbiBkZWZpbml0aW9uKSB7XG5cdFx0aWYoX193ZWJwYWNrX3JlcXVpcmVfXy5vKGRlZmluaXRpb24sIGtleSkgJiYgIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBrZXkpKSB7XG5cdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZGVmaW5pdGlvbltrZXldIH0pO1xuXHRcdH1cblx0fVxufTsiLCJfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSAob2JqLCBwcm9wKSA9PiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCkpIiwiLy8gZGVmaW5lIF9fZXNNb2R1bGUgb24gZXhwb3J0c1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yID0gKGV4cG9ydHMpID0+IHtcblx0aWYodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnKSB7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG5cdH1cblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbn07IiwiaW1wb3J0IHsgUmFpbndheVJ1bnRpbWUgfSBmcm9tIFwicmFpbndheS1zZGtcIjtcbmltcG9ydCBSZWFjdCwgeyB1c2VFZmZlY3QsIHVzZVJlZiwgdXNlU3RhdGUgfSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCBSZWFjdERPTSBmcm9tIFwicmVhY3QtZG9tXCI7XG5pbXBvcnQgXCIuLi9zdHlsZS5jc3NcIjtcbmltcG9ydCB1c2VBc3luY0VmZmVjdCBmcm9tIFwidXNlLWFzeW5jLWVmZmVjdFwiO1xuXG5jb25zdCBRdWlja0RlbW8gPSAoKSA9PiB7XG4gIGNvbnN0IFtydW50aW1lLCBzZXRSdW50aW1lXSA9IHVzZVN0YXRlPFJhaW53YXlSdW50aW1lIHwgdW5kZWZpbmVkPigpO1xuICBjb25zdCBbZXJyb3IsIHNldEVycm9yXSA9IHVzZVN0YXRlPHN0cmluZz4oXCJcIik7XG4gIHVzZUFzeW5jRWZmZWN0KGFzeW5jIChpc0FsaXZlKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJ0ID0gYXdhaXQgUmFpbndheVJ1bnRpbWUuaW5pdGlhbGl6ZSh7XG4gICAgICAgIGFwaUtleTpcbiAgICAgICAgICBuZXcgVVJMU2VhcmNoUGFyYW1zKHdpbmRvdy5sb2NhdGlvbi5zZWFyY2gpLmdldChcImFwaV9rZXlcIikgPz8gXCJcIixcbiAgICAgICAgZXh0ZXJuYWxJZDogXCJ3ZWItZGVtby1xdWlja1wiLFxuICAgICAgICBvblJ1bnRpbWVDb25uZWN0aW9uTG9zdDogKHJ0LCBlcnJvcikgPT4ge1xuICAgICAgICAgIHNldFJ1bnRpbWUodW5kZWZpbmVkKTtcbiAgICAgICAgfSxcbiAgICAgICAgb25Db25uZWN0aW9uUmVxdWVzdDogKHJ0LCByZXF1ZXN0KSA9PiB7XG4gICAgICAgICAgcmVxdWVzdC5hY2NlcHQoKTtcbiAgICAgICAgfSxcbiAgICAgICAgb25QZWVyTWVzc2FnZTogKCkgPT4ge30sXG4gICAgICAgIG9uUGVlckRhdGFDaGFubmVsOiAoKSA9PiB7fSxcbiAgICAgICAgb25QZWVyRXJyb3I6IChydCwgcGVlciwgZXJyb3IpID0+IHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oXCJvblBlZXJFcnJvclwiLCBwZWVyLCBlcnJvcik7XG4gICAgICAgIH0sXG4gICAgICAgIG9uUGVlclN0YXRlQ2hhbmdlOiAocnQsIHBlZXIsIHN0YXRlKSA9PiB7XG4gICAgICAgICAgY29uc29sZS5sb2coYFBlZXIgJHtwZWVyLnBlZXJJZH0gY2hhbmdlZCBzdGF0ZXMgdG8gJHtzdGF0ZX1gKTtcbiAgICAgICAgfSxcbiAgICAgICAgb25TdHJlYW1Bbm5vdW5jZW1lbnQ6ICgpID0+IHt9LFxuICAgICAgICBvblN0cmVhbVN0b3A6ICgpID0+IHt9LFxuICAgICAgICBsb2dTaW5rOiAoKSA9PiB7fSxcbiAgICAgIH0pO1xuICAgICAgaWYgKCFpc0FsaXZlKCkpIHJldHVybjtcbiAgICAgIHNldFJ1bnRpbWUocnQpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHNldEVycm9yKChlIGFzIEVycm9yKS5tZXNzYWdlKTtcbiAgICAgIGNvbnNvbGUubG9nKGUpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiAoXG4gICAgPG1haW4gY2xhc3NOYW1lPVwibS10LTggbS1sLTggbS1yLTggbS1iLThcIj5cbiAgICAgIHtlcnJvciA/IGVycm9yIDogcnVudGltZSA/IFwiQ29ubmVjdGVkLlwiIDogXCJDb25uZWN0aW5n4oCmXCJ9XG4gICAgPC9tYWluPlxuICApO1xufTtcblxuUmVhY3RET00ucmVuZGVyKFxuICA8UmVhY3QuU3RyaWN0TW9kZT5cbiAgICA8UXVpY2tEZW1vIC8+XG4gIDwvUmVhY3QuU3RyaWN0TW9kZT4sXG4gIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwicmVhY3Qtcm9vdFwiKSxcbik7XG4iXSwic291cmNlUm9vdCI6IiJ9